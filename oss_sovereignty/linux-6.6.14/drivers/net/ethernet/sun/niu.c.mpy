{
  "module_name": "niu.c",
  "hash_id": "90483814f288fea3fed268bab91a5cebf86caea9d0c3dfa195ba3f96abaa4091",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/sun/niu.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/dma-mapping.h>\n#include <linux/netdevice.h>\n#include <linux/ethtool.h>\n#include <linux/etherdevice.h>\n#include <linux/platform_device.h>\n#include <linux/delay.h>\n#include <linux/bitops.h>\n#include <linux/mii.h>\n#include <linux/if.h>\n#include <linux/if_ether.h>\n#include <linux/if_vlan.h>\n#include <linux/ip.h>\n#include <linux/in.h>\n#include <linux/ipv6.h>\n#include <linux/log2.h>\n#include <linux/jiffies.h>\n#include <linux/crc32.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n\n#include <linux/io.h>\n#include <linux/of.h>\n\n#include \"niu.h\"\n\n \nunion niu_page {\n\tstruct page page;\n\tstruct {\n\t\tunsigned long __flags;\t \n\t\tstruct list_head __lru;\t \n\t\tstruct page *next;\t \n\t};\n};\n#define niu_next_page(p)\tcontainer_of(p, union niu_page, page)->next\n\n#define DRV_MODULE_NAME\t\t\"niu\"\n#define DRV_MODULE_VERSION\t\"1.1\"\n#define DRV_MODULE_RELDATE\t\"Apr 22, 2010\"\n\nstatic char version[] =\n\tDRV_MODULE_NAME \".c:v\" DRV_MODULE_VERSION \" (\" DRV_MODULE_RELDATE \")\\n\";\n\nMODULE_AUTHOR(\"David S. Miller (davem@davemloft.net)\");\nMODULE_DESCRIPTION(\"NIU ethernet driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(DRV_MODULE_VERSION);\n\n#ifndef readq\nstatic u64 readq(void __iomem *reg)\n{\n\treturn ((u64) readl(reg)) | (((u64) readl(reg + 4UL)) << 32);\n}\n\nstatic void writeq(u64 val, void __iomem *reg)\n{\n\twritel(val & 0xffffffff, reg);\n\twritel(val >> 32, reg + 0x4UL);\n}\n#endif\n\nstatic const struct pci_device_id niu_pci_tbl[] = {\n\t{PCI_DEVICE(PCI_VENDOR_ID_SUN, 0xabcd)},\n\t{}\n};\n\nMODULE_DEVICE_TABLE(pci, niu_pci_tbl);\n\n#define NIU_TX_TIMEOUT\t\t\t(5 * HZ)\n\n#define nr64(reg)\t\treadq(np->regs + (reg))\n#define nw64(reg, val)\t\twriteq((val), np->regs + (reg))\n\n#define nr64_mac(reg)\t\treadq(np->mac_regs + (reg))\n#define nw64_mac(reg, val)\twriteq((val), np->mac_regs + (reg))\n\n#define nr64_ipp(reg)\t\treadq(np->regs + np->ipp_off + (reg))\n#define nw64_ipp(reg, val)\twriteq((val), np->regs + np->ipp_off + (reg))\n\n#define nr64_pcs(reg)\t\treadq(np->regs + np->pcs_off + (reg))\n#define nw64_pcs(reg, val)\twriteq((val), np->regs + np->pcs_off + (reg))\n\n#define nr64_xpcs(reg)\t\treadq(np->regs + np->xpcs_off + (reg))\n#define nw64_xpcs(reg, val)\twriteq((val), np->regs + np->xpcs_off + (reg))\n\n#define NIU_MSG_DEFAULT (NETIF_MSG_DRV | NETIF_MSG_PROBE | NETIF_MSG_LINK)\n\nstatic int niu_debug;\nstatic int debug = -1;\nmodule_param(debug, int, 0);\nMODULE_PARM_DESC(debug, \"NIU debug level\");\n\n#define niu_lock_parent(np, flags) \\\n\tspin_lock_irqsave(&np->parent->lock, flags)\n#define niu_unlock_parent(np, flags) \\\n\tspin_unlock_irqrestore(&np->parent->lock, flags)\n\nstatic int serdes_init_10g_serdes(struct niu *np);\n\nstatic int __niu_wait_bits_clear_mac(struct niu *np, unsigned long reg,\n\t\t\t\t     u64 bits, int limit, int delay)\n{\n\twhile (--limit >= 0) {\n\t\tu64 val = nr64_mac(reg);\n\n\t\tif (!(val & bits))\n\t\t\tbreak;\n\t\tudelay(delay);\n\t}\n\tif (limit < 0)\n\t\treturn -ENODEV;\n\treturn 0;\n}\n\nstatic int __niu_set_and_wait_clear_mac(struct niu *np, unsigned long reg,\n\t\t\t\t\tu64 bits, int limit, int delay,\n\t\t\t\t\tconst char *reg_name)\n{\n\tint err;\n\n\tnw64_mac(reg, bits);\n\terr = __niu_wait_bits_clear_mac(np, reg, bits, limit, delay);\n\tif (err)\n\t\tnetdev_err(np->dev, \"bits (%llx) of register %s would not clear, val[%llx]\\n\",\n\t\t\t   (unsigned long long)bits, reg_name,\n\t\t\t   (unsigned long long)nr64_mac(reg));\n\treturn err;\n}\n\n#define niu_set_and_wait_clear_mac(NP, REG, BITS, LIMIT, DELAY, REG_NAME) \\\n({\tBUILD_BUG_ON(LIMIT <= 0 || DELAY < 0); \\\n\t__niu_set_and_wait_clear_mac(NP, REG, BITS, LIMIT, DELAY, REG_NAME); \\\n})\n\nstatic int __niu_wait_bits_clear_ipp(struct niu *np, unsigned long reg,\n\t\t\t\t     u64 bits, int limit, int delay)\n{\n\twhile (--limit >= 0) {\n\t\tu64 val = nr64_ipp(reg);\n\n\t\tif (!(val & bits))\n\t\t\tbreak;\n\t\tudelay(delay);\n\t}\n\tif (limit < 0)\n\t\treturn -ENODEV;\n\treturn 0;\n}\n\nstatic int __niu_set_and_wait_clear_ipp(struct niu *np, unsigned long reg,\n\t\t\t\t\tu64 bits, int limit, int delay,\n\t\t\t\t\tconst char *reg_name)\n{\n\tint err;\n\tu64 val;\n\n\tval = nr64_ipp(reg);\n\tval |= bits;\n\tnw64_ipp(reg, val);\n\n\terr = __niu_wait_bits_clear_ipp(np, reg, bits, limit, delay);\n\tif (err)\n\t\tnetdev_err(np->dev, \"bits (%llx) of register %s would not clear, val[%llx]\\n\",\n\t\t\t   (unsigned long long)bits, reg_name,\n\t\t\t   (unsigned long long)nr64_ipp(reg));\n\treturn err;\n}\n\n#define niu_set_and_wait_clear_ipp(NP, REG, BITS, LIMIT, DELAY, REG_NAME) \\\n({\tBUILD_BUG_ON(LIMIT <= 0 || DELAY < 0); \\\n\t__niu_set_and_wait_clear_ipp(NP, REG, BITS, LIMIT, DELAY, REG_NAME); \\\n})\n\nstatic int __niu_wait_bits_clear(struct niu *np, unsigned long reg,\n\t\t\t\t u64 bits, int limit, int delay)\n{\n\twhile (--limit >= 0) {\n\t\tu64 val = nr64(reg);\n\n\t\tif (!(val & bits))\n\t\t\tbreak;\n\t\tudelay(delay);\n\t}\n\tif (limit < 0)\n\t\treturn -ENODEV;\n\treturn 0;\n}\n\n#define niu_wait_bits_clear(NP, REG, BITS, LIMIT, DELAY) \\\n({\tBUILD_BUG_ON(LIMIT <= 0 || DELAY < 0); \\\n\t__niu_wait_bits_clear(NP, REG, BITS, LIMIT, DELAY); \\\n})\n\nstatic int __niu_set_and_wait_clear(struct niu *np, unsigned long reg,\n\t\t\t\t    u64 bits, int limit, int delay,\n\t\t\t\t    const char *reg_name)\n{\n\tint err;\n\n\tnw64(reg, bits);\n\terr = __niu_wait_bits_clear(np, reg, bits, limit, delay);\n\tif (err)\n\t\tnetdev_err(np->dev, \"bits (%llx) of register %s would not clear, val[%llx]\\n\",\n\t\t\t   (unsigned long long)bits, reg_name,\n\t\t\t   (unsigned long long)nr64(reg));\n\treturn err;\n}\n\n#define niu_set_and_wait_clear(NP, REG, BITS, LIMIT, DELAY, REG_NAME) \\\n({\tBUILD_BUG_ON(LIMIT <= 0 || DELAY < 0); \\\n\t__niu_set_and_wait_clear(NP, REG, BITS, LIMIT, DELAY, REG_NAME); \\\n})\n\nstatic void niu_ldg_rearm(struct niu *np, struct niu_ldg *lp, int on)\n{\n\tu64 val = (u64) lp->timer;\n\n\tif (on)\n\t\tval |= LDG_IMGMT_ARM;\n\n\tnw64(LDG_IMGMT(lp->ldg_num), val);\n}\n\nstatic int niu_ldn_irq_enable(struct niu *np, int ldn, int on)\n{\n\tunsigned long mask_reg, bits;\n\tu64 val;\n\n\tif (ldn < 0 || ldn > LDN_MAX)\n\t\treturn -EINVAL;\n\n\tif (ldn < 64) {\n\t\tmask_reg = LD_IM0(ldn);\n\t\tbits = LD_IM0_MASK;\n\t} else {\n\t\tmask_reg = LD_IM1(ldn - 64);\n\t\tbits = LD_IM1_MASK;\n\t}\n\n\tval = nr64(mask_reg);\n\tif (on)\n\t\tval &= ~bits;\n\telse\n\t\tval |= bits;\n\tnw64(mask_reg, val);\n\n\treturn 0;\n}\n\nstatic int niu_enable_ldn_in_ldg(struct niu *np, struct niu_ldg *lp, int on)\n{\n\tstruct niu_parent *parent = np->parent;\n\tint i;\n\n\tfor (i = 0; i <= LDN_MAX; i++) {\n\t\tint err;\n\n\t\tif (parent->ldg_map[i] != lp->ldg_num)\n\t\t\tcontinue;\n\n\t\terr = niu_ldn_irq_enable(np, i, on);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n\nstatic int niu_enable_interrupts(struct niu *np, int on)\n{\n\tint i;\n\n\tfor (i = 0; i < np->num_ldg; i++) {\n\t\tstruct niu_ldg *lp = &np->ldg[i];\n\t\tint err;\n\n\t\terr = niu_enable_ldn_in_ldg(np, lp, on);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tfor (i = 0; i < np->num_ldg; i++)\n\t\tniu_ldg_rearm(np, &np->ldg[i], on);\n\n\treturn 0;\n}\n\nstatic u32 phy_encode(u32 type, int port)\n{\n\treturn type << (port * 2);\n}\n\nstatic u32 phy_decode(u32 val, int port)\n{\n\treturn (val >> (port * 2)) & PORT_TYPE_MASK;\n}\n\nstatic int mdio_wait(struct niu *np)\n{\n\tint limit = 1000;\n\tu64 val;\n\n\twhile (--limit > 0) {\n\t\tval = nr64(MIF_FRAME_OUTPUT);\n\t\tif ((val >> MIF_FRAME_OUTPUT_TA_SHIFT) & 0x1)\n\t\t\treturn val & MIF_FRAME_OUTPUT_DATA;\n\n\t\tudelay(10);\n\t}\n\n\treturn -ENODEV;\n}\n\nstatic int mdio_read(struct niu *np, int port, int dev, int reg)\n{\n\tint err;\n\n\tnw64(MIF_FRAME_OUTPUT, MDIO_ADDR_OP(port, dev, reg));\n\terr = mdio_wait(np);\n\tif (err < 0)\n\t\treturn err;\n\n\tnw64(MIF_FRAME_OUTPUT, MDIO_READ_OP(port, dev));\n\treturn mdio_wait(np);\n}\n\nstatic int mdio_write(struct niu *np, int port, int dev, int reg, int data)\n{\n\tint err;\n\n\tnw64(MIF_FRAME_OUTPUT, MDIO_ADDR_OP(port, dev, reg));\n\terr = mdio_wait(np);\n\tif (err < 0)\n\t\treturn err;\n\n\tnw64(MIF_FRAME_OUTPUT, MDIO_WRITE_OP(port, dev, data));\n\terr = mdio_wait(np);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic int mii_read(struct niu *np, int port, int reg)\n{\n\tnw64(MIF_FRAME_OUTPUT, MII_READ_OP(port, reg));\n\treturn mdio_wait(np);\n}\n\nstatic int mii_write(struct niu *np, int port, int reg, int data)\n{\n\tint err;\n\n\tnw64(MIF_FRAME_OUTPUT, MII_WRITE_OP(port, reg, data));\n\terr = mdio_wait(np);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic int esr2_set_tx_cfg(struct niu *np, unsigned long channel, u32 val)\n{\n\tint err;\n\n\terr = mdio_write(np, np->port, NIU_ESR2_DEV_ADDR,\n\t\t\t ESR2_TI_PLL_TX_CFG_L(channel),\n\t\t\t val & 0xffff);\n\tif (!err)\n\t\terr = mdio_write(np, np->port, NIU_ESR2_DEV_ADDR,\n\t\t\t\t ESR2_TI_PLL_TX_CFG_H(channel),\n\t\t\t\t val >> 16);\n\treturn err;\n}\n\nstatic int esr2_set_rx_cfg(struct niu *np, unsigned long channel, u32 val)\n{\n\tint err;\n\n\terr = mdio_write(np, np->port, NIU_ESR2_DEV_ADDR,\n\t\t\t ESR2_TI_PLL_RX_CFG_L(channel),\n\t\t\t val & 0xffff);\n\tif (!err)\n\t\terr = mdio_write(np, np->port, NIU_ESR2_DEV_ADDR,\n\t\t\t\t ESR2_TI_PLL_RX_CFG_H(channel),\n\t\t\t\t val >> 16);\n\treturn err;\n}\n\n \nstatic int serdes_init_niu_10g_fiber(struct niu *np)\n{\n\tstruct niu_link_config *lp = &np->link_config;\n\tu32 tx_cfg, rx_cfg;\n\tunsigned long i;\n\n\ttx_cfg = (PLL_TX_CFG_ENTX | PLL_TX_CFG_SWING_1375MV);\n\trx_cfg = (PLL_RX_CFG_ENRX | PLL_RX_CFG_TERM_0P8VDDT |\n\t\t  PLL_RX_CFG_ALIGN_ENA | PLL_RX_CFG_LOS_LTHRESH |\n\t\t  PLL_RX_CFG_EQ_LP_ADAPTIVE);\n\n\tif (lp->loopback_mode == LOOPBACK_PHY) {\n\t\tu16 test_cfg = PLL_TEST_CFG_LOOPBACK_CML_DIS;\n\n\t\tmdio_write(np, np->port, NIU_ESR2_DEV_ADDR,\n\t\t\t   ESR2_TI_PLL_TEST_CFG_L, test_cfg);\n\n\t\ttx_cfg |= PLL_TX_CFG_ENTEST;\n\t\trx_cfg |= PLL_RX_CFG_ENTEST;\n\t}\n\n\t \n\tfor (i = 0; i < 4; i++) {\n\t\tint err = esr2_set_tx_cfg(np, i, tx_cfg);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tfor (i = 0; i < 4; i++) {\n\t\tint err = esr2_set_rx_cfg(np, i, rx_cfg);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int serdes_init_niu_1g_serdes(struct niu *np)\n{\n\tstruct niu_link_config *lp = &np->link_config;\n\tu16 pll_cfg, pll_sts;\n\tint max_retry = 100;\n\tu64 sig, mask, val;\n\tu32 tx_cfg, rx_cfg;\n\tunsigned long i;\n\tint err;\n\n\ttx_cfg = (PLL_TX_CFG_ENTX | PLL_TX_CFG_SWING_1375MV |\n\t\t  PLL_TX_CFG_RATE_HALF);\n\trx_cfg = (PLL_RX_CFG_ENRX | PLL_RX_CFG_TERM_0P8VDDT |\n\t\t  PLL_RX_CFG_ALIGN_ENA | PLL_RX_CFG_LOS_LTHRESH |\n\t\t  PLL_RX_CFG_RATE_HALF);\n\n\tif (np->port == 0)\n\t\trx_cfg |= PLL_RX_CFG_EQ_LP_ADAPTIVE;\n\n\tif (lp->loopback_mode == LOOPBACK_PHY) {\n\t\tu16 test_cfg = PLL_TEST_CFG_LOOPBACK_CML_DIS;\n\n\t\tmdio_write(np, np->port, NIU_ESR2_DEV_ADDR,\n\t\t\t   ESR2_TI_PLL_TEST_CFG_L, test_cfg);\n\n\t\ttx_cfg |= PLL_TX_CFG_ENTEST;\n\t\trx_cfg |= PLL_RX_CFG_ENTEST;\n\t}\n\n\t \n\tpll_cfg = (PLL_CFG_ENPLL | PLL_CFG_MPY_8X);\n\n\terr = mdio_write(np, np->port, NIU_ESR2_DEV_ADDR,\n\t\t\t ESR2_TI_PLL_CFG_L, pll_cfg);\n\tif (err) {\n\t\tnetdev_err(np->dev, \"NIU Port %d %s() mdio write to ESR2_TI_PLL_CFG_L failed\\n\",\n\t\t\t   np->port, __func__);\n\t\treturn err;\n\t}\n\n\tpll_sts = PLL_CFG_ENPLL;\n\n\terr = mdio_write(np, np->port, NIU_ESR2_DEV_ADDR,\n\t\t\t ESR2_TI_PLL_STS_L, pll_sts);\n\tif (err) {\n\t\tnetdev_err(np->dev, \"NIU Port %d %s() mdio write to ESR2_TI_PLL_STS_L failed\\n\",\n\t\t\t   np->port, __func__);\n\t\treturn err;\n\t}\n\n\tudelay(200);\n\n\t \n\tfor (i = 0; i < 4; i++) {\n\t\terr = esr2_set_tx_cfg(np, i, tx_cfg);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tfor (i = 0; i < 4; i++) {\n\t\terr = esr2_set_rx_cfg(np, i, rx_cfg);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tswitch (np->port) {\n\tcase 0:\n\t\tval = (ESR_INT_SRDY0_P0 | ESR_INT_DET0_P0);\n\t\tmask = val;\n\t\tbreak;\n\n\tcase 1:\n\t\tval = (ESR_INT_SRDY0_P1 | ESR_INT_DET0_P1);\n\t\tmask = val;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\twhile (max_retry--) {\n\t\tsig = nr64(ESR_INT_SIGNALS);\n\t\tif ((sig & mask) == val)\n\t\t\tbreak;\n\n\t\tmdelay(500);\n\t}\n\n\tif ((sig & mask) != val) {\n\t\tnetdev_err(np->dev, \"Port %u signal bits [%08x] are not [%08x]\\n\",\n\t\t\t   np->port, (int)(sig & mask), (int)val);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic int serdes_init_niu_10g_serdes(struct niu *np)\n{\n\tstruct niu_link_config *lp = &np->link_config;\n\tu32 tx_cfg, rx_cfg, pll_cfg, pll_sts;\n\tint max_retry = 100;\n\tu64 sig, mask, val;\n\tunsigned long i;\n\tint err;\n\n\ttx_cfg = (PLL_TX_CFG_ENTX | PLL_TX_CFG_SWING_1375MV);\n\trx_cfg = (PLL_RX_CFG_ENRX | PLL_RX_CFG_TERM_0P8VDDT |\n\t\t  PLL_RX_CFG_ALIGN_ENA | PLL_RX_CFG_LOS_LTHRESH |\n\t\t  PLL_RX_CFG_EQ_LP_ADAPTIVE);\n\n\tif (lp->loopback_mode == LOOPBACK_PHY) {\n\t\tu16 test_cfg = PLL_TEST_CFG_LOOPBACK_CML_DIS;\n\n\t\tmdio_write(np, np->port, NIU_ESR2_DEV_ADDR,\n\t\t\t   ESR2_TI_PLL_TEST_CFG_L, test_cfg);\n\n\t\ttx_cfg |= PLL_TX_CFG_ENTEST;\n\t\trx_cfg |= PLL_RX_CFG_ENTEST;\n\t}\n\n\t \n\tpll_cfg = (PLL_CFG_ENPLL | PLL_CFG_MPY_10X);\n\n\terr = mdio_write(np, np->port, NIU_ESR2_DEV_ADDR,\n\t\t\t ESR2_TI_PLL_CFG_L, pll_cfg & 0xffff);\n\tif (err) {\n\t\tnetdev_err(np->dev, \"NIU Port %d %s() mdio write to ESR2_TI_PLL_CFG_L failed\\n\",\n\t\t\t   np->port, __func__);\n\t\treturn err;\n\t}\n\n\tpll_sts = PLL_CFG_ENPLL;\n\n\terr = mdio_write(np, np->port, NIU_ESR2_DEV_ADDR,\n\t\t\t ESR2_TI_PLL_STS_L, pll_sts & 0xffff);\n\tif (err) {\n\t\tnetdev_err(np->dev, \"NIU Port %d %s() mdio write to ESR2_TI_PLL_STS_L failed\\n\",\n\t\t\t   np->port, __func__);\n\t\treturn err;\n\t}\n\n\tudelay(200);\n\n\t \n\tfor (i = 0; i < 4; i++) {\n\t\terr = esr2_set_tx_cfg(np, i, tx_cfg);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tfor (i = 0; i < 4; i++) {\n\t\terr = esr2_set_rx_cfg(np, i, rx_cfg);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t \n\n\tswitch (np->port) {\n\tcase 0:\n\t\tmask = ESR_INT_SIGNALS_P0_BITS;\n\t\tval = (ESR_INT_SRDY0_P0 |\n\t\t       ESR_INT_DET0_P0 |\n\t\t       ESR_INT_XSRDY_P0 |\n\t\t       ESR_INT_XDP_P0_CH3 |\n\t\t       ESR_INT_XDP_P0_CH2 |\n\t\t       ESR_INT_XDP_P0_CH1 |\n\t\t       ESR_INT_XDP_P0_CH0);\n\t\tbreak;\n\n\tcase 1:\n\t\tmask = ESR_INT_SIGNALS_P1_BITS;\n\t\tval = (ESR_INT_SRDY0_P1 |\n\t\t       ESR_INT_DET0_P1 |\n\t\t       ESR_INT_XSRDY_P1 |\n\t\t       ESR_INT_XDP_P1_CH3 |\n\t\t       ESR_INT_XDP_P1_CH2 |\n\t\t       ESR_INT_XDP_P1_CH1 |\n\t\t       ESR_INT_XDP_P1_CH0);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\twhile (max_retry--) {\n\t\tsig = nr64(ESR_INT_SIGNALS);\n\t\tif ((sig & mask) == val)\n\t\t\tbreak;\n\n\t\tmdelay(500);\n\t}\n\n\tif ((sig & mask) != val) {\n\t\tpr_info(\"NIU Port %u signal bits [%08x] are not [%08x] for 10G...trying 1G\\n\",\n\t\t\tnp->port, (int)(sig & mask), (int)val);\n\n\t\t \n\t\terr = serdes_init_niu_1g_serdes(np);\n\t\tif (!err) {\n\t\t\tnp->flags &= ~NIU_FLAGS_10G;\n\t\t\tnp->mac_xcvr = MAC_XCVR_PCS;\n\t\t}  else {\n\t\t\tnetdev_err(np->dev, \"Port %u 10G/1G SERDES Link Failed\\n\",\n\t\t\t\t   np->port);\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int esr_read_rxtx_ctrl(struct niu *np, unsigned long chan, u32 *val)\n{\n\tint err;\n\n\terr = mdio_read(np, np->port, NIU_ESR_DEV_ADDR, ESR_RXTX_CTRL_L(chan));\n\tif (err >= 0) {\n\t\t*val = (err & 0xffff);\n\t\terr = mdio_read(np, np->port, NIU_ESR_DEV_ADDR,\n\t\t\t\tESR_RXTX_CTRL_H(chan));\n\t\tif (err >= 0)\n\t\t\t*val |= ((err & 0xffff) << 16);\n\t\terr = 0;\n\t}\n\treturn err;\n}\n\nstatic int esr_read_glue0(struct niu *np, unsigned long chan, u32 *val)\n{\n\tint err;\n\n\terr = mdio_read(np, np->port, NIU_ESR_DEV_ADDR,\n\t\t\tESR_GLUE_CTRL0_L(chan));\n\tif (err >= 0) {\n\t\t*val = (err & 0xffff);\n\t\terr = mdio_read(np, np->port, NIU_ESR_DEV_ADDR,\n\t\t\t\tESR_GLUE_CTRL0_H(chan));\n\t\tif (err >= 0) {\n\t\t\t*val |= ((err & 0xffff) << 16);\n\t\t\terr = 0;\n\t\t}\n\t}\n\treturn err;\n}\n\nstatic int esr_read_reset(struct niu *np, u32 *val)\n{\n\tint err;\n\n\terr = mdio_read(np, np->port, NIU_ESR_DEV_ADDR,\n\t\t\tESR_RXTX_RESET_CTRL_L);\n\tif (err >= 0) {\n\t\t*val = (err & 0xffff);\n\t\terr = mdio_read(np, np->port, NIU_ESR_DEV_ADDR,\n\t\t\t\tESR_RXTX_RESET_CTRL_H);\n\t\tif (err >= 0) {\n\t\t\t*val |= ((err & 0xffff) << 16);\n\t\t\terr = 0;\n\t\t}\n\t}\n\treturn err;\n}\n\nstatic int esr_write_rxtx_ctrl(struct niu *np, unsigned long chan, u32 val)\n{\n\tint err;\n\n\terr = mdio_write(np, np->port, NIU_ESR_DEV_ADDR,\n\t\t\t ESR_RXTX_CTRL_L(chan), val & 0xffff);\n\tif (!err)\n\t\terr = mdio_write(np, np->port, NIU_ESR_DEV_ADDR,\n\t\t\t\t ESR_RXTX_CTRL_H(chan), (val >> 16));\n\treturn err;\n}\n\nstatic int esr_write_glue0(struct niu *np, unsigned long chan, u32 val)\n{\n\tint err;\n\n\terr = mdio_write(np, np->port, NIU_ESR_DEV_ADDR,\n\t\t\tESR_GLUE_CTRL0_L(chan), val & 0xffff);\n\tif (!err)\n\t\terr = mdio_write(np, np->port, NIU_ESR_DEV_ADDR,\n\t\t\t\t ESR_GLUE_CTRL0_H(chan), (val >> 16));\n\treturn err;\n}\n\nstatic int esr_reset(struct niu *np)\n{\n\tu32 reset;\n\tint err;\n\n\terr = mdio_write(np, np->port, NIU_ESR_DEV_ADDR,\n\t\t\t ESR_RXTX_RESET_CTRL_L, 0x0000);\n\tif (err)\n\t\treturn err;\n\terr = mdio_write(np, np->port, NIU_ESR_DEV_ADDR,\n\t\t\t ESR_RXTX_RESET_CTRL_H, 0xffff);\n\tif (err)\n\t\treturn err;\n\tudelay(200);\n\n\terr = mdio_write(np, np->port, NIU_ESR_DEV_ADDR,\n\t\t\t ESR_RXTX_RESET_CTRL_L, 0xffff);\n\tif (err)\n\t\treturn err;\n\tudelay(200);\n\n\terr = mdio_write(np, np->port, NIU_ESR_DEV_ADDR,\n\t\t\t ESR_RXTX_RESET_CTRL_H, 0x0000);\n\tif (err)\n\t\treturn err;\n\tudelay(200);\n\n\terr = esr_read_reset(np, &reset);\n\tif (err)\n\t\treturn err;\n\tif (reset != 0) {\n\t\tnetdev_err(np->dev, \"Port %u ESR_RESET did not clear [%08x]\\n\",\n\t\t\t   np->port, reset);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic int serdes_init_10g(struct niu *np)\n{\n\tstruct niu_link_config *lp = &np->link_config;\n\tunsigned long ctrl_reg, test_cfg_reg, i;\n\tu64 ctrl_val, test_cfg_val, sig, mask, val;\n\tint err;\n\n\tswitch (np->port) {\n\tcase 0:\n\t\tctrl_reg = ENET_SERDES_0_CTRL_CFG;\n\t\ttest_cfg_reg = ENET_SERDES_0_TEST_CFG;\n\t\tbreak;\n\tcase 1:\n\t\tctrl_reg = ENET_SERDES_1_CTRL_CFG;\n\t\ttest_cfg_reg = ENET_SERDES_1_TEST_CFG;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tctrl_val = (ENET_SERDES_CTRL_SDET_0 |\n\t\t    ENET_SERDES_CTRL_SDET_1 |\n\t\t    ENET_SERDES_CTRL_SDET_2 |\n\t\t    ENET_SERDES_CTRL_SDET_3 |\n\t\t    (0x5 << ENET_SERDES_CTRL_EMPH_0_SHIFT) |\n\t\t    (0x5 << ENET_SERDES_CTRL_EMPH_1_SHIFT) |\n\t\t    (0x5 << ENET_SERDES_CTRL_EMPH_2_SHIFT) |\n\t\t    (0x5 << ENET_SERDES_CTRL_EMPH_3_SHIFT) |\n\t\t    (0x1 << ENET_SERDES_CTRL_LADJ_0_SHIFT) |\n\t\t    (0x1 << ENET_SERDES_CTRL_LADJ_1_SHIFT) |\n\t\t    (0x1 << ENET_SERDES_CTRL_LADJ_2_SHIFT) |\n\t\t    (0x1 << ENET_SERDES_CTRL_LADJ_3_SHIFT));\n\ttest_cfg_val = 0;\n\n\tif (lp->loopback_mode == LOOPBACK_PHY) {\n\t\ttest_cfg_val |= ((ENET_TEST_MD_PAD_LOOPBACK <<\n\t\t\t\t  ENET_SERDES_TEST_MD_0_SHIFT) |\n\t\t\t\t (ENET_TEST_MD_PAD_LOOPBACK <<\n\t\t\t\t  ENET_SERDES_TEST_MD_1_SHIFT) |\n\t\t\t\t (ENET_TEST_MD_PAD_LOOPBACK <<\n\t\t\t\t  ENET_SERDES_TEST_MD_2_SHIFT) |\n\t\t\t\t (ENET_TEST_MD_PAD_LOOPBACK <<\n\t\t\t\t  ENET_SERDES_TEST_MD_3_SHIFT));\n\t}\n\n\tnw64(ctrl_reg, ctrl_val);\n\tnw64(test_cfg_reg, test_cfg_val);\n\n\t \n\tfor (i = 0; i < 4; i++) {\n\t\tu32 rxtx_ctrl, glue0;\n\n\t\terr = esr_read_rxtx_ctrl(np, i, &rxtx_ctrl);\n\t\tif (err)\n\t\t\treturn err;\n\t\terr = esr_read_glue0(np, i, &glue0);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\trxtx_ctrl &= ~(ESR_RXTX_CTRL_VMUXLO);\n\t\trxtx_ctrl |= (ESR_RXTX_CTRL_ENSTRETCH |\n\t\t\t      (2 << ESR_RXTX_CTRL_VMUXLO_SHIFT));\n\n\t\tglue0 &= ~(ESR_GLUE_CTRL0_SRATE |\n\t\t\t   ESR_GLUE_CTRL0_THCNT |\n\t\t\t   ESR_GLUE_CTRL0_BLTIME);\n\t\tglue0 |= (ESR_GLUE_CTRL0_RXLOSENAB |\n\t\t\t  (0xf << ESR_GLUE_CTRL0_SRATE_SHIFT) |\n\t\t\t  (0xff << ESR_GLUE_CTRL0_THCNT_SHIFT) |\n\t\t\t  (BLTIME_300_CYCLES <<\n\t\t\t   ESR_GLUE_CTRL0_BLTIME_SHIFT));\n\n\t\terr = esr_write_rxtx_ctrl(np, i, rxtx_ctrl);\n\t\tif (err)\n\t\t\treturn err;\n\t\terr = esr_write_glue0(np, i, glue0);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\terr = esr_reset(np);\n\tif (err)\n\t\treturn err;\n\n\tsig = nr64(ESR_INT_SIGNALS);\n\tswitch (np->port) {\n\tcase 0:\n\t\tmask = ESR_INT_SIGNALS_P0_BITS;\n\t\tval = (ESR_INT_SRDY0_P0 |\n\t\t       ESR_INT_DET0_P0 |\n\t\t       ESR_INT_XSRDY_P0 |\n\t\t       ESR_INT_XDP_P0_CH3 |\n\t\t       ESR_INT_XDP_P0_CH2 |\n\t\t       ESR_INT_XDP_P0_CH1 |\n\t\t       ESR_INT_XDP_P0_CH0);\n\t\tbreak;\n\n\tcase 1:\n\t\tmask = ESR_INT_SIGNALS_P1_BITS;\n\t\tval = (ESR_INT_SRDY0_P1 |\n\t\t       ESR_INT_DET0_P1 |\n\t\t       ESR_INT_XSRDY_P1 |\n\t\t       ESR_INT_XDP_P1_CH3 |\n\t\t       ESR_INT_XDP_P1_CH2 |\n\t\t       ESR_INT_XDP_P1_CH1 |\n\t\t       ESR_INT_XDP_P1_CH0);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif ((sig & mask) != val) {\n\t\tif (np->flags & NIU_FLAGS_HOTPLUG_PHY) {\n\t\t\tnp->flags &= ~NIU_FLAGS_HOTPLUG_PHY_PRESENT;\n\t\t\treturn 0;\n\t\t}\n\t\tnetdev_err(np->dev, \"Port %u signal bits [%08x] are not [%08x]\\n\",\n\t\t\t   np->port, (int)(sig & mask), (int)val);\n\t\treturn -ENODEV;\n\t}\n\tif (np->flags & NIU_FLAGS_HOTPLUG_PHY)\n\t\tnp->flags |= NIU_FLAGS_HOTPLUG_PHY_PRESENT;\n\treturn 0;\n}\n\nstatic int serdes_init_1g(struct niu *np)\n{\n\tu64 val;\n\n\tval = nr64(ENET_SERDES_1_PLL_CFG);\n\tval &= ~ENET_SERDES_PLL_FBDIV2;\n\tswitch (np->port) {\n\tcase 0:\n\t\tval |= ENET_SERDES_PLL_HRATE0;\n\t\tbreak;\n\tcase 1:\n\t\tval |= ENET_SERDES_PLL_HRATE1;\n\t\tbreak;\n\tcase 2:\n\t\tval |= ENET_SERDES_PLL_HRATE2;\n\t\tbreak;\n\tcase 3:\n\t\tval |= ENET_SERDES_PLL_HRATE3;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tnw64(ENET_SERDES_1_PLL_CFG, val);\n\n\treturn 0;\n}\n\nstatic int serdes_init_1g_serdes(struct niu *np)\n{\n\tstruct niu_link_config *lp = &np->link_config;\n\tunsigned long ctrl_reg, test_cfg_reg, pll_cfg, i;\n\tu64 ctrl_val, test_cfg_val, sig, mask, val;\n\tint err;\n\tu64 reset_val, val_rd;\n\n\tval = ENET_SERDES_PLL_HRATE0 | ENET_SERDES_PLL_HRATE1 |\n\t\tENET_SERDES_PLL_HRATE2 | ENET_SERDES_PLL_HRATE3 |\n\t\tENET_SERDES_PLL_FBDIV0;\n\tswitch (np->port) {\n\tcase 0:\n\t\treset_val =  ENET_SERDES_RESET_0;\n\t\tctrl_reg = ENET_SERDES_0_CTRL_CFG;\n\t\ttest_cfg_reg = ENET_SERDES_0_TEST_CFG;\n\t\tpll_cfg = ENET_SERDES_0_PLL_CFG;\n\t\tbreak;\n\tcase 1:\n\t\treset_val =  ENET_SERDES_RESET_1;\n\t\tctrl_reg = ENET_SERDES_1_CTRL_CFG;\n\t\ttest_cfg_reg = ENET_SERDES_1_TEST_CFG;\n\t\tpll_cfg = ENET_SERDES_1_PLL_CFG;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tctrl_val = (ENET_SERDES_CTRL_SDET_0 |\n\t\t    ENET_SERDES_CTRL_SDET_1 |\n\t\t    ENET_SERDES_CTRL_SDET_2 |\n\t\t    ENET_SERDES_CTRL_SDET_3 |\n\t\t    (0x5 << ENET_SERDES_CTRL_EMPH_0_SHIFT) |\n\t\t    (0x5 << ENET_SERDES_CTRL_EMPH_1_SHIFT) |\n\t\t    (0x5 << ENET_SERDES_CTRL_EMPH_2_SHIFT) |\n\t\t    (0x5 << ENET_SERDES_CTRL_EMPH_3_SHIFT) |\n\t\t    (0x1 << ENET_SERDES_CTRL_LADJ_0_SHIFT) |\n\t\t    (0x1 << ENET_SERDES_CTRL_LADJ_1_SHIFT) |\n\t\t    (0x1 << ENET_SERDES_CTRL_LADJ_2_SHIFT) |\n\t\t    (0x1 << ENET_SERDES_CTRL_LADJ_3_SHIFT));\n\ttest_cfg_val = 0;\n\n\tif (lp->loopback_mode == LOOPBACK_PHY) {\n\t\ttest_cfg_val |= ((ENET_TEST_MD_PAD_LOOPBACK <<\n\t\t\t\t  ENET_SERDES_TEST_MD_0_SHIFT) |\n\t\t\t\t (ENET_TEST_MD_PAD_LOOPBACK <<\n\t\t\t\t  ENET_SERDES_TEST_MD_1_SHIFT) |\n\t\t\t\t (ENET_TEST_MD_PAD_LOOPBACK <<\n\t\t\t\t  ENET_SERDES_TEST_MD_2_SHIFT) |\n\t\t\t\t (ENET_TEST_MD_PAD_LOOPBACK <<\n\t\t\t\t  ENET_SERDES_TEST_MD_3_SHIFT));\n\t}\n\n\tnw64(ENET_SERDES_RESET, reset_val);\n\tmdelay(20);\n\tval_rd = nr64(ENET_SERDES_RESET);\n\tval_rd &= ~reset_val;\n\tnw64(pll_cfg, val);\n\tnw64(ctrl_reg, ctrl_val);\n\tnw64(test_cfg_reg, test_cfg_val);\n\tnw64(ENET_SERDES_RESET, val_rd);\n\tmdelay(2000);\n\n\t \n\tfor (i = 0; i < 4; i++) {\n\t\tu32 rxtx_ctrl, glue0;\n\n\t\terr = esr_read_rxtx_ctrl(np, i, &rxtx_ctrl);\n\t\tif (err)\n\t\t\treturn err;\n\t\terr = esr_read_glue0(np, i, &glue0);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\trxtx_ctrl &= ~(ESR_RXTX_CTRL_VMUXLO);\n\t\trxtx_ctrl |= (ESR_RXTX_CTRL_ENSTRETCH |\n\t\t\t      (2 << ESR_RXTX_CTRL_VMUXLO_SHIFT));\n\n\t\tglue0 &= ~(ESR_GLUE_CTRL0_SRATE |\n\t\t\t   ESR_GLUE_CTRL0_THCNT |\n\t\t\t   ESR_GLUE_CTRL0_BLTIME);\n\t\tglue0 |= (ESR_GLUE_CTRL0_RXLOSENAB |\n\t\t\t  (0xf << ESR_GLUE_CTRL0_SRATE_SHIFT) |\n\t\t\t  (0xff << ESR_GLUE_CTRL0_THCNT_SHIFT) |\n\t\t\t  (BLTIME_300_CYCLES <<\n\t\t\t   ESR_GLUE_CTRL0_BLTIME_SHIFT));\n\n\t\terr = esr_write_rxtx_ctrl(np, i, rxtx_ctrl);\n\t\tif (err)\n\t\t\treturn err;\n\t\terr = esr_write_glue0(np, i, glue0);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\n\tsig = nr64(ESR_INT_SIGNALS);\n\tswitch (np->port) {\n\tcase 0:\n\t\tval = (ESR_INT_SRDY0_P0 | ESR_INT_DET0_P0);\n\t\tmask = val;\n\t\tbreak;\n\n\tcase 1:\n\t\tval = (ESR_INT_SRDY0_P1 | ESR_INT_DET0_P1);\n\t\tmask = val;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif ((sig & mask) != val) {\n\t\tnetdev_err(np->dev, \"Port %u signal bits [%08x] are not [%08x]\\n\",\n\t\t\t   np->port, (int)(sig & mask), (int)val);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic int link_status_1g_serdes(struct niu *np, int *link_up_p)\n{\n\tstruct niu_link_config *lp = &np->link_config;\n\tint link_up;\n\tu64 val;\n\tu16 current_speed;\n\tunsigned long flags;\n\tu8 current_duplex;\n\n\tlink_up = 0;\n\tcurrent_speed = SPEED_INVALID;\n\tcurrent_duplex = DUPLEX_INVALID;\n\n\tspin_lock_irqsave(&np->lock, flags);\n\n\tval = nr64_pcs(PCS_MII_STAT);\n\n\tif (val & PCS_MII_STAT_LINK_STATUS) {\n\t\tlink_up = 1;\n\t\tcurrent_speed = SPEED_1000;\n\t\tcurrent_duplex = DUPLEX_FULL;\n\t}\n\n\tlp->active_speed = current_speed;\n\tlp->active_duplex = current_duplex;\n\tspin_unlock_irqrestore(&np->lock, flags);\n\n\t*link_up_p = link_up;\n\treturn 0;\n}\n\nstatic int link_status_10g_serdes(struct niu *np, int *link_up_p)\n{\n\tunsigned long flags;\n\tstruct niu_link_config *lp = &np->link_config;\n\tint link_up = 0;\n\tint link_ok = 1;\n\tu64 val, val2;\n\tu16 current_speed;\n\tu8 current_duplex;\n\n\tif (!(np->flags & NIU_FLAGS_10G))\n\t\treturn link_status_1g_serdes(np, link_up_p);\n\n\tcurrent_speed = SPEED_INVALID;\n\tcurrent_duplex = DUPLEX_INVALID;\n\tspin_lock_irqsave(&np->lock, flags);\n\n\tval = nr64_xpcs(XPCS_STATUS(0));\n\tval2 = nr64_mac(XMAC_INTER2);\n\tif (val2 & 0x01000000)\n\t\tlink_ok = 0;\n\n\tif ((val & 0x1000ULL) && link_ok) {\n\t\tlink_up = 1;\n\t\tcurrent_speed = SPEED_10000;\n\t\tcurrent_duplex = DUPLEX_FULL;\n\t}\n\tlp->active_speed = current_speed;\n\tlp->active_duplex = current_duplex;\n\tspin_unlock_irqrestore(&np->lock, flags);\n\t*link_up_p = link_up;\n\treturn 0;\n}\n\nstatic int link_status_mii(struct niu *np, int *link_up_p)\n{\n\tstruct niu_link_config *lp = &np->link_config;\n\tint err;\n\tint bmsr, advert, ctrl1000, stat1000, lpa, bmcr, estatus;\n\tint supported, advertising, active_speed, active_duplex;\n\n\terr = mii_read(np, np->phy_addr, MII_BMCR);\n\tif (unlikely(err < 0))\n\t\treturn err;\n\tbmcr = err;\n\n\terr = mii_read(np, np->phy_addr, MII_BMSR);\n\tif (unlikely(err < 0))\n\t\treturn err;\n\tbmsr = err;\n\n\terr = mii_read(np, np->phy_addr, MII_ADVERTISE);\n\tif (unlikely(err < 0))\n\t\treturn err;\n\tadvert = err;\n\n\terr = mii_read(np, np->phy_addr, MII_LPA);\n\tif (unlikely(err < 0))\n\t\treturn err;\n\tlpa = err;\n\n\tif (likely(bmsr & BMSR_ESTATEN)) {\n\t\terr = mii_read(np, np->phy_addr, MII_ESTATUS);\n\t\tif (unlikely(err < 0))\n\t\t\treturn err;\n\t\testatus = err;\n\n\t\terr = mii_read(np, np->phy_addr, MII_CTRL1000);\n\t\tif (unlikely(err < 0))\n\t\t\treturn err;\n\t\tctrl1000 = err;\n\n\t\terr = mii_read(np, np->phy_addr, MII_STAT1000);\n\t\tif (unlikely(err < 0))\n\t\t\treturn err;\n\t\tstat1000 = err;\n\t} else\n\t\testatus = ctrl1000 = stat1000 = 0;\n\n\tsupported = 0;\n\tif (bmsr & BMSR_ANEGCAPABLE)\n\t\tsupported |= SUPPORTED_Autoneg;\n\tif (bmsr & BMSR_10HALF)\n\t\tsupported |= SUPPORTED_10baseT_Half;\n\tif (bmsr & BMSR_10FULL)\n\t\tsupported |= SUPPORTED_10baseT_Full;\n\tif (bmsr & BMSR_100HALF)\n\t\tsupported |= SUPPORTED_100baseT_Half;\n\tif (bmsr & BMSR_100FULL)\n\t\tsupported |= SUPPORTED_100baseT_Full;\n\tif (estatus & ESTATUS_1000_THALF)\n\t\tsupported |= SUPPORTED_1000baseT_Half;\n\tif (estatus & ESTATUS_1000_TFULL)\n\t\tsupported |= SUPPORTED_1000baseT_Full;\n\tlp->supported = supported;\n\n\tadvertising = mii_adv_to_ethtool_adv_t(advert);\n\tadvertising |= mii_ctrl1000_to_ethtool_adv_t(ctrl1000);\n\n\tif (bmcr & BMCR_ANENABLE) {\n\t\tint neg, neg1000;\n\n\t\tlp->active_autoneg = 1;\n\t\tadvertising |= ADVERTISED_Autoneg;\n\n\t\tneg = advert & lpa;\n\t\tneg1000 = (ctrl1000 << 2) & stat1000;\n\n\t\tif (neg1000 & (LPA_1000FULL | LPA_1000HALF))\n\t\t\tactive_speed = SPEED_1000;\n\t\telse if (neg & LPA_100)\n\t\t\tactive_speed = SPEED_100;\n\t\telse if (neg & (LPA_10HALF | LPA_10FULL))\n\t\t\tactive_speed = SPEED_10;\n\t\telse\n\t\t\tactive_speed = SPEED_INVALID;\n\n\t\tif ((neg1000 & LPA_1000FULL) || (neg & LPA_DUPLEX))\n\t\t\tactive_duplex = DUPLEX_FULL;\n\t\telse if (active_speed != SPEED_INVALID)\n\t\t\tactive_duplex = DUPLEX_HALF;\n\t\telse\n\t\t\tactive_duplex = DUPLEX_INVALID;\n\t} else {\n\t\tlp->active_autoneg = 0;\n\n\t\tif ((bmcr & BMCR_SPEED1000) && !(bmcr & BMCR_SPEED100))\n\t\t\tactive_speed = SPEED_1000;\n\t\telse if (bmcr & BMCR_SPEED100)\n\t\t\tactive_speed = SPEED_100;\n\t\telse\n\t\t\tactive_speed = SPEED_10;\n\n\t\tif (bmcr & BMCR_FULLDPLX)\n\t\t\tactive_duplex = DUPLEX_FULL;\n\t\telse\n\t\t\tactive_duplex = DUPLEX_HALF;\n\t}\n\n\tlp->active_advertising = advertising;\n\tlp->active_speed = active_speed;\n\tlp->active_duplex = active_duplex;\n\t*link_up_p = !!(bmsr & BMSR_LSTATUS);\n\n\treturn 0;\n}\n\nstatic int link_status_1g_rgmii(struct niu *np, int *link_up_p)\n{\n\tstruct niu_link_config *lp = &np->link_config;\n\tu16 current_speed, bmsr;\n\tunsigned long flags;\n\tu8 current_duplex;\n\tint err, link_up;\n\n\tlink_up = 0;\n\tcurrent_speed = SPEED_INVALID;\n\tcurrent_duplex = DUPLEX_INVALID;\n\n\tspin_lock_irqsave(&np->lock, flags);\n\n\terr = mii_read(np, np->phy_addr, MII_BMSR);\n\tif (err < 0)\n\t\tgoto out;\n\n\tbmsr = err;\n\tif (bmsr & BMSR_LSTATUS) {\n\t\tlink_up = 1;\n\t\tcurrent_speed = SPEED_1000;\n\t\tcurrent_duplex = DUPLEX_FULL;\n\t}\n\tlp->active_speed = current_speed;\n\tlp->active_duplex = current_duplex;\n\terr = 0;\n\nout:\n\tspin_unlock_irqrestore(&np->lock, flags);\n\n\t*link_up_p = link_up;\n\treturn err;\n}\n\nstatic int link_status_1g(struct niu *np, int *link_up_p)\n{\n\tstruct niu_link_config *lp = &np->link_config;\n\tunsigned long flags;\n\tint err;\n\n\tspin_lock_irqsave(&np->lock, flags);\n\n\terr = link_status_mii(np, link_up_p);\n\tlp->supported |= SUPPORTED_TP;\n\tlp->active_advertising |= ADVERTISED_TP;\n\n\tspin_unlock_irqrestore(&np->lock, flags);\n\treturn err;\n}\n\nstatic int bcm8704_reset(struct niu *np)\n{\n\tint err, limit;\n\n\terr = mdio_read(np, np->phy_addr,\n\t\t\tBCM8704_PHYXS_DEV_ADDR, MII_BMCR);\n\tif (err < 0 || err == 0xffff)\n\t\treturn err;\n\terr |= BMCR_RESET;\n\terr = mdio_write(np, np->phy_addr, BCM8704_PHYXS_DEV_ADDR,\n\t\t\t MII_BMCR, err);\n\tif (err)\n\t\treturn err;\n\n\tlimit = 1000;\n\twhile (--limit >= 0) {\n\t\terr = mdio_read(np, np->phy_addr,\n\t\t\t\tBCM8704_PHYXS_DEV_ADDR, MII_BMCR);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tif (!(err & BMCR_RESET))\n\t\t\tbreak;\n\t}\n\tif (limit < 0) {\n\t\tnetdev_err(np->dev, \"Port %u PHY will not reset (bmcr=%04x)\\n\",\n\t\t\t   np->port, (err & 0xffff));\n\t\treturn -ENODEV;\n\t}\n\treturn 0;\n}\n\n \nstatic int bcm8704_user_dev3_readback(struct niu *np, int reg)\n{\n\tint err = mdio_read(np, np->phy_addr, BCM8704_USER_DEV3_ADDR, reg);\n\tif (err < 0)\n\t\treturn err;\n\terr = mdio_read(np, np->phy_addr, BCM8704_USER_DEV3_ADDR, reg);\n\tif (err < 0)\n\t\treturn err;\n\treturn 0;\n}\n\nstatic int bcm8706_init_user_dev3(struct niu *np)\n{\n\tint err;\n\n\n\terr = mdio_read(np, np->phy_addr, BCM8704_USER_DEV3_ADDR,\n\t\t\tBCM8704_USER_OPT_DIGITAL_CTRL);\n\tif (err < 0)\n\t\treturn err;\n\terr &= ~USER_ODIG_CTRL_GPIOS;\n\terr |= (0x3 << USER_ODIG_CTRL_GPIOS_SHIFT);\n\terr |=  USER_ODIG_CTRL_RESV2;\n\terr = mdio_write(np, np->phy_addr, BCM8704_USER_DEV3_ADDR,\n\t\t\t BCM8704_USER_OPT_DIGITAL_CTRL, err);\n\tif (err)\n\t\treturn err;\n\n\tmdelay(1000);\n\n\treturn 0;\n}\n\nstatic int bcm8704_init_user_dev3(struct niu *np)\n{\n\tint err;\n\n\terr = mdio_write(np, np->phy_addr,\n\t\t\t BCM8704_USER_DEV3_ADDR, BCM8704_USER_CONTROL,\n\t\t\t (USER_CONTROL_OPTXRST_LVL |\n\t\t\t  USER_CONTROL_OPBIASFLT_LVL |\n\t\t\t  USER_CONTROL_OBTMPFLT_LVL |\n\t\t\t  USER_CONTROL_OPPRFLT_LVL |\n\t\t\t  USER_CONTROL_OPTXFLT_LVL |\n\t\t\t  USER_CONTROL_OPRXLOS_LVL |\n\t\t\t  USER_CONTROL_OPRXFLT_LVL |\n\t\t\t  USER_CONTROL_OPTXON_LVL |\n\t\t\t  (0x3f << USER_CONTROL_RES1_SHIFT)));\n\tif (err)\n\t\treturn err;\n\n\terr = mdio_write(np, np->phy_addr,\n\t\t\t BCM8704_USER_DEV3_ADDR, BCM8704_USER_PMD_TX_CONTROL,\n\t\t\t (USER_PMD_TX_CTL_XFP_CLKEN |\n\t\t\t  (1 << USER_PMD_TX_CTL_TX_DAC_TXD_SH) |\n\t\t\t  (2 << USER_PMD_TX_CTL_TX_DAC_TXCK_SH) |\n\t\t\t  USER_PMD_TX_CTL_TSCK_LPWREN));\n\tif (err)\n\t\treturn err;\n\n\terr = bcm8704_user_dev3_readback(np, BCM8704_USER_CONTROL);\n\tif (err)\n\t\treturn err;\n\terr = bcm8704_user_dev3_readback(np, BCM8704_USER_PMD_TX_CONTROL);\n\tif (err)\n\t\treturn err;\n\n\terr = mdio_read(np, np->phy_addr, BCM8704_USER_DEV3_ADDR,\n\t\t\tBCM8704_USER_OPT_DIGITAL_CTRL);\n\tif (err < 0)\n\t\treturn err;\n\terr &= ~USER_ODIG_CTRL_GPIOS;\n\terr |= (0x3 << USER_ODIG_CTRL_GPIOS_SHIFT);\n\terr = mdio_write(np, np->phy_addr, BCM8704_USER_DEV3_ADDR,\n\t\t\t BCM8704_USER_OPT_DIGITAL_CTRL, err);\n\tif (err)\n\t\treturn err;\n\n\tmdelay(1000);\n\n\treturn 0;\n}\n\nstatic int mrvl88x2011_act_led(struct niu *np, int val)\n{\n\tint\terr;\n\n\terr  = mdio_read(np, np->phy_addr, MRVL88X2011_USER_DEV2_ADDR,\n\t\tMRVL88X2011_LED_8_TO_11_CTL);\n\tif (err < 0)\n\t\treturn err;\n\n\terr &= ~MRVL88X2011_LED(MRVL88X2011_LED_ACT,MRVL88X2011_LED_CTL_MASK);\n\terr |=  MRVL88X2011_LED(MRVL88X2011_LED_ACT,val);\n\n\treturn mdio_write(np, np->phy_addr, MRVL88X2011_USER_DEV2_ADDR,\n\t\t\t  MRVL88X2011_LED_8_TO_11_CTL, err);\n}\n\nstatic int mrvl88x2011_led_blink_rate(struct niu *np, int rate)\n{\n\tint\terr;\n\n\terr = mdio_read(np, np->phy_addr, MRVL88X2011_USER_DEV2_ADDR,\n\t\t\tMRVL88X2011_LED_BLINK_CTL);\n\tif (err >= 0) {\n\t\terr &= ~MRVL88X2011_LED_BLKRATE_MASK;\n\t\terr |= (rate << 4);\n\n\t\terr = mdio_write(np, np->phy_addr, MRVL88X2011_USER_DEV2_ADDR,\n\t\t\t\t MRVL88X2011_LED_BLINK_CTL, err);\n\t}\n\n\treturn err;\n}\n\nstatic int xcvr_init_10g_mrvl88x2011(struct niu *np)\n{\n\tint\terr;\n\n\t \n\terr = mrvl88x2011_led_blink_rate(np, MRVL88X2011_LED_BLKRATE_134MS);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = mrvl88x2011_act_led(np, MRVL88X2011_LED_CTL_OFF);\n\tif (err)\n\t\treturn err;\n\n\terr = mdio_read(np, np->phy_addr, MRVL88X2011_USER_DEV3_ADDR,\n\t\t\tMRVL88X2011_GENERAL_CTL);\n\tif (err < 0)\n\t\treturn err;\n\n\terr |= MRVL88X2011_ENA_XFPREFCLK;\n\n\terr = mdio_write(np, np->phy_addr, MRVL88X2011_USER_DEV3_ADDR,\n\t\t\t MRVL88X2011_GENERAL_CTL, err);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = mdio_read(np, np->phy_addr, MRVL88X2011_USER_DEV1_ADDR,\n\t\t\tMRVL88X2011_PMA_PMD_CTL_1);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (np->link_config.loopback_mode == LOOPBACK_MAC)\n\t\terr |= MRVL88X2011_LOOPBACK;\n\telse\n\t\terr &= ~MRVL88X2011_LOOPBACK;\n\n\terr = mdio_write(np, np->phy_addr, MRVL88X2011_USER_DEV1_ADDR,\n\t\t\t MRVL88X2011_PMA_PMD_CTL_1, err);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\treturn mdio_write(np, np->phy_addr, MRVL88X2011_USER_DEV1_ADDR,\n\t\t\t  MRVL88X2011_10G_PMD_TX_DIS, MRVL88X2011_ENA_PMDTX);\n}\n\n\nstatic int xcvr_diag_bcm870x(struct niu *np)\n{\n\tu16 analog_stat0, tx_alarm_status;\n\tint err = 0;\n\n#if 1\n\terr = mdio_read(np, np->phy_addr, BCM8704_PMA_PMD_DEV_ADDR,\n\t\t\tMII_STAT1000);\n\tif (err < 0)\n\t\treturn err;\n\tpr_info(\"Port %u PMA_PMD(MII_STAT1000) [%04x]\\n\", np->port, err);\n\n\terr = mdio_read(np, np->phy_addr, BCM8704_USER_DEV3_ADDR, 0x20);\n\tif (err < 0)\n\t\treturn err;\n\tpr_info(\"Port %u USER_DEV3(0x20) [%04x]\\n\", np->port, err);\n\n\terr = mdio_read(np, np->phy_addr, BCM8704_PHYXS_DEV_ADDR,\n\t\t\tMII_NWAYTEST);\n\tif (err < 0)\n\t\treturn err;\n\tpr_info(\"Port %u PHYXS(MII_NWAYTEST) [%04x]\\n\", np->port, err);\n#endif\n\n\t \n\terr = mdio_read(np, np->phy_addr, BCM8704_USER_DEV3_ADDR,\n\t\t\tBCM8704_USER_ANALOG_STATUS0);\n\tif (err < 0)\n\t\treturn err;\n\terr = mdio_read(np, np->phy_addr, BCM8704_USER_DEV3_ADDR,\n\t\t\tBCM8704_USER_ANALOG_STATUS0);\n\tif (err < 0)\n\t\treturn err;\n\tanalog_stat0 = err;\n\n\terr = mdio_read(np, np->phy_addr, BCM8704_USER_DEV3_ADDR,\n\t\t\tBCM8704_USER_TX_ALARM_STATUS);\n\tif (err < 0)\n\t\treturn err;\n\terr = mdio_read(np, np->phy_addr, BCM8704_USER_DEV3_ADDR,\n\t\t\tBCM8704_USER_TX_ALARM_STATUS);\n\tif (err < 0)\n\t\treturn err;\n\ttx_alarm_status = err;\n\n\tif (analog_stat0 != 0x03fc) {\n\t\tif ((analog_stat0 == 0x43bc) && (tx_alarm_status != 0)) {\n\t\t\tpr_info(\"Port %u cable not connected or bad cable\\n\",\n\t\t\t\tnp->port);\n\t\t} else if (analog_stat0 == 0x639c) {\n\t\t\tpr_info(\"Port %u optical module is bad or missing\\n\",\n\t\t\t\tnp->port);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int xcvr_10g_set_lb_bcm870x(struct niu *np)\n{\n\tstruct niu_link_config *lp = &np->link_config;\n\tint err;\n\n\terr = mdio_read(np, np->phy_addr, BCM8704_PCS_DEV_ADDR,\n\t\t\tMII_BMCR);\n\tif (err < 0)\n\t\treturn err;\n\n\terr &= ~BMCR_LOOPBACK;\n\n\tif (lp->loopback_mode == LOOPBACK_MAC)\n\t\terr |= BMCR_LOOPBACK;\n\n\terr = mdio_write(np, np->phy_addr, BCM8704_PCS_DEV_ADDR,\n\t\t\t MII_BMCR, err);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic int xcvr_init_10g_bcm8706(struct niu *np)\n{\n\tint err = 0;\n\tu64 val;\n\n\tif ((np->flags & NIU_FLAGS_HOTPLUG_PHY) &&\n\t    (np->flags & NIU_FLAGS_HOTPLUG_PHY_PRESENT) == 0)\n\t\t\treturn err;\n\n\tval = nr64_mac(XMAC_CONFIG);\n\tval &= ~XMAC_CONFIG_LED_POLARITY;\n\tval |= XMAC_CONFIG_FORCE_LED_ON;\n\tnw64_mac(XMAC_CONFIG, val);\n\n\tval = nr64(MIF_CONFIG);\n\tval |= MIF_CONFIG_INDIRECT_MODE;\n\tnw64(MIF_CONFIG, val);\n\n\terr = bcm8704_reset(np);\n\tif (err)\n\t\treturn err;\n\n\terr = xcvr_10g_set_lb_bcm870x(np);\n\tif (err)\n\t\treturn err;\n\n\terr = bcm8706_init_user_dev3(np);\n\tif (err)\n\t\treturn err;\n\n\terr = xcvr_diag_bcm870x(np);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic int xcvr_init_10g_bcm8704(struct niu *np)\n{\n\tint err;\n\n\terr = bcm8704_reset(np);\n\tif (err)\n\t\treturn err;\n\n\terr = bcm8704_init_user_dev3(np);\n\tif (err)\n\t\treturn err;\n\n\terr = xcvr_10g_set_lb_bcm870x(np);\n\tif (err)\n\t\treturn err;\n\n\terr =  xcvr_diag_bcm870x(np);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic int xcvr_init_10g(struct niu *np)\n{\n\tint phy_id, err;\n\tu64 val;\n\n\tval = nr64_mac(XMAC_CONFIG);\n\tval &= ~XMAC_CONFIG_LED_POLARITY;\n\tval |= XMAC_CONFIG_FORCE_LED_ON;\n\tnw64_mac(XMAC_CONFIG, val);\n\n\t \n\tval = nr64(MIF_CONFIG);\n\tval |= MIF_CONFIG_INDIRECT_MODE;\n\tnw64(MIF_CONFIG, val);\n\n\tphy_id = phy_decode(np->parent->port_phy, np->port);\n\tphy_id = np->parent->phy_probe_info.phy_id[phy_id][np->port];\n\n\t \n\tswitch (phy_id & NIU_PHY_ID_MASK) {\n\tcase NIU_PHY_ID_MRVL88X2011:\n\t\terr = xcvr_init_10g_mrvl88x2011(np);\n\t\tbreak;\n\n\tdefault:  \n\t\terr = xcvr_init_10g_bcm8704(np);\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nstatic int mii_reset(struct niu *np)\n{\n\tint limit, err;\n\n\terr = mii_write(np, np->phy_addr, MII_BMCR, BMCR_RESET);\n\tif (err)\n\t\treturn err;\n\n\tlimit = 1000;\n\twhile (--limit >= 0) {\n\t\tudelay(500);\n\t\terr = mii_read(np, np->phy_addr, MII_BMCR);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tif (!(err & BMCR_RESET))\n\t\t\tbreak;\n\t}\n\tif (limit < 0) {\n\t\tnetdev_err(np->dev, \"Port %u MII would not reset, bmcr[%04x]\\n\",\n\t\t\t   np->port, err);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic int xcvr_init_1g_rgmii(struct niu *np)\n{\n\tint err;\n\tu64 val;\n\tu16 bmcr, bmsr, estat;\n\n\tval = nr64(MIF_CONFIG);\n\tval &= ~MIF_CONFIG_INDIRECT_MODE;\n\tnw64(MIF_CONFIG, val);\n\n\terr = mii_reset(np);\n\tif (err)\n\t\treturn err;\n\n\terr = mii_read(np, np->phy_addr, MII_BMSR);\n\tif (err < 0)\n\t\treturn err;\n\tbmsr = err;\n\n\testat = 0;\n\tif (bmsr & BMSR_ESTATEN) {\n\t\terr = mii_read(np, np->phy_addr, MII_ESTATUS);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\testat = err;\n\t}\n\n\tbmcr = 0;\n\terr = mii_write(np, np->phy_addr, MII_BMCR, bmcr);\n\tif (err)\n\t\treturn err;\n\n\tif (bmsr & BMSR_ESTATEN) {\n\t\tu16 ctrl1000 = 0;\n\n\t\tif (estat & ESTATUS_1000_TFULL)\n\t\t\tctrl1000 |= ADVERTISE_1000FULL;\n\t\terr = mii_write(np, np->phy_addr, MII_CTRL1000, ctrl1000);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tbmcr = (BMCR_SPEED1000 | BMCR_FULLDPLX);\n\n\terr = mii_write(np, np->phy_addr, MII_BMCR, bmcr);\n\tif (err)\n\t\treturn err;\n\n\terr = mii_read(np, np->phy_addr, MII_BMCR);\n\tif (err < 0)\n\t\treturn err;\n\tbmcr = mii_read(np, np->phy_addr, MII_BMCR);\n\n\terr = mii_read(np, np->phy_addr, MII_BMSR);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic int mii_init_common(struct niu *np)\n{\n\tstruct niu_link_config *lp = &np->link_config;\n\tu16 bmcr, bmsr, adv, estat;\n\tint err;\n\n\terr = mii_reset(np);\n\tif (err)\n\t\treturn err;\n\n\terr = mii_read(np, np->phy_addr, MII_BMSR);\n\tif (err < 0)\n\t\treturn err;\n\tbmsr = err;\n\n\testat = 0;\n\tif (bmsr & BMSR_ESTATEN) {\n\t\terr = mii_read(np, np->phy_addr, MII_ESTATUS);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\testat = err;\n\t}\n\n\tbmcr = 0;\n\terr = mii_write(np, np->phy_addr, MII_BMCR, bmcr);\n\tif (err)\n\t\treturn err;\n\n\tif (lp->loopback_mode == LOOPBACK_MAC) {\n\t\tbmcr |= BMCR_LOOPBACK;\n\t\tif (lp->active_speed == SPEED_1000)\n\t\t\tbmcr |= BMCR_SPEED1000;\n\t\tif (lp->active_duplex == DUPLEX_FULL)\n\t\t\tbmcr |= BMCR_FULLDPLX;\n\t}\n\n\tif (lp->loopback_mode == LOOPBACK_PHY) {\n\t\tu16 aux;\n\n\t\taux = (BCM5464R_AUX_CTL_EXT_LB |\n\t\t       BCM5464R_AUX_CTL_WRITE_1);\n\t\terr = mii_write(np, np->phy_addr, BCM5464R_AUX_CTL, aux);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (lp->autoneg) {\n\t\tu16 ctrl1000;\n\n\t\tadv = ADVERTISE_CSMA | ADVERTISE_PAUSE_CAP;\n\t\tif ((bmsr & BMSR_10HALF) &&\n\t\t\t(lp->advertising & ADVERTISED_10baseT_Half))\n\t\t\tadv |= ADVERTISE_10HALF;\n\t\tif ((bmsr & BMSR_10FULL) &&\n\t\t\t(lp->advertising & ADVERTISED_10baseT_Full))\n\t\t\tadv |= ADVERTISE_10FULL;\n\t\tif ((bmsr & BMSR_100HALF) &&\n\t\t\t(lp->advertising & ADVERTISED_100baseT_Half))\n\t\t\tadv |= ADVERTISE_100HALF;\n\t\tif ((bmsr & BMSR_100FULL) &&\n\t\t\t(lp->advertising & ADVERTISED_100baseT_Full))\n\t\t\tadv |= ADVERTISE_100FULL;\n\t\terr = mii_write(np, np->phy_addr, MII_ADVERTISE, adv);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (likely(bmsr & BMSR_ESTATEN)) {\n\t\t\tctrl1000 = 0;\n\t\t\tif ((estat & ESTATUS_1000_THALF) &&\n\t\t\t\t(lp->advertising & ADVERTISED_1000baseT_Half))\n\t\t\t\tctrl1000 |= ADVERTISE_1000HALF;\n\t\t\tif ((estat & ESTATUS_1000_TFULL) &&\n\t\t\t\t(lp->advertising & ADVERTISED_1000baseT_Full))\n\t\t\t\tctrl1000 |= ADVERTISE_1000FULL;\n\t\t\terr = mii_write(np, np->phy_addr,\n\t\t\t\t\tMII_CTRL1000, ctrl1000);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\n\t\tbmcr |= (BMCR_ANENABLE | BMCR_ANRESTART);\n\t} else {\n\t\t \n\t\tint fulldpx;\n\n\t\tif (lp->duplex == DUPLEX_FULL) {\n\t\t\tbmcr |= BMCR_FULLDPLX;\n\t\t\tfulldpx = 1;\n\t\t} else if (lp->duplex == DUPLEX_HALF)\n\t\t\tfulldpx = 0;\n\t\telse\n\t\t\treturn -EINVAL;\n\n\t\tif (lp->speed == SPEED_1000) {\n\t\t\t \n\t\t\tif ((fulldpx && !(estat & ESTATUS_1000_TFULL)) ||\n\t\t\t\t(!fulldpx && !(estat & ESTATUS_1000_THALF)))\n\t\t\t\treturn -EINVAL;\n\t\t\tbmcr |= BMCR_SPEED1000;\n\t\t} else if (lp->speed == SPEED_100) {\n\t\t\tif ((fulldpx && !(bmsr & BMSR_100FULL)) ||\n\t\t\t\t(!fulldpx && !(bmsr & BMSR_100HALF)))\n\t\t\t\treturn -EINVAL;\n\t\t\tbmcr |= BMCR_SPEED100;\n\t\t} else if (lp->speed == SPEED_10) {\n\t\t\tif ((fulldpx && !(bmsr & BMSR_10FULL)) ||\n\t\t\t\t(!fulldpx && !(bmsr & BMSR_10HALF)))\n\t\t\t\treturn -EINVAL;\n\t\t} else\n\t\t\treturn -EINVAL;\n\t}\n\n\terr = mii_write(np, np->phy_addr, MII_BMCR, bmcr);\n\tif (err)\n\t\treturn err;\n\n#if 0\n\terr = mii_read(np, np->phy_addr, MII_BMCR);\n\tif (err < 0)\n\t\treturn err;\n\tbmcr = err;\n\n\terr = mii_read(np, np->phy_addr, MII_BMSR);\n\tif (err < 0)\n\t\treturn err;\n\tbmsr = err;\n\n\tpr_info(\"Port %u after MII init bmcr[%04x] bmsr[%04x]\\n\",\n\t\tnp->port, bmcr, bmsr);\n#endif\n\n\treturn 0;\n}\n\nstatic int xcvr_init_1g(struct niu *np)\n{\n\tu64 val;\n\n\t \n\tval = nr64(MIF_CONFIG);\n\tval &= ~MIF_CONFIG_INDIRECT_MODE;\n\tnw64(MIF_CONFIG, val);\n\n\treturn mii_init_common(np);\n}\n\nstatic int niu_xcvr_init(struct niu *np)\n{\n\tconst struct niu_phy_ops *ops = np->phy_ops;\n\tint err;\n\n\terr = 0;\n\tif (ops->xcvr_init)\n\t\terr = ops->xcvr_init(np);\n\n\treturn err;\n}\n\nstatic int niu_serdes_init(struct niu *np)\n{\n\tconst struct niu_phy_ops *ops = np->phy_ops;\n\tint err;\n\n\terr = 0;\n\tif (ops->serdes_init)\n\t\terr = ops->serdes_init(np);\n\n\treturn err;\n}\n\nstatic void niu_init_xif(struct niu *);\nstatic void niu_handle_led(struct niu *, int status);\n\nstatic int niu_link_status_common(struct niu *np, int link_up)\n{\n\tstruct niu_link_config *lp = &np->link_config;\n\tstruct net_device *dev = np->dev;\n\tunsigned long flags;\n\n\tif (!netif_carrier_ok(dev) && link_up) {\n\t\tnetif_info(np, link, dev, \"Link is up at %s, %s duplex\\n\",\n\t\t\t   lp->active_speed == SPEED_10000 ? \"10Gb/sec\" :\n\t\t\t   lp->active_speed == SPEED_1000 ? \"1Gb/sec\" :\n\t\t\t   lp->active_speed == SPEED_100 ? \"100Mbit/sec\" :\n\t\t\t   \"10Mbit/sec\",\n\t\t\t   lp->active_duplex == DUPLEX_FULL ? \"full\" : \"half\");\n\n\t\tspin_lock_irqsave(&np->lock, flags);\n\t\tniu_init_xif(np);\n\t\tniu_handle_led(np, 1);\n\t\tspin_unlock_irqrestore(&np->lock, flags);\n\n\t\tnetif_carrier_on(dev);\n\t} else if (netif_carrier_ok(dev) && !link_up) {\n\t\tnetif_warn(np, link, dev, \"Link is down\\n\");\n\t\tspin_lock_irqsave(&np->lock, flags);\n\t\tniu_handle_led(np, 0);\n\t\tspin_unlock_irqrestore(&np->lock, flags);\n\t\tnetif_carrier_off(dev);\n\t}\n\n\treturn 0;\n}\n\nstatic int link_status_10g_mrvl(struct niu *np, int *link_up_p)\n{\n\tint err, link_up, pma_status, pcs_status;\n\n\tlink_up = 0;\n\n\terr = mdio_read(np, np->phy_addr, MRVL88X2011_USER_DEV1_ADDR,\n\t\t\tMRVL88X2011_10G_PMD_STATUS_2);\n\tif (err < 0)\n\t\tgoto out;\n\n\t \n\terr = mdio_read(np, np->phy_addr, MRVL88X2011_USER_DEV1_ADDR,\n\t\t\tMRVL88X2011_PMA_PMD_STATUS_1);\n\tif (err < 0)\n\t\tgoto out;\n\n\tpma_status = ((err & MRVL88X2011_LNK_STATUS_OK) ? 1 : 0);\n\n         \n\terr = mdio_read(np, np->phy_addr, MRVL88X2011_USER_DEV3_ADDR,\n\t\t\tMRVL88X2011_PMA_PMD_STATUS_1);\n\tif (err < 0)\n\t\tgoto out;\n\n\terr = mdio_read(np, np->phy_addr, MRVL88X2011_USER_DEV3_ADDR,\n\t\t\tMRVL88X2011_PMA_PMD_STATUS_1);\n\tif (err < 0)\n\t\tgoto out;\n\n\tpcs_status = ((err & MRVL88X2011_LNK_STATUS_OK) ? 1 : 0);\n\n         \n\terr = mdio_read(np, np->phy_addr, MRVL88X2011_USER_DEV4_ADDR,\n\t\t\tMRVL88X2011_10G_XGXS_LANE_STAT);\n\tif (err < 0)\n\t\tgoto out;\n\n\tif (err == (PHYXS_XGXS_LANE_STAT_ALINGED | PHYXS_XGXS_LANE_STAT_LANE3 |\n\t\t    PHYXS_XGXS_LANE_STAT_LANE2 | PHYXS_XGXS_LANE_STAT_LANE1 |\n\t\t    PHYXS_XGXS_LANE_STAT_LANE0 | PHYXS_XGXS_LANE_STAT_MAGIC |\n\t\t    0x800))\n\t\tlink_up = (pma_status && pcs_status) ? 1 : 0;\n\n\tnp->link_config.active_speed = SPEED_10000;\n\tnp->link_config.active_duplex = DUPLEX_FULL;\n\terr = 0;\nout:\n\tmrvl88x2011_act_led(np, (link_up ?\n\t\t\t\t MRVL88X2011_LED_CTL_PCS_ACT :\n\t\t\t\t MRVL88X2011_LED_CTL_OFF));\n\n\t*link_up_p = link_up;\n\treturn err;\n}\n\nstatic int link_status_10g_bcm8706(struct niu *np, int *link_up_p)\n{\n\tint err, link_up;\n\tlink_up = 0;\n\n\terr = mdio_read(np, np->phy_addr, BCM8704_PMA_PMD_DEV_ADDR,\n\t\t\tBCM8704_PMD_RCV_SIGDET);\n\tif (err < 0 || err == 0xffff)\n\t\tgoto out;\n\tif (!(err & PMD_RCV_SIGDET_GLOBAL)) {\n\t\terr = 0;\n\t\tgoto out;\n\t}\n\n\terr = mdio_read(np, np->phy_addr, BCM8704_PCS_DEV_ADDR,\n\t\t\tBCM8704_PCS_10G_R_STATUS);\n\tif (err < 0)\n\t\tgoto out;\n\n\tif (!(err & PCS_10G_R_STATUS_BLK_LOCK)) {\n\t\terr = 0;\n\t\tgoto out;\n\t}\n\n\terr = mdio_read(np, np->phy_addr, BCM8704_PHYXS_DEV_ADDR,\n\t\t\tBCM8704_PHYXS_XGXS_LANE_STAT);\n\tif (err < 0)\n\t\tgoto out;\n\tif (err != (PHYXS_XGXS_LANE_STAT_ALINGED |\n\t\t    PHYXS_XGXS_LANE_STAT_MAGIC |\n\t\t    PHYXS_XGXS_LANE_STAT_PATTEST |\n\t\t    PHYXS_XGXS_LANE_STAT_LANE3 |\n\t\t    PHYXS_XGXS_LANE_STAT_LANE2 |\n\t\t    PHYXS_XGXS_LANE_STAT_LANE1 |\n\t\t    PHYXS_XGXS_LANE_STAT_LANE0)) {\n\t\terr = 0;\n\t\tnp->link_config.active_speed = SPEED_INVALID;\n\t\tnp->link_config.active_duplex = DUPLEX_INVALID;\n\t\tgoto out;\n\t}\n\n\tlink_up = 1;\n\tnp->link_config.active_speed = SPEED_10000;\n\tnp->link_config.active_duplex = DUPLEX_FULL;\n\terr = 0;\n\nout:\n\t*link_up_p = link_up;\n\treturn err;\n}\n\nstatic int link_status_10g_bcom(struct niu *np, int *link_up_p)\n{\n\tint err, link_up;\n\n\tlink_up = 0;\n\n\terr = mdio_read(np, np->phy_addr, BCM8704_PMA_PMD_DEV_ADDR,\n\t\t\tBCM8704_PMD_RCV_SIGDET);\n\tif (err < 0)\n\t\tgoto out;\n\tif (!(err & PMD_RCV_SIGDET_GLOBAL)) {\n\t\terr = 0;\n\t\tgoto out;\n\t}\n\n\terr = mdio_read(np, np->phy_addr, BCM8704_PCS_DEV_ADDR,\n\t\t\tBCM8704_PCS_10G_R_STATUS);\n\tif (err < 0)\n\t\tgoto out;\n\tif (!(err & PCS_10G_R_STATUS_BLK_LOCK)) {\n\t\terr = 0;\n\t\tgoto out;\n\t}\n\n\terr = mdio_read(np, np->phy_addr, BCM8704_PHYXS_DEV_ADDR,\n\t\t\tBCM8704_PHYXS_XGXS_LANE_STAT);\n\tif (err < 0)\n\t\tgoto out;\n\n\tif (err != (PHYXS_XGXS_LANE_STAT_ALINGED |\n\t\t    PHYXS_XGXS_LANE_STAT_MAGIC |\n\t\t    PHYXS_XGXS_LANE_STAT_LANE3 |\n\t\t    PHYXS_XGXS_LANE_STAT_LANE2 |\n\t\t    PHYXS_XGXS_LANE_STAT_LANE1 |\n\t\t    PHYXS_XGXS_LANE_STAT_LANE0)) {\n\t\terr = 0;\n\t\tgoto out;\n\t}\n\n\tlink_up = 1;\n\tnp->link_config.active_speed = SPEED_10000;\n\tnp->link_config.active_duplex = DUPLEX_FULL;\n\terr = 0;\n\nout:\n\t*link_up_p = link_up;\n\treturn err;\n}\n\nstatic int link_status_10g(struct niu *np, int *link_up_p)\n{\n\tunsigned long flags;\n\tint err = -EINVAL;\n\n\tspin_lock_irqsave(&np->lock, flags);\n\n\tif (np->link_config.loopback_mode == LOOPBACK_DISABLED) {\n\t\tint phy_id;\n\n\t\tphy_id = phy_decode(np->parent->port_phy, np->port);\n\t\tphy_id = np->parent->phy_probe_info.phy_id[phy_id][np->port];\n\n\t\t \n\t\tswitch (phy_id & NIU_PHY_ID_MASK) {\n\t\tcase NIU_PHY_ID_MRVL88X2011:\n\t\t\terr = link_status_10g_mrvl(np, link_up_p);\n\t\t\tbreak;\n\n\t\tdefault:  \n\t\t\terr = link_status_10g_bcom(np, link_up_p);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&np->lock, flags);\n\n\treturn err;\n}\n\nstatic int niu_10g_phy_present(struct niu *np)\n{\n\tu64 sig, mask, val;\n\n\tsig = nr64(ESR_INT_SIGNALS);\n\tswitch (np->port) {\n\tcase 0:\n\t\tmask = ESR_INT_SIGNALS_P0_BITS;\n\t\tval = (ESR_INT_SRDY0_P0 |\n\t\t       ESR_INT_DET0_P0 |\n\t\t       ESR_INT_XSRDY_P0 |\n\t\t       ESR_INT_XDP_P0_CH3 |\n\t\t       ESR_INT_XDP_P0_CH2 |\n\t\t       ESR_INT_XDP_P0_CH1 |\n\t\t       ESR_INT_XDP_P0_CH0);\n\t\tbreak;\n\n\tcase 1:\n\t\tmask = ESR_INT_SIGNALS_P1_BITS;\n\t\tval = (ESR_INT_SRDY0_P1 |\n\t\t       ESR_INT_DET0_P1 |\n\t\t       ESR_INT_XSRDY_P1 |\n\t\t       ESR_INT_XDP_P1_CH3 |\n\t\t       ESR_INT_XDP_P1_CH2 |\n\t\t       ESR_INT_XDP_P1_CH1 |\n\t\t       ESR_INT_XDP_P1_CH0);\n\t\tbreak;\n\n\tdefault:\n\t\treturn 0;\n\t}\n\n\tif ((sig & mask) != val)\n\t\treturn 0;\n\treturn 1;\n}\n\nstatic int link_status_10g_hotplug(struct niu *np, int *link_up_p)\n{\n\tunsigned long flags;\n\tint err = 0;\n\tint phy_present;\n\tint phy_present_prev;\n\n\tspin_lock_irqsave(&np->lock, flags);\n\n\tif (np->link_config.loopback_mode == LOOPBACK_DISABLED) {\n\t\tphy_present_prev = (np->flags & NIU_FLAGS_HOTPLUG_PHY_PRESENT) ?\n\t\t\t1 : 0;\n\t\tphy_present = niu_10g_phy_present(np);\n\t\tif (phy_present != phy_present_prev) {\n\t\t\t \n\t\t\tif (phy_present) {\n\t\t\t\t \n\t\t\t\tnp->flags |= NIU_FLAGS_HOTPLUG_PHY_PRESENT;\n\t\t\t\tif (np->phy_ops->xcvr_init)\n\t\t\t\t\terr = np->phy_ops->xcvr_init(np);\n\t\t\t\tif (err) {\n\t\t\t\t\terr = mdio_read(np, np->phy_addr,\n\t\t\t\t\t\tBCM8704_PHYXS_DEV_ADDR, MII_BMCR);\n\t\t\t\t\tif (err == 0xffff) {\n\t\t\t\t\t\t \n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t\t \n\t\t\t\t\tnp->flags &= ~NIU_FLAGS_HOTPLUG_PHY_PRESENT;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnp->flags &= ~NIU_FLAGS_HOTPLUG_PHY_PRESENT;\n\t\t\t\t*link_up_p = 0;\n\t\t\t\tnetif_warn(np, link, np->dev,\n\t\t\t\t\t   \"Hotplug PHY Removed\\n\");\n\t\t\t}\n\t\t}\nout:\n\t\tif (np->flags & NIU_FLAGS_HOTPLUG_PHY_PRESENT) {\n\t\t\terr = link_status_10g_bcm8706(np, link_up_p);\n\t\t\tif (err == 0xffff) {\n\t\t\t\t \n\t\t\t\t*link_up_p = 1;\n\t\t\t\tnp->link_config.active_speed = SPEED_10000;\n\t\t\t\tnp->link_config.active_duplex = DUPLEX_FULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&np->lock, flags);\n\n\treturn 0;\n}\n\nstatic int niu_link_status(struct niu *np, int *link_up_p)\n{\n\tconst struct niu_phy_ops *ops = np->phy_ops;\n\tint err;\n\n\terr = 0;\n\tif (ops->link_status)\n\t\terr = ops->link_status(np, link_up_p);\n\n\treturn err;\n}\n\nstatic void niu_timer(struct timer_list *t)\n{\n\tstruct niu *np = from_timer(np, t, timer);\n\tunsigned long off;\n\tint err, link_up;\n\n\terr = niu_link_status(np, &link_up);\n\tif (!err)\n\t\tniu_link_status_common(np, link_up);\n\n\tif (netif_carrier_ok(np->dev))\n\t\toff = 5 * HZ;\n\telse\n\t\toff = 1 * HZ;\n\tnp->timer.expires = jiffies + off;\n\n\tadd_timer(&np->timer);\n}\n\nstatic const struct niu_phy_ops phy_ops_10g_serdes = {\n\t.serdes_init\t\t= serdes_init_10g_serdes,\n\t.link_status\t\t= link_status_10g_serdes,\n};\n\nstatic const struct niu_phy_ops phy_ops_10g_serdes_niu = {\n\t.serdes_init\t\t= serdes_init_niu_10g_serdes,\n\t.link_status\t\t= link_status_10g_serdes,\n};\n\nstatic const struct niu_phy_ops phy_ops_1g_serdes_niu = {\n\t.serdes_init\t\t= serdes_init_niu_1g_serdes,\n\t.link_status\t\t= link_status_1g_serdes,\n};\n\nstatic const struct niu_phy_ops phy_ops_1g_rgmii = {\n\t.xcvr_init\t\t= xcvr_init_1g_rgmii,\n\t.link_status\t\t= link_status_1g_rgmii,\n};\n\nstatic const struct niu_phy_ops phy_ops_10g_fiber_niu = {\n\t.serdes_init\t\t= serdes_init_niu_10g_fiber,\n\t.xcvr_init\t\t= xcvr_init_10g,\n\t.link_status\t\t= link_status_10g,\n};\n\nstatic const struct niu_phy_ops phy_ops_10g_fiber = {\n\t.serdes_init\t\t= serdes_init_10g,\n\t.xcvr_init\t\t= xcvr_init_10g,\n\t.link_status\t\t= link_status_10g,\n};\n\nstatic const struct niu_phy_ops phy_ops_10g_fiber_hotplug = {\n\t.serdes_init\t\t= serdes_init_10g,\n\t.xcvr_init\t\t= xcvr_init_10g_bcm8706,\n\t.link_status\t\t= link_status_10g_hotplug,\n};\n\nstatic const struct niu_phy_ops phy_ops_niu_10g_hotplug = {\n\t.serdes_init\t\t= serdes_init_niu_10g_fiber,\n\t.xcvr_init\t\t= xcvr_init_10g_bcm8706,\n\t.link_status\t\t= link_status_10g_hotplug,\n};\n\nstatic const struct niu_phy_ops phy_ops_10g_copper = {\n\t.serdes_init\t\t= serdes_init_10g,\n\t.link_status\t\t= link_status_10g,  \n};\n\nstatic const struct niu_phy_ops phy_ops_1g_fiber = {\n\t.serdes_init\t\t= serdes_init_1g,\n\t.xcvr_init\t\t= xcvr_init_1g,\n\t.link_status\t\t= link_status_1g,\n};\n\nstatic const struct niu_phy_ops phy_ops_1g_copper = {\n\t.xcvr_init\t\t= xcvr_init_1g,\n\t.link_status\t\t= link_status_1g,\n};\n\nstruct niu_phy_template {\n\tconst struct niu_phy_ops\t*ops;\n\tu32\t\t\t\tphy_addr_base;\n};\n\nstatic const struct niu_phy_template phy_template_niu_10g_fiber = {\n\t.ops\t\t= &phy_ops_10g_fiber_niu,\n\t.phy_addr_base\t= 16,\n};\n\nstatic const struct niu_phy_template phy_template_niu_10g_serdes = {\n\t.ops\t\t= &phy_ops_10g_serdes_niu,\n\t.phy_addr_base\t= 0,\n};\n\nstatic const struct niu_phy_template phy_template_niu_1g_serdes = {\n\t.ops\t\t= &phy_ops_1g_serdes_niu,\n\t.phy_addr_base\t= 0,\n};\n\nstatic const struct niu_phy_template phy_template_10g_fiber = {\n\t.ops\t\t= &phy_ops_10g_fiber,\n\t.phy_addr_base\t= 8,\n};\n\nstatic const struct niu_phy_template phy_template_10g_fiber_hotplug = {\n\t.ops\t\t= &phy_ops_10g_fiber_hotplug,\n\t.phy_addr_base\t= 8,\n};\n\nstatic const struct niu_phy_template phy_template_niu_10g_hotplug = {\n\t.ops\t\t= &phy_ops_niu_10g_hotplug,\n\t.phy_addr_base\t= 8,\n};\n\nstatic const struct niu_phy_template phy_template_10g_copper = {\n\t.ops\t\t= &phy_ops_10g_copper,\n\t.phy_addr_base\t= 10,\n};\n\nstatic const struct niu_phy_template phy_template_1g_fiber = {\n\t.ops\t\t= &phy_ops_1g_fiber,\n\t.phy_addr_base\t= 0,\n};\n\nstatic const struct niu_phy_template phy_template_1g_copper = {\n\t.ops\t\t= &phy_ops_1g_copper,\n\t.phy_addr_base\t= 0,\n};\n\nstatic const struct niu_phy_template phy_template_1g_rgmii = {\n\t.ops\t\t= &phy_ops_1g_rgmii,\n\t.phy_addr_base\t= 0,\n};\n\nstatic const struct niu_phy_template phy_template_10g_serdes = {\n\t.ops\t\t= &phy_ops_10g_serdes,\n\t.phy_addr_base\t= 0,\n};\n\nstatic int niu_atca_port_num[4] = {\n\t0, 0,  11, 10\n};\n\nstatic int serdes_init_10g_serdes(struct niu *np)\n{\n\tstruct niu_link_config *lp = &np->link_config;\n\tunsigned long ctrl_reg, test_cfg_reg, pll_cfg, i;\n\tu64 ctrl_val, test_cfg_val, sig, mask, val;\n\n\tswitch (np->port) {\n\tcase 0:\n\t\tctrl_reg = ENET_SERDES_0_CTRL_CFG;\n\t\ttest_cfg_reg = ENET_SERDES_0_TEST_CFG;\n\t\tpll_cfg = ENET_SERDES_0_PLL_CFG;\n\t\tbreak;\n\tcase 1:\n\t\tctrl_reg = ENET_SERDES_1_CTRL_CFG;\n\t\ttest_cfg_reg = ENET_SERDES_1_TEST_CFG;\n\t\tpll_cfg = ENET_SERDES_1_PLL_CFG;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tctrl_val = (ENET_SERDES_CTRL_SDET_0 |\n\t\t    ENET_SERDES_CTRL_SDET_1 |\n\t\t    ENET_SERDES_CTRL_SDET_2 |\n\t\t    ENET_SERDES_CTRL_SDET_3 |\n\t\t    (0x5 << ENET_SERDES_CTRL_EMPH_0_SHIFT) |\n\t\t    (0x5 << ENET_SERDES_CTRL_EMPH_1_SHIFT) |\n\t\t    (0x5 << ENET_SERDES_CTRL_EMPH_2_SHIFT) |\n\t\t    (0x5 << ENET_SERDES_CTRL_EMPH_3_SHIFT) |\n\t\t    (0x1 << ENET_SERDES_CTRL_LADJ_0_SHIFT) |\n\t\t    (0x1 << ENET_SERDES_CTRL_LADJ_1_SHIFT) |\n\t\t    (0x1 << ENET_SERDES_CTRL_LADJ_2_SHIFT) |\n\t\t    (0x1 << ENET_SERDES_CTRL_LADJ_3_SHIFT));\n\ttest_cfg_val = 0;\n\n\tif (lp->loopback_mode == LOOPBACK_PHY) {\n\t\ttest_cfg_val |= ((ENET_TEST_MD_PAD_LOOPBACK <<\n\t\t\t\t  ENET_SERDES_TEST_MD_0_SHIFT) |\n\t\t\t\t (ENET_TEST_MD_PAD_LOOPBACK <<\n\t\t\t\t  ENET_SERDES_TEST_MD_1_SHIFT) |\n\t\t\t\t (ENET_TEST_MD_PAD_LOOPBACK <<\n\t\t\t\t  ENET_SERDES_TEST_MD_2_SHIFT) |\n\t\t\t\t (ENET_TEST_MD_PAD_LOOPBACK <<\n\t\t\t\t  ENET_SERDES_TEST_MD_3_SHIFT));\n\t}\n\n\tesr_reset(np);\n\tnw64(pll_cfg, ENET_SERDES_PLL_FBDIV2);\n\tnw64(ctrl_reg, ctrl_val);\n\tnw64(test_cfg_reg, test_cfg_val);\n\n\t \n\tfor (i = 0; i < 4; i++) {\n\t\tu32 rxtx_ctrl, glue0;\n\t\tint err;\n\n\t\terr = esr_read_rxtx_ctrl(np, i, &rxtx_ctrl);\n\t\tif (err)\n\t\t\treturn err;\n\t\terr = esr_read_glue0(np, i, &glue0);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\trxtx_ctrl &= ~(ESR_RXTX_CTRL_VMUXLO);\n\t\trxtx_ctrl |= (ESR_RXTX_CTRL_ENSTRETCH |\n\t\t\t      (2 << ESR_RXTX_CTRL_VMUXLO_SHIFT));\n\n\t\tglue0 &= ~(ESR_GLUE_CTRL0_SRATE |\n\t\t\t   ESR_GLUE_CTRL0_THCNT |\n\t\t\t   ESR_GLUE_CTRL0_BLTIME);\n\t\tglue0 |= (ESR_GLUE_CTRL0_RXLOSENAB |\n\t\t\t  (0xf << ESR_GLUE_CTRL0_SRATE_SHIFT) |\n\t\t\t  (0xff << ESR_GLUE_CTRL0_THCNT_SHIFT) |\n\t\t\t  (BLTIME_300_CYCLES <<\n\t\t\t   ESR_GLUE_CTRL0_BLTIME_SHIFT));\n\n\t\terr = esr_write_rxtx_ctrl(np, i, rxtx_ctrl);\n\t\tif (err)\n\t\t\treturn err;\n\t\terr = esr_write_glue0(np, i, glue0);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\n\tsig = nr64(ESR_INT_SIGNALS);\n\tswitch (np->port) {\n\tcase 0:\n\t\tmask = ESR_INT_SIGNALS_P0_BITS;\n\t\tval = (ESR_INT_SRDY0_P0 |\n\t\t       ESR_INT_DET0_P0 |\n\t\t       ESR_INT_XSRDY_P0 |\n\t\t       ESR_INT_XDP_P0_CH3 |\n\t\t       ESR_INT_XDP_P0_CH2 |\n\t\t       ESR_INT_XDP_P0_CH1 |\n\t\t       ESR_INT_XDP_P0_CH0);\n\t\tbreak;\n\n\tcase 1:\n\t\tmask = ESR_INT_SIGNALS_P1_BITS;\n\t\tval = (ESR_INT_SRDY0_P1 |\n\t\t       ESR_INT_DET0_P1 |\n\t\t       ESR_INT_XSRDY_P1 |\n\t\t       ESR_INT_XDP_P1_CH3 |\n\t\t       ESR_INT_XDP_P1_CH2 |\n\t\t       ESR_INT_XDP_P1_CH1 |\n\t\t       ESR_INT_XDP_P1_CH0);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif ((sig & mask) != val) {\n\t\tint err;\n\t\terr = serdes_init_1g_serdes(np);\n\t\tif (!err) {\n\t\t\tnp->flags &= ~NIU_FLAGS_10G;\n\t\t\tnp->mac_xcvr = MAC_XCVR_PCS;\n\t\t}  else {\n\t\t\tnetdev_err(np->dev, \"Port %u 10G/1G SERDES Link Failed\\n\",\n\t\t\t\t   np->port);\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int niu_determine_phy_disposition(struct niu *np)\n{\n\tstruct niu_parent *parent = np->parent;\n\tu8 plat_type = parent->plat_type;\n\tconst struct niu_phy_template *tp;\n\tu32 phy_addr_off = 0;\n\n\tif (plat_type == PLAT_TYPE_NIU) {\n\t\tswitch (np->flags &\n\t\t\t(NIU_FLAGS_10G |\n\t\t\t NIU_FLAGS_FIBER |\n\t\t\t NIU_FLAGS_XCVR_SERDES)) {\n\t\tcase NIU_FLAGS_10G | NIU_FLAGS_XCVR_SERDES:\n\t\t\t \n\t\t\ttp = &phy_template_niu_10g_serdes;\n\t\t\tbreak;\n\t\tcase NIU_FLAGS_XCVR_SERDES:\n\t\t\t \n\t\t\ttp = &phy_template_niu_1g_serdes;\n\t\t\tbreak;\n\t\tcase NIU_FLAGS_10G | NIU_FLAGS_FIBER:\n\t\t\t \n\t\tdefault:\n\t\t\tif (np->flags & NIU_FLAGS_HOTPLUG_PHY) {\n\t\t\t\ttp = &phy_template_niu_10g_hotplug;\n\t\t\t\tif (np->port == 0)\n\t\t\t\t\tphy_addr_off = 8;\n\t\t\t\tif (np->port == 1)\n\t\t\t\t\tphy_addr_off = 12;\n\t\t\t} else {\n\t\t\t\ttp = &phy_template_niu_10g_fiber;\n\t\t\t\tphy_addr_off += np->port;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tswitch (np->flags &\n\t\t\t(NIU_FLAGS_10G |\n\t\t\t NIU_FLAGS_FIBER |\n\t\t\t NIU_FLAGS_XCVR_SERDES)) {\n\t\tcase 0:\n\t\t\t \n\t\t\ttp = &phy_template_1g_copper;\n\t\t\tif (plat_type == PLAT_TYPE_VF_P0)\n\t\t\t\tphy_addr_off = 10;\n\t\t\telse if (plat_type == PLAT_TYPE_VF_P1)\n\t\t\t\tphy_addr_off = 26;\n\n\t\t\tphy_addr_off += (np->port ^ 0x3);\n\t\t\tbreak;\n\n\t\tcase NIU_FLAGS_10G:\n\t\t\t \n\t\t\ttp = &phy_template_10g_copper;\n\t\t\tbreak;\n\n\t\tcase NIU_FLAGS_FIBER:\n\t\t\t \n\t\t\ttp = &phy_template_1g_fiber;\n\t\t\tbreak;\n\n\t\tcase NIU_FLAGS_10G | NIU_FLAGS_FIBER:\n\t\t\t \n\t\t\ttp = &phy_template_10g_fiber;\n\t\t\tif (plat_type == PLAT_TYPE_VF_P0 ||\n\t\t\t    plat_type == PLAT_TYPE_VF_P1)\n\t\t\t\tphy_addr_off = 8;\n\t\t\tphy_addr_off += np->port;\n\t\t\tif (np->flags & NIU_FLAGS_HOTPLUG_PHY) {\n\t\t\t\ttp = &phy_template_10g_fiber_hotplug;\n\t\t\t\tif (np->port == 0)\n\t\t\t\t\tphy_addr_off = 8;\n\t\t\t\tif (np->port == 1)\n\t\t\t\t\tphy_addr_off = 12;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase NIU_FLAGS_10G | NIU_FLAGS_XCVR_SERDES:\n\t\tcase NIU_FLAGS_XCVR_SERDES | NIU_FLAGS_FIBER:\n\t\tcase NIU_FLAGS_XCVR_SERDES:\n\t\t\tswitch(np->port) {\n\t\t\tcase 0:\n\t\t\tcase 1:\n\t\t\t\ttp = &phy_template_10g_serdes;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\tcase 3:\n\t\t\t\ttp = &phy_template_1g_rgmii;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tphy_addr_off = niu_atca_port_num[np->port];\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tnp->phy_ops = tp->ops;\n\tnp->phy_addr = tp->phy_addr_base + phy_addr_off;\n\n\treturn 0;\n}\n\nstatic int niu_init_link(struct niu *np)\n{\n\tstruct niu_parent *parent = np->parent;\n\tint err, ignore;\n\n\tif (parent->plat_type == PLAT_TYPE_NIU) {\n\t\terr = niu_xcvr_init(np);\n\t\tif (err)\n\t\t\treturn err;\n\t\tmsleep(200);\n\t}\n\terr = niu_serdes_init(np);\n\tif (err && !(np->flags & NIU_FLAGS_HOTPLUG_PHY))\n\t\treturn err;\n\tmsleep(200);\n\terr = niu_xcvr_init(np);\n\tif (!err || (np->flags & NIU_FLAGS_HOTPLUG_PHY))\n\t\tniu_link_status(np, &ignore);\n\treturn 0;\n}\n\nstatic void niu_set_primary_mac(struct niu *np, const unsigned char *addr)\n{\n\tu16 reg0 = addr[4] << 8 | addr[5];\n\tu16 reg1 = addr[2] << 8 | addr[3];\n\tu16 reg2 = addr[0] << 8 | addr[1];\n\n\tif (np->flags & NIU_FLAGS_XMAC) {\n\t\tnw64_mac(XMAC_ADDR0, reg0);\n\t\tnw64_mac(XMAC_ADDR1, reg1);\n\t\tnw64_mac(XMAC_ADDR2, reg2);\n\t} else {\n\t\tnw64_mac(BMAC_ADDR0, reg0);\n\t\tnw64_mac(BMAC_ADDR1, reg1);\n\t\tnw64_mac(BMAC_ADDR2, reg2);\n\t}\n}\n\nstatic int niu_num_alt_addr(struct niu *np)\n{\n\tif (np->flags & NIU_FLAGS_XMAC)\n\t\treturn XMAC_NUM_ALT_ADDR;\n\telse\n\t\treturn BMAC_NUM_ALT_ADDR;\n}\n\nstatic int niu_set_alt_mac(struct niu *np, int index, unsigned char *addr)\n{\n\tu16 reg0 = addr[4] << 8 | addr[5];\n\tu16 reg1 = addr[2] << 8 | addr[3];\n\tu16 reg2 = addr[0] << 8 | addr[1];\n\n\tif (index >= niu_num_alt_addr(np))\n\t\treturn -EINVAL;\n\n\tif (np->flags & NIU_FLAGS_XMAC) {\n\t\tnw64_mac(XMAC_ALT_ADDR0(index), reg0);\n\t\tnw64_mac(XMAC_ALT_ADDR1(index), reg1);\n\t\tnw64_mac(XMAC_ALT_ADDR2(index), reg2);\n\t} else {\n\t\tnw64_mac(BMAC_ALT_ADDR0(index), reg0);\n\t\tnw64_mac(BMAC_ALT_ADDR1(index), reg1);\n\t\tnw64_mac(BMAC_ALT_ADDR2(index), reg2);\n\t}\n\n\treturn 0;\n}\n\nstatic int niu_enable_alt_mac(struct niu *np, int index, int on)\n{\n\tunsigned long reg;\n\tu64 val, mask;\n\n\tif (index >= niu_num_alt_addr(np))\n\t\treturn -EINVAL;\n\n\tif (np->flags & NIU_FLAGS_XMAC) {\n\t\treg = XMAC_ADDR_CMPEN;\n\t\tmask = 1 << index;\n\t} else {\n\t\treg = BMAC_ADDR_CMPEN;\n\t\tmask = 1 << (index + 1);\n\t}\n\n\tval = nr64_mac(reg);\n\tif (on)\n\t\tval |= mask;\n\telse\n\t\tval &= ~mask;\n\tnw64_mac(reg, val);\n\n\treturn 0;\n}\n\nstatic void __set_rdc_table_num_hw(struct niu *np, unsigned long reg,\n\t\t\t\t   int num, int mac_pref)\n{\n\tu64 val = nr64_mac(reg);\n\tval &= ~(HOST_INFO_MACRDCTBLN | HOST_INFO_MPR);\n\tval |= num;\n\tif (mac_pref)\n\t\tval |= HOST_INFO_MPR;\n\tnw64_mac(reg, val);\n}\n\nstatic int __set_rdc_table_num(struct niu *np,\n\t\t\t       int xmac_index, int bmac_index,\n\t\t\t       int rdc_table_num, int mac_pref)\n{\n\tunsigned long reg;\n\n\tif (rdc_table_num & ~HOST_INFO_MACRDCTBLN)\n\t\treturn -EINVAL;\n\tif (np->flags & NIU_FLAGS_XMAC)\n\t\treg = XMAC_HOST_INFO(xmac_index);\n\telse\n\t\treg = BMAC_HOST_INFO(bmac_index);\n\t__set_rdc_table_num_hw(np, reg, rdc_table_num, mac_pref);\n\treturn 0;\n}\n\nstatic int niu_set_primary_mac_rdc_table(struct niu *np, int table_num,\n\t\t\t\t\t int mac_pref)\n{\n\treturn __set_rdc_table_num(np, 17, 0, table_num, mac_pref);\n}\n\nstatic int niu_set_multicast_mac_rdc_table(struct niu *np, int table_num,\n\t\t\t\t\t   int mac_pref)\n{\n\treturn __set_rdc_table_num(np, 16, 8, table_num, mac_pref);\n}\n\nstatic int niu_set_alt_mac_rdc_table(struct niu *np, int idx,\n\t\t\t\t     int table_num, int mac_pref)\n{\n\tif (idx >= niu_num_alt_addr(np))\n\t\treturn -EINVAL;\n\treturn __set_rdc_table_num(np, idx, idx + 1, table_num, mac_pref);\n}\n\nstatic u64 vlan_entry_set_parity(u64 reg_val)\n{\n\tu64 port01_mask;\n\tu64 port23_mask;\n\n\tport01_mask = 0x00ff;\n\tport23_mask = 0xff00;\n\n\tif (hweight64(reg_val & port01_mask) & 1)\n\t\treg_val |= ENET_VLAN_TBL_PARITY0;\n\telse\n\t\treg_val &= ~ENET_VLAN_TBL_PARITY0;\n\n\tif (hweight64(reg_val & port23_mask) & 1)\n\t\treg_val |= ENET_VLAN_TBL_PARITY1;\n\telse\n\t\treg_val &= ~ENET_VLAN_TBL_PARITY1;\n\n\treturn reg_val;\n}\n\nstatic void vlan_tbl_write(struct niu *np, unsigned long index,\n\t\t\t   int port, int vpr, int rdc_table)\n{\n\tu64 reg_val = nr64(ENET_VLAN_TBL(index));\n\n\treg_val &= ~((ENET_VLAN_TBL_VPR |\n\t\t      ENET_VLAN_TBL_VLANRDCTBLN) <<\n\t\t     ENET_VLAN_TBL_SHIFT(port));\n\tif (vpr)\n\t\treg_val |= (ENET_VLAN_TBL_VPR <<\n\t\t\t    ENET_VLAN_TBL_SHIFT(port));\n\treg_val |= (rdc_table << ENET_VLAN_TBL_SHIFT(port));\n\n\treg_val = vlan_entry_set_parity(reg_val);\n\n\tnw64(ENET_VLAN_TBL(index), reg_val);\n}\n\nstatic void vlan_tbl_clear(struct niu *np)\n{\n\tint i;\n\n\tfor (i = 0; i < ENET_VLAN_TBL_NUM_ENTRIES; i++)\n\t\tnw64(ENET_VLAN_TBL(i), 0);\n}\n\nstatic int tcam_wait_bit(struct niu *np, u64 bit)\n{\n\tint limit = 1000;\n\n\twhile (--limit > 0) {\n\t\tif (nr64(TCAM_CTL) & bit)\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\tif (limit <= 0)\n\t\treturn -ENODEV;\n\n\treturn 0;\n}\n\nstatic int tcam_flush(struct niu *np, int index)\n{\n\tnw64(TCAM_KEY_0, 0x00);\n\tnw64(TCAM_KEY_MASK_0, 0xff);\n\tnw64(TCAM_CTL, (TCAM_CTL_RWC_TCAM_WRITE | index));\n\n\treturn tcam_wait_bit(np, TCAM_CTL_STAT);\n}\n\n#if 0\nstatic int tcam_read(struct niu *np, int index,\n\t\t     u64 *key, u64 *mask)\n{\n\tint err;\n\n\tnw64(TCAM_CTL, (TCAM_CTL_RWC_TCAM_READ | index));\n\terr = tcam_wait_bit(np, TCAM_CTL_STAT);\n\tif (!err) {\n\t\tkey[0] = nr64(TCAM_KEY_0);\n\t\tkey[1] = nr64(TCAM_KEY_1);\n\t\tkey[2] = nr64(TCAM_KEY_2);\n\t\tkey[3] = nr64(TCAM_KEY_3);\n\t\tmask[0] = nr64(TCAM_KEY_MASK_0);\n\t\tmask[1] = nr64(TCAM_KEY_MASK_1);\n\t\tmask[2] = nr64(TCAM_KEY_MASK_2);\n\t\tmask[3] = nr64(TCAM_KEY_MASK_3);\n\t}\n\treturn err;\n}\n#endif\n\nstatic int tcam_write(struct niu *np, int index,\n\t\t      u64 *key, u64 *mask)\n{\n\tnw64(TCAM_KEY_0, key[0]);\n\tnw64(TCAM_KEY_1, key[1]);\n\tnw64(TCAM_KEY_2, key[2]);\n\tnw64(TCAM_KEY_3, key[3]);\n\tnw64(TCAM_KEY_MASK_0, mask[0]);\n\tnw64(TCAM_KEY_MASK_1, mask[1]);\n\tnw64(TCAM_KEY_MASK_2, mask[2]);\n\tnw64(TCAM_KEY_MASK_3, mask[3]);\n\tnw64(TCAM_CTL, (TCAM_CTL_RWC_TCAM_WRITE | index));\n\n\treturn tcam_wait_bit(np, TCAM_CTL_STAT);\n}\n\n#if 0\nstatic int tcam_assoc_read(struct niu *np, int index, u64 *data)\n{\n\tint err;\n\n\tnw64(TCAM_CTL, (TCAM_CTL_RWC_RAM_READ | index));\n\terr = tcam_wait_bit(np, TCAM_CTL_STAT);\n\tif (!err)\n\t\t*data = nr64(TCAM_KEY_1);\n\n\treturn err;\n}\n#endif\n\nstatic int tcam_assoc_write(struct niu *np, int index, u64 assoc_data)\n{\n\tnw64(TCAM_KEY_1, assoc_data);\n\tnw64(TCAM_CTL, (TCAM_CTL_RWC_RAM_WRITE | index));\n\n\treturn tcam_wait_bit(np, TCAM_CTL_STAT);\n}\n\nstatic void tcam_enable(struct niu *np, int on)\n{\n\tu64 val = nr64(FFLP_CFG_1);\n\n\tif (on)\n\t\tval &= ~FFLP_CFG_1_TCAM_DIS;\n\telse\n\t\tval |= FFLP_CFG_1_TCAM_DIS;\n\tnw64(FFLP_CFG_1, val);\n}\n\nstatic void tcam_set_lat_and_ratio(struct niu *np, u64 latency, u64 ratio)\n{\n\tu64 val = nr64(FFLP_CFG_1);\n\n\tval &= ~(FFLP_CFG_1_FFLPINITDONE |\n\t\t FFLP_CFG_1_CAMLAT |\n\t\t FFLP_CFG_1_CAMRATIO);\n\tval |= (latency << FFLP_CFG_1_CAMLAT_SHIFT);\n\tval |= (ratio << FFLP_CFG_1_CAMRATIO_SHIFT);\n\tnw64(FFLP_CFG_1, val);\n\n\tval = nr64(FFLP_CFG_1);\n\tval |= FFLP_CFG_1_FFLPINITDONE;\n\tnw64(FFLP_CFG_1, val);\n}\n\nstatic int tcam_user_eth_class_enable(struct niu *np, unsigned long class,\n\t\t\t\t      int on)\n{\n\tunsigned long reg;\n\tu64 val;\n\n\tif (class < CLASS_CODE_ETHERTYPE1 ||\n\t    class > CLASS_CODE_ETHERTYPE2)\n\t\treturn -EINVAL;\n\n\treg = L2_CLS(class - CLASS_CODE_ETHERTYPE1);\n\tval = nr64(reg);\n\tif (on)\n\t\tval |= L2_CLS_VLD;\n\telse\n\t\tval &= ~L2_CLS_VLD;\n\tnw64(reg, val);\n\n\treturn 0;\n}\n\n#if 0\nstatic int tcam_user_eth_class_set(struct niu *np, unsigned long class,\n\t\t\t\t   u64 ether_type)\n{\n\tunsigned long reg;\n\tu64 val;\n\n\tif (class < CLASS_CODE_ETHERTYPE1 ||\n\t    class > CLASS_CODE_ETHERTYPE2 ||\n\t    (ether_type & ~(u64)0xffff) != 0)\n\t\treturn -EINVAL;\n\n\treg = L2_CLS(class - CLASS_CODE_ETHERTYPE1);\n\tval = nr64(reg);\n\tval &= ~L2_CLS_ETYPE;\n\tval |= (ether_type << L2_CLS_ETYPE_SHIFT);\n\tnw64(reg, val);\n\n\treturn 0;\n}\n#endif\n\nstatic int tcam_user_ip_class_enable(struct niu *np, unsigned long class,\n\t\t\t\t     int on)\n{\n\tunsigned long reg;\n\tu64 val;\n\n\tif (class < CLASS_CODE_USER_PROG1 ||\n\t    class > CLASS_CODE_USER_PROG4)\n\t\treturn -EINVAL;\n\n\treg = L3_CLS(class - CLASS_CODE_USER_PROG1);\n\tval = nr64(reg);\n\tif (on)\n\t\tval |= L3_CLS_VALID;\n\telse\n\t\tval &= ~L3_CLS_VALID;\n\tnw64(reg, val);\n\n\treturn 0;\n}\n\nstatic int tcam_user_ip_class_set(struct niu *np, unsigned long class,\n\t\t\t\t  int ipv6, u64 protocol_id,\n\t\t\t\t  u64 tos_mask, u64 tos_val)\n{\n\tunsigned long reg;\n\tu64 val;\n\n\tif (class < CLASS_CODE_USER_PROG1 ||\n\t    class > CLASS_CODE_USER_PROG4 ||\n\t    (protocol_id & ~(u64)0xff) != 0 ||\n\t    (tos_mask & ~(u64)0xff) != 0 ||\n\t    (tos_val & ~(u64)0xff) != 0)\n\t\treturn -EINVAL;\n\n\treg = L3_CLS(class - CLASS_CODE_USER_PROG1);\n\tval = nr64(reg);\n\tval &= ~(L3_CLS_IPVER | L3_CLS_PID |\n\t\t L3_CLS_TOSMASK | L3_CLS_TOS);\n\tif (ipv6)\n\t\tval |= L3_CLS_IPVER;\n\tval |= (protocol_id << L3_CLS_PID_SHIFT);\n\tval |= (tos_mask << L3_CLS_TOSMASK_SHIFT);\n\tval |= (tos_val << L3_CLS_TOS_SHIFT);\n\tnw64(reg, val);\n\n\treturn 0;\n}\n\nstatic int tcam_early_init(struct niu *np)\n{\n\tunsigned long i;\n\tint err;\n\n\ttcam_enable(np, 0);\n\ttcam_set_lat_and_ratio(np,\n\t\t\t       DEFAULT_TCAM_LATENCY,\n\t\t\t       DEFAULT_TCAM_ACCESS_RATIO);\n\tfor (i = CLASS_CODE_ETHERTYPE1; i <= CLASS_CODE_ETHERTYPE2; i++) {\n\t\terr = tcam_user_eth_class_enable(np, i, 0);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tfor (i = CLASS_CODE_USER_PROG1; i <= CLASS_CODE_USER_PROG4; i++) {\n\t\terr = tcam_user_ip_class_enable(np, i, 0);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int tcam_flush_all(struct niu *np)\n{\n\tunsigned long i;\n\n\tfor (i = 0; i < np->parent->tcam_num_entries; i++) {\n\t\tint err = tcam_flush(np, i);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n\nstatic u64 hash_addr_regval(unsigned long index, unsigned long num_entries)\n{\n\treturn (u64)index | (num_entries == 1 ? HASH_TBL_ADDR_AUTOINC : 0);\n}\n\n#if 0\nstatic int hash_read(struct niu *np, unsigned long partition,\n\t\t     unsigned long index, unsigned long num_entries,\n\t\t     u64 *data)\n{\n\tu64 val = hash_addr_regval(index, num_entries);\n\tunsigned long i;\n\n\tif (partition >= FCRAM_NUM_PARTITIONS ||\n\t    index + num_entries > FCRAM_SIZE)\n\t\treturn -EINVAL;\n\n\tnw64(HASH_TBL_ADDR(partition), val);\n\tfor (i = 0; i < num_entries; i++)\n\t\tdata[i] = nr64(HASH_TBL_DATA(partition));\n\n\treturn 0;\n}\n#endif\n\nstatic int hash_write(struct niu *np, unsigned long partition,\n\t\t      unsigned long index, unsigned long num_entries,\n\t\t      u64 *data)\n{\n\tu64 val = hash_addr_regval(index, num_entries);\n\tunsigned long i;\n\n\tif (partition >= FCRAM_NUM_PARTITIONS ||\n\t    index + (num_entries * 8) > FCRAM_SIZE)\n\t\treturn -EINVAL;\n\n\tnw64(HASH_TBL_ADDR(partition), val);\n\tfor (i = 0; i < num_entries; i++)\n\t\tnw64(HASH_TBL_DATA(partition), data[i]);\n\n\treturn 0;\n}\n\nstatic void fflp_reset(struct niu *np)\n{\n\tu64 val;\n\n\tnw64(FFLP_CFG_1, FFLP_CFG_1_PIO_FIO_RST);\n\tudelay(10);\n\tnw64(FFLP_CFG_1, 0);\n\n\tval = FFLP_CFG_1_FCRAMOUTDR_NORMAL | FFLP_CFG_1_FFLPINITDONE;\n\tnw64(FFLP_CFG_1, val);\n}\n\nstatic void fflp_set_timings(struct niu *np)\n{\n\tu64 val = nr64(FFLP_CFG_1);\n\n\tval &= ~FFLP_CFG_1_FFLPINITDONE;\n\tval |= (DEFAULT_FCRAMRATIO << FFLP_CFG_1_FCRAMRATIO_SHIFT);\n\tnw64(FFLP_CFG_1, val);\n\n\tval = nr64(FFLP_CFG_1);\n\tval |= FFLP_CFG_1_FFLPINITDONE;\n\tnw64(FFLP_CFG_1, val);\n\n\tval = nr64(FCRAM_REF_TMR);\n\tval &= ~(FCRAM_REF_TMR_MAX | FCRAM_REF_TMR_MIN);\n\tval |= (DEFAULT_FCRAM_REFRESH_MAX << FCRAM_REF_TMR_MAX_SHIFT);\n\tval |= (DEFAULT_FCRAM_REFRESH_MIN << FCRAM_REF_TMR_MIN_SHIFT);\n\tnw64(FCRAM_REF_TMR, val);\n}\n\nstatic int fflp_set_partition(struct niu *np, u64 partition,\n\t\t\t      u64 mask, u64 base, int enable)\n{\n\tunsigned long reg;\n\tu64 val;\n\n\tif (partition >= FCRAM_NUM_PARTITIONS ||\n\t    (mask & ~(u64)0x1f) != 0 ||\n\t    (base & ~(u64)0x1f) != 0)\n\t\treturn -EINVAL;\n\n\treg = FLW_PRT_SEL(partition);\n\n\tval = nr64(reg);\n\tval &= ~(FLW_PRT_SEL_EXT | FLW_PRT_SEL_MASK | FLW_PRT_SEL_BASE);\n\tval |= (mask << FLW_PRT_SEL_MASK_SHIFT);\n\tval |= (base << FLW_PRT_SEL_BASE_SHIFT);\n\tif (enable)\n\t\tval |= FLW_PRT_SEL_EXT;\n\tnw64(reg, val);\n\n\treturn 0;\n}\n\nstatic int fflp_disable_all_partitions(struct niu *np)\n{\n\tunsigned long i;\n\n\tfor (i = 0; i < FCRAM_NUM_PARTITIONS; i++) {\n\t\tint err = fflp_set_partition(np, 0, 0, 0, 0);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n\nstatic void fflp_llcsnap_enable(struct niu *np, int on)\n{\n\tu64 val = nr64(FFLP_CFG_1);\n\n\tif (on)\n\t\tval |= FFLP_CFG_1_LLCSNAP;\n\telse\n\t\tval &= ~FFLP_CFG_1_LLCSNAP;\n\tnw64(FFLP_CFG_1, val);\n}\n\nstatic void fflp_errors_enable(struct niu *np, int on)\n{\n\tu64 val = nr64(FFLP_CFG_1);\n\n\tif (on)\n\t\tval &= ~FFLP_CFG_1_ERRORDIS;\n\telse\n\t\tval |= FFLP_CFG_1_ERRORDIS;\n\tnw64(FFLP_CFG_1, val);\n}\n\nstatic int fflp_hash_clear(struct niu *np)\n{\n\tstruct fcram_hash_ipv4 ent;\n\tunsigned long i;\n\n\t \n\tmemset(&ent, 0, sizeof(ent));\n\tent.header = HASH_HEADER_EXT;\n\n\tfor (i = 0; i < FCRAM_SIZE; i += sizeof(ent)) {\n\t\tint err = hash_write(np, 0, i, 1, (u64 *) &ent);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n\nstatic int fflp_early_init(struct niu *np)\n{\n\tstruct niu_parent *parent;\n\tunsigned long flags;\n\tint err;\n\n\tniu_lock_parent(np, flags);\n\n\tparent = np->parent;\n\terr = 0;\n\tif (!(parent->flags & PARENT_FLGS_CLS_HWINIT)) {\n\t\tif (np->parent->plat_type != PLAT_TYPE_NIU) {\n\t\t\tfflp_reset(np);\n\t\t\tfflp_set_timings(np);\n\t\t\terr = fflp_disable_all_partitions(np);\n\t\t\tif (err) {\n\t\t\t\tnetif_printk(np, probe, KERN_DEBUG, np->dev,\n\t\t\t\t\t     \"fflp_disable_all_partitions failed, err=%d\\n\",\n\t\t\t\t\t     err);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\terr = tcam_early_init(np);\n\t\tif (err) {\n\t\t\tnetif_printk(np, probe, KERN_DEBUG, np->dev,\n\t\t\t\t     \"tcam_early_init failed, err=%d\\n\", err);\n\t\t\tgoto out;\n\t\t}\n\t\tfflp_llcsnap_enable(np, 1);\n\t\tfflp_errors_enable(np, 0);\n\t\tnw64(H1POLY, 0);\n\t\tnw64(H2POLY, 0);\n\n\t\terr = tcam_flush_all(np);\n\t\tif (err) {\n\t\t\tnetif_printk(np, probe, KERN_DEBUG, np->dev,\n\t\t\t\t     \"tcam_flush_all failed, err=%d\\n\", err);\n\t\t\tgoto out;\n\t\t}\n\t\tif (np->parent->plat_type != PLAT_TYPE_NIU) {\n\t\t\terr = fflp_hash_clear(np);\n\t\t\tif (err) {\n\t\t\t\tnetif_printk(np, probe, KERN_DEBUG, np->dev,\n\t\t\t\t\t     \"fflp_hash_clear failed, err=%d\\n\",\n\t\t\t\t\t     err);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tvlan_tbl_clear(np);\n\n\t\tparent->flags |= PARENT_FLGS_CLS_HWINIT;\n\t}\nout:\n\tniu_unlock_parent(np, flags);\n\treturn err;\n}\n\nstatic int niu_set_flow_key(struct niu *np, unsigned long class_code, u64 key)\n{\n\tif (class_code < CLASS_CODE_USER_PROG1 ||\n\t    class_code > CLASS_CODE_SCTP_IPV6)\n\t\treturn -EINVAL;\n\n\tnw64(FLOW_KEY(class_code - CLASS_CODE_USER_PROG1), key);\n\treturn 0;\n}\n\nstatic int niu_set_tcam_key(struct niu *np, unsigned long class_code, u64 key)\n{\n\tif (class_code < CLASS_CODE_USER_PROG1 ||\n\t    class_code > CLASS_CODE_SCTP_IPV6)\n\t\treturn -EINVAL;\n\n\tnw64(TCAM_KEY(class_code - CLASS_CODE_USER_PROG1), key);\n\treturn 0;\n}\n\n \nstatic u16 tcam_get_index(struct niu *np, u16 idx)\n{\n\t \n\tif (idx >= (np->clas.tcam_sz - 1))\n\t\tidx = 0;\n\treturn np->clas.tcam_top + ((idx+1) * np->parent->num_ports);\n}\n\nstatic u16 tcam_get_size(struct niu *np)\n{\n\t \n\treturn np->clas.tcam_sz - 1;\n}\n\nstatic u16 tcam_get_valid_entry_cnt(struct niu *np)\n{\n\t \n\treturn np->clas.tcam_valid_entries - 1;\n}\n\nstatic void niu_rx_skb_append(struct sk_buff *skb, struct page *page,\n\t\t\t      u32 offset, u32 size, u32 truesize)\n{\n\tskb_fill_page_desc(skb, skb_shinfo(skb)->nr_frags, page, offset, size);\n\n\tskb->len += size;\n\tskb->data_len += size;\n\tskb->truesize += truesize;\n}\n\nstatic unsigned int niu_hash_rxaddr(struct rx_ring_info *rp, u64 a)\n{\n\ta >>= PAGE_SHIFT;\n\ta ^= (a >> ilog2(MAX_RBR_RING_SIZE));\n\n\treturn a & (MAX_RBR_RING_SIZE - 1);\n}\n\nstatic struct page *niu_find_rxpage(struct rx_ring_info *rp, u64 addr,\n\t\t\t\t    struct page ***link)\n{\n\tunsigned int h = niu_hash_rxaddr(rp, addr);\n\tstruct page *p, **pp;\n\n\taddr &= PAGE_MASK;\n\tpp = &rp->rxhash[h];\n\tfor (; (p = *pp) != NULL; pp = &niu_next_page(p)) {\n\t\tif (p->index == addr) {\n\t\t\t*link = pp;\n\t\t\tgoto found;\n\t\t}\n\t}\n\tBUG();\n\nfound:\n\treturn p;\n}\n\nstatic void niu_hash_page(struct rx_ring_info *rp, struct page *page, u64 base)\n{\n\tunsigned int h = niu_hash_rxaddr(rp, base);\n\n\tpage->index = base;\n\tniu_next_page(page) = rp->rxhash[h];\n\trp->rxhash[h] = page;\n}\n\nstatic int niu_rbr_add_page(struct niu *np, struct rx_ring_info *rp,\n\t\t\t    gfp_t mask, int start_index)\n{\n\tstruct page *page;\n\tu64 addr;\n\tint i;\n\n\tpage = alloc_page(mask);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\taddr = np->ops->map_page(np->device, page, 0,\n\t\t\t\t PAGE_SIZE, DMA_FROM_DEVICE);\n\tif (!addr) {\n\t\t__free_page(page);\n\t\treturn -ENOMEM;\n\t}\n\n\tniu_hash_page(rp, page, addr);\n\tif (rp->rbr_blocks_per_page > 1)\n\t\tpage_ref_add(page, rp->rbr_blocks_per_page - 1);\n\n\tfor (i = 0; i < rp->rbr_blocks_per_page; i++) {\n\t\t__le32 *rbr = &rp->rbr[start_index + i];\n\n\t\t*rbr = cpu_to_le32(addr >> RBR_DESCR_ADDR_SHIFT);\n\t\taddr += rp->rbr_block_size;\n\t}\n\n\treturn 0;\n}\n\nstatic void niu_rbr_refill(struct niu *np, struct rx_ring_info *rp, gfp_t mask)\n{\n\tint index = rp->rbr_index;\n\n\trp->rbr_pending++;\n\tif ((rp->rbr_pending % rp->rbr_blocks_per_page) == 0) {\n\t\tint err = niu_rbr_add_page(np, rp, mask, index);\n\n\t\tif (unlikely(err)) {\n\t\t\trp->rbr_pending--;\n\t\t\treturn;\n\t\t}\n\n\t\trp->rbr_index += rp->rbr_blocks_per_page;\n\t\tBUG_ON(rp->rbr_index > rp->rbr_table_size);\n\t\tif (rp->rbr_index == rp->rbr_table_size)\n\t\t\trp->rbr_index = 0;\n\n\t\tif (rp->rbr_pending >= rp->rbr_kick_thresh) {\n\t\t\tnw64(RBR_KICK(rp->rx_channel), rp->rbr_pending);\n\t\t\trp->rbr_pending = 0;\n\t\t}\n\t}\n}\n\nstatic int niu_rx_pkt_ignore(struct niu *np, struct rx_ring_info *rp)\n{\n\tunsigned int index = rp->rcr_index;\n\tint num_rcr = 0;\n\n\trp->rx_dropped++;\n\twhile (1) {\n\t\tstruct page *page, **link;\n\t\tu64 addr, val;\n\t\tu32 rcr_size;\n\n\t\tnum_rcr++;\n\n\t\tval = le64_to_cpup(&rp->rcr[index]);\n\t\taddr = (val & RCR_ENTRY_PKT_BUF_ADDR) <<\n\t\t\tRCR_ENTRY_PKT_BUF_ADDR_SHIFT;\n\t\tpage = niu_find_rxpage(rp, addr, &link);\n\n\t\trcr_size = rp->rbr_sizes[(val & RCR_ENTRY_PKTBUFSZ) >>\n\t\t\t\t\t RCR_ENTRY_PKTBUFSZ_SHIFT];\n\t\tif ((page->index + PAGE_SIZE) - rcr_size == addr) {\n\t\t\t*link = niu_next_page(page);\n\t\t\tnp->ops->unmap_page(np->device, page->index,\n\t\t\t\t\t    PAGE_SIZE, DMA_FROM_DEVICE);\n\t\t\tpage->index = 0;\n\t\t\tniu_next_page(page) = NULL;\n\t\t\t__free_page(page);\n\t\t\trp->rbr_refill_pending++;\n\t\t}\n\n\t\tindex = NEXT_RCR(rp, index);\n\t\tif (!(val & RCR_ENTRY_MULTI))\n\t\t\tbreak;\n\n\t}\n\trp->rcr_index = index;\n\n\treturn num_rcr;\n}\n\nstatic int niu_process_rx_pkt(struct napi_struct *napi, struct niu *np,\n\t\t\t      struct rx_ring_info *rp)\n{\n\tunsigned int index = rp->rcr_index;\n\tstruct rx_pkt_hdr1 *rh;\n\tstruct sk_buff *skb;\n\tint len, num_rcr;\n\n\tskb = netdev_alloc_skb(np->dev, RX_SKB_ALLOC_SIZE);\n\tif (unlikely(!skb))\n\t\treturn niu_rx_pkt_ignore(np, rp);\n\n\tnum_rcr = 0;\n\twhile (1) {\n\t\tstruct page *page, **link;\n\t\tu32 rcr_size, append_size;\n\t\tu64 addr, val, off;\n\n\t\tnum_rcr++;\n\n\t\tval = le64_to_cpup(&rp->rcr[index]);\n\n\t\tlen = (val & RCR_ENTRY_L2_LEN) >>\n\t\t\tRCR_ENTRY_L2_LEN_SHIFT;\n\t\tappend_size = len + ETH_HLEN + ETH_FCS_LEN;\n\n\t\taddr = (val & RCR_ENTRY_PKT_BUF_ADDR) <<\n\t\t\tRCR_ENTRY_PKT_BUF_ADDR_SHIFT;\n\t\tpage = niu_find_rxpage(rp, addr, &link);\n\n\t\trcr_size = rp->rbr_sizes[(val & RCR_ENTRY_PKTBUFSZ) >>\n\t\t\t\t\t RCR_ENTRY_PKTBUFSZ_SHIFT];\n\n\t\toff = addr & ~PAGE_MASK;\n\t\tif (num_rcr == 1) {\n\t\t\tint ptype;\n\n\t\t\tptype = (val >> RCR_ENTRY_PKT_TYPE_SHIFT);\n\t\t\tif ((ptype == RCR_PKT_TYPE_TCP ||\n\t\t\t     ptype == RCR_PKT_TYPE_UDP) &&\n\t\t\t    !(val & (RCR_ENTRY_NOPORT |\n\t\t\t\t     RCR_ENTRY_ERROR)))\n\t\t\t\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\t\t\telse\n\t\t\t\tskb_checksum_none_assert(skb);\n\t\t} else if (!(val & RCR_ENTRY_MULTI))\n\t\t\tappend_size = append_size - skb->len;\n\n\t\tniu_rx_skb_append(skb, page, off, append_size, rcr_size);\n\t\tif ((page->index + rp->rbr_block_size) - rcr_size == addr) {\n\t\t\t*link = niu_next_page(page);\n\t\t\tnp->ops->unmap_page(np->device, page->index,\n\t\t\t\t\t    PAGE_SIZE, DMA_FROM_DEVICE);\n\t\t\tpage->index = 0;\n\t\t\tniu_next_page(page) = NULL;\n\t\t\trp->rbr_refill_pending++;\n\t\t} else\n\t\t\tget_page(page);\n\n\t\tindex = NEXT_RCR(rp, index);\n\t\tif (!(val & RCR_ENTRY_MULTI))\n\t\t\tbreak;\n\n\t}\n\trp->rcr_index = index;\n\n\tlen += sizeof(*rh);\n\tlen = min_t(int, len, sizeof(*rh) + VLAN_ETH_HLEN);\n\t__pskb_pull_tail(skb, len);\n\n\trh = (struct rx_pkt_hdr1 *) skb->data;\n\tif (np->dev->features & NETIF_F_RXHASH)\n\t\tskb_set_hash(skb,\n\t\t\t     ((u32)rh->hashval2_0 << 24 |\n\t\t\t      (u32)rh->hashval2_1 << 16 |\n\t\t\t      (u32)rh->hashval1_1 << 8 |\n\t\t\t      (u32)rh->hashval1_2 << 0),\n\t\t\t     PKT_HASH_TYPE_L3);\n\tskb_pull(skb, sizeof(*rh));\n\n\trp->rx_packets++;\n\trp->rx_bytes += skb->len;\n\n\tskb->protocol = eth_type_trans(skb, np->dev);\n\tskb_record_rx_queue(skb, rp->rx_channel);\n\tnapi_gro_receive(napi, skb);\n\n\treturn num_rcr;\n}\n\nstatic int niu_rbr_fill(struct niu *np, struct rx_ring_info *rp, gfp_t mask)\n{\n\tint blocks_per_page = rp->rbr_blocks_per_page;\n\tint err, index = rp->rbr_index;\n\n\terr = 0;\n\twhile (index < (rp->rbr_table_size - blocks_per_page)) {\n\t\terr = niu_rbr_add_page(np, rp, mask, index);\n\t\tif (unlikely(err))\n\t\t\tbreak;\n\n\t\tindex += blocks_per_page;\n\t}\n\n\trp->rbr_index = index;\n\treturn err;\n}\n\nstatic void niu_rbr_free(struct niu *np, struct rx_ring_info *rp)\n{\n\tint i;\n\n\tfor (i = 0; i < MAX_RBR_RING_SIZE; i++) {\n\t\tstruct page *page;\n\n\t\tpage = rp->rxhash[i];\n\t\twhile (page) {\n\t\t\tstruct page *next = niu_next_page(page);\n\t\t\tu64 base = page->index;\n\n\t\t\tnp->ops->unmap_page(np->device, base, PAGE_SIZE,\n\t\t\t\t\t    DMA_FROM_DEVICE);\n\t\t\tpage->index = 0;\n\t\t\tniu_next_page(page) = NULL;\n\n\t\t\t__free_page(page);\n\n\t\t\tpage = next;\n\t\t}\n\t}\n\n\tfor (i = 0; i < rp->rbr_table_size; i++)\n\t\trp->rbr[i] = cpu_to_le32(0);\n\trp->rbr_index = 0;\n}\n\nstatic int release_tx_packet(struct niu *np, struct tx_ring_info *rp, int idx)\n{\n\tstruct tx_buff_info *tb = &rp->tx_buffs[idx];\n\tstruct sk_buff *skb = tb->skb;\n\tstruct tx_pkt_hdr *tp;\n\tu64 tx_flags;\n\tint i, len;\n\n\ttp = (struct tx_pkt_hdr *) skb->data;\n\ttx_flags = le64_to_cpup(&tp->flags);\n\n\trp->tx_packets++;\n\trp->tx_bytes += (((tx_flags & TXHDR_LEN) >> TXHDR_LEN_SHIFT) -\n\t\t\t ((tx_flags & TXHDR_PAD) / 2));\n\n\tlen = skb_headlen(skb);\n\tnp->ops->unmap_single(np->device, tb->mapping,\n\t\t\t      len, DMA_TO_DEVICE);\n\n\tif (le64_to_cpu(rp->descr[idx]) & TX_DESC_MARK)\n\t\trp->mark_pending--;\n\n\ttb->skb = NULL;\n\tdo {\n\t\tidx = NEXT_TX(rp, idx);\n\t\tlen -= MAX_TX_DESC_LEN;\n\t} while (len > 0);\n\n\tfor (i = 0; i < skb_shinfo(skb)->nr_frags; i++) {\n\t\ttb = &rp->tx_buffs[idx];\n\t\tBUG_ON(tb->skb != NULL);\n\t\tnp->ops->unmap_page(np->device, tb->mapping,\n\t\t\t\t    skb_frag_size(&skb_shinfo(skb)->frags[i]),\n\t\t\t\t    DMA_TO_DEVICE);\n\t\tidx = NEXT_TX(rp, idx);\n\t}\n\n\tdev_kfree_skb(skb);\n\n\treturn idx;\n}\n\n#define NIU_TX_WAKEUP_THRESH(rp)\t\t((rp)->pending / 4)\n\nstatic void niu_tx_work(struct niu *np, struct tx_ring_info *rp)\n{\n\tstruct netdev_queue *txq;\n\tu16 pkt_cnt, tmp;\n\tint cons, index;\n\tu64 cs;\n\n\tindex = (rp - np->tx_rings);\n\ttxq = netdev_get_tx_queue(np->dev, index);\n\n\tcs = rp->tx_cs;\n\tif (unlikely(!(cs & (TX_CS_MK | TX_CS_MMK))))\n\t\tgoto out;\n\n\ttmp = pkt_cnt = (cs & TX_CS_PKT_CNT) >> TX_CS_PKT_CNT_SHIFT;\n\tpkt_cnt = (pkt_cnt - rp->last_pkt_cnt) &\n\t\t(TX_CS_PKT_CNT >> TX_CS_PKT_CNT_SHIFT);\n\n\trp->last_pkt_cnt = tmp;\n\n\tcons = rp->cons;\n\n\tnetif_printk(np, tx_done, KERN_DEBUG, np->dev,\n\t\t     \"%s() pkt_cnt[%u] cons[%d]\\n\", __func__, pkt_cnt, cons);\n\n\twhile (pkt_cnt--)\n\t\tcons = release_tx_packet(np, rp, cons);\n\n\trp->cons = cons;\n\tsmp_mb();\n\nout:\n\tif (unlikely(netif_tx_queue_stopped(txq) &&\n\t\t     (niu_tx_avail(rp) > NIU_TX_WAKEUP_THRESH(rp)))) {\n\t\t__netif_tx_lock(txq, smp_processor_id());\n\t\tif (netif_tx_queue_stopped(txq) &&\n\t\t    (niu_tx_avail(rp) > NIU_TX_WAKEUP_THRESH(rp)))\n\t\t\tnetif_tx_wake_queue(txq);\n\t\t__netif_tx_unlock(txq);\n\t}\n}\n\nstatic inline void niu_sync_rx_discard_stats(struct niu *np,\n\t\t\t\t\t     struct rx_ring_info *rp,\n\t\t\t\t\t     const int limit)\n{\n\t \n\tint rx_channel = rp->rx_channel;\n\tu32 misc, wred;\n\n\t \n\tmisc = nr64(RXMISC(rx_channel));\n\tif (unlikely((misc & RXMISC_COUNT) > limit)) {\n\t\tnw64(RXMISC(rx_channel), 0);\n\t\trp->rx_errors += misc & RXMISC_COUNT;\n\n\t\tif (unlikely(misc & RXMISC_OFLOW))\n\t\t\tdev_err(np->device, \"rx-%d: Counter overflow RXMISC discard\\n\",\n\t\t\t\trx_channel);\n\n\t\tnetif_printk(np, rx_err, KERN_DEBUG, np->dev,\n\t\t\t     \"rx-%d: MISC drop=%u over=%u\\n\",\n\t\t\t     rx_channel, misc, misc-limit);\n\t}\n\n\t \n\twred = nr64(RED_DIS_CNT(rx_channel));\n\tif (unlikely((wred & RED_DIS_CNT_COUNT) > limit)) {\n\t\tnw64(RED_DIS_CNT(rx_channel), 0);\n\t\trp->rx_dropped += wred & RED_DIS_CNT_COUNT;\n\n\t\tif (unlikely(wred & RED_DIS_CNT_OFLOW))\n\t\t\tdev_err(np->device, \"rx-%d: Counter overflow WRED discard\\n\", rx_channel);\n\n\t\tnetif_printk(np, rx_err, KERN_DEBUG, np->dev,\n\t\t\t     \"rx-%d: WRED drop=%u over=%u\\n\",\n\t\t\t     rx_channel, wred, wred-limit);\n\t}\n}\n\nstatic int niu_rx_work(struct napi_struct *napi, struct niu *np,\n\t\t       struct rx_ring_info *rp, int budget)\n{\n\tint qlen, rcr_done = 0, work_done = 0;\n\tstruct rxdma_mailbox *mbox = rp->mbox;\n\tu64 stat;\n\n#if 1\n\tstat = nr64(RX_DMA_CTL_STAT(rp->rx_channel));\n\tqlen = nr64(RCRSTAT_A(rp->rx_channel)) & RCRSTAT_A_QLEN;\n#else\n\tstat = le64_to_cpup(&mbox->rx_dma_ctl_stat);\n\tqlen = (le64_to_cpup(&mbox->rcrstat_a) & RCRSTAT_A_QLEN);\n#endif\n\tmbox->rx_dma_ctl_stat = 0;\n\tmbox->rcrstat_a = 0;\n\n\tnetif_printk(np, rx_status, KERN_DEBUG, np->dev,\n\t\t     \"%s(chan[%d]), stat[%llx] qlen=%d\\n\",\n\t\t     __func__, rp->rx_channel, (unsigned long long)stat, qlen);\n\n\trcr_done = work_done = 0;\n\tqlen = min(qlen, budget);\n\twhile (work_done < qlen) {\n\t\trcr_done += niu_process_rx_pkt(napi, np, rp);\n\t\twork_done++;\n\t}\n\n\tif (rp->rbr_refill_pending >= rp->rbr_kick_thresh) {\n\t\tunsigned int i;\n\n\t\tfor (i = 0; i < rp->rbr_refill_pending; i++)\n\t\t\tniu_rbr_refill(np, rp, GFP_ATOMIC);\n\t\trp->rbr_refill_pending = 0;\n\t}\n\n\tstat = (RX_DMA_CTL_STAT_MEX |\n\t\t((u64)work_done << RX_DMA_CTL_STAT_PKTREAD_SHIFT) |\n\t\t((u64)rcr_done << RX_DMA_CTL_STAT_PTRREAD_SHIFT));\n\n\tnw64(RX_DMA_CTL_STAT(rp->rx_channel), stat);\n\n\t \n\tif (qlen > 10)\n\t\tniu_sync_rx_discard_stats(np, rp, 0x7FFF);\n\n\treturn work_done;\n}\n\nstatic int niu_poll_core(struct niu *np, struct niu_ldg *lp, int budget)\n{\n\tu64 v0 = lp->v0;\n\tu32 tx_vec = (v0 >> 32);\n\tu32 rx_vec = (v0 & 0xffffffff);\n\tint i, work_done = 0;\n\n\tnetif_printk(np, intr, KERN_DEBUG, np->dev,\n\t\t     \"%s() v0[%016llx]\\n\", __func__, (unsigned long long)v0);\n\n\tfor (i = 0; i < np->num_tx_rings; i++) {\n\t\tstruct tx_ring_info *rp = &np->tx_rings[i];\n\t\tif (tx_vec & (1 << rp->tx_channel))\n\t\t\tniu_tx_work(np, rp);\n\t\tnw64(LD_IM0(LDN_TXDMA(rp->tx_channel)), 0);\n\t}\n\n\tfor (i = 0; i < np->num_rx_rings; i++) {\n\t\tstruct rx_ring_info *rp = &np->rx_rings[i];\n\n\t\tif (rx_vec & (1 << rp->rx_channel)) {\n\t\t\tint this_work_done;\n\n\t\t\tthis_work_done = niu_rx_work(&lp->napi, np, rp,\n\t\t\t\t\t\t     budget);\n\n\t\t\tbudget -= this_work_done;\n\t\t\twork_done += this_work_done;\n\t\t}\n\t\tnw64(LD_IM0(LDN_RXDMA(rp->rx_channel)), 0);\n\t}\n\n\treturn work_done;\n}\n\nstatic int niu_poll(struct napi_struct *napi, int budget)\n{\n\tstruct niu_ldg *lp = container_of(napi, struct niu_ldg, napi);\n\tstruct niu *np = lp->np;\n\tint work_done;\n\n\twork_done = niu_poll_core(np, lp, budget);\n\n\tif (work_done < budget) {\n\t\tnapi_complete_done(napi, work_done);\n\t\tniu_ldg_rearm(np, lp, 1);\n\t}\n\treturn work_done;\n}\n\nstatic void niu_log_rxchan_errors(struct niu *np, struct rx_ring_info *rp,\n\t\t\t\t  u64 stat)\n{\n\tnetdev_err(np->dev, \"RX channel %u errors ( \", rp->rx_channel);\n\n\tif (stat & RX_DMA_CTL_STAT_RBR_TMOUT)\n\t\tpr_cont(\"RBR_TMOUT \");\n\tif (stat & RX_DMA_CTL_STAT_RSP_CNT_ERR)\n\t\tpr_cont(\"RSP_CNT \");\n\tif (stat & RX_DMA_CTL_STAT_BYTE_EN_BUS)\n\t\tpr_cont(\"BYTE_EN_BUS \");\n\tif (stat & RX_DMA_CTL_STAT_RSP_DAT_ERR)\n\t\tpr_cont(\"RSP_DAT \");\n\tif (stat & RX_DMA_CTL_STAT_RCR_ACK_ERR)\n\t\tpr_cont(\"RCR_ACK \");\n\tif (stat & RX_DMA_CTL_STAT_RCR_SHA_PAR)\n\t\tpr_cont(\"RCR_SHA_PAR \");\n\tif (stat & RX_DMA_CTL_STAT_RBR_PRE_PAR)\n\t\tpr_cont(\"RBR_PRE_PAR \");\n\tif (stat & RX_DMA_CTL_STAT_CONFIG_ERR)\n\t\tpr_cont(\"CONFIG \");\n\tif (stat & RX_DMA_CTL_STAT_RCRINCON)\n\t\tpr_cont(\"RCRINCON \");\n\tif (stat & RX_DMA_CTL_STAT_RCRFULL)\n\t\tpr_cont(\"RCRFULL \");\n\tif (stat & RX_DMA_CTL_STAT_RBRFULL)\n\t\tpr_cont(\"RBRFULL \");\n\tif (stat & RX_DMA_CTL_STAT_RBRLOGPAGE)\n\t\tpr_cont(\"RBRLOGPAGE \");\n\tif (stat & RX_DMA_CTL_STAT_CFIGLOGPAGE)\n\t\tpr_cont(\"CFIGLOGPAGE \");\n\tif (stat & RX_DMA_CTL_STAT_DC_FIFO_ERR)\n\t\tpr_cont(\"DC_FIDO \");\n\n\tpr_cont(\")\\n\");\n}\n\nstatic int niu_rx_error(struct niu *np, struct rx_ring_info *rp)\n{\n\tu64 stat = nr64(RX_DMA_CTL_STAT(rp->rx_channel));\n\tint err = 0;\n\n\n\tif (stat & (RX_DMA_CTL_STAT_CHAN_FATAL |\n\t\t    RX_DMA_CTL_STAT_PORT_FATAL))\n\t\terr = -EINVAL;\n\n\tif (err) {\n\t\tnetdev_err(np->dev, \"RX channel %u error, stat[%llx]\\n\",\n\t\t\t   rp->rx_channel,\n\t\t\t   (unsigned long long) stat);\n\n\t\tniu_log_rxchan_errors(np, rp, stat);\n\t}\n\n\tnw64(RX_DMA_CTL_STAT(rp->rx_channel),\n\t     stat & RX_DMA_CTL_WRITE_CLEAR_ERRS);\n\n\treturn err;\n}\n\nstatic void niu_log_txchan_errors(struct niu *np, struct tx_ring_info *rp,\n\t\t\t\t  u64 cs)\n{\n\tnetdev_err(np->dev, \"TX channel %u errors ( \", rp->tx_channel);\n\n\tif (cs & TX_CS_MBOX_ERR)\n\t\tpr_cont(\"MBOX \");\n\tif (cs & TX_CS_PKT_SIZE_ERR)\n\t\tpr_cont(\"PKT_SIZE \");\n\tif (cs & TX_CS_TX_RING_OFLOW)\n\t\tpr_cont(\"TX_RING_OFLOW \");\n\tif (cs & TX_CS_PREF_BUF_PAR_ERR)\n\t\tpr_cont(\"PREF_BUF_PAR \");\n\tif (cs & TX_CS_NACK_PREF)\n\t\tpr_cont(\"NACK_PREF \");\n\tif (cs & TX_CS_NACK_PKT_RD)\n\t\tpr_cont(\"NACK_PKT_RD \");\n\tif (cs & TX_CS_CONF_PART_ERR)\n\t\tpr_cont(\"CONF_PART \");\n\tif (cs & TX_CS_PKT_PRT_ERR)\n\t\tpr_cont(\"PKT_PTR \");\n\n\tpr_cont(\")\\n\");\n}\n\nstatic int niu_tx_error(struct niu *np, struct tx_ring_info *rp)\n{\n\tu64 cs, logh, logl;\n\n\tcs = nr64(TX_CS(rp->tx_channel));\n\tlogh = nr64(TX_RNG_ERR_LOGH(rp->tx_channel));\n\tlogl = nr64(TX_RNG_ERR_LOGL(rp->tx_channel));\n\n\tnetdev_err(np->dev, \"TX channel %u error, cs[%llx] logh[%llx] logl[%llx]\\n\",\n\t\t   rp->tx_channel,\n\t\t   (unsigned long long)cs,\n\t\t   (unsigned long long)logh,\n\t\t   (unsigned long long)logl);\n\n\tniu_log_txchan_errors(np, rp, cs);\n\n\treturn -ENODEV;\n}\n\nstatic int niu_mif_interrupt(struct niu *np)\n{\n\tu64 mif_status = nr64(MIF_STATUS);\n\tint phy_mdint = 0;\n\n\tif (np->flags & NIU_FLAGS_XMAC) {\n\t\tu64 xrxmac_stat = nr64_mac(XRXMAC_STATUS);\n\n\t\tif (xrxmac_stat & XRXMAC_STATUS_PHY_MDINT)\n\t\t\tphy_mdint = 1;\n\t}\n\n\tnetdev_err(np->dev, \"MIF interrupt, stat[%llx] phy_mdint(%d)\\n\",\n\t\t   (unsigned long long)mif_status, phy_mdint);\n\n\treturn -ENODEV;\n}\n\nstatic void niu_xmac_interrupt(struct niu *np)\n{\n\tstruct niu_xmac_stats *mp = &np->mac_stats.xmac;\n\tu64 val;\n\n\tval = nr64_mac(XTXMAC_STATUS);\n\tif (val & XTXMAC_STATUS_FRAME_CNT_EXP)\n\t\tmp->tx_frames += TXMAC_FRM_CNT_COUNT;\n\tif (val & XTXMAC_STATUS_BYTE_CNT_EXP)\n\t\tmp->tx_bytes += TXMAC_BYTE_CNT_COUNT;\n\tif (val & XTXMAC_STATUS_TXFIFO_XFR_ERR)\n\t\tmp->tx_fifo_errors++;\n\tif (val & XTXMAC_STATUS_TXMAC_OFLOW)\n\t\tmp->tx_overflow_errors++;\n\tif (val & XTXMAC_STATUS_MAX_PSIZE_ERR)\n\t\tmp->tx_max_pkt_size_errors++;\n\tif (val & XTXMAC_STATUS_TXMAC_UFLOW)\n\t\tmp->tx_underflow_errors++;\n\n\tval = nr64_mac(XRXMAC_STATUS);\n\tif (val & XRXMAC_STATUS_LCL_FLT_STATUS)\n\t\tmp->rx_local_faults++;\n\tif (val & XRXMAC_STATUS_RFLT_DET)\n\t\tmp->rx_remote_faults++;\n\tif (val & XRXMAC_STATUS_LFLT_CNT_EXP)\n\t\tmp->rx_link_faults += LINK_FAULT_CNT_COUNT;\n\tif (val & XRXMAC_STATUS_ALIGNERR_CNT_EXP)\n\t\tmp->rx_align_errors += RXMAC_ALIGN_ERR_CNT_COUNT;\n\tif (val & XRXMAC_STATUS_RXFRAG_CNT_EXP)\n\t\tmp->rx_frags += RXMAC_FRAG_CNT_COUNT;\n\tif (val & XRXMAC_STATUS_RXMULTF_CNT_EXP)\n\t\tmp->rx_mcasts += RXMAC_MC_FRM_CNT_COUNT;\n\tif (val & XRXMAC_STATUS_RXBCAST_CNT_EXP)\n\t\tmp->rx_bcasts += RXMAC_BC_FRM_CNT_COUNT;\n\tif (val & XRXMAC_STATUS_RXHIST1_CNT_EXP)\n\t\tmp->rx_hist_cnt1 += RXMAC_HIST_CNT1_COUNT;\n\tif (val & XRXMAC_STATUS_RXHIST2_CNT_EXP)\n\t\tmp->rx_hist_cnt2 += RXMAC_HIST_CNT2_COUNT;\n\tif (val & XRXMAC_STATUS_RXHIST3_CNT_EXP)\n\t\tmp->rx_hist_cnt3 += RXMAC_HIST_CNT3_COUNT;\n\tif (val & XRXMAC_STATUS_RXHIST4_CNT_EXP)\n\t\tmp->rx_hist_cnt4 += RXMAC_HIST_CNT4_COUNT;\n\tif (val & XRXMAC_STATUS_RXHIST5_CNT_EXP)\n\t\tmp->rx_hist_cnt5 += RXMAC_HIST_CNT5_COUNT;\n\tif (val & XRXMAC_STATUS_RXHIST6_CNT_EXP)\n\t\tmp->rx_hist_cnt6 += RXMAC_HIST_CNT6_COUNT;\n\tif (val & XRXMAC_STATUS_RXHIST7_CNT_EXP)\n\t\tmp->rx_hist_cnt7 += RXMAC_HIST_CNT7_COUNT;\n\tif (val & XRXMAC_STATUS_RXOCTET_CNT_EXP)\n\t\tmp->rx_octets += RXMAC_BT_CNT_COUNT;\n\tif (val & XRXMAC_STATUS_CVIOLERR_CNT_EXP)\n\t\tmp->rx_code_violations += RXMAC_CD_VIO_CNT_COUNT;\n\tif (val & XRXMAC_STATUS_LENERR_CNT_EXP)\n\t\tmp->rx_len_errors += RXMAC_MPSZER_CNT_COUNT;\n\tif (val & XRXMAC_STATUS_CRCERR_CNT_EXP)\n\t\tmp->rx_crc_errors += RXMAC_CRC_ER_CNT_COUNT;\n\tif (val & XRXMAC_STATUS_RXUFLOW)\n\t\tmp->rx_underflows++;\n\tif (val & XRXMAC_STATUS_RXOFLOW)\n\t\tmp->rx_overflows++;\n\n\tval = nr64_mac(XMAC_FC_STAT);\n\tif (val & XMAC_FC_STAT_TX_MAC_NPAUSE)\n\t\tmp->pause_off_state++;\n\tif (val & XMAC_FC_STAT_TX_MAC_PAUSE)\n\t\tmp->pause_on_state++;\n\tif (val & XMAC_FC_STAT_RX_MAC_RPAUSE)\n\t\tmp->pause_received++;\n}\n\nstatic void niu_bmac_interrupt(struct niu *np)\n{\n\tstruct niu_bmac_stats *mp = &np->mac_stats.bmac;\n\tu64 val;\n\n\tval = nr64_mac(BTXMAC_STATUS);\n\tif (val & BTXMAC_STATUS_UNDERRUN)\n\t\tmp->tx_underflow_errors++;\n\tif (val & BTXMAC_STATUS_MAX_PKT_ERR)\n\t\tmp->tx_max_pkt_size_errors++;\n\tif (val & BTXMAC_STATUS_BYTE_CNT_EXP)\n\t\tmp->tx_bytes += BTXMAC_BYTE_CNT_COUNT;\n\tif (val & BTXMAC_STATUS_FRAME_CNT_EXP)\n\t\tmp->tx_frames += BTXMAC_FRM_CNT_COUNT;\n\n\tval = nr64_mac(BRXMAC_STATUS);\n\tif (val & BRXMAC_STATUS_OVERFLOW)\n\t\tmp->rx_overflows++;\n\tif (val & BRXMAC_STATUS_FRAME_CNT_EXP)\n\t\tmp->rx_frames += BRXMAC_FRAME_CNT_COUNT;\n\tif (val & BRXMAC_STATUS_ALIGN_ERR_EXP)\n\t\tmp->rx_align_errors += BRXMAC_ALIGN_ERR_CNT_COUNT;\n\tif (val & BRXMAC_STATUS_CRC_ERR_EXP)\n\t\tmp->rx_crc_errors += BRXMAC_ALIGN_ERR_CNT_COUNT;\n\tif (val & BRXMAC_STATUS_LEN_ERR_EXP)\n\t\tmp->rx_len_errors += BRXMAC_CODE_VIOL_ERR_CNT_COUNT;\n\n\tval = nr64_mac(BMAC_CTRL_STATUS);\n\tif (val & BMAC_CTRL_STATUS_NOPAUSE)\n\t\tmp->pause_off_state++;\n\tif (val & BMAC_CTRL_STATUS_PAUSE)\n\t\tmp->pause_on_state++;\n\tif (val & BMAC_CTRL_STATUS_PAUSE_RECV)\n\t\tmp->pause_received++;\n}\n\nstatic int niu_mac_interrupt(struct niu *np)\n{\n\tif (np->flags & NIU_FLAGS_XMAC)\n\t\tniu_xmac_interrupt(np);\n\telse\n\t\tniu_bmac_interrupt(np);\n\n\treturn 0;\n}\n\nstatic void niu_log_device_error(struct niu *np, u64 stat)\n{\n\tnetdev_err(np->dev, \"Core device errors ( \");\n\n\tif (stat & SYS_ERR_MASK_META2)\n\t\tpr_cont(\"META2 \");\n\tif (stat & SYS_ERR_MASK_META1)\n\t\tpr_cont(\"META1 \");\n\tif (stat & SYS_ERR_MASK_PEU)\n\t\tpr_cont(\"PEU \");\n\tif (stat & SYS_ERR_MASK_TXC)\n\t\tpr_cont(\"TXC \");\n\tif (stat & SYS_ERR_MASK_RDMC)\n\t\tpr_cont(\"RDMC \");\n\tif (stat & SYS_ERR_MASK_TDMC)\n\t\tpr_cont(\"TDMC \");\n\tif (stat & SYS_ERR_MASK_ZCP)\n\t\tpr_cont(\"ZCP \");\n\tif (stat & SYS_ERR_MASK_FFLP)\n\t\tpr_cont(\"FFLP \");\n\tif (stat & SYS_ERR_MASK_IPP)\n\t\tpr_cont(\"IPP \");\n\tif (stat & SYS_ERR_MASK_MAC)\n\t\tpr_cont(\"MAC \");\n\tif (stat & SYS_ERR_MASK_SMX)\n\t\tpr_cont(\"SMX \");\n\n\tpr_cont(\")\\n\");\n}\n\nstatic int niu_device_error(struct niu *np)\n{\n\tu64 stat = nr64(SYS_ERR_STAT);\n\n\tnetdev_err(np->dev, \"Core device error, stat[%llx]\\n\",\n\t\t   (unsigned long long)stat);\n\n\tniu_log_device_error(np, stat);\n\n\treturn -ENODEV;\n}\n\nstatic int niu_slowpath_interrupt(struct niu *np, struct niu_ldg *lp,\n\t\t\t      u64 v0, u64 v1, u64 v2)\n{\n\n\tint i, err = 0;\n\n\tlp->v0 = v0;\n\tlp->v1 = v1;\n\tlp->v2 = v2;\n\n\tif (v1 & 0x00000000ffffffffULL) {\n\t\tu32 rx_vec = (v1 & 0xffffffff);\n\n\t\tfor (i = 0; i < np->num_rx_rings; i++) {\n\t\t\tstruct rx_ring_info *rp = &np->rx_rings[i];\n\n\t\t\tif (rx_vec & (1 << rp->rx_channel)) {\n\t\t\t\tint r = niu_rx_error(np, rp);\n\t\t\t\tif (r) {\n\t\t\t\t\terr = r;\n\t\t\t\t} else {\n\t\t\t\t\tif (!v0)\n\t\t\t\t\t\tnw64(RX_DMA_CTL_STAT(rp->rx_channel),\n\t\t\t\t\t\t     RX_DMA_CTL_STAT_MEX);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (v1 & 0x7fffffff00000000ULL) {\n\t\tu32 tx_vec = (v1 >> 32) & 0x7fffffff;\n\n\t\tfor (i = 0; i < np->num_tx_rings; i++) {\n\t\t\tstruct tx_ring_info *rp = &np->tx_rings[i];\n\n\t\t\tif (tx_vec & (1 << rp->tx_channel)) {\n\t\t\t\tint r = niu_tx_error(np, rp);\n\t\t\t\tif (r)\n\t\t\t\t\terr = r;\n\t\t\t}\n\t\t}\n\t}\n\tif ((v0 | v1) & 0x8000000000000000ULL) {\n\t\tint r = niu_mif_interrupt(np);\n\t\tif (r)\n\t\t\terr = r;\n\t}\n\tif (v2) {\n\t\tif (v2 & 0x01ef) {\n\t\t\tint r = niu_mac_interrupt(np);\n\t\t\tif (r)\n\t\t\t\terr = r;\n\t\t}\n\t\tif (v2 & 0x0210) {\n\t\t\tint r = niu_device_error(np);\n\t\t\tif (r)\n\t\t\t\terr = r;\n\t\t}\n\t}\n\n\tif (err)\n\t\tniu_enable_interrupts(np, 0);\n\n\treturn err;\n}\n\nstatic void niu_rxchan_intr(struct niu *np, struct rx_ring_info *rp,\n\t\t\t    int ldn)\n{\n\tstruct rxdma_mailbox *mbox = rp->mbox;\n\tu64 stat_write, stat = le64_to_cpup(&mbox->rx_dma_ctl_stat);\n\n\tstat_write = (RX_DMA_CTL_STAT_RCRTHRES |\n\t\t      RX_DMA_CTL_STAT_RCRTO);\n\tnw64(RX_DMA_CTL_STAT(rp->rx_channel), stat_write);\n\n\tnetif_printk(np, intr, KERN_DEBUG, np->dev,\n\t\t     \"%s() stat[%llx]\\n\", __func__, (unsigned long long)stat);\n}\n\nstatic void niu_txchan_intr(struct niu *np, struct tx_ring_info *rp,\n\t\t\t    int ldn)\n{\n\trp->tx_cs = nr64(TX_CS(rp->tx_channel));\n\n\tnetif_printk(np, intr, KERN_DEBUG, np->dev,\n\t\t     \"%s() cs[%llx]\\n\", __func__, (unsigned long long)rp->tx_cs);\n}\n\nstatic void __niu_fastpath_interrupt(struct niu *np, int ldg, u64 v0)\n{\n\tstruct niu_parent *parent = np->parent;\n\tu32 rx_vec, tx_vec;\n\tint i;\n\n\ttx_vec = (v0 >> 32);\n\trx_vec = (v0 & 0xffffffff);\n\n\tfor (i = 0; i < np->num_rx_rings; i++) {\n\t\tstruct rx_ring_info *rp = &np->rx_rings[i];\n\t\tint ldn = LDN_RXDMA(rp->rx_channel);\n\n\t\tif (parent->ldg_map[ldn] != ldg)\n\t\t\tcontinue;\n\n\t\tnw64(LD_IM0(ldn), LD_IM0_MASK);\n\t\tif (rx_vec & (1 << rp->rx_channel))\n\t\t\tniu_rxchan_intr(np, rp, ldn);\n\t}\n\n\tfor (i = 0; i < np->num_tx_rings; i++) {\n\t\tstruct tx_ring_info *rp = &np->tx_rings[i];\n\t\tint ldn = LDN_TXDMA(rp->tx_channel);\n\n\t\tif (parent->ldg_map[ldn] != ldg)\n\t\t\tcontinue;\n\n\t\tnw64(LD_IM0(ldn), LD_IM0_MASK);\n\t\tif (tx_vec & (1 << rp->tx_channel))\n\t\t\tniu_txchan_intr(np, rp, ldn);\n\t}\n}\n\nstatic void niu_schedule_napi(struct niu *np, struct niu_ldg *lp,\n\t\t\t      u64 v0, u64 v1, u64 v2)\n{\n\tif (likely(napi_schedule_prep(&lp->napi))) {\n\t\tlp->v0 = v0;\n\t\tlp->v1 = v1;\n\t\tlp->v2 = v2;\n\t\t__niu_fastpath_interrupt(np, lp->ldg_num, v0);\n\t\t__napi_schedule(&lp->napi);\n\t}\n}\n\nstatic irqreturn_t niu_interrupt(int irq, void *dev_id)\n{\n\tstruct niu_ldg *lp = dev_id;\n\tstruct niu *np = lp->np;\n\tint ldg = lp->ldg_num;\n\tunsigned long flags;\n\tu64 v0, v1, v2;\n\n\tif (netif_msg_intr(np))\n\t\tprintk(KERN_DEBUG KBUILD_MODNAME \": \" \"%s() ldg[%p](%d)\",\n\t\t       __func__, lp, ldg);\n\n\tspin_lock_irqsave(&np->lock, flags);\n\n\tv0 = nr64(LDSV0(ldg));\n\tv1 = nr64(LDSV1(ldg));\n\tv2 = nr64(LDSV2(ldg));\n\n\tif (netif_msg_intr(np))\n\t\tpr_cont(\" v0[%llx] v1[%llx] v2[%llx]\\n\",\n\t\t       (unsigned long long) v0,\n\t\t       (unsigned long long) v1,\n\t\t       (unsigned long long) v2);\n\n\tif (unlikely(!v0 && !v1 && !v2)) {\n\t\tspin_unlock_irqrestore(&np->lock, flags);\n\t\treturn IRQ_NONE;\n\t}\n\n\tif (unlikely((v0 & ((u64)1 << LDN_MIF)) || v1 || v2)) {\n\t\tint err = niu_slowpath_interrupt(np, lp, v0, v1, v2);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\tif (likely(v0 & ~((u64)1 << LDN_MIF)))\n\t\tniu_schedule_napi(np, lp, v0, v1, v2);\n\telse\n\t\tniu_ldg_rearm(np, lp, 1);\nout:\n\tspin_unlock_irqrestore(&np->lock, flags);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void niu_free_rx_ring_info(struct niu *np, struct rx_ring_info *rp)\n{\n\tif (rp->mbox) {\n\t\tnp->ops->free_coherent(np->device,\n\t\t\t\t       sizeof(struct rxdma_mailbox),\n\t\t\t\t       rp->mbox, rp->mbox_dma);\n\t\trp->mbox = NULL;\n\t}\n\tif (rp->rcr) {\n\t\tnp->ops->free_coherent(np->device,\n\t\t\t\t       MAX_RCR_RING_SIZE * sizeof(__le64),\n\t\t\t\t       rp->rcr, rp->rcr_dma);\n\t\trp->rcr = NULL;\n\t\trp->rcr_table_size = 0;\n\t\trp->rcr_index = 0;\n\t}\n\tif (rp->rbr) {\n\t\tniu_rbr_free(np, rp);\n\n\t\tnp->ops->free_coherent(np->device,\n\t\t\t\t       MAX_RBR_RING_SIZE * sizeof(__le32),\n\t\t\t\t       rp->rbr, rp->rbr_dma);\n\t\trp->rbr = NULL;\n\t\trp->rbr_table_size = 0;\n\t\trp->rbr_index = 0;\n\t}\n\tkfree(rp->rxhash);\n\trp->rxhash = NULL;\n}\n\nstatic void niu_free_tx_ring_info(struct niu *np, struct tx_ring_info *rp)\n{\n\tif (rp->mbox) {\n\t\tnp->ops->free_coherent(np->device,\n\t\t\t\t       sizeof(struct txdma_mailbox),\n\t\t\t\t       rp->mbox, rp->mbox_dma);\n\t\trp->mbox = NULL;\n\t}\n\tif (rp->descr) {\n\t\tint i;\n\n\t\tfor (i = 0; i < MAX_TX_RING_SIZE; i++) {\n\t\t\tif (rp->tx_buffs[i].skb)\n\t\t\t\t(void) release_tx_packet(np, rp, i);\n\t\t}\n\n\t\tnp->ops->free_coherent(np->device,\n\t\t\t\t       MAX_TX_RING_SIZE * sizeof(__le64),\n\t\t\t\t       rp->descr, rp->descr_dma);\n\t\trp->descr = NULL;\n\t\trp->pending = 0;\n\t\trp->prod = 0;\n\t\trp->cons = 0;\n\t\trp->wrap_bit = 0;\n\t}\n}\n\nstatic void niu_free_channels(struct niu *np)\n{\n\tint i;\n\n\tif (np->rx_rings) {\n\t\tfor (i = 0; i < np->num_rx_rings; i++) {\n\t\t\tstruct rx_ring_info *rp = &np->rx_rings[i];\n\n\t\t\tniu_free_rx_ring_info(np, rp);\n\t\t}\n\t\tkfree(np->rx_rings);\n\t\tnp->rx_rings = NULL;\n\t\tnp->num_rx_rings = 0;\n\t}\n\n\tif (np->tx_rings) {\n\t\tfor (i = 0; i < np->num_tx_rings; i++) {\n\t\t\tstruct tx_ring_info *rp = &np->tx_rings[i];\n\n\t\t\tniu_free_tx_ring_info(np, rp);\n\t\t}\n\t\tkfree(np->tx_rings);\n\t\tnp->tx_rings = NULL;\n\t\tnp->num_tx_rings = 0;\n\t}\n}\n\nstatic int niu_alloc_rx_ring_info(struct niu *np,\n\t\t\t\t  struct rx_ring_info *rp)\n{\n\tBUILD_BUG_ON(sizeof(struct rxdma_mailbox) != 64);\n\n\trp->rxhash = kcalloc(MAX_RBR_RING_SIZE, sizeof(struct page *),\n\t\t\t     GFP_KERNEL);\n\tif (!rp->rxhash)\n\t\treturn -ENOMEM;\n\n\trp->mbox = np->ops->alloc_coherent(np->device,\n\t\t\t\t\t   sizeof(struct rxdma_mailbox),\n\t\t\t\t\t   &rp->mbox_dma, GFP_KERNEL);\n\tif (!rp->mbox)\n\t\treturn -ENOMEM;\n\tif ((unsigned long)rp->mbox & (64UL - 1)) {\n\t\tnetdev_err(np->dev, \"Coherent alloc gives misaligned RXDMA mailbox %p\\n\",\n\t\t\t   rp->mbox);\n\t\treturn -EINVAL;\n\t}\n\n\trp->rcr = np->ops->alloc_coherent(np->device,\n\t\t\t\t\t  MAX_RCR_RING_SIZE * sizeof(__le64),\n\t\t\t\t\t  &rp->rcr_dma, GFP_KERNEL);\n\tif (!rp->rcr)\n\t\treturn -ENOMEM;\n\tif ((unsigned long)rp->rcr & (64UL - 1)) {\n\t\tnetdev_err(np->dev, \"Coherent alloc gives misaligned RXDMA RCR table %p\\n\",\n\t\t\t   rp->rcr);\n\t\treturn -EINVAL;\n\t}\n\trp->rcr_table_size = MAX_RCR_RING_SIZE;\n\trp->rcr_index = 0;\n\n\trp->rbr = np->ops->alloc_coherent(np->device,\n\t\t\t\t\t  MAX_RBR_RING_SIZE * sizeof(__le32),\n\t\t\t\t\t  &rp->rbr_dma, GFP_KERNEL);\n\tif (!rp->rbr)\n\t\treturn -ENOMEM;\n\tif ((unsigned long)rp->rbr & (64UL - 1)) {\n\t\tnetdev_err(np->dev, \"Coherent alloc gives misaligned RXDMA RBR table %p\\n\",\n\t\t\t   rp->rbr);\n\t\treturn -EINVAL;\n\t}\n\trp->rbr_table_size = MAX_RBR_RING_SIZE;\n\trp->rbr_index = 0;\n\trp->rbr_pending = 0;\n\n\treturn 0;\n}\n\nstatic void niu_set_max_burst(struct niu *np, struct tx_ring_info *rp)\n{\n\tint mtu = np->dev->mtu;\n\n\t \n\trp->max_burst = mtu + 32;\n\tif (rp->max_burst > 4096)\n\t\trp->max_burst = 4096;\n}\n\nstatic int niu_alloc_tx_ring_info(struct niu *np,\n\t\t\t\t  struct tx_ring_info *rp)\n{\n\tBUILD_BUG_ON(sizeof(struct txdma_mailbox) != 64);\n\n\trp->mbox = np->ops->alloc_coherent(np->device,\n\t\t\t\t\t   sizeof(struct txdma_mailbox),\n\t\t\t\t\t   &rp->mbox_dma, GFP_KERNEL);\n\tif (!rp->mbox)\n\t\treturn -ENOMEM;\n\tif ((unsigned long)rp->mbox & (64UL - 1)) {\n\t\tnetdev_err(np->dev, \"Coherent alloc gives misaligned TXDMA mailbox %p\\n\",\n\t\t\t   rp->mbox);\n\t\treturn -EINVAL;\n\t}\n\n\trp->descr = np->ops->alloc_coherent(np->device,\n\t\t\t\t\t    MAX_TX_RING_SIZE * sizeof(__le64),\n\t\t\t\t\t    &rp->descr_dma, GFP_KERNEL);\n\tif (!rp->descr)\n\t\treturn -ENOMEM;\n\tif ((unsigned long)rp->descr & (64UL - 1)) {\n\t\tnetdev_err(np->dev, \"Coherent alloc gives misaligned TXDMA descr table %p\\n\",\n\t\t\t   rp->descr);\n\t\treturn -EINVAL;\n\t}\n\n\trp->pending = MAX_TX_RING_SIZE;\n\trp->prod = 0;\n\trp->cons = 0;\n\trp->wrap_bit = 0;\n\n\t \n\trp->mark_freq = rp->pending / 4;\n\n\tniu_set_max_burst(np, rp);\n\n\treturn 0;\n}\n\nstatic void niu_size_rbr(struct niu *np, struct rx_ring_info *rp)\n{\n\tu16 bss;\n\n\tbss = min(PAGE_SHIFT, 15);\n\n\trp->rbr_block_size = 1 << bss;\n\trp->rbr_blocks_per_page = 1 << (PAGE_SHIFT-bss);\n\n\trp->rbr_sizes[0] = 256;\n\trp->rbr_sizes[1] = 1024;\n\tif (np->dev->mtu > ETH_DATA_LEN) {\n\t\tswitch (PAGE_SIZE) {\n\t\tcase 4 * 1024:\n\t\t\trp->rbr_sizes[2] = 4096;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\trp->rbr_sizes[2] = 8192;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\trp->rbr_sizes[2] = 2048;\n\t}\n\trp->rbr_sizes[3] = rp->rbr_block_size;\n}\n\nstatic int niu_alloc_channels(struct niu *np)\n{\n\tstruct niu_parent *parent = np->parent;\n\tint first_rx_channel, first_tx_channel;\n\tint num_rx_rings, num_tx_rings;\n\tstruct rx_ring_info *rx_rings;\n\tstruct tx_ring_info *tx_rings;\n\tint i, port, err;\n\n\tport = np->port;\n\tfirst_rx_channel = first_tx_channel = 0;\n\tfor (i = 0; i < port; i++) {\n\t\tfirst_rx_channel += parent->rxchan_per_port[i];\n\t\tfirst_tx_channel += parent->txchan_per_port[i];\n\t}\n\n\tnum_rx_rings = parent->rxchan_per_port[port];\n\tnum_tx_rings = parent->txchan_per_port[port];\n\n\trx_rings = kcalloc(num_rx_rings, sizeof(struct rx_ring_info),\n\t\t\t   GFP_KERNEL);\n\terr = -ENOMEM;\n\tif (!rx_rings)\n\t\tgoto out_err;\n\n\tnp->num_rx_rings = num_rx_rings;\n\tsmp_wmb();\n\tnp->rx_rings = rx_rings;\n\n\tnetif_set_real_num_rx_queues(np->dev, num_rx_rings);\n\n\tfor (i = 0; i < np->num_rx_rings; i++) {\n\t\tstruct rx_ring_info *rp = &np->rx_rings[i];\n\n\t\trp->np = np;\n\t\trp->rx_channel = first_rx_channel + i;\n\n\t\terr = niu_alloc_rx_ring_info(np, rp);\n\t\tif (err)\n\t\t\tgoto out_err;\n\n\t\tniu_size_rbr(np, rp);\n\n\t\t \n\t\trp->nonsyn_window = 64;\n\t\trp->nonsyn_threshold = rp->rcr_table_size - 64;\n\t\trp->syn_window = 64;\n\t\trp->syn_threshold = rp->rcr_table_size - 64;\n\t\trp->rcr_pkt_threshold = 16;\n\t\trp->rcr_timeout = 8;\n\t\trp->rbr_kick_thresh = RBR_REFILL_MIN;\n\t\tif (rp->rbr_kick_thresh < rp->rbr_blocks_per_page)\n\t\t\trp->rbr_kick_thresh = rp->rbr_blocks_per_page;\n\n\t\terr = niu_rbr_fill(np, rp, GFP_KERNEL);\n\t\tif (err)\n\t\t\tgoto out_err;\n\t}\n\n\ttx_rings = kcalloc(num_tx_rings, sizeof(struct tx_ring_info),\n\t\t\t   GFP_KERNEL);\n\terr = -ENOMEM;\n\tif (!tx_rings)\n\t\tgoto out_err;\n\n\tnp->num_tx_rings = num_tx_rings;\n\tsmp_wmb();\n\tnp->tx_rings = tx_rings;\n\n\tnetif_set_real_num_tx_queues(np->dev, num_tx_rings);\n\n\tfor (i = 0; i < np->num_tx_rings; i++) {\n\t\tstruct tx_ring_info *rp = &np->tx_rings[i];\n\n\t\trp->np = np;\n\t\trp->tx_channel = first_tx_channel + i;\n\n\t\terr = niu_alloc_tx_ring_info(np, rp);\n\t\tif (err)\n\t\t\tgoto out_err;\n\t}\n\n\treturn 0;\n\nout_err:\n\tniu_free_channels(np);\n\treturn err;\n}\n\nstatic int niu_tx_cs_sng_poll(struct niu *np, int channel)\n{\n\tint limit = 1000;\n\n\twhile (--limit > 0) {\n\t\tu64 val = nr64(TX_CS(channel));\n\t\tif (val & TX_CS_SNG_STATE)\n\t\t\treturn 0;\n\t}\n\treturn -ENODEV;\n}\n\nstatic int niu_tx_channel_stop(struct niu *np, int channel)\n{\n\tu64 val = nr64(TX_CS(channel));\n\n\tval |= TX_CS_STOP_N_GO;\n\tnw64(TX_CS(channel), val);\n\n\treturn niu_tx_cs_sng_poll(np, channel);\n}\n\nstatic int niu_tx_cs_reset_poll(struct niu *np, int channel)\n{\n\tint limit = 1000;\n\n\twhile (--limit > 0) {\n\t\tu64 val = nr64(TX_CS(channel));\n\t\tif (!(val & TX_CS_RST))\n\t\t\treturn 0;\n\t}\n\treturn -ENODEV;\n}\n\nstatic int niu_tx_channel_reset(struct niu *np, int channel)\n{\n\tu64 val = nr64(TX_CS(channel));\n\tint err;\n\n\tval |= TX_CS_RST;\n\tnw64(TX_CS(channel), val);\n\n\terr = niu_tx_cs_reset_poll(np, channel);\n\tif (!err)\n\t\tnw64(TX_RING_KICK(channel), 0);\n\n\treturn err;\n}\n\nstatic int niu_tx_channel_lpage_init(struct niu *np, int channel)\n{\n\tu64 val;\n\n\tnw64(TX_LOG_MASK1(channel), 0);\n\tnw64(TX_LOG_VAL1(channel), 0);\n\tnw64(TX_LOG_MASK2(channel), 0);\n\tnw64(TX_LOG_VAL2(channel), 0);\n\tnw64(TX_LOG_PAGE_RELO1(channel), 0);\n\tnw64(TX_LOG_PAGE_RELO2(channel), 0);\n\tnw64(TX_LOG_PAGE_HDL(channel), 0);\n\n\tval  = (u64)np->port << TX_LOG_PAGE_VLD_FUNC_SHIFT;\n\tval |= (TX_LOG_PAGE_VLD_PAGE0 | TX_LOG_PAGE_VLD_PAGE1);\n\tnw64(TX_LOG_PAGE_VLD(channel), val);\n\n\t \n\n\treturn 0;\n}\n\nstatic void niu_txc_enable_port(struct niu *np, int on)\n{\n\tunsigned long flags;\n\tu64 val, mask;\n\n\tniu_lock_parent(np, flags);\n\tval = nr64(TXC_CONTROL);\n\tmask = (u64)1 << np->port;\n\tif (on) {\n\t\tval |= TXC_CONTROL_ENABLE | mask;\n\t} else {\n\t\tval &= ~mask;\n\t\tif ((val & ~TXC_CONTROL_ENABLE) == 0)\n\t\t\tval &= ~TXC_CONTROL_ENABLE;\n\t}\n\tnw64(TXC_CONTROL, val);\n\tniu_unlock_parent(np, flags);\n}\n\nstatic void niu_txc_set_imask(struct niu *np, u64 imask)\n{\n\tunsigned long flags;\n\tu64 val;\n\n\tniu_lock_parent(np, flags);\n\tval = nr64(TXC_INT_MASK);\n\tval &= ~TXC_INT_MASK_VAL(np->port);\n\tval |= (imask << TXC_INT_MASK_VAL_SHIFT(np->port));\n\tniu_unlock_parent(np, flags);\n}\n\nstatic void niu_txc_port_dma_enable(struct niu *np, int on)\n{\n\tu64 val = 0;\n\n\tif (on) {\n\t\tint i;\n\n\t\tfor (i = 0; i < np->num_tx_rings; i++)\n\t\t\tval |= (1 << np->tx_rings[i].tx_channel);\n\t}\n\tnw64(TXC_PORT_DMA(np->port), val);\n}\n\nstatic int niu_init_one_tx_channel(struct niu *np, struct tx_ring_info *rp)\n{\n\tint err, channel = rp->tx_channel;\n\tu64 val, ring_len;\n\n\terr = niu_tx_channel_stop(np, channel);\n\tif (err)\n\t\treturn err;\n\n\terr = niu_tx_channel_reset(np, channel);\n\tif (err)\n\t\treturn err;\n\n\terr = niu_tx_channel_lpage_init(np, channel);\n\tif (err)\n\t\treturn err;\n\n\tnw64(TXC_DMA_MAX(channel), rp->max_burst);\n\tnw64(TX_ENT_MSK(channel), 0);\n\n\tif (rp->descr_dma & ~(TX_RNG_CFIG_STADDR_BASE |\n\t\t\t      TX_RNG_CFIG_STADDR)) {\n\t\tnetdev_err(np->dev, \"TX ring channel %d DMA addr (%llx) is not aligned\\n\",\n\t\t\t   channel, (unsigned long long)rp->descr_dma);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tring_len = (rp->pending / 8);\n\n\tval = ((ring_len << TX_RNG_CFIG_LEN_SHIFT) |\n\t       rp->descr_dma);\n\tnw64(TX_RNG_CFIG(channel), val);\n\n\tif (((rp->mbox_dma >> 32) & ~TXDMA_MBH_MBADDR) ||\n\t    ((u32)rp->mbox_dma & ~TXDMA_MBL_MBADDR)) {\n\t\tnetdev_err(np->dev, \"TX ring channel %d MBOX addr (%llx) has invalid bits\\n\",\n\t\t\t    channel, (unsigned long long)rp->mbox_dma);\n\t\treturn -EINVAL;\n\t}\n\tnw64(TXDMA_MBH(channel), rp->mbox_dma >> 32);\n\tnw64(TXDMA_MBL(channel), rp->mbox_dma & TXDMA_MBL_MBADDR);\n\n\tnw64(TX_CS(channel), 0);\n\n\trp->last_pkt_cnt = 0;\n\n\treturn 0;\n}\n\nstatic void niu_init_rdc_groups(struct niu *np)\n{\n\tstruct niu_rdc_tables *tp = &np->parent->rdc_group_cfg[np->port];\n\tint i, first_table_num = tp->first_table_num;\n\n\tfor (i = 0; i < tp->num_tables; i++) {\n\t\tstruct rdc_table *tbl = &tp->tables[i];\n\t\tint this_table = first_table_num + i;\n\t\tint slot;\n\n\t\tfor (slot = 0; slot < NIU_RDC_TABLE_SLOTS; slot++)\n\t\t\tnw64(RDC_TBL(this_table, slot),\n\t\t\t     tbl->rxdma_channel[slot]);\n\t}\n\n\tnw64(DEF_RDC(np->port), np->parent->rdc_default[np->port]);\n}\n\nstatic void niu_init_drr_weight(struct niu *np)\n{\n\tint type = phy_decode(np->parent->port_phy, np->port);\n\tu64 val;\n\n\tswitch (type) {\n\tcase PORT_TYPE_10G:\n\t\tval = PT_DRR_WEIGHT_DEFAULT_10G;\n\t\tbreak;\n\n\tcase PORT_TYPE_1G:\n\tdefault:\n\t\tval = PT_DRR_WEIGHT_DEFAULT_1G;\n\t\tbreak;\n\t}\n\tnw64(PT_DRR_WT(np->port), val);\n}\n\nstatic int niu_init_hostinfo(struct niu *np)\n{\n\tstruct niu_parent *parent = np->parent;\n\tstruct niu_rdc_tables *tp = &parent->rdc_group_cfg[np->port];\n\tint i, err, num_alt = niu_num_alt_addr(np);\n\tint first_rdc_table = tp->first_table_num;\n\n\terr = niu_set_primary_mac_rdc_table(np, first_rdc_table, 1);\n\tif (err)\n\t\treturn err;\n\n\terr = niu_set_multicast_mac_rdc_table(np, first_rdc_table, 1);\n\tif (err)\n\t\treturn err;\n\n\tfor (i = 0; i < num_alt; i++) {\n\t\terr = niu_set_alt_mac_rdc_table(np, i, first_rdc_table, 1);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int niu_rx_channel_reset(struct niu *np, int channel)\n{\n\treturn niu_set_and_wait_clear(np, RXDMA_CFIG1(channel),\n\t\t\t\t      RXDMA_CFIG1_RST, 1000, 10,\n\t\t\t\t      \"RXDMA_CFIG1\");\n}\n\nstatic int niu_rx_channel_lpage_init(struct niu *np, int channel)\n{\n\tu64 val;\n\n\tnw64(RX_LOG_MASK1(channel), 0);\n\tnw64(RX_LOG_VAL1(channel), 0);\n\tnw64(RX_LOG_MASK2(channel), 0);\n\tnw64(RX_LOG_VAL2(channel), 0);\n\tnw64(RX_LOG_PAGE_RELO1(channel), 0);\n\tnw64(RX_LOG_PAGE_RELO2(channel), 0);\n\tnw64(RX_LOG_PAGE_HDL(channel), 0);\n\n\tval  = (u64)np->port << RX_LOG_PAGE_VLD_FUNC_SHIFT;\n\tval |= (RX_LOG_PAGE_VLD_PAGE0 | RX_LOG_PAGE_VLD_PAGE1);\n\tnw64(RX_LOG_PAGE_VLD(channel), val);\n\n\treturn 0;\n}\n\nstatic void niu_rx_channel_wred_init(struct niu *np, struct rx_ring_info *rp)\n{\n\tu64 val;\n\n\tval = (((u64)rp->nonsyn_window << RDC_RED_PARA_WIN_SHIFT) |\n\t       ((u64)rp->nonsyn_threshold << RDC_RED_PARA_THRE_SHIFT) |\n\t       ((u64)rp->syn_window << RDC_RED_PARA_WIN_SYN_SHIFT) |\n\t       ((u64)rp->syn_threshold << RDC_RED_PARA_THRE_SYN_SHIFT));\n\tnw64(RDC_RED_PARA(rp->rx_channel), val);\n}\n\nstatic int niu_compute_rbr_cfig_b(struct rx_ring_info *rp, u64 *ret)\n{\n\tu64 val = 0;\n\n\t*ret = 0;\n\tswitch (rp->rbr_block_size) {\n\tcase 4 * 1024:\n\t\tval |= (RBR_BLKSIZE_4K << RBR_CFIG_B_BLKSIZE_SHIFT);\n\t\tbreak;\n\tcase 8 * 1024:\n\t\tval |= (RBR_BLKSIZE_8K << RBR_CFIG_B_BLKSIZE_SHIFT);\n\t\tbreak;\n\tcase 16 * 1024:\n\t\tval |= (RBR_BLKSIZE_16K << RBR_CFIG_B_BLKSIZE_SHIFT);\n\t\tbreak;\n\tcase 32 * 1024:\n\t\tval |= (RBR_BLKSIZE_32K << RBR_CFIG_B_BLKSIZE_SHIFT);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tval |= RBR_CFIG_B_VLD2;\n\tswitch (rp->rbr_sizes[2]) {\n\tcase 2 * 1024:\n\t\tval |= (RBR_BUFSZ2_2K << RBR_CFIG_B_BUFSZ2_SHIFT);\n\t\tbreak;\n\tcase 4 * 1024:\n\t\tval |= (RBR_BUFSZ2_4K << RBR_CFIG_B_BUFSZ2_SHIFT);\n\t\tbreak;\n\tcase 8 * 1024:\n\t\tval |= (RBR_BUFSZ2_8K << RBR_CFIG_B_BUFSZ2_SHIFT);\n\t\tbreak;\n\tcase 16 * 1024:\n\t\tval |= (RBR_BUFSZ2_16K << RBR_CFIG_B_BUFSZ2_SHIFT);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tval |= RBR_CFIG_B_VLD1;\n\tswitch (rp->rbr_sizes[1]) {\n\tcase 1 * 1024:\n\t\tval |= (RBR_BUFSZ1_1K << RBR_CFIG_B_BUFSZ1_SHIFT);\n\t\tbreak;\n\tcase 2 * 1024:\n\t\tval |= (RBR_BUFSZ1_2K << RBR_CFIG_B_BUFSZ1_SHIFT);\n\t\tbreak;\n\tcase 4 * 1024:\n\t\tval |= (RBR_BUFSZ1_4K << RBR_CFIG_B_BUFSZ1_SHIFT);\n\t\tbreak;\n\tcase 8 * 1024:\n\t\tval |= (RBR_BUFSZ1_8K << RBR_CFIG_B_BUFSZ1_SHIFT);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tval |= RBR_CFIG_B_VLD0;\n\tswitch (rp->rbr_sizes[0]) {\n\tcase 256:\n\t\tval |= (RBR_BUFSZ0_256 << RBR_CFIG_B_BUFSZ0_SHIFT);\n\t\tbreak;\n\tcase 512:\n\t\tval |= (RBR_BUFSZ0_512 << RBR_CFIG_B_BUFSZ0_SHIFT);\n\t\tbreak;\n\tcase 1 * 1024:\n\t\tval |= (RBR_BUFSZ0_1K << RBR_CFIG_B_BUFSZ0_SHIFT);\n\t\tbreak;\n\tcase 2 * 1024:\n\t\tval |= (RBR_BUFSZ0_2K << RBR_CFIG_B_BUFSZ0_SHIFT);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t*ret = val;\n\treturn 0;\n}\n\nstatic int niu_enable_rx_channel(struct niu *np, int channel, int on)\n{\n\tu64 val = nr64(RXDMA_CFIG1(channel));\n\tint limit;\n\n\tif (on)\n\t\tval |= RXDMA_CFIG1_EN;\n\telse\n\t\tval &= ~RXDMA_CFIG1_EN;\n\tnw64(RXDMA_CFIG1(channel), val);\n\n\tlimit = 1000;\n\twhile (--limit > 0) {\n\t\tif (nr64(RXDMA_CFIG1(channel)) & RXDMA_CFIG1_QST)\n\t\t\tbreak;\n\t\tudelay(10);\n\t}\n\tif (limit <= 0)\n\t\treturn -ENODEV;\n\treturn 0;\n}\n\nstatic int niu_init_one_rx_channel(struct niu *np, struct rx_ring_info *rp)\n{\n\tint err, channel = rp->rx_channel;\n\tu64 val;\n\n\terr = niu_rx_channel_reset(np, channel);\n\tif (err)\n\t\treturn err;\n\n\terr = niu_rx_channel_lpage_init(np, channel);\n\tif (err)\n\t\treturn err;\n\n\tniu_rx_channel_wred_init(np, rp);\n\n\tnw64(RX_DMA_ENT_MSK(channel), RX_DMA_ENT_MSK_RBR_EMPTY);\n\tnw64(RX_DMA_CTL_STAT(channel),\n\t     (RX_DMA_CTL_STAT_MEX |\n\t      RX_DMA_CTL_STAT_RCRTHRES |\n\t      RX_DMA_CTL_STAT_RCRTO |\n\t      RX_DMA_CTL_STAT_RBR_EMPTY));\n\tnw64(RXDMA_CFIG1(channel), rp->mbox_dma >> 32);\n\tnw64(RXDMA_CFIG2(channel),\n\t     ((rp->mbox_dma & RXDMA_CFIG2_MBADDR_L) |\n\t      RXDMA_CFIG2_FULL_HDR));\n\tnw64(RBR_CFIG_A(channel),\n\t     ((u64)rp->rbr_table_size << RBR_CFIG_A_LEN_SHIFT) |\n\t     (rp->rbr_dma & (RBR_CFIG_A_STADDR_BASE | RBR_CFIG_A_STADDR)));\n\terr = niu_compute_rbr_cfig_b(rp, &val);\n\tif (err)\n\t\treturn err;\n\tnw64(RBR_CFIG_B(channel), val);\n\tnw64(RCRCFIG_A(channel),\n\t     ((u64)rp->rcr_table_size << RCRCFIG_A_LEN_SHIFT) |\n\t     (rp->rcr_dma & (RCRCFIG_A_STADDR_BASE | RCRCFIG_A_STADDR)));\n\tnw64(RCRCFIG_B(channel),\n\t     ((u64)rp->rcr_pkt_threshold << RCRCFIG_B_PTHRES_SHIFT) |\n\t     RCRCFIG_B_ENTOUT |\n\t     ((u64)rp->rcr_timeout << RCRCFIG_B_TIMEOUT_SHIFT));\n\n\terr = niu_enable_rx_channel(np, channel, 1);\n\tif (err)\n\t\treturn err;\n\n\tnw64(RBR_KICK(channel), rp->rbr_index);\n\n\tval = nr64(RX_DMA_CTL_STAT(channel));\n\tval |= RX_DMA_CTL_STAT_RBR_EMPTY;\n\tnw64(RX_DMA_CTL_STAT(channel), val);\n\n\treturn 0;\n}\n\nstatic int niu_init_rx_channels(struct niu *np)\n{\n\tunsigned long flags;\n\tu64 seed = jiffies_64;\n\tint err, i;\n\n\tniu_lock_parent(np, flags);\n\tnw64(RX_DMA_CK_DIV, np->parent->rxdma_clock_divider);\n\tnw64(RED_RAN_INIT, RED_RAN_INIT_OPMODE | (seed & RED_RAN_INIT_VAL));\n\tniu_unlock_parent(np, flags);\n\n\t \n\n\tniu_init_rdc_groups(np);\n\tniu_init_drr_weight(np);\n\n\terr = niu_init_hostinfo(np);\n\tif (err)\n\t\treturn err;\n\n\tfor (i = 0; i < np->num_rx_rings; i++) {\n\t\tstruct rx_ring_info *rp = &np->rx_rings[i];\n\n\t\terr = niu_init_one_rx_channel(np, rp);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int niu_set_ip_frag_rule(struct niu *np)\n{\n\tstruct niu_parent *parent = np->parent;\n\tstruct niu_classifier *cp = &np->clas;\n\tstruct niu_tcam_entry *tp;\n\tint index, err;\n\n\tindex = cp->tcam_top;\n\ttp = &parent->tcam[index];\n\n\t \n\tmemset(tp, 0, sizeof(*tp));\n\ttp->key[1] = TCAM_V4KEY1_NOPORT;\n\ttp->key_mask[1] = TCAM_V4KEY1_NOPORT;\n\ttp->assoc_data = (TCAM_ASSOCDATA_TRES_USE_OFFSET |\n\t\t\t  ((u64)0 << TCAM_ASSOCDATA_OFFSET_SHIFT));\n\terr = tcam_write(np, index, tp->key, tp->key_mask);\n\tif (err)\n\t\treturn err;\n\terr = tcam_assoc_write(np, index, tp->assoc_data);\n\tif (err)\n\t\treturn err;\n\ttp->valid = 1;\n\tcp->tcam_valid_entries++;\n\n\treturn 0;\n}\n\nstatic int niu_init_classifier_hw(struct niu *np)\n{\n\tstruct niu_parent *parent = np->parent;\n\tstruct niu_classifier *cp = &np->clas;\n\tint i, err;\n\n\tnw64(H1POLY, cp->h1_init);\n\tnw64(H2POLY, cp->h2_init);\n\n\terr = niu_init_hostinfo(np);\n\tif (err)\n\t\treturn err;\n\n\tfor (i = 0; i < ENET_VLAN_TBL_NUM_ENTRIES; i++) {\n\t\tstruct niu_vlan_rdc *vp = &cp->vlan_mappings[i];\n\n\t\tvlan_tbl_write(np, i, np->port,\n\t\t\t       vp->vlan_pref, vp->rdc_num);\n\t}\n\n\tfor (i = 0; i < cp->num_alt_mac_mappings; i++) {\n\t\tstruct niu_altmac_rdc *ap = &cp->alt_mac_mappings[i];\n\n\t\terr = niu_set_alt_mac_rdc_table(np, ap->alt_mac_num,\n\t\t\t\t\t\tap->rdc_num, ap->mac_pref);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tfor (i = CLASS_CODE_USER_PROG1; i <= CLASS_CODE_SCTP_IPV6; i++) {\n\t\tint index = i - CLASS_CODE_USER_PROG1;\n\n\t\terr = niu_set_tcam_key(np, i, parent->tcam_key[index]);\n\t\tif (err)\n\t\t\treturn err;\n\t\terr = niu_set_flow_key(np, i, parent->flow_key[index]);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\terr = niu_set_ip_frag_rule(np);\n\tif (err)\n\t\treturn err;\n\n\ttcam_enable(np, 1);\n\n\treturn 0;\n}\n\nstatic int niu_zcp_write(struct niu *np, int index, u64 *data)\n{\n\tnw64(ZCP_RAM_DATA0, data[0]);\n\tnw64(ZCP_RAM_DATA1, data[1]);\n\tnw64(ZCP_RAM_DATA2, data[2]);\n\tnw64(ZCP_RAM_DATA3, data[3]);\n\tnw64(ZCP_RAM_DATA4, data[4]);\n\tnw64(ZCP_RAM_BE, ZCP_RAM_BE_VAL);\n\tnw64(ZCP_RAM_ACC,\n\t     (ZCP_RAM_ACC_WRITE |\n\t      (0 << ZCP_RAM_ACC_ZFCID_SHIFT) |\n\t      (ZCP_RAM_SEL_CFIFO(np->port) << ZCP_RAM_ACC_RAM_SEL_SHIFT)));\n\n\treturn niu_wait_bits_clear(np, ZCP_RAM_ACC, ZCP_RAM_ACC_BUSY,\n\t\t\t\t   1000, 100);\n}\n\nstatic int niu_zcp_read(struct niu *np, int index, u64 *data)\n{\n\tint err;\n\n\terr = niu_wait_bits_clear(np, ZCP_RAM_ACC, ZCP_RAM_ACC_BUSY,\n\t\t\t\t  1000, 100);\n\tif (err) {\n\t\tnetdev_err(np->dev, \"ZCP read busy won't clear, ZCP_RAM_ACC[%llx]\\n\",\n\t\t\t   (unsigned long long)nr64(ZCP_RAM_ACC));\n\t\treturn err;\n\t}\n\n\tnw64(ZCP_RAM_ACC,\n\t     (ZCP_RAM_ACC_READ |\n\t      (0 << ZCP_RAM_ACC_ZFCID_SHIFT) |\n\t      (ZCP_RAM_SEL_CFIFO(np->port) << ZCP_RAM_ACC_RAM_SEL_SHIFT)));\n\n\terr = niu_wait_bits_clear(np, ZCP_RAM_ACC, ZCP_RAM_ACC_BUSY,\n\t\t\t\t  1000, 100);\n\tif (err) {\n\t\tnetdev_err(np->dev, \"ZCP read busy2 won't clear, ZCP_RAM_ACC[%llx]\\n\",\n\t\t\t   (unsigned long long)nr64(ZCP_RAM_ACC));\n\t\treturn err;\n\t}\n\n\tdata[0] = nr64(ZCP_RAM_DATA0);\n\tdata[1] = nr64(ZCP_RAM_DATA1);\n\tdata[2] = nr64(ZCP_RAM_DATA2);\n\tdata[3] = nr64(ZCP_RAM_DATA3);\n\tdata[4] = nr64(ZCP_RAM_DATA4);\n\n\treturn 0;\n}\n\nstatic void niu_zcp_cfifo_reset(struct niu *np)\n{\n\tu64 val = nr64(RESET_CFIFO);\n\n\tval |= RESET_CFIFO_RST(np->port);\n\tnw64(RESET_CFIFO, val);\n\tudelay(10);\n\n\tval &= ~RESET_CFIFO_RST(np->port);\n\tnw64(RESET_CFIFO, val);\n}\n\nstatic int niu_init_zcp(struct niu *np)\n{\n\tu64 data[5], rbuf[5];\n\tint i, max, err;\n\n\tif (np->parent->plat_type != PLAT_TYPE_NIU) {\n\t\tif (np->port == 0 || np->port == 1)\n\t\t\tmax = ATLAS_P0_P1_CFIFO_ENTRIES;\n\t\telse\n\t\t\tmax = ATLAS_P2_P3_CFIFO_ENTRIES;\n\t} else\n\t\tmax = NIU_CFIFO_ENTRIES;\n\n\tdata[0] = 0;\n\tdata[1] = 0;\n\tdata[2] = 0;\n\tdata[3] = 0;\n\tdata[4] = 0;\n\n\tfor (i = 0; i < max; i++) {\n\t\terr = niu_zcp_write(np, i, data);\n\t\tif (err)\n\t\t\treturn err;\n\t\terr = niu_zcp_read(np, i, rbuf);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tniu_zcp_cfifo_reset(np);\n\tnw64(CFIFO_ECC(np->port), 0);\n\tnw64(ZCP_INT_STAT, ZCP_INT_STAT_ALL);\n\t(void) nr64(ZCP_INT_STAT);\n\tnw64(ZCP_INT_MASK, ZCP_INT_MASK_ALL);\n\n\treturn 0;\n}\n\nstatic void niu_ipp_write(struct niu *np, int index, u64 *data)\n{\n\tu64 val = nr64_ipp(IPP_CFIG);\n\n\tnw64_ipp(IPP_CFIG, val | IPP_CFIG_DFIFO_PIO_W);\n\tnw64_ipp(IPP_DFIFO_WR_PTR, index);\n\tnw64_ipp(IPP_DFIFO_WR0, data[0]);\n\tnw64_ipp(IPP_DFIFO_WR1, data[1]);\n\tnw64_ipp(IPP_DFIFO_WR2, data[2]);\n\tnw64_ipp(IPP_DFIFO_WR3, data[3]);\n\tnw64_ipp(IPP_DFIFO_WR4, data[4]);\n\tnw64_ipp(IPP_CFIG, val & ~IPP_CFIG_DFIFO_PIO_W);\n}\n\nstatic void niu_ipp_read(struct niu *np, int index, u64 *data)\n{\n\tnw64_ipp(IPP_DFIFO_RD_PTR, index);\n\tdata[0] = nr64_ipp(IPP_DFIFO_RD0);\n\tdata[1] = nr64_ipp(IPP_DFIFO_RD1);\n\tdata[2] = nr64_ipp(IPP_DFIFO_RD2);\n\tdata[3] = nr64_ipp(IPP_DFIFO_RD3);\n\tdata[4] = nr64_ipp(IPP_DFIFO_RD4);\n}\n\nstatic int niu_ipp_reset(struct niu *np)\n{\n\treturn niu_set_and_wait_clear_ipp(np, IPP_CFIG, IPP_CFIG_SOFT_RST,\n\t\t\t\t\t  1000, 100, \"IPP_CFIG\");\n}\n\nstatic int niu_init_ipp(struct niu *np)\n{\n\tu64 data[5], rbuf[5], val;\n\tint i, max, err;\n\n\tif (np->parent->plat_type != PLAT_TYPE_NIU) {\n\t\tif (np->port == 0 || np->port == 1)\n\t\t\tmax = ATLAS_P0_P1_DFIFO_ENTRIES;\n\t\telse\n\t\t\tmax = ATLAS_P2_P3_DFIFO_ENTRIES;\n\t} else\n\t\tmax = NIU_DFIFO_ENTRIES;\n\n\tdata[0] = 0;\n\tdata[1] = 0;\n\tdata[2] = 0;\n\tdata[3] = 0;\n\tdata[4] = 0;\n\n\tfor (i = 0; i < max; i++) {\n\t\tniu_ipp_write(np, i, data);\n\t\tniu_ipp_read(np, i, rbuf);\n\t}\n\n\t(void) nr64_ipp(IPP_INT_STAT);\n\t(void) nr64_ipp(IPP_INT_STAT);\n\n\terr = niu_ipp_reset(np);\n\tif (err)\n\t\treturn err;\n\n\t(void) nr64_ipp(IPP_PKT_DIS);\n\t(void) nr64_ipp(IPP_BAD_CS_CNT);\n\t(void) nr64_ipp(IPP_ECC);\n\n\t(void) nr64_ipp(IPP_INT_STAT);\n\n\tnw64_ipp(IPP_MSK, ~IPP_MSK_ALL);\n\n\tval = nr64_ipp(IPP_CFIG);\n\tval &= ~IPP_CFIG_IP_MAX_PKT;\n\tval |= (IPP_CFIG_IPP_ENABLE |\n\t\tIPP_CFIG_DFIFO_ECC_EN |\n\t\tIPP_CFIG_DROP_BAD_CRC |\n\t\tIPP_CFIG_CKSUM_EN |\n\t\t(0x1ffff << IPP_CFIG_IP_MAX_PKT_SHIFT));\n\tnw64_ipp(IPP_CFIG, val);\n\n\treturn 0;\n}\n\nstatic void niu_handle_led(struct niu *np, int status)\n{\n\tu64 val;\n\tval = nr64_mac(XMAC_CONFIG);\n\n\tif ((np->flags & NIU_FLAGS_10G) != 0 &&\n\t    (np->flags & NIU_FLAGS_FIBER) != 0) {\n\t\tif (status) {\n\t\t\tval |= XMAC_CONFIG_LED_POLARITY;\n\t\t\tval &= ~XMAC_CONFIG_FORCE_LED_ON;\n\t\t} else {\n\t\t\tval |= XMAC_CONFIG_FORCE_LED_ON;\n\t\t\tval &= ~XMAC_CONFIG_LED_POLARITY;\n\t\t}\n\t}\n\n\tnw64_mac(XMAC_CONFIG, val);\n}\n\nstatic void niu_init_xif_xmac(struct niu *np)\n{\n\tstruct niu_link_config *lp = &np->link_config;\n\tu64 val;\n\n\tif (np->flags & NIU_FLAGS_XCVR_SERDES) {\n\t\tval = nr64(MIF_CONFIG);\n\t\tval |= MIF_CONFIG_ATCA_GE;\n\t\tnw64(MIF_CONFIG, val);\n\t}\n\n\tval = nr64_mac(XMAC_CONFIG);\n\tval &= ~XMAC_CONFIG_SEL_POR_CLK_SRC;\n\n\tval |= XMAC_CONFIG_TX_OUTPUT_EN;\n\n\tif (lp->loopback_mode == LOOPBACK_MAC) {\n\t\tval &= ~XMAC_CONFIG_SEL_POR_CLK_SRC;\n\t\tval |= XMAC_CONFIG_LOOPBACK;\n\t} else {\n\t\tval &= ~XMAC_CONFIG_LOOPBACK;\n\t}\n\n\tif (np->flags & NIU_FLAGS_10G) {\n\t\tval &= ~XMAC_CONFIG_LFS_DISABLE;\n\t} else {\n\t\tval |= XMAC_CONFIG_LFS_DISABLE;\n\t\tif (!(np->flags & NIU_FLAGS_FIBER) &&\n\t\t    !(np->flags & NIU_FLAGS_XCVR_SERDES))\n\t\t\tval |= XMAC_CONFIG_1G_PCS_BYPASS;\n\t\telse\n\t\t\tval &= ~XMAC_CONFIG_1G_PCS_BYPASS;\n\t}\n\n\tval &= ~XMAC_CONFIG_10G_XPCS_BYPASS;\n\n\tif (lp->active_speed == SPEED_100)\n\t\tval |= XMAC_CONFIG_SEL_CLK_25MHZ;\n\telse\n\t\tval &= ~XMAC_CONFIG_SEL_CLK_25MHZ;\n\n\tnw64_mac(XMAC_CONFIG, val);\n\n\tval = nr64_mac(XMAC_CONFIG);\n\tval &= ~XMAC_CONFIG_MODE_MASK;\n\tif (np->flags & NIU_FLAGS_10G) {\n\t\tval |= XMAC_CONFIG_MODE_XGMII;\n\t} else {\n\t\tif (lp->active_speed == SPEED_1000)\n\t\t\tval |= XMAC_CONFIG_MODE_GMII;\n\t\telse\n\t\t\tval |= XMAC_CONFIG_MODE_MII;\n\t}\n\n\tnw64_mac(XMAC_CONFIG, val);\n}\n\nstatic void niu_init_xif_bmac(struct niu *np)\n{\n\tstruct niu_link_config *lp = &np->link_config;\n\tu64 val;\n\n\tval = BMAC_XIF_CONFIG_TX_OUTPUT_EN;\n\n\tif (lp->loopback_mode == LOOPBACK_MAC)\n\t\tval |= BMAC_XIF_CONFIG_MII_LOOPBACK;\n\telse\n\t\tval &= ~BMAC_XIF_CONFIG_MII_LOOPBACK;\n\n\tif (lp->active_speed == SPEED_1000)\n\t\tval |= BMAC_XIF_CONFIG_GMII_MODE;\n\telse\n\t\tval &= ~BMAC_XIF_CONFIG_GMII_MODE;\n\n\tval &= ~(BMAC_XIF_CONFIG_LINK_LED |\n\t\t BMAC_XIF_CONFIG_LED_POLARITY);\n\n\tif (!(np->flags & NIU_FLAGS_10G) &&\n\t    !(np->flags & NIU_FLAGS_FIBER) &&\n\t    lp->active_speed == SPEED_100)\n\t\tval |= BMAC_XIF_CONFIG_25MHZ_CLOCK;\n\telse\n\t\tval &= ~BMAC_XIF_CONFIG_25MHZ_CLOCK;\n\n\tnw64_mac(BMAC_XIF_CONFIG, val);\n}\n\nstatic void niu_init_xif(struct niu *np)\n{\n\tif (np->flags & NIU_FLAGS_XMAC)\n\t\tniu_init_xif_xmac(np);\n\telse\n\t\tniu_init_xif_bmac(np);\n}\n\nstatic void niu_pcs_mii_reset(struct niu *np)\n{\n\tint limit = 1000;\n\tu64 val = nr64_pcs(PCS_MII_CTL);\n\tval |= PCS_MII_CTL_RST;\n\tnw64_pcs(PCS_MII_CTL, val);\n\twhile ((--limit >= 0) && (val & PCS_MII_CTL_RST)) {\n\t\tudelay(100);\n\t\tval = nr64_pcs(PCS_MII_CTL);\n\t}\n}\n\nstatic void niu_xpcs_reset(struct niu *np)\n{\n\tint limit = 1000;\n\tu64 val = nr64_xpcs(XPCS_CONTROL1);\n\tval |= XPCS_CONTROL1_RESET;\n\tnw64_xpcs(XPCS_CONTROL1, val);\n\twhile ((--limit >= 0) && (val & XPCS_CONTROL1_RESET)) {\n\t\tudelay(100);\n\t\tval = nr64_xpcs(XPCS_CONTROL1);\n\t}\n}\n\nstatic int niu_init_pcs(struct niu *np)\n{\n\tstruct niu_link_config *lp = &np->link_config;\n\tu64 val;\n\n\tswitch (np->flags & (NIU_FLAGS_10G |\n\t\t\t     NIU_FLAGS_FIBER |\n\t\t\t     NIU_FLAGS_XCVR_SERDES)) {\n\tcase NIU_FLAGS_FIBER:\n\t\t \n\t\tnw64_pcs(PCS_CONF, PCS_CONF_MASK | PCS_CONF_ENABLE);\n\t\tnw64_pcs(PCS_DPATH_MODE, 0);\n\t\tniu_pcs_mii_reset(np);\n\t\tbreak;\n\n\tcase NIU_FLAGS_10G:\n\tcase NIU_FLAGS_10G | NIU_FLAGS_FIBER:\n\tcase NIU_FLAGS_10G | NIU_FLAGS_XCVR_SERDES:\n\t\t \n\t\tif (!(np->flags & NIU_FLAGS_XMAC))\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tval = nr64_mac(XMAC_CONFIG);\n\t\tval &= ~XMAC_CONFIG_10G_XPCS_BYPASS;\n\t\tnw64_mac(XMAC_CONFIG, val);\n\n\t\tniu_xpcs_reset(np);\n\n\t\tval = nr64_xpcs(XPCS_CONTROL1);\n\t\tif (lp->loopback_mode == LOOPBACK_PHY)\n\t\t\tval |= XPCS_CONTROL1_LOOPBACK;\n\t\telse\n\t\t\tval &= ~XPCS_CONTROL1_LOOPBACK;\n\t\tnw64_xpcs(XPCS_CONTROL1, val);\n\n\t\tnw64_xpcs(XPCS_DESKEW_ERR_CNT, 0);\n\t\t(void) nr64_xpcs(XPCS_SYMERR_CNT01);\n\t\t(void) nr64_xpcs(XPCS_SYMERR_CNT23);\n\t\tbreak;\n\n\n\tcase NIU_FLAGS_XCVR_SERDES:\n\t\t \n\t\tniu_pcs_mii_reset(np);\n\t\tnw64_pcs(PCS_CONF, PCS_CONF_MASK | PCS_CONF_ENABLE);\n\t\tnw64_pcs(PCS_DPATH_MODE, 0);\n\t\tbreak;\n\n\tcase 0:\n\t\t \n\tcase NIU_FLAGS_XCVR_SERDES | NIU_FLAGS_FIBER:\n\t\t \n\t\tnw64_pcs(PCS_DPATH_MODE, PCS_DPATH_MODE_MII);\n\t\tniu_pcs_mii_reset(np);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int niu_reset_tx_xmac(struct niu *np)\n{\n\treturn niu_set_and_wait_clear_mac(np, XTXMAC_SW_RST,\n\t\t\t\t\t  (XTXMAC_SW_RST_REG_RS |\n\t\t\t\t\t   XTXMAC_SW_RST_SOFT_RST),\n\t\t\t\t\t  1000, 100, \"XTXMAC_SW_RST\");\n}\n\nstatic int niu_reset_tx_bmac(struct niu *np)\n{\n\tint limit;\n\n\tnw64_mac(BTXMAC_SW_RST, BTXMAC_SW_RST_RESET);\n\tlimit = 1000;\n\twhile (--limit >= 0) {\n\t\tif (!(nr64_mac(BTXMAC_SW_RST) & BTXMAC_SW_RST_RESET))\n\t\t\tbreak;\n\t\tudelay(100);\n\t}\n\tif (limit < 0) {\n\t\tdev_err(np->device, \"Port %u TX BMAC would not reset, BTXMAC_SW_RST[%llx]\\n\",\n\t\t\tnp->port,\n\t\t\t(unsigned long long) nr64_mac(BTXMAC_SW_RST));\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic int niu_reset_tx_mac(struct niu *np)\n{\n\tif (np->flags & NIU_FLAGS_XMAC)\n\t\treturn niu_reset_tx_xmac(np);\n\telse\n\t\treturn niu_reset_tx_bmac(np);\n}\n\nstatic void niu_init_tx_xmac(struct niu *np, u64 min, u64 max)\n{\n\tu64 val;\n\n\tval = nr64_mac(XMAC_MIN);\n\tval &= ~(XMAC_MIN_TX_MIN_PKT_SIZE |\n\t\t XMAC_MIN_RX_MIN_PKT_SIZE);\n\tval |= (min << XMAC_MIN_RX_MIN_PKT_SIZE_SHFT);\n\tval |= (min << XMAC_MIN_TX_MIN_PKT_SIZE_SHFT);\n\tnw64_mac(XMAC_MIN, val);\n\n\tnw64_mac(XMAC_MAX, max);\n\n\tnw64_mac(XTXMAC_STAT_MSK, ~(u64)0);\n\n\tval = nr64_mac(XMAC_IPG);\n\tif (np->flags & NIU_FLAGS_10G) {\n\t\tval &= ~XMAC_IPG_IPG_XGMII;\n\t\tval |= (IPG_12_15_XGMII << XMAC_IPG_IPG_XGMII_SHIFT);\n\t} else {\n\t\tval &= ~XMAC_IPG_IPG_MII_GMII;\n\t\tval |= (IPG_12_MII_GMII << XMAC_IPG_IPG_MII_GMII_SHIFT);\n\t}\n\tnw64_mac(XMAC_IPG, val);\n\n\tval = nr64_mac(XMAC_CONFIG);\n\tval &= ~(XMAC_CONFIG_ALWAYS_NO_CRC |\n\t\t XMAC_CONFIG_STRETCH_MODE |\n\t\t XMAC_CONFIG_VAR_MIN_IPG_EN |\n\t\t XMAC_CONFIG_TX_ENABLE);\n\tnw64_mac(XMAC_CONFIG, val);\n\n\tnw64_mac(TXMAC_FRM_CNT, 0);\n\tnw64_mac(TXMAC_BYTE_CNT, 0);\n}\n\nstatic void niu_init_tx_bmac(struct niu *np, u64 min, u64 max)\n{\n\tu64 val;\n\n\tnw64_mac(BMAC_MIN_FRAME, min);\n\tnw64_mac(BMAC_MAX_FRAME, max);\n\n\tnw64_mac(BTXMAC_STATUS_MASK, ~(u64)0);\n\tnw64_mac(BMAC_CTRL_TYPE, 0x8808);\n\tnw64_mac(BMAC_PREAMBLE_SIZE, 7);\n\n\tval = nr64_mac(BTXMAC_CONFIG);\n\tval &= ~(BTXMAC_CONFIG_FCS_DISABLE |\n\t\t BTXMAC_CONFIG_ENABLE);\n\tnw64_mac(BTXMAC_CONFIG, val);\n}\n\nstatic void niu_init_tx_mac(struct niu *np)\n{\n\tu64 min, max;\n\n\tmin = 64;\n\tif (np->dev->mtu > ETH_DATA_LEN)\n\t\tmax = 9216;\n\telse\n\t\tmax = 1522;\n\n\t \n\tBUG_ON(min & 0x7);\n\n\tif (np->flags & NIU_FLAGS_XMAC)\n\t\tniu_init_tx_xmac(np, min, max);\n\telse\n\t\tniu_init_tx_bmac(np, min, max);\n}\n\nstatic int niu_reset_rx_xmac(struct niu *np)\n{\n\tint limit;\n\n\tnw64_mac(XRXMAC_SW_RST,\n\t\t XRXMAC_SW_RST_REG_RS | XRXMAC_SW_RST_SOFT_RST);\n\tlimit = 1000;\n\twhile (--limit >= 0) {\n\t\tif (!(nr64_mac(XRXMAC_SW_RST) & (XRXMAC_SW_RST_REG_RS |\n\t\t\t\t\t\t XRXMAC_SW_RST_SOFT_RST)))\n\t\t\tbreak;\n\t\tudelay(100);\n\t}\n\tif (limit < 0) {\n\t\tdev_err(np->device, \"Port %u RX XMAC would not reset, XRXMAC_SW_RST[%llx]\\n\",\n\t\t\tnp->port,\n\t\t\t(unsigned long long) nr64_mac(XRXMAC_SW_RST));\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic int niu_reset_rx_bmac(struct niu *np)\n{\n\tint limit;\n\n\tnw64_mac(BRXMAC_SW_RST, BRXMAC_SW_RST_RESET);\n\tlimit = 1000;\n\twhile (--limit >= 0) {\n\t\tif (!(nr64_mac(BRXMAC_SW_RST) & BRXMAC_SW_RST_RESET))\n\t\t\tbreak;\n\t\tudelay(100);\n\t}\n\tif (limit < 0) {\n\t\tdev_err(np->device, \"Port %u RX BMAC would not reset, BRXMAC_SW_RST[%llx]\\n\",\n\t\t\tnp->port,\n\t\t\t(unsigned long long) nr64_mac(BRXMAC_SW_RST));\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic int niu_reset_rx_mac(struct niu *np)\n{\n\tif (np->flags & NIU_FLAGS_XMAC)\n\t\treturn niu_reset_rx_xmac(np);\n\telse\n\t\treturn niu_reset_rx_bmac(np);\n}\n\nstatic void niu_init_rx_xmac(struct niu *np)\n{\n\tstruct niu_parent *parent = np->parent;\n\tstruct niu_rdc_tables *tp = &parent->rdc_group_cfg[np->port];\n\tint first_rdc_table = tp->first_table_num;\n\tunsigned long i;\n\tu64 val;\n\n\tnw64_mac(XMAC_ADD_FILT0, 0);\n\tnw64_mac(XMAC_ADD_FILT1, 0);\n\tnw64_mac(XMAC_ADD_FILT2, 0);\n\tnw64_mac(XMAC_ADD_FILT12_MASK, 0);\n\tnw64_mac(XMAC_ADD_FILT00_MASK, 0);\n\tfor (i = 0; i < MAC_NUM_HASH; i++)\n\t\tnw64_mac(XMAC_HASH_TBL(i), 0);\n\tnw64_mac(XRXMAC_STAT_MSK, ~(u64)0);\n\tniu_set_primary_mac_rdc_table(np, first_rdc_table, 1);\n\tniu_set_multicast_mac_rdc_table(np, first_rdc_table, 1);\n\n\tval = nr64_mac(XMAC_CONFIG);\n\tval &= ~(XMAC_CONFIG_RX_MAC_ENABLE |\n\t\t XMAC_CONFIG_PROMISCUOUS |\n\t\t XMAC_CONFIG_PROMISC_GROUP |\n\t\t XMAC_CONFIG_ERR_CHK_DIS |\n\t\t XMAC_CONFIG_RX_CRC_CHK_DIS |\n\t\t XMAC_CONFIG_RESERVED_MULTICAST |\n\t\t XMAC_CONFIG_RX_CODEV_CHK_DIS |\n\t\t XMAC_CONFIG_ADDR_FILTER_EN |\n\t\t XMAC_CONFIG_RCV_PAUSE_ENABLE |\n\t\t XMAC_CONFIG_STRIP_CRC |\n\t\t XMAC_CONFIG_PASS_FLOW_CTRL |\n\t\t XMAC_CONFIG_MAC2IPP_PKT_CNT_EN);\n\tval |= (XMAC_CONFIG_HASH_FILTER_EN);\n\tnw64_mac(XMAC_CONFIG, val);\n\n\tnw64_mac(RXMAC_BT_CNT, 0);\n\tnw64_mac(RXMAC_BC_FRM_CNT, 0);\n\tnw64_mac(RXMAC_MC_FRM_CNT, 0);\n\tnw64_mac(RXMAC_FRAG_CNT, 0);\n\tnw64_mac(RXMAC_HIST_CNT1, 0);\n\tnw64_mac(RXMAC_HIST_CNT2, 0);\n\tnw64_mac(RXMAC_HIST_CNT3, 0);\n\tnw64_mac(RXMAC_HIST_CNT4, 0);\n\tnw64_mac(RXMAC_HIST_CNT5, 0);\n\tnw64_mac(RXMAC_HIST_CNT6, 0);\n\tnw64_mac(RXMAC_HIST_CNT7, 0);\n\tnw64_mac(RXMAC_MPSZER_CNT, 0);\n\tnw64_mac(RXMAC_CRC_ER_CNT, 0);\n\tnw64_mac(RXMAC_CD_VIO_CNT, 0);\n\tnw64_mac(LINK_FAULT_CNT, 0);\n}\n\nstatic void niu_init_rx_bmac(struct niu *np)\n{\n\tstruct niu_parent *parent = np->parent;\n\tstruct niu_rdc_tables *tp = &parent->rdc_group_cfg[np->port];\n\tint first_rdc_table = tp->first_table_num;\n\tunsigned long i;\n\tu64 val;\n\n\tnw64_mac(BMAC_ADD_FILT0, 0);\n\tnw64_mac(BMAC_ADD_FILT1, 0);\n\tnw64_mac(BMAC_ADD_FILT2, 0);\n\tnw64_mac(BMAC_ADD_FILT12_MASK, 0);\n\tnw64_mac(BMAC_ADD_FILT00_MASK, 0);\n\tfor (i = 0; i < MAC_NUM_HASH; i++)\n\t\tnw64_mac(BMAC_HASH_TBL(i), 0);\n\tniu_set_primary_mac_rdc_table(np, first_rdc_table, 1);\n\tniu_set_multicast_mac_rdc_table(np, first_rdc_table, 1);\n\tnw64_mac(BRXMAC_STATUS_MASK, ~(u64)0);\n\n\tval = nr64_mac(BRXMAC_CONFIG);\n\tval &= ~(BRXMAC_CONFIG_ENABLE |\n\t\t BRXMAC_CONFIG_STRIP_PAD |\n\t\t BRXMAC_CONFIG_STRIP_FCS |\n\t\t BRXMAC_CONFIG_PROMISC |\n\t\t BRXMAC_CONFIG_PROMISC_GRP |\n\t\t BRXMAC_CONFIG_ADDR_FILT_EN |\n\t\t BRXMAC_CONFIG_DISCARD_DIS);\n\tval |= (BRXMAC_CONFIG_HASH_FILT_EN);\n\tnw64_mac(BRXMAC_CONFIG, val);\n\n\tval = nr64_mac(BMAC_ADDR_CMPEN);\n\tval |= BMAC_ADDR_CMPEN_EN0;\n\tnw64_mac(BMAC_ADDR_CMPEN, val);\n}\n\nstatic void niu_init_rx_mac(struct niu *np)\n{\n\tniu_set_primary_mac(np, np->dev->dev_addr);\n\n\tif (np->flags & NIU_FLAGS_XMAC)\n\t\tniu_init_rx_xmac(np);\n\telse\n\t\tniu_init_rx_bmac(np);\n}\n\nstatic void niu_enable_tx_xmac(struct niu *np, int on)\n{\n\tu64 val = nr64_mac(XMAC_CONFIG);\n\n\tif (on)\n\t\tval |= XMAC_CONFIG_TX_ENABLE;\n\telse\n\t\tval &= ~XMAC_CONFIG_TX_ENABLE;\n\tnw64_mac(XMAC_CONFIG, val);\n}\n\nstatic void niu_enable_tx_bmac(struct niu *np, int on)\n{\n\tu64 val = nr64_mac(BTXMAC_CONFIG);\n\n\tif (on)\n\t\tval |= BTXMAC_CONFIG_ENABLE;\n\telse\n\t\tval &= ~BTXMAC_CONFIG_ENABLE;\n\tnw64_mac(BTXMAC_CONFIG, val);\n}\n\nstatic void niu_enable_tx_mac(struct niu *np, int on)\n{\n\tif (np->flags & NIU_FLAGS_XMAC)\n\t\tniu_enable_tx_xmac(np, on);\n\telse\n\t\tniu_enable_tx_bmac(np, on);\n}\n\nstatic void niu_enable_rx_xmac(struct niu *np, int on)\n{\n\tu64 val = nr64_mac(XMAC_CONFIG);\n\n\tval &= ~(XMAC_CONFIG_HASH_FILTER_EN |\n\t\t XMAC_CONFIG_PROMISCUOUS);\n\n\tif (np->flags & NIU_FLAGS_MCAST)\n\t\tval |= XMAC_CONFIG_HASH_FILTER_EN;\n\tif (np->flags & NIU_FLAGS_PROMISC)\n\t\tval |= XMAC_CONFIG_PROMISCUOUS;\n\n\tif (on)\n\t\tval |= XMAC_CONFIG_RX_MAC_ENABLE;\n\telse\n\t\tval &= ~XMAC_CONFIG_RX_MAC_ENABLE;\n\tnw64_mac(XMAC_CONFIG, val);\n}\n\nstatic void niu_enable_rx_bmac(struct niu *np, int on)\n{\n\tu64 val = nr64_mac(BRXMAC_CONFIG);\n\n\tval &= ~(BRXMAC_CONFIG_HASH_FILT_EN |\n\t\t BRXMAC_CONFIG_PROMISC);\n\n\tif (np->flags & NIU_FLAGS_MCAST)\n\t\tval |= BRXMAC_CONFIG_HASH_FILT_EN;\n\tif (np->flags & NIU_FLAGS_PROMISC)\n\t\tval |= BRXMAC_CONFIG_PROMISC;\n\n\tif (on)\n\t\tval |= BRXMAC_CONFIG_ENABLE;\n\telse\n\t\tval &= ~BRXMAC_CONFIG_ENABLE;\n\tnw64_mac(BRXMAC_CONFIG, val);\n}\n\nstatic void niu_enable_rx_mac(struct niu *np, int on)\n{\n\tif (np->flags & NIU_FLAGS_XMAC)\n\t\tniu_enable_rx_xmac(np, on);\n\telse\n\t\tniu_enable_rx_bmac(np, on);\n}\n\nstatic int niu_init_mac(struct niu *np)\n{\n\tint err;\n\n\tniu_init_xif(np);\n\terr = niu_init_pcs(np);\n\tif (err)\n\t\treturn err;\n\n\terr = niu_reset_tx_mac(np);\n\tif (err)\n\t\treturn err;\n\tniu_init_tx_mac(np);\n\terr = niu_reset_rx_mac(np);\n\tif (err)\n\t\treturn err;\n\tniu_init_rx_mac(np);\n\n\t \n\tniu_init_tx_mac(np);\n\tniu_enable_tx_mac(np, 1);\n\n\tniu_enable_rx_mac(np, 1);\n\n\treturn 0;\n}\n\nstatic void niu_stop_one_tx_channel(struct niu *np, struct tx_ring_info *rp)\n{\n\t(void) niu_tx_channel_stop(np, rp->tx_channel);\n}\n\nstatic void niu_stop_tx_channels(struct niu *np)\n{\n\tint i;\n\n\tfor (i = 0; i < np->num_tx_rings; i++) {\n\t\tstruct tx_ring_info *rp = &np->tx_rings[i];\n\n\t\tniu_stop_one_tx_channel(np, rp);\n\t}\n}\n\nstatic void niu_reset_one_tx_channel(struct niu *np, struct tx_ring_info *rp)\n{\n\t(void) niu_tx_channel_reset(np, rp->tx_channel);\n}\n\nstatic void niu_reset_tx_channels(struct niu *np)\n{\n\tint i;\n\n\tfor (i = 0; i < np->num_tx_rings; i++) {\n\t\tstruct tx_ring_info *rp = &np->tx_rings[i];\n\n\t\tniu_reset_one_tx_channel(np, rp);\n\t}\n}\n\nstatic void niu_stop_one_rx_channel(struct niu *np, struct rx_ring_info *rp)\n{\n\t(void) niu_enable_rx_channel(np, rp->rx_channel, 0);\n}\n\nstatic void niu_stop_rx_channels(struct niu *np)\n{\n\tint i;\n\n\tfor (i = 0; i < np->num_rx_rings; i++) {\n\t\tstruct rx_ring_info *rp = &np->rx_rings[i];\n\n\t\tniu_stop_one_rx_channel(np, rp);\n\t}\n}\n\nstatic void niu_reset_one_rx_channel(struct niu *np, struct rx_ring_info *rp)\n{\n\tint channel = rp->rx_channel;\n\n\t(void) niu_rx_channel_reset(np, channel);\n\tnw64(RX_DMA_ENT_MSK(channel), RX_DMA_ENT_MSK_ALL);\n\tnw64(RX_DMA_CTL_STAT(channel), 0);\n\t(void) niu_enable_rx_channel(np, channel, 0);\n}\n\nstatic void niu_reset_rx_channels(struct niu *np)\n{\n\tint i;\n\n\tfor (i = 0; i < np->num_rx_rings; i++) {\n\t\tstruct rx_ring_info *rp = &np->rx_rings[i];\n\n\t\tniu_reset_one_rx_channel(np, rp);\n\t}\n}\n\nstatic void niu_disable_ipp(struct niu *np)\n{\n\tu64 rd, wr, val;\n\tint limit;\n\n\trd = nr64_ipp(IPP_DFIFO_RD_PTR);\n\twr = nr64_ipp(IPP_DFIFO_WR_PTR);\n\tlimit = 100;\n\twhile (--limit >= 0 && (rd != wr)) {\n\t\trd = nr64_ipp(IPP_DFIFO_RD_PTR);\n\t\twr = nr64_ipp(IPP_DFIFO_WR_PTR);\n\t}\n\tif (limit < 0 &&\n\t    (rd != 0 && wr != 1)) {\n\t\tnetdev_err(np->dev, \"IPP would not quiesce, rd_ptr[%llx] wr_ptr[%llx]\\n\",\n\t\t\t   (unsigned long long)nr64_ipp(IPP_DFIFO_RD_PTR),\n\t\t\t   (unsigned long long)nr64_ipp(IPP_DFIFO_WR_PTR));\n\t}\n\n\tval = nr64_ipp(IPP_CFIG);\n\tval &= ~(IPP_CFIG_IPP_ENABLE |\n\t\t IPP_CFIG_DFIFO_ECC_EN |\n\t\t IPP_CFIG_DROP_BAD_CRC |\n\t\t IPP_CFIG_CKSUM_EN);\n\tnw64_ipp(IPP_CFIG, val);\n\n\t(void) niu_ipp_reset(np);\n}\n\nstatic int niu_init_hw(struct niu *np)\n{\n\tint i, err;\n\n\tnetif_printk(np, ifup, KERN_DEBUG, np->dev, \"Initialize TXC\\n\");\n\tniu_txc_enable_port(np, 1);\n\tniu_txc_port_dma_enable(np, 1);\n\tniu_txc_set_imask(np, 0);\n\n\tnetif_printk(np, ifup, KERN_DEBUG, np->dev, \"Initialize TX channels\\n\");\n\tfor (i = 0; i < np->num_tx_rings; i++) {\n\t\tstruct tx_ring_info *rp = &np->tx_rings[i];\n\n\t\terr = niu_init_one_tx_channel(np, rp);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tnetif_printk(np, ifup, KERN_DEBUG, np->dev, \"Initialize RX channels\\n\");\n\terr = niu_init_rx_channels(np);\n\tif (err)\n\t\tgoto out_uninit_tx_channels;\n\n\tnetif_printk(np, ifup, KERN_DEBUG, np->dev, \"Initialize classifier\\n\");\n\terr = niu_init_classifier_hw(np);\n\tif (err)\n\t\tgoto out_uninit_rx_channels;\n\n\tnetif_printk(np, ifup, KERN_DEBUG, np->dev, \"Initialize ZCP\\n\");\n\terr = niu_init_zcp(np);\n\tif (err)\n\t\tgoto out_uninit_rx_channels;\n\n\tnetif_printk(np, ifup, KERN_DEBUG, np->dev, \"Initialize IPP\\n\");\n\terr = niu_init_ipp(np);\n\tif (err)\n\t\tgoto out_uninit_rx_channels;\n\n\tnetif_printk(np, ifup, KERN_DEBUG, np->dev, \"Initialize MAC\\n\");\n\terr = niu_init_mac(np);\n\tif (err)\n\t\tgoto out_uninit_ipp;\n\n\treturn 0;\n\nout_uninit_ipp:\n\tnetif_printk(np, ifup, KERN_DEBUG, np->dev, \"Uninit IPP\\n\");\n\tniu_disable_ipp(np);\n\nout_uninit_rx_channels:\n\tnetif_printk(np, ifup, KERN_DEBUG, np->dev, \"Uninit RX channels\\n\");\n\tniu_stop_rx_channels(np);\n\tniu_reset_rx_channels(np);\n\nout_uninit_tx_channels:\n\tnetif_printk(np, ifup, KERN_DEBUG, np->dev, \"Uninit TX channels\\n\");\n\tniu_stop_tx_channels(np);\n\tniu_reset_tx_channels(np);\n\n\treturn err;\n}\n\nstatic void niu_stop_hw(struct niu *np)\n{\n\tnetif_printk(np, ifdown, KERN_DEBUG, np->dev, \"Disable interrupts\\n\");\n\tniu_enable_interrupts(np, 0);\n\n\tnetif_printk(np, ifdown, KERN_DEBUG, np->dev, \"Disable RX MAC\\n\");\n\tniu_enable_rx_mac(np, 0);\n\n\tnetif_printk(np, ifdown, KERN_DEBUG, np->dev, \"Disable IPP\\n\");\n\tniu_disable_ipp(np);\n\n\tnetif_printk(np, ifdown, KERN_DEBUG, np->dev, \"Stop TX channels\\n\");\n\tniu_stop_tx_channels(np);\n\n\tnetif_printk(np, ifdown, KERN_DEBUG, np->dev, \"Stop RX channels\\n\");\n\tniu_stop_rx_channels(np);\n\n\tnetif_printk(np, ifdown, KERN_DEBUG, np->dev, \"Reset TX channels\\n\");\n\tniu_reset_tx_channels(np);\n\n\tnetif_printk(np, ifdown, KERN_DEBUG, np->dev, \"Reset RX channels\\n\");\n\tniu_reset_rx_channels(np);\n}\n\nstatic void niu_set_irq_name(struct niu *np)\n{\n\tint port = np->port;\n\tint i, j = 1;\n\n\tsprintf(np->irq_name[0], \"%s:MAC\", np->dev->name);\n\n\tif (port == 0) {\n\t\tsprintf(np->irq_name[1], \"%s:MIF\", np->dev->name);\n\t\tsprintf(np->irq_name[2], \"%s:SYSERR\", np->dev->name);\n\t\tj = 3;\n\t}\n\n\tfor (i = 0; i < np->num_ldg - j; i++) {\n\t\tif (i < np->num_rx_rings)\n\t\t\tsprintf(np->irq_name[i+j], \"%s-rx-%d\",\n\t\t\t\tnp->dev->name, i);\n\t\telse if (i < np->num_tx_rings + np->num_rx_rings)\n\t\t\tsprintf(np->irq_name[i+j], \"%s-tx-%d\", np->dev->name,\n\t\t\t\ti - np->num_rx_rings);\n\t}\n}\n\nstatic int niu_request_irq(struct niu *np)\n{\n\tint i, j, err;\n\n\tniu_set_irq_name(np);\n\n\terr = 0;\n\tfor (i = 0; i < np->num_ldg; i++) {\n\t\tstruct niu_ldg *lp = &np->ldg[i];\n\n\t\terr = request_irq(lp->irq, niu_interrupt, IRQF_SHARED,\n\t\t\t\t  np->irq_name[i], lp);\n\t\tif (err)\n\t\t\tgoto out_free_irqs;\n\n\t}\n\n\treturn 0;\n\nout_free_irqs:\n\tfor (j = 0; j < i; j++) {\n\t\tstruct niu_ldg *lp = &np->ldg[j];\n\n\t\tfree_irq(lp->irq, lp);\n\t}\n\treturn err;\n}\n\nstatic void niu_free_irq(struct niu *np)\n{\n\tint i;\n\n\tfor (i = 0; i < np->num_ldg; i++) {\n\t\tstruct niu_ldg *lp = &np->ldg[i];\n\n\t\tfree_irq(lp->irq, lp);\n\t}\n}\n\nstatic void niu_enable_napi(struct niu *np)\n{\n\tint i;\n\n\tfor (i = 0; i < np->num_ldg; i++)\n\t\tnapi_enable(&np->ldg[i].napi);\n}\n\nstatic void niu_disable_napi(struct niu *np)\n{\n\tint i;\n\n\tfor (i = 0; i < np->num_ldg; i++)\n\t\tnapi_disable(&np->ldg[i].napi);\n}\n\nstatic int niu_open(struct net_device *dev)\n{\n\tstruct niu *np = netdev_priv(dev);\n\tint err;\n\n\tnetif_carrier_off(dev);\n\n\terr = niu_alloc_channels(np);\n\tif (err)\n\t\tgoto out_err;\n\n\terr = niu_enable_interrupts(np, 0);\n\tif (err)\n\t\tgoto out_free_channels;\n\n\terr = niu_request_irq(np);\n\tif (err)\n\t\tgoto out_free_channels;\n\n\tniu_enable_napi(np);\n\n\tspin_lock_irq(&np->lock);\n\n\terr = niu_init_hw(np);\n\tif (!err) {\n\t\ttimer_setup(&np->timer, niu_timer, 0);\n\t\tnp->timer.expires = jiffies + HZ;\n\n\t\terr = niu_enable_interrupts(np, 1);\n\t\tif (err)\n\t\t\tniu_stop_hw(np);\n\t}\n\n\tspin_unlock_irq(&np->lock);\n\n\tif (err) {\n\t\tniu_disable_napi(np);\n\t\tgoto out_free_irq;\n\t}\n\n\tnetif_tx_start_all_queues(dev);\n\n\tif (np->link_config.loopback_mode != LOOPBACK_DISABLED)\n\t\tnetif_carrier_on(dev);\n\n\tadd_timer(&np->timer);\n\n\treturn 0;\n\nout_free_irq:\n\tniu_free_irq(np);\n\nout_free_channels:\n\tniu_free_channels(np);\n\nout_err:\n\treturn err;\n}\n\nstatic void niu_full_shutdown(struct niu *np, struct net_device *dev)\n{\n\tcancel_work_sync(&np->reset_task);\n\n\tniu_disable_napi(np);\n\tnetif_tx_stop_all_queues(dev);\n\n\tdel_timer_sync(&np->timer);\n\n\tspin_lock_irq(&np->lock);\n\n\tniu_stop_hw(np);\n\n\tspin_unlock_irq(&np->lock);\n}\n\nstatic int niu_close(struct net_device *dev)\n{\n\tstruct niu *np = netdev_priv(dev);\n\n\tniu_full_shutdown(np, dev);\n\n\tniu_free_irq(np);\n\n\tniu_free_channels(np);\n\n\tniu_handle_led(np, 0);\n\n\treturn 0;\n}\n\nstatic void niu_sync_xmac_stats(struct niu *np)\n{\n\tstruct niu_xmac_stats *mp = &np->mac_stats.xmac;\n\n\tmp->tx_frames += nr64_mac(TXMAC_FRM_CNT);\n\tmp->tx_bytes += nr64_mac(TXMAC_BYTE_CNT);\n\n\tmp->rx_link_faults += nr64_mac(LINK_FAULT_CNT);\n\tmp->rx_align_errors += nr64_mac(RXMAC_ALIGN_ERR_CNT);\n\tmp->rx_frags += nr64_mac(RXMAC_FRAG_CNT);\n\tmp->rx_mcasts += nr64_mac(RXMAC_MC_FRM_CNT);\n\tmp->rx_bcasts += nr64_mac(RXMAC_BC_FRM_CNT);\n\tmp->rx_hist_cnt1 += nr64_mac(RXMAC_HIST_CNT1);\n\tmp->rx_hist_cnt2 += nr64_mac(RXMAC_HIST_CNT2);\n\tmp->rx_hist_cnt3 += nr64_mac(RXMAC_HIST_CNT3);\n\tmp->rx_hist_cnt4 += nr64_mac(RXMAC_HIST_CNT4);\n\tmp->rx_hist_cnt5 += nr64_mac(RXMAC_HIST_CNT5);\n\tmp->rx_hist_cnt6 += nr64_mac(RXMAC_HIST_CNT6);\n\tmp->rx_hist_cnt7 += nr64_mac(RXMAC_HIST_CNT7);\n\tmp->rx_octets += nr64_mac(RXMAC_BT_CNT);\n\tmp->rx_code_violations += nr64_mac(RXMAC_CD_VIO_CNT);\n\tmp->rx_len_errors += nr64_mac(RXMAC_MPSZER_CNT);\n\tmp->rx_crc_errors += nr64_mac(RXMAC_CRC_ER_CNT);\n}\n\nstatic void niu_sync_bmac_stats(struct niu *np)\n{\n\tstruct niu_bmac_stats *mp = &np->mac_stats.bmac;\n\n\tmp->tx_bytes += nr64_mac(BTXMAC_BYTE_CNT);\n\tmp->tx_frames += nr64_mac(BTXMAC_FRM_CNT);\n\n\tmp->rx_frames += nr64_mac(BRXMAC_FRAME_CNT);\n\tmp->rx_align_errors += nr64_mac(BRXMAC_ALIGN_ERR_CNT);\n\tmp->rx_crc_errors += nr64_mac(BRXMAC_ALIGN_ERR_CNT);\n\tmp->rx_len_errors += nr64_mac(BRXMAC_CODE_VIOL_ERR_CNT);\n}\n\nstatic void niu_sync_mac_stats(struct niu *np)\n{\n\tif (np->flags & NIU_FLAGS_XMAC)\n\t\tniu_sync_xmac_stats(np);\n\telse\n\t\tniu_sync_bmac_stats(np);\n}\n\nstatic void niu_get_rx_stats(struct niu *np,\n\t\t\t     struct rtnl_link_stats64 *stats)\n{\n\tu64 pkts, dropped, errors, bytes;\n\tstruct rx_ring_info *rx_rings;\n\tint i;\n\n\tpkts = dropped = errors = bytes = 0;\n\n\trx_rings = READ_ONCE(np->rx_rings);\n\tif (!rx_rings)\n\t\tgoto no_rings;\n\n\tfor (i = 0; i < np->num_rx_rings; i++) {\n\t\tstruct rx_ring_info *rp = &rx_rings[i];\n\n\t\tniu_sync_rx_discard_stats(np, rp, 0);\n\n\t\tpkts += rp->rx_packets;\n\t\tbytes += rp->rx_bytes;\n\t\tdropped += rp->rx_dropped;\n\t\terrors += rp->rx_errors;\n\t}\n\nno_rings:\n\tstats->rx_packets = pkts;\n\tstats->rx_bytes = bytes;\n\tstats->rx_dropped = dropped;\n\tstats->rx_errors = errors;\n}\n\nstatic void niu_get_tx_stats(struct niu *np,\n\t\t\t     struct rtnl_link_stats64 *stats)\n{\n\tu64 pkts, errors, bytes;\n\tstruct tx_ring_info *tx_rings;\n\tint i;\n\n\tpkts = errors = bytes = 0;\n\n\ttx_rings = READ_ONCE(np->tx_rings);\n\tif (!tx_rings)\n\t\tgoto no_rings;\n\n\tfor (i = 0; i < np->num_tx_rings; i++) {\n\t\tstruct tx_ring_info *rp = &tx_rings[i];\n\n\t\tpkts += rp->tx_packets;\n\t\tbytes += rp->tx_bytes;\n\t\terrors += rp->tx_errors;\n\t}\n\nno_rings:\n\tstats->tx_packets = pkts;\n\tstats->tx_bytes = bytes;\n\tstats->tx_errors = errors;\n}\n\nstatic void niu_get_stats(struct net_device *dev,\n\t\t\t  struct rtnl_link_stats64 *stats)\n{\n\tstruct niu *np = netdev_priv(dev);\n\n\tif (netif_running(dev)) {\n\t\tniu_get_rx_stats(np, stats);\n\t\tniu_get_tx_stats(np, stats);\n\t}\n}\n\nstatic void niu_load_hash_xmac(struct niu *np, u16 *hash)\n{\n\tint i;\n\n\tfor (i = 0; i < 16; i++)\n\t\tnw64_mac(XMAC_HASH_TBL(i), hash[i]);\n}\n\nstatic void niu_load_hash_bmac(struct niu *np, u16 *hash)\n{\n\tint i;\n\n\tfor (i = 0; i < 16; i++)\n\t\tnw64_mac(BMAC_HASH_TBL(i), hash[i]);\n}\n\nstatic void niu_load_hash(struct niu *np, u16 *hash)\n{\n\tif (np->flags & NIU_FLAGS_XMAC)\n\t\tniu_load_hash_xmac(np, hash);\n\telse\n\t\tniu_load_hash_bmac(np, hash);\n}\n\nstatic void niu_set_rx_mode(struct net_device *dev)\n{\n\tstruct niu *np = netdev_priv(dev);\n\tint i, alt_cnt, err;\n\tstruct netdev_hw_addr *ha;\n\tunsigned long flags;\n\tu16 hash[16] = { 0, };\n\n\tspin_lock_irqsave(&np->lock, flags);\n\tniu_enable_rx_mac(np, 0);\n\n\tnp->flags &= ~(NIU_FLAGS_MCAST | NIU_FLAGS_PROMISC);\n\tif (dev->flags & IFF_PROMISC)\n\t\tnp->flags |= NIU_FLAGS_PROMISC;\n\tif ((dev->flags & IFF_ALLMULTI) || (!netdev_mc_empty(dev)))\n\t\tnp->flags |= NIU_FLAGS_MCAST;\n\n\talt_cnt = netdev_uc_count(dev);\n\tif (alt_cnt > niu_num_alt_addr(np)) {\n\t\talt_cnt = 0;\n\t\tnp->flags |= NIU_FLAGS_PROMISC;\n\t}\n\n\tif (alt_cnt) {\n\t\tint index = 0;\n\n\t\tnetdev_for_each_uc_addr(ha, dev) {\n\t\t\terr = niu_set_alt_mac(np, index, ha->addr);\n\t\t\tif (err)\n\t\t\t\tnetdev_warn(dev, \"Error %d adding alt mac %d\\n\",\n\t\t\t\t\t    err, index);\n\t\t\terr = niu_enable_alt_mac(np, index, 1);\n\t\t\tif (err)\n\t\t\t\tnetdev_warn(dev, \"Error %d enabling alt mac %d\\n\",\n\t\t\t\t\t    err, index);\n\n\t\t\tindex++;\n\t\t}\n\t} else {\n\t\tint alt_start;\n\t\tif (np->flags & NIU_FLAGS_XMAC)\n\t\t\talt_start = 0;\n\t\telse\n\t\t\talt_start = 1;\n\t\tfor (i = alt_start; i < niu_num_alt_addr(np); i++) {\n\t\t\terr = niu_enable_alt_mac(np, i, 0);\n\t\t\tif (err)\n\t\t\t\tnetdev_warn(dev, \"Error %d disabling alt mac %d\\n\",\n\t\t\t\t\t    err, i);\n\t\t}\n\t}\n\tif (dev->flags & IFF_ALLMULTI) {\n\t\tfor (i = 0; i < 16; i++)\n\t\t\thash[i] = 0xffff;\n\t} else if (!netdev_mc_empty(dev)) {\n\t\tnetdev_for_each_mc_addr(ha, dev) {\n\t\t\tu32 crc = ether_crc_le(ETH_ALEN, ha->addr);\n\n\t\t\tcrc >>= 24;\n\t\t\thash[crc >> 4] |= (1 << (15 - (crc & 0xf)));\n\t\t}\n\t}\n\n\tif (np->flags & NIU_FLAGS_MCAST)\n\t\tniu_load_hash(np, hash);\n\n\tniu_enable_rx_mac(np, 1);\n\tspin_unlock_irqrestore(&np->lock, flags);\n}\n\nstatic int niu_set_mac_addr(struct net_device *dev, void *p)\n{\n\tstruct niu *np = netdev_priv(dev);\n\tstruct sockaddr *addr = p;\n\tunsigned long flags;\n\n\tif (!is_valid_ether_addr(addr->sa_data))\n\t\treturn -EADDRNOTAVAIL;\n\n\teth_hw_addr_set(dev, addr->sa_data);\n\n\tif (!netif_running(dev))\n\t\treturn 0;\n\n\tspin_lock_irqsave(&np->lock, flags);\n\tniu_enable_rx_mac(np, 0);\n\tniu_set_primary_mac(np, dev->dev_addr);\n\tniu_enable_rx_mac(np, 1);\n\tspin_unlock_irqrestore(&np->lock, flags);\n\n\treturn 0;\n}\n\nstatic int niu_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic void niu_netif_stop(struct niu *np)\n{\n\tnetif_trans_update(np->dev);\t \n\n\tniu_disable_napi(np);\n\n\tnetif_tx_disable(np->dev);\n}\n\nstatic void niu_netif_start(struct niu *np)\n{\n\t \n\tnetif_tx_wake_all_queues(np->dev);\n\n\tniu_enable_napi(np);\n\n\tniu_enable_interrupts(np, 1);\n}\n\nstatic void niu_reset_buffers(struct niu *np)\n{\n\tint i, j, k, err;\n\n\tif (np->rx_rings) {\n\t\tfor (i = 0; i < np->num_rx_rings; i++) {\n\t\t\tstruct rx_ring_info *rp = &np->rx_rings[i];\n\n\t\t\tfor (j = 0, k = 0; j < MAX_RBR_RING_SIZE; j++) {\n\t\t\t\tstruct page *page;\n\n\t\t\t\tpage = rp->rxhash[j];\n\t\t\t\twhile (page) {\n\t\t\t\t\tstruct page *next = niu_next_page(page);\n\t\t\t\t\tu64 base = page->index;\n\t\t\t\t\tbase = base >> RBR_DESCR_ADDR_SHIFT;\n\t\t\t\t\trp->rbr[k++] = cpu_to_le32(base);\n\t\t\t\t\tpage = next;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (; k < MAX_RBR_RING_SIZE; k++) {\n\t\t\t\terr = niu_rbr_add_page(np, rp, GFP_ATOMIC, k);\n\t\t\t\tif (unlikely(err))\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\trp->rbr_index = rp->rbr_table_size - 1;\n\t\t\trp->rcr_index = 0;\n\t\t\trp->rbr_pending = 0;\n\t\t\trp->rbr_refill_pending = 0;\n\t\t}\n\t}\n\tif (np->tx_rings) {\n\t\tfor (i = 0; i < np->num_tx_rings; i++) {\n\t\t\tstruct tx_ring_info *rp = &np->tx_rings[i];\n\n\t\t\tfor (j = 0; j < MAX_TX_RING_SIZE; j++) {\n\t\t\t\tif (rp->tx_buffs[j].skb)\n\t\t\t\t\t(void) release_tx_packet(np, rp, j);\n\t\t\t}\n\n\t\t\trp->pending = MAX_TX_RING_SIZE;\n\t\t\trp->prod = 0;\n\t\t\trp->cons = 0;\n\t\t\trp->wrap_bit = 0;\n\t\t}\n\t}\n}\n\nstatic void niu_reset_task(struct work_struct *work)\n{\n\tstruct niu *np = container_of(work, struct niu, reset_task);\n\tunsigned long flags;\n\tint err;\n\n\tspin_lock_irqsave(&np->lock, flags);\n\tif (!netif_running(np->dev)) {\n\t\tspin_unlock_irqrestore(&np->lock, flags);\n\t\treturn;\n\t}\n\n\tspin_unlock_irqrestore(&np->lock, flags);\n\n\tdel_timer_sync(&np->timer);\n\n\tniu_netif_stop(np);\n\n\tspin_lock_irqsave(&np->lock, flags);\n\n\tniu_stop_hw(np);\n\n\tspin_unlock_irqrestore(&np->lock, flags);\n\n\tniu_reset_buffers(np);\n\n\tspin_lock_irqsave(&np->lock, flags);\n\n\terr = niu_init_hw(np);\n\tif (!err) {\n\t\tnp->timer.expires = jiffies + HZ;\n\t\tadd_timer(&np->timer);\n\t\tniu_netif_start(np);\n\t}\n\n\tspin_unlock_irqrestore(&np->lock, flags);\n}\n\nstatic void niu_tx_timeout(struct net_device *dev, unsigned int txqueue)\n{\n\tstruct niu *np = netdev_priv(dev);\n\n\tdev_err(np->device, \"%s: Transmit timed out, resetting\\n\",\n\t\tdev->name);\n\n\tschedule_work(&np->reset_task);\n}\n\nstatic void niu_set_txd(struct tx_ring_info *rp, int index,\n\t\t\tu64 mapping, u64 len, u64 mark,\n\t\t\tu64 n_frags)\n{\n\t__le64 *desc = &rp->descr[index];\n\n\t*desc = cpu_to_le64(mark |\n\t\t\t    (n_frags << TX_DESC_NUM_PTR_SHIFT) |\n\t\t\t    (len << TX_DESC_TR_LEN_SHIFT) |\n\t\t\t    (mapping & TX_DESC_SAD));\n}\n\nstatic u64 niu_compute_tx_flags(struct sk_buff *skb, struct ethhdr *ehdr,\n\t\t\t\tu64 pad_bytes, u64 len)\n{\n\tu16 eth_proto, eth_proto_inner;\n\tu64 csum_bits, l3off, ihl, ret;\n\tu8 ip_proto;\n\tint ipv6;\n\n\teth_proto = be16_to_cpu(ehdr->h_proto);\n\teth_proto_inner = eth_proto;\n\tif (eth_proto == ETH_P_8021Q) {\n\t\tstruct vlan_ethhdr *vp = (struct vlan_ethhdr *) ehdr;\n\t\t__be16 val = vp->h_vlan_encapsulated_proto;\n\n\t\teth_proto_inner = be16_to_cpu(val);\n\t}\n\n\tipv6 = ihl = 0;\n\tswitch (skb->protocol) {\n\tcase cpu_to_be16(ETH_P_IP):\n\t\tip_proto = ip_hdr(skb)->protocol;\n\t\tihl = ip_hdr(skb)->ihl;\n\t\tbreak;\n\tcase cpu_to_be16(ETH_P_IPV6):\n\t\tip_proto = ipv6_hdr(skb)->nexthdr;\n\t\tihl = (40 >> 2);\n\t\tipv6 = 1;\n\t\tbreak;\n\tdefault:\n\t\tip_proto = ihl = 0;\n\t\tbreak;\n\t}\n\n\tcsum_bits = TXHDR_CSUM_NONE;\n\tif (skb->ip_summed == CHECKSUM_PARTIAL) {\n\t\tu64 start, stuff;\n\n\t\tcsum_bits = (ip_proto == IPPROTO_TCP ?\n\t\t\t     TXHDR_CSUM_TCP :\n\t\t\t     (ip_proto == IPPROTO_UDP ?\n\t\t\t      TXHDR_CSUM_UDP : TXHDR_CSUM_SCTP));\n\n\t\tstart = skb_checksum_start_offset(skb) -\n\t\t\t(pad_bytes + sizeof(struct tx_pkt_hdr));\n\t\tstuff = start + skb->csum_offset;\n\n\t\tcsum_bits |= (start / 2) << TXHDR_L4START_SHIFT;\n\t\tcsum_bits |= (stuff / 2) << TXHDR_L4STUFF_SHIFT;\n\t}\n\n\tl3off = skb_network_offset(skb) -\n\t\t(pad_bytes + sizeof(struct tx_pkt_hdr));\n\n\tret = (((pad_bytes / 2) << TXHDR_PAD_SHIFT) |\n\t       (len << TXHDR_LEN_SHIFT) |\n\t       ((l3off / 2) << TXHDR_L3START_SHIFT) |\n\t       (ihl << TXHDR_IHL_SHIFT) |\n\t       ((eth_proto_inner < ETH_P_802_3_MIN) ? TXHDR_LLC : 0) |\n\t       ((eth_proto == ETH_P_8021Q) ? TXHDR_VLAN : 0) |\n\t       (ipv6 ? TXHDR_IP_VER : 0) |\n\t       csum_bits);\n\n\treturn ret;\n}\n\nstatic netdev_tx_t niu_start_xmit(struct sk_buff *skb,\n\t\t\t\t  struct net_device *dev)\n{\n\tstruct niu *np = netdev_priv(dev);\n\tunsigned long align, headroom;\n\tstruct netdev_queue *txq;\n\tstruct tx_ring_info *rp;\n\tstruct tx_pkt_hdr *tp;\n\tunsigned int len, nfg;\n\tstruct ethhdr *ehdr;\n\tint prod, i, tlen;\n\tu64 mapping, mrk;\n\n\ti = skb_get_queue_mapping(skb);\n\trp = &np->tx_rings[i];\n\ttxq = netdev_get_tx_queue(dev, i);\n\n\tif (niu_tx_avail(rp) <= (skb_shinfo(skb)->nr_frags + 1)) {\n\t\tnetif_tx_stop_queue(txq);\n\t\tdev_err(np->device, \"%s: BUG! Tx ring full when queue awake!\\n\", dev->name);\n\t\trp->tx_errors++;\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\n\tif (eth_skb_pad(skb))\n\t\tgoto out;\n\n\tlen = sizeof(struct tx_pkt_hdr) + 15;\n\tif (skb_headroom(skb) < len) {\n\t\tstruct sk_buff *skb_new;\n\n\t\tskb_new = skb_realloc_headroom(skb, len);\n\t\tif (!skb_new)\n\t\t\tgoto out_drop;\n\t\tkfree_skb(skb);\n\t\tskb = skb_new;\n\t} else\n\t\tskb_orphan(skb);\n\n\talign = ((unsigned long) skb->data & (16 - 1));\n\theadroom = align + sizeof(struct tx_pkt_hdr);\n\n\tehdr = (struct ethhdr *) skb->data;\n\ttp = skb_push(skb, headroom);\n\n\tlen = skb->len - sizeof(struct tx_pkt_hdr);\n\ttp->flags = cpu_to_le64(niu_compute_tx_flags(skb, ehdr, align, len));\n\ttp->resv = 0;\n\n\tlen = skb_headlen(skb);\n\tmapping = np->ops->map_single(np->device, skb->data,\n\t\t\t\t      len, DMA_TO_DEVICE);\n\n\tprod = rp->prod;\n\n\trp->tx_buffs[prod].skb = skb;\n\trp->tx_buffs[prod].mapping = mapping;\n\n\tmrk = TX_DESC_SOP;\n\tif (++rp->mark_counter == rp->mark_freq) {\n\t\trp->mark_counter = 0;\n\t\tmrk |= TX_DESC_MARK;\n\t\trp->mark_pending++;\n\t}\n\n\ttlen = len;\n\tnfg = skb_shinfo(skb)->nr_frags;\n\twhile (tlen > 0) {\n\t\ttlen -= MAX_TX_DESC_LEN;\n\t\tnfg++;\n\t}\n\n\twhile (len > 0) {\n\t\tunsigned int this_len = len;\n\n\t\tif (this_len > MAX_TX_DESC_LEN)\n\t\t\tthis_len = MAX_TX_DESC_LEN;\n\n\t\tniu_set_txd(rp, prod, mapping, this_len, mrk, nfg);\n\t\tmrk = nfg = 0;\n\n\t\tprod = NEXT_TX(rp, prod);\n\t\tmapping += this_len;\n\t\tlen -= this_len;\n\t}\n\n\tfor (i = 0; i <  skb_shinfo(skb)->nr_frags; i++) {\n\t\tconst skb_frag_t *frag = &skb_shinfo(skb)->frags[i];\n\n\t\tlen = skb_frag_size(frag);\n\t\tmapping = np->ops->map_page(np->device, skb_frag_page(frag),\n\t\t\t\t\t    skb_frag_off(frag), len,\n\t\t\t\t\t    DMA_TO_DEVICE);\n\n\t\trp->tx_buffs[prod].skb = NULL;\n\t\trp->tx_buffs[prod].mapping = mapping;\n\n\t\tniu_set_txd(rp, prod, mapping, len, 0, 0);\n\n\t\tprod = NEXT_TX(rp, prod);\n\t}\n\n\tif (prod < rp->prod)\n\t\trp->wrap_bit ^= TX_RING_KICK_WRAP;\n\trp->prod = prod;\n\n\tnw64(TX_RING_KICK(rp->tx_channel), rp->wrap_bit | (prod << 3));\n\n\tif (unlikely(niu_tx_avail(rp) <= (MAX_SKB_FRAGS + 1))) {\n\t\tnetif_tx_stop_queue(txq);\n\t\tif (niu_tx_avail(rp) > NIU_TX_WAKEUP_THRESH(rp))\n\t\t\tnetif_tx_wake_queue(txq);\n\t}\n\nout:\n\treturn NETDEV_TX_OK;\n\nout_drop:\n\trp->tx_errors++;\n\tkfree_skb(skb);\n\tgoto out;\n}\n\nstatic int niu_change_mtu(struct net_device *dev, int new_mtu)\n{\n\tstruct niu *np = netdev_priv(dev);\n\tint err, orig_jumbo, new_jumbo;\n\n\torig_jumbo = (dev->mtu > ETH_DATA_LEN);\n\tnew_jumbo = (new_mtu > ETH_DATA_LEN);\n\n\tdev->mtu = new_mtu;\n\n\tif (!netif_running(dev) ||\n\t    (orig_jumbo == new_jumbo))\n\t\treturn 0;\n\n\tniu_full_shutdown(np, dev);\n\n\tniu_free_channels(np);\n\n\tniu_enable_napi(np);\n\n\terr = niu_alloc_channels(np);\n\tif (err)\n\t\treturn err;\n\n\tspin_lock_irq(&np->lock);\n\n\terr = niu_init_hw(np);\n\tif (!err) {\n\t\ttimer_setup(&np->timer, niu_timer, 0);\n\t\tnp->timer.expires = jiffies + HZ;\n\n\t\terr = niu_enable_interrupts(np, 1);\n\t\tif (err)\n\t\t\tniu_stop_hw(np);\n\t}\n\n\tspin_unlock_irq(&np->lock);\n\n\tif (!err) {\n\t\tnetif_tx_start_all_queues(dev);\n\t\tif (np->link_config.loopback_mode != LOOPBACK_DISABLED)\n\t\t\tnetif_carrier_on(dev);\n\n\t\tadd_timer(&np->timer);\n\t}\n\n\treturn err;\n}\n\nstatic void niu_get_drvinfo(struct net_device *dev,\n\t\t\t    struct ethtool_drvinfo *info)\n{\n\tstruct niu *np = netdev_priv(dev);\n\tstruct niu_vpd *vpd = &np->vpd;\n\n\tstrscpy(info->driver, DRV_MODULE_NAME, sizeof(info->driver));\n\tstrscpy(info->version, DRV_MODULE_VERSION, sizeof(info->version));\n\tsnprintf(info->fw_version, sizeof(info->fw_version), \"%d.%d\",\n\t\tvpd->fcode_major, vpd->fcode_minor);\n\tif (np->parent->plat_type != PLAT_TYPE_NIU)\n\t\tstrscpy(info->bus_info, pci_name(np->pdev),\n\t\t\tsizeof(info->bus_info));\n}\n\nstatic int niu_get_link_ksettings(struct net_device *dev,\n\t\t\t\t  struct ethtool_link_ksettings *cmd)\n{\n\tstruct niu *np = netdev_priv(dev);\n\tstruct niu_link_config *lp;\n\n\tlp = &np->link_config;\n\n\tmemset(cmd, 0, sizeof(*cmd));\n\tcmd->base.phy_address = np->phy_addr;\n\tethtool_convert_legacy_u32_to_link_mode(cmd->link_modes.supported,\n\t\t\t\t\t\tlp->supported);\n\tethtool_convert_legacy_u32_to_link_mode(cmd->link_modes.advertising,\n\t\t\t\t\t\tlp->active_advertising);\n\tcmd->base.autoneg = lp->active_autoneg;\n\tcmd->base.speed = lp->active_speed;\n\tcmd->base.duplex = lp->active_duplex;\n\tcmd->base.port = (np->flags & NIU_FLAGS_FIBER) ? PORT_FIBRE : PORT_TP;\n\n\treturn 0;\n}\n\nstatic int niu_set_link_ksettings(struct net_device *dev,\n\t\t\t\t  const struct ethtool_link_ksettings *cmd)\n{\n\tstruct niu *np = netdev_priv(dev);\n\tstruct niu_link_config *lp = &np->link_config;\n\n\tethtool_convert_link_mode_to_legacy_u32(&lp->advertising,\n\t\t\t\t\t\tcmd->link_modes.advertising);\n\tlp->speed = cmd->base.speed;\n\tlp->duplex = cmd->base.duplex;\n\tlp->autoneg = cmd->base.autoneg;\n\treturn niu_init_link(np);\n}\n\nstatic u32 niu_get_msglevel(struct net_device *dev)\n{\n\tstruct niu *np = netdev_priv(dev);\n\treturn np->msg_enable;\n}\n\nstatic void niu_set_msglevel(struct net_device *dev, u32 value)\n{\n\tstruct niu *np = netdev_priv(dev);\n\tnp->msg_enable = value;\n}\n\nstatic int niu_nway_reset(struct net_device *dev)\n{\n\tstruct niu *np = netdev_priv(dev);\n\n\tif (np->link_config.autoneg)\n\t\treturn niu_init_link(np);\n\n\treturn 0;\n}\n\nstatic int niu_get_eeprom_len(struct net_device *dev)\n{\n\tstruct niu *np = netdev_priv(dev);\n\n\treturn np->eeprom_len;\n}\n\nstatic int niu_get_eeprom(struct net_device *dev,\n\t\t\t  struct ethtool_eeprom *eeprom, u8 *data)\n{\n\tstruct niu *np = netdev_priv(dev);\n\tu32 offset, len, val;\n\n\toffset = eeprom->offset;\n\tlen = eeprom->len;\n\n\tif (offset + len < offset)\n\t\treturn -EINVAL;\n\tif (offset >= np->eeprom_len)\n\t\treturn -EINVAL;\n\tif (offset + len > np->eeprom_len)\n\t\tlen = eeprom->len = np->eeprom_len - offset;\n\n\tif (offset & 3) {\n\t\tu32 b_offset, b_count;\n\n\t\tb_offset = offset & 3;\n\t\tb_count = 4 - b_offset;\n\t\tif (b_count > len)\n\t\t\tb_count = len;\n\n\t\tval = nr64(ESPC_NCR((offset - b_offset) / 4));\n\t\tmemcpy(data, ((char *)&val) + b_offset, b_count);\n\t\tdata += b_count;\n\t\tlen -= b_count;\n\t\toffset += b_count;\n\t}\n\twhile (len >= 4) {\n\t\tval = nr64(ESPC_NCR(offset / 4));\n\t\tmemcpy(data, &val, 4);\n\t\tdata += 4;\n\t\tlen -= 4;\n\t\toffset += 4;\n\t}\n\tif (len) {\n\t\tval = nr64(ESPC_NCR(offset / 4));\n\t\tmemcpy(data, &val, len);\n\t}\n\treturn 0;\n}\n\nstatic void niu_ethflow_to_l3proto(int flow_type, u8 *pid)\n{\n\tswitch (flow_type) {\n\tcase TCP_V4_FLOW:\n\tcase TCP_V6_FLOW:\n\t\t*pid = IPPROTO_TCP;\n\t\tbreak;\n\tcase UDP_V4_FLOW:\n\tcase UDP_V6_FLOW:\n\t\t*pid = IPPROTO_UDP;\n\t\tbreak;\n\tcase SCTP_V4_FLOW:\n\tcase SCTP_V6_FLOW:\n\t\t*pid = IPPROTO_SCTP;\n\t\tbreak;\n\tcase AH_V4_FLOW:\n\tcase AH_V6_FLOW:\n\t\t*pid = IPPROTO_AH;\n\t\tbreak;\n\tcase ESP_V4_FLOW:\n\tcase ESP_V6_FLOW:\n\t\t*pid = IPPROTO_ESP;\n\t\tbreak;\n\tdefault:\n\t\t*pid = 0;\n\t\tbreak;\n\t}\n}\n\nstatic int niu_class_to_ethflow(u64 class, int *flow_type)\n{\n\tswitch (class) {\n\tcase CLASS_CODE_TCP_IPV4:\n\t\t*flow_type = TCP_V4_FLOW;\n\t\tbreak;\n\tcase CLASS_CODE_UDP_IPV4:\n\t\t*flow_type = UDP_V4_FLOW;\n\t\tbreak;\n\tcase CLASS_CODE_AH_ESP_IPV4:\n\t\t*flow_type = AH_V4_FLOW;\n\t\tbreak;\n\tcase CLASS_CODE_SCTP_IPV4:\n\t\t*flow_type = SCTP_V4_FLOW;\n\t\tbreak;\n\tcase CLASS_CODE_TCP_IPV6:\n\t\t*flow_type = TCP_V6_FLOW;\n\t\tbreak;\n\tcase CLASS_CODE_UDP_IPV6:\n\t\t*flow_type = UDP_V6_FLOW;\n\t\tbreak;\n\tcase CLASS_CODE_AH_ESP_IPV6:\n\t\t*flow_type = AH_V6_FLOW;\n\t\tbreak;\n\tcase CLASS_CODE_SCTP_IPV6:\n\t\t*flow_type = SCTP_V6_FLOW;\n\t\tbreak;\n\tcase CLASS_CODE_USER_PROG1:\n\tcase CLASS_CODE_USER_PROG2:\n\tcase CLASS_CODE_USER_PROG3:\n\tcase CLASS_CODE_USER_PROG4:\n\t\t*flow_type = IP_USER_FLOW;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int niu_ethflow_to_class(int flow_type, u64 *class)\n{\n\tswitch (flow_type) {\n\tcase TCP_V4_FLOW:\n\t\t*class = CLASS_CODE_TCP_IPV4;\n\t\tbreak;\n\tcase UDP_V4_FLOW:\n\t\t*class = CLASS_CODE_UDP_IPV4;\n\t\tbreak;\n\tcase AH_ESP_V4_FLOW:\n\tcase AH_V4_FLOW:\n\tcase ESP_V4_FLOW:\n\t\t*class = CLASS_CODE_AH_ESP_IPV4;\n\t\tbreak;\n\tcase SCTP_V4_FLOW:\n\t\t*class = CLASS_CODE_SCTP_IPV4;\n\t\tbreak;\n\tcase TCP_V6_FLOW:\n\t\t*class = CLASS_CODE_TCP_IPV6;\n\t\tbreak;\n\tcase UDP_V6_FLOW:\n\t\t*class = CLASS_CODE_UDP_IPV6;\n\t\tbreak;\n\tcase AH_ESP_V6_FLOW:\n\tcase AH_V6_FLOW:\n\tcase ESP_V6_FLOW:\n\t\t*class = CLASS_CODE_AH_ESP_IPV6;\n\t\tbreak;\n\tcase SCTP_V6_FLOW:\n\t\t*class = CLASS_CODE_SCTP_IPV6;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic u64 niu_flowkey_to_ethflow(u64 flow_key)\n{\n\tu64 ethflow = 0;\n\n\tif (flow_key & FLOW_KEY_L2DA)\n\t\tethflow |= RXH_L2DA;\n\tif (flow_key & FLOW_KEY_VLAN)\n\t\tethflow |= RXH_VLAN;\n\tif (flow_key & FLOW_KEY_IPSA)\n\t\tethflow |= RXH_IP_SRC;\n\tif (flow_key & FLOW_KEY_IPDA)\n\t\tethflow |= RXH_IP_DST;\n\tif (flow_key & FLOW_KEY_PROTO)\n\t\tethflow |= RXH_L3_PROTO;\n\tif (flow_key & (FLOW_KEY_L4_BYTE12 << FLOW_KEY_L4_0_SHIFT))\n\t\tethflow |= RXH_L4_B_0_1;\n\tif (flow_key & (FLOW_KEY_L4_BYTE12 << FLOW_KEY_L4_1_SHIFT))\n\t\tethflow |= RXH_L4_B_2_3;\n\n\treturn ethflow;\n\n}\n\nstatic int niu_ethflow_to_flowkey(u64 ethflow, u64 *flow_key)\n{\n\tu64 key = 0;\n\n\tif (ethflow & RXH_L2DA)\n\t\tkey |= FLOW_KEY_L2DA;\n\tif (ethflow & RXH_VLAN)\n\t\tkey |= FLOW_KEY_VLAN;\n\tif (ethflow & RXH_IP_SRC)\n\t\tkey |= FLOW_KEY_IPSA;\n\tif (ethflow & RXH_IP_DST)\n\t\tkey |= FLOW_KEY_IPDA;\n\tif (ethflow & RXH_L3_PROTO)\n\t\tkey |= FLOW_KEY_PROTO;\n\tif (ethflow & RXH_L4_B_0_1)\n\t\tkey |= (FLOW_KEY_L4_BYTE12 << FLOW_KEY_L4_0_SHIFT);\n\tif (ethflow & RXH_L4_B_2_3)\n\t\tkey |= (FLOW_KEY_L4_BYTE12 << FLOW_KEY_L4_1_SHIFT);\n\n\t*flow_key = key;\n\n\treturn 1;\n\n}\n\nstatic int niu_get_hash_opts(struct niu *np, struct ethtool_rxnfc *nfc)\n{\n\tu64 class;\n\n\tnfc->data = 0;\n\n\tif (!niu_ethflow_to_class(nfc->flow_type, &class))\n\t\treturn -EINVAL;\n\n\tif (np->parent->tcam_key[class - CLASS_CODE_USER_PROG1] &\n\t    TCAM_KEY_DISC)\n\t\tnfc->data = RXH_DISCARD;\n\telse\n\t\tnfc->data = niu_flowkey_to_ethflow(np->parent->flow_key[class -\n\t\t\t\t\t\t      CLASS_CODE_USER_PROG1]);\n\treturn 0;\n}\n\nstatic void niu_get_ip4fs_from_tcam_key(struct niu_tcam_entry *tp,\n\t\t\t\t\tstruct ethtool_rx_flow_spec *fsp)\n{\n\tu32 tmp;\n\tu16 prt;\n\n\ttmp = (tp->key[3] & TCAM_V4KEY3_SADDR) >> TCAM_V4KEY3_SADDR_SHIFT;\n\tfsp->h_u.tcp_ip4_spec.ip4src = cpu_to_be32(tmp);\n\n\ttmp = (tp->key[3] & TCAM_V4KEY3_DADDR) >> TCAM_V4KEY3_DADDR_SHIFT;\n\tfsp->h_u.tcp_ip4_spec.ip4dst = cpu_to_be32(tmp);\n\n\ttmp = (tp->key_mask[3] & TCAM_V4KEY3_SADDR) >> TCAM_V4KEY3_SADDR_SHIFT;\n\tfsp->m_u.tcp_ip4_spec.ip4src = cpu_to_be32(tmp);\n\n\ttmp = (tp->key_mask[3] & TCAM_V4KEY3_DADDR) >> TCAM_V4KEY3_DADDR_SHIFT;\n\tfsp->m_u.tcp_ip4_spec.ip4dst = cpu_to_be32(tmp);\n\n\tfsp->h_u.tcp_ip4_spec.tos = (tp->key[2] & TCAM_V4KEY2_TOS) >>\n\t\tTCAM_V4KEY2_TOS_SHIFT;\n\tfsp->m_u.tcp_ip4_spec.tos = (tp->key_mask[2] & TCAM_V4KEY2_TOS) >>\n\t\tTCAM_V4KEY2_TOS_SHIFT;\n\n\tswitch (fsp->flow_type) {\n\tcase TCP_V4_FLOW:\n\tcase UDP_V4_FLOW:\n\tcase SCTP_V4_FLOW:\n\t\tprt = ((tp->key[2] & TCAM_V4KEY2_PORT_SPI) >>\n\t\t\tTCAM_V4KEY2_PORT_SPI_SHIFT) >> 16;\n\t\tfsp->h_u.tcp_ip4_spec.psrc = cpu_to_be16(prt);\n\n\t\tprt = ((tp->key[2] & TCAM_V4KEY2_PORT_SPI) >>\n\t\t\tTCAM_V4KEY2_PORT_SPI_SHIFT) & 0xffff;\n\t\tfsp->h_u.tcp_ip4_spec.pdst = cpu_to_be16(prt);\n\n\t\tprt = ((tp->key_mask[2] & TCAM_V4KEY2_PORT_SPI) >>\n\t\t\tTCAM_V4KEY2_PORT_SPI_SHIFT) >> 16;\n\t\tfsp->m_u.tcp_ip4_spec.psrc = cpu_to_be16(prt);\n\n\t\tprt = ((tp->key_mask[2] & TCAM_V4KEY2_PORT_SPI) >>\n\t\t\t TCAM_V4KEY2_PORT_SPI_SHIFT) & 0xffff;\n\t\tfsp->m_u.tcp_ip4_spec.pdst = cpu_to_be16(prt);\n\t\tbreak;\n\tcase AH_V4_FLOW:\n\tcase ESP_V4_FLOW:\n\t\ttmp = (tp->key[2] & TCAM_V4KEY2_PORT_SPI) >>\n\t\t\tTCAM_V4KEY2_PORT_SPI_SHIFT;\n\t\tfsp->h_u.ah_ip4_spec.spi = cpu_to_be32(tmp);\n\n\t\ttmp = (tp->key_mask[2] & TCAM_V4KEY2_PORT_SPI) >>\n\t\t\tTCAM_V4KEY2_PORT_SPI_SHIFT;\n\t\tfsp->m_u.ah_ip4_spec.spi = cpu_to_be32(tmp);\n\t\tbreak;\n\tcase IP_USER_FLOW:\n\t\ttmp = (tp->key[2] & TCAM_V4KEY2_PORT_SPI) >>\n\t\t\tTCAM_V4KEY2_PORT_SPI_SHIFT;\n\t\tfsp->h_u.usr_ip4_spec.l4_4_bytes = cpu_to_be32(tmp);\n\n\t\ttmp = (tp->key_mask[2] & TCAM_V4KEY2_PORT_SPI) >>\n\t\t\tTCAM_V4KEY2_PORT_SPI_SHIFT;\n\t\tfsp->m_u.usr_ip4_spec.l4_4_bytes = cpu_to_be32(tmp);\n\n\t\tfsp->h_u.usr_ip4_spec.proto =\n\t\t\t(tp->key[2] & TCAM_V4KEY2_PROTO) >>\n\t\t\tTCAM_V4KEY2_PROTO_SHIFT;\n\t\tfsp->m_u.usr_ip4_spec.proto =\n\t\t\t(tp->key_mask[2] & TCAM_V4KEY2_PROTO) >>\n\t\t\tTCAM_V4KEY2_PROTO_SHIFT;\n\n\t\tfsp->h_u.usr_ip4_spec.ip_ver = ETH_RX_NFC_IP4;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic int niu_get_ethtool_tcam_entry(struct niu *np,\n\t\t\t\t      struct ethtool_rxnfc *nfc)\n{\n\tstruct niu_parent *parent = np->parent;\n\tstruct niu_tcam_entry *tp;\n\tstruct ethtool_rx_flow_spec *fsp = &nfc->fs;\n\tu16 idx;\n\tu64 class;\n\tint ret = 0;\n\n\tidx = tcam_get_index(np, (u16)nfc->fs.location);\n\n\ttp = &parent->tcam[idx];\n\tif (!tp->valid) {\n\t\tnetdev_info(np->dev, \"niu%d: entry [%d] invalid for idx[%d]\\n\",\n\t\t\t    parent->index, (u16)nfc->fs.location, idx);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tclass = (tp->key[0] & TCAM_V4KEY0_CLASS_CODE) >>\n\t\tTCAM_V4KEY0_CLASS_CODE_SHIFT;\n\tret = niu_class_to_ethflow(class, &fsp->flow_type);\n\tif (ret < 0) {\n\t\tnetdev_info(np->dev, \"niu%d: niu_class_to_ethflow failed\\n\",\n\t\t\t    parent->index);\n\t\tgoto out;\n\t}\n\n\tif (fsp->flow_type == AH_V4_FLOW || fsp->flow_type == AH_V6_FLOW) {\n\t\tu32 proto = (tp->key[2] & TCAM_V4KEY2_PROTO) >>\n\t\t\tTCAM_V4KEY2_PROTO_SHIFT;\n\t\tif (proto == IPPROTO_ESP) {\n\t\t\tif (fsp->flow_type == AH_V4_FLOW)\n\t\t\t\tfsp->flow_type = ESP_V4_FLOW;\n\t\t\telse\n\t\t\t\tfsp->flow_type = ESP_V6_FLOW;\n\t\t}\n\t}\n\n\tswitch (fsp->flow_type) {\n\tcase TCP_V4_FLOW:\n\tcase UDP_V4_FLOW:\n\tcase SCTP_V4_FLOW:\n\tcase AH_V4_FLOW:\n\tcase ESP_V4_FLOW:\n\t\tniu_get_ip4fs_from_tcam_key(tp, fsp);\n\t\tbreak;\n\tcase TCP_V6_FLOW:\n\tcase UDP_V6_FLOW:\n\tcase SCTP_V6_FLOW:\n\tcase AH_V6_FLOW:\n\tcase ESP_V6_FLOW:\n\t\t \n\t\tret = -EINVAL;\n\t\tbreak;\n\tcase IP_USER_FLOW:\n\t\tniu_get_ip4fs_from_tcam_key(tp, fsp);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (tp->assoc_data & TCAM_ASSOCDATA_DISC)\n\t\tfsp->ring_cookie = RX_CLS_FLOW_DISC;\n\telse\n\t\tfsp->ring_cookie = (tp->assoc_data & TCAM_ASSOCDATA_OFFSET) >>\n\t\t\tTCAM_ASSOCDATA_OFFSET_SHIFT;\n\n\t \n\tnfc->data = tcam_get_size(np);\nout:\n\treturn ret;\n}\n\nstatic int niu_get_ethtool_tcam_all(struct niu *np,\n\t\t\t\t    struct ethtool_rxnfc *nfc,\n\t\t\t\t    u32 *rule_locs)\n{\n\tstruct niu_parent *parent = np->parent;\n\tstruct niu_tcam_entry *tp;\n\tint i, idx, cnt;\n\tunsigned long flags;\n\tint ret = 0;\n\n\t \n\tnfc->data = tcam_get_size(np);\n\n\tniu_lock_parent(np, flags);\n\tfor (cnt = 0, i = 0; i < nfc->data; i++) {\n\t\tidx = tcam_get_index(np, i);\n\t\ttp = &parent->tcam[idx];\n\t\tif (!tp->valid)\n\t\t\tcontinue;\n\t\tif (cnt == nfc->rule_cnt) {\n\t\t\tret = -EMSGSIZE;\n\t\t\tbreak;\n\t\t}\n\t\trule_locs[cnt] = i;\n\t\tcnt++;\n\t}\n\tniu_unlock_parent(np, flags);\n\n\tnfc->rule_cnt = cnt;\n\n\treturn ret;\n}\n\nstatic int niu_get_nfc(struct net_device *dev, struct ethtool_rxnfc *cmd,\n\t\t       u32 *rule_locs)\n{\n\tstruct niu *np = netdev_priv(dev);\n\tint ret = 0;\n\n\tswitch (cmd->cmd) {\n\tcase ETHTOOL_GRXFH:\n\t\tret = niu_get_hash_opts(np, cmd);\n\t\tbreak;\n\tcase ETHTOOL_GRXRINGS:\n\t\tcmd->data = np->num_rx_rings;\n\t\tbreak;\n\tcase ETHTOOL_GRXCLSRLCNT:\n\t\tcmd->rule_cnt = tcam_get_valid_entry_cnt(np);\n\t\tbreak;\n\tcase ETHTOOL_GRXCLSRULE:\n\t\tret = niu_get_ethtool_tcam_entry(np, cmd);\n\t\tbreak;\n\tcase ETHTOOL_GRXCLSRLALL:\n\t\tret = niu_get_ethtool_tcam_all(np, cmd, rule_locs);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int niu_set_hash_opts(struct niu *np, struct ethtool_rxnfc *nfc)\n{\n\tu64 class;\n\tu64 flow_key = 0;\n\tunsigned long flags;\n\n\tif (!niu_ethflow_to_class(nfc->flow_type, &class))\n\t\treturn -EINVAL;\n\n\tif (class < CLASS_CODE_USER_PROG1 ||\n\t    class > CLASS_CODE_SCTP_IPV6)\n\t\treturn -EINVAL;\n\n\tif (nfc->data & RXH_DISCARD) {\n\t\tniu_lock_parent(np, flags);\n\t\tflow_key = np->parent->tcam_key[class -\n\t\t\t\t\t       CLASS_CODE_USER_PROG1];\n\t\tflow_key |= TCAM_KEY_DISC;\n\t\tnw64(TCAM_KEY(class - CLASS_CODE_USER_PROG1), flow_key);\n\t\tnp->parent->tcam_key[class - CLASS_CODE_USER_PROG1] = flow_key;\n\t\tniu_unlock_parent(np, flags);\n\t\treturn 0;\n\t} else {\n\t\t \n\t\tif (np->parent->tcam_key[class - CLASS_CODE_USER_PROG1] &\n\t\t    TCAM_KEY_DISC) {\n\t\t\tniu_lock_parent(np, flags);\n\t\t\tflow_key = np->parent->tcam_key[class -\n\t\t\t\t\t       CLASS_CODE_USER_PROG1];\n\t\t\tflow_key &= ~TCAM_KEY_DISC;\n\t\t\tnw64(TCAM_KEY(class - CLASS_CODE_USER_PROG1),\n\t\t\t     flow_key);\n\t\t\tnp->parent->tcam_key[class - CLASS_CODE_USER_PROG1] =\n\t\t\t\tflow_key;\n\t\t\tniu_unlock_parent(np, flags);\n\t\t}\n\t}\n\n\tif (!niu_ethflow_to_flowkey(nfc->data, &flow_key))\n\t\treturn -EINVAL;\n\n\tniu_lock_parent(np, flags);\n\tnw64(FLOW_KEY(class - CLASS_CODE_USER_PROG1), flow_key);\n\tnp->parent->flow_key[class - CLASS_CODE_USER_PROG1] = flow_key;\n\tniu_unlock_parent(np, flags);\n\n\treturn 0;\n}\n\nstatic void niu_get_tcamkey_from_ip4fs(struct ethtool_rx_flow_spec *fsp,\n\t\t\t\t       struct niu_tcam_entry *tp,\n\t\t\t\t       int l2_rdc_tab, u64 class)\n{\n\tu8 pid = 0;\n\tu32 sip, dip, sipm, dipm, spi, spim;\n\tu16 sport, dport, spm, dpm;\n\n\tsip = be32_to_cpu(fsp->h_u.tcp_ip4_spec.ip4src);\n\tsipm = be32_to_cpu(fsp->m_u.tcp_ip4_spec.ip4src);\n\tdip = be32_to_cpu(fsp->h_u.tcp_ip4_spec.ip4dst);\n\tdipm = be32_to_cpu(fsp->m_u.tcp_ip4_spec.ip4dst);\n\n\ttp->key[0] = class << TCAM_V4KEY0_CLASS_CODE_SHIFT;\n\ttp->key_mask[0] = TCAM_V4KEY0_CLASS_CODE;\n\ttp->key[1] = (u64)l2_rdc_tab << TCAM_V4KEY1_L2RDCNUM_SHIFT;\n\ttp->key_mask[1] = TCAM_V4KEY1_L2RDCNUM;\n\n\ttp->key[3] = (u64)sip << TCAM_V4KEY3_SADDR_SHIFT;\n\ttp->key[3] |= dip;\n\n\ttp->key_mask[3] = (u64)sipm << TCAM_V4KEY3_SADDR_SHIFT;\n\ttp->key_mask[3] |= dipm;\n\n\ttp->key[2] |= ((u64)fsp->h_u.tcp_ip4_spec.tos <<\n\t\t       TCAM_V4KEY2_TOS_SHIFT);\n\ttp->key_mask[2] |= ((u64)fsp->m_u.tcp_ip4_spec.tos <<\n\t\t\t    TCAM_V4KEY2_TOS_SHIFT);\n\tswitch (fsp->flow_type) {\n\tcase TCP_V4_FLOW:\n\tcase UDP_V4_FLOW:\n\tcase SCTP_V4_FLOW:\n\t\tsport = be16_to_cpu(fsp->h_u.tcp_ip4_spec.psrc);\n\t\tspm = be16_to_cpu(fsp->m_u.tcp_ip4_spec.psrc);\n\t\tdport = be16_to_cpu(fsp->h_u.tcp_ip4_spec.pdst);\n\t\tdpm = be16_to_cpu(fsp->m_u.tcp_ip4_spec.pdst);\n\n\t\ttp->key[2] |= (((u64)sport << 16) | dport);\n\t\ttp->key_mask[2] |= (((u64)spm << 16) | dpm);\n\t\tniu_ethflow_to_l3proto(fsp->flow_type, &pid);\n\t\tbreak;\n\tcase AH_V4_FLOW:\n\tcase ESP_V4_FLOW:\n\t\tspi = be32_to_cpu(fsp->h_u.ah_ip4_spec.spi);\n\t\tspim = be32_to_cpu(fsp->m_u.ah_ip4_spec.spi);\n\n\t\ttp->key[2] |= spi;\n\t\ttp->key_mask[2] |= spim;\n\t\tniu_ethflow_to_l3proto(fsp->flow_type, &pid);\n\t\tbreak;\n\tcase IP_USER_FLOW:\n\t\tspi = be32_to_cpu(fsp->h_u.usr_ip4_spec.l4_4_bytes);\n\t\tspim = be32_to_cpu(fsp->m_u.usr_ip4_spec.l4_4_bytes);\n\n\t\ttp->key[2] |= spi;\n\t\ttp->key_mask[2] |= spim;\n\t\tpid = fsp->h_u.usr_ip4_spec.proto;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\ttp->key[2] |= ((u64)pid << TCAM_V4KEY2_PROTO_SHIFT);\n\tif (pid) {\n\t\ttp->key_mask[2] |= TCAM_V4KEY2_PROTO;\n\t}\n}\n\nstatic int niu_add_ethtool_tcam_entry(struct niu *np,\n\t\t\t\t      struct ethtool_rxnfc *nfc)\n{\n\tstruct niu_parent *parent = np->parent;\n\tstruct niu_tcam_entry *tp;\n\tstruct ethtool_rx_flow_spec *fsp = &nfc->fs;\n\tstruct niu_rdc_tables *rdc_table = &parent->rdc_group_cfg[np->port];\n\tint l2_rdc_table = rdc_table->first_table_num;\n\tu16 idx;\n\tu64 class;\n\tunsigned long flags;\n\tint err, ret;\n\n\tret = 0;\n\n\tidx = nfc->fs.location;\n\tif (idx >= tcam_get_size(np))\n\t\treturn -EINVAL;\n\n\tif (fsp->flow_type == IP_USER_FLOW) {\n\t\tint i;\n\t\tint add_usr_cls = 0;\n\t\tstruct ethtool_usrip4_spec *uspec = &fsp->h_u.usr_ip4_spec;\n\t\tstruct ethtool_usrip4_spec *umask = &fsp->m_u.usr_ip4_spec;\n\n\t\tif (uspec->ip_ver != ETH_RX_NFC_IP4)\n\t\t\treturn -EINVAL;\n\n\t\tniu_lock_parent(np, flags);\n\n\t\tfor (i = 0; i < NIU_L3_PROG_CLS; i++) {\n\t\t\tif (parent->l3_cls[i]) {\n\t\t\t\tif (uspec->proto == parent->l3_cls_pid[i]) {\n\t\t\t\t\tclass = parent->l3_cls[i];\n\t\t\t\t\tparent->l3_cls_refcnt[i]++;\n\t\t\t\t\tadd_usr_cls = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tswitch (i) {\n\t\t\t\tcase 0:\n\t\t\t\t\tclass = CLASS_CODE_USER_PROG1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tclass = CLASS_CODE_USER_PROG2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tclass = CLASS_CODE_USER_PROG3;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\tclass = CLASS_CODE_USER_PROG4;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tclass = CLASS_CODE_UNRECOG;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tret = tcam_user_ip_class_set(np, class, 0,\n\t\t\t\t\t\t\t     uspec->proto,\n\t\t\t\t\t\t\t     uspec->tos,\n\t\t\t\t\t\t\t     umask->tos);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto out;\n\n\t\t\t\tret = tcam_user_ip_class_enable(np, class, 1);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto out;\n\t\t\t\tparent->l3_cls[i] = class;\n\t\t\t\tparent->l3_cls_pid[i] = uspec->proto;\n\t\t\t\tparent->l3_cls_refcnt[i]++;\n\t\t\t\tadd_usr_cls = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!add_usr_cls) {\n\t\t\tnetdev_info(np->dev, \"niu%d: %s(): Could not find/insert class for pid %d\\n\",\n\t\t\t\t    parent->index, __func__, uspec->proto);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tniu_unlock_parent(np, flags);\n\t} else {\n\t\tif (!niu_ethflow_to_class(fsp->flow_type, &class)) {\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tniu_lock_parent(np, flags);\n\n\tidx = tcam_get_index(np, idx);\n\ttp = &parent->tcam[idx];\n\n\tmemset(tp, 0, sizeof(*tp));\n\n\t \n\tswitch (fsp->flow_type) {\n\tcase TCP_V4_FLOW:\n\tcase UDP_V4_FLOW:\n\tcase SCTP_V4_FLOW:\n\tcase AH_V4_FLOW:\n\tcase ESP_V4_FLOW:\n\t\tniu_get_tcamkey_from_ip4fs(fsp, tp, l2_rdc_table, class);\n\t\tbreak;\n\tcase TCP_V6_FLOW:\n\tcase UDP_V6_FLOW:\n\tcase SCTP_V6_FLOW:\n\tcase AH_V6_FLOW:\n\tcase ESP_V6_FLOW:\n\t\t \n\t\tnetdev_info(np->dev, \"niu%d: In %s(): flow %d for IPv6 not implemented\\n\",\n\t\t\t    parent->index, __func__, fsp->flow_type);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\tcase IP_USER_FLOW:\n\t\tniu_get_tcamkey_from_ip4fs(fsp, tp, l2_rdc_table, class);\n\t\tbreak;\n\tdefault:\n\t\tnetdev_info(np->dev, \"niu%d: In %s(): Unknown flow type %d\\n\",\n\t\t\t    parent->index, __func__, fsp->flow_type);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t \n\tif (fsp->ring_cookie == RX_CLS_FLOW_DISC) {\n\t\ttp->assoc_data = TCAM_ASSOCDATA_DISC;\n\t} else {\n\t\tif (fsp->ring_cookie >= np->num_rx_rings) {\n\t\t\tnetdev_info(np->dev, \"niu%d: In %s(): Invalid RX ring %lld\\n\",\n\t\t\t\t    parent->index, __func__,\n\t\t\t\t    (long long)fsp->ring_cookie);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\ttp->assoc_data = (TCAM_ASSOCDATA_TRES_USE_OFFSET |\n\t\t\t\t  (fsp->ring_cookie <<\n\t\t\t\t   TCAM_ASSOCDATA_OFFSET_SHIFT));\n\t}\n\n\terr = tcam_write(np, idx, tp->key, tp->key_mask);\n\tif (err) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\terr = tcam_assoc_write(np, idx, tp->assoc_data);\n\tif (err) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t \n\ttp->valid = 1;\n\tnp->clas.tcam_valid_entries++;\nout:\n\tniu_unlock_parent(np, flags);\n\n\treturn ret;\n}\n\nstatic int niu_del_ethtool_tcam_entry(struct niu *np, u32 loc)\n{\n\tstruct niu_parent *parent = np->parent;\n\tstruct niu_tcam_entry *tp;\n\tu16 idx;\n\tunsigned long flags;\n\tu64 class;\n\tint ret = 0;\n\n\tif (loc >= tcam_get_size(np))\n\t\treturn -EINVAL;\n\n\tniu_lock_parent(np, flags);\n\n\tidx = tcam_get_index(np, loc);\n\ttp = &parent->tcam[idx];\n\n\t \n\tclass = (tp->key[0] & TCAM_V4KEY0_CLASS_CODE) >>\n\t\tTCAM_V4KEY0_CLASS_CODE_SHIFT;\n\n\tif (class >= CLASS_CODE_USER_PROG1 && class <= CLASS_CODE_USER_PROG4) {\n\t\tint i;\n\t\tfor (i = 0; i < NIU_L3_PROG_CLS; i++) {\n\t\t\tif (parent->l3_cls[i] == class) {\n\t\t\t\tparent->l3_cls_refcnt[i]--;\n\t\t\t\tif (!parent->l3_cls_refcnt[i]) {\n\t\t\t\t\t \n\t\t\t\t\tret = tcam_user_ip_class_enable(np,\n\t\t\t\t\t\t\t\t\tclass,\n\t\t\t\t\t\t\t\t\t0);\n\t\t\t\t\tif (ret)\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\tparent->l3_cls[i] = 0;\n\t\t\t\t\tparent->l3_cls_pid[i] = 0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (i == NIU_L3_PROG_CLS) {\n\t\t\tnetdev_info(np->dev, \"niu%d: In %s(): Usr class 0x%llx not found\\n\",\n\t\t\t\t    parent->index, __func__,\n\t\t\t\t    (unsigned long long)class);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = tcam_flush(np, idx);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\ttp->valid = 0;\n\tnp->clas.tcam_valid_entries--;\nout:\n\tniu_unlock_parent(np, flags);\n\n\treturn ret;\n}\n\nstatic int niu_set_nfc(struct net_device *dev, struct ethtool_rxnfc *cmd)\n{\n\tstruct niu *np = netdev_priv(dev);\n\tint ret = 0;\n\n\tswitch (cmd->cmd) {\n\tcase ETHTOOL_SRXFH:\n\t\tret = niu_set_hash_opts(np, cmd);\n\t\tbreak;\n\tcase ETHTOOL_SRXCLSRLINS:\n\t\tret = niu_add_ethtool_tcam_entry(np, cmd);\n\t\tbreak;\n\tcase ETHTOOL_SRXCLSRLDEL:\n\t\tret = niu_del_ethtool_tcam_entry(np, cmd->fs.location);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic const struct {\n\tconst char string[ETH_GSTRING_LEN];\n} niu_xmac_stat_keys[] = {\n\t{ \"tx_frames\" },\n\t{ \"tx_bytes\" },\n\t{ \"tx_fifo_errors\" },\n\t{ \"tx_overflow_errors\" },\n\t{ \"tx_max_pkt_size_errors\" },\n\t{ \"tx_underflow_errors\" },\n\t{ \"rx_local_faults\" },\n\t{ \"rx_remote_faults\" },\n\t{ \"rx_link_faults\" },\n\t{ \"rx_align_errors\" },\n\t{ \"rx_frags\" },\n\t{ \"rx_mcasts\" },\n\t{ \"rx_bcasts\" },\n\t{ \"rx_hist_cnt1\" },\n\t{ \"rx_hist_cnt2\" },\n\t{ \"rx_hist_cnt3\" },\n\t{ \"rx_hist_cnt4\" },\n\t{ \"rx_hist_cnt5\" },\n\t{ \"rx_hist_cnt6\" },\n\t{ \"rx_hist_cnt7\" },\n\t{ \"rx_octets\" },\n\t{ \"rx_code_violations\" },\n\t{ \"rx_len_errors\" },\n\t{ \"rx_crc_errors\" },\n\t{ \"rx_underflows\" },\n\t{ \"rx_overflows\" },\n\t{ \"pause_off_state\" },\n\t{ \"pause_on_state\" },\n\t{ \"pause_received\" },\n};\n\n#define NUM_XMAC_STAT_KEYS\tARRAY_SIZE(niu_xmac_stat_keys)\n\nstatic const struct {\n\tconst char string[ETH_GSTRING_LEN];\n} niu_bmac_stat_keys[] = {\n\t{ \"tx_underflow_errors\" },\n\t{ \"tx_max_pkt_size_errors\" },\n\t{ \"tx_bytes\" },\n\t{ \"tx_frames\" },\n\t{ \"rx_overflows\" },\n\t{ \"rx_frames\" },\n\t{ \"rx_align_errors\" },\n\t{ \"rx_crc_errors\" },\n\t{ \"rx_len_errors\" },\n\t{ \"pause_off_state\" },\n\t{ \"pause_on_state\" },\n\t{ \"pause_received\" },\n};\n\n#define NUM_BMAC_STAT_KEYS\tARRAY_SIZE(niu_bmac_stat_keys)\n\nstatic const struct {\n\tconst char string[ETH_GSTRING_LEN];\n} niu_rxchan_stat_keys[] = {\n\t{ \"rx_channel\" },\n\t{ \"rx_packets\" },\n\t{ \"rx_bytes\" },\n\t{ \"rx_dropped\" },\n\t{ \"rx_errors\" },\n};\n\n#define NUM_RXCHAN_STAT_KEYS\tARRAY_SIZE(niu_rxchan_stat_keys)\n\nstatic const struct {\n\tconst char string[ETH_GSTRING_LEN];\n} niu_txchan_stat_keys[] = {\n\t{ \"tx_channel\" },\n\t{ \"tx_packets\" },\n\t{ \"tx_bytes\" },\n\t{ \"tx_errors\" },\n};\n\n#define NUM_TXCHAN_STAT_KEYS\tARRAY_SIZE(niu_txchan_stat_keys)\n\nstatic void niu_get_strings(struct net_device *dev, u32 stringset, u8 *data)\n{\n\tstruct niu *np = netdev_priv(dev);\n\tint i;\n\n\tif (stringset != ETH_SS_STATS)\n\t\treturn;\n\n\tif (np->flags & NIU_FLAGS_XMAC) {\n\t\tmemcpy(data, niu_xmac_stat_keys,\n\t\t       sizeof(niu_xmac_stat_keys));\n\t\tdata += sizeof(niu_xmac_stat_keys);\n\t} else {\n\t\tmemcpy(data, niu_bmac_stat_keys,\n\t\t       sizeof(niu_bmac_stat_keys));\n\t\tdata += sizeof(niu_bmac_stat_keys);\n\t}\n\tfor (i = 0; i < np->num_rx_rings; i++) {\n\t\tmemcpy(data, niu_rxchan_stat_keys,\n\t\t       sizeof(niu_rxchan_stat_keys));\n\t\tdata += sizeof(niu_rxchan_stat_keys);\n\t}\n\tfor (i = 0; i < np->num_tx_rings; i++) {\n\t\tmemcpy(data, niu_txchan_stat_keys,\n\t\t       sizeof(niu_txchan_stat_keys));\n\t\tdata += sizeof(niu_txchan_stat_keys);\n\t}\n}\n\nstatic int niu_get_sset_count(struct net_device *dev, int stringset)\n{\n\tstruct niu *np = netdev_priv(dev);\n\n\tif (stringset != ETH_SS_STATS)\n\t\treturn -EINVAL;\n\n\treturn (np->flags & NIU_FLAGS_XMAC ?\n\t\t NUM_XMAC_STAT_KEYS :\n\t\t NUM_BMAC_STAT_KEYS) +\n\t\t(np->num_rx_rings * NUM_RXCHAN_STAT_KEYS) +\n\t\t(np->num_tx_rings * NUM_TXCHAN_STAT_KEYS);\n}\n\nstatic void niu_get_ethtool_stats(struct net_device *dev,\n\t\t\t\t  struct ethtool_stats *stats, u64 *data)\n{\n\tstruct niu *np = netdev_priv(dev);\n\tint i;\n\n\tniu_sync_mac_stats(np);\n\tif (np->flags & NIU_FLAGS_XMAC) {\n\t\tmemcpy(data, &np->mac_stats.xmac,\n\t\t       sizeof(struct niu_xmac_stats));\n\t\tdata += (sizeof(struct niu_xmac_stats) / sizeof(u64));\n\t} else {\n\t\tmemcpy(data, &np->mac_stats.bmac,\n\t\t       sizeof(struct niu_bmac_stats));\n\t\tdata += (sizeof(struct niu_bmac_stats) / sizeof(u64));\n\t}\n\tfor (i = 0; i < np->num_rx_rings; i++) {\n\t\tstruct rx_ring_info *rp = &np->rx_rings[i];\n\n\t\tniu_sync_rx_discard_stats(np, rp, 0);\n\n\t\tdata[0] = rp->rx_channel;\n\t\tdata[1] = rp->rx_packets;\n\t\tdata[2] = rp->rx_bytes;\n\t\tdata[3] = rp->rx_dropped;\n\t\tdata[4] = rp->rx_errors;\n\t\tdata += 5;\n\t}\n\tfor (i = 0; i < np->num_tx_rings; i++) {\n\t\tstruct tx_ring_info *rp = &np->tx_rings[i];\n\n\t\tdata[0] = rp->tx_channel;\n\t\tdata[1] = rp->tx_packets;\n\t\tdata[2] = rp->tx_bytes;\n\t\tdata[3] = rp->tx_errors;\n\t\tdata += 4;\n\t}\n}\n\nstatic u64 niu_led_state_save(struct niu *np)\n{\n\tif (np->flags & NIU_FLAGS_XMAC)\n\t\treturn nr64_mac(XMAC_CONFIG);\n\telse\n\t\treturn nr64_mac(BMAC_XIF_CONFIG);\n}\n\nstatic void niu_led_state_restore(struct niu *np, u64 val)\n{\n\tif (np->flags & NIU_FLAGS_XMAC)\n\t\tnw64_mac(XMAC_CONFIG, val);\n\telse\n\t\tnw64_mac(BMAC_XIF_CONFIG, val);\n}\n\nstatic void niu_force_led(struct niu *np, int on)\n{\n\tu64 val, reg, bit;\n\n\tif (np->flags & NIU_FLAGS_XMAC) {\n\t\treg = XMAC_CONFIG;\n\t\tbit = XMAC_CONFIG_FORCE_LED_ON;\n\t} else {\n\t\treg = BMAC_XIF_CONFIG;\n\t\tbit = BMAC_XIF_CONFIG_LINK_LED;\n\t}\n\n\tval = nr64_mac(reg);\n\tif (on)\n\t\tval |= bit;\n\telse\n\t\tval &= ~bit;\n\tnw64_mac(reg, val);\n}\n\nstatic int niu_set_phys_id(struct net_device *dev,\n\t\t\t   enum ethtool_phys_id_state state)\n\n{\n\tstruct niu *np = netdev_priv(dev);\n\n\tif (!netif_running(dev))\n\t\treturn -EAGAIN;\n\n\tswitch (state) {\n\tcase ETHTOOL_ID_ACTIVE:\n\t\tnp->orig_led_state = niu_led_state_save(np);\n\t\treturn 1;\t \n\n\tcase ETHTOOL_ID_ON:\n\t\tniu_force_led(np, 1);\n\t\tbreak;\n\n\tcase ETHTOOL_ID_OFF:\n\t\tniu_force_led(np, 0);\n\t\tbreak;\n\n\tcase ETHTOOL_ID_INACTIVE:\n\t\tniu_led_state_restore(np, np->orig_led_state);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct ethtool_ops niu_ethtool_ops = {\n\t.get_drvinfo\t\t= niu_get_drvinfo,\n\t.get_link\t\t= ethtool_op_get_link,\n\t.get_msglevel\t\t= niu_get_msglevel,\n\t.set_msglevel\t\t= niu_set_msglevel,\n\t.nway_reset\t\t= niu_nway_reset,\n\t.get_eeprom_len\t\t= niu_get_eeprom_len,\n\t.get_eeprom\t\t= niu_get_eeprom,\n\t.get_strings\t\t= niu_get_strings,\n\t.get_sset_count\t\t= niu_get_sset_count,\n\t.get_ethtool_stats\t= niu_get_ethtool_stats,\n\t.set_phys_id\t\t= niu_set_phys_id,\n\t.get_rxnfc\t\t= niu_get_nfc,\n\t.set_rxnfc\t\t= niu_set_nfc,\n\t.get_link_ksettings\t= niu_get_link_ksettings,\n\t.set_link_ksettings\t= niu_set_link_ksettings,\n};\n\nstatic int niu_ldg_assign_ldn(struct niu *np, struct niu_parent *parent,\n\t\t\t      int ldg, int ldn)\n{\n\tif (ldg < NIU_LDG_MIN || ldg > NIU_LDG_MAX)\n\t\treturn -EINVAL;\n\tif (ldn < 0 || ldn > LDN_MAX)\n\t\treturn -EINVAL;\n\n\tparent->ldg_map[ldn] = ldg;\n\n\tif (np->parent->plat_type == PLAT_TYPE_NIU) {\n\t\t \n\t\tif (nr64(LDG_NUM(ldn)) != ldg) {\n\t\t\tdev_err(np->device, \"Port %u, mismatched LDG assignment for ldn %d, should be %d is %llu\\n\",\n\t\t\t\tnp->port, ldn, ldg,\n\t\t\t\t(unsigned long long) nr64(LDG_NUM(ldn)));\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else\n\t\tnw64(LDG_NUM(ldn), ldg);\n\n\treturn 0;\n}\n\nstatic int niu_set_ldg_timer_res(struct niu *np, int res)\n{\n\tif (res < 0 || res > LDG_TIMER_RES_VAL)\n\t\treturn -EINVAL;\n\n\n\tnw64(LDG_TIMER_RES, res);\n\n\treturn 0;\n}\n\nstatic int niu_set_ldg_sid(struct niu *np, int ldg, int func, int vector)\n{\n\tif ((ldg < NIU_LDG_MIN || ldg > NIU_LDG_MAX) ||\n\t    (func < 0 || func > 3) ||\n\t    (vector < 0 || vector > 0x1f))\n\t\treturn -EINVAL;\n\n\tnw64(SID(ldg), (func << SID_FUNC_SHIFT) | vector);\n\n\treturn 0;\n}\n\nstatic int niu_pci_eeprom_read(struct niu *np, u32 addr)\n{\n\tu64 frame, frame_base = (ESPC_PIO_STAT_READ_START |\n\t\t\t\t (addr << ESPC_PIO_STAT_ADDR_SHIFT));\n\tint limit;\n\n\tif (addr > (ESPC_PIO_STAT_ADDR >> ESPC_PIO_STAT_ADDR_SHIFT))\n\t\treturn -EINVAL;\n\n\tframe = frame_base;\n\tnw64(ESPC_PIO_STAT, frame);\n\tlimit = 64;\n\tdo {\n\t\tudelay(5);\n\t\tframe = nr64(ESPC_PIO_STAT);\n\t\tif (frame & ESPC_PIO_STAT_READ_END)\n\t\t\tbreak;\n\t} while (limit--);\n\tif (!(frame & ESPC_PIO_STAT_READ_END)) {\n\t\tdev_err(np->device, \"EEPROM read timeout frame[%llx]\\n\",\n\t\t\t(unsigned long long) frame);\n\t\treturn -ENODEV;\n\t}\n\n\tframe = frame_base;\n\tnw64(ESPC_PIO_STAT, frame);\n\tlimit = 64;\n\tdo {\n\t\tudelay(5);\n\t\tframe = nr64(ESPC_PIO_STAT);\n\t\tif (frame & ESPC_PIO_STAT_READ_END)\n\t\t\tbreak;\n\t} while (limit--);\n\tif (!(frame & ESPC_PIO_STAT_READ_END)) {\n\t\tdev_err(np->device, \"EEPROM read timeout frame[%llx]\\n\",\n\t\t\t(unsigned long long) frame);\n\t\treturn -ENODEV;\n\t}\n\n\tframe = nr64(ESPC_PIO_STAT);\n\treturn (frame & ESPC_PIO_STAT_DATA) >> ESPC_PIO_STAT_DATA_SHIFT;\n}\n\nstatic int niu_pci_eeprom_read16(struct niu *np, u32 off)\n{\n\tint err = niu_pci_eeprom_read(np, off);\n\tu16 val;\n\n\tif (err < 0)\n\t\treturn err;\n\tval = (err << 8);\n\terr = niu_pci_eeprom_read(np, off + 1);\n\tif (err < 0)\n\t\treturn err;\n\tval |= (err & 0xff);\n\n\treturn val;\n}\n\nstatic int niu_pci_eeprom_read16_swp(struct niu *np, u32 off)\n{\n\tint err = niu_pci_eeprom_read(np, off);\n\tu16 val;\n\n\tif (err < 0)\n\t\treturn err;\n\n\tval = (err & 0xff);\n\terr = niu_pci_eeprom_read(np, off + 1);\n\tif (err < 0)\n\t\treturn err;\n\n\tval |= (err & 0xff) << 8;\n\n\treturn val;\n}\n\nstatic int niu_pci_vpd_get_propname(struct niu *np, u32 off, char *namebuf,\n\t\t\t\t    int namebuf_len)\n{\n\tint i;\n\n\tfor (i = 0; i < namebuf_len; i++) {\n\t\tint err = niu_pci_eeprom_read(np, off + i);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\t*namebuf++ = err;\n\t\tif (!err)\n\t\t\tbreak;\n\t}\n\tif (i >= namebuf_len)\n\t\treturn -EINVAL;\n\n\treturn i + 1;\n}\n\nstatic void niu_vpd_parse_version(struct niu *np)\n{\n\tstruct niu_vpd *vpd = &np->vpd;\n\tint len = strlen(vpd->version) + 1;\n\tconst char *s = vpd->version;\n\tint i;\n\n\tfor (i = 0; i < len - 5; i++) {\n\t\tif (!strncmp(s + i, \"FCode \", 6))\n\t\t\tbreak;\n\t}\n\tif (i >= len - 5)\n\t\treturn;\n\n\ts += i + 5;\n\tsscanf(s, \"%d.%d\", &vpd->fcode_major, &vpd->fcode_minor);\n\n\tnetif_printk(np, probe, KERN_DEBUG, np->dev,\n\t\t     \"VPD_SCAN: FCODE major(%d) minor(%d)\\n\",\n\t\t     vpd->fcode_major, vpd->fcode_minor);\n\tif (vpd->fcode_major > NIU_VPD_MIN_MAJOR ||\n\t    (vpd->fcode_major == NIU_VPD_MIN_MAJOR &&\n\t     vpd->fcode_minor >= NIU_VPD_MIN_MINOR))\n\t\tnp->flags |= NIU_FLAGS_VPD_VALID;\n}\n\n \nstatic int niu_pci_vpd_scan_props(struct niu *np, u32 start, u32 end)\n{\n\tunsigned int found_mask = 0;\n#define FOUND_MASK_MODEL\t0x00000001\n#define FOUND_MASK_BMODEL\t0x00000002\n#define FOUND_MASK_VERS\t\t0x00000004\n#define FOUND_MASK_MAC\t\t0x00000008\n#define FOUND_MASK_NMAC\t\t0x00000010\n#define FOUND_MASK_PHY\t\t0x00000020\n#define FOUND_MASK_ALL\t\t0x0000003f\n\n\tnetif_printk(np, probe, KERN_DEBUG, np->dev,\n\t\t     \"VPD_SCAN: start[%x] end[%x]\\n\", start, end);\n\twhile (start < end) {\n\t\tint len, err, prop_len;\n\t\tchar namebuf[64];\n\t\tu8 *prop_buf;\n\t\tint max_len;\n\n\t\tif (found_mask == FOUND_MASK_ALL) {\n\t\t\tniu_vpd_parse_version(np);\n\t\t\treturn 1;\n\t\t}\n\n\t\terr = niu_pci_eeprom_read(np, start + 2);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tlen = err;\n\t\tstart += 3;\n\n\t\tprop_len = niu_pci_eeprom_read(np, start + 4);\n\t\tif (prop_len < 0)\n\t\t\treturn prop_len;\n\t\terr = niu_pci_vpd_get_propname(np, start + 5, namebuf, 64);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tprop_buf = NULL;\n\t\tmax_len = 0;\n\t\tif (!strcmp(namebuf, \"model\")) {\n\t\t\tprop_buf = np->vpd.model;\n\t\t\tmax_len = NIU_VPD_MODEL_MAX;\n\t\t\tfound_mask |= FOUND_MASK_MODEL;\n\t\t} else if (!strcmp(namebuf, \"board-model\")) {\n\t\t\tprop_buf = np->vpd.board_model;\n\t\t\tmax_len = NIU_VPD_BD_MODEL_MAX;\n\t\t\tfound_mask |= FOUND_MASK_BMODEL;\n\t\t} else if (!strcmp(namebuf, \"version\")) {\n\t\t\tprop_buf = np->vpd.version;\n\t\t\tmax_len = NIU_VPD_VERSION_MAX;\n\t\t\tfound_mask |= FOUND_MASK_VERS;\n\t\t} else if (!strcmp(namebuf, \"local-mac-address\")) {\n\t\t\tprop_buf = np->vpd.local_mac;\n\t\t\tmax_len = ETH_ALEN;\n\t\t\tfound_mask |= FOUND_MASK_MAC;\n\t\t} else if (!strcmp(namebuf, \"num-mac-addresses\")) {\n\t\t\tprop_buf = &np->vpd.mac_num;\n\t\t\tmax_len = 1;\n\t\t\tfound_mask |= FOUND_MASK_NMAC;\n\t\t} else if (!strcmp(namebuf, \"phy-type\")) {\n\t\t\tprop_buf = np->vpd.phy_type;\n\t\t\tmax_len = NIU_VPD_PHY_TYPE_MAX;\n\t\t\tfound_mask |= FOUND_MASK_PHY;\n\t\t}\n\n\t\tif (max_len && prop_len > max_len) {\n\t\t\tdev_err(np->device, \"Property '%s' length (%d) is too long\\n\", namebuf, prop_len);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (prop_buf) {\n\t\t\tu32 off = start + 5 + err;\n\t\t\tint i;\n\n\t\t\tnetif_printk(np, probe, KERN_DEBUG, np->dev,\n\t\t\t\t     \"VPD_SCAN: Reading in property [%s] len[%d]\\n\",\n\t\t\t\t     namebuf, prop_len);\n\t\t\tfor (i = 0; i < prop_len; i++) {\n\t\t\t\terr =  niu_pci_eeprom_read(np, off + i);\n\t\t\t\tif (err < 0)\n\t\t\t\t\treturn err;\n\t\t\t\t*prop_buf++ = err;\n\t\t\t}\n\t\t}\n\n\t\tstart += len;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int niu_pci_vpd_fetch(struct niu *np, u32 start)\n{\n\tu32 offset;\n\tint err;\n\n\terr = niu_pci_eeprom_read16_swp(np, start + 1);\n\tif (err < 0)\n\t\treturn err;\n\n\toffset = err + 3;\n\n\twhile (start + offset < ESPC_EEPROM_SIZE) {\n\t\tu32 here = start + offset;\n\t\tu32 end;\n\n\t\terr = niu_pci_eeprom_read(np, here);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tif (err != 0x90)\n\t\t\treturn -EINVAL;\n\n\t\terr = niu_pci_eeprom_read16_swp(np, here + 1);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\there = start + offset + 3;\n\t\tend = start + offset + err;\n\n\t\toffset += err;\n\n\t\terr = niu_pci_vpd_scan_props(np, here, end);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\t \n\t\tif (err == 1)\n\t\t\treturn 0;\n\t}\n\treturn 0;\n}\n\n \nstatic u32 niu_pci_vpd_offset(struct niu *np)\n{\n\tu32 start = 0, end = ESPC_EEPROM_SIZE, ret;\n\tint err;\n\n\twhile (start < end) {\n\t\tret = start;\n\n\t\t \n\t\terr = niu_pci_eeprom_read16(np, start +  0);\n\t\tif (err != 0x55aa)\n\t\t\treturn 0;\n\n\t\t \n\t\terr = niu_pci_eeprom_read16(np, start + 23);\n\t\tif (err < 0)\n\t\t\treturn 0;\n\t\tstart += err;\n\n\t\t \n\t\terr = niu_pci_eeprom_read16(np, start +  0);\n\t\tif (err != 0x5043)\n\t\t\treturn 0;\n\t\terr = niu_pci_eeprom_read16(np, start +  2);\n\t\tif (err != 0x4952)\n\t\t\treturn 0;\n\n\t\t \n\t\terr = niu_pci_eeprom_read(np, start + 20);\n\t\tif (err < 0)\n\t\t\treturn 0;\n\t\tif (err != 0x01) {\n\t\t\terr = niu_pci_eeprom_read(np, ret + 2);\n\t\t\tif (err < 0)\n\t\t\t\treturn 0;\n\n\t\t\tstart = ret + (err * 512);\n\t\t\tcontinue;\n\t\t}\n\n\t\terr = niu_pci_eeprom_read16_swp(np, start + 8);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tret += err;\n\n\t\terr = niu_pci_eeprom_read(np, ret + 0);\n\t\tif (err != 0x82)\n\t\t\treturn 0;\n\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int niu_phy_type_prop_decode(struct niu *np, const char *phy_prop)\n{\n\tif (!strcmp(phy_prop, \"mif\")) {\n\t\t \n\t\tnp->flags &= ~(NIU_FLAGS_FIBER |\n\t\t\t       NIU_FLAGS_10G);\n\t\tnp->mac_xcvr = MAC_XCVR_MII;\n\t} else if (!strcmp(phy_prop, \"xgf\")) {\n\t\t \n\t\tnp->flags |= (NIU_FLAGS_10G |\n\t\t\t      NIU_FLAGS_FIBER);\n\t\tnp->mac_xcvr = MAC_XCVR_XPCS;\n\t} else if (!strcmp(phy_prop, \"pcs\")) {\n\t\t \n\t\tnp->flags &= ~NIU_FLAGS_10G;\n\t\tnp->flags |= NIU_FLAGS_FIBER;\n\t\tnp->mac_xcvr = MAC_XCVR_PCS;\n\t} else if (!strcmp(phy_prop, \"xgc\")) {\n\t\t \n\t\tnp->flags |= NIU_FLAGS_10G;\n\t\tnp->flags &= ~NIU_FLAGS_FIBER;\n\t\tnp->mac_xcvr = MAC_XCVR_XPCS;\n\t} else if (!strcmp(phy_prop, \"xgsd\") || !strcmp(phy_prop, \"gsd\")) {\n\t\t \n\t\tnp->flags |= NIU_FLAGS_10G;\n\t\tnp->flags &= ~NIU_FLAGS_FIBER;\n\t\tnp->flags |= NIU_FLAGS_XCVR_SERDES;\n\t\tnp->mac_xcvr = MAC_XCVR_XPCS;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int niu_pci_vpd_get_nports(struct niu *np)\n{\n\tint ports = 0;\n\n\tif ((!strcmp(np->vpd.model, NIU_QGC_LP_MDL_STR)) ||\n\t    (!strcmp(np->vpd.model, NIU_QGC_PEM_MDL_STR)) ||\n\t    (!strcmp(np->vpd.model, NIU_MARAMBA_MDL_STR)) ||\n\t    (!strcmp(np->vpd.model, NIU_KIMI_MDL_STR)) ||\n\t    (!strcmp(np->vpd.model, NIU_ALONSO_MDL_STR))) {\n\t\tports = 4;\n\t} else if ((!strcmp(np->vpd.model, NIU_2XGF_LP_MDL_STR)) ||\n\t\t   (!strcmp(np->vpd.model, NIU_2XGF_PEM_MDL_STR)) ||\n\t\t   (!strcmp(np->vpd.model, NIU_FOXXY_MDL_STR)) ||\n\t\t   (!strcmp(np->vpd.model, NIU_2XGF_MRVL_MDL_STR))) {\n\t\tports = 2;\n\t}\n\n\treturn ports;\n}\n\nstatic void niu_pci_vpd_validate(struct niu *np)\n{\n\tstruct net_device *dev = np->dev;\n\tstruct niu_vpd *vpd = &np->vpd;\n\tu8 addr[ETH_ALEN];\n\tu8 val8;\n\n\tif (!is_valid_ether_addr(&vpd->local_mac[0])) {\n\t\tdev_err(np->device, \"VPD MAC invalid, falling back to SPROM\\n\");\n\n\t\tnp->flags &= ~NIU_FLAGS_VPD_VALID;\n\t\treturn;\n\t}\n\n\tif (!strcmp(np->vpd.model, NIU_ALONSO_MDL_STR) ||\n\t    !strcmp(np->vpd.model, NIU_KIMI_MDL_STR)) {\n\t\tnp->flags |= NIU_FLAGS_10G;\n\t\tnp->flags &= ~NIU_FLAGS_FIBER;\n\t\tnp->flags |= NIU_FLAGS_XCVR_SERDES;\n\t\tnp->mac_xcvr = MAC_XCVR_PCS;\n\t\tif (np->port > 1) {\n\t\t\tnp->flags |= NIU_FLAGS_FIBER;\n\t\t\tnp->flags &= ~NIU_FLAGS_10G;\n\t\t}\n\t\tif (np->flags & NIU_FLAGS_10G)\n\t\t\tnp->mac_xcvr = MAC_XCVR_XPCS;\n\t} else if (!strcmp(np->vpd.model, NIU_FOXXY_MDL_STR)) {\n\t\tnp->flags |= (NIU_FLAGS_10G | NIU_FLAGS_FIBER |\n\t\t\t      NIU_FLAGS_HOTPLUG_PHY);\n\t} else if (niu_phy_type_prop_decode(np, np->vpd.phy_type)) {\n\t\tdev_err(np->device, \"Illegal phy string [%s]\\n\",\n\t\t\tnp->vpd.phy_type);\n\t\tdev_err(np->device, \"Falling back to SPROM\\n\");\n\t\tnp->flags &= ~NIU_FLAGS_VPD_VALID;\n\t\treturn;\n\t}\n\n\tether_addr_copy(addr, vpd->local_mac);\n\n\tval8 = addr[5];\n\taddr[5] += np->port;\n\tif (addr[5] < val8)\n\t\taddr[4]++;\n\n\teth_hw_addr_set(dev, addr);\n}\n\nstatic int niu_pci_probe_sprom(struct niu *np)\n{\n\tstruct net_device *dev = np->dev;\n\tu8 addr[ETH_ALEN];\n\tint len, i;\n\tu64 val, sum;\n\tu8 val8;\n\n\tval = (nr64(ESPC_VER_IMGSZ) & ESPC_VER_IMGSZ_IMGSZ);\n\tval >>= ESPC_VER_IMGSZ_IMGSZ_SHIFT;\n\tlen = val / 4;\n\n\tnp->eeprom_len = len;\n\n\tnetif_printk(np, probe, KERN_DEBUG, np->dev,\n\t\t     \"SPROM: Image size %llu\\n\", (unsigned long long)val);\n\n\tsum = 0;\n\tfor (i = 0; i < len; i++) {\n\t\tval = nr64(ESPC_NCR(i));\n\t\tsum += (val >>  0) & 0xff;\n\t\tsum += (val >>  8) & 0xff;\n\t\tsum += (val >> 16) & 0xff;\n\t\tsum += (val >> 24) & 0xff;\n\t}\n\tnetif_printk(np, probe, KERN_DEBUG, np->dev,\n\t\t     \"SPROM: Checksum %x\\n\", (int)(sum & 0xff));\n\tif ((sum & 0xff) != 0xab) {\n\t\tdev_err(np->device, \"Bad SPROM checksum (%x, should be 0xab)\\n\", (int)(sum & 0xff));\n\t\treturn -EINVAL;\n\t}\n\n\tval = nr64(ESPC_PHY_TYPE);\n\tswitch (np->port) {\n\tcase 0:\n\t\tval8 = (val & ESPC_PHY_TYPE_PORT0) >>\n\t\t\tESPC_PHY_TYPE_PORT0_SHIFT;\n\t\tbreak;\n\tcase 1:\n\t\tval8 = (val & ESPC_PHY_TYPE_PORT1) >>\n\t\t\tESPC_PHY_TYPE_PORT1_SHIFT;\n\t\tbreak;\n\tcase 2:\n\t\tval8 = (val & ESPC_PHY_TYPE_PORT2) >>\n\t\t\tESPC_PHY_TYPE_PORT2_SHIFT;\n\t\tbreak;\n\tcase 3:\n\t\tval8 = (val & ESPC_PHY_TYPE_PORT3) >>\n\t\t\tESPC_PHY_TYPE_PORT3_SHIFT;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(np->device, \"Bogus port number %u\\n\",\n\t\t\tnp->port);\n\t\treturn -EINVAL;\n\t}\n\tnetif_printk(np, probe, KERN_DEBUG, np->dev,\n\t\t     \"SPROM: PHY type %x\\n\", val8);\n\n\tswitch (val8) {\n\tcase ESPC_PHY_TYPE_1G_COPPER:\n\t\t \n\t\tnp->flags &= ~(NIU_FLAGS_FIBER |\n\t\t\t       NIU_FLAGS_10G);\n\t\tnp->mac_xcvr = MAC_XCVR_MII;\n\t\tbreak;\n\n\tcase ESPC_PHY_TYPE_1G_FIBER:\n\t\t \n\t\tnp->flags &= ~NIU_FLAGS_10G;\n\t\tnp->flags |= NIU_FLAGS_FIBER;\n\t\tnp->mac_xcvr = MAC_XCVR_PCS;\n\t\tbreak;\n\n\tcase ESPC_PHY_TYPE_10G_COPPER:\n\t\t \n\t\tnp->flags |= NIU_FLAGS_10G;\n\t\tnp->flags &= ~NIU_FLAGS_FIBER;\n\t\tnp->mac_xcvr = MAC_XCVR_XPCS;\n\t\tbreak;\n\n\tcase ESPC_PHY_TYPE_10G_FIBER:\n\t\t \n\t\tnp->flags |= (NIU_FLAGS_10G |\n\t\t\t      NIU_FLAGS_FIBER);\n\t\tnp->mac_xcvr = MAC_XCVR_XPCS;\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(np->device, \"Bogus SPROM phy type %u\\n\", val8);\n\t\treturn -EINVAL;\n\t}\n\n\tval = nr64(ESPC_MAC_ADDR0);\n\tnetif_printk(np, probe, KERN_DEBUG, np->dev,\n\t\t     \"SPROM: MAC_ADDR0[%08llx]\\n\", (unsigned long long)val);\n\taddr[0] = (val >>  0) & 0xff;\n\taddr[1] = (val >>  8) & 0xff;\n\taddr[2] = (val >> 16) & 0xff;\n\taddr[3] = (val >> 24) & 0xff;\n\n\tval = nr64(ESPC_MAC_ADDR1);\n\tnetif_printk(np, probe, KERN_DEBUG, np->dev,\n\t\t     \"SPROM: MAC_ADDR1[%08llx]\\n\", (unsigned long long)val);\n\taddr[4] = (val >>  0) & 0xff;\n\taddr[5] = (val >>  8) & 0xff;\n\n\tif (!is_valid_ether_addr(addr)) {\n\t\tdev_err(np->device, \"SPROM MAC address invalid [ %pM ]\\n\",\n\t\t\taddr);\n\t\treturn -EINVAL;\n\t}\n\n\tval8 = addr[5];\n\taddr[5] += np->port;\n\tif (addr[5] < val8)\n\t\taddr[4]++;\n\n\teth_hw_addr_set(dev, addr);\n\n\tval = nr64(ESPC_MOD_STR_LEN);\n\tnetif_printk(np, probe, KERN_DEBUG, np->dev,\n\t\t     \"SPROM: MOD_STR_LEN[%llu]\\n\", (unsigned long long)val);\n\tif (val >= 8 * 4)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < val; i += 4) {\n\t\tu64 tmp = nr64(ESPC_NCR(5 + (i / 4)));\n\n\t\tnp->vpd.model[i + 3] = (tmp >>  0) & 0xff;\n\t\tnp->vpd.model[i + 2] = (tmp >>  8) & 0xff;\n\t\tnp->vpd.model[i + 1] = (tmp >> 16) & 0xff;\n\t\tnp->vpd.model[i + 0] = (tmp >> 24) & 0xff;\n\t}\n\tnp->vpd.model[val] = '\\0';\n\n\tval = nr64(ESPC_BD_MOD_STR_LEN);\n\tnetif_printk(np, probe, KERN_DEBUG, np->dev,\n\t\t     \"SPROM: BD_MOD_STR_LEN[%llu]\\n\", (unsigned long long)val);\n\tif (val >= 4 * 4)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < val; i += 4) {\n\t\tu64 tmp = nr64(ESPC_NCR(14 + (i / 4)));\n\n\t\tnp->vpd.board_model[i + 3] = (tmp >>  0) & 0xff;\n\t\tnp->vpd.board_model[i + 2] = (tmp >>  8) & 0xff;\n\t\tnp->vpd.board_model[i + 1] = (tmp >> 16) & 0xff;\n\t\tnp->vpd.board_model[i + 0] = (tmp >> 24) & 0xff;\n\t}\n\tnp->vpd.board_model[val] = '\\0';\n\n\tnp->vpd.mac_num =\n\t\tnr64(ESPC_NUM_PORTS_MACS) & ESPC_NUM_PORTS_MACS_VAL;\n\tnetif_printk(np, probe, KERN_DEBUG, np->dev,\n\t\t     \"SPROM: NUM_PORTS_MACS[%d]\\n\", np->vpd.mac_num);\n\n\treturn 0;\n}\n\nstatic int niu_get_and_validate_port(struct niu *np)\n{\n\tstruct niu_parent *parent = np->parent;\n\n\tif (np->port <= 1)\n\t\tnp->flags |= NIU_FLAGS_XMAC;\n\n\tif (!parent->num_ports) {\n\t\tif (parent->plat_type == PLAT_TYPE_NIU) {\n\t\t\tparent->num_ports = 2;\n\t\t} else {\n\t\t\tparent->num_ports = niu_pci_vpd_get_nports(np);\n\t\t\tif (!parent->num_ports) {\n\t\t\t\t \n\t\t\t\tparent->num_ports = nr64(ESPC_NUM_PORTS_MACS) &\n\t\t\t\t\tESPC_NUM_PORTS_MACS_VAL;\n\n\t\t\t\t \n\t\t\t\tif (!parent->num_ports)\n\t\t\t\t\tparent->num_ports = 4;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (np->port >= parent->num_ports)\n\t\treturn -ENODEV;\n\n\treturn 0;\n}\n\nstatic int phy_record(struct niu_parent *parent, struct phy_probe_info *p,\n\t\t      int dev_id_1, int dev_id_2, u8 phy_port, int type)\n{\n\tu32 id = (dev_id_1 << 16) | dev_id_2;\n\tu8 idx;\n\n\tif (dev_id_1 < 0 || dev_id_2 < 0)\n\t\treturn 0;\n\tif (type == PHY_TYPE_PMA_PMD || type == PHY_TYPE_PCS) {\n\t\t \n\t\tif (((id & NIU_PHY_ID_MASK) != NIU_PHY_ID_BCM8704) &&\n\t\t    ((id & NIU_PHY_ID_MASK) != NIU_PHY_ID_MRVL88X2011))\n\t\t\treturn 0;\n\t} else {\n\t\tif ((id & NIU_PHY_ID_MASK) != NIU_PHY_ID_BCM5464R)\n\t\t\treturn 0;\n\t}\n\n\tpr_info(\"niu%d: Found PHY %08x type %s at phy_port %u\\n\",\n\t\tparent->index, id,\n\t\ttype == PHY_TYPE_PMA_PMD ? \"PMA/PMD\" :\n\t\ttype == PHY_TYPE_PCS ? \"PCS\" : \"MII\",\n\t\tphy_port);\n\n\tif (p->cur[type] >= NIU_MAX_PORTS) {\n\t\tpr_err(\"Too many PHY ports\\n\");\n\t\treturn -EINVAL;\n\t}\n\tidx = p->cur[type];\n\tp->phy_id[type][idx] = id;\n\tp->phy_port[type][idx] = phy_port;\n\tp->cur[type] = idx + 1;\n\treturn 0;\n}\n\nstatic int port_has_10g(struct phy_probe_info *p, int port)\n{\n\tint i;\n\n\tfor (i = 0; i < p->cur[PHY_TYPE_PMA_PMD]; i++) {\n\t\tif (p->phy_port[PHY_TYPE_PMA_PMD][i] == port)\n\t\t\treturn 1;\n\t}\n\tfor (i = 0; i < p->cur[PHY_TYPE_PCS]; i++) {\n\t\tif (p->phy_port[PHY_TYPE_PCS][i] == port)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int count_10g_ports(struct phy_probe_info *p, int *lowest)\n{\n\tint port, cnt;\n\n\tcnt = 0;\n\t*lowest = 32;\n\tfor (port = 8; port < 32; port++) {\n\t\tif (port_has_10g(p, port)) {\n\t\t\tif (!cnt)\n\t\t\t\t*lowest = port;\n\t\t\tcnt++;\n\t\t}\n\t}\n\n\treturn cnt;\n}\n\nstatic int count_1g_ports(struct phy_probe_info *p, int *lowest)\n{\n\t*lowest = 32;\n\tif (p->cur[PHY_TYPE_MII])\n\t\t*lowest = p->phy_port[PHY_TYPE_MII][0];\n\n\treturn p->cur[PHY_TYPE_MII];\n}\n\nstatic void niu_n2_divide_channels(struct niu_parent *parent)\n{\n\tint num_ports = parent->num_ports;\n\tint i;\n\n\tfor (i = 0; i < num_ports; i++) {\n\t\tparent->rxchan_per_port[i] = (16 / num_ports);\n\t\tparent->txchan_per_port[i] = (16 / num_ports);\n\n\t\tpr_info(\"niu%d: Port %u [%u RX chans] [%u TX chans]\\n\",\n\t\t\tparent->index, i,\n\t\t\tparent->rxchan_per_port[i],\n\t\t\tparent->txchan_per_port[i]);\n\t}\n}\n\nstatic void niu_divide_channels(struct niu_parent *parent,\n\t\t\t\tint num_10g, int num_1g)\n{\n\tint num_ports = parent->num_ports;\n\tint rx_chans_per_10g, rx_chans_per_1g;\n\tint tx_chans_per_10g, tx_chans_per_1g;\n\tint i, tot_rx, tot_tx;\n\n\tif (!num_10g || !num_1g) {\n\t\trx_chans_per_10g = rx_chans_per_1g =\n\t\t\t(NIU_NUM_RXCHAN / num_ports);\n\t\ttx_chans_per_10g = tx_chans_per_1g =\n\t\t\t(NIU_NUM_TXCHAN / num_ports);\n\t} else {\n\t\trx_chans_per_1g = NIU_NUM_RXCHAN / 8;\n\t\trx_chans_per_10g = (NIU_NUM_RXCHAN -\n\t\t\t\t    (rx_chans_per_1g * num_1g)) /\n\t\t\tnum_10g;\n\n\t\ttx_chans_per_1g = NIU_NUM_TXCHAN / 6;\n\t\ttx_chans_per_10g = (NIU_NUM_TXCHAN -\n\t\t\t\t    (tx_chans_per_1g * num_1g)) /\n\t\t\tnum_10g;\n\t}\n\n\ttot_rx = tot_tx = 0;\n\tfor (i = 0; i < num_ports; i++) {\n\t\tint type = phy_decode(parent->port_phy, i);\n\n\t\tif (type == PORT_TYPE_10G) {\n\t\t\tparent->rxchan_per_port[i] = rx_chans_per_10g;\n\t\t\tparent->txchan_per_port[i] = tx_chans_per_10g;\n\t\t} else {\n\t\t\tparent->rxchan_per_port[i] = rx_chans_per_1g;\n\t\t\tparent->txchan_per_port[i] = tx_chans_per_1g;\n\t\t}\n\t\tpr_info(\"niu%d: Port %u [%u RX chans] [%u TX chans]\\n\",\n\t\t\tparent->index, i,\n\t\t\tparent->rxchan_per_port[i],\n\t\t\tparent->txchan_per_port[i]);\n\t\ttot_rx += parent->rxchan_per_port[i];\n\t\ttot_tx += parent->txchan_per_port[i];\n\t}\n\n\tif (tot_rx > NIU_NUM_RXCHAN) {\n\t\tpr_err(\"niu%d: Too many RX channels (%d), resetting to one per port\\n\",\n\t\t       parent->index, tot_rx);\n\t\tfor (i = 0; i < num_ports; i++)\n\t\t\tparent->rxchan_per_port[i] = 1;\n\t}\n\tif (tot_tx > NIU_NUM_TXCHAN) {\n\t\tpr_err(\"niu%d: Too many TX channels (%d), resetting to one per port\\n\",\n\t\t       parent->index, tot_tx);\n\t\tfor (i = 0; i < num_ports; i++)\n\t\t\tparent->txchan_per_port[i] = 1;\n\t}\n\tif (tot_rx < NIU_NUM_RXCHAN || tot_tx < NIU_NUM_TXCHAN) {\n\t\tpr_warn(\"niu%d: Driver bug, wasted channels, RX[%d] TX[%d]\\n\",\n\t\t\tparent->index, tot_rx, tot_tx);\n\t}\n}\n\nstatic void niu_divide_rdc_groups(struct niu_parent *parent,\n\t\t\t\t  int num_10g, int num_1g)\n{\n\tint i, num_ports = parent->num_ports;\n\tint rdc_group, rdc_groups_per_port;\n\tint rdc_channel_base;\n\n\trdc_group = 0;\n\trdc_groups_per_port = NIU_NUM_RDC_TABLES / num_ports;\n\n\trdc_channel_base = 0;\n\n\tfor (i = 0; i < num_ports; i++) {\n\t\tstruct niu_rdc_tables *tp = &parent->rdc_group_cfg[i];\n\t\tint grp, num_channels = parent->rxchan_per_port[i];\n\t\tint this_channel_offset;\n\n\t\ttp->first_table_num = rdc_group;\n\t\ttp->num_tables = rdc_groups_per_port;\n\t\tthis_channel_offset = 0;\n\t\tfor (grp = 0; grp < tp->num_tables; grp++) {\n\t\t\tstruct rdc_table *rt = &tp->tables[grp];\n\t\t\tint slot;\n\n\t\t\tpr_info(\"niu%d: Port %d RDC tbl(%d) [ \",\n\t\t\t\tparent->index, i, tp->first_table_num + grp);\n\t\t\tfor (slot = 0; slot < NIU_RDC_TABLE_SLOTS; slot++) {\n\t\t\t\trt->rxdma_channel[slot] =\n\t\t\t\t\trdc_channel_base + this_channel_offset;\n\n\t\t\t\tpr_cont(\"%d \", rt->rxdma_channel[slot]);\n\n\t\t\t\tif (++this_channel_offset == num_channels)\n\t\t\t\t\tthis_channel_offset = 0;\n\t\t\t}\n\t\t\tpr_cont(\"]\\n\");\n\t\t}\n\n\t\tparent->rdc_default[i] = rdc_channel_base;\n\n\t\trdc_channel_base += num_channels;\n\t\trdc_group += rdc_groups_per_port;\n\t}\n}\n\nstatic int fill_phy_probe_info(struct niu *np, struct niu_parent *parent,\n\t\t\t       struct phy_probe_info *info)\n{\n\tunsigned long flags;\n\tint port, err;\n\n\tmemset(info, 0, sizeof(*info));\n\n\t \n\tniu_lock_parent(np, flags);\n\terr = 0;\n\tfor (port = 8; port < 32; port++) {\n\t\tint dev_id_1, dev_id_2;\n\n\t\tdev_id_1 = mdio_read(np, port,\n\t\t\t\t     NIU_PMA_PMD_DEV_ADDR, MII_PHYSID1);\n\t\tdev_id_2 = mdio_read(np, port,\n\t\t\t\t     NIU_PMA_PMD_DEV_ADDR, MII_PHYSID2);\n\t\terr = phy_record(parent, info, dev_id_1, dev_id_2, port,\n\t\t\t\t PHY_TYPE_PMA_PMD);\n\t\tif (err)\n\t\t\tbreak;\n\t\tdev_id_1 = mdio_read(np, port,\n\t\t\t\t     NIU_PCS_DEV_ADDR, MII_PHYSID1);\n\t\tdev_id_2 = mdio_read(np, port,\n\t\t\t\t     NIU_PCS_DEV_ADDR, MII_PHYSID2);\n\t\terr = phy_record(parent, info, dev_id_1, dev_id_2, port,\n\t\t\t\t PHY_TYPE_PCS);\n\t\tif (err)\n\t\t\tbreak;\n\t\tdev_id_1 = mii_read(np, port, MII_PHYSID1);\n\t\tdev_id_2 = mii_read(np, port, MII_PHYSID2);\n\t\terr = phy_record(parent, info, dev_id_1, dev_id_2, port,\n\t\t\t\t PHY_TYPE_MII);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\tniu_unlock_parent(np, flags);\n\n\treturn err;\n}\n\nstatic int walk_phys(struct niu *np, struct niu_parent *parent)\n{\n\tstruct phy_probe_info *info = &parent->phy_probe_info;\n\tint lowest_10g, lowest_1g;\n\tint num_10g, num_1g;\n\tu32 val;\n\tint err;\n\n\tnum_10g = num_1g = 0;\n\n\tif (!strcmp(np->vpd.model, NIU_ALONSO_MDL_STR) ||\n\t    !strcmp(np->vpd.model, NIU_KIMI_MDL_STR)) {\n\t\tnum_10g = 0;\n\t\tnum_1g = 2;\n\t\tparent->plat_type = PLAT_TYPE_ATCA_CP3220;\n\t\tparent->num_ports = 4;\n\t\tval = (phy_encode(PORT_TYPE_1G, 0) |\n\t\t       phy_encode(PORT_TYPE_1G, 1) |\n\t\t       phy_encode(PORT_TYPE_1G, 2) |\n\t\t       phy_encode(PORT_TYPE_1G, 3));\n\t} else if (!strcmp(np->vpd.model, NIU_FOXXY_MDL_STR)) {\n\t\tnum_10g = 2;\n\t\tnum_1g = 0;\n\t\tparent->num_ports = 2;\n\t\tval = (phy_encode(PORT_TYPE_10G, 0) |\n\t\t       phy_encode(PORT_TYPE_10G, 1));\n\t} else if ((np->flags & NIU_FLAGS_XCVR_SERDES) &&\n\t\t   (parent->plat_type == PLAT_TYPE_NIU)) {\n\t\t \n\t\tif (np->flags & NIU_FLAGS_10G) {\n\t\t\tval = (phy_encode(PORT_TYPE_10G, 0) |\n\t\t\t       phy_encode(PORT_TYPE_10G, 1));\n\t\t} else {\n\t\t\tval = (phy_encode(PORT_TYPE_1G, 0) |\n\t\t\t       phy_encode(PORT_TYPE_1G, 1));\n\t\t}\n\t} else {\n\t\terr = fill_phy_probe_info(np, parent, info);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tnum_10g = count_10g_ports(info, &lowest_10g);\n\t\tnum_1g = count_1g_ports(info, &lowest_1g);\n\n\t\tswitch ((num_10g << 4) | num_1g) {\n\t\tcase 0x24:\n\t\t\tif (lowest_1g == 10)\n\t\t\t\tparent->plat_type = PLAT_TYPE_VF_P0;\n\t\t\telse if (lowest_1g == 26)\n\t\t\t\tparent->plat_type = PLAT_TYPE_VF_P1;\n\t\t\telse\n\t\t\t\tgoto unknown_vg_1g_port;\n\n\t\t\tfallthrough;\n\t\tcase 0x22:\n\t\t\tval = (phy_encode(PORT_TYPE_10G, 0) |\n\t\t\t       phy_encode(PORT_TYPE_10G, 1) |\n\t\t\t       phy_encode(PORT_TYPE_1G, 2) |\n\t\t\t       phy_encode(PORT_TYPE_1G, 3));\n\t\t\tbreak;\n\n\t\tcase 0x20:\n\t\t\tval = (phy_encode(PORT_TYPE_10G, 0) |\n\t\t\t       phy_encode(PORT_TYPE_10G, 1));\n\t\t\tbreak;\n\n\t\tcase 0x10:\n\t\t\tval = phy_encode(PORT_TYPE_10G, np->port);\n\t\t\tbreak;\n\n\t\tcase 0x14:\n\t\t\tif (lowest_1g == 10)\n\t\t\t\tparent->plat_type = PLAT_TYPE_VF_P0;\n\t\t\telse if (lowest_1g == 26)\n\t\t\t\tparent->plat_type = PLAT_TYPE_VF_P1;\n\t\t\telse\n\t\t\t\tgoto unknown_vg_1g_port;\n\n\t\t\tfallthrough;\n\t\tcase 0x13:\n\t\t\tif ((lowest_10g & 0x7) == 0)\n\t\t\t\tval = (phy_encode(PORT_TYPE_10G, 0) |\n\t\t\t\t       phy_encode(PORT_TYPE_1G, 1) |\n\t\t\t\t       phy_encode(PORT_TYPE_1G, 2) |\n\t\t\t\t       phy_encode(PORT_TYPE_1G, 3));\n\t\t\telse\n\t\t\t\tval = (phy_encode(PORT_TYPE_1G, 0) |\n\t\t\t\t       phy_encode(PORT_TYPE_10G, 1) |\n\t\t\t\t       phy_encode(PORT_TYPE_1G, 2) |\n\t\t\t\t       phy_encode(PORT_TYPE_1G, 3));\n\t\t\tbreak;\n\n\t\tcase 0x04:\n\t\t\tif (lowest_1g == 10)\n\t\t\t\tparent->plat_type = PLAT_TYPE_VF_P0;\n\t\t\telse if (lowest_1g == 26)\n\t\t\t\tparent->plat_type = PLAT_TYPE_VF_P1;\n\t\t\telse\n\t\t\t\tgoto unknown_vg_1g_port;\n\n\t\t\tval = (phy_encode(PORT_TYPE_1G, 0) |\n\t\t\t       phy_encode(PORT_TYPE_1G, 1) |\n\t\t\t       phy_encode(PORT_TYPE_1G, 2) |\n\t\t\t       phy_encode(PORT_TYPE_1G, 3));\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tpr_err(\"Unsupported port config 10G[%d] 1G[%d]\\n\",\n\t\t\t       num_10g, num_1g);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tparent->port_phy = val;\n\n\tif (parent->plat_type == PLAT_TYPE_NIU)\n\t\tniu_n2_divide_channels(parent);\n\telse\n\t\tniu_divide_channels(parent, num_10g, num_1g);\n\n\tniu_divide_rdc_groups(parent, num_10g, num_1g);\n\n\treturn 0;\n\nunknown_vg_1g_port:\n\tpr_err(\"Cannot identify platform type, 1gport=%d\\n\", lowest_1g);\n\treturn -EINVAL;\n}\n\nstatic int niu_probe_ports(struct niu *np)\n{\n\tstruct niu_parent *parent = np->parent;\n\tint err, i;\n\n\tif (parent->port_phy == PORT_PHY_UNKNOWN) {\n\t\terr = walk_phys(np, parent);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tniu_set_ldg_timer_res(np, 2);\n\t\tfor (i = 0; i <= LDN_MAX; i++)\n\t\t\tniu_ldn_irq_enable(np, i, 0);\n\t}\n\n\tif (parent->port_phy == PORT_PHY_INVALID)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int niu_classifier_swstate_init(struct niu *np)\n{\n\tstruct niu_classifier *cp = &np->clas;\n\n\tcp->tcam_top = (u16) np->port;\n\tcp->tcam_sz = np->parent->tcam_num_entries / np->parent->num_ports;\n\tcp->h1_init = 0xffffffff;\n\tcp->h2_init = 0xffff;\n\n\treturn fflp_early_init(np);\n}\n\nstatic void niu_link_config_init(struct niu *np)\n{\n\tstruct niu_link_config *lp = &np->link_config;\n\n\tlp->advertising = (ADVERTISED_10baseT_Half |\n\t\t\t   ADVERTISED_10baseT_Full |\n\t\t\t   ADVERTISED_100baseT_Half |\n\t\t\t   ADVERTISED_100baseT_Full |\n\t\t\t   ADVERTISED_1000baseT_Half |\n\t\t\t   ADVERTISED_1000baseT_Full |\n\t\t\t   ADVERTISED_10000baseT_Full |\n\t\t\t   ADVERTISED_Autoneg);\n\tlp->speed = lp->active_speed = SPEED_INVALID;\n\tlp->duplex = DUPLEX_FULL;\n\tlp->active_duplex = DUPLEX_INVALID;\n\tlp->autoneg = 1;\n#if 0\n\tlp->loopback_mode = LOOPBACK_MAC;\n\tlp->active_speed = SPEED_10000;\n\tlp->active_duplex = DUPLEX_FULL;\n#else\n\tlp->loopback_mode = LOOPBACK_DISABLED;\n#endif\n}\n\nstatic int niu_init_mac_ipp_pcs_base(struct niu *np)\n{\n\tswitch (np->port) {\n\tcase 0:\n\t\tnp->mac_regs = np->regs + XMAC_PORT0_OFF;\n\t\tnp->ipp_off  = 0x00000;\n\t\tnp->pcs_off  = 0x04000;\n\t\tnp->xpcs_off = 0x02000;\n\t\tbreak;\n\n\tcase 1:\n\t\tnp->mac_regs = np->regs + XMAC_PORT1_OFF;\n\t\tnp->ipp_off  = 0x08000;\n\t\tnp->pcs_off  = 0x0a000;\n\t\tnp->xpcs_off = 0x08000;\n\t\tbreak;\n\n\tcase 2:\n\t\tnp->mac_regs = np->regs + BMAC_PORT2_OFF;\n\t\tnp->ipp_off  = 0x04000;\n\t\tnp->pcs_off  = 0x0e000;\n\t\tnp->xpcs_off = ~0UL;\n\t\tbreak;\n\n\tcase 3:\n\t\tnp->mac_regs = np->regs + BMAC_PORT3_OFF;\n\t\tnp->ipp_off  = 0x0c000;\n\t\tnp->pcs_off  = 0x12000;\n\t\tnp->xpcs_off = ~0UL;\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(np->device, \"Port %u is invalid, cannot compute MAC block offset\\n\", np->port);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void niu_try_msix(struct niu *np, u8 *ldg_num_map)\n{\n\tstruct msix_entry msi_vec[NIU_NUM_LDG];\n\tstruct niu_parent *parent = np->parent;\n\tstruct pci_dev *pdev = np->pdev;\n\tint i, num_irqs;\n\tu8 first_ldg;\n\n\tfirst_ldg = (NIU_NUM_LDG / parent->num_ports) * np->port;\n\tfor (i = 0; i < (NIU_NUM_LDG / parent->num_ports); i++)\n\t\tldg_num_map[i] = first_ldg + i;\n\n\tnum_irqs = (parent->rxchan_per_port[np->port] +\n\t\t    parent->txchan_per_port[np->port] +\n\t\t    (np->port == 0 ? 3 : 1));\n\tBUG_ON(num_irqs > (NIU_NUM_LDG / parent->num_ports));\n\n\tfor (i = 0; i < num_irqs; i++) {\n\t\tmsi_vec[i].vector = 0;\n\t\tmsi_vec[i].entry = i;\n\t}\n\n\tnum_irqs = pci_enable_msix_range(pdev, msi_vec, 1, num_irqs);\n\tif (num_irqs < 0) {\n\t\tnp->flags &= ~NIU_FLAGS_MSIX;\n\t\treturn;\n\t}\n\n\tnp->flags |= NIU_FLAGS_MSIX;\n\tfor (i = 0; i < num_irqs; i++)\n\t\tnp->ldg[i].irq = msi_vec[i].vector;\n\tnp->num_ldg = num_irqs;\n}\n\nstatic int niu_n2_irq_init(struct niu *np, u8 *ldg_num_map)\n{\n#ifdef CONFIG_SPARC64\n\tstruct platform_device *op = np->op;\n\tconst u32 *int_prop;\n\tint i;\n\n\tint_prop = of_get_property(op->dev.of_node, \"interrupts\", NULL);\n\tif (!int_prop)\n\t\treturn -ENODEV;\n\n\tfor (i = 0; i < op->archdata.num_irqs; i++) {\n\t\tldg_num_map[i] = int_prop[i];\n\t\tnp->ldg[i].irq = op->archdata.irqs[i];\n\t}\n\n\tnp->num_ldg = op->archdata.num_irqs;\n\n\treturn 0;\n#else\n\treturn -EINVAL;\n#endif\n}\n\nstatic int niu_ldg_init(struct niu *np)\n{\n\tstruct niu_parent *parent = np->parent;\n\tu8 ldg_num_map[NIU_NUM_LDG];\n\tint first_chan, num_chan;\n\tint i, err, ldg_rotor;\n\tu8 port;\n\n\tnp->num_ldg = 1;\n\tnp->ldg[0].irq = np->dev->irq;\n\tif (parent->plat_type == PLAT_TYPE_NIU) {\n\t\terr = niu_n2_irq_init(np, ldg_num_map);\n\t\tif (err)\n\t\t\treturn err;\n\t} else\n\t\tniu_try_msix(np, ldg_num_map);\n\n\tport = np->port;\n\tfor (i = 0; i < np->num_ldg; i++) {\n\t\tstruct niu_ldg *lp = &np->ldg[i];\n\n\t\tnetif_napi_add(np->dev, &lp->napi, niu_poll);\n\n\t\tlp->np = np;\n\t\tlp->ldg_num = ldg_num_map[i];\n\t\tlp->timer = 2;  \n\n\t\t \n\t\tif (np->parent->plat_type != PLAT_TYPE_NIU) {\n\t\t\terr = niu_set_ldg_sid(np, lp->ldg_num, port, i);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\t \n\n\tldg_rotor = 0;\n\n\terr = niu_ldg_assign_ldn(np, parent, ldg_num_map[ldg_rotor],\n\t\t\t\t  LDN_MAC(port));\n\tif (err)\n\t\treturn err;\n\n\tldg_rotor++;\n\tif (ldg_rotor == np->num_ldg)\n\t\tldg_rotor = 0;\n\n\tif (port == 0) {\n\t\terr = niu_ldg_assign_ldn(np, parent,\n\t\t\t\t\t ldg_num_map[ldg_rotor],\n\t\t\t\t\t LDN_MIF);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tldg_rotor++;\n\t\tif (ldg_rotor == np->num_ldg)\n\t\t\tldg_rotor = 0;\n\n\t\terr = niu_ldg_assign_ldn(np, parent,\n\t\t\t\t\t ldg_num_map[ldg_rotor],\n\t\t\t\t\t LDN_DEVICE_ERROR);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tldg_rotor++;\n\t\tif (ldg_rotor == np->num_ldg)\n\t\t\tldg_rotor = 0;\n\n\t}\n\n\tfirst_chan = 0;\n\tfor (i = 0; i < port; i++)\n\t\tfirst_chan += parent->rxchan_per_port[i];\n\tnum_chan = parent->rxchan_per_port[port];\n\n\tfor (i = first_chan; i < (first_chan + num_chan); i++) {\n\t\terr = niu_ldg_assign_ldn(np, parent,\n\t\t\t\t\t ldg_num_map[ldg_rotor],\n\t\t\t\t\t LDN_RXDMA(i));\n\t\tif (err)\n\t\t\treturn err;\n\t\tldg_rotor++;\n\t\tif (ldg_rotor == np->num_ldg)\n\t\t\tldg_rotor = 0;\n\t}\n\n\tfirst_chan = 0;\n\tfor (i = 0; i < port; i++)\n\t\tfirst_chan += parent->txchan_per_port[i];\n\tnum_chan = parent->txchan_per_port[port];\n\tfor (i = first_chan; i < (first_chan + num_chan); i++) {\n\t\terr = niu_ldg_assign_ldn(np, parent,\n\t\t\t\t\t ldg_num_map[ldg_rotor],\n\t\t\t\t\t LDN_TXDMA(i));\n\t\tif (err)\n\t\t\treturn err;\n\t\tldg_rotor++;\n\t\tif (ldg_rotor == np->num_ldg)\n\t\t\tldg_rotor = 0;\n\t}\n\n\treturn 0;\n}\n\nstatic void niu_ldg_free(struct niu *np)\n{\n\tif (np->flags & NIU_FLAGS_MSIX)\n\t\tpci_disable_msix(np->pdev);\n}\n\nstatic int niu_get_of_props(struct niu *np)\n{\n#ifdef CONFIG_SPARC64\n\tstruct net_device *dev = np->dev;\n\tstruct device_node *dp;\n\tconst char *phy_type;\n\tconst u8 *mac_addr;\n\tconst char *model;\n\tint prop_len;\n\n\tif (np->parent->plat_type == PLAT_TYPE_NIU)\n\t\tdp = np->op->dev.of_node;\n\telse\n\t\tdp = pci_device_to_OF_node(np->pdev);\n\n\tphy_type = of_get_property(dp, \"phy-type\", NULL);\n\tif (!phy_type) {\n\t\tnetdev_err(dev, \"%pOF: OF node lacks phy-type property\\n\", dp);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!strcmp(phy_type, \"none\"))\n\t\treturn -ENODEV;\n\n\tstrcpy(np->vpd.phy_type, phy_type);\n\n\tif (niu_phy_type_prop_decode(np, np->vpd.phy_type)) {\n\t\tnetdev_err(dev, \"%pOF: Illegal phy string [%s]\\n\",\n\t\t\t   dp, np->vpd.phy_type);\n\t\treturn -EINVAL;\n\t}\n\n\tmac_addr = of_get_property(dp, \"local-mac-address\", &prop_len);\n\tif (!mac_addr) {\n\t\tnetdev_err(dev, \"%pOF: OF node lacks local-mac-address property\\n\",\n\t\t\t   dp);\n\t\treturn -EINVAL;\n\t}\n\tif (prop_len != dev->addr_len) {\n\t\tnetdev_err(dev, \"%pOF: OF MAC address prop len (%d) is wrong\\n\",\n\t\t\t   dp, prop_len);\n\t}\n\teth_hw_addr_set(dev, mac_addr);\n\tif (!is_valid_ether_addr(&dev->dev_addr[0])) {\n\t\tnetdev_err(dev, \"%pOF: OF MAC address is invalid\\n\", dp);\n\t\tnetdev_err(dev, \"%pOF: [ %pM ]\\n\", dp, dev->dev_addr);\n\t\treturn -EINVAL;\n\t}\n\n\tmodel = of_get_property(dp, \"model\", NULL);\n\n\tif (model)\n\t\tstrcpy(np->vpd.model, model);\n\n\tif (of_property_read_bool(dp, \"hot-swappable-phy\")) {\n\t\tnp->flags |= (NIU_FLAGS_10G | NIU_FLAGS_FIBER |\n\t\t\tNIU_FLAGS_HOTPLUG_PHY);\n\t}\n\n\treturn 0;\n#else\n\treturn -EINVAL;\n#endif\n}\n\nstatic int niu_get_invariants(struct niu *np)\n{\n\tint err, have_props;\n\tu32 offset;\n\n\terr = niu_get_of_props(np);\n\tif (err == -ENODEV)\n\t\treturn err;\n\n\thave_props = !err;\n\n\terr = niu_init_mac_ipp_pcs_base(np);\n\tif (err)\n\t\treturn err;\n\n\tif (have_props) {\n\t\terr = niu_get_and_validate_port(np);\n\t\tif (err)\n\t\t\treturn err;\n\n\t} else  {\n\t\tif (np->parent->plat_type == PLAT_TYPE_NIU)\n\t\t\treturn -EINVAL;\n\n\t\tnw64(ESPC_PIO_EN, ESPC_PIO_EN_ENABLE);\n\t\toffset = niu_pci_vpd_offset(np);\n\t\tnetif_printk(np, probe, KERN_DEBUG, np->dev,\n\t\t\t     \"%s() VPD offset [%08x]\\n\", __func__, offset);\n\t\tif (offset) {\n\t\t\terr = niu_pci_vpd_fetch(np, offset);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\tnw64(ESPC_PIO_EN, 0);\n\n\t\tif (np->flags & NIU_FLAGS_VPD_VALID) {\n\t\t\tniu_pci_vpd_validate(np);\n\t\t\terr = niu_get_and_validate_port(np);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\n\t\tif (!(np->flags & NIU_FLAGS_VPD_VALID)) {\n\t\t\terr = niu_get_and_validate_port(np);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\terr = niu_pci_probe_sprom(np);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\terr = niu_probe_ports(np);\n\tif (err)\n\t\treturn err;\n\n\tniu_ldg_init(np);\n\n\tniu_classifier_swstate_init(np);\n\tniu_link_config_init(np);\n\n\terr = niu_determine_phy_disposition(np);\n\tif (!err)\n\t\terr = niu_init_link(np);\n\n\treturn err;\n}\n\nstatic LIST_HEAD(niu_parent_list);\nstatic DEFINE_MUTEX(niu_parent_lock);\nstatic int niu_parent_index;\n\nstatic ssize_t show_port_phy(struct device *dev,\n\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct platform_device *plat_dev = to_platform_device(dev);\n\tstruct niu_parent *p = dev_get_platdata(&plat_dev->dev);\n\tu32 port_phy = p->port_phy;\n\tchar *orig_buf = buf;\n\tint i;\n\n\tif (port_phy == PORT_PHY_UNKNOWN ||\n\t    port_phy == PORT_PHY_INVALID)\n\t\treturn 0;\n\n\tfor (i = 0; i < p->num_ports; i++) {\n\t\tconst char *type_str;\n\t\tint type;\n\n\t\ttype = phy_decode(port_phy, i);\n\t\tif (type == PORT_TYPE_10G)\n\t\t\ttype_str = \"10G\";\n\t\telse\n\t\t\ttype_str = \"1G\";\n\t\tbuf += sprintf(buf,\n\t\t\t       (i == 0) ? \"%s\" : \" %s\",\n\t\t\t       type_str);\n\t}\n\tbuf += sprintf(buf, \"\\n\");\n\treturn buf - orig_buf;\n}\n\nstatic ssize_t show_plat_type(struct device *dev,\n\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tstruct platform_device *plat_dev = to_platform_device(dev);\n\tstruct niu_parent *p = dev_get_platdata(&plat_dev->dev);\n\tconst char *type_str;\n\n\tswitch (p->plat_type) {\n\tcase PLAT_TYPE_ATLAS:\n\t\ttype_str = \"atlas\";\n\t\tbreak;\n\tcase PLAT_TYPE_NIU:\n\t\ttype_str = \"niu\";\n\t\tbreak;\n\tcase PLAT_TYPE_VF_P0:\n\t\ttype_str = \"vf_p0\";\n\t\tbreak;\n\tcase PLAT_TYPE_VF_P1:\n\t\ttype_str = \"vf_p1\";\n\t\tbreak;\n\tdefault:\n\t\ttype_str = \"unknown\";\n\t\tbreak;\n\t}\n\n\treturn sprintf(buf, \"%s\\n\", type_str);\n}\n\nstatic ssize_t __show_chan_per_port(struct device *dev,\n\t\t\t\t    struct device_attribute *attr, char *buf,\n\t\t\t\t    int rx)\n{\n\tstruct platform_device *plat_dev = to_platform_device(dev);\n\tstruct niu_parent *p = dev_get_platdata(&plat_dev->dev);\n\tchar *orig_buf = buf;\n\tu8 *arr;\n\tint i;\n\n\tarr = (rx ? p->rxchan_per_port : p->txchan_per_port);\n\n\tfor (i = 0; i < p->num_ports; i++) {\n\t\tbuf += sprintf(buf,\n\t\t\t       (i == 0) ? \"%d\" : \" %d\",\n\t\t\t       arr[i]);\n\t}\n\tbuf += sprintf(buf, \"\\n\");\n\n\treturn buf - orig_buf;\n}\n\nstatic ssize_t show_rxchan_per_port(struct device *dev,\n\t\t\t\t    struct device_attribute *attr, char *buf)\n{\n\treturn __show_chan_per_port(dev, attr, buf, 1);\n}\n\nstatic ssize_t show_txchan_per_port(struct device *dev,\n\t\t\t\t    struct device_attribute *attr, char *buf)\n{\n\treturn __show_chan_per_port(dev, attr, buf, 1);\n}\n\nstatic ssize_t show_num_ports(struct device *dev,\n\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tstruct platform_device *plat_dev = to_platform_device(dev);\n\tstruct niu_parent *p = dev_get_platdata(&plat_dev->dev);\n\n\treturn sprintf(buf, \"%d\\n\", p->num_ports);\n}\n\nstatic struct device_attribute niu_parent_attributes[] = {\n\t__ATTR(port_phy, 0444, show_port_phy, NULL),\n\t__ATTR(plat_type, 0444, show_plat_type, NULL),\n\t__ATTR(rxchan_per_port, 0444, show_rxchan_per_port, NULL),\n\t__ATTR(txchan_per_port, 0444, show_txchan_per_port, NULL),\n\t__ATTR(num_ports, 0444, show_num_ports, NULL),\n\t{}\n};\n\nstatic struct niu_parent *niu_new_parent(struct niu *np,\n\t\t\t\t\t union niu_parent_id *id, u8 ptype)\n{\n\tstruct platform_device *plat_dev;\n\tstruct niu_parent *p;\n\tint i;\n\n\tplat_dev = platform_device_register_simple(\"niu-board\", niu_parent_index,\n\t\t\t\t\t\t   NULL, 0);\n\tif (IS_ERR(plat_dev))\n\t\treturn NULL;\n\n\tfor (i = 0; niu_parent_attributes[i].attr.name; i++) {\n\t\tint err = device_create_file(&plat_dev->dev,\n\t\t\t\t\t     &niu_parent_attributes[i]);\n\t\tif (err)\n\t\t\tgoto fail_unregister;\n\t}\n\n\tp = kzalloc(sizeof(*p), GFP_KERNEL);\n\tif (!p)\n\t\tgoto fail_unregister;\n\n\tp->index = niu_parent_index++;\n\n\tplat_dev->dev.platform_data = p;\n\tp->plat_dev = plat_dev;\n\n\tmemcpy(&p->id, id, sizeof(*id));\n\tp->plat_type = ptype;\n\tINIT_LIST_HEAD(&p->list);\n\tatomic_set(&p->refcnt, 0);\n\tlist_add(&p->list, &niu_parent_list);\n\tspin_lock_init(&p->lock);\n\n\tp->rxdma_clock_divider = 7500;\n\n\tp->tcam_num_entries = NIU_PCI_TCAM_ENTRIES;\n\tif (p->plat_type == PLAT_TYPE_NIU)\n\t\tp->tcam_num_entries = NIU_NONPCI_TCAM_ENTRIES;\n\n\tfor (i = CLASS_CODE_USER_PROG1; i <= CLASS_CODE_SCTP_IPV6; i++) {\n\t\tint index = i - CLASS_CODE_USER_PROG1;\n\n\t\tp->tcam_key[index] = TCAM_KEY_TSEL;\n\t\tp->flow_key[index] = (FLOW_KEY_IPSA |\n\t\t\t\t      FLOW_KEY_IPDA |\n\t\t\t\t      FLOW_KEY_PROTO |\n\t\t\t\t      (FLOW_KEY_L4_BYTE12 <<\n\t\t\t\t       FLOW_KEY_L4_0_SHIFT) |\n\t\t\t\t      (FLOW_KEY_L4_BYTE12 <<\n\t\t\t\t       FLOW_KEY_L4_1_SHIFT));\n\t}\n\n\tfor (i = 0; i < LDN_MAX + 1; i++)\n\t\tp->ldg_map[i] = LDG_INVALID;\n\n\treturn p;\n\nfail_unregister:\n\tplatform_device_unregister(plat_dev);\n\treturn NULL;\n}\n\nstatic struct niu_parent *niu_get_parent(struct niu *np,\n\t\t\t\t\t union niu_parent_id *id, u8 ptype)\n{\n\tstruct niu_parent *p, *tmp;\n\tint port = np->port;\n\n\tmutex_lock(&niu_parent_lock);\n\tp = NULL;\n\tlist_for_each_entry(tmp, &niu_parent_list, list) {\n\t\tif (!memcmp(id, &tmp->id, sizeof(*id))) {\n\t\t\tp = tmp;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!p)\n\t\tp = niu_new_parent(np, id, ptype);\n\n\tif (p) {\n\t\tchar port_name[8];\n\t\tint err;\n\n\t\tsprintf(port_name, \"port%d\", port);\n\t\terr = sysfs_create_link(&p->plat_dev->dev.kobj,\n\t\t\t\t\t&np->device->kobj,\n\t\t\t\t\tport_name);\n\t\tif (!err) {\n\t\t\tp->ports[port] = np;\n\t\t\tatomic_inc(&p->refcnt);\n\t\t}\n\t}\n\tmutex_unlock(&niu_parent_lock);\n\n\treturn p;\n}\n\nstatic void niu_put_parent(struct niu *np)\n{\n\tstruct niu_parent *p = np->parent;\n\tu8 port = np->port;\n\tchar port_name[8];\n\n\tBUG_ON(!p || p->ports[port] != np);\n\n\tnetif_printk(np, probe, KERN_DEBUG, np->dev,\n\t\t     \"%s() port[%u]\\n\", __func__, port);\n\n\tsprintf(port_name, \"port%d\", port);\n\n\tmutex_lock(&niu_parent_lock);\n\n\tsysfs_remove_link(&p->plat_dev->dev.kobj, port_name);\n\n\tp->ports[port] = NULL;\n\tnp->parent = NULL;\n\n\tif (atomic_dec_and_test(&p->refcnt)) {\n\t\tlist_del(&p->list);\n\t\tplatform_device_unregister(p->plat_dev);\n\t}\n\n\tmutex_unlock(&niu_parent_lock);\n}\n\nstatic void *niu_pci_alloc_coherent(struct device *dev, size_t size,\n\t\t\t\t    u64 *handle, gfp_t flag)\n{\n\tdma_addr_t dh;\n\tvoid *ret;\n\n\tret = dma_alloc_coherent(dev, size, &dh, flag);\n\tif (ret)\n\t\t*handle = dh;\n\treturn ret;\n}\n\nstatic void niu_pci_free_coherent(struct device *dev, size_t size,\n\t\t\t\t  void *cpu_addr, u64 handle)\n{\n\tdma_free_coherent(dev, size, cpu_addr, handle);\n}\n\nstatic u64 niu_pci_map_page(struct device *dev, struct page *page,\n\t\t\t    unsigned long offset, size_t size,\n\t\t\t    enum dma_data_direction direction)\n{\n\treturn dma_map_page(dev, page, offset, size, direction);\n}\n\nstatic void niu_pci_unmap_page(struct device *dev, u64 dma_address,\n\t\t\t       size_t size, enum dma_data_direction direction)\n{\n\tdma_unmap_page(dev, dma_address, size, direction);\n}\n\nstatic u64 niu_pci_map_single(struct device *dev, void *cpu_addr,\n\t\t\t      size_t size,\n\t\t\t      enum dma_data_direction direction)\n{\n\treturn dma_map_single(dev, cpu_addr, size, direction);\n}\n\nstatic void niu_pci_unmap_single(struct device *dev, u64 dma_address,\n\t\t\t\t size_t size,\n\t\t\t\t enum dma_data_direction direction)\n{\n\tdma_unmap_single(dev, dma_address, size, direction);\n}\n\nstatic const struct niu_ops niu_pci_ops = {\n\t.alloc_coherent\t= niu_pci_alloc_coherent,\n\t.free_coherent\t= niu_pci_free_coherent,\n\t.map_page\t= niu_pci_map_page,\n\t.unmap_page\t= niu_pci_unmap_page,\n\t.map_single\t= niu_pci_map_single,\n\t.unmap_single\t= niu_pci_unmap_single,\n};\n\nstatic void niu_driver_version(void)\n{\n\tstatic int niu_version_printed;\n\n\tif (niu_version_printed++ == 0)\n\t\tpr_info(\"%s\", version);\n}\n\nstatic struct net_device *niu_alloc_and_init(struct device *gen_dev,\n\t\t\t\t\t     struct pci_dev *pdev,\n\t\t\t\t\t     struct platform_device *op,\n\t\t\t\t\t     const struct niu_ops *ops, u8 port)\n{\n\tstruct net_device *dev;\n\tstruct niu *np;\n\n\tdev = alloc_etherdev_mq(sizeof(struct niu), NIU_NUM_TXCHAN);\n\tif (!dev)\n\t\treturn NULL;\n\n\tSET_NETDEV_DEV(dev, gen_dev);\n\n\tnp = netdev_priv(dev);\n\tnp->dev = dev;\n\tnp->pdev = pdev;\n\tnp->op = op;\n\tnp->device = gen_dev;\n\tnp->ops = ops;\n\n\tnp->msg_enable = niu_debug;\n\n\tspin_lock_init(&np->lock);\n\tINIT_WORK(&np->reset_task, niu_reset_task);\n\n\tnp->port = port;\n\n\treturn dev;\n}\n\nstatic const struct net_device_ops niu_netdev_ops = {\n\t.ndo_open\t\t= niu_open,\n\t.ndo_stop\t\t= niu_close,\n\t.ndo_start_xmit\t\t= niu_start_xmit,\n\t.ndo_get_stats64\t= niu_get_stats,\n\t.ndo_set_rx_mode\t= niu_set_rx_mode,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_set_mac_address\t= niu_set_mac_addr,\n\t.ndo_eth_ioctl\t\t= niu_ioctl,\n\t.ndo_tx_timeout\t\t= niu_tx_timeout,\n\t.ndo_change_mtu\t\t= niu_change_mtu,\n};\n\nstatic void niu_assign_netdev_ops(struct net_device *dev)\n{\n\tdev->netdev_ops = &niu_netdev_ops;\n\tdev->ethtool_ops = &niu_ethtool_ops;\n\tdev->watchdog_timeo = NIU_TX_TIMEOUT;\n}\n\nstatic void niu_device_announce(struct niu *np)\n{\n\tstruct net_device *dev = np->dev;\n\n\tpr_info(\"%s: NIU Ethernet %pM\\n\", dev->name, dev->dev_addr);\n\n\tif (np->parent->plat_type == PLAT_TYPE_ATCA_CP3220) {\n\t\tpr_info(\"%s: Port type[%s] mode[%s:%s] XCVR[%s] phy[%s]\\n\",\n\t\t\t\tdev->name,\n\t\t\t\t(np->flags & NIU_FLAGS_XMAC ? \"XMAC\" : \"BMAC\"),\n\t\t\t\t(np->flags & NIU_FLAGS_10G ? \"10G\" : \"1G\"),\n\t\t\t\t(np->flags & NIU_FLAGS_FIBER ? \"RGMII FIBER\" : \"SERDES\"),\n\t\t\t\t(np->mac_xcvr == MAC_XCVR_MII ? \"MII\" :\n\t\t\t\t (np->mac_xcvr == MAC_XCVR_PCS ? \"PCS\" : \"XPCS\")),\n\t\t\t\tnp->vpd.phy_type);\n\t} else {\n\t\tpr_info(\"%s: Port type[%s] mode[%s:%s] XCVR[%s] phy[%s]\\n\",\n\t\t\t\tdev->name,\n\t\t\t\t(np->flags & NIU_FLAGS_XMAC ? \"XMAC\" : \"BMAC\"),\n\t\t\t\t(np->flags & NIU_FLAGS_10G ? \"10G\" : \"1G\"),\n\t\t\t\t(np->flags & NIU_FLAGS_FIBER ? \"FIBER\" :\n\t\t\t\t (np->flags & NIU_FLAGS_XCVR_SERDES ? \"SERDES\" :\n\t\t\t\t  \"COPPER\")),\n\t\t\t\t(np->mac_xcvr == MAC_XCVR_MII ? \"MII\" :\n\t\t\t\t (np->mac_xcvr == MAC_XCVR_PCS ? \"PCS\" : \"XPCS\")),\n\t\t\t\tnp->vpd.phy_type);\n\t}\n}\n\nstatic void niu_set_basic_features(struct net_device *dev)\n{\n\tdev->hw_features = NETIF_F_SG | NETIF_F_HW_CSUM | NETIF_F_RXHASH;\n\tdev->features |= dev->hw_features | NETIF_F_RXCSUM;\n}\n\nstatic int niu_pci_init_one(struct pci_dev *pdev,\n\t\t\t    const struct pci_device_id *ent)\n{\n\tunion niu_parent_id parent_id;\n\tstruct net_device *dev;\n\tstruct niu *np;\n\tint err;\n\n\tniu_driver_version();\n\n\terr = pci_enable_device(pdev);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Cannot enable PCI device, aborting\\n\");\n\t\treturn err;\n\t}\n\n\tif (!(pci_resource_flags(pdev, 0) & IORESOURCE_MEM) ||\n\t    !(pci_resource_flags(pdev, 2) & IORESOURCE_MEM)) {\n\t\tdev_err(&pdev->dev, \"Cannot find proper PCI device base addresses, aborting\\n\");\n\t\terr = -ENODEV;\n\t\tgoto err_out_disable_pdev;\n\t}\n\n\terr = pci_request_regions(pdev, DRV_MODULE_NAME);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Cannot obtain PCI resources, aborting\\n\");\n\t\tgoto err_out_disable_pdev;\n\t}\n\n\tif (!pci_is_pcie(pdev)) {\n\t\tdev_err(&pdev->dev, \"Cannot find PCI Express capability, aborting\\n\");\n\t\terr = -ENODEV;\n\t\tgoto err_out_free_res;\n\t}\n\n\tdev = niu_alloc_and_init(&pdev->dev, pdev, NULL,\n\t\t\t\t &niu_pci_ops, PCI_FUNC(pdev->devfn));\n\tif (!dev) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out_free_res;\n\t}\n\tnp = netdev_priv(dev);\n\n\tmemset(&parent_id, 0, sizeof(parent_id));\n\tparent_id.pci.domain = pci_domain_nr(pdev->bus);\n\tparent_id.pci.bus = pdev->bus->number;\n\tparent_id.pci.device = PCI_SLOT(pdev->devfn);\n\n\tnp->parent = niu_get_parent(np, &parent_id,\n\t\t\t\t    PLAT_TYPE_ATLAS);\n\tif (!np->parent) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out_free_dev;\n\t}\n\n\tpcie_capability_clear_and_set_word(pdev, PCI_EXP_DEVCTL,\n\t\tPCI_EXP_DEVCTL_NOSNOOP_EN,\n\t\tPCI_EXP_DEVCTL_CERE | PCI_EXP_DEVCTL_NFERE |\n\t\tPCI_EXP_DEVCTL_FERE | PCI_EXP_DEVCTL_URRE |\n\t\tPCI_EXP_DEVCTL_RELAX_EN);\n\n\terr = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(44));\n\tif (!err)\n\t\tdev->features |= NETIF_F_HIGHDMA;\n\tif (err) {\n\t\terr = dma_set_mask(&pdev->dev, DMA_BIT_MASK(32));\n\t\tif (err) {\n\t\t\tdev_err(&pdev->dev, \"No usable DMA configuration, aborting\\n\");\n\t\t\tgoto err_out_release_parent;\n\t\t}\n\t}\n\n\tniu_set_basic_features(dev);\n\n\tdev->priv_flags |= IFF_UNICAST_FLT;\n\n\tnp->regs = pci_ioremap_bar(pdev, 0);\n\tif (!np->regs) {\n\t\tdev_err(&pdev->dev, \"Cannot map device registers, aborting\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto err_out_release_parent;\n\t}\n\n\tpci_set_master(pdev);\n\tpci_save_state(pdev);\n\n\tdev->irq = pdev->irq;\n\n\t \n\tdev->min_mtu = ETH_MIN_MTU;\n\tdev->max_mtu = NIU_MAX_MTU;\n\n\tniu_assign_netdev_ops(dev);\n\n\terr = niu_get_invariants(np);\n\tif (err) {\n\t\tif (err != -ENODEV)\n\t\t\tdev_err(&pdev->dev, \"Problem fetching invariants of chip, aborting\\n\");\n\t\tgoto err_out_iounmap;\n\t}\n\n\terr = register_netdev(dev);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Cannot register net device, aborting\\n\");\n\t\tgoto err_out_iounmap;\n\t}\n\n\tpci_set_drvdata(pdev, dev);\n\n\tniu_device_announce(np);\n\n\treturn 0;\n\nerr_out_iounmap:\n\tif (np->regs) {\n\t\tiounmap(np->regs);\n\t\tnp->regs = NULL;\n\t}\n\nerr_out_release_parent:\n\tniu_put_parent(np);\n\nerr_out_free_dev:\n\tfree_netdev(dev);\n\nerr_out_free_res:\n\tpci_release_regions(pdev);\n\nerr_out_disable_pdev:\n\tpci_disable_device(pdev);\n\n\treturn err;\n}\n\nstatic void niu_pci_remove_one(struct pci_dev *pdev)\n{\n\tstruct net_device *dev = pci_get_drvdata(pdev);\n\n\tif (dev) {\n\t\tstruct niu *np = netdev_priv(dev);\n\n\t\tunregister_netdev(dev);\n\t\tif (np->regs) {\n\t\t\tiounmap(np->regs);\n\t\t\tnp->regs = NULL;\n\t\t}\n\n\t\tniu_ldg_free(np);\n\n\t\tniu_put_parent(np);\n\n\t\tfree_netdev(dev);\n\t\tpci_release_regions(pdev);\n\t\tpci_disable_device(pdev);\n\t}\n}\n\nstatic int __maybe_unused niu_suspend(struct device *dev_d)\n{\n\tstruct net_device *dev = dev_get_drvdata(dev_d);\n\tstruct niu *np = netdev_priv(dev);\n\tunsigned long flags;\n\n\tif (!netif_running(dev))\n\t\treturn 0;\n\n\tflush_work(&np->reset_task);\n\tniu_netif_stop(np);\n\n\tdel_timer_sync(&np->timer);\n\n\tspin_lock_irqsave(&np->lock, flags);\n\tniu_enable_interrupts(np, 0);\n\tspin_unlock_irqrestore(&np->lock, flags);\n\n\tnetif_device_detach(dev);\n\n\tspin_lock_irqsave(&np->lock, flags);\n\tniu_stop_hw(np);\n\tspin_unlock_irqrestore(&np->lock, flags);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused niu_resume(struct device *dev_d)\n{\n\tstruct net_device *dev = dev_get_drvdata(dev_d);\n\tstruct niu *np = netdev_priv(dev);\n\tunsigned long flags;\n\tint err;\n\n\tif (!netif_running(dev))\n\t\treturn 0;\n\n\tnetif_device_attach(dev);\n\n\tspin_lock_irqsave(&np->lock, flags);\n\n\terr = niu_init_hw(np);\n\tif (!err) {\n\t\tnp->timer.expires = jiffies + HZ;\n\t\tadd_timer(&np->timer);\n\t\tniu_netif_start(np);\n\t}\n\n\tspin_unlock_irqrestore(&np->lock, flags);\n\n\treturn err;\n}\n\nstatic SIMPLE_DEV_PM_OPS(niu_pm_ops, niu_suspend, niu_resume);\n\nstatic struct pci_driver niu_pci_driver = {\n\t.name\t\t= DRV_MODULE_NAME,\n\t.id_table\t= niu_pci_tbl,\n\t.probe\t\t= niu_pci_init_one,\n\t.remove\t\t= niu_pci_remove_one,\n\t.driver.pm\t= &niu_pm_ops,\n};\n\n#ifdef CONFIG_SPARC64\nstatic void *niu_phys_alloc_coherent(struct device *dev, size_t size,\n\t\t\t\t     u64 *dma_addr, gfp_t flag)\n{\n\tunsigned long order = get_order(size);\n\tunsigned long page = __get_free_pages(flag, order);\n\n\tif (page == 0UL)\n\t\treturn NULL;\n\tmemset((char *)page, 0, PAGE_SIZE << order);\n\t*dma_addr = __pa(page);\n\n\treturn (void *) page;\n}\n\nstatic void niu_phys_free_coherent(struct device *dev, size_t size,\n\t\t\t\t   void *cpu_addr, u64 handle)\n{\n\tunsigned long order = get_order(size);\n\n\tfree_pages((unsigned long) cpu_addr, order);\n}\n\nstatic u64 niu_phys_map_page(struct device *dev, struct page *page,\n\t\t\t     unsigned long offset, size_t size,\n\t\t\t     enum dma_data_direction direction)\n{\n\treturn page_to_phys(page) + offset;\n}\n\nstatic void niu_phys_unmap_page(struct device *dev, u64 dma_address,\n\t\t\t\tsize_t size, enum dma_data_direction direction)\n{\n\t \n}\n\nstatic u64 niu_phys_map_single(struct device *dev, void *cpu_addr,\n\t\t\t       size_t size,\n\t\t\t       enum dma_data_direction direction)\n{\n\treturn __pa(cpu_addr);\n}\n\nstatic void niu_phys_unmap_single(struct device *dev, u64 dma_address,\n\t\t\t\t  size_t size,\n\t\t\t\t  enum dma_data_direction direction)\n{\n\t \n}\n\nstatic const struct niu_ops niu_phys_ops = {\n\t.alloc_coherent\t= niu_phys_alloc_coherent,\n\t.free_coherent\t= niu_phys_free_coherent,\n\t.map_page\t= niu_phys_map_page,\n\t.unmap_page\t= niu_phys_unmap_page,\n\t.map_single\t= niu_phys_map_single,\n\t.unmap_single\t= niu_phys_unmap_single,\n};\n\nstatic int niu_of_probe(struct platform_device *op)\n{\n\tunion niu_parent_id parent_id;\n\tstruct net_device *dev;\n\tstruct niu *np;\n\tconst u32 *reg;\n\tint err;\n\n\tniu_driver_version();\n\n\treg = of_get_property(op->dev.of_node, \"reg\", NULL);\n\tif (!reg) {\n\t\tdev_err(&op->dev, \"%pOF: No 'reg' property, aborting\\n\",\n\t\t\top->dev.of_node);\n\t\treturn -ENODEV;\n\t}\n\n\tdev = niu_alloc_and_init(&op->dev, NULL, op,\n\t\t\t\t &niu_phys_ops, reg[0] & 0x1);\n\tif (!dev) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\tnp = netdev_priv(dev);\n\n\tmemset(&parent_id, 0, sizeof(parent_id));\n\tparent_id.of = of_get_parent(op->dev.of_node);\n\n\tnp->parent = niu_get_parent(np, &parent_id,\n\t\t\t\t    PLAT_TYPE_NIU);\n\tif (!np->parent) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out_free_dev;\n\t}\n\n\tniu_set_basic_features(dev);\n\n\tnp->regs = of_ioremap(&op->resource[1], 0,\n\t\t\t      resource_size(&op->resource[1]),\n\t\t\t      \"niu regs\");\n\tif (!np->regs) {\n\t\tdev_err(&op->dev, \"Cannot map device registers, aborting\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto err_out_release_parent;\n\t}\n\n\tnp->vir_regs_1 = of_ioremap(&op->resource[2], 0,\n\t\t\t\t    resource_size(&op->resource[2]),\n\t\t\t\t    \"niu vregs-1\");\n\tif (!np->vir_regs_1) {\n\t\tdev_err(&op->dev, \"Cannot map device vir registers 1, aborting\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto err_out_iounmap;\n\t}\n\n\tnp->vir_regs_2 = of_ioremap(&op->resource[3], 0,\n\t\t\t\t    resource_size(&op->resource[3]),\n\t\t\t\t    \"niu vregs-2\");\n\tif (!np->vir_regs_2) {\n\t\tdev_err(&op->dev, \"Cannot map device vir registers 2, aborting\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto err_out_iounmap;\n\t}\n\n\tniu_assign_netdev_ops(dev);\n\n\terr = niu_get_invariants(np);\n\tif (err) {\n\t\tif (err != -ENODEV)\n\t\t\tdev_err(&op->dev, \"Problem fetching invariants of chip, aborting\\n\");\n\t\tgoto err_out_iounmap;\n\t}\n\n\terr = register_netdev(dev);\n\tif (err) {\n\t\tdev_err(&op->dev, \"Cannot register net device, aborting\\n\");\n\t\tgoto err_out_iounmap;\n\t}\n\n\tplatform_set_drvdata(op, dev);\n\n\tniu_device_announce(np);\n\n\treturn 0;\n\nerr_out_iounmap:\n\tif (np->vir_regs_1) {\n\t\tof_iounmap(&op->resource[2], np->vir_regs_1,\n\t\t\t   resource_size(&op->resource[2]));\n\t\tnp->vir_regs_1 = NULL;\n\t}\n\n\tif (np->vir_regs_2) {\n\t\tof_iounmap(&op->resource[3], np->vir_regs_2,\n\t\t\t   resource_size(&op->resource[3]));\n\t\tnp->vir_regs_2 = NULL;\n\t}\n\n\tif (np->regs) {\n\t\tof_iounmap(&op->resource[1], np->regs,\n\t\t\t   resource_size(&op->resource[1]));\n\t\tnp->regs = NULL;\n\t}\n\nerr_out_release_parent:\n\tniu_put_parent(np);\n\nerr_out_free_dev:\n\tfree_netdev(dev);\n\nerr_out:\n\treturn err;\n}\n\nstatic int niu_of_remove(struct platform_device *op)\n{\n\tstruct net_device *dev = platform_get_drvdata(op);\n\n\tif (dev) {\n\t\tstruct niu *np = netdev_priv(dev);\n\n\t\tunregister_netdev(dev);\n\n\t\tif (np->vir_regs_1) {\n\t\t\tof_iounmap(&op->resource[2], np->vir_regs_1,\n\t\t\t\t   resource_size(&op->resource[2]));\n\t\t\tnp->vir_regs_1 = NULL;\n\t\t}\n\n\t\tif (np->vir_regs_2) {\n\t\t\tof_iounmap(&op->resource[3], np->vir_regs_2,\n\t\t\t\t   resource_size(&op->resource[3]));\n\t\t\tnp->vir_regs_2 = NULL;\n\t\t}\n\n\t\tif (np->regs) {\n\t\t\tof_iounmap(&op->resource[1], np->regs,\n\t\t\t\t   resource_size(&op->resource[1]));\n\t\t\tnp->regs = NULL;\n\t\t}\n\n\t\tniu_ldg_free(np);\n\n\t\tniu_put_parent(np);\n\n\t\tfree_netdev(dev);\n\t}\n\treturn 0;\n}\n\nstatic const struct of_device_id niu_match[] = {\n\t{\n\t\t.name = \"network\",\n\t\t.compatible = \"SUNW,niusl\",\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, niu_match);\n\nstatic struct platform_driver niu_of_driver = {\n\t.driver = {\n\t\t.name = \"niu\",\n\t\t.of_match_table = niu_match,\n\t},\n\t.probe\t\t= niu_of_probe,\n\t.remove\t\t= niu_of_remove,\n};\n\n#endif  \n\nstatic int __init niu_init(void)\n{\n\tint err = 0;\n\n\tBUILD_BUG_ON(PAGE_SIZE < 4 * 1024);\n\n\tBUILD_BUG_ON(offsetof(struct page, mapping) !=\n\t\t     offsetof(union niu_page, next));\n\n\tniu_debug = netif_msg_init(debug, NIU_MSG_DEFAULT);\n\n#ifdef CONFIG_SPARC64\n\terr = platform_driver_register(&niu_of_driver);\n#endif\n\n\tif (!err) {\n\t\terr = pci_register_driver(&niu_pci_driver);\n#ifdef CONFIG_SPARC64\n\t\tif (err)\n\t\t\tplatform_driver_unregister(&niu_of_driver);\n#endif\n\t}\n\n\treturn err;\n}\n\nstatic void __exit niu_exit(void)\n{\n\tpci_unregister_driver(&niu_pci_driver);\n#ifdef CONFIG_SPARC64\n\tplatform_driver_unregister(&niu_of_driver);\n#endif\n}\n\nmodule_init(niu_init);\nmodule_exit(niu_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}