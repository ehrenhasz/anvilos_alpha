{
  "module_name": "sunqe.c",
  "hash_id": "da40ca0c3b77df872ae2c018ee96919c95f7c78f40440aa515354aa533eae20f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/sun/sunqe.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/errno.h>\n#include <linux/fcntl.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/in.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/crc32.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/skbuff.h>\n#include <linux/ethtool.h>\n#include <linux/bitops.h>\n#include <linux/dma-mapping.h>\n#include <linux/of.h>\n#include <linux/pgtable.h>\n#include <linux/platform_device.h>\n\n#include <asm/io.h>\n#include <asm/dma.h>\n#include <asm/byteorder.h>\n#include <asm/idprom.h>\n#include <asm/openprom.h>\n#include <asm/oplib.h>\n#include <asm/auxio.h>\n#include <asm/irq.h>\n\n#include \"sunqe.h\"\n\n#define DRV_NAME\t\"sunqe\"\n#define DRV_VERSION\t\"4.1\"\n#define DRV_RELDATE\t\"August 27, 2008\"\n#define DRV_AUTHOR\t\"David S. Miller (davem@davemloft.net)\"\n\nstatic char version[] =\n\tDRV_NAME \".c:v\" DRV_VERSION \" \" DRV_RELDATE \" \" DRV_AUTHOR \"\\n\";\n\nMODULE_VERSION(DRV_VERSION);\nMODULE_AUTHOR(DRV_AUTHOR);\nMODULE_DESCRIPTION(\"Sun QuadEthernet 10baseT SBUS card driver\");\nMODULE_LICENSE(\"GPL\");\n\nstatic struct sunqec *root_qec_dev;\n\nstatic void qe_set_multicast(struct net_device *dev);\n\n#define QEC_RESET_TRIES 200\n\nstatic inline int qec_global_reset(void __iomem *gregs)\n{\n\tint tries = QEC_RESET_TRIES;\n\n\tsbus_writel(GLOB_CTRL_RESET, gregs + GLOB_CTRL);\n\twhile (--tries) {\n\t\tu32 tmp = sbus_readl(gregs + GLOB_CTRL);\n\t\tif (tmp & GLOB_CTRL_RESET) {\n\t\t\tudelay(20);\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\tif (tries)\n\t\treturn 0;\n\tprintk(KERN_ERR \"QuadEther: AIEEE cannot reset the QEC!\\n\");\n\treturn -1;\n}\n\n#define MACE_RESET_RETRIES 200\n#define QE_RESET_RETRIES   200\n\nstatic inline int qe_stop(struct sunqe *qep)\n{\n\tvoid __iomem *cregs = qep->qcregs;\n\tvoid __iomem *mregs = qep->mregs;\n\tint tries;\n\n\t \n\tsbus_writeb(MREGS_BCONFIG_RESET, mregs + MREGS_BCONFIG);\n\ttries = MACE_RESET_RETRIES;\n\twhile (--tries) {\n\t\tu8 tmp = sbus_readb(mregs + MREGS_BCONFIG);\n\t\tif (tmp & MREGS_BCONFIG_RESET) {\n\t\t\tudelay(20);\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\tif (!tries) {\n\t\tprintk(KERN_ERR \"QuadEther: AIEEE cannot reset the MACE!\\n\");\n\t\treturn -1;\n\t}\n\n\tsbus_writel(CREG_CTRL_RESET, cregs + CREG_CTRL);\n\ttries = QE_RESET_RETRIES;\n\twhile (--tries) {\n\t\tu32 tmp = sbus_readl(cregs + CREG_CTRL);\n\t\tif (tmp & CREG_CTRL_RESET) {\n\t\t\tudelay(20);\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\tif (!tries) {\n\t\tprintk(KERN_ERR \"QuadEther: Cannot reset QE channel!\\n\");\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic void qe_init_rings(struct sunqe *qep)\n{\n\tstruct qe_init_block *qb = qep->qe_block;\n\tstruct sunqe_buffers *qbufs = qep->buffers;\n\t__u32 qbufs_dvma = (__u32)qep->buffers_dvma;\n\tint i;\n\n\tqep->rx_new = qep->rx_old = qep->tx_new = qep->tx_old = 0;\n\tmemset(qb, 0, sizeof(struct qe_init_block));\n\tmemset(qbufs, 0, sizeof(struct sunqe_buffers));\n\tfor (i = 0; i < RX_RING_SIZE; i++) {\n\t\tqb->qe_rxd[i].rx_addr = qbufs_dvma + qebuf_offset(rx_buf, i);\n\t\tqb->qe_rxd[i].rx_flags =\n\t\t\t(RXD_OWN | ((RXD_PKT_SZ) & RXD_LENGTH));\n\t}\n}\n\nstatic int qe_init(struct sunqe *qep, int from_irq)\n{\n\tstruct sunqec *qecp = qep->parent;\n\tvoid __iomem *cregs = qep->qcregs;\n\tvoid __iomem *mregs = qep->mregs;\n\tvoid __iomem *gregs = qecp->gregs;\n\tconst unsigned char *e = &qep->dev->dev_addr[0];\n\t__u32 qblk_dvma = (__u32)qep->qblock_dvma;\n\tu32 tmp;\n\tint i;\n\n\t \n\tif (qe_stop(qep))\n\t\treturn -EAGAIN;\n\n\t \n\tsbus_writel(qblk_dvma + qib_offset(qe_rxd, 0), cregs + CREG_RXDS);\n\tsbus_writel(qblk_dvma + qib_offset(qe_txd, 0), cregs + CREG_TXDS);\n\n\t \n\tsbus_writel(0, cregs + CREG_RIMASK);\n\tsbus_writel(1, cregs + CREG_TIMASK);\n\n\tsbus_writel(0, cregs + CREG_QMASK);\n\tsbus_writel(CREG_MMASK_RXCOLL, cregs + CREG_MMASK);\n\n\t \n\ttmp = qep->channel * sbus_readl(gregs + GLOB_MSIZE);\n\tsbus_writel(tmp, cregs + CREG_RXRBUFPTR);\n\tsbus_writel(tmp, cregs + CREG_RXWBUFPTR);\n\n\ttmp = sbus_readl(cregs + CREG_RXRBUFPTR) +\n\t\tsbus_readl(gregs + GLOB_RSIZE);\n\tsbus_writel(tmp, cregs + CREG_TXRBUFPTR);\n\tsbus_writel(tmp, cregs + CREG_TXWBUFPTR);\n\n\t \n\tsbus_writel(0, cregs + CREG_CCNT);\n\n\t \n\tsbus_writel(0, cregs + CREG_PIPG);\n\n\t \n\tsbus_writeb(MREGS_PHYCONFIG_AUTO, mregs + MREGS_PHYCONFIG);\n\tsbus_writeb(MREGS_TXFCNTL_AUTOPAD, mregs + MREGS_TXFCNTL);\n\tsbus_writeb(0, mregs + MREGS_RXFCNTL);\n\n\t \n\tsbus_writeb(MREGS_IMASK_COLL | MREGS_IMASK_RXIRQ, mregs + MREGS_IMASK);\n\tsbus_writeb(MREGS_BCONFIG_BSWAP | MREGS_BCONFIG_64TS, mregs + MREGS_BCONFIG);\n\tsbus_writeb((MREGS_FCONFIG_TXF16 | MREGS_FCONFIG_RXF32 |\n\t\t     MREGS_FCONFIG_RFWU | MREGS_FCONFIG_TFWU),\n\t\t    mregs + MREGS_FCONFIG);\n\n\t \n\tsbus_writeb(MREGS_PLSCONFIG_TP, mregs + MREGS_PLSCONFIG);\n\n\t \n\tsbus_writeb(MREGS_IACONFIG_ACHNGE | MREGS_IACONFIG_PARESET,\n\t\t    mregs + MREGS_IACONFIG);\n\twhile ((sbus_readb(mregs + MREGS_IACONFIG) & MREGS_IACONFIG_ACHNGE) != 0)\n\t\tbarrier();\n\tsbus_writeb(e[0], mregs + MREGS_ETHADDR);\n\tsbus_writeb(e[1], mregs + MREGS_ETHADDR);\n\tsbus_writeb(e[2], mregs + MREGS_ETHADDR);\n\tsbus_writeb(e[3], mregs + MREGS_ETHADDR);\n\tsbus_writeb(e[4], mregs + MREGS_ETHADDR);\n\tsbus_writeb(e[5], mregs + MREGS_ETHADDR);\n\n\t \n\tsbus_writeb(MREGS_IACONFIG_ACHNGE | MREGS_IACONFIG_LARESET,\n\t\t    mregs + MREGS_IACONFIG);\n\twhile ((sbus_readb(mregs + MREGS_IACONFIG) & MREGS_IACONFIG_ACHNGE) != 0)\n\t\tbarrier();\n\tfor (i = 0; i < 8; i++)\n\t\tsbus_writeb(0, mregs + MREGS_FILTER);\n\n\t \n\tsbus_writeb(0, mregs + MREGS_IACONFIG);\n\n\tqe_init_rings(qep);\n\n\t \n\tmdelay(5);\n\tif (!(sbus_readb(mregs + MREGS_PHYCONFIG) & MREGS_PHYCONFIG_LTESTDIS)) {\n\t\tint tries = 50;\n\n\t\twhile (--tries) {\n\t\t\tu8 tmp;\n\n\t\t\tmdelay(5);\n\t\t\tbarrier();\n\t\t\ttmp = sbus_readb(mregs + MREGS_PHYCONFIG);\n\t\t\tif ((tmp & MREGS_PHYCONFIG_LSTAT) != 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (tries == 0)\n\t\t\tprintk(KERN_NOTICE \"%s: Warning, link state is down.\\n\", qep->dev->name);\n\t}\n\n\t \n\tsbus_readb(mregs + MREGS_MPCNT);\n\n\t \n\tqe_set_multicast(qep->dev);\n\n\t \n\treturn 0;\n}\n\n \nstatic int qe_is_bolixed(struct sunqe *qep, u32 qe_status)\n{\n\tstruct net_device *dev = qep->dev;\n\tint mace_hwbug_workaround = 0;\n\n\tif (qe_status & CREG_STAT_EDEFER) {\n\t\tprintk(KERN_ERR \"%s: Excessive transmit defers.\\n\", dev->name);\n\t\tdev->stats.tx_errors++;\n\t}\n\n\tif (qe_status & CREG_STAT_CLOSS) {\n\t\tprintk(KERN_ERR \"%s: Carrier lost, link down?\\n\", dev->name);\n\t\tdev->stats.tx_errors++;\n\t\tdev->stats.tx_carrier_errors++;\n\t}\n\n\tif (qe_status & CREG_STAT_ERETRIES) {\n\t\tprintk(KERN_ERR \"%s: Excessive transmit retries (more than 16).\\n\", dev->name);\n\t\tdev->stats.tx_errors++;\n\t\tmace_hwbug_workaround = 1;\n\t}\n\n\tif (qe_status & CREG_STAT_LCOLL) {\n\t\tprintk(KERN_ERR \"%s: Late transmit collision.\\n\", dev->name);\n\t\tdev->stats.tx_errors++;\n\t\tdev->stats.collisions++;\n\t\tmace_hwbug_workaround = 1;\n\t}\n\n\tif (qe_status & CREG_STAT_FUFLOW) {\n\t\tprintk(KERN_ERR \"%s: Transmit fifo underflow, driver bug.\\n\", dev->name);\n\t\tdev->stats.tx_errors++;\n\t\tmace_hwbug_workaround = 1;\n\t}\n\n\tif (qe_status & CREG_STAT_JERROR) {\n\t\tprintk(KERN_ERR \"%s: Jabber error.\\n\", dev->name);\n\t}\n\n\tif (qe_status & CREG_STAT_BERROR) {\n\t\tprintk(KERN_ERR \"%s: Babble error.\\n\", dev->name);\n\t}\n\n\tif (qe_status & CREG_STAT_CCOFLOW) {\n\t\tdev->stats.tx_errors += 256;\n\t\tdev->stats.collisions += 256;\n\t}\n\n\tif (qe_status & CREG_STAT_TXDERROR) {\n\t\tprintk(KERN_ERR \"%s: Transmit descriptor is bogus, driver bug.\\n\", dev->name);\n\t\tdev->stats.tx_errors++;\n\t\tdev->stats.tx_aborted_errors++;\n\t\tmace_hwbug_workaround = 1;\n\t}\n\n\tif (qe_status & CREG_STAT_TXLERR) {\n\t\tprintk(KERN_ERR \"%s: Transmit late error.\\n\", dev->name);\n\t\tdev->stats.tx_errors++;\n\t\tmace_hwbug_workaround = 1;\n\t}\n\n\tif (qe_status & CREG_STAT_TXPERR) {\n\t\tprintk(KERN_ERR \"%s: Transmit DMA parity error.\\n\", dev->name);\n\t\tdev->stats.tx_errors++;\n\t\tdev->stats.tx_aborted_errors++;\n\t\tmace_hwbug_workaround = 1;\n\t}\n\n\tif (qe_status & CREG_STAT_TXSERR) {\n\t\tprintk(KERN_ERR \"%s: Transmit DMA sbus error ack.\\n\", dev->name);\n\t\tdev->stats.tx_errors++;\n\t\tdev->stats.tx_aborted_errors++;\n\t\tmace_hwbug_workaround = 1;\n\t}\n\n\tif (qe_status & CREG_STAT_RCCOFLOW) {\n\t\tdev->stats.rx_errors += 256;\n\t\tdev->stats.collisions += 256;\n\t}\n\n\tif (qe_status & CREG_STAT_RUOFLOW) {\n\t\tdev->stats.rx_errors += 256;\n\t\tdev->stats.rx_over_errors += 256;\n\t}\n\n\tif (qe_status & CREG_STAT_MCOFLOW) {\n\t\tdev->stats.rx_errors += 256;\n\t\tdev->stats.rx_missed_errors += 256;\n\t}\n\n\tif (qe_status & CREG_STAT_RXFOFLOW) {\n\t\tprintk(KERN_ERR \"%s: Receive fifo overflow.\\n\", dev->name);\n\t\tdev->stats.rx_errors++;\n\t\tdev->stats.rx_over_errors++;\n\t}\n\n\tif (qe_status & CREG_STAT_RLCOLL) {\n\t\tprintk(KERN_ERR \"%s: Late receive collision.\\n\", dev->name);\n\t\tdev->stats.rx_errors++;\n\t\tdev->stats.collisions++;\n\t}\n\n\tif (qe_status & CREG_STAT_FCOFLOW) {\n\t\tdev->stats.rx_errors += 256;\n\t\tdev->stats.rx_frame_errors += 256;\n\t}\n\n\tif (qe_status & CREG_STAT_CECOFLOW) {\n\t\tdev->stats.rx_errors += 256;\n\t\tdev->stats.rx_crc_errors += 256;\n\t}\n\n\tif (qe_status & CREG_STAT_RXDROP) {\n\t\tprintk(KERN_ERR \"%s: Receive packet dropped.\\n\", dev->name);\n\t\tdev->stats.rx_errors++;\n\t\tdev->stats.rx_dropped++;\n\t\tdev->stats.rx_missed_errors++;\n\t}\n\n\tif (qe_status & CREG_STAT_RXSMALL) {\n\t\tprintk(KERN_ERR \"%s: Receive buffer too small, driver bug.\\n\", dev->name);\n\t\tdev->stats.rx_errors++;\n\t\tdev->stats.rx_length_errors++;\n\t}\n\n\tif (qe_status & CREG_STAT_RXLERR) {\n\t\tprintk(KERN_ERR \"%s: Receive late error.\\n\", dev->name);\n\t\tdev->stats.rx_errors++;\n\t\tmace_hwbug_workaround = 1;\n\t}\n\n\tif (qe_status & CREG_STAT_RXPERR) {\n\t\tprintk(KERN_ERR \"%s: Receive DMA parity error.\\n\", dev->name);\n\t\tdev->stats.rx_errors++;\n\t\tdev->stats.rx_missed_errors++;\n\t\tmace_hwbug_workaround = 1;\n\t}\n\n\tif (qe_status & CREG_STAT_RXSERR) {\n\t\tprintk(KERN_ERR \"%s: Receive DMA sbus error ack.\\n\", dev->name);\n\t\tdev->stats.rx_errors++;\n\t\tdev->stats.rx_missed_errors++;\n\t\tmace_hwbug_workaround = 1;\n\t}\n\n\tif (mace_hwbug_workaround)\n\t\tqe_init(qep, 1);\n\treturn mace_hwbug_workaround;\n}\n\n \nstatic void qe_rx(struct sunqe *qep)\n{\n\tstruct qe_rxd *rxbase = &qep->qe_block->qe_rxd[0];\n\tstruct net_device *dev = qep->dev;\n\tstruct qe_rxd *this;\n\tstruct sunqe_buffers *qbufs = qep->buffers;\n\t__u32 qbufs_dvma = (__u32)qep->buffers_dvma;\n\tint elem = qep->rx_new;\n\tu32 flags;\n\n\tthis = &rxbase[elem];\n\twhile (!((flags = this->rx_flags) & RXD_OWN)) {\n\t\tstruct sk_buff *skb;\n\t\tunsigned char *this_qbuf =\n\t\t\t&qbufs->rx_buf[elem & (RX_RING_SIZE - 1)][0];\n\t\t__u32 this_qbuf_dvma = qbufs_dvma +\n\t\t\tqebuf_offset(rx_buf, (elem & (RX_RING_SIZE - 1)));\n\t\tstruct qe_rxd *end_rxd =\n\t\t\t&rxbase[(elem+RX_RING_SIZE)&(RX_RING_MAXSIZE-1)];\n\t\tint len = (flags & RXD_LENGTH) - 4;   \n\n\t\t \n\t\tif (len < ETH_ZLEN) {\n\t\t\tdev->stats.rx_errors++;\n\t\t\tdev->stats.rx_length_errors++;\n\t\t\tdev->stats.rx_dropped++;\n\t\t} else {\n\t\t\tskb = netdev_alloc_skb(dev, len + 2);\n\t\t\tif (skb == NULL) {\n\t\t\t\tdev->stats.rx_dropped++;\n\t\t\t} else {\n\t\t\t\tskb_reserve(skb, 2);\n\t\t\t\tskb_put(skb, len);\n\t\t\t\tskb_copy_to_linear_data(skb, this_qbuf,\n\t\t\t\t\t\t len);\n\t\t\t\tskb->protocol = eth_type_trans(skb, qep->dev);\n\t\t\t\tnetif_rx(skb);\n\t\t\t\tdev->stats.rx_packets++;\n\t\t\t\tdev->stats.rx_bytes += len;\n\t\t\t}\n\t\t}\n\t\tend_rxd->rx_addr = this_qbuf_dvma;\n\t\tend_rxd->rx_flags = (RXD_OWN | ((RXD_PKT_SZ) & RXD_LENGTH));\n\n\t\telem = NEXT_RX(elem);\n\t\tthis = &rxbase[elem];\n\t}\n\tqep->rx_new = elem;\n}\n\nstatic void qe_tx_reclaim(struct sunqe *qep);\n\n \nstatic irqreturn_t qec_interrupt(int irq, void *dev_id)\n{\n\tstruct sunqec *qecp = dev_id;\n\tu32 qec_status;\n\tint channel = 0;\n\n\t \n\tqec_status = sbus_readl(qecp->gregs + GLOB_STAT);\n\twhile (channel < 4) {\n\t\tif (qec_status & 0xf) {\n\t\t\tstruct sunqe *qep = qecp->qes[channel];\n\t\t\tu32 qe_status;\n\n\t\t\tqe_status = sbus_readl(qep->qcregs + CREG_STAT);\n\t\t\tif (qe_status & CREG_STAT_ERRORS) {\n\t\t\t\tif (qe_is_bolixed(qep, qe_status))\n\t\t\t\t\tgoto next;\n\t\t\t}\n\t\t\tif (qe_status & CREG_STAT_RXIRQ)\n\t\t\t\tqe_rx(qep);\n\t\t\tif (netif_queue_stopped(qep->dev) &&\n\t\t\t    (qe_status & CREG_STAT_TXIRQ)) {\n\t\t\t\tspin_lock(&qep->lock);\n\t\t\t\tqe_tx_reclaim(qep);\n\t\t\t\tif (TX_BUFFS_AVAIL(qep) > 0) {\n\t\t\t\t\t \n\t\t\t\t\tnetif_wake_queue(qep->dev);\n\t\t\t\t\tsbus_writel(1, qep->qcregs + CREG_TIMASK);\n\t\t\t\t}\n\t\t\t\tspin_unlock(&qep->lock);\n\t\t\t}\n\tnext:\n\t\t\t;\n\t\t}\n\t\tqec_status >>= 4;\n\t\tchannel++;\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int qe_open(struct net_device *dev)\n{\n\tstruct sunqe *qep = netdev_priv(dev);\n\n\tqep->mconfig = (MREGS_MCONFIG_TXENAB |\n\t\t\tMREGS_MCONFIG_RXENAB |\n\t\t\tMREGS_MCONFIG_MBAENAB);\n\treturn qe_init(qep, 0);\n}\n\nstatic int qe_close(struct net_device *dev)\n{\n\tstruct sunqe *qep = netdev_priv(dev);\n\n\tqe_stop(qep);\n\treturn 0;\n}\n\n \nstatic void qe_tx_reclaim(struct sunqe *qep)\n{\n\tstruct qe_txd *txbase = &qep->qe_block->qe_txd[0];\n\tint elem = qep->tx_old;\n\n\twhile (elem != qep->tx_new) {\n\t\tu32 flags = txbase[elem].tx_flags;\n\n\t\tif (flags & TXD_OWN)\n\t\t\tbreak;\n\t\telem = NEXT_TX(elem);\n\t}\n\tqep->tx_old = elem;\n}\n\nstatic void qe_tx_timeout(struct net_device *dev, unsigned int txqueue)\n{\n\tstruct sunqe *qep = netdev_priv(dev);\n\tint tx_full;\n\n\tspin_lock_irq(&qep->lock);\n\n\t \n\tqe_tx_reclaim(qep);\n\ttx_full = TX_BUFFS_AVAIL(qep) <= 0;\n\n\tspin_unlock_irq(&qep->lock);\n\n\tif (! tx_full)\n\t\tgoto out;\n\n\tprintk(KERN_ERR \"%s: transmit timed out, resetting\\n\", dev->name);\n\tqe_init(qep, 1);\n\nout:\n\tnetif_wake_queue(dev);\n}\n\n \nstatic netdev_tx_t qe_start_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct sunqe *qep = netdev_priv(dev);\n\tstruct sunqe_buffers *qbufs = qep->buffers;\n\t__u32 txbuf_dvma, qbufs_dvma = (__u32)qep->buffers_dvma;\n\tunsigned char *txbuf;\n\tint len, entry;\n\n\tspin_lock_irq(&qep->lock);\n\n\tqe_tx_reclaim(qep);\n\n\tlen = skb->len;\n\tentry = qep->tx_new;\n\n\ttxbuf = &qbufs->tx_buf[entry & (TX_RING_SIZE - 1)][0];\n\ttxbuf_dvma = qbufs_dvma +\n\t\tqebuf_offset(tx_buf, (entry & (TX_RING_SIZE - 1)));\n\n\t \n\tqep->qe_block->qe_txd[entry].tx_flags = TXD_UPDATE;\n\n\tskb_copy_from_linear_data(skb, txbuf, len);\n\n\tqep->qe_block->qe_txd[entry].tx_addr = txbuf_dvma;\n\tqep->qe_block->qe_txd[entry].tx_flags =\n\t\t(TXD_OWN | TXD_SOP | TXD_EOP | (len & TXD_LENGTH));\n\tqep->tx_new = NEXT_TX(entry);\n\n\t \n\tsbus_writel(CREG_CTRL_TWAKEUP, qep->qcregs + CREG_CTRL);\n\n\tdev->stats.tx_packets++;\n\tdev->stats.tx_bytes += len;\n\n\tif (TX_BUFFS_AVAIL(qep) <= 0) {\n\t\t \n\t\tnetif_stop_queue(dev);\n\t\tsbus_writel(0, qep->qcregs + CREG_TIMASK);\n\t}\n\tspin_unlock_irq(&qep->lock);\n\n\tdev_kfree_skb(skb);\n\n\treturn NETDEV_TX_OK;\n}\n\nstatic void qe_set_multicast(struct net_device *dev)\n{\n\tstruct sunqe *qep = netdev_priv(dev);\n\tstruct netdev_hw_addr *ha;\n\tu8 new_mconfig = qep->mconfig;\n\tint i;\n\tu32 crc;\n\n\t \n\tnetif_stop_queue(dev);\n\n\tif ((dev->flags & IFF_ALLMULTI) || (netdev_mc_count(dev) > 64)) {\n\t\tsbus_writeb(MREGS_IACONFIG_ACHNGE | MREGS_IACONFIG_LARESET,\n\t\t\t    qep->mregs + MREGS_IACONFIG);\n\t\twhile ((sbus_readb(qep->mregs + MREGS_IACONFIG) & MREGS_IACONFIG_ACHNGE) != 0)\n\t\t\tbarrier();\n\t\tfor (i = 0; i < 8; i++)\n\t\t\tsbus_writeb(0xff, qep->mregs + MREGS_FILTER);\n\t\tsbus_writeb(0, qep->mregs + MREGS_IACONFIG);\n\t} else if (dev->flags & IFF_PROMISC) {\n\t\tnew_mconfig |= MREGS_MCONFIG_PROMISC;\n\t} else {\n\t\tu16 hash_table[4];\n\t\tu8 *hbytes = (unsigned char *) &hash_table[0];\n\n\t\tmemset(hash_table, 0, sizeof(hash_table));\n\t\tnetdev_for_each_mc_addr(ha, dev) {\n\t\t\tcrc = ether_crc_le(6, ha->addr);\n\t\t\tcrc >>= 26;\n\t\t\thash_table[crc >> 4] |= 1 << (crc & 0xf);\n\t\t}\n\t\t \n\t\tsbus_writeb(MREGS_IACONFIG_ACHNGE | MREGS_IACONFIG_LARESET,\n\t\t\t    qep->mregs + MREGS_IACONFIG);\n\t\twhile ((sbus_readb(qep->mregs + MREGS_IACONFIG) & MREGS_IACONFIG_ACHNGE) != 0)\n\t\t\tbarrier();\n\t\tfor (i = 0; i < 8; i++) {\n\t\t\tu8 tmp = *hbytes++;\n\t\t\tsbus_writeb(tmp, qep->mregs + MREGS_FILTER);\n\t\t}\n\t\tsbus_writeb(0, qep->mregs + MREGS_IACONFIG);\n\t}\n\n\t \n\tqep->mconfig = new_mconfig;\n\tsbus_writeb(qep->mconfig, qep->mregs + MREGS_MCONFIG);\n\n\t \n\tnetif_wake_queue(dev);\n}\n\n \nstatic void qe_get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *info)\n{\n\tconst struct linux_prom_registers *regs;\n\tstruct sunqe *qep = netdev_priv(dev);\n\tstruct platform_device *op;\n\n\tstrscpy(info->driver, \"sunqe\", sizeof(info->driver));\n\tstrscpy(info->version, \"3.0\", sizeof(info->version));\n\n\top = qep->op;\n\tregs = of_get_property(op->dev.of_node, \"reg\", NULL);\n\tif (regs)\n\t\tsnprintf(info->bus_info, sizeof(info->bus_info), \"SBUS:%d\",\n\t\t\t regs->which_io);\n\n}\n\nstatic u32 qe_get_link(struct net_device *dev)\n{\n\tstruct sunqe *qep = netdev_priv(dev);\n\tvoid __iomem *mregs = qep->mregs;\n\tu8 phyconfig;\n\n\tspin_lock_irq(&qep->lock);\n\tphyconfig = sbus_readb(mregs + MREGS_PHYCONFIG);\n\tspin_unlock_irq(&qep->lock);\n\n\treturn phyconfig & MREGS_PHYCONFIG_LSTAT;\n}\n\nstatic const struct ethtool_ops qe_ethtool_ops = {\n\t.get_drvinfo\t\t= qe_get_drvinfo,\n\t.get_link\t\t= qe_get_link,\n};\n\n \nstatic void qec_init_once(struct sunqec *qecp, struct platform_device *op)\n{\n\tu8 bsizes = qecp->qec_bursts;\n\n\tif (sbus_can_burst64() && (bsizes & DMA_BURST64)) {\n\t\tsbus_writel(GLOB_CTRL_B64, qecp->gregs + GLOB_CTRL);\n\t} else if (bsizes & DMA_BURST32) {\n\t\tsbus_writel(GLOB_CTRL_B32, qecp->gregs + GLOB_CTRL);\n\t} else {\n\t\tsbus_writel(GLOB_CTRL_B16, qecp->gregs + GLOB_CTRL);\n\t}\n\n\t \n\tsbus_writel(GLOB_PSIZE_2048, qecp->gregs + GLOB_PSIZE);\n\n\t \n\tsbus_writel((resource_size(&op->resource[1]) >> 2),\n\t\t    qecp->gregs + GLOB_MSIZE);\n\n\t \n\tsbus_writel((resource_size(&op->resource[1]) >> 2) >> 1,\n\t\t    qecp->gregs + GLOB_TSIZE);\n\tsbus_writel((resource_size(&op->resource[1]) >> 2) >> 1,\n\t\t    qecp->gregs + GLOB_RSIZE);\n}\n\nstatic u8 qec_get_burst(struct device_node *dp)\n{\n\tu8 bsizes, bsizes_more;\n\n\t \n\tbsizes = of_getintprop_default(dp, \"burst-sizes\", 0xff);\n\tbsizes &= 0xff;\n\tbsizes_more = of_getintprop_default(dp->parent, \"burst-sizes\", 0xff);\n\n\tif (bsizes_more != 0xff)\n\t\tbsizes &= bsizes_more;\n\tif (bsizes == 0xff || (bsizes & DMA_BURST16) == 0 ||\n\t    (bsizes & DMA_BURST32)==0)\n\t\tbsizes = (DMA_BURST32 - 1);\n\n\treturn bsizes;\n}\n\nstatic struct sunqec *get_qec(struct platform_device *child)\n{\n\tstruct platform_device *op = to_platform_device(child->dev.parent);\n\tstruct sunqec *qecp;\n\n\tqecp = platform_get_drvdata(op);\n\tif (!qecp) {\n\t\tqecp = kzalloc(sizeof(struct sunqec), GFP_KERNEL);\n\t\tif (qecp) {\n\t\t\tu32 ctrl;\n\n\t\t\tqecp->op = op;\n\t\t\tqecp->gregs = of_ioremap(&op->resource[0], 0,\n\t\t\t\t\t\t GLOB_REG_SIZE,\n\t\t\t\t\t\t \"QEC Global Registers\");\n\t\t\tif (!qecp->gregs)\n\t\t\t\tgoto fail;\n\n\t\t\t \n\t\t\tctrl = sbus_readl(qecp->gregs + GLOB_CTRL);\n\t\t\tctrl &= 0xf0000000;\n\t\t\tif (ctrl != GLOB_CTRL_MMODE) {\n\t\t\t\tprintk(KERN_ERR \"qec: Not in MACE mode!\\n\");\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\tif (qec_global_reset(qecp->gregs))\n\t\t\t\tgoto fail;\n\n\t\t\tqecp->qec_bursts = qec_get_burst(op->dev.of_node);\n\n\t\t\tqec_init_once(qecp, op);\n\n\t\t\tif (request_irq(op->archdata.irqs[0], qec_interrupt,\n\t\t\t\t\tIRQF_SHARED, \"qec\", (void *) qecp)) {\n\t\t\t\tprintk(KERN_ERR \"qec: Can't register irq.\\n\");\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\tplatform_set_drvdata(op, qecp);\n\n\t\t\tqecp->next_module = root_qec_dev;\n\t\t\troot_qec_dev = qecp;\n\t\t}\n\t}\n\n\treturn qecp;\n\nfail:\n\tif (qecp->gregs)\n\t\tof_iounmap(&op->resource[0], qecp->gregs, GLOB_REG_SIZE);\n\tkfree(qecp);\n\treturn NULL;\n}\n\nstatic const struct net_device_ops qec_ops = {\n\t.ndo_open\t\t= qe_open,\n\t.ndo_stop\t\t= qe_close,\n\t.ndo_start_xmit\t\t= qe_start_xmit,\n\t.ndo_set_rx_mode\t= qe_set_multicast,\n\t.ndo_tx_timeout\t\t= qe_tx_timeout,\n\t.ndo_set_mac_address\t= eth_mac_addr,\n\t.ndo_validate_addr\t= eth_validate_addr,\n};\n\nstatic int qec_ether_init(struct platform_device *op)\n{\n\tstatic unsigned version_printed;\n\tstruct net_device *dev;\n\tstruct sunqec *qecp;\n\tstruct sunqe *qe;\n\tint i, res;\n\n\tif (version_printed++ == 0)\n\t\tprintk(KERN_INFO \"%s\", version);\n\n\tdev = alloc_etherdev(sizeof(struct sunqe));\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\teth_hw_addr_set(dev, idprom->id_ethaddr);\n\n\tqe = netdev_priv(dev);\n\n\tres = -ENODEV;\n\n\ti = of_getintprop_default(op->dev.of_node, \"channel#\", -1);\n\tif (i == -1)\n\t\tgoto fail;\n\tqe->channel = i;\n\tspin_lock_init(&qe->lock);\n\n\tqecp = get_qec(op);\n\tif (!qecp)\n\t\tgoto fail;\n\n\tqecp->qes[qe->channel] = qe;\n\tqe->dev = dev;\n\tqe->parent = qecp;\n\tqe->op = op;\n\n\tres = -ENOMEM;\n\tqe->qcregs = of_ioremap(&op->resource[0], 0,\n\t\t\t\tCREG_REG_SIZE, \"QEC Channel Registers\");\n\tif (!qe->qcregs) {\n\t\tprintk(KERN_ERR \"qe: Cannot map channel registers.\\n\");\n\t\tgoto fail;\n\t}\n\n\tqe->mregs = of_ioremap(&op->resource[1], 0,\n\t\t\t       MREGS_REG_SIZE, \"QE MACE Registers\");\n\tif (!qe->mregs) {\n\t\tprintk(KERN_ERR \"qe: Cannot map MACE registers.\\n\");\n\t\tgoto fail;\n\t}\n\n\tqe->qe_block = dma_alloc_coherent(&op->dev, PAGE_SIZE,\n\t\t\t\t\t  &qe->qblock_dvma, GFP_ATOMIC);\n\tqe->buffers = dma_alloc_coherent(&op->dev, sizeof(struct sunqe_buffers),\n\t\t\t\t\t &qe->buffers_dvma, GFP_ATOMIC);\n\tif (qe->qe_block == NULL || qe->qblock_dvma == 0 ||\n\t    qe->buffers == NULL || qe->buffers_dvma == 0)\n\t\tgoto fail;\n\n\t \n\tqe_stop(qe);\n\n\tSET_NETDEV_DEV(dev, &op->dev);\n\n\tdev->watchdog_timeo = 5*HZ;\n\tdev->irq = op->archdata.irqs[0];\n\tdev->dma = 0;\n\tdev->ethtool_ops = &qe_ethtool_ops;\n\tdev->netdev_ops = &qec_ops;\n\n\tres = register_netdev(dev);\n\tif (res)\n\t\tgoto fail;\n\n\tplatform_set_drvdata(op, qe);\n\n\tprintk(KERN_INFO \"%s: qe channel[%d] %pM\\n\", dev->name, qe->channel,\n\t       dev->dev_addr);\n\treturn 0;\n\nfail:\n\tif (qe->qcregs)\n\t\tof_iounmap(&op->resource[0], qe->qcregs, CREG_REG_SIZE);\n\tif (qe->mregs)\n\t\tof_iounmap(&op->resource[1], qe->mregs, MREGS_REG_SIZE);\n\tif (qe->qe_block)\n\t\tdma_free_coherent(&op->dev, PAGE_SIZE,\n\t\t\t\t  qe->qe_block, qe->qblock_dvma);\n\tif (qe->buffers)\n\t\tdma_free_coherent(&op->dev,\n\t\t\t\t  sizeof(struct sunqe_buffers),\n\t\t\t\t  qe->buffers,\n\t\t\t\t  qe->buffers_dvma);\n\n\tfree_netdev(dev);\n\n\treturn res;\n}\n\nstatic int qec_sbus_probe(struct platform_device *op)\n{\n\treturn qec_ether_init(op);\n}\n\nstatic int qec_sbus_remove(struct platform_device *op)\n{\n\tstruct sunqe *qp = platform_get_drvdata(op);\n\tstruct net_device *net_dev = qp->dev;\n\n\tunregister_netdev(net_dev);\n\n\tof_iounmap(&op->resource[0], qp->qcregs, CREG_REG_SIZE);\n\tof_iounmap(&op->resource[1], qp->mregs, MREGS_REG_SIZE);\n\tdma_free_coherent(&op->dev, PAGE_SIZE,\n\t\t\t  qp->qe_block, qp->qblock_dvma);\n\tdma_free_coherent(&op->dev, sizeof(struct sunqe_buffers),\n\t\t\t  qp->buffers, qp->buffers_dvma);\n\n\tfree_netdev(net_dev);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id qec_sbus_match[] = {\n\t{\n\t\t.name = \"qe\",\n\t},\n\t{},\n};\n\nMODULE_DEVICE_TABLE(of, qec_sbus_match);\n\nstatic struct platform_driver qec_sbus_driver = {\n\t.driver = {\n\t\t.name = \"qec\",\n\t\t.of_match_table = qec_sbus_match,\n\t},\n\t.probe\t\t= qec_sbus_probe,\n\t.remove\t\t= qec_sbus_remove,\n};\n\nstatic int __init qec_init(void)\n{\n\treturn platform_driver_register(&qec_sbus_driver);\n}\n\nstatic void __exit qec_exit(void)\n{\n\tplatform_driver_unregister(&qec_sbus_driver);\n\n\twhile (root_qec_dev) {\n\t\tstruct sunqec *next = root_qec_dev->next_module;\n\t\tstruct platform_device *op = root_qec_dev->op;\n\n\t\tfree_irq(op->archdata.irqs[0], (void *) root_qec_dev);\n\t\tof_iounmap(&op->resource[0], root_qec_dev->gregs,\n\t\t\t   GLOB_REG_SIZE);\n\t\tkfree(root_qec_dev);\n\n\t\troot_qec_dev = next;\n\t}\n}\n\nmodule_init(qec_init);\nmodule_exit(qec_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}