{
  "module_name": "ether1.c",
  "hash_id": "9d3ff71fafff3040f17bb3f28ba7f9bfe106d67de4ce4884625cf504f570bf67",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/i825xx/ether1.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/fcntl.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/in.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/device.h>\n#include <linux/init.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/skbuff.h>\n#include <linux/bitops.h>\n\n#include <asm/io.h>\n#include <asm/dma.h>\n#include <asm/ecard.h>\n\n#define __ETHER1_C\n#include \"ether1.h\"\n\nstatic unsigned int net_debug = NET_DEBUG;\n\n#define BUFFER_SIZE\t0x10000\n#define TX_AREA_START\t0x00100\n#define TX_AREA_END\t0x05000\n#define RX_AREA_START\t0x05000\n#define RX_AREA_END\t0x0fc00\n\nstatic int ether1_open(struct net_device *dev);\nstatic netdev_tx_t ether1_sendpacket(struct sk_buff *skb,\n\t\t\t\t     struct net_device *dev);\nstatic irqreturn_t ether1_interrupt(int irq, void *dev_id);\nstatic int ether1_close(struct net_device *dev);\nstatic void ether1_setmulticastlist(struct net_device *dev);\nstatic void ether1_timeout(struct net_device *dev, unsigned int txqueue);\n\n \n\nstatic char version[] = \"ether1 ethernet driver (c) 2000 Russell King v1.07\\n\";\n\n#define BUS_16 16\n#define BUS_8  8\n\n \n\n#define DISABLEIRQS 1\n#define NORMALIRQS  0\n\n#define ether1_readw(dev, addr, type, offset, svflgs) ether1_inw_p (dev, addr + (int)(&((type *)0)->offset), svflgs)\n#define ether1_writew(dev, val, addr, type, offset, svflgs) ether1_outw_p (dev, val, addr + (int)(&((type *)0)->offset), svflgs)\n\nstatic inline unsigned short\nether1_inw_p (struct net_device *dev, int addr, int svflgs)\n{\n\tunsigned long flags;\n\tunsigned short ret;\n\n\tif (svflgs)\n\t\tlocal_irq_save (flags);\n\n\twriteb(addr >> 12, REG_PAGE);\n\tret = readw(ETHER1_RAM + ((addr & 4095) << 1));\n\tif (svflgs)\n\t\tlocal_irq_restore (flags);\n\treturn ret;\n}\n\nstatic inline void\nether1_outw_p (struct net_device *dev, unsigned short val, int addr, int svflgs)\n{\n\tunsigned long flags;\n\n\tif (svflgs)\n\t\tlocal_irq_save (flags);\n\n\twriteb(addr >> 12, REG_PAGE);\n\twritew(val, ETHER1_RAM + ((addr & 4095) << 1));\n\tif (svflgs)\n\t\tlocal_irq_restore (flags);\n}\n\n \nstatic void\nether1_writebuffer (struct net_device *dev, void *data, unsigned int start, unsigned int length)\n{\n\tunsigned int page, thislen, offset;\n\tvoid __iomem *addr;\n\n\toffset = start & 4095;\n\tpage = start >> 12;\n\taddr = ETHER1_RAM + (offset << 1);\n\n\tif (offset + length > 4096)\n\t\tthislen = 4096 - offset;\n\telse\n\t\tthislen = length;\n\n\tdo {\n\t\tint used;\n\n\t\twriteb(page, REG_PAGE);\n\t\tlength -= thislen;\n\n\t\t__asm__ __volatile__(\n\t\"subs\t%3, %3, #2\\n\\\n\tbmi\t2f\\n\\\n1:\tldr\t%0, [%1], #2\\n\\\n\tmov\t%0, %0, lsl #16\\n\\\n\torr\t%0, %0, %0, lsr #16\\n\\\n\tstr\t%0, [%2], #4\\n\\\n\tsubs\t%3, %3, #2\\n\\\n\tbmi\t2f\\n\\\n\tldr\t%0, [%1], #2\\n\\\n\tmov\t%0, %0, lsl #16\\n\\\n\torr\t%0, %0, %0, lsr #16\\n\\\n\tstr\t%0, [%2], #4\\n\\\n\tsubs\t%3, %3, #2\\n\\\n\tbmi\t2f\\n\\\n\tldr\t%0, [%1], #2\\n\\\n\tmov\t%0, %0, lsl #16\\n\\\n\torr\t%0, %0, %0, lsr #16\\n\\\n\tstr\t%0, [%2], #4\\n\\\n\tsubs\t%3, %3, #2\\n\\\n\tbmi\t2f\\n\\\n\tldr\t%0, [%1], #2\\n\\\n\tmov\t%0, %0, lsl #16\\n\\\n\torr\t%0, %0, %0, lsr #16\\n\\\n\tstr\t%0, [%2], #4\\n\\\n\tsubs\t%3, %3, #2\\n\\\n\tbpl\t1b\\n\\\n2:\tadds\t%3, %3, #1\\n\\\n\tldreqb\t%0, [%1]\\n\\\n\tstreqb\t%0, [%2]\"\n\t\t: \"=&r\" (used), \"=&r\" (data)\n\t\t: \"r\"  (addr), \"r\" (thislen), \"1\" (data));\n\n\t\taddr = ETHER1_RAM;\n\n\t\tthislen = length;\n\t\tif (thislen > 4096)\n\t\t\tthislen = 4096;\n\t\tpage++;\n\t} while (thislen);\n}\n\nstatic void\nether1_readbuffer (struct net_device *dev, void *data, unsigned int start, unsigned int length)\n{\n\tunsigned int page, thislen, offset;\n\tvoid __iomem *addr;\n\n\toffset = start & 4095;\n\tpage = start >> 12;\n\taddr = ETHER1_RAM + (offset << 1);\n\n\tif (offset + length > 4096)\n\t\tthislen = 4096 - offset;\n\telse\n\t\tthislen = length;\n\n\tdo {\n\t\tint used;\n\n\t\twriteb(page, REG_PAGE);\n\t\tlength -= thislen;\n\n\t\t__asm__ __volatile__(\n\t\"subs\t%3, %3, #2\\n\\\n\tbmi\t2f\\n\\\n1:\tldr\t%0, [%2], #4\\n\\\n\tstrb\t%0, [%1], #1\\n\\\n\tmov\t%0, %0, lsr #8\\n\\\n\tstrb\t%0, [%1], #1\\n\\\n\tsubs\t%3, %3, #2\\n\\\n\tbmi\t2f\\n\\\n\tldr\t%0, [%2], #4\\n\\\n\tstrb\t%0, [%1], #1\\n\\\n\tmov\t%0, %0, lsr #8\\n\\\n\tstrb\t%0, [%1], #1\\n\\\n\tsubs\t%3, %3, #2\\n\\\n\tbmi\t2f\\n\\\n\tldr\t%0, [%2], #4\\n\\\n\tstrb\t%0, [%1], #1\\n\\\n\tmov\t%0, %0, lsr #8\\n\\\n\tstrb\t%0, [%1], #1\\n\\\n\tsubs\t%3, %3, #2\\n\\\n\tbmi\t2f\\n\\\n\tldr\t%0, [%2], #4\\n\\\n\tstrb\t%0, [%1], #1\\n\\\n\tmov\t%0, %0, lsr #8\\n\\\n\tstrb\t%0, [%1], #1\\n\\\n\tsubs\t%3, %3, #2\\n\\\n\tbpl\t1b\\n\\\n2:\tadds\t%3, %3, #1\\n\\\n\tldreqb\t%0, [%2]\\n\\\n\tstreqb\t%0, [%1]\"\n\t\t: \"=&r\" (used), \"=&r\" (data)\n\t\t: \"r\"  (addr), \"r\" (thislen), \"1\" (data));\n\n\t\taddr = ETHER1_RAM;\n\n\t\tthislen = length;\n\t\tif (thislen > 4096)\n\t\t\tthislen = 4096;\n\t\tpage++;\n\t} while (thislen);\n}\n\nstatic int\nether1_ramtest(struct net_device *dev, unsigned char byte)\n{\n\tunsigned char *buffer = kmalloc (BUFFER_SIZE, GFP_KERNEL);\n\tint i, ret = BUFFER_SIZE;\n\tint max_errors = 15;\n\tint bad = -1;\n\tint bad_start = 0;\n\n\tif (!buffer)\n\t\treturn 1;\n\n\tmemset (buffer, byte, BUFFER_SIZE);\n\tether1_writebuffer (dev, buffer, 0, BUFFER_SIZE);\n\tmemset (buffer, byte ^ 0xff, BUFFER_SIZE);\n\tether1_readbuffer (dev, buffer, 0, BUFFER_SIZE);\n\n\tfor (i = 0; i < BUFFER_SIZE; i++) {\n\t\tif (buffer[i] != byte) {\n\t\t\tif (max_errors >= 0 && bad != buffer[i]) {\n\t\t\t\tif (bad != -1)\n\t\t\t\t\tprintk (\"\\n\");\n\t\t\t\tprintk (KERN_CRIT \"%s: RAM failed with (%02X instead of %02X) at 0x%04X\",\n\t\t\t\t\tdev->name, buffer[i], byte, i);\n\t\t\t\tret = -ENODEV;\n\t\t\t\tmax_errors --;\n\t\t\t\tbad = buffer[i];\n\t\t\t\tbad_start = i;\n\t\t\t}\n\t\t} else {\n\t\t\tif (bad != -1) {\n\t\t\t    \tif (bad_start == i - 1)\n\t\t\t\t\tprintk (\"\\n\");\n\t\t\t\telse\n\t\t\t\t\tprintk (\" - 0x%04X\\n\", i - 1);\n\t\t\t\tbad = -1;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (bad != -1)\n\t\tprintk (\" - 0x%04X\\n\", BUFFER_SIZE);\n\tkfree (buffer);\n\n\treturn ret;\n}\n\nstatic int\nether1_reset (struct net_device *dev)\n{\n\twriteb(CTRL_RST|CTRL_ACK, REG_CONTROL);\n\treturn BUS_16;\n}\n\nstatic int\nether1_init_2(struct net_device *dev)\n{\n\tint i;\n\tdev->mem_start = 0;\n\n\ti = ether1_ramtest (dev, 0x5a);\n\n\tif (i > 0)\n\t\ti = ether1_ramtest (dev, 0x1e);\n\n\tif (i <= 0)\n\t    \treturn -ENODEV;\n\n\tdev->mem_end = i;\n\treturn 0;\n}\n\n/*\n * These are the structures that are loaded into the ether RAM card to\n * initialise the 82586\n */\n\n/* at 0x0100 */\n#define NOP_ADDR\t(TX_AREA_START)\n#define NOP_SIZE\t(0x06)\nstatic nop_t  init_nop  = {\n\t0,\n\tCMD_NOP,\n\tNOP_ADDR\n};\n\n/* at 0x003a */\n#define TDR_ADDR\t(0x003a)\n#define TDR_SIZE\t(0x08)\nstatic tdr_t  init_tdr\t= {\n\t0,\n\tCMD_TDR | CMD_INTR,\n\tNOP_ADDR,\n\t0\n};\n\n/* at 0x002e */\n#define MC_ADDR\t\t(0x002e)\n#define MC_SIZE\t\t(0x0c)\nstatic mc_t   init_mc   = {\n\t0,\n\tCMD_SETMULTICAST,\n\tTDR_ADDR,\n\t0,\n\t{ { 0, } }\n};\n\n/* at 0x0022 */\n#define SA_ADDR\t\t(0x0022)\n#define SA_SIZE\t\t(0x0c)\nstatic sa_t   init_sa   = {\n\t0,\n\tCMD_SETADDRESS,\n\tMC_ADDR,\n\t{ 0, }\n};\n\n/* at 0x0010 */\n#define CFG_ADDR\t(0x0010)\n#define CFG_SIZE\t(0x12)\nstatic cfg_t  init_cfg  = {\n\t0,\n\tCMD_CONFIG,\n\tSA_ADDR,\n\t8,\n\t8,\n\tCFG8_SRDY,\n\tCFG9_PREAMB8 | CFG9_ADDRLENBUF | CFG9_ADDRLEN(6),\n\t0,\n\t0x60,\n\t0,\n\tCFG13_RETRY(15) | CFG13_SLOTH(2),\n\t0,\n};\n\n/* at 0x0000 */\n#define SCB_ADDR\t(0x0000)\n#define SCB_SIZE\t(0x10)\nstatic scb_t  init_scb  = {\n\t0,\n\tSCB_CMDACKRNR | SCB_CMDACKCNA | SCB_CMDACKFR | SCB_CMDACKCX,\n\tCFG_ADDR,\n\tRX_AREA_START,\n\t0,\n\t0,\n\t0,\n\t0\n};\n\n/* at 0xffee */\n#define ISCP_ADDR\t(0xffee)\n#define ISCP_SIZE\t(0x08)\nstatic iscp_t init_iscp = {\n\t1,\n\tSCB_ADDR,\n\t0x0000,\n\t0x0000\n};\n\n/* at 0xfff6 */\n#define SCP_ADDR\t(0xfff6)\n#define SCP_SIZE\t(0x0a)\nstatic scp_t  init_scp  = {\n\tSCP_SY_16BBUS,\n\t{ 0, 0 },\n\tISCP_ADDR,\n\t0\n};\n\n#define RFD_SIZE\t(0x16)\nstatic rfd_t  init_rfd\t= {\n\t0,\n\t0,\n\t0,\n\t0,\n\t{ 0, },\n\t{ 0, },\n\t0\n};\n\n#define RBD_SIZE\t(0x0a)\nstatic rbd_t  init_rbd\t= {\n\t0,\n\t0,\n\t0,\n\t0,\n\tETH_FRAME_LEN + 8\n};\n\n#define TX_SIZE\t\t(0x08)\n#define TBD_SIZE\t(0x08)\n\nstatic int\nether1_init_for_open (struct net_device *dev)\n{\n\tint i, status, addr, next, next2;\n\tint failures = 0;\n\tunsigned long timeout;\n\n\twriteb(CTRL_RST|CTRL_ACK, REG_CONTROL);\n\n\tfor (i = 0; i < 6; i++)\n\t\tinit_sa.sa_addr[i] = dev->dev_addr[i];\n\n\t/* load data structures into ether1 RAM */\n\tether1_writebuffer (dev, &init_scp,  SCP_ADDR,  SCP_SIZE);\n\tether1_writebuffer (dev, &init_iscp, ISCP_ADDR, ISCP_SIZE);\n\tether1_writebuffer (dev, &init_scb,  SCB_ADDR,  SCB_SIZE);\n\tether1_writebuffer (dev, &init_cfg,  CFG_ADDR,  CFG_SIZE);\n\tether1_writebuffer (dev, &init_sa,   SA_ADDR,   SA_SIZE);\n\tether1_writebuffer (dev, &init_mc,   MC_ADDR,   MC_SIZE);\n\tether1_writebuffer (dev, &init_tdr,  TDR_ADDR,  TDR_SIZE);\n\tether1_writebuffer (dev, &init_nop,  NOP_ADDR,  NOP_SIZE);\n\n\tif (ether1_readw(dev, CFG_ADDR, cfg_t, cfg_command, NORMALIRQS) != CMD_CONFIG) {\n\t\tprintk (KERN_ERR \"%s: detected either RAM fault or compiler bug\\n\",\n\t\t\tdev->name);\n\t\treturn 1;\n\t}\n\n\t/*\n\t * setup circularly linked list of { rfd, rbd, buffer }, with\n\t * all rfds circularly linked, rbds circularly linked.\n\t * First rfd is linked to scp, first rbd is linked to first\n\t * rfd.  Last rbd has a suspend command.\n\t */\n\taddr = RX_AREA_START;\n\tdo {\n\t\tnext = addr + RFD_SIZE + RBD_SIZE + ETH_FRAME_LEN + 10;\n\t\tnext2 = next + RFD_SIZE + RBD_SIZE + ETH_FRAME_LEN + 10;\n\n\t\tif (next2 >= RX_AREA_END) {\n\t\t\tnext = RX_AREA_START;\n\t\t\tinit_rfd.rfd_command = RFD_CMDEL | RFD_CMDSUSPEND;\n\t\t\tpriv(dev)->rx_tail = addr;\n\t\t} else\n\t\t\tinit_rfd.rfd_command = 0;\n\t\tif (addr == RX_AREA_START)\n\t\t\tinit_rfd.rfd_rbdoffset = addr + RFD_SIZE;\n\t\telse\n\t\t\tinit_rfd.rfd_rbdoffset = 0;\n\t\tinit_rfd.rfd_link = next;\n\t\tinit_rbd.rbd_link = next + RFD_SIZE;\n\t\tinit_rbd.rbd_bufl = addr + RFD_SIZE + RBD_SIZE;\n\n\t\tether1_writebuffer (dev, &init_rfd, addr, RFD_SIZE);\n\t\tether1_writebuffer (dev, &init_rbd, addr + RFD_SIZE, RBD_SIZE);\n\t\taddr = next;\n\t} while (next2 < RX_AREA_END);\n\n\tpriv(dev)->tx_link = NOP_ADDR;\n\tpriv(dev)->tx_head = NOP_ADDR + NOP_SIZE;\n\tpriv(dev)->tx_tail = TDR_ADDR;\n\tpriv(dev)->rx_head = RX_AREA_START;\n\n\t/* release reset & give 586 a prod */\n\tpriv(dev)->resetting = 1;\n\tpriv(dev)->initialising = 1;\n\twriteb(CTRL_RST, REG_CONTROL);\n\twriteb(0, REG_CONTROL);\n\twriteb(CTRL_CA, REG_CONTROL);\n\n\t/* 586 should now unset iscp.busy */\n\ttimeout = jiffies + HZ/2;\n\twhile (ether1_readw(dev, ISCP_ADDR, iscp_t, iscp_busy, DISABLEIRQS) == 1) {\n\t\tif (time_after(jiffies, timeout)) {\n\t\t\tprintk (KERN_WARNING \"%s: can't initialise 82586: iscp is busy\\n\", dev->name);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t/* check status of commands that we issued */\n\ttimeout += HZ/10;\n\twhile (((status = ether1_readw(dev, CFG_ADDR, cfg_t, cfg_status, DISABLEIRQS))\n\t\t\t& STAT_COMPLETE) == 0) {\n\t\tif (time_after(jiffies, timeout))\n\t\t\tbreak;\n\t}\n\n\tif ((status & (STAT_COMPLETE | STAT_OK)) != (STAT_COMPLETE | STAT_OK)) {\n\t\tprintk (KERN_WARNING \"%s: can't initialise 82586: config status %04X\\n\", dev->name, status);\n\t\tprintk (KERN_DEBUG \"%s: SCB=[STS=%04X CMD=%04X CBL=%04X RFA=%04X]\\n\", dev->name,\n\t\t\tether1_readw(dev, SCB_ADDR, scb_t, scb_status, NORMALIRQS),\n\t\t\tether1_readw(dev, SCB_ADDR, scb_t, scb_command, NORMALIRQS),\n\t\t\tether1_readw(dev, SCB_ADDR, scb_t, scb_cbl_offset, NORMALIRQS),\n\t\t\tether1_readw(dev, SCB_ADDR, scb_t, scb_rfa_offset, NORMALIRQS));\n\t\tfailures += 1;\n\t}\n\n\ttimeout += HZ/10;\n\twhile (((status = ether1_readw(dev, SA_ADDR, sa_t, sa_status, DISABLEIRQS))\n\t\t\t& STAT_COMPLETE) == 0) {\n\t\tif (time_after(jiffies, timeout))\n\t\t\tbreak;\n\t}\n\n\tif ((status & (STAT_COMPLETE | STAT_OK)) != (STAT_COMPLETE | STAT_OK)) {\n\t\tprintk (KERN_WARNING \"%s: can't initialise 82586: set address status %04X\\n\", dev->name, status);\n\t\tprintk (KERN_DEBUG \"%s: SCB=[STS=%04X CMD=%04X CBL=%04X RFA=%04X]\\n\", dev->name,\n\t\t\tether1_readw(dev, SCB_ADDR, scb_t, scb_status, NORMALIRQS),\n\t\t\tether1_readw(dev, SCB_ADDR, scb_t, scb_command, NORMALIRQS),\n\t\t\tether1_readw(dev, SCB_ADDR, scb_t, scb_cbl_offset, NORMALIRQS),\n\t\t\tether1_readw(dev, SCB_ADDR, scb_t, scb_rfa_offset, NORMALIRQS));\n\t\tfailures += 1;\n\t}\n\n\ttimeout += HZ/10;\n\twhile (((status = ether1_readw(dev, MC_ADDR, mc_t, mc_status, DISABLEIRQS))\n\t\t\t& STAT_COMPLETE) == 0) {\n\t\tif (time_after(jiffies, timeout))\n\t\t\tbreak;\n\t}\n\n\tif ((status & (STAT_COMPLETE | STAT_OK)) != (STAT_COMPLETE | STAT_OK)) {\n\t\tprintk (KERN_WARNING \"%s: can't initialise 82586: set multicast status %04X\\n\", dev->name, status);\n\t\tprintk (KERN_DEBUG \"%s: SCB=[STS=%04X CMD=%04X CBL=%04X RFA=%04X]\\n\", dev->name,\n\t\t\tether1_readw(dev, SCB_ADDR, scb_t, scb_status, NORMALIRQS),\n\t\t\tether1_readw(dev, SCB_ADDR, scb_t, scb_command, NORMALIRQS),\n\t\t\tether1_readw(dev, SCB_ADDR, scb_t, scb_cbl_offset, NORMALIRQS),\n\t\t\tether1_readw(dev, SCB_ADDR, scb_t, scb_rfa_offset, NORMALIRQS));\n\t\tfailures += 1;\n\t}\n\n\ttimeout += HZ;\n\twhile (((status = ether1_readw(dev, TDR_ADDR, tdr_t, tdr_status, DISABLEIRQS))\n\t\t\t& STAT_COMPLETE) == 0) {\n\t\tif (time_after(jiffies, timeout))\n\t\t\tbreak;\n\t}\n\n\tif ((status & (STAT_COMPLETE | STAT_OK)) != (STAT_COMPLETE | STAT_OK)) {\n\t\tprintk (KERN_WARNING \"%s: can't tdr (ignored)\\n\", dev->name);\n\t\tprintk (KERN_DEBUG \"%s: SCB=[STS=%04X CMD=%04X CBL=%04X RFA=%04X]\\n\", dev->name,\n\t\t\tether1_readw(dev, SCB_ADDR, scb_t, scb_status, NORMALIRQS),\n\t\t\tether1_readw(dev, SCB_ADDR, scb_t, scb_command, NORMALIRQS),\n\t\t\tether1_readw(dev, SCB_ADDR, scb_t, scb_cbl_offset, NORMALIRQS),\n\t\t\tether1_readw(dev, SCB_ADDR, scb_t, scb_rfa_offset, NORMALIRQS));\n\t} else {\n\t\tstatus = ether1_readw(dev, TDR_ADDR, tdr_t, tdr_result, DISABLEIRQS);\n\t\tif (status & TDR_XCVRPROB)\n\t\t\tprintk (KERN_WARNING \"%s: i/f failed tdr: transceiver problem\\n\", dev->name);\n\t\telse if ((status & (TDR_SHORT|TDR_OPEN)) && (status & TDR_TIME)) {\n#ifdef FANCY\n\t\t\tprintk (KERN_WARNING \"%s: i/f failed tdr: cable %s %d.%d us away\\n\", dev->name,\n\t\t\t\tstatus & TDR_SHORT ? \"short\" : \"open\", (status & TDR_TIME) / 10,\n\t\t\t\t(status & TDR_TIME) % 10);\n#else\n\t\t\tprintk (KERN_WARNING \"%s: i/f failed tdr: cable %s %d clks away\\n\", dev->name,\n\t\t\t\tstatus & TDR_SHORT ? \"short\" : \"open\", (status & TDR_TIME));\n#endif\n\t\t}\n\t}\n\n\tif (failures)\n\t\tether1_reset (dev);\n\treturn failures ? 1 : 0;\n}\n\n/* ------------------------------------------------------------------------- */\n\nstatic int\nether1_txalloc (struct net_device *dev, int size)\n{\n\tint start, tail;\n\n\tsize = (size + 1) & ~1;\n\ttail = priv(dev)->tx_tail;\n\n\tif (priv(dev)->tx_head + size > TX_AREA_END) {\n\t\tif (tail > priv(dev)->tx_head)\n\t\t\treturn -1;\n\t\tstart = TX_AREA_START;\n\t\tif (start + size > tail)\n\t\t\treturn -1;\n\t\tpriv(dev)->tx_head = start + size;\n\t} else {\n\t\tif (priv(dev)->tx_head < tail && (priv(dev)->tx_head + size) > tail)\n\t\t\treturn -1;\n\t\tstart = priv(dev)->tx_head;\n\t\tpriv(dev)->tx_head += size;\n\t}\n\n\treturn start;\n}\n\nstatic int\nether1_open (struct net_device *dev)\n{\n\tif (request_irq(dev->irq, ether1_interrupt, 0, \"ether1\", dev))\n\t\treturn -EAGAIN;\n\n\tif (ether1_init_for_open (dev)) {\n\t\tfree_irq (dev->irq, dev);\n\t\treturn -EAGAIN;\n\t}\n\n\tnetif_start_queue(dev);\n\n\treturn 0;\n}\n\nstatic void\nether1_timeout(struct net_device *dev, unsigned int txqueue)\n{\n\tprintk(KERN_WARNING \"%s: transmit timeout, network cable problem?\\n\",\n\t\tdev->name);\n\tprintk(KERN_WARNING \"%s: resetting device\\n\", dev->name);\n\n\tether1_reset (dev);\n\n\tif (ether1_init_for_open (dev))\n\t\tprintk (KERN_ERR \"%s: unable to restart interface\\n\", dev->name);\n\n\tdev->stats.tx_errors++;\n\tnetif_wake_queue(dev);\n}\n\nstatic netdev_tx_t\nether1_sendpacket (struct sk_buff *skb, struct net_device *dev)\n{\n\tint tmp, tst, nopaddr, txaddr, tbdaddr, dataddr;\n\tunsigned long flags;\n\ttx_t tx;\n\ttbd_t tbd;\n\tnop_t nop;\n\n\tif (priv(dev)->restart) {\n\t\tprintk(KERN_WARNING \"%s: resetting device\\n\", dev->name);\n\n\t\tether1_reset(dev);\n\n\t\tif (ether1_init_for_open(dev))\n\t\t\tprintk(KERN_ERR \"%s: unable to restart interface\\n\", dev->name);\n\t\telse\n\t\t\tpriv(dev)->restart = 0;\n\t}\n\n\tif (skb->len < ETH_ZLEN) {\n\t\tif (skb_padto(skb, ETH_ZLEN))\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t * insert packet followed by a nop\n\t */\n\ttxaddr = ether1_txalloc (dev, TX_SIZE);\n\ttbdaddr = ether1_txalloc (dev, TBD_SIZE);\n\tdataddr = ether1_txalloc (dev, skb->len);\n\tnopaddr = ether1_txalloc (dev, NOP_SIZE);\n\n\ttx.tx_status = 0;\n\ttx.tx_command = CMD_TX | CMD_INTR;\n\ttx.tx_link = nopaddr;\n\ttx.tx_tbdoffset = tbdaddr;\n\ttbd.tbd_opts = TBD_EOL | skb->len;\n\ttbd.tbd_link = I82586_NULL;\n\ttbd.tbd_bufl = dataddr;\n\ttbd.tbd_bufh = 0;\n\tnop.nop_status = 0;\n\tnop.nop_command = CMD_NOP;\n\tnop.nop_link = nopaddr;\n\n\tlocal_irq_save(flags);\n\tether1_writebuffer (dev, &tx, txaddr, TX_SIZE);\n\tether1_writebuffer (dev, &tbd, tbdaddr, TBD_SIZE);\n\tether1_writebuffer (dev, skb->data, dataddr, skb->len);\n\tether1_writebuffer (dev, &nop, nopaddr, NOP_SIZE);\n\ttmp = priv(dev)->tx_link;\n\tpriv(dev)->tx_link = nopaddr;\n\n\t/* now reset the previous nop pointer */\n\tether1_writew(dev, txaddr, tmp, nop_t, nop_link, NORMALIRQS);\n\n\tlocal_irq_restore(flags);\n\n\t/* handle transmit */\n\n\t/* check to see if we have room for a full sized ether frame */\n\ttmp = priv(dev)->tx_head;\n\ttst = ether1_txalloc (dev, TX_SIZE + TBD_SIZE + NOP_SIZE + ETH_FRAME_LEN);\n\tpriv(dev)->tx_head = tmp;\n\tdev_kfree_skb (skb);\n\n\tif (tst == -1)\n\t\tnetif_stop_queue(dev);\n\n out:\n\treturn NETDEV_TX_OK;\n}\n\nstatic void\nether1_xmit_done (struct net_device *dev)\n{\n\tnop_t nop;\n\tint caddr, tst;\n\n\tcaddr = priv(dev)->tx_tail;\n\nagain:\n\tether1_readbuffer (dev, &nop, caddr, NOP_SIZE);\n\n\tswitch (nop.nop_command & CMD_MASK) {\n\tcase CMD_TDR:\n\t\t/* special case */\n\t\tif (ether1_readw(dev, SCB_ADDR, scb_t, scb_cbl_offset, NORMALIRQS)\n\t\t\t\t!= (unsigned short)I82586_NULL) {\n\t\t\tether1_writew(dev, SCB_CMDCUCSTART | SCB_CMDRXSTART, SCB_ADDR, scb_t,\n\t\t\t\t    scb_command, NORMALIRQS);\n\t\t\twriteb(CTRL_CA, REG_CONTROL);\n\t\t}\n\t\tpriv(dev)->tx_tail = NOP_ADDR;\n\t\treturn;\n\n\tcase CMD_NOP:\n\t\tif (nop.nop_link == caddr) {\n\t\t\tif (priv(dev)->initialising == 0)\n\t\t\t\tprintk (KERN_WARNING \"%s: strange command complete with no tx command!\\n\", dev->name);\n\t\t\telse\n\t\t\t        priv(dev)->initialising = 0;\n\t\t\treturn;\n\t\t}\n\t\tif (caddr == nop.nop_link)\n\t\t\treturn;\n\t\tcaddr = nop.nop_link;\n\t\tgoto again;\n\n\tcase CMD_TX:\n\t\tif (nop.nop_status & STAT_COMPLETE)\n\t\t\tbreak;\n\t\tprintk (KERN_ERR \"%s: strange command complete without completed command\\n\", dev->name);\n\t\tpriv(dev)->restart = 1;\n\t\treturn;\n\n\tdefault:\n\t\tprintk (KERN_WARNING \"%s: strange command %d complete! (offset %04X)\", dev->name,\n\t\t\tnop.nop_command & CMD_MASK, caddr);\n\t\tpriv(dev)->restart = 1;\n\t\treturn;\n\t}\n\n\twhile (nop.nop_status & STAT_COMPLETE) {\n\t\tif (nop.nop_status & STAT_OK) {\n\t\t\tdev->stats.tx_packets++;\n\t\t\tdev->stats.collisions += (nop.nop_status & STAT_COLLISIONS);\n\t\t} else {\n\t\t\tdev->stats.tx_errors++;\n\n\t\t\tif (nop.nop_status & STAT_COLLAFTERTX)\n\t\t\t\tdev->stats.collisions++;\n\t\t\tif (nop.nop_status & STAT_NOCARRIER)\n\t\t\t\tdev->stats.tx_carrier_errors++;\n\t\t\tif (nop.nop_status & STAT_TXLOSTCTS)\n\t\t\t\tprintk (KERN_WARNING \"%s: cts lost\\n\", dev->name);\n\t\t\tif (nop.nop_status & STAT_TXSLOWDMA)\n\t\t\t\tdev->stats.tx_fifo_errors++;\n\t\t\tif (nop.nop_status & STAT_COLLEXCESSIVE)\n\t\t\t\tdev->stats.collisions += 16;\n\t\t}\n\n\t\tif (nop.nop_link == caddr) {\n\t\t\tprintk (KERN_ERR \"%s: tx buffer chaining error: tx command points to itself\\n\", dev->name);\n\t\t\tbreak;\n\t\t}\n\n\t\tcaddr = nop.nop_link;\n\t\tether1_readbuffer (dev, &nop, caddr, NOP_SIZE);\n\t\tif ((nop.nop_command & CMD_MASK) != CMD_NOP) {\n\t\t\tprintk (KERN_ERR \"%s: tx buffer chaining error: no nop after tx command\\n\", dev->name);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (caddr == nop.nop_link)\n\t\t\tbreak;\n\n\t\tcaddr = nop.nop_link;\n\t\tether1_readbuffer (dev, &nop, caddr, NOP_SIZE);\n\t\tif ((nop.nop_command & CMD_MASK) != CMD_TX) {\n\t\t\tprintk (KERN_ERR \"%s: tx buffer chaining error: no tx command after nop\\n\", dev->name);\n\t\t\tbreak;\n\t\t}\n\t}\n\tpriv(dev)->tx_tail = caddr;\n\n\tcaddr = priv(dev)->tx_head;\n\ttst = ether1_txalloc (dev, TX_SIZE + TBD_SIZE + NOP_SIZE + ETH_FRAME_LEN);\n\tpriv(dev)->tx_head = caddr;\n\tif (tst != -1)\n\t\tnetif_wake_queue(dev);\n}\n\nstatic void\nether1_recv_done (struct net_device *dev)\n{\n\tint status;\n\tint nexttail, rbdaddr;\n\trbd_t rbd;\n\n\tdo {\n\t\tstatus = ether1_readw(dev, priv(dev)->rx_head, rfd_t, rfd_status, NORMALIRQS);\n\t\tif ((status & RFD_COMPLETE) == 0)\n\t\t\tbreak;\n\n\t\trbdaddr = ether1_readw(dev, priv(dev)->rx_head, rfd_t, rfd_rbdoffset, NORMALIRQS);\n\t\tether1_readbuffer (dev, &rbd, rbdaddr, RBD_SIZE);\n\n\t\tif ((rbd.rbd_status & (RBD_EOF | RBD_ACNTVALID)) == (RBD_EOF | RBD_ACNTVALID)) {\n\t\t\tint length = rbd.rbd_status & RBD_ACNT;\n\t\t\tstruct sk_buff *skb;\n\n\t\t\tlength = (length + 1) & ~1;\n\t\t\tskb = netdev_alloc_skb(dev, length + 2);\n\n\t\t\tif (skb) {\n\t\t\t\tskb_reserve (skb, 2);\n\n\t\t\t\tether1_readbuffer (dev, skb_put (skb, length), rbd.rbd_bufl, length);\n\n\t\t\t\tskb->protocol = eth_type_trans (skb, dev);\n\t\t\t\tnetif_rx (skb);\n\t\t\t\tdev->stats.rx_packets++;\n\t\t\t} else\n\t\t\t\tdev->stats.rx_dropped++;\n\t\t} else {\n\t\t\tprintk(KERN_WARNING \"%s: %s\\n\", dev->name,\n\t\t\t\t(rbd.rbd_status & RBD_EOF) ? \"oversized packet\" : \"acnt not valid\");\n\t\t\tdev->stats.rx_dropped++;\n\t\t}\n\n\t\tnexttail = ether1_readw(dev, priv(dev)->rx_tail, rfd_t, rfd_link, NORMALIRQS);\n\t\t/* nexttail should be rx_head */\n\t\tif (nexttail != priv(dev)->rx_head)\n\t\t\tprintk(KERN_ERR \"%s: receiver buffer chaining error (%04X != %04X)\\n\",\n\t\t\t\tdev->name, nexttail, priv(dev)->rx_head);\n\t\tether1_writew(dev, RFD_CMDEL | RFD_CMDSUSPEND, nexttail, rfd_t, rfd_command, NORMALIRQS);\n\t\tether1_writew(dev, 0, priv(dev)->rx_tail, rfd_t, rfd_command, NORMALIRQS);\n\t\tether1_writew(dev, 0, priv(dev)->rx_tail, rfd_t, rfd_status, NORMALIRQS);\n\t\tether1_writew(dev, 0, priv(dev)->rx_tail, rfd_t, rfd_rbdoffset, NORMALIRQS);\n\t\n\t\tpriv(dev)->rx_tail = nexttail;\n\t\tpriv(dev)->rx_head = ether1_readw(dev, priv(dev)->rx_head, rfd_t, rfd_link, NORMALIRQS);\n\t} while (1);\n}\n\nstatic irqreturn_t\nether1_interrupt (int irq, void *dev_id)\n{\n\tstruct net_device *dev = (struct net_device *)dev_id;\n\tint status;\n\n\tstatus = ether1_readw(dev, SCB_ADDR, scb_t, scb_status, NORMALIRQS);\n\n\tif (status) {\n\t\tether1_writew(dev, status & (SCB_STRNR | SCB_STCNA | SCB_STFR | SCB_STCX),\n\t\t\t    SCB_ADDR, scb_t, scb_command, NORMALIRQS);\n\t\twriteb(CTRL_CA | CTRL_ACK, REG_CONTROL);\n\t\tif (status & SCB_STCX) {\n\t\t\tether1_xmit_done (dev);\n\t\t}\n\t\tif (status & SCB_STCNA) {\n\t\t\tif (priv(dev)->resetting == 0)\n\t\t\t\tprintk (KERN_WARNING \"%s: CU went not ready ???\\n\", dev->name);\n\t\t\telse\n\t\t\t\tpriv(dev)->resetting += 1;\n\t\t\tif (ether1_readw(dev, SCB_ADDR, scb_t, scb_cbl_offset, NORMALIRQS)\n\t\t\t\t\t!= (unsigned short)I82586_NULL) {\n\t\t\t\tether1_writew(dev, SCB_CMDCUCSTART, SCB_ADDR, scb_t, scb_command, NORMALIRQS);\n\t\t\t\twriteb(CTRL_CA, REG_CONTROL);\n\t\t\t}\n\t\t\tif (priv(dev)->resetting == 2)\n\t\t\t\tpriv(dev)->resetting = 0;\n\t\t}\n\t\tif (status & SCB_STFR) {\n\t\t\tether1_recv_done (dev);\n\t\t}\n\t\tif (status & SCB_STRNR) {\n\t\t\tif (ether1_readw(dev, SCB_ADDR, scb_t, scb_status, NORMALIRQS) & SCB_STRXSUSP) {\n\t\t\t\tprintk (KERN_WARNING \"%s: RU went not ready: RU suspended\\n\", dev->name);\n\t\t\t\tether1_writew(dev, SCB_CMDRXRESUME, SCB_ADDR, scb_t, scb_command, NORMALIRQS);\n\t\t\t\twriteb(CTRL_CA, REG_CONTROL);\n\t\t\t\tdev->stats.rx_dropped++;\t/* we suspended due to lack of buffer space */\n\t\t\t} else\n\t\t\t\tprintk(KERN_WARNING \"%s: RU went not ready: %04X\\n\", dev->name,\n\t\t\t\t\tether1_readw(dev, SCB_ADDR, scb_t, scb_status, NORMALIRQS));\n\t\t\tprintk (KERN_WARNING \"RU ptr = %04X\\n\", ether1_readw(dev, SCB_ADDR, scb_t, scb_rfa_offset,\n\t\t\t\t\t\tNORMALIRQS));\n\t\t}\n\t} else\n\t\twriteb(CTRL_ACK, REG_CONTROL);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int\nether1_close (struct net_device *dev)\n{\n\tether1_reset (dev);\n\n\tfree_irq(dev->irq, dev);\n\n\treturn 0;\n}\n\n/*\n * Set or clear the multicast filter for this adaptor.\n * num_addrs == -1\tPromiscuous mode, receive all packets.\n * num_addrs == 0\tNormal mode, clear multicast list.\n * num_addrs > 0\tMulticast mode, receive normal and MC packets, and do\n *\t\t\tbest-effort filtering.\n */\nstatic void\nether1_setmulticastlist (struct net_device *dev)\n{\n}\n\n/* ------------------------------------------------------------------------- */\n\nstatic void ether1_banner(void)\n{\n\tstatic unsigned int version_printed = 0;\n\n\tif (net_debug && version_printed++ == 0)\n\t\tprintk(KERN_INFO \"%s\", version);\n}\n\nstatic const struct net_device_ops ether1_netdev_ops = {\n\t.ndo_open\t\t= ether1_open,\n\t.ndo_stop\t\t= ether1_close,\n\t.ndo_start_xmit\t\t= ether1_sendpacket,\n\t.ndo_set_rx_mode\t= ether1_setmulticastlist,\n\t.ndo_tx_timeout\t\t= ether1_timeout,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_set_mac_address\t= eth_mac_addr,\n};\n\nstatic int\nether1_probe(struct expansion_card *ec, const struct ecard_id *id)\n{\n\tstruct net_device *dev;\n\tu8 addr[ETH_ALEN];\n\tint i, ret = 0;\n\n\tether1_banner();\n\n\tret = ecard_request_resources(ec);\n\tif (ret)\n\t\tgoto out;\n\n\tdev = alloc_etherdev(sizeof(struct ether1_priv));\n\tif (!dev) {\n\t\tret = -ENOMEM;\n\t\tgoto release;\n\t}\n\n\tSET_NETDEV_DEV(dev, &ec->dev);\n\n\tdev->irq = ec->irq;\n\tpriv(dev)->base = ecardm_iomap(ec, ECARD_RES_IOCFAST, 0, 0);\n\tif (!priv(dev)->base) {\n\t\tret = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\tif ((priv(dev)->bus_type = ether1_reset(dev)) == 0) {\n\t\tret = -ENODEV;\n\t\tgoto free;\n\t}\n\n\tfor (i = 0; i < 6; i++)\n\t\taddr[i] = readb(IDPROM_ADDRESS + (i << 2));\n\teth_hw_addr_set(dev, addr);\n\n\tif (ether1_init_2(dev)) {\n\t\tret = -ENODEV;\n\t\tgoto free;\n\t}\n\n\tdev->netdev_ops\t\t= &ether1_netdev_ops;\n\tdev->watchdog_timeo\t= 5 * HZ / 100;\n\n\tret = register_netdev(dev);\n\tif (ret)\n\t\tgoto free;\n\n\tprintk(KERN_INFO \"%s: ether1 in slot %d, %pM\\n\",\n\t\tdev->name, ec->slot_no, dev->dev_addr);\n    \n\tecard_set_drvdata(ec, dev);\n\treturn 0;\n\n free:\n\tfree_netdev(dev);\n release:\n\tecard_release_resources(ec);\n out:\n\treturn ret;\n}\n\nstatic void ether1_remove(struct expansion_card *ec)\n{\n\tstruct net_device *dev = ecard_get_drvdata(ec);\n\n\tecard_set_drvdata(ec, NULL);\t\n\n\tunregister_netdev(dev);\n\tfree_netdev(dev);\n\tecard_release_resources(ec);\n}\n\nstatic const struct ecard_id ether1_ids[] = {\n\t{ MANU_ACORN, PROD_ACORN_ETHER1 },\n\t{ 0xffff, 0xffff }\n};\n\nstatic struct ecard_driver ether1_driver = {\n\t.probe\t\t= ether1_probe,\n\t.remove\t\t= ether1_remove,\n\t.id_table\t= ether1_ids,\n\t.drv = {\n\t\t.name\t= \"ether1\",\n\t},\n};\n\nstatic int __init ether1_init(void)\n{\n\treturn ecard_register_driver(&ether1_driver);\n}\n\nstatic void __exit ether1_exit(void)\n{\n\tecard_remove_driver(&ether1_driver);\n}\n\nmodule_init(ether1_init);\nmodule_exit(ether1_exit);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}