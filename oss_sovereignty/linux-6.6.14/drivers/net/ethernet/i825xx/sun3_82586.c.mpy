{
  "module_name": "sun3_82586.c",
  "hash_id": "ff0d6d7306e303f5fce98ad1b82b2555b85b6b2d1b59408213b23088b6b0ffb9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/i825xx/sun3_82586.c",
  "human_readable_source": "\n \n\nstatic int debuglevel = 0;  \nstatic int automatic_resume = 0;  \nstatic int rfdadd = 0;  \nstatic int fifo=0x8;\t \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/ioport.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/bitops.h>\n#include <asm/io.h>\n#include <asm/idprom.h>\n#include <asm/machines.h>\n#include <asm/sun3mmu.h>\n#include <asm/dvma.h>\n#include <asm/byteorder.h>\n\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/skbuff.h>\n\n#include \"sun3_82586.h\"\n\n#define DRV_NAME \"sun3_82586\"\n\n#define DEBUG        \n#define SYSBUSVAL 0  \n#define SUN3_82586_TOTAL_SIZE\tPAGE_SIZE\n\n#define sun3_attn586()  {*(volatile unsigned char *)(dev->base_addr) |= IEOB_ATTEN; *(volatile unsigned char *)(dev->base_addr) &= ~IEOB_ATTEN;}\n#define sun3_reset586() {*(volatile unsigned char *)(dev->base_addr) = 0; udelay(100); *(volatile unsigned char *)(dev->base_addr) = IEOB_NORSET;}\n#define sun3_disint()   {*(volatile unsigned char *)(dev->base_addr) &= ~IEOB_IENAB;}\n#define sun3_enaint()   {*(volatile unsigned char *)(dev->base_addr) |= IEOB_IENAB;}\n#define sun3_active()   {*(volatile unsigned char *)(dev->base_addr) |= (IEOB_IENAB|IEOB_ONAIR|IEOB_NORSET);}\n\n#define make32(ptr16) (p->memtop + (swab16((unsigned short) (ptr16))) )\n#define make24(ptr32) (char *)swab32(( ((unsigned long) (ptr32)) - p->base))\n#define make16(ptr32) (swab16((unsigned short) ((unsigned long)(ptr32) - (unsigned long) p->memtop )))\n\n \n\n#define RECV_BUFF_SIZE 1536  \n#define XMIT_BUFF_SIZE 1536  \n#define NUM_XMIT_BUFFS 1     \n#define NUM_RECV_BUFFS_8 4  \n#define NUM_RECV_BUFFS_16 9  \n#define NUM_RECV_BUFFS_32 16  \n#define NO_NOPCOMMANDS       \n\n \n\n \n#define DELAY(x) mdelay(32 * x);\n#define DELAY_16(); { udelay(16); }\n#define DELAY_18(); { udelay(4); }\n\n \n#define WAIT_4_SCB_CMD() \\\n{ int i; \\\n  for(i=0;i<16384;i++) { \\\n    if(!p->scb->cmd_cuc) break; \\\n    DELAY_18(); \\\n    if(i == 16383) { \\\n      printk(\"%s: scb_cmd timed out: %04x,%04x .. disabling i82586!!\\n\",dev->name,p->scb->cmd_cuc,p->scb->cus); \\\n       if(!p->reseted) { p->reseted = 1; sun3_reset586(); } } } }\n\n#define WAIT_4_SCB_CMD_RUC() { int i; \\\n  for(i=0;i<16384;i++) { \\\n    if(!p->scb->cmd_ruc) break; \\\n    DELAY_18(); \\\n    if(i == 16383) { \\\n      printk(\"%s: scb_cmd (ruc) timed out: %04x,%04x .. disabling i82586!!\\n\",dev->name,p->scb->cmd_ruc,p->scb->rus); \\\n       if(!p->reseted) { p->reseted = 1; sun3_reset586(); } } } }\n\n#define WAIT_4_STAT_COMPL(addr) { int i; \\\n   for(i=0;i<32767;i++) { \\\n     if(swab16((addr)->cmd_status) & STAT_COMPL) break; \\\n     DELAY_16(); DELAY_16(); } }\n\nstatic int     sun3_82586_probe1(struct net_device *dev,int ioaddr);\nstatic irqreturn_t sun3_82586_interrupt(int irq,void *dev_id);\nstatic int     sun3_82586_open(struct net_device *dev);\nstatic int     sun3_82586_close(struct net_device *dev);\nstatic netdev_tx_t     sun3_82586_send_packet(struct sk_buff *,\n\t\t\t\t\t      struct net_device *);\nstatic struct  net_device_stats *sun3_82586_get_stats(struct net_device *dev);\nstatic void    set_multicast_list(struct net_device *dev);\nstatic void    sun3_82586_timeout(struct net_device *dev, unsigned int txqueue);\n#if 0\nstatic void    sun3_82586_dump(struct net_device *,void *);\n#endif\n\n \nstatic int     init586(struct net_device *dev);\nstatic int     check586(struct net_device *dev,char *where,unsigned size);\nstatic void    alloc586(struct net_device *dev);\nstatic void    startrecv586(struct net_device *dev);\nstatic void   *alloc_rfa(struct net_device *dev,void *ptr);\nstatic void    sun3_82586_rcv_int(struct net_device *dev);\nstatic void    sun3_82586_xmt_int(struct net_device *dev);\nstatic void    sun3_82586_rnr_int(struct net_device *dev);\n\nstruct priv\n{\n\tunsigned long base;\n\tchar *memtop;\n\tlong int lock;\n\tint reseted;\n\tvolatile struct rfd_struct\t*rfd_last,*rfd_top,*rfd_first;\n\tvolatile struct scp_struct\t*scp;\t \n\tvolatile struct iscp_struct\t*iscp;\t \n\tvolatile struct scb_struct\t*scb;\t \n\tvolatile struct tbd_struct\t*xmit_buffs[NUM_XMIT_BUFFS];\n\tvolatile struct transmit_cmd_struct *xmit_cmds[NUM_XMIT_BUFFS];\n#if (NUM_XMIT_BUFFS == 1)\n\tvolatile struct nop_cmd_struct *nop_cmds[2];\n#else\n\tvolatile struct nop_cmd_struct *nop_cmds[NUM_XMIT_BUFFS];\n#endif\n\tvolatile int\t\tnop_point,num_recv_buffs;\n\tvolatile char\t\t*xmit_cbuffs[NUM_XMIT_BUFFS];\n\tvolatile int\t\txmit_count,xmit_last;\n};\n\n \nstatic int sun3_82586_close(struct net_device *dev)\n{\n\tfree_irq(dev->irq, dev);\n\n\tsun3_reset586();  \n\n\tnetif_stop_queue(dev);\n\n\treturn 0;\n}\n\n \nstatic int sun3_82586_open(struct net_device *dev)\n{\n\tint ret;\n\n\tsun3_disint();\n\talloc586(dev);\n\tinit586(dev);\n\tstartrecv586(dev);\n\tsun3_enaint();\n\n\tret = request_irq(dev->irq, sun3_82586_interrupt,0,dev->name,dev);\n\tif (ret)\n\t{\n\t\tsun3_reset586();\n\t\treturn ret;\n\t}\n\n\tnetif_start_queue(dev);\n\n\treturn 0;  \n}\n\n \nstatic int check586(struct net_device *dev,char *where,unsigned size)\n{\n\tstruct priv pb;\n\tstruct priv *p = &pb;\n\tchar *iscp_addr;\n\tint i;\n\n\tp->base = (unsigned long) dvma_btov(0);\n\tp->memtop = (char *)dvma_btov((unsigned long)where);\n\tp->scp = (struct scp_struct *)(p->base + SCP_DEFAULT_ADDRESS);\n\tmemset((char *)p->scp,0, sizeof(struct scp_struct));\n\tfor(i=0;i<sizeof(struct scp_struct);i++)  \n\t\tif(((char *)p->scp)[i])\n\t\t\treturn 0;\n\tp->scp->sysbus = SYSBUSVAL;\t\t\t\t \n\tif(p->scp->sysbus != SYSBUSVAL)\n\t\treturn 0;\n\n\tiscp_addr = (char *)dvma_btov((unsigned long)where);\n\n\tp->iscp = (struct iscp_struct *) iscp_addr;\n\tmemset((char *)p->iscp,0, sizeof(struct iscp_struct));\n\n\tp->scp->iscp = make24(p->iscp);\n\tp->iscp->busy = 1;\n\n\tsun3_reset586();\n\tsun3_attn586();\n\tDELAY(1);\t \n\n\tif(p->iscp->busy)  \n\t\treturn 0;\n\n\treturn 1;\n}\n\n \nstatic void alloc586(struct net_device *dev)\n{\n\tstruct priv *p = netdev_priv(dev);\n\n\tsun3_reset586();\n\tDELAY(1);\n\n\tp->scp\t= (struct scp_struct *)\t(p->base + SCP_DEFAULT_ADDRESS);\n\tp->iscp\t= (struct iscp_struct *) dvma_btov(dev->mem_start);\n\tp->scb  = (struct scb_struct *)  ((char *)p->iscp + sizeof(struct iscp_struct));\n\n\tmemset((char *) p->iscp,0,sizeof(struct iscp_struct));\n\tmemset((char *) p->scp ,0,sizeof(struct scp_struct));\n\n\tp->scp->iscp = make24(p->iscp);\n\tp->scp->sysbus = SYSBUSVAL;\n\tp->iscp->scb_offset = make16(p->scb);\n\tp->iscp->scb_base = make24(dvma_btov(dev->mem_start));\n\n\tp->iscp->busy = 1;\n\tsun3_reset586();\n\tsun3_attn586();\n\n\tDELAY(1);\n\n\tif(p->iscp->busy)\n\t\tprintk(\"%s: Init-Problems (alloc).\\n\",dev->name);\n\n\tp->reseted = 0;\n\n\tmemset((char *)p->scb,0,sizeof(struct scb_struct));\n}\n\nstatic int __init sun3_82586_probe(void)\n{\n\tstruct net_device *dev;\n\tunsigned long ioaddr;\n\tstatic int found = 0;\n\tint err = -ENOMEM;\n\n\t \n\tswitch(idprom->id_machtype) {\n\tcase SM_SUN3|SM_3_160:\n\tcase SM_SUN3|SM_3_260:\n\t\t \n\t\tbreak;\n\n\tdefault:\n\t\treturn -ENODEV;\n\t}\n\n\tif (found)\n\t\treturn -ENODEV;\n\n\tioaddr = (unsigned long)ioremap(IE_OBIO, SUN3_82586_TOTAL_SIZE);\n\tif (!ioaddr)\n\t\treturn -ENOMEM;\n\tfound = 1;\n\n\tdev = alloc_etherdev(sizeof(struct priv));\n\tif (!dev)\n\t\tgoto out;\n\tdev->irq = IE_IRQ;\n\tdev->base_addr = ioaddr;\n\terr = sun3_82586_probe1(dev, ioaddr);\n\tif (err)\n\t\tgoto out1;\n\terr = register_netdev(dev);\n\tif (err)\n\t\tgoto out2;\n\treturn 0;\n\nout2:\n\trelease_region(ioaddr, SUN3_82586_TOTAL_SIZE);\nout1:\n\tfree_netdev(dev);\nout:\n\tiounmap((void __iomem *)ioaddr);\n\treturn err;\n}\nmodule_init(sun3_82586_probe);\n\nstatic const struct net_device_ops sun3_82586_netdev_ops = {\n\t.ndo_open\t\t= sun3_82586_open,\n\t.ndo_stop\t\t= sun3_82586_close,\n\t.ndo_start_xmit\t\t= sun3_82586_send_packet,\n\t.ndo_set_rx_mode\t= set_multicast_list,\n\t.ndo_tx_timeout\t\t= sun3_82586_timeout,\n\t.ndo_get_stats\t\t= sun3_82586_get_stats,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_set_mac_address\t= eth_mac_addr,\n};\n\nstatic int __init sun3_82586_probe1(struct net_device *dev,int ioaddr)\n{\n\tint size, retval;\n\n\tif (!request_region(ioaddr, SUN3_82586_TOTAL_SIZE, DRV_NAME))\n\t\treturn -EBUSY;\n\n\t \n\teth_hw_addr_set(dev, idprom->id_ethaddr);\n\n\tprintk(\"%s: SUN3 Intel 82586 found at %lx, \",dev->name,dev->base_addr);\n\n\t \n\tsize = 0x8000;\n\n\tdev->mem_start = (unsigned long)dvma_malloc_align(0x8000, 0x1000);\n\tdev->mem_end = dev->mem_start + size;\n\n\tif(size != 0x2000 && size != 0x4000 && size != 0x8000) {\n\t\tprintk(\"\\n%s: Illegal memory size %d. Allowed is 0x2000 or 0x4000 or 0x8000 bytes.\\n\",dev->name,size);\n\t\tretval = -ENODEV;\n\t\tgoto out;\n\t}\n\tif(!check586(dev,(char *) dev->mem_start,size)) {\n\t\tprintk(\"?memcheck, Can't find memory at 0x%lx with size %d!\\n\",dev->mem_start,size);\n\t\tretval = -ENODEV;\n\t\tgoto out;\n\t}\n\n\t((struct priv *)netdev_priv(dev))->memtop =\n\t\t\t\t\t(char *)dvma_btov(dev->mem_start);\n\t((struct priv *)netdev_priv(dev))->base = (unsigned long) dvma_btov(0);\n\talloc586(dev);\n\n\t \n\tif(size == 0x2000)\n\t\t((struct priv *)netdev_priv(dev))->num_recv_buffs =\n\t\t\t\t\t\t\tNUM_RECV_BUFFS_8;\n\telse if(size == 0x4000)\n\t\t((struct priv *)netdev_priv(dev))->num_recv_buffs =\n\t\t\t\t\t\t\tNUM_RECV_BUFFS_16;\n\telse\n\t\t((struct priv *)netdev_priv(dev))->num_recv_buffs =\n\t\t\t\t\t\t\tNUM_RECV_BUFFS_32;\n\n\tprintk(\"Memaddr: 0x%lx, Memsize: %d, IRQ %d\\n\",dev->mem_start,size, dev->irq);\n\n\tdev->netdev_ops\t\t= &sun3_82586_netdev_ops;\n\tdev->watchdog_timeo\t= HZ/20;\n\n\tdev->if_port \t\t= 0;\n\treturn 0;\nout:\n\trelease_region(ioaddr, SUN3_82586_TOTAL_SIZE);\n\treturn retval;\n}\n\n\nstatic int init586(struct net_device *dev)\n{\n\tvoid *ptr;\n\tint i,result=0;\n\tstruct priv *p = netdev_priv(dev);\n\tvolatile struct configure_cmd_struct\t*cfg_cmd;\n\tvolatile struct iasetup_cmd_struct *ias_cmd;\n\tvolatile struct tdr_cmd_struct *tdr_cmd;\n\tvolatile struct mcsetup_cmd_struct *mc_cmd;\n\tstruct netdev_hw_addr *ha;\n\tint num_addrs=netdev_mc_count(dev);\n\n\tptr = (void *) ((char *)p->scb + sizeof(struct scb_struct));\n\n\tcfg_cmd = (struct configure_cmd_struct *)ptr;  \n\tcfg_cmd->cmd_status\t= 0;\n\tcfg_cmd->cmd_cmd\t= swab16(CMD_CONFIGURE | CMD_LAST);\n\tcfg_cmd->cmd_link\t= 0xffff;\n\n\tcfg_cmd->byte_cnt\t= 0x0a;  \n\tcfg_cmd->fifo\t\t= fifo;  \n\tcfg_cmd->sav_bf\t\t= 0x40;  \n\tcfg_cmd->adr_len\t= 0x2e;  \n\tcfg_cmd->priority\t= 0x00;\n\tcfg_cmd->ifs\t\t= 0x60;\n\tcfg_cmd->time_low\t= 0x00;\n\tcfg_cmd->time_high\t= 0xf2;\n\tcfg_cmd->promisc\t= 0;\n\tif(dev->flags & IFF_ALLMULTI) {\n\t\tint len = ((char *) p->iscp - (char *) ptr - 8) / 6;\n\t\tif(num_addrs > len)\t{\n\t\t\tprintk(\"%s: switching to promisc. mode\\n\",dev->name);\n\t\t\tcfg_cmd->promisc = 1;\n\t\t}\n\t}\n\tif(dev->flags&IFF_PROMISC)\n\t\tcfg_cmd->promisc = 1;\n\tcfg_cmd->carr_coll\t= 0x00;\n\n\tp->scb->cbl_offset\t= make16(cfg_cmd);\n\tp->scb->cmd_ruc\t\t= 0;\n\n\tp->scb->cmd_cuc\t\t= CUC_START;  \n\tsun3_attn586();\n\n\tWAIT_4_STAT_COMPL(cfg_cmd);\n\n\tif((swab16(cfg_cmd->cmd_status) & (STAT_OK|STAT_COMPL)) != (STAT_COMPL|STAT_OK))\n\t{\n\t\tprintk(\"%s: configure command failed: %x\\n\",dev->name,swab16(cfg_cmd->cmd_status));\n\t\treturn 1;\n\t}\n\n\t \n\n\tias_cmd = (struct iasetup_cmd_struct *)ptr;\n\n\tias_cmd->cmd_status\t= 0;\n\tias_cmd->cmd_cmd\t= swab16(CMD_IASETUP | CMD_LAST);\n\tias_cmd->cmd_link\t= 0xffff;\n\n\tmemcpy((char *)&ias_cmd->iaddr,(const char *) dev->dev_addr,ETH_ALEN);\n\n\tp->scb->cbl_offset = make16(ias_cmd);\n\n\tp->scb->cmd_cuc = CUC_START;  \n\tsun3_attn586();\n\n\tWAIT_4_STAT_COMPL(ias_cmd);\n\n\tif((swab16(ias_cmd->cmd_status) & (STAT_OK|STAT_COMPL)) != (STAT_OK|STAT_COMPL)) {\n\t\tprintk(\"%s (82586): individual address setup command failed: %04x\\n\",dev->name,swab16(ias_cmd->cmd_status));\n\t\treturn 1;\n\t}\n\n\t \n\n\ttdr_cmd = (struct tdr_cmd_struct *)ptr;\n\n\ttdr_cmd->cmd_status\t= 0;\n\ttdr_cmd->cmd_cmd\t= swab16(CMD_TDR | CMD_LAST);\n\ttdr_cmd->cmd_link\t= 0xffff;\n\ttdr_cmd->status\t\t= 0;\n\n\tp->scb->cbl_offset = make16(tdr_cmd);\n\tp->scb->cmd_cuc = CUC_START;  \n\tsun3_attn586();\n\n\tWAIT_4_STAT_COMPL(tdr_cmd);\n\n\tif(!(swab16(tdr_cmd->cmd_status) & STAT_COMPL))\n\t{\n\t\tprintk(\"%s: Problems while running the TDR.\\n\",dev->name);\n\t}\n\telse\n\t{\n\t\tDELAY_16();  \n\t\tresult = swab16(tdr_cmd->status);\n\n\t\tp->scb->cmd_cuc = p->scb->cus & STAT_MASK;\n\t\tsun3_attn586();  \n\n\t\tif(result & TDR_LNK_OK)\n\t\t\t;\n\t\telse if(result & TDR_XCVR_PRB)\n\t\t\tprintk(\"%s: TDR: Transceiver problem. Check the cable(s)!\\n\",dev->name);\n\t\telse if(result & TDR_ET_OPN)\n\t\t\tprintk(\"%s: TDR: No correct termination %d clocks away.\\n\",dev->name,result & TDR_TIMEMASK);\n\t\telse if(result & TDR_ET_SRT)\n\t\t{\n\t\t\tif (result & TDR_TIMEMASK)  \n\t\t\t\tprintk(\"%s: TDR: Detected a short circuit %d clocks away.\\n\",dev->name,result & TDR_TIMEMASK);\n\t\t}\n\t\telse\n\t\t\tprintk(\"%s: TDR: Unknown status %04x\\n\",dev->name,result);\n\t}\n\n\t \n\tif(num_addrs && !(dev->flags & IFF_PROMISC) )\n\t{\n\t\tmc_cmd = (struct mcsetup_cmd_struct *) ptr;\n\t\tmc_cmd->cmd_status = 0;\n\t\tmc_cmd->cmd_cmd = swab16(CMD_MCSETUP | CMD_LAST);\n\t\tmc_cmd->cmd_link = 0xffff;\n\t\tmc_cmd->mc_cnt = swab16(num_addrs * 6);\n\n\t\ti = 0;\n\t\tnetdev_for_each_mc_addr(ha, dev)\n\t\t\tmemcpy((char *) mc_cmd->mc_list[i++],\n\t\t\t       ha->addr, ETH_ALEN);\n\n\t\tp->scb->cbl_offset = make16(mc_cmd);\n\t\tp->scb->cmd_cuc = CUC_START;\n\t\tsun3_attn586();\n\n\t\tWAIT_4_STAT_COMPL(mc_cmd);\n\n\t\tif( (swab16(mc_cmd->cmd_status) & (STAT_COMPL|STAT_OK)) != (STAT_COMPL|STAT_OK) )\n\t\t\tprintk(\"%s: Can't apply multicast-address-list.\\n\",dev->name);\n\t}\n\n\t \n#if (NUM_XMIT_BUFFS == 1)\n\tfor(i=0;i<2;i++)\n\t{\n\t\tp->nop_cmds[i] \t\t\t= (struct nop_cmd_struct *)ptr;\n\t\tp->nop_cmds[i]->cmd_cmd\t\t= swab16(CMD_NOP);\n\t\tp->nop_cmds[i]->cmd_status \t= 0;\n\t\tp->nop_cmds[i]->cmd_link\t= make16((p->nop_cmds[i]));\n\t\tptr = (char *) ptr + sizeof(struct nop_cmd_struct);\n\t}\n#else\n\tfor(i=0;i<NUM_XMIT_BUFFS;i++)\n\t{\n\t\tp->nop_cmds[i]\t\t\t= (struct nop_cmd_struct *)ptr;\n\t\tp->nop_cmds[i]->cmd_cmd\t\t= swab16(CMD_NOP);\n\t\tp->nop_cmds[i]->cmd_status\t= 0;\n\t\tp->nop_cmds[i]->cmd_link\t= make16((p->nop_cmds[i]));\n\t\tptr = (char *) ptr + sizeof(struct nop_cmd_struct);\n\t}\n#endif\n\n\tptr = alloc_rfa(dev,ptr);  \n\n\t \n\tfor(i=0;i<NUM_XMIT_BUFFS;i++)\n\t{\n\t\tp->xmit_cmds[i] = (struct transmit_cmd_struct *)ptr;  \n\t\tptr = (char *) ptr + sizeof(struct transmit_cmd_struct);\n\t\tp->xmit_cbuffs[i] = (char *)ptr;  \n\t\tptr = (char *) ptr + XMIT_BUFF_SIZE;\n\t\tp->xmit_buffs[i] = (struct tbd_struct *)ptr;  \n\t\tptr = (char *) ptr + sizeof(struct tbd_struct);\n\t\tif(ptr > (void *)dev->mem_end)\n\t\t{\n\t\t\tprintk(\"%s: not enough shared-mem for your configuration!\\n\",dev->name);\n\t\t\treturn 1;\n\t\t}\n\t\tmemset((char *)(p->xmit_cmds[i]) ,0, sizeof(struct transmit_cmd_struct));\n\t\tmemset((char *)(p->xmit_buffs[i]),0, sizeof(struct tbd_struct));\n\t\tp->xmit_cmds[i]->cmd_link = make16(p->nop_cmds[(i+1)%NUM_XMIT_BUFFS]);\n\t\tp->xmit_cmds[i]->cmd_status = swab16(STAT_COMPL);\n\t\tp->xmit_cmds[i]->cmd_cmd = swab16(CMD_XMIT | CMD_INT);\n\t\tp->xmit_cmds[i]->tbd_offset = make16((p->xmit_buffs[i]));\n\t\tp->xmit_buffs[i]->next = 0xffff;\n\t\tp->xmit_buffs[i]->buffer = make24((p->xmit_cbuffs[i]));\n\t}\n\n\tp->xmit_count = 0;\n\tp->xmit_last\t= 0;\n#ifndef NO_NOPCOMMANDS\n\tp->nop_point\t= 0;\n#endif\n\n\t  \n#ifndef NO_NOPCOMMANDS\n\tp->scb->cbl_offset = make16(p->nop_cmds[0]);\n\tp->scb->cmd_cuc = CUC_START;\n\tsun3_attn586();\n\tWAIT_4_SCB_CMD();\n#else\n\tp->xmit_cmds[0]->cmd_link = make16(p->xmit_cmds[0]);\n\tp->xmit_cmds[0]->cmd_cmd\t= swab16(CMD_XMIT | CMD_SUSPEND | CMD_INT);\n#endif\n\n\t \n\tp->scb->cmd_cuc = p->scb->cus & STAT_MASK;\n\tsun3_attn586();\n\tDELAY_16();\n\n\tsun3_enaint();\n\tsun3_active();\n\n\treturn 0;\n}\n\n \n\nstatic void *alloc_rfa(struct net_device *dev,void *ptr)\n{\n\tvolatile struct rfd_struct *rfd = (struct rfd_struct *)ptr;\n\tvolatile struct rbd_struct *rbd;\n\tint i;\n\tstruct priv *p = netdev_priv(dev);\n\n\tmemset((char *) rfd,0,sizeof(struct rfd_struct)*(p->num_recv_buffs+rfdadd));\n\tp->rfd_first = rfd;\n\n\tfor(i = 0; i < (p->num_recv_buffs+rfdadd); i++) {\n\t\trfd[i].next = make16(rfd + (i+1) % (p->num_recv_buffs+rfdadd) );\n\t\trfd[i].rbd_offset = 0xffff;\n\t}\n\trfd[p->num_recv_buffs-1+rfdadd].last = RFD_SUSP;\t  \n\n\tptr = (void *) (rfd + (p->num_recv_buffs + rfdadd) );\n\n\trbd = (struct rbd_struct *) ptr;\n\tptr = (void *) (rbd + p->num_recv_buffs);\n\n\t  \n\tmemset((char *) rbd,0,sizeof(struct rbd_struct)*(p->num_recv_buffs));\n\n\tfor(i=0;i<p->num_recv_buffs;i++)\n\t{\n\t\trbd[i].next = make16((rbd + (i+1) % p->num_recv_buffs));\n\t\trbd[i].size = swab16(RECV_BUFF_SIZE);\n\t\trbd[i].buffer = make24(ptr);\n\t\tptr = (char *) ptr + RECV_BUFF_SIZE;\n\t}\n\n\tp->rfd_top\t= p->rfd_first;\n\tp->rfd_last = p->rfd_first + (p->num_recv_buffs - 1 + rfdadd);\n\n\tp->scb->rfa_offset\t\t= make16(p->rfd_first);\n\tp->rfd_first->rbd_offset\t= make16(rbd);\n\n\treturn ptr;\n}\n\n\n \n\nstatic irqreturn_t sun3_82586_interrupt(int irq,void *dev_id)\n{\n\tstruct net_device *dev = dev_id;\n\tunsigned short stat;\n\tint cnt=0;\n\tstruct priv *p;\n\n\tif (!dev) {\n\t\tprintk (\"sun3_82586-interrupt: irq %d for unknown device.\\n\",irq);\n\t\treturn IRQ_NONE;\n\t}\n\tp = netdev_priv(dev);\n\n\tif(debuglevel > 1)\n\t\tprintk(\"I\");\n\n\tWAIT_4_SCB_CMD();  \n\n\twhile((stat=p->scb->cus & STAT_MASK))\n\t{\n\t\tp->scb->cmd_cuc = stat;\n\t\tsun3_attn586();\n\n\t\tif(stat & STAT_FR)\t  \n\t\t\tsun3_82586_rcv_int(dev);\n\n\t\tif(stat & STAT_RNR)  \n\t\t{\n\t\t\tprintk(\"(R)\");\n\t\t\tif(p->scb->rus & RU_SUSPEND)  \n\t\t\t{\n\t\t\t\tWAIT_4_SCB_CMD();\n\t\t\t\tp->scb->cmd_ruc = RUC_RESUME;\n\t\t\t\tsun3_attn586();\n\t\t\t\tWAIT_4_SCB_CMD_RUC();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tprintk(\"%s: Receiver-Unit went 'NOT READY': %04x/%02x.\\n\",dev->name,(int) stat,(int) p->scb->rus);\n\t\t\t\tsun3_82586_rnr_int(dev);\n\t\t\t}\n\t\t}\n\n\t\tif(stat & STAT_CX)\t\t \n\t\t\t sun3_82586_xmt_int(dev);\n\n#ifndef NO_NOPCOMMANDS\n\t\tif(stat & STAT_CNA)\t \n\t\t{\n\t\t\tif(netif_running(dev))\n\t\t\t\tprintk(\"%s: oops! CU has left active state. stat: %04x/%02x.\\n\",dev->name,(int) stat,(int) p->scb->cus);\n\t\t}\n#endif\n\n\t\tif(debuglevel > 1)\n\t\t\tprintk(\"%d\",cnt++);\n\n\t\tWAIT_4_SCB_CMD();  \n\t\tif(p->scb->cmd_cuc)\t  \n\t\t{\n\t\t\tprintk(\"%s: Acknowledge timed out.\\n\",dev->name);\n\t\t\tsun3_disint();\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif(debuglevel > 1)\n\t\tprintk(\"i\");\n\treturn IRQ_HANDLED;\n}\n\n \n\nstatic void sun3_82586_rcv_int(struct net_device *dev)\n{\n\tint status,cnt=0;\n\tunsigned short totlen;\n\tstruct sk_buff *skb;\n\tstruct rbd_struct *rbd;\n\tstruct priv *p = netdev_priv(dev);\n\n\tif(debuglevel > 0)\n\t\tprintk(\"R\");\n\n\tfor(;(status = p->rfd_top->stat_high) & RFD_COMPL;)\n\t{\n\t\t\trbd = (struct rbd_struct *) make32(p->rfd_top->rbd_offset);\n\n\t\t\tif(status & RFD_OK)  \n\t\t\t{\n\t\t\t\tif( (totlen = swab16(rbd->status)) & RBD_LAST)  \n\t\t\t\t{\n\t\t\t\t\ttotlen &= RBD_MASK;  \n\t\t\t\t\trbd->status = 0;\n\t\t\t\t\tskb = netdev_alloc_skb(dev, totlen + 2);\n\t\t\t\t\tif(skb != NULL)\n\t\t\t\t\t{\n\t\t\t\t\t\tskb_reserve(skb,2);\n\t\t\t\t\t\tskb_put(skb,totlen);\n\t\t\t\t\t\tskb_copy_to_linear_data(skb,(char *) p->base+swab32((unsigned long) rbd->buffer),totlen);\n\t\t\t\t\t\tskb->protocol=eth_type_trans(skb,dev);\n\t\t\t\t\t\tnetif_rx(skb);\n\t\t\t\t\t\tdev->stats.rx_packets++;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tdev->stats.rx_dropped++;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tint rstat;\n\t\t\t\t\t\t  \n\t\t\t\t\ttotlen = 0;\n\t\t\t\t\twhile(!((rstat=swab16(rbd->status)) & RBD_LAST))\n\t\t\t\t\t{\n\t\t\t\t\t\ttotlen += rstat & RBD_MASK;\n\t\t\t\t\t\tif(!rstat)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tprintk(\"%s: Whoops .. no end mark in RBD list\\n\",dev->name);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\trbd->status = 0;\n\t\t\t\t\t\trbd = (struct rbd_struct *) make32(rbd->next);\n\t\t\t\t\t}\n\t\t\t\t\ttotlen += rstat & RBD_MASK;\n\t\t\t\t\trbd->status = 0;\n\t\t\t\t\tprintk(\"%s: received oversized frame! length: %d\\n\",dev->name,totlen);\n\t\t\t\t\tdev->stats.rx_dropped++;\n\t\t\t }\n\t\t}\n\t\telse  \n\t\t{\n\t\t\tprintk(\"%s: oops! rfd-error-status: %04x\\n\",dev->name,status);\n\t\t\tdev->stats.rx_errors++;\n\t\t}\n\t\tp->rfd_top->stat_high = 0;\n\t\tp->rfd_top->last = RFD_SUSP;  \n\t\tp->rfd_top->rbd_offset = 0xffff;\n\t\tp->rfd_last->last = 0;\t\t\t\t \n\t\tp->rfd_last = p->rfd_top;\n\t\tp->rfd_top = (struct rfd_struct *) make32(p->rfd_top->next);  \n\t\tp->scb->rfa_offset = make16(p->rfd_top);\n\n\t\tif(debuglevel > 0)\n\t\t\tprintk(\"%d\",cnt++);\n\t}\n\n\tif(automatic_resume)\n\t{\n\t\tWAIT_4_SCB_CMD();\n\t\tp->scb->cmd_ruc = RUC_RESUME;\n\t\tsun3_attn586();\n\t\tWAIT_4_SCB_CMD_RUC();\n\t}\n\n#ifdef WAIT_4_BUSY\n\t{\n\t\tint i;\n\t\tfor(i=0;i<1024;i++)\n\t\t{\n\t\t\tif(p->rfd_top->status)\n\t\t\t\tbreak;\n\t\t\tDELAY_16();\n\t\t\tif(i == 1023)\n\t\t\t\tprintk(\"%s: RU hasn't fetched next RFD (not busy/complete)\\n\",dev->name);\n\t\t}\n\t}\n#endif\n\n#if 0\n\tif(!at_least_one)\n\t{\n\t\tint i;\n\t\tvolatile struct rfd_struct *rfds=p->rfd_top;\n\t\tvolatile struct rbd_struct *rbds;\n\t\tprintk(\"%s: received a FC intr. without having a frame: %04x %d\\n\",dev->name,status,old_at_least);\n\t\tfor(i=0;i< (p->num_recv_buffs+4);i++)\n\t\t{\n\t\t\trbds = (struct rbd_struct *) make32(rfds->rbd_offset);\n\t\t\tprintk(\"%04x:%04x \",rfds->status,rbds->status);\n\t\t\trfds = (struct rfd_struct *) make32(rfds->next);\n\t\t}\n\t\tprintk(\"\\nerrs: %04x %04x stat: %04x\\n\",(int)p->scb->rsc_errs,(int)p->scb->ovrn_errs,(int)p->scb->status);\n\t\tprintk(\"\\nerrs: %04x %04x rus: %02x, cus: %02x\\n\",(int)p->scb->rsc_errs,(int)p->scb->ovrn_errs,(int)p->scb->rus,(int)p->scb->cus);\n\t}\n\told_at_least = at_least_one;\n#endif\n\n\tif(debuglevel > 0)\n\t\tprintk(\"r\");\n}\n\n \n\nstatic void sun3_82586_rnr_int(struct net_device *dev)\n{\n\tstruct priv *p = netdev_priv(dev);\n\n\tdev->stats.rx_errors++;\n\n\tWAIT_4_SCB_CMD();\t\t \n\tp->scb->cmd_ruc = RUC_ABORT;  \n\tsun3_attn586();\n\tWAIT_4_SCB_CMD_RUC();\t\t \n\n\talloc_rfa(dev,(char *)p->rfd_first);\n \n\tstartrecv586(dev);  \n\n\tprintk(\"%s: Receive-Unit restarted. Status: %04x\\n\",dev->name,p->scb->rus);\n\n}\n\n \n\nstatic void sun3_82586_xmt_int(struct net_device *dev)\n{\n\tint status;\n\tstruct priv *p = netdev_priv(dev);\n\n\tif(debuglevel > 0)\n\t\tprintk(\"X\");\n\n\tstatus = swab16(p->xmit_cmds[p->xmit_last]->cmd_status);\n\tif(!(status & STAT_COMPL))\n\t\tprintk(\"%s: strange .. xmit-int without a 'COMPLETE'\\n\",dev->name);\n\n\tif(status & STAT_OK)\n\t{\n\t\tdev->stats.tx_packets++;\n\t\tdev->stats.collisions += (status & TCMD_MAXCOLLMASK);\n\t}\n\telse\n\t{\n\t\tdev->stats.tx_errors++;\n\t\tif(status & TCMD_LATECOLL) {\n\t\t\tprintk(\"%s: late collision detected.\\n\",dev->name);\n\t\t\tdev->stats.collisions++;\n\t\t}\n\t\telse if(status & TCMD_NOCARRIER) {\n\t\t\tdev->stats.tx_carrier_errors++;\n\t\t\tprintk(\"%s: no carrier detected.\\n\",dev->name);\n\t\t}\n\t\telse if(status & TCMD_LOSTCTS)\n\t\t\tprintk(\"%s: loss of CTS detected.\\n\",dev->name);\n\t\telse if(status & TCMD_UNDERRUN) {\n\t\t\tdev->stats.tx_fifo_errors++;\n\t\t\tprintk(\"%s: DMA underrun detected.\\n\",dev->name);\n\t\t}\n\t\telse if(status & TCMD_MAXCOLL) {\n\t\t\tprintk(\"%s: Max. collisions exceeded.\\n\",dev->name);\n\t\t\tdev->stats.collisions += 16;\n\t\t}\n\t}\n\n#if (NUM_XMIT_BUFFS > 1)\n\tif( (++p->xmit_last) == NUM_XMIT_BUFFS)\n\t\tp->xmit_last = 0;\n#endif\n\tnetif_wake_queue(dev);\n}\n\n \n\nstatic void startrecv586(struct net_device *dev)\n{\n\tstruct priv *p = netdev_priv(dev);\n\n\tWAIT_4_SCB_CMD();\n\tWAIT_4_SCB_CMD_RUC();\n\tp->scb->rfa_offset = make16(p->rfd_first);\n\tp->scb->cmd_ruc = RUC_START;\n\tsun3_attn586();\t\t \n\tWAIT_4_SCB_CMD_RUC();\t \n}\n\nstatic void sun3_82586_timeout(struct net_device *dev, unsigned int txqueue)\n{\n\tstruct priv *p = netdev_priv(dev);\n#ifndef NO_NOPCOMMANDS\n\tif(p->scb->cus & CU_ACTIVE)  \n\t{\n\t\tnetif_wake_queue(dev);\n#ifdef DEBUG\n\t\tprintk(\"%s: strange ... timeout with CU active?!?\\n\",dev->name);\n\t\tprintk(\"%s: X0: %04x N0: %04x N1: %04x %d\\n\",dev->name,(int)swab16(p->xmit_cmds[0]->cmd_status),(int)swab16(p->nop_cmds[0]->cmd_status),(int)swab16(p->nop_cmds[1]->cmd_status),(int)p->nop_point);\n#endif\n\t\tp->scb->cmd_cuc = CUC_ABORT;\n\t\tsun3_attn586();\n\t\tWAIT_4_SCB_CMD();\n\t\tp->scb->cbl_offset = make16(p->nop_cmds[p->nop_point]);\n\t\tp->scb->cmd_cuc = CUC_START;\n\t\tsun3_attn586();\n\t\tWAIT_4_SCB_CMD();\n\t\tnetif_trans_update(dev);  \n\t\treturn 0;\n\t}\n#endif\n\t{\n#ifdef DEBUG\n\t\tprintk(\"%s: xmitter timed out, try to restart! stat: %02x\\n\",dev->name,p->scb->cus);\n\t\tprintk(\"%s: command-stats: %04x %04x\\n\",dev->name,swab16(p->xmit_cmds[0]->cmd_status),swab16(p->xmit_cmds[1]->cmd_status));\n\t\tprintk(\"%s: check, whether you set the right interrupt number!\\n\",dev->name);\n#endif\n\t\tsun3_82586_close(dev);\n\t\tsun3_82586_open(dev);\n\t}\n\tnetif_trans_update(dev);  \n}\n\n \n\nstatic netdev_tx_t\nsun3_82586_send_packet(struct sk_buff *skb, struct net_device *dev)\n{\n\tint len,i;\n#ifndef NO_NOPCOMMANDS\n\tint next_nop;\n#endif\n\tstruct priv *p = netdev_priv(dev);\n\n\tif(skb->len > XMIT_BUFF_SIZE)\n\t{\n\t\tprintk(\"%s: Sorry, max. framelength is %d bytes. The length of your frame is %d bytes.\\n\",dev->name,XMIT_BUFF_SIZE,skb->len);\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\tnetif_stop_queue(dev);\n\n#if(NUM_XMIT_BUFFS > 1)\n\tif(test_and_set_bit(0,(void *) &p->lock)) {\n\t\tprintk(\"%s: Queue was locked\\n\",dev->name);\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\telse\n#endif\n\t{\n\t\tlen = skb->len;\n\t\tif (len < ETH_ZLEN) {\n\t\t\tmemset((void *)p->xmit_cbuffs[p->xmit_count], 0,\n\t\t\t       ETH_ZLEN);\n\t\t\tlen = ETH_ZLEN;\n\t\t}\n\t\tskb_copy_from_linear_data(skb, (void *)p->xmit_cbuffs[p->xmit_count], skb->len);\n\n#if (NUM_XMIT_BUFFS == 1)\n#\tifdef NO_NOPCOMMANDS\n\n#ifdef DEBUG\n\t\tif(p->scb->cus & CU_ACTIVE)\n\t\t{\n\t\t\tprintk(\"%s: Hmmm .. CU is still running and we wanna send a new packet.\\n\",dev->name);\n\t\t\tprintk(\"%s: stat: %04x %04x\\n\",dev->name,p->scb->cus,swab16(p->xmit_cmds[0]->cmd_status));\n\t\t}\n#endif\n\n\t\tp->xmit_buffs[0]->size = swab16(TBD_LAST | len);\n\t\tfor(i=0;i<16;i++)\n\t\t{\n\t\t\tp->xmit_cmds[0]->cmd_status = 0;\n\t\t\tWAIT_4_SCB_CMD();\n\t\t\tif( (p->scb->cus & CU_STATUS) == CU_SUSPEND)\n\t\t\t\tp->scb->cmd_cuc = CUC_RESUME;\n\t\t\telse\n\t\t\t{\n\t\t\t\tp->scb->cbl_offset = make16(p->xmit_cmds[0]);\n\t\t\t\tp->scb->cmd_cuc = CUC_START;\n\t\t\t}\n\n\t\t\tsun3_attn586();\n\t\t\tif(!i)\n\t\t\t\tdev_kfree_skb(skb);\n\t\t\tWAIT_4_SCB_CMD();\n\t\t\tif( (p->scb->cus & CU_ACTIVE))  \n\t\t\t\tbreak;\n\t\t\tif(p->xmit_cmds[0]->cmd_status)\n\t\t\t\tbreak;\n\t\t\tif(i==15)\n\t\t\t\tprintk(\"%s: Can't start transmit-command.\\n\",dev->name);\n\t\t}\n#\telse\n\t\tnext_nop = (p->nop_point + 1) & 0x1;\n\t\tp->xmit_buffs[0]->size = swab16(TBD_LAST | len);\n\n\t\tp->xmit_cmds[0]->cmd_link\t = p->nop_cmds[next_nop]->cmd_link\n\t\t\t= make16((p->nop_cmds[next_nop]));\n\t\tp->xmit_cmds[0]->cmd_status = p->nop_cmds[next_nop]->cmd_status = 0;\n\n\t\tp->nop_cmds[p->nop_point]->cmd_link = make16((p->xmit_cmds[0]));\n\t\tp->nop_point = next_nop;\n\t\tdev_kfree_skb(skb);\n#\tendif\n#else\n\t\tp->xmit_buffs[p->xmit_count]->size = swab16(TBD_LAST | len);\n\t\tif( (next_nop = p->xmit_count + 1) == NUM_XMIT_BUFFS )\n\t\t\tnext_nop = 0;\n\n\t\tp->xmit_cmds[p->xmit_count]->cmd_status\t= 0;\n\t\t \n\t\tp->nop_cmds[next_nop]->cmd_link = make16((p->nop_cmds[next_nop]));\n\t\tp->nop_cmds[next_nop]->cmd_status = 0;\n\n\t\tp->nop_cmds[p->xmit_count]->cmd_link = make16((p->xmit_cmds[p->xmit_count]));\n\t\tp->xmit_count = next_nop;\n\n\t\t{\n\t\t\tunsigned long flags;\n\t\t\tlocal_irq_save(flags);\n\t\t\tif(p->xmit_count != p->xmit_last)\n\t\t\t\tnetif_wake_queue(dev);\n\t\t\tp->lock = 0;\n\t\t\tlocal_irq_restore(flags);\n\t\t}\n\t\tdev_kfree_skb(skb);\n#endif\n\t}\n\treturn NETDEV_TX_OK;\n}\n\n \n\nstatic struct net_device_stats *sun3_82586_get_stats(struct net_device *dev)\n{\n\tstruct priv *p = netdev_priv(dev);\n\tunsigned short crc,aln,rsc,ovrn;\n\n\tcrc = swab16(p->scb->crc_errs);  \n\tp->scb->crc_errs = 0;\n\taln = swab16(p->scb->aln_errs);\n\tp->scb->aln_errs = 0;\n\trsc = swab16(p->scb->rsc_errs);\n\tp->scb->rsc_errs = 0;\n\tovrn = swab16(p->scb->ovrn_errs);\n\tp->scb->ovrn_errs = 0;\n\n\tdev->stats.rx_crc_errors += crc;\n\tdev->stats.rx_fifo_errors += ovrn;\n\tdev->stats.rx_frame_errors += aln;\n\tdev->stats.rx_dropped += rsc;\n\n\treturn &dev->stats;\n}\n\n \n\nstatic void set_multicast_list(struct net_device *dev)\n{\n\tnetif_stop_queue(dev);\n\tsun3_disint();\n\talloc586(dev);\n\tinit586(dev);\n\tstartrecv586(dev);\n\tsun3_enaint();\n\tnetif_wake_queue(dev);\n}\n\n#if 0\n \nvoid sun3_82586_dump(struct net_device *dev,void *ptr)\n{\n\tstruct priv *p = netdev_priv(dev);\n\tstruct dump_cmd_struct *dump_cmd = (struct dump_cmd_struct *) ptr;\n\tint i;\n\n\tp->scb->cmd_cuc = CUC_ABORT;\n\tsun3_attn586();\n\tWAIT_4_SCB_CMD();\n\tWAIT_4_SCB_CMD_RUC();\n\n\tdump_cmd->cmd_status = 0;\n\tdump_cmd->cmd_cmd = CMD_DUMP | CMD_LAST;\n\tdump_cmd->dump_offset = make16((dump_cmd + 1));\n\tdump_cmd->cmd_link = 0xffff;\n\n\tp->scb->cbl_offset = make16(dump_cmd);\n\tp->scb->cmd_cuc = CUC_START;\n\tsun3_attn586();\n\tWAIT_4_STAT_COMPL(dump_cmd);\n\n\tif( (dump_cmd->cmd_status & (STAT_COMPL|STAT_OK)) != (STAT_COMPL|STAT_OK) )\n\t\t\t\tprintk(\"%s: Can't get dump information.\\n\",dev->name);\n\n\tfor(i=0;i<170;i++) {\n\t\tprintk(\"%02x \",(int) ((unsigned char *) (dump_cmd + 1))[i]);\n\t\tif(i % 24 == 23)\n\t\t\tprintk(\"\\n\");\n\t}\n\tprintk(\"\\n\");\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}