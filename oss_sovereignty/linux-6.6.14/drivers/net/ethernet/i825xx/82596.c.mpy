{
  "module_name": "82596.c",
  "hash_id": "dd4f3687966f13991ac64ef5ff541a6c6abab18e82fd8432eee11a325d1f407f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/i825xx/82596.c",
  "human_readable_source": "\n \n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/ioport.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/bitops.h>\n#include <linux/gfp.h>\n#include <linux/pgtable.h>\n\n#include <asm/io.h>\n#include <asm/dma.h>\n#include <asm/cacheflush.h>\n\nstatic char version[] __initdata =\n\t\"82596.c $Revision: 1.5 $\\n\";\n\n#define DRV_NAME\t\"82596\"\n\n \n\n#define DEB_INIT\t0x0001\n#define DEB_PROBE\t0x0002\n#define DEB_SERIOUS\t0x0004\n#define DEB_ERRORS\t0x0008\n#define DEB_MULTI\t0x0010\n#define DEB_TDR\t\t0x0020\n#define DEB_OPEN\t0x0040\n#define DEB_RESET\t0x0080\n#define DEB_ADDCMD\t0x0100\n#define DEB_STATUS\t0x0200\n#define DEB_STARTTX\t0x0400\n#define DEB_RXADDR\t0x0800\n#define DEB_TXADDR\t0x1000\n#define DEB_RXFRAME\t0x2000\n#define DEB_INTS\t0x4000\n#define DEB_STRUCT\t0x8000\n#define DEB_ANY\t\t0xffff\n\n\n#define DEB(x,y)\tif (i596_debug & (x)) y\n\n\n#if IS_ENABLED(CONFIG_MVME16x_NET)\n#define ENABLE_MVME16x_NET\n#endif\n#if IS_ENABLED(CONFIG_BVME6000_NET)\n#define ENABLE_BVME6000_NET\n#endif\n\n#ifdef ENABLE_MVME16x_NET\n#include <asm/mvme16xhw.h>\n#endif\n#ifdef ENABLE_BVME6000_NET\n#include <asm/bvme6000hw.h>\n#endif\n\n \n\n#ifdef __mc68000__\n#define WSWAPrfd(x)  ((struct i596_rfd *) (((u32)(x)<<16) | ((((u32)(x)))>>16)))\n#define WSWAPrbd(x)  ((struct i596_rbd *) (((u32)(x)<<16) | ((((u32)(x)))>>16)))\n#define WSWAPiscp(x) ((struct i596_iscp *)(((u32)(x)<<16) | ((((u32)(x)))>>16)))\n#define WSWAPscb(x)  ((struct i596_scb *) (((u32)(x)<<16) | ((((u32)(x)))>>16)))\n#define WSWAPcmd(x)  ((struct i596_cmd *) (((u32)(x)<<16) | ((((u32)(x)))>>16)))\n#define WSWAPtbd(x)  ((struct i596_tbd *) (((u32)(x)<<16) | ((((u32)(x)))>>16)))\n#define WSWAPchar(x) ((char *)            (((u32)(x)<<16) | ((((u32)(x)))>>16)))\n#define ISCP_BUSY\t0x00010000\n#else\n#error 82596.c: unknown architecture\n#endif\n\n \n#if 0\n#define WSWAPrfd(x)     ((struct i596_rfd *)((long)x))\n#define WSWAPrbd(x)     ((struct i596_rbd *)((long)x))\n#define WSWAPiscp(x)    ((struct i596_iscp *)((long)x))\n#define WSWAPscb(x)     ((struct i596_scb *)((long)x))\n#define WSWAPcmd(x)     ((struct i596_cmd *)((long)x))\n#define WSWAPtbd(x)     ((struct i596_tbd *)((long)x))\n#define WSWAPchar(x)    ((char *)((long)x))\n#define ISCP_BUSY\t0x0001\n#endif\n\n \n#define PORT_RESET\t\t0x00\t \n#define PORT_SELFTEST\t\t0x01\t \n#define PORT_ALTSCP\t\t0x02\t \n#define PORT_ALTDUMP\t\t0x03\t \n\nstatic int i596_debug = (DEB_SERIOUS|DEB_PROBE);\n\nMODULE_AUTHOR(\"Richard Hirst\");\nMODULE_DESCRIPTION(\"i82596 driver\");\nMODULE_LICENSE(\"GPL\");\n\nmodule_param(i596_debug, int, 0);\nMODULE_PARM_DESC(i596_debug, \"i82596 debug mask\");\n\n\n \nstatic int rx_copybreak = 100;\n\n#define PKT_BUF_SZ\t1536\n#define MAX_MC_CNT\t64\n\n#define I596_TOTAL_SIZE 17\n\n#define I596_NULL ((void *)0xffffffff)\n\n#define CMD_EOL\t\t0x8000\t \n#define CMD_SUSP\t0x4000\t \n#define CMD_INTR\t0x2000\t \n\n#define CMD_FLEX\t0x0008\t \n\nenum commands {\n\tCmdNOp = 0, CmdSASetup = 1, CmdConfigure = 2, CmdMulticastList = 3,\n\tCmdTx = 4, CmdTDR = 5, CmdDump = 6, CmdDiagnose = 7\n};\n\n#define STAT_C\t\t0x8000\t \n#define STAT_B\t\t0x4000\t \n#define STAT_OK\t\t0x2000\t \n#define STAT_A\t\t0x1000\t \n\n#define\t CUC_START\t0x0100\n#define\t CUC_RESUME\t0x0200\n#define\t CUC_SUSPEND    0x0300\n#define\t CUC_ABORT\t0x0400\n#define\t RX_START\t0x0010\n#define\t RX_RESUME\t0x0020\n#define\t RX_SUSPEND\t0x0030\n#define\t RX_ABORT\t0x0040\n\n#define TX_TIMEOUT\t(HZ/20)\n\n\nstruct i596_reg {\n\tunsigned short porthi;\n\tunsigned short portlo;\n\tunsigned long ca;\n};\n\n#define EOF\t\t0x8000\n#define SIZE_MASK\t0x3fff\n\nstruct i596_tbd {\n\tunsigned short size;\n\tunsigned short pad;\n\tstruct i596_tbd *next;\n\tchar *data;\n};\n\n \n\nstruct i596_cmd {\n\tstruct i596_cmd *v_next;\t \n\tunsigned short status;\n\tunsigned short command;\n\tstruct i596_cmd *b_next;\t \n};\n\nstruct tx_cmd {\n\tstruct i596_cmd cmd;\n\tstruct i596_tbd *tbd;\n\tunsigned short size;\n\tunsigned short pad;\n\tstruct sk_buff *skb;\t \n};\n\nstruct tdr_cmd {\n\tstruct i596_cmd cmd;\n\tunsigned short status;\n\tunsigned short pad;\n};\n\nstruct mc_cmd {\n\tstruct i596_cmd cmd;\n\tshort mc_cnt;\n\tchar mc_addrs[MAX_MC_CNT*6];\n};\n\nstruct sa_cmd {\n\tstruct i596_cmd cmd;\n\tchar eth_addr[8];\n};\n\nstruct cf_cmd {\n\tstruct i596_cmd cmd;\n\tchar i596_config[16];\n};\n\nstruct i596_rfd {\n\tunsigned short stat;\n\tunsigned short cmd;\n\tstruct i596_rfd *b_next;\t \n\tstruct i596_rbd *rbd;\n\tunsigned short count;\n\tunsigned short size;\n\tstruct i596_rfd *v_next;\t \n\tstruct i596_rfd *v_prev;\n};\n\nstruct i596_rbd {\n    unsigned short count;\n    unsigned short zero1;\n    struct i596_rbd *b_next;\n    unsigned char *b_data;\t\t \n    unsigned short size;\n    unsigned short zero2;\n    struct sk_buff *skb;\n    struct i596_rbd *v_next;\n    struct i596_rbd *b_addr;\t\t \n    unsigned char *v_data;\t\t \n};\n\n#define TX_RING_SIZE 64\n#define RX_RING_SIZE 16\n\nstruct i596_scb {\n\tunsigned short status;\n\tunsigned short command;\n\tstruct i596_cmd *cmd;\n\tstruct i596_rfd *rfd;\n\tunsigned long crc_err;\n\tunsigned long align_err;\n\tunsigned long resource_err;\n\tunsigned long over_err;\n\tunsigned long rcvdt_err;\n\tunsigned long short_err;\n\tunsigned short t_on;\n\tunsigned short t_off;\n};\n\nstruct i596_iscp {\n\tunsigned long stat;\n\tstruct i596_scb *scb;\n};\n\nstruct i596_scp {\n\tunsigned long sysbus;\n\tunsigned long pad;\n\tstruct i596_iscp *iscp;\n};\n\nstruct i596_private {\n\tvolatile struct i596_scp scp;\n\tvolatile struct i596_iscp iscp;\n\tvolatile struct i596_scb scb;\n\tstruct sa_cmd sa_cmd;\n\tstruct cf_cmd cf_cmd;\n\tstruct tdr_cmd tdr_cmd;\n\tstruct mc_cmd mc_cmd;\n\tunsigned long stat;\n\tint last_restart __attribute__((aligned(4)));\n\tstruct i596_rfd *rfd_head;\n\tstruct i596_rbd *rbd_head;\n\tstruct i596_cmd *cmd_tail;\n\tstruct i596_cmd *cmd_head;\n\tint cmd_backlog;\n\tunsigned long last_cmd;\n\tstruct i596_rfd rfds[RX_RING_SIZE];\n\tstruct i596_rbd rbds[RX_RING_SIZE];\n\tstruct tx_cmd tx_cmds[TX_RING_SIZE];\n\tstruct i596_tbd tbds[TX_RING_SIZE];\n\tint next_tx_cmd;\n\tspinlock_t lock;\n};\n\nstatic char init_setup[] =\n{\n\t0x8E,\t\t\t \n\t0xC8,\t\t\t \n#ifdef CONFIG_VME\n\t0xc0,\t\t\t \n#else\n\t0x80,\t\t\t \n#endif\n\t0x2E,\t\t\t \n\t0x00,\t\t\t \n\t0x60,\t\t\t \n\t0x00,\t\t\t \n\t0xf2,\t\t\t \n\t0x00,\t\t\t \n\t0x00,\t\t\t \n\t0x40,\t\t\t \n\t0xff,\n\t0x00,\n\t0x7f   };\n\nstatic int i596_open(struct net_device *dev);\nstatic netdev_tx_t i596_start_xmit(struct sk_buff *skb, struct net_device *dev);\nstatic irqreturn_t i596_interrupt(int irq, void *dev_id);\nstatic int i596_close(struct net_device *dev);\nstatic void i596_add_cmd(struct net_device *dev, struct i596_cmd *cmd);\nstatic void i596_tx_timeout (struct net_device *dev, unsigned int txqueue);\nstatic void print_eth(unsigned char *buf, char *str);\nstatic void set_multicast_list(struct net_device *dev);\n\nstatic int rx_ring_size = RX_RING_SIZE;\nstatic int ticks_limit = 25;\nstatic int max_cmd_backlog = TX_RING_SIZE-1;\n\n\nstatic inline void CA(struct net_device *dev)\n{\n#ifdef ENABLE_MVME16x_NET\n\tif (MACH_IS_MVME16x) {\n\t\t((struct i596_reg *) dev->base_addr)->ca = 1;\n\t}\n#endif\n#ifdef ENABLE_BVME6000_NET\n\tif (MACH_IS_BVME6000) {\n\t\tvolatile u32 i;\n\n\t\ti = *(volatile u32 *) (dev->base_addr);\n\t}\n#endif\n}\n\n\nstatic inline void MPU_PORT(struct net_device *dev, int c, volatile void *x)\n{\n#ifdef ENABLE_MVME16x_NET\n\tif (MACH_IS_MVME16x) {\n\t\tstruct i596_reg *p = (struct i596_reg *) (dev->base_addr);\n\t\tp->porthi = ((c) | (u32) (x)) & 0xffff;\n\t\tp->portlo = ((c) | (u32) (x)) >> 16;\n\t}\n#endif\n#ifdef ENABLE_BVME6000_NET\n\tif (MACH_IS_BVME6000) {\n\t\tu32 v = (u32) (c) | (u32) (x);\n\t\tv = ((u32) (v) << 16) | ((u32) (v) >> 16);\n\t\t*(volatile u32 *) dev->base_addr = v;\n\t\tudelay(1);\n\t\t*(volatile u32 *) dev->base_addr = v;\n\t}\n#endif\n}\n\n\nstatic inline int wait_istat(struct net_device *dev, struct i596_private *lp, int delcnt, char *str)\n{\n\twhile (--delcnt && lp->iscp.stat)\n\t\tudelay(10);\n\tif (!delcnt) {\n\t\tprintk(KERN_ERR \"%s: %s, status %4.4x, cmd %4.4x.\\n\",\n\t\t     dev->name, str, lp->scb.status, lp->scb.command);\n\t\treturn -1;\n\t}\n\telse\n\t\treturn 0;\n}\n\n\nstatic inline int wait_cmd(struct net_device *dev, struct i596_private *lp, int delcnt, char *str)\n{\n\twhile (--delcnt && lp->scb.command)\n\t\tudelay(10);\n\tif (!delcnt) {\n\t\tprintk(KERN_ERR \"%s: %s, status %4.4x, cmd %4.4x.\\n\",\n\t\t     dev->name, str, lp->scb.status, lp->scb.command);\n\t\treturn -1;\n\t}\n\telse\n\t\treturn 0;\n}\n\n\nstatic inline int wait_cfg(struct net_device *dev, struct i596_cmd *cmd, int delcnt, char *str)\n{\n\tvolatile struct i596_cmd *c = cmd;\n\n\twhile (--delcnt && c->command)\n\t\tudelay(10);\n\tif (!delcnt) {\n\t\tprintk(KERN_ERR \"%s: %s.\\n\", dev->name, str);\n\t\treturn -1;\n\t}\n\telse\n\t\treturn 0;\n}\n\n\nstatic void i596_display_data(struct net_device *dev)\n{\n\tstruct i596_private *lp = dev->ml_priv;\n\tstruct i596_cmd *cmd;\n\tstruct i596_rfd *rfd;\n\tstruct i596_rbd *rbd;\n\n\tprintk(KERN_ERR \"lp and scp at %p, .sysbus = %08lx, .iscp = %p\\n\",\n\t       &lp->scp, lp->scp.sysbus, lp->scp.iscp);\n\tprintk(KERN_ERR \"iscp at %p, iscp.stat = %08lx, .scb = %p\\n\",\n\t       &lp->iscp, lp->iscp.stat, lp->iscp.scb);\n\tprintk(KERN_ERR \"scb at %p, scb.status = %04x, .command = %04x,\"\n\t\t\" .cmd = %p, .rfd = %p\\n\",\n\t       &lp->scb, lp->scb.status, lp->scb.command,\n\t\tlp->scb.cmd, lp->scb.rfd);\n\tprintk(KERN_ERR \"   errors: crc %lx, align %lx, resource %lx,\"\n               \" over %lx, rcvdt %lx, short %lx\\n\",\n\t\tlp->scb.crc_err, lp->scb.align_err, lp->scb.resource_err,\n\t\tlp->scb.over_err, lp->scb.rcvdt_err, lp->scb.short_err);\n\tcmd = lp->cmd_head;\n\twhile (cmd != I596_NULL) {\n\t\tprintk(KERN_ERR \"cmd at %p, .status = %04x, .command = %04x, .b_next = %p\\n\",\n\t\t  cmd, cmd->status, cmd->command, cmd->b_next);\n\t\tcmd = cmd->v_next;\n\t}\n\trfd = lp->rfd_head;\n\tprintk(KERN_ERR \"rfd_head = %p\\n\", rfd);\n\tdo {\n\t\tprintk(KERN_ERR \"   %p .stat %04x, .cmd %04x, b_next %p, rbd %p,\"\n                        \" count %04x\\n\",\n\t\t\trfd, rfd->stat, rfd->cmd, rfd->b_next, rfd->rbd,\n\t\t\trfd->count);\n\t\trfd = rfd->v_next;\n\t} while (rfd != lp->rfd_head);\n\trbd = lp->rbd_head;\n\tprintk(KERN_ERR \"rbd_head = %p\\n\", rbd);\n\tdo {\n\t\tprintk(KERN_ERR \"   %p .count %04x, b_next %p, b_data %p, size %04x\\n\",\n\t\t\trbd, rbd->count, rbd->b_next, rbd->b_data, rbd->size);\n\t\trbd = rbd->v_next;\n\t} while (rbd != lp->rbd_head);\n}\n\n\n#if defined(ENABLE_MVME16x_NET) || defined(ENABLE_BVME6000_NET)\nstatic irqreturn_t i596_error(int irq, void *dev_id)\n{\n\tstruct net_device *dev = dev_id;\n#ifdef ENABLE_MVME16x_NET\n\tif (MACH_IS_MVME16x) {\n\t\tvolatile unsigned char *pcc2 = (unsigned char *) 0xfff42000;\n\n\t\tpcc2[0x28] = 1;\n\t\tpcc2[0x2b] = 0x1d;\n\t}\n#endif\n#ifdef ENABLE_BVME6000_NET\n\tif (MACH_IS_BVME6000) {\n\t\tvolatile unsigned char *ethirq = (unsigned char *) BVME_ETHIRQ_REG;\n\n\t\t*ethirq = 1;\n\t\t*ethirq = 3;\n\t}\n#endif\n\tprintk(KERN_ERR \"%s: Error interrupt\\n\", dev->name);\n\ti596_display_data(dev);\n\treturn IRQ_HANDLED;\n}\n#endif\n\nstatic inline void remove_rx_bufs(struct net_device *dev)\n{\n\tstruct i596_private *lp = dev->ml_priv;\n\tstruct i596_rbd *rbd;\n\tint i;\n\n\tfor (i = 0, rbd = lp->rbds; i < rx_ring_size; i++, rbd++) {\n\t\tif (rbd->skb == NULL)\n\t\t\tbreak;\n\t\tdev_kfree_skb(rbd->skb);\n\t\trbd->skb = NULL;\n\t}\n}\n\nstatic inline int init_rx_bufs(struct net_device *dev)\n{\n\tstruct i596_private *lp = dev->ml_priv;\n\tint i;\n\tstruct i596_rfd *rfd;\n\tstruct i596_rbd *rbd;\n\n\t \n\n\tfor (i = 0, rbd = lp->rbds; i < rx_ring_size; i++, rbd++) {\n\t\tstruct sk_buff *skb = netdev_alloc_skb(dev, PKT_BUF_SZ);\n\n\t\tif (skb == NULL) {\n\t\t\tremove_rx_bufs(dev);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\trbd->v_next = rbd+1;\n\t\trbd->b_next = WSWAPrbd(virt_to_bus(rbd+1));\n\t\trbd->b_addr = WSWAPrbd(virt_to_bus(rbd));\n\t\trbd->skb = skb;\n\t\trbd->v_data = skb->data;\n\t\trbd->b_data = WSWAPchar(virt_to_bus(skb->data));\n\t\trbd->size = PKT_BUF_SZ;\n#ifdef __mc68000__\n\t\tcache_clear(virt_to_phys(skb->data), PKT_BUF_SZ);\n#endif\n\t}\n\tlp->rbd_head = lp->rbds;\n\trbd = lp->rbds + rx_ring_size - 1;\n\trbd->v_next = lp->rbds;\n\trbd->b_next = WSWAPrbd(virt_to_bus(lp->rbds));\n\n\t \n\n\tfor (i = 0, rfd = lp->rfds; i < rx_ring_size; i++, rfd++) {\n\t\trfd->rbd = I596_NULL;\n\t\trfd->v_next = rfd+1;\n\t\trfd->v_prev = rfd-1;\n\t\trfd->b_next = WSWAPrfd(virt_to_bus(rfd+1));\n\t\trfd->cmd = CMD_FLEX;\n\t}\n\tlp->rfd_head = lp->rfds;\n\tlp->scb.rfd = WSWAPrfd(virt_to_bus(lp->rfds));\n\trfd = lp->rfds;\n\trfd->rbd = lp->rbd_head;\n\trfd->v_prev = lp->rfds + rx_ring_size - 1;\n\trfd = lp->rfds + rx_ring_size - 1;\n\trfd->v_next = lp->rfds;\n\trfd->b_next = WSWAPrfd(virt_to_bus(lp->rfds));\n\trfd->cmd = CMD_EOL|CMD_FLEX;\n\n\treturn 0;\n}\n\n\nstatic void rebuild_rx_bufs(struct net_device *dev)\n{\n\tstruct i596_private *lp = dev->ml_priv;\n\tint i;\n\n\t \n\n\tfor (i = 0; i < rx_ring_size; i++) {\n\t\tlp->rfds[i].rbd = I596_NULL;\n\t\tlp->rfds[i].cmd = CMD_FLEX;\n\t}\n\tlp->rfds[rx_ring_size-1].cmd = CMD_EOL|CMD_FLEX;\n\tlp->rfd_head = lp->rfds;\n\tlp->scb.rfd = WSWAPrfd(virt_to_bus(lp->rfds));\n\tlp->rbd_head = lp->rbds;\n\tlp->rfds[0].rbd = WSWAPrbd(virt_to_bus(lp->rbds));\n}\n\n\nstatic int init_i596_mem(struct net_device *dev)\n{\n\tstruct i596_private *lp = dev->ml_priv;\n\tunsigned long flags;\n\n\tMPU_PORT(dev, PORT_RESET, NULL);\n\n\tudelay(100);\t\t \n\n#if defined(ENABLE_MVME16x_NET) || defined(ENABLE_BVME6000_NET)\n#ifdef ENABLE_MVME16x_NET\n\tif (MACH_IS_MVME16x) {\n\t\tvolatile unsigned char *pcc2 = (unsigned char *) 0xfff42000;\n\n\t\t \n\t\tpcc2[0x28] = 1;\n\t\tpcc2[0x2a] = 0x48;\n\t\t \n\t\tpcc2[0x2b] = 0x08;\n\t}\n#endif\n#ifdef ENABLE_BVME6000_NET\n\tif (MACH_IS_BVME6000) {\n\t\tvolatile unsigned char *ethirq = (unsigned char *) BVME_ETHIRQ_REG;\n\n\t\t*ethirq = 1;\n\t}\n#endif\n\n\t \n\n\tMPU_PORT(dev, PORT_ALTSCP, (void *)virt_to_bus((void *)&lp->scp));\n\n#endif\n\n\tlp->last_cmd = jiffies;\n\n#ifdef ENABLE_MVME16x_NET\n\tif (MACH_IS_MVME16x)\n\t\tlp->scp.sysbus = 0x00000054;\n#endif\n#ifdef ENABLE_BVME6000_NET\n\tif (MACH_IS_BVME6000)\n\t\tlp->scp.sysbus = 0x0000004c;\n#endif\n\n\tlp->scp.iscp = WSWAPiscp(virt_to_bus((void *)&lp->iscp));\n\tlp->iscp.scb = WSWAPscb(virt_to_bus((void *)&lp->scb));\n\tlp->iscp.stat = ISCP_BUSY;\n\tlp->cmd_backlog = 0;\n\n\tlp->cmd_head = lp->scb.cmd = I596_NULL;\n\n#ifdef ENABLE_BVME6000_NET\n\tif (MACH_IS_BVME6000) {\n\t\tlp->scb.t_on  = 7 * 25;\n\t\tlp->scb.t_off = 1 * 25;\n\t}\n#endif\n\n\tDEB(DEB_INIT,printk(KERN_DEBUG \"%s: starting i82596.\\n\", dev->name));\n\n\tCA(dev);\n\n\tif (wait_istat(dev,lp,1000,\"initialization timed out\"))\n\t\tgoto failed;\n\tDEB(DEB_INIT,printk(KERN_DEBUG \"%s: i82596 initialization successful\\n\", dev->name));\n\n\t \n\trebuild_rx_bufs(dev);\n\tlp->scb.command = 0;\n\n#ifdef ENABLE_MVME16x_NET\n\tif (MACH_IS_MVME16x) {\n\t\tvolatile unsigned char *pcc2 = (unsigned char *) 0xfff42000;\n\n\t\t \n\t\tpcc2[0x2a] = 0x55;\t \n\t\tpcc2[0x2b] = 0x15;\n\t}\n#endif\n#ifdef ENABLE_BVME6000_NET\n\tif (MACH_IS_BVME6000) {\n\t\tvolatile unsigned char *ethirq = (unsigned char *) BVME_ETHIRQ_REG;\n\n\t\t*ethirq = 3;\n\t}\n#endif\n\n\n\tDEB(DEB_INIT,printk(KERN_DEBUG \"%s: queuing CmdConfigure\\n\", dev->name));\n\tmemcpy(lp->cf_cmd.i596_config, init_setup, 14);\n\tlp->cf_cmd.cmd.command = CmdConfigure;\n\ti596_add_cmd(dev, &lp->cf_cmd.cmd);\n\n\tDEB(DEB_INIT,printk(KERN_DEBUG \"%s: queuing CmdSASetup\\n\", dev->name));\n\tmemcpy(lp->sa_cmd.eth_addr, dev->dev_addr, ETH_ALEN);\n\tlp->sa_cmd.cmd.command = CmdSASetup;\n\ti596_add_cmd(dev, &lp->sa_cmd.cmd);\n\n\tDEB(DEB_INIT,printk(KERN_DEBUG \"%s: queuing CmdTDR\\n\", dev->name));\n\tlp->tdr_cmd.cmd.command = CmdTDR;\n\ti596_add_cmd(dev, &lp->tdr_cmd.cmd);\n\n\tspin_lock_irqsave (&lp->lock, flags);\n\n\tif (wait_cmd(dev,lp,1000,\"timed out waiting to issue RX_START\")) {\n\t\tspin_unlock_irqrestore (&lp->lock, flags);\n\t\tgoto failed;\n\t}\n\tDEB(DEB_INIT,printk(KERN_DEBUG \"%s: Issuing RX_START\\n\", dev->name));\n\tlp->scb.command = RX_START;\n\tCA(dev);\n\n\tspin_unlock_irqrestore (&lp->lock, flags);\n\n\tif (wait_cmd(dev,lp,1000,\"RX_START not processed\"))\n\t\tgoto failed;\n\tDEB(DEB_INIT,printk(KERN_DEBUG \"%s: Receive unit started OK\\n\", dev->name));\n\treturn 0;\n\nfailed:\n\tprintk(KERN_CRIT \"%s: Failed to initialise 82596\\n\", dev->name);\n\tMPU_PORT(dev, PORT_RESET, NULL);\n\treturn -1;\n}\n\nstatic inline int i596_rx(struct net_device *dev)\n{\n\tstruct i596_private *lp = dev->ml_priv;\n\tstruct i596_rfd *rfd;\n\tstruct i596_rbd *rbd;\n\tint frames = 0;\n\n\tDEB(DEB_RXFRAME,printk(KERN_DEBUG \"i596_rx(), rfd_head %p, rbd_head %p\\n\",\n\t\t\tlp->rfd_head, lp->rbd_head));\n\n\trfd = lp->rfd_head;\t\t \n\n\twhile ((rfd->stat) & STAT_C) {\t \n\t\tif (rfd->rbd == I596_NULL)\n\t\t\trbd = I596_NULL;\n\t\telse if (rfd->rbd == lp->rbd_head->b_addr)\n\t\t\trbd = lp->rbd_head;\n\t\telse {\n\t\t\tprintk(KERN_CRIT \"%s: rbd chain broken!\\n\", dev->name);\n\t\t\t \n\t\t\trbd = I596_NULL;\n\t\t}\n\t\tDEB(DEB_RXFRAME, printk(KERN_DEBUG \"  rfd %p, rfd.rbd %p, rfd.stat %04x\\n\",\n\t\t\trfd, rfd->rbd, rfd->stat));\n\n\t\tif (rbd != I596_NULL && ((rfd->stat) & STAT_OK)) {\n\t\t\t \n\t\t\tint pkt_len = rbd->count & 0x3fff;\n\t\t\tstruct sk_buff *skb = rbd->skb;\n\t\t\tint rx_in_place = 0;\n\n\t\t\tDEB(DEB_RXADDR,print_eth(rbd->v_data, \"received\"));\n\t\t\tframes++;\n\n\t\t\t \n\n\t\t\tif (pkt_len > rx_copybreak) {\n\t\t\t\tstruct sk_buff *newskb;\n\n\t\t\t\t \n\t\t\t\tnewskb = netdev_alloc_skb(dev, PKT_BUF_SZ);\n\t\t\t\tif (newskb == NULL) {\n\t\t\t\t\tskb = NULL;\t \n\t\t\t\t\tgoto memory_squeeze;\n\t\t\t\t}\n\t\t\t\t \n\t\t\t\tskb_put(skb, pkt_len);\n\t\t\t\trx_in_place = 1;\n\t\t\t\trbd->skb = newskb;\n\t\t\t\trbd->v_data = newskb->data;\n\t\t\t\trbd->b_data = WSWAPchar(virt_to_bus(newskb->data));\n#ifdef __mc68000__\n\t\t\t\tcache_clear(virt_to_phys(newskb->data), PKT_BUF_SZ);\n#endif\n\t\t\t} else {\n\t\t\t\tskb = netdev_alloc_skb(dev, pkt_len + 2);\n\t\t\t}\nmemory_squeeze:\n\t\t\tif (skb == NULL) {\n\t\t\t\t \n\t\t\t\tdev->stats.rx_dropped++;\n\t\t\t} else {\n\t\t\t\tif (!rx_in_place) {\n\t\t\t\t\t \n\t\t\t\t\tskb_reserve(skb, 2);\n\t\t\t\t\tskb_put_data(skb, rbd->v_data,\n\t\t\t\t\t\t     pkt_len);\n\t\t\t\t}\n\t\t\t\tskb->protocol=eth_type_trans(skb,dev);\n\t\t\t\tskb->len = pkt_len;\n#ifdef __mc68000__\n\t\t\t\tcache_clear(virt_to_phys(rbd->skb->data),\n\t\t\t\t\t\tpkt_len);\n#endif\n\t\t\t\tnetif_rx(skb);\n\t\t\t\tdev->stats.rx_packets++;\n\t\t\t\tdev->stats.rx_bytes+=pkt_len;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tDEB(DEB_ERRORS, printk(KERN_DEBUG \"%s: Error, rfd.stat = 0x%04x\\n\",\n\t\t\t\t\tdev->name, rfd->stat));\n\t\t\tdev->stats.rx_errors++;\n\t\t\tif ((rfd->stat) & 0x0001)\n\t\t\t\tdev->stats.collisions++;\n\t\t\tif ((rfd->stat) & 0x0080)\n\t\t\t\tdev->stats.rx_length_errors++;\n\t\t\tif ((rfd->stat) & 0x0100)\n\t\t\t\tdev->stats.rx_over_errors++;\n\t\t\tif ((rfd->stat) & 0x0200)\n\t\t\t\tdev->stats.rx_fifo_errors++;\n\t\t\tif ((rfd->stat) & 0x0400)\n\t\t\t\tdev->stats.rx_frame_errors++;\n\t\t\tif ((rfd->stat) & 0x0800)\n\t\t\t\tdev->stats.rx_crc_errors++;\n\t\t\tif ((rfd->stat) & 0x1000)\n\t\t\t\tdev->stats.rx_length_errors++;\n\t\t}\n\n\t\t \n\n\t\tif (rbd != I596_NULL && (rbd->count & 0x4000)) {\n\t\t\trbd->count = 0;\n\t\t\tlp->rbd_head = rbd->v_next;\n\t\t}\n\n\t\t \n\n\t\trfd->rbd = I596_NULL;\n\t\trfd->stat = 0;\n\t\trfd->cmd = CMD_EOL|CMD_FLEX;\n\t\trfd->count = 0;\n\n\t\t \n\n\t\trfd->v_prev->cmd = CMD_FLEX;\n\n\t\t \n\n\t\tlp->scb.rfd = rfd->b_next;\n\t\tlp->rfd_head = rfd->v_next;\n\t\trfd = lp->rfd_head;\n\t}\n\n\tDEB(DEB_RXFRAME,printk(KERN_DEBUG \"frames %d\\n\", frames));\n\n\treturn 0;\n}\n\n\nstatic void i596_cleanup_cmd(struct net_device *dev, struct i596_private *lp)\n{\n\tstruct i596_cmd *ptr;\n\n\twhile (lp->cmd_head != I596_NULL) {\n\t\tptr = lp->cmd_head;\n\t\tlp->cmd_head = ptr->v_next;\n\t\tlp->cmd_backlog--;\n\n\t\tswitch ((ptr->command) & 0x7) {\n\t\tcase CmdTx:\n\t\t\t{\n\t\t\t\tstruct tx_cmd *tx_cmd = (struct tx_cmd *) ptr;\n\t\t\t\tstruct sk_buff *skb = tx_cmd->skb;\n\n\t\t\t\tdev_kfree_skb(skb);\n\n\t\t\t\tdev->stats.tx_errors++;\n\t\t\t\tdev->stats.tx_aborted_errors++;\n\n\t\t\t\tptr->v_next = ptr->b_next = I596_NULL;\n\t\t\t\ttx_cmd->cmd.command = 0;   \n\t\t\t\tbreak;\n\t\t\t}\n\t\tdefault:\n\t\t\tptr->v_next = ptr->b_next = I596_NULL;\n\t\t}\n\t}\n\n\twait_cmd(dev,lp,100,\"i596_cleanup_cmd timed out\");\n\tlp->scb.cmd = I596_NULL;\n}\n\nstatic void i596_reset(struct net_device *dev, struct i596_private *lp,\n\t\t\tint ioaddr)\n{\n\tunsigned long flags;\n\n\tDEB(DEB_RESET,printk(KERN_DEBUG \"i596_reset\\n\"));\n\n\tspin_lock_irqsave (&lp->lock, flags);\n\n\twait_cmd(dev,lp,100,\"i596_reset timed out\");\n\n\tnetif_stop_queue(dev);\n\n\tlp->scb.command = CUC_ABORT | RX_ABORT;\n\tCA(dev);\n\n\t \n\twait_cmd(dev,lp,1000,\"i596_reset 2 timed out\");\n\tspin_unlock_irqrestore (&lp->lock, flags);\n\n\ti596_cleanup_cmd(dev,lp);\n\ti596_rx(dev);\n\n\tnetif_start_queue(dev);\n\tinit_i596_mem(dev);\n}\n\nstatic void i596_add_cmd(struct net_device *dev, struct i596_cmd *cmd)\n{\n\tstruct i596_private *lp = dev->ml_priv;\n\tint ioaddr = dev->base_addr;\n\tunsigned long flags;\n\n\tDEB(DEB_ADDCMD,printk(KERN_DEBUG \"i596_add_cmd\\n\"));\n\n\tcmd->status = 0;\n\tcmd->command |= (CMD_EOL | CMD_INTR);\n\tcmd->v_next = cmd->b_next = I596_NULL;\n\n\tspin_lock_irqsave (&lp->lock, flags);\n\n\tif (lp->cmd_head != I596_NULL) {\n\t\tlp->cmd_tail->v_next = cmd;\n\t\tlp->cmd_tail->b_next = WSWAPcmd(virt_to_bus(&cmd->status));\n\t} else {\n\t\tlp->cmd_head = cmd;\n\t\twait_cmd(dev,lp,100,\"i596_add_cmd timed out\");\n\t\tlp->scb.cmd = WSWAPcmd(virt_to_bus(&cmd->status));\n\t\tlp->scb.command = CUC_START;\n\t\tCA(dev);\n\t}\n\tlp->cmd_tail = cmd;\n\tlp->cmd_backlog++;\n\n\tspin_unlock_irqrestore (&lp->lock, flags);\n\n\tif (lp->cmd_backlog > max_cmd_backlog) {\n\t\tunsigned long tickssofar = jiffies - lp->last_cmd;\n\n\t\tif (tickssofar < ticks_limit)\n\t\t\treturn;\n\n\t\tprintk(KERN_NOTICE \"%s: command unit timed out, status resetting.\\n\", dev->name);\n\n\t\ti596_reset(dev, lp, ioaddr);\n\t}\n}\n\nstatic int i596_open(struct net_device *dev)\n{\n\tint res = 0;\n\n\tDEB(DEB_OPEN,printk(KERN_DEBUG \"%s: i596_open() irq %d.\\n\", dev->name, dev->irq));\n\n\tif (request_irq(dev->irq, i596_interrupt, 0, \"i82596\", dev)) {\n\t\tprintk(KERN_ERR \"%s: IRQ %d not free\\n\", dev->name, dev->irq);\n\t\treturn -EAGAIN;\n\t}\n#ifdef ENABLE_MVME16x_NET\n\tif (MACH_IS_MVME16x) {\n\t\tif (request_irq(0x56, i596_error, 0, \"i82596_error\", dev)) {\n\t\t\tres = -EAGAIN;\n\t\t\tgoto err_irq_dev;\n\t\t}\n\t}\n#endif\n\tres = init_rx_bufs(dev);\n\tif (res)\n\t\tgoto err_irq_56;\n\n\tnetif_start_queue(dev);\n\n\tif (init_i596_mem(dev)) {\n\t\tres = -EAGAIN;\n\t\tgoto err_queue;\n\t}\n\n\treturn 0;\n\nerr_queue:\n\tnetif_stop_queue(dev);\n\tremove_rx_bufs(dev);\nerr_irq_56:\n#ifdef ENABLE_MVME16x_NET\n\tfree_irq(0x56, dev);\nerr_irq_dev:\n#endif\n\tfree_irq(dev->irq, dev);\n\n\treturn res;\n}\n\nstatic void i596_tx_timeout (struct net_device *dev, unsigned int txqueue)\n{\n\tstruct i596_private *lp = dev->ml_priv;\n\tint ioaddr = dev->base_addr;\n\n\t \n\tDEB(DEB_ERRORS,printk(KERN_ERR \"%s: transmit timed out, status resetting.\\n\",\n\t\t\tdev->name));\n\n\tdev->stats.tx_errors++;\n\n\t \n\tif (lp->last_restart == dev->stats.tx_packets) {\n\t\tDEB(DEB_ERRORS,printk(KERN_ERR \"Resetting board.\\n\"));\n\t\t \n\t\ti596_reset (dev, lp, ioaddr);\n\t} else {\n\t\t \n\t\tDEB(DEB_ERRORS,printk(KERN_ERR \"Kicking board.\\n\"));\n\t\tlp->scb.command = CUC_START | RX_START;\n\t\tCA (dev);\n\t\tlp->last_restart = dev->stats.tx_packets;\n\t}\n\n\tnetif_trans_update(dev);  \n\tnetif_wake_queue (dev);\n}\n\nstatic netdev_tx_t i596_start_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct i596_private *lp = dev->ml_priv;\n\tstruct tx_cmd *tx_cmd;\n\tstruct i596_tbd *tbd;\n\tshort length = skb->len;\n\n\tDEB(DEB_STARTTX,printk(KERN_DEBUG \"%s: i596_start_xmit(%x,%p) called\\n\",\n\t\t\t\tdev->name, skb->len, skb->data));\n\n\tif (skb->len < ETH_ZLEN) {\n\t\tif (skb_padto(skb, ETH_ZLEN))\n\t\t\treturn NETDEV_TX_OK;\n\t\tlength = ETH_ZLEN;\n\t}\n\tnetif_stop_queue(dev);\n\n\ttx_cmd = lp->tx_cmds + lp->next_tx_cmd;\n\ttbd = lp->tbds + lp->next_tx_cmd;\n\n\tif (tx_cmd->cmd.command) {\n\t\tprintk(KERN_NOTICE \"%s: xmit ring full, dropping packet.\\n\",\n\t\t\t\tdev->name);\n\t\tdev->stats.tx_dropped++;\n\n\t\tdev_kfree_skb(skb);\n\t} else {\n\t\tif (++lp->next_tx_cmd == TX_RING_SIZE)\n\t\t\tlp->next_tx_cmd = 0;\n\t\ttx_cmd->tbd = WSWAPtbd(virt_to_bus(tbd));\n\t\ttbd->next = I596_NULL;\n\n\t\ttx_cmd->cmd.command = CMD_FLEX | CmdTx;\n\t\ttx_cmd->skb = skb;\n\n\t\ttx_cmd->pad = 0;\n\t\ttx_cmd->size = 0;\n\t\ttbd->pad = 0;\n\t\ttbd->size = EOF | length;\n\n\t\ttbd->data = WSWAPchar(virt_to_bus(skb->data));\n\n#ifdef __mc68000__\n\t\tcache_push(virt_to_phys(skb->data), length);\n#endif\n\t\tDEB(DEB_TXADDR,print_eth(skb->data, \"tx-queued\"));\n\t\ti596_add_cmd(dev, &tx_cmd->cmd);\n\n\t\tdev->stats.tx_packets++;\n\t\tdev->stats.tx_bytes += length;\n\t}\n\n\tnetif_start_queue(dev);\n\n\treturn NETDEV_TX_OK;\n}\n\nstatic void print_eth(unsigned char *add, char *str)\n{\n\tprintk(KERN_DEBUG \"i596 0x%p, %pM --> %pM %02X%02X, %s\\n\",\n\t       add, add + 6, add, add[12], add[13], str);\n}\n\nstatic const struct net_device_ops i596_netdev_ops = {\n\t.ndo_open \t\t= i596_open,\n\t.ndo_stop\t\t= i596_close,\n\t.ndo_start_xmit\t\t= i596_start_xmit,\n\t.ndo_set_rx_mode\t= set_multicast_list,\n\t.ndo_tx_timeout\t\t= i596_tx_timeout,\n\t.ndo_set_mac_address \t= eth_mac_addr,\n\t.ndo_validate_addr\t= eth_validate_addr,\n};\n\nstatic struct net_device * __init i82596_probe(void)\n{\n\tstruct net_device *dev;\n\tint i;\n\tstruct i596_private *lp;\n\tchar eth_addr[8];\n\tstatic int probed;\n\tint err;\n\n\tif (probed)\n\t\treturn ERR_PTR(-ENODEV);\n\tprobed++;\n\n\tdev = alloc_etherdev(0);\n\tif (!dev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n#ifdef ENABLE_MVME16x_NET\n\tif (MACH_IS_MVME16x) {\n\t\tif (mvme16x_config & MVME16x_CONFIG_NO_ETHERNET) {\n\t\t\tprintk(KERN_NOTICE \"Ethernet probe disabled - chip not present\\n\");\n\t\t\terr = -ENODEV;\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(eth_addr, absolute_pointer(0xfffc1f2c), ETH_ALEN);  \n\t\tdev->base_addr = MVME_I596_BASE;\n\t\tdev->irq = (unsigned) MVME16x_IRQ_I596;\n\t\tgoto found;\n\t}\n#endif\n#ifdef ENABLE_BVME6000_NET\n\tif (MACH_IS_BVME6000) {\n\t\tvolatile unsigned char *rtc = (unsigned char *) BVME_RTC_BASE;\n\t\tunsigned char msr = rtc[3];\n\t\tint i;\n\n\t\trtc[3] |= 0x80;\n\t\tfor (i = 0; i < 6; i++)\n\t\t\teth_addr[i] = rtc[i * 4 + 7];\t \n\t\trtc[3] = msr;\n\t\tdev->base_addr = BVME_I596_BASE;\n\t\tdev->irq = (unsigned) BVME_IRQ_I596;\n\t\tgoto found;\n\t}\n#endif\n\terr = -ENODEV;\n\tgoto out;\n\nfound:\n\tdev->mem_start = (int)__get_free_pages(GFP_ATOMIC, 0);\n\tif (!dev->mem_start) {\n\t\terr = -ENOMEM;\n\t\tgoto out1;\n\t}\n\n\tDEB(DEB_PROBE,printk(KERN_INFO \"%s: 82596 at %#3lx,\", dev->name, dev->base_addr));\n\n\tfor (i = 0; i < 6; i++)\n\t\tDEB(DEB_PROBE,printk(\" %2.2X\", eth_addr[i]));\n\teth_hw_addr_set(dev, eth_addr);\n\n\tDEB(DEB_PROBE,printk(\" IRQ %d.\\n\", dev->irq));\n\n\tDEB(DEB_PROBE,printk(KERN_INFO \"%s\", version));\n\n\t \n\tdev->netdev_ops = &i596_netdev_ops;\n\tdev->watchdog_timeo = TX_TIMEOUT;\n\n\tdev->ml_priv = (void *)(dev->mem_start);\n\n\tlp = dev->ml_priv;\n\tDEB(DEB_INIT,printk(KERN_DEBUG \"%s: lp at 0x%08lx (%zd bytes), \"\n\t\t\t\"lp->scb at 0x%08lx\\n\",\n\t\t\tdev->name, (unsigned long)lp,\n\t\t\tsizeof(struct i596_private), (unsigned long)&lp->scb));\n\tmemset((void *) lp, 0, sizeof(struct i596_private));\n\n#ifdef __mc68000__\n\tcache_push(virt_to_phys((void *)(dev->mem_start)), 4096);\n\tcache_clear(virt_to_phys((void *)(dev->mem_start)), 4096);\n\tkernel_set_cachemode((void *)(dev->mem_start), 4096, IOMAP_NOCACHE_SER);\n#endif\n\tlp->scb.command = 0;\n\tlp->scb.cmd = I596_NULL;\n\tlp->scb.rfd = I596_NULL;\n\tspin_lock_init(&lp->lock);\n\n\terr = register_netdev(dev);\n\tif (err)\n\t\tgoto out2;\n\treturn dev;\nout2:\n#ifdef __mc68000__\n\t \n\tkernel_set_cachemode((void *)(dev->mem_start), 4096,\n\t\t\tIOMAP_FULL_CACHING);\n#endif\n\tfree_page ((u32)(dev->mem_start));\nout1:\nout:\n\tfree_netdev(dev);\n\treturn ERR_PTR(err);\n}\n\nstatic irqreturn_t i596_interrupt(int irq, void *dev_id)\n{\n\tstruct net_device *dev = dev_id;\n\tstruct i596_private *lp;\n\tshort ioaddr;\n\tunsigned short status, ack_cmd = 0;\n\tint handled = 0;\n\n#ifdef ENABLE_BVME6000_NET\n\tif (MACH_IS_BVME6000) {\n\t\tif (*(char *) BVME_LOCAL_IRQ_STAT & BVME_ETHERR) {\n\t\t\ti596_error(irq, dev_id);\n\t\t\treturn IRQ_HANDLED;\n\t\t}\n\t}\n#endif\n\tif (dev == NULL) {\n\t\tprintk(KERN_ERR \"i596_interrupt(): irq %d for unknown device.\\n\", irq);\n\t\treturn IRQ_NONE;\n\t}\n\n\tioaddr = dev->base_addr;\n\tlp = dev->ml_priv;\n\n\tspin_lock (&lp->lock);\n\n\twait_cmd(dev,lp,100,\"i596 interrupt, timeout\");\n\tstatus = lp->scb.status;\n\n\tDEB(DEB_INTS,printk(KERN_DEBUG \"%s: i596 interrupt, IRQ %d, status %4.4x.\\n\",\n\t\t\tdev->name, irq, status));\n\n\tack_cmd = status & 0xf000;\n\n\tif ((status & 0x8000) || (status & 0x2000)) {\n\t\tstruct i596_cmd *ptr;\n\n\t\thandled = 1;\n\t\tif ((status & 0x8000))\n\t\t\tDEB(DEB_INTS,printk(KERN_DEBUG \"%s: i596 interrupt completed command.\\n\", dev->name));\n\t\tif ((status & 0x2000))\n\t\t\tDEB(DEB_INTS,printk(KERN_DEBUG \"%s: i596 interrupt command unit inactive %x.\\n\", dev->name, status & 0x0700));\n\n\t\twhile ((lp->cmd_head != I596_NULL) && (lp->cmd_head->status & STAT_C)) {\n\t\t\tptr = lp->cmd_head;\n\n\t\t\tDEB(DEB_STATUS,printk(KERN_DEBUG \"cmd_head->status = %04x, ->command = %04x\\n\",\n\t\t\t\t       lp->cmd_head->status, lp->cmd_head->command));\n\t\t\tlp->cmd_head = ptr->v_next;\n\t\t\tlp->cmd_backlog--;\n\n\t\t\tswitch ((ptr->command) & 0x7) {\n\t\t\tcase CmdTx:\n\t\t\t    {\n\t\t\t\tstruct tx_cmd *tx_cmd = (struct tx_cmd *) ptr;\n\t\t\t\tstruct sk_buff *skb = tx_cmd->skb;\n\n\t\t\t\tif ((ptr->status) & STAT_OK) {\n\t\t\t\t\tDEB(DEB_TXADDR,print_eth(skb->data, \"tx-done\"));\n\t\t\t\t} else {\n\t\t\t\t\tdev->stats.tx_errors++;\n\t\t\t\t\tif ((ptr->status) & 0x0020)\n\t\t\t\t\t\tdev->stats.collisions++;\n\t\t\t\t\tif (!((ptr->status) & 0x0040))\n\t\t\t\t\t\tdev->stats.tx_heartbeat_errors++;\n\t\t\t\t\tif ((ptr->status) & 0x0400)\n\t\t\t\t\t\tdev->stats.tx_carrier_errors++;\n\t\t\t\t\tif ((ptr->status) & 0x0800)\n\t\t\t\t\t\tdev->stats.collisions++;\n\t\t\t\t\tif ((ptr->status) & 0x1000)\n\t\t\t\t\t\tdev->stats.tx_aborted_errors++;\n\t\t\t\t}\n\n\t\t\t\tdev_consume_skb_irq(skb);\n\n\t\t\t\ttx_cmd->cmd.command = 0;  \n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\tcase CmdTDR:\n\t\t\t    {\n\t\t\t\tunsigned short status = ((struct tdr_cmd *)ptr)->status;\n\n\t\t\t\tif (status & 0x8000) {\n\t\t\t\t\tDEB(DEB_TDR,printk(KERN_INFO \"%s: link ok.\\n\", dev->name));\n\t\t\t\t} else {\n\t\t\t\t\tif (status & 0x4000)\n\t\t\t\t\t\tprintk(KERN_ERR \"%s: Transceiver problem.\\n\", dev->name);\n\t\t\t\t\tif (status & 0x2000)\n\t\t\t\t\t\tprintk(KERN_ERR \"%s: Termination problem.\\n\", dev->name);\n\t\t\t\t\tif (status & 0x1000)\n\t\t\t\t\t\tprintk(KERN_ERR \"%s: Short circuit.\\n\", dev->name);\n\n\t\t\t\t\tDEB(DEB_TDR,printk(KERN_INFO \"%s: Time %d.\\n\", dev->name, status & 0x07ff));\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\tcase CmdConfigure:\n\t\t\tcase CmdMulticastList:\n\t\t\t\t \n\t\t\t\tptr->command = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tptr->v_next = ptr->b_next = I596_NULL;\n\t\t\tlp->last_cmd = jiffies;\n\t\t}\n\n\t\tptr = lp->cmd_head;\n\t\twhile ((ptr != I596_NULL) && (ptr != lp->cmd_tail)) {\n\t\t\tptr->command &= 0x1fff;\n\t\t\tptr = ptr->v_next;\n\t\t}\n\n\t\tif ((lp->cmd_head != I596_NULL))\n\t\t\tack_cmd |= CUC_START;\n\t\tlp->scb.cmd = WSWAPcmd(virt_to_bus(&lp->cmd_head->status));\n\t}\n\tif ((status & 0x1000) || (status & 0x4000)) {\n\t\tif ((status & 0x4000))\n\t\t\tDEB(DEB_INTS,printk(KERN_DEBUG \"%s: i596 interrupt received a frame.\\n\", dev->name));\n\t\ti596_rx(dev);\n\t\t \n\t\tif (status & 0x1000) {\n\t\t\tif (netif_running(dev)) {\n\t\t\t\tDEB(DEB_ERRORS,printk(KERN_ERR \"%s: i596 interrupt receive unit inactive, status 0x%x\\n\", dev->name, status));\n\t\t\t\tack_cmd |= RX_START;\n\t\t\t\tdev->stats.rx_errors++;\n\t\t\t\tdev->stats.rx_fifo_errors++;\n\t\t\t\trebuild_rx_bufs(dev);\n\t\t\t}\n\t\t}\n\t}\n\twait_cmd(dev,lp,100,\"i596 interrupt, timeout\");\n\tlp->scb.command = ack_cmd;\n\n#ifdef ENABLE_MVME16x_NET\n\tif (MACH_IS_MVME16x) {\n\t\t \n\n\t\tvolatile unsigned char *pcc2 = (unsigned char *) 0xfff42000;\n\n\t\tpcc2[0x2a] |= 0x08;\n\t}\n#endif\n#ifdef ENABLE_BVME6000_NET\n\tif (MACH_IS_BVME6000) {\n\t\tvolatile unsigned char *ethirq = (unsigned char *) BVME_ETHIRQ_REG;\n\n\t\t*ethirq = 1;\n\t\t*ethirq = 3;\n\t}\n#endif\n\tCA(dev);\n\n\tDEB(DEB_INTS,printk(KERN_DEBUG \"%s: exiting interrupt.\\n\", dev->name));\n\n\tspin_unlock (&lp->lock);\n\treturn IRQ_RETVAL(handled);\n}\n\nstatic int i596_close(struct net_device *dev)\n{\n\tstruct i596_private *lp = dev->ml_priv;\n\tunsigned long flags;\n\n\tnetif_stop_queue(dev);\n\n\tDEB(DEB_INIT,printk(KERN_DEBUG \"%s: Shutting down ethercard, status was %4.4x.\\n\",\n\t\t       dev->name, lp->scb.status));\n\n\tspin_lock_irqsave(&lp->lock, flags);\n\n\twait_cmd(dev,lp,100,\"close1 timed out\");\n\tlp->scb.command = CUC_ABORT | RX_ABORT;\n\tCA(dev);\n\n\twait_cmd(dev,lp,100,\"close2 timed out\");\n\n\tspin_unlock_irqrestore(&lp->lock, flags);\n\tDEB(DEB_STRUCT,i596_display_data(dev));\n\ti596_cleanup_cmd(dev,lp);\n\n#ifdef ENABLE_MVME16x_NET\n\tif (MACH_IS_MVME16x) {\n\t\tvolatile unsigned char *pcc2 = (unsigned char *) 0xfff42000;\n\n\t\t \n\t\tpcc2[0x28] = 1;\n\t\tpcc2[0x2a] = 0x40;\n\t\tpcc2[0x2b] = 0x40;\t \n\t}\n#endif\n#ifdef ENABLE_BVME6000_NET\n\tif (MACH_IS_BVME6000) {\n\t\tvolatile unsigned char *ethirq = (unsigned char *) BVME_ETHIRQ_REG;\n\n\t\t*ethirq = 1;\n\t}\n#endif\n\n#ifdef ENABLE_MVME16x_NET\n\tfree_irq(0x56, dev);\n#endif\n\tfree_irq(dev->irq, dev);\n\tremove_rx_bufs(dev);\n\n\treturn 0;\n}\n\n \n\nstatic void set_multicast_list(struct net_device *dev)\n{\n\tstruct i596_private *lp = dev->ml_priv;\n\tint config = 0, cnt;\n\n\tDEB(DEB_MULTI,printk(KERN_DEBUG \"%s: set multicast list, %d entries, promisc %s, allmulti %s\\n\",\n\t\tdev->name, netdev_mc_count(dev),\n\t\tdev->flags & IFF_PROMISC  ? \"ON\" : \"OFF\",\n\t\tdev->flags & IFF_ALLMULTI ? \"ON\" : \"OFF\"));\n\n\tif (wait_cfg(dev, &lp->cf_cmd.cmd, 1000, \"config change request timed out\"))\n\t\treturn;\n\n\tif ((dev->flags & IFF_PROMISC) && !(lp->cf_cmd.i596_config[8] & 0x01)) {\n\t\tlp->cf_cmd.i596_config[8] |= 0x01;\n\t\tconfig = 1;\n\t}\n\tif (!(dev->flags & IFF_PROMISC) && (lp->cf_cmd.i596_config[8] & 0x01)) {\n\t\tlp->cf_cmd.i596_config[8] &= ~0x01;\n\t\tconfig = 1;\n\t}\n\tif ((dev->flags & IFF_ALLMULTI) && (lp->cf_cmd.i596_config[11] & 0x20)) {\n\t\tlp->cf_cmd.i596_config[11] &= ~0x20;\n\t\tconfig = 1;\n\t}\n\tif (!(dev->flags & IFF_ALLMULTI) && !(lp->cf_cmd.i596_config[11] & 0x20)) {\n\t\tlp->cf_cmd.i596_config[11] |= 0x20;\n\t\tconfig = 1;\n\t}\n\tif (config) {\n\t\tlp->cf_cmd.cmd.command = CmdConfigure;\n\t\ti596_add_cmd(dev, &lp->cf_cmd.cmd);\n\t}\n\n\tcnt = netdev_mc_count(dev);\n\tif (cnt > MAX_MC_CNT)\n\t{\n\t\tcnt = MAX_MC_CNT;\n\t\tprintk(KERN_ERR \"%s: Only %d multicast addresses supported\",\n\t\t\tdev->name, cnt);\n\t}\n\n\tif (!netdev_mc_empty(dev)) {\n\t\tstruct netdev_hw_addr *ha;\n\t\tunsigned char *cp;\n\t\tstruct mc_cmd *cmd;\n\n\t\tif (wait_cfg(dev, &lp->mc_cmd.cmd, 1000, \"multicast list change request timed out\"))\n\t\t\treturn;\n\t\tcmd = &lp->mc_cmd;\n\t\tcmd->cmd.command = CmdMulticastList;\n\t\tcmd->mc_cnt = cnt * ETH_ALEN;\n\t\tcp = cmd->mc_addrs;\n\t\tnetdev_for_each_mc_addr(ha, dev) {\n\t\t\tif (!cnt--)\n\t\t\t\tbreak;\n\t\t\tmemcpy(cp, ha->addr, ETH_ALEN);\n\t\t\tif (i596_debug > 1)\n\t\t\t\tDEB(DEB_MULTI,printk(KERN_INFO \"%s: Adding address %pM\\n\",\n\t\t\t\t\t\tdev->name, cp));\n\t\t\tcp += ETH_ALEN;\n\t\t}\n\t\ti596_add_cmd(dev, &cmd->cmd);\n\t}\n}\n\nstatic struct net_device *dev_82596;\n\nstatic int debug = -1;\nmodule_param(debug, int, 0);\nMODULE_PARM_DESC(debug, \"i82596 debug mask\");\n\nstatic int __init i82596_init(void)\n{\n\tif (debug >= 0)\n\t\ti596_debug = debug;\n\tdev_82596 = i82596_probe();\n\treturn PTR_ERR_OR_ZERO(dev_82596);\n}\nmodule_init(i82596_init);\n\nstatic void __exit i82596_cleanup(void)\n{\n\tunregister_netdev(dev_82596);\n#ifdef __mc68000__\n\t \n\n\tkernel_set_cachemode((void *)(dev_82596->mem_start), 4096,\n\t\t\tIOMAP_FULL_CACHING);\n#endif\n\tfree_page ((u32)(dev_82596->mem_start));\n\tfree_netdev(dev_82596);\n}\nmodule_exit(i82596_cleanup);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}