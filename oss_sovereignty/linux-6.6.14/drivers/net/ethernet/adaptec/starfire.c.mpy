{
  "module_name": "starfire.c",
  "hash_id": "ab8e384446d5c16022afaf2c075bdc939e8f4f8cf4fc4970cec3c7ca0bc9ef54",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/adaptec/starfire.c",
  "human_readable_source": " \n \n\n#define DRV_NAME\t\"starfire\"\n\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/pci.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/crc32.h>\n#include <linux/ethtool.h>\n#include <linux/mii.h>\n#include <linux/if_vlan.h>\n#include <linux/mm.h>\n#include <linux/firmware.h>\n#include <asm/processor.h>\t\t \n#include <linux/uaccess.h>\n#include <asm/io.h>\n\n \n#define HAS_BROKEN_FIRMWARE\n\n \n#ifdef HAS_BROKEN_FIRMWARE\n#define PADDING_MASK 3\n#endif\n\n \n#define ZEROCOPY\n\n#if IS_ENABLED(CONFIG_VLAN_8021Q)\n#define VLAN_SUPPORT\n#endif\n\n \n\n \nstatic int intr_latency;\nstatic int small_frames;\n\nstatic int debug = 1;\t\t\t \nstatic int max_interrupt_work = 20;\nstatic int mtu;\n \nstatic const int multicast_filter_limit = 512;\n \nstatic int enable_hw_cksum = 1;\n\n#define PKT_BUF_SZ\t1536\t\t \n \n#if defined(__ia64__) || defined(__alpha__) || defined(__sparc__)\nstatic int rx_copybreak = PKT_BUF_SZ;\n#else\nstatic int rx_copybreak  ;\n#endif\n\n \n#ifdef __sparc__\n#define DMA_BURST_SIZE 64\n#else\n#define DMA_BURST_SIZE 128\n#endif\n\n \n\n \n#define RX_RING_SIZE\t256\n#define TX_RING_SIZE\t32\n \n#define DONE_Q_SIZE\t1024\n \n#define QUEUE_ALIGN\t256\n\n#if RX_RING_SIZE > 256\n#define RX_Q_ENTRIES Rx2048QEntries\n#else\n#define RX_Q_ENTRIES Rx256QEntries\n#endif\n\n \n \n#define TX_TIMEOUT\t(2 * HZ)\n\n#ifdef CONFIG_ARCH_DMA_ADDR_T_64BIT\n \n#define ADDR_64BITS\t \n#define netdrv_addr_t __le64\n#define cpu_to_dma(x) cpu_to_le64(x)\n#define dma_to_cpu(x) le64_to_cpu(x)\n#define RX_DESC_Q_ADDR_SIZE RxDescQAddr64bit\n#define TX_DESC_Q_ADDR_SIZE TxDescQAddr64bit\n#define RX_COMPL_Q_ADDR_SIZE RxComplQAddr64bit\n#define TX_COMPL_Q_ADDR_SIZE TxComplQAddr64bit\n#define RX_DESC_ADDR_SIZE RxDescAddr64bit\n#else   \n#define netdrv_addr_t __le32\n#define cpu_to_dma(x) cpu_to_le32(x)\n#define dma_to_cpu(x) le32_to_cpu(x)\n#define RX_DESC_Q_ADDR_SIZE RxDescQAddr32bit\n#define TX_DESC_Q_ADDR_SIZE TxDescQAddr32bit\n#define RX_COMPL_Q_ADDR_SIZE RxComplQAddr32bit\n#define TX_COMPL_Q_ADDR_SIZE TxComplQAddr32bit\n#define RX_DESC_ADDR_SIZE RxDescAddr32bit\n#endif\n\n#define skb_first_frag_len(skb)\tskb_headlen(skb)\n#define skb_num_frags(skb) (skb_shinfo(skb)->nr_frags + 1)\n\n \n#define FIRMWARE_RX\t\"adaptec/starfire_rx.bin\"\n#define FIRMWARE_TX\t\"adaptec/starfire_tx.bin\"\n\nMODULE_AUTHOR(\"Donald Becker <becker@scyld.com>\");\nMODULE_DESCRIPTION(\"Adaptec Starfire Ethernet driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_FIRMWARE(FIRMWARE_RX);\nMODULE_FIRMWARE(FIRMWARE_TX);\n\nmodule_param(max_interrupt_work, int, 0);\nmodule_param(mtu, int, 0);\nmodule_param(debug, int, 0);\nmodule_param(rx_copybreak, int, 0);\nmodule_param(intr_latency, int, 0);\nmodule_param(small_frames, int, 0);\nmodule_param(enable_hw_cksum, int, 0);\nMODULE_PARM_DESC(max_interrupt_work, \"Maximum events handled per interrupt\");\nMODULE_PARM_DESC(mtu, \"MTU (all boards)\");\nMODULE_PARM_DESC(debug, \"Debug level (0-6)\");\nMODULE_PARM_DESC(rx_copybreak, \"Copy breakpoint for copy-only-tiny-frames\");\nMODULE_PARM_DESC(intr_latency, \"Maximum interrupt latency, in microseconds\");\nMODULE_PARM_DESC(small_frames, \"Maximum size of receive frames that bypass interrupt latency (0,64,128,256,512)\");\nMODULE_PARM_DESC(enable_hw_cksum, \"Enable/disable hardware cksum support (0/1)\");\n\n \n\n\n\nenum chip_capability_flags {CanHaveMII=1, };\n\nenum chipset {\n\tCH_6915 = 0,\n};\n\nstatic const struct pci_device_id starfire_pci_tbl[] = {\n\t{ PCI_VDEVICE(ADAPTEC, 0x6915), CH_6915 },\n\t{ 0, }\n};\nMODULE_DEVICE_TABLE(pci, starfire_pci_tbl);\n\n \nstatic const struct chip_info {\n\tconst char *name;\n\tint drv_flags;\n} netdrv_tbl[] = {\n\t{ \"Adaptec Starfire 6915\", CanHaveMII },\n};\n\n\n \nenum register_offsets {\n\tPCIDeviceConfig=0x50040, GenCtrl=0x50070, IntrTimerCtrl=0x50074,\n\tIntrClear=0x50080, IntrStatus=0x50084, IntrEnable=0x50088,\n\tMIICtrl=0x52000, TxStationAddr=0x50120, EEPROMCtrl=0x51000,\n\tGPIOCtrl=0x5008C, TxDescCtrl=0x50090,\n\tTxRingPtr=0x50098, HiPriTxRingPtr=0x50094,  \n\tTxRingHiAddr=0x5009C,\t\t \n\tTxProducerIdx=0x500A0, TxConsumerIdx=0x500A4,\n\tTxThreshold=0x500B0,\n\tCompletionHiAddr=0x500B4, TxCompletionAddr=0x500B8,\n\tRxCompletionAddr=0x500BC, RxCompletionQ2Addr=0x500C0,\n\tCompletionQConsumerIdx=0x500C4, RxDMACtrl=0x500D0,\n\tRxDescQCtrl=0x500D4, RxDescQHiAddr=0x500DC, RxDescQAddr=0x500E0,\n\tRxDescQIdx=0x500E8, RxDMAStatus=0x500F0, RxFilterMode=0x500F4,\n\tTxMode=0x55000, VlanType=0x55064,\n\tPerfFilterTable=0x56000, HashTable=0x56100,\n\tTxGfpMem=0x58000, RxGfpMem=0x5a000,\n};\n\n \nenum intr_status_bits {\n\tIntrLinkChange=0xf0000000, IntrStatsMax=0x08000000,\n\tIntrAbnormalSummary=0x02000000, IntrGeneralTimer=0x01000000,\n\tIntrSoftware=0x800000, IntrRxComplQ1Low=0x400000,\n\tIntrTxComplQLow=0x200000, IntrPCI=0x100000,\n\tIntrDMAErr=0x080000, IntrTxDataLow=0x040000,\n\tIntrRxComplQ2Low=0x020000, IntrRxDescQ1Low=0x010000,\n\tIntrNormalSummary=0x8000, IntrTxDone=0x4000,\n\tIntrTxDMADone=0x2000, IntrTxEmpty=0x1000,\n\tIntrEarlyRxQ2=0x0800, IntrEarlyRxQ1=0x0400,\n\tIntrRxQ2Done=0x0200, IntrRxQ1Done=0x0100,\n\tIntrRxGFPDead=0x80, IntrRxDescQ2Low=0x40,\n\tIntrNoTxCsum=0x20, IntrTxBadID=0x10,\n\tIntrHiPriTxBadID=0x08, IntrRxGfp=0x04,\n\tIntrTxGfp=0x02, IntrPCIPad=0x01,\n\t \n\tIntrRxDone=IntrRxQ2Done | IntrRxQ1Done,\n\tIntrRxEmpty=IntrRxDescQ1Low | IntrRxDescQ2Low,\n\tIntrNormalMask=0xff00, IntrAbnormalMask=0x3ff00fe,\n};\n\n \nenum rx_mode_bits {\n\tAcceptBroadcast=0x04, AcceptAllMulticast=0x02, AcceptAll=0x01,\n\tAcceptMulticast=0x10, PerfectFilter=0x40, HashFilter=0x30,\n\tPerfectFilterVlan=0x80, MinVLANPrio=0xE000, VlanMode=0x0200,\n\tWakeupOnGFP=0x0800,\n};\n\n \nenum tx_mode_bits {\n\tMiiSoftReset=0x8000, MIILoopback=0x4000,\n\tTxFlowEnable=0x0800, RxFlowEnable=0x0400,\n\tPadEnable=0x04, FullDuplex=0x02, HugeFrame=0x01,\n};\n\n \nenum tx_ctrl_bits {\n\tTxDescSpaceUnlim=0x00, TxDescSpace32=0x10, TxDescSpace64=0x20,\n\tTxDescSpace128=0x30, TxDescSpace256=0x40,\n\tTxDescType0=0x00, TxDescType1=0x01, TxDescType2=0x02,\n\tTxDescType3=0x03, TxDescType4=0x04,\n\tTxNoDMACompletion=0x08,\n\tTxDescQAddr64bit=0x80, TxDescQAddr32bit=0,\n\tTxHiPriFIFOThreshShift=24, TxPadLenShift=16,\n\tTxDMABurstSizeShift=8,\n};\n\n \nenum rx_ctrl_bits {\n\tRxBufferLenShift=16, RxMinDescrThreshShift=0,\n\tRxPrefetchMode=0x8000, RxVariableQ=0x2000,\n\tRx2048QEntries=0x4000, Rx256QEntries=0,\n\tRxDescAddr64bit=0x1000, RxDescAddr32bit=0,\n\tRxDescQAddr64bit=0x0100, RxDescQAddr32bit=0,\n\tRxDescSpace4=0x000, RxDescSpace8=0x100,\n\tRxDescSpace16=0x200, RxDescSpace32=0x300,\n\tRxDescSpace64=0x400, RxDescSpace128=0x500,\n\tRxConsumerWrEn=0x80,\n};\n\n \nenum rx_dmactrl_bits {\n\tRxReportBadFrames=0x80000000, RxDMAShortFrames=0x40000000,\n\tRxDMABadFrames=0x20000000, RxDMACrcErrorFrames=0x10000000,\n\tRxDMAControlFrame=0x08000000, RxDMAPauseFrame=0x04000000,\n\tRxChecksumIgnore=0, RxChecksumRejectTCPUDP=0x02000000,\n\tRxChecksumRejectTCPOnly=0x01000000,\n\tRxCompletionQ2Enable=0x800000,\n\tRxDMAQ2Disable=0, RxDMAQ2FPOnly=0x100000,\n\tRxDMAQ2SmallPkt=0x200000, RxDMAQ2HighPrio=0x300000,\n\tRxDMAQ2NonIP=0x400000,\n\tRxUseBackupQueue=0x080000, RxDMACRC=0x040000,\n\tRxEarlyIntThreshShift=12, RxHighPrioThreshShift=8,\n\tRxBurstSizeShift=0,\n};\n\n \nenum rx_compl_bits {\n\tRxComplQAddr64bit=0x80, RxComplQAddr32bit=0,\n\tRxComplProducerWrEn=0x40,\n\tRxComplType0=0x00, RxComplType1=0x10,\n\tRxComplType2=0x20, RxComplType3=0x30,\n\tRxComplThreshShift=0,\n};\n\n \nenum tx_compl_bits {\n\tTxComplQAddr64bit=0x80, TxComplQAddr32bit=0,\n\tTxComplProducerWrEn=0x40,\n\tTxComplIntrStatus=0x20,\n\tCommonQueueMode=0x10,\n\tTxComplThreshShift=0,\n};\n\n \nenum gen_ctrl_bits {\n\tRxEnable=0x05, TxEnable=0x0a,\n\tRxGFPEnable=0x10, TxGFPEnable=0x20,\n};\n\n \nenum intr_ctrl_bits {\n\tTimer10X=0x800, EnableIntrMasking=0x60, SmallFrameBypass=0x100,\n\tSmallFrame64=0, SmallFrame128=0x200, SmallFrame256=0x400, SmallFrame512=0x600,\n\tIntrLatencyMask=0x1f,\n};\n\n \nstruct starfire_rx_desc {\n\tnetdrv_addr_t rxaddr;\n};\nenum rx_desc_bits {\n\tRxDescValid=1, RxDescEndRing=2,\n};\n\n \nstruct short_rx_done_desc {\n\t__le32 status;\t\t\t \n};\nstruct basic_rx_done_desc {\n\t__le32 status;\t\t\t \n\t__le16 vlanid;\n\t__le16 status2;\n};\nstruct csum_rx_done_desc {\n\t__le32 status;\t\t\t \n\t__le16 csum;\t\t\t \n\t__le16 status2;\n};\nstruct full_rx_done_desc {\n\t__le32 status;\t\t\t \n\t__le16 status3;\n\t__le16 status2;\n\t__le16 vlanid;\n\t__le16 csum;\t\t\t \n\t__le32 timestamp;\n};\n \n#ifdef VLAN_SUPPORT\ntypedef struct full_rx_done_desc rx_done_desc;\n#define RxComplType RxComplType3\n#else   \ntypedef struct csum_rx_done_desc rx_done_desc;\n#define RxComplType RxComplType2\n#endif  \n\nenum rx_done_bits {\n\tRxOK=0x20000000, RxFIFOErr=0x10000000, RxBufQ2=0x08000000,\n};\n\n \nstruct starfire_tx_desc_1 {\n\t__le32 status;\t\t\t \n\t__le32 addr;\n};\n\n \nstruct starfire_tx_desc_2 {\n\t__le32 status;\t\t\t \n\t__le32 reserved;\n\t__le64 addr;\n};\n\n#ifdef ADDR_64BITS\ntypedef struct starfire_tx_desc_2 starfire_tx_desc;\n#define TX_DESC_TYPE TxDescType2\n#else   \ntypedef struct starfire_tx_desc_1 starfire_tx_desc;\n#define TX_DESC_TYPE TxDescType1\n#endif  \n#define TX_DESC_SPACING TxDescSpaceUnlim\n\nenum tx_desc_bits {\n\tTxDescID=0xB0000000,\n\tTxCRCEn=0x01000000, TxDescIntr=0x08000000,\n\tTxRingWrap=0x04000000, TxCalTCP=0x02000000,\n};\nstruct tx_done_desc {\n\t__le32 status;\t\t\t \n#if 0\n\t__le32 intrstatus;\t\t \n#endif\n};\n\nstruct rx_ring_info {\n\tstruct sk_buff *skb;\n\tdma_addr_t mapping;\n};\nstruct tx_ring_info {\n\tstruct sk_buff *skb;\n\tdma_addr_t mapping;\n\tunsigned int used_slots;\n};\n\n#define PHY_CNT\t\t2\nstruct netdev_private {\n\t \n\tstruct starfire_rx_desc *rx_ring;\n\tstarfire_tx_desc *tx_ring;\n\tdma_addr_t rx_ring_dma;\n\tdma_addr_t tx_ring_dma;\n\t \n\tstruct rx_ring_info rx_info[RX_RING_SIZE];\n\tstruct tx_ring_info tx_info[TX_RING_SIZE];\n\t \n\trx_done_desc *rx_done_q;\n\tdma_addr_t rx_done_q_dma;\n\tunsigned int rx_done;\n\tstruct tx_done_desc *tx_done_q;\n\tdma_addr_t tx_done_q_dma;\n\tunsigned int tx_done;\n\tstruct napi_struct napi;\n\tstruct net_device *dev;\n\tstruct pci_dev *pci_dev;\n#ifdef VLAN_SUPPORT\n\tunsigned long active_vlans[BITS_TO_LONGS(VLAN_N_VID)];\n#endif\n\tvoid *queue_mem;\n\tdma_addr_t queue_mem_dma;\n\tsize_t queue_mem_size;\n\n\t \n\tspinlock_t lock;\n\tunsigned int cur_rx, dirty_rx;\t \n\tunsigned int cur_tx, dirty_tx, reap_tx;\n\tunsigned int rx_buf_sz;\t\t \n\t \n\tint speed100;\t\t\t \n\tu32 tx_mode;\n\tu32 intr_timer_ctrl;\n\tu8 tx_threshold;\n\t \n\tstruct mii_if_info mii_if;\t\t \n\tint phy_cnt;\t\t\t \n\tunsigned char phys[PHY_CNT];\t \n\tvoid __iomem *base;\n};\n\n\nstatic int\tmdio_read(struct net_device *dev, int phy_id, int location);\nstatic void\tmdio_write(struct net_device *dev, int phy_id, int location, int value);\nstatic int\tnetdev_open(struct net_device *dev);\nstatic void\tcheck_duplex(struct net_device *dev);\nstatic void\ttx_timeout(struct net_device *dev, unsigned int txqueue);\nstatic void\tinit_ring(struct net_device *dev);\nstatic netdev_tx_t start_tx(struct sk_buff *skb, struct net_device *dev);\nstatic irqreturn_t intr_handler(int irq, void *dev_instance);\nstatic void\tnetdev_error(struct net_device *dev, int intr_status);\nstatic int\t__netdev_rx(struct net_device *dev, int *quota);\nstatic int\tnetdev_poll(struct napi_struct *napi, int budget);\nstatic void\trefill_rx_ring(struct net_device *dev);\nstatic void\tnetdev_error(struct net_device *dev, int intr_status);\nstatic void\tset_rx_mode(struct net_device *dev);\nstatic struct net_device_stats *get_stats(struct net_device *dev);\nstatic int\tnetdev_ioctl(struct net_device *dev, struct ifreq *rq, int cmd);\nstatic int\tnetdev_close(struct net_device *dev);\nstatic void\tnetdev_media_change(struct net_device *dev);\nstatic const struct ethtool_ops ethtool_ops;\n\n\n#ifdef VLAN_SUPPORT\nstatic int netdev_vlan_rx_add_vid(struct net_device *dev,\n\t\t\t\t  __be16 proto, u16 vid)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\n\tspin_lock(&np->lock);\n\tif (debug > 1)\n\t\tprintk(\"%s: Adding vlanid %d to vlan filter\\n\", dev->name, vid);\n\tset_bit(vid, np->active_vlans);\n\tset_rx_mode(dev);\n\tspin_unlock(&np->lock);\n\n\treturn 0;\n}\n\nstatic int netdev_vlan_rx_kill_vid(struct net_device *dev,\n\t\t\t\t   __be16 proto, u16 vid)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\n\tspin_lock(&np->lock);\n\tif (debug > 1)\n\t\tprintk(\"%s: removing vlanid %d from vlan filter\\n\", dev->name, vid);\n\tclear_bit(vid, np->active_vlans);\n\tset_rx_mode(dev);\n\tspin_unlock(&np->lock);\n\n\treturn 0;\n}\n#endif  \n\n\nstatic const struct net_device_ops netdev_ops = {\n\t.ndo_open\t\t= netdev_open,\n\t.ndo_stop\t\t= netdev_close,\n\t.ndo_start_xmit\t\t= start_tx,\n\t.ndo_tx_timeout\t\t= tx_timeout,\n\t.ndo_get_stats\t\t= get_stats,\n\t.ndo_set_rx_mode\t= set_rx_mode,\n\t.ndo_eth_ioctl\t\t= netdev_ioctl,\n\t.ndo_set_mac_address\t= eth_mac_addr,\n\t.ndo_validate_addr\t= eth_validate_addr,\n#ifdef VLAN_SUPPORT\n\t.ndo_vlan_rx_add_vid\t= netdev_vlan_rx_add_vid,\n\t.ndo_vlan_rx_kill_vid\t= netdev_vlan_rx_kill_vid,\n#endif\n};\n\nstatic int starfire_init_one(struct pci_dev *pdev,\n\t\t\t     const struct pci_device_id *ent)\n{\n\tstruct device *d = &pdev->dev;\n\tstruct netdev_private *np;\n\tint i, irq, chip_idx = ent->driver_data;\n\tstruct net_device *dev;\n\tu8 addr[ETH_ALEN];\n\tlong ioaddr;\n\tvoid __iomem *base;\n\tint drv_flags, io_size;\n\tint boguscnt;\n\n\tif (pci_enable_device (pdev))\n\t\treturn -EIO;\n\n\tioaddr = pci_resource_start(pdev, 0);\n\tio_size = pci_resource_len(pdev, 0);\n\tif (!ioaddr || ((pci_resource_flags(pdev, 0) & IORESOURCE_MEM) == 0)) {\n\t\tdev_err(d, \"no PCI MEM resources, aborting\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tdev = alloc_etherdev(sizeof(*np));\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tSET_NETDEV_DEV(dev, &pdev->dev);\n\n\tirq = pdev->irq;\n\n\tif (pci_request_regions (pdev, DRV_NAME)) {\n\t\tdev_err(d, \"cannot reserve PCI resources, aborting\\n\");\n\t\tgoto err_out_free_netdev;\n\t}\n\n\tbase = ioremap(ioaddr, io_size);\n\tif (!base) {\n\t\tdev_err(d, \"cannot remap %#x @ %#lx, aborting\\n\",\n\t\t\tio_size, ioaddr);\n\t\tgoto err_out_free_res;\n\t}\n\n\tpci_set_master(pdev);\n\n\t \n\tpci_try_set_mwi(pdev);\n\n#ifdef ZEROCOPY\n\t \n\tif (enable_hw_cksum)\n\t\tdev->features |= NETIF_F_IP_CSUM | NETIF_F_SG;\n#endif  \n\n#ifdef VLAN_SUPPORT\n\tdev->features |= NETIF_F_HW_VLAN_CTAG_RX | NETIF_F_HW_VLAN_CTAG_FILTER;\n#endif  \n#ifdef ADDR_64BITS\n\tdev->features |= NETIF_F_HIGHDMA;\n#endif  \n\n\t \n\tfor (i = 0; i < 6; i++)\n\t\taddr[i] = readb(base + EEPROMCtrl + 20 - i);\n\teth_hw_addr_set(dev, addr);\n\n#if ! defined(final_version)  \n\tif (debug > 4)\n\t\tfor (i = 0; i < 0x20; i++)\n\t\t\tprintk(\"%2.2x%s\",\n\t\t\t       (unsigned int)readb(base + EEPROMCtrl + i),\n\t\t\t       i % 16 != 15 ? \" \" : \"\\n\");\n#endif\n\n\t \n\twritel(MiiSoftReset, base + TxMode);\n\tudelay(1000);\n\twritel(0, base + TxMode);\n\n\t \n\twritel(1, base + PCIDeviceConfig);\n\tboguscnt = 1000;\n\twhile (--boguscnt > 0) {\n\t\tudelay(10);\n\t\tif ((readl(base + PCIDeviceConfig) & 1) == 0)\n\t\t\tbreak;\n\t}\n\tif (boguscnt == 0)\n\t\tprintk(\"%s: chipset reset never completed!\\n\", dev->name);\n\t \n\tudelay(1000);\n\n\tnp = netdev_priv(dev);\n\tnp->dev = dev;\n\tnp->base = base;\n\tspin_lock_init(&np->lock);\n\tpci_set_drvdata(pdev, dev);\n\n\tnp->pci_dev = pdev;\n\n\tnp->mii_if.dev = dev;\n\tnp->mii_if.mdio_read = mdio_read;\n\tnp->mii_if.mdio_write = mdio_write;\n\tnp->mii_if.phy_id_mask = 0x1f;\n\tnp->mii_if.reg_num_mask = 0x1f;\n\n\tdrv_flags = netdrv_tbl[chip_idx].drv_flags;\n\n\tnp->speed100 = 1;\n\n\t \n\tnp->intr_timer_ctrl = (((intr_latency * 10) / 1024) & IntrLatencyMask) |\n\t\tTimer10X | EnableIntrMasking;\n\n\tif (small_frames > 0) {\n\t\tnp->intr_timer_ctrl |= SmallFrameBypass;\n\t\tswitch (small_frames) {\n\t\tcase 1 ... 64:\n\t\t\tnp->intr_timer_ctrl |= SmallFrame64;\n\t\t\tbreak;\n\t\tcase 65 ... 128:\n\t\t\tnp->intr_timer_ctrl |= SmallFrame128;\n\t\t\tbreak;\n\t\tcase 129 ... 256:\n\t\t\tnp->intr_timer_ctrl |= SmallFrame256;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tnp->intr_timer_ctrl |= SmallFrame512;\n\t\t\tif (small_frames > 512)\n\t\t\t\tprintk(\"Adjusting small_frames down to 512\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tdev->netdev_ops = &netdev_ops;\n\tdev->watchdog_timeo = TX_TIMEOUT;\n\tdev->ethtool_ops = &ethtool_ops;\n\n\tnetif_napi_add_weight(dev, &np->napi, netdev_poll, max_interrupt_work);\n\n\tif (mtu)\n\t\tdev->mtu = mtu;\n\n\tif (register_netdev(dev))\n\t\tgoto err_out_cleardev;\n\n\tprintk(KERN_INFO \"%s: %s at %p, %pM, IRQ %d.\\n\",\n\t       dev->name, netdrv_tbl[chip_idx].name, base,\n\t       dev->dev_addr, irq);\n\n\tif (drv_flags & CanHaveMII) {\n\t\tint phy, phy_idx = 0;\n\t\tint mii_status;\n\t\tfor (phy = 0; phy < 32 && phy_idx < PHY_CNT; phy++) {\n\t\t\tmdio_write(dev, phy, MII_BMCR, BMCR_RESET);\n\t\t\tmsleep(100);\n\t\t\tboguscnt = 1000;\n\t\t\twhile (--boguscnt > 0)\n\t\t\t\tif ((mdio_read(dev, phy, MII_BMCR) & BMCR_RESET) == 0)\n\t\t\t\t\tbreak;\n\t\t\tif (boguscnt == 0) {\n\t\t\t\tprintk(\"%s: PHY#%d reset never completed!\\n\", dev->name, phy);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tmii_status = mdio_read(dev, phy, MII_BMSR);\n\t\t\tif (mii_status != 0) {\n\t\t\t\tnp->phys[phy_idx++] = phy;\n\t\t\t\tnp->mii_if.advertising = mdio_read(dev, phy, MII_ADVERTISE);\n\t\t\t\tprintk(KERN_INFO \"%s: MII PHY found at address %d, status \"\n\t\t\t\t\t   \"%#4.4x advertising %#4.4x.\\n\",\n\t\t\t\t\t   dev->name, phy, mii_status, np->mii_if.advertising);\n\t\t\t\t \n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tnp->phy_cnt = phy_idx;\n\t\tif (np->phy_cnt > 0)\n\t\t\tnp->mii_if.phy_id = np->phys[0];\n\t\telse\n\t\t\tmemset(&np->mii_if, 0, sizeof(np->mii_if));\n\t}\n\n\tprintk(KERN_INFO \"%s: scatter-gather and hardware TCP cksumming %s.\\n\",\n\t       dev->name, enable_hw_cksum ? \"enabled\" : \"disabled\");\n\treturn 0;\n\nerr_out_cleardev:\n\tiounmap(base);\nerr_out_free_res:\n\tpci_release_regions (pdev);\nerr_out_free_netdev:\n\tfree_netdev(dev);\n\treturn -ENODEV;\n}\n\n\n \nstatic int mdio_read(struct net_device *dev, int phy_id, int location)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tvoid __iomem *mdio_addr = np->base + MIICtrl + (phy_id<<7) + (location<<2);\n\tint result, boguscnt=1000;\n\t \n\tdo {\n\t\tresult = readl(mdio_addr);\n\t} while ((result & 0xC0000000) != 0x80000000 && --boguscnt > 0);\n\tif (boguscnt == 0)\n\t\treturn 0;\n\tif ((result & 0xffff) == 0xffff)\n\t\treturn 0;\n\treturn result & 0xffff;\n}\n\n\nstatic void mdio_write(struct net_device *dev, int phy_id, int location, int value)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tvoid __iomem *mdio_addr = np->base + MIICtrl + (phy_id<<7) + (location<<2);\n\twritel(value, mdio_addr);\n\t \n}\n\n\nstatic int netdev_open(struct net_device *dev)\n{\n\tconst struct firmware *fw_rx, *fw_tx;\n\tconst __be32 *fw_rx_data, *fw_tx_data;\n\tstruct netdev_private *np = netdev_priv(dev);\n\tvoid __iomem *ioaddr = np->base;\n\tconst int irq = np->pci_dev->irq;\n\tint i, retval;\n\tsize_t tx_size, rx_size;\n\tsize_t tx_done_q_size, rx_done_q_size, tx_ring_size, rx_ring_size;\n\n\t \n\n\tretval = request_irq(irq, intr_handler, IRQF_SHARED, dev->name, dev);\n\tif (retval)\n\t\treturn retval;\n\n\t \n\twritel(0, ioaddr + GenCtrl);\n\twritel(1, ioaddr + PCIDeviceConfig);\n\tif (debug > 1)\n\t\tprintk(KERN_DEBUG \"%s: netdev_open() irq %d.\\n\",\n\t\t       dev->name, irq);\n\n\t \n\tif (!np->queue_mem) {\n\t\ttx_done_q_size = ((sizeof(struct tx_done_desc) * DONE_Q_SIZE + QUEUE_ALIGN - 1) / QUEUE_ALIGN) * QUEUE_ALIGN;\n\t\trx_done_q_size = ((sizeof(rx_done_desc) * DONE_Q_SIZE + QUEUE_ALIGN - 1) / QUEUE_ALIGN) * QUEUE_ALIGN;\n\t\ttx_ring_size = ((sizeof(starfire_tx_desc) * TX_RING_SIZE + QUEUE_ALIGN - 1) / QUEUE_ALIGN) * QUEUE_ALIGN;\n\t\trx_ring_size = sizeof(struct starfire_rx_desc) * RX_RING_SIZE;\n\t\tnp->queue_mem_size = tx_done_q_size + rx_done_q_size + tx_ring_size + rx_ring_size;\n\t\tnp->queue_mem = dma_alloc_coherent(&np->pci_dev->dev,\n\t\t\t\t\t\t   np->queue_mem_size,\n\t\t\t\t\t\t   &np->queue_mem_dma, GFP_ATOMIC);\n\t\tif (np->queue_mem == NULL) {\n\t\t\tfree_irq(irq, dev);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tnp->tx_done_q     = np->queue_mem;\n\t\tnp->tx_done_q_dma = np->queue_mem_dma;\n\t\tnp->rx_done_q     = (void *) np->tx_done_q + tx_done_q_size;\n\t\tnp->rx_done_q_dma = np->tx_done_q_dma + tx_done_q_size;\n\t\tnp->tx_ring       = (void *) np->rx_done_q + rx_done_q_size;\n\t\tnp->tx_ring_dma   = np->rx_done_q_dma + rx_done_q_size;\n\t\tnp->rx_ring       = (void *) np->tx_ring + tx_ring_size;\n\t\tnp->rx_ring_dma   = np->tx_ring_dma + tx_ring_size;\n\t}\n\n\t \n\tnetif_carrier_off(dev);\n\tinit_ring(dev);\n\t \n\twritel((np->rx_buf_sz << RxBufferLenShift) |\n\t       (0 << RxMinDescrThreshShift) |\n\t       RxPrefetchMode | RxVariableQ |\n\t       RX_Q_ENTRIES |\n\t       RX_DESC_Q_ADDR_SIZE | RX_DESC_ADDR_SIZE |\n\t       RxDescSpace4,\n\t       ioaddr + RxDescQCtrl);\n\n\t \n\twritel(RxChecksumIgnore |\n\t       (0 << RxEarlyIntThreshShift) |\n\t       (6 << RxHighPrioThreshShift) |\n\t       ((DMA_BURST_SIZE / 32) << RxBurstSizeShift),\n\t       ioaddr + RxDMACtrl);\n\n\t \n\twritel((2 << TxHiPriFIFOThreshShift) |\n\t       (0 << TxPadLenShift) |\n\t       ((DMA_BURST_SIZE / 32) << TxDMABurstSizeShift) |\n\t       TX_DESC_Q_ADDR_SIZE |\n\t       TX_DESC_SPACING | TX_DESC_TYPE,\n\t       ioaddr + TxDescCtrl);\n\n\twritel( (np->queue_mem_dma >> 16) >> 16, ioaddr + RxDescQHiAddr);\n\twritel( (np->queue_mem_dma >> 16) >> 16, ioaddr + TxRingHiAddr);\n\twritel( (np->queue_mem_dma >> 16) >> 16, ioaddr + CompletionHiAddr);\n\twritel(np->rx_ring_dma, ioaddr + RxDescQAddr);\n\twritel(np->tx_ring_dma, ioaddr + TxRingPtr);\n\n\twritel(np->tx_done_q_dma, ioaddr + TxCompletionAddr);\n\twritel(np->rx_done_q_dma |\n\t       RxComplType |\n\t       (0 << RxComplThreshShift),\n\t       ioaddr + RxCompletionAddr);\n\n\tif (debug > 1)\n\t\tprintk(KERN_DEBUG \"%s: Filling in the station address.\\n\", dev->name);\n\n\t \n\tfor (i = 0; i < 6; i++)\n\t\twriteb(dev->dev_addr[i], ioaddr + TxStationAddr + 5 - i);\n\t \n\twritew(0, ioaddr + PerfFilterTable);\n\twritew(0, ioaddr + PerfFilterTable + 4);\n\twritew(0, ioaddr + PerfFilterTable + 8);\n\tfor (i = 1; i < 16; i++) {\n\t\tconst __be16 *eaddrs = (const __be16 *)dev->dev_addr;\n\t\tvoid __iomem *setup_frm = ioaddr + PerfFilterTable + i * 16;\n\t\twritew(be16_to_cpu(eaddrs[2]), setup_frm); setup_frm += 4;\n\t\twritew(be16_to_cpu(eaddrs[1]), setup_frm); setup_frm += 4;\n\t\twritew(be16_to_cpu(eaddrs[0]), setup_frm); setup_frm += 8;\n\t}\n\n\t \n\t \n\tnp->tx_mode = TxFlowEnable|RxFlowEnable|PadEnable;\t \n\twritel(MiiSoftReset | np->tx_mode, ioaddr + TxMode);\n\tudelay(1000);\n\twritel(np->tx_mode, ioaddr + TxMode);\n\tnp->tx_threshold = 4;\n\twritel(np->tx_threshold, ioaddr + TxThreshold);\n\n\twritel(np->intr_timer_ctrl, ioaddr + IntrTimerCtrl);\n\n\tnapi_enable(&np->napi);\n\n\tnetif_start_queue(dev);\n\n\tif (debug > 1)\n\t\tprintk(KERN_DEBUG \"%s: Setting the Rx and Tx modes.\\n\", dev->name);\n\tset_rx_mode(dev);\n\n\tnp->mii_if.advertising = mdio_read(dev, np->phys[0], MII_ADVERTISE);\n\tcheck_duplex(dev);\n\n\t \n\twritel(0x0f00ff00, ioaddr + GPIOCtrl);\n\n\t \n\twritel(IntrRxDone | IntrRxEmpty | IntrDMAErr |\n\t       IntrTxDMADone | IntrStatsMax | IntrLinkChange |\n\t       IntrRxGFPDead | IntrNoTxCsum | IntrTxBadID,\n\t       ioaddr + IntrEnable);\n\t \n\twritel(0x00800000 | readl(ioaddr + PCIDeviceConfig),\n\t       ioaddr + PCIDeviceConfig);\n\n#ifdef VLAN_SUPPORT\n\t \n\twritel(ETH_P_8021Q, ioaddr + VlanType);\n#endif  \n\n\tretval = request_firmware(&fw_rx, FIRMWARE_RX, &np->pci_dev->dev);\n\tif (retval) {\n\t\tprintk(KERN_ERR \"starfire: Failed to load firmware \\\"%s\\\"\\n\",\n\t\t       FIRMWARE_RX);\n\t\tgoto out_init;\n\t}\n\tif (fw_rx->size % 4) {\n\t\tprintk(KERN_ERR \"starfire: bogus length %zu in \\\"%s\\\"\\n\",\n\t\t       fw_rx->size, FIRMWARE_RX);\n\t\tretval = -EINVAL;\n\t\tgoto out_rx;\n\t}\n\tretval = request_firmware(&fw_tx, FIRMWARE_TX, &np->pci_dev->dev);\n\tif (retval) {\n\t\tprintk(KERN_ERR \"starfire: Failed to load firmware \\\"%s\\\"\\n\",\n\t\t       FIRMWARE_TX);\n\t\tgoto out_rx;\n\t}\n\tif (fw_tx->size % 4) {\n\t\tprintk(KERN_ERR \"starfire: bogus length %zu in \\\"%s\\\"\\n\",\n\t\t       fw_tx->size, FIRMWARE_TX);\n\t\tretval = -EINVAL;\n\t\tgoto out_tx;\n\t}\n\tfw_rx_data = (const __be32 *)&fw_rx->data[0];\n\tfw_tx_data = (const __be32 *)&fw_tx->data[0];\n\trx_size = fw_rx->size / 4;\n\ttx_size = fw_tx->size / 4;\n\n\t \n\tfor (i = 0; i < rx_size; i++)\n\t\twritel(be32_to_cpup(&fw_rx_data[i]), ioaddr + RxGfpMem + i * 4);\n\tfor (i = 0; i < tx_size; i++)\n\t\twritel(be32_to_cpup(&fw_tx_data[i]), ioaddr + TxGfpMem + i * 4);\n\tif (enable_hw_cksum)\n\t\t \n\t\twritel(TxEnable|TxGFPEnable|RxEnable|RxGFPEnable, ioaddr + GenCtrl);\n\telse\n\t\t \n\t\twritel(TxEnable|RxEnable, ioaddr + GenCtrl);\n\n\tif (debug > 1)\n\t\tprintk(KERN_DEBUG \"%s: Done netdev_open().\\n\",\n\t\t       dev->name);\n\nout_tx:\n\trelease_firmware(fw_tx);\nout_rx:\n\trelease_firmware(fw_rx);\nout_init:\n\tif (retval)\n\t\tnetdev_close(dev);\n\treturn retval;\n}\n\n\nstatic void check_duplex(struct net_device *dev)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tu16 reg0;\n\tint silly_count = 1000;\n\n\tmdio_write(dev, np->phys[0], MII_ADVERTISE, np->mii_if.advertising);\n\tmdio_write(dev, np->phys[0], MII_BMCR, BMCR_RESET);\n\tudelay(500);\n\twhile (--silly_count && mdio_read(dev, np->phys[0], MII_BMCR) & BMCR_RESET)\n\t\t ;\n\tif (!silly_count) {\n\t\tprintk(\"%s: MII reset failed!\\n\", dev->name);\n\t\treturn;\n\t}\n\n\treg0 = mdio_read(dev, np->phys[0], MII_BMCR);\n\n\tif (!np->mii_if.force_media) {\n\t\treg0 |= BMCR_ANENABLE | BMCR_ANRESTART;\n\t} else {\n\t\treg0 &= ~(BMCR_ANENABLE | BMCR_ANRESTART);\n\t\tif (np->speed100)\n\t\t\treg0 |= BMCR_SPEED100;\n\t\tif (np->mii_if.full_duplex)\n\t\t\treg0 |= BMCR_FULLDPLX;\n\t\tprintk(KERN_DEBUG \"%s: Link forced to %sMbit %s-duplex\\n\",\n\t\t       dev->name,\n\t\t       np->speed100 ? \"100\" : \"10\",\n\t\t       np->mii_if.full_duplex ? \"full\" : \"half\");\n\t}\n\tmdio_write(dev, np->phys[0], MII_BMCR, reg0);\n}\n\n\nstatic void tx_timeout(struct net_device *dev, unsigned int txqueue)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tvoid __iomem *ioaddr = np->base;\n\tint old_debug;\n\n\tprintk(KERN_WARNING \"%s: Transmit timed out, status %#8.8x, \"\n\t       \"resetting...\\n\", dev->name, (int) readl(ioaddr + IntrStatus));\n\n\t \n\n\t \n\told_debug = debug;\n\tdebug = 2;\n\tnetdev_close(dev);\n\tnetdev_open(dev);\n\tdebug = old_debug;\n\n\t \n\n\tnetif_trans_update(dev);  \n\tdev->stats.tx_errors++;\n\tnetif_wake_queue(dev);\n}\n\n\n \nstatic void init_ring(struct net_device *dev)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tint i;\n\n\tnp->cur_rx = np->cur_tx = np->reap_tx = 0;\n\tnp->dirty_rx = np->dirty_tx = np->rx_done = np->tx_done = 0;\n\n\tnp->rx_buf_sz = (dev->mtu <= 1500 ? PKT_BUF_SZ : dev->mtu + 32);\n\n\t \n\tfor (i = 0; i < RX_RING_SIZE; i++) {\n\t\tstruct sk_buff *skb = netdev_alloc_skb(dev, np->rx_buf_sz);\n\t\tnp->rx_info[i].skb = skb;\n\t\tif (skb == NULL)\n\t\t\tbreak;\n\t\tnp->rx_info[i].mapping = dma_map_single(&np->pci_dev->dev,\n\t\t\t\t\t\t\tskb->data,\n\t\t\t\t\t\t\tnp->rx_buf_sz,\n\t\t\t\t\t\t\tDMA_FROM_DEVICE);\n\t\tif (dma_mapping_error(&np->pci_dev->dev, np->rx_info[i].mapping)) {\n\t\t\tdev_kfree_skb(skb);\n\t\t\tnp->rx_info[i].skb = NULL;\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tnp->rx_ring[i].rxaddr = cpu_to_dma(np->rx_info[i].mapping | RxDescValid);\n\t}\n\twritew(i - 1, np->base + RxDescQIdx);\n\tnp->dirty_rx = (unsigned int)(i - RX_RING_SIZE);\n\n\t \n\tfor (  ; i < RX_RING_SIZE; i++) {\n\t\tnp->rx_ring[i].rxaddr = 0;\n\t\tnp->rx_info[i].skb = NULL;\n\t\tnp->rx_info[i].mapping = 0;\n\t}\n\t \n\tnp->rx_ring[RX_RING_SIZE - 1].rxaddr |= cpu_to_dma(RxDescEndRing);\n\n\t \n\tfor (i = 0; i < DONE_Q_SIZE; i++) {\n\t\tnp->rx_done_q[i].status = 0;\n\t\tnp->tx_done_q[i].status = 0;\n\t}\n\n\tfor (i = 0; i < TX_RING_SIZE; i++)\n\t\tmemset(&np->tx_info[i], 0, sizeof(np->tx_info[i]));\n}\n\n\nstatic netdev_tx_t start_tx(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tunsigned int entry;\n\tunsigned int prev_tx;\n\tu32 status;\n\tint i, j;\n\n\t \n\tif ((np->cur_tx - np->dirty_tx) + skb_num_frags(skb) * 2 > TX_RING_SIZE) {\n\t\tnetif_stop_queue(dev);\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\n#if defined(ZEROCOPY) && defined(HAS_BROKEN_FIRMWARE)\n\tif (skb->ip_summed == CHECKSUM_PARTIAL) {\n\t\tif (skb_padto(skb, (skb->len + PADDING_MASK) & ~PADDING_MASK))\n\t\t\treturn NETDEV_TX_OK;\n\t}\n#endif  \n\n\tprev_tx = np->cur_tx;\n\tentry = np->cur_tx % TX_RING_SIZE;\n\tfor (i = 0; i < skb_num_frags(skb); i++) {\n\t\tint wrap_ring = 0;\n\t\tstatus = TxDescID;\n\n\t\tif (i == 0) {\n\t\t\tnp->tx_info[entry].skb = skb;\n\t\t\tstatus |= TxCRCEn;\n\t\t\tif (entry >= TX_RING_SIZE - skb_num_frags(skb)) {\n\t\t\t\tstatus |= TxRingWrap;\n\t\t\t\twrap_ring = 1;\n\t\t\t}\n\t\t\tif (np->reap_tx) {\n\t\t\t\tstatus |= TxDescIntr;\n\t\t\t\tnp->reap_tx = 0;\n\t\t\t}\n\t\t\tif (skb->ip_summed == CHECKSUM_PARTIAL) {\n\t\t\t\tstatus |= TxCalTCP;\n\t\t\t\tdev->stats.tx_compressed++;\n\t\t\t}\n\t\t\tstatus |= skb_first_frag_len(skb) | (skb_num_frags(skb) << 16);\n\n\t\t\tnp->tx_info[entry].mapping =\n\t\t\t\tdma_map_single(&np->pci_dev->dev, skb->data,\n\t\t\t\t\t       skb_first_frag_len(skb),\n\t\t\t\t\t       DMA_TO_DEVICE);\n\t\t} else {\n\t\t\tconst skb_frag_t *this_frag = &skb_shinfo(skb)->frags[i - 1];\n\t\t\tstatus |= skb_frag_size(this_frag);\n\t\t\tnp->tx_info[entry].mapping =\n\t\t\t\tdma_map_single(&np->pci_dev->dev,\n\t\t\t\t\t       skb_frag_address(this_frag),\n\t\t\t\t\t       skb_frag_size(this_frag),\n\t\t\t\t\t       DMA_TO_DEVICE);\n\t\t}\n\t\tif (dma_mapping_error(&np->pci_dev->dev, np->tx_info[entry].mapping)) {\n\t\t\tdev->stats.tx_dropped++;\n\t\t\tgoto err_out;\n\t\t}\n\n\t\tnp->tx_ring[entry].addr = cpu_to_dma(np->tx_info[entry].mapping);\n\t\tnp->tx_ring[entry].status = cpu_to_le32(status);\n\t\tif (debug > 3)\n\t\t\tprintk(KERN_DEBUG \"%s: Tx #%d/#%d slot %d status %#8.8x.\\n\",\n\t\t\t       dev->name, np->cur_tx, np->dirty_tx,\n\t\t\t       entry, status);\n\t\tif (wrap_ring) {\n\t\t\tnp->tx_info[entry].used_slots = TX_RING_SIZE - entry;\n\t\t\tnp->cur_tx += np->tx_info[entry].used_slots;\n\t\t\tentry = 0;\n\t\t} else {\n\t\t\tnp->tx_info[entry].used_slots = 1;\n\t\t\tnp->cur_tx += np->tx_info[entry].used_slots;\n\t\t\tentry++;\n\t\t}\n\t\t \n\t\tif (np->cur_tx % (TX_RING_SIZE / 2) == 0)\n\t\t\tnp->reap_tx = 1;\n\t}\n\n\t \n\t \n\twmb();\n\n\t \n\twritel(entry * (sizeof(starfire_tx_desc) / 8), np->base + TxProducerIdx);\n\n\t \n\tif ((np->cur_tx - np->dirty_tx) + 4 > TX_RING_SIZE)\n\t\tnetif_stop_queue(dev);\n\n\treturn NETDEV_TX_OK;\n\nerr_out:\n\tentry = prev_tx % TX_RING_SIZE;\n\tnp->tx_info[entry].skb = NULL;\n\tif (i > 0) {\n\t\tdma_unmap_single(&np->pci_dev->dev,\n\t\t\t\t np->tx_info[entry].mapping,\n\t\t\t\t skb_first_frag_len(skb), DMA_TO_DEVICE);\n\t\tnp->tx_info[entry].mapping = 0;\n\t\tentry = (entry + np->tx_info[entry].used_slots) % TX_RING_SIZE;\n\t\tfor (j = 1; j < i; j++) {\n\t\t\tdma_unmap_single(&np->pci_dev->dev,\n\t\t\t\t\t np->tx_info[entry].mapping,\n\t\t\t\t\t skb_frag_size(&skb_shinfo(skb)->frags[j - 1]),\n\t\t\t\t\t DMA_TO_DEVICE);\n\t\t\tentry++;\n\t\t}\n\t}\n\tdev_kfree_skb_any(skb);\n\tnp->cur_tx = prev_tx;\n\treturn NETDEV_TX_OK;\n}\n\n \nstatic irqreturn_t intr_handler(int irq, void *dev_instance)\n{\n\tstruct net_device *dev = dev_instance;\n\tstruct netdev_private *np = netdev_priv(dev);\n\tvoid __iomem *ioaddr = np->base;\n\tint boguscnt = max_interrupt_work;\n\tint consumer;\n\tint tx_status;\n\tint handled = 0;\n\n\tdo {\n\t\tu32 intr_status = readl(ioaddr + IntrClear);\n\n\t\tif (debug > 4)\n\t\t\tprintk(KERN_DEBUG \"%s: Interrupt status %#8.8x.\\n\",\n\t\t\t       dev->name, intr_status);\n\n\t\tif (intr_status == 0 || intr_status == (u32) -1)\n\t\t\tbreak;\n\n\t\thandled = 1;\n\n\t\tif (intr_status & (IntrRxDone | IntrRxEmpty)) {\n\t\t\tu32 enable;\n\n\t\t\tif (likely(napi_schedule_prep(&np->napi))) {\n\t\t\t\t__napi_schedule(&np->napi);\n\t\t\t\tenable = readl(ioaddr + IntrEnable);\n\t\t\t\tenable &= ~(IntrRxDone | IntrRxEmpty);\n\t\t\t\twritel(enable, ioaddr + IntrEnable);\n\t\t\t\t \n\t\t\t\treadl(ioaddr + IntrEnable);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tenable = readl(ioaddr + IntrEnable);\n\t\t\t\tif (enable & (IntrRxDone | IntrRxEmpty)) {\n\t\t\t\t\tprintk(KERN_INFO\n\t\t\t\t\t       \"%s: interrupt while in poll!\\n\",\n\t\t\t\t\t       dev->name);\n\t\t\t\t\tenable &= ~(IntrRxDone | IntrRxEmpty);\n\t\t\t\t\twritel(enable, ioaddr + IntrEnable);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tconsumer = readl(ioaddr + TxConsumerIdx);\n\t\tif (debug > 3)\n\t\t\tprintk(KERN_DEBUG \"%s: Tx Consumer index is %d.\\n\",\n\t\t\t       dev->name, consumer);\n\n\t\twhile ((tx_status = le32_to_cpu(np->tx_done_q[np->tx_done].status)) != 0) {\n\t\t\tif (debug > 3)\n\t\t\t\tprintk(KERN_DEBUG \"%s: Tx completion #%d entry %d is %#8.8x.\\n\",\n\t\t\t\t       dev->name, np->dirty_tx, np->tx_done, tx_status);\n\t\t\tif ((tx_status & 0xe0000000) == 0xa0000000) {\n\t\t\t\tdev->stats.tx_packets++;\n\t\t\t} else if ((tx_status & 0xe0000000) == 0x80000000) {\n\t\t\t\tu16 entry = (tx_status & 0x7fff) / sizeof(starfire_tx_desc);\n\t\t\t\tstruct sk_buff *skb = np->tx_info[entry].skb;\n\t\t\t\tnp->tx_info[entry].skb = NULL;\n\t\t\t\tdma_unmap_single(&np->pci_dev->dev,\n\t\t\t\t\t\t np->tx_info[entry].mapping,\n\t\t\t\t\t\t skb_first_frag_len(skb),\n\t\t\t\t\t\t DMA_TO_DEVICE);\n\t\t\t\tnp->tx_info[entry].mapping = 0;\n\t\t\t\tnp->dirty_tx += np->tx_info[entry].used_slots;\n\t\t\t\tentry = (entry + np->tx_info[entry].used_slots) % TX_RING_SIZE;\n\t\t\t\t{\n\t\t\t\t\tint i;\n\t\t\t\t\tfor (i = 0; i < skb_shinfo(skb)->nr_frags; i++) {\n\t\t\t\t\t\tdma_unmap_single(&np->pci_dev->dev,\n\t\t\t\t\t\t\t\t np->tx_info[entry].mapping,\n\t\t\t\t\t\t\t\t skb_frag_size(&skb_shinfo(skb)->frags[i]),\n\t\t\t\t\t\t\t\t DMA_TO_DEVICE);\n\t\t\t\t\t\tnp->dirty_tx++;\n\t\t\t\t\t\tentry++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tdev_consume_skb_irq(skb);\n\t\t\t}\n\t\t\tnp->tx_done_q[np->tx_done].status = 0;\n\t\t\tnp->tx_done = (np->tx_done + 1) % DONE_Q_SIZE;\n\t\t}\n\t\twritew(np->tx_done, ioaddr + CompletionQConsumerIdx + 2);\n\n\t\tif (netif_queue_stopped(dev) &&\n\t\t    (np->cur_tx - np->dirty_tx + 4 < TX_RING_SIZE)) {\n\t\t\t \n\t\t\tnetif_wake_queue(dev);\n\t\t}\n\n\t\t \n\t\tif (intr_status & IntrStatsMax)\n\t\t\tget_stats(dev);\n\n\t\t \n\t\tif (intr_status & IntrLinkChange)\n\t\t\tnetdev_media_change(dev);\n\n\t\t \n\t\tif (intr_status & IntrAbnormalSummary)\n\t\t\tnetdev_error(dev, intr_status);\n\n\t\tif (--boguscnt < 0) {\n\t\t\tif (debug > 1)\n\t\t\t\tprintk(KERN_WARNING \"%s: Too much work at interrupt, \"\n\t\t\t\t       \"status=%#8.8x.\\n\",\n\t\t\t\t       dev->name, intr_status);\n\t\t\tbreak;\n\t\t}\n\t} while (1);\n\n\tif (debug > 4)\n\t\tprintk(KERN_DEBUG \"%s: exiting interrupt, status=%#8.8x.\\n\",\n\t\t       dev->name, (int) readl(ioaddr + IntrStatus));\n\treturn IRQ_RETVAL(handled);\n}\n\n\n \nstatic int __netdev_rx(struct net_device *dev, int *quota)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tu32 desc_status;\n\tint retcode = 0;\n\n\t \n\twhile ((desc_status = le32_to_cpu(np->rx_done_q[np->rx_done].status)) != 0) {\n\t\tstruct sk_buff *skb;\n\t\tu16 pkt_len;\n\t\tint entry;\n\t\trx_done_desc *desc = &np->rx_done_q[np->rx_done];\n\n\t\tif (debug > 4)\n\t\t\tprintk(KERN_DEBUG \"  netdev_rx() status of %d was %#8.8x.\\n\", np->rx_done, desc_status);\n\t\tif (!(desc_status & RxOK)) {\n\t\t\t \n\t\t\tif (debug > 2)\n\t\t\t\tprintk(KERN_DEBUG \"  netdev_rx() Rx error was %#8.8x.\\n\", desc_status);\n\t\t\tdev->stats.rx_errors++;\n\t\t\tif (desc_status & RxFIFOErr)\n\t\t\t\tdev->stats.rx_fifo_errors++;\n\t\t\tgoto next_rx;\n\t\t}\n\n\t\tif (*quota <= 0) {\t \n\t\t\tretcode = 1;\n\t\t\tgoto out;\n\t\t}\n\t\t(*quota)--;\n\n\t\tpkt_len = desc_status;\t \n\t\tentry = (desc_status >> 16) & 0x7ff;\n\n\t\tif (debug > 4)\n\t\t\tprintk(KERN_DEBUG \"  netdev_rx() normal Rx pkt length %d, quota %d.\\n\", pkt_len, *quota);\n\t\t \n\t\tif (pkt_len < rx_copybreak &&\n\t\t    (skb = netdev_alloc_skb(dev, pkt_len + 2)) != NULL) {\n\t\t\tskb_reserve(skb, 2);\t \n\t\t\tdma_sync_single_for_cpu(&np->pci_dev->dev,\n\t\t\t\t\t\tnp->rx_info[entry].mapping,\n\t\t\t\t\t\tpkt_len, DMA_FROM_DEVICE);\n\t\t\tskb_copy_to_linear_data(skb, np->rx_info[entry].skb->data, pkt_len);\n\t\t\tdma_sync_single_for_device(&np->pci_dev->dev,\n\t\t\t\t\t\t   np->rx_info[entry].mapping,\n\t\t\t\t\t\t   pkt_len, DMA_FROM_DEVICE);\n\t\t\tskb_put(skb, pkt_len);\n\t\t} else {\n\t\t\tdma_unmap_single(&np->pci_dev->dev,\n\t\t\t\t\t np->rx_info[entry].mapping,\n\t\t\t\t\t np->rx_buf_sz, DMA_FROM_DEVICE);\n\t\t\tskb = np->rx_info[entry].skb;\n\t\t\tskb_put(skb, pkt_len);\n\t\t\tnp->rx_info[entry].skb = NULL;\n\t\t\tnp->rx_info[entry].mapping = 0;\n\t\t}\n#ifndef final_version\t\t\t \n\t\t \n\t\tif (debug > 5) {\n\t\t\tprintk(KERN_DEBUG \"  Rx data %pM %pM %2.2x%2.2x.\\n\",\n\t\t\t       skb->data, skb->data + 6,\n\t\t\t       skb->data[12], skb->data[13]);\n\t\t}\n#endif\n\n\t\tskb->protocol = eth_type_trans(skb, dev);\n#ifdef VLAN_SUPPORT\n\t\tif (debug > 4)\n\t\t\tprintk(KERN_DEBUG \"  netdev_rx() status2 of %d was %#4.4x.\\n\", np->rx_done, le16_to_cpu(desc->status2));\n#endif\n\t\tif (le16_to_cpu(desc->status2) & 0x0100) {\n\t\t\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\t\t\tdev->stats.rx_compressed++;\n\t\t}\n\t\t \n\t\telse if (le16_to_cpu(desc->status2) & 0x0040) {\n\t\t\tskb->ip_summed = CHECKSUM_COMPLETE;\n\t\t\tskb->csum = le16_to_cpu(desc->csum);\n\t\t\tprintk(KERN_DEBUG \"%s: checksum_hw, status2 = %#x\\n\", dev->name, le16_to_cpu(desc->status2));\n\t\t}\n#ifdef VLAN_SUPPORT\n\t\tif (le16_to_cpu(desc->status2) & 0x0200) {\n\t\t\tu16 vlid = le16_to_cpu(desc->vlanid);\n\n\t\t\tif (debug > 4) {\n\t\t\t\tprintk(KERN_DEBUG \"  netdev_rx() vlanid = %d\\n\",\n\t\t\t\t       vlid);\n\t\t\t}\n\t\t\t__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q), vlid);\n\t\t}\n#endif  \n\t\tnetif_receive_skb(skb);\n\t\tdev->stats.rx_packets++;\n\n\tnext_rx:\n\t\tnp->cur_rx++;\n\t\tdesc->status = 0;\n\t\tnp->rx_done = (np->rx_done + 1) % DONE_Q_SIZE;\n\t}\n\n\tif (*quota == 0) {\t \n\t\tretcode = 1;\n\t\tgoto out;\n\t}\n\twritew(np->rx_done, np->base + CompletionQConsumerIdx);\n\n out:\n\trefill_rx_ring(dev);\n\tif (debug > 5)\n\t\tprintk(KERN_DEBUG \"  exiting netdev_rx(): %d, status of %d was %#8.8x.\\n\",\n\t\t       retcode, np->rx_done, desc_status);\n\treturn retcode;\n}\n\nstatic int netdev_poll(struct napi_struct *napi, int budget)\n{\n\tstruct netdev_private *np = container_of(napi, struct netdev_private, napi);\n\tstruct net_device *dev = np->dev;\n\tu32 intr_status;\n\tvoid __iomem *ioaddr = np->base;\n\tint quota = budget;\n\n\tdo {\n\t\twritel(IntrRxDone | IntrRxEmpty, ioaddr + IntrClear);\n\n\t\tif (__netdev_rx(dev, &quota))\n\t\t\tgoto out;\n\n\t\tintr_status = readl(ioaddr + IntrStatus);\n\t} while (intr_status & (IntrRxDone | IntrRxEmpty));\n\n\tnapi_complete(napi);\n\tintr_status = readl(ioaddr + IntrEnable);\n\tintr_status |= IntrRxDone | IntrRxEmpty;\n\twritel(intr_status, ioaddr + IntrEnable);\n\n out:\n\tif (debug > 5)\n\t\tprintk(KERN_DEBUG \"  exiting netdev_poll(): %d.\\n\",\n\t\t       budget - quota);\n\n\t \n\treturn budget - quota;\n}\n\nstatic void refill_rx_ring(struct net_device *dev)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tstruct sk_buff *skb;\n\tint entry = -1;\n\n\t \n\tfor (; np->cur_rx - np->dirty_rx > 0; np->dirty_rx++) {\n\t\tentry = np->dirty_rx % RX_RING_SIZE;\n\t\tif (np->rx_info[entry].skb == NULL) {\n\t\t\tskb = netdev_alloc_skb(dev, np->rx_buf_sz);\n\t\t\tnp->rx_info[entry].skb = skb;\n\t\t\tif (skb == NULL)\n\t\t\t\tbreak;\t \n\t\t\tnp->rx_info[entry].mapping =\n\t\t\t\tdma_map_single(&np->pci_dev->dev, skb->data,\n\t\t\t\t\t       np->rx_buf_sz, DMA_FROM_DEVICE);\n\t\t\tif (dma_mapping_error(&np->pci_dev->dev, np->rx_info[entry].mapping)) {\n\t\t\t\tdev_kfree_skb(skb);\n\t\t\t\tnp->rx_info[entry].skb = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnp->rx_ring[entry].rxaddr =\n\t\t\t\tcpu_to_dma(np->rx_info[entry].mapping | RxDescValid);\n\t\t}\n\t\tif (entry == RX_RING_SIZE - 1)\n\t\t\tnp->rx_ring[entry].rxaddr |= cpu_to_dma(RxDescEndRing);\n\t}\n\tif (entry >= 0)\n\t\twritew(entry, np->base + RxDescQIdx);\n}\n\n\nstatic void netdev_media_change(struct net_device *dev)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tvoid __iomem *ioaddr = np->base;\n\tu16 reg0, reg1, reg4, reg5;\n\tu32 new_tx_mode;\n\tu32 new_intr_timer_ctrl;\n\n\t \n\tmdio_read(dev, np->phys[0], MII_BMCR);\n\tmdio_read(dev, np->phys[0], MII_BMSR);\n\n\treg0 = mdio_read(dev, np->phys[0], MII_BMCR);\n\treg1 = mdio_read(dev, np->phys[0], MII_BMSR);\n\n\tif (reg1 & BMSR_LSTATUS) {\n\t\t \n\t\tif (reg0 & BMCR_ANENABLE) {\n\t\t\t \n\t\t\treg4 = mdio_read(dev, np->phys[0], MII_ADVERTISE);\n\t\t\treg5 = mdio_read(dev, np->phys[0], MII_LPA);\n\t\t\tif (reg4 & ADVERTISE_100FULL && reg5 & LPA_100FULL) {\n\t\t\t\tnp->speed100 = 1;\n\t\t\t\tnp->mii_if.full_duplex = 1;\n\t\t\t} else if (reg4 & ADVERTISE_100HALF && reg5 & LPA_100HALF) {\n\t\t\t\tnp->speed100 = 1;\n\t\t\t\tnp->mii_if.full_duplex = 0;\n\t\t\t} else if (reg4 & ADVERTISE_10FULL && reg5 & LPA_10FULL) {\n\t\t\t\tnp->speed100 = 0;\n\t\t\t\tnp->mii_if.full_duplex = 1;\n\t\t\t} else {\n\t\t\t\tnp->speed100 = 0;\n\t\t\t\tnp->mii_if.full_duplex = 0;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tif (reg0 & BMCR_SPEED100)\n\t\t\t\tnp->speed100 = 1;\n\t\t\telse\n\t\t\t\tnp->speed100 = 0;\n\t\t\tif (reg0 & BMCR_FULLDPLX)\n\t\t\t\tnp->mii_if.full_duplex = 1;\n\t\t\telse\n\t\t\t\tnp->mii_if.full_duplex = 0;\n\t\t}\n\t\tnetif_carrier_on(dev);\n\t\tprintk(KERN_DEBUG \"%s: Link is up, running at %sMbit %s-duplex\\n\",\n\t\t       dev->name,\n\t\t       np->speed100 ? \"100\" : \"10\",\n\t\t       np->mii_if.full_duplex ? \"full\" : \"half\");\n\n\t\tnew_tx_mode = np->tx_mode & ~FullDuplex;\t \n\t\tif (np->mii_if.full_duplex)\n\t\t\tnew_tx_mode |= FullDuplex;\n\t\tif (np->tx_mode != new_tx_mode) {\n\t\t\tnp->tx_mode = new_tx_mode;\n\t\t\twritel(np->tx_mode | MiiSoftReset, ioaddr + TxMode);\n\t\t\tudelay(1000);\n\t\t\twritel(np->tx_mode, ioaddr + TxMode);\n\t\t}\n\n\t\tnew_intr_timer_ctrl = np->intr_timer_ctrl & ~Timer10X;\n\t\tif (np->speed100)\n\t\t\tnew_intr_timer_ctrl |= Timer10X;\n\t\tif (np->intr_timer_ctrl != new_intr_timer_ctrl) {\n\t\t\tnp->intr_timer_ctrl = new_intr_timer_ctrl;\n\t\t\twritel(new_intr_timer_ctrl, ioaddr + IntrTimerCtrl);\n\t\t}\n\t} else {\n\t\tnetif_carrier_off(dev);\n\t\tprintk(KERN_DEBUG \"%s: Link is down\\n\", dev->name);\n\t}\n}\n\n\nstatic void netdev_error(struct net_device *dev, int intr_status)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\n\t \n\tif (intr_status & IntrTxDataLow) {\n\t\tif (np->tx_threshold <= PKT_BUF_SZ / 16) {\n\t\t\twritel(++np->tx_threshold, np->base + TxThreshold);\n\t\t\tprintk(KERN_NOTICE \"%s: PCI bus congestion, increasing Tx FIFO threshold to %d bytes\\n\",\n\t\t\t       dev->name, np->tx_threshold * 16);\n\t\t} else\n\t\t\tprintk(KERN_WARNING \"%s: PCI Tx underflow -- adapter is probably malfunctioning\\n\", dev->name);\n\t}\n\tif (intr_status & IntrRxGFPDead) {\n\t\tdev->stats.rx_fifo_errors++;\n\t\tdev->stats.rx_errors++;\n\t}\n\tif (intr_status & (IntrNoTxCsum | IntrDMAErr)) {\n\t\tdev->stats.tx_fifo_errors++;\n\t\tdev->stats.tx_errors++;\n\t}\n\tif ((intr_status & ~(IntrNormalMask | IntrAbnormalSummary | IntrLinkChange | IntrStatsMax | IntrTxDataLow | IntrRxGFPDead | IntrNoTxCsum | IntrPCIPad)) && debug)\n\t\tprintk(KERN_ERR \"%s: Something Wicked happened! %#8.8x.\\n\",\n\t\t       dev->name, intr_status);\n}\n\n\nstatic struct net_device_stats *get_stats(struct net_device *dev)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tvoid __iomem *ioaddr = np->base;\n\n\t \n\tdev->stats.tx_bytes = readl(ioaddr + 0x57010);\n\tdev->stats.rx_bytes = readl(ioaddr + 0x57044);\n\tdev->stats.tx_packets = readl(ioaddr + 0x57000);\n\tdev->stats.tx_aborted_errors =\n\t\treadl(ioaddr + 0x57024) + readl(ioaddr + 0x57028);\n\tdev->stats.tx_window_errors = readl(ioaddr + 0x57018);\n\tdev->stats.collisions =\n\t\treadl(ioaddr + 0x57004) + readl(ioaddr + 0x57008);\n\n\t \n\tdev->stats.rx_dropped += readw(ioaddr + RxDMAStatus);\n\twritew(0, ioaddr + RxDMAStatus);\n\tdev->stats.rx_crc_errors = readl(ioaddr + 0x5703C);\n\tdev->stats.rx_frame_errors = readl(ioaddr + 0x57040);\n\tdev->stats.rx_length_errors = readl(ioaddr + 0x57058);\n\tdev->stats.rx_missed_errors = readl(ioaddr + 0x5707C);\n\n\treturn &dev->stats;\n}\n\n#ifdef VLAN_SUPPORT\nstatic u32 set_vlan_mode(struct netdev_private *np)\n{\n\tu32 ret = VlanMode;\n\tu16 vid;\n\tvoid __iomem *filter_addr = np->base + HashTable + 8;\n\tint vlan_count = 0;\n\n\tfor_each_set_bit(vid, np->active_vlans, VLAN_N_VID) {\n\t\tif (vlan_count == 32)\n\t\t\tbreak;\n\t\twritew(vid, filter_addr);\n\t\tfilter_addr += 16;\n\t\tvlan_count++;\n\t}\n\tif (vlan_count == 32) {\n\t\tret |= PerfectFilterVlan;\n\t\twhile (vlan_count < 32) {\n\t\t\twritew(0, filter_addr);\n\t\t\tfilter_addr += 16;\n\t\t\tvlan_count++;\n\t\t}\n\t}\n\treturn ret;\n}\n#endif  \n\nstatic void set_rx_mode(struct net_device *dev)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tvoid __iomem *ioaddr = np->base;\n\tu32 rx_mode = MinVLANPrio;\n\tstruct netdev_hw_addr *ha;\n\tint i;\n\n#ifdef VLAN_SUPPORT\n\trx_mode |= set_vlan_mode(np);\n#endif  \n\n\tif (dev->flags & IFF_PROMISC) {\t \n\t\trx_mode |= AcceptAll;\n\t} else if ((netdev_mc_count(dev) > multicast_filter_limit) ||\n\t\t   (dev->flags & IFF_ALLMULTI)) {\n\t\t \n\t\trx_mode |= AcceptBroadcast|AcceptAllMulticast|PerfectFilter;\n\t} else if (netdev_mc_count(dev) <= 14) {\n\t\t \n\t\tvoid __iomem *filter_addr = ioaddr + PerfFilterTable + 2 * 16;\n\t\tconst __be16 *eaddrs;\n\t\tnetdev_for_each_mc_addr(ha, dev) {\n\t\t\teaddrs = (__be16 *) ha->addr;\n\t\t\twritew(be16_to_cpu(eaddrs[2]), filter_addr); filter_addr += 4;\n\t\t\twritew(be16_to_cpu(eaddrs[1]), filter_addr); filter_addr += 4;\n\t\t\twritew(be16_to_cpu(eaddrs[0]), filter_addr); filter_addr += 8;\n\t\t}\n\t\teaddrs = (const __be16 *)dev->dev_addr;\n\t\ti = netdev_mc_count(dev) + 2;\n\t\twhile (i++ < 16) {\n\t\t\twritew(be16_to_cpu(eaddrs[0]), filter_addr); filter_addr += 4;\n\t\t\twritew(be16_to_cpu(eaddrs[1]), filter_addr); filter_addr += 4;\n\t\t\twritew(be16_to_cpu(eaddrs[2]), filter_addr); filter_addr += 8;\n\t\t}\n\t\trx_mode |= AcceptBroadcast|PerfectFilter;\n\t} else {\n\t\t \n\t\tvoid __iomem *filter_addr;\n\t\tconst __be16 *eaddrs;\n\t\t__le16 mc_filter[32] __attribute__ ((aligned(sizeof(long))));\t \n\n\t\tmemset(mc_filter, 0, sizeof(mc_filter));\n\t\tnetdev_for_each_mc_addr(ha, dev) {\n\t\t\t \n\t\t\tint bit_nr = ether_crc_le(ETH_ALEN, ha->addr) >> 23;\n\t\t\t__le32 *fptr = (__le32 *) &mc_filter[(bit_nr >> 4) & ~1];\n\n\t\t\t*fptr |= cpu_to_le32(1 << (bit_nr & 31));\n\t\t}\n\t\t \n\t\tfilter_addr = ioaddr + PerfFilterTable + 2 * 16;\n\t\teaddrs = (const __be16 *)dev->dev_addr;\n\t\tfor (i = 2; i < 16; i++) {\n\t\t\twritew(be16_to_cpu(eaddrs[0]), filter_addr); filter_addr += 4;\n\t\t\twritew(be16_to_cpu(eaddrs[1]), filter_addr); filter_addr += 4;\n\t\t\twritew(be16_to_cpu(eaddrs[2]), filter_addr); filter_addr += 8;\n\t\t}\n\t\tfor (filter_addr = ioaddr + HashTable, i = 0; i < 32; filter_addr+= 16, i++)\n\t\t\twritew(mc_filter[i], filter_addr);\n\t\trx_mode |= AcceptBroadcast|PerfectFilter|HashFilter;\n\t}\n\twritel(rx_mode, ioaddr + RxFilterMode);\n}\n\nstatic int check_if_running(struct net_device *dev)\n{\n\tif (!netif_running(dev))\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic void get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *info)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tstrscpy(info->driver, DRV_NAME, sizeof(info->driver));\n\tstrscpy(info->bus_info, pci_name(np->pci_dev), sizeof(info->bus_info));\n}\n\nstatic int get_link_ksettings(struct net_device *dev,\n\t\t\t      struct ethtool_link_ksettings *cmd)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tspin_lock_irq(&np->lock);\n\tmii_ethtool_get_link_ksettings(&np->mii_if, cmd);\n\tspin_unlock_irq(&np->lock);\n\treturn 0;\n}\n\nstatic int set_link_ksettings(struct net_device *dev,\n\t\t\t      const struct ethtool_link_ksettings *cmd)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tint res;\n\tspin_lock_irq(&np->lock);\n\tres = mii_ethtool_set_link_ksettings(&np->mii_if, cmd);\n\tspin_unlock_irq(&np->lock);\n\tcheck_duplex(dev);\n\treturn res;\n}\n\nstatic int nway_reset(struct net_device *dev)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\treturn mii_nway_restart(&np->mii_if);\n}\n\nstatic u32 get_link(struct net_device *dev)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\treturn mii_link_ok(&np->mii_if);\n}\n\nstatic u32 get_msglevel(struct net_device *dev)\n{\n\treturn debug;\n}\n\nstatic void set_msglevel(struct net_device *dev, u32 val)\n{\n\tdebug = val;\n}\n\nstatic const struct ethtool_ops ethtool_ops = {\n\t.begin = check_if_running,\n\t.get_drvinfo = get_drvinfo,\n\t.nway_reset = nway_reset,\n\t.get_link = get_link,\n\t.get_msglevel = get_msglevel,\n\t.set_msglevel = set_msglevel,\n\t.get_link_ksettings = get_link_ksettings,\n\t.set_link_ksettings = set_link_ksettings,\n};\n\nstatic int netdev_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tstruct mii_ioctl_data *data = if_mii(rq);\n\tint rc;\n\n\tif (!netif_running(dev))\n\t\treturn -EINVAL;\n\n\tspin_lock_irq(&np->lock);\n\trc = generic_mii_ioctl(&np->mii_if, data, cmd, NULL);\n\tspin_unlock_irq(&np->lock);\n\n\tif ((cmd == SIOCSMIIREG) && (data->phy_id == np->phys[0]))\n\t\tcheck_duplex(dev);\n\n\treturn rc;\n}\n\nstatic int netdev_close(struct net_device *dev)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tvoid __iomem *ioaddr = np->base;\n\tint i;\n\n\tnetif_stop_queue(dev);\n\n\tnapi_disable(&np->napi);\n\n\tif (debug > 1) {\n\t\tprintk(KERN_DEBUG \"%s: Shutting down ethercard, Intr status %#8.8x.\\n\",\n\t\t\t   dev->name, (int) readl(ioaddr + IntrStatus));\n\t\tprintk(KERN_DEBUG \"%s: Queue pointers were Tx %d / %d, Rx %d / %d.\\n\",\n\t\t       dev->name, np->cur_tx, np->dirty_tx,\n\t\t       np->cur_rx, np->dirty_rx);\n\t}\n\n\t \n\twritel(0, ioaddr + IntrEnable);\n\n\t \n\twritel(0, ioaddr + GenCtrl);\n\treadl(ioaddr + GenCtrl);\n\n\tif (debug > 5) {\n\t\tprintk(KERN_DEBUG\"  Tx ring at %#llx:\\n\",\n\t\t       (long long) np->tx_ring_dma);\n\t\tfor (i = 0; i < 8  ; i++)\n\t\t\tprintk(KERN_DEBUG \" #%d desc. %#8.8x %#llx -> %#8.8x.\\n\",\n\t\t\t       i, le32_to_cpu(np->tx_ring[i].status),\n\t\t\t       (long long) dma_to_cpu(np->tx_ring[i].addr),\n\t\t\t       le32_to_cpu(np->tx_done_q[i].status));\n\t\tprintk(KERN_DEBUG \"  Rx ring at %#llx -> %p:\\n\",\n\t\t       (long long) np->rx_ring_dma, np->rx_done_q);\n\t\tif (np->rx_done_q)\n\t\t\tfor (i = 0; i < 8  ; i++) {\n\t\t\t\tprintk(KERN_DEBUG \" #%d desc. %#llx -> %#8.8x\\n\",\n\t\t\t\t       i, (long long) dma_to_cpu(np->rx_ring[i].rxaddr), le32_to_cpu(np->rx_done_q[i].status));\n\t\t}\n\t}\n\n\tfree_irq(np->pci_dev->irq, dev);\n\n\t \n\tfor (i = 0; i < RX_RING_SIZE; i++) {\n\t\tnp->rx_ring[i].rxaddr = cpu_to_dma(0xBADF00D0);  \n\t\tif (np->rx_info[i].skb != NULL) {\n\t\t\tdma_unmap_single(&np->pci_dev->dev,\n\t\t\t\t\t np->rx_info[i].mapping,\n\t\t\t\t\t np->rx_buf_sz, DMA_FROM_DEVICE);\n\t\t\tdev_kfree_skb(np->rx_info[i].skb);\n\t\t}\n\t\tnp->rx_info[i].skb = NULL;\n\t\tnp->rx_info[i].mapping = 0;\n\t}\n\tfor (i = 0; i < TX_RING_SIZE; i++) {\n\t\tstruct sk_buff *skb = np->tx_info[i].skb;\n\t\tif (skb == NULL)\n\t\t\tcontinue;\n\t\tdma_unmap_single(&np->pci_dev->dev, np->tx_info[i].mapping,\n\t\t\t\t skb_first_frag_len(skb), DMA_TO_DEVICE);\n\t\tnp->tx_info[i].mapping = 0;\n\t\tdev_kfree_skb(skb);\n\t\tnp->tx_info[i].skb = NULL;\n\t}\n\n\treturn 0;\n}\n\nstatic int __maybe_unused starfire_suspend(struct device *dev_d)\n{\n\tstruct net_device *dev = dev_get_drvdata(dev_d);\n\n\tif (netif_running(dev)) {\n\t\tnetif_device_detach(dev);\n\t\tnetdev_close(dev);\n\t}\n\n\treturn 0;\n}\n\nstatic int __maybe_unused starfire_resume(struct device *dev_d)\n{\n\tstruct net_device *dev = dev_get_drvdata(dev_d);\n\n\tif (netif_running(dev)) {\n\t\tnetdev_open(dev);\n\t\tnetif_device_attach(dev);\n\t}\n\n\treturn 0;\n}\n\nstatic void starfire_remove_one(struct pci_dev *pdev)\n{\n\tstruct net_device *dev = pci_get_drvdata(pdev);\n\tstruct netdev_private *np = netdev_priv(dev);\n\n\tBUG_ON(!dev);\n\n\tunregister_netdev(dev);\n\n\tif (np->queue_mem)\n\t\tdma_free_coherent(&pdev->dev, np->queue_mem_size,\n\t\t\t\t  np->queue_mem, np->queue_mem_dma);\n\n\n\t \n\tpci_set_power_state(pdev, PCI_D3hot);\t \n\tpci_disable_device(pdev);\n\n\tiounmap(np->base);\n\tpci_release_regions(pdev);\n\n\tfree_netdev(dev);\t\t\t \n}\n\nstatic SIMPLE_DEV_PM_OPS(starfire_pm_ops, starfire_suspend, starfire_resume);\n\nstatic struct pci_driver starfire_driver = {\n\t.name\t\t= DRV_NAME,\n\t.probe\t\t= starfire_init_one,\n\t.remove\t\t= starfire_remove_one,\n\t.driver.pm\t= &starfire_pm_ops,\n\t.id_table\t= starfire_pci_tbl,\n};\n\n\nstatic int __init starfire_init (void)\n{\n \n#ifdef MODULE\n\tprintk(KERN_INFO DRV_NAME \": polling (NAPI) enabled\\n\");\n#endif\n\n\tBUILD_BUG_ON(sizeof(dma_addr_t) != sizeof(netdrv_addr_t));\n\n\treturn pci_register_driver(&starfire_driver);\n}\n\n\nstatic void __exit starfire_cleanup (void)\n{\n\tpci_unregister_driver (&starfire_driver);\n}\n\n\nmodule_init(starfire_init);\nmodule_exit(starfire_cleanup);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}