{
  "module_name": "nic_main.c",
  "hash_id": "ecc242c1e68121369e7bb7d81b11f228c1bad3e980059dbcfec4cd2fc92b5340",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/cavium/thunder/nic_main.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/etherdevice.h>\n#include <linux/of.h>\n#include <linux/if_vlan.h>\n\n#include \"nic_reg.h\"\n#include \"nic.h\"\n#include \"q_struct.h\"\n#include \"thunder_bgx.h\"\n\n#define DRV_NAME\t\"nicpf\"\n#define DRV_VERSION\t\"1.0\"\n\n#define NIC_VF_PER_MBX_REG      64\n\nstruct hw_info {\n\tu8\t\tbgx_cnt;\n\tu8\t\tchans_per_lmac;\n\tu8\t\tchans_per_bgx;  \n\tu8\t\tchans_per_rgx;\n\tu8\t\tchans_per_lbk;\n\tu16\t\tcpi_cnt;\n\tu16\t\trssi_cnt;\n\tu16\t\trss_ind_tbl_size;\n\tu16\t\ttl4_cnt;\n\tu16\t\ttl3_cnt;\n\tu8\t\ttl2_cnt;\n\tu8\t\ttl1_cnt;\n\tbool\t\ttl1_per_bgx;  \n};\n\nstruct nicpf {\n\tstruct pci_dev\t\t*pdev;\n\tstruct hw_info          *hw;\n\tu8\t\t\tnode;\n\tunsigned int\t\tflags;\n\tu8\t\t\tnum_vf_en;       \n\tbool\t\t\tvf_enabled[MAX_NUM_VFS_SUPPORTED];\n\tvoid __iomem\t\t*reg_base;        \n\tu8\t\t\tnum_sqs_en;\t \n\tu64\t\t\tnicvf[MAX_NUM_VFS_SUPPORTED];\n\tu8\t\t\tvf_sqs[MAX_NUM_VFS_SUPPORTED][MAX_SQS_PER_VF];\n\tu8\t\t\tpqs_vf[MAX_NUM_VFS_SUPPORTED];\n\tbool\t\t\tsqs_used[MAX_NUM_VFS_SUPPORTED];\n\tstruct pkind_cfg\tpkind;\n#define\tNIC_SET_VF_LMAC_MAP(bgx, lmac)\t(((bgx & 0xF) << 4) | (lmac & 0xF))\n#define\tNIC_GET_BGX_FROM_VF_LMAC_MAP(map)\t((map >> 4) & 0xF)\n#define\tNIC_GET_LMAC_FROM_VF_LMAC_MAP(map)\t(map & 0xF)\n\tu8\t\t\t*vf_lmac_map;\n\tu16\t\t\tcpi_base[MAX_NUM_VFS_SUPPORTED];\n\tu16\t\t\trssi_base[MAX_NUM_VFS_SUPPORTED];\n\n\t \n\tu8\t\t\tnum_vec;\n\tunsigned int\t\tirq_allocated[NIC_PF_MSIX_VECTORS];\n\tchar\t\t\tirq_name[NIC_PF_MSIX_VECTORS][20];\n};\n\n \nstatic const struct pci_device_id nic_id_table[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_CAVIUM, PCI_DEVICE_ID_THUNDER_NIC_PF) },\n\t{ 0, }   \n};\n\nMODULE_AUTHOR(\"Sunil Goutham\");\nMODULE_DESCRIPTION(\"Cavium Thunder NIC Physical Function Driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_VERSION(DRV_VERSION);\nMODULE_DEVICE_TABLE(pci, nic_id_table);\n\n \n\n \nstatic void nic_reg_write(struct nicpf *nic, u64 offset, u64 val)\n{\n\twriteq_relaxed(val, nic->reg_base + offset);\n}\n\nstatic u64 nic_reg_read(struct nicpf *nic, u64 offset)\n{\n\treturn readq_relaxed(nic->reg_base + offset);\n}\n\n \nstatic void nic_enable_mbx_intr(struct nicpf *nic)\n{\n\tint vf_cnt = pci_sriov_get_totalvfs(nic->pdev);\n\n#define INTR_MASK(vfs) ((vfs < 64) ? (BIT_ULL(vfs) - 1) : (~0ull))\n\n\t \n\tnic_reg_write(nic, NIC_PF_MAILBOX_INT, INTR_MASK(vf_cnt));\n\n\t \n\tnic_reg_write(nic, NIC_PF_MAILBOX_ENA_W1S, INTR_MASK(vf_cnt));\n\t \n\tif (vf_cnt > 64) {\n\t\tnic_reg_write(nic, NIC_PF_MAILBOX_INT + sizeof(u64),\n\t\t\t      INTR_MASK(vf_cnt - 64));\n\t\tnic_reg_write(nic, NIC_PF_MAILBOX_ENA_W1S + sizeof(u64),\n\t\t\t      INTR_MASK(vf_cnt - 64));\n\t}\n}\n\nstatic void nic_clear_mbx_intr(struct nicpf *nic, int vf, int mbx_reg)\n{\n\tnic_reg_write(nic, NIC_PF_MAILBOX_INT + (mbx_reg << 3), BIT_ULL(vf));\n}\n\nstatic u64 nic_get_mbx_addr(int vf)\n{\n\treturn NIC_PF_VF_0_127_MAILBOX_0_1 + (vf << NIC_VF_NUM_SHIFT);\n}\n\n \nstatic void nic_send_msg_to_vf(struct nicpf *nic, int vf, union nic_mbx *mbx)\n{\n\tvoid __iomem *mbx_addr = nic->reg_base + nic_get_mbx_addr(vf);\n\tu64 *msg = (u64 *)mbx;\n\n\t \n\tif (pass1_silicon(nic->pdev)) {\n\t\t \n\t\twriteq_relaxed(msg[0], mbx_addr);\n\t\twriteq_relaxed(msg[1], mbx_addr + 8);\n\t} else {\n\t\twriteq_relaxed(msg[1], mbx_addr + 8);\n\t\twriteq_relaxed(msg[0], mbx_addr);\n\t}\n}\n\n \nstatic void nic_mbx_send_ready(struct nicpf *nic, int vf)\n{\n\tunion nic_mbx mbx = {};\n\tint bgx_idx, lmac;\n\tconst char *mac;\n\n\tmbx.nic_cfg.msg = NIC_MBOX_MSG_READY;\n\tmbx.nic_cfg.vf_id = vf;\n\n\tmbx.nic_cfg.tns_mode = NIC_TNS_BYPASS_MODE;\n\n\tif (vf < nic->num_vf_en) {\n\t\tbgx_idx = NIC_GET_BGX_FROM_VF_LMAC_MAP(nic->vf_lmac_map[vf]);\n\t\tlmac = NIC_GET_LMAC_FROM_VF_LMAC_MAP(nic->vf_lmac_map[vf]);\n\n\t\tmac = bgx_get_lmac_mac(nic->node, bgx_idx, lmac);\n\t\tif (mac)\n\t\t\tether_addr_copy((u8 *)&mbx.nic_cfg.mac_addr, mac);\n\t}\n\tmbx.nic_cfg.sqs_mode = (vf >= nic->num_vf_en) ? true : false;\n\tmbx.nic_cfg.node_id = nic->node;\n\n\tmbx.nic_cfg.loopback_supported = vf < nic->num_vf_en;\n\n\tnic_send_msg_to_vf(nic, vf, &mbx);\n}\n\n \nstatic void nic_mbx_send_ack(struct nicpf *nic, int vf)\n{\n\tunion nic_mbx mbx = {};\n\n\tmbx.msg.msg = NIC_MBOX_MSG_ACK;\n\tnic_send_msg_to_vf(nic, vf, &mbx);\n}\n\n \nstatic void nic_mbx_send_nack(struct nicpf *nic, int vf)\n{\n\tunion nic_mbx mbx = {};\n\n\tmbx.msg.msg = NIC_MBOX_MSG_NACK;\n\tnic_send_msg_to_vf(nic, vf, &mbx);\n}\n\n \nstatic int nic_rcv_queue_sw_sync(struct nicpf *nic)\n{\n\tu16 timeout = ~0x00;\n\n\tnic_reg_write(nic, NIC_PF_SW_SYNC_RX, 0x01);\n\t \n\twhile (timeout) {\n\t\tif (nic_reg_read(nic, NIC_PF_SW_SYNC_RX_DONE) & 0x1)\n\t\t\tbreak;\n\t\ttimeout--;\n\t}\n\tnic_reg_write(nic, NIC_PF_SW_SYNC_RX, 0x00);\n\tif (!timeout) {\n\t\tdev_err(&nic->pdev->dev, \"Receive queue software sync failed\");\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n \nstatic void nic_get_bgx_stats(struct nicpf *nic, struct bgx_stats_msg *bgx)\n{\n\tint bgx_idx, lmac;\n\tunion nic_mbx mbx = {};\n\n\tbgx_idx = NIC_GET_BGX_FROM_VF_LMAC_MAP(nic->vf_lmac_map[bgx->vf_id]);\n\tlmac = NIC_GET_LMAC_FROM_VF_LMAC_MAP(nic->vf_lmac_map[bgx->vf_id]);\n\n\tmbx.bgx_stats.msg = NIC_MBOX_MSG_BGX_STATS;\n\tmbx.bgx_stats.vf_id = bgx->vf_id;\n\tmbx.bgx_stats.rx = bgx->rx;\n\tmbx.bgx_stats.idx = bgx->idx;\n\tif (bgx->rx)\n\t\tmbx.bgx_stats.stats = bgx_get_rx_stats(nic->node, bgx_idx,\n\t\t\t\t\t\t\t    lmac, bgx->idx);\n\telse\n\t\tmbx.bgx_stats.stats = bgx_get_tx_stats(nic->node, bgx_idx,\n\t\t\t\t\t\t\t    lmac, bgx->idx);\n\tnic_send_msg_to_vf(nic, bgx->vf_id, &mbx);\n}\n\n \nstatic int nic_update_hw_frs(struct nicpf *nic, int new_frs, int vf)\n{\n\tint bgx, lmac, lmac_cnt;\n\tu64 lmac_credits;\n\n\tif ((new_frs > NIC_HW_MAX_FRS) || (new_frs < NIC_HW_MIN_FRS))\n\t\treturn 1;\n\n\tbgx = NIC_GET_BGX_FROM_VF_LMAC_MAP(nic->vf_lmac_map[vf]);\n\tlmac = NIC_GET_LMAC_FROM_VF_LMAC_MAP(nic->vf_lmac_map[vf]);\n\tlmac += bgx * MAX_LMAC_PER_BGX;\n\n\tnew_frs += VLAN_ETH_HLEN + ETH_FCS_LEN + 4;\n\n\t \n\tlmac_cnt = bgx_get_lmac_count(nic->node, bgx);\n\tlmac_credits = nic_reg_read(nic, NIC_PF_LMAC_0_7_CREDIT + (lmac * 8));\n\tlmac_credits &= ~(0xFFFFFULL << 12);\n\tlmac_credits |= (((((48 * 1024) / lmac_cnt) - new_frs) / 16) << 12);\n\tnic_reg_write(nic, NIC_PF_LMAC_0_7_CREDIT + (lmac * 8), lmac_credits);\n\n\t \n\tif (!pass1_silicon(nic->pdev))\n\t\tnic_reg_write(nic,\n\t\t\t      NIC_PF_LMAC_0_7_CFG2 + (lmac * 8), new_frs);\n\treturn 0;\n}\n\n \nstatic void nic_set_tx_pkt_pad(struct nicpf *nic, int size)\n{\n\tint lmac, max_lmac;\n\tu16 sdevid;\n\tu64 lmac_cfg;\n\n\t \n\tif (size > 52)\n\t\tsize = 52;\n\n\tpci_read_config_word(nic->pdev, PCI_SUBSYSTEM_ID, &sdevid);\n\t \n\tif (sdevid == PCI_SUBSYS_DEVID_81XX_NIC_PF)\n\t\tmax_lmac = ((nic->hw->bgx_cnt - 1) * MAX_LMAC_PER_BGX) + 1;\n\telse\n\t\tmax_lmac = nic->hw->bgx_cnt * MAX_LMAC_PER_BGX;\n\n\tfor (lmac = 0; lmac < max_lmac; lmac++) {\n\t\tlmac_cfg = nic_reg_read(nic, NIC_PF_LMAC_0_7_CFG | (lmac << 3));\n\t\tlmac_cfg &= ~(0xF << 2);\n\t\tlmac_cfg |= ((size / 4) << 2);\n\t\tnic_reg_write(nic, NIC_PF_LMAC_0_7_CFG | (lmac << 3), lmac_cfg);\n\t}\n}\n\n \nstatic void nic_set_lmac_vf_mapping(struct nicpf *nic)\n{\n\tunsigned bgx_map = bgx_get_map(nic->node);\n\tint bgx, next_bgx_lmac = 0;\n\tint lmac, lmac_cnt = 0;\n\tu64 lmac_credit;\n\n\tnic->num_vf_en = 0;\n\n\tfor (bgx = 0; bgx < nic->hw->bgx_cnt; bgx++) {\n\t\tif (!(bgx_map & (1 << bgx)))\n\t\t\tcontinue;\n\t\tlmac_cnt = bgx_get_lmac_count(nic->node, bgx);\n\t\tfor (lmac = 0; lmac < lmac_cnt; lmac++)\n\t\t\tnic->vf_lmac_map[next_bgx_lmac++] =\n\t\t\t\t\t\tNIC_SET_VF_LMAC_MAP(bgx, lmac);\n\t\tnic->num_vf_en += lmac_cnt;\n\n\t\t \n\t\tlmac_credit = (1ull << 1);  \n\t\tlmac_credit |= (0x1ff << 2);  \n\t\t \n\t\tlmac_credit |= (((((48 * 1024) / lmac_cnt) -\n\t\t\t\tNIC_HW_MAX_FRS) / 16) << 12);\n\t\tlmac = bgx * MAX_LMAC_PER_BGX;\n\t\tfor (; lmac < lmac_cnt + (bgx * MAX_LMAC_PER_BGX); lmac++)\n\t\t\tnic_reg_write(nic,\n\t\t\t\t      NIC_PF_LMAC_0_7_CREDIT + (lmac * 8),\n\t\t\t\t      lmac_credit);\n\n\t\t \n\t\tif (nic->num_vf_en >= pci_sriov_get_totalvfs(nic->pdev)) {\n\t\t\tnic->num_vf_en = pci_sriov_get_totalvfs(nic->pdev);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void nic_get_hw_info(struct nicpf *nic)\n{\n\tu16 sdevid;\n\tstruct hw_info *hw = nic->hw;\n\n\tpci_read_config_word(nic->pdev, PCI_SUBSYSTEM_ID, &sdevid);\n\n\tswitch (sdevid) {\n\tcase PCI_SUBSYS_DEVID_88XX_NIC_PF:\n\t\thw->bgx_cnt = MAX_BGX_PER_CN88XX;\n\t\thw->chans_per_lmac = 16;\n\t\thw->chans_per_bgx = 128;\n\t\thw->cpi_cnt = 2048;\n\t\thw->rssi_cnt = 4096;\n\t\thw->rss_ind_tbl_size = NIC_MAX_RSS_IDR_TBL_SIZE;\n\t\thw->tl3_cnt = 256;\n\t\thw->tl2_cnt = 64;\n\t\thw->tl1_cnt = 2;\n\t\thw->tl1_per_bgx = true;\n\t\tbreak;\n\tcase PCI_SUBSYS_DEVID_81XX_NIC_PF:\n\t\thw->bgx_cnt = MAX_BGX_PER_CN81XX;\n\t\thw->chans_per_lmac = 8;\n\t\thw->chans_per_bgx = 32;\n\t\thw->chans_per_rgx = 8;\n\t\thw->chans_per_lbk = 24;\n\t\thw->cpi_cnt = 512;\n\t\thw->rssi_cnt = 256;\n\t\thw->rss_ind_tbl_size = 32;  \n\t\thw->tl3_cnt = 64;\n\t\thw->tl2_cnt = 16;\n\t\thw->tl1_cnt = 10;\n\t\thw->tl1_per_bgx = false;\n\t\tbreak;\n\tcase PCI_SUBSYS_DEVID_83XX_NIC_PF:\n\t\thw->bgx_cnt = MAX_BGX_PER_CN83XX;\n\t\thw->chans_per_lmac = 8;\n\t\thw->chans_per_bgx = 32;\n\t\thw->chans_per_lbk = 64;\n\t\thw->cpi_cnt = 2048;\n\t\thw->rssi_cnt = 1024;\n\t\thw->rss_ind_tbl_size = 64;  \n\t\thw->tl3_cnt = 256;\n\t\thw->tl2_cnt = 64;\n\t\thw->tl1_cnt = 18;\n\t\thw->tl1_per_bgx = false;\n\t\tbreak;\n\t}\n\thw->tl4_cnt = MAX_QUEUES_PER_QSET * pci_sriov_get_totalvfs(nic->pdev);\n}\n\n#define BGX0_BLOCK 8\n#define BGX1_BLOCK 9\n\nstatic void nic_init_hw(struct nicpf *nic)\n{\n\tint i;\n\tu64 cqm_cfg;\n\n\t \n\tnic_reg_write(nic, NIC_PF_CFG, 0x3);\n\n\t \n\tnic_reg_write(nic, NIC_PF_BP_CFG, (1ULL << 6) | 0x03);\n\n\t \n\tif (nic->pdev->subsystem_device == PCI_SUBSYS_DEVID_88XX_NIC_PF) {\n\t\t \n\t\tnic_reg_write(nic, NIC_PF_INTF_0_1_SEND_CFG,\n\t\t\t      (NIC_TNS_BYPASS_MODE << 7) |\n\t\t\t      BGX0_BLOCK | (1ULL << 16));\n\t\tnic_reg_write(nic, NIC_PF_INTF_0_1_SEND_CFG | (1 << 8),\n\t\t\t      (NIC_TNS_BYPASS_MODE << 7) |\n\t\t\t      BGX1_BLOCK | (1ULL << 16));\n\t} else {\n\t\t \n\t\tfor (i = 0; i < nic->hw->bgx_cnt; i++)\n\t\t\tnic_reg_write(nic, NIC_PF_INTFX_SEND_CFG | (i << 3),\n\t\t\t\t      (1ULL << 16));\n\t}\n\n\tnic_reg_write(nic, NIC_PF_INTF_0_1_BP_CFG,\n\t\t      (1ULL << 63) | BGX0_BLOCK);\n\tnic_reg_write(nic, NIC_PF_INTF_0_1_BP_CFG + (1 << 8),\n\t\t      (1ULL << 63) | BGX1_BLOCK);\n\n\t \n\tnic->pkind.minlen = 0;\n\tnic->pkind.maxlen = NIC_HW_MAX_FRS + VLAN_ETH_HLEN + ETH_FCS_LEN + 4;\n\tnic->pkind.lenerr_en = 1;\n\tnic->pkind.rx_hdr = 0;\n\tnic->pkind.hdr_sl = 0;\n\n\tfor (i = 0; i < NIC_MAX_PKIND; i++)\n\t\tnic_reg_write(nic, NIC_PF_PKIND_0_15_CFG | (i << 3),\n\t\t\t      *(u64 *)&nic->pkind);\n\n\tnic_set_tx_pkt_pad(nic, NIC_HW_MIN_FRS);\n\n\t \n\tnic_reg_write(nic, NIC_PF_INTR_TIMER_CFG, NICPF_CLK_PER_INT_TICK);\n\n\t \n\tnic_reg_write(nic, NIC_PF_RX_ETYPE_0_7,\n\t\t      (2 << 19) | (ETYPE_ALG_VLAN_STRIP << 16) | ETH_P_8021Q);\n\n\t \n\tcqm_cfg = nic_reg_read(nic, NIC_PF_CQM_CFG);\n\tif (cqm_cfg < NICPF_CQM_MIN_DROP_LEVEL)\n\t\tnic_reg_write(nic, NIC_PF_CQM_CFG, NICPF_CQM_MIN_DROP_LEVEL);\n}\n\n \nstatic void nic_config_cpi(struct nicpf *nic, struct cpi_cfg_msg *cfg)\n{\n\tstruct hw_info *hw = nic->hw;\n\tu32 vnic, bgx, lmac, chan;\n\tu32 padd, cpi_count = 0;\n\tu64 cpi_base, cpi, rssi_base, rssi;\n\tu8  qset, rq_idx = 0;\n\n\tvnic = cfg->vf_id;\n\tbgx = NIC_GET_BGX_FROM_VF_LMAC_MAP(nic->vf_lmac_map[vnic]);\n\tlmac = NIC_GET_LMAC_FROM_VF_LMAC_MAP(nic->vf_lmac_map[vnic]);\n\n\tchan = (lmac * hw->chans_per_lmac) + (bgx * hw->chans_per_bgx);\n\tcpi_base = vnic * NIC_MAX_CPI_PER_LMAC;\n\trssi_base = vnic * hw->rss_ind_tbl_size;\n\n\t \n\tnic_reg_write(nic, NIC_PF_CHAN_0_255_RX_BP_CFG | (chan << 3),\n\t\t      (1ull << 63) | (vnic << 0));\n\tnic_reg_write(nic, NIC_PF_CHAN_0_255_RX_CFG | (chan << 3),\n\t\t      ((u64)cfg->cpi_alg << 62) | (cpi_base << 48));\n\n\tif (cfg->cpi_alg == CPI_ALG_NONE)\n\t\tcpi_count = 1;\n\telse if (cfg->cpi_alg == CPI_ALG_VLAN)  \n\t\tcpi_count = 8;\n\telse if (cfg->cpi_alg == CPI_ALG_VLAN16)  \n\t\tcpi_count = 16;\n\telse if (cfg->cpi_alg == CPI_ALG_DIFF)  \n\t\tcpi_count = NIC_MAX_CPI_PER_LMAC;\n\n\t \n\tqset = cfg->vf_id;\n\trssi = rssi_base;\n\tfor (; rssi < (rssi_base + cfg->rq_cnt); rssi++) {\n\t\tnic_reg_write(nic, NIC_PF_RSSI_0_4097_RQ | (rssi << 3),\n\t\t\t      (qset << 3) | rq_idx);\n\t\trq_idx++;\n\t}\n\n\trssi = 0;\n\tcpi = cpi_base;\n\tfor (; cpi < (cpi_base + cpi_count); cpi++) {\n\t\t \n\t\tif (cfg->cpi_alg != CPI_ALG_DIFF)\n\t\t\tpadd = cpi % cpi_count;\n\t\telse\n\t\t\tpadd = cpi % 8;  \n\n\t\t \n\t\tif (pass1_silicon(nic->pdev)) {\n\t\t\tnic_reg_write(nic, NIC_PF_CPI_0_2047_CFG | (cpi << 3),\n\t\t\t\t      (vnic << 24) | (padd << 16) |\n\t\t\t\t      (rssi_base + rssi));\n\t\t} else {\n\t\t\t \n\t\t\tnic_reg_write(nic, NIC_PF_CPI_0_2047_CFG | (cpi << 3),\n\t\t\t\t      (padd << 16));\n\t\t\t \n\t\t\tnic_reg_write(nic, NIC_PF_MPI_0_2047_CFG | (cpi << 3),\n\t\t\t\t      (vnic << 24) | (rssi_base + rssi));\n\t\t}\n\n\t\tif ((rssi + 1) >= cfg->rq_cnt)\n\t\t\tcontinue;\n\n\t\tif (cfg->cpi_alg == CPI_ALG_VLAN)\n\t\t\trssi++;\n\t\telse if (cfg->cpi_alg == CPI_ALG_VLAN16)\n\t\t\trssi = ((cpi - cpi_base) & 0xe) >> 1;\n\t\telse if (cfg->cpi_alg == CPI_ALG_DIFF)\n\t\t\trssi = ((cpi - cpi_base) & 0x38) >> 3;\n\t}\n\tnic->cpi_base[cfg->vf_id] = cpi_base;\n\tnic->rssi_base[cfg->vf_id] = rssi_base;\n}\n\n \nstatic void nic_send_rss_size(struct nicpf *nic, int vf)\n{\n\tunion nic_mbx mbx = {};\n\n\tmbx.rss_size.msg = NIC_MBOX_MSG_RSS_SIZE;\n\tmbx.rss_size.ind_tbl_size = nic->hw->rss_ind_tbl_size;\n\tnic_send_msg_to_vf(nic, vf, &mbx);\n}\n\n \nstatic void nic_config_rss(struct nicpf *nic, struct rss_cfg_msg *cfg)\n{\n\tu8  qset, idx = 0;\n\tu64 cpi_cfg, cpi_base, rssi_base, rssi;\n\tu64 idx_addr;\n\n\trssi_base = nic->rssi_base[cfg->vf_id] + cfg->tbl_offset;\n\n\trssi = rssi_base;\n\n\tfor (; rssi < (rssi_base + cfg->tbl_len); rssi++) {\n\t\tu8 svf = cfg->ind_tbl[idx] >> 3;\n\n\t\tif (svf)\n\t\t\tqset = nic->vf_sqs[cfg->vf_id][svf - 1];\n\t\telse\n\t\t\tqset = cfg->vf_id;\n\t\tnic_reg_write(nic, NIC_PF_RSSI_0_4097_RQ | (rssi << 3),\n\t\t\t      (qset << 3) | (cfg->ind_tbl[idx] & 0x7));\n\t\tidx++;\n\t}\n\n\tcpi_base = nic->cpi_base[cfg->vf_id];\n\tif (pass1_silicon(nic->pdev))\n\t\tidx_addr = NIC_PF_CPI_0_2047_CFG;\n\telse\n\t\tidx_addr = NIC_PF_MPI_0_2047_CFG;\n\tcpi_cfg = nic_reg_read(nic, idx_addr | (cpi_base << 3));\n\tcpi_cfg &= ~(0xFULL << 20);\n\tcpi_cfg |= (cfg->hash_bits << 20);\n\tnic_reg_write(nic, idx_addr | (cpi_base << 3), cpi_cfg);\n}\n\n \nstatic void nic_tx_channel_cfg(struct nicpf *nic, u8 vnic,\n\t\t\t       struct sq_cfg_msg *sq)\n{\n\tstruct hw_info *hw = nic->hw;\n\tu32 bgx, lmac, chan;\n\tu32 tl2, tl3, tl4;\n\tu32 rr_quantum;\n\tu8 sq_idx = sq->sq_num;\n\tu8 pqs_vnic;\n\tint svf;\n\n\tif (sq->sqs_mode)\n\t\tpqs_vnic = nic->pqs_vf[vnic];\n\telse\n\t\tpqs_vnic = vnic;\n\n\tbgx = NIC_GET_BGX_FROM_VF_LMAC_MAP(nic->vf_lmac_map[pqs_vnic]);\n\tlmac = NIC_GET_LMAC_FROM_VF_LMAC_MAP(nic->vf_lmac_map[pqs_vnic]);\n\n\t \n\trr_quantum = ((NIC_HW_MAX_FRS + 24) / 4);\n\n\t \n\tif (hw->tl1_per_bgx) {\n\t\ttl4 = bgx * (hw->tl4_cnt / hw->bgx_cnt);\n\t\tif (!sq->sqs_mode) {\n\t\t\ttl4 += (lmac * MAX_QUEUES_PER_QSET);\n\t\t} else {\n\t\t\tfor (svf = 0; svf < MAX_SQS_PER_VF; svf++) {\n\t\t\t\tif (nic->vf_sqs[pqs_vnic][svf] == vnic)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttl4 += (MAX_LMAC_PER_BGX * MAX_QUEUES_PER_QSET);\n\t\t\ttl4 += (lmac * MAX_QUEUES_PER_QSET * MAX_SQS_PER_VF);\n\t\t\ttl4 += (svf * MAX_QUEUES_PER_QSET);\n\t\t}\n\t} else {\n\t\ttl4 = (vnic * MAX_QUEUES_PER_QSET);\n\t}\n\ttl4 += sq_idx;\n\n\ttl3 = tl4 / (hw->tl4_cnt / hw->tl3_cnt);\n\tnic_reg_write(nic, NIC_PF_QSET_0_127_SQ_0_7_CFG2 |\n\t\t      ((u64)vnic << NIC_QS_ID_SHIFT) |\n\t\t      ((u32)sq_idx << NIC_Q_NUM_SHIFT), tl4);\n\tnic_reg_write(nic, NIC_PF_TL4_0_1023_CFG | (tl4 << 3),\n\t\t      ((u64)vnic << 27) | ((u32)sq_idx << 24) | rr_quantum);\n\n\tnic_reg_write(nic, NIC_PF_TL3_0_255_CFG | (tl3 << 3), rr_quantum);\n\n\t \n\tchan = (lmac * hw->chans_per_lmac) + (bgx * hw->chans_per_bgx);\n\tif (hw->tl1_per_bgx)\n\t\tnic_reg_write(nic, NIC_PF_TL3_0_255_CHAN | (tl3 << 3), chan);\n\telse\n\t\tnic_reg_write(nic, NIC_PF_TL3_0_255_CHAN | (tl3 << 3), 0);\n\n\t \n\tnic_reg_write(nic, NIC_PF_CHAN_0_255_TX_CFG | (chan << 3), 1);\n\n\ttl2 = tl3 >> 2;\n\tnic_reg_write(nic, NIC_PF_TL3A_0_63_CFG | (tl2 << 3), tl2);\n\tnic_reg_write(nic, NIC_PF_TL2_0_63_CFG | (tl2 << 3), rr_quantum);\n\t \n\tnic_reg_write(nic, NIC_PF_TL2_0_63_PRI | (tl2 << 3), 0x00);\n\n\t \n\tif (!hw->tl1_per_bgx)\n\t\tnic_reg_write(nic, NIC_PF_TL2_LMAC | (tl2 << 3),\n\t\t\t      lmac + (bgx * MAX_LMAC_PER_BGX));\n}\n\n \nstatic void nic_send_pnicvf(struct nicpf *nic, int sqs)\n{\n\tunion nic_mbx mbx = {};\n\n\tmbx.nicvf.msg = NIC_MBOX_MSG_PNICVF_PTR;\n\tmbx.nicvf.nicvf = nic->nicvf[nic->pqs_vf[sqs]];\n\tnic_send_msg_to_vf(nic, sqs, &mbx);\n}\n\n \nstatic void nic_send_snicvf(struct nicpf *nic, struct nicvf_ptr *nicvf)\n{\n\tunion nic_mbx mbx = {};\n\tint sqs_id = nic->vf_sqs[nicvf->vf_id][nicvf->sqs_id];\n\n\tmbx.nicvf.msg = NIC_MBOX_MSG_SNICVF_PTR;\n\tmbx.nicvf.sqs_id = nicvf->sqs_id;\n\tmbx.nicvf.nicvf = nic->nicvf[sqs_id];\n\tnic_send_msg_to_vf(nic, nicvf->vf_id, &mbx);\n}\n\n \nstatic int nic_nxt_avail_sqs(struct nicpf *nic)\n{\n\tint sqs;\n\n\tfor (sqs = 0; sqs < nic->num_sqs_en; sqs++) {\n\t\tif (!nic->sqs_used[sqs])\n\t\t\tnic->sqs_used[sqs] = true;\n\t\telse\n\t\t\tcontinue;\n\t\treturn sqs + nic->num_vf_en;\n\t}\n\treturn -1;\n}\n\n \nstatic void nic_alloc_sqs(struct nicpf *nic, struct sqs_alloc *sqs)\n{\n\tunion nic_mbx mbx = {};\n\tint idx, alloc_qs = 0;\n\tint sqs_id;\n\n\tif (!nic->num_sqs_en)\n\t\tgoto send_mbox;\n\n\tfor (idx = 0; idx < sqs->qs_count; idx++) {\n\t\tsqs_id = nic_nxt_avail_sqs(nic);\n\t\tif (sqs_id < 0)\n\t\t\tbreak;\n\t\tnic->vf_sqs[sqs->vf_id][idx] = sqs_id;\n\t\tnic->pqs_vf[sqs_id] = sqs->vf_id;\n\t\talloc_qs++;\n\t}\n\nsend_mbox:\n\tmbx.sqs_alloc.msg = NIC_MBOX_MSG_ALLOC_SQS;\n\tmbx.sqs_alloc.vf_id = sqs->vf_id;\n\tmbx.sqs_alloc.qs_count = alloc_qs;\n\tnic_send_msg_to_vf(nic, sqs->vf_id, &mbx);\n}\n\nstatic int nic_config_loopback(struct nicpf *nic, struct set_loopback *lbk)\n{\n\tint bgx_idx, lmac_idx;\n\n\tif (lbk->vf_id >= nic->num_vf_en)\n\t\treturn -1;\n\n\tbgx_idx = NIC_GET_BGX_FROM_VF_LMAC_MAP(nic->vf_lmac_map[lbk->vf_id]);\n\tlmac_idx = NIC_GET_LMAC_FROM_VF_LMAC_MAP(nic->vf_lmac_map[lbk->vf_id]);\n\n\tbgx_lmac_internal_loopback(nic->node, bgx_idx, lmac_idx, lbk->enable);\n\n\t \n\tnic_reg_write(nic, NIC_PF_CQ_AVG_CFG,\n\t\t      (BIT_ULL(20) | 0x2ull << 14 | 0x1));\n\tnic_reg_write(nic, NIC_PF_RRM_AVG_CFG,\n\t\t      (BIT_ULL(20) | 0x3ull << 14 | 0x1));\n\n\treturn 0;\n}\n\n \nstatic int nic_reset_stat_counters(struct nicpf *nic,\n\t\t\t\t   int vf, struct reset_stat_cfg *cfg)\n{\n\tint i, stat, qnum;\n\tu64 reg_addr;\n\n\tfor (i = 0; i < RX_STATS_ENUM_LAST; i++) {\n\t\tif (cfg->rx_stat_mask & BIT(i)) {\n\t\t\treg_addr = NIC_PF_VNIC_0_127_RX_STAT_0_13 |\n\t\t\t\t   (vf << NIC_QS_ID_SHIFT) |\n\t\t\t\t   (i << 3);\n\t\t\tnic_reg_write(nic, reg_addr, 0);\n\t\t}\n\t}\n\n\tfor (i = 0; i < TX_STATS_ENUM_LAST; i++) {\n\t\tif (cfg->tx_stat_mask & BIT(i)) {\n\t\t\treg_addr = NIC_PF_VNIC_0_127_TX_STAT_0_4 |\n\t\t\t\t   (vf << NIC_QS_ID_SHIFT) |\n\t\t\t\t   (i << 3);\n\t\t\tnic_reg_write(nic, reg_addr, 0);\n\t\t}\n\t}\n\n\tfor (i = 0; i <= 15; i++) {\n\t\tqnum = i >> 1;\n\t\tstat = i & 1 ? 1 : 0;\n\t\treg_addr = (vf << NIC_QS_ID_SHIFT) |\n\t\t\t   (qnum << NIC_Q_NUM_SHIFT) | (stat << 3);\n\t\tif (cfg->rq_stat_mask & BIT(i)) {\n\t\t\treg_addr |= NIC_PF_QSET_0_127_RQ_0_7_STAT_0_1;\n\t\t\tnic_reg_write(nic, reg_addr, 0);\n\t\t}\n\t\tif (cfg->sq_stat_mask & BIT(i)) {\n\t\t\treg_addr |= NIC_PF_QSET_0_127_SQ_0_7_STAT_0_1;\n\t\t\tnic_reg_write(nic, reg_addr, 0);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void nic_enable_tunnel_parsing(struct nicpf *nic, int vf)\n{\n\tu64 prot_def = (IPV6_PROT << 32) | (IPV4_PROT << 16) | ET_PROT;\n\tu64 vxlan_prot_def = (IPV6_PROT_DEF << 32) |\n\t\t\t      (IPV4_PROT_DEF) << 16 | ET_PROT_DEF;\n\n\t \n\tnic_reg_write(nic, NIC_PF_RX_GENEVE_DEF,\n\t\t      (1ULL << 63 | UDP_GENEVE_PORT_NUM));\n\tnic_reg_write(nic, NIC_PF_RX_GENEVE_PROT_DEF,\n\t\t      ((7ULL << 61) | prot_def));\n\tnic_reg_write(nic, NIC_PF_RX_NVGRE_PROT_DEF,\n\t\t      ((7ULL << 61) | prot_def));\n\tnic_reg_write(nic, NIC_PF_RX_VXLAN_DEF_0_1,\n\t\t      ((1ULL << 63) | UDP_VXLAN_PORT_NUM));\n\tnic_reg_write(nic, NIC_PF_RX_VXLAN_PROT_DEF,\n\t\t      ((0xfULL << 60) | vxlan_prot_def));\n}\n\nstatic void nic_enable_vf(struct nicpf *nic, int vf, bool enable)\n{\n\tint bgx, lmac;\n\n\tnic->vf_enabled[vf] = enable;\n\n\tif (vf >= nic->num_vf_en)\n\t\treturn;\n\n\tbgx = NIC_GET_BGX_FROM_VF_LMAC_MAP(nic->vf_lmac_map[vf]);\n\tlmac = NIC_GET_LMAC_FROM_VF_LMAC_MAP(nic->vf_lmac_map[vf]);\n\n\tbgx_lmac_rx_tx_enable(nic->node, bgx, lmac, enable);\n}\n\nstatic void nic_pause_frame(struct nicpf *nic, int vf, struct pfc *cfg)\n{\n\tint bgx, lmac;\n\tstruct pfc pfc;\n\tunion nic_mbx mbx = {};\n\n\tif (vf >= nic->num_vf_en)\n\t\treturn;\n\tbgx = NIC_GET_BGX_FROM_VF_LMAC_MAP(nic->vf_lmac_map[vf]);\n\tlmac = NIC_GET_LMAC_FROM_VF_LMAC_MAP(nic->vf_lmac_map[vf]);\n\n\tif (cfg->get) {\n\t\tbgx_lmac_get_pfc(nic->node, bgx, lmac, &pfc);\n\t\tmbx.pfc.msg = NIC_MBOX_MSG_PFC;\n\t\tmbx.pfc.autoneg = pfc.autoneg;\n\t\tmbx.pfc.fc_rx = pfc.fc_rx;\n\t\tmbx.pfc.fc_tx = pfc.fc_tx;\n\t\tnic_send_msg_to_vf(nic, vf, &mbx);\n\t} else {\n\t\tbgx_lmac_set_pfc(nic->node, bgx, lmac, cfg);\n\t\tnic_mbx_send_ack(nic, vf);\n\t}\n}\n\n \nstatic void nic_config_timestamp(struct nicpf *nic, int vf, struct set_ptp *ptp)\n{\n\tstruct pkind_cfg *pkind;\n\tu8 lmac, bgx_idx;\n\tu64 pkind_val, pkind_idx;\n\n\tif (vf >= nic->num_vf_en)\n\t\treturn;\n\n\tbgx_idx = NIC_GET_BGX_FROM_VF_LMAC_MAP(nic->vf_lmac_map[vf]);\n\tlmac = NIC_GET_LMAC_FROM_VF_LMAC_MAP(nic->vf_lmac_map[vf]);\n\n\tpkind_idx = lmac + bgx_idx * MAX_LMAC_PER_BGX;\n\tpkind_val = nic_reg_read(nic, NIC_PF_PKIND_0_15_CFG | (pkind_idx << 3));\n\tpkind = (struct pkind_cfg *)&pkind_val;\n\n\tif (ptp->enable && !pkind->hdr_sl) {\n\t\t \n\t\tpkind->hdr_sl = 4;\n\t\t \n\t\tpkind->maxlen += (pkind->hdr_sl * 2);\n\t\tbgx_config_timestamping(nic->node, bgx_idx, lmac, true);\n\t\tnic_reg_write(nic, NIC_PF_RX_ETYPE_0_7 | (1 << 3),\n\t\t\t      (ETYPE_ALG_ENDPARSE << 16) | ETH_P_1588);\n\t} else if (!ptp->enable && pkind->hdr_sl) {\n\t\tpkind->maxlen -= (pkind->hdr_sl * 2);\n\t\tpkind->hdr_sl = 0;\n\t\tbgx_config_timestamping(nic->node, bgx_idx, lmac, false);\n\t\tnic_reg_write(nic, NIC_PF_RX_ETYPE_0_7 | (1 << 3),\n\t\t\t      (ETYPE_ALG_SKIP << 16) | ETH_P_8021Q);\n\t}\n\n\tnic_reg_write(nic, NIC_PF_PKIND_0_15_CFG | (pkind_idx << 3), pkind_val);\n}\n\n \nstatic void nic_link_status_get(struct nicpf *nic, u8 vf)\n{\n\tunion nic_mbx mbx = {};\n\tstruct bgx_link_status link;\n\tu8 bgx, lmac;\n\n\tmbx.link_status.msg = NIC_MBOX_MSG_BGX_LINK_CHANGE;\n\n\t \n\tbgx = NIC_GET_BGX_FROM_VF_LMAC_MAP(nic->vf_lmac_map[vf]);\n\tlmac = NIC_GET_LMAC_FROM_VF_LMAC_MAP(nic->vf_lmac_map[vf]);\n\n\t \n\tbgx_get_lmac_link_state(nic->node, bgx, lmac, &link);\n\n\t \n\tmbx.link_status.link_up = link.link_up;\n\tmbx.link_status.duplex = link.duplex;\n\tmbx.link_status.speed = link.speed;\n\tmbx.link_status.mac_type = link.mac_type;\n\n\t \n\tnic_send_msg_to_vf(nic, vf, &mbx);\n}\n\n \nstatic void nic_handle_mbx_intr(struct nicpf *nic, int vf)\n{\n\tunion nic_mbx mbx = {};\n\tu64 *mbx_data;\n\tu64 mbx_addr;\n\tu64 reg_addr;\n\tu64 cfg;\n\tint bgx, lmac;\n\tint i;\n\tint ret = 0;\n\n\tmbx_addr = nic_get_mbx_addr(vf);\n\tmbx_data = (u64 *)&mbx;\n\n\tfor (i = 0; i < NIC_PF_VF_MAILBOX_SIZE; i++) {\n\t\t*mbx_data = nic_reg_read(nic, mbx_addr);\n\t\tmbx_data++;\n\t\tmbx_addr += sizeof(u64);\n\t}\n\n\tdev_dbg(&nic->pdev->dev, \"%s: Mailbox msg 0x%02x from VF%d\\n\",\n\t\t__func__, mbx.msg.msg, vf);\n\tswitch (mbx.msg.msg) {\n\tcase NIC_MBOX_MSG_READY:\n\t\tnic_mbx_send_ready(nic, vf);\n\t\treturn;\n\tcase NIC_MBOX_MSG_QS_CFG:\n\t\treg_addr = NIC_PF_QSET_0_127_CFG |\n\t\t\t   (mbx.qs.num << NIC_QS_ID_SHIFT);\n\t\tcfg = mbx.qs.cfg;\n\t\t \n\t\tif (vf >= nic->num_vf_en) {\n\t\t\tcfg = cfg & (~0x7FULL);\n\t\t\t \n\t\t\tcfg |= nic->pqs_vf[vf];\n\t\t}\n\t\tnic_reg_write(nic, reg_addr, cfg);\n\t\tbreak;\n\tcase NIC_MBOX_MSG_RQ_CFG:\n\t\treg_addr = NIC_PF_QSET_0_127_RQ_0_7_CFG |\n\t\t\t   (mbx.rq.qs_num << NIC_QS_ID_SHIFT) |\n\t\t\t   (mbx.rq.rq_num << NIC_Q_NUM_SHIFT);\n\t\tnic_reg_write(nic, reg_addr, mbx.rq.cfg);\n\t\t \n\t\tif (pass2_silicon(nic->pdev))\n\t\t\tnic_reg_write(nic, NIC_PF_RX_CFG, 0x01);\n\t\tif (!pass1_silicon(nic->pdev))\n\t\t\tnic_enable_tunnel_parsing(nic, vf);\n\t\tbreak;\n\tcase NIC_MBOX_MSG_RQ_BP_CFG:\n\t\treg_addr = NIC_PF_QSET_0_127_RQ_0_7_BP_CFG |\n\t\t\t   (mbx.rq.qs_num << NIC_QS_ID_SHIFT) |\n\t\t\t   (mbx.rq.rq_num << NIC_Q_NUM_SHIFT);\n\t\tnic_reg_write(nic, reg_addr, mbx.rq.cfg);\n\t\tbreak;\n\tcase NIC_MBOX_MSG_RQ_SW_SYNC:\n\t\tret = nic_rcv_queue_sw_sync(nic);\n\t\tbreak;\n\tcase NIC_MBOX_MSG_RQ_DROP_CFG:\n\t\treg_addr = NIC_PF_QSET_0_127_RQ_0_7_DROP_CFG |\n\t\t\t   (mbx.rq.qs_num << NIC_QS_ID_SHIFT) |\n\t\t\t   (mbx.rq.rq_num << NIC_Q_NUM_SHIFT);\n\t\tnic_reg_write(nic, reg_addr, mbx.rq.cfg);\n\t\tbreak;\n\tcase NIC_MBOX_MSG_SQ_CFG:\n\t\treg_addr = NIC_PF_QSET_0_127_SQ_0_7_CFG |\n\t\t\t   (mbx.sq.qs_num << NIC_QS_ID_SHIFT) |\n\t\t\t   (mbx.sq.sq_num << NIC_Q_NUM_SHIFT);\n\t\tnic_reg_write(nic, reg_addr, mbx.sq.cfg);\n\t\tnic_tx_channel_cfg(nic, mbx.qs.num, &mbx.sq);\n\t\tbreak;\n\tcase NIC_MBOX_MSG_SET_MAC:\n\t\tif (vf >= nic->num_vf_en) {\n\t\t\tret = -1;  \n\t\t\tbreak;\n\t\t}\n\t\tlmac = mbx.mac.vf_id;\n\t\tbgx = NIC_GET_BGX_FROM_VF_LMAC_MAP(nic->vf_lmac_map[lmac]);\n\t\tlmac = NIC_GET_LMAC_FROM_VF_LMAC_MAP(nic->vf_lmac_map[lmac]);\n\t\tbgx_set_lmac_mac(nic->node, bgx, lmac, mbx.mac.mac_addr);\n\t\tbreak;\n\tcase NIC_MBOX_MSG_SET_MAX_FRS:\n\t\tret = nic_update_hw_frs(nic, mbx.frs.max_frs,\n\t\t\t\t\tmbx.frs.vf_id);\n\t\tbreak;\n\tcase NIC_MBOX_MSG_CPI_CFG:\n\t\tnic_config_cpi(nic, &mbx.cpi_cfg);\n\t\tbreak;\n\tcase NIC_MBOX_MSG_RSS_SIZE:\n\t\tnic_send_rss_size(nic, vf);\n\t\treturn;\n\tcase NIC_MBOX_MSG_RSS_CFG:\n\tcase NIC_MBOX_MSG_RSS_CFG_CONT:\n\t\tnic_config_rss(nic, &mbx.rss_cfg);\n\t\tbreak;\n\tcase NIC_MBOX_MSG_CFG_DONE:\n\t\t \n\t\tnic_enable_vf(nic, vf, true);\n\t\tbreak;\n\tcase NIC_MBOX_MSG_SHUTDOWN:\n\t\t \n\t\tif (vf >= nic->num_vf_en)\n\t\t\tnic->sqs_used[vf - nic->num_vf_en] = false;\n\t\tnic->pqs_vf[vf] = 0;\n\t\tnic_enable_vf(nic, vf, false);\n\t\tbreak;\n\tcase NIC_MBOX_MSG_ALLOC_SQS:\n\t\tnic_alloc_sqs(nic, &mbx.sqs_alloc);\n\t\treturn;\n\tcase NIC_MBOX_MSG_NICVF_PTR:\n\t\tnic->nicvf[vf] = mbx.nicvf.nicvf;\n\t\tbreak;\n\tcase NIC_MBOX_MSG_PNICVF_PTR:\n\t\tnic_send_pnicvf(nic, vf);\n\t\treturn;\n\tcase NIC_MBOX_MSG_SNICVF_PTR:\n\t\tnic_send_snicvf(nic, &mbx.nicvf);\n\t\treturn;\n\tcase NIC_MBOX_MSG_BGX_STATS:\n\t\tnic_get_bgx_stats(nic, &mbx.bgx_stats);\n\t\treturn;\n\tcase NIC_MBOX_MSG_LOOPBACK:\n\t\tret = nic_config_loopback(nic, &mbx.lbk);\n\t\tbreak;\n\tcase NIC_MBOX_MSG_RESET_STAT_COUNTER:\n\t\tret = nic_reset_stat_counters(nic, vf, &mbx.reset_stat);\n\t\tbreak;\n\tcase NIC_MBOX_MSG_PFC:\n\t\tnic_pause_frame(nic, vf, &mbx.pfc);\n\t\treturn;\n\tcase NIC_MBOX_MSG_PTP_CFG:\n\t\tnic_config_timestamp(nic, vf, &mbx.ptp);\n\t\tbreak;\n\tcase NIC_MBOX_MSG_RESET_XCAST:\n\t\tif (vf >= nic->num_vf_en) {\n\t\t\tret = -1;  \n\t\t\tbreak;\n\t\t}\n\t\tbgx = NIC_GET_BGX_FROM_VF_LMAC_MAP(nic->vf_lmac_map[vf]);\n\t\tlmac = NIC_GET_LMAC_FROM_VF_LMAC_MAP(nic->vf_lmac_map[vf]);\n\t\tbgx_reset_xcast_mode(nic->node, bgx, lmac,\n\t\t\t\t     vf < NIC_VF_PER_MBX_REG ? vf :\n\t\t\t\t     vf - NIC_VF_PER_MBX_REG);\n\t\tbreak;\n\n\tcase NIC_MBOX_MSG_ADD_MCAST:\n\t\tif (vf >= nic->num_vf_en) {\n\t\t\tret = -1;  \n\t\t\tbreak;\n\t\t}\n\t\tbgx = NIC_GET_BGX_FROM_VF_LMAC_MAP(nic->vf_lmac_map[vf]);\n\t\tlmac = NIC_GET_LMAC_FROM_VF_LMAC_MAP(nic->vf_lmac_map[vf]);\n\t\tbgx_set_dmac_cam_filter(nic->node, bgx, lmac,\n\t\t\t\t\tmbx.xcast.mac,\n\t\t\t\t\tvf < NIC_VF_PER_MBX_REG ? vf :\n\t\t\t\t\tvf - NIC_VF_PER_MBX_REG);\n\t\tbreak;\n\n\tcase NIC_MBOX_MSG_SET_XCAST:\n\t\tif (vf >= nic->num_vf_en) {\n\t\t\tret = -1;  \n\t\t\tbreak;\n\t\t}\n\t\tbgx = NIC_GET_BGX_FROM_VF_LMAC_MAP(nic->vf_lmac_map[vf]);\n\t\tlmac = NIC_GET_LMAC_FROM_VF_LMAC_MAP(nic->vf_lmac_map[vf]);\n\t\tbgx_set_xcast_mode(nic->node, bgx, lmac, mbx.xcast.mode);\n\t\tbreak;\n\tcase NIC_MBOX_MSG_BGX_LINK_CHANGE:\n\t\tif (vf >= nic->num_vf_en) {\n\t\t\tret = -1;  \n\t\t\tbreak;\n\t\t}\n\t\tnic_link_status_get(nic, vf);\n\t\treturn;\n\tdefault:\n\t\tdev_err(&nic->pdev->dev,\n\t\t\t\"Invalid msg from VF%d, msg 0x%x\\n\", vf, mbx.msg.msg);\n\t\tbreak;\n\t}\n\n\tif (!ret) {\n\t\tnic_mbx_send_ack(nic, vf);\n\t} else if (mbx.msg.msg != NIC_MBOX_MSG_READY) {\n\t\tdev_err(&nic->pdev->dev, \"NACK for MBOX 0x%02x from VF %d\\n\",\n\t\t\tmbx.msg.msg, vf);\n\t\tnic_mbx_send_nack(nic, vf);\n\t}\n}\n\nstatic irqreturn_t nic_mbx_intr_handler(int irq, void *nic_irq)\n{\n\tstruct nicpf *nic = (struct nicpf *)nic_irq;\n\tint mbx;\n\tu64 intr;\n\tu8  vf;\n\n\tif (irq == nic->irq_allocated[NIC_PF_INTR_ID_MBOX0])\n\t\tmbx = 0;\n\telse\n\t\tmbx = 1;\n\n\tintr = nic_reg_read(nic, NIC_PF_MAILBOX_INT + (mbx << 3));\n\tdev_dbg(&nic->pdev->dev, \"PF interrupt Mbox%d 0x%llx\\n\", mbx, intr);\n\tfor (vf = 0; vf < NIC_VF_PER_MBX_REG; vf++) {\n\t\tif (intr & (1ULL << vf)) {\n\t\t\tdev_dbg(&nic->pdev->dev, \"Intr from VF %d\\n\",\n\t\t\t\tvf + (mbx * NIC_VF_PER_MBX_REG));\n\n\t\t\tnic_handle_mbx_intr(nic, vf +\n\t\t\t\t\t    (mbx * NIC_VF_PER_MBX_REG));\n\t\t\tnic_clear_mbx_intr(nic, vf, mbx);\n\t\t}\n\t}\n\treturn IRQ_HANDLED;\n}\n\nstatic void nic_free_all_interrupts(struct nicpf *nic)\n{\n\tint irq;\n\n\tfor (irq = 0; irq < nic->num_vec; irq++) {\n\t\tif (nic->irq_allocated[irq])\n\t\t\tfree_irq(nic->irq_allocated[irq], nic);\n\t\tnic->irq_allocated[irq] = 0;\n\t}\n}\n\nstatic int nic_register_interrupts(struct nicpf *nic)\n{\n\tint i, ret, irq;\n\tnic->num_vec = pci_msix_vec_count(nic->pdev);\n\n\t \n\tret = pci_alloc_irq_vectors(nic->pdev, nic->num_vec, nic->num_vec,\n\t\t\t\t    PCI_IRQ_MSIX);\n\tif (ret < 0) {\n\t\tdev_err(&nic->pdev->dev,\n\t\t\t\"Request for #%d msix vectors failed, returned %d\\n\",\n\t\t\t   nic->num_vec, ret);\n\t\treturn ret;\n\t}\n\n\t \n\tfor (i = NIC_PF_INTR_ID_MBOX0; i < nic->num_vec; i++) {\n\t\tsprintf(nic->irq_name[i],\n\t\t\t\"NICPF Mbox%d\", (i - NIC_PF_INTR_ID_MBOX0));\n\n\t\tirq = pci_irq_vector(nic->pdev, i);\n\t\tret = request_irq(irq, nic_mbx_intr_handler, 0,\n\t\t\t\t  nic->irq_name[i], nic);\n\t\tif (ret)\n\t\t\tgoto fail;\n\n\t\tnic->irq_allocated[i] = irq;\n\t}\n\n\t \n\tnic_enable_mbx_intr(nic);\n\treturn 0;\n\nfail:\n\tdev_err(&nic->pdev->dev, \"Request irq failed\\n\");\n\tnic_free_all_interrupts(nic);\n\tpci_free_irq_vectors(nic->pdev);\n\tnic->num_vec = 0;\n\treturn ret;\n}\n\nstatic void nic_unregister_interrupts(struct nicpf *nic)\n{\n\tnic_free_all_interrupts(nic);\n\tpci_free_irq_vectors(nic->pdev);\n\tnic->num_vec = 0;\n}\n\nstatic int nic_num_sqs_en(struct nicpf *nic, int vf_en)\n{\n\tint pos, sqs_per_vf = MAX_SQS_PER_VF_SINGLE_NODE;\n\tu16 total_vf;\n\n\t \n\tif (num_online_cpus() <= MAX_QUEUES_PER_QSET)\n\t\treturn 0;\n\n\t \n\tif (nr_node_ids > 1)\n\t\tsqs_per_vf = MAX_SQS_PER_VF;\n\n\tpos = pci_find_ext_capability(nic->pdev, PCI_EXT_CAP_ID_SRIOV);\n\tpci_read_config_word(nic->pdev, (pos + PCI_SRIOV_TOTAL_VF), &total_vf);\n\treturn min(total_vf - vf_en, vf_en * sqs_per_vf);\n}\n\nstatic int nic_sriov_init(struct pci_dev *pdev, struct nicpf *nic)\n{\n\tint pos = 0;\n\tint vf_en;\n\tint err;\n\tu16 total_vf_cnt;\n\n\tpos = pci_find_ext_capability(pdev, PCI_EXT_CAP_ID_SRIOV);\n\tif (!pos) {\n\t\tdev_err(&pdev->dev, \"SRIOV capability is not found in PCIe config space\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tpci_read_config_word(pdev, (pos + PCI_SRIOV_TOTAL_VF), &total_vf_cnt);\n\tif (total_vf_cnt < nic->num_vf_en)\n\t\tnic->num_vf_en = total_vf_cnt;\n\n\tif (!total_vf_cnt)\n\t\treturn 0;\n\n\tvf_en = nic->num_vf_en;\n\tnic->num_sqs_en = nic_num_sqs_en(nic, nic->num_vf_en);\n\tvf_en += nic->num_sqs_en;\n\n\terr = pci_enable_sriov(pdev, vf_en);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"SRIOV enable failed, num VF is %d\\n\",\n\t\t\tvf_en);\n\t\tnic->num_vf_en = 0;\n\t\treturn err;\n\t}\n\n\tdev_info(&pdev->dev, \"SRIOV enabled, number of VF available %d\\n\",\n\t\t vf_en);\n\n\tnic->flags |= NIC_SRIOV_ENABLED;\n\treturn 0;\n}\n\nstatic int nic_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct nicpf *nic;\n\tu8     max_lmac;\n\tint    err;\n\n\tBUILD_BUG_ON(sizeof(union nic_mbx) > 16);\n\n\tnic = devm_kzalloc(dev, sizeof(*nic), GFP_KERNEL);\n\tif (!nic)\n\t\treturn -ENOMEM;\n\n\tnic->hw = devm_kzalloc(dev, sizeof(struct hw_info), GFP_KERNEL);\n\tif (!nic->hw)\n\t\treturn -ENOMEM;\n\n\tpci_set_drvdata(pdev, nic);\n\n\tnic->pdev = pdev;\n\n\terr = pci_enable_device(pdev);\n\tif (err) {\n\t\tpci_set_drvdata(pdev, NULL);\n\t\treturn dev_err_probe(dev, err, \"Failed to enable PCI device\\n\");\n\t}\n\n\terr = pci_request_regions(pdev, DRV_NAME);\n\tif (err) {\n\t\tdev_err(dev, \"PCI request regions failed 0x%x\\n\", err);\n\t\tgoto err_disable_device;\n\t}\n\n\terr = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(48));\n\tif (err) {\n\t\tdev_err(dev, \"Unable to get usable DMA configuration\\n\");\n\t\tgoto err_release_regions;\n\t}\n\n\t \n\tnic->reg_base = pcim_iomap(pdev, PCI_CFG_REG_BAR_NUM, 0);\n\tif (!nic->reg_base) {\n\t\tdev_err(dev, \"Cannot map config register space, aborting\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto err_release_regions;\n\t}\n\n\tnic->node = nic_get_node_id(pdev);\n\n\t \n\tnic_get_hw_info(nic);\n\n\t \n\terr = -ENOMEM;\n\tmax_lmac = nic->hw->bgx_cnt * MAX_LMAC_PER_BGX;\n\n\tnic->vf_lmac_map = devm_kmalloc_array(dev, max_lmac, sizeof(u8),\n\t\t\t\t\t      GFP_KERNEL);\n\tif (!nic->vf_lmac_map)\n\t\tgoto err_release_regions;\n\n\t \n\tnic_init_hw(nic);\n\n\tnic_set_lmac_vf_mapping(nic);\n\n\t \n\terr = nic_register_interrupts(nic);\n\tif (err)\n\t\tgoto err_release_regions;\n\n\t \n\terr = nic_sriov_init(pdev, nic);\n\tif (err)\n\t\tgoto err_unregister_interrupts;\n\n\treturn 0;\n\nerr_unregister_interrupts:\n\tnic_unregister_interrupts(nic);\nerr_release_regions:\n\tpci_release_regions(pdev);\nerr_disable_device:\n\tpci_disable_device(pdev);\n\tpci_set_drvdata(pdev, NULL);\n\treturn err;\n}\n\nstatic void nic_remove(struct pci_dev *pdev)\n{\n\tstruct nicpf *nic = pci_get_drvdata(pdev);\n\n\tif (!nic)\n\t\treturn;\n\n\tif (nic->flags & NIC_SRIOV_ENABLED)\n\t\tpci_disable_sriov(pdev);\n\n\tnic_unregister_interrupts(nic);\n\tpci_release_regions(pdev);\n\n\tpci_disable_device(pdev);\n\tpci_set_drvdata(pdev, NULL);\n}\n\nstatic struct pci_driver nic_driver = {\n\t.name = DRV_NAME,\n\t.id_table = nic_id_table,\n\t.probe = nic_probe,\n\t.remove = nic_remove,\n};\n\nstatic int __init nic_init_module(void)\n{\n\tpr_info(\"%s, ver %s\\n\", DRV_NAME, DRV_VERSION);\n\n\treturn pci_register_driver(&nic_driver);\n}\n\nstatic void __exit nic_cleanup_module(void)\n{\n\tpci_unregister_driver(&nic_driver);\n}\n\nmodule_init(nic_init_module);\nmodule_exit(nic_cleanup_module);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}