{
  "module_name": "nicvf_ethtool.c",
  "hash_id": "a688049e4f8769ba3815acb903d8928041c15990fa88e4d8e6e14c0875be3def",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/cavium/thunder/nicvf_ethtool.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/ethtool.h>\n#include <linux/pci.h>\n#include <linux/net_tstamp.h>\n\n#include \"nic_reg.h\"\n#include \"nic.h\"\n#include \"nicvf_queues.h\"\n#include \"q_struct.h\"\n#include \"thunder_bgx.h\"\n#include \"../common/cavium_ptp.h\"\n\n#define DRV_NAME\t\"nicvf\"\n\nstruct nicvf_stat {\n\tchar name[ETH_GSTRING_LEN];\n\tunsigned int index;\n};\n\n#define NICVF_HW_STAT(stat) { \\\n\t.name = #stat, \\\n\t.index = offsetof(struct nicvf_hw_stats, stat) / sizeof(u64), \\\n}\n\n#define NICVF_DRV_STAT(stat) { \\\n\t.name = #stat, \\\n\t.index = offsetof(struct nicvf_drv_stats, stat) / sizeof(u64), \\\n}\n\nstatic const struct nicvf_stat nicvf_hw_stats[] = {\n\tNICVF_HW_STAT(rx_bytes),\n\tNICVF_HW_STAT(rx_frames),\n\tNICVF_HW_STAT(rx_ucast_frames),\n\tNICVF_HW_STAT(rx_bcast_frames),\n\tNICVF_HW_STAT(rx_mcast_frames),\n\tNICVF_HW_STAT(rx_drops),\n\tNICVF_HW_STAT(rx_drop_red),\n\tNICVF_HW_STAT(rx_drop_red_bytes),\n\tNICVF_HW_STAT(rx_drop_overrun),\n\tNICVF_HW_STAT(rx_drop_overrun_bytes),\n\tNICVF_HW_STAT(rx_drop_bcast),\n\tNICVF_HW_STAT(rx_drop_mcast),\n\tNICVF_HW_STAT(rx_drop_l3_bcast),\n\tNICVF_HW_STAT(rx_drop_l3_mcast),\n\tNICVF_HW_STAT(rx_fcs_errors),\n\tNICVF_HW_STAT(rx_l2_errors),\n\tNICVF_HW_STAT(tx_bytes),\n\tNICVF_HW_STAT(tx_frames),\n\tNICVF_HW_STAT(tx_ucast_frames),\n\tNICVF_HW_STAT(tx_bcast_frames),\n\tNICVF_HW_STAT(tx_mcast_frames),\n\tNICVF_HW_STAT(tx_drops),\n};\n\nstatic const struct nicvf_stat nicvf_drv_stats[] = {\n\tNICVF_DRV_STAT(rx_bgx_truncated_pkts),\n\tNICVF_DRV_STAT(rx_jabber_errs),\n\tNICVF_DRV_STAT(rx_fcs_errs),\n\tNICVF_DRV_STAT(rx_bgx_errs),\n\tNICVF_DRV_STAT(rx_prel2_errs),\n\tNICVF_DRV_STAT(rx_l2_hdr_malformed),\n\tNICVF_DRV_STAT(rx_oversize),\n\tNICVF_DRV_STAT(rx_undersize),\n\tNICVF_DRV_STAT(rx_l2_len_mismatch),\n\tNICVF_DRV_STAT(rx_l2_pclp),\n\tNICVF_DRV_STAT(rx_ip_ver_errs),\n\tNICVF_DRV_STAT(rx_ip_csum_errs),\n\tNICVF_DRV_STAT(rx_ip_hdr_malformed),\n\tNICVF_DRV_STAT(rx_ip_payload_malformed),\n\tNICVF_DRV_STAT(rx_ip_ttl_errs),\n\tNICVF_DRV_STAT(rx_l3_pclp),\n\tNICVF_DRV_STAT(rx_l4_malformed),\n\tNICVF_DRV_STAT(rx_l4_csum_errs),\n\tNICVF_DRV_STAT(rx_udp_len_errs),\n\tNICVF_DRV_STAT(rx_l4_port_errs),\n\tNICVF_DRV_STAT(rx_tcp_flag_errs),\n\tNICVF_DRV_STAT(rx_tcp_offset_errs),\n\tNICVF_DRV_STAT(rx_l4_pclp),\n\tNICVF_DRV_STAT(rx_truncated_pkts),\n\n\tNICVF_DRV_STAT(tx_desc_fault),\n\tNICVF_DRV_STAT(tx_hdr_cons_err),\n\tNICVF_DRV_STAT(tx_subdesc_err),\n\tNICVF_DRV_STAT(tx_max_size_exceeded),\n\tNICVF_DRV_STAT(tx_imm_size_oflow),\n\tNICVF_DRV_STAT(tx_data_seq_err),\n\tNICVF_DRV_STAT(tx_mem_seq_err),\n\tNICVF_DRV_STAT(tx_lock_viol),\n\tNICVF_DRV_STAT(tx_data_fault),\n\tNICVF_DRV_STAT(tx_tstmp_conflict),\n\tNICVF_DRV_STAT(tx_tstmp_timeout),\n\tNICVF_DRV_STAT(tx_mem_fault),\n\tNICVF_DRV_STAT(tx_csum_overlap),\n\tNICVF_DRV_STAT(tx_csum_overflow),\n\n\tNICVF_DRV_STAT(tx_tso),\n\tNICVF_DRV_STAT(tx_timeout),\n\tNICVF_DRV_STAT(txq_stop),\n\tNICVF_DRV_STAT(txq_wake),\n\tNICVF_DRV_STAT(rcv_buffer_alloc_failures),\n\tNICVF_DRV_STAT(page_alloc),\n};\n\nstatic const struct nicvf_stat nicvf_queue_stats[] = {\n\t{ \"bytes\", 0 },\n\t{ \"frames\", 1 },\n};\n\nstatic const unsigned int nicvf_n_hw_stats = ARRAY_SIZE(nicvf_hw_stats);\nstatic const unsigned int nicvf_n_drv_stats = ARRAY_SIZE(nicvf_drv_stats);\nstatic const unsigned int nicvf_n_queue_stats = ARRAY_SIZE(nicvf_queue_stats);\n\nstatic int nicvf_get_link_ksettings(struct net_device *netdev,\n\t\t\t\t    struct ethtool_link_ksettings *cmd)\n{\n\tstruct nicvf *nic = netdev_priv(netdev);\n\tu32 supported, advertising;\n\n\tsupported = 0;\n\tadvertising = 0;\n\n\tif (!nic->link_up) {\n\t\tcmd->base.duplex = DUPLEX_UNKNOWN;\n\t\tcmd->base.speed = SPEED_UNKNOWN;\n\t\treturn 0;\n\t}\n\n\tswitch (nic->speed) {\n\tcase SPEED_1000:\n\t\tcmd->base.port = PORT_MII | PORT_TP;\n\t\tcmd->base.autoneg = AUTONEG_ENABLE;\n\t\tsupported |= SUPPORTED_MII | SUPPORTED_TP;\n\t\tsupported |= SUPPORTED_1000baseT_Full |\n\t\t\t\t  SUPPORTED_1000baseT_Half |\n\t\t\t\t  SUPPORTED_100baseT_Full  |\n\t\t\t\t  SUPPORTED_100baseT_Half  |\n\t\t\t\t  SUPPORTED_10baseT_Full   |\n\t\t\t\t  SUPPORTED_10baseT_Half;\n\t\tsupported |= SUPPORTED_Autoneg;\n\t\tadvertising |= ADVERTISED_1000baseT_Full |\n\t\t\t\t    ADVERTISED_1000baseT_Half |\n\t\t\t\t    ADVERTISED_100baseT_Full  |\n\t\t\t\t    ADVERTISED_100baseT_Half  |\n\t\t\t\t    ADVERTISED_10baseT_Full   |\n\t\t\t\t    ADVERTISED_10baseT_Half;\n\t\tbreak;\n\tcase SPEED_10000:\n\t\tif (nic->mac_type == BGX_MODE_RXAUI) {\n\t\t\tcmd->base.port = PORT_TP;\n\t\t\tsupported |= SUPPORTED_TP;\n\t\t} else {\n\t\t\tcmd->base.port = PORT_FIBRE;\n\t\t\tsupported |= SUPPORTED_FIBRE;\n\t\t}\n\t\tcmd->base.autoneg = AUTONEG_DISABLE;\n\t\tsupported |= SUPPORTED_10000baseT_Full;\n\t\tbreak;\n\tcase SPEED_40000:\n\t\tcmd->base.port = PORT_FIBRE;\n\t\tcmd->base.autoneg = AUTONEG_DISABLE;\n\t\tsupported |= SUPPORTED_FIBRE;\n\t\tsupported |= SUPPORTED_40000baseCR4_Full;\n\t\tbreak;\n\t}\n\tcmd->base.duplex = nic->duplex;\n\tcmd->base.speed = nic->speed;\n\n\tethtool_convert_legacy_u32_to_link_mode(cmd->link_modes.supported,\n\t\t\t\t\t\tsupported);\n\tethtool_convert_legacy_u32_to_link_mode(cmd->link_modes.advertising,\n\t\t\t\t\t\tadvertising);\n\n\treturn 0;\n}\n\nstatic u32 nicvf_get_link(struct net_device *netdev)\n{\n\tstruct nicvf *nic = netdev_priv(netdev);\n\n\treturn nic->link_up;\n}\n\nstatic void nicvf_get_drvinfo(struct net_device *netdev,\n\t\t\t      struct ethtool_drvinfo *info)\n{\n\tstruct nicvf *nic = netdev_priv(netdev);\n\n\tstrscpy(info->driver, DRV_NAME, sizeof(info->driver));\n\tstrscpy(info->bus_info, pci_name(nic->pdev), sizeof(info->bus_info));\n}\n\nstatic u32 nicvf_get_msglevel(struct net_device *netdev)\n{\n\tstruct nicvf *nic = netdev_priv(netdev);\n\n\treturn nic->msg_enable;\n}\n\nstatic void nicvf_set_msglevel(struct net_device *netdev, u32 lvl)\n{\n\tstruct nicvf *nic = netdev_priv(netdev);\n\n\tnic->msg_enable = lvl;\n}\n\nstatic void nicvf_get_qset_strings(struct nicvf *nic, u8 **data, int qset)\n{\n\tint stats, qidx;\n\tint start_qidx = qset * MAX_RCV_QUEUES_PER_QS;\n\n\tfor (qidx = 0; qidx < nic->qs->rq_cnt; qidx++) {\n\t\tfor (stats = 0; stats < nicvf_n_queue_stats; stats++) {\n\t\t\tsprintf(*data, \"rxq%d: %s\", qidx + start_qidx,\n\t\t\t\tnicvf_queue_stats[stats].name);\n\t\t\t*data += ETH_GSTRING_LEN;\n\t\t}\n\t}\n\n\tfor (qidx = 0; qidx < nic->qs->sq_cnt; qidx++) {\n\t\tfor (stats = 0; stats < nicvf_n_queue_stats; stats++) {\n\t\t\tsprintf(*data, \"txq%d: %s\", qidx + start_qidx,\n\t\t\t\tnicvf_queue_stats[stats].name);\n\t\t\t*data += ETH_GSTRING_LEN;\n\t\t}\n\t}\n}\n\nstatic void nicvf_get_strings(struct net_device *netdev, u32 sset, u8 *data)\n{\n\tstruct nicvf *nic = netdev_priv(netdev);\n\tint stats;\n\tint sqs;\n\n\tif (sset != ETH_SS_STATS)\n\t\treturn;\n\n\tfor (stats = 0; stats < nicvf_n_hw_stats; stats++) {\n\t\tmemcpy(data, nicvf_hw_stats[stats].name, ETH_GSTRING_LEN);\n\t\tdata += ETH_GSTRING_LEN;\n\t}\n\n\tfor (stats = 0; stats < nicvf_n_drv_stats; stats++) {\n\t\tmemcpy(data, nicvf_drv_stats[stats].name, ETH_GSTRING_LEN);\n\t\tdata += ETH_GSTRING_LEN;\n\t}\n\n\tnicvf_get_qset_strings(nic, &data, 0);\n\n\tfor (sqs = 0; sqs < nic->sqs_count; sqs++) {\n\t\tif (!nic->snicvf[sqs])\n\t\t\tcontinue;\n\t\tnicvf_get_qset_strings(nic->snicvf[sqs], &data, sqs + 1);\n\t}\n\n\tfor (stats = 0; stats < BGX_RX_STATS_COUNT; stats++) {\n\t\tsprintf(data, \"bgx_rxstat%d: \", stats);\n\t\tdata += ETH_GSTRING_LEN;\n\t}\n\n\tfor (stats = 0; stats < BGX_TX_STATS_COUNT; stats++) {\n\t\tsprintf(data, \"bgx_txstat%d: \", stats);\n\t\tdata += ETH_GSTRING_LEN;\n\t}\n}\n\nstatic int nicvf_get_sset_count(struct net_device *netdev, int sset)\n{\n\tstruct nicvf *nic = netdev_priv(netdev);\n\tint qstats_count;\n\tint sqs;\n\n\tif (sset != ETH_SS_STATS)\n\t\treturn -EINVAL;\n\n\tqstats_count = nicvf_n_queue_stats *\n\t\t       (nic->qs->rq_cnt + nic->qs->sq_cnt);\n\tfor (sqs = 0; sqs < nic->sqs_count; sqs++) {\n\t\tstruct nicvf *snic;\n\n\t\tsnic = nic->snicvf[sqs];\n\t\tif (!snic)\n\t\t\tcontinue;\n\t\tqstats_count += nicvf_n_queue_stats *\n\t\t\t\t(snic->qs->rq_cnt + snic->qs->sq_cnt);\n\t}\n\n\treturn nicvf_n_hw_stats + nicvf_n_drv_stats +\n\t\tqstats_count +\n\t\tBGX_RX_STATS_COUNT + BGX_TX_STATS_COUNT;\n}\n\nstatic void nicvf_get_qset_stats(struct nicvf *nic,\n\t\t\t\t struct ethtool_stats *stats, u64 **data)\n{\n\tint stat, qidx;\n\n\tif (!nic)\n\t\treturn;\n\n\tfor (qidx = 0; qidx < nic->qs->rq_cnt; qidx++) {\n\t\tnicvf_update_rq_stats(nic, qidx);\n\t\tfor (stat = 0; stat < nicvf_n_queue_stats; stat++)\n\t\t\t*((*data)++) = ((u64 *)&nic->qs->rq[qidx].stats)\n\t\t\t\t\t[nicvf_queue_stats[stat].index];\n\t}\n\n\tfor (qidx = 0; qidx < nic->qs->sq_cnt; qidx++) {\n\t\tnicvf_update_sq_stats(nic, qidx);\n\t\tfor (stat = 0; stat < nicvf_n_queue_stats; stat++)\n\t\t\t*((*data)++) = ((u64 *)&nic->qs->sq[qidx].stats)\n\t\t\t\t\t[nicvf_queue_stats[stat].index];\n\t}\n}\n\nstatic void nicvf_get_ethtool_stats(struct net_device *netdev,\n\t\t\t\t    struct ethtool_stats *stats, u64 *data)\n{\n\tstruct nicvf *nic = netdev_priv(netdev);\n\tint stat, tmp_stats;\n\tint sqs, cpu;\n\n\tnicvf_update_stats(nic);\n\n\t \n\tnicvf_update_lmac_stats(nic);\n\n\tfor (stat = 0; stat < nicvf_n_hw_stats; stat++)\n\t\t*(data++) = ((u64 *)&nic->hw_stats)\n\t\t\t\t[nicvf_hw_stats[stat].index];\n\tfor (stat = 0; stat < nicvf_n_drv_stats; stat++) {\n\t\ttmp_stats = 0;\n\t\tfor_each_possible_cpu(cpu)\n\t\t\ttmp_stats += ((u64 *)per_cpu_ptr(nic->drv_stats, cpu))\n\t\t\t\t     [nicvf_drv_stats[stat].index];\n\t\t*(data++) = tmp_stats;\n\t}\n\n\tnicvf_get_qset_stats(nic, stats, &data);\n\n\tfor (sqs = 0; sqs < nic->sqs_count; sqs++) {\n\t\tif (!nic->snicvf[sqs])\n\t\t\tcontinue;\n\t\tnicvf_get_qset_stats(nic->snicvf[sqs], stats, &data);\n\t}\n\n\tfor (stat = 0; stat < BGX_RX_STATS_COUNT; stat++)\n\t\t*(data++) = nic->bgx_stats.rx_stats[stat];\n\tfor (stat = 0; stat < BGX_TX_STATS_COUNT; stat++)\n\t\t*(data++) = nic->bgx_stats.tx_stats[stat];\n}\n\nstatic int nicvf_get_regs_len(struct net_device *dev)\n{\n\treturn sizeof(u64) * NIC_VF_REG_COUNT;\n}\n\nstatic void nicvf_get_regs(struct net_device *dev,\n\t\t\t   struct ethtool_regs *regs, void *reg)\n{\n\tstruct nicvf *nic = netdev_priv(dev);\n\tu64 *p = (u64 *)reg;\n\tu64 reg_offset;\n\tint mbox, key, stat, q;\n\tint i = 0;\n\n\tregs->version = 0;\n\tmemset(p, 0, NIC_VF_REG_COUNT);\n\n\tp[i++] = nicvf_reg_read(nic, NIC_VNIC_CFG);\n\t \n\tfor (mbox = 0; mbox < NIC_PF_VF_MAILBOX_SIZE; mbox++)\n\t\tp[i++] = nicvf_reg_read(nic,\n\t\t\t\t\tNIC_VF_PF_MAILBOX_0_1 | (mbox << 3));\n\n\tp[i++] = nicvf_reg_read(nic, NIC_VF_INT);\n\tp[i++] = nicvf_reg_read(nic, NIC_VF_INT_W1S);\n\tp[i++] = nicvf_reg_read(nic, NIC_VF_ENA_W1C);\n\tp[i++] = nicvf_reg_read(nic, NIC_VF_ENA_W1S);\n\tp[i++] = nicvf_reg_read(nic, NIC_VNIC_RSS_CFG);\n\n\tfor (key = 0; key < RSS_HASH_KEY_SIZE; key++)\n\t\tp[i++] = nicvf_reg_read(nic, NIC_VNIC_RSS_KEY_0_4 | (key << 3));\n\n\t \n\tfor (stat = 0; stat < TX_STATS_ENUM_LAST; stat++)\n\t\tp[i++] = nicvf_reg_read(nic,\n\t\t\t\t\tNIC_VNIC_TX_STAT_0_4 | (stat << 3));\n\n\tfor (i = 0; i < RX_STATS_ENUM_LAST; i++)\n\t\tp[i++] = nicvf_reg_read(nic,\n\t\t\t\t\tNIC_VNIC_RX_STAT_0_13 | (stat << 3));\n\n\tp[i++] = nicvf_reg_read(nic, NIC_QSET_RQ_GEN_CFG);\n\n\t \n\tfor (q = 0; q < MAX_CMP_QUEUES_PER_QS; q++) {\n\t\tp[i++] = nicvf_queue_reg_read(nic, NIC_QSET_CQ_0_7_CFG, q);\n\t\tp[i++] = nicvf_queue_reg_read(nic, NIC_QSET_CQ_0_7_CFG2, q);\n\t\tp[i++] = nicvf_queue_reg_read(nic, NIC_QSET_CQ_0_7_THRESH, q);\n\t\tp[i++] = nicvf_queue_reg_read(nic, NIC_QSET_CQ_0_7_BASE, q);\n\t\tp[i++] = nicvf_queue_reg_read(nic, NIC_QSET_CQ_0_7_HEAD, q);\n\t\tp[i++] = nicvf_queue_reg_read(nic, NIC_QSET_CQ_0_7_TAIL, q);\n\t\tp[i++] = nicvf_queue_reg_read(nic, NIC_QSET_CQ_0_7_DOOR, q);\n\t\tp[i++] = nicvf_queue_reg_read(nic, NIC_QSET_CQ_0_7_STATUS, q);\n\t\tp[i++] = nicvf_queue_reg_read(nic, NIC_QSET_CQ_0_7_STATUS2, q);\n\t\tp[i++] = nicvf_queue_reg_read(nic, NIC_QSET_CQ_0_7_DEBUG, q);\n\t}\n\n\t \n\tfor (q = 0; q < MAX_RCV_QUEUES_PER_QS; q++) {\n\t\tp[i++] = nicvf_queue_reg_read(nic, NIC_QSET_RQ_0_7_CFG, q);\n\t\tp[i++] = nicvf_queue_reg_read(nic,\n\t\t\t\t\t\t  NIC_QSET_RQ_0_7_STAT_0_1, q);\n\t\treg_offset = NIC_QSET_RQ_0_7_STAT_0_1 | (1 << 3);\n\t\tp[i++] = nicvf_queue_reg_read(nic, reg_offset, q);\n\t}\n\n\tfor (q = 0; q < MAX_SND_QUEUES_PER_QS; q++) {\n\t\tp[i++] = nicvf_queue_reg_read(nic, NIC_QSET_SQ_0_7_CFG, q);\n\t\tp[i++] = nicvf_queue_reg_read(nic, NIC_QSET_SQ_0_7_THRESH, q);\n\t\tp[i++] = nicvf_queue_reg_read(nic, NIC_QSET_SQ_0_7_BASE, q);\n\t\tp[i++] = nicvf_queue_reg_read(nic, NIC_QSET_SQ_0_7_HEAD, q);\n\t\tp[i++] = nicvf_queue_reg_read(nic, NIC_QSET_SQ_0_7_TAIL, q);\n\t\tp[i++] = nicvf_queue_reg_read(nic, NIC_QSET_SQ_0_7_DOOR, q);\n\t\tp[i++] = nicvf_queue_reg_read(nic, NIC_QSET_SQ_0_7_STATUS, q);\n\t\tp[i++] = nicvf_queue_reg_read(nic, NIC_QSET_SQ_0_7_DEBUG, q);\n\t\t \n\t\tp[i++] = 0;\n\t\tp[i++] = nicvf_queue_reg_read(nic, NIC_QSET_SQ_0_7_STAT_0_1, q);\n\t\treg_offset = NIC_QSET_SQ_0_7_STAT_0_1 | (1 << 3);\n\t\tp[i++] = nicvf_queue_reg_read(nic, reg_offset, q);\n\t}\n\n\tfor (q = 0; q < MAX_RCV_BUF_DESC_RINGS_PER_QS; q++) {\n\t\tp[i++] = nicvf_queue_reg_read(nic, NIC_QSET_RBDR_0_1_CFG, q);\n\t\tp[i++] = nicvf_queue_reg_read(nic, NIC_QSET_RBDR_0_1_THRESH, q);\n\t\tp[i++] = nicvf_queue_reg_read(nic, NIC_QSET_RBDR_0_1_BASE, q);\n\t\tp[i++] = nicvf_queue_reg_read(nic, NIC_QSET_RBDR_0_1_HEAD, q);\n\t\tp[i++] = nicvf_queue_reg_read(nic, NIC_QSET_RBDR_0_1_TAIL, q);\n\t\tp[i++] = nicvf_queue_reg_read(nic, NIC_QSET_RBDR_0_1_DOOR, q);\n\t\tp[i++] = nicvf_queue_reg_read(nic,\n\t\t\t\t\t      NIC_QSET_RBDR_0_1_STATUS0, q);\n\t\tp[i++] = nicvf_queue_reg_read(nic,\n\t\t\t\t\t      NIC_QSET_RBDR_0_1_STATUS1, q);\n\t\treg_offset = NIC_QSET_RBDR_0_1_PREFETCH_STATUS;\n\t\tp[i++] = nicvf_queue_reg_read(nic, reg_offset, q);\n\t}\n}\n\nstatic int nicvf_get_coalesce(struct net_device *netdev,\n\t\t\t      struct ethtool_coalesce *cmd,\n\t\t\t      struct kernel_ethtool_coalesce *kernel_coal,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct nicvf *nic = netdev_priv(netdev);\n\n\tcmd->rx_coalesce_usecs = nic->cq_coalesce_usecs;\n\treturn 0;\n}\n\nstatic void nicvf_get_ringparam(struct net_device *netdev,\n\t\t\t\tstruct ethtool_ringparam *ring,\n\t\t\t\tstruct kernel_ethtool_ringparam *kernel_ring,\n\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct nicvf *nic = netdev_priv(netdev);\n\tstruct queue_set *qs = nic->qs;\n\n\tring->rx_max_pending = MAX_CMP_QUEUE_LEN;\n\tring->rx_pending = qs->cq_len;\n\tring->tx_max_pending = MAX_SND_QUEUE_LEN;\n\tring->tx_pending = qs->sq_len;\n}\n\nstatic int nicvf_set_ringparam(struct net_device *netdev,\n\t\t\t       struct ethtool_ringparam *ring,\n\t\t\t       struct kernel_ethtool_ringparam *kernel_ring,\n\t\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct nicvf *nic = netdev_priv(netdev);\n\tstruct queue_set *qs = nic->qs;\n\tu32 rx_count, tx_count;\n\n\t \n\tif (pass1_silicon(nic->pdev))\n\t\treturn -EINVAL;\n\n\tif ((ring->rx_mini_pending) || (ring->rx_jumbo_pending))\n\t\treturn -EINVAL;\n\n\ttx_count = clamp_t(u32, ring->tx_pending,\n\t\t\t   MIN_SND_QUEUE_LEN, MAX_SND_QUEUE_LEN);\n\trx_count = clamp_t(u32, ring->rx_pending,\n\t\t\t   MIN_CMP_QUEUE_LEN, MAX_CMP_QUEUE_LEN);\n\n\tif ((tx_count == qs->sq_len) && (rx_count == qs->cq_len))\n\t\treturn 0;\n\n\t \n\tqs->sq_len = rounddown_pow_of_two(tx_count);\n\tqs->cq_len = rounddown_pow_of_two(rx_count);\n\n\tif (netif_running(netdev)) {\n\t\tnicvf_stop(netdev);\n\t\tnicvf_open(netdev);\n\t}\n\n\treturn 0;\n}\n\nstatic int nicvf_get_rss_hash_opts(struct nicvf *nic,\n\t\t\t\t   struct ethtool_rxnfc *info)\n{\n\tinfo->data = 0;\n\n\tswitch (info->flow_type) {\n\tcase TCP_V4_FLOW:\n\tcase TCP_V6_FLOW:\n\tcase UDP_V4_FLOW:\n\tcase UDP_V6_FLOW:\n\tcase SCTP_V4_FLOW:\n\tcase SCTP_V6_FLOW:\n\t\tinfo->data |= RXH_L4_B_0_1 | RXH_L4_B_2_3;\n\t\tfallthrough;\n\tcase IPV4_FLOW:\n\tcase IPV6_FLOW:\n\t\tinfo->data |= RXH_IP_SRC | RXH_IP_DST;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int nicvf_get_rxnfc(struct net_device *dev,\n\t\t\t   struct ethtool_rxnfc *info, u32 *rules)\n{\n\tstruct nicvf *nic = netdev_priv(dev);\n\tint ret = -EOPNOTSUPP;\n\n\tswitch (info->cmd) {\n\tcase ETHTOOL_GRXRINGS:\n\t\tinfo->data = nic->rx_queues;\n\t\tret = 0;\n\t\tbreak;\n\tcase ETHTOOL_GRXFH:\n\t\treturn nicvf_get_rss_hash_opts(nic, info);\n\tdefault:\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic int nicvf_set_rss_hash_opts(struct nicvf *nic,\n\t\t\t\t   struct ethtool_rxnfc *info)\n{\n\tstruct nicvf_rss_info *rss = &nic->rss_info;\n\tu64 rss_cfg = nicvf_reg_read(nic, NIC_VNIC_RSS_CFG);\n\n\tif (!rss->enable)\n\t\tnetdev_err(nic->netdev,\n\t\t\t   \"RSS is disabled, hash cannot be set\\n\");\n\n\tnetdev_info(nic->netdev, \"Set RSS flow type = %d, data = %lld\\n\",\n\t\t    info->flow_type, info->data);\n\n\tif (!(info->data & RXH_IP_SRC) || !(info->data & RXH_IP_DST))\n\t\treturn -EINVAL;\n\n\tswitch (info->flow_type) {\n\tcase TCP_V4_FLOW:\n\tcase TCP_V6_FLOW:\n\t\tswitch (info->data & (RXH_L4_B_0_1 | RXH_L4_B_2_3)) {\n\t\tcase 0:\n\t\t\trss_cfg &= ~(1ULL << RSS_HASH_TCP);\n\t\t\tbreak;\n\t\tcase (RXH_L4_B_0_1 | RXH_L4_B_2_3):\n\t\t\trss_cfg |= (1ULL << RSS_HASH_TCP);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase UDP_V4_FLOW:\n\tcase UDP_V6_FLOW:\n\t\tswitch (info->data & (RXH_L4_B_0_1 | RXH_L4_B_2_3)) {\n\t\tcase 0:\n\t\t\trss_cfg &= ~(1ULL << RSS_HASH_UDP);\n\t\t\tbreak;\n\t\tcase (RXH_L4_B_0_1 | RXH_L4_B_2_3):\n\t\t\trss_cfg |= (1ULL << RSS_HASH_UDP);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase SCTP_V4_FLOW:\n\tcase SCTP_V6_FLOW:\n\t\tswitch (info->data & (RXH_L4_B_0_1 | RXH_L4_B_2_3)) {\n\t\tcase 0:\n\t\t\trss_cfg &= ~(1ULL << RSS_HASH_L4ETC);\n\t\t\tbreak;\n\t\tcase (RXH_L4_B_0_1 | RXH_L4_B_2_3):\n\t\t\trss_cfg |= (1ULL << RSS_HASH_L4ETC);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase IPV4_FLOW:\n\tcase IPV6_FLOW:\n\t\trss_cfg = RSS_HASH_IP;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tnicvf_reg_write(nic, NIC_VNIC_RSS_CFG, rss_cfg);\n\treturn 0;\n}\n\nstatic int nicvf_set_rxnfc(struct net_device *dev, struct ethtool_rxnfc *info)\n{\n\tstruct nicvf *nic = netdev_priv(dev);\n\n\tswitch (info->cmd) {\n\tcase ETHTOOL_SRXFH:\n\t\treturn nicvf_set_rss_hash_opts(nic, info);\n\tdefault:\n\t\tbreak;\n\t}\n\treturn -EOPNOTSUPP;\n}\n\nstatic u32 nicvf_get_rxfh_key_size(struct net_device *netdev)\n{\n\treturn RSS_HASH_KEY_SIZE * sizeof(u64);\n}\n\nstatic u32 nicvf_get_rxfh_indir_size(struct net_device *dev)\n{\n\tstruct nicvf *nic = netdev_priv(dev);\n\n\treturn nic->rss_info.rss_size;\n}\n\nstatic int nicvf_get_rxfh(struct net_device *dev, u32 *indir, u8 *hkey,\n\t\t\t  u8 *hfunc)\n{\n\tstruct nicvf *nic = netdev_priv(dev);\n\tstruct nicvf_rss_info *rss = &nic->rss_info;\n\tint idx;\n\n\tif (indir) {\n\t\tfor (idx = 0; idx < rss->rss_size; idx++)\n\t\t\tindir[idx] = rss->ind_tbl[idx];\n\t}\n\n\tif (hkey)\n\t\tmemcpy(hkey, rss->key, RSS_HASH_KEY_SIZE * sizeof(u64));\n\n\tif (hfunc)\n\t\t*hfunc = ETH_RSS_HASH_TOP;\n\n\treturn 0;\n}\n\nstatic int nicvf_set_rxfh(struct net_device *dev, const u32 *indir,\n\t\t\t  const u8 *hkey, const u8 hfunc)\n{\n\tstruct nicvf *nic = netdev_priv(dev);\n\tstruct nicvf_rss_info *rss = &nic->rss_info;\n\tint idx;\n\n\tif (hfunc != ETH_RSS_HASH_NO_CHANGE && hfunc != ETH_RSS_HASH_TOP)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!rss->enable) {\n\t\tnetdev_err(nic->netdev,\n\t\t\t   \"RSS is disabled, cannot change settings\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (indir) {\n\t\tfor (idx = 0; idx < rss->rss_size; idx++)\n\t\t\trss->ind_tbl[idx] = indir[idx];\n\t}\n\n\tif (hkey) {\n\t\tmemcpy(rss->key, hkey, RSS_HASH_KEY_SIZE * sizeof(u64));\n\t\tnicvf_set_rss_key(nic);\n\t}\n\n\tnicvf_config_rss(nic);\n\treturn 0;\n}\n\n \nstatic void nicvf_get_channels(struct net_device *dev,\n\t\t\t       struct ethtool_channels *channel)\n{\n\tstruct nicvf *nic = netdev_priv(dev);\n\n\tmemset(channel, 0, sizeof(*channel));\n\n\tchannel->max_rx = nic->max_queues;\n\tchannel->max_tx = nic->max_queues;\n\n\tchannel->rx_count = nic->rx_queues;\n\tchannel->tx_count = nic->tx_queues;\n}\n\n \nstatic int nicvf_set_channels(struct net_device *dev,\n\t\t\t      struct ethtool_channels *channel)\n{\n\tstruct nicvf *nic = netdev_priv(dev);\n\tint err = 0;\n\tbool if_up = netif_running(dev);\n\tu8 cqcount, txq_count;\n\n\tif (!channel->rx_count || !channel->tx_count)\n\t\treturn -EINVAL;\n\tif (channel->rx_count > nic->max_queues)\n\t\treturn -EINVAL;\n\tif (channel->tx_count > nic->max_queues)\n\t\treturn -EINVAL;\n\n\tif (channel->tx_count + channel->rx_count > nic->max_queues) {\n\t\tif (nic->xdp_prog) {\n\t\t\tnetdev_err(nic->netdev,\n\t\t\t\t   \"XDP mode, RXQs + TXQs > Max %d\\n\",\n\t\t\t\t   nic->max_queues);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\txdp_clear_features_flag(nic->netdev);\n\t} else if (!pass1_silicon(nic->pdev)) {\n\t\txdp_set_features_flag(dev, NETDEV_XDP_ACT_BASIC);\n\t}\n\n\tif (if_up)\n\t\tnicvf_stop(dev);\n\n\tnic->rx_queues = channel->rx_count;\n\tnic->tx_queues = channel->tx_count;\n\tif (!nic->xdp_prog)\n\t\tnic->xdp_tx_queues = 0;\n\telse\n\t\tnic->xdp_tx_queues = channel->rx_count;\n\n\ttxq_count = nic->xdp_tx_queues + nic->tx_queues;\n\tcqcount = max(nic->rx_queues, txq_count);\n\n\tif (cqcount > MAX_CMP_QUEUES_PER_QS) {\n\t\tnic->sqs_count = roundup(cqcount, MAX_CMP_QUEUES_PER_QS);\n\t\tnic->sqs_count = (nic->sqs_count / MAX_CMP_QUEUES_PER_QS) - 1;\n\t} else {\n\t\tnic->sqs_count = 0;\n\t}\n\n\tnic->qs->rq_cnt = min_t(u8, nic->rx_queues, MAX_RCV_QUEUES_PER_QS);\n\tnic->qs->sq_cnt = min_t(u8, txq_count, MAX_SND_QUEUES_PER_QS);\n\tnic->qs->cq_cnt = max(nic->qs->rq_cnt, nic->qs->sq_cnt);\n\n\terr = nicvf_set_real_num_queues(dev, nic->tx_queues, nic->rx_queues);\n\tif (err)\n\t\treturn err;\n\n\tif (if_up)\n\t\tnicvf_open(dev);\n\n\tnetdev_info(dev, \"Setting num Tx rings to %d, Rx rings to %d success\\n\",\n\t\t    nic->tx_queues, nic->rx_queues);\n\n\treturn err;\n}\n\nstatic void nicvf_get_pauseparam(struct net_device *dev,\n\t\t\t\t struct ethtool_pauseparam *pause)\n{\n\tstruct nicvf *nic = netdev_priv(dev);\n\tunion nic_mbx mbx = {};\n\n\t \n\tif ((nic->mac_type == BGX_MODE_SGMII) ||\n\t    (nic->mac_type == BGX_MODE_QSGMII) ||\n\t    (nic->mac_type == BGX_MODE_RGMII))\n\t\treturn;\n\n\tmbx.pfc.msg = NIC_MBOX_MSG_PFC;\n\tmbx.pfc.get = 1;\n\tif (!nicvf_send_msg_to_pf(nic, &mbx)) {\n\t\tpause->autoneg = nic->pfc.autoneg;\n\t\tpause->rx_pause = nic->pfc.fc_rx;\n\t\tpause->tx_pause = nic->pfc.fc_tx;\n\t}\n}\n\nstatic int nicvf_set_pauseparam(struct net_device *dev,\n\t\t\t\tstruct ethtool_pauseparam *pause)\n{\n\tstruct nicvf *nic = netdev_priv(dev);\n\tunion nic_mbx mbx = {};\n\n\t \n\tif ((nic->mac_type == BGX_MODE_SGMII) ||\n\t    (nic->mac_type == BGX_MODE_QSGMII) ||\n\t    (nic->mac_type == BGX_MODE_RGMII))\n\t\treturn -EOPNOTSUPP;\n\n\tif (pause->autoneg)\n\t\treturn -EOPNOTSUPP;\n\n\tmbx.pfc.msg = NIC_MBOX_MSG_PFC;\n\tmbx.pfc.get = 0;\n\tmbx.pfc.fc_rx = pause->rx_pause;\n\tmbx.pfc.fc_tx = pause->tx_pause;\n\tif (nicvf_send_msg_to_pf(nic, &mbx))\n\t\treturn -EAGAIN;\n\n\tnic->pfc.fc_rx = pause->rx_pause;\n\tnic->pfc.fc_tx = pause->tx_pause;\n\n\treturn 0;\n}\n\nstatic int nicvf_get_ts_info(struct net_device *netdev,\n\t\t\t     struct ethtool_ts_info *info)\n{\n\tstruct nicvf *nic = netdev_priv(netdev);\n\n\tif (!nic->ptp_clock)\n\t\treturn ethtool_op_get_ts_info(netdev, info);\n\n\tinfo->so_timestamping = SOF_TIMESTAMPING_TX_SOFTWARE |\n\t\t\t\tSOF_TIMESTAMPING_RX_SOFTWARE |\n\t\t\t\tSOF_TIMESTAMPING_SOFTWARE |\n\t\t\t\tSOF_TIMESTAMPING_TX_HARDWARE |\n\t\t\t\tSOF_TIMESTAMPING_RX_HARDWARE |\n\t\t\t\tSOF_TIMESTAMPING_RAW_HARDWARE;\n\n\tinfo->phc_index = cavium_ptp_clock_index(nic->ptp_clock);\n\n\tinfo->tx_types = (1 << HWTSTAMP_TX_OFF) | (1 << HWTSTAMP_TX_ON);\n\n\tinfo->rx_filters = (1 << HWTSTAMP_FILTER_NONE) |\n\t\t\t   (1 << HWTSTAMP_FILTER_ALL);\n\n\treturn 0;\n}\n\nstatic const struct ethtool_ops nicvf_ethtool_ops = {\n\t.get_link\t\t= nicvf_get_link,\n\t.get_drvinfo\t\t= nicvf_get_drvinfo,\n\t.get_msglevel\t\t= nicvf_get_msglevel,\n\t.set_msglevel\t\t= nicvf_set_msglevel,\n\t.get_strings\t\t= nicvf_get_strings,\n\t.get_sset_count\t\t= nicvf_get_sset_count,\n\t.get_ethtool_stats\t= nicvf_get_ethtool_stats,\n\t.get_regs_len\t\t= nicvf_get_regs_len,\n\t.get_regs\t\t= nicvf_get_regs,\n\t.get_coalesce\t\t= nicvf_get_coalesce,\n\t.get_ringparam\t\t= nicvf_get_ringparam,\n\t.set_ringparam\t\t= nicvf_set_ringparam,\n\t.get_rxnfc\t\t= nicvf_get_rxnfc,\n\t.set_rxnfc\t\t= nicvf_set_rxnfc,\n\t.get_rxfh_key_size\t= nicvf_get_rxfh_key_size,\n\t.get_rxfh_indir_size\t= nicvf_get_rxfh_indir_size,\n\t.get_rxfh\t\t= nicvf_get_rxfh,\n\t.set_rxfh\t\t= nicvf_set_rxfh,\n\t.get_channels\t\t= nicvf_get_channels,\n\t.set_channels\t\t= nicvf_set_channels,\n\t.get_pauseparam         = nicvf_get_pauseparam,\n\t.set_pauseparam         = nicvf_set_pauseparam,\n\t.get_ts_info\t\t= nicvf_get_ts_info,\n\t.get_link_ksettings\t= nicvf_get_link_ksettings,\n};\n\nvoid nicvf_set_ethtool_ops(struct net_device *netdev)\n{\n\tnetdev->ethtool_ops = &nicvf_ethtool_ops;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}