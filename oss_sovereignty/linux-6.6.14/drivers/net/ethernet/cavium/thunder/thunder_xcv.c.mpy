{
  "module_name": "thunder_xcv.c",
  "hash_id": "2c1ceb420516ec42ded82fa95c469f14c9d6f4fd3494fe62dbb1ac64d8f54ff9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/cavium/thunder/thunder_xcv.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/phy.h>\n#include <linux/of.h>\n#include <linux/of_mdio.h>\n#include <linux/of_net.h>\n\n#include \"nic.h\"\n#include \"thunder_bgx.h\"\n\n#define DRV_NAME\t\"thunder_xcv\"\n#define DRV_VERSION\t\"1.0\"\n\n \n#define XCV_RESET\t\t0x00\n#define   PORT_EN\t\tBIT_ULL(63)\n#define   CLK_RESET\t\tBIT_ULL(15)\n#define   DLL_RESET\t\tBIT_ULL(11)\n#define   COMP_EN\t\tBIT_ULL(7)\n#define   TX_PKT_RESET\t\tBIT_ULL(3)\n#define   TX_DATA_RESET\t\tBIT_ULL(2)\n#define   RX_PKT_RESET\t\tBIT_ULL(1)\n#define   RX_DATA_RESET\t\tBIT_ULL(0)\n#define XCV_DLL_CTL\t\t0x10\n#define   CLKRX_BYP\t\tBIT_ULL(23)\n#define   CLKTX_BYP\t\tBIT_ULL(15)\n#define XCV_COMP_CTL\t\t0x20\n#define   DRV_BYP\t\tBIT_ULL(63)\n#define XCV_CTL\t\t\t0x30\n#define XCV_INT\t\t\t0x40\n#define XCV_INT_W1S\t\t0x48\n#define XCV_INT_ENA_W1C\t\t0x50\n#define XCV_INT_ENA_W1S\t\t0x58\n#define XCV_INBND_STATUS\t0x80\n#define XCV_BATCH_CRD_RET\t0x100\n\nstruct xcv {\n\tvoid __iomem\t\t*reg_base;\n\tstruct pci_dev\t\t*pdev;\n};\n\nstatic struct xcv *xcv;\n\n \nstatic const struct pci_device_id xcv_id_table[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_CAVIUM, 0xA056) },\n\t{ 0, }   \n};\n\nMODULE_AUTHOR(\"Cavium Inc\");\nMODULE_DESCRIPTION(\"Cavium Thunder RGX/XCV Driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_VERSION(DRV_VERSION);\nMODULE_DEVICE_TABLE(pci, xcv_id_table);\n\nvoid xcv_init_hw(void)\n{\n\tu64  cfg;\n\n\t \n\tcfg = readq_relaxed(xcv->reg_base + XCV_RESET);\n\tcfg &= ~DLL_RESET;\n\twriteq_relaxed(cfg, xcv->reg_base + XCV_RESET);\n\n\t \n\tcfg = readq_relaxed(xcv->reg_base + XCV_RESET);\n\tcfg &= ~CLK_RESET;\n\twriteq_relaxed(cfg, xcv->reg_base + XCV_RESET);\n\t \n\tmsleep(1);\n\n\t \n\tcfg = readq_relaxed(xcv->reg_base + XCV_DLL_CTL);\n\tcfg &= ~0xFF03;\n\tcfg |= CLKRX_BYP;\n\twriteq_relaxed(cfg, xcv->reg_base + XCV_DLL_CTL);\n\n\t \n\tcfg = readq_relaxed(xcv->reg_base + XCV_RESET);\n\tcfg |= COMP_EN;\n\twriteq_relaxed(cfg, xcv->reg_base + XCV_RESET);\n\treadq_relaxed(xcv->reg_base + XCV_RESET);\n\t \n\tmsleep(10);\n\n\t \n\tcfg = readq_relaxed(xcv->reg_base + XCV_RESET);\n\tcfg |= PORT_EN;\n\twriteq_relaxed(cfg, xcv->reg_base + XCV_RESET);\n\n\tcfg = readq_relaxed(xcv->reg_base + XCV_RESET);\n\tcfg |= CLK_RESET;\n\twriteq_relaxed(cfg, xcv->reg_base + XCV_RESET);\n}\nEXPORT_SYMBOL(xcv_init_hw);\n\nvoid xcv_setup_link(bool link_up, int link_speed)\n{\n\tu64  cfg;\n\tint speed = 2;\n\n\tif (!xcv) {\n\t\tpr_err(\"XCV init not done, probe may have failed\\n\");\n\t\treturn;\n\t}\n\n\tif (link_speed == 100)\n\t\tspeed = 1;\n\telse if (link_speed == 10)\n\t\tspeed = 0;\n\n\tif (link_up) {\n\t\t \n\t\tcfg = readq_relaxed(xcv->reg_base + XCV_CTL);\n\t\tcfg &= ~0x03;\n\t\tcfg |= speed;\n\t\twriteq_relaxed(cfg, xcv->reg_base + XCV_CTL);\n\n\t\t \n\t\tcfg = readq_relaxed(xcv->reg_base + XCV_RESET);\n\t\tcfg |= TX_DATA_RESET | RX_DATA_RESET;\n\t\twriteq_relaxed(cfg, xcv->reg_base + XCV_RESET);\n\n\t\t \n\t\tcfg = readq_relaxed(xcv->reg_base + XCV_RESET);\n\t\tcfg |= TX_PKT_RESET | RX_PKT_RESET;\n\t\twriteq_relaxed(cfg, xcv->reg_base + XCV_RESET);\n\n\t\t \n\t\twriteq_relaxed(0x01, xcv->reg_base + XCV_BATCH_CRD_RET);\n\t} else {\n\t\t \n\t\tcfg = readq_relaxed(xcv->reg_base + XCV_RESET);\n\t\tcfg &= ~(TX_PKT_RESET | RX_PKT_RESET);\n\t\twriteq_relaxed(cfg, xcv->reg_base + XCV_RESET);\n\t\treadq_relaxed(xcv->reg_base + XCV_RESET);\n\t}\n}\nEXPORT_SYMBOL(xcv_setup_link);\n\nstatic int xcv_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tint err;\n\tstruct device *dev = &pdev->dev;\n\n\txcv = devm_kzalloc(dev, sizeof(struct xcv), GFP_KERNEL);\n\tif (!xcv)\n\t\treturn -ENOMEM;\n\txcv->pdev = pdev;\n\n\tpci_set_drvdata(pdev, xcv);\n\n\terr = pci_enable_device(pdev);\n\tif (err) {\n\t\tdev_err(dev, \"Failed to enable PCI device\\n\");\n\t\tgoto err_kfree;\n\t}\n\n\terr = pci_request_regions(pdev, DRV_NAME);\n\tif (err) {\n\t\tdev_err(dev, \"PCI request regions failed 0x%x\\n\", err);\n\t\tgoto err_disable_device;\n\t}\n\n\t \n\txcv->reg_base = pcim_iomap(pdev, PCI_CFG_REG_BAR_NUM, 0);\n\tif (!xcv->reg_base) {\n\t\tdev_err(dev, \"XCV: Cannot map CSR memory space, aborting\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto err_release_regions;\n\t}\n\n\treturn 0;\n\nerr_release_regions:\n\tpci_release_regions(pdev);\nerr_disable_device:\n\tpci_disable_device(pdev);\nerr_kfree:\n\tdevm_kfree(dev, xcv);\n\txcv = NULL;\n\treturn err;\n}\n\nstatic void xcv_remove(struct pci_dev *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\n\tif (xcv) {\n\t\tdevm_kfree(dev, xcv);\n\t\txcv = NULL;\n\t}\n\n\tpci_release_regions(pdev);\n\tpci_disable_device(pdev);\n}\n\nstatic struct pci_driver xcv_driver = {\n\t.name = DRV_NAME,\n\t.id_table = xcv_id_table,\n\t.probe = xcv_probe,\n\t.remove = xcv_remove,\n};\n\nstatic int __init xcv_init_module(void)\n{\n\tpr_info(\"%s, ver %s\\n\", DRV_NAME, DRV_VERSION);\n\n\treturn pci_register_driver(&xcv_driver);\n}\n\nstatic void __exit xcv_cleanup_module(void)\n{\n\tpci_unregister_driver(&xcv_driver);\n}\n\nmodule_init(xcv_init_module);\nmodule_exit(xcv_cleanup_module);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}