{
  "module_name": "cn68xx_device.c",
  "hash_id": "a2f82e93fc300f2437ab46a4d8a026bef3e5f011662e011ec3268c0e21459eae",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/cavium/liquidio/cn68xx_device.c",
  "human_readable_source": " \n#include <linux/pci.h>\n#include <linux/netdevice.h>\n#include \"liquidio_common.h\"\n#include \"octeon_droq.h\"\n#include \"octeon_iq.h\"\n#include \"response_manager.h\"\n#include \"octeon_device.h\"\n#include \"octeon_main.h\"\n#include \"cn66xx_regs.h\"\n#include \"cn66xx_device.h\"\n#include \"cn68xx_device.h\"\n#include \"cn68xx_regs.h\"\n\nstatic void lio_cn68xx_set_dpi_regs(struct octeon_device *oct)\n{\n\tu32 i;\n\tu32 fifo_sizes[6] = { 3, 3, 1, 1, 1, 8 };\n\n\tlio_pci_writeq(oct, CN6XXX_DPI_DMA_CTL_MASK, CN6XXX_DPI_DMA_CONTROL);\n\tdev_dbg(&oct->pci_dev->dev, \"DPI_DMA_CONTROL: 0x%016llx\\n\",\n\t\tlio_pci_readq(oct, CN6XXX_DPI_DMA_CONTROL));\n\n\tfor (i = 0; i < 6; i++) {\n\t\t \n\t\tlio_pci_writeq(oct, 0, CN6XXX_DPI_DMA_ENG_ENB(i));\n\t\tlio_pci_writeq(oct, fifo_sizes[i], CN6XXX_DPI_DMA_ENG_BUF(i));\n\t\tdev_dbg(&oct->pci_dev->dev, \"DPI_ENG_BUF%d: 0x%016llx\\n\", i,\n\t\t\tlio_pci_readq(oct, CN6XXX_DPI_DMA_ENG_BUF(i)));\n\t}\n\n\t \n\n\tlio_pci_writeq(oct, 1, CN6XXX_DPI_CTL);\n\tdev_dbg(&oct->pci_dev->dev, \"DPI_CTL: 0x%016llx\\n\",\n\t\tlio_pci_readq(oct, CN6XXX_DPI_CTL));\n}\n\nstatic int lio_cn68xx_soft_reset(struct octeon_device *oct)\n{\n\tlio_cn6xxx_soft_reset(oct);\n\tlio_cn68xx_set_dpi_regs(oct);\n\n\treturn 0;\n}\n\nstatic void lio_cn68xx_setup_pkt_ctl_regs(struct octeon_device *oct)\n{\n\tstruct octeon_cn6xxx *cn68xx = (struct octeon_cn6xxx *)oct->chip;\n\tu64 pktctl, tx_pipe, max_oqs;\n\n\tpktctl = octeon_read_csr64(oct, CN6XXX_SLI_PKT_CTL);\n\n\t \n\tmax_oqs = CFG_GET_OQ_MAX_Q(CHIP_CONF(oct, cn6xxx));\n\ttx_pipe  = octeon_read_csr64(oct, CN68XX_SLI_TX_PIPE);\n\ttx_pipe &= 0xffffffffff00ffffULL;  \n\ttx_pipe |= max_oqs << 16;  \n\tocteon_write_csr64(oct, CN68XX_SLI_TX_PIPE, tx_pipe);\n\n\tif (CFG_GET_IS_SLI_BP_ON(cn68xx->conf))\n\t\tpktctl |= 0xF;\n\telse\n\t\t \n\t\tpktctl &= ~0xF;\n\tocteon_write_csr64(oct, CN6XXX_SLI_PKT_CTL, pktctl);\n}\n\nstatic int lio_cn68xx_setup_device_regs(struct octeon_device *oct)\n{\n\tlio_cn6xxx_setup_pcie_mps(oct, PCIE_MPS_DEFAULT);\n\tlio_cn6xxx_setup_pcie_mrrs(oct, PCIE_MRRS_256B);\n\tlio_cn6xxx_enable_error_reporting(oct);\n\n\tlio_cn6xxx_setup_global_input_regs(oct);\n\tlio_cn68xx_setup_pkt_ctl_regs(oct);\n\tlio_cn6xxx_setup_global_output_regs(oct);\n\n\t \n\tocteon_write_csr64(oct, CN6XXX_SLI_WINDOW_CTL, 0x200000ULL);\n\n\treturn 0;\n}\n\nstatic inline void lio_cn68xx_vendor_message_fix(struct octeon_device *oct)\n{\n\tu32 val = 0;\n\n\t \n\tpci_read_config_dword(oct->pci_dev, CN6XXX_PCIE_FLTMSK, &val);\n\tval |= 0x3;\n\tpci_write_config_dword(oct->pci_dev, CN6XXX_PCIE_FLTMSK, val);\n}\n\nstatic int lio_is_210nv(struct octeon_device *oct)\n{\n\tu64 mio_qlm4_cfg = lio_pci_readq(oct, CN6XXX_MIO_QLM4_CFG);\n\n\treturn ((mio_qlm4_cfg & CN6XXX_MIO_QLM_CFG_MASK) == 0);\n}\n\nint lio_setup_cn68xx_octeon_device(struct octeon_device *oct)\n{\n\tstruct octeon_cn6xxx *cn68xx = (struct octeon_cn6xxx *)oct->chip;\n\tu16 card_type = LIO_410NV;\n\n\tif (octeon_map_pci_barx(oct, 0, 0))\n\t\treturn 1;\n\n\tif (octeon_map_pci_barx(oct, 1, MAX_BAR1_IOREMAP_SIZE)) {\n\t\tdev_err(&oct->pci_dev->dev, \"%s CN68XX BAR1 map failed\\n\",\n\t\t\t__func__);\n\t\tocteon_unmap_pci_barx(oct, 0);\n\t\treturn 1;\n\t}\n\n\tspin_lock_init(&cn68xx->lock_for_droq_int_enb_reg);\n\n\toct->fn_list.setup_iq_regs = lio_cn6xxx_setup_iq_regs;\n\toct->fn_list.setup_oq_regs = lio_cn6xxx_setup_oq_regs;\n\n\toct->fn_list.process_interrupt_regs = lio_cn6xxx_process_interrupt_regs;\n\toct->fn_list.soft_reset = lio_cn68xx_soft_reset;\n\toct->fn_list.setup_device_regs = lio_cn68xx_setup_device_regs;\n\toct->fn_list.update_iq_read_idx = lio_cn6xxx_update_read_index;\n\n\toct->fn_list.bar1_idx_setup = lio_cn6xxx_bar1_idx_setup;\n\toct->fn_list.bar1_idx_write = lio_cn6xxx_bar1_idx_write;\n\toct->fn_list.bar1_idx_read = lio_cn6xxx_bar1_idx_read;\n\n\toct->fn_list.enable_interrupt = lio_cn6xxx_enable_interrupt;\n\toct->fn_list.disable_interrupt = lio_cn6xxx_disable_interrupt;\n\n\toct->fn_list.enable_io_queues = lio_cn6xxx_enable_io_queues;\n\toct->fn_list.disable_io_queues = lio_cn6xxx_disable_io_queues;\n\n\tlio_cn6xxx_setup_reg_address(oct, oct->chip, &oct->reg_list);\n\n\t \n\tif (lio_is_210nv(oct))\n\t\tcard_type = LIO_210NV;\n\n\tcn68xx->conf = (struct octeon_config *)\n\t\t       oct_get_config_info(oct, card_type);\n\tif (!cn68xx->conf) {\n\t\tdev_err(&oct->pci_dev->dev, \"%s No Config found for CN68XX %s\\n\",\n\t\t\t__func__,\n\t\t\t(card_type == LIO_410NV) ? LIO_410NV_NAME :\n\t\t\tLIO_210NV_NAME);\n\t\tocteon_unmap_pci_barx(oct, 0);\n\t\tocteon_unmap_pci_barx(oct, 1);\n\t\treturn 1;\n\t}\n\n\toct->coproc_clock_rate = 1000000ULL * lio_cn6xxx_coprocessor_clock(oct);\n\n\tlio_cn68xx_vendor_message_fix(oct);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(lio_setup_cn68xx_octeon_device);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}