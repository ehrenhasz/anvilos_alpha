{
  "module_name": "response_manager.c",
  "hash_id": "1a0d25045ce48030b1a017117a494585dd6ebd63c1cd9dbf3fb77e8d46429e6b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/cavium/liquidio/response_manager.c",
  "human_readable_source": " \n#include <linux/pci.h>\n#include <linux/netdevice.h>\n#include \"liquidio_common.h\"\n#include \"octeon_droq.h\"\n#include \"octeon_iq.h\"\n#include \"response_manager.h\"\n#include \"octeon_device.h\"\n#include \"octeon_main.h\"\n\nstatic void oct_poll_req_completion(struct work_struct *work);\n\nint octeon_setup_response_list(struct octeon_device *oct)\n{\n\tint i, ret = 0;\n\tstruct cavium_wq *cwq;\n\n\tfor (i = 0; i < MAX_RESPONSE_LISTS; i++) {\n\t\tINIT_LIST_HEAD(&oct->response_list[i].head);\n\t\tspin_lock_init(&oct->response_list[i].lock);\n\t\tatomic_set(&oct->response_list[i].pending_req_count, 0);\n\t}\n\tspin_lock_init(&oct->cmd_resp_wqlock);\n\n\toct->dma_comp_wq.wq = alloc_workqueue(\"dma-comp\", WQ_MEM_RECLAIM, 0);\n\tif (!oct->dma_comp_wq.wq) {\n\t\tdev_err(&oct->pci_dev->dev, \"failed to create wq thread\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tcwq = &oct->dma_comp_wq;\n\tINIT_DELAYED_WORK(&cwq->wk.work, oct_poll_req_completion);\n\tcwq->wk.ctxptr = oct;\n\toct->cmd_resp_state = OCT_DRV_ONLINE;\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(octeon_setup_response_list);\n\nvoid octeon_delete_response_list(struct octeon_device *oct)\n{\n\tcancel_delayed_work_sync(&oct->dma_comp_wq.wk.work);\n\tdestroy_workqueue(oct->dma_comp_wq.wq);\n}\nEXPORT_SYMBOL_GPL(octeon_delete_response_list);\n\nint lio_process_ordered_list(struct octeon_device *octeon_dev,\n\t\t\t     u32 force_quit)\n{\n\tstruct octeon_response_list *ordered_sc_list;\n\tstruct octeon_soft_command *sc;\n\tint request_complete = 0;\n\tint resp_to_process = MAX_ORD_REQS_TO_PROCESS;\n\tu32 status;\n\tu64 status64;\n\n\tocteon_free_sc_done_list(octeon_dev);\n\n\tordered_sc_list = &octeon_dev->response_list[OCTEON_ORDERED_SC_LIST];\n\n\tdo {\n\t\tspin_lock_bh(&ordered_sc_list->lock);\n\n\t\tif (list_empty(&ordered_sc_list->head)) {\n\t\t\tspin_unlock_bh(&ordered_sc_list->lock);\n\t\t\treturn 1;\n\t\t}\n\n\t\tsc = list_first_entry(&ordered_sc_list->head,\n\t\t\t\t      struct octeon_soft_command, node);\n\n\t\tstatus = OCTEON_REQUEST_PENDING;\n\n\t\t \n\t\tstatus64 = *sc->status_word;\n\n\t\tif (status64 != COMPLETION_WORD_INIT) {\n\t\t\t \n\t\t\tif ((status64 & 0xff) != 0xff) {\n\t\t\t\tocteon_swap_8B_data(&status64, 1);\n\t\t\t\tif (((status64 & 0xff) != 0xff)) {\n\t\t\t\t\t \n\t\t\t\t\tstatus = (u32)(status64 & 0xffffULL);\n\t\t\t\t\tif (status) {\n\t\t\t\t\t\tstatus =\n\t\t\t\t\t\t  FIRMWARE_STATUS_CODE(status);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t \n\t\t\t\t\t\tstatus = OCTEON_REQUEST_DONE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (unlikely(force_quit) || (sc->expiry_time &&\n\t\t\ttime_after(jiffies, (unsigned long)sc->expiry_time))) {\n\t\t\tstruct octeon_instr_irh *irh =\n\t\t\t\t(struct octeon_instr_irh *)&sc->cmd.cmd3.irh;\n\n\t\t\tdev_err(&octeon_dev->pci_dev->dev, \"%s: \", __func__);\n\t\t\tdev_err(&octeon_dev->pci_dev->dev,\n\t\t\t\t\"cmd %x/%x/%llx/%llx failed, \",\n\t\t\t\tirh->opcode, irh->subcode,\n\t\t\t\tsc->cmd.cmd3.ossp[0], sc->cmd.cmd3.ossp[1]);\n\t\t\tdev_err(&octeon_dev->pci_dev->dev,\n\t\t\t\t\"timeout (%ld, %ld)\\n\",\n\t\t\t\t(long)jiffies, (long)sc->expiry_time);\n\t\t\tstatus = OCTEON_REQUEST_TIMEOUT;\n\t\t}\n\n\t\tif (status != OCTEON_REQUEST_PENDING) {\n\t\t\tsc->sc_status = status;\n\n\t\t\t \n\t\t\t \n\t\t\tlist_del(&sc->node);\n\t\t\tatomic_dec(&octeon_dev->response_list\n\t\t\t\t   [OCTEON_ORDERED_SC_LIST].\n\t\t\t\t   pending_req_count);\n\n\t\t\tif (!sc->callback) {\n\t\t\t\tatomic_inc(&octeon_dev->response_list\n\t\t\t\t\t   [OCTEON_DONE_SC_LIST].\n\t\t\t\t\t   pending_req_count);\n\t\t\t\tlist_add_tail(&sc->node,\n\t\t\t\t\t      &octeon_dev->response_list\n\t\t\t\t\t      [OCTEON_DONE_SC_LIST].head);\n\n\t\t\t\tif (unlikely(READ_ONCE(sc->caller_is_done))) {\n\t\t\t\t\t \n\t\t\t\t\tif (status != OCTEON_REQUEST_DONE) {\n\t\t\t\t\t\tstruct octeon_instr_irh *irh;\n\n\t\t\t\t\t\tirh =\n\t\t\t\t\t\t    (struct octeon_instr_irh *)\n\t\t\t\t\t\t    &sc->cmd.cmd3.irh;\n\t\t\t\t\t\tdev_dbg\n\t\t\t\t\t\t    (&octeon_dev->pci_dev->dev,\n\t\t\t\t\t\t    \"%s: sc failed: opcode=%x, \",\n\t\t\t\t\t\t    __func__, irh->opcode);\n\t\t\t\t\t\tdev_dbg\n\t\t\t\t\t\t    (&octeon_dev->pci_dev->dev,\n\t\t\t\t\t\t    \"subcode=%x, ossp[0]=%llx, \",\n\t\t\t\t\t\t    irh->subcode,\n\t\t\t\t\t\t    sc->cmd.cmd3.ossp[0]);\n\t\t\t\t\t\tdev_dbg\n\t\t\t\t\t\t    (&octeon_dev->pci_dev->dev,\n\t\t\t\t\t\t    \"ossp[1]=%llx, status=%d\\n\",\n\t\t\t\t\t\t    sc->cmd.cmd3.ossp[1],\n\t\t\t\t\t\t    status);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tcomplete(&sc->complete);\n\t\t\t\t}\n\n\t\t\t\tspin_unlock_bh(&ordered_sc_list->lock);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tif (status == OCTEON_REQUEST_TIMEOUT) {\n\t\t\t\t\tatomic_inc(&octeon_dev->response_list\n\t\t\t\t\t\t   [OCTEON_ZOMBIE_SC_LIST].\n\t\t\t\t\t\t   pending_req_count);\n\t\t\t\t\tlist_add_tail(&sc->node,\n\t\t\t\t\t\t      &octeon_dev->response_list\n\t\t\t\t\t\t      [OCTEON_ZOMBIE_SC_LIST].\n\t\t\t\t\t\t      head);\n\t\t\t\t}\n\n\t\t\t\tspin_unlock_bh(&ordered_sc_list->lock);\n\n\t\t\t\tsc->callback(octeon_dev, status,\n\t\t\t\t\t     sc->callback_arg);\n\t\t\t\t \n\t\t\t}\n\n\t\t\trequest_complete++;\n\n\t\t} else {\n\t\t\t \n\t\t\trequest_complete = 0;\n\t\t\tspin_unlock_bh\n\t\t\t    (&ordered_sc_list->lock);\n\t\t}\n\n\t\t \n\t\tif (request_complete >= resp_to_process)\n\t\t\tbreak;\n\t} while (request_complete);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(lio_process_ordered_list);\n\nstatic void oct_poll_req_completion(struct work_struct *work)\n{\n\tstruct cavium_wk *wk = (struct cavium_wk *)work;\n\tstruct octeon_device *oct = (struct octeon_device *)wk->ctxptr;\n\tstruct cavium_wq *cwq = &oct->dma_comp_wq;\n\n\tlio_process_ordered_list(oct, 0);\n\n\tif (atomic_read(&oct->response_list\n\t\t\t[OCTEON_ORDERED_SC_LIST].pending_req_count))\n\t\tqueue_delayed_work(cwq->wq, &cwq->wk.work, msecs_to_jiffies(1));\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}