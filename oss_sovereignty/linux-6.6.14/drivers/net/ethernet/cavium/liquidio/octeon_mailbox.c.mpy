{
  "module_name": "octeon_mailbox.c",
  "hash_id": "346e62a62f830014989c692699370db7e3fce7932e94580a419f74a26dfcb354",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/cavium/liquidio/octeon_mailbox.c",
  "human_readable_source": " \n#include <linux/pci.h>\n#include <linux/netdevice.h>\n#include \"liquidio_common.h\"\n#include \"octeon_droq.h\"\n#include \"octeon_iq.h\"\n#include \"response_manager.h\"\n#include \"octeon_device.h\"\n#include \"octeon_main.h\"\n#include \"octeon_mailbox.h\"\n#include \"cn23xx_pf_device.h\"\n\n \nint octeon_mbox_read(struct octeon_mbox *mbox)\n{\n\tunion octeon_mbox_message msg;\n\tint ret = 0;\n\n\tspin_lock(&mbox->lock);\n\n\tmsg.u64 = readq(mbox->mbox_read_reg);\n\n\tif ((msg.u64 == OCTEON_PFVFACK) || (msg.u64 == OCTEON_PFVFSIG)) {\n\t\tspin_unlock(&mbox->lock);\n\t\treturn 0;\n\t}\n\n\tif (mbox->state & OCTEON_MBOX_STATE_REQUEST_RECEIVING) {\n\t\tmbox->mbox_req.data[mbox->mbox_req.recv_len - 1] = msg.u64;\n\t\tmbox->mbox_req.recv_len++;\n\t} else {\n\t\tif (mbox->state & OCTEON_MBOX_STATE_RESPONSE_RECEIVING) {\n\t\t\tmbox->mbox_resp.data[mbox->mbox_resp.recv_len - 1] =\n\t\t\t\tmsg.u64;\n\t\t\tmbox->mbox_resp.recv_len++;\n\t\t} else {\n\t\t\tif ((mbox->state & OCTEON_MBOX_STATE_IDLE) &&\n\t\t\t    (msg.s.type == OCTEON_MBOX_REQUEST)) {\n\t\t\t\tmbox->state &= ~OCTEON_MBOX_STATE_IDLE;\n\t\t\t\tmbox->state |=\n\t\t\t\t    OCTEON_MBOX_STATE_REQUEST_RECEIVING;\n\t\t\t\tmbox->mbox_req.msg.u64 = msg.u64;\n\t\t\t\tmbox->mbox_req.q_no = mbox->q_no;\n\t\t\t\tmbox->mbox_req.recv_len = 1;\n\t\t\t} else {\n\t\t\t\tif ((mbox->state &\n\t\t\t\t     OCTEON_MBOX_STATE_RESPONSE_PENDING) &&\n\t\t\t\t    (msg.s.type == OCTEON_MBOX_RESPONSE)) {\n\t\t\t\t\tmbox->state &=\n\t\t\t\t\t    ~OCTEON_MBOX_STATE_RESPONSE_PENDING;\n\t\t\t\t\tmbox->state |=\n\t\t\t\t\t    OCTEON_MBOX_STATE_RESPONSE_RECEIVING\n\t\t\t\t\t    ;\n\t\t\t\t\tmbox->mbox_resp.msg.u64 = msg.u64;\n\t\t\t\t\tmbox->mbox_resp.q_no = mbox->q_no;\n\t\t\t\t\tmbox->mbox_resp.recv_len = 1;\n\t\t\t\t} else {\n\t\t\t\t\twriteq(OCTEON_PFVFERR,\n\t\t\t\t\t       mbox->mbox_read_reg);\n\t\t\t\t\tmbox->state |= OCTEON_MBOX_STATE_ERROR;\n\t\t\t\t\tspin_unlock(&mbox->lock);\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (mbox->state & OCTEON_MBOX_STATE_REQUEST_RECEIVING) {\n\t\tif (mbox->mbox_req.recv_len < mbox->mbox_req.msg.s.len) {\n\t\t\tret = 0;\n\t\t} else {\n\t\t\tmbox->state &= ~OCTEON_MBOX_STATE_REQUEST_RECEIVING;\n\t\t\tmbox->state |= OCTEON_MBOX_STATE_REQUEST_RECEIVED;\n\t\t\tret = 1;\n\t\t}\n\t} else {\n\t\tif (mbox->state & OCTEON_MBOX_STATE_RESPONSE_RECEIVING) {\n\t\t\tif (mbox->mbox_resp.recv_len <\n\t\t\t    mbox->mbox_resp.msg.s.len) {\n\t\t\t\tret = 0;\n\t\t\t} else {\n\t\t\t\tmbox->state &=\n\t\t\t\t    ~OCTEON_MBOX_STATE_RESPONSE_RECEIVING;\n\t\t\t\tmbox->state |=\n\t\t\t\t    OCTEON_MBOX_STATE_RESPONSE_RECEIVED;\n\t\t\t\tret = 1;\n\t\t\t}\n\t\t} else {\n\t\t\tWARN_ON(1);\n\t\t}\n\t}\n\n\twriteq(OCTEON_PFVFACK, mbox->mbox_read_reg);\n\n\tspin_unlock(&mbox->lock);\n\n\treturn ret;\n}\n\n \nint octeon_mbox_write(struct octeon_device *oct,\n\t\t      struct octeon_mbox_cmd *mbox_cmd)\n{\n\tstruct octeon_mbox *mbox = oct->mbox[mbox_cmd->q_no];\n\tu32 count, i, ret = OCTEON_MBOX_STATUS_SUCCESS;\n\tlong timeout = LIO_MBOX_WRITE_WAIT_TIME;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&mbox->lock, flags);\n\n\tif ((mbox_cmd->msg.s.type == OCTEON_MBOX_RESPONSE) &&\n\t    !(mbox->state & OCTEON_MBOX_STATE_REQUEST_RECEIVED)) {\n\t\tspin_unlock_irqrestore(&mbox->lock, flags);\n\t\treturn OCTEON_MBOX_STATUS_FAILED;\n\t}\n\n\tif ((mbox_cmd->msg.s.type == OCTEON_MBOX_REQUEST) &&\n\t    !(mbox->state & OCTEON_MBOX_STATE_IDLE)) {\n\t\tspin_unlock_irqrestore(&mbox->lock, flags);\n\t\treturn OCTEON_MBOX_STATUS_BUSY;\n\t}\n\n\tif (mbox_cmd->msg.s.type == OCTEON_MBOX_REQUEST) {\n\t\tmemcpy(&mbox->mbox_resp, mbox_cmd,\n\t\t       sizeof(struct octeon_mbox_cmd));\n\t\tmbox->state = OCTEON_MBOX_STATE_RESPONSE_PENDING;\n\t}\n\n\tspin_unlock_irqrestore(&mbox->lock, flags);\n\n\tcount = 0;\n\n\twhile (readq(mbox->mbox_write_reg) != OCTEON_PFVFSIG) {\n\t\tschedule_timeout_uninterruptible(timeout);\n\t\tif (count++ == LIO_MBOX_WRITE_WAIT_CNT) {\n\t\t\tret = OCTEON_MBOX_STATUS_FAILED;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ret == OCTEON_MBOX_STATUS_SUCCESS) {\n\t\twriteq(mbox_cmd->msg.u64, mbox->mbox_write_reg);\n\t\tfor (i = 0; i < (u32)(mbox_cmd->msg.s.len - 1); i++) {\n\t\t\tcount = 0;\n\t\t\twhile (readq(mbox->mbox_write_reg) !=\n\t\t\t       OCTEON_PFVFACK) {\n\t\t\t\tschedule_timeout_uninterruptible(timeout);\n\t\t\t\tif (count++ == LIO_MBOX_WRITE_WAIT_CNT) {\n\t\t\t\t\tret = OCTEON_MBOX_STATUS_FAILED;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ret == OCTEON_MBOX_STATUS_SUCCESS)\n\t\t\t\twriteq(mbox_cmd->data[i], mbox->mbox_write_reg);\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_lock_irqsave(&mbox->lock, flags);\n\tif (mbox_cmd->msg.s.type == OCTEON_MBOX_RESPONSE) {\n\t\tmbox->state = OCTEON_MBOX_STATE_IDLE;\n\t\twriteq(OCTEON_PFVFSIG, mbox->mbox_read_reg);\n\t} else {\n\t\tif ((!mbox_cmd->msg.s.resp_needed) ||\n\t\t    (ret == OCTEON_MBOX_STATUS_FAILED)) {\n\t\t\tmbox->state &= ~OCTEON_MBOX_STATE_RESPONSE_PENDING;\n\t\t\tif (!(mbox->state &\n\t\t\t      (OCTEON_MBOX_STATE_REQUEST_RECEIVING |\n\t\t\t       OCTEON_MBOX_STATE_REQUEST_RECEIVED)))\n\t\t\t\tmbox->state = OCTEON_MBOX_STATE_IDLE;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&mbox->lock, flags);\n\n\treturn ret;\n}\n\nstatic void get_vf_stats(struct octeon_device *oct,\n\t\t\t struct oct_vf_stats *stats)\n{\n\tint i;\n\n\tfor (i = 0; i < oct->num_iqs; i++) {\n\t\tif (!oct->instr_queue[i])\n\t\t\tcontinue;\n\t\tstats->tx_packets += oct->instr_queue[i]->stats.tx_done;\n\t\tstats->tx_bytes += oct->instr_queue[i]->stats.tx_tot_bytes;\n\t}\n\n\tfor (i = 0; i < oct->num_oqs; i++) {\n\t\tif (!oct->droq[i])\n\t\t\tcontinue;\n\t\tstats->rx_packets += oct->droq[i]->stats.rx_pkts_received;\n\t\tstats->rx_bytes += oct->droq[i]->stats.rx_bytes_received;\n\t}\n}\n\n \nstatic int octeon_mbox_process_cmd(struct octeon_mbox *mbox,\n\t\t\t\t   struct octeon_mbox_cmd *mbox_cmd)\n{\n\tstruct octeon_device *oct = mbox->oct_dev;\n\n\tswitch (mbox_cmd->msg.s.cmd) {\n\tcase OCTEON_VF_ACTIVE:\n\t\tdev_dbg(&oct->pci_dev->dev, \"got vfactive sending data back\\n\");\n\t\tmbox_cmd->msg.s.type = OCTEON_MBOX_RESPONSE;\n\t\tmbox_cmd->msg.s.resp_needed = 1;\n\t\tmbox_cmd->msg.s.len = 2;\n\t\tmbox_cmd->data[0] = 0;  \n\t\t((struct lio_version *)&mbox_cmd->data[0])->major =\n\t\t\tLIQUIDIO_BASE_MAJOR_VERSION;\n\t\t((struct lio_version *)&mbox_cmd->data[0])->minor =\n\t\t\tLIQUIDIO_BASE_MINOR_VERSION;\n\t\t((struct lio_version *)&mbox_cmd->data[0])->micro =\n\t\t\tLIQUIDIO_BASE_MICRO_VERSION;\n\t\tmemcpy(mbox_cmd->msg.s.params, (uint8_t *)&oct->pfvf_hsword, 6);\n\t\t \n\t\tocteon_mbox_write(oct, mbox_cmd);\n\t\tbreak;\n\n\tcase OCTEON_VF_FLR_REQUEST:\n\t\tdev_info(&oct->pci_dev->dev,\n\t\t\t \"got a request for FLR from VF that owns DPI ring %u\\n\",\n\t\t\t mbox->q_no);\n\t\tpcie_flr(oct->sriov_info.dpiring_to_vfpcidev_lut[mbox->q_no]);\n\t\tbreak;\n\n\tcase OCTEON_PF_CHANGED_VF_MACADDR:\n\t\tif (OCTEON_CN23XX_VF(oct))\n\t\t\tocteon_pf_changed_vf_macaddr(oct,\n\t\t\t\t\t\t     mbox_cmd->msg.s.params);\n\t\tbreak;\n\n\tcase OCTEON_GET_VF_STATS:\n\t\tdev_dbg(&oct->pci_dev->dev, \"Got VF stats request. Sending data back\\n\");\n\t\tmbox_cmd->msg.s.type = OCTEON_MBOX_RESPONSE;\n\t\tmbox_cmd->msg.s.resp_needed = 1;\n\t\tmbox_cmd->msg.s.len = 1 +\n\t\t\tsizeof(struct oct_vf_stats) / sizeof(u64);\n\t\tget_vf_stats(oct, (struct oct_vf_stats *)mbox_cmd->data);\n\t\tocteon_mbox_write(oct, mbox_cmd);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\n \nint octeon_mbox_process_message(struct octeon_mbox *mbox)\n{\n\tstruct octeon_mbox_cmd mbox_cmd;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&mbox->lock, flags);\n\n\tif (mbox->state & OCTEON_MBOX_STATE_ERROR) {\n\t\tif (mbox->state & (OCTEON_MBOX_STATE_RESPONSE_PENDING |\n\t\t\t\t   OCTEON_MBOX_STATE_RESPONSE_RECEIVING)) {\n\t\t\tmemcpy(&mbox_cmd, &mbox->mbox_resp,\n\t\t\t       sizeof(struct octeon_mbox_cmd));\n\t\t\tmbox->state = OCTEON_MBOX_STATE_IDLE;\n\t\t\twriteq(OCTEON_PFVFSIG, mbox->mbox_read_reg);\n\t\t\tspin_unlock_irqrestore(&mbox->lock, flags);\n\t\t\tmbox_cmd.recv_status = 1;\n\t\t\tif (mbox_cmd.fn)\n\t\t\t\tmbox_cmd.fn(mbox->oct_dev, &mbox_cmd,\n\t\t\t\t\t    mbox_cmd.fn_arg);\n\t\t\treturn 0;\n\t\t}\n\n\t\tmbox->state = OCTEON_MBOX_STATE_IDLE;\n\t\twriteq(OCTEON_PFVFSIG, mbox->mbox_read_reg);\n\t\tspin_unlock_irqrestore(&mbox->lock, flags);\n\t\treturn 0;\n\t}\n\n\tif (mbox->state & OCTEON_MBOX_STATE_RESPONSE_RECEIVED) {\n\t\tmemcpy(&mbox_cmd, &mbox->mbox_resp,\n\t\t       sizeof(struct octeon_mbox_cmd));\n\t\tmbox->state = OCTEON_MBOX_STATE_IDLE;\n\t\twriteq(OCTEON_PFVFSIG, mbox->mbox_read_reg);\n\t\tspin_unlock_irqrestore(&mbox->lock, flags);\n\t\tmbox_cmd.recv_status = 0;\n\t\tif (mbox_cmd.fn)\n\t\t\tmbox_cmd.fn(mbox->oct_dev, &mbox_cmd, mbox_cmd.fn_arg);\n\t\treturn 0;\n\t}\n\n\tif (mbox->state & OCTEON_MBOX_STATE_REQUEST_RECEIVED) {\n\t\tmemcpy(&mbox_cmd, &mbox->mbox_req,\n\t\t       sizeof(struct octeon_mbox_cmd));\n\t\tif (!mbox_cmd.msg.s.resp_needed) {\n\t\t\tmbox->state &= ~OCTEON_MBOX_STATE_REQUEST_RECEIVED;\n\t\t\tif (!(mbox->state &\n\t\t\t      OCTEON_MBOX_STATE_RESPONSE_PENDING))\n\t\t\t\tmbox->state = OCTEON_MBOX_STATE_IDLE;\n\t\t\twriteq(OCTEON_PFVFSIG, mbox->mbox_read_reg);\n\t\t}\n\n\t\tspin_unlock_irqrestore(&mbox->lock, flags);\n\t\tocteon_mbox_process_cmd(mbox, &mbox_cmd);\n\t\treturn 0;\n\t}\n\n\tspin_unlock_irqrestore(&mbox->lock, flags);\n\tWARN_ON(1);\n\n\treturn 0;\n}\n\nint octeon_mbox_cancel(struct octeon_device *oct, int q_no)\n{\n\tstruct octeon_mbox *mbox = oct->mbox[q_no];\n\tstruct octeon_mbox_cmd *mbox_cmd;\n\tunsigned long flags = 0;\n\n\tspin_lock_irqsave(&mbox->lock, flags);\n\tmbox_cmd = &mbox->mbox_resp;\n\n\tif (!(mbox->state & OCTEON_MBOX_STATE_RESPONSE_PENDING)) {\n\t\tspin_unlock_irqrestore(&mbox->lock, flags);\n\t\treturn 1;\n\t}\n\n\tmbox->state = OCTEON_MBOX_STATE_IDLE;\n\tmemset(mbox_cmd, 0, sizeof(*mbox_cmd));\n\twriteq(OCTEON_PFVFSIG, mbox->mbox_read_reg);\n\tspin_unlock_irqrestore(&mbox->lock, flags);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}