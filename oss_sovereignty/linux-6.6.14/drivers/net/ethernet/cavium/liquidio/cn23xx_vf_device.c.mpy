{
  "module_name": "cn23xx_vf_device.c",
  "hash_id": "e0301996b812d691a53e3c00ac28dea97002f168967508779ea6b53ed1c565df",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/cavium/liquidio/cn23xx_vf_device.c",
  "human_readable_source": " \n#include <linux/pci.h>\n#include <linux/netdevice.h>\n#include <linux/vmalloc.h>\n#include \"liquidio_common.h\"\n#include \"octeon_droq.h\"\n#include \"octeon_iq.h\"\n#include \"response_manager.h\"\n#include \"octeon_device.h\"\n#include \"cn23xx_vf_device.h\"\n#include \"octeon_main.h\"\n#include \"octeon_mailbox.h\"\n\nu32 cn23xx_vf_get_oq_ticks(struct octeon_device *oct, u32 time_intr_in_us)\n{\n\t \n\tu32 oqticks_per_us = (u32)oct->pfvf_hsword.coproc_tics_per_us;\n\n\t \n\toqticks_per_us *= 1000;\n\n\t \n\toqticks_per_us /= 1024;\n\n\t \n\toqticks_per_us *= time_intr_in_us;\n\toqticks_per_us /= 1000;\n\n\treturn oqticks_per_us;\n}\n\nstatic int cn23xx_vf_reset_io_queues(struct octeon_device *oct, u32 num_queues)\n{\n\tu32 loop = BUSY_READING_REG_VF_LOOP_COUNT;\n\tint ret_val = 0;\n\tu32 q_no;\n\tu64 d64;\n\n\tfor (q_no = 0; q_no < num_queues; q_no++) {\n\t\t \n\t\td64 = octeon_read_csr64(oct,\n\t\t\t\t\tCN23XX_VF_SLI_IQ_PKT_CONTROL64(q_no));\n\t\td64 |= CN23XX_PKT_INPUT_CTL_RST;\n\t\tocteon_write_csr64(oct, CN23XX_VF_SLI_IQ_PKT_CONTROL64(q_no),\n\t\t\t\t   d64);\n\t}\n\n\t \n\tfor (q_no = 0; q_no < num_queues; q_no++) {\n\t\tu64 reg_val = octeon_read_csr64(oct,\n\t\t\t\t\tCN23XX_VF_SLI_IQ_PKT_CONTROL64(q_no));\n\t\twhile ((READ_ONCE(reg_val) & CN23XX_PKT_INPUT_CTL_RST) &&\n\t\t       !(READ_ONCE(reg_val) & CN23XX_PKT_INPUT_CTL_QUIET) &&\n\t\t       loop) {\n\t\t\tWRITE_ONCE(reg_val, octeon_read_csr64(\n\t\t\t    oct, CN23XX_VF_SLI_IQ_PKT_CONTROL64(q_no)));\n\t\t\tloop--;\n\t\t}\n\t\tif (!loop) {\n\t\t\tdev_err(&oct->pci_dev->dev,\n\t\t\t\t\"clearing the reset reg failed or setting the quiet reg failed for qno: %u\\n\",\n\t\t\t\tq_no);\n\t\t\treturn -1;\n\t\t}\n\t\tWRITE_ONCE(reg_val, READ_ONCE(reg_val) &\n\t\t\t   ~CN23XX_PKT_INPUT_CTL_RST);\n\t\tocteon_write_csr64(oct, CN23XX_VF_SLI_IQ_PKT_CONTROL64(q_no),\n\t\t\t\t   READ_ONCE(reg_val));\n\n\t\tWRITE_ONCE(reg_val, octeon_read_csr64(\n\t\t    oct, CN23XX_VF_SLI_IQ_PKT_CONTROL64(q_no)));\n\t\tif (READ_ONCE(reg_val) & CN23XX_PKT_INPUT_CTL_RST) {\n\t\t\tdev_err(&oct->pci_dev->dev,\n\t\t\t\t\"clearing the reset failed for qno: %u\\n\",\n\t\t\t\tq_no);\n\t\t\tret_val = -1;\n\t\t}\n\t}\n\n\treturn ret_val;\n}\n\nstatic int cn23xx_vf_setup_global_input_regs(struct octeon_device *oct)\n{\n\tstruct octeon_cn23xx_vf *cn23xx = (struct octeon_cn23xx_vf *)oct->chip;\n\tstruct octeon_instr_queue *iq;\n\tu64 q_no, intr_threshold;\n\tu64 d64;\n\n\tif (cn23xx_vf_reset_io_queues(oct, oct->sriov_info.rings_per_vf))\n\t\treturn -1;\n\n\tfor (q_no = 0; q_no < (oct->sriov_info.rings_per_vf); q_no++) {\n\t\tvoid __iomem *inst_cnt_reg;\n\n\t\tocteon_write_csr64(oct, CN23XX_VF_SLI_IQ_DOORBELL(q_no),\n\t\t\t\t   0xFFFFFFFF);\n\t\tiq = oct->instr_queue[q_no];\n\n\t\tif (iq)\n\t\t\tinst_cnt_reg = iq->inst_cnt_reg;\n\t\telse\n\t\t\tinst_cnt_reg = (u8 *)oct->mmio[0].hw_addr +\n\t\t\t\t       CN23XX_VF_SLI_IQ_INSTR_COUNT64(q_no);\n\n\t\td64 = octeon_read_csr64(oct,\n\t\t\t\t\tCN23XX_VF_SLI_IQ_INSTR_COUNT64(q_no));\n\n\t\td64 &= 0xEFFFFFFFFFFFFFFFL;\n\n\t\tocteon_write_csr64(oct, CN23XX_VF_SLI_IQ_INSTR_COUNT64(q_no),\n\t\t\t\t   d64);\n\n\t\t \n\t\tocteon_write_csr64(oct, CN23XX_VF_SLI_IQ_PKT_CONTROL64(q_no),\n\t\t\t\t   CN23XX_PKT_INPUT_CTL_MASK);\n\n\t\t \n\t\tintr_threshold = CFG_GET_IQ_INTR_PKT(cn23xx->conf) &\n\t\t\t\t CN23XX_PKT_IN_DONE_WMARK_MASK;\n\n\t\twriteq((readq(inst_cnt_reg) &\n\t\t\t~(CN23XX_PKT_IN_DONE_WMARK_MASK <<\n\t\t\t  CN23XX_PKT_IN_DONE_WMARK_BIT_POS)) |\n\t\t       (intr_threshold << CN23XX_PKT_IN_DONE_WMARK_BIT_POS),\n\t\t       inst_cnt_reg);\n\t}\n\treturn 0;\n}\n\nstatic void cn23xx_vf_setup_global_output_regs(struct octeon_device *oct)\n{\n\tu32 reg_val;\n\tu32 q_no;\n\n\tfor (q_no = 0; q_no < (oct->sriov_info.rings_per_vf); q_no++) {\n\t\tocteon_write_csr(oct, CN23XX_VF_SLI_OQ_PKTS_CREDIT(q_no),\n\t\t\t\t 0xFFFFFFFF);\n\n\t\treg_val =\n\t\t    octeon_read_csr(oct, CN23XX_VF_SLI_OQ_PKTS_SENT(q_no));\n\n\t\treg_val &= 0xEFFFFFFFFFFFFFFFL;\n\n\t\treg_val =\n\t\t    octeon_read_csr(oct, CN23XX_VF_SLI_OQ_PKT_CONTROL(q_no));\n\n\t\t \n\t\treg_val &= ~CN23XX_PKT_OUTPUT_CTL_IPTR;\n\n\t\t \n\t\treg_val |= CN23XX_PKT_OUTPUT_CTL_DPTR;\n\n\t\t \n\t\treg_val &= ~(CN23XX_PKT_OUTPUT_CTL_BMODE);\n\n\t\t \n\t\treg_val &= ~(CN23XX_PKT_OUTPUT_CTL_ROR_P);\n\t\treg_val &= ~(CN23XX_PKT_OUTPUT_CTL_NSR_P);\n\n#ifdef __LITTLE_ENDIAN_BITFIELD\n\t\treg_val &= ~(CN23XX_PKT_OUTPUT_CTL_ES_P);\n#else\n\t\treg_val |= (CN23XX_PKT_OUTPUT_CTL_ES_P);\n#endif\n\t\t \n\t\treg_val &= ~(CN23XX_PKT_OUTPUT_CTL_ROR);\n\t\treg_val &= ~(CN23XX_PKT_OUTPUT_CTL_NSR);\n\t\t \n\t\treg_val |= (CN23XX_PKT_OUTPUT_CTL_ES);\n\n\t\t \n\t\tocteon_write_csr(oct, CN23XX_VF_SLI_OQ_PKT_CONTROL(q_no),\n\t\t\t\t reg_val);\n\t}\n}\n\nstatic int cn23xx_setup_vf_device_regs(struct octeon_device *oct)\n{\n\tif (cn23xx_vf_setup_global_input_regs(oct))\n\t\treturn -1;\n\n\tcn23xx_vf_setup_global_output_regs(oct);\n\n\treturn 0;\n}\n\nstatic void cn23xx_setup_vf_iq_regs(struct octeon_device *oct, u32 iq_no)\n{\n\tstruct octeon_instr_queue *iq = oct->instr_queue[iq_no];\n\tu64 pkt_in_done;\n\n\t \n\tocteon_write_csr64(oct, CN23XX_VF_SLI_IQ_BASE_ADDR64(iq_no),\n\t\t\t   iq->base_addr_dma);\n\tocteon_write_csr(oct, CN23XX_VF_SLI_IQ_SIZE(iq_no), iq->max_count);\n\n\t \n\tiq->doorbell_reg =\n\t    (u8 *)oct->mmio[0].hw_addr + CN23XX_VF_SLI_IQ_DOORBELL(iq_no);\n\tiq->inst_cnt_reg =\n\t    (u8 *)oct->mmio[0].hw_addr + CN23XX_VF_SLI_IQ_INSTR_COUNT64(iq_no);\n\tdev_dbg(&oct->pci_dev->dev, \"InstQ[%d]:dbell reg @ 0x%p instcnt_reg @ 0x%p\\n\",\n\t\tiq_no, iq->doorbell_reg, iq->inst_cnt_reg);\n\n\t \n\tpkt_in_done = readq(iq->inst_cnt_reg);\n\n\tif (oct->msix_on) {\n\t\t \n\t\twriteq((pkt_in_done | CN23XX_INTR_CINT_ENB),\n\t\t       iq->inst_cnt_reg);\n\t}\n\tiq->reset_instr_cnt = 0;\n}\n\nstatic void cn23xx_setup_vf_oq_regs(struct octeon_device *oct, u32 oq_no)\n{\n\tstruct octeon_droq *droq = oct->droq[oq_no];\n\n\tocteon_write_csr64(oct, CN23XX_VF_SLI_OQ_BASE_ADDR64(oq_no),\n\t\t\t   droq->desc_ring_dma);\n\tocteon_write_csr(oct, CN23XX_VF_SLI_OQ_SIZE(oq_no), droq->max_count);\n\n\tocteon_write_csr(oct, CN23XX_VF_SLI_OQ_BUFF_INFO_SIZE(oq_no),\n\t\t\t droq->buffer_size);\n\n\t \n\tdroq->pkts_sent_reg =\n\t    (u8 *)oct->mmio[0].hw_addr + CN23XX_VF_SLI_OQ_PKTS_SENT(oq_no);\n\tdroq->pkts_credit_reg =\n\t    (u8 *)oct->mmio[0].hw_addr + CN23XX_VF_SLI_OQ_PKTS_CREDIT(oq_no);\n}\n\nstatic void cn23xx_vf_mbox_thread(struct work_struct *work)\n{\n\tstruct cavium_wk *wk = (struct cavium_wk *)work;\n\tstruct octeon_mbox *mbox = (struct octeon_mbox *)wk->ctxptr;\n\n\tocteon_mbox_process_message(mbox);\n}\n\nstatic int cn23xx_free_vf_mbox(struct octeon_device *oct)\n{\n\tcancel_delayed_work_sync(&oct->mbox[0]->mbox_poll_wk.work);\n\tvfree(oct->mbox[0]);\n\treturn 0;\n}\n\nstatic int cn23xx_setup_vf_mbox(struct octeon_device *oct)\n{\n\tstruct octeon_mbox *mbox = NULL;\n\n\tmbox = vzalloc(sizeof(*mbox));\n\tif (!mbox)\n\t\treturn 1;\n\n\tspin_lock_init(&mbox->lock);\n\n\tmbox->oct_dev = oct;\n\n\tmbox->q_no = 0;\n\n\tmbox->state = OCTEON_MBOX_STATE_IDLE;\n\n\t \n\tmbox->mbox_int_reg =\n\t    (u8 *)oct->mmio[0].hw_addr + CN23XX_VF_SLI_PKT_MBOX_INT(0);\n\t \n\tmbox->mbox_read_reg =\n\t    (u8 *)oct->mmio[0].hw_addr + CN23XX_SLI_PKT_PF_VF_MBOX_SIG(0, 0);\n\t \n\tmbox->mbox_write_reg =\n\t    (u8 *)oct->mmio[0].hw_addr + CN23XX_SLI_PKT_PF_VF_MBOX_SIG(0, 1);\n\n\tINIT_DELAYED_WORK(&mbox->mbox_poll_wk.work,\n\t\t\t  cn23xx_vf_mbox_thread);\n\n\tmbox->mbox_poll_wk.ctxptr = mbox;\n\n\toct->mbox[0] = mbox;\n\n\twriteq(OCTEON_PFVFSIG, mbox->mbox_read_reg);\n\n\treturn 0;\n}\n\nstatic int cn23xx_enable_vf_io_queues(struct octeon_device *oct)\n{\n\tu32 q_no;\n\n\tfor (q_no = 0; q_no < oct->num_iqs; q_no++) {\n\t\tu64 reg_val;\n\n\t\t \n\t\tif (oct->io_qmask.iq64B & BIT_ULL(q_no)) {\n\t\t\treg_val = octeon_read_csr64(\n\t\t\t    oct, CN23XX_VF_SLI_IQ_PKT_CONTROL64(q_no));\n\t\t\treg_val |= CN23XX_PKT_INPUT_CTL_IS_64B;\n\t\t\tocteon_write_csr64(\n\t\t\t    oct, CN23XX_VF_SLI_IQ_PKT_CONTROL64(q_no), reg_val);\n\t\t}\n\n\t\t \n\t\tif (oct->io_qmask.iq & BIT_ULL(q_no)) {\n\t\t\treg_val = octeon_read_csr64(\n\t\t\t    oct, CN23XX_VF_SLI_IQ_PKT_CONTROL64(q_no));\n\t\t\treg_val |= CN23XX_PKT_INPUT_CTL_RING_ENB;\n\t\t\tocteon_write_csr64(\n\t\t\t    oct, CN23XX_VF_SLI_IQ_PKT_CONTROL64(q_no), reg_val);\n\t\t}\n\t}\n\tfor (q_no = 0; q_no < oct->num_oqs; q_no++) {\n\t\tu32 reg_val;\n\n\t\t \n\t\tif (oct->io_qmask.oq & BIT_ULL(q_no)) {\n\t\t\treg_val = octeon_read_csr(\n\t\t\t    oct, CN23XX_VF_SLI_OQ_PKT_CONTROL(q_no));\n\t\t\treg_val |= CN23XX_PKT_OUTPUT_CTL_RING_ENB;\n\t\t\tocteon_write_csr(\n\t\t\t    oct, CN23XX_VF_SLI_OQ_PKT_CONTROL(q_no), reg_val);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void cn23xx_disable_vf_io_queues(struct octeon_device *oct)\n{\n\tu32 num_queues = oct->num_iqs;\n\n\t \n\tif (num_queues < oct->num_oqs)\n\t\tnum_queues = oct->num_oqs;\n\n\tcn23xx_vf_reset_io_queues(oct, num_queues);\n}\n\nvoid cn23xx_vf_ask_pf_to_do_flr(struct octeon_device *oct)\n{\n\tstruct octeon_mbox_cmd mbox_cmd;\n\n\tmbox_cmd.msg.u64 = 0;\n\tmbox_cmd.msg.s.type = OCTEON_MBOX_REQUEST;\n\tmbox_cmd.msg.s.resp_needed = 0;\n\tmbox_cmd.msg.s.cmd = OCTEON_VF_FLR_REQUEST;\n\tmbox_cmd.msg.s.len = 1;\n\tmbox_cmd.q_no = 0;\n\tmbox_cmd.recv_len = 0;\n\tmbox_cmd.recv_status = 0;\n\tmbox_cmd.fn = NULL;\n\tmbox_cmd.fn_arg = NULL;\n\n\tocteon_mbox_write(oct, &mbox_cmd);\n}\nEXPORT_SYMBOL_GPL(cn23xx_vf_ask_pf_to_do_flr);\n\nstatic void octeon_pfvf_hs_callback(struct octeon_device *oct,\n\t\t\t\t    struct octeon_mbox_cmd *cmd,\n\t\t\t\t    void *arg)\n{\n\tu32 major = 0;\n\n\tmemcpy((uint8_t *)&oct->pfvf_hsword, cmd->msg.s.params,\n\t       CN23XX_MAILBOX_MSGPARAM_SIZE);\n\tif (cmd->recv_len > 1)  {\n\t\tmajor = ((struct lio_version *)(cmd->data))->major;\n\t\tmajor = major << 16;\n\t}\n\n\tatomic_set((atomic_t *)arg, major | 1);\n}\n\nint cn23xx_octeon_pfvf_handshake(struct octeon_device *oct)\n{\n\tstruct octeon_mbox_cmd mbox_cmd;\n\tu32 q_no, count = 0;\n\tatomic_t status;\n\tu32 pfmajor;\n\tu32 vfmajor;\n\tu32 ret;\n\n\t \n\tdev_dbg(&oct->pci_dev->dev, \"requesting info from pf\\n\");\n\n\tmbox_cmd.msg.u64 = 0;\n\tmbox_cmd.msg.s.type = OCTEON_MBOX_REQUEST;\n\tmbox_cmd.msg.s.resp_needed = 1;\n\tmbox_cmd.msg.s.cmd = OCTEON_VF_ACTIVE;\n\tmbox_cmd.msg.s.len = 2;\n\tmbox_cmd.data[0] = 0;\n\t((struct lio_version *)&mbox_cmd.data[0])->major =\n\t\t\t\t\t\tLIQUIDIO_BASE_MAJOR_VERSION;\n\t((struct lio_version *)&mbox_cmd.data[0])->minor =\n\t\t\t\t\t\tLIQUIDIO_BASE_MINOR_VERSION;\n\t((struct lio_version *)&mbox_cmd.data[0])->micro =\n\t\t\t\t\t\tLIQUIDIO_BASE_MICRO_VERSION;\n\tmbox_cmd.q_no = 0;\n\tmbox_cmd.recv_len = 0;\n\tmbox_cmd.recv_status = 0;\n\tmbox_cmd.fn = (octeon_mbox_callback_t)octeon_pfvf_hs_callback;\n\tmbox_cmd.fn_arg = &status;\n\n\tocteon_mbox_write(oct, &mbox_cmd);\n\n\tatomic_set(&status, 0);\n\n\tdo {\n\t\tschedule_timeout_uninterruptible(1);\n\t} while ((!atomic_read(&status)) && (count++ < 100000));\n\n\tret = atomic_read(&status);\n\tif (!ret) {\n\t\tdev_err(&oct->pci_dev->dev, \"octeon_pfvf_handshake timeout\\n\");\n\t\treturn 1;\n\t}\n\n\tfor (q_no = 0 ; q_no < oct->num_iqs ; q_no++)\n\t\toct->instr_queue[q_no]->txpciq.s.pkind = oct->pfvf_hsword.pkind;\n\n\tvfmajor = LIQUIDIO_BASE_MAJOR_VERSION;\n\tpfmajor = ret >> 16;\n\tif (pfmajor != vfmajor) {\n\t\tdev_err(&oct->pci_dev->dev,\n\t\t\t\"VF Liquidio driver (major version %d) is not compatible with Liquidio PF driver (major version %d)\\n\",\n\t\t\tvfmajor, pfmajor);\n\t\treturn 1;\n\t}\n\n\tdev_dbg(&oct->pci_dev->dev,\n\t\t\"VF Liquidio driver (major version %d), Liquidio PF driver (major version %d)\\n\",\n\t\tvfmajor, pfmajor);\n\n\tdev_dbg(&oct->pci_dev->dev, \"got data from pf pkind is %d\\n\",\n\t\toct->pfvf_hsword.pkind);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(cn23xx_octeon_pfvf_handshake);\n\nstatic void cn23xx_handle_vf_mbox_intr(struct octeon_ioq_vector *ioq_vector)\n{\n\tstruct octeon_device *oct = ioq_vector->oct_dev;\n\tu64 mbox_int_val;\n\n\tif (!ioq_vector->droq_index) {\n\t\t \n\t\tmbox_int_val = readq(oct->mbox[0]->mbox_int_reg);\n\t\twriteq(mbox_int_val, oct->mbox[0]->mbox_int_reg);\n\t\tif (octeon_mbox_read(oct->mbox[0]))\n\t\t\tschedule_delayed_work(&oct->mbox[0]->mbox_poll_wk.work,\n\t\t\t\t\t      msecs_to_jiffies(0));\n\t}\n}\n\nstatic u64 cn23xx_vf_msix_interrupt_handler(void *dev)\n{\n\tstruct octeon_ioq_vector *ioq_vector = (struct octeon_ioq_vector *)dev;\n\tstruct octeon_device *oct = ioq_vector->oct_dev;\n\tstruct octeon_droq *droq = oct->droq[ioq_vector->droq_index];\n\tu64 pkts_sent;\n\tu64 ret = 0;\n\n\tdev_dbg(&oct->pci_dev->dev, \"In %s octeon_dev @ %p\\n\", __func__, oct);\n\tpkts_sent = readq(droq->pkts_sent_reg);\n\n\t \n\tif (!pkts_sent || (pkts_sent == 0xFFFFFFFFFFFFFFFFULL))\n\t\treturn ret;\n\n\t \n\tif ((pkts_sent & CN23XX_INTR_PO_INT) ||\n\t    (pkts_sent & CN23XX_INTR_PI_INT)) {\n\t\tif (pkts_sent & CN23XX_INTR_PO_INT)\n\t\t\tret |= MSIX_PO_INT;\n\t}\n\n\tif (pkts_sent & CN23XX_INTR_PI_INT)\n\t\t \n\t\tret |= MSIX_PI_INT;\n\n\tif (pkts_sent & CN23XX_INTR_MBOX_INT) {\n\t\tcn23xx_handle_vf_mbox_intr(ioq_vector);\n\t\tret |= MSIX_MBOX_INT;\n\t}\n\n\treturn ret;\n}\n\nstatic u32 cn23xx_update_read_index(struct octeon_instr_queue *iq)\n{\n\tu32 pkt_in_done = readl(iq->inst_cnt_reg);\n\tu32 last_done;\n\tu32 new_idx;\n\n\tlast_done = pkt_in_done - iq->pkt_in_done;\n\tiq->pkt_in_done = pkt_in_done;\n\n\t \n\tnew_idx = (iq->octeon_read_index +\n\t\t   (u32)(last_done & CN23XX_PKT_IN_DONE_CNT_MASK)) %\n\t\t  iq->max_count;\n\n\treturn new_idx;\n}\n\nstatic void cn23xx_enable_vf_interrupt(struct octeon_device *oct, u8 intr_flag)\n{\n\tstruct octeon_cn23xx_vf *cn23xx = (struct octeon_cn23xx_vf *)oct->chip;\n\tu32 q_no, time_threshold;\n\n\tif (intr_flag & OCTEON_OUTPUT_INTR) {\n\t\tfor (q_no = 0; q_no < oct->num_oqs; q_no++) {\n\t\t\t \n\t\t\ttime_threshold = cn23xx_vf_get_oq_ticks(\n\t\t\t\toct, (u32)CFG_GET_OQ_INTR_TIME(cn23xx->conf));\n\n\t\t\tocteon_write_csr64(\n\t\t\t    oct, CN23XX_VF_SLI_OQ_PKT_INT_LEVELS(q_no),\n\t\t\t    (CFG_GET_OQ_INTR_PKT(cn23xx->conf) |\n\t\t\t     ((u64)time_threshold << 32)));\n\t\t}\n\t}\n\n\tif (intr_flag & OCTEON_INPUT_INTR) {\n\t\tfor (q_no = 0; q_no < oct->num_oqs; q_no++) {\n\t\t\t \n\t\t\tocteon_write_csr64(\n\t\t\t    oct, CN23XX_VF_SLI_IQ_INSTR_COUNT64(q_no),\n\t\t\t    ((octeon_read_csr64(\n\t\t\t\t  oct, CN23XX_VF_SLI_IQ_INSTR_COUNT64(q_no)) &\n\t\t\t      ~CN23XX_PKT_IN_DONE_CNT_MASK) |\n\t\t\t     CN23XX_INTR_CINT_ENB));\n\t\t}\n\t}\n\n\t \n\tif (intr_flag & OCTEON_MBOX_INTR) {\n\t\tocteon_write_csr64(\n\t\t    oct, CN23XX_VF_SLI_PKT_MBOX_INT(0),\n\t\t    (octeon_read_csr64(oct, CN23XX_VF_SLI_PKT_MBOX_INT(0)) |\n\t\t     CN23XX_INTR_MBOX_ENB));\n\t}\n}\n\nstatic void cn23xx_disable_vf_interrupt(struct octeon_device *oct, u8 intr_flag)\n{\n\tu32 q_no;\n\n\tif (intr_flag & OCTEON_OUTPUT_INTR) {\n\t\tfor (q_no = 0; q_no < oct->num_oqs; q_no++) {\n\t\t\t \n\t\t\tocteon_write_csr64(\n\t\t\t    oct, CN23XX_VF_SLI_OQ_PKT_INT_LEVELS(q_no),\n\t\t\t    0x3fffffffffffff);\n\t\t}\n\t}\n\tif (intr_flag & OCTEON_INPUT_INTR) {\n\t\tfor (q_no = 0; q_no < oct->num_oqs; q_no++) {\n\t\t\tocteon_write_csr64(\n\t\t\t    oct, CN23XX_VF_SLI_IQ_INSTR_COUNT64(q_no),\n\t\t\t    (octeon_read_csr64(\n\t\t\t\t oct, CN23XX_VF_SLI_IQ_INSTR_COUNT64(q_no)) &\n\t\t\t     ~(CN23XX_INTR_CINT_ENB |\n\t\t\t       CN23XX_PKT_IN_DONE_CNT_MASK)));\n\t\t}\n\t}\n\n\tif (intr_flag & OCTEON_MBOX_INTR) {\n\t\tocteon_write_csr64(\n\t\t    oct, CN23XX_VF_SLI_PKT_MBOX_INT(0),\n\t\t    (octeon_read_csr64(oct, CN23XX_VF_SLI_PKT_MBOX_INT(0)) &\n\t\t     ~CN23XX_INTR_MBOX_ENB));\n\t}\n}\n\nint cn23xx_setup_octeon_vf_device(struct octeon_device *oct)\n{\n\tstruct octeon_cn23xx_vf *cn23xx = (struct octeon_cn23xx_vf *)oct->chip;\n\tu32 rings_per_vf;\n\tu64 reg_val;\n\n\tif (octeon_map_pci_barx(oct, 0, 0))\n\t\treturn 1;\n\n\t \n\treg_val = octeon_read_csr64(oct, CN23XX_VF_SLI_IQ_PKT_CONTROL64(0));\n\n\toct->pf_num = (reg_val >> CN23XX_PKT_INPUT_CTL_PF_NUM_POS) &\n\t\t      CN23XX_PKT_INPUT_CTL_PF_NUM_MASK;\n\toct->vf_num = (reg_val >> CN23XX_PKT_INPUT_CTL_VF_NUM_POS) &\n\t\t      CN23XX_PKT_INPUT_CTL_VF_NUM_MASK;\n\n\treg_val = reg_val >> CN23XX_PKT_INPUT_CTL_RPVF_POS;\n\n\trings_per_vf = reg_val & CN23XX_PKT_INPUT_CTL_RPVF_MASK;\n\n\tcn23xx->conf  = oct_get_config_info(oct, LIO_23XX);\n\tif (!cn23xx->conf) {\n\t\tdev_err(&oct->pci_dev->dev, \"%s No Config found for CN23XX\\n\",\n\t\t\t__func__);\n\t\tocteon_unmap_pci_barx(oct, 0);\n\t\treturn 1;\n\t}\n\n\tif (oct->sriov_info.rings_per_vf > rings_per_vf) {\n\t\tdev_warn(&oct->pci_dev->dev,\n\t\t\t \"num_queues:%d greater than PF configured rings_per_vf:%d. Reducing to %d.\\n\",\n\t\t\t oct->sriov_info.rings_per_vf, rings_per_vf,\n\t\t\t rings_per_vf);\n\t\toct->sriov_info.rings_per_vf = rings_per_vf;\n\t} else {\n\t\tif (rings_per_vf > num_present_cpus()) {\n\t\t\tdev_warn(&oct->pci_dev->dev,\n\t\t\t\t \"PF configured rings_per_vf:%d greater than num_cpu:%d. Using rings_per_vf:%d equal to num cpus\\n\",\n\t\t\t\t rings_per_vf,\n\t\t\t\t num_present_cpus(),\n\t\t\t\t num_present_cpus());\n\t\t\toct->sriov_info.rings_per_vf =\n\t\t\t\tnum_present_cpus();\n\t\t} else {\n\t\t\toct->sriov_info.rings_per_vf = rings_per_vf;\n\t\t}\n\t}\n\n\toct->fn_list.setup_iq_regs = cn23xx_setup_vf_iq_regs;\n\toct->fn_list.setup_oq_regs = cn23xx_setup_vf_oq_regs;\n\toct->fn_list.setup_mbox = cn23xx_setup_vf_mbox;\n\toct->fn_list.free_mbox = cn23xx_free_vf_mbox;\n\n\toct->fn_list.msix_interrupt_handler = cn23xx_vf_msix_interrupt_handler;\n\n\toct->fn_list.setup_device_regs = cn23xx_setup_vf_device_regs;\n\toct->fn_list.update_iq_read_idx = cn23xx_update_read_index;\n\n\toct->fn_list.enable_interrupt = cn23xx_enable_vf_interrupt;\n\toct->fn_list.disable_interrupt = cn23xx_disable_vf_interrupt;\n\n\toct->fn_list.enable_io_queues = cn23xx_enable_vf_io_queues;\n\toct->fn_list.disable_io_queues = cn23xx_disable_vf_io_queues;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(cn23xx_setup_octeon_vf_device);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}