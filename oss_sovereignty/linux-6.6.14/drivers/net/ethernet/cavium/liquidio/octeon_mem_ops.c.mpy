{
  "module_name": "octeon_mem_ops.c",
  "hash_id": "5363999ad21abc546a35628589350bc57675760205f4a121bbe90ab6e94365e1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/cavium/liquidio/octeon_mem_ops.c",
  "human_readable_source": " \n#include <linux/netdevice.h>\n#include \"liquidio_common.h\"\n#include \"octeon_droq.h\"\n#include \"octeon_iq.h\"\n#include \"response_manager.h\"\n#include \"octeon_device.h\"\n#include \"octeon_mem_ops.h\"\n\n#define MEMOPS_IDX   BAR1_INDEX_DYNAMIC_MAP\n\n#ifdef __BIG_ENDIAN_BITFIELD\nstatic inline void\nocteon_toggle_bar1_swapmode(struct octeon_device *oct, u32 idx)\n{\n\tu32 mask;\n\n\tmask = oct->fn_list.bar1_idx_read(oct, idx);\n\tmask = (mask & 0x2) ? (mask & ~2) : (mask | 2);\n\toct->fn_list.bar1_idx_write(oct, idx, mask);\n}\n#else\n#define octeon_toggle_bar1_swapmode(oct, idx)\n#endif\n\nstatic void\nocteon_pci_fastwrite(struct octeon_device *oct, u8 __iomem *mapped_addr,\n\t\t     u8 *hostbuf, u32 len)\n{\n\twhile ((len) && ((unsigned long)mapped_addr) & 7) {\n\t\twriteb(*(hostbuf++), mapped_addr++);\n\t\tlen--;\n\t}\n\n\tocteon_toggle_bar1_swapmode(oct, MEMOPS_IDX);\n\n\twhile (len >= 8) {\n\t\twriteq(*((u64 *)hostbuf), mapped_addr);\n\t\tmapped_addr += 8;\n\t\thostbuf += 8;\n\t\tlen -= 8;\n\t}\n\n\tocteon_toggle_bar1_swapmode(oct, MEMOPS_IDX);\n\n\twhile (len--)\n\t\twriteb(*(hostbuf++), mapped_addr++);\n}\n\nstatic void\nocteon_pci_fastread(struct octeon_device *oct, u8 __iomem *mapped_addr,\n\t\t    u8 *hostbuf, u32 len)\n{\n\twhile ((len) && ((unsigned long)mapped_addr) & 7) {\n\t\t*(hostbuf++) = readb(mapped_addr++);\n\t\tlen--;\n\t}\n\n\tocteon_toggle_bar1_swapmode(oct, MEMOPS_IDX);\n\n\twhile (len >= 8) {\n\t\t*((u64 *)hostbuf) = readq(mapped_addr);\n\t\tmapped_addr += 8;\n\t\thostbuf += 8;\n\t\tlen -= 8;\n\t}\n\n\tocteon_toggle_bar1_swapmode(oct, MEMOPS_IDX);\n\n\twhile (len--)\n\t\t*(hostbuf++) = readb(mapped_addr++);\n}\n\n \n \nstatic void\n__octeon_pci_rw_core_mem(struct octeon_device *oct, u64 addr,\n\t\t\t u8 *hostbuf, u32 len, u32 op)\n{\n\tu32 copy_len = 0, index_reg_val = 0;\n\tunsigned long flags;\n\tu8 __iomem *mapped_addr;\n\tu64 static_mapping_base;\n\n\tstatic_mapping_base = oct->console_nb_info.dram_region_base;\n\n\tif (static_mapping_base &&\n\t    static_mapping_base == (addr & ~(OCTEON_BAR1_ENTRY_SIZE - 1ULL))) {\n\t\tint bar1_index = oct->console_nb_info.bar1_index;\n\n\t\tmapped_addr = oct->mmio[1].hw_addr\n\t\t\t+ (bar1_index << ilog2(OCTEON_BAR1_ENTRY_SIZE))\n\t\t\t+ (addr & (OCTEON_BAR1_ENTRY_SIZE - 1ULL));\n\n\t\tif (op)\n\t\t\tocteon_pci_fastread(oct, mapped_addr, hostbuf, len);\n\t\telse\n\t\t\tocteon_pci_fastwrite(oct, mapped_addr, hostbuf, len);\n\n\t\treturn;\n\t}\n\n\tspin_lock_irqsave(&oct->mem_access_lock, flags);\n\n\t \n\tindex_reg_val = oct->fn_list.bar1_idx_read(oct, MEMOPS_IDX);\n\tdo {\n\t\toct->fn_list.bar1_idx_setup(oct, addr, MEMOPS_IDX, 1);\n\t\tmapped_addr = oct->mmio[1].hw_addr\n\t\t    + (MEMOPS_IDX << 22) + (addr & 0x3fffff);\n\n\t\t \n\t\tif (((addr + len - 1) & ~(0x3fffff)) != (addr & ~(0x3fffff))) {\n\t\t\tcopy_len = (u32)(((addr & ~(0x3fffff)) +\n\t\t\t\t   (MEMOPS_IDX << 22)) - addr);\n\t\t} else {\n\t\t\tcopy_len = len;\n\t\t}\n\n\t\tif (op) {\t \n\t\t\tocteon_pci_fastread(oct, mapped_addr, hostbuf,\n\t\t\t\t\t    copy_len);\n\t\t} else {\n\t\t\tocteon_pci_fastwrite(oct, mapped_addr, hostbuf,\n\t\t\t\t\t     copy_len);\n\t\t}\n\n\t\tlen -= copy_len;\n\t\taddr += copy_len;\n\t\thostbuf += copy_len;\n\n\t} while (len);\n\n\toct->fn_list.bar1_idx_write(oct, MEMOPS_IDX, index_reg_val);\n\n\tspin_unlock_irqrestore(&oct->mem_access_lock, flags);\n}\n\nvoid\nocteon_pci_read_core_mem(struct octeon_device *oct,\n\t\t\t u64 coreaddr,\n\t\t\t u8 *buf,\n\t\t\t u32 len)\n{\n\t__octeon_pci_rw_core_mem(oct, coreaddr, buf, len, 1);\n}\nEXPORT_SYMBOL_GPL(octeon_pci_read_core_mem);\n\nvoid\nocteon_pci_write_core_mem(struct octeon_device *oct,\n\t\t\t  u64 coreaddr,\n\t\t\t  const u8 *buf,\n\t\t\t  u32 len)\n{\n\t__octeon_pci_rw_core_mem(oct, coreaddr, (u8 *)buf, len, 0);\n}\nEXPORT_SYMBOL_GPL(octeon_pci_write_core_mem);\n\nu64 octeon_read_device_mem64(struct octeon_device *oct, u64 coreaddr)\n{\n\t__be64 ret;\n\n\t__octeon_pci_rw_core_mem(oct, coreaddr, (u8 *)&ret, 8, 1);\n\n\treturn be64_to_cpu(ret);\n}\nEXPORT_SYMBOL_GPL(octeon_read_device_mem64);\n\nu32 octeon_read_device_mem32(struct octeon_device *oct, u64 coreaddr)\n{\n\t__be32 ret;\n\n\t__octeon_pci_rw_core_mem(oct, coreaddr, (u8 *)&ret, 4, 1);\n\n\treturn be32_to_cpu(ret);\n}\nEXPORT_SYMBOL_GPL(octeon_read_device_mem32);\n\nvoid octeon_write_device_mem32(struct octeon_device *oct, u64 coreaddr,\n\t\t\t       u32 val)\n{\n\t__be32 t = cpu_to_be32(val);\n\n\t__octeon_pci_rw_core_mem(oct, coreaddr, (u8 *)&t, 4, 0);\n}\nEXPORT_SYMBOL_GPL(octeon_write_device_mem32);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}