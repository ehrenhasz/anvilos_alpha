{
  "module_name": "octeon_device.h",
  "hash_id": "dc8969ed7d2ee4bc9ba9cab223156b2ab93c3483c2405192b9aba8918da35c8f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/cavium/liquidio/octeon_device.h",
  "human_readable_source": " \n \n\n#ifndef _OCTEON_DEVICE_H_\n#define  _OCTEON_DEVICE_H_\n\n#include <linux/interrupt.h>\n#include <net/devlink.h>\n\n \n#define  OCTEON_CN68XX_PCIID          0x91177d\n#define  OCTEON_CN66XX_PCIID          0x92177d\n#define  OCTEON_CN23XX_PCIID_PF       0x9702177d\n \n#define  OCTEON_CN68XX                0x0091\n#define  OCTEON_CN66XX                0x0092\n#define  OCTEON_CN23XX_PF_VID         0x9702\n#define  OCTEON_CN23XX_VF_VID         0x9712\n\n \n#define  OCTEON_CN23XX_REV_1_0        0x00\n#define  OCTEON_CN23XX_REV_1_1        0x01\n#define  OCTEON_CN23XX_REV_2_0        0x80\n\n \n#define\t OCTEON_CN2350_10GB_SUBSYS_ID_1\t0X3177d\n#define\t OCTEON_CN2350_10GB_SUBSYS_ID_2\t0X4177d\n#define\t OCTEON_CN2360_10GB_SUBSYS_ID\t0X5177d\n#define\t OCTEON_CN2350_25GB_SUBSYS_ID\t0X7177d\n#define\t OCTEON_CN2360_25GB_SUBSYS_ID\t0X6177d\n\n \nenum octeon_pci_swap_mode {\n\tOCTEON_PCI_PASSTHROUGH = 0,\n\tOCTEON_PCI_64BIT_SWAP = 1,\n\tOCTEON_PCI_32BIT_BYTE_SWAP = 2,\n\tOCTEON_PCI_32BIT_LW_SWAP = 3\n};\n\nenum lio_fw_state {\n\tFW_IS_PRELOADED = 0,\n\tFW_NEEDS_TO_BE_LOADED = 1,\n\tFW_IS_BEING_LOADED = 2,\n\tFW_HAS_BEEN_LOADED = 3,\n};\n\nenum {\n\tOCTEON_CONFIG_TYPE_DEFAULT = 0,\n\tNUM_OCTEON_CONFS,\n};\n\n#define  OCTEON_INPUT_INTR    (1)\n#define  OCTEON_OUTPUT_INTR   (2)\n#define  OCTEON_MBOX_INTR     (4)\n#define  OCTEON_ALL_INTR      0xff\n\n \n\n \n#define    PCI_BAR1_ENABLE_CA            1\n#define    PCI_BAR1_ENDIAN_MODE          OCTEON_PCI_64BIT_SWAP\n#define    PCI_BAR1_ENTRY_VALID          1\n#define    PCI_BAR1_MASK                 ((PCI_BAR1_ENABLE_CA << 3)   \\\n\t\t\t\t\t    | (PCI_BAR1_ENDIAN_MODE << 1) \\\n\t\t\t\t\t    | PCI_BAR1_ENTRY_VALID)\n\n \n#define    OCT_DEV_BEGIN_STATE            0x0\n#define    OCT_DEV_PCI_ENABLE_DONE        0x1\n#define    OCT_DEV_PCI_MAP_DONE           0x2\n#define    OCT_DEV_DISPATCH_INIT_DONE     0x3\n#define    OCT_DEV_INSTR_QUEUE_INIT_DONE  0x4\n#define    OCT_DEV_SC_BUFF_POOL_INIT_DONE 0x5\n#define    OCT_DEV_RESP_LIST_INIT_DONE    0x6\n#define    OCT_DEV_DROQ_INIT_DONE         0x7\n#define    OCT_DEV_MBOX_SETUP_DONE        0x8\n#define    OCT_DEV_MSIX_ALLOC_VECTOR_DONE 0x9\n#define    OCT_DEV_INTR_SET_DONE          0xa\n#define    OCT_DEV_IO_QUEUES_DONE         0xb\n#define    OCT_DEV_CONSOLE_INIT_DONE      0xc\n#define    OCT_DEV_HOST_OK                0xd\n#define    OCT_DEV_CORE_OK                0xe\n#define    OCT_DEV_RUNNING                0xf\n#define    OCT_DEV_IN_RESET               0x10\n#define    OCT_DEV_STATE_INVALID          0x11\n\n#define    OCT_DEV_STATES                 OCT_DEV_STATE_INVALID\n\n \n#define\t   OCT_DEV_INTR_DMA0_FORCE\t  0x01\n#define\t   OCT_DEV_INTR_DMA1_FORCE\t  0x02\n#define\t   OCT_DEV_INTR_PKT_DATA\t  0x04\n\n#define LIO_RESET_SECS (3)\n\n \n\n \nstruct octeon_dispatch {\n\t \n\tstruct list_head list;\n\n\t \n\tu16 opcode;\n\n\t \n\tocteon_dispatch_fn_t dispatch_fn;\n\n\t \n\tvoid *arg;\n};\n\n \nstruct octeon_dispatch_list {\n\t \n\tspinlock_t lock;\n\n\t \n\tu32 count;\n\n\t \n\tstruct octeon_dispatch *dlist;\n};\n\n \n\n#define OCT_MEM_REGIONS     3\n \nstruct octeon_mmio {\n\t \n\tu64 start;\n\n\t \n\tu32 len;\n\n\t \n\tu32 mapped_len;\n\n\t \n\tu8 __iomem *hw_addr;\n\n\t \n\tu32 done;\n};\n\n#define   MAX_OCTEON_MAPS    32\n\nstruct octeon_io_enable {\n\tu64 iq;\n\tu64 oq;\n\tu64 iq64B;\n};\n\nstruct octeon_reg_list {\n\tu32 __iomem *pci_win_wr_addr_hi;\n\tu32 __iomem *pci_win_wr_addr_lo;\n\tu64 __iomem *pci_win_wr_addr;\n\n\tu32 __iomem *pci_win_rd_addr_hi;\n\tu32 __iomem *pci_win_rd_addr_lo;\n\tu64 __iomem *pci_win_rd_addr;\n\n\tu32 __iomem *pci_win_wr_data_hi;\n\tu32 __iomem *pci_win_wr_data_lo;\n\tu64 __iomem *pci_win_wr_data;\n\n\tu32 __iomem *pci_win_rd_data_hi;\n\tu32 __iomem *pci_win_rd_data_lo;\n\tu64 __iomem *pci_win_rd_data;\n};\n\n#define OCTEON_CONSOLE_MAX_READ_BYTES 512\ntypedef int (*octeon_console_print_fn)(struct octeon_device *oct,\n\t\t\t\t       u32 num, char *pre, char *suf);\nstruct octeon_console {\n\tu32 active;\n\tu32 waiting;\n\tu64 addr;\n\tu32 buffer_size;\n\tu64 input_base_addr;\n\tu64 output_base_addr;\n\tocteon_console_print_fn print;\n\tchar leftover[OCTEON_CONSOLE_MAX_READ_BYTES];\n};\n\nstruct octeon_board_info {\n\tchar name[OCT_BOARD_NAME];\n\tchar serial_number[OCT_SERIAL_LEN];\n\tu64 major;\n\tu64 minor;\n};\n\nstruct octeon_fn_list {\n\tvoid (*setup_iq_regs)(struct octeon_device *, u32);\n\tvoid (*setup_oq_regs)(struct octeon_device *, u32);\n\n\tirqreturn_t (*process_interrupt_regs)(void *);\n\tu64 (*msix_interrupt_handler)(void *);\n\n\tint (*setup_mbox)(struct octeon_device *);\n\tint (*free_mbox)(struct octeon_device *);\n\n\tint (*soft_reset)(struct octeon_device *);\n\tint (*setup_device_regs)(struct octeon_device *);\n\tvoid (*bar1_idx_setup)(struct octeon_device *, u64, u32, int);\n\tvoid (*bar1_idx_write)(struct octeon_device *, u32, u32);\n\tu32 (*bar1_idx_read)(struct octeon_device *, u32);\n\tu32 (*update_iq_read_idx)(struct octeon_instr_queue *);\n\n\tvoid (*enable_oq_pkt_time_intr)(struct octeon_device *, u32);\n\tvoid (*disable_oq_pkt_time_intr)(struct octeon_device *, u32);\n\n\tvoid (*enable_interrupt)(struct octeon_device *, u8);\n\tvoid (*disable_interrupt)(struct octeon_device *, u8);\n\n\tint (*enable_io_queues)(struct octeon_device *);\n\tvoid (*disable_io_queues)(struct octeon_device *);\n};\n\n \n#define CVMX_BOOTMEM_NAME_LEN 128\n\n \nstruct cvmx_bootmem_named_block_desc {\n\t \n\tu64 base_addr;\n\n\t \n\tu64 size;\n\n\t \n\tchar name[CVMX_BOOTMEM_NAME_LEN];\n};\n\nstruct oct_fw_info {\n\tu32 max_nic_ports;       \n\tu32 num_gmx_ports;       \n\tu64 app_cap_flags;       \n\n\t \n\tu32 app_mode;\n\tchar   liquidio_firmware_version[32];\n\t \n\tstruct {\n\t\tu8  maj;\n\t\tu8  min;\n\t\tu8  rev;\n\t} ver;\n};\n\n#define OCT_FW_VER(maj, min, rev) \\\n\t(((u32)(maj) << 16) | ((u32)(min) << 8) | ((u32)(rev)))\n\n \nstruct cavium_wk {\n\tstruct delayed_work work;\n\tvoid *ctxptr;\n\tu64 ctxul;\n};\n\nstruct cavium_wq {\n\tstruct workqueue_struct *wq;\n\tstruct cavium_wk wk;\n};\n\nstruct octdev_props {\n\t \n\tint    rx_on;\n\tint    fec;\n\tint    fec_boot;\n\tint    napi_enabled;\n\tint    gmxport;\n\tstruct net_device *netdev;\n};\n\n#define LIO_FLAG_MSIX_ENABLED\t0x1\n#define MSIX_PO_INT\t\t0x1\n#define MSIX_PI_INT\t\t0x2\n#define MSIX_MBOX_INT\t\t0x4\n\nstruct octeon_pf_vf_hs_word {\n#ifdef __LITTLE_ENDIAN_BITFIELD\n\t \n\tu64        pkind : 8;\n\n\t \n\tu64        core_tics_per_us : 16;\n\n\t \n\tu64        coproc_tics_per_us : 16;\n\n\t \n\tu64        app_mode : 8;\n\n\t \n\tu64 reserved : 16;\n\n#else\n\n\t \n\tu64 reserved : 16;\n\n\t \n\tu64        app_mode : 8;\n\n\t \n\tu64        coproc_tics_per_us : 16;\n\n\t \n\tu64        core_tics_per_us : 16;\n\n\t \n\tu64        pkind : 8;\n#endif\n};\n\nstruct octeon_sriov_info {\n\t \n\tu32\trings_per_vf;\n\n\t \n\tu32\tmax_vfs;\n\n\t \n\tu32\tnum_vfs_alloced;\n\n\t \n\tu32\tnum_pf_rings;\n\n\t \n\tu32\tpf_srn;\n\n\t \n\tu32\ttrs;\n\n\tu32\tsriov_enabled;\n\n\tstruct lio_trusted_vf\ttrusted_vf;\n\n\t \n\tstruct pci_dev *dpiring_to_vfpcidev_lut[MAX_POSSIBLE_VFS];\n\n\tu64\tvf_macaddr[MAX_POSSIBLE_VFS];\n\n\tu16\tvf_vlantci[MAX_POSSIBLE_VFS];\n\n\tint\tvf_linkstate[MAX_POSSIBLE_VFS];\n\n\tbool    vf_spoofchk[MAX_POSSIBLE_VFS];\n\n\tu64\tvf_drv_loaded_mask;\n};\n\nstruct octeon_ioq_vector {\n\tstruct octeon_device   *oct_dev;\n\tint\t\t        iq_index;\n\tint\t\t        droq_index;\n\tint\t\t\tvector;\n\tstruct octeon_mbox     *mbox;\n\tstruct cpumask\t\taffinity_mask;\n\tu32\t\t\tioq_num;\n};\n\nstruct lio_vf_rep_list {\n\tint num_vfs;\n\tstruct net_device *ndev[CN23XX_MAX_VFS_PER_PF];\n};\n\nstruct lio_devlink_priv {\n\tstruct octeon_device *oct;\n};\n\n \nstruct octeon_device {\n\t \n\tspinlock_t pci_win_lock;\n\n\t \n\tspinlock_t mem_access_lock;\n\n\t \n\tstruct pci_dev *pci_dev;\n\n\t \n\tvoid *chip;\n\n\t \n\tu32 ifcount;\n\n\tstruct octdev_props props[MAX_OCTEON_LINKS];\n\n\t \n\tu16 chip_id;\n\n\tu16 rev_id;\n\n\tu32 subsystem_id;\n\n\tu16 pf_num;\n\n\tu16 vf_num;\n\n\t \n\tu32 octeon_id;\n\n\t \n\tu16 pcie_port;\n\n\tu16 flags;\n#define LIO_FLAG_MSI_ENABLED                  (u32)(1 << 1)\n\n\t \n\tatomic_t status;\n\n\t \n\tstruct octeon_mmio mmio[OCT_MEM_REGIONS];\n\n\tstruct octeon_reg_list reg_list;\n\n\tstruct octeon_fn_list fn_list;\n\n\tstruct octeon_board_info boardinfo;\n\n\tu32 num_iqs;\n\n\t \n\tstruct octeon_sc_buffer_pool\tsc_buf_pool;\n\n\t \n\tstruct octeon_instr_queue *instr_queue\n\t\t[MAX_POSSIBLE_OCTEON_INSTR_QUEUES];\n\n\t \n\tstruct octeon_response_list response_list[MAX_RESPONSE_LISTS];\n\n\tu32 num_oqs;\n\n\t \n\tstruct octeon_droq *droq[MAX_POSSIBLE_OCTEON_OUTPUT_QUEUES];\n\n\tstruct octeon_io_enable io_qmask;\n\n\t \n\tstruct octeon_dispatch_list dispatch;\n\n\tu32 int_status;\n\n\tu64 droq_intr;\n\n\t \n\tu64 bootmem_desc_addr;\n\n\t \n\tstruct cvmx_bootmem_named_block_desc bootmem_named_block_desc;\n\n\t \n\tu64 console_desc_addr;\n\n\t \n\tu32 num_consoles;\n\n\t \n\tstruct octeon_console console[MAX_OCTEON_MAPS];\n\n\t \n\tstruct {\n\t\tu64 dram_region_base;\n\t\tint bar1_index;\n\t} console_nb_info;\n\n\t \n\tu64 coproc_clock_rate;\n\n\t \n\tu32 app_mode;\n\n\tstruct oct_fw_info fw_info;\n\n\t \n\tchar device_name[32];\n\n\t \n\tvoid *app_ctx;\n\n\tstruct cavium_wq dma_comp_wq;\n\n\t \n\tspinlock_t cmd_resp_wqlock;\n\tu32 cmd_resp_state;\n\n\tstruct cavium_wq check_db_wq[MAX_POSSIBLE_OCTEON_INSTR_QUEUES];\n\n\tstruct cavium_wk nic_poll_work;\n\n\tstruct cavium_wk console_poll_work[MAX_OCTEON_MAPS];\n\n\tvoid *priv;\n\n\tint num_msix_irqs;\n\n\tvoid *msix_entries;\n\n\t \n\tvoid *irq_name_storage;\n\n\tstruct octeon_sriov_info sriov_info;\n\n\tstruct octeon_pf_vf_hs_word pfvf_hsword;\n\n\tint msix_on;\n\n\t \n\tstruct octeon_mbox  *mbox[MAX_POSSIBLE_VFS];\n\n\t \n\tstruct octeon_ioq_vector    *ioq_vector;\n\n\tint rx_pause;\n\tint tx_pause;\n\n\tstruct oct_link_stats link_stats;  \n\n\t \n\tu32 priv_flags;\n\n\tvoid *watchdog_task;\n\n\tu32 rx_coalesce_usecs;\n\tu32 rx_max_coalesced_frames;\n\tu32 tx_max_coalesced_frames;\n\n\tbool cores_crashed;\n\n\tstruct {\n\t\tint bus;\n\t\tint dev;\n\t\tint func;\n\t} loc;\n\n\tatomic_t *adapter_refcount;  \n\n\tatomic_t *adapter_fw_state;  \n\n\tbool ptp_enable;\n\n\tstruct lio_vf_rep_list vf_rep_list;\n\tstruct devlink *devlink;\n\tenum devlink_eswitch_mode eswitch_mode;\n\n\t \n\tu8  speed_boot;\n\tu8  speed_setting;\n\tu8  no_speed_setting;\n\n\tu32    vfstats_poll;\n#define LIO_VFSTATS_POLL 10\n};\n\n#define  OCT_DRV_ONLINE 1\n#define  OCT_DRV_OFFLINE 2\n#define  OCTEON_CN6XXX(oct)\t({\t\t\t\t\t\\\n\t\t\t\t typeof(oct) _oct = (oct);\t\t\\\n\t\t\t\t ((_oct->chip_id == OCTEON_CN66XX) ||\t\\\n\t\t\t\t  (_oct->chip_id == OCTEON_CN68XX));\t})\n#define  OCTEON_CN23XX_PF(oct)        ((oct)->chip_id == OCTEON_CN23XX_PF_VID)\n#define  OCTEON_CN23XX_VF(oct)        ((oct)->chip_id == OCTEON_CN23XX_VF_VID)\n#define CHIP_CONF(oct, TYPE)             \\\n\t(((struct octeon_ ## TYPE  *)((oct)->chip))->conf)\n\n#define MAX_IO_PENDING_PKT_COUNT 100\n\n \n\n \nvoid octeon_init_device_list(int conf_type);\n\n \nvoid octeon_free_device_mem(struct octeon_device *oct);\n\n \nstruct octeon_device *octeon_allocate_device(u32 pci_id,\n\t\t\t\t\t     u32 priv_size);\n\n \nint octeon_register_device(struct octeon_device *oct,\n\t\t\t   int bus, int dev, int func, int is_pf);\n\n \nint octeon_deregister_device(struct octeon_device *oct);\n\n \nint octeon_init_dispatch_list(struct octeon_device *octeon_dev);\n\n \nvoid octeon_delete_dispatch_list(struct octeon_device *octeon_dev);\n\n \nint octeon_core_drv_init(struct octeon_recv_info *recv_info, void *buf);\n\n \nocteon_dispatch_fn_t\nocteon_get_dispatch(struct octeon_device *octeon_dev, u16 opcode,\n\t\t    u16 subcode);\n\n \nstruct octeon_device *lio_get_device(u32 octeon_id);\n\n \nint lio_get_device_id(void *dev);\n\n \n\nu64 lio_pci_readq(struct octeon_device *oct, u64 addr);\n\n \nvoid lio_pci_writeq(struct octeon_device *oct, u64 val, u64 addr);\n\n \n#define   octeon_write_csr(oct_dev, reg_off, value) \\\n\t\twritel(value, (oct_dev)->mmio[0].hw_addr + (reg_off))\n\n#define   octeon_write_csr64(oct_dev, reg_off, val64) \\\n\t\twriteq(val64, (oct_dev)->mmio[0].hw_addr + (reg_off))\n\n#define   octeon_read_csr(oct_dev, reg_off)         \\\n\t\treadl((oct_dev)->mmio[0].hw_addr + (reg_off))\n\n#define   octeon_read_csr64(oct_dev, reg_off)         \\\n\t\treadq((oct_dev)->mmio[0].hw_addr + (reg_off))\n\n \nint octeon_mem_access_ok(struct octeon_device *oct);\n\n \nint octeon_wait_for_ddr_init(struct octeon_device *oct,\n\t\t\t     u32 *timeout_in_ms);\n\n \nint octeon_wait_for_bootloader(struct octeon_device *oct,\n\t\t\t       u32 wait_time_hundredths);\n\n \nint octeon_init_consoles(struct octeon_device *oct);\n\n \nint octeon_add_console(struct octeon_device *oct, u32 console_num,\n\t\t       char *dbg_enb);\n\n \nint octeon_console_write(struct octeon_device *oct, u32 console_num,\n\t\t\t char *buffer, u32 write_request_size, u32 flags);\nint octeon_console_write_avail(struct octeon_device *oct, u32 console_num);\n\nint octeon_console_read_avail(struct octeon_device *oct, u32 console_num);\n\n \nvoid octeon_remove_consoles(struct octeon_device *oct);\n\n \nint octeon_console_send_cmd(struct octeon_device *oct, char *cmd_str,\n\t\t\t    u32 wait_hundredths);\n\n \nint octeon_download_firmware(struct octeon_device *oct, const u8 *data,\n\t\t\t     size_t size);\n\nchar *lio_get_state_string(atomic_t *state_ptr);\n\n \nint octeon_setup_instr_queues(struct octeon_device *oct);\n\n \nint octeon_setup_output_queues(struct octeon_device *oct);\n\nint octeon_get_tx_qsize(struct octeon_device *oct, u32 q_no);\n\nint octeon_get_rx_qsize(struct octeon_device *oct, u32 q_no);\n\n \nint octeon_set_io_queues_off(struct octeon_device *oct);\n\n \nvoid octeon_set_droq_pkt_op(struct octeon_device *oct, u32 q_no, u32 enable);\n\n \nvoid *oct_get_config_info(struct octeon_device *oct, u16 card_type);\n\n \nstruct octeon_config *octeon_get_conf(struct octeon_device *oct);\n\nvoid octeon_free_ioq_vector(struct octeon_device *oct);\nint octeon_allocate_ioq_vector(struct octeon_device  *oct, u32 num_ioqs);\nvoid lio_enable_irq(struct octeon_droq *droq, struct octeon_instr_queue *iq);\n\n \nenum {\n\tOCT_PRIV_FLAG_TX_BYTES = 0,  \n};\n\n#define OCT_PRIV_FLAG_DEFAULT 0x0\n\nstatic inline u32 lio_get_priv_flag(struct octeon_device *octdev, u32 flag)\n{\n\treturn !!(octdev->priv_flags & (0x1 << flag));\n}\n\nstatic inline void lio_set_priv_flag(struct octeon_device *octdev,\n\t\t\t\t     u32 flag, u32 val)\n{\n\tif (val)\n\t\toctdev->priv_flags |= (0x1 << flag);\n\telse\n\t\toctdev->priv_flags &= ~(0x1 << flag);\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}