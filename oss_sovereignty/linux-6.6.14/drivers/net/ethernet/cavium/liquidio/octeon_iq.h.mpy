{
  "module_name": "octeon_iq.h",
  "hash_id": "c0f1d220893b9531121aabf21b529ccc7f3acfd9506a7ed65a7eba5bd8b23599",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/cavium/liquidio/octeon_iq.h",
  "human_readable_source": " \n \n\n#ifndef __OCTEON_IQ_H__\n#define  __OCTEON_IQ_H__\n\n#define IQ_STATUS_RUNNING   1\n\n#define IQ_SEND_OK          0\n#define IQ_SEND_STOP        1\n#define IQ_SEND_FAILED     -1\n\n \n\n \n\n#define REQTYPE_NONE                 0\n#define REQTYPE_NORESP_NET           1\n#define REQTYPE_NORESP_NET_SG        2\n#define REQTYPE_RESP_NET             3\n#define REQTYPE_RESP_NET_SG          4\n#define REQTYPE_SOFT_COMMAND         5\n#define REQTYPE_LAST                 5\n\nstruct octeon_request_list {\n\tu32 reqtype;\n\tvoid *buf;\n};\n\n \n\n \nstruct oct_iq_stats {\n\tu64 instr_posted;  \n\tu64 instr_processed;  \n\tu64 instr_dropped;  \n\tu64 bytes_sent;   \n\tu64 sgentry_sent; \n\tu64 tx_done; \n\tu64 tx_iq_busy; \n\tu64 tx_dropped; \n\tu64 tx_tot_bytes; \n\tu64 tx_gso;   \n\tu64 tx_vxlan;  \n\tu64 tx_dmamap_fail;  \n\tu64 tx_restart;  \n};\n\n#define OCT_IQ_STATS_SIZE   (sizeof(struct oct_iq_stats))\n\n \nstruct octeon_instr_queue {\n\tstruct octeon_device *oct_dev;\n\n\t \n\tspinlock_t lock;\n\n\t \n\tspinlock_t post_lock;\n\n\t \n\tbool allow_soft_cmds;\n\n\tu32 pkt_in_done;\n\n\tu32 pkts_processed;\n\n\t \n\tspinlock_t iq_flush_running_lock;\n\n\t \n\tu32 iqcmd_64B:1;\n\n\t \n\tunion oct_txpciq txpciq;\n\n\tu32 rsvd:17;\n\n\t \n\tu32 do_auto_flush:1;\n\n\tu32 status:8;\n\n\t \n\tu32 max_count;\n\n\t \n\tu32 host_write_index;\n\n\t \n\tu32 octeon_read_index;\n\n\t \n\tu32 flush_index;\n\n\t \n\tatomic_t instr_pending;\n\n\tu32 reset_instr_cnt;\n\n\t \n\tu8 *base_addr;\n\n\tstruct octeon_request_list *request_list;\n\n\t \n\tvoid __iomem *doorbell_reg;\n\n\t \n\tvoid __iomem *inst_cnt_reg;\n\n\t \n\tu32 fill_cnt;\n\n\t \n\tu32 fill_threshold;\n\n\t \n\tu64 last_db_time;\n\n\t \n\tu32 db_timeout;\n\n\t \n\tstruct oct_iq_stats stats;\n\n\t \n\tdma_addr_t base_addr_dma;\n\n\t \n\tvoid *app_ctx;\n\n\t \n\tint q_index;\n\n\t \n\tint ifidx;\n\n};\n\n \n\n \nstruct octeon_instr_32B {\n\t \n\tu64 dptr;\n\n\t \n\tu64 ih;\n\n\t \n\tu64 rptr;\n\n\t \n\tu64 irh;\n\n};\n\n#define OCT_32B_INSTR_SIZE     (sizeof(struct octeon_instr_32B))\n\n \nstruct octeon_instr2_64B {\n\t \n\tu64 dptr;\n\n\t \n\tu64 ih2;\n\n\t \n\tu64 irh;\n\n\t \n\tu64 ossp[2];\n\n\t \n\tu64 rdp;\n\n\t \n\tu64 rptr;\n\n\tu64 reserved;\n};\n\nstruct octeon_instr3_64B {\n\t \n\tu64 dptr;\n\n\t \n\tu64 ih3;\n\n\t \n\tu64 pki_ih3;\n\n\t \n\tu64 irh;\n\n\t \n\tu64 ossp[2];\n\n\t \n\tu64 rdp;\n\n\t \n\tu64 rptr;\n\n};\n\nunion octeon_instr_64B {\n\tstruct octeon_instr2_64B cmd2;\n\tstruct octeon_instr3_64B cmd3;\n};\n\n#define OCT_64B_INSTR_SIZE     (sizeof(union octeon_instr_64B))\n\n \n#define  SOFT_COMMAND_BUFFER_SIZE\t2048\n\nstruct octeon_soft_command {\n\t \n\tstruct list_head node;\n\tu64 dma_addr;\n\tu32 size;\n\n\t \n\tunion octeon_instr_64B cmd;\n\n#define COMPLETION_WORD_INIT    0xffffffffffffffffULL\n\tu64 *status_word;\n\n\t \n\tvoid *virtdptr;\n\tu64 dmadptr;\n\tu32 datasize;\n\n\t \n\tvoid *virtrptr;\n\tu64 dmarptr;\n\tu32 rdatasize;\n\n\t \n\tvoid *ctxptr;\n\tu32  ctxsize;\n\n\t \n\tsize_t expiry_time;\n\tu32 iq_no;\n\tvoid (*callback)(struct octeon_device *, u32, void *);\n\tvoid *callback_arg;\n\n\tint caller_is_done;\n\tu32 sc_status;\n\tstruct completion complete;\n};\n\n \n#define LIO_SC_MAX_TMO_MS       60000\n\n \n#define  MAX_SOFT_COMMAND_BUFFERS\t256\n\n \nstruct octeon_sc_buffer_pool {\n\t \n\tstruct list_head head;\n\n\t \n\tspinlock_t lock;\n\n\tatomic_t alloc_buf_count;\n};\n\n#define INCR_INSTRQUEUE_PKT_COUNT(octeon_dev_ptr, iq_no, field, count)  \\\n\t\t(((octeon_dev_ptr)->instr_queue[iq_no]->stats.field) += count)\n\nint octeon_setup_sc_buffer_pool(struct octeon_device *oct);\nint octeon_free_sc_done_list(struct octeon_device *oct);\nint octeon_free_sc_zombie_list(struct octeon_device *oct);\nint octeon_free_sc_buffer_pool(struct octeon_device *oct);\nstruct octeon_soft_command *\n\tocteon_alloc_soft_command(struct octeon_device *oct,\n\t\t\t\t  u32 datasize, u32 rdatasize,\n\t\t\t\t  u32 ctxsize);\nvoid octeon_free_soft_command(struct octeon_device *oct,\n\t\t\t      struct octeon_soft_command *sc);\n\n \nint octeon_init_instr_queue(struct octeon_device *octeon_dev,\n\t\t\t    union oct_txpciq txpciq,\n\t\t\t    u32 num_descs);\n\n \nint octeon_delete_instr_queue(struct octeon_device *octeon_dev, u32 iq_no);\n\nint lio_wait_for_instr_fetch(struct octeon_device *oct);\n\nvoid\nocteon_ring_doorbell_locked(struct octeon_device *oct, u32 iq_no);\n\nint\nocteon_register_reqtype_free_fn(struct octeon_device *oct, int reqtype,\n\t\t\t\tvoid (*fn)(void *));\n\nint\nlio_process_iq_request_list(struct octeon_device *oct,\n\t\t\t    struct octeon_instr_queue *iq, u32 napi_budget);\n\nint octeon_send_command(struct octeon_device *oct, u32 iq_no,\n\t\t\tu32 force_db, void *cmd, void *buf,\n\t\t\tu32 datasize, u32 reqtype);\n\nvoid octeon_dump_soft_command(struct octeon_device *oct,\n\t\t\t      struct octeon_soft_command *sc);\n\nvoid octeon_prepare_soft_command(struct octeon_device *oct,\n\t\t\t\t struct octeon_soft_command *sc,\n\t\t\t\t u8 opcode, u8 subcode,\n\t\t\t\t u32 irh_ossp, u64 ossp0,\n\t\t\t\t u64 ossp1);\n\nint octeon_send_soft_command(struct octeon_device *oct,\n\t\t\t     struct octeon_soft_command *sc);\n\nint octeon_setup_iq(struct octeon_device *oct, int ifidx,\n\t\t    int q_index, union oct_txpciq iq_no, u32 num_descs,\n\t\t    void *app_ctx);\nint\nocteon_flush_iq(struct octeon_device *oct, struct octeon_instr_queue *iq,\n\t\tu32 napi_budget);\n#endif\t\t\t\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}