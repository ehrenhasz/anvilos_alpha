{
  "module_name": "cn23xx_pf_device.c",
  "hash_id": "4f56e89db0c821cc218dd77844f1b9d227af2bf62550029f0b2331b9651bcf36",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/cavium/liquidio/cn23xx_pf_device.c",
  "human_readable_source": " \n#include <linux/pci.h>\n#include <linux/vmalloc.h>\n#include <linux/etherdevice.h>\n#include \"liquidio_common.h\"\n#include \"octeon_droq.h\"\n#include \"octeon_iq.h\"\n#include \"response_manager.h\"\n#include \"octeon_device.h\"\n#include \"cn23xx_pf_device.h\"\n#include \"octeon_main.h\"\n#include \"octeon_mailbox.h\"\n\n#define RESET_NOTDONE 0\n#define RESET_DONE 1\n\n \n#define CN23XX_INPUT_JABBER 64600\n\nvoid cn23xx_dump_pf_initialized_regs(struct octeon_device *oct)\n{\n\tint i = 0;\n\tu32 regval = 0;\n\tstruct octeon_cn23xx_pf *cn23xx = (struct octeon_cn23xx_pf *)oct->chip;\n\n\t \n\tdev_dbg(&oct->pci_dev->dev, \"%s[%llx] : 0x%llx\\n\",\n\t\t\"CN23XX_WIN_WR_MASK_REG\", CVM_CAST64(CN23XX_WIN_WR_MASK_REG),\n\t\tCVM_CAST64(octeon_read_csr64(oct, CN23XX_WIN_WR_MASK_REG)));\n\tdev_dbg(&oct->pci_dev->dev, \"%s[%llx] : 0x%016llx\\n\",\n\t\t\"CN23XX_SLI_SCRATCH1\", CVM_CAST64(CN23XX_SLI_SCRATCH1),\n\t\tCVM_CAST64(octeon_read_csr64(oct, CN23XX_SLI_SCRATCH1)));\n\tdev_dbg(&oct->pci_dev->dev, \"%s[%llx] : 0x%016llx\\n\",\n\t\t\"CN23XX_RST_SOFT_RST\", CN23XX_RST_SOFT_RST,\n\t\tlio_pci_readq(oct, CN23XX_RST_SOFT_RST));\n\n\t \n\tdev_dbg(&oct->pci_dev->dev, \"%s[%llx] : 0x%016llx\\n\",\n\t\t\"CN23XX_DPI_DMA_CONTROL\", CN23XX_DPI_DMA_CONTROL,\n\t\tlio_pci_readq(oct, CN23XX_DPI_DMA_CONTROL));\n\n\tfor (i = 0; i < 6; i++) {\n\t\tdev_dbg(&oct->pci_dev->dev, \"%s(%d)[%llx] : 0x%016llx\\n\",\n\t\t\t\"CN23XX_DPI_DMA_ENG_ENB\", i,\n\t\t\tCN23XX_DPI_DMA_ENG_ENB(i),\n\t\t\tlio_pci_readq(oct, CN23XX_DPI_DMA_ENG_ENB(i)));\n\t\tdev_dbg(&oct->pci_dev->dev, \"%s(%d)[%llx] : 0x%016llx\\n\",\n\t\t\t\"CN23XX_DPI_DMA_ENG_BUF\", i,\n\t\t\tCN23XX_DPI_DMA_ENG_BUF(i),\n\t\t\tlio_pci_readq(oct, CN23XX_DPI_DMA_ENG_BUF(i)));\n\t}\n\n\tdev_dbg(&oct->pci_dev->dev, \"%s[%llx] : 0x%016llx\\n\", \"CN23XX_DPI_CTL\",\n\t\tCN23XX_DPI_CTL, lio_pci_readq(oct, CN23XX_DPI_CTL));\n\n\t \n\tpci_read_config_dword(oct->pci_dev, CN23XX_CONFIG_PCIE_DEVCTL, &regval);\n\tdev_dbg(&oct->pci_dev->dev, \"%s[%llx] : 0x%016llx\\n\",\n\t\t\"CN23XX_CONFIG_PCIE_DEVCTL\",\n\t\tCVM_CAST64(CN23XX_CONFIG_PCIE_DEVCTL), CVM_CAST64(regval));\n\n\tdev_dbg(&oct->pci_dev->dev, \"%s(%d)[%llx] : 0x%016llx\\n\",\n\t\t\"CN23XX_DPI_SLI_PRTX_CFG\", oct->pcie_port,\n\t\tCN23XX_DPI_SLI_PRTX_CFG(oct->pcie_port),\n\t\tlio_pci_readq(oct, CN23XX_DPI_SLI_PRTX_CFG(oct->pcie_port)));\n\n\t \n\tdev_dbg(&oct->pci_dev->dev, \"%s(%d)[%llx] : 0x%016llx\\n\",\n\t\t\"CN23XX_SLI_S2M_PORTX_CTL\", oct->pcie_port,\n\t\tCVM_CAST64(CN23XX_SLI_S2M_PORTX_CTL(oct->pcie_port)),\n\t\tCVM_CAST64(octeon_read_csr64(\n\t\t\toct, CN23XX_SLI_S2M_PORTX_CTL(oct->pcie_port))));\n\n\tdev_dbg(&oct->pci_dev->dev, \"%s[%llx] : 0x%016llx\\n\",\n\t\t\"CN23XX_SLI_RING_RST\", CVM_CAST64(CN23XX_SLI_PKT_IOQ_RING_RST),\n\t\t(u64)octeon_read_csr64(oct, CN23XX_SLI_PKT_IOQ_RING_RST));\n\n\t \n\tfor (i = 0; i < CN23XX_MAX_MACS; i++) {\n\t\tdev_dbg(&oct->pci_dev->dev, \"%s(%d)[%llx] : 0x%016llx\\n\",\n\t\t\t\"CN23XX_SLI_PKT_MAC_RINFO64\", i,\n\t\t\tCVM_CAST64(CN23XX_SLI_PKT_MAC_RINFO64(i, oct->pf_num)),\n\t\t\tCVM_CAST64(octeon_read_csr64\n\t\t\t\t(oct, CN23XX_SLI_PKT_MAC_RINFO64\n\t\t\t\t\t(i, oct->pf_num))));\n\t}\n\n\t \n\tfor (i = 0; i < CN23XX_MAX_INPUT_QUEUES; i++) {\n\t\tdev_dbg(&oct->pci_dev->dev, \"%s(%d)[%llx] : 0x%016llx\\n\",\n\t\t\t\"CN23XX_SLI_IQ_PKT_CONTROL64\", i,\n\t\t\tCVM_CAST64(CN23XX_SLI_IQ_PKT_CONTROL64(i)),\n\t\t\tCVM_CAST64(octeon_read_csr64\n\t\t\t\t(oct, CN23XX_SLI_IQ_PKT_CONTROL64(i))));\n\t}\n\n\t \n\tdev_dbg(&oct->pci_dev->dev, \"%s[%llx] : 0x%016llx\\n\",\n\t\t\"CN23XX_SLI_OQ_WMARK\", CVM_CAST64(CN23XX_SLI_OQ_WMARK),\n\t\tCVM_CAST64(octeon_read_csr64(oct, CN23XX_SLI_OQ_WMARK)));\n\n\tfor (i = 0; i < CN23XX_MAX_OUTPUT_QUEUES; i++) {\n\t\tdev_dbg(&oct->pci_dev->dev, \"%s(%d)[%llx] : 0x%016llx\\n\",\n\t\t\t\"CN23XX_SLI_OQ_PKT_CONTROL\", i,\n\t\t\tCVM_CAST64(CN23XX_SLI_OQ_PKT_CONTROL(i)),\n\t\t\tCVM_CAST64(octeon_read_csr(\n\t\t\t\toct, CN23XX_SLI_OQ_PKT_CONTROL(i))));\n\t\tdev_dbg(&oct->pci_dev->dev, \"%s(%d)[%llx] : 0x%016llx\\n\",\n\t\t\t\"CN23XX_SLI_OQ_PKT_INT_LEVELS\", i,\n\t\t\tCVM_CAST64(CN23XX_SLI_OQ_PKT_INT_LEVELS(i)),\n\t\t\tCVM_CAST64(octeon_read_csr64(\n\t\t\t\toct, CN23XX_SLI_OQ_PKT_INT_LEVELS(i))));\n\t}\n\n\t \n\tdev_dbg(&oct->pci_dev->dev, \"%s[%llx] : 0x%016llx\\n\",\n\t\t\"cn23xx->intr_enb_reg64\",\n\t\tCVM_CAST64((long)(cn23xx->intr_enb_reg64)),\n\t\tCVM_CAST64(readq(cn23xx->intr_enb_reg64)));\n\n\tdev_dbg(&oct->pci_dev->dev, \"%s[%llx] : 0x%016llx\\n\",\n\t\t\"cn23xx->intr_sum_reg64\",\n\t\tCVM_CAST64((long)(cn23xx->intr_sum_reg64)),\n\t\tCVM_CAST64(readq(cn23xx->intr_sum_reg64)));\n\n\t \n\tfor (i = 0; i < CN23XX_MAX_INPUT_QUEUES; i++) {\n\t\tdev_dbg(&oct->pci_dev->dev, \"%s(%d)[%llx] : 0x%016llx\\n\",\n\t\t\t\"CN23XX_SLI_IQ_BASE_ADDR64\", i,\n\t\t\tCVM_CAST64(CN23XX_SLI_IQ_BASE_ADDR64(i)),\n\t\t\tCVM_CAST64(octeon_read_csr64(\n\t\t\t\toct, CN23XX_SLI_IQ_BASE_ADDR64(i))));\n\t\tdev_dbg(&oct->pci_dev->dev, \"%s(%d)[%llx] : 0x%016llx\\n\",\n\t\t\t\"CN23XX_SLI_IQ_SIZE\", i,\n\t\t\tCVM_CAST64(CN23XX_SLI_IQ_SIZE(i)),\n\t\t\tCVM_CAST64(octeon_read_csr\n\t\t\t\t(oct, CN23XX_SLI_IQ_SIZE(i))));\n\t\tdev_dbg(&oct->pci_dev->dev, \"%s(%d)[%llx] : 0x%016llx\\n\",\n\t\t\t\"CN23XX_SLI_IQ_DOORBELL\", i,\n\t\t\tCVM_CAST64(CN23XX_SLI_IQ_DOORBELL(i)),\n\t\t\tCVM_CAST64(octeon_read_csr64(\n\t\t\t\toct, CN23XX_SLI_IQ_DOORBELL(i))));\n\t\tdev_dbg(&oct->pci_dev->dev, \"%s(%d)[%llx] : 0x%016llx\\n\",\n\t\t\t\"CN23XX_SLI_IQ_INSTR_COUNT64\", i,\n\t\t\tCVM_CAST64(CN23XX_SLI_IQ_INSTR_COUNT64(i)),\n\t\t\tCVM_CAST64(octeon_read_csr64(\n\t\t\t\toct, CN23XX_SLI_IQ_INSTR_COUNT64(i))));\n\t}\n\n\t \n\tfor (i = 0; i < CN23XX_MAX_OUTPUT_QUEUES; i++) {\n\t\tdev_dbg(&oct->pci_dev->dev, \"%s(%d)[%llx] : 0x%016llx\\n\",\n\t\t\t\"CN23XX_SLI_OQ_BASE_ADDR64\", i,\n\t\t\tCVM_CAST64(CN23XX_SLI_OQ_BASE_ADDR64(i)),\n\t\t\tCVM_CAST64(octeon_read_csr64(\n\t\t\t\toct, CN23XX_SLI_OQ_BASE_ADDR64(i))));\n\t\tdev_dbg(&oct->pci_dev->dev, \"%s(%d)[%llx] : 0x%016llx\\n\",\n\t\t\t\"CN23XX_SLI_OQ_SIZE\", i,\n\t\t\tCVM_CAST64(CN23XX_SLI_OQ_SIZE(i)),\n\t\t\tCVM_CAST64(octeon_read_csr\n\t\t\t\t(oct, CN23XX_SLI_OQ_SIZE(i))));\n\t\tdev_dbg(&oct->pci_dev->dev, \"%s(%d)[%llx] : 0x%016llx\\n\",\n\t\t\t\"CN23XX_SLI_OQ_BUFF_INFO_SIZE\", i,\n\t\t\tCVM_CAST64(CN23XX_SLI_OQ_BUFF_INFO_SIZE(i)),\n\t\t\tCVM_CAST64(octeon_read_csr(\n\t\t\t\toct, CN23XX_SLI_OQ_BUFF_INFO_SIZE(i))));\n\t\tdev_dbg(&oct->pci_dev->dev, \"%s(%d)[%llx] : 0x%016llx\\n\",\n\t\t\t\"CN23XX_SLI_OQ_PKTS_SENT\", i,\n\t\t\tCVM_CAST64(CN23XX_SLI_OQ_PKTS_SENT(i)),\n\t\t\tCVM_CAST64(octeon_read_csr64(\n\t\t\t\toct, CN23XX_SLI_OQ_PKTS_SENT(i))));\n\t\tdev_dbg(&oct->pci_dev->dev, \"%s(%d)[%llx] : 0x%016llx\\n\",\n\t\t\t\"CN23XX_SLI_OQ_PKTS_CREDIT\", i,\n\t\t\tCVM_CAST64(CN23XX_SLI_OQ_PKTS_CREDIT(i)),\n\t\t\tCVM_CAST64(octeon_read_csr64(\n\t\t\t\toct, CN23XX_SLI_OQ_PKTS_CREDIT(i))));\n\t}\n\n\tdev_dbg(&oct->pci_dev->dev, \"%s[%llx] : 0x%016llx\\n\",\n\t\t\"CN23XX_SLI_PKT_TIME_INT\",\n\t\tCVM_CAST64(CN23XX_SLI_PKT_TIME_INT),\n\t\tCVM_CAST64(octeon_read_csr64(oct, CN23XX_SLI_PKT_TIME_INT)));\n\tdev_dbg(&oct->pci_dev->dev, \"%s[%llx] : 0x%016llx\\n\",\n\t\t\"CN23XX_SLI_PKT_CNT_INT\",\n\t\tCVM_CAST64(CN23XX_SLI_PKT_CNT_INT),\n\t\tCVM_CAST64(octeon_read_csr64(oct, CN23XX_SLI_PKT_CNT_INT)));\n}\n\nstatic int cn23xx_pf_soft_reset(struct octeon_device *oct)\n{\n\tocteon_write_csr64(oct, CN23XX_WIN_WR_MASK_REG, 0xFF);\n\n\tdev_dbg(&oct->pci_dev->dev, \"OCTEON[%d]: BIST enabled for CN23XX soft reset\\n\",\n\t\toct->octeon_id);\n\n\tocteon_write_csr64(oct, CN23XX_SLI_SCRATCH1, 0x1234ULL);\n\n\t \n\tlio_pci_readq(oct, CN23XX_RST_SOFT_RST);\n\tlio_pci_writeq(oct, 1, CN23XX_RST_SOFT_RST);\n\n\t \n\tmdelay(100);\n\n\tif (octeon_read_csr64(oct, CN23XX_SLI_SCRATCH1)) {\n\t\tdev_err(&oct->pci_dev->dev, \"OCTEON[%d]: Soft reset failed\\n\",\n\t\t\toct->octeon_id);\n\t\treturn 1;\n\t}\n\n\tdev_dbg(&oct->pci_dev->dev, \"OCTEON[%d]: Reset completed\\n\",\n\t\toct->octeon_id);\n\n\t \n\tocteon_write_csr64(oct, CN23XX_WIN_WR_MASK_REG, 0xFF);\n\n\treturn 0;\n}\n\nstatic void cn23xx_enable_error_reporting(struct octeon_device *oct)\n{\n\tu32 regval;\n\tu32 uncorrectable_err_mask, corrtable_err_status;\n\n\tpci_read_config_dword(oct->pci_dev, CN23XX_CONFIG_PCIE_DEVCTL, &regval);\n\tif (regval & CN23XX_CONFIG_PCIE_DEVCTL_MASK) {\n\t\tuncorrectable_err_mask = 0;\n\t\tcorrtable_err_status = 0;\n\t\tpci_read_config_dword(oct->pci_dev,\n\t\t\t\t      CN23XX_CONFIG_PCIE_UNCORRECT_ERR_MASK,\n\t\t\t\t      &uncorrectable_err_mask);\n\t\tpci_read_config_dword(oct->pci_dev,\n\t\t\t\t      CN23XX_CONFIG_PCIE_CORRECT_ERR_STATUS,\n\t\t\t\t      &corrtable_err_status);\n\t\tdev_err(&oct->pci_dev->dev, \"PCI-E Fatal error detected;\\n\"\n\t\t\t\t \"\\tdev_ctl_status_reg = 0x%08x\\n\"\n\t\t\t\t \"\\tuncorrectable_error_mask_reg = 0x%08x\\n\"\n\t\t\t\t \"\\tcorrectable_error_status_reg = 0x%08x\\n\",\n\t\t\t    regval, uncorrectable_err_mask,\n\t\t\t    corrtable_err_status);\n\t}\n\n\tregval |= 0xf;  \n\n\tdev_dbg(&oct->pci_dev->dev, \"OCTEON[%d]: Enabling PCI-E error reporting..\\n\",\n\t\toct->octeon_id);\n\tpci_write_config_dword(oct->pci_dev, CN23XX_CONFIG_PCIE_DEVCTL, regval);\n}\n\nstatic u32 cn23xx_coprocessor_clock(struct octeon_device *oct)\n{\n\t \n\n\t \n\treturn (((lio_pci_readq(oct, CN23XX_RST_BOOT) >> 24) & 0x3f) * 50);\n}\n\nu32 cn23xx_pf_get_oq_ticks(struct octeon_device *oct, u32 time_intr_in_us)\n{\n\t \n\tu32 oqticks_per_us = cn23xx_coprocessor_clock(oct);\n\n\toct->pfvf_hsword.coproc_tics_per_us = oqticks_per_us;\n\n\t \n\toqticks_per_us *= 1000;\n\n\t \n\toqticks_per_us /= 1024;\n\n\t \n\toqticks_per_us *= time_intr_in_us;\n\toqticks_per_us /= 1000;\n\n\treturn oqticks_per_us;\n}\n\nstatic void cn23xx_setup_global_mac_regs(struct octeon_device *oct)\n{\n\tu16 mac_no = oct->pcie_port;\n\tu16 pf_num = oct->pf_num;\n\tu64 reg_val;\n\tu64 temp;\n\n\t \n\n\tdev_dbg(&oct->pci_dev->dev, \"%s:Using pcie port %d\\n\",\n\t\t__func__, mac_no);\n\t \n\n\treg_val =\n\t    octeon_read_csr64(oct, CN23XX_SLI_PKT_MAC_RINFO64(mac_no, pf_num));\n\n\tif (oct->rev_id == OCTEON_CN23XX_REV_1_1) {\n\t\t \n\t\treg_val = pf_num * CN23XX_MAX_RINGS_PER_PF_PASS_1_1;\n\t} else {\n\t\t \n\t\treg_val = pf_num * CN23XX_MAX_RINGS_PER_PF;\n\t}\n\n\t \n\treg_val = reg_val |\n\t\t  (oct->sriov_info.trs << CN23XX_PKT_MAC_CTL_RINFO_TRS_BIT_POS);\n\t \n\ttemp = oct->sriov_info.rings_per_vf & 0xff;\n\treg_val |= (temp << CN23XX_PKT_MAC_CTL_RINFO_RPVF_BIT_POS);\n\n\t \n\ttemp = oct->sriov_info.max_vfs & 0xff;\n\treg_val |= (temp << CN23XX_PKT_MAC_CTL_RINFO_NVFS_BIT_POS);\n\n\t \n\tocteon_write_csr64(oct, CN23XX_SLI_PKT_MAC_RINFO64(mac_no, pf_num),\n\t\t\t   reg_val);\n\n\tdev_dbg(&oct->pci_dev->dev, \"SLI_PKT_MAC(%d)_PF(%d)_RINFO : 0x%016llx\\n\",\n\t\tmac_no, pf_num, (u64)octeon_read_csr64\n\t\t(oct, CN23XX_SLI_PKT_MAC_RINFO64(mac_no, pf_num)));\n}\n\nstatic int cn23xx_reset_io_queues(struct octeon_device *oct)\n{\n\tint ret_val = 0;\n\tu64 d64;\n\tu32 q_no, srn, ern;\n\tu32 loop = 1000;\n\n\tsrn = oct->sriov_info.pf_srn;\n\tern = srn + oct->sriov_info.num_pf_rings;\n\n\t \n\t \n\n\t \n\tfor (q_no = srn; q_no < ern; q_no++) {\n\t\t \n\t\td64 = octeon_read_csr64(oct, CN23XX_SLI_IQ_PKT_CONTROL64(q_no));\n\t\td64 = d64 | CN23XX_PKT_INPUT_CTL_RST;\n\t\tocteon_write_csr64(oct, CN23XX_SLI_IQ_PKT_CONTROL64(q_no), d64);\n\t}\n\n\t \n\tfor (q_no = srn; q_no < ern; q_no++) {\n\t\tu64 reg_val = octeon_read_csr64(oct,\n\t\t\t\t\tCN23XX_SLI_IQ_PKT_CONTROL64(q_no));\n\t\twhile ((READ_ONCE(reg_val) & CN23XX_PKT_INPUT_CTL_RST) &&\n\t\t       !(READ_ONCE(reg_val) & CN23XX_PKT_INPUT_CTL_QUIET) &&\n\t\t       loop--) {\n\t\t\tWRITE_ONCE(reg_val, octeon_read_csr64(\n\t\t\t    oct, CN23XX_SLI_IQ_PKT_CONTROL64(q_no)));\n\t\t}\n\t\tif (!loop) {\n\t\t\tdev_err(&oct->pci_dev->dev,\n\t\t\t\t\"clearing the reset reg failed or setting the quiet reg failed for qno: %u\\n\",\n\t\t\t\tq_no);\n\t\t\treturn -1;\n\t\t}\n\t\tWRITE_ONCE(reg_val, READ_ONCE(reg_val) &\n\t\t\t~CN23XX_PKT_INPUT_CTL_RST);\n\t\tocteon_write_csr64(oct, CN23XX_SLI_IQ_PKT_CONTROL64(q_no),\n\t\t\t\t   READ_ONCE(reg_val));\n\n\t\tWRITE_ONCE(reg_val, octeon_read_csr64(\n\t\t\t   oct, CN23XX_SLI_IQ_PKT_CONTROL64(q_no)));\n\t\tif (READ_ONCE(reg_val) & CN23XX_PKT_INPUT_CTL_RST) {\n\t\t\tdev_err(&oct->pci_dev->dev,\n\t\t\t\t\"clearing the reset failed for qno: %u\\n\",\n\t\t\t\tq_no);\n\t\t\tret_val = -1;\n\t\t}\n\t}\n\n\treturn ret_val;\n}\n\nstatic int cn23xx_pf_setup_global_input_regs(struct octeon_device *oct)\n{\n\tstruct octeon_cn23xx_pf *cn23xx = (struct octeon_cn23xx_pf *)oct->chip;\n\tstruct octeon_instr_queue *iq;\n\tu64 intr_threshold, reg_val;\n\tu32 q_no, ern, srn;\n\tu64 pf_num;\n\tu64 vf_num;\n\n\tpf_num = oct->pf_num;\n\n\tsrn = oct->sriov_info.pf_srn;\n\tern = srn + oct->sriov_info.num_pf_rings;\n\n\tif (cn23xx_reset_io_queues(oct))\n\t\treturn -1;\n\n\t \n\tfor (q_no = 0; q_no < ern; q_no++) {\n\t\treg_val = (u64)oct->pcie_port << CN23XX_PKT_INPUT_CTL_MAC_NUM_POS;\n\n\t\t \n\t\tif (q_no < oct->sriov_info.pf_srn) {\n\t\t\tvf_num = q_no / oct->sriov_info.rings_per_vf;\n\t\t\tvf_num += 1;  \n\t\t} else {\n\t\t\tvf_num = 0;\n\t\t}\n\n\t\treg_val |= vf_num << CN23XX_PKT_INPUT_CTL_VF_NUM_POS;\n\t\treg_val |= pf_num << CN23XX_PKT_INPUT_CTL_PF_NUM_POS;\n\n\t\tocteon_write_csr64(oct, CN23XX_SLI_IQ_PKT_CONTROL64(q_no),\n\t\t\t\t   reg_val);\n\t}\n\n\t \n\tfor (q_no = srn; q_no < ern; q_no++) {\n\t\tvoid __iomem *inst_cnt_reg;\n\n\t\tiq = oct->instr_queue[q_no];\n\t\tif (iq)\n\t\t\tinst_cnt_reg = iq->inst_cnt_reg;\n\t\telse\n\t\t\tinst_cnt_reg = (u8 *)oct->mmio[0].hw_addr +\n\t\t\t\t       CN23XX_SLI_IQ_INSTR_COUNT64(q_no);\n\n\t\treg_val =\n\t\t    octeon_read_csr64(oct, CN23XX_SLI_IQ_PKT_CONTROL64(q_no));\n\n\t\treg_val |= CN23XX_PKT_INPUT_CTL_MASK;\n\n\t\tocteon_write_csr64(oct, CN23XX_SLI_IQ_PKT_CONTROL64(q_no),\n\t\t\t\t   reg_val);\n\n\t\t \n\t\t \n\t\tintr_threshold = CFG_GET_IQ_INTR_PKT(cn23xx->conf) &\n\t\t\t\t CN23XX_PKT_IN_DONE_WMARK_MASK;\n\n\t\twriteq((readq(inst_cnt_reg) &\n\t\t\t~(CN23XX_PKT_IN_DONE_WMARK_MASK <<\n\t\t\t  CN23XX_PKT_IN_DONE_WMARK_BIT_POS)) |\n\t\t       (intr_threshold << CN23XX_PKT_IN_DONE_WMARK_BIT_POS),\n\t\t       inst_cnt_reg);\n\t}\n\treturn 0;\n}\n\nstatic void cn23xx_pf_setup_global_output_regs(struct octeon_device *oct)\n{\n\tu32 reg_val;\n\tu32 q_no, ern, srn;\n\tu64 time_threshold;\n\n\tstruct octeon_cn23xx_pf *cn23xx = (struct octeon_cn23xx_pf *)oct->chip;\n\n\tsrn = oct->sriov_info.pf_srn;\n\tern = srn + oct->sriov_info.num_pf_rings;\n\n\tif (CFG_GET_IS_SLI_BP_ON(cn23xx->conf)) {\n\t\tocteon_write_csr64(oct, CN23XX_SLI_OQ_WMARK, 32);\n\t} else {\n\t\t \n\t\tocteon_write_csr64(oct, CN23XX_SLI_OQ_WMARK, 0);\n\t}\n\n\tfor (q_no = srn; q_no < ern; q_no++) {\n\t\treg_val = octeon_read_csr(oct, CN23XX_SLI_OQ_PKT_CONTROL(q_no));\n\n\t\t \n\t\treg_val &= ~CN23XX_PKT_OUTPUT_CTL_IPTR;\n\n\t\t \n\t\treg_val |= CN23XX_PKT_OUTPUT_CTL_DPTR;\n\n\t\t \n\t\treg_val &= ~(CN23XX_PKT_OUTPUT_CTL_BMODE);\n\n\t\t \n\t\treg_val &= ~(CN23XX_PKT_OUTPUT_CTL_ROR_P);\n\t\treg_val &= ~(CN23XX_PKT_OUTPUT_CTL_NSR_P);\n\n#ifdef __LITTLE_ENDIAN_BITFIELD\n\t\treg_val &= ~(CN23XX_PKT_OUTPUT_CTL_ES_P);\n#else\n\t\treg_val |= (CN23XX_PKT_OUTPUT_CTL_ES_P);\n#endif\n\t\t \n\t\treg_val &= ~(CN23XX_PKT_OUTPUT_CTL_ROR);\n\t\treg_val &= ~(CN23XX_PKT_OUTPUT_CTL_NSR);\n\t\t \n\t\treg_val |= (CN23XX_PKT_OUTPUT_CTL_ES);\n\n\t\t \n\t\tocteon_write_csr(oct, CN23XX_SLI_OQ_PKT_CONTROL(q_no), reg_val);\n\n\t\t \n\t\ttime_threshold = cn23xx_pf_get_oq_ticks(\n\t\t    oct, (u32)CFG_GET_OQ_INTR_TIME(cn23xx->conf));\n\n\t\tocteon_write_csr64(oct, CN23XX_SLI_OQ_PKT_INT_LEVELS(q_no),\n\t\t\t\t   (CFG_GET_OQ_INTR_PKT(cn23xx->conf) |\n\t\t\t\t    (time_threshold << 32)));\n\t}\n\n\t \n\twriteq(0x40, (u8 *)oct->mmio[0].hw_addr + CN23XX_SLI_OQ_WMARK);\n\n\t \n\t \n\tif ((oct->rev_id == OCTEON_CN23XX_REV_1_0) ||\n\t    (oct->rev_id == OCTEON_CN23XX_REV_1_1))\n\t\twriteq(readq((u8 *)oct->mmio[0].hw_addr +\n\t\t\t\t     CN23XX_SLI_GBL_CONTROL) | 0x2,\n\t\t       (u8 *)oct->mmio[0].hw_addr + CN23XX_SLI_GBL_CONTROL);\n\n\t \n\tif (oct->pf_num)\n\t\twriteq(0xffffffffffffffffULL,\n\t\t       (u8 *)oct->mmio[0].hw_addr + CN23XX_SLI_OUT_BP_EN2_W1S);\n\telse\n\t\twriteq(0xffffffffffffffffULL,\n\t\t       (u8 *)oct->mmio[0].hw_addr + CN23XX_SLI_OUT_BP_EN_W1S);\n}\n\nstatic int cn23xx_setup_pf_device_regs(struct octeon_device *oct)\n{\n\tcn23xx_enable_error_reporting(oct);\n\n\t \n\tcn23xx_setup_global_mac_regs(oct);\n\n\tif (cn23xx_pf_setup_global_input_regs(oct))\n\t\treturn -1;\n\n\tcn23xx_pf_setup_global_output_regs(oct);\n\n\t \n\tocteon_write_csr64(oct, CN23XX_SLI_WINDOW_CTL,\n\t\t\t   CN23XX_SLI_WINDOW_CTL_DEFAULT);\n\n\t \n\tocteon_write_csr64(oct, CN23XX_SLI_PKT_IN_JABBER, CN23XX_INPUT_JABBER);\n\treturn 0;\n}\n\nstatic void cn23xx_setup_iq_regs(struct octeon_device *oct, u32 iq_no)\n{\n\tstruct octeon_instr_queue *iq = oct->instr_queue[iq_no];\n\tu64 pkt_in_done;\n\n\tiq_no += oct->sriov_info.pf_srn;\n\n\t \n\tocteon_write_csr64(oct, CN23XX_SLI_IQ_BASE_ADDR64(iq_no),\n\t\t\t   iq->base_addr_dma);\n\tocteon_write_csr(oct, CN23XX_SLI_IQ_SIZE(iq_no), iq->max_count);\n\n\t \n\tiq->doorbell_reg =\n\t    (u8 *)oct->mmio[0].hw_addr + CN23XX_SLI_IQ_DOORBELL(iq_no);\n\tiq->inst_cnt_reg =\n\t    (u8 *)oct->mmio[0].hw_addr + CN23XX_SLI_IQ_INSTR_COUNT64(iq_no);\n\tdev_dbg(&oct->pci_dev->dev, \"InstQ[%d]:dbell reg @ 0x%p instcnt_reg @ 0x%p\\n\",\n\t\tiq_no, iq->doorbell_reg, iq->inst_cnt_reg);\n\n\t \n\tpkt_in_done = readq(iq->inst_cnt_reg);\n\n\tif (oct->msix_on) {\n\t\t \n\t\twriteq((pkt_in_done | CN23XX_INTR_CINT_ENB),\n\t\t       iq->inst_cnt_reg);\n\t} else {\n\t\t \n\t\twriteq(pkt_in_done, iq->inst_cnt_reg);\n\t}\n\n\tiq->reset_instr_cnt = 0;\n}\n\nstatic void cn23xx_setup_oq_regs(struct octeon_device *oct, u32 oq_no)\n{\n\tu32 reg_val;\n\tstruct octeon_droq *droq = oct->droq[oq_no];\n\tstruct octeon_cn23xx_pf *cn23xx = (struct octeon_cn23xx_pf *)oct->chip;\n\tu64 time_threshold;\n\tu64 cnt_threshold;\n\n\toq_no += oct->sriov_info.pf_srn;\n\n\tocteon_write_csr64(oct, CN23XX_SLI_OQ_BASE_ADDR64(oq_no),\n\t\t\t   droq->desc_ring_dma);\n\tocteon_write_csr(oct, CN23XX_SLI_OQ_SIZE(oq_no), droq->max_count);\n\n\tocteon_write_csr(oct, CN23XX_SLI_OQ_BUFF_INFO_SIZE(oq_no),\n\t\t\t droq->buffer_size);\n\n\t \n\tdroq->pkts_sent_reg =\n\t    (u8 *)oct->mmio[0].hw_addr + CN23XX_SLI_OQ_PKTS_SENT(oq_no);\n\tdroq->pkts_credit_reg =\n\t    (u8 *)oct->mmio[0].hw_addr + CN23XX_SLI_OQ_PKTS_CREDIT(oq_no);\n\n\tif (!oct->msix_on) {\n\t\t \n\t\treg_val =\n\t\t    octeon_read_csr(oct, CN23XX_SLI_OQ_PKT_CONTROL(oq_no));\n\t\treg_val |= CN23XX_PKT_OUTPUT_CTL_TENB;\n\t\tocteon_write_csr(oct, CN23XX_SLI_OQ_PKT_CONTROL(oq_no),\n\t\t\t\t reg_val);\n\n\t\t \n\t\treg_val =\n\t\t    octeon_read_csr(oct, CN23XX_SLI_OQ_PKT_CONTROL(oq_no));\n\t\treg_val |= CN23XX_PKT_OUTPUT_CTL_CENB;\n\t\tocteon_write_csr(oct, CN23XX_SLI_OQ_PKT_CONTROL(oq_no),\n\t\t\t\t reg_val);\n\t} else {\n\t\ttime_threshold = cn23xx_pf_get_oq_ticks(\n\t\t    oct, (u32)CFG_GET_OQ_INTR_TIME(cn23xx->conf));\n\t\tcnt_threshold = (u32)CFG_GET_OQ_INTR_PKT(cn23xx->conf);\n\n\t\tocteon_write_csr64(\n\t\t    oct, CN23XX_SLI_OQ_PKT_INT_LEVELS(oq_no),\n\t\t    ((time_threshold << 32 | cnt_threshold)));\n\t}\n}\n\nstatic void cn23xx_pf_mbox_thread(struct work_struct *work)\n{\n\tstruct cavium_wk *wk = (struct cavium_wk *)work;\n\tstruct octeon_mbox *mbox = (struct octeon_mbox *)wk->ctxptr;\n\tstruct octeon_device *oct = mbox->oct_dev;\n\tu64 mbox_int_val, val64;\n\tu32 q_no, i;\n\n\tif (oct->rev_id < OCTEON_CN23XX_REV_1_1) {\n\t\t \n\t\tmbox_int_val = readq(mbox->mbox_int_reg);\n\t\twriteq(mbox_int_val, mbox->mbox_int_reg);\n\n\t\tfor (i = 0; i < oct->sriov_info.num_vfs_alloced; i++) {\n\t\t\tq_no = i * oct->sriov_info.rings_per_vf;\n\n\t\t\tval64 = readq(oct->mbox[q_no]->mbox_write_reg);\n\n\t\t\tif (val64 && (val64 != OCTEON_PFVFACK)) {\n\t\t\t\tif (octeon_mbox_read(oct->mbox[q_no]))\n\t\t\t\t\tocteon_mbox_process_message(\n\t\t\t\t\t    oct->mbox[q_no]);\n\t\t\t}\n\t\t}\n\n\t\tschedule_delayed_work(&wk->work, msecs_to_jiffies(10));\n\t} else {\n\t\tocteon_mbox_process_message(mbox);\n\t}\n}\n\nstatic int cn23xx_setup_pf_mbox(struct octeon_device *oct)\n{\n\tstruct octeon_mbox *mbox = NULL;\n\tu16 mac_no = oct->pcie_port;\n\tu16 pf_num = oct->pf_num;\n\tu32 q_no, i;\n\n\tif (!oct->sriov_info.max_vfs)\n\t\treturn 0;\n\n\tfor (i = 0; i < oct->sriov_info.max_vfs; i++) {\n\t\tq_no = i * oct->sriov_info.rings_per_vf;\n\n\t\tmbox = vzalloc(sizeof(*mbox));\n\t\tif (!mbox)\n\t\t\tgoto free_mbox;\n\n\t\tspin_lock_init(&mbox->lock);\n\n\t\tmbox->oct_dev = oct;\n\n\t\tmbox->q_no = q_no;\n\n\t\tmbox->state = OCTEON_MBOX_STATE_IDLE;\n\n\t\t \n\t\tmbox->mbox_int_reg = (u8 *)oct->mmio[0].hw_addr +\n\t\t\t\t     CN23XX_SLI_MAC_PF_MBOX_INT(mac_no, pf_num);\n\n\t\t \n\t\tmbox->mbox_write_reg = (u8 *)oct->mmio[0].hw_addr +\n\t\t\t\t       CN23XX_SLI_PKT_PF_VF_MBOX_SIG(q_no, 0);\n\n\t\t \n\t\tmbox->mbox_read_reg = (u8 *)oct->mmio[0].hw_addr +\n\t\t\t\t      CN23XX_SLI_PKT_PF_VF_MBOX_SIG(q_no, 1);\n\n\t\t \n\t\tINIT_DELAYED_WORK(&mbox->mbox_poll_wk.work,\n\t\t\t\t  cn23xx_pf_mbox_thread);\n\t\tmbox->mbox_poll_wk.ctxptr = (void *)mbox;\n\n\t\toct->mbox[q_no] = mbox;\n\n\t\twriteq(OCTEON_PFVFSIG, mbox->mbox_read_reg);\n\t}\n\n\tif (oct->rev_id < OCTEON_CN23XX_REV_1_1)\n\t\tschedule_delayed_work(&oct->mbox[0]->mbox_poll_wk.work,\n\t\t\t\t      msecs_to_jiffies(0));\n\n\treturn 0;\n\nfree_mbox:\n\twhile (i) {\n\t\ti--;\n\t\tvfree(oct->mbox[i]);\n\t}\n\n\treturn 1;\n}\n\nstatic int cn23xx_free_pf_mbox(struct octeon_device *oct)\n{\n\tu32 q_no, i;\n\n\tif (!oct->sriov_info.max_vfs)\n\t\treturn 0;\n\n\tfor (i = 0; i < oct->sriov_info.max_vfs; i++) {\n\t\tq_no = i * oct->sriov_info.rings_per_vf;\n\t\tcancel_delayed_work_sync(\n\t\t    &oct->mbox[q_no]->mbox_poll_wk.work);\n\t\tvfree(oct->mbox[q_no]);\n\t}\n\n\treturn 0;\n}\n\nstatic int cn23xx_enable_io_queues(struct octeon_device *oct)\n{\n\tu64 reg_val;\n\tu32 srn, ern, q_no;\n\tu32 loop = 1000;\n\n\tsrn = oct->sriov_info.pf_srn;\n\tern = srn + oct->num_iqs;\n\n\tfor (q_no = srn; q_no < ern; q_no++) {\n\t\t \n\t\tif (oct->io_qmask.iq64B & BIT_ULL(q_no - srn)) {\n\t\t\treg_val = octeon_read_csr64(\n\t\t\t    oct, CN23XX_SLI_IQ_PKT_CONTROL64(q_no));\n\t\t\treg_val = reg_val | CN23XX_PKT_INPUT_CTL_IS_64B;\n\t\t\tocteon_write_csr64(\n\t\t\t    oct, CN23XX_SLI_IQ_PKT_CONTROL64(q_no), reg_val);\n\t\t}\n\n\t\t \n\t\tif (oct->io_qmask.iq & BIT_ULL(q_no - srn)) {\n\t\t\t \n\t\t\treg_val = octeon_read_csr64(\n\t\t\t    oct, CN23XX_SLI_IQ_PKT_CONTROL64(q_no));\n\n\t\t\tif (reg_val & CN23XX_PKT_INPUT_CTL_RST) {\n\t\t\t\twhile ((reg_val & CN23XX_PKT_INPUT_CTL_RST) &&\n\t\t\t\t       !(reg_val &\n\t\t\t\t\t CN23XX_PKT_INPUT_CTL_QUIET) &&\n\t\t\t\t       --loop) {\n\t\t\t\t\treg_val = octeon_read_csr64(\n\t\t\t\t\t    oct,\n\t\t\t\t\t    CN23XX_SLI_IQ_PKT_CONTROL64(q_no));\n\t\t\t\t}\n\t\t\t\tif (!loop) {\n\t\t\t\t\tdev_err(&oct->pci_dev->dev,\n\t\t\t\t\t\t\"clearing the reset reg failed or setting the quiet reg failed for qno: %u\\n\",\n\t\t\t\t\t\tq_no);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\treg_val = reg_val & ~CN23XX_PKT_INPUT_CTL_RST;\n\t\t\t\tocteon_write_csr64(\n\t\t\t\t    oct, CN23XX_SLI_IQ_PKT_CONTROL64(q_no),\n\t\t\t\t    reg_val);\n\n\t\t\t\treg_val = octeon_read_csr64(\n\t\t\t\t    oct, CN23XX_SLI_IQ_PKT_CONTROL64(q_no));\n\t\t\t\tif (reg_val & CN23XX_PKT_INPUT_CTL_RST) {\n\t\t\t\t\tdev_err(&oct->pci_dev->dev,\n\t\t\t\t\t\t\"clearing the reset failed for qno: %u\\n\",\n\t\t\t\t\t\tq_no);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\treg_val = octeon_read_csr64(\n\t\t\t    oct, CN23XX_SLI_IQ_PKT_CONTROL64(q_no));\n\t\t\treg_val = reg_val | CN23XX_PKT_INPUT_CTL_RING_ENB;\n\t\t\tocteon_write_csr64(\n\t\t\t    oct, CN23XX_SLI_IQ_PKT_CONTROL64(q_no), reg_val);\n\t\t}\n\t}\n\tfor (q_no = srn; q_no < ern; q_no++) {\n\t\tu32 reg_val;\n\t\t \n\t\tif (oct->io_qmask.oq & BIT_ULL(q_no - srn)) {\n\t\t\treg_val = octeon_read_csr(\n\t\t\t    oct, CN23XX_SLI_OQ_PKT_CONTROL(q_no));\n\t\t\treg_val = reg_val | CN23XX_PKT_OUTPUT_CTL_RING_ENB;\n\t\t\tocteon_write_csr(oct, CN23XX_SLI_OQ_PKT_CONTROL(q_no),\n\t\t\t\t\t reg_val);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void cn23xx_disable_io_queues(struct octeon_device *oct)\n{\n\tint q_no, loop;\n\tu64 d64;\n\tu32 d32;\n\tu32 srn, ern;\n\n\tsrn = oct->sriov_info.pf_srn;\n\tern = srn + oct->num_iqs;\n\n\t \n\tfor (q_no = srn; q_no < ern; q_no++) {\n\t\tloop = HZ;\n\n\t\t \n\t\tWRITE_ONCE(d64, octeon_read_csr64(\n\t\t\t   oct, CN23XX_SLI_IQ_PKT_CONTROL64(q_no)));\n\t\tWRITE_ONCE(d64, READ_ONCE(d64) &\n\t\t\t\t\t(~(CN23XX_PKT_INPUT_CTL_RING_ENB)));\n\t\tWRITE_ONCE(d64, READ_ONCE(d64) | CN23XX_PKT_INPUT_CTL_RST);\n\t\tocteon_write_csr64(oct, CN23XX_SLI_IQ_PKT_CONTROL64(q_no),\n\t\t\t\t   READ_ONCE(d64));\n\n\t\t \n\t\tWRITE_ONCE(d64, octeon_read_csr64(\n\t\t\t\t\toct, CN23XX_SLI_PKT_IOQ_RING_RST));\n\t\twhile (!(READ_ONCE(d64) & BIT_ULL(q_no)) && loop--) {\n\t\t\tWRITE_ONCE(d64, octeon_read_csr64(\n\t\t\t\t\toct, CN23XX_SLI_PKT_IOQ_RING_RST));\n\t\t\tschedule_timeout_uninterruptible(1);\n\t\t}\n\n\t\t \n\t\tocteon_write_csr(oct, CN23XX_SLI_IQ_DOORBELL(q_no), 0xFFFFFFFF);\n\t\twhile (octeon_read_csr64(oct, CN23XX_SLI_IQ_DOORBELL(q_no)) &&\n\t\t       loop--) {\n\t\t\tschedule_timeout_uninterruptible(1);\n\t\t}\n\t}\n\n\t \n\tfor (q_no = srn; q_no < ern; q_no++) {\n\t\tloop = HZ;\n\n\t\t \n\t\tWRITE_ONCE(d64, octeon_read_csr64(\n\t\t\t\t\toct, CN23XX_SLI_PKT_IOQ_RING_RST));\n\t\twhile (!(READ_ONCE(d64) & BIT_ULL(q_no)) && loop--) {\n\t\t\tWRITE_ONCE(d64, octeon_read_csr64(\n\t\t\t\t\toct, CN23XX_SLI_PKT_IOQ_RING_RST));\n\t\t\tschedule_timeout_uninterruptible(1);\n\t\t}\n\n\t\t \n\t\tocteon_write_csr(oct, CN23XX_SLI_OQ_PKTS_CREDIT(q_no),\n\t\t\t\t 0xFFFFFFFF);\n\t\twhile (octeon_read_csr64(oct,\n\t\t\t\t\t CN23XX_SLI_OQ_PKTS_CREDIT(q_no)) &&\n\t\t       loop--) {\n\t\t\tschedule_timeout_uninterruptible(1);\n\t\t}\n\n\t\t \n\t\tWRITE_ONCE(d32, octeon_read_csr(\n\t\t\t\t\toct, CN23XX_SLI_OQ_PKTS_SENT(q_no)));\n\t\tocteon_write_csr(oct, CN23XX_SLI_OQ_PKTS_SENT(q_no),\n\t\t\t\t READ_ONCE(d32));\n\t}\n}\n\nstatic u64 cn23xx_pf_msix_interrupt_handler(void *dev)\n{\n\tstruct octeon_ioq_vector *ioq_vector = (struct octeon_ioq_vector *)dev;\n\tstruct octeon_device *oct = ioq_vector->oct_dev;\n\tu64 pkts_sent;\n\tu64 ret = 0;\n\tstruct octeon_droq *droq = oct->droq[ioq_vector->droq_index];\n\n\tdev_dbg(&oct->pci_dev->dev, \"In %s octeon_dev @ %p\\n\", __func__, oct);\n\n\tif (!droq) {\n\t\tdev_err(&oct->pci_dev->dev, \"23XX bringup FIXME: oct pfnum:%d ioq_vector->ioq_num :%d droq is NULL\\n\",\n\t\t\toct->pf_num, ioq_vector->ioq_num);\n\t\treturn 0;\n\t}\n\n\tpkts_sent = readq(droq->pkts_sent_reg);\n\n\t \n\tif (!pkts_sent || (pkts_sent == 0xFFFFFFFFFFFFFFFFULL))\n\t\treturn ret;\n\n\t \n\tif ((pkts_sent & CN23XX_INTR_PO_INT) ||\n\t    (pkts_sent & CN23XX_INTR_PI_INT)) {\n\t\tif (pkts_sent & CN23XX_INTR_PO_INT)\n\t\t\tret |= MSIX_PO_INT;\n\t}\n\n\tif (pkts_sent & CN23XX_INTR_PI_INT)\n\t\t \n\t\tret |= MSIX_PI_INT;\n\n\t \n\treturn ret;\n}\n\nstatic void cn23xx_handle_pf_mbox_intr(struct octeon_device *oct)\n{\n\tstruct delayed_work *work;\n\tu64 mbox_int_val;\n\tu32 i, q_no;\n\n\tmbox_int_val = readq(oct->mbox[0]->mbox_int_reg);\n\n\tfor (i = 0; i < oct->sriov_info.num_vfs_alloced; i++) {\n\t\tq_no = i * oct->sriov_info.rings_per_vf;\n\n\t\tif (mbox_int_val & BIT_ULL(q_no)) {\n\t\t\twriteq(BIT_ULL(q_no),\n\t\t\t       oct->mbox[0]->mbox_int_reg);\n\t\t\tif (octeon_mbox_read(oct->mbox[q_no])) {\n\t\t\t\twork = &oct->mbox[q_no]->mbox_poll_wk.work;\n\t\t\t\tschedule_delayed_work(work,\n\t\t\t\t\t\t      msecs_to_jiffies(0));\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic irqreturn_t cn23xx_interrupt_handler(void *dev)\n{\n\tstruct octeon_device *oct = (struct octeon_device *)dev;\n\tstruct octeon_cn23xx_pf *cn23xx = (struct octeon_cn23xx_pf *)oct->chip;\n\tu64 intr64;\n\n\tdev_dbg(&oct->pci_dev->dev, \"In %s octeon_dev @ %p\\n\", __func__, oct);\n\tintr64 = readq(cn23xx->intr_sum_reg64);\n\n\toct->int_status = 0;\n\n\tif (intr64 & CN23XX_INTR_ERR)\n\t\tdev_err(&oct->pci_dev->dev, \"OCTEON[%d]: Error Intr: 0x%016llx\\n\",\n\t\t\toct->octeon_id, CVM_CAST64(intr64));\n\n\t \n\tif (intr64 & CN23XX_INTR_VF_MBOX)\n\t\tcn23xx_handle_pf_mbox_intr(oct);\n\n\tif (oct->msix_on != LIO_FLAG_MSIX_ENABLED) {\n\t\tif (intr64 & CN23XX_INTR_PKT_DATA)\n\t\t\toct->int_status |= OCT_DEV_INTR_PKT_DATA;\n\t}\n\n\tif (intr64 & (CN23XX_INTR_DMA0_FORCE))\n\t\toct->int_status |= OCT_DEV_INTR_DMA0_FORCE;\n\tif (intr64 & (CN23XX_INTR_DMA1_FORCE))\n\t\toct->int_status |= OCT_DEV_INTR_DMA1_FORCE;\n\n\t \n\twriteq(intr64, cn23xx->intr_sum_reg64);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void cn23xx_bar1_idx_setup(struct octeon_device *oct, u64 core_addr,\n\t\t\t\t  u32 idx, int valid)\n{\n\tu64 bar1;\n\tu64 reg_adr;\n\n\tif (!valid) {\n\t\treg_adr = lio_pci_readq(\n\t\t\toct, CN23XX_PEM_BAR1_INDEX_REG(oct->pcie_port, idx));\n\t\tWRITE_ONCE(bar1, reg_adr);\n\t\tlio_pci_writeq(oct, (READ_ONCE(bar1) & 0xFFFFFFFEULL),\n\t\t\t       CN23XX_PEM_BAR1_INDEX_REG(oct->pcie_port, idx));\n\t\treg_adr = lio_pci_readq(\n\t\t\toct, CN23XX_PEM_BAR1_INDEX_REG(oct->pcie_port, idx));\n\t\tWRITE_ONCE(bar1, reg_adr);\n\t\treturn;\n\t}\n\n\t \n\tlio_pci_writeq(oct, (((core_addr >> 22) << 4) | PCI_BAR1_MASK),\n\t\t       CN23XX_PEM_BAR1_INDEX_REG(oct->pcie_port, idx));\n\n\tWRITE_ONCE(bar1, lio_pci_readq(\n\t\t   oct, CN23XX_PEM_BAR1_INDEX_REG(oct->pcie_port, idx)));\n}\n\nstatic void cn23xx_bar1_idx_write(struct octeon_device *oct, u32 idx, u32 mask)\n{\n\tlio_pci_writeq(oct, mask,\n\t\t       CN23XX_PEM_BAR1_INDEX_REG(oct->pcie_port, idx));\n}\n\nstatic u32 cn23xx_bar1_idx_read(struct octeon_device *oct, u32 idx)\n{\n\treturn (u32)lio_pci_readq(\n\t    oct, CN23XX_PEM_BAR1_INDEX_REG(oct->pcie_port, idx));\n}\n\n \nstatic u32 cn23xx_update_read_index(struct octeon_instr_queue *iq)\n{\n\tu32 new_idx;\n\tu32 last_done;\n\tu32 pkt_in_done = readl(iq->inst_cnt_reg);\n\n\tlast_done = pkt_in_done - iq->pkt_in_done;\n\tiq->pkt_in_done = pkt_in_done;\n\n\t \n\tnew_idx = (iq->octeon_read_index +\n\t\t   (u32)(last_done & CN23XX_PKT_IN_DONE_CNT_MASK)) %\n\t\t  iq->max_count;\n\n\treturn new_idx;\n}\n\nstatic void cn23xx_enable_pf_interrupt(struct octeon_device *oct, u8 intr_flag)\n{\n\tstruct octeon_cn23xx_pf *cn23xx = (struct octeon_cn23xx_pf *)oct->chip;\n\tu64 intr_val = 0;\n\n\t \n\t \n\tif (intr_flag == OCTEON_ALL_INTR) {\n\t\twriteq(cn23xx->intr_mask64, cn23xx->intr_enb_reg64);\n\t} else if (intr_flag & OCTEON_OUTPUT_INTR) {\n\t\tintr_val = readq(cn23xx->intr_enb_reg64);\n\t\tintr_val |= CN23XX_INTR_PKT_DATA;\n\t\twriteq(intr_val, cn23xx->intr_enb_reg64);\n\t} else if ((intr_flag & OCTEON_MBOX_INTR) &&\n\t\t   (oct->sriov_info.max_vfs > 0)) {\n\t\tif (oct->rev_id >= OCTEON_CN23XX_REV_1_1) {\n\t\t\tintr_val = readq(cn23xx->intr_enb_reg64);\n\t\t\tintr_val |= CN23XX_INTR_VF_MBOX;\n\t\t\twriteq(intr_val, cn23xx->intr_enb_reg64);\n\t\t}\n\t}\n}\n\nstatic void cn23xx_disable_pf_interrupt(struct octeon_device *oct, u8 intr_flag)\n{\n\tstruct octeon_cn23xx_pf *cn23xx = (struct octeon_cn23xx_pf *)oct->chip;\n\tu64 intr_val = 0;\n\n\t \n\tif (intr_flag == OCTEON_ALL_INTR) {\n\t\twriteq(0, cn23xx->intr_enb_reg64);\n\t} else if (intr_flag & OCTEON_OUTPUT_INTR) {\n\t\tintr_val = readq(cn23xx->intr_enb_reg64);\n\t\tintr_val &= ~CN23XX_INTR_PKT_DATA;\n\t\twriteq(intr_val, cn23xx->intr_enb_reg64);\n\t} else if ((intr_flag & OCTEON_MBOX_INTR) &&\n\t\t   (oct->sriov_info.max_vfs > 0)) {\n\t\tif (oct->rev_id >= OCTEON_CN23XX_REV_1_1) {\n\t\t\tintr_val = readq(cn23xx->intr_enb_reg64);\n\t\t\tintr_val &= ~CN23XX_INTR_VF_MBOX;\n\t\t\twriteq(intr_val, cn23xx->intr_enb_reg64);\n\t\t}\n\t}\n}\n\nstatic void cn23xx_get_pcie_qlmport(struct octeon_device *oct)\n{\n\toct->pcie_port = (octeon_read_csr(oct, CN23XX_SLI_MAC_NUMBER)) & 0xff;\n\n\tdev_dbg(&oct->pci_dev->dev, \"OCTEON: CN23xx uses PCIE Port %d\\n\",\n\t\toct->pcie_port);\n}\n\nstatic int cn23xx_get_pf_num(struct octeon_device *oct)\n{\n\tu32 fdl_bit = 0;\n\tu64 pkt0_in_ctl, d64;\n\tint pfnum, mac, trs, ret;\n\n\tret = 0;\n\n\t \n\tif (pci_read_config_dword(oct->pci_dev, CN23XX_PCIE_SRIOV_FDL,\n\t\t\t\t  &fdl_bit) == 0) {\n\t\toct->pf_num = ((fdl_bit >> CN23XX_PCIE_SRIOV_FDL_BIT_POS) &\n\t\t\t       CN23XX_PCIE_SRIOV_FDL_MASK);\n\t} else {\n\t\tret = -EINVAL;\n\n\t\t \n\t\tpkt0_in_ctl = octeon_read_csr64(oct,\n\t\t\t\t\t\tCN23XX_SLI_IQ_PKT_CONTROL64(0));\n\t\tpfnum = (pkt0_in_ctl >> CN23XX_PKT_INPUT_CTL_PF_NUM_POS) &\n\t\t\tCN23XX_PKT_INPUT_CTL_PF_NUM_MASK;\n\t\tmac = (octeon_read_csr(oct, CN23XX_SLI_MAC_NUMBER)) & 0xff;\n\n\t\t \n\t\td64 = octeon_read_csr64(oct,\n\t\t\t\t\tCN23XX_SLI_PKT_MAC_RINFO64(mac, pfnum));\n\t\ttrs = (int)(d64 >> CN23XX_PKT_MAC_CTL_RINFO_TRS_BIT_POS) & 0xff;\n\t\tif (trs == 1) {\n\t\t\tdev_err(&oct->pci_dev->dev,\n\t\t\t\t\"OCTEON: error reading PCI cfg space pfnum, re-read %u\\n\",\n\t\t\t\tpfnum);\n\t\t\toct->pf_num = pfnum;\n\t\t\tret = 0;\n\t\t} else {\n\t\t\tdev_err(&oct->pci_dev->dev,\n\t\t\t\t\"OCTEON: error reading PCI cfg space pfnum; could not ascertain PF number\\n\");\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic void cn23xx_setup_reg_address(struct octeon_device *oct)\n{\n\tu8 __iomem *bar0_pciaddr = oct->mmio[0].hw_addr;\n\tstruct octeon_cn23xx_pf *cn23xx = (struct octeon_cn23xx_pf *)oct->chip;\n\n\toct->reg_list.pci_win_wr_addr_hi =\n\t    (u32 __iomem *)(bar0_pciaddr + CN23XX_WIN_WR_ADDR_HI);\n\toct->reg_list.pci_win_wr_addr_lo =\n\t    (u32 __iomem *)(bar0_pciaddr + CN23XX_WIN_WR_ADDR_LO);\n\toct->reg_list.pci_win_wr_addr =\n\t    (u64 __iomem *)(bar0_pciaddr + CN23XX_WIN_WR_ADDR64);\n\n\toct->reg_list.pci_win_rd_addr_hi =\n\t    (u32 __iomem *)(bar0_pciaddr + CN23XX_WIN_RD_ADDR_HI);\n\toct->reg_list.pci_win_rd_addr_lo =\n\t    (u32 __iomem *)(bar0_pciaddr + CN23XX_WIN_RD_ADDR_LO);\n\toct->reg_list.pci_win_rd_addr =\n\t    (u64 __iomem *)(bar0_pciaddr + CN23XX_WIN_RD_ADDR64);\n\n\toct->reg_list.pci_win_wr_data_hi =\n\t    (u32 __iomem *)(bar0_pciaddr + CN23XX_WIN_WR_DATA_HI);\n\toct->reg_list.pci_win_wr_data_lo =\n\t    (u32 __iomem *)(bar0_pciaddr + CN23XX_WIN_WR_DATA_LO);\n\toct->reg_list.pci_win_wr_data =\n\t    (u64 __iomem *)(bar0_pciaddr + CN23XX_WIN_WR_DATA64);\n\n\toct->reg_list.pci_win_rd_data_hi =\n\t    (u32 __iomem *)(bar0_pciaddr + CN23XX_WIN_RD_DATA_HI);\n\toct->reg_list.pci_win_rd_data_lo =\n\t    (u32 __iomem *)(bar0_pciaddr + CN23XX_WIN_RD_DATA_LO);\n\toct->reg_list.pci_win_rd_data =\n\t    (u64 __iomem *)(bar0_pciaddr + CN23XX_WIN_RD_DATA64);\n\n\tcn23xx_get_pcie_qlmport(oct);\n\n\tcn23xx->intr_mask64 = CN23XX_INTR_MASK;\n\tif (!oct->msix_on)\n\t\tcn23xx->intr_mask64 |= CN23XX_INTR_PKT_TIME;\n\tif (oct->rev_id >= OCTEON_CN23XX_REV_1_1)\n\t\tcn23xx->intr_mask64 |= CN23XX_INTR_VF_MBOX;\n\n\tcn23xx->intr_sum_reg64 =\n\t    bar0_pciaddr +\n\t    CN23XX_SLI_MAC_PF_INT_SUM64(oct->pcie_port, oct->pf_num);\n\tcn23xx->intr_enb_reg64 =\n\t    bar0_pciaddr +\n\t    CN23XX_SLI_MAC_PF_INT_ENB64(oct->pcie_port, oct->pf_num);\n}\n\nint cn23xx_sriov_config(struct octeon_device *oct)\n{\n\tstruct octeon_cn23xx_pf *cn23xx = (struct octeon_cn23xx_pf *)oct->chip;\n\tu32 max_rings, total_rings, max_vfs, rings_per_vf;\n\tu32 pf_srn, num_pf_rings;\n\tu32 max_possible_vfs;\n\n\tcn23xx->conf =\n\t\t(struct octeon_config *)oct_get_config_info(oct, LIO_23XX);\n\tswitch (oct->rev_id) {\n\tcase OCTEON_CN23XX_REV_1_0:\n\t\tmax_rings = CN23XX_MAX_RINGS_PER_PF_PASS_1_0;\n\t\tmax_possible_vfs = CN23XX_MAX_VFS_PER_PF_PASS_1_0;\n\t\tbreak;\n\tcase OCTEON_CN23XX_REV_1_1:\n\t\tmax_rings = CN23XX_MAX_RINGS_PER_PF_PASS_1_1;\n\t\tmax_possible_vfs = CN23XX_MAX_VFS_PER_PF_PASS_1_1;\n\t\tbreak;\n\tdefault:\n\t\tmax_rings = CN23XX_MAX_RINGS_PER_PF;\n\t\tmax_possible_vfs = CN23XX_MAX_VFS_PER_PF;\n\t\tbreak;\n\t}\n\n\tif (oct->sriov_info.num_pf_rings)\n\t\tnum_pf_rings = oct->sriov_info.num_pf_rings;\n\telse\n\t\tnum_pf_rings = num_present_cpus();\n\n#ifdef CONFIG_PCI_IOV\n\tmax_vfs = min_t(u32,\n\t\t\t(max_rings - num_pf_rings), max_possible_vfs);\n\trings_per_vf = 1;\n#else\n\tmax_vfs = 0;\n\trings_per_vf = 0;\n#endif\n\n\ttotal_rings = num_pf_rings + max_vfs;\n\n\t \n\tpf_srn = total_rings - num_pf_rings;\n\n\toct->sriov_info.trs = total_rings;\n\toct->sriov_info.max_vfs = max_vfs;\n\toct->sriov_info.rings_per_vf = rings_per_vf;\n\toct->sriov_info.pf_srn = pf_srn;\n\toct->sriov_info.num_pf_rings = num_pf_rings;\n\tdev_notice(&oct->pci_dev->dev, \"trs:%d max_vfs:%d rings_per_vf:%d pf_srn:%d num_pf_rings:%d\\n\",\n\t\t   oct->sriov_info.trs, oct->sriov_info.max_vfs,\n\t\t   oct->sriov_info.rings_per_vf, oct->sriov_info.pf_srn,\n\t\t   oct->sriov_info.num_pf_rings);\n\n\toct->sriov_info.sriov_enabled = 0;\n\n\treturn 0;\n}\n\nint setup_cn23xx_octeon_pf_device(struct octeon_device *oct)\n{\n\tu32 data32;\n\tu64 BAR0, BAR1;\n\n\tpci_read_config_dword(oct->pci_dev, PCI_BASE_ADDRESS_0, &data32);\n\tBAR0 = (u64)(data32 & ~0xf);\n\tpci_read_config_dword(oct->pci_dev, PCI_BASE_ADDRESS_1, &data32);\n\tBAR0 |= ((u64)data32 << 32);\n\tpci_read_config_dword(oct->pci_dev, PCI_BASE_ADDRESS_2, &data32);\n\tBAR1 = (u64)(data32 & ~0xf);\n\tpci_read_config_dword(oct->pci_dev, PCI_BASE_ADDRESS_3, &data32);\n\tBAR1 |= ((u64)data32 << 32);\n\n\tif (!BAR0 || !BAR1) {\n\t\tif (!BAR0)\n\t\t\tdev_err(&oct->pci_dev->dev, \"device BAR0 unassigned\\n\");\n\t\tif (!BAR1)\n\t\t\tdev_err(&oct->pci_dev->dev, \"device BAR1 unassigned\\n\");\n\t\treturn 1;\n\t}\n\n\tif (octeon_map_pci_barx(oct, 0, 0))\n\t\treturn 1;\n\n\tif (octeon_map_pci_barx(oct, 1, MAX_BAR1_IOREMAP_SIZE)) {\n\t\tdev_err(&oct->pci_dev->dev, \"%s CN23XX BAR1 map failed\\n\",\n\t\t\t__func__);\n\t\tocteon_unmap_pci_barx(oct, 0);\n\t\treturn 1;\n\t}\n\n\tif (cn23xx_get_pf_num(oct) != 0)\n\t\treturn 1;\n\n\tif (cn23xx_sriov_config(oct)) {\n\t\tocteon_unmap_pci_barx(oct, 0);\n\t\tocteon_unmap_pci_barx(oct, 1);\n\t\treturn 1;\n\t}\n\n\tocteon_write_csr64(oct, CN23XX_SLI_MAC_CREDIT_CNT, 0x3F802080802080ULL);\n\n\toct->fn_list.setup_iq_regs = cn23xx_setup_iq_regs;\n\toct->fn_list.setup_oq_regs = cn23xx_setup_oq_regs;\n\toct->fn_list.setup_mbox = cn23xx_setup_pf_mbox;\n\toct->fn_list.free_mbox = cn23xx_free_pf_mbox;\n\n\toct->fn_list.process_interrupt_regs = cn23xx_interrupt_handler;\n\toct->fn_list.msix_interrupt_handler = cn23xx_pf_msix_interrupt_handler;\n\n\toct->fn_list.soft_reset = cn23xx_pf_soft_reset;\n\toct->fn_list.setup_device_regs = cn23xx_setup_pf_device_regs;\n\toct->fn_list.update_iq_read_idx = cn23xx_update_read_index;\n\n\toct->fn_list.bar1_idx_setup = cn23xx_bar1_idx_setup;\n\toct->fn_list.bar1_idx_write = cn23xx_bar1_idx_write;\n\toct->fn_list.bar1_idx_read = cn23xx_bar1_idx_read;\n\n\toct->fn_list.enable_interrupt = cn23xx_enable_pf_interrupt;\n\toct->fn_list.disable_interrupt = cn23xx_disable_pf_interrupt;\n\n\toct->fn_list.enable_io_queues = cn23xx_enable_io_queues;\n\toct->fn_list.disable_io_queues = cn23xx_disable_io_queues;\n\n\tcn23xx_setup_reg_address(oct);\n\n\toct->coproc_clock_rate = 1000000ULL * cn23xx_coprocessor_clock(oct);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(setup_cn23xx_octeon_pf_device);\n\nint validate_cn23xx_pf_config_info(struct octeon_device *oct,\n\t\t\t\t   struct octeon_config *conf23xx)\n{\n\tif (CFG_GET_IQ_MAX_Q(conf23xx) > CN23XX_MAX_INPUT_QUEUES) {\n\t\tdev_err(&oct->pci_dev->dev, \"%s: Num IQ (%d) exceeds Max (%d)\\n\",\n\t\t\t__func__, CFG_GET_IQ_MAX_Q(conf23xx),\n\t\t\tCN23XX_MAX_INPUT_QUEUES);\n\t\treturn 1;\n\t}\n\n\tif (CFG_GET_OQ_MAX_Q(conf23xx) > CN23XX_MAX_OUTPUT_QUEUES) {\n\t\tdev_err(&oct->pci_dev->dev, \"%s: Num OQ (%d) exceeds Max (%d)\\n\",\n\t\t\t__func__, CFG_GET_OQ_MAX_Q(conf23xx),\n\t\t\tCN23XX_MAX_OUTPUT_QUEUES);\n\t\treturn 1;\n\t}\n\n\tif (CFG_GET_IQ_INSTR_TYPE(conf23xx) != OCTEON_32BYTE_INSTR &&\n\t    CFG_GET_IQ_INSTR_TYPE(conf23xx) != OCTEON_64BYTE_INSTR) {\n\t\tdev_err(&oct->pci_dev->dev, \"%s: Invalid instr type for IQ\\n\",\n\t\t\t__func__);\n\t\treturn 1;\n\t}\n\n\tif (!CFG_GET_OQ_REFILL_THRESHOLD(conf23xx)) {\n\t\tdev_err(&oct->pci_dev->dev, \"%s: Invalid parameter for OQ\\n\",\n\t\t\t__func__);\n\t\treturn 1;\n\t}\n\n\tif (!(CFG_GET_OQ_INTR_TIME(conf23xx))) {\n\t\tdev_err(&oct->pci_dev->dev, \"%s: Invalid parameter for OQ\\n\",\n\t\t\t__func__);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nint cn23xx_fw_loaded(struct octeon_device *oct)\n{\n\tu64 val;\n\n\t \n\tif (atomic_read(oct->adapter_refcount) > 1)\n\t\treturn 1;\n\n\tval = octeon_read_csr64(oct, CN23XX_SLI_SCRATCH2);\n\treturn (val >> SCR2_BIT_FW_LOADED) & 1ULL;\n}\nEXPORT_SYMBOL_GPL(cn23xx_fw_loaded);\n\nvoid cn23xx_tell_vf_its_macaddr_changed(struct octeon_device *oct, int vfidx,\n\t\t\t\t\tu8 *mac)\n{\n\tif (oct->sriov_info.vf_drv_loaded_mask & BIT_ULL(vfidx)) {\n\t\tstruct octeon_mbox_cmd mbox_cmd;\n\n\t\tmbox_cmd.msg.u64 = 0;\n\t\tmbox_cmd.msg.s.type = OCTEON_MBOX_REQUEST;\n\t\tmbox_cmd.msg.s.resp_needed = 0;\n\t\tmbox_cmd.msg.s.cmd = OCTEON_PF_CHANGED_VF_MACADDR;\n\t\tmbox_cmd.msg.s.len = 1;\n\t\tmbox_cmd.recv_len = 0;\n\t\tmbox_cmd.recv_status = 0;\n\t\tmbox_cmd.fn = NULL;\n\t\tmbox_cmd.fn_arg = NULL;\n\t\tether_addr_copy(mbox_cmd.msg.s.params, mac);\n\t\tmbox_cmd.q_no = vfidx * oct->sriov_info.rings_per_vf;\n\t\tocteon_mbox_write(oct, &mbox_cmd);\n\t}\n}\nEXPORT_SYMBOL_GPL(cn23xx_tell_vf_its_macaddr_changed);\n\nstatic void\ncn23xx_get_vf_stats_callback(struct octeon_device *oct,\n\t\t\t     struct octeon_mbox_cmd *cmd, void *arg)\n{\n\tstruct oct_vf_stats_ctx *ctx = arg;\n\n\tmemcpy(ctx->stats, cmd->data, sizeof(struct oct_vf_stats));\n\tatomic_set(&ctx->status, 1);\n}\n\nint cn23xx_get_vf_stats(struct octeon_device *oct, int vfidx,\n\t\t\tstruct oct_vf_stats *stats)\n{\n\tu32 timeout = HZ; \n\tstruct octeon_mbox_cmd mbox_cmd;\n\tstruct oct_vf_stats_ctx ctx;\n\tu32 count = 0, ret;\n\n\tif (!(oct->sriov_info.vf_drv_loaded_mask & (1ULL << vfidx)))\n\t\treturn -1;\n\n\tif (sizeof(struct oct_vf_stats) > sizeof(mbox_cmd.data))\n\t\treturn -1;\n\n\tmbox_cmd.msg.u64 = 0;\n\tmbox_cmd.msg.s.type = OCTEON_MBOX_REQUEST;\n\tmbox_cmd.msg.s.resp_needed = 1;\n\tmbox_cmd.msg.s.cmd = OCTEON_GET_VF_STATS;\n\tmbox_cmd.msg.s.len = 1;\n\tmbox_cmd.q_no = vfidx * oct->sriov_info.rings_per_vf;\n\tmbox_cmd.recv_len = 0;\n\tmbox_cmd.recv_status = 0;\n\tmbox_cmd.fn = (octeon_mbox_callback_t)cn23xx_get_vf_stats_callback;\n\tctx.stats = stats;\n\tatomic_set(&ctx.status, 0);\n\tmbox_cmd.fn_arg = (void *)&ctx;\n\tmemset(mbox_cmd.data, 0, sizeof(mbox_cmd.data));\n\tocteon_mbox_write(oct, &mbox_cmd);\n\n\tdo {\n\t\tschedule_timeout_uninterruptible(1);\n\t} while ((atomic_read(&ctx.status) == 0) && (count++ < timeout));\n\n\tret = atomic_read(&ctx.status);\n\tif (ret == 0) {\n\t\tocteon_mbox_cancel(oct, 0);\n\t\tdev_err(&oct->pci_dev->dev, \"Unable to get stats from VF-%d, timedout\\n\",\n\t\t\tvfidx);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(cn23xx_get_vf_stats);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}