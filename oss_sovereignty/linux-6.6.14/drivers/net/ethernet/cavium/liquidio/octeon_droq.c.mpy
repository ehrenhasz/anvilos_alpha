{
  "module_name": "octeon_droq.c",
  "hash_id": "d7c862b8fdb91a36aa4038ebd59334849d201c90c7995ad232386114e378fe63",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/cavium/liquidio/octeon_droq.c",
  "human_readable_source": " \n#include <linux/pci.h>\n#include <linux/netdevice.h>\n#include <linux/vmalloc.h>\n#include \"liquidio_common.h\"\n#include \"octeon_droq.h\"\n#include \"octeon_iq.h\"\n#include \"response_manager.h\"\n#include \"octeon_device.h\"\n#include \"octeon_main.h\"\n#include \"octeon_network.h\"\n#include \"cn66xx_regs.h\"\n#include \"cn66xx_device.h\"\n#include \"cn23xx_pf_device.h\"\n#include \"cn23xx_vf_device.h\"\n\nstruct niclist {\n\tstruct list_head list;\n\tvoid *ptr;\n};\n\nstruct __dispatch {\n\tstruct list_head list;\n\tstruct octeon_recv_info *rinfo;\n\tocteon_dispatch_fn_t disp_fn;\n};\n\n \nvoid *octeon_get_dispatch_arg(struct octeon_device *octeon_dev,\n\t\t\t      u16 opcode, u16 subcode)\n{\n\tint idx;\n\tstruct list_head *dispatch;\n\tvoid *fn_arg = NULL;\n\tu16 combined_opcode = OPCODE_SUBCODE(opcode, subcode);\n\n\tidx = combined_opcode & OCTEON_OPCODE_MASK;\n\n\tspin_lock_bh(&octeon_dev->dispatch.lock);\n\n\tif (octeon_dev->dispatch.count == 0) {\n\t\tspin_unlock_bh(&octeon_dev->dispatch.lock);\n\t\treturn NULL;\n\t}\n\n\tif (octeon_dev->dispatch.dlist[idx].opcode == combined_opcode) {\n\t\tfn_arg = octeon_dev->dispatch.dlist[idx].arg;\n\t} else {\n\t\tlist_for_each(dispatch,\n\t\t\t      &octeon_dev->dispatch.dlist[idx].list) {\n\t\t\tif (((struct octeon_dispatch *)dispatch)->opcode ==\n\t\t\t    combined_opcode) {\n\t\t\t\tfn_arg = ((struct octeon_dispatch *)\n\t\t\t\t\t  dispatch)->arg;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tspin_unlock_bh(&octeon_dev->dispatch.lock);\n\treturn fn_arg;\n}\n\n \nu32 octeon_droq_check_hw_for_pkts(struct octeon_droq *droq)\n{\n\tu32 pkt_count = 0;\n\tu32 last_count;\n\n\tpkt_count = readl(droq->pkts_sent_reg);\n\n\tlast_count = pkt_count - droq->pkt_count;\n\tdroq->pkt_count = pkt_count;\n\n\t \n\tif (last_count)\n\t\tatomic_add(last_count, &droq->pkts_pending);\n\n\treturn last_count;\n}\nEXPORT_SYMBOL_GPL(octeon_droq_check_hw_for_pkts);\n\nstatic void octeon_droq_compute_max_packet_bufs(struct octeon_droq *droq)\n{\n\tu32 count = 0;\n\n\t \n\tdroq->max_empty_descs = 0;\n\n\tdo {\n\t\tdroq->max_empty_descs++;\n\t\tcount += droq->buffer_size;\n\t} while (count < (64 * 1024));\n\n\tdroq->max_empty_descs = droq->max_count - droq->max_empty_descs;\n}\n\nstatic void octeon_droq_reset_indices(struct octeon_droq *droq)\n{\n\tdroq->read_idx = 0;\n\tdroq->write_idx = 0;\n\tdroq->refill_idx = 0;\n\tdroq->refill_count = 0;\n\tatomic_set(&droq->pkts_pending, 0);\n}\n\nstatic void\nocteon_droq_destroy_ring_buffers(struct octeon_device *oct,\n\t\t\t\t struct octeon_droq *droq)\n{\n\tu32 i;\n\tstruct octeon_skb_page_info *pg_info;\n\n\tfor (i = 0; i < droq->max_count; i++) {\n\t\tpg_info = &droq->recv_buf_list[i].pg_info;\n\t\tif (!pg_info)\n\t\t\tcontinue;\n\n\t\tif (pg_info->dma)\n\t\t\tlio_unmap_ring(oct->pci_dev,\n\t\t\t\t       (u64)pg_info->dma);\n\t\tpg_info->dma = 0;\n\n\t\tif (pg_info->page)\n\t\t\trecv_buffer_destroy(droq->recv_buf_list[i].buffer,\n\t\t\t\t\t    pg_info);\n\n\t\tdroq->recv_buf_list[i].buffer = NULL;\n\t}\n\n\tocteon_droq_reset_indices(droq);\n}\n\nstatic int\nocteon_droq_setup_ring_buffers(struct octeon_device *oct,\n\t\t\t       struct octeon_droq *droq)\n{\n\tu32 i;\n\tvoid *buf;\n\tstruct octeon_droq_desc *desc_ring = droq->desc_ring;\n\n\tfor (i = 0; i < droq->max_count; i++) {\n\t\tbuf = recv_buffer_alloc(oct, &droq->recv_buf_list[i].pg_info);\n\n\t\tif (!buf) {\n\t\t\tdev_err(&oct->pci_dev->dev, \"%s buffer alloc failed\\n\",\n\t\t\t\t__func__);\n\t\t\tdroq->stats.rx_alloc_failure++;\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tdroq->recv_buf_list[i].buffer = buf;\n\t\tdroq->recv_buf_list[i].data = get_rbd(buf);\n\t\tdesc_ring[i].info_ptr = 0;\n\t\tdesc_ring[i].buffer_ptr =\n\t\t\tlio_map_ring(droq->recv_buf_list[i].buffer);\n\t}\n\n\tocteon_droq_reset_indices(droq);\n\n\tocteon_droq_compute_max_packet_bufs(droq);\n\n\treturn 0;\n}\n\nint octeon_delete_droq(struct octeon_device *oct, u32 q_no)\n{\n\tstruct octeon_droq *droq = oct->droq[q_no];\n\n\tdev_dbg(&oct->pci_dev->dev, \"%s[%d]\\n\", __func__, q_no);\n\n\tocteon_droq_destroy_ring_buffers(oct, droq);\n\tvfree(droq->recv_buf_list);\n\n\tif (droq->desc_ring)\n\t\tlio_dma_free(oct, (droq->max_count * OCT_DROQ_DESC_SIZE),\n\t\t\t     droq->desc_ring, droq->desc_ring_dma);\n\n\tmemset(droq, 0, OCT_DROQ_SIZE);\n\toct->io_qmask.oq &= ~(1ULL << q_no);\n\tvfree(oct->droq[q_no]);\n\toct->droq[q_no] = NULL;\n\toct->num_oqs--;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(octeon_delete_droq);\n\nint octeon_init_droq(struct octeon_device *oct,\n\t\t     u32 q_no,\n\t\t     u32 num_descs,\n\t\t     u32 desc_size,\n\t\t     void *app_ctx)\n{\n\tstruct octeon_droq *droq;\n\tu32 desc_ring_size = 0, c_num_descs = 0, c_buf_size = 0;\n\tu32 c_pkts_per_intr = 0, c_refill_threshold = 0;\n\tint numa_node = dev_to_node(&oct->pci_dev->dev);\n\n\tdev_dbg(&oct->pci_dev->dev, \"%s[%d]\\n\", __func__, q_no);\n\n\tdroq = oct->droq[q_no];\n\tmemset(droq, 0, OCT_DROQ_SIZE);\n\n\tdroq->oct_dev = oct;\n\tdroq->q_no = q_no;\n\tif (app_ctx)\n\t\tdroq->app_ctx = app_ctx;\n\telse\n\t\tdroq->app_ctx = (void *)(size_t)q_no;\n\n\tc_num_descs = num_descs;\n\tc_buf_size = desc_size;\n\tif (OCTEON_CN6XXX(oct)) {\n\t\tstruct octeon_config *conf6x = CHIP_CONF(oct, cn6xxx);\n\n\t\tc_pkts_per_intr = (u32)CFG_GET_OQ_PKTS_PER_INTR(conf6x);\n\t\tc_refill_threshold =\n\t\t\t(u32)CFG_GET_OQ_REFILL_THRESHOLD(conf6x);\n\t} else if (OCTEON_CN23XX_PF(oct)) {\n\t\tstruct octeon_config *conf23 = CHIP_CONF(oct, cn23xx_pf);\n\n\t\tc_pkts_per_intr = (u32)CFG_GET_OQ_PKTS_PER_INTR(conf23);\n\t\tc_refill_threshold = (u32)CFG_GET_OQ_REFILL_THRESHOLD(conf23);\n\t} else if (OCTEON_CN23XX_VF(oct)) {\n\t\tstruct octeon_config *conf23 = CHIP_CONF(oct, cn23xx_vf);\n\n\t\tc_pkts_per_intr = (u32)CFG_GET_OQ_PKTS_PER_INTR(conf23);\n\t\tc_refill_threshold = (u32)CFG_GET_OQ_REFILL_THRESHOLD(conf23);\n\t} else {\n\t\treturn 1;\n\t}\n\n\tdroq->max_count = c_num_descs;\n\tdroq->buffer_size = c_buf_size;\n\n\tdesc_ring_size = droq->max_count * OCT_DROQ_DESC_SIZE;\n\tdroq->desc_ring = lio_dma_alloc(oct, desc_ring_size,\n\t\t\t\t\t(dma_addr_t *)&droq->desc_ring_dma);\n\n\tif (!droq->desc_ring) {\n\t\tdev_err(&oct->pci_dev->dev,\n\t\t\t\"Output queue %d ring alloc failed\\n\", q_no);\n\t\treturn 1;\n\t}\n\n\tdev_dbg(&oct->pci_dev->dev, \"droq[%d]: desc_ring: virt: 0x%p, dma: %lx\\n\",\n\t\tq_no, droq->desc_ring, droq->desc_ring_dma);\n\tdev_dbg(&oct->pci_dev->dev, \"droq[%d]: num_desc: %d\\n\", q_no,\n\t\tdroq->max_count);\n\n\tdroq->recv_buf_list = vzalloc_node(array_size(droq->max_count, OCT_DROQ_RECVBUF_SIZE),\n\t\t\t\t\t   numa_node);\n\tif (!droq->recv_buf_list)\n\t\tdroq->recv_buf_list = vzalloc(array_size(droq->max_count, OCT_DROQ_RECVBUF_SIZE));\n\tif (!droq->recv_buf_list) {\n\t\tdev_err(&oct->pci_dev->dev, \"Output queue recv buf list alloc failed\\n\");\n\t\tgoto init_droq_fail;\n\t}\n\n\tif (octeon_droq_setup_ring_buffers(oct, droq))\n\t\tgoto init_droq_fail;\n\n\tdroq->pkts_per_intr = c_pkts_per_intr;\n\tdroq->refill_threshold = c_refill_threshold;\n\n\tdev_dbg(&oct->pci_dev->dev, \"DROQ INIT: max_empty_descs: %d\\n\",\n\t\tdroq->max_empty_descs);\n\n\tINIT_LIST_HEAD(&droq->dispatch_list);\n\n\t \n\toct->fn_list.setup_oq_regs(oct, q_no);\n\n\toct->io_qmask.oq |= BIT_ULL(q_no);\n\n\treturn 0;\n\ninit_droq_fail:\n\tocteon_delete_droq(oct, q_no);\n\treturn 1;\n}\n\n \nstatic inline struct octeon_recv_info *octeon_create_recv_info(\n\t\tstruct octeon_device *octeon_dev,\n\t\tstruct octeon_droq *droq,\n\t\tu32 buf_cnt,\n\t\tu32 idx)\n{\n\tstruct octeon_droq_info *info;\n\tstruct octeon_recv_pkt *recv_pkt;\n\tstruct octeon_recv_info *recv_info;\n\tu32 i, bytes_left;\n\tstruct octeon_skb_page_info *pg_info;\n\n\tinfo = (struct octeon_droq_info *)droq->recv_buf_list[idx].data;\n\n\trecv_info = octeon_alloc_recv_info(sizeof(struct __dispatch));\n\tif (!recv_info)\n\t\treturn NULL;\n\n\trecv_pkt = recv_info->recv_pkt;\n\trecv_pkt->rh = info->rh;\n\trecv_pkt->length = (u32)info->length;\n\trecv_pkt->buffer_count = (u16)buf_cnt;\n\trecv_pkt->octeon_id = (u16)octeon_dev->octeon_id;\n\n\ti = 0;\n\tbytes_left = (u32)info->length;\n\n\twhile (buf_cnt) {\n\t\t{\n\t\t\tpg_info = &droq->recv_buf_list[idx].pg_info;\n\n\t\t\tlio_unmap_ring(octeon_dev->pci_dev,\n\t\t\t\t       (u64)pg_info->dma);\n\t\t\tpg_info->page = NULL;\n\t\t\tpg_info->dma = 0;\n\t\t}\n\n\t\trecv_pkt->buffer_size[i] =\n\t\t\t(bytes_left >=\n\t\t\t droq->buffer_size) ? droq->buffer_size : bytes_left;\n\n\t\trecv_pkt->buffer_ptr[i] = droq->recv_buf_list[idx].buffer;\n\t\tdroq->recv_buf_list[idx].buffer = NULL;\n\n\t\tidx = incr_index(idx, 1, droq->max_count);\n\t\tbytes_left -= droq->buffer_size;\n\t\ti++;\n\t\tbuf_cnt--;\n\t}\n\n\treturn recv_info;\n}\n\n \nstatic inline u32\nocteon_droq_refill_pullup_descs(struct octeon_droq *droq,\n\t\t\t\tstruct octeon_droq_desc *desc_ring)\n{\n\tu32 desc_refilled = 0;\n\n\tu32 refill_index = droq->refill_idx;\n\n\twhile (refill_index != droq->read_idx) {\n\t\tif (droq->recv_buf_list[refill_index].buffer) {\n\t\t\tdroq->recv_buf_list[droq->refill_idx].buffer =\n\t\t\t\tdroq->recv_buf_list[refill_index].buffer;\n\t\t\tdroq->recv_buf_list[droq->refill_idx].data =\n\t\t\t\tdroq->recv_buf_list[refill_index].data;\n\t\t\tdesc_ring[droq->refill_idx].buffer_ptr =\n\t\t\t\tdesc_ring[refill_index].buffer_ptr;\n\t\t\tdroq->recv_buf_list[refill_index].buffer = NULL;\n\t\t\tdesc_ring[refill_index].buffer_ptr = 0;\n\t\t\tdo {\n\t\t\t\tdroq->refill_idx = incr_index(droq->refill_idx,\n\t\t\t\t\t\t\t      1,\n\t\t\t\t\t\t\t      droq->max_count);\n\t\t\t\tdesc_refilled++;\n\t\t\t\tdroq->refill_count--;\n\t\t\t} while (droq->recv_buf_list[droq->refill_idx].buffer);\n\t\t}\n\t\trefill_index = incr_index(refill_index, 1, droq->max_count);\n\t}                        \n\treturn desc_refilled;\n}\n\n \nstatic u32\nocteon_droq_refill(struct octeon_device *octeon_dev, struct octeon_droq *droq)\n{\n\tstruct octeon_droq_desc *desc_ring;\n\tvoid *buf = NULL;\n\tu8 *data;\n\tu32 desc_refilled = 0;\n\tstruct octeon_skb_page_info *pg_info;\n\n\tdesc_ring = droq->desc_ring;\n\n\twhile (droq->refill_count && (desc_refilled < droq->max_count)) {\n\t\t \n\t\tif (!droq->recv_buf_list[droq->refill_idx].buffer) {\n\t\t\tpg_info =\n\t\t\t\t&droq->recv_buf_list[droq->refill_idx].pg_info;\n\t\t\t \n\t\t\tif (pg_info->page)\n\t\t\t\tbuf = recv_buffer_reuse(octeon_dev, pg_info);\n\t\t\telse\n\t\t\t\tbuf = recv_buffer_alloc(octeon_dev, pg_info);\n\t\t\t \n\t\t\tif (!buf) {\n\t\t\t\tdroq->stats.rx_alloc_failure++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdroq->recv_buf_list[droq->refill_idx].buffer =\n\t\t\t\tbuf;\n\t\t\tdata = get_rbd(buf);\n\t\t} else {\n\t\t\tdata = get_rbd(droq->recv_buf_list\n\t\t\t\t       [droq->refill_idx].buffer);\n\t\t}\n\n\t\tdroq->recv_buf_list[droq->refill_idx].data = data;\n\n\t\tdesc_ring[droq->refill_idx].buffer_ptr =\n\t\t\tlio_map_ring(droq->recv_buf_list[\n\t\t\t\t     droq->refill_idx].buffer);\n\n\t\tdroq->refill_idx = incr_index(droq->refill_idx, 1,\n\t\t\t\t\t      droq->max_count);\n\t\tdesc_refilled++;\n\t\tdroq->refill_count--;\n\t}\n\n\tif (droq->refill_count)\n\t\tdesc_refilled +=\n\t\t\tocteon_droq_refill_pullup_descs(droq, desc_ring);\n\n\t \n\treturn desc_refilled;\n}\n\n \nint octeon_retry_droq_refill(struct octeon_droq *droq)\n{\n\tstruct octeon_device *oct = droq->oct_dev;\n\tint desc_refilled, reschedule = 1;\n\tu32 pkts_credit;\n\n\tpkts_credit = readl(droq->pkts_credit_reg);\n\tdesc_refilled = octeon_droq_refill(oct, droq);\n\tif (desc_refilled) {\n\t\t \n\t\twmb();\n\t\twritel(desc_refilled, droq->pkts_credit_reg);\n\n\t\tif (pkts_credit + desc_refilled >= CN23XX_SLI_DEF_BP)\n\t\t\treschedule = 0;\n\t}\n\n\treturn reschedule;\n}\n\nstatic inline u32\nocteon_droq_get_bufcount(u32 buf_size, u32 total_len)\n{\n\treturn DIV_ROUND_UP(total_len, buf_size);\n}\n\nstatic int\nocteon_droq_dispatch_pkt(struct octeon_device *oct,\n\t\t\t struct octeon_droq *droq,\n\t\t\t union octeon_rh *rh,\n\t\t\t struct octeon_droq_info *info)\n{\n\tu32 cnt;\n\tocteon_dispatch_fn_t disp_fn;\n\tstruct octeon_recv_info *rinfo;\n\n\tcnt = octeon_droq_get_bufcount(droq->buffer_size, (u32)info->length);\n\n\tdisp_fn = octeon_get_dispatch(oct, (u16)rh->r.opcode,\n\t\t\t\t      (u16)rh->r.subcode);\n\tif (disp_fn) {\n\t\trinfo = octeon_create_recv_info(oct, droq, cnt, droq->read_idx);\n\t\tif (rinfo) {\n\t\t\tstruct __dispatch *rdisp = rinfo->rsvd;\n\n\t\t\trdisp->rinfo = rinfo;\n\t\t\trdisp->disp_fn = disp_fn;\n\t\t\trinfo->recv_pkt->rh = *rh;\n\t\t\tlist_add_tail(&rdisp->list,\n\t\t\t\t      &droq->dispatch_list);\n\t\t} else {\n\t\t\tdroq->stats.dropped_nomem++;\n\t\t}\n\t} else {\n\t\tdev_err(&oct->pci_dev->dev, \"DROQ: No dispatch function (opcode %u/%u)\\n\",\n\t\t\t(unsigned int)rh->r.opcode,\n\t\t\t(unsigned int)rh->r.subcode);\n\t\tdroq->stats.dropped_nodispatch++;\n\t}\n\n\treturn cnt;\n}\n\nstatic inline void octeon_droq_drop_packets(struct octeon_device *oct,\n\t\t\t\t\t    struct octeon_droq *droq,\n\t\t\t\t\t    u32 cnt)\n{\n\tu32 i = 0, buf_cnt;\n\tstruct octeon_droq_info *info;\n\n\tfor (i = 0; i < cnt; i++) {\n\t\tinfo = (struct octeon_droq_info *)\n\t\t\tdroq->recv_buf_list[droq->read_idx].data;\n\t\tocteon_swap_8B_data((u64 *)info, 2);\n\n\t\tif (info->length) {\n\t\t\tinfo->length += OCTNET_FRM_LENGTH_SIZE;\n\t\t\tdroq->stats.bytes_received += info->length;\n\t\t\tbuf_cnt = octeon_droq_get_bufcount(droq->buffer_size,\n\t\t\t\t\t\t\t   (u32)info->length);\n\t\t} else {\n\t\t\tdev_err(&oct->pci_dev->dev, \"DROQ: In drop: pkt with len 0\\n\");\n\t\t\tbuf_cnt = 1;\n\t\t}\n\n\t\tdroq->read_idx = incr_index(droq->read_idx, buf_cnt,\n\t\t\t\t\t    droq->max_count);\n\t\tdroq->refill_count += buf_cnt;\n\t}\n}\n\nstatic u32\nocteon_droq_fast_process_packets(struct octeon_device *oct,\n\t\t\t\t struct octeon_droq *droq,\n\t\t\t\t u32 pkts_to_process)\n{\n\tu32 pkt, total_len = 0, pkt_count, retval;\n\tstruct octeon_droq_info *info;\n\tunion octeon_rh *rh;\n\n\tpkt_count = pkts_to_process;\n\n\tfor (pkt = 0; pkt < pkt_count; pkt++) {\n\t\tu32 pkt_len = 0;\n\t\tstruct sk_buff *nicbuf = NULL;\n\t\tstruct octeon_skb_page_info *pg_info;\n\t\tvoid *buf;\n\n\t\tinfo = (struct octeon_droq_info *)\n\t\t\tdroq->recv_buf_list[droq->read_idx].data;\n\t\tocteon_swap_8B_data((u64 *)info, 2);\n\n\t\tif (!info->length) {\n\t\t\tdev_err(&oct->pci_dev->dev,\n\t\t\t\t\"DROQ[%d] idx: %d len:0, pkt_cnt: %d\\n\",\n\t\t\t\tdroq->q_no, droq->read_idx, pkt_count);\n\t\t\tprint_hex_dump_bytes(\"\", DUMP_PREFIX_ADDRESS,\n\t\t\t\t\t     (u8 *)info,\n\t\t\t\t\t     OCT_DROQ_INFO_SIZE);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\trh = &info->rh;\n\n\t\tinfo->length += OCTNET_FRM_LENGTH_SIZE;\n\t\trh->r_dh.len += (ROUNDUP8(OCT_DROQ_INFO_SIZE) / sizeof(u64));\n\t\ttotal_len += (u32)info->length;\n\t\tif (opcode_slow_path(rh)) {\n\t\t\tu32 buf_cnt;\n\n\t\t\tbuf_cnt = octeon_droq_dispatch_pkt(oct, droq, rh, info);\n\t\t\tdroq->read_idx = incr_index(droq->read_idx,\n\t\t\t\t\t\t    buf_cnt, droq->max_count);\n\t\t\tdroq->refill_count += buf_cnt;\n\t\t} else {\n\t\t\tif (info->length <= droq->buffer_size) {\n\t\t\t\tpkt_len = (u32)info->length;\n\t\t\t\tnicbuf = droq->recv_buf_list[\n\t\t\t\t\tdroq->read_idx].buffer;\n\t\t\t\tpg_info = &droq->recv_buf_list[\n\t\t\t\t\tdroq->read_idx].pg_info;\n\t\t\t\tif (recv_buffer_recycle(oct, pg_info))\n\t\t\t\t\tpg_info->page = NULL;\n\t\t\t\tdroq->recv_buf_list[droq->read_idx].buffer =\n\t\t\t\t\tNULL;\n\n\t\t\t\tdroq->read_idx = incr_index(droq->read_idx, 1,\n\t\t\t\t\t\t\t    droq->max_count);\n\t\t\t\tdroq->refill_count++;\n\t\t\t} else {\n\t\t\t\tnicbuf = octeon_fast_packet_alloc((u32)\n\t\t\t\t\t\t\t\t  info->length);\n\t\t\t\tpkt_len = 0;\n\t\t\t\t \n\t\t\t\twhile (pkt_len < info->length) {\n\t\t\t\t\tint cpy_len, idx = droq->read_idx;\n\n\t\t\t\t\tcpy_len = ((pkt_len + droq->buffer_size)\n\t\t\t\t\t\t   > info->length) ?\n\t\t\t\t\t\t((u32)info->length - pkt_len) :\n\t\t\t\t\t\tdroq->buffer_size;\n\n\t\t\t\t\tif (nicbuf) {\n\t\t\t\t\t\tocteon_fast_packet_next(droq,\n\t\t\t\t\t\t\t\t\tnicbuf,\n\t\t\t\t\t\t\t\t\tcpy_len,\n\t\t\t\t\t\t\t\t\tidx);\n\t\t\t\t\t\tbuf = droq->recv_buf_list[\n\t\t\t\t\t\t\tidx].buffer;\n\t\t\t\t\t\trecv_buffer_fast_free(buf);\n\t\t\t\t\t\tdroq->recv_buf_list[idx].buffer\n\t\t\t\t\t\t\t= NULL;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdroq->stats.rx_alloc_failure++;\n\t\t\t\t\t}\n\n\t\t\t\t\tpkt_len += cpy_len;\n\t\t\t\t\tdroq->read_idx =\n\t\t\t\t\t\tincr_index(droq->read_idx, 1,\n\t\t\t\t\t\t\t   droq->max_count);\n\t\t\t\t\tdroq->refill_count++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (nicbuf) {\n\t\t\t\tif (droq->ops.fptr) {\n\t\t\t\t\tdroq->ops.fptr(oct->octeon_id,\n\t\t\t\t\t\t       nicbuf, pkt_len,\n\t\t\t\t\t\t       rh, &droq->napi,\n\t\t\t\t\t\t       droq->ops.farg);\n\t\t\t\t} else {\n\t\t\t\t\trecv_buffer_free(nicbuf);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (droq->refill_count >= droq->refill_threshold) {\n\t\t\tint desc_refilled = octeon_droq_refill(oct, droq);\n\n\t\t\tif (desc_refilled) {\n\t\t\t\t \n\t\t\t\twmb();\n\t\t\t\twritel(desc_refilled, droq->pkts_credit_reg);\n\t\t\t}\n\t\t}\n\t}                        \n\n\t \n\tdroq->stats.pkts_received += pkt;\n\tdroq->stats.bytes_received += total_len;\n\n\tretval = pkt;\n\tif ((droq->ops.drop_on_max) && (pkts_to_process - pkt)) {\n\t\tocteon_droq_drop_packets(oct, droq, (pkts_to_process - pkt));\n\n\t\tdroq->stats.dropped_toomany += (pkts_to_process - pkt);\n\t\tretval = pkts_to_process;\n\t}\n\n\tatomic_sub(retval, &droq->pkts_pending);\n\n\tif (droq->refill_count >= droq->refill_threshold &&\n\t    readl(droq->pkts_credit_reg) < CN23XX_SLI_DEF_BP) {\n\t\tocteon_droq_check_hw_for_pkts(droq);\n\n\t\t \n\t\tif (!atomic_read(&droq->pkts_pending))\n\t\t\tocteon_schedule_rxq_oom_work(oct, droq);\n\t}\n\n\treturn retval;\n}\n\nint\nocteon_droq_process_packets(struct octeon_device *oct,\n\t\t\t    struct octeon_droq *droq,\n\t\t\t    u32 budget)\n{\n\tu32 pkt_count = 0;\n\tstruct list_head *tmp, *tmp2;\n\n\tocteon_droq_check_hw_for_pkts(droq);\n\tpkt_count = atomic_read(&droq->pkts_pending);\n\n\tif (!pkt_count)\n\t\treturn 0;\n\n\tif (pkt_count > budget)\n\t\tpkt_count = budget;\n\n\tocteon_droq_fast_process_packets(oct, droq, pkt_count);\n\n\tlist_for_each_safe(tmp, tmp2, &droq->dispatch_list) {\n\t\tstruct __dispatch *rdisp = (struct __dispatch *)tmp;\n\n\t\tlist_del(tmp);\n\t\trdisp->disp_fn(rdisp->rinfo,\n\t\t\t       octeon_get_dispatch_arg\n\t\t\t       (oct,\n\t\t\t\t(u16)rdisp->rinfo->recv_pkt->rh.r.opcode,\n\t\t\t\t(u16)rdisp->rinfo->recv_pkt->rh.r.subcode));\n\t}\n\n\t \n\tif (atomic_read(&droq->pkts_pending))\n\t\treturn 1;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(octeon_droq_process_packets);\n\n \n\nint\nocteon_droq_process_poll_pkts(struct octeon_device *oct,\n\t\t\t      struct octeon_droq *droq, u32 budget)\n{\n\tstruct list_head *tmp, *tmp2;\n\tu32 pkts_available = 0, pkts_processed = 0;\n\tu32 total_pkts_processed = 0;\n\n\tif (budget > droq->max_count)\n\t\tbudget = droq->max_count;\n\n\twhile (total_pkts_processed < budget) {\n\t\tocteon_droq_check_hw_for_pkts(droq);\n\n\t\tpkts_available = min((budget - total_pkts_processed),\n\t\t\t\t     (u32)(atomic_read(&droq->pkts_pending)));\n\n\t\tif (pkts_available == 0)\n\t\t\tbreak;\n\n\t\tpkts_processed =\n\t\t\tocteon_droq_fast_process_packets(oct, droq,\n\t\t\t\t\t\t\t pkts_available);\n\n\t\ttotal_pkts_processed += pkts_processed;\n\t}\n\n\tlist_for_each_safe(tmp, tmp2, &droq->dispatch_list) {\n\t\tstruct __dispatch *rdisp = (struct __dispatch *)tmp;\n\n\t\tlist_del(tmp);\n\t\trdisp->disp_fn(rdisp->rinfo,\n\t\t\t       octeon_get_dispatch_arg\n\t\t\t       (oct,\n\t\t\t\t(u16)rdisp->rinfo->recv_pkt->rh.r.opcode,\n\t\t\t\t(u16)rdisp->rinfo->recv_pkt->rh.r.subcode));\n\t}\n\n\treturn total_pkts_processed;\n}\n\n \nint\nocteon_enable_irq(struct octeon_device *oct, u32 q_no)\n{\n\tswitch (oct->chip_id) {\n\tcase OCTEON_CN66XX:\n\tcase OCTEON_CN68XX: {\n\t\tstruct octeon_cn6xxx *cn6xxx =\n\t\t\t(struct octeon_cn6xxx *)oct->chip;\n\t\tunsigned long flags;\n\t\tu32 value;\n\n\t\tspin_lock_irqsave\n\t\t\t(&cn6xxx->lock_for_droq_int_enb_reg, flags);\n\t\tvalue = octeon_read_csr(oct, CN6XXX_SLI_PKT_TIME_INT_ENB);\n\t\tvalue |= (1 << q_no);\n\t\tocteon_write_csr(oct, CN6XXX_SLI_PKT_TIME_INT_ENB, value);\n\t\tvalue = octeon_read_csr(oct, CN6XXX_SLI_PKT_CNT_INT_ENB);\n\t\tvalue |= (1 << q_no);\n\t\tocteon_write_csr(oct, CN6XXX_SLI_PKT_CNT_INT_ENB, value);\n\n\t\t \n\n\t\tspin_unlock_irqrestore\n\t\t\t(&cn6xxx->lock_for_droq_int_enb_reg, flags);\n\t}\n\t\tbreak;\n\tcase OCTEON_CN23XX_PF_VID:\n\t\tlio_enable_irq(oct->droq[q_no], oct->instr_queue[q_no]);\n\t\tbreak;\n\n\tcase OCTEON_CN23XX_VF_VID:\n\t\tlio_enable_irq(oct->droq[q_no], oct->instr_queue[q_no]);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&oct->pci_dev->dev, \"%s Unknown Chip\\n\", __func__);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nint octeon_register_droq_ops(struct octeon_device *oct, u32 q_no,\n\t\t\t     struct octeon_droq_ops *ops)\n{\n\tstruct octeon_config *oct_cfg = NULL;\n\tstruct octeon_droq *droq;\n\n\toct_cfg = octeon_get_conf(oct);\n\n\tif (!oct_cfg)\n\t\treturn -EINVAL;\n\n\tif (!(ops)) {\n\t\tdev_err(&oct->pci_dev->dev, \"%s: droq_ops pointer is NULL\\n\",\n\t\t\t__func__);\n\t\treturn -EINVAL;\n\t}\n\n\tif (q_no >= CFG_GET_OQ_MAX_Q(oct_cfg)) {\n\t\tdev_err(&oct->pci_dev->dev, \"%s: droq id (%d) exceeds MAX (%d)\\n\",\n\t\t\t__func__, q_no, (oct->num_oqs - 1));\n\t\treturn -EINVAL;\n\t}\n\n\tdroq = oct->droq[q_no];\n\tmemcpy(&droq->ops, ops, sizeof(struct octeon_droq_ops));\n\n\treturn 0;\n}\n\nint octeon_unregister_droq_ops(struct octeon_device *oct, u32 q_no)\n{\n\tstruct octeon_config *oct_cfg = NULL;\n\tstruct octeon_droq *droq;\n\n\toct_cfg = octeon_get_conf(oct);\n\n\tif (!oct_cfg)\n\t\treturn -EINVAL;\n\n\tif (q_no >= CFG_GET_OQ_MAX_Q(oct_cfg)) {\n\t\tdev_err(&oct->pci_dev->dev, \"%s: droq id (%d) exceeds MAX (%d)\\n\",\n\t\t\t__func__, q_no, oct->num_oqs - 1);\n\t\treturn -EINVAL;\n\t}\n\n\tdroq = oct->droq[q_no];\n\n\tif (!droq) {\n\t\tdev_info(&oct->pci_dev->dev,\n\t\t\t \"Droq id (%d) not available.\\n\", q_no);\n\t\treturn 0;\n\t}\n\n\tdroq->ops.fptr = NULL;\n\tdroq->ops.farg = NULL;\n\tdroq->ops.drop_on_max = 0;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(octeon_unregister_droq_ops);\n\nint octeon_create_droq(struct octeon_device *oct,\n\t\t       u32 q_no, u32 num_descs,\n\t\t       u32 desc_size, void *app_ctx)\n{\n\tstruct octeon_droq *droq;\n\tint numa_node = dev_to_node(&oct->pci_dev->dev);\n\n\tif (oct->droq[q_no]) {\n\t\tdev_dbg(&oct->pci_dev->dev, \"Droq already in use. Cannot create droq %d again\\n\",\n\t\t\tq_no);\n\t\treturn 1;\n\t}\n\n\t \n\tdroq = vmalloc_node(sizeof(*droq), numa_node);\n\tif (!droq)\n\t\tdroq = vmalloc(sizeof(*droq));\n\tif (!droq)\n\t\treturn -1;\n\n\tmemset(droq, 0, sizeof(struct octeon_droq));\n\n\t \n\tocteon_set_droq_pkt_op(oct, q_no, 0);\n\toct->droq[q_no] = droq;\n\n\t \n\tif (octeon_init_droq(oct, q_no, num_descs, desc_size, app_ctx)) {\n\t\tvfree(oct->droq[q_no]);\n\t\toct->droq[q_no] = NULL;\n\t\treturn -1;\n\t}\n\n\toct->num_oqs++;\n\n\tdev_dbg(&oct->pci_dev->dev, \"%s: Total number of OQ: %d\\n\", __func__,\n\t\toct->num_oqs);\n\n\t \n\n\t \n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}