{
  "module_name": "octeon_device.c",
  "hash_id": "263372b42d1700da4dedf331d8d29ec02dbc2fba72eb43f148667498207f7ff1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/cavium/liquidio/octeon_device.c",
  "human_readable_source": " \n#include <linux/pci.h>\n#include <linux/netdevice.h>\n#include <linux/vmalloc.h>\n#include \"liquidio_common.h\"\n#include \"octeon_droq.h\"\n#include \"octeon_iq.h\"\n#include \"response_manager.h\"\n#include \"octeon_device.h\"\n#include \"octeon_main.h\"\n#include \"octeon_network.h\"\n#include \"cn66xx_regs.h\"\n#include \"cn66xx_device.h\"\n#include \"cn23xx_pf_device.h\"\n#include \"cn23xx_vf_device.h\"\n\n \nstatic struct octeon_config default_cn66xx_conf = {\n\t.card_type                              = LIO_210SV,\n\t.card_name                              = LIO_210SV_NAME,\n\n\t \n\t.iq\t\t\t\t\t= {\n\t\t.max_iqs\t\t\t= CN6XXX_CFG_IO_QUEUES,\n\t\t.pending_list_size\t\t=\n\t\t\t(CN6XXX_MAX_IQ_DESCRIPTORS * CN6XXX_CFG_IO_QUEUES),\n\t\t.instr_type\t\t\t= OCTEON_64BYTE_INSTR,\n\t\t.db_min\t\t\t\t= CN6XXX_DB_MIN,\n\t\t.db_timeout\t\t\t= CN6XXX_DB_TIMEOUT,\n\t}\n\t,\n\n\t \n\t.oq\t\t\t\t\t= {\n\t\t.max_oqs\t\t\t= CN6XXX_CFG_IO_QUEUES,\n\t\t.refill_threshold\t\t= CN6XXX_OQ_REFIL_THRESHOLD,\n\t\t.oq_intr_pkt\t\t\t= CN6XXX_OQ_INTR_PKT,\n\t\t.oq_intr_time\t\t\t= CN6XXX_OQ_INTR_TIME,\n\t\t.pkts_per_intr\t\t\t= CN6XXX_OQ_PKTSPER_INTR,\n\t}\n\t,\n\n\t.num_nic_ports\t\t\t\t= DEFAULT_NUM_NIC_PORTS_66XX,\n\t.num_def_rx_descs\t\t\t= CN6XXX_MAX_OQ_DESCRIPTORS,\n\t.num_def_tx_descs\t\t\t= CN6XXX_MAX_IQ_DESCRIPTORS,\n\t.def_rx_buf_size\t\t\t= CN6XXX_OQ_BUF_SIZE,\n\n\t \n\t.nic_if_cfg[0] = {\n\t\t \n\t\t.max_txqs\t\t\t= MAX_TXQS_PER_INTF,\n\n\t\t \n\t\t.num_txqs\t\t\t= DEF_TXQS_PER_INTF,\n\n\t\t \n\t\t.max_rxqs\t\t\t= MAX_RXQS_PER_INTF,\n\n\t\t \n\t\t.num_rxqs\t\t\t= DEF_RXQS_PER_INTF,\n\n\t\t \n\t\t.num_rx_descs\t\t\t= CN6XXX_MAX_OQ_DESCRIPTORS,\n\n\t\t \n\t\t.num_tx_descs\t\t\t= CN6XXX_MAX_IQ_DESCRIPTORS,\n\n\t\t \n\t\t.rx_buf_size\t\t\t= CN6XXX_OQ_BUF_SIZE,\n\n\t\t.base_queue\t\t\t= BASE_QUEUE_NOT_REQUESTED,\n\n\t\t.gmx_port_id\t\t\t= 0,\n\t},\n\n\t.nic_if_cfg[1] = {\n\t\t \n\t\t.max_txqs\t\t\t= MAX_TXQS_PER_INTF,\n\n\t\t \n\t\t.num_txqs\t\t\t= DEF_TXQS_PER_INTF,\n\n\t\t \n\t\t.max_rxqs\t\t\t= MAX_RXQS_PER_INTF,\n\n\t\t \n\t\t.num_rxqs\t\t\t= DEF_RXQS_PER_INTF,\n\n\t\t \n\t\t.num_rx_descs\t\t\t= CN6XXX_MAX_OQ_DESCRIPTORS,\n\n\t\t \n\t\t.num_tx_descs\t\t\t= CN6XXX_MAX_IQ_DESCRIPTORS,\n\n\t\t \n\t\t.rx_buf_size\t\t\t= CN6XXX_OQ_BUF_SIZE,\n\n\t\t.base_queue\t\t\t= BASE_QUEUE_NOT_REQUESTED,\n\n\t\t.gmx_port_id\t\t\t= 1,\n\t},\n\n\t \n\t.misc\t\t\t\t\t= {\n\t\t \n\t\t.oct_link_query_interval\t= 100,\n\n\t\t \n\t\t.host_link_query_interval\t= 500,\n\n\t\t.enable_sli_oq_bp\t\t= 0,\n\n\t\t \n\t\t.ctrlq_grp\t\t\t= 1,\n\t}\n\t,\n};\n\n \n\nstatic struct octeon_config default_cn68xx_conf = {\n\t.card_type                              = LIO_410NV,\n\t.card_name                              = LIO_410NV_NAME,\n\n\t \n\t.iq\t\t\t\t\t= {\n\t\t.max_iqs\t\t\t= CN6XXX_CFG_IO_QUEUES,\n\t\t.pending_list_size\t\t=\n\t\t\t(CN6XXX_MAX_IQ_DESCRIPTORS * CN6XXX_CFG_IO_QUEUES),\n\t\t.instr_type\t\t\t= OCTEON_64BYTE_INSTR,\n\t\t.db_min\t\t\t\t= CN6XXX_DB_MIN,\n\t\t.db_timeout\t\t\t= CN6XXX_DB_TIMEOUT,\n\t}\n\t,\n\n\t \n\t.oq\t\t\t\t\t= {\n\t\t.max_oqs\t\t\t= CN6XXX_CFG_IO_QUEUES,\n\t\t.refill_threshold\t\t= CN6XXX_OQ_REFIL_THRESHOLD,\n\t\t.oq_intr_pkt\t\t\t= CN6XXX_OQ_INTR_PKT,\n\t\t.oq_intr_time\t\t\t= CN6XXX_OQ_INTR_TIME,\n\t\t.pkts_per_intr\t\t\t= CN6XXX_OQ_PKTSPER_INTR,\n\t}\n\t,\n\n\t.num_nic_ports\t\t\t\t= DEFAULT_NUM_NIC_PORTS_68XX,\n\t.num_def_rx_descs\t\t\t= CN6XXX_MAX_OQ_DESCRIPTORS,\n\t.num_def_tx_descs\t\t\t= CN6XXX_MAX_IQ_DESCRIPTORS,\n\t.def_rx_buf_size\t\t\t= CN6XXX_OQ_BUF_SIZE,\n\n\t.nic_if_cfg[0] = {\n\t\t \n\t\t.max_txqs\t\t\t= MAX_TXQS_PER_INTF,\n\n\t\t \n\t\t.num_txqs\t\t\t= DEF_TXQS_PER_INTF,\n\n\t\t \n\t\t.max_rxqs\t\t\t= MAX_RXQS_PER_INTF,\n\n\t\t \n\t\t.num_rxqs\t\t\t= DEF_RXQS_PER_INTF,\n\n\t\t \n\t\t.num_rx_descs\t\t\t= CN6XXX_MAX_OQ_DESCRIPTORS,\n\n\t\t \n\t\t.num_tx_descs\t\t\t= CN6XXX_MAX_IQ_DESCRIPTORS,\n\n\t\t \n\t\t.rx_buf_size\t\t\t= CN6XXX_OQ_BUF_SIZE,\n\n\t\t.base_queue\t\t\t= BASE_QUEUE_NOT_REQUESTED,\n\n\t\t.gmx_port_id\t\t\t= 0,\n\t},\n\n\t.nic_if_cfg[1] = {\n\t\t \n\t\t.max_txqs\t\t\t= MAX_TXQS_PER_INTF,\n\n\t\t \n\t\t.num_txqs\t\t\t= DEF_TXQS_PER_INTF,\n\n\t\t \n\t\t.max_rxqs\t\t\t= MAX_RXQS_PER_INTF,\n\n\t\t \n\t\t.num_rxqs\t\t\t= DEF_RXQS_PER_INTF,\n\n\t\t \n\t\t.num_rx_descs\t\t\t= CN6XXX_MAX_OQ_DESCRIPTORS,\n\n\t\t \n\t\t.num_tx_descs\t\t\t= CN6XXX_MAX_IQ_DESCRIPTORS,\n\n\t\t \n\t\t.rx_buf_size\t\t\t= CN6XXX_OQ_BUF_SIZE,\n\n\t\t.base_queue\t\t\t= BASE_QUEUE_NOT_REQUESTED,\n\n\t\t.gmx_port_id\t\t\t= 1,\n\t},\n\n\t.nic_if_cfg[2] = {\n\t\t \n\t\t.max_txqs\t\t\t= MAX_TXQS_PER_INTF,\n\n\t\t \n\t\t.num_txqs\t\t\t= DEF_TXQS_PER_INTF,\n\n\t\t \n\t\t.max_rxqs\t\t\t= MAX_RXQS_PER_INTF,\n\n\t\t \n\t\t.num_rxqs\t\t\t= DEF_RXQS_PER_INTF,\n\n\t\t \n\t\t.num_rx_descs\t\t\t= CN6XXX_MAX_OQ_DESCRIPTORS,\n\n\t\t \n\t\t.num_tx_descs\t\t\t= CN6XXX_MAX_IQ_DESCRIPTORS,\n\n\t\t \n\t\t.rx_buf_size\t\t\t= CN6XXX_OQ_BUF_SIZE,\n\n\t\t.base_queue\t\t\t= BASE_QUEUE_NOT_REQUESTED,\n\n\t\t.gmx_port_id\t\t\t= 2,\n\t},\n\n\t.nic_if_cfg[3] = {\n\t\t \n\t\t.max_txqs\t\t\t= MAX_TXQS_PER_INTF,\n\n\t\t \n\t\t.num_txqs\t\t\t= DEF_TXQS_PER_INTF,\n\n\t\t \n\t\t.max_rxqs\t\t\t= MAX_RXQS_PER_INTF,\n\n\t\t \n\t\t.num_rxqs\t\t\t= DEF_RXQS_PER_INTF,\n\n\t\t \n\t\t.num_rx_descs\t\t\t= CN6XXX_MAX_OQ_DESCRIPTORS,\n\n\t\t \n\t\t.num_tx_descs\t\t\t= CN6XXX_MAX_IQ_DESCRIPTORS,\n\n\t\t \n\t\t.rx_buf_size\t\t\t= CN6XXX_OQ_BUF_SIZE,\n\n\t\t.base_queue\t\t\t= BASE_QUEUE_NOT_REQUESTED,\n\n\t\t.gmx_port_id\t\t\t= 3,\n\t},\n\n\t \n\t.misc\t\t\t\t\t= {\n\t\t \n\t\t.oct_link_query_interval\t= 100,\n\n\t\t \n\t\t.host_link_query_interval\t= 500,\n\n\t\t.enable_sli_oq_bp\t\t= 0,\n\n\t\t \n\t\t.ctrlq_grp\t\t\t= 1,\n\t}\n\t,\n};\n\n \nstatic struct octeon_config default_cn68xx_210nv_conf = {\n\t.card_type                              = LIO_210NV,\n\t.card_name                              = LIO_210NV_NAME,\n\n\t \n\n\t.iq\t\t\t\t\t= {\n\t\t.max_iqs\t\t\t= CN6XXX_CFG_IO_QUEUES,\n\t\t.pending_list_size\t\t=\n\t\t\t(CN6XXX_MAX_IQ_DESCRIPTORS * CN6XXX_CFG_IO_QUEUES),\n\t\t.instr_type\t\t\t= OCTEON_64BYTE_INSTR,\n\t\t.db_min\t\t\t\t= CN6XXX_DB_MIN,\n\t\t.db_timeout\t\t\t= CN6XXX_DB_TIMEOUT,\n\t}\n\t,\n\n\t \n\t.oq\t\t\t\t\t= {\n\t\t.max_oqs\t\t\t= CN6XXX_CFG_IO_QUEUES,\n\t\t.refill_threshold\t\t= CN6XXX_OQ_REFIL_THRESHOLD,\n\t\t.oq_intr_pkt\t\t\t= CN6XXX_OQ_INTR_PKT,\n\t\t.oq_intr_time\t\t\t= CN6XXX_OQ_INTR_TIME,\n\t\t.pkts_per_intr\t\t\t= CN6XXX_OQ_PKTSPER_INTR,\n\t}\n\t,\n\n\t.num_nic_ports\t\t\t= DEFAULT_NUM_NIC_PORTS_68XX_210NV,\n\t.num_def_rx_descs\t\t= CN6XXX_MAX_OQ_DESCRIPTORS,\n\t.num_def_tx_descs\t\t= CN6XXX_MAX_IQ_DESCRIPTORS,\n\t.def_rx_buf_size\t\t= CN6XXX_OQ_BUF_SIZE,\n\n\t.nic_if_cfg[0] = {\n\t\t \n\t\t.max_txqs\t\t\t= MAX_TXQS_PER_INTF,\n\n\t\t \n\t\t.num_txqs\t\t\t= DEF_TXQS_PER_INTF,\n\n\t\t \n\t\t.max_rxqs\t\t\t= MAX_RXQS_PER_INTF,\n\n\t\t \n\t\t.num_rxqs\t\t\t= DEF_RXQS_PER_INTF,\n\n\t\t \n\t\t.num_rx_descs\t\t\t= CN6XXX_MAX_OQ_DESCRIPTORS,\n\n\t\t \n\t\t.num_tx_descs\t\t\t= CN6XXX_MAX_IQ_DESCRIPTORS,\n\n\t\t \n\t\t.rx_buf_size\t\t\t= CN6XXX_OQ_BUF_SIZE,\n\n\t\t.base_queue\t\t\t= BASE_QUEUE_NOT_REQUESTED,\n\n\t\t.gmx_port_id\t\t\t= 0,\n\t},\n\n\t.nic_if_cfg[1] = {\n\t\t \n\t\t.max_txqs\t\t\t= MAX_TXQS_PER_INTF,\n\n\t\t \n\t\t.num_txqs\t\t\t= DEF_TXQS_PER_INTF,\n\n\t\t \n\t\t.max_rxqs\t\t\t= MAX_RXQS_PER_INTF,\n\n\t\t \n\t\t.num_rxqs\t\t\t= DEF_RXQS_PER_INTF,\n\n\t\t \n\t\t.num_rx_descs\t\t\t= CN6XXX_MAX_OQ_DESCRIPTORS,\n\n\t\t \n\t\t.num_tx_descs\t\t\t= CN6XXX_MAX_IQ_DESCRIPTORS,\n\n\t\t \n\t\t.rx_buf_size\t\t\t= CN6XXX_OQ_BUF_SIZE,\n\n\t\t.base_queue\t\t\t= BASE_QUEUE_NOT_REQUESTED,\n\n\t\t.gmx_port_id\t\t\t= 1,\n\t},\n\n\t \n\t.misc\t\t\t\t\t= {\n\t\t \n\t\t.oct_link_query_interval\t= 100,\n\n\t\t \n\t\t.host_link_query_interval\t= 500,\n\n\t\t.enable_sli_oq_bp\t\t= 0,\n\n\t\t \n\t\t.ctrlq_grp\t\t\t= 1,\n\t}\n\t,\n};\n\nstatic struct octeon_config default_cn23xx_conf = {\n\t.card_type                              = LIO_23XX,\n\t.card_name                              = LIO_23XX_NAME,\n\t \n\t.iq = {\n\t\t.max_iqs\t\t= CN23XX_CFG_IO_QUEUES,\n\t\t.pending_list_size\t= (CN23XX_DEFAULT_IQ_DESCRIPTORS *\n\t\t\t\t\t   CN23XX_CFG_IO_QUEUES),\n\t\t.instr_type\t\t= OCTEON_64BYTE_INSTR,\n\t\t.db_min\t\t\t= CN23XX_DB_MIN,\n\t\t.db_timeout\t\t= CN23XX_DB_TIMEOUT,\n\t\t.iq_intr_pkt\t\t= CN23XX_DEF_IQ_INTR_THRESHOLD,\n\t},\n\n\t \n\t.oq = {\n\t\t.max_oqs\t\t= CN23XX_CFG_IO_QUEUES,\n\t\t.pkts_per_intr\t= CN23XX_OQ_PKTSPER_INTR,\n\t\t.refill_threshold\t= CN23XX_OQ_REFIL_THRESHOLD,\n\t\t.oq_intr_pkt\t= CN23XX_OQ_INTR_PKT,\n\t\t.oq_intr_time\t= CN23XX_OQ_INTR_TIME,\n\t},\n\n\t.num_nic_ports\t\t\t\t= DEFAULT_NUM_NIC_PORTS_23XX,\n\t.num_def_rx_descs\t\t\t= CN23XX_DEFAULT_OQ_DESCRIPTORS,\n\t.num_def_tx_descs\t\t\t= CN23XX_DEFAULT_IQ_DESCRIPTORS,\n\t.def_rx_buf_size\t\t\t= CN23XX_OQ_BUF_SIZE,\n\n\t \n\t.nic_if_cfg[0] = {\n\t\t \n\t\t.max_txqs\t\t\t= MAX_TXQS_PER_INTF,\n\n\t\t \n\t\t.num_txqs\t\t\t= DEF_TXQS_PER_INTF,\n\n\t\t \n\t\t.max_rxqs\t\t\t= MAX_RXQS_PER_INTF,\n\n\t\t \n\t\t.num_rxqs\t\t\t= DEF_RXQS_PER_INTF,\n\n\t\t \n\t\t.num_rx_descs\t\t\t= CN23XX_DEFAULT_OQ_DESCRIPTORS,\n\n\t\t \n\t\t.num_tx_descs\t\t\t= CN23XX_DEFAULT_IQ_DESCRIPTORS,\n\n\t\t \n\t\t.rx_buf_size\t\t\t= CN23XX_OQ_BUF_SIZE,\n\n\t\t.base_queue\t\t\t= BASE_QUEUE_NOT_REQUESTED,\n\n\t\t.gmx_port_id\t\t\t= 0,\n\t},\n\n\t.nic_if_cfg[1] = {\n\t\t \n\t\t.max_txqs\t\t\t= MAX_TXQS_PER_INTF,\n\n\t\t \n\t\t.num_txqs\t\t\t= DEF_TXQS_PER_INTF,\n\n\t\t \n\t\t.max_rxqs\t\t\t= MAX_RXQS_PER_INTF,\n\n\t\t \n\t\t.num_rxqs\t\t\t= DEF_RXQS_PER_INTF,\n\n\t\t \n\t\t.num_rx_descs\t\t\t= CN23XX_DEFAULT_OQ_DESCRIPTORS,\n\n\t\t \n\t\t.num_tx_descs\t\t\t= CN23XX_DEFAULT_IQ_DESCRIPTORS,\n\n\t\t \n\t\t.rx_buf_size\t\t\t= CN23XX_OQ_BUF_SIZE,\n\n\t\t.base_queue\t\t\t= BASE_QUEUE_NOT_REQUESTED,\n\n\t\t.gmx_port_id\t\t\t= 1,\n\t},\n\n\t.misc\t\t\t\t\t= {\n\t\t \n\t\t.oct_link_query_interval\t= 100,\n\n\t\t \n\t\t.host_link_query_interval\t= 500,\n\n\t\t.enable_sli_oq_bp\t\t= 0,\n\n\t\t \n\t\t.ctrlq_grp\t\t\t= 1,\n\t}\n};\n\nstatic struct octeon_config_ptr {\n\tu32 conf_type;\n} oct_conf_info[MAX_OCTEON_DEVICES] = {\n\t{\n\t\tOCTEON_CONFIG_TYPE_DEFAULT,\n\t}, {\n\t\tOCTEON_CONFIG_TYPE_DEFAULT,\n\t}, {\n\t\tOCTEON_CONFIG_TYPE_DEFAULT,\n\t}, {\n\t\tOCTEON_CONFIG_TYPE_DEFAULT,\n\t},\n};\n\nstatic char oct_dev_state_str[OCT_DEV_STATES + 1][32] = {\n\t\"BEGIN\", \"PCI-ENABLE-DONE\", \"PCI-MAP-DONE\", \"DISPATCH-INIT-DONE\",\n\t\"IQ-INIT-DONE\", \"SCBUFF-POOL-INIT-DONE\", \"RESPLIST-INIT-DONE\",\n\t\"DROQ-INIT-DONE\", \"MBOX-SETUP-DONE\", \"MSIX-ALLOC-VECTOR-DONE\",\n\t\"INTR-SET-DONE\", \"IO-QUEUES-INIT-DONE\", \"CONSOLE-INIT-DONE\",\n\t\"HOST-READY\", \"CORE-READY\", \"RUNNING\", \"IN-RESET\",\n\t\"INVALID\"\n};\n\nstatic char oct_dev_app_str[CVM_DRV_APP_COUNT + 1][32] = {\n\t\"BASE\", \"NIC\", \"UNKNOWN\"};\n\nstatic struct octeon_device *octeon_device[MAX_OCTEON_DEVICES];\nstatic atomic_t adapter_refcounts[MAX_OCTEON_DEVICES];\nstatic atomic_t adapter_fw_states[MAX_OCTEON_DEVICES];\n\nstatic u32 octeon_device_count;\n \nstatic DEFINE_SPINLOCK(octeon_devices_lock);\n\nstatic struct octeon_core_setup core_setup[MAX_OCTEON_DEVICES];\n\nstatic void oct_set_config_info(int oct_id, int conf_type)\n{\n\tif (conf_type < 0 || conf_type > (NUM_OCTEON_CONFS - 1))\n\t\tconf_type = OCTEON_CONFIG_TYPE_DEFAULT;\n\toct_conf_info[oct_id].conf_type = conf_type;\n}\n\nvoid octeon_init_device_list(int conf_type)\n{\n\tint i;\n\n\tmemset(octeon_device, 0, (sizeof(void *) * MAX_OCTEON_DEVICES));\n\tfor (i = 0; i <  MAX_OCTEON_DEVICES; i++)\n\t\toct_set_config_info(i, conf_type);\n}\nEXPORT_SYMBOL_GPL(octeon_init_device_list);\n\nstatic void *__retrieve_octeon_config_info(struct octeon_device *oct,\n\t\t\t\t\t   u16 card_type)\n{\n\tu32 oct_id = oct->octeon_id;\n\tvoid *ret = NULL;\n\n\tswitch (oct_conf_info[oct_id].conf_type) {\n\tcase OCTEON_CONFIG_TYPE_DEFAULT:\n\t\tif (oct->chip_id == OCTEON_CN66XX) {\n\t\t\tret = &default_cn66xx_conf;\n\t\t} else if ((oct->chip_id == OCTEON_CN68XX) &&\n\t\t\t   (card_type == LIO_210NV)) {\n\t\t\tret = &default_cn68xx_210nv_conf;\n\t\t} else if ((oct->chip_id == OCTEON_CN68XX) &&\n\t\t\t   (card_type == LIO_410NV)) {\n\t\t\tret = &default_cn68xx_conf;\n\t\t} else if (oct->chip_id == OCTEON_CN23XX_PF_VID) {\n\t\t\tret = &default_cn23xx_conf;\n\t\t} else if (oct->chip_id == OCTEON_CN23XX_VF_VID) {\n\t\t\tret = &default_cn23xx_conf;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic int __verify_octeon_config_info(struct octeon_device *oct, void *conf)\n{\n\tswitch (oct->chip_id) {\n\tcase OCTEON_CN66XX:\n\tcase OCTEON_CN68XX:\n\t\treturn lio_validate_cn6xxx_config_info(oct, conf);\n\tcase OCTEON_CN23XX_PF_VID:\n\tcase OCTEON_CN23XX_VF_VID:\n\t\treturn 0;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 1;\n}\n\nvoid *oct_get_config_info(struct octeon_device *oct, u16 card_type)\n{\n\tvoid *conf = NULL;\n\n\tconf = __retrieve_octeon_config_info(oct, card_type);\n\tif (!conf)\n\t\treturn NULL;\n\n\tif (__verify_octeon_config_info(oct, conf)) {\n\t\tdev_err(&oct->pci_dev->dev, \"Configuration verification failed\\n\");\n\t\treturn NULL;\n\t}\n\n\treturn conf;\n}\n\nchar *lio_get_state_string(atomic_t *state_ptr)\n{\n\ts32 istate = (s32)atomic_read(state_ptr);\n\n\tif (istate > OCT_DEV_STATES || istate < 0)\n\t\treturn oct_dev_state_str[OCT_DEV_STATE_INVALID];\n\treturn oct_dev_state_str[istate];\n}\nEXPORT_SYMBOL_GPL(lio_get_state_string);\n\nstatic char *get_oct_app_string(u32 app_mode)\n{\n\tif (app_mode <= CVM_DRV_APP_END)\n\t\treturn oct_dev_app_str[app_mode - CVM_DRV_APP_START];\n\treturn oct_dev_app_str[CVM_DRV_INVALID_APP - CVM_DRV_APP_START];\n}\n\nvoid octeon_free_device_mem(struct octeon_device *oct)\n{\n\tint i;\n\n\tfor (i = 0; i < MAX_OCTEON_OUTPUT_QUEUES(oct); i++) {\n\t\tif (oct->io_qmask.oq & BIT_ULL(i))\n\t\t\tvfree(oct->droq[i]);\n\t}\n\n\tfor (i = 0; i < MAX_OCTEON_INSTR_QUEUES(oct); i++) {\n\t\tif (oct->io_qmask.iq & BIT_ULL(i))\n\t\t\tvfree(oct->instr_queue[i]);\n\t}\n\n\ti = oct->octeon_id;\n\tvfree(oct);\n\n\tocteon_device[i] = NULL;\n\tocteon_device_count--;\n}\nEXPORT_SYMBOL_GPL(octeon_free_device_mem);\n\nstatic struct octeon_device *octeon_allocate_device_mem(u32 pci_id,\n\t\t\t\t\t\t\tu32 priv_size)\n{\n\tstruct octeon_device *oct;\n\tu8 *buf = NULL;\n\tu32 octdevsize = 0, configsize = 0, size;\n\n\tswitch (pci_id) {\n\tcase OCTEON_CN68XX:\n\tcase OCTEON_CN66XX:\n\t\tconfigsize = sizeof(struct octeon_cn6xxx);\n\t\tbreak;\n\n\tcase OCTEON_CN23XX_PF_VID:\n\t\tconfigsize = sizeof(struct octeon_cn23xx_pf);\n\t\tbreak;\n\tcase OCTEON_CN23XX_VF_VID:\n\t\tconfigsize = sizeof(struct octeon_cn23xx_vf);\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"%s: Unknown PCI Device: 0x%x\\n\",\n\t\t       __func__,\n\t\t       pci_id);\n\t\treturn NULL;\n\t}\n\n\tif (configsize & 0x7)\n\t\tconfigsize += (8 - (configsize & 0x7));\n\n\toctdevsize = sizeof(struct octeon_device);\n\tif (octdevsize & 0x7)\n\t\toctdevsize += (8 - (octdevsize & 0x7));\n\n\tif (priv_size & 0x7)\n\t\tpriv_size += (8 - (priv_size & 0x7));\n\n\tsize = octdevsize + priv_size + configsize +\n\t\t(sizeof(struct octeon_dispatch) * DISPATCH_LIST_SIZE);\n\n\tbuf = vzalloc(size);\n\tif (!buf)\n\t\treturn NULL;\n\n\toct = (struct octeon_device *)buf;\n\toct->priv = (void *)(buf + octdevsize);\n\toct->chip = (void *)(buf + octdevsize + priv_size);\n\toct->dispatch.dlist = (struct octeon_dispatch *)\n\t\t(buf + octdevsize + priv_size + configsize);\n\n\treturn oct;\n}\n\nstruct octeon_device *octeon_allocate_device(u32 pci_id,\n\t\t\t\t\t     u32 priv_size)\n{\n\tu32 oct_idx = 0;\n\tstruct octeon_device *oct = NULL;\n\n\tspin_lock(&octeon_devices_lock);\n\n\tfor (oct_idx = 0; oct_idx < MAX_OCTEON_DEVICES; oct_idx++)\n\t\tif (!octeon_device[oct_idx])\n\t\t\tbreak;\n\n\tif (oct_idx < MAX_OCTEON_DEVICES) {\n\t\toct = octeon_allocate_device_mem(pci_id, priv_size);\n\t\tif (oct) {\n\t\t\tocteon_device_count++;\n\t\t\tocteon_device[oct_idx] = oct;\n\t\t}\n\t}\n\n\tspin_unlock(&octeon_devices_lock);\n\tif (!oct)\n\t\treturn NULL;\n\n\tspin_lock_init(&oct->pci_win_lock);\n\tspin_lock_init(&oct->mem_access_lock);\n\n\toct->octeon_id = oct_idx;\n\tsnprintf(oct->device_name, sizeof(oct->device_name),\n\t\t \"LiquidIO%d\", (oct->octeon_id));\n\n\treturn oct;\n}\nEXPORT_SYMBOL_GPL(octeon_allocate_device);\n\n \nint octeon_register_device(struct octeon_device *oct,\n\t\t\t   int bus, int dev, int func, int is_pf)\n{\n\tint idx, refcount;\n\n\toct->loc.bus = bus;\n\toct->loc.dev = dev;\n\toct->loc.func = func;\n\n\toct->adapter_refcount = &adapter_refcounts[oct->octeon_id];\n\tatomic_set(oct->adapter_refcount, 0);\n\n\t \n\toct->adapter_fw_state = &adapter_fw_states[oct->octeon_id];\n\tatomic_set(oct->adapter_fw_state, FW_NEEDS_TO_BE_LOADED);\n\n\tspin_lock(&octeon_devices_lock);\n\tfor (idx = (int)oct->octeon_id - 1; idx >= 0; idx--) {\n\t\tif (!octeon_device[idx]) {\n\t\t\tdev_err(&oct->pci_dev->dev,\n\t\t\t\t\"%s: Internal driver error, missing dev\",\n\t\t\t\t__func__);\n\t\t\tspin_unlock(&octeon_devices_lock);\n\t\t\tatomic_inc(oct->adapter_refcount);\n\t\t\treturn 1;  \n\t\t}\n\t\t \n\t\tif ((octeon_device[idx]->loc.bus == bus) &&\n\t\t    (octeon_device[idx]->loc.dev == dev)) {\n\t\t\toct->adapter_refcount =\n\t\t\t\tocteon_device[idx]->adapter_refcount;\n\t\t\toct->adapter_fw_state =\n\t\t\t\tocteon_device[idx]->adapter_fw_state;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&octeon_devices_lock);\n\n\tatomic_inc(oct->adapter_refcount);\n\trefcount = atomic_read(oct->adapter_refcount);\n\n\tdev_dbg(&oct->pci_dev->dev, \"%s: %02x:%02x:%d refcount %u\", __func__,\n\t\toct->loc.bus, oct->loc.dev, oct->loc.func, refcount);\n\n\treturn refcount;\n}\nEXPORT_SYMBOL_GPL(octeon_register_device);\n\n \nint octeon_deregister_device(struct octeon_device *oct)\n{\n\tint refcount;\n\n\tatomic_dec(oct->adapter_refcount);\n\trefcount = atomic_read(oct->adapter_refcount);\n\n\tdev_dbg(&oct->pci_dev->dev, \"%s: %04d:%02d:%d refcount %u\", __func__,\n\t\toct->loc.bus, oct->loc.dev, oct->loc.func, refcount);\n\n\treturn refcount;\n}\nEXPORT_SYMBOL_GPL(octeon_deregister_device);\n\nint\nocteon_allocate_ioq_vector(struct octeon_device *oct, u32 num_ioqs)\n{\n\tstruct octeon_ioq_vector *ioq_vector;\n\tint cpu_num;\n\tint size;\n\tint i;\n\n\tsize = sizeof(struct octeon_ioq_vector) * num_ioqs;\n\n\toct->ioq_vector = vzalloc(size);\n\tif (!oct->ioq_vector)\n\t\treturn -1;\n\tfor (i = 0; i < num_ioqs; i++) {\n\t\tioq_vector\t\t= &oct->ioq_vector[i];\n\t\tioq_vector->oct_dev\t= oct;\n\t\tioq_vector->iq_index\t= i;\n\t\tioq_vector->droq_index\t= i;\n\t\tioq_vector->mbox\t= oct->mbox[i];\n\n\t\tcpu_num = i % num_online_cpus();\n\t\tcpumask_set_cpu(cpu_num, &ioq_vector->affinity_mask);\n\n\t\tif (oct->chip_id == OCTEON_CN23XX_PF_VID)\n\t\t\tioq_vector->ioq_num\t= i + oct->sriov_info.pf_srn;\n\t\telse\n\t\t\tioq_vector->ioq_num\t= i;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(octeon_allocate_ioq_vector);\n\nvoid\nocteon_free_ioq_vector(struct octeon_device *oct)\n{\n\tvfree(oct->ioq_vector);\n}\nEXPORT_SYMBOL_GPL(octeon_free_ioq_vector);\n\n \nint octeon_setup_instr_queues(struct octeon_device *oct)\n{\n\tu32 num_descs = 0;\n\tu32 iq_no = 0;\n\tunion oct_txpciq txpciq;\n\tint numa_node = dev_to_node(&oct->pci_dev->dev);\n\n\tif (OCTEON_CN6XXX(oct))\n\t\tnum_descs =\n\t\t\tCFG_GET_NUM_DEF_TX_DESCS(CHIP_CONF(oct, cn6xxx));\n\telse if (OCTEON_CN23XX_PF(oct))\n\t\tnum_descs = CFG_GET_NUM_DEF_TX_DESCS(CHIP_CONF(oct, cn23xx_pf));\n\telse if (OCTEON_CN23XX_VF(oct))\n\t\tnum_descs = CFG_GET_NUM_DEF_TX_DESCS(CHIP_CONF(oct, cn23xx_vf));\n\n\toct->num_iqs = 0;\n\n\toct->instr_queue[0] = vzalloc_node(sizeof(*oct->instr_queue[0]),\n\t\t\t\tnuma_node);\n\tif (!oct->instr_queue[0])\n\t\toct->instr_queue[0] =\n\t\t\tvzalloc(sizeof(struct octeon_instr_queue));\n\tif (!oct->instr_queue[0])\n\t\treturn 1;\n\tmemset(oct->instr_queue[0], 0, sizeof(struct octeon_instr_queue));\n\toct->instr_queue[0]->q_index = 0;\n\toct->instr_queue[0]->app_ctx = (void *)(size_t)0;\n\toct->instr_queue[0]->ifidx = 0;\n\ttxpciq.u64 = 0;\n\ttxpciq.s.q_no = iq_no;\n\ttxpciq.s.pkind = oct->pfvf_hsword.pkind;\n\ttxpciq.s.use_qpg = 0;\n\ttxpciq.s.qpg = 0;\n\tif (octeon_init_instr_queue(oct, txpciq, num_descs)) {\n\t\t \n\t\tvfree(oct->instr_queue[0]);\n\t\toct->instr_queue[0] = NULL;\n\t\treturn 1;\n\t}\n\n\toct->num_iqs++;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(octeon_setup_instr_queues);\n\nint octeon_setup_output_queues(struct octeon_device *oct)\n{\n\tu32 num_descs = 0;\n\tu32 desc_size = 0;\n\tu32 oq_no = 0;\n\tint numa_node = dev_to_node(&oct->pci_dev->dev);\n\n\tif (OCTEON_CN6XXX(oct)) {\n\t\tnum_descs =\n\t\t\tCFG_GET_NUM_DEF_RX_DESCS(CHIP_CONF(oct, cn6xxx));\n\t\tdesc_size =\n\t\t\tCFG_GET_DEF_RX_BUF_SIZE(CHIP_CONF(oct, cn6xxx));\n\t} else if (OCTEON_CN23XX_PF(oct)) {\n\t\tnum_descs = CFG_GET_NUM_DEF_RX_DESCS(CHIP_CONF(oct, cn23xx_pf));\n\t\tdesc_size = CFG_GET_DEF_RX_BUF_SIZE(CHIP_CONF(oct, cn23xx_pf));\n\t} else if (OCTEON_CN23XX_VF(oct)) {\n\t\tnum_descs = CFG_GET_NUM_DEF_RX_DESCS(CHIP_CONF(oct, cn23xx_vf));\n\t\tdesc_size = CFG_GET_DEF_RX_BUF_SIZE(CHIP_CONF(oct, cn23xx_vf));\n\t}\n\toct->num_oqs = 0;\n\toct->droq[0] = vzalloc_node(sizeof(*oct->droq[0]), numa_node);\n\tif (!oct->droq[0])\n\t\toct->droq[0] = vzalloc(sizeof(*oct->droq[0]));\n\tif (!oct->droq[0])\n\t\treturn 1;\n\n\tif (octeon_init_droq(oct, oq_no, num_descs, desc_size, NULL)) {\n\t\tvfree(oct->droq[oq_no]);\n\t\toct->droq[oq_no] = NULL;\n\t\treturn 1;\n\t}\n\toct->num_oqs++;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(octeon_setup_output_queues);\n\nint octeon_set_io_queues_off(struct octeon_device *oct)\n{\n\tint loop = BUSY_READING_REG_VF_LOOP_COUNT;\n\n\tif (OCTEON_CN6XXX(oct)) {\n\t\tocteon_write_csr(oct, CN6XXX_SLI_PKT_INSTR_ENB, 0);\n\t\tocteon_write_csr(oct, CN6XXX_SLI_PKT_OUT_ENB, 0);\n\t} else if (oct->chip_id == OCTEON_CN23XX_VF_VID) {\n\t\tu32 q_no;\n\n\t\t \n\t\tfor (q_no = 0; q_no < oct->sriov_info.rings_per_vf; q_no++) {\n\t\t\tu64 reg_val = octeon_read_csr64(\n\t\t\t\toct, CN23XX_VF_SLI_IQ_PKT_CONTROL64(q_no));\n\n\t\t\twhile ((reg_val & CN23XX_PKT_INPUT_CTL_RST) &&\n\t\t\t       !(reg_val &  CN23XX_PKT_INPUT_CTL_QUIET) &&\n\t\t\t       loop) {\n\t\t\t\treg_val = octeon_read_csr64(\n\t\t\t\t\toct, CN23XX_SLI_IQ_PKT_CONTROL64(q_no));\n\t\t\t\tloop--;\n\t\t\t}\n\t\t\tif (!loop) {\n\t\t\t\tdev_err(&oct->pci_dev->dev,\n\t\t\t\t\t\"clearing the reset reg failed or setting the quiet reg failed for qno: %u\\n\",\n\t\t\t\t\tq_no);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\treg_val = reg_val & ~CN23XX_PKT_INPUT_CTL_RST;\n\t\t\tocteon_write_csr64(oct,\n\t\t\t\t\t   CN23XX_SLI_IQ_PKT_CONTROL64(q_no),\n\t\t\t\t\t   reg_val);\n\n\t\t\treg_val = octeon_read_csr64(\n\t\t\t\t\toct, CN23XX_SLI_IQ_PKT_CONTROL64(q_no));\n\t\t\tif (reg_val & CN23XX_PKT_INPUT_CTL_RST) {\n\t\t\t\tdev_err(&oct->pci_dev->dev,\n\t\t\t\t\t\"unable to reset qno %u\\n\", q_no);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(octeon_set_io_queues_off);\n\nvoid octeon_set_droq_pkt_op(struct octeon_device *oct,\n\t\t\t    u32 q_no,\n\t\t\t    u32 enable)\n{\n\tu32 reg_val = 0;\n\n\t \n\tif (OCTEON_CN6XXX(oct)) {\n\t\treg_val = octeon_read_csr(oct, CN6XXX_SLI_PKT_OUT_ENB);\n\n\t\tif (enable)\n\t\t\treg_val = reg_val | (1 << q_no);\n\t\telse\n\t\t\treg_val = reg_val & (~(1 << q_no));\n\n\t\tocteon_write_csr(oct, CN6XXX_SLI_PKT_OUT_ENB, reg_val);\n\t}\n}\n\nint octeon_init_dispatch_list(struct octeon_device *oct)\n{\n\tu32 i;\n\n\toct->dispatch.count = 0;\n\n\tfor (i = 0; i < DISPATCH_LIST_SIZE; i++) {\n\t\toct->dispatch.dlist[i].opcode = 0;\n\t\tINIT_LIST_HEAD(&oct->dispatch.dlist[i].list);\n\t}\n\n\tfor (i = 0; i <= REQTYPE_LAST; i++)\n\t\tocteon_register_reqtype_free_fn(oct, i, NULL);\n\n\tspin_lock_init(&oct->dispatch.lock);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(octeon_init_dispatch_list);\n\nvoid octeon_delete_dispatch_list(struct octeon_device *oct)\n{\n\tu32 i;\n\tstruct list_head freelist, *temp, *tmp2;\n\n\tINIT_LIST_HEAD(&freelist);\n\n\tspin_lock_bh(&oct->dispatch.lock);\n\n\tfor (i = 0; i < DISPATCH_LIST_SIZE; i++) {\n\t\tstruct list_head *dispatch;\n\n\t\tdispatch = &oct->dispatch.dlist[i].list;\n\t\twhile (dispatch->next != dispatch) {\n\t\t\ttemp = dispatch->next;\n\t\t\tlist_move_tail(temp, &freelist);\n\t\t}\n\n\t\toct->dispatch.dlist[i].opcode = 0;\n\t}\n\n\toct->dispatch.count = 0;\n\n\tspin_unlock_bh(&oct->dispatch.lock);\n\n\tlist_for_each_safe(temp, tmp2, &freelist) {\n\t\tlist_del(temp);\n\t\tkfree(temp);\n\t}\n}\nEXPORT_SYMBOL_GPL(octeon_delete_dispatch_list);\n\nocteon_dispatch_fn_t\nocteon_get_dispatch(struct octeon_device *octeon_dev, u16 opcode,\n\t\t    u16 subcode)\n{\n\tu32 idx;\n\tstruct list_head *dispatch;\n\tocteon_dispatch_fn_t fn = NULL;\n\tu16 combined_opcode = OPCODE_SUBCODE(opcode, subcode);\n\n\tidx = combined_opcode & OCTEON_OPCODE_MASK;\n\n\tspin_lock_bh(&octeon_dev->dispatch.lock);\n\n\tif (octeon_dev->dispatch.count == 0) {\n\t\tspin_unlock_bh(&octeon_dev->dispatch.lock);\n\t\treturn NULL;\n\t}\n\n\tif (!(octeon_dev->dispatch.dlist[idx].opcode)) {\n\t\tspin_unlock_bh(&octeon_dev->dispatch.lock);\n\t\treturn NULL;\n\t}\n\n\tif (octeon_dev->dispatch.dlist[idx].opcode == combined_opcode) {\n\t\tfn = octeon_dev->dispatch.dlist[idx].dispatch_fn;\n\t} else {\n\t\tlist_for_each(dispatch,\n\t\t\t      &octeon_dev->dispatch.dlist[idx].list) {\n\t\t\tif (((struct octeon_dispatch *)dispatch)->opcode ==\n\t\t\t    combined_opcode) {\n\t\t\t\tfn = ((struct octeon_dispatch *)\n\t\t\t\t      dispatch)->dispatch_fn;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tspin_unlock_bh(&octeon_dev->dispatch.lock);\n\treturn fn;\n}\n\n \nint\nocteon_register_dispatch_fn(struct octeon_device *oct,\n\t\t\t    u16 opcode,\n\t\t\t    u16 subcode,\n\t\t\t    octeon_dispatch_fn_t fn, void *fn_arg)\n{\n\tu32 idx;\n\tocteon_dispatch_fn_t pfn;\n\tu16 combined_opcode = OPCODE_SUBCODE(opcode, subcode);\n\n\tidx = combined_opcode & OCTEON_OPCODE_MASK;\n\n\tspin_lock_bh(&oct->dispatch.lock);\n\t \n\tif (oct->dispatch.dlist[idx].opcode == 0) {\n\t\toct->dispatch.dlist[idx].opcode = combined_opcode;\n\t\toct->dispatch.dlist[idx].dispatch_fn = fn;\n\t\toct->dispatch.dlist[idx].arg = fn_arg;\n\t\toct->dispatch.count++;\n\t\tspin_unlock_bh(&oct->dispatch.lock);\n\t\treturn 0;\n\t}\n\n\tspin_unlock_bh(&oct->dispatch.lock);\n\n\t \n\tpfn = octeon_get_dispatch(oct, opcode, subcode);\n\tif (!pfn) {\n\t\tstruct octeon_dispatch *dispatch;\n\n\t\tdev_dbg(&oct->pci_dev->dev,\n\t\t\t\"Adding opcode to dispatch list linked list\\n\");\n\t\tdispatch = kmalloc(sizeof(*dispatch), GFP_KERNEL);\n\t\tif (!dispatch)\n\t\t\treturn 1;\n\n\t\tdispatch->opcode = combined_opcode;\n\t\tdispatch->dispatch_fn = fn;\n\t\tdispatch->arg = fn_arg;\n\n\t\t \n\t\tspin_lock_bh(&oct->dispatch.lock);\n\t\tlist_add(&dispatch->list, &oct->dispatch.dlist[idx].list);\n\t\toct->dispatch.count++;\n\t\tspin_unlock_bh(&oct->dispatch.lock);\n\n\t} else {\n\t\tif (pfn == fn &&\n\t\t    octeon_get_dispatch_arg(oct, opcode, subcode) == fn_arg)\n\t\t\treturn 0;\n\n\t\tdev_err(&oct->pci_dev->dev,\n\t\t\t\"Found previously registered dispatch fn for opcode/subcode: %x/%x\\n\",\n\t\t\topcode, subcode);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(octeon_register_dispatch_fn);\n\nint octeon_core_drv_init(struct octeon_recv_info *recv_info, void *buf)\n{\n\tu32 i;\n\tchar app_name[16];\n\tstruct octeon_device *oct = (struct octeon_device *)buf;\n\tstruct octeon_recv_pkt *recv_pkt = recv_info->recv_pkt;\n\tstruct octeon_core_setup *cs = NULL;\n\tu32 num_nic_ports = 0;\n\n\tif (OCTEON_CN6XXX(oct))\n\t\tnum_nic_ports =\n\t\t\tCFG_GET_NUM_NIC_PORTS(CHIP_CONF(oct, cn6xxx));\n\telse if (OCTEON_CN23XX_PF(oct))\n\t\tnum_nic_ports =\n\t\t\tCFG_GET_NUM_NIC_PORTS(CHIP_CONF(oct, cn23xx_pf));\n\n\tif (atomic_read(&oct->status) >= OCT_DEV_RUNNING) {\n\t\tdev_err(&oct->pci_dev->dev, \"Received CORE OK when device state is 0x%x\\n\",\n\t\t\tatomic_read(&oct->status));\n\t\tgoto core_drv_init_err;\n\t}\n\n\tstrncpy(app_name,\n\t\tget_oct_app_string(\n\t\t(u32)recv_pkt->rh.r_core_drv_init.app_mode),\n\t\tsizeof(app_name) - 1);\n\toct->app_mode = (u32)recv_pkt->rh.r_core_drv_init.app_mode;\n\tif (recv_pkt->rh.r_core_drv_init.app_mode == CVM_DRV_NIC_APP) {\n\t\toct->fw_info.max_nic_ports =\n\t\t\t(u32)recv_pkt->rh.r_core_drv_init.max_nic_ports;\n\t\toct->fw_info.num_gmx_ports =\n\t\t\t(u32)recv_pkt->rh.r_core_drv_init.num_gmx_ports;\n\t}\n\n\tif (oct->fw_info.max_nic_ports < num_nic_ports) {\n\t\tdev_err(&oct->pci_dev->dev,\n\t\t\t\"Config has more ports than firmware allows (%d > %d).\\n\",\n\t\t\tnum_nic_ports, oct->fw_info.max_nic_ports);\n\t\tgoto core_drv_init_err;\n\t}\n\toct->fw_info.app_cap_flags = recv_pkt->rh.r_core_drv_init.app_cap_flags;\n\toct->fw_info.app_mode = (u32)recv_pkt->rh.r_core_drv_init.app_mode;\n\toct->pfvf_hsword.app_mode = (u32)recv_pkt->rh.r_core_drv_init.app_mode;\n\n\toct->pfvf_hsword.pkind = recv_pkt->rh.r_core_drv_init.pkind;\n\n\tfor (i = 0; i < oct->num_iqs; i++)\n\t\toct->instr_queue[i]->txpciq.s.pkind = oct->pfvf_hsword.pkind;\n\n\tatomic_set(&oct->status, OCT_DEV_CORE_OK);\n\n\tcs = &core_setup[oct->octeon_id];\n\n\tif (recv_pkt->buffer_size[0] != (sizeof(*cs) + OCT_DROQ_INFO_SIZE)) {\n\t\tdev_dbg(&oct->pci_dev->dev, \"Core setup bytes expected %u found %d\\n\",\n\t\t\t(u32)sizeof(*cs),\n\t\t\trecv_pkt->buffer_size[0]);\n\t}\n\n\tmemcpy(cs, get_rbd(\n\t       recv_pkt->buffer_ptr[0]) + OCT_DROQ_INFO_SIZE, sizeof(*cs));\n\n\tstrncpy(oct->boardinfo.name, cs->boardname, OCT_BOARD_NAME);\n\tstrncpy(oct->boardinfo.serial_number, cs->board_serial_number,\n\t\tOCT_SERIAL_LEN);\n\n\tocteon_swap_8B_data((u64 *)cs, (sizeof(*cs) >> 3));\n\n\toct->boardinfo.major = cs->board_rev_major;\n\toct->boardinfo.minor = cs->board_rev_minor;\n\n\tdev_info(&oct->pci_dev->dev,\n\t\t \"Running %s (%llu Hz)\\n\",\n\t\t app_name, CVM_CAST64(cs->corefreq));\n\ncore_drv_init_err:\n\tfor (i = 0; i < recv_pkt->buffer_count; i++)\n\t\trecv_buffer_free(recv_pkt->buffer_ptr[i]);\n\tocteon_free_recv_info(recv_info);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(octeon_core_drv_init);\n\nint octeon_get_tx_qsize(struct octeon_device *oct, u32 q_no)\n\n{\n\tif (oct && (q_no < MAX_OCTEON_INSTR_QUEUES(oct)) &&\n\t    (oct->io_qmask.iq & BIT_ULL(q_no)))\n\t\treturn oct->instr_queue[q_no]->max_count;\n\n\treturn -1;\n}\nEXPORT_SYMBOL_GPL(octeon_get_tx_qsize);\n\nint octeon_get_rx_qsize(struct octeon_device *oct, u32 q_no)\n{\n\tif (oct && (q_no < MAX_OCTEON_OUTPUT_QUEUES(oct)) &&\n\t    (oct->io_qmask.oq & BIT_ULL(q_no)))\n\t\treturn oct->droq[q_no]->max_count;\n\treturn -1;\n}\nEXPORT_SYMBOL_GPL(octeon_get_rx_qsize);\n\n \nstruct octeon_config *octeon_get_conf(struct octeon_device *oct)\n{\n\tstruct octeon_config *default_oct_conf = NULL;\n\n\t \n\n\tif (OCTEON_CN6XXX(oct)) {\n\t\tdefault_oct_conf =\n\t\t\t(struct octeon_config *)(CHIP_CONF(oct, cn6xxx));\n\t} else if (OCTEON_CN23XX_PF(oct)) {\n\t\tdefault_oct_conf = (struct octeon_config *)\n\t\t\t(CHIP_CONF(oct, cn23xx_pf));\n\t} else if (OCTEON_CN23XX_VF(oct)) {\n\t\tdefault_oct_conf = (struct octeon_config *)\n\t\t\t(CHIP_CONF(oct, cn23xx_vf));\n\t}\n\treturn default_oct_conf;\n}\nEXPORT_SYMBOL_GPL(octeon_get_conf);\n\n \n#define CNXX_SLI_SCRATCH1   0x3C0\n\n \nstruct octeon_device *lio_get_device(u32 octeon_id)\n{\n\tif (octeon_id >= MAX_OCTEON_DEVICES)\n\t\treturn NULL;\n\telse\n\t\treturn octeon_device[octeon_id];\n}\nEXPORT_SYMBOL_GPL(lio_get_device);\n\nu64 lio_pci_readq(struct octeon_device *oct, u64 addr)\n{\n\tu64 val64;\n\tunsigned long flags;\n\tu32 addrhi;\n\n\tspin_lock_irqsave(&oct->pci_win_lock, flags);\n\n\t \n\taddrhi = (addr >> 32);\n\tif ((oct->chip_id == OCTEON_CN66XX) ||\n\t    (oct->chip_id == OCTEON_CN68XX) ||\n\t    (oct->chip_id == OCTEON_CN23XX_PF_VID))\n\t\taddrhi |= 0x00060000;\n\twritel(addrhi, oct->reg_list.pci_win_rd_addr_hi);\n\n\t \n\treadl(oct->reg_list.pci_win_rd_addr_hi);\n\n\twritel(addr & 0xffffffff, oct->reg_list.pci_win_rd_addr_lo);\n\treadl(oct->reg_list.pci_win_rd_addr_lo);\n\n\tval64 = readq(oct->reg_list.pci_win_rd_data);\n\n\tspin_unlock_irqrestore(&oct->pci_win_lock, flags);\n\n\treturn val64;\n}\nEXPORT_SYMBOL_GPL(lio_pci_readq);\n\nvoid lio_pci_writeq(struct octeon_device *oct,\n\t\t    u64 val,\n\t\t    u64 addr)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&oct->pci_win_lock, flags);\n\n\twriteq(addr, oct->reg_list.pci_win_wr_addr);\n\n\t \n\twritel(val >> 32, oct->reg_list.pci_win_wr_data_hi);\n\t \n\treadl(oct->reg_list.pci_win_wr_data_hi);\n\n\twritel(val & 0xffffffff, oct->reg_list.pci_win_wr_data_lo);\n\n\tspin_unlock_irqrestore(&oct->pci_win_lock, flags);\n}\nEXPORT_SYMBOL_GPL(lio_pci_writeq);\n\nint octeon_mem_access_ok(struct octeon_device *oct)\n{\n\tu64 access_okay = 0;\n\tu64 lmc0_reset_ctl;\n\n\t \n\tif (OCTEON_CN23XX_PF(oct)) {\n\t\tlmc0_reset_ctl = lio_pci_readq(oct, CN23XX_LMC0_RESET_CTL);\n\t\taccess_okay =\n\t\t\t(lmc0_reset_ctl & CN23XX_LMC0_RESET_CTL_DDR3RST_MASK);\n\t} else {\n\t\tlmc0_reset_ctl = lio_pci_readq(oct, CN6XXX_LMC0_RESET_CTL);\n\t\taccess_okay =\n\t\t\t(lmc0_reset_ctl & CN6XXX_LMC0_RESET_CTL_DDR3RST_MASK);\n\t}\n\n\treturn access_okay ? 0 : 1;\n}\nEXPORT_SYMBOL_GPL(octeon_mem_access_ok);\n\nint octeon_wait_for_ddr_init(struct octeon_device *oct, u32 *timeout)\n{\n\tint ret = 1;\n\tu32 ms;\n\n\tif (!timeout)\n\t\treturn ret;\n\n\tfor (ms = 0; (ret != 0) && ((*timeout == 0) || (ms <= *timeout));\n\t     ms += HZ / 10) {\n\t\tret = octeon_mem_access_ok(oct);\n\n\t\t \n\t\tif (ret)\n\t\t\tschedule_timeout_uninterruptible(HZ / 10);\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(octeon_wait_for_ddr_init);\n\n \nint lio_get_device_id(void *dev)\n{\n\tstruct octeon_device *octeon_dev = (struct octeon_device *)dev;\n\tu32 i;\n\n\tfor (i = 0; i < MAX_OCTEON_DEVICES; i++)\n\t\tif (octeon_device[i] == octeon_dev)\n\t\t\treturn octeon_dev->octeon_id;\n\treturn -1;\n}\n\nvoid lio_enable_irq(struct octeon_droq *droq, struct octeon_instr_queue *iq)\n{\n\tu64 instr_cnt;\n\tu32 pkts_pend;\n\tstruct octeon_device *oct = NULL;\n\n\t \n\tif (droq) {\n\t\tpkts_pend = (u32)atomic_read(&droq->pkts_pending);\n\t\twritel(droq->pkt_count - pkts_pend, droq->pkts_sent_reg);\n\t\tdroq->pkt_count = pkts_pend;\n\t\toct = droq->oct_dev;\n\t}\n\tif (iq) {\n\t\tspin_lock_bh(&iq->lock);\n\t\twritel(iq->pkts_processed, iq->inst_cnt_reg);\n\t\tiq->pkt_in_done -= iq->pkts_processed;\n\t\tiq->pkts_processed = 0;\n\t\t \n\t\tspin_unlock_bh(&iq->lock);\n\t\toct = iq->oct_dev;\n\t}\n\t \n\tif (oct && (OCTEON_CN23XX_PF(oct) || OCTEON_CN23XX_VF(oct))) {\n\t\tif (droq)\n\t\t\twriteq(CN23XX_INTR_RESEND, droq->pkts_sent_reg);\n\t\t \n\t\telse if (iq) {\n\t\t\tinstr_cnt =  readq(iq->inst_cnt_reg);\n\t\t\twriteq(((instr_cnt & 0xFFFFFFFF00000000ULL) |\n\t\t\t\tCN23XX_INTR_RESEND),\n\t\t\t       iq->inst_cnt_reg);\n\t\t}\n\t}\n}\nEXPORT_SYMBOL_GPL(lio_enable_irq);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}