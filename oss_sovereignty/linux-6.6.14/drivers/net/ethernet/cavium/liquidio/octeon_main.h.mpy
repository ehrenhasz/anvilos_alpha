{
  "module_name": "octeon_main.h",
  "hash_id": "1d1ff8c2818610080e5197fe2ed551097071eb914b70ebda4534e223eedc1e37",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/cavium/liquidio/octeon_main.h",
  "human_readable_source": " \n \n\n#ifndef _OCTEON_MAIN_H_\n#define  _OCTEON_MAIN_H_\n\n#include <linux/sched/signal.h>\n\n#if BITS_PER_LONG == 32\n#define CVM_CAST64(v) ((long long)(v))\n#elif BITS_PER_LONG == 64\n#define CVM_CAST64(v) ((long long)(long)(v))\n#else\n#error \"Unknown system architecture\"\n#endif\n\n#define DRV_NAME \"LiquidIO\"\n\nstruct octeon_device_priv {\n\t \n\tstruct tasklet_struct droq_tasklet;\n\tunsigned long napi_mask;\n\tstruct octeon_device *dev;\n};\n\n \nstruct octnet_buf_free_info {\n\t \n\tstruct lio *lio;\n\n\t \n\tstruct sk_buff *skb;\n\n\t \n\tstruct octnic_gather *g;\n\n\t \n\tu64 dptr;\n\n\t \n\tstruct octeon_soft_command *sc;\n};\n\n \nint octeon_report_sent_bytes_to_bql(void *buf, int reqtype);\nvoid octeon_update_tx_completion_counters(void *buf, int reqtype,\n\t\t\t\t\t  unsigned int *pkts_compl,\n\t\t\t\t\t  unsigned int *bytes_compl);\nvoid octeon_report_tx_completion_to_bql(void *txq, unsigned int pkts_compl,\n\t\t\t\t\tunsigned int bytes_compl);\nvoid octeon_pf_changed_vf_macaddr(struct octeon_device *oct, u8 *mac);\n\nvoid octeon_schedule_rxq_oom_work(struct octeon_device *oct,\n\t\t\t\t  struct octeon_droq *droq);\n\n \nstatic inline void octeon_swap_8B_data(u64 *data, u32 blocks)\n{\n\twhile (blocks) {\n\t\tcpu_to_be64s(data);\n\t\tblocks--;\n\t\tdata++;\n\t}\n}\n\n \nstatic inline void octeon_unmap_pci_barx(struct octeon_device *oct, int baridx)\n{\n\tdev_dbg(&oct->pci_dev->dev, \"Freeing PCI mapped regions for Bar%d\\n\",\n\t\tbaridx);\n\n\tif (oct->mmio[baridx].done)\n\t\tiounmap(oct->mmio[baridx].hw_addr);\n\n\tif (oct->mmio[baridx].start)\n\t\tpci_release_region(oct->pci_dev, baridx * 2);\n}\n\n \nstatic inline int octeon_map_pci_barx(struct octeon_device *oct,\n\t\t\t\t      int baridx, int max_map_len)\n{\n\tu32 mapped_len = 0;\n\n\tif (pci_request_region(oct->pci_dev, baridx * 2, DRV_NAME)) {\n\t\tdev_err(&oct->pci_dev->dev, \"pci_request_region failed for bar %d\\n\",\n\t\t\tbaridx);\n\t\treturn 1;\n\t}\n\n\toct->mmio[baridx].start = pci_resource_start(oct->pci_dev, baridx * 2);\n\toct->mmio[baridx].len = pci_resource_len(oct->pci_dev, baridx * 2);\n\n\tmapped_len = oct->mmio[baridx].len;\n\tif (!mapped_len)\n\t\tgoto err_release_region;\n\n\tif (max_map_len && (mapped_len > max_map_len))\n\t\tmapped_len = max_map_len;\n\n\toct->mmio[baridx].hw_addr =\n\t\tioremap(oct->mmio[baridx].start, mapped_len);\n\toct->mmio[baridx].mapped_len = mapped_len;\n\n\tdev_dbg(&oct->pci_dev->dev, \"BAR%d start: 0x%llx mapped %u of %u bytes\\n\",\n\t\tbaridx, oct->mmio[baridx].start, mapped_len,\n\t\toct->mmio[baridx].len);\n\n\tif (!oct->mmio[baridx].hw_addr) {\n\t\tdev_err(&oct->pci_dev->dev, \"error ioremap for bar %d\\n\",\n\t\t\tbaridx);\n\t\tgoto err_release_region;\n\t}\n\toct->mmio[baridx].done = 1;\n\n\treturn 0;\n\nerr_release_region:\n\tpci_release_region(oct->pci_dev, baridx * 2);\n\treturn 1;\n}\n\n \nstatic inline int\nwait_for_sc_completion_timeout(struct octeon_device *oct_dev,\n\t\t\t       struct octeon_soft_command *sc,\n\t\t\t       unsigned long timeout)\n{\n\tint errno = 0;\n\tlong timeout_jiff;\n\n\tif (timeout)\n\t\ttimeout_jiff = msecs_to_jiffies(timeout);\n\telse\n\t\ttimeout_jiff = MAX_SCHEDULE_TIMEOUT;\n\n\ttimeout_jiff =\n\t\twait_for_completion_interruptible_timeout(&sc->complete,\n\t\t\t\t\t\t\t  timeout_jiff);\n\tif (timeout_jiff == 0) {\n\t\tdev_err(&oct_dev->pci_dev->dev, \"%s: sc is timeout\\n\",\n\t\t\t__func__);\n\t\tWRITE_ONCE(sc->caller_is_done, true);\n\t\terrno = -ETIME;\n\t} else if (timeout_jiff == -ERESTARTSYS) {\n\t\tdev_err(&oct_dev->pci_dev->dev, \"%s: sc is interrupted\\n\",\n\t\t\t__func__);\n\t\tWRITE_ONCE(sc->caller_is_done, true);\n\t\terrno = -EINTR;\n\t} else  if (sc->sc_status == OCTEON_REQUEST_TIMEOUT) {\n\t\tdev_err(&oct_dev->pci_dev->dev, \"%s: sc has fatal timeout\\n\",\n\t\t\t__func__);\n\t\tWRITE_ONCE(sc->caller_is_done, true);\n\t\terrno = -EBUSY;\n\t}\n\n\treturn errno;\n}\n\n#ifndef ROUNDUP4\n#define ROUNDUP4(val) (((val) + 3) & 0xfffffffc)\n#endif\n\n#ifndef ROUNDUP8\n#define ROUNDUP8(val) (((val) + 7) & 0xfffffff8)\n#endif\n\n#ifndef ROUNDUP16\n#define ROUNDUP16(val) (((val) + 15) & 0xfffffff0)\n#endif\n\n#ifndef ROUNDUP128\n#define ROUNDUP128(val) (((val) + 127) & 0xffffff80)\n#endif\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}