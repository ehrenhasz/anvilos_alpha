{
  "module_name": "octeon_nic.c",
  "hash_id": "47f71888d00e1e63faf501f56159f003675239c333347f826cc6824ae96b7fc5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/cavium/liquidio/octeon_nic.c",
  "human_readable_source": " \n#include <linux/pci.h>\n#include <linux/netdevice.h>\n#include \"liquidio_common.h\"\n#include \"octeon_droq.h\"\n#include \"octeon_iq.h\"\n#include \"response_manager.h\"\n#include \"octeon_device.h\"\n#include \"octeon_nic.h\"\n#include \"octeon_main.h\"\n\nvoid *\nocteon_alloc_soft_command_resp(struct octeon_device    *oct,\n\t\t\t       union octeon_instr_64B *cmd,\n\t\t\t       u32\t\t       rdatasize)\n{\n\tstruct octeon_soft_command *sc;\n\tstruct octeon_instr_ih3  *ih3;\n\tstruct octeon_instr_ih2  *ih2;\n\tstruct octeon_instr_irh *irh;\n\tstruct octeon_instr_rdp *rdp;\n\n\tsc = (struct octeon_soft_command *)\n\t\tocteon_alloc_soft_command(oct, 0, rdatasize, 0);\n\n\tif (!sc)\n\t\treturn NULL;\n\n\t \n\tmemcpy(&sc->cmd, cmd, sizeof(union octeon_instr_64B));\n\n\t \n\tif (OCTEON_CN23XX_PF(oct) || OCTEON_CN23XX_VF(oct)) {\n\t\tih3      = (struct octeon_instr_ih3 *)&sc->cmd.cmd3.ih3;\n\t\trdp     = (struct octeon_instr_rdp *)&sc->cmd.cmd3.rdp;\n\t\tirh     = (struct octeon_instr_irh *)&sc->cmd.cmd3.irh;\n\t\t \n\t\tih3->fsz = LIO_SOFTCMDRESP_IH3;\n\t} else {\n\t\tih2      = (struct octeon_instr_ih2 *)&sc->cmd.cmd2.ih2;\n\t\trdp     = (struct octeon_instr_rdp *)&sc->cmd.cmd2.rdp;\n\t\tirh     = (struct octeon_instr_irh *)&sc->cmd.cmd2.irh;\n\t\t \n\t\tih2->fsz = LIO_SOFTCMDRESP_IH2;\n\t}\n\n\tirh->rflag = 1;  \n\n\trdp->pcie_port = oct->pcie_port;\n\trdp->rlen      = rdatasize;\n\n\t*sc->status_word = COMPLETION_WORD_INIT;\n\n\tif (OCTEON_CN23XX_PF(oct) || OCTEON_CN23XX_VF(oct))\n\t\tsc->cmd.cmd3.rptr =  sc->dmarptr;\n\telse\n\t\tsc->cmd.cmd2.rptr =  sc->dmarptr;\n\n\tsc->expiry_time = jiffies + msecs_to_jiffies(LIO_SC_MAX_TMO_MS);\n\n\treturn sc;\n}\nEXPORT_SYMBOL_GPL(octeon_alloc_soft_command_resp);\n\nint octnet_send_nic_data_pkt(struct octeon_device *oct,\n\t\t\t     struct octnic_data_pkt *ndata,\n\t\t\t     int xmit_more)\n{\n\tint ring_doorbell = !xmit_more;\n\n\treturn octeon_send_command(oct, ndata->q_no, ring_doorbell, &ndata->cmd,\n\t\t\t\t   ndata->buf, ndata->datasize,\n\t\t\t\t   ndata->reqtype);\n}\nEXPORT_SYMBOL_GPL(octnet_send_nic_data_pkt);\n\nstatic inline struct octeon_soft_command\n*octnic_alloc_ctrl_pkt_sc(struct octeon_device *oct,\n\t\t\t  struct octnic_ctrl_pkt *nctrl)\n{\n\tstruct octeon_soft_command *sc = NULL;\n\tu8 *data;\n\tu32 rdatasize;\n\tu32 uddsize = 0, datasize = 0;\n\n\tuddsize = (u32)(nctrl->ncmd.s.more * 8);\n\n\tdatasize = OCTNET_CMD_SIZE + uddsize;\n\trdatasize = 16;\n\n\tsc = (struct octeon_soft_command *)\n\t\tocteon_alloc_soft_command(oct, datasize, rdatasize, 0);\n\n\tif (!sc)\n\t\treturn NULL;\n\n\tdata = (u8 *)sc->virtdptr;\n\n\tmemcpy(data, &nctrl->ncmd, OCTNET_CMD_SIZE);\n\n\tocteon_swap_8B_data((u64 *)data, (OCTNET_CMD_SIZE >> 3));\n\n\tif (uddsize) {\n\t\t \n\t\tmemcpy(data + OCTNET_CMD_SIZE, nctrl->udd, uddsize);\n\t}\n\n\tsc->iq_no = (u32)nctrl->iq_no;\n\n\tocteon_prepare_soft_command(oct, sc, OPCODE_NIC, OPCODE_NIC_CMD,\n\t\t\t\t    0, 0, 0);\n\n\tinit_completion(&sc->complete);\n\tsc->sc_status = OCTEON_REQUEST_PENDING;\n\n\treturn sc;\n}\n\nint\noctnet_send_nic_ctrl_pkt(struct octeon_device *oct,\n\t\t\t struct octnic_ctrl_pkt *nctrl)\n{\n\tint retval;\n\tstruct octeon_soft_command *sc = NULL;\n\n\tspin_lock_bh(&oct->cmd_resp_wqlock);\n\t \n\tif ((oct->cmd_resp_state == OCT_DRV_OFFLINE) &&\n\t    (nctrl->ncmd.s.cmd != OCTNET_CMD_RX_CTL)) {\n\t\tspin_unlock_bh(&oct->cmd_resp_wqlock);\n\t\tdev_err(&oct->pci_dev->dev,\n\t\t\t\"%s cmd:%d not processed since driver offline\\n\",\n\t\t\t__func__, nctrl->ncmd.s.cmd);\n\t\treturn -1;\n\t}\n\n\tsc = octnic_alloc_ctrl_pkt_sc(oct, nctrl);\n\tif (!sc) {\n\t\tdev_err(&oct->pci_dev->dev, \"%s soft command alloc failed\\n\",\n\t\t\t__func__);\n\t\tspin_unlock_bh(&oct->cmd_resp_wqlock);\n\t\treturn -1;\n\t}\n\n\tretval = octeon_send_soft_command(oct, sc);\n\tif (retval == IQ_SEND_FAILED) {\n\t\tocteon_free_soft_command(oct, sc);\n\t\tdev_err(&oct->pci_dev->dev, \"%s pf_num:%d soft command:%d send failed status: %x\\n\",\n\t\t\t__func__, oct->pf_num, nctrl->ncmd.s.cmd, retval);\n\t\tspin_unlock_bh(&oct->cmd_resp_wqlock);\n\t\treturn -1;\n\t}\n\n\tspin_unlock_bh(&oct->cmd_resp_wqlock);\n\n\tif (nctrl->ncmd.s.cmdgroup == 0) {\n\t\tswitch (nctrl->ncmd.s.cmd) {\n\t\t\t \n\t\tcase OCTNET_CMD_CHANGE_DEVFLAGS:\n\t\tcase OCTNET_CMD_SET_MULTI_LIST:\n\t\tcase OCTNET_CMD_SET_UC_LIST:\n\t\t\tWRITE_ONCE(sc->caller_is_done, true);\n\t\t\treturn retval;\n\t\t}\n\t}\n\n\tretval = wait_for_sc_completion_timeout(oct, sc, 0);\n\tif (retval)\n\t\treturn (retval);\n\n\tnctrl->sc_status = sc->sc_status;\n\tretval = nctrl->sc_status;\n\tif (nctrl->cb_fn)\n\t\tnctrl->cb_fn(nctrl);\n\n\tWRITE_ONCE(sc->caller_is_done, true);\n\n\treturn retval;\n}\nEXPORT_SYMBOL_GPL(octnet_send_nic_ctrl_pkt);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}