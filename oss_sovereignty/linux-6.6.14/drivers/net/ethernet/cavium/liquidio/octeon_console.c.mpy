{
  "module_name": "octeon_console.c",
  "hash_id": "1b0afd0795a2e7ded6913bbf631567f37d4af91c5cb0315d092e2fa0c93b2c11",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/cavium/liquidio/octeon_console.c",
  "human_readable_source": " \n \n#include <linux/moduleparam.h>\n#include <linux/pci.h>\n#include <linux/netdevice.h>\n#include <linux/crc32.h>\n#include \"liquidio_common.h\"\n#include \"octeon_droq.h\"\n#include \"octeon_iq.h\"\n#include \"response_manager.h\"\n#include \"octeon_device.h\"\n#include \"liquidio_image.h\"\n#include \"octeon_mem_ops.h\"\n\nstatic void octeon_remote_lock(void);\nstatic void octeon_remote_unlock(void);\nstatic u64 cvmx_bootmem_phy_named_block_find(struct octeon_device *oct,\n\t\t\t\t\t     const char *name,\n\t\t\t\t\t     u32 flags);\nstatic int octeon_console_read(struct octeon_device *oct, u32 console_num,\n\t\t\t       char *buffer, u32 buf_size);\n\n#define BOOTLOADER_PCI_READ_BUFFER_DATA_ADDR    0x0006c008\n#define BOOTLOADER_PCI_READ_BUFFER_LEN_ADDR     0x0006c004\n#define BOOTLOADER_PCI_READ_BUFFER_OWNER_ADDR   0x0006c000\n#define BOOTLOADER_PCI_READ_DESC_ADDR           0x0006c100\n#define BOOTLOADER_PCI_WRITE_BUFFER_STR_LEN     248\n\n#define OCTEON_PCI_IO_BUF_OWNER_OCTEON    0x00000001\n#define OCTEON_PCI_IO_BUF_OWNER_HOST      0x00000002\n\n \n#define CVMX_BOOTMEM_NUM_NAMED_BLOCKS 64\n\n \n#define CVMX_BOOTMEM_ALIGNMENT_SIZE     (16ull)\n\n \n#define CVMX_BOOTMEM_DESC_MAJ_VER   3\n \n#define CVMX_BOOTMEM_DESC_MIN_VER   0\n\n \n#define OCTEON_PCI_CONSOLE_MAJOR_VERSION    1\n#define OCTEON_PCI_CONSOLE_MINOR_VERSION    0\n#define OCTEON_PCI_CONSOLE_BLOCK_NAME   \"__pci_console\"\n#define OCTEON_CONSOLE_POLL_INTERVAL_MS  100     \n\n \nstruct cvmx_bootmem_desc {\n\t \n\tu32 lock;\n\n\t \n\tu32 flags;\n\n\tu64 head_addr;\n\n\t \n\tu32 major_version;\n\n\t \n\tu32 minor_version;\n\n\tu64 app_data_addr;\n\tu64 app_data_size;\n\n\t \n\tu32 nb_num_blocks;\n\n\t \n\tu32 named_block_name_len;\n\n\t \n\tu64 named_block_array_addr;\n};\n\n \nstruct octeon_pci_console {\n\tu64 input_base_addr;\n\tu32 input_read_index;\n\tu32 input_write_index;\n\tu64 output_base_addr;\n\tu32 output_read_index;\n\tu32 output_write_index;\n\tu32 lock;\n\tu32 buf_size;\n};\n\n \nstruct octeon_pci_console_desc {\n\tu32 major_version;\n\tu32 minor_version;\n\tu32 lock;\n\tu32 flags;\n\tu32 num_consoles;\n\tu32 pad;\n\t \n\t \n\tu64 console_addr_array[];\n\t \n};\n\n \nstatic inline u64 __cvmx_bootmem_desc_get(struct octeon_device *oct,\n\t\t\t\t\t  u64 base,\n\t\t\t\t\t  u32 offset,\n\t\t\t\t\t  u32 size)\n{\n\tbase = (1ull << 63) | (base + offset);\n\tswitch (size) {\n\tcase 4:\n\t\treturn octeon_read_device_mem32(oct, base);\n\tcase 8:\n\t\treturn octeon_read_device_mem64(oct, base);\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\n \nstatic void CVMX_BOOTMEM_NAMED_GET_NAME(struct octeon_device *oct,\n\t\t\t\t\tu64 addr,\n\t\t\t\t\tchar *str,\n\t\t\t\t\tu32 len)\n{\n\taddr += offsetof(struct cvmx_bootmem_named_block_desc, name);\n\tocteon_pci_read_core_mem(oct, addr, (u8 *)str, len);\n\tstr[len] = 0;\n}\n\n \n\n \nstatic int __cvmx_bootmem_check_version(struct octeon_device *oct,\n\t\t\t\t\tu32 exact_match)\n{\n\tu32 major_version;\n\tu32 minor_version;\n\n\tif (!oct->bootmem_desc_addr)\n\t\toct->bootmem_desc_addr =\n\t\t\tocteon_read_device_mem64(oct,\n\t\t\t\t\t\t BOOTLOADER_PCI_READ_DESC_ADDR);\n\tmajor_version = (u32)__cvmx_bootmem_desc_get(\n\t\t\toct, oct->bootmem_desc_addr,\n\t\t\toffsetof(struct cvmx_bootmem_desc, major_version),\n\t\t\tsizeof_field(struct cvmx_bootmem_desc, major_version));\n\tminor_version = (u32)__cvmx_bootmem_desc_get(\n\t\t\toct, oct->bootmem_desc_addr,\n\t\t\toffsetof(struct cvmx_bootmem_desc, minor_version),\n\t\t\tsizeof_field(struct cvmx_bootmem_desc, minor_version));\n\n\tdev_dbg(&oct->pci_dev->dev, \"%s: major_version=%d\\n\", __func__,\n\t\tmajor_version);\n\tif ((major_version > 3) ||\n\t    (exact_match && major_version != exact_match)) {\n\t\tdev_err(&oct->pci_dev->dev, \"bootmem ver mismatch %d.%d addr:0x%llx\\n\",\n\t\t\tmajor_version, minor_version,\n\t\t\t(long long)oct->bootmem_desc_addr);\n\t\treturn -1;\n\t} else {\n\t\treturn 0;\n\t}\n}\n\nstatic const struct cvmx_bootmem_named_block_desc\n*__cvmx_bootmem_find_named_block_flags(struct octeon_device *oct,\n\t\t\t\t\tconst char *name, u32 flags)\n{\n\tstruct cvmx_bootmem_named_block_desc *desc =\n\t\t&oct->bootmem_named_block_desc;\n\tu64 named_addr = cvmx_bootmem_phy_named_block_find(oct, name, flags);\n\n\tif (named_addr) {\n\t\tdesc->base_addr = __cvmx_bootmem_desc_get(\n\t\t\t\toct, named_addr,\n\t\t\t\toffsetof(struct cvmx_bootmem_named_block_desc,\n\t\t\t\t\t base_addr),\n\t\t\t\tsizeof_field(\n\t\t\t\t\tstruct cvmx_bootmem_named_block_desc,\n\t\t\t\t\tbase_addr));\n\t\tdesc->size = __cvmx_bootmem_desc_get(oct, named_addr,\n\t\t\t\toffsetof(struct cvmx_bootmem_named_block_desc,\n\t\t\t\t\t size),\n\t\t\t\tsizeof_field(\n\t\t\t\t\tstruct cvmx_bootmem_named_block_desc,\n\t\t\t\t\tsize));\n\n\t\tstrscpy(desc->name, name, sizeof(desc->name));\n\t\treturn &oct->bootmem_named_block_desc;\n\t} else {\n\t\treturn NULL;\n\t}\n}\n\nstatic u64 cvmx_bootmem_phy_named_block_find(struct octeon_device *oct,\n\t\t\t\t\t     const char *name,\n\t\t\t\t\t     u32 flags)\n{\n\tu64 result = 0;\n\n\tif (!__cvmx_bootmem_check_version(oct, 3)) {\n\t\tu32 i;\n\n\t\tu64 named_block_array_addr = __cvmx_bootmem_desc_get(\n\t\t\t\t\toct, oct->bootmem_desc_addr,\n\t\t\t\t\toffsetof(struct cvmx_bootmem_desc,\n\t\t\t\t\t\t named_block_array_addr),\n\t\t\t\t\tsizeof_field(struct cvmx_bootmem_desc,\n\t\t\t\t\t\t     named_block_array_addr));\n\t\tu32 num_blocks = (u32)__cvmx_bootmem_desc_get(\n\t\t\t\t\toct, oct->bootmem_desc_addr,\n\t\t\t\t\toffsetof(struct cvmx_bootmem_desc,\n\t\t\t\t\t\t nb_num_blocks),\n\t\t\t\t\tsizeof_field(struct cvmx_bootmem_desc,\n\t\t\t\t\t\t     nb_num_blocks));\n\n\t\tu32 name_length = (u32)__cvmx_bootmem_desc_get(\n\t\t\t\t\toct, oct->bootmem_desc_addr,\n\t\t\t\t\toffsetof(struct cvmx_bootmem_desc,\n\t\t\t\t\t\t named_block_name_len),\n\t\t\t\t\tsizeof_field(struct cvmx_bootmem_desc,\n\t\t\t\t\t\t     named_block_name_len));\n\n\t\tu64 named_addr = named_block_array_addr;\n\n\t\tfor (i = 0; i < num_blocks; i++) {\n\t\t\tu64 named_size = __cvmx_bootmem_desc_get(\n\t\t\t\t\toct, named_addr,\n\t\t\t\t\t offsetof(\n\t\t\t\t\tstruct cvmx_bootmem_named_block_desc,\n\t\t\t\t\tsize),\n\t\t\t\t\t sizeof_field(\n\t\t\t\t\tstruct cvmx_bootmem_named_block_desc,\n\t\t\t\t\tsize));\n\n\t\t\tif (name && named_size) {\n\t\t\t\tchar *name_tmp =\n\t\t\t\t\tkmalloc(name_length + 1, GFP_KERNEL);\n\t\t\t\tif (!name_tmp)\n\t\t\t\t\tbreak;\n\n\t\t\t\tCVMX_BOOTMEM_NAMED_GET_NAME(oct, named_addr,\n\t\t\t\t\t\t\t    name_tmp,\n\t\t\t\t\t\t\t    name_length);\n\t\t\t\tif (!strncmp(name, name_tmp, name_length)) {\n\t\t\t\t\tresult = named_addr;\n\t\t\t\t\tkfree(name_tmp);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tkfree(name_tmp);\n\t\t\t} else if (!name && !named_size) {\n\t\t\t\tresult = named_addr;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tnamed_addr +=\n\t\t\t\tsizeof(struct cvmx_bootmem_named_block_desc);\n\t\t}\n\t}\n\treturn result;\n}\n\n \nstatic int octeon_named_block_find(struct octeon_device *oct, const char *name,\n\t\t\t\t   u64 *base_addr, u64 *size)\n{\n\tconst struct cvmx_bootmem_named_block_desc *named_block;\n\n\tocteon_remote_lock();\n\tnamed_block = __cvmx_bootmem_find_named_block_flags(oct, name, 0);\n\tocteon_remote_unlock();\n\tif (named_block) {\n\t\t*base_addr = named_block->base_addr;\n\t\t*size = named_block->size;\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nstatic void octeon_remote_lock(void)\n{\n\t \n}\n\nstatic void octeon_remote_unlock(void)\n{\n\t \n}\n\nint octeon_console_send_cmd(struct octeon_device *oct, char *cmd_str,\n\t\t\t    u32 wait_hundredths)\n{\n\tu32 len = (u32)strlen(cmd_str);\n\n\tdev_dbg(&oct->pci_dev->dev, \"sending \\\"%s\\\" to bootloader\\n\", cmd_str);\n\n\tif (len > BOOTLOADER_PCI_WRITE_BUFFER_STR_LEN - 1) {\n\t\tdev_err(&oct->pci_dev->dev, \"Command string too long, max length is: %d\\n\",\n\t\t\tBOOTLOADER_PCI_WRITE_BUFFER_STR_LEN - 1);\n\t\treturn -1;\n\t}\n\n\tif (octeon_wait_for_bootloader(oct, wait_hundredths) != 0) {\n\t\tdev_err(&oct->pci_dev->dev, \"Bootloader not ready for command.\\n\");\n\t\treturn -1;\n\t}\n\n\t \n\tocteon_remote_lock();\n\tocteon_pci_write_core_mem(oct, BOOTLOADER_PCI_READ_BUFFER_DATA_ADDR,\n\t\t\t\t  (u8 *)cmd_str, len);\n\tocteon_write_device_mem32(oct, BOOTLOADER_PCI_READ_BUFFER_LEN_ADDR,\n\t\t\t\t  len);\n\tocteon_write_device_mem32(oct, BOOTLOADER_PCI_READ_BUFFER_OWNER_ADDR,\n\t\t\t\t  OCTEON_PCI_IO_BUF_OWNER_OCTEON);\n\n\t \n\tif (octeon_wait_for_bootloader(oct, 200) != 0) {\n\t\tocteon_remote_unlock();\n\t\tdev_err(&oct->pci_dev->dev, \"Bootloader did not accept command.\\n\");\n\t\treturn -1;\n\t}\n\tocteon_remote_unlock();\n\treturn 0;\n}\n\nint octeon_wait_for_bootloader(struct octeon_device *oct,\n\t\t\t       u32 wait_time_hundredths)\n{\n\tdev_dbg(&oct->pci_dev->dev, \"waiting %d0 ms for bootloader\\n\",\n\t\twait_time_hundredths);\n\n\tif (octeon_mem_access_ok(oct))\n\t\treturn -1;\n\n\twhile (wait_time_hundredths > 0 &&\n\t       octeon_read_device_mem32(oct,\n\t\t\t\t\tBOOTLOADER_PCI_READ_BUFFER_OWNER_ADDR)\n\t       != OCTEON_PCI_IO_BUF_OWNER_HOST) {\n\t\tif (--wait_time_hundredths <= 0)\n\t\t\treturn -1;\n\t\tschedule_timeout_uninterruptible(HZ / 100);\n\t}\n\treturn 0;\n}\n\nstatic void octeon_console_handle_result(struct octeon_device *oct,\n\t\t\t\t\t size_t console_num)\n{\n\tstruct octeon_console *console;\n\n\tconsole = &oct->console[console_num];\n\n\tconsole->waiting = 0;\n}\n\nstatic char console_buffer[OCTEON_CONSOLE_MAX_READ_BYTES];\n\nstatic void output_console_line(struct octeon_device *oct,\n\t\t\t\tstruct octeon_console *console,\n\t\t\t\tsize_t console_num,\n\t\t\t\tchar *console_buffer,\n\t\t\t\ts32 bytes_read)\n{\n\tchar *line;\n\ts32 i;\n\tsize_t len;\n\n\tline = console_buffer;\n\tfor (i = 0; i < bytes_read; i++) {\n\t\t \n\t\tif (console_buffer[i] == '\\n') {\n\t\t\tconsole_buffer[i] = '\\0';\n\t\t\t \n\t\t\tif (console->leftover[0] &&\n\t\t\t    (line != console->leftover)) {\n\t\t\t\tif (console->print)\n\t\t\t\t\t(*console->print)(oct, (u32)console_num,\n\t\t\t\t\t\t\t  console->leftover,\n\t\t\t\t\t\t\t  line);\n\t\t\t\tconsole->leftover[0] = '\\0';\n\t\t\t} else {\n\t\t\t\tif (console->print)\n\t\t\t\t\t(*console->print)(oct, (u32)console_num,\n\t\t\t\t\t\t\t  line, NULL);\n\t\t\t}\n\t\t\tline = &console_buffer[i + 1];\n\t\t}\n\t}\n\n\t \n\tif (line != &console_buffer[bytes_read]) {\n\t\tconsole_buffer[bytes_read] = '\\0';\n\t\tlen = strlen(console->leftover);\n\t\tstrscpy(&console->leftover[len], line,\n\t\t\tsizeof(console->leftover) - len + 1);\n\t}\n}\n\nstatic void check_console(struct work_struct *work)\n{\n\ts32 bytes_read, tries, total_read;\n\tsize_t len;\n\tstruct octeon_console *console;\n\tstruct cavium_wk *wk = (struct cavium_wk *)work;\n\tstruct octeon_device *oct = (struct octeon_device *)wk->ctxptr;\n\tu32 console_num = (u32)wk->ctxul;\n\tu32 delay;\n\n\tconsole = &oct->console[console_num];\n\ttries = 0;\n\ttotal_read = 0;\n\n\tdo {\n\t\t \n\t\tbytes_read =\n\t\t\tocteon_console_read(oct, console_num, console_buffer,\n\t\t\t\t\t    sizeof(console_buffer) - 1);\n\t\tif (bytes_read > 0) {\n\t\t\ttotal_read += bytes_read;\n\t\t\tif (console->waiting)\n\t\t\t\tocteon_console_handle_result(oct, console_num);\n\t\t\tif (console->print) {\n\t\t\t\toutput_console_line(oct, console, console_num,\n\t\t\t\t\t\t    console_buffer, bytes_read);\n\t\t\t}\n\t\t} else if (bytes_read < 0) {\n\t\t\tdev_err(&oct->pci_dev->dev, \"Error reading console %u, ret=%d\\n\",\n\t\t\t\tconsole_num, bytes_read);\n\t\t}\n\n\t\ttries++;\n\t} while ((bytes_read > 0) && (tries < 16));\n\n\t \n\tif (console->print && (total_read == 0) &&\n\t    (console->leftover[0])) {\n\t\t \n\t\tlen = strlen(console->leftover);\n\t\tconsole->leftover[len] = '\\n';\n\t\toutput_console_line(oct, console, console_num,\n\t\t\t\t    console->leftover, (s32)(len + 1));\n\t\tconsole->leftover[0] = '\\0';\n\t}\n\n\tdelay = OCTEON_CONSOLE_POLL_INTERVAL_MS;\n\n\tschedule_delayed_work(&wk->work, msecs_to_jiffies(delay));\n}\n\nint octeon_init_consoles(struct octeon_device *oct)\n{\n\tint ret = 0;\n\tu64 addr, size;\n\n\tret = octeon_mem_access_ok(oct);\n\tif (ret) {\n\t\tdev_err(&oct->pci_dev->dev, \"Memory access not okay'\\n\");\n\t\treturn ret;\n\t}\n\n\tret = octeon_named_block_find(oct, OCTEON_PCI_CONSOLE_BLOCK_NAME, &addr,\n\t\t\t\t      &size);\n\tif (ret) {\n\t\tdev_err(&oct->pci_dev->dev, \"Could not find console '%s'\\n\",\n\t\t\tOCTEON_PCI_CONSOLE_BLOCK_NAME);\n\t\treturn ret;\n\t}\n\n\t \n\toct->console_nb_info.bar1_index = BAR1_INDEX_STATIC_MAP;\n\toct->fn_list.bar1_idx_setup(oct, addr, oct->console_nb_info.bar1_index,\n\t\t\t\t    true);\n\toct->console_nb_info.dram_region_base = addr\n\t\t& ~(OCTEON_BAR1_ENTRY_SIZE - 1ULL);\n\n\t \n\toct->num_consoles = octeon_read_device_mem32(oct,\n\t\taddr + offsetof(struct octeon_pci_console_desc,\n\t\t\tnum_consoles));\n\toct->console_desc_addr = addr;\n\n\tdev_dbg(&oct->pci_dev->dev, \"Initialized consoles. %d available\\n\",\n\t\toct->num_consoles);\n\n\treturn ret;\n}\n\nstatic void octeon_get_uboot_version(struct octeon_device *oct)\n{\n\ts32 bytes_read, tries, total_read;\n\tstruct octeon_console *console;\n\tu32 console_num = 0;\n\tchar *uboot_ver;\n\tchar *buf;\n\tchar *p;\n\n#define OCTEON_UBOOT_VER_BUF_SIZE 512\n\tbuf = kmalloc(OCTEON_UBOOT_VER_BUF_SIZE, GFP_KERNEL);\n\tif (!buf)\n\t\treturn;\n\n\tif (octeon_console_send_cmd(oct, \"setenv stdout pci\\n\", 50)) {\n\t\tkfree(buf);\n\t\treturn;\n\t}\n\n\tif (octeon_console_send_cmd(oct, \"version\\n\", 1)) {\n\t\tkfree(buf);\n\t\treturn;\n\t}\n\n\tconsole = &oct->console[console_num];\n\ttries = 0;\n\ttotal_read = 0;\n\n\tdo {\n\t\t \n\t\tbytes_read =\n\t\t\tocteon_console_read(oct,\n\t\t\t\t\t    console_num, buf + total_read,\n\t\t\t\t\t    OCTEON_UBOOT_VER_BUF_SIZE - 1 -\n\t\t\t\t\t    total_read);\n\t\tif (bytes_read > 0) {\n\t\t\tbuf[bytes_read] = '\\0';\n\n\t\t\ttotal_read += bytes_read;\n\t\t\tif (console->waiting)\n\t\t\t\tocteon_console_handle_result(oct, console_num);\n\t\t} else if (bytes_read < 0) {\n\t\t\tdev_err(&oct->pci_dev->dev, \"Error reading console %u, ret=%d\\n\",\n\t\t\t\tconsole_num, bytes_read);\n\t\t}\n\n\t\ttries++;\n\t} while ((bytes_read > 0) && (tries < 16));\n\n\t \n\tif ((total_read == 0) && (console->leftover[0])) {\n\t\tdev_dbg(&oct->pci_dev->dev, \"%u: %s\\n\",\n\t\t\tconsole_num, console->leftover);\n\t\tconsole->leftover[0] = '\\0';\n\t}\n\n\tbuf[OCTEON_UBOOT_VER_BUF_SIZE - 1] = '\\0';\n\n\tuboot_ver = strstr(buf, \"U-Boot\");\n\tif (uboot_ver) {\n\t\tp = strstr(uboot_ver, \"mips\");\n\t\tif (p) {\n\t\t\tp--;\n\t\t\t*p = '\\0';\n\t\t\tdev_info(&oct->pci_dev->dev, \"%s\\n\", uboot_ver);\n\t\t}\n\t}\n\n\tkfree(buf);\n\tocteon_console_send_cmd(oct, \"setenv stdout serial\\n\", 50);\n}\n\nint octeon_add_console(struct octeon_device *oct, u32 console_num,\n\t\t       char *dbg_enb)\n{\n\tint ret = 0;\n\tu32 delay;\n\tu64 coreaddr;\n\tstruct delayed_work *work;\n\tstruct octeon_console *console;\n\n\tif (console_num >= oct->num_consoles) {\n\t\tdev_err(&oct->pci_dev->dev,\n\t\t\t\"trying to read from console number %d when only 0 to %d exist\\n\",\n\t\t\tconsole_num, oct->num_consoles);\n\t} else {\n\t\tconsole = &oct->console[console_num];\n\n\t\tconsole->waiting = 0;\n\n\t\tcoreaddr = oct->console_desc_addr + console_num * 8 +\n\t\t\toffsetof(struct octeon_pci_console_desc,\n\t\t\t\t console_addr_array);\n\t\tconsole->addr = octeon_read_device_mem64(oct, coreaddr);\n\t\tcoreaddr = console->addr + offsetof(struct octeon_pci_console,\n\t\t\t\t\t\t    buf_size);\n\t\tconsole->buffer_size = octeon_read_device_mem32(oct, coreaddr);\n\t\tcoreaddr = console->addr + offsetof(struct octeon_pci_console,\n\t\t\t\t\t\t    input_base_addr);\n\t\tconsole->input_base_addr =\n\t\t\tocteon_read_device_mem64(oct, coreaddr);\n\t\tcoreaddr = console->addr + offsetof(struct octeon_pci_console,\n\t\t\t\t\t\t    output_base_addr);\n\t\tconsole->output_base_addr =\n\t\t\tocteon_read_device_mem64(oct, coreaddr);\n\t\tconsole->leftover[0] = '\\0';\n\n\t\twork = &oct->console_poll_work[console_num].work;\n\n\t\tocteon_get_uboot_version(oct);\n\n\t\tINIT_DELAYED_WORK(work, check_console);\n\t\toct->console_poll_work[console_num].ctxptr = (void *)oct;\n\t\toct->console_poll_work[console_num].ctxul = console_num;\n\t\tdelay = OCTEON_CONSOLE_POLL_INTERVAL_MS;\n\t\tschedule_delayed_work(work, msecs_to_jiffies(delay));\n\n\t\t \n\t\tif (dbg_enb && !dbg_enb[0])\n\t\t\tdbg_enb = \"setenv pci_console_active 1\";\n\t\tif (dbg_enb)\n\t\t\tret = octeon_console_send_cmd(oct, dbg_enb, 2000);\n\n\t\tconsole->active = 1;\n\t}\n\n\treturn ret;\n}\n\n \nvoid octeon_remove_consoles(struct octeon_device *oct)\n{\n\tu32 i;\n\tstruct octeon_console *console;\n\n\tfor (i = 0; i < oct->num_consoles; i++) {\n\t\tconsole = &oct->console[i];\n\n\t\tif (!console->active)\n\t\t\tcontinue;\n\n\t\tcancel_delayed_work_sync(&oct->console_poll_work[i].\n\t\t\t\t\t\twork);\n\t\tconsole->addr = 0;\n\t\tconsole->buffer_size = 0;\n\t\tconsole->input_base_addr = 0;\n\t\tconsole->output_base_addr = 0;\n\t}\n\n\toct->num_consoles = 0;\n}\n\nstatic inline int octeon_console_free_bytes(u32 buffer_size,\n\t\t\t\t\t    u32 wr_idx,\n\t\t\t\t\t    u32 rd_idx)\n{\n\tif (rd_idx >= buffer_size || wr_idx >= buffer_size)\n\t\treturn -1;\n\n\treturn ((buffer_size - 1) - (wr_idx - rd_idx)) % buffer_size;\n}\n\nstatic inline int octeon_console_avail_bytes(u32 buffer_size,\n\t\t\t\t\t     u32 wr_idx,\n\t\t\t\t\t     u32 rd_idx)\n{\n\tif (rd_idx >= buffer_size || wr_idx >= buffer_size)\n\t\treturn -1;\n\n\treturn buffer_size - 1 -\n\t       octeon_console_free_bytes(buffer_size, wr_idx, rd_idx);\n}\n\nstatic int octeon_console_read(struct octeon_device *oct, u32 console_num,\n\t\t\t       char *buffer, u32 buf_size)\n{\n\tint bytes_to_read;\n\tu32 rd_idx, wr_idx;\n\tstruct octeon_console *console;\n\n\tif (console_num >= oct->num_consoles) {\n\t\tdev_err(&oct->pci_dev->dev, \"Attempted to read from disabled console %d\\n\",\n\t\t\tconsole_num);\n\t\treturn 0;\n\t}\n\n\tconsole = &oct->console[console_num];\n\n\t \n\trd_idx = octeon_read_device_mem32(oct, console->addr +\n\t\toffsetof(struct octeon_pci_console, output_read_index));\n\twr_idx = octeon_read_device_mem32(oct, console->addr +\n\t\toffsetof(struct octeon_pci_console, output_write_index));\n\n\tbytes_to_read = octeon_console_avail_bytes(console->buffer_size,\n\t\t\t\t\t\t   wr_idx, rd_idx);\n\tif (bytes_to_read <= 0)\n\t\treturn bytes_to_read;\n\n\tbytes_to_read = min_t(s32, bytes_to_read, buf_size);\n\n\t \n\tif (rd_idx + bytes_to_read >= console->buffer_size)\n\t\tbytes_to_read = console->buffer_size - rd_idx;\n\n\tocteon_pci_read_core_mem(oct, console->output_base_addr + rd_idx,\n\t\t\t\t (u8 *)buffer, bytes_to_read);\n\tocteon_write_device_mem32(oct, console->addr +\n\t\t\t\t  offsetof(struct octeon_pci_console,\n\t\t\t\t\t   output_read_index),\n\t\t\t\t  (rd_idx + bytes_to_read) %\n\t\t\t\t  console->buffer_size);\n\n\treturn bytes_to_read;\n}\n\n#define FBUF_SIZE\t(4 * 1024 * 1024)\n#define MAX_BOOTTIME_SIZE    80\n\nint octeon_download_firmware(struct octeon_device *oct, const u8 *data,\n\t\t\t     size_t size)\n{\n\tstruct octeon_firmware_file_header *h;\n\tchar boottime[MAX_BOOTTIME_SIZE];\n\tstruct timespec64 ts;\n\tu32 crc32_result;\n\tu64 load_addr;\n\tu32 image_len;\n\tint ret = 0;\n\tu32 i, rem;\n\n\tif (size < sizeof(struct octeon_firmware_file_header)) {\n\t\tdev_err(&oct->pci_dev->dev, \"Firmware file too small (%d < %d).\\n\",\n\t\t\t(u32)size,\n\t\t\t(u32)sizeof(struct octeon_firmware_file_header));\n\t\treturn -EINVAL;\n\t}\n\n\th = (struct octeon_firmware_file_header *)data;\n\n\tif (be32_to_cpu(h->magic) != LIO_NIC_MAGIC) {\n\t\tdev_err(&oct->pci_dev->dev, \"Unrecognized firmware file.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tcrc32_result = crc32((unsigned int)~0, data,\n\t\t\t     sizeof(struct octeon_firmware_file_header) -\n\t\t\t     sizeof(u32)) ^ ~0U;\n\tif (crc32_result != be32_to_cpu(h->crc32)) {\n\t\tdev_err(&oct->pci_dev->dev, \"Firmware CRC mismatch (0x%08x != 0x%08x).\\n\",\n\t\t\tcrc32_result, be32_to_cpu(h->crc32));\n\t\treturn -EINVAL;\n\t}\n\n\tif (memcmp(LIQUIDIO_BASE_VERSION, h->version,\n\t\t   strlen(LIQUIDIO_BASE_VERSION))) {\n\t\tdev_err(&oct->pci_dev->dev, \"Unmatched firmware version. Expected %s.x, got %s.\\n\",\n\t\t\tLIQUIDIO_BASE_VERSION,\n\t\t\th->version);\n\t\treturn -EINVAL;\n\t}\n\n\tif (be32_to_cpu(h->num_images) > LIO_MAX_IMAGES) {\n\t\tdev_err(&oct->pci_dev->dev, \"Too many images in firmware file (%d).\\n\",\n\t\t\tbe32_to_cpu(h->num_images));\n\t\treturn -EINVAL;\n\t}\n\n\tdev_info(&oct->pci_dev->dev, \"Firmware version: %s\\n\", h->version);\n\tsnprintf(oct->fw_info.liquidio_firmware_version, 32, \"LIQUIDIO: %s\",\n\t\t h->version);\n\n\tdata += sizeof(struct octeon_firmware_file_header);\n\n\tdev_info(&oct->pci_dev->dev, \"%s: Loading %d images\\n\", __func__,\n\t\t be32_to_cpu(h->num_images));\n\t \n\tfor (i = 0; i < be32_to_cpu(h->num_images); i++) {\n\t\tload_addr = be64_to_cpu(h->desc[i].addr);\n\t\timage_len = be32_to_cpu(h->desc[i].len);\n\n\t\tdev_info(&oct->pci_dev->dev, \"Loading firmware %d at %llx\\n\",\n\t\t\t image_len, load_addr);\n\n\t\t \n\t\trem = image_len;\n\n\t\twhile (rem) {\n\t\t\tif (rem < FBUF_SIZE)\n\t\t\t\tsize = rem;\n\t\t\telse\n\t\t\t\tsize = FBUF_SIZE;\n\n\t\t\t \n\t\t\tocteon_pci_write_core_mem(oct, load_addr, data, (u32)size);\n\n\t\t\tdata += size;\n\t\t\trem -= (u32)size;\n\t\t\tload_addr += size;\n\t\t}\n\t}\n\n\t \n\tktime_get_real_ts64(&ts);\n\tret = snprintf(boottime, MAX_BOOTTIME_SIZE,\n\t\t       \" time_sec=%lld time_nsec=%ld\",\n\t\t       (s64)ts.tv_sec, ts.tv_nsec);\n\tif ((sizeof(h->bootcmd) - strnlen(h->bootcmd, sizeof(h->bootcmd))) <\n\t\tret) {\n\t\tdev_err(&oct->pci_dev->dev, \"Boot command buffer too small\\n\");\n\t\treturn -EINVAL;\n\t}\n\tstrncat(h->bootcmd, boottime,\n\t\tsizeof(h->bootcmd) - strnlen(h->bootcmd, sizeof(h->bootcmd)));\n\n\tdev_info(&oct->pci_dev->dev, \"Writing boot command: %s\\n\",\n\t\t h->bootcmd);\n\n\t \n\tret = octeon_console_send_cmd(oct, h->bootcmd, 50);\n\tif (ret)\n\t\tdev_info(&oct->pci_dev->dev, \"Boot command send failed\\n\");\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}