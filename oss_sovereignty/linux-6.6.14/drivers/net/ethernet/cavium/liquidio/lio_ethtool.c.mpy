{
  "module_name": "lio_ethtool.c",
  "hash_id": "3af84ceaaf95c06d4bcb392f6e8da606d229d5dc5f740016bf188036bafc1c39",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/cavium/liquidio/lio_ethtool.c",
  "human_readable_source": " \n#include <linux/ethtool.h>\n#include <linux/netdevice.h>\n#include <linux/net_tstamp.h>\n#include <linux/pci.h>\n#include \"liquidio_common.h\"\n#include \"octeon_droq.h\"\n#include \"octeon_iq.h\"\n#include \"response_manager.h\"\n#include \"octeon_device.h\"\n#include \"octeon_nic.h\"\n#include \"octeon_main.h\"\n#include \"octeon_network.h\"\n#include \"cn66xx_regs.h\"\n#include \"cn66xx_device.h\"\n#include \"cn23xx_pf_device.h\"\n#include \"cn23xx_vf_device.h\"\n\nstatic int lio_reset_queues(struct net_device *netdev, uint32_t num_qs);\n\nstruct oct_intrmod_resp {\n\tu64     rh;\n\tstruct oct_intrmod_cfg intrmod;\n\tu64     status;\n};\n\nstruct oct_mdio_cmd_resp {\n\tu64 rh;\n\tstruct oct_mdio_cmd resp;\n\tu64 status;\n};\n\n#define OCT_MDIO45_RESP_SIZE   (sizeof(struct oct_mdio_cmd_resp))\n\n \nenum {\n\tINTERFACE_MODE_DISABLED,\n\tINTERFACE_MODE_RGMII,\n\tINTERFACE_MODE_GMII,\n\tINTERFACE_MODE_SPI,\n\tINTERFACE_MODE_PCIE,\n\tINTERFACE_MODE_XAUI,\n\tINTERFACE_MODE_SGMII,\n\tINTERFACE_MODE_PICMG,\n\tINTERFACE_MODE_NPI,\n\tINTERFACE_MODE_LOOP,\n\tINTERFACE_MODE_SRIO,\n\tINTERFACE_MODE_ILK,\n\tINTERFACE_MODE_RXAUI,\n\tINTERFACE_MODE_QSGMII,\n\tINTERFACE_MODE_AGL,\n\tINTERFACE_MODE_XLAUI,\n\tINTERFACE_MODE_XFI,\n\tINTERFACE_MODE_10G_KR,\n\tINTERFACE_MODE_40G_KR4,\n\tINTERFACE_MODE_MIXED,\n};\n\n#define OCT_ETHTOOL_REGDUMP_LEN  4096\n#define OCT_ETHTOOL_REGDUMP_LEN_23XX  (4096 * 11)\n#define OCT_ETHTOOL_REGDUMP_LEN_23XX_VF  (4096 * 2)\n#define OCT_ETHTOOL_REGSVER  1\n\n \nstatic const char oct_stats_strings[][ETH_GSTRING_LEN] = {\n\t\"rx_packets\",\n\t\"tx_packets\",\n\t\"rx_bytes\",\n\t\"tx_bytes\",\n\t\"rx_errors\",\n\t\"tx_errors\",\n\t\"rx_dropped\",\n\t\"tx_dropped\",\n\n\t\"tx_total_sent\",\n\t\"tx_total_fwd\",\n\t\"tx_err_pko\",\n\t\"tx_err_pki\",\n\t\"tx_err_link\",\n\t\"tx_err_drop\",\n\n\t\"tx_tso\",\n\t\"tx_tso_packets\",\n\t\"tx_tso_err\",\n\t\"tx_vxlan\",\n\n\t\"tx_mcast\",\n\t\"tx_bcast\",\n\n\t\"mac_tx_total_pkts\",\n\t\"mac_tx_total_bytes\",\n\t\"mac_tx_mcast_pkts\",\n\t\"mac_tx_bcast_pkts\",\n\t\"mac_tx_ctl_packets\",\n\t\"mac_tx_total_collisions\",\n\t\"mac_tx_one_collision\",\n\t\"mac_tx_multi_collision\",\n\t\"mac_tx_max_collision_fail\",\n\t\"mac_tx_max_deferral_fail\",\n\t\"mac_tx_fifo_err\",\n\t\"mac_tx_runts\",\n\n\t\"rx_total_rcvd\",\n\t\"rx_total_fwd\",\n\t\"rx_mcast\",\n\t\"rx_bcast\",\n\t\"rx_jabber_err\",\n\t\"rx_l2_err\",\n\t\"rx_frame_err\",\n\t\"rx_err_pko\",\n\t\"rx_err_link\",\n\t\"rx_err_drop\",\n\n\t\"rx_vxlan\",\n\t\"rx_vxlan_err\",\n\n\t\"rx_lro_pkts\",\n\t\"rx_lro_bytes\",\n\t\"rx_total_lro\",\n\n\t\"rx_lro_aborts\",\n\t\"rx_lro_aborts_port\",\n\t\"rx_lro_aborts_seq\",\n\t\"rx_lro_aborts_tsval\",\n\t\"rx_lro_aborts_timer\",\n\t\"rx_fwd_rate\",\n\n\t\"mac_rx_total_rcvd\",\n\t\"mac_rx_bytes\",\n\t\"mac_rx_total_bcst\",\n\t\"mac_rx_total_mcst\",\n\t\"mac_rx_runts\",\n\t\"mac_rx_ctl_packets\",\n\t\"mac_rx_fifo_err\",\n\t\"mac_rx_dma_drop\",\n\t\"mac_rx_fcs_err\",\n\n\t\"link_state_changes\",\n};\n\n \nstatic const char oct_vf_stats_strings[][ETH_GSTRING_LEN] = {\n\t\"rx_packets\",\n\t\"tx_packets\",\n\t\"rx_bytes\",\n\t\"tx_bytes\",\n\t\"rx_errors\",\n\t\"tx_errors\",\n\t\"rx_dropped\",\n\t\"tx_dropped\",\n\t\"rx_mcast\",\n\t\"tx_mcast\",\n\t\"rx_bcast\",\n\t\"tx_bcast\",\n\t\"link_state_changes\",\n};\n\n \nstatic const char oct_iq_stats_strings[][ETH_GSTRING_LEN] = {\n\t\"packets\",\n\t\"bytes\",\n\t\"dropped\",\n\t\"iq_busy\",\n\t\"sgentry_sent\",\n\n\t\"fw_instr_posted\",\n\t\"fw_instr_processed\",\n\t\"fw_instr_dropped\",\n\t\"fw_bytes_sent\",\n\n\t\"tso\",\n\t\"vxlan\",\n\t\"txq_restart\",\n};\n\n \nstatic const char oct_droq_stats_strings[][ETH_GSTRING_LEN] = {\n\t\"packets\",\n\t\"bytes\",\n\t\"dropped\",\n\t\"dropped_nomem\",\n\t\"dropped_toomany\",\n\t\"fw_dropped\",\n\t\"fw_pkts_received\",\n\t\"fw_bytes_received\",\n\t\"fw_dropped_nodispatch\",\n\n\t\"vxlan\",\n\t\"buffer_alloc_failure\",\n};\n\n \nstatic const char oct_priv_flags_strings[][ETH_GSTRING_LEN] = {\n};\n\n#define OCTNIC_NCMD_AUTONEG_ON  0x1\n#define OCTNIC_NCMD_PHY_ON      0x2\n\nstatic int lio_get_link_ksettings(struct net_device *netdev,\n\t\t\t\t  struct ethtool_link_ksettings *ecmd)\n{\n\tstruct lio *lio = GET_LIO(netdev);\n\tstruct octeon_device *oct = lio->oct_dev;\n\tstruct oct_link_info *linfo;\n\n\tlinfo = &lio->linfo;\n\n\tethtool_link_ksettings_zero_link_mode(ecmd, supported);\n\tethtool_link_ksettings_zero_link_mode(ecmd, advertising);\n\n\tswitch (linfo->link.s.phy_type) {\n\tcase LIO_PHY_PORT_TP:\n\t\tecmd->base.port = PORT_TP;\n\t\tecmd->base.autoneg = AUTONEG_DISABLE;\n\t\tethtool_link_ksettings_add_link_mode(ecmd, supported, TP);\n\t\tethtool_link_ksettings_add_link_mode(ecmd, supported, Pause);\n\t\tethtool_link_ksettings_add_link_mode(ecmd, supported,\n\t\t\t\t\t\t     10000baseT_Full);\n\n\t\tethtool_link_ksettings_add_link_mode(ecmd, advertising, Pause);\n\t\tethtool_link_ksettings_add_link_mode(ecmd, advertising,\n\t\t\t\t\t\t     10000baseT_Full);\n\n\t\tbreak;\n\n\tcase LIO_PHY_PORT_FIBRE:\n\t\tif (linfo->link.s.if_mode == INTERFACE_MODE_XAUI ||\n\t\t    linfo->link.s.if_mode == INTERFACE_MODE_RXAUI ||\n\t\t    linfo->link.s.if_mode == INTERFACE_MODE_XLAUI ||\n\t\t    linfo->link.s.if_mode == INTERFACE_MODE_XFI) {\n\t\t\tdev_dbg(&oct->pci_dev->dev, \"ecmd->base.transceiver is XCVR_EXTERNAL\\n\");\n\t\t\tecmd->base.transceiver = XCVR_EXTERNAL;\n\t\t} else {\n\t\t\tdev_err(&oct->pci_dev->dev, \"Unknown link interface mode: %d\\n\",\n\t\t\t\tlinfo->link.s.if_mode);\n\t\t}\n\n\t\tecmd->base.port = PORT_FIBRE;\n\t\tecmd->base.autoneg = AUTONEG_DISABLE;\n\t\tethtool_link_ksettings_add_link_mode(ecmd, supported, FIBRE);\n\n\t\tethtool_link_ksettings_add_link_mode(ecmd, supported, Pause);\n\t\tethtool_link_ksettings_add_link_mode(ecmd, advertising, Pause);\n\t\tif (oct->subsystem_id == OCTEON_CN2350_25GB_SUBSYS_ID ||\n\t\t    oct->subsystem_id == OCTEON_CN2360_25GB_SUBSYS_ID) {\n\t\t\tif (OCTEON_CN23XX_PF(oct)) {\n\t\t\t\tethtool_link_ksettings_add_link_mode\n\t\t\t\t\t(ecmd, supported, 25000baseSR_Full);\n\t\t\t\tethtool_link_ksettings_add_link_mode\n\t\t\t\t\t(ecmd, supported, 25000baseKR_Full);\n\t\t\t\tethtool_link_ksettings_add_link_mode\n\t\t\t\t\t(ecmd, supported, 25000baseCR_Full);\n\n\t\t\t\tif (oct->no_speed_setting == 0)  {\n\t\t\t\t\tethtool_link_ksettings_add_link_mode\n\t\t\t\t\t\t(ecmd, supported,\n\t\t\t\t\t\t 10000baseSR_Full);\n\t\t\t\t\tethtool_link_ksettings_add_link_mode\n\t\t\t\t\t\t(ecmd, supported,\n\t\t\t\t\t\t 10000baseKR_Full);\n\t\t\t\t\tethtool_link_ksettings_add_link_mode\n\t\t\t\t\t\t(ecmd, supported,\n\t\t\t\t\t\t 10000baseCR_Full);\n\t\t\t\t}\n\n\t\t\t\tif (oct->no_speed_setting == 0) {\n\t\t\t\t\tliquidio_get_speed(lio);\n\t\t\t\t\tliquidio_get_fec(lio);\n\t\t\t\t} else {\n\t\t\t\t\toct->speed_setting = 25;\n\t\t\t\t}\n\n\t\t\t\tif (oct->speed_setting == 10) {\n\t\t\t\t\tethtool_link_ksettings_add_link_mode\n\t\t\t\t\t\t(ecmd, advertising,\n\t\t\t\t\t\t 10000baseSR_Full);\n\t\t\t\t\tethtool_link_ksettings_add_link_mode\n\t\t\t\t\t\t(ecmd, advertising,\n\t\t\t\t\t\t 10000baseKR_Full);\n\t\t\t\t\tethtool_link_ksettings_add_link_mode\n\t\t\t\t\t\t(ecmd, advertising,\n\t\t\t\t\t\t 10000baseCR_Full);\n\t\t\t\t}\n\t\t\t\tif (oct->speed_setting == 25) {\n\t\t\t\t\tethtool_link_ksettings_add_link_mode\n\t\t\t\t\t\t(ecmd, advertising,\n\t\t\t\t\t\t 25000baseSR_Full);\n\t\t\t\t\tethtool_link_ksettings_add_link_mode\n\t\t\t\t\t\t(ecmd, advertising,\n\t\t\t\t\t\t 25000baseKR_Full);\n\t\t\t\t\tethtool_link_ksettings_add_link_mode\n\t\t\t\t\t\t(ecmd, advertising,\n\t\t\t\t\t\t 25000baseCR_Full);\n\t\t\t\t}\n\n\t\t\t\tif (oct->no_speed_setting)\n\t\t\t\t\tbreak;\n\n\t\t\t\tethtool_link_ksettings_add_link_mode\n\t\t\t\t\t(ecmd, supported, FEC_RS);\n\t\t\t\tethtool_link_ksettings_add_link_mode\n\t\t\t\t\t(ecmd, supported, FEC_NONE);\n\t\t\t\t\t \n\t\t\t\tif (oct->props[lio->ifidx].fec == 1) {\n\t\t\t\t\t \n\t\t\t\t\tethtool_link_ksettings_add_link_mode\n\t\t\t\t\t\t(ecmd, advertising, FEC_RS);\n\t\t\t\t} else {\n\t\t\t\t\t \n\t\t\t\t\tethtool_link_ksettings_add_link_mode\n\t\t\t\t\t\t(ecmd, advertising, FEC_NONE);\n\t\t\t\t}\n\t\t\t} else {  \n\t\t\t\tif (linfo->link.s.speed == 10000) {\n\t\t\t\t\tethtool_link_ksettings_add_link_mode\n\t\t\t\t\t\t(ecmd, supported,\n\t\t\t\t\t\t 10000baseSR_Full);\n\t\t\t\t\tethtool_link_ksettings_add_link_mode\n\t\t\t\t\t\t(ecmd, supported,\n\t\t\t\t\t\t 10000baseKR_Full);\n\t\t\t\t\tethtool_link_ksettings_add_link_mode\n\t\t\t\t\t\t(ecmd, supported,\n\t\t\t\t\t\t 10000baseCR_Full);\n\n\t\t\t\t\tethtool_link_ksettings_add_link_mode\n\t\t\t\t\t\t(ecmd, advertising,\n\t\t\t\t\t\t 10000baseSR_Full);\n\t\t\t\t\tethtool_link_ksettings_add_link_mode\n\t\t\t\t\t\t(ecmd, advertising,\n\t\t\t\t\t\t 10000baseKR_Full);\n\t\t\t\t\tethtool_link_ksettings_add_link_mode\n\t\t\t\t\t\t(ecmd, advertising,\n\t\t\t\t\t\t 10000baseCR_Full);\n\t\t\t\t}\n\n\t\t\t\tif (linfo->link.s.speed == 25000) {\n\t\t\t\t\tethtool_link_ksettings_add_link_mode\n\t\t\t\t\t\t(ecmd, supported,\n\t\t\t\t\t\t 25000baseSR_Full);\n\t\t\t\t\tethtool_link_ksettings_add_link_mode\n\t\t\t\t\t\t(ecmd, supported,\n\t\t\t\t\t\t 25000baseKR_Full);\n\t\t\t\t\tethtool_link_ksettings_add_link_mode\n\t\t\t\t\t\t(ecmd, supported,\n\t\t\t\t\t\t 25000baseCR_Full);\n\n\t\t\t\t\tethtool_link_ksettings_add_link_mode\n\t\t\t\t\t\t(ecmd, advertising,\n\t\t\t\t\t\t 25000baseSR_Full);\n\t\t\t\t\tethtool_link_ksettings_add_link_mode\n\t\t\t\t\t\t(ecmd, advertising,\n\t\t\t\t\t\t 25000baseKR_Full);\n\t\t\t\t\tethtool_link_ksettings_add_link_mode\n\t\t\t\t\t\t(ecmd, advertising,\n\t\t\t\t\t\t 25000baseCR_Full);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tethtool_link_ksettings_add_link_mode(ecmd, supported,\n\t\t\t\t\t\t\t     10000baseT_Full);\n\t\t\tethtool_link_ksettings_add_link_mode(ecmd, advertising,\n\t\t\t\t\t\t\t     10000baseT_Full);\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (linfo->link.s.link_up) {\n\t\tecmd->base.speed = linfo->link.s.speed;\n\t\tecmd->base.duplex = linfo->link.s.duplex;\n\t} else {\n\t\tecmd->base.speed = SPEED_UNKNOWN;\n\t\tecmd->base.duplex = DUPLEX_UNKNOWN;\n\t}\n\n\treturn 0;\n}\n\nstatic int lio_set_link_ksettings(struct net_device *netdev,\n\t\t\t\t  const struct ethtool_link_ksettings *ecmd)\n{\n\tconst int speed = ecmd->base.speed;\n\tstruct lio *lio = GET_LIO(netdev);\n\tstruct oct_link_info *linfo;\n\tstruct octeon_device *oct;\n\n\toct = lio->oct_dev;\n\n\tlinfo = &lio->linfo;\n\n\tif (!(oct->subsystem_id == OCTEON_CN2350_25GB_SUBSYS_ID ||\n\t      oct->subsystem_id == OCTEON_CN2360_25GB_SUBSYS_ID))\n\t\treturn -EOPNOTSUPP;\n\n\tif (oct->no_speed_setting) {\n\t\tdev_err(&oct->pci_dev->dev, \"%s: Changing speed is not supported\\n\",\n\t\t\t__func__);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif ((ecmd->base.duplex != DUPLEX_UNKNOWN &&\n\t     ecmd->base.duplex != linfo->link.s.duplex) ||\n\t     ecmd->base.autoneg != AUTONEG_DISABLE ||\n\t    (ecmd->base.speed != 10000 && ecmd->base.speed != 25000 &&\n\t     ecmd->base.speed != SPEED_UNKNOWN))\n\t\treturn -EOPNOTSUPP;\n\n\tif ((oct->speed_boot == speed / 1000) &&\n\t    oct->speed_boot == oct->speed_setting)\n\t\treturn 0;\n\n\tliquidio_set_speed(lio, speed / 1000);\n\n\tdev_dbg(&oct->pci_dev->dev, \"Port speed is set to %dG\\n\",\n\t\toct->speed_setting);\n\n\treturn 0;\n}\n\nstatic void\nlio_get_drvinfo(struct net_device *netdev, struct ethtool_drvinfo *drvinfo)\n{\n\tstruct lio *lio;\n\tstruct octeon_device *oct;\n\n\tlio = GET_LIO(netdev);\n\toct = lio->oct_dev;\n\n\tmemset(drvinfo, 0, sizeof(struct ethtool_drvinfo));\n\tstrcpy(drvinfo->driver, \"liquidio\");\n\tstrncpy(drvinfo->fw_version, oct->fw_info.liquidio_firmware_version,\n\t\tETHTOOL_FWVERS_LEN);\n\tstrncpy(drvinfo->bus_info, pci_name(oct->pci_dev), 32);\n}\n\nstatic void\nlio_get_vf_drvinfo(struct net_device *netdev, struct ethtool_drvinfo *drvinfo)\n{\n\tstruct octeon_device *oct;\n\tstruct lio *lio;\n\n\tlio = GET_LIO(netdev);\n\toct = lio->oct_dev;\n\n\tmemset(drvinfo, 0, sizeof(struct ethtool_drvinfo));\n\tstrcpy(drvinfo->driver, \"liquidio_vf\");\n\tstrncpy(drvinfo->fw_version, oct->fw_info.liquidio_firmware_version,\n\t\tETHTOOL_FWVERS_LEN);\n\tstrncpy(drvinfo->bus_info, pci_name(oct->pci_dev), 32);\n}\n\nstatic int\nlio_send_queue_count_update(struct net_device *netdev, uint32_t num_queues)\n{\n\tstruct lio *lio = GET_LIO(netdev);\n\tstruct octeon_device *oct = lio->oct_dev;\n\tstruct octnic_ctrl_pkt nctrl;\n\tint ret = 0;\n\n\tmemset(&nctrl, 0, sizeof(struct octnic_ctrl_pkt));\n\n\tnctrl.ncmd.u64 = 0;\n\tnctrl.ncmd.s.cmd = OCTNET_CMD_QUEUE_COUNT_CTL;\n\tnctrl.ncmd.s.param1 = num_queues;\n\tnctrl.ncmd.s.param2 = num_queues;\n\tnctrl.iq_no = lio->linfo.txpciq[0].s.q_no;\n\tnctrl.netpndev = (u64)netdev;\n\tnctrl.cb_fn = liquidio_link_ctrl_cmd_completion;\n\n\tret = octnet_send_nic_ctrl_pkt(lio->oct_dev, &nctrl);\n\tif (ret) {\n\t\tdev_err(&oct->pci_dev->dev, \"Failed to send Queue reset command (ret: 0x%x)\\n\",\n\t\t\tret);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic void\nlio_ethtool_get_channels(struct net_device *dev,\n\t\t\t struct ethtool_channels *channel)\n{\n\tstruct lio *lio = GET_LIO(dev);\n\tstruct octeon_device *oct = lio->oct_dev;\n\tu32 max_rx = 0, max_tx = 0, tx_count = 0, rx_count = 0;\n\tu32 combined_count = 0, max_combined = 0;\n\n\tif (OCTEON_CN6XXX(oct)) {\n\t\tstruct octeon_config *conf6x = CHIP_CONF(oct, cn6xxx);\n\n\t\tmax_rx = CFG_GET_OQ_MAX_Q(conf6x);\n\t\tmax_tx = CFG_GET_IQ_MAX_Q(conf6x);\n\t\trx_count = CFG_GET_NUM_RXQS_NIC_IF(conf6x, lio->ifidx);\n\t\ttx_count = CFG_GET_NUM_TXQS_NIC_IF(conf6x, lio->ifidx);\n\t} else if (OCTEON_CN23XX_PF(oct)) {\n\t\tif (oct->sriov_info.sriov_enabled) {\n\t\t\tmax_combined = lio->linfo.num_txpciq;\n\t\t} else {\n\t\t\tstruct octeon_config *conf23_pf =\n\t\t\t\tCHIP_CONF(oct, cn23xx_pf);\n\n\t\t\tmax_combined = CFG_GET_IQ_MAX_Q(conf23_pf);\n\t\t}\n\t\tcombined_count = oct->num_iqs;\n\t} else if (OCTEON_CN23XX_VF(oct)) {\n\t\tu64 reg_val = 0ULL;\n\t\tu64 ctrl = CN23XX_VF_SLI_IQ_PKT_CONTROL64(0);\n\n\t\treg_val = octeon_read_csr64(oct, ctrl);\n\t\treg_val = reg_val >> CN23XX_PKT_INPUT_CTL_RPVF_POS;\n\t\tmax_combined = reg_val & CN23XX_PKT_INPUT_CTL_RPVF_MASK;\n\t\tcombined_count = oct->num_iqs;\n\t}\n\n\tchannel->max_rx = max_rx;\n\tchannel->max_tx = max_tx;\n\tchannel->max_combined = max_combined;\n\tchannel->rx_count = rx_count;\n\tchannel->tx_count = tx_count;\n\tchannel->combined_count = combined_count;\n}\n\nstatic int\nlio_irq_reallocate_irqs(struct octeon_device *oct, uint32_t num_ioqs)\n{\n\tstruct msix_entry *msix_entries;\n\tint num_msix_irqs = 0;\n\tint i;\n\n\tif (!oct->msix_on)\n\t\treturn 0;\n\n\t \n\toct->fn_list.disable_interrupt(oct, OCTEON_ALL_INTR);\n\n\tif (oct->msix_on) {\n\t\tif (OCTEON_CN23XX_PF(oct))\n\t\t\tnum_msix_irqs = oct->num_msix_irqs - 1;\n\t\telse if (OCTEON_CN23XX_VF(oct))\n\t\t\tnum_msix_irqs = oct->num_msix_irqs;\n\n\t\tmsix_entries = (struct msix_entry *)oct->msix_entries;\n\t\tfor (i = 0; i < num_msix_irqs; i++) {\n\t\t\tif (oct->ioq_vector[i].vector) {\n\t\t\t\t \n\t\t\t\tirq_set_affinity_hint(msix_entries[i].vector,\n\t\t\t\t\t\t      NULL);\n\t\t\t\tfree_irq(msix_entries[i].vector,\n\t\t\t\t\t &oct->ioq_vector[i]);\n\t\t\t\toct->ioq_vector[i].vector = 0;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (OCTEON_CN23XX_PF(oct))\n\t\t\tfree_irq(msix_entries[i].vector, oct);\n\n\t\tpci_disable_msix(oct->pci_dev);\n\t\tkfree(oct->msix_entries);\n\t\toct->msix_entries = NULL;\n\t}\n\n\tkfree(oct->irq_name_storage);\n\toct->irq_name_storage = NULL;\n\n\tif (octeon_allocate_ioq_vector(oct, num_ioqs)) {\n\t\tdev_err(&oct->pci_dev->dev, \"OCTEON: ioq vector allocation failed\\n\");\n\t\treturn -1;\n\t}\n\n\tif (octeon_setup_interrupt(oct, num_ioqs)) {\n\t\tdev_info(&oct->pci_dev->dev, \"Setup interrupt failed\\n\");\n\t\treturn -1;\n\t}\n\n\t \n\toct->fn_list.enable_interrupt(oct, OCTEON_ALL_INTR);\n\n\treturn 0;\n}\n\nstatic int\nlio_ethtool_set_channels(struct net_device *dev,\n\t\t\t struct ethtool_channels *channel)\n{\n\tu32 combined_count, max_combined;\n\tstruct lio *lio = GET_LIO(dev);\n\tstruct octeon_device *oct = lio->oct_dev;\n\tint stopped = 0;\n\n\tif (strcmp(oct->fw_info.liquidio_firmware_version, \"1.6.1\") < 0) {\n\t\tdev_err(&oct->pci_dev->dev, \"Minimum firmware version required is 1.6.1\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!channel->combined_count || channel->other_count ||\n\t    channel->rx_count || channel->tx_count)\n\t\treturn -EINVAL;\n\n\tcombined_count = channel->combined_count;\n\n\tif (OCTEON_CN23XX_PF(oct)) {\n\t\tif (oct->sriov_info.sriov_enabled) {\n\t\t\tmax_combined = lio->linfo.num_txpciq;\n\t\t} else {\n\t\t\tstruct octeon_config *conf23_pf =\n\t\t\t\tCHIP_CONF(oct,\n\t\t\t\t\t  cn23xx_pf);\n\n\t\t\tmax_combined =\n\t\t\t\tCFG_GET_IQ_MAX_Q(conf23_pf);\n\t\t}\n\t} else if (OCTEON_CN23XX_VF(oct)) {\n\t\tu64 reg_val = 0ULL;\n\t\tu64 ctrl = CN23XX_VF_SLI_IQ_PKT_CONTROL64(0);\n\n\t\treg_val = octeon_read_csr64(oct, ctrl);\n\t\treg_val = reg_val >> CN23XX_PKT_INPUT_CTL_RPVF_POS;\n\t\tmax_combined = reg_val & CN23XX_PKT_INPUT_CTL_RPVF_MASK;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\tif (combined_count > max_combined || combined_count < 1)\n\t\treturn -EINVAL;\n\n\tif (combined_count == oct->num_iqs)\n\t\treturn 0;\n\n\tifstate_set(lio, LIO_IFSTATE_RESETTING);\n\n\tif (netif_running(dev)) {\n\t\tdev->netdev_ops->ndo_stop(dev);\n\t\tstopped = 1;\n\t}\n\n\tif (lio_reset_queues(dev, combined_count))\n\t\treturn -EINVAL;\n\n\tif (stopped)\n\t\tdev->netdev_ops->ndo_open(dev);\n\n\tifstate_reset(lio, LIO_IFSTATE_RESETTING);\n\n\treturn 0;\n}\n\nstatic int lio_get_eeprom_len(struct net_device *netdev)\n{\n\tu8 buf[192];\n\tstruct lio *lio = GET_LIO(netdev);\n\tstruct octeon_device *oct_dev = lio->oct_dev;\n\tstruct octeon_board_info *board_info;\n\tint len;\n\n\tboard_info = (struct octeon_board_info *)(&oct_dev->boardinfo);\n\tlen = sprintf(buf, \"boardname:%s serialnum:%s maj:%lld min:%lld\\n\",\n\t\t      board_info->name, board_info->serial_number,\n\t\t      board_info->major, board_info->minor);\n\n\treturn len;\n}\n\nstatic int\nlio_get_eeprom(struct net_device *netdev, struct ethtool_eeprom *eeprom,\n\t       u8 *bytes)\n{\n\tstruct lio *lio = GET_LIO(netdev);\n\tstruct octeon_device *oct_dev = lio->oct_dev;\n\tstruct octeon_board_info *board_info;\n\n\tif (eeprom->offset)\n\t\treturn -EINVAL;\n\n\teeprom->magic = oct_dev->pci_dev->vendor;\n\tboard_info = (struct octeon_board_info *)(&oct_dev->boardinfo);\n\tsprintf((char *)bytes,\n\t\t\"boardname:%s serialnum:%s maj:%lld min:%lld\\n\",\n\t\tboard_info->name, board_info->serial_number,\n\t\tboard_info->major, board_info->minor);\n\n\treturn 0;\n}\n\nstatic int octnet_gpio_access(struct net_device *netdev, int addr, int val)\n{\n\tstruct lio *lio = GET_LIO(netdev);\n\tstruct octeon_device *oct = lio->oct_dev;\n\tstruct octnic_ctrl_pkt nctrl;\n\tint ret = 0;\n\n\tmemset(&nctrl, 0, sizeof(struct octnic_ctrl_pkt));\n\n\tnctrl.ncmd.u64 = 0;\n\tnctrl.ncmd.s.cmd = OCTNET_CMD_GPIO_ACCESS;\n\tnctrl.ncmd.s.param1 = addr;\n\tnctrl.ncmd.s.param2 = val;\n\tnctrl.iq_no = lio->linfo.txpciq[0].s.q_no;\n\tnctrl.netpndev = (u64)netdev;\n\tnctrl.cb_fn = liquidio_link_ctrl_cmd_completion;\n\n\tret = octnet_send_nic_ctrl_pkt(lio->oct_dev, &nctrl);\n\tif (ret) {\n\t\tdev_err(&oct->pci_dev->dev,\n\t\t\t\"Failed to configure gpio value, ret=%d\\n\", ret);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int octnet_id_active(struct net_device *netdev, int val)\n{\n\tstruct lio *lio = GET_LIO(netdev);\n\tstruct octeon_device *oct = lio->oct_dev;\n\tstruct octnic_ctrl_pkt nctrl;\n\tint ret = 0;\n\n\tmemset(&nctrl, 0, sizeof(struct octnic_ctrl_pkt));\n\n\tnctrl.ncmd.u64 = 0;\n\tnctrl.ncmd.s.cmd = OCTNET_CMD_ID_ACTIVE;\n\tnctrl.ncmd.s.param1 = val;\n\tnctrl.iq_no = lio->linfo.txpciq[0].s.q_no;\n\tnctrl.netpndev = (u64)netdev;\n\tnctrl.cb_fn = liquidio_link_ctrl_cmd_completion;\n\n\tret = octnet_send_nic_ctrl_pkt(lio->oct_dev, &nctrl);\n\tif (ret) {\n\t\tdev_err(&oct->pci_dev->dev,\n\t\t\t\"Failed to configure gpio value, ret=%d\\n\", ret);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int\noctnet_mdio45_access(struct lio *lio, int op, int loc, int *value)\n{\n\tstruct octeon_device *oct_dev = lio->oct_dev;\n\tstruct octeon_soft_command *sc;\n\tstruct oct_mdio_cmd_resp *mdio_cmd_rsp;\n\tstruct oct_mdio_cmd *mdio_cmd;\n\tint retval = 0;\n\n\tsc = (struct octeon_soft_command *)\n\t\tocteon_alloc_soft_command(oct_dev,\n\t\t\t\t\t  sizeof(struct oct_mdio_cmd),\n\t\t\t\t\t  sizeof(struct oct_mdio_cmd_resp), 0);\n\n\tif (!sc)\n\t\treturn -ENOMEM;\n\n\tmdio_cmd_rsp = (struct oct_mdio_cmd_resp *)sc->virtrptr;\n\tmdio_cmd = (struct oct_mdio_cmd *)sc->virtdptr;\n\n\tmdio_cmd->op = op;\n\tmdio_cmd->mdio_addr = loc;\n\tif (op)\n\t\tmdio_cmd->value1 = *value;\n\tocteon_swap_8B_data((u64 *)mdio_cmd, sizeof(struct oct_mdio_cmd) / 8);\n\n\tsc->iq_no = lio->linfo.txpciq[0].s.q_no;\n\n\tocteon_prepare_soft_command(oct_dev, sc, OPCODE_NIC, OPCODE_NIC_MDIO45,\n\t\t\t\t    0, 0, 0);\n\n\tinit_completion(&sc->complete);\n\tsc->sc_status = OCTEON_REQUEST_PENDING;\n\n\tretval = octeon_send_soft_command(oct_dev, sc);\n\tif (retval == IQ_SEND_FAILED) {\n\t\tdev_err(&oct_dev->pci_dev->dev,\n\t\t\t\"octnet_mdio45_access instruction failed status: %x\\n\",\n\t\t\tretval);\n\t\tocteon_free_soft_command(oct_dev, sc);\n\t\treturn -EBUSY;\n\t} else {\n\t\t \n\t\tretval = wait_for_sc_completion_timeout(oct_dev, sc, 0);\n\t\tif (retval)\n\t\t\treturn retval;\n\n\t\tretval = mdio_cmd_rsp->status;\n\t\tif (retval) {\n\t\t\tdev_err(&oct_dev->pci_dev->dev,\n\t\t\t\t\"octnet mdio45 access failed: %x\\n\", retval);\n\t\t\tWRITE_ONCE(sc->caller_is_done, true);\n\t\t\treturn -EBUSY;\n\t\t}\n\n\t\tocteon_swap_8B_data((u64 *)(&mdio_cmd_rsp->resp),\n\t\t\t\t    sizeof(struct oct_mdio_cmd) / 8);\n\n\t\tif (!op)\n\t\t\t*value = mdio_cmd_rsp->resp.value1;\n\n\t\tWRITE_ONCE(sc->caller_is_done, true);\n\t}\n\n\treturn retval;\n}\n\nstatic int lio_set_phys_id(struct net_device *netdev,\n\t\t\t   enum ethtool_phys_id_state state)\n{\n\tstruct lio *lio = GET_LIO(netdev);\n\tstruct octeon_device *oct = lio->oct_dev;\n\tstruct oct_link_info *linfo;\n\tint value, ret;\n\tu32 cur_ver;\n\n\tlinfo = &lio->linfo;\n\tcur_ver = OCT_FW_VER(oct->fw_info.ver.maj,\n\t\t\t     oct->fw_info.ver.min,\n\t\t\t     oct->fw_info.ver.rev);\n\n\tswitch (state) {\n\tcase ETHTOOL_ID_ACTIVE:\n\t\tif (oct->chip_id == OCTEON_CN66XX) {\n\t\t\toctnet_gpio_access(netdev, VITESSE_PHY_GPIO_CFG,\n\t\t\t\t\t   VITESSE_PHY_GPIO_DRIVEON);\n\t\t\treturn 2;\n\n\t\t} else if (oct->chip_id == OCTEON_CN68XX) {\n\t\t\t \n\t\t\tret = octnet_mdio45_access(lio, 0,\n\t\t\t\t\t\t   LIO68XX_LED_BEACON_ADDR,\n\t\t\t\t\t\t   &lio->phy_beacon_val);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tret = octnet_mdio45_access(lio, 0,\n\t\t\t\t\t\t   LIO68XX_LED_CTRL_ADDR,\n\t\t\t\t\t\t   &lio->led_ctrl_val);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\t \n\t\t\tvalue = LIO68XX_LED_BEACON_CFGON;\n\t\t\tret = octnet_mdio45_access(lio, 1,\n\t\t\t\t\t\t   LIO68XX_LED_BEACON_ADDR,\n\t\t\t\t\t\t   &value);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tvalue = LIO68XX_LED_CTRL_CFGON;\n\t\t\tret = octnet_mdio45_access(lio, 1,\n\t\t\t\t\t\t   LIO68XX_LED_CTRL_ADDR,\n\t\t\t\t\t\t   &value);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t} else if (oct->chip_id == OCTEON_CN23XX_PF_VID) {\n\t\t\toctnet_id_active(netdev, LED_IDENTIFICATION_ON);\n\t\t\tif (linfo->link.s.phy_type == LIO_PHY_PORT_TP &&\n\t\t\t    cur_ver > OCT_FW_VER(1, 7, 2))\n\t\t\t\treturn 2;\n\t\t\telse\n\t\t\t\treturn 0;\n\t\t} else {\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\n\tcase ETHTOOL_ID_ON:\n\t\tif (oct->chip_id == OCTEON_CN23XX_PF_VID &&\n\t\t    linfo->link.s.phy_type == LIO_PHY_PORT_TP &&\n\t\t    cur_ver > OCT_FW_VER(1, 7, 2))\n\t\t\toctnet_id_active(netdev, LED_IDENTIFICATION_ON);\n\t\telse if (oct->chip_id == OCTEON_CN66XX)\n\t\t\toctnet_gpio_access(netdev, VITESSE_PHY_GPIO_CFG,\n\t\t\t\t\t   VITESSE_PHY_GPIO_HIGH);\n\t\telse\n\t\t\treturn -EINVAL;\n\n\t\tbreak;\n\n\tcase ETHTOOL_ID_OFF:\n\t\tif (oct->chip_id == OCTEON_CN23XX_PF_VID &&\n\t\t    linfo->link.s.phy_type == LIO_PHY_PORT_TP &&\n\t\t    cur_ver > OCT_FW_VER(1, 7, 2))\n\t\t\toctnet_id_active(netdev, LED_IDENTIFICATION_OFF);\n\t\telse if (oct->chip_id == OCTEON_CN66XX)\n\t\t\toctnet_gpio_access(netdev, VITESSE_PHY_GPIO_CFG,\n\t\t\t\t\t   VITESSE_PHY_GPIO_LOW);\n\t\telse\n\t\t\treturn -EINVAL;\n\n\t\tbreak;\n\n\tcase ETHTOOL_ID_INACTIVE:\n\t\tif (oct->chip_id == OCTEON_CN66XX) {\n\t\t\toctnet_gpio_access(netdev, VITESSE_PHY_GPIO_CFG,\n\t\t\t\t\t   VITESSE_PHY_GPIO_DRIVEOFF);\n\t\t} else if (oct->chip_id == OCTEON_CN68XX) {\n\t\t\t \n\t\t\tret = octnet_mdio45_access(lio, 1,\n\t\t\t\t\t\t   LIO68XX_LED_CTRL_ADDR,\n\t\t\t\t\t\t   &lio->led_ctrl_val);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tret = octnet_mdio45_access(lio, 1,\n\t\t\t\t\t\t   LIO68XX_LED_BEACON_ADDR,\n\t\t\t\t\t\t   &lio->phy_beacon_val);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t} else if (oct->chip_id == OCTEON_CN23XX_PF_VID) {\n\t\t\toctnet_id_active(netdev, LED_IDENTIFICATION_OFF);\n\n\t\t\treturn 0;\n\t\t} else {\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void\nlio_ethtool_get_ringparam(struct net_device *netdev,\n\t\t\t  struct ethtool_ringparam *ering,\n\t\t\t  struct kernel_ethtool_ringparam *kernel_ering,\n\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct lio *lio = GET_LIO(netdev);\n\tstruct octeon_device *oct = lio->oct_dev;\n\tu32 tx_max_pending = 0, rx_max_pending = 0, tx_pending = 0,\n\t    rx_pending = 0;\n\n\tif (ifstate_check(lio, LIO_IFSTATE_RESETTING))\n\t\treturn;\n\n\tif (OCTEON_CN6XXX(oct)) {\n\t\tstruct octeon_config *conf6x = CHIP_CONF(oct, cn6xxx);\n\n\t\ttx_max_pending = CN6XXX_MAX_IQ_DESCRIPTORS;\n\t\trx_max_pending = CN6XXX_MAX_OQ_DESCRIPTORS;\n\t\trx_pending = CFG_GET_NUM_RX_DESCS_NIC_IF(conf6x, lio->ifidx);\n\t\ttx_pending = CFG_GET_NUM_TX_DESCS_NIC_IF(conf6x, lio->ifidx);\n\t} else if (OCTEON_CN23XX_PF(oct) || OCTEON_CN23XX_VF(oct)) {\n\t\ttx_max_pending = CN23XX_MAX_IQ_DESCRIPTORS;\n\t\trx_max_pending = CN23XX_MAX_OQ_DESCRIPTORS;\n\t\trx_pending = oct->droq[0]->max_count;\n\t\ttx_pending = oct->instr_queue[0]->max_count;\n\t}\n\n\tering->tx_pending = tx_pending;\n\tering->tx_max_pending = tx_max_pending;\n\tering->rx_pending = rx_pending;\n\tering->rx_max_pending = rx_max_pending;\n\tering->rx_mini_pending = 0;\n\tering->rx_jumbo_pending = 0;\n\tering->rx_mini_max_pending = 0;\n\tering->rx_jumbo_max_pending = 0;\n}\n\nstatic int lio_23xx_reconfigure_queue_count(struct lio *lio)\n{\n\tstruct octeon_device *oct = lio->oct_dev;\n\tu32 resp_size, data_size;\n\tstruct liquidio_if_cfg_resp *resp;\n\tstruct octeon_soft_command *sc;\n\tunion oct_nic_if_cfg if_cfg;\n\tstruct lio_version *vdata;\n\tu32 ifidx_or_pfnum;\n\tint retval;\n\tint j;\n\n\tresp_size = sizeof(struct liquidio_if_cfg_resp);\n\tdata_size = sizeof(struct lio_version);\n\tsc = (struct octeon_soft_command *)\n\t\tocteon_alloc_soft_command(oct, data_size,\n\t\t\t\t\t  resp_size, 0);\n\tif (!sc) {\n\t\tdev_err(&oct->pci_dev->dev, \"%s: Failed to allocate soft command\\n\",\n\t\t\t__func__);\n\t\treturn -1;\n\t}\n\n\tresp = (struct liquidio_if_cfg_resp *)sc->virtrptr;\n\tvdata = (struct lio_version *)sc->virtdptr;\n\n\tvdata->major = (__force u16)cpu_to_be16(LIQUIDIO_BASE_MAJOR_VERSION);\n\tvdata->minor = (__force u16)cpu_to_be16(LIQUIDIO_BASE_MINOR_VERSION);\n\tvdata->micro = (__force u16)cpu_to_be16(LIQUIDIO_BASE_MICRO_VERSION);\n\n\tifidx_or_pfnum = oct->pf_num;\n\n\tif_cfg.u64 = 0;\n\tif_cfg.s.num_iqueues = oct->sriov_info.num_pf_rings;\n\tif_cfg.s.num_oqueues = oct->sriov_info.num_pf_rings;\n\tif_cfg.s.base_queue = oct->sriov_info.pf_srn;\n\tif_cfg.s.gmx_port_id = oct->pf_num;\n\n\tsc->iq_no = 0;\n\tocteon_prepare_soft_command(oct, sc, OPCODE_NIC,\n\t\t\t\t    OPCODE_NIC_QCOUNT_UPDATE, 0,\n\t\t\t\t    if_cfg.u64, 0);\n\n\tinit_completion(&sc->complete);\n\tsc->sc_status = OCTEON_REQUEST_PENDING;\n\n\tretval = octeon_send_soft_command(oct, sc);\n\tif (retval == IQ_SEND_FAILED) {\n\t\tdev_err(&oct->pci_dev->dev,\n\t\t\t\"Sending iq/oq config failed status: %x\\n\",\n\t\t\tretval);\n\t\tocteon_free_soft_command(oct, sc);\n\t\treturn -EIO;\n\t}\n\n\tretval = wait_for_sc_completion_timeout(oct, sc, 0);\n\tif (retval)\n\t\treturn retval;\n\n\tretval = resp->status;\n\tif (retval) {\n\t\tdev_err(&oct->pci_dev->dev,\n\t\t\t\"iq/oq config failed: %x\\n\", retval);\n\t\tWRITE_ONCE(sc->caller_is_done, true);\n\t\treturn -1;\n\t}\n\n\tocteon_swap_8B_data((u64 *)(&resp->cfg_info),\n\t\t\t    (sizeof(struct liquidio_if_cfg_info)) >> 3);\n\n\tlio->ifidx = ifidx_or_pfnum;\n\tlio->linfo.num_rxpciq = hweight64(resp->cfg_info.iqmask);\n\tlio->linfo.num_txpciq = hweight64(resp->cfg_info.iqmask);\n\tfor (j = 0; j < lio->linfo.num_rxpciq; j++) {\n\t\tlio->linfo.rxpciq[j].u64 =\n\t\t\tresp->cfg_info.linfo.rxpciq[j].u64;\n\t}\n\n\tfor (j = 0; j < lio->linfo.num_txpciq; j++) {\n\t\tlio->linfo.txpciq[j].u64 =\n\t\t\tresp->cfg_info.linfo.txpciq[j].u64;\n\t}\n\n\tlio->linfo.hw_addr = resp->cfg_info.linfo.hw_addr;\n\tlio->linfo.gmxport = resp->cfg_info.linfo.gmxport;\n\tlio->linfo.link.u64 = resp->cfg_info.linfo.link.u64;\n\tlio->txq = lio->linfo.txpciq[0].s.q_no;\n\tlio->rxq = lio->linfo.rxpciq[0].s.q_no;\n\n\tdev_info(&oct->pci_dev->dev, \"Queue count updated to %d\\n\",\n\t\t lio->linfo.num_rxpciq);\n\n\tWRITE_ONCE(sc->caller_is_done, true);\n\n\treturn 0;\n}\n\nstatic int lio_reset_queues(struct net_device *netdev, uint32_t num_qs)\n{\n\tstruct lio *lio = GET_LIO(netdev);\n\tstruct octeon_device *oct = lio->oct_dev;\n\tint i, queue_count_update = 0;\n\tstruct napi_struct *napi, *n;\n\tint ret;\n\n\tschedule_timeout_uninterruptible(msecs_to_jiffies(100));\n\n\tif (wait_for_pending_requests(oct))\n\t\tdev_err(&oct->pci_dev->dev, \"There were pending requests\\n\");\n\n\tif (lio_wait_for_instr_fetch(oct))\n\t\tdev_err(&oct->pci_dev->dev, \"IQ had pending instructions\\n\");\n\n\tif (octeon_set_io_queues_off(oct)) {\n\t\tdev_err(&oct->pci_dev->dev, \"Setting io queues off failed\\n\");\n\t\treturn -1;\n\t}\n\n\t \n\toct->fn_list.disable_io_queues(oct);\n\t \n\tlist_for_each_entry_safe(napi, n, &netdev->napi_list, dev_list)\n\t\tnetif_napi_del(napi);\n\n\tif (num_qs != oct->num_iqs) {\n\t\tret = netif_set_real_num_rx_queues(netdev, num_qs);\n\t\tif (ret) {\n\t\t\tdev_err(&oct->pci_dev->dev,\n\t\t\t\t\"Setting real number rx failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = netif_set_real_num_tx_queues(netdev, num_qs);\n\t\tif (ret) {\n\t\t\tdev_err(&oct->pci_dev->dev,\n\t\t\t\t\"Setting real number tx failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tqueue_count_update = 1;\n\t}\n\n\t \n\tif (queue_count_update) {\n\t\tcleanup_rx_oom_poll_fn(netdev);\n\n\t\tlio_delete_glists(lio);\n\n\t\t \n\t\tif ((OCTEON_CN23XX_PF(oct)) && !oct->sriov_info.sriov_enabled)\n\t\t\toct->fn_list.free_mbox(oct);\n\t}\n\n\tfor (i = 0; i < MAX_OCTEON_OUTPUT_QUEUES(oct); i++) {\n\t\tif (!(oct->io_qmask.oq & BIT_ULL(i)))\n\t\t\tcontinue;\n\t\tocteon_delete_droq(oct, i);\n\t}\n\n\tfor (i = 0; i < MAX_OCTEON_INSTR_QUEUES(oct); i++) {\n\t\tif (!(oct->io_qmask.iq & BIT_ULL(i)))\n\t\t\tcontinue;\n\t\tocteon_delete_instr_queue(oct, i);\n\t}\n\n\tif (queue_count_update) {\n\t\t \n\t\tif ((OCTEON_CN23XX_PF(oct)) &&\n\t\t    !oct->sriov_info.sriov_enabled) {\n\t\t\toct->sriov_info.num_pf_rings = num_qs;\n\t\t\tif (cn23xx_sriov_config(oct)) {\n\t\t\t\tdev_err(&oct->pci_dev->dev,\n\t\t\t\t\t\"Queue reset aborted: SRIOV config failed\\n\");\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tnum_qs = oct->sriov_info.num_pf_rings;\n\t\t}\n\t}\n\n\tif (oct->fn_list.setup_device_regs(oct)) {\n\t\tdev_err(&oct->pci_dev->dev, \"Failed to configure device registers\\n\");\n\t\treturn -1;\n\t}\n\n\t \n\tif (queue_count_update) {\n\t\tif (octeon_setup_instr_queues(oct))\n\t\t\treturn -1;\n\n\t\tif (octeon_setup_output_queues(oct))\n\t\t\treturn -1;\n\n\t\t \n\t\tif (OCTEON_CN23XX_PF(oct) && !oct->sriov_info.sriov_enabled) {\n\t\t\tif (oct->fn_list.setup_mbox(oct)) {\n\t\t\t\tdev_err(&oct->pci_dev->dev, \"Mailbox setup failed\\n\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (lio_irq_reallocate_irqs(oct, num_qs)) {\n\t\t\tdev_err(&oct->pci_dev->dev, \"IRQs could not be allocated\\n\");\n\t\t\treturn -1;\n\t\t}\n\n\t\t \n\t\tif (oct->fn_list.enable_io_queues(oct)) {\n\t\t\tdev_err(&oct->pci_dev->dev, \"Failed to enable input/output queues\\n\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tfor (i = 0; i < oct->num_oqs; i++)\n\t\t\twritel(oct->droq[i]->max_count,\n\t\t\t       oct->droq[i]->pkts_credit_reg);\n\n\t\t \n\t\tif (OCTEON_CN23XX_PF(oct) && !oct->sriov_info.sriov_enabled) {\n\t\t\tif (lio_23xx_reconfigure_queue_count(lio))\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\n\t \n\tif (liquidio_setup_io_queues(oct, 0, num_qs, num_qs)) {\n\t\tdev_err(&oct->pci_dev->dev, \"I/O queues creation failed\\n\");\n\t\treturn -1;\n\t}\n\n\tif (queue_count_update) {\n\t\tif (lio_setup_glists(oct, lio, num_qs)) {\n\t\t\tdev_err(&oct->pci_dev->dev, \"Gather list allocation failed\\n\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (setup_rx_oom_poll_fn(netdev)) {\n\t\t\tdev_err(&oct->pci_dev->dev, \"lio_setup_rx_oom_poll_fn failed\\n\");\n\t\t\treturn 1;\n\t\t}\n\n\t\t \n\t\tif (oct->sriov_info.sriov_enabled || OCTEON_CN23XX_VF(oct))\n\t\t\tif (lio_send_queue_count_update(netdev, num_qs))\n\t\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nlio_ethtool_set_ringparam(struct net_device *netdev,\n\t\t\t  struct ethtool_ringparam *ering,\n\t\t\t  struct kernel_ethtool_ringparam *kernel_ering,\n\t\t\t  struct netlink_ext_ack *extack)\n{\n\tu32 rx_count, tx_count, rx_count_old, tx_count_old;\n\tstruct lio *lio = GET_LIO(netdev);\n\tstruct octeon_device *oct = lio->oct_dev;\n\tint stopped = 0;\n\n\tif (!OCTEON_CN23XX_PF(oct) && !OCTEON_CN23XX_VF(oct))\n\t\treturn -EINVAL;\n\n\tif (ering->rx_mini_pending || ering->rx_jumbo_pending)\n\t\treturn -EINVAL;\n\n\trx_count = clamp_t(u32, ering->rx_pending, CN23XX_MIN_OQ_DESCRIPTORS,\n\t\t\t   CN23XX_MAX_OQ_DESCRIPTORS);\n\ttx_count = clamp_t(u32, ering->tx_pending, CN23XX_MIN_IQ_DESCRIPTORS,\n\t\t\t   CN23XX_MAX_IQ_DESCRIPTORS);\n\n\trx_count_old = oct->droq[0]->max_count;\n\ttx_count_old = oct->instr_queue[0]->max_count;\n\n\tif (rx_count == rx_count_old && tx_count == tx_count_old)\n\t\treturn 0;\n\n\tifstate_set(lio, LIO_IFSTATE_RESETTING);\n\n\tif (netif_running(netdev)) {\n\t\tnetdev->netdev_ops->ndo_stop(netdev);\n\t\tstopped = 1;\n\t}\n\n\t \n\tif (tx_count != tx_count_old)\n\t\tCFG_SET_NUM_TX_DESCS_NIC_IF(octeon_get_conf(oct), lio->ifidx,\n\t\t\t\t\t    tx_count);\n\tif (rx_count != rx_count_old)\n\t\tCFG_SET_NUM_RX_DESCS_NIC_IF(octeon_get_conf(oct), lio->ifidx,\n\t\t\t\t\t    rx_count);\n\n\tif (lio_reset_queues(netdev, oct->num_iqs))\n\t\tgoto err_lio_reset_queues;\n\n\tif (stopped)\n\t\tnetdev->netdev_ops->ndo_open(netdev);\n\n\tifstate_reset(lio, LIO_IFSTATE_RESETTING);\n\n\treturn 0;\n\nerr_lio_reset_queues:\n\tif (tx_count != tx_count_old)\n\t\tCFG_SET_NUM_TX_DESCS_NIC_IF(octeon_get_conf(oct), lio->ifidx,\n\t\t\t\t\t    tx_count_old);\n\tif (rx_count != rx_count_old)\n\t\tCFG_SET_NUM_RX_DESCS_NIC_IF(octeon_get_conf(oct), lio->ifidx,\n\t\t\t\t\t    rx_count_old);\n\treturn -EINVAL;\n}\n\nstatic u32 lio_get_msglevel(struct net_device *netdev)\n{\n\tstruct lio *lio = GET_LIO(netdev);\n\n\treturn lio->msg_enable;\n}\n\nstatic void lio_set_msglevel(struct net_device *netdev, u32 msglvl)\n{\n\tstruct lio *lio = GET_LIO(netdev);\n\n\tif ((msglvl ^ lio->msg_enable) & NETIF_MSG_HW) {\n\t\tif (msglvl & NETIF_MSG_HW)\n\t\t\tliquidio_set_feature(netdev,\n\t\t\t\t\t     OCTNET_CMD_VERBOSE_ENABLE, 0);\n\t\telse\n\t\t\tliquidio_set_feature(netdev,\n\t\t\t\t\t     OCTNET_CMD_VERBOSE_DISABLE, 0);\n\t}\n\n\tlio->msg_enable = msglvl;\n}\n\nstatic void lio_vf_set_msglevel(struct net_device *netdev, u32 msglvl)\n{\n\tstruct lio *lio = GET_LIO(netdev);\n\n\tlio->msg_enable = msglvl;\n}\n\nstatic void\nlio_get_pauseparam(struct net_device *netdev, struct ethtool_pauseparam *pause)\n{\n\t \n\tstruct lio *lio = GET_LIO(netdev);\n\tstruct octeon_device *oct = lio->oct_dev;\n\n\tpause->autoneg = 0;\n\n\tpause->tx_pause = oct->tx_pause;\n\tpause->rx_pause = oct->rx_pause;\n}\n\nstatic int\nlio_set_pauseparam(struct net_device *netdev, struct ethtool_pauseparam *pause)\n{\n\t \n\tstruct lio *lio = GET_LIO(netdev);\n\tstruct octeon_device *oct = lio->oct_dev;\n\tstruct octnic_ctrl_pkt nctrl;\n\tstruct oct_link_info *linfo = &lio->linfo;\n\n\tint ret = 0;\n\n\tif (oct->chip_id != OCTEON_CN23XX_PF_VID)\n\t\treturn -EINVAL;\n\n\tif (linfo->link.s.duplex == 0) {\n\t\t \n\t\tif (pause->rx_pause || pause->tx_pause)\n\t\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (pause->autoneg == AUTONEG_ENABLE)\n\t\treturn -EINVAL;\n\n\tmemset(&nctrl, 0, sizeof(struct octnic_ctrl_pkt));\n\n\tnctrl.ncmd.u64 = 0;\n\tnctrl.ncmd.s.cmd = OCTNET_CMD_SET_FLOW_CTL;\n\tnctrl.iq_no = lio->linfo.txpciq[0].s.q_no;\n\tnctrl.netpndev = (u64)netdev;\n\tnctrl.cb_fn = liquidio_link_ctrl_cmd_completion;\n\n\tif (pause->rx_pause) {\n\t\t \n\t\tnctrl.ncmd.s.param1 = 1;\n\t} else {\n\t\t \n\t\tnctrl.ncmd.s.param1 = 0;\n\t}\n\n\tif (pause->tx_pause) {\n\t\t \n\t\tnctrl.ncmd.s.param2 = 1;\n\t} else {\n\t\t \n\t\tnctrl.ncmd.s.param2 = 0;\n\t}\n\n\tret = octnet_send_nic_ctrl_pkt(lio->oct_dev, &nctrl);\n\tif (ret) {\n\t\tdev_err(&oct->pci_dev->dev,\n\t\t\t\"Failed to set pause parameter, ret=%d\\n\", ret);\n\t\treturn -EINVAL;\n\t}\n\n\toct->rx_pause = pause->rx_pause;\n\toct->tx_pause = pause->tx_pause;\n\n\treturn 0;\n}\n\nstatic void\nlio_get_ethtool_stats(struct net_device *netdev,\n\t\t      struct ethtool_stats *stats  __attribute__((unused)),\n\t\t      u64 *data)\n{\n\tstruct lio *lio = GET_LIO(netdev);\n\tstruct octeon_device *oct_dev = lio->oct_dev;\n\tstruct rtnl_link_stats64 lstats;\n\tint i = 0, j;\n\n\tif (ifstate_check(lio, LIO_IFSTATE_RESETTING))\n\t\treturn;\n\n\tnetdev->netdev_ops->ndo_get_stats64(netdev, &lstats);\n\t \n\tdata[i++] = lstats.rx_packets;\n\t \n\tdata[i++] = lstats.tx_packets;\n\t \n\tdata[i++] = lstats.rx_bytes;\n\t \n\tdata[i++] = lstats.tx_bytes;\n\tdata[i++] = lstats.rx_errors +\n\t\t\toct_dev->link_stats.fromwire.fcs_err +\n\t\t\toct_dev->link_stats.fromwire.jabber_err +\n\t\t\toct_dev->link_stats.fromwire.l2_err +\n\t\t\toct_dev->link_stats.fromwire.frame_err;\n\tdata[i++] = lstats.tx_errors;\n\t \n\tdata[i++] = lstats.rx_dropped +\n\t\t\toct_dev->link_stats.fromwire.fifo_err +\n\t\t\toct_dev->link_stats.fromwire.dmac_drop +\n\t\t\toct_dev->link_stats.fromwire.red_drops +\n\t\t\toct_dev->link_stats.fromwire.fw_err_pko +\n\t\t\toct_dev->link_stats.fromwire.fw_err_link +\n\t\t\toct_dev->link_stats.fromwire.fw_err_drop;\n\t \n\tdata[i++] = lstats.tx_dropped +\n\t\t\toct_dev->link_stats.fromhost.max_collision_fail +\n\t\t\toct_dev->link_stats.fromhost.max_deferral_fail +\n\t\t\toct_dev->link_stats.fromhost.total_collisions +\n\t\t\toct_dev->link_stats.fromhost.fw_err_pko +\n\t\t\toct_dev->link_stats.fromhost.fw_err_link +\n\t\t\toct_dev->link_stats.fromhost.fw_err_drop +\n\t\t\toct_dev->link_stats.fromhost.fw_err_pki;\n\n\t \n\t \n\tdata[i++] = CVM_CAST64(oct_dev->link_stats.fromhost.fw_total_sent);\n\t \n\tdata[i++] = CVM_CAST64(oct_dev->link_stats.fromhost.fw_total_fwd);\n\t \n\tdata[i++] = CVM_CAST64(oct_dev->link_stats.fromhost.fw_err_pko);\n\t \n\tdata[i++] = CVM_CAST64(oct_dev->link_stats.fromhost.fw_err_pki);\n\t \n\tdata[i++] = CVM_CAST64(oct_dev->link_stats.fromhost.fw_err_link);\n\t \n\tdata[i++] = CVM_CAST64(oct_dev->link_stats.fromhost.fw_err_drop);\n\n\t \n\tdata[i++] = CVM_CAST64(oct_dev->link_stats.fromhost.fw_tso);\n\t \n\tdata[i++] = CVM_CAST64(oct_dev->link_stats.fromhost.fw_tso_fwd);\n\t \n\tdata[i++] = CVM_CAST64(oct_dev->link_stats.fromhost.fw_err_tso);\n\t \n\tdata[i++] = CVM_CAST64(oct_dev->link_stats.fromhost.fw_tx_vxlan);\n\n\t \n\tdata[i++] = oct_dev->link_stats.fromhost.fw_total_mcast_sent;\n\tdata[i++] = oct_dev->link_stats.fromhost.fw_total_bcast_sent;\n\n\t \n\t \n\tdata[i++] = CVM_CAST64(oct_dev->link_stats.fromhost.total_pkts_sent);\n\t \n\tdata[i++] = CVM_CAST64(oct_dev->link_stats.fromhost.total_bytes_sent);\n\t \n\tdata[i++] = CVM_CAST64(oct_dev->link_stats.fromhost.mcast_pkts_sent);\n\t \n\tdata[i++] = CVM_CAST64(oct_dev->link_stats.fromhost.bcast_pkts_sent);\n\t \n\tdata[i++] = CVM_CAST64(oct_dev->link_stats.fromhost.ctl_sent);\n\t \n\tdata[i++] = CVM_CAST64(oct_dev->link_stats.fromhost.total_collisions);\n\t \n\tdata[i++] = CVM_CAST64(oct_dev->link_stats.fromhost.one_collision_sent);\n\t \n\tdata[i++] =\n\t\tCVM_CAST64(oct_dev->link_stats.fromhost.multi_collision_sent);\n\t \n\tdata[i++] = CVM_CAST64(oct_dev->link_stats.fromhost.max_collision_fail);\n\t \n\tdata[i++] = CVM_CAST64(oct_dev->link_stats.fromhost.max_deferral_fail);\n\t \n\tdata[i++] = CVM_CAST64(oct_dev->link_stats.fromhost.fifo_err);\n\t \n\tdata[i++] = CVM_CAST64(oct_dev->link_stats.fromhost.runts);\n\n\t \n\t \n\tdata[i++] = CVM_CAST64(oct_dev->link_stats.fromwire.fw_total_rcvd);\n\t \n\tdata[i++] = CVM_CAST64(oct_dev->link_stats.fromwire.fw_total_fwd);\n\t \n\tdata[i++] = oct_dev->link_stats.fromwire.fw_total_mcast;\n\tdata[i++] = oct_dev->link_stats.fromwire.fw_total_bcast;\n\t \n\tdata[i++] = CVM_CAST64(oct_dev->link_stats.fromwire.jabber_err);\n\t \n\tdata[i++] = CVM_CAST64(oct_dev->link_stats.fromwire.l2_err);\n\t \n\tdata[i++] = CVM_CAST64(oct_dev->link_stats.fromwire.frame_err);\n\t \n\tdata[i++] = CVM_CAST64(oct_dev->link_stats.fromwire.fw_err_pko);\n\t \n\tdata[i++] = CVM_CAST64(oct_dev->link_stats.fromwire.fw_err_link);\n\t \n\tdata[i++] = CVM_CAST64(oct_dev->link_stats.fromwire.fw_err_drop);\n\n\t \n\tdata[i++] = CVM_CAST64(oct_dev->link_stats.fromwire.fw_rx_vxlan);\n\t \n\tdata[i++] = CVM_CAST64(oct_dev->link_stats.fromwire.fw_rx_vxlan_err);\n\n\t \n\t \n\tdata[i++] = CVM_CAST64(oct_dev->link_stats.fromwire.fw_lro_pkts);\n\t \n\tdata[i++] = CVM_CAST64(oct_dev->link_stats.fromwire.fw_lro_octs);\n\t \n\tdata[i++] = CVM_CAST64(oct_dev->link_stats.fromwire.fw_total_lro);\n\t \n\tdata[i++] = CVM_CAST64(oct_dev->link_stats.fromwire.fw_lro_aborts);\n\t \n\tdata[i++] = CVM_CAST64(oct_dev->link_stats.fromwire.fw_lro_aborts_port);\n\t \n\tdata[i++] = CVM_CAST64(oct_dev->link_stats.fromwire.fw_lro_aborts_seq);\n\t \n\tdata[i++] =\n\t\tCVM_CAST64(oct_dev->link_stats.fromwire.fw_lro_aborts_tsval);\n\t \n\t \n\tdata[i++] =\n\t\tCVM_CAST64(oct_dev->link_stats.fromwire.fw_lro_aborts_timer);\n\t \n\tdata[i++] = CVM_CAST64(oct_dev->link_stats.fromwire.fwd_rate);\n\n\t \n\t \n\tdata[i++] = CVM_CAST64(oct_dev->link_stats.fromwire.total_rcvd);\n\t \n\tdata[i++] = CVM_CAST64(oct_dev->link_stats.fromwire.bytes_rcvd);\n\t \n\tdata[i++] = CVM_CAST64(oct_dev->link_stats.fromwire.total_bcst);\n\t \n\tdata[i++] = CVM_CAST64(oct_dev->link_stats.fromwire.total_mcst);\n\t \n\tdata[i++] = CVM_CAST64(oct_dev->link_stats.fromwire.runts);\n\t \n\tdata[i++] = CVM_CAST64(oct_dev->link_stats.fromwire.ctl_rcvd);\n\t \n\tdata[i++] = CVM_CAST64(oct_dev->link_stats.fromwire.fifo_err);\n\t \n\tdata[i++] = CVM_CAST64(oct_dev->link_stats.fromwire.dmac_drop);\n\t \n\tdata[i++] = CVM_CAST64(oct_dev->link_stats.fromwire.fcs_err);\n\t \n\tdata[i++] = CVM_CAST64(lio->link_changes);\n\n\tfor (j = 0; j < MAX_OCTEON_INSTR_QUEUES(oct_dev); j++) {\n\t\tif (!(oct_dev->io_qmask.iq & BIT_ULL(j)))\n\t\t\tcontinue;\n\t\t \n\t\t \n\t\tdata[i++] = CVM_CAST64(oct_dev->instr_queue[j]->stats.tx_done);\n\t\t \n\t\tdata[i++] =\n\t\t\tCVM_CAST64(oct_dev->instr_queue[j]->stats.tx_tot_bytes);\n\t\t \n\t\tdata[i++] =\n\t\t\tCVM_CAST64(oct_dev->instr_queue[j]->stats.tx_dropped);\n\t\t \n\t\tdata[i++] =\n\t\t\tCVM_CAST64(oct_dev->instr_queue[j]->stats.tx_iq_busy);\n\t\t \n\t\tdata[i++] =\n\t\t\tCVM_CAST64(oct_dev->instr_queue[j]->stats.sgentry_sent);\n\n\t\t \n\t\t \n\t\tdata[i++] =\n\t\t\tCVM_CAST64(oct_dev->instr_queue[j]->stats.instr_posted);\n\t\t \n\t\tdata[i++] = CVM_CAST64(\n\t\t\t\toct_dev->instr_queue[j]->stats.instr_processed);\n\t\t \n\t\tdata[i++] = CVM_CAST64(\n\t\t\t\toct_dev->instr_queue[j]->stats.instr_dropped);\n\t\t \n\t\tdata[i++] =\n\t\t\tCVM_CAST64(oct_dev->instr_queue[j]->stats.bytes_sent);\n\n\t\t \n\t\tdata[i++] = CVM_CAST64(oct_dev->instr_queue[j]->stats.tx_gso);\n\t\t \n\t\tdata[i++] = CVM_CAST64(oct_dev->instr_queue[j]->stats.tx_vxlan);\n\t\t \n\t\tdata[i++] =\n\t\t\tCVM_CAST64(oct_dev->instr_queue[j]->stats.tx_restart);\n\t}\n\n\t \n\tfor (j = 0; j < MAX_OCTEON_OUTPUT_QUEUES(oct_dev); j++) {\n\t\tif (!(oct_dev->io_qmask.oq & BIT_ULL(j)))\n\t\t\tcontinue;\n\n\t\t \n\t\t \n\t\tdata[i++] =\n\t\t\tCVM_CAST64(oct_dev->droq[j]->stats.rx_pkts_received);\n\t\t \n\t\tdata[i++] =\n\t\t\tCVM_CAST64(oct_dev->droq[j]->stats.rx_bytes_received);\n\t\t \n\t\tdata[i++] = CVM_CAST64(oct_dev->droq[j]->stats.dropped_nomem +\n\t\t\t\t       oct_dev->droq[j]->stats.dropped_toomany +\n\t\t\t\t       oct_dev->droq[j]->stats.rx_dropped);\n\t\tdata[i++] =\n\t\t\tCVM_CAST64(oct_dev->droq[j]->stats.dropped_nomem);\n\t\tdata[i++] =\n\t\t\tCVM_CAST64(oct_dev->droq[j]->stats.dropped_toomany);\n\t\tdata[i++] =\n\t\t\tCVM_CAST64(oct_dev->droq[j]->stats.rx_dropped);\n\n\t\t \n\t\tdata[i++] =\n\t\t\tCVM_CAST64(oct_dev->droq[j]->stats.pkts_received);\n\t\tdata[i++] =\n\t\t\tCVM_CAST64(oct_dev->droq[j]->stats.bytes_received);\n\t\tdata[i++] =\n\t\t\tCVM_CAST64(oct_dev->droq[j]->stats.dropped_nodispatch);\n\n\t\tdata[i++] =\n\t\t\tCVM_CAST64(oct_dev->droq[j]->stats.rx_vxlan);\n\t\tdata[i++] =\n\t\t\tCVM_CAST64(oct_dev->droq[j]->stats.rx_alloc_failure);\n\t}\n}\n\nstatic void lio_vf_get_ethtool_stats(struct net_device *netdev,\n\t\t\t\t     struct ethtool_stats *stats\n\t\t\t\t     __attribute__((unused)),\n\t\t\t\t     u64 *data)\n{\n\tstruct rtnl_link_stats64 lstats;\n\tstruct lio *lio = GET_LIO(netdev);\n\tstruct octeon_device *oct_dev = lio->oct_dev;\n\tint i = 0, j, vj;\n\n\tif (ifstate_check(lio, LIO_IFSTATE_RESETTING))\n\t\treturn;\n\n\tnetdev->netdev_ops->ndo_get_stats64(netdev, &lstats);\n\t \n\tdata[i++] = lstats.rx_packets;\n\t \n\tdata[i++] = lstats.tx_packets;\n\t \n\tdata[i++] = lstats.rx_bytes;\n\t \n\tdata[i++] = lstats.tx_bytes;\n\tdata[i++] = lstats.rx_errors;\n\tdata[i++] = lstats.tx_errors;\n\t  \n\tdata[i++] = lstats.rx_dropped;\n\t \n\tdata[i++] = lstats.tx_dropped +\n\t\toct_dev->link_stats.fromhost.fw_err_drop;\n\n\tdata[i++] = oct_dev->link_stats.fromwire.fw_total_mcast;\n\tdata[i++] = oct_dev->link_stats.fromhost.fw_total_mcast_sent;\n\tdata[i++] = oct_dev->link_stats.fromwire.fw_total_bcast;\n\tdata[i++] = oct_dev->link_stats.fromhost.fw_total_bcast_sent;\n\n\t \n\tdata[i++] = CVM_CAST64(lio->link_changes);\n\n\tfor (vj = 0; vj < oct_dev->num_iqs; vj++) {\n\t\tj = lio->linfo.txpciq[vj].s.q_no;\n\n\t\t \n\t\t \n\t\tdata[i++] = CVM_CAST64(oct_dev->instr_queue[j]->stats.tx_done);\n\t\t  \n\t\tdata[i++] = CVM_CAST64(\n\t\t\t\toct_dev->instr_queue[j]->stats.tx_tot_bytes);\n\t\t \n\t\tdata[i++] = CVM_CAST64(\n\t\t\t\toct_dev->instr_queue[j]->stats.tx_dropped);\n\t\t \n\t\tdata[i++] = CVM_CAST64(\n\t\t\t\toct_dev->instr_queue[j]->stats.tx_iq_busy);\n\t\t \n\t\tdata[i++] = CVM_CAST64(\n\t\t\t\toct_dev->instr_queue[j]->stats.sgentry_sent);\n\n\t\t \n\t\t \n\t\tdata[i++] = CVM_CAST64(\n\t\t\t\toct_dev->instr_queue[j]->stats.instr_posted);\n\t\t \n\t\tdata[i++] =\n\t\t    CVM_CAST64(oct_dev->instr_queue[j]->stats.instr_processed);\n\t\t \n\t\tdata[i++] =\n\t\t    CVM_CAST64(oct_dev->instr_queue[j]->stats.instr_dropped);\n\t\t \n\t\tdata[i++] = CVM_CAST64(\n\t\t\t\toct_dev->instr_queue[j]->stats.bytes_sent);\n\t\t \n\t\tdata[i++] = CVM_CAST64(oct_dev->instr_queue[j]->stats.tx_gso);\n\t\t \n\t\tdata[i++] = CVM_CAST64(oct_dev->instr_queue[j]->stats.tx_vxlan);\n\t\t \n\t\tdata[i++] = CVM_CAST64(\n\t\t\t\toct_dev->instr_queue[j]->stats.tx_restart);\n\t}\n\n\t \n\tfor (vj = 0; vj < oct_dev->num_oqs; vj++) {\n\t\tj = lio->linfo.rxpciq[vj].s.q_no;\n\n\t\t \n\t\t \n\t\tdata[i++] = CVM_CAST64(\n\t\t\t\toct_dev->droq[j]->stats.rx_pkts_received);\n\t\t \n\t\tdata[i++] = CVM_CAST64(\n\t\t\t\toct_dev->droq[j]->stats.rx_bytes_received);\n\t\tdata[i++] = CVM_CAST64(oct_dev->droq[j]->stats.dropped_nomem +\n\t\t\t\t       oct_dev->droq[j]->stats.dropped_toomany +\n\t\t\t\t       oct_dev->droq[j]->stats.rx_dropped);\n\t\tdata[i++] = CVM_CAST64(oct_dev->droq[j]->stats.dropped_nomem);\n\t\tdata[i++] = CVM_CAST64(oct_dev->droq[j]->stats.dropped_toomany);\n\t\tdata[i++] = CVM_CAST64(oct_dev->droq[j]->stats.rx_dropped);\n\n\t\t \n\t\tdata[i++] = CVM_CAST64(oct_dev->droq[j]->stats.pkts_received);\n\t\tdata[i++] = CVM_CAST64(oct_dev->droq[j]->stats.bytes_received);\n\t\tdata[i++] =\n\t\t\tCVM_CAST64(oct_dev->droq[j]->stats.dropped_nodispatch);\n\n\t\tdata[i++] = CVM_CAST64(oct_dev->droq[j]->stats.rx_vxlan);\n\t\tdata[i++] =\n\t\t    CVM_CAST64(oct_dev->droq[j]->stats.rx_alloc_failure);\n\t}\n}\n\nstatic void lio_get_priv_flags_strings(struct lio *lio, u8 *data)\n{\n\tstruct octeon_device *oct_dev = lio->oct_dev;\n\tint i;\n\n\tswitch (oct_dev->chip_id) {\n\tcase OCTEON_CN23XX_PF_VID:\n\tcase OCTEON_CN23XX_VF_VID:\n\t\tfor (i = 0; i < ARRAY_SIZE(oct_priv_flags_strings); i++) {\n\t\t\tsprintf(data, \"%s\", oct_priv_flags_strings[i]);\n\t\t\tdata += ETH_GSTRING_LEN;\n\t\t}\n\t\tbreak;\n\tcase OCTEON_CN68XX:\n\tcase OCTEON_CN66XX:\n\t\tbreak;\n\tdefault:\n\t\tnetif_info(lio, drv, lio->netdev, \"Unknown Chip !!\\n\");\n\t\tbreak;\n\t}\n}\n\nstatic void lio_get_strings(struct net_device *netdev, u32 stringset, u8 *data)\n{\n\tstruct lio *lio = GET_LIO(netdev);\n\tstruct octeon_device *oct_dev = lio->oct_dev;\n\tint num_iq_stats, num_oq_stats, i, j;\n\tint num_stats;\n\n\tswitch (stringset) {\n\tcase ETH_SS_STATS:\n\t\tnum_stats = ARRAY_SIZE(oct_stats_strings);\n\t\tfor (j = 0; j < num_stats; j++) {\n\t\t\tsprintf(data, \"%s\", oct_stats_strings[j]);\n\t\t\tdata += ETH_GSTRING_LEN;\n\t\t}\n\n\t\tnum_iq_stats = ARRAY_SIZE(oct_iq_stats_strings);\n\t\tfor (i = 0; i < MAX_OCTEON_INSTR_QUEUES(oct_dev); i++) {\n\t\t\tif (!(oct_dev->io_qmask.iq & BIT_ULL(i)))\n\t\t\t\tcontinue;\n\t\t\tfor (j = 0; j < num_iq_stats; j++) {\n\t\t\t\tsprintf(data, \"tx-%d-%s\", i,\n\t\t\t\t\toct_iq_stats_strings[j]);\n\t\t\t\tdata += ETH_GSTRING_LEN;\n\t\t\t}\n\t\t}\n\n\t\tnum_oq_stats = ARRAY_SIZE(oct_droq_stats_strings);\n\t\tfor (i = 0; i < MAX_OCTEON_OUTPUT_QUEUES(oct_dev); i++) {\n\t\t\tif (!(oct_dev->io_qmask.oq & BIT_ULL(i)))\n\t\t\t\tcontinue;\n\t\t\tfor (j = 0; j < num_oq_stats; j++) {\n\t\t\t\tsprintf(data, \"rx-%d-%s\", i,\n\t\t\t\t\toct_droq_stats_strings[j]);\n\t\t\t\tdata += ETH_GSTRING_LEN;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase ETH_SS_PRIV_FLAGS:\n\t\tlio_get_priv_flags_strings(lio, data);\n\t\tbreak;\n\tdefault:\n\t\tnetif_info(lio, drv, lio->netdev, \"Unknown Stringset !!\\n\");\n\t\tbreak;\n\t}\n}\n\nstatic void lio_vf_get_strings(struct net_device *netdev, u32 stringset,\n\t\t\t       u8 *data)\n{\n\tint num_iq_stats, num_oq_stats, i, j;\n\tstruct lio *lio = GET_LIO(netdev);\n\tstruct octeon_device *oct_dev = lio->oct_dev;\n\tint num_stats;\n\n\tswitch (stringset) {\n\tcase ETH_SS_STATS:\n\t\tnum_stats = ARRAY_SIZE(oct_vf_stats_strings);\n\t\tfor (j = 0; j < num_stats; j++) {\n\t\t\tsprintf(data, \"%s\", oct_vf_stats_strings[j]);\n\t\t\tdata += ETH_GSTRING_LEN;\n\t\t}\n\n\t\tnum_iq_stats = ARRAY_SIZE(oct_iq_stats_strings);\n\t\tfor (i = 0; i < MAX_OCTEON_INSTR_QUEUES(oct_dev); i++) {\n\t\t\tif (!(oct_dev->io_qmask.iq & BIT_ULL(i)))\n\t\t\t\tcontinue;\n\t\t\tfor (j = 0; j < num_iq_stats; j++) {\n\t\t\t\tsprintf(data, \"tx-%d-%s\", i,\n\t\t\t\t\toct_iq_stats_strings[j]);\n\t\t\t\tdata += ETH_GSTRING_LEN;\n\t\t\t}\n\t\t}\n\n\t\tnum_oq_stats = ARRAY_SIZE(oct_droq_stats_strings);\n\t\tfor (i = 0; i < MAX_OCTEON_OUTPUT_QUEUES(oct_dev); i++) {\n\t\t\tif (!(oct_dev->io_qmask.oq & BIT_ULL(i)))\n\t\t\t\tcontinue;\n\t\t\tfor (j = 0; j < num_oq_stats; j++) {\n\t\t\t\tsprintf(data, \"rx-%d-%s\", i,\n\t\t\t\t\toct_droq_stats_strings[j]);\n\t\t\t\tdata += ETH_GSTRING_LEN;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase ETH_SS_PRIV_FLAGS:\n\t\tlio_get_priv_flags_strings(lio, data);\n\t\tbreak;\n\tdefault:\n\t\tnetif_info(lio, drv, lio->netdev, \"Unknown Stringset !!\\n\");\n\t\tbreak;\n\t}\n}\n\nstatic int lio_get_priv_flags_ss_count(struct lio *lio)\n{\n\tstruct octeon_device *oct_dev = lio->oct_dev;\n\n\tswitch (oct_dev->chip_id) {\n\tcase OCTEON_CN23XX_PF_VID:\n\tcase OCTEON_CN23XX_VF_VID:\n\t\treturn ARRAY_SIZE(oct_priv_flags_strings);\n\tcase OCTEON_CN68XX:\n\tcase OCTEON_CN66XX:\n\t\treturn -EOPNOTSUPP;\n\tdefault:\n\t\tnetif_info(lio, drv, lio->netdev, \"Unknown Chip !!\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int lio_get_sset_count(struct net_device *netdev, int sset)\n{\n\tstruct lio *lio = GET_LIO(netdev);\n\tstruct octeon_device *oct_dev = lio->oct_dev;\n\n\tswitch (sset) {\n\tcase ETH_SS_STATS:\n\t\treturn (ARRAY_SIZE(oct_stats_strings) +\n\t\t\tARRAY_SIZE(oct_iq_stats_strings) * oct_dev->num_iqs +\n\t\t\tARRAY_SIZE(oct_droq_stats_strings) * oct_dev->num_oqs);\n\tcase ETH_SS_PRIV_FLAGS:\n\t\treturn lio_get_priv_flags_ss_count(lio);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int lio_vf_get_sset_count(struct net_device *netdev, int sset)\n{\n\tstruct lio *lio = GET_LIO(netdev);\n\tstruct octeon_device *oct_dev = lio->oct_dev;\n\n\tswitch (sset) {\n\tcase ETH_SS_STATS:\n\t\treturn (ARRAY_SIZE(oct_vf_stats_strings) +\n\t\t\tARRAY_SIZE(oct_iq_stats_strings) * oct_dev->num_iqs +\n\t\t\tARRAY_SIZE(oct_droq_stats_strings) * oct_dev->num_oqs);\n\tcase ETH_SS_PRIV_FLAGS:\n\t\treturn lio_get_priv_flags_ss_count(lio);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\n \nstatic int octnet_get_intrmod_cfg(struct lio *lio,\n\t\t\t\t  struct oct_intrmod_cfg *intr_cfg)\n{\n\tstruct octeon_soft_command *sc;\n\tstruct oct_intrmod_resp *resp;\n\tint retval;\n\tstruct octeon_device *oct_dev = lio->oct_dev;\n\n\t \n\tsc = (struct octeon_soft_command *)\n\t\tocteon_alloc_soft_command(oct_dev,\n\t\t\t\t\t  0,\n\t\t\t\t\t  sizeof(struct oct_intrmod_resp), 0);\n\n\tif (!sc)\n\t\treturn -ENOMEM;\n\n\tresp = (struct oct_intrmod_resp *)sc->virtrptr;\n\tmemset(resp, 0, sizeof(struct oct_intrmod_resp));\n\n\tsc->iq_no = lio->linfo.txpciq[0].s.q_no;\n\n\tocteon_prepare_soft_command(oct_dev, sc, OPCODE_NIC,\n\t\t\t\t    OPCODE_NIC_INTRMOD_PARAMS, 0, 0, 0);\n\n\tinit_completion(&sc->complete);\n\tsc->sc_status = OCTEON_REQUEST_PENDING;\n\n\tretval = octeon_send_soft_command(oct_dev, sc);\n\tif (retval == IQ_SEND_FAILED) {\n\t\tocteon_free_soft_command(oct_dev, sc);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tretval = wait_for_sc_completion_timeout(oct_dev, sc, 0);\n\tif (retval)\n\t\treturn -ENODEV;\n\n\tif (resp->status) {\n\t\tdev_err(&oct_dev->pci_dev->dev,\n\t\t\t\"Get interrupt moderation parameters failed\\n\");\n\t\tWRITE_ONCE(sc->caller_is_done, true);\n\t\treturn -ENODEV;\n\t}\n\n\tocteon_swap_8B_data((u64 *)&resp->intrmod,\n\t\t\t    (sizeof(struct oct_intrmod_cfg)) / 8);\n\tmemcpy(intr_cfg, &resp->intrmod, sizeof(struct oct_intrmod_cfg));\n\tWRITE_ONCE(sc->caller_is_done, true);\n\n\treturn 0;\n}\n\n \nstatic int octnet_set_intrmod_cfg(struct lio *lio,\n\t\t\t\t  struct oct_intrmod_cfg *intr_cfg)\n{\n\tstruct octeon_soft_command *sc;\n\tstruct oct_intrmod_cfg *cfg;\n\tint retval;\n\tstruct octeon_device *oct_dev = lio->oct_dev;\n\n\t \n\tsc = (struct octeon_soft_command *)\n\t\tocteon_alloc_soft_command(oct_dev,\n\t\t\t\t\t  sizeof(struct oct_intrmod_cfg),\n\t\t\t\t\t  16, 0);\n\n\tif (!sc)\n\t\treturn -ENOMEM;\n\n\tcfg = (struct oct_intrmod_cfg *)sc->virtdptr;\n\n\tmemcpy(cfg, intr_cfg, sizeof(struct oct_intrmod_cfg));\n\tocteon_swap_8B_data((u64 *)cfg, (sizeof(struct oct_intrmod_cfg)) / 8);\n\n\tsc->iq_no = lio->linfo.txpciq[0].s.q_no;\n\n\tocteon_prepare_soft_command(oct_dev, sc, OPCODE_NIC,\n\t\t\t\t    OPCODE_NIC_INTRMOD_CFG, 0, 0, 0);\n\n\tinit_completion(&sc->complete);\n\tsc->sc_status = OCTEON_REQUEST_PENDING;\n\n\tretval = octeon_send_soft_command(oct_dev, sc);\n\tif (retval == IQ_SEND_FAILED) {\n\t\tocteon_free_soft_command(oct_dev, sc);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tretval = wait_for_sc_completion_timeout(oct_dev, sc, 0);\n\tif (retval)\n\t\treturn retval;\n\n\tretval = sc->sc_status;\n\tif (retval == 0) {\n\t\tdev_info(&oct_dev->pci_dev->dev,\n\t\t\t \"Rx-Adaptive Interrupt moderation %s\\n\",\n\t\t\t (intr_cfg->rx_enable) ?\n\t\t\t \"enabled\" : \"disabled\");\n\t\tWRITE_ONCE(sc->caller_is_done, true);\n\t\treturn 0;\n\t}\n\n\tdev_err(&oct_dev->pci_dev->dev,\n\t\t\"intrmod config failed. Status: %x\\n\", retval);\n\tWRITE_ONCE(sc->caller_is_done, true);\n\treturn -ENODEV;\n}\n\nstatic int lio_get_intr_coalesce(struct net_device *netdev,\n\t\t\t\t struct ethtool_coalesce *intr_coal,\n\t\t\t\t struct kernel_ethtool_coalesce *kernel_coal,\n\t\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct lio *lio = GET_LIO(netdev);\n\tstruct octeon_device *oct = lio->oct_dev;\n\tstruct octeon_instr_queue *iq;\n\tstruct oct_intrmod_cfg intrmod_cfg;\n\n\tif (octnet_get_intrmod_cfg(lio, &intrmod_cfg))\n\t\treturn -ENODEV;\n\n\tswitch (oct->chip_id) {\n\tcase OCTEON_CN23XX_PF_VID:\n\tcase OCTEON_CN23XX_VF_VID: {\n\t\tif (!intrmod_cfg.rx_enable) {\n\t\t\tintr_coal->rx_coalesce_usecs = oct->rx_coalesce_usecs;\n\t\t\tintr_coal->rx_max_coalesced_frames =\n\t\t\t\toct->rx_max_coalesced_frames;\n\t\t}\n\t\tif (!intrmod_cfg.tx_enable)\n\t\t\tintr_coal->tx_max_coalesced_frames =\n\t\t\t\toct->tx_max_coalesced_frames;\n\t\tbreak;\n\t}\n\tcase OCTEON_CN68XX:\n\tcase OCTEON_CN66XX: {\n\t\tstruct octeon_cn6xxx *cn6xxx =\n\t\t\t(struct octeon_cn6xxx *)oct->chip;\n\n\t\tif (!intrmod_cfg.rx_enable) {\n\t\t\tintr_coal->rx_coalesce_usecs =\n\t\t\t\tCFG_GET_OQ_INTR_TIME(cn6xxx->conf);\n\t\t\tintr_coal->rx_max_coalesced_frames =\n\t\t\t\tCFG_GET_OQ_INTR_PKT(cn6xxx->conf);\n\t\t}\n\t\tiq = oct->instr_queue[lio->linfo.txpciq[0].s.q_no];\n\t\tintr_coal->tx_max_coalesced_frames = iq->fill_threshold;\n\t\tbreak;\n\t}\n\tdefault:\n\t\tnetif_info(lio, drv, lio->netdev, \"Unknown Chip !!\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (intrmod_cfg.rx_enable) {\n\t\tintr_coal->use_adaptive_rx_coalesce =\n\t\t\tintrmod_cfg.rx_enable;\n\t\tintr_coal->rate_sample_interval =\n\t\t\tintrmod_cfg.check_intrvl;\n\t\tintr_coal->pkt_rate_high =\n\t\t\tintrmod_cfg.maxpkt_ratethr;\n\t\tintr_coal->pkt_rate_low =\n\t\t\tintrmod_cfg.minpkt_ratethr;\n\t\tintr_coal->rx_max_coalesced_frames_high =\n\t\t\tintrmod_cfg.rx_maxcnt_trigger;\n\t\tintr_coal->rx_coalesce_usecs_high =\n\t\t\tintrmod_cfg.rx_maxtmr_trigger;\n\t\tintr_coal->rx_coalesce_usecs_low =\n\t\t\tintrmod_cfg.rx_mintmr_trigger;\n\t\tintr_coal->rx_max_coalesced_frames_low =\n\t\t\tintrmod_cfg.rx_mincnt_trigger;\n\t}\n\tif ((OCTEON_CN23XX_PF(oct) || OCTEON_CN23XX_VF(oct)) &&\n\t    (intrmod_cfg.tx_enable)) {\n\t\tintr_coal->use_adaptive_tx_coalesce =\n\t\t\tintrmod_cfg.tx_enable;\n\t\tintr_coal->tx_max_coalesced_frames_high =\n\t\t\tintrmod_cfg.tx_maxcnt_trigger;\n\t\tintr_coal->tx_max_coalesced_frames_low =\n\t\t\tintrmod_cfg.tx_mincnt_trigger;\n\t}\n\treturn 0;\n}\n\n \nstatic int oct_cfg_adaptive_intr(struct lio *lio,\n\t\t\t\t struct oct_intrmod_cfg *intrmod_cfg,\n\t\t\t\t struct ethtool_coalesce *intr_coal)\n{\n\tint ret = 0;\n\n\tif (intrmod_cfg->rx_enable || intrmod_cfg->tx_enable) {\n\t\tintrmod_cfg->check_intrvl = intr_coal->rate_sample_interval;\n\t\tintrmod_cfg->maxpkt_ratethr = intr_coal->pkt_rate_high;\n\t\tintrmod_cfg->minpkt_ratethr = intr_coal->pkt_rate_low;\n\t}\n\tif (intrmod_cfg->rx_enable) {\n\t\tintrmod_cfg->rx_maxcnt_trigger =\n\t\t\tintr_coal->rx_max_coalesced_frames_high;\n\t\tintrmod_cfg->rx_maxtmr_trigger =\n\t\t\tintr_coal->rx_coalesce_usecs_high;\n\t\tintrmod_cfg->rx_mintmr_trigger =\n\t\t\tintr_coal->rx_coalesce_usecs_low;\n\t\tintrmod_cfg->rx_mincnt_trigger =\n\t\t\tintr_coal->rx_max_coalesced_frames_low;\n\t}\n\tif (intrmod_cfg->tx_enable) {\n\t\tintrmod_cfg->tx_maxcnt_trigger =\n\t\t\tintr_coal->tx_max_coalesced_frames_high;\n\t\tintrmod_cfg->tx_mincnt_trigger =\n\t\t\tintr_coal->tx_max_coalesced_frames_low;\n\t}\n\n\tret = octnet_set_intrmod_cfg(lio, intrmod_cfg);\n\n\treturn ret;\n}\n\nstatic int\noct_cfg_rx_intrcnt(struct lio *lio,\n\t\t   struct oct_intrmod_cfg *intrmod,\n\t\t   struct ethtool_coalesce *intr_coal)\n{\n\tstruct octeon_device *oct = lio->oct_dev;\n\tu32 rx_max_coalesced_frames;\n\n\t \n\tswitch (oct->chip_id) {\n\tcase OCTEON_CN68XX:\n\tcase OCTEON_CN66XX: {\n\t\tstruct octeon_cn6xxx *cn6xxx =\n\t\t\t(struct octeon_cn6xxx *)oct->chip;\n\n\t\tif (!intr_coal->rx_max_coalesced_frames)\n\t\t\trx_max_coalesced_frames = CN6XXX_OQ_INTR_PKT;\n\t\telse\n\t\t\trx_max_coalesced_frames =\n\t\t\t\tintr_coal->rx_max_coalesced_frames;\n\t\tocteon_write_csr(oct, CN6XXX_SLI_OQ_INT_LEVEL_PKTS,\n\t\t\t\t rx_max_coalesced_frames);\n\t\tCFG_SET_OQ_INTR_PKT(cn6xxx->conf, rx_max_coalesced_frames);\n\t\tbreak;\n\t}\n\tcase OCTEON_CN23XX_PF_VID: {\n\t\tint q_no;\n\n\t\tif (!intr_coal->rx_max_coalesced_frames)\n\t\t\trx_max_coalesced_frames = intrmod->rx_frames;\n\t\telse\n\t\t\trx_max_coalesced_frames =\n\t\t\t    intr_coal->rx_max_coalesced_frames;\n\t\tfor (q_no = 0; q_no < oct->num_oqs; q_no++) {\n\t\t\tq_no += oct->sriov_info.pf_srn;\n\t\t\tocteon_write_csr64(\n\t\t\t    oct, CN23XX_SLI_OQ_PKT_INT_LEVELS(q_no),\n\t\t\t    (octeon_read_csr64(\n\t\t\t\t oct, CN23XX_SLI_OQ_PKT_INT_LEVELS(q_no)) &\n\t\t\t     (0x3fffff00000000UL)) |\n\t\t\t\t(rx_max_coalesced_frames - 1));\n\t\t\t \n\t\t}\n\t\tintrmod->rx_frames = rx_max_coalesced_frames;\n\t\toct->rx_max_coalesced_frames = rx_max_coalesced_frames;\n\t\tbreak;\n\t}\n\tcase OCTEON_CN23XX_VF_VID: {\n\t\tint q_no;\n\n\t\tif (!intr_coal->rx_max_coalesced_frames)\n\t\t\trx_max_coalesced_frames = intrmod->rx_frames;\n\t\telse\n\t\t\trx_max_coalesced_frames =\n\t\t\t    intr_coal->rx_max_coalesced_frames;\n\t\tfor (q_no = 0; q_no < oct->num_oqs; q_no++) {\n\t\t\tocteon_write_csr64(\n\t\t\t    oct, CN23XX_VF_SLI_OQ_PKT_INT_LEVELS(q_no),\n\t\t\t    (octeon_read_csr64(\n\t\t\t\t oct, CN23XX_VF_SLI_OQ_PKT_INT_LEVELS(q_no)) &\n\t\t\t     (0x3fffff00000000UL)) |\n\t\t\t\t(rx_max_coalesced_frames - 1));\n\t\t\t \n\t\t}\n\t\tintrmod->rx_frames = rx_max_coalesced_frames;\n\t\toct->rx_max_coalesced_frames = rx_max_coalesced_frames;\n\t\tbreak;\n\t}\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int oct_cfg_rx_intrtime(struct lio *lio,\n\t\t\t       struct oct_intrmod_cfg *intrmod,\n\t\t\t       struct ethtool_coalesce *intr_coal)\n{\n\tstruct octeon_device *oct = lio->oct_dev;\n\tu32 time_threshold, rx_coalesce_usecs;\n\n\t \n\tswitch (oct->chip_id) {\n\tcase OCTEON_CN68XX:\n\tcase OCTEON_CN66XX: {\n\t\tstruct octeon_cn6xxx *cn6xxx =\n\t\t\t(struct octeon_cn6xxx *)oct->chip;\n\t\tif (!intr_coal->rx_coalesce_usecs)\n\t\t\trx_coalesce_usecs = CN6XXX_OQ_INTR_TIME;\n\t\telse\n\t\t\trx_coalesce_usecs = intr_coal->rx_coalesce_usecs;\n\n\t\ttime_threshold = lio_cn6xxx_get_oq_ticks(oct,\n\t\t\t\t\t\t\t rx_coalesce_usecs);\n\t\tocteon_write_csr(oct,\n\t\t\t\t CN6XXX_SLI_OQ_INT_LEVEL_TIME,\n\t\t\t\t time_threshold);\n\n\t\tCFG_SET_OQ_INTR_TIME(cn6xxx->conf, rx_coalesce_usecs);\n\t\tbreak;\n\t}\n\tcase OCTEON_CN23XX_PF_VID: {\n\t\tu64 time_threshold;\n\t\tint q_no;\n\n\t\tif (!intr_coal->rx_coalesce_usecs)\n\t\t\trx_coalesce_usecs = intrmod->rx_usecs;\n\t\telse\n\t\t\trx_coalesce_usecs = intr_coal->rx_coalesce_usecs;\n\t\ttime_threshold =\n\t\t    cn23xx_pf_get_oq_ticks(oct, (u32)rx_coalesce_usecs);\n\t\tfor (q_no = 0; q_no < oct->num_oqs; q_no++) {\n\t\t\tq_no += oct->sriov_info.pf_srn;\n\t\t\tocteon_write_csr64(oct,\n\t\t\t\t\t   CN23XX_SLI_OQ_PKT_INT_LEVELS(q_no),\n\t\t\t\t\t   (intrmod->rx_frames |\n\t\t\t\t\t    ((u64)time_threshold << 32)));\n\t\t\t \n\t\t}\n\t\tintrmod->rx_usecs = rx_coalesce_usecs;\n\t\toct->rx_coalesce_usecs = rx_coalesce_usecs;\n\t\tbreak;\n\t}\n\tcase OCTEON_CN23XX_VF_VID: {\n\t\tu64 time_threshold;\n\t\tint q_no;\n\n\t\tif (!intr_coal->rx_coalesce_usecs)\n\t\t\trx_coalesce_usecs = intrmod->rx_usecs;\n\t\telse\n\t\t\trx_coalesce_usecs = intr_coal->rx_coalesce_usecs;\n\n\t\ttime_threshold =\n\t\t    cn23xx_vf_get_oq_ticks(oct, (u32)rx_coalesce_usecs);\n\t\tfor (q_no = 0; q_no < oct->num_oqs; q_no++) {\n\t\t\tocteon_write_csr64(\n\t\t\t\toct, CN23XX_VF_SLI_OQ_PKT_INT_LEVELS(q_no),\n\t\t\t\t(intrmod->rx_frames |\n\t\t\t\t ((u64)time_threshold << 32)));\n\t\t\t \n\t\t}\n\t\tintrmod->rx_usecs = rx_coalesce_usecs;\n\t\toct->rx_coalesce_usecs = rx_coalesce_usecs;\n\t\tbreak;\n\t}\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int\noct_cfg_tx_intrcnt(struct lio *lio,\n\t\t   struct oct_intrmod_cfg *intrmod,\n\t\t   struct ethtool_coalesce *intr_coal)\n{\n\tstruct octeon_device *oct = lio->oct_dev;\n\tu32 iq_intr_pkt;\n\tvoid __iomem *inst_cnt_reg;\n\tu64 val;\n\n\t \n\tswitch (oct->chip_id) {\n\tcase OCTEON_CN68XX:\n\tcase OCTEON_CN66XX:\n\t\tbreak;\n\tcase OCTEON_CN23XX_VF_VID:\n\tcase OCTEON_CN23XX_PF_VID: {\n\t\tint q_no;\n\n\t\tif (!intr_coal->tx_max_coalesced_frames)\n\t\t\tiq_intr_pkt = CN23XX_DEF_IQ_INTR_THRESHOLD &\n\t\t\t\t      CN23XX_PKT_IN_DONE_WMARK_MASK;\n\t\telse\n\t\t\tiq_intr_pkt = intr_coal->tx_max_coalesced_frames &\n\t\t\t\t      CN23XX_PKT_IN_DONE_WMARK_MASK;\n\t\tfor (q_no = 0; q_no < oct->num_iqs; q_no++) {\n\t\t\tinst_cnt_reg = (oct->instr_queue[q_no])->inst_cnt_reg;\n\t\t\tval = readq(inst_cnt_reg);\n\t\t\t \n\t\t\tval = (val & 0xFFFF000000000000ULL) |\n\t\t\t      ((u64)(iq_intr_pkt - 1)\n\t\t\t       << CN23XX_PKT_IN_DONE_WMARK_BIT_POS);\n\t\t\twriteq(val, inst_cnt_reg);\n\t\t\t \n\t\t}\n\t\tintrmod->tx_frames = iq_intr_pkt;\n\t\toct->tx_max_coalesced_frames = iq_intr_pkt;\n\t\tbreak;\n\t}\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int lio_set_intr_coalesce(struct net_device *netdev,\n\t\t\t\t struct ethtool_coalesce *intr_coal,\n\t\t\t\t struct kernel_ethtool_coalesce *kernel_coal,\n\t\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct lio *lio = GET_LIO(netdev);\n\tint ret;\n\tstruct octeon_device *oct = lio->oct_dev;\n\tstruct oct_intrmod_cfg intrmod = {0};\n\tu32 j, q_no;\n\tint db_max, db_min;\n\n\tswitch (oct->chip_id) {\n\tcase OCTEON_CN68XX:\n\tcase OCTEON_CN66XX:\n\t\tdb_min = CN6XXX_DB_MIN;\n\t\tdb_max = CN6XXX_DB_MAX;\n\t\tif ((intr_coal->tx_max_coalesced_frames >= db_min) &&\n\t\t    (intr_coal->tx_max_coalesced_frames <= db_max)) {\n\t\t\tfor (j = 0; j < lio->linfo.num_txpciq; j++) {\n\t\t\t\tq_no = lio->linfo.txpciq[j].s.q_no;\n\t\t\t\toct->instr_queue[q_no]->fill_threshold =\n\t\t\t\t\tintr_coal->tx_max_coalesced_frames;\n\t\t\t}\n\t\t} else {\n\t\t\tdev_err(&oct->pci_dev->dev,\n\t\t\t\t\"LIQUIDIO: Invalid tx-frames:%d. Range is min:%d max:%d\\n\",\n\t\t\t\tintr_coal->tx_max_coalesced_frames,\n\t\t\t\tdb_min, db_max);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase OCTEON_CN23XX_PF_VID:\n\tcase OCTEON_CN23XX_VF_VID:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tintrmod.rx_enable = intr_coal->use_adaptive_rx_coalesce ? 1 : 0;\n\tintrmod.tx_enable = intr_coal->use_adaptive_tx_coalesce ? 1 : 0;\n\tintrmod.rx_frames = CFG_GET_OQ_INTR_PKT(octeon_get_conf(oct));\n\tintrmod.rx_usecs = CFG_GET_OQ_INTR_TIME(octeon_get_conf(oct));\n\tintrmod.tx_frames = CFG_GET_IQ_INTR_PKT(octeon_get_conf(oct));\n\n\tret = oct_cfg_adaptive_intr(lio, &intrmod, intr_coal);\n\n\tif (!intr_coal->use_adaptive_rx_coalesce) {\n\t\tret = oct_cfg_rx_intrtime(lio, &intrmod, intr_coal);\n\t\tif (ret)\n\t\t\tgoto ret_intrmod;\n\n\t\tret = oct_cfg_rx_intrcnt(lio, &intrmod, intr_coal);\n\t\tif (ret)\n\t\t\tgoto ret_intrmod;\n\t} else {\n\t\toct->rx_coalesce_usecs =\n\t\t\tCFG_GET_OQ_INTR_TIME(octeon_get_conf(oct));\n\t\toct->rx_max_coalesced_frames =\n\t\t\tCFG_GET_OQ_INTR_PKT(octeon_get_conf(oct));\n\t}\n\n\tif (!intr_coal->use_adaptive_tx_coalesce) {\n\t\tret = oct_cfg_tx_intrcnt(lio, &intrmod, intr_coal);\n\t\tif (ret)\n\t\t\tgoto ret_intrmod;\n\t} else {\n\t\toct->tx_max_coalesced_frames =\n\t\t\tCFG_GET_IQ_INTR_PKT(octeon_get_conf(oct));\n\t}\n\n\treturn 0;\nret_intrmod:\n\treturn ret;\n}\n\nstatic int lio_get_ts_info(struct net_device *netdev,\n\t\t\t   struct ethtool_ts_info *info)\n{\n\tstruct lio *lio = GET_LIO(netdev);\n\n\tinfo->so_timestamping =\n#ifdef PTP_HARDWARE_TIMESTAMPING\n\t\tSOF_TIMESTAMPING_TX_HARDWARE |\n\t\tSOF_TIMESTAMPING_RX_HARDWARE |\n\t\tSOF_TIMESTAMPING_RAW_HARDWARE |\n\t\tSOF_TIMESTAMPING_TX_SOFTWARE |\n#endif\n\t\tSOF_TIMESTAMPING_RX_SOFTWARE |\n\t\tSOF_TIMESTAMPING_SOFTWARE;\n\n\tif (lio->ptp_clock)\n\t\tinfo->phc_index = ptp_clock_index(lio->ptp_clock);\n\telse\n\t\tinfo->phc_index = -1;\n\n#ifdef PTP_HARDWARE_TIMESTAMPING\n\tinfo->tx_types = (1 << HWTSTAMP_TX_OFF) | (1 << HWTSTAMP_TX_ON);\n\n\tinfo->rx_filters = (1 << HWTSTAMP_FILTER_NONE) |\n\t\t\t   (1 << HWTSTAMP_FILTER_PTP_V1_L4_EVENT) |\n\t\t\t   (1 << HWTSTAMP_FILTER_PTP_V2_L2_EVENT) |\n\t\t\t   (1 << HWTSTAMP_FILTER_PTP_V2_L4_EVENT);\n#endif\n\n\treturn 0;\n}\n\n \nstatic int lio_get_regs_len(struct net_device *dev)\n{\n\tstruct lio *lio = GET_LIO(dev);\n\tstruct octeon_device *oct = lio->oct_dev;\n\n\tswitch (oct->chip_id) {\n\tcase OCTEON_CN23XX_PF_VID:\n\t\treturn OCT_ETHTOOL_REGDUMP_LEN_23XX;\n\tcase OCTEON_CN23XX_VF_VID:\n\t\treturn OCT_ETHTOOL_REGDUMP_LEN_23XX_VF;\n\tdefault:\n\t\treturn OCT_ETHTOOL_REGDUMP_LEN;\n\t}\n}\n\nstatic int cn23xx_read_csr_reg(char *s, struct octeon_device *oct)\n{\n\tu32 reg;\n\tu8 pf_num = oct->pf_num;\n\tint len = 0;\n\tint i;\n\n\t \n\n\tlen += sprintf(s + len, \"\\n\\t Octeon CSR Registers\\n\\n\");\n\n\t \n\treg = CN23XX_SLI_PKT_MAC_RINFO64(oct->pcie_port, oct->pf_num);\n\tlen += sprintf(s + len,\n\t\t       \"\\n[%08x] (SLI_PKT_MAC%d_PF%d_RINFO): %016llx\\n\",\n\t\t       reg, oct->pcie_port, oct->pf_num,\n\t\t       (u64)octeon_read_csr64(oct, reg));\n\n\t \n\treg = CN23XX_SLI_MAC_PF_INT_ENB64(oct->pcie_port, oct->pf_num);\n\tlen +=\n\t    sprintf(s + len, \"\\n[%08x] (SLI_MAC%d_PF%d_INT_ENB): %016llx\\n\",\n\t\t    reg, oct->pcie_port, oct->pf_num,\n\t\t    (u64)octeon_read_csr64(oct, reg));\n\n\t \n\treg = CN23XX_SLI_MAC_PF_INT_SUM64(oct->pcie_port, oct->pf_num);\n\tlen +=\n\t    sprintf(s + len, \"\\n[%08x] (SLI_MAC%d_PF%d_INT_SUM): %016llx\\n\",\n\t\t    reg, oct->pcie_port, oct->pf_num,\n\t\t    (u64)octeon_read_csr64(oct, reg));\n\n\t \n\treg = 0x29120;\n\tlen += sprintf(s + len, \"\\n[%08x] (SLI_PKT_MEM_CTL): %016llx\\n\", reg,\n\t\t       (u64)octeon_read_csr64(oct, reg));\n\n\t \n\treg = 0x27300 + oct->pcie_port * CN23XX_MAC_INT_OFFSET +\n\t      (oct->pf_num) * CN23XX_PF_INT_OFFSET;\n\tlen += sprintf(\n\t    s + len, \"\\n[%08x] (SLI_MAC%d_PF%d_PKT_VF_INT): %016llx\\n\", reg,\n\t    oct->pcie_port, oct->pf_num, (u64)octeon_read_csr64(oct, reg));\n\n\t \n\treg = 0x27200 + oct->pcie_port * CN23XX_MAC_INT_OFFSET +\n\t      (oct->pf_num) * CN23XX_PF_INT_OFFSET;\n\tlen += sprintf(s + len,\n\t\t       \"\\n[%08x] (SLI_MAC%d_PF%d_PP_VF_INT): %016llx\\n\",\n\t\t       reg, oct->pcie_port, oct->pf_num,\n\t\t       (u64)octeon_read_csr64(oct, reg));\n\n\t \n\treg = CN23XX_SLI_PKT_CNT_INT;\n\tlen += sprintf(s + len, \"\\n[%08x] (SLI_PKT_CNT_INT): %016llx\\n\", reg,\n\t\t       (u64)octeon_read_csr64(oct, reg));\n\n\t \n\treg = CN23XX_SLI_PKT_TIME_INT;\n\tlen += sprintf(s + len, \"\\n[%08x] (SLI_PKT_TIME_INT): %016llx\\n\", reg,\n\t\t       (u64)octeon_read_csr64(oct, reg));\n\n\t \n\treg = 0x29160;\n\tlen += sprintf(s + len, \"\\n[%08x] (SLI_PKT_INT): %016llx\\n\", reg,\n\t\t       (u64)octeon_read_csr64(oct, reg));\n\n\t \n\treg = CN23XX_SLI_OQ_WMARK;\n\tlen += sprintf(s + len, \"\\n[%08x] (SLI_PKT_OUTPUT_WMARK): %016llx\\n\",\n\t\t       reg, (u64)octeon_read_csr64(oct, reg));\n\n\t \n\treg = CN23XX_SLI_PKT_IOQ_RING_RST;\n\tlen += sprintf(s + len, \"\\n[%08x] (SLI_PKT_RING_RST): %016llx\\n\", reg,\n\t\t       (u64)octeon_read_csr64(oct, reg));\n\n\t \n\treg = CN23XX_SLI_GBL_CONTROL;\n\tlen += sprintf(s + len,\n\t\t       \"\\n[%08x] (SLI_PKT_GBL_CONTROL): %016llx\\n\", reg,\n\t\t       (u64)octeon_read_csr64(oct, reg));\n\n\t \n\treg = 0x29220;\n\tlen += sprintf(s + len, \"\\n[%08x] (SLI_PKT_BIST_STATUS): %016llx\\n\",\n\t\t       reg, (u64)octeon_read_csr64(oct, reg));\n\n\t \n\tif (pf_num == 0) {\n\t\t \n\t\treg = CN23XX_SLI_OUT_BP_EN_W1S;\n\t\tlen += sprintf(s + len,\n\t\t\t       \"\\n[%08x] (SLI_PKT_OUT_BP_EN_W1S):  %016llx\\n\",\n\t\t\t       reg, (u64)octeon_read_csr64(oct, reg));\n\t} else if (pf_num == 1) {\n\t\t \n\t\treg = CN23XX_SLI_OUT_BP_EN2_W1S;\n\t\tlen += sprintf(s + len,\n\t\t\t       \"\\n[%08x] (SLI_PKT_OUT_BP_EN2_W1S): %016llx\\n\",\n\t\t\t       reg, (u64)octeon_read_csr64(oct, reg));\n\t}\n\n\tfor (i = 0; i < CN23XX_MAX_OUTPUT_QUEUES; i++) {\n\t\treg = CN23XX_SLI_OQ_BUFF_INFO_SIZE(i);\n\t\tlen +=\n\t\t    sprintf(s + len, \"\\n[%08x] (SLI_PKT%d_OUT_SIZE): %016llx\\n\",\n\t\t\t    reg, i, (u64)octeon_read_csr64(oct, reg));\n\t}\n\n\t \n\tfor (i = 0; i < CN23XX_MAX_INPUT_QUEUES; i++) {\n\t\treg = CN23XX_SLI_IQ_INSTR_COUNT64(i);\n\t\tlen += sprintf(s + len,\n\t\t\t       \"\\n[%08x] (SLI_PKT_IN_DONE%d_CNTS): %016llx\\n\",\n\t\t\t       reg, i, (u64)octeon_read_csr64(oct, reg));\n\t}\n\n\t \n\tfor (i = 0; i < CN23XX_MAX_OUTPUT_QUEUES; i++) {\n\t\treg = CN23XX_SLI_OQ_PKTS_CREDIT(i);\n\t\tlen += sprintf(s + len,\n\t\t\t       \"\\n[%08x] (SLI_PKT%d_SLIST_BAOFF_DBELL): %016llx\\n\",\n\t\t\t       reg, i, (u64)octeon_read_csr64(oct, reg));\n\t}\n\n\t \n\tfor (i = 0; i < CN23XX_MAX_OUTPUT_QUEUES; i++) {\n\t\treg = CN23XX_SLI_OQ_SIZE(i);\n\t\tlen += sprintf(\n\t\t    s + len, \"\\n[%08x] (SLI_PKT%d_SLIST_FIFO_RSIZE): %016llx\\n\",\n\t\t    reg, i, (u64)octeon_read_csr64(oct, reg));\n\t}\n\n\t \n\tfor (i = 0; i < CN23XX_MAX_OUTPUT_QUEUES; i++) {\n\t\treg = CN23XX_SLI_OQ_PKT_CONTROL(i);\n\t\tlen += sprintf(\n\t\t\ts + len,\n\t\t\t\"\\n[%08x] (SLI_PKT%d__OUTPUT_CONTROL): %016llx\\n\",\n\t\t\treg, i, (u64)octeon_read_csr64(oct, reg));\n\t}\n\n\t \n\tfor (i = 0; i < CN23XX_MAX_OUTPUT_QUEUES; i++) {\n\t\treg = CN23XX_SLI_OQ_BASE_ADDR64(i);\n\t\tlen += sprintf(s + len,\n\t\t\t       \"\\n[%08x] (SLI_PKT%d_SLIST_BADDR): %016llx\\n\",\n\t\t\t       reg, i, (u64)octeon_read_csr64(oct, reg));\n\t}\n\n\t \n\tfor (i = 0; i < CN23XX_MAX_OUTPUT_QUEUES; i++) {\n\t\treg = CN23XX_SLI_OQ_PKT_INT_LEVELS(i);\n\t\tlen += sprintf(s + len,\n\t\t\t       \"\\n[%08x] (SLI_PKT%d_INT_LEVELS): %016llx\\n\",\n\t\t\t       reg, i, (u64)octeon_read_csr64(oct, reg));\n\t}\n\n\t \n\tfor (i = 0; i < CN23XX_MAX_OUTPUT_QUEUES; i++) {\n\t\treg = CN23XX_SLI_OQ_PKTS_SENT(i);\n\t\tlen += sprintf(s + len, \"\\n[%08x] (SLI_PKT%d_CNTS): %016llx\\n\",\n\t\t\t       reg, i, (u64)octeon_read_csr64(oct, reg));\n\t}\n\n\t \n\tfor (i = 0; i < CN23XX_MAX_OUTPUT_QUEUES; i++) {\n\t\treg = 0x100c0 + i * CN23XX_OQ_OFFSET;\n\t\tlen += sprintf(s + len,\n\t\t\t       \"\\n[%08x] (SLI_PKT%d_ERROR_INFO): %016llx\\n\",\n\t\t\t       reg, i, (u64)octeon_read_csr64(oct, reg));\n\n\t\t \n\t\tfor (i = 0; i < CN23XX_MAX_INPUT_QUEUES; i++) {\n\t\t\treg = CN23XX_SLI_IQ_PKT_CONTROL64(i);\n\t\t\tlen += sprintf(\n\t\t\t\ts + len,\n\t\t\t\t\"\\n[%08x] (SLI_PKT%d_INPUT_CONTROL): %016llx\\n\",\n\t\t\t\treg, i, (u64)octeon_read_csr64(oct, reg));\n\t\t}\n\n\t\t \n\t\tfor (i = 0; i < CN23XX_MAX_INPUT_QUEUES; i++) {\n\t\t\treg = CN23XX_SLI_IQ_BASE_ADDR64(i);\n\t\t\tlen += sprintf(\n\t\t\t    s + len,\n\t\t\t    \"\\n[%08x] (SLI_PKT%d_INSTR_BADDR): %016llx\\n\", reg,\n\t\t\t    i, (u64)octeon_read_csr64(oct, reg));\n\t\t}\n\n\t\t \n\t\tfor (i = 0; i < CN23XX_MAX_INPUT_QUEUES; i++) {\n\t\t\treg = CN23XX_SLI_IQ_DOORBELL(i);\n\t\t\tlen += sprintf(\n\t\t\t    s + len,\n\t\t\t    \"\\n[%08x] (SLI_PKT%d_INSTR_BAOFF_DBELL): %016llx\\n\",\n\t\t\t    reg, i, (u64)octeon_read_csr64(oct, reg));\n\t\t}\n\n\t\t \n\t\tfor (i = 0; i < CN23XX_MAX_INPUT_QUEUES; i++) {\n\t\t\treg = CN23XX_SLI_IQ_SIZE(i);\n\t\t\tlen += sprintf(\n\t\t\t    s + len,\n\t\t\t    \"\\n[%08x] (SLI_PKT%d_INSTR_FIFO_RSIZE): %016llx\\n\",\n\t\t\t    reg, i, (u64)octeon_read_csr64(oct, reg));\n\t\t}\n\n\t\t \n\t\tfor (i = 0; i < CN23XX_MAX_INPUT_QUEUES; i++)\n\t\t\treg = CN23XX_SLI_IQ_INSTR_COUNT64(i);\n\t\tlen += sprintf(s + len,\n\t\t\t       \"\\n[%08x] (SLI_PKT_IN_DONE%d_CNTS): %016llx\\n\",\n\t\t\t       reg, i, (u64)octeon_read_csr64(oct, reg));\n\t}\n\n\treturn len;\n}\n\nstatic int cn23xx_vf_read_csr_reg(char *s, struct octeon_device *oct)\n{\n\tint len = 0;\n\tu32 reg;\n\tint i;\n\n\t \n\n\tlen += sprintf(s + len, \"\\n\\t Octeon CSR Registers\\n\\n\");\n\n\tfor (i = 0; i < (oct->sriov_info.rings_per_vf); i++) {\n\t\treg = CN23XX_VF_SLI_OQ_BUFF_INFO_SIZE(i);\n\t\tlen += sprintf(s + len,\n\t\t\t       \"\\n[%08x] (SLI_PKT%d_OUT_SIZE): %016llx\\n\",\n\t\t\t       reg, i, (u64)octeon_read_csr64(oct, reg));\n\t}\n\n\tfor (i = 0; i < (oct->sriov_info.rings_per_vf); i++) {\n\t\treg = CN23XX_VF_SLI_IQ_INSTR_COUNT64(i);\n\t\tlen += sprintf(s + len,\n\t\t\t       \"\\n[%08x] (SLI_PKT_IN_DONE%d_CNTS): %016llx\\n\",\n\t\t\t       reg, i, (u64)octeon_read_csr64(oct, reg));\n\t}\n\n\tfor (i = 0; i < (oct->sriov_info.rings_per_vf); i++) {\n\t\treg = CN23XX_VF_SLI_OQ_PKTS_CREDIT(i);\n\t\tlen += sprintf(s + len,\n\t\t\t       \"\\n[%08x] (SLI_PKT%d_SLIST_BAOFF_DBELL): %016llx\\n\",\n\t\t\t       reg, i, (u64)octeon_read_csr64(oct, reg));\n\t}\n\n\tfor (i = 0; i < (oct->sriov_info.rings_per_vf); i++) {\n\t\treg = CN23XX_VF_SLI_OQ_SIZE(i);\n\t\tlen += sprintf(s + len,\n\t\t\t       \"\\n[%08x] (SLI_PKT%d_SLIST_FIFO_RSIZE): %016llx\\n\",\n\t\t\t       reg, i, (u64)octeon_read_csr64(oct, reg));\n\t}\n\n\tfor (i = 0; i < (oct->sriov_info.rings_per_vf); i++) {\n\t\treg = CN23XX_VF_SLI_OQ_PKT_CONTROL(i);\n\t\tlen += sprintf(s + len,\n\t\t\t       \"\\n[%08x] (SLI_PKT%d__OUTPUT_CONTROL): %016llx\\n\",\n\t\t\t       reg, i, (u64)octeon_read_csr64(oct, reg));\n\t}\n\n\tfor (i = 0; i < (oct->sriov_info.rings_per_vf); i++) {\n\t\treg = CN23XX_VF_SLI_OQ_BASE_ADDR64(i);\n\t\tlen += sprintf(s + len,\n\t\t\t       \"\\n[%08x] (SLI_PKT%d_SLIST_BADDR): %016llx\\n\",\n\t\t\t       reg, i, (u64)octeon_read_csr64(oct, reg));\n\t}\n\n\tfor (i = 0; i < (oct->sriov_info.rings_per_vf); i++) {\n\t\treg = CN23XX_VF_SLI_OQ_PKT_INT_LEVELS(i);\n\t\tlen += sprintf(s + len,\n\t\t\t       \"\\n[%08x] (SLI_PKT%d_INT_LEVELS): %016llx\\n\",\n\t\t\t       reg, i, (u64)octeon_read_csr64(oct, reg));\n\t}\n\n\tfor (i = 0; i < (oct->sriov_info.rings_per_vf); i++) {\n\t\treg = CN23XX_VF_SLI_OQ_PKTS_SENT(i);\n\t\tlen += sprintf(s + len, \"\\n[%08x] (SLI_PKT%d_CNTS): %016llx\\n\",\n\t\t\t       reg, i, (u64)octeon_read_csr64(oct, reg));\n\t}\n\n\tfor (i = 0; i < (oct->sriov_info.rings_per_vf); i++) {\n\t\treg = 0x100c0 + i * CN23XX_VF_OQ_OFFSET;\n\t\tlen += sprintf(s + len,\n\t\t\t       \"\\n[%08x] (SLI_PKT%d_ERROR_INFO): %016llx\\n\",\n\t\t\t       reg, i, (u64)octeon_read_csr64(oct, reg));\n\t}\n\n\tfor (i = 0; i < (oct->sriov_info.rings_per_vf); i++) {\n\t\treg = 0x100d0 + i * CN23XX_VF_IQ_OFFSET;\n\t\tlen += sprintf(s + len,\n\t\t\t       \"\\n[%08x] (SLI_PKT%d_VF_INT_SUM): %016llx\\n\",\n\t\t\t       reg, i, (u64)octeon_read_csr64(oct, reg));\n\t}\n\n\tfor (i = 0; i < (oct->sriov_info.rings_per_vf); i++) {\n\t\treg = CN23XX_VF_SLI_IQ_PKT_CONTROL64(i);\n\t\tlen += sprintf(s + len,\n\t\t\t       \"\\n[%08x] (SLI_PKT%d_INPUT_CONTROL): %016llx\\n\",\n\t\t\t       reg, i, (u64)octeon_read_csr64(oct, reg));\n\t}\n\n\tfor (i = 0; i < (oct->sriov_info.rings_per_vf); i++) {\n\t\treg = CN23XX_VF_SLI_IQ_BASE_ADDR64(i);\n\t\tlen += sprintf(s + len,\n\t\t\t       \"\\n[%08x] (SLI_PKT%d_INSTR_BADDR): %016llx\\n\",\n\t\t\t       reg, i, (u64)octeon_read_csr64(oct, reg));\n\t}\n\n\tfor (i = 0; i < (oct->sriov_info.rings_per_vf); i++) {\n\t\treg = CN23XX_VF_SLI_IQ_DOORBELL(i);\n\t\tlen += sprintf(s + len,\n\t\t\t       \"\\n[%08x] (SLI_PKT%d_INSTR_BAOFF_DBELL): %016llx\\n\",\n\t\t\t       reg, i, (u64)octeon_read_csr64(oct, reg));\n\t}\n\n\tfor (i = 0; i < (oct->sriov_info.rings_per_vf); i++) {\n\t\treg = CN23XX_VF_SLI_IQ_SIZE(i);\n\t\tlen += sprintf(s + len,\n\t\t\t       \"\\n[%08x] (SLI_PKT%d_INSTR_FIFO_RSIZE): %016llx\\n\",\n\t\t\t       reg, i, (u64)octeon_read_csr64(oct, reg));\n\t}\n\n\tfor (i = 0; i < (oct->sriov_info.rings_per_vf); i++) {\n\t\treg = CN23XX_VF_SLI_IQ_INSTR_COUNT64(i);\n\t\tlen += sprintf(s + len,\n\t\t\t       \"\\n[%08x] (SLI_PKT_IN_DONE%d_CNTS): %016llx\\n\",\n\t\t\t       reg, i, (u64)octeon_read_csr64(oct, reg));\n\t}\n\n\treturn len;\n}\n\nstatic int cn6xxx_read_csr_reg(char *s, struct octeon_device *oct)\n{\n\tu32 reg;\n\tint i, len = 0;\n\n\t \n\n\tlen += sprintf(s + len, \"\\n\\t Octeon CSR Registers\\n\\n\");\n\treg = CN6XXX_WIN_WR_ADDR_LO;\n\tlen += sprintf(s + len, \"\\n[%02x] (WIN_WR_ADDR_LO): %08x\\n\",\n\t\t       CN6XXX_WIN_WR_ADDR_LO, octeon_read_csr(oct, reg));\n\treg = CN6XXX_WIN_WR_ADDR_HI;\n\tlen += sprintf(s + len, \"[%02x] (WIN_WR_ADDR_HI): %08x\\n\",\n\t\t       CN6XXX_WIN_WR_ADDR_HI, octeon_read_csr(oct, reg));\n\treg = CN6XXX_WIN_RD_ADDR_LO;\n\tlen += sprintf(s + len, \"[%02x] (WIN_RD_ADDR_LO): %08x\\n\",\n\t\t       CN6XXX_WIN_RD_ADDR_LO, octeon_read_csr(oct, reg));\n\treg = CN6XXX_WIN_RD_ADDR_HI;\n\tlen += sprintf(s + len, \"[%02x] (WIN_RD_ADDR_HI): %08x\\n\",\n\t\t       CN6XXX_WIN_RD_ADDR_HI, octeon_read_csr(oct, reg));\n\treg = CN6XXX_WIN_WR_DATA_LO;\n\tlen += sprintf(s + len, \"[%02x] (WIN_WR_DATA_LO): %08x\\n\",\n\t\t       CN6XXX_WIN_WR_DATA_LO, octeon_read_csr(oct, reg));\n\treg = CN6XXX_WIN_WR_DATA_HI;\n\tlen += sprintf(s + len, \"[%02x] (WIN_WR_DATA_HI): %08x\\n\",\n\t\t       CN6XXX_WIN_WR_DATA_HI, octeon_read_csr(oct, reg));\n\tlen += sprintf(s + len, \"[%02x] (WIN_WR_MASK_REG): %08x\\n\",\n\t\t       CN6XXX_WIN_WR_MASK_REG,\n\t\t       octeon_read_csr(oct, CN6XXX_WIN_WR_MASK_REG));\n\n\t \n\tlen += sprintf(s + len, \"\\n[%x] (INT_ENABLE PORT 0): %08x\\n\",\n\t\t       CN6XXX_SLI_INT_ENB64_PORT0, octeon_read_csr(oct,\n\t\t\t\t\t\tCN6XXX_SLI_INT_ENB64_PORT0));\n\tlen += sprintf(s + len, \"\\n[%x] (INT_ENABLE PORT 1): %08x\\n\",\n\t\t       CN6XXX_SLI_INT_ENB64_PORT1,\n\t\t       octeon_read_csr(oct, CN6XXX_SLI_INT_ENB64_PORT1));\n\tlen += sprintf(s + len, \"[%x] (INT_SUM): %08x\\n\", CN6XXX_SLI_INT_SUM64,\n\t\t       octeon_read_csr(oct, CN6XXX_SLI_INT_SUM64));\n\n\t \n\tfor (i = 0; i < oct->num_oqs; i++) {\n\t\treg = CN6XXX_SLI_OQ_PKTS_SENT(i);\n\t\tlen += sprintf(s + len, \"\\n[%x] (PKTS_SENT_%d): %08x\\n\",\n\t\t\t       reg, i, octeon_read_csr(oct, reg));\n\t\treg = CN6XXX_SLI_OQ_PKTS_CREDIT(i);\n\t\tlen += sprintf(s + len, \"[%x] (PKT_CREDITS_%d): %08x\\n\",\n\t\t\t       reg, i, octeon_read_csr(oct, reg));\n\t}\n\treg = CN6XXX_SLI_OQ_INT_LEVEL_PKTS;\n\tlen += sprintf(s + len, \"\\n[%x] (PKTS_SENT_INT_LEVEL): %08x\\n\",\n\t\t       reg, octeon_read_csr(oct, reg));\n\treg = CN6XXX_SLI_OQ_INT_LEVEL_TIME;\n\tlen += sprintf(s + len, \"[%x] (PKTS_SENT_TIME): %08x\\n\",\n\t\t       reg, octeon_read_csr(oct, reg));\n\n\t \n\tfor (i = 0; i <= 3; i++) {\n\t\tu32 reg;\n\n\t\treg = CN6XXX_SLI_IQ_DOORBELL(i);\n\t\tlen += sprintf(s + len, \"\\n[%x] (INSTR_DOORBELL_%d): %08x\\n\",\n\t\t\t       reg, i, octeon_read_csr(oct, reg));\n\t\treg = CN6XXX_SLI_IQ_INSTR_COUNT(i);\n\t\tlen += sprintf(s + len, \"[%x] (INSTR_COUNT_%d): %08x\\n\",\n\t\t\t       reg, i, octeon_read_csr(oct, reg));\n\t}\n\n\t \n\n\tlen += sprintf(s + len, \"\\n[%x] (DMA_CNT_0): %08x\\n\",\n\t\t       CN6XXX_DMA_CNT(0),\n\t\t       octeon_read_csr(oct, CN6XXX_DMA_CNT(0)));\n\treg = CN6XXX_DMA_PKT_INT_LEVEL(0);\n\tlen += sprintf(s + len, \"[%x] (DMA_INT_LEV_0): %08x\\n\",\n\t\t       CN6XXX_DMA_PKT_INT_LEVEL(0), octeon_read_csr(oct, reg));\n\treg = CN6XXX_DMA_TIME_INT_LEVEL(0);\n\tlen += sprintf(s + len, \"[%x] (DMA_TIME_0): %08x\\n\",\n\t\t       CN6XXX_DMA_TIME_INT_LEVEL(0),\n\t\t       octeon_read_csr(oct, reg));\n\n\tlen += sprintf(s + len, \"\\n[%x] (DMA_CNT_1): %08x\\n\",\n\t\t       CN6XXX_DMA_CNT(1),\n\t\t       octeon_read_csr(oct, CN6XXX_DMA_CNT(1)));\n\treg = CN6XXX_DMA_PKT_INT_LEVEL(1);\n\tlen += sprintf(s + len, \"[%x] (DMA_INT_LEV_1): %08x\\n\",\n\t\t       CN6XXX_DMA_PKT_INT_LEVEL(1),\n\t\t       octeon_read_csr(oct, reg));\n\treg = CN6XXX_DMA_PKT_INT_LEVEL(1);\n\tlen += sprintf(s + len, \"[%x] (DMA_TIME_1): %08x\\n\",\n\t\t       CN6XXX_DMA_TIME_INT_LEVEL(1),\n\t\t       octeon_read_csr(oct, reg));\n\n\t \n\n\tlen += sprintf(s + len, \"\\n\");\n\n\tfor (i = 0; i < 16; i++) {\n\t\treg = lio_pci_readq(oct, CN6XXX_BAR1_REG(i, oct->pcie_port));\n\t\tlen += sprintf(s + len, \"[%llx] (BAR1_INDEX_%02d): %08x\\n\",\n\t\t\t       CN6XXX_BAR1_REG(i, oct->pcie_port), i, reg);\n\t}\n\n\treturn len;\n}\n\nstatic int cn6xxx_read_config_reg(char *s, struct octeon_device *oct)\n{\n\tu32 val;\n\tint i, len = 0;\n\n\t \n\n\tlen += sprintf(s + len,\n\t\t       \"\\n\\t Octeon Config space Registers\\n\\n\");\n\n\tfor (i = 0; i <= 13; i++) {\n\t\tpci_read_config_dword(oct->pci_dev, (i * 4), &val);\n\t\tlen += sprintf(s + len, \"[0x%x] (Config[%d]): 0x%08x\\n\",\n\t\t\t       (i * 4), i, val);\n\t}\n\n\tfor (i = 30; i <= 34; i++) {\n\t\tpci_read_config_dword(oct->pci_dev, (i * 4), &val);\n\t\tlen += sprintf(s + len, \"[0x%x] (Config[%d]): 0x%08x\\n\",\n\t\t\t       (i * 4), i, val);\n\t}\n\n\treturn len;\n}\n\n \nstatic void lio_get_regs(struct net_device *dev,\n\t\t\t struct ethtool_regs *regs, void *regbuf)\n{\n\tstruct lio *lio = GET_LIO(dev);\n\tint len = 0;\n\tstruct octeon_device *oct = lio->oct_dev;\n\n\tregs->version = OCT_ETHTOOL_REGSVER;\n\n\tswitch (oct->chip_id) {\n\tcase OCTEON_CN23XX_PF_VID:\n\t\tmemset(regbuf, 0, OCT_ETHTOOL_REGDUMP_LEN_23XX);\n\t\tlen += cn23xx_read_csr_reg(regbuf + len, oct);\n\t\tbreak;\n\tcase OCTEON_CN23XX_VF_VID:\n\t\tmemset(regbuf, 0, OCT_ETHTOOL_REGDUMP_LEN_23XX_VF);\n\t\tlen += cn23xx_vf_read_csr_reg(regbuf + len, oct);\n\t\tbreak;\n\tcase OCTEON_CN68XX:\n\tcase OCTEON_CN66XX:\n\t\tmemset(regbuf, 0, OCT_ETHTOOL_REGDUMP_LEN);\n\t\tlen += cn6xxx_read_csr_reg(regbuf + len, oct);\n\t\tlen += cn6xxx_read_config_reg(regbuf + len, oct);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&oct->pci_dev->dev, \"%s Unknown chipid: %d\\n\",\n\t\t\t__func__, oct->chip_id);\n\t}\n}\n\nstatic u32 lio_get_priv_flags(struct net_device *netdev)\n{\n\tstruct lio *lio = GET_LIO(netdev);\n\n\treturn lio->oct_dev->priv_flags;\n}\n\nstatic int lio_set_priv_flags(struct net_device *netdev, u32 flags)\n{\n\tstruct lio *lio = GET_LIO(netdev);\n\tbool intr_by_tx_bytes = !!(flags & (0x1 << OCT_PRIV_FLAG_TX_BYTES));\n\n\tlio_set_priv_flag(lio->oct_dev, OCT_PRIV_FLAG_TX_BYTES,\n\t\t\t  intr_by_tx_bytes);\n\treturn 0;\n}\n\nstatic int lio_get_fecparam(struct net_device *netdev,\n\t\t\t    struct ethtool_fecparam *fec)\n{\n\tstruct lio *lio = GET_LIO(netdev);\n\tstruct octeon_device *oct = lio->oct_dev;\n\n\tfec->active_fec = ETHTOOL_FEC_NONE;\n\tfec->fec = ETHTOOL_FEC_NONE;\n\n\tif (oct->subsystem_id == OCTEON_CN2350_25GB_SUBSYS_ID ||\n\t    oct->subsystem_id == OCTEON_CN2360_25GB_SUBSYS_ID) {\n\t\tif (oct->no_speed_setting == 1)\n\t\t\treturn 0;\n\n\t\tliquidio_get_fec(lio);\n\t\tfec->fec = (ETHTOOL_FEC_RS | ETHTOOL_FEC_OFF);\n\t\tif (oct->props[lio->ifidx].fec == 1)\n\t\t\tfec->active_fec = ETHTOOL_FEC_RS;\n\t\telse\n\t\t\tfec->active_fec = ETHTOOL_FEC_OFF;\n\t}\n\n\treturn 0;\n}\n\nstatic int lio_set_fecparam(struct net_device *netdev,\n\t\t\t    struct ethtool_fecparam *fec)\n{\n\tstruct lio *lio = GET_LIO(netdev);\n\tstruct octeon_device *oct = lio->oct_dev;\n\n\tif (oct->subsystem_id == OCTEON_CN2350_25GB_SUBSYS_ID ||\n\t    oct->subsystem_id == OCTEON_CN2360_25GB_SUBSYS_ID) {\n\t\tif (oct->no_speed_setting == 1)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tif (fec->fec & ETHTOOL_FEC_OFF)\n\t\t\tliquidio_set_fec(lio, 0);\n\t\telse if (fec->fec & ETHTOOL_FEC_RS)\n\t\t\tliquidio_set_fec(lio, 1);\n\t\telse\n\t\t\treturn -EOPNOTSUPP;\n\t} else {\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\n#define LIO_ETHTOOL_COALESCE\t(ETHTOOL_COALESCE_RX_USECS |\t\t\\\n\t\t\t\t ETHTOOL_COALESCE_MAX_FRAMES |\t\t\\\n\t\t\t\t ETHTOOL_COALESCE_USE_ADAPTIVE |\t\\\n\t\t\t\t ETHTOOL_COALESCE_RX_MAX_FRAMES_LOW |\t\\\n\t\t\t\t ETHTOOL_COALESCE_TX_MAX_FRAMES_LOW |\t\\\n\t\t\t\t ETHTOOL_COALESCE_RX_MAX_FRAMES_HIGH |\t\\\n\t\t\t\t ETHTOOL_COALESCE_TX_MAX_FRAMES_HIGH |\t\\\n\t\t\t\t ETHTOOL_COALESCE_PKT_RATE_RX_USECS)\n\nstatic const struct ethtool_ops lio_ethtool_ops = {\n\t.supported_coalesce_params = LIO_ETHTOOL_COALESCE,\n\t.get_link_ksettings\t= lio_get_link_ksettings,\n\t.set_link_ksettings\t= lio_set_link_ksettings,\n\t.get_fecparam\t\t= lio_get_fecparam,\n\t.set_fecparam\t\t= lio_set_fecparam,\n\t.get_link\t\t= ethtool_op_get_link,\n\t.get_drvinfo\t\t= lio_get_drvinfo,\n\t.get_ringparam\t\t= lio_ethtool_get_ringparam,\n\t.set_ringparam\t\t= lio_ethtool_set_ringparam,\n\t.get_channels\t\t= lio_ethtool_get_channels,\n\t.set_channels\t\t= lio_ethtool_set_channels,\n\t.set_phys_id\t\t= lio_set_phys_id,\n\t.get_eeprom_len\t\t= lio_get_eeprom_len,\n\t.get_eeprom\t\t= lio_get_eeprom,\n\t.get_strings\t\t= lio_get_strings,\n\t.get_ethtool_stats\t= lio_get_ethtool_stats,\n\t.get_pauseparam\t\t= lio_get_pauseparam,\n\t.set_pauseparam\t\t= lio_set_pauseparam,\n\t.get_regs_len\t\t= lio_get_regs_len,\n\t.get_regs\t\t= lio_get_regs,\n\t.get_msglevel\t\t= lio_get_msglevel,\n\t.set_msglevel\t\t= lio_set_msglevel,\n\t.get_sset_count\t\t= lio_get_sset_count,\n\t.get_coalesce\t\t= lio_get_intr_coalesce,\n\t.set_coalesce\t\t= lio_set_intr_coalesce,\n\t.get_priv_flags\t\t= lio_get_priv_flags,\n\t.set_priv_flags\t\t= lio_set_priv_flags,\n\t.get_ts_info\t\t= lio_get_ts_info,\n};\n\nstatic const struct ethtool_ops lio_vf_ethtool_ops = {\n\t.supported_coalesce_params = LIO_ETHTOOL_COALESCE,\n\t.get_link_ksettings\t= lio_get_link_ksettings,\n\t.get_link\t\t= ethtool_op_get_link,\n\t.get_drvinfo\t\t= lio_get_vf_drvinfo,\n\t.get_ringparam\t\t= lio_ethtool_get_ringparam,\n\t.set_ringparam          = lio_ethtool_set_ringparam,\n\t.get_channels\t\t= lio_ethtool_get_channels,\n\t.set_channels\t\t= lio_ethtool_set_channels,\n\t.get_strings\t\t= lio_vf_get_strings,\n\t.get_ethtool_stats\t= lio_vf_get_ethtool_stats,\n\t.get_regs_len\t\t= lio_get_regs_len,\n\t.get_regs\t\t= lio_get_regs,\n\t.get_msglevel\t\t= lio_get_msglevel,\n\t.set_msglevel\t\t= lio_vf_set_msglevel,\n\t.get_sset_count\t\t= lio_vf_get_sset_count,\n\t.get_coalesce\t\t= lio_get_intr_coalesce,\n\t.set_coalesce\t\t= lio_set_intr_coalesce,\n\t.get_priv_flags\t\t= lio_get_priv_flags,\n\t.set_priv_flags\t\t= lio_set_priv_flags,\n\t.get_ts_info\t\t= lio_get_ts_info,\n};\n\nvoid liquidio_set_ethtool_ops(struct net_device *netdev)\n{\n\tstruct lio *lio = GET_LIO(netdev);\n\tstruct octeon_device *oct = lio->oct_dev;\n\n\tif (OCTEON_CN23XX_VF(oct))\n\t\tnetdev->ethtool_ops = &lio_vf_ethtool_ops;\n\telse\n\t\tnetdev->ethtool_ops = &lio_ethtool_ops;\n}\nEXPORT_SYMBOL_GPL(liquidio_set_ethtool_ops);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}