{
  "module_name": "octeon_nic.h",
  "hash_id": "e47a46c61dc241f54d230ed1b1c3fe70dac0ac10e1192d1a231e6389297f554a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/cavium/liquidio/octeon_nic.h",
  "human_readable_source": " \n\n \n\n#ifndef __OCTEON_NIC_H__\n#define  __OCTEON_NIC_H__\n\n \n#define  MAX_NCTRL_UDD  32\n\ntypedef void (*octnic_ctrl_pkt_cb_fn_t) (void *);\n\n \nstruct octnic_ctrl_pkt {\n\t \n\tunion octnet_cmd ncmd;\n\n\t \n\tvoid *data;\n\tu64 dmadata;\n\n\t \n\tvoid *rdata;\n\tu64 dmardata;\n\n\t \n\tu64 udd[MAX_NCTRL_UDD];\n\n\t \n\tu64 iq_no;\n\n\t \n\tu64 netpndev;\n\n\t \n\toctnic_ctrl_pkt_cb_fn_t cb_fn;\n\n\tu32 sc_status;\n};\n\n#define MAX_UDD_SIZE(nctrl) (sizeof((nctrl)->udd))\n\n \nstruct octnic_data_pkt {\n\t \n\tvoid *buf;\n\n\t \n\tu32 reqtype;\n\n\t \n\tu32 datasize;\n\n\t \n\tunion octeon_instr_64B cmd;\n\n\t \n\tu32 q_no;\n\n};\n\n \nunion octnic_cmd_setup {\n\tstruct {\n\t\tu32 iq_no:8;\n\t\tu32 gather:1;\n\t\tu32 timestamp:1;\n\t\tu32 ip_csum:1;\n\t\tu32 transport_csum:1;\n\t\tu32 tnl_csum:1;\n\t\tu32 rsvd:19;\n\n\t\tunion {\n\t\t\tu32 datasize;\n\t\t\tu32 gatherptrs;\n\t\t} u;\n\t} s;\n\n\tu64 u64;\n\n};\n\nstatic inline int octnet_iq_is_full(struct octeon_device *oct, u32 q_no)\n{\n\treturn ((u32)atomic_read(&oct->instr_queue[q_no]->instr_pending)\n\t\t>= (oct->instr_queue[q_no]->max_count - 2));\n}\n\nstatic inline void\noctnet_prepare_pci_cmd_o2(struct octeon_device *oct,\n\t\t\t  union octeon_instr_64B *cmd,\n\t\t\t  union octnic_cmd_setup *setup, u32 tag)\n{\n\tstruct octeon_instr_ih2 *ih2;\n\tstruct octeon_instr_irh *irh;\n\tunion octnic_packet_params packet_params;\n\tint port;\n\n\tmemset(cmd, 0, sizeof(union octeon_instr_64B));\n\n\tih2 = (struct octeon_instr_ih2 *)&cmd->cmd2.ih2;\n\n\t \n\tih2->fsz = LIO_PCICMD_O2;\n\n\tih2->tagtype = ORDERED_TAG;\n\tih2->grp = DEFAULT_POW_GRP;\n\n\tport = (int)oct->instr_queue[setup->s.iq_no]->txpciq.s.port;\n\n\tif (tag)\n\t\tih2->tag = tag;\n\telse\n\t\tih2->tag = LIO_DATA(port);\n\n\tih2->raw = 1;\n\tih2->qos = (port & 3) + 4;\t \n\n\tif (!setup->s.gather) {\n\t\tih2->dlengsz = setup->s.u.datasize;\n\t} else {\n\t\tih2->gather = 1;\n\t\tih2->dlengsz = setup->s.u.gatherptrs;\n\t}\n\n\tirh = (struct octeon_instr_irh *)&cmd->cmd2.irh;\n\n\tirh->opcode = OPCODE_NIC;\n\tirh->subcode = OPCODE_NIC_NW_DATA;\n\n\tpacket_params.u32 = 0;\n\n\tpacket_params.s.ip_csum = setup->s.ip_csum;\n\tpacket_params.s.transport_csum = setup->s.transport_csum;\n\tpacket_params.s.tnl_csum = setup->s.tnl_csum;\n\tpacket_params.s.tsflag = setup->s.timestamp;\n\n\tirh->ossp = packet_params.u32;\n}\n\nstatic inline void\noctnet_prepare_pci_cmd_o3(struct octeon_device *oct,\n\t\t\t  union octeon_instr_64B *cmd,\n\t\t\t  union octnic_cmd_setup *setup, u32 tag)\n{\n\tstruct octeon_instr_irh *irh;\n\tstruct octeon_instr_ih3     *ih3;\n\tstruct octeon_instr_pki_ih3 *pki_ih3;\n\tunion octnic_packet_params packet_params;\n\tint port;\n\n\tmemset(cmd, 0, sizeof(union octeon_instr_64B));\n\n\tih3 = (struct octeon_instr_ih3 *)&cmd->cmd3.ih3;\n\tpki_ih3 = (struct octeon_instr_pki_ih3 *)&cmd->cmd3.pki_ih3;\n\n\t \n\tih3->pkind       = oct->instr_queue[setup->s.iq_no]->txpciq.s.pkind;\n\t \n\tih3->fsz = LIO_PCICMD_O3;\n\n\tif (!setup->s.gather) {\n\t\tih3->dlengsz = setup->s.u.datasize;\n\t} else {\n\t\tih3->gather = 1;\n\t\tih3->dlengsz = setup->s.u.gatherptrs;\n\t}\n\n\tpki_ih3->w       = 1;\n\tpki_ih3->raw     = 1;\n\tpki_ih3->utag    = 1;\n\tpki_ih3->utt     = 1;\n\tpki_ih3->uqpg    = oct->instr_queue[setup->s.iq_no]->txpciq.s.use_qpg;\n\n\tport = (int)oct->instr_queue[setup->s.iq_no]->txpciq.s.port;\n\n\tif (tag)\n\t\tpki_ih3->tag = tag;\n\telse\n\t\tpki_ih3->tag     = LIO_DATA(port);\n\n\tpki_ih3->tagtype = ORDERED_TAG;\n\tpki_ih3->qpg     = oct->instr_queue[setup->s.iq_no]->txpciq.s.qpg;\n\tpki_ih3->pm      = 0x7;  \n\tpki_ih3->sl      = 8;    \n\n\tirh = (struct octeon_instr_irh *)&cmd->cmd3.irh;\n\n\tirh->opcode = OPCODE_NIC;\n\tirh->subcode = OPCODE_NIC_NW_DATA;\n\n\tpacket_params.u32 = 0;\n\n\tpacket_params.s.ip_csum = setup->s.ip_csum;\n\tpacket_params.s.transport_csum = setup->s.transport_csum;\n\tpacket_params.s.tnl_csum = setup->s.tnl_csum;\n\tpacket_params.s.tsflag = setup->s.timestamp;\n\n\tirh->ossp = packet_params.u32;\n}\n\n \nstatic inline void\noctnet_prepare_pci_cmd(struct octeon_device *oct, union octeon_instr_64B *cmd,\n\t\t       union octnic_cmd_setup *setup, u32 tag)\n{\n\tif (OCTEON_CN6XXX(oct))\n\t\toctnet_prepare_pci_cmd_o2(oct, cmd, setup, tag);\n\telse\n\t\toctnet_prepare_pci_cmd_o3(oct, cmd, setup, tag);\n}\n\n \nvoid *\nocteon_alloc_soft_command_resp(struct octeon_device    *oct,\n\t\t\t       union octeon_instr_64B *cmd,\n\t\t\t       u32\t\t       rdatasize);\n\n \nint octnet_send_nic_data_pkt(struct octeon_device *oct,\n\t\t\t     struct octnic_data_pkt *ndata,\n\t\t\t     int xmit_more);\n\n \nint\noctnet_send_nic_ctrl_pkt(struct octeon_device *oct,\n\t\t\t struct octnic_ctrl_pkt *nctrl);\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}