{
  "module_name": "cavium_ptp.c",
  "hash_id": "ad531d9a7f35ab8f3e3c60a04b464575a5ff1a3d586c85f4a3f7fac7c1589af0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/cavium/common/cavium_ptp.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/module.h>\n#include <linux/timecounter.h>\n#include <linux/pci.h>\n\n#include \"cavium_ptp.h\"\n\n#define DRV_NAME \"cavium_ptp\"\n\n#define PCI_DEVICE_ID_CAVIUM_PTP\t0xA00C\n#define PCI_SUBSYS_DEVID_88XX_PTP\t0xA10C\n#define PCI_SUBSYS_DEVID_81XX_PTP\t0XA20C\n#define PCI_SUBSYS_DEVID_83XX_PTP\t0xA30C\n#define PCI_DEVICE_ID_CAVIUM_RST\t0xA00E\n\n#define PCI_PTP_BAR_NO\t0\n#define PCI_RST_BAR_NO\t0\n\n#define PTP_CLOCK_CFG\t\t0xF00ULL\n#define  PTP_CLOCK_CFG_PTP_EN\tBIT(0)\n#define PTP_CLOCK_LO\t\t0xF08ULL\n#define PTP_CLOCK_HI\t\t0xF10ULL\n#define PTP_CLOCK_COMP\t\t0xF18ULL\n\n#define RST_BOOT\t0x1600ULL\n#define CLOCK_BASE_RATE\t50000000ULL\n\nstatic u64 ptp_cavium_clock_get(void)\n{\n\tstruct pci_dev *pdev;\n\tvoid __iomem *base;\n\tu64 ret = CLOCK_BASE_RATE * 16;\n\n\tpdev = pci_get_device(PCI_VENDOR_ID_CAVIUM,\n\t\t\t      PCI_DEVICE_ID_CAVIUM_RST, NULL);\n\tif (!pdev)\n\t\tgoto error;\n\n\tbase = pci_ioremap_bar(pdev, PCI_RST_BAR_NO);\n\tif (!base)\n\t\tgoto error_put_pdev;\n\n\tret = CLOCK_BASE_RATE * ((readq(base + RST_BOOT) >> 33) & 0x3f);\n\n\tiounmap(base);\n\nerror_put_pdev:\n\tpci_dev_put(pdev);\n\nerror:\n\treturn ret;\n}\n\nstruct cavium_ptp *cavium_ptp_get(void)\n{\n\tstruct cavium_ptp *ptp;\n\tstruct pci_dev *pdev;\n\n\tpdev = pci_get_device(PCI_VENDOR_ID_CAVIUM,\n\t\t\t      PCI_DEVICE_ID_CAVIUM_PTP, NULL);\n\tif (!pdev)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tptp = pci_get_drvdata(pdev);\n\tif (!ptp)\n\t\tptp = ERR_PTR(-EPROBE_DEFER);\n\tif (IS_ERR(ptp))\n\t\tpci_dev_put(pdev);\n\n\treturn ptp;\n}\nEXPORT_SYMBOL(cavium_ptp_get);\n\nvoid cavium_ptp_put(struct cavium_ptp *ptp)\n{\n\tif (!ptp)\n\t\treturn;\n\tpci_dev_put(ptp->pdev);\n}\nEXPORT_SYMBOL(cavium_ptp_put);\n\n \nstatic int cavium_ptp_adjfine(struct ptp_clock_info *ptp_info, long scaled_ppm)\n{\n\tstruct cavium_ptp *clock =\n\t\tcontainer_of(ptp_info, struct cavium_ptp, ptp_info);\n\tunsigned long flags;\n\tu64 comp;\n\tu64 adj;\n\tbool neg_adj = false;\n\n\tif (scaled_ppm < 0) {\n\t\tneg_adj = true;\n\t\tscaled_ppm = -scaled_ppm;\n\t}\n\n\t \n\tcomp = ((u64)1000000000ull << 32) / clock->clock_rate;\n\tadj = comp * scaled_ppm;\n\tadj >>= 16;\n\tadj = div_u64(adj, 1000000ull);\n\tcomp = neg_adj ? comp - adj : comp + adj;\n\n\tspin_lock_irqsave(&clock->spin_lock, flags);\n\twriteq(comp, clock->reg_base + PTP_CLOCK_COMP);\n\tspin_unlock_irqrestore(&clock->spin_lock, flags);\n\n\treturn 0;\n}\n\n \nstatic int cavium_ptp_adjtime(struct ptp_clock_info *ptp_info, s64 delta)\n{\n\tstruct cavium_ptp *clock =\n\t\tcontainer_of(ptp_info, struct cavium_ptp, ptp_info);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&clock->spin_lock, flags);\n\ttimecounter_adjtime(&clock->time_counter, delta);\n\tspin_unlock_irqrestore(&clock->spin_lock, flags);\n\n\t \n\tsmp_mb();\n\n\treturn 0;\n}\n\n \nstatic int cavium_ptp_gettime(struct ptp_clock_info *ptp_info,\n\t\t\t      struct timespec64 *ts)\n{\n\tstruct cavium_ptp *clock =\n\t\tcontainer_of(ptp_info, struct cavium_ptp, ptp_info);\n\tunsigned long flags;\n\tu64 nsec;\n\n\tspin_lock_irqsave(&clock->spin_lock, flags);\n\tnsec = timecounter_read(&clock->time_counter);\n\tspin_unlock_irqrestore(&clock->spin_lock, flags);\n\n\t*ts = ns_to_timespec64(nsec);\n\n\treturn 0;\n}\n\n \nstatic int cavium_ptp_settime(struct ptp_clock_info *ptp_info,\n\t\t\t      const struct timespec64 *ts)\n{\n\tstruct cavium_ptp *clock =\n\t\tcontainer_of(ptp_info, struct cavium_ptp, ptp_info);\n\tunsigned long flags;\n\tu64 nsec;\n\n\tnsec = timespec64_to_ns(ts);\n\n\tspin_lock_irqsave(&clock->spin_lock, flags);\n\ttimecounter_init(&clock->time_counter, &clock->cycle_counter, nsec);\n\tspin_unlock_irqrestore(&clock->spin_lock, flags);\n\n\treturn 0;\n}\n\n \nstatic int cavium_ptp_enable(struct ptp_clock_info *ptp_info,\n\t\t\t     struct ptp_clock_request *rq, int on)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic u64 cavium_ptp_cc_read(const struct cyclecounter *cc)\n{\n\tstruct cavium_ptp *clock =\n\t\tcontainer_of(cc, struct cavium_ptp, cycle_counter);\n\n\treturn readq(clock->reg_base + PTP_CLOCK_HI);\n}\n\nstatic int cavium_ptp_probe(struct pci_dev *pdev,\n\t\t\t    const struct pci_device_id *ent)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct cavium_ptp *clock;\n\tstruct cyclecounter *cc;\n\tu64 clock_cfg;\n\tu64 clock_comp;\n\tint err;\n\n\tclock = devm_kzalloc(dev, sizeof(*clock), GFP_KERNEL);\n\tif (!clock) {\n\t\terr = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\tclock->pdev = pdev;\n\n\terr = pcim_enable_device(pdev);\n\tif (err)\n\t\tgoto error_free;\n\n\terr = pcim_iomap_regions(pdev, 1 << PCI_PTP_BAR_NO, pci_name(pdev));\n\tif (err)\n\t\tgoto error_free;\n\n\tclock->reg_base = pcim_iomap_table(pdev)[PCI_PTP_BAR_NO];\n\n\tspin_lock_init(&clock->spin_lock);\n\n\tcc = &clock->cycle_counter;\n\tcc->read = cavium_ptp_cc_read;\n\tcc->mask = CYCLECOUNTER_MASK(64);\n\tcc->mult = 1;\n\tcc->shift = 0;\n\n\ttimecounter_init(&clock->time_counter, &clock->cycle_counter,\n\t\t\t ktime_to_ns(ktime_get_real()));\n\n\tclock->clock_rate = ptp_cavium_clock_get();\n\n\tclock->ptp_info = (struct ptp_clock_info) {\n\t\t.owner\t\t= THIS_MODULE,\n\t\t.name\t\t= \"ThunderX PTP\",\n\t\t.max_adj\t= 1000000000ull,\n\t\t.n_ext_ts\t= 0,\n\t\t.n_pins\t\t= 0,\n\t\t.pps\t\t= 0,\n\t\t.adjfine\t= cavium_ptp_adjfine,\n\t\t.adjtime\t= cavium_ptp_adjtime,\n\t\t.gettime64\t= cavium_ptp_gettime,\n\t\t.settime64\t= cavium_ptp_settime,\n\t\t.enable\t\t= cavium_ptp_enable,\n\t};\n\n\tclock_cfg = readq(clock->reg_base + PTP_CLOCK_CFG);\n\tclock_cfg |= PTP_CLOCK_CFG_PTP_EN;\n\twriteq(clock_cfg, clock->reg_base + PTP_CLOCK_CFG);\n\n\tclock_comp = ((u64)1000000000ull << 32) / clock->clock_rate;\n\twriteq(clock_comp, clock->reg_base + PTP_CLOCK_COMP);\n\n\tclock->ptp_clock = ptp_clock_register(&clock->ptp_info, dev);\n\tif (IS_ERR(clock->ptp_clock)) {\n\t\terr = PTR_ERR(clock->ptp_clock);\n\t\tgoto error_stop;\n\t}\n\n\tpci_set_drvdata(pdev, clock);\n\treturn 0;\n\nerror_stop:\n\tclock_cfg = readq(clock->reg_base + PTP_CLOCK_CFG);\n\tclock_cfg &= ~PTP_CLOCK_CFG_PTP_EN;\n\twriteq(clock_cfg, clock->reg_base + PTP_CLOCK_CFG);\n\tpcim_iounmap_regions(pdev, 1 << PCI_PTP_BAR_NO);\n\nerror_free:\n\tdevm_kfree(dev, clock);\n\nerror:\n\t \n\tpci_set_drvdata(pdev, ERR_PTR(err));\n\treturn 0;\n}\n\nstatic void cavium_ptp_remove(struct pci_dev *pdev)\n{\n\tstruct cavium_ptp *clock = pci_get_drvdata(pdev);\n\tu64 clock_cfg;\n\n\tif (IS_ERR_OR_NULL(clock))\n\t\treturn;\n\n\tptp_clock_unregister(clock->ptp_clock);\n\n\tclock_cfg = readq(clock->reg_base + PTP_CLOCK_CFG);\n\tclock_cfg &= ~PTP_CLOCK_CFG_PTP_EN;\n\twriteq(clock_cfg, clock->reg_base + PTP_CLOCK_CFG);\n}\n\nstatic const struct pci_device_id cavium_ptp_id_table[] = {\n\t{ PCI_DEVICE_SUB(PCI_VENDOR_ID_CAVIUM, PCI_DEVICE_ID_CAVIUM_PTP,\n\t\t\tPCI_VENDOR_ID_CAVIUM, PCI_SUBSYS_DEVID_88XX_PTP) },\n\t{ PCI_DEVICE_SUB(PCI_VENDOR_ID_CAVIUM, PCI_DEVICE_ID_CAVIUM_PTP,\n\t\t\tPCI_VENDOR_ID_CAVIUM, PCI_SUBSYS_DEVID_81XX_PTP) },\n\t{ PCI_DEVICE_SUB(PCI_VENDOR_ID_CAVIUM, PCI_DEVICE_ID_CAVIUM_PTP,\n\t\t\tPCI_VENDOR_ID_CAVIUM, PCI_SUBSYS_DEVID_83XX_PTP) },\n\t{ 0, }\n};\n\nstatic struct pci_driver cavium_ptp_driver = {\n\t.name = DRV_NAME,\n\t.id_table = cavium_ptp_id_table,\n\t.probe = cavium_ptp_probe,\n\t.remove = cavium_ptp_remove,\n};\n\nmodule_pci_driver(cavium_ptp_driver);\n\nMODULE_DESCRIPTION(DRV_NAME);\nMODULE_AUTHOR(\"Cavium Networks <support@cavium.com>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DEVICE_TABLE(pci, cavium_ptp_id_table);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}