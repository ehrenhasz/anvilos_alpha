{
  "module_name": "sc92031.c",
  "hash_id": "399ac0cf36e8dd7ab1716df4148104915527ad1128f35dac3fcc9d95631ae181",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/silan/sc92031.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/delay.h>\n#include <linux/pci.h>\n#include <linux/dma-mapping.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/ethtool.h>\n#include <linux/mii.h>\n#include <linux/crc32.h>\n\n#include <asm/irq.h>\n\n#define SC92031_NAME \"sc92031\"\n\n \n#define SC92031_USE_PIO\t0\n\n \nstatic int multicast_filter_limit = 64;\nmodule_param(multicast_filter_limit, int, 0);\nMODULE_PARM_DESC(multicast_filter_limit,\n\t\"Maximum number of filtered multicast addresses\");\n\nstatic int media;\nmodule_param(media, int, 0);\nMODULE_PARM_DESC(media, \"Media type (0x00 = autodetect,\"\n\t\" 0x01 = 10M half, 0x02 = 10M full,\"\n\t\" 0x04 = 100M half, 0x08 = 100M full)\");\n\n \n#define  RX_BUF_LEN_IDX  3  \n#define  RX_BUF_LEN\t(8192 << RX_BUF_LEN_IDX)\n\n \n#define  NUM_TX_DESC\t   4\n\n \n#define  MAX_ETH_FRAME_SIZE\t  1536\n\n \n#define  TX_BUF_SIZE       MAX_ETH_FRAME_SIZE\n#define  TX_BUF_TOT_LEN    (TX_BUF_SIZE * NUM_TX_DESC)\n\n \n#define  RX_FIFO_THRESH    7      \n\n \n#define  TX_TIMEOUT     (4*HZ)\n\n#define  SILAN_STATS_NUM    2     \n\n \n#define  AUTOSELECT    0x00\n#define  M10_HALF      0x01\n#define  M10_FULL      0x02\n#define  M100_HALF     0x04\n#define  M100_FULL     0x08\n\n  \nenum  silan_registers {\n   Config0    = 0x00,          \n   Config1    = 0x04,          \n   RxBufWPtr  = 0x08,          \n   IntrStatus = 0x0C,          \n   IntrMask   = 0x10,          \n   RxbufAddr  = 0x14,          \n   RxBufRPtr  = 0x18,          \n   Txstatusall = 0x1C,         \n   TxStatus0  = 0x20,\t       \n   TxAddr0    = 0x30,          \n   RxConfig   = 0x40,          \n   MAC0\t      = 0x44,\t       \n   MAR0\t      = 0x4C,\t       \n   RxStatus0  = 0x54,          \n   TxConfig   = 0x5C,          \n   PhyCtrl    = 0x60,          \n   FlowCtrlConfig = 0x64,      \n   Miicmd0    = 0x68,          \n   Miicmd1    = 0x6C,          \n   Miistatus  = 0x70,          \n   Timercnt   = 0x74,          \n   TimerIntr  = 0x78,          \n   PMConfig   = 0x7C,          \n   CRC0       = 0x80,          \n   Wakeup0    = 0x88,          \n   LSBCRC0    = 0xC8,          \n   TestD0     = 0xD0,\n   TestD4     = 0xD4,\n   TestD8     = 0xD8,\n};\n\n#define MII_JAB             16\n#define MII_OutputStatus    24\n\n#define PHY_16_JAB_ENB      0x1000\n#define PHY_16_PORT_ENB     0x1\n\nenum IntrStatusBits {\n   LinkFail       = 0x80000000,\n   LinkOK         = 0x40000000,\n   TimeOut        = 0x20000000,\n   RxOverflow     = 0x0040,\n   RxOK           = 0x0020,\n   TxOK           = 0x0001,\n   IntrBits = LinkFail|LinkOK|TimeOut|RxOverflow|RxOK|TxOK,\n};\n\nenum TxStatusBits {\n   TxCarrierLost = 0x20000000,\n   TxAborted     = 0x10000000,\n   TxOutOfWindow = 0x08000000,\n   TxNccShift    = 22,\n   EarlyTxThresShift = 16,\n   TxStatOK      = 0x8000,\n   TxUnderrun    = 0x4000,\n   TxOwn         = 0x2000,\n};\n\nenum RxStatusBits {\n   RxStatesOK   = 0x80000,\n   RxBadAlign   = 0x40000,\n   RxHugeFrame  = 0x20000,\n   RxSmallFrame = 0x10000,\n   RxCRCOK      = 0x8000,\n   RxCrlFrame   = 0x4000,\n   Rx_Broadcast = 0x2000,\n   Rx_Multicast = 0x1000,\n   RxAddrMatch  = 0x0800,\n   MiiErr       = 0x0400,\n};\n\nenum RxConfigBits {\n   RxFullDx    = 0x80000000,\n   RxEnb       = 0x40000000,\n   RxSmall     = 0x20000000,\n   RxHuge      = 0x10000000,\n   RxErr       = 0x08000000,\n   RxAllphys   = 0x04000000,\n   RxMulticast = 0x02000000,\n   RxBroadcast = 0x01000000,\n   RxLoopBack  = (1 << 23) | (1 << 22),\n   LowThresholdShift  = 12,\n   HighThresholdShift = 2,\n};\n\nenum TxConfigBits {\n   TxFullDx       = 0x80000000,\n   TxEnb          = 0x40000000,\n   TxEnbPad       = 0x20000000,\n   TxEnbHuge      = 0x10000000,\n   TxEnbFCS       = 0x08000000,\n   TxNoBackOff    = 0x04000000,\n   TxEnbPrem      = 0x02000000,\n   TxCareLostCrs  = 0x1000000,\n   TxExdCollNum   = 0xf00000,\n   TxDataRate     = 0x80000,\n};\n\nenum PhyCtrlconfigbits {\n   PhyCtrlAne         = 0x80000000,\n   PhyCtrlSpd100      = 0x40000000,\n   PhyCtrlSpd10       = 0x20000000,\n   PhyCtrlPhyBaseAddr = 0x1f000000,\n   PhyCtrlDux         = 0x800000,\n   PhyCtrlReset       = 0x400000,\n};\n\nenum FlowCtrlConfigBits {\n   FlowCtrlFullDX = 0x80000000,\n   FlowCtrlEnb    = 0x40000000,\n};\n\nenum Config0Bits {\n   Cfg0_Reset  = 0x80000000,\n   Cfg0_Anaoff = 0x40000000,\n   Cfg0_LDPS   = 0x20000000,\n};\n\nenum Config1Bits {\n   Cfg1_EarlyRx = 1 << 31,\n   Cfg1_EarlyTx = 1 << 30,\n\n    \n   Cfg1_Rcv8K   = 0x0,\n   Cfg1_Rcv16K  = 0x1,\n   Cfg1_Rcv32K  = 0x3,\n   Cfg1_Rcv64K  = 0x7,\n   Cfg1_Rcv128K = 0xf,\n};\n\nenum MiiCmd0Bits {\n   Mii_Divider = 0x20000000,\n   Mii_WRITE   = 0x400000,\n   Mii_READ    = 0x200000,\n   Mii_SCAN    = 0x100000,\n   Mii_Tamod   = 0x80000,\n   Mii_Drvmod  = 0x40000,\n   Mii_mdc     = 0x20000,\n   Mii_mdoen   = 0x10000,\n   Mii_mdo     = 0x8000,\n   Mii_mdi     = 0x4000,\n};\n\nenum MiiStatusBits {\n    Mii_StatusBusy = 0x80000000,\n};\n\nenum PMConfigBits {\n   PM_Enable  = 1 << 31,\n   PM_LongWF  = 1 << 30,\n   PM_Magic   = 1 << 29,\n   PM_LANWake = 1 << 28,\n   PM_LWPTN   = (1 << 27 | 1<< 26),\n   PM_LinkUp  = 1 << 25,\n   PM_WakeUp  = 1 << 24,\n};\n\n \n\n \n\nstruct sc92031_priv {\n\tspinlock_t\t\tlock;\n\t \n\tvoid __iomem\t\t*port_base;\n\t \n\tstruct pci_dev\t\t*pdev;\n\t \n\tstruct tasklet_struct\ttasklet;\n\n\t \n\tvoid\t\t\t*rx_ring;\n\t \n\tdma_addr_t\t\trx_ring_dma_addr;\n\t \n\tdma_addr_t\t\trx_ring_tail;\n\n\t \n\tunsigned\t\ttx_head;\n\t \n\tunsigned\t\ttx_tail;\n\t \n\tvoid\t\t\t*tx_bufs;\n\t \n\tdma_addr_t\t\ttx_bufs_dma_addr;\n\n\t \n\tu32\t\t\tintr_status;\n\tatomic_t\t\tintr_mask;\n\tu32\t\t\trx_config;\n\tu32\t\t\ttx_config;\n\tu32\t\t\tpm_config;\n\n\t \n\tunsigned int\t\tmc_flags;\n\n\t \n\tu64\t\t\ttx_timeouts;\n\tu64\t\t\trx_loss;\n\n\t \n\tlong\t\t\trx_value;\n\tstruct net_device\t*ndev;\n};\n\n \nstatic inline void _sc92031_dummy_read(void __iomem *port_base)\n{\n\tioread32(port_base + MAC0);\n}\n\nstatic u32 _sc92031_mii_wait(void __iomem *port_base)\n{\n\tu32 mii_status;\n\n\tdo {\n\t\tudelay(10);\n\t\tmii_status = ioread32(port_base + Miistatus);\n\t} while (mii_status & Mii_StatusBusy);\n\n\treturn mii_status;\n}\n\nstatic u32 _sc92031_mii_cmd(void __iomem *port_base, u32 cmd0, u32 cmd1)\n{\n\tiowrite32(Mii_Divider, port_base + Miicmd0);\n\n\t_sc92031_mii_wait(port_base);\n\n\tiowrite32(cmd1, port_base + Miicmd1);\n\tiowrite32(Mii_Divider | cmd0, port_base + Miicmd0);\n\n\treturn _sc92031_mii_wait(port_base);\n}\n\nstatic void _sc92031_mii_scan(void __iomem *port_base)\n{\n\t_sc92031_mii_cmd(port_base, Mii_SCAN, 0x1 << 6);\n}\n\nstatic u16 _sc92031_mii_read(void __iomem *port_base, unsigned reg)\n{\n\treturn _sc92031_mii_cmd(port_base, Mii_READ, reg << 6) >> 13;\n}\n\nstatic void _sc92031_mii_write(void __iomem *port_base, unsigned reg, u16 val)\n{\n\t_sc92031_mii_cmd(port_base, Mii_WRITE, (reg << 6) | ((u32)val << 11));\n}\n\nstatic void sc92031_disable_interrupts(struct net_device *dev)\n{\n\tstruct sc92031_priv *priv = netdev_priv(dev);\n\tvoid __iomem *port_base = priv->port_base;\n\n\t \n\tatomic_set(&priv->intr_mask, 0);\n\twmb();\n\n\t \n\tiowrite32(0, port_base + IntrMask);\n\t_sc92031_dummy_read(port_base);\n\n\t \n\tsynchronize_irq(priv->pdev->irq);\n\ttasklet_disable(&priv->tasklet);\n}\n\nstatic void sc92031_enable_interrupts(struct net_device *dev)\n{\n\tstruct sc92031_priv *priv = netdev_priv(dev);\n\tvoid __iomem *port_base = priv->port_base;\n\n\ttasklet_enable(&priv->tasklet);\n\n\tatomic_set(&priv->intr_mask, IntrBits);\n\twmb();\n\n\tiowrite32(IntrBits, port_base + IntrMask);\n}\n\nstatic void _sc92031_disable_tx_rx(struct net_device *dev)\n{\n\tstruct sc92031_priv *priv = netdev_priv(dev);\n\tvoid __iomem *port_base = priv->port_base;\n\n\tpriv->rx_config &= ~RxEnb;\n\tpriv->tx_config &= ~TxEnb;\n\tiowrite32(priv->rx_config, port_base + RxConfig);\n\tiowrite32(priv->tx_config, port_base + TxConfig);\n}\n\nstatic void _sc92031_enable_tx_rx(struct net_device *dev)\n{\n\tstruct sc92031_priv *priv = netdev_priv(dev);\n\tvoid __iomem *port_base = priv->port_base;\n\n\tpriv->rx_config |= RxEnb;\n\tpriv->tx_config |= TxEnb;\n\tiowrite32(priv->rx_config, port_base + RxConfig);\n\tiowrite32(priv->tx_config, port_base + TxConfig);\n}\n\nstatic void _sc92031_tx_clear(struct net_device *dev)\n{\n\tstruct sc92031_priv *priv = netdev_priv(dev);\n\n\twhile (priv->tx_head - priv->tx_tail > 0) {\n\t\tpriv->tx_tail++;\n\t\tdev->stats.tx_dropped++;\n\t}\n\tpriv->tx_head = priv->tx_tail = 0;\n}\n\nstatic void _sc92031_set_mar(struct net_device *dev)\n{\n\tstruct sc92031_priv *priv = netdev_priv(dev);\n\tvoid __iomem *port_base = priv->port_base;\n\tu32 mar0 = 0, mar1 = 0;\n\n\tif ((dev->flags & IFF_PROMISC) ||\n\t    netdev_mc_count(dev) > multicast_filter_limit ||\n\t    (dev->flags & IFF_ALLMULTI))\n\t\tmar0 = mar1 = 0xffffffff;\n\telse if (dev->flags & IFF_MULTICAST) {\n\t\tstruct netdev_hw_addr *ha;\n\n\t\tnetdev_for_each_mc_addr(ha, dev) {\n\t\t\tu32 crc;\n\t\t\tunsigned bit = 0;\n\n\t\t\tcrc = ~ether_crc(ETH_ALEN, ha->addr);\n\t\t\tcrc >>= 24;\n\n\t\t\tif (crc & 0x01)\tbit |= 0x02;\n\t\t\tif (crc & 0x02)\tbit |= 0x01;\n\t\t\tif (crc & 0x10)\tbit |= 0x20;\n\t\t\tif (crc & 0x20)\tbit |= 0x10;\n\t\t\tif (crc & 0x40)\tbit |= 0x08;\n\t\t\tif (crc & 0x80)\tbit |= 0x04;\n\n\t\t\tif (bit > 31)\n\t\t\t\tmar0 |= 0x1 << (bit - 32);\n\t\t\telse\n\t\t\t\tmar1 |= 0x1 << bit;\n\t\t}\n\t}\n\n\tiowrite32(mar0, port_base + MAR0);\n\tiowrite32(mar1, port_base + MAR0 + 4);\n}\n\nstatic void _sc92031_set_rx_config(struct net_device *dev)\n{\n\tstruct sc92031_priv *priv = netdev_priv(dev);\n\tvoid __iomem *port_base = priv->port_base;\n\tunsigned int old_mc_flags;\n\tu32 rx_config_bits = 0;\n\n\told_mc_flags = priv->mc_flags;\n\n\tif (dev->flags & IFF_PROMISC)\n\t\trx_config_bits |= RxSmall | RxHuge | RxErr | RxBroadcast\n\t\t\t\t| RxMulticast | RxAllphys;\n\n\tif (dev->flags & (IFF_ALLMULTI | IFF_MULTICAST))\n\t\trx_config_bits |= RxMulticast;\n\n\tif (dev->flags & IFF_BROADCAST)\n\t\trx_config_bits |= RxBroadcast;\n\n\tpriv->rx_config &= ~(RxSmall | RxHuge | RxErr | RxBroadcast\n\t\t\t| RxMulticast | RxAllphys);\n\tpriv->rx_config |= rx_config_bits;\n\n\tpriv->mc_flags = dev->flags & (IFF_PROMISC | IFF_ALLMULTI\n\t\t\t| IFF_MULTICAST | IFF_BROADCAST);\n\n\tif (netif_carrier_ok(dev) && priv->mc_flags != old_mc_flags)\n\t\tiowrite32(priv->rx_config, port_base + RxConfig);\n}\n\nstatic bool _sc92031_check_media(struct net_device *dev)\n{\n\tstruct sc92031_priv *priv = netdev_priv(dev);\n\tvoid __iomem *port_base = priv->port_base;\n\tu16 bmsr;\n\n\tbmsr = _sc92031_mii_read(port_base, MII_BMSR);\n\trmb();\n\tif (bmsr & BMSR_LSTATUS) {\n\t\tbool speed_100, duplex_full;\n\t\tu32 flow_ctrl_config = 0;\n\t\tu16 output_status = _sc92031_mii_read(port_base,\n\t\t\t\tMII_OutputStatus);\n\t\t_sc92031_mii_scan(port_base);\n\n\t\tspeed_100 = output_status & 0x2;\n\t\tduplex_full = output_status & 0x4;\n\n\t\t \n\t\tpriv->rx_config = (0x40 << LowThresholdShift) | (0x1c0 << HighThresholdShift);\n\t\tpriv->tx_config = 0x48800000;\n\n\t\t \n\n\t\tif (!speed_100)\n\t\t\tpriv->tx_config |= 0x80000;\n\n\t\t\n\t\t_sc92031_set_rx_config(dev);\n\n\t\tif (duplex_full) {\n\t\t\tpriv->rx_config |= RxFullDx;\n\t\t\tpriv->tx_config |= TxFullDx;\n\t\t\tflow_ctrl_config = FlowCtrlFullDX | FlowCtrlEnb;\n\t\t} else {\n\t\t\tpriv->rx_config &= ~RxFullDx;\n\t\t\tpriv->tx_config &= ~TxFullDx;\n\t\t}\n\n\t\t_sc92031_set_mar(dev);\n\t\t_sc92031_set_rx_config(dev);\n\t\t_sc92031_enable_tx_rx(dev);\n\t\tiowrite32(flow_ctrl_config, port_base + FlowCtrlConfig);\n\n\t\tnetif_carrier_on(dev);\n\n\t\tif (printk_ratelimit())\n\t\t\tprintk(KERN_INFO \"%s: link up, %sMbps, %s-duplex\\n\",\n\t\t\t\tdev->name,\n\t\t\t\tspeed_100 ? \"100\" : \"10\",\n\t\t\t\tduplex_full ? \"full\" : \"half\");\n\t\treturn true;\n\t} else {\n\t\t_sc92031_mii_scan(port_base);\n\n\t\tnetif_carrier_off(dev);\n\n\t\t_sc92031_disable_tx_rx(dev);\n\n\t\tif (printk_ratelimit())\n\t\t\tprintk(KERN_INFO \"%s: link down\\n\", dev->name);\n\t\treturn false;\n\t}\n}\n\nstatic void _sc92031_phy_reset(struct net_device *dev)\n{\n\tstruct sc92031_priv *priv = netdev_priv(dev);\n\tvoid __iomem *port_base = priv->port_base;\n\tu32 phy_ctrl;\n\n\tphy_ctrl = ioread32(port_base + PhyCtrl);\n\tphy_ctrl &= ~(PhyCtrlDux | PhyCtrlSpd100 | PhyCtrlSpd10);\n\tphy_ctrl |= PhyCtrlAne | PhyCtrlReset;\n\n\tswitch (media) {\n\tdefault:\n\tcase AUTOSELECT:\n\t\tphy_ctrl |= PhyCtrlDux | PhyCtrlSpd100 | PhyCtrlSpd10;\n\t\tbreak;\n\tcase M10_HALF:\n\t\tphy_ctrl |= PhyCtrlSpd10;\n\t\tbreak;\n\tcase M10_FULL:\n\t\tphy_ctrl |= PhyCtrlDux | PhyCtrlSpd10;\n\t\tbreak;\n\tcase M100_HALF:\n\t\tphy_ctrl |= PhyCtrlSpd100;\n\t\tbreak;\n\tcase M100_FULL:\n\t\tphy_ctrl |= PhyCtrlDux | PhyCtrlSpd100;\n\t\tbreak;\n\t}\n\n\tiowrite32(phy_ctrl, port_base + PhyCtrl);\n\tmdelay(10);\n\n\tphy_ctrl &= ~PhyCtrlReset;\n\tiowrite32(phy_ctrl, port_base + PhyCtrl);\n\tmdelay(1);\n\n\t_sc92031_mii_write(port_base, MII_JAB,\n\t\t\tPHY_16_JAB_ENB | PHY_16_PORT_ENB);\n\t_sc92031_mii_scan(port_base);\n\n\tnetif_carrier_off(dev);\n\tnetif_stop_queue(dev);\n}\n\nstatic void _sc92031_reset(struct net_device *dev)\n{\n\tstruct sc92031_priv *priv = netdev_priv(dev);\n\tvoid __iomem *port_base = priv->port_base;\n\n\t \n\tiowrite32(0, port_base + PMConfig);\n\n\t \n\tiowrite32(Cfg0_Reset, port_base + Config0);\n\tmdelay(200);\n\n\tiowrite32(0, port_base + Config0);\n\tmdelay(10);\n\n\t \n\tiowrite32(0, port_base + IntrMask);\n\n\t \n\tiowrite32(0, port_base + MAR0);\n\tiowrite32(0, port_base + MAR0 + 4);\n\n\t \n\tiowrite32(priv->rx_ring_dma_addr, port_base + RxbufAddr);\n\tpriv->rx_ring_tail = priv->rx_ring_dma_addr;\n\n\t \n\t_sc92031_tx_clear(dev);\n\n\t \n\tpriv->intr_status = 0;\n\tatomic_set(&priv->intr_mask, 0);\n\tpriv->rx_config = 0;\n\tpriv->tx_config = 0;\n\tpriv->mc_flags = 0;\n\n\t \n\t \n\tiowrite32(Cfg1_Rcv64K, port_base + Config1);\n\n\t_sc92031_phy_reset(dev);\n\t_sc92031_check_media(dev);\n\n\t \n\tpriv->rx_value = 0;\n\n\t \n\tiowrite32(priv->pm_config, port_base + PMConfig);\n\n\t \n\tioread32(port_base + IntrStatus);\n}\n\nstatic void _sc92031_tx_tasklet(struct net_device *dev)\n{\n\tstruct sc92031_priv *priv = netdev_priv(dev);\n\tvoid __iomem *port_base = priv->port_base;\n\n\tunsigned old_tx_tail;\n\tunsigned entry;\n\tu32 tx_status;\n\n\told_tx_tail = priv->tx_tail;\n\twhile (priv->tx_head - priv->tx_tail > 0) {\n\t\tentry = priv->tx_tail % NUM_TX_DESC;\n\t\ttx_status = ioread32(port_base + TxStatus0 + entry * 4);\n\n\t\tif (!(tx_status & (TxStatOK | TxUnderrun | TxAborted)))\n\t\t\tbreak;\n\n\t\tpriv->tx_tail++;\n\n\t\tif (tx_status & TxStatOK) {\n\t\t\tdev->stats.tx_bytes += tx_status & 0x1fff;\n\t\t\tdev->stats.tx_packets++;\n\t\t\t \n\t\t\tdev->stats.collisions += (tx_status >> 22) & 0xf;\n\t\t}\n\n\t\tif (tx_status & (TxOutOfWindow | TxAborted)) {\n\t\t\tdev->stats.tx_errors++;\n\n\t\t\tif (tx_status & TxAborted)\n\t\t\t\tdev->stats.tx_aborted_errors++;\n\n\t\t\tif (tx_status & TxCarrierLost)\n\t\t\t\tdev->stats.tx_carrier_errors++;\n\n\t\t\tif (tx_status & TxOutOfWindow)\n\t\t\t\tdev->stats.tx_window_errors++;\n\t\t}\n\n\t\tif (tx_status & TxUnderrun)\n\t\t\tdev->stats.tx_fifo_errors++;\n\t}\n\n\tif (priv->tx_tail != old_tx_tail)\n\t\tif (netif_queue_stopped(dev))\n\t\t\tnetif_wake_queue(dev);\n}\n\nstatic void _sc92031_rx_tasklet_error(struct net_device *dev,\n\t\t\t\t      u32 rx_status, unsigned rx_size)\n{\n\tif(rx_size > (MAX_ETH_FRAME_SIZE + 4) || rx_size < 16) {\n\t\tdev->stats.rx_errors++;\n\t\tdev->stats.rx_length_errors++;\n\t}\n\n\tif (!(rx_status & RxStatesOK)) {\n\t\tdev->stats.rx_errors++;\n\n\t\tif (rx_status & (RxHugeFrame | RxSmallFrame))\n\t\t\tdev->stats.rx_length_errors++;\n\n\t\tif (rx_status & RxBadAlign)\n\t\t\tdev->stats.rx_frame_errors++;\n\n\t\tif (!(rx_status & RxCRCOK))\n\t\t\tdev->stats.rx_crc_errors++;\n\t} else {\n\t\tstruct sc92031_priv *priv = netdev_priv(dev);\n\t\tpriv->rx_loss++;\n\t}\n}\n\nstatic void _sc92031_rx_tasklet(struct net_device *dev)\n{\n\tstruct sc92031_priv *priv = netdev_priv(dev);\n\tvoid __iomem *port_base = priv->port_base;\n\n\tdma_addr_t rx_ring_head;\n\tunsigned rx_len;\n\tunsigned rx_ring_offset;\n\tvoid *rx_ring = priv->rx_ring;\n\n\trx_ring_head = ioread32(port_base + RxBufWPtr);\n\trmb();\n\n\t \n\trx_ring_head &= (dma_addr_t)(RX_BUF_LEN - 1);\n\trx_ring_head |= priv->rx_ring_dma_addr & ~(dma_addr_t)(RX_BUF_LEN - 1);\n\tif (rx_ring_head < priv->rx_ring_dma_addr)\n\t\trx_ring_head += RX_BUF_LEN;\n\n\tif (rx_ring_head >= priv->rx_ring_tail)\n\t\trx_len = rx_ring_head - priv->rx_ring_tail;\n\telse\n\t\trx_len = RX_BUF_LEN - (priv->rx_ring_tail - rx_ring_head);\n\n\tif (!rx_len)\n\t\treturn;\n\n\tif (unlikely(rx_len > RX_BUF_LEN)) {\n\t\tif (printk_ratelimit())\n\t\t\tprintk(KERN_ERR \"%s: rx packets length > rx buffer\\n\",\n\t\t\t\t\tdev->name);\n\t\treturn;\n\t}\n\n\trx_ring_offset = (priv->rx_ring_tail - priv->rx_ring_dma_addr) % RX_BUF_LEN;\n\n\twhile (rx_len) {\n\t\tu32 rx_status;\n\t\tunsigned rx_size, rx_size_align, pkt_size;\n\t\tstruct sk_buff *skb;\n\n\t\trx_status = le32_to_cpup((__le32 *)(rx_ring + rx_ring_offset));\n\t\trmb();\n\n\t\trx_size = rx_status >> 20;\n\t\trx_size_align = (rx_size + 3) & ~3;\t\n\t\tpkt_size = rx_size - 4;\t\n\n\t\trx_ring_offset = (rx_ring_offset + 4) % RX_BUF_LEN;\n\n\t\tif (unlikely(rx_status == 0 ||\n\t\t\t     rx_size > (MAX_ETH_FRAME_SIZE + 4) ||\n\t\t\t     rx_size < 16 ||\n\t\t\t     !(rx_status & RxStatesOK))) {\n\t\t\t_sc92031_rx_tasklet_error(dev, rx_status, rx_size);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (unlikely(rx_size_align + 4 > rx_len)) {\n\t\t\tif (printk_ratelimit())\n\t\t\t\tprintk(KERN_ERR \"%s: rx_len is too small\\n\", dev->name);\n\t\t\tbreak;\n\t\t}\n\n\t\trx_len -= rx_size_align + 4;\n\n\t\tskb = netdev_alloc_skb_ip_align(dev, pkt_size);\n\t\tif (unlikely(!skb)) {\n\t\t\tif (printk_ratelimit())\n\t\t\t\tprintk(KERN_ERR \"%s: Couldn't allocate a skb_buff for a packet of size %u\\n\",\n\t\t\t\t\t\tdev->name, pkt_size);\n\t\t\tgoto next;\n\t\t}\n\n\t\tif ((rx_ring_offset + pkt_size) > RX_BUF_LEN) {\n\t\t\tskb_put_data(skb, rx_ring + rx_ring_offset,\n\t\t\t\t     RX_BUF_LEN - rx_ring_offset);\n\t\t\tskb_put_data(skb, rx_ring,\n\t\t\t\t     pkt_size - (RX_BUF_LEN - rx_ring_offset));\n\t\t} else {\n\t\t\tskb_put_data(skb, rx_ring + rx_ring_offset, pkt_size);\n\t\t}\n\n\t\tskb->protocol = eth_type_trans(skb, dev);\n\t\tnetif_rx(skb);\n\n\t\tdev->stats.rx_bytes += pkt_size;\n\t\tdev->stats.rx_packets++;\n\n\t\tif (rx_status & Rx_Multicast)\n\t\t\tdev->stats.multicast++;\n\n\tnext:\n\t\trx_ring_offset = (rx_ring_offset + rx_size_align) % RX_BUF_LEN;\n\t}\n\tmb();\n\n\tpriv->rx_ring_tail = rx_ring_head;\n\tiowrite32(priv->rx_ring_tail, port_base + RxBufRPtr);\n}\n\nstatic void _sc92031_link_tasklet(struct net_device *dev)\n{\n\tif (_sc92031_check_media(dev))\n\t\tnetif_wake_queue(dev);\n\telse {\n\t\tnetif_stop_queue(dev);\n\t\tdev->stats.tx_carrier_errors++;\n\t}\n}\n\nstatic void sc92031_tasklet(struct tasklet_struct *t)\n{\n\tstruct  sc92031_priv *priv = from_tasklet(priv, t, tasklet);\n\tstruct net_device *dev = priv->ndev;\n\tvoid __iomem *port_base = priv->port_base;\n\tu32 intr_status, intr_mask;\n\n\tintr_status = priv->intr_status;\n\n\tspin_lock(&priv->lock);\n\n\tif (unlikely(!netif_running(dev)))\n\t\tgoto out;\n\n\tif (intr_status & TxOK)\n\t\t_sc92031_tx_tasklet(dev);\n\n\tif (intr_status & RxOK)\n\t\t_sc92031_rx_tasklet(dev);\n\n\tif (intr_status & RxOverflow)\n\t\tdev->stats.rx_errors++;\n\n\tif (intr_status & TimeOut) {\n\t\tdev->stats.rx_errors++;\n\t\tdev->stats.rx_length_errors++;\n\t}\n\n\tif (intr_status & (LinkFail | LinkOK))\n\t\t_sc92031_link_tasklet(dev);\n\nout:\n\tintr_mask = atomic_read(&priv->intr_mask);\n\trmb();\n\n\tiowrite32(intr_mask, port_base + IntrMask);\n\n\tspin_unlock(&priv->lock);\n}\n\nstatic irqreturn_t sc92031_interrupt(int irq, void *dev_id)\n{\n\tstruct net_device *dev = dev_id;\n\tstruct sc92031_priv *priv = netdev_priv(dev);\n\tvoid __iomem *port_base = priv->port_base;\n\tu32 intr_status, intr_mask;\n\n\t \n\tiowrite32(0, port_base + IntrMask);\n\t_sc92031_dummy_read(port_base);\n\n\tintr_status = ioread32(port_base + IntrStatus);\n\tif (unlikely(intr_status == 0xffffffff))\n\t\treturn IRQ_NONE;\t\n\n\tintr_status &= IntrBits;\n\tif (!intr_status)\n\t\tgoto out_none;\n\n\tpriv->intr_status = intr_status;\n\ttasklet_schedule(&priv->tasklet);\n\n\treturn IRQ_HANDLED;\n\nout_none:\n\tintr_mask = atomic_read(&priv->intr_mask);\n\trmb();\n\n\tiowrite32(intr_mask, port_base + IntrMask);\n\n\treturn IRQ_NONE;\n}\n\nstatic struct net_device_stats *sc92031_get_stats(struct net_device *dev)\n{\n\tstruct sc92031_priv *priv = netdev_priv(dev);\n\tvoid __iomem *port_base = priv->port_base;\n\n\t\n\tif (netif_running(dev)) {\n\t\tint temp;\n\n\t\tspin_lock_bh(&priv->lock);\n\n\t\t \n\t\ttemp = (ioread32(port_base + RxStatus0) >> 16) & 0xffff;\n\n\t\tif (temp == 0xffff) {\n\t\t\tpriv->rx_value += temp;\n\t\t\tdev->stats.rx_fifo_errors = priv->rx_value;\n\t\t} else\n\t\t\tdev->stats.rx_fifo_errors = temp + priv->rx_value;\n\n\t\tspin_unlock_bh(&priv->lock);\n\t}\n\n\treturn &dev->stats;\n}\n\nstatic netdev_tx_t sc92031_start_xmit(struct sk_buff *skb,\n\t\t\t\t      struct net_device *dev)\n{\n\tstruct sc92031_priv *priv = netdev_priv(dev);\n\tvoid __iomem *port_base = priv->port_base;\n\tunsigned len;\n\tunsigned entry;\n\tu32 tx_status;\n\n\tif (unlikely(skb->len > TX_BUF_SIZE)) {\n\t\tdev->stats.tx_dropped++;\n\t\tgoto out;\n\t}\n\n\tspin_lock(&priv->lock);\n\n\tif (unlikely(!netif_carrier_ok(dev))) {\n\t\tdev->stats.tx_dropped++;\n\t\tgoto out_unlock;\n\t}\n\n\tBUG_ON(priv->tx_head - priv->tx_tail >= NUM_TX_DESC);\n\n\tentry = priv->tx_head++ % NUM_TX_DESC;\n\n\tskb_copy_and_csum_dev(skb, priv->tx_bufs + entry * TX_BUF_SIZE);\n\n\tlen = skb->len;\n\tif (len < ETH_ZLEN) {\n\t\tmemset(priv->tx_bufs + entry * TX_BUF_SIZE + len,\n\t\t\t\t0, ETH_ZLEN - len);\n\t\tlen = ETH_ZLEN;\n\t}\n\n\twmb();\n\n\tif (len < 100)\n\t\ttx_status = len;\n\telse if (len < 300)\n\t\ttx_status = 0x30000 | len;\n\telse\n\t\ttx_status = 0x50000 | len;\n\n\tiowrite32(priv->tx_bufs_dma_addr + entry * TX_BUF_SIZE,\n\t\t\tport_base + TxAddr0 + entry * 4);\n\tiowrite32(tx_status, port_base + TxStatus0 + entry * 4);\n\n\tif (priv->tx_head - priv->tx_tail >= NUM_TX_DESC)\n\t\tnetif_stop_queue(dev);\n\nout_unlock:\n\tspin_unlock(&priv->lock);\n\nout:\n\tdev_consume_skb_any(skb);\n\n\treturn NETDEV_TX_OK;\n}\n\nstatic int sc92031_open(struct net_device *dev)\n{\n\tint err;\n\tstruct sc92031_priv *priv = netdev_priv(dev);\n\tstruct pci_dev *pdev = priv->pdev;\n\n\tpriv->rx_ring = dma_alloc_coherent(&pdev->dev, RX_BUF_LEN,\n\t\t\t\t\t   &priv->rx_ring_dma_addr, GFP_KERNEL);\n\tif (unlikely(!priv->rx_ring)) {\n\t\terr = -ENOMEM;\n\t\tgoto out_alloc_rx_ring;\n\t}\n\n\tpriv->tx_bufs = dma_alloc_coherent(&pdev->dev, TX_BUF_TOT_LEN,\n\t\t\t\t\t   &priv->tx_bufs_dma_addr, GFP_KERNEL);\n\tif (unlikely(!priv->tx_bufs)) {\n\t\terr = -ENOMEM;\n\t\tgoto out_alloc_tx_bufs;\n\t}\n\tpriv->tx_head = priv->tx_tail = 0;\n\n\terr = request_irq(pdev->irq, sc92031_interrupt,\n\t\t\tIRQF_SHARED, dev->name, dev);\n\tif (unlikely(err < 0))\n\t\tgoto out_request_irq;\n\n\tpriv->pm_config = 0;\n\n\t \n\tspin_lock_bh(&priv->lock);\n\n\t_sc92031_reset(dev);\n\n\tspin_unlock_bh(&priv->lock);\n\tsc92031_enable_interrupts(dev);\n\n\tif (netif_carrier_ok(dev))\n\t\tnetif_start_queue(dev);\n\telse\n\t\tnetif_tx_disable(dev);\n\n\treturn 0;\n\nout_request_irq:\n\tdma_free_coherent(&pdev->dev, TX_BUF_TOT_LEN, priv->tx_bufs,\n\t\t\t  priv->tx_bufs_dma_addr);\nout_alloc_tx_bufs:\n\tdma_free_coherent(&pdev->dev, RX_BUF_LEN, priv->rx_ring,\n\t\t\t  priv->rx_ring_dma_addr);\nout_alloc_rx_ring:\n\treturn err;\n}\n\nstatic int sc92031_stop(struct net_device *dev)\n{\n\tstruct sc92031_priv *priv = netdev_priv(dev);\n\tstruct pci_dev *pdev = priv->pdev;\n\n\tnetif_tx_disable(dev);\n\n\t \n\tsc92031_disable_interrupts(dev);\n\n\tspin_lock_bh(&priv->lock);\n\n\t_sc92031_disable_tx_rx(dev);\n\t_sc92031_tx_clear(dev);\n\n\tspin_unlock_bh(&priv->lock);\n\n\tfree_irq(pdev->irq, dev);\n\tdma_free_coherent(&pdev->dev, TX_BUF_TOT_LEN, priv->tx_bufs,\n\t\t\t  priv->tx_bufs_dma_addr);\n\tdma_free_coherent(&pdev->dev, RX_BUF_LEN, priv->rx_ring,\n\t\t\t  priv->rx_ring_dma_addr);\n\n\treturn 0;\n}\n\nstatic void sc92031_set_multicast_list(struct net_device *dev)\n{\n\tstruct sc92031_priv *priv = netdev_priv(dev);\n\n\tspin_lock_bh(&priv->lock);\n\n\t_sc92031_set_mar(dev);\n\t_sc92031_set_rx_config(dev);\n\n\tspin_unlock_bh(&priv->lock);\n}\n\nstatic void sc92031_tx_timeout(struct net_device *dev, unsigned int txqueue)\n{\n\tstruct sc92031_priv *priv = netdev_priv(dev);\n\n\t \n\tsc92031_disable_interrupts(dev);\n\n\tspin_lock(&priv->lock);\n\n\tpriv->tx_timeouts++;\n\n\t_sc92031_reset(dev);\n\n\tspin_unlock(&priv->lock);\n\n\t \n\tsc92031_enable_interrupts(dev);\n\n\tif (netif_carrier_ok(dev))\n\t\tnetif_wake_queue(dev);\n}\n\n#ifdef CONFIG_NET_POLL_CONTROLLER\nstatic void sc92031_poll_controller(struct net_device *dev)\n{\n\tstruct sc92031_priv *priv = netdev_priv(dev);\n\tconst int irq = priv->pdev->irq;\n\n\tdisable_irq(irq);\n\tif (sc92031_interrupt(irq, dev) != IRQ_NONE)\n\t\tsc92031_tasklet(&priv->tasklet);\n\tenable_irq(irq);\n}\n#endif\n\nstatic int\nsc92031_ethtool_get_link_ksettings(struct net_device *dev,\n\t\t\t\t   struct ethtool_link_ksettings *cmd)\n{\n\tstruct sc92031_priv *priv = netdev_priv(dev);\n\tvoid __iomem *port_base = priv->port_base;\n\tu8 phy_address;\n\tu32 phy_ctrl;\n\tu16 output_status;\n\tu32 supported, advertising;\n\n\tspin_lock_bh(&priv->lock);\n\n\tphy_address = ioread32(port_base + Miicmd1) >> 27;\n\tphy_ctrl = ioread32(port_base + PhyCtrl);\n\n\toutput_status = _sc92031_mii_read(port_base, MII_OutputStatus);\n\t_sc92031_mii_scan(port_base);\n\n\tspin_unlock_bh(&priv->lock);\n\n\tsupported = SUPPORTED_10baseT_Half | SUPPORTED_10baseT_Full\n\t\t\t| SUPPORTED_100baseT_Half | SUPPORTED_100baseT_Full\n\t\t\t| SUPPORTED_Autoneg | SUPPORTED_TP | SUPPORTED_MII;\n\n\tadvertising = ADVERTISED_TP | ADVERTISED_MII;\n\n\tif ((phy_ctrl & (PhyCtrlDux | PhyCtrlSpd100 | PhyCtrlSpd10))\n\t\t\t== (PhyCtrlDux | PhyCtrlSpd100 | PhyCtrlSpd10))\n\t\tadvertising |= ADVERTISED_Autoneg;\n\n\tif ((phy_ctrl & PhyCtrlSpd10) == PhyCtrlSpd10)\n\t\tadvertising |= ADVERTISED_10baseT_Half;\n\n\tif ((phy_ctrl & (PhyCtrlSpd10 | PhyCtrlDux))\n\t\t\t== (PhyCtrlSpd10 | PhyCtrlDux))\n\t\tadvertising |= ADVERTISED_10baseT_Full;\n\n\tif ((phy_ctrl & PhyCtrlSpd100) == PhyCtrlSpd100)\n\t\tadvertising |= ADVERTISED_100baseT_Half;\n\n\tif ((phy_ctrl & (PhyCtrlSpd100 | PhyCtrlDux))\n\t\t\t== (PhyCtrlSpd100 | PhyCtrlDux))\n\t\tadvertising |= ADVERTISED_100baseT_Full;\n\n\tif (phy_ctrl & PhyCtrlAne)\n\t\tadvertising |= ADVERTISED_Autoneg;\n\n\tcmd->base.speed = (output_status & 0x2) ? SPEED_100 : SPEED_10;\n\tcmd->base.duplex = (output_status & 0x4) ? DUPLEX_FULL : DUPLEX_HALF;\n\tcmd->base.port = PORT_MII;\n\tcmd->base.phy_address = phy_address;\n\tcmd->base.autoneg = (phy_ctrl & PhyCtrlAne) ?\n\t\tAUTONEG_ENABLE : AUTONEG_DISABLE;\n\n\tethtool_convert_legacy_u32_to_link_mode(cmd->link_modes.supported,\n\t\t\t\t\t\tsupported);\n\tethtool_convert_legacy_u32_to_link_mode(cmd->link_modes.advertising,\n\t\t\t\t\t\tadvertising);\n\n\treturn 0;\n}\n\nstatic int\nsc92031_ethtool_set_link_ksettings(struct net_device *dev,\n\t\t\t\t   const struct ethtool_link_ksettings *cmd)\n{\n\tstruct sc92031_priv *priv = netdev_priv(dev);\n\tvoid __iomem *port_base = priv->port_base;\n\tu32 speed = cmd->base.speed;\n\tu32 phy_ctrl;\n\tu32 old_phy_ctrl;\n\tu32 advertising;\n\n\tethtool_convert_link_mode_to_legacy_u32(&advertising,\n\t\t\t\t\t\tcmd->link_modes.advertising);\n\n\tif (!(speed == SPEED_10 || speed == SPEED_100))\n\t\treturn -EINVAL;\n\tif (!(cmd->base.duplex == DUPLEX_HALF ||\n\t      cmd->base.duplex == DUPLEX_FULL))\n\t\treturn -EINVAL;\n\tif (!(cmd->base.port == PORT_MII))\n\t\treturn -EINVAL;\n\tif (!(cmd->base.phy_address == 0x1f))\n\t\treturn -EINVAL;\n\tif (!(cmd->base.autoneg == AUTONEG_DISABLE ||\n\t      cmd->base.autoneg == AUTONEG_ENABLE))\n\t\treturn -EINVAL;\n\n\tif (cmd->base.autoneg == AUTONEG_ENABLE) {\n\t\tif (!(advertising & (ADVERTISED_Autoneg\n\t\t\t\t| ADVERTISED_100baseT_Full\n\t\t\t\t| ADVERTISED_100baseT_Half\n\t\t\t\t| ADVERTISED_10baseT_Full\n\t\t\t\t| ADVERTISED_10baseT_Half)))\n\t\t\treturn -EINVAL;\n\n\t\tphy_ctrl = PhyCtrlAne;\n\n\t\t\n\t\tif (advertising & ADVERTISED_Autoneg)\n\t\t\tphy_ctrl |= PhyCtrlDux | PhyCtrlSpd100 | PhyCtrlSpd10;\n\t\tif (advertising & ADVERTISED_100baseT_Full)\n\t\t\tphy_ctrl |= PhyCtrlDux | PhyCtrlSpd100;\n\t\tif (advertising & ADVERTISED_100baseT_Half)\n\t\t\tphy_ctrl |= PhyCtrlSpd100;\n\t\tif (advertising & ADVERTISED_10baseT_Full)\n\t\t\tphy_ctrl |= PhyCtrlSpd10 | PhyCtrlDux;\n\t\tif (advertising & ADVERTISED_10baseT_Half)\n\t\t\tphy_ctrl |= PhyCtrlSpd10;\n\t} else {\n\t\t\n\t\tphy_ctrl = 0;\n\n\t\tif (speed == SPEED_10)\n\t\t\tphy_ctrl |= PhyCtrlSpd10;\n\t\telse  \n\t\t\tphy_ctrl |= PhyCtrlSpd100;\n\n\t\tif (cmd->base.duplex == DUPLEX_FULL)\n\t\t\tphy_ctrl |= PhyCtrlDux;\n\t}\n\n\tspin_lock_bh(&priv->lock);\n\n\told_phy_ctrl = ioread32(port_base + PhyCtrl);\n\tphy_ctrl |= old_phy_ctrl & ~(PhyCtrlAne | PhyCtrlDux\n\t\t\t| PhyCtrlSpd100 | PhyCtrlSpd10);\n\tif (phy_ctrl != old_phy_ctrl)\n\t\tiowrite32(phy_ctrl, port_base + PhyCtrl);\n\n\tspin_unlock_bh(&priv->lock);\n\n\treturn 0;\n}\n\nstatic void sc92031_ethtool_get_wol(struct net_device *dev,\n\t\tstruct ethtool_wolinfo *wolinfo)\n{\n\tstruct sc92031_priv *priv = netdev_priv(dev);\n\tvoid __iomem *port_base = priv->port_base;\n\tu32 pm_config;\n\n\tspin_lock_bh(&priv->lock);\n\tpm_config = ioread32(port_base + PMConfig);\n\tspin_unlock_bh(&priv->lock);\n\n\t\n\twolinfo->supported = WAKE_PHY | WAKE_MAGIC\n\t\t\t| WAKE_UCAST | WAKE_MCAST | WAKE_BCAST;\n\twolinfo->wolopts = 0;\n\n\tif (pm_config & PM_LinkUp)\n\t\twolinfo->wolopts |= WAKE_PHY;\n\n\tif (pm_config & PM_Magic)\n\t\twolinfo->wolopts |= WAKE_MAGIC;\n\n\tif (pm_config & PM_WakeUp)\n\t\t\n\t\twolinfo->wolopts |= WAKE_UCAST | WAKE_MCAST | WAKE_BCAST;\n}\n\nstatic int sc92031_ethtool_set_wol(struct net_device *dev,\n\t\tstruct ethtool_wolinfo *wolinfo)\n{\n\tstruct sc92031_priv *priv = netdev_priv(dev);\n\tvoid __iomem *port_base = priv->port_base;\n\tu32 pm_config;\n\n\tspin_lock_bh(&priv->lock);\n\n\tpm_config = ioread32(port_base + PMConfig)\n\t\t\t& ~(PM_LinkUp | PM_Magic | PM_WakeUp);\n\n\tif (wolinfo->wolopts & WAKE_PHY)\n\t\tpm_config |= PM_LinkUp;\n\n\tif (wolinfo->wolopts & WAKE_MAGIC)\n\t\tpm_config |= PM_Magic;\n\n\t\n\tif (wolinfo->wolopts & (WAKE_UCAST | WAKE_MCAST | WAKE_BCAST))\n\t\tpm_config |= PM_WakeUp;\n\n\tpriv->pm_config = pm_config;\n\tiowrite32(pm_config, port_base + PMConfig);\n\n\tspin_unlock_bh(&priv->lock);\n\n\treturn 0;\n}\n\nstatic int sc92031_ethtool_nway_reset(struct net_device *dev)\n{\n\tint err = 0;\n\tstruct sc92031_priv *priv = netdev_priv(dev);\n\tvoid __iomem *port_base = priv->port_base;\n\tu16 bmcr;\n\n\tspin_lock_bh(&priv->lock);\n\n\tbmcr = _sc92031_mii_read(port_base, MII_BMCR);\n\tif (!(bmcr & BMCR_ANENABLE)) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t_sc92031_mii_write(port_base, MII_BMCR, bmcr | BMCR_ANRESTART);\n\nout:\n\t_sc92031_mii_scan(port_base);\n\n\tspin_unlock_bh(&priv->lock);\n\n\treturn err;\n}\n\nstatic const char sc92031_ethtool_stats_strings[SILAN_STATS_NUM][ETH_GSTRING_LEN] = {\n\t\"tx_timeout\",\n\t\"rx_loss\",\n};\n\nstatic void sc92031_ethtool_get_strings(struct net_device *dev,\n\t\tu32 stringset, u8 *data)\n{\n\tif (stringset == ETH_SS_STATS)\n\t\tmemcpy(data, sc92031_ethtool_stats_strings,\n\t\t\t\tSILAN_STATS_NUM * ETH_GSTRING_LEN);\n}\n\nstatic int sc92031_ethtool_get_sset_count(struct net_device *dev, int sset)\n{\n\tswitch (sset) {\n\tcase ETH_SS_STATS:\n\t\treturn SILAN_STATS_NUM;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic void sc92031_ethtool_get_ethtool_stats(struct net_device *dev,\n\t\tstruct ethtool_stats *stats, u64 *data)\n{\n\tstruct sc92031_priv *priv = netdev_priv(dev);\n\n\tspin_lock_bh(&priv->lock);\n\tdata[0] = priv->tx_timeouts;\n\tdata[1] = priv->rx_loss;\n\tspin_unlock_bh(&priv->lock);\n}\n\nstatic const struct ethtool_ops sc92031_ethtool_ops = {\n\t.get_wol\t\t= sc92031_ethtool_get_wol,\n\t.set_wol\t\t= sc92031_ethtool_set_wol,\n\t.nway_reset\t\t= sc92031_ethtool_nway_reset,\n\t.get_link\t\t= ethtool_op_get_link,\n\t.get_strings\t\t= sc92031_ethtool_get_strings,\n\t.get_sset_count\t\t= sc92031_ethtool_get_sset_count,\n\t.get_ethtool_stats\t= sc92031_ethtool_get_ethtool_stats,\n\t.get_link_ksettings\t= sc92031_ethtool_get_link_ksettings,\n\t.set_link_ksettings\t= sc92031_ethtool_set_link_ksettings,\n};\n\n\nstatic const struct net_device_ops sc92031_netdev_ops = {\n\t.ndo_get_stats\t\t= sc92031_get_stats,\n\t.ndo_start_xmit\t\t= sc92031_start_xmit,\n\t.ndo_open\t\t= sc92031_open,\n\t.ndo_stop\t\t= sc92031_stop,\n\t.ndo_set_rx_mode\t= sc92031_set_multicast_list,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_set_mac_address \t= eth_mac_addr,\n\t.ndo_tx_timeout\t\t= sc92031_tx_timeout,\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\t.ndo_poll_controller\t= sc92031_poll_controller,\n#endif\n};\n\nstatic int sc92031_probe(struct pci_dev *pdev, const struct pci_device_id *id)\n{\n\tint err;\n\tvoid __iomem* port_base;\n\tstruct net_device *dev;\n\tstruct sc92031_priv *priv;\n\tu8 addr[ETH_ALEN];\n\tu32 mac0, mac1;\n\n\terr = pci_enable_device(pdev);\n\tif (unlikely(err < 0))\n\t\tgoto out_enable_device;\n\n\tpci_set_master(pdev);\n\n\terr = dma_set_mask(&pdev->dev, DMA_BIT_MASK(32));\n\tif (unlikely(err < 0))\n\t\tgoto out_set_dma_mask;\n\n\terr = dma_set_coherent_mask(&pdev->dev, DMA_BIT_MASK(32));\n\tif (unlikely(err < 0))\n\t\tgoto out_set_dma_mask;\n\n\terr = pci_request_regions(pdev, SC92031_NAME);\n\tif (unlikely(err < 0))\n\t\tgoto out_request_regions;\n\n\tport_base = pci_iomap(pdev, SC92031_USE_PIO, 0);\n\tif (unlikely(!port_base)) {\n\t\terr = -EIO;\n\t\tgoto out_iomap;\n\t}\n\n\tdev = alloc_etherdev(sizeof(struct sc92031_priv));\n\tif (unlikely(!dev)) {\n\t\terr = -ENOMEM;\n\t\tgoto out_alloc_etherdev;\n\t}\n\n\tpci_set_drvdata(pdev, dev);\n\tSET_NETDEV_DEV(dev, &pdev->dev);\n\n\t \n\tdev->features = NETIF_F_SG | NETIF_F_HIGHDMA |\n\t\tNETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM;\n\n\tdev->netdev_ops\t\t= &sc92031_netdev_ops;\n\tdev->watchdog_timeo\t= TX_TIMEOUT;\n\tdev->ethtool_ops\t= &sc92031_ethtool_ops;\n\n\tpriv = netdev_priv(dev);\n\tpriv->ndev = dev;\n\tspin_lock_init(&priv->lock);\n\tpriv->port_base = port_base;\n\tpriv->pdev = pdev;\n\ttasklet_setup(&priv->tasklet, sc92031_tasklet);\n\t \n\ttasklet_disable_nosync(&priv->tasklet);\n\n\t \n\tiowrite32((~PM_LongWF & ~PM_LWPTN) | PM_Enable, port_base + PMConfig);\n\n\tmac0 = ioread32(port_base + MAC0);\n\tmac1 = ioread32(port_base + MAC0 + 4);\n\taddr[0] = mac0 >> 24;\n\taddr[1] = mac0 >> 16;\n\taddr[2] = mac0 >> 8;\n\taddr[3] = mac0;\n\taddr[4] = mac1 >> 8;\n\taddr[5] = mac1;\n\teth_hw_addr_set(dev, addr);\n\n\terr = register_netdev(dev);\n\tif (err < 0)\n\t\tgoto out_register_netdev;\n\n\tprintk(KERN_INFO \"%s: SC92031 at 0x%lx, %pM, IRQ %d\\n\", dev->name,\n\t       (long)pci_resource_start(pdev, SC92031_USE_PIO), dev->dev_addr,\n\t       pdev->irq);\n\n\treturn 0;\n\nout_register_netdev:\n\tfree_netdev(dev);\nout_alloc_etherdev:\n\tpci_iounmap(pdev, port_base);\nout_iomap:\n\tpci_release_regions(pdev);\nout_request_regions:\nout_set_dma_mask:\n\tpci_disable_device(pdev);\nout_enable_device:\n\treturn err;\n}\n\nstatic void sc92031_remove(struct pci_dev *pdev)\n{\n\tstruct net_device *dev = pci_get_drvdata(pdev);\n\tstruct sc92031_priv *priv = netdev_priv(dev);\n\tvoid __iomem* port_base = priv->port_base;\n\n\tunregister_netdev(dev);\n\tfree_netdev(dev);\n\tpci_iounmap(pdev, port_base);\n\tpci_release_regions(pdev);\n\tpci_disable_device(pdev);\n}\n\nstatic int __maybe_unused sc92031_suspend(struct device *dev_d)\n{\n\tstruct net_device *dev = dev_get_drvdata(dev_d);\n\tstruct sc92031_priv *priv = netdev_priv(dev);\n\n\tif (!netif_running(dev))\n\t\treturn 0;\n\n\tnetif_device_detach(dev);\n\n\t \n\tsc92031_disable_interrupts(dev);\n\n\tspin_lock_bh(&priv->lock);\n\n\t_sc92031_disable_tx_rx(dev);\n\t_sc92031_tx_clear(dev);\n\n\tspin_unlock_bh(&priv->lock);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused sc92031_resume(struct device *dev_d)\n{\n\tstruct net_device *dev = dev_get_drvdata(dev_d);\n\tstruct sc92031_priv *priv = netdev_priv(dev);\n\n\tif (!netif_running(dev))\n\t\treturn 0;\n\n\t \n\tspin_lock_bh(&priv->lock);\n\n\t_sc92031_reset(dev);\n\n\tspin_unlock_bh(&priv->lock);\n\tsc92031_enable_interrupts(dev);\n\n\tnetif_device_attach(dev);\n\n\tif (netif_carrier_ok(dev))\n\t\tnetif_wake_queue(dev);\n\telse\n\t\tnetif_tx_disable(dev);\n\n\treturn 0;\n}\n\nstatic const struct pci_device_id sc92031_pci_device_id_table[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_SILAN, 0x2031) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_SILAN, 0x8139) },\n\t{ PCI_DEVICE(0x1088, 0x2031) },\n\t{ 0, }\n};\nMODULE_DEVICE_TABLE(pci, sc92031_pci_device_id_table);\n\nstatic SIMPLE_DEV_PM_OPS(sc92031_pm_ops, sc92031_suspend, sc92031_resume);\n\nstatic struct pci_driver sc92031_pci_driver = {\n\t.name\t\t= SC92031_NAME,\n\t.id_table\t= sc92031_pci_device_id_table,\n\t.probe\t\t= sc92031_probe,\n\t.remove\t\t= sc92031_remove,\n\t.driver.pm\t= &sc92031_pm_ops,\n};\n\nmodule_pci_driver(sc92031_pci_driver);\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Cesar Eduardo Barros <cesarb@cesarb.net>\");\nMODULE_DESCRIPTION(\"Silan SC92031 PCI Fast Ethernet Adapter driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}