{
  "module_name": "ks8851_spi.c",
  "hash_id": "934aafb9ba3d7655495ed8c3f74ad67d4f352a0b0285da82c4bacb64eb34750e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/micrel/ks8851_spi.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/ethtool.h>\n#include <linux/cache.h>\n#include <linux/crc32.h>\n#include <linux/mii.h>\n#include <linux/regulator/consumer.h>\n\n#include <linux/spi/spi.h>\n#include <linux/gpio.h>\n#include <linux/of_gpio.h>\n#include <linux/of_net.h>\n\n#include \"ks8851.h\"\n\nstatic int msg_enable;\n\n \nstruct ks8851_net_spi {\n\tstruct ks8851_net\tks8851;\n\tstruct mutex\t\tlock;\n\tstruct work_struct\ttx_work;\n\tstruct spi_device\t*spidev;\n\tstruct spi_message\tspi_msg1;\n\tstruct spi_message\tspi_msg2;\n\tstruct spi_transfer\tspi_xfer1;\n\tstruct spi_transfer\tspi_xfer2[2];\n};\n\n#define to_ks8851_spi(ks) container_of((ks), struct ks8851_net_spi, ks8851)\n\n \n#define KS_SPIOP_RD\t0x00\n#define KS_SPIOP_WR\t0x40\n#define KS_SPIOP_RXFIFO\t0x80\n#define KS_SPIOP_TXFIFO\t0xC0\n\n \n#define BYTE_EN(_x)\t((_x) << 2)\n\n \n#define MK_OP(_byteen, _reg)\t\\\n\t(BYTE_EN(_byteen) | (_reg) << (8 + 2) | (_reg) >> 6)\n\n \nstatic void ks8851_lock_spi(struct ks8851_net *ks, unsigned long *flags)\n{\n\tstruct ks8851_net_spi *kss = to_ks8851_spi(ks);\n\n\tmutex_lock(&kss->lock);\n}\n\n \nstatic void ks8851_unlock_spi(struct ks8851_net *ks, unsigned long *flags)\n{\n\tstruct ks8851_net_spi *kss = to_ks8851_spi(ks);\n\n\tmutex_unlock(&kss->lock);\n}\n\n \n\n \nstatic void ks8851_wrreg16_spi(struct ks8851_net *ks, unsigned int reg,\n\t\t\t       unsigned int val)\n{\n\tstruct ks8851_net_spi *kss = to_ks8851_spi(ks);\n\tstruct spi_transfer *xfer = &kss->spi_xfer1;\n\tstruct spi_message *msg = &kss->spi_msg1;\n\t__le16 txb[2];\n\tint ret;\n\n\ttxb[0] = cpu_to_le16(MK_OP(reg & 2 ? 0xC : 0x03, reg) | KS_SPIOP_WR);\n\ttxb[1] = cpu_to_le16(val);\n\n\txfer->tx_buf = txb;\n\txfer->rx_buf = NULL;\n\txfer->len = 4;\n\n\tret = spi_sync(kss->spidev, msg);\n\tif (ret < 0)\n\t\tnetdev_err(ks->netdev, \"spi_sync() failed\\n\");\n}\n\n \nstatic void ks8851_rdreg(struct ks8851_net *ks, unsigned int op,\n\t\t\t u8 *rxb, unsigned int rxl)\n{\n\tstruct ks8851_net_spi *kss = to_ks8851_spi(ks);\n\tstruct spi_transfer *xfer;\n\tstruct spi_message *msg;\n\t__le16 *txb = (__le16 *)ks->txd;\n\tu8 *trx = ks->rxd;\n\tint ret;\n\n\ttxb[0] = cpu_to_le16(op | KS_SPIOP_RD);\n\n\tif (kss->spidev->master->flags & SPI_MASTER_HALF_DUPLEX) {\n\t\tmsg = &kss->spi_msg2;\n\t\txfer = kss->spi_xfer2;\n\n\t\txfer->tx_buf = txb;\n\t\txfer->rx_buf = NULL;\n\t\txfer->len = 2;\n\n\t\txfer++;\n\t\txfer->tx_buf = NULL;\n\t\txfer->rx_buf = trx;\n\t\txfer->len = rxl;\n\t} else {\n\t\tmsg = &kss->spi_msg1;\n\t\txfer = &kss->spi_xfer1;\n\n\t\txfer->tx_buf = txb;\n\t\txfer->rx_buf = trx;\n\t\txfer->len = rxl + 2;\n\t}\n\n\tret = spi_sync(kss->spidev, msg);\n\tif (ret < 0)\n\t\tnetdev_err(ks->netdev, \"read: spi_sync() failed\\n\");\n\telse if (kss->spidev->master->flags & SPI_MASTER_HALF_DUPLEX)\n\t\tmemcpy(rxb, trx, rxl);\n\telse\n\t\tmemcpy(rxb, trx + 2, rxl);\n}\n\n \nstatic unsigned int ks8851_rdreg16_spi(struct ks8851_net *ks, unsigned int reg)\n{\n\t__le16 rx = 0;\n\n\tks8851_rdreg(ks, MK_OP(reg & 2 ? 0xC : 0x3, reg), (u8 *)&rx, 2);\n\treturn le16_to_cpu(rx);\n}\n\n \nstatic void ks8851_rdfifo_spi(struct ks8851_net *ks, u8 *buff, unsigned int len)\n{\n\tstruct ks8851_net_spi *kss = to_ks8851_spi(ks);\n\tstruct spi_transfer *xfer = kss->spi_xfer2;\n\tstruct spi_message *msg = &kss->spi_msg2;\n\tu8 txb[1];\n\tint ret;\n\n\tnetif_dbg(ks, rx_status, ks->netdev,\n\t\t  \"%s: %d@%p\\n\", __func__, len, buff);\n\n\t \n\ttxb[0] = KS_SPIOP_RXFIFO;\n\n\txfer->tx_buf = txb;\n\txfer->rx_buf = NULL;\n\txfer->len = 1;\n\n\txfer++;\n\txfer->rx_buf = buff;\n\txfer->tx_buf = NULL;\n\txfer->len = len;\n\n\tret = spi_sync(kss->spidev, msg);\n\tif (ret < 0)\n\t\tnetdev_err(ks->netdev, \"%s: spi_sync() failed\\n\", __func__);\n}\n\n \nstatic void ks8851_wrfifo_spi(struct ks8851_net *ks, struct sk_buff *txp,\n\t\t\t      bool irq)\n{\n\tstruct ks8851_net_spi *kss = to_ks8851_spi(ks);\n\tstruct spi_transfer *xfer = kss->spi_xfer2;\n\tstruct spi_message *msg = &kss->spi_msg2;\n\tunsigned int fid = 0;\n\tint ret;\n\n\tnetif_dbg(ks, tx_queued, ks->netdev, \"%s: skb %p, %d@%p, irq %d\\n\",\n\t\t  __func__, txp, txp->len, txp->data, irq);\n\n\tfid = ks->fid++;\n\tfid &= TXFR_TXFID_MASK;\n\n\tif (irq)\n\t\tfid |= TXFR_TXIC;\t \n\n\t \n\tks->txh.txb[1] = KS_SPIOP_TXFIFO;\n\tks->txh.txw[1] = cpu_to_le16(fid);\n\tks->txh.txw[2] = cpu_to_le16(txp->len);\n\n\txfer->tx_buf = &ks->txh.txb[1];\n\txfer->rx_buf = NULL;\n\txfer->len = 5;\n\n\txfer++;\n\txfer->tx_buf = txp->data;\n\txfer->rx_buf = NULL;\n\txfer->len = ALIGN(txp->len, 4);\n\n\tret = spi_sync(kss->spidev, msg);\n\tif (ret < 0)\n\t\tnetdev_err(ks->netdev, \"%s: spi_sync() failed\\n\", __func__);\n}\n\n \nstatic unsigned int calc_txlen(unsigned int len)\n{\n\treturn ALIGN(len + 4, 4);\n}\n\n \nstatic void ks8851_rx_skb_spi(struct ks8851_net *ks, struct sk_buff *skb)\n{\n\tnetif_rx(skb);\n}\n\n \nstatic void ks8851_tx_work(struct work_struct *work)\n{\n\tunsigned int dequeued_len = 0;\n\tstruct ks8851_net_spi *kss;\n\tunsigned short tx_space;\n\tstruct ks8851_net *ks;\n\tunsigned long flags;\n\tstruct sk_buff *txb;\n\tbool last;\n\n\tkss = container_of(work, struct ks8851_net_spi, tx_work);\n\tks = &kss->ks8851;\n\tlast = skb_queue_empty(&ks->txq);\n\n\tks8851_lock_spi(ks, &flags);\n\n\twhile (!last) {\n\t\ttxb = skb_dequeue(&ks->txq);\n\t\tlast = skb_queue_empty(&ks->txq);\n\n\t\tif (txb) {\n\t\t\tdequeued_len += calc_txlen(txb->len);\n\n\t\t\tks8851_wrreg16_spi(ks, KS_RXQCR,\n\t\t\t\t\t   ks->rc_rxqcr | RXQCR_SDA);\n\t\t\tks8851_wrfifo_spi(ks, txb, last);\n\t\t\tks8851_wrreg16_spi(ks, KS_RXQCR, ks->rc_rxqcr);\n\t\t\tks8851_wrreg16_spi(ks, KS_TXQCR, TXQCR_METFE);\n\n\t\t\tks8851_done_tx(ks, txb);\n\t\t}\n\t}\n\n\ttx_space = ks8851_rdreg16_spi(ks, KS_TXMIR);\n\n\tspin_lock(&ks->statelock);\n\tks->queued_len -= dequeued_len;\n\tks->tx_space = tx_space;\n\tspin_unlock(&ks->statelock);\n\n\tks8851_unlock_spi(ks, &flags);\n}\n\n \nstatic void ks8851_flush_tx_work_spi(struct ks8851_net *ks)\n{\n\tstruct ks8851_net_spi *kss = to_ks8851_spi(ks);\n\n\tflush_work(&kss->tx_work);\n}\n\n \nstatic netdev_tx_t ks8851_start_xmit_spi(struct sk_buff *skb,\n\t\t\t\t\t struct net_device *dev)\n{\n\tunsigned int needed = calc_txlen(skb->len);\n\tstruct ks8851_net *ks = netdev_priv(dev);\n\tnetdev_tx_t ret = NETDEV_TX_OK;\n\tstruct ks8851_net_spi *kss;\n\n\tkss = to_ks8851_spi(ks);\n\n\tnetif_dbg(ks, tx_queued, ks->netdev,\n\t\t  \"%s: skb %p, %d@%p\\n\", __func__, skb, skb->len, skb->data);\n\n\tspin_lock(&ks->statelock);\n\n\tif (ks->queued_len + needed > ks->tx_space) {\n\t\tnetif_stop_queue(dev);\n\t\tret = NETDEV_TX_BUSY;\n\t} else {\n\t\tks->queued_len += needed;\n\t\tskb_queue_tail(&ks->txq, skb);\n\t}\n\n\tspin_unlock(&ks->statelock);\n\tif (ret == NETDEV_TX_OK)\n\t\tschedule_work(&kss->tx_work);\n\n\treturn ret;\n}\n\nstatic int ks8851_probe_spi(struct spi_device *spi)\n{\n\tstruct device *dev = &spi->dev;\n\tstruct ks8851_net_spi *kss;\n\tstruct net_device *netdev;\n\tstruct ks8851_net *ks;\n\n\tnetdev = devm_alloc_etherdev(dev, sizeof(struct ks8851_net_spi));\n\tif (!netdev)\n\t\treturn -ENOMEM;\n\n\tspi->bits_per_word = 8;\n\n\tkss = netdev_priv(netdev);\n\tks = &kss->ks8851;\n\n\tks->lock = ks8851_lock_spi;\n\tks->unlock = ks8851_unlock_spi;\n\tks->rdreg16 = ks8851_rdreg16_spi;\n\tks->wrreg16 = ks8851_wrreg16_spi;\n\tks->rdfifo = ks8851_rdfifo_spi;\n\tks->wrfifo = ks8851_wrfifo_spi;\n\tks->start_xmit = ks8851_start_xmit_spi;\n\tks->rx_skb = ks8851_rx_skb_spi;\n\tks->flush_tx_work = ks8851_flush_tx_work_spi;\n\n#define STD_IRQ (IRQ_LCI |\t \t\\\n\t\t IRQ_TXI |\t \t\t\\\n\t\t IRQ_RXI |\t \t\t\\\n\t\t IRQ_SPIBEI |\t \t\\\n\t\t IRQ_TXPSI |\t \t\\\n\t\t IRQ_RXPSI)\t \n\tks->rc_ier = STD_IRQ;\n\n\tkss->spidev = spi;\n\tmutex_init(&kss->lock);\n\tINIT_WORK(&kss->tx_work, ks8851_tx_work);\n\n\t \n\tspi_message_init(&kss->spi_msg1);\n\tspi_message_add_tail(&kss->spi_xfer1, &kss->spi_msg1);\n\n\tspi_message_init(&kss->spi_msg2);\n\tspi_message_add_tail(&kss->spi_xfer2[0], &kss->spi_msg2);\n\tspi_message_add_tail(&kss->spi_xfer2[1], &kss->spi_msg2);\n\n\tnetdev->irq = spi->irq;\n\n\treturn ks8851_probe_common(netdev, dev, msg_enable);\n}\n\nstatic void ks8851_remove_spi(struct spi_device *spi)\n{\n\tks8851_remove_common(&spi->dev);\n}\n\nstatic const struct of_device_id ks8851_match_table[] = {\n\t{ .compatible = \"micrel,ks8851\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, ks8851_match_table);\n\nstatic struct spi_driver ks8851_driver = {\n\t.driver = {\n\t\t.name = \"ks8851\",\n\t\t.of_match_table = ks8851_match_table,\n\t\t.pm = &ks8851_pm_ops,\n\t},\n\t.probe = ks8851_probe_spi,\n\t.remove = ks8851_remove_spi,\n};\nmodule_spi_driver(ks8851_driver);\n\nMODULE_DESCRIPTION(\"KS8851 Network driver\");\nMODULE_AUTHOR(\"Ben Dooks <ben@simtec.co.uk>\");\nMODULE_LICENSE(\"GPL\");\n\nmodule_param_named(message, msg_enable, int, 0);\nMODULE_PARM_DESC(message, \"Message verbosity level (0=none, 31=all)\");\nMODULE_ALIAS(\"spi:ks8851\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}