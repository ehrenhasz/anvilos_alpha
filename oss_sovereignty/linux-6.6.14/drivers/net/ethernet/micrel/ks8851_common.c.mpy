{
  "module_name": "ks8851_common.c",
  "hash_id": "031f033aefb1337b941a7d7060739a7ca4b0810476cb3202f4fd9f96a76d47c3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/micrel/ks8851_common.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/ethtool.h>\n#include <linux/cache.h>\n#include <linux/crc32.h>\n#include <linux/mii.h>\n#include <linux/gpio/consumer.h>\n#include <linux/regulator/consumer.h>\n\n#include <linux/of_mdio.h>\n#include <linux/of_net.h>\n\n#include \"ks8851.h\"\n\n \nstatic void ks8851_lock(struct ks8851_net *ks, unsigned long *flags)\n{\n\tks->lock(ks, flags);\n}\n\n \nstatic void ks8851_unlock(struct ks8851_net *ks, unsigned long *flags)\n{\n\tks->unlock(ks, flags);\n}\n\n \nstatic void ks8851_wrreg16(struct ks8851_net *ks, unsigned int reg,\n\t\t\t   unsigned int val)\n{\n\tks->wrreg16(ks, reg, val);\n}\n\n \nstatic unsigned int ks8851_rdreg16(struct ks8851_net *ks,\n\t\t\t\t   unsigned int reg)\n{\n\treturn ks->rdreg16(ks, reg);\n}\n\n \nstatic void ks8851_soft_reset(struct ks8851_net *ks, unsigned op)\n{\n\tks8851_wrreg16(ks, KS_GRR, op);\n\tmdelay(1);\t \n\tks8851_wrreg16(ks, KS_GRR, 0);\n\tmdelay(1);\t \n}\n\n \nstatic void ks8851_set_powermode(struct ks8851_net *ks, unsigned pwrmode)\n{\n\tunsigned pmecr;\n\n\tnetif_dbg(ks, hw, ks->netdev, \"setting power mode %d\\n\", pwrmode);\n\n\tpmecr = ks8851_rdreg16(ks, KS_PMECR);\n\tpmecr &= ~PMECR_PM_MASK;\n\tpmecr |= pwrmode;\n\n\tks8851_wrreg16(ks, KS_PMECR, pmecr);\n}\n\n \nstatic int ks8851_write_mac_addr(struct net_device *dev)\n{\n\tstruct ks8851_net *ks = netdev_priv(dev);\n\tunsigned long flags;\n\tu16 val;\n\tint i;\n\n\tks8851_lock(ks, &flags);\n\n\t \n\tks8851_set_powermode(ks, PMECR_PM_NORMAL);\n\n\tfor (i = 0; i < ETH_ALEN; i += 2) {\n\t\tval = (dev->dev_addr[i] << 8) | dev->dev_addr[i + 1];\n\t\tks8851_wrreg16(ks, KS_MAR(i), val);\n\t}\n\n\tif (!netif_running(dev))\n\t\tks8851_set_powermode(ks, PMECR_PM_SOFTDOWN);\n\n\tks8851_unlock(ks, &flags);\n\n\treturn 0;\n}\n\n \nstatic void ks8851_read_mac_addr(struct net_device *dev)\n{\n\tstruct ks8851_net *ks = netdev_priv(dev);\n\tunsigned long flags;\n\tu8 addr[ETH_ALEN];\n\tu16 reg;\n\tint i;\n\n\tks8851_lock(ks, &flags);\n\n\tfor (i = 0; i < ETH_ALEN; i += 2) {\n\t\treg = ks8851_rdreg16(ks, KS_MAR(i));\n\t\taddr[i] = reg >> 8;\n\t\taddr[i + 1] = reg & 0xff;\n\t}\n\teth_hw_addr_set(dev, addr);\n\n\tks8851_unlock(ks, &flags);\n}\n\n \nstatic void ks8851_init_mac(struct ks8851_net *ks, struct device_node *np)\n{\n\tstruct net_device *dev = ks->netdev;\n\tint ret;\n\n\tret = of_get_ethdev_address(np, dev);\n\tif (!ret) {\n\t\tks8851_write_mac_addr(dev);\n\t\treturn;\n\t}\n\n\tif (ks->rc_ccr & CCR_EEPROM) {\n\t\tks8851_read_mac_addr(dev);\n\t\tif (is_valid_ether_addr(dev->dev_addr))\n\t\t\treturn;\n\n\t\tnetdev_err(ks->netdev, \"invalid mac address read %pM\\n\",\n\t\t\t\tdev->dev_addr);\n\t}\n\n\teth_hw_addr_random(dev);\n\tks8851_write_mac_addr(dev);\n}\n\n \nstatic void ks8851_dbg_dumpkkt(struct ks8851_net *ks, u8 *rxpkt)\n{\n\tnetdev_dbg(ks->netdev,\n\t\t   \"pkt %02x%02x%02x%02x %02x%02x%02x%02x %02x%02x%02x%02x\\n\",\n\t\t   rxpkt[4], rxpkt[5], rxpkt[6], rxpkt[7],\n\t\t   rxpkt[8], rxpkt[9], rxpkt[10], rxpkt[11],\n\t\t   rxpkt[12], rxpkt[13], rxpkt[14], rxpkt[15]);\n}\n\n \nstatic void ks8851_rx_skb(struct ks8851_net *ks, struct sk_buff *skb)\n{\n\tks->rx_skb(ks, skb);\n}\n\n \nstatic void ks8851_rx_pkts(struct ks8851_net *ks)\n{\n\tstruct sk_buff *skb;\n\tunsigned rxfc;\n\tunsigned rxlen;\n\tunsigned rxstat;\n\tu8 *rxpkt;\n\n\trxfc = (ks8851_rdreg16(ks, KS_RXFCTR) >> 8) & 0xff;\n\n\tnetif_dbg(ks, rx_status, ks->netdev,\n\t\t  \"%s: %d packets\\n\", __func__, rxfc);\n\n\t \n\n\tfor (; rxfc != 0; rxfc--) {\n\t\trxstat = ks8851_rdreg16(ks, KS_RXFHSR);\n\t\trxlen = ks8851_rdreg16(ks, KS_RXFHBCR) & RXFHBCR_CNT_MASK;\n\n\t\tnetif_dbg(ks, rx_status, ks->netdev,\n\t\t\t  \"rx: stat 0x%04x, len 0x%04x\\n\", rxstat, rxlen);\n\n\t\t \n\n\t\t \n\t\tks8851_wrreg16(ks, KS_RXFDPR, RXFDPR_RXFPAI | 0x00);\n\n\t\t \n\t\tks8851_wrreg16(ks, KS_RXQCR, ks->rc_rxqcr | RXQCR_SDA);\n\n\t\tif (rxlen > 4) {\n\t\t\tunsigned int rxalign;\n\n\t\t\trxlen -= 4;\n\t\t\trxalign = ALIGN(rxlen, 4);\n\t\t\tskb = netdev_alloc_skb_ip_align(ks->netdev, rxalign);\n\t\t\tif (skb) {\n\n\t\t\t\t \n\n\t\t\t\trxpkt = skb_put(skb, rxlen) - 8;\n\n\t\t\t\tks->rdfifo(ks, rxpkt, rxalign + 8);\n\n\t\t\t\tif (netif_msg_pktdata(ks))\n\t\t\t\t\tks8851_dbg_dumpkkt(ks, rxpkt);\n\n\t\t\t\tskb->protocol = eth_type_trans(skb, ks->netdev);\n\t\t\t\tks8851_rx_skb(ks, skb);\n\n\t\t\t\tks->netdev->stats.rx_packets++;\n\t\t\t\tks->netdev->stats.rx_bytes += rxlen;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tks8851_wrreg16(ks, KS_RXQCR, ks->rc_rxqcr | RXQCR_RRXEF);\n\t}\n}\n\n \nstatic irqreturn_t ks8851_irq(int irq, void *_ks)\n{\n\tstruct ks8851_net *ks = _ks;\n\tunsigned handled = 0;\n\tunsigned long flags;\n\tunsigned int status;\n\n\tks8851_lock(ks, &flags);\n\n\tstatus = ks8851_rdreg16(ks, KS_ISR);\n\n\tnetif_dbg(ks, intr, ks->netdev,\n\t\t  \"%s: status 0x%04x\\n\", __func__, status);\n\n\tif (status & IRQ_LCI)\n\t\thandled |= IRQ_LCI;\n\n\tif (status & IRQ_LDI) {\n\t\tu16 pmecr = ks8851_rdreg16(ks, KS_PMECR);\n\t\tpmecr &= ~PMECR_WKEVT_MASK;\n\t\tks8851_wrreg16(ks, KS_PMECR, pmecr | PMECR_WKEVT_LINK);\n\n\t\thandled |= IRQ_LDI;\n\t}\n\n\tif (status & IRQ_RXPSI)\n\t\thandled |= IRQ_RXPSI;\n\n\tif (status & IRQ_TXI) {\n\t\tunsigned short tx_space = ks8851_rdreg16(ks, KS_TXMIR);\n\n\t\tnetif_dbg(ks, intr, ks->netdev,\n\t\t\t  \"%s: txspace %d\\n\", __func__, tx_space);\n\n\t\tspin_lock(&ks->statelock);\n\t\tks->tx_space = tx_space;\n\t\tif (netif_queue_stopped(ks->netdev))\n\t\t\tnetif_wake_queue(ks->netdev);\n\t\tspin_unlock(&ks->statelock);\n\n\t\thandled |= IRQ_TXI;\n\t}\n\n\tif (status & IRQ_RXI)\n\t\thandled |= IRQ_RXI;\n\n\tif (status & IRQ_SPIBEI) {\n\t\tnetdev_err(ks->netdev, \"%s: spi bus error\\n\", __func__);\n\t\thandled |= IRQ_SPIBEI;\n\t}\n\n\tks8851_wrreg16(ks, KS_ISR, handled);\n\n\tif (status & IRQ_RXI) {\n\t\t \n\n\t\tks8851_rx_pkts(ks);\n\t}\n\n\t \n\tif (status & IRQ_RXPSI) {\n\t\tstruct ks8851_rxctrl *rxc = &ks->rxctrl;\n\n\t\t \n\t\tks8851_wrreg16(ks, KS_MAHTR0, rxc->mchash[0]);\n\t\tks8851_wrreg16(ks, KS_MAHTR1, rxc->mchash[1]);\n\t\tks8851_wrreg16(ks, KS_MAHTR2, rxc->mchash[2]);\n\t\tks8851_wrreg16(ks, KS_MAHTR3, rxc->mchash[3]);\n\n\t\tks8851_wrreg16(ks, KS_RXCR2, rxc->rxcr2);\n\t\tks8851_wrreg16(ks, KS_RXCR1, rxc->rxcr1);\n\t}\n\n\tks8851_unlock(ks, &flags);\n\n\tif (status & IRQ_LCI)\n\t\tmii_check_link(&ks->mii);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic void ks8851_flush_tx_work(struct ks8851_net *ks)\n{\n\tif (ks->flush_tx_work)\n\t\tks->flush_tx_work(ks);\n}\n\n \nstatic int ks8851_net_open(struct net_device *dev)\n{\n\tstruct ks8851_net *ks = netdev_priv(dev);\n\tunsigned long flags;\n\tint ret;\n\n\tret = request_threaded_irq(dev->irq, NULL, ks8851_irq,\n\t\t\t\t   IRQF_TRIGGER_LOW | IRQF_ONESHOT,\n\t\t\t\t   dev->name, ks);\n\tif (ret < 0) {\n\t\tnetdev_err(dev, \"failed to get irq\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tks8851_lock(ks, &flags);\n\n\tnetif_dbg(ks, ifup, ks->netdev, \"opening\\n\");\n\n\t \n\tks8851_set_powermode(ks, PMECR_PM_NORMAL);\n\n\t \n\tks8851_soft_reset(ks, GRR_QMU);\n\n\t \n\n\tks8851_wrreg16(ks, KS_TXCR, (TXCR_TXE |  \n\t\t\t\t     TXCR_TXPE |  \n\t\t\t\t     TXCR_TXCRC |  \n\t\t\t\t     TXCR_TXFCE));  \n\n\t \n\tks8851_wrreg16(ks, KS_TXFDPR, TXFDPR_TXFPAI);\n\n\t \n\n\tks8851_wrreg16(ks, KS_RXCR1, (RXCR1_RXPAFMA |  \n\t\t\t\t      RXCR1_RXFCE |  \n\t\t\t\t      RXCR1_RXBE |  \n\t\t\t\t      RXCR1_RXUE |  \n\t\t\t\t      RXCR1_RXE));  \n\n\t \n\tks8851_wrreg16(ks, KS_RXCR2, RXCR2_SRDBL_FRAME);\n\n\t \n\tks8851_wrreg16(ks, KS_RXDTTR, 1000);  \n\tks8851_wrreg16(ks, KS_RXDBCTR, 4096);  \n\tks8851_wrreg16(ks, KS_RXFCTR, 10);   \n\n\tks->rc_rxqcr = (RXQCR_RXFCTE |   \n\t\t\tRXQCR_RXDBCTE |  \n\t\t\tRXQCR_RXDTTE);   \n\n\tks8851_wrreg16(ks, KS_RXQCR, ks->rc_rxqcr);\n\n\t \n\tks8851_wrreg16(ks, KS_ISR, ks->rc_ier);\n\tks8851_wrreg16(ks, KS_IER, ks->rc_ier);\n\n\tks->queued_len = 0;\n\tnetif_start_queue(ks->netdev);\n\n\tnetif_dbg(ks, ifup, ks->netdev, \"network device up\\n\");\n\n\tks8851_unlock(ks, &flags);\n\tmii_check_link(&ks->mii);\n\treturn 0;\n}\n\n \nstatic int ks8851_net_stop(struct net_device *dev)\n{\n\tstruct ks8851_net *ks = netdev_priv(dev);\n\tunsigned long flags;\n\n\tnetif_info(ks, ifdown, dev, \"shutting down\\n\");\n\n\tnetif_stop_queue(dev);\n\n\tks8851_lock(ks, &flags);\n\t \n\tks8851_wrreg16(ks, KS_IER, 0x0000);\n\tks8851_wrreg16(ks, KS_ISR, 0xffff);\n\tks8851_unlock(ks, &flags);\n\n\t \n\tks8851_flush_tx_work(ks);\n\tflush_work(&ks->rxctrl_work);\n\n\tks8851_lock(ks, &flags);\n\t \n\tks8851_wrreg16(ks, KS_RXCR1, 0x0000);\n\n\t \n\tks8851_wrreg16(ks, KS_TXCR, 0x0000);\n\n\t \n\tks8851_set_powermode(ks, PMECR_PM_SOFTDOWN);\n\tks8851_unlock(ks, &flags);\n\n\t \n\twhile (!skb_queue_empty(&ks->txq)) {\n\t\tstruct sk_buff *txb = skb_dequeue(&ks->txq);\n\n\t\tnetif_dbg(ks, ifdown, ks->netdev,\n\t\t\t  \"%s: freeing txb %p\\n\", __func__, txb);\n\n\t\tdev_kfree_skb(txb);\n\t}\n\n\tfree_irq(dev->irq, ks);\n\n\treturn 0;\n}\n\n \nstatic netdev_tx_t ks8851_start_xmit(struct sk_buff *skb,\n\t\t\t\t     struct net_device *dev)\n{\n\tstruct ks8851_net *ks = netdev_priv(dev);\n\n\treturn ks->start_xmit(skb, dev);\n}\n\n \nstatic void ks8851_rxctrl_work(struct work_struct *work)\n{\n\tstruct ks8851_net *ks = container_of(work, struct ks8851_net, rxctrl_work);\n\tunsigned long flags;\n\n\tks8851_lock(ks, &flags);\n\n\t \n\tks8851_wrreg16(ks, KS_RXCR1, 0x00);\n\n\tks8851_unlock(ks, &flags);\n}\n\nstatic void ks8851_set_rx_mode(struct net_device *dev)\n{\n\tstruct ks8851_net *ks = netdev_priv(dev);\n\tstruct ks8851_rxctrl rxctrl;\n\n\tmemset(&rxctrl, 0, sizeof(rxctrl));\n\n\tif (dev->flags & IFF_PROMISC) {\n\t\t \n\n\t\trxctrl.rxcr1 = RXCR1_RXAE | RXCR1_RXINVF;\n\t} else if (dev->flags & IFF_ALLMULTI) {\n\t\t \n\n\t\trxctrl.rxcr1 = (RXCR1_RXME | RXCR1_RXAE |\n\t\t\t\tRXCR1_RXPAFMA | RXCR1_RXMAFMA);\n\t} else if (dev->flags & IFF_MULTICAST && !netdev_mc_empty(dev)) {\n\t\tstruct netdev_hw_addr *ha;\n\t\tu32 crc;\n\n\t\t \n\n\t\tnetdev_for_each_mc_addr(ha, dev) {\n\t\t\tcrc = ether_crc(ETH_ALEN, ha->addr);\n\t\t\tcrc >>= (32 - 6);   \n\n\t\t\trxctrl.mchash[crc >> 4] |= (1 << (crc & 0xf));\n\t\t}\n\n\t\trxctrl.rxcr1 = RXCR1_RXME | RXCR1_RXPAFMA;\n\t} else {\n\t\t \n\t\trxctrl.rxcr1 = RXCR1_RXPAFMA;\n\t}\n\n\trxctrl.rxcr1 |= (RXCR1_RXUE |  \n\t\t\t RXCR1_RXBE |  \n\t\t\t RXCR1_RXE |  \n\t\t\t RXCR1_RXFCE);  \n\n\trxctrl.rxcr2 |= RXCR2_SRDBL_FRAME;\n\n\t \n\n\tspin_lock(&ks->statelock);\n\n\tif (memcmp(&rxctrl, &ks->rxctrl, sizeof(rxctrl)) != 0) {\n\t\tmemcpy(&ks->rxctrl, &rxctrl, sizeof(ks->rxctrl));\n\t\tschedule_work(&ks->rxctrl_work);\n\t}\n\n\tspin_unlock(&ks->statelock);\n}\n\nstatic int ks8851_set_mac_address(struct net_device *dev, void *addr)\n{\n\tstruct sockaddr *sa = addr;\n\n\tif (netif_running(dev))\n\t\treturn -EBUSY;\n\n\tif (!is_valid_ether_addr(sa->sa_data))\n\t\treturn -EADDRNOTAVAIL;\n\n\teth_hw_addr_set(dev, sa->sa_data);\n\treturn ks8851_write_mac_addr(dev);\n}\n\nstatic int ks8851_net_ioctl(struct net_device *dev, struct ifreq *req, int cmd)\n{\n\tstruct ks8851_net *ks = netdev_priv(dev);\n\n\tif (!netif_running(dev))\n\t\treturn -EINVAL;\n\n\treturn generic_mii_ioctl(&ks->mii, if_mii(req), cmd, NULL);\n}\n\nstatic const struct net_device_ops ks8851_netdev_ops = {\n\t.ndo_open\t\t= ks8851_net_open,\n\t.ndo_stop\t\t= ks8851_net_stop,\n\t.ndo_eth_ioctl\t\t= ks8851_net_ioctl,\n\t.ndo_start_xmit\t\t= ks8851_start_xmit,\n\t.ndo_set_mac_address\t= ks8851_set_mac_address,\n\t.ndo_set_rx_mode\t= ks8851_set_rx_mode,\n\t.ndo_validate_addr\t= eth_validate_addr,\n};\n\n \n\nstatic void ks8851_get_drvinfo(struct net_device *dev,\n\t\t\t       struct ethtool_drvinfo *di)\n{\n\tstrscpy(di->driver, \"KS8851\", sizeof(di->driver));\n\tstrscpy(di->version, \"1.00\", sizeof(di->version));\n\tstrscpy(di->bus_info, dev_name(dev->dev.parent), sizeof(di->bus_info));\n}\n\nstatic u32 ks8851_get_msglevel(struct net_device *dev)\n{\n\tstruct ks8851_net *ks = netdev_priv(dev);\n\treturn ks->msg_enable;\n}\n\nstatic void ks8851_set_msglevel(struct net_device *dev, u32 to)\n{\n\tstruct ks8851_net *ks = netdev_priv(dev);\n\tks->msg_enable = to;\n}\n\nstatic int ks8851_get_link_ksettings(struct net_device *dev,\n\t\t\t\t     struct ethtool_link_ksettings *cmd)\n{\n\tstruct ks8851_net *ks = netdev_priv(dev);\n\n\tmii_ethtool_get_link_ksettings(&ks->mii, cmd);\n\n\treturn 0;\n}\n\nstatic int ks8851_set_link_ksettings(struct net_device *dev,\n\t\t\t\t     const struct ethtool_link_ksettings *cmd)\n{\n\tstruct ks8851_net *ks = netdev_priv(dev);\n\treturn mii_ethtool_set_link_ksettings(&ks->mii, cmd);\n}\n\nstatic u32 ks8851_get_link(struct net_device *dev)\n{\n\tstruct ks8851_net *ks = netdev_priv(dev);\n\treturn mii_link_ok(&ks->mii);\n}\n\nstatic int ks8851_nway_reset(struct net_device *dev)\n{\n\tstruct ks8851_net *ks = netdev_priv(dev);\n\treturn mii_nway_restart(&ks->mii);\n}\n\n \n\nstatic void ks8851_eeprom_regread(struct eeprom_93cx6 *ee)\n{\n\tstruct ks8851_net *ks = ee->data;\n\tunsigned val;\n\n\tval = ks8851_rdreg16(ks, KS_EEPCR);\n\n\tee->reg_data_out = (val & EEPCR_EESB) ? 1 : 0;\n\tee->reg_data_clock = (val & EEPCR_EESCK) ? 1 : 0;\n\tee->reg_chip_select = (val & EEPCR_EECS) ? 1 : 0;\n}\n\nstatic void ks8851_eeprom_regwrite(struct eeprom_93cx6 *ee)\n{\n\tstruct ks8851_net *ks = ee->data;\n\tunsigned val = EEPCR_EESA;\t \n\n\tif (ee->drive_data)\n\t\tval |= EEPCR_EESRWA;\n\tif (ee->reg_data_in)\n\t\tval |= EEPCR_EEDO;\n\tif (ee->reg_data_clock)\n\t\tval |= EEPCR_EESCK;\n\tif (ee->reg_chip_select)\n\t\tval |= EEPCR_EECS;\n\n\tks8851_wrreg16(ks, KS_EEPCR, val);\n}\n\n \nstatic int ks8851_eeprom_claim(struct ks8851_net *ks)\n{\n\t \n\tks8851_wrreg16(ks, KS_EEPCR, EEPCR_EESA | EEPCR_EECS);\n\treturn 0;\n}\n\n \nstatic void ks8851_eeprom_release(struct ks8851_net *ks)\n{\n\tunsigned val = ks8851_rdreg16(ks, KS_EEPCR);\n\n\tks8851_wrreg16(ks, KS_EEPCR, val & ~EEPCR_EESA);\n}\n\n#define KS_EEPROM_MAGIC (0x00008851)\n\nstatic int ks8851_set_eeprom(struct net_device *dev,\n\t\t\t     struct ethtool_eeprom *ee, u8 *data)\n{\n\tstruct ks8851_net *ks = netdev_priv(dev);\n\tint offset = ee->offset;\n\tunsigned long flags;\n\tint len = ee->len;\n\tu16 tmp;\n\n\t \n\tif (len != 1)\n\t\treturn -EINVAL;\n\n\tif (ee->magic != KS_EEPROM_MAGIC)\n\t\treturn -EINVAL;\n\n\tif (!(ks->rc_ccr & CCR_EEPROM))\n\t\treturn -ENOENT;\n\n\tks8851_lock(ks, &flags);\n\n\tks8851_eeprom_claim(ks);\n\n\teeprom_93cx6_wren(&ks->eeprom, true);\n\n\t \n\n\teeprom_93cx6_read(&ks->eeprom, offset/2, &tmp);\n\n\tif (offset & 1) {\n\t\ttmp &= 0xff;\n\t\ttmp |= *data << 8;\n\t} else {\n\t\ttmp &= 0xff00;\n\t\ttmp |= *data;\n\t}\n\n\teeprom_93cx6_write(&ks->eeprom, offset/2, tmp);\n\teeprom_93cx6_wren(&ks->eeprom, false);\n\n\tks8851_eeprom_release(ks);\n\tks8851_unlock(ks, &flags);\n\n\treturn 0;\n}\n\nstatic int ks8851_get_eeprom(struct net_device *dev,\n\t\t\t     struct ethtool_eeprom *ee, u8 *data)\n{\n\tstruct ks8851_net *ks = netdev_priv(dev);\n\tint offset = ee->offset;\n\tunsigned long flags;\n\tint len = ee->len;\n\n\t \n\tif (len & 1 || offset & 1)\n\t\treturn -EINVAL;\n\n\tif (!(ks->rc_ccr & CCR_EEPROM))\n\t\treturn -ENOENT;\n\n\tks8851_lock(ks, &flags);\n\n\tks8851_eeprom_claim(ks);\n\n\tee->magic = KS_EEPROM_MAGIC;\n\n\teeprom_93cx6_multiread(&ks->eeprom, offset/2, (__le16 *)data, len/2);\n\tks8851_eeprom_release(ks);\n\tks8851_unlock(ks, &flags);\n\n\treturn 0;\n}\n\nstatic int ks8851_get_eeprom_len(struct net_device *dev)\n{\n\tstruct ks8851_net *ks = netdev_priv(dev);\n\n\t \n\treturn ks->rc_ccr & CCR_EEPROM ? 128 : 0;\n}\n\nstatic const struct ethtool_ops ks8851_ethtool_ops = {\n\t.get_drvinfo\t= ks8851_get_drvinfo,\n\t.get_msglevel\t= ks8851_get_msglevel,\n\t.set_msglevel\t= ks8851_set_msglevel,\n\t.get_link\t= ks8851_get_link,\n\t.nway_reset\t= ks8851_nway_reset,\n\t.get_eeprom_len\t= ks8851_get_eeprom_len,\n\t.get_eeprom\t= ks8851_get_eeprom,\n\t.set_eeprom\t= ks8851_set_eeprom,\n\t.get_link_ksettings = ks8851_get_link_ksettings,\n\t.set_link_ksettings = ks8851_set_link_ksettings,\n};\n\n \n\n \nstatic int ks8851_phy_reg(int reg)\n{\n\tswitch (reg) {\n\tcase MII_BMCR:\n\t\treturn KS_P1MBCR;\n\tcase MII_BMSR:\n\t\treturn KS_P1MBSR;\n\tcase MII_PHYSID1:\n\t\treturn KS_PHY1ILR;\n\tcase MII_PHYSID2:\n\t\treturn KS_PHY1IHR;\n\tcase MII_ADVERTISE:\n\t\treturn KS_P1ANAR;\n\tcase MII_LPA:\n\t\treturn KS_P1ANLPR;\n\t}\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic int ks8851_phy_read_common(struct net_device *dev, int phy_addr, int reg)\n{\n\tstruct ks8851_net *ks = netdev_priv(dev);\n\tunsigned long flags;\n\tint result;\n\tint ksreg;\n\n\tksreg = ks8851_phy_reg(reg);\n\tif (ksreg < 0)\n\t\treturn ksreg;\n\n\tks8851_lock(ks, &flags);\n\tresult = ks8851_rdreg16(ks, ksreg);\n\tks8851_unlock(ks, &flags);\n\n\treturn result;\n}\n\n \nstatic int ks8851_phy_read(struct net_device *dev, int phy_addr, int reg)\n{\n\tint ret;\n\n\tret = ks8851_phy_read_common(dev, phy_addr, reg);\n\tif (ret < 0)\n\t\treturn 0x0;\t \n\n\treturn ret;\n}\n\nstatic void ks8851_phy_write(struct net_device *dev,\n\t\t\t     int phy, int reg, int value)\n{\n\tstruct ks8851_net *ks = netdev_priv(dev);\n\tunsigned long flags;\n\tint ksreg;\n\n\tksreg = ks8851_phy_reg(reg);\n\tif (ksreg >= 0) {\n\t\tks8851_lock(ks, &flags);\n\t\tks8851_wrreg16(ks, ksreg, value);\n\t\tks8851_unlock(ks, &flags);\n\t}\n}\n\nstatic int ks8851_mdio_read(struct mii_bus *bus, int phy_id, int reg)\n{\n\tstruct ks8851_net *ks = bus->priv;\n\n\tif (phy_id != 0)\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tif (reg == MII_PHYSID1)\n\t\treg = MII_PHYSID2;\n\telse if (reg == MII_PHYSID2)\n\t\treg = MII_PHYSID1;\n\n\treturn ks8851_phy_read_common(ks->netdev, phy_id, reg);\n}\n\nstatic int ks8851_mdio_write(struct mii_bus *bus, int phy_id, int reg, u16 val)\n{\n\tstruct ks8851_net *ks = bus->priv;\n\n\tks8851_phy_write(ks->netdev, phy_id, reg, val);\n\treturn 0;\n}\n\n \nstatic void ks8851_read_selftest(struct ks8851_net *ks)\n{\n\tunsigned both_done = MBIR_TXMBF | MBIR_RXMBF;\n\tunsigned rd;\n\n\trd = ks8851_rdreg16(ks, KS_MBIR);\n\n\tif ((rd & both_done) != both_done) {\n\t\tnetdev_warn(ks->netdev, \"Memory selftest not finished\\n\");\n\t\treturn;\n\t}\n\n\tif (rd & MBIR_TXMBFA)\n\t\tnetdev_err(ks->netdev, \"TX memory selftest fail\\n\");\n\n\tif (rd & MBIR_RXMBFA)\n\t\tnetdev_err(ks->netdev, \"RX memory selftest fail\\n\");\n}\n\n \n\n#ifdef CONFIG_PM_SLEEP\n\nint ks8851_suspend(struct device *dev)\n{\n\tstruct ks8851_net *ks = dev_get_drvdata(dev);\n\tstruct net_device *netdev = ks->netdev;\n\n\tif (netif_running(netdev)) {\n\t\tnetif_device_detach(netdev);\n\t\tks8851_net_stop(netdev);\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ks8851_suspend);\n\nint ks8851_resume(struct device *dev)\n{\n\tstruct ks8851_net *ks = dev_get_drvdata(dev);\n\tstruct net_device *netdev = ks->netdev;\n\n\tif (netif_running(netdev)) {\n\t\tks8851_net_open(netdev);\n\t\tnetif_device_attach(netdev);\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ks8851_resume);\n#endif\n\nstatic int ks8851_register_mdiobus(struct ks8851_net *ks, struct device *dev)\n{\n\tstruct mii_bus *mii_bus;\n\tint ret;\n\n\tmii_bus = mdiobus_alloc();\n\tif (!mii_bus)\n\t\treturn -ENOMEM;\n\n\tmii_bus->name = \"ks8851_eth_mii\";\n\tmii_bus->read = ks8851_mdio_read;\n\tmii_bus->write = ks8851_mdio_write;\n\tmii_bus->priv = ks;\n\tmii_bus->parent = dev;\n\tmii_bus->phy_mask = ~((u32)BIT(0));\n\tsnprintf(mii_bus->id, MII_BUS_ID_SIZE, \"%s\", dev_name(dev));\n\n\tret = mdiobus_register(mii_bus);\n\tif (ret)\n\t\tgoto err_mdiobus_register;\n\n\tks->mii_bus = mii_bus;\n\n\treturn 0;\n\nerr_mdiobus_register:\n\tmdiobus_free(mii_bus);\n\treturn ret;\n}\n\nstatic void ks8851_unregister_mdiobus(struct ks8851_net *ks)\n{\n\tmdiobus_unregister(ks->mii_bus);\n\tmdiobus_free(ks->mii_bus);\n}\n\nint ks8851_probe_common(struct net_device *netdev, struct device *dev,\n\t\t\tint msg_en)\n{\n\tstruct ks8851_net *ks = netdev_priv(netdev);\n\tunsigned cider;\n\tint ret;\n\n\tks->netdev = netdev;\n\tks->tx_space = 6144;\n\n\tks->gpio = devm_gpiod_get_optional(dev, \"reset\", GPIOD_OUT_HIGH);\n\tret = PTR_ERR_OR_ZERO(ks->gpio);\n\tif (ret) {\n\t\tif (ret != -EPROBE_DEFER)\n\t\t\tdev_err(dev, \"reset gpio request failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = gpiod_set_consumer_name(ks->gpio, \"ks8851_rst_n\");\n\tif (ret) {\n\t\tdev_err(dev, \"failed to set reset gpio name: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tks->vdd_io = devm_regulator_get(dev, \"vdd-io\");\n\tif (IS_ERR(ks->vdd_io)) {\n\t\tret = PTR_ERR(ks->vdd_io);\n\t\tgoto err_reg_io;\n\t}\n\n\tret = regulator_enable(ks->vdd_io);\n\tif (ret) {\n\t\tdev_err(dev, \"regulator vdd_io enable fail: %d\\n\", ret);\n\t\tgoto err_reg_io;\n\t}\n\n\tks->vdd_reg = devm_regulator_get(dev, \"vdd\");\n\tif (IS_ERR(ks->vdd_reg)) {\n\t\tret = PTR_ERR(ks->vdd_reg);\n\t\tgoto err_reg;\n\t}\n\n\tret = regulator_enable(ks->vdd_reg);\n\tif (ret) {\n\t\tdev_err(dev, \"regulator vdd enable fail: %d\\n\", ret);\n\t\tgoto err_reg;\n\t}\n\n\tif (ks->gpio) {\n\t\tusleep_range(10000, 11000);\n\t\tgpiod_set_value_cansleep(ks->gpio, 0);\n\t}\n\n\tspin_lock_init(&ks->statelock);\n\n\tINIT_WORK(&ks->rxctrl_work, ks8851_rxctrl_work);\n\n\tSET_NETDEV_DEV(netdev, dev);\n\n\t \n\tks->eeprom.data = ks;\n\tks->eeprom.width = PCI_EEPROM_WIDTH_93C46;\n\tks->eeprom.register_read = ks8851_eeprom_regread;\n\tks->eeprom.register_write = ks8851_eeprom_regwrite;\n\n\t \n\tks->mii.dev\t\t= netdev;\n\tks->mii.phy_id\t\t= 1;\n\tks->mii.phy_id_mask\t= 1;\n\tks->mii.reg_num_mask\t= 0xf;\n\tks->mii.mdio_read\t= ks8851_phy_read;\n\tks->mii.mdio_write\t= ks8851_phy_write;\n\n\tdev_info(dev, \"message enable is %d\\n\", msg_en);\n\n\tret = ks8851_register_mdiobus(ks, dev);\n\tif (ret)\n\t\tgoto err_mdio;\n\n\t \n\tks->msg_enable = netif_msg_init(msg_en, NETIF_MSG_DRV |\n\t\t\t\t\t\tNETIF_MSG_PROBE |\n\t\t\t\t\t\tNETIF_MSG_LINK);\n\n\tskb_queue_head_init(&ks->txq);\n\n\tnetdev->ethtool_ops = &ks8851_ethtool_ops;\n\n\tdev_set_drvdata(dev, ks);\n\n\tnetif_carrier_off(ks->netdev);\n\tnetdev->if_port = IF_PORT_100BASET;\n\tnetdev->netdev_ops = &ks8851_netdev_ops;\n\n\t \n\tks8851_soft_reset(ks, GRR_GSR);\n\n\t \n\tcider = ks8851_rdreg16(ks, KS_CIDER);\n\tif ((cider & ~CIDER_REV_MASK) != CIDER_ID) {\n\t\tdev_err(dev, \"failed to read device ID\\n\");\n\t\tret = -ENODEV;\n\t\tgoto err_id;\n\t}\n\n\t \n\tks->rc_ccr = ks8851_rdreg16(ks, KS_CCR);\n\n\tks8851_read_selftest(ks);\n\tks8851_init_mac(ks, dev->of_node);\n\n\tret = register_netdev(netdev);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to register network device\\n\");\n\t\tgoto err_id;\n\t}\n\n\tnetdev_info(netdev, \"revision %d, MAC %pM, IRQ %d, %s EEPROM\\n\",\n\t\t    CIDER_REV_GET(cider), netdev->dev_addr, netdev->irq,\n\t\t    ks->rc_ccr & CCR_EEPROM ? \"has\" : \"no\");\n\n\treturn 0;\n\nerr_id:\n\tks8851_unregister_mdiobus(ks);\nerr_mdio:\n\tif (ks->gpio)\n\t\tgpiod_set_value_cansleep(ks->gpio, 1);\n\tregulator_disable(ks->vdd_reg);\nerr_reg:\n\tregulator_disable(ks->vdd_io);\nerr_reg_io:\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(ks8851_probe_common);\n\nvoid ks8851_remove_common(struct device *dev)\n{\n\tstruct ks8851_net *priv = dev_get_drvdata(dev);\n\n\tks8851_unregister_mdiobus(priv);\n\n\tif (netif_msg_drv(priv))\n\t\tdev_info(dev, \"remove\\n\");\n\n\tunregister_netdev(priv->netdev);\n\tif (priv->gpio)\n\t\tgpiod_set_value_cansleep(priv->gpio, 1);\n\tregulator_disable(priv->vdd_reg);\n\tregulator_disable(priv->vdd_io);\n}\nEXPORT_SYMBOL_GPL(ks8851_remove_common);\n\nMODULE_DESCRIPTION(\"KS8851 Network driver\");\nMODULE_AUTHOR(\"Ben Dooks <ben@simtec.co.uk>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}