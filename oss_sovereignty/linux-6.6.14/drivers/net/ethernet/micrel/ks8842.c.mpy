{
  "module_name": "ks8842.c",
  "hash_id": "b6a0b01def8222c5afe2c19153a4d31cb693064115bd64e263a3afb69a046a4e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/micrel/ks8842.c",
  "human_readable_source": "\n \n\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/ethtool.h>\n#include <linux/ks8842.h>\n#include <linux/dmaengine.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n\n#define DRV_NAME \"ks8842\"\n\n \n#define REG_TIMB_RST\t\t0x1c\n#define REG_TIMB_FIFO\t\t0x20\n#define REG_TIMB_ISR\t\t0x24\n#define REG_TIMB_IER\t\t0x28\n#define REG_TIMB_IAR\t\t0x2C\n#define REQ_TIMB_DMA_RESUME\t0x30\n\n \n\n#define REG_SELECT_BANK 0x0e\n\n \n#define REG_QRFCR\t0x04\n\n \n#define REG_MARL\t0x00\n#define REG_MARM\t0x02\n#define REG_MARH\t0x04\n\n \n#define REG_GRR\t\t0x06\n\n \n#define REG_TXCR\t0x00\n#define REG_TXSR\t0x02\n#define REG_RXCR\t0x04\n#define REG_TXMIR\t0x08\n#define REG_RXMIR\t0x0A\n\n \n#define REG_TXQCR\t0x00\n#define REG_RXQCR\t0x02\n#define REG_TXFDPR\t0x04\n#define REG_RXFDPR\t0x06\n#define REG_QMU_DATA_LO 0x08\n#define REG_QMU_DATA_HI 0x0A\n\n \n#define REG_IER\t\t0x00\n#define IRQ_LINK_CHANGE\t0x8000\n#define IRQ_TX\t\t0x4000\n#define IRQ_RX\t\t0x2000\n#define IRQ_RX_OVERRUN\t0x0800\n#define IRQ_TX_STOPPED\t0x0200\n#define IRQ_RX_STOPPED\t0x0100\n#define IRQ_RX_ERROR\t0x0080\n#define ENABLED_IRQS\t(IRQ_LINK_CHANGE | IRQ_TX | IRQ_RX | IRQ_RX_STOPPED | \\\n\t\tIRQ_TX_STOPPED | IRQ_RX_OVERRUN | IRQ_RX_ERROR)\n \n#define ENABLED_IRQS_DMA_IP\t(IRQ_LINK_CHANGE | IRQ_RX_STOPPED | \\\n\tIRQ_TX_STOPPED | IRQ_RX_OVERRUN | IRQ_RX_ERROR)\n#define ENABLED_IRQS_DMA\t(ENABLED_IRQS_DMA_IP | IRQ_RX)\n#define REG_ISR\t\t0x02\n#define REG_RXSR\t0x04\n#define RXSR_VALID\t0x8000\n#define RXSR_BROADCAST\t0x80\n#define RXSR_MULTICAST\t0x40\n#define RXSR_UNICAST\t0x20\n#define RXSR_FRAMETYPE\t0x08\n#define RXSR_TOO_LONG\t0x04\n#define RXSR_RUNT\t0x02\n#define RXSR_CRC_ERROR\t0x01\n#define RXSR_ERROR\t(RXSR_TOO_LONG | RXSR_RUNT | RXSR_CRC_ERROR)\n\n \n#define REG_SW_ID_AND_ENABLE\t0x00\n#define REG_SGCR1\t\t0x02\n#define REG_SGCR2\t\t0x04\n#define REG_SGCR3\t\t0x06\n\n \n#define REG_MACAR1\t\t0x00\n#define REG_MACAR2\t\t0x02\n#define REG_MACAR3\t\t0x04\n\n \n#define REG_P1MBCR\t\t0x00\n#define REG_P1MBSR\t\t0x02\n\n \n#define REG_P2MBCR\t\t0x00\n#define REG_P2MBSR\t\t0x02\n\n \n#define REG_P1CR2\t\t0x02\n\n \n#define REG_P1CR4\t\t0x02\n#define REG_P1SR\t\t0x04\n\n \n#define\tMICREL_KS884X\t\t0x01\t \n#define\tKS884X_16BIT\t\t0x02\t \n\n#define DMA_BUFFER_SIZE\t\t2048\n\nstruct ks8842_tx_dma_ctl {\n\tstruct dma_chan *chan;\n\tstruct dma_async_tx_descriptor *adesc;\n\tvoid *buf;\n\tstruct scatterlist sg;\n\tint channel;\n};\n\nstruct ks8842_rx_dma_ctl {\n\tstruct dma_chan *chan;\n\tstruct dma_async_tx_descriptor *adesc;\n\tstruct sk_buff  *skb;\n\tstruct scatterlist sg;\n\tstruct tasklet_struct tasklet;\n\tint channel;\n};\n\n#define KS8842_USE_DMA(adapter) (((adapter)->dma_tx.channel != -1) && \\\n\t ((adapter)->dma_rx.channel != -1))\n\nstruct ks8842_adapter {\n\tvoid __iomem\t*hw_addr;\n\tint\t\tirq;\n\tunsigned long\tconf_flags;\t \n\tstruct tasklet_struct\ttasklet;\n\tspinlock_t\tlock;  \n\tstruct work_struct timeout_work;\n\tstruct net_device *netdev;\n\tstruct device *dev;\n\tstruct ks8842_tx_dma_ctl\tdma_tx;\n\tstruct ks8842_rx_dma_ctl\tdma_rx;\n};\n\nstatic void ks8842_dma_rx_cb(void *data);\nstatic void ks8842_dma_tx_cb(void *data);\n\nstatic inline void ks8842_resume_dma(struct ks8842_adapter *adapter)\n{\n\tiowrite32(1, adapter->hw_addr + REQ_TIMB_DMA_RESUME);\n}\n\nstatic inline void ks8842_select_bank(struct ks8842_adapter *adapter, u16 bank)\n{\n\tiowrite16(bank, adapter->hw_addr + REG_SELECT_BANK);\n}\n\nstatic inline void ks8842_write8(struct ks8842_adapter *adapter, u16 bank,\n\tu8 value, int offset)\n{\n\tks8842_select_bank(adapter, bank);\n\tiowrite8(value, adapter->hw_addr + offset);\n}\n\nstatic inline void ks8842_write16(struct ks8842_adapter *adapter, u16 bank,\n\tu16 value, int offset)\n{\n\tks8842_select_bank(adapter, bank);\n\tiowrite16(value, adapter->hw_addr + offset);\n}\n\nstatic inline void ks8842_enable_bits(struct ks8842_adapter *adapter, u16 bank,\n\tu16 bits, int offset)\n{\n\tu16 reg;\n\tks8842_select_bank(adapter, bank);\n\treg = ioread16(adapter->hw_addr + offset);\n\treg |= bits;\n\tiowrite16(reg, adapter->hw_addr + offset);\n}\n\nstatic inline void ks8842_clear_bits(struct ks8842_adapter *adapter, u16 bank,\n\tu16 bits, int offset)\n{\n\tu16 reg;\n\tks8842_select_bank(adapter, bank);\n\treg = ioread16(adapter->hw_addr + offset);\n\treg &= ~bits;\n\tiowrite16(reg, adapter->hw_addr + offset);\n}\n\nstatic inline void ks8842_write32(struct ks8842_adapter *adapter, u16 bank,\n\tu32 value, int offset)\n{\n\tks8842_select_bank(adapter, bank);\n\tiowrite32(value, adapter->hw_addr + offset);\n}\n\nstatic inline u8 ks8842_read8(struct ks8842_adapter *adapter, u16 bank,\n\tint offset)\n{\n\tks8842_select_bank(adapter, bank);\n\treturn ioread8(adapter->hw_addr + offset);\n}\n\nstatic inline u16 ks8842_read16(struct ks8842_adapter *adapter, u16 bank,\n\tint offset)\n{\n\tks8842_select_bank(adapter, bank);\n\treturn ioread16(adapter->hw_addr + offset);\n}\n\nstatic inline u32 ks8842_read32(struct ks8842_adapter *adapter, u16 bank,\n\tint offset)\n{\n\tks8842_select_bank(adapter, bank);\n\treturn ioread32(adapter->hw_addr + offset);\n}\n\nstatic void ks8842_reset(struct ks8842_adapter *adapter)\n{\n\tif (adapter->conf_flags & MICREL_KS884X) {\n\t\tks8842_write16(adapter, 3, 1, REG_GRR);\n\t\tmsleep(10);\n\t\tiowrite16(0, adapter->hw_addr + REG_GRR);\n\t} else {\n\t\t \n\t\tiowrite32(0x1, adapter->hw_addr + REG_TIMB_RST);\n\t\tmsleep(20);\n\t}\n}\n\nstatic void ks8842_update_link_status(struct net_device *netdev,\n\tstruct ks8842_adapter *adapter)\n{\n\t \n\tif (ks8842_read16(adapter, 45, REG_P1MBSR) & 0x4) {\n\t\tnetif_carrier_on(netdev);\n\t\tnetif_wake_queue(netdev);\n\t} else {\n\t\tnetif_stop_queue(netdev);\n\t\tnetif_carrier_off(netdev);\n\t}\n}\n\nstatic void ks8842_enable_tx(struct ks8842_adapter *adapter)\n{\n\tks8842_enable_bits(adapter, 16, 0x01, REG_TXCR);\n}\n\nstatic void ks8842_disable_tx(struct ks8842_adapter *adapter)\n{\n\tks8842_clear_bits(adapter, 16, 0x01, REG_TXCR);\n}\n\nstatic void ks8842_enable_rx(struct ks8842_adapter *adapter)\n{\n\tks8842_enable_bits(adapter, 16, 0x01, REG_RXCR);\n}\n\nstatic void ks8842_disable_rx(struct ks8842_adapter *adapter)\n{\n\tks8842_clear_bits(adapter, 16, 0x01, REG_RXCR);\n}\n\nstatic void ks8842_reset_hw(struct ks8842_adapter *adapter)\n{\n\t \n\tks8842_reset(adapter);\n\n\t \n\tks8842_write16(adapter, 16, 0x000E, REG_TXCR);\n\n\t \n\tks8842_write16(adapter, 16, 0x8 | 0x20 | 0x40 | 0x80 | 0x400,\n\t\tREG_RXCR);\n\n\t \n\tks8842_write16(adapter, 17, 0x4000, REG_TXFDPR);\n\n\t \n\tks8842_write16(adapter, 17, 0x4000, REG_RXFDPR);\n\n\t \n\tks8842_write16(adapter, 0, 0x1000, REG_QRFCR);\n\n\t \n\tks8842_enable_bits(adapter, 32, 1 << 8, REG_SGCR1);\n\n\t \n\tks8842_enable_bits(adapter, 32, 1 << 3, REG_SGCR2);\n\n\t \n\tks8842_write16(adapter, 48, 0x1E07, REG_P1CR2);\n\n\t \n\tks8842_enable_bits(adapter, 49, 1 << 13, REG_P1CR4);\n\n\t \n\tks8842_enable_tx(adapter);\n\n\t \n\tks8842_enable_rx(adapter);\n\n\t \n\tks8842_write16(adapter, 18, 0xffff, REG_ISR);\n\n\t \n\tif (KS8842_USE_DMA(adapter)) {\n\t\t \n\t\tiowrite16(ENABLED_IRQS_DMA_IP, adapter->hw_addr + REG_TIMB_IER);\n\t\tks8842_write16(adapter, 18, ENABLED_IRQS_DMA, REG_IER);\n\t} else {\n\t\tif (!(adapter->conf_flags & MICREL_KS884X))\n\t\t\tiowrite16(ENABLED_IRQS,\n\t\t\t\tadapter->hw_addr + REG_TIMB_IER);\n\t\tks8842_write16(adapter, 18, ENABLED_IRQS, REG_IER);\n\t}\n\t \n\tks8842_write16(adapter, 32, 0x1, REG_SW_ID_AND_ENABLE);\n}\n\nstatic void ks8842_init_mac_addr(struct ks8842_adapter *adapter)\n{\n\tu8 addr[ETH_ALEN];\n\tint i;\n\tu16 mac;\n\n\tfor (i = 0; i < ETH_ALEN; i++)\n\t\taddr[ETH_ALEN - i - 1] = ks8842_read8(adapter, 2, REG_MARL + i);\n\teth_hw_addr_set(adapter->netdev, addr);\n\n\tif (adapter->conf_flags & MICREL_KS884X) {\n\t\t \n\n\t\tmac = ks8842_read16(adapter, 2, REG_MARL);\n\t\tks8842_write16(adapter, 39, mac, REG_MACAR3);\n\t\tmac = ks8842_read16(adapter, 2, REG_MARM);\n\t\tks8842_write16(adapter, 39, mac, REG_MACAR2);\n\t\tmac = ks8842_read16(adapter, 2, REG_MARH);\n\t\tks8842_write16(adapter, 39, mac, REG_MACAR1);\n\t} else {\n\n\t\t \n\t\tmac = ks8842_read16(adapter, 2, REG_MARL);\n\t\tks8842_write16(adapter, 39, mac, REG_MACAR1);\n\t\tmac = ks8842_read16(adapter, 2, REG_MARM);\n\t\tks8842_write16(adapter, 39, mac, REG_MACAR2);\n\t\tmac = ks8842_read16(adapter, 2, REG_MARH);\n\t\tks8842_write16(adapter, 39, mac, REG_MACAR3);\n\t}\n}\n\nstatic void ks8842_write_mac_addr(struct ks8842_adapter *adapter, const u8 *mac)\n{\n\tunsigned long flags;\n\tunsigned i;\n\n\tspin_lock_irqsave(&adapter->lock, flags);\n\tfor (i = 0; i < ETH_ALEN; i++) {\n\t\tks8842_write8(adapter, 2, mac[ETH_ALEN - i - 1], REG_MARL + i);\n\t\tif (!(adapter->conf_flags & MICREL_KS884X))\n\t\t\tks8842_write8(adapter, 39, mac[ETH_ALEN - i - 1],\n\t\t\t\tREG_MACAR1 + i);\n\t}\n\n\tif (adapter->conf_flags & MICREL_KS884X) {\n\t\t \n\n\t\tu16 mac;\n\n\t\tmac = ks8842_read16(adapter, 2, REG_MARL);\n\t\tks8842_write16(adapter, 39, mac, REG_MACAR3);\n\t\tmac = ks8842_read16(adapter, 2, REG_MARM);\n\t\tks8842_write16(adapter, 39, mac, REG_MACAR2);\n\t\tmac = ks8842_read16(adapter, 2, REG_MARH);\n\t\tks8842_write16(adapter, 39, mac, REG_MACAR1);\n\t}\n\tspin_unlock_irqrestore(&adapter->lock, flags);\n}\n\nstatic inline u16 ks8842_tx_fifo_space(struct ks8842_adapter *adapter)\n{\n\treturn ks8842_read16(adapter, 16, REG_TXMIR) & 0x1fff;\n}\n\nstatic int ks8842_tx_frame_dma(struct sk_buff *skb, struct net_device *netdev)\n{\n\tstruct ks8842_adapter *adapter = netdev_priv(netdev);\n\tstruct ks8842_tx_dma_ctl *ctl = &adapter->dma_tx;\n\tu8 *buf = ctl->buf;\n\n\tif (ctl->adesc) {\n\t\tnetdev_dbg(netdev, \"%s: TX ongoing\\n\", __func__);\n\t\t \n\t\treturn NETDEV_TX_BUSY;\n\t}\n\n\tsg_dma_len(&ctl->sg) = skb->len + sizeof(u32);\n\n\t \n\t \n\t*buf++ = 0x00;\n\t*buf++ = 0x01;  \n\t*buf++ = skb->len & 0xff;\n\t*buf++ = (skb->len >> 8) & 0xff;\n\tskb_copy_from_linear_data(skb, buf, skb->len);\n\n\tdma_sync_single_range_for_device(adapter->dev,\n\t\tsg_dma_address(&ctl->sg), 0, sg_dma_len(&ctl->sg),\n\t\tDMA_TO_DEVICE);\n\n\t \n\tif (sg_dma_len(&ctl->sg) % 4)\n\t\tsg_dma_len(&ctl->sg) += 4 - sg_dma_len(&ctl->sg) % 4;\n\n\tctl->adesc = dmaengine_prep_slave_sg(ctl->chan,\n\t\t&ctl->sg, 1, DMA_MEM_TO_DEV, DMA_PREP_INTERRUPT);\n\tif (!ctl->adesc)\n\t\treturn NETDEV_TX_BUSY;\n\n\tctl->adesc->callback_param = netdev;\n\tctl->adesc->callback = ks8842_dma_tx_cb;\n\tctl->adesc->tx_submit(ctl->adesc);\n\n\tnetdev->stats.tx_bytes += skb->len;\n\n\tdev_kfree_skb(skb);\n\n\treturn NETDEV_TX_OK;\n}\n\nstatic int ks8842_tx_frame(struct sk_buff *skb, struct net_device *netdev)\n{\n\tstruct ks8842_adapter *adapter = netdev_priv(netdev);\n\tint len = skb->len;\n\n\tnetdev_dbg(netdev, \"%s: len %u head %p data %p tail %p end %p\\n\",\n\t\t__func__, skb->len, skb->head, skb->data,\n\t\tskb_tail_pointer(skb), skb_end_pointer(skb));\n\n\t \n\tif (ks8842_tx_fifo_space(adapter) < len + 8)\n\t\treturn NETDEV_TX_BUSY;\n\n\tif (adapter->conf_flags & KS884X_16BIT) {\n\t\tu16 *ptr16 = (u16 *)skb->data;\n\t\tks8842_write16(adapter, 17, 0x8000 | 0x100, REG_QMU_DATA_LO);\n\t\tks8842_write16(adapter, 17, (u16)len, REG_QMU_DATA_HI);\n\t\tnetdev->stats.tx_bytes += len;\n\n\t\t \n\t\twhile (len > 0) {\n\t\t\tiowrite16(*ptr16++, adapter->hw_addr + REG_QMU_DATA_LO);\n\t\t\tiowrite16(*ptr16++, adapter->hw_addr + REG_QMU_DATA_HI);\n\t\t\tlen -= sizeof(u32);\n\t\t}\n\t} else {\n\n\t\tu32 *ptr = (u32 *)skb->data;\n\t\tu32 ctrl;\n\t\t \n\t\tctrl = 0x8000 | 0x100 | (len << 16);\n\t\tks8842_write32(adapter, 17, ctrl, REG_QMU_DATA_LO);\n\n\t\tnetdev->stats.tx_bytes += len;\n\n\t\t \n\t\twhile (len > 0) {\n\t\t\tiowrite32(*ptr, adapter->hw_addr + REG_QMU_DATA_LO);\n\t\t\tlen -= sizeof(u32);\n\t\t\tptr++;\n\t\t}\n\t}\n\n\t \n\tks8842_write16(adapter, 17, 1, REG_TXQCR);\n\n\tdev_kfree_skb(skb);\n\n\treturn NETDEV_TX_OK;\n}\n\nstatic void ks8842_update_rx_err_counters(struct net_device *netdev, u32 status)\n{\n\tnetdev_dbg(netdev, \"RX error, status: %x\\n\", status);\n\n\tnetdev->stats.rx_errors++;\n\tif (status & RXSR_TOO_LONG)\n\t\tnetdev->stats.rx_length_errors++;\n\tif (status & RXSR_CRC_ERROR)\n\t\tnetdev->stats.rx_crc_errors++;\n\tif (status & RXSR_RUNT)\n\t\tnetdev->stats.rx_frame_errors++;\n}\n\nstatic void ks8842_update_rx_counters(struct net_device *netdev, u32 status,\n\tint len)\n{\n\tnetdev_dbg(netdev, \"RX packet, len: %d\\n\", len);\n\n\tnetdev->stats.rx_packets++;\n\tnetdev->stats.rx_bytes += len;\n\tif (status & RXSR_MULTICAST)\n\t\tnetdev->stats.multicast++;\n}\n\nstatic int __ks8842_start_new_rx_dma(struct net_device *netdev)\n{\n\tstruct ks8842_adapter *adapter = netdev_priv(netdev);\n\tstruct ks8842_rx_dma_ctl *ctl = &adapter->dma_rx;\n\tstruct scatterlist *sg = &ctl->sg;\n\tint err;\n\n\tctl->skb = netdev_alloc_skb(netdev, DMA_BUFFER_SIZE);\n\tif (ctl->skb) {\n\t\tsg_init_table(sg, 1);\n\t\tsg_dma_address(sg) = dma_map_single(adapter->dev,\n\t\t\tctl->skb->data, DMA_BUFFER_SIZE, DMA_FROM_DEVICE);\n\t\tif (dma_mapping_error(adapter->dev, sg_dma_address(sg))) {\n\t\t\terr = -ENOMEM;\n\t\t\tsg_dma_address(sg) = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\tsg_dma_len(sg) = DMA_BUFFER_SIZE;\n\n\t\tctl->adesc = dmaengine_prep_slave_sg(ctl->chan,\n\t\t\tsg, 1, DMA_DEV_TO_MEM, DMA_PREP_INTERRUPT);\n\n\t\tif (!ctl->adesc) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tctl->adesc->callback_param = netdev;\n\t\tctl->adesc->callback = ks8842_dma_rx_cb;\n\t\tctl->adesc->tx_submit(ctl->adesc);\n\t} else {\n\t\terr = -ENOMEM;\n\t\tsg_dma_address(sg) = 0;\n\t\tgoto out;\n\t}\n\n\treturn 0;\nout:\n\tif (sg_dma_address(sg))\n\t\tdma_unmap_single(adapter->dev, sg_dma_address(sg),\n\t\t\tDMA_BUFFER_SIZE, DMA_FROM_DEVICE);\n\tsg_dma_address(sg) = 0;\n\tdev_kfree_skb(ctl->skb);\n\tctl->skb = NULL;\n\n\tprintk(KERN_ERR DRV_NAME\": Failed to start RX DMA: %d\\n\", err);\n\treturn err;\n}\n\nstatic void ks8842_rx_frame_dma_tasklet(struct tasklet_struct *t)\n{\n\tstruct ks8842_adapter *adapter = from_tasklet(adapter, t, dma_rx.tasklet);\n\tstruct net_device *netdev = adapter->netdev;\n\tstruct ks8842_rx_dma_ctl *ctl = &adapter->dma_rx;\n\tstruct sk_buff *skb = ctl->skb;\n\tdma_addr_t addr = sg_dma_address(&ctl->sg);\n\tu32 status;\n\n\tctl->adesc = NULL;\n\n\t \n\t__ks8842_start_new_rx_dma(netdev);\n\n\t \n\tdma_unmap_single(adapter->dev, addr, DMA_BUFFER_SIZE, DMA_FROM_DEVICE);\n\n\tstatus = *((u32 *)skb->data);\n\n\tnetdev_dbg(netdev, \"%s - rx_data: status: %x\\n\",\n\t\t__func__, status & 0xffff);\n\n\t \n\tif ((status & RXSR_VALID) && !(status & RXSR_ERROR)) {\n\t\tint len = (status >> 16) & 0x7ff;\n\n\t\tks8842_update_rx_counters(netdev, status, len);\n\n\t\t \n\t\tskb_reserve(skb, 4);\n\t\tskb_put(skb, len);\n\n\t\tskb->protocol = eth_type_trans(skb, netdev);\n\t\tnetif_rx(skb);\n\t} else {\n\t\tks8842_update_rx_err_counters(netdev, status);\n\t\tdev_kfree_skb(skb);\n\t}\n}\n\nstatic void ks8842_rx_frame(struct net_device *netdev,\n\tstruct ks8842_adapter *adapter)\n{\n\tu32 status;\n\tint len;\n\n\tif (adapter->conf_flags & KS884X_16BIT) {\n\t\tstatus = ks8842_read16(adapter, 17, REG_QMU_DATA_LO);\n\t\tlen = ks8842_read16(adapter, 17, REG_QMU_DATA_HI);\n\t\tnetdev_dbg(netdev, \"%s - rx_data: status: %x\\n\",\n\t\t\t   __func__, status);\n\t} else {\n\t\tstatus = ks8842_read32(adapter, 17, REG_QMU_DATA_LO);\n\t\tlen = (status >> 16) & 0x7ff;\n\t\tstatus &= 0xffff;\n\t\tnetdev_dbg(netdev, \"%s - rx_data: status: %x\\n\",\n\t\t\t   __func__, status);\n\t}\n\n\t \n\tif ((status & RXSR_VALID) && !(status & RXSR_ERROR)) {\n\t\tstruct sk_buff *skb = netdev_alloc_skb_ip_align(netdev, len + 3);\n\n\t\tif (skb) {\n\n\t\t\tks8842_update_rx_counters(netdev, status, len);\n\n\t\t\tif (adapter->conf_flags & KS884X_16BIT) {\n\t\t\t\tu16 *data16 = skb_put(skb, len);\n\t\t\t\tks8842_select_bank(adapter, 17);\n\t\t\t\twhile (len > 0) {\n\t\t\t\t\t*data16++ = ioread16(adapter->hw_addr +\n\t\t\t\t\t\tREG_QMU_DATA_LO);\n\t\t\t\t\t*data16++ = ioread16(adapter->hw_addr +\n\t\t\t\t\t\tREG_QMU_DATA_HI);\n\t\t\t\t\tlen -= sizeof(u32);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tu32 *data = skb_put(skb, len);\n\n\t\t\t\tks8842_select_bank(adapter, 17);\n\t\t\t\twhile (len > 0) {\n\t\t\t\t\t*data++ = ioread32(adapter->hw_addr +\n\t\t\t\t\t\tREG_QMU_DATA_LO);\n\t\t\t\t\tlen -= sizeof(u32);\n\t\t\t\t}\n\t\t\t}\n\t\t\tskb->protocol = eth_type_trans(skb, netdev);\n\t\t\tnetif_rx(skb);\n\t\t} else\n\t\t\tnetdev->stats.rx_dropped++;\n\t} else\n\t\tks8842_update_rx_err_counters(netdev, status);\n\n\t \n\tks8842_clear_bits(adapter, 0, 1 << 12, REG_QRFCR);\n\n\t \n\tks8842_write16(adapter, 17, 0x01, REG_RXQCR);\n\n\t \n\tks8842_enable_bits(adapter, 0, 1 << 12, REG_QRFCR);\n}\n\nstatic void ks8842_handle_rx(struct net_device *netdev,\n\tstruct ks8842_adapter *adapter)\n{\n\tu16 rx_data = ks8842_read16(adapter, 16, REG_RXMIR) & 0x1fff;\n\tnetdev_dbg(netdev, \"%s Entry - rx_data: %d\\n\", __func__, rx_data);\n\twhile (rx_data) {\n\t\tks8842_rx_frame(netdev, adapter);\n\t\trx_data = ks8842_read16(adapter, 16, REG_RXMIR) & 0x1fff;\n\t}\n}\n\nstatic void ks8842_handle_tx(struct net_device *netdev,\n\tstruct ks8842_adapter *adapter)\n{\n\tu16 sr = ks8842_read16(adapter, 16, REG_TXSR);\n\tnetdev_dbg(netdev, \"%s - entry, sr: %x\\n\", __func__, sr);\n\tnetdev->stats.tx_packets++;\n\tif (netif_queue_stopped(netdev))\n\t\tnetif_wake_queue(netdev);\n}\n\nstatic void ks8842_handle_rx_overrun(struct net_device *netdev,\n\tstruct ks8842_adapter *adapter)\n{\n\tnetdev_dbg(netdev, \"%s: entry\\n\", __func__);\n\tnetdev->stats.rx_errors++;\n\tnetdev->stats.rx_fifo_errors++;\n}\n\nstatic void ks8842_tasklet(struct tasklet_struct *t)\n{\n\tstruct ks8842_adapter *adapter = from_tasklet(adapter, t, tasklet);\n\tstruct net_device *netdev = adapter->netdev;\n\tu16 isr;\n\tunsigned long flags;\n\tu16 entry_bank;\n\n\t \n\tspin_lock_irqsave(&adapter->lock, flags);\n\tentry_bank = ioread16(adapter->hw_addr + REG_SELECT_BANK);\n\tspin_unlock_irqrestore(&adapter->lock, flags);\n\n\tisr = ks8842_read16(adapter, 18, REG_ISR);\n\tnetdev_dbg(netdev, \"%s - ISR: 0x%x\\n\", __func__, isr);\n\n\t \n\tif (KS8842_USE_DMA(adapter))\n\t\tisr &= ~IRQ_RX;\n\n\t \n\tks8842_write16(adapter, 18, isr, REG_ISR);\n\n\tif (!(adapter->conf_flags & MICREL_KS884X))\n\t\t \n\t\tiowrite32(0x1, adapter->hw_addr + REG_TIMB_IAR);\n\n\tif (!netif_running(netdev))\n\t\treturn;\n\n\tif (isr & IRQ_LINK_CHANGE)\n\t\tks8842_update_link_status(netdev, adapter);\n\n\t \n\tif (isr & (IRQ_RX | IRQ_RX_ERROR) && !KS8842_USE_DMA(adapter))\n\t\tks8842_handle_rx(netdev, adapter);\n\n\t \n\tif (isr & IRQ_TX)\n\t\tks8842_handle_tx(netdev, adapter);\n\n\tif (isr & IRQ_RX_OVERRUN)\n\t\tks8842_handle_rx_overrun(netdev, adapter);\n\n\tif (isr & IRQ_TX_STOPPED) {\n\t\tks8842_disable_tx(adapter);\n\t\tks8842_enable_tx(adapter);\n\t}\n\n\tif (isr & IRQ_RX_STOPPED) {\n\t\tks8842_disable_rx(adapter);\n\t\tks8842_enable_rx(adapter);\n\t}\n\n\t \n\tspin_lock_irqsave(&adapter->lock, flags);\n\tif (KS8842_USE_DMA(adapter))\n\t\tks8842_write16(adapter, 18, ENABLED_IRQS_DMA, REG_IER);\n\telse\n\t\tks8842_write16(adapter, 18, ENABLED_IRQS, REG_IER);\n\tiowrite16(entry_bank, adapter->hw_addr + REG_SELECT_BANK);\n\n\t \n\tif (KS8842_USE_DMA(adapter))\n\t\tks8842_resume_dma(adapter);\n\n\tspin_unlock_irqrestore(&adapter->lock, flags);\n}\n\nstatic irqreturn_t ks8842_irq(int irq, void *devid)\n{\n\tstruct net_device *netdev = devid;\n\tstruct ks8842_adapter *adapter = netdev_priv(netdev);\n\tu16 isr;\n\tu16 entry_bank = ioread16(adapter->hw_addr + REG_SELECT_BANK);\n\tirqreturn_t ret = IRQ_NONE;\n\n\tisr = ks8842_read16(adapter, 18, REG_ISR);\n\tnetdev_dbg(netdev, \"%s - ISR: 0x%x\\n\", __func__, isr);\n\n\tif (isr) {\n\t\tif (KS8842_USE_DMA(adapter))\n\t\t\t \n\t\t\tks8842_write16(adapter, 18, IRQ_RX, REG_IER);\n\t\telse\n\t\t\t \n\t\t\tks8842_write16(adapter, 18, 0x00, REG_IER);\n\n\t\t \n\t\ttasklet_schedule(&adapter->tasklet);\n\n\t\tret = IRQ_HANDLED;\n\t}\n\n\tiowrite16(entry_bank, adapter->hw_addr + REG_SELECT_BANK);\n\n\t \n\tks8842_resume_dma(adapter);\n\n\treturn ret;\n}\n\nstatic void ks8842_dma_rx_cb(void *data)\n{\n\tstruct net_device\t*netdev = data;\n\tstruct ks8842_adapter\t*adapter = netdev_priv(netdev);\n\n\tnetdev_dbg(netdev, \"RX DMA finished\\n\");\n\t \n\tif (adapter->dma_rx.adesc)\n\t\ttasklet_schedule(&adapter->dma_rx.tasklet);\n}\n\nstatic void ks8842_dma_tx_cb(void *data)\n{\n\tstruct net_device\t\t*netdev = data;\n\tstruct ks8842_adapter\t\t*adapter = netdev_priv(netdev);\n\tstruct ks8842_tx_dma_ctl\t*ctl = &adapter->dma_tx;\n\n\tnetdev_dbg(netdev, \"TX DMA finished\\n\");\n\n\tif (!ctl->adesc)\n\t\treturn;\n\n\tnetdev->stats.tx_packets++;\n\tctl->adesc = NULL;\n\n\tif (netif_queue_stopped(netdev))\n\t\tnetif_wake_queue(netdev);\n}\n\nstatic void ks8842_stop_dma(struct ks8842_adapter *adapter)\n{\n\tstruct ks8842_tx_dma_ctl *tx_ctl = &adapter->dma_tx;\n\tstruct ks8842_rx_dma_ctl *rx_ctl = &adapter->dma_rx;\n\n\ttx_ctl->adesc = NULL;\n\tif (tx_ctl->chan)\n\t\tdmaengine_terminate_all(tx_ctl->chan);\n\n\trx_ctl->adesc = NULL;\n\tif (rx_ctl->chan)\n\t\tdmaengine_terminate_all(rx_ctl->chan);\n\n\tif (sg_dma_address(&rx_ctl->sg))\n\t\tdma_unmap_single(adapter->dev, sg_dma_address(&rx_ctl->sg),\n\t\t\tDMA_BUFFER_SIZE, DMA_FROM_DEVICE);\n\tsg_dma_address(&rx_ctl->sg) = 0;\n\n\tdev_kfree_skb(rx_ctl->skb);\n\trx_ctl->skb = NULL;\n}\n\nstatic void ks8842_dealloc_dma_bufs(struct ks8842_adapter *adapter)\n{\n\tstruct ks8842_tx_dma_ctl *tx_ctl = &adapter->dma_tx;\n\tstruct ks8842_rx_dma_ctl *rx_ctl = &adapter->dma_rx;\n\n\tks8842_stop_dma(adapter);\n\n\tif (tx_ctl->chan)\n\t\tdma_release_channel(tx_ctl->chan);\n\ttx_ctl->chan = NULL;\n\n\tif (rx_ctl->chan)\n\t\tdma_release_channel(rx_ctl->chan);\n\trx_ctl->chan = NULL;\n\n\ttasklet_kill(&rx_ctl->tasklet);\n\n\tif (sg_dma_address(&tx_ctl->sg))\n\t\tdma_unmap_single(adapter->dev, sg_dma_address(&tx_ctl->sg),\n\t\t\tDMA_BUFFER_SIZE, DMA_TO_DEVICE);\n\tsg_dma_address(&tx_ctl->sg) = 0;\n\n\tkfree(tx_ctl->buf);\n\ttx_ctl->buf = NULL;\n}\n\nstatic bool ks8842_dma_filter_fn(struct dma_chan *chan, void *filter_param)\n{\n\treturn chan->chan_id == (long)filter_param;\n}\n\nstatic int ks8842_alloc_dma_bufs(struct net_device *netdev)\n{\n\tstruct ks8842_adapter *adapter = netdev_priv(netdev);\n\tstruct ks8842_tx_dma_ctl *tx_ctl = &adapter->dma_tx;\n\tstruct ks8842_rx_dma_ctl *rx_ctl = &adapter->dma_rx;\n\tint err;\n\n\tdma_cap_mask_t mask;\n\n\tdma_cap_zero(mask);\n\tdma_cap_set(DMA_SLAVE, mask);\n\tdma_cap_set(DMA_PRIVATE, mask);\n\n\tsg_init_table(&tx_ctl->sg, 1);\n\n\ttx_ctl->chan = dma_request_channel(mask, ks8842_dma_filter_fn,\n\t\t\t\t\t   (void *)(long)tx_ctl->channel);\n\tif (!tx_ctl->chan) {\n\t\terr = -ENODEV;\n\t\tgoto err;\n\t}\n\n\t \n\ttx_ctl->buf = kmalloc(DMA_BUFFER_SIZE, GFP_KERNEL);\n\tif (!tx_ctl->buf) {\n\t\terr = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tsg_dma_address(&tx_ctl->sg) = dma_map_single(adapter->dev,\n\t\ttx_ctl->buf, DMA_BUFFER_SIZE, DMA_TO_DEVICE);\n\tif (dma_mapping_error(adapter->dev, sg_dma_address(&tx_ctl->sg))) {\n\t\terr = -ENOMEM;\n\t\tsg_dma_address(&tx_ctl->sg) = 0;\n\t\tgoto err;\n\t}\n\n\trx_ctl->chan = dma_request_channel(mask, ks8842_dma_filter_fn,\n\t\t\t\t\t   (void *)(long)rx_ctl->channel);\n\tif (!rx_ctl->chan) {\n\t\terr = -ENODEV;\n\t\tgoto err;\n\t}\n\n\ttasklet_setup(&rx_ctl->tasklet, ks8842_rx_frame_dma_tasklet);\n\n\treturn 0;\nerr:\n\tks8842_dealloc_dma_bufs(adapter);\n\treturn err;\n}\n\n \n\nstatic int ks8842_open(struct net_device *netdev)\n{\n\tstruct ks8842_adapter *adapter = netdev_priv(netdev);\n\tint err;\n\n\tnetdev_dbg(netdev, \"%s - entry\\n\", __func__);\n\n\tif (KS8842_USE_DMA(adapter)) {\n\t\terr = ks8842_alloc_dma_bufs(netdev);\n\n\t\tif (!err) {\n\t\t\t \n\t\t\terr = __ks8842_start_new_rx_dma(netdev);\n\t\t\tif (err)\n\t\t\t\tks8842_dealloc_dma_bufs(adapter);\n\t\t}\n\n\t\tif (err) {\n\t\t\tprintk(KERN_WARNING DRV_NAME\n\t\t\t\t\": Failed to initiate DMA, running PIO\\n\");\n\t\t\tks8842_dealloc_dma_bufs(adapter);\n\t\t\tadapter->dma_rx.channel = -1;\n\t\t\tadapter->dma_tx.channel = -1;\n\t\t}\n\t}\n\n\t \n\tks8842_reset_hw(adapter);\n\n\tks8842_write_mac_addr(adapter, netdev->dev_addr);\n\n\tks8842_update_link_status(netdev, adapter);\n\n\terr = request_irq(adapter->irq, ks8842_irq, IRQF_SHARED, DRV_NAME,\n\t\tnetdev);\n\tif (err) {\n\t\tpr_err(\"Failed to request IRQ: %d: %d\\n\", adapter->irq, err);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int ks8842_close(struct net_device *netdev)\n{\n\tstruct ks8842_adapter *adapter = netdev_priv(netdev);\n\n\tnetdev_dbg(netdev, \"%s - entry\\n\", __func__);\n\n\tcancel_work_sync(&adapter->timeout_work);\n\n\tif (KS8842_USE_DMA(adapter))\n\t\tks8842_dealloc_dma_bufs(adapter);\n\n\t \n\tfree_irq(adapter->irq, netdev);\n\n\t \n\tks8842_write16(adapter, 32, 0x0, REG_SW_ID_AND_ENABLE);\n\n\treturn 0;\n}\n\nstatic netdev_tx_t ks8842_xmit_frame(struct sk_buff *skb,\n\t\t\t\t     struct net_device *netdev)\n{\n\tint ret;\n\tstruct ks8842_adapter *adapter = netdev_priv(netdev);\n\n\tnetdev_dbg(netdev, \"%s: entry\\n\", __func__);\n\n\tif (KS8842_USE_DMA(adapter)) {\n\t\tunsigned long flags;\n\t\tret = ks8842_tx_frame_dma(skb, netdev);\n\t\t \n\t\tspin_lock_irqsave(&adapter->lock, flags);\n\t\tif (adapter->dma_tx.adesc)\n\t\t\tnetif_stop_queue(netdev);\n\t\tspin_unlock_irqrestore(&adapter->lock, flags);\n\t\treturn ret;\n\t}\n\n\tret = ks8842_tx_frame(skb, netdev);\n\n\tif (ks8842_tx_fifo_space(adapter) <  netdev->mtu + 8)\n\t\tnetif_stop_queue(netdev);\n\n\treturn ret;\n}\n\nstatic int ks8842_set_mac(struct net_device *netdev, void *p)\n{\n\tstruct ks8842_adapter *adapter = netdev_priv(netdev);\n\tstruct sockaddr *addr = p;\n\tchar *mac = (u8 *)addr->sa_data;\n\n\tnetdev_dbg(netdev, \"%s: entry\\n\", __func__);\n\n\tif (!is_valid_ether_addr(addr->sa_data))\n\t\treturn -EADDRNOTAVAIL;\n\n\teth_hw_addr_set(netdev, mac);\n\n\tks8842_write_mac_addr(adapter, mac);\n\treturn 0;\n}\n\nstatic void ks8842_tx_timeout_work(struct work_struct *work)\n{\n\tstruct ks8842_adapter *adapter =\n\t\tcontainer_of(work, struct ks8842_adapter, timeout_work);\n\tstruct net_device *netdev = adapter->netdev;\n\tunsigned long flags;\n\n\tnetdev_dbg(netdev, \"%s: entry\\n\", __func__);\n\n\tspin_lock_irqsave(&adapter->lock, flags);\n\n\tif (KS8842_USE_DMA(adapter))\n\t\tks8842_stop_dma(adapter);\n\n\t \n\tks8842_write16(adapter, 18, 0, REG_IER);\n\tks8842_write16(adapter, 18, 0xFFFF, REG_ISR);\n\n\tnetif_stop_queue(netdev);\n\n\tspin_unlock_irqrestore(&adapter->lock, flags);\n\n\tks8842_reset_hw(adapter);\n\n\tks8842_write_mac_addr(adapter, netdev->dev_addr);\n\n\tks8842_update_link_status(netdev, adapter);\n\n\tif (KS8842_USE_DMA(adapter))\n\t\t__ks8842_start_new_rx_dma(netdev);\n}\n\nstatic void ks8842_tx_timeout(struct net_device *netdev, unsigned int txqueue)\n{\n\tstruct ks8842_adapter *adapter = netdev_priv(netdev);\n\n\tnetdev_dbg(netdev, \"%s: entry\\n\", __func__);\n\n\tschedule_work(&adapter->timeout_work);\n}\n\nstatic const struct net_device_ops ks8842_netdev_ops = {\n\t.ndo_open\t\t= ks8842_open,\n\t.ndo_stop\t\t= ks8842_close,\n\t.ndo_start_xmit\t\t= ks8842_xmit_frame,\n\t.ndo_set_mac_address\t= ks8842_set_mac,\n\t.ndo_tx_timeout \t= ks8842_tx_timeout,\n\t.ndo_validate_addr\t= eth_validate_addr\n};\n\nstatic const struct ethtool_ops ks8842_ethtool_ops = {\n\t.get_link\t\t= ethtool_op_get_link,\n};\n\nstatic int ks8842_probe(struct platform_device *pdev)\n{\n\tint err = -ENOMEM;\n\tstruct resource *iomem;\n\tstruct net_device *netdev;\n\tstruct ks8842_adapter *adapter;\n\tstruct ks8842_platform_data *pdata = dev_get_platdata(&pdev->dev);\n\tu16 id;\n\tunsigned i;\n\n\tiomem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!iomem) {\n\t\tdev_err(&pdev->dev, \"Invalid resource\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (!request_mem_region(iomem->start, resource_size(iomem), DRV_NAME))\n\t\tgoto err_mem_region;\n\n\tnetdev = alloc_etherdev(sizeof(struct ks8842_adapter));\n\tif (!netdev)\n\t\tgoto err_alloc_etherdev;\n\n\tSET_NETDEV_DEV(netdev, &pdev->dev);\n\n\tadapter = netdev_priv(netdev);\n\tadapter->netdev = netdev;\n\tINIT_WORK(&adapter->timeout_work, ks8842_tx_timeout_work);\n\tadapter->hw_addr = ioremap(iomem->start, resource_size(iomem));\n\tadapter->conf_flags = iomem->flags;\n\n\tif (!adapter->hw_addr)\n\t\tgoto err_ioremap;\n\n\tadapter->irq = platform_get_irq(pdev, 0);\n\tif (adapter->irq < 0) {\n\t\terr = adapter->irq;\n\t\tgoto err_get_irq;\n\t}\n\n\tadapter->dev = (pdev->dev.parent) ? pdev->dev.parent : &pdev->dev;\n\n\t \n\tif (!(adapter->conf_flags & MICREL_KS884X) && pdata &&\n\t\t(pdata->tx_dma_channel != -1) &&\n\t\t(pdata->rx_dma_channel != -1)) {\n\t\tadapter->dma_rx.channel = pdata->rx_dma_channel;\n\t\tadapter->dma_tx.channel = pdata->tx_dma_channel;\n\t} else {\n\t\tadapter->dma_rx.channel = -1;\n\t\tadapter->dma_tx.channel = -1;\n\t}\n\n\ttasklet_setup(&adapter->tasklet, ks8842_tasklet);\n\tspin_lock_init(&adapter->lock);\n\n\tnetdev->netdev_ops = &ks8842_netdev_ops;\n\tnetdev->ethtool_ops = &ks8842_ethtool_ops;\n\n\t \n\ti = netdev->addr_len;\n\tif (pdata) {\n\t\tfor (i = 0; i < netdev->addr_len; i++)\n\t\t\tif (pdata->macaddr[i] != 0)\n\t\t\t\tbreak;\n\n\t\tif (i < netdev->addr_len)\n\t\t\t \n\t\t\teth_hw_addr_set(netdev, pdata->macaddr);\n\t}\n\n\tif (i == netdev->addr_len) {\n\t\tks8842_init_mac_addr(adapter);\n\n\t\tif (!is_valid_ether_addr(netdev->dev_addr))\n\t\t\teth_hw_addr_random(netdev);\n\t}\n\n\tid = ks8842_read16(adapter, 32, REG_SW_ID_AND_ENABLE);\n\n\tstrcpy(netdev->name, \"eth%d\");\n\terr = register_netdev(netdev);\n\tif (err)\n\t\tgoto err_register;\n\n\tplatform_set_drvdata(pdev, netdev);\n\n\tpr_info(\"Found chip, family: 0x%x, id: 0x%x, rev: 0x%x\\n\",\n\t\t(id >> 8) & 0xff, (id >> 4) & 0xf, (id >> 1) & 0x7);\n\n\treturn 0;\n\nerr_register:\nerr_get_irq:\n\tiounmap(adapter->hw_addr);\nerr_ioremap:\n\tfree_netdev(netdev);\nerr_alloc_etherdev:\n\trelease_mem_region(iomem->start, resource_size(iomem));\nerr_mem_region:\n\treturn err;\n}\n\nstatic int ks8842_remove(struct platform_device *pdev)\n{\n\tstruct net_device *netdev = platform_get_drvdata(pdev);\n\tstruct ks8842_adapter *adapter = netdev_priv(netdev);\n\tstruct resource *iomem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\n\tunregister_netdev(netdev);\n\ttasklet_kill(&adapter->tasklet);\n\tiounmap(adapter->hw_addr);\n\tfree_netdev(netdev);\n\trelease_mem_region(iomem->start, resource_size(iomem));\n\treturn 0;\n}\n\n\nstatic struct platform_driver ks8842_platform_driver = {\n\t.driver = {\n\t\t.name\t= DRV_NAME,\n\t},\n\t.probe\t\t= ks8842_probe,\n\t.remove\t\t= ks8842_remove,\n};\n\nmodule_platform_driver(ks8842_platform_driver);\n\nMODULE_DESCRIPTION(\"Timberdale KS8842 ethernet driver\");\nMODULE_AUTHOR(\"Mocean Laboratories <info@mocean-labs.com>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:ks8842\");\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}