{
  "module_name": "ksz884x.c",
  "hash_id": "fc2a427f4476c000fc4d5c729ad473acb74507c757f8d7368759b5c0d674e795",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/micrel/ksz884x.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/ioport.h>\n#include <linux/pci.h>\n#include <linux/proc_fs.h>\n#include <linux/mii.h>\n#include <linux/platform_device.h>\n#include <linux/ethtool.h>\n#include <linux/etherdevice.h>\n#include <linux/in.h>\n#include <linux/ip.h>\n#include <linux/if_vlan.h>\n#include <linux/crc32.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/micrel_phy.h>\n\n\n \n\n#define KS_DMA_TX_CTRL\t\t\t0x0000\n#define DMA_TX_ENABLE\t\t\t0x00000001\n#define DMA_TX_CRC_ENABLE\t\t0x00000002\n#define DMA_TX_PAD_ENABLE\t\t0x00000004\n#define DMA_TX_LOOPBACK\t\t\t0x00000100\n#define DMA_TX_FLOW_ENABLE\t\t0x00000200\n#define DMA_TX_CSUM_IP\t\t\t0x00010000\n#define DMA_TX_CSUM_TCP\t\t\t0x00020000\n#define DMA_TX_CSUM_UDP\t\t\t0x00040000\n#define DMA_TX_BURST_SIZE\t\t0x3F000000\n\n#define KS_DMA_RX_CTRL\t\t\t0x0004\n#define DMA_RX_ENABLE\t\t\t0x00000001\n#define KS884X_DMA_RX_MULTICAST\t\t0x00000002\n#define DMA_RX_PROMISCUOUS\t\t0x00000004\n#define DMA_RX_ERROR\t\t\t0x00000008\n#define DMA_RX_UNICAST\t\t\t0x00000010\n#define DMA_RX_ALL_MULTICAST\t\t0x00000020\n#define DMA_RX_BROADCAST\t\t0x00000040\n#define DMA_RX_FLOW_ENABLE\t\t0x00000200\n#define DMA_RX_CSUM_IP\t\t\t0x00010000\n#define DMA_RX_CSUM_TCP\t\t\t0x00020000\n#define DMA_RX_CSUM_UDP\t\t\t0x00040000\n#define DMA_RX_BURST_SIZE\t\t0x3F000000\n\n#define DMA_BURST_SHIFT\t\t\t24\n#define DMA_BURST_DEFAULT\t\t8\n\n#define KS_DMA_TX_START\t\t\t0x0008\n#define KS_DMA_RX_START\t\t\t0x000C\n#define DMA_START\t\t\t0x00000001\n\n#define KS_DMA_TX_ADDR\t\t\t0x0010\n#define KS_DMA_RX_ADDR\t\t\t0x0014\n\n#define DMA_ADDR_LIST_MASK\t\t0xFFFFFFFC\n#define DMA_ADDR_LIST_SHIFT\t\t2\n\n \n#define KS884X_MULTICAST_0_OFFSET\t0x0020\n#define KS884X_MULTICAST_1_OFFSET\t0x0021\n#define KS884X_MULTICAST_2_OFFSET\t0x0022\n#define KS884x_MULTICAST_3_OFFSET\t0x0023\n \n#define KS884X_MULTICAST_4_OFFSET\t0x0024\n#define KS884X_MULTICAST_5_OFFSET\t0x0025\n#define KS884X_MULTICAST_6_OFFSET\t0x0026\n#define KS884X_MULTICAST_7_OFFSET\t0x0027\n\n \n\n \n#define KS884X_INTERRUPTS_ENABLE\t0x0028\n \n#define KS884X_INTERRUPTS_STATUS\t0x002C\n\n#define KS884X_INT_RX_STOPPED\t\t0x02000000\n#define KS884X_INT_TX_STOPPED\t\t0x04000000\n#define KS884X_INT_RX_OVERRUN\t\t0x08000000\n#define KS884X_INT_TX_EMPTY\t\t0x10000000\n#define KS884X_INT_RX\t\t\t0x20000000\n#define KS884X_INT_TX\t\t\t0x40000000\n#define KS884X_INT_PHY\t\t\t0x80000000\n\n#define KS884X_INT_RX_MASK\t\t\\\n\t(KS884X_INT_RX | KS884X_INT_RX_OVERRUN)\n#define KS884X_INT_TX_MASK\t\t\\\n\t(KS884X_INT_TX | KS884X_INT_TX_EMPTY)\n#define KS884X_INT_MASK\t(KS884X_INT_RX | KS884X_INT_TX | KS884X_INT_PHY)\n\n \n\n \n#define KS_ADD_ADDR_0_LO\t\t0x0080\n \n#define KS_ADD_ADDR_0_HI\t\t0x0084\n \n#define KS_ADD_ADDR_1_LO\t\t0x0088\n \n#define KS_ADD_ADDR_1_HI\t\t0x008C\n \n#define KS_ADD_ADDR_2_LO\t\t0x0090\n \n#define KS_ADD_ADDR_2_HI\t\t0x0094\n \n#define KS_ADD_ADDR_3_LO\t\t0x0098\n \n#define KS_ADD_ADDR_3_HI\t\t0x009C\n \n#define KS_ADD_ADDR_4_LO\t\t0x00A0\n \n#define KS_ADD_ADDR_4_HI\t\t0x00A4\n \n#define KS_ADD_ADDR_5_LO\t\t0x00A8\n \n#define KS_ADD_ADDR_5_HI\t\t0x00AC\n \n#define KS_ADD_ADDR_6_LO\t\t0x00B0\n \n#define KS_ADD_ADDR_6_HI\t\t0x00B4\n \n#define KS_ADD_ADDR_7_LO\t\t0x00B8\n \n#define KS_ADD_ADDR_7_HI\t\t0x00BC\n \n#define KS_ADD_ADDR_8_LO\t\t0x00C0\n \n#define KS_ADD_ADDR_8_HI\t\t0x00C4\n \n#define KS_ADD_ADDR_9_LO\t\t0x00C8\n \n#define KS_ADD_ADDR_9_HI\t\t0x00CC\n \n#define KS_ADD_ADDR_A_LO\t\t0x00D0\n \n#define KS_ADD_ADDR_A_HI\t\t0x00D4\n \n#define KS_ADD_ADDR_B_LO\t\t0x00D8\n \n#define KS_ADD_ADDR_B_HI\t\t0x00DC\n \n#define KS_ADD_ADDR_C_LO\t\t0x00E0\n \n#define KS_ADD_ADDR_C_HI\t\t0x00E4\n \n#define KS_ADD_ADDR_D_LO\t\t0x00E8\n \n#define KS_ADD_ADDR_D_HI\t\t0x00EC\n \n#define KS_ADD_ADDR_E_LO\t\t0x00F0\n \n#define KS_ADD_ADDR_E_HI\t\t0x00F4\n \n#define KS_ADD_ADDR_F_LO\t\t0x00F8\n \n#define KS_ADD_ADDR_F_HI\t\t0x00FC\n\n#define ADD_ADDR_HI_MASK\t\t0x0000FFFF\n#define ADD_ADDR_ENABLE\t\t\t0x80000000\n#define ADD_ADDR_INCR\t\t\t8\n\n \n\n \n#define KS884X_ADDR_0_OFFSET\t\t0x0200\n#define KS884X_ADDR_1_OFFSET\t\t0x0201\n \n#define KS884X_ADDR_2_OFFSET\t\t0x0202\n#define KS884X_ADDR_3_OFFSET\t\t0x0203\n \n#define KS884X_ADDR_4_OFFSET\t\t0x0204\n#define KS884X_ADDR_5_OFFSET\t\t0x0205\n\n \n#define KS884X_BUS_CTRL_OFFSET\t\t0x0210\n\n#define BUS_SPEED_125_MHZ\t\t0x0000\n#define BUS_SPEED_62_5_MHZ\t\t0x0001\n#define BUS_SPEED_41_66_MHZ\t\t0x0002\n#define BUS_SPEED_25_MHZ\t\t0x0003\n\n \n#define KS884X_EEPROM_CTRL_OFFSET\t0x0212\n\n#define EEPROM_CHIP_SELECT\t\t0x0001\n#define EEPROM_SERIAL_CLOCK\t\t0x0002\n#define EEPROM_DATA_OUT\t\t\t0x0004\n#define EEPROM_DATA_IN\t\t\t0x0008\n#define EEPROM_ACCESS_ENABLE\t\t0x0010\n\n \n#define KS884X_MEM_INFO_OFFSET\t\t0x0214\n\n#define RX_MEM_TEST_FAILED\t\t0x0008\n#define RX_MEM_TEST_FINISHED\t\t0x0010\n#define TX_MEM_TEST_FAILED\t\t0x0800\n#define TX_MEM_TEST_FINISHED\t\t0x1000\n\n \n#define KS884X_GLOBAL_CTRL_OFFSET\t0x0216\n#define GLOBAL_SOFTWARE_RESET\t\t0x0001\n\n#define KS8841_POWER_MANAGE_OFFSET\t0x0218\n\n \n#define KS8841_WOL_CTRL_OFFSET\t\t0x021A\n#define KS8841_WOL_MAGIC_ENABLE\t\t0x0080\n#define KS8841_WOL_FRAME3_ENABLE\t0x0008\n#define KS8841_WOL_FRAME2_ENABLE\t0x0004\n#define KS8841_WOL_FRAME1_ENABLE\t0x0002\n#define KS8841_WOL_FRAME0_ENABLE\t0x0001\n\n \n#define KS8841_WOL_FRAME_CRC_OFFSET\t0x0220\n#define KS8841_WOL_FRAME_BYTE0_OFFSET\t0x0224\n#define KS8841_WOL_FRAME_BYTE2_OFFSET\t0x0228\n\n \n#define KS884X_IACR_P\t\t\t0x04A0\n#define KS884X_IACR_OFFSET\t\tKS884X_IACR_P\n\n \n#define KS884X_IADR1_P\t\t\t0x04A2\n#define KS884X_IADR2_P\t\t\t0x04A4\n#define KS884X_IADR3_P\t\t\t0x04A6\n#define KS884X_IADR4_P\t\t\t0x04A8\n#define KS884X_IADR5_P\t\t\t0x04AA\n\n#define KS884X_ACC_CTRL_SEL_OFFSET\tKS884X_IACR_P\n#define KS884X_ACC_CTRL_INDEX_OFFSET\t(KS884X_ACC_CTRL_SEL_OFFSET + 1)\n\n#define KS884X_ACC_DATA_0_OFFSET\tKS884X_IADR4_P\n#define KS884X_ACC_DATA_1_OFFSET\t(KS884X_ACC_DATA_0_OFFSET + 1)\n#define KS884X_ACC_DATA_2_OFFSET\tKS884X_IADR5_P\n#define KS884X_ACC_DATA_3_OFFSET\t(KS884X_ACC_DATA_2_OFFSET + 1)\n#define KS884X_ACC_DATA_4_OFFSET\tKS884X_IADR2_P\n#define KS884X_ACC_DATA_5_OFFSET\t(KS884X_ACC_DATA_4_OFFSET + 1)\n#define KS884X_ACC_DATA_6_OFFSET\tKS884X_IADR3_P\n#define KS884X_ACC_DATA_7_OFFSET\t(KS884X_ACC_DATA_6_OFFSET + 1)\n#define KS884X_ACC_DATA_8_OFFSET\tKS884X_IADR1_P\n\n \n#define KS884X_P1MBCR_P\t\t\t0x04D0\n#define KS884X_P1MBSR_P\t\t\t0x04D2\n#define KS884X_PHY1ILR_P\t\t0x04D4\n#define KS884X_PHY1IHR_P\t\t0x04D6\n#define KS884X_P1ANAR_P\t\t\t0x04D8\n#define KS884X_P1ANLPR_P\t\t0x04DA\n\n \n#define KS884X_P2MBCR_P\t\t\t0x04E0\n#define KS884X_P2MBSR_P\t\t\t0x04E2\n#define KS884X_PHY2ILR_P\t\t0x04E4\n#define KS884X_PHY2IHR_P\t\t0x04E6\n#define KS884X_P2ANAR_P\t\t\t0x04E8\n#define KS884X_P2ANLPR_P\t\t0x04EA\n\n#define KS884X_PHY_1_CTRL_OFFSET\tKS884X_P1MBCR_P\n#define PHY_CTRL_INTERVAL\t\t(KS884X_P2MBCR_P - KS884X_P1MBCR_P)\n\n#define KS884X_PHY_CTRL_OFFSET\t\t0x00\n\n#define KS884X_PHY_STATUS_OFFSET\t0x02\n\n#define KS884X_PHY_ID_1_OFFSET\t\t0x04\n#define KS884X_PHY_ID_2_OFFSET\t\t0x06\n\n#define KS884X_PHY_AUTO_NEG_OFFSET\t0x08\n\n#define KS884X_PHY_REMOTE_CAP_OFFSET\t0x0A\n\n \n#define KS884X_P1VCT_P\t\t\t0x04F0\n#define KS884X_P1PHYCTRL_P\t\t0x04F2\n\n \n#define KS884X_P2VCT_P\t\t\t0x04F4\n#define KS884X_P2PHYCTRL_P\t\t0x04F6\n\n#define KS884X_PHY_SPECIAL_OFFSET\tKS884X_P1VCT_P\n#define PHY_SPECIAL_INTERVAL\t\t(KS884X_P2VCT_P - KS884X_P1VCT_P)\n\n#define KS884X_PHY_LINK_MD_OFFSET\t0x00\n\n#define PHY_START_CABLE_DIAG\t\t0x8000\n#define PHY_CABLE_DIAG_RESULT\t\t0x6000\n#define PHY_CABLE_STAT_NORMAL\t\t0x0000\n#define PHY_CABLE_STAT_OPEN\t\t0x2000\n#define PHY_CABLE_STAT_SHORT\t\t0x4000\n#define PHY_CABLE_STAT_FAILED\t\t0x6000\n#define PHY_CABLE_10M_SHORT\t\t0x1000\n#define PHY_CABLE_FAULT_COUNTER\t\t0x01FF\n\n#define KS884X_PHY_PHY_CTRL_OFFSET\t0x02\n\n#define PHY_STAT_REVERSED_POLARITY\t0x0020\n#define PHY_STAT_MDIX\t\t\t0x0010\n#define PHY_FORCE_LINK\t\t\t0x0008\n#define PHY_POWER_SAVING_DISABLE\t0x0004\n#define PHY_REMOTE_LOOPBACK\t\t0x0002\n\n \n#define KS884X_SIDER_P\t\t\t0x0400\n#define KS884X_CHIP_ID_OFFSET\t\tKS884X_SIDER_P\n#define KS884X_FAMILY_ID_OFFSET\t\t(KS884X_CHIP_ID_OFFSET + 1)\n\n#define REG_FAMILY_ID\t\t\t0x88\n\n#define REG_CHIP_ID_41\t\t\t0x8810\n#define REG_CHIP_ID_42\t\t\t0x8800\n\n#define KS884X_CHIP_ID_MASK_41\t\t0xFF10\n#define KS884X_CHIP_ID_MASK\t\t0xFFF0\n#define KS884X_CHIP_ID_SHIFT\t\t4\n#define KS884X_REVISION_MASK\t\t0x000E\n#define KS884X_REVISION_SHIFT\t\t1\n#define KS8842_START\t\t\t0x0001\n\n#define CHIP_IP_41_M\t\t\t0x8810\n#define CHIP_IP_42_M\t\t\t0x8800\n#define CHIP_IP_61_M\t\t\t0x8890\n#define CHIP_IP_62_M\t\t\t0x8880\n\n#define CHIP_IP_41_P\t\t\t0x8850\n#define CHIP_IP_42_P\t\t\t0x8840\n#define CHIP_IP_61_P\t\t\t0x88D0\n#define CHIP_IP_62_P\t\t\t0x88C0\n\n \n#define KS8842_SGCR1_P\t\t\t0x0402\n#define KS8842_SWITCH_CTRL_1_OFFSET\tKS8842_SGCR1_P\n\n#define SWITCH_PASS_ALL\t\t\t0x8000\n#define SWITCH_TX_FLOW_CTRL\t\t0x2000\n#define SWITCH_RX_FLOW_CTRL\t\t0x1000\n#define SWITCH_CHECK_LENGTH\t\t0x0800\n#define SWITCH_AGING_ENABLE\t\t0x0400\n#define SWITCH_FAST_AGING\t\t0x0200\n#define SWITCH_AGGR_BACKOFF\t\t0x0100\n#define SWITCH_PASS_PAUSE\t\t0x0008\n#define SWITCH_LINK_AUTO_AGING\t\t0x0001\n\n \n#define KS8842_SGCR2_P\t\t\t0x0404\n#define KS8842_SWITCH_CTRL_2_OFFSET\tKS8842_SGCR2_P\n\n#define SWITCH_VLAN_ENABLE\t\t0x8000\n#define SWITCH_IGMP_SNOOP\t\t0x4000\n#define IPV6_MLD_SNOOP_ENABLE\t\t0x2000\n#define IPV6_MLD_SNOOP_OPTION\t\t0x1000\n#define PRIORITY_SCHEME_SELECT\t\t0x0800\n#define SWITCH_MIRROR_RX_TX\t\t0x0100\n#define UNICAST_VLAN_BOUNDARY\t\t0x0080\n#define MULTICAST_STORM_DISABLE\t\t0x0040\n#define SWITCH_BACK_PRESSURE\t\t0x0020\n#define FAIR_FLOW_CTRL\t\t\t0x0010\n#define NO_EXC_COLLISION_DROP\t\t0x0008\n#define SWITCH_HUGE_PACKET\t\t0x0004\n#define SWITCH_LEGAL_PACKET\t\t0x0002\n#define SWITCH_BUF_RESERVE\t\t0x0001\n\n \n#define KS8842_SGCR3_P\t\t\t0x0406\n#define KS8842_SWITCH_CTRL_3_OFFSET\tKS8842_SGCR3_P\n\n#define BROADCAST_STORM_RATE_LO\t\t0xFF00\n#define SWITCH_REPEATER\t\t\t0x0080\n#define SWITCH_HALF_DUPLEX\t\t0x0040\n#define SWITCH_FLOW_CTRL\t\t0x0020\n#define SWITCH_10_MBIT\t\t\t0x0010\n#define SWITCH_REPLACE_NULL_VID\t\t0x0008\n#define BROADCAST_STORM_RATE_HI\t\t0x0007\n\n#define BROADCAST_STORM_RATE\t\t0x07FF\n\n \n#define KS8842_SGCR4_P\t\t\t0x0408\n\n \n#define KS8842_SGCR5_P\t\t\t0x040A\n#define KS8842_SWITCH_CTRL_5_OFFSET\tKS8842_SGCR5_P\n\n#define LED_MODE\t\t\t0x8200\n#define LED_SPEED_DUPLEX_ACT\t\t0x0000\n#define LED_SPEED_DUPLEX_LINK_ACT\t0x8000\n#define LED_DUPLEX_10_100\t\t0x0200\n\n \n#define KS8842_SGCR6_P\t\t\t0x0410\n#define KS8842_SWITCH_CTRL_6_OFFSET\tKS8842_SGCR6_P\n\n#define KS8842_PRIORITY_MASK\t\t3\n#define KS8842_PRIORITY_SHIFT\t\t2\n\n \n#define KS8842_SGCR7_P\t\t\t0x0412\n#define KS8842_SWITCH_CTRL_7_OFFSET\tKS8842_SGCR7_P\n\n#define SWITCH_UNK_DEF_PORT_ENABLE\t0x0008\n#define SWITCH_UNK_DEF_PORT_3\t\t0x0004\n#define SWITCH_UNK_DEF_PORT_2\t\t0x0002\n#define SWITCH_UNK_DEF_PORT_1\t\t0x0001\n\n \n#define KS8842_MACAR1_P\t\t\t0x0470\n#define KS8842_MACAR2_P\t\t\t0x0472\n#define KS8842_MACAR3_P\t\t\t0x0474\n#define KS8842_MAC_ADDR_1_OFFSET\tKS8842_MACAR1_P\n#define KS8842_MAC_ADDR_0_OFFSET\t(KS8842_MAC_ADDR_1_OFFSET + 1)\n#define KS8842_MAC_ADDR_3_OFFSET\tKS8842_MACAR2_P\n#define KS8842_MAC_ADDR_2_OFFSET\t(KS8842_MAC_ADDR_3_OFFSET + 1)\n#define KS8842_MAC_ADDR_5_OFFSET\tKS8842_MACAR3_P\n#define KS8842_MAC_ADDR_4_OFFSET\t(KS8842_MAC_ADDR_5_OFFSET + 1)\n\n \n#define KS8842_TOSR1_P\t\t\t0x0480\n#define KS8842_TOSR2_P\t\t\t0x0482\n#define KS8842_TOSR3_P\t\t\t0x0484\n#define KS8842_TOSR4_P\t\t\t0x0486\n#define KS8842_TOSR5_P\t\t\t0x0488\n#define KS8842_TOSR6_P\t\t\t0x048A\n#define KS8842_TOSR7_P\t\t\t0x0490\n#define KS8842_TOSR8_P\t\t\t0x0492\n#define KS8842_TOS_1_OFFSET\t\tKS8842_TOSR1_P\n#define KS8842_TOS_2_OFFSET\t\tKS8842_TOSR2_P\n#define KS8842_TOS_3_OFFSET\t\tKS8842_TOSR3_P\n#define KS8842_TOS_4_OFFSET\t\tKS8842_TOSR4_P\n#define KS8842_TOS_5_OFFSET\t\tKS8842_TOSR5_P\n#define KS8842_TOS_6_OFFSET\t\tKS8842_TOSR6_P\n\n#define KS8842_TOS_7_OFFSET\t\tKS8842_TOSR7_P\n#define KS8842_TOS_8_OFFSET\t\tKS8842_TOSR8_P\n\n \n#define KS8842_P1CR1_P\t\t\t0x0500\n#define KS8842_P1CR2_P\t\t\t0x0502\n#define KS8842_P1VIDR_P\t\t\t0x0504\n#define KS8842_P1CR3_P\t\t\t0x0506\n#define KS8842_P1IRCR_P\t\t\t0x0508\n#define KS8842_P1ERCR_P\t\t\t0x050A\n#define KS884X_P1SCSLMD_P\t\t0x0510\n#define KS884X_P1CR4_P\t\t\t0x0512\n#define KS884X_P1SR_P\t\t\t0x0514\n\n \n#define KS8842_P2CR1_P\t\t\t0x0520\n#define KS8842_P2CR2_P\t\t\t0x0522\n#define KS8842_P2VIDR_P\t\t\t0x0524\n#define KS8842_P2CR3_P\t\t\t0x0526\n#define KS8842_P2IRCR_P\t\t\t0x0528\n#define KS8842_P2ERCR_P\t\t\t0x052A\n#define KS884X_P2SCSLMD_P\t\t0x0530\n#define KS884X_P2CR4_P\t\t\t0x0532\n#define KS884X_P2SR_P\t\t\t0x0534\n\n \n#define KS8842_P3CR1_P\t\t\t0x0540\n#define KS8842_P3CR2_P\t\t\t0x0542\n#define KS8842_P3VIDR_P\t\t\t0x0544\n#define KS8842_P3CR3_P\t\t\t0x0546\n#define KS8842_P3IRCR_P\t\t\t0x0548\n#define KS8842_P3ERCR_P\t\t\t0x054A\n\n#define KS8842_PORT_1_CTRL_1\t\tKS8842_P1CR1_P\n#define KS8842_PORT_2_CTRL_1\t\tKS8842_P2CR1_P\n#define KS8842_PORT_3_CTRL_1\t\tKS8842_P3CR1_P\n\n#define PORT_CTRL_ADDR(port, addr)\t\t\\\n\t(addr = KS8842_PORT_1_CTRL_1 + (port) *\t\\\n\t\t(KS8842_PORT_2_CTRL_1 - KS8842_PORT_1_CTRL_1))\n\n#define KS8842_PORT_CTRL_1_OFFSET\t0x00\n\n#define PORT_BROADCAST_STORM\t\t0x0080\n#define PORT_DIFFSERV_ENABLE\t\t0x0040\n#define PORT_802_1P_ENABLE\t\t0x0020\n#define PORT_BASED_PRIORITY_MASK\t0x0018\n#define PORT_BASED_PRIORITY_BASE\t0x0003\n#define PORT_BASED_PRIORITY_SHIFT\t3\n#define PORT_BASED_PRIORITY_0\t\t0x0000\n#define PORT_BASED_PRIORITY_1\t\t0x0008\n#define PORT_BASED_PRIORITY_2\t\t0x0010\n#define PORT_BASED_PRIORITY_3\t\t0x0018\n#define PORT_INSERT_TAG\t\t\t0x0004\n#define PORT_REMOVE_TAG\t\t\t0x0002\n#define PORT_PRIO_QUEUE_ENABLE\t\t0x0001\n\n#define KS8842_PORT_CTRL_2_OFFSET\t0x02\n\n#define PORT_INGRESS_VLAN_FILTER\t0x4000\n#define PORT_DISCARD_NON_VID\t\t0x2000\n#define PORT_FORCE_FLOW_CTRL\t\t0x1000\n#define PORT_BACK_PRESSURE\t\t0x0800\n#define PORT_TX_ENABLE\t\t\t0x0400\n#define PORT_RX_ENABLE\t\t\t0x0200\n#define PORT_LEARN_DISABLE\t\t0x0100\n#define PORT_MIRROR_SNIFFER\t\t0x0080\n#define PORT_MIRROR_RX\t\t\t0x0040\n#define PORT_MIRROR_TX\t\t\t0x0020\n#define PORT_USER_PRIORITY_CEILING\t0x0008\n#define PORT_VLAN_MEMBERSHIP\t\t0x0007\n\n#define KS8842_PORT_CTRL_VID_OFFSET\t0x04\n\n#define PORT_DEFAULT_VID\t\t0x0001\n\n#define KS8842_PORT_CTRL_3_OFFSET\t0x06\n\n#define PORT_INGRESS_LIMIT_MODE\t\t0x000C\n#define PORT_INGRESS_ALL\t\t0x0000\n#define PORT_INGRESS_UNICAST\t\t0x0004\n#define PORT_INGRESS_MULTICAST\t\t0x0008\n#define PORT_INGRESS_BROADCAST\t\t0x000C\n#define PORT_COUNT_IFG\t\t\t0x0002\n#define PORT_COUNT_PREAMBLE\t\t0x0001\n\n#define KS8842_PORT_IN_RATE_OFFSET\t0x08\n#define KS8842_PORT_OUT_RATE_OFFSET\t0x0A\n\n#define PORT_PRIORITY_RATE\t\t0x0F\n#define PORT_PRIORITY_RATE_SHIFT\t4\n\n#define KS884X_PORT_LINK_MD\t\t0x10\n\n#define PORT_CABLE_10M_SHORT\t\t0x8000\n#define PORT_CABLE_DIAG_RESULT\t\t0x6000\n#define PORT_CABLE_STAT_NORMAL\t\t0x0000\n#define PORT_CABLE_STAT_OPEN\t\t0x2000\n#define PORT_CABLE_STAT_SHORT\t\t0x4000\n#define PORT_CABLE_STAT_FAILED\t\t0x6000\n#define PORT_START_CABLE_DIAG\t\t0x1000\n#define PORT_FORCE_LINK\t\t\t0x0800\n#define PORT_POWER_SAVING_DISABLE\t0x0400\n#define PORT_PHY_REMOTE_LOOPBACK\t0x0200\n#define PORT_CABLE_FAULT_COUNTER\t0x01FF\n\n#define KS884X_PORT_CTRL_4_OFFSET\t0x12\n\n#define PORT_LED_OFF\t\t\t0x8000\n#define PORT_TX_DISABLE\t\t\t0x4000\n#define PORT_AUTO_NEG_RESTART\t\t0x2000\n#define PORT_REMOTE_FAULT_DISABLE\t0x1000\n#define PORT_POWER_DOWN\t\t\t0x0800\n#define PORT_AUTO_MDIX_DISABLE\t\t0x0400\n#define PORT_FORCE_MDIX\t\t\t0x0200\n#define PORT_LOOPBACK\t\t\t0x0100\n#define PORT_AUTO_NEG_ENABLE\t\t0x0080\n#define PORT_FORCE_100_MBIT\t\t0x0040\n#define PORT_FORCE_FULL_DUPLEX\t\t0x0020\n#define PORT_AUTO_NEG_SYM_PAUSE\t\t0x0010\n#define PORT_AUTO_NEG_100BTX_FD\t\t0x0008\n#define PORT_AUTO_NEG_100BTX\t\t0x0004\n#define PORT_AUTO_NEG_10BT_FD\t\t0x0002\n#define PORT_AUTO_NEG_10BT\t\t0x0001\n\n#define KS884X_PORT_STATUS_OFFSET\t0x14\n\n#define PORT_HP_MDIX\t\t\t0x8000\n#define PORT_REVERSED_POLARITY\t\t0x2000\n#define PORT_RX_FLOW_CTRL\t\t0x0800\n#define PORT_TX_FLOW_CTRL\t\t0x1000\n#define PORT_STATUS_SPEED_100MBIT\t0x0400\n#define PORT_STATUS_FULL_DUPLEX\t\t0x0200\n#define PORT_REMOTE_FAULT\t\t0x0100\n#define PORT_MDIX_STATUS\t\t0x0080\n#define PORT_AUTO_NEG_COMPLETE\t\t0x0040\n#define PORT_STATUS_LINK_GOOD\t\t0x0020\n#define PORT_REMOTE_SYM_PAUSE\t\t0x0010\n#define PORT_REMOTE_100BTX_FD\t\t0x0008\n#define PORT_REMOTE_100BTX\t\t0x0004\n#define PORT_REMOTE_10BT_FD\t\t0x0002\n#define PORT_REMOTE_10BT\t\t0x0001\n\n \n\n#define STATIC_MAC_TABLE_ADDR\t\t0x0000FFFF\n#define STATIC_MAC_TABLE_FWD_PORTS\t0x00070000\n#define STATIC_MAC_TABLE_VALID\t\t0x00080000\n#define STATIC_MAC_TABLE_OVERRIDE\t0x00100000\n#define STATIC_MAC_TABLE_USE_FID\t0x00200000\n#define STATIC_MAC_TABLE_FID\t\t0x03C00000\n\n#define STATIC_MAC_FWD_PORTS_SHIFT\t16\n#define STATIC_MAC_FID_SHIFT\t\t22\n\n \n\n#define VLAN_TABLE_VID\t\t\t0x00000FFF\n#define VLAN_TABLE_FID\t\t\t0x0000F000\n#define VLAN_TABLE_MEMBERSHIP\t\t0x00070000\n#define VLAN_TABLE_VALID\t\t0x00080000\n\n#define VLAN_TABLE_FID_SHIFT\t\t12\n#define VLAN_TABLE_MEMBERSHIP_SHIFT\t16\n\n \n\n#define DYNAMIC_MAC_TABLE_ADDR\t\t0x0000FFFF\n#define DYNAMIC_MAC_TABLE_FID\t\t0x000F0000\n#define DYNAMIC_MAC_TABLE_SRC_PORT\t0x00300000\n#define DYNAMIC_MAC_TABLE_TIMESTAMP\t0x00C00000\n#define DYNAMIC_MAC_TABLE_ENTRIES\t0xFF000000\n\n#define DYNAMIC_MAC_TABLE_ENTRIES_H\t0x03\n#define DYNAMIC_MAC_TABLE_MAC_EMPTY\t0x04\n#define DYNAMIC_MAC_TABLE_RESERVED\t0x78\n#define DYNAMIC_MAC_TABLE_NOT_READY\t0x80\n\n#define DYNAMIC_MAC_FID_SHIFT\t\t16\n#define DYNAMIC_MAC_SRC_PORT_SHIFT\t20\n#define DYNAMIC_MAC_TIMESTAMP_SHIFT\t22\n#define DYNAMIC_MAC_ENTRIES_SHIFT\t24\n#define DYNAMIC_MAC_ENTRIES_H_SHIFT\t8\n\n \n\n#define MIB_COUNTER_VALUE\t\t0x3FFFFFFF\n#define MIB_COUNTER_VALID\t\t0x40000000\n#define MIB_COUNTER_OVERFLOW\t\t0x80000000\n\n#define MIB_PACKET_DROPPED\t\t0x0000FFFF\n\n#define KS_MIB_PACKET_DROPPED_TX_0\t0x100\n#define KS_MIB_PACKET_DROPPED_TX_1\t0x101\n#define KS_MIB_PACKET_DROPPED_TX\t0x102\n#define KS_MIB_PACKET_DROPPED_RX_0\t0x103\n#define KS_MIB_PACKET_DROPPED_RX_1\t0x104\n#define KS_MIB_PACKET_DROPPED_RX\t0x105\n\n \n#define SET_DEFAULT_LED\t\t\tLED_SPEED_DUPLEX_ACT\n\n#define MAC_ADDR_ORDER(i)\t\t(ETH_ALEN - 1 - (i))\n\n#define MAX_ETHERNET_BODY_SIZE\t\t1500\n#define ETHERNET_HEADER_SIZE\t\t(14 + VLAN_HLEN)\n\n#define MAX_ETHERNET_PACKET_SIZE\t\\\n\t(MAX_ETHERNET_BODY_SIZE + ETHERNET_HEADER_SIZE)\n\n#define REGULAR_RX_BUF_SIZE\t\t(MAX_ETHERNET_PACKET_SIZE + 4)\n#define MAX_RX_BUF_SIZE\t\t\t(1912 + 4)\n\n#define ADDITIONAL_ENTRIES\t\t16\n#define MAX_MULTICAST_LIST\t\t32\n\n#define HW_MULTICAST_SIZE\t\t8\n\n#define HW_TO_DEV_PORT(port)\t\t(port - 1)\n\nenum {\n\tmedia_connected,\n\tmedia_disconnected\n};\n\nenum {\n\tOID_COUNTER_UNKOWN,\n\n\tOID_COUNTER_FIRST,\n\n\t \n\tOID_COUNTER_XMIT_ERROR,\n\n\t \n\tOID_COUNTER_RCV_ERROR,\n\n\tOID_COUNTER_LAST\n};\n\n \n\n#define DESC_ALIGNMENT\t\t\t16\n#define BUFFER_ALIGNMENT\t\t8\n\n#define NUM_OF_RX_DESC\t\t\t64\n#define NUM_OF_TX_DESC\t\t\t64\n\n#define KS_DESC_RX_FRAME_LEN\t\t0x000007FF\n#define KS_DESC_RX_FRAME_TYPE\t\t0x00008000\n#define KS_DESC_RX_ERROR_CRC\t\t0x00010000\n#define KS_DESC_RX_ERROR_RUNT\t\t0x00020000\n#define KS_DESC_RX_ERROR_TOO_LONG\t0x00040000\n#define KS_DESC_RX_ERROR_PHY\t\t0x00080000\n#define KS884X_DESC_RX_PORT_MASK\t0x00300000\n#define KS_DESC_RX_MULTICAST\t\t0x01000000\n#define KS_DESC_RX_ERROR\t\t0x02000000\n#define KS_DESC_RX_ERROR_CSUM_UDP\t0x04000000\n#define KS_DESC_RX_ERROR_CSUM_TCP\t0x08000000\n#define KS_DESC_RX_ERROR_CSUM_IP\t0x10000000\n#define KS_DESC_RX_LAST\t\t\t0x20000000\n#define KS_DESC_RX_FIRST\t\t0x40000000\n#define KS_DESC_RX_ERROR_COND\t\t\\\n\t(KS_DESC_RX_ERROR_CRC |\t\t\\\n\tKS_DESC_RX_ERROR_RUNT |\t\t\\\n\tKS_DESC_RX_ERROR_PHY |\t\t\\\n\tKS_DESC_RX_ERROR_TOO_LONG)\n\n#define KS_DESC_HW_OWNED\t\t0x80000000\n\n#define KS_DESC_BUF_SIZE\t\t0x000007FF\n#define KS884X_DESC_TX_PORT_MASK\t0x00300000\n#define KS_DESC_END_OF_RING\t\t0x02000000\n#define KS_DESC_TX_CSUM_GEN_UDP\t\t0x04000000\n#define KS_DESC_TX_CSUM_GEN_TCP\t\t0x08000000\n#define KS_DESC_TX_CSUM_GEN_IP\t\t0x10000000\n#define KS_DESC_TX_LAST\t\t\t0x20000000\n#define KS_DESC_TX_FIRST\t\t0x40000000\n#define KS_DESC_TX_INTERRUPT\t\t0x80000000\n\n#define KS_DESC_PORT_SHIFT\t\t20\n\n#define KS_DESC_RX_MASK\t\t\t(KS_DESC_BUF_SIZE)\n\n#define KS_DESC_TX_MASK\t\t\t\\\n\t(KS_DESC_TX_INTERRUPT |\t\t\\\n\tKS_DESC_TX_FIRST |\t\t\\\n\tKS_DESC_TX_LAST |\t\t\\\n\tKS_DESC_TX_CSUM_GEN_IP |\t\\\n\tKS_DESC_TX_CSUM_GEN_TCP |\t\\\n\tKS_DESC_TX_CSUM_GEN_UDP |\t\\\n\tKS_DESC_BUF_SIZE)\n\nstruct ksz_desc_rx_stat {\n#ifdef __BIG_ENDIAN_BITFIELD\n\tu32 hw_owned:1;\n\tu32 first_desc:1;\n\tu32 last_desc:1;\n\tu32 csum_err_ip:1;\n\tu32 csum_err_tcp:1;\n\tu32 csum_err_udp:1;\n\tu32 error:1;\n\tu32 multicast:1;\n\tu32 src_port:4;\n\tu32 err_phy:1;\n\tu32 err_too_long:1;\n\tu32 err_runt:1;\n\tu32 err_crc:1;\n\tu32 frame_type:1;\n\tu32 reserved1:4;\n\tu32 frame_len:11;\n#else\n\tu32 frame_len:11;\n\tu32 reserved1:4;\n\tu32 frame_type:1;\n\tu32 err_crc:1;\n\tu32 err_runt:1;\n\tu32 err_too_long:1;\n\tu32 err_phy:1;\n\tu32 src_port:4;\n\tu32 multicast:1;\n\tu32 error:1;\n\tu32 csum_err_udp:1;\n\tu32 csum_err_tcp:1;\n\tu32 csum_err_ip:1;\n\tu32 last_desc:1;\n\tu32 first_desc:1;\n\tu32 hw_owned:1;\n#endif\n};\n\nstruct ksz_desc_tx_stat {\n#ifdef __BIG_ENDIAN_BITFIELD\n\tu32 hw_owned:1;\n\tu32 reserved1:31;\n#else\n\tu32 reserved1:31;\n\tu32 hw_owned:1;\n#endif\n};\n\nstruct ksz_desc_rx_buf {\n#ifdef __BIG_ENDIAN_BITFIELD\n\tu32 reserved4:6;\n\tu32 end_of_ring:1;\n\tu32 reserved3:14;\n\tu32 buf_size:11;\n#else\n\tu32 buf_size:11;\n\tu32 reserved3:14;\n\tu32 end_of_ring:1;\n\tu32 reserved4:6;\n#endif\n};\n\nstruct ksz_desc_tx_buf {\n#ifdef __BIG_ENDIAN_BITFIELD\n\tu32 intr:1;\n\tu32 first_seg:1;\n\tu32 last_seg:1;\n\tu32 csum_gen_ip:1;\n\tu32 csum_gen_tcp:1;\n\tu32 csum_gen_udp:1;\n\tu32 end_of_ring:1;\n\tu32 reserved4:1;\n\tu32 dest_port:4;\n\tu32 reserved3:9;\n\tu32 buf_size:11;\n#else\n\tu32 buf_size:11;\n\tu32 reserved3:9;\n\tu32 dest_port:4;\n\tu32 reserved4:1;\n\tu32 end_of_ring:1;\n\tu32 csum_gen_udp:1;\n\tu32 csum_gen_tcp:1;\n\tu32 csum_gen_ip:1;\n\tu32 last_seg:1;\n\tu32 first_seg:1;\n\tu32 intr:1;\n#endif\n};\n\nunion desc_stat {\n\tstruct ksz_desc_rx_stat rx;\n\tstruct ksz_desc_tx_stat tx;\n\tu32 data;\n};\n\nunion desc_buf {\n\tstruct ksz_desc_rx_buf rx;\n\tstruct ksz_desc_tx_buf tx;\n\tu32 data;\n};\n\n \nstruct ksz_hw_desc {\n\tunion desc_stat ctrl;\n\tunion desc_buf buf;\n\tu32 addr;\n\tu32 next;\n};\n\n \nstruct ksz_sw_desc {\n\tunion desc_stat ctrl;\n\tunion desc_buf buf;\n\tu32 buf_size;\n};\n\n \nstruct ksz_dma_buf {\n\tstruct sk_buff *skb;\n\tdma_addr_t dma;\n\tint len;\n};\n\n \nstruct ksz_desc {\n\tstruct ksz_hw_desc *phw;\n\tstruct ksz_sw_desc sw;\n\tstruct ksz_dma_buf dma_buf;\n};\n\n#define DMA_BUFFER(desc)  ((struct ksz_dma_buf *)(&(desc)->dma_buf))\n\n \nstruct ksz_desc_info {\n\tstruct ksz_desc *ring;\n\tstruct ksz_desc *cur;\n\tstruct ksz_hw_desc *ring_virt;\n\tu32 ring_phys;\n\tint size;\n\tint alloc;\n\tint avail;\n\tint last;\n\tint next;\n\tint mask;\n};\n\n \n\nenum {\n\tTABLE_STATIC_MAC = 0,\n\tTABLE_VLAN,\n\tTABLE_DYNAMIC_MAC,\n\tTABLE_MIB\n};\n\n#define LEARNED_MAC_TABLE_ENTRIES\t1024\n#define STATIC_MAC_TABLE_ENTRIES\t8\n\n \nstruct ksz_mac_table {\n\tu8 mac_addr[ETH_ALEN];\n\tu16 vid;\n\tu8 fid;\n\tu8 ports;\n\tu8 override:1;\n\tu8 use_fid:1;\n\tu8 valid:1;\n};\n\n#define VLAN_TABLE_ENTRIES\t\t16\n\n \nstruct ksz_vlan_table {\n\tu16 vid;\n\tu8 fid;\n\tu8 member;\n};\n\n#define DIFFSERV_ENTRIES\t\t64\n#define PRIO_802_1P_ENTRIES\t\t8\n#define PRIO_QUEUES\t\t\t4\n\n#define SWITCH_PORT_NUM\t\t\t2\n#define TOTAL_PORT_NUM\t\t\t(SWITCH_PORT_NUM + 1)\n#define HOST_MASK\t\t\t(1 << SWITCH_PORT_NUM)\n#define PORT_MASK\t\t\t7\n\n#define MAIN_PORT\t\t\t0\n#define OTHER_PORT\t\t\t1\n#define HOST_PORT\t\t\tSWITCH_PORT_NUM\n\n#define PORT_COUNTER_NUM\t\t0x20\n#define TOTAL_PORT_COUNTER_NUM\t\t(PORT_COUNTER_NUM + 2)\n\n#define MIB_COUNTER_RX_LO_PRIORITY\t0x00\n#define MIB_COUNTER_RX_HI_PRIORITY\t0x01\n#define MIB_COUNTER_RX_UNDERSIZE\t0x02\n#define MIB_COUNTER_RX_FRAGMENT\t\t0x03\n#define MIB_COUNTER_RX_OVERSIZE\t\t0x04\n#define MIB_COUNTER_RX_JABBER\t\t0x05\n#define MIB_COUNTER_RX_SYMBOL_ERR\t0x06\n#define MIB_COUNTER_RX_CRC_ERR\t\t0x07\n#define MIB_COUNTER_RX_ALIGNMENT_ERR\t0x08\n#define MIB_COUNTER_RX_CTRL_8808\t0x09\n#define MIB_COUNTER_RX_PAUSE\t\t0x0A\n#define MIB_COUNTER_RX_BROADCAST\t0x0B\n#define MIB_COUNTER_RX_MULTICAST\t0x0C\n#define MIB_COUNTER_RX_UNICAST\t\t0x0D\n#define MIB_COUNTER_RX_OCTET_64\t\t0x0E\n#define MIB_COUNTER_RX_OCTET_65_127\t0x0F\n#define MIB_COUNTER_RX_OCTET_128_255\t0x10\n#define MIB_COUNTER_RX_OCTET_256_511\t0x11\n#define MIB_COUNTER_RX_OCTET_512_1023\t0x12\n#define MIB_COUNTER_RX_OCTET_1024_1522\t0x13\n#define MIB_COUNTER_TX_LO_PRIORITY\t0x14\n#define MIB_COUNTER_TX_HI_PRIORITY\t0x15\n#define MIB_COUNTER_TX_LATE_COLLISION\t0x16\n#define MIB_COUNTER_TX_PAUSE\t\t0x17\n#define MIB_COUNTER_TX_BROADCAST\t0x18\n#define MIB_COUNTER_TX_MULTICAST\t0x19\n#define MIB_COUNTER_TX_UNICAST\t\t0x1A\n#define MIB_COUNTER_TX_DEFERRED\t\t0x1B\n#define MIB_COUNTER_TX_TOTAL_COLLISION\t0x1C\n#define MIB_COUNTER_TX_EXCESS_COLLISION\t0x1D\n#define MIB_COUNTER_TX_SINGLE_COLLISION\t0x1E\n#define MIB_COUNTER_TX_MULTI_COLLISION\t0x1F\n\n#define MIB_COUNTER_RX_DROPPED_PACKET\t0x20\n#define MIB_COUNTER_TX_DROPPED_PACKET\t0x21\n\n \nstruct ksz_port_mib {\n\tu8 cnt_ptr;\n\tu8 link_down;\n\tu8 state;\n\tu8 mib_start;\n\n\tu64 counter[TOTAL_PORT_COUNTER_NUM];\n\tu32 dropped[2];\n};\n\n \nstruct ksz_port_cfg {\n\tu16 vid;\n\tu8 member;\n\tu8 port_prio;\n\tu32 rx_rate[PRIO_QUEUES];\n\tu32 tx_rate[PRIO_QUEUES];\n\tint stp_state;\n};\n\n \nstruct ksz_switch {\n\tstruct ksz_mac_table mac_table[STATIC_MAC_TABLE_ENTRIES];\n\tstruct ksz_vlan_table vlan_table[VLAN_TABLE_ENTRIES];\n\tstruct ksz_port_cfg port_cfg[TOTAL_PORT_NUM];\n\n\tu8 diffserv[DIFFSERV_ENTRIES];\n\tu8 p_802_1p[PRIO_802_1P_ENTRIES];\n\n\tu8 br_addr[ETH_ALEN];\n\tu8 other_addr[ETH_ALEN];\n\n\tu8 broad_per;\n\tu8 member;\n};\n\n#define TX_RATE_UNIT\t\t\t10000\n\n \nstruct ksz_port_info {\n\tuint state;\n\tuint tx_rate;\n\tu8 duplex;\n\tu8 advertised;\n\tu8 partner;\n\tu8 port_id;\n\tvoid *pdev;\n};\n\n#define MAX_TX_HELD_SIZE\t\t52000\n\n \n#define LINK_INT_WORKING\t\t(1 << 0)\n#define SMALL_PACKET_TX_BUG\t\t(1 << 1)\n#define HALF_DUPLEX_SIGNAL_BUG\t\t(1 << 2)\n#define RX_HUGE_FRAME\t\t\t(1 << 4)\n#define STP_SUPPORT\t\t\t(1 << 8)\n\n \n#define PAUSE_FLOW_CTRL\t\t\t(1 << 0)\n#define FAST_AGING\t\t\t(1 << 1)\n\n \nstruct ksz_hw {\n\tvoid __iomem *io;\n\n\tstruct ksz_switch *ksz_switch;\n\tstruct ksz_port_info port_info[SWITCH_PORT_NUM];\n\tstruct ksz_port_mib port_mib[TOTAL_PORT_NUM];\n\tint dev_count;\n\tint dst_ports;\n\tint id;\n\tint mib_cnt;\n\tint mib_port_cnt;\n\n\tu32 tx_cfg;\n\tu32 rx_cfg;\n\tu32 intr_mask;\n\tu32 intr_set;\n\tuint intr_blocked;\n\n\tstruct ksz_desc_info rx_desc_info;\n\tstruct ksz_desc_info tx_desc_info;\n\n\tint tx_int_cnt;\n\tint tx_int_mask;\n\tint tx_size;\n\n\tu8 perm_addr[ETH_ALEN];\n\tu8 override_addr[ETH_ALEN];\n\tu8 address[ADDITIONAL_ENTRIES][ETH_ALEN];\n\tu8 addr_list_size;\n\tu8 mac_override;\n\tu8 promiscuous;\n\tu8 all_multi;\n\tu8 multi_list[MAX_MULTICAST_LIST][ETH_ALEN];\n\tu8 multi_bits[HW_MULTICAST_SIZE];\n\tu8 multi_list_size;\n\n\tu8 enabled;\n\tu8 rx_stop;\n\tu8 reserved2[1];\n\n\tuint features;\n\tuint overrides;\n\n\tvoid *parent;\n};\n\nenum {\n\tPHY_NO_FLOW_CTRL,\n\tPHY_FLOW_CTRL,\n\tPHY_TX_ONLY,\n\tPHY_RX_ONLY\n};\n\n \nstruct ksz_port {\n\tu8 duplex;\n\tu8 speed;\n\tu8 force_link;\n\tu8 flow_ctrl;\n\n\tint first_port;\n\tint mib_port_cnt;\n\tint port_cnt;\n\tu64 counter[OID_COUNTER_LAST];\n\n\tstruct ksz_hw *hw;\n\tstruct ksz_port_info *linked;\n};\n\n \nstruct ksz_timer_info {\n\tstruct timer_list timer;\n\tint cnt;\n\tint max;\n\tint period;\n};\n\n \nstruct ksz_shared_mem {\n\tdma_addr_t dma_addr;\n\tuint alloc_size;\n\tuint phys;\n\tu8 *alloc_virt;\n\tu8 *virt;\n};\n\n \nstruct ksz_counter_info {\n\twait_queue_head_t counter;\n\tunsigned long time;\n\tint read;\n};\n\n \nstruct dev_info {\n\tstruct net_device *dev;\n\tstruct pci_dev *pdev;\n\n\tstruct ksz_hw hw;\n\tstruct ksz_shared_mem desc_pool;\n\n\tspinlock_t hwlock;\n\tstruct mutex lock;\n\n\tint (*dev_rcv)(struct dev_info *);\n\n\tstruct sk_buff *last_skb;\n\tint skb_index;\n\tint skb_len;\n\n\tstruct work_struct mib_read;\n\tstruct ksz_timer_info mib_timer_info;\n\tstruct ksz_counter_info counter[TOTAL_PORT_NUM];\n\n\tint mtu;\n\tint opened;\n\n\tstruct tasklet_struct rx_tasklet;\n\tstruct tasklet_struct tx_tasklet;\n\n\tint wol_enable;\n\tint wol_support;\n\tunsigned long pme_wait;\n};\n\n \nstruct dev_priv {\n\tstruct dev_info *adapter;\n\tstruct ksz_port port;\n\tstruct ksz_timer_info monitor_timer_info;\n\n\tstruct semaphore proc_sem;\n\tint id;\n\n\tstruct mii_if_info mii_if;\n\tu32 advertising;\n\n\tu32 msg_enable;\n\tint media_state;\n\tint multicast;\n\tint promiscuous;\n};\n\n#define DRV_NAME\t\t\"KSZ884X PCI\"\n#define DEVICE_NAME\t\t\"KSZ884x PCI\"\n#define DRV_VERSION\t\t\"1.0.0\"\n#define DRV_RELDATE\t\t\"Feb 8, 2010\"\n\nstatic char version[] =\n\t\"Micrel \" DEVICE_NAME \" \" DRV_VERSION \" (\" DRV_RELDATE \")\";\n\nstatic u8 DEFAULT_MAC_ADDRESS[] = { 0x00, 0x10, 0xA1, 0x88, 0x42, 0x01 };\n\n \n\nstatic inline void hw_ack_intr(struct ksz_hw *hw, uint interrupt)\n{\n\twritel(interrupt, hw->io + KS884X_INTERRUPTS_STATUS);\n}\n\nstatic inline void hw_dis_intr(struct ksz_hw *hw)\n{\n\thw->intr_blocked = hw->intr_mask;\n\twritel(0, hw->io + KS884X_INTERRUPTS_ENABLE);\n\thw->intr_set = readl(hw->io + KS884X_INTERRUPTS_ENABLE);\n}\n\nstatic inline void hw_set_intr(struct ksz_hw *hw, uint interrupt)\n{\n\thw->intr_set = interrupt;\n\twritel(interrupt, hw->io + KS884X_INTERRUPTS_ENABLE);\n}\n\nstatic inline void hw_ena_intr(struct ksz_hw *hw)\n{\n\thw->intr_blocked = 0;\n\thw_set_intr(hw, hw->intr_mask);\n}\n\nstatic inline void hw_dis_intr_bit(struct ksz_hw *hw, uint bit)\n{\n\thw->intr_mask &= ~(bit);\n}\n\nstatic inline void hw_turn_off_intr(struct ksz_hw *hw, uint interrupt)\n{\n\tu32 read_intr;\n\n\tread_intr = readl(hw->io + KS884X_INTERRUPTS_ENABLE);\n\thw->intr_set = read_intr & ~interrupt;\n\twritel(hw->intr_set, hw->io + KS884X_INTERRUPTS_ENABLE);\n\thw_dis_intr_bit(hw, interrupt);\n}\n\n \nstatic void hw_turn_on_intr(struct ksz_hw *hw, u32 bit)\n{\n\thw->intr_mask |= bit;\n\n\tif (!hw->intr_blocked)\n\t\thw_set_intr(hw, hw->intr_mask);\n}\n\nstatic inline void hw_read_intr(struct ksz_hw *hw, uint *status)\n{\n\t*status = readl(hw->io + KS884X_INTERRUPTS_STATUS);\n\t*status = *status & hw->intr_set;\n}\n\nstatic inline void hw_restore_intr(struct ksz_hw *hw, uint interrupt)\n{\n\tif (interrupt)\n\t\thw_ena_intr(hw);\n}\n\n \nstatic uint hw_block_intr(struct ksz_hw *hw)\n{\n\tuint interrupt = 0;\n\n\tif (!hw->intr_blocked) {\n\t\thw_dis_intr(hw);\n\t\tinterrupt = hw->intr_blocked;\n\t}\n\treturn interrupt;\n}\n\n \n\nstatic inline void reset_desc(struct ksz_desc *desc, union desc_stat status)\n{\n\tstatus.rx.hw_owned = 0;\n\tdesc->phw->ctrl.data = cpu_to_le32(status.data);\n}\n\nstatic inline void release_desc(struct ksz_desc *desc)\n{\n\tdesc->sw.ctrl.tx.hw_owned = 1;\n\tif (desc->sw.buf_size != desc->sw.buf.data) {\n\t\tdesc->sw.buf_size = desc->sw.buf.data;\n\t\tdesc->phw->buf.data = cpu_to_le32(desc->sw.buf.data);\n\t}\n\tdesc->phw->ctrl.data = cpu_to_le32(desc->sw.ctrl.data);\n}\n\nstatic void get_rx_pkt(struct ksz_desc_info *info, struct ksz_desc **desc)\n{\n\t*desc = &info->ring[info->last];\n\tinfo->last++;\n\tinfo->last &= info->mask;\n\tinfo->avail--;\n\t(*desc)->sw.buf.data &= ~KS_DESC_RX_MASK;\n}\n\nstatic inline void set_rx_buf(struct ksz_desc *desc, u32 addr)\n{\n\tdesc->phw->addr = cpu_to_le32(addr);\n}\n\nstatic inline void set_rx_len(struct ksz_desc *desc, u32 len)\n{\n\tdesc->sw.buf.rx.buf_size = len;\n}\n\nstatic inline void get_tx_pkt(struct ksz_desc_info *info,\n\tstruct ksz_desc **desc)\n{\n\t*desc = &info->ring[info->next];\n\tinfo->next++;\n\tinfo->next &= info->mask;\n\tinfo->avail--;\n\t(*desc)->sw.buf.data &= ~KS_DESC_TX_MASK;\n}\n\nstatic inline void set_tx_buf(struct ksz_desc *desc, u32 addr)\n{\n\tdesc->phw->addr = cpu_to_le32(addr);\n}\n\nstatic inline void set_tx_len(struct ksz_desc *desc, u32 len)\n{\n\tdesc->sw.buf.tx.buf_size = len;\n}\n\n \n\n#define TABLE_READ\t\t\t0x10\n#define TABLE_SEL_SHIFT\t\t\t2\n\n#define HW_DELAY(hw, reg)\t\t\t\\\n\tdo {\t\t\t\t\t\\\n\t\treadw(hw->io + reg);\t\t\\\n\t} while (0)\n\n \nstatic void sw_r_table(struct ksz_hw *hw, int table, u16 addr, u32 *data)\n{\n\tu16 ctrl_addr;\n\tuint interrupt;\n\n\tctrl_addr = (((table << TABLE_SEL_SHIFT) | TABLE_READ) << 8) | addr;\n\n\tinterrupt = hw_block_intr(hw);\n\n\twritew(ctrl_addr, hw->io + KS884X_IACR_OFFSET);\n\tHW_DELAY(hw, KS884X_IACR_OFFSET);\n\t*data = readl(hw->io + KS884X_ACC_DATA_0_OFFSET);\n\n\thw_restore_intr(hw, interrupt);\n}\n\n \nstatic void sw_w_table_64(struct ksz_hw *hw, int table, u16 addr, u32 data_hi,\n\tu32 data_lo)\n{\n\tu16 ctrl_addr;\n\tuint interrupt;\n\n\tctrl_addr = ((table << TABLE_SEL_SHIFT) << 8) | addr;\n\n\tinterrupt = hw_block_intr(hw);\n\n\twritel(data_hi, hw->io + KS884X_ACC_DATA_4_OFFSET);\n\twritel(data_lo, hw->io + KS884X_ACC_DATA_0_OFFSET);\n\n\twritew(ctrl_addr, hw->io + KS884X_IACR_OFFSET);\n\tHW_DELAY(hw, KS884X_IACR_OFFSET);\n\n\thw_restore_intr(hw, interrupt);\n}\n\n \nstatic void sw_w_sta_mac_table(struct ksz_hw *hw, u16 addr, u8 *mac_addr,\n\tu8 ports, int override, int valid, int use_fid, u8 fid)\n{\n\tu32 data_hi;\n\tu32 data_lo;\n\n\tdata_lo = ((u32) mac_addr[2] << 24) |\n\t\t((u32) mac_addr[3] << 16) |\n\t\t((u32) mac_addr[4] << 8) | mac_addr[5];\n\tdata_hi = ((u32) mac_addr[0] << 8) | mac_addr[1];\n\tdata_hi |= (u32) ports << STATIC_MAC_FWD_PORTS_SHIFT;\n\n\tif (override)\n\t\tdata_hi |= STATIC_MAC_TABLE_OVERRIDE;\n\tif (use_fid) {\n\t\tdata_hi |= STATIC_MAC_TABLE_USE_FID;\n\t\tdata_hi |= (u32) fid << STATIC_MAC_FID_SHIFT;\n\t}\n\tif (valid)\n\t\tdata_hi |= STATIC_MAC_TABLE_VALID;\n\n\tsw_w_table_64(hw, TABLE_STATIC_MAC, addr, data_hi, data_lo);\n}\n\n \nstatic int sw_r_vlan_table(struct ksz_hw *hw, u16 addr, u16 *vid, u8 *fid,\n\tu8 *member)\n{\n\tu32 data;\n\n\tsw_r_table(hw, TABLE_VLAN, addr, &data);\n\tif (data & VLAN_TABLE_VALID) {\n\t\t*vid = (u16)(data & VLAN_TABLE_VID);\n\t\t*fid = (u8)((data & VLAN_TABLE_FID) >> VLAN_TABLE_FID_SHIFT);\n\t\t*member = (u8)((data & VLAN_TABLE_MEMBERSHIP) >>\n\t\t\tVLAN_TABLE_MEMBERSHIP_SHIFT);\n\t\treturn 0;\n\t}\n\treturn -1;\n}\n\n \nstatic void port_r_mib_cnt(struct ksz_hw *hw, int port, u16 addr, u64 *cnt)\n{\n\tu32 data;\n\tu16 ctrl_addr;\n\tuint interrupt;\n\tint timeout;\n\n\tctrl_addr = addr + PORT_COUNTER_NUM * port;\n\n\tinterrupt = hw_block_intr(hw);\n\n\tctrl_addr |= (((TABLE_MIB << TABLE_SEL_SHIFT) | TABLE_READ) << 8);\n\twritew(ctrl_addr, hw->io + KS884X_IACR_OFFSET);\n\tHW_DELAY(hw, KS884X_IACR_OFFSET);\n\n\tfor (timeout = 100; timeout > 0; timeout--) {\n\t\tdata = readl(hw->io + KS884X_ACC_DATA_0_OFFSET);\n\n\t\tif (data & MIB_COUNTER_VALID) {\n\t\t\tif (data & MIB_COUNTER_OVERFLOW)\n\t\t\t\t*cnt += MIB_COUNTER_VALUE + 1;\n\t\t\t*cnt += data & MIB_COUNTER_VALUE;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\thw_restore_intr(hw, interrupt);\n}\n\n \nstatic void port_r_mib_pkt(struct ksz_hw *hw, int port, u32 *last, u64 *cnt)\n{\n\tu32 cur;\n\tu32 data;\n\tu16 ctrl_addr;\n\tuint interrupt;\n\tint index;\n\n\tindex = KS_MIB_PACKET_DROPPED_RX_0 + port;\n\tdo {\n\t\tinterrupt = hw_block_intr(hw);\n\n\t\tctrl_addr = (u16) index;\n\t\tctrl_addr |= (((TABLE_MIB << TABLE_SEL_SHIFT) | TABLE_READ)\n\t\t\t<< 8);\n\t\twritew(ctrl_addr, hw->io + KS884X_IACR_OFFSET);\n\t\tHW_DELAY(hw, KS884X_IACR_OFFSET);\n\t\tdata = readl(hw->io + KS884X_ACC_DATA_0_OFFSET);\n\n\t\thw_restore_intr(hw, interrupt);\n\n\t\tdata &= MIB_PACKET_DROPPED;\n\t\tcur = *last;\n\t\tif (data != cur) {\n\t\t\t*last = data;\n\t\t\tif (data < cur)\n\t\t\t\tdata += MIB_PACKET_DROPPED + 1;\n\t\t\tdata -= cur;\n\t\t\t*cnt += data;\n\t\t}\n\t\t++last;\n\t\t++cnt;\n\t\tindex -= KS_MIB_PACKET_DROPPED_TX -\n\t\t\tKS_MIB_PACKET_DROPPED_TX_0 + 1;\n\t} while (index >= KS_MIB_PACKET_DROPPED_TX_0 + port);\n}\n\n \nstatic int port_r_cnt(struct ksz_hw *hw, int port)\n{\n\tstruct ksz_port_mib *mib = &hw->port_mib[port];\n\n\tif (mib->mib_start < PORT_COUNTER_NUM)\n\t\twhile (mib->cnt_ptr < PORT_COUNTER_NUM) {\n\t\t\tport_r_mib_cnt(hw, port, mib->cnt_ptr,\n\t\t\t\t&mib->counter[mib->cnt_ptr]);\n\t\t\t++mib->cnt_ptr;\n\t\t}\n\tif (hw->mib_cnt > PORT_COUNTER_NUM)\n\t\tport_r_mib_pkt(hw, port, mib->dropped,\n\t\t\t&mib->counter[PORT_COUNTER_NUM]);\n\tmib->cnt_ptr = 0;\n\treturn 0;\n}\n\n \nstatic void port_init_cnt(struct ksz_hw *hw, int port)\n{\n\tstruct ksz_port_mib *mib = &hw->port_mib[port];\n\n\tmib->cnt_ptr = 0;\n\tif (mib->mib_start < PORT_COUNTER_NUM)\n\t\tdo {\n\t\t\tport_r_mib_cnt(hw, port, mib->cnt_ptr,\n\t\t\t\t&mib->counter[mib->cnt_ptr]);\n\t\t\t++mib->cnt_ptr;\n\t\t} while (mib->cnt_ptr < PORT_COUNTER_NUM);\n\tif (hw->mib_cnt > PORT_COUNTER_NUM)\n\t\tport_r_mib_pkt(hw, port, mib->dropped,\n\t\t\t&mib->counter[PORT_COUNTER_NUM]);\n\tmemset((void *) mib->counter, 0, sizeof(u64) * TOTAL_PORT_COUNTER_NUM);\n\tmib->cnt_ptr = 0;\n}\n\n \n\n \nstatic void port_cfg(struct ksz_hw *hw, int port, int offset, u16 bits,\n\tint set)\n{\n\tu32 addr;\n\tu16 data;\n\n\tPORT_CTRL_ADDR(port, addr);\n\taddr += offset;\n\tdata = readw(hw->io + addr);\n\tif (set)\n\t\tdata |= bits;\n\telse\n\t\tdata &= ~bits;\n\twritew(data, hw->io + addr);\n}\n\n \nstatic void port_r8(struct ksz_hw *hw, int port, int offset, u8 *data)\n{\n\tu32 addr;\n\n\tPORT_CTRL_ADDR(port, addr);\n\taddr += offset;\n\t*data = readb(hw->io + addr);\n}\n\n \nstatic void port_r16(struct ksz_hw *hw, int port, int offset, u16 *data)\n{\n\tu32 addr;\n\n\tPORT_CTRL_ADDR(port, addr);\n\taddr += offset;\n\t*data = readw(hw->io + addr);\n}\n\n \nstatic void port_w16(struct ksz_hw *hw, int port, int offset, u16 data)\n{\n\tu32 addr;\n\n\tPORT_CTRL_ADDR(port, addr);\n\taddr += offset;\n\twritew(data, hw->io + addr);\n}\n\n \nstatic int sw_chk(struct ksz_hw *hw, u32 addr, u16 bits)\n{\n\tu16 data;\n\n\tdata = readw(hw->io + addr);\n\treturn (data & bits) == bits;\n}\n\n \nstatic void sw_cfg(struct ksz_hw *hw, u32 addr, u16 bits, int set)\n{\n\tu16 data;\n\n\tdata = readw(hw->io + addr);\n\tif (set)\n\t\tdata |= bits;\n\telse\n\t\tdata &= ~bits;\n\twritew(data, hw->io + addr);\n}\n\n \n\nstatic inline void port_cfg_broad_storm(struct ksz_hw *hw, int p, int set)\n{\n\tport_cfg(hw, p,\n\t\tKS8842_PORT_CTRL_1_OFFSET, PORT_BROADCAST_STORM, set);\n}\n\n \n#define BROADCAST_STORM_PROTECTION_RATE\t10\n\n \n#define BROADCAST_STORM_VALUE\t\t9969\n\n \nstatic void sw_cfg_broad_storm(struct ksz_hw *hw, u8 percent)\n{\n\tu16 data;\n\tu32 value = ((u32) BROADCAST_STORM_VALUE * (u32) percent / 100);\n\n\tif (value > BROADCAST_STORM_RATE)\n\t\tvalue = BROADCAST_STORM_RATE;\n\n\tdata = readw(hw->io + KS8842_SWITCH_CTRL_3_OFFSET);\n\tdata &= ~(BROADCAST_STORM_RATE_LO | BROADCAST_STORM_RATE_HI);\n\tdata |= ((value & 0x00FF) << 8) | ((value & 0xFF00) >> 8);\n\twritew(data, hw->io + KS8842_SWITCH_CTRL_3_OFFSET);\n}\n\n \nstatic void sw_get_broad_storm(struct ksz_hw *hw, u8 *percent)\n{\n\tint num;\n\tu16 data;\n\n\tdata = readw(hw->io + KS8842_SWITCH_CTRL_3_OFFSET);\n\tnum = (data & BROADCAST_STORM_RATE_HI);\n\tnum <<= 8;\n\tnum |= (data & BROADCAST_STORM_RATE_LO) >> 8;\n\tnum = DIV_ROUND_CLOSEST(num * 100, BROADCAST_STORM_VALUE);\n\t*percent = (u8) num;\n}\n\n \nstatic void sw_dis_broad_storm(struct ksz_hw *hw, int port)\n{\n\tport_cfg_broad_storm(hw, port, 0);\n}\n\n \nstatic void sw_ena_broad_storm(struct ksz_hw *hw, int port)\n{\n\tsw_cfg_broad_storm(hw, hw->ksz_switch->broad_per);\n\tport_cfg_broad_storm(hw, port, 1);\n}\n\n \nstatic void sw_init_broad_storm(struct ksz_hw *hw)\n{\n\tint port;\n\n\thw->ksz_switch->broad_per = 1;\n\tsw_cfg_broad_storm(hw, hw->ksz_switch->broad_per);\n\tfor (port = 0; port < TOTAL_PORT_NUM; port++)\n\t\tsw_dis_broad_storm(hw, port);\n\tsw_cfg(hw, KS8842_SWITCH_CTRL_2_OFFSET, MULTICAST_STORM_DISABLE, 1);\n}\n\n \nstatic void hw_cfg_broad_storm(struct ksz_hw *hw, u8 percent)\n{\n\tif (percent > 100)\n\t\tpercent = 100;\n\n\tsw_cfg_broad_storm(hw, percent);\n\tsw_get_broad_storm(hw, &percent);\n\thw->ksz_switch->broad_per = percent;\n}\n\n \nstatic void sw_dis_prio_rate(struct ksz_hw *hw, int port)\n{\n\tu32 addr;\n\n\tPORT_CTRL_ADDR(port, addr);\n\taddr += KS8842_PORT_IN_RATE_OFFSET;\n\twritel(0, hw->io + addr);\n}\n\n \nstatic void sw_init_prio_rate(struct ksz_hw *hw)\n{\n\tint port;\n\tint prio;\n\tstruct ksz_switch *sw = hw->ksz_switch;\n\n\tfor (port = 0; port < TOTAL_PORT_NUM; port++) {\n\t\tfor (prio = 0; prio < PRIO_QUEUES; prio++) {\n\t\t\tsw->port_cfg[port].rx_rate[prio] =\n\t\t\tsw->port_cfg[port].tx_rate[prio] = 0;\n\t\t}\n\t\tsw_dis_prio_rate(hw, port);\n\t}\n}\n\n \n\nstatic inline void port_cfg_back_pressure(struct ksz_hw *hw, int p, int set)\n{\n\tport_cfg(hw, p,\n\t\tKS8842_PORT_CTRL_2_OFFSET, PORT_BACK_PRESSURE, set);\n}\n\n \n\nstatic inline void port_cfg_mirror_sniffer(struct ksz_hw *hw, int p, int set)\n{\n\tport_cfg(hw, p,\n\t\tKS8842_PORT_CTRL_2_OFFSET, PORT_MIRROR_SNIFFER, set);\n}\n\nstatic inline void port_cfg_mirror_rx(struct ksz_hw *hw, int p, int set)\n{\n\tport_cfg(hw, p,\n\t\tKS8842_PORT_CTRL_2_OFFSET, PORT_MIRROR_RX, set);\n}\n\nstatic inline void port_cfg_mirror_tx(struct ksz_hw *hw, int p, int set)\n{\n\tport_cfg(hw, p,\n\t\tKS8842_PORT_CTRL_2_OFFSET, PORT_MIRROR_TX, set);\n}\n\nstatic inline void sw_cfg_mirror_rx_tx(struct ksz_hw *hw, int set)\n{\n\tsw_cfg(hw, KS8842_SWITCH_CTRL_2_OFFSET, SWITCH_MIRROR_RX_TX, set);\n}\n\nstatic void sw_init_mirror(struct ksz_hw *hw)\n{\n\tint port;\n\n\tfor (port = 0; port < TOTAL_PORT_NUM; port++) {\n\t\tport_cfg_mirror_sniffer(hw, port, 0);\n\t\tport_cfg_mirror_rx(hw, port, 0);\n\t\tport_cfg_mirror_tx(hw, port, 0);\n\t}\n\tsw_cfg_mirror_rx_tx(hw, 0);\n}\n\n \n\nstatic inline void port_cfg_diffserv(struct ksz_hw *hw, int p, int set)\n{\n\tport_cfg(hw, p,\n\t\tKS8842_PORT_CTRL_1_OFFSET, PORT_DIFFSERV_ENABLE, set);\n}\n\nstatic inline void port_cfg_802_1p(struct ksz_hw *hw, int p, int set)\n{\n\tport_cfg(hw, p,\n\t\tKS8842_PORT_CTRL_1_OFFSET, PORT_802_1P_ENABLE, set);\n}\n\nstatic inline void port_cfg_replace_vid(struct ksz_hw *hw, int p, int set)\n{\n\tport_cfg(hw, p,\n\t\tKS8842_PORT_CTRL_2_OFFSET, PORT_USER_PRIORITY_CEILING, set);\n}\n\nstatic inline void port_cfg_prio(struct ksz_hw *hw, int p, int set)\n{\n\tport_cfg(hw, p,\n\t\tKS8842_PORT_CTRL_1_OFFSET, PORT_PRIO_QUEUE_ENABLE, set);\n}\n\n \nstatic void sw_dis_diffserv(struct ksz_hw *hw, int port)\n{\n\tport_cfg_diffserv(hw, port, 0);\n}\n\n \nstatic void sw_dis_802_1p(struct ksz_hw *hw, int port)\n{\n\tport_cfg_802_1p(hw, port, 0);\n}\n\n \nstatic void sw_cfg_replace_null_vid(struct ksz_hw *hw, int set)\n{\n\tsw_cfg(hw, KS8842_SWITCH_CTRL_3_OFFSET, SWITCH_REPLACE_NULL_VID, set);\n}\n\n \nstatic void sw_cfg_replace_vid(struct ksz_hw *hw, int port, int set)\n{\n\tport_cfg_replace_vid(hw, port, set);\n}\n\n \nstatic void sw_cfg_port_based(struct ksz_hw *hw, int port, u8 prio)\n{\n\tu16 data;\n\n\tif (prio > PORT_BASED_PRIORITY_BASE)\n\t\tprio = PORT_BASED_PRIORITY_BASE;\n\n\thw->ksz_switch->port_cfg[port].port_prio = prio;\n\n\tport_r16(hw, port, KS8842_PORT_CTRL_1_OFFSET, &data);\n\tdata &= ~PORT_BASED_PRIORITY_MASK;\n\tdata |= prio << PORT_BASED_PRIORITY_SHIFT;\n\tport_w16(hw, port, KS8842_PORT_CTRL_1_OFFSET, data);\n}\n\n \nstatic void sw_dis_multi_queue(struct ksz_hw *hw, int port)\n{\n\tport_cfg_prio(hw, port, 0);\n}\n\n \nstatic void sw_init_prio(struct ksz_hw *hw)\n{\n\tint port;\n\tint tos;\n\tstruct ksz_switch *sw = hw->ksz_switch;\n\n\t \n\tsw->p_802_1p[0] = 0;\n\tsw->p_802_1p[1] = 0;\n\tsw->p_802_1p[2] = 1;\n\tsw->p_802_1p[3] = 1;\n\tsw->p_802_1p[4] = 2;\n\tsw->p_802_1p[5] = 2;\n\tsw->p_802_1p[6] = 3;\n\tsw->p_802_1p[7] = 3;\n\n\t \n\tfor (tos = 0; tos < DIFFSERV_ENTRIES; tos++)\n\t\tsw->diffserv[tos] = 0;\n\n\t \n\tfor (port = 0; port < TOTAL_PORT_NUM; port++) {\n\t\tsw_dis_multi_queue(hw, port);\n\t\tsw_dis_diffserv(hw, port);\n\t\tsw_dis_802_1p(hw, port);\n\t\tsw_cfg_replace_vid(hw, port, 0);\n\n\t\tsw->port_cfg[port].port_prio = 0;\n\t\tsw_cfg_port_based(hw, port, sw->port_cfg[port].port_prio);\n\t}\n\tsw_cfg_replace_null_vid(hw, 0);\n}\n\n \nstatic void port_get_def_vid(struct ksz_hw *hw, int port, u16 *vid)\n{\n\tu32 addr;\n\n\tPORT_CTRL_ADDR(port, addr);\n\taddr += KS8842_PORT_CTRL_VID_OFFSET;\n\t*vid = readw(hw->io + addr);\n}\n\n \nstatic void sw_init_vlan(struct ksz_hw *hw)\n{\n\tint port;\n\tint entry;\n\tstruct ksz_switch *sw = hw->ksz_switch;\n\n\t \n\tfor (entry = 0; entry < VLAN_TABLE_ENTRIES; entry++) {\n\t\tsw_r_vlan_table(hw, entry,\n\t\t\t&sw->vlan_table[entry].vid,\n\t\t\t&sw->vlan_table[entry].fid,\n\t\t\t&sw->vlan_table[entry].member);\n\t}\n\n\tfor (port = 0; port < TOTAL_PORT_NUM; port++) {\n\t\tport_get_def_vid(hw, port, &sw->port_cfg[port].vid);\n\t\tsw->port_cfg[port].member = PORT_MASK;\n\t}\n}\n\n \nstatic void sw_cfg_port_base_vlan(struct ksz_hw *hw, int port, u8 member)\n{\n\tu32 addr;\n\tu8 data;\n\n\tPORT_CTRL_ADDR(port, addr);\n\taddr += KS8842_PORT_CTRL_2_OFFSET;\n\n\tdata = readb(hw->io + addr);\n\tdata &= ~PORT_VLAN_MEMBERSHIP;\n\tdata |= (member & PORT_MASK);\n\twriteb(data, hw->io + addr);\n\n\thw->ksz_switch->port_cfg[port].member = member;\n}\n\n \nstatic void sw_set_addr(struct ksz_hw *hw, u8 *mac_addr)\n{\n\tint i;\n\n\tfor (i = 0; i < 6; i += 2) {\n\t\twriteb(mac_addr[i], hw->io + KS8842_MAC_ADDR_0_OFFSET + i);\n\t\twriteb(mac_addr[1 + i], hw->io + KS8842_MAC_ADDR_1_OFFSET + i);\n\t}\n}\n\n \nstatic void sw_set_global_ctrl(struct ksz_hw *hw)\n{\n\tu16 data;\n\n\t \n\tdata = readw(hw->io + KS8842_SWITCH_CTRL_3_OFFSET);\n\tdata |= SWITCH_FLOW_CTRL;\n\twritew(data, hw->io + KS8842_SWITCH_CTRL_3_OFFSET);\n\n\tdata = readw(hw->io + KS8842_SWITCH_CTRL_1_OFFSET);\n\n\t \n\tdata |= SWITCH_AGGR_BACKOFF;\n\n\t \n\tdata |= SWITCH_AGING_ENABLE;\n\tdata |= SWITCH_LINK_AUTO_AGING;\n\n\tif (hw->overrides & FAST_AGING)\n\t\tdata |= SWITCH_FAST_AGING;\n\telse\n\t\tdata &= ~SWITCH_FAST_AGING;\n\twritew(data, hw->io + KS8842_SWITCH_CTRL_1_OFFSET);\n\n\tdata = readw(hw->io + KS8842_SWITCH_CTRL_2_OFFSET);\n\n\t \n\tdata |= NO_EXC_COLLISION_DROP;\n\twritew(data, hw->io + KS8842_SWITCH_CTRL_2_OFFSET);\n}\n\nenum {\n\tSTP_STATE_DISABLED = 0,\n\tSTP_STATE_LISTENING,\n\tSTP_STATE_LEARNING,\n\tSTP_STATE_FORWARDING,\n\tSTP_STATE_BLOCKED,\n\tSTP_STATE_SIMPLE\n};\n\n \nstatic void port_set_stp_state(struct ksz_hw *hw, int port, int state)\n{\n\tu16 data;\n\n\tport_r16(hw, port, KS8842_PORT_CTRL_2_OFFSET, &data);\n\tswitch (state) {\n\tcase STP_STATE_DISABLED:\n\t\tdata &= ~(PORT_TX_ENABLE | PORT_RX_ENABLE);\n\t\tdata |= PORT_LEARN_DISABLE;\n\t\tbreak;\n\tcase STP_STATE_LISTENING:\n \n\t\tdata &= ~PORT_TX_ENABLE;\n\t\tdata |= PORT_RX_ENABLE;\n\t\tdata |= PORT_LEARN_DISABLE;\n\t\tbreak;\n\tcase STP_STATE_LEARNING:\n\t\tdata &= ~PORT_TX_ENABLE;\n\t\tdata |= PORT_RX_ENABLE;\n\t\tdata &= ~PORT_LEARN_DISABLE;\n\t\tbreak;\n\tcase STP_STATE_FORWARDING:\n\t\tdata |= (PORT_TX_ENABLE | PORT_RX_ENABLE);\n\t\tdata &= ~PORT_LEARN_DISABLE;\n\t\tbreak;\n\tcase STP_STATE_BLOCKED:\n \n\t\tdata &= ~(PORT_TX_ENABLE | PORT_RX_ENABLE);\n\t\tdata |= PORT_LEARN_DISABLE;\n\t\tbreak;\n\tcase STP_STATE_SIMPLE:\n\t\tdata |= (PORT_TX_ENABLE | PORT_RX_ENABLE);\n\t\tdata |= PORT_LEARN_DISABLE;\n\t\tbreak;\n\t}\n\tport_w16(hw, port, KS8842_PORT_CTRL_2_OFFSET, data);\n\thw->ksz_switch->port_cfg[port].stp_state = state;\n}\n\n#define STP_ENTRY\t\t\t0\n#define BROADCAST_ENTRY\t\t\t1\n#define BRIDGE_ADDR_ENTRY\t\t2\n#define IPV6_ADDR_ENTRY\t\t\t3\n\n \nstatic void sw_clr_sta_mac_table(struct ksz_hw *hw)\n{\n\tstruct ksz_mac_table *entry;\n\tint i;\n\n\tfor (i = 0; i < STATIC_MAC_TABLE_ENTRIES; i++) {\n\t\tentry = &hw->ksz_switch->mac_table[i];\n\t\tsw_w_sta_mac_table(hw, i,\n\t\t\tentry->mac_addr, entry->ports,\n\t\t\tentry->override, 0,\n\t\t\tentry->use_fid, entry->fid);\n\t}\n}\n\n \nstatic void sw_init_stp(struct ksz_hw *hw)\n{\n\tstruct ksz_mac_table *entry;\n\n\tentry = &hw->ksz_switch->mac_table[STP_ENTRY];\n\tentry->mac_addr[0] = 0x01;\n\tentry->mac_addr[1] = 0x80;\n\tentry->mac_addr[2] = 0xC2;\n\tentry->mac_addr[3] = 0x00;\n\tentry->mac_addr[4] = 0x00;\n\tentry->mac_addr[5] = 0x00;\n\tentry->ports = HOST_MASK;\n\tentry->override = 1;\n\tentry->valid = 1;\n\tsw_w_sta_mac_table(hw, STP_ENTRY,\n\t\tentry->mac_addr, entry->ports,\n\t\tentry->override, entry->valid,\n\t\tentry->use_fid, entry->fid);\n}\n\n \nstatic void sw_block_addr(struct ksz_hw *hw)\n{\n\tstruct ksz_mac_table *entry;\n\tint i;\n\n\tfor (i = BROADCAST_ENTRY; i <= IPV6_ADDR_ENTRY; i++) {\n\t\tentry = &hw->ksz_switch->mac_table[i];\n\t\tentry->valid = 0;\n\t\tsw_w_sta_mac_table(hw, i,\n\t\t\tentry->mac_addr, entry->ports,\n\t\t\tentry->override, entry->valid,\n\t\t\tentry->use_fid, entry->fid);\n\t}\n}\n\nstatic inline void hw_r_phy_ctrl(struct ksz_hw *hw, int phy, u16 *data)\n{\n\t*data = readw(hw->io + phy + KS884X_PHY_CTRL_OFFSET);\n}\n\nstatic inline void hw_w_phy_ctrl(struct ksz_hw *hw, int phy, u16 data)\n{\n\twritew(data, hw->io + phy + KS884X_PHY_CTRL_OFFSET);\n}\n\n \nstatic void hw_r_phy(struct ksz_hw *hw, int port, u16 reg, u16 *val)\n{\n\tint phy;\n\n\tphy = KS884X_PHY_1_CTRL_OFFSET + port * PHY_CTRL_INTERVAL + reg;\n\t*val = readw(hw->io + phy);\n}\n\n \nstatic void hw_w_phy(struct ksz_hw *hw, int port, u16 reg, u16 val)\n{\n\tint phy;\n\n\tphy = KS884X_PHY_1_CTRL_OFFSET + port * PHY_CTRL_INTERVAL + reg;\n\twritew(val, hw->io + phy);\n}\n\n \n\n#define AT93C_CODE\t\t\t0\n#define AT93C_WR_OFF\t\t\t0x00\n#define AT93C_WR_ALL\t\t\t0x10\n#define AT93C_ER_ALL\t\t\t0x20\n#define AT93C_WR_ON\t\t\t0x30\n\n#define AT93C_WRITE\t\t\t1\n#define AT93C_READ\t\t\t2\n#define AT93C_ERASE\t\t\t3\n\n#define EEPROM_DELAY\t\t\t4\n\nstatic inline void drop_gpio(struct ksz_hw *hw, u8 gpio)\n{\n\tu16 data;\n\n\tdata = readw(hw->io + KS884X_EEPROM_CTRL_OFFSET);\n\tdata &= ~gpio;\n\twritew(data, hw->io + KS884X_EEPROM_CTRL_OFFSET);\n}\n\nstatic inline void raise_gpio(struct ksz_hw *hw, u8 gpio)\n{\n\tu16 data;\n\n\tdata = readw(hw->io + KS884X_EEPROM_CTRL_OFFSET);\n\tdata |= gpio;\n\twritew(data, hw->io + KS884X_EEPROM_CTRL_OFFSET);\n}\n\nstatic inline u8 state_gpio(struct ksz_hw *hw, u8 gpio)\n{\n\tu16 data;\n\n\tdata = readw(hw->io + KS884X_EEPROM_CTRL_OFFSET);\n\treturn (u8)(data & gpio);\n}\n\nstatic void eeprom_clk(struct ksz_hw *hw)\n{\n\traise_gpio(hw, EEPROM_SERIAL_CLOCK);\n\tudelay(EEPROM_DELAY);\n\tdrop_gpio(hw, EEPROM_SERIAL_CLOCK);\n\tudelay(EEPROM_DELAY);\n}\n\nstatic u16 spi_r(struct ksz_hw *hw)\n{\n\tint i;\n\tu16 temp = 0;\n\n\tfor (i = 15; i >= 0; i--) {\n\t\traise_gpio(hw, EEPROM_SERIAL_CLOCK);\n\t\tudelay(EEPROM_DELAY);\n\n\t\ttemp |= (state_gpio(hw, EEPROM_DATA_IN)) ? 1 << i : 0;\n\n\t\tdrop_gpio(hw, EEPROM_SERIAL_CLOCK);\n\t\tudelay(EEPROM_DELAY);\n\t}\n\treturn temp;\n}\n\nstatic void spi_w(struct ksz_hw *hw, u16 data)\n{\n\tint i;\n\n\tfor (i = 15; i >= 0; i--) {\n\t\t(data & (0x01 << i)) ? raise_gpio(hw, EEPROM_DATA_OUT) :\n\t\t\tdrop_gpio(hw, EEPROM_DATA_OUT);\n\t\teeprom_clk(hw);\n\t}\n}\n\nstatic void spi_reg(struct ksz_hw *hw, u8 data, u8 reg)\n{\n\tint i;\n\n\t \n\traise_gpio(hw, EEPROM_DATA_OUT);\n\teeprom_clk(hw);\n\n\t \n\tfor (i = 1; i >= 0; i--) {\n\t\t(data & (0x01 << i)) ? raise_gpio(hw, EEPROM_DATA_OUT) :\n\t\t\tdrop_gpio(hw, EEPROM_DATA_OUT);\n\t\teeprom_clk(hw);\n\t}\n\n\t \n\tfor (i = 5; i >= 0; i--) {\n\t\t(reg & (0x01 << i)) ? raise_gpio(hw, EEPROM_DATA_OUT) :\n\t\t\tdrop_gpio(hw, EEPROM_DATA_OUT);\n\t\teeprom_clk(hw);\n\t}\n}\n\n#define EEPROM_DATA_RESERVED\t\t0\n#define EEPROM_DATA_MAC_ADDR_0\t\t1\n#define EEPROM_DATA_MAC_ADDR_1\t\t2\n#define EEPROM_DATA_MAC_ADDR_2\t\t3\n#define EEPROM_DATA_SUBSYS_ID\t\t4\n#define EEPROM_DATA_SUBSYS_VEN_ID\t5\n#define EEPROM_DATA_PM_CAP\t\t6\n\n \n#define EEPROM_DATA_OTHER_MAC_ADDR\t9\n\n \nstatic u16 eeprom_read(struct ksz_hw *hw, u8 reg)\n{\n\tu16 data;\n\n\traise_gpio(hw, EEPROM_ACCESS_ENABLE | EEPROM_CHIP_SELECT);\n\n\tspi_reg(hw, AT93C_READ, reg);\n\tdata = spi_r(hw);\n\n\tdrop_gpio(hw, EEPROM_ACCESS_ENABLE | EEPROM_CHIP_SELECT);\n\n\treturn data;\n}\n\n \nstatic void eeprom_write(struct ksz_hw *hw, u8 reg, u16 data)\n{\n\tint timeout;\n\n\traise_gpio(hw, EEPROM_ACCESS_ENABLE | EEPROM_CHIP_SELECT);\n\n\t \n\tspi_reg(hw, AT93C_CODE, AT93C_WR_ON);\n\tdrop_gpio(hw, EEPROM_CHIP_SELECT);\n\tudelay(1);\n\n\t \n\traise_gpio(hw, EEPROM_CHIP_SELECT);\n\tspi_reg(hw, AT93C_ERASE, reg);\n\tdrop_gpio(hw, EEPROM_CHIP_SELECT);\n\tudelay(1);\n\n\t \n\traise_gpio(hw, EEPROM_CHIP_SELECT);\n\ttimeout = 8;\n\tmdelay(2);\n\tdo {\n\t\tmdelay(1);\n\t} while (!state_gpio(hw, EEPROM_DATA_IN) && --timeout);\n\tdrop_gpio(hw, EEPROM_CHIP_SELECT);\n\tudelay(1);\n\n\t \n\traise_gpio(hw, EEPROM_CHIP_SELECT);\n\tspi_reg(hw, AT93C_WRITE, reg);\n\tspi_w(hw, data);\n\tdrop_gpio(hw, EEPROM_CHIP_SELECT);\n\tudelay(1);\n\n\t \n\traise_gpio(hw, EEPROM_CHIP_SELECT);\n\ttimeout = 8;\n\tmdelay(2);\n\tdo {\n\t\tmdelay(1);\n\t} while (!state_gpio(hw, EEPROM_DATA_IN) && --timeout);\n\tdrop_gpio(hw, EEPROM_CHIP_SELECT);\n\tudelay(1);\n\n\t \n\traise_gpio(hw, EEPROM_CHIP_SELECT);\n\tspi_reg(hw, AT93C_CODE, AT93C_WR_OFF);\n\n\tdrop_gpio(hw, EEPROM_ACCESS_ENABLE | EEPROM_CHIP_SELECT);\n}\n\n \n\nstatic u16 advertised_flow_ctrl(struct ksz_port *port, u16 ctrl)\n{\n\tctrl &= ~PORT_AUTO_NEG_SYM_PAUSE;\n\tswitch (port->flow_ctrl) {\n\tcase PHY_FLOW_CTRL:\n\t\tctrl |= PORT_AUTO_NEG_SYM_PAUSE;\n\t\tbreak;\n\t \n\tcase PHY_TX_ONLY:\n\tcase PHY_RX_ONLY:\n\tdefault:\n\t\tbreak;\n\t}\n\treturn ctrl;\n}\n\nstatic void set_flow_ctrl(struct ksz_hw *hw, int rx, int tx)\n{\n\tu32 rx_cfg;\n\tu32 tx_cfg;\n\n\trx_cfg = hw->rx_cfg;\n\ttx_cfg = hw->tx_cfg;\n\tif (rx)\n\t\thw->rx_cfg |= DMA_RX_FLOW_ENABLE;\n\telse\n\t\thw->rx_cfg &= ~DMA_RX_FLOW_ENABLE;\n\tif (tx)\n\t\thw->tx_cfg |= DMA_TX_FLOW_ENABLE;\n\telse\n\t\thw->tx_cfg &= ~DMA_TX_FLOW_ENABLE;\n\tif (hw->enabled) {\n\t\tif (rx_cfg != hw->rx_cfg)\n\t\t\twritel(hw->rx_cfg, hw->io + KS_DMA_RX_CTRL);\n\t\tif (tx_cfg != hw->tx_cfg)\n\t\t\twritel(hw->tx_cfg, hw->io + KS_DMA_TX_CTRL);\n\t}\n}\n\nstatic void determine_flow_ctrl(struct ksz_hw *hw, struct ksz_port *port,\n\tu16 local, u16 remote)\n{\n\tint rx;\n\tint tx;\n\n\tif (hw->overrides & PAUSE_FLOW_CTRL)\n\t\treturn;\n\n\trx = tx = 0;\n\tif (port->force_link)\n\t\trx = tx = 1;\n\tif (remote & LPA_PAUSE_CAP) {\n\t\tif (local & ADVERTISE_PAUSE_CAP) {\n\t\t\trx = tx = 1;\n\t\t} else if ((remote & LPA_PAUSE_ASYM) &&\n\t\t\t   (local &\n\t\t\t    (ADVERTISE_PAUSE_CAP | ADVERTISE_PAUSE_ASYM)) ==\n\t\t\t   ADVERTISE_PAUSE_ASYM) {\n\t\t\ttx = 1;\n\t\t}\n\t} else if (remote & LPA_PAUSE_ASYM) {\n\t\tif ((local & (ADVERTISE_PAUSE_CAP | ADVERTISE_PAUSE_ASYM))\n\t\t    == (ADVERTISE_PAUSE_CAP | ADVERTISE_PAUSE_ASYM))\n\t\t\trx = 1;\n\t}\n\tif (!hw->ksz_switch)\n\t\tset_flow_ctrl(hw, rx, tx);\n}\n\nstatic inline void port_cfg_change(struct ksz_hw *hw, struct ksz_port *port,\n\tstruct ksz_port_info *info, u16 link_status)\n{\n\tif ((hw->features & HALF_DUPLEX_SIGNAL_BUG) &&\n\t\t\t!(hw->overrides & PAUSE_FLOW_CTRL)) {\n\t\tu32 cfg = hw->tx_cfg;\n\n\t\t \n\t\tif (1 == info->duplex)\n\t\t\thw->tx_cfg &= ~DMA_TX_FLOW_ENABLE;\n\t\tif (hw->enabled && cfg != hw->tx_cfg)\n\t\t\twritel(hw->tx_cfg, hw->io + KS_DMA_TX_CTRL);\n\t}\n}\n\n \nstatic void port_get_link_speed(struct ksz_port *port)\n{\n\tuint interrupt;\n\tstruct ksz_port_info *info;\n\tstruct ksz_port_info *linked = NULL;\n\tstruct ksz_hw *hw = port->hw;\n\tu16 data;\n\tu16 status;\n\tu8 local;\n\tu8 remote;\n\tint i;\n\tint p;\n\n\tinterrupt = hw_block_intr(hw);\n\n\tfor (i = 0, p = port->first_port; i < port->port_cnt; i++, p++) {\n\t\tinfo = &hw->port_info[p];\n\t\tport_r16(hw, p, KS884X_PORT_CTRL_4_OFFSET, &data);\n\t\tport_r16(hw, p, KS884X_PORT_STATUS_OFFSET, &status);\n\n\t\t \n\t\tremote = status & (PORT_AUTO_NEG_COMPLETE |\n\t\t\tPORT_STATUS_LINK_GOOD);\n\t\tlocal = (u8) data;\n\n\t\t \n\t\tif (local == info->advertised && remote == info->partner)\n\t\t\tcontinue;\n\n\t\tinfo->advertised = local;\n\t\tinfo->partner = remote;\n\t\tif (status & PORT_STATUS_LINK_GOOD) {\n\n\t\t\t \n\t\t\tif (!linked)\n\t\t\t\tlinked = info;\n\n\t\t\tinfo->tx_rate = 10 * TX_RATE_UNIT;\n\t\t\tif (status & PORT_STATUS_SPEED_100MBIT)\n\t\t\t\tinfo->tx_rate = 100 * TX_RATE_UNIT;\n\n\t\t\tinfo->duplex = 1;\n\t\t\tif (status & PORT_STATUS_FULL_DUPLEX)\n\t\t\t\tinfo->duplex = 2;\n\n\t\t\tif (media_connected != info->state) {\n\t\t\t\thw_r_phy(hw, p, KS884X_PHY_AUTO_NEG_OFFSET,\n\t\t\t\t\t&data);\n\t\t\t\thw_r_phy(hw, p, KS884X_PHY_REMOTE_CAP_OFFSET,\n\t\t\t\t\t&status);\n\t\t\t\tdetermine_flow_ctrl(hw, port, data, status);\n\t\t\t\tif (hw->ksz_switch) {\n\t\t\t\t\tport_cfg_back_pressure(hw, p,\n\t\t\t\t\t\t(1 == info->duplex));\n\t\t\t\t}\n\t\t\t\tport_cfg_change(hw, port, info, status);\n\t\t\t}\n\t\t\tinfo->state = media_connected;\n\t\t} else {\n\t\t\t \n\t\t\tif (media_disconnected != info->state)\n\t\t\t\thw->port_mib[p].link_down = 1;\n\n\t\t\tinfo->state = media_disconnected;\n\t\t}\n\t\thw->port_mib[p].state = (u8) info->state;\n\t}\n\n\tif (linked && media_disconnected == port->linked->state)\n\t\tport->linked = linked;\n\n\thw_restore_intr(hw, interrupt);\n}\n\n#define PHY_RESET_TIMEOUT\t\t10\n\n \nstatic void port_set_link_speed(struct ksz_port *port)\n{\n\tstruct ksz_hw *hw = port->hw;\n\tu16 data;\n\tu16 cfg;\n\tu8 status;\n\tint i;\n\tint p;\n\n\tfor (i = 0, p = port->first_port; i < port->port_cnt; i++, p++) {\n\t\tport_r16(hw, p, KS884X_PORT_CTRL_4_OFFSET, &data);\n\t\tport_r8(hw, p, KS884X_PORT_STATUS_OFFSET, &status);\n\n\t\tcfg = 0;\n\t\tif (status & PORT_STATUS_LINK_GOOD)\n\t\t\tcfg = data;\n\n\t\tdata |= PORT_AUTO_NEG_ENABLE;\n\t\tdata = advertised_flow_ctrl(port, data);\n\n\t\tdata |= PORT_AUTO_NEG_100BTX_FD | PORT_AUTO_NEG_100BTX |\n\t\t\tPORT_AUTO_NEG_10BT_FD | PORT_AUTO_NEG_10BT;\n\n\t\t \n\t\tif (port->speed || port->duplex) {\n\t\t\tif (10 == port->speed)\n\t\t\t\tdata &= ~(PORT_AUTO_NEG_100BTX_FD |\n\t\t\t\t\tPORT_AUTO_NEG_100BTX);\n\t\t\telse if (100 == port->speed)\n\t\t\t\tdata &= ~(PORT_AUTO_NEG_10BT_FD |\n\t\t\t\t\tPORT_AUTO_NEG_10BT);\n\t\t\tif (1 == port->duplex)\n\t\t\t\tdata &= ~(PORT_AUTO_NEG_100BTX_FD |\n\t\t\t\t\tPORT_AUTO_NEG_10BT_FD);\n\t\t\telse if (2 == port->duplex)\n\t\t\t\tdata &= ~(PORT_AUTO_NEG_100BTX |\n\t\t\t\t\tPORT_AUTO_NEG_10BT);\n\t\t}\n\t\tif (data != cfg) {\n\t\t\tdata |= PORT_AUTO_NEG_RESTART;\n\t\t\tport_w16(hw, p, KS884X_PORT_CTRL_4_OFFSET, data);\n\t\t}\n\t}\n}\n\n \nstatic void port_force_link_speed(struct ksz_port *port)\n{\n\tstruct ksz_hw *hw = port->hw;\n\tu16 data;\n\tint i;\n\tint phy;\n\tint p;\n\n\tfor (i = 0, p = port->first_port; i < port->port_cnt; i++, p++) {\n\t\tphy = KS884X_PHY_1_CTRL_OFFSET + p * PHY_CTRL_INTERVAL;\n\t\thw_r_phy_ctrl(hw, phy, &data);\n\n\t\tdata &= ~BMCR_ANENABLE;\n\n\t\tif (10 == port->speed)\n\t\t\tdata &= ~BMCR_SPEED100;\n\t\telse if (100 == port->speed)\n\t\t\tdata |= BMCR_SPEED100;\n\t\tif (1 == port->duplex)\n\t\t\tdata &= ~BMCR_FULLDPLX;\n\t\telse if (2 == port->duplex)\n\t\t\tdata |= BMCR_FULLDPLX;\n\t\thw_w_phy_ctrl(hw, phy, data);\n\t}\n}\n\nstatic void port_set_power_saving(struct ksz_port *port, int enable)\n{\n\tstruct ksz_hw *hw = port->hw;\n\tint i;\n\tint p;\n\n\tfor (i = 0, p = port->first_port; i < port->port_cnt; i++, p++)\n\t\tport_cfg(hw, p,\n\t\t\tKS884X_PORT_CTRL_4_OFFSET, PORT_POWER_DOWN, enable);\n}\n\n \n\n \nstatic int hw_chk_wol_pme_status(struct ksz_hw *hw)\n{\n\tstruct dev_info *hw_priv = container_of(hw, struct dev_info, hw);\n\tstruct pci_dev *pdev = hw_priv->pdev;\n\tu16 data;\n\n\tif (!pdev->pm_cap)\n\t\treturn 0;\n\tpci_read_config_word(pdev, pdev->pm_cap + PCI_PM_CTRL, &data);\n\treturn (data & PCI_PM_CTRL_PME_STATUS) == PCI_PM_CTRL_PME_STATUS;\n}\n\n \nstatic void hw_clr_wol_pme_status(struct ksz_hw *hw)\n{\n\tstruct dev_info *hw_priv = container_of(hw, struct dev_info, hw);\n\tstruct pci_dev *pdev = hw_priv->pdev;\n\tu16 data;\n\n\tif (!pdev->pm_cap)\n\t\treturn;\n\n\t \n\tpci_read_config_word(pdev, pdev->pm_cap + PCI_PM_CTRL, &data);\n\tdata |= PCI_PM_CTRL_PME_STATUS;\n\tpci_write_config_word(pdev, pdev->pm_cap + PCI_PM_CTRL, data);\n}\n\n \nstatic void hw_cfg_wol_pme(struct ksz_hw *hw, int set)\n{\n\tstruct dev_info *hw_priv = container_of(hw, struct dev_info, hw);\n\tstruct pci_dev *pdev = hw_priv->pdev;\n\tu16 data;\n\n\tif (!pdev->pm_cap)\n\t\treturn;\n\tpci_read_config_word(pdev, pdev->pm_cap + PCI_PM_CTRL, &data);\n\tdata &= ~PCI_PM_CTRL_STATE_MASK;\n\tif (set)\n\t\tdata |= PCI_PM_CTRL_PME_ENABLE | PCI_D3hot;\n\telse\n\t\tdata &= ~PCI_PM_CTRL_PME_ENABLE;\n\tpci_write_config_word(pdev, pdev->pm_cap + PCI_PM_CTRL, data);\n}\n\n \nstatic void hw_cfg_wol(struct ksz_hw *hw, u16 frame, int set)\n{\n\tu16 data;\n\n\tdata = readw(hw->io + KS8841_WOL_CTRL_OFFSET);\n\tif (set)\n\t\tdata |= frame;\n\telse\n\t\tdata &= ~frame;\n\twritew(data, hw->io + KS8841_WOL_CTRL_OFFSET);\n}\n\n \nstatic void hw_set_wol_frame(struct ksz_hw *hw, int i, uint mask_size,\n\tconst u8 *mask, uint frame_size, const u8 *pattern)\n{\n\tint bits;\n\tint from;\n\tint len;\n\tint to;\n\tu32 crc;\n\tu8 data[64];\n\tu8 val = 0;\n\n\tif (frame_size > mask_size * 8)\n\t\tframe_size = mask_size * 8;\n\tif (frame_size > 64)\n\t\tframe_size = 64;\n\n\ti *= 0x10;\n\twritel(0, hw->io + KS8841_WOL_FRAME_BYTE0_OFFSET + i);\n\twritel(0, hw->io + KS8841_WOL_FRAME_BYTE2_OFFSET + i);\n\n\tbits = len = from = to = 0;\n\tdo {\n\t\tif (bits) {\n\t\t\tif ((val & 1))\n\t\t\t\tdata[to++] = pattern[from];\n\t\t\tval >>= 1;\n\t\t\t++from;\n\t\t\t--bits;\n\t\t} else {\n\t\t\tval = mask[len];\n\t\t\twriteb(val, hw->io + KS8841_WOL_FRAME_BYTE0_OFFSET + i\n\t\t\t\t+ len);\n\t\t\t++len;\n\t\t\tif (val)\n\t\t\t\tbits = 8;\n\t\t\telse\n\t\t\t\tfrom += 8;\n\t\t}\n\t} while (from < (int) frame_size);\n\tif (val) {\n\t\tbits = mask[len - 1];\n\t\tval <<= (from % 8);\n\t\tbits &= ~val;\n\t\twriteb(bits, hw->io + KS8841_WOL_FRAME_BYTE0_OFFSET + i + len -\n\t\t\t1);\n\t}\n\tcrc = ether_crc(to, data);\n\twritel(crc, hw->io + KS8841_WOL_FRAME_CRC_OFFSET + i);\n}\n\n \nstatic void hw_add_wol_arp(struct ksz_hw *hw, const u8 *ip_addr)\n{\n\tstatic const u8 mask[6] = { 0x3F, 0xF0, 0x3F, 0x00, 0xC0, 0x03 };\n\tu8 pattern[42] = {\n\t\t0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t0x08, 0x06,\n\t\t0x00, 0x01, 0x08, 0x00, 0x06, 0x04, 0x00, 0x01,\n\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t0x00, 0x00, 0x00, 0x00,\n\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t0x00, 0x00, 0x00, 0x00 };\n\n\tmemcpy(&pattern[38], ip_addr, 4);\n\thw_set_wol_frame(hw, 3, 6, mask, 42, pattern);\n}\n\n \nstatic void hw_add_wol_bcast(struct ksz_hw *hw)\n{\n\tstatic const u8 mask[] = { 0x3F };\n\tstatic const u8 pattern[] = { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF };\n\n\thw_set_wol_frame(hw, 2, 1, mask, ETH_ALEN, pattern);\n}\n\n \nstatic void hw_add_wol_mcast(struct ksz_hw *hw)\n{\n\tstatic const u8 mask[] = { 0x3F };\n\tu8 pattern[] = { 0x33, 0x33, 0xFF, 0x00, 0x00, 0x00 };\n\n\tmemcpy(&pattern[3], &hw->override_addr[3], 3);\n\thw_set_wol_frame(hw, 1, 1, mask, 6, pattern);\n}\n\n \nstatic void hw_add_wol_ucast(struct ksz_hw *hw)\n{\n\tstatic const u8 mask[] = { 0x3F };\n\n\thw_set_wol_frame(hw, 0, 1, mask, ETH_ALEN, hw->override_addr);\n}\n\n \nstatic void hw_enable_wol(struct ksz_hw *hw, u32 wol_enable, const u8 *net_addr)\n{\n\thw_cfg_wol(hw, KS8841_WOL_MAGIC_ENABLE, (wol_enable & WAKE_MAGIC));\n\thw_cfg_wol(hw, KS8841_WOL_FRAME0_ENABLE, (wol_enable & WAKE_UCAST));\n\thw_add_wol_ucast(hw);\n\thw_cfg_wol(hw, KS8841_WOL_FRAME1_ENABLE, (wol_enable & WAKE_MCAST));\n\thw_add_wol_mcast(hw);\n\thw_cfg_wol(hw, KS8841_WOL_FRAME2_ENABLE, (wol_enable & WAKE_BCAST));\n\thw_cfg_wol(hw, KS8841_WOL_FRAME3_ENABLE, (wol_enable & WAKE_ARP));\n\thw_add_wol_arp(hw, net_addr);\n}\n\n \nstatic int hw_init(struct ksz_hw *hw)\n{\n\tint rc = 0;\n\tu16 data;\n\tu16 revision;\n\n\t \n\twritew(BUS_SPEED_125_MHZ, hw->io + KS884X_BUS_CTRL_OFFSET);\n\n\t \n\tdata = readw(hw->io + KS884X_CHIP_ID_OFFSET);\n\n\trevision = (data & KS884X_REVISION_MASK) >> KS884X_REVISION_SHIFT;\n\tdata &= KS884X_CHIP_ID_MASK_41;\n\tif (REG_CHIP_ID_41 == data)\n\t\trc = 1;\n\telse if (REG_CHIP_ID_42 == data)\n\t\trc = 2;\n\telse\n\t\treturn 0;\n\n\t \n\tif (revision <= 1) {\n\t\thw->features |= SMALL_PACKET_TX_BUG;\n\t\tif (1 == rc)\n\t\t\thw->features |= HALF_DUPLEX_SIGNAL_BUG;\n\t}\n\treturn rc;\n}\n\n \nstatic void hw_reset(struct ksz_hw *hw)\n{\n\twritew(GLOBAL_SOFTWARE_RESET, hw->io + KS884X_GLOBAL_CTRL_OFFSET);\n\n\t \n\tmdelay(10);\n\n\t \n\twritew(0, hw->io + KS884X_GLOBAL_CTRL_OFFSET);\n}\n\n \nstatic void hw_setup(struct ksz_hw *hw)\n{\n#if SET_DEFAULT_LED\n\tu16 data;\n\n\t \n\tdata = readw(hw->io + KS8842_SWITCH_CTRL_5_OFFSET);\n\tdata &= ~LED_MODE;\n\tdata |= SET_DEFAULT_LED;\n\twritew(data, hw->io + KS8842_SWITCH_CTRL_5_OFFSET);\n#endif\n\n\t \n\thw->tx_cfg = (DMA_TX_PAD_ENABLE | DMA_TX_CRC_ENABLE |\n\t\t(DMA_BURST_DEFAULT << DMA_BURST_SHIFT) | DMA_TX_ENABLE);\n\n\t \n\thw->rx_cfg = (DMA_RX_BROADCAST | DMA_RX_UNICAST |\n\t\t(DMA_BURST_DEFAULT << DMA_BURST_SHIFT) | DMA_RX_ENABLE);\n\thw->rx_cfg |= KS884X_DMA_RX_MULTICAST;\n\n\t \n\thw->rx_cfg |= (DMA_RX_CSUM_TCP | DMA_RX_CSUM_IP);\n\n\tif (hw->all_multi)\n\t\thw->rx_cfg |= DMA_RX_ALL_MULTICAST;\n\tif (hw->promiscuous)\n\t\thw->rx_cfg |= DMA_RX_PROMISCUOUS;\n}\n\n \nstatic void hw_setup_intr(struct ksz_hw *hw)\n{\n\thw->intr_mask = KS884X_INT_MASK | KS884X_INT_RX_OVERRUN;\n}\n\nstatic void ksz_check_desc_num(struct ksz_desc_info *info)\n{\n#define MIN_DESC_SHIFT  2\n\n\tint alloc = info->alloc;\n\tint shift;\n\n\tshift = 0;\n\twhile (!(alloc & 1)) {\n\t\tshift++;\n\t\talloc >>= 1;\n\t}\n\tif (alloc != 1 || shift < MIN_DESC_SHIFT) {\n\t\tpr_alert(\"Hardware descriptor numbers not right!\\n\");\n\t\twhile (alloc) {\n\t\t\tshift++;\n\t\t\talloc >>= 1;\n\t\t}\n\t\tif (shift < MIN_DESC_SHIFT)\n\t\t\tshift = MIN_DESC_SHIFT;\n\t\talloc = 1 << shift;\n\t\tinfo->alloc = alloc;\n\t}\n\tinfo->mask = info->alloc - 1;\n}\n\nstatic void hw_init_desc(struct ksz_desc_info *desc_info, int transmit)\n{\n\tint i;\n\tu32 phys = desc_info->ring_phys;\n\tstruct ksz_hw_desc *desc = desc_info->ring_virt;\n\tstruct ksz_desc *cur = desc_info->ring;\n\tstruct ksz_desc *previous = NULL;\n\n\tfor (i = 0; i < desc_info->alloc; i++) {\n\t\tcur->phw = desc++;\n\t\tphys += desc_info->size;\n\t\tprevious = cur++;\n\t\tprevious->phw->next = cpu_to_le32(phys);\n\t}\n\tprevious->phw->next = cpu_to_le32(desc_info->ring_phys);\n\tprevious->sw.buf.rx.end_of_ring = 1;\n\tprevious->phw->buf.data = cpu_to_le32(previous->sw.buf.data);\n\n\tdesc_info->avail = desc_info->alloc;\n\tdesc_info->last = desc_info->next = 0;\n\n\tdesc_info->cur = desc_info->ring;\n}\n\n \nstatic void hw_set_desc_base(struct ksz_hw *hw, u32 tx_addr, u32 rx_addr)\n{\n\t \n\twritel(tx_addr, hw->io + KS_DMA_TX_ADDR);\n\twritel(rx_addr, hw->io + KS_DMA_RX_ADDR);\n}\n\nstatic void hw_reset_pkts(struct ksz_desc_info *info)\n{\n\tinfo->cur = info->ring;\n\tinfo->avail = info->alloc;\n\tinfo->last = info->next = 0;\n}\n\nstatic inline void hw_resume_rx(struct ksz_hw *hw)\n{\n\twritel(DMA_START, hw->io + KS_DMA_RX_START);\n}\n\n \nstatic void hw_start_rx(struct ksz_hw *hw)\n{\n\twritel(hw->rx_cfg, hw->io + KS_DMA_RX_CTRL);\n\n\t \n\thw->intr_mask |= KS884X_INT_RX_STOPPED;\n\n\twritel(DMA_START, hw->io + KS_DMA_RX_START);\n\thw_ack_intr(hw, KS884X_INT_RX_STOPPED);\n\thw->rx_stop++;\n\n\t \n\tif (0 == hw->rx_stop)\n\t\thw->rx_stop = 2;\n}\n\n \nstatic void hw_stop_rx(struct ksz_hw *hw)\n{\n\thw->rx_stop = 0;\n\thw_turn_off_intr(hw, KS884X_INT_RX_STOPPED);\n\twritel((hw->rx_cfg & ~DMA_RX_ENABLE), hw->io + KS_DMA_RX_CTRL);\n}\n\n \nstatic void hw_start_tx(struct ksz_hw *hw)\n{\n\twritel(hw->tx_cfg, hw->io + KS_DMA_TX_CTRL);\n}\n\n \nstatic void hw_stop_tx(struct ksz_hw *hw)\n{\n\twritel((hw->tx_cfg & ~DMA_TX_ENABLE), hw->io + KS_DMA_TX_CTRL);\n}\n\n \nstatic void hw_disable(struct ksz_hw *hw)\n{\n\thw_stop_rx(hw);\n\thw_stop_tx(hw);\n\thw->enabled = 0;\n}\n\n \nstatic void hw_enable(struct ksz_hw *hw)\n{\n\thw_start_tx(hw);\n\thw_start_rx(hw);\n\thw->enabled = 1;\n}\n\n \nstatic int hw_alloc_pkt(struct ksz_hw *hw, int length, int physical)\n{\n\t \n\tif (hw->tx_desc_info.avail <= 1)\n\t\treturn 0;\n\n\t \n\tget_tx_pkt(&hw->tx_desc_info, &hw->tx_desc_info.cur);\n\thw->tx_desc_info.cur->sw.buf.tx.first_seg = 1;\n\n\t \n\t++hw->tx_int_cnt;\n\thw->tx_size += length;\n\n\t \n\tif (hw->tx_size >= MAX_TX_HELD_SIZE)\n\t\thw->tx_int_cnt = hw->tx_int_mask + 1;\n\n\tif (physical > hw->tx_desc_info.avail)\n\t\treturn 1;\n\n\treturn hw->tx_desc_info.avail;\n}\n\n \nstatic void hw_send_pkt(struct ksz_hw *hw)\n{\n\tstruct ksz_desc *cur = hw->tx_desc_info.cur;\n\n\tcur->sw.buf.tx.last_seg = 1;\n\n\t \n\tif (hw->tx_int_cnt > hw->tx_int_mask) {\n\t\tcur->sw.buf.tx.intr = 1;\n\t\thw->tx_int_cnt = 0;\n\t\thw->tx_size = 0;\n\t}\n\n\t \n\tcur->sw.buf.tx.dest_port = hw->dst_ports;\n\n\trelease_desc(cur);\n\n\twritel(0, hw->io + KS_DMA_TX_START);\n}\n\nstatic int empty_addr(u8 *addr)\n{\n\tu32 *addr1 = (u32 *) addr;\n\tu16 *addr2 = (u16 *) &addr[4];\n\n\treturn 0 == *addr1 && 0 == *addr2;\n}\n\n \nstatic void hw_set_addr(struct ksz_hw *hw)\n{\n\tint i;\n\n\tfor (i = 0; i < ETH_ALEN; i++)\n\t\twriteb(hw->override_addr[MAC_ADDR_ORDER(i)],\n\t\t\thw->io + KS884X_ADDR_0_OFFSET + i);\n\n\tsw_set_addr(hw, hw->override_addr);\n}\n\n \nstatic void hw_read_addr(struct ksz_hw *hw)\n{\n\tint i;\n\n\tfor (i = 0; i < ETH_ALEN; i++)\n\t\thw->perm_addr[MAC_ADDR_ORDER(i)] = readb(hw->io +\n\t\t\tKS884X_ADDR_0_OFFSET + i);\n\n\tif (!hw->mac_override) {\n\t\tmemcpy(hw->override_addr, hw->perm_addr, ETH_ALEN);\n\t\tif (empty_addr(hw->override_addr)) {\n\t\t\tmemcpy(hw->perm_addr, DEFAULT_MAC_ADDRESS, ETH_ALEN);\n\t\t\tmemcpy(hw->override_addr, DEFAULT_MAC_ADDRESS,\n\t\t\t       ETH_ALEN);\n\t\t\thw->override_addr[5] += hw->id;\n\t\t\thw_set_addr(hw);\n\t\t}\n\t}\n}\n\nstatic void hw_ena_add_addr(struct ksz_hw *hw, int index, u8 *mac_addr)\n{\n\tint i;\n\tu32 mac_addr_lo;\n\tu32 mac_addr_hi;\n\n\tmac_addr_hi = 0;\n\tfor (i = 0; i < 2; i++) {\n\t\tmac_addr_hi <<= 8;\n\t\tmac_addr_hi |= mac_addr[i];\n\t}\n\tmac_addr_hi |= ADD_ADDR_ENABLE;\n\tmac_addr_lo = 0;\n\tfor (i = 2; i < 6; i++) {\n\t\tmac_addr_lo <<= 8;\n\t\tmac_addr_lo |= mac_addr[i];\n\t}\n\tindex *= ADD_ADDR_INCR;\n\n\twritel(mac_addr_lo, hw->io + index + KS_ADD_ADDR_0_LO);\n\twritel(mac_addr_hi, hw->io + index + KS_ADD_ADDR_0_HI);\n}\n\nstatic void hw_set_add_addr(struct ksz_hw *hw)\n{\n\tint i;\n\n\tfor (i = 0; i < ADDITIONAL_ENTRIES; i++) {\n\t\tif (empty_addr(hw->address[i]))\n\t\t\twritel(0, hw->io + ADD_ADDR_INCR * i +\n\t\t\t\tKS_ADD_ADDR_0_HI);\n\t\telse\n\t\t\thw_ena_add_addr(hw, i, hw->address[i]);\n\t}\n}\n\nstatic int hw_add_addr(struct ksz_hw *hw, const u8 *mac_addr)\n{\n\tint i;\n\tint j = ADDITIONAL_ENTRIES;\n\n\tif (ether_addr_equal(hw->override_addr, mac_addr))\n\t\treturn 0;\n\tfor (i = 0; i < hw->addr_list_size; i++) {\n\t\tif (ether_addr_equal(hw->address[i], mac_addr))\n\t\t\treturn 0;\n\t\tif (ADDITIONAL_ENTRIES == j && empty_addr(hw->address[i]))\n\t\t\tj = i;\n\t}\n\tif (j < ADDITIONAL_ENTRIES) {\n\t\tmemcpy(hw->address[j], mac_addr, ETH_ALEN);\n\t\thw_ena_add_addr(hw, j, hw->address[j]);\n\t\treturn 0;\n\t}\n\treturn -1;\n}\n\nstatic int hw_del_addr(struct ksz_hw *hw, const u8 *mac_addr)\n{\n\tint i;\n\n\tfor (i = 0; i < hw->addr_list_size; i++) {\n\t\tif (ether_addr_equal(hw->address[i], mac_addr)) {\n\t\t\teth_zero_addr(hw->address[i]);\n\t\t\twritel(0, hw->io + ADD_ADDR_INCR * i +\n\t\t\t\tKS_ADD_ADDR_0_HI);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -1;\n}\n\n \nstatic void hw_clr_multicast(struct ksz_hw *hw)\n{\n\tint i;\n\n\tfor (i = 0; i < HW_MULTICAST_SIZE; i++) {\n\t\thw->multi_bits[i] = 0;\n\n\t\twriteb(0, hw->io + KS884X_MULTICAST_0_OFFSET + i);\n\t}\n}\n\n \nstatic void hw_set_grp_addr(struct ksz_hw *hw)\n{\n\tint i;\n\tint index;\n\tint position;\n\tint value;\n\n\tmemset(hw->multi_bits, 0, sizeof(u8) * HW_MULTICAST_SIZE);\n\n\tfor (i = 0; i < hw->multi_list_size; i++) {\n\t\tposition = (ether_crc(6, hw->multi_list[i]) >> 26) & 0x3f;\n\t\tindex = position >> 3;\n\t\tvalue = 1 << (position & 7);\n\t\thw->multi_bits[index] |= (u8) value;\n\t}\n\n\tfor (i = 0; i < HW_MULTICAST_SIZE; i++)\n\t\twriteb(hw->multi_bits[i], hw->io + KS884X_MULTICAST_0_OFFSET +\n\t\t\ti);\n}\n\n \nstatic void hw_set_multicast(struct ksz_hw *hw, u8 multicast)\n{\n\t \n\thw_stop_rx(hw);\n\n\tif (multicast)\n\t\thw->rx_cfg |= DMA_RX_ALL_MULTICAST;\n\telse\n\t\thw->rx_cfg &= ~DMA_RX_ALL_MULTICAST;\n\n\tif (hw->enabled)\n\t\thw_start_rx(hw);\n}\n\n \nstatic void hw_set_promiscuous(struct ksz_hw *hw, u8 prom)\n{\n\t \n\thw_stop_rx(hw);\n\n\tif (prom)\n\t\thw->rx_cfg |= DMA_RX_PROMISCUOUS;\n\telse\n\t\thw->rx_cfg &= ~DMA_RX_PROMISCUOUS;\n\n\tif (hw->enabled)\n\t\thw_start_rx(hw);\n}\n\n \nstatic void sw_enable(struct ksz_hw *hw, int enable)\n{\n\tint port;\n\n\tfor (port = 0; port < SWITCH_PORT_NUM; port++) {\n\t\tif (hw->dev_count > 1) {\n\t\t\t \n\t\t\tsw_cfg_port_base_vlan(hw, port,\n\t\t\t\tHOST_MASK | (1 << port));\n\t\t\tport_set_stp_state(hw, port, STP_STATE_DISABLED);\n\t\t} else {\n\t\t\tsw_cfg_port_base_vlan(hw, port, PORT_MASK);\n\t\t\tport_set_stp_state(hw, port, STP_STATE_FORWARDING);\n\t\t}\n\t}\n\tif (hw->dev_count > 1)\n\t\tport_set_stp_state(hw, SWITCH_PORT_NUM, STP_STATE_SIMPLE);\n\telse\n\t\tport_set_stp_state(hw, SWITCH_PORT_NUM, STP_STATE_FORWARDING);\n\n\tif (enable)\n\t\tenable = KS8842_START;\n\twritew(enable, hw->io + KS884X_CHIP_ID_OFFSET);\n}\n\n \nstatic void sw_setup(struct ksz_hw *hw)\n{\n\tint port;\n\n\tsw_set_global_ctrl(hw);\n\n\t \n\tsw_init_broad_storm(hw);\n\thw_cfg_broad_storm(hw, BROADCAST_STORM_PROTECTION_RATE);\n\tfor (port = 0; port < SWITCH_PORT_NUM; port++)\n\t\tsw_ena_broad_storm(hw, port);\n\n\tsw_init_prio(hw);\n\n\tsw_init_mirror(hw);\n\n\tsw_init_prio_rate(hw);\n\n\tsw_init_vlan(hw);\n\n\tif (hw->features & STP_SUPPORT)\n\t\tsw_init_stp(hw);\n\tif (!sw_chk(hw, KS8842_SWITCH_CTRL_1_OFFSET,\n\t\t\tSWITCH_TX_FLOW_CTRL | SWITCH_RX_FLOW_CTRL))\n\t\thw->overrides |= PAUSE_FLOW_CTRL;\n\tsw_enable(hw, 1);\n}\n\n \nstatic void ksz_start_timer(struct ksz_timer_info *info, int time)\n{\n\tinfo->cnt = 0;\n\tinfo->timer.expires = jiffies + time;\n\tadd_timer(&info->timer);\n\n\t \n\tinfo->max = -1;\n}\n\n \nstatic void ksz_stop_timer(struct ksz_timer_info *info)\n{\n\tif (info->max) {\n\t\tinfo->max = 0;\n\t\tdel_timer_sync(&info->timer);\n\t}\n}\n\nstatic void ksz_init_timer(struct ksz_timer_info *info, int period,\n\tvoid (*function)(struct timer_list *))\n{\n\tinfo->max = 0;\n\tinfo->period = period;\n\ttimer_setup(&info->timer, function, 0);\n}\n\nstatic void ksz_update_timer(struct ksz_timer_info *info)\n{\n\t++info->cnt;\n\tif (info->max > 0) {\n\t\tif (info->cnt < info->max) {\n\t\t\tinfo->timer.expires = jiffies + info->period;\n\t\t\tadd_timer(&info->timer);\n\t\t} else\n\t\t\tinfo->max = 0;\n\t} else if (info->max < 0) {\n\t\tinfo->timer.expires = jiffies + info->period;\n\t\tadd_timer(&info->timer);\n\t}\n}\n\n \nstatic int ksz_alloc_soft_desc(struct ksz_desc_info *desc_info, int transmit)\n{\n\tdesc_info->ring = kcalloc(desc_info->alloc, sizeof(struct ksz_desc),\n\t\t\t\t  GFP_KERNEL);\n\tif (!desc_info->ring)\n\t\treturn 1;\n\thw_init_desc(desc_info, transmit);\n\treturn 0;\n}\n\n \nstatic int ksz_alloc_desc(struct dev_info *adapter)\n{\n\tstruct ksz_hw *hw = &adapter->hw;\n\tint offset;\n\n\t \n\tadapter->desc_pool.alloc_size =\n\t\thw->rx_desc_info.size * hw->rx_desc_info.alloc +\n\t\thw->tx_desc_info.size * hw->tx_desc_info.alloc +\n\t\tDESC_ALIGNMENT;\n\n\tadapter->desc_pool.alloc_virt =\n\t\tdma_alloc_coherent(&adapter->pdev->dev,\n\t\t\t\t   adapter->desc_pool.alloc_size,\n\t\t\t\t   &adapter->desc_pool.dma_addr, GFP_KERNEL);\n\tif (adapter->desc_pool.alloc_virt == NULL) {\n\t\tadapter->desc_pool.alloc_size = 0;\n\t\treturn 1;\n\t}\n\n\t \n\toffset = (((ulong) adapter->desc_pool.alloc_virt % DESC_ALIGNMENT) ?\n\t\t(DESC_ALIGNMENT -\n\t\t((ulong) adapter->desc_pool.alloc_virt % DESC_ALIGNMENT)) : 0);\n\tadapter->desc_pool.virt = adapter->desc_pool.alloc_virt + offset;\n\tadapter->desc_pool.phys = adapter->desc_pool.dma_addr + offset;\n\n\t \n\thw->rx_desc_info.ring_virt = (struct ksz_hw_desc *)\n\t\tadapter->desc_pool.virt;\n\thw->rx_desc_info.ring_phys = adapter->desc_pool.phys;\n\toffset = hw->rx_desc_info.alloc * hw->rx_desc_info.size;\n\thw->tx_desc_info.ring_virt = (struct ksz_hw_desc *)\n\t\t(adapter->desc_pool.virt + offset);\n\thw->tx_desc_info.ring_phys = adapter->desc_pool.phys + offset;\n\n\tif (ksz_alloc_soft_desc(&hw->rx_desc_info, 0))\n\t\treturn 1;\n\tif (ksz_alloc_soft_desc(&hw->tx_desc_info, 1))\n\t\treturn 1;\n\n\treturn 0;\n}\n\n \nstatic void free_dma_buf(struct dev_info *adapter, struct ksz_dma_buf *dma_buf,\n\tint direction)\n{\n\tdma_unmap_single(&adapter->pdev->dev, dma_buf->dma, dma_buf->len,\n\t\t\t direction);\n\tdev_kfree_skb(dma_buf->skb);\n\tdma_buf->skb = NULL;\n\tdma_buf->dma = 0;\n}\n\n \nstatic void ksz_init_rx_buffers(struct dev_info *adapter)\n{\n\tint i;\n\tstruct ksz_desc *desc;\n\tstruct ksz_dma_buf *dma_buf;\n\tstruct ksz_hw *hw = &adapter->hw;\n\tstruct ksz_desc_info *info = &hw->rx_desc_info;\n\n\tfor (i = 0; i < hw->rx_desc_info.alloc; i++) {\n\t\tget_rx_pkt(info, &desc);\n\n\t\tdma_buf = DMA_BUFFER(desc);\n\t\tif (dma_buf->skb && dma_buf->len != adapter->mtu)\n\t\t\tfree_dma_buf(adapter, dma_buf, DMA_FROM_DEVICE);\n\t\tdma_buf->len = adapter->mtu;\n\t\tif (!dma_buf->skb)\n\t\t\tdma_buf->skb = alloc_skb(dma_buf->len, GFP_ATOMIC);\n\t\tif (dma_buf->skb && !dma_buf->dma)\n\t\t\tdma_buf->dma = dma_map_single(&adapter->pdev->dev,\n\t\t\t\t\t\tskb_tail_pointer(dma_buf->skb),\n\t\t\t\t\t\tdma_buf->len,\n\t\t\t\t\t\tDMA_FROM_DEVICE);\n\n\t\t \n\t\tset_rx_buf(desc, dma_buf->dma);\n\t\tset_rx_len(desc, dma_buf->len);\n\t\trelease_desc(desc);\n\t}\n}\n\n \nstatic int ksz_alloc_mem(struct dev_info *adapter)\n{\n\tstruct ksz_hw *hw = &adapter->hw;\n\n\t \n\thw->rx_desc_info.alloc = NUM_OF_RX_DESC;\n\thw->tx_desc_info.alloc = NUM_OF_TX_DESC;\n\n\t \n\thw->tx_int_cnt = 0;\n\thw->tx_int_mask = NUM_OF_TX_DESC / 4;\n\tif (hw->tx_int_mask > 8)\n\t\thw->tx_int_mask = 8;\n\twhile (hw->tx_int_mask) {\n\t\thw->tx_int_cnt++;\n\t\thw->tx_int_mask >>= 1;\n\t}\n\tif (hw->tx_int_cnt) {\n\t\thw->tx_int_mask = (1 << (hw->tx_int_cnt - 1)) - 1;\n\t\thw->tx_int_cnt = 0;\n\t}\n\n\t \n\thw->rx_desc_info.size =\n\t\t(((sizeof(struct ksz_hw_desc) + DESC_ALIGNMENT - 1) /\n\t\tDESC_ALIGNMENT) * DESC_ALIGNMENT);\n\thw->tx_desc_info.size =\n\t\t(((sizeof(struct ksz_hw_desc) + DESC_ALIGNMENT - 1) /\n\t\tDESC_ALIGNMENT) * DESC_ALIGNMENT);\n\tif (hw->rx_desc_info.size != sizeof(struct ksz_hw_desc))\n\t\tpr_alert(\"Hardware descriptor size not right!\\n\");\n\tksz_check_desc_num(&hw->rx_desc_info);\n\tksz_check_desc_num(&hw->tx_desc_info);\n\n\t \n\tif (ksz_alloc_desc(adapter))\n\t\treturn 1;\n\n\treturn 0;\n}\n\n \nstatic void ksz_free_desc(struct dev_info *adapter)\n{\n\tstruct ksz_hw *hw = &adapter->hw;\n\n\t \n\thw->rx_desc_info.ring_virt = NULL;\n\thw->tx_desc_info.ring_virt = NULL;\n\thw->rx_desc_info.ring_phys = 0;\n\thw->tx_desc_info.ring_phys = 0;\n\n\t \n\tif (adapter->desc_pool.alloc_virt)\n\t\tdma_free_coherent(&adapter->pdev->dev,\n\t\t\t\t  adapter->desc_pool.alloc_size,\n\t\t\t\t  adapter->desc_pool.alloc_virt,\n\t\t\t\t  adapter->desc_pool.dma_addr);\n\n\t \n\tadapter->desc_pool.alloc_size = 0;\n\tadapter->desc_pool.alloc_virt = NULL;\n\n\tkfree(hw->rx_desc_info.ring);\n\thw->rx_desc_info.ring = NULL;\n\tkfree(hw->tx_desc_info.ring);\n\thw->tx_desc_info.ring = NULL;\n}\n\n \nstatic void ksz_free_buffers(struct dev_info *adapter,\n\tstruct ksz_desc_info *desc_info, int direction)\n{\n\tint i;\n\tstruct ksz_dma_buf *dma_buf;\n\tstruct ksz_desc *desc = desc_info->ring;\n\n\tfor (i = 0; i < desc_info->alloc; i++) {\n\t\tdma_buf = DMA_BUFFER(desc);\n\t\tif (dma_buf->skb)\n\t\t\tfree_dma_buf(adapter, dma_buf, direction);\n\t\tdesc++;\n\t}\n}\n\n \nstatic void ksz_free_mem(struct dev_info *adapter)\n{\n\t \n\tksz_free_buffers(adapter, &adapter->hw.tx_desc_info, DMA_TO_DEVICE);\n\n\t \n\tksz_free_buffers(adapter, &adapter->hw.rx_desc_info, DMA_FROM_DEVICE);\n\n\t \n\tksz_free_desc(adapter);\n}\n\nstatic void get_mib_counters(struct ksz_hw *hw, int first, int cnt,\n\tu64 *counter)\n{\n\tint i;\n\tint mib;\n\tint port;\n\tstruct ksz_port_mib *port_mib;\n\n\tmemset(counter, 0, sizeof(u64) * TOTAL_PORT_COUNTER_NUM);\n\tfor (i = 0, port = first; i < cnt; i++, port++) {\n\t\tport_mib = &hw->port_mib[port];\n\t\tfor (mib = port_mib->mib_start; mib < hw->mib_cnt; mib++)\n\t\t\tcounter[mib] += port_mib->counter[mib];\n\t}\n}\n\n \nstatic void send_packet(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct ksz_desc *desc;\n\tstruct ksz_desc *first;\n\tstruct dev_priv *priv = netdev_priv(dev);\n\tstruct dev_info *hw_priv = priv->adapter;\n\tstruct ksz_hw *hw = &hw_priv->hw;\n\tstruct ksz_desc_info *info = &hw->tx_desc_info;\n\tstruct ksz_dma_buf *dma_buf;\n\tint len;\n\tint last_frag = skb_shinfo(skb)->nr_frags;\n\n\t \n\tif (hw->dev_count > 1)\n\t\thw->dst_ports = 1 << priv->port.first_port;\n\n\t \n\tlen = skb->len;\n\n\t \n\tfirst = info->cur;\n\tdesc = first;\n\n\tdma_buf = DMA_BUFFER(desc);\n\tif (last_frag) {\n\t\tint frag;\n\t\tskb_frag_t *this_frag;\n\n\t\tdma_buf->len = skb_headlen(skb);\n\n\t\tdma_buf->dma = dma_map_single(&hw_priv->pdev->dev, skb->data,\n\t\t\t\t\t      dma_buf->len, DMA_TO_DEVICE);\n\t\tset_tx_buf(desc, dma_buf->dma);\n\t\tset_tx_len(desc, dma_buf->len);\n\n\t\tfrag = 0;\n\t\tdo {\n\t\t\tthis_frag = &skb_shinfo(skb)->frags[frag];\n\n\t\t\t \n\t\t\tget_tx_pkt(info, &desc);\n\n\t\t\t \n\t\t\t++hw->tx_int_cnt;\n\n\t\t\tdma_buf = DMA_BUFFER(desc);\n\t\t\tdma_buf->len = skb_frag_size(this_frag);\n\n\t\t\tdma_buf->dma = dma_map_single(&hw_priv->pdev->dev,\n\t\t\t\t\t\t      skb_frag_address(this_frag),\n\t\t\t\t\t\t      dma_buf->len,\n\t\t\t\t\t\t      DMA_TO_DEVICE);\n\t\t\tset_tx_buf(desc, dma_buf->dma);\n\t\t\tset_tx_len(desc, dma_buf->len);\n\n\t\t\tfrag++;\n\t\t\tif (frag == last_frag)\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\trelease_desc(desc);\n\t\t} while (1);\n\n\t\t \n\t\tinfo->cur = desc;\n\n\t\t \n\t\trelease_desc(first);\n\t} else {\n\t\tdma_buf->len = len;\n\n\t\tdma_buf->dma = dma_map_single(&hw_priv->pdev->dev, skb->data,\n\t\t\t\t\t      dma_buf->len, DMA_TO_DEVICE);\n\t\tset_tx_buf(desc, dma_buf->dma);\n\t\tset_tx_len(desc, dma_buf->len);\n\t}\n\n\tif (skb->ip_summed == CHECKSUM_PARTIAL) {\n\t\t(desc)->sw.buf.tx.csum_gen_tcp = 1;\n\t\t(desc)->sw.buf.tx.csum_gen_udp = 1;\n\t}\n\n\t \n\tdma_buf->skb = skb;\n\n\thw_send_pkt(hw);\n\n\t \n\tdev->stats.tx_packets++;\n\tdev->stats.tx_bytes += len;\n}\n\n \nstatic void transmit_cleanup(struct dev_info *hw_priv, int normal)\n{\n\tint last;\n\tunion desc_stat status;\n\tstruct ksz_hw *hw = &hw_priv->hw;\n\tstruct ksz_desc_info *info = &hw->tx_desc_info;\n\tstruct ksz_desc *desc;\n\tstruct ksz_dma_buf *dma_buf;\n\tstruct net_device *dev = NULL;\n\n\tspin_lock_irq(&hw_priv->hwlock);\n\tlast = info->last;\n\n\twhile (info->avail < info->alloc) {\n\t\t \n\t\tdesc = &info->ring[last];\n\t\tstatus.data = le32_to_cpu(desc->phw->ctrl.data);\n\t\tif (status.tx.hw_owned) {\n\t\t\tif (normal)\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\treset_desc(desc, status);\n\t\t}\n\n\t\tdma_buf = DMA_BUFFER(desc);\n\t\tdma_unmap_single(&hw_priv->pdev->dev, dma_buf->dma,\n\t\t\t\t dma_buf->len, DMA_TO_DEVICE);\n\n\t\t \n\t\tif (dma_buf->skb) {\n\t\t\tdev = dma_buf->skb->dev;\n\n\t\t\t \n\t\t\tdev_kfree_skb_irq(dma_buf->skb);\n\t\t\tdma_buf->skb = NULL;\n\t\t}\n\n\t\t \n\t\tlast++;\n\t\tlast &= info->mask;\n\t\tinfo->avail++;\n\t}\n\tinfo->last = last;\n\tspin_unlock_irq(&hw_priv->hwlock);\n\n\t \n\tif (dev)\n\t\tnetif_trans_update(dev);\n}\n\n \nstatic void tx_done(struct dev_info *hw_priv)\n{\n\tstruct ksz_hw *hw = &hw_priv->hw;\n\tint port;\n\n\ttransmit_cleanup(hw_priv, 1);\n\n\tfor (port = 0; port < hw->dev_count; port++) {\n\t\tstruct net_device *dev = hw->port_info[port].pdev;\n\n\t\tif (netif_running(dev) && netif_queue_stopped(dev))\n\t\t\tnetif_wake_queue(dev);\n\t}\n}\n\nstatic inline void copy_old_skb(struct sk_buff *old, struct sk_buff *skb)\n{\n\tskb->dev = old->dev;\n\tskb->protocol = old->protocol;\n\tskb->ip_summed = old->ip_summed;\n\tskb->csum = old->csum;\n\tskb_set_network_header(skb, ETH_HLEN);\n\n\tdev_consume_skb_any(old);\n}\n\n \nstatic netdev_tx_t netdev_tx(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct dev_priv *priv = netdev_priv(dev);\n\tstruct dev_info *hw_priv = priv->adapter;\n\tstruct ksz_hw *hw = &hw_priv->hw;\n\tint left;\n\tint num = 1;\n\tint rc = 0;\n\n\tif (hw->features & SMALL_PACKET_TX_BUG) {\n\t\tstruct sk_buff *org_skb = skb;\n\n\t\tif (skb->len <= 48) {\n\t\t\tif (skb_end_pointer(skb) - skb->data >= 50) {\n\t\t\t\tmemset(&skb->data[skb->len], 0, 50 - skb->len);\n\t\t\t\tskb->len = 50;\n\t\t\t} else {\n\t\t\t\tskb = netdev_alloc_skb(dev, 50);\n\t\t\t\tif (!skb)\n\t\t\t\t\treturn NETDEV_TX_BUSY;\n\t\t\t\tmemcpy(skb->data, org_skb->data, org_skb->len);\n\t\t\t\tmemset(&skb->data[org_skb->len], 0,\n\t\t\t\t\t50 - org_skb->len);\n\t\t\t\tskb->len = 50;\n\t\t\t\tcopy_old_skb(org_skb, skb);\n\t\t\t}\n\t\t}\n\t}\n\n\tspin_lock_irq(&hw_priv->hwlock);\n\n\tnum = skb_shinfo(skb)->nr_frags + 1;\n\tleft = hw_alloc_pkt(hw, skb->len, num);\n\tif (left) {\n\t\tif (left < num ||\n\t\t    (CHECKSUM_PARTIAL == skb->ip_summed &&\n\t\t     skb->protocol == htons(ETH_P_IPV6))) {\n\t\t\tstruct sk_buff *org_skb = skb;\n\n\t\t\tskb = netdev_alloc_skb(dev, org_skb->len);\n\t\t\tif (!skb) {\n\t\t\t\trc = NETDEV_TX_BUSY;\n\t\t\t\tgoto unlock;\n\t\t\t}\n\t\t\tskb_copy_and_csum_dev(org_skb, skb->data);\n\t\t\torg_skb->ip_summed = CHECKSUM_NONE;\n\t\t\tskb->len = org_skb->len;\n\t\t\tcopy_old_skb(org_skb, skb);\n\t\t}\n\t\tsend_packet(skb, dev);\n\t\tif (left <= num)\n\t\t\tnetif_stop_queue(dev);\n\t} else {\n\t\t \n\t\tnetif_stop_queue(dev);\n\t\trc = NETDEV_TX_BUSY;\n\t}\nunlock:\n\tspin_unlock_irq(&hw_priv->hwlock);\n\n\treturn rc;\n}\n\n \nstatic void netdev_tx_timeout(struct net_device *dev, unsigned int txqueue)\n{\n\tstatic unsigned long last_reset;\n\n\tstruct dev_priv *priv = netdev_priv(dev);\n\tstruct dev_info *hw_priv = priv->adapter;\n\tstruct ksz_hw *hw = &hw_priv->hw;\n\tint port;\n\n\tif (hw->dev_count > 1) {\n\t\t \n\t\tif (time_before_eq(jiffies, last_reset + dev->watchdog_timeo))\n\t\t\thw_priv = NULL;\n\t}\n\n\tlast_reset = jiffies;\n\tif (hw_priv) {\n\t\thw_dis_intr(hw);\n\t\thw_disable(hw);\n\n\t\ttransmit_cleanup(hw_priv, 0);\n\t\thw_reset_pkts(&hw->rx_desc_info);\n\t\thw_reset_pkts(&hw->tx_desc_info);\n\t\tksz_init_rx_buffers(hw_priv);\n\n\t\thw_reset(hw);\n\n\t\thw_set_desc_base(hw,\n\t\t\thw->tx_desc_info.ring_phys,\n\t\t\thw->rx_desc_info.ring_phys);\n\t\thw_set_addr(hw);\n\t\tif (hw->all_multi)\n\t\t\thw_set_multicast(hw, hw->all_multi);\n\t\telse if (hw->multi_list_size)\n\t\t\thw_set_grp_addr(hw);\n\n\t\tif (hw->dev_count > 1) {\n\t\t\thw_set_add_addr(hw);\n\t\t\tfor (port = 0; port < SWITCH_PORT_NUM; port++) {\n\t\t\t\tstruct net_device *port_dev;\n\n\t\t\t\tport_set_stp_state(hw, port,\n\t\t\t\t\tSTP_STATE_DISABLED);\n\n\t\t\t\tport_dev = hw->port_info[port].pdev;\n\t\t\t\tif (netif_running(port_dev))\n\t\t\t\t\tport_set_stp_state(hw, port,\n\t\t\t\t\t\tSTP_STATE_SIMPLE);\n\t\t\t}\n\t\t}\n\n\t\thw_enable(hw);\n\t\thw_ena_intr(hw);\n\t}\n\n\tnetif_trans_update(dev);\n\tnetif_wake_queue(dev);\n}\n\nstatic inline void csum_verified(struct sk_buff *skb)\n{\n\tunsigned short protocol;\n\tstruct iphdr *iph;\n\n\tprotocol = skb->protocol;\n\tskb_reset_network_header(skb);\n\tiph = (struct iphdr *) skb_network_header(skb);\n\tif (protocol == htons(ETH_P_8021Q)) {\n\t\tprotocol = iph->tot_len;\n\t\tskb_set_network_header(skb, VLAN_HLEN);\n\t\tiph = (struct iphdr *) skb_network_header(skb);\n\t}\n\tif (protocol == htons(ETH_P_IP)) {\n\t\tif (iph->protocol == IPPROTO_TCP)\n\t\t\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\t}\n}\n\nstatic inline int rx_proc(struct net_device *dev, struct ksz_hw* hw,\n\tstruct ksz_desc *desc, union desc_stat status)\n{\n\tint packet_len;\n\tstruct dev_priv *priv = netdev_priv(dev);\n\tstruct dev_info *hw_priv = priv->adapter;\n\tstruct ksz_dma_buf *dma_buf;\n\tstruct sk_buff *skb;\n\n\t \n\tpacket_len = status.rx.frame_len - 4;\n\n\tdma_buf = DMA_BUFFER(desc);\n\tdma_sync_single_for_cpu(&hw_priv->pdev->dev, dma_buf->dma,\n\t\t\t\tpacket_len + 4, DMA_FROM_DEVICE);\n\n\tdo {\n\t\t \n\t\tskb = netdev_alloc_skb(dev, packet_len + 2);\n\t\tif (!skb) {\n\t\t\tdev->stats.rx_dropped++;\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\t \n\t\tskb_reserve(skb, 2);\n\n\t\tskb_put_data(skb, dma_buf->skb->data, packet_len);\n\t} while (0);\n\n\tskb->protocol = eth_type_trans(skb, dev);\n\n\tif (hw->rx_cfg & (DMA_RX_CSUM_UDP | DMA_RX_CSUM_TCP))\n\t\tcsum_verified(skb);\n\n\t \n\tdev->stats.rx_packets++;\n\tdev->stats.rx_bytes += packet_len;\n\n\t \n\tnetif_rx(skb);\n\n\treturn 0;\n}\n\nstatic int dev_rcv_packets(struct dev_info *hw_priv)\n{\n\tint next;\n\tunion desc_stat status;\n\tstruct ksz_hw *hw = &hw_priv->hw;\n\tstruct net_device *dev = hw->port_info[0].pdev;\n\tstruct ksz_desc_info *info = &hw->rx_desc_info;\n\tint left = info->alloc;\n\tstruct ksz_desc *desc;\n\tint received = 0;\n\n\tnext = info->next;\n\twhile (left--) {\n\t\t \n\t\tdesc = &info->ring[next];\n\t\tstatus.data = le32_to_cpu(desc->phw->ctrl.data);\n\t\tif (status.rx.hw_owned)\n\t\t\tbreak;\n\n\t\t \n\t\tif (status.rx.last_desc && status.rx.first_desc) {\n\t\t\tif (rx_proc(dev, hw, desc, status))\n\t\t\t\tgoto release_packet;\n\t\t\treceived++;\n\t\t}\n\nrelease_packet:\n\t\trelease_desc(desc);\n\t\tnext++;\n\t\tnext &= info->mask;\n\t}\n\tinfo->next = next;\n\n\treturn received;\n}\n\nstatic int port_rcv_packets(struct dev_info *hw_priv)\n{\n\tint next;\n\tunion desc_stat status;\n\tstruct ksz_hw *hw = &hw_priv->hw;\n\tstruct net_device *dev = hw->port_info[0].pdev;\n\tstruct ksz_desc_info *info = &hw->rx_desc_info;\n\tint left = info->alloc;\n\tstruct ksz_desc *desc;\n\tint received = 0;\n\n\tnext = info->next;\n\twhile (left--) {\n\t\t \n\t\tdesc = &info->ring[next];\n\t\tstatus.data = le32_to_cpu(desc->phw->ctrl.data);\n\t\tif (status.rx.hw_owned)\n\t\t\tbreak;\n\n\t\tif (hw->dev_count > 1) {\n\t\t\t \n\t\t\tint p = HW_TO_DEV_PORT(status.rx.src_port);\n\n\t\t\tdev = hw->port_info[p].pdev;\n\t\t\tif (!netif_running(dev))\n\t\t\t\tgoto release_packet;\n\t\t}\n\n\t\t \n\t\tif (status.rx.last_desc && status.rx.first_desc) {\n\t\t\tif (rx_proc(dev, hw, desc, status))\n\t\t\t\tgoto release_packet;\n\t\t\treceived++;\n\t\t}\n\nrelease_packet:\n\t\trelease_desc(desc);\n\t\tnext++;\n\t\tnext &= info->mask;\n\t}\n\tinfo->next = next;\n\n\treturn received;\n}\n\nstatic int dev_rcv_special(struct dev_info *hw_priv)\n{\n\tint next;\n\tunion desc_stat status;\n\tstruct ksz_hw *hw = &hw_priv->hw;\n\tstruct net_device *dev = hw->port_info[0].pdev;\n\tstruct ksz_desc_info *info = &hw->rx_desc_info;\n\tint left = info->alloc;\n\tstruct ksz_desc *desc;\n\tint received = 0;\n\n\tnext = info->next;\n\twhile (left--) {\n\t\t \n\t\tdesc = &info->ring[next];\n\t\tstatus.data = le32_to_cpu(desc->phw->ctrl.data);\n\t\tif (status.rx.hw_owned)\n\t\t\tbreak;\n\n\t\tif (hw->dev_count > 1) {\n\t\t\t \n\t\t\tint p = HW_TO_DEV_PORT(status.rx.src_port);\n\n\t\t\tdev = hw->port_info[p].pdev;\n\t\t\tif (!netif_running(dev))\n\t\t\t\tgoto release_packet;\n\t\t}\n\n\t\t \n\t\tif (status.rx.last_desc && status.rx.first_desc) {\n\t\t\t \n\t\t\tif (!status.rx.error || (status.data &\n\t\t\t\t\tKS_DESC_RX_ERROR_COND) ==\n\t\t\t\t\tKS_DESC_RX_ERROR_TOO_LONG) {\n\t\t\t\tif (rx_proc(dev, hw, desc, status))\n\t\t\t\t\tgoto release_packet;\n\t\t\t\treceived++;\n\t\t\t} else {\n\t\t\t\tstruct dev_priv *priv = netdev_priv(dev);\n\n\t\t\t\t \n\t\t\t\tpriv->port.counter[OID_COUNTER_RCV_ERROR]++;\n\t\t\t}\n\t\t}\n\nrelease_packet:\n\t\trelease_desc(desc);\n\t\tnext++;\n\t\tnext &= info->mask;\n\t}\n\tinfo->next = next;\n\n\treturn received;\n}\n\nstatic void rx_proc_task(struct tasklet_struct *t)\n{\n\tstruct dev_info *hw_priv = from_tasklet(hw_priv, t, rx_tasklet);\n\tstruct ksz_hw *hw = &hw_priv->hw;\n\n\tif (!hw->enabled)\n\t\treturn;\n\tif (unlikely(!hw_priv->dev_rcv(hw_priv))) {\n\n\t\t \n\t\thw_resume_rx(hw);\n\n\t\t \n\t\tspin_lock_irq(&hw_priv->hwlock);\n\t\thw_turn_on_intr(hw, KS884X_INT_RX_MASK);\n\t\tspin_unlock_irq(&hw_priv->hwlock);\n\t} else {\n\t\thw_ack_intr(hw, KS884X_INT_RX);\n\t\ttasklet_schedule(&hw_priv->rx_tasklet);\n\t}\n}\n\nstatic void tx_proc_task(struct tasklet_struct *t)\n{\n\tstruct dev_info *hw_priv = from_tasklet(hw_priv, t, tx_tasklet);\n\tstruct ksz_hw *hw = &hw_priv->hw;\n\n\thw_ack_intr(hw, KS884X_INT_TX_MASK);\n\n\ttx_done(hw_priv);\n\n\t \n\tspin_lock_irq(&hw_priv->hwlock);\n\thw_turn_on_intr(hw, KS884X_INT_TX);\n\tspin_unlock_irq(&hw_priv->hwlock);\n}\n\nstatic inline void handle_rx_stop(struct ksz_hw *hw)\n{\n\t \n\tif (0 == hw->rx_stop)\n\t\thw->intr_mask &= ~KS884X_INT_RX_STOPPED;\n\telse if (hw->rx_stop > 1) {\n\t\tif (hw->enabled && (hw->rx_cfg & DMA_RX_ENABLE)) {\n\t\t\thw_start_rx(hw);\n\t\t} else {\n\t\t\thw->intr_mask &= ~KS884X_INT_RX_STOPPED;\n\t\t\thw->rx_stop = 0;\n\t\t}\n\t} else\n\t\t \n\t\thw->rx_stop++;\n}\n\n \nstatic irqreturn_t netdev_intr(int irq, void *dev_id)\n{\n\tuint int_enable = 0;\n\tstruct net_device *dev = (struct net_device *) dev_id;\n\tstruct dev_priv *priv = netdev_priv(dev);\n\tstruct dev_info *hw_priv = priv->adapter;\n\tstruct ksz_hw *hw = &hw_priv->hw;\n\n\tspin_lock(&hw_priv->hwlock);\n\n\thw_read_intr(hw, &int_enable);\n\n\t \n\tif (!int_enable) {\n\t\tspin_unlock(&hw_priv->hwlock);\n\t\treturn IRQ_NONE;\n\t}\n\n\tdo {\n\t\thw_ack_intr(hw, int_enable);\n\t\tint_enable &= hw->intr_mask;\n\n\t\tif (unlikely(int_enable & KS884X_INT_TX_MASK)) {\n\t\t\thw_dis_intr_bit(hw, KS884X_INT_TX_MASK);\n\t\t\ttasklet_schedule(&hw_priv->tx_tasklet);\n\t\t}\n\n\t\tif (likely(int_enable & KS884X_INT_RX)) {\n\t\t\thw_dis_intr_bit(hw, KS884X_INT_RX);\n\t\t\ttasklet_schedule(&hw_priv->rx_tasklet);\n\t\t}\n\n\t\tif (unlikely(int_enable & KS884X_INT_RX_OVERRUN)) {\n\t\t\tdev->stats.rx_fifo_errors++;\n\t\t\thw_resume_rx(hw);\n\t\t}\n\n\t\tif (unlikely(int_enable & KS884X_INT_PHY)) {\n\t\t\tstruct ksz_port *port = &priv->port;\n\n\t\t\thw->features |= LINK_INT_WORKING;\n\t\t\tport_get_link_speed(port);\n\t\t}\n\n\t\tif (unlikely(int_enable & KS884X_INT_RX_STOPPED)) {\n\t\t\thandle_rx_stop(hw);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (unlikely(int_enable & KS884X_INT_TX_STOPPED)) {\n\t\t\tu32 data;\n\n\t\t\thw->intr_mask &= ~KS884X_INT_TX_STOPPED;\n\t\t\tpr_info(\"Tx stopped\\n\");\n\t\t\tdata = readl(hw->io + KS_DMA_TX_CTRL);\n\t\t\tif (!(data & DMA_TX_ENABLE))\n\t\t\t\tpr_info(\"Tx disabled\\n\");\n\t\t\tbreak;\n\t\t}\n\t} while (0);\n\n\thw_ena_intr(hw);\n\n\tspin_unlock(&hw_priv->hwlock);\n\n\treturn IRQ_HANDLED;\n}\n\n \n\n\n#ifdef CONFIG_NET_POLL_CONTROLLER\nstatic void netdev_netpoll(struct net_device *dev)\n{\n\tstruct dev_priv *priv = netdev_priv(dev);\n\tstruct dev_info *hw_priv = priv->adapter;\n\n\thw_dis_intr(&hw_priv->hw);\n\tnetdev_intr(dev->irq, dev);\n}\n#endif\n\nstatic void bridge_change(struct ksz_hw *hw)\n{\n\tint port;\n\tu8  member;\n\tstruct ksz_switch *sw = hw->ksz_switch;\n\n\t \n\tif (!sw->member) {\n\t\tport_set_stp_state(hw, SWITCH_PORT_NUM, STP_STATE_SIMPLE);\n\t\tsw_block_addr(hw);\n\t}\n\tfor (port = 0; port < SWITCH_PORT_NUM; port++) {\n\t\tif (STP_STATE_FORWARDING == sw->port_cfg[port].stp_state)\n\t\t\tmember = HOST_MASK | sw->member;\n\t\telse\n\t\t\tmember = HOST_MASK | (1 << port);\n\t\tif (member != sw->port_cfg[port].member)\n\t\t\tsw_cfg_port_base_vlan(hw, port, member);\n\t}\n}\n\n \nstatic int netdev_close(struct net_device *dev)\n{\n\tstruct dev_priv *priv = netdev_priv(dev);\n\tstruct dev_info *hw_priv = priv->adapter;\n\tstruct ksz_port *port = &priv->port;\n\tstruct ksz_hw *hw = &hw_priv->hw;\n\tint pi;\n\n\tnetif_stop_queue(dev);\n\n\tksz_stop_timer(&priv->monitor_timer_info);\n\n\t \n\tif (hw->dev_count > 1) {\n\t\tport_set_stp_state(hw, port->first_port, STP_STATE_DISABLED);\n\n\t\t \n\t\tif (hw->features & STP_SUPPORT) {\n\t\t\tpi = 1 << port->first_port;\n\t\t\tif (hw->ksz_switch->member & pi) {\n\t\t\t\thw->ksz_switch->member &= ~pi;\n\t\t\t\tbridge_change(hw);\n\t\t\t}\n\t\t}\n\t}\n\tif (port->first_port > 0)\n\t\thw_del_addr(hw, dev->dev_addr);\n\tif (!hw_priv->wol_enable)\n\t\tport_set_power_saving(port, true);\n\n\tif (priv->multicast)\n\t\t--hw->all_multi;\n\tif (priv->promiscuous)\n\t\t--hw->promiscuous;\n\n\thw_priv->opened--;\n\tif (!(hw_priv->opened)) {\n\t\tksz_stop_timer(&hw_priv->mib_timer_info);\n\t\tflush_work(&hw_priv->mib_read);\n\n\t\thw_dis_intr(hw);\n\t\thw_disable(hw);\n\t\thw_clr_multicast(hw);\n\n\t\t \n\t\tmsleep(2000 / HZ);\n\n\t\ttasklet_kill(&hw_priv->rx_tasklet);\n\t\ttasklet_kill(&hw_priv->tx_tasklet);\n\t\tfree_irq(dev->irq, hw_priv->dev);\n\n\t\ttransmit_cleanup(hw_priv, 0);\n\t\thw_reset_pkts(&hw->rx_desc_info);\n\t\thw_reset_pkts(&hw->tx_desc_info);\n\n\t\t \n\t\tif (hw->features & STP_SUPPORT)\n\t\t\tsw_clr_sta_mac_table(hw);\n\t}\n\n\treturn 0;\n}\n\nstatic void hw_cfg_huge_frame(struct dev_info *hw_priv, struct ksz_hw *hw)\n{\n\tif (hw->ksz_switch) {\n\t\tu32 data;\n\n\t\tdata = readw(hw->io + KS8842_SWITCH_CTRL_2_OFFSET);\n\t\tif (hw->features & RX_HUGE_FRAME)\n\t\t\tdata |= SWITCH_HUGE_PACKET;\n\t\telse\n\t\t\tdata &= ~SWITCH_HUGE_PACKET;\n\t\twritew(data, hw->io + KS8842_SWITCH_CTRL_2_OFFSET);\n\t}\n\tif (hw->features & RX_HUGE_FRAME) {\n\t\thw->rx_cfg |= DMA_RX_ERROR;\n\t\thw_priv->dev_rcv = dev_rcv_special;\n\t} else {\n\t\thw->rx_cfg &= ~DMA_RX_ERROR;\n\t\tif (hw->dev_count > 1)\n\t\t\thw_priv->dev_rcv = port_rcv_packets;\n\t\telse\n\t\t\thw_priv->dev_rcv = dev_rcv_packets;\n\t}\n}\n\nstatic int prepare_hardware(struct net_device *dev)\n{\n\tstruct dev_priv *priv = netdev_priv(dev);\n\tstruct dev_info *hw_priv = priv->adapter;\n\tstruct ksz_hw *hw = &hw_priv->hw;\n\tint rc = 0;\n\n\t \n\thw_priv->dev = dev;\n\trc = request_irq(dev->irq, netdev_intr, IRQF_SHARED, dev->name, dev);\n\tif (rc)\n\t\treturn rc;\n\ttasklet_setup(&hw_priv->rx_tasklet, rx_proc_task);\n\ttasklet_setup(&hw_priv->tx_tasklet, tx_proc_task);\n\n\thw->promiscuous = 0;\n\thw->all_multi = 0;\n\thw->multi_list_size = 0;\n\n\thw_reset(hw);\n\n\thw_set_desc_base(hw,\n\t\thw->tx_desc_info.ring_phys, hw->rx_desc_info.ring_phys);\n\thw_set_addr(hw);\n\thw_cfg_huge_frame(hw_priv, hw);\n\tksz_init_rx_buffers(hw_priv);\n\treturn 0;\n}\n\nstatic void set_media_state(struct net_device *dev, int media_state)\n{\n\tstruct dev_priv *priv = netdev_priv(dev);\n\n\tif (media_state == priv->media_state)\n\t\tnetif_carrier_on(dev);\n\telse\n\t\tnetif_carrier_off(dev);\n\tnetif_info(priv, link, dev, \"link %s\\n\",\n\t\t   media_state == priv->media_state ? \"on\" : \"off\");\n}\n\n \nstatic int netdev_open(struct net_device *dev)\n{\n\tstruct dev_priv *priv = netdev_priv(dev);\n\tstruct dev_info *hw_priv = priv->adapter;\n\tstruct ksz_hw *hw = &hw_priv->hw;\n\tstruct ksz_port *port = &priv->port;\n\tunsigned long next_jiffies;\n\tint i;\n\tint p;\n\tint rc = 0;\n\n\tnext_jiffies = jiffies + HZ * 2;\n\tpriv->multicast = 0;\n\tpriv->promiscuous = 0;\n\n\t \n\tmemset(&dev->stats, 0, sizeof(struct net_device_stats));\n\tmemset((void *) port->counter, 0,\n\t\t(sizeof(u64) * OID_COUNTER_LAST));\n\n\tif (!(hw_priv->opened)) {\n\t\trc = prepare_hardware(dev);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tfor (i = 0; i < hw->mib_port_cnt; i++) {\n\t\t\tnext_jiffies += HZ * 1;\n\t\t\thw_priv->counter[i].time = next_jiffies;\n\t\t\thw->port_mib[i].state = media_disconnected;\n\t\t\tport_init_cnt(hw, i);\n\t\t}\n\t\tif (hw->ksz_switch)\n\t\t\thw->port_mib[HOST_PORT].state = media_connected;\n\t\telse {\n\t\t\thw_add_wol_bcast(hw);\n\t\t\thw_cfg_wol_pme(hw, 0);\n\t\t\thw_clr_wol_pme_status(&hw_priv->hw);\n\t\t}\n\t}\n\tport_set_power_saving(port, false);\n\n\tfor (i = 0, p = port->first_port; i < port->port_cnt; i++, p++) {\n\t\t \n\t\thw->port_info[p].partner = 0xFF;\n\t\thw->port_info[p].state = media_disconnected;\n\t}\n\n\t \n\tif (hw->dev_count > 1) {\n\t\tport_set_stp_state(hw, port->first_port, STP_STATE_SIMPLE);\n\t\tif (port->first_port > 0)\n\t\t\thw_add_addr(hw, dev->dev_addr);\n\t}\n\n\tport_get_link_speed(port);\n\tif (port->force_link)\n\t\tport_force_link_speed(port);\n\telse\n\t\tport_set_link_speed(port);\n\n\tif (!(hw_priv->opened)) {\n\t\thw_setup_intr(hw);\n\t\thw_enable(hw);\n\t\thw_ena_intr(hw);\n\n\t\tif (hw->mib_port_cnt)\n\t\t\tksz_start_timer(&hw_priv->mib_timer_info,\n\t\t\t\thw_priv->mib_timer_info.period);\n\t}\n\n\thw_priv->opened++;\n\n\tksz_start_timer(&priv->monitor_timer_info,\n\t\tpriv->monitor_timer_info.period);\n\n\tpriv->media_state = port->linked->state;\n\n\tset_media_state(dev, media_connected);\n\tnetif_start_queue(dev);\n\n\treturn 0;\n}\n\n \n \n \n \n \n \n \n \n \n\n \nstatic struct net_device_stats *netdev_query_statistics(struct net_device *dev)\n{\n\tstruct dev_priv *priv = netdev_priv(dev);\n\tstruct ksz_port *port = &priv->port;\n\tstruct ksz_hw *hw = &priv->adapter->hw;\n\tstruct ksz_port_mib *mib;\n\tint i;\n\tint p;\n\n\tdev->stats.rx_errors = port->counter[OID_COUNTER_RCV_ERROR];\n\tdev->stats.tx_errors = port->counter[OID_COUNTER_XMIT_ERROR];\n\n\t \n\tdev->stats.multicast = 0;\n\tdev->stats.collisions = 0;\n\tdev->stats.rx_length_errors = 0;\n\tdev->stats.rx_crc_errors = 0;\n\tdev->stats.rx_frame_errors = 0;\n\tdev->stats.tx_window_errors = 0;\n\n\tfor (i = 0, p = port->first_port; i < port->mib_port_cnt; i++, p++) {\n\t\tmib = &hw->port_mib[p];\n\n\t\tdev->stats.multicast += (unsigned long)\n\t\t\tmib->counter[MIB_COUNTER_RX_MULTICAST];\n\n\t\tdev->stats.collisions += (unsigned long)\n\t\t\tmib->counter[MIB_COUNTER_TX_TOTAL_COLLISION];\n\n\t\tdev->stats.rx_length_errors += (unsigned long)(\n\t\t\tmib->counter[MIB_COUNTER_RX_UNDERSIZE] +\n\t\t\tmib->counter[MIB_COUNTER_RX_FRAGMENT] +\n\t\t\tmib->counter[MIB_COUNTER_RX_OVERSIZE] +\n\t\t\tmib->counter[MIB_COUNTER_RX_JABBER]);\n\t\tdev->stats.rx_crc_errors += (unsigned long)\n\t\t\tmib->counter[MIB_COUNTER_RX_CRC_ERR];\n\t\tdev->stats.rx_frame_errors += (unsigned long)(\n\t\t\tmib->counter[MIB_COUNTER_RX_ALIGNMENT_ERR] +\n\t\t\tmib->counter[MIB_COUNTER_RX_SYMBOL_ERR]);\n\n\t\tdev->stats.tx_window_errors += (unsigned long)\n\t\t\tmib->counter[MIB_COUNTER_TX_LATE_COLLISION];\n\t}\n\n\treturn &dev->stats;\n}\n\n \nstatic int netdev_set_mac_address(struct net_device *dev, void *addr)\n{\n\tstruct dev_priv *priv = netdev_priv(dev);\n\tstruct dev_info *hw_priv = priv->adapter;\n\tstruct ksz_hw *hw = &hw_priv->hw;\n\tstruct sockaddr *mac = addr;\n\tuint interrupt;\n\n\tif (priv->port.first_port > 0)\n\t\thw_del_addr(hw, dev->dev_addr);\n\telse {\n\t\thw->mac_override = 1;\n\t\tmemcpy(hw->override_addr, mac->sa_data, ETH_ALEN);\n\t}\n\n\teth_hw_addr_set(dev, mac->sa_data);\n\n\tinterrupt = hw_block_intr(hw);\n\n\tif (priv->port.first_port > 0)\n\t\thw_add_addr(hw, dev->dev_addr);\n\telse\n\t\thw_set_addr(hw);\n\thw_restore_intr(hw, interrupt);\n\n\treturn 0;\n}\n\nstatic void dev_set_promiscuous(struct net_device *dev, struct dev_priv *priv,\n\tstruct ksz_hw *hw, int promiscuous)\n{\n\tif (promiscuous != priv->promiscuous) {\n\t\tu8 prev_state = hw->promiscuous;\n\n\t\tif (promiscuous)\n\t\t\t++hw->promiscuous;\n\t\telse\n\t\t\t--hw->promiscuous;\n\t\tpriv->promiscuous = promiscuous;\n\n\t\t \n\t\tif (hw->promiscuous <= 1 && prev_state <= 1)\n\t\t\thw_set_promiscuous(hw, hw->promiscuous);\n\n\t\t \n\t\tif ((hw->features & STP_SUPPORT) && !promiscuous &&\n\t\t    netif_is_bridge_port(dev)) {\n\t\t\tstruct ksz_switch *sw = hw->ksz_switch;\n\t\t\tint port = priv->port.first_port;\n\n\t\t\tport_set_stp_state(hw, port, STP_STATE_DISABLED);\n\t\t\tport = 1 << port;\n\t\t\tif (sw->member & port) {\n\t\t\t\tsw->member &= ~port;\n\t\t\t\tbridge_change(hw);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void dev_set_multicast(struct dev_priv *priv, struct ksz_hw *hw,\n\tint multicast)\n{\n\tif (multicast != priv->multicast) {\n\t\tu8 all_multi = hw->all_multi;\n\n\t\tif (multicast)\n\t\t\t++hw->all_multi;\n\t\telse\n\t\t\t--hw->all_multi;\n\t\tpriv->multicast = multicast;\n\n\t\t \n\t\tif (hw->all_multi <= 1 && all_multi <= 1)\n\t\t\thw_set_multicast(hw, hw->all_multi);\n\t}\n}\n\n \nstatic void netdev_set_rx_mode(struct net_device *dev)\n{\n\tstruct dev_priv *priv = netdev_priv(dev);\n\tstruct dev_info *hw_priv = priv->adapter;\n\tstruct ksz_hw *hw = &hw_priv->hw;\n\tstruct netdev_hw_addr *ha;\n\tint multicast = (dev->flags & IFF_ALLMULTI);\n\n\tdev_set_promiscuous(dev, priv, hw, (dev->flags & IFF_PROMISC));\n\n\tif (hw_priv->hw.dev_count > 1)\n\t\tmulticast |= (dev->flags & IFF_MULTICAST);\n\tdev_set_multicast(priv, hw, multicast);\n\n\t \n\tif (hw_priv->hw.dev_count > 1)\n\t\treturn;\n\n\tif ((dev->flags & IFF_MULTICAST) && !netdev_mc_empty(dev)) {\n\t\tint i = 0;\n\n\t\t \n\t\tif (netdev_mc_count(dev) > MAX_MULTICAST_LIST) {\n\t\t\tif (MAX_MULTICAST_LIST != hw->multi_list_size) {\n\t\t\t\thw->multi_list_size = MAX_MULTICAST_LIST;\n\t\t\t\t++hw->all_multi;\n\t\t\t\thw_set_multicast(hw, hw->all_multi);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tnetdev_for_each_mc_addr(ha, dev) {\n\t\t\tif (i >= MAX_MULTICAST_LIST)\n\t\t\t\tbreak;\n\t\t\tmemcpy(hw->multi_list[i++], ha->addr, ETH_ALEN);\n\t\t}\n\t\thw->multi_list_size = (u8) i;\n\t\thw_set_grp_addr(hw);\n\t} else {\n\t\tif (MAX_MULTICAST_LIST == hw->multi_list_size) {\n\t\t\t--hw->all_multi;\n\t\t\thw_set_multicast(hw, hw->all_multi);\n\t\t}\n\t\thw->multi_list_size = 0;\n\t\thw_clr_multicast(hw);\n\t}\n}\n\nstatic int netdev_change_mtu(struct net_device *dev, int new_mtu)\n{\n\tstruct dev_priv *priv = netdev_priv(dev);\n\tstruct dev_info *hw_priv = priv->adapter;\n\tstruct ksz_hw *hw = &hw_priv->hw;\n\tint hw_mtu;\n\n\tif (netif_running(dev))\n\t\treturn -EBUSY;\n\n\t \n\tif (hw->dev_count > 1)\n\t\tif (dev != hw_priv->dev)\n\t\t\treturn 0;\n\n\thw_mtu = new_mtu + ETHERNET_HEADER_SIZE + 4;\n\tif (hw_mtu > REGULAR_RX_BUF_SIZE) {\n\t\thw->features |= RX_HUGE_FRAME;\n\t\thw_mtu = MAX_RX_BUF_SIZE;\n\t} else {\n\t\thw->features &= ~RX_HUGE_FRAME;\n\t\thw_mtu = REGULAR_RX_BUF_SIZE;\n\t}\n\thw_mtu = (hw_mtu + 3) & ~3;\n\thw_priv->mtu = hw_mtu;\n\tdev->mtu = new_mtu;\n\n\treturn 0;\n}\n\n \nstatic int netdev_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\n{\n\tstruct dev_priv *priv = netdev_priv(dev);\n\tstruct dev_info *hw_priv = priv->adapter;\n\tstruct ksz_hw *hw = &hw_priv->hw;\n\tstruct ksz_port *port = &priv->port;\n\tint result = 0;\n\tstruct mii_ioctl_data *data = if_mii(ifr);\n\n\tif (down_interruptible(&priv->proc_sem))\n\t\treturn -ERESTARTSYS;\n\n\tswitch (cmd) {\n\t \n\tcase SIOCGMIIPHY:\n\t\tdata->phy_id = priv->id;\n\t\tfallthrough;\n\n\t \n\tcase SIOCGMIIREG:\n\t\tif (data->phy_id != priv->id || data->reg_num >= 6)\n\t\t\tresult = -EIO;\n\t\telse\n\t\t\thw_r_phy(hw, port->linked->port_id, data->reg_num,\n\t\t\t\t&data->val_out);\n\t\tbreak;\n\n\t \n\tcase SIOCSMIIREG:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\tresult = -EPERM;\n\t\telse if (data->phy_id != priv->id || data->reg_num >= 6)\n\t\t\tresult = -EIO;\n\t\telse\n\t\t\thw_w_phy(hw, port->linked->port_id, data->reg_num,\n\t\t\t\tdata->val_in);\n\t\tbreak;\n\n\tdefault:\n\t\tresult = -EOPNOTSUPP;\n\t}\n\n\tup(&priv->proc_sem);\n\n\treturn result;\n}\n\n \n\n \nstatic int mdio_read(struct net_device *dev, int phy_id, int reg_num)\n{\n\tstruct dev_priv *priv = netdev_priv(dev);\n\tstruct ksz_port *port = &priv->port;\n\tstruct ksz_hw *hw = port->hw;\n\tu16 val_out;\n\n\thw_r_phy(hw, port->linked->port_id, reg_num << 1, &val_out);\n\treturn val_out;\n}\n\n \nstatic void mdio_write(struct net_device *dev, int phy_id, int reg_num, int val)\n{\n\tstruct dev_priv *priv = netdev_priv(dev);\n\tstruct ksz_port *port = &priv->port;\n\tstruct ksz_hw *hw = port->hw;\n\tint i;\n\tint pi;\n\n\tfor (i = 0, pi = port->first_port; i < port->port_cnt; i++, pi++)\n\t\thw_w_phy(hw, pi, reg_num << 1, val);\n}\n\n \n\n#define EEPROM_SIZE\t\t\t0x40\n\nstatic u16 eeprom_data[EEPROM_SIZE] = { 0 };\n\n#define ADVERTISED_ALL\t\t\t\\\n\t(ADVERTISED_10baseT_Half |\t\\\n\tADVERTISED_10baseT_Full |\t\\\n\tADVERTISED_100baseT_Half |\t\\\n\tADVERTISED_100baseT_Full)\n\n \n\n \nstatic int netdev_get_link_ksettings(struct net_device *dev,\n\t\t\t\t     struct ethtool_link_ksettings *cmd)\n{\n\tstruct dev_priv *priv = netdev_priv(dev);\n\tstruct dev_info *hw_priv = priv->adapter;\n\n\tmutex_lock(&hw_priv->lock);\n\tmii_ethtool_get_link_ksettings(&priv->mii_if, cmd);\n\tethtool_link_ksettings_add_link_mode(cmd, advertising, TP);\n\tmutex_unlock(&hw_priv->lock);\n\n\t \n\tethtool_convert_link_mode_to_legacy_u32(&priv->advertising,\n\t\t\t\t\t\tcmd->link_modes.advertising);\n\n\treturn 0;\n}\n\n \nstatic int netdev_set_link_ksettings(struct net_device *dev,\n\t\t\t\t     const struct ethtool_link_ksettings *cmd)\n{\n\tstruct dev_priv *priv = netdev_priv(dev);\n\tstruct dev_info *hw_priv = priv->adapter;\n\tstruct ksz_port *port = &priv->port;\n\tstruct ethtool_link_ksettings copy_cmd;\n\tu32 speed = cmd->base.speed;\n\tu32 advertising;\n\tint rc;\n\n\tethtool_convert_link_mode_to_legacy_u32(&advertising,\n\t\t\t\t\t\tcmd->link_modes.advertising);\n\n\t \n\tif (cmd->base.autoneg && priv->advertising == advertising) {\n\t\tadvertising |= ADVERTISED_ALL;\n\t\tif (10 == speed)\n\t\t\tadvertising &=\n\t\t\t\t~(ADVERTISED_100baseT_Full |\n\t\t\t\tADVERTISED_100baseT_Half);\n\t\telse if (100 == speed)\n\t\t\tadvertising &=\n\t\t\t\t~(ADVERTISED_10baseT_Full |\n\t\t\t\tADVERTISED_10baseT_Half);\n\t\tif (0 == cmd->base.duplex)\n\t\t\tadvertising &=\n\t\t\t\t~(ADVERTISED_100baseT_Full |\n\t\t\t\tADVERTISED_10baseT_Full);\n\t\telse if (1 == cmd->base.duplex)\n\t\t\tadvertising &=\n\t\t\t\t~(ADVERTISED_100baseT_Half |\n\t\t\t\tADVERTISED_10baseT_Half);\n\t}\n\tmutex_lock(&hw_priv->lock);\n\tif (cmd->base.autoneg &&\n\t    (advertising & ADVERTISED_ALL) == ADVERTISED_ALL) {\n\t\tport->duplex = 0;\n\t\tport->speed = 0;\n\t\tport->force_link = 0;\n\t} else {\n\t\tport->duplex = cmd->base.duplex + 1;\n\t\tif (1000 != speed)\n\t\t\tport->speed = speed;\n\t\tif (cmd->base.autoneg)\n\t\t\tport->force_link = 0;\n\t\telse\n\t\t\tport->force_link = 1;\n\t}\n\n\tmemcpy(&copy_cmd, cmd, sizeof(copy_cmd));\n\tethtool_convert_legacy_u32_to_link_mode(copy_cmd.link_modes.advertising,\n\t\t\t\t\t\tadvertising);\n\trc = mii_ethtool_set_link_ksettings(\n\t\t&priv->mii_if,\n\t\t(const struct ethtool_link_ksettings *)&copy_cmd);\n\tmutex_unlock(&hw_priv->lock);\n\treturn rc;\n}\n\n \nstatic int netdev_nway_reset(struct net_device *dev)\n{\n\tstruct dev_priv *priv = netdev_priv(dev);\n\tstruct dev_info *hw_priv = priv->adapter;\n\tint rc;\n\n\tmutex_lock(&hw_priv->lock);\n\trc = mii_nway_restart(&priv->mii_if);\n\tmutex_unlock(&hw_priv->lock);\n\treturn rc;\n}\n\n \nstatic u32 netdev_get_link(struct net_device *dev)\n{\n\tstruct dev_priv *priv = netdev_priv(dev);\n\tint rc;\n\n\trc = mii_link_ok(&priv->mii_if);\n\treturn rc;\n}\n\n \nstatic void netdev_get_drvinfo(struct net_device *dev,\n\tstruct ethtool_drvinfo *info)\n{\n\tstruct dev_priv *priv = netdev_priv(dev);\n\tstruct dev_info *hw_priv = priv->adapter;\n\n\tstrscpy(info->driver, DRV_NAME, sizeof(info->driver));\n\tstrscpy(info->version, DRV_VERSION, sizeof(info->version));\n\tstrscpy(info->bus_info, pci_name(hw_priv->pdev),\n\t\tsizeof(info->bus_info));\n}\n\nstatic struct hw_regs {\n\tint start;\n\tint end;\n} hw_regs_range[] = {\n\t{ KS_DMA_TX_CTRL,\tKS884X_INTERRUPTS_STATUS },\n\t{ KS_ADD_ADDR_0_LO,\tKS_ADD_ADDR_F_HI },\n\t{ KS884X_ADDR_0_OFFSET,\tKS8841_WOL_FRAME_BYTE2_OFFSET },\n\t{ KS884X_SIDER_P,\tKS8842_SGCR7_P },\n\t{ KS8842_MACAR1_P,\tKS8842_TOSR8_P },\n\t{ KS884X_P1MBCR_P,\tKS8842_P3ERCR_P },\n\t{ 0, 0 }\n};\n\n \nstatic int netdev_get_regs_len(struct net_device *dev)\n{\n\tstruct hw_regs *range = hw_regs_range;\n\tint regs_len = 0x10 * sizeof(u32);\n\n\twhile (range->end > range->start) {\n\t\tregs_len += (range->end - range->start + 3) / 4 * 4;\n\t\trange++;\n\t}\n\treturn regs_len;\n}\n\n \nstatic void netdev_get_regs(struct net_device *dev, struct ethtool_regs *regs,\n\tvoid *ptr)\n{\n\tstruct dev_priv *priv = netdev_priv(dev);\n\tstruct dev_info *hw_priv = priv->adapter;\n\tstruct ksz_hw *hw = &hw_priv->hw;\n\tint *buf = (int *) ptr;\n\tstruct hw_regs *range = hw_regs_range;\n\tint len;\n\n\tmutex_lock(&hw_priv->lock);\n\tregs->version = 0;\n\tfor (len = 0; len < 0x40; len += 4) {\n\t\tpci_read_config_dword(hw_priv->pdev, len, buf);\n\t\tbuf++;\n\t}\n\twhile (range->end > range->start) {\n\t\tfor (len = range->start; len < range->end; len += 4) {\n\t\t\t*buf = readl(hw->io + len);\n\t\t\tbuf++;\n\t\t}\n\t\trange++;\n\t}\n\tmutex_unlock(&hw_priv->lock);\n}\n\n#define WOL_SUPPORT\t\t\t\\\n\t(WAKE_PHY | WAKE_MAGIC |\t\\\n\tWAKE_UCAST | WAKE_MCAST |\t\\\n\tWAKE_BCAST | WAKE_ARP)\n\n \nstatic void netdev_get_wol(struct net_device *dev,\n\tstruct ethtool_wolinfo *wol)\n{\n\tstruct dev_priv *priv = netdev_priv(dev);\n\tstruct dev_info *hw_priv = priv->adapter;\n\n\twol->supported = hw_priv->wol_support;\n\twol->wolopts = hw_priv->wol_enable;\n\tmemset(&wol->sopass, 0, sizeof(wol->sopass));\n}\n\n \nstatic int netdev_set_wol(struct net_device *dev,\n\tstruct ethtool_wolinfo *wol)\n{\n\tstruct dev_priv *priv = netdev_priv(dev);\n\tstruct dev_info *hw_priv = priv->adapter;\n\n\t \n\tstatic const u8 net_addr[] = { 192, 168, 1, 1 };\n\n\tif (wol->wolopts & ~hw_priv->wol_support)\n\t\treturn -EINVAL;\n\n\thw_priv->wol_enable = wol->wolopts;\n\n\t \n\tif (wol->wolopts)\n\t\thw_priv->wol_enable |= WAKE_PHY;\n\thw_enable_wol(&hw_priv->hw, hw_priv->wol_enable, net_addr);\n\treturn 0;\n}\n\n \nstatic u32 netdev_get_msglevel(struct net_device *dev)\n{\n\tstruct dev_priv *priv = netdev_priv(dev);\n\n\treturn priv->msg_enable;\n}\n\n \nstatic void netdev_set_msglevel(struct net_device *dev, u32 value)\n{\n\tstruct dev_priv *priv = netdev_priv(dev);\n\n\tpriv->msg_enable = value;\n}\n\n \nstatic int netdev_get_eeprom_len(struct net_device *dev)\n{\n\treturn EEPROM_SIZE * 2;\n}\n\n#define EEPROM_MAGIC\t\t\t0x10A18842\n\n \nstatic int netdev_get_eeprom(struct net_device *dev,\n\tstruct ethtool_eeprom *eeprom, u8 *data)\n{\n\tstruct dev_priv *priv = netdev_priv(dev);\n\tstruct dev_info *hw_priv = priv->adapter;\n\tu8 *eeprom_byte = (u8 *) eeprom_data;\n\tint i;\n\tint len;\n\n\tlen = (eeprom->offset + eeprom->len + 1) / 2;\n\tfor (i = eeprom->offset / 2; i < len; i++)\n\t\teeprom_data[i] = eeprom_read(&hw_priv->hw, i);\n\teeprom->magic = EEPROM_MAGIC;\n\tmemcpy(data, &eeprom_byte[eeprom->offset], eeprom->len);\n\n\treturn 0;\n}\n\n \nstatic int netdev_set_eeprom(struct net_device *dev,\n\tstruct ethtool_eeprom *eeprom, u8 *data)\n{\n\tstruct dev_priv *priv = netdev_priv(dev);\n\tstruct dev_info *hw_priv = priv->adapter;\n\tu16 eeprom_word[EEPROM_SIZE];\n\tu8 *eeprom_byte = (u8 *) eeprom_word;\n\tint i;\n\tint len;\n\n\tif (eeprom->magic != EEPROM_MAGIC)\n\t\treturn -EINVAL;\n\n\tlen = (eeprom->offset + eeprom->len + 1) / 2;\n\tfor (i = eeprom->offset / 2; i < len; i++)\n\t\teeprom_data[i] = eeprom_read(&hw_priv->hw, i);\n\tmemcpy(eeprom_word, eeprom_data, EEPROM_SIZE * 2);\n\tmemcpy(&eeprom_byte[eeprom->offset], data, eeprom->len);\n\tfor (i = 0; i < EEPROM_SIZE; i++)\n\t\tif (eeprom_word[i] != eeprom_data[i]) {\n\t\t\teeprom_data[i] = eeprom_word[i];\n\t\t\teeprom_write(&hw_priv->hw, i, eeprom_data[i]);\n\t}\n\n\treturn 0;\n}\n\n \nstatic void netdev_get_pauseparam(struct net_device *dev,\n\tstruct ethtool_pauseparam *pause)\n{\n\tstruct dev_priv *priv = netdev_priv(dev);\n\tstruct dev_info *hw_priv = priv->adapter;\n\tstruct ksz_hw *hw = &hw_priv->hw;\n\n\tpause->autoneg = (hw->overrides & PAUSE_FLOW_CTRL) ? 0 : 1;\n\tif (!hw->ksz_switch) {\n\t\tpause->rx_pause =\n\t\t\t(hw->rx_cfg & DMA_RX_FLOW_ENABLE) ? 1 : 0;\n\t\tpause->tx_pause =\n\t\t\t(hw->tx_cfg & DMA_TX_FLOW_ENABLE) ? 1 : 0;\n\t} else {\n\t\tpause->rx_pause =\n\t\t\t(sw_chk(hw, KS8842_SWITCH_CTRL_1_OFFSET,\n\t\t\t\tSWITCH_RX_FLOW_CTRL)) ? 1 : 0;\n\t\tpause->tx_pause =\n\t\t\t(sw_chk(hw, KS8842_SWITCH_CTRL_1_OFFSET,\n\t\t\t\tSWITCH_TX_FLOW_CTRL)) ? 1 : 0;\n\t}\n}\n\n \nstatic int netdev_set_pauseparam(struct net_device *dev,\n\tstruct ethtool_pauseparam *pause)\n{\n\tstruct dev_priv *priv = netdev_priv(dev);\n\tstruct dev_info *hw_priv = priv->adapter;\n\tstruct ksz_hw *hw = &hw_priv->hw;\n\tstruct ksz_port *port = &priv->port;\n\n\tmutex_lock(&hw_priv->lock);\n\tif (pause->autoneg) {\n\t\tif (!pause->rx_pause && !pause->tx_pause)\n\t\t\tport->flow_ctrl = PHY_NO_FLOW_CTRL;\n\t\telse\n\t\t\tport->flow_ctrl = PHY_FLOW_CTRL;\n\t\thw->overrides &= ~PAUSE_FLOW_CTRL;\n\t\tport->force_link = 0;\n\t\tif (hw->ksz_switch) {\n\t\t\tsw_cfg(hw, KS8842_SWITCH_CTRL_1_OFFSET,\n\t\t\t\tSWITCH_RX_FLOW_CTRL, 1);\n\t\t\tsw_cfg(hw, KS8842_SWITCH_CTRL_1_OFFSET,\n\t\t\t\tSWITCH_TX_FLOW_CTRL, 1);\n\t\t}\n\t\tport_set_link_speed(port);\n\t} else {\n\t\thw->overrides |= PAUSE_FLOW_CTRL;\n\t\tif (hw->ksz_switch) {\n\t\t\tsw_cfg(hw, KS8842_SWITCH_CTRL_1_OFFSET,\n\t\t\t\tSWITCH_RX_FLOW_CTRL, pause->rx_pause);\n\t\t\tsw_cfg(hw, KS8842_SWITCH_CTRL_1_OFFSET,\n\t\t\t\tSWITCH_TX_FLOW_CTRL, pause->tx_pause);\n\t\t} else\n\t\t\tset_flow_ctrl(hw, pause->rx_pause, pause->tx_pause);\n\t}\n\tmutex_unlock(&hw_priv->lock);\n\n\treturn 0;\n}\n\n \nstatic void netdev_get_ringparam(struct net_device *dev,\n\t\t\t\t struct ethtool_ringparam *ring,\n\t\t\t\t struct kernel_ethtool_ringparam *kernel_ring,\n\t\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct dev_priv *priv = netdev_priv(dev);\n\tstruct dev_info *hw_priv = priv->adapter;\n\tstruct ksz_hw *hw = &hw_priv->hw;\n\n\tring->tx_max_pending = (1 << 9);\n\tring->tx_pending = hw->tx_desc_info.alloc;\n\tring->rx_max_pending = (1 << 9);\n\tring->rx_pending = hw->rx_desc_info.alloc;\n}\n\n#define STATS_LEN\t\t\t(TOTAL_PORT_COUNTER_NUM)\n\nstatic struct {\n\tchar string[ETH_GSTRING_LEN];\n} ethtool_stats_keys[STATS_LEN] = {\n\t{ \"rx_lo_priority_octets\" },\n\t{ \"rx_hi_priority_octets\" },\n\t{ \"rx_undersize_packets\" },\n\t{ \"rx_fragments\" },\n\t{ \"rx_oversize_packets\" },\n\t{ \"rx_jabbers\" },\n\t{ \"rx_symbol_errors\" },\n\t{ \"rx_crc_errors\" },\n\t{ \"rx_align_errors\" },\n\t{ \"rx_mac_ctrl_packets\" },\n\t{ \"rx_pause_packets\" },\n\t{ \"rx_bcast_packets\" },\n\t{ \"rx_mcast_packets\" },\n\t{ \"rx_ucast_packets\" },\n\t{ \"rx_64_or_less_octet_packets\" },\n\t{ \"rx_65_to_127_octet_packets\" },\n\t{ \"rx_128_to_255_octet_packets\" },\n\t{ \"rx_256_to_511_octet_packets\" },\n\t{ \"rx_512_to_1023_octet_packets\" },\n\t{ \"rx_1024_to_1522_octet_packets\" },\n\n\t{ \"tx_lo_priority_octets\" },\n\t{ \"tx_hi_priority_octets\" },\n\t{ \"tx_late_collisions\" },\n\t{ \"tx_pause_packets\" },\n\t{ \"tx_bcast_packets\" },\n\t{ \"tx_mcast_packets\" },\n\t{ \"tx_ucast_packets\" },\n\t{ \"tx_deferred\" },\n\t{ \"tx_total_collisions\" },\n\t{ \"tx_excessive_collisions\" },\n\t{ \"tx_single_collisions\" },\n\t{ \"tx_mult_collisions\" },\n\n\t{ \"rx_discards\" },\n\t{ \"tx_discards\" },\n};\n\n \nstatic void netdev_get_strings(struct net_device *dev, u32 stringset, u8 *buf)\n{\n\tstruct dev_priv *priv = netdev_priv(dev);\n\tstruct dev_info *hw_priv = priv->adapter;\n\tstruct ksz_hw *hw = &hw_priv->hw;\n\n\tif (ETH_SS_STATS == stringset)\n\t\tmemcpy(buf, &ethtool_stats_keys,\n\t\t\tETH_GSTRING_LEN * hw->mib_cnt);\n}\n\n \nstatic int netdev_get_sset_count(struct net_device *dev, int sset)\n{\n\tstruct dev_priv *priv = netdev_priv(dev);\n\tstruct dev_info *hw_priv = priv->adapter;\n\tstruct ksz_hw *hw = &hw_priv->hw;\n\n\tswitch (sset) {\n\tcase ETH_SS_STATS:\n\t\treturn hw->mib_cnt;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\n \nstatic void netdev_get_ethtool_stats(struct net_device *dev,\n\tstruct ethtool_stats *stats, u64 *data)\n{\n\tstruct dev_priv *priv = netdev_priv(dev);\n\tstruct dev_info *hw_priv = priv->adapter;\n\tstruct ksz_hw *hw = &hw_priv->hw;\n\tstruct ksz_port *port = &priv->port;\n\tint n_stats = stats->n_stats;\n\tint i;\n\tint n;\n\tint p;\n\tu64 counter[TOTAL_PORT_COUNTER_NUM];\n\n\tmutex_lock(&hw_priv->lock);\n\tn = SWITCH_PORT_NUM;\n\tfor (i = 0, p = port->first_port; i < port->mib_port_cnt; i++, p++) {\n\t\tif (media_connected == hw->port_mib[p].state) {\n\t\t\thw_priv->counter[p].read = 1;\n\n\t\t\t \n\t\t\tif (n == SWITCH_PORT_NUM)\n\t\t\t\tn = p;\n\t\t}\n\t}\n\tmutex_unlock(&hw_priv->lock);\n\n\tif (n < SWITCH_PORT_NUM)\n\t\tschedule_work(&hw_priv->mib_read);\n\n\tif (1 == port->mib_port_cnt && n < SWITCH_PORT_NUM) {\n\t\tp = n;\n\t\twait_event_interruptible_timeout(\n\t\t\thw_priv->counter[p].counter,\n\t\t\t2 == hw_priv->counter[p].read,\n\t\t\tHZ * 1);\n\t} else\n\t\tfor (i = 0, p = n; i < port->mib_port_cnt - n; i++, p++) {\n\t\t\tif (0 == i) {\n\t\t\t\twait_event_interruptible_timeout(\n\t\t\t\t\thw_priv->counter[p].counter,\n\t\t\t\t\t2 == hw_priv->counter[p].read,\n\t\t\t\t\tHZ * 2);\n\t\t\t} else if (hw->port_mib[p].cnt_ptr) {\n\t\t\t\twait_event_interruptible_timeout(\n\t\t\t\t\thw_priv->counter[p].counter,\n\t\t\t\t\t2 == hw_priv->counter[p].read,\n\t\t\t\t\tHZ * 1);\n\t\t\t}\n\t\t}\n\n\tget_mib_counters(hw, port->first_port, port->mib_port_cnt, counter);\n\tn = hw->mib_cnt;\n\tif (n > n_stats)\n\t\tn = n_stats;\n\tn_stats -= n;\n\tfor (i = 0; i < n; i++)\n\t\t*data++ = counter[i];\n}\n\n \nstatic int netdev_set_features(struct net_device *dev,\n\tnetdev_features_t features)\n{\n\tstruct dev_priv *priv = netdev_priv(dev);\n\tstruct dev_info *hw_priv = priv->adapter;\n\tstruct ksz_hw *hw = &hw_priv->hw;\n\n\tmutex_lock(&hw_priv->lock);\n\n\t \n\tif (features & NETIF_F_RXCSUM)\n\t\thw->rx_cfg |= DMA_RX_CSUM_TCP | DMA_RX_CSUM_IP;\n\telse\n\t\thw->rx_cfg &= ~(DMA_RX_CSUM_TCP | DMA_RX_CSUM_IP);\n\n\tif (hw->enabled)\n\t\twritel(hw->rx_cfg, hw->io + KS_DMA_RX_CTRL);\n\n\tmutex_unlock(&hw_priv->lock);\n\n\treturn 0;\n}\n\nstatic const struct ethtool_ops netdev_ethtool_ops = {\n\t.nway_reset\t\t= netdev_nway_reset,\n\t.get_link\t\t= netdev_get_link,\n\t.get_drvinfo\t\t= netdev_get_drvinfo,\n\t.get_regs_len\t\t= netdev_get_regs_len,\n\t.get_regs\t\t= netdev_get_regs,\n\t.get_wol\t\t= netdev_get_wol,\n\t.set_wol\t\t= netdev_set_wol,\n\t.get_msglevel\t\t= netdev_get_msglevel,\n\t.set_msglevel\t\t= netdev_set_msglevel,\n\t.get_eeprom_len\t\t= netdev_get_eeprom_len,\n\t.get_eeprom\t\t= netdev_get_eeprom,\n\t.set_eeprom\t\t= netdev_set_eeprom,\n\t.get_pauseparam\t\t= netdev_get_pauseparam,\n\t.set_pauseparam\t\t= netdev_set_pauseparam,\n\t.get_ringparam\t\t= netdev_get_ringparam,\n\t.get_strings\t\t= netdev_get_strings,\n\t.get_sset_count\t\t= netdev_get_sset_count,\n\t.get_ethtool_stats\t= netdev_get_ethtool_stats,\n\t.get_link_ksettings\t= netdev_get_link_ksettings,\n\t.set_link_ksettings\t= netdev_set_link_ksettings,\n};\n\n \n\nstatic void update_link(struct net_device *dev, struct dev_priv *priv,\n\tstruct ksz_port *port)\n{\n\tif (priv->media_state != port->linked->state) {\n\t\tpriv->media_state = port->linked->state;\n\t\tif (netif_running(dev))\n\t\t\tset_media_state(dev, media_connected);\n\t}\n}\n\nstatic void mib_read_work(struct work_struct *work)\n{\n\tstruct dev_info *hw_priv =\n\t\tcontainer_of(work, struct dev_info, mib_read);\n\tstruct ksz_hw *hw = &hw_priv->hw;\n\tunsigned long next_jiffies;\n\tstruct ksz_port_mib *mib;\n\tint i;\n\n\tnext_jiffies = jiffies;\n\tfor (i = 0; i < hw->mib_port_cnt; i++) {\n\t\tmib = &hw->port_mib[i];\n\n\t\t \n\t\tif (mib->cnt_ptr || 1 == hw_priv->counter[i].read) {\n\n\t\t\t \n\t\t\tif (port_r_cnt(hw, i))\n\t\t\t\tbreak;\n\t\t\thw_priv->counter[i].read = 0;\n\n\t\t\t \n\t\t\tif (0 == mib->cnt_ptr) {\n\t\t\t\thw_priv->counter[i].read = 2;\n\t\t\t\twake_up_interruptible(\n\t\t\t\t\t&hw_priv->counter[i].counter);\n\t\t\t}\n\t\t} else if (time_after_eq(jiffies, hw_priv->counter[i].time)) {\n\t\t\t \n\t\t\tif (media_connected == mib->state)\n\t\t\t\thw_priv->counter[i].read = 1;\n\t\t\tnext_jiffies += HZ * 1 * hw->mib_port_cnt;\n\t\t\thw_priv->counter[i].time = next_jiffies;\n\n\t\t \n\t\t} else if (mib->link_down) {\n\t\t\tmib->link_down = 0;\n\n\t\t\t \n\t\t\thw_priv->counter[i].read = 1;\n\t\t}\n\t}\n}\n\nstatic void mib_monitor(struct timer_list *t)\n{\n\tstruct dev_info *hw_priv = from_timer(hw_priv, t, mib_timer_info.timer);\n\n\tmib_read_work(&hw_priv->mib_read);\n\n\t \n\tif (hw_priv->pme_wait) {\n\t\tif (time_is_before_eq_jiffies(hw_priv->pme_wait)) {\n\t\t\thw_clr_wol_pme_status(&hw_priv->hw);\n\t\t\thw_priv->pme_wait = 0;\n\t\t}\n\t} else if (hw_chk_wol_pme_status(&hw_priv->hw)) {\n\n\t\t \n\t\thw_priv->pme_wait = jiffies + HZ * 2;\n\t}\n\n\tksz_update_timer(&hw_priv->mib_timer_info);\n}\n\n \nstatic void dev_monitor(struct timer_list *t)\n{\n\tstruct dev_priv *priv = from_timer(priv, t, monitor_timer_info.timer);\n\tstruct net_device *dev = priv->mii_if.dev;\n\tstruct dev_info *hw_priv = priv->adapter;\n\tstruct ksz_hw *hw = &hw_priv->hw;\n\tstruct ksz_port *port = &priv->port;\n\n\tif (!(hw->features & LINK_INT_WORKING))\n\t\tport_get_link_speed(port);\n\tupdate_link(dev, priv, port);\n\n\tksz_update_timer(&priv->monitor_timer_info);\n}\n\n \n\n \n\nstatic int msg_enable;\n\nstatic char *macaddr = \":\";\nstatic char *mac1addr = \":\";\n\n \nstatic int multi_dev;\n\n \nstatic int stp;\n\n \nstatic int fast_aging;\n\n \nstatic int __init netdev_init(struct net_device *dev)\n{\n\tstruct dev_priv *priv = netdev_priv(dev);\n\n\t \n\tksz_init_timer(&priv->monitor_timer_info, 500 * HZ / 1000,\n\t\tdev_monitor);\n\n\t \n\tdev->watchdog_timeo = HZ / 2;\n\n\tdev->hw_features = NETIF_F_IP_CSUM | NETIF_F_SG | NETIF_F_RXCSUM;\n\n\t \n\tdev->hw_features |= NETIF_F_IPV6_CSUM;\n\n\tdev->features |= dev->hw_features;\n\n\tsema_init(&priv->proc_sem, 1);\n\n\tpriv->mii_if.phy_id_mask = 0x1;\n\tpriv->mii_if.reg_num_mask = 0x7;\n\tpriv->mii_if.dev = dev;\n\tpriv->mii_if.mdio_read = mdio_read;\n\tpriv->mii_if.mdio_write = mdio_write;\n\tpriv->mii_if.phy_id = priv->port.first_port + 1;\n\n\tpriv->msg_enable = netif_msg_init(msg_enable,\n\t\t(NETIF_MSG_DRV | NETIF_MSG_PROBE | NETIF_MSG_LINK));\n\n\treturn 0;\n}\n\nstatic const struct net_device_ops netdev_ops = {\n\t.ndo_init\t\t= netdev_init,\n\t.ndo_open\t\t= netdev_open,\n\t.ndo_stop\t\t= netdev_close,\n\t.ndo_get_stats\t\t= netdev_query_statistics,\n\t.ndo_start_xmit\t\t= netdev_tx,\n\t.ndo_tx_timeout\t\t= netdev_tx_timeout,\n\t.ndo_change_mtu\t\t= netdev_change_mtu,\n\t.ndo_set_features\t= netdev_set_features,\n\t.ndo_set_mac_address\t= netdev_set_mac_address,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_eth_ioctl\t\t= netdev_ioctl,\n\t.ndo_set_rx_mode\t= netdev_set_rx_mode,\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\t.ndo_poll_controller\t= netdev_netpoll,\n#endif\n};\n\nstatic void netdev_free(struct net_device *dev)\n{\n\tif (dev->watchdog_timeo)\n\t\tunregister_netdev(dev);\n\n\tfree_netdev(dev);\n}\n\nstruct platform_info {\n\tstruct dev_info dev_info;\n\tstruct net_device *netdev[SWITCH_PORT_NUM];\n};\n\nstatic int net_device_present;\n\nstatic void get_mac_addr(struct dev_info *hw_priv, u8 *macaddr, int port)\n{\n\tint i;\n\tint j;\n\tint got_num;\n\tint num;\n\n\ti = j = num = got_num = 0;\n\twhile (j < ETH_ALEN) {\n\t\tif (macaddr[i]) {\n\t\t\tint digit;\n\n\t\t\tgot_num = 1;\n\t\t\tdigit = hex_to_bin(macaddr[i]);\n\t\t\tif (digit >= 0)\n\t\t\t\tnum = num * 16 + digit;\n\t\t\telse if (':' == macaddr[i])\n\t\t\t\tgot_num = 2;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t} else if (got_num)\n\t\t\tgot_num = 2;\n\t\telse\n\t\t\tbreak;\n\t\tif (2 == got_num) {\n\t\t\tif (MAIN_PORT == port) {\n\t\t\t\thw_priv->hw.override_addr[j++] = (u8) num;\n\t\t\t\thw_priv->hw.override_addr[5] +=\n\t\t\t\t\thw_priv->hw.id;\n\t\t\t} else {\n\t\t\t\thw_priv->hw.ksz_switch->other_addr[j++] =\n\t\t\t\t\t(u8) num;\n\t\t\t\thw_priv->hw.ksz_switch->other_addr[5] +=\n\t\t\t\t\thw_priv->hw.id;\n\t\t\t}\n\t\t\tnum = got_num = 0;\n\t\t}\n\t\ti++;\n\t}\n\tif (ETH_ALEN == j) {\n\t\tif (MAIN_PORT == port)\n\t\t\thw_priv->hw.mac_override = 1;\n\t}\n}\n\n#define KS884X_DMA_MASK\t\t\t(~0x0UL)\n\nstatic void read_other_addr(struct ksz_hw *hw)\n{\n\tint i;\n\tu16 data[3];\n\tstruct ksz_switch *sw = hw->ksz_switch;\n\n\tfor (i = 0; i < 3; i++)\n\t\tdata[i] = eeprom_read(hw, i + EEPROM_DATA_OTHER_MAC_ADDR);\n\tif ((data[0] || data[1] || data[2]) && data[0] != 0xffff) {\n\t\tsw->other_addr[5] = (u8) data[0];\n\t\tsw->other_addr[4] = (u8)(data[0] >> 8);\n\t\tsw->other_addr[3] = (u8) data[1];\n\t\tsw->other_addr[2] = (u8)(data[1] >> 8);\n\t\tsw->other_addr[1] = (u8) data[2];\n\t\tsw->other_addr[0] = (u8)(data[2] >> 8);\n\t}\n}\n\n#ifndef PCI_VENDOR_ID_MICREL_KS\n#define PCI_VENDOR_ID_MICREL_KS\t\t0x16c6\n#endif\n\nstatic int pcidev_init(struct pci_dev *pdev, const struct pci_device_id *id)\n{\n\tstruct net_device *dev;\n\tstruct dev_priv *priv;\n\tstruct dev_info *hw_priv;\n\tstruct ksz_hw *hw;\n\tstruct platform_info *info;\n\tstruct ksz_port *port;\n\tunsigned long reg_base;\n\tunsigned long reg_len;\n\tint cnt;\n\tint i;\n\tint mib_port_count;\n\tint pi;\n\tint port_count;\n\tint result;\n\tchar banner[sizeof(version)];\n\tstruct ksz_switch *sw = NULL;\n\n\tresult = pcim_enable_device(pdev);\n\tif (result)\n\t\treturn result;\n\n\tresult = -ENODEV;\n\n\tif (dma_set_mask(&pdev->dev, DMA_BIT_MASK(32)) ||\n\t    dma_set_coherent_mask(&pdev->dev, DMA_BIT_MASK(32)))\n\t\treturn result;\n\n\treg_base = pci_resource_start(pdev, 0);\n\treg_len = pci_resource_len(pdev, 0);\n\tif ((pci_resource_flags(pdev, 0) & IORESOURCE_IO) != 0)\n\t\treturn result;\n\n\tif (!request_mem_region(reg_base, reg_len, DRV_NAME))\n\t\treturn result;\n\tpci_set_master(pdev);\n\n\tresult = -ENOMEM;\n\n\tinfo = kzalloc(sizeof(struct platform_info), GFP_KERNEL);\n\tif (!info)\n\t\tgoto pcidev_init_dev_err;\n\n\thw_priv = &info->dev_info;\n\thw_priv->pdev = pdev;\n\n\thw = &hw_priv->hw;\n\n\thw->io = ioremap(reg_base, reg_len);\n\tif (!hw->io)\n\t\tgoto pcidev_init_io_err;\n\n\tcnt = hw_init(hw);\n\tif (!cnt) {\n\t\tif (msg_enable & NETIF_MSG_PROBE)\n\t\t\tpr_alert(\"chip not detected\\n\");\n\t\tresult = -ENODEV;\n\t\tgoto pcidev_init_alloc_err;\n\t}\n\n\tsnprintf(banner, sizeof(banner), \"%s\", version);\n\tbanner[13] = cnt + '0';\t\t \n\tdev_info(&hw_priv->pdev->dev, \"%s\\n\", banner);\n\tdev_dbg(&hw_priv->pdev->dev, \"Mem = %p; IRQ = %d\\n\", hw->io, pdev->irq);\n\n\t \n\thw->dev_count = 1;\n\tport_count = 1;\n\tmib_port_count = 1;\n\thw->addr_list_size = 0;\n\thw->mib_cnt = PORT_COUNTER_NUM;\n\thw->mib_port_cnt = 1;\n\n\t \n\tif (2 == cnt) {\n\t\tif (fast_aging)\n\t\t\thw->overrides |= FAST_AGING;\n\n\t\thw->mib_cnt = TOTAL_PORT_COUNTER_NUM;\n\n\t\t \n\t\tif (multi_dev) {\n\t\t\thw->dev_count = SWITCH_PORT_NUM;\n\t\t\thw->addr_list_size = SWITCH_PORT_NUM - 1;\n\t\t}\n\n\t\t \n\t\tif (1 == hw->dev_count) {\n\t\t\tport_count = SWITCH_PORT_NUM;\n\t\t\tmib_port_count = SWITCH_PORT_NUM;\n\t\t}\n\t\thw->mib_port_cnt = TOTAL_PORT_NUM;\n\t\thw->ksz_switch = kzalloc(sizeof(struct ksz_switch), GFP_KERNEL);\n\t\tif (!hw->ksz_switch)\n\t\t\tgoto pcidev_init_alloc_err;\n\n\t\tsw = hw->ksz_switch;\n\t}\n\tfor (i = 0; i < hw->mib_port_cnt; i++)\n\t\thw->port_mib[i].mib_start = 0;\n\n\thw->parent = hw_priv;\n\n\t \n\thw_priv->mtu = (REGULAR_RX_BUF_SIZE + 3) & ~3;\n\n\tif (ksz_alloc_mem(hw_priv))\n\t\tgoto pcidev_init_mem_err;\n\n\thw_priv->hw.id = net_device_present;\n\n\tspin_lock_init(&hw_priv->hwlock);\n\tmutex_init(&hw_priv->lock);\n\n\tfor (i = 0; i < TOTAL_PORT_NUM; i++)\n\t\tinit_waitqueue_head(&hw_priv->counter[i].counter);\n\n\tif (macaddr[0] != ':')\n\t\tget_mac_addr(hw_priv, macaddr, MAIN_PORT);\n\n\t \n\thw_read_addr(hw);\n\n\t \n\tif (hw->dev_count > 1) {\n\t\tmemcpy(sw->other_addr, hw->override_addr, ETH_ALEN);\n\t\tread_other_addr(hw);\n\t\tif (mac1addr[0] != ':')\n\t\t\tget_mac_addr(hw_priv, mac1addr, OTHER_PORT);\n\t}\n\n\thw_setup(hw);\n\tif (hw->ksz_switch)\n\t\tsw_setup(hw);\n\telse {\n\t\thw_priv->wol_support = WOL_SUPPORT;\n\t\thw_priv->wol_enable = 0;\n\t}\n\n\tINIT_WORK(&hw_priv->mib_read, mib_read_work);\n\n\t \n\tksz_init_timer(&hw_priv->mib_timer_info, 500 * HZ / 1000,\n\t\tmib_monitor);\n\n\tfor (i = 0; i < hw->dev_count; i++) {\n\t\tdev = alloc_etherdev(sizeof(struct dev_priv));\n\t\tif (!dev)\n\t\t\tgoto pcidev_init_reg_err;\n\t\tSET_NETDEV_DEV(dev, &pdev->dev);\n\t\tinfo->netdev[i] = dev;\n\n\t\tpriv = netdev_priv(dev);\n\t\tpriv->adapter = hw_priv;\n\t\tpriv->id = net_device_present++;\n\n\t\tport = &priv->port;\n\t\tport->port_cnt = port_count;\n\t\tport->mib_port_cnt = mib_port_count;\n\t\tport->first_port = i;\n\t\tport->flow_ctrl = PHY_FLOW_CTRL;\n\n\t\tport->hw = hw;\n\t\tport->linked = &hw->port_info[port->first_port];\n\n\t\tfor (cnt = 0, pi = i; cnt < port_count; cnt++, pi++) {\n\t\t\thw->port_info[pi].port_id = pi;\n\t\t\thw->port_info[pi].pdev = dev;\n\t\t\thw->port_info[pi].state = media_disconnected;\n\t\t}\n\n\t\tdev->mem_start = (unsigned long) hw->io;\n\t\tdev->mem_end = dev->mem_start + reg_len - 1;\n\t\tdev->irq = pdev->irq;\n\t\tif (MAIN_PORT == i)\n\t\t\teth_hw_addr_set(dev, hw_priv->hw.override_addr);\n\t\telse {\n\t\t\tu8 addr[ETH_ALEN];\n\n\t\t\tether_addr_copy(addr, sw->other_addr);\n\t\t\tif (ether_addr_equal(sw->other_addr, hw->override_addr))\n\t\t\t\taddr[5] += port->first_port;\n\t\t\teth_hw_addr_set(dev, addr);\n\t\t}\n\n\t\tdev->netdev_ops = &netdev_ops;\n\t\tdev->ethtool_ops = &netdev_ethtool_ops;\n\n\t\t \n\t\tdev->min_mtu = ETH_ZLEN;\n\t\tdev->max_mtu = MAX_RX_BUF_SIZE -\n\t\t\t       (ETH_HLEN + ETH_FCS_LEN + VLAN_HLEN);\n\n\t\tif (register_netdev(dev))\n\t\t\tgoto pcidev_init_reg_err;\n\t\tport_set_power_saving(port, true);\n\t}\n\n\tpci_dev_get(hw_priv->pdev);\n\tpci_set_drvdata(pdev, info);\n\treturn 0;\n\npcidev_init_reg_err:\n\tfor (i = 0; i < hw->dev_count; i++) {\n\t\tif (info->netdev[i]) {\n\t\t\tnetdev_free(info->netdev[i]);\n\t\t\tinfo->netdev[i] = NULL;\n\t\t}\n\t}\n\npcidev_init_mem_err:\n\tksz_free_mem(hw_priv);\n\tkfree(hw->ksz_switch);\n\npcidev_init_alloc_err:\n\tiounmap(hw->io);\n\npcidev_init_io_err:\n\tkfree(info);\n\npcidev_init_dev_err:\n\trelease_mem_region(reg_base, reg_len);\n\n\treturn result;\n}\n\nstatic void pcidev_exit(struct pci_dev *pdev)\n{\n\tint i;\n\tstruct platform_info *info = pci_get_drvdata(pdev);\n\tstruct dev_info *hw_priv = &info->dev_info;\n\n\trelease_mem_region(pci_resource_start(pdev, 0),\n\t\tpci_resource_len(pdev, 0));\n\tfor (i = 0; i < hw_priv->hw.dev_count; i++) {\n\t\tif (info->netdev[i])\n\t\t\tnetdev_free(info->netdev[i]);\n\t}\n\tif (hw_priv->hw.io)\n\t\tiounmap(hw_priv->hw.io);\n\tksz_free_mem(hw_priv);\n\tkfree(hw_priv->hw.ksz_switch);\n\tpci_dev_put(hw_priv->pdev);\n\tkfree(info);\n}\n\nstatic int __maybe_unused pcidev_resume(struct device *dev_d)\n{\n\tint i;\n\tstruct platform_info *info = dev_get_drvdata(dev_d);\n\tstruct dev_info *hw_priv = &info->dev_info;\n\tstruct ksz_hw *hw = &hw_priv->hw;\n\n\tdevice_wakeup_disable(dev_d);\n\n\tif (hw_priv->wol_enable)\n\t\thw_cfg_wol_pme(hw, 0);\n\tfor (i = 0; i < hw->dev_count; i++) {\n\t\tif (info->netdev[i]) {\n\t\t\tstruct net_device *dev = info->netdev[i];\n\n\t\t\tif (netif_running(dev)) {\n\t\t\t\tnetdev_open(dev);\n\t\t\t\tnetif_device_attach(dev);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int __maybe_unused pcidev_suspend(struct device *dev_d)\n{\n\tint i;\n\tstruct platform_info *info = dev_get_drvdata(dev_d);\n\tstruct dev_info *hw_priv = &info->dev_info;\n\tstruct ksz_hw *hw = &hw_priv->hw;\n\n\t \n\tstatic const u8 net_addr[] = { 192, 168, 1, 1 };\n\n\tfor (i = 0; i < hw->dev_count; i++) {\n\t\tif (info->netdev[i]) {\n\t\t\tstruct net_device *dev = info->netdev[i];\n\n\t\t\tif (netif_running(dev)) {\n\t\t\t\tnetif_device_detach(dev);\n\t\t\t\tnetdev_close(dev);\n\t\t\t}\n\t\t}\n\t}\n\tif (hw_priv->wol_enable) {\n\t\thw_enable_wol(hw, hw_priv->wol_enable, net_addr);\n\t\thw_cfg_wol_pme(hw, 1);\n\t}\n\n\tdevice_wakeup_enable(dev_d);\n\treturn 0;\n}\n\nstatic char pcidev_name[] = \"ksz884xp\";\n\nstatic const struct pci_device_id pcidev_table[] = {\n\t{ PCI_VENDOR_ID_MICREL_KS, 0x8841,\n\t\tPCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },\n\t{ PCI_VENDOR_ID_MICREL_KS, 0x8842,\n\t\tPCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },\n\t{ 0 }\n};\n\nMODULE_DEVICE_TABLE(pci, pcidev_table);\n\nstatic SIMPLE_DEV_PM_OPS(pcidev_pm_ops, pcidev_suspend, pcidev_resume);\n\nstatic struct pci_driver pci_device_driver = {\n\t.driver.pm\t= &pcidev_pm_ops,\n\t.name\t\t= pcidev_name,\n\t.id_table\t= pcidev_table,\n\t.probe\t\t= pcidev_init,\n\t.remove\t\t= pcidev_exit\n};\n\nmodule_pci_driver(pci_device_driver);\n\nMODULE_DESCRIPTION(\"KSZ8841/2 PCI network driver\");\nMODULE_AUTHOR(\"Tristram Ha <Tristram.Ha@micrel.com>\");\nMODULE_LICENSE(\"GPL\");\n\nmodule_param_named(message, msg_enable, int, 0);\nMODULE_PARM_DESC(message, \"Message verbosity level (0=none, 31=all)\");\n\nmodule_param(macaddr, charp, 0);\nmodule_param(mac1addr, charp, 0);\nmodule_param(fast_aging, int, 0);\nmodule_param(multi_dev, int, 0);\nmodule_param(stp, int, 0);\nMODULE_PARM_DESC(macaddr, \"MAC address\");\nMODULE_PARM_DESC(mac1addr, \"Second MAC address\");\nMODULE_PARM_DESC(fast_aging, \"Fast aging\");\nMODULE_PARM_DESC(multi_dev, \"Multiple device interfaces\");\nMODULE_PARM_DESC(stp, \"STP support\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}