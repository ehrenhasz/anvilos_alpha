{
  "module_name": "ena_eth_com.c",
  "hash_id": "ff407416199e66b70693678953cc30cc7cc73797760983ea3cac677654e51dbe",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/amazon/ena/ena_eth_com.c",
  "human_readable_source": "\n \n\n#include \"ena_eth_com.h\"\n\nstatic struct ena_eth_io_rx_cdesc_base *ena_com_get_next_rx_cdesc(\n\tstruct ena_com_io_cq *io_cq)\n{\n\tstruct ena_eth_io_rx_cdesc_base *cdesc;\n\tu16 expected_phase, head_masked;\n\tu16 desc_phase;\n\n\thead_masked = io_cq->head & (io_cq->q_depth - 1);\n\texpected_phase = io_cq->phase;\n\n\tcdesc = (struct ena_eth_io_rx_cdesc_base *)(io_cq->cdesc_addr.virt_addr\n\t\t\t+ (head_masked * io_cq->cdesc_entry_size_in_bytes));\n\n\tdesc_phase = (READ_ONCE(cdesc->status) &\n\t\t      ENA_ETH_IO_RX_CDESC_BASE_PHASE_MASK) >>\n\t\t     ENA_ETH_IO_RX_CDESC_BASE_PHASE_SHIFT;\n\n\tif (desc_phase != expected_phase)\n\t\treturn NULL;\n\n\t \n\tdma_rmb();\n\n\treturn cdesc;\n}\n\nstatic void *get_sq_desc_regular_queue(struct ena_com_io_sq *io_sq)\n{\n\tu16 tail_masked;\n\tu32 offset;\n\n\ttail_masked = io_sq->tail & (io_sq->q_depth - 1);\n\n\toffset = tail_masked * io_sq->desc_entry_size;\n\n\treturn (void *)((uintptr_t)io_sq->desc_addr.virt_addr + offset);\n}\n\nstatic int ena_com_write_bounce_buffer_to_dev(struct ena_com_io_sq *io_sq,\n\t\t\t\t\t\t     u8 *bounce_buffer)\n{\n\tstruct ena_com_llq_info *llq_info = &io_sq->llq_info;\n\n\tu16 dst_tail_mask;\n\tu32 dst_offset;\n\n\tdst_tail_mask = io_sq->tail & (io_sq->q_depth - 1);\n\tdst_offset = dst_tail_mask * llq_info->desc_list_entry_size;\n\n\tif (is_llq_max_tx_burst_exists(io_sq)) {\n\t\tif (unlikely(!io_sq->entries_in_tx_burst_left)) {\n\t\t\tnetdev_err(ena_com_io_sq_to_ena_dev(io_sq)->net_device,\n\t\t\t\t   \"Error: trying to send more packets than tx burst allows\\n\");\n\t\t\treturn -ENOSPC;\n\t\t}\n\n\t\tio_sq->entries_in_tx_burst_left--;\n\t\tnetdev_dbg(ena_com_io_sq_to_ena_dev(io_sq)->net_device,\n\t\t\t   \"Decreasing entries_in_tx_burst_left of queue %d to %d\\n\",\n\t\t\t   io_sq->qid, io_sq->entries_in_tx_burst_left);\n\t}\n\n\t \n\twmb();\n\n\t \n\t__iowrite64_copy(io_sq->desc_addr.pbuf_dev_addr + dst_offset,\n\t\t\t bounce_buffer, (llq_info->desc_list_entry_size) / 8);\n\n\tio_sq->tail++;\n\n\t \n\tif (unlikely((io_sq->tail & (io_sq->q_depth - 1)) == 0))\n\t\tio_sq->phase ^= 1;\n\n\treturn 0;\n}\n\nstatic int ena_com_write_header_to_bounce(struct ena_com_io_sq *io_sq,\n\t\t\t\t\t\t u8 *header_src,\n\t\t\t\t\t\t u16 header_len)\n{\n\tstruct ena_com_llq_pkt_ctrl *pkt_ctrl = &io_sq->llq_buf_ctrl;\n\tstruct ena_com_llq_info *llq_info = &io_sq->llq_info;\n\tu8 *bounce_buffer = pkt_ctrl->curr_bounce_buf;\n\tu16 header_offset;\n\n\tif (unlikely(io_sq->mem_queue_type == ENA_ADMIN_PLACEMENT_POLICY_HOST))\n\t\treturn 0;\n\n\theader_offset =\n\t\tllq_info->descs_num_before_header * io_sq->desc_entry_size;\n\n\tif (unlikely((header_offset + header_len) >\n\t\t     llq_info->desc_list_entry_size)) {\n\t\tnetdev_err(ena_com_io_sq_to_ena_dev(io_sq)->net_device,\n\t\t\t   \"Trying to write header larger than llq entry can accommodate\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\tif (unlikely(!bounce_buffer)) {\n\t\tnetdev_err(ena_com_io_sq_to_ena_dev(io_sq)->net_device,\n\t\t\t   \"Bounce buffer is NULL\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\tmemcpy(bounce_buffer + header_offset, header_src, header_len);\n\n\treturn 0;\n}\n\nstatic void *get_sq_desc_llq(struct ena_com_io_sq *io_sq)\n{\n\tstruct ena_com_llq_pkt_ctrl *pkt_ctrl = &io_sq->llq_buf_ctrl;\n\tu8 *bounce_buffer;\n\tvoid *sq_desc;\n\n\tbounce_buffer = pkt_ctrl->curr_bounce_buf;\n\n\tif (unlikely(!bounce_buffer)) {\n\t\tnetdev_err(ena_com_io_sq_to_ena_dev(io_sq)->net_device,\n\t\t\t   \"Bounce buffer is NULL\\n\");\n\t\treturn NULL;\n\t}\n\n\tsq_desc = bounce_buffer + pkt_ctrl->idx * io_sq->desc_entry_size;\n\tpkt_ctrl->idx++;\n\tpkt_ctrl->descs_left_in_line--;\n\n\treturn sq_desc;\n}\n\nstatic int ena_com_close_bounce_buffer(struct ena_com_io_sq *io_sq)\n{\n\tstruct ena_com_llq_pkt_ctrl *pkt_ctrl = &io_sq->llq_buf_ctrl;\n\tstruct ena_com_llq_info *llq_info = &io_sq->llq_info;\n\tint rc;\n\n\tif (unlikely(io_sq->mem_queue_type == ENA_ADMIN_PLACEMENT_POLICY_HOST))\n\t\treturn 0;\n\n\t \n\tif (likely(pkt_ctrl->idx)) {\n\t\trc = ena_com_write_bounce_buffer_to_dev(io_sq,\n\t\t\t\t\t\t\tpkt_ctrl->curr_bounce_buf);\n\t\tif (unlikely(rc)) {\n\t\t\tnetdev_err(ena_com_io_sq_to_ena_dev(io_sq)->net_device,\n\t\t\t\t   \"Failed to write bounce buffer to device\\n\");\n\t\t\treturn rc;\n\t\t}\n\n\t\tpkt_ctrl->curr_bounce_buf =\n\t\t\tena_com_get_next_bounce_buffer(&io_sq->bounce_buf_ctrl);\n\t\tmemset(io_sq->llq_buf_ctrl.curr_bounce_buf,\n\t\t       0x0, llq_info->desc_list_entry_size);\n\t}\n\n\tpkt_ctrl->idx = 0;\n\tpkt_ctrl->descs_left_in_line = llq_info->descs_num_before_header;\n\treturn 0;\n}\n\nstatic void *get_sq_desc(struct ena_com_io_sq *io_sq)\n{\n\tif (io_sq->mem_queue_type == ENA_ADMIN_PLACEMENT_POLICY_DEV)\n\t\treturn get_sq_desc_llq(io_sq);\n\n\treturn get_sq_desc_regular_queue(io_sq);\n}\n\nstatic int ena_com_sq_update_llq_tail(struct ena_com_io_sq *io_sq)\n{\n\tstruct ena_com_llq_pkt_ctrl *pkt_ctrl = &io_sq->llq_buf_ctrl;\n\tstruct ena_com_llq_info *llq_info = &io_sq->llq_info;\n\tint rc;\n\n\tif (!pkt_ctrl->descs_left_in_line) {\n\t\trc = ena_com_write_bounce_buffer_to_dev(io_sq,\n\t\t\t\t\t\t\tpkt_ctrl->curr_bounce_buf);\n\t\tif (unlikely(rc)) {\n\t\t\tnetdev_err(ena_com_io_sq_to_ena_dev(io_sq)->net_device,\n\t\t\t\t   \"Failed to write bounce buffer to device\\n\");\n\t\t\treturn rc;\n\t\t}\n\n\t\tpkt_ctrl->curr_bounce_buf =\n\t\t\tena_com_get_next_bounce_buffer(&io_sq->bounce_buf_ctrl);\n\t\tmemset(io_sq->llq_buf_ctrl.curr_bounce_buf,\n\t\t       0x0, llq_info->desc_list_entry_size);\n\n\t\tpkt_ctrl->idx = 0;\n\t\tif (unlikely(llq_info->desc_stride_ctrl == ENA_ADMIN_SINGLE_DESC_PER_ENTRY))\n\t\t\tpkt_ctrl->descs_left_in_line = 1;\n\t\telse\n\t\t\tpkt_ctrl->descs_left_in_line =\n\t\t\tllq_info->desc_list_entry_size / io_sq->desc_entry_size;\n\t}\n\n\treturn 0;\n}\n\nstatic int ena_com_sq_update_tail(struct ena_com_io_sq *io_sq)\n{\n\tif (io_sq->mem_queue_type == ENA_ADMIN_PLACEMENT_POLICY_DEV)\n\t\treturn ena_com_sq_update_llq_tail(io_sq);\n\n\tio_sq->tail++;\n\n\t \n\tif (unlikely((io_sq->tail & (io_sq->q_depth - 1)) == 0))\n\t\tio_sq->phase ^= 1;\n\n\treturn 0;\n}\n\nstatic struct ena_eth_io_rx_cdesc_base *\n\tena_com_rx_cdesc_idx_to_ptr(struct ena_com_io_cq *io_cq, u16 idx)\n{\n\tidx &= (io_cq->q_depth - 1);\n\treturn (struct ena_eth_io_rx_cdesc_base *)\n\t\t((uintptr_t)io_cq->cdesc_addr.virt_addr +\n\t\tidx * io_cq->cdesc_entry_size_in_bytes);\n}\n\nstatic u16 ena_com_cdesc_rx_pkt_get(struct ena_com_io_cq *io_cq,\n\t\t\t\t\t   u16 *first_cdesc_idx)\n{\n\tstruct ena_eth_io_rx_cdesc_base *cdesc;\n\tu16 count = 0, head_masked;\n\tu32 last = 0;\n\n\tdo {\n\t\tcdesc = ena_com_get_next_rx_cdesc(io_cq);\n\t\tif (!cdesc)\n\t\t\tbreak;\n\n\t\tena_com_cq_inc_head(io_cq);\n\t\tcount++;\n\t\tlast = (READ_ONCE(cdesc->status) &\n\t\t\tENA_ETH_IO_RX_CDESC_BASE_LAST_MASK) >>\n\t\t       ENA_ETH_IO_RX_CDESC_BASE_LAST_SHIFT;\n\t} while (!last);\n\n\tif (last) {\n\t\t*first_cdesc_idx = io_cq->cur_rx_pkt_cdesc_start_idx;\n\t\tcount += io_cq->cur_rx_pkt_cdesc_count;\n\n\t\thead_masked = io_cq->head & (io_cq->q_depth - 1);\n\n\t\tio_cq->cur_rx_pkt_cdesc_count = 0;\n\t\tio_cq->cur_rx_pkt_cdesc_start_idx = head_masked;\n\n\t\tnetdev_dbg(ena_com_io_cq_to_ena_dev(io_cq)->net_device,\n\t\t\t   \"ENA q_id: %d packets were completed. first desc idx %u descs# %d\\n\",\n\t\t\t   io_cq->qid, *first_cdesc_idx, count);\n\t} else {\n\t\tio_cq->cur_rx_pkt_cdesc_count += count;\n\t\tcount = 0;\n\t}\n\n\treturn count;\n}\n\nstatic int ena_com_create_meta(struct ena_com_io_sq *io_sq,\n\t\t\t       struct ena_com_tx_meta *ena_meta)\n{\n\tstruct ena_eth_io_tx_meta_desc *meta_desc = NULL;\n\n\tmeta_desc = get_sq_desc(io_sq);\n\tif (unlikely(!meta_desc))\n\t\treturn -EFAULT;\n\n\tmemset(meta_desc, 0x0, sizeof(struct ena_eth_io_tx_meta_desc));\n\n\tmeta_desc->len_ctrl |= ENA_ETH_IO_TX_META_DESC_META_DESC_MASK;\n\n\tmeta_desc->len_ctrl |= ENA_ETH_IO_TX_META_DESC_EXT_VALID_MASK;\n\n\t \n\tmeta_desc->word2 |= ((u32)ena_meta->mss <<\n\t\tENA_ETH_IO_TX_META_DESC_MSS_LO_SHIFT) &\n\t\tENA_ETH_IO_TX_META_DESC_MSS_LO_MASK;\n\t \n\tmeta_desc->len_ctrl |= ((ena_meta->mss >> 10) <<\n\t\tENA_ETH_IO_TX_META_DESC_MSS_HI_SHIFT) &\n\t\tENA_ETH_IO_TX_META_DESC_MSS_HI_MASK;\n\n\t \n\tmeta_desc->len_ctrl |= ENA_ETH_IO_TX_META_DESC_ETH_META_TYPE_MASK;\n\tmeta_desc->len_ctrl |= ((u32)io_sq->phase <<\n\t\tENA_ETH_IO_TX_META_DESC_PHASE_SHIFT) &\n\t\tENA_ETH_IO_TX_META_DESC_PHASE_MASK;\n\n\tmeta_desc->len_ctrl |= ENA_ETH_IO_TX_META_DESC_FIRST_MASK;\n\tmeta_desc->len_ctrl |= ENA_ETH_IO_TX_META_DESC_META_STORE_MASK;\n\n\tmeta_desc->word2 |= ena_meta->l3_hdr_len &\n\t\tENA_ETH_IO_TX_META_DESC_L3_HDR_LEN_MASK;\n\tmeta_desc->word2 |= (ena_meta->l3_hdr_offset <<\n\t\tENA_ETH_IO_TX_META_DESC_L3_HDR_OFF_SHIFT) &\n\t\tENA_ETH_IO_TX_META_DESC_L3_HDR_OFF_MASK;\n\n\tmeta_desc->word2 |= ((u32)ena_meta->l4_hdr_len <<\n\t\tENA_ETH_IO_TX_META_DESC_L4_HDR_LEN_IN_WORDS_SHIFT) &\n\t\tENA_ETH_IO_TX_META_DESC_L4_HDR_LEN_IN_WORDS_MASK;\n\n\treturn ena_com_sq_update_tail(io_sq);\n}\n\nstatic int ena_com_create_and_store_tx_meta_desc(struct ena_com_io_sq *io_sq,\n\t\t\t\t\t\t struct ena_com_tx_ctx *ena_tx_ctx,\n\t\t\t\t\t\t bool *have_meta)\n{\n\tstruct ena_com_tx_meta *ena_meta = &ena_tx_ctx->ena_meta;\n\n\t \n\tif (io_sq->disable_meta_caching) {\n\t\t*have_meta = true;\n\t\treturn ena_com_create_meta(io_sq, ena_meta);\n\t}\n\n\tif (ena_com_meta_desc_changed(io_sq, ena_tx_ctx)) {\n\t\t*have_meta = true;\n\t\t \n\t\tmemcpy(&io_sq->cached_tx_meta, ena_meta,\n\t\t       sizeof(struct ena_com_tx_meta));\n\t\treturn ena_com_create_meta(io_sq, ena_meta);\n\t}\n\n\t*have_meta = false;\n\treturn 0;\n}\n\nstatic void ena_com_rx_set_flags(struct ena_com_io_cq *io_cq,\n\t\t\t\t struct ena_com_rx_ctx *ena_rx_ctx,\n\t\t\t\t struct ena_eth_io_rx_cdesc_base *cdesc)\n{\n\tena_rx_ctx->l3_proto = cdesc->status &\n\t\tENA_ETH_IO_RX_CDESC_BASE_L3_PROTO_IDX_MASK;\n\tena_rx_ctx->l4_proto =\n\t\t(cdesc->status & ENA_ETH_IO_RX_CDESC_BASE_L4_PROTO_IDX_MASK) >>\n\t\tENA_ETH_IO_RX_CDESC_BASE_L4_PROTO_IDX_SHIFT;\n\tena_rx_ctx->l3_csum_err =\n\t\t!!((cdesc->status & ENA_ETH_IO_RX_CDESC_BASE_L3_CSUM_ERR_MASK) >>\n\t\tENA_ETH_IO_RX_CDESC_BASE_L3_CSUM_ERR_SHIFT);\n\tena_rx_ctx->l4_csum_err =\n\t\t!!((cdesc->status & ENA_ETH_IO_RX_CDESC_BASE_L4_CSUM_ERR_MASK) >>\n\t\tENA_ETH_IO_RX_CDESC_BASE_L4_CSUM_ERR_SHIFT);\n\tena_rx_ctx->l4_csum_checked =\n\t\t!!((cdesc->status & ENA_ETH_IO_RX_CDESC_BASE_L4_CSUM_CHECKED_MASK) >>\n\t\tENA_ETH_IO_RX_CDESC_BASE_L4_CSUM_CHECKED_SHIFT);\n\tena_rx_ctx->hash = cdesc->hash;\n\tena_rx_ctx->frag =\n\t\t(cdesc->status & ENA_ETH_IO_RX_CDESC_BASE_IPV4_FRAG_MASK) >>\n\t\tENA_ETH_IO_RX_CDESC_BASE_IPV4_FRAG_SHIFT;\n\n\tnetdev_dbg(ena_com_io_cq_to_ena_dev(io_cq)->net_device,\n\t\t   \"l3_proto %d l4_proto %d l3_csum_err %d l4_csum_err %d hash %d frag %d cdesc_status %x\\n\",\n\t\t   ena_rx_ctx->l3_proto, ena_rx_ctx->l4_proto,\n\t\t   ena_rx_ctx->l3_csum_err, ena_rx_ctx->l4_csum_err,\n\t\t   ena_rx_ctx->hash, ena_rx_ctx->frag, cdesc->status);\n}\n\n \n \n \n\nint ena_com_prepare_tx(struct ena_com_io_sq *io_sq,\n\t\t       struct ena_com_tx_ctx *ena_tx_ctx,\n\t\t       int *nb_hw_desc)\n{\n\tstruct ena_eth_io_tx_desc *desc = NULL;\n\tstruct ena_com_buf *ena_bufs = ena_tx_ctx->ena_bufs;\n\tvoid *buffer_to_push = ena_tx_ctx->push_header;\n\tu16 header_len = ena_tx_ctx->header_len;\n\tu16 num_bufs = ena_tx_ctx->num_bufs;\n\tu16 start_tail = io_sq->tail;\n\tint i, rc;\n\tbool have_meta;\n\tu64 addr_hi;\n\n\tWARN(io_sq->direction != ENA_COM_IO_QUEUE_DIRECTION_TX, \"wrong Q type\");\n\n\t \n\tif (unlikely(!ena_com_sq_have_enough_space(io_sq, num_bufs + 1))) {\n\t\tnetdev_dbg(ena_com_io_sq_to_ena_dev(io_sq)->net_device,\n\t\t\t   \"Not enough space in the tx queue\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tif (unlikely(header_len > io_sq->tx_max_header_size)) {\n\t\tnetdev_err(ena_com_io_sq_to_ena_dev(io_sq)->net_device,\n\t\t\t   \"Header size is too large %d max header: %d\\n\",\n\t\t\t   header_len, io_sq->tx_max_header_size);\n\t\treturn -EINVAL;\n\t}\n\n\tif (unlikely(io_sq->mem_queue_type == ENA_ADMIN_PLACEMENT_POLICY_DEV &&\n\t\t     !buffer_to_push)) {\n\t\tnetdev_err(ena_com_io_sq_to_ena_dev(io_sq)->net_device,\n\t\t\t   \"Push header wasn't provided in LLQ mode\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\trc = ena_com_write_header_to_bounce(io_sq, buffer_to_push, header_len);\n\tif (unlikely(rc))\n\t\treturn rc;\n\n\trc = ena_com_create_and_store_tx_meta_desc(io_sq, ena_tx_ctx, &have_meta);\n\tif (unlikely(rc)) {\n\t\tnetdev_err(ena_com_io_sq_to_ena_dev(io_sq)->net_device,\n\t\t\t   \"Failed to create and store tx meta desc\\n\");\n\t\treturn rc;\n\t}\n\n\t \n\tif (unlikely(!num_bufs && !header_len)) {\n\t\trc = ena_com_close_bounce_buffer(io_sq);\n\t\tif (rc)\n\t\t\tnetdev_err(ena_com_io_sq_to_ena_dev(io_sq)->net_device,\n\t\t\t\t   \"Failed to write buffers to LLQ\\n\");\n\t\t*nb_hw_desc = io_sq->tail - start_tail;\n\t\treturn rc;\n\t}\n\n\tdesc = get_sq_desc(io_sq);\n\tif (unlikely(!desc))\n\t\treturn -EFAULT;\n\tmemset(desc, 0x0, sizeof(struct ena_eth_io_tx_desc));\n\n\t \n\tif (!have_meta)\n\t\tdesc->len_ctrl |= ENA_ETH_IO_TX_DESC_FIRST_MASK;\n\n\tdesc->buff_addr_hi_hdr_sz |= ((u32)header_len <<\n\t\tENA_ETH_IO_TX_DESC_HEADER_LENGTH_SHIFT) &\n\t\tENA_ETH_IO_TX_DESC_HEADER_LENGTH_MASK;\n\tdesc->len_ctrl |= ((u32)io_sq->phase << ENA_ETH_IO_TX_DESC_PHASE_SHIFT) &\n\t\tENA_ETH_IO_TX_DESC_PHASE_MASK;\n\n\tdesc->len_ctrl |= ENA_ETH_IO_TX_DESC_COMP_REQ_MASK;\n\n\t \n\tdesc->meta_ctrl |= ((u32)ena_tx_ctx->req_id <<\n\t\tENA_ETH_IO_TX_DESC_REQ_ID_LO_SHIFT) &\n\t\tENA_ETH_IO_TX_DESC_REQ_ID_LO_MASK;\n\n\tdesc->meta_ctrl |= (ena_tx_ctx->df <<\n\t\tENA_ETH_IO_TX_DESC_DF_SHIFT) &\n\t\tENA_ETH_IO_TX_DESC_DF_MASK;\n\n\t \n\tdesc->len_ctrl |= ((ena_tx_ctx->req_id >> 10) <<\n\t\tENA_ETH_IO_TX_DESC_REQ_ID_HI_SHIFT) &\n\t\tENA_ETH_IO_TX_DESC_REQ_ID_HI_MASK;\n\n\tif (ena_tx_ctx->meta_valid) {\n\t\tdesc->meta_ctrl |= (ena_tx_ctx->tso_enable <<\n\t\t\tENA_ETH_IO_TX_DESC_TSO_EN_SHIFT) &\n\t\t\tENA_ETH_IO_TX_DESC_TSO_EN_MASK;\n\t\tdesc->meta_ctrl |= ena_tx_ctx->l3_proto &\n\t\t\tENA_ETH_IO_TX_DESC_L3_PROTO_IDX_MASK;\n\t\tdesc->meta_ctrl |= (ena_tx_ctx->l4_proto <<\n\t\t\tENA_ETH_IO_TX_DESC_L4_PROTO_IDX_SHIFT) &\n\t\t\tENA_ETH_IO_TX_DESC_L4_PROTO_IDX_MASK;\n\t\tdesc->meta_ctrl |= (ena_tx_ctx->l3_csum_enable <<\n\t\t\tENA_ETH_IO_TX_DESC_L3_CSUM_EN_SHIFT) &\n\t\t\tENA_ETH_IO_TX_DESC_L3_CSUM_EN_MASK;\n\t\tdesc->meta_ctrl |= (ena_tx_ctx->l4_csum_enable <<\n\t\t\tENA_ETH_IO_TX_DESC_L4_CSUM_EN_SHIFT) &\n\t\t\tENA_ETH_IO_TX_DESC_L4_CSUM_EN_MASK;\n\t\tdesc->meta_ctrl |= (ena_tx_ctx->l4_csum_partial <<\n\t\t\tENA_ETH_IO_TX_DESC_L4_CSUM_PARTIAL_SHIFT) &\n\t\t\tENA_ETH_IO_TX_DESC_L4_CSUM_PARTIAL_MASK;\n\t}\n\n\tfor (i = 0; i < num_bufs; i++) {\n\t\t \n\t\tif (likely(i != 0)) {\n\t\t\trc = ena_com_sq_update_tail(io_sq);\n\t\t\tif (unlikely(rc)) {\n\t\t\t\tnetdev_err(ena_com_io_sq_to_ena_dev(io_sq)->net_device,\n\t\t\t\t\t   \"Failed to update sq tail\\n\");\n\t\t\t\treturn rc;\n\t\t\t}\n\n\t\t\tdesc = get_sq_desc(io_sq);\n\t\t\tif (unlikely(!desc))\n\t\t\t\treturn -EFAULT;\n\n\t\t\tmemset(desc, 0x0, sizeof(struct ena_eth_io_tx_desc));\n\n\t\t\tdesc->len_ctrl |= ((u32)io_sq->phase <<\n\t\t\t\tENA_ETH_IO_TX_DESC_PHASE_SHIFT) &\n\t\t\t\tENA_ETH_IO_TX_DESC_PHASE_MASK;\n\t\t}\n\n\t\tdesc->len_ctrl |= ena_bufs->len &\n\t\t\tENA_ETH_IO_TX_DESC_LENGTH_MASK;\n\n\t\taddr_hi = ((ena_bufs->paddr &\n\t\t\tGENMASK_ULL(io_sq->dma_addr_bits - 1, 32)) >> 32);\n\n\t\tdesc->buff_addr_lo = (u32)ena_bufs->paddr;\n\t\tdesc->buff_addr_hi_hdr_sz |= addr_hi &\n\t\t\tENA_ETH_IO_TX_DESC_ADDR_HI_MASK;\n\t\tena_bufs++;\n\t}\n\n\t \n\tdesc->len_ctrl |= ENA_ETH_IO_TX_DESC_LAST_MASK;\n\n\trc = ena_com_sq_update_tail(io_sq);\n\tif (unlikely(rc)) {\n\t\tnetdev_err(ena_com_io_sq_to_ena_dev(io_sq)->net_device,\n\t\t\t   \"Failed to update sq tail of the last descriptor\\n\");\n\t\treturn rc;\n\t}\n\n\trc = ena_com_close_bounce_buffer(io_sq);\n\n\t*nb_hw_desc = io_sq->tail - start_tail;\n\treturn rc;\n}\n\nint ena_com_rx_pkt(struct ena_com_io_cq *io_cq,\n\t\t   struct ena_com_io_sq *io_sq,\n\t\t   struct ena_com_rx_ctx *ena_rx_ctx)\n{\n\tstruct ena_com_rx_buf_info *ena_buf = &ena_rx_ctx->ena_bufs[0];\n\tstruct ena_eth_io_rx_cdesc_base *cdesc = NULL;\n\tu16 q_depth = io_cq->q_depth;\n\tu16 cdesc_idx = 0;\n\tu16 nb_hw_desc;\n\tu16 i = 0;\n\n\tWARN(io_cq->direction != ENA_COM_IO_QUEUE_DIRECTION_RX, \"wrong Q type\");\n\n\tnb_hw_desc = ena_com_cdesc_rx_pkt_get(io_cq, &cdesc_idx);\n\tif (nb_hw_desc == 0) {\n\t\tena_rx_ctx->descs = nb_hw_desc;\n\t\treturn 0;\n\t}\n\n\tnetdev_dbg(ena_com_io_cq_to_ena_dev(io_cq)->net_device,\n\t\t   \"Fetch rx packet: queue %d completed desc: %d\\n\", io_cq->qid,\n\t\t   nb_hw_desc);\n\n\tif (unlikely(nb_hw_desc > ena_rx_ctx->max_bufs)) {\n\t\tnetdev_err(ena_com_io_cq_to_ena_dev(io_cq)->net_device,\n\t\t\t   \"Too many RX cdescs (%d) > MAX(%d)\\n\", nb_hw_desc,\n\t\t\t   ena_rx_ctx->max_bufs);\n\t\treturn -ENOSPC;\n\t}\n\n\tcdesc = ena_com_rx_cdesc_idx_to_ptr(io_cq, cdesc_idx);\n\tena_rx_ctx->pkt_offset = cdesc->offset;\n\n\tdo {\n\t\tena_buf[i].len = cdesc->length;\n\t\tena_buf[i].req_id = cdesc->req_id;\n\t\tif (unlikely(ena_buf[i].req_id >= q_depth))\n\t\t\treturn -EIO;\n\n\t\tif (++i >= nb_hw_desc)\n\t\t\tbreak;\n\n\t\tcdesc = ena_com_rx_cdesc_idx_to_ptr(io_cq, cdesc_idx + i);\n\n\t} while (1);\n\n\t \n\tio_sq->next_to_comp += nb_hw_desc;\n\n\tnetdev_dbg(ena_com_io_cq_to_ena_dev(io_cq)->net_device,\n\t\t   \"[%s][QID#%d] Updating SQ head to: %d\\n\", __func__,\n\t\t   io_sq->qid, io_sq->next_to_comp);\n\n\t \n\tena_com_rx_set_flags(io_cq, ena_rx_ctx, cdesc);\n\n\tena_rx_ctx->descs = nb_hw_desc;\n\n\treturn 0;\n}\n\nint ena_com_add_single_rx_desc(struct ena_com_io_sq *io_sq,\n\t\t\t       struct ena_com_buf *ena_buf,\n\t\t\t       u16 req_id)\n{\n\tstruct ena_eth_io_rx_desc *desc;\n\n\tWARN(io_sq->direction != ENA_COM_IO_QUEUE_DIRECTION_RX, \"wrong Q type\");\n\n\tif (unlikely(!ena_com_sq_have_enough_space(io_sq, 1)))\n\t\treturn -ENOSPC;\n\n\tdesc = get_sq_desc(io_sq);\n\tif (unlikely(!desc))\n\t\treturn -EFAULT;\n\n\tmemset(desc, 0x0, sizeof(struct ena_eth_io_rx_desc));\n\n\tdesc->length = ena_buf->len;\n\n\tdesc->ctrl = ENA_ETH_IO_RX_DESC_FIRST_MASK |\n\t\t     ENA_ETH_IO_RX_DESC_LAST_MASK |\n\t\t     ENA_ETH_IO_RX_DESC_COMP_REQ_MASK |\n\t\t     (io_sq->phase & ENA_ETH_IO_RX_DESC_PHASE_MASK);\n\n\tdesc->req_id = req_id;\n\n\tnetdev_dbg(ena_com_io_sq_to_ena_dev(io_sq)->net_device,\n\t\t   \"[%s] Adding single RX desc, Queue: %u, req_id: %u\\n\",\n\t\t   __func__, io_sq->qid, req_id);\n\n\tdesc->buff_addr_lo = (u32)ena_buf->paddr;\n\tdesc->buff_addr_hi =\n\t\t((ena_buf->paddr & GENMASK_ULL(io_sq->dma_addr_bits - 1, 32)) >> 32);\n\n\treturn ena_com_sq_update_tail(io_sq);\n}\n\nbool ena_com_cq_empty(struct ena_com_io_cq *io_cq)\n{\n\tstruct ena_eth_io_rx_cdesc_base *cdesc;\n\n\tcdesc = ena_com_get_next_rx_cdesc(io_cq);\n\tif (cdesc)\n\t\treturn false;\n\telse\n\t\treturn true;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}