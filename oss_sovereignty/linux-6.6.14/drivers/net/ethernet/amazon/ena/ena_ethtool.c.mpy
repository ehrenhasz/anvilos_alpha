{
  "module_name": "ena_ethtool.c",
  "hash_id": "676da431206bf29f0f879293bb3aefce8b67aa451d2ada5aedb95a60458afc11",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/amazon/ena/ena_ethtool.c",
  "human_readable_source": "\n \n\n#include <linux/ethtool.h>\n#include <linux/pci.h>\n\n#include \"ena_netdev.h\"\n\nstruct ena_stats {\n\tchar name[ETH_GSTRING_LEN];\n\tint stat_offset;\n};\n\n#define ENA_STAT_ENA_COM_ENTRY(stat) { \\\n\t.name = #stat, \\\n\t.stat_offset = offsetof(struct ena_com_stats_admin, stat) / sizeof(u64) \\\n}\n\n#define ENA_STAT_ENTRY(stat, stat_type) { \\\n\t.name = #stat, \\\n\t.stat_offset = offsetof(struct ena_stats_##stat_type, stat) / sizeof(u64) \\\n}\n\n#define ENA_STAT_HW_ENTRY(stat, stat_type) { \\\n\t.name = #stat, \\\n\t.stat_offset = offsetof(struct ena_admin_##stat_type, stat) / sizeof(u64) \\\n}\n\n#define ENA_STAT_RX_ENTRY(stat) \\\n\tENA_STAT_ENTRY(stat, rx)\n\n#define ENA_STAT_TX_ENTRY(stat) \\\n\tENA_STAT_ENTRY(stat, tx)\n\n#define ENA_STAT_GLOBAL_ENTRY(stat) \\\n\tENA_STAT_ENTRY(stat, dev)\n\n#define ENA_STAT_ENI_ENTRY(stat) \\\n\tENA_STAT_HW_ENTRY(stat, eni_stats)\n\nstatic const struct ena_stats ena_stats_global_strings[] = {\n\tENA_STAT_GLOBAL_ENTRY(tx_timeout),\n\tENA_STAT_GLOBAL_ENTRY(suspend),\n\tENA_STAT_GLOBAL_ENTRY(resume),\n\tENA_STAT_GLOBAL_ENTRY(wd_expired),\n\tENA_STAT_GLOBAL_ENTRY(interface_up),\n\tENA_STAT_GLOBAL_ENTRY(interface_down),\n\tENA_STAT_GLOBAL_ENTRY(admin_q_pause),\n};\n\nstatic const struct ena_stats ena_stats_eni_strings[] = {\n\tENA_STAT_ENI_ENTRY(bw_in_allowance_exceeded),\n\tENA_STAT_ENI_ENTRY(bw_out_allowance_exceeded),\n\tENA_STAT_ENI_ENTRY(pps_allowance_exceeded),\n\tENA_STAT_ENI_ENTRY(conntrack_allowance_exceeded),\n\tENA_STAT_ENI_ENTRY(linklocal_allowance_exceeded),\n};\n\nstatic const struct ena_stats ena_stats_tx_strings[] = {\n\tENA_STAT_TX_ENTRY(cnt),\n\tENA_STAT_TX_ENTRY(bytes),\n\tENA_STAT_TX_ENTRY(queue_stop),\n\tENA_STAT_TX_ENTRY(queue_wakeup),\n\tENA_STAT_TX_ENTRY(dma_mapping_err),\n\tENA_STAT_TX_ENTRY(linearize),\n\tENA_STAT_TX_ENTRY(linearize_failed),\n\tENA_STAT_TX_ENTRY(napi_comp),\n\tENA_STAT_TX_ENTRY(tx_poll),\n\tENA_STAT_TX_ENTRY(doorbells),\n\tENA_STAT_TX_ENTRY(prepare_ctx_err),\n\tENA_STAT_TX_ENTRY(bad_req_id),\n\tENA_STAT_TX_ENTRY(llq_buffer_copy),\n\tENA_STAT_TX_ENTRY(missed_tx),\n\tENA_STAT_TX_ENTRY(unmask_interrupt),\n};\n\nstatic const struct ena_stats ena_stats_rx_strings[] = {\n\tENA_STAT_RX_ENTRY(cnt),\n\tENA_STAT_RX_ENTRY(bytes),\n\tENA_STAT_RX_ENTRY(rx_copybreak_pkt),\n\tENA_STAT_RX_ENTRY(csum_good),\n\tENA_STAT_RX_ENTRY(refil_partial),\n\tENA_STAT_RX_ENTRY(csum_bad),\n\tENA_STAT_RX_ENTRY(page_alloc_fail),\n\tENA_STAT_RX_ENTRY(skb_alloc_fail),\n\tENA_STAT_RX_ENTRY(dma_mapping_err),\n\tENA_STAT_RX_ENTRY(bad_desc_num),\n\tENA_STAT_RX_ENTRY(bad_req_id),\n\tENA_STAT_RX_ENTRY(empty_rx_ring),\n\tENA_STAT_RX_ENTRY(csum_unchecked),\n\tENA_STAT_RX_ENTRY(xdp_aborted),\n\tENA_STAT_RX_ENTRY(xdp_drop),\n\tENA_STAT_RX_ENTRY(xdp_pass),\n\tENA_STAT_RX_ENTRY(xdp_tx),\n\tENA_STAT_RX_ENTRY(xdp_invalid),\n\tENA_STAT_RX_ENTRY(xdp_redirect),\n};\n\nstatic const struct ena_stats ena_stats_ena_com_strings[] = {\n\tENA_STAT_ENA_COM_ENTRY(aborted_cmd),\n\tENA_STAT_ENA_COM_ENTRY(submitted_cmd),\n\tENA_STAT_ENA_COM_ENTRY(completed_cmd),\n\tENA_STAT_ENA_COM_ENTRY(out_of_space),\n\tENA_STAT_ENA_COM_ENTRY(no_completion),\n};\n\n#define ENA_STATS_ARRAY_GLOBAL\t\tARRAY_SIZE(ena_stats_global_strings)\n#define ENA_STATS_ARRAY_TX\t\tARRAY_SIZE(ena_stats_tx_strings)\n#define ENA_STATS_ARRAY_RX\t\tARRAY_SIZE(ena_stats_rx_strings)\n#define ENA_STATS_ARRAY_ENA_COM\t\tARRAY_SIZE(ena_stats_ena_com_strings)\n#define ENA_STATS_ARRAY_ENI(adapter)\tARRAY_SIZE(ena_stats_eni_strings)\n\nstatic void ena_safe_update_stat(u64 *src, u64 *dst,\n\t\t\t\t struct u64_stats_sync *syncp)\n{\n\tunsigned int start;\n\n\tdo {\n\t\tstart = u64_stats_fetch_begin(syncp);\n\t\t*(dst) = *src;\n\t} while (u64_stats_fetch_retry(syncp, start));\n}\n\nstatic void ena_queue_stats(struct ena_adapter *adapter, u64 **data)\n{\n\tconst struct ena_stats *ena_stats;\n\tstruct ena_ring *ring;\n\n\tu64 *ptr;\n\tint i, j;\n\n\tfor (i = 0; i < adapter->num_io_queues + adapter->xdp_num_queues; i++) {\n\t\t \n\t\tring = &adapter->tx_ring[i];\n\n\t\tfor (j = 0; j < ENA_STATS_ARRAY_TX; j++) {\n\t\t\tena_stats = &ena_stats_tx_strings[j];\n\n\t\t\tptr = (u64 *)&ring->tx_stats + ena_stats->stat_offset;\n\n\t\t\tena_safe_update_stat(ptr, (*data)++, &ring->syncp);\n\t\t}\n\t\t \n\t\tif (!ENA_IS_XDP_INDEX(adapter, i)) {\n\t\t\t \n\t\t\tring = &adapter->rx_ring[i];\n\n\t\t\tfor (j = 0; j < ENA_STATS_ARRAY_RX; j++) {\n\t\t\t\tena_stats = &ena_stats_rx_strings[j];\n\n\t\t\t\tptr = (u64 *)&ring->rx_stats +\n\t\t\t\t\tena_stats->stat_offset;\n\n\t\t\t\tena_safe_update_stat(ptr, (*data)++, &ring->syncp);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void ena_dev_admin_queue_stats(struct ena_adapter *adapter, u64 **data)\n{\n\tconst struct ena_stats *ena_stats;\n\tu64 *ptr;\n\tint i;\n\n\tfor (i = 0; i < ENA_STATS_ARRAY_ENA_COM; i++) {\n\t\tena_stats = &ena_stats_ena_com_strings[i];\n\n\t\tptr = (u64 *)&adapter->ena_dev->admin_queue.stats +\n\t\t\tena_stats->stat_offset;\n\n\t\t*(*data)++ = *ptr;\n\t}\n}\n\nstatic void ena_get_stats(struct ena_adapter *adapter,\n\t\t\t  u64 *data,\n\t\t\t  bool eni_stats_needed)\n{\n\tconst struct ena_stats *ena_stats;\n\tu64 *ptr;\n\tint i;\n\n\tfor (i = 0; i < ENA_STATS_ARRAY_GLOBAL; i++) {\n\t\tena_stats = &ena_stats_global_strings[i];\n\n\t\tptr = (u64 *)&adapter->dev_stats + ena_stats->stat_offset;\n\n\t\tena_safe_update_stat(ptr, data++, &adapter->syncp);\n\t}\n\n\tif (eni_stats_needed) {\n\t\tena_update_hw_stats(adapter);\n\t\tfor (i = 0; i < ENA_STATS_ARRAY_ENI(adapter); i++) {\n\t\t\tena_stats = &ena_stats_eni_strings[i];\n\n\t\t\tptr = (u64 *)&adapter->eni_stats +\n\t\t\t\tena_stats->stat_offset;\n\n\t\t\tena_safe_update_stat(ptr, data++, &adapter->syncp);\n\t\t}\n\t}\n\n\tena_queue_stats(adapter, &data);\n\tena_dev_admin_queue_stats(adapter, &data);\n}\n\nstatic void ena_get_ethtool_stats(struct net_device *netdev,\n\t\t\t\t  struct ethtool_stats *stats,\n\t\t\t\t  u64 *data)\n{\n\tstruct ena_adapter *adapter = netdev_priv(netdev);\n\tstruct ena_com_dev *dev = adapter->ena_dev;\n\n\tena_get_stats(adapter, data, ena_com_get_cap(dev, ENA_ADMIN_ENI_STATS));\n}\n\nstatic int ena_get_sw_stats_count(struct ena_adapter *adapter)\n{\n\treturn adapter->num_io_queues * (ENA_STATS_ARRAY_TX + ENA_STATS_ARRAY_RX)\n\t\t+ adapter->xdp_num_queues * ENA_STATS_ARRAY_TX\n\t\t+ ENA_STATS_ARRAY_GLOBAL + ENA_STATS_ARRAY_ENA_COM;\n}\n\nstatic int ena_get_hw_stats_count(struct ena_adapter *adapter)\n{\n\tbool supported = ena_com_get_cap(adapter->ena_dev, ENA_ADMIN_ENI_STATS);\n\n\treturn ENA_STATS_ARRAY_ENI(adapter) * supported;\n}\n\nint ena_get_sset_count(struct net_device *netdev, int sset)\n{\n\tstruct ena_adapter *adapter = netdev_priv(netdev);\n\n\tswitch (sset) {\n\tcase ETH_SS_STATS:\n\t\treturn ena_get_sw_stats_count(adapter) +\n\t\t       ena_get_hw_stats_count(adapter);\n\t}\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic void ena_queue_strings(struct ena_adapter *adapter, u8 **data)\n{\n\tconst struct ena_stats *ena_stats;\n\tbool is_xdp;\n\tint i, j;\n\n\tfor (i = 0; i < adapter->num_io_queues + adapter->xdp_num_queues; i++) {\n\t\tis_xdp = ENA_IS_XDP_INDEX(adapter, i);\n\t\t \n\t\tfor (j = 0; j < ENA_STATS_ARRAY_TX; j++) {\n\t\t\tena_stats = &ena_stats_tx_strings[j];\n\n\t\t\tethtool_sprintf(data,\n\t\t\t\t\t\"queue_%u_%s_%s\", i,\n\t\t\t\t\tis_xdp ? \"xdp_tx\" : \"tx\",\n\t\t\t\t\tena_stats->name);\n\t\t}\n\n\t\tif (!is_xdp) {\n\t\t\t \n\t\t\tfor (j = 0; j < ENA_STATS_ARRAY_RX; j++) {\n\t\t\t\tena_stats = &ena_stats_rx_strings[j];\n\n\t\t\t\tethtool_sprintf(data,\n\t\t\t\t\t\t\"queue_%u_rx_%s\", i,\n\t\t\t\t\t\tena_stats->name);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void ena_com_dev_strings(u8 **data)\n{\n\tconst struct ena_stats *ena_stats;\n\tint i;\n\n\tfor (i = 0; i < ENA_STATS_ARRAY_ENA_COM; i++) {\n\t\tena_stats = &ena_stats_ena_com_strings[i];\n\n\t\tethtool_sprintf(data,\n\t\t\t\t\"ena_admin_q_%s\", ena_stats->name);\n\t}\n}\n\nstatic void ena_get_strings(struct ena_adapter *adapter,\n\t\t\t    u8 *data,\n\t\t\t    bool eni_stats_needed)\n{\n\tconst struct ena_stats *ena_stats;\n\tint i;\n\n\tfor (i = 0; i < ENA_STATS_ARRAY_GLOBAL; i++) {\n\t\tena_stats = &ena_stats_global_strings[i];\n\t\tethtool_sprintf(&data, ena_stats->name);\n\t}\n\n\tif (eni_stats_needed) {\n\t\tfor (i = 0; i < ENA_STATS_ARRAY_ENI(adapter); i++) {\n\t\t\tena_stats = &ena_stats_eni_strings[i];\n\t\t\tethtool_sprintf(&data, ena_stats->name);\n\t\t}\n\t}\n\n\tena_queue_strings(adapter, &data);\n\tena_com_dev_strings(&data);\n}\n\nstatic void ena_get_ethtool_strings(struct net_device *netdev,\n\t\t\t\t    u32 sset,\n\t\t\t\t    u8 *data)\n{\n\tstruct ena_adapter *adapter = netdev_priv(netdev);\n\tstruct ena_com_dev *dev = adapter->ena_dev;\n\n\tswitch (sset) {\n\tcase ETH_SS_STATS:\n\t\tena_get_strings(adapter, data, ena_com_get_cap(dev, ENA_ADMIN_ENI_STATS));\n\t\tbreak;\n\t}\n}\n\nstatic int ena_get_link_ksettings(struct net_device *netdev,\n\t\t\t\t  struct ethtool_link_ksettings *link_ksettings)\n{\n\tstruct ena_adapter *adapter = netdev_priv(netdev);\n\tstruct ena_com_dev *ena_dev = adapter->ena_dev;\n\tstruct ena_admin_get_feature_link_desc *link;\n\tstruct ena_admin_get_feat_resp feat_resp;\n\tint rc;\n\n\trc = ena_com_get_link_params(ena_dev, &feat_resp);\n\tif (rc)\n\t\treturn rc;\n\n\tlink = &feat_resp.u.link;\n\tlink_ksettings->base.speed = link->speed;\n\n\tif (link->flags & ENA_ADMIN_GET_FEATURE_LINK_DESC_AUTONEG_MASK) {\n\t\tethtool_link_ksettings_add_link_mode(link_ksettings,\n\t\t\t\t\t\t     supported, Autoneg);\n\t\tethtool_link_ksettings_add_link_mode(link_ksettings,\n\t\t\t\t\t\t     supported, Autoneg);\n\t}\n\n\tlink_ksettings->base.autoneg =\n\t\t(link->flags & ENA_ADMIN_GET_FEATURE_LINK_DESC_AUTONEG_MASK) ?\n\t\tAUTONEG_ENABLE : AUTONEG_DISABLE;\n\n\tlink_ksettings->base.duplex = DUPLEX_FULL;\n\n\treturn 0;\n}\n\nstatic int ena_get_coalesce(struct net_device *net_dev,\n\t\t\t    struct ethtool_coalesce *coalesce,\n\t\t\t    struct kernel_ethtool_coalesce *kernel_coal,\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct ena_adapter *adapter = netdev_priv(net_dev);\n\tstruct ena_com_dev *ena_dev = adapter->ena_dev;\n\n\tif (!ena_com_interrupt_moderation_supported(ena_dev))\n\t\treturn -EOPNOTSUPP;\n\n\tcoalesce->tx_coalesce_usecs =\n\t\tena_com_get_nonadaptive_moderation_interval_tx(ena_dev) *\n\t\t\tena_dev->intr_delay_resolution;\n\n\tcoalesce->rx_coalesce_usecs =\n\t\tena_com_get_nonadaptive_moderation_interval_rx(ena_dev)\n\t\t* ena_dev->intr_delay_resolution;\n\n\tcoalesce->use_adaptive_rx_coalesce =\n\t\tena_com_get_adaptive_moderation_enabled(ena_dev);\n\n\treturn 0;\n}\n\nstatic void ena_update_tx_rings_nonadaptive_intr_moderation(struct ena_adapter *adapter)\n{\n\tunsigned int val;\n\tint i;\n\n\tval = ena_com_get_nonadaptive_moderation_interval_tx(adapter->ena_dev);\n\n\tfor (i = 0; i < adapter->num_io_queues; i++)\n\t\tadapter->tx_ring[i].smoothed_interval = val;\n}\n\nstatic void ena_update_rx_rings_nonadaptive_intr_moderation(struct ena_adapter *adapter)\n{\n\tunsigned int val;\n\tint i;\n\n\tval = ena_com_get_nonadaptive_moderation_interval_rx(adapter->ena_dev);\n\n\tfor (i = 0; i < adapter->num_io_queues; i++)\n\t\tadapter->rx_ring[i].smoothed_interval = val;\n}\n\nstatic int ena_set_coalesce(struct net_device *net_dev,\n\t\t\t    struct ethtool_coalesce *coalesce,\n\t\t\t    struct kernel_ethtool_coalesce *kernel_coal,\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct ena_adapter *adapter = netdev_priv(net_dev);\n\tstruct ena_com_dev *ena_dev = adapter->ena_dev;\n\tint rc;\n\n\tif (!ena_com_interrupt_moderation_supported(ena_dev))\n\t\treturn -EOPNOTSUPP;\n\n\trc = ena_com_update_nonadaptive_moderation_interval_tx(ena_dev,\n\t\t\t\t\t\t\t       coalesce->tx_coalesce_usecs);\n\tif (rc)\n\t\treturn rc;\n\n\tena_update_tx_rings_nonadaptive_intr_moderation(adapter);\n\n\trc = ena_com_update_nonadaptive_moderation_interval_rx(ena_dev,\n\t\t\t\t\t\t\t       coalesce->rx_coalesce_usecs);\n\tif (rc)\n\t\treturn rc;\n\n\tena_update_rx_rings_nonadaptive_intr_moderation(adapter);\n\n\tif (coalesce->use_adaptive_rx_coalesce &&\n\t    !ena_com_get_adaptive_moderation_enabled(ena_dev))\n\t\tena_com_enable_adaptive_moderation(ena_dev);\n\n\tif (!coalesce->use_adaptive_rx_coalesce &&\n\t    ena_com_get_adaptive_moderation_enabled(ena_dev))\n\t\tena_com_disable_adaptive_moderation(ena_dev);\n\n\treturn 0;\n}\n\nstatic u32 ena_get_msglevel(struct net_device *netdev)\n{\n\tstruct ena_adapter *adapter = netdev_priv(netdev);\n\n\treturn adapter->msg_enable;\n}\n\nstatic void ena_set_msglevel(struct net_device *netdev, u32 value)\n{\n\tstruct ena_adapter *adapter = netdev_priv(netdev);\n\n\tadapter->msg_enable = value;\n}\n\nstatic void ena_get_drvinfo(struct net_device *dev,\n\t\t\t    struct ethtool_drvinfo *info)\n{\n\tstruct ena_adapter *adapter = netdev_priv(dev);\n\n\tstrscpy(info->driver, DRV_MODULE_NAME, sizeof(info->driver));\n\tstrscpy(info->bus_info, pci_name(adapter->pdev),\n\t\tsizeof(info->bus_info));\n}\n\nstatic void ena_get_ringparam(struct net_device *netdev,\n\t\t\t      struct ethtool_ringparam *ring,\n\t\t\t      struct kernel_ethtool_ringparam *kernel_ring,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct ena_adapter *adapter = netdev_priv(netdev);\n\n\tring->tx_max_pending = adapter->max_tx_ring_size;\n\tring->rx_max_pending = adapter->max_rx_ring_size;\n\tif (adapter->ena_dev->tx_mem_queue_type == ENA_ADMIN_PLACEMENT_POLICY_DEV) {\n\t\tbool large_llq_supported = adapter->large_llq_header_supported;\n\n\t\tkernel_ring->tx_push = true;\n\t\tkernel_ring->tx_push_buf_len = adapter->ena_dev->tx_max_header_size;\n\t\tif (large_llq_supported)\n\t\t\tkernel_ring->tx_push_buf_max_len = ENA_LLQ_LARGE_HEADER;\n\t\telse\n\t\t\tkernel_ring->tx_push_buf_max_len = ENA_LLQ_HEADER;\n\t} else {\n\t\tkernel_ring->tx_push = false;\n\t\tkernel_ring->tx_push_buf_max_len = 0;\n\t\tkernel_ring->tx_push_buf_len = 0;\n\t}\n\n\tring->tx_pending = adapter->tx_ring[0].ring_size;\n\tring->rx_pending = adapter->rx_ring[0].ring_size;\n}\n\nstatic int ena_set_ringparam(struct net_device *netdev,\n\t\t\t     struct ethtool_ringparam *ring,\n\t\t\t     struct kernel_ethtool_ringparam *kernel_ring,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct ena_adapter *adapter = netdev_priv(netdev);\n\tu32 new_tx_size, new_rx_size, new_tx_push_buf_len;\n\tbool changed = false;\n\n\tnew_tx_size = ring->tx_pending < ENA_MIN_RING_SIZE ?\n\t\t\tENA_MIN_RING_SIZE : ring->tx_pending;\n\tnew_tx_size = rounddown_pow_of_two(new_tx_size);\n\n\tnew_rx_size = ring->rx_pending < ENA_MIN_RING_SIZE ?\n\t\t\tENA_MIN_RING_SIZE : ring->rx_pending;\n\tnew_rx_size = rounddown_pow_of_two(new_rx_size);\n\n\tchanged |= new_tx_size != adapter->requested_tx_ring_size ||\n\t\t   new_rx_size != adapter->requested_rx_ring_size;\n\n\t \n\tnew_tx_push_buf_len = adapter->ena_dev->tx_max_header_size;\n\n\tif ((adapter->ena_dev->tx_mem_queue_type == ENA_ADMIN_PLACEMENT_POLICY_DEV) !=\n\t    kernel_ring->tx_push) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Push mode state cannot be modified\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (kernel_ring->tx_push_buf_len) {\n\t\tenum ena_admin_placement_policy_type placement;\n\n\t\tnew_tx_push_buf_len = kernel_ring->tx_push_buf_len;\n\n\t\tplacement = adapter->ena_dev->tx_mem_queue_type;\n\t\tif (placement == ENA_ADMIN_PLACEMENT_POLICY_HOST)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tif (new_tx_push_buf_len != ENA_LLQ_HEADER &&\n\t\t    new_tx_push_buf_len != ENA_LLQ_LARGE_HEADER) {\n\t\t\tbool large_llq_sup = adapter->large_llq_header_supported;\n\t\t\tchar large_llq_size_str[40];\n\n\t\t\tsnprintf(large_llq_size_str, 40, \", %lu\", ENA_LLQ_LARGE_HEADER);\n\n\t\t\tNL_SET_ERR_MSG_FMT_MOD(extack,\n\t\t\t\t\t       \"Supported tx push buff values: [%lu%s]\",\n\t\t\t\t\t       ENA_LLQ_HEADER,\n\t\t\t\t\t       large_llq_sup ? large_llq_size_str : \"\");\n\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tchanged |= new_tx_push_buf_len != adapter->ena_dev->tx_max_header_size;\n\t}\n\n\tif (!changed)\n\t\treturn 0;\n\n\treturn ena_update_queue_params(adapter, new_tx_size, new_rx_size,\n\t\t\t\t       new_tx_push_buf_len);\n}\n\nstatic u32 ena_flow_hash_to_flow_type(u16 hash_fields)\n{\n\tu32 data = 0;\n\n\tif (hash_fields & ENA_ADMIN_RSS_L2_DA)\n\t\tdata |= RXH_L2DA;\n\n\tif (hash_fields & ENA_ADMIN_RSS_L3_DA)\n\t\tdata |= RXH_IP_DST;\n\n\tif (hash_fields & ENA_ADMIN_RSS_L3_SA)\n\t\tdata |= RXH_IP_SRC;\n\n\tif (hash_fields & ENA_ADMIN_RSS_L4_DP)\n\t\tdata |= RXH_L4_B_2_3;\n\n\tif (hash_fields & ENA_ADMIN_RSS_L4_SP)\n\t\tdata |= RXH_L4_B_0_1;\n\n\treturn data;\n}\n\nstatic u16 ena_flow_data_to_flow_hash(u32 hash_fields)\n{\n\tu16 data = 0;\n\n\tif (hash_fields & RXH_L2DA)\n\t\tdata |= ENA_ADMIN_RSS_L2_DA;\n\n\tif (hash_fields & RXH_IP_DST)\n\t\tdata |= ENA_ADMIN_RSS_L3_DA;\n\n\tif (hash_fields & RXH_IP_SRC)\n\t\tdata |= ENA_ADMIN_RSS_L3_SA;\n\n\tif (hash_fields & RXH_L4_B_2_3)\n\t\tdata |= ENA_ADMIN_RSS_L4_DP;\n\n\tif (hash_fields & RXH_L4_B_0_1)\n\t\tdata |= ENA_ADMIN_RSS_L4_SP;\n\n\treturn data;\n}\n\nstatic int ena_get_rss_hash(struct ena_com_dev *ena_dev,\n\t\t\t    struct ethtool_rxnfc *cmd)\n{\n\tenum ena_admin_flow_hash_proto proto;\n\tu16 hash_fields;\n\tint rc;\n\n\tcmd->data = 0;\n\n\tswitch (cmd->flow_type) {\n\tcase TCP_V4_FLOW:\n\t\tproto = ENA_ADMIN_RSS_TCP4;\n\t\tbreak;\n\tcase UDP_V4_FLOW:\n\t\tproto = ENA_ADMIN_RSS_UDP4;\n\t\tbreak;\n\tcase TCP_V6_FLOW:\n\t\tproto = ENA_ADMIN_RSS_TCP6;\n\t\tbreak;\n\tcase UDP_V6_FLOW:\n\t\tproto = ENA_ADMIN_RSS_UDP6;\n\t\tbreak;\n\tcase IPV4_FLOW:\n\t\tproto = ENA_ADMIN_RSS_IP4;\n\t\tbreak;\n\tcase IPV6_FLOW:\n\t\tproto = ENA_ADMIN_RSS_IP6;\n\t\tbreak;\n\tcase ETHER_FLOW:\n\t\tproto = ENA_ADMIN_RSS_NOT_IP;\n\t\tbreak;\n\tcase AH_V4_FLOW:\n\tcase ESP_V4_FLOW:\n\tcase AH_V6_FLOW:\n\tcase ESP_V6_FLOW:\n\tcase SCTP_V4_FLOW:\n\tcase AH_ESP_V4_FLOW:\n\t\treturn -EOPNOTSUPP;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\trc = ena_com_get_hash_ctrl(ena_dev, proto, &hash_fields);\n\tif (rc)\n\t\treturn rc;\n\n\tcmd->data = ena_flow_hash_to_flow_type(hash_fields);\n\n\treturn 0;\n}\n\nstatic int ena_set_rss_hash(struct ena_com_dev *ena_dev,\n\t\t\t    struct ethtool_rxnfc *cmd)\n{\n\tenum ena_admin_flow_hash_proto proto;\n\tu16 hash_fields;\n\n\tswitch (cmd->flow_type) {\n\tcase TCP_V4_FLOW:\n\t\tproto = ENA_ADMIN_RSS_TCP4;\n\t\tbreak;\n\tcase UDP_V4_FLOW:\n\t\tproto = ENA_ADMIN_RSS_UDP4;\n\t\tbreak;\n\tcase TCP_V6_FLOW:\n\t\tproto = ENA_ADMIN_RSS_TCP6;\n\t\tbreak;\n\tcase UDP_V6_FLOW:\n\t\tproto = ENA_ADMIN_RSS_UDP6;\n\t\tbreak;\n\tcase IPV4_FLOW:\n\t\tproto = ENA_ADMIN_RSS_IP4;\n\t\tbreak;\n\tcase IPV6_FLOW:\n\t\tproto = ENA_ADMIN_RSS_IP6;\n\t\tbreak;\n\tcase ETHER_FLOW:\n\t\tproto = ENA_ADMIN_RSS_NOT_IP;\n\t\tbreak;\n\tcase AH_V4_FLOW:\n\tcase ESP_V4_FLOW:\n\tcase AH_V6_FLOW:\n\tcase ESP_V6_FLOW:\n\tcase SCTP_V4_FLOW:\n\tcase AH_ESP_V4_FLOW:\n\t\treturn -EOPNOTSUPP;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\thash_fields = ena_flow_data_to_flow_hash(cmd->data);\n\n\treturn ena_com_fill_hash_ctrl(ena_dev, proto, hash_fields);\n}\n\nstatic int ena_set_rxnfc(struct net_device *netdev, struct ethtool_rxnfc *info)\n{\n\tstruct ena_adapter *adapter = netdev_priv(netdev);\n\tint rc = 0;\n\n\tswitch (info->cmd) {\n\tcase ETHTOOL_SRXFH:\n\t\trc = ena_set_rss_hash(adapter->ena_dev, info);\n\t\tbreak;\n\tcase ETHTOOL_SRXCLSRLDEL:\n\tcase ETHTOOL_SRXCLSRLINS:\n\tdefault:\n\t\tnetif_err(adapter, drv, netdev,\n\t\t\t  \"Command parameter %d is not supported\\n\", info->cmd);\n\t\trc = -EOPNOTSUPP;\n\t}\n\n\treturn rc;\n}\n\nstatic int ena_get_rxnfc(struct net_device *netdev, struct ethtool_rxnfc *info,\n\t\t\t u32 *rules)\n{\n\tstruct ena_adapter *adapter = netdev_priv(netdev);\n\tint rc = 0;\n\n\tswitch (info->cmd) {\n\tcase ETHTOOL_GRXRINGS:\n\t\tinfo->data = adapter->num_io_queues;\n\t\trc = 0;\n\t\tbreak;\n\tcase ETHTOOL_GRXFH:\n\t\trc = ena_get_rss_hash(adapter->ena_dev, info);\n\t\tbreak;\n\tcase ETHTOOL_GRXCLSRLCNT:\n\tcase ETHTOOL_GRXCLSRULE:\n\tcase ETHTOOL_GRXCLSRLALL:\n\tdefault:\n\t\tnetif_err(adapter, drv, netdev,\n\t\t\t  \"Command parameter %d is not supported\\n\", info->cmd);\n\t\trc = -EOPNOTSUPP;\n\t}\n\n\treturn rc;\n}\n\nstatic u32 ena_get_rxfh_indir_size(struct net_device *netdev)\n{\n\treturn ENA_RX_RSS_TABLE_SIZE;\n}\n\nstatic u32 ena_get_rxfh_key_size(struct net_device *netdev)\n{\n\treturn ENA_HASH_KEY_SIZE;\n}\n\nstatic int ena_indirection_table_set(struct ena_adapter *adapter,\n\t\t\t\t     const u32 *indir)\n{\n\tstruct ena_com_dev *ena_dev = adapter->ena_dev;\n\tint i, rc;\n\n\tfor (i = 0; i < ENA_RX_RSS_TABLE_SIZE; i++) {\n\t\trc = ena_com_indirect_table_fill_entry(ena_dev,\n\t\t\t\t\t\t       i,\n\t\t\t\t\t\t       ENA_IO_RXQ_IDX(indir[i]));\n\t\tif (unlikely(rc)) {\n\t\t\tnetif_err(adapter, drv, adapter->netdev,\n\t\t\t\t  \"Cannot fill indirect table (index is too large)\\n\");\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\trc = ena_com_indirect_table_set(ena_dev);\n\tif (rc) {\n\t\tnetif_err(adapter, drv, adapter->netdev,\n\t\t\t  \"Cannot set indirect table\\n\");\n\t\treturn rc == -EPERM ? -EOPNOTSUPP : rc;\n\t}\n\treturn rc;\n}\n\nstatic int ena_indirection_table_get(struct ena_adapter *adapter, u32 *indir)\n{\n\tstruct ena_com_dev *ena_dev = adapter->ena_dev;\n\tint i, rc;\n\n\tif (!indir)\n\t\treturn 0;\n\n\trc = ena_com_indirect_table_get(ena_dev, indir);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tfor (i = 0; i < ENA_RX_RSS_TABLE_SIZE; i++)\n\t\tindir[i] = ENA_IO_RXQ_IDX_TO_COMBINED_IDX(indir[i]);\n\n\treturn rc;\n}\n\nstatic int ena_get_rxfh(struct net_device *netdev, u32 *indir, u8 *key,\n\t\t\tu8 *hfunc)\n{\n\tstruct ena_adapter *adapter = netdev_priv(netdev);\n\tenum ena_admin_hash_functions ena_func;\n\tu8 func;\n\tint rc;\n\n\trc = ena_indirection_table_get(adapter, indir);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\trc = ena_com_get_hash_function(adapter->ena_dev, &ena_func);\n\tif (rc) {\n\t\tif (rc == -EOPNOTSUPP)\n\t\t\trc = 0;\n\n\t\treturn rc;\n\t}\n\n\trc = ena_com_get_hash_key(adapter->ena_dev, key);\n\tif (rc)\n\t\treturn rc;\n\n\tswitch (ena_func) {\n\tcase ENA_ADMIN_TOEPLITZ:\n\t\tfunc = ETH_RSS_HASH_TOP;\n\t\tbreak;\n\tcase ENA_ADMIN_CRC32:\n\t\tfunc = ETH_RSS_HASH_CRC32;\n\t\tbreak;\n\tdefault:\n\t\tnetif_err(adapter, drv, netdev,\n\t\t\t  \"Command parameter is not supported\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (hfunc)\n\t\t*hfunc = func;\n\n\treturn 0;\n}\n\nstatic int ena_set_rxfh(struct net_device *netdev, const u32 *indir,\n\t\t\tconst u8 *key, const u8 hfunc)\n{\n\tstruct ena_adapter *adapter = netdev_priv(netdev);\n\tstruct ena_com_dev *ena_dev = adapter->ena_dev;\n\tenum ena_admin_hash_functions func = 0;\n\tint rc;\n\n\tif (indir) {\n\t\trc = ena_indirection_table_set(adapter, indir);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\tswitch (hfunc) {\n\tcase ETH_RSS_HASH_NO_CHANGE:\n\t\tfunc = ena_com_get_current_hash_function(ena_dev);\n\t\tbreak;\n\tcase ETH_RSS_HASH_TOP:\n\t\tfunc = ENA_ADMIN_TOEPLITZ;\n\t\tbreak;\n\tcase ETH_RSS_HASH_CRC32:\n\t\tfunc = ENA_ADMIN_CRC32;\n\t\tbreak;\n\tdefault:\n\t\tnetif_err(adapter, drv, netdev, \"Unsupported hfunc %d\\n\",\n\t\t\t  hfunc);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (key || func) {\n\t\trc = ena_com_fill_hash_function(ena_dev, func, key,\n\t\t\t\t\t\tENA_HASH_KEY_SIZE,\n\t\t\t\t\t\t0xFFFFFFFF);\n\t\tif (unlikely(rc)) {\n\t\t\tnetif_err(adapter, drv, netdev, \"Cannot fill key\\n\");\n\t\t\treturn rc == -EPERM ? -EOPNOTSUPP : rc;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void ena_get_channels(struct net_device *netdev,\n\t\t\t     struct ethtool_channels *channels)\n{\n\tstruct ena_adapter *adapter = netdev_priv(netdev);\n\n\tchannels->max_combined = adapter->max_num_io_queues;\n\tchannels->combined_count = adapter->num_io_queues;\n}\n\nstatic int ena_set_channels(struct net_device *netdev,\n\t\t\t    struct ethtool_channels *channels)\n{\n\tstruct ena_adapter *adapter = netdev_priv(netdev);\n\tu32 count = channels->combined_count;\n\t \n\tif (count < ENA_MIN_NUM_IO_QUEUES)\n\t\treturn -EINVAL;\n\n\tif (!ena_xdp_legal_queue_count(adapter, count)) {\n\t\tif (ena_xdp_present(adapter))\n\t\t\treturn -EINVAL;\n\n\t\txdp_clear_features_flag(netdev);\n\t} else {\n\t\txdp_set_features_flag(netdev,\n\t\t\t\t      NETDEV_XDP_ACT_BASIC |\n\t\t\t\t      NETDEV_XDP_ACT_REDIRECT);\n\t}\n\n\treturn ena_update_queue_count(adapter, count);\n}\n\nstatic int ena_get_tunable(struct net_device *netdev,\n\t\t\t   const struct ethtool_tunable *tuna, void *data)\n{\n\tstruct ena_adapter *adapter = netdev_priv(netdev);\n\tint ret = 0;\n\n\tswitch (tuna->id) {\n\tcase ETHTOOL_RX_COPYBREAK:\n\t\t*(u32 *)data = adapter->rx_copybreak;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int ena_set_tunable(struct net_device *netdev,\n\t\t\t   const struct ethtool_tunable *tuna,\n\t\t\t   const void *data)\n{\n\tstruct ena_adapter *adapter = netdev_priv(netdev);\n\tint ret = 0;\n\tu32 len;\n\n\tswitch (tuna->id) {\n\tcase ETHTOOL_RX_COPYBREAK:\n\t\tlen = *(u32 *)data;\n\t\tret = ena_set_rx_copybreak(adapter, len);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic const struct ethtool_ops ena_ethtool_ops = {\n\t.supported_coalesce_params = ETHTOOL_COALESCE_USECS |\n\t\t\t\t     ETHTOOL_COALESCE_USE_ADAPTIVE_RX,\n\t.supported_ring_params\t= ETHTOOL_RING_USE_TX_PUSH_BUF_LEN |\n\t\t\t\t  ETHTOOL_RING_USE_TX_PUSH,\n\t.get_link_ksettings\t= ena_get_link_ksettings,\n\t.get_drvinfo\t\t= ena_get_drvinfo,\n\t.get_msglevel\t\t= ena_get_msglevel,\n\t.set_msglevel\t\t= ena_set_msglevel,\n\t.get_link\t\t= ethtool_op_get_link,\n\t.get_coalesce\t\t= ena_get_coalesce,\n\t.set_coalesce\t\t= ena_set_coalesce,\n\t.get_ringparam\t\t= ena_get_ringparam,\n\t.set_ringparam\t\t= ena_set_ringparam,\n\t.get_sset_count         = ena_get_sset_count,\n\t.get_strings\t\t= ena_get_ethtool_strings,\n\t.get_ethtool_stats      = ena_get_ethtool_stats,\n\t.get_rxnfc\t\t= ena_get_rxnfc,\n\t.set_rxnfc\t\t= ena_set_rxnfc,\n\t.get_rxfh_indir_size    = ena_get_rxfh_indir_size,\n\t.get_rxfh_key_size\t= ena_get_rxfh_key_size,\n\t.get_rxfh\t\t= ena_get_rxfh,\n\t.set_rxfh\t\t= ena_set_rxfh,\n\t.get_channels\t\t= ena_get_channels,\n\t.set_channels\t\t= ena_set_channels,\n\t.get_tunable\t\t= ena_get_tunable,\n\t.set_tunable\t\t= ena_set_tunable,\n\t.get_ts_info            = ethtool_op_get_ts_info,\n};\n\nvoid ena_set_ethtool_ops(struct net_device *netdev)\n{\n\tnetdev->ethtool_ops = &ena_ethtool_ops;\n}\n\nstatic void ena_dump_stats_ex(struct ena_adapter *adapter, u8 *buf)\n{\n\tstruct net_device *netdev = adapter->netdev;\n\tu8 *strings_buf;\n\tu64 *data_buf;\n\tint strings_num;\n\tint i, rc;\n\n\tstrings_num = ena_get_sw_stats_count(adapter);\n\tif (strings_num <= 0) {\n\t\tnetif_err(adapter, drv, netdev, \"Can't get stats num\\n\");\n\t\treturn;\n\t}\n\n\tstrings_buf = devm_kcalloc(&adapter->pdev->dev,\n\t\t\t\t   ETH_GSTRING_LEN, strings_num,\n\t\t\t\t   GFP_ATOMIC);\n\tif (!strings_buf) {\n\t\tnetif_err(adapter, drv, netdev,\n\t\t\t  \"Failed to allocate strings_buf\\n\");\n\t\treturn;\n\t}\n\n\tdata_buf = devm_kcalloc(&adapter->pdev->dev,\n\t\t\t\tstrings_num, sizeof(u64),\n\t\t\t\tGFP_ATOMIC);\n\tif (!data_buf) {\n\t\tnetif_err(adapter, drv, netdev,\n\t\t\t  \"Failed to allocate data buf\\n\");\n\t\tdevm_kfree(&adapter->pdev->dev, strings_buf);\n\t\treturn;\n\t}\n\n\tena_get_strings(adapter, strings_buf, false);\n\tena_get_stats(adapter, data_buf, false);\n\n\t \n\tif (buf)\n\t\tfor (i = 0; i < strings_num; i++) {\n\t\t\trc = snprintf(buf, ETH_GSTRING_LEN + sizeof(u64),\n\t\t\t\t      \"%s %llu\\n\",\n\t\t\t\t      strings_buf + i * ETH_GSTRING_LEN,\n\t\t\t\t      data_buf[i]);\n\t\t\tbuf += rc;\n\t\t}\n\telse\n\t\tfor (i = 0; i < strings_num; i++)\n\t\t\tnetif_err(adapter, drv, netdev, \"%s: %llu\\n\",\n\t\t\t\t  strings_buf + i * ETH_GSTRING_LEN,\n\t\t\t\t  data_buf[i]);\n\n\tdevm_kfree(&adapter->pdev->dev, strings_buf);\n\tdevm_kfree(&adapter->pdev->dev, data_buf);\n}\n\nvoid ena_dump_stats_to_buf(struct ena_adapter *adapter, u8 *buf)\n{\n\tif (!buf)\n\t\treturn;\n\n\tena_dump_stats_ex(adapter, buf);\n}\n\nvoid ena_dump_stats_to_dmesg(struct ena_adapter *adapter)\n{\n\tena_dump_stats_ex(adapter, NULL);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}