{
  "module_name": "ena_netdev.c",
  "hash_id": "b191b07f1e097ef9d1873a09e045056a59b37752ddea143b9c0e4429c7002089",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/amazon/ena/ena_netdev.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#ifdef CONFIG_RFS_ACCEL\n#include <linux/cpu_rmap.h>\n#endif  \n#include <linux/ethtool.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/numa.h>\n#include <linux/pci.h>\n#include <linux/utsname.h>\n#include <linux/version.h>\n#include <linux/vmalloc.h>\n#include <net/ip.h>\n\n#include \"ena_netdev.h\"\n#include <linux/bpf_trace.h>\n#include \"ena_pci_id_tbl.h\"\n\nMODULE_AUTHOR(\"Amazon.com, Inc. or its affiliates\");\nMODULE_DESCRIPTION(DEVICE_NAME);\nMODULE_LICENSE(\"GPL\");\n\n \n#define TX_TIMEOUT  (5 * HZ)\n\n#define ENA_MAX_RINGS min_t(unsigned int, ENA_MAX_NUM_IO_QUEUES, num_possible_cpus())\n\n#define DEFAULT_MSG_ENABLE (NETIF_MSG_DRV | NETIF_MSG_PROBE | NETIF_MSG_IFUP | \\\n\t\tNETIF_MSG_TX_DONE | NETIF_MSG_TX_ERR | NETIF_MSG_RX_ERR)\n\nstatic struct ena_aenq_handlers aenq_handlers;\n\nstatic struct workqueue_struct *ena_wq;\n\nMODULE_DEVICE_TABLE(pci, ena_pci_tbl);\n\nstatic int ena_rss_init_default(struct ena_adapter *adapter);\nstatic void check_for_admin_com_state(struct ena_adapter *adapter);\nstatic void ena_destroy_device(struct ena_adapter *adapter, bool graceful);\nstatic int ena_restore_device(struct ena_adapter *adapter);\n\nstatic void ena_init_io_rings(struct ena_adapter *adapter,\n\t\t\t      int first_index, int count);\nstatic void ena_init_napi_in_range(struct ena_adapter *adapter, int first_index,\n\t\t\t\t   int count);\nstatic void ena_del_napi_in_range(struct ena_adapter *adapter, int first_index,\n\t\t\t\t  int count);\nstatic int ena_setup_tx_resources(struct ena_adapter *adapter, int qid);\nstatic int ena_setup_tx_resources_in_range(struct ena_adapter *adapter,\n\t\t\t\t\t   int first_index,\n\t\t\t\t\t   int count);\nstatic int ena_create_io_tx_queue(struct ena_adapter *adapter, int qid);\nstatic void ena_free_tx_resources(struct ena_adapter *adapter, int qid);\nstatic int ena_clean_xdp_irq(struct ena_ring *xdp_ring, u32 budget);\nstatic void ena_destroy_all_tx_queues(struct ena_adapter *adapter);\nstatic void ena_free_all_io_tx_resources(struct ena_adapter *adapter);\nstatic void ena_napi_disable_in_range(struct ena_adapter *adapter,\n\t\t\t\t      int first_index, int count);\nstatic void ena_napi_enable_in_range(struct ena_adapter *adapter,\n\t\t\t\t     int first_index, int count);\nstatic int ena_up(struct ena_adapter *adapter);\nstatic void ena_down(struct ena_adapter *adapter);\nstatic void ena_unmask_interrupt(struct ena_ring *tx_ring,\n\t\t\t\t struct ena_ring *rx_ring);\nstatic void ena_update_ring_numa_node(struct ena_ring *tx_ring,\n\t\t\t\t      struct ena_ring *rx_ring);\nstatic void ena_unmap_tx_buff(struct ena_ring *tx_ring,\n\t\t\t      struct ena_tx_buffer *tx_info);\nstatic int ena_create_io_tx_queues_in_range(struct ena_adapter *adapter,\n\t\t\t\t\t    int first_index, int count);\nstatic void ena_free_all_io_tx_resources_in_range(struct ena_adapter *adapter,\n\t\t\t\t\t\t  int first_index, int count);\n\n \nstatic void ena_increase_stat(u64 *statp, u64 cnt,\n\t\t\t      struct u64_stats_sync *syncp)\n{\n\tu64_stats_update_begin(syncp);\n\t(*statp) += cnt;\n\tu64_stats_update_end(syncp);\n}\n\nstatic void ena_ring_tx_doorbell(struct ena_ring *tx_ring)\n{\n\tena_com_write_sq_doorbell(tx_ring->ena_com_io_sq);\n\tena_increase_stat(&tx_ring->tx_stats.doorbells, 1, &tx_ring->syncp);\n}\n\nstatic void ena_tx_timeout(struct net_device *dev, unsigned int txqueue)\n{\n\tstruct ena_adapter *adapter = netdev_priv(dev);\n\n\t \n\n\tif (test_and_set_bit(ENA_FLAG_TRIGGER_RESET, &adapter->flags))\n\t\treturn;\n\n\tena_reset_device(adapter, ENA_REGS_RESET_OS_NETDEV_WD);\n\tena_increase_stat(&adapter->dev_stats.tx_timeout, 1, &adapter->syncp);\n\n\tnetif_err(adapter, tx_err, dev, \"Transmit time out\\n\");\n}\n\nstatic void update_rx_ring_mtu(struct ena_adapter *adapter, int mtu)\n{\n\tint i;\n\n\tfor (i = 0; i < adapter->num_io_queues; i++)\n\t\tadapter->rx_ring[i].mtu = mtu;\n}\n\nstatic int ena_change_mtu(struct net_device *dev, int new_mtu)\n{\n\tstruct ena_adapter *adapter = netdev_priv(dev);\n\tint ret;\n\n\tret = ena_com_set_dev_mtu(adapter->ena_dev, new_mtu);\n\tif (!ret) {\n\t\tnetif_dbg(adapter, drv, dev, \"Set MTU to %d\\n\", new_mtu);\n\t\tupdate_rx_ring_mtu(adapter, new_mtu);\n\t\tdev->mtu = new_mtu;\n\t} else {\n\t\tnetif_err(adapter, drv, dev, \"Failed to set MTU to %d\\n\",\n\t\t\t  new_mtu);\n\t}\n\n\treturn ret;\n}\n\nstatic int ena_xmit_common(struct net_device *dev,\n\t\t\t   struct ena_ring *ring,\n\t\t\t   struct ena_tx_buffer *tx_info,\n\t\t\t   struct ena_com_tx_ctx *ena_tx_ctx,\n\t\t\t   u16 next_to_use,\n\t\t\t   u32 bytes)\n{\n\tstruct ena_adapter *adapter = netdev_priv(dev);\n\tint rc, nb_hw_desc;\n\n\tif (unlikely(ena_com_is_doorbell_needed(ring->ena_com_io_sq,\n\t\t\t\t\t\tena_tx_ctx))) {\n\t\tnetif_dbg(adapter, tx_queued, dev,\n\t\t\t  \"llq tx max burst size of queue %d achieved, writing doorbell to send burst\\n\",\n\t\t\t  ring->qid);\n\t\tena_ring_tx_doorbell(ring);\n\t}\n\n\t \n\trc = ena_com_prepare_tx(ring->ena_com_io_sq, ena_tx_ctx,\n\t\t\t\t&nb_hw_desc);\n\n\t \n\tif (unlikely(rc)) {\n\t\tnetif_err(adapter, tx_queued, dev,\n\t\t\t  \"Failed to prepare tx bufs\\n\");\n\t\tena_increase_stat(&ring->tx_stats.prepare_ctx_err, 1,\n\t\t\t\t  &ring->syncp);\n\t\tif (rc != -ENOMEM)\n\t\t\tena_reset_device(adapter,\n\t\t\t\t\t ENA_REGS_RESET_DRIVER_INVALID_STATE);\n\t\treturn rc;\n\t}\n\n\tu64_stats_update_begin(&ring->syncp);\n\tring->tx_stats.cnt++;\n\tring->tx_stats.bytes += bytes;\n\tu64_stats_update_end(&ring->syncp);\n\n\ttx_info->tx_descs = nb_hw_desc;\n\ttx_info->last_jiffies = jiffies;\n\ttx_info->print_once = 0;\n\n\tring->next_to_use = ENA_TX_RING_IDX_NEXT(next_to_use,\n\t\t\t\t\t\t ring->ring_size);\n\treturn 0;\n}\n\n \nstatic int ena_xdp_io_poll(struct napi_struct *napi, int budget)\n{\n\tstruct ena_napi *ena_napi = container_of(napi, struct ena_napi, napi);\n\tu32 xdp_work_done, xdp_budget;\n\tstruct ena_ring *xdp_ring;\n\tint napi_comp_call = 0;\n\tint ret;\n\n\txdp_ring = ena_napi->xdp_ring;\n\n\txdp_budget = budget;\n\n\tif (!test_bit(ENA_FLAG_DEV_UP, &xdp_ring->adapter->flags) ||\n\t    test_bit(ENA_FLAG_TRIGGER_RESET, &xdp_ring->adapter->flags)) {\n\t\tnapi_complete_done(napi, 0);\n\t\treturn 0;\n\t}\n\n\txdp_work_done = ena_clean_xdp_irq(xdp_ring, xdp_budget);\n\n\t \n\tif (unlikely(!test_bit(ENA_FLAG_DEV_UP, &xdp_ring->adapter->flags))) {\n\t\tnapi_complete_done(napi, 0);\n\t\tret = 0;\n\t} else if (xdp_budget > xdp_work_done) {\n\t\tnapi_comp_call = 1;\n\t\tif (napi_complete_done(napi, xdp_work_done))\n\t\t\tena_unmask_interrupt(xdp_ring, NULL);\n\t\tena_update_ring_numa_node(xdp_ring, NULL);\n\t\tret = xdp_work_done;\n\t} else {\n\t\tret = xdp_budget;\n\t}\n\n\tu64_stats_update_begin(&xdp_ring->syncp);\n\txdp_ring->tx_stats.napi_comp += napi_comp_call;\n\txdp_ring->tx_stats.tx_poll++;\n\tu64_stats_update_end(&xdp_ring->syncp);\n\txdp_ring->tx_stats.last_napi_jiffies = jiffies;\n\n\treturn ret;\n}\n\nstatic int ena_xdp_tx_map_frame(struct ena_ring *xdp_ring,\n\t\t\t\tstruct ena_tx_buffer *tx_info,\n\t\t\t\tstruct xdp_frame *xdpf,\n\t\t\t\tstruct ena_com_tx_ctx *ena_tx_ctx)\n{\n\tstruct ena_adapter *adapter = xdp_ring->adapter;\n\tstruct ena_com_buf *ena_buf;\n\tint push_len = 0;\n\tdma_addr_t dma;\n\tvoid *data;\n\tu32 size;\n\n\ttx_info->xdpf = xdpf;\n\tdata = tx_info->xdpf->data;\n\tsize = tx_info->xdpf->len;\n\n\tif (xdp_ring->tx_mem_queue_type == ENA_ADMIN_PLACEMENT_POLICY_DEV) {\n\t\t \n\t\tpush_len = min_t(u32, size, xdp_ring->tx_max_header_size);\n\n\t\tena_tx_ctx->push_header = data;\n\n\t\tsize -= push_len;\n\t\tdata += push_len;\n\t}\n\n\tena_tx_ctx->header_len = push_len;\n\n\tif (size > 0) {\n\t\tdma = dma_map_single(xdp_ring->dev,\n\t\t\t\t     data,\n\t\t\t\t     size,\n\t\t\t\t     DMA_TO_DEVICE);\n\t\tif (unlikely(dma_mapping_error(xdp_ring->dev, dma)))\n\t\t\tgoto error_report_dma_error;\n\n\t\ttx_info->map_linear_data = 0;\n\n\t\tena_buf = tx_info->bufs;\n\t\tena_buf->paddr = dma;\n\t\tena_buf->len = size;\n\n\t\tena_tx_ctx->ena_bufs = ena_buf;\n\t\tena_tx_ctx->num_bufs = tx_info->num_of_bufs = 1;\n\t}\n\n\treturn 0;\n\nerror_report_dma_error:\n\tena_increase_stat(&xdp_ring->tx_stats.dma_mapping_err, 1,\n\t\t\t  &xdp_ring->syncp);\n\tnetif_warn(adapter, tx_queued, adapter->netdev, \"Failed to map xdp buff\\n\");\n\n\treturn -EINVAL;\n}\n\nstatic int ena_xdp_xmit_frame(struct ena_ring *xdp_ring,\n\t\t\t      struct net_device *dev,\n\t\t\t      struct xdp_frame *xdpf,\n\t\t\t      int flags)\n{\n\tstruct ena_com_tx_ctx ena_tx_ctx = {};\n\tstruct ena_tx_buffer *tx_info;\n\tu16 next_to_use, req_id;\n\tint rc;\n\n\tnext_to_use = xdp_ring->next_to_use;\n\treq_id = xdp_ring->free_ids[next_to_use];\n\ttx_info = &xdp_ring->tx_buffer_info[req_id];\n\ttx_info->num_of_bufs = 0;\n\n\trc = ena_xdp_tx_map_frame(xdp_ring, tx_info, xdpf, &ena_tx_ctx);\n\tif (unlikely(rc))\n\t\treturn rc;\n\n\tena_tx_ctx.req_id = req_id;\n\n\trc = ena_xmit_common(dev,\n\t\t\t     xdp_ring,\n\t\t\t     tx_info,\n\t\t\t     &ena_tx_ctx,\n\t\t\t     next_to_use,\n\t\t\t     xdpf->len);\n\tif (rc)\n\t\tgoto error_unmap_dma;\n\n\t \n\tif (flags & XDP_XMIT_FLUSH)\n\t\tena_ring_tx_doorbell(xdp_ring);\n\n\treturn rc;\n\nerror_unmap_dma:\n\tena_unmap_tx_buff(xdp_ring, tx_info);\n\ttx_info->xdpf = NULL;\n\treturn rc;\n}\n\nstatic int ena_xdp_xmit(struct net_device *dev, int n,\n\t\t\tstruct xdp_frame **frames, u32 flags)\n{\n\tstruct ena_adapter *adapter = netdev_priv(dev);\n\tstruct ena_ring *xdp_ring;\n\tint qid, i, nxmit = 0;\n\n\tif (unlikely(flags & ~XDP_XMIT_FLAGS_MASK))\n\t\treturn -EINVAL;\n\n\tif (!test_bit(ENA_FLAG_DEV_UP, &adapter->flags))\n\t\treturn -ENETDOWN;\n\n\t \n\tif (!READ_ONCE(adapter->rx_ring->xdp_bpf_prog))\n\t\treturn -ENXIO;\n\n\tqid = smp_processor_id() % adapter->xdp_num_queues;\n\tqid += adapter->xdp_first_ring;\n\txdp_ring = &adapter->tx_ring[qid];\n\n\t \n\tspin_lock(&xdp_ring->xdp_tx_lock);\n\n\tfor (i = 0; i < n; i++) {\n\t\tif (ena_xdp_xmit_frame(xdp_ring, dev, frames[i], 0))\n\t\t\tbreak;\n\t\tnxmit++;\n\t}\n\n\t \n\tif (flags & XDP_XMIT_FLUSH)\n\t\tena_ring_tx_doorbell(xdp_ring);\n\n\tspin_unlock(&xdp_ring->xdp_tx_lock);\n\n\t \n\treturn nxmit;\n}\n\nstatic int ena_xdp_execute(struct ena_ring *rx_ring, struct xdp_buff *xdp)\n{\n\tu32 verdict = ENA_XDP_PASS;\n\tstruct bpf_prog *xdp_prog;\n\tstruct ena_ring *xdp_ring;\n\tstruct xdp_frame *xdpf;\n\tu64 *xdp_stat;\n\n\txdp_prog = READ_ONCE(rx_ring->xdp_bpf_prog);\n\n\tif (!xdp_prog)\n\t\tgoto out;\n\n\tverdict = bpf_prog_run_xdp(xdp_prog, xdp);\n\n\tswitch (verdict) {\n\tcase XDP_TX:\n\t\txdpf = xdp_convert_buff_to_frame(xdp);\n\t\tif (unlikely(!xdpf)) {\n\t\t\ttrace_xdp_exception(rx_ring->netdev, xdp_prog, verdict);\n\t\t\txdp_stat = &rx_ring->rx_stats.xdp_aborted;\n\t\t\tverdict = ENA_XDP_DROP;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\txdp_ring = rx_ring->xdp_ring;\n\n\t\t \n\t\tspin_lock(&xdp_ring->xdp_tx_lock);\n\n\t\tif (ena_xdp_xmit_frame(xdp_ring, rx_ring->netdev, xdpf,\n\t\t\t\t       XDP_XMIT_FLUSH))\n\t\t\txdp_return_frame(xdpf);\n\n\t\tspin_unlock(&xdp_ring->xdp_tx_lock);\n\t\txdp_stat = &rx_ring->rx_stats.xdp_tx;\n\t\tverdict = ENA_XDP_TX;\n\t\tbreak;\n\tcase XDP_REDIRECT:\n\t\tif (likely(!xdp_do_redirect(rx_ring->netdev, xdp, xdp_prog))) {\n\t\t\txdp_stat = &rx_ring->rx_stats.xdp_redirect;\n\t\t\tverdict = ENA_XDP_REDIRECT;\n\t\t\tbreak;\n\t\t}\n\t\ttrace_xdp_exception(rx_ring->netdev, xdp_prog, verdict);\n\t\txdp_stat = &rx_ring->rx_stats.xdp_aborted;\n\t\tverdict = ENA_XDP_DROP;\n\t\tbreak;\n\tcase XDP_ABORTED:\n\t\ttrace_xdp_exception(rx_ring->netdev, xdp_prog, verdict);\n\t\txdp_stat = &rx_ring->rx_stats.xdp_aborted;\n\t\tverdict = ENA_XDP_DROP;\n\t\tbreak;\n\tcase XDP_DROP:\n\t\txdp_stat = &rx_ring->rx_stats.xdp_drop;\n\t\tverdict = ENA_XDP_DROP;\n\t\tbreak;\n\tcase XDP_PASS:\n\t\txdp_stat = &rx_ring->rx_stats.xdp_pass;\n\t\tverdict = ENA_XDP_PASS;\n\t\tbreak;\n\tdefault:\n\t\tbpf_warn_invalid_xdp_action(rx_ring->netdev, xdp_prog, verdict);\n\t\txdp_stat = &rx_ring->rx_stats.xdp_invalid;\n\t\tverdict = ENA_XDP_DROP;\n\t}\n\n\tena_increase_stat(xdp_stat, 1, &rx_ring->syncp);\nout:\n\treturn verdict;\n}\n\nstatic void ena_init_all_xdp_queues(struct ena_adapter *adapter)\n{\n\tadapter->xdp_first_ring = adapter->num_io_queues;\n\tadapter->xdp_num_queues = adapter->num_io_queues;\n\n\tena_init_io_rings(adapter,\n\t\t\t  adapter->xdp_first_ring,\n\t\t\t  adapter->xdp_num_queues);\n}\n\nstatic int ena_setup_and_create_all_xdp_queues(struct ena_adapter *adapter)\n{\n\tu32 xdp_first_ring = adapter->xdp_first_ring;\n\tu32 xdp_num_queues = adapter->xdp_num_queues;\n\tint rc = 0;\n\n\trc = ena_setup_tx_resources_in_range(adapter, xdp_first_ring, xdp_num_queues);\n\tif (rc)\n\t\tgoto setup_err;\n\n\trc = ena_create_io_tx_queues_in_range(adapter, xdp_first_ring, xdp_num_queues);\n\tif (rc)\n\t\tgoto create_err;\n\n\treturn 0;\n\ncreate_err:\n\tena_free_all_io_tx_resources_in_range(adapter, xdp_first_ring, xdp_num_queues);\nsetup_err:\n\treturn rc;\n}\n\n \nstatic int ena_xdp_register_rxq_info(struct ena_ring *rx_ring)\n{\n\tint rc;\n\n\trc = xdp_rxq_info_reg(&rx_ring->xdp_rxq, rx_ring->netdev, rx_ring->qid, 0);\n\n\tif (rc) {\n\t\tnetif_err(rx_ring->adapter, ifup, rx_ring->netdev,\n\t\t\t  \"Failed to register xdp rx queue info. RX queue num %d rc: %d\\n\",\n\t\t\t  rx_ring->qid, rc);\n\t\tgoto err;\n\t}\n\n\trc = xdp_rxq_info_reg_mem_model(&rx_ring->xdp_rxq, MEM_TYPE_PAGE_SHARED,\n\t\t\t\t\tNULL);\n\n\tif (rc) {\n\t\tnetif_err(rx_ring->adapter, ifup, rx_ring->netdev,\n\t\t\t  \"Failed to register xdp rx queue info memory model. RX queue num %d rc: %d\\n\",\n\t\t\t  rx_ring->qid, rc);\n\t\txdp_rxq_info_unreg(&rx_ring->xdp_rxq);\n\t}\n\nerr:\n\treturn rc;\n}\n\nstatic void ena_xdp_unregister_rxq_info(struct ena_ring *rx_ring)\n{\n\txdp_rxq_info_unreg_mem_model(&rx_ring->xdp_rxq);\n\txdp_rxq_info_unreg(&rx_ring->xdp_rxq);\n}\n\nstatic void ena_xdp_exchange_program_rx_in_range(struct ena_adapter *adapter,\n\t\t\t\t\t\t struct bpf_prog *prog,\n\t\t\t\t\t\t int first, int count)\n{\n\tstruct bpf_prog *old_bpf_prog;\n\tstruct ena_ring *rx_ring;\n\tint i = 0;\n\n\tfor (i = first; i < count; i++) {\n\t\trx_ring = &adapter->rx_ring[i];\n\t\told_bpf_prog = xchg(&rx_ring->xdp_bpf_prog, prog);\n\n\t\tif (!old_bpf_prog && prog) {\n\t\t\tena_xdp_register_rxq_info(rx_ring);\n\t\t\trx_ring->rx_headroom = XDP_PACKET_HEADROOM;\n\t\t} else if (old_bpf_prog && !prog) {\n\t\t\tena_xdp_unregister_rxq_info(rx_ring);\n\t\t\trx_ring->rx_headroom = NET_SKB_PAD;\n\t\t}\n\t}\n}\n\nstatic void ena_xdp_exchange_program(struct ena_adapter *adapter,\n\t\t\t\t     struct bpf_prog *prog)\n{\n\tstruct bpf_prog *old_bpf_prog = xchg(&adapter->xdp_bpf_prog, prog);\n\n\tena_xdp_exchange_program_rx_in_range(adapter,\n\t\t\t\t\t     prog,\n\t\t\t\t\t     0,\n\t\t\t\t\t     adapter->num_io_queues);\n\n\tif (old_bpf_prog)\n\t\tbpf_prog_put(old_bpf_prog);\n}\n\nstatic int ena_destroy_and_free_all_xdp_queues(struct ena_adapter *adapter)\n{\n\tbool was_up;\n\tint rc;\n\n\twas_up = test_bit(ENA_FLAG_DEV_UP, &adapter->flags);\n\n\tif (was_up)\n\t\tena_down(adapter);\n\n\tadapter->xdp_first_ring = 0;\n\tadapter->xdp_num_queues = 0;\n\tena_xdp_exchange_program(adapter, NULL);\n\tif (was_up) {\n\t\trc = ena_up(adapter);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\treturn 0;\n}\n\nstatic int ena_xdp_set(struct net_device *netdev, struct netdev_bpf *bpf)\n{\n\tstruct ena_adapter *adapter = netdev_priv(netdev);\n\tstruct bpf_prog *prog = bpf->prog;\n\tstruct bpf_prog *old_bpf_prog;\n\tint rc, prev_mtu;\n\tbool is_up;\n\n\tis_up = test_bit(ENA_FLAG_DEV_UP, &adapter->flags);\n\trc = ena_xdp_allowed(adapter);\n\tif (rc == ENA_XDP_ALLOWED) {\n\t\told_bpf_prog = adapter->xdp_bpf_prog;\n\t\tif (prog) {\n\t\t\tif (!is_up) {\n\t\t\t\tena_init_all_xdp_queues(adapter);\n\t\t\t} else if (!old_bpf_prog) {\n\t\t\t\tena_down(adapter);\n\t\t\t\tena_init_all_xdp_queues(adapter);\n\t\t\t}\n\t\t\tena_xdp_exchange_program(adapter, prog);\n\n\t\t\tif (is_up && !old_bpf_prog) {\n\t\t\t\trc = ena_up(adapter);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t}\n\t\t\txdp_features_set_redirect_target(netdev, false);\n\t\t} else if (old_bpf_prog) {\n\t\t\txdp_features_clear_redirect_target(netdev);\n\t\t\trc = ena_destroy_and_free_all_xdp_queues(adapter);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t}\n\n\t\tprev_mtu = netdev->max_mtu;\n\t\tnetdev->max_mtu = prog ? ENA_XDP_MAX_MTU : adapter->max_mtu;\n\n\t\tif (!old_bpf_prog)\n\t\t\tnetif_info(adapter, drv, adapter->netdev,\n\t\t\t\t   \"XDP program is set, changing the max_mtu from %d to %d\",\n\t\t\t\t   prev_mtu, netdev->max_mtu);\n\n\t} else if (rc == ENA_XDP_CURRENT_MTU_TOO_LARGE) {\n\t\tnetif_err(adapter, drv, adapter->netdev,\n\t\t\t  \"Failed to set xdp program, the current MTU (%d) is larger than the maximum allowed MTU (%lu) while xdp is on\",\n\t\t\t  netdev->mtu, ENA_XDP_MAX_MTU);\n\t\tNL_SET_ERR_MSG_MOD(bpf->extack,\n\t\t\t\t   \"Failed to set xdp program, the current MTU is larger than the maximum allowed MTU. Check the dmesg for more info\");\n\t\treturn -EINVAL;\n\t} else if (rc == ENA_XDP_NO_ENOUGH_QUEUES) {\n\t\tnetif_err(adapter, drv, adapter->netdev,\n\t\t\t  \"Failed to set xdp program, the Rx/Tx channel count should be at most half of the maximum allowed channel count. The current queue count (%d), the maximal queue count (%d)\\n\",\n\t\t\t  adapter->num_io_queues, adapter->max_num_io_queues);\n\t\tNL_SET_ERR_MSG_MOD(bpf->extack,\n\t\t\t\t   \"Failed to set xdp program, there is no enough space for allocating XDP queues, Check the dmesg for more info\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int ena_xdp(struct net_device *netdev, struct netdev_bpf *bpf)\n{\n\tswitch (bpf->command) {\n\tcase XDP_SETUP_PROG:\n\t\treturn ena_xdp_set(netdev, bpf);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int ena_init_rx_cpu_rmap(struct ena_adapter *adapter)\n{\n#ifdef CONFIG_RFS_ACCEL\n\tu32 i;\n\tint rc;\n\n\tadapter->netdev->rx_cpu_rmap = alloc_irq_cpu_rmap(adapter->num_io_queues);\n\tif (!adapter->netdev->rx_cpu_rmap)\n\t\treturn -ENOMEM;\n\tfor (i = 0; i < adapter->num_io_queues; i++) {\n\t\tint irq_idx = ENA_IO_IRQ_IDX(i);\n\n\t\trc = irq_cpu_rmap_add(adapter->netdev->rx_cpu_rmap,\n\t\t\t\t      pci_irq_vector(adapter->pdev, irq_idx));\n\t\tif (rc) {\n\t\t\tfree_irq_cpu_rmap(adapter->netdev->rx_cpu_rmap);\n\t\t\tadapter->netdev->rx_cpu_rmap = NULL;\n\t\t\treturn rc;\n\t\t}\n\t}\n#endif  \n\treturn 0;\n}\n\nstatic void ena_init_io_rings_common(struct ena_adapter *adapter,\n\t\t\t\t     struct ena_ring *ring, u16 qid)\n{\n\tring->qid = qid;\n\tring->pdev = adapter->pdev;\n\tring->dev = &adapter->pdev->dev;\n\tring->netdev = adapter->netdev;\n\tring->napi = &adapter->ena_napi[qid].napi;\n\tring->adapter = adapter;\n\tring->ena_dev = adapter->ena_dev;\n\tring->per_napi_packets = 0;\n\tring->cpu = 0;\n\tring->numa_node = 0;\n\tring->no_interrupt_event_cnt = 0;\n\tu64_stats_init(&ring->syncp);\n}\n\nstatic void ena_init_io_rings(struct ena_adapter *adapter,\n\t\t\t      int first_index, int count)\n{\n\tstruct ena_com_dev *ena_dev;\n\tstruct ena_ring *txr, *rxr;\n\tint i;\n\n\tena_dev = adapter->ena_dev;\n\n\tfor (i = first_index; i < first_index + count; i++) {\n\t\ttxr = &adapter->tx_ring[i];\n\t\trxr = &adapter->rx_ring[i];\n\n\t\t \n\t\tena_init_io_rings_common(adapter, txr, i);\n\n\t\t \n\t\ttxr->ring_size = adapter->requested_tx_ring_size;\n\t\ttxr->tx_max_header_size = ena_dev->tx_max_header_size;\n\t\ttxr->tx_mem_queue_type = ena_dev->tx_mem_queue_type;\n\t\ttxr->sgl_size = adapter->max_tx_sgl_size;\n\t\ttxr->smoothed_interval =\n\t\t\tena_com_get_nonadaptive_moderation_interval_tx(ena_dev);\n\t\ttxr->disable_meta_caching = adapter->disable_meta_caching;\n\t\tspin_lock_init(&txr->xdp_tx_lock);\n\n\t\t \n\t\tif (!ENA_IS_XDP_INDEX(adapter, i)) {\n\t\t\t \n\t\t\tena_init_io_rings_common(adapter, rxr, i);\n\n\t\t\t \n\t\t\trxr->ring_size = adapter->requested_rx_ring_size;\n\t\t\trxr->rx_copybreak = adapter->rx_copybreak;\n\t\t\trxr->sgl_size = adapter->max_rx_sgl_size;\n\t\t\trxr->smoothed_interval =\n\t\t\t\tena_com_get_nonadaptive_moderation_interval_rx(ena_dev);\n\t\t\trxr->empty_rx_queue = 0;\n\t\t\trxr->rx_headroom = NET_SKB_PAD;\n\t\t\tadapter->ena_napi[i].dim.mode = DIM_CQ_PERIOD_MODE_START_FROM_EQE;\n\t\t\trxr->xdp_ring = &adapter->tx_ring[i + adapter->num_io_queues];\n\t\t}\n\t}\n}\n\n \nstatic int ena_setup_tx_resources(struct ena_adapter *adapter, int qid)\n{\n\tstruct ena_ring *tx_ring = &adapter->tx_ring[qid];\n\tstruct ena_irq *ena_irq = &adapter->irq_tbl[ENA_IO_IRQ_IDX(qid)];\n\tint size, i, node;\n\n\tif (tx_ring->tx_buffer_info) {\n\t\tnetif_err(adapter, ifup,\n\t\t\t  adapter->netdev, \"tx_buffer_info info is not NULL\");\n\t\treturn -EEXIST;\n\t}\n\n\tsize = sizeof(struct ena_tx_buffer) * tx_ring->ring_size;\n\tnode = cpu_to_node(ena_irq->cpu);\n\n\ttx_ring->tx_buffer_info = vzalloc_node(size, node);\n\tif (!tx_ring->tx_buffer_info) {\n\t\ttx_ring->tx_buffer_info = vzalloc(size);\n\t\tif (!tx_ring->tx_buffer_info)\n\t\t\tgoto err_tx_buffer_info;\n\t}\n\n\tsize = sizeof(u16) * tx_ring->ring_size;\n\ttx_ring->free_ids = vzalloc_node(size, node);\n\tif (!tx_ring->free_ids) {\n\t\ttx_ring->free_ids = vzalloc(size);\n\t\tif (!tx_ring->free_ids)\n\t\t\tgoto err_tx_free_ids;\n\t}\n\n\tsize = tx_ring->tx_max_header_size;\n\ttx_ring->push_buf_intermediate_buf = vzalloc_node(size, node);\n\tif (!tx_ring->push_buf_intermediate_buf) {\n\t\ttx_ring->push_buf_intermediate_buf = vzalloc(size);\n\t\tif (!tx_ring->push_buf_intermediate_buf)\n\t\t\tgoto err_push_buf_intermediate_buf;\n\t}\n\n\t \n\tfor (i = 0; i < tx_ring->ring_size; i++)\n\t\ttx_ring->free_ids[i] = i;\n\n\t \n\tmemset(&tx_ring->tx_stats, 0x0, sizeof(tx_ring->tx_stats));\n\n\ttx_ring->next_to_use = 0;\n\ttx_ring->next_to_clean = 0;\n\ttx_ring->cpu = ena_irq->cpu;\n\ttx_ring->numa_node = node;\n\treturn 0;\n\nerr_push_buf_intermediate_buf:\n\tvfree(tx_ring->free_ids);\n\ttx_ring->free_ids = NULL;\nerr_tx_free_ids:\n\tvfree(tx_ring->tx_buffer_info);\n\ttx_ring->tx_buffer_info = NULL;\nerr_tx_buffer_info:\n\treturn -ENOMEM;\n}\n\n \nstatic void ena_free_tx_resources(struct ena_adapter *adapter, int qid)\n{\n\tstruct ena_ring *tx_ring = &adapter->tx_ring[qid];\n\n\tvfree(tx_ring->tx_buffer_info);\n\ttx_ring->tx_buffer_info = NULL;\n\n\tvfree(tx_ring->free_ids);\n\ttx_ring->free_ids = NULL;\n\n\tvfree(tx_ring->push_buf_intermediate_buf);\n\ttx_ring->push_buf_intermediate_buf = NULL;\n}\n\nstatic int ena_setup_tx_resources_in_range(struct ena_adapter *adapter,\n\t\t\t\t\t   int first_index,\n\t\t\t\t\t   int count)\n{\n\tint i, rc = 0;\n\n\tfor (i = first_index; i < first_index + count; i++) {\n\t\trc = ena_setup_tx_resources(adapter, i);\n\t\tif (rc)\n\t\t\tgoto err_setup_tx;\n\t}\n\n\treturn 0;\n\nerr_setup_tx:\n\n\tnetif_err(adapter, ifup, adapter->netdev,\n\t\t  \"Tx queue %d: allocation failed\\n\", i);\n\n\t \n\twhile (first_index < i--)\n\t\tena_free_tx_resources(adapter, i);\n\treturn rc;\n}\n\nstatic void ena_free_all_io_tx_resources_in_range(struct ena_adapter *adapter,\n\t\t\t\t\t\t  int first_index, int count)\n{\n\tint i;\n\n\tfor (i = first_index; i < first_index + count; i++)\n\t\tena_free_tx_resources(adapter, i);\n}\n\n \nstatic void ena_free_all_io_tx_resources(struct ena_adapter *adapter)\n{\n\tena_free_all_io_tx_resources_in_range(adapter,\n\t\t\t\t\t      0,\n\t\t\t\t\t      adapter->xdp_num_queues +\n\t\t\t\t\t      adapter->num_io_queues);\n}\n\n \nstatic int ena_setup_rx_resources(struct ena_adapter *adapter,\n\t\t\t\t  u32 qid)\n{\n\tstruct ena_ring *rx_ring = &adapter->rx_ring[qid];\n\tstruct ena_irq *ena_irq = &adapter->irq_tbl[ENA_IO_IRQ_IDX(qid)];\n\tint size, node, i;\n\n\tif (rx_ring->rx_buffer_info) {\n\t\tnetif_err(adapter, ifup, adapter->netdev,\n\t\t\t  \"rx_buffer_info is not NULL\");\n\t\treturn -EEXIST;\n\t}\n\n\t \n\tsize = sizeof(struct ena_rx_buffer) * (rx_ring->ring_size + 1);\n\tnode = cpu_to_node(ena_irq->cpu);\n\n\trx_ring->rx_buffer_info = vzalloc_node(size, node);\n\tif (!rx_ring->rx_buffer_info) {\n\t\trx_ring->rx_buffer_info = vzalloc(size);\n\t\tif (!rx_ring->rx_buffer_info)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tsize = sizeof(u16) * rx_ring->ring_size;\n\trx_ring->free_ids = vzalloc_node(size, node);\n\tif (!rx_ring->free_ids) {\n\t\trx_ring->free_ids = vzalloc(size);\n\t\tif (!rx_ring->free_ids) {\n\t\t\tvfree(rx_ring->rx_buffer_info);\n\t\t\trx_ring->rx_buffer_info = NULL;\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < rx_ring->ring_size; i++)\n\t\trx_ring->free_ids[i] = i;\n\n\t \n\tmemset(&rx_ring->rx_stats, 0x0, sizeof(rx_ring->rx_stats));\n\n\trx_ring->next_to_clean = 0;\n\trx_ring->next_to_use = 0;\n\trx_ring->cpu = ena_irq->cpu;\n\trx_ring->numa_node = node;\n\n\treturn 0;\n}\n\n \nstatic void ena_free_rx_resources(struct ena_adapter *adapter,\n\t\t\t\t  u32 qid)\n{\n\tstruct ena_ring *rx_ring = &adapter->rx_ring[qid];\n\n\tvfree(rx_ring->rx_buffer_info);\n\trx_ring->rx_buffer_info = NULL;\n\n\tvfree(rx_ring->free_ids);\n\trx_ring->free_ids = NULL;\n}\n\n \nstatic int ena_setup_all_rx_resources(struct ena_adapter *adapter)\n{\n\tint i, rc = 0;\n\n\tfor (i = 0; i < adapter->num_io_queues; i++) {\n\t\trc = ena_setup_rx_resources(adapter, i);\n\t\tif (rc)\n\t\t\tgoto err_setup_rx;\n\t}\n\n\treturn 0;\n\nerr_setup_rx:\n\n\tnetif_err(adapter, ifup, adapter->netdev,\n\t\t  \"Rx queue %d: allocation failed\\n\", i);\n\n\t \n\twhile (i--)\n\t\tena_free_rx_resources(adapter, i);\n\treturn rc;\n}\n\n \nstatic void ena_free_all_io_rx_resources(struct ena_adapter *adapter)\n{\n\tint i;\n\n\tfor (i = 0; i < adapter->num_io_queues; i++)\n\t\tena_free_rx_resources(adapter, i);\n}\n\nstatic struct page *ena_alloc_map_page(struct ena_ring *rx_ring,\n\t\t\t\t       dma_addr_t *dma)\n{\n\tstruct page *page;\n\n\t \n\tpage = dev_alloc_page();\n\tif (!page) {\n\t\tena_increase_stat(&rx_ring->rx_stats.page_alloc_fail, 1,\n\t\t\t\t  &rx_ring->syncp);\n\t\treturn ERR_PTR(-ENOSPC);\n\t}\n\n\t \n\t*dma = dma_map_page(rx_ring->dev, page, 0, ENA_PAGE_SIZE,\n\t\t\t    DMA_BIDIRECTIONAL);\n\tif (unlikely(dma_mapping_error(rx_ring->dev, *dma))) {\n\t\tena_increase_stat(&rx_ring->rx_stats.dma_mapping_err, 1,\n\t\t\t\t  &rx_ring->syncp);\n\t\t__free_page(page);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\n\treturn page;\n}\n\nstatic int ena_alloc_rx_buffer(struct ena_ring *rx_ring,\n\t\t\t       struct ena_rx_buffer *rx_info)\n{\n\tint headroom = rx_ring->rx_headroom;\n\tstruct ena_com_buf *ena_buf;\n\tstruct page *page;\n\tdma_addr_t dma;\n\tint tailroom;\n\n\t \n\trx_info->buf_offset = headroom;\n\n\t \n\tif (unlikely(rx_info->page))\n\t\treturn 0;\n\n\t \n\tpage = ena_alloc_map_page(rx_ring, &dma);\n\tif (unlikely(IS_ERR(page)))\n\t\treturn PTR_ERR(page);\n\n\tnetif_dbg(rx_ring->adapter, rx_status, rx_ring->netdev,\n\t\t  \"Allocate page %p, rx_info %p\\n\", page, rx_info);\n\n\ttailroom = SKB_DATA_ALIGN(sizeof(struct skb_shared_info));\n\n\trx_info->page = page;\n\trx_info->dma_addr = dma;\n\trx_info->page_offset = 0;\n\tena_buf = &rx_info->ena_buf;\n\tena_buf->paddr = dma + headroom;\n\tena_buf->len = ENA_PAGE_SIZE - headroom - tailroom;\n\n\treturn 0;\n}\n\nstatic void ena_unmap_rx_buff_attrs(struct ena_ring *rx_ring,\n\t\t\t\t    struct ena_rx_buffer *rx_info,\n\t\t\t\t    unsigned long attrs)\n{\n\tdma_unmap_page_attrs(rx_ring->dev, rx_info->dma_addr, ENA_PAGE_SIZE,\n\t\t\t     DMA_BIDIRECTIONAL, attrs);\n}\n\nstatic void ena_free_rx_page(struct ena_ring *rx_ring,\n\t\t\t     struct ena_rx_buffer *rx_info)\n{\n\tstruct page *page = rx_info->page;\n\n\tif (unlikely(!page)) {\n\t\tnetif_warn(rx_ring->adapter, rx_err, rx_ring->netdev,\n\t\t\t   \"Trying to free unallocated buffer\\n\");\n\t\treturn;\n\t}\n\n\tena_unmap_rx_buff_attrs(rx_ring, rx_info, 0);\n\n\t__free_page(page);\n\trx_info->page = NULL;\n}\n\nstatic int ena_refill_rx_bufs(struct ena_ring *rx_ring, u32 num)\n{\n\tu16 next_to_use, req_id;\n\tu32 i;\n\tint rc;\n\n\tnext_to_use = rx_ring->next_to_use;\n\n\tfor (i = 0; i < num; i++) {\n\t\tstruct ena_rx_buffer *rx_info;\n\n\t\treq_id = rx_ring->free_ids[next_to_use];\n\n\t\trx_info = &rx_ring->rx_buffer_info[req_id];\n\n\t\trc = ena_alloc_rx_buffer(rx_ring, rx_info);\n\t\tif (unlikely(rc < 0)) {\n\t\t\tnetif_warn(rx_ring->adapter, rx_err, rx_ring->netdev,\n\t\t\t\t   \"Failed to allocate buffer for rx queue %d\\n\",\n\t\t\t\t   rx_ring->qid);\n\t\t\tbreak;\n\t\t}\n\t\trc = ena_com_add_single_rx_desc(rx_ring->ena_com_io_sq,\n\t\t\t\t\t\t&rx_info->ena_buf,\n\t\t\t\t\t\treq_id);\n\t\tif (unlikely(rc)) {\n\t\t\tnetif_warn(rx_ring->adapter, rx_status, rx_ring->netdev,\n\t\t\t\t   \"Failed to add buffer for rx queue %d\\n\",\n\t\t\t\t   rx_ring->qid);\n\t\t\tbreak;\n\t\t}\n\t\tnext_to_use = ENA_RX_RING_IDX_NEXT(next_to_use,\n\t\t\t\t\t\t   rx_ring->ring_size);\n\t}\n\n\tif (unlikely(i < num)) {\n\t\tena_increase_stat(&rx_ring->rx_stats.refil_partial, 1,\n\t\t\t\t  &rx_ring->syncp);\n\t\tnetif_warn(rx_ring->adapter, rx_err, rx_ring->netdev,\n\t\t\t   \"Refilled rx qid %d with only %d buffers (from %d)\\n\",\n\t\t\t   rx_ring->qid, i, num);\n\t}\n\n\t \n\tif (likely(i))\n\t\tena_com_write_sq_doorbell(rx_ring->ena_com_io_sq);\n\n\trx_ring->next_to_use = next_to_use;\n\n\treturn i;\n}\n\nstatic void ena_free_rx_bufs(struct ena_adapter *adapter,\n\t\t\t     u32 qid)\n{\n\tstruct ena_ring *rx_ring = &adapter->rx_ring[qid];\n\tu32 i;\n\n\tfor (i = 0; i < rx_ring->ring_size; i++) {\n\t\tstruct ena_rx_buffer *rx_info = &rx_ring->rx_buffer_info[i];\n\n\t\tif (rx_info->page)\n\t\t\tena_free_rx_page(rx_ring, rx_info);\n\t}\n}\n\n \nstatic void ena_refill_all_rx_bufs(struct ena_adapter *adapter)\n{\n\tstruct ena_ring *rx_ring;\n\tint i, rc, bufs_num;\n\n\tfor (i = 0; i < adapter->num_io_queues; i++) {\n\t\trx_ring = &adapter->rx_ring[i];\n\t\tbufs_num = rx_ring->ring_size - 1;\n\t\trc = ena_refill_rx_bufs(rx_ring, bufs_num);\n\n\t\tif (unlikely(rc != bufs_num))\n\t\t\tnetif_warn(rx_ring->adapter, rx_status, rx_ring->netdev,\n\t\t\t\t   \"Refilling Queue %d failed. allocated %d buffers from: %d\\n\",\n\t\t\t\t   i, rc, bufs_num);\n\t}\n}\n\nstatic void ena_free_all_rx_bufs(struct ena_adapter *adapter)\n{\n\tint i;\n\n\tfor (i = 0; i < adapter->num_io_queues; i++)\n\t\tena_free_rx_bufs(adapter, i);\n}\n\nstatic void ena_unmap_tx_buff(struct ena_ring *tx_ring,\n\t\t\t      struct ena_tx_buffer *tx_info)\n{\n\tstruct ena_com_buf *ena_buf;\n\tu32 cnt;\n\tint i;\n\n\tena_buf = tx_info->bufs;\n\tcnt = tx_info->num_of_bufs;\n\n\tif (unlikely(!cnt))\n\t\treturn;\n\n\tif (tx_info->map_linear_data) {\n\t\tdma_unmap_single(tx_ring->dev,\n\t\t\t\t dma_unmap_addr(ena_buf, paddr),\n\t\t\t\t dma_unmap_len(ena_buf, len),\n\t\t\t\t DMA_TO_DEVICE);\n\t\tena_buf++;\n\t\tcnt--;\n\t}\n\n\t \n\tfor (i = 0; i < cnt; i++) {\n\t\tdma_unmap_page(tx_ring->dev, dma_unmap_addr(ena_buf, paddr),\n\t\t\t       dma_unmap_len(ena_buf, len), DMA_TO_DEVICE);\n\t\tena_buf++;\n\t}\n}\n\n \nstatic void ena_free_tx_bufs(struct ena_ring *tx_ring)\n{\n\tbool print_once = true;\n\tu32 i;\n\n\tfor (i = 0; i < tx_ring->ring_size; i++) {\n\t\tstruct ena_tx_buffer *tx_info = &tx_ring->tx_buffer_info[i];\n\n\t\tif (!tx_info->skb)\n\t\t\tcontinue;\n\n\t\tif (print_once) {\n\t\t\tnetif_notice(tx_ring->adapter, ifdown, tx_ring->netdev,\n\t\t\t\t     \"Free uncompleted tx skb qid %d idx 0x%x\\n\",\n\t\t\t\t     tx_ring->qid, i);\n\t\t\tprint_once = false;\n\t\t} else {\n\t\t\tnetif_dbg(tx_ring->adapter, ifdown, tx_ring->netdev,\n\t\t\t\t  \"Free uncompleted tx skb qid %d idx 0x%x\\n\",\n\t\t\t\t  tx_ring->qid, i);\n\t\t}\n\n\t\tena_unmap_tx_buff(tx_ring, tx_info);\n\n\t\tdev_kfree_skb_any(tx_info->skb);\n\t}\n\tnetdev_tx_reset_queue(netdev_get_tx_queue(tx_ring->netdev,\n\t\t\t\t\t\t  tx_ring->qid));\n}\n\nstatic void ena_free_all_tx_bufs(struct ena_adapter *adapter)\n{\n\tstruct ena_ring *tx_ring;\n\tint i;\n\n\tfor (i = 0; i < adapter->num_io_queues + adapter->xdp_num_queues; i++) {\n\t\ttx_ring = &adapter->tx_ring[i];\n\t\tena_free_tx_bufs(tx_ring);\n\t}\n}\n\nstatic void ena_destroy_all_tx_queues(struct ena_adapter *adapter)\n{\n\tu16 ena_qid;\n\tint i;\n\n\tfor (i = 0; i < adapter->num_io_queues + adapter->xdp_num_queues; i++) {\n\t\tena_qid = ENA_IO_TXQ_IDX(i);\n\t\tena_com_destroy_io_queue(adapter->ena_dev, ena_qid);\n\t}\n}\n\nstatic void ena_destroy_all_rx_queues(struct ena_adapter *adapter)\n{\n\tu16 ena_qid;\n\tint i;\n\n\tfor (i = 0; i < adapter->num_io_queues; i++) {\n\t\tena_qid = ENA_IO_RXQ_IDX(i);\n\t\tcancel_work_sync(&adapter->ena_napi[i].dim.work);\n\t\tena_com_destroy_io_queue(adapter->ena_dev, ena_qid);\n\t}\n}\n\nstatic void ena_destroy_all_io_queues(struct ena_adapter *adapter)\n{\n\tena_destroy_all_tx_queues(adapter);\n\tena_destroy_all_rx_queues(adapter);\n}\n\nstatic int handle_invalid_req_id(struct ena_ring *ring, u16 req_id,\n\t\t\t\t struct ena_tx_buffer *tx_info, bool is_xdp)\n{\n\tif (tx_info)\n\t\tnetif_err(ring->adapter,\n\t\t\t  tx_done,\n\t\t\t  ring->netdev,\n\t\t\t  \"tx_info doesn't have valid %s. qid %u req_id %u\",\n\t\t\t   is_xdp ? \"xdp frame\" : \"skb\", ring->qid, req_id);\n\telse\n\t\tnetif_err(ring->adapter,\n\t\t\t  tx_done,\n\t\t\t  ring->netdev,\n\t\t\t  \"Invalid req_id %u in qid %u\\n\",\n\t\t\t  req_id, ring->qid);\n\n\tena_increase_stat(&ring->tx_stats.bad_req_id, 1, &ring->syncp);\n\tena_reset_device(ring->adapter, ENA_REGS_RESET_INV_TX_REQ_ID);\n\n\treturn -EFAULT;\n}\n\nstatic int validate_tx_req_id(struct ena_ring *tx_ring, u16 req_id)\n{\n\tstruct ena_tx_buffer *tx_info;\n\n\ttx_info = &tx_ring->tx_buffer_info[req_id];\n\tif (likely(tx_info->skb))\n\t\treturn 0;\n\n\treturn handle_invalid_req_id(tx_ring, req_id, tx_info, false);\n}\n\nstatic int validate_xdp_req_id(struct ena_ring *xdp_ring, u16 req_id)\n{\n\tstruct ena_tx_buffer *tx_info;\n\n\ttx_info = &xdp_ring->tx_buffer_info[req_id];\n\tif (likely(tx_info->xdpf))\n\t\treturn 0;\n\n\treturn handle_invalid_req_id(xdp_ring, req_id, tx_info, true);\n}\n\nstatic int ena_clean_tx_irq(struct ena_ring *tx_ring, u32 budget)\n{\n\tstruct netdev_queue *txq;\n\tbool above_thresh;\n\tu32 tx_bytes = 0;\n\tu32 total_done = 0;\n\tu16 next_to_clean;\n\tu16 req_id;\n\tint tx_pkts = 0;\n\tint rc;\n\n\tnext_to_clean = tx_ring->next_to_clean;\n\ttxq = netdev_get_tx_queue(tx_ring->netdev, tx_ring->qid);\n\n\twhile (tx_pkts < budget) {\n\t\tstruct ena_tx_buffer *tx_info;\n\t\tstruct sk_buff *skb;\n\n\t\trc = ena_com_tx_comp_req_id_get(tx_ring->ena_com_io_cq,\n\t\t\t\t\t\t&req_id);\n\t\tif (rc) {\n\t\t\tif (unlikely(rc == -EINVAL))\n\t\t\t\thandle_invalid_req_id(tx_ring, req_id, NULL,\n\t\t\t\t\t\t      false);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\trc = validate_tx_req_id(tx_ring, req_id);\n\t\tif (rc)\n\t\t\tbreak;\n\n\t\ttx_info = &tx_ring->tx_buffer_info[req_id];\n\t\tskb = tx_info->skb;\n\n\t\t \n\t\tprefetch(&skb->end);\n\n\t\ttx_info->skb = NULL;\n\t\ttx_info->last_jiffies = 0;\n\n\t\tena_unmap_tx_buff(tx_ring, tx_info);\n\n\t\tnetif_dbg(tx_ring->adapter, tx_done, tx_ring->netdev,\n\t\t\t  \"tx_poll: q %d skb %p completed\\n\", tx_ring->qid,\n\t\t\t  skb);\n\n\t\ttx_bytes += skb->len;\n\t\tdev_kfree_skb(skb);\n\t\ttx_pkts++;\n\t\ttotal_done += tx_info->tx_descs;\n\n\t\ttx_ring->free_ids[next_to_clean] = req_id;\n\t\tnext_to_clean = ENA_TX_RING_IDX_NEXT(next_to_clean,\n\t\t\t\t\t\t     tx_ring->ring_size);\n\t}\n\n\ttx_ring->next_to_clean = next_to_clean;\n\tena_com_comp_ack(tx_ring->ena_com_io_sq, total_done);\n\tena_com_update_dev_comp_head(tx_ring->ena_com_io_cq);\n\n\tnetdev_tx_completed_queue(txq, tx_pkts, tx_bytes);\n\n\tnetif_dbg(tx_ring->adapter, tx_done, tx_ring->netdev,\n\t\t  \"tx_poll: q %d done. total pkts: %d\\n\",\n\t\t  tx_ring->qid, tx_pkts);\n\n\t \n\tsmp_mb();\n\n\tabove_thresh = ena_com_sq_have_enough_space(tx_ring->ena_com_io_sq,\n\t\t\t\t\t\t    ENA_TX_WAKEUP_THRESH);\n\tif (unlikely(netif_tx_queue_stopped(txq) && above_thresh)) {\n\t\t__netif_tx_lock(txq, smp_processor_id());\n\t\tabove_thresh =\n\t\t\tena_com_sq_have_enough_space(tx_ring->ena_com_io_sq,\n\t\t\t\t\t\t     ENA_TX_WAKEUP_THRESH);\n\t\tif (netif_tx_queue_stopped(txq) && above_thresh &&\n\t\t    test_bit(ENA_FLAG_DEV_UP, &tx_ring->adapter->flags)) {\n\t\t\tnetif_tx_wake_queue(txq);\n\t\t\tena_increase_stat(&tx_ring->tx_stats.queue_wakeup, 1,\n\t\t\t\t\t  &tx_ring->syncp);\n\t\t}\n\t\t__netif_tx_unlock(txq);\n\t}\n\n\treturn tx_pkts;\n}\n\nstatic struct sk_buff *ena_alloc_skb(struct ena_ring *rx_ring, void *first_frag, u16 len)\n{\n\tstruct sk_buff *skb;\n\n\tif (!first_frag)\n\t\tskb = napi_alloc_skb(rx_ring->napi, len);\n\telse\n\t\tskb = napi_build_skb(first_frag, len);\n\n\tif (unlikely(!skb)) {\n\t\tena_increase_stat(&rx_ring->rx_stats.skb_alloc_fail, 1,\n\t\t\t\t  &rx_ring->syncp);\n\n\t\tnetif_dbg(rx_ring->adapter, rx_err, rx_ring->netdev,\n\t\t\t  \"Failed to allocate skb. first_frag %s\\n\",\n\t\t\t  first_frag ? \"provided\" : \"not provided\");\n\t}\n\n\treturn skb;\n}\n\nstatic bool ena_try_rx_buf_page_reuse(struct ena_rx_buffer *rx_info, u16 buf_len,\n\t\t\t\t      u16 len, int pkt_offset)\n{\n\tstruct ena_com_buf *ena_buf = &rx_info->ena_buf;\n\n\t \n\tif (SKB_DATA_ALIGN(len + pkt_offset) + ENA_MIN_RX_BUF_SIZE <= ena_buf->len) {\n\t\tpage_ref_inc(rx_info->page);\n\t\trx_info->page_offset += buf_len;\n\t\tena_buf->paddr += buf_len;\n\t\tena_buf->len -= buf_len;\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic struct sk_buff *ena_rx_skb(struct ena_ring *rx_ring,\n\t\t\t\t  struct ena_com_rx_buf_info *ena_bufs,\n\t\t\t\t  u32 descs,\n\t\t\t\t  u16 *next_to_clean)\n{\n\tint tailroom = SKB_DATA_ALIGN(sizeof(struct skb_shared_info));\n\tbool is_xdp_loaded = ena_xdp_present_ring(rx_ring);\n\tstruct ena_rx_buffer *rx_info;\n\tstruct ena_adapter *adapter;\n\tint page_offset, pkt_offset;\n\tdma_addr_t pre_reuse_paddr;\n\tu16 len, req_id, buf = 0;\n\tbool reuse_rx_buf_page;\n\tstruct sk_buff *skb;\n\tvoid *buf_addr;\n\tint buf_offset;\n\tu16 buf_len;\n\n\tlen = ena_bufs[buf].len;\n\treq_id = ena_bufs[buf].req_id;\n\n\trx_info = &rx_ring->rx_buffer_info[req_id];\n\n\tif (unlikely(!rx_info->page)) {\n\t\tadapter = rx_ring->adapter;\n\t\tnetif_err(adapter, rx_err, rx_ring->netdev,\n\t\t\t  \"Page is NULL. qid %u req_id %u\\n\", rx_ring->qid, req_id);\n\t\tena_increase_stat(&rx_ring->rx_stats.bad_req_id, 1, &rx_ring->syncp);\n\t\tena_reset_device(adapter, ENA_REGS_RESET_INV_RX_REQ_ID);\n\t\treturn NULL;\n\t}\n\n\tnetif_dbg(rx_ring->adapter, rx_status, rx_ring->netdev,\n\t\t  \"rx_info %p page %p\\n\",\n\t\t  rx_info, rx_info->page);\n\n\tbuf_offset = rx_info->buf_offset;\n\tpkt_offset = buf_offset - rx_ring->rx_headroom;\n\tpage_offset = rx_info->page_offset;\n\tbuf_addr = page_address(rx_info->page) + page_offset;\n\n\tif (len <= rx_ring->rx_copybreak) {\n\t\tskb = ena_alloc_skb(rx_ring, NULL, len);\n\t\tif (unlikely(!skb))\n\t\t\treturn NULL;\n\n\t\tskb_copy_to_linear_data(skb, buf_addr + buf_offset, len);\n\t\tdma_sync_single_for_device(rx_ring->dev,\n\t\t\t\t\t   dma_unmap_addr(&rx_info->ena_buf, paddr) + pkt_offset,\n\t\t\t\t\t   len,\n\t\t\t\t\t   DMA_FROM_DEVICE);\n\n\t\tskb_put(skb, len);\n\t\tnetif_dbg(rx_ring->adapter, rx_status, rx_ring->netdev,\n\t\t\t  \"RX allocated small packet. len %d.\\n\", skb->len);\n\t\tskb->protocol = eth_type_trans(skb, rx_ring->netdev);\n\t\trx_ring->free_ids[*next_to_clean] = req_id;\n\t\t*next_to_clean = ENA_RX_RING_IDX_ADD(*next_to_clean, descs,\n\t\t\t\t\t\t     rx_ring->ring_size);\n\t\treturn skb;\n\t}\n\n\tbuf_len = SKB_DATA_ALIGN(len + buf_offset + tailroom);\n\n\t \n\treuse_rx_buf_page = !is_xdp_loaded &&\n\t\t\t    ena_try_rx_buf_page_reuse(rx_info, buf_len, len, pkt_offset);\n\n\tif (!reuse_rx_buf_page)\n\t\tena_unmap_rx_buff_attrs(rx_ring, rx_info, DMA_ATTR_SKIP_CPU_SYNC);\n\n\tskb = ena_alloc_skb(rx_ring, buf_addr, buf_len);\n\tif (unlikely(!skb))\n\t\treturn NULL;\n\n\t \n\tskb_reserve(skb, buf_offset);\n\tskb_put(skb, len);\n\tskb->protocol = eth_type_trans(skb, rx_ring->netdev);\n\n\tdo {\n\t\tnetif_dbg(rx_ring->adapter, rx_status, rx_ring->netdev,\n\t\t\t  \"RX skb updated. len %d. data_len %d\\n\",\n\t\t\t  skb->len, skb->data_len);\n\n\t\tif (!reuse_rx_buf_page)\n\t\t\trx_info->page = NULL;\n\n\t\trx_ring->free_ids[*next_to_clean] = req_id;\n\t\t*next_to_clean =\n\t\t\tENA_RX_RING_IDX_NEXT(*next_to_clean,\n\t\t\t\t\t     rx_ring->ring_size);\n\t\tif (likely(--descs == 0))\n\t\t\tbreak;\n\n\t\tbuf++;\n\t\tlen = ena_bufs[buf].len;\n\t\treq_id = ena_bufs[buf].req_id;\n\n\t\trx_info = &rx_ring->rx_buffer_info[req_id];\n\n\t\t \n\t\tbuf_offset = rx_info->buf_offset;\n\t\tpkt_offset = buf_offset - rx_ring->rx_headroom;\n\t\tbuf_len = SKB_DATA_ALIGN(len + buf_offset + tailroom);\n\t\tpage_offset = rx_info->page_offset;\n\n\t\tpre_reuse_paddr = dma_unmap_addr(&rx_info->ena_buf, paddr);\n\n\t\treuse_rx_buf_page = !is_xdp_loaded &&\n\t\t\t\t    ena_try_rx_buf_page_reuse(rx_info, buf_len, len, pkt_offset);\n\n\t\tdma_sync_single_for_cpu(rx_ring->dev,\n\t\t\t\t\tpre_reuse_paddr + pkt_offset,\n\t\t\t\t\tlen,\n\t\t\t\t\tDMA_FROM_DEVICE);\n\n\t\tif (!reuse_rx_buf_page)\n\t\t\tena_unmap_rx_buff_attrs(rx_ring, rx_info,\n\t\t\t\t\t\tDMA_ATTR_SKIP_CPU_SYNC);\n\n\t\tskb_add_rx_frag(skb, skb_shinfo(skb)->nr_frags, rx_info->page,\n\t\t\t\tpage_offset + buf_offset, len, buf_len);\n\n\t} while (1);\n\n\treturn skb;\n}\n\n \nstatic void ena_rx_checksum(struct ena_ring *rx_ring,\n\t\t\t\t   struct ena_com_rx_ctx *ena_rx_ctx,\n\t\t\t\t   struct sk_buff *skb)\n{\n\t \n\tif (unlikely(!(rx_ring->netdev->features & NETIF_F_RXCSUM))) {\n\t\tskb->ip_summed = CHECKSUM_NONE;\n\t\treturn;\n\t}\n\n\t \n\tif (ena_rx_ctx->frag) {\n\t\tskb->ip_summed = CHECKSUM_NONE;\n\t\treturn;\n\t}\n\n\t \n\tif (unlikely((ena_rx_ctx->l3_proto == ENA_ETH_IO_L3_PROTO_IPV4) &&\n\t\t     (ena_rx_ctx->l3_csum_err))) {\n\t\t \n\t\tskb->ip_summed = CHECKSUM_NONE;\n\t\tena_increase_stat(&rx_ring->rx_stats.csum_bad, 1,\n\t\t\t\t  &rx_ring->syncp);\n\t\tnetif_dbg(rx_ring->adapter, rx_err, rx_ring->netdev,\n\t\t\t  \"RX IPv4 header checksum error\\n\");\n\t\treturn;\n\t}\n\n\t \n\tif (likely((ena_rx_ctx->l4_proto == ENA_ETH_IO_L4_PROTO_TCP) ||\n\t\t   (ena_rx_ctx->l4_proto == ENA_ETH_IO_L4_PROTO_UDP))) {\n\t\tif (unlikely(ena_rx_ctx->l4_csum_err)) {\n\t\t\t \n\t\t\tena_increase_stat(&rx_ring->rx_stats.csum_bad, 1,\n\t\t\t\t\t  &rx_ring->syncp);\n\t\t\tnetif_dbg(rx_ring->adapter, rx_err, rx_ring->netdev,\n\t\t\t\t  \"RX L4 checksum error\\n\");\n\t\t\tskb->ip_summed = CHECKSUM_NONE;\n\t\t\treturn;\n\t\t}\n\n\t\tif (likely(ena_rx_ctx->l4_csum_checked)) {\n\t\t\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\t\t\tena_increase_stat(&rx_ring->rx_stats.csum_good, 1,\n\t\t\t\t\t  &rx_ring->syncp);\n\t\t} else {\n\t\t\tena_increase_stat(&rx_ring->rx_stats.csum_unchecked, 1,\n\t\t\t\t\t  &rx_ring->syncp);\n\t\t\tskb->ip_summed = CHECKSUM_NONE;\n\t\t}\n\t} else {\n\t\tskb->ip_summed = CHECKSUM_NONE;\n\t\treturn;\n\t}\n\n}\n\nstatic void ena_set_rx_hash(struct ena_ring *rx_ring,\n\t\t\t    struct ena_com_rx_ctx *ena_rx_ctx,\n\t\t\t    struct sk_buff *skb)\n{\n\tenum pkt_hash_types hash_type;\n\n\tif (likely(rx_ring->netdev->features & NETIF_F_RXHASH)) {\n\t\tif (likely((ena_rx_ctx->l4_proto == ENA_ETH_IO_L4_PROTO_TCP) ||\n\t\t\t   (ena_rx_ctx->l4_proto == ENA_ETH_IO_L4_PROTO_UDP)))\n\n\t\t\thash_type = PKT_HASH_TYPE_L4;\n\t\telse\n\t\t\thash_type = PKT_HASH_TYPE_NONE;\n\n\t\t \n\t\tif (ena_rx_ctx->frag)\n\t\t\thash_type = PKT_HASH_TYPE_NONE;\n\n\t\tskb_set_hash(skb, ena_rx_ctx->hash, hash_type);\n\t}\n}\n\nstatic int ena_xdp_handle_buff(struct ena_ring *rx_ring, struct xdp_buff *xdp, u16 num_descs)\n{\n\tstruct ena_rx_buffer *rx_info;\n\tint ret;\n\n\t \n\tif (unlikely(num_descs > 1)) {\n\t\tnetdev_err_once(rx_ring->adapter->netdev,\n\t\t\t\t\"xdp: dropped unsupported multi-buffer packets\\n\");\n\t\tena_increase_stat(&rx_ring->rx_stats.xdp_drop, 1, &rx_ring->syncp);\n\t\treturn ENA_XDP_DROP;\n\t}\n\n\trx_info = &rx_ring->rx_buffer_info[rx_ring->ena_bufs[0].req_id];\n\txdp_prepare_buff(xdp, page_address(rx_info->page),\n\t\t\t rx_info->buf_offset,\n\t\t\t rx_ring->ena_bufs[0].len, false);\n\n\tret = ena_xdp_execute(rx_ring, xdp);\n\n\t \n\tif (ret == ENA_XDP_PASS) {\n\t\trx_info->buf_offset = xdp->data - xdp->data_hard_start;\n\t\trx_ring->ena_bufs[0].len = xdp->data_end - xdp->data;\n\t}\n\n\treturn ret;\n}\n \nstatic int ena_clean_rx_irq(struct ena_ring *rx_ring, struct napi_struct *napi,\n\t\t\t    u32 budget)\n{\n\tu16 next_to_clean = rx_ring->next_to_clean;\n\tstruct ena_com_rx_ctx ena_rx_ctx;\n\tstruct ena_rx_buffer *rx_info;\n\tstruct ena_adapter *adapter;\n\tu32 res_budget, work_done;\n\tint rx_copybreak_pkt = 0;\n\tint refill_threshold;\n\tstruct sk_buff *skb;\n\tint refill_required;\n\tstruct xdp_buff xdp;\n\tint xdp_flags = 0;\n\tint total_len = 0;\n\tint xdp_verdict;\n\tu8 pkt_offset;\n\tint rc = 0;\n\tint i;\n\n\tnetif_dbg(rx_ring->adapter, rx_status, rx_ring->netdev,\n\t\t  \"%s qid %d\\n\", __func__, rx_ring->qid);\n\tres_budget = budget;\n\txdp_init_buff(&xdp, ENA_PAGE_SIZE, &rx_ring->xdp_rxq);\n\n\tdo {\n\t\txdp_verdict = ENA_XDP_PASS;\n\t\tskb = NULL;\n\t\tena_rx_ctx.ena_bufs = rx_ring->ena_bufs;\n\t\tena_rx_ctx.max_bufs = rx_ring->sgl_size;\n\t\tena_rx_ctx.descs = 0;\n\t\tena_rx_ctx.pkt_offset = 0;\n\t\trc = ena_com_rx_pkt(rx_ring->ena_com_io_cq,\n\t\t\t\t    rx_ring->ena_com_io_sq,\n\t\t\t\t    &ena_rx_ctx);\n\t\tif (unlikely(rc))\n\t\t\tgoto error;\n\n\t\tif (unlikely(ena_rx_ctx.descs == 0))\n\t\t\tbreak;\n\n\t\t \n\t\trx_info = &rx_ring->rx_buffer_info[rx_ring->ena_bufs[0].req_id];\n\t\tpkt_offset = ena_rx_ctx.pkt_offset;\n\t\trx_info->buf_offset += pkt_offset;\n\n\t\tnetif_dbg(rx_ring->adapter, rx_status, rx_ring->netdev,\n\t\t\t  \"rx_poll: q %d got packet from ena. descs #: %d l3 proto %d l4 proto %d hash: %x\\n\",\n\t\t\t  rx_ring->qid, ena_rx_ctx.descs, ena_rx_ctx.l3_proto,\n\t\t\t  ena_rx_ctx.l4_proto, ena_rx_ctx.hash);\n\n\t\tdma_sync_single_for_cpu(rx_ring->dev,\n\t\t\t\t\tdma_unmap_addr(&rx_info->ena_buf, paddr) + pkt_offset,\n\t\t\t\t\trx_ring->ena_bufs[0].len,\n\t\t\t\t\tDMA_FROM_DEVICE);\n\n\t\tif (ena_xdp_present_ring(rx_ring))\n\t\t\txdp_verdict = ena_xdp_handle_buff(rx_ring, &xdp, ena_rx_ctx.descs);\n\n\t\t \n\t\tif (xdp_verdict == ENA_XDP_PASS)\n\t\t\tskb = ena_rx_skb(rx_ring,\n\t\t\t\t\t rx_ring->ena_bufs,\n\t\t\t\t\t ena_rx_ctx.descs,\n\t\t\t\t\t &next_to_clean);\n\n\t\tif (unlikely(!skb)) {\n\t\t\tfor (i = 0; i < ena_rx_ctx.descs; i++) {\n\t\t\t\tint req_id = rx_ring->ena_bufs[i].req_id;\n\n\t\t\t\trx_ring->free_ids[next_to_clean] = req_id;\n\t\t\t\tnext_to_clean =\n\t\t\t\t\tENA_RX_RING_IDX_NEXT(next_to_clean,\n\t\t\t\t\t\t\t     rx_ring->ring_size);\n\n\t\t\t\t \n\t\t\t\tif (xdp_verdict & ENA_XDP_FORWARDED) {\n\t\t\t\t\tena_unmap_rx_buff_attrs(rx_ring,\n\t\t\t\t\t\t\t\t&rx_ring->rx_buffer_info[req_id],\n\t\t\t\t\t\t\t\tDMA_ATTR_SKIP_CPU_SYNC);\n\t\t\t\t\trx_ring->rx_buffer_info[req_id].page = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (xdp_verdict != ENA_XDP_PASS) {\n\t\t\t\txdp_flags |= xdp_verdict;\n\t\t\t\ttotal_len += ena_rx_ctx.ena_bufs[0].len;\n\t\t\t\tres_budget--;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tena_rx_checksum(rx_ring, &ena_rx_ctx, skb);\n\n\t\tena_set_rx_hash(rx_ring, &ena_rx_ctx, skb);\n\n\t\tskb_record_rx_queue(skb, rx_ring->qid);\n\n\t\tif (rx_ring->ena_bufs[0].len <= rx_ring->rx_copybreak)\n\t\t\trx_copybreak_pkt++;\n\n\t\ttotal_len += skb->len;\n\n\t\tnapi_gro_receive(napi, skb);\n\n\t\tres_budget--;\n\t} while (likely(res_budget));\n\n\twork_done = budget - res_budget;\n\trx_ring->per_napi_packets += work_done;\n\tu64_stats_update_begin(&rx_ring->syncp);\n\trx_ring->rx_stats.bytes += total_len;\n\trx_ring->rx_stats.cnt += work_done;\n\trx_ring->rx_stats.rx_copybreak_pkt += rx_copybreak_pkt;\n\tu64_stats_update_end(&rx_ring->syncp);\n\n\trx_ring->next_to_clean = next_to_clean;\n\n\trefill_required = ena_com_free_q_entries(rx_ring->ena_com_io_sq);\n\trefill_threshold =\n\t\tmin_t(int, rx_ring->ring_size / ENA_RX_REFILL_THRESH_DIVIDER,\n\t\t      ENA_RX_REFILL_THRESH_PACKET);\n\n\t \n\tif (refill_required > refill_threshold) {\n\t\tena_com_update_dev_comp_head(rx_ring->ena_com_io_cq);\n\t\tena_refill_rx_bufs(rx_ring, refill_required);\n\t}\n\n\tif (xdp_flags & ENA_XDP_REDIRECT)\n\t\txdp_do_flush_map();\n\n\treturn work_done;\n\nerror:\n\tif (xdp_flags & ENA_XDP_REDIRECT)\n\t\txdp_do_flush();\n\n\tadapter = netdev_priv(rx_ring->netdev);\n\n\tif (rc == -ENOSPC) {\n\t\tena_increase_stat(&rx_ring->rx_stats.bad_desc_num, 1,\n\t\t\t\t  &rx_ring->syncp);\n\t\tena_reset_device(adapter, ENA_REGS_RESET_TOO_MANY_RX_DESCS);\n\t} else {\n\t\tena_increase_stat(&rx_ring->rx_stats.bad_req_id, 1,\n\t\t\t\t  &rx_ring->syncp);\n\t\tena_reset_device(adapter, ENA_REGS_RESET_INV_RX_REQ_ID);\n\t}\n\treturn 0;\n}\n\nstatic void ena_dim_work(struct work_struct *w)\n{\n\tstruct dim *dim = container_of(w, struct dim, work);\n\tstruct dim_cq_moder cur_moder =\n\t\tnet_dim_get_rx_moderation(dim->mode, dim->profile_ix);\n\tstruct ena_napi *ena_napi = container_of(dim, struct ena_napi, dim);\n\n\tena_napi->rx_ring->smoothed_interval = cur_moder.usec;\n\tdim->state = DIM_START_MEASURE;\n}\n\nstatic void ena_adjust_adaptive_rx_intr_moderation(struct ena_napi *ena_napi)\n{\n\tstruct dim_sample dim_sample;\n\tstruct ena_ring *rx_ring = ena_napi->rx_ring;\n\n\tif (!rx_ring->per_napi_packets)\n\t\treturn;\n\n\trx_ring->non_empty_napi_events++;\n\n\tdim_update_sample(rx_ring->non_empty_napi_events,\n\t\t\t  rx_ring->rx_stats.cnt,\n\t\t\t  rx_ring->rx_stats.bytes,\n\t\t\t  &dim_sample);\n\n\tnet_dim(&ena_napi->dim, dim_sample);\n\n\trx_ring->per_napi_packets = 0;\n}\n\nstatic void ena_unmask_interrupt(struct ena_ring *tx_ring,\n\t\t\t\t\tstruct ena_ring *rx_ring)\n{\n\tu32 rx_interval = tx_ring->smoothed_interval;\n\tstruct ena_eth_io_intr_reg intr_reg;\n\n\t \n\tif (rx_ring)\n\t\trx_interval = ena_com_get_adaptive_moderation_enabled(rx_ring->ena_dev) ?\n\t\t\trx_ring->smoothed_interval :\n\t\t\tena_com_get_nonadaptive_moderation_interval_rx(rx_ring->ena_dev);\n\n\t \n\tena_com_update_intr_reg(&intr_reg,\n\t\t\t\trx_interval,\n\t\t\t\ttx_ring->smoothed_interval,\n\t\t\t\ttrue);\n\n\tena_increase_stat(&tx_ring->tx_stats.unmask_interrupt, 1,\n\t\t\t  &tx_ring->syncp);\n\n\t \n\tena_com_unmask_intr(tx_ring->ena_com_io_cq, &intr_reg);\n}\n\nstatic void ena_update_ring_numa_node(struct ena_ring *tx_ring,\n\t\t\t\t\t     struct ena_ring *rx_ring)\n{\n\tint cpu = get_cpu();\n\tint numa_node;\n\n\t \n\tif (likely(tx_ring->cpu == cpu))\n\t\tgoto out;\n\n\ttx_ring->cpu = cpu;\n\tif (rx_ring)\n\t\trx_ring->cpu = cpu;\n\n\tnuma_node = cpu_to_node(cpu);\n\n\tif (likely(tx_ring->numa_node == numa_node))\n\t\tgoto out;\n\n\tput_cpu();\n\n\tif (numa_node != NUMA_NO_NODE) {\n\t\tena_com_update_numa_node(tx_ring->ena_com_io_cq, numa_node);\n\t\ttx_ring->numa_node = numa_node;\n\t\tif (rx_ring) {\n\t\t\trx_ring->numa_node = numa_node;\n\t\t\tena_com_update_numa_node(rx_ring->ena_com_io_cq,\n\t\t\t\t\t\t numa_node);\n\t\t}\n\t}\n\n\treturn;\nout:\n\tput_cpu();\n}\n\nstatic int ena_clean_xdp_irq(struct ena_ring *xdp_ring, u32 budget)\n{\n\tu32 total_done = 0;\n\tu16 next_to_clean;\n\tint tx_pkts = 0;\n\tu16 req_id;\n\tint rc;\n\n\tif (unlikely(!xdp_ring))\n\t\treturn 0;\n\tnext_to_clean = xdp_ring->next_to_clean;\n\n\twhile (tx_pkts < budget) {\n\t\tstruct ena_tx_buffer *tx_info;\n\t\tstruct xdp_frame *xdpf;\n\n\t\trc = ena_com_tx_comp_req_id_get(xdp_ring->ena_com_io_cq,\n\t\t\t\t\t\t&req_id);\n\t\tif (rc) {\n\t\t\tif (unlikely(rc == -EINVAL))\n\t\t\t\thandle_invalid_req_id(xdp_ring, req_id, NULL,\n\t\t\t\t\t\t      true);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\trc = validate_xdp_req_id(xdp_ring, req_id);\n\t\tif (rc)\n\t\t\tbreak;\n\n\t\ttx_info = &xdp_ring->tx_buffer_info[req_id];\n\t\txdpf = tx_info->xdpf;\n\n\t\ttx_info->xdpf = NULL;\n\t\ttx_info->last_jiffies = 0;\n\t\tena_unmap_tx_buff(xdp_ring, tx_info);\n\n\t\tnetif_dbg(xdp_ring->adapter, tx_done, xdp_ring->netdev,\n\t\t\t  \"tx_poll: q %d skb %p completed\\n\", xdp_ring->qid,\n\t\t\t  xdpf);\n\n\t\ttx_pkts++;\n\t\ttotal_done += tx_info->tx_descs;\n\n\t\txdp_return_frame(xdpf);\n\t\txdp_ring->free_ids[next_to_clean] = req_id;\n\t\tnext_to_clean = ENA_TX_RING_IDX_NEXT(next_to_clean,\n\t\t\t\t\t\t     xdp_ring->ring_size);\n\t}\n\n\txdp_ring->next_to_clean = next_to_clean;\n\tena_com_comp_ack(xdp_ring->ena_com_io_sq, total_done);\n\tena_com_update_dev_comp_head(xdp_ring->ena_com_io_cq);\n\n\tnetif_dbg(xdp_ring->adapter, tx_done, xdp_ring->netdev,\n\t\t  \"tx_poll: q %d done. total pkts: %d\\n\",\n\t\t  xdp_ring->qid, tx_pkts);\n\n\treturn tx_pkts;\n}\n\nstatic int ena_io_poll(struct napi_struct *napi, int budget)\n{\n\tstruct ena_napi *ena_napi = container_of(napi, struct ena_napi, napi);\n\tstruct ena_ring *tx_ring, *rx_ring;\n\tint tx_work_done;\n\tint rx_work_done = 0;\n\tint tx_budget;\n\tint napi_comp_call = 0;\n\tint ret;\n\n\ttx_ring = ena_napi->tx_ring;\n\trx_ring = ena_napi->rx_ring;\n\n\ttx_budget = tx_ring->ring_size / ENA_TX_POLL_BUDGET_DIVIDER;\n\n\tif (!test_bit(ENA_FLAG_DEV_UP, &tx_ring->adapter->flags) ||\n\t    test_bit(ENA_FLAG_TRIGGER_RESET, &tx_ring->adapter->flags)) {\n\t\tnapi_complete_done(napi, 0);\n\t\treturn 0;\n\t}\n\n\ttx_work_done = ena_clean_tx_irq(tx_ring, tx_budget);\n\t \n\tif (likely(budget))\n\t\trx_work_done = ena_clean_rx_irq(rx_ring, napi, budget);\n\n\t \n\tif (unlikely(!test_bit(ENA_FLAG_DEV_UP, &tx_ring->adapter->flags) ||\n\t\t     test_bit(ENA_FLAG_TRIGGER_RESET, &tx_ring->adapter->flags))) {\n\t\tnapi_complete_done(napi, 0);\n\t\tret = 0;\n\n\t} else if ((budget > rx_work_done) && (tx_budget > tx_work_done)) {\n\t\tnapi_comp_call = 1;\n\n\t\t \n\t\tif (napi_complete_done(napi, rx_work_done) &&\n\t\t    READ_ONCE(ena_napi->interrupts_masked)) {\n\t\t\tsmp_rmb();  \n\t\t\tWRITE_ONCE(ena_napi->interrupts_masked, false);\n\t\t\t \n\t\t\tif (ena_com_get_adaptive_moderation_enabled(rx_ring->ena_dev))\n\t\t\t\tena_adjust_adaptive_rx_intr_moderation(ena_napi);\n\n\t\t\tena_update_ring_numa_node(tx_ring, rx_ring);\n\t\t\tena_unmask_interrupt(tx_ring, rx_ring);\n\t\t}\n\n\t\tret = rx_work_done;\n\t} else {\n\t\tret = budget;\n\t}\n\n\tu64_stats_update_begin(&tx_ring->syncp);\n\ttx_ring->tx_stats.napi_comp += napi_comp_call;\n\ttx_ring->tx_stats.tx_poll++;\n\tu64_stats_update_end(&tx_ring->syncp);\n\n\ttx_ring->tx_stats.last_napi_jiffies = jiffies;\n\n\treturn ret;\n}\n\nstatic irqreturn_t ena_intr_msix_mgmnt(int irq, void *data)\n{\n\tstruct ena_adapter *adapter = (struct ena_adapter *)data;\n\n\tena_com_admin_q_comp_intr_handler(adapter->ena_dev);\n\n\t \n\tif (likely(test_bit(ENA_FLAG_DEVICE_RUNNING, &adapter->flags)))\n\t\tena_com_aenq_intr_handler(adapter->ena_dev, data);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic irqreturn_t ena_intr_msix_io(int irq, void *data)\n{\n\tstruct ena_napi *ena_napi = data;\n\n\t \n\tWRITE_ONCE(ena_napi->first_interrupt, true);\n\n\tWRITE_ONCE(ena_napi->interrupts_masked, true);\n\tsmp_wmb();  \n\n\tnapi_schedule_irqoff(&ena_napi->napi);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic int ena_enable_msix(struct ena_adapter *adapter)\n{\n\tint msix_vecs, irq_cnt;\n\n\tif (test_bit(ENA_FLAG_MSIX_ENABLED, &adapter->flags)) {\n\t\tnetif_err(adapter, probe, adapter->netdev,\n\t\t\t  \"Error, MSI-X is already enabled\\n\");\n\t\treturn -EPERM;\n\t}\n\n\t \n\tmsix_vecs = ENA_MAX_MSIX_VEC(adapter->max_num_io_queues);\n\tnetif_dbg(adapter, probe, adapter->netdev,\n\t\t  \"Trying to enable MSI-X, vectors %d\\n\", msix_vecs);\n\n\tirq_cnt = pci_alloc_irq_vectors(adapter->pdev, ENA_MIN_MSIX_VEC,\n\t\t\t\t\tmsix_vecs, PCI_IRQ_MSIX);\n\n\tif (irq_cnt < 0) {\n\t\tnetif_err(adapter, probe, adapter->netdev,\n\t\t\t  \"Failed to enable MSI-X. irq_cnt %d\\n\", irq_cnt);\n\t\treturn -ENOSPC;\n\t}\n\n\tif (irq_cnt != msix_vecs) {\n\t\tnetif_notice(adapter, probe, adapter->netdev,\n\t\t\t     \"Enable only %d MSI-X (out of %d), reduce the number of queues\\n\",\n\t\t\t     irq_cnt, msix_vecs);\n\t\tadapter->num_io_queues = irq_cnt - ENA_ADMIN_MSIX_VEC;\n\t}\n\n\tif (ena_init_rx_cpu_rmap(adapter))\n\t\tnetif_warn(adapter, probe, adapter->netdev,\n\t\t\t   \"Failed to map IRQs to CPUs\\n\");\n\n\tadapter->msix_vecs = irq_cnt;\n\tset_bit(ENA_FLAG_MSIX_ENABLED, &adapter->flags);\n\n\treturn 0;\n}\n\nstatic void ena_setup_mgmnt_intr(struct ena_adapter *adapter)\n{\n\tu32 cpu;\n\n\tsnprintf(adapter->irq_tbl[ENA_MGMNT_IRQ_IDX].name,\n\t\t ENA_IRQNAME_SIZE, \"ena-mgmnt@pci:%s\",\n\t\t pci_name(adapter->pdev));\n\tadapter->irq_tbl[ENA_MGMNT_IRQ_IDX].handler =\n\t\tena_intr_msix_mgmnt;\n\tadapter->irq_tbl[ENA_MGMNT_IRQ_IDX].data = adapter;\n\tadapter->irq_tbl[ENA_MGMNT_IRQ_IDX].vector =\n\t\tpci_irq_vector(adapter->pdev, ENA_MGMNT_IRQ_IDX);\n\tcpu = cpumask_first(cpu_online_mask);\n\tadapter->irq_tbl[ENA_MGMNT_IRQ_IDX].cpu = cpu;\n\tcpumask_set_cpu(cpu,\n\t\t\t&adapter->irq_tbl[ENA_MGMNT_IRQ_IDX].affinity_hint_mask);\n}\n\nstatic void ena_setup_io_intr(struct ena_adapter *adapter)\n{\n\tstruct net_device *netdev;\n\tint irq_idx, i, cpu;\n\tint io_queue_count;\n\n\tnetdev = adapter->netdev;\n\tio_queue_count = adapter->num_io_queues + adapter->xdp_num_queues;\n\n\tfor (i = 0; i < io_queue_count; i++) {\n\t\tirq_idx = ENA_IO_IRQ_IDX(i);\n\t\tcpu = i % num_online_cpus();\n\n\t\tsnprintf(adapter->irq_tbl[irq_idx].name, ENA_IRQNAME_SIZE,\n\t\t\t \"%s-Tx-Rx-%d\", netdev->name, i);\n\t\tadapter->irq_tbl[irq_idx].handler = ena_intr_msix_io;\n\t\tadapter->irq_tbl[irq_idx].data = &adapter->ena_napi[i];\n\t\tadapter->irq_tbl[irq_idx].vector =\n\t\t\tpci_irq_vector(adapter->pdev, irq_idx);\n\t\tadapter->irq_tbl[irq_idx].cpu = cpu;\n\n\t\tcpumask_set_cpu(cpu,\n\t\t\t\t&adapter->irq_tbl[irq_idx].affinity_hint_mask);\n\t}\n}\n\nstatic int ena_request_mgmnt_irq(struct ena_adapter *adapter)\n{\n\tunsigned long flags = 0;\n\tstruct ena_irq *irq;\n\tint rc;\n\n\tirq = &adapter->irq_tbl[ENA_MGMNT_IRQ_IDX];\n\trc = request_irq(irq->vector, irq->handler, flags, irq->name,\n\t\t\t irq->data);\n\tif (rc) {\n\t\tnetif_err(adapter, probe, adapter->netdev,\n\t\t\t  \"Failed to request admin irq\\n\");\n\t\treturn rc;\n\t}\n\n\tnetif_dbg(adapter, probe, adapter->netdev,\n\t\t  \"Set affinity hint of mgmnt irq.to 0x%lx (irq vector: %d)\\n\",\n\t\t  irq->affinity_hint_mask.bits[0], irq->vector);\n\n\tirq_set_affinity_hint(irq->vector, &irq->affinity_hint_mask);\n\n\treturn rc;\n}\n\nstatic int ena_request_io_irq(struct ena_adapter *adapter)\n{\n\tu32 io_queue_count = adapter->num_io_queues + adapter->xdp_num_queues;\n\tunsigned long flags = 0;\n\tstruct ena_irq *irq;\n\tint rc = 0, i, k;\n\n\tif (!test_bit(ENA_FLAG_MSIX_ENABLED, &adapter->flags)) {\n\t\tnetif_err(adapter, ifup, adapter->netdev,\n\t\t\t  \"Failed to request I/O IRQ: MSI-X is not enabled\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = ENA_IO_IRQ_FIRST_IDX; i < ENA_MAX_MSIX_VEC(io_queue_count); i++) {\n\t\tirq = &adapter->irq_tbl[i];\n\t\trc = request_irq(irq->vector, irq->handler, flags, irq->name,\n\t\t\t\t irq->data);\n\t\tif (rc) {\n\t\t\tnetif_err(adapter, ifup, adapter->netdev,\n\t\t\t\t  \"Failed to request I/O IRQ. index %d rc %d\\n\",\n\t\t\t\t   i, rc);\n\t\t\tgoto err;\n\t\t}\n\n\t\tnetif_dbg(adapter, ifup, adapter->netdev,\n\t\t\t  \"Set affinity hint of irq. index %d to 0x%lx (irq vector: %d)\\n\",\n\t\t\t  i, irq->affinity_hint_mask.bits[0], irq->vector);\n\n\t\tirq_set_affinity_hint(irq->vector, &irq->affinity_hint_mask);\n\t}\n\n\treturn rc;\n\nerr:\n\tfor (k = ENA_IO_IRQ_FIRST_IDX; k < i; k++) {\n\t\tirq = &adapter->irq_tbl[k];\n\t\tfree_irq(irq->vector, irq->data);\n\t}\n\n\treturn rc;\n}\n\nstatic void ena_free_mgmnt_irq(struct ena_adapter *adapter)\n{\n\tstruct ena_irq *irq;\n\n\tirq = &adapter->irq_tbl[ENA_MGMNT_IRQ_IDX];\n\tsynchronize_irq(irq->vector);\n\tirq_set_affinity_hint(irq->vector, NULL);\n\tfree_irq(irq->vector, irq->data);\n}\n\nstatic void ena_free_io_irq(struct ena_adapter *adapter)\n{\n\tu32 io_queue_count = adapter->num_io_queues + adapter->xdp_num_queues;\n\tstruct ena_irq *irq;\n\tint i;\n\n#ifdef CONFIG_RFS_ACCEL\n\tif (adapter->msix_vecs >= 1) {\n\t\tfree_irq_cpu_rmap(adapter->netdev->rx_cpu_rmap);\n\t\tadapter->netdev->rx_cpu_rmap = NULL;\n\t}\n#endif  \n\n\tfor (i = ENA_IO_IRQ_FIRST_IDX; i < ENA_MAX_MSIX_VEC(io_queue_count); i++) {\n\t\tirq = &adapter->irq_tbl[i];\n\t\tirq_set_affinity_hint(irq->vector, NULL);\n\t\tfree_irq(irq->vector, irq->data);\n\t}\n}\n\nstatic void ena_disable_msix(struct ena_adapter *adapter)\n{\n\tif (test_and_clear_bit(ENA_FLAG_MSIX_ENABLED, &adapter->flags))\n\t\tpci_free_irq_vectors(adapter->pdev);\n}\n\nstatic void ena_disable_io_intr_sync(struct ena_adapter *adapter)\n{\n\tu32 io_queue_count = adapter->num_io_queues + adapter->xdp_num_queues;\n\tint i;\n\n\tif (!netif_running(adapter->netdev))\n\t\treturn;\n\n\tfor (i = ENA_IO_IRQ_FIRST_IDX; i < ENA_MAX_MSIX_VEC(io_queue_count); i++)\n\t\tsynchronize_irq(adapter->irq_tbl[i].vector);\n}\n\nstatic void ena_del_napi_in_range(struct ena_adapter *adapter,\n\t\t\t\t  int first_index,\n\t\t\t\t  int count)\n{\n\tint i;\n\n\tfor (i = first_index; i < first_index + count; i++) {\n\t\tnetif_napi_del(&adapter->ena_napi[i].napi);\n\n\t\tWARN_ON(!ENA_IS_XDP_INDEX(adapter, i) &&\n\t\t\tadapter->ena_napi[i].xdp_ring);\n\t}\n}\n\nstatic void ena_init_napi_in_range(struct ena_adapter *adapter,\n\t\t\t\t   int first_index, int count)\n{\n\tint i;\n\n\tfor (i = first_index; i < first_index + count; i++) {\n\t\tstruct ena_napi *napi = &adapter->ena_napi[i];\n\n\t\tnetif_napi_add(adapter->netdev, &napi->napi,\n\t\t\t       ENA_IS_XDP_INDEX(adapter, i) ? ena_xdp_io_poll : ena_io_poll);\n\n\t\tif (!ENA_IS_XDP_INDEX(adapter, i)) {\n\t\t\tnapi->rx_ring = &adapter->rx_ring[i];\n\t\t\tnapi->tx_ring = &adapter->tx_ring[i];\n\t\t} else {\n\t\t\tnapi->xdp_ring = &adapter->tx_ring[i];\n\t\t}\n\t\tnapi->qid = i;\n\t}\n}\n\nstatic void ena_napi_disable_in_range(struct ena_adapter *adapter,\n\t\t\t\t      int first_index,\n\t\t\t\t      int count)\n{\n\tint i;\n\n\tfor (i = first_index; i < first_index + count; i++)\n\t\tnapi_disable(&adapter->ena_napi[i].napi);\n}\n\nstatic void ena_napi_enable_in_range(struct ena_adapter *adapter,\n\t\t\t\t     int first_index,\n\t\t\t\t     int count)\n{\n\tint i;\n\n\tfor (i = first_index; i < first_index + count; i++)\n\t\tnapi_enable(&adapter->ena_napi[i].napi);\n}\n\n \nstatic int ena_rss_configure(struct ena_adapter *adapter)\n{\n\tstruct ena_com_dev *ena_dev = adapter->ena_dev;\n\tint rc;\n\n\t \n\tif (!ena_dev->rss.tbl_log_size) {\n\t\trc = ena_rss_init_default(adapter);\n\t\tif (rc && (rc != -EOPNOTSUPP)) {\n\t\t\tnetif_err(adapter, ifup, adapter->netdev,\n\t\t\t\t  \"Failed to init RSS rc: %d\\n\", rc);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\t \n\trc = ena_com_indirect_table_set(ena_dev);\n\tif (unlikely(rc && rc != -EOPNOTSUPP))\n\t\treturn rc;\n\n\t \n\trc = ena_com_set_hash_function(ena_dev);\n\tif (unlikely(rc && (rc != -EOPNOTSUPP)))\n\t\treturn rc;\n\n\t \n\trc = ena_com_set_hash_ctrl(ena_dev);\n\tif (unlikely(rc && (rc != -EOPNOTSUPP)))\n\t\treturn rc;\n\n\treturn 0;\n}\n\nstatic int ena_up_complete(struct ena_adapter *adapter)\n{\n\tint rc;\n\n\trc = ena_rss_configure(adapter);\n\tif (rc)\n\t\treturn rc;\n\n\tena_change_mtu(adapter->netdev, adapter->netdev->mtu);\n\n\tena_refill_all_rx_bufs(adapter);\n\n\t \n\tnetif_tx_start_all_queues(adapter->netdev);\n\n\tena_napi_enable_in_range(adapter,\n\t\t\t\t 0,\n\t\t\t\t adapter->xdp_num_queues + adapter->num_io_queues);\n\n\treturn 0;\n}\n\nstatic int ena_create_io_tx_queue(struct ena_adapter *adapter, int qid)\n{\n\tstruct ena_com_create_io_ctx ctx;\n\tstruct ena_com_dev *ena_dev;\n\tstruct ena_ring *tx_ring;\n\tu32 msix_vector;\n\tu16 ena_qid;\n\tint rc;\n\n\tena_dev = adapter->ena_dev;\n\n\ttx_ring = &adapter->tx_ring[qid];\n\tmsix_vector = ENA_IO_IRQ_IDX(qid);\n\tena_qid = ENA_IO_TXQ_IDX(qid);\n\n\tmemset(&ctx, 0x0, sizeof(ctx));\n\n\tctx.direction = ENA_COM_IO_QUEUE_DIRECTION_TX;\n\tctx.qid = ena_qid;\n\tctx.mem_queue_type = ena_dev->tx_mem_queue_type;\n\tctx.msix_vector = msix_vector;\n\tctx.queue_size = tx_ring->ring_size;\n\tctx.numa_node = tx_ring->numa_node;\n\n\trc = ena_com_create_io_queue(ena_dev, &ctx);\n\tif (rc) {\n\t\tnetif_err(adapter, ifup, adapter->netdev,\n\t\t\t  \"Failed to create I/O TX queue num %d rc: %d\\n\",\n\t\t\t  qid, rc);\n\t\treturn rc;\n\t}\n\n\trc = ena_com_get_io_handlers(ena_dev, ena_qid,\n\t\t\t\t     &tx_ring->ena_com_io_sq,\n\t\t\t\t     &tx_ring->ena_com_io_cq);\n\tif (rc) {\n\t\tnetif_err(adapter, ifup, adapter->netdev,\n\t\t\t  \"Failed to get TX queue handlers. TX queue num %d rc: %d\\n\",\n\t\t\t  qid, rc);\n\t\tena_com_destroy_io_queue(ena_dev, ena_qid);\n\t\treturn rc;\n\t}\n\n\tena_com_update_numa_node(tx_ring->ena_com_io_cq, ctx.numa_node);\n\treturn rc;\n}\n\nstatic int ena_create_io_tx_queues_in_range(struct ena_adapter *adapter,\n\t\t\t\t\t    int first_index, int count)\n{\n\tstruct ena_com_dev *ena_dev = adapter->ena_dev;\n\tint rc, i;\n\n\tfor (i = first_index; i < first_index + count; i++) {\n\t\trc = ena_create_io_tx_queue(adapter, i);\n\t\tif (rc)\n\t\t\tgoto create_err;\n\t}\n\n\treturn 0;\n\ncreate_err:\n\twhile (i-- > first_index)\n\t\tena_com_destroy_io_queue(ena_dev, ENA_IO_TXQ_IDX(i));\n\n\treturn rc;\n}\n\nstatic int ena_create_io_rx_queue(struct ena_adapter *adapter, int qid)\n{\n\tstruct ena_com_dev *ena_dev;\n\tstruct ena_com_create_io_ctx ctx;\n\tstruct ena_ring *rx_ring;\n\tu32 msix_vector;\n\tu16 ena_qid;\n\tint rc;\n\n\tena_dev = adapter->ena_dev;\n\n\trx_ring = &adapter->rx_ring[qid];\n\tmsix_vector = ENA_IO_IRQ_IDX(qid);\n\tena_qid = ENA_IO_RXQ_IDX(qid);\n\n\tmemset(&ctx, 0x0, sizeof(ctx));\n\n\tctx.qid = ena_qid;\n\tctx.direction = ENA_COM_IO_QUEUE_DIRECTION_RX;\n\tctx.mem_queue_type = ENA_ADMIN_PLACEMENT_POLICY_HOST;\n\tctx.msix_vector = msix_vector;\n\tctx.queue_size = rx_ring->ring_size;\n\tctx.numa_node = rx_ring->numa_node;\n\n\trc = ena_com_create_io_queue(ena_dev, &ctx);\n\tif (rc) {\n\t\tnetif_err(adapter, ifup, adapter->netdev,\n\t\t\t  \"Failed to create I/O RX queue num %d rc: %d\\n\",\n\t\t\t  qid, rc);\n\t\treturn rc;\n\t}\n\n\trc = ena_com_get_io_handlers(ena_dev, ena_qid,\n\t\t\t\t     &rx_ring->ena_com_io_sq,\n\t\t\t\t     &rx_ring->ena_com_io_cq);\n\tif (rc) {\n\t\tnetif_err(adapter, ifup, adapter->netdev,\n\t\t\t  \"Failed to get RX queue handlers. RX queue num %d rc: %d\\n\",\n\t\t\t  qid, rc);\n\t\tgoto err;\n\t}\n\n\tena_com_update_numa_node(rx_ring->ena_com_io_cq, ctx.numa_node);\n\n\treturn rc;\nerr:\n\tena_com_destroy_io_queue(ena_dev, ena_qid);\n\treturn rc;\n}\n\nstatic int ena_create_all_io_rx_queues(struct ena_adapter *adapter)\n{\n\tstruct ena_com_dev *ena_dev = adapter->ena_dev;\n\tint rc, i;\n\n\tfor (i = 0; i < adapter->num_io_queues; i++) {\n\t\trc = ena_create_io_rx_queue(adapter, i);\n\t\tif (rc)\n\t\t\tgoto create_err;\n\t\tINIT_WORK(&adapter->ena_napi[i].dim.work, ena_dim_work);\n\t}\n\n\treturn 0;\n\ncreate_err:\n\twhile (i--) {\n\t\tcancel_work_sync(&adapter->ena_napi[i].dim.work);\n\t\tena_com_destroy_io_queue(ena_dev, ENA_IO_RXQ_IDX(i));\n\t}\n\n\treturn rc;\n}\n\nstatic void set_io_rings_size(struct ena_adapter *adapter,\n\t\t\t      int new_tx_size,\n\t\t\t      int new_rx_size)\n{\n\tint i;\n\n\tfor (i = 0; i < adapter->num_io_queues; i++) {\n\t\tadapter->tx_ring[i].ring_size = new_tx_size;\n\t\tadapter->rx_ring[i].ring_size = new_rx_size;\n\t}\n}\n\n \nstatic int create_queues_with_size_backoff(struct ena_adapter *adapter)\n{\n\tint rc, cur_rx_ring_size, cur_tx_ring_size;\n\tint new_rx_ring_size, new_tx_ring_size;\n\n\t \n\tset_io_rings_size(adapter, adapter->requested_tx_ring_size,\n\t\t\t  adapter->requested_rx_ring_size);\n\n\twhile (1) {\n\t\tif (ena_xdp_present(adapter)) {\n\t\t\trc = ena_setup_and_create_all_xdp_queues(adapter);\n\n\t\t\tif (rc)\n\t\t\t\tgoto err_setup_tx;\n\t\t}\n\t\trc = ena_setup_tx_resources_in_range(adapter,\n\t\t\t\t\t\t     0,\n\t\t\t\t\t\t     adapter->num_io_queues);\n\t\tif (rc)\n\t\t\tgoto err_setup_tx;\n\n\t\trc = ena_create_io_tx_queues_in_range(adapter,\n\t\t\t\t\t\t      0,\n\t\t\t\t\t\t      adapter->num_io_queues);\n\t\tif (rc)\n\t\t\tgoto err_create_tx_queues;\n\n\t\trc = ena_setup_all_rx_resources(adapter);\n\t\tif (rc)\n\t\t\tgoto err_setup_rx;\n\n\t\trc = ena_create_all_io_rx_queues(adapter);\n\t\tif (rc)\n\t\t\tgoto err_create_rx_queues;\n\n\t\treturn 0;\n\nerr_create_rx_queues:\n\t\tena_free_all_io_rx_resources(adapter);\nerr_setup_rx:\n\t\tena_destroy_all_tx_queues(adapter);\nerr_create_tx_queues:\n\t\tena_free_all_io_tx_resources(adapter);\nerr_setup_tx:\n\t\tif (rc != -ENOMEM) {\n\t\t\tnetif_err(adapter, ifup, adapter->netdev,\n\t\t\t\t  \"Queue creation failed with error code %d\\n\",\n\t\t\t\t  rc);\n\t\t\treturn rc;\n\t\t}\n\n\t\tcur_tx_ring_size = adapter->tx_ring[0].ring_size;\n\t\tcur_rx_ring_size = adapter->rx_ring[0].ring_size;\n\n\t\tnetif_err(adapter, ifup, adapter->netdev,\n\t\t\t  \"Not enough memory to create queues with sizes TX=%d, RX=%d\\n\",\n\t\t\t  cur_tx_ring_size, cur_rx_ring_size);\n\n\t\tnew_tx_ring_size = cur_tx_ring_size;\n\t\tnew_rx_ring_size = cur_rx_ring_size;\n\n\t\t \n\t\tif (cur_rx_ring_size <= cur_tx_ring_size)\n\t\t\tnew_tx_ring_size = cur_tx_ring_size / 2;\n\t\tif (cur_rx_ring_size >= cur_tx_ring_size)\n\t\t\tnew_rx_ring_size = cur_rx_ring_size / 2;\n\n\t\tif (new_tx_ring_size < ENA_MIN_RING_SIZE ||\n\t\t    new_rx_ring_size < ENA_MIN_RING_SIZE) {\n\t\t\tnetif_err(adapter, ifup, adapter->netdev,\n\t\t\t\t  \"Queue creation failed with the smallest possible queue size of %d for both queues. Not retrying with smaller queues\\n\",\n\t\t\t\t  ENA_MIN_RING_SIZE);\n\t\t\treturn rc;\n\t\t}\n\n\t\tnetif_err(adapter, ifup, adapter->netdev,\n\t\t\t  \"Retrying queue creation with sizes TX=%d, RX=%d\\n\",\n\t\t\t  new_tx_ring_size,\n\t\t\t  new_rx_ring_size);\n\n\t\tset_io_rings_size(adapter, new_tx_ring_size,\n\t\t\t\t  new_rx_ring_size);\n\t}\n}\n\nstatic int ena_up(struct ena_adapter *adapter)\n{\n\tint io_queue_count, rc, i;\n\n\tnetif_dbg(adapter, ifup, adapter->netdev, \"%s\\n\", __func__);\n\n\tio_queue_count = adapter->num_io_queues + adapter->xdp_num_queues;\n\tena_setup_io_intr(adapter);\n\n\t \n\tena_init_napi_in_range(adapter, 0, io_queue_count);\n\n\trc = ena_request_io_irq(adapter);\n\tif (rc)\n\t\tgoto err_req_irq;\n\n\trc = create_queues_with_size_backoff(adapter);\n\tif (rc)\n\t\tgoto err_create_queues_with_backoff;\n\n\trc = ena_up_complete(adapter);\n\tif (rc)\n\t\tgoto err_up;\n\n\tif (test_bit(ENA_FLAG_LINK_UP, &adapter->flags))\n\t\tnetif_carrier_on(adapter->netdev);\n\n\tena_increase_stat(&adapter->dev_stats.interface_up, 1,\n\t\t\t  &adapter->syncp);\n\n\tset_bit(ENA_FLAG_DEV_UP, &adapter->flags);\n\n\t \n\tfor (i = 0; i < adapter->num_io_queues; i++)\n\t\tena_unmask_interrupt(&adapter->tx_ring[i],\n\t\t\t\t     &adapter->rx_ring[i]);\n\n\t \n\tfor (i = 0; i < io_queue_count; i++)\n\t\tnapi_schedule(&adapter->ena_napi[i].napi);\n\n\treturn rc;\n\nerr_up:\n\tena_destroy_all_tx_queues(adapter);\n\tena_free_all_io_tx_resources(adapter);\n\tena_destroy_all_rx_queues(adapter);\n\tena_free_all_io_rx_resources(adapter);\nerr_create_queues_with_backoff:\n\tena_free_io_irq(adapter);\nerr_req_irq:\n\tena_del_napi_in_range(adapter, 0, io_queue_count);\n\n\treturn rc;\n}\n\nstatic void ena_down(struct ena_adapter *adapter)\n{\n\tint io_queue_count = adapter->num_io_queues + adapter->xdp_num_queues;\n\n\tnetif_info(adapter, ifdown, adapter->netdev, \"%s\\n\", __func__);\n\n\tclear_bit(ENA_FLAG_DEV_UP, &adapter->flags);\n\n\tena_increase_stat(&adapter->dev_stats.interface_down, 1,\n\t\t\t  &adapter->syncp);\n\n\tnetif_carrier_off(adapter->netdev);\n\tnetif_tx_disable(adapter->netdev);\n\n\t \n\tena_napi_disable_in_range(adapter, 0, io_queue_count);\n\n\t \n\n\tif (test_bit(ENA_FLAG_TRIGGER_RESET, &adapter->flags)) {\n\t\tint rc;\n\n\t\trc = ena_com_dev_reset(adapter->ena_dev, adapter->reset_reason);\n\t\tif (rc)\n\t\t\tnetif_err(adapter, ifdown, adapter->netdev,\n\t\t\t\t  \"Device reset failed\\n\");\n\t\t \n\t\tena_com_set_admin_running_state(adapter->ena_dev, false);\n\t}\n\n\tena_destroy_all_io_queues(adapter);\n\n\tena_disable_io_intr_sync(adapter);\n\tena_free_io_irq(adapter);\n\tena_del_napi_in_range(adapter, 0, io_queue_count);\n\n\tena_free_all_tx_bufs(adapter);\n\tena_free_all_rx_bufs(adapter);\n\tena_free_all_io_tx_resources(adapter);\n\tena_free_all_io_rx_resources(adapter);\n}\n\n \nstatic int ena_open(struct net_device *netdev)\n{\n\tstruct ena_adapter *adapter = netdev_priv(netdev);\n\tint rc;\n\n\t \n\trc = netif_set_real_num_tx_queues(netdev, adapter->num_io_queues);\n\tif (rc) {\n\t\tnetif_err(adapter, ifup, netdev, \"Can't set num tx queues\\n\");\n\t\treturn rc;\n\t}\n\n\trc = netif_set_real_num_rx_queues(netdev, adapter->num_io_queues);\n\tif (rc) {\n\t\tnetif_err(adapter, ifup, netdev, \"Can't set num rx queues\\n\");\n\t\treturn rc;\n\t}\n\n\trc = ena_up(adapter);\n\tif (rc)\n\t\treturn rc;\n\n\treturn rc;\n}\n\n \nstatic int ena_close(struct net_device *netdev)\n{\n\tstruct ena_adapter *adapter = netdev_priv(netdev);\n\n\tnetif_dbg(adapter, ifdown, netdev, \"%s\\n\", __func__);\n\n\tif (!test_bit(ENA_FLAG_DEVICE_RUNNING, &adapter->flags))\n\t\treturn 0;\n\n\tif (test_bit(ENA_FLAG_DEV_UP, &adapter->flags))\n\t\tena_down(adapter);\n\n\t \n\tcheck_for_admin_com_state(adapter);\n\tif (unlikely(test_bit(ENA_FLAG_TRIGGER_RESET, &adapter->flags))) {\n\t\tnetif_err(adapter, ifdown, adapter->netdev,\n\t\t\t  \"Destroy failure, restarting device\\n\");\n\t\tena_dump_stats_to_dmesg(adapter);\n\t\t \n\t\tena_destroy_device(adapter, false);\n\t\tena_restore_device(adapter);\n\t}\n\n\treturn 0;\n}\n\nint ena_update_queue_params(struct ena_adapter *adapter,\n\t\t\t    u32 new_tx_size,\n\t\t\t    u32 new_rx_size,\n\t\t\t    u32 new_llq_header_len)\n{\n\tbool dev_was_up, large_llq_changed = false;\n\tint rc = 0;\n\n\tdev_was_up = test_bit(ENA_FLAG_DEV_UP, &adapter->flags);\n\tena_close(adapter->netdev);\n\tadapter->requested_tx_ring_size = new_tx_size;\n\tadapter->requested_rx_ring_size = new_rx_size;\n\tena_init_io_rings(adapter,\n\t\t\t  0,\n\t\t\t  adapter->xdp_num_queues +\n\t\t\t  adapter->num_io_queues);\n\n\tlarge_llq_changed = adapter->ena_dev->tx_mem_queue_type ==\n\t\t\t    ENA_ADMIN_PLACEMENT_POLICY_DEV;\n\tlarge_llq_changed &=\n\t\tnew_llq_header_len != adapter->ena_dev->tx_max_header_size;\n\n\t \n\tif (large_llq_changed) {\n\t\tadapter->large_llq_header_enabled = !adapter->large_llq_header_enabled;\n\n\t\tena_destroy_device(adapter, false);\n\t\trc = ena_restore_device(adapter);\n\t}\n\n\treturn dev_was_up && !rc ? ena_up(adapter) : rc;\n}\n\nint ena_set_rx_copybreak(struct ena_adapter *adapter, u32 rx_copybreak)\n{\n\tstruct ena_ring *rx_ring;\n\tint i;\n\n\tif (rx_copybreak > min_t(u16, adapter->netdev->mtu, ENA_PAGE_SIZE))\n\t\treturn -EINVAL;\n\n\tadapter->rx_copybreak = rx_copybreak;\n\n\tfor (i = 0; i < adapter->num_io_queues; i++) {\n\t\trx_ring = &adapter->rx_ring[i];\n\t\trx_ring->rx_copybreak = rx_copybreak;\n\t}\n\n\treturn 0;\n}\n\nint ena_update_queue_count(struct ena_adapter *adapter, u32 new_channel_count)\n{\n\tstruct ena_com_dev *ena_dev = adapter->ena_dev;\n\tint prev_channel_count;\n\tbool dev_was_up;\n\n\tdev_was_up = test_bit(ENA_FLAG_DEV_UP, &adapter->flags);\n\tena_close(adapter->netdev);\n\tprev_channel_count = adapter->num_io_queues;\n\tadapter->num_io_queues = new_channel_count;\n\tif (ena_xdp_present(adapter) &&\n\t    ena_xdp_allowed(adapter) == ENA_XDP_ALLOWED) {\n\t\tadapter->xdp_first_ring = new_channel_count;\n\t\tadapter->xdp_num_queues = new_channel_count;\n\t\tif (prev_channel_count > new_channel_count)\n\t\t\tena_xdp_exchange_program_rx_in_range(adapter,\n\t\t\t\t\t\t\t     NULL,\n\t\t\t\t\t\t\t     new_channel_count,\n\t\t\t\t\t\t\t     prev_channel_count);\n\t\telse\n\t\t\tena_xdp_exchange_program_rx_in_range(adapter,\n\t\t\t\t\t\t\t     adapter->xdp_bpf_prog,\n\t\t\t\t\t\t\t     prev_channel_count,\n\t\t\t\t\t\t\t     new_channel_count);\n\t}\n\n\t \n\tena_com_rss_destroy(ena_dev);\n\tena_init_io_rings(adapter,\n\t\t\t  0,\n\t\t\t  adapter->xdp_num_queues +\n\t\t\t  adapter->num_io_queues);\n\treturn dev_was_up ? ena_open(adapter->netdev) : 0;\n}\n\nstatic void ena_tx_csum(struct ena_com_tx_ctx *ena_tx_ctx,\n\t\t\tstruct sk_buff *skb,\n\t\t\tbool disable_meta_caching)\n{\n\tu32 mss = skb_shinfo(skb)->gso_size;\n\tstruct ena_com_tx_meta *ena_meta = &ena_tx_ctx->ena_meta;\n\tu8 l4_protocol = 0;\n\n\tif ((skb->ip_summed == CHECKSUM_PARTIAL) || mss) {\n\t\tena_tx_ctx->l4_csum_enable = 1;\n\t\tif (mss) {\n\t\t\tena_tx_ctx->tso_enable = 1;\n\t\t\tena_meta->l4_hdr_len = tcp_hdr(skb)->doff;\n\t\t\tena_tx_ctx->l4_csum_partial = 0;\n\t\t} else {\n\t\t\tena_tx_ctx->tso_enable = 0;\n\t\t\tena_meta->l4_hdr_len = 0;\n\t\t\tena_tx_ctx->l4_csum_partial = 1;\n\t\t}\n\n\t\tswitch (ip_hdr(skb)->version) {\n\t\tcase IPVERSION:\n\t\t\tena_tx_ctx->l3_proto = ENA_ETH_IO_L3_PROTO_IPV4;\n\t\t\tif (ip_hdr(skb)->frag_off & htons(IP_DF))\n\t\t\t\tena_tx_ctx->df = 1;\n\t\t\tif (mss)\n\t\t\t\tena_tx_ctx->l3_csum_enable = 1;\n\t\t\tl4_protocol = ip_hdr(skb)->protocol;\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tena_tx_ctx->l3_proto = ENA_ETH_IO_L3_PROTO_IPV6;\n\t\t\tl4_protocol = ipv6_hdr(skb)->nexthdr;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tif (l4_protocol == IPPROTO_TCP)\n\t\t\tena_tx_ctx->l4_proto = ENA_ETH_IO_L4_PROTO_TCP;\n\t\telse\n\t\t\tena_tx_ctx->l4_proto = ENA_ETH_IO_L4_PROTO_UDP;\n\n\t\tena_meta->mss = mss;\n\t\tena_meta->l3_hdr_len = skb_network_header_len(skb);\n\t\tena_meta->l3_hdr_offset = skb_network_offset(skb);\n\t\tena_tx_ctx->meta_valid = 1;\n\t} else if (disable_meta_caching) {\n\t\tmemset(ena_meta, 0, sizeof(*ena_meta));\n\t\tena_tx_ctx->meta_valid = 1;\n\t} else {\n\t\tena_tx_ctx->meta_valid = 0;\n\t}\n}\n\nstatic int ena_check_and_linearize_skb(struct ena_ring *tx_ring,\n\t\t\t\t       struct sk_buff *skb)\n{\n\tint num_frags, header_len, rc;\n\n\tnum_frags = skb_shinfo(skb)->nr_frags;\n\theader_len = skb_headlen(skb);\n\n\tif (num_frags < tx_ring->sgl_size)\n\t\treturn 0;\n\n\tif ((num_frags == tx_ring->sgl_size) &&\n\t    (header_len < tx_ring->tx_max_header_size))\n\t\treturn 0;\n\n\tena_increase_stat(&tx_ring->tx_stats.linearize, 1, &tx_ring->syncp);\n\n\trc = skb_linearize(skb);\n\tif (unlikely(rc)) {\n\t\tena_increase_stat(&tx_ring->tx_stats.linearize_failed, 1,\n\t\t\t\t  &tx_ring->syncp);\n\t}\n\n\treturn rc;\n}\n\nstatic int ena_tx_map_skb(struct ena_ring *tx_ring,\n\t\t\t  struct ena_tx_buffer *tx_info,\n\t\t\t  struct sk_buff *skb,\n\t\t\t  void **push_hdr,\n\t\t\t  u16 *header_len)\n{\n\tstruct ena_adapter *adapter = tx_ring->adapter;\n\tstruct ena_com_buf *ena_buf;\n\tdma_addr_t dma;\n\tu32 skb_head_len, frag_len, last_frag;\n\tu16 push_len = 0;\n\tu16 delta = 0;\n\tint i = 0;\n\n\tskb_head_len = skb_headlen(skb);\n\ttx_info->skb = skb;\n\tena_buf = tx_info->bufs;\n\n\tif (tx_ring->tx_mem_queue_type == ENA_ADMIN_PLACEMENT_POLICY_DEV) {\n\t\t \n\n\t\tpush_len = min_t(u32, skb->len, tx_ring->tx_max_header_size);\n\t\t*push_hdr = skb_header_pointer(skb, 0, push_len,\n\t\t\t\t\t       tx_ring->push_buf_intermediate_buf);\n\t\t*header_len = push_len;\n\t\tif (unlikely(skb->data != *push_hdr)) {\n\t\t\tena_increase_stat(&tx_ring->tx_stats.llq_buffer_copy, 1,\n\t\t\t\t\t  &tx_ring->syncp);\n\n\t\t\tdelta = push_len - skb_head_len;\n\t\t}\n\t} else {\n\t\t*push_hdr = NULL;\n\t\t*header_len = min_t(u32, skb_head_len,\n\t\t\t\t    tx_ring->tx_max_header_size);\n\t}\n\n\tnetif_dbg(adapter, tx_queued, adapter->netdev,\n\t\t  \"skb: %p header_buf->vaddr: %p push_len: %d\\n\", skb,\n\t\t  *push_hdr, push_len);\n\n\tif (skb_head_len > push_len) {\n\t\tdma = dma_map_single(tx_ring->dev, skb->data + push_len,\n\t\t\t\t     skb_head_len - push_len, DMA_TO_DEVICE);\n\t\tif (unlikely(dma_mapping_error(tx_ring->dev, dma)))\n\t\t\tgoto error_report_dma_error;\n\n\t\tena_buf->paddr = dma;\n\t\tena_buf->len = skb_head_len - push_len;\n\n\t\tena_buf++;\n\t\ttx_info->num_of_bufs++;\n\t\ttx_info->map_linear_data = 1;\n\t} else {\n\t\ttx_info->map_linear_data = 0;\n\t}\n\n\tlast_frag = skb_shinfo(skb)->nr_frags;\n\n\tfor (i = 0; i < last_frag; i++) {\n\t\tconst skb_frag_t *frag = &skb_shinfo(skb)->frags[i];\n\n\t\tfrag_len = skb_frag_size(frag);\n\n\t\tif (unlikely(delta >= frag_len)) {\n\t\t\tdelta -= frag_len;\n\t\t\tcontinue;\n\t\t}\n\n\t\tdma = skb_frag_dma_map(tx_ring->dev, frag, delta,\n\t\t\t\t       frag_len - delta, DMA_TO_DEVICE);\n\t\tif (unlikely(dma_mapping_error(tx_ring->dev, dma)))\n\t\t\tgoto error_report_dma_error;\n\n\t\tena_buf->paddr = dma;\n\t\tena_buf->len = frag_len - delta;\n\t\tena_buf++;\n\t\ttx_info->num_of_bufs++;\n\t\tdelta = 0;\n\t}\n\n\treturn 0;\n\nerror_report_dma_error:\n\tena_increase_stat(&tx_ring->tx_stats.dma_mapping_err, 1,\n\t\t\t  &tx_ring->syncp);\n\tnetif_warn(adapter, tx_queued, adapter->netdev, \"Failed to map skb\\n\");\n\n\ttx_info->skb = NULL;\n\n\ttx_info->num_of_bufs += i;\n\tena_unmap_tx_buff(tx_ring, tx_info);\n\n\treturn -EINVAL;\n}\n\n \nstatic netdev_tx_t ena_start_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct ena_adapter *adapter = netdev_priv(dev);\n\tstruct ena_tx_buffer *tx_info;\n\tstruct ena_com_tx_ctx ena_tx_ctx;\n\tstruct ena_ring *tx_ring;\n\tstruct netdev_queue *txq;\n\tvoid *push_hdr;\n\tu16 next_to_use, req_id, header_len;\n\tint qid, rc;\n\n\tnetif_dbg(adapter, tx_queued, dev, \"%s skb %p\\n\", __func__, skb);\n\t \n\tqid = skb_get_queue_mapping(skb);\n\ttx_ring = &adapter->tx_ring[qid];\n\ttxq = netdev_get_tx_queue(dev, qid);\n\n\trc = ena_check_and_linearize_skb(tx_ring, skb);\n\tif (unlikely(rc))\n\t\tgoto error_drop_packet;\n\n\tskb_tx_timestamp(skb);\n\n\tnext_to_use = tx_ring->next_to_use;\n\treq_id = tx_ring->free_ids[next_to_use];\n\ttx_info = &tx_ring->tx_buffer_info[req_id];\n\ttx_info->num_of_bufs = 0;\n\n\tWARN(tx_info->skb, \"SKB isn't NULL req_id %d\\n\", req_id);\n\n\trc = ena_tx_map_skb(tx_ring, tx_info, skb, &push_hdr, &header_len);\n\tif (unlikely(rc))\n\t\tgoto error_drop_packet;\n\n\tmemset(&ena_tx_ctx, 0x0, sizeof(struct ena_com_tx_ctx));\n\tena_tx_ctx.ena_bufs = tx_info->bufs;\n\tena_tx_ctx.push_header = push_hdr;\n\tena_tx_ctx.num_bufs = tx_info->num_of_bufs;\n\tena_tx_ctx.req_id = req_id;\n\tena_tx_ctx.header_len = header_len;\n\n\t \n\tena_tx_csum(&ena_tx_ctx, skb, tx_ring->disable_meta_caching);\n\n\trc = ena_xmit_common(dev,\n\t\t\t     tx_ring,\n\t\t\t     tx_info,\n\t\t\t     &ena_tx_ctx,\n\t\t\t     next_to_use,\n\t\t\t     skb->len);\n\tif (rc)\n\t\tgoto error_unmap_dma;\n\n\tnetdev_tx_sent_queue(txq, skb->len);\n\n\t \n\tif (unlikely(!ena_com_sq_have_enough_space(tx_ring->ena_com_io_sq,\n\t\t\t\t\t\t   tx_ring->sgl_size + 2))) {\n\t\tnetif_dbg(adapter, tx_queued, dev, \"%s stop queue %d\\n\",\n\t\t\t  __func__, qid);\n\n\t\tnetif_tx_stop_queue(txq);\n\t\tena_increase_stat(&tx_ring->tx_stats.queue_stop, 1,\n\t\t\t\t  &tx_ring->syncp);\n\n\t\t \n\t\tsmp_mb();\n\n\t\tif (ena_com_sq_have_enough_space(tx_ring->ena_com_io_sq,\n\t\t\t\t\t\t ENA_TX_WAKEUP_THRESH)) {\n\t\t\tnetif_tx_wake_queue(txq);\n\t\t\tena_increase_stat(&tx_ring->tx_stats.queue_wakeup, 1,\n\t\t\t\t\t  &tx_ring->syncp);\n\t\t}\n\t}\n\n\tif (netif_xmit_stopped(txq) || !netdev_xmit_more())\n\t\t \n\t\tena_ring_tx_doorbell(tx_ring);\n\n\treturn NETDEV_TX_OK;\n\nerror_unmap_dma:\n\tena_unmap_tx_buff(tx_ring, tx_info);\n\ttx_info->skb = NULL;\n\nerror_drop_packet:\n\tdev_kfree_skb(skb);\n\treturn NETDEV_TX_OK;\n}\n\nstatic u16 ena_select_queue(struct net_device *dev, struct sk_buff *skb,\n\t\t\t    struct net_device *sb_dev)\n{\n\tu16 qid;\n\t \n\tif (skb_rx_queue_recorded(skb))\n\t\tqid = skb_get_rx_queue(skb);\n\telse\n\t\tqid = netdev_pick_tx(dev, skb, NULL);\n\n\treturn qid;\n}\n\nstatic void ena_config_host_info(struct ena_com_dev *ena_dev, struct pci_dev *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct ena_admin_host_info *host_info;\n\tint rc;\n\n\t \n\trc = ena_com_allocate_host_info(ena_dev);\n\tif (rc) {\n\t\tdev_err(dev, \"Cannot allocate host info\\n\");\n\t\treturn;\n\t}\n\n\thost_info = ena_dev->host_attr.host_info;\n\n\thost_info->bdf = pci_dev_id(pdev);\n\thost_info->os_type = ENA_ADMIN_OS_LINUX;\n\thost_info->kernel_ver = LINUX_VERSION_CODE;\n\tstrscpy(host_info->kernel_ver_str, utsname()->version,\n\t\tsizeof(host_info->kernel_ver_str) - 1);\n\thost_info->os_dist = 0;\n\tstrncpy(host_info->os_dist_str, utsname()->release,\n\t\tsizeof(host_info->os_dist_str) - 1);\n\thost_info->driver_version =\n\t\t(DRV_MODULE_GEN_MAJOR) |\n\t\t(DRV_MODULE_GEN_MINOR << ENA_ADMIN_HOST_INFO_MINOR_SHIFT) |\n\t\t(DRV_MODULE_GEN_SUBMINOR << ENA_ADMIN_HOST_INFO_SUB_MINOR_SHIFT) |\n\t\t(\"K\"[0] << ENA_ADMIN_HOST_INFO_MODULE_TYPE_SHIFT);\n\thost_info->num_cpus = num_online_cpus();\n\n\thost_info->driver_supported_features =\n\t\tENA_ADMIN_HOST_INFO_RX_OFFSET_MASK |\n\t\tENA_ADMIN_HOST_INFO_INTERRUPT_MODERATION_MASK |\n\t\tENA_ADMIN_HOST_INFO_RX_BUF_MIRRORING_MASK |\n\t\tENA_ADMIN_HOST_INFO_RSS_CONFIGURABLE_FUNCTION_KEY_MASK |\n\t\tENA_ADMIN_HOST_INFO_RX_PAGE_REUSE_MASK;\n\n\trc = ena_com_set_host_attributes(ena_dev);\n\tif (rc) {\n\t\tif (rc == -EOPNOTSUPP)\n\t\t\tdev_warn(dev, \"Cannot set host attributes\\n\");\n\t\telse\n\t\t\tdev_err(dev, \"Cannot set host attributes\\n\");\n\n\t\tgoto err;\n\t}\n\n\treturn;\n\nerr:\n\tena_com_delete_host_info(ena_dev);\n}\n\nstatic void ena_config_debug_area(struct ena_adapter *adapter)\n{\n\tu32 debug_area_size;\n\tint rc, ss_count;\n\n\tss_count = ena_get_sset_count(adapter->netdev, ETH_SS_STATS);\n\tif (ss_count <= 0) {\n\t\tnetif_err(adapter, drv, adapter->netdev,\n\t\t\t  \"SS count is negative\\n\");\n\t\treturn;\n\t}\n\n\t \n\tdebug_area_size = ss_count * ETH_GSTRING_LEN + sizeof(u64) * ss_count;\n\n\trc = ena_com_allocate_debug_area(adapter->ena_dev, debug_area_size);\n\tif (rc) {\n\t\tnetif_err(adapter, drv, adapter->netdev,\n\t\t\t  \"Cannot allocate debug area\\n\");\n\t\treturn;\n\t}\n\n\trc = ena_com_set_host_attributes(adapter->ena_dev);\n\tif (rc) {\n\t\tif (rc == -EOPNOTSUPP)\n\t\t\tnetif_warn(adapter, drv, adapter->netdev,\n\t\t\t\t   \"Cannot set host attributes\\n\");\n\t\telse\n\t\t\tnetif_err(adapter, drv, adapter->netdev,\n\t\t\t\t  \"Cannot set host attributes\\n\");\n\t\tgoto err;\n\t}\n\n\treturn;\nerr:\n\tena_com_delete_debug_area(adapter->ena_dev);\n}\n\nint ena_update_hw_stats(struct ena_adapter *adapter)\n{\n\tint rc;\n\n\trc = ena_com_get_eni_stats(adapter->ena_dev, &adapter->eni_stats);\n\tif (rc) {\n\t\tnetdev_err(adapter->netdev, \"Failed to get ENI stats\\n\");\n\t\treturn rc;\n\t}\n\n\treturn 0;\n}\n\nstatic void ena_get_stats64(struct net_device *netdev,\n\t\t\t    struct rtnl_link_stats64 *stats)\n{\n\tstruct ena_adapter *adapter = netdev_priv(netdev);\n\tstruct ena_ring *rx_ring, *tx_ring;\n\tunsigned int start;\n\tu64 rx_drops;\n\tu64 tx_drops;\n\tint i;\n\n\tif (!test_bit(ENA_FLAG_DEV_UP, &adapter->flags))\n\t\treturn;\n\n\tfor (i = 0; i < adapter->num_io_queues; i++) {\n\t\tu64 bytes, packets;\n\n\t\ttx_ring = &adapter->tx_ring[i];\n\n\t\tdo {\n\t\t\tstart = u64_stats_fetch_begin(&tx_ring->syncp);\n\t\t\tpackets = tx_ring->tx_stats.cnt;\n\t\t\tbytes = tx_ring->tx_stats.bytes;\n\t\t} while (u64_stats_fetch_retry(&tx_ring->syncp, start));\n\n\t\tstats->tx_packets += packets;\n\t\tstats->tx_bytes += bytes;\n\n\t\trx_ring = &adapter->rx_ring[i];\n\n\t\tdo {\n\t\t\tstart = u64_stats_fetch_begin(&rx_ring->syncp);\n\t\t\tpackets = rx_ring->rx_stats.cnt;\n\t\t\tbytes = rx_ring->rx_stats.bytes;\n\t\t} while (u64_stats_fetch_retry(&rx_ring->syncp, start));\n\n\t\tstats->rx_packets += packets;\n\t\tstats->rx_bytes += bytes;\n\t}\n\n\tdo {\n\t\tstart = u64_stats_fetch_begin(&adapter->syncp);\n\t\trx_drops = adapter->dev_stats.rx_drops;\n\t\ttx_drops = adapter->dev_stats.tx_drops;\n\t} while (u64_stats_fetch_retry(&adapter->syncp, start));\n\n\tstats->rx_dropped = rx_drops;\n\tstats->tx_dropped = tx_drops;\n\n\tstats->multicast = 0;\n\tstats->collisions = 0;\n\n\tstats->rx_length_errors = 0;\n\tstats->rx_crc_errors = 0;\n\tstats->rx_frame_errors = 0;\n\tstats->rx_fifo_errors = 0;\n\tstats->rx_missed_errors = 0;\n\tstats->tx_window_errors = 0;\n\n\tstats->rx_errors = 0;\n\tstats->tx_errors = 0;\n}\n\nstatic const struct net_device_ops ena_netdev_ops = {\n\t.ndo_open\t\t= ena_open,\n\t.ndo_stop\t\t= ena_close,\n\t.ndo_start_xmit\t\t= ena_start_xmit,\n\t.ndo_select_queue\t= ena_select_queue,\n\t.ndo_get_stats64\t= ena_get_stats64,\n\t.ndo_tx_timeout\t\t= ena_tx_timeout,\n\t.ndo_change_mtu\t\t= ena_change_mtu,\n\t.ndo_set_mac_address\t= NULL,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_bpf\t\t= ena_xdp,\n\t.ndo_xdp_xmit\t\t= ena_xdp_xmit,\n};\n\nstatic void ena_calc_io_queue_size(struct ena_adapter *adapter,\n\t\t\t\t   struct ena_com_dev_get_features_ctx *get_feat_ctx)\n{\n\tstruct ena_admin_feature_llq_desc *llq = &get_feat_ctx->llq;\n\tstruct ena_com_dev *ena_dev = adapter->ena_dev;\n\tu32 tx_queue_size = ENA_DEFAULT_RING_SIZE;\n\tu32 rx_queue_size = ENA_DEFAULT_RING_SIZE;\n\tu32 max_tx_queue_size;\n\tu32 max_rx_queue_size;\n\n\t \n\tif (adapter->tx_ring->ring_size)\n\t\ttx_queue_size = adapter->tx_ring->ring_size;\n\n\tif (adapter->rx_ring->ring_size)\n\t\trx_queue_size = adapter->rx_ring->ring_size;\n\n\tif (ena_dev->supported_features & BIT(ENA_ADMIN_MAX_QUEUES_EXT)) {\n\t\tstruct ena_admin_queue_ext_feature_fields *max_queue_ext =\n\t\t\t&get_feat_ctx->max_queue_ext.max_queue_ext;\n\t\tmax_rx_queue_size = min_t(u32, max_queue_ext->max_rx_cq_depth,\n\t\t\t\t\t  max_queue_ext->max_rx_sq_depth);\n\t\tmax_tx_queue_size = max_queue_ext->max_tx_cq_depth;\n\n\t\tif (ena_dev->tx_mem_queue_type == ENA_ADMIN_PLACEMENT_POLICY_DEV)\n\t\t\tmax_tx_queue_size = min_t(u32, max_tx_queue_size,\n\t\t\t\t\t\t  llq->max_llq_depth);\n\t\telse\n\t\t\tmax_tx_queue_size = min_t(u32, max_tx_queue_size,\n\t\t\t\t\t\t  max_queue_ext->max_tx_sq_depth);\n\n\t\tadapter->max_tx_sgl_size = min_t(u16, ENA_PKT_MAX_BUFS,\n\t\t\t\t\t\t max_queue_ext->max_per_packet_tx_descs);\n\t\tadapter->max_rx_sgl_size = min_t(u16, ENA_PKT_MAX_BUFS,\n\t\t\t\t\t\t max_queue_ext->max_per_packet_rx_descs);\n\t} else {\n\t\tstruct ena_admin_queue_feature_desc *max_queues =\n\t\t\t&get_feat_ctx->max_queues;\n\t\tmax_rx_queue_size = min_t(u32, max_queues->max_cq_depth,\n\t\t\t\t\t  max_queues->max_sq_depth);\n\t\tmax_tx_queue_size = max_queues->max_cq_depth;\n\n\t\tif (ena_dev->tx_mem_queue_type == ENA_ADMIN_PLACEMENT_POLICY_DEV)\n\t\t\tmax_tx_queue_size = min_t(u32, max_tx_queue_size,\n\t\t\t\t\t\t  llq->max_llq_depth);\n\t\telse\n\t\t\tmax_tx_queue_size = min_t(u32, max_tx_queue_size,\n\t\t\t\t\t\t  max_queues->max_sq_depth);\n\n\t\tadapter->max_tx_sgl_size = min_t(u16, ENA_PKT_MAX_BUFS,\n\t\t\t\t\t\t max_queues->max_packet_tx_descs);\n\t\tadapter->max_rx_sgl_size = min_t(u16, ENA_PKT_MAX_BUFS,\n\t\t\t\t\t\t max_queues->max_packet_rx_descs);\n\t}\n\n\tmax_tx_queue_size = rounddown_pow_of_two(max_tx_queue_size);\n\tmax_rx_queue_size = rounddown_pow_of_two(max_rx_queue_size);\n\n\t \n\tif (adapter->large_llq_header_enabled) {\n\t\tif ((llq->entry_size_ctrl_supported & ENA_ADMIN_LIST_ENTRY_SIZE_256B) &&\n\t\t    ena_dev->tx_mem_queue_type == ENA_ADMIN_PLACEMENT_POLICY_DEV) {\n\t\t\tmax_tx_queue_size /= 2;\n\t\t\tdev_info(&adapter->pdev->dev,\n\t\t\t\t \"Forcing large headers and decreasing maximum TX queue size to %d\\n\",\n\t\t\t\t max_tx_queue_size);\n\t\t} else {\n\t\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\t\"Forcing large headers failed: LLQ is disabled or device does not support large headers\\n\");\n\n\t\t\tadapter->large_llq_header_enabled = false;\n\t\t}\n\t}\n\n\ttx_queue_size = clamp_val(tx_queue_size, ENA_MIN_RING_SIZE,\n\t\t\t\t  max_tx_queue_size);\n\trx_queue_size = clamp_val(rx_queue_size, ENA_MIN_RING_SIZE,\n\t\t\t\t  max_rx_queue_size);\n\n\ttx_queue_size = rounddown_pow_of_two(tx_queue_size);\n\trx_queue_size = rounddown_pow_of_two(rx_queue_size);\n\n\tadapter->max_tx_ring_size  = max_tx_queue_size;\n\tadapter->max_rx_ring_size = max_rx_queue_size;\n\tadapter->requested_tx_ring_size = tx_queue_size;\n\tadapter->requested_rx_ring_size = rx_queue_size;\n}\n\nstatic int ena_device_validate_params(struct ena_adapter *adapter,\n\t\t\t\t      struct ena_com_dev_get_features_ctx *get_feat_ctx)\n{\n\tstruct net_device *netdev = adapter->netdev;\n\tint rc;\n\n\trc = ether_addr_equal(get_feat_ctx->dev_attr.mac_addr,\n\t\t\t      adapter->mac_addr);\n\tif (!rc) {\n\t\tnetif_err(adapter, drv, netdev,\n\t\t\t  \"Error, mac address are different\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (get_feat_ctx->dev_attr.max_mtu < netdev->mtu) {\n\t\tnetif_err(adapter, drv, netdev,\n\t\t\t  \"Error, device max mtu is smaller than netdev MTU\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void set_default_llq_configurations(struct ena_adapter *adapter,\n\t\t\t\t\t   struct ena_llq_configurations *llq_config,\n\t\t\t\t\t   struct ena_admin_feature_llq_desc *llq)\n{\n\tstruct ena_com_dev *ena_dev = adapter->ena_dev;\n\n\tllq_config->llq_header_location = ENA_ADMIN_INLINE_HEADER;\n\tllq_config->llq_stride_ctrl = ENA_ADMIN_MULTIPLE_DESCS_PER_ENTRY;\n\tllq_config->llq_num_decs_before_header = ENA_ADMIN_LLQ_NUM_DESCS_BEFORE_HEADER_2;\n\n\tadapter->large_llq_header_supported =\n\t\t!!(ena_dev->supported_features & BIT(ENA_ADMIN_LLQ));\n\tadapter->large_llq_header_supported &=\n\t\t!!(llq->entry_size_ctrl_supported &\n\t\t\tENA_ADMIN_LIST_ENTRY_SIZE_256B);\n\n\tif ((llq->entry_size_ctrl_supported & ENA_ADMIN_LIST_ENTRY_SIZE_256B) &&\n\t    adapter->large_llq_header_enabled) {\n\t\tllq_config->llq_ring_entry_size = ENA_ADMIN_LIST_ENTRY_SIZE_256B;\n\t\tllq_config->llq_ring_entry_size_value = 256;\n\t} else {\n\t\tllq_config->llq_ring_entry_size = ENA_ADMIN_LIST_ENTRY_SIZE_128B;\n\t\tllq_config->llq_ring_entry_size_value = 128;\n\t}\n}\n\nstatic int ena_set_queues_placement_policy(struct pci_dev *pdev,\n\t\t\t\t\t   struct ena_com_dev *ena_dev,\n\t\t\t\t\t   struct ena_admin_feature_llq_desc *llq,\n\t\t\t\t\t   struct ena_llq_configurations *llq_default_configurations)\n{\n\tint rc;\n\tu32 llq_feature_mask;\n\n\tllq_feature_mask = 1 << ENA_ADMIN_LLQ;\n\tif (!(ena_dev->supported_features & llq_feature_mask)) {\n\t\tdev_warn(&pdev->dev,\n\t\t\t\"LLQ is not supported Fallback to host mode policy.\\n\");\n\t\tena_dev->tx_mem_queue_type = ENA_ADMIN_PLACEMENT_POLICY_HOST;\n\t\treturn 0;\n\t}\n\n\tif (!ena_dev->mem_bar) {\n\t\tnetdev_err(ena_dev->net_device,\n\t\t\t   \"LLQ is advertised as supported but device doesn't expose mem bar\\n\");\n\t\tena_dev->tx_mem_queue_type = ENA_ADMIN_PLACEMENT_POLICY_HOST;\n\t\treturn 0;\n\t}\n\n\trc = ena_com_config_dev_mode(ena_dev, llq, llq_default_configurations);\n\tif (unlikely(rc)) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Failed to configure the device mode.  Fallback to host mode policy.\\n\");\n\t\tena_dev->tx_mem_queue_type = ENA_ADMIN_PLACEMENT_POLICY_HOST;\n\t}\n\n\treturn 0;\n}\n\nstatic int ena_map_llq_mem_bar(struct pci_dev *pdev, struct ena_com_dev *ena_dev,\n\t\t\t       int bars)\n{\n\tbool has_mem_bar = !!(bars & BIT(ENA_MEM_BAR));\n\n\tif (!has_mem_bar)\n\t\treturn 0;\n\n\tena_dev->mem_bar = devm_ioremap_wc(&pdev->dev,\n\t\t\t\t\t   pci_resource_start(pdev, ENA_MEM_BAR),\n\t\t\t\t\t   pci_resource_len(pdev, ENA_MEM_BAR));\n\n\tif (!ena_dev->mem_bar)\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int ena_device_init(struct ena_adapter *adapter, struct pci_dev *pdev,\n\t\t\t   struct ena_com_dev_get_features_ctx *get_feat_ctx,\n\t\t\t   bool *wd_state)\n{\n\tstruct ena_com_dev *ena_dev = adapter->ena_dev;\n\tstruct ena_llq_configurations llq_config;\n\tstruct device *dev = &pdev->dev;\n\tbool readless_supported;\n\tu32 aenq_groups;\n\tint dma_width;\n\tint rc;\n\n\trc = ena_com_mmio_reg_read_request_init(ena_dev);\n\tif (rc) {\n\t\tdev_err(dev, \"Failed to init mmio read less\\n\");\n\t\treturn rc;\n\t}\n\n\t \n\treadless_supported = !(pdev->revision & ENA_MMIO_DISABLE_REG_READ);\n\tena_com_set_mmio_read_mode(ena_dev, readless_supported);\n\n\trc = ena_com_dev_reset(ena_dev, ENA_REGS_RESET_NORMAL);\n\tif (rc) {\n\t\tdev_err(dev, \"Can not reset device\\n\");\n\t\tgoto err_mmio_read_less;\n\t}\n\n\trc = ena_com_validate_version(ena_dev);\n\tif (rc) {\n\t\tdev_err(dev, \"Device version is too low\\n\");\n\t\tgoto err_mmio_read_less;\n\t}\n\n\tdma_width = ena_com_get_dma_width(ena_dev);\n\tif (dma_width < 0) {\n\t\tdev_err(dev, \"Invalid dma width value %d\", dma_width);\n\t\trc = dma_width;\n\t\tgoto err_mmio_read_less;\n\t}\n\n\trc = dma_set_mask_and_coherent(dev, DMA_BIT_MASK(dma_width));\n\tif (rc) {\n\t\tdev_err(dev, \"dma_set_mask_and_coherent failed %d\\n\", rc);\n\t\tgoto err_mmio_read_less;\n\t}\n\n\t \n\trc = ena_com_admin_init(ena_dev, &aenq_handlers);\n\tif (rc) {\n\t\tdev_err(dev,\n\t\t\t\"Can not initialize ena admin queue with device\\n\");\n\t\tgoto err_mmio_read_less;\n\t}\n\n\t \n\tena_com_set_admin_polling_mode(ena_dev, true);\n\n\tena_config_host_info(ena_dev, pdev);\n\n\t \n\trc = ena_com_get_dev_attr_feat(ena_dev, get_feat_ctx);\n\tif (rc) {\n\t\tdev_err(dev, \"Cannot get attribute for ena device rc=%d\\n\", rc);\n\t\tgoto err_admin_init;\n\t}\n\n\t \n\taenq_groups = BIT(ENA_ADMIN_LINK_CHANGE) |\n\t\tBIT(ENA_ADMIN_FATAL_ERROR) |\n\t\tBIT(ENA_ADMIN_WARNING) |\n\t\tBIT(ENA_ADMIN_NOTIFICATION) |\n\t\tBIT(ENA_ADMIN_KEEP_ALIVE);\n\n\taenq_groups &= get_feat_ctx->aenq.supported_groups;\n\n\trc = ena_com_set_aenq_config(ena_dev, aenq_groups);\n\tif (rc) {\n\t\tdev_err(dev, \"Cannot configure aenq groups rc= %d\\n\", rc);\n\t\tgoto err_admin_init;\n\t}\n\n\t*wd_state = !!(aenq_groups & BIT(ENA_ADMIN_KEEP_ALIVE));\n\n\tset_default_llq_configurations(adapter, &llq_config, &get_feat_ctx->llq);\n\n\trc = ena_set_queues_placement_policy(pdev, ena_dev, &get_feat_ctx->llq,\n\t\t\t\t\t     &llq_config);\n\tif (rc) {\n\t\tdev_err(dev, \"ENA device init failed\\n\");\n\t\tgoto err_admin_init;\n\t}\n\n\tena_calc_io_queue_size(adapter, get_feat_ctx);\n\n\treturn 0;\n\nerr_admin_init:\n\tena_com_delete_host_info(ena_dev);\n\tena_com_admin_destroy(ena_dev);\nerr_mmio_read_less:\n\tena_com_mmio_reg_read_request_destroy(ena_dev);\n\n\treturn rc;\n}\n\nstatic int ena_enable_msix_and_set_admin_interrupts(struct ena_adapter *adapter)\n{\n\tstruct ena_com_dev *ena_dev = adapter->ena_dev;\n\tstruct device *dev = &adapter->pdev->dev;\n\tint rc;\n\n\trc = ena_enable_msix(adapter);\n\tif (rc) {\n\t\tdev_err(dev, \"Can not reserve msix vectors\\n\");\n\t\treturn rc;\n\t}\n\n\tena_setup_mgmnt_intr(adapter);\n\n\trc = ena_request_mgmnt_irq(adapter);\n\tif (rc) {\n\t\tdev_err(dev, \"Can not setup management interrupts\\n\");\n\t\tgoto err_disable_msix;\n\t}\n\n\tena_com_set_admin_polling_mode(ena_dev, false);\n\n\tena_com_admin_aenq_enable(ena_dev);\n\n\treturn 0;\n\nerr_disable_msix:\n\tena_disable_msix(adapter);\n\n\treturn rc;\n}\n\nstatic void ena_destroy_device(struct ena_adapter *adapter, bool graceful)\n{\n\tstruct net_device *netdev = adapter->netdev;\n\tstruct ena_com_dev *ena_dev = adapter->ena_dev;\n\tbool dev_up;\n\n\tif (!test_bit(ENA_FLAG_DEVICE_RUNNING, &adapter->flags))\n\t\treturn;\n\n\tnetif_carrier_off(netdev);\n\n\tdel_timer_sync(&adapter->timer_service);\n\n\tdev_up = test_bit(ENA_FLAG_DEV_UP, &adapter->flags);\n\tadapter->dev_up_before_reset = dev_up;\n\tif (!graceful)\n\t\tena_com_set_admin_running_state(ena_dev, false);\n\n\tif (test_bit(ENA_FLAG_DEV_UP, &adapter->flags))\n\t\tena_down(adapter);\n\n\t \n\tif (!(test_bit(ENA_FLAG_TRIGGER_RESET, &adapter->flags) && dev_up))\n\t\tena_com_dev_reset(adapter->ena_dev, adapter->reset_reason);\n\n\tena_free_mgmnt_irq(adapter);\n\n\tena_disable_msix(adapter);\n\n\tena_com_abort_admin_commands(ena_dev);\n\n\tena_com_wait_for_abort_completion(ena_dev);\n\n\tena_com_admin_destroy(ena_dev);\n\n\tena_com_mmio_reg_read_request_destroy(ena_dev);\n\n\t \n\tadapter->reset_reason = ENA_REGS_RESET_NORMAL;\n\n\tclear_bit(ENA_FLAG_TRIGGER_RESET, &adapter->flags);\n\tclear_bit(ENA_FLAG_DEVICE_RUNNING, &adapter->flags);\n}\n\nstatic int ena_restore_device(struct ena_adapter *adapter)\n{\n\tstruct ena_com_dev_get_features_ctx get_feat_ctx;\n\tstruct ena_com_dev *ena_dev = adapter->ena_dev;\n\tstruct pci_dev *pdev = adapter->pdev;\n\tstruct ena_ring *txr;\n\tint rc, count, i;\n\tbool wd_state;\n\n\tset_bit(ENA_FLAG_ONGOING_RESET, &adapter->flags);\n\trc = ena_device_init(adapter, adapter->pdev, &get_feat_ctx, &wd_state);\n\tif (rc) {\n\t\tdev_err(&pdev->dev, \"Can not initialize device\\n\");\n\t\tgoto err;\n\t}\n\tadapter->wd_state = wd_state;\n\n\tcount =  adapter->xdp_num_queues + adapter->num_io_queues;\n\tfor (i = 0 ; i < count; i++) {\n\t\ttxr = &adapter->tx_ring[i];\n\t\ttxr->tx_mem_queue_type = ena_dev->tx_mem_queue_type;\n\t\ttxr->tx_max_header_size = ena_dev->tx_max_header_size;\n\t}\n\n\trc = ena_device_validate_params(adapter, &get_feat_ctx);\n\tif (rc) {\n\t\tdev_err(&pdev->dev, \"Validation of device parameters failed\\n\");\n\t\tgoto err_device_destroy;\n\t}\n\n\trc = ena_enable_msix_and_set_admin_interrupts(adapter);\n\tif (rc) {\n\t\tdev_err(&pdev->dev, \"Enable MSI-X failed\\n\");\n\t\tgoto err_device_destroy;\n\t}\n\t \n\tif (adapter->dev_up_before_reset) {\n\t\trc = ena_up(adapter);\n\t\tif (rc) {\n\t\t\tdev_err(&pdev->dev, \"Failed to create I/O queues\\n\");\n\t\t\tgoto err_disable_msix;\n\t\t}\n\t}\n\n\tset_bit(ENA_FLAG_DEVICE_RUNNING, &adapter->flags);\n\n\tclear_bit(ENA_FLAG_ONGOING_RESET, &adapter->flags);\n\tif (test_bit(ENA_FLAG_LINK_UP, &adapter->flags))\n\t\tnetif_carrier_on(adapter->netdev);\n\n\tmod_timer(&adapter->timer_service, round_jiffies(jiffies + HZ));\n\tadapter->last_keep_alive_jiffies = jiffies;\n\n\treturn rc;\nerr_disable_msix:\n\tena_free_mgmnt_irq(adapter);\n\tena_disable_msix(adapter);\nerr_device_destroy:\n\tena_com_abort_admin_commands(ena_dev);\n\tena_com_wait_for_abort_completion(ena_dev);\n\tena_com_admin_destroy(ena_dev);\n\tena_com_dev_reset(ena_dev, ENA_REGS_RESET_DRIVER_INVALID_STATE);\n\tena_com_mmio_reg_read_request_destroy(ena_dev);\nerr:\n\tclear_bit(ENA_FLAG_DEVICE_RUNNING, &adapter->flags);\n\tclear_bit(ENA_FLAG_ONGOING_RESET, &adapter->flags);\n\tdev_err(&pdev->dev,\n\t\t\"Reset attempt failed. Can not reset the device\\n\");\n\n\treturn rc;\n}\n\nstatic void ena_fw_reset_device(struct work_struct *work)\n{\n\tstruct ena_adapter *adapter =\n\t\tcontainer_of(work, struct ena_adapter, reset_task);\n\n\trtnl_lock();\n\n\tif (likely(test_bit(ENA_FLAG_TRIGGER_RESET, &adapter->flags))) {\n\t\tena_destroy_device(adapter, false);\n\t\tena_restore_device(adapter);\n\n\t\tdev_err(&adapter->pdev->dev, \"Device reset completed successfully\\n\");\n\t}\n\n\trtnl_unlock();\n}\n\nstatic int check_for_rx_interrupt_queue(struct ena_adapter *adapter,\n\t\t\t\t\tstruct ena_ring *rx_ring)\n{\n\tstruct ena_napi *ena_napi = container_of(rx_ring->napi, struct ena_napi, napi);\n\n\tif (likely(READ_ONCE(ena_napi->first_interrupt)))\n\t\treturn 0;\n\n\tif (ena_com_cq_empty(rx_ring->ena_com_io_cq))\n\t\treturn 0;\n\n\trx_ring->no_interrupt_event_cnt++;\n\n\tif (rx_ring->no_interrupt_event_cnt == ENA_MAX_NO_INTERRUPT_ITERATIONS) {\n\t\tnetif_err(adapter, rx_err, adapter->netdev,\n\t\t\t  \"Potential MSIX issue on Rx side Queue = %d. Reset the device\\n\",\n\t\t\t  rx_ring->qid);\n\n\t\tena_reset_device(adapter, ENA_REGS_RESET_MISS_INTERRUPT);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int check_missing_comp_in_tx_queue(struct ena_adapter *adapter,\n\t\t\t\t\t  struct ena_ring *tx_ring)\n{\n\tstruct ena_napi *ena_napi = container_of(tx_ring->napi, struct ena_napi, napi);\n\tunsigned int time_since_last_napi;\n\tunsigned int missing_tx_comp_to;\n\tbool is_tx_comp_time_expired;\n\tstruct ena_tx_buffer *tx_buf;\n\tunsigned long last_jiffies;\n\tu32 missed_tx = 0;\n\tint i, rc = 0;\n\n\tfor (i = 0; i < tx_ring->ring_size; i++) {\n\t\ttx_buf = &tx_ring->tx_buffer_info[i];\n\t\tlast_jiffies = tx_buf->last_jiffies;\n\n\t\tif (last_jiffies == 0)\n\t\t\t \n\t\t\tcontinue;\n\n\t\tis_tx_comp_time_expired = time_is_before_jiffies(last_jiffies +\n\t\t\t 2 * adapter->missing_tx_completion_to);\n\n\t\tif (unlikely(!READ_ONCE(ena_napi->first_interrupt) && is_tx_comp_time_expired)) {\n\t\t\t \n\t\t\tnetif_err(adapter, tx_err, adapter->netdev,\n\t\t\t\t  \"Potential MSIX issue on Tx side Queue = %d. Reset the device\\n\",\n\t\t\t\t  tx_ring->qid);\n\t\t\tena_reset_device(adapter, ENA_REGS_RESET_MISS_INTERRUPT);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tis_tx_comp_time_expired = time_is_before_jiffies(last_jiffies +\n\t\t\tadapter->missing_tx_completion_to);\n\n\t\tif (unlikely(is_tx_comp_time_expired)) {\n\t\t\tif (!tx_buf->print_once) {\n\t\t\t\ttime_since_last_napi = jiffies_to_usecs(jiffies - tx_ring->tx_stats.last_napi_jiffies);\n\t\t\t\tmissing_tx_comp_to = jiffies_to_msecs(adapter->missing_tx_completion_to);\n\t\t\t\tnetif_notice(adapter, tx_err, adapter->netdev,\n\t\t\t\t\t     \"Found a Tx that wasn't completed on time, qid %d, index %d. %u usecs have passed since last napi execution. Missing Tx timeout value %u msecs\\n\",\n\t\t\t\t\t     tx_ring->qid, i, time_since_last_napi, missing_tx_comp_to);\n\t\t\t}\n\n\t\t\ttx_buf->print_once = 1;\n\t\t\tmissed_tx++;\n\t\t}\n\t}\n\n\tif (unlikely(missed_tx > adapter->missing_tx_completion_threshold)) {\n\t\tnetif_err(adapter, tx_err, adapter->netdev,\n\t\t\t  \"The number of lost tx completions is above the threshold (%d > %d). Reset the device\\n\",\n\t\t\t  missed_tx,\n\t\t\t  adapter->missing_tx_completion_threshold);\n\t\tena_reset_device(adapter, ENA_REGS_RESET_MISS_TX_CMPL);\n\t\trc = -EIO;\n\t}\n\n\tena_increase_stat(&tx_ring->tx_stats.missed_tx, missed_tx,\n\t\t\t  &tx_ring->syncp);\n\n\treturn rc;\n}\n\nstatic void check_for_missing_completions(struct ena_adapter *adapter)\n{\n\tstruct ena_ring *tx_ring;\n\tstruct ena_ring *rx_ring;\n\tint i, budget, rc;\n\tint io_queue_count;\n\n\tio_queue_count = adapter->xdp_num_queues + adapter->num_io_queues;\n\t \n\tsmp_rmb();\n\n\tif (!test_bit(ENA_FLAG_DEV_UP, &adapter->flags))\n\t\treturn;\n\n\tif (test_bit(ENA_FLAG_TRIGGER_RESET, &adapter->flags))\n\t\treturn;\n\n\tif (adapter->missing_tx_completion_to == ENA_HW_HINTS_NO_TIMEOUT)\n\t\treturn;\n\n\tbudget = ENA_MONITORED_TX_QUEUES;\n\n\tfor (i = adapter->last_monitored_tx_qid; i < io_queue_count; i++) {\n\t\ttx_ring = &adapter->tx_ring[i];\n\t\trx_ring = &adapter->rx_ring[i];\n\n\t\trc = check_missing_comp_in_tx_queue(adapter, tx_ring);\n\t\tif (unlikely(rc))\n\t\t\treturn;\n\n\t\trc =  !ENA_IS_XDP_INDEX(adapter, i) ?\n\t\t\tcheck_for_rx_interrupt_queue(adapter, rx_ring) : 0;\n\t\tif (unlikely(rc))\n\t\t\treturn;\n\n\t\tbudget--;\n\t\tif (!budget)\n\t\t\tbreak;\n\t}\n\n\tadapter->last_monitored_tx_qid = i % io_queue_count;\n}\n\n \n#define EMPTY_RX_REFILL 2\n \nstatic void check_for_empty_rx_ring(struct ena_adapter *adapter)\n{\n\tstruct ena_ring *rx_ring;\n\tint i, refill_required;\n\n\tif (!test_bit(ENA_FLAG_DEV_UP, &adapter->flags))\n\t\treturn;\n\n\tif (test_bit(ENA_FLAG_TRIGGER_RESET, &adapter->flags))\n\t\treturn;\n\n\tfor (i = 0; i < adapter->num_io_queues; i++) {\n\t\trx_ring = &adapter->rx_ring[i];\n\n\t\trefill_required = ena_com_free_q_entries(rx_ring->ena_com_io_sq);\n\t\tif (unlikely(refill_required == (rx_ring->ring_size - 1))) {\n\t\t\trx_ring->empty_rx_queue++;\n\n\t\t\tif (rx_ring->empty_rx_queue >= EMPTY_RX_REFILL) {\n\t\t\t\tena_increase_stat(&rx_ring->rx_stats.empty_rx_ring, 1,\n\t\t\t\t\t\t  &rx_ring->syncp);\n\n\t\t\t\tnetif_err(adapter, drv, adapter->netdev,\n\t\t\t\t\t  \"Trigger refill for ring %d\\n\", i);\n\n\t\t\t\tnapi_schedule(rx_ring->napi);\n\t\t\t\trx_ring->empty_rx_queue = 0;\n\t\t\t}\n\t\t} else {\n\t\t\trx_ring->empty_rx_queue = 0;\n\t\t}\n\t}\n}\n\n \nstatic void check_for_missing_keep_alive(struct ena_adapter *adapter)\n{\n\tunsigned long keep_alive_expired;\n\n\tif (!adapter->wd_state)\n\t\treturn;\n\n\tif (adapter->keep_alive_timeout == ENA_HW_HINTS_NO_TIMEOUT)\n\t\treturn;\n\n\tkeep_alive_expired = adapter->last_keep_alive_jiffies +\n\t\t\t     adapter->keep_alive_timeout;\n\tif (unlikely(time_is_before_jiffies(keep_alive_expired))) {\n\t\tnetif_err(adapter, drv, adapter->netdev,\n\t\t\t  \"Keep alive watchdog timeout.\\n\");\n\t\tena_increase_stat(&adapter->dev_stats.wd_expired, 1,\n\t\t\t\t  &adapter->syncp);\n\t\tena_reset_device(adapter, ENA_REGS_RESET_KEEP_ALIVE_TO);\n\t}\n}\n\nstatic void check_for_admin_com_state(struct ena_adapter *adapter)\n{\n\tif (unlikely(!ena_com_get_admin_running_state(adapter->ena_dev))) {\n\t\tnetif_err(adapter, drv, adapter->netdev,\n\t\t\t  \"ENA admin queue is not in running state!\\n\");\n\t\tena_increase_stat(&adapter->dev_stats.admin_q_pause, 1,\n\t\t\t\t  &adapter->syncp);\n\t\tena_reset_device(adapter, ENA_REGS_RESET_ADMIN_TO);\n\t}\n}\n\nstatic void ena_update_hints(struct ena_adapter *adapter,\n\t\t\t     struct ena_admin_ena_hw_hints *hints)\n{\n\tstruct net_device *netdev = adapter->netdev;\n\n\tif (hints->admin_completion_tx_timeout)\n\t\tadapter->ena_dev->admin_queue.completion_timeout =\n\t\t\thints->admin_completion_tx_timeout * 1000;\n\n\tif (hints->mmio_read_timeout)\n\t\t \n\t\tadapter->ena_dev->mmio_read.reg_read_to =\n\t\t\thints->mmio_read_timeout * 1000;\n\n\tif (hints->missed_tx_completion_count_threshold_to_reset)\n\t\tadapter->missing_tx_completion_threshold =\n\t\t\thints->missed_tx_completion_count_threshold_to_reset;\n\n\tif (hints->missing_tx_completion_timeout) {\n\t\tif (hints->missing_tx_completion_timeout == ENA_HW_HINTS_NO_TIMEOUT)\n\t\t\tadapter->missing_tx_completion_to = ENA_HW_HINTS_NO_TIMEOUT;\n\t\telse\n\t\t\tadapter->missing_tx_completion_to =\n\t\t\t\tmsecs_to_jiffies(hints->missing_tx_completion_timeout);\n\t}\n\n\tif (hints->netdev_wd_timeout)\n\t\tnetdev->watchdog_timeo = msecs_to_jiffies(hints->netdev_wd_timeout);\n\n\tif (hints->driver_watchdog_timeout) {\n\t\tif (hints->driver_watchdog_timeout == ENA_HW_HINTS_NO_TIMEOUT)\n\t\t\tadapter->keep_alive_timeout = ENA_HW_HINTS_NO_TIMEOUT;\n\t\telse\n\t\t\tadapter->keep_alive_timeout =\n\t\t\t\tmsecs_to_jiffies(hints->driver_watchdog_timeout);\n\t}\n}\n\nstatic void ena_update_host_info(struct ena_admin_host_info *host_info,\n\t\t\t\t struct net_device *netdev)\n{\n\thost_info->supported_network_features[0] =\n\t\tnetdev->features & GENMASK_ULL(31, 0);\n\thost_info->supported_network_features[1] =\n\t\t(netdev->features & GENMASK_ULL(63, 32)) >> 32;\n}\n\nstatic void ena_timer_service(struct timer_list *t)\n{\n\tstruct ena_adapter *adapter = from_timer(adapter, t, timer_service);\n\tu8 *debug_area = adapter->ena_dev->host_attr.debug_area_virt_addr;\n\tstruct ena_admin_host_info *host_info =\n\t\tadapter->ena_dev->host_attr.host_info;\n\n\tcheck_for_missing_keep_alive(adapter);\n\n\tcheck_for_admin_com_state(adapter);\n\n\tcheck_for_missing_completions(adapter);\n\n\tcheck_for_empty_rx_ring(adapter);\n\n\tif (debug_area)\n\t\tena_dump_stats_to_buf(adapter, debug_area);\n\n\tif (host_info)\n\t\tena_update_host_info(host_info, adapter->netdev);\n\n\tif (unlikely(test_bit(ENA_FLAG_TRIGGER_RESET, &adapter->flags))) {\n\t\tnetif_err(adapter, drv, adapter->netdev,\n\t\t\t  \"Trigger reset is on\\n\");\n\t\tena_dump_stats_to_dmesg(adapter);\n\t\tqueue_work(ena_wq, &adapter->reset_task);\n\t\treturn;\n\t}\n\n\t \n\tmod_timer(&adapter->timer_service, round_jiffies(jiffies + HZ));\n}\n\nstatic u32 ena_calc_max_io_queue_num(struct pci_dev *pdev,\n\t\t\t\t     struct ena_com_dev *ena_dev,\n\t\t\t\t     struct ena_com_dev_get_features_ctx *get_feat_ctx)\n{\n\tu32 io_tx_sq_num, io_tx_cq_num, io_rx_num, max_num_io_queues;\n\n\tif (ena_dev->supported_features & BIT(ENA_ADMIN_MAX_QUEUES_EXT)) {\n\t\tstruct ena_admin_queue_ext_feature_fields *max_queue_ext =\n\t\t\t&get_feat_ctx->max_queue_ext.max_queue_ext;\n\t\tio_rx_num = min_t(u32, max_queue_ext->max_rx_sq_num,\n\t\t\t\t  max_queue_ext->max_rx_cq_num);\n\n\t\tio_tx_sq_num = max_queue_ext->max_tx_sq_num;\n\t\tio_tx_cq_num = max_queue_ext->max_tx_cq_num;\n\t} else {\n\t\tstruct ena_admin_queue_feature_desc *max_queues =\n\t\t\t&get_feat_ctx->max_queues;\n\t\tio_tx_sq_num = max_queues->max_sq_num;\n\t\tio_tx_cq_num = max_queues->max_cq_num;\n\t\tio_rx_num = min_t(u32, io_tx_sq_num, io_tx_cq_num);\n\t}\n\n\t \n\tif (ena_dev->tx_mem_queue_type == ENA_ADMIN_PLACEMENT_POLICY_DEV)\n\t\tio_tx_sq_num = get_feat_ctx->llq.max_llq_num;\n\n\tmax_num_io_queues = min_t(u32, num_online_cpus(), ENA_MAX_NUM_IO_QUEUES);\n\tmax_num_io_queues = min_t(u32, max_num_io_queues, io_rx_num);\n\tmax_num_io_queues = min_t(u32, max_num_io_queues, io_tx_sq_num);\n\tmax_num_io_queues = min_t(u32, max_num_io_queues, io_tx_cq_num);\n\t \n\tmax_num_io_queues = min_t(u32, max_num_io_queues, pci_msix_vec_count(pdev) - 1);\n\n\treturn max_num_io_queues;\n}\n\nstatic void ena_set_dev_offloads(struct ena_com_dev_get_features_ctx *feat,\n\t\t\t\t struct net_device *netdev)\n{\n\tnetdev_features_t dev_features = 0;\n\n\t \n\tif (feat->offload.tx &\n\t\tENA_ADMIN_FEATURE_OFFLOAD_DESC_TX_L4_IPV4_CSUM_PART_MASK)\n\t\tdev_features |= NETIF_F_IP_CSUM;\n\n\tif (feat->offload.tx &\n\t\tENA_ADMIN_FEATURE_OFFLOAD_DESC_TX_L4_IPV6_CSUM_PART_MASK)\n\t\tdev_features |= NETIF_F_IPV6_CSUM;\n\n\tif (feat->offload.tx & ENA_ADMIN_FEATURE_OFFLOAD_DESC_TSO_IPV4_MASK)\n\t\tdev_features |= NETIF_F_TSO;\n\n\tif (feat->offload.tx & ENA_ADMIN_FEATURE_OFFLOAD_DESC_TSO_IPV6_MASK)\n\t\tdev_features |= NETIF_F_TSO6;\n\n\tif (feat->offload.tx & ENA_ADMIN_FEATURE_OFFLOAD_DESC_TSO_ECN_MASK)\n\t\tdev_features |= NETIF_F_TSO_ECN;\n\n\tif (feat->offload.rx_supported &\n\t\tENA_ADMIN_FEATURE_OFFLOAD_DESC_RX_L4_IPV4_CSUM_MASK)\n\t\tdev_features |= NETIF_F_RXCSUM;\n\n\tif (feat->offload.rx_supported &\n\t\tENA_ADMIN_FEATURE_OFFLOAD_DESC_RX_L4_IPV6_CSUM_MASK)\n\t\tdev_features |= NETIF_F_RXCSUM;\n\n\tnetdev->features =\n\t\tdev_features |\n\t\tNETIF_F_SG |\n\t\tNETIF_F_RXHASH |\n\t\tNETIF_F_HIGHDMA;\n\n\tnetdev->hw_features |= netdev->features;\n\tnetdev->vlan_features |= netdev->features;\n}\n\nstatic void ena_set_conf_feat_params(struct ena_adapter *adapter,\n\t\t\t\t     struct ena_com_dev_get_features_ctx *feat)\n{\n\tstruct net_device *netdev = adapter->netdev;\n\n\t \n\tif (!is_valid_ether_addr(feat->dev_attr.mac_addr)) {\n\t\teth_hw_addr_random(netdev);\n\t\tether_addr_copy(adapter->mac_addr, netdev->dev_addr);\n\t} else {\n\t\tether_addr_copy(adapter->mac_addr, feat->dev_attr.mac_addr);\n\t\teth_hw_addr_set(netdev, adapter->mac_addr);\n\t}\n\n\t \n\tena_set_dev_offloads(feat, netdev);\n\n\tadapter->max_mtu = feat->dev_attr.max_mtu;\n\tnetdev->max_mtu = adapter->max_mtu;\n\tnetdev->min_mtu = ENA_MIN_MTU;\n}\n\nstatic int ena_rss_init_default(struct ena_adapter *adapter)\n{\n\tstruct ena_com_dev *ena_dev = adapter->ena_dev;\n\tstruct device *dev = &adapter->pdev->dev;\n\tint rc, i;\n\tu32 val;\n\n\trc = ena_com_rss_init(ena_dev, ENA_RX_RSS_TABLE_LOG_SIZE);\n\tif (unlikely(rc)) {\n\t\tdev_err(dev, \"Cannot init indirect table\\n\");\n\t\tgoto err_rss_init;\n\t}\n\n\tfor (i = 0; i < ENA_RX_RSS_TABLE_SIZE; i++) {\n\t\tval = ethtool_rxfh_indir_default(i, adapter->num_io_queues);\n\t\trc = ena_com_indirect_table_fill_entry(ena_dev, i,\n\t\t\t\t\t\t       ENA_IO_RXQ_IDX(val));\n\t\tif (unlikely(rc)) {\n\t\t\tdev_err(dev, \"Cannot fill indirect table\\n\");\n\t\t\tgoto err_fill_indir;\n\t\t}\n\t}\n\n\trc = ena_com_fill_hash_function(ena_dev, ENA_ADMIN_TOEPLITZ, NULL,\n\t\t\t\t\tENA_HASH_KEY_SIZE, 0xFFFFFFFF);\n\tif (unlikely(rc && (rc != -EOPNOTSUPP))) {\n\t\tdev_err(dev, \"Cannot fill hash function\\n\");\n\t\tgoto err_fill_indir;\n\t}\n\n\trc = ena_com_set_default_hash_ctrl(ena_dev);\n\tif (unlikely(rc && (rc != -EOPNOTSUPP))) {\n\t\tdev_err(dev, \"Cannot fill hash control\\n\");\n\t\tgoto err_fill_indir;\n\t}\n\n\treturn 0;\n\nerr_fill_indir:\n\tena_com_rss_destroy(ena_dev);\nerr_rss_init:\n\n\treturn rc;\n}\n\nstatic void ena_release_bars(struct ena_com_dev *ena_dev, struct pci_dev *pdev)\n{\n\tint release_bars = pci_select_bars(pdev, IORESOURCE_MEM) & ENA_BAR_MASK;\n\n\tpci_release_selected_regions(pdev, release_bars);\n}\n\n \nstatic int ena_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tstruct ena_com_dev_get_features_ctx get_feat_ctx;\n\tstruct ena_com_dev *ena_dev = NULL;\n\tstruct ena_adapter *adapter;\n\tstruct net_device *netdev;\n\tstatic int adapters_found;\n\tu32 max_num_io_queues;\n\tbool wd_state;\n\tint bars, rc;\n\n\tdev_dbg(&pdev->dev, \"%s\\n\", __func__);\n\n\trc = pci_enable_device_mem(pdev);\n\tif (rc) {\n\t\tdev_err(&pdev->dev, \"pci_enable_device_mem() failed!\\n\");\n\t\treturn rc;\n\t}\n\n\trc = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(ENA_MAX_PHYS_ADDR_SIZE_BITS));\n\tif (rc) {\n\t\tdev_err(&pdev->dev, \"dma_set_mask_and_coherent failed %d\\n\", rc);\n\t\tgoto err_disable_device;\n\t}\n\n\tpci_set_master(pdev);\n\n\tena_dev = vzalloc(sizeof(*ena_dev));\n\tif (!ena_dev) {\n\t\trc = -ENOMEM;\n\t\tgoto err_disable_device;\n\t}\n\n\tbars = pci_select_bars(pdev, IORESOURCE_MEM) & ENA_BAR_MASK;\n\trc = pci_request_selected_regions(pdev, bars, DRV_MODULE_NAME);\n\tif (rc) {\n\t\tdev_err(&pdev->dev, \"pci_request_selected_regions failed %d\\n\",\n\t\t\trc);\n\t\tgoto err_free_ena_dev;\n\t}\n\n\tena_dev->reg_bar = devm_ioremap(&pdev->dev,\n\t\t\t\t\tpci_resource_start(pdev, ENA_REG_BAR),\n\t\t\t\t\tpci_resource_len(pdev, ENA_REG_BAR));\n\tif (!ena_dev->reg_bar) {\n\t\tdev_err(&pdev->dev, \"Failed to remap regs bar\\n\");\n\t\trc = -EFAULT;\n\t\tgoto err_free_region;\n\t}\n\n\tena_dev->ena_min_poll_delay_us = ENA_ADMIN_POLL_DELAY_US;\n\n\tena_dev->dmadev = &pdev->dev;\n\n\tnetdev = alloc_etherdev_mq(sizeof(struct ena_adapter), ENA_MAX_RINGS);\n\tif (!netdev) {\n\t\tdev_err(&pdev->dev, \"alloc_etherdev_mq failed\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto err_free_region;\n\t}\n\n\tSET_NETDEV_DEV(netdev, &pdev->dev);\n\tadapter = netdev_priv(netdev);\n\tadapter->ena_dev = ena_dev;\n\tadapter->netdev = netdev;\n\tadapter->pdev = pdev;\n\tadapter->msg_enable = DEFAULT_MSG_ENABLE;\n\n\tena_dev->net_device = netdev;\n\n\tpci_set_drvdata(pdev, adapter);\n\n\trc = ena_map_llq_mem_bar(pdev, ena_dev, bars);\n\tif (rc) {\n\t\tdev_err(&pdev->dev, \"ENA LLQ bar mapping failed\\n\");\n\t\tgoto err_netdev_destroy;\n\t}\n\n\trc = ena_device_init(adapter, pdev, &get_feat_ctx, &wd_state);\n\tif (rc) {\n\t\tdev_err(&pdev->dev, \"ENA device init failed\\n\");\n\t\tif (rc == -ETIME)\n\t\t\trc = -EPROBE_DEFER;\n\t\tgoto err_netdev_destroy;\n\t}\n\n\t \n\tena_dev->intr_moder_tx_interval = ENA_INTR_INITIAL_TX_INTERVAL_USECS;\n\tena_dev->intr_moder_rx_interval = ENA_INTR_INITIAL_RX_INTERVAL_USECS;\n\tena_dev->intr_delay_resolution = ENA_DEFAULT_INTR_DELAY_RESOLUTION;\n\tmax_num_io_queues = ena_calc_max_io_queue_num(pdev, ena_dev, &get_feat_ctx);\n\tif (unlikely(!max_num_io_queues)) {\n\t\trc = -EFAULT;\n\t\tgoto err_device_destroy;\n\t}\n\n\tena_set_conf_feat_params(adapter, &get_feat_ctx);\n\n\tadapter->reset_reason = ENA_REGS_RESET_NORMAL;\n\n\tadapter->num_io_queues = max_num_io_queues;\n\tadapter->max_num_io_queues = max_num_io_queues;\n\tadapter->last_monitored_tx_qid = 0;\n\n\tadapter->xdp_first_ring = 0;\n\tadapter->xdp_num_queues = 0;\n\n\tadapter->rx_copybreak = ENA_DEFAULT_RX_COPYBREAK;\n\tif (ena_dev->tx_mem_queue_type == ENA_ADMIN_PLACEMENT_POLICY_DEV)\n\t\tadapter->disable_meta_caching =\n\t\t\t!!(get_feat_ctx.llq.accel_mode.u.get.supported_flags &\n\t\t\t   BIT(ENA_ADMIN_DISABLE_META_CACHING));\n\n\tadapter->wd_state = wd_state;\n\n\tsnprintf(adapter->name, ENA_NAME_MAX_LEN, \"ena_%d\", adapters_found);\n\n\trc = ena_com_init_interrupt_moderation(adapter->ena_dev);\n\tif (rc) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Failed to query interrupt moderation feature\\n\");\n\t\tgoto err_device_destroy;\n\t}\n\n\tena_init_io_rings(adapter,\n\t\t\t  0,\n\t\t\t  adapter->xdp_num_queues +\n\t\t\t  adapter->num_io_queues);\n\n\tnetdev->netdev_ops = &ena_netdev_ops;\n\tnetdev->watchdog_timeo = TX_TIMEOUT;\n\tena_set_ethtool_ops(netdev);\n\n\tnetdev->priv_flags |= IFF_UNICAST_FLT;\n\n\tu64_stats_init(&adapter->syncp);\n\n\trc = ena_enable_msix_and_set_admin_interrupts(adapter);\n\tif (rc) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Failed to enable and set the admin interrupts\\n\");\n\t\tgoto err_worker_destroy;\n\t}\n\trc = ena_rss_init_default(adapter);\n\tif (rc && (rc != -EOPNOTSUPP)) {\n\t\tdev_err(&pdev->dev, \"Cannot init RSS rc: %d\\n\", rc);\n\t\tgoto err_free_msix;\n\t}\n\n\tena_config_debug_area(adapter);\n\n\tif (ena_xdp_legal_queue_count(adapter, adapter->num_io_queues))\n\t\tnetdev->xdp_features = NETDEV_XDP_ACT_BASIC |\n\t\t\t\t       NETDEV_XDP_ACT_REDIRECT;\n\n\tmemcpy(adapter->netdev->perm_addr, adapter->mac_addr, netdev->addr_len);\n\n\tnetif_carrier_off(netdev);\n\n\trc = register_netdev(netdev);\n\tif (rc) {\n\t\tdev_err(&pdev->dev, \"Cannot register net device\\n\");\n\t\tgoto err_rss;\n\t}\n\n\tINIT_WORK(&adapter->reset_task, ena_fw_reset_device);\n\n\tadapter->last_keep_alive_jiffies = jiffies;\n\tadapter->keep_alive_timeout = ENA_DEVICE_KALIVE_TIMEOUT;\n\tadapter->missing_tx_completion_to = TX_TIMEOUT;\n\tadapter->missing_tx_completion_threshold = MAX_NUM_OF_TIMEOUTED_PACKETS;\n\n\tena_update_hints(adapter, &get_feat_ctx.hw_hints);\n\n\ttimer_setup(&adapter->timer_service, ena_timer_service, 0);\n\tmod_timer(&adapter->timer_service, round_jiffies(jiffies + HZ));\n\n\tdev_info(&pdev->dev,\n\t\t \"%s found at mem %lx, mac addr %pM\\n\",\n\t\t DEVICE_NAME, (long)pci_resource_start(pdev, 0),\n\t\t netdev->dev_addr);\n\n\tset_bit(ENA_FLAG_DEVICE_RUNNING, &adapter->flags);\n\n\tadapters_found++;\n\n\treturn 0;\n\nerr_rss:\n\tena_com_delete_debug_area(ena_dev);\n\tena_com_rss_destroy(ena_dev);\nerr_free_msix:\n\tena_com_dev_reset(ena_dev, ENA_REGS_RESET_INIT_ERR);\n\t \n\tena_com_set_admin_running_state(ena_dev, false);\n\tena_free_mgmnt_irq(adapter);\n\tena_disable_msix(adapter);\nerr_worker_destroy:\n\tdel_timer(&adapter->timer_service);\nerr_device_destroy:\n\tena_com_delete_host_info(ena_dev);\n\tena_com_admin_destroy(ena_dev);\nerr_netdev_destroy:\n\tfree_netdev(netdev);\nerr_free_region:\n\tena_release_bars(ena_dev, pdev);\nerr_free_ena_dev:\n\tvfree(ena_dev);\nerr_disable_device:\n\tpci_disable_device(pdev);\n\treturn rc;\n}\n\n \n\n \nstatic void __ena_shutoff(struct pci_dev *pdev, bool shutdown)\n{\n\tstruct ena_adapter *adapter = pci_get_drvdata(pdev);\n\tstruct ena_com_dev *ena_dev;\n\tstruct net_device *netdev;\n\n\tena_dev = adapter->ena_dev;\n\tnetdev = adapter->netdev;\n\n#ifdef CONFIG_RFS_ACCEL\n\tif ((adapter->msix_vecs >= 1) && (netdev->rx_cpu_rmap)) {\n\t\tfree_irq_cpu_rmap(netdev->rx_cpu_rmap);\n\t\tnetdev->rx_cpu_rmap = NULL;\n\t}\n#endif  \n\n\t \n\tdel_timer_sync(&adapter->timer_service);\n\tcancel_work_sync(&adapter->reset_task);\n\n\trtnl_lock();  \n\tadapter->reset_reason = ENA_REGS_RESET_SHUTDOWN;\n\tena_destroy_device(adapter, true);\n\n\tif (shutdown) {\n\t\tnetif_device_detach(netdev);\n\t\tdev_close(netdev);\n\t\trtnl_unlock();\n\t} else {\n\t\trtnl_unlock();\n\t\tunregister_netdev(netdev);\n\t\tfree_netdev(netdev);\n\t}\n\n\tena_com_rss_destroy(ena_dev);\n\n\tena_com_delete_debug_area(ena_dev);\n\n\tena_com_delete_host_info(ena_dev);\n\n\tena_release_bars(ena_dev, pdev);\n\n\tpci_disable_device(pdev);\n\n\tvfree(ena_dev);\n}\n\n \n\nstatic void ena_remove(struct pci_dev *pdev)\n{\n\t__ena_shutoff(pdev, false);\n}\n\n \n\nstatic void ena_shutdown(struct pci_dev *pdev)\n{\n\t__ena_shutoff(pdev, true);\n}\n\n \nstatic int __maybe_unused ena_suspend(struct device *dev_d)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev_d);\n\tstruct ena_adapter *adapter = pci_get_drvdata(pdev);\n\n\tena_increase_stat(&adapter->dev_stats.suspend, 1, &adapter->syncp);\n\n\trtnl_lock();\n\tif (unlikely(test_bit(ENA_FLAG_TRIGGER_RESET, &adapter->flags))) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Ignoring device reset request as the device is being suspended\\n\");\n\t\tclear_bit(ENA_FLAG_TRIGGER_RESET, &adapter->flags);\n\t}\n\tena_destroy_device(adapter, true);\n\trtnl_unlock();\n\treturn 0;\n}\n\n \nstatic int __maybe_unused ena_resume(struct device *dev_d)\n{\n\tstruct ena_adapter *adapter = dev_get_drvdata(dev_d);\n\tint rc;\n\n\tena_increase_stat(&adapter->dev_stats.resume, 1, &adapter->syncp);\n\n\trtnl_lock();\n\trc = ena_restore_device(adapter);\n\trtnl_unlock();\n\treturn rc;\n}\n\nstatic SIMPLE_DEV_PM_OPS(ena_pm_ops, ena_suspend, ena_resume);\n\nstatic struct pci_driver ena_pci_driver = {\n\t.name\t\t= DRV_MODULE_NAME,\n\t.id_table\t= ena_pci_tbl,\n\t.probe\t\t= ena_probe,\n\t.remove\t\t= ena_remove,\n\t.shutdown\t= ena_shutdown,\n\t.driver.pm\t= &ena_pm_ops,\n\t.sriov_configure = pci_sriov_configure_simple,\n};\n\nstatic int __init ena_init(void)\n{\n\tint ret;\n\n\tena_wq = create_singlethread_workqueue(DRV_MODULE_NAME);\n\tif (!ena_wq) {\n\t\tpr_err(\"Failed to create workqueue\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tret = pci_register_driver(&ena_pci_driver);\n\tif (ret)\n\t\tdestroy_workqueue(ena_wq);\n\n\treturn ret;\n}\n\nstatic void __exit ena_cleanup(void)\n{\n\tpci_unregister_driver(&ena_pci_driver);\n\n\tif (ena_wq) {\n\t\tdestroy_workqueue(ena_wq);\n\t\tena_wq = NULL;\n\t}\n}\n\n \n \nstatic void ena_update_on_link_change(void *adapter_data,\n\t\t\t\t      struct ena_admin_aenq_entry *aenq_e)\n{\n\tstruct ena_adapter *adapter = (struct ena_adapter *)adapter_data;\n\tstruct ena_admin_aenq_link_change_desc *aenq_desc =\n\t\t(struct ena_admin_aenq_link_change_desc *)aenq_e;\n\tint status = aenq_desc->flags &\n\t\tENA_ADMIN_AENQ_LINK_CHANGE_DESC_LINK_STATUS_MASK;\n\n\tif (status) {\n\t\tnetif_dbg(adapter, ifup, adapter->netdev, \"%s\\n\", __func__);\n\t\tset_bit(ENA_FLAG_LINK_UP, &adapter->flags);\n\t\tif (!test_bit(ENA_FLAG_ONGOING_RESET, &adapter->flags))\n\t\t\tnetif_carrier_on(adapter->netdev);\n\t} else {\n\t\tclear_bit(ENA_FLAG_LINK_UP, &adapter->flags);\n\t\tnetif_carrier_off(adapter->netdev);\n\t}\n}\n\nstatic void ena_keep_alive_wd(void *adapter_data,\n\t\t\t      struct ena_admin_aenq_entry *aenq_e)\n{\n\tstruct ena_adapter *adapter = (struct ena_adapter *)adapter_data;\n\tstruct ena_admin_aenq_keep_alive_desc *desc;\n\tu64 rx_drops;\n\tu64 tx_drops;\n\n\tdesc = (struct ena_admin_aenq_keep_alive_desc *)aenq_e;\n\tadapter->last_keep_alive_jiffies = jiffies;\n\n\trx_drops = ((u64)desc->rx_drops_high << 32) | desc->rx_drops_low;\n\ttx_drops = ((u64)desc->tx_drops_high << 32) | desc->tx_drops_low;\n\n\tu64_stats_update_begin(&adapter->syncp);\n\t \n\tadapter->dev_stats.rx_drops = rx_drops;\n\tadapter->dev_stats.tx_drops = tx_drops;\n\tu64_stats_update_end(&adapter->syncp);\n}\n\nstatic void ena_notification(void *adapter_data,\n\t\t\t     struct ena_admin_aenq_entry *aenq_e)\n{\n\tstruct ena_adapter *adapter = (struct ena_adapter *)adapter_data;\n\tstruct ena_admin_ena_hw_hints *hints;\n\n\tWARN(aenq_e->aenq_common_desc.group != ENA_ADMIN_NOTIFICATION,\n\t     \"Invalid group(%x) expected %x\\n\",\n\t     aenq_e->aenq_common_desc.group,\n\t     ENA_ADMIN_NOTIFICATION);\n\n\tswitch (aenq_e->aenq_common_desc.syndrome) {\n\tcase ENA_ADMIN_UPDATE_HINTS:\n\t\thints = (struct ena_admin_ena_hw_hints *)\n\t\t\t(&aenq_e->inline_data_w4);\n\t\tena_update_hints(adapter, hints);\n\t\tbreak;\n\tdefault:\n\t\tnetif_err(adapter, drv, adapter->netdev,\n\t\t\t  \"Invalid aenq notification link state %d\\n\",\n\t\t\t  aenq_e->aenq_common_desc.syndrome);\n\t}\n}\n\n \nstatic void unimplemented_aenq_handler(void *data,\n\t\t\t\t       struct ena_admin_aenq_entry *aenq_e)\n{\n\tstruct ena_adapter *adapter = (struct ena_adapter *)data;\n\n\tnetif_err(adapter, drv, adapter->netdev,\n\t\t  \"Unknown event was received or event with unimplemented handler\\n\");\n}\n\nstatic struct ena_aenq_handlers aenq_handlers = {\n\t.handlers = {\n\t\t[ENA_ADMIN_LINK_CHANGE] = ena_update_on_link_change,\n\t\t[ENA_ADMIN_NOTIFICATION] = ena_notification,\n\t\t[ENA_ADMIN_KEEP_ALIVE] = ena_keep_alive_wd,\n\t},\n\t.unimplemented_handler = unimplemented_aenq_handler\n};\n\nmodule_init(ena_init);\nmodule_exit(ena_cleanup);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}