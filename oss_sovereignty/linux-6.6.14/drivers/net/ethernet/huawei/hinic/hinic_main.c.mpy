{
  "module_name": "hinic_main.c",
  "hash_id": "0bda7890945f71d74c4463f2767d56144cfbab04274f9817ec53c541f5707f33",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/huawei/hinic/hinic_main.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/pci.h>\n#include <linux/device.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/etherdevice.h>\n#include <linux/netdevice.h>\n#include <linux/slab.h>\n#include <linux/if_vlan.h>\n#include <linux/semaphore.h>\n#include <linux/workqueue.h>\n#include <net/ip.h>\n#include <net/devlink.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n\n#include \"hinic_debugfs.h\"\n#include \"hinic_hw_qp.h\"\n#include \"hinic_hw_dev.h\"\n#include \"hinic_devlink.h\"\n#include \"hinic_port.h\"\n#include \"hinic_tx.h\"\n#include \"hinic_rx.h\"\n#include \"hinic_dev.h\"\n#include \"hinic_sriov.h\"\n\nMODULE_AUTHOR(\"Huawei Technologies CO., Ltd\");\nMODULE_DESCRIPTION(\"Huawei Intelligent NIC driver\");\nMODULE_LICENSE(\"GPL\");\n\nstatic unsigned int tx_weight = 64;\nmodule_param(tx_weight, uint, 0644);\nMODULE_PARM_DESC(tx_weight, \"Number Tx packets for NAPI budget (default=64)\");\n\nstatic unsigned int rx_weight = 64;\nmodule_param(rx_weight, uint, 0644);\nMODULE_PARM_DESC(rx_weight, \"Number Rx packets for NAPI budget (default=64)\");\n\n#define HINIC_DEV_ID_QUAD_PORT_25GE         0x1822\n#define HINIC_DEV_ID_DUAL_PORT_100GE        0x0200\n#define HINIC_DEV_ID_DUAL_PORT_100GE_MEZZ   0x0205\n#define HINIC_DEV_ID_QUAD_PORT_25GE_MEZZ    0x0210\n#define HINIC_DEV_ID_VF    0x375e\n\n#define HINIC_WQ_NAME                   \"hinic_dev\"\n\n#define MSG_ENABLE_DEFAULT              (NETIF_MSG_DRV | NETIF_MSG_PROBE | \\\n\t\t\t\t\t NETIF_MSG_IFUP |                  \\\n\t\t\t\t\t NETIF_MSG_TX_ERR | NETIF_MSG_RX_ERR)\n\n#define HINIC_LRO_MAX_WQE_NUM_DEFAULT\t8\n\n#define HINIC_LRO_RX_TIMER_DEFAULT\t16\n\n#define work_to_rx_mode_work(work)      \\\n\t\tcontainer_of(work, struct hinic_rx_mode_work, work)\n\n#define rx_mode_work_to_nic_dev(rx_mode_work) \\\n\t\tcontainer_of(rx_mode_work, struct hinic_dev, rx_mode_work)\n\n#define HINIC_WAIT_SRIOV_CFG_TIMEOUT\t15000\n\n#define HINIC_DEAULT_TXRX_MSIX_PENDING_LIMIT\t\t2\n#define HINIC_DEAULT_TXRX_MSIX_COALESC_TIMER_CFG\t32\n#define HINIC_DEAULT_TXRX_MSIX_RESEND_TIMER_CFG\t\t7\n\nstatic int change_mac_addr(struct net_device *netdev, const u8 *addr);\n\nstatic int set_features(struct hinic_dev *nic_dev,\n\t\t\tnetdev_features_t pre_features,\n\t\t\tnetdev_features_t features, bool force_change);\n\nstatic void gather_rx_stats(struct hinic_rxq_stats *nic_rx_stats, struct hinic_rxq *rxq)\n{\n\tstruct hinic_rxq_stats rx_stats;\n\n\thinic_rxq_get_stats(rxq, &rx_stats);\n\n\tnic_rx_stats->bytes += rx_stats.bytes;\n\tnic_rx_stats->pkts  += rx_stats.pkts;\n\tnic_rx_stats->errors += rx_stats.errors;\n\tnic_rx_stats->csum_errors += rx_stats.csum_errors;\n\tnic_rx_stats->other_errors += rx_stats.other_errors;\n}\n\nstatic void gather_tx_stats(struct hinic_txq_stats *nic_tx_stats, struct hinic_txq *txq)\n{\n\tstruct hinic_txq_stats tx_stats;\n\n\thinic_txq_get_stats(txq, &tx_stats);\n\n\tnic_tx_stats->bytes += tx_stats.bytes;\n\tnic_tx_stats->pkts += tx_stats.pkts;\n\tnic_tx_stats->tx_busy += tx_stats.tx_busy;\n\tnic_tx_stats->tx_wake += tx_stats.tx_wake;\n\tnic_tx_stats->tx_dropped += tx_stats.tx_dropped;\n\tnic_tx_stats->big_frags_pkts += tx_stats.big_frags_pkts;\n}\n\nstatic void gather_nic_stats(struct hinic_dev *nic_dev,\n\t\t\t     struct hinic_rxq_stats *nic_rx_stats,\n\t\t\t     struct hinic_txq_stats *nic_tx_stats)\n{\n\tint i, num_qps = hinic_hwdev_num_qps(nic_dev->hwdev);\n\n\tfor (i = 0; i < num_qps; i++)\n\t\tgather_rx_stats(nic_rx_stats, &nic_dev->rxqs[i]);\n\n\tfor (i = 0; i < num_qps; i++)\n\t\tgather_tx_stats(nic_tx_stats, &nic_dev->txqs[i]);\n}\n\n \nstatic int create_txqs(struct hinic_dev *nic_dev)\n{\n\tint err, i, j, num_txqs = hinic_hwdev_num_qps(nic_dev->hwdev);\n\tstruct net_device *netdev = nic_dev->netdev;\n\n\tif (nic_dev->txqs)\n\t\treturn -EINVAL;\n\n\tnic_dev->txqs = devm_kcalloc(&netdev->dev, num_txqs,\n\t\t\t\t     sizeof(*nic_dev->txqs), GFP_KERNEL);\n\tif (!nic_dev->txqs)\n\t\treturn -ENOMEM;\n\n\thinic_sq_dbgfs_init(nic_dev);\n\n\tfor (i = 0; i < num_txqs; i++) {\n\t\tstruct hinic_sq *sq = hinic_hwdev_get_sq(nic_dev->hwdev, i);\n\n\t\terr = hinic_init_txq(&nic_dev->txqs[i], sq, netdev);\n\t\tif (err) {\n\t\t\tnetif_err(nic_dev, drv, netdev,\n\t\t\t\t  \"Failed to init Txq\\n\");\n\t\t\tgoto err_init_txq;\n\t\t}\n\n\t\terr = hinic_sq_debug_add(nic_dev, i);\n\t\tif (err) {\n\t\t\tnetif_err(nic_dev, drv, netdev,\n\t\t\t\t  \"Failed to add SQ%d debug\\n\", i);\n\t\t\tgoto err_add_sq_dbg;\n\t\t}\n\t}\n\n\treturn 0;\n\nerr_add_sq_dbg:\n\thinic_clean_txq(&nic_dev->txqs[i]);\nerr_init_txq:\n\tfor (j = 0; j < i; j++) {\n\t\thinic_sq_debug_rem(nic_dev->txqs[j].sq);\n\t\thinic_clean_txq(&nic_dev->txqs[j]);\n\t}\n\n\thinic_sq_dbgfs_uninit(nic_dev);\n\n\tdevm_kfree(&netdev->dev, nic_dev->txqs);\n\treturn err;\n}\n\nstatic void enable_txqs_napi(struct hinic_dev *nic_dev)\n{\n\tint num_txqs = hinic_hwdev_num_qps(nic_dev->hwdev);\n\tint i;\n\n\tfor (i = 0; i < num_txqs; i++)\n\t\tnapi_enable(&nic_dev->txqs[i].napi);\n}\n\nstatic void disable_txqs_napi(struct hinic_dev *nic_dev)\n{\n\tint num_txqs = hinic_hwdev_num_qps(nic_dev->hwdev);\n\tint i;\n\n\tfor (i = 0; i < num_txqs; i++)\n\t\tnapi_disable(&nic_dev->txqs[i].napi);\n}\n\n \nstatic void free_txqs(struct hinic_dev *nic_dev)\n{\n\tint i, num_txqs = hinic_hwdev_num_qps(nic_dev->hwdev);\n\tstruct net_device *netdev = nic_dev->netdev;\n\n\tif (!nic_dev->txqs)\n\t\treturn;\n\n\tfor (i = 0; i < num_txqs; i++) {\n\t\thinic_sq_debug_rem(nic_dev->txqs[i].sq);\n\t\thinic_clean_txq(&nic_dev->txqs[i]);\n\t}\n\n\thinic_sq_dbgfs_uninit(nic_dev);\n\n\tdevm_kfree(&netdev->dev, nic_dev->txqs);\n\tnic_dev->txqs = NULL;\n}\n\n \nstatic int create_rxqs(struct hinic_dev *nic_dev)\n{\n\tint err, i, j, num_rxqs = hinic_hwdev_num_qps(nic_dev->hwdev);\n\tstruct net_device *netdev = nic_dev->netdev;\n\n\tif (nic_dev->rxqs)\n\t\treturn -EINVAL;\n\n\tnic_dev->rxqs = devm_kcalloc(&netdev->dev, num_rxqs,\n\t\t\t\t     sizeof(*nic_dev->rxqs), GFP_KERNEL);\n\tif (!nic_dev->rxqs)\n\t\treturn -ENOMEM;\n\n\thinic_rq_dbgfs_init(nic_dev);\n\n\tfor (i = 0; i < num_rxqs; i++) {\n\t\tstruct hinic_rq *rq = hinic_hwdev_get_rq(nic_dev->hwdev, i);\n\n\t\terr = hinic_init_rxq(&nic_dev->rxqs[i], rq, netdev);\n\t\tif (err) {\n\t\t\tnetif_err(nic_dev, drv, netdev,\n\t\t\t\t  \"Failed to init rxq\\n\");\n\t\t\tgoto err_init_rxq;\n\t\t}\n\n\t\terr = hinic_rq_debug_add(nic_dev, i);\n\t\tif (err) {\n\t\t\tnetif_err(nic_dev, drv, netdev,\n\t\t\t\t  \"Failed to add RQ%d debug\\n\", i);\n\t\t\tgoto err_add_rq_dbg;\n\t\t}\n\t}\n\n\treturn 0;\n\nerr_add_rq_dbg:\n\thinic_clean_rxq(&nic_dev->rxqs[i]);\nerr_init_rxq:\n\tfor (j = 0; j < i; j++) {\n\t\thinic_rq_debug_rem(nic_dev->rxqs[j].rq);\n\t\thinic_clean_rxq(&nic_dev->rxqs[j]);\n\t}\n\n\thinic_rq_dbgfs_uninit(nic_dev);\n\n\tdevm_kfree(&netdev->dev, nic_dev->rxqs);\n\treturn err;\n}\n\n \nstatic void free_rxqs(struct hinic_dev *nic_dev)\n{\n\tint i, num_rxqs = hinic_hwdev_num_qps(nic_dev->hwdev);\n\tstruct net_device *netdev = nic_dev->netdev;\n\n\tif (!nic_dev->rxqs)\n\t\treturn;\n\n\tfor (i = 0; i < num_rxqs; i++) {\n\t\thinic_rq_debug_rem(nic_dev->rxqs[i].rq);\n\t\thinic_clean_rxq(&nic_dev->rxqs[i]);\n\t}\n\n\thinic_rq_dbgfs_uninit(nic_dev);\n\n\tdevm_kfree(&netdev->dev, nic_dev->rxqs);\n\tnic_dev->rxqs = NULL;\n}\n\nstatic int hinic_configure_max_qnum(struct hinic_dev *nic_dev)\n{\n\treturn hinic_set_max_qnum(nic_dev, nic_dev->hwdev->nic_cap.max_qps);\n}\n\nstatic int hinic_rss_init(struct hinic_dev *nic_dev)\n{\n\tu8 default_rss_key[HINIC_RSS_KEY_SIZE];\n\tu8 tmpl_idx = nic_dev->rss_tmpl_idx;\n\tu32 *indir_tbl;\n\tint err, i;\n\n\tindir_tbl = kcalloc(HINIC_RSS_INDIR_SIZE, sizeof(u32), GFP_KERNEL);\n\tif (!indir_tbl)\n\t\treturn -ENOMEM;\n\n\tnetdev_rss_key_fill(default_rss_key, sizeof(default_rss_key));\n\tfor (i = 0; i < HINIC_RSS_INDIR_SIZE; i++)\n\t\tindir_tbl[i] = ethtool_rxfh_indir_default(i, nic_dev->num_rss);\n\n\terr = hinic_rss_set_template_tbl(nic_dev, tmpl_idx, default_rss_key);\n\tif (err)\n\t\tgoto out;\n\n\terr = hinic_rss_set_indir_tbl(nic_dev, tmpl_idx, indir_tbl);\n\tif (err)\n\t\tgoto out;\n\n\terr = hinic_set_rss_type(nic_dev, tmpl_idx, nic_dev->rss_type);\n\tif (err)\n\t\tgoto out;\n\n\terr = hinic_rss_set_hash_engine(nic_dev, tmpl_idx,\n\t\t\t\t\tnic_dev->rss_hash_engine);\n\tif (err)\n\t\tgoto out;\n\n\terr = hinic_rss_cfg(nic_dev, 1, tmpl_idx);\n\tif (err)\n\t\tgoto out;\n\nout:\n\tkfree(indir_tbl);\n\treturn err;\n}\n\nstatic void hinic_rss_deinit(struct hinic_dev *nic_dev)\n{\n\thinic_rss_cfg(nic_dev, 0, nic_dev->rss_tmpl_idx);\n}\n\nstatic void hinic_init_rss_parameters(struct hinic_dev *nic_dev)\n{\n\tnic_dev->rss_hash_engine = HINIC_RSS_HASH_ENGINE_TYPE_XOR;\n\tnic_dev->rss_type.tcp_ipv6_ext = 1;\n\tnic_dev->rss_type.ipv6_ext = 1;\n\tnic_dev->rss_type.tcp_ipv6 = 1;\n\tnic_dev->rss_type.ipv6 = 1;\n\tnic_dev->rss_type.tcp_ipv4 = 1;\n\tnic_dev->rss_type.ipv4 = 1;\n\tnic_dev->rss_type.udp_ipv6 = 1;\n\tnic_dev->rss_type.udp_ipv4 = 1;\n}\n\nstatic void hinic_enable_rss(struct hinic_dev *nic_dev)\n{\n\tstruct net_device *netdev = nic_dev->netdev;\n\tstruct hinic_hwdev *hwdev = nic_dev->hwdev;\n\tstruct hinic_hwif *hwif = hwdev->hwif;\n\tstruct pci_dev *pdev = hwif->pdev;\n\tint i, node, err = 0;\n\tu16 num_cpus = 0;\n\n\tif (nic_dev->max_qps <= 1) {\n\t\tnic_dev->flags &= ~HINIC_RSS_ENABLE;\n\t\tnic_dev->rss_limit = nic_dev->max_qps;\n\t\tnic_dev->num_qps = nic_dev->max_qps;\n\t\tnic_dev->num_rss = nic_dev->max_qps;\n\n\t\treturn;\n\t}\n\n\terr = hinic_rss_template_alloc(nic_dev, &nic_dev->rss_tmpl_idx);\n\tif (err) {\n\t\tnetif_err(nic_dev, drv, netdev,\n\t\t\t  \"Failed to alloc tmpl_idx for rss, can't enable rss for this function\\n\");\n\t\tnic_dev->flags &= ~HINIC_RSS_ENABLE;\n\t\tnic_dev->max_qps = 1;\n\t\tnic_dev->rss_limit = nic_dev->max_qps;\n\t\tnic_dev->num_qps = nic_dev->max_qps;\n\t\tnic_dev->num_rss = nic_dev->max_qps;\n\n\t\treturn;\n\t}\n\n\tnic_dev->flags |= HINIC_RSS_ENABLE;\n\n\tfor (i = 0; i < num_online_cpus(); i++) {\n\t\tnode = cpu_to_node(i);\n\t\tif (node == dev_to_node(&pdev->dev))\n\t\t\tnum_cpus++;\n\t}\n\n\tif (!num_cpus)\n\t\tnum_cpus = num_online_cpus();\n\n\tnic_dev->num_qps = hinic_hwdev_num_qps(hwdev);\n\tnic_dev->num_qps = min_t(u16, nic_dev->num_qps, num_cpus);\n\n\tnic_dev->rss_limit = nic_dev->num_qps;\n\tnic_dev->num_rss = nic_dev->num_qps;\n\n\thinic_init_rss_parameters(nic_dev);\n\terr = hinic_rss_init(nic_dev);\n\tif (err)\n\t\tnetif_err(nic_dev, drv, netdev, \"Failed to init rss\\n\");\n}\n\nint hinic_open(struct net_device *netdev)\n{\n\tstruct hinic_dev *nic_dev = netdev_priv(netdev);\n\tenum hinic_port_link_state link_state;\n\tint err, ret;\n\n\tif (!(nic_dev->flags & HINIC_INTF_UP)) {\n\t\terr = hinic_hwdev_ifup(nic_dev->hwdev, nic_dev->sq_depth,\n\t\t\t\t       nic_dev->rq_depth);\n\t\tif (err) {\n\t\t\tnetif_err(nic_dev, drv, netdev,\n\t\t\t\t  \"Failed - HW interface up\\n\");\n\t\t\treturn err;\n\t\t}\n\t}\n\n\terr = create_txqs(nic_dev);\n\tif (err) {\n\t\tnetif_err(nic_dev, drv, netdev,\n\t\t\t  \"Failed to create Tx queues\\n\");\n\t\tgoto err_create_txqs;\n\t}\n\n\tenable_txqs_napi(nic_dev);\n\n\terr = create_rxqs(nic_dev);\n\tif (err) {\n\t\tnetif_err(nic_dev, drv, netdev,\n\t\t\t  \"Failed to create Rx queues\\n\");\n\t\tgoto err_create_rxqs;\n\t}\n\n\thinic_enable_rss(nic_dev);\n\n\terr = hinic_configure_max_qnum(nic_dev);\n\tif (err) {\n\t\tnetif_err(nic_dev, drv, nic_dev->netdev,\n\t\t\t  \"Failed to configure the maximum number of queues\\n\");\n\t\tgoto err_port_state;\n\t}\n\n\tnetif_set_real_num_tx_queues(netdev, nic_dev->num_qps);\n\tnetif_set_real_num_rx_queues(netdev, nic_dev->num_qps);\n\n\terr = hinic_port_set_state(nic_dev, HINIC_PORT_ENABLE);\n\tif (err) {\n\t\tnetif_err(nic_dev, drv, netdev,\n\t\t\t  \"Failed to set port state\\n\");\n\t\tgoto err_port_state;\n\t}\n\n\terr = hinic_port_set_func_state(nic_dev, HINIC_FUNC_PORT_ENABLE);\n\tif (err) {\n\t\tnetif_err(nic_dev, drv, netdev,\n\t\t\t  \"Failed to set func port state\\n\");\n\t\tgoto err_func_port_state;\n\t}\n\n\tdown(&nic_dev->mgmt_lock);\n\n\terr = hinic_port_link_state(nic_dev, &link_state);\n\tif (err) {\n\t\tnetif_err(nic_dev, drv, netdev, \"Failed to get link state\\n\");\n\t\tgoto err_port_link;\n\t}\n\n\tif (!HINIC_IS_VF(nic_dev->hwdev->hwif))\n\t\thinic_notify_all_vfs_link_changed(nic_dev->hwdev, link_state);\n\n\tif (link_state == HINIC_LINK_STATE_UP) {\n\t\tnic_dev->flags |= HINIC_LINK_UP;\n\t\tnic_dev->cable_unplugged = false;\n\t\tnic_dev->module_unrecognized = false;\n\t}\n\n\tnic_dev->flags |= HINIC_INTF_UP;\n\n\tif ((nic_dev->flags & (HINIC_LINK_UP | HINIC_INTF_UP)) ==\n\t    (HINIC_LINK_UP | HINIC_INTF_UP)) {\n\t\tnetif_info(nic_dev, drv, netdev, \"link + intf UP\\n\");\n\t\tnetif_carrier_on(netdev);\n\t\tnetif_tx_wake_all_queues(netdev);\n\t}\n\n\tup(&nic_dev->mgmt_lock);\n\n\tnetif_info(nic_dev, drv, netdev, \"HINIC_INTF is UP\\n\");\n\treturn 0;\n\nerr_port_link:\n\tup(&nic_dev->mgmt_lock);\n\tret = hinic_port_set_func_state(nic_dev, HINIC_FUNC_PORT_DISABLE);\n\tif (ret)\n\t\tnetif_warn(nic_dev, drv, netdev,\n\t\t\t   \"Failed to revert func port state\\n\");\n\nerr_func_port_state:\n\tret = hinic_port_set_state(nic_dev, HINIC_PORT_DISABLE);\n\tif (ret)\n\t\tnetif_warn(nic_dev, drv, netdev,\n\t\t\t   \"Failed to revert port state\\n\");\nerr_port_state:\n\tfree_rxqs(nic_dev);\n\tif (nic_dev->flags & HINIC_RSS_ENABLE) {\n\t\thinic_rss_deinit(nic_dev);\n\t\thinic_rss_template_free(nic_dev, nic_dev->rss_tmpl_idx);\n\t}\n\nerr_create_rxqs:\n\tdisable_txqs_napi(nic_dev);\n\tfree_txqs(nic_dev);\n\nerr_create_txqs:\n\tif (!(nic_dev->flags & HINIC_INTF_UP))\n\t\thinic_hwdev_ifdown(nic_dev->hwdev);\n\treturn err;\n}\n\nint hinic_close(struct net_device *netdev)\n{\n\tstruct hinic_dev *nic_dev = netdev_priv(netdev);\n\tunsigned int flags;\n\n\t \n\tdisable_txqs_napi(nic_dev);\n\n\tdown(&nic_dev->mgmt_lock);\n\n\tflags = nic_dev->flags;\n\tnic_dev->flags &= ~HINIC_INTF_UP;\n\n\tnetif_carrier_off(netdev);\n\tnetif_tx_disable(netdev);\n\n\tup(&nic_dev->mgmt_lock);\n\n\tif (!HINIC_IS_VF(nic_dev->hwdev->hwif))\n\t\thinic_notify_all_vfs_link_changed(nic_dev->hwdev, 0);\n\n\thinic_port_set_state(nic_dev, HINIC_PORT_DISABLE);\n\n\thinic_port_set_func_state(nic_dev, HINIC_FUNC_PORT_DISABLE);\n\n\tif (nic_dev->flags & HINIC_RSS_ENABLE) {\n\t\thinic_rss_deinit(nic_dev);\n\t\thinic_rss_template_free(nic_dev, nic_dev->rss_tmpl_idx);\n\t}\n\n\tfree_rxqs(nic_dev);\n\tfree_txqs(nic_dev);\n\n\tif (flags & HINIC_INTF_UP)\n\t\thinic_hwdev_ifdown(nic_dev->hwdev);\n\n\tnetif_info(nic_dev, drv, netdev, \"HINIC_INTF is DOWN\\n\");\n\treturn 0;\n}\n\nstatic int hinic_change_mtu(struct net_device *netdev, int new_mtu)\n{\n\tstruct hinic_dev *nic_dev = netdev_priv(netdev);\n\tint err;\n\n\tnetif_info(nic_dev, drv, netdev, \"set_mtu = %d\\n\", new_mtu);\n\n\terr = hinic_port_set_mtu(nic_dev, new_mtu);\n\tif (err)\n\t\tnetif_err(nic_dev, drv, netdev, \"Failed to set port mtu\\n\");\n\telse\n\t\tnetdev->mtu = new_mtu;\n\n\treturn err;\n}\n\n \nstatic int change_mac_addr(struct net_device *netdev, const u8 *addr)\n{\n\tstruct hinic_dev *nic_dev = netdev_priv(netdev);\n\tu16 vid = 0;\n\tint err;\n\n\tif (!is_valid_ether_addr(addr))\n\t\treturn -EADDRNOTAVAIL;\n\n\tnetif_info(nic_dev, drv, netdev, \"change mac addr = %02x %02x %02x %02x %02x %02x\\n\",\n\t\t   addr[0], addr[1], addr[2], addr[3], addr[4], addr[5]);\n\n\tdown(&nic_dev->mgmt_lock);\n\n\tdo {\n\t\terr = hinic_port_del_mac(nic_dev, netdev->dev_addr, vid);\n\t\tif (err) {\n\t\t\tnetif_err(nic_dev, drv, netdev,\n\t\t\t\t  \"Failed to delete mac\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\terr = hinic_port_add_mac(nic_dev, addr, vid);\n\t\tif (err) {\n\t\t\tnetif_err(nic_dev, drv, netdev, \"Failed to add mac\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tvid = find_next_bit(nic_dev->vlan_bitmap, VLAN_N_VID, vid + 1);\n\t} while (vid != VLAN_N_VID);\n\n\tup(&nic_dev->mgmt_lock);\n\treturn err;\n}\n\nstatic int hinic_set_mac_addr(struct net_device *netdev, void *addr)\n{\n\tunsigned char new_mac[ETH_ALEN];\n\tstruct sockaddr *saddr = addr;\n\tint err;\n\n\tmemcpy(new_mac, saddr->sa_data, ETH_ALEN);\n\n\terr = change_mac_addr(netdev, new_mac);\n\tif (!err)\n\t\teth_hw_addr_set(netdev, new_mac);\n\n\treturn err;\n}\n\n \nstatic int add_mac_addr(struct net_device *netdev, const u8 *addr)\n{\n\tstruct hinic_dev *nic_dev = netdev_priv(netdev);\n\tu16 vid = 0;\n\tint err;\n\n\tnetif_info(nic_dev, drv, netdev, \"set mac addr = %02x %02x %02x %02x %02x %02x\\n\",\n\t\t   addr[0], addr[1], addr[2], addr[3], addr[4], addr[5]);\n\n\tdown(&nic_dev->mgmt_lock);\n\n\tdo {\n\t\terr = hinic_port_add_mac(nic_dev, addr, vid);\n\t\tif (err) {\n\t\t\tnetif_err(nic_dev, drv, netdev, \"Failed to add mac\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tvid = find_next_bit(nic_dev->vlan_bitmap, VLAN_N_VID, vid + 1);\n\t} while (vid != VLAN_N_VID);\n\n\tup(&nic_dev->mgmt_lock);\n\treturn err;\n}\n\n \nstatic int remove_mac_addr(struct net_device *netdev, const u8 *addr)\n{\n\tstruct hinic_dev *nic_dev = netdev_priv(netdev);\n\tu16 vid = 0;\n\tint err;\n\n\tif (!is_valid_ether_addr(addr))\n\t\treturn -EADDRNOTAVAIL;\n\n\tnetif_info(nic_dev, drv, netdev, \"remove mac addr = %02x %02x %02x %02x %02x %02x\\n\",\n\t\t   addr[0], addr[1], addr[2], addr[3], addr[4], addr[5]);\n\n\tdown(&nic_dev->mgmt_lock);\n\n\tdo {\n\t\terr = hinic_port_del_mac(nic_dev, addr, vid);\n\t\tif (err) {\n\t\t\tnetif_err(nic_dev, drv, netdev,\n\t\t\t\t  \"Failed to delete mac\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tvid = find_next_bit(nic_dev->vlan_bitmap, VLAN_N_VID, vid + 1);\n\t} while (vid != VLAN_N_VID);\n\n\tup(&nic_dev->mgmt_lock);\n\treturn err;\n}\n\nstatic int hinic_vlan_rx_add_vid(struct net_device *netdev,\n\t\t\t\t __always_unused __be16 proto, u16 vid)\n{\n\tstruct hinic_dev *nic_dev = netdev_priv(netdev);\n\tint ret, err;\n\n\tnetif_info(nic_dev, drv, netdev, \"add vid = %d\\n\", vid);\n\n\tdown(&nic_dev->mgmt_lock);\n\n\terr = hinic_port_add_vlan(nic_dev, vid);\n\tif (err) {\n\t\tnetif_err(nic_dev, drv, netdev, \"Failed to add vlan\\n\");\n\t\tgoto err_vlan_add;\n\t}\n\n\terr = hinic_port_add_mac(nic_dev, netdev->dev_addr, vid);\n\tif (err && err != HINIC_PF_SET_VF_ALREADY) {\n\t\tnetif_err(nic_dev, drv, netdev, \"Failed to set mac\\n\");\n\t\tgoto err_add_mac;\n\t}\n\n\tbitmap_set(nic_dev->vlan_bitmap, vid, 1);\n\n\tup(&nic_dev->mgmt_lock);\n\treturn 0;\n\nerr_add_mac:\n\tret = hinic_port_del_vlan(nic_dev, vid);\n\tif (ret)\n\t\tnetif_err(nic_dev, drv, netdev,\n\t\t\t  \"Failed to revert by removing vlan\\n\");\n\nerr_vlan_add:\n\tup(&nic_dev->mgmt_lock);\n\treturn err;\n}\n\nstatic int hinic_vlan_rx_kill_vid(struct net_device *netdev,\n\t\t\t\t  __always_unused __be16 proto, u16 vid)\n{\n\tstruct hinic_dev *nic_dev = netdev_priv(netdev);\n\tint err;\n\n\tnetif_info(nic_dev, drv, netdev, \"remove vid = %d\\n\", vid);\n\n\tdown(&nic_dev->mgmt_lock);\n\n\terr = hinic_port_del_vlan(nic_dev, vid);\n\tif (err) {\n\t\tnetif_err(nic_dev, drv, netdev, \"Failed to delete vlan\\n\");\n\t\tgoto err_del_vlan;\n\t}\n\n\tbitmap_clear(nic_dev->vlan_bitmap, vid, 1);\n\n\tup(&nic_dev->mgmt_lock);\n\treturn 0;\n\nerr_del_vlan:\n\tup(&nic_dev->mgmt_lock);\n\treturn err;\n}\n\nstatic void set_rx_mode(struct work_struct *work)\n{\n\tstruct hinic_rx_mode_work *rx_mode_work = work_to_rx_mode_work(work);\n\tstruct hinic_dev *nic_dev = rx_mode_work_to_nic_dev(rx_mode_work);\n\n\thinic_port_set_rx_mode(nic_dev, rx_mode_work->rx_mode);\n\n\t__dev_uc_sync(nic_dev->netdev, add_mac_addr, remove_mac_addr);\n\t__dev_mc_sync(nic_dev->netdev, add_mac_addr, remove_mac_addr);\n}\n\nstatic void hinic_set_rx_mode(struct net_device *netdev)\n{\n\tstruct hinic_dev *nic_dev = netdev_priv(netdev);\n\tstruct hinic_rx_mode_work *rx_mode_work;\n\tu32 rx_mode;\n\n\trx_mode_work = &nic_dev->rx_mode_work;\n\n\trx_mode = HINIC_RX_MODE_UC |\n\t\t  HINIC_RX_MODE_MC |\n\t\t  HINIC_RX_MODE_BC;\n\n\tif (netdev->flags & IFF_PROMISC) {\n\t\tif (!HINIC_IS_VF(nic_dev->hwdev->hwif))\n\t\t\trx_mode |= HINIC_RX_MODE_PROMISC;\n\t} else if (netdev->flags & IFF_ALLMULTI) {\n\t\trx_mode |= HINIC_RX_MODE_MC_ALL;\n\t}\n\n\trx_mode_work->rx_mode = rx_mode;\n\n\tqueue_work(nic_dev->workq, &rx_mode_work->work);\n}\n\nstatic void hinic_tx_timeout(struct net_device *netdev, unsigned int txqueue)\n{\n\tstruct hinic_dev *nic_dev = netdev_priv(netdev);\n\tu16 sw_pi, hw_ci, sw_ci;\n\tstruct hinic_sq *sq;\n\tu16 num_sqs, q_id;\n\n\tnum_sqs = hinic_hwdev_num_qps(nic_dev->hwdev);\n\n\tnetif_err(nic_dev, drv, netdev, \"Tx timeout\\n\");\n\n\tfor (q_id = 0; q_id < num_sqs; q_id++) {\n\t\tif (!netif_xmit_stopped(netdev_get_tx_queue(netdev, q_id)))\n\t\t\tcontinue;\n\n\t\tsq = hinic_hwdev_get_sq(nic_dev->hwdev, q_id);\n\t\tsw_pi = atomic_read(&sq->wq->prod_idx) & sq->wq->mask;\n\t\thw_ci = be16_to_cpu(*(u16 *)(sq->hw_ci_addr)) & sq->wq->mask;\n\t\tsw_ci = atomic_read(&sq->wq->cons_idx) & sq->wq->mask;\n\t\tnetif_err(nic_dev, drv, netdev, \"Txq%d: sw_pi: %d, hw_ci: %d, sw_ci: %d, napi->state: 0x%lx\\n\",\n\t\t\t  q_id, sw_pi, hw_ci, sw_ci,\n\t\t\t  nic_dev->txqs[q_id].napi.state);\n\t}\n}\n\nstatic void hinic_get_stats64(struct net_device *netdev,\n\t\t\t      struct rtnl_link_stats64 *stats)\n{\n\tstruct hinic_dev *nic_dev = netdev_priv(netdev);\n\tstruct hinic_rxq_stats nic_rx_stats = {};\n\tstruct hinic_txq_stats nic_tx_stats = {};\n\n\tif (nic_dev->flags & HINIC_INTF_UP)\n\t\tgather_nic_stats(nic_dev, &nic_rx_stats, &nic_tx_stats);\n\n\tstats->rx_bytes   = nic_rx_stats.bytes;\n\tstats->rx_packets = nic_rx_stats.pkts;\n\tstats->rx_errors  = nic_rx_stats.errors;\n\n\tstats->tx_bytes   = nic_tx_stats.bytes;\n\tstats->tx_packets = nic_tx_stats.pkts;\n\tstats->tx_errors  = nic_tx_stats.tx_dropped;\n}\n\nstatic int hinic_set_features(struct net_device *netdev,\n\t\t\t      netdev_features_t features)\n{\n\tstruct hinic_dev *nic_dev = netdev_priv(netdev);\n\n\treturn set_features(nic_dev, nic_dev->netdev->features,\n\t\t\t    features, false);\n}\n\nstatic netdev_features_t hinic_fix_features(struct net_device *netdev,\n\t\t\t\t\t    netdev_features_t features)\n{\n\tstruct hinic_dev *nic_dev = netdev_priv(netdev);\n\n\t \n\tif (!(features & NETIF_F_RXCSUM)) {\n\t\tnetif_info(nic_dev, drv, netdev, \"disabling LRO as RXCSUM is off\\n\");\n\t\tfeatures &= ~NETIF_F_LRO;\n\t}\n\n\treturn features;\n}\n\nstatic const struct net_device_ops hinic_netdev_ops = {\n\t.ndo_open = hinic_open,\n\t.ndo_stop = hinic_close,\n\t.ndo_change_mtu = hinic_change_mtu,\n\t.ndo_set_mac_address = hinic_set_mac_addr,\n\t.ndo_validate_addr = eth_validate_addr,\n\t.ndo_vlan_rx_add_vid = hinic_vlan_rx_add_vid,\n\t.ndo_vlan_rx_kill_vid = hinic_vlan_rx_kill_vid,\n\t.ndo_set_rx_mode = hinic_set_rx_mode,\n\t.ndo_start_xmit = hinic_xmit_frame,\n\t.ndo_tx_timeout = hinic_tx_timeout,\n\t.ndo_get_stats64 = hinic_get_stats64,\n\t.ndo_fix_features = hinic_fix_features,\n\t.ndo_set_features = hinic_set_features,\n\t.ndo_set_vf_mac\t= hinic_ndo_set_vf_mac,\n\t.ndo_set_vf_vlan = hinic_ndo_set_vf_vlan,\n\t.ndo_get_vf_config = hinic_ndo_get_vf_config,\n\t.ndo_set_vf_trust = hinic_ndo_set_vf_trust,\n\t.ndo_set_vf_rate = hinic_ndo_set_vf_bw,\n\t.ndo_set_vf_spoofchk = hinic_ndo_set_vf_spoofchk,\n\t.ndo_set_vf_link_state = hinic_ndo_set_vf_link_state,\n};\n\nstatic const struct net_device_ops hinicvf_netdev_ops = {\n\t.ndo_open = hinic_open,\n\t.ndo_stop = hinic_close,\n\t.ndo_change_mtu = hinic_change_mtu,\n\t.ndo_set_mac_address = hinic_set_mac_addr,\n\t.ndo_validate_addr = eth_validate_addr,\n\t.ndo_vlan_rx_add_vid = hinic_vlan_rx_add_vid,\n\t.ndo_vlan_rx_kill_vid = hinic_vlan_rx_kill_vid,\n\t.ndo_set_rx_mode = hinic_set_rx_mode,\n\t.ndo_start_xmit = hinic_xmit_frame,\n\t.ndo_tx_timeout = hinic_tx_timeout,\n\t.ndo_get_stats64 = hinic_get_stats64,\n\t.ndo_fix_features = hinic_fix_features,\n\t.ndo_set_features = hinic_set_features,\n};\n\nstatic void netdev_features_init(struct net_device *netdev)\n{\n\tnetdev->hw_features = NETIF_F_SG | NETIF_F_HIGHDMA | NETIF_F_IP_CSUM |\n\t\t\t      NETIF_F_IPV6_CSUM | NETIF_F_TSO | NETIF_F_TSO6 |\n\t\t\t      NETIF_F_RXCSUM | NETIF_F_LRO |\n\t\t\t      NETIF_F_HW_VLAN_CTAG_TX | NETIF_F_HW_VLAN_CTAG_RX |\n\t\t\t      NETIF_F_GSO_UDP_TUNNEL | NETIF_F_GSO_UDP_TUNNEL_CSUM;\n\n\tnetdev->vlan_features = netdev->hw_features;\n\n\tnetdev->features = netdev->hw_features | NETIF_F_HW_VLAN_CTAG_FILTER;\n\n\tnetdev->hw_enc_features = NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM | NETIF_F_SCTP_CRC |\n\t\t\t\t  NETIF_F_SG | NETIF_F_TSO | NETIF_F_TSO6 | NETIF_F_TSO_ECN |\n\t\t\t\t  NETIF_F_GSO_UDP_TUNNEL_CSUM | NETIF_F_GSO_UDP_TUNNEL;\n}\n\nstatic void hinic_refresh_nic_cfg(struct hinic_dev *nic_dev)\n{\n\tstruct hinic_nic_cfg *nic_cfg = &nic_dev->hwdev->func_to_io.nic_cfg;\n\tstruct hinic_pause_config pause_info = {0};\n\tstruct hinic_port_cap port_cap = {0};\n\n\tif (hinic_port_get_cap(nic_dev, &port_cap))\n\t\treturn;\n\n\tmutex_lock(&nic_cfg->cfg_mutex);\n\tif (nic_cfg->pause_set || !port_cap.autoneg_state) {\n\t\tnic_cfg->auto_neg = port_cap.autoneg_state;\n\t\tpause_info.auto_neg = nic_cfg->auto_neg;\n\t\tpause_info.rx_pause = nic_cfg->rx_pause;\n\t\tpause_info.tx_pause = nic_cfg->tx_pause;\n\t\thinic_set_hw_pause_info(nic_dev->hwdev, &pause_info);\n\t}\n\tmutex_unlock(&nic_cfg->cfg_mutex);\n}\n\n \nstatic void link_status_event_handler(void *handle, void *buf_in, u16 in_size,\n\t\t\t\t      void *buf_out, u16 *out_size)\n{\n\tstruct hinic_port_link_status *link_status, *ret_link_status;\n\tstruct hinic_dev *nic_dev = handle;\n\n\tlink_status = buf_in;\n\n\tif (link_status->link == HINIC_LINK_STATE_UP) {\n\t\tdown(&nic_dev->mgmt_lock);\n\n\t\tnic_dev->flags |= HINIC_LINK_UP;\n\t\tnic_dev->cable_unplugged = false;\n\t\tnic_dev->module_unrecognized = false;\n\n\t\tif ((nic_dev->flags & (HINIC_LINK_UP | HINIC_INTF_UP)) ==\n\t\t    (HINIC_LINK_UP | HINIC_INTF_UP)) {\n\t\t\tnetif_carrier_on(nic_dev->netdev);\n\t\t\tnetif_tx_wake_all_queues(nic_dev->netdev);\n\t\t}\n\n\t\tup(&nic_dev->mgmt_lock);\n\n\t\tif (!HINIC_IS_VF(nic_dev->hwdev->hwif))\n\t\t\thinic_refresh_nic_cfg(nic_dev);\n\n\t\tnetif_info(nic_dev, drv, nic_dev->netdev, \"HINIC_Link is UP\\n\");\n\t} else {\n\t\tdown(&nic_dev->mgmt_lock);\n\n\t\tnic_dev->flags &= ~HINIC_LINK_UP;\n\n\t\tnetif_carrier_off(nic_dev->netdev);\n\t\tnetif_tx_disable(nic_dev->netdev);\n\n\t\tup(&nic_dev->mgmt_lock);\n\n\t\tnetif_info(nic_dev, drv, nic_dev->netdev, \"HINIC_Link is DOWN\\n\");\n\t}\n\n\tif (!HINIC_IS_VF(nic_dev->hwdev->hwif))\n\t\thinic_notify_all_vfs_link_changed(nic_dev->hwdev,\n\t\t\t\t\t\t  link_status->link);\n\n\tret_link_status = buf_out;\n\tret_link_status->status = 0;\n\n\t*out_size = sizeof(*ret_link_status);\n}\n\nstatic void cable_plug_event(void *handle,\n\t\t\t     void *buf_in, u16 in_size,\n\t\t\t     void *buf_out, u16 *out_size)\n{\n\tstruct hinic_cable_plug_event *plug_event = buf_in;\n\tstruct hinic_dev *nic_dev = handle;\n\n\tnic_dev->cable_unplugged = plug_event->plugged ? false : true;\n\n\t*out_size = sizeof(*plug_event);\n\tplug_event = buf_out;\n\tplug_event->status = 0;\n}\n\nstatic void link_err_event(void *handle,\n\t\t\t   void *buf_in, u16 in_size,\n\t\t\t   void *buf_out, u16 *out_size)\n{\n\tstruct hinic_link_err_event *link_err = buf_in;\n\tstruct hinic_dev *nic_dev = handle;\n\n\tif (link_err->err_type >= LINK_ERR_NUM)\n\t\tnetif_info(nic_dev, link, nic_dev->netdev,\n\t\t\t   \"Link failed, Unknown error type: 0x%x\\n\",\n\t\t\t   link_err->err_type);\n\telse\n\t\tnic_dev->module_unrecognized = true;\n\n\t*out_size = sizeof(*link_err);\n\tlink_err = buf_out;\n\tlink_err->status = 0;\n}\n\nstatic int set_features(struct hinic_dev *nic_dev,\n\t\t\tnetdev_features_t pre_features,\n\t\t\tnetdev_features_t features, bool force_change)\n{\n\tnetdev_features_t changed = force_change ? ~0 : pre_features ^ features;\n\tu32 csum_en = HINIC_RX_CSUM_OFFLOAD_EN;\n\tnetdev_features_t failed_features = 0;\n\tint ret = 0;\n\tint err = 0;\n\n\tif (changed & NETIF_F_TSO) {\n\t\tret = hinic_port_set_tso(nic_dev, (features & NETIF_F_TSO) ?\n\t\t\t\t\t HINIC_TSO_ENABLE : HINIC_TSO_DISABLE);\n\t\tif (ret) {\n\t\t\terr = ret;\n\t\t\tfailed_features |= NETIF_F_TSO;\n\t\t}\n\t}\n\n\tif (changed & NETIF_F_RXCSUM) {\n\t\tret = hinic_set_rx_csum_offload(nic_dev, csum_en);\n\t\tif (ret) {\n\t\t\terr = ret;\n\t\t\tfailed_features |= NETIF_F_RXCSUM;\n\t\t}\n\t}\n\n\tif (changed & NETIF_F_LRO) {\n\t\tret = hinic_set_rx_lro_state(nic_dev,\n\t\t\t\t\t     !!(features & NETIF_F_LRO),\n\t\t\t\t\t     HINIC_LRO_RX_TIMER_DEFAULT,\n\t\t\t\t\t     HINIC_LRO_MAX_WQE_NUM_DEFAULT);\n\t\tif (ret) {\n\t\t\terr = ret;\n\t\t\tfailed_features |= NETIF_F_LRO;\n\t\t}\n\t}\n\n\tif (changed & NETIF_F_HW_VLAN_CTAG_RX) {\n\t\tret = hinic_set_rx_vlan_offload(nic_dev,\n\t\t\t\t\t\t!!(features &\n\t\t\t\t\t\t   NETIF_F_HW_VLAN_CTAG_RX));\n\t\tif (ret) {\n\t\t\terr = ret;\n\t\t\tfailed_features |= NETIF_F_HW_VLAN_CTAG_RX;\n\t\t}\n\t}\n\n\tif (changed & NETIF_F_HW_VLAN_CTAG_FILTER) {\n\t\tret = hinic_set_vlan_fliter(nic_dev,\n\t\t\t\t\t    !!(features &\n\t\t\t\t\t       NETIF_F_HW_VLAN_CTAG_FILTER));\n\t\tif (ret) {\n\t\t\terr = ret;\n\t\t\tfailed_features |= NETIF_F_HW_VLAN_CTAG_FILTER;\n\t\t}\n\t}\n\n\tif (err) {\n\t\tnic_dev->netdev->features = features ^ failed_features;\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int hinic_init_intr_coalesce(struct hinic_dev *nic_dev)\n{\n\tu64 size;\n\tu16 i;\n\n\tsize = sizeof(struct hinic_intr_coal_info) * nic_dev->max_qps;\n\tnic_dev->rx_intr_coalesce = kzalloc(size, GFP_KERNEL);\n\tif (!nic_dev->rx_intr_coalesce)\n\t\treturn -ENOMEM;\n\tnic_dev->tx_intr_coalesce = kzalloc(size, GFP_KERNEL);\n\tif (!nic_dev->tx_intr_coalesce) {\n\t\tkfree(nic_dev->rx_intr_coalesce);\n\t\treturn -ENOMEM;\n\t}\n\n\tfor (i = 0; i < nic_dev->max_qps; i++) {\n\t\tnic_dev->rx_intr_coalesce[i].pending_limt =\n\t\t\tHINIC_DEAULT_TXRX_MSIX_PENDING_LIMIT;\n\t\tnic_dev->rx_intr_coalesce[i].coalesce_timer_cfg =\n\t\t\tHINIC_DEAULT_TXRX_MSIX_COALESC_TIMER_CFG;\n\t\tnic_dev->rx_intr_coalesce[i].resend_timer_cfg =\n\t\t\tHINIC_DEAULT_TXRX_MSIX_RESEND_TIMER_CFG;\n\t\tnic_dev->tx_intr_coalesce[i].pending_limt =\n\t\t\tHINIC_DEAULT_TXRX_MSIX_PENDING_LIMIT;\n\t\tnic_dev->tx_intr_coalesce[i].coalesce_timer_cfg =\n\t\t\tHINIC_DEAULT_TXRX_MSIX_COALESC_TIMER_CFG;\n\t\tnic_dev->tx_intr_coalesce[i].resend_timer_cfg =\n\t\t\tHINIC_DEAULT_TXRX_MSIX_RESEND_TIMER_CFG;\n\t}\n\n\treturn 0;\n}\n\nstatic void hinic_free_intr_coalesce(struct hinic_dev *nic_dev)\n{\n\tkfree(nic_dev->tx_intr_coalesce);\n\tkfree(nic_dev->rx_intr_coalesce);\n}\n\n \nstatic int nic_dev_init(struct pci_dev *pdev)\n{\n\tstruct hinic_rx_mode_work *rx_mode_work;\n\tstruct hinic_dev *nic_dev;\n\tstruct net_device *netdev;\n\tstruct hinic_hwdev *hwdev;\n\tstruct devlink *devlink;\n\tu8 addr[ETH_ALEN];\n\tint err, num_qps;\n\n\tdevlink = hinic_devlink_alloc(&pdev->dev);\n\tif (!devlink) {\n\t\tdev_err(&pdev->dev, \"Hinic devlink alloc failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\thwdev = hinic_init_hwdev(pdev, devlink);\n\tif (IS_ERR(hwdev)) {\n\t\tdev_err(&pdev->dev, \"Failed to initialize HW device\\n\");\n\t\thinic_devlink_free(devlink);\n\t\treturn PTR_ERR(hwdev);\n\t}\n\n\tnum_qps = hinic_hwdev_num_qps(hwdev);\n\tif (num_qps <= 0) {\n\t\tdev_err(&pdev->dev, \"Invalid number of QPS\\n\");\n\t\terr = -EINVAL;\n\t\tgoto err_num_qps;\n\t}\n\n\tnetdev = alloc_etherdev_mq(sizeof(*nic_dev), num_qps);\n\tif (!netdev) {\n\t\tdev_err(&pdev->dev, \"Failed to allocate Ethernet device\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto err_alloc_etherdev;\n\t}\n\n\tif (!HINIC_IS_VF(hwdev->hwif))\n\t\tnetdev->netdev_ops = &hinic_netdev_ops;\n\telse\n\t\tnetdev->netdev_ops = &hinicvf_netdev_ops;\n\n\tnetdev->max_mtu = HINIC_MAX_MTU_SIZE;\n\tnetdev->min_mtu = HINIC_MIN_MTU_SIZE;\n\n\tnic_dev = netdev_priv(netdev);\n\tnic_dev->netdev = netdev;\n\tnic_dev->hwdev  = hwdev;\n\tnic_dev->msg_enable = MSG_ENABLE_DEFAULT;\n\tnic_dev->flags = 0;\n\tnic_dev->txqs = NULL;\n\tnic_dev->rxqs = NULL;\n\tnic_dev->tx_weight = tx_weight;\n\tnic_dev->rx_weight = rx_weight;\n\tnic_dev->sq_depth = HINIC_SQ_DEPTH;\n\tnic_dev->rq_depth = HINIC_RQ_DEPTH;\n\tnic_dev->sriov_info.hwdev = hwdev;\n\tnic_dev->sriov_info.pdev = pdev;\n\tnic_dev->max_qps = num_qps;\n\tnic_dev->devlink = devlink;\n\n\thinic_set_ethtool_ops(netdev);\n\n\tsema_init(&nic_dev->mgmt_lock, 1);\n\n\tnic_dev->vlan_bitmap = devm_bitmap_zalloc(&pdev->dev, VLAN_N_VID,\n\t\t\t\t\t\t  GFP_KERNEL);\n\tif (!nic_dev->vlan_bitmap) {\n\t\terr = -ENOMEM;\n\t\tgoto err_vlan_bitmap;\n\t}\n\n\tnic_dev->workq = create_singlethread_workqueue(HINIC_WQ_NAME);\n\tif (!nic_dev->workq) {\n\t\terr = -ENOMEM;\n\t\tgoto err_workq;\n\t}\n\n\tpci_set_drvdata(pdev, netdev);\n\n\terr = hinic_port_get_mac(nic_dev, addr);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Failed to get mac address\\n\");\n\t\tgoto err_get_mac;\n\t}\n\teth_hw_addr_set(netdev, addr);\n\n\tif (!is_valid_ether_addr(netdev->dev_addr)) {\n\t\tif (!HINIC_IS_VF(nic_dev->hwdev->hwif)) {\n\t\t\tdev_err(&pdev->dev, \"Invalid MAC address\\n\");\n\t\t\terr = -EIO;\n\t\t\tgoto err_add_mac;\n\t\t}\n\n\t\tdev_info(&pdev->dev, \"Invalid MAC address %pM, using random\\n\",\n\t\t\t netdev->dev_addr);\n\t\teth_hw_addr_random(netdev);\n\t}\n\n\terr = hinic_port_add_mac(nic_dev, netdev->dev_addr, 0);\n\tif (err && err != HINIC_PF_SET_VF_ALREADY) {\n\t\tdev_err(&pdev->dev, \"Failed to add mac\\n\");\n\t\tgoto err_add_mac;\n\t}\n\n\terr = hinic_port_set_mtu(nic_dev, netdev->mtu);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Failed to set mtu\\n\");\n\t\tgoto err_set_mtu;\n\t}\n\n\trx_mode_work = &nic_dev->rx_mode_work;\n\tINIT_WORK(&rx_mode_work->work, set_rx_mode);\n\n\tnetdev_features_init(netdev);\n\n\tnetif_carrier_off(netdev);\n\n\thinic_hwdev_cb_register(nic_dev->hwdev, HINIC_MGMT_MSG_CMD_LINK_STATUS,\n\t\t\t\tnic_dev, link_status_event_handler);\n\thinic_hwdev_cb_register(nic_dev->hwdev,\n\t\t\t\tHINIC_MGMT_MSG_CMD_CABLE_PLUG_EVENT,\n\t\t\t\tnic_dev, cable_plug_event);\n\thinic_hwdev_cb_register(nic_dev->hwdev,\n\t\t\t\tHINIC_MGMT_MSG_CMD_LINK_ERR_EVENT,\n\t\t\t\tnic_dev, link_err_event);\n\n\terr = set_features(nic_dev, 0, nic_dev->netdev->features, true);\n\tif (err)\n\t\tgoto err_set_features;\n\n\t \n\terr = hinic_dcb_set_pfc(nic_dev->hwdev, 0, 0);\n\tif (err)\n\t\tgoto err_set_pfc;\n\n\tSET_NETDEV_DEV(netdev, &pdev->dev);\n\n\terr = hinic_init_intr_coalesce(nic_dev);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Failed to init_intr_coalesce\\n\");\n\t\tgoto err_init_intr;\n\t}\n\n\thinic_dbg_init(nic_dev);\n\n\thinic_func_tbl_dbgfs_init(nic_dev);\n\n\terr = hinic_func_table_debug_add(nic_dev);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Failed to add func_table debug\\n\");\n\t\tgoto err_add_func_table_dbg;\n\t}\n\n\terr = register_netdev(netdev);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Failed to register netdev\\n\");\n\t\tgoto err_reg_netdev;\n\t}\n\n\treturn 0;\n\nerr_reg_netdev:\n\thinic_func_table_debug_rem(nic_dev);\nerr_add_func_table_dbg:\n\thinic_func_tbl_dbgfs_uninit(nic_dev);\n\thinic_dbg_uninit(nic_dev);\n\thinic_free_intr_coalesce(nic_dev);\nerr_init_intr:\nerr_set_pfc:\nerr_set_features:\n\thinic_hwdev_cb_unregister(nic_dev->hwdev,\n\t\t\t\t  HINIC_MGMT_MSG_CMD_LINK_ERR_EVENT);\n\thinic_hwdev_cb_unregister(nic_dev->hwdev,\n\t\t\t\t  HINIC_MGMT_MSG_CMD_CABLE_PLUG_EVENT);\n\thinic_hwdev_cb_unregister(nic_dev->hwdev,\n\t\t\t\t  HINIC_MGMT_MSG_CMD_LINK_STATUS);\n\tcancel_work_sync(&rx_mode_work->work);\n\nerr_set_mtu:\n\thinic_port_del_mac(nic_dev, netdev->dev_addr, 0);\nerr_add_mac:\nerr_get_mac:\n\tpci_set_drvdata(pdev, NULL);\n\tdestroy_workqueue(nic_dev->workq);\nerr_workq:\nerr_vlan_bitmap:\n\tfree_netdev(netdev);\n\nerr_alloc_etherdev:\nerr_num_qps:\n\thinic_free_hwdev(hwdev);\n\thinic_devlink_free(devlink);\n\treturn err;\n}\n\nstatic int hinic_probe(struct pci_dev *pdev,\n\t\t       const struct pci_device_id *id)\n{\n\tint err = pci_enable_device(pdev);\n\n\tif (err)\n\t\treturn dev_err_probe(&pdev->dev, err, \"Failed to enable PCI device\\n\");\n\n\terr = pci_request_regions(pdev, HINIC_DRV_NAME);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Failed to request PCI regions\\n\");\n\t\tgoto err_pci_regions;\n\t}\n\n\tpci_set_master(pdev);\n\n\terr = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(64));\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Failed to set DMA mask\\n\");\n\t\tgoto err_dma_mask;\n\t}\n\n\terr = nic_dev_init(pdev);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Failed to initialize NIC device\\n\");\n\t\tgoto err_nic_dev_init;\n\t}\n\n\tdev_info(&pdev->dev, \"HiNIC driver - probed\\n\");\n\treturn 0;\n\nerr_nic_dev_init:\nerr_dma_mask:\n\tpci_release_regions(pdev);\n\nerr_pci_regions:\n\tpci_disable_device(pdev);\n\treturn err;\n}\n\nstatic void wait_sriov_cfg_complete(struct hinic_dev *nic_dev)\n{\n\tstruct hinic_sriov_info *sriov_info = &nic_dev->sriov_info;\n\tu32 loop_cnt = 0;\n\n\tset_bit(HINIC_FUNC_REMOVE, &sriov_info->state);\n\tusleep_range(9900, 10000);\n\n\twhile (loop_cnt < HINIC_WAIT_SRIOV_CFG_TIMEOUT) {\n\t\tif (!test_bit(HINIC_SRIOV_ENABLE, &sriov_info->state) &&\n\t\t    !test_bit(HINIC_SRIOV_DISABLE, &sriov_info->state))\n\t\t\treturn;\n\n\t\tusleep_range(9900, 10000);\n\t\tloop_cnt++;\n\t}\n}\n\nstatic void hinic_remove(struct pci_dev *pdev)\n{\n\tstruct net_device *netdev = pci_get_drvdata(pdev);\n\tstruct hinic_dev *nic_dev = netdev_priv(netdev);\n\tstruct devlink *devlink = nic_dev->devlink;\n\tstruct hinic_rx_mode_work *rx_mode_work;\n\n\tif (!HINIC_IS_VF(nic_dev->hwdev->hwif)) {\n\t\twait_sriov_cfg_complete(nic_dev);\n\t\thinic_pci_sriov_disable(pdev);\n\t}\n\n\tunregister_netdev(netdev);\n\n\thinic_func_table_debug_rem(nic_dev);\n\n\thinic_func_tbl_dbgfs_uninit(nic_dev);\n\n\thinic_dbg_uninit(nic_dev);\n\n\thinic_free_intr_coalesce(nic_dev);\n\n\thinic_port_del_mac(nic_dev, netdev->dev_addr, 0);\n\n\thinic_hwdev_cb_unregister(nic_dev->hwdev,\n\t\t\t\t  HINIC_MGMT_MSG_CMD_LINK_ERR_EVENT);\n\thinic_hwdev_cb_unregister(nic_dev->hwdev,\n\t\t\t\t  HINIC_MGMT_MSG_CMD_CABLE_PLUG_EVENT);\n\thinic_hwdev_cb_unregister(nic_dev->hwdev,\n\t\t\t\t  HINIC_MGMT_MSG_CMD_LINK_STATUS);\n\n\trx_mode_work = &nic_dev->rx_mode_work;\n\tcancel_work_sync(&rx_mode_work->work);\n\n\tpci_set_drvdata(pdev, NULL);\n\n\tdestroy_workqueue(nic_dev->workq);\n\n\thinic_free_hwdev(nic_dev->hwdev);\n\n\tfree_netdev(netdev);\n\n\thinic_devlink_free(devlink);\n\n\tpci_release_regions(pdev);\n\tpci_disable_device(pdev);\n\n\tdev_info(&pdev->dev, \"HiNIC driver - removed\\n\");\n}\n\nstatic void hinic_shutdown(struct pci_dev *pdev)\n{\n\tpci_disable_device(pdev);\n}\n\nstatic const struct pci_device_id hinic_pci_table[] = {\n\t{ PCI_VDEVICE(HUAWEI, HINIC_DEV_ID_QUAD_PORT_25GE), 0},\n\t{ PCI_VDEVICE(HUAWEI, HINIC_DEV_ID_DUAL_PORT_100GE), 0},\n\t{ PCI_VDEVICE(HUAWEI, HINIC_DEV_ID_DUAL_PORT_100GE_MEZZ), 0},\n\t{ PCI_VDEVICE(HUAWEI, HINIC_DEV_ID_QUAD_PORT_25GE_MEZZ), 0},\n\t{ PCI_VDEVICE(HUAWEI, HINIC_DEV_ID_VF), 0},\n\t{ 0, 0}\n};\nMODULE_DEVICE_TABLE(pci, hinic_pci_table);\n\nstatic struct pci_driver hinic_driver = {\n\t.name           = HINIC_DRV_NAME,\n\t.id_table       = hinic_pci_table,\n\t.probe          = hinic_probe,\n\t.remove         = hinic_remove,\n\t.shutdown       = hinic_shutdown,\n\t.sriov_configure = hinic_pci_sriov_configure,\n};\n\nstatic int __init hinic_module_init(void)\n{\n\tint ret;\n\n\thinic_dbg_register_debugfs(HINIC_DRV_NAME);\n\n\tret = pci_register_driver(&hinic_driver);\n\tif (ret)\n\t\thinic_dbg_unregister_debugfs();\n\n\treturn ret;\n}\n\nstatic void __exit hinic_module_exit(void)\n{\n\tpci_unregister_driver(&hinic_driver);\n\thinic_dbg_unregister_debugfs();\n}\n\nmodule_init(hinic_module_init);\nmodule_exit(hinic_module_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}