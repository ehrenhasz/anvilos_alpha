{
  "module_name": "hinic_rx.c",
  "hash_id": "37253b4744ab1c415eca41c8162423cccda13ac5c1db9fd4a9605d19d1ae3efd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/huawei/hinic/hinic_rx.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/errno.h>\n#include <linux/pci.h>\n#include <linux/device.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/u64_stats_sync.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/skbuff.h>\n#include <linux/dma-mapping.h>\n#include <linux/prefetch.h>\n#include <linux/cpumask.h>\n#include <linux/if_vlan.h>\n#include <asm/barrier.h>\n\n#include \"hinic_common.h\"\n#include \"hinic_hw_if.h\"\n#include \"hinic_hw_wqe.h\"\n#include \"hinic_hw_wq.h\"\n#include \"hinic_hw_qp.h\"\n#include \"hinic_hw_dev.h\"\n#include \"hinic_rx.h\"\n#include \"hinic_dev.h\"\n\n#define RX_IRQ_NO_PENDING               0\n#define RX_IRQ_NO_COALESC               0\n#define RX_IRQ_NO_LLI_TIMER             0\n#define RX_IRQ_NO_CREDIT                0\n#define RX_IRQ_NO_RESEND_TIMER          0\n#define HINIC_RX_BUFFER_WRITE           16\n\n#define HINIC_RX_IPV6_PKT\t\t7\n#define LRO_PKT_HDR_LEN_IPV4\t\t66\n#define LRO_PKT_HDR_LEN_IPV6\t\t86\n#define LRO_REPLENISH_THLD\t\t256\n\n#define LRO_PKT_HDR_LEN(cqe)\t\t\\\n\t(HINIC_GET_RX_PKT_TYPE(be32_to_cpu((cqe)->offload_type)) == \\\n\t HINIC_RX_IPV6_PKT ? LRO_PKT_HDR_LEN_IPV6 : LRO_PKT_HDR_LEN_IPV4)\n\n \nstatic void hinic_rxq_clean_stats(struct hinic_rxq *rxq)\n{\n\tstruct hinic_rxq_stats *rxq_stats = &rxq->rxq_stats;\n\n\tu64_stats_update_begin(&rxq_stats->syncp);\n\trxq_stats->pkts  = 0;\n\trxq_stats->bytes = 0;\n\trxq_stats->errors = 0;\n\trxq_stats->csum_errors = 0;\n\trxq_stats->other_errors = 0;\n\tu64_stats_update_end(&rxq_stats->syncp);\n}\n\n \nvoid hinic_rxq_get_stats(struct hinic_rxq *rxq, struct hinic_rxq_stats *stats)\n{\n\tstruct hinic_rxq_stats *rxq_stats = &rxq->rxq_stats;\n\tunsigned int start;\n\n\tdo {\n\t\tstart = u64_stats_fetch_begin(&rxq_stats->syncp);\n\t\tstats->pkts = rxq_stats->pkts;\n\t\tstats->bytes = rxq_stats->bytes;\n\t\tstats->errors = rxq_stats->csum_errors +\n\t\t\t\trxq_stats->other_errors;\n\t\tstats->csum_errors = rxq_stats->csum_errors;\n\t\tstats->other_errors = rxq_stats->other_errors;\n\t} while (u64_stats_fetch_retry(&rxq_stats->syncp, start));\n}\n\n \nstatic void rxq_stats_init(struct hinic_rxq *rxq)\n{\n\tstruct hinic_rxq_stats *rxq_stats = &rxq->rxq_stats;\n\n\tu64_stats_init(&rxq_stats->syncp);\n\thinic_rxq_clean_stats(rxq);\n}\n\nstatic void rx_csum(struct hinic_rxq *rxq, u32 status,\n\t\t    struct sk_buff *skb)\n{\n\tstruct net_device *netdev = rxq->netdev;\n\tu32 csum_err;\n\n\tcsum_err = HINIC_RQ_CQE_STATUS_GET(status, CSUM_ERR);\n\n\tif (!(netdev->features & NETIF_F_RXCSUM))\n\t\treturn;\n\n\tif (!csum_err) {\n\t\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\t} else {\n\t\tif (!(csum_err & (HINIC_RX_CSUM_HW_CHECK_NONE |\n\t\t\tHINIC_RX_CSUM_IPSU_OTHER_ERR)))\n\t\t\trxq->rxq_stats.csum_errors++;\n\t\tskb->ip_summed = CHECKSUM_NONE;\n\t}\n}\n\n \nstatic struct sk_buff *rx_alloc_skb(struct hinic_rxq *rxq,\n\t\t\t\t    dma_addr_t *dma_addr)\n{\n\tstruct hinic_dev *nic_dev = netdev_priv(rxq->netdev);\n\tstruct hinic_hwdev *hwdev = nic_dev->hwdev;\n\tstruct hinic_hwif *hwif = hwdev->hwif;\n\tstruct pci_dev *pdev = hwif->pdev;\n\tstruct sk_buff *skb;\n\tdma_addr_t addr;\n\tint err;\n\n\tskb = netdev_alloc_skb_ip_align(rxq->netdev, rxq->rq->buf_sz);\n\tif (!skb)\n\t\treturn NULL;\n\n\taddr = dma_map_single(&pdev->dev, skb->data, rxq->rq->buf_sz,\n\t\t\t      DMA_FROM_DEVICE);\n\terr = dma_mapping_error(&pdev->dev, addr);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Failed to map Rx DMA, err = %d\\n\", err);\n\t\tgoto err_rx_map;\n\t}\n\n\t*dma_addr = addr;\n\treturn skb;\n\nerr_rx_map:\n\tdev_kfree_skb_any(skb);\n\treturn NULL;\n}\n\n \nstatic void rx_unmap_skb(struct hinic_rxq *rxq, dma_addr_t dma_addr)\n{\n\tstruct hinic_dev *nic_dev = netdev_priv(rxq->netdev);\n\tstruct hinic_hwdev *hwdev = nic_dev->hwdev;\n\tstruct hinic_hwif *hwif = hwdev->hwif;\n\tstruct pci_dev *pdev = hwif->pdev;\n\n\tdma_unmap_single(&pdev->dev, dma_addr, rxq->rq->buf_sz,\n\t\t\t DMA_FROM_DEVICE);\n}\n\n \nstatic void rx_free_skb(struct hinic_rxq *rxq, struct sk_buff *skb,\n\t\t\tdma_addr_t dma_addr)\n{\n\trx_unmap_skb(rxq, dma_addr);\n\tdev_kfree_skb_any(skb);\n}\n\n \nstatic int rx_alloc_pkts(struct hinic_rxq *rxq)\n{\n\tstruct hinic_dev *nic_dev = netdev_priv(rxq->netdev);\n\tstruct hinic_rq_wqe *rq_wqe;\n\tunsigned int free_wqebbs;\n\tstruct hinic_sge sge;\n\tdma_addr_t dma_addr;\n\tstruct sk_buff *skb;\n\tu16 prod_idx;\n\tint i;\n\n\tfree_wqebbs = hinic_get_rq_free_wqebbs(rxq->rq);\n\n\t \n\tif (free_wqebbs > nic_dev->rx_weight)\n\t\tfree_wqebbs = nic_dev->rx_weight;\n\n\tfor (i = 0; i < free_wqebbs; i++) {\n\t\tskb = rx_alloc_skb(rxq, &dma_addr);\n\t\tif (!skb)\n\t\t\tgoto skb_out;\n\n\t\thinic_set_sge(&sge, dma_addr, skb->len);\n\n\t\trq_wqe = hinic_rq_get_wqe(rxq->rq, HINIC_RQ_WQE_SIZE,\n\t\t\t\t\t  &prod_idx);\n\t\tif (!rq_wqe) {\n\t\t\trx_free_skb(rxq, skb, dma_addr);\n\t\t\tgoto skb_out;\n\t\t}\n\n\t\thinic_rq_prepare_wqe(rxq->rq, prod_idx, rq_wqe, &sge);\n\n\t\thinic_rq_write_wqe(rxq->rq, prod_idx, rq_wqe, skb);\n\t}\n\nskb_out:\n\tif (i) {\n\t\twmb();   \n\n\t\thinic_rq_update(rxq->rq, prod_idx);\n\t}\n\n\treturn i;\n}\n\n \nstatic void free_all_rx_skbs(struct hinic_rxq *rxq)\n{\n\tstruct hinic_rq *rq = rxq->rq;\n\tstruct hinic_hw_wqe *hw_wqe;\n\tstruct hinic_sge sge;\n\tu16 ci;\n\n\twhile ((hw_wqe = hinic_read_wqe(rq->wq, HINIC_RQ_WQE_SIZE, &ci))) {\n\t\tif (IS_ERR(hw_wqe))\n\t\t\tbreak;\n\n\t\thinic_rq_get_sge(rq, &hw_wqe->rq_wqe, ci, &sge);\n\n\t\thinic_put_wqe(rq->wq, HINIC_RQ_WQE_SIZE);\n\n\t\trx_free_skb(rxq, rq->saved_skb[ci], hinic_sge_to_dma(&sge));\n\t}\n}\n\n \nstatic int rx_recv_jumbo_pkt(struct hinic_rxq *rxq, struct sk_buff *head_skb,\n\t\t\t     unsigned int left_pkt_len, u16 ci)\n{\n\tstruct sk_buff *skb, *curr_skb = head_skb;\n\tstruct hinic_rq_wqe *rq_wqe;\n\tunsigned int curr_len;\n\tstruct hinic_sge sge;\n\tint num_wqes = 0;\n\n\twhile (left_pkt_len > 0) {\n\t\trq_wqe = hinic_rq_read_next_wqe(rxq->rq, HINIC_RQ_WQE_SIZE,\n\t\t\t\t\t\t&skb, &ci);\n\n\t\tnum_wqes++;\n\n\t\thinic_rq_get_sge(rxq->rq, rq_wqe, ci, &sge);\n\n\t\trx_unmap_skb(rxq, hinic_sge_to_dma(&sge));\n\n\t\tprefetch(skb->data);\n\n\t\tcurr_len = (left_pkt_len > HINIC_RX_BUF_SZ) ? HINIC_RX_BUF_SZ :\n\t\t\t    left_pkt_len;\n\n\t\tleft_pkt_len -= curr_len;\n\n\t\t__skb_put(skb, curr_len);\n\n\t\tif (curr_skb == head_skb)\n\t\t\tskb_shinfo(head_skb)->frag_list = skb;\n\t\telse\n\t\t\tcurr_skb->next = skb;\n\n\t\thead_skb->len += skb->len;\n\t\thead_skb->data_len += skb->len;\n\t\thead_skb->truesize += skb->truesize;\n\n\t\tcurr_skb = skb;\n\t}\n\n\treturn num_wqes;\n}\n\nstatic void hinic_copy_lp_data(struct hinic_dev *nic_dev,\n\t\t\t       struct sk_buff *skb)\n{\n\tstruct net_device *netdev = nic_dev->netdev;\n\tu8 *lb_buf = nic_dev->lb_test_rx_buf;\n\tint lb_len = nic_dev->lb_pkt_len;\n\tint pkt_offset, frag_len, i;\n\tvoid *frag_data = NULL;\n\n\tif (nic_dev->lb_test_rx_idx == LP_PKT_CNT) {\n\t\tnic_dev->lb_test_rx_idx = 0;\n\t\tnetif_warn(nic_dev, drv, netdev, \"Loopback test warning, receive too more test pkts\\n\");\n\t}\n\n\tif (skb->len != nic_dev->lb_pkt_len) {\n\t\tnetif_warn(nic_dev, drv, netdev, \"Wrong packet length\\n\");\n\t\tnic_dev->lb_test_rx_idx++;\n\t\treturn;\n\t}\n\n\tpkt_offset = nic_dev->lb_test_rx_idx * lb_len;\n\tfrag_len = (int)skb_headlen(skb);\n\tmemcpy(lb_buf + pkt_offset, skb->data, frag_len);\n\tpkt_offset += frag_len;\n\tfor (i = 0; i < skb_shinfo(skb)->nr_frags; i++) {\n\t\tfrag_data = skb_frag_address(&skb_shinfo(skb)->frags[i]);\n\t\tfrag_len = (int)skb_frag_size(&skb_shinfo(skb)->frags[i]);\n\t\tmemcpy((lb_buf + pkt_offset), frag_data, frag_len);\n\t\tpkt_offset += frag_len;\n\t}\n\tnic_dev->lb_test_rx_idx++;\n}\n\n \nstatic int rxq_recv(struct hinic_rxq *rxq, int budget)\n{\n\tstruct hinic_qp *qp = container_of(rxq->rq, struct hinic_qp, rq);\n\tstruct net_device *netdev = rxq->netdev;\n\tu64 pkt_len = 0, rx_bytes = 0;\n\tstruct hinic_rq *rq = rxq->rq;\n\tstruct hinic_rq_wqe *rq_wqe;\n\tstruct hinic_dev *nic_dev;\n\tunsigned int free_wqebbs;\n\tstruct hinic_rq_cqe *cqe;\n\tint num_wqes, pkts = 0;\n\tstruct hinic_sge sge;\n\tunsigned int status;\n\tstruct sk_buff *skb;\n\tu32 offload_type;\n\tu16 ci, num_lro;\n\tu16 num_wqe = 0;\n\tu32 vlan_len;\n\tu16 vid;\n\n\tnic_dev = netdev_priv(netdev);\n\n\twhile (pkts < budget) {\n\t\tnum_wqes = 0;\n\n\t\trq_wqe = hinic_rq_read_wqe(rxq->rq, HINIC_RQ_WQE_SIZE, &skb,\n\t\t\t\t\t   &ci);\n\t\tif (!rq_wqe)\n\t\t\tbreak;\n\n\t\t \n\t\tdma_rmb();\n\n\t\tcqe = rq->cqe[ci];\n\t\tstatus =  be32_to_cpu(cqe->status);\n\t\thinic_rq_get_sge(rxq->rq, rq_wqe, ci, &sge);\n\n\t\trx_unmap_skb(rxq, hinic_sge_to_dma(&sge));\n\n\t\trx_csum(rxq, status, skb);\n\n\t\tprefetch(skb->data);\n\n\t\tpkt_len = sge.len;\n\n\t\tif (pkt_len <= HINIC_RX_BUF_SZ) {\n\t\t\t__skb_put(skb, pkt_len);\n\t\t} else {\n\t\t\t__skb_put(skb, HINIC_RX_BUF_SZ);\n\t\t\tnum_wqes = rx_recv_jumbo_pkt(rxq, skb, pkt_len -\n\t\t\t\t\t\t     HINIC_RX_BUF_SZ, ci);\n\t\t}\n\n\t\thinic_rq_put_wqe(rq, ci,\n\t\t\t\t (num_wqes + 1) * HINIC_RQ_WQE_SIZE);\n\n\t\toffload_type = be32_to_cpu(cqe->offload_type);\n\t\tvlan_len = be32_to_cpu(cqe->len);\n\t\tif ((netdev->features & NETIF_F_HW_VLAN_CTAG_RX) &&\n\t\t    HINIC_GET_RX_VLAN_OFFLOAD_EN(offload_type)) {\n\t\t\tvid = HINIC_GET_RX_VLAN_TAG(vlan_len);\n\t\t\t__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q), vid);\n\t\t}\n\n\t\tif (unlikely(nic_dev->flags & HINIC_LP_TEST))\n\t\t\thinic_copy_lp_data(nic_dev, skb);\n\n\t\tskb_record_rx_queue(skb, qp->q_id);\n\t\tskb->protocol = eth_type_trans(skb, rxq->netdev);\n\n\t\tnapi_gro_receive(&rxq->napi, skb);\n\n\t\tpkts++;\n\t\trx_bytes += pkt_len;\n\n\t\tnum_lro = HINIC_GET_RX_NUM_LRO(status);\n\t\tif (num_lro) {\n\t\t\trx_bytes += ((num_lro - 1) *\n\t\t\t\t     LRO_PKT_HDR_LEN(cqe));\n\n\t\t\tnum_wqe +=\n\t\t\t(u16)(pkt_len >> rxq->rx_buff_shift) +\n\t\t\t((pkt_len & (rxq->buf_len - 1)) ? 1 : 0);\n\t\t}\n\n\t\tcqe->status = 0;\n\n\t\tif (num_wqe >= LRO_REPLENISH_THLD)\n\t\t\tbreak;\n\t}\n\n\tfree_wqebbs = hinic_get_rq_free_wqebbs(rxq->rq);\n\tif (free_wqebbs > HINIC_RX_BUFFER_WRITE)\n\t\trx_alloc_pkts(rxq);\n\n\tu64_stats_update_begin(&rxq->rxq_stats.syncp);\n\trxq->rxq_stats.pkts += pkts;\n\trxq->rxq_stats.bytes += rx_bytes;\n\tu64_stats_update_end(&rxq->rxq_stats.syncp);\n\n\treturn pkts;\n}\n\nstatic int rx_poll(struct napi_struct *napi, int budget)\n{\n\tstruct hinic_rxq *rxq = container_of(napi, struct hinic_rxq, napi);\n\tstruct hinic_dev *nic_dev = netdev_priv(rxq->netdev);\n\tstruct hinic_rq *rq = rxq->rq;\n\tint pkts;\n\n\tpkts = rxq_recv(rxq, budget);\n\tif (pkts >= budget)\n\t\treturn budget;\n\n\tnapi_complete(napi);\n\n\tif (!HINIC_IS_VF(nic_dev->hwdev->hwif))\n\t\thinic_hwdev_set_msix_state(nic_dev->hwdev,\n\t\t\t\t\t   rq->msix_entry,\n\t\t\t\t\t   HINIC_MSIX_ENABLE);\n\n\treturn pkts;\n}\n\nstatic void rx_add_napi(struct hinic_rxq *rxq)\n{\n\tstruct hinic_dev *nic_dev = netdev_priv(rxq->netdev);\n\n\tnetif_napi_add_weight(rxq->netdev, &rxq->napi, rx_poll,\n\t\t\t      nic_dev->rx_weight);\n\tnapi_enable(&rxq->napi);\n}\n\nstatic void rx_del_napi(struct hinic_rxq *rxq)\n{\n\tnapi_disable(&rxq->napi);\n\tnetif_napi_del(&rxq->napi);\n}\n\nstatic irqreturn_t rx_irq(int irq, void *data)\n{\n\tstruct hinic_rxq *rxq = (struct hinic_rxq *)data;\n\tstruct hinic_rq *rq = rxq->rq;\n\tstruct hinic_dev *nic_dev;\n\n\t \n\tnic_dev = netdev_priv(rxq->netdev);\n\tif (!HINIC_IS_VF(nic_dev->hwdev->hwif))\n\t\thinic_hwdev_set_msix_state(nic_dev->hwdev,\n\t\t\t\t\t   rq->msix_entry,\n\t\t\t\t\t   HINIC_MSIX_DISABLE);\n\n\tnic_dev = netdev_priv(rxq->netdev);\n\thinic_hwdev_msix_cnt_set(nic_dev->hwdev, rq->msix_entry);\n\n\tnapi_schedule(&rxq->napi);\n\treturn IRQ_HANDLED;\n}\n\nstatic int rx_request_irq(struct hinic_rxq *rxq)\n{\n\tstruct hinic_dev *nic_dev = netdev_priv(rxq->netdev);\n\tstruct hinic_msix_config interrupt_info = {0};\n\tstruct hinic_intr_coal_info *intr_coal = NULL;\n\tstruct hinic_hwdev *hwdev = nic_dev->hwdev;\n\tstruct hinic_rq *rq = rxq->rq;\n\tstruct hinic_qp *qp;\n\tint err;\n\n\tqp = container_of(rq, struct hinic_qp, rq);\n\n\trx_add_napi(rxq);\n\n\thinic_hwdev_msix_set(hwdev, rq->msix_entry,\n\t\t\t     RX_IRQ_NO_PENDING, RX_IRQ_NO_COALESC,\n\t\t\t     RX_IRQ_NO_LLI_TIMER, RX_IRQ_NO_CREDIT,\n\t\t\t     RX_IRQ_NO_RESEND_TIMER);\n\n\tintr_coal = &nic_dev->rx_intr_coalesce[qp->q_id];\n\tinterrupt_info.msix_index = rq->msix_entry;\n\tinterrupt_info.coalesce_timer_cnt = intr_coal->coalesce_timer_cfg;\n\tinterrupt_info.pending_cnt = intr_coal->pending_limt;\n\tinterrupt_info.resend_timer_cnt = intr_coal->resend_timer_cfg;\n\n\terr = hinic_set_interrupt_cfg(hwdev, &interrupt_info);\n\tif (err) {\n\t\tnetif_err(nic_dev, drv, rxq->netdev,\n\t\t\t  \"Failed to set RX interrupt coalescing attribute\\n\");\n\t\tgoto err_req_irq;\n\t}\n\n\terr = request_irq(rq->irq, rx_irq, 0, rxq->irq_name, rxq);\n\tif (err)\n\t\tgoto err_req_irq;\n\n\tcpumask_set_cpu(qp->q_id % num_online_cpus(), &rq->affinity_mask);\n\terr = irq_set_affinity_and_hint(rq->irq, &rq->affinity_mask);\n\tif (err)\n\t\tgoto err_irq_affinity;\n\n\treturn 0;\n\nerr_irq_affinity:\n\tfree_irq(rq->irq, rxq);\nerr_req_irq:\n\trx_del_napi(rxq);\n\treturn err;\n}\n\nstatic void rx_free_irq(struct hinic_rxq *rxq)\n{\n\tstruct hinic_rq *rq = rxq->rq;\n\n\tirq_update_affinity_hint(rq->irq, NULL);\n\tfree_irq(rq->irq, rxq);\n\trx_del_napi(rxq);\n}\n\n \nint hinic_init_rxq(struct hinic_rxq *rxq, struct hinic_rq *rq,\n\t\t   struct net_device *netdev)\n{\n\tstruct hinic_qp *qp = container_of(rq, struct hinic_qp, rq);\n\tint err, pkts;\n\n\trxq->netdev = netdev;\n\trxq->rq = rq;\n\trxq->buf_len = HINIC_RX_BUF_SZ;\n\trxq->rx_buff_shift = ilog2(HINIC_RX_BUF_SZ);\n\n\trxq_stats_init(rxq);\n\n\trxq->irq_name = devm_kasprintf(&netdev->dev, GFP_KERNEL,\n\t\t\t\t       \"%s_rxq%d\", netdev->name, qp->q_id);\n\tif (!rxq->irq_name)\n\t\treturn -ENOMEM;\n\n\tpkts = rx_alloc_pkts(rxq);\n\tif (!pkts) {\n\t\terr = -ENOMEM;\n\t\tgoto err_rx_pkts;\n\t}\n\n\terr = rx_request_irq(rxq);\n\tif (err) {\n\t\tnetdev_err(netdev, \"Failed to request Rx irq\\n\");\n\t\tgoto err_req_rx_irq;\n\t}\n\n\treturn 0;\n\nerr_req_rx_irq:\nerr_rx_pkts:\n\tfree_all_rx_skbs(rxq);\n\tdevm_kfree(&netdev->dev, rxq->irq_name);\n\treturn err;\n}\n\n \nvoid hinic_clean_rxq(struct hinic_rxq *rxq)\n{\n\tstruct net_device *netdev = rxq->netdev;\n\n\trx_free_irq(rxq);\n\n\tfree_all_rx_skbs(rxq);\n\tdevm_kfree(&netdev->dev, rxq->irq_name);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}