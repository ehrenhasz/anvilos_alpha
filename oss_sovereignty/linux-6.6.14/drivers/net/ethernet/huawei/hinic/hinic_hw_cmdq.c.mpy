{
  "module_name": "hinic_hw_cmdq.c",
  "hash_id": "79189d6ba409a854da646c90ee57d72404ae9f1ddbe3f6f7ada8d6b1c6c515e7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/huawei/hinic/hinic_hw_cmdq.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/errno.h>\n#include <linux/pci.h>\n#include <linux/device.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/sizes.h>\n#include <linux/atomic.h>\n#include <linux/log2.h>\n#include <linux/io.h>\n#include <linux/completion.h>\n#include <linux/err.h>\n#include <asm/byteorder.h>\n#include <asm/barrier.h>\n\n#include \"hinic_common.h\"\n#include \"hinic_hw_if.h\"\n#include \"hinic_hw_eqs.h\"\n#include \"hinic_hw_mgmt.h\"\n#include \"hinic_hw_wqe.h\"\n#include \"hinic_hw_wq.h\"\n#include \"hinic_hw_cmdq.h\"\n#include \"hinic_hw_io.h\"\n#include \"hinic_hw_dev.h\"\n\n#define CMDQ_CEQE_TYPE_SHIFT                    0\n\n#define CMDQ_CEQE_TYPE_MASK                     0x7\n\n#define CMDQ_CEQE_GET(val, member)              \\\n\t\t\t(((val) >> CMDQ_CEQE_##member##_SHIFT) \\\n\t\t\t & CMDQ_CEQE_##member##_MASK)\n\n#define CMDQ_WQE_ERRCODE_VAL_SHIFT              20\n\n#define CMDQ_WQE_ERRCODE_VAL_MASK               0xF\n\n#define CMDQ_WQE_ERRCODE_GET(val, member)       \\\n\t\t\t(((val) >> CMDQ_WQE_ERRCODE_##member##_SHIFT) \\\n\t\t\t & CMDQ_WQE_ERRCODE_##member##_MASK)\n\n#define CMDQ_DB_PI_OFF(pi)              (((u16)LOWER_8_BITS(pi)) << 3)\n\n#define CMDQ_DB_ADDR(db_base, pi)       ((db_base) + CMDQ_DB_PI_OFF(pi))\n\n#define CMDQ_WQE_HEADER(wqe)            ((struct hinic_cmdq_header *)(wqe))\n\n#define CMDQ_WQE_COMPLETED(ctrl_info)   \\\n\t\t\tHINIC_CMDQ_CTRL_GET(ctrl_info, HW_BUSY_BIT)\n\n#define FIRST_DATA_TO_WRITE_LAST        sizeof(u64)\n\n#define CMDQ_DB_OFF                     SZ_2K\n\n#define CMDQ_WQEBB_SIZE                 64\n#define CMDQ_WQE_SIZE                   64\n#define CMDQ_DEPTH                      SZ_4K\n\n#define CMDQ_WQ_PAGE_SIZE               SZ_256K\n\n#define WQE_LCMD_SIZE                   64\n#define WQE_SCMD_SIZE                   64\n\n#define COMPLETE_LEN                    3\n\n#define CMDQ_TIMEOUT                    1000\n\n#define CMDQ_PFN(addr, page_size)       ((addr) >> (ilog2(page_size)))\n\n#define cmdq_to_cmdqs(cmdq)     container_of((cmdq) - (cmdq)->cmdq_type, \\\n\t\t\t\t\t     struct hinic_cmdqs, cmdq[0])\n\n#define cmdqs_to_func_to_io(cmdqs)      container_of(cmdqs, \\\n\t\t\t\t\t\t     struct hinic_func_to_io, \\\n\t\t\t\t\t\t     cmdqs)\n\nenum completion_format {\n\tCOMPLETE_DIRECT = 0,\n\tCOMPLETE_SGE    = 1,\n};\n\nenum data_format {\n\tDATA_SGE        = 0,\n\tDATA_DIRECT     = 1,\n};\n\nenum bufdesc_len {\n\tBUFDESC_LCMD_LEN = 2,    \n\tBUFDESC_SCMD_LEN = 3,    \n};\n\nenum ctrl_sect_len {\n\tCTRL_SECT_LEN        = 1,  \n\tCTRL_DIRECT_SECT_LEN = 2,  \n};\n\nenum cmdq_scmd_type {\n\tCMDQ_SET_ARM_CMD = 2,\n};\n\nenum cmdq_cmd_type {\n\tCMDQ_CMD_SYNC_DIRECT_RESP = 0,\n\tCMDQ_CMD_SYNC_SGE_RESP    = 1,\n};\n\nenum completion_request {\n\tNO_CEQ  = 0,\n\tCEQ_SET = 1,\n};\n\n \nint hinic_alloc_cmdq_buf(struct hinic_cmdqs *cmdqs,\n\t\t\t struct hinic_cmdq_buf *cmdq_buf)\n{\n\tstruct hinic_hwif *hwif = cmdqs->hwif;\n\tstruct pci_dev *pdev = hwif->pdev;\n\n\tcmdq_buf->buf = dma_pool_alloc(cmdqs->cmdq_buf_pool, GFP_KERNEL,\n\t\t\t\t       &cmdq_buf->dma_addr);\n\tif (!cmdq_buf->buf) {\n\t\tdev_err(&pdev->dev, \"Failed to allocate cmd from the pool\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\n \nvoid hinic_free_cmdq_buf(struct hinic_cmdqs *cmdqs,\n\t\t\t struct hinic_cmdq_buf *cmdq_buf)\n{\n\tdma_pool_free(cmdqs->cmdq_buf_pool, cmdq_buf->buf, cmdq_buf->dma_addr);\n}\n\nstatic unsigned int cmdq_wqe_size_from_bdlen(enum bufdesc_len len)\n{\n\tunsigned int wqe_size = 0;\n\n\tswitch (len) {\n\tcase BUFDESC_LCMD_LEN:\n\t\twqe_size = WQE_LCMD_SIZE;\n\t\tbreak;\n\tcase BUFDESC_SCMD_LEN:\n\t\twqe_size = WQE_SCMD_SIZE;\n\t\tbreak;\n\t}\n\n\treturn wqe_size;\n}\n\nstatic void cmdq_set_sge_completion(struct hinic_cmdq_completion *completion,\n\t\t\t\t    struct hinic_cmdq_buf *buf_out)\n{\n\tstruct hinic_sge_resp *sge_resp = &completion->sge_resp;\n\n\thinic_set_sge(&sge_resp->sge, buf_out->dma_addr, buf_out->size);\n}\n\nstatic void cmdq_prepare_wqe_ctrl(struct hinic_cmdq_wqe *wqe, int wrapped,\n\t\t\t\t  enum hinic_cmd_ack_type ack_type,\n\t\t\t\t  enum hinic_mod_type mod, u8 cmd, u16 prod_idx,\n\t\t\t\t  enum completion_format complete_format,\n\t\t\t\t  enum data_format data_format,\n\t\t\t\t  enum bufdesc_len buf_len)\n{\n\tstruct hinic_cmdq_wqe_lcmd *wqe_lcmd;\n\tstruct hinic_cmdq_wqe_scmd *wqe_scmd;\n\tenum ctrl_sect_len ctrl_len;\n\tstruct hinic_ctrl *ctrl;\n\tu32 saved_data;\n\n\tif (data_format == DATA_SGE) {\n\t\twqe_lcmd = &wqe->wqe_lcmd;\n\n\t\twqe_lcmd->status.status_info = 0;\n\t\tctrl = &wqe_lcmd->ctrl;\n\t\tctrl_len = CTRL_SECT_LEN;\n\t} else {\n\t\twqe_scmd = &wqe->direct_wqe.wqe_scmd;\n\n\t\twqe_scmd->status.status_info = 0;\n\t\tctrl = &wqe_scmd->ctrl;\n\t\tctrl_len = CTRL_DIRECT_SECT_LEN;\n\t}\n\n\tctrl->ctrl_info = HINIC_CMDQ_CTRL_SET(prod_idx, PI)             |\n\t\t\t  HINIC_CMDQ_CTRL_SET(cmd, CMD)                 |\n\t\t\t  HINIC_CMDQ_CTRL_SET(mod, MOD)                 |\n\t\t\t  HINIC_CMDQ_CTRL_SET(ack_type, ACK_TYPE);\n\n\tCMDQ_WQE_HEADER(wqe)->header_info =\n\t\tHINIC_CMDQ_WQE_HEADER_SET(buf_len, BUFDESC_LEN)            |\n\t\tHINIC_CMDQ_WQE_HEADER_SET(complete_format, COMPLETE_FMT)   |\n\t\tHINIC_CMDQ_WQE_HEADER_SET(data_format, DATA_FMT)           |\n\t\tHINIC_CMDQ_WQE_HEADER_SET(CEQ_SET, COMPLETE_REQ)           |\n\t\tHINIC_CMDQ_WQE_HEADER_SET(COMPLETE_LEN, COMPLETE_SECT_LEN) |\n\t\tHINIC_CMDQ_WQE_HEADER_SET(ctrl_len, CTRL_LEN)              |\n\t\tHINIC_CMDQ_WQE_HEADER_SET(wrapped, TOGGLED_WRAPPED);\n\n\tsaved_data = CMDQ_WQE_HEADER(wqe)->saved_data;\n\tsaved_data = HINIC_SAVED_DATA_CLEAR(saved_data, ARM);\n\n\tif (cmd == CMDQ_SET_ARM_CMD && mod == HINIC_MOD_COMM)\n\t\tCMDQ_WQE_HEADER(wqe)->saved_data |=\n\t\t\t\t\t\tHINIC_SAVED_DATA_SET(1, ARM);\n\telse\n\t\tCMDQ_WQE_HEADER(wqe)->saved_data = saved_data;\n}\n\nstatic void cmdq_set_lcmd_bufdesc(struct hinic_cmdq_wqe_lcmd *wqe_lcmd,\n\t\t\t\t  struct hinic_cmdq_buf *buf_in)\n{\n\thinic_set_sge(&wqe_lcmd->buf_desc.sge, buf_in->dma_addr, buf_in->size);\n}\n\nstatic void cmdq_set_direct_wqe_data(struct hinic_cmdq_direct_wqe *wqe,\n\t\t\t\t     void *buf_in, u32 in_size)\n{\n\tstruct hinic_cmdq_wqe_scmd *wqe_scmd = &wqe->wqe_scmd;\n\n\twqe_scmd->buf_desc.buf_len = in_size;\n\tmemcpy(wqe_scmd->buf_desc.data, buf_in, in_size);\n}\n\nstatic void cmdq_set_lcmd_wqe(struct hinic_cmdq_wqe *wqe,\n\t\t\t      enum cmdq_cmd_type cmd_type,\n\t\t\t      struct hinic_cmdq_buf *buf_in,\n\t\t\t      struct hinic_cmdq_buf *buf_out, int wrapped,\n\t\t\t      enum hinic_cmd_ack_type ack_type,\n\t\t\t      enum hinic_mod_type mod, u8 cmd, u16 prod_idx)\n{\n\tstruct hinic_cmdq_wqe_lcmd *wqe_lcmd = &wqe->wqe_lcmd;\n\tenum completion_format complete_format;\n\n\tswitch (cmd_type) {\n\tcase CMDQ_CMD_SYNC_SGE_RESP:\n\t\tcomplete_format = COMPLETE_SGE;\n\t\tcmdq_set_sge_completion(&wqe_lcmd->completion, buf_out);\n\t\tbreak;\n\tcase CMDQ_CMD_SYNC_DIRECT_RESP:\n\t\tcomplete_format = COMPLETE_DIRECT;\n\t\twqe_lcmd->completion.direct_resp = 0;\n\t\tbreak;\n\t}\n\n\tcmdq_prepare_wqe_ctrl(wqe, wrapped, ack_type, mod, cmd,\n\t\t\t      prod_idx, complete_format, DATA_SGE,\n\t\t\t      BUFDESC_LCMD_LEN);\n\n\tcmdq_set_lcmd_bufdesc(wqe_lcmd, buf_in);\n}\n\nstatic void cmdq_set_direct_wqe(struct hinic_cmdq_wqe *wqe,\n\t\t\t\tenum cmdq_cmd_type cmd_type,\n\t\t\t\tvoid *buf_in, u16 in_size,\n\t\t\t\tstruct hinic_cmdq_buf *buf_out, int wrapped,\n\t\t\t\tenum hinic_cmd_ack_type ack_type,\n\t\t\t\tenum hinic_mod_type mod, u8 cmd, u16 prod_idx)\n{\n\tstruct hinic_cmdq_direct_wqe *direct_wqe = &wqe->direct_wqe;\n\tenum completion_format complete_format;\n\tstruct hinic_cmdq_wqe_scmd *wqe_scmd;\n\n\twqe_scmd = &direct_wqe->wqe_scmd;\n\n\tswitch (cmd_type) {\n\tcase CMDQ_CMD_SYNC_SGE_RESP:\n\t\tcomplete_format = COMPLETE_SGE;\n\t\tcmdq_set_sge_completion(&wqe_scmd->completion, buf_out);\n\t\tbreak;\n\tcase CMDQ_CMD_SYNC_DIRECT_RESP:\n\t\tcomplete_format = COMPLETE_DIRECT;\n\t\twqe_scmd->completion.direct_resp = 0;\n\t\tbreak;\n\t}\n\n\tcmdq_prepare_wqe_ctrl(wqe, wrapped, ack_type, mod, cmd, prod_idx,\n\t\t\t      complete_format, DATA_DIRECT, BUFDESC_SCMD_LEN);\n\n\tcmdq_set_direct_wqe_data(direct_wqe, buf_in, in_size);\n}\n\nstatic void cmdq_wqe_fill(void *dst, void *src)\n{\n\tmemcpy(dst + FIRST_DATA_TO_WRITE_LAST, src + FIRST_DATA_TO_WRITE_LAST,\n\t       CMDQ_WQE_SIZE - FIRST_DATA_TO_WRITE_LAST);\n\n\twmb();           \n\n\t*(u64 *)dst = *(u64 *)src;\n}\n\nstatic void cmdq_fill_db(u32 *db_info,\n\t\t\t enum hinic_cmdq_type cmdq_type, u16 prod_idx)\n{\n\t*db_info = HINIC_CMDQ_DB_INFO_SET(UPPER_8_BITS(prod_idx), HI_PROD_IDX) |\n\t\t   HINIC_CMDQ_DB_INFO_SET(HINIC_CTRL_PATH, PATH)               |\n\t\t   HINIC_CMDQ_DB_INFO_SET(cmdq_type, CMDQ_TYPE)                |\n\t\t   HINIC_CMDQ_DB_INFO_SET(HINIC_DB_CMDQ_TYPE, DB_TYPE);\n}\n\nstatic void cmdq_set_db(struct hinic_cmdq *cmdq,\n\t\t\tenum hinic_cmdq_type cmdq_type, u16 prod_idx)\n{\n\tu32 db_info;\n\n\tcmdq_fill_db(&db_info, cmdq_type, prod_idx);\n\n\t \n\tdb_info = cpu_to_be32(db_info);\n\n\twmb();   \n\n\twritel(db_info, CMDQ_DB_ADDR(cmdq->db_base, prod_idx));\n}\n\nstatic int cmdq_sync_cmd_direct_resp(struct hinic_cmdq *cmdq,\n\t\t\t\t     enum hinic_mod_type mod, u8 cmd,\n\t\t\t\t     struct hinic_cmdq_buf *buf_in,\n\t\t\t\t     u64 *resp)\n{\n\tstruct hinic_cmdq_wqe *curr_cmdq_wqe, cmdq_wqe;\n\tu16 curr_prod_idx, next_prod_idx;\n\tint errcode, wrapped, num_wqebbs;\n\tstruct hinic_wq *wq = cmdq->wq;\n\tstruct hinic_hw_wqe *hw_wqe;\n\tstruct completion done;\n\n\t \n\tspin_lock_bh(&cmdq->cmdq_lock);\n\n\t \n\thw_wqe = hinic_get_wqe(wq, WQE_LCMD_SIZE, &curr_prod_idx);\n\tif (IS_ERR(hw_wqe)) {\n\t\tspin_unlock_bh(&cmdq->cmdq_lock);\n\t\treturn -EBUSY;\n\t}\n\n\tcurr_cmdq_wqe = &hw_wqe->cmdq_wqe;\n\n\twrapped = cmdq->wrapped;\n\n\tnum_wqebbs = ALIGN(WQE_LCMD_SIZE, wq->wqebb_size) / wq->wqebb_size;\n\tnext_prod_idx = curr_prod_idx + num_wqebbs;\n\tif (next_prod_idx >= wq->q_depth) {\n\t\tcmdq->wrapped = !cmdq->wrapped;\n\t\tnext_prod_idx -= wq->q_depth;\n\t}\n\n\tcmdq->errcode[curr_prod_idx] = &errcode;\n\n\tinit_completion(&done);\n\tcmdq->done[curr_prod_idx] = &done;\n\n\tcmdq_set_lcmd_wqe(&cmdq_wqe, CMDQ_CMD_SYNC_DIRECT_RESP, buf_in, NULL,\n\t\t\t  wrapped, HINIC_CMD_ACK_TYPE_CMDQ, mod, cmd,\n\t\t\t  curr_prod_idx);\n\n\t \n\thinic_cpu_to_be32(&cmdq_wqe, WQE_LCMD_SIZE);\n\n\t \n\tcmdq_wqe_fill(curr_cmdq_wqe, &cmdq_wqe);\n\n\tcmdq_set_db(cmdq, HINIC_CMDQ_SYNC, next_prod_idx);\n\n\tspin_unlock_bh(&cmdq->cmdq_lock);\n\n\tif (!wait_for_completion_timeout(&done,\n\t\t\t\t\t msecs_to_jiffies(CMDQ_TIMEOUT))) {\n\t\tspin_lock_bh(&cmdq->cmdq_lock);\n\n\t\tif (cmdq->errcode[curr_prod_idx] == &errcode)\n\t\t\tcmdq->errcode[curr_prod_idx] = NULL;\n\n\t\tif (cmdq->done[curr_prod_idx] == &done)\n\t\t\tcmdq->done[curr_prod_idx] = NULL;\n\n\t\tspin_unlock_bh(&cmdq->cmdq_lock);\n\n\t\thinic_dump_ceq_info(cmdq->hwdev);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tsmp_rmb();       \n\n\tif (resp) {\n\t\tstruct hinic_cmdq_wqe_lcmd *wqe_lcmd = &curr_cmdq_wqe->wqe_lcmd;\n\n\t\t*resp = cpu_to_be64(wqe_lcmd->completion.direct_resp);\n\t}\n\n\tif (errcode != 0)\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int cmdq_set_arm_bit(struct hinic_cmdq *cmdq, void *buf_in,\n\t\t\t    u16 in_size)\n{\n\tstruct hinic_cmdq_wqe *curr_cmdq_wqe, cmdq_wqe;\n\tu16 curr_prod_idx, next_prod_idx;\n\tstruct hinic_wq *wq = cmdq->wq;\n\tstruct hinic_hw_wqe *hw_wqe;\n\tint wrapped, num_wqebbs;\n\n\t \n\tspin_lock(&cmdq->cmdq_lock);\n\n\t \n\thw_wqe = hinic_get_wqe(wq, WQE_SCMD_SIZE, &curr_prod_idx);\n\tif (IS_ERR(hw_wqe)) {\n\t\tspin_unlock(&cmdq->cmdq_lock);\n\t\treturn -EBUSY;\n\t}\n\n\tcurr_cmdq_wqe = &hw_wqe->cmdq_wqe;\n\n\twrapped = cmdq->wrapped;\n\n\tnum_wqebbs = ALIGN(WQE_SCMD_SIZE, wq->wqebb_size) / wq->wqebb_size;\n\tnext_prod_idx = curr_prod_idx + num_wqebbs;\n\tif (next_prod_idx >= wq->q_depth) {\n\t\tcmdq->wrapped = !cmdq->wrapped;\n\t\tnext_prod_idx -= wq->q_depth;\n\t}\n\n\tcmdq_set_direct_wqe(&cmdq_wqe, CMDQ_CMD_SYNC_DIRECT_RESP, buf_in,\n\t\t\t    in_size, NULL, wrapped, HINIC_CMD_ACK_TYPE_CMDQ,\n\t\t\t    HINIC_MOD_COMM, CMDQ_SET_ARM_CMD, curr_prod_idx);\n\n\t \n\thinic_cpu_to_be32(&cmdq_wqe, WQE_SCMD_SIZE);\n\n\t \n\tcmdq_wqe_fill(curr_cmdq_wqe, &cmdq_wqe);\n\n\tcmdq_set_db(cmdq, HINIC_CMDQ_SYNC, next_prod_idx);\n\n\tspin_unlock(&cmdq->cmdq_lock);\n\treturn 0;\n}\n\nstatic int cmdq_params_valid(struct hinic_cmdq_buf *buf_in)\n{\n\tif (buf_in->size > HINIC_CMDQ_MAX_DATA_SIZE)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n \nint hinic_cmdq_direct_resp(struct hinic_cmdqs *cmdqs,\n\t\t\t   enum hinic_mod_type mod, u8 cmd,\n\t\t\t   struct hinic_cmdq_buf *buf_in, u64 *resp)\n{\n\tstruct hinic_hwif *hwif = cmdqs->hwif;\n\tstruct pci_dev *pdev = hwif->pdev;\n\tint err;\n\n\terr = cmdq_params_valid(buf_in);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Invalid CMDQ parameters\\n\");\n\t\treturn err;\n\t}\n\n\treturn cmdq_sync_cmd_direct_resp(&cmdqs->cmdq[HINIC_CMDQ_SYNC],\n\t\t\t\t\t mod, cmd, buf_in, resp);\n}\n\n \nstatic int hinic_set_arm_bit(struct hinic_cmdqs *cmdqs,\n\t\t\t     enum hinic_set_arm_qtype q_type, u32 q_id)\n{\n\tstruct hinic_cmdq *cmdq = &cmdqs->cmdq[HINIC_CMDQ_SYNC];\n\tstruct hinic_hwif *hwif = cmdqs->hwif;\n\tstruct pci_dev *pdev = hwif->pdev;\n\tstruct hinic_cmdq_arm_bit arm_bit;\n\tint err;\n\n\tarm_bit.q_type = q_type;\n\tarm_bit.q_id   = q_id;\n\n\terr = cmdq_set_arm_bit(cmdq, &arm_bit, sizeof(arm_bit));\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Failed to set arm for qid %d\\n\", q_id);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic void clear_wqe_complete_bit(struct hinic_cmdq *cmdq,\n\t\t\t\t   struct hinic_cmdq_wqe *wqe)\n{\n\tu32 header_info = be32_to_cpu(CMDQ_WQE_HEADER(wqe)->header_info);\n\tunsigned int bufdesc_len, wqe_size;\n\tstruct hinic_ctrl *ctrl;\n\n\tbufdesc_len = HINIC_CMDQ_WQE_HEADER_GET(header_info, BUFDESC_LEN);\n\twqe_size = cmdq_wqe_size_from_bdlen(bufdesc_len);\n\tif (wqe_size == WQE_LCMD_SIZE) {\n\t\tstruct hinic_cmdq_wqe_lcmd *wqe_lcmd = &wqe->wqe_lcmd;\n\n\t\tctrl = &wqe_lcmd->ctrl;\n\t} else {\n\t\tstruct hinic_cmdq_direct_wqe *direct_wqe = &wqe->direct_wqe;\n\t\tstruct hinic_cmdq_wqe_scmd *wqe_scmd;\n\n\t\twqe_scmd = &direct_wqe->wqe_scmd;\n\t\tctrl = &wqe_scmd->ctrl;\n\t}\n\n\t \n\tctrl->ctrl_info = 0;\n\n\twmb();   \n}\n\n \nstatic int cmdq_arm_ceq_handler(struct hinic_cmdq *cmdq,\n\t\t\t\tstruct hinic_cmdq_wqe *wqe)\n{\n\tstruct hinic_cmdq_direct_wqe *direct_wqe = &wqe->direct_wqe;\n\tstruct hinic_cmdq_wqe_scmd *wqe_scmd;\n\tstruct hinic_ctrl *ctrl;\n\tu32 ctrl_info;\n\n\twqe_scmd = &direct_wqe->wqe_scmd;\n\tctrl = &wqe_scmd->ctrl;\n\tctrl_info = be32_to_cpu(ctrl->ctrl_info);\n\n\t \n\tif (!CMDQ_WQE_COMPLETED(ctrl_info))\n\t\treturn -EBUSY;\n\n\tclear_wqe_complete_bit(cmdq, wqe);\n\n\thinic_put_wqe(cmdq->wq, WQE_SCMD_SIZE);\n\treturn 0;\n}\n\nstatic void cmdq_update_errcode(struct hinic_cmdq *cmdq, u16 prod_idx,\n\t\t\t\tint errcode)\n{\n\tif (cmdq->errcode[prod_idx])\n\t\t*cmdq->errcode[prod_idx] = errcode;\n}\n\n \nstatic void cmdq_sync_cmd_handler(struct hinic_cmdq *cmdq, u16 cons_idx,\n\t\t\t\t  int errcode)\n{\n\tu16 prod_idx = cons_idx;\n\n\tspin_lock(&cmdq->cmdq_lock);\n\tcmdq_update_errcode(cmdq, prod_idx, errcode);\n\n\twmb();   \n\n\tif (cmdq->done[prod_idx])\n\t\tcomplete(cmdq->done[prod_idx]);\n\tspin_unlock(&cmdq->cmdq_lock);\n}\n\nstatic int cmdq_cmd_ceq_handler(struct hinic_cmdq *cmdq, u16 ci,\n\t\t\t\tstruct hinic_cmdq_wqe *cmdq_wqe)\n{\n\tstruct hinic_cmdq_wqe_lcmd *wqe_lcmd = &cmdq_wqe->wqe_lcmd;\n\tstruct hinic_status *status = &wqe_lcmd->status;\n\tstruct hinic_ctrl *ctrl = &wqe_lcmd->ctrl;\n\tint errcode;\n\n\tif (!CMDQ_WQE_COMPLETED(be32_to_cpu(ctrl->ctrl_info)))\n\t\treturn -EBUSY;\n\n\tdma_rmb();\n\n\terrcode = CMDQ_WQE_ERRCODE_GET(be32_to_cpu(status->status_info), VAL);\n\n\tcmdq_sync_cmd_handler(cmdq, ci, errcode);\n\n\tclear_wqe_complete_bit(cmdq, cmdq_wqe);\n\thinic_put_wqe(cmdq->wq, WQE_LCMD_SIZE);\n\treturn 0;\n}\n\n \nstatic void cmdq_ceq_handler(void *handle, u32 ceqe_data)\n{\n\tenum hinic_cmdq_type cmdq_type = CMDQ_CEQE_GET(ceqe_data, TYPE);\n\tstruct hinic_cmdqs *cmdqs = (struct hinic_cmdqs *)handle;\n\tstruct hinic_cmdq *cmdq = &cmdqs->cmdq[cmdq_type];\n\tstruct hinic_cmdq_header *header;\n\tstruct hinic_hw_wqe *hw_wqe;\n\tint err, set_arm = 0;\n\tu32 saved_data;\n\tu16 ci;\n\n\t \n\twhile ((hw_wqe = hinic_read_wqe(cmdq->wq, WQE_SCMD_SIZE, &ci))) {\n\t\tif (IS_ERR(hw_wqe))\n\t\t\tbreak;\n\n\t\theader = CMDQ_WQE_HEADER(&hw_wqe->cmdq_wqe);\n\t\tsaved_data = be32_to_cpu(header->saved_data);\n\n\t\tif (HINIC_SAVED_DATA_GET(saved_data, ARM)) {\n\t\t\t \n\t\t\tset_arm = 0;\n\n\t\t\tif (cmdq_arm_ceq_handler(cmdq, &hw_wqe->cmdq_wqe))\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tset_arm = 1;\n\n\t\t\thw_wqe = hinic_read_wqe(cmdq->wq, WQE_LCMD_SIZE, &ci);\n\t\t\tif (IS_ERR(hw_wqe))\n\t\t\t\tbreak;\n\n\t\t\tif (cmdq_cmd_ceq_handler(cmdq, ci, &hw_wqe->cmdq_wqe))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (set_arm) {\n\t\tstruct hinic_hwif *hwif = cmdqs->hwif;\n\t\tstruct pci_dev *pdev = hwif->pdev;\n\n\t\terr = hinic_set_arm_bit(cmdqs, HINIC_SET_ARM_CMDQ, cmdq_type);\n\t\tif (err)\n\t\t\tdev_err(&pdev->dev, \"Failed to set arm for CMDQ\\n\");\n\t}\n}\n\n \nstatic void cmdq_init_queue_ctxt(struct hinic_cmdq_ctxt *cmdq_ctxt,\n\t\t\t\t struct hinic_cmdq *cmdq,\n\t\t\t\t struct hinic_cmdq_pages *cmdq_pages)\n{\n\tstruct hinic_cmdq_ctxt_info *ctxt_info = &cmdq_ctxt->ctxt_info;\n\tu64 wq_first_page_paddr, cmdq_first_block_paddr, pfn;\n\tstruct hinic_cmdqs *cmdqs = cmdq_to_cmdqs(cmdq);\n\tstruct hinic_wq *wq = cmdq->wq;\n\n\t \n\twq_first_page_paddr = be64_to_cpu(*wq->block_vaddr);\n\n\tpfn = CMDQ_PFN(wq_first_page_paddr, SZ_4K);\n\n\tctxt_info->curr_wqe_page_pfn =\n\t\tHINIC_CMDQ_CTXT_PAGE_INFO_SET(pfn, CURR_WQE_PAGE_PFN)   |\n\t\tHINIC_CMDQ_CTXT_PAGE_INFO_SET(HINIC_CEQ_ID_CMDQ, EQ_ID) |\n\t\tHINIC_CMDQ_CTXT_PAGE_INFO_SET(1, CEQ_ARM)               |\n\t\tHINIC_CMDQ_CTXT_PAGE_INFO_SET(1, CEQ_EN)                |\n\t\tHINIC_CMDQ_CTXT_PAGE_INFO_SET(cmdq->wrapped, WRAPPED);\n\n\tif (wq->num_q_pages != 1) {\n\t\t \n\t\tcmdq_first_block_paddr = cmdq_pages->page_paddr;\n\n\t\tpfn = CMDQ_PFN(cmdq_first_block_paddr, wq->wq_page_size);\n\t}\n\n\tctxt_info->wq_block_pfn =\n\t\tHINIC_CMDQ_CTXT_BLOCK_INFO_SET(pfn, WQ_BLOCK_PFN) |\n\t\tHINIC_CMDQ_CTXT_BLOCK_INFO_SET(atomic_read(&wq->cons_idx), CI);\n\n\tcmdq_ctxt->func_idx = HINIC_HWIF_FUNC_IDX(cmdqs->hwif);\n\tcmdq_ctxt->ppf_idx = HINIC_HWIF_PPF_IDX(cmdqs->hwif);\n\tcmdq_ctxt->cmdq_type  = cmdq->cmdq_type;\n}\n\n \nstatic int init_cmdq(struct hinic_cmdq *cmdq, struct hinic_wq *wq,\n\t\t     enum hinic_cmdq_type q_type, void __iomem *db_area)\n{\n\tint err;\n\n\tcmdq->wq = wq;\n\tcmdq->cmdq_type = q_type;\n\tcmdq->wrapped = 1;\n\n\tspin_lock_init(&cmdq->cmdq_lock);\n\n\tcmdq->done = vzalloc(array_size(sizeof(*cmdq->done), wq->q_depth));\n\tif (!cmdq->done)\n\t\treturn -ENOMEM;\n\n\tcmdq->errcode = vzalloc(array_size(sizeof(*cmdq->errcode),\n\t\t\t\t\t   wq->q_depth));\n\tif (!cmdq->errcode) {\n\t\terr = -ENOMEM;\n\t\tgoto err_errcode;\n\t}\n\n\tcmdq->db_base = db_area + CMDQ_DB_OFF;\n\treturn 0;\n\nerr_errcode:\n\tvfree(cmdq->done);\n\treturn err;\n}\n\n \nstatic void free_cmdq(struct hinic_cmdq *cmdq)\n{\n\tvfree(cmdq->errcode);\n\tvfree(cmdq->done);\n}\n\n \nstatic int init_cmdqs_ctxt(struct hinic_hwdev *hwdev,\n\t\t\t   struct hinic_cmdqs *cmdqs, void __iomem **db_area)\n{\n\tstruct hinic_hwif *hwif = hwdev->hwif;\n\tenum hinic_cmdq_type type, cmdq_type;\n\tstruct hinic_cmdq_ctxt *cmdq_ctxts;\n\tstruct pci_dev *pdev = hwif->pdev;\n\tstruct hinic_pfhwdev *pfhwdev;\n\tint err;\n\n\tcmdq_ctxts = devm_kcalloc(&pdev->dev, HINIC_MAX_CMDQ_TYPES,\n\t\t\t\t  sizeof(*cmdq_ctxts), GFP_KERNEL);\n\tif (!cmdq_ctxts)\n\t\treturn -ENOMEM;\n\n\tpfhwdev = container_of(hwdev, struct hinic_pfhwdev, hwdev);\n\n\tcmdq_type = HINIC_CMDQ_SYNC;\n\tfor (; cmdq_type < HINIC_MAX_CMDQ_TYPES; cmdq_type++) {\n\t\tcmdqs->cmdq[cmdq_type].hwdev = hwdev;\n\t\terr = init_cmdq(&cmdqs->cmdq[cmdq_type],\n\t\t\t\t&cmdqs->saved_wqs[cmdq_type], cmdq_type,\n\t\t\t\tdb_area[cmdq_type]);\n\t\tif (err) {\n\t\t\tdev_err(&pdev->dev, \"Failed to initialize cmdq\\n\");\n\t\t\tgoto err_init_cmdq;\n\t\t}\n\n\t\tcmdq_init_queue_ctxt(&cmdq_ctxts[cmdq_type],\n\t\t\t\t     &cmdqs->cmdq[cmdq_type],\n\t\t\t\t     &cmdqs->cmdq_pages);\n\t}\n\n\t \n\tcmdq_type = HINIC_CMDQ_SYNC;\n\tfor (; cmdq_type < HINIC_MAX_CMDQ_TYPES; cmdq_type++) {\n\t\terr = hinic_msg_to_mgmt(&pfhwdev->pf_to_mgmt, HINIC_MOD_COMM,\n\t\t\t\t\tHINIC_COMM_CMD_CMDQ_CTXT_SET,\n\t\t\t\t\t&cmdq_ctxts[cmdq_type],\n\t\t\t\t\tsizeof(cmdq_ctxts[cmdq_type]),\n\t\t\t\t\tNULL, NULL, HINIC_MGMT_MSG_SYNC);\n\t\tif (err) {\n\t\t\tdev_err(&pdev->dev, \"Failed to set CMDQ CTXT type = %d\\n\",\n\t\t\t\tcmdq_type);\n\t\t\tgoto err_write_cmdq_ctxt;\n\t\t}\n\t}\n\n\tdevm_kfree(&pdev->dev, cmdq_ctxts);\n\treturn 0;\n\nerr_write_cmdq_ctxt:\n\tcmdq_type = HINIC_MAX_CMDQ_TYPES;\n\nerr_init_cmdq:\n\tfor (type = HINIC_CMDQ_SYNC; type < cmdq_type; type++)\n\t\tfree_cmdq(&cmdqs->cmdq[type]);\n\n\tdevm_kfree(&pdev->dev, cmdq_ctxts);\n\treturn err;\n}\n\nstatic int hinic_set_cmdq_depth(struct hinic_hwdev *hwdev, u16 cmdq_depth)\n{\n\tstruct hinic_cmd_hw_ioctxt hw_ioctxt = { 0 };\n\tstruct hinic_pfhwdev *pfhwdev;\n\n\tpfhwdev = container_of(hwdev, struct hinic_pfhwdev, hwdev);\n\n\thw_ioctxt.func_idx = HINIC_HWIF_FUNC_IDX(hwdev->hwif);\n\thw_ioctxt.ppf_idx = HINIC_HWIF_PPF_IDX(hwdev->hwif);\n\n\thw_ioctxt.set_cmdq_depth = HW_IOCTXT_SET_CMDQ_DEPTH_ENABLE;\n\thw_ioctxt.cmdq_depth = (u8)ilog2(cmdq_depth);\n\n\treturn hinic_msg_to_mgmt(&pfhwdev->pf_to_mgmt, HINIC_MOD_COMM,\n\t\t\t\t HINIC_COMM_CMD_HWCTXT_SET,\n\t\t\t\t &hw_ioctxt, sizeof(hw_ioctxt), NULL,\n\t\t\t\t NULL, HINIC_MGMT_MSG_SYNC);\n}\n\n \nint hinic_init_cmdqs(struct hinic_cmdqs *cmdqs, struct hinic_hwif *hwif,\n\t\t     void __iomem **db_area)\n{\n\tstruct hinic_func_to_io *func_to_io = cmdqs_to_func_to_io(cmdqs);\n\tstruct pci_dev *pdev = hwif->pdev;\n\tstruct hinic_hwdev *hwdev;\n\tu16 max_wqe_size;\n\tint err;\n\n\tcmdqs->hwif = hwif;\n\tcmdqs->cmdq_buf_pool = dma_pool_create(\"hinic_cmdq\", &pdev->dev,\n\t\t\t\t\t       HINIC_CMDQ_BUF_SIZE,\n\t\t\t\t\t       HINIC_CMDQ_BUF_SIZE, 0);\n\tif (!cmdqs->cmdq_buf_pool)\n\t\treturn -ENOMEM;\n\n\tcmdqs->saved_wqs = devm_kcalloc(&pdev->dev, HINIC_MAX_CMDQ_TYPES,\n\t\t\t\t\tsizeof(*cmdqs->saved_wqs), GFP_KERNEL);\n\tif (!cmdqs->saved_wqs) {\n\t\terr = -ENOMEM;\n\t\tgoto err_saved_wqs;\n\t}\n\n\tmax_wqe_size = WQE_LCMD_SIZE;\n\terr = hinic_wqs_cmdq_alloc(&cmdqs->cmdq_pages, cmdqs->saved_wqs, hwif,\n\t\t\t\t   HINIC_MAX_CMDQ_TYPES, CMDQ_WQEBB_SIZE,\n\t\t\t\t   CMDQ_WQ_PAGE_SIZE, CMDQ_DEPTH, max_wqe_size);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Failed to allocate CMDQ wqs\\n\");\n\t\tgoto err_cmdq_wqs;\n\t}\n\n\thwdev = container_of(func_to_io, struct hinic_hwdev, func_to_io);\n\terr = init_cmdqs_ctxt(hwdev, cmdqs, db_area);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Failed to write cmdq ctxt\\n\");\n\t\tgoto err_cmdq_ctxt;\n\t}\n\n\thinic_ceq_register_cb(&func_to_io->ceqs, HINIC_CEQ_CMDQ, cmdqs,\n\t\t\t      cmdq_ceq_handler);\n\n\terr = hinic_set_cmdq_depth(hwdev, CMDQ_DEPTH);\n\tif (err) {\n\t\tdev_err(&hwif->pdev->dev, \"Failed to set cmdq depth\\n\");\n\t\tgoto err_set_cmdq_depth;\n\t}\n\n\treturn 0;\n\nerr_set_cmdq_depth:\n\thinic_ceq_unregister_cb(&func_to_io->ceqs, HINIC_CEQ_CMDQ);\n\tfree_cmdq(&cmdqs->cmdq[HINIC_CMDQ_SYNC]);\nerr_cmdq_ctxt:\n\thinic_wqs_cmdq_free(&cmdqs->cmdq_pages, cmdqs->saved_wqs,\n\t\t\t    HINIC_MAX_CMDQ_TYPES);\n\nerr_cmdq_wqs:\n\tdevm_kfree(&pdev->dev, cmdqs->saved_wqs);\n\nerr_saved_wqs:\n\tdma_pool_destroy(cmdqs->cmdq_buf_pool);\n\treturn err;\n}\n\n \nvoid hinic_free_cmdqs(struct hinic_cmdqs *cmdqs)\n{\n\tstruct hinic_func_to_io *func_to_io = cmdqs_to_func_to_io(cmdqs);\n\tstruct hinic_hwif *hwif = cmdqs->hwif;\n\tstruct pci_dev *pdev = hwif->pdev;\n\tenum hinic_cmdq_type cmdq_type;\n\n\thinic_ceq_unregister_cb(&func_to_io->ceqs, HINIC_CEQ_CMDQ);\n\n\tcmdq_type = HINIC_CMDQ_SYNC;\n\tfor (; cmdq_type < HINIC_MAX_CMDQ_TYPES; cmdq_type++)\n\t\tfree_cmdq(&cmdqs->cmdq[cmdq_type]);\n\n\thinic_wqs_cmdq_free(&cmdqs->cmdq_pages, cmdqs->saved_wqs,\n\t\t\t    HINIC_MAX_CMDQ_TYPES);\n\n\tdevm_kfree(&pdev->dev, cmdqs->saved_wqs);\n\n\tdma_pool_destroy(cmdqs->cmdq_buf_pool);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}