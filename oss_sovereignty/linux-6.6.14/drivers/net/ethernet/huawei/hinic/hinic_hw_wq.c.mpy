{
  "module_name": "hinic_hw_wq.c",
  "hash_id": "8dfb51b29d5c68ca069b1d194b6e3679329cece92c6acd7dde3a1a15d5c18ea3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/huawei/hinic/hinic_hw_wq.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/pci.h>\n#include <linux/device.h>\n#include <linux/dma-mapping.h>\n#include <linux/slab.h>\n#include <linux/atomic.h>\n#include <linux/semaphore.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <asm/byteorder.h>\n\n#include \"hinic_hw_if.h\"\n#include \"hinic_hw_wqe.h\"\n#include \"hinic_hw_wq.h\"\n#include \"hinic_hw_cmdq.h\"\n\n#define WQS_BLOCKS_PER_PAGE             4\n\n#define WQ_BLOCK_SIZE                   4096\n#define WQS_PAGE_SIZE                   (WQS_BLOCKS_PER_PAGE * WQ_BLOCK_SIZE)\n\n#define WQS_MAX_NUM_BLOCKS              128\n#define WQS_FREE_BLOCKS_SIZE(wqs)       (WQS_MAX_NUM_BLOCKS * \\\n\t\t\t\t\t sizeof((wqs)->free_blocks[0]))\n\n#define WQ_SIZE(wq)                     ((wq)->q_depth * (wq)->wqebb_size)\n\n#define WQ_PAGE_ADDR_SIZE               sizeof(u64)\n#define WQ_MAX_PAGES                    (WQ_BLOCK_SIZE / WQ_PAGE_ADDR_SIZE)\n\n#define CMDQ_BLOCK_SIZE                 512\n#define CMDQ_PAGE_SIZE                  4096\n\n#define CMDQ_WQ_MAX_PAGES               (CMDQ_BLOCK_SIZE / WQ_PAGE_ADDR_SIZE)\n\n#define WQ_BASE_VADDR(wqs, wq)          \\\n\t\t\t((void *)((wqs)->page_vaddr[(wq)->page_idx]) \\\n\t\t\t\t+ (wq)->block_idx * WQ_BLOCK_SIZE)\n\n#define WQ_BASE_PADDR(wqs, wq)          \\\n\t\t\t((wqs)->page_paddr[(wq)->page_idx] \\\n\t\t\t\t+ (wq)->block_idx * WQ_BLOCK_SIZE)\n\n#define WQ_BASE_ADDR(wqs, wq)           \\\n\t\t\t((void *)((wqs)->shadow_page_vaddr[(wq)->page_idx]) \\\n\t\t\t\t+ (wq)->block_idx * WQ_BLOCK_SIZE)\n\n#define CMDQ_BASE_VADDR(cmdq_pages, wq) \\\n\t\t\t((void *)((cmdq_pages)->page_vaddr) \\\n\t\t\t\t+ (wq)->block_idx * CMDQ_BLOCK_SIZE)\n\n#define CMDQ_BASE_PADDR(cmdq_pages, wq) \\\n\t\t\t((cmdq_pages)->page_paddr \\\n\t\t\t\t+ (wq)->block_idx * CMDQ_BLOCK_SIZE)\n\n#define CMDQ_BASE_ADDR(cmdq_pages, wq)  \\\n\t\t\t((void *)((cmdq_pages)->shadow_page_vaddr) \\\n\t\t\t\t+ (wq)->block_idx * CMDQ_BLOCK_SIZE)\n\n#define WQ_PAGE_ADDR(wq, idx)           \\\n\t\t\t((wq)->shadow_block_vaddr[WQE_PAGE_NUM(wq, idx)])\n\n#define MASKED_WQE_IDX(wq, idx)         ((idx) & (wq)->mask)\n\n#define WQE_IN_RANGE(wqe, start, end)   \\\n\t\t(((unsigned long)(wqe) >= (unsigned long)(start)) && \\\n\t\t ((unsigned long)(wqe) < (unsigned long)(end)))\n\n#define WQE_SHADOW_PAGE(wq, wqe)        \\\n\t\t(((unsigned long)(wqe) - (unsigned long)(wq)->shadow_wqe) \\\n\t\t\t/ (wq)->max_wqe_size)\n\nstatic inline int WQE_PAGE_OFF(struct hinic_wq *wq, u16 idx)\n{\n\treturn (((idx) & ((wq)->num_wqebbs_per_page - 1))\n\t\t<< (wq)->wqebb_size_shift);\n}\n\nstatic inline int WQE_PAGE_NUM(struct hinic_wq *wq, u16 idx)\n{\n\treturn (((idx) >> ((wq)->wqebbs_per_page_shift))\n\t\t& ((wq)->num_q_pages - 1));\n}\n\n \nstatic int queue_alloc_page(struct hinic_hwif *hwif, u64 **vaddr, u64 *paddr,\n\t\t\t    void ***shadow_vaddr, size_t page_sz)\n{\n\tstruct pci_dev *pdev = hwif->pdev;\n\tdma_addr_t dma_addr;\n\n\t*vaddr = dma_alloc_coherent(&pdev->dev, page_sz, &dma_addr,\n\t\t\t\t    GFP_KERNEL);\n\tif (!*vaddr) {\n\t\tdev_err(&pdev->dev, \"Failed to allocate dma for wqs page\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t*paddr = (u64)dma_addr;\n\n\t \n\t*shadow_vaddr = vzalloc(page_sz);\n\tif (!*shadow_vaddr)\n\t\tgoto err_shadow_vaddr;\n\n\treturn 0;\n\nerr_shadow_vaddr:\n\tdma_free_coherent(&pdev->dev, page_sz, *vaddr, dma_addr);\n\treturn -ENOMEM;\n}\n\n \nstatic int wqs_allocate_page(struct hinic_wqs *wqs, int page_idx)\n{\n\treturn queue_alloc_page(wqs->hwif, &wqs->page_vaddr[page_idx],\n\t\t\t\t&wqs->page_paddr[page_idx],\n\t\t\t\t&wqs->shadow_page_vaddr[page_idx],\n\t\t\t\tWQS_PAGE_SIZE);\n}\n\n \nstatic void wqs_free_page(struct hinic_wqs *wqs, int page_idx)\n{\n\tstruct hinic_hwif *hwif = wqs->hwif;\n\tstruct pci_dev *pdev = hwif->pdev;\n\n\tdma_free_coherent(&pdev->dev, WQS_PAGE_SIZE,\n\t\t\t  wqs->page_vaddr[page_idx],\n\t\t\t  (dma_addr_t)wqs->page_paddr[page_idx]);\n\tvfree(wqs->shadow_page_vaddr[page_idx]);\n}\n\n \nstatic int cmdq_allocate_page(struct hinic_cmdq_pages *cmdq_pages)\n{\n\treturn queue_alloc_page(cmdq_pages->hwif, &cmdq_pages->page_vaddr,\n\t\t\t\t&cmdq_pages->page_paddr,\n\t\t\t\t&cmdq_pages->shadow_page_vaddr,\n\t\t\t\tCMDQ_PAGE_SIZE);\n}\n\n \nstatic void cmdq_free_page(struct hinic_cmdq_pages *cmdq_pages)\n{\n\tstruct hinic_hwif *hwif = cmdq_pages->hwif;\n\tstruct pci_dev *pdev = hwif->pdev;\n\n\tdma_free_coherent(&pdev->dev, CMDQ_PAGE_SIZE,\n\t\t\t  cmdq_pages->page_vaddr,\n\t\t\t  (dma_addr_t)cmdq_pages->page_paddr);\n\tvfree(cmdq_pages->shadow_page_vaddr);\n}\n\nstatic int alloc_page_arrays(struct hinic_wqs *wqs)\n{\n\tstruct hinic_hwif *hwif = wqs->hwif;\n\tstruct pci_dev *pdev = hwif->pdev;\n\n\twqs->page_paddr = devm_kcalloc(&pdev->dev, wqs->num_pages,\n\t\t\t\t       sizeof(*wqs->page_paddr), GFP_KERNEL);\n\tif (!wqs->page_paddr)\n\t\treturn -ENOMEM;\n\n\twqs->page_vaddr = devm_kcalloc(&pdev->dev, wqs->num_pages,\n\t\t\t\t       sizeof(*wqs->page_vaddr), GFP_KERNEL);\n\tif (!wqs->page_vaddr)\n\t\tgoto err_page_vaddr;\n\n\twqs->shadow_page_vaddr = devm_kcalloc(&pdev->dev, wqs->num_pages,\n\t\t\t\t\t      sizeof(*wqs->shadow_page_vaddr),\n\t\t\t\t\t      GFP_KERNEL);\n\tif (!wqs->shadow_page_vaddr)\n\t\tgoto err_page_shadow_vaddr;\n\n\treturn 0;\n\nerr_page_shadow_vaddr:\n\tdevm_kfree(&pdev->dev, wqs->page_vaddr);\n\nerr_page_vaddr:\n\tdevm_kfree(&pdev->dev, wqs->page_paddr);\n\treturn -ENOMEM;\n}\n\nstatic void free_page_arrays(struct hinic_wqs *wqs)\n{\n\tstruct hinic_hwif *hwif = wqs->hwif;\n\tstruct pci_dev *pdev = hwif->pdev;\n\n\tdevm_kfree(&pdev->dev, wqs->shadow_page_vaddr);\n\tdevm_kfree(&pdev->dev, wqs->page_vaddr);\n\tdevm_kfree(&pdev->dev, wqs->page_paddr);\n}\n\nstatic int wqs_next_block(struct hinic_wqs *wqs, int *page_idx,\n\t\t\t  int *block_idx)\n{\n\tint pos;\n\n\tdown(&wqs->alloc_blocks_lock);\n\n\twqs->num_free_blks--;\n\n\tif (wqs->num_free_blks < 0) {\n\t\twqs->num_free_blks++;\n\t\tup(&wqs->alloc_blocks_lock);\n\t\treturn -ENOMEM;\n\t}\n\n\tpos = wqs->alloc_blk_pos++;\n\tpos &= WQS_MAX_NUM_BLOCKS - 1;\n\n\t*page_idx = wqs->free_blocks[pos].page_idx;\n\t*block_idx = wqs->free_blocks[pos].block_idx;\n\n\twqs->free_blocks[pos].page_idx = -1;\n\twqs->free_blocks[pos].block_idx = -1;\n\n\tup(&wqs->alloc_blocks_lock);\n\treturn 0;\n}\n\nstatic void wqs_return_block(struct hinic_wqs *wqs, int page_idx,\n\t\t\t     int block_idx)\n{\n\tint pos;\n\n\tdown(&wqs->alloc_blocks_lock);\n\n\tpos = wqs->return_blk_pos++;\n\tpos &= WQS_MAX_NUM_BLOCKS - 1;\n\n\twqs->free_blocks[pos].page_idx = page_idx;\n\twqs->free_blocks[pos].block_idx = block_idx;\n\n\twqs->num_free_blks++;\n\n\tup(&wqs->alloc_blocks_lock);\n}\n\nstatic void init_wqs_blocks_arr(struct hinic_wqs *wqs)\n{\n\tint page_idx, blk_idx, pos = 0;\n\n\tfor (page_idx = 0; page_idx < wqs->num_pages; page_idx++) {\n\t\tfor (blk_idx = 0; blk_idx < WQS_BLOCKS_PER_PAGE; blk_idx++) {\n\t\t\twqs->free_blocks[pos].page_idx = page_idx;\n\t\t\twqs->free_blocks[pos].block_idx = blk_idx;\n\t\t\tpos++;\n\t\t}\n\t}\n\n\twqs->alloc_blk_pos = 0;\n\twqs->return_blk_pos = pos;\n\twqs->num_free_blks = pos;\n\n\tsema_init(&wqs->alloc_blocks_lock, 1);\n}\n\n \nint hinic_wqs_alloc(struct hinic_wqs *wqs, int max_wqs,\n\t\t    struct hinic_hwif *hwif)\n{\n\tstruct pci_dev *pdev = hwif->pdev;\n\tint err, i, page_idx;\n\n\tmax_wqs = ALIGN(max_wqs, WQS_BLOCKS_PER_PAGE);\n\tif (max_wqs > WQS_MAX_NUM_BLOCKS)  {\n\t\tdev_err(&pdev->dev, \"Invalid max_wqs = %d\\n\", max_wqs);\n\t\treturn -EINVAL;\n\t}\n\n\twqs->hwif = hwif;\n\twqs->num_pages = max_wqs / WQS_BLOCKS_PER_PAGE;\n\n\tif (alloc_page_arrays(wqs)) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Failed to allocate mem for page addresses\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tfor (page_idx = 0; page_idx < wqs->num_pages; page_idx++) {\n\t\terr = wqs_allocate_page(wqs, page_idx);\n\t\tif (err) {\n\t\t\tdev_err(&pdev->dev, \"Failed wq page allocation\\n\");\n\t\t\tgoto err_wq_allocate_page;\n\t\t}\n\t}\n\n\twqs->free_blocks = devm_kzalloc(&pdev->dev, WQS_FREE_BLOCKS_SIZE(wqs),\n\t\t\t\t\tGFP_KERNEL);\n\tif (!wqs->free_blocks) {\n\t\terr = -ENOMEM;\n\t\tgoto err_alloc_blocks;\n\t}\n\n\tinit_wqs_blocks_arr(wqs);\n\treturn 0;\n\nerr_alloc_blocks:\nerr_wq_allocate_page:\n\tfor (i = 0; i < page_idx; i++)\n\t\twqs_free_page(wqs, i);\n\n\tfree_page_arrays(wqs);\n\treturn err;\n}\n\n \nvoid hinic_wqs_free(struct hinic_wqs *wqs)\n{\n\tstruct hinic_hwif *hwif = wqs->hwif;\n\tstruct pci_dev *pdev = hwif->pdev;\n\tint page_idx;\n\n\tdevm_kfree(&pdev->dev, wqs->free_blocks);\n\n\tfor (page_idx = 0; page_idx < wqs->num_pages; page_idx++)\n\t\twqs_free_page(wqs, page_idx);\n\n\tfree_page_arrays(wqs);\n}\n\n \nstatic int alloc_wqes_shadow(struct hinic_wq *wq)\n{\n\tstruct hinic_hwif *hwif = wq->hwif;\n\tstruct pci_dev *pdev = hwif->pdev;\n\n\twq->shadow_wqe = devm_kcalloc(&pdev->dev, wq->num_q_pages,\n\t\t\t\t      wq->max_wqe_size, GFP_KERNEL);\n\tif (!wq->shadow_wqe)\n\t\treturn -ENOMEM;\n\n\twq->shadow_idx = devm_kcalloc(&pdev->dev, wq->num_q_pages,\n\t\t\t\t      sizeof(*wq->shadow_idx), GFP_KERNEL);\n\tif (!wq->shadow_idx)\n\t\tgoto err_shadow_idx;\n\n\treturn 0;\n\nerr_shadow_idx:\n\tdevm_kfree(&pdev->dev, wq->shadow_wqe);\n\treturn -ENOMEM;\n}\n\n \nstatic void free_wqes_shadow(struct hinic_wq *wq)\n{\n\tstruct hinic_hwif *hwif = wq->hwif;\n\tstruct pci_dev *pdev = hwif->pdev;\n\n\tdevm_kfree(&pdev->dev, wq->shadow_idx);\n\tdevm_kfree(&pdev->dev, wq->shadow_wqe);\n}\n\n \nstatic void free_wq_pages(struct hinic_wq *wq, struct hinic_hwif *hwif,\n\t\t\t  int num_q_pages)\n{\n\tstruct pci_dev *pdev = hwif->pdev;\n\tint i;\n\n\tfor (i = 0; i < num_q_pages; i++) {\n\t\tvoid **vaddr = &wq->shadow_block_vaddr[i];\n\t\tu64 *paddr = &wq->block_vaddr[i];\n\t\tdma_addr_t dma_addr;\n\n\t\tdma_addr = (dma_addr_t)be64_to_cpu(*paddr);\n\t\tdma_free_coherent(&pdev->dev, wq->wq_page_size, *vaddr,\n\t\t\t\t  dma_addr);\n\t}\n\n\tfree_wqes_shadow(wq);\n}\n\n \nstatic int alloc_wq_pages(struct hinic_wq *wq, struct hinic_hwif *hwif,\n\t\t\t  int max_pages)\n{\n\tstruct pci_dev *pdev = hwif->pdev;\n\tint i, err, num_q_pages;\n\n\tnum_q_pages = ALIGN(WQ_SIZE(wq), wq->wq_page_size) / wq->wq_page_size;\n\tif (num_q_pages > max_pages) {\n\t\tdev_err(&pdev->dev, \"Number wq pages exceeds the limit\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (num_q_pages & (num_q_pages - 1)) {\n\t\tdev_err(&pdev->dev, \"Number wq pages must be power of 2\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\twq->num_q_pages = num_q_pages;\n\n\terr = alloc_wqes_shadow(wq);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Failed to allocate wqe shadow\\n\");\n\t\treturn err;\n\t}\n\n\tfor (i = 0; i < num_q_pages; i++) {\n\t\tvoid **vaddr = &wq->shadow_block_vaddr[i];\n\t\tu64 *paddr = &wq->block_vaddr[i];\n\t\tdma_addr_t dma_addr;\n\n\t\t*vaddr = dma_alloc_coherent(&pdev->dev, wq->wq_page_size,\n\t\t\t\t\t    &dma_addr, GFP_KERNEL);\n\t\tif (!*vaddr) {\n\t\t\tdev_err(&pdev->dev, \"Failed to allocate wq page\\n\");\n\t\t\tgoto err_alloc_wq_pages;\n\t\t}\n\n\t\t \n\t\t*paddr = cpu_to_be64(dma_addr);\n\t}\n\n\treturn 0;\n\nerr_alloc_wq_pages:\n\tfree_wq_pages(wq, hwif, i);\n\treturn -ENOMEM;\n}\n\n \nint hinic_wq_allocate(struct hinic_wqs *wqs, struct hinic_wq *wq,\n\t\t      u16 wqebb_size, u32 wq_page_size, u16 q_depth,\n\t\t      u16 max_wqe_size)\n{\n\tstruct hinic_hwif *hwif = wqs->hwif;\n\tstruct pci_dev *pdev = hwif->pdev;\n\tu16 num_wqebbs_per_page;\n\tu16 wqebb_size_shift;\n\tint err;\n\n\tif (!is_power_of_2(wqebb_size)) {\n\t\tdev_err(&pdev->dev, \"wqebb_size must be power of 2\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (wq_page_size == 0) {\n\t\tdev_err(&pdev->dev, \"wq_page_size must be > 0\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (q_depth & (q_depth - 1)) {\n\t\tdev_err(&pdev->dev, \"WQ q_depth must be power of 2\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\twqebb_size_shift = ilog2(wqebb_size);\n\tnum_wqebbs_per_page = ALIGN(wq_page_size, wqebb_size)\n\t\t\t\t>> wqebb_size_shift;\n\n\tif (!is_power_of_2(num_wqebbs_per_page)) {\n\t\tdev_err(&pdev->dev, \"num wqebbs per page must be power of 2\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\twq->hwif = hwif;\n\n\terr = wqs_next_block(wqs, &wq->page_idx, &wq->block_idx);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Failed to get free wqs next block\\n\");\n\t\treturn err;\n\t}\n\n\twq->wqebb_size = wqebb_size;\n\twq->wq_page_size = wq_page_size;\n\twq->q_depth = q_depth;\n\twq->max_wqe_size = max_wqe_size;\n\twq->num_wqebbs_per_page = num_wqebbs_per_page;\n\twq->wqebbs_per_page_shift = ilog2(num_wqebbs_per_page);\n\twq->wqebb_size_shift = wqebb_size_shift;\n\twq->block_vaddr = WQ_BASE_VADDR(wqs, wq);\n\twq->shadow_block_vaddr = WQ_BASE_ADDR(wqs, wq);\n\twq->block_paddr = WQ_BASE_PADDR(wqs, wq);\n\n\terr = alloc_wq_pages(wq, wqs->hwif, WQ_MAX_PAGES);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Failed to allocate wq pages\\n\");\n\t\tgoto err_alloc_wq_pages;\n\t}\n\n\tatomic_set(&wq->cons_idx, 0);\n\tatomic_set(&wq->prod_idx, 0);\n\tatomic_set(&wq->delta, q_depth);\n\twq->mask = q_depth - 1;\n\n\treturn 0;\n\nerr_alloc_wq_pages:\n\twqs_return_block(wqs, wq->page_idx, wq->block_idx);\n\treturn err;\n}\n\n \nvoid hinic_wq_free(struct hinic_wqs *wqs, struct hinic_wq *wq)\n{\n\tfree_wq_pages(wq, wqs->hwif, wq->num_q_pages);\n\n\twqs_return_block(wqs, wq->page_idx, wq->block_idx);\n}\n\n \nint hinic_wqs_cmdq_alloc(struct hinic_cmdq_pages *cmdq_pages,\n\t\t\t struct hinic_wq *wq, struct hinic_hwif *hwif,\n\t\t\t int cmdq_blocks, u16 wqebb_size, u32 wq_page_size,\n\t\t\t u16 q_depth, u16 max_wqe_size)\n{\n\tstruct pci_dev *pdev = hwif->pdev;\n\tu16 num_wqebbs_per_page_shift;\n\tu16 num_wqebbs_per_page;\n\tu16 wqebb_size_shift;\n\tint i, j, err = -ENOMEM;\n\n\tif (!is_power_of_2(wqebb_size)) {\n\t\tdev_err(&pdev->dev, \"wqebb_size must be power of 2\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (wq_page_size == 0) {\n\t\tdev_err(&pdev->dev, \"wq_page_size must be > 0\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (q_depth & (q_depth - 1)) {\n\t\tdev_err(&pdev->dev, \"WQ q_depth must be power of 2\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\twqebb_size_shift = ilog2(wqebb_size);\n\tnum_wqebbs_per_page = ALIGN(wq_page_size, wqebb_size)\n\t\t\t\t>> wqebb_size_shift;\n\n\tif (!is_power_of_2(num_wqebbs_per_page)) {\n\t\tdev_err(&pdev->dev, \"num wqebbs per page must be power of 2\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tcmdq_pages->hwif = hwif;\n\n\terr = cmdq_allocate_page(cmdq_pages);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Failed to allocate CMDQ page\\n\");\n\t\treturn err;\n\t}\n\tnum_wqebbs_per_page_shift = ilog2(num_wqebbs_per_page);\n\n\tfor (i = 0; i < cmdq_blocks; i++) {\n\t\twq[i].hwif = hwif;\n\t\twq[i].page_idx = 0;\n\t\twq[i].block_idx = i;\n\n\t\twq[i].wqebb_size = wqebb_size;\n\t\twq[i].wq_page_size = wq_page_size;\n\t\twq[i].q_depth = q_depth;\n\t\twq[i].max_wqe_size = max_wqe_size;\n\t\twq[i].num_wqebbs_per_page = num_wqebbs_per_page;\n\t\twq[i].wqebbs_per_page_shift = num_wqebbs_per_page_shift;\n\t\twq[i].wqebb_size_shift = wqebb_size_shift;\n\t\twq[i].block_vaddr = CMDQ_BASE_VADDR(cmdq_pages, &wq[i]);\n\t\twq[i].shadow_block_vaddr = CMDQ_BASE_ADDR(cmdq_pages, &wq[i]);\n\t\twq[i].block_paddr = CMDQ_BASE_PADDR(cmdq_pages, &wq[i]);\n\n\t\terr = alloc_wq_pages(&wq[i], cmdq_pages->hwif,\n\t\t\t\t     CMDQ_WQ_MAX_PAGES);\n\t\tif (err) {\n\t\t\tdev_err(&pdev->dev, \"Failed to alloc CMDQ blocks\\n\");\n\t\t\tgoto err_cmdq_block;\n\t\t}\n\n\t\tatomic_set(&wq[i].cons_idx, 0);\n\t\tatomic_set(&wq[i].prod_idx, 0);\n\t\tatomic_set(&wq[i].delta, q_depth);\n\t\twq[i].mask = q_depth - 1;\n\t}\n\n\treturn 0;\n\nerr_cmdq_block:\n\tfor (j = 0; j < i; j++)\n\t\tfree_wq_pages(&wq[j], cmdq_pages->hwif, wq[j].num_q_pages);\n\n\tcmdq_free_page(cmdq_pages);\n\treturn err;\n}\n\n \nvoid hinic_wqs_cmdq_free(struct hinic_cmdq_pages *cmdq_pages,\n\t\t\t struct hinic_wq *wq, int cmdq_blocks)\n{\n\tint i;\n\n\tfor (i = 0; i < cmdq_blocks; i++)\n\t\tfree_wq_pages(&wq[i], cmdq_pages->hwif, wq[i].num_q_pages);\n\n\tcmdq_free_page(cmdq_pages);\n}\n\nstatic void copy_wqe_to_shadow(struct hinic_wq *wq, void *shadow_addr,\n\t\t\t       int num_wqebbs, u16 idx)\n{\n\tvoid *wqebb_addr;\n\tint i;\n\n\tfor (i = 0; i < num_wqebbs; i++, idx++) {\n\t\tidx = MASKED_WQE_IDX(wq, idx);\n\t\twqebb_addr = WQ_PAGE_ADDR(wq, idx) +\n\t\t\t     WQE_PAGE_OFF(wq, idx);\n\n\t\tmemcpy(shadow_addr, wqebb_addr, wq->wqebb_size);\n\n\t\tshadow_addr += wq->wqebb_size;\n\t}\n}\n\nstatic void copy_wqe_from_shadow(struct hinic_wq *wq, void *shadow_addr,\n\t\t\t\t int num_wqebbs, u16 idx)\n{\n\tvoid *wqebb_addr;\n\tint i;\n\n\tfor (i = 0; i < num_wqebbs; i++, idx++) {\n\t\tidx = MASKED_WQE_IDX(wq, idx);\n\t\twqebb_addr = WQ_PAGE_ADDR(wq, idx) +\n\t\t\t     WQE_PAGE_OFF(wq, idx);\n\n\t\tmemcpy(wqebb_addr, shadow_addr, wq->wqebb_size);\n\t\tshadow_addr += wq->wqebb_size;\n\t}\n}\n\n \nstruct hinic_hw_wqe *hinic_get_wqe(struct hinic_wq *wq, unsigned int wqe_size,\n\t\t\t\t   u16 *prod_idx)\n{\n\tint curr_pg, end_pg, num_wqebbs;\n\tu16 curr_prod_idx, end_prod_idx;\n\n\t*prod_idx = MASKED_WQE_IDX(wq, atomic_read(&wq->prod_idx));\n\n\tnum_wqebbs = ALIGN(wqe_size, wq->wqebb_size) >> wq->wqebb_size_shift;\n\n\tif (atomic_sub_return(num_wqebbs, &wq->delta) <= 0) {\n\t\tatomic_add(num_wqebbs, &wq->delta);\n\t\treturn ERR_PTR(-EBUSY);\n\t}\n\n\tend_prod_idx = atomic_add_return(num_wqebbs, &wq->prod_idx);\n\n\tend_prod_idx = MASKED_WQE_IDX(wq, end_prod_idx);\n\tcurr_prod_idx = end_prod_idx - num_wqebbs;\n\tcurr_prod_idx = MASKED_WQE_IDX(wq, curr_prod_idx);\n\n\t \n\tend_prod_idx = MASKED_WQE_IDX(wq, end_prod_idx - 1);\n\n\tcurr_pg = WQE_PAGE_NUM(wq, curr_prod_idx);\n\tend_pg = WQE_PAGE_NUM(wq, end_prod_idx);\n\n\t*prod_idx = curr_prod_idx;\n\n\t \n\tif (curr_pg != end_pg || end_prod_idx < *prod_idx) {\n\t\tvoid *shadow_addr = &wq->shadow_wqe[curr_pg * wq->max_wqe_size];\n\n\t\tcopy_wqe_to_shadow(wq, shadow_addr, num_wqebbs, *prod_idx);\n\n\t\twq->shadow_idx[curr_pg] = *prod_idx;\n\t\treturn shadow_addr;\n\t}\n\n\treturn WQ_PAGE_ADDR(wq, *prod_idx) + WQE_PAGE_OFF(wq, *prod_idx);\n}\n\n \nvoid hinic_return_wqe(struct hinic_wq *wq, unsigned int wqe_size)\n{\n\tint num_wqebbs = ALIGN(wqe_size, wq->wqebb_size) / wq->wqebb_size;\n\n\tatomic_sub(num_wqebbs, &wq->prod_idx);\n\n\tatomic_add(num_wqebbs, &wq->delta);\n}\n\n \nvoid hinic_put_wqe(struct hinic_wq *wq, unsigned int wqe_size)\n{\n\tint num_wqebbs = ALIGN(wqe_size, wq->wqebb_size)\n\t\t\t>> wq->wqebb_size_shift;\n\n\tatomic_add(num_wqebbs, &wq->cons_idx);\n\n\tatomic_add(num_wqebbs, &wq->delta);\n}\n\n \nstruct hinic_hw_wqe *hinic_read_wqe(struct hinic_wq *wq, unsigned int wqe_size,\n\t\t\t\t    u16 *cons_idx)\n{\n\tint num_wqebbs = ALIGN(wqe_size, wq->wqebb_size)\n\t\t\t>> wq->wqebb_size_shift;\n\tu16 curr_cons_idx, end_cons_idx;\n\tint curr_pg, end_pg;\n\n\tif ((atomic_read(&wq->delta) + num_wqebbs) > wq->q_depth)\n\t\treturn ERR_PTR(-EBUSY);\n\n\tcurr_cons_idx = atomic_read(&wq->cons_idx);\n\n\tcurr_cons_idx = MASKED_WQE_IDX(wq, curr_cons_idx);\n\tend_cons_idx = MASKED_WQE_IDX(wq, curr_cons_idx + num_wqebbs - 1);\n\n\tcurr_pg = WQE_PAGE_NUM(wq, curr_cons_idx);\n\tend_pg = WQE_PAGE_NUM(wq, end_cons_idx);\n\n\t*cons_idx = curr_cons_idx;\n\n\t \n\tif (curr_pg != end_pg || end_cons_idx < curr_cons_idx) {\n\t\tvoid *shadow_addr = &wq->shadow_wqe[curr_pg * wq->max_wqe_size];\n\n\t\tcopy_wqe_to_shadow(wq, shadow_addr, num_wqebbs, *cons_idx);\n\t\treturn shadow_addr;\n\t}\n\n\treturn WQ_PAGE_ADDR(wq, *cons_idx) + WQE_PAGE_OFF(wq, *cons_idx);\n}\n\n \nstruct hinic_hw_wqe *hinic_read_wqe_direct(struct hinic_wq *wq, u16 cons_idx)\n{\n\treturn WQ_PAGE_ADDR(wq, cons_idx) + WQE_PAGE_OFF(wq, cons_idx);\n}\n\n \nstatic inline bool wqe_shadow(struct hinic_wq *wq, struct hinic_hw_wqe *wqe)\n{\n\tsize_t wqe_shadow_size = wq->num_q_pages * wq->max_wqe_size;\n\n\treturn WQE_IN_RANGE(wqe, wq->shadow_wqe,\n\t\t\t    &wq->shadow_wqe[wqe_shadow_size]);\n}\n\n \nvoid hinic_write_wqe(struct hinic_wq *wq, struct hinic_hw_wqe *wqe,\n\t\t     unsigned int wqe_size)\n{\n\tint curr_pg, num_wqebbs;\n\tvoid *shadow_addr;\n\tu16 prod_idx;\n\n\tif (wqe_shadow(wq, wqe)) {\n\t\tcurr_pg = WQE_SHADOW_PAGE(wq, wqe);\n\n\t\tprod_idx = wq->shadow_idx[curr_pg];\n\t\tnum_wqebbs = ALIGN(wqe_size, wq->wqebb_size) / wq->wqebb_size;\n\t\tshadow_addr = &wq->shadow_wqe[curr_pg * wq->max_wqe_size];\n\n\t\tcopy_wqe_from_shadow(wq, shadow_addr, num_wqebbs, prod_idx);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}