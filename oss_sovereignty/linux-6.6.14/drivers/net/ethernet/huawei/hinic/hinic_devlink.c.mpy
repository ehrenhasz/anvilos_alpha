{
  "module_name": "hinic_devlink.c",
  "hash_id": "54e2b86e877c591c4c6dd861d8b058add0990d568a4c11b509b75ec63b46b543",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/huawei/hinic/hinic_devlink.c",
  "human_readable_source": "\n \n#include <linux/netlink.h>\n#include <net/devlink.h>\n#include <linux/firmware.h>\n\n#include \"hinic_port.h\"\n#include \"hinic_devlink.h\"\n#include \"hinic_hw_dev.h\"\n\nstatic bool check_image_valid(struct hinic_devlink_priv *priv, const u8 *buf,\n\t\t\t      u32 image_size, struct host_image_st *host_image)\n{\n\tstruct fw_image_st *fw_image = NULL;\n\tu32 len = 0;\n\tu32 i;\n\n\tfw_image = (struct fw_image_st *)buf;\n\n\tif (fw_image->fw_magic != HINIC_MAGIC_NUM) {\n\t\tdev_err(&priv->hwdev->hwif->pdev->dev, \"Wrong fw_magic read from file, fw_magic: 0x%x\\n\",\n\t\t\tfw_image->fw_magic);\n\t\treturn false;\n\t}\n\n\tif (fw_image->fw_info.fw_section_cnt > MAX_FW_TYPE_NUM) {\n\t\tdev_err(&priv->hwdev->hwif->pdev->dev, \"Wrong fw_type_num read from file, fw_type_num: 0x%x\\n\",\n\t\t\tfw_image->fw_info.fw_section_cnt);\n\t\treturn false;\n\t}\n\n\tfor (i = 0; i < fw_image->fw_info.fw_section_cnt; i++) {\n\t\tlen += fw_image->fw_section_info[i].fw_section_len;\n\t\thost_image->image_section_info[i] = fw_image->fw_section_info[i];\n\t}\n\n\tif (len != fw_image->fw_len ||\n\t    (fw_image->fw_len + UPDATEFW_IMAGE_HEAD_SIZE) != image_size) {\n\t\tdev_err(&priv->hwdev->hwif->pdev->dev, \"Wrong data size read from file\\n\");\n\t\treturn false;\n\t}\n\n\thost_image->image_info.up_total_len = fw_image->fw_len;\n\thost_image->image_info.fw_version = fw_image->fw_version;\n\thost_image->section_type_num = fw_image->fw_info.fw_section_cnt;\n\thost_image->device_id = fw_image->device_id;\n\n\treturn true;\n}\n\nstatic bool check_image_integrity(struct hinic_devlink_priv *priv,\n\t\t\t\t  struct host_image_st *host_image,\n\t\t\t\t  u32 update_type)\n{\n\tu32 collect_section_type = 0;\n\tu32 i, type;\n\n\tfor (i = 0; i < host_image->section_type_num; i++) {\n\t\ttype = host_image->image_section_info[i].fw_section_type;\n\t\tif (collect_section_type & (1U << type)) {\n\t\t\tdev_err(&priv->hwdev->hwif->pdev->dev, \"Duplicate section type: %u\\n\",\n\t\t\t\ttype);\n\t\t\treturn false;\n\t\t}\n\t\tcollect_section_type |= (1U << type);\n\t}\n\n\tif (update_type == FW_UPDATE_COLD &&\n\t    (((collect_section_type & _IMAGE_COLD_SUB_MODULES_MUST_IN) ==\n\t       _IMAGE_COLD_SUB_MODULES_MUST_IN) ||\n\t      collect_section_type == _IMAGE_CFG_SUB_MODULES_MUST_IN))\n\t\treturn true;\n\n\tif (update_type == FW_UPDATE_HOT &&\n\t    (collect_section_type & _IMAGE_HOT_SUB_MODULES_MUST_IN) ==\n\t    _IMAGE_HOT_SUB_MODULES_MUST_IN)\n\t\treturn true;\n\n\tif (update_type == FW_UPDATE_COLD)\n\t\tdev_err(&priv->hwdev->hwif->pdev->dev, \"Check file integrity failed, valid: 0x%x or 0x%lx, current: 0x%x\\n\",\n\t\t\t_IMAGE_COLD_SUB_MODULES_MUST_IN,\n\t\t\t_IMAGE_CFG_SUB_MODULES_MUST_IN, collect_section_type);\n\telse\n\t\tdev_err(&priv->hwdev->hwif->pdev->dev, \"Check file integrity failed, valid:0x%x, current: 0x%x\\n\",\n\t\t\t_IMAGE_HOT_SUB_MODULES_MUST_IN, collect_section_type);\n\n\treturn false;\n}\n\nstatic int check_image_device_type(struct hinic_devlink_priv *priv,\n\t\t\t\t   u32 image_device_type)\n{\n\tstruct hinic_comm_board_info board_info = {0};\n\n\tif (hinic_get_board_info(priv->hwdev, &board_info)) {\n\t\tdev_err(&priv->hwdev->hwif->pdev->dev, \"Get board info failed\\n\");\n\t\treturn false;\n\t}\n\n\tif (image_device_type == board_info.info.board_type)\n\t\treturn true;\n\n\tdev_err(&priv->hwdev->hwif->pdev->dev, \"The device type of upgrade file doesn't match the device type of current firmware, please check the upgrade file\\n\");\n\tdev_err(&priv->hwdev->hwif->pdev->dev, \"The image device type: 0x%x, firmware device type: 0x%x\\n\",\n\t\timage_device_type, board_info.info.board_type);\n\n\treturn false;\n}\n\nstatic int hinic_flash_fw(struct hinic_devlink_priv *priv, const u8 *data,\n\t\t\t  struct host_image_st *host_image)\n{\n\tu32 section_remain_send_len, send_fragment_len, send_pos, up_total_len;\n\tstruct hinic_cmd_update_fw *fw_update_msg = NULL;\n\tu32 section_type, section_crc, section_version;\n\tu32 i, len, section_len, section_offset;\n\tu16 out_size = sizeof(*fw_update_msg);\n\tint total_len_flag = 0;\n\tint err;\n\n\tfw_update_msg = kzalloc(sizeof(*fw_update_msg), GFP_KERNEL);\n\tif (!fw_update_msg)\n\t\treturn -ENOMEM;\n\n\tup_total_len = host_image->image_info.up_total_len;\n\n\tfor (i = 0; i < host_image->section_type_num; i++) {\n\t\tlen = host_image->image_section_info[i].fw_section_len;\n\t\tif (host_image->image_section_info[i].fw_section_type ==\n\t\t    UP_FW_UPDATE_BOOT) {\n\t\t\tup_total_len = up_total_len - len;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfor (i = 0; i < host_image->section_type_num; i++) {\n\t\tsection_len =\n\t\t\thost_image->image_section_info[i].fw_section_len;\n\t\tsection_offset =\n\t\t\thost_image->image_section_info[i].fw_section_offset;\n\t\tsection_remain_send_len = section_len;\n\t\tsection_type =\n\t\t\thost_image->image_section_info[i].fw_section_type;\n\t\tsection_crc = host_image->image_section_info[i].fw_section_crc;\n\t\tsection_version =\n\t\t\thost_image->image_section_info[i].fw_section_version;\n\n\t\tif (section_type == UP_FW_UPDATE_BOOT)\n\t\t\tcontinue;\n\n\t\tsend_fragment_len = 0;\n\t\tsend_pos = 0;\n\n\t\twhile (section_remain_send_len > 0) {\n\t\t\tif (!total_len_flag) {\n\t\t\t\tfw_update_msg->total_len = up_total_len;\n\t\t\t\ttotal_len_flag = 1;\n\t\t\t} else {\n\t\t\t\tfw_update_msg->total_len = 0;\n\t\t\t}\n\n\t\t\tmemset(fw_update_msg->data, 0, MAX_FW_FRAGMENT_LEN);\n\n\t\t\tfw_update_msg->ctl_info.SF =\n\t\t\t\t(section_remain_send_len == section_len) ?\n\t\t\t\ttrue : false;\n\t\t\tfw_update_msg->section_info.FW_section_CRC = section_crc;\n\t\t\tfw_update_msg->fw_section_version = section_version;\n\t\t\tfw_update_msg->ctl_info.flag = UP_TYPE_A;\n\n\t\t\tif (section_type <= UP_FW_UPDATE_UP_DATA_B) {\n\t\t\t\tfw_update_msg->section_info.FW_section_type =\n\t\t\t\t\t(section_type % 2) ?\n\t\t\t\t\tUP_FW_UPDATE_UP_DATA :\n\t\t\t\t\tUP_FW_UPDATE_UP_TEXT;\n\n\t\t\t\tfw_update_msg->ctl_info.flag = UP_TYPE_B;\n\t\t\t\tif (section_type <= UP_FW_UPDATE_UP_DATA_A)\n\t\t\t\t\tfw_update_msg->ctl_info.flag = UP_TYPE_A;\n\t\t\t} else {\n\t\t\t\tfw_update_msg->section_info.FW_section_type =\n\t\t\t\t\tsection_type - 0x2;\n\t\t\t}\n\n\t\t\tfw_update_msg->setion_total_len = section_len;\n\t\t\tfw_update_msg->section_offset = send_pos;\n\n\t\t\tif (section_remain_send_len <= MAX_FW_FRAGMENT_LEN) {\n\t\t\t\tfw_update_msg->ctl_info.SL = true;\n\t\t\t\tfw_update_msg->ctl_info.fragment_len =\n\t\t\t\t\tsection_remain_send_len;\n\t\t\t\tsend_fragment_len += section_remain_send_len;\n\t\t\t} else {\n\t\t\t\tfw_update_msg->ctl_info.SL = false;\n\t\t\t\tfw_update_msg->ctl_info.fragment_len =\n\t\t\t\t\tMAX_FW_FRAGMENT_LEN;\n\t\t\t\tsend_fragment_len += MAX_FW_FRAGMENT_LEN;\n\t\t\t}\n\n\t\t\tmemcpy(fw_update_msg->data,\n\t\t\t       data + UPDATEFW_IMAGE_HEAD_SIZE +\n\t\t\t       section_offset + send_pos,\n\t\t\t       fw_update_msg->ctl_info.fragment_len);\n\n\t\t\terr = hinic_port_msg_cmd(priv->hwdev,\n\t\t\t\t\t\t HINIC_PORT_CMD_UPDATE_FW,\n\t\t\t\t\t\t fw_update_msg,\n\t\t\t\t\t\t sizeof(*fw_update_msg),\n\t\t\t\t\t\t fw_update_msg, &out_size);\n\t\t\tif (err || !out_size || fw_update_msg->status) {\n\t\t\t\tdev_err(&priv->hwdev->hwif->pdev->dev, \"Failed to update firmware, err: %d, status: 0x%x, out size: 0x%x\\n\",\n\t\t\t\t\terr, fw_update_msg->status, out_size);\n\t\t\t\terr = fw_update_msg->status ?\n\t\t\t\t\tfw_update_msg->status : -EIO;\n\t\t\t\tkfree(fw_update_msg);\n\t\t\t\treturn err;\n\t\t\t}\n\n\t\t\tsend_pos = send_fragment_len;\n\t\t\tsection_remain_send_len = section_len -\n\t\t\t\t\t\t  send_fragment_len;\n\t\t}\n\t}\n\n\tkfree(fw_update_msg);\n\n\treturn 0;\n}\n\nstatic int hinic_firmware_update(struct hinic_devlink_priv *priv,\n\t\t\t\t const struct firmware *fw,\n\t\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct host_image_st host_image;\n\tint err;\n\n\tmemset(&host_image, 0, sizeof(struct host_image_st));\n\n\tif (!check_image_valid(priv, fw->data, fw->size, &host_image) ||\n\t    !check_image_integrity(priv, &host_image, FW_UPDATE_COLD) ||\n\t    !check_image_device_type(priv, host_image.device_id)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Check image failed\");\n\t\treturn -EINVAL;\n\t}\n\n\tdev_info(&priv->hwdev->hwif->pdev->dev, \"Flash firmware begin\\n\");\n\n\terr = hinic_flash_fw(priv, fw->data, &host_image);\n\tif (err) {\n\t\tif (err == HINIC_FW_DISMATCH_ERROR) {\n\t\t\tdev_err(&priv->hwdev->hwif->pdev->dev, \"Firmware image doesn't match this card, please use newer image, err: %d\\n\",\n\t\t\t\terr);\n\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t   \"Firmware image doesn't match this card, please use newer image\");\n\t\t} else {\n\t\t\tdev_err(&priv->hwdev->hwif->pdev->dev, \"Send firmware image data failed, err: %d\\n\",\n\t\t\t\terr);\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Send firmware image data failed\");\n\t\t}\n\n\t\treturn err;\n\t}\n\n\tdev_info(&priv->hwdev->hwif->pdev->dev, \"Flash firmware end\\n\");\n\n\treturn 0;\n}\n\nstatic int hinic_devlink_flash_update(struct devlink *devlink,\n\t\t\t\t      struct devlink_flash_update_params *params,\n\t\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct hinic_devlink_priv *priv = devlink_priv(devlink);\n\n\treturn hinic_firmware_update(priv, params->fw, extack);\n}\n\nstatic const struct devlink_ops hinic_devlink_ops = {\n\t.flash_update = hinic_devlink_flash_update,\n};\n\nstruct devlink *hinic_devlink_alloc(struct device *dev)\n{\n\treturn devlink_alloc(&hinic_devlink_ops, sizeof(struct hinic_dev), dev);\n}\n\nvoid hinic_devlink_free(struct devlink *devlink)\n{\n\tdevlink_free(devlink);\n}\n\nvoid hinic_devlink_register(struct hinic_devlink_priv *priv)\n{\n\tstruct devlink *devlink = priv_to_devlink(priv);\n\n\tdevlink_register(devlink);\n}\n\nvoid hinic_devlink_unregister(struct hinic_devlink_priv *priv)\n{\n\tstruct devlink *devlink = priv_to_devlink(priv);\n\n\tdevlink_unregister(devlink);\n}\n\nstatic int chip_fault_show(struct devlink_fmsg *fmsg,\n\t\t\t   struct hinic_fault_event *event)\n{\n\tconst char * const level_str[FAULT_LEVEL_MAX + 1] = {\n\t\t\"fatal\", \"reset\", \"flr\", \"general\", \"suggestion\", \"Unknown\"};\n\tu8 fault_level;\n\tint err;\n\n\tfault_level = (event->event.chip.err_level < FAULT_LEVEL_MAX) ?\n\t\tevent->event.chip.err_level : FAULT_LEVEL_MAX;\n\tif (fault_level == FAULT_LEVEL_SERIOUS_FLR) {\n\t\terr = devlink_fmsg_u32_pair_put(fmsg, \"Function level err func_id\",\n\t\t\t\t\t\t(u32)event->event.chip.func_id);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\terr = devlink_fmsg_u8_pair_put(fmsg, \"module_id\", event->event.chip.node_id);\n\tif (err)\n\t\treturn err;\n\n\terr = devlink_fmsg_u32_pair_put(fmsg, \"err_type\", (u32)event->event.chip.err_type);\n\tif (err)\n\t\treturn err;\n\n\terr = devlink_fmsg_string_pair_put(fmsg, \"err_level\", level_str[fault_level]);\n\tif (err)\n\t\treturn err;\n\n\terr = devlink_fmsg_u32_pair_put(fmsg, \"err_csr_addr\",\n\t\t\t\t\tevent->event.chip.err_csr_addr);\n\tif (err)\n\t\treturn err;\n\n\terr = devlink_fmsg_u32_pair_put(fmsg, \"err_csr_value\",\n\t\t\t\t\tevent->event.chip.err_csr_value);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic int fault_report_show(struct devlink_fmsg *fmsg,\n\t\t\t     struct hinic_fault_event *event)\n{\n\tconst char * const type_str[FAULT_TYPE_MAX + 1] = {\n\t\t\"chip\", \"ucode\", \"mem rd timeout\", \"mem wr timeout\",\n\t\t\"reg rd timeout\", \"reg wr timeout\", \"phy fault\", \"Unknown\"};\n\tu8 fault_type;\n\tint err;\n\n\tfault_type = (event->type < FAULT_TYPE_MAX) ? event->type : FAULT_TYPE_MAX;\n\n\terr = devlink_fmsg_string_pair_put(fmsg, \"Fault type\", type_str[fault_type]);\n\tif (err)\n\t\treturn err;\n\n\terr = devlink_fmsg_binary_pair_put(fmsg, \"Fault raw data\",\n\t\t\t\t\t   event->event.val, sizeof(event->event.val));\n\tif (err)\n\t\treturn err;\n\n\tswitch (event->type) {\n\tcase FAULT_TYPE_CHIP:\n\t\terr = chip_fault_show(fmsg, event);\n\t\tif (err)\n\t\t\treturn err;\n\t\tbreak;\n\tcase FAULT_TYPE_UCODE:\n\t\terr = devlink_fmsg_u8_pair_put(fmsg, \"Cause_id\", event->event.ucode.cause_id);\n\t\tif (err)\n\t\t\treturn err;\n\t\terr = devlink_fmsg_u8_pair_put(fmsg, \"core_id\", event->event.ucode.core_id);\n\t\tif (err)\n\t\t\treturn err;\n\t\terr = devlink_fmsg_u8_pair_put(fmsg, \"c_id\", event->event.ucode.c_id);\n\t\tif (err)\n\t\t\treturn err;\n\t\terr = devlink_fmsg_u8_pair_put(fmsg, \"epc\", event->event.ucode.epc);\n\t\tif (err)\n\t\t\treturn err;\n\t\tbreak;\n\tcase FAULT_TYPE_MEM_RD_TIMEOUT:\n\tcase FAULT_TYPE_MEM_WR_TIMEOUT:\n\t\terr = devlink_fmsg_u32_pair_put(fmsg, \"Err_csr_ctrl\",\n\t\t\t\t\t\tevent->event.mem_timeout.err_csr_ctrl);\n\t\tif (err)\n\t\t\treturn err;\n\t\terr = devlink_fmsg_u32_pair_put(fmsg, \"err_csr_data\",\n\t\t\t\t\t\tevent->event.mem_timeout.err_csr_data);\n\t\tif (err)\n\t\t\treturn err;\n\t\terr = devlink_fmsg_u32_pair_put(fmsg, \"ctrl_tab\",\n\t\t\t\t\t\tevent->event.mem_timeout.ctrl_tab);\n\t\tif (err)\n\t\t\treturn err;\n\t\terr = devlink_fmsg_u32_pair_put(fmsg, \"mem_index\",\n\t\t\t\t\t\tevent->event.mem_timeout.mem_index);\n\t\tif (err)\n\t\t\treturn err;\n\t\tbreak;\n\tcase FAULT_TYPE_REG_RD_TIMEOUT:\n\tcase FAULT_TYPE_REG_WR_TIMEOUT:\n\t\terr = devlink_fmsg_u32_pair_put(fmsg, \"Err_csr\", event->event.reg_timeout.err_csr);\n\t\tif (err)\n\t\t\treturn err;\n\t\tbreak;\n\tcase FAULT_TYPE_PHY_FAULT:\n\t\terr = devlink_fmsg_u8_pair_put(fmsg, \"Op_type\", event->event.phy_fault.op_type);\n\t\tif (err)\n\t\t\treturn err;\n\t\terr = devlink_fmsg_u8_pair_put(fmsg, \"port_id\", event->event.phy_fault.port_id);\n\t\tif (err)\n\t\t\treturn err;\n\t\terr = devlink_fmsg_u8_pair_put(fmsg, \"dev_ad\", event->event.phy_fault.dev_ad);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = devlink_fmsg_u32_pair_put(fmsg, \"csr_addr\", event->event.phy_fault.csr_addr);\n\t\tif (err)\n\t\t\treturn err;\n\t\terr = devlink_fmsg_u32_pair_put(fmsg, \"op_data\", event->event.phy_fault.op_data);\n\t\tif (err)\n\t\t\treturn err;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int hinic_hw_reporter_dump(struct devlink_health_reporter *reporter,\n\t\t\t\t  struct devlink_fmsg *fmsg, void *priv_ctx,\n\t\t\t\t  struct netlink_ext_ack *extack)\n{\n\tif (priv_ctx)\n\t\treturn fault_report_show(fmsg, priv_ctx);\n\n\treturn 0;\n}\n\nstatic int mgmt_watchdog_report_show(struct devlink_fmsg *fmsg,\n\t\t\t\t     struct hinic_mgmt_watchdog_info *watchdog_info)\n{\n\tint err;\n\n\terr = devlink_fmsg_u32_pair_put(fmsg, \"Mgmt deadloop time_h\", watchdog_info->curr_time_h);\n\tif (err)\n\t\treturn err;\n\n\terr = devlink_fmsg_u32_pair_put(fmsg, \"time_l\", watchdog_info->curr_time_l);\n\tif (err)\n\t\treturn err;\n\n\terr = devlink_fmsg_u32_pair_put(fmsg, \"task_id\", watchdog_info->task_id);\n\tif (err)\n\t\treturn err;\n\n\terr = devlink_fmsg_u32_pair_put(fmsg, \"sp\", watchdog_info->sp);\n\tif (err)\n\t\treturn err;\n\n\terr = devlink_fmsg_u32_pair_put(fmsg, \"stack_current_used\", watchdog_info->curr_used);\n\tif (err)\n\t\treturn err;\n\n\terr = devlink_fmsg_u32_pair_put(fmsg, \"peak_used\", watchdog_info->peak_used);\n\tif (err)\n\t\treturn err;\n\n\terr = devlink_fmsg_u32_pair_put(fmsg, \"\\n Overflow_flag\", watchdog_info->is_overflow);\n\tif (err)\n\t\treturn err;\n\n\terr = devlink_fmsg_u32_pair_put(fmsg, \"stack_top\", watchdog_info->stack_top);\n\tif (err)\n\t\treturn err;\n\n\terr = devlink_fmsg_u32_pair_put(fmsg, \"stack_bottom\", watchdog_info->stack_bottom);\n\tif (err)\n\t\treturn err;\n\n\terr = devlink_fmsg_u32_pair_put(fmsg, \"mgmt_pc\", watchdog_info->pc);\n\tif (err)\n\t\treturn err;\n\n\terr = devlink_fmsg_u32_pair_put(fmsg, \"lr\", watchdog_info->lr);\n\tif (err)\n\t\treturn err;\n\n\terr = devlink_fmsg_u32_pair_put(fmsg, \"cpsr\", watchdog_info->cpsr);\n\tif (err)\n\t\treturn err;\n\n\terr = devlink_fmsg_binary_pair_put(fmsg, \"Mgmt register info\",\n\t\t\t\t\t   watchdog_info->reg, sizeof(watchdog_info->reg));\n\tif (err)\n\t\treturn err;\n\n\terr = devlink_fmsg_binary_pair_put(fmsg, \"Mgmt dump stack(start from sp)\",\n\t\t\t\t\t   watchdog_info->data, sizeof(watchdog_info->data));\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic int hinic_fw_reporter_dump(struct devlink_health_reporter *reporter,\n\t\t\t\t  struct devlink_fmsg *fmsg, void *priv_ctx,\n\t\t\t\t  struct netlink_ext_ack *extack)\n{\n\tif (priv_ctx)\n\t\treturn mgmt_watchdog_report_show(fmsg, priv_ctx);\n\n\treturn 0;\n}\n\nstatic const struct devlink_health_reporter_ops hinic_hw_fault_reporter_ops = {\n\t.name = \"hw\",\n\t.dump = hinic_hw_reporter_dump,\n};\n\nstatic const struct devlink_health_reporter_ops hinic_fw_fault_reporter_ops = {\n\t.name = \"fw\",\n\t.dump = hinic_fw_reporter_dump,\n};\n\nint hinic_health_reporters_create(struct hinic_devlink_priv *priv)\n{\n\tstruct devlink *devlink = priv_to_devlink(priv);\n\n\tpriv->hw_fault_reporter =\n\t\tdevlink_health_reporter_create(devlink, &hinic_hw_fault_reporter_ops,\n\t\t\t\t\t       0, priv);\n\tif (IS_ERR(priv->hw_fault_reporter)) {\n\t\tdev_warn(&priv->hwdev->hwif->pdev->dev, \"Failed to create hw fault reporter, err: %ld\\n\",\n\t\t\t PTR_ERR(priv->hw_fault_reporter));\n\t\treturn PTR_ERR(priv->hw_fault_reporter);\n\t}\n\n\tpriv->fw_fault_reporter =\n\t\tdevlink_health_reporter_create(devlink, &hinic_fw_fault_reporter_ops,\n\t\t\t\t\t       0, priv);\n\tif (IS_ERR(priv->fw_fault_reporter)) {\n\t\tdev_warn(&priv->hwdev->hwif->pdev->dev, \"Failed to create fw fault reporter, err: %ld\\n\",\n\t\t\t PTR_ERR(priv->fw_fault_reporter));\n\t\tdevlink_health_reporter_destroy(priv->hw_fault_reporter);\n\t\tpriv->hw_fault_reporter = NULL;\n\t\treturn PTR_ERR(priv->fw_fault_reporter);\n\t}\n\n\treturn 0;\n}\n\nvoid hinic_health_reporters_destroy(struct hinic_devlink_priv *priv)\n{\n\tif (!IS_ERR_OR_NULL(priv->fw_fault_reporter)) {\n\t\tdevlink_health_reporter_destroy(priv->fw_fault_reporter);\n\t\tpriv->fw_fault_reporter = NULL;\n\t}\n\n\tif (!IS_ERR_OR_NULL(priv->hw_fault_reporter)) {\n\t\tdevlink_health_reporter_destroy(priv->hw_fault_reporter);\n\t\tpriv->hw_fault_reporter = NULL;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}