{
  "module_name": "hinic_debugfs.c",
  "hash_id": "4d8d8e2c40aa91643d22a712ce67126e669df696c75c09bcbbbc657d07e435f0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/huawei/hinic/hinic_debugfs.c",
  "human_readable_source": "\n \n\n#include <linux/debugfs.h>\n#include <linux/device.h>\n\n#include \"hinic_debugfs.h\"\n\nstatic struct dentry *hinic_dbgfs_root;\n\nenum sq_dbg_info {\n\tGLB_SQ_ID,\n\tSQ_PI,\n\tSQ_CI,\n\tSQ_FI,\n\tSQ_MSIX_ENTRY,\n};\n\nstatic char *sq_fields[] = {\"glb_sq_id\", \"sq_pi\", \"sq_ci\", \"sq_fi\", \"sq_msix_entry\"};\n\nstatic u64 hinic_dbg_get_sq_info(struct hinic_dev *nic_dev, struct hinic_sq *sq, int idx)\n{\n\tstruct hinic_wq *wq = sq->wq;\n\n\tswitch (idx) {\n\tcase GLB_SQ_ID:\n\t\treturn nic_dev->hwdev->func_to_io.global_qpn + sq->qid;\n\tcase SQ_PI:\n\t\treturn atomic_read(&wq->prod_idx) & wq->mask;\n\tcase SQ_CI:\n\t\treturn atomic_read(&wq->cons_idx) & wq->mask;\n\tcase SQ_FI:\n\t\treturn be16_to_cpu(*(__be16 *)(sq->hw_ci_addr)) & wq->mask;\n\tcase SQ_MSIX_ENTRY:\n\t\treturn sq->msix_entry;\n\t}\n\n\treturn 0;\n}\n\nenum rq_dbg_info {\n\tGLB_RQ_ID,\n\tRQ_HW_PI,\n\tRQ_SW_CI,\n\tRQ_SW_PI,\n\tRQ_MSIX_ENTRY,\n};\n\nstatic char *rq_fields[] = {\"glb_rq_id\", \"rq_hw_pi\", \"rq_sw_ci\", \"rq_sw_pi\", \"rq_msix_entry\"};\n\nstatic u64 hinic_dbg_get_rq_info(struct hinic_dev *nic_dev, struct hinic_rq *rq, int idx)\n{\n\tstruct hinic_wq *wq = rq->wq;\n\n\tswitch (idx) {\n\tcase GLB_RQ_ID:\n\t\treturn nic_dev->hwdev->func_to_io.global_qpn + rq->qid;\n\tcase RQ_HW_PI:\n\t\treturn be16_to_cpu(*(__be16 *)(rq->pi_virt_addr)) & wq->mask;\n\tcase RQ_SW_CI:\n\t\treturn atomic_read(&wq->cons_idx) & wq->mask;\n\tcase RQ_SW_PI:\n\t\treturn atomic_read(&wq->prod_idx) & wq->mask;\n\tcase RQ_MSIX_ENTRY:\n\t\treturn rq->msix_entry;\n\t}\n\n\treturn 0;\n}\n\nenum func_tbl_info {\n\tVALID,\n\tRX_MODE,\n\tMTU,\n\tRQ_DEPTH,\n\tQUEUE_NUM,\n};\n\nstatic char *func_table_fields[] = {\"valid\", \"rx_mode\", \"mtu\", \"rq_depth\", \"cfg_q_num\"};\n\nstatic int hinic_dbg_get_func_table(struct hinic_dev *nic_dev, int idx)\n{\n\tstruct tag_sml_funcfg_tbl *funcfg_table_elem;\n\tstruct hinic_cmd_lt_rd *read_data;\n\tu16 out_size = sizeof(*read_data);\n\tint ret = ~0;\n\tint err;\n\n\tread_data = kzalloc(sizeof(*read_data), GFP_KERNEL);\n\tif (!read_data)\n\t\treturn ~0;\n\n\tread_data->node = TBL_ID_FUNC_CFG_SM_NODE;\n\tread_data->inst = TBL_ID_FUNC_CFG_SM_INST;\n\tread_data->entry_size = HINIC_FUNCTION_CONFIGURE_TABLE_SIZE;\n\tread_data->lt_index = HINIC_HWIF_FUNC_IDX(nic_dev->hwdev->hwif);\n\tread_data->len = HINIC_FUNCTION_CONFIGURE_TABLE_SIZE;\n\n\terr = hinic_port_msg_cmd(nic_dev->hwdev, HINIC_PORT_CMD_RD_LINE_TBL, read_data,\n\t\t\t\t sizeof(*read_data), read_data, &out_size);\n\tif (err || out_size != sizeof(*read_data) || read_data->status) {\n\t\tnetif_err(nic_dev, drv, nic_dev->netdev,\n\t\t\t  \"Failed to get func table, err: %d, status: 0x%x, out size: 0x%x\\n\",\n\t\t\t  err, read_data->status, out_size);\n\t\tkfree(read_data);\n\t\treturn ~0;\n\t}\n\n\tfuncfg_table_elem = (struct tag_sml_funcfg_tbl *)read_data->data;\n\n\tswitch (idx) {\n\tcase VALID:\n\t\tret = funcfg_table_elem->dw0.bs.valid;\n\t\tbreak;\n\tcase RX_MODE:\n\t\tret = funcfg_table_elem->dw0.bs.nic_rx_mode;\n\t\tbreak;\n\tcase MTU:\n\t\tret = funcfg_table_elem->dw1.bs.mtu;\n\t\tbreak;\n\tcase RQ_DEPTH:\n\t\tret = funcfg_table_elem->dw13.bs.cfg_rq_depth;\n\t\tbreak;\n\tcase QUEUE_NUM:\n\t\tret = funcfg_table_elem->dw13.bs.cfg_q_num;\n\t\tbreak;\n\t}\n\n\tkfree(read_data);\n\n\treturn ret;\n}\n\nstatic ssize_t hinic_dbg_cmd_read(struct file *filp, char __user *buffer, size_t count,\n\t\t\t\t  loff_t *ppos)\n{\n\tstruct hinic_debug_priv *dbg;\n\tchar ret_buf[20];\n\tint *desc;\n\tu64 out;\n\tint ret;\n\n\tdesc = filp->private_data;\n\tdbg = container_of(desc, struct hinic_debug_priv, field_id[*desc]);\n\n\tswitch (dbg->type) {\n\tcase HINIC_DBG_SQ_INFO:\n\t\tout = hinic_dbg_get_sq_info(dbg->dev, dbg->object, *desc);\n\t\tbreak;\n\n\tcase HINIC_DBG_RQ_INFO:\n\t\tout = hinic_dbg_get_rq_info(dbg->dev, dbg->object, *desc);\n\t\tbreak;\n\n\tcase HINIC_DBG_FUNC_TABLE:\n\t\tout = hinic_dbg_get_func_table(dbg->dev, *desc);\n\t\tbreak;\n\n\tdefault:\n\t\tnetif_warn(dbg->dev, drv, dbg->dev->netdev, \"Invalid hinic debug cmd: %d\\n\",\n\t\t\t   dbg->type);\n\t\treturn -EINVAL;\n\t}\n\n\tret = snprintf(ret_buf, sizeof(ret_buf), \"0x%llx\\n\", out);\n\n\treturn simple_read_from_buffer(buffer, count, ppos, ret_buf, ret);\n}\n\nstatic const struct file_operations hinic_dbg_cmd_fops = {\n\t.owner = THIS_MODULE,\n\t.open  = simple_open,\n\t.read  = hinic_dbg_cmd_read,\n};\n\nstatic int create_dbg_files(struct hinic_dev *dev, enum hinic_dbg_type type, void *data,\n\t\t\t    struct dentry *root, struct hinic_debug_priv **dbg, char **field,\n\t\t\t    int nfile)\n{\n\tstruct hinic_debug_priv *tmp;\n\tint i;\n\n\ttmp = kzalloc(sizeof(*tmp), GFP_KERNEL);\n\tif (!tmp)\n\t\treturn -ENOMEM;\n\n\ttmp->dev = dev;\n\ttmp->object = data;\n\ttmp->type = type;\n\ttmp->root = root;\n\n\tfor (i = 0; i < nfile; i++) {\n\t\ttmp->field_id[i] = i;\n\t\tdebugfs_create_file(field[i], 0400, root, &tmp->field_id[i], &hinic_dbg_cmd_fops);\n\t}\n\n\t*dbg = tmp;\n\n\treturn 0;\n}\n\nstatic void rem_dbg_files(struct hinic_debug_priv *dbg)\n{\n\tif (dbg->type != HINIC_DBG_FUNC_TABLE)\n\t\tdebugfs_remove_recursive(dbg->root);\n\n\tkfree(dbg);\n}\n\nint hinic_sq_debug_add(struct hinic_dev *dev, u16 sq_id)\n{\n\tstruct hinic_sq *sq;\n\tstruct dentry *root;\n\tchar sub_dir[16];\n\n\tsq = dev->txqs[sq_id].sq;\n\n\tsprintf(sub_dir, \"0x%x\", sq_id);\n\n\troot = debugfs_create_dir(sub_dir, dev->sq_dbgfs);\n\n\treturn create_dbg_files(dev, HINIC_DBG_SQ_INFO, sq, root, &sq->dbg, sq_fields,\n\t\t\t\tARRAY_SIZE(sq_fields));\n}\n\nvoid hinic_sq_debug_rem(struct hinic_sq *sq)\n{\n\tif (sq->dbg)\n\t\trem_dbg_files(sq->dbg);\n}\n\nint hinic_rq_debug_add(struct hinic_dev *dev, u16 rq_id)\n{\n\tstruct hinic_rq *rq;\n\tstruct dentry *root;\n\tchar sub_dir[16];\n\n\trq = dev->rxqs[rq_id].rq;\n\n\tsprintf(sub_dir, \"0x%x\", rq_id);\n\n\troot = debugfs_create_dir(sub_dir, dev->rq_dbgfs);\n\n\treturn create_dbg_files(dev, HINIC_DBG_RQ_INFO, rq, root, &rq->dbg, rq_fields,\n\t\t\t\tARRAY_SIZE(rq_fields));\n}\n\nvoid hinic_rq_debug_rem(struct hinic_rq *rq)\n{\n\tif (rq->dbg)\n\t\trem_dbg_files(rq->dbg);\n}\n\nint hinic_func_table_debug_add(struct hinic_dev *dev)\n{\n\tif (HINIC_IS_VF(dev->hwdev->hwif))\n\t\treturn 0;\n\n\treturn create_dbg_files(dev, HINIC_DBG_FUNC_TABLE, dev, dev->func_tbl_dbgfs, &dev->dbg,\n\t\t\t\tfunc_table_fields, ARRAY_SIZE(func_table_fields));\n}\n\nvoid hinic_func_table_debug_rem(struct hinic_dev *dev)\n{\n\tif (!HINIC_IS_VF(dev->hwdev->hwif) && dev->dbg)\n\t\trem_dbg_files(dev->dbg);\n}\n\nvoid hinic_sq_dbgfs_init(struct hinic_dev *nic_dev)\n{\n\tnic_dev->sq_dbgfs = debugfs_create_dir(\"SQs\", nic_dev->dbgfs_root);\n}\n\nvoid hinic_sq_dbgfs_uninit(struct hinic_dev *nic_dev)\n{\n\tdebugfs_remove_recursive(nic_dev->sq_dbgfs);\n}\n\nvoid hinic_rq_dbgfs_init(struct hinic_dev *nic_dev)\n{\n\tnic_dev->rq_dbgfs = debugfs_create_dir(\"RQs\", nic_dev->dbgfs_root);\n}\n\nvoid hinic_rq_dbgfs_uninit(struct hinic_dev *nic_dev)\n{\n\tdebugfs_remove_recursive(nic_dev->rq_dbgfs);\n}\n\nvoid hinic_func_tbl_dbgfs_init(struct hinic_dev *nic_dev)\n{\n\tif (!HINIC_IS_VF(nic_dev->hwdev->hwif))\n\t\tnic_dev->func_tbl_dbgfs = debugfs_create_dir(\"func_table\", nic_dev->dbgfs_root);\n}\n\nvoid hinic_func_tbl_dbgfs_uninit(struct hinic_dev *nic_dev)\n{\n\tif (!HINIC_IS_VF(nic_dev->hwdev->hwif))\n\t\tdebugfs_remove_recursive(nic_dev->func_tbl_dbgfs);\n}\n\nvoid hinic_dbg_init(struct hinic_dev *nic_dev)\n{\n\tnic_dev->dbgfs_root = debugfs_create_dir(pci_name(nic_dev->hwdev->hwif->pdev),\n\t\t\t\t\t\t hinic_dbgfs_root);\n}\n\nvoid hinic_dbg_uninit(struct hinic_dev *nic_dev)\n{\n\tdebugfs_remove_recursive(nic_dev->dbgfs_root);\n\tnic_dev->dbgfs_root = NULL;\n}\n\nvoid hinic_dbg_register_debugfs(const char *debugfs_dir_name)\n{\n\thinic_dbgfs_root = debugfs_create_dir(debugfs_dir_name, NULL);\n}\n\nvoid hinic_dbg_unregister_debugfs(void)\n{\n\tdebugfs_remove_recursive(hinic_dbgfs_root);\n\thinic_dbgfs_root = NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}