{
  "module_name": "hinic_port.c",
  "hash_id": "298f61fbc03eb6d50e5619dd3263676e7c8f9f8911a55a511cb1b3a67976a03a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/huawei/hinic/hinic_port.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/if_vlan.h>\n#include <linux/pci.h>\n#include <linux/device.h>\n#include <linux/errno.h>\n\n#include \"hinic_hw_if.h\"\n#include \"hinic_hw_dev.h\"\n#include \"hinic_port.h\"\n#include \"hinic_dev.h\"\n\nenum mac_op {\n\tMAC_DEL,\n\tMAC_SET,\n};\n\n \nstatic int change_mac(struct hinic_dev *nic_dev, const u8 *addr,\n\t\t      u16 vlan_id, enum mac_op op)\n{\n\tstruct hinic_hwdev *hwdev = nic_dev->hwdev;\n\tstruct hinic_port_mac_cmd port_mac_cmd;\n\tstruct hinic_hwif *hwif = hwdev->hwif;\n\tu16 out_size = sizeof(port_mac_cmd);\n\tstruct pci_dev *pdev = hwif->pdev;\n\tenum hinic_port_cmd cmd;\n\tint err;\n\n\tif (op == MAC_SET)\n\t\tcmd = HINIC_PORT_CMD_SET_MAC;\n\telse\n\t\tcmd = HINIC_PORT_CMD_DEL_MAC;\n\n\tport_mac_cmd.func_idx = HINIC_HWIF_FUNC_IDX(hwif);\n\tport_mac_cmd.vlan_id = vlan_id;\n\tmemcpy(port_mac_cmd.mac, addr, ETH_ALEN);\n\n\terr = hinic_port_msg_cmd(hwdev, cmd, &port_mac_cmd,\n\t\t\t\t sizeof(port_mac_cmd),\n\t\t\t\t &port_mac_cmd, &out_size);\n\tif (err || out_size != sizeof(port_mac_cmd) ||\n\t    (port_mac_cmd.status &&\n\t     (port_mac_cmd.status != HINIC_PF_SET_VF_ALREADY || !HINIC_IS_VF(hwif)) &&\n\t     port_mac_cmd.status != HINIC_MGMT_STATUS_EXIST)) {\n\t\tdev_err(&pdev->dev, \"Failed to change MAC, err: %d, status: 0x%x, out size: 0x%x\\n\",\n\t\t\terr, port_mac_cmd.status, out_size);\n\t\treturn -EFAULT;\n\t}\n\n\tif (port_mac_cmd.status == HINIC_PF_SET_VF_ALREADY) {\n\t\tdev_warn(&pdev->dev, \"PF has already set VF mac, ignore %s operation\\n\",\n\t\t\t (op == MAC_SET) ? \"set\" : \"del\");\n\t\treturn HINIC_PF_SET_VF_ALREADY;\n\t}\n\n\tif (cmd == HINIC_PORT_CMD_SET_MAC && port_mac_cmd.status ==\n\t    HINIC_MGMT_STATUS_EXIST)\n\t\tdev_warn(&pdev->dev, \"MAC is repeated, ignore set operation\\n\");\n\n\treturn 0;\n}\n\n \nint hinic_port_add_mac(struct hinic_dev *nic_dev,\n\t\t       const u8 *addr, u16 vlan_id)\n{\n\treturn change_mac(nic_dev, addr, vlan_id, MAC_SET);\n}\n\n \nint hinic_port_del_mac(struct hinic_dev *nic_dev, const u8 *addr,\n\t\t       u16 vlan_id)\n{\n\treturn change_mac(nic_dev, addr, vlan_id, MAC_DEL);\n}\n\n \nint hinic_port_get_mac(struct hinic_dev *nic_dev, u8 *addr)\n{\n\tstruct hinic_hwdev *hwdev = nic_dev->hwdev;\n\tstruct hinic_port_mac_cmd port_mac_cmd;\n\tstruct hinic_hwif *hwif = hwdev->hwif;\n\tu16 out_size = sizeof(port_mac_cmd);\n\tstruct pci_dev *pdev = hwif->pdev;\n\tint err;\n\n\tport_mac_cmd.func_idx = HINIC_HWIF_FUNC_IDX(hwif);\n\n\terr = hinic_port_msg_cmd(hwdev, HINIC_PORT_CMD_GET_MAC,\n\t\t\t\t &port_mac_cmd, sizeof(port_mac_cmd),\n\t\t\t\t &port_mac_cmd, &out_size);\n\tif (err || out_size != sizeof(port_mac_cmd) || port_mac_cmd.status) {\n\t\tdev_err(&pdev->dev, \"Failed to get mac, err: %d, status: 0x%x, out size: 0x%x\\n\",\n\t\t\terr, port_mac_cmd.status, out_size);\n\t\treturn -EFAULT;\n\t}\n\n\tmemcpy(addr, port_mac_cmd.mac, ETH_ALEN);\n\treturn 0;\n}\n\n \nint hinic_port_set_mtu(struct hinic_dev *nic_dev, int new_mtu)\n{\n\tstruct hinic_hwdev *hwdev = nic_dev->hwdev;\n\tstruct hinic_port_mtu_cmd port_mtu_cmd;\n\tstruct hinic_hwif *hwif = hwdev->hwif;\n\tu16 out_size = sizeof(port_mtu_cmd);\n\tstruct pci_dev *pdev = hwif->pdev;\n\tint err;\n\n\tport_mtu_cmd.func_idx = HINIC_HWIF_FUNC_IDX(hwif);\n\tport_mtu_cmd.mtu = new_mtu;\n\n\terr = hinic_port_msg_cmd(hwdev, HINIC_PORT_CMD_CHANGE_MTU,\n\t\t\t\t &port_mtu_cmd, sizeof(port_mtu_cmd),\n\t\t\t\t &port_mtu_cmd, &out_size);\n\tif (err || out_size != sizeof(port_mtu_cmd) || port_mtu_cmd.status) {\n\t\tdev_err(&pdev->dev, \"Failed to set mtu, err: %d, status: 0x%x, out size: 0x%x\\n\",\n\t\t\terr, port_mtu_cmd.status, out_size);\n\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n}\n\n \nint hinic_port_add_vlan(struct hinic_dev *nic_dev, u16 vlan_id)\n{\n\tstruct hinic_hwdev *hwdev = nic_dev->hwdev;\n\tstruct hinic_port_vlan_cmd port_vlan_cmd;\n\n\tport_vlan_cmd.func_idx = HINIC_HWIF_FUNC_IDX(hwdev->hwif);\n\tport_vlan_cmd.vlan_id = vlan_id;\n\n\treturn hinic_port_msg_cmd(hwdev, HINIC_PORT_CMD_ADD_VLAN,\n\t\t\t\t  &port_vlan_cmd, sizeof(port_vlan_cmd),\n\t\t\t\t  NULL, NULL);\n}\n\n \nint hinic_port_del_vlan(struct hinic_dev *nic_dev, u16 vlan_id)\n{\n\tstruct hinic_hwdev *hwdev = nic_dev->hwdev;\n\tstruct hinic_port_vlan_cmd port_vlan_cmd;\n\n\tport_vlan_cmd.func_idx = HINIC_HWIF_FUNC_IDX(hwdev->hwif);\n\tport_vlan_cmd.vlan_id = vlan_id;\n\n\treturn hinic_port_msg_cmd(hwdev, HINIC_PORT_CMD_DEL_VLAN,\n\t\t\t\t &port_vlan_cmd, sizeof(port_vlan_cmd),\n\t\t\t\t NULL, NULL);\n}\n\n \nint hinic_port_set_rx_mode(struct hinic_dev *nic_dev, u32 rx_mode)\n{\n\tstruct hinic_hwdev *hwdev = nic_dev->hwdev;\n\tstruct hinic_port_rx_mode_cmd rx_mode_cmd;\n\n\trx_mode_cmd.func_idx = HINIC_HWIF_FUNC_IDX(hwdev->hwif);\n\trx_mode_cmd.rx_mode = rx_mode;\n\n\treturn hinic_port_msg_cmd(hwdev, HINIC_PORT_CMD_SET_RX_MODE,\n\t\t\t\t  &rx_mode_cmd, sizeof(rx_mode_cmd),\n\t\t\t\t  NULL, NULL);\n}\n\n \nint hinic_port_link_state(struct hinic_dev *nic_dev,\n\t\t\t  enum hinic_port_link_state *link_state)\n{\n\tstruct hinic_hwdev *hwdev = nic_dev->hwdev;\n\tstruct hinic_hwif *hwif = hwdev->hwif;\n\tstruct hinic_port_link_cmd link_cmd;\n\tstruct pci_dev *pdev = hwif->pdev;\n\tu16 out_size = sizeof(link_cmd);\n\tint err;\n\n\tlink_cmd.func_idx = HINIC_HWIF_FUNC_IDX(hwif);\n\n\terr = hinic_port_msg_cmd(hwdev, HINIC_PORT_CMD_GET_LINK_STATE,\n\t\t\t\t &link_cmd, sizeof(link_cmd),\n\t\t\t\t &link_cmd, &out_size);\n\tif (err || out_size != sizeof(link_cmd) || link_cmd.status) {\n\t\tdev_err(&pdev->dev, \"Failed to get link state, err: %d, status: 0x%x, out size: 0x%x\\n\",\n\t\t\terr, link_cmd.status, out_size);\n\t\treturn -EINVAL;\n\t}\n\n\t*link_state = link_cmd.state;\n\treturn 0;\n}\n\n \nint hinic_port_set_state(struct hinic_dev *nic_dev, enum hinic_port_state state)\n{\n\tstruct hinic_hwdev *hwdev = nic_dev->hwdev;\n\tstruct hinic_port_state_cmd port_state;\n\tstruct hinic_hwif *hwif = hwdev->hwif;\n\tstruct pci_dev *pdev = hwif->pdev;\n\tu16 out_size = sizeof(port_state);\n\tint err;\n\n\tif (HINIC_IS_VF(hwdev->hwif))\n\t\treturn 0;\n\n\tport_state.state = state;\n\n\terr = hinic_port_msg_cmd(hwdev, HINIC_PORT_CMD_SET_PORT_STATE,\n\t\t\t\t &port_state, sizeof(port_state),\n\t\t\t\t &port_state, &out_size);\n\tif (err || out_size != sizeof(port_state) || port_state.status) {\n\t\tdev_err(&pdev->dev, \"Failed to set port state, err: %d, status: 0x%x, out size: 0x%x\\n\",\n\t\t\terr, port_state.status, out_size);\n\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n}\n\n \nint hinic_port_set_func_state(struct hinic_dev *nic_dev,\n\t\t\t      enum hinic_func_port_state state)\n{\n\tstruct hinic_port_func_state_cmd func_state;\n\tstruct hinic_hwdev *hwdev = nic_dev->hwdev;\n\tstruct hinic_hwif *hwif = hwdev->hwif;\n\tstruct pci_dev *pdev = hwif->pdev;\n\tu16 out_size = sizeof(func_state);\n\tint err;\n\n\tfunc_state.func_idx = HINIC_HWIF_FUNC_IDX(hwif);\n\tfunc_state.state = state;\n\n\terr = hinic_port_msg_cmd(hwdev, HINIC_PORT_CMD_SET_FUNC_STATE,\n\t\t\t\t &func_state, sizeof(func_state),\n\t\t\t\t &func_state, &out_size);\n\tif (err || out_size != sizeof(func_state) || func_state.status) {\n\t\tdev_err(&pdev->dev, \"Failed to set port func state, err: %d, status: 0x%x, out size: 0x%x\\n\",\n\t\t\terr, func_state.status, out_size);\n\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n}\n\n \nint hinic_port_get_cap(struct hinic_dev *nic_dev,\n\t\t       struct hinic_port_cap *port_cap)\n{\n\tstruct hinic_hwdev *hwdev = nic_dev->hwdev;\n\tstruct hinic_hwif *hwif = hwdev->hwif;\n\tstruct pci_dev *pdev = hwif->pdev;\n\tu16 out_size = sizeof(*port_cap);\n\tint err;\n\n\tport_cap->func_idx = HINIC_HWIF_FUNC_IDX(hwif);\n\n\terr = hinic_port_msg_cmd(hwdev, HINIC_PORT_CMD_GET_CAP,\n\t\t\t\t port_cap, sizeof(*port_cap),\n\t\t\t\t port_cap, &out_size);\n\tif (err || out_size != sizeof(*port_cap) || port_cap->status) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Failed to get port capabilities, err: %d, status: 0x%x, out size: 0x%x\\n\",\n\t\t\terr, port_cap->status, out_size);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\n \nint hinic_port_set_tso(struct hinic_dev *nic_dev, enum hinic_tso_state state)\n{\n\tstruct hinic_hwdev *hwdev = nic_dev->hwdev;\n\tstruct hinic_hwif *hwif = hwdev->hwif;\n\tstruct hinic_tso_config tso_cfg = {0};\n\tstruct pci_dev *pdev = hwif->pdev;\n\tu16 out_size = sizeof(tso_cfg);\n\tint err;\n\n\ttso_cfg.func_id = HINIC_HWIF_FUNC_IDX(hwif);\n\ttso_cfg.tso_en = state;\n\n\terr = hinic_port_msg_cmd(hwdev, HINIC_PORT_CMD_SET_TSO,\n\t\t\t\t &tso_cfg, sizeof(tso_cfg),\n\t\t\t\t &tso_cfg, &out_size);\n\tif (err || out_size != sizeof(tso_cfg) || tso_cfg.status) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Failed to set port tso, err: %d, status: 0x%x, out size: 0x%x\\n\",\n\t\t\terr, tso_cfg.status, out_size);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nint hinic_set_rx_csum_offload(struct hinic_dev *nic_dev, u32 en)\n{\n\tstruct hinic_checksum_offload rx_csum_cfg = {0};\n\tstruct hinic_hwdev *hwdev = nic_dev->hwdev;\n\tu16 out_size = sizeof(rx_csum_cfg);\n\tstruct hinic_hwif *hwif;\n\tstruct pci_dev *pdev;\n\tint err;\n\n\tif (!hwdev)\n\t\treturn -EINVAL;\n\n\thwif = hwdev->hwif;\n\tpdev = hwif->pdev;\n\trx_csum_cfg.func_id = HINIC_HWIF_FUNC_IDX(hwif);\n\trx_csum_cfg.rx_csum_offload = en;\n\n\terr = hinic_port_msg_cmd(hwdev, HINIC_PORT_CMD_SET_RX_CSUM,\n\t\t\t\t &rx_csum_cfg, sizeof(rx_csum_cfg),\n\t\t\t\t &rx_csum_cfg, &out_size);\n\tif (err || !out_size || rx_csum_cfg.status) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Failed to set rx csum offload, err: %d, status: 0x%x, out size: 0x%x\\n\",\n\t\t\terr, rx_csum_cfg.status, out_size);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nint hinic_set_rx_vlan_offload(struct hinic_dev *nic_dev, u8 en)\n{\n\tstruct hinic_hwdev *hwdev = nic_dev->hwdev;\n\tstruct hinic_vlan_cfg vlan_cfg;\n\tstruct hinic_hwif *hwif;\n\tstruct pci_dev *pdev;\n\tu16 out_size;\n\tint err;\n\n\tif (!hwdev)\n\t\treturn -EINVAL;\n\n\tout_size = sizeof(vlan_cfg);\n\thwif = hwdev->hwif;\n\tpdev = hwif->pdev;\n\tvlan_cfg.func_id = HINIC_HWIF_FUNC_IDX(hwif);\n\tvlan_cfg.vlan_rx_offload = en;\n\n\terr = hinic_port_msg_cmd(hwdev, HINIC_PORT_CMD_SET_RX_VLAN_OFFLOAD,\n\t\t\t\t &vlan_cfg, sizeof(vlan_cfg),\n\t\t\t\t &vlan_cfg, &out_size);\n\tif (err || !out_size || vlan_cfg.status) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Failed to set rx vlan offload, err: %d, status: 0x%x, out size: 0x%x\\n\",\n\t\t\terr, vlan_cfg.status, out_size);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nint hinic_set_vlan_fliter(struct hinic_dev *nic_dev, u32 en)\n{\n\tstruct hinic_hwdev *hwdev = nic_dev->hwdev;\n\tstruct hinic_hwif *hwif = hwdev->hwif;\n\tstruct pci_dev *pdev = hwif->pdev;\n\tstruct hinic_vlan_filter vlan_filter;\n\tu16 out_size = sizeof(vlan_filter);\n\tint err;\n\n\tvlan_filter.func_idx = HINIC_HWIF_FUNC_IDX(hwif);\n\tvlan_filter.enable = en;\n\n\terr = hinic_port_msg_cmd(hwdev, HINIC_PORT_CMD_SET_VLAN_FILTER,\n\t\t\t\t &vlan_filter, sizeof(vlan_filter),\n\t\t\t\t &vlan_filter, &out_size);\n\tif (vlan_filter.status == HINIC_MGMT_CMD_UNSUPPORTED) {\n\t\terr = HINIC_MGMT_CMD_UNSUPPORTED;\n\t} else if ((err == HINIC_MBOX_VF_CMD_ERROR) &&\n\t\t\t   HINIC_IS_VF(hwif)) {\n\t\terr = HINIC_MGMT_CMD_UNSUPPORTED;\n\t} else if (err || !out_size || vlan_filter.status) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Failed to set vlan fliter, err: %d, status: 0x%x, out size: 0x%x\\n\",\n\t\t\terr, vlan_filter.status, out_size);\n\t\terr = -EINVAL;\n\t}\n\n\treturn err;\n}\n\nint hinic_set_max_qnum(struct hinic_dev *nic_dev, u8 num_rqs)\n{\n\tstruct hinic_hwdev *hwdev = nic_dev->hwdev;\n\tstruct hinic_hwif *hwif = hwdev->hwif;\n\tstruct hinic_rq_num rq_num = { 0 };\n\tstruct pci_dev *pdev = hwif->pdev;\n\tu16 out_size = sizeof(rq_num);\n\tint err;\n\n\trq_num.func_id = HINIC_HWIF_FUNC_IDX(hwif);\n\trq_num.num_rqs = num_rqs;\n\trq_num.rq_depth = ilog2(nic_dev->rq_depth);\n\n\terr = hinic_port_msg_cmd(hwdev, HINIC_PORT_CMD_SET_RQ_IQ_MAP,\n\t\t\t\t &rq_num, sizeof(rq_num),\n\t\t\t\t &rq_num, &out_size);\n\tif (err || !out_size || rq_num.status) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Failed to set rxq number, err: %d, status: 0x%x, out size: 0x%x\\n\",\n\t\t\terr, rq_num.status, out_size);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int hinic_set_rx_lro(struct hinic_dev *nic_dev, u8 ipv4_en, u8 ipv6_en,\n\t\t\t    u8 max_wqe_num)\n{\n\tstruct hinic_hwdev *hwdev = nic_dev->hwdev;\n\tstruct hinic_lro_config lro_cfg = { 0 };\n\tstruct hinic_hwif *hwif = hwdev->hwif;\n\tstruct pci_dev *pdev = hwif->pdev;\n\tu16 out_size = sizeof(lro_cfg);\n\tint err;\n\n\tlro_cfg.func_id = HINIC_HWIF_FUNC_IDX(hwif);\n\tlro_cfg.lro_ipv4_en = ipv4_en;\n\tlro_cfg.lro_ipv6_en = ipv6_en;\n\tlro_cfg.lro_max_wqe_num = max_wqe_num;\n\n\terr = hinic_port_msg_cmd(hwdev, HINIC_PORT_CMD_SET_LRO,\n\t\t\t\t &lro_cfg, sizeof(lro_cfg),\n\t\t\t\t &lro_cfg, &out_size);\n\tif (err || !out_size || lro_cfg.status) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Failed to set lro offload, err: %d, status: 0x%x, out size: 0x%x\\n\",\n\t\t\terr, lro_cfg.status, out_size);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int hinic_set_rx_lro_timer(struct hinic_dev *nic_dev, u32 timer_value)\n{\n\tstruct hinic_hwdev *hwdev = nic_dev->hwdev;\n\tstruct hinic_lro_timer lro_timer = { 0 };\n\tstruct hinic_hwif *hwif = hwdev->hwif;\n\tstruct pci_dev *pdev = hwif->pdev;\n\tu16 out_size = sizeof(lro_timer);\n\tint err;\n\n\tlro_timer.status = 0;\n\tlro_timer.type = 0;\n\tlro_timer.enable = 1;\n\tlro_timer.timer = timer_value;\n\n\terr = hinic_port_msg_cmd(hwdev, HINIC_PORT_CMD_SET_LRO_TIMER,\n\t\t\t\t &lro_timer, sizeof(lro_timer),\n\t\t\t\t &lro_timer, &out_size);\n\tif (lro_timer.status == 0xFF) {\n\t\t \n\t\tlro_timer.status = 0;\n\t\tdev_dbg(&pdev->dev,\n\t\t\t\"Set lro timer not supported by the current FW version, it will be 1ms default\\n\");\n\t}\n\n\tif (err || !out_size || lro_timer.status) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Failed to set lro timer, err: %d, status: 0x%x, out size: 0x%x\\n\",\n\t\t\terr, lro_timer.status, out_size);\n\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nint hinic_set_rx_lro_state(struct hinic_dev *nic_dev, u8 lro_en,\n\t\t\t   u32 lro_timer, u32 wqe_num)\n{\n\tstruct hinic_hwdev *hwdev = nic_dev->hwdev;\n\tu8 ipv4_en;\n\tu8 ipv6_en;\n\tint err;\n\n\tif (!hwdev)\n\t\treturn -EINVAL;\n\n\tipv4_en = lro_en ? 1 : 0;\n\tipv6_en = lro_en ? 1 : 0;\n\n\terr = hinic_set_rx_lro(nic_dev, ipv4_en, ipv6_en, (u8)wqe_num);\n\tif (err)\n\t\treturn err;\n\n\tif (HINIC_IS_VF(nic_dev->hwdev->hwif))\n\t\treturn 0;\n\n\terr = hinic_set_rx_lro_timer(nic_dev, lro_timer);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\nint hinic_rss_set_indir_tbl(struct hinic_dev *nic_dev, u32 tmpl_idx,\n\t\t\t    const u32 *indir_table)\n{\n\tstruct hinic_rss_indirect_tbl *indir_tbl;\n\tstruct hinic_func_to_io *func_to_io;\n\tstruct hinic_cmdq_buf cmd_buf;\n\tstruct hinic_hwdev *hwdev;\n\tstruct hinic_hwif *hwif;\n\tstruct pci_dev *pdev;\n\tu32 indir_size;\n\tu64 out_param;\n\tint err, i;\n\tu32 *temp;\n\n\thwdev = nic_dev->hwdev;\n\tfunc_to_io = &hwdev->func_to_io;\n\thwif = hwdev->hwif;\n\tpdev = hwif->pdev;\n\n\terr = hinic_alloc_cmdq_buf(&func_to_io->cmdqs, &cmd_buf);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Failed to allocate cmdq buf\\n\");\n\t\treturn err;\n\t}\n\n\tcmd_buf.size = sizeof(*indir_tbl);\n\n\tindir_tbl = cmd_buf.buf;\n\tindir_tbl->group_index = cpu_to_be32(tmpl_idx);\n\n\tfor (i = 0; i < HINIC_RSS_INDIR_SIZE; i++) {\n\t\tindir_tbl->entry[i] = indir_table[i];\n\n\t\tif (0x3 == (i & 0x3)) {\n\t\t\ttemp = (u32 *)&indir_tbl->entry[i - 3];\n\t\t\t*temp = cpu_to_be32(*temp);\n\t\t}\n\t}\n\n\t \n\tindir_size = HINIC_RSS_INDIR_SIZE / 2;\n\tindir_tbl->offset = 0;\n\tindir_tbl->size = cpu_to_be32(indir_size);\n\n\terr = hinic_cmdq_direct_resp(&func_to_io->cmdqs, HINIC_MOD_L2NIC,\n\t\t\t\t     HINIC_UCODE_CMD_SET_RSS_INDIR_TABLE,\n\t\t\t\t     &cmd_buf, &out_param);\n\tif (err || out_param != 0) {\n\t\tdev_err(&pdev->dev, \"Failed to set rss indir table\\n\");\n\t\terr = -EFAULT;\n\t\tgoto free_buf;\n\t}\n\n\tindir_tbl->offset = cpu_to_be32(indir_size);\n\tindir_tbl->size = cpu_to_be32(indir_size);\n\tmemcpy(&indir_tbl->entry[0], &indir_tbl->entry[indir_size], indir_size);\n\n\terr = hinic_cmdq_direct_resp(&func_to_io->cmdqs, HINIC_MOD_L2NIC,\n\t\t\t\t     HINIC_UCODE_CMD_SET_RSS_INDIR_TABLE,\n\t\t\t\t     &cmd_buf, &out_param);\n\tif (err || out_param != 0) {\n\t\tdev_err(&pdev->dev, \"Failed to set rss indir table\\n\");\n\t\terr = -EFAULT;\n\t}\n\nfree_buf:\n\thinic_free_cmdq_buf(&func_to_io->cmdqs, &cmd_buf);\n\n\treturn err;\n}\n\nint hinic_rss_get_indir_tbl(struct hinic_dev *nic_dev, u32 tmpl_idx,\n\t\t\t    u32 *indir_table)\n{\n\tstruct hinic_rss_indir_table rss_cfg = { 0 };\n\tstruct hinic_hwdev *hwdev = nic_dev->hwdev;\n\tstruct hinic_hwif *hwif = hwdev->hwif;\n\tstruct pci_dev *pdev = hwif->pdev;\n\tu16 out_size = sizeof(rss_cfg);\n\tint err = 0, i;\n\n\trss_cfg.func_id = HINIC_HWIF_FUNC_IDX(hwif);\n\trss_cfg.template_id = tmpl_idx;\n\n\terr = hinic_port_msg_cmd(hwdev,\n\t\t\t\t HINIC_PORT_CMD_GET_RSS_TEMPLATE_INDIR_TBL,\n\t\t\t\t &rss_cfg, sizeof(rss_cfg), &rss_cfg,\n\t\t\t\t &out_size);\n\tif (err || !out_size || rss_cfg.status) {\n\t\tdev_err(&pdev->dev, \"Failed to get indir table, err: %d, status: 0x%x, out size: 0x%x\\n\",\n\t\t\terr, rss_cfg.status, out_size);\n\t\treturn -EINVAL;\n\t}\n\n\thinic_be32_to_cpu(rss_cfg.indir, HINIC_RSS_INDIR_SIZE);\n\tfor (i = 0; i < HINIC_RSS_INDIR_SIZE; i++)\n\t\tindir_table[i] = rss_cfg.indir[i];\n\n\treturn 0;\n}\n\nint hinic_set_rss_type(struct hinic_dev *nic_dev, u32 tmpl_idx,\n\t\t       struct hinic_rss_type rss_type)\n{\n\tstruct hinic_rss_context_tbl *ctx_tbl;\n\tstruct hinic_func_to_io *func_to_io;\n\tstruct hinic_cmdq_buf cmd_buf;\n\tstruct hinic_hwdev *hwdev;\n\tstruct hinic_hwif *hwif;\n\tstruct pci_dev *pdev;\n\tu64 out_param;\n\tu32 ctx = 0;\n\tint err;\n\n\thwdev = nic_dev->hwdev;\n\tfunc_to_io = &hwdev->func_to_io;\n\thwif = hwdev->hwif;\n\tpdev = hwif->pdev;\n\n\terr = hinic_alloc_cmdq_buf(&func_to_io->cmdqs, &cmd_buf);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Failed to allocate cmd buf\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tctx |=  HINIC_RSS_TYPE_SET(1, VALID) |\n\t\tHINIC_RSS_TYPE_SET(rss_type.ipv4, IPV4) |\n\t\tHINIC_RSS_TYPE_SET(rss_type.ipv6, IPV6) |\n\t\tHINIC_RSS_TYPE_SET(rss_type.ipv6_ext, IPV6_EXT) |\n\t\tHINIC_RSS_TYPE_SET(rss_type.tcp_ipv4, TCP_IPV4) |\n\t\tHINIC_RSS_TYPE_SET(rss_type.tcp_ipv6, TCP_IPV6) |\n\t\tHINIC_RSS_TYPE_SET(rss_type.tcp_ipv6_ext, TCP_IPV6_EXT) |\n\t\tHINIC_RSS_TYPE_SET(rss_type.udp_ipv4, UDP_IPV4) |\n\t\tHINIC_RSS_TYPE_SET(rss_type.udp_ipv6, UDP_IPV6);\n\n\tcmd_buf.size = sizeof(struct hinic_rss_context_tbl);\n\n\tctx_tbl = (struct hinic_rss_context_tbl *)cmd_buf.buf;\n\tctx_tbl->group_index = cpu_to_be32(tmpl_idx);\n\tctx_tbl->offset = 0;\n\tctx_tbl->size = sizeof(u32);\n\tctx_tbl->size = cpu_to_be32(ctx_tbl->size);\n\tctx_tbl->rsvd = 0;\n\tctx_tbl->ctx = cpu_to_be32(ctx);\n\n\t \n\terr = hinic_cmdq_direct_resp(&func_to_io->cmdqs, HINIC_MOD_L2NIC,\n\t\t\t\t     HINIC_UCODE_CMD_SET_RSS_CONTEXT_TABLE,\n\t\t\t\t     &cmd_buf, &out_param);\n\n\thinic_free_cmdq_buf(&func_to_io->cmdqs, &cmd_buf);\n\n\tif (err || out_param != 0) {\n\t\tdev_err(&pdev->dev, \"Failed to set rss context table, err: %d\\n\",\n\t\t\terr);\n\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n}\n\nint hinic_get_rss_type(struct hinic_dev *nic_dev, u32 tmpl_idx,\n\t\t       struct hinic_rss_type *rss_type)\n{\n\tstruct hinic_rss_context_table ctx_tbl = { 0 };\n\tstruct hinic_hwdev *hwdev = nic_dev->hwdev;\n\tu16 out_size = sizeof(ctx_tbl);\n\tstruct hinic_hwif *hwif;\n\tstruct pci_dev *pdev;\n\tint err;\n\n\tif (!hwdev || !rss_type)\n\t\treturn -EINVAL;\n\n\thwif = hwdev->hwif;\n\tpdev = hwif->pdev;\n\n\tctx_tbl.func_id = HINIC_HWIF_FUNC_IDX(hwif);\n\tctx_tbl.template_id = tmpl_idx;\n\n\terr = hinic_port_msg_cmd(hwdev, HINIC_PORT_CMD_GET_RSS_CTX_TBL,\n\t\t\t\t &ctx_tbl, sizeof(ctx_tbl),\n\t\t\t\t &ctx_tbl, &out_size);\n\tif (err || !out_size || ctx_tbl.status) {\n\t\tdev_err(&pdev->dev, \"Failed to get hash type, err: %d, status: 0x%x, out size: 0x%x\\n\",\n\t\t\terr, ctx_tbl.status, out_size);\n\t\treturn -EINVAL;\n\t}\n\n\trss_type->ipv4          = HINIC_RSS_TYPE_GET(ctx_tbl.context, IPV4);\n\trss_type->ipv6          = HINIC_RSS_TYPE_GET(ctx_tbl.context, IPV6);\n\trss_type->ipv6_ext      = HINIC_RSS_TYPE_GET(ctx_tbl.context, IPV6_EXT);\n\trss_type->tcp_ipv4      = HINIC_RSS_TYPE_GET(ctx_tbl.context, TCP_IPV4);\n\trss_type->tcp_ipv6      = HINIC_RSS_TYPE_GET(ctx_tbl.context, TCP_IPV6);\n\trss_type->tcp_ipv6_ext  = HINIC_RSS_TYPE_GET(ctx_tbl.context,\n\t\t\t\t\t\t     TCP_IPV6_EXT);\n\trss_type->udp_ipv4      = HINIC_RSS_TYPE_GET(ctx_tbl.context, UDP_IPV4);\n\trss_type->udp_ipv6      = HINIC_RSS_TYPE_GET(ctx_tbl.context, UDP_IPV6);\n\n\treturn 0;\n}\n\nint hinic_rss_set_template_tbl(struct hinic_dev *nic_dev, u32 template_id,\n\t\t\t       const u8 *temp)\n{\n\tstruct hinic_hwdev *hwdev = nic_dev->hwdev;\n\tstruct hinic_hwif *hwif = hwdev->hwif;\n\tstruct hinic_rss_key rss_key = { 0 };\n\tstruct pci_dev *pdev = hwif->pdev;\n\tu16 out_size = sizeof(rss_key);\n\tint err;\n\n\trss_key.func_id = HINIC_HWIF_FUNC_IDX(hwif);\n\trss_key.template_id = template_id;\n\tmemcpy(rss_key.key, temp, HINIC_RSS_KEY_SIZE);\n\n\terr = hinic_port_msg_cmd(hwdev, HINIC_PORT_CMD_SET_RSS_TEMPLATE_TBL,\n\t\t\t\t &rss_key, sizeof(rss_key),\n\t\t\t\t &rss_key, &out_size);\n\tif (err || !out_size || rss_key.status) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Failed to set rss hash key, err: %d, status: 0x%x, out size: 0x%x\\n\",\n\t\t\terr, rss_key.status, out_size);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nint hinic_rss_get_template_tbl(struct hinic_dev *nic_dev, u32 tmpl_idx,\n\t\t\t       u8 *temp)\n{\n\tstruct hinic_rss_template_key temp_key = { 0 };\n\tstruct hinic_hwdev *hwdev = nic_dev->hwdev;\n\tu16 out_size = sizeof(temp_key);\n\tstruct hinic_hwif *hwif;\n\tstruct pci_dev *pdev;\n\tint err;\n\n\tif (!hwdev || !temp)\n\t\treturn -EINVAL;\n\n\thwif = hwdev->hwif;\n\tpdev = hwif->pdev;\n\n\ttemp_key.func_id = HINIC_HWIF_FUNC_IDX(hwif);\n\ttemp_key.template_id = tmpl_idx;\n\n\terr = hinic_port_msg_cmd(hwdev, HINIC_PORT_CMD_GET_RSS_TEMPLATE_TBL,\n\t\t\t\t &temp_key, sizeof(temp_key),\n\t\t\t\t &temp_key, &out_size);\n\tif (err || !out_size || temp_key.status) {\n\t\tdev_err(&pdev->dev, \"Failed to set hash key, err: %d, status: 0x%x, out size: 0x%x\\n\",\n\t\t\terr, temp_key.status, out_size);\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(temp, temp_key.key, HINIC_RSS_KEY_SIZE);\n\n\treturn 0;\n}\n\nint hinic_rss_set_hash_engine(struct hinic_dev *nic_dev, u8 template_id,\n\t\t\t      u8 type)\n{\n\tstruct hinic_rss_engine_type rss_engine = { 0 };\n\tstruct hinic_hwdev *hwdev = nic_dev->hwdev;\n\tstruct hinic_hwif *hwif = hwdev->hwif;\n\tstruct pci_dev *pdev = hwif->pdev;\n\tu16 out_size = sizeof(rss_engine);\n\tint err;\n\n\trss_engine.func_id = HINIC_HWIF_FUNC_IDX(hwif);\n\trss_engine.hash_engine = type;\n\trss_engine.template_id = template_id;\n\n\terr = hinic_port_msg_cmd(hwdev, HINIC_PORT_CMD_SET_RSS_HASH_ENGINE,\n\t\t\t\t &rss_engine, sizeof(rss_engine),\n\t\t\t\t &rss_engine, &out_size);\n\tif (err || !out_size || rss_engine.status) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Failed to set hash engine, err: %d, status: 0x%x, out size: 0x%x\\n\",\n\t\t\terr, rss_engine.status, out_size);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nint hinic_rss_get_hash_engine(struct hinic_dev *nic_dev, u8 tmpl_idx, u8 *type)\n{\n\tstruct hinic_rss_engine_type hash_type = { 0 };\n\tstruct hinic_hwdev *hwdev = nic_dev->hwdev;\n\tu16 out_size = sizeof(hash_type);\n\tstruct hinic_hwif *hwif;\n\tstruct pci_dev *pdev;\n\tint err;\n\n\tif (!hwdev || !type)\n\t\treturn -EINVAL;\n\n\thwif = hwdev->hwif;\n\tpdev = hwif->pdev;\n\n\thash_type.func_id = HINIC_HWIF_FUNC_IDX(hwif);\n\thash_type.template_id = tmpl_idx;\n\n\terr = hinic_port_msg_cmd(hwdev, HINIC_PORT_CMD_GET_RSS_HASH_ENGINE,\n\t\t\t\t &hash_type, sizeof(hash_type),\n\t\t\t\t &hash_type, &out_size);\n\tif (err || !out_size || hash_type.status) {\n\t\tdev_err(&pdev->dev, \"Failed to get hash engine, err: %d, status: 0x%x, out size: 0x%x\\n\",\n\t\t\terr, hash_type.status, out_size);\n\t\treturn -EINVAL;\n\t}\n\n\t*type = hash_type.hash_engine;\n\treturn 0;\n}\n\nint hinic_rss_cfg(struct hinic_dev *nic_dev, u8 rss_en, u8 template_id)\n{\n\tstruct hinic_hwdev *hwdev = nic_dev->hwdev;\n\tstruct hinic_rss_config rss_cfg = { 0 };\n\tstruct hinic_hwif *hwif = hwdev->hwif;\n\tstruct pci_dev *pdev = hwif->pdev;\n\tu16 out_size = sizeof(rss_cfg);\n\tint err;\n\n\trss_cfg.func_id = HINIC_HWIF_FUNC_IDX(hwif);\n\trss_cfg.rss_en = rss_en;\n\trss_cfg.template_id = template_id;\n\trss_cfg.rq_priority_number = 0;\n\n\terr = hinic_port_msg_cmd(hwdev, HINIC_PORT_CMD_RSS_CFG,\n\t\t\t\t &rss_cfg, sizeof(rss_cfg),\n\t\t\t\t &rss_cfg, &out_size);\n\tif (err || !out_size || rss_cfg.status) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Failed to set rss cfg, err: %d, status: 0x%x, out size: 0x%x\\n\",\n\t\t\terr, rss_cfg.status, out_size);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nint hinic_rss_template_alloc(struct hinic_dev *nic_dev, u8 *tmpl_idx)\n{\n\tstruct hinic_rss_template_mgmt template_mgmt = { 0 };\n\tstruct hinic_hwdev *hwdev = nic_dev->hwdev;\n\tstruct hinic_hwif *hwif = hwdev->hwif;\n\tu16 out_size = sizeof(template_mgmt);\n\tstruct pci_dev *pdev = hwif->pdev;\n\tint err;\n\n\ttemplate_mgmt.func_id = HINIC_HWIF_FUNC_IDX(hwif);\n\ttemplate_mgmt.cmd = NIC_RSS_CMD_TEMP_ALLOC;\n\n\terr = hinic_port_msg_cmd(hwdev, HINIC_PORT_CMD_RSS_TEMP_MGR,\n\t\t\t\t &template_mgmt, sizeof(template_mgmt),\n\t\t\t\t &template_mgmt, &out_size);\n\tif (err || !out_size || template_mgmt.status) {\n\t\tdev_err(&pdev->dev, \"Failed to alloc rss template, err: %d, status: 0x%x, out size: 0x%x\\n\",\n\t\t\terr, template_mgmt.status, out_size);\n\t\treturn -EINVAL;\n\t}\n\n\t*tmpl_idx = template_mgmt.template_id;\n\n\treturn 0;\n}\n\nint hinic_rss_template_free(struct hinic_dev *nic_dev, u8 tmpl_idx)\n{\n\tstruct hinic_rss_template_mgmt template_mgmt = { 0 };\n\tstruct hinic_hwdev *hwdev = nic_dev->hwdev;\n\tstruct hinic_hwif *hwif = hwdev->hwif;\n\tu16 out_size = sizeof(template_mgmt);\n\tstruct pci_dev *pdev = hwif->pdev;\n\tint err;\n\n\ttemplate_mgmt.func_id = HINIC_HWIF_FUNC_IDX(hwif);\n\ttemplate_mgmt.template_id = tmpl_idx;\n\ttemplate_mgmt.cmd = NIC_RSS_CMD_TEMP_FREE;\n\n\terr = hinic_port_msg_cmd(hwdev, HINIC_PORT_CMD_RSS_TEMP_MGR,\n\t\t\t\t &template_mgmt, sizeof(template_mgmt),\n\t\t\t\t &template_mgmt, &out_size);\n\tif (err || !out_size || template_mgmt.status) {\n\t\tdev_err(&pdev->dev, \"Failed to free rss template, err: %d, status: 0x%x, out size: 0x%x\\n\",\n\t\t\terr, template_mgmt.status, out_size);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nint hinic_get_vport_stats(struct hinic_dev *nic_dev,\n\t\t\t  struct hinic_vport_stats *stats)\n{\n\tstruct hinic_cmd_vport_stats vport_stats = { 0 };\n\tstruct hinic_port_stats_info stats_info = { 0 };\n\tstruct hinic_hwdev *hwdev = nic_dev->hwdev;\n\tstruct hinic_hwif *hwif = hwdev->hwif;\n\tu16 out_size = sizeof(vport_stats);\n\tstruct pci_dev *pdev = hwif->pdev;\n\tint err;\n\n\tstats_info.stats_version = HINIC_PORT_STATS_VERSION;\n\tstats_info.func_id = HINIC_HWIF_FUNC_IDX(hwif);\n\tstats_info.stats_size = sizeof(vport_stats);\n\n\terr = hinic_port_msg_cmd(hwdev, HINIC_PORT_CMD_GET_VPORT_STAT,\n\t\t\t\t &stats_info, sizeof(stats_info),\n\t\t\t\t &vport_stats, &out_size);\n\tif (err || !out_size || vport_stats.status) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Failed to get function statistics, err: %d, status: 0x%x, out size: 0x%x\\n\",\n\t\t\terr, vport_stats.status, out_size);\n\t\treturn -EFAULT;\n\t}\n\n\tmemcpy(stats, &vport_stats.stats, sizeof(*stats));\n\treturn 0;\n}\n\nint hinic_get_phy_port_stats(struct hinic_dev *nic_dev,\n\t\t\t     struct hinic_phy_port_stats *stats)\n{\n\tstruct hinic_port_stats_info stats_info = { 0 };\n\tstruct hinic_hwdev *hwdev = nic_dev->hwdev;\n\tstruct hinic_hwif *hwif = hwdev->hwif;\n\tstruct hinic_port_stats *port_stats;\n\tu16 out_size = sizeof(*port_stats);\n\tstruct pci_dev *pdev = hwif->pdev;\n\tint err;\n\n\tport_stats = kzalloc(sizeof(*port_stats), GFP_KERNEL);\n\tif (!port_stats)\n\t\treturn -ENOMEM;\n\n\tstats_info.stats_version = HINIC_PORT_STATS_VERSION;\n\tstats_info.stats_size = sizeof(*port_stats);\n\n\terr = hinic_port_msg_cmd(hwdev, HINIC_PORT_CMD_GET_PORT_STATISTICS,\n\t\t\t\t &stats_info, sizeof(stats_info),\n\t\t\t\t port_stats, &out_size);\n\tif (err || !out_size || port_stats->status) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Failed to get port statistics, err: %d, status: 0x%x, out size: 0x%x\\n\",\n\t\t\terr, port_stats->status, out_size);\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tmemcpy(stats, &port_stats->stats, sizeof(*stats));\n\nout:\n\tkfree(port_stats);\n\n\treturn err;\n}\n\nint hinic_get_mgmt_version(struct hinic_dev *nic_dev, u8 *mgmt_ver)\n{\n\tstruct hinic_hwdev *hwdev = nic_dev->hwdev;\n\tstruct hinic_version_info up_ver = {0};\n\tu16 out_size = sizeof(up_ver);\n\tstruct hinic_hwif *hwif;\n\tstruct pci_dev *pdev;\n\tint err;\n\n\tif (!hwdev)\n\t\treturn -EINVAL;\n\n\thwif = hwdev->hwif;\n\tpdev = hwif->pdev;\n\n\terr = hinic_port_msg_cmd(hwdev, HINIC_PORT_CMD_GET_MGMT_VERSION,\n\t\t\t\t &up_ver, sizeof(up_ver), &up_ver,\n\t\t\t\t &out_size);\n\tif (err || !out_size || up_ver.status) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Failed to get mgmt version, err: %d, status: 0x%x, out size: 0x%x\\n\",\n\t\t\terr, up_ver.status, out_size);\n\t\treturn -EINVAL;\n\t}\n\n\tsnprintf(mgmt_ver, HINIC_MGMT_VERSION_MAX_LEN, \"%s\", up_ver.ver);\n\n\treturn 0;\n}\n\nint hinic_get_link_mode(struct hinic_hwdev *hwdev,\n\t\t\tstruct hinic_link_mode_cmd *link_mode)\n{\n\tu16 out_size;\n\tint err;\n\n\tif (!hwdev || !link_mode)\n\t\treturn -EINVAL;\n\n\tlink_mode->func_id = HINIC_HWIF_FUNC_IDX(hwdev->hwif);\n\tout_size = sizeof(*link_mode);\n\n\terr = hinic_port_msg_cmd(hwdev, HINIC_PORT_CMD_GET_LINK_MODE,\n\t\t\t\t link_mode, sizeof(*link_mode),\n\t\t\t\t link_mode, &out_size);\n\tif (err || !out_size || link_mode->status) {\n\t\tdev_err(&hwdev->hwif->pdev->dev,\n\t\t\t\"Failed to get link mode, err: %d, status: 0x%x, out size: 0x%x\\n\",\n\t\t\terr, link_mode->status, out_size);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nint hinic_set_autoneg(struct hinic_hwdev *hwdev, bool enable)\n{\n\tstruct hinic_set_autoneg_cmd autoneg = {0};\n\tu16 out_size = sizeof(autoneg);\n\tint err;\n\n\tif (!hwdev)\n\t\treturn -EINVAL;\n\n\tautoneg.func_id = HINIC_HWIF_FUNC_IDX(hwdev->hwif);\n\tautoneg.enable = enable;\n\n\terr = hinic_port_msg_cmd(hwdev, HINIC_PORT_CMD_SET_AUTONEG,\n\t\t\t\t &autoneg, sizeof(autoneg),\n\t\t\t\t &autoneg, &out_size);\n\tif (err || !out_size || autoneg.status) {\n\t\tdev_err(&hwdev->hwif->pdev->dev, \"Failed to %s autoneg, err: %d, status: 0x%x, out size: 0x%x\\n\",\n\t\t\tenable ? \"enable\" : \"disable\", err, autoneg.status,\n\t\t\tout_size);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nint hinic_set_speed(struct hinic_hwdev *hwdev, enum nic_speed_level speed)\n{\n\tstruct hinic_speed_cmd speed_info = {0};\n\tu16 out_size = sizeof(speed_info);\n\tint err;\n\n\tif (!hwdev)\n\t\treturn -EINVAL;\n\n\tspeed_info.func_id = HINIC_HWIF_FUNC_IDX(hwdev->hwif);\n\tspeed_info.speed = speed;\n\n\terr = hinic_port_msg_cmd(hwdev, HINIC_PORT_CMD_SET_SPEED,\n\t\t\t\t &speed_info, sizeof(speed_info),\n\t\t\t\t &speed_info, &out_size);\n\tif (err || !out_size || speed_info.status) {\n\t\tdev_err(&hwdev->hwif->pdev->dev,\n\t\t\t\"Failed to set speed, err: %d, status: 0x%x, out size: 0x%x\\n\",\n\t\t\terr, speed_info.status, out_size);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nint hinic_set_link_settings(struct hinic_hwdev *hwdev,\n\t\t\t    struct hinic_link_ksettings_info *info)\n{\n\tu16 out_size = sizeof(*info);\n\tint err;\n\n\terr = hinic_hilink_msg_cmd(hwdev, HINIC_HILINK_CMD_SET_LINK_SETTINGS,\n\t\t\t\t   info, sizeof(*info), info, &out_size);\n\tif ((info->status != HINIC_MGMT_CMD_UNSUPPORTED &&\n\t     info->status) || err || !out_size) {\n\t\tdev_err(&hwdev->hwif->pdev->dev,\n\t\t\t\"Failed to set link settings, err: %d, status: 0x%x, out size: 0x%x\\n\",\n\t\t\terr, info->status, out_size);\n\t\treturn -EFAULT;\n\t}\n\n\treturn info->status;\n}\n\nint hinic_get_hw_pause_info(struct hinic_hwdev *hwdev,\n\t\t\t    struct hinic_pause_config *pause_info)\n{\n\tu16 out_size = sizeof(*pause_info);\n\tint err;\n\n\tpause_info->func_id = HINIC_HWIF_FUNC_IDX(hwdev->hwif);\n\n\terr = hinic_port_msg_cmd(hwdev, HINIC_PORT_CMD_GET_PAUSE_INFO,\n\t\t\t\t pause_info, sizeof(*pause_info),\n\t\t\t\t pause_info, &out_size);\n\tif (err || !out_size || pause_info->status) {\n\t\tdev_err(&hwdev->hwif->pdev->dev, \"Failed to get pause info, err: %d, status: 0x%x, out size: 0x%x\\n\",\n\t\t\terr, pause_info->status, out_size);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nint hinic_set_hw_pause_info(struct hinic_hwdev *hwdev,\n\t\t\t    struct hinic_pause_config *pause_info)\n{\n\tu16 out_size = sizeof(*pause_info);\n\tint err;\n\n\tpause_info->func_id = HINIC_HWIF_FUNC_IDX(hwdev->hwif);\n\n\terr = hinic_port_msg_cmd(hwdev, HINIC_PORT_CMD_SET_PAUSE_INFO,\n\t\t\t\t pause_info, sizeof(*pause_info),\n\t\t\t\t pause_info, &out_size);\n\tif (err || !out_size || pause_info->status) {\n\t\tdev_err(&hwdev->hwif->pdev->dev, \"Failed to set pause info, err: %d, status: 0x%x, out size: 0x%x\\n\",\n\t\t\terr, pause_info->status, out_size);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nint hinic_dcb_set_pfc(struct hinic_hwdev *hwdev, u8 pfc_en, u8 pfc_bitmap)\n{\n\tstruct hinic_nic_cfg *nic_cfg = &hwdev->func_to_io.nic_cfg;\n\tstruct hinic_set_pfc pfc = {0};\n\tu16 out_size = sizeof(pfc);\n\tint err;\n\n\tif (HINIC_IS_VF(hwdev->hwif))\n\t\treturn 0;\n\n\tmutex_lock(&nic_cfg->cfg_mutex);\n\n\tpfc.func_id = HINIC_HWIF_FUNC_IDX(hwdev->hwif);\n\tpfc.pfc_bitmap = pfc_bitmap;\n\tpfc.pfc_en = pfc_en;\n\n\terr = hinic_port_msg_cmd(hwdev, HINIC_PORT_CMD_SET_PFC,\n\t\t\t\t &pfc, sizeof(pfc), &pfc, &out_size);\n\tif (err || pfc.status || !out_size) {\n\t\tdev_err(&hwdev->hwif->pdev->dev, \"Failed to %s pfc, err: %d, status: 0x%x, out size: 0x%x\\n\",\n\t\t\tpfc_en ? \"enable\" : \"disable\", err, pfc.status,\n\t\t\tout_size);\n\t\tmutex_unlock(&nic_cfg->cfg_mutex);\n\t\treturn -EIO;\n\t}\n\n\t \n\tnic_cfg->rx_pause = pfc_en ? 0 : 1;\n\tnic_cfg->tx_pause = pfc_en ? 0 : 1;\n\n\tmutex_unlock(&nic_cfg->cfg_mutex);\n\n\treturn 0;\n}\n\nint hinic_set_loopback_mode(struct hinic_hwdev *hwdev, u32 mode, u32 enable)\n{\n\tstruct hinic_port_loopback lb = {0};\n\tu16 out_size = sizeof(lb);\n\tint err;\n\n\tlb.mode = mode;\n\tlb.en = enable;\n\n\tif (mode < LOOP_MODE_MIN || mode > LOOP_MODE_MAX) {\n\t\tdev_err(&hwdev->hwif->pdev->dev,\n\t\t\t\"Invalid loopback mode %d to set\\n\", mode);\n\t\treturn -EINVAL;\n\t}\n\n\terr = hinic_port_msg_cmd(hwdev, HINIC_PORT_CMD_SET_LOOPBACK_MODE,\n\t\t\t\t &lb, sizeof(lb), &lb, &out_size);\n\tif (err || !out_size || lb.status) {\n\t\tdev_err(&hwdev->hwif->pdev->dev,\n\t\t\t\"Failed to set loopback mode %d en %d, err: %d, status: 0x%x, out size: 0x%x\\n\",\n\t\t\tmode, enable, err, lb.status, out_size);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int _set_led_status(struct hinic_hwdev *hwdev, u8 port,\n\t\t\t   enum hinic_led_type type,\n\t\t\t   enum hinic_led_mode mode, u8 reset)\n{\n\tstruct hinic_led_info led_info = {0};\n\tu16 out_size = sizeof(led_info);\n\tstruct hinic_pfhwdev *pfhwdev;\n\tint err;\n\n\tpfhwdev = container_of(hwdev, struct hinic_pfhwdev, hwdev);\n\n\tled_info.port = port;\n\tled_info.reset = reset;\n\n\tled_info.type = type;\n\tled_info.mode = mode;\n\n\terr = hinic_msg_to_mgmt(&pfhwdev->pf_to_mgmt, HINIC_MOD_COMM,\n\t\t\t\tHINIC_COMM_CMD_SET_LED_STATUS,\n\t\t\t\t&led_info, sizeof(led_info),\n\t\t\t\t&led_info, &out_size, HINIC_MGMT_MSG_SYNC);\n\tif (err || led_info.status || !out_size) {\n\t\tdev_err(&hwdev->hwif->pdev->dev, \"Failed to set led status, err: %d, status: 0x%x, out size: 0x%x\\n\",\n\t\t\terr, led_info.status, out_size);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nint hinic_set_led_status(struct hinic_hwdev *hwdev, u8 port,\n\t\t\t enum hinic_led_type type, enum hinic_led_mode mode)\n{\n\tif (!hwdev)\n\t\treturn -EINVAL;\n\n\treturn _set_led_status(hwdev, port, type, mode, 0);\n}\n\nint hinic_reset_led_status(struct hinic_hwdev *hwdev, u8 port)\n{\n\tint err;\n\n\tif (!hwdev)\n\t\treturn -EINVAL;\n\n\terr = _set_led_status(hwdev, port, HINIC_LED_TYPE_INVALID,\n\t\t\t      HINIC_LED_MODE_INVALID, 1);\n\tif (err)\n\t\tdev_err(&hwdev->hwif->pdev->dev,\n\t\t\t\"Failed to reset led status\\n\");\n\n\treturn err;\n}\n\nstatic bool hinic_if_sfp_absent(struct hinic_hwdev *hwdev)\n{\n\tstruct hinic_cmd_get_light_module_abs sfp_abs = {0};\n\tu16 out_size = sizeof(sfp_abs);\n\tu8 port_id = hwdev->port_id;\n\tint err;\n\n\tsfp_abs.port_id = port_id;\n\terr = hinic_port_msg_cmd(hwdev, HINIC_PORT_CMD_GET_SFP_ABS,\n\t\t\t\t &sfp_abs, sizeof(sfp_abs), &sfp_abs,\n\t\t\t\t &out_size);\n\tif (sfp_abs.status || err || !out_size) {\n\t\tdev_err(&hwdev->hwif->pdev->dev,\n\t\t\t\"Failed to get port%d sfp absent status, err: %d, status: 0x%x, out size: 0x%x\\n\",\n\t\t\tport_id, err, sfp_abs.status, out_size);\n\t\treturn true;\n\t}\n\n\treturn ((sfp_abs.abs_status == 0) ? false : true);\n}\n\nint hinic_get_sfp_eeprom(struct hinic_hwdev *hwdev, u8 *data, u16 *len)\n{\n\tstruct hinic_cmd_get_std_sfp_info sfp_info = {0};\n\tu16 out_size = sizeof(sfp_info);\n\tu8 port_id;\n\tint err;\n\n\tif (!hwdev || !data || !len)\n\t\treturn -EINVAL;\n\n\tport_id = hwdev->port_id;\n\n\tif (hinic_if_sfp_absent(hwdev))\n\t\treturn -ENXIO;\n\n\tsfp_info.port_id = port_id;\n\terr = hinic_port_msg_cmd(hwdev, HINIC_PORT_CMD_GET_STD_SFP_INFO,\n\t\t\t\t &sfp_info, sizeof(sfp_info), &sfp_info,\n\t\t\t\t &out_size);\n\tif (sfp_info.status || err || !out_size) {\n\t\tdev_err(&hwdev->hwif->pdev->dev,\n\t\t\t\"Failed to get port%d sfp eeprom information, err: %d, status: 0x%x, out size: 0x%x\\n\",\n\t\t\tport_id, err, sfp_info.status, out_size);\n\t\treturn -EIO;\n\t}\n\n\t*len = min_t(u16, sfp_info.eeprom_len, STD_SFP_INFO_MAX_SIZE);\n\tmemcpy(data, sfp_info.sfp_info, STD_SFP_INFO_MAX_SIZE);\n\n\treturn 0;\n}\n\nint hinic_get_sfp_type(struct hinic_hwdev *hwdev, u8 *data0, u8 *data1)\n{\n\tu8 sfp_data[STD_SFP_INFO_MAX_SIZE];\n\tu16 len;\n\tint err;\n\n\tif (hinic_if_sfp_absent(hwdev))\n\t\treturn -ENXIO;\n\n\terr = hinic_get_sfp_eeprom(hwdev, sfp_data, &len);\n\tif (err)\n\t\treturn err;\n\n\t*data0 = sfp_data[0];\n\t*data1 = sfp_data[1];\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}