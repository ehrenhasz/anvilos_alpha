{
  "module_name": "hinic_hw_dev.c",
  "hash_id": "33513bebff07d43c1eda084f6066820f7774b5fe19215ed535520f3051607a01",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/huawei/hinic/hinic_hw_dev.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/pci.h>\n#include <linux/device.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/log2.h>\n#include <linux/err.h>\n#include <linux/netdevice.h>\n#include <net/devlink.h>\n\n#include \"hinic_devlink.h\"\n#include \"hinic_sriov.h\"\n#include \"hinic_dev.h\"\n#include \"hinic_hw_if.h\"\n#include \"hinic_hw_eqs.h\"\n#include \"hinic_hw_mgmt.h\"\n#include \"hinic_hw_qp_ctxt.h\"\n#include \"hinic_hw_qp.h\"\n#include \"hinic_hw_io.h\"\n#include \"hinic_hw_dev.h\"\n\n#define OUTBOUND_STATE_TIMEOUT          100\n#define DB_STATE_TIMEOUT                100\n\n#define MAX_IRQS(max_qps, num_aeqs, num_ceqs)   \\\n\t\t (2 * (max_qps) + (num_aeqs) + (num_ceqs))\n\n#define ADDR_IN_4BYTES(addr)            ((addr) >> 2)\n\nenum intr_type {\n\tINTR_MSIX_TYPE,\n};\n\n \nstatic int parse_capability(struct hinic_hwdev *hwdev,\n\t\t\t    struct hinic_dev_cap *dev_cap)\n{\n\tstruct hinic_cap *nic_cap = &hwdev->nic_cap;\n\tint num_aeqs, num_ceqs, num_irqs;\n\n\tif (!HINIC_IS_VF(hwdev->hwif) && dev_cap->intr_type != INTR_MSIX_TYPE)\n\t\treturn -EFAULT;\n\n\tnum_aeqs = HINIC_HWIF_NUM_AEQS(hwdev->hwif);\n\tnum_ceqs = HINIC_HWIF_NUM_CEQS(hwdev->hwif);\n\tnum_irqs = HINIC_HWIF_NUM_IRQS(hwdev->hwif);\n\n\t \n\tnic_cap->num_qps = (num_irqs - (num_aeqs + num_ceqs)) / 2;\n\n\tif (nic_cap->num_qps > HINIC_Q_CTXT_MAX)\n\t\tnic_cap->num_qps = HINIC_Q_CTXT_MAX;\n\n\tif (!HINIC_IS_VF(hwdev->hwif))\n\t\tnic_cap->max_qps = dev_cap->max_sqs + 1;\n\telse\n\t\tnic_cap->max_qps = dev_cap->max_sqs;\n\n\tif (nic_cap->num_qps > nic_cap->max_qps)\n\t\tnic_cap->num_qps = nic_cap->max_qps;\n\n\tif (!HINIC_IS_VF(hwdev->hwif)) {\n\t\tnic_cap->max_vf = dev_cap->max_vf;\n\t\tnic_cap->max_vf_qps = dev_cap->max_vf_sqs + 1;\n\t}\n\n\thwdev->port_id = dev_cap->port_id;\n\n\treturn 0;\n}\n\n \nstatic int get_capability(struct hinic_pfhwdev *pfhwdev)\n{\n\tstruct hinic_hwdev *hwdev = &pfhwdev->hwdev;\n\tstruct hinic_hwif *hwif = hwdev->hwif;\n\tstruct pci_dev *pdev = hwif->pdev;\n\tstruct hinic_dev_cap dev_cap;\n\tu16 out_len;\n\tint err;\n\n\tout_len = sizeof(dev_cap);\n\n\terr = hinic_msg_to_mgmt(&pfhwdev->pf_to_mgmt, HINIC_MOD_CFGM,\n\t\t\t\tHINIC_CFG_NIC_CAP, &dev_cap, sizeof(dev_cap),\n\t\t\t\t&dev_cap, &out_len, HINIC_MGMT_MSG_SYNC);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Failed to get capability from FW\\n\");\n\t\treturn err;\n\t}\n\n\treturn parse_capability(hwdev, &dev_cap);\n}\n\n \nstatic int get_dev_cap(struct hinic_hwdev *hwdev)\n{\n\tstruct hinic_hwif *hwif = hwdev->hwif;\n\tstruct pci_dev *pdev = hwif->pdev;\n\tstruct hinic_pfhwdev *pfhwdev;\n\tint err;\n\n\tswitch (HINIC_FUNC_TYPE(hwif)) {\n\tcase HINIC_PPF:\n\tcase HINIC_PF:\n\tcase HINIC_VF:\n\t\tpfhwdev = container_of(hwdev, struct hinic_pfhwdev, hwdev);\n\t\terr = get_capability(pfhwdev);\n\t\tif (err) {\n\t\t\tdev_err(&pdev->dev, \"Failed to get capability\\n\");\n\t\t\treturn err;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&pdev->dev, \"Unsupported PCI Function type\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int init_msix(struct hinic_hwdev *hwdev)\n{\n\tstruct hinic_hwif *hwif = hwdev->hwif;\n\tstruct pci_dev *pdev = hwif->pdev;\n\tint nr_irqs, num_aeqs, num_ceqs;\n\tint i, err;\n\n\tnum_aeqs = HINIC_HWIF_NUM_AEQS(hwif);\n\tnum_ceqs = HINIC_HWIF_NUM_CEQS(hwif);\n\tnr_irqs = MAX_IRQS(HINIC_MAX_QPS, num_aeqs, num_ceqs);\n\tif (nr_irqs > HINIC_HWIF_NUM_IRQS(hwif))\n\t\tnr_irqs = HINIC_HWIF_NUM_IRQS(hwif);\n\n\thwdev->msix_entries = devm_kcalloc(&pdev->dev, nr_irqs,\n\t\t\t\t\t   sizeof(*hwdev->msix_entries),\n\t\t\t\t\t   GFP_KERNEL);\n\tif (!hwdev->msix_entries)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < nr_irqs; i++)\n\t\thwdev->msix_entries[i].entry = i;\n\n\terr = pci_enable_msix_exact(pdev, hwdev->msix_entries, nr_irqs);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Failed to enable pci msix\\n\");\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void disable_msix(struct hinic_hwdev *hwdev)\n{\n\tstruct hinic_hwif *hwif = hwdev->hwif;\n\tstruct pci_dev *pdev = hwif->pdev;\n\n\tpci_disable_msix(pdev);\n}\n\n \nint hinic_port_msg_cmd(struct hinic_hwdev *hwdev, enum hinic_port_cmd cmd,\n\t\t       void *buf_in, u16 in_size, void *buf_out, u16 *out_size)\n{\n\tstruct hinic_pfhwdev *pfhwdev;\n\n\tpfhwdev = container_of(hwdev, struct hinic_pfhwdev, hwdev);\n\n\treturn hinic_msg_to_mgmt(&pfhwdev->pf_to_mgmt, HINIC_MOD_L2NIC, cmd,\n\t\t\t\t buf_in, in_size, buf_out, out_size,\n\t\t\t\t HINIC_MGMT_MSG_SYNC);\n}\n\nint hinic_hilink_msg_cmd(struct hinic_hwdev *hwdev, enum hinic_hilink_cmd cmd,\n\t\t\t void *buf_in, u16 in_size, void *buf_out,\n\t\t\t u16 *out_size)\n{\n\tstruct hinic_pfhwdev *pfhwdev;\n\n\tpfhwdev = container_of(hwdev, struct hinic_pfhwdev, hwdev);\n\n\treturn hinic_msg_to_mgmt(&pfhwdev->pf_to_mgmt, HINIC_MOD_HILINK, cmd,\n\t\t\t\t buf_in, in_size, buf_out, out_size,\n\t\t\t\t HINIC_MGMT_MSG_SYNC);\n}\n\n \nstatic int init_fw_ctxt(struct hinic_hwdev *hwdev)\n{\n\tstruct hinic_hwif *hwif = hwdev->hwif;\n\tstruct pci_dev *pdev = hwif->pdev;\n\tstruct hinic_cmd_fw_ctxt fw_ctxt;\n\tu16 out_size = sizeof(fw_ctxt);\n\tint err;\n\n\tfw_ctxt.func_idx = HINIC_HWIF_FUNC_IDX(hwif);\n\tfw_ctxt.rx_buf_sz = HINIC_RX_BUF_SZ;\n\n\terr = hinic_port_msg_cmd(hwdev, HINIC_PORT_CMD_FWCTXT_INIT,\n\t\t\t\t &fw_ctxt, sizeof(fw_ctxt),\n\t\t\t\t &fw_ctxt, &out_size);\n\tif (err || out_size != sizeof(fw_ctxt) || fw_ctxt.status) {\n\t\tdev_err(&pdev->dev, \"Failed to init FW ctxt, err: %d, status: 0x%x, out size: 0x%x\\n\",\n\t\t\terr, fw_ctxt.status, out_size);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int set_hw_ioctxt(struct hinic_hwdev *hwdev, unsigned int sq_depth,\n\t\t\t unsigned int rq_depth)\n{\n\tstruct hinic_hwif *hwif = hwdev->hwif;\n\tstruct hinic_cmd_hw_ioctxt hw_ioctxt;\n\tstruct hinic_pfhwdev *pfhwdev;\n\n\thw_ioctxt.func_idx = HINIC_HWIF_FUNC_IDX(hwif);\n\thw_ioctxt.ppf_idx = HINIC_HWIF_PPF_IDX(hwif);\n\n\thw_ioctxt.set_cmdq_depth = HW_IOCTXT_SET_CMDQ_DEPTH_DEFAULT;\n\thw_ioctxt.cmdq_depth = 0;\n\n\thw_ioctxt.lro_en = 1;\n\n\thw_ioctxt.rq_depth  = ilog2(rq_depth);\n\n\thw_ioctxt.rx_buf_sz_idx = HINIC_RX_BUF_SZ_IDX;\n\n\thw_ioctxt.sq_depth  = ilog2(sq_depth);\n\n\tpfhwdev = container_of(hwdev, struct hinic_pfhwdev, hwdev);\n\n\treturn hinic_msg_to_mgmt(&pfhwdev->pf_to_mgmt, HINIC_MOD_COMM,\n\t\t\t\t HINIC_COMM_CMD_HWCTXT_SET,\n\t\t\t\t &hw_ioctxt, sizeof(hw_ioctxt), NULL,\n\t\t\t\t NULL, HINIC_MGMT_MSG_SYNC);\n}\n\nstatic int wait_for_outbound_state(struct hinic_hwdev *hwdev)\n{\n\tenum hinic_outbound_state outbound_state;\n\tstruct hinic_hwif *hwif = hwdev->hwif;\n\tstruct pci_dev *pdev = hwif->pdev;\n\tunsigned long end;\n\n\tend = jiffies + msecs_to_jiffies(OUTBOUND_STATE_TIMEOUT);\n\tdo {\n\t\toutbound_state = hinic_outbound_state_get(hwif);\n\n\t\tif (outbound_state == HINIC_OUTBOUND_ENABLE)\n\t\t\treturn 0;\n\n\t\tmsleep(20);\n\t} while (time_before(jiffies, end));\n\n\tdev_err(&pdev->dev, \"Wait for OUTBOUND - Timeout\\n\");\n\treturn -EFAULT;\n}\n\nstatic int wait_for_db_state(struct hinic_hwdev *hwdev)\n{\n\tstruct hinic_hwif *hwif = hwdev->hwif;\n\tstruct pci_dev *pdev = hwif->pdev;\n\tenum hinic_db_state db_state;\n\tunsigned long end;\n\n\tend = jiffies + msecs_to_jiffies(DB_STATE_TIMEOUT);\n\tdo {\n\t\tdb_state = hinic_db_state_get(hwif);\n\n\t\tif (db_state == HINIC_DB_ENABLE)\n\t\t\treturn 0;\n\n\t\tmsleep(20);\n\t} while (time_before(jiffies, end));\n\n\tdev_err(&pdev->dev, \"Wait for DB - Timeout\\n\");\n\treturn -EFAULT;\n}\n\n \nstatic int clear_io_resources(struct hinic_hwdev *hwdev)\n{\n\tstruct hinic_cmd_clear_io_res cmd_clear_io_res;\n\tstruct hinic_hwif *hwif = hwdev->hwif;\n\tstruct pci_dev *pdev = hwif->pdev;\n\tstruct hinic_pfhwdev *pfhwdev;\n\tint err;\n\n\t \n\tmsleep(100);\n\n\tcmd_clear_io_res.func_idx = HINIC_HWIF_FUNC_IDX(hwif);\n\n\tpfhwdev = container_of(hwdev, struct hinic_pfhwdev, hwdev);\n\n\terr = hinic_msg_to_mgmt(&pfhwdev->pf_to_mgmt, HINIC_MOD_COMM,\n\t\t\t\tHINIC_COMM_CMD_IO_RES_CLEAR, &cmd_clear_io_res,\n\t\t\t\tsizeof(cmd_clear_io_res), NULL, NULL,\n\t\t\t\tHINIC_MGMT_MSG_SYNC);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Failed to clear IO resources\\n\");\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int set_resources_state(struct hinic_hwdev *hwdev,\n\t\t\t       enum hinic_res_state state)\n{\n\tstruct hinic_cmd_set_res_state res_state;\n\tstruct hinic_hwif *hwif = hwdev->hwif;\n\tstruct hinic_pfhwdev *pfhwdev;\n\n\tres_state.func_idx = HINIC_HWIF_FUNC_IDX(hwif);\n\tres_state.state = state;\n\n\tpfhwdev = container_of(hwdev, struct hinic_pfhwdev, hwdev);\n\n\treturn hinic_msg_to_mgmt(&pfhwdev->pf_to_mgmt,\n\t\t\t\t HINIC_MOD_COMM,\n\t\t\t\t HINIC_COMM_CMD_RES_STATE_SET,\n\t\t\t\t &res_state, sizeof(res_state), NULL,\n\t\t\t\t NULL, HINIC_MGMT_MSG_SYNC);\n}\n\n \nstatic int get_base_qpn(struct hinic_hwdev *hwdev, u16 *base_qpn)\n{\n\tstruct hinic_cmd_base_qpn cmd_base_qpn;\n\tstruct hinic_hwif *hwif = hwdev->hwif;\n\tu16 out_size = sizeof(cmd_base_qpn);\n\tstruct pci_dev *pdev = hwif->pdev;\n\tint err;\n\n\tcmd_base_qpn.func_idx = HINIC_HWIF_FUNC_IDX(hwif);\n\n\terr = hinic_port_msg_cmd(hwdev, HINIC_PORT_CMD_GET_GLOBAL_QPN,\n\t\t\t\t &cmd_base_qpn, sizeof(cmd_base_qpn),\n\t\t\t\t &cmd_base_qpn, &out_size);\n\tif (err || out_size != sizeof(cmd_base_qpn) || cmd_base_qpn.status) {\n\t\tdev_err(&pdev->dev, \"Failed to get base qpn, err: %d, status: 0x%x, out size: 0x%x\\n\",\n\t\t\terr, cmd_base_qpn.status, out_size);\n\t\treturn -EIO;\n\t}\n\n\t*base_qpn = cmd_base_qpn.qpn;\n\treturn 0;\n}\n\n \nint hinic_hwdev_ifup(struct hinic_hwdev *hwdev, u16 sq_depth, u16 rq_depth)\n{\n\tstruct hinic_func_to_io *func_to_io = &hwdev->func_to_io;\n\tstruct hinic_cap *nic_cap = &hwdev->nic_cap;\n\tstruct hinic_hwif *hwif = hwdev->hwif;\n\tint err, num_aeqs, num_ceqs, num_qps;\n\tstruct msix_entry *ceq_msix_entries;\n\tstruct msix_entry *sq_msix_entries;\n\tstruct msix_entry *rq_msix_entries;\n\tstruct pci_dev *pdev = hwif->pdev;\n\tu16 base_qpn;\n\n\terr = get_base_qpn(hwdev, &base_qpn);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Failed to get global base qp number\\n\");\n\t\treturn err;\n\t}\n\n\tnum_aeqs = HINIC_HWIF_NUM_AEQS(hwif);\n\tnum_ceqs = HINIC_HWIF_NUM_CEQS(hwif);\n\n\tceq_msix_entries = &hwdev->msix_entries[num_aeqs];\n\tfunc_to_io->hwdev = hwdev;\n\tfunc_to_io->sq_depth = sq_depth;\n\tfunc_to_io->rq_depth = rq_depth;\n\tfunc_to_io->global_qpn = base_qpn;\n\n\terr = hinic_io_init(func_to_io, hwif, nic_cap->max_qps, num_ceqs,\n\t\t\t    ceq_msix_entries);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Failed to init IO channel\\n\");\n\t\treturn err;\n\t}\n\n\tnum_qps = nic_cap->num_qps;\n\tsq_msix_entries = &hwdev->msix_entries[num_aeqs + num_ceqs];\n\trq_msix_entries = &hwdev->msix_entries[num_aeqs + num_ceqs + num_qps];\n\n\terr = hinic_io_create_qps(func_to_io, base_qpn, num_qps,\n\t\t\t\t  sq_msix_entries, rq_msix_entries);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Failed to create QPs\\n\");\n\t\tgoto err_create_qps;\n\t}\n\n\terr = wait_for_db_state(hwdev);\n\tif (err) {\n\t\tdev_warn(&pdev->dev, \"db - disabled, try again\\n\");\n\t\thinic_db_state_set(hwif, HINIC_DB_ENABLE);\n\t}\n\n\terr = set_hw_ioctxt(hwdev, sq_depth, rq_depth);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Failed to set HW IO ctxt\\n\");\n\t\tgoto err_hw_ioctxt;\n\t}\n\n\treturn 0;\n\nerr_hw_ioctxt:\n\thinic_io_destroy_qps(func_to_io, num_qps);\n\nerr_create_qps:\n\thinic_io_free(func_to_io);\n\treturn err;\n}\n\n \nvoid hinic_hwdev_ifdown(struct hinic_hwdev *hwdev)\n{\n\tstruct hinic_func_to_io *func_to_io = &hwdev->func_to_io;\n\tstruct hinic_cap *nic_cap = &hwdev->nic_cap;\n\n\tclear_io_resources(hwdev);\n\n\thinic_io_destroy_qps(func_to_io, nic_cap->num_qps);\n\thinic_io_free(func_to_io);\n}\n\n \nvoid hinic_hwdev_cb_register(struct hinic_hwdev *hwdev,\n\t\t\t     enum hinic_mgmt_msg_cmd cmd, void *handle,\n\t\t\t     void (*handler)(void *handle, void *buf_in,\n\t\t\t\t\t     u16 in_size, void *buf_out,\n\t\t\t\t\t     u16 *out_size))\n{\n\tstruct hinic_pfhwdev *pfhwdev;\n\tstruct hinic_nic_cb *nic_cb;\n\tu8 cmd_cb;\n\n\tpfhwdev = container_of(hwdev, struct hinic_pfhwdev, hwdev);\n\n\tcmd_cb = cmd - HINIC_MGMT_MSG_CMD_BASE;\n\tnic_cb = &pfhwdev->nic_cb[cmd_cb];\n\n\tnic_cb->handler = handler;\n\tnic_cb->handle = handle;\n\tnic_cb->cb_state = HINIC_CB_ENABLED;\n}\n\n \nvoid hinic_hwdev_cb_unregister(struct hinic_hwdev *hwdev,\n\t\t\t       enum hinic_mgmt_msg_cmd cmd)\n{\n\tstruct hinic_hwif *hwif = hwdev->hwif;\n\tstruct hinic_pfhwdev *pfhwdev;\n\tstruct hinic_nic_cb *nic_cb;\n\tu8 cmd_cb;\n\n\tif (!HINIC_IS_PF(hwif) && !HINIC_IS_PPF(hwif))\n\t\treturn;\n\n\tpfhwdev = container_of(hwdev, struct hinic_pfhwdev, hwdev);\n\n\tcmd_cb = cmd - HINIC_MGMT_MSG_CMD_BASE;\n\tnic_cb = &pfhwdev->nic_cb[cmd_cb];\n\n\tnic_cb->cb_state &= ~HINIC_CB_ENABLED;\n\n\twhile (nic_cb->cb_state & HINIC_CB_RUNNING)\n\t\tschedule();\n\n\tnic_cb->handler = NULL;\n}\n\n \nstatic void nic_mgmt_msg_handler(void *handle, u8 cmd, void *buf_in,\n\t\t\t\t u16 in_size, void *buf_out, u16 *out_size)\n{\n\tstruct hinic_pfhwdev *pfhwdev = handle;\n\tenum hinic_cb_state cb_state;\n\tstruct hinic_nic_cb *nic_cb;\n\tstruct hinic_hwdev *hwdev;\n\tstruct hinic_hwif *hwif;\n\tstruct pci_dev *pdev;\n\tu8 cmd_cb;\n\n\thwdev = &pfhwdev->hwdev;\n\thwif = hwdev->hwif;\n\tpdev = hwif->pdev;\n\n\tif (cmd < HINIC_MGMT_MSG_CMD_BASE ||\n\t    cmd >= HINIC_MGMT_MSG_CMD_MAX) {\n\t\tdev_err(&pdev->dev, \"unknown L2NIC event, cmd = %d\\n\", cmd);\n\t\treturn;\n\t}\n\n\tcmd_cb = cmd - HINIC_MGMT_MSG_CMD_BASE;\n\n\tnic_cb = &pfhwdev->nic_cb[cmd_cb];\n\n\tcb_state = cmpxchg(&nic_cb->cb_state,\n\t\t\t   HINIC_CB_ENABLED,\n\t\t\t   HINIC_CB_ENABLED | HINIC_CB_RUNNING);\n\n\tif (cb_state == HINIC_CB_ENABLED && nic_cb->handler)\n\t\tnic_cb->handler(nic_cb->handle, buf_in,\n\t\t\t\tin_size, buf_out, out_size);\n\telse\n\t\tdev_err(&pdev->dev, \"Unhandled NIC Event %d\\n\", cmd);\n\n\tnic_cb->cb_state &= ~HINIC_CB_RUNNING;\n}\n\nstatic void hinic_comm_recv_mgmt_self_cmd_reg(struct hinic_pfhwdev *pfhwdev,\n\t\t\t\t\t      u8 cmd,\n\t\t\t\t\t      comm_mgmt_self_msg_proc proc)\n{\n\tu8 cmd_idx;\n\n\tcmd_idx = pfhwdev->proc.cmd_num;\n\tif (cmd_idx >= HINIC_COMM_SELF_CMD_MAX) {\n\t\tdev_err(&pfhwdev->hwdev.hwif->pdev->dev,\n\t\t\t\"Register recv mgmt process failed, cmd: 0x%x\\n\", cmd);\n\t\treturn;\n\t}\n\n\tpfhwdev->proc.info[cmd_idx].cmd = cmd;\n\tpfhwdev->proc.info[cmd_idx].proc = proc;\n\tpfhwdev->proc.cmd_num++;\n}\n\nstatic void hinic_comm_recv_mgmt_self_cmd_unreg(struct hinic_pfhwdev *pfhwdev,\n\t\t\t\t\t\tu8 cmd)\n{\n\tu8 cmd_idx;\n\n\tcmd_idx = pfhwdev->proc.cmd_num;\n\tif (cmd_idx >= HINIC_COMM_SELF_CMD_MAX) {\n\t\tdev_err(&pfhwdev->hwdev.hwif->pdev->dev, \"Unregister recv mgmt process failed, cmd: 0x%x\\n\",\n\t\t\tcmd);\n\t\treturn;\n\t}\n\n\tfor (cmd_idx = 0; cmd_idx < HINIC_COMM_SELF_CMD_MAX; cmd_idx++) {\n\t\tif (cmd == pfhwdev->proc.info[cmd_idx].cmd) {\n\t\t\tpfhwdev->proc.info[cmd_idx].cmd = 0;\n\t\t\tpfhwdev->proc.info[cmd_idx].proc = NULL;\n\t\t\tpfhwdev->proc.cmd_num--;\n\t\t}\n\t}\n}\n\nstatic void comm_mgmt_msg_handler(void *handle, u8 cmd, void *buf_in,\n\t\t\t\t  u16 in_size, void *buf_out, u16 *out_size)\n{\n\tstruct hinic_pfhwdev *pfhwdev = handle;\n\tu8 cmd_idx;\n\n\tfor (cmd_idx = 0; cmd_idx < pfhwdev->proc.cmd_num; cmd_idx++) {\n\t\tif (cmd == pfhwdev->proc.info[cmd_idx].cmd) {\n\t\t\tif (!pfhwdev->proc.info[cmd_idx].proc) {\n\t\t\t\tdev_warn(&pfhwdev->hwdev.hwif->pdev->dev,\n\t\t\t\t\t \"PF recv mgmt comm msg handle null, cmd: 0x%x\\n\",\n\t\t\t\t\t cmd);\n\t\t\t} else {\n\t\t\t\tpfhwdev->proc.info[cmd_idx].proc\n\t\t\t\t\t(&pfhwdev->hwdev, buf_in, in_size,\n\t\t\t\t\t buf_out, out_size);\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\t}\n\n\tdev_warn(&pfhwdev->hwdev.hwif->pdev->dev, \"Received unknown mgmt cpu event: 0x%x\\n\",\n\t\t cmd);\n\n\t*out_size = 0;\n}\n\n \nstatic void pf_fault_event_handler(void *dev, void *buf_in, u16 in_size,\n\t\t\t\t   void *buf_out, u16 *out_size)\n{\n\tstruct hinic_cmd_fault_event *fault_event = buf_in;\n\tstruct hinic_hwdev *hwdev = dev;\n\n\tif (in_size != sizeof(*fault_event)) {\n\t\tdev_err(&hwdev->hwif->pdev->dev, \"Invalid fault event report, length: %d, should be %zu\\n\",\n\t\t\tin_size, sizeof(*fault_event));\n\t\treturn;\n\t}\n\n\tif (!hwdev->devlink_dev || IS_ERR_OR_NULL(hwdev->devlink_dev->hw_fault_reporter))\n\t\treturn;\n\n\tdevlink_health_report(hwdev->devlink_dev->hw_fault_reporter,\n\t\t\t      \"HW fatal error reported\", &fault_event->event);\n}\n\nstatic void mgmt_watchdog_timeout_event_handler(void *dev,\n\t\t\t\t\t\tvoid *buf_in, u16 in_size,\n\t\t\t\t\t\tvoid *buf_out, u16 *out_size)\n{\n\tstruct hinic_mgmt_watchdog_info *watchdog_info = buf_in;\n\tstruct hinic_hwdev *hwdev = dev;\n\n\tif (in_size != sizeof(*watchdog_info)) {\n\t\tdev_err(&hwdev->hwif->pdev->dev, \"Invalid mgmt watchdog report, length: %d, should be %zu\\n\",\n\t\t\tin_size, sizeof(*watchdog_info));\n\t\treturn;\n\t}\n\n\tif (!hwdev->devlink_dev || IS_ERR_OR_NULL(hwdev->devlink_dev->fw_fault_reporter))\n\t\treturn;\n\n\tdevlink_health_report(hwdev->devlink_dev->fw_fault_reporter,\n\t\t\t      \"FW fatal error reported\", watchdog_info);\n}\n\n \nstatic int init_pfhwdev(struct hinic_pfhwdev *pfhwdev)\n{\n\tstruct hinic_hwdev *hwdev = &pfhwdev->hwdev;\n\tstruct hinic_hwif *hwif = hwdev->hwif;\n\tstruct pci_dev *pdev = hwif->pdev;\n\tint err;\n\n\terr = hinic_pf_to_mgmt_init(&pfhwdev->pf_to_mgmt, hwif);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Failed to initialize PF to MGMT channel\\n\");\n\t\treturn err;\n\t}\n\n\terr = hinic_func_to_func_init(hwdev);\n\tif (err) {\n\t\tdev_err(&hwif->pdev->dev, \"Failed to init mailbox\\n\");\n\t\thinic_pf_to_mgmt_free(&pfhwdev->pf_to_mgmt);\n\t\treturn err;\n\t}\n\n\tif (!HINIC_IS_VF(hwif)) {\n\t\thinic_register_mgmt_msg_cb(&pfhwdev->pf_to_mgmt,\n\t\t\t\t\t   HINIC_MOD_L2NIC, pfhwdev,\n\t\t\t\t\t   nic_mgmt_msg_handler);\n\t\thinic_register_mgmt_msg_cb(&pfhwdev->pf_to_mgmt, HINIC_MOD_COMM,\n\t\t\t\t\t   pfhwdev, comm_mgmt_msg_handler);\n\t\thinic_comm_recv_mgmt_self_cmd_reg(pfhwdev,\n\t\t\t\t\t\t  HINIC_COMM_CMD_FAULT_REPORT,\n\t\t\t\t\t\t  pf_fault_event_handler);\n\t\thinic_comm_recv_mgmt_self_cmd_reg\n\t\t\t(pfhwdev, HINIC_COMM_CMD_WATCHDOG_INFO,\n\t\t\t mgmt_watchdog_timeout_event_handler);\n\t} else {\n\t\thinic_register_vf_mbox_cb(hwdev, HINIC_MOD_L2NIC,\n\t\t\t\t\t  nic_mgmt_msg_handler);\n\t}\n\n\thinic_set_pf_action(hwif, HINIC_PF_MGMT_ACTIVE);\n\thinic_devlink_register(hwdev->devlink_dev);\n\treturn 0;\n}\n\n \nstatic void free_pfhwdev(struct hinic_pfhwdev *pfhwdev)\n{\n\tstruct hinic_hwdev *hwdev = &pfhwdev->hwdev;\n\n\thinic_devlink_unregister(hwdev->devlink_dev);\n\thinic_set_pf_action(hwdev->hwif, HINIC_PF_MGMT_INIT);\n\n\tif (!HINIC_IS_VF(hwdev->hwif)) {\n\t\thinic_comm_recv_mgmt_self_cmd_unreg(pfhwdev,\n\t\t\t\t\t\t    HINIC_COMM_CMD_WATCHDOG_INFO);\n\t\thinic_comm_recv_mgmt_self_cmd_unreg(pfhwdev,\n\t\t\t\t\t\t    HINIC_COMM_CMD_FAULT_REPORT);\n\t\thinic_unregister_mgmt_msg_cb(&pfhwdev->pf_to_mgmt,\n\t\t\t\t\t     HINIC_MOD_COMM);\n\t\thinic_unregister_mgmt_msg_cb(&pfhwdev->pf_to_mgmt,\n\t\t\t\t\t     HINIC_MOD_L2NIC);\n\t} else {\n\t\thinic_unregister_vf_mbox_cb(hwdev, HINIC_MOD_L2NIC);\n\t}\n\n\thinic_func_to_func_free(hwdev);\n\n\thinic_pf_to_mgmt_free(&pfhwdev->pf_to_mgmt);\n}\n\nstatic int hinic_l2nic_reset(struct hinic_hwdev *hwdev)\n{\n\tstruct hinic_cmd_l2nic_reset l2nic_reset = {0};\n\tu16 out_size = sizeof(l2nic_reset);\n\tstruct hinic_pfhwdev *pfhwdev;\n\tint err;\n\n\tpfhwdev = container_of(hwdev, struct hinic_pfhwdev, hwdev);\n\n\tl2nic_reset.func_id = HINIC_HWIF_FUNC_IDX(hwdev->hwif);\n\t \n\tl2nic_reset.reset_flag = 0;\n\n\terr = hinic_msg_to_mgmt(&pfhwdev->pf_to_mgmt, HINIC_MOD_COMM,\n\t\t\t\tHINIC_COMM_CMD_L2NIC_RESET, &l2nic_reset,\n\t\t\t\tsizeof(l2nic_reset), &l2nic_reset,\n\t\t\t\t&out_size, HINIC_MGMT_MSG_SYNC);\n\tif (err || !out_size || l2nic_reset.status) {\n\t\tdev_err(&hwdev->hwif->pdev->dev, \"Failed to reset L2NIC resources, err: %d, status: 0x%x, out_size: 0x%x\\n\",\n\t\t\terr, l2nic_reset.status, out_size);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int hinic_get_interrupt_cfg(struct hinic_hwdev *hwdev,\n\t\t\t\t   struct hinic_msix_config *interrupt_info)\n{\n\tu16 out_size = sizeof(*interrupt_info);\n\tstruct hinic_pfhwdev *pfhwdev;\n\tint err;\n\n\tif (!hwdev || !interrupt_info)\n\t\treturn -EINVAL;\n\n\tpfhwdev = container_of(hwdev, struct hinic_pfhwdev, hwdev);\n\n\tinterrupt_info->func_id = HINIC_HWIF_FUNC_IDX(hwdev->hwif);\n\n\terr = hinic_msg_to_mgmt(&pfhwdev->pf_to_mgmt, HINIC_MOD_COMM,\n\t\t\t\tHINIC_COMM_CMD_MSI_CTRL_REG_RD_BY_UP,\n\t\t\t\tinterrupt_info, sizeof(*interrupt_info),\n\t\t\t\tinterrupt_info, &out_size, HINIC_MGMT_MSG_SYNC);\n\tif (err || !out_size || interrupt_info->status) {\n\t\tdev_err(&hwdev->hwif->pdev->dev, \"Failed to get interrupt config, err: %d, status: 0x%x, out size: 0x%x\\n\",\n\t\t\terr, interrupt_info->status, out_size);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nint hinic_set_interrupt_cfg(struct hinic_hwdev *hwdev,\n\t\t\t    struct hinic_msix_config *interrupt_info)\n{\n\tu16 out_size = sizeof(*interrupt_info);\n\tstruct hinic_msix_config temp_info;\n\tstruct hinic_pfhwdev *pfhwdev;\n\tint err;\n\n\tif (!hwdev)\n\t\treturn -EINVAL;\n\n\tpfhwdev = container_of(hwdev, struct hinic_pfhwdev, hwdev);\n\n\tinterrupt_info->func_id = HINIC_HWIF_FUNC_IDX(hwdev->hwif);\n\n\terr = hinic_get_interrupt_cfg(hwdev, &temp_info);\n\tif (err)\n\t\treturn -EINVAL;\n\n\tinterrupt_info->lli_credit_cnt = temp_info.lli_credit_cnt;\n\tinterrupt_info->lli_timer_cnt = temp_info.lli_timer_cnt;\n\n\terr = hinic_msg_to_mgmt(&pfhwdev->pf_to_mgmt, HINIC_MOD_COMM,\n\t\t\t\tHINIC_COMM_CMD_MSI_CTRL_REG_WR_BY_UP,\n\t\t\t\tinterrupt_info, sizeof(*interrupt_info),\n\t\t\t\tinterrupt_info, &out_size, HINIC_MGMT_MSG_SYNC);\n\tif (err || !out_size || interrupt_info->status) {\n\t\tdev_err(&hwdev->hwif->pdev->dev, \"Failed to get interrupt config, err: %d, status: 0x%x, out size: 0x%x\\n\",\n\t\t\terr, interrupt_info->status, out_size);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\n \nstruct hinic_hwdev *hinic_init_hwdev(struct pci_dev *pdev, struct devlink *devlink)\n{\n\tstruct hinic_pfhwdev *pfhwdev;\n\tstruct hinic_hwdev *hwdev;\n\tstruct hinic_hwif *hwif;\n\tint err, num_aeqs;\n\n\thwif = devm_kzalloc(&pdev->dev, sizeof(*hwif), GFP_KERNEL);\n\tif (!hwif)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = hinic_init_hwif(hwif, pdev);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Failed to init HW interface\\n\");\n\t\treturn ERR_PTR(err);\n\t}\n\n\tpfhwdev = devm_kzalloc(&pdev->dev, sizeof(*pfhwdev), GFP_KERNEL);\n\tif (!pfhwdev) {\n\t\terr = -ENOMEM;\n\t\tgoto err_pfhwdev_alloc;\n\t}\n\n\thwdev = &pfhwdev->hwdev;\n\thwdev->hwif = hwif;\n\thwdev->devlink_dev = devlink_priv(devlink);\n\thwdev->devlink_dev->hwdev = hwdev;\n\n\terr = init_msix(hwdev);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Failed to init msix\\n\");\n\t\tgoto err_init_msix;\n\t}\n\n\terr = wait_for_outbound_state(hwdev);\n\tif (err) {\n\t\tdev_warn(&pdev->dev, \"outbound - disabled, try again\\n\");\n\t\thinic_outbound_state_set(hwif, HINIC_OUTBOUND_ENABLE);\n\t}\n\n\tnum_aeqs = HINIC_HWIF_NUM_AEQS(hwif);\n\n\terr = hinic_aeqs_init(&hwdev->aeqs, hwif, num_aeqs,\n\t\t\t      HINIC_DEFAULT_AEQ_LEN, HINIC_EQ_PAGE_SIZE,\n\t\t\t      hwdev->msix_entries);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Failed to init async event queues\\n\");\n\t\tgoto err_aeqs_init;\n\t}\n\n\terr = init_pfhwdev(pfhwdev);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Failed to init PF HW device\\n\");\n\t\tgoto err_init_pfhwdev;\n\t}\n\n\terr = hinic_l2nic_reset(hwdev);\n\tif (err)\n\t\tgoto err_l2nic_reset;\n\n\terr = get_dev_cap(hwdev);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Failed to get device capabilities\\n\");\n\t\tgoto err_dev_cap;\n\t}\n\n\tmutex_init(&hwdev->func_to_io.nic_cfg.cfg_mutex);\n\n\terr = hinic_vf_func_init(hwdev);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Failed to init nic mbox\\n\");\n\t\tgoto err_vf_func_init;\n\t}\n\n\terr = init_fw_ctxt(hwdev);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Failed to init function table\\n\");\n\t\tgoto err_init_fw_ctxt;\n\t}\n\n\terr = set_resources_state(hwdev, HINIC_RES_ACTIVE);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Failed to set resources state\\n\");\n\t\tgoto err_resources_state;\n\t}\n\n\treturn hwdev;\n\nerr_resources_state:\nerr_init_fw_ctxt:\n\thinic_vf_func_free(hwdev);\nerr_vf_func_init:\nerr_l2nic_reset:\nerr_dev_cap:\n\tfree_pfhwdev(pfhwdev);\n\nerr_init_pfhwdev:\n\thinic_aeqs_free(&hwdev->aeqs);\n\nerr_aeqs_init:\n\tdisable_msix(hwdev);\n\nerr_init_msix:\nerr_pfhwdev_alloc:\n\thinic_free_hwif(hwif);\n\tif (err > 0)\n\t\terr = -EIO;\n\treturn ERR_PTR(err);\n}\n\n \nvoid hinic_free_hwdev(struct hinic_hwdev *hwdev)\n{\n\tstruct hinic_pfhwdev *pfhwdev = container_of(hwdev,\n\t\t\t\t\t\t     struct hinic_pfhwdev,\n\t\t\t\t\t\t     hwdev);\n\n\tset_resources_state(hwdev, HINIC_RES_CLEAN);\n\n\thinic_vf_func_free(hwdev);\n\n\tfree_pfhwdev(pfhwdev);\n\n\thinic_aeqs_free(&hwdev->aeqs);\n\n\tdisable_msix(hwdev);\n\n\thinic_free_hwif(hwdev->hwif);\n}\n\n \nint hinic_hwdev_num_qps(struct hinic_hwdev *hwdev)\n{\n\tstruct hinic_cap *nic_cap = &hwdev->nic_cap;\n\n\treturn nic_cap->num_qps;\n}\n\n \nstruct hinic_sq *hinic_hwdev_get_sq(struct hinic_hwdev *hwdev, int i)\n{\n\tstruct hinic_func_to_io *func_to_io = &hwdev->func_to_io;\n\tstruct hinic_qp *qp = &func_to_io->qps[i];\n\n\tif (i >= hinic_hwdev_num_qps(hwdev))\n\t\treturn NULL;\n\n\treturn &qp->sq;\n}\n\n \nstruct hinic_rq *hinic_hwdev_get_rq(struct hinic_hwdev *hwdev, int i)\n{\n\tstruct hinic_func_to_io *func_to_io = &hwdev->func_to_io;\n\tstruct hinic_qp *qp = &func_to_io->qps[i];\n\n\tif (i >= hinic_hwdev_num_qps(hwdev))\n\t\treturn NULL;\n\n\treturn &qp->rq;\n}\n\n \nint hinic_hwdev_msix_cnt_set(struct hinic_hwdev *hwdev, u16 msix_index)\n{\n\treturn hinic_msix_attr_cnt_clear(hwdev->hwif, msix_index);\n}\n\n \nint hinic_hwdev_msix_set(struct hinic_hwdev *hwdev, u16 msix_index,\n\t\t\t u8 pending_limit, u8 coalesc_timer,\n\t\t\t u8 lli_timer_cfg, u8 lli_credit_limit,\n\t\t\t u8 resend_timer)\n{\n\treturn hinic_msix_attr_set(hwdev->hwif, msix_index,\n\t\t\t\t   pending_limit, coalesc_timer,\n\t\t\t\t   lli_timer_cfg, lli_credit_limit,\n\t\t\t\t   resend_timer);\n}\n\n \nint hinic_hwdev_hw_ci_addr_set(struct hinic_hwdev *hwdev, struct hinic_sq *sq,\n\t\t\t       u8 pending_limit, u8 coalesc_timer)\n{\n\tstruct hinic_qp *qp = container_of(sq, struct hinic_qp, sq);\n\tstruct hinic_hwif *hwif = hwdev->hwif;\n\tstruct hinic_pfhwdev *pfhwdev;\n\tstruct hinic_cmd_hw_ci hw_ci;\n\n\thw_ci.dma_attr_off  = 0;\n\thw_ci.pending_limit = pending_limit;\n\thw_ci.coalesc_timer = coalesc_timer;\n\n\thw_ci.msix_en = 1;\n\thw_ci.msix_entry_idx = sq->msix_entry;\n\n\thw_ci.func_idx = HINIC_HWIF_FUNC_IDX(hwif);\n\n\thw_ci.sq_id = qp->q_id;\n\n\thw_ci.ci_addr = ADDR_IN_4BYTES(sq->hw_ci_dma_addr);\n\n\tpfhwdev = container_of(hwdev, struct hinic_pfhwdev, hwdev);\n\treturn hinic_msg_to_mgmt(&pfhwdev->pf_to_mgmt,\n\t\t\t\t HINIC_MOD_COMM,\n\t\t\t\t HINIC_COMM_CMD_SQ_HI_CI_SET,\n\t\t\t\t &hw_ci, sizeof(hw_ci), NULL,\n\t\t\t\t NULL, HINIC_MGMT_MSG_SYNC);\n}\n\n \nvoid hinic_hwdev_set_msix_state(struct hinic_hwdev *hwdev, u16 msix_index,\n\t\t\t\tenum hinic_msix_state flag)\n{\n\thinic_set_msix_state(hwdev->hwif, msix_index, flag);\n}\n\nint hinic_get_board_info(struct hinic_hwdev *hwdev,\n\t\t\t struct hinic_comm_board_info *board_info)\n{\n\tu16 out_size = sizeof(*board_info);\n\tstruct hinic_pfhwdev *pfhwdev;\n\tint err;\n\n\tif (!hwdev || !board_info)\n\t\treturn -EINVAL;\n\n\tpfhwdev = container_of(hwdev, struct hinic_pfhwdev, hwdev);\n\n\terr = hinic_msg_to_mgmt(&pfhwdev->pf_to_mgmt, HINIC_MOD_COMM,\n\t\t\t\tHINIC_COMM_CMD_GET_BOARD_INFO,\n\t\t\t\tboard_info, sizeof(*board_info),\n\t\t\t\tboard_info, &out_size, HINIC_MGMT_MSG_SYNC);\n\tif (err || board_info->status || !out_size) {\n\t\tdev_err(&hwdev->hwif->pdev->dev,\n\t\t\t\"Failed to get board info, err: %d, status: 0x%x, out size: 0x%x\\n\",\n\t\t\terr, board_info->status, out_size);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}