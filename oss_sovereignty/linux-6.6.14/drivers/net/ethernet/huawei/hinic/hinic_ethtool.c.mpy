{
  "module_name": "hinic_ethtool.c",
  "hash_id": "ad68a714ec1702545c0a70dfd356529a8f662b7fe649f396f1b834a357b3dcda",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/huawei/hinic/hinic_ethtool.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/pci.h>\n#include <linux/device.h>\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/errno.h>\n#include <linux/interrupt.h>\n#include <linux/etherdevice.h>\n#include <linux/netdevice.h>\n#include <linux/if_vlan.h>\n#include <linux/ethtool.h>\n#include <linux/vmalloc.h>\n#include <linux/sfp.h>\n\n#include \"hinic_hw_qp.h\"\n#include \"hinic_hw_dev.h\"\n#include \"hinic_port.h\"\n#include \"hinic_tx.h\"\n#include \"hinic_rx.h\"\n#include \"hinic_dev.h\"\n\n#define SET_LINK_STR_MAX_LEN\t16\n\n#define GET_SUPPORTED_MODE\t0\n#define GET_ADVERTISED_MODE\t1\n\n#define ETHTOOL_ADD_SUPPORTED_SPEED_LINK_MODE(ecmd, mode)\t\\\n\t\t((ecmd)->supported |=\t\\\n\t\t(1UL << hw_to_ethtool_link_mode_table[mode].link_mode_bit))\n#define ETHTOOL_ADD_ADVERTISED_SPEED_LINK_MODE(ecmd, mode)\t\\\n\t\t((ecmd)->advertising |=\t\\\n\t\t(1UL << hw_to_ethtool_link_mode_table[mode].link_mode_bit))\n#define ETHTOOL_ADD_SUPPORTED_LINK_MODE(ecmd, mode)\t\\\n\t\t\t\t((ecmd)->supported |= SUPPORTED_##mode)\n#define ETHTOOL_ADD_ADVERTISED_LINK_MODE(ecmd, mode)\t\\\n\t\t\t\t((ecmd)->advertising |= ADVERTISED_##mode)\n\n#define COALESCE_PENDING_LIMIT_UNIT\t8\n#define\tCOALESCE_TIMER_CFG_UNIT\t\t9\n#define COALESCE_ALL_QUEUE\t\t0xFFFF\n#define COALESCE_MAX_PENDING_LIMIT\t(255 * COALESCE_PENDING_LIMIT_UNIT)\n#define COALESCE_MAX_TIMER_CFG\t\t(255 * COALESCE_TIMER_CFG_UNIT)\n\nstruct hw2ethtool_link_mode {\n\tenum ethtool_link_mode_bit_indices link_mode_bit;\n\tu32 speed;\n\tenum hinic_link_mode hw_link_mode;\n};\n\nstruct cmd_link_settings {\n\tu64\tsupported;\n\tu64\tadvertising;\n\n\tu32\tspeed;\n\tu8\tduplex;\n\tu8\tport;\n\tu8\tautoneg;\n};\n\nstatic u32 hw_to_ethtool_speed[LINK_SPEED_LEVELS] = {\n\tSPEED_10, SPEED_100,\n\tSPEED_1000, SPEED_10000,\n\tSPEED_25000, SPEED_40000,\n\tSPEED_100000\n};\n\nstatic struct hw2ethtool_link_mode\n\thw_to_ethtool_link_mode_table[HINIC_LINK_MODE_NUMBERS] = {\n\t{\n\t\t.link_mode_bit = ETHTOOL_LINK_MODE_10000baseKR_Full_BIT,\n\t\t.speed = SPEED_10000,\n\t\t.hw_link_mode = HINIC_10GE_BASE_KR,\n\t},\n\t{\n\t\t.link_mode_bit = ETHTOOL_LINK_MODE_40000baseKR4_Full_BIT,\n\t\t.speed = SPEED_40000,\n\t\t.hw_link_mode = HINIC_40GE_BASE_KR4,\n\t},\n\t{\n\t\t.link_mode_bit = ETHTOOL_LINK_MODE_40000baseCR4_Full_BIT,\n\t\t.speed = SPEED_40000,\n\t\t.hw_link_mode = HINIC_40GE_BASE_CR4,\n\t},\n\t{\n\t\t.link_mode_bit = ETHTOOL_LINK_MODE_100000baseKR4_Full_BIT,\n\t\t.speed = SPEED_100000,\n\t\t.hw_link_mode = HINIC_100GE_BASE_KR4,\n\t},\n\t{\n\t\t.link_mode_bit = ETHTOOL_LINK_MODE_100000baseCR4_Full_BIT,\n\t\t.speed = SPEED_100000,\n\t\t.hw_link_mode = HINIC_100GE_BASE_CR4,\n\t},\n\t{\n\t\t.link_mode_bit = ETHTOOL_LINK_MODE_25000baseKR_Full_BIT,\n\t\t.speed = SPEED_25000,\n\t\t.hw_link_mode = HINIC_25GE_BASE_KR_S,\n\t},\n\t{\n\t\t.link_mode_bit = ETHTOOL_LINK_MODE_25000baseCR_Full_BIT,\n\t\t.speed = SPEED_25000,\n\t\t.hw_link_mode = HINIC_25GE_BASE_CR_S,\n\t},\n\t{\n\t\t.link_mode_bit = ETHTOOL_LINK_MODE_25000baseKR_Full_BIT,\n\t\t.speed = SPEED_25000,\n\t\t.hw_link_mode = HINIC_25GE_BASE_KR,\n\t},\n\t{\n\t\t.link_mode_bit = ETHTOOL_LINK_MODE_25000baseCR_Full_BIT,\n\t\t.speed = SPEED_25000,\n\t\t.hw_link_mode = HINIC_25GE_BASE_CR,\n\t},\n\t{\n\t\t.link_mode_bit = ETHTOOL_LINK_MODE_1000baseKX_Full_BIT,\n\t\t.speed = SPEED_1000,\n\t\t.hw_link_mode = HINIC_GE_BASE_KX,\n\t},\n};\n\n#define LP_DEFAULT_TIME                 5  \n#define LP_PKT_LEN                      1514\n\n#define PORT_DOWN_ERR_IDX\t\t0\nenum diag_test_index {\n\tINTERNAL_LP_TEST = 0,\n\tEXTERNAL_LP_TEST = 1,\n\tDIAG_TEST_MAX = 2,\n};\n\nstatic void set_link_speed(struct ethtool_link_ksettings *link_ksettings,\n\t\t\t   enum hinic_speed speed)\n{\n\tswitch (speed) {\n\tcase HINIC_SPEED_10MB_LINK:\n\t\tlink_ksettings->base.speed = SPEED_10;\n\t\tbreak;\n\n\tcase HINIC_SPEED_100MB_LINK:\n\t\tlink_ksettings->base.speed = SPEED_100;\n\t\tbreak;\n\n\tcase HINIC_SPEED_1000MB_LINK:\n\t\tlink_ksettings->base.speed = SPEED_1000;\n\t\tbreak;\n\n\tcase HINIC_SPEED_10GB_LINK:\n\t\tlink_ksettings->base.speed = SPEED_10000;\n\t\tbreak;\n\n\tcase HINIC_SPEED_25GB_LINK:\n\t\tlink_ksettings->base.speed = SPEED_25000;\n\t\tbreak;\n\n\tcase HINIC_SPEED_40GB_LINK:\n\t\tlink_ksettings->base.speed = SPEED_40000;\n\t\tbreak;\n\n\tcase HINIC_SPEED_100GB_LINK:\n\t\tlink_ksettings->base.speed = SPEED_100000;\n\t\tbreak;\n\n\tdefault:\n\t\tlink_ksettings->base.speed = SPEED_UNKNOWN;\n\t\tbreak;\n\t}\n}\n\nstatic int hinic_get_link_mode_index(enum hinic_link_mode link_mode)\n{\n\tint i = 0;\n\n\tfor (i = 0; i < HINIC_LINK_MODE_NUMBERS; i++) {\n\t\tif (link_mode == hw_to_ethtool_link_mode_table[i].hw_link_mode)\n\t\t\tbreak;\n\t}\n\n\treturn i;\n}\n\nstatic void hinic_add_ethtool_link_mode(struct cmd_link_settings *link_settings,\n\t\t\t\t\tenum hinic_link_mode hw_link_mode,\n\t\t\t\t\tu32 name)\n{\n\tenum hinic_link_mode link_mode;\n\tint idx = 0;\n\n\tfor (link_mode = 0; link_mode < HINIC_LINK_MODE_NUMBERS; link_mode++) {\n\t\tif (hw_link_mode & ((u32)1 << link_mode)) {\n\t\t\tidx = hinic_get_link_mode_index(link_mode);\n\t\t\tif (idx >= HINIC_LINK_MODE_NUMBERS)\n\t\t\t\tcontinue;\n\n\t\t\tif (name == GET_SUPPORTED_MODE)\n\t\t\t\tETHTOOL_ADD_SUPPORTED_SPEED_LINK_MODE\n\t\t\t\t\t(link_settings, idx);\n\t\t\telse\n\t\t\t\tETHTOOL_ADD_ADVERTISED_SPEED_LINK_MODE\n\t\t\t\t\t(link_settings, idx);\n\t\t}\n\t}\n}\n\nstatic void hinic_link_port_type(struct cmd_link_settings *link_settings,\n\t\t\t\t enum hinic_port_type port_type)\n{\n\tswitch (port_type) {\n\tcase HINIC_PORT_ELEC:\n\tcase HINIC_PORT_TP:\n\t\tETHTOOL_ADD_SUPPORTED_LINK_MODE(link_settings, TP);\n\t\tETHTOOL_ADD_ADVERTISED_LINK_MODE(link_settings, TP);\n\t\tlink_settings->port = PORT_TP;\n\t\tbreak;\n\n\tcase HINIC_PORT_AOC:\n\tcase HINIC_PORT_FIBRE:\n\t\tETHTOOL_ADD_SUPPORTED_LINK_MODE(link_settings, FIBRE);\n\t\tETHTOOL_ADD_ADVERTISED_LINK_MODE(link_settings, FIBRE);\n\t\tlink_settings->port = PORT_FIBRE;\n\t\tbreak;\n\n\tcase HINIC_PORT_COPPER:\n\t\tETHTOOL_ADD_SUPPORTED_LINK_MODE(link_settings, FIBRE);\n\t\tETHTOOL_ADD_ADVERTISED_LINK_MODE(link_settings, FIBRE);\n\t\tlink_settings->port = PORT_DA;\n\t\tbreak;\n\n\tcase HINIC_PORT_BACKPLANE:\n\t\tETHTOOL_ADD_SUPPORTED_LINK_MODE(link_settings, Backplane);\n\t\tETHTOOL_ADD_ADVERTISED_LINK_MODE(link_settings, Backplane);\n\t\tlink_settings->port = PORT_NONE;\n\t\tbreak;\n\n\tdefault:\n\t\tlink_settings->port = PORT_OTHER;\n\t\tbreak;\n\t}\n}\n\nstatic int hinic_get_link_ksettings(struct net_device *netdev,\n\t\t\t\t    struct ethtool_link_ksettings\n\t\t\t\t    *link_ksettings)\n{\n\tstruct hinic_dev *nic_dev = netdev_priv(netdev);\n\tstruct hinic_link_mode_cmd link_mode = { 0 };\n\tstruct hinic_pause_config pause_info = { 0 };\n\tstruct cmd_link_settings settings = { 0 };\n\tenum hinic_port_link_state link_state;\n\tstruct hinic_port_cap port_cap;\n\tint err;\n\n\tethtool_link_ksettings_zero_link_mode(link_ksettings, supported);\n\tethtool_link_ksettings_zero_link_mode(link_ksettings, advertising);\n\n\tlink_ksettings->base.speed = SPEED_UNKNOWN;\n\tlink_ksettings->base.autoneg = AUTONEG_DISABLE;\n\tlink_ksettings->base.duplex = DUPLEX_UNKNOWN;\n\n\terr = hinic_port_get_cap(nic_dev, &port_cap);\n\tif (err)\n\t\treturn err;\n\n\thinic_link_port_type(&settings, port_cap.port_type);\n\tlink_ksettings->base.port = settings.port;\n\n\terr = hinic_port_link_state(nic_dev, &link_state);\n\tif (err)\n\t\treturn err;\n\n\tif (link_state == HINIC_LINK_STATE_UP) {\n\t\tset_link_speed(link_ksettings, port_cap.speed);\n\t\tlink_ksettings->base.duplex =\n\t\t\t(port_cap.duplex == HINIC_DUPLEX_FULL) ?\n\t\t\tDUPLEX_FULL : DUPLEX_HALF;\n\t}\n\n\tif (!!(port_cap.autoneg_cap & HINIC_AUTONEG_SUPPORTED))\n\t\tethtool_link_ksettings_add_link_mode(link_ksettings,\n\t\t\t\t\t\t     advertising, Autoneg);\n\n\tif (port_cap.autoneg_state == HINIC_AUTONEG_ACTIVE)\n\t\tlink_ksettings->base.autoneg = AUTONEG_ENABLE;\n\n\terr = hinic_get_link_mode(nic_dev->hwdev, &link_mode);\n\tif (err || link_mode.supported == HINIC_SUPPORTED_UNKNOWN ||\n\t    link_mode.advertised == HINIC_SUPPORTED_UNKNOWN)\n\t\treturn -EIO;\n\n\thinic_add_ethtool_link_mode(&settings, link_mode.supported,\n\t\t\t\t    GET_SUPPORTED_MODE);\n\thinic_add_ethtool_link_mode(&settings, link_mode.advertised,\n\t\t\t\t    GET_ADVERTISED_MODE);\n\n\tif (!HINIC_IS_VF(nic_dev->hwdev->hwif)) {\n\t\terr = hinic_get_hw_pause_info(nic_dev->hwdev, &pause_info);\n\t\tif (err)\n\t\t\treturn err;\n\t\tETHTOOL_ADD_SUPPORTED_LINK_MODE(&settings, Pause);\n\t\tif (pause_info.rx_pause && pause_info.tx_pause) {\n\t\t\tETHTOOL_ADD_ADVERTISED_LINK_MODE(&settings, Pause);\n\t\t} else if (pause_info.tx_pause) {\n\t\t\tETHTOOL_ADD_ADVERTISED_LINK_MODE(&settings, Asym_Pause);\n\t\t} else if (pause_info.rx_pause) {\n\t\t\tETHTOOL_ADD_ADVERTISED_LINK_MODE(&settings, Pause);\n\t\t\tETHTOOL_ADD_ADVERTISED_LINK_MODE(&settings, Asym_Pause);\n\t\t}\n\t}\n\n\tlinkmode_copy(link_ksettings->link_modes.supported,\n\t\t      (unsigned long *)&settings.supported);\n\tlinkmode_copy(link_ksettings->link_modes.advertising,\n\t\t      (unsigned long *)&settings.advertising);\n\n\treturn 0;\n}\n\nstatic int hinic_ethtool_to_hw_speed_level(u32 speed)\n{\n\tint i;\n\n\tfor (i = 0; i < LINK_SPEED_LEVELS; i++) {\n\t\tif (hw_to_ethtool_speed[i] == speed)\n\t\t\tbreak;\n\t}\n\n\treturn i;\n}\n\nstatic bool hinic_is_support_speed(enum hinic_link_mode supported_link,\n\t\t\t\t   u32 speed)\n{\n\tenum hinic_link_mode link_mode;\n\tint idx;\n\n\tfor (link_mode = 0; link_mode < HINIC_LINK_MODE_NUMBERS; link_mode++) {\n\t\tif (!(supported_link & ((u32)1 << link_mode)))\n\t\t\tcontinue;\n\n\t\tidx = hinic_get_link_mode_index(link_mode);\n\t\tif (idx >= HINIC_LINK_MODE_NUMBERS)\n\t\t\tcontinue;\n\n\t\tif (hw_to_ethtool_link_mode_table[idx].speed == speed)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic bool hinic_is_speed_legal(struct hinic_dev *nic_dev, u32 speed)\n{\n\tstruct hinic_link_mode_cmd link_mode = { 0 };\n\tstruct net_device *netdev = nic_dev->netdev;\n\tenum nic_speed_level speed_level = 0;\n\tint err;\n\n\terr = hinic_get_link_mode(nic_dev->hwdev, &link_mode);\n\tif (err)\n\t\treturn false;\n\n\tif (link_mode.supported == HINIC_SUPPORTED_UNKNOWN ||\n\t    link_mode.advertised == HINIC_SUPPORTED_UNKNOWN)\n\t\treturn false;\n\n\tspeed_level = hinic_ethtool_to_hw_speed_level(speed);\n\tif (speed_level >= LINK_SPEED_LEVELS ||\n\t    !hinic_is_support_speed(link_mode.supported, speed)) {\n\t\tnetif_err(nic_dev, drv, netdev,\n\t\t\t  \"Unsupported speed: %d\\n\", speed);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic int get_link_settings_type(struct hinic_dev *nic_dev,\n\t\t\t\t  u8 autoneg, u32 speed, u32 *set_settings)\n{\n\tstruct hinic_port_cap port_cap = { 0 };\n\tint err;\n\n\terr = hinic_port_get_cap(nic_dev, &port_cap);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (port_cap.autoneg_cap)\n\t\t*set_settings |= HILINK_LINK_SET_AUTONEG;\n\n\tif (autoneg == AUTONEG_ENABLE) {\n\t\tif (!port_cap.autoneg_cap) {\n\t\t\tnetif_err(nic_dev, drv, nic_dev->netdev, \"Not support autoneg\\n\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t} else if (speed != (u32)SPEED_UNKNOWN) {\n\t\t \n\t\tif (!hinic_is_speed_legal(nic_dev, speed))\n\t\t\treturn -EINVAL;\n\t\t*set_settings |= HILINK_LINK_SET_SPEED;\n\t} else {\n\t\tnetif_err(nic_dev, drv, nic_dev->netdev, \"Need to set speed when autoneg is off\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic int set_link_settings_separate_cmd(struct hinic_dev *nic_dev,\n\t\t\t\t\t  u32 set_settings, u8 autoneg,\n\t\t\t\t\t  u32 speed)\n{\n\tenum nic_speed_level speed_level = 0;\n\tint err = 0;\n\n\tif (set_settings & HILINK_LINK_SET_AUTONEG) {\n\t\terr = hinic_set_autoneg(nic_dev->hwdev,\n\t\t\t\t\t(autoneg == AUTONEG_ENABLE));\n\t\tif (err)\n\t\t\tnetif_err(nic_dev, drv, nic_dev->netdev, \"%s autoneg failed\\n\",\n\t\t\t\t  (autoneg == AUTONEG_ENABLE) ?\n\t\t\t\t  \"Enable\" : \"Disable\");\n\t\telse\n\t\t\tnetif_info(nic_dev, drv, nic_dev->netdev, \"%s autoneg successfully\\n\",\n\t\t\t\t   (autoneg == AUTONEG_ENABLE) ?\n\t\t\t\t   \"Enable\" : \"Disable\");\n\t}\n\n\tif (!err && (set_settings & HILINK_LINK_SET_SPEED)) {\n\t\tspeed_level = hinic_ethtool_to_hw_speed_level(speed);\n\t\terr = hinic_set_speed(nic_dev->hwdev, speed_level);\n\t\tif (err)\n\t\t\tnetif_err(nic_dev, drv, nic_dev->netdev, \"Set speed %d failed\\n\",\n\t\t\t\t  speed);\n\t\telse\n\t\t\tnetif_info(nic_dev, drv, nic_dev->netdev, \"Set speed %d successfully\\n\",\n\t\t\t\t   speed);\n\t}\n\n\treturn err;\n}\n\nstatic int hinic_set_settings_to_hw(struct hinic_dev *nic_dev,\n\t\t\t\t    u32 set_settings, u8 autoneg, u32 speed)\n{\n\tstruct hinic_link_ksettings_info settings = {0};\n\tchar set_link_str[SET_LINK_STR_MAX_LEN] = {0};\n\tconst char *autoneg_str;\n\tstruct net_device *netdev = nic_dev->netdev;\n\tenum nic_speed_level speed_level = 0;\n\tint err;\n\n\tautoneg_str = (set_settings & HILINK_LINK_SET_AUTONEG) ?\n\t\t      (autoneg ? \"autong enable \" : \"autong disable \") : \"\";\n\n\tif (set_settings & HILINK_LINK_SET_SPEED) {\n\t\tspeed_level = hinic_ethtool_to_hw_speed_level(speed);\n\t\terr = snprintf(set_link_str, SET_LINK_STR_MAX_LEN,\n\t\t\t       \"speed %d \", speed);\n\t\tif (err >= SET_LINK_STR_MAX_LEN) {\n\t\t\tnetif_err(nic_dev, drv, netdev, \"Failed to snprintf link speed, function return(%d) and dest_len(%d)\\n\",\n\t\t\t\t  err, SET_LINK_STR_MAX_LEN);\n\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\n\tsettings.func_id = HINIC_HWIF_FUNC_IDX(nic_dev->hwdev->hwif);\n\tsettings.valid_bitmap = set_settings;\n\tsettings.autoneg = autoneg;\n\tsettings.speed = speed_level;\n\n\terr = hinic_set_link_settings(nic_dev->hwdev, &settings);\n\tif (err != HINIC_MGMT_CMD_UNSUPPORTED) {\n\t\tif (err)\n\t\t\tnetif_err(nic_dev, drv, netdev, \"Set %s%sfailed\\n\",\n\t\t\t\t  autoneg_str, set_link_str);\n\t\telse\n\t\t\tnetif_info(nic_dev, drv, netdev, \"Set %s%ssuccessfully\\n\",\n\t\t\t\t   autoneg_str, set_link_str);\n\n\t\treturn err;\n\t}\n\n\treturn set_link_settings_separate_cmd(nic_dev, set_settings, autoneg,\n\t\t\t\t\t      speed);\n}\n\nstatic int set_link_settings(struct net_device *netdev, u8 autoneg, u32 speed)\n{\n\tstruct hinic_dev *nic_dev = netdev_priv(netdev);\n\tu32 set_settings = 0;\n\tint err;\n\n\terr = get_link_settings_type(nic_dev, autoneg, speed, &set_settings);\n\tif (err)\n\t\treturn err;\n\n\tif (set_settings)\n\t\terr = hinic_set_settings_to_hw(nic_dev, set_settings,\n\t\t\t\t\t       autoneg, speed);\n\telse\n\t\tnetif_info(nic_dev, drv, netdev, \"Nothing changed, exit without setting anything\\n\");\n\n\treturn err;\n}\n\nstatic int hinic_set_link_ksettings(struct net_device *netdev, const struct\n\t\t\t\t    ethtool_link_ksettings *link_settings)\n{\n\t \n\treturn set_link_settings(netdev, link_settings->base.autoneg,\n\t\t\t\t link_settings->base.speed);\n}\n\nstatic void hinic_get_drvinfo(struct net_device *netdev,\n\t\t\t      struct ethtool_drvinfo *info)\n{\n\tstruct hinic_dev *nic_dev = netdev_priv(netdev);\n\tu8 mgmt_ver[HINIC_MGMT_VERSION_MAX_LEN] = {0};\n\tstruct hinic_hwdev *hwdev = nic_dev->hwdev;\n\tstruct hinic_hwif *hwif = hwdev->hwif;\n\tint err;\n\n\tstrscpy(info->driver, HINIC_DRV_NAME, sizeof(info->driver));\n\tstrscpy(info->bus_info, pci_name(hwif->pdev), sizeof(info->bus_info));\n\n\terr = hinic_get_mgmt_version(nic_dev, mgmt_ver);\n\tif (err)\n\t\treturn;\n\n\tsnprintf(info->fw_version, sizeof(info->fw_version), \"%s\", mgmt_ver);\n}\n\nstatic void hinic_get_ringparam(struct net_device *netdev,\n\t\t\t\tstruct ethtool_ringparam *ring,\n\t\t\t\tstruct kernel_ethtool_ringparam *kernel_ring,\n\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct hinic_dev *nic_dev = netdev_priv(netdev);\n\n\tring->rx_max_pending = HINIC_MAX_QUEUE_DEPTH;\n\tring->tx_max_pending = HINIC_MAX_QUEUE_DEPTH;\n\tring->rx_pending = nic_dev->rq_depth;\n\tring->tx_pending = nic_dev->sq_depth;\n}\n\nstatic int check_ringparam_valid(struct hinic_dev *nic_dev,\n\t\t\t\t struct ethtool_ringparam *ring)\n{\n\tif (ring->rx_jumbo_pending || ring->rx_mini_pending) {\n\t\tnetif_err(nic_dev, drv, nic_dev->netdev,\n\t\t\t  \"Unsupported rx_jumbo_pending/rx_mini_pending\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (ring->tx_pending > HINIC_MAX_QUEUE_DEPTH ||\n\t    ring->tx_pending < HINIC_MIN_QUEUE_DEPTH ||\n\t    ring->rx_pending > HINIC_MAX_QUEUE_DEPTH ||\n\t    ring->rx_pending < HINIC_MIN_QUEUE_DEPTH) {\n\t\tnetif_err(nic_dev, drv, nic_dev->netdev,\n\t\t\t  \"Queue depth out of range [%d-%d]\\n\",\n\t\t\t  HINIC_MIN_QUEUE_DEPTH, HINIC_MAX_QUEUE_DEPTH);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int hinic_set_ringparam(struct net_device *netdev,\n\t\t\t       struct ethtool_ringparam *ring,\n\t\t\t       struct kernel_ethtool_ringparam *kernel_ring,\n\t\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct hinic_dev *nic_dev = netdev_priv(netdev);\n\tu16 new_sq_depth, new_rq_depth;\n\tint err;\n\n\terr = check_ringparam_valid(nic_dev, ring);\n\tif (err)\n\t\treturn err;\n\n\tnew_sq_depth = (u16)(1U << (u16)ilog2(ring->tx_pending));\n\tnew_rq_depth = (u16)(1U << (u16)ilog2(ring->rx_pending));\n\n\tif (new_sq_depth == nic_dev->sq_depth &&\n\t    new_rq_depth == nic_dev->rq_depth)\n\t\treturn 0;\n\n\tnetif_info(nic_dev, drv, netdev,\n\t\t   \"Change Tx/Rx ring depth from %d/%d to %d/%d\\n\",\n\t\t   nic_dev->sq_depth, nic_dev->rq_depth,\n\t\t   new_sq_depth, new_rq_depth);\n\n\tnic_dev->sq_depth = new_sq_depth;\n\tnic_dev->rq_depth = new_rq_depth;\n\n\tif (netif_running(netdev)) {\n\t\tnetif_info(nic_dev, drv, netdev, \"Restarting netdev\\n\");\n\t\terr = hinic_close(netdev);\n\t\tif (err) {\n\t\t\tnetif_err(nic_dev, drv, netdev,\n\t\t\t\t  \"Failed to close netdev\\n\");\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\terr = hinic_open(netdev);\n\t\tif (err) {\n\t\t\tnetif_err(nic_dev, drv, netdev,\n\t\t\t\t  \"Failed to open netdev\\n\");\n\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int __hinic_get_coalesce(struct net_device *netdev,\n\t\t\t\tstruct ethtool_coalesce *coal, u16 queue)\n{\n\tstruct hinic_dev *nic_dev = netdev_priv(netdev);\n\tstruct hinic_intr_coal_info *rx_intr_coal_info;\n\tstruct hinic_intr_coal_info *tx_intr_coal_info;\n\n\tif (queue == COALESCE_ALL_QUEUE) {\n\t\t \n\t\trx_intr_coal_info = &nic_dev->rx_intr_coalesce[0];\n\t\ttx_intr_coal_info = &nic_dev->tx_intr_coalesce[0];\n\t} else {\n\t\tif (queue >= nic_dev->num_qps) {\n\t\t\tnetif_err(nic_dev, drv, netdev,\n\t\t\t\t  \"Invalid queue_id: %d\\n\", queue);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\trx_intr_coal_info = &nic_dev->rx_intr_coalesce[queue];\n\t\ttx_intr_coal_info = &nic_dev->tx_intr_coalesce[queue];\n\t}\n\n\t \n\tcoal->rx_coalesce_usecs = rx_intr_coal_info->coalesce_timer_cfg *\n\t\t\tCOALESCE_TIMER_CFG_UNIT;\n\t \n\tcoal->rx_max_coalesced_frames = rx_intr_coal_info->pending_limt *\n\t\t\tCOALESCE_PENDING_LIMIT_UNIT;\n\tcoal->tx_coalesce_usecs = tx_intr_coal_info->coalesce_timer_cfg *\n\t\t\tCOALESCE_TIMER_CFG_UNIT;\n\tcoal->tx_max_coalesced_frames = tx_intr_coal_info->pending_limt *\n\t\t\tCOALESCE_PENDING_LIMIT_UNIT;\n\n\treturn 0;\n}\n\nstatic int is_coalesce_exceed_limit(const struct ethtool_coalesce *coal)\n{\n\tif (coal->rx_coalesce_usecs > COALESCE_MAX_TIMER_CFG ||\n\t    coal->rx_max_coalesced_frames > COALESCE_MAX_PENDING_LIMIT ||\n\t    coal->tx_coalesce_usecs > COALESCE_MAX_TIMER_CFG ||\n\t    coal->tx_max_coalesced_frames > COALESCE_MAX_PENDING_LIMIT)\n\t\treturn -ERANGE;\n\n\treturn 0;\n}\n\nstatic int set_queue_coalesce(struct hinic_dev *nic_dev, u16 q_id,\n\t\t\t      struct hinic_intr_coal_info *coal,\n\t\t\t      bool set_rx_coal)\n{\n\tstruct hinic_intr_coal_info *intr_coal = NULL;\n\tstruct hinic_msix_config interrupt_info = {0};\n\tstruct net_device *netdev = nic_dev->netdev;\n\tu16 msix_idx;\n\tint err;\n\n\tintr_coal = set_rx_coal ? &nic_dev->rx_intr_coalesce[q_id] :\n\t\t    &nic_dev->tx_intr_coalesce[q_id];\n\n\tintr_coal->coalesce_timer_cfg = coal->coalesce_timer_cfg;\n\tintr_coal->pending_limt = coal->pending_limt;\n\n\t \n\tif (!(nic_dev->flags & HINIC_INTF_UP) ||\n\t    q_id >= nic_dev->num_qps)\n\t\treturn 0;\n\n\tmsix_idx = set_rx_coal ? nic_dev->rxqs[q_id].rq->msix_entry :\n\t\t   nic_dev->txqs[q_id].sq->msix_entry;\n\tinterrupt_info.msix_index = msix_idx;\n\tinterrupt_info.coalesce_timer_cnt = intr_coal->coalesce_timer_cfg;\n\tinterrupt_info.pending_cnt = intr_coal->pending_limt;\n\tinterrupt_info.resend_timer_cnt = intr_coal->resend_timer_cfg;\n\n\terr = hinic_set_interrupt_cfg(nic_dev->hwdev, &interrupt_info);\n\tif (err)\n\t\tnetif_warn(nic_dev, drv, netdev,\n\t\t\t   \"Failed to set %s queue%d coalesce\",\n\t\t\t   set_rx_coal ? \"rx\" : \"tx\", q_id);\n\n\treturn err;\n}\n\nstatic int __set_hw_coal_param(struct hinic_dev *nic_dev,\n\t\t\t       struct hinic_intr_coal_info *intr_coal,\n\t\t\t       u16 queue, bool set_rx_coal)\n{\n\tint err;\n\tu16 i;\n\n\tif (queue == COALESCE_ALL_QUEUE) {\n\t\tfor (i = 0; i < nic_dev->max_qps; i++) {\n\t\t\terr = set_queue_coalesce(nic_dev, i, intr_coal,\n\t\t\t\t\t\t set_rx_coal);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t} else {\n\t\tif (queue >= nic_dev->num_qps) {\n\t\t\tnetif_err(nic_dev, drv, nic_dev->netdev,\n\t\t\t\t  \"Invalid queue_id: %d\\n\", queue);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\terr = set_queue_coalesce(nic_dev, queue, intr_coal,\n\t\t\t\t\t set_rx_coal);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int __hinic_set_coalesce(struct net_device *netdev,\n\t\t\t\tstruct ethtool_coalesce *coal, u16 queue)\n{\n\tstruct hinic_dev *nic_dev = netdev_priv(netdev);\n\tstruct hinic_intr_coal_info rx_intr_coal = {0};\n\tstruct hinic_intr_coal_info tx_intr_coal = {0};\n\tbool set_rx_coal = false;\n\tbool set_tx_coal = false;\n\tint err;\n\n\terr = is_coalesce_exceed_limit(coal);\n\tif (err)\n\t\treturn err;\n\n\tif (coal->rx_coalesce_usecs || coal->rx_max_coalesced_frames) {\n\t\trx_intr_coal.coalesce_timer_cfg =\n\t\t(u8)(coal->rx_coalesce_usecs / COALESCE_TIMER_CFG_UNIT);\n\t\trx_intr_coal.pending_limt = (u8)(coal->rx_max_coalesced_frames /\n\t\t\t\tCOALESCE_PENDING_LIMIT_UNIT);\n\t\tset_rx_coal = true;\n\t}\n\n\tif (coal->tx_coalesce_usecs || coal->tx_max_coalesced_frames) {\n\t\ttx_intr_coal.coalesce_timer_cfg =\n\t\t(u8)(coal->tx_coalesce_usecs / COALESCE_TIMER_CFG_UNIT);\n\t\ttx_intr_coal.pending_limt = (u8)(coal->tx_max_coalesced_frames /\n\t\tCOALESCE_PENDING_LIMIT_UNIT);\n\t\tset_tx_coal = true;\n\t}\n\n\t \n\tif (set_rx_coal && (!rx_intr_coal.coalesce_timer_cfg ||\n\t\t\t    !rx_intr_coal.pending_limt))\n\t\tnetif_warn(nic_dev, drv, netdev, \"RX coalesce will be disabled\\n\");\n\tif (set_tx_coal && (!tx_intr_coal.coalesce_timer_cfg ||\n\t\t\t    !tx_intr_coal.pending_limt))\n\t\tnetif_warn(nic_dev, drv, netdev, \"TX coalesce will be disabled\\n\");\n\n\tif (set_rx_coal) {\n\t\terr = __set_hw_coal_param(nic_dev, &rx_intr_coal, queue, true);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tif (set_tx_coal) {\n\t\terr = __set_hw_coal_param(nic_dev, &tx_intr_coal, queue, false);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n\nstatic int hinic_get_coalesce(struct net_device *netdev,\n\t\t\t      struct ethtool_coalesce *coal,\n\t\t\t      struct kernel_ethtool_coalesce *kernel_coal,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\treturn __hinic_get_coalesce(netdev, coal, COALESCE_ALL_QUEUE);\n}\n\nstatic int hinic_set_coalesce(struct net_device *netdev,\n\t\t\t      struct ethtool_coalesce *coal,\n\t\t\t      struct kernel_ethtool_coalesce *kernel_coal,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\treturn __hinic_set_coalesce(netdev, coal, COALESCE_ALL_QUEUE);\n}\n\nstatic int hinic_get_per_queue_coalesce(struct net_device *netdev, u32 queue,\n\t\t\t\t\tstruct ethtool_coalesce *coal)\n{\n\treturn __hinic_get_coalesce(netdev, coal, queue);\n}\n\nstatic int hinic_set_per_queue_coalesce(struct net_device *netdev, u32 queue,\n\t\t\t\t\tstruct ethtool_coalesce *coal)\n{\n\treturn __hinic_set_coalesce(netdev, coal, queue);\n}\n\nstatic void hinic_get_pauseparam(struct net_device *netdev,\n\t\t\t\t struct ethtool_pauseparam *pause)\n{\n\tstruct hinic_dev *nic_dev = netdev_priv(netdev);\n\tstruct hinic_pause_config pause_info = {0};\n\tstruct hinic_nic_cfg *nic_cfg;\n\tint err;\n\n\tnic_cfg = &nic_dev->hwdev->func_to_io.nic_cfg;\n\n\terr = hinic_get_hw_pause_info(nic_dev->hwdev, &pause_info);\n\tif (!err) {\n\t\tpause->autoneg = pause_info.auto_neg;\n\t\tif (nic_cfg->pause_set || !pause_info.auto_neg) {\n\t\t\tpause->rx_pause = nic_cfg->rx_pause;\n\t\t\tpause->tx_pause = nic_cfg->tx_pause;\n\t\t} else {\n\t\t\tpause->rx_pause = pause_info.rx_pause;\n\t\t\tpause->tx_pause = pause_info.tx_pause;\n\t\t}\n\t}\n}\n\nstatic int hinic_set_pauseparam(struct net_device *netdev,\n\t\t\t\tstruct ethtool_pauseparam *pause)\n{\n\tstruct hinic_dev *nic_dev = netdev_priv(netdev);\n\tstruct hinic_pause_config pause_info = {0};\n\tstruct hinic_port_cap port_cap = {0};\n\tint err;\n\n\terr = hinic_port_get_cap(nic_dev, &port_cap);\n\tif (err)\n\t\treturn -EIO;\n\n\tif (pause->autoneg != port_cap.autoneg_state)\n\t\treturn -EOPNOTSUPP;\n\n\tpause_info.auto_neg = pause->autoneg;\n\tpause_info.rx_pause = pause->rx_pause;\n\tpause_info.tx_pause = pause->tx_pause;\n\n\tmutex_lock(&nic_dev->hwdev->func_to_io.nic_cfg.cfg_mutex);\n\terr = hinic_set_hw_pause_info(nic_dev->hwdev, &pause_info);\n\tif (err) {\n\t\tmutex_unlock(&nic_dev->hwdev->func_to_io.nic_cfg.cfg_mutex);\n\t\treturn err;\n\t}\n\tnic_dev->hwdev->func_to_io.nic_cfg.pause_set = true;\n\tnic_dev->hwdev->func_to_io.nic_cfg.auto_neg = pause->autoneg;\n\tnic_dev->hwdev->func_to_io.nic_cfg.rx_pause = pause->rx_pause;\n\tnic_dev->hwdev->func_to_io.nic_cfg.tx_pause = pause->tx_pause;\n\tmutex_unlock(&nic_dev->hwdev->func_to_io.nic_cfg.cfg_mutex);\n\n\treturn 0;\n}\n\nstatic void hinic_get_channels(struct net_device *netdev,\n\t\t\t       struct ethtool_channels *channels)\n{\n\tstruct hinic_dev *nic_dev = netdev_priv(netdev);\n\tstruct hinic_hwdev *hwdev = nic_dev->hwdev;\n\n\tchannels->max_combined = nic_dev->max_qps;\n\tchannels->combined_count = hinic_hwdev_num_qps(hwdev);\n}\n\nstatic int hinic_set_channels(struct net_device *netdev,\n\t\t\t      struct ethtool_channels *channels)\n{\n\tstruct hinic_dev *nic_dev = netdev_priv(netdev);\n\tunsigned int count = channels->combined_count;\n\tint err;\n\n\tnetif_info(nic_dev, drv, netdev, \"Set max combined queue number from %d to %d\\n\",\n\t\t   hinic_hwdev_num_qps(nic_dev->hwdev), count);\n\n\tif (netif_running(netdev)) {\n\t\tnetif_info(nic_dev, drv, netdev, \"Restarting netdev\\n\");\n\t\thinic_close(netdev);\n\n\t\tnic_dev->hwdev->nic_cap.num_qps = count;\n\n\t\terr = hinic_open(netdev);\n\t\tif (err) {\n\t\t\tnetif_err(nic_dev, drv, netdev,\n\t\t\t\t  \"Failed to open netdev\\n\");\n\t\t\treturn -EFAULT;\n\t\t}\n\t} else {\n\t\tnic_dev->hwdev->nic_cap.num_qps = count;\n\t}\n\n\treturn 0;\n}\n\nstatic int hinic_get_rss_hash_opts(struct hinic_dev *nic_dev,\n\t\t\t\t   struct ethtool_rxnfc *cmd)\n{\n\tstruct hinic_rss_type rss_type = { 0 };\n\tint err;\n\n\tcmd->data = 0;\n\n\tif (!(nic_dev->flags & HINIC_RSS_ENABLE))\n\t\treturn 0;\n\n\terr = hinic_get_rss_type(nic_dev, nic_dev->rss_tmpl_idx,\n\t\t\t\t &rss_type);\n\tif (err)\n\t\treturn err;\n\n\tcmd->data = RXH_IP_SRC | RXH_IP_DST;\n\tswitch (cmd->flow_type) {\n\tcase TCP_V4_FLOW:\n\t\tif (rss_type.tcp_ipv4)\n\t\t\tcmd->data |= RXH_L4_B_0_1 | RXH_L4_B_2_3;\n\t\tbreak;\n\tcase TCP_V6_FLOW:\n\t\tif (rss_type.tcp_ipv6)\n\t\t\tcmd->data |= RXH_L4_B_0_1 | RXH_L4_B_2_3;\n\t\tbreak;\n\tcase UDP_V4_FLOW:\n\t\tif (rss_type.udp_ipv4)\n\t\t\tcmd->data |= RXH_L4_B_0_1 | RXH_L4_B_2_3;\n\t\tbreak;\n\tcase UDP_V6_FLOW:\n\t\tif (rss_type.udp_ipv6)\n\t\t\tcmd->data |= RXH_L4_B_0_1 | RXH_L4_B_2_3;\n\t\tbreak;\n\tcase IPV4_FLOW:\n\tcase IPV6_FLOW:\n\t\tbreak;\n\tdefault:\n\t\tcmd->data = 0;\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int set_l4_rss_hash_ops(struct ethtool_rxnfc *cmd,\n\t\t\t       struct hinic_rss_type *rss_type)\n{\n\tu8 rss_l4_en = 0;\n\n\tswitch (cmd->data & (RXH_L4_B_0_1 | RXH_L4_B_2_3)) {\n\tcase 0:\n\t\trss_l4_en = 0;\n\t\tbreak;\n\tcase (RXH_L4_B_0_1 | RXH_L4_B_2_3):\n\t\trss_l4_en = 1;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (cmd->flow_type) {\n\tcase TCP_V4_FLOW:\n\t\trss_type->tcp_ipv4 = rss_l4_en;\n\t\tbreak;\n\tcase TCP_V6_FLOW:\n\t\trss_type->tcp_ipv6 = rss_l4_en;\n\t\tbreak;\n\tcase UDP_V4_FLOW:\n\t\trss_type->udp_ipv4 = rss_l4_en;\n\t\tbreak;\n\tcase UDP_V6_FLOW:\n\t\trss_type->udp_ipv6 = rss_l4_en;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int hinic_set_rss_hash_opts(struct hinic_dev *nic_dev,\n\t\t\t\t   struct ethtool_rxnfc *cmd)\n{\n\tstruct hinic_rss_type *rss_type = &nic_dev->rss_type;\n\tint err;\n\n\tif (!(nic_dev->flags & HINIC_RSS_ENABLE)) {\n\t\tcmd->data = 0;\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t \n\tif (cmd->data & ~(RXH_IP_SRC | RXH_IP_DST | RXH_L4_B_0_1 |\n\t\tRXH_L4_B_2_3))\n\t\treturn -EINVAL;\n\n\t \n\tif (!(cmd->data & RXH_IP_SRC) || !(cmd->data & RXH_IP_DST))\n\t\treturn -EINVAL;\n\n\terr = hinic_get_rss_type(nic_dev,\n\t\t\t\t nic_dev->rss_tmpl_idx, rss_type);\n\tif (err)\n\t\treturn -EFAULT;\n\n\tswitch (cmd->flow_type) {\n\tcase TCP_V4_FLOW:\n\tcase TCP_V6_FLOW:\n\tcase UDP_V4_FLOW:\n\tcase UDP_V6_FLOW:\n\t\terr = set_l4_rss_hash_ops(cmd, rss_type);\n\t\tif (err)\n\t\t\treturn err;\n\t\tbreak;\n\tcase IPV4_FLOW:\n\t\trss_type->ipv4 = 1;\n\t\tbreak;\n\tcase IPV6_FLOW:\n\t\trss_type->ipv6 = 1;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\terr = hinic_set_rss_type(nic_dev, nic_dev->rss_tmpl_idx,\n\t\t\t\t *rss_type);\n\tif (err)\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int __set_rss_rxfh(struct net_device *netdev,\n\t\t\t  const u32 *indir, const u8 *key)\n{\n\tstruct hinic_dev *nic_dev = netdev_priv(netdev);\n\tint err;\n\n\tif (indir) {\n\t\tif (!nic_dev->rss_indir_user) {\n\t\t\tnic_dev->rss_indir_user =\n\t\t\t\tkzalloc(sizeof(u32) * HINIC_RSS_INDIR_SIZE,\n\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (!nic_dev->rss_indir_user)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tmemcpy(nic_dev->rss_indir_user, indir,\n\t\t       sizeof(u32) * HINIC_RSS_INDIR_SIZE);\n\n\t\terr = hinic_rss_set_indir_tbl(nic_dev,\n\t\t\t\t\t      nic_dev->rss_tmpl_idx, indir);\n\t\tif (err)\n\t\t\treturn -EFAULT;\n\t}\n\n\tif (key) {\n\t\tif (!nic_dev->rss_hkey_user) {\n\t\t\tnic_dev->rss_hkey_user =\n\t\t\t\tkzalloc(HINIC_RSS_KEY_SIZE * 2, GFP_KERNEL);\n\n\t\t\tif (!nic_dev->rss_hkey_user)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tmemcpy(nic_dev->rss_hkey_user, key, HINIC_RSS_KEY_SIZE);\n\n\t\terr = hinic_rss_set_template_tbl(nic_dev,\n\t\t\t\t\t\t nic_dev->rss_tmpl_idx, key);\n\t\tif (err)\n\t\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n}\n\nstatic int hinic_get_rxnfc(struct net_device *netdev,\n\t\t\t   struct ethtool_rxnfc *cmd, u32 *rule_locs)\n{\n\tstruct hinic_dev *nic_dev = netdev_priv(netdev);\n\tint err = 0;\n\n\tswitch (cmd->cmd) {\n\tcase ETHTOOL_GRXRINGS:\n\t\tcmd->data = nic_dev->num_qps;\n\t\tbreak;\n\tcase ETHTOOL_GRXFH:\n\t\terr = hinic_get_rss_hash_opts(nic_dev, cmd);\n\t\tbreak;\n\tdefault:\n\t\terr = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nstatic int hinic_set_rxnfc(struct net_device *netdev, struct ethtool_rxnfc *cmd)\n{\n\tstruct hinic_dev *nic_dev = netdev_priv(netdev);\n\tint err = 0;\n\n\tswitch (cmd->cmd) {\n\tcase ETHTOOL_SRXFH:\n\t\terr = hinic_set_rss_hash_opts(nic_dev, cmd);\n\t\tbreak;\n\tdefault:\n\t\terr = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nstatic int hinic_get_rxfh(struct net_device *netdev,\n\t\t\t  u32 *indir, u8 *key, u8 *hfunc)\n{\n\tstruct hinic_dev *nic_dev = netdev_priv(netdev);\n\tu8 hash_engine_type = 0;\n\tint err = 0;\n\n\tif (!(nic_dev->flags & HINIC_RSS_ENABLE))\n\t\treturn -EOPNOTSUPP;\n\n\tif (hfunc) {\n\t\terr = hinic_rss_get_hash_engine(nic_dev,\n\t\t\t\t\t\tnic_dev->rss_tmpl_idx,\n\t\t\t\t\t\t&hash_engine_type);\n\t\tif (err)\n\t\t\treturn -EFAULT;\n\n\t\t*hfunc = hash_engine_type ? ETH_RSS_HASH_TOP : ETH_RSS_HASH_XOR;\n\t}\n\n\tif (indir) {\n\t\terr = hinic_rss_get_indir_tbl(nic_dev,\n\t\t\t\t\t      nic_dev->rss_tmpl_idx, indir);\n\t\tif (err)\n\t\t\treturn -EFAULT;\n\t}\n\n\tif (key)\n\t\terr = hinic_rss_get_template_tbl(nic_dev,\n\t\t\t\t\t\t nic_dev->rss_tmpl_idx, key);\n\n\treturn err;\n}\n\nstatic int hinic_set_rxfh(struct net_device *netdev, const u32 *indir,\n\t\t\t  const u8 *key, const u8 hfunc)\n{\n\tstruct hinic_dev *nic_dev = netdev_priv(netdev);\n\tint err = 0;\n\n\tif (!(nic_dev->flags & HINIC_RSS_ENABLE))\n\t\treturn -EOPNOTSUPP;\n\n\tif (hfunc != ETH_RSS_HASH_NO_CHANGE) {\n\t\tif (hfunc != ETH_RSS_HASH_TOP && hfunc != ETH_RSS_HASH_XOR)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tnic_dev->rss_hash_engine = (hfunc == ETH_RSS_HASH_XOR) ?\n\t\t\tHINIC_RSS_HASH_ENGINE_TYPE_XOR :\n\t\t\tHINIC_RSS_HASH_ENGINE_TYPE_TOEP;\n\t\terr = hinic_rss_set_hash_engine\n\t\t\t(nic_dev, nic_dev->rss_tmpl_idx,\n\t\t\tnic_dev->rss_hash_engine);\n\t\tif (err)\n\t\t\treturn -EFAULT;\n\t}\n\n\terr = __set_rss_rxfh(netdev, indir, key);\n\n\treturn err;\n}\n\nstatic u32 hinic_get_rxfh_key_size(struct net_device *netdev)\n{\n\treturn HINIC_RSS_KEY_SIZE;\n}\n\nstatic u32 hinic_get_rxfh_indir_size(struct net_device *netdev)\n{\n\treturn HINIC_RSS_INDIR_SIZE;\n}\n\n#define HINIC_FUNC_STAT(_stat_item) {\t\\\n\t.name = #_stat_item, \\\n\t.size = sizeof_field(struct hinic_vport_stats, _stat_item), \\\n\t.offset = offsetof(struct hinic_vport_stats, _stat_item) \\\n}\n\nstatic struct hinic_stats hinic_function_stats[] = {\n\tHINIC_FUNC_STAT(tx_unicast_pkts_vport),\n\tHINIC_FUNC_STAT(tx_unicast_bytes_vport),\n\tHINIC_FUNC_STAT(tx_multicast_pkts_vport),\n\tHINIC_FUNC_STAT(tx_multicast_bytes_vport),\n\tHINIC_FUNC_STAT(tx_broadcast_pkts_vport),\n\tHINIC_FUNC_STAT(tx_broadcast_bytes_vport),\n\n\tHINIC_FUNC_STAT(rx_unicast_pkts_vport),\n\tHINIC_FUNC_STAT(rx_unicast_bytes_vport),\n\tHINIC_FUNC_STAT(rx_multicast_pkts_vport),\n\tHINIC_FUNC_STAT(rx_multicast_bytes_vport),\n\tHINIC_FUNC_STAT(rx_broadcast_pkts_vport),\n\tHINIC_FUNC_STAT(rx_broadcast_bytes_vport),\n\n\tHINIC_FUNC_STAT(tx_discard_vport),\n\tHINIC_FUNC_STAT(rx_discard_vport),\n\tHINIC_FUNC_STAT(tx_err_vport),\n\tHINIC_FUNC_STAT(rx_err_vport),\n};\n\nstatic char hinic_test_strings[][ETH_GSTRING_LEN] = {\n\t\"Internal lb test  (on/offline)\",\n\t\"External lb test (external_lb)\",\n};\n\n#define HINIC_PORT_STAT(_stat_item) { \\\n\t.name = #_stat_item, \\\n\t.size = sizeof_field(struct hinic_phy_port_stats, _stat_item), \\\n\t.offset = offsetof(struct hinic_phy_port_stats, _stat_item) \\\n}\n\nstatic struct hinic_stats hinic_port_stats[] = {\n\tHINIC_PORT_STAT(mac_rx_total_pkt_num),\n\tHINIC_PORT_STAT(mac_rx_total_oct_num),\n\tHINIC_PORT_STAT(mac_rx_bad_pkt_num),\n\tHINIC_PORT_STAT(mac_rx_bad_oct_num),\n\tHINIC_PORT_STAT(mac_rx_good_pkt_num),\n\tHINIC_PORT_STAT(mac_rx_good_oct_num),\n\tHINIC_PORT_STAT(mac_rx_uni_pkt_num),\n\tHINIC_PORT_STAT(mac_rx_multi_pkt_num),\n\tHINIC_PORT_STAT(mac_rx_broad_pkt_num),\n\tHINIC_PORT_STAT(mac_tx_total_pkt_num),\n\tHINIC_PORT_STAT(mac_tx_total_oct_num),\n\tHINIC_PORT_STAT(mac_tx_bad_pkt_num),\n\tHINIC_PORT_STAT(mac_tx_bad_oct_num),\n\tHINIC_PORT_STAT(mac_tx_good_pkt_num),\n\tHINIC_PORT_STAT(mac_tx_good_oct_num),\n\tHINIC_PORT_STAT(mac_tx_uni_pkt_num),\n\tHINIC_PORT_STAT(mac_tx_multi_pkt_num),\n\tHINIC_PORT_STAT(mac_tx_broad_pkt_num),\n\tHINIC_PORT_STAT(mac_rx_fragment_pkt_num),\n\tHINIC_PORT_STAT(mac_rx_undersize_pkt_num),\n\tHINIC_PORT_STAT(mac_rx_undermin_pkt_num),\n\tHINIC_PORT_STAT(mac_rx_64_oct_pkt_num),\n\tHINIC_PORT_STAT(mac_rx_65_127_oct_pkt_num),\n\tHINIC_PORT_STAT(mac_rx_128_255_oct_pkt_num),\n\tHINIC_PORT_STAT(mac_rx_256_511_oct_pkt_num),\n\tHINIC_PORT_STAT(mac_rx_512_1023_oct_pkt_num),\n\tHINIC_PORT_STAT(mac_rx_1024_1518_oct_pkt_num),\n\tHINIC_PORT_STAT(mac_rx_1519_2047_oct_pkt_num),\n\tHINIC_PORT_STAT(mac_rx_2048_4095_oct_pkt_num),\n\tHINIC_PORT_STAT(mac_rx_4096_8191_oct_pkt_num),\n\tHINIC_PORT_STAT(mac_rx_8192_9216_oct_pkt_num),\n\tHINIC_PORT_STAT(mac_rx_9217_12287_oct_pkt_num),\n\tHINIC_PORT_STAT(mac_rx_12288_16383_oct_pkt_num),\n\tHINIC_PORT_STAT(mac_rx_1519_max_good_pkt_num),\n\tHINIC_PORT_STAT(mac_rx_1519_max_bad_pkt_num),\n\tHINIC_PORT_STAT(mac_rx_oversize_pkt_num),\n\tHINIC_PORT_STAT(mac_rx_jabber_pkt_num),\n\tHINIC_PORT_STAT(mac_rx_pause_num),\n\tHINIC_PORT_STAT(mac_rx_pfc_pkt_num),\n\tHINIC_PORT_STAT(mac_rx_pfc_pri0_pkt_num),\n\tHINIC_PORT_STAT(mac_rx_pfc_pri1_pkt_num),\n\tHINIC_PORT_STAT(mac_rx_pfc_pri2_pkt_num),\n\tHINIC_PORT_STAT(mac_rx_pfc_pri3_pkt_num),\n\tHINIC_PORT_STAT(mac_rx_pfc_pri4_pkt_num),\n\tHINIC_PORT_STAT(mac_rx_pfc_pri5_pkt_num),\n\tHINIC_PORT_STAT(mac_rx_pfc_pri6_pkt_num),\n\tHINIC_PORT_STAT(mac_rx_pfc_pri7_pkt_num),\n\tHINIC_PORT_STAT(mac_rx_control_pkt_num),\n\tHINIC_PORT_STAT(mac_rx_sym_err_pkt_num),\n\tHINIC_PORT_STAT(mac_rx_fcs_err_pkt_num),\n\tHINIC_PORT_STAT(mac_rx_send_app_good_pkt_num),\n\tHINIC_PORT_STAT(mac_rx_send_app_bad_pkt_num),\n\tHINIC_PORT_STAT(mac_tx_fragment_pkt_num),\n\tHINIC_PORT_STAT(mac_tx_undersize_pkt_num),\n\tHINIC_PORT_STAT(mac_tx_undermin_pkt_num),\n\tHINIC_PORT_STAT(mac_tx_64_oct_pkt_num),\n\tHINIC_PORT_STAT(mac_tx_65_127_oct_pkt_num),\n\tHINIC_PORT_STAT(mac_tx_128_255_oct_pkt_num),\n\tHINIC_PORT_STAT(mac_tx_256_511_oct_pkt_num),\n\tHINIC_PORT_STAT(mac_tx_512_1023_oct_pkt_num),\n\tHINIC_PORT_STAT(mac_tx_1024_1518_oct_pkt_num),\n\tHINIC_PORT_STAT(mac_tx_1519_2047_oct_pkt_num),\n\tHINIC_PORT_STAT(mac_tx_2048_4095_oct_pkt_num),\n\tHINIC_PORT_STAT(mac_tx_4096_8191_oct_pkt_num),\n\tHINIC_PORT_STAT(mac_tx_8192_9216_oct_pkt_num),\n\tHINIC_PORT_STAT(mac_tx_9217_12287_oct_pkt_num),\n\tHINIC_PORT_STAT(mac_tx_12288_16383_oct_pkt_num),\n\tHINIC_PORT_STAT(mac_tx_1519_max_good_pkt_num),\n\tHINIC_PORT_STAT(mac_tx_1519_max_bad_pkt_num),\n\tHINIC_PORT_STAT(mac_tx_oversize_pkt_num),\n\tHINIC_PORT_STAT(mac_tx_jabber_pkt_num),\n\tHINIC_PORT_STAT(mac_tx_pause_num),\n\tHINIC_PORT_STAT(mac_tx_pfc_pkt_num),\n\tHINIC_PORT_STAT(mac_tx_pfc_pri0_pkt_num),\n\tHINIC_PORT_STAT(mac_tx_pfc_pri1_pkt_num),\n\tHINIC_PORT_STAT(mac_tx_pfc_pri2_pkt_num),\n\tHINIC_PORT_STAT(mac_tx_pfc_pri3_pkt_num),\n\tHINIC_PORT_STAT(mac_tx_pfc_pri4_pkt_num),\n\tHINIC_PORT_STAT(mac_tx_pfc_pri5_pkt_num),\n\tHINIC_PORT_STAT(mac_tx_pfc_pri6_pkt_num),\n\tHINIC_PORT_STAT(mac_tx_pfc_pri7_pkt_num),\n\tHINIC_PORT_STAT(mac_tx_control_pkt_num),\n\tHINIC_PORT_STAT(mac_tx_err_all_pkt_num),\n\tHINIC_PORT_STAT(mac_tx_from_app_good_pkt_num),\n\tHINIC_PORT_STAT(mac_tx_from_app_bad_pkt_num),\n};\n\n#define HINIC_TXQ_STAT(_stat_item) { \\\n\t.name = \"txq%d_\"#_stat_item, \\\n\t.size = sizeof_field(struct hinic_txq_stats, _stat_item), \\\n\t.offset = offsetof(struct hinic_txq_stats, _stat_item) \\\n}\n\nstatic struct hinic_stats hinic_tx_queue_stats[] = {\n\tHINIC_TXQ_STAT(pkts),\n\tHINIC_TXQ_STAT(bytes),\n\tHINIC_TXQ_STAT(tx_busy),\n\tHINIC_TXQ_STAT(tx_wake),\n\tHINIC_TXQ_STAT(tx_dropped),\n\tHINIC_TXQ_STAT(big_frags_pkts),\n};\n\n#define HINIC_RXQ_STAT(_stat_item) { \\\n\t.name = \"rxq%d_\"#_stat_item, \\\n\t.size = sizeof_field(struct hinic_rxq_stats, _stat_item), \\\n\t.offset = offsetof(struct hinic_rxq_stats, _stat_item) \\\n}\n\nstatic struct hinic_stats hinic_rx_queue_stats[] = {\n\tHINIC_RXQ_STAT(pkts),\n\tHINIC_RXQ_STAT(bytes),\n\tHINIC_RXQ_STAT(errors),\n\tHINIC_RXQ_STAT(csum_errors),\n\tHINIC_RXQ_STAT(other_errors),\n};\n\nstatic void get_drv_queue_stats(struct hinic_dev *nic_dev, u64 *data)\n{\n\tstruct hinic_txq_stats txq_stats;\n\tstruct hinic_rxq_stats rxq_stats;\n\tu16 i = 0, j = 0, qid = 0;\n\tchar *p;\n\n\tfor (qid = 0; qid < nic_dev->num_qps; qid++) {\n\t\tif (!nic_dev->txqs)\n\t\t\tbreak;\n\n\t\thinic_txq_get_stats(&nic_dev->txqs[qid], &txq_stats);\n\t\tfor (j = 0; j < ARRAY_SIZE(hinic_tx_queue_stats); j++, i++) {\n\t\t\tp = (char *)&txq_stats +\n\t\t\t\thinic_tx_queue_stats[j].offset;\n\t\t\tdata[i] = (hinic_tx_queue_stats[j].size ==\n\t\t\t\t\tsizeof(u64)) ? *(u64 *)p : *(u32 *)p;\n\t\t}\n\t}\n\n\tfor (qid = 0; qid < nic_dev->num_qps; qid++) {\n\t\tif (!nic_dev->rxqs)\n\t\t\tbreak;\n\n\t\thinic_rxq_get_stats(&nic_dev->rxqs[qid], &rxq_stats);\n\t\tfor (j = 0; j < ARRAY_SIZE(hinic_rx_queue_stats); j++, i++) {\n\t\t\tp = (char *)&rxq_stats +\n\t\t\t\thinic_rx_queue_stats[j].offset;\n\t\t\tdata[i] = (hinic_rx_queue_stats[j].size ==\n\t\t\t\t\tsizeof(u64)) ? *(u64 *)p : *(u32 *)p;\n\t\t}\n\t}\n}\n\nstatic void hinic_get_ethtool_stats(struct net_device *netdev,\n\t\t\t\t    struct ethtool_stats *stats, u64 *data)\n{\n\tstruct hinic_dev *nic_dev = netdev_priv(netdev);\n\tstruct hinic_vport_stats vport_stats = {0};\n\tstruct hinic_phy_port_stats *port_stats;\n\tu16 i = 0, j = 0;\n\tchar *p;\n\tint err;\n\n\terr = hinic_get_vport_stats(nic_dev, &vport_stats);\n\tif (err)\n\t\tnetif_err(nic_dev, drv, netdev,\n\t\t\t  \"Failed to get vport stats from firmware\\n\");\n\n\tfor (j = 0; j < ARRAY_SIZE(hinic_function_stats); j++, i++) {\n\t\tp = (char *)&vport_stats + hinic_function_stats[j].offset;\n\t\tdata[i] = (hinic_function_stats[j].size ==\n\t\t\t\tsizeof(u64)) ? *(u64 *)p : *(u32 *)p;\n\t}\n\n\tport_stats = kzalloc(sizeof(*port_stats), GFP_KERNEL);\n\tif (!port_stats) {\n\t\tmemset(&data[i], 0,\n\t\t       ARRAY_SIZE(hinic_port_stats) * sizeof(*data));\n\t\ti += ARRAY_SIZE(hinic_port_stats);\n\t\tgoto get_drv_stats;\n\t}\n\n\terr = hinic_get_phy_port_stats(nic_dev, port_stats);\n\tif (err)\n\t\tnetif_err(nic_dev, drv, netdev,\n\t\t\t  \"Failed to get port stats from firmware\\n\");\n\n\tfor (j = 0; j < ARRAY_SIZE(hinic_port_stats); j++, i++) {\n\t\tp = (char *)port_stats + hinic_port_stats[j].offset;\n\t\tdata[i] = (hinic_port_stats[j].size ==\n\t\t\t\tsizeof(u64)) ? *(u64 *)p : *(u32 *)p;\n\t}\n\n\tkfree(port_stats);\n\nget_drv_stats:\n\tget_drv_queue_stats(nic_dev, data + i);\n}\n\nstatic int hinic_get_sset_count(struct net_device *netdev, int sset)\n{\n\tstruct hinic_dev *nic_dev = netdev_priv(netdev);\n\tint count, q_num;\n\n\tswitch (sset) {\n\tcase ETH_SS_TEST:\n\t\treturn ARRAY_SIZE(hinic_test_strings);\n\tcase ETH_SS_STATS:\n\t\tq_num = nic_dev->num_qps;\n\t\tcount = ARRAY_SIZE(hinic_function_stats) +\n\t\t\t(ARRAY_SIZE(hinic_tx_queue_stats) +\n\t\t\tARRAY_SIZE(hinic_rx_queue_stats)) * q_num;\n\n\t\tcount += ARRAY_SIZE(hinic_port_stats);\n\n\t\treturn count;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic void hinic_get_strings(struct net_device *netdev,\n\t\t\t      u32 stringset, u8 *data)\n{\n\tstruct hinic_dev *nic_dev = netdev_priv(netdev);\n\tchar *p = (char *)data;\n\tu16 i, j;\n\n\tswitch (stringset) {\n\tcase ETH_SS_TEST:\n\t\tmemcpy(data, *hinic_test_strings, sizeof(hinic_test_strings));\n\t\treturn;\n\tcase ETH_SS_STATS:\n\t\tfor (i = 0; i < ARRAY_SIZE(hinic_function_stats); i++) {\n\t\t\tmemcpy(p, hinic_function_stats[i].name,\n\t\t\t       ETH_GSTRING_LEN);\n\t\t\tp += ETH_GSTRING_LEN;\n\t\t}\n\n\t\tfor (i = 0; i < ARRAY_SIZE(hinic_port_stats); i++) {\n\t\t\tmemcpy(p, hinic_port_stats[i].name,\n\t\t\t       ETH_GSTRING_LEN);\n\t\t\tp += ETH_GSTRING_LEN;\n\t\t}\n\n\t\tfor (i = 0; i < nic_dev->num_qps; i++) {\n\t\t\tfor (j = 0; j < ARRAY_SIZE(hinic_tx_queue_stats); j++) {\n\t\t\t\tsprintf(p, hinic_tx_queue_stats[j].name, i);\n\t\t\t\tp += ETH_GSTRING_LEN;\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0; i < nic_dev->num_qps; i++) {\n\t\t\tfor (j = 0; j < ARRAY_SIZE(hinic_rx_queue_stats); j++) {\n\t\t\t\tsprintf(p, hinic_rx_queue_stats[j].name, i);\n\t\t\t\tp += ETH_GSTRING_LEN;\n\t\t\t}\n\t\t}\n\n\t\treturn;\n\tdefault:\n\t\treturn;\n\t}\n}\n\nstatic int hinic_run_lp_test(struct hinic_dev *nic_dev, u32 test_time)\n{\n\tu8 *lb_test_rx_buf = nic_dev->lb_test_rx_buf;\n\tstruct net_device *netdev = nic_dev->netdev;\n\tstruct sk_buff *skb_tmp = NULL;\n\tstruct sk_buff *skb = NULL;\n\tu32 cnt = test_time * 5;\n\tu8 *test_data = NULL;\n\tu32 i;\n\tu8 j;\n\n\tskb_tmp = alloc_skb(LP_PKT_LEN, GFP_ATOMIC);\n\tif (!skb_tmp)\n\t\treturn -ENOMEM;\n\n\ttest_data = __skb_put(skb_tmp, LP_PKT_LEN);\n\n\tmemset(test_data, 0xFF, 2 * ETH_ALEN);\n\ttest_data[ETH_ALEN] = 0xFE;\n\ttest_data[2 * ETH_ALEN] = 0x08;\n\ttest_data[2 * ETH_ALEN + 1] = 0x0;\n\n\tfor (i = ETH_HLEN; i < LP_PKT_LEN; i++)\n\t\ttest_data[i] = i & 0xFF;\n\n\tskb_tmp->queue_mapping = 0;\n\tskb_tmp->ip_summed = CHECKSUM_COMPLETE;\n\tskb_tmp->dev = netdev;\n\n\tfor (i = 0; i < cnt; i++) {\n\t\tnic_dev->lb_test_rx_idx = 0;\n\t\tmemset(lb_test_rx_buf, 0, LP_PKT_CNT * LP_PKT_LEN);\n\n\t\tfor (j = 0; j < LP_PKT_CNT; j++) {\n\t\t\tskb = pskb_copy(skb_tmp, GFP_ATOMIC);\n\t\t\tif (!skb) {\n\t\t\t\tdev_kfree_skb_any(skb_tmp);\n\t\t\t\tnetif_err(nic_dev, drv, netdev,\n\t\t\t\t\t  \"Copy skb failed for loopback test\\n\");\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\n\t\t\t \n\t\t\tskb->data[LP_PKT_LEN - 1] = j;\n\n\t\t\tif (hinic_lb_xmit_frame(skb, netdev)) {\n\t\t\t\tdev_kfree_skb_any(skb);\n\t\t\t\tdev_kfree_skb_any(skb_tmp);\n\t\t\t\tnetif_err(nic_dev, drv, netdev,\n\t\t\t\t\t  \"Xmit pkt failed for loopback test\\n\");\n\t\t\t\treturn -EBUSY;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tmsleep(200);\n\n\t\tfor (j = 0; j < LP_PKT_CNT; j++) {\n\t\t\tif (memcmp(lb_test_rx_buf + j * LP_PKT_LEN,\n\t\t\t\t   skb_tmp->data, LP_PKT_LEN - 1) ||\n\t\t\t    (*(lb_test_rx_buf + j * LP_PKT_LEN +\n\t\t\t     LP_PKT_LEN - 1) != j)) {\n\t\t\t\tdev_kfree_skb_any(skb_tmp);\n\t\t\t\tnetif_err(nic_dev, drv, netdev,\n\t\t\t\t\t  \"Compare pkt failed in loopback test(index=0x%02x, data[%d]=0x%02x)\\n\",\n\t\t\t\t\t  j + i * LP_PKT_CNT,\n\t\t\t\t\t  LP_PKT_LEN - 1,\n\t\t\t\t\t  *(lb_test_rx_buf + j * LP_PKT_LEN +\n\t\t\t\t\t    LP_PKT_LEN - 1));\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t}\n\t}\n\n\tdev_kfree_skb_any(skb_tmp);\n\treturn 0;\n}\n\nstatic int do_lp_test(struct hinic_dev *nic_dev, u32 flags, u32 test_time,\n\t\t      enum diag_test_index *test_index)\n{\n\tstruct net_device *netdev = nic_dev->netdev;\n\tu8 *lb_test_rx_buf = NULL;\n\tint err = 0;\n\n\tif (!(flags & ETH_TEST_FL_EXTERNAL_LB)) {\n\t\t*test_index = INTERNAL_LP_TEST;\n\t\tif (hinic_set_loopback_mode(nic_dev->hwdev,\n\t\t\t\t\t    HINIC_INTERNAL_LP_MODE, true)) {\n\t\t\tnetif_err(nic_dev, drv, netdev,\n\t\t\t\t  \"Failed to set port loopback mode before loopback test\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t} else {\n\t\t*test_index = EXTERNAL_LP_TEST;\n\t}\n\n\tlb_test_rx_buf = vmalloc(LP_PKT_CNT * LP_PKT_LEN);\n\tif (!lb_test_rx_buf) {\n\t\terr = -ENOMEM;\n\t} else {\n\t\tnic_dev->lb_test_rx_buf = lb_test_rx_buf;\n\t\tnic_dev->lb_pkt_len = LP_PKT_LEN;\n\t\tnic_dev->flags |= HINIC_LP_TEST;\n\t\terr = hinic_run_lp_test(nic_dev, test_time);\n\t\tnic_dev->flags &= ~HINIC_LP_TEST;\n\t\tmsleep(100);\n\t\tvfree(lb_test_rx_buf);\n\t\tnic_dev->lb_test_rx_buf = NULL;\n\t}\n\n\tif (!(flags & ETH_TEST_FL_EXTERNAL_LB)) {\n\t\tif (hinic_set_loopback_mode(nic_dev->hwdev,\n\t\t\t\t\t    HINIC_INTERNAL_LP_MODE, false)) {\n\t\t\tnetif_err(nic_dev, drv, netdev,\n\t\t\t\t  \"Failed to cancel port loopback mode after loopback test\\n\");\n\t\t\terr = -EIO;\n\t\t}\n\t}\n\n\treturn err;\n}\n\nstatic void hinic_diag_test(struct net_device *netdev,\n\t\t\t    struct ethtool_test *eth_test, u64 *data)\n{\n\tstruct hinic_dev *nic_dev = netdev_priv(netdev);\n\tenum hinic_port_link_state link_state;\n\tenum diag_test_index test_index = 0;\n\tint err = 0;\n\n\tmemset(data, 0, DIAG_TEST_MAX * sizeof(u64));\n\n\t \n\tif (!(nic_dev->flags & HINIC_INTF_UP)) {\n\t\tnetif_err(nic_dev, drv, netdev,\n\t\t\t  \"Do not support loopback test when netdev is closed\\n\");\n\t\teth_test->flags |= ETH_TEST_FL_FAILED;\n\t\tdata[PORT_DOWN_ERR_IDX] = 1;\n\t\treturn;\n\t}\n\n\tnetif_carrier_off(netdev);\n\tnetif_tx_disable(netdev);\n\n\terr = do_lp_test(nic_dev, eth_test->flags, LP_DEFAULT_TIME,\n\t\t\t &test_index);\n\tif (err) {\n\t\teth_test->flags |= ETH_TEST_FL_FAILED;\n\t\tdata[test_index] = 1;\n\t}\n\n\tnetif_tx_wake_all_queues(netdev);\n\n\terr = hinic_port_link_state(nic_dev, &link_state);\n\tif (!err && link_state == HINIC_LINK_STATE_UP)\n\t\tnetif_carrier_on(netdev);\n}\n\nstatic int hinic_set_phys_id(struct net_device *netdev,\n\t\t\t     enum ethtool_phys_id_state state)\n{\n\tstruct hinic_dev *nic_dev = netdev_priv(netdev);\n\tint err = 0;\n\tu8 port;\n\n\tport = nic_dev->hwdev->port_id;\n\n\tswitch (state) {\n\tcase ETHTOOL_ID_ACTIVE:\n\t\terr = hinic_set_led_status(nic_dev->hwdev, port,\n\t\t\t\t\t   HINIC_LED_TYPE_LINK,\n\t\t\t\t\t   HINIC_LED_MODE_FORCE_2HZ);\n\t\tif (err)\n\t\t\tnetif_err(nic_dev, drv, netdev,\n\t\t\t\t  \"Set LED blinking in 2HZ failed\\n\");\n\t\tbreak;\n\n\tcase ETHTOOL_ID_INACTIVE:\n\t\terr = hinic_reset_led_status(nic_dev->hwdev, port);\n\t\tif (err)\n\t\t\tnetif_err(nic_dev, drv, netdev,\n\t\t\t\t  \"Reset LED to original status failed\\n\");\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn err;\n}\n\nstatic int hinic_get_module_info(struct net_device *netdev,\n\t\t\t\t struct ethtool_modinfo *modinfo)\n{\n\tstruct hinic_dev *nic_dev = netdev_priv(netdev);\n\tu8 sfp_type_ext;\n\tu8 sfp_type;\n\tint err;\n\n\terr = hinic_get_sfp_type(nic_dev->hwdev, &sfp_type, &sfp_type_ext);\n\tif (err)\n\t\treturn err;\n\n\tswitch (sfp_type) {\n\tcase SFF8024_ID_SFP:\n\t\tmodinfo->type = ETH_MODULE_SFF_8472;\n\t\tmodinfo->eeprom_len = ETH_MODULE_SFF_8472_LEN;\n\t\tbreak;\n\tcase SFF8024_ID_QSFP_8438:\n\t\tmodinfo->type = ETH_MODULE_SFF_8436;\n\t\tmodinfo->eeprom_len = ETH_MODULE_SFF_8436_MAX_LEN;\n\t\tbreak;\n\tcase SFF8024_ID_QSFP_8436_8636:\n\t\tif (sfp_type_ext >= 0x3) {\n\t\t\tmodinfo->type = ETH_MODULE_SFF_8636;\n\t\t\tmodinfo->eeprom_len = ETH_MODULE_SFF_8636_MAX_LEN;\n\n\t\t} else {\n\t\t\tmodinfo->type = ETH_MODULE_SFF_8436;\n\t\t\tmodinfo->eeprom_len = ETH_MODULE_SFF_8436_MAX_LEN;\n\t\t}\n\t\tbreak;\n\tcase SFF8024_ID_QSFP28_8636:\n\t\tmodinfo->type = ETH_MODULE_SFF_8636;\n\t\tmodinfo->eeprom_len = ETH_MODULE_SFF_8636_MAX_LEN;\n\t\tbreak;\n\tdefault:\n\t\tnetif_warn(nic_dev, drv, netdev,\n\t\t\t   \"Optical module unknown: 0x%x\\n\", sfp_type);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int hinic_get_module_eeprom(struct net_device *netdev,\n\t\t\t\t   struct ethtool_eeprom *ee, u8 *data)\n{\n\tstruct hinic_dev *nic_dev = netdev_priv(netdev);\n\tu8 sfp_data[STD_SFP_INFO_MAX_SIZE];\n\tu16 len;\n\tint err;\n\n\tif (!ee->len || ((ee->len + ee->offset) > STD_SFP_INFO_MAX_SIZE))\n\t\treturn -EINVAL;\n\n\tmemset(data, 0, ee->len);\n\n\terr = hinic_get_sfp_eeprom(nic_dev->hwdev, sfp_data, &len);\n\tif (err)\n\t\treturn err;\n\n\tmemcpy(data, sfp_data + ee->offset, ee->len);\n\n\treturn 0;\n}\n\nstatic int\nhinic_get_link_ext_state(struct net_device *netdev,\n\t\t\t struct ethtool_link_ext_state_info *link_ext_state_info)\n{\n\tstruct hinic_dev *nic_dev = netdev_priv(netdev);\n\n\tif (netif_carrier_ok(netdev))\n\t\treturn -ENODATA;\n\n\tif (nic_dev->cable_unplugged)\n\t\tlink_ext_state_info->link_ext_state =\n\t\t\tETHTOOL_LINK_EXT_STATE_NO_CABLE;\n\telse if (nic_dev->module_unrecognized)\n\t\tlink_ext_state_info->link_ext_state =\n\t\t\tETHTOOL_LINK_EXT_STATE_LINK_LOGICAL_MISMATCH;\n\n\treturn 0;\n}\n\nstatic const struct ethtool_ops hinic_ethtool_ops = {\n\t.supported_coalesce_params = ETHTOOL_COALESCE_RX_USECS |\n\t\t\t\t     ETHTOOL_COALESCE_RX_MAX_FRAMES |\n\t\t\t\t     ETHTOOL_COALESCE_TX_USECS |\n\t\t\t\t     ETHTOOL_COALESCE_TX_MAX_FRAMES,\n\n\t.get_link_ksettings = hinic_get_link_ksettings,\n\t.set_link_ksettings = hinic_set_link_ksettings,\n\t.get_drvinfo = hinic_get_drvinfo,\n\t.get_link = ethtool_op_get_link,\n\t.get_link_ext_state = hinic_get_link_ext_state,\n\t.get_ringparam = hinic_get_ringparam,\n\t.set_ringparam = hinic_set_ringparam,\n\t.get_coalesce = hinic_get_coalesce,\n\t.set_coalesce = hinic_set_coalesce,\n\t.get_per_queue_coalesce = hinic_get_per_queue_coalesce,\n\t.set_per_queue_coalesce = hinic_set_per_queue_coalesce,\n\t.get_pauseparam = hinic_get_pauseparam,\n\t.set_pauseparam = hinic_set_pauseparam,\n\t.get_channels = hinic_get_channels,\n\t.set_channels = hinic_set_channels,\n\t.get_rxnfc = hinic_get_rxnfc,\n\t.set_rxnfc = hinic_set_rxnfc,\n\t.get_rxfh_key_size = hinic_get_rxfh_key_size,\n\t.get_rxfh_indir_size = hinic_get_rxfh_indir_size,\n\t.get_rxfh = hinic_get_rxfh,\n\t.set_rxfh = hinic_set_rxfh,\n\t.get_sset_count = hinic_get_sset_count,\n\t.get_ethtool_stats = hinic_get_ethtool_stats,\n\t.get_strings = hinic_get_strings,\n\t.self_test = hinic_diag_test,\n\t.set_phys_id = hinic_set_phys_id,\n\t.get_module_info = hinic_get_module_info,\n\t.get_module_eeprom = hinic_get_module_eeprom,\n};\n\nstatic const struct ethtool_ops hinicvf_ethtool_ops = {\n\t.supported_coalesce_params = ETHTOOL_COALESCE_RX_USECS |\n\t\t\t\t     ETHTOOL_COALESCE_RX_MAX_FRAMES |\n\t\t\t\t     ETHTOOL_COALESCE_TX_USECS |\n\t\t\t\t     ETHTOOL_COALESCE_TX_MAX_FRAMES,\n\n\t.get_link_ksettings = hinic_get_link_ksettings,\n\t.get_drvinfo = hinic_get_drvinfo,\n\t.get_link = ethtool_op_get_link,\n\t.get_ringparam = hinic_get_ringparam,\n\t.set_ringparam = hinic_set_ringparam,\n\t.get_coalesce = hinic_get_coalesce,\n\t.set_coalesce = hinic_set_coalesce,\n\t.get_per_queue_coalesce = hinic_get_per_queue_coalesce,\n\t.set_per_queue_coalesce = hinic_set_per_queue_coalesce,\n\t.get_channels = hinic_get_channels,\n\t.set_channels = hinic_set_channels,\n\t.get_rxnfc = hinic_get_rxnfc,\n\t.set_rxnfc = hinic_set_rxnfc,\n\t.get_rxfh_key_size = hinic_get_rxfh_key_size,\n\t.get_rxfh_indir_size = hinic_get_rxfh_indir_size,\n\t.get_rxfh = hinic_get_rxfh,\n\t.set_rxfh = hinic_set_rxfh,\n\t.get_sset_count = hinic_get_sset_count,\n\t.get_ethtool_stats = hinic_get_ethtool_stats,\n\t.get_strings = hinic_get_strings,\n};\n\nvoid hinic_set_ethtool_ops(struct net_device *netdev)\n{\n\tstruct hinic_dev *nic_dev = netdev_priv(netdev);\n\n\tif (!HINIC_IS_VF(nic_dev->hwdev->hwif))\n\t\tnetdev->ethtool_ops = &hinic_ethtool_ops;\n\telse\n\t\tnetdev->ethtool_ops = &hinicvf_ethtool_ops;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}