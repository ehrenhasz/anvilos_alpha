{
  "module_name": "hinic_hw_if.c",
  "hash_id": "d2db6d32312f18c5d9d5782afe3d7f9dd6d9bfe71f3fb2c7e453a90faf81fb97",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/huawei/hinic/hinic_hw_if.c",
  "human_readable_source": "\n \n\n#include <linux/pci.h>\n#include <linux/device.h>\n#include <linux/errno.h>\n#include <linux/io.h>\n#include <linux/types.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n\n#include \"hinic_hw_csr.h\"\n#include \"hinic_hw_if.h\"\n\n#define PCIE_ATTR_ENTRY         0\n\n#define VALID_MSIX_IDX(attr, msix_index) ((msix_index) < (attr)->num_irqs)\n\n#define WAIT_HWIF_READY_TIMEOUT\t10000\n\n#define HINIC_SELFTEST_RESULT 0x883C\n\n \nint hinic_msix_attr_set(struct hinic_hwif *hwif, u16 msix_index,\n\t\t\tu8 pending_limit, u8 coalesc_timer,\n\t\t\tu8 lli_timer, u8 lli_credit_limit,\n\t\t\tu8 resend_timer)\n{\n\tu32 msix_ctrl, addr;\n\n\tif (!VALID_MSIX_IDX(&hwif->attr, msix_index))\n\t\treturn -EINVAL;\n\n\tmsix_ctrl = HINIC_MSIX_ATTR_SET(pending_limit, PENDING_LIMIT)   |\n\t\t    HINIC_MSIX_ATTR_SET(coalesc_timer, COALESC_TIMER)   |\n\t\t    HINIC_MSIX_ATTR_SET(lli_timer, LLI_TIMER)           |\n\t\t    HINIC_MSIX_ATTR_SET(lli_credit_limit, LLI_CREDIT)   |\n\t\t    HINIC_MSIX_ATTR_SET(resend_timer, RESEND_TIMER);\n\n\taddr = HINIC_CSR_MSIX_CTRL_ADDR(msix_index);\n\n\thinic_hwif_write_reg(hwif, addr, msix_ctrl);\n\treturn 0;\n}\n\n \nint hinic_msix_attr_cnt_clear(struct hinic_hwif *hwif, u16 msix_index)\n{\n\tu32 msix_ctrl, addr;\n\n\tif (!VALID_MSIX_IDX(&hwif->attr, msix_index))\n\t\treturn -EINVAL;\n\n\tmsix_ctrl = HINIC_MSIX_CNT_SET(1, RESEND_TIMER);\n\taddr = HINIC_CSR_MSIX_CNT_ADDR(msix_index);\n\n\thinic_hwif_write_reg(hwif, addr, msix_ctrl);\n\treturn 0;\n}\n\n \nvoid hinic_set_pf_action(struct hinic_hwif *hwif, enum hinic_pf_action action)\n{\n\tu32 attr5;\n\n\tif (HINIC_IS_VF(hwif))\n\t\treturn;\n\n\tattr5 = hinic_hwif_read_reg(hwif, HINIC_CSR_FUNC_ATTR5_ADDR);\n\tattr5 = HINIC_FA5_CLEAR(attr5, PF_ACTION);\n\tattr5 |= HINIC_FA5_SET(action, PF_ACTION);\n\n\thinic_hwif_write_reg(hwif, HINIC_CSR_FUNC_ATTR5_ADDR, attr5);\n}\n\nenum hinic_outbound_state hinic_outbound_state_get(struct hinic_hwif *hwif)\n{\n\tu32 attr4 = hinic_hwif_read_reg(hwif, HINIC_CSR_FUNC_ATTR4_ADDR);\n\n\treturn HINIC_FA4_GET(attr4, OUTBOUND_STATE);\n}\n\nvoid hinic_outbound_state_set(struct hinic_hwif *hwif,\n\t\t\t      enum hinic_outbound_state outbound_state)\n{\n\tu32 attr4 = hinic_hwif_read_reg(hwif, HINIC_CSR_FUNC_ATTR4_ADDR);\n\n\tattr4 = HINIC_FA4_CLEAR(attr4, OUTBOUND_STATE);\n\tattr4 |= HINIC_FA4_SET(outbound_state, OUTBOUND_STATE);\n\n\thinic_hwif_write_reg(hwif, HINIC_CSR_FUNC_ATTR4_ADDR, attr4);\n}\n\nenum hinic_db_state hinic_db_state_get(struct hinic_hwif *hwif)\n{\n\tu32 attr4 = hinic_hwif_read_reg(hwif, HINIC_CSR_FUNC_ATTR4_ADDR);\n\n\treturn HINIC_FA4_GET(attr4, DB_STATE);\n}\n\nvoid hinic_db_state_set(struct hinic_hwif *hwif,\n\t\t\tenum hinic_db_state db_state)\n{\n\tu32 attr4 = hinic_hwif_read_reg(hwif, HINIC_CSR_FUNC_ATTR4_ADDR);\n\n\tattr4 = HINIC_FA4_CLEAR(attr4, DB_STATE);\n\tattr4 |= HINIC_FA4_SET(db_state, DB_STATE);\n\n\thinic_hwif_write_reg(hwif, HINIC_CSR_FUNC_ATTR4_ADDR, attr4);\n}\n\nvoid hinic_set_msix_state(struct hinic_hwif *hwif, u16 msix_idx,\n\t\t\t  enum hinic_msix_state flag)\n{\n\tu32 offset = msix_idx * HINIC_PCI_MSIX_ENTRY_SIZE +\n\t\t\tHINIC_PCI_MSIX_ENTRY_VECTOR_CTRL;\n\tu32 mask_bits;\n\n\tmask_bits = readl(hwif->intr_regs_base + offset);\n\tmask_bits &= ~HINIC_PCI_MSIX_ENTRY_CTRL_MASKBIT;\n\n\tif (flag)\n\t\tmask_bits |= HINIC_PCI_MSIX_ENTRY_CTRL_MASKBIT;\n\n\twritel(mask_bits, hwif->intr_regs_base + offset);\n}\n\n \nstatic int hwif_ready(struct hinic_hwif *hwif)\n{\n\tu32 addr, attr1;\n\n\taddr   = HINIC_CSR_FUNC_ATTR1_ADDR;\n\tattr1  = hinic_hwif_read_reg(hwif, addr);\n\n\tif (!HINIC_FA1_GET(attr1, MGMT_INIT_STATUS))\n\t\treturn -EBUSY;\n\n\tif (HINIC_IS_VF(hwif)) {\n\t\tif (!HINIC_FA1_GET(attr1, PF_INIT_STATUS))\n\t\t\treturn -EBUSY;\n\t}\n\n\treturn 0;\n}\n\nstatic int wait_hwif_ready(struct hinic_hwif *hwif)\n{\n\tunsigned long timeout = 0;\n\n\tdo {\n\t\tif (!hwif_ready(hwif))\n\t\t\treturn 0;\n\n\t\tusleep_range(999, 1000);\n\t\ttimeout++;\n\t} while (timeout <= WAIT_HWIF_READY_TIMEOUT);\n\n\tdev_err(&hwif->pdev->dev, \"Wait for hwif timeout\\n\");\n\n\treturn -EBUSY;\n}\n\n \nstatic void set_hwif_attr(struct hinic_hwif *hwif, u32 attr0, u32 attr1,\n\t\t\t  u32 attr2)\n{\n\thwif->attr.func_idx     = HINIC_FA0_GET(attr0, FUNC_IDX);\n\thwif->attr.pf_idx       = HINIC_FA0_GET(attr0, PF_IDX);\n\thwif->attr.pci_intf_idx = HINIC_FA0_GET(attr0, PCI_INTF_IDX);\n\thwif->attr.func_type    = HINIC_FA0_GET(attr0, FUNC_TYPE);\n\n\thwif->attr.num_aeqs = BIT(HINIC_FA1_GET(attr1, AEQS_PER_FUNC));\n\thwif->attr.num_ceqs = BIT(HINIC_FA1_GET(attr1, CEQS_PER_FUNC));\n\thwif->attr.num_irqs = BIT(HINIC_FA1_GET(attr1, IRQS_PER_FUNC));\n\thwif->attr.num_dma_attr = BIT(HINIC_FA1_GET(attr1, DMA_ATTR_PER_FUNC));\n\thwif->attr.global_vf_id_of_pf = HINIC_FA2_GET(attr2,\n\t\t\t\t\t\t      GLOBAL_VF_ID_OF_PF);\n}\n\n \nstatic void read_hwif_attr(struct hinic_hwif *hwif)\n{\n\tu32 addr, attr0, attr1, attr2;\n\n\taddr   = HINIC_CSR_FUNC_ATTR0_ADDR;\n\tattr0  = hinic_hwif_read_reg(hwif, addr);\n\n\taddr   = HINIC_CSR_FUNC_ATTR1_ADDR;\n\tattr1  = hinic_hwif_read_reg(hwif, addr);\n\n\taddr   = HINIC_CSR_FUNC_ATTR2_ADDR;\n\tattr2  = hinic_hwif_read_reg(hwif, addr);\n\n\tset_hwif_attr(hwif, attr0, attr1, attr2);\n}\n\n \nstatic void set_ppf(struct hinic_hwif *hwif)\n{\n\tstruct hinic_func_attr *attr = &hwif->attr;\n\tu32 addr, val, ppf_election;\n\n\t \n\taddr = HINIC_CSR_PPF_ELECTION_ADDR(HINIC_HWIF_PCI_INTF(hwif));\n\n\tval = hinic_hwif_read_reg(hwif, addr);\n\tval = HINIC_PPF_ELECTION_CLEAR(val, IDX);\n\n\tppf_election = HINIC_PPF_ELECTION_SET(HINIC_HWIF_FUNC_IDX(hwif), IDX);\n\n\tval |= ppf_election;\n\thinic_hwif_write_reg(hwif, addr, val);\n\n\t \n\tval = hinic_hwif_read_reg(hwif, addr);\n\n\tattr->ppf_idx = HINIC_PPF_ELECTION_GET(val, IDX);\n\tif (attr->ppf_idx == HINIC_HWIF_FUNC_IDX(hwif))\n\t\tattr->func_type = HINIC_PPF;\n}\n\n \nstatic void set_dma_attr(struct hinic_hwif *hwif, u32 entry_idx,\n\t\t\t u8 st, u8 at, u8 ph,\n\t\t\t enum hinic_pcie_nosnoop no_snooping,\n\t\t\t enum hinic_pcie_tph tph_en)\n{\n\tu32 addr, val, dma_attr_entry;\n\n\t \n\taddr = HINIC_CSR_DMA_ATTR_ADDR(entry_idx);\n\n\tval = hinic_hwif_read_reg(hwif, addr);\n\tval = HINIC_DMA_ATTR_CLEAR(val, ST)             &\n\t      HINIC_DMA_ATTR_CLEAR(val, AT)             &\n\t      HINIC_DMA_ATTR_CLEAR(val, PH)             &\n\t      HINIC_DMA_ATTR_CLEAR(val, NO_SNOOPING)    &\n\t      HINIC_DMA_ATTR_CLEAR(val, TPH_EN);\n\n\tdma_attr_entry = HINIC_DMA_ATTR_SET(st, ST)                     |\n\t\t\t HINIC_DMA_ATTR_SET(at, AT)                     |\n\t\t\t HINIC_DMA_ATTR_SET(ph, PH)                     |\n\t\t\t HINIC_DMA_ATTR_SET(no_snooping, NO_SNOOPING)   |\n\t\t\t HINIC_DMA_ATTR_SET(tph_en, TPH_EN);\n\n\tval |= dma_attr_entry;\n\thinic_hwif_write_reg(hwif, addr, val);\n}\n\n \nstatic void dma_attr_init(struct hinic_hwif *hwif)\n{\n\tset_dma_attr(hwif, PCIE_ATTR_ENTRY, HINIC_PCIE_ST_DISABLE,\n\t\t     HINIC_PCIE_AT_DISABLE, HINIC_PCIE_PH_DISABLE,\n\t\t     HINIC_PCIE_SNOOP, HINIC_PCIE_TPH_DISABLE);\n}\n\nu16 hinic_glb_pf_vf_offset(struct hinic_hwif *hwif)\n{\n\tif (!hwif)\n\t\treturn 0;\n\n\treturn hwif->attr.global_vf_id_of_pf;\n}\n\nu16 hinic_global_func_id_hw(struct hinic_hwif *hwif)\n{\n\tu32 addr, attr0;\n\n\taddr   = HINIC_CSR_FUNC_ATTR0_ADDR;\n\tattr0  = hinic_hwif_read_reg(hwif, addr);\n\n\treturn HINIC_FA0_GET(attr0, FUNC_IDX);\n}\n\nu16 hinic_pf_id_of_vf_hw(struct hinic_hwif *hwif)\n{\n\tu32 addr, attr0;\n\n\taddr   = HINIC_CSR_FUNC_ATTR0_ADDR;\n\tattr0  = hinic_hwif_read_reg(hwif, addr);\n\n\treturn HINIC_FA0_GET(attr0, PF_IDX);\n}\n\nstatic void __print_selftest_reg(struct hinic_hwif *hwif)\n{\n\tu32 addr, attr0, attr1;\n\n\taddr   = HINIC_CSR_FUNC_ATTR1_ADDR;\n\tattr1  = hinic_hwif_read_reg(hwif, addr);\n\n\tif (attr1 == HINIC_PCIE_LINK_DOWN) {\n\t\tdev_err(&hwif->pdev->dev, \"PCIE is link down\\n\");\n\t\treturn;\n\t}\n\n\taddr   = HINIC_CSR_FUNC_ATTR0_ADDR;\n\tattr0  = hinic_hwif_read_reg(hwif, addr);\n\tif (HINIC_FA0_GET(attr0, FUNC_TYPE) != HINIC_VF &&\n\t    !HINIC_FA0_GET(attr0, PCI_INTF_IDX))\n\t\tdev_err(&hwif->pdev->dev, \"Selftest reg: 0x%08x\\n\",\n\t\t\thinic_hwif_read_reg(hwif, HINIC_SELFTEST_RESULT));\n}\n\n \nint hinic_init_hwif(struct hinic_hwif *hwif, struct pci_dev *pdev)\n{\n\tint err;\n\n\thwif->pdev = pdev;\n\n\thwif->cfg_regs_bar = pci_ioremap_bar(pdev, HINIC_PCI_CFG_REGS_BAR);\n\tif (!hwif->cfg_regs_bar) {\n\t\tdev_err(&pdev->dev, \"Failed to map configuration regs\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\thwif->intr_regs_base = pci_ioremap_bar(pdev, HINIC_PCI_INTR_REGS_BAR);\n\tif (!hwif->intr_regs_base) {\n\t\tdev_err(&pdev->dev, \"Failed to map configuration regs\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto err_map_intr_bar;\n\t}\n\n\terr = wait_hwif_ready(hwif);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"HW interface is not ready\\n\");\n\t\t__print_selftest_reg(hwif);\n\t\tgoto err_hwif_ready;\n\t}\n\n\tread_hwif_attr(hwif);\n\n\tif (HINIC_IS_PF(hwif))\n\t\tset_ppf(hwif);\n\n\t \n\tdma_attr_init(hwif);\n\treturn 0;\n\nerr_hwif_ready:\n\tiounmap(hwif->intr_regs_base);\n\nerr_map_intr_bar:\n\tiounmap(hwif->cfg_regs_bar);\n\n\treturn err;\n}\n\n \nvoid hinic_free_hwif(struct hinic_hwif *hwif)\n{\n\tiounmap(hwif->intr_regs_base);\n\tiounmap(hwif->cfg_regs_bar);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}