{
  "module_name": "hinic_hw_mgmt.c",
  "hash_id": "2b7af201136e73e5c67f2e5c3faca10ddcb498d133790090a2a1def8910d4c3b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/huawei/hinic/hinic_hw_mgmt.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/errno.h>\n#include <linux/pci.h>\n#include <linux/device.h>\n#include <linux/semaphore.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <net/devlink.h>\n#include <asm/barrier.h>\n\n#include \"hinic_devlink.h\"\n#include \"hinic_hw_if.h\"\n#include \"hinic_hw_eqs.h\"\n#include \"hinic_hw_api_cmd.h\"\n#include \"hinic_hw_mgmt.h\"\n#include \"hinic_hw_dev.h\"\n\n#define SYNC_MSG_ID_MASK                0x1FF\n\n#define SYNC_MSG_ID(pf_to_mgmt)         ((pf_to_mgmt)->sync_msg_id)\n\n#define SYNC_MSG_ID_INC(pf_to_mgmt)     (SYNC_MSG_ID(pf_to_mgmt) = \\\n\t\t\t\t\t((SYNC_MSG_ID(pf_to_mgmt) + 1) & \\\n\t\t\t\t\t SYNC_MSG_ID_MASK))\n\n#define MSG_SZ_IS_VALID(in_size)        ((in_size) <= MAX_MSG_LEN)\n\n#define MGMT_MSG_LEN_MIN                20\n#define MGMT_MSG_LEN_STEP               16\n#define MGMT_MSG_RSVD_FOR_DEV           8\n\n#define SEGMENT_LEN                     48\n\n#define MAX_PF_MGMT_BUF_SIZE            2048\n\n \n#define MAX_MSG_LEN                     2016\n\n#define MSG_NOT_RESP                    0xFFFF\n\n#define MGMT_MSG_TIMEOUT                5000\n\n#define SET_FUNC_PORT_MBOX_TIMEOUT\t30000\n\n#define SET_FUNC_PORT_MGMT_TIMEOUT\t25000\n\n#define UPDATE_FW_MGMT_TIMEOUT\t\t20000\n\n#define mgmt_to_pfhwdev(pf_mgmt)        \\\n\t\tcontainer_of(pf_mgmt, struct hinic_pfhwdev, pf_to_mgmt)\n\nenum msg_segment_type {\n\tNOT_LAST_SEGMENT = 0,\n\tLAST_SEGMENT     = 1,\n};\n\nenum mgmt_direction_type {\n\tMGMT_DIRECT_SEND = 0,\n\tMGMT_RESP        = 1,\n};\n\nenum msg_ack_type {\n\tMSG_ACK         = 0,\n\tMSG_NO_ACK      = 1,\n};\n\n \nvoid hinic_register_mgmt_msg_cb(struct hinic_pf_to_mgmt *pf_to_mgmt,\n\t\t\t\tenum hinic_mod_type mod,\n\t\t\t\tvoid *handle,\n\t\t\t\tvoid (*callback)(void *handle,\n\t\t\t\t\t\t u8 cmd, void *buf_in,\n\t\t\t\t\t\t u16 in_size, void *buf_out,\n\t\t\t\t\t\t u16 *out_size))\n{\n\tstruct hinic_mgmt_cb *mgmt_cb = &pf_to_mgmt->mgmt_cb[mod];\n\n\tmgmt_cb->cb = callback;\n\tmgmt_cb->handle = handle;\n\tmgmt_cb->state = HINIC_MGMT_CB_ENABLED;\n}\n\n \nvoid hinic_unregister_mgmt_msg_cb(struct hinic_pf_to_mgmt *pf_to_mgmt,\n\t\t\t\t  enum hinic_mod_type mod)\n{\n\tstruct hinic_mgmt_cb *mgmt_cb = &pf_to_mgmt->mgmt_cb[mod];\n\n\tmgmt_cb->state &= ~HINIC_MGMT_CB_ENABLED;\n\n\twhile (mgmt_cb->state & HINIC_MGMT_CB_RUNNING)\n\t\tschedule();\n\n\tmgmt_cb->cb = NULL;\n}\n\n \nstatic u64 prepare_header(struct hinic_pf_to_mgmt *pf_to_mgmt,\n\t\t\t  u16 msg_len, enum hinic_mod_type mod,\n\t\t\t  enum msg_ack_type ack_type,\n\t\t\t  enum mgmt_direction_type direction,\n\t\t\t  u16 cmd, u16 msg_id)\n{\n\tstruct hinic_hwif *hwif = pf_to_mgmt->hwif;\n\n\treturn HINIC_MSG_HEADER_SET(msg_len, MSG_LEN)           |\n\t       HINIC_MSG_HEADER_SET(mod, MODULE)                |\n\t       HINIC_MSG_HEADER_SET(SEGMENT_LEN, SEG_LEN)       |\n\t       HINIC_MSG_HEADER_SET(ack_type, NO_ACK)           |\n\t       HINIC_MSG_HEADER_SET(0, ASYNC_MGMT_TO_PF)        |\n\t       HINIC_MSG_HEADER_SET(0, SEQID)                   |\n\t       HINIC_MSG_HEADER_SET(LAST_SEGMENT, LAST)         |\n\t       HINIC_MSG_HEADER_SET(direction, DIRECTION)       |\n\t       HINIC_MSG_HEADER_SET(cmd, CMD)                   |\n\t       HINIC_MSG_HEADER_SET(HINIC_HWIF_PCI_INTF(hwif), PCI_INTF) |\n\t       HINIC_MSG_HEADER_SET(HINIC_HWIF_PF_IDX(hwif), PF_IDX)     |\n\t       HINIC_MSG_HEADER_SET(msg_id, MSG_ID);\n}\n\n \nstatic void prepare_mgmt_cmd(u8 *mgmt_cmd, u64 *header, u8 *msg, u16 msg_len)\n{\n\tmemset(mgmt_cmd, 0, MGMT_MSG_RSVD_FOR_DEV);\n\n\tmgmt_cmd += MGMT_MSG_RSVD_FOR_DEV;\n\tmemcpy(mgmt_cmd, header, sizeof(*header));\n\n\tmgmt_cmd += sizeof(*header);\n\tmemcpy(mgmt_cmd, msg, msg_len);\n}\n\n \nstatic u16 mgmt_msg_len(u16 msg_data_len)\n{\n\t \n\tu16 msg_len = MGMT_MSG_RSVD_FOR_DEV + sizeof(u64) + msg_data_len;\n\n\tif (msg_len > MGMT_MSG_LEN_MIN)\n\t\tmsg_len = MGMT_MSG_LEN_MIN +\n\t\t\t   ALIGN((msg_len - MGMT_MSG_LEN_MIN),\n\t\t\t\t MGMT_MSG_LEN_STEP);\n\telse\n\t\tmsg_len = MGMT_MSG_LEN_MIN;\n\n\treturn msg_len;\n}\n\n \nstatic int send_msg_to_mgmt(struct hinic_pf_to_mgmt *pf_to_mgmt,\n\t\t\t    enum hinic_mod_type mod, u8 cmd,\n\t\t\t    u8 *data, u16 data_len,\n\t\t\t    enum msg_ack_type ack_type,\n\t\t\t    enum mgmt_direction_type direction,\n\t\t\t    u16 resp_msg_id)\n{\n\tstruct hinic_api_cmd_chain *chain;\n\tu64 header;\n\tu16 msg_id;\n\n\tmsg_id = SYNC_MSG_ID(pf_to_mgmt);\n\n\tif (direction == MGMT_RESP) {\n\t\theader = prepare_header(pf_to_mgmt, data_len, mod, ack_type,\n\t\t\t\t\tdirection, cmd, resp_msg_id);\n\t} else {\n\t\tSYNC_MSG_ID_INC(pf_to_mgmt);\n\t\theader = prepare_header(pf_to_mgmt, data_len, mod, ack_type,\n\t\t\t\t\tdirection, cmd, msg_id);\n\t}\n\n\tprepare_mgmt_cmd(pf_to_mgmt->sync_msg_buf, &header, data, data_len);\n\n\tchain = pf_to_mgmt->cmd_chain[HINIC_API_CMD_WRITE_TO_MGMT_CPU];\n\treturn hinic_api_cmd_write(chain, HINIC_NODE_ID_MGMT,\n\t\t\t\t   pf_to_mgmt->sync_msg_buf,\n\t\t\t\t   mgmt_msg_len(data_len));\n}\n\n \nstatic int msg_to_mgmt_sync(struct hinic_pf_to_mgmt *pf_to_mgmt,\n\t\t\t    enum hinic_mod_type mod, u8 cmd,\n\t\t\t    u8 *buf_in, u16 in_size,\n\t\t\t    u8 *buf_out, u16 *out_size,\n\t\t\t    enum mgmt_direction_type direction,\n\t\t\t    u16 resp_msg_id, u32 timeout)\n{\n\tstruct hinic_hwif *hwif = pf_to_mgmt->hwif;\n\tstruct pci_dev *pdev = hwif->pdev;\n\tstruct hinic_recv_msg *recv_msg;\n\tstruct completion *recv_done;\n\tunsigned long timeo;\n\tu16 msg_id;\n\tint err;\n\n\t \n\tdown(&pf_to_mgmt->sync_msg_lock);\n\n\trecv_msg = &pf_to_mgmt->recv_resp_msg_from_mgmt;\n\trecv_done = &recv_msg->recv_done;\n\n\tif (resp_msg_id == MSG_NOT_RESP)\n\t\tmsg_id = SYNC_MSG_ID(pf_to_mgmt);\n\telse\n\t\tmsg_id = resp_msg_id;\n\n\tinit_completion(recv_done);\n\n\terr = send_msg_to_mgmt(pf_to_mgmt, mod, cmd, buf_in, in_size,\n\t\t\t       MSG_ACK, direction, resp_msg_id);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Failed to send sync msg to mgmt\\n\");\n\t\tgoto unlock_sync_msg;\n\t}\n\n\ttimeo = msecs_to_jiffies(timeout ? timeout : MGMT_MSG_TIMEOUT);\n\n\tif (!wait_for_completion_timeout(recv_done, timeo)) {\n\t\tdev_err(&pdev->dev, \"MGMT timeout, MSG id = %d\\n\", msg_id);\n\t\thinic_dump_aeq_info(pf_to_mgmt->hwdev);\n\t\terr = -ETIMEDOUT;\n\t\tgoto unlock_sync_msg;\n\t}\n\n\tsmp_rmb();       \n\n\tif (recv_msg->msg_id != msg_id) {\n\t\tdev_err(&pdev->dev, \"incorrect MSG for id = %d\\n\", msg_id);\n\t\terr = -EFAULT;\n\t\tgoto unlock_sync_msg;\n\t}\n\n\tif (buf_out && recv_msg->msg_len <= MAX_PF_MGMT_BUF_SIZE) {\n\t\tmemcpy(buf_out, recv_msg->msg, recv_msg->msg_len);\n\t\t*out_size = recv_msg->msg_len;\n\t}\n\nunlock_sync_msg:\n\tup(&pf_to_mgmt->sync_msg_lock);\n\treturn err;\n}\n\n \nstatic int msg_to_mgmt_async(struct hinic_pf_to_mgmt *pf_to_mgmt,\n\t\t\t     enum hinic_mod_type mod, u8 cmd,\n\t\t\t     u8 *buf_in, u16 in_size,\n\t\t\t     enum mgmt_direction_type direction,\n\t\t\t     u16 resp_msg_id)\n{\n\tint err;\n\n\t \n\tdown(&pf_to_mgmt->sync_msg_lock);\n\n\terr = send_msg_to_mgmt(pf_to_mgmt, mod, cmd, buf_in, in_size,\n\t\t\t       MSG_NO_ACK, direction, resp_msg_id);\n\n\tup(&pf_to_mgmt->sync_msg_lock);\n\treturn err;\n}\n\n \nint hinic_msg_to_mgmt(struct hinic_pf_to_mgmt *pf_to_mgmt,\n\t\t      enum hinic_mod_type mod, u8 cmd,\n\t\t      void *buf_in, u16 in_size, void *buf_out, u16 *out_size,\n\t\t      enum hinic_mgmt_msg_type sync)\n{\n\tstruct hinic_hwif *hwif = pf_to_mgmt->hwif;\n\tstruct pci_dev *pdev = hwif->pdev;\n\tu32 timeout = 0;\n\n\tif (sync != HINIC_MGMT_MSG_SYNC) {\n\t\tdev_err(&pdev->dev, \"Invalid MGMT msg type\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!MSG_SZ_IS_VALID(in_size)) {\n\t\tdev_err(&pdev->dev, \"Invalid MGMT msg buffer size\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (HINIC_IS_VF(hwif)) {\n\t\tif (cmd == HINIC_PORT_CMD_SET_FUNC_STATE)\n\t\t\ttimeout = SET_FUNC_PORT_MBOX_TIMEOUT;\n\n\t\treturn hinic_mbox_to_pf(pf_to_mgmt->hwdev, mod, cmd, buf_in,\n\t\t\t\t\tin_size, buf_out, out_size, timeout);\n\t} else {\n\t\tif (cmd == HINIC_PORT_CMD_SET_FUNC_STATE)\n\t\t\ttimeout = SET_FUNC_PORT_MGMT_TIMEOUT;\n\t\telse if (cmd == HINIC_PORT_CMD_UPDATE_FW)\n\t\t\ttimeout = UPDATE_FW_MGMT_TIMEOUT;\n\n\t\treturn msg_to_mgmt_sync(pf_to_mgmt, mod, cmd, buf_in, in_size,\n\t\t\t\tbuf_out, out_size, MGMT_DIRECT_SEND,\n\t\t\t\tMSG_NOT_RESP, timeout);\n\t}\n}\n\nstatic void recv_mgmt_msg_work_handler(struct work_struct *work)\n{\n\tstruct hinic_mgmt_msg_handle_work *mgmt_work =\n\t\tcontainer_of(work, struct hinic_mgmt_msg_handle_work, work);\n\tstruct hinic_pf_to_mgmt *pf_to_mgmt = mgmt_work->pf_to_mgmt;\n\tstruct pci_dev *pdev = pf_to_mgmt->hwif->pdev;\n\tu8 *buf_out = pf_to_mgmt->mgmt_ack_buf;\n\tstruct hinic_mgmt_cb *mgmt_cb;\n\tunsigned long cb_state;\n\tu16 out_size = 0;\n\n\tmemset(buf_out, 0, MAX_PF_MGMT_BUF_SIZE);\n\n\tif (mgmt_work->mod >= HINIC_MOD_MAX) {\n\t\tdev_err(&pdev->dev, \"Unknown MGMT MSG module = %d\\n\",\n\t\t\tmgmt_work->mod);\n\t\tkfree(mgmt_work->msg);\n\t\tkfree(mgmt_work);\n\t\treturn;\n\t}\n\n\tmgmt_cb = &pf_to_mgmt->mgmt_cb[mgmt_work->mod];\n\n\tcb_state = cmpxchg(&mgmt_cb->state,\n\t\t\t   HINIC_MGMT_CB_ENABLED,\n\t\t\t   HINIC_MGMT_CB_ENABLED | HINIC_MGMT_CB_RUNNING);\n\n\tif (cb_state == HINIC_MGMT_CB_ENABLED && mgmt_cb->cb)\n\t\tmgmt_cb->cb(mgmt_cb->handle, mgmt_work->cmd,\n\t\t\t    mgmt_work->msg, mgmt_work->msg_len,\n\t\t\t    buf_out, &out_size);\n\telse\n\t\tdev_err(&pdev->dev, \"No MGMT msg handler, mod: %d, cmd: %d\\n\",\n\t\t\tmgmt_work->mod, mgmt_work->cmd);\n\n\tmgmt_cb->state &= ~HINIC_MGMT_CB_RUNNING;\n\n\tif (!mgmt_work->async_mgmt_to_pf)\n\t\t \n\t\tmsg_to_mgmt_async(pf_to_mgmt, mgmt_work->mod, mgmt_work->cmd,\n\t\t\t\t  buf_out, out_size, MGMT_RESP,\n\t\t\t\t  mgmt_work->msg_id);\n\n\tkfree(mgmt_work->msg);\n\tkfree(mgmt_work);\n}\n\n \nstatic void mgmt_recv_msg_handler(struct hinic_pf_to_mgmt *pf_to_mgmt,\n\t\t\t\t  struct hinic_recv_msg *recv_msg)\n{\n\tstruct hinic_mgmt_msg_handle_work *mgmt_work = NULL;\n\n\tmgmt_work = kzalloc(sizeof(*mgmt_work), GFP_KERNEL);\n\tif (!mgmt_work)\n\t\treturn;\n\n\tif (recv_msg->msg_len) {\n\t\tmgmt_work->msg = kzalloc(recv_msg->msg_len, GFP_KERNEL);\n\t\tif (!mgmt_work->msg) {\n\t\t\tkfree(mgmt_work);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tmgmt_work->pf_to_mgmt = pf_to_mgmt;\n\tmgmt_work->msg_len = recv_msg->msg_len;\n\tmemcpy(mgmt_work->msg, recv_msg->msg, recv_msg->msg_len);\n\tmgmt_work->msg_id = recv_msg->msg_id;\n\tmgmt_work->mod = recv_msg->mod;\n\tmgmt_work->cmd = recv_msg->cmd;\n\tmgmt_work->async_mgmt_to_pf = recv_msg->async_mgmt_to_pf;\n\n\tINIT_WORK(&mgmt_work->work, recv_mgmt_msg_work_handler);\n\tqueue_work(pf_to_mgmt->workq, &mgmt_work->work);\n}\n\n \nstatic void mgmt_resp_msg_handler(struct hinic_pf_to_mgmt *pf_to_mgmt,\n\t\t\t\t  struct hinic_recv_msg *recv_msg)\n{\n\twmb();   \n\n\tcomplete(&recv_msg->recv_done);\n}\n\n \nstatic void recv_mgmt_msg_handler(struct hinic_pf_to_mgmt *pf_to_mgmt,\n\t\t\t\t  u64 *header, struct hinic_recv_msg *recv_msg)\n{\n\tstruct hinic_hwif *hwif = pf_to_mgmt->hwif;\n\tstruct pci_dev *pdev = hwif->pdev;\n\tint seq_id, seg_len;\n\tu8 *msg_body;\n\n\tseq_id = HINIC_MSG_HEADER_GET(*header, SEQID);\n\tseg_len = HINIC_MSG_HEADER_GET(*header, SEG_LEN);\n\n\tif (seq_id >= (MAX_MSG_LEN / SEGMENT_LEN)) {\n\t\tdev_err(&pdev->dev, \"recv big mgmt msg\\n\");\n\t\treturn;\n\t}\n\n\tmsg_body = (u8 *)header + sizeof(*header);\n\tmemcpy(recv_msg->msg + seq_id * SEGMENT_LEN, msg_body, seg_len);\n\n\tif (!HINIC_MSG_HEADER_GET(*header, LAST))\n\t\treturn;\n\n\trecv_msg->cmd = HINIC_MSG_HEADER_GET(*header, CMD);\n\trecv_msg->mod = HINIC_MSG_HEADER_GET(*header, MODULE);\n\trecv_msg->async_mgmt_to_pf = HINIC_MSG_HEADER_GET(*header,\n\t\t\t\t\t\t\t  ASYNC_MGMT_TO_PF);\n\trecv_msg->msg_len = HINIC_MSG_HEADER_GET(*header, MSG_LEN);\n\trecv_msg->msg_id = HINIC_MSG_HEADER_GET(*header, MSG_ID);\n\n\tif (HINIC_MSG_HEADER_GET(*header, DIRECTION) == MGMT_RESP)\n\t\tmgmt_resp_msg_handler(pf_to_mgmt, recv_msg);\n\telse\n\t\tmgmt_recv_msg_handler(pf_to_mgmt, recv_msg);\n}\n\n \nstatic void mgmt_msg_aeqe_handler(void *handle, void *data, u8 size)\n{\n\tstruct hinic_pf_to_mgmt *pf_to_mgmt = handle;\n\tstruct hinic_recv_msg *recv_msg;\n\tu64 *header = (u64 *)data;\n\n\trecv_msg = HINIC_MSG_HEADER_GET(*header, DIRECTION) ==\n\t\t   MGMT_DIRECT_SEND ?\n\t\t   &pf_to_mgmt->recv_msg_from_mgmt :\n\t\t   &pf_to_mgmt->recv_resp_msg_from_mgmt;\n\n\trecv_mgmt_msg_handler(pf_to_mgmt, header, recv_msg);\n}\n\n \nstatic int alloc_recv_msg(struct hinic_pf_to_mgmt *pf_to_mgmt,\n\t\t\t  struct hinic_recv_msg *recv_msg)\n{\n\tstruct hinic_hwif *hwif = pf_to_mgmt->hwif;\n\tstruct pci_dev *pdev = hwif->pdev;\n\n\trecv_msg->msg = devm_kzalloc(&pdev->dev, MAX_PF_MGMT_BUF_SIZE,\n\t\t\t\t     GFP_KERNEL);\n\tif (!recv_msg->msg)\n\t\treturn -ENOMEM;\n\n\trecv_msg->buf_out = devm_kzalloc(&pdev->dev, MAX_PF_MGMT_BUF_SIZE,\n\t\t\t\t\t GFP_KERNEL);\n\tif (!recv_msg->buf_out)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\n \nstatic int alloc_msg_buf(struct hinic_pf_to_mgmt *pf_to_mgmt)\n{\n\tstruct hinic_hwif *hwif = pf_to_mgmt->hwif;\n\tstruct pci_dev *pdev = hwif->pdev;\n\tint err;\n\n\terr = alloc_recv_msg(pf_to_mgmt,\n\t\t\t     &pf_to_mgmt->recv_msg_from_mgmt);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Failed to allocate recv msg\\n\");\n\t\treturn err;\n\t}\n\n\terr = alloc_recv_msg(pf_to_mgmt,\n\t\t\t     &pf_to_mgmt->recv_resp_msg_from_mgmt);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Failed to allocate resp recv msg\\n\");\n\t\treturn err;\n\t}\n\n\tpf_to_mgmt->sync_msg_buf = devm_kzalloc(&pdev->dev,\n\t\t\t\t\t\tMAX_PF_MGMT_BUF_SIZE,\n\t\t\t\t\t\tGFP_KERNEL);\n\tif (!pf_to_mgmt->sync_msg_buf)\n\t\treturn -ENOMEM;\n\n\tpf_to_mgmt->mgmt_ack_buf = devm_kzalloc(&pdev->dev,\n\t\t\t\t\t\tMAX_PF_MGMT_BUF_SIZE,\n\t\t\t\t\t\tGFP_KERNEL);\n\tif (!pf_to_mgmt->mgmt_ack_buf)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\n \nint hinic_pf_to_mgmt_init(struct hinic_pf_to_mgmt *pf_to_mgmt,\n\t\t\t  struct hinic_hwif *hwif)\n{\n\tstruct hinic_pfhwdev *pfhwdev = mgmt_to_pfhwdev(pf_to_mgmt);\n\tstruct hinic_hwdev *hwdev = &pfhwdev->hwdev;\n\tstruct pci_dev *pdev = hwif->pdev;\n\tint err;\n\n\tpf_to_mgmt->hwif = hwif;\n\tpf_to_mgmt->hwdev = hwdev;\n\n\tif (HINIC_IS_VF(hwif))\n\t\treturn 0;\n\n\terr = hinic_health_reporters_create(hwdev->devlink_dev);\n\tif (err)\n\t\treturn err;\n\n\tsema_init(&pf_to_mgmt->sync_msg_lock, 1);\n\tpf_to_mgmt->workq = create_singlethread_workqueue(\"hinic_mgmt\");\n\tif (!pf_to_mgmt->workq) {\n\t\tdev_err(&pdev->dev, \"Failed to initialize MGMT workqueue\\n\");\n\t\thinic_health_reporters_destroy(hwdev->devlink_dev);\n\t\treturn -ENOMEM;\n\t}\n\tpf_to_mgmt->sync_msg_id = 0;\n\n\terr = alloc_msg_buf(pf_to_mgmt);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Failed to allocate msg buffers\\n\");\n\t\tdestroy_workqueue(pf_to_mgmt->workq);\n\t\thinic_health_reporters_destroy(hwdev->devlink_dev);\n\t\treturn err;\n\t}\n\n\terr = hinic_api_cmd_init(pf_to_mgmt->cmd_chain, hwif);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Failed to initialize cmd chains\\n\");\n\t\tdestroy_workqueue(pf_to_mgmt->workq);\n\t\thinic_health_reporters_destroy(hwdev->devlink_dev);\n\t\treturn err;\n\t}\n\n\thinic_aeq_register_hw_cb(&hwdev->aeqs, HINIC_MSG_FROM_MGMT_CPU,\n\t\t\t\t pf_to_mgmt,\n\t\t\t\t mgmt_msg_aeqe_handler);\n\treturn 0;\n}\n\n \nvoid hinic_pf_to_mgmt_free(struct hinic_pf_to_mgmt *pf_to_mgmt)\n{\n\tstruct hinic_pfhwdev *pfhwdev = mgmt_to_pfhwdev(pf_to_mgmt);\n\tstruct hinic_hwdev *hwdev = &pfhwdev->hwdev;\n\n\tif (HINIC_IS_VF(hwdev->hwif))\n\t\treturn;\n\n\thinic_aeq_unregister_hw_cb(&hwdev->aeqs, HINIC_MSG_FROM_MGMT_CPU);\n\thinic_api_cmd_free(pf_to_mgmt->cmd_chain);\n\tdestroy_workqueue(pf_to_mgmt->workq);\n\thinic_health_reporters_destroy(hwdev->devlink_dev);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}