{
  "module_name": "hinic_hw_api_cmd.c",
  "hash_id": "64aafe973ff344452a3bb35cda0967688fee35cdabe7a9deeb88c1234cc64cd2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/huawei/hinic/hinic_hw_api_cmd.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/errno.h>\n#include <linux/pci.h>\n#include <linux/device.h>\n#include <linux/slab.h>\n#include <linux/dma-mapping.h>\n#include <linux/bitops.h>\n#include <linux/err.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/log2.h>\n#include <linux/semaphore.h>\n#include <asm/byteorder.h>\n#include <asm/barrier.h>\n\n#include \"hinic_hw_csr.h\"\n#include \"hinic_hw_if.h\"\n#include \"hinic_hw_api_cmd.h\"\n\n#define API_CHAIN_NUM_CELLS                     32\n\n#define API_CMD_CELL_SIZE_SHIFT                 6\n#define API_CMD_CELL_SIZE_MIN                   (BIT(API_CMD_CELL_SIZE_SHIFT))\n\n#define API_CMD_CELL_SIZE(cell_size)            \\\n\t\t(((cell_size) >= API_CMD_CELL_SIZE_MIN) ? \\\n\t\t (1 << (fls(cell_size - 1))) : API_CMD_CELL_SIZE_MIN)\n\n#define API_CMD_CELL_SIZE_VAL(size)             \\\n\t\tilog2((size) >> API_CMD_CELL_SIZE_SHIFT)\n\n#define API_CMD_BUF_SIZE                        2048\n\n \n#define API_CMD_CELL_DESC_SIZE          8\n#define API_CMD_CELL_DATA_ADDR_SIZE     8\n\n#define API_CMD_CELL_ALIGNMENT          8\n\n#define API_CMD_TIMEOUT                 1000\n\n#define MASKED_IDX(chain, idx)          ((idx) & ((chain)->num_cells - 1))\n\n#define SIZE_8BYTES(size)               (ALIGN((size), 8) >> 3)\n#define SIZE_4BYTES(size)               (ALIGN((size), 4) >> 2)\n\n#define RD_DMA_ATTR_DEFAULT             0\n#define WR_DMA_ATTR_DEFAULT             0\n\nenum api_cmd_data_format {\n\tSGE_DATA = 1,            \n};\n\nenum api_cmd_type {\n\tAPI_CMD_WRITE = 0,\n};\n\nenum api_cmd_bypass {\n\tNO_BYPASS       = 0,\n\tBYPASS          = 1,\n};\n\nenum api_cmd_xor_chk_level {\n\tXOR_CHK_DIS = 0,\n\n\tXOR_CHK_ALL = 3,\n};\n\nstatic u8 xor_chksum_set(void *data)\n{\n\tint idx;\n\tu8 *val, checksum = 0;\n\n\tval = data;\n\n\tfor (idx = 0; idx < 7; idx++)\n\t\tchecksum ^= val[idx];\n\n\treturn checksum;\n}\n\nstatic void set_prod_idx(struct hinic_api_cmd_chain *chain)\n{\n\tenum hinic_api_cmd_chain_type chain_type = chain->chain_type;\n\tstruct hinic_hwif *hwif = chain->hwif;\n\tu32 addr, prod_idx;\n\n\taddr = HINIC_CSR_API_CMD_CHAIN_PI_ADDR(chain_type);\n\tprod_idx = hinic_hwif_read_reg(hwif, addr);\n\n\tprod_idx = HINIC_API_CMD_PI_CLEAR(prod_idx, IDX);\n\n\tprod_idx |= HINIC_API_CMD_PI_SET(chain->prod_idx, IDX);\n\n\thinic_hwif_write_reg(hwif, addr, prod_idx);\n}\n\nstatic u32 get_hw_cons_idx(struct hinic_api_cmd_chain *chain)\n{\n\tu32 addr, val;\n\n\taddr = HINIC_CSR_API_CMD_STATUS_ADDR(chain->chain_type);\n\tval  = hinic_hwif_read_reg(chain->hwif, addr);\n\n\treturn HINIC_API_CMD_STATUS_GET(val, CONS_IDX);\n}\n\nstatic void dump_api_chain_reg(struct hinic_api_cmd_chain *chain)\n{\n\tu32 addr, val;\n\n\taddr = HINIC_CSR_API_CMD_STATUS_ADDR(chain->chain_type);\n\tval  = hinic_hwif_read_reg(chain->hwif, addr);\n\n\tdev_err(&chain->hwif->pdev->dev, \"Chain type: 0x%x, cpld error: 0x%x, check error: 0x%x, current fsm: 0x%x\\n\",\n\t\tchain->chain_type, HINIC_API_CMD_STATUS_GET(val, CPLD_ERR),\n\t\tHINIC_API_CMD_STATUS_GET(val, CHKSUM_ERR),\n\t\tHINIC_API_CMD_STATUS_GET(val, FSM));\n\n\tdev_err(&chain->hwif->pdev->dev, \"Chain hw current ci: 0x%x\\n\",\n\t\tHINIC_API_CMD_STATUS_GET(val, CONS_IDX));\n\n\taddr = HINIC_CSR_API_CMD_CHAIN_PI_ADDR(chain->chain_type);\n\tval  = hinic_hwif_read_reg(chain->hwif, addr);\n\tdev_err(&chain->hwif->pdev->dev, \"Chain hw current pi: 0x%x\\n\", val);\n}\n\n \nstatic int chain_busy(struct hinic_api_cmd_chain *chain)\n{\n\tstruct hinic_hwif *hwif = chain->hwif;\n\tstruct pci_dev *pdev = hwif->pdev;\n\tu32 prod_idx;\n\n\tswitch (chain->chain_type) {\n\tcase HINIC_API_CMD_WRITE_TO_MGMT_CPU:\n\t\tchain->cons_idx = get_hw_cons_idx(chain);\n\t\tprod_idx = chain->prod_idx;\n\n\t\t \n\t\tif (chain->cons_idx == MASKED_IDX(chain, prod_idx + 1)) {\n\t\t\tdev_err(&pdev->dev, \"API CMD chain %d is busy, cons_idx: %d, prod_idx: %d\\n\",\n\t\t\t\tchain->chain_type, chain->cons_idx,\n\t\t\t\tchain->prod_idx);\n\t\t\tdump_api_chain_reg(chain);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(&pdev->dev, \"Unknown API CMD Chain type\\n\");\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n \nstatic u8 get_cell_data_size(enum hinic_api_cmd_chain_type type)\n{\n\tu8 cell_data_size = 0;\n\n\tswitch (type) {\n\tcase HINIC_API_CMD_WRITE_TO_MGMT_CPU:\n\t\tcell_data_size = ALIGN(API_CMD_CELL_DESC_SIZE +\n\t\t\t\t       API_CMD_CELL_DATA_ADDR_SIZE,\n\t\t\t\t       API_CMD_CELL_ALIGNMENT);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn cell_data_size;\n}\n\n \nstatic void prepare_cell_ctrl(u64 *cell_ctrl, u16 data_size)\n{\n\tu8 chksum;\n\tu64 ctrl;\n\n\tctrl =  HINIC_API_CMD_CELL_CTRL_SET(SIZE_8BYTES(data_size), DATA_SZ)  |\n\t\tHINIC_API_CMD_CELL_CTRL_SET(RD_DMA_ATTR_DEFAULT, RD_DMA_ATTR) |\n\t\tHINIC_API_CMD_CELL_CTRL_SET(WR_DMA_ATTR_DEFAULT, WR_DMA_ATTR);\n\n\tchksum = xor_chksum_set(&ctrl);\n\n\tctrl |= HINIC_API_CMD_CELL_CTRL_SET(chksum, XOR_CHKSUM);\n\n\t \n\t*cell_ctrl = cpu_to_be64(ctrl);\n}\n\n \nstatic void prepare_api_cmd(struct hinic_api_cmd_chain *chain,\n\t\t\t    enum hinic_node_id dest,\n\t\t\t    void *cmd, u16 cmd_size)\n{\n\tstruct hinic_api_cmd_cell *cell = chain->curr_node;\n\tstruct hinic_api_cmd_cell_ctxt *cell_ctxt;\n\tstruct hinic_hwif *hwif = chain->hwif;\n\tstruct pci_dev *pdev = hwif->pdev;\n\n\tcell_ctxt = &chain->cell_ctxt[chain->prod_idx];\n\n\tswitch (chain->chain_type) {\n\tcase HINIC_API_CMD_WRITE_TO_MGMT_CPU:\n\t\tcell->desc = HINIC_API_CMD_DESC_SET(SGE_DATA, API_TYPE)   |\n\t\t\t     HINIC_API_CMD_DESC_SET(API_CMD_WRITE, RD_WR) |\n\t\t\t     HINIC_API_CMD_DESC_SET(NO_BYPASS, MGMT_BYPASS);\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(&pdev->dev, \"unknown Chain type\\n\");\n\t\treturn;\n\t}\n\n\tcell->desc |= HINIC_API_CMD_DESC_SET(dest, DEST)        |\n\t\t      HINIC_API_CMD_DESC_SET(SIZE_4BYTES(cmd_size), SIZE);\n\n\tcell->desc |= HINIC_API_CMD_DESC_SET(xor_chksum_set(&cell->desc),\n\t\t\t\t\t     XOR_CHKSUM);\n\n\t \n\tcell->desc = cpu_to_be64(cell->desc);\n\n\tmemcpy(cell_ctxt->api_cmd_vaddr, cmd, cmd_size);\n}\n\n \nstatic void prepare_cell(struct hinic_api_cmd_chain *chain,\n\t\t\t enum  hinic_node_id dest,\n\t\t\t void *cmd, u16 cmd_size)\n{\n\tstruct hinic_api_cmd_cell *curr_node = chain->curr_node;\n\tu16 data_size = get_cell_data_size(chain->chain_type);\n\n\tprepare_cell_ctrl(&curr_node->ctrl, data_size);\n\tprepare_api_cmd(chain, dest, cmd, cmd_size);\n}\n\nstatic inline void cmd_chain_prod_idx_inc(struct hinic_api_cmd_chain *chain)\n{\n\tchain->prod_idx = MASKED_IDX(chain, chain->prod_idx + 1);\n}\n\n \nstatic void api_cmd_status_update(struct hinic_api_cmd_chain *chain)\n{\n\tenum hinic_api_cmd_chain_type chain_type;\n\tstruct hinic_api_cmd_status *wb_status;\n\tstruct hinic_hwif *hwif = chain->hwif;\n\tstruct pci_dev *pdev = hwif->pdev;\n\tu64 status_header;\n\tu32 status;\n\n\twb_status = chain->wb_status;\n\tstatus_header = be64_to_cpu(wb_status->header);\n\n\tstatus = be32_to_cpu(wb_status->status);\n\tif (HINIC_API_CMD_STATUS_GET(status, CHKSUM_ERR)) {\n\t\tdev_err(&pdev->dev, \"API CMD status: Xor check error\\n\");\n\t\treturn;\n\t}\n\n\tchain_type = HINIC_API_CMD_STATUS_HEADER_GET(status_header, CHAIN_ID);\n\tif (chain_type >= HINIC_API_CMD_MAX) {\n\t\tdev_err(&pdev->dev, \"unknown API CMD Chain %d\\n\", chain_type);\n\t\treturn;\n\t}\n\n\tchain->cons_idx = HINIC_API_CMD_STATUS_GET(status, CONS_IDX);\n}\n\n \nstatic int wait_for_status_poll(struct hinic_api_cmd_chain *chain)\n{\n\tint err = -ETIMEDOUT;\n\tunsigned long end;\n\n\tend = jiffies + msecs_to_jiffies(API_CMD_TIMEOUT);\n\tdo {\n\t\tapi_cmd_status_update(chain);\n\n\t\t \n\t\tif (chain->cons_idx == chain->prod_idx) {\n\t\t\terr = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tmsleep(20);\n\t} while (time_before(jiffies, end));\n\n\treturn err;\n}\n\n \nstatic int wait_for_api_cmd_completion(struct hinic_api_cmd_chain *chain)\n{\n\tstruct hinic_hwif *hwif = chain->hwif;\n\tstruct pci_dev *pdev = hwif->pdev;\n\tint err;\n\n\tswitch (chain->chain_type) {\n\tcase HINIC_API_CMD_WRITE_TO_MGMT_CPU:\n\t\terr = wait_for_status_poll(chain);\n\t\tif (err) {\n\t\t\tdev_err(&pdev->dev, \"API CMD Poll status timeout\\n\");\n\t\t\tdump_api_chain_reg(chain);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(&pdev->dev, \"unknown API CMD Chain type\\n\");\n\t\terr = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\n \nstatic int api_cmd(struct hinic_api_cmd_chain *chain,\n\t\t   enum hinic_node_id dest, u8 *cmd, u16 cmd_size)\n{\n\tstruct hinic_api_cmd_cell_ctxt *ctxt;\n\tint err;\n\n\tdown(&chain->sem);\n\tif (chain_busy(chain)) {\n\t\tup(&chain->sem);\n\t\treturn -EBUSY;\n\t}\n\n\tprepare_cell(chain, dest, cmd, cmd_size);\n\tcmd_chain_prod_idx_inc(chain);\n\n\twmb();   \n\n\tset_prod_idx(chain);     \n\n\tctxt = &chain->cell_ctxt[chain->prod_idx];\n\n\tchain->curr_node = ctxt->cell_vaddr;\n\n\terr = wait_for_api_cmd_completion(chain);\n\n\tup(&chain->sem);\n\treturn err;\n}\n\n \nint hinic_api_cmd_write(struct hinic_api_cmd_chain *chain,\n\t\t\tenum hinic_node_id dest, u8 *cmd, u16 size)\n{\n\t \n\tif (chain->chain_type == HINIC_API_CMD_WRITE_TO_MGMT_CPU)\n\t\treturn api_cmd(chain, dest, cmd, size);\n\n\treturn -EINVAL;\n}\n\n \nstatic int api_cmd_hw_restart(struct hinic_api_cmd_chain *chain)\n{\n\tstruct hinic_hwif *hwif = chain->hwif;\n\tint err = -ETIMEDOUT;\n\tunsigned long end;\n\tu32 reg_addr, val;\n\n\t \n\treg_addr = HINIC_CSR_API_CMD_CHAIN_REQ_ADDR(chain->chain_type);\n\tval = hinic_hwif_read_reg(hwif, reg_addr);\n\n\tval = HINIC_API_CMD_CHAIN_REQ_CLEAR(val, RESTART);\n\tval |= HINIC_API_CMD_CHAIN_REQ_SET(1, RESTART);\n\n\thinic_hwif_write_reg(hwif, reg_addr, val);\n\n\tend = jiffies + msecs_to_jiffies(API_CMD_TIMEOUT);\n\tdo {\n\t\tval = hinic_hwif_read_reg(hwif, reg_addr);\n\n\t\tif (!HINIC_API_CMD_CHAIN_REQ_GET(val, RESTART)) {\n\t\t\terr = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tmsleep(20);\n\t} while (time_before(jiffies, end));\n\n\treturn err;\n}\n\n \nstatic void api_cmd_ctrl_init(struct hinic_api_cmd_chain *chain)\n{\n\tstruct hinic_hwif *hwif = chain->hwif;\n\tu32 addr, ctrl;\n\tu16 cell_size;\n\n\t \n\taddr = HINIC_CSR_API_CMD_CHAIN_CTRL_ADDR(chain->chain_type);\n\n\tcell_size = API_CMD_CELL_SIZE_VAL(chain->cell_size);\n\n\tctrl = hinic_hwif_read_reg(hwif, addr);\n\n\tctrl =  HINIC_API_CMD_CHAIN_CTRL_CLEAR(ctrl, RESTART_WB_STAT) &\n\t\tHINIC_API_CMD_CHAIN_CTRL_CLEAR(ctrl, XOR_ERR)         &\n\t\tHINIC_API_CMD_CHAIN_CTRL_CLEAR(ctrl, AEQE_EN)         &\n\t\tHINIC_API_CMD_CHAIN_CTRL_CLEAR(ctrl, XOR_CHK_EN)      &\n\t\tHINIC_API_CMD_CHAIN_CTRL_CLEAR(ctrl, CELL_SIZE);\n\n\tctrl |= HINIC_API_CMD_CHAIN_CTRL_SET(1, XOR_ERR)              |\n\t\tHINIC_API_CMD_CHAIN_CTRL_SET(XOR_CHK_ALL, XOR_CHK_EN) |\n\t\tHINIC_API_CMD_CHAIN_CTRL_SET(cell_size, CELL_SIZE);\n\n\thinic_hwif_write_reg(hwif, addr, ctrl);\n}\n\n \nstatic void api_cmd_set_status_addr(struct hinic_api_cmd_chain *chain)\n{\n\tstruct hinic_hwif *hwif = chain->hwif;\n\tu32 addr, val;\n\n\taddr = HINIC_CSR_API_CMD_STATUS_HI_ADDR(chain->chain_type);\n\tval = upper_32_bits(chain->wb_status_paddr);\n\thinic_hwif_write_reg(hwif, addr, val);\n\n\taddr = HINIC_CSR_API_CMD_STATUS_LO_ADDR(chain->chain_type);\n\tval = lower_32_bits(chain->wb_status_paddr);\n\thinic_hwif_write_reg(hwif, addr, val);\n}\n\n \nstatic void api_cmd_set_num_cells(struct hinic_api_cmd_chain *chain)\n{\n\tstruct hinic_hwif *hwif = chain->hwif;\n\tu32 addr, val;\n\n\taddr = HINIC_CSR_API_CMD_CHAIN_NUM_CELLS_ADDR(chain->chain_type);\n\tval  = chain->num_cells;\n\thinic_hwif_write_reg(hwif, addr, val);\n}\n\n \nstatic void api_cmd_head_init(struct hinic_api_cmd_chain *chain)\n{\n\tstruct hinic_hwif *hwif = chain->hwif;\n\tu32 addr, val;\n\n\taddr = HINIC_CSR_API_CMD_CHAIN_HEAD_HI_ADDR(chain->chain_type);\n\tval = upper_32_bits(chain->head_cell_paddr);\n\thinic_hwif_write_reg(hwif, addr, val);\n\n\taddr = HINIC_CSR_API_CMD_CHAIN_HEAD_LO_ADDR(chain->chain_type);\n\tval = lower_32_bits(chain->head_cell_paddr);\n\thinic_hwif_write_reg(hwif, addr, val);\n}\n\n \nstatic void api_cmd_chain_hw_clean(struct hinic_api_cmd_chain *chain)\n{\n\tstruct hinic_hwif *hwif = chain->hwif;\n\tu32 addr, ctrl;\n\n\taddr = HINIC_CSR_API_CMD_CHAIN_CTRL_ADDR(chain->chain_type);\n\n\tctrl = hinic_hwif_read_reg(hwif, addr);\n\tctrl = HINIC_API_CMD_CHAIN_CTRL_CLEAR(ctrl, RESTART_WB_STAT) &\n\t       HINIC_API_CMD_CHAIN_CTRL_CLEAR(ctrl, XOR_ERR)         &\n\t       HINIC_API_CMD_CHAIN_CTRL_CLEAR(ctrl, AEQE_EN)         &\n\t       HINIC_API_CMD_CHAIN_CTRL_CLEAR(ctrl, XOR_CHK_EN)      &\n\t       HINIC_API_CMD_CHAIN_CTRL_CLEAR(ctrl, CELL_SIZE);\n\n\thinic_hwif_write_reg(hwif, addr, ctrl);\n}\n\n \nstatic int api_cmd_chain_hw_init(struct hinic_api_cmd_chain *chain)\n{\n\tstruct hinic_hwif *hwif = chain->hwif;\n\tstruct pci_dev *pdev = hwif->pdev;\n\tint err;\n\n\tapi_cmd_chain_hw_clean(chain);\n\n\tapi_cmd_set_status_addr(chain);\n\n\terr = api_cmd_hw_restart(chain);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Failed to restart API CMD HW\\n\");\n\t\treturn err;\n\t}\n\n\tapi_cmd_ctrl_init(chain);\n\tapi_cmd_set_num_cells(chain);\n\tapi_cmd_head_init(chain);\n\treturn 0;\n}\n\n \nstatic void free_cmd_buf(struct hinic_api_cmd_chain *chain, int cell_idx)\n{\n\tstruct hinic_api_cmd_cell_ctxt *cell_ctxt;\n\tstruct hinic_hwif *hwif = chain->hwif;\n\tstruct pci_dev *pdev = hwif->pdev;\n\n\tcell_ctxt = &chain->cell_ctxt[cell_idx];\n\n\tdma_free_coherent(&pdev->dev, API_CMD_BUF_SIZE,\n\t\t\t  cell_ctxt->api_cmd_vaddr,\n\t\t\t  cell_ctxt->api_cmd_paddr);\n}\n\n \nstatic int alloc_cmd_buf(struct hinic_api_cmd_chain *chain,\n\t\t\t struct hinic_api_cmd_cell *cell, int cell_idx)\n{\n\tstruct hinic_api_cmd_cell_ctxt *cell_ctxt;\n\tstruct hinic_hwif *hwif = chain->hwif;\n\tstruct pci_dev *pdev = hwif->pdev;\n\tdma_addr_t cmd_paddr;\n\tu8 *cmd_vaddr;\n\tint err = 0;\n\n\tcmd_vaddr = dma_alloc_coherent(&pdev->dev, API_CMD_BUF_SIZE,\n\t\t\t\t       &cmd_paddr, GFP_KERNEL);\n\tif (!cmd_vaddr)\n\t\treturn -ENOMEM;\n\n\tcell_ctxt = &chain->cell_ctxt[cell_idx];\n\n\tcell_ctxt->api_cmd_vaddr = cmd_vaddr;\n\tcell_ctxt->api_cmd_paddr = cmd_paddr;\n\n\t \n\tswitch (chain->chain_type) {\n\tcase HINIC_API_CMD_WRITE_TO_MGMT_CPU:\n\t\t \n\t\tcell->write.hw_cmd_paddr = cpu_to_be64(cmd_paddr);\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(&pdev->dev, \"Unsupported API CMD chain type\\n\");\n\t\tfree_cmd_buf(chain, cell_idx);\n\t\terr = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\n \nstatic int api_cmd_create_cell(struct hinic_api_cmd_chain *chain,\n\t\t\t       int cell_idx,\n\t\t\t       struct hinic_api_cmd_cell *pre_node,\n\t\t\t       struct hinic_api_cmd_cell **node_vaddr)\n{\n\tstruct hinic_api_cmd_cell_ctxt *cell_ctxt;\n\tstruct hinic_hwif *hwif = chain->hwif;\n\tstruct pci_dev *pdev = hwif->pdev;\n\tstruct hinic_api_cmd_cell *node;\n\tdma_addr_t node_paddr;\n\tint err;\n\n\tnode = dma_alloc_coherent(&pdev->dev, chain->cell_size, &node_paddr,\n\t\t\t\t  GFP_KERNEL);\n\tif (!node)\n\t\treturn -ENOMEM;\n\n\tnode->read.hw_wb_resp_paddr = 0;\n\n\tcell_ctxt = &chain->cell_ctxt[cell_idx];\n\tcell_ctxt->cell_vaddr = node;\n\tcell_ctxt->cell_paddr = node_paddr;\n\n\tif (!pre_node) {\n\t\tchain->head_cell_paddr = node_paddr;\n\t\tchain->head_node = node;\n\t} else {\n\t\t \n\t\tpre_node->next_cell_paddr = cpu_to_be64(node_paddr);\n\t}\n\n\tswitch (chain->chain_type) {\n\tcase HINIC_API_CMD_WRITE_TO_MGMT_CPU:\n\t\terr = alloc_cmd_buf(chain, node, cell_idx);\n\t\tif (err) {\n\t\t\tdev_err(&pdev->dev, \"Failed to allocate cmd buffer\\n\");\n\t\t\tgoto err_alloc_cmd_buf;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(&pdev->dev, \"Unsupported API CMD chain type\\n\");\n\t\terr = -EINVAL;\n\t\tgoto err_alloc_cmd_buf;\n\t}\n\n\t*node_vaddr = node;\n\treturn 0;\n\nerr_alloc_cmd_buf:\n\tdma_free_coherent(&pdev->dev, chain->cell_size, node, node_paddr);\n\treturn err;\n}\n\n \nstatic void api_cmd_destroy_cell(struct hinic_api_cmd_chain *chain,\n\t\t\t\t int cell_idx)\n{\n\tstruct hinic_api_cmd_cell_ctxt *cell_ctxt;\n\tstruct hinic_hwif *hwif = chain->hwif;\n\tstruct pci_dev *pdev = hwif->pdev;\n\tstruct hinic_api_cmd_cell *node;\n\tdma_addr_t node_paddr;\n\tsize_t node_size;\n\n\tcell_ctxt = &chain->cell_ctxt[cell_idx];\n\n\tnode = cell_ctxt->cell_vaddr;\n\tnode_paddr = cell_ctxt->cell_paddr;\n\tnode_size = chain->cell_size;\n\n\tif (cell_ctxt->api_cmd_vaddr) {\n\t\tswitch (chain->chain_type) {\n\t\tcase HINIC_API_CMD_WRITE_TO_MGMT_CPU:\n\t\t\tfree_cmd_buf(chain, cell_idx);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(&pdev->dev, \"Unsupported API CMD chain type\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tdma_free_coherent(&pdev->dev, node_size, node,\n\t\t\t\t  node_paddr);\n\t}\n}\n\n \nstatic void api_cmd_destroy_cells(struct hinic_api_cmd_chain *chain,\n\t\t\t\t  int num_cells)\n{\n\tint cell_idx;\n\n\tfor (cell_idx = 0; cell_idx < num_cells; cell_idx++)\n\t\tapi_cmd_destroy_cell(chain, cell_idx);\n}\n\n \nstatic int api_cmd_create_cells(struct hinic_api_cmd_chain *chain)\n{\n\tstruct hinic_api_cmd_cell *node = NULL, *pre_node = NULL;\n\tstruct hinic_hwif *hwif = chain->hwif;\n\tstruct pci_dev *pdev = hwif->pdev;\n\tint err, cell_idx;\n\n\tfor (cell_idx = 0; cell_idx < chain->num_cells; cell_idx++) {\n\t\terr = api_cmd_create_cell(chain, cell_idx, pre_node, &node);\n\t\tif (err) {\n\t\t\tdev_err(&pdev->dev, \"Failed to create API CMD cell\\n\");\n\t\t\tgoto err_create_cell;\n\t\t}\n\n\t\tpre_node = node;\n\t}\n\n\t \n\tnode->next_cell_paddr = cpu_to_be64(chain->head_cell_paddr);\n\n\t \n\tchain->curr_node = chain->head_node;\n\treturn 0;\n\nerr_create_cell:\n\tapi_cmd_destroy_cells(chain, cell_idx);\n\treturn err;\n}\n\n \nstatic int api_chain_init(struct hinic_api_cmd_chain *chain,\n\t\t\t  struct hinic_api_cmd_chain_attr *attr)\n{\n\tstruct hinic_hwif *hwif = attr->hwif;\n\tstruct pci_dev *pdev = hwif->pdev;\n\n\tchain->hwif = hwif;\n\tchain->chain_type  = attr->chain_type;\n\tchain->num_cells = attr->num_cells;\n\tchain->cell_size = attr->cell_size;\n\n\tchain->prod_idx  = 0;\n\tchain->cons_idx  = 0;\n\n\tsema_init(&chain->sem, 1);\n\n\tchain->cell_ctxt = devm_kcalloc(&pdev->dev, chain->num_cells,\n\t\t\t\t\tsizeof(*chain->cell_ctxt), GFP_KERNEL);\n\tif (!chain->cell_ctxt)\n\t\treturn -ENOMEM;\n\n\tchain->wb_status = dma_alloc_coherent(&pdev->dev,\n\t\t\t\t\t      sizeof(*chain->wb_status),\n\t\t\t\t\t      &chain->wb_status_paddr,\n\t\t\t\t\t      GFP_KERNEL);\n\tif (!chain->wb_status) {\n\t\tdev_err(&pdev->dev, \"Failed to allocate DMA wb status\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void api_chain_free(struct hinic_api_cmd_chain *chain)\n{\n\tstruct hinic_hwif *hwif = chain->hwif;\n\tstruct pci_dev *pdev = hwif->pdev;\n\n\tdma_free_coherent(&pdev->dev, sizeof(*chain->wb_status),\n\t\t\t  chain->wb_status, chain->wb_status_paddr);\n}\n\n \nstatic struct hinic_api_cmd_chain *\n\tapi_cmd_create_chain(struct hinic_api_cmd_chain_attr *attr)\n{\n\tstruct hinic_hwif *hwif = attr->hwif;\n\tstruct pci_dev *pdev = hwif->pdev;\n\tstruct hinic_api_cmd_chain *chain;\n\tint err;\n\n\tif (attr->num_cells & (attr->num_cells - 1)) {\n\t\tdev_err(&pdev->dev, \"Invalid number of cells, must be power of 2\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tchain = devm_kzalloc(&pdev->dev, sizeof(*chain), GFP_KERNEL);\n\tif (!chain)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = api_chain_init(chain, attr);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Failed to initialize chain\\n\");\n\t\treturn ERR_PTR(err);\n\t}\n\n\terr = api_cmd_create_cells(chain);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Failed to create cells for API CMD chain\\n\");\n\t\tgoto err_create_cells;\n\t}\n\n\terr = api_cmd_chain_hw_init(chain);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Failed to initialize chain HW\\n\");\n\t\tgoto err_chain_hw_init;\n\t}\n\n\treturn chain;\n\nerr_chain_hw_init:\n\tapi_cmd_destroy_cells(chain, chain->num_cells);\n\nerr_create_cells:\n\tapi_chain_free(chain);\n\treturn ERR_PTR(err);\n}\n\n \nstatic void api_cmd_destroy_chain(struct hinic_api_cmd_chain *chain)\n{\n\tapi_cmd_chain_hw_clean(chain);\n\tapi_cmd_destroy_cells(chain, chain->num_cells);\n\tapi_chain_free(chain);\n}\n\n \nint hinic_api_cmd_init(struct hinic_api_cmd_chain **chain,\n\t\t       struct hinic_hwif *hwif)\n{\n\tenum hinic_api_cmd_chain_type type, chain_type;\n\tstruct hinic_api_cmd_chain_attr attr;\n\tstruct pci_dev *pdev = hwif->pdev;\n\tsize_t hw_cell_sz;\n\tint err;\n\n\thw_cell_sz = sizeof(struct hinic_api_cmd_cell);\n\n\tattr.hwif = hwif;\n\tattr.num_cells  = API_CHAIN_NUM_CELLS;\n\tattr.cell_size  = API_CMD_CELL_SIZE(hw_cell_sz);\n\n\tchain_type = HINIC_API_CMD_WRITE_TO_MGMT_CPU;\n\tfor ( ; chain_type < HINIC_API_CMD_MAX; chain_type++) {\n\t\tattr.chain_type = chain_type;\n\n\t\tif (chain_type != HINIC_API_CMD_WRITE_TO_MGMT_CPU)\n\t\t\tcontinue;\n\n\t\tchain[chain_type] = api_cmd_create_chain(&attr);\n\t\tif (IS_ERR(chain[chain_type])) {\n\t\t\tdev_err(&pdev->dev, \"Failed to create chain %d\\n\",\n\t\t\t\tchain_type);\n\t\t\terr = PTR_ERR(chain[chain_type]);\n\t\t\tgoto err_create_chain;\n\t\t}\n\t}\n\n\treturn 0;\n\nerr_create_chain:\n\ttype = HINIC_API_CMD_WRITE_TO_MGMT_CPU;\n\tfor ( ; type < chain_type; type++) {\n\t\tif (type != HINIC_API_CMD_WRITE_TO_MGMT_CPU)\n\t\t\tcontinue;\n\n\t\tapi_cmd_destroy_chain(chain[type]);\n\t}\n\n\treturn err;\n}\n\n \nvoid hinic_api_cmd_free(struct hinic_api_cmd_chain **chain)\n{\n\tenum hinic_api_cmd_chain_type chain_type;\n\n\tchain_type = HINIC_API_CMD_WRITE_TO_MGMT_CPU;\n\tfor ( ; chain_type < HINIC_API_CMD_MAX; chain_type++) {\n\t\tif (chain_type != HINIC_API_CMD_WRITE_TO_MGMT_CPU)\n\t\t\tcontinue;\n\n\t\tapi_cmd_destroy_chain(chain[chain_type]);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}