{
  "module_name": "hinic_hw_mbox.c",
  "hash_id": "f05432ec035c0f96d4e4999b295e3696e88ef320ceb110b9a60d915ed782e8ff",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/huawei/hinic/hinic_hw_mbox.c",
  "human_readable_source": "\n \n#include <linux/pci.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\n#include \"hinic_hw_if.h\"\n#include \"hinic_hw_mgmt.h\"\n#include \"hinic_hw_csr.h\"\n#include \"hinic_hw_dev.h\"\n#include \"hinic_hw_mbox.h\"\n\n#define HINIC_MBOX_INT_DST_FUNC_SHIFT\t\t\t\t0\n#define HINIC_MBOX_INT_DST_AEQN_SHIFT\t\t\t\t10\n#define HINIC_MBOX_INT_SRC_RESP_AEQN_SHIFT\t\t\t12\n#define HINIC_MBOX_INT_STAT_DMA_SHIFT\t\t\t\t14\n \n#define HINIC_MBOX_INT_TX_SIZE_SHIFT\t\t\t\t20\n \n#define HINIC_MBOX_INT_STAT_DMA_SO_RO_SHIFT\t\t\t25\n#define HINIC_MBOX_INT_WB_EN_SHIFT\t\t\t\t28\n\n#define HINIC_MBOX_INT_DST_FUNC_MASK\t\t\t\t0x3FF\n#define HINIC_MBOX_INT_DST_AEQN_MASK\t\t\t\t0x3\n#define HINIC_MBOX_INT_SRC_RESP_AEQN_MASK\t\t\t0x3\n#define HINIC_MBOX_INT_STAT_DMA_MASK\t\t\t\t0x3F\n#define HINIC_MBOX_INT_TX_SIZE_MASK\t\t\t\t0x1F\n#define HINIC_MBOX_INT_STAT_DMA_SO_RO_MASK\t\t\t0x3\n#define HINIC_MBOX_INT_WB_EN_MASK\t\t\t\t0x1\n\n#define HINIC_MBOX_INT_SET(val, field)\t\\\n\t\t\t(((val) & HINIC_MBOX_INT_##field##_MASK) << \\\n\t\t\tHINIC_MBOX_INT_##field##_SHIFT)\n\nenum hinic_mbox_tx_status {\n\tTX_NOT_DONE = 1,\n};\n\n#define HINIC_MBOX_CTRL_TRIGGER_AEQE_SHIFT\t\t\t0\n\n \n#define HINIC_MBOX_CTRL_TX_STATUS_SHIFT\t\t\t\t1\n\n#define HINIC_MBOX_CTRL_TRIGGER_AEQE_MASK\t\t\t0x1\n#define HINIC_MBOX_CTRL_TX_STATUS_MASK\t\t\t\t0x1\n\n#define HINIC_MBOX_CTRL_SET(val, field)\t\\\n\t\t\t(((val) & HINIC_MBOX_CTRL_##field##_MASK) << \\\n\t\t\tHINIC_MBOX_CTRL_##field##_SHIFT)\n\n#define HINIC_MBOX_HEADER_MSG_LEN_SHIFT\t\t\t\t0\n#define HINIC_MBOX_HEADER_MODULE_SHIFT\t\t\t\t11\n#define HINIC_MBOX_HEADER_SEG_LEN_SHIFT\t\t\t\t16\n#define HINIC_MBOX_HEADER_NO_ACK_SHIFT\t\t\t\t22\n#define HINIC_MBOX_HEADER_SEQID_SHIFT\t\t\t\t24\n#define HINIC_MBOX_HEADER_LAST_SHIFT\t\t\t\t30\n\n \n#define HINIC_MBOX_HEADER_DIRECTION_SHIFT\t\t\t31\n#define HINIC_MBOX_HEADER_CMD_SHIFT\t\t\t\t32\n#define HINIC_MBOX_HEADER_MSG_ID_SHIFT\t\t\t\t40\n#define HINIC_MBOX_HEADER_STATUS_SHIFT\t\t\t\t48\n#define HINIC_MBOX_HEADER_SRC_GLB_FUNC_IDX_SHIFT\t\t54\n\n#define HINIC_MBOX_HEADER_MSG_LEN_MASK\t\t\t\t0x7FF\n#define HINIC_MBOX_HEADER_MODULE_MASK\t\t\t\t0x1F\n#define HINIC_MBOX_HEADER_SEG_LEN_MASK\t\t\t\t0x3F\n#define HINIC_MBOX_HEADER_NO_ACK_MASK\t\t\t\t0x1\n#define HINIC_MBOX_HEADER_SEQID_MASK\t\t\t\t0x3F\n#define HINIC_MBOX_HEADER_LAST_MASK\t\t\t\t0x1\n#define HINIC_MBOX_HEADER_DIRECTION_MASK\t\t\t0x1\n#define HINIC_MBOX_HEADER_CMD_MASK\t\t\t\t0xFF\n#define HINIC_MBOX_HEADER_MSG_ID_MASK\t\t\t\t0xFF\n#define HINIC_MBOX_HEADER_STATUS_MASK\t\t\t\t0x3F\n#define HINIC_MBOX_HEADER_SRC_GLB_FUNC_IDX_MASK\t\t\t0x3FF\n\n#define HINIC_MBOX_HEADER_GET(val, field)\t\\\n\t\t\t(((val) >> HINIC_MBOX_HEADER_##field##_SHIFT) & \\\n\t\t\tHINIC_MBOX_HEADER_##field##_MASK)\n#define HINIC_MBOX_HEADER_SET(val, field)\t\\\n\t\t\t((u64)((val) & HINIC_MBOX_HEADER_##field##_MASK) << \\\n\t\t\tHINIC_MBOX_HEADER_##field##_SHIFT)\n\n#define MBOX_SEGLEN_MASK\t\t\t\\\n\t\tHINIC_MBOX_HEADER_SET(HINIC_MBOX_HEADER_SEG_LEN_MASK, SEG_LEN)\n\n#define HINIC_MBOX_SEG_LEN\t\t\t48\n#define HINIC_MBOX_COMP_TIME\t\t\t8000U\n#define MBOX_MSG_POLLING_TIMEOUT\t\t8000\n\n#define HINIC_MBOX_DATA_SIZE\t\t\t2040\n\n#define MBOX_MAX_BUF_SZ\t\t\t\t2048UL\n#define MBOX_HEADER_SZ\t\t\t\t8\n\n#define MBOX_INFO_SZ\t\t\t\t4\n\n \n#define MBOX_SEG_LEN\t\t\t\t48\n#define MBOX_SEG_LEN_ALIGN\t\t\t4\n#define MBOX_WB_STATUS_LEN\t\t\t16UL\n\n \n#define MBOX_WB_STATUS_ERRCODE_MASK\t\t0xFFFF\n#define MBOX_WB_STATUS_MASK\t\t\t0xFF\n#define MBOX_WB_ERROR_CODE_MASK\t\t\t0xFF00\n#define MBOX_WB_STATUS_FINISHED_SUCCESS\t\t0xFF\n#define MBOX_WB_STATUS_NOT_FINISHED\t\t0x00\n\n#define MBOX_STATUS_FINISHED(wb)\t\\\n\t(((wb) & MBOX_WB_STATUS_MASK) != MBOX_WB_STATUS_NOT_FINISHED)\n#define MBOX_STATUS_SUCCESS(wb)\t\t\\\n\t(((wb) & MBOX_WB_STATUS_MASK) == MBOX_WB_STATUS_FINISHED_SUCCESS)\n#define MBOX_STATUS_ERRCODE(wb)\t\t\\\n\t((wb) & MBOX_WB_ERROR_CODE_MASK)\n\n#define SEQ_ID_START_VAL\t\t\t0\n#define SEQ_ID_MAX_VAL\t\t\t\t42\n\n#define NO_DMA_ATTRIBUTE_VAL\t\t\t0\n\n#define HINIC_MBOX_RSP_AEQN\t\t\t2\n#define HINIC_MBOX_RECV_AEQN\t\t\t0\n\n#define MBOX_MSG_NO_DATA_LEN\t\t\t1\n\n#define MBOX_BODY_FROM_HDR(header)\t((u8 *)(header) + MBOX_HEADER_SZ)\n#define MBOX_AREA(hwif)\t\t\t\\\n\t((hwif)->cfg_regs_bar + HINIC_FUNC_CSR_MAILBOX_DATA_OFF)\n\n#define IS_PF_OR_PPF_SRC(src_func_idx)\t((src_func_idx) < HINIC_MAX_PF_FUNCS)\n\n#define MBOX_MSG_ID_MASK\t\t0xFF\n#define MBOX_MSG_ID(func_to_func)\t((func_to_func)->send_msg_id)\n#define MBOX_MSG_ID_INC(func_to_func_mbox) (MBOX_MSG_ID(func_to_func_mbox) = \\\n\t\t\t(MBOX_MSG_ID(func_to_func_mbox) + 1) & MBOX_MSG_ID_MASK)\n\n#define FUNC_ID_OFF_SET_8B\t\t8\n\n \n#define HINIC_MAX_MSG_CNT_TO_PROCESS\t10\n\n#define HINIC_QUEUE_MIN_DEPTH\t\t6\n#define HINIC_QUEUE_MAX_DEPTH\t\t12\n#define HINIC_MAX_RX_BUFFER_SIZE\t\t15\n\nenum hinic_hwif_direction_type {\n\tHINIC_HWIF_DIRECT_SEND\t= 0,\n\tHINIC_HWIF_RESPONSE\t= 1,\n};\n\nenum mbox_send_mod {\n\tMBOX_SEND_MSG_INT,\n};\n\nenum mbox_seg_type {\n\tNOT_LAST_SEG,\n\tLAST_SEG,\n};\n\nenum mbox_ordering_type {\n\tSTRONG_ORDER,\n};\n\nenum mbox_write_back_type {\n\tWRITE_BACK = 1,\n};\n\nenum mbox_aeq_trig_type {\n\tNOT_TRIGGER,\n\tTRIGGER,\n};\n\nstatic bool check_func_id(struct hinic_hwdev *hwdev, u16 src_func_idx,\n\t\t\t  const void *buf_in, u16 in_size, u16 offset)\n{\n\tu16 func_idx;\n\n\tif (in_size < offset + sizeof(func_idx)) {\n\t\tdev_warn(&hwdev->hwif->pdev->dev,\n\t\t\t \"Receive mailbox msg len: %d less than %d Bytes is invalid\\n\",\n\t\t\t in_size, offset);\n\t\treturn false;\n\t}\n\n\tfunc_idx = *((u16 *)((u8 *)buf_in + offset));\n\n\tif (src_func_idx != func_idx) {\n\t\tdev_warn(&hwdev->hwif->pdev->dev,\n\t\t\t \"Receive mailbox function id: 0x%x not equal to msg function id: 0x%x\\n\",\n\t\t\t src_func_idx, func_idx);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nbool hinic_mbox_check_func_id_8B(struct hinic_hwdev *hwdev, u16 func_idx,\n\t\t\t\t void *buf_in, u16 in_size)\n{\n\treturn check_func_id(hwdev, func_idx, buf_in, in_size,\n\t\t\t     FUNC_ID_OFF_SET_8B);\n}\n\n \nint hinic_register_pf_mbox_cb(struct hinic_hwdev *hwdev,\n\t\t\t      enum hinic_mod_type mod,\n\t\t\t      hinic_pf_mbox_cb callback)\n{\n\tstruct hinic_mbox_func_to_func *func_to_func = hwdev->func_to_func;\n\n\tif (mod >= HINIC_MOD_MAX)\n\t\treturn -EFAULT;\n\n\tfunc_to_func->pf_mbox_cb[mod] = callback;\n\n\tset_bit(HINIC_PF_MBOX_CB_REG, &func_to_func->pf_mbox_cb_state[mod]);\n\n\treturn 0;\n}\n\n \nint hinic_register_vf_mbox_cb(struct hinic_hwdev *hwdev,\n\t\t\t      enum hinic_mod_type mod,\n\t\t\t      hinic_vf_mbox_cb callback)\n{\n\tstruct hinic_mbox_func_to_func *func_to_func = hwdev->func_to_func;\n\n\tif (mod >= HINIC_MOD_MAX)\n\t\treturn -EFAULT;\n\n\tfunc_to_func->vf_mbox_cb[mod] = callback;\n\n\tset_bit(HINIC_VF_MBOX_CB_REG, &func_to_func->vf_mbox_cb_state[mod]);\n\n\treturn 0;\n}\n\n \nvoid hinic_unregister_pf_mbox_cb(struct hinic_hwdev *hwdev,\n\t\t\t\t enum hinic_mod_type mod)\n{\n\tstruct hinic_mbox_func_to_func *func_to_func = hwdev->func_to_func;\n\n\tclear_bit(HINIC_PF_MBOX_CB_REG, &func_to_func->pf_mbox_cb_state[mod]);\n\n\twhile (test_bit(HINIC_PF_MBOX_CB_RUNNING,\n\t\t\t&func_to_func->pf_mbox_cb_state[mod]))\n\t\tusleep_range(900, 1000);\n\n\tfunc_to_func->pf_mbox_cb[mod] = NULL;\n}\n\n \nvoid hinic_unregister_vf_mbox_cb(struct hinic_hwdev *hwdev,\n\t\t\t\t enum hinic_mod_type mod)\n{\n\tstruct hinic_mbox_func_to_func *func_to_func = hwdev->func_to_func;\n\n\tclear_bit(HINIC_VF_MBOX_CB_REG, &func_to_func->vf_mbox_cb_state[mod]);\n\n\twhile (test_bit(HINIC_VF_MBOX_CB_RUNNING,\n\t\t\t&func_to_func->vf_mbox_cb_state[mod]))\n\t\tusleep_range(900, 1000);\n\n\tfunc_to_func->vf_mbox_cb[mod] = NULL;\n}\n\nstatic int recv_vf_mbox_handler(struct hinic_mbox_func_to_func *func_to_func,\n\t\t\t\tstruct hinic_recv_mbox *recv_mbox,\n\t\t\t\tvoid *buf_out, u16 *out_size)\n{\n\thinic_vf_mbox_cb cb;\n\tint ret = 0;\n\n\tif (recv_mbox->mod >= HINIC_MOD_MAX) {\n\t\tdev_err(&func_to_func->hwif->pdev->dev, \"Receive illegal mbox message, mod = %d\\n\",\n\t\t\trecv_mbox->mod);\n\t\treturn -EINVAL;\n\t}\n\n\tset_bit(HINIC_VF_MBOX_CB_RUNNING,\n\t\t&func_to_func->vf_mbox_cb_state[recv_mbox->mod]);\n\n\tcb = func_to_func->vf_mbox_cb[recv_mbox->mod];\n\tif (cb && test_bit(HINIC_VF_MBOX_CB_REG,\n\t\t\t   &func_to_func->vf_mbox_cb_state[recv_mbox->mod])) {\n\t\tcb(func_to_func->hwdev, recv_mbox->cmd, recv_mbox->mbox,\n\t\t   recv_mbox->mbox_len, buf_out, out_size);\n\t} else {\n\t\tdev_err(&func_to_func->hwif->pdev->dev, \"VF mbox cb is not registered\\n\");\n\t\tret = -EINVAL;\n\t}\n\n\tclear_bit(HINIC_VF_MBOX_CB_RUNNING,\n\t\t  &func_to_func->vf_mbox_cb_state[recv_mbox->mod]);\n\n\treturn ret;\n}\n\nstatic int\nrecv_pf_from_vf_mbox_handler(struct hinic_mbox_func_to_func *func_to_func,\n\t\t\t     struct hinic_recv_mbox *recv_mbox,\n\t\t\t     u16 src_func_idx, void *buf_out,\n\t\t\t     u16 *out_size)\n{\n\thinic_pf_mbox_cb cb;\n\tu16 vf_id = 0;\n\tint ret;\n\n\tif (recv_mbox->mod >= HINIC_MOD_MAX) {\n\t\tdev_err(&func_to_func->hwif->pdev->dev, \"Receive illegal mbox message, mod = %d\\n\",\n\t\t\trecv_mbox->mod);\n\t\treturn -EINVAL;\n\t}\n\n\tset_bit(HINIC_PF_MBOX_CB_RUNNING,\n\t\t&func_to_func->pf_mbox_cb_state[recv_mbox->mod]);\n\n\tcb = func_to_func->pf_mbox_cb[recv_mbox->mod];\n\tif (cb && test_bit(HINIC_PF_MBOX_CB_REG,\n\t\t\t   &func_to_func->pf_mbox_cb_state[recv_mbox->mod])) {\n\t\tvf_id = src_func_idx -\n\t\t\thinic_glb_pf_vf_offset(func_to_func->hwif);\n\t\tret = cb(func_to_func->hwdev, vf_id, recv_mbox->cmd,\n\t\t\t recv_mbox->mbox, recv_mbox->mbox_len,\n\t\t\t buf_out, out_size);\n\t} else {\n\t\tdev_err(&func_to_func->hwif->pdev->dev, \"PF mbox mod(0x%x) cb is not registered\\n\",\n\t\t\trecv_mbox->mod);\n\t\tret = -EINVAL;\n\t}\n\n\tclear_bit(HINIC_PF_MBOX_CB_RUNNING,\n\t\t  &func_to_func->pf_mbox_cb_state[recv_mbox->mod]);\n\n\treturn ret;\n}\n\nstatic bool check_mbox_seq_id_and_seg_len(struct hinic_recv_mbox *recv_mbox,\n\t\t\t\t\t  u8 seq_id, u8 seg_len)\n{\n\tif (seq_id > SEQ_ID_MAX_VAL || seg_len > MBOX_SEG_LEN)\n\t\treturn false;\n\n\tif (seq_id == 0) {\n\t\trecv_mbox->seq_id = seq_id;\n\t} else {\n\t\tif (seq_id != recv_mbox->seq_id + 1)\n\t\t\treturn false;\n\n\t\trecv_mbox->seq_id = seq_id;\n\t}\n\n\treturn true;\n}\n\nstatic void resp_mbox_handler(struct hinic_mbox_func_to_func *func_to_func,\n\t\t\t      struct hinic_recv_mbox *recv_mbox)\n{\n\tspin_lock(&func_to_func->mbox_lock);\n\tif (recv_mbox->msg_info.msg_id == func_to_func->send_msg_id &&\n\t    func_to_func->event_flag == EVENT_START)\n\t\tcomplete(&recv_mbox->recv_done);\n\telse\n\t\tdev_err(&func_to_func->hwif->pdev->dev,\n\t\t\t\"Mbox response timeout, current send msg id(0x%x), recv msg id(0x%x), status(0x%x)\\n\",\n\t\t\tfunc_to_func->send_msg_id, recv_mbox->msg_info.msg_id,\n\t\t\trecv_mbox->msg_info.status);\n\tspin_unlock(&func_to_func->mbox_lock);\n}\n\nstatic void recv_func_mbox_handler(struct hinic_mbox_func_to_func *func_to_func,\n\t\t\t\t   struct hinic_recv_mbox *recv_mbox,\n\t\t\t\t   u16 src_func_idx);\n\nstatic void recv_func_mbox_work_handler(struct work_struct *work)\n{\n\tstruct hinic_mbox_work *mbox_work =\n\t\t\tcontainer_of(work, struct hinic_mbox_work, work);\n\tstruct hinic_recv_mbox *recv_mbox;\n\n\trecv_func_mbox_handler(mbox_work->func_to_func, mbox_work->recv_mbox,\n\t\t\t       mbox_work->src_func_idx);\n\n\trecv_mbox =\n\t\t&mbox_work->func_to_func->mbox_send[mbox_work->src_func_idx];\n\n\tatomic_dec(&recv_mbox->msg_cnt);\n\n\tkfree(mbox_work);\n}\n\nstatic void recv_mbox_handler(struct hinic_mbox_func_to_func *func_to_func,\n\t\t\t      void *header, struct hinic_recv_mbox *recv_mbox)\n{\n\tvoid *mbox_body = MBOX_BODY_FROM_HDR(header);\n\tstruct hinic_recv_mbox *rcv_mbox_temp = NULL;\n\tu64 mbox_header = *((u64 *)header);\n\tstruct hinic_mbox_work *mbox_work;\n\tu8 seq_id, seg_len;\n\tu16 src_func_idx;\n\tint pos;\n\n\tseq_id = HINIC_MBOX_HEADER_GET(mbox_header, SEQID);\n\tseg_len = HINIC_MBOX_HEADER_GET(mbox_header, SEG_LEN);\n\tsrc_func_idx = HINIC_MBOX_HEADER_GET(mbox_header, SRC_GLB_FUNC_IDX);\n\n\tif (!check_mbox_seq_id_and_seg_len(recv_mbox, seq_id, seg_len)) {\n\t\tdev_err(&func_to_func->hwif->pdev->dev,\n\t\t\t\"Mailbox sequence and segment check fail, src func id: 0x%x, front id: 0x%x, current id: 0x%x, seg len: 0x%x\\n\",\n\t\t\tsrc_func_idx, recv_mbox->seq_id, seq_id, seg_len);\n\t\trecv_mbox->seq_id = SEQ_ID_MAX_VAL;\n\t\treturn;\n\t}\n\n\tpos = seq_id * MBOX_SEG_LEN;\n\tmemcpy((u8 *)recv_mbox->mbox + pos, mbox_body,\n\t       HINIC_MBOX_HEADER_GET(mbox_header, SEG_LEN));\n\n\tif (!HINIC_MBOX_HEADER_GET(mbox_header, LAST))\n\t\treturn;\n\n\trecv_mbox->cmd = HINIC_MBOX_HEADER_GET(mbox_header, CMD);\n\trecv_mbox->mod = HINIC_MBOX_HEADER_GET(mbox_header, MODULE);\n\trecv_mbox->mbox_len = HINIC_MBOX_HEADER_GET(mbox_header, MSG_LEN);\n\trecv_mbox->ack_type = HINIC_MBOX_HEADER_GET(mbox_header, NO_ACK);\n\trecv_mbox->msg_info.msg_id = HINIC_MBOX_HEADER_GET(mbox_header, MSG_ID);\n\trecv_mbox->msg_info.status = HINIC_MBOX_HEADER_GET(mbox_header, STATUS);\n\trecv_mbox->seq_id = SEQ_ID_MAX_VAL;\n\n\tif (HINIC_MBOX_HEADER_GET(mbox_header, DIRECTION) ==\n\t    HINIC_HWIF_RESPONSE) {\n\t\tresp_mbox_handler(func_to_func, recv_mbox);\n\t\treturn;\n\t}\n\n\tif (atomic_read(&recv_mbox->msg_cnt) > HINIC_MAX_MSG_CNT_TO_PROCESS) {\n\t\tdev_warn(&func_to_func->hwif->pdev->dev,\n\t\t\t \"This function(%u) have %d message wait to process,can't add to work queue\\n\",\n\t\t\t src_func_idx, atomic_read(&recv_mbox->msg_cnt));\n\t\treturn;\n\t}\n\n\trcv_mbox_temp = kmemdup(recv_mbox, sizeof(*rcv_mbox_temp), GFP_KERNEL);\n\tif (!rcv_mbox_temp)\n\t\treturn;\n\n\trcv_mbox_temp->mbox = kmemdup(recv_mbox->mbox, MBOX_MAX_BUF_SZ,\n\t\t\t\t      GFP_KERNEL);\n\tif (!rcv_mbox_temp->mbox)\n\t\tgoto err_alloc_rcv_mbox_msg;\n\n\trcv_mbox_temp->buf_out = kzalloc(MBOX_MAX_BUF_SZ, GFP_KERNEL);\n\tif (!rcv_mbox_temp->buf_out)\n\t\tgoto err_alloc_rcv_mbox_buf;\n\n\tmbox_work = kzalloc(sizeof(*mbox_work), GFP_KERNEL);\n\tif (!mbox_work)\n\t\tgoto err_alloc_mbox_work;\n\n\tmbox_work->func_to_func = func_to_func;\n\tmbox_work->recv_mbox = rcv_mbox_temp;\n\tmbox_work->src_func_idx = src_func_idx;\n\n\tatomic_inc(&recv_mbox->msg_cnt);\n\tINIT_WORK(&mbox_work->work, recv_func_mbox_work_handler);\n\tqueue_work(func_to_func->workq, &mbox_work->work);\n\n\treturn;\n\nerr_alloc_mbox_work:\n\tkfree(rcv_mbox_temp->buf_out);\n\nerr_alloc_rcv_mbox_buf:\n\tkfree(rcv_mbox_temp->mbox);\n\nerr_alloc_rcv_mbox_msg:\n\tkfree(rcv_mbox_temp);\n}\n\nstatic int set_vf_mbox_random_id(struct hinic_hwdev *hwdev, u16 func_id)\n{\n\tstruct hinic_mbox_func_to_func *func_to_func = hwdev->func_to_func;\n\tstruct hinic_set_random_id rand_info = {0};\n\tu16 out_size = sizeof(rand_info);\n\tstruct hinic_pfhwdev *pfhwdev;\n\tint ret;\n\n\tpfhwdev = container_of(hwdev, struct hinic_pfhwdev, hwdev);\n\n\trand_info.version = HINIC_CMD_VER_FUNC_ID;\n\trand_info.func_idx = func_id;\n\trand_info.vf_in_pf = func_id - hinic_glb_pf_vf_offset(hwdev->hwif);\n\trand_info.random_id = get_random_u32();\n\n\tfunc_to_func->vf_mbx_rand_id[func_id] = rand_info.random_id;\n\n\tret = hinic_msg_to_mgmt(&pfhwdev->pf_to_mgmt, HINIC_MOD_COMM,\n\t\t\t\tHINIC_MGMT_CMD_SET_VF_RANDOM_ID,\n\t\t\t\t&rand_info, sizeof(rand_info),\n\t\t\t\t&rand_info, &out_size, HINIC_MGMT_MSG_SYNC);\n\tif ((rand_info.status != HINIC_MGMT_CMD_UNSUPPORTED &&\n\t     rand_info.status) || !out_size || ret) {\n\t\tdev_err(&hwdev->hwif->pdev->dev, \"Set VF random id failed, err: %d, status: 0x%x, out size: 0x%x\\n\",\n\t\t\tret, rand_info.status, out_size);\n\t\treturn -EIO;\n\t}\n\n\tif (rand_info.status == HINIC_MGMT_CMD_UNSUPPORTED)\n\t\treturn rand_info.status;\n\n\tfunc_to_func->vf_mbx_old_rand_id[func_id] =\n\t\t\t\tfunc_to_func->vf_mbx_rand_id[func_id];\n\n\treturn 0;\n}\n\nstatic void update_random_id_work_handler(struct work_struct *work)\n{\n\tstruct hinic_mbox_work *mbox_work =\n\t\t\tcontainer_of(work, struct hinic_mbox_work, work);\n\tstruct hinic_mbox_func_to_func *func_to_func;\n\tu16 src = mbox_work->src_func_idx;\n\n\tfunc_to_func = mbox_work->func_to_func;\n\n\tif (set_vf_mbox_random_id(func_to_func->hwdev, src))\n\t\tdev_warn(&func_to_func->hwdev->hwif->pdev->dev, \"Update VF id: 0x%x random id failed\\n\",\n\t\t\t mbox_work->src_func_idx);\n\n\tkfree(mbox_work);\n}\n\nstatic bool check_vf_mbox_random_id(struct hinic_mbox_func_to_func *func_to_func,\n\t\t\t\t    u8 *header)\n{\n\tstruct hinic_hwdev *hwdev = func_to_func->hwdev;\n\tstruct hinic_mbox_work *mbox_work = NULL;\n\tu64 mbox_header = *((u64 *)header);\n\tu16 offset, src;\n\tu32 random_id;\n\tint vf_in_pf;\n\n\tsrc = HINIC_MBOX_HEADER_GET(mbox_header, SRC_GLB_FUNC_IDX);\n\n\tif (IS_PF_OR_PPF_SRC(src) || !func_to_func->support_vf_random)\n\t\treturn true;\n\n\tif (!HINIC_IS_PPF(hwdev->hwif)) {\n\t\toffset = hinic_glb_pf_vf_offset(hwdev->hwif);\n\t\tvf_in_pf = src - offset;\n\n\t\tif (vf_in_pf < 1 || vf_in_pf > hwdev->nic_cap.max_vf) {\n\t\t\tdev_warn(&hwdev->hwif->pdev->dev,\n\t\t\t\t \"Receive vf id(0x%x) is invalid, vf id should be from 0x%x to 0x%x\\n\",\n\t\t\t\t src, offset + 1,\n\t\t\t\t hwdev->nic_cap.max_vf + offset);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\trandom_id = be32_to_cpu(*(u32 *)(header + MBOX_SEG_LEN +\n\t\t\t\t\t MBOX_HEADER_SZ));\n\n\tif (random_id == func_to_func->vf_mbx_rand_id[src] ||\n\t    random_id == func_to_func->vf_mbx_old_rand_id[src])\n\t\treturn true;\n\n\tdev_warn(&hwdev->hwif->pdev->dev,\n\t\t \"The mailbox random id(0x%x) of func_id(0x%x) doesn't match with pf reservation(0x%x)\\n\",\n\t\t random_id, src, func_to_func->vf_mbx_rand_id[src]);\n\n\tmbox_work = kzalloc(sizeof(*mbox_work), GFP_KERNEL);\n\tif (!mbox_work)\n\t\treturn false;\n\n\tmbox_work->func_to_func = func_to_func;\n\tmbox_work->src_func_idx = src;\n\n\tINIT_WORK(&mbox_work->work, update_random_id_work_handler);\n\tqueue_work(func_to_func->workq, &mbox_work->work);\n\n\treturn false;\n}\n\nstatic void hinic_mbox_func_aeqe_handler(void *handle, void *header, u8 size)\n{\n\tstruct hinic_mbox_func_to_func *func_to_func;\n\tu64 mbox_header = *((u64 *)header);\n\tstruct hinic_recv_mbox *recv_mbox;\n\tu64 src, dir;\n\n\tfunc_to_func = ((struct hinic_hwdev *)handle)->func_to_func;\n\n\tdir = HINIC_MBOX_HEADER_GET(mbox_header, DIRECTION);\n\tsrc = HINIC_MBOX_HEADER_GET(mbox_header, SRC_GLB_FUNC_IDX);\n\n\tif (src >= HINIC_MAX_FUNCTIONS) {\n\t\tdev_err(&func_to_func->hwif->pdev->dev,\n\t\t\t\"Mailbox source function id:%u is invalid\\n\", (u32)src);\n\t\treturn;\n\t}\n\n\tif (!check_vf_mbox_random_id(func_to_func, header))\n\t\treturn;\n\n\trecv_mbox = (dir == HINIC_HWIF_DIRECT_SEND) ?\n\t\t    &func_to_func->mbox_send[src] :\n\t\t    &func_to_func->mbox_resp[src];\n\n\trecv_mbox_handler(func_to_func, (u64 *)header, recv_mbox);\n}\n\nstatic void hinic_mbox_self_aeqe_handler(void *handle, void *header, u8 size)\n{\n\tstruct hinic_mbox_func_to_func *func_to_func;\n\tstruct hinic_send_mbox *send_mbox;\n\n\tfunc_to_func = ((struct hinic_hwdev *)handle)->func_to_func;\n\tsend_mbox = &func_to_func->send_mbox;\n\n\tcomplete(&send_mbox->send_done);\n}\n\nstatic void clear_mbox_status(struct hinic_send_mbox *mbox)\n{\n\t*mbox->wb_status = 0;\n\n\t \n\twmb();\n}\n\nstatic void mbox_copy_header(struct hinic_hwdev *hwdev,\n\t\t\t     struct hinic_send_mbox *mbox, u64 *header)\n{\n\tu32 i, idx_max = MBOX_HEADER_SZ / sizeof(u32);\n\tu32 *data = (u32 *)header;\n\n\tfor (i = 0; i < idx_max; i++)\n\t\t__raw_writel(*(data + i), mbox->data + i * sizeof(u32));\n}\n\nstatic void mbox_copy_send_data(struct hinic_hwdev *hwdev,\n\t\t\t\tstruct hinic_send_mbox *mbox, void *seg,\n\t\t\t\tu16 seg_len)\n{\n\tu8 mbox_max_buf[MBOX_SEG_LEN] = {0};\n\tu32 data_len, chk_sz = sizeof(u32);\n\tu32 *data = seg;\n\tu32 i, idx_max;\n\n\t \n\tif (seg_len % chk_sz) {\n\t\tmemcpy(mbox_max_buf, seg, seg_len);\n\t\tdata = (u32 *)mbox_max_buf;\n\t}\n\n\tdata_len = seg_len;\n\tidx_max = ALIGN(data_len, chk_sz) / chk_sz;\n\n\tfor (i = 0; i < idx_max; i++)\n\t\t__raw_writel(*(data + i),\n\t\t\t     mbox->data + MBOX_HEADER_SZ + i * sizeof(u32));\n}\n\nstatic void write_mbox_msg_attr(struct hinic_mbox_func_to_func *func_to_func,\n\t\t\t\tu16 dst_func, u16 dst_aeqn, u16 seg_len,\n\t\t\t\tint poll)\n{\n\tu16 rsp_aeq = (dst_aeqn == 0) ? 0 : HINIC_MBOX_RSP_AEQN;\n\tu32 mbox_int, mbox_ctrl;\n\n\tmbox_int = HINIC_MBOX_INT_SET(dst_func, DST_FUNC) |\n\t\t   HINIC_MBOX_INT_SET(dst_aeqn, DST_AEQN) |\n\t\t   HINIC_MBOX_INT_SET(rsp_aeq, SRC_RESP_AEQN) |\n\t\t   HINIC_MBOX_INT_SET(NO_DMA_ATTRIBUTE_VAL, STAT_DMA) |\n\t\t   HINIC_MBOX_INT_SET(ALIGN(MBOX_SEG_LEN + MBOX_HEADER_SZ +\n\t\t\t\t      MBOX_INFO_SZ, MBOX_SEG_LEN_ALIGN) >> 2,\n\t\t\t\t      TX_SIZE) |\n\t\t   HINIC_MBOX_INT_SET(STRONG_ORDER, STAT_DMA_SO_RO) |\n\t\t   HINIC_MBOX_INT_SET(WRITE_BACK, WB_EN);\n\n\thinic_hwif_write_reg(func_to_func->hwif,\n\t\t\t     HINIC_FUNC_CSR_MAILBOX_INT_OFFSET_OFF, mbox_int);\n\n\twmb();  \n\tmbox_ctrl = HINIC_MBOX_CTRL_SET(TX_NOT_DONE, TX_STATUS);\n\n\tif (poll)\n\t\tmbox_ctrl |= HINIC_MBOX_CTRL_SET(NOT_TRIGGER, TRIGGER_AEQE);\n\telse\n\t\tmbox_ctrl |= HINIC_MBOX_CTRL_SET(TRIGGER, TRIGGER_AEQE);\n\n\thinic_hwif_write_reg(func_to_func->hwif,\n\t\t\t     HINIC_FUNC_CSR_MAILBOX_CONTROL_OFF, mbox_ctrl);\n}\n\nstatic void dump_mox_reg(struct hinic_hwdev *hwdev)\n{\n\tu32 val;\n\n\tval = hinic_hwif_read_reg(hwdev->hwif,\n\t\t\t\t  HINIC_FUNC_CSR_MAILBOX_CONTROL_OFF);\n\tdev_err(&hwdev->hwif->pdev->dev, \"Mailbox control reg: 0x%x\\n\", val);\n\n\tval = hinic_hwif_read_reg(hwdev->hwif,\n\t\t\t\t  HINIC_FUNC_CSR_MAILBOX_INT_OFFSET_OFF);\n\tdev_err(&hwdev->hwif->pdev->dev, \"Mailbox interrupt offset: 0x%x\\n\",\n\t\tval);\n}\n\nstatic u16 get_mbox_status(struct hinic_send_mbox *mbox)\n{\n\t \n\tu64 wb_val = be64_to_cpu(*mbox->wb_status);\n\n\trmb();  \n\n\treturn (u16)(wb_val & MBOX_WB_STATUS_ERRCODE_MASK);\n}\n\nstatic int\nwait_for_mbox_seg_completion(struct hinic_mbox_func_to_func *func_to_func,\n\t\t\t     int poll, u16 *wb_status)\n{\n\tstruct hinic_send_mbox *send_mbox = &func_to_func->send_mbox;\n\tstruct hinic_hwdev *hwdev = func_to_func->hwdev;\n\tstruct completion *done = &send_mbox->send_done;\n\tu32 cnt = 0;\n\tunsigned long jif;\n\n\tif (poll) {\n\t\twhile (cnt < MBOX_MSG_POLLING_TIMEOUT) {\n\t\t\t*wb_status = get_mbox_status(send_mbox);\n\t\t\tif (MBOX_STATUS_FINISHED(*wb_status))\n\t\t\t\tbreak;\n\n\t\t\tusleep_range(900, 1000);\n\t\t\tcnt++;\n\t\t}\n\n\t\tif (cnt == MBOX_MSG_POLLING_TIMEOUT) {\n\t\t\tdev_err(&hwdev->hwif->pdev->dev, \"Send mailbox segment timeout, wb status: 0x%x\\n\",\n\t\t\t\t*wb_status);\n\t\t\tdump_mox_reg(hwdev);\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t} else {\n\t\tjif = msecs_to_jiffies(HINIC_MBOX_COMP_TIME);\n\t\tif (!wait_for_completion_timeout(done, jif)) {\n\t\t\tdev_err(&hwdev->hwif->pdev->dev, \"Send mailbox segment timeout\\n\");\n\t\t\tdump_mox_reg(hwdev);\n\t\t\thinic_dump_aeq_info(hwdev);\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\n\t\t*wb_status = get_mbox_status(send_mbox);\n\t}\n\n\treturn 0;\n}\n\nstatic int send_mbox_seg(struct hinic_mbox_func_to_func *func_to_func,\n\t\t\t u64 header, u16 dst_func, void *seg, u16 seg_len,\n\t\t\t int poll, void *msg_info)\n{\n\tstruct hinic_send_mbox *send_mbox = &func_to_func->send_mbox;\n\tu16 seq_dir = HINIC_MBOX_HEADER_GET(header, DIRECTION);\n\tstruct hinic_hwdev *hwdev = func_to_func->hwdev;\n\tstruct completion *done = &send_mbox->send_done;\n\tu8 num_aeqs = hwdev->hwif->attr.num_aeqs;\n\tu16 dst_aeqn, wb_status = 0, errcode;\n\n\tif (num_aeqs >= 4)\n\t\tdst_aeqn = (seq_dir == HINIC_HWIF_DIRECT_SEND) ?\n\t\t\t   HINIC_MBOX_RECV_AEQN : HINIC_MBOX_RSP_AEQN;\n\telse\n\t\tdst_aeqn = 0;\n\n\tif (!poll)\n\t\tinit_completion(done);\n\n\tclear_mbox_status(send_mbox);\n\n\tmbox_copy_header(hwdev, send_mbox, &header);\n\n\tmbox_copy_send_data(hwdev, send_mbox, seg, seg_len);\n\n\twrite_mbox_msg_attr(func_to_func, dst_func, dst_aeqn, seg_len, poll);\n\n\twmb();  \n\n\tif (wait_for_mbox_seg_completion(func_to_func, poll, &wb_status))\n\t\treturn -ETIMEDOUT;\n\n\tif (!MBOX_STATUS_SUCCESS(wb_status)) {\n\t\tdev_err(&hwdev->hwif->pdev->dev, \"Send mailbox segment to function %d error, wb status: 0x%x\\n\",\n\t\t\tdst_func, wb_status);\n\t\terrcode = MBOX_STATUS_ERRCODE(wb_status);\n\t\treturn errcode ? errcode : -EFAULT;\n\t}\n\n\treturn 0;\n}\n\nstatic int send_mbox_to_func(struct hinic_mbox_func_to_func *func_to_func,\n\t\t\t     enum hinic_mod_type mod, u16 cmd, void *msg,\n\t\t\t     u16 msg_len, u16 dst_func,\n\t\t\t     enum hinic_hwif_direction_type direction,\n\t\t\t     enum hinic_mbox_ack_type ack_type,\n\t\t\t     struct mbox_msg_info *msg_info)\n{\n\tstruct hinic_hwdev *hwdev = func_to_func->hwdev;\n\tu16 seg_len = MBOX_SEG_LEN;\n\tu8 *msg_seg = (u8 *)msg;\n\tu16 left = msg_len;\n\tu32 seq_id = 0;\n\tu64 header = 0;\n\tint err = 0;\n\n\tdown(&func_to_func->msg_send_sem);\n\n\theader = HINIC_MBOX_HEADER_SET(msg_len, MSG_LEN) |\n\t\t HINIC_MBOX_HEADER_SET(mod, MODULE) |\n\t\t HINIC_MBOX_HEADER_SET(seg_len, SEG_LEN) |\n\t\t HINIC_MBOX_HEADER_SET(ack_type, NO_ACK) |\n\t\t HINIC_MBOX_HEADER_SET(SEQ_ID_START_VAL, SEQID) |\n\t\t HINIC_MBOX_HEADER_SET(NOT_LAST_SEG, LAST) |\n\t\t HINIC_MBOX_HEADER_SET(direction, DIRECTION) |\n\t\t HINIC_MBOX_HEADER_SET(cmd, CMD) |\n\t\t  \n\t\t HINIC_MBOX_HEADER_SET(msg_info->msg_id, MSG_ID) |\n\t\t HINIC_MBOX_HEADER_SET(msg_info->status, STATUS) |\n\t\t HINIC_MBOX_HEADER_SET(hinic_global_func_id_hw(hwdev->hwif),\n\t\t\t\t       SRC_GLB_FUNC_IDX);\n\n\twhile (!(HINIC_MBOX_HEADER_GET(header, LAST))) {\n\t\tif (left <= HINIC_MBOX_SEG_LEN) {\n\t\t\theader &= ~MBOX_SEGLEN_MASK;\n\t\t\theader |= HINIC_MBOX_HEADER_SET(left, SEG_LEN);\n\t\t\theader |= HINIC_MBOX_HEADER_SET(LAST_SEG, LAST);\n\n\t\t\tseg_len = left;\n\t\t}\n\n\t\terr = send_mbox_seg(func_to_func, header, dst_func, msg_seg,\n\t\t\t\t    seg_len, MBOX_SEND_MSG_INT, msg_info);\n\t\tif (err) {\n\t\t\tdev_err(&hwdev->hwif->pdev->dev, \"Failed to send mbox seg, seq_id=0x%llx\\n\",\n\t\t\t\tHINIC_MBOX_HEADER_GET(header, SEQID));\n\t\t\tgoto err_send_mbox_seg;\n\t\t}\n\n\t\tleft -= HINIC_MBOX_SEG_LEN;\n\t\tmsg_seg += HINIC_MBOX_SEG_LEN;\n\n\t\tseq_id++;\n\t\theader &= ~(HINIC_MBOX_HEADER_SET(HINIC_MBOX_HEADER_SEQID_MASK,\n\t\t\t\t\t\t  SEQID));\n\t\theader |= HINIC_MBOX_HEADER_SET(seq_id, SEQID);\n\t}\n\nerr_send_mbox_seg:\n\tup(&func_to_func->msg_send_sem);\n\n\treturn err;\n}\n\nstatic void\nresponse_for_recv_func_mbox(struct hinic_mbox_func_to_func *func_to_func,\n\t\t\t    struct hinic_recv_mbox *recv_mbox, int err,\n\t\t\t    u16 out_size, u16 src_func_idx)\n{\n\tstruct mbox_msg_info msg_info = {0};\n\n\tif (recv_mbox->ack_type == MBOX_ACK) {\n\t\tmsg_info.msg_id = recv_mbox->msg_info.msg_id;\n\t\tif (err == HINIC_MBOX_PF_BUSY_ACTIVE_FW)\n\t\t\tmsg_info.status = HINIC_MBOX_PF_BUSY_ACTIVE_FW;\n\t\telse if (err == HINIC_MBOX_VF_CMD_ERROR)\n\t\t\tmsg_info.status = HINIC_MBOX_VF_CMD_ERROR;\n\t\telse if (err)\n\t\t\tmsg_info.status = HINIC_MBOX_PF_SEND_ERR;\n\n\t\t \n\t\tif (!out_size || err)\n\t\t\tout_size = MBOX_MSG_NO_DATA_LEN;\n\n\t\tsend_mbox_to_func(func_to_func, recv_mbox->mod, recv_mbox->cmd,\n\t\t\t\t  recv_mbox->buf_out, out_size, src_func_idx,\n\t\t\t\t  HINIC_HWIF_RESPONSE, MBOX_ACK,\n\t\t\t\t  &msg_info);\n\t}\n}\n\nstatic void recv_func_mbox_handler(struct hinic_mbox_func_to_func *func_to_func,\n\t\t\t\t   struct hinic_recv_mbox *recv_mbox,\n\t\t\t\t   u16 src_func_idx)\n{\n\tvoid *buf_out = recv_mbox->buf_out;\n\tu16 out_size = MBOX_MAX_BUF_SZ;\n\tint err = 0;\n\n\tif (HINIC_IS_VF(func_to_func->hwif)) {\n\t\terr = recv_vf_mbox_handler(func_to_func, recv_mbox, buf_out,\n\t\t\t\t\t   &out_size);\n\t} else {\n\t\tif (IS_PF_OR_PPF_SRC(src_func_idx))\n\t\t\tdev_warn(&func_to_func->hwif->pdev->dev,\n\t\t\t\t \"Unsupported pf2pf mbox msg\\n\");\n\t\telse\n\t\t\terr = recv_pf_from_vf_mbox_handler(func_to_func,\n\t\t\t\t\t\t\t   recv_mbox,\n\t\t\t\t\t\t\t   src_func_idx,\n\t\t\t\t\t\t\t   buf_out, &out_size);\n\t}\n\n\tresponse_for_recv_func_mbox(func_to_func, recv_mbox, err, out_size,\n\t\t\t\t    src_func_idx);\n\tkfree(recv_mbox->buf_out);\n\tkfree(recv_mbox->mbox);\n\tkfree(recv_mbox);\n}\n\nstatic void set_mbox_to_func_event(struct hinic_mbox_func_to_func *func_to_func,\n\t\t\t\t   enum mbox_event_state event_flag)\n{\n\tspin_lock(&func_to_func->mbox_lock);\n\tfunc_to_func->event_flag = event_flag;\n\tspin_unlock(&func_to_func->mbox_lock);\n}\n\nstatic int mbox_resp_info_handler(struct hinic_mbox_func_to_func *func_to_func,\n\t\t\t\t  struct hinic_recv_mbox *mbox_for_resp,\n\t\t\t\t  enum hinic_mod_type mod, u16 cmd,\n\t\t\t\t  void *buf_out, u16 *out_size)\n{\n\tint err;\n\n\tif (mbox_for_resp->msg_info.status) {\n\t\terr = mbox_for_resp->msg_info.status;\n\t\tif (err != HINIC_MBOX_PF_BUSY_ACTIVE_FW)\n\t\t\tdev_err(&func_to_func->hwif->pdev->dev, \"Mbox response error(0x%x)\\n\",\n\t\t\t\tmbox_for_resp->msg_info.status);\n\t\treturn err;\n\t}\n\n\tif (buf_out && out_size) {\n\t\tif (*out_size < mbox_for_resp->mbox_len) {\n\t\t\tdev_err(&func_to_func->hwif->pdev->dev,\n\t\t\t\t\"Invalid response mbox message length: %d for mod %d cmd %d, should less than: %d\\n\",\n\t\t\t\tmbox_for_resp->mbox_len, mod, cmd, *out_size);\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tif (mbox_for_resp->mbox_len)\n\t\t\tmemcpy(buf_out, mbox_for_resp->mbox,\n\t\t\t       mbox_for_resp->mbox_len);\n\n\t\t*out_size = mbox_for_resp->mbox_len;\n\t}\n\n\treturn 0;\n}\n\nint hinic_mbox_to_func(struct hinic_mbox_func_to_func *func_to_func,\n\t\t       enum hinic_mod_type mod, u16 cmd, u16 dst_func,\n\t\t       void *buf_in, u16 in_size, void *buf_out,\n\t\t       u16 *out_size, u32 timeout)\n{\n\tstruct hinic_recv_mbox *mbox_for_resp;\n\tstruct mbox_msg_info msg_info = {0};\n\tunsigned long timeo;\n\tint err;\n\n\tmbox_for_resp = &func_to_func->mbox_resp[dst_func];\n\n\tdown(&func_to_func->mbox_send_sem);\n\n\tinit_completion(&mbox_for_resp->recv_done);\n\n\tmsg_info.msg_id = MBOX_MSG_ID_INC(func_to_func);\n\n\tset_mbox_to_func_event(func_to_func, EVENT_START);\n\n\terr = send_mbox_to_func(func_to_func, mod, cmd, buf_in, in_size,\n\t\t\t\tdst_func, HINIC_HWIF_DIRECT_SEND, MBOX_ACK,\n\t\t\t\t&msg_info);\n\tif (err) {\n\t\tdev_err(&func_to_func->hwif->pdev->dev, \"Send mailbox failed, msg_id: %d\\n\",\n\t\t\tmsg_info.msg_id);\n\t\tset_mbox_to_func_event(func_to_func, EVENT_FAIL);\n\t\tgoto err_send_mbox;\n\t}\n\n\ttimeo = msecs_to_jiffies(timeout ? timeout : HINIC_MBOX_COMP_TIME);\n\tif (!wait_for_completion_timeout(&mbox_for_resp->recv_done, timeo)) {\n\t\tset_mbox_to_func_event(func_to_func, EVENT_TIMEOUT);\n\t\tdev_err(&func_to_func->hwif->pdev->dev,\n\t\t\t\"Send mbox msg timeout, msg_id: %d\\n\", msg_info.msg_id);\n\t\thinic_dump_aeq_info(func_to_func->hwdev);\n\t\terr = -ETIMEDOUT;\n\t\tgoto err_send_mbox;\n\t}\n\n\tset_mbox_to_func_event(func_to_func, EVENT_END);\n\n\terr = mbox_resp_info_handler(func_to_func, mbox_for_resp, mod, cmd,\n\t\t\t\t     buf_out, out_size);\n\nerr_send_mbox:\n\tup(&func_to_func->mbox_send_sem);\n\n\treturn err;\n}\n\nstatic int mbox_func_params_valid(struct hinic_mbox_func_to_func *func_to_func,\n\t\t\t\t  void *buf_in, u16 in_size)\n{\n\tif (in_size > HINIC_MBOX_DATA_SIZE) {\n\t\tdev_err(&func_to_func->hwif->pdev->dev,\n\t\t\t\"Mbox msg len(%d) exceed limit(%d)\\n\",\n\t\t\tin_size, HINIC_MBOX_DATA_SIZE);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nint hinic_mbox_to_pf(struct hinic_hwdev *hwdev,\n\t\t     enum hinic_mod_type mod, u8 cmd, void *buf_in,\n\t\t     u16 in_size, void *buf_out, u16 *out_size, u32 timeout)\n{\n\tstruct hinic_mbox_func_to_func *func_to_func = hwdev->func_to_func;\n\tint err = mbox_func_params_valid(func_to_func, buf_in, in_size);\n\n\tif (err)\n\t\treturn err;\n\n\tif (!HINIC_IS_VF(hwdev->hwif)) {\n\t\tdev_err(&hwdev->hwif->pdev->dev, \"Params error, func_type: %d\\n\",\n\t\t\tHINIC_FUNC_TYPE(hwdev->hwif));\n\t\treturn -EINVAL;\n\t}\n\n\treturn hinic_mbox_to_func(func_to_func, mod, cmd,\n\t\t\t\t  hinic_pf_id_of_vf_hw(hwdev->hwif), buf_in,\n\t\t\t\t  in_size, buf_out, out_size, timeout);\n}\n\nint hinic_mbox_to_vf(struct hinic_hwdev *hwdev,\n\t\t     enum hinic_mod_type mod, u16 vf_id, u8 cmd, void *buf_in,\n\t\t     u16 in_size, void *buf_out, u16 *out_size, u32 timeout)\n{\n\tstruct hinic_mbox_func_to_func *func_to_func;\n\tu16 dst_func_idx;\n\tint err;\n\n\tif (!hwdev)\n\t\treturn -EINVAL;\n\n\tfunc_to_func = hwdev->func_to_func;\n\terr = mbox_func_params_valid(func_to_func, buf_in, in_size);\n\tif (err)\n\t\treturn err;\n\n\tif (HINIC_IS_VF(hwdev->hwif)) {\n\t\tdev_err(&hwdev->hwif->pdev->dev, \"Params error, func_type: %d\\n\",\n\t\t\tHINIC_FUNC_TYPE(hwdev->hwif));\n\t\treturn -EINVAL;\n\t}\n\n\tif (!vf_id) {\n\t\tdev_err(&hwdev->hwif->pdev->dev,\n\t\t\t\"VF id(%d) error!\\n\", vf_id);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tdst_func_idx = hinic_glb_pf_vf_offset(hwdev->hwif) + vf_id;\n\n\treturn hinic_mbox_to_func(func_to_func, mod, cmd, dst_func_idx, buf_in,\n\t\t\t\t  in_size, buf_out, out_size, timeout);\n}\n\nstatic int init_mbox_info(struct hinic_recv_mbox *mbox_info)\n{\n\tint err;\n\n\tmbox_info->seq_id = SEQ_ID_MAX_VAL;\n\n\tmbox_info->mbox = kzalloc(MBOX_MAX_BUF_SZ, GFP_KERNEL);\n\tif (!mbox_info->mbox)\n\t\treturn -ENOMEM;\n\n\tmbox_info->buf_out = kzalloc(MBOX_MAX_BUF_SZ, GFP_KERNEL);\n\tif (!mbox_info->buf_out) {\n\t\terr = -ENOMEM;\n\t\tgoto err_alloc_buf_out;\n\t}\n\n\tatomic_set(&mbox_info->msg_cnt, 0);\n\n\treturn 0;\n\nerr_alloc_buf_out:\n\tkfree(mbox_info->mbox);\n\n\treturn err;\n}\n\nstatic void clean_mbox_info(struct hinic_recv_mbox *mbox_info)\n{\n\tkfree(mbox_info->buf_out);\n\tkfree(mbox_info->mbox);\n}\n\nstatic int alloc_mbox_info(struct hinic_hwdev *hwdev,\n\t\t\t   struct hinic_recv_mbox *mbox_info)\n{\n\tu16 func_idx, i;\n\tint err;\n\n\tfor (func_idx = 0; func_idx < HINIC_MAX_FUNCTIONS; func_idx++) {\n\t\terr = init_mbox_info(&mbox_info[func_idx]);\n\t\tif (err) {\n\t\t\tdev_err(&hwdev->hwif->pdev->dev, \"Failed to init function %d mbox info\\n\",\n\t\t\t\tfunc_idx);\n\t\t\tgoto err_init_mbox_info;\n\t\t}\n\t}\n\n\treturn 0;\n\nerr_init_mbox_info:\n\tfor (i = 0; i < func_idx; i++)\n\t\tclean_mbox_info(&mbox_info[i]);\n\n\treturn err;\n}\n\nstatic void free_mbox_info(struct hinic_recv_mbox *mbox_info)\n{\n\tu16 func_idx;\n\n\tfor (func_idx = 0; func_idx < HINIC_MAX_FUNCTIONS; func_idx++)\n\t\tclean_mbox_info(&mbox_info[func_idx]);\n}\n\nstatic void prepare_send_mbox(struct hinic_mbox_func_to_func *func_to_func)\n{\n\tstruct hinic_send_mbox *send_mbox = &func_to_func->send_mbox;\n\n\tsend_mbox->data = MBOX_AREA(func_to_func->hwif);\n}\n\nstatic int alloc_mbox_wb_status(struct hinic_mbox_func_to_func *func_to_func)\n{\n\tstruct hinic_send_mbox *send_mbox = &func_to_func->send_mbox;\n\tstruct hinic_hwdev *hwdev = func_to_func->hwdev;\n\tu32 addr_h, addr_l;\n\n\tsend_mbox->wb_vaddr = dma_alloc_coherent(&hwdev->hwif->pdev->dev,\n\t\t\t\t\t\t MBOX_WB_STATUS_LEN,\n\t\t\t\t\t\t &send_mbox->wb_paddr,\n\t\t\t\t\t\t GFP_KERNEL);\n\tif (!send_mbox->wb_vaddr)\n\t\treturn -ENOMEM;\n\n\tsend_mbox->wb_status = send_mbox->wb_vaddr;\n\n\taddr_h = upper_32_bits(send_mbox->wb_paddr);\n\taddr_l = lower_32_bits(send_mbox->wb_paddr);\n\n\thinic_hwif_write_reg(hwdev->hwif, HINIC_FUNC_CSR_MAILBOX_RESULT_H_OFF,\n\t\t\t     addr_h);\n\thinic_hwif_write_reg(hwdev->hwif, HINIC_FUNC_CSR_MAILBOX_RESULT_L_OFF,\n\t\t\t     addr_l);\n\n\treturn 0;\n}\n\nstatic void free_mbox_wb_status(struct hinic_mbox_func_to_func *func_to_func)\n{\n\tstruct hinic_send_mbox *send_mbox = &func_to_func->send_mbox;\n\tstruct hinic_hwdev *hwdev = func_to_func->hwdev;\n\n\thinic_hwif_write_reg(hwdev->hwif, HINIC_FUNC_CSR_MAILBOX_RESULT_H_OFF,\n\t\t\t     0);\n\thinic_hwif_write_reg(hwdev->hwif, HINIC_FUNC_CSR_MAILBOX_RESULT_L_OFF,\n\t\t\t     0);\n\n\tdma_free_coherent(&hwdev->hwif->pdev->dev, MBOX_WB_STATUS_LEN,\n\t\t\t  send_mbox->wb_vaddr,\n\t\t\t  send_mbox->wb_paddr);\n}\n\nbool hinic_mbox_check_cmd_valid(struct hinic_hwdev *hwdev,\n\t\t\t\tstruct vf_cmd_check_handle *cmd_handle,\n\t\t\t\tu16 vf_id, u8 cmd, void *buf_in,\n\t\t\t\tu16 in_size, u8 size)\n{\n\tu16 src_idx = vf_id + hinic_glb_pf_vf_offset(hwdev->hwif);\n\tint i;\n\n\tfor (i = 0; i < size; i++) {\n\t\tif (cmd == cmd_handle[i].cmd) {\n\t\t\tif (cmd_handle[i].check_cmd)\n\t\t\t\treturn cmd_handle[i].check_cmd(hwdev, src_idx,\n\t\t\t\t\t\t\t       buf_in, in_size);\n\t\t\telse\n\t\t\t\treturn true;\n\t\t}\n\t}\n\n\tdev_err(&hwdev->hwif->pdev->dev,\n\t\t\"PF Receive VF(%d) unsupported cmd(0x%x)\\n\",\n\t\tvf_id + hinic_glb_pf_vf_offset(hwdev->hwif), cmd);\n\n\treturn false;\n}\n\nstatic bool hinic_cmdq_check_vf_ctxt(struct hinic_hwdev *hwdev,\n\t\t\t\t     struct hinic_cmdq_ctxt *cmdq_ctxt)\n{\n\tstruct hinic_cmdq_ctxt_info *ctxt_info = &cmdq_ctxt->ctxt_info;\n\tu64 curr_pg_pfn, wq_block_pfn;\n\n\tif (cmdq_ctxt->ppf_idx != HINIC_HWIF_PPF_IDX(hwdev->hwif) ||\n\t    cmdq_ctxt->cmdq_type > HINIC_MAX_CMDQ_TYPES)\n\t\treturn false;\n\n\tcurr_pg_pfn = HINIC_CMDQ_CTXT_PAGE_INFO_GET\n\t\t(ctxt_info->curr_wqe_page_pfn, CURR_WQE_PAGE_PFN);\n\twq_block_pfn = HINIC_CMDQ_CTXT_BLOCK_INFO_GET\n\t\t(ctxt_info->wq_block_pfn, WQ_BLOCK_PFN);\n\t \n\tif (curr_pg_pfn != wq_block_pfn)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool check_cmdq_ctxt(struct hinic_hwdev *hwdev, u16 func_idx,\n\t\t\t    void *buf_in, u16 in_size)\n{\n\tif (!hinic_mbox_check_func_id_8B(hwdev, func_idx, buf_in, in_size))\n\t\treturn false;\n\n\treturn hinic_cmdq_check_vf_ctxt(hwdev, buf_in);\n}\n\n#define HW_CTX_QPS_VALID(hw_ctxt)   \\\n\t\t((hw_ctxt)->rq_depth >= HINIC_QUEUE_MIN_DEPTH &&\t\\\n\t\t(hw_ctxt)->rq_depth <= HINIC_QUEUE_MAX_DEPTH &&\t\\\n\t\t(hw_ctxt)->sq_depth >= HINIC_QUEUE_MIN_DEPTH &&\t\\\n\t\t(hw_ctxt)->sq_depth <= HINIC_QUEUE_MAX_DEPTH &&\t\\\n\t\t(hw_ctxt)->rx_buf_sz_idx <= HINIC_MAX_RX_BUFFER_SIZE)\n\nstatic bool hw_ctxt_qps_param_valid(struct hinic_cmd_hw_ioctxt *hw_ctxt)\n{\n\tif (HW_CTX_QPS_VALID(hw_ctxt))\n\t\treturn true;\n\n\tif (!hw_ctxt->rq_depth && !hw_ctxt->sq_depth &&\n\t    !hw_ctxt->rx_buf_sz_idx)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic bool check_hwctxt(struct hinic_hwdev *hwdev, u16 func_idx,\n\t\t\t void *buf_in, u16 in_size)\n{\n\tstruct hinic_cmd_hw_ioctxt *hw_ctxt = buf_in;\n\n\tif (!hinic_mbox_check_func_id_8B(hwdev, func_idx, buf_in, in_size))\n\t\treturn false;\n\n\tif (hw_ctxt->ppf_idx != HINIC_HWIF_PPF_IDX(hwdev->hwif))\n\t\treturn false;\n\n\tif (hw_ctxt->set_cmdq_depth) {\n\t\tif (hw_ctxt->cmdq_depth >= HINIC_QUEUE_MIN_DEPTH &&\n\t\t    hw_ctxt->cmdq_depth <= HINIC_QUEUE_MAX_DEPTH)\n\t\t\treturn true;\n\n\t\treturn false;\n\t}\n\n\treturn hw_ctxt_qps_param_valid(hw_ctxt);\n}\n\nstatic bool check_set_wq_page_size(struct hinic_hwdev *hwdev, u16 func_idx,\n\t\t\t\t   void *buf_in, u16 in_size)\n{\n\tstruct hinic_wq_page_size *page_size_info = buf_in;\n\n\tif (!hinic_mbox_check_func_id_8B(hwdev, func_idx, buf_in, in_size))\n\t\treturn false;\n\n\tif (page_size_info->ppf_idx != HINIC_HWIF_PPF_IDX(hwdev->hwif))\n\t\treturn false;\n\n\tif (((1U << page_size_info->page_size) * SZ_4K) !=\n\t    HINIC_DEFAULT_WQ_PAGE_SIZE)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic struct vf_cmd_check_handle hw_cmd_support_vf[] = {\n\t{HINIC_COMM_CMD_START_FLR, hinic_mbox_check_func_id_8B},\n\t{HINIC_COMM_CMD_DMA_ATTR_SET, hinic_mbox_check_func_id_8B},\n\t{HINIC_COMM_CMD_CMDQ_CTXT_SET, check_cmdq_ctxt},\n\t{HINIC_COMM_CMD_CMDQ_CTXT_GET, check_cmdq_ctxt},\n\t{HINIC_COMM_CMD_HWCTXT_SET, check_hwctxt},\n\t{HINIC_COMM_CMD_HWCTXT_GET, check_hwctxt},\n\t{HINIC_COMM_CMD_SQ_HI_CI_SET, hinic_mbox_check_func_id_8B},\n\t{HINIC_COMM_CMD_RES_STATE_SET, hinic_mbox_check_func_id_8B},\n\t{HINIC_COMM_CMD_IO_RES_CLEAR, hinic_mbox_check_func_id_8B},\n\t{HINIC_COMM_CMD_CEQ_CTRL_REG_WR_BY_UP, hinic_mbox_check_func_id_8B},\n\t{HINIC_COMM_CMD_MSI_CTRL_REG_WR_BY_UP, hinic_mbox_check_func_id_8B},\n\t{HINIC_COMM_CMD_MSI_CTRL_REG_RD_BY_UP, hinic_mbox_check_func_id_8B},\n\t{HINIC_COMM_CMD_L2NIC_RESET, hinic_mbox_check_func_id_8B},\n\t{HINIC_COMM_CMD_PAGESIZE_SET, check_set_wq_page_size},\n};\n\nstatic int comm_pf_mbox_handler(void *handle, u16 vf_id, u8 cmd, void *buf_in,\n\t\t\t\tu16 in_size, void *buf_out, u16 *out_size)\n{\n\tu8 size = ARRAY_SIZE(hw_cmd_support_vf);\n\tstruct hinic_hwdev *hwdev = handle;\n\tstruct hinic_pfhwdev *pfhwdev;\n\tint err = 0;\n\n\tpfhwdev = container_of(hwdev, struct hinic_pfhwdev, hwdev);\n\n\tif (!hinic_mbox_check_cmd_valid(handle, hw_cmd_support_vf, vf_id, cmd,\n\t\t\t\t\tbuf_in, in_size, size)) {\n\t\tdev_err(&hwdev->hwif->pdev->dev,\n\t\t\t\"PF Receive VF: %d common cmd: 0x%x or mbox len: 0x%x is invalid\\n\",\n\t\t\tvf_id + hinic_glb_pf_vf_offset(hwdev->hwif), cmd,\n\t\t\tin_size);\n\t\treturn HINIC_MBOX_VF_CMD_ERROR;\n\t}\n\n\tif (cmd == HINIC_COMM_CMD_START_FLR) {\n\t\t*out_size = 0;\n\t} else {\n\t\terr = hinic_msg_to_mgmt(&pfhwdev->pf_to_mgmt, HINIC_MOD_COMM,\n\t\t\t\t\tcmd, buf_in, in_size, buf_out, out_size,\n\t\t\t\t\tHINIC_MGMT_MSG_SYNC);\n\t\tif (err && err != HINIC_MBOX_PF_BUSY_ACTIVE_FW)\n\t\t\tdev_err(&hwdev->hwif->pdev->dev,\n\t\t\t\t\"PF mbox common callback handler err: %d\\n\",\n\t\t\t\terr);\n\t}\n\n\treturn err;\n}\n\nint hinic_func_to_func_init(struct hinic_hwdev *hwdev)\n{\n\tstruct hinic_mbox_func_to_func *func_to_func;\n\tstruct hinic_pfhwdev *pfhwdev;\n\tint err;\n\n\tpfhwdev =  container_of(hwdev, struct hinic_pfhwdev, hwdev);\n\tfunc_to_func = kzalloc(sizeof(*func_to_func), GFP_KERNEL);\n\tif (!func_to_func)\n\t\treturn -ENOMEM;\n\n\thwdev->func_to_func = func_to_func;\n\tfunc_to_func->hwdev = hwdev;\n\tfunc_to_func->hwif = hwdev->hwif;\n\tsema_init(&func_to_func->mbox_send_sem, 1);\n\tsema_init(&func_to_func->msg_send_sem, 1);\n\tspin_lock_init(&func_to_func->mbox_lock);\n\tfunc_to_func->workq = create_singlethread_workqueue(HINIC_MBOX_WQ_NAME);\n\tif (!func_to_func->workq) {\n\t\tdev_err(&hwdev->hwif->pdev->dev, \"Failed to initialize MBOX workqueue\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto err_create_mbox_workq;\n\t}\n\n\terr = alloc_mbox_info(hwdev, func_to_func->mbox_send);\n\tif (err) {\n\t\tdev_err(&hwdev->hwif->pdev->dev, \"Failed to alloc mem for mbox_active\\n\");\n\t\tgoto err_alloc_mbox_for_send;\n\t}\n\n\terr = alloc_mbox_info(hwdev, func_to_func->mbox_resp);\n\tif (err) {\n\t\tdev_err(&hwdev->hwif->pdev->dev, \"Failed to alloc mem for mbox_passive\\n\");\n\t\tgoto err_alloc_mbox_for_resp;\n\t}\n\n\terr = alloc_mbox_wb_status(func_to_func);\n\tif (err) {\n\t\tdev_err(&hwdev->hwif->pdev->dev, \"Failed to alloc mbox write back status\\n\");\n\t\tgoto err_alloc_wb_status;\n\t}\n\n\tprepare_send_mbox(func_to_func);\n\n\thinic_aeq_register_hw_cb(&hwdev->aeqs, HINIC_MBX_FROM_FUNC,\n\t\t\t\t &pfhwdev->hwdev, hinic_mbox_func_aeqe_handler);\n\thinic_aeq_register_hw_cb(&hwdev->aeqs, HINIC_MBX_SEND_RSLT,\n\t\t\t\t &pfhwdev->hwdev, hinic_mbox_self_aeqe_handler);\n\n\tif (!HINIC_IS_VF(hwdev->hwif))\n\t\thinic_register_pf_mbox_cb(hwdev, HINIC_MOD_COMM,\n\t\t\t\t\t  comm_pf_mbox_handler);\n\n\treturn 0;\n\nerr_alloc_wb_status:\n\tfree_mbox_info(func_to_func->mbox_resp);\n\nerr_alloc_mbox_for_resp:\n\tfree_mbox_info(func_to_func->mbox_send);\n\nerr_alloc_mbox_for_send:\n\tdestroy_workqueue(func_to_func->workq);\n\nerr_create_mbox_workq:\n\tkfree(func_to_func);\n\n\treturn err;\n}\n\nvoid hinic_func_to_func_free(struct hinic_hwdev *hwdev)\n{\n\tstruct hinic_mbox_func_to_func *func_to_func = hwdev->func_to_func;\n\n\thinic_aeq_unregister_hw_cb(&hwdev->aeqs, HINIC_MBX_FROM_FUNC);\n\thinic_aeq_unregister_hw_cb(&hwdev->aeqs, HINIC_MBX_SEND_RSLT);\n\n\thinic_unregister_pf_mbox_cb(hwdev, HINIC_MOD_COMM);\n\t \n\tdestroy_workqueue(func_to_func->workq);\n\n\tfree_mbox_wb_status(func_to_func);\n\tfree_mbox_info(func_to_func->mbox_resp);\n\tfree_mbox_info(func_to_func->mbox_send);\n\n\tkfree(func_to_func);\n}\n\nint hinic_vf_mbox_random_id_init(struct hinic_hwdev *hwdev)\n{\n\tu16 vf_offset;\n\tu8 vf_in_pf;\n\tint err = 0;\n\n\tif (HINIC_IS_VF(hwdev->hwif))\n\t\treturn 0;\n\n\tvf_offset = hinic_glb_pf_vf_offset(hwdev->hwif);\n\n\tfor (vf_in_pf = 1; vf_in_pf <= hwdev->nic_cap.max_vf; vf_in_pf++) {\n\t\terr = set_vf_mbox_random_id(hwdev, vf_offset + vf_in_pf);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\tif (err == HINIC_MGMT_CMD_UNSUPPORTED) {\n\t\thwdev->func_to_func->support_vf_random = false;\n\t\terr = 0;\n\t\tdev_warn(&hwdev->hwif->pdev->dev, \"Mgmt is unsupported to set VF%d random id\\n\",\n\t\t\t vf_in_pf - 1);\n\t} else if (!err) {\n\t\thwdev->func_to_func->support_vf_random = true;\n\t}\n\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}