{
  "module_name": "hinic_sriov.c",
  "hash_id": "3716aee2f451e21c43c7569d53e290bb06e13d225b5be548a6cf5c69c9e1c85f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/huawei/hinic/hinic_sriov.c",
  "human_readable_source": "\n \n\n#include <linux/pci.h>\n#include <linux/if_vlan.h>\n#include <linux/interrupt.h>\n#include <linux/etherdevice.h>\n#include <linux/netdevice.h>\n#include <linux/module.h>\n\n#include \"hinic_hw_dev.h\"\n#include \"hinic_dev.h\"\n#include \"hinic_hw_mbox.h\"\n#include \"hinic_hw_cmdq.h\"\n#include \"hinic_port.h\"\n#include \"hinic_sriov.h\"\n\nstatic unsigned char set_vf_link_state;\nmodule_param(set_vf_link_state, byte, 0444);\nMODULE_PARM_DESC(set_vf_link_state, \"Set vf link state, 0 represents link auto, 1 represents link always up, 2 represents link always down. - default is 0.\");\n\n#define HINIC_VLAN_PRIORITY_SHIFT 13\n#define HINIC_ADD_VLAN_IN_MAC 0x8000\n#define HINIC_TX_RATE_TABLE_FULL 12\n#define HINIC_MAX_QOS 7\n\nstatic int hinic_set_mac(struct hinic_hwdev *hwdev, const u8 *mac_addr,\n\t\t\t u16 vlan_id, u16 func_id)\n{\n\tstruct hinic_port_mac_cmd mac_info = {0};\n\tu16 out_size = sizeof(mac_info);\n\tint err;\n\n\tmac_info.func_idx = func_id;\n\tmac_info.vlan_id = vlan_id;\n\tmemcpy(mac_info.mac, mac_addr, ETH_ALEN);\n\n\terr = hinic_port_msg_cmd(hwdev, HINIC_PORT_CMD_SET_MAC, &mac_info,\n\t\t\t\t sizeof(mac_info), &mac_info, &out_size);\n\tif (err || out_size != sizeof(mac_info) ||\n\t    (mac_info.status && mac_info.status != HINIC_MGMT_STATUS_EXIST)) {\n\t\tdev_err(&hwdev->func_to_io.hwif->pdev->dev, \"Failed to set MAC, err: %d, status: 0x%x, out size: 0x%x\\n\",\n\t\t\terr, mac_info.status, out_size);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic void hinic_notify_vf_link_status(struct hinic_hwdev *hwdev, u16 vf_id,\n\t\t\t\t\tu8 link_status)\n{\n\tstruct vf_data_storage *vf_infos = hwdev->func_to_io.vf_infos;\n\tstruct hinic_port_link_status link = {0};\n\tu16 out_size = sizeof(link);\n\tint err;\n\n\tif (vf_infos[HW_VF_ID_TO_OS(vf_id)].registered) {\n\t\tlink.link = link_status;\n\t\tlink.func_id = hinic_glb_pf_vf_offset(hwdev->hwif) + vf_id;\n\t\terr = hinic_mbox_to_vf(hwdev, HINIC_MOD_L2NIC,\n\t\t\t\t       vf_id, HINIC_PORT_CMD_LINK_STATUS_REPORT,\n\t\t\t\t       &link, sizeof(link),\n\t\t\t\t       &link, &out_size, 0);\n\t\tif (err || !out_size || link.status)\n\t\t\tdev_err(&hwdev->hwif->pdev->dev,\n\t\t\t\t\"Send link change event to VF %d failed, err: %d, status: 0x%x, out_size: 0x%x\\n\",\n\t\t\t\tHW_VF_ID_TO_OS(vf_id), err,\n\t\t\t\tlink.status, out_size);\n\t}\n}\n\n \nvoid hinic_notify_all_vfs_link_changed(struct hinic_hwdev *hwdev,\n\t\t\t\t       u8 link_status)\n{\n\tstruct hinic_func_to_io *nic_io = &hwdev->func_to_io;\n\tu16 i;\n\n\tnic_io->link_status = link_status;\n\tfor (i = 1; i <= nic_io->max_vfs; i++) {\n\t\tif (!nic_io->vf_infos[HW_VF_ID_TO_OS(i)].link_forced)\n\t\t\thinic_notify_vf_link_status(hwdev, i,  link_status);\n\t}\n}\n\nstatic u16 hinic_vf_info_vlanprio(struct hinic_hwdev *hwdev, int vf_id)\n{\n\tstruct hinic_func_to_io *nic_io = &hwdev->func_to_io;\n\tu16 pf_vlan, vlanprio;\n\tu8 pf_qos;\n\n\tpf_vlan = nic_io->vf_infos[HW_VF_ID_TO_OS(vf_id)].pf_vlan;\n\tpf_qos = nic_io->vf_infos[HW_VF_ID_TO_OS(vf_id)].pf_qos;\n\tvlanprio = pf_vlan | pf_qos << HINIC_VLAN_PRIORITY_SHIFT;\n\n\treturn vlanprio;\n}\n\nstatic int hinic_set_vf_vlan(struct hinic_hwdev *hwdev, bool add, u16 vid,\n\t\t\t     u8 qos, int vf_id)\n{\n\tstruct hinic_vf_vlan_config vf_vlan = {0};\n\tu16 out_size = sizeof(vf_vlan);\n\tint err;\n\tu8 cmd;\n\n\t \n\tif (!vid && !add)\n\t\treturn 0;\n\n\tvf_vlan.func_id = hinic_glb_pf_vf_offset(hwdev->hwif) + vf_id;\n\tvf_vlan.vlan_id = vid;\n\tvf_vlan.qos = qos;\n\n\tif (add)\n\t\tcmd = HINIC_PORT_CMD_SET_VF_VLAN;\n\telse\n\t\tcmd = HINIC_PORT_CMD_CLR_VF_VLAN;\n\n\terr = hinic_port_msg_cmd(hwdev, cmd, &vf_vlan,\n\t\t\t\t sizeof(vf_vlan), &vf_vlan, &out_size);\n\tif (err || !out_size || vf_vlan.status) {\n\t\tdev_err(&hwdev->hwif->pdev->dev, \"Failed to set VF %d vlan, err: %d, status: 0x%x, out size: 0x%x\\n\",\n\t\t\tHW_VF_ID_TO_OS(vf_id), err, vf_vlan.status, out_size);\n\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n}\n\nstatic int hinic_set_vf_tx_rate_max_min(struct hinic_hwdev *hwdev, u16 vf_id,\n\t\t\t\t\tu32 max_rate, u32 min_rate)\n{\n\tstruct hinic_func_to_io *nic_io = &hwdev->func_to_io;\n\tstruct hinic_tx_rate_cfg_max_min rate_cfg = {0};\n\tu16 out_size = sizeof(rate_cfg);\n\tint err;\n\n\trate_cfg.func_id = hinic_glb_pf_vf_offset(hwdev->hwif) + vf_id;\n\trate_cfg.max_rate = max_rate;\n\trate_cfg.min_rate = min_rate;\n\terr = hinic_port_msg_cmd(hwdev, HINIC_PORT_CMD_SET_VF_MAX_MIN_RATE,\n\t\t\t\t &rate_cfg, sizeof(rate_cfg), &rate_cfg,\n\t\t\t\t &out_size);\n\tif ((rate_cfg.status != HINIC_MGMT_CMD_UNSUPPORTED &&\n\t     rate_cfg.status) || err || !out_size) {\n\t\tdev_err(&hwdev->hwif->pdev->dev, \"Failed to set VF(%d) max rate(%d), min rate(%d), err: %d, status: 0x%x, out size: 0x%x\\n\",\n\t\t\tHW_VF_ID_TO_OS(vf_id), max_rate, min_rate, err,\n\t\t\trate_cfg.status, out_size);\n\t\treturn -EIO;\n\t}\n\n\tif (!rate_cfg.status) {\n\t\tnic_io->vf_infos[HW_VF_ID_TO_OS(vf_id)].max_rate = max_rate;\n\t\tnic_io->vf_infos[HW_VF_ID_TO_OS(vf_id)].min_rate = min_rate;\n\t}\n\n\treturn rate_cfg.status;\n}\n\nstatic int hinic_set_vf_rate_limit(struct hinic_hwdev *hwdev, u16 vf_id,\n\t\t\t\t   u32 tx_rate)\n{\n\tstruct hinic_func_to_io *nic_io = &hwdev->func_to_io;\n\tstruct hinic_tx_rate_cfg rate_cfg = {0};\n\tu16 out_size = sizeof(rate_cfg);\n\tint err;\n\n\trate_cfg.func_id = hinic_glb_pf_vf_offset(hwdev->hwif) + vf_id;\n\trate_cfg.tx_rate = tx_rate;\n\terr = hinic_port_msg_cmd(hwdev, HINIC_PORT_CMD_SET_VF_RATE,\n\t\t\t\t &rate_cfg, sizeof(rate_cfg), &rate_cfg,\n\t\t\t\t &out_size);\n\tif (err || !out_size || rate_cfg.status) {\n\t\tdev_err(&hwdev->hwif->pdev->dev, \"Failed to set VF(%d) rate(%d), err: %d, status: 0x%x, out size: 0x%x\\n\",\n\t\t\tHW_VF_ID_TO_OS(vf_id), tx_rate, err, rate_cfg.status,\n\t\t\tout_size);\n\t\tif (rate_cfg.status)\n\t\t\treturn rate_cfg.status;\n\n\t\treturn -EIO;\n\t}\n\n\tnic_io->vf_infos[HW_VF_ID_TO_OS(vf_id)].max_rate = tx_rate;\n\tnic_io->vf_infos[HW_VF_ID_TO_OS(vf_id)].min_rate = 0;\n\n\treturn 0;\n}\n\nstatic int hinic_set_vf_tx_rate(struct hinic_hwdev *hwdev, u16 vf_id,\n\t\t\t\tu32 max_rate, u32 min_rate)\n{\n\tint err;\n\n\terr = hinic_set_vf_tx_rate_max_min(hwdev, vf_id, max_rate, min_rate);\n\tif (err != HINIC_MGMT_CMD_UNSUPPORTED)\n\t\treturn err;\n\n\tif (min_rate) {\n\t\tdev_err(&hwdev->hwif->pdev->dev, \"Current firmware doesn't support to set min tx rate\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tdev_info(&hwdev->hwif->pdev->dev, \"Current firmware doesn't support to set min tx rate, force min_tx_rate = max_tx_rate\\n\");\n\n\treturn hinic_set_vf_rate_limit(hwdev, vf_id, max_rate);\n}\n\nstatic int hinic_init_vf_config(struct hinic_hwdev *hwdev, u16 vf_id)\n{\n\tstruct vf_data_storage *vf_info;\n\tu16 func_id, vlan_id;\n\tint err = 0;\n\n\tvf_info = hwdev->func_to_io.vf_infos + HW_VF_ID_TO_OS(vf_id);\n\tif (vf_info->pf_set_mac) {\n\t\tfunc_id = hinic_glb_pf_vf_offset(hwdev->hwif) + vf_id;\n\n\t\tvlan_id = 0;\n\n\t\terr = hinic_set_mac(hwdev, vf_info->vf_mac_addr, vlan_id,\n\t\t\t\t    func_id);\n\t\tif (err) {\n\t\t\tdev_err(&hwdev->func_to_io.hwif->pdev->dev, \"Failed to set VF %d MAC\\n\",\n\t\t\t\tHW_VF_ID_TO_OS(vf_id));\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tif (hinic_vf_info_vlanprio(hwdev, vf_id)) {\n\t\terr = hinic_set_vf_vlan(hwdev, true, vf_info->pf_vlan,\n\t\t\t\t\tvf_info->pf_qos, vf_id);\n\t\tif (err) {\n\t\t\tdev_err(&hwdev->hwif->pdev->dev, \"Failed to add VF %d VLAN_QOS\\n\",\n\t\t\t\tHW_VF_ID_TO_OS(vf_id));\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tif (vf_info->max_rate) {\n\t\terr = hinic_set_vf_tx_rate(hwdev, vf_id, vf_info->max_rate,\n\t\t\t\t\t   vf_info->min_rate);\n\t\tif (err) {\n\t\t\tdev_err(&hwdev->hwif->pdev->dev, \"Failed to set VF %d max rate: %d, min rate: %d\\n\",\n\t\t\t\tHW_VF_ID_TO_OS(vf_id), vf_info->max_rate,\n\t\t\t\tvf_info->min_rate);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int hinic_register_vf_msg_handler(void *hwdev, u16 vf_id,\n\t\t\t\t\t void *buf_in, u16 in_size,\n\t\t\t\t\t void *buf_out, u16 *out_size)\n{\n\tstruct hinic_register_vf *register_info = buf_out;\n\tstruct hinic_hwdev *hw_dev = hwdev;\n\tstruct hinic_func_to_io *nic_io;\n\tint err;\n\n\tnic_io = &hw_dev->func_to_io;\n\tif (vf_id > nic_io->max_vfs) {\n\t\tdev_err(&hw_dev->hwif->pdev->dev, \"Register VF id %d exceed limit[0-%d]\\n\",\n\t\t\tHW_VF_ID_TO_OS(vf_id), HW_VF_ID_TO_OS(nic_io->max_vfs));\n\t\tregister_info->status = EFAULT;\n\t\treturn -EFAULT;\n\t}\n\n\t*out_size = sizeof(*register_info);\n\terr = hinic_init_vf_config(hw_dev, vf_id);\n\tif (err) {\n\t\tregister_info->status = EFAULT;\n\t\treturn err;\n\t}\n\n\tnic_io->vf_infos[HW_VF_ID_TO_OS(vf_id)].registered = true;\n\n\treturn 0;\n}\n\nstatic int hinic_unregister_vf_msg_handler(void *hwdev, u16 vf_id,\n\t\t\t\t\t   void *buf_in, u16 in_size,\n\t\t\t\t\t   void *buf_out, u16 *out_size)\n{\n\tstruct hinic_hwdev *hw_dev = hwdev;\n\tstruct hinic_func_to_io *nic_io;\n\n\tnic_io = &hw_dev->func_to_io;\n\t*out_size = 0;\n\tif (vf_id > nic_io->max_vfs)\n\t\treturn 0;\n\n\tnic_io->vf_infos[HW_VF_ID_TO_OS(vf_id)].registered = false;\n\n\treturn 0;\n}\n\nstatic int hinic_change_vf_mtu_msg_handler(void *hwdev, u16 vf_id,\n\t\t\t\t\t   void *buf_in, u16 in_size,\n\t\t\t\t\t   void *buf_out, u16 *out_size)\n{\n\tstruct hinic_hwdev *hw_dev = hwdev;\n\tint err;\n\n\terr = hinic_port_msg_cmd(hwdev, HINIC_PORT_CMD_CHANGE_MTU, buf_in,\n\t\t\t\t in_size, buf_out, out_size);\n\tif (err) {\n\t\tdev_err(&hw_dev->hwif->pdev->dev, \"Failed to set VF %u mtu\\n\",\n\t\t\tvf_id);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int hinic_get_vf_mac_msg_handler(void *hwdev, u16 vf_id,\n\t\t\t\t\tvoid *buf_in, u16 in_size,\n\t\t\t\t\tvoid *buf_out, u16 *out_size)\n{\n\tstruct hinic_port_mac_cmd *mac_info = buf_out;\n\tstruct hinic_hwdev *dev = hwdev;\n\tstruct hinic_func_to_io *nic_io;\n\tstruct vf_data_storage *vf_info;\n\n\tnic_io = &dev->func_to_io;\n\tvf_info = nic_io->vf_infos + HW_VF_ID_TO_OS(vf_id);\n\n\tmemcpy(mac_info->mac, vf_info->vf_mac_addr, ETH_ALEN);\n\tmac_info->status = 0;\n\t*out_size = sizeof(*mac_info);\n\n\treturn 0;\n}\n\nstatic int hinic_set_vf_mac_msg_handler(void *hwdev, u16 vf_id,\n\t\t\t\t\tvoid *buf_in, u16 in_size,\n\t\t\t\t\tvoid *buf_out, u16 *out_size)\n{\n\tstruct hinic_port_mac_cmd *mac_out = buf_out;\n\tstruct hinic_port_mac_cmd *mac_in = buf_in;\n\tstruct hinic_hwdev *hw_dev = hwdev;\n\tstruct hinic_func_to_io *nic_io;\n\tstruct vf_data_storage *vf_info;\n\tint err;\n\n\tnic_io =  &hw_dev->func_to_io;\n\tvf_info = nic_io->vf_infos + HW_VF_ID_TO_OS(vf_id);\n\tif (vf_info->pf_set_mac && !(vf_info->trust) &&\n\t    is_valid_ether_addr(mac_in->mac)) {\n\t\tdev_warn(&hw_dev->hwif->pdev->dev, \"PF has already set VF %d MAC address\\n\",\n\t\t\t HW_VF_ID_TO_OS(vf_id));\n\t\tmac_out->status = HINIC_PF_SET_VF_ALREADY;\n\t\t*out_size = sizeof(*mac_out);\n\t\treturn 0;\n\t}\n\n\terr = hinic_port_msg_cmd(hw_dev, HINIC_PORT_CMD_SET_MAC, buf_in,\n\t\t\t\t in_size, buf_out, out_size);\n\tif ((err &&  err != HINIC_MBOX_PF_BUSY_ACTIVE_FW) || !(*out_size)) {\n\t\tdev_err(&hw_dev->hwif->pdev->dev,\n\t\t\t\"Failed to set VF %d MAC address, err: %d, status: 0x%x, out size: 0x%x\\n\",\n\t\t\tHW_VF_ID_TO_OS(vf_id), err, mac_out->status, *out_size);\n\t\treturn -EFAULT;\n\t}\n\n\treturn err;\n}\n\nstatic int hinic_del_vf_mac_msg_handler(void *hwdev, u16 vf_id,\n\t\t\t\t\tvoid *buf_in, u16 in_size,\n\t\t\t\t\tvoid *buf_out, u16 *out_size)\n{\n\tstruct hinic_port_mac_cmd *mac_out = buf_out;\n\tstruct hinic_port_mac_cmd *mac_in = buf_in;\n\tstruct hinic_hwdev *hw_dev = hwdev;\n\tstruct hinic_func_to_io *nic_io;\n\tstruct vf_data_storage *vf_info;\n\tint err;\n\n\tnic_io = &hw_dev->func_to_io;\n\tvf_info = nic_io->vf_infos + HW_VF_ID_TO_OS(vf_id);\n\tif (vf_info->pf_set_mac && is_valid_ether_addr(mac_in->mac) &&\n\t    !memcmp(vf_info->vf_mac_addr, mac_in->mac, ETH_ALEN)) {\n\t\tdev_warn(&hw_dev->hwif->pdev->dev, \"PF has already set VF mac.\\n\");\n\t\tmac_out->status = HINIC_PF_SET_VF_ALREADY;\n\t\t*out_size = sizeof(*mac_out);\n\t\treturn 0;\n\t}\n\n\terr = hinic_port_msg_cmd(hw_dev, HINIC_PORT_CMD_DEL_MAC, buf_in,\n\t\t\t\t in_size, buf_out, out_size);\n\tif ((err && err != HINIC_MBOX_PF_BUSY_ACTIVE_FW) || !(*out_size)) {\n\t\tdev_err(&hw_dev->hwif->pdev->dev, \"Failed to delete VF %d MAC, err: %d, status: 0x%x, out size: 0x%x\\n\",\n\t\t\tHW_VF_ID_TO_OS(vf_id), err, mac_out->status, *out_size);\n\t\treturn -EFAULT;\n\t}\n\n\treturn err;\n}\n\nstatic int hinic_get_vf_link_status_msg_handler(void *hwdev, u16 vf_id,\n\t\t\t\t\t\tvoid *buf_in, u16 in_size,\n\t\t\t\t\t\tvoid *buf_out, u16 *out_size)\n{\n\tstruct hinic_port_link_cmd *get_link = buf_out;\n\tstruct hinic_hwdev *hw_dev = hwdev;\n\tstruct vf_data_storage *vf_infos;\n\tstruct hinic_func_to_io *nic_io;\n\tbool link_forced, link_up;\n\n\tnic_io = &hw_dev->func_to_io;\n\tvf_infos = nic_io->vf_infos;\n\tlink_forced = vf_infos[HW_VF_ID_TO_OS(vf_id)].link_forced;\n\tlink_up = vf_infos[HW_VF_ID_TO_OS(vf_id)].link_up;\n\n\tif (link_forced)\n\t\tget_link->state = link_up ?\n\t\t\tHINIC_LINK_STATE_UP : HINIC_LINK_STATE_DOWN;\n\telse\n\t\tget_link->state = nic_io->link_status;\n\n\tget_link->status = 0;\n\t*out_size = sizeof(*get_link);\n\n\treturn 0;\n}\n\nstatic bool check_func_table(struct hinic_hwdev *hwdev, u16 func_idx,\n\t\t\t     void *buf_in, u16 in_size)\n{\n\tstruct hinic_cmd_fw_ctxt *function_table = buf_in;\n\n\tif (!hinic_mbox_check_func_id_8B(hwdev, func_idx, buf_in, in_size) ||\n\t    !function_table->rx_buf_sz)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic struct vf_cmd_msg_handle nic_vf_cmd_msg_handler[] = {\n\t{HINIC_PORT_CMD_VF_REGISTER, hinic_register_vf_msg_handler},\n\t{HINIC_PORT_CMD_VF_UNREGISTER, hinic_unregister_vf_msg_handler},\n\t{HINIC_PORT_CMD_CHANGE_MTU, hinic_change_vf_mtu_msg_handler},\n\t{HINIC_PORT_CMD_GET_MAC, hinic_get_vf_mac_msg_handler},\n\t{HINIC_PORT_CMD_SET_MAC, hinic_set_vf_mac_msg_handler},\n\t{HINIC_PORT_CMD_DEL_MAC, hinic_del_vf_mac_msg_handler},\n\t{HINIC_PORT_CMD_GET_LINK_STATE, hinic_get_vf_link_status_msg_handler},\n};\n\nstatic struct vf_cmd_check_handle nic_cmd_support_vf[] = {\n\t{HINIC_PORT_CMD_VF_REGISTER, NULL},\n\t{HINIC_PORT_CMD_VF_UNREGISTER, NULL},\n\t{HINIC_PORT_CMD_CHANGE_MTU, hinic_mbox_check_func_id_8B},\n\t{HINIC_PORT_CMD_ADD_VLAN, hinic_mbox_check_func_id_8B},\n\t{HINIC_PORT_CMD_DEL_VLAN, hinic_mbox_check_func_id_8B},\n\t{HINIC_PORT_CMD_SET_MAC, hinic_mbox_check_func_id_8B},\n\t{HINIC_PORT_CMD_GET_MAC, hinic_mbox_check_func_id_8B},\n\t{HINIC_PORT_CMD_DEL_MAC, hinic_mbox_check_func_id_8B},\n\t{HINIC_PORT_CMD_SET_RX_MODE, hinic_mbox_check_func_id_8B},\n\t{HINIC_PORT_CMD_GET_PAUSE_INFO, hinic_mbox_check_func_id_8B},\n\t{HINIC_PORT_CMD_GET_LINK_STATE, hinic_mbox_check_func_id_8B},\n\t{HINIC_PORT_CMD_SET_LRO, hinic_mbox_check_func_id_8B},\n\t{HINIC_PORT_CMD_SET_RX_CSUM, hinic_mbox_check_func_id_8B},\n\t{HINIC_PORT_CMD_SET_RX_VLAN_OFFLOAD, hinic_mbox_check_func_id_8B},\n\t{HINIC_PORT_CMD_GET_VPORT_STAT, hinic_mbox_check_func_id_8B},\n\t{HINIC_PORT_CMD_CLEAN_VPORT_STAT, hinic_mbox_check_func_id_8B},\n\t{HINIC_PORT_CMD_GET_RSS_TEMPLATE_INDIR_TBL,\n\t hinic_mbox_check_func_id_8B},\n\t{HINIC_PORT_CMD_SET_RSS_TEMPLATE_TBL, hinic_mbox_check_func_id_8B},\n\t{HINIC_PORT_CMD_GET_RSS_TEMPLATE_TBL, hinic_mbox_check_func_id_8B},\n\t{HINIC_PORT_CMD_SET_RSS_HASH_ENGINE, hinic_mbox_check_func_id_8B},\n\t{HINIC_PORT_CMD_GET_RSS_HASH_ENGINE, hinic_mbox_check_func_id_8B},\n\t{HINIC_PORT_CMD_GET_RSS_CTX_TBL, hinic_mbox_check_func_id_8B},\n\t{HINIC_PORT_CMD_SET_RSS_CTX_TBL, hinic_mbox_check_func_id_8B},\n\t{HINIC_PORT_CMD_RSS_TEMP_MGR, hinic_mbox_check_func_id_8B},\n\t{HINIC_PORT_CMD_RSS_CFG, hinic_mbox_check_func_id_8B},\n\t{HINIC_PORT_CMD_FWCTXT_INIT, check_func_table},\n\t{HINIC_PORT_CMD_GET_MGMT_VERSION, NULL},\n\t{HINIC_PORT_CMD_SET_FUNC_STATE, hinic_mbox_check_func_id_8B},\n\t{HINIC_PORT_CMD_GET_GLOBAL_QPN, hinic_mbox_check_func_id_8B},\n\t{HINIC_PORT_CMD_SET_TSO, hinic_mbox_check_func_id_8B},\n\t{HINIC_PORT_CMD_SET_RQ_IQ_MAP, hinic_mbox_check_func_id_8B},\n\t{HINIC_PORT_CMD_LINK_STATUS_REPORT, hinic_mbox_check_func_id_8B},\n\t{HINIC_PORT_CMD_UPDATE_MAC, hinic_mbox_check_func_id_8B},\n\t{HINIC_PORT_CMD_GET_CAP, hinic_mbox_check_func_id_8B},\n\t{HINIC_PORT_CMD_GET_LINK_MODE, hinic_mbox_check_func_id_8B},\n\t{HINIC_PORT_CMD_GET_VF_COS, NULL},\n\t{HINIC_PORT_CMD_SET_VHD_CFG, hinic_mbox_check_func_id_8B},\n\t{HINIC_PORT_CMD_SET_VLAN_FILTER, hinic_mbox_check_func_id_8B},\n\t{HINIC_PORT_CMD_Q_FILTER, hinic_mbox_check_func_id_8B},\n\t{HINIC_PORT_CMD_TCAM_FILTER, NULL},\n\t{HINIC_PORT_CMD_UP_TC_ADD_FLOW, NULL},\n\t{HINIC_PORT_CMD_UP_TC_DEL_FLOW, NULL},\n\t{HINIC_PORT_CMD_UP_TC_FLUSH_TCAM, hinic_mbox_check_func_id_8B},\n\t{HINIC_PORT_CMD_UP_TC_CTRL_TCAM_BLOCK, hinic_mbox_check_func_id_8B},\n\t{HINIC_PORT_CMD_UP_TC_ENABLE, hinic_mbox_check_func_id_8B},\n\t{HINIC_PORT_CMD_CABLE_PLUG_EVENT, NULL},\n\t{HINIC_PORT_CMD_LINK_ERR_EVENT, NULL},\n\t{HINIC_PORT_CMD_SET_PORT_STATE, hinic_mbox_check_func_id_8B},\n\t{HINIC_PORT_CMD_SET_ETS, NULL},\n\t{HINIC_PORT_CMD_SET_ANTI_ATTACK_RATE, NULL},\n\t{HINIC_PORT_CMD_RESET_LINK_CFG, hinic_mbox_check_func_id_8B},\n\t{HINIC_PORT_CMD_SET_LINK_FOLLOW, NULL},\n\t{HINIC_PORT_CMD_CLEAR_QP_RES, NULL},\n};\n\n#define CHECK_IPSU_15BIT\t0X8000\n\nstatic\nstruct hinic_sriov_info *hinic_get_sriov_info_by_pcidev(struct pci_dev *pdev)\n{\n\tstruct net_device *netdev = pci_get_drvdata(pdev);\n\tstruct hinic_dev *nic_dev = netdev_priv(netdev);\n\n\treturn &nic_dev->sriov_info;\n}\n\nstatic int hinic_check_mac_info(u8 status, u16 vlan_id)\n{\n\tif ((status && status != HINIC_MGMT_STATUS_EXIST) ||\n\t    (vlan_id & CHECK_IPSU_15BIT &&\n\t     status == HINIC_MGMT_STATUS_EXIST))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n#define HINIC_VLAN_ID_MASK\t0x7FFF\n\nstatic int hinic_update_mac(struct hinic_hwdev *hwdev, u8 *old_mac,\n\t\t\t    u8 *new_mac, u16 vlan_id, u16 func_id)\n{\n\tstruct hinic_port_mac_update mac_info = {0};\n\tu16 out_size = sizeof(mac_info);\n\tint err;\n\n\tif (!hwdev || !old_mac || !new_mac)\n\t\treturn -EINVAL;\n\n\tif ((vlan_id & HINIC_VLAN_ID_MASK) >= VLAN_N_VID) {\n\t\tdev_err(&hwdev->hwif->pdev->dev, \"Invalid VLAN number: %d\\n\",\n\t\t\t(vlan_id & HINIC_VLAN_ID_MASK));\n\t\treturn -EINVAL;\n\t}\n\n\tmac_info.func_id = func_id;\n\tmac_info.vlan_id = vlan_id;\n\tmemcpy(mac_info.old_mac, old_mac, ETH_ALEN);\n\tmemcpy(mac_info.new_mac, new_mac, ETH_ALEN);\n\n\terr = hinic_port_msg_cmd(hwdev, HINIC_PORT_CMD_UPDATE_MAC, &mac_info,\n\t\t\t\t sizeof(mac_info), &mac_info, &out_size);\n\n\tif (err || !out_size ||\n\t    hinic_check_mac_info(mac_info.status, mac_info.vlan_id)) {\n\t\tdev_err(&hwdev->hwif->pdev->dev,\n\t\t\t\"Failed to update MAC, err: %d, status: 0x%x, out size: 0x%x\\n\",\n\t\t\terr, mac_info.status, out_size);\n\t\treturn -EINVAL;\n\t}\n\n\tif (mac_info.status == HINIC_MGMT_STATUS_EXIST)\n\t\tdev_warn(&hwdev->hwif->pdev->dev, \"MAC is repeated. Ignore update operation\\n\");\n\n\treturn 0;\n}\n\nstatic void hinic_get_vf_config(struct hinic_hwdev *hwdev, u16 vf_id,\n\t\t\t\tstruct ifla_vf_info *ivi)\n{\n\tstruct vf_data_storage *vfinfo;\n\n\tvfinfo = hwdev->func_to_io.vf_infos + HW_VF_ID_TO_OS(vf_id);\n\n\tivi->vf = HW_VF_ID_TO_OS(vf_id);\n\tmemcpy(ivi->mac, vfinfo->vf_mac_addr, ETH_ALEN);\n\tivi->vlan = vfinfo->pf_vlan;\n\tivi->qos = vfinfo->pf_qos;\n\tivi->spoofchk = vfinfo->spoofchk;\n\tivi->trusted = vfinfo->trust;\n\tivi->max_tx_rate = vfinfo->max_rate;\n\tivi->min_tx_rate = vfinfo->min_rate;\n\n\tif (!vfinfo->link_forced)\n\t\tivi->linkstate = IFLA_VF_LINK_STATE_AUTO;\n\telse if (vfinfo->link_up)\n\t\tivi->linkstate = IFLA_VF_LINK_STATE_ENABLE;\n\telse\n\t\tivi->linkstate = IFLA_VF_LINK_STATE_DISABLE;\n}\n\nint hinic_ndo_get_vf_config(struct net_device *netdev,\n\t\t\t    int vf, struct ifla_vf_info *ivi)\n{\n\tstruct hinic_dev *nic_dev = netdev_priv(netdev);\n\tstruct hinic_sriov_info *sriov_info;\n\n\tsriov_info = &nic_dev->sriov_info;\n\tif (vf >= sriov_info->num_vfs)\n\t\treturn -EINVAL;\n\n\thinic_get_vf_config(sriov_info->hwdev, OS_VF_ID_TO_HW(vf), ivi);\n\n\treturn 0;\n}\n\nstatic int hinic_set_vf_mac(struct hinic_hwdev *hwdev, int vf,\n\t\t\t    unsigned char *mac_addr)\n{\n\tstruct hinic_func_to_io *nic_io = &hwdev->func_to_io;\n\tstruct vf_data_storage *vf_info;\n\tu16 func_id;\n\tint err;\n\n\tvf_info = nic_io->vf_infos + HW_VF_ID_TO_OS(vf);\n\n\t \n\tif (vf_info->pf_set_mac &&\n\t    !memcmp(vf_info->vf_mac_addr, mac_addr, ETH_ALEN))\n\t\treturn 0;\n\n\tvf_info->pf_set_mac = true;\n\n\tfunc_id = hinic_glb_pf_vf_offset(hwdev->hwif) + vf;\n\terr = hinic_update_mac(hwdev, vf_info->vf_mac_addr,\n\t\t\t       mac_addr, 0, func_id);\n\tif (err) {\n\t\tvf_info->pf_set_mac = false;\n\t\treturn err;\n\t}\n\n\tmemcpy(vf_info->vf_mac_addr, mac_addr, ETH_ALEN);\n\n\treturn 0;\n}\n\nint hinic_ndo_set_vf_mac(struct net_device *netdev, int vf, u8 *mac)\n{\n\tstruct hinic_dev *nic_dev = netdev_priv(netdev);\n\tstruct hinic_sriov_info *sriov_info;\n\tint err;\n\n\tsriov_info = &nic_dev->sriov_info;\n\tif (!is_valid_ether_addr(mac) || vf >= sriov_info->num_vfs)\n\t\treturn -EINVAL;\n\n\terr = hinic_set_vf_mac(sriov_info->hwdev, OS_VF_ID_TO_HW(vf), mac);\n\tif (err)\n\t\treturn err;\n\n\tnetif_info(nic_dev, drv, netdev, \"Setting MAC %pM on VF %d\\n\", mac, vf);\n\tnetif_info(nic_dev, drv, netdev, \"Reload the VF driver to make this change effective.\");\n\n\treturn 0;\n}\n\nstatic int hinic_add_vf_vlan(struct hinic_hwdev *hwdev, int vf_id,\n\t\t\t     u16 vlan, u8 qos)\n{\n\tstruct hinic_func_to_io *nic_io = &hwdev->func_to_io;\n\tint err;\n\n\terr = hinic_set_vf_vlan(hwdev, true, vlan, qos, vf_id);\n\tif (err)\n\t\treturn err;\n\n\tnic_io->vf_infos[HW_VF_ID_TO_OS(vf_id)].pf_vlan = vlan;\n\tnic_io->vf_infos[HW_VF_ID_TO_OS(vf_id)].pf_qos = qos;\n\n\tdev_info(&hwdev->hwif->pdev->dev, \"Setting VLAN %d, QOS 0x%x on VF %d\\n\",\n\t\t vlan, qos, HW_VF_ID_TO_OS(vf_id));\n\treturn 0;\n}\n\nstatic int hinic_kill_vf_vlan(struct hinic_hwdev *hwdev, int vf_id)\n{\n\tstruct hinic_func_to_io *nic_io = &hwdev->func_to_io;\n\tint err;\n\n\terr = hinic_set_vf_vlan(hwdev, false,\n\t\t\t\tnic_io->vf_infos[HW_VF_ID_TO_OS(vf_id)].pf_vlan,\n\t\t\t\tnic_io->vf_infos[HW_VF_ID_TO_OS(vf_id)].pf_qos,\n\t\t\t\tvf_id);\n\tif (err)\n\t\treturn err;\n\n\tdev_info(&hwdev->hwif->pdev->dev, \"Remove VLAN %d on VF %d\\n\",\n\t\t nic_io->vf_infos[HW_VF_ID_TO_OS(vf_id)].pf_vlan,\n\t\t HW_VF_ID_TO_OS(vf_id));\n\n\tnic_io->vf_infos[HW_VF_ID_TO_OS(vf_id)].pf_vlan = 0;\n\tnic_io->vf_infos[HW_VF_ID_TO_OS(vf_id)].pf_qos = 0;\n\n\treturn 0;\n}\n\nstatic int hinic_update_mac_vlan(struct hinic_dev *nic_dev, u16 old_vlan,\n\t\t\t\t u16 new_vlan, int vf_id)\n{\n\tstruct vf_data_storage *vf_info;\n\tu16 vlan_id;\n\tint err;\n\n\tif (!nic_dev || old_vlan >= VLAN_N_VID || new_vlan >= VLAN_N_VID)\n\t\treturn -EINVAL;\n\n\tvf_info = nic_dev->hwdev->func_to_io.vf_infos + HW_VF_ID_TO_OS(vf_id);\n\tif (!vf_info->pf_set_mac)\n\t\treturn 0;\n\n\tvlan_id = old_vlan;\n\tif (vlan_id)\n\t\tvlan_id |= HINIC_ADD_VLAN_IN_MAC;\n\n\terr = hinic_port_del_mac(nic_dev, vf_info->vf_mac_addr, vlan_id);\n\tif (err) {\n\t\tdev_err(&nic_dev->hwdev->hwif->pdev->dev, \"Failed to delete VF %d MAC %pM vlan %d\\n\",\n\t\t\tHW_VF_ID_TO_OS(vf_id), vf_info->vf_mac_addr, old_vlan);\n\t\treturn err;\n\t}\n\n\tvlan_id = new_vlan;\n\tif (vlan_id)\n\t\tvlan_id |= HINIC_ADD_VLAN_IN_MAC;\n\n\terr = hinic_port_add_mac(nic_dev, vf_info->vf_mac_addr, vlan_id);\n\tif (err) {\n\t\tdev_err(&nic_dev->hwdev->hwif->pdev->dev, \"Failed to add VF %d MAC %pM vlan %d\\n\",\n\t\t\tHW_VF_ID_TO_OS(vf_id), vf_info->vf_mac_addr, new_vlan);\n\t\tgoto out;\n\t}\n\n\treturn 0;\n\nout:\n\tvlan_id = old_vlan;\n\tif (vlan_id)\n\t\tvlan_id |= HINIC_ADD_VLAN_IN_MAC;\n\thinic_port_add_mac(nic_dev, vf_info->vf_mac_addr, vlan_id);\n\n\treturn err;\n}\n\nstatic int set_hw_vf_vlan(struct hinic_dev *nic_dev,\n\t\t\t  u16 cur_vlanprio, int vf, u16 vlan, u8 qos)\n{\n\tu16 old_vlan = cur_vlanprio & VLAN_VID_MASK;\n\tint err = 0;\n\n\tif (vlan || qos) {\n\t\tif (cur_vlanprio) {\n\t\t\terr = hinic_kill_vf_vlan(nic_dev->hwdev,\n\t\t\t\t\t\t OS_VF_ID_TO_HW(vf));\n\t\t\tif (err) {\n\t\t\t\tdev_err(&nic_dev->sriov_info.pdev->dev, \"Failed to delete vf %d old vlan %d\\n\",\n\t\t\t\t\tvf, old_vlan);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\terr = hinic_add_vf_vlan(nic_dev->hwdev,\n\t\t\t\t\tOS_VF_ID_TO_HW(vf), vlan, qos);\n\t\tif (err) {\n\t\t\tdev_err(&nic_dev->sriov_info.pdev->dev, \"Failed to add vf %d new vlan %d\\n\",\n\t\t\t\tvf, vlan);\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\terr = hinic_kill_vf_vlan(nic_dev->hwdev, OS_VF_ID_TO_HW(vf));\n\t\tif (err) {\n\t\t\tdev_err(&nic_dev->sriov_info.pdev->dev, \"Failed to delete vf %d vlan %d\\n\",\n\t\t\t\tvf, old_vlan);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\terr = hinic_update_mac_vlan(nic_dev, old_vlan, vlan,\n\t\t\t\t    OS_VF_ID_TO_HW(vf));\n\nout:\n\treturn err;\n}\n\nint hinic_ndo_set_vf_vlan(struct net_device *netdev, int vf, u16 vlan, u8 qos,\n\t\t\t  __be16 vlan_proto)\n{\n\tstruct hinic_dev *nic_dev = netdev_priv(netdev);\n\tstruct hinic_sriov_info *sriov_info;\n\tu16 vlanprio, cur_vlanprio;\n\n\tsriov_info = &nic_dev->sriov_info;\n\tif (vf >= sriov_info->num_vfs || vlan >= VLAN_N_VID || qos > HINIC_MAX_QOS)\n\t\treturn -EINVAL;\n\tif (vlan_proto != htons(ETH_P_8021Q))\n\t\treturn -EPROTONOSUPPORT;\n\tvlanprio = vlan | qos << HINIC_VLAN_PRIORITY_SHIFT;\n\tcur_vlanprio = hinic_vf_info_vlanprio(nic_dev->hwdev,\n\t\t\t\t\t      OS_VF_ID_TO_HW(vf));\n\t \n\tif (vlanprio == cur_vlanprio)\n\t\treturn 0;\n\n\treturn set_hw_vf_vlan(nic_dev, cur_vlanprio, vf, vlan, qos);\n}\n\nstatic int hinic_set_vf_trust(struct hinic_hwdev *hwdev, u16 vf_id,\n\t\t\t      bool trust)\n{\n\tstruct vf_data_storage *vf_infos;\n\tstruct hinic_func_to_io *nic_io;\n\n\tif (!hwdev)\n\t\treturn -EINVAL;\n\n\tnic_io = &hwdev->func_to_io;\n\tvf_infos = nic_io->vf_infos;\n\tvf_infos[vf_id].trust = trust;\n\n\treturn 0;\n}\n\nint hinic_ndo_set_vf_trust(struct net_device *netdev, int vf, bool setting)\n{\n\tstruct hinic_dev *adapter = netdev_priv(netdev);\n\tstruct hinic_sriov_info *sriov_info;\n\tstruct hinic_func_to_io *nic_io;\n\tbool cur_trust;\n\tint err;\n\n\tsriov_info = &adapter->sriov_info;\n\tnic_io = &adapter->hwdev->func_to_io;\n\n\tif (vf >= sriov_info->num_vfs)\n\t\treturn -EINVAL;\n\n\tcur_trust = nic_io->vf_infos[vf].trust;\n\t \n\tif (setting == cur_trust)\n\t\treturn 0;\n\n\terr = hinic_set_vf_trust(adapter->hwdev, vf, setting);\n\tif (!err)\n\t\tdev_info(&sriov_info->pdev->dev, \"Set VF %d trusted %s succeed\\n\",\n\t\t\t vf, setting ? \"on\" : \"off\");\n\telse\n\t\tdev_err(&sriov_info->pdev->dev, \"Failed set VF %d trusted %s\\n\",\n\t\t\tvf, setting ? \"on\" : \"off\");\n\n\treturn err;\n}\n\nint hinic_ndo_set_vf_bw(struct net_device *netdev,\n\t\t\tint vf, int min_tx_rate, int max_tx_rate)\n{\n\tstatic const u32 speeds[] = {\n\t\tSPEED_10, SPEED_100, SPEED_1000, SPEED_10000,\n\t\tSPEED_25000, SPEED_40000, SPEED_100000\n\t};\n\tstruct hinic_dev *nic_dev = netdev_priv(netdev);\n\tstruct hinic_port_cap port_cap = { 0 };\n\tenum hinic_port_link_state link_state;\n\tint err;\n\n\tif (vf >= nic_dev->sriov_info.num_vfs) {\n\t\tnetif_err(nic_dev, drv, netdev, \"VF number must be less than %d\\n\",\n\t\t\t  nic_dev->sriov_info.num_vfs);\n\t\treturn -EINVAL;\n\t}\n\n\terr = hinic_port_link_state(nic_dev, &link_state);\n\tif (err) {\n\t\tnetif_err(nic_dev, drv, netdev,\n\t\t\t  \"Get link status failed when setting vf tx rate\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (link_state == HINIC_LINK_STATE_DOWN) {\n\t\tnetif_err(nic_dev, drv, netdev,\n\t\t\t  \"Link status must be up when setting vf tx rate\\n\");\n\t\treturn -EPERM;\n\t}\n\n\terr = hinic_port_get_cap(nic_dev, &port_cap);\n\tif (err || port_cap.speed > LINK_SPEED_100GB)\n\t\treturn -EIO;\n\n\t \n\tif (max_tx_rate < 0 || max_tx_rate > speeds[port_cap.speed]) {\n\t\tnetif_err(nic_dev, drv, netdev, \"Max tx rate must be in [0 - %d]\\n\",\n\t\t\t  speeds[port_cap.speed]);\n\t\treturn -EINVAL;\n\t}\n\n\terr = hinic_set_vf_tx_rate(nic_dev->hwdev, OS_VF_ID_TO_HW(vf),\n\t\t\t\t   max_tx_rate, min_tx_rate);\n\tif (err) {\n\t\tnetif_err(nic_dev, drv, netdev,\n\t\t\t  \"Unable to set VF %d max rate %d min rate %d%s\\n\",\n\t\t\t  vf, max_tx_rate, min_tx_rate,\n\t\t\t  err == HINIC_TX_RATE_TABLE_FULL ?\n\t\t\t  \", tx rate profile is full\" : \"\");\n\t\treturn -EIO;\n\t}\n\n\tnetif_info(nic_dev, drv, netdev,\n\t\t   \"Set VF %d max tx rate %d min tx rate %d successfully\\n\",\n\t\t   vf, max_tx_rate, min_tx_rate);\n\n\treturn 0;\n}\n\nstatic int hinic_set_vf_spoofchk(struct hinic_hwdev *hwdev, u16 vf_id,\n\t\t\t\t bool spoofchk)\n{\n\tstruct hinic_spoofchk_set spoofchk_cfg = {0};\n\tstruct vf_data_storage *vf_infos = NULL;\n\tu16 out_size = sizeof(spoofchk_cfg);\n\tint err;\n\n\tif (!hwdev)\n\t\treturn -EINVAL;\n\n\tvf_infos = hwdev->func_to_io.vf_infos;\n\n\tspoofchk_cfg.func_id = hinic_glb_pf_vf_offset(hwdev->hwif) + vf_id;\n\tspoofchk_cfg.state = spoofchk ? 1 : 0;\n\terr = hinic_port_msg_cmd(hwdev, HINIC_PORT_CMD_ENABLE_SPOOFCHK,\n\t\t\t\t &spoofchk_cfg, sizeof(spoofchk_cfg),\n\t\t\t\t &spoofchk_cfg, &out_size);\n\tif (spoofchk_cfg.status == HINIC_MGMT_CMD_UNSUPPORTED) {\n\t\terr = HINIC_MGMT_CMD_UNSUPPORTED;\n\t} else if (err || !out_size || spoofchk_cfg.status) {\n\t\tdev_err(&hwdev->hwif->pdev->dev, \"Failed to set VF(%d) spoofchk, err: %d, status: 0x%x, out size: 0x%x\\n\",\n\t\t\tHW_VF_ID_TO_OS(vf_id), err, spoofchk_cfg.status,\n\t\t\tout_size);\n\t\terr = -EIO;\n\t}\n\n\tvf_infos[HW_VF_ID_TO_OS(vf_id)].spoofchk = spoofchk;\n\n\treturn err;\n}\n\nint hinic_ndo_set_vf_spoofchk(struct net_device *netdev, int vf, bool setting)\n{\n\tstruct hinic_dev *nic_dev = netdev_priv(netdev);\n\tstruct hinic_sriov_info *sriov_info;\n\tbool cur_spoofchk;\n\tint err;\n\n\tsriov_info = &nic_dev->sriov_info;\n\tif (vf >= sriov_info->num_vfs)\n\t\treturn -EINVAL;\n\n\tcur_spoofchk = nic_dev->hwdev->func_to_io.vf_infos[vf].spoofchk;\n\n\t \n\tif (setting == cur_spoofchk)\n\t\treturn 0;\n\n\terr = hinic_set_vf_spoofchk(sriov_info->hwdev,\n\t\t\t\t    OS_VF_ID_TO_HW(vf), setting);\n\tif (!err) {\n\t\tnetif_info(nic_dev, drv, netdev, \"Set VF %d spoofchk %s successfully\\n\",\n\t\t\t   vf, setting ? \"on\" : \"off\");\n\t} else if (err == HINIC_MGMT_CMD_UNSUPPORTED) {\n\t\tnetif_err(nic_dev, drv, netdev,\n\t\t\t  \"Current firmware doesn't support to set vf spoofchk, need to upgrade latest firmware version\\n\");\n\t\terr = -EOPNOTSUPP;\n\t}\n\n\treturn err;\n}\n\nstatic int hinic_set_vf_link_state(struct hinic_hwdev *hwdev, u16 vf_id,\n\t\t\t\t   int link)\n{\n\tstruct hinic_func_to_io *nic_io = &hwdev->func_to_io;\n\tstruct vf_data_storage *vf_infos = nic_io->vf_infos;\n\tu8 link_status = 0;\n\n\tswitch (link) {\n\tcase HINIC_IFLA_VF_LINK_STATE_AUTO:\n\t\tvf_infos[HW_VF_ID_TO_OS(vf_id)].link_forced = false;\n\t\tvf_infos[HW_VF_ID_TO_OS(vf_id)].link_up = nic_io->link_status ?\n\t\t\ttrue : false;\n\t\tlink_status = nic_io->link_status;\n\t\tbreak;\n\tcase HINIC_IFLA_VF_LINK_STATE_ENABLE:\n\t\tvf_infos[HW_VF_ID_TO_OS(vf_id)].link_forced = true;\n\t\tvf_infos[HW_VF_ID_TO_OS(vf_id)].link_up = true;\n\t\tlink_status = HINIC_LINK_UP;\n\t\tbreak;\n\tcase HINIC_IFLA_VF_LINK_STATE_DISABLE:\n\t\tvf_infos[HW_VF_ID_TO_OS(vf_id)].link_forced = true;\n\t\tvf_infos[HW_VF_ID_TO_OS(vf_id)].link_up = false;\n\t\tlink_status = HINIC_LINK_DOWN;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\thinic_notify_vf_link_status(hwdev, vf_id, link_status);\n\n\treturn 0;\n}\n\nint hinic_ndo_set_vf_link_state(struct net_device *netdev, int vf_id, int link)\n{\n\tstruct hinic_dev *nic_dev = netdev_priv(netdev);\n\tstruct hinic_sriov_info *sriov_info;\n\n\tsriov_info = &nic_dev->sriov_info;\n\n\tif (vf_id >= sriov_info->num_vfs) {\n\t\tnetif_err(nic_dev, drv, netdev,\n\t\t\t  \"Invalid VF Identifier %d\\n\", vf_id);\n\t\treturn -EINVAL;\n\t}\n\n\treturn hinic_set_vf_link_state(sriov_info->hwdev,\n\t\t\t\t      OS_VF_ID_TO_HW(vf_id), link);\n}\n\n \nstatic int nic_pf_mbox_handler(void *hwdev, u16 vf_id, u8 cmd, void *buf_in,\n\t\t\t       u16 in_size, void *buf_out, u16 *out_size)\n{\n\tu8 size = ARRAY_SIZE(nic_cmd_support_vf);\n\tstruct vf_cmd_msg_handle *vf_msg_handle;\n\tstruct hinic_hwdev *dev = hwdev;\n\tstruct hinic_func_to_io *nic_io;\n\tstruct hinic_pfhwdev *pfhwdev;\n\tint err = 0;\n\tu32 i;\n\n\tif (!hwdev)\n\t\treturn -EINVAL;\n\n\tif (!hinic_mbox_check_cmd_valid(hwdev, nic_cmd_support_vf, vf_id, cmd,\n\t\t\t\t\tbuf_in, in_size, size)) {\n\t\tdev_err(&dev->hwif->pdev->dev,\n\t\t\t\"PF Receive VF nic cmd: 0x%x, mbox len: 0x%x is invalid\\n\",\n\t\t\tcmd, in_size);\n\t\treturn HINIC_MBOX_VF_CMD_ERROR;\n\t}\n\n\tpfhwdev = container_of(dev, struct hinic_pfhwdev, hwdev);\n\tnic_io = &dev->func_to_io;\n\tfor (i = 0; i < ARRAY_SIZE(nic_vf_cmd_msg_handler); i++) {\n\t\tvf_msg_handle = &nic_vf_cmd_msg_handler[i];\n\t\tif (cmd == vf_msg_handle->cmd &&\n\t\t    vf_msg_handle->cmd_msg_handler) {\n\t\t\terr = vf_msg_handle->cmd_msg_handler(hwdev, vf_id,\n\t\t\t\t\t\t\t     buf_in, in_size,\n\t\t\t\t\t\t\t     buf_out,\n\t\t\t\t\t\t\t     out_size);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i == ARRAY_SIZE(nic_vf_cmd_msg_handler))\n\t\terr = hinic_msg_to_mgmt(&pfhwdev->pf_to_mgmt, HINIC_MOD_L2NIC,\n\t\t\t\t\tcmd, buf_in, in_size, buf_out,\n\t\t\t\t\tout_size, HINIC_MGMT_MSG_SYNC);\n\n\tif (err &&  err != HINIC_MBOX_PF_BUSY_ACTIVE_FW)\n\t\tdev_err(&nic_io->hwif->pdev->dev, \"PF receive VF L2NIC cmd: %d process error, err:%d\\n\",\n\t\t\tcmd, err);\n\treturn err;\n}\n\nstatic int cfg_mbx_pf_proc_vf_msg(void *hwdev, u16 vf_id, u8 cmd, void *buf_in,\n\t\t\t\t  u16 in_size, void *buf_out, u16 *out_size)\n{\n\tstruct hinic_dev_cap *dev_cap = buf_out;\n\tstruct hinic_hwdev *dev = hwdev;\n\tstruct hinic_cap *cap;\n\n\tcap = &dev->nic_cap;\n\tmemset(dev_cap, 0, sizeof(*dev_cap));\n\n\tdev_cap->max_vf = cap->max_vf;\n\tdev_cap->max_sqs = cap->max_vf_qps;\n\tdev_cap->max_rqs = cap->max_vf_qps;\n\tdev_cap->port_id = dev->port_id;\n\n\t*out_size = sizeof(*dev_cap);\n\n\treturn 0;\n}\n\nstatic int hinic_init_vf_infos(struct hinic_func_to_io *nic_io, u16 vf_id)\n{\n\tstruct vf_data_storage *vf_infos = nic_io->vf_infos;\n\n\tif (set_vf_link_state > HINIC_IFLA_VF_LINK_STATE_DISABLE) {\n\t\tdev_warn(&nic_io->hwif->pdev->dev, \"Module Parameter set_vf_link_state value %d is out of range, resetting to %d\\n\",\n\t\t\t set_vf_link_state, HINIC_IFLA_VF_LINK_STATE_AUTO);\n\t\tset_vf_link_state = HINIC_IFLA_VF_LINK_STATE_AUTO;\n\t}\n\n\tswitch (set_vf_link_state) {\n\tcase HINIC_IFLA_VF_LINK_STATE_AUTO:\n\t\tvf_infos[vf_id].link_forced = false;\n\t\tbreak;\n\tcase HINIC_IFLA_VF_LINK_STATE_ENABLE:\n\t\tvf_infos[vf_id].link_forced = true;\n\t\tvf_infos[vf_id].link_up = true;\n\t\tbreak;\n\tcase HINIC_IFLA_VF_LINK_STATE_DISABLE:\n\t\tvf_infos[vf_id].link_forced = true;\n\t\tvf_infos[vf_id].link_up = false;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&nic_io->hwif->pdev->dev, \"Invalid input parameter set_vf_link_state: %d\\n\",\n\t\t\tset_vf_link_state);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void hinic_clear_vf_infos(struct hinic_dev *nic_dev, u16 vf_id)\n{\n\tstruct vf_data_storage *vf_infos;\n\n\tvf_infos = nic_dev->hwdev->func_to_io.vf_infos + HW_VF_ID_TO_OS(vf_id);\n\tif (vf_infos->pf_set_mac)\n\t\thinic_port_del_mac(nic_dev, vf_infos->vf_mac_addr, 0);\n\n\tif (hinic_vf_info_vlanprio(nic_dev->hwdev, vf_id))\n\t\thinic_kill_vf_vlan(nic_dev->hwdev, vf_id);\n\n\tif (vf_infos->max_rate)\n\t\thinic_set_vf_tx_rate(nic_dev->hwdev, vf_id, 0, 0);\n\n\tif (vf_infos->spoofchk)\n\t\thinic_set_vf_spoofchk(nic_dev->hwdev, vf_id, false);\n\n\tif (vf_infos->trust)\n\t\thinic_set_vf_trust(nic_dev->hwdev, vf_id, false);\n\n\tmemset(vf_infos, 0, sizeof(*vf_infos));\n\t \n\thinic_init_vf_infos(&nic_dev->hwdev->func_to_io, HW_VF_ID_TO_OS(vf_id));\n}\n\nstatic void hinic_deinit_vf_hw(struct hinic_sriov_info *sriov_info,\n\t\t\t       u16 start_vf_id, u16 end_vf_id)\n{\n\tstruct hinic_dev *nic_dev;\n\tu16 func_idx, idx;\n\n\tnic_dev = container_of(sriov_info, struct hinic_dev, sriov_info);\n\n\tfor (idx = start_vf_id; idx <= end_vf_id; idx++) {\n\t\tfunc_idx = hinic_glb_pf_vf_offset(nic_dev->hwdev->hwif) + idx;\n\t\thinic_set_wq_page_size(nic_dev->hwdev, func_idx,\n\t\t\t\t       HINIC_HW_WQ_PAGE_SIZE);\n\t\thinic_clear_vf_infos(nic_dev, idx);\n\t}\n}\n\nint hinic_vf_func_init(struct hinic_hwdev *hwdev)\n{\n\tstruct hinic_register_vf register_info = {0};\n\tu16 out_size = sizeof(register_info);\n\tstruct hinic_func_to_io *nic_io;\n\tint err = 0;\n\tu32 size, i;\n\n\terr = hinic_vf_mbox_random_id_init(hwdev);\n\tif (err) {\n\t\tdev_err(&hwdev->hwif->pdev->dev, \"Failed to init vf mbox random id, err: %d\\n\",\n\t\t\terr);\n\t\treturn err;\n\t}\n\n\tnic_io = &hwdev->func_to_io;\n\n\tif (HINIC_IS_VF(hwdev->hwif)) {\n\t\terr = hinic_mbox_to_pf(hwdev, HINIC_MOD_L2NIC,\n\t\t\t\t       HINIC_PORT_CMD_VF_REGISTER,\n\t\t\t\t       &register_info, sizeof(register_info),\n\t\t\t\t       &register_info, &out_size, 0);\n\t\tif (err || register_info.status || !out_size) {\n\t\t\tdev_err(&hwdev->hwif->pdev->dev,\n\t\t\t\t\"Failed to register VF, err: %d, status: 0x%x, out size: 0x%x\\n\",\n\t\t\t\terr, register_info.status, out_size);\n\t\t\treturn -EIO;\n\t\t}\n\t} else {\n\t\terr = hinic_register_pf_mbox_cb(hwdev, HINIC_MOD_CFGM,\n\t\t\t\t\t\tcfg_mbx_pf_proc_vf_msg);\n\t\tif (err) {\n\t\t\tdev_err(&hwdev->hwif->pdev->dev,\n\t\t\t\t\"Register PF mailbox callback failed\\n\");\n\t\t\treturn err;\n\t\t}\n\t\tnic_io->max_vfs = hwdev->nic_cap.max_vf;\n\t\tsize = sizeof(*nic_io->vf_infos) * nic_io->max_vfs;\n\t\tif (size != 0) {\n\t\t\tnic_io->vf_infos = kzalloc(size, GFP_KERNEL);\n\t\t\tif (!nic_io->vf_infos) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto out_free_nic_io;\n\t\t\t}\n\n\t\t\tfor (i = 0; i < nic_io->max_vfs; i++) {\n\t\t\t\terr = hinic_init_vf_infos(nic_io, i);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto err_init_vf_infos;\n\t\t\t}\n\n\t\t\terr = hinic_register_pf_mbox_cb(hwdev, HINIC_MOD_L2NIC,\n\t\t\t\t\t\t\tnic_pf_mbox_handler);\n\t\t\tif (err)\n\t\t\t\tgoto err_register_pf_mbox_cb;\n\t\t}\n\t}\n\n\treturn 0;\n\nerr_register_pf_mbox_cb:\nerr_init_vf_infos:\n\tkfree(nic_io->vf_infos);\nout_free_nic_io:\n\treturn err;\n}\n\nvoid hinic_vf_func_free(struct hinic_hwdev *hwdev)\n{\n\tstruct hinic_register_vf unregister = {0};\n\tu16 out_size = sizeof(unregister);\n\tint err;\n\n\tif (HINIC_IS_VF(hwdev->hwif)) {\n\t\terr = hinic_mbox_to_pf(hwdev, HINIC_MOD_L2NIC,\n\t\t\t\t       HINIC_PORT_CMD_VF_UNREGISTER,\n\t\t\t\t       &unregister, sizeof(unregister),\n\t\t\t\t       &unregister, &out_size, 0);\n\t\tif (err || !out_size || unregister.status)\n\t\t\tdev_err(&hwdev->hwif->pdev->dev, \"Failed to unregister VF, err: %d, status: 0x%x, out_size: 0x%x\\n\",\n\t\t\t\terr, unregister.status, out_size);\n\t} else {\n\t\tif (hwdev->func_to_io.vf_infos) {\n\t\t\thinic_unregister_pf_mbox_cb(hwdev, HINIC_MOD_L2NIC);\n\t\t\tkfree(hwdev->func_to_io.vf_infos);\n\t\t}\n\t}\n}\n\nstatic int hinic_init_vf_hw(struct hinic_hwdev *hwdev, u16 start_vf_id,\n\t\t\t    u16 end_vf_id)\n{\n\tu16 i, func_idx;\n\tint err;\n\n\t \n\tfor (i = start_vf_id; i <= end_vf_id; i++) {\n\t\tfunc_idx = hinic_glb_pf_vf_offset(hwdev->hwif) + i;\n\t\terr = hinic_set_wq_page_size(hwdev, func_idx,\n\t\t\t\t\t     HINIC_DEFAULT_WQ_PAGE_SIZE);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nint hinic_pci_sriov_disable(struct pci_dev *pdev)\n{\n\tstruct hinic_sriov_info *sriov_info;\n\tu16 tmp_vfs;\n\n\tsriov_info = hinic_get_sriov_info_by_pcidev(pdev);\n\t \n\tif (!sriov_info->sriov_enabled)\n\t\treturn 0;\n\n\tset_bit(HINIC_SRIOV_DISABLE, &sriov_info->state);\n\n\t \n\tif (pci_vfs_assigned(sriov_info->pdev)) {\n\t\tclear_bit(HINIC_SRIOV_DISABLE, &sriov_info->state);\n\t\tdev_warn(&pdev->dev, \"Unloading driver while VFs are assigned - VFs will not be deallocated\\n\");\n\t\treturn -EPERM;\n\t}\n\tsriov_info->sriov_enabled = false;\n\n\t \n\tpci_disable_sriov(sriov_info->pdev);\n\n\ttmp_vfs = (u16)sriov_info->num_vfs;\n\tsriov_info->num_vfs = 0;\n\thinic_deinit_vf_hw(sriov_info, OS_VF_ID_TO_HW(0),\n\t\t\t   OS_VF_ID_TO_HW(tmp_vfs - 1));\n\n\tclear_bit(HINIC_SRIOV_DISABLE, &sriov_info->state);\n\n\treturn 0;\n}\n\nstatic int hinic_pci_sriov_enable(struct pci_dev *pdev, int num_vfs)\n{\n\tstruct hinic_sriov_info *sriov_info;\n\tint err;\n\n\tsriov_info = hinic_get_sriov_info_by_pcidev(pdev);\n\n\tif (test_and_set_bit(HINIC_SRIOV_ENABLE, &sriov_info->state)) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"SR-IOV enable in process, please wait, num_vfs %d\\n\",\n\t\t\tnum_vfs);\n\t\treturn -EPERM;\n\t}\n\n\terr = hinic_init_vf_hw(sriov_info->hwdev, OS_VF_ID_TO_HW(0),\n\t\t\t       OS_VF_ID_TO_HW((u16)num_vfs - 1));\n\tif (err) {\n\t\tdev_err(&sriov_info->pdev->dev,\n\t\t\t\"Failed to init vf in hardware before enable sriov, error %d\\n\",\n\t\t\terr);\n\t\tclear_bit(HINIC_SRIOV_ENABLE, &sriov_info->state);\n\t\treturn err;\n\t}\n\n\terr = pci_enable_sriov(sriov_info->pdev, num_vfs);\n\tif (err) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Failed to enable SR-IOV, error %d\\n\", err);\n\t\tclear_bit(HINIC_SRIOV_ENABLE, &sriov_info->state);\n\t\treturn err;\n\t}\n\n\tsriov_info->sriov_enabled = true;\n\tsriov_info->num_vfs = num_vfs;\n\tclear_bit(HINIC_SRIOV_ENABLE, &sriov_info->state);\n\n\treturn num_vfs;\n}\n\nint hinic_pci_sriov_configure(struct pci_dev *dev, int num_vfs)\n{\n\tstruct hinic_sriov_info *sriov_info;\n\n\tsriov_info = hinic_get_sriov_info_by_pcidev(dev);\n\n\tif (test_bit(HINIC_FUNC_REMOVE, &sriov_info->state))\n\t\treturn -EBUSY;\n\n\tif (!num_vfs)\n\t\treturn hinic_pci_sriov_disable(dev);\n\telse\n\t\treturn hinic_pci_sriov_enable(dev, num_vfs);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}