{
  "module_name": "bgmac-platform.c",
  "hash_id": "3b10e355f9bfff7fe2330f7dc8944e30b2104350d8553911c66a905fe1ceb9e4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/broadcom/bgmac-platform.c",
  "human_readable_source": " \n\n#define pr_fmt(fmt)\t\tKBUILD_MODNAME \": \" fmt\n\n#include <linux/bcma/bcma.h>\n#include <linux/brcmphy.h>\n#include <linux/etherdevice.h>\n#include <linux/of_address.h>\n#include <linux/of_mdio.h>\n#include <linux/of_net.h>\n#include \"bgmac.h\"\n\n#define NICPM_PADRING_CFG\t\t0x00000004\n#define NICPM_IOMUX_CTRL\t\t0x00000008\n\n#define NICPM_PADRING_CFG_INIT_VAL\t0x74000000\n#define NICPM_IOMUX_CTRL_INIT_VAL_AX\t0x21880000\n\n#define NICPM_IOMUX_CTRL_INIT_VAL\t0x3196e000\n#define NICPM_IOMUX_CTRL_SPD_SHIFT\t10\n#define NICPM_IOMUX_CTRL_SPD_10M\t0\n#define NICPM_IOMUX_CTRL_SPD_100M\t1\n#define NICPM_IOMUX_CTRL_SPD_1000M\t2\n\nstatic u32 platform_bgmac_read(struct bgmac *bgmac, u16 offset)\n{\n\treturn readl(bgmac->plat.base + offset);\n}\n\nstatic void platform_bgmac_write(struct bgmac *bgmac, u16 offset, u32 value)\n{\n\twritel(value, bgmac->plat.base + offset);\n}\n\nstatic u32 platform_bgmac_idm_read(struct bgmac *bgmac, u16 offset)\n{\n\treturn readl(bgmac->plat.idm_base + offset);\n}\n\nstatic void platform_bgmac_idm_write(struct bgmac *bgmac, u16 offset, u32 value)\n{\n\twritel(value, bgmac->plat.idm_base + offset);\n}\n\nstatic bool platform_bgmac_clk_enabled(struct bgmac *bgmac)\n{\n\tif (!bgmac->plat.idm_base)\n\t\treturn true;\n\n\tif ((bgmac_idm_read(bgmac, BCMA_IOCTL) & BGMAC_CLK_EN) != BGMAC_CLK_EN)\n\t\treturn false;\n\tif (bgmac_idm_read(bgmac, BCMA_RESET_CTL) & BCMA_RESET_CTL_RESET)\n\t\treturn false;\n\treturn true;\n}\n\nstatic void platform_bgmac_clk_enable(struct bgmac *bgmac, u32 flags)\n{\n\tu32 val;\n\n\tif (!bgmac->plat.idm_base)\n\t\treturn;\n\n\t \n\tval = bgmac_idm_read(bgmac, BCMA_RESET_CTL);\n\tif (val) {\n\t\tbgmac_idm_write(bgmac, BCMA_RESET_CTL, 0);\n\t\tbgmac_idm_read(bgmac, BCMA_RESET_CTL);\n\t\tudelay(1);\n\t}\n\n\tval = bgmac_idm_read(bgmac, BCMA_IOCTL);\n\t \n\tval |= flags & ~(BGMAC_AWCACHE | BGMAC_ARCACHE | BGMAC_AWUSER |\n\t\t\t BGMAC_ARUSER);\n\tval |= BGMAC_CLK_EN;\n\tbgmac_idm_write(bgmac, BCMA_IOCTL, val);\n\tbgmac_idm_read(bgmac, BCMA_IOCTL);\n\tudelay(1);\n}\n\nstatic void platform_bgmac_cco_ctl_maskset(struct bgmac *bgmac, u32 offset,\n\t\t\t\t\t   u32 mask, u32 set)\n{\n\t \n\tWARN_ON(1);\n}\n\nstatic u32 platform_bgmac_get_bus_clock(struct bgmac *bgmac)\n{\n\t \n\tWARN_ON(1);\n\n\treturn 0;\n}\n\nstatic void platform_bgmac_cmn_maskset32(struct bgmac *bgmac, u16 offset,\n\t\t\t\t\t u32 mask, u32 set)\n{\n\t \n\tWARN_ON(1);\n}\n\nstatic void bgmac_nicpm_speed_set(struct net_device *net_dev)\n{\n\tstruct bgmac *bgmac = netdev_priv(net_dev);\n\tu32 val;\n\n\tif (!bgmac->plat.nicpm_base)\n\t\treturn;\n\n\t \n\twritel(NICPM_PADRING_CFG_INIT_VAL,\n\t       bgmac->plat.nicpm_base + NICPM_PADRING_CFG);\n\n\tval = NICPM_IOMUX_CTRL_INIT_VAL;\n\tswitch (bgmac->net_dev->phydev->speed) {\n\tdefault:\n\t\tnetdev_err(net_dev, \"Unsupported speed. Defaulting to 1000Mb\\n\");\n\t\tfallthrough;\n\tcase SPEED_1000:\n\t\tval |= NICPM_IOMUX_CTRL_SPD_1000M << NICPM_IOMUX_CTRL_SPD_SHIFT;\n\t\tbreak;\n\tcase SPEED_100:\n\t\tval |= NICPM_IOMUX_CTRL_SPD_100M << NICPM_IOMUX_CTRL_SPD_SHIFT;\n\t\tbreak;\n\tcase SPEED_10:\n\t\tval |= NICPM_IOMUX_CTRL_SPD_10M << NICPM_IOMUX_CTRL_SPD_SHIFT;\n\t\tbreak;\n\t}\n\n\twritel(val, bgmac->plat.nicpm_base + NICPM_IOMUX_CTRL);\n\n\tbgmac_adjust_link(bgmac->net_dev);\n}\n\nstatic int platform_phy_connect(struct bgmac *bgmac)\n{\n\tstruct phy_device *phy_dev;\n\n\tif (bgmac->plat.nicpm_base)\n\t\tphy_dev = of_phy_get_and_connect(bgmac->net_dev,\n\t\t\t\t\t\t bgmac->dev->of_node,\n\t\t\t\t\t\t bgmac_nicpm_speed_set);\n\telse\n\t\tphy_dev = of_phy_get_and_connect(bgmac->net_dev,\n\t\t\t\t\t\t bgmac->dev->of_node,\n\t\t\t\t\t\t bgmac_adjust_link);\n\tif (!phy_dev) {\n\t\tdev_err(bgmac->dev, \"PHY connection failed\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic int bgmac_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct bgmac *bgmac;\n\tstruct resource *regs;\n\tint ret;\n\n\tbgmac = bgmac_alloc(&pdev->dev);\n\tif (!bgmac)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, bgmac);\n\n\t \n\tbgmac->feature_flags |= BGMAC_FEAT_CLKCTLST;\n\tbgmac->feature_flags |= BGMAC_FEAT_NO_RESET;\n\tbgmac->feature_flags |= BGMAC_FEAT_CMDCFG_SR_REV4;\n\tbgmac->feature_flags |= BGMAC_FEAT_TX_MASK_SETUP;\n\tbgmac->feature_flags |= BGMAC_FEAT_RX_MASK_SETUP;\n\tbgmac->feature_flags |= BGMAC_FEAT_IDM_MASK;\n\n\tbgmac->dev = &pdev->dev;\n\tbgmac->dma_dev = &pdev->dev;\n\n\tret = of_get_ethdev_address(np, bgmac->net_dev);\n\tif (ret == -EPROBE_DEFER)\n\t\treturn ret;\n\n\tif (ret)\n\t\tdev_warn(&pdev->dev,\n\t\t\t \"MAC address not present in device tree\\n\");\n\n\tbgmac->irq = platform_get_irq(pdev, 0);\n\tif (bgmac->irq < 0)\n\t\treturn bgmac->irq;\n\n\tbgmac->plat.base =\n\t\tdevm_platform_ioremap_resource_byname(pdev, \"amac_base\");\n\tif (IS_ERR(bgmac->plat.base))\n\t\treturn PTR_ERR(bgmac->plat.base);\n\n\t \n\tregs = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"idm_base\");\n\tif (regs) {\n\t\tbgmac->plat.idm_base = devm_ioremap_resource(&pdev->dev, regs);\n\t\tif (IS_ERR(bgmac->plat.idm_base))\n\t\t\treturn PTR_ERR(bgmac->plat.idm_base);\n\t\tbgmac->feature_flags &= ~BGMAC_FEAT_IDM_MASK;\n\t}\n\n\t \n\tregs = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"nicpm_base\");\n\tif (regs) {\n\t\tbgmac->plat.nicpm_base = devm_ioremap_resource(&pdev->dev,\n\t\t\t\t\t\t\t       regs);\n\t\tif (IS_ERR(bgmac->plat.nicpm_base))\n\t\t\treturn PTR_ERR(bgmac->plat.nicpm_base);\n\t}\n\n\tbgmac->read = platform_bgmac_read;\n\tbgmac->write = platform_bgmac_write;\n\tbgmac->idm_read = platform_bgmac_idm_read;\n\tbgmac->idm_write = platform_bgmac_idm_write;\n\tbgmac->clk_enabled = platform_bgmac_clk_enabled;\n\tbgmac->clk_enable = platform_bgmac_clk_enable;\n\tbgmac->cco_ctl_maskset = platform_bgmac_cco_ctl_maskset;\n\tbgmac->get_bus_clock = platform_bgmac_get_bus_clock;\n\tbgmac->cmn_maskset32 = platform_bgmac_cmn_maskset32;\n\tif (of_parse_phandle(np, \"phy-handle\", 0)) {\n\t\tbgmac->phy_connect = platform_phy_connect;\n\t} else {\n\t\tbgmac->phy_connect = bgmac_phy_connect_direct;\n\t\tbgmac->feature_flags |= BGMAC_FEAT_FORCE_SPEED_2500;\n\t}\n\n\treturn bgmac_enet_probe(bgmac);\n}\n\nstatic int bgmac_remove(struct platform_device *pdev)\n{\n\tstruct bgmac *bgmac = platform_get_drvdata(pdev);\n\n\tbgmac_enet_remove(bgmac);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM\nstatic int bgmac_suspend(struct device *dev)\n{\n\tstruct bgmac *bgmac = dev_get_drvdata(dev);\n\n\treturn bgmac_enet_suspend(bgmac);\n}\n\nstatic int bgmac_resume(struct device *dev)\n{\n\tstruct bgmac *bgmac = dev_get_drvdata(dev);\n\n\treturn bgmac_enet_resume(bgmac);\n}\n\nstatic const struct dev_pm_ops bgmac_pm_ops = {\n\t.suspend = bgmac_suspend,\n\t.resume = bgmac_resume\n};\n\n#define BGMAC_PM_OPS (&bgmac_pm_ops)\n#else\n#define BGMAC_PM_OPS NULL\n#endif  \n\nstatic const struct of_device_id bgmac_of_enet_match[] = {\n\t{.compatible = \"brcm,amac\",},\n\t{.compatible = \"brcm,nsp-amac\",},\n\t{.compatible = \"brcm,ns2-amac\",},\n\t{},\n};\n\nMODULE_DEVICE_TABLE(of, bgmac_of_enet_match);\n\nstatic struct platform_driver bgmac_enet_driver = {\n\t.driver = {\n\t\t.name  = \"bgmac-enet\",\n\t\t.of_match_table = bgmac_of_enet_match,\n\t\t.pm = BGMAC_PM_OPS\n\t},\n\t.probe = bgmac_probe,\n\t.remove = bgmac_remove,\n};\n\nmodule_platform_driver(bgmac_enet_driver);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}