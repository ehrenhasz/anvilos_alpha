{
  "module_name": "b44.c",
  "hash_id": "1701b20330138e62d0b15bf3c95299f53c28a4d32cc387b1790c3e32252ab3d9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/broadcom/b44.c",
  "human_readable_source": " \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/types.h>\n#include <linux/netdevice.h>\n#include <linux/ethtool.h>\n#include <linux/mii.h>\n#include <linux/if_ether.h>\n#include <linux/if_vlan.h>\n#include <linux/etherdevice.h>\n#include <linux/pci.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/dma-mapping.h>\n#include <linux/ssb/ssb.h>\n#include <linux/slab.h>\n#include <linux/phy.h>\n\n#include <linux/uaccess.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n\n\n#include \"b44.h\"\n\n#define DRV_MODULE_NAME\t\t\"b44\"\n#define DRV_DESCRIPTION\t\t\"Broadcom 44xx/47xx 10/100 PCI ethernet driver\"\n\n#define B44_DEF_MSG_ENABLE\t  \\\n\t(NETIF_MSG_DRV\t\t| \\\n\t NETIF_MSG_PROBE\t| \\\n\t NETIF_MSG_LINK\t\t| \\\n\t NETIF_MSG_TIMER\t| \\\n\t NETIF_MSG_IFDOWN\t| \\\n\t NETIF_MSG_IFUP\t\t| \\\n\t NETIF_MSG_RX_ERR\t| \\\n\t NETIF_MSG_TX_ERR)\n\n \n#define B44_TX_TIMEOUT\t\t\t(5 * HZ)\n\n \n#define B44_MIN_MTU\t\t\tETH_ZLEN\n#define B44_MAX_MTU\t\t\tETH_DATA_LEN\n\n#define B44_RX_RING_SIZE\t\t512\n#define B44_DEF_RX_RING_PENDING\t\t200\n#define B44_RX_RING_BYTES\t(sizeof(struct dma_desc) * \\\n\t\t\t\t B44_RX_RING_SIZE)\n#define B44_TX_RING_SIZE\t\t512\n#define B44_DEF_TX_RING_PENDING\t\t(B44_TX_RING_SIZE - 1)\n#define B44_TX_RING_BYTES\t(sizeof(struct dma_desc) * \\\n\t\t\t\t B44_TX_RING_SIZE)\n\n#define TX_RING_GAP(BP)\t\\\n\t(B44_TX_RING_SIZE - (BP)->tx_pending)\n#define TX_BUFFS_AVAIL(BP)\t\t\t\t\t\t\\\n\t(((BP)->tx_cons <= (BP)->tx_prod) ?\t\t\t\t\\\n\t  (BP)->tx_cons + (BP)->tx_pending - (BP)->tx_prod :\t\t\\\n\t  (BP)->tx_cons - (BP)->tx_prod - TX_RING_GAP(BP))\n#define NEXT_TX(N)\t\t(((N) + 1) & (B44_TX_RING_SIZE - 1))\n\n#define RX_PKT_OFFSET\t\t(RX_HEADER_LEN + 2)\n#define RX_PKT_BUF_SZ\t\t(1536 + RX_PKT_OFFSET)\n\n \n#define B44_TX_WAKEUP_THRESH\t\t(B44_TX_RING_SIZE / 4)\n\n \n#define B44_PATTERN_BASE\t0x400\n#define B44_PATTERN_SIZE\t0x80\n#define B44_PMASK_BASE\t\t0x600\n#define B44_PMASK_SIZE\t\t0x10\n#define B44_MAX_PATTERNS\t16\n#define B44_ETHIPV6UDP_HLEN\t62\n#define B44_ETHIPV4UDP_HLEN\t42\n\nMODULE_AUTHOR(\"Felix Fietkau, Florian Schirmer, Pekka Pietikainen, David S. Miller\");\nMODULE_DESCRIPTION(DRV_DESCRIPTION);\nMODULE_LICENSE(\"GPL\");\n\nstatic int b44_debug = -1;\t \nmodule_param(b44_debug, int, 0);\nMODULE_PARM_DESC(b44_debug, \"B44 bitmapped debugging message enable value\");\n\n\n#ifdef CONFIG_B44_PCI\nstatic const struct pci_device_id b44_pci_tbl[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, PCI_DEVICE_ID_BCM4401) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, PCI_DEVICE_ID_BCM4401B0) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, PCI_DEVICE_ID_BCM4401B1) },\n\t{ 0 }  \n};\nMODULE_DEVICE_TABLE(pci, b44_pci_tbl);\n\nstatic struct pci_driver b44_pci_driver = {\n\t.name\t\t= DRV_MODULE_NAME,\n\t.id_table\t= b44_pci_tbl,\n};\n#endif  \n\nstatic const struct ssb_device_id b44_ssb_tbl[] = {\n\tSSB_DEVICE(SSB_VENDOR_BROADCOM, SSB_DEV_ETHERNET, SSB_ANY_REV),\n\t{},\n};\nMODULE_DEVICE_TABLE(ssb, b44_ssb_tbl);\n\nstatic void b44_halt(struct b44 *);\nstatic void b44_init_rings(struct b44 *);\n\n#define B44_FULL_RESET\t\t1\n#define B44_FULL_RESET_SKIP_PHY\t2\n#define B44_PARTIAL_RESET\t3\n#define B44_CHIP_RESET_FULL\t4\n#define B44_CHIP_RESET_PARTIAL\t5\n\nstatic void b44_init_hw(struct b44 *, int);\n\nstatic int dma_desc_sync_size;\nstatic int instance;\n\nstatic const char b44_gstrings[][ETH_GSTRING_LEN] = {\n#define _B44(x...)\t# x,\nB44_STAT_REG_DECLARE\n#undef _B44\n};\n\nstatic inline void b44_sync_dma_desc_for_device(struct ssb_device *sdev,\n\t\t\t\t\t\tdma_addr_t dma_base,\n\t\t\t\t\t\tunsigned long offset,\n\t\t\t\t\t\tenum dma_data_direction dir)\n{\n\tdma_sync_single_for_device(sdev->dma_dev, dma_base + offset,\n\t\t\t\t   dma_desc_sync_size, dir);\n}\n\nstatic inline void b44_sync_dma_desc_for_cpu(struct ssb_device *sdev,\n\t\t\t\t\t     dma_addr_t dma_base,\n\t\t\t\t\t     unsigned long offset,\n\t\t\t\t\t     enum dma_data_direction dir)\n{\n\tdma_sync_single_for_cpu(sdev->dma_dev, dma_base + offset,\n\t\t\t\tdma_desc_sync_size, dir);\n}\n\nstatic inline unsigned long br32(const struct b44 *bp, unsigned long reg)\n{\n\treturn ssb_read32(bp->sdev, reg);\n}\n\nstatic inline void bw32(const struct b44 *bp,\n\t\t\tunsigned long reg, unsigned long val)\n{\n\tssb_write32(bp->sdev, reg, val);\n}\n\nstatic int b44_wait_bit(struct b44 *bp, unsigned long reg,\n\t\t\tu32 bit, unsigned long timeout, const int clear)\n{\n\tunsigned long i;\n\n\tfor (i = 0; i < timeout; i++) {\n\t\tu32 val = br32(bp, reg);\n\n\t\tif (clear && !(val & bit))\n\t\t\tbreak;\n\t\tif (!clear && (val & bit))\n\t\t\tbreak;\n\t\tudelay(10);\n\t}\n\tif (i == timeout) {\n\t\tif (net_ratelimit())\n\t\t\tnetdev_err(bp->dev, \"BUG!  Timeout waiting for bit %08x of register %lx to %s\\n\",\n\t\t\t\t   bit, reg, clear ? \"clear\" : \"set\");\n\n\t\treturn -ENODEV;\n\t}\n\treturn 0;\n}\n\nstatic inline void __b44_cam_write(struct b44 *bp,\n\t\t\t\t   const unsigned char *data, int index)\n{\n\tu32 val;\n\n\tval  = ((u32) data[2]) << 24;\n\tval |= ((u32) data[3]) << 16;\n\tval |= ((u32) data[4]) <<  8;\n\tval |= ((u32) data[5]) <<  0;\n\tbw32(bp, B44_CAM_DATA_LO, val);\n\tval = (CAM_DATA_HI_VALID |\n\t       (((u32) data[0]) << 8) |\n\t       (((u32) data[1]) << 0));\n\tbw32(bp, B44_CAM_DATA_HI, val);\n\tbw32(bp, B44_CAM_CTRL, (CAM_CTRL_WRITE |\n\t\t\t    (index << CAM_CTRL_INDEX_SHIFT)));\n\tb44_wait_bit(bp, B44_CAM_CTRL, CAM_CTRL_BUSY, 100, 1);\n}\n\nstatic inline void __b44_disable_ints(struct b44 *bp)\n{\n\tbw32(bp, B44_IMASK, 0);\n}\n\nstatic void b44_disable_ints(struct b44 *bp)\n{\n\t__b44_disable_ints(bp);\n\n\t \n\tbr32(bp, B44_IMASK);\n}\n\nstatic void b44_enable_ints(struct b44 *bp)\n{\n\tbw32(bp, B44_IMASK, bp->imask);\n}\n\nstatic int __b44_readphy(struct b44 *bp, int phy_addr, int reg, u32 *val)\n{\n\tint err;\n\n\tbw32(bp, B44_EMAC_ISTAT, EMAC_INT_MII);\n\tbw32(bp, B44_MDIO_DATA, (MDIO_DATA_SB_START |\n\t\t\t     (MDIO_OP_READ << MDIO_DATA_OP_SHIFT) |\n\t\t\t     (phy_addr << MDIO_DATA_PMD_SHIFT) |\n\t\t\t     (reg << MDIO_DATA_RA_SHIFT) |\n\t\t\t     (MDIO_TA_VALID << MDIO_DATA_TA_SHIFT)));\n\terr = b44_wait_bit(bp, B44_EMAC_ISTAT, EMAC_INT_MII, 100, 0);\n\t*val = br32(bp, B44_MDIO_DATA) & MDIO_DATA_DATA;\n\n\treturn err;\n}\n\nstatic int __b44_writephy(struct b44 *bp, int phy_addr, int reg, u32 val)\n{\n\tbw32(bp, B44_EMAC_ISTAT, EMAC_INT_MII);\n\tbw32(bp, B44_MDIO_DATA, (MDIO_DATA_SB_START |\n\t\t\t     (MDIO_OP_WRITE << MDIO_DATA_OP_SHIFT) |\n\t\t\t     (phy_addr << MDIO_DATA_PMD_SHIFT) |\n\t\t\t     (reg << MDIO_DATA_RA_SHIFT) |\n\t\t\t     (MDIO_TA_VALID << MDIO_DATA_TA_SHIFT) |\n\t\t\t     (val & MDIO_DATA_DATA)));\n\treturn b44_wait_bit(bp, B44_EMAC_ISTAT, EMAC_INT_MII, 100, 0);\n}\n\nstatic inline int b44_readphy(struct b44 *bp, int reg, u32 *val)\n{\n\tif (bp->flags & B44_FLAG_EXTERNAL_PHY)\n\t\treturn 0;\n\n\treturn __b44_readphy(bp, bp->phy_addr, reg, val);\n}\n\nstatic inline int b44_writephy(struct b44 *bp, int reg, u32 val)\n{\n\tif (bp->flags & B44_FLAG_EXTERNAL_PHY)\n\t\treturn 0;\n\n\treturn __b44_writephy(bp, bp->phy_addr, reg, val);\n}\n\n \nstatic int b44_mdio_read_mii(struct net_device *dev, int phy_id, int location)\n{\n\tu32 val;\n\tstruct b44 *bp = netdev_priv(dev);\n\tint rc = __b44_readphy(bp, phy_id, location, &val);\n\tif (rc)\n\t\treturn 0xffffffff;\n\treturn val;\n}\n\nstatic void b44_mdio_write_mii(struct net_device *dev, int phy_id, int location,\n\t\t\t       int val)\n{\n\tstruct b44 *bp = netdev_priv(dev);\n\t__b44_writephy(bp, phy_id, location, val);\n}\n\nstatic int b44_mdio_read_phylib(struct mii_bus *bus, int phy_id, int location)\n{\n\tu32 val;\n\tstruct b44 *bp = bus->priv;\n\tint rc = __b44_readphy(bp, phy_id, location, &val);\n\tif (rc)\n\t\treturn 0xffffffff;\n\treturn val;\n}\n\nstatic int b44_mdio_write_phylib(struct mii_bus *bus, int phy_id, int location,\n\t\t\t\t u16 val)\n{\n\tstruct b44 *bp = bus->priv;\n\treturn __b44_writephy(bp, phy_id, location, val);\n}\n\nstatic int b44_phy_reset(struct b44 *bp)\n{\n\tu32 val;\n\tint err;\n\n\tif (bp->flags & B44_FLAG_EXTERNAL_PHY)\n\t\treturn 0;\n\terr = b44_writephy(bp, MII_BMCR, BMCR_RESET);\n\tif (err)\n\t\treturn err;\n\tudelay(100);\n\terr = b44_readphy(bp, MII_BMCR, &val);\n\tif (!err) {\n\t\tif (val & BMCR_RESET) {\n\t\t\tnetdev_err(bp->dev, \"PHY Reset would not complete\\n\");\n\t\t\terr = -ENODEV;\n\t\t}\n\t}\n\n\treturn err;\n}\n\nstatic void __b44_set_flow_ctrl(struct b44 *bp, u32 pause_flags)\n{\n\tu32 val;\n\n\tbp->flags &= ~(B44_FLAG_TX_PAUSE | B44_FLAG_RX_PAUSE);\n\tbp->flags |= pause_flags;\n\n\tval = br32(bp, B44_RXCONFIG);\n\tif (pause_flags & B44_FLAG_RX_PAUSE)\n\t\tval |= RXCONFIG_FLOW;\n\telse\n\t\tval &= ~RXCONFIG_FLOW;\n\tbw32(bp, B44_RXCONFIG, val);\n\n\tval = br32(bp, B44_MAC_FLOW);\n\tif (pause_flags & B44_FLAG_TX_PAUSE)\n\t\tval |= (MAC_FLOW_PAUSE_ENAB |\n\t\t\t(0xc0 & MAC_FLOW_RX_HI_WATER));\n\telse\n\t\tval &= ~MAC_FLOW_PAUSE_ENAB;\n\tbw32(bp, B44_MAC_FLOW, val);\n}\n\nstatic void b44_set_flow_ctrl(struct b44 *bp, u32 local, u32 remote)\n{\n\tu32 pause_enab = 0;\n\n\t \n\tif ((local & ADVERTISE_PAUSE_CAP) &&\n\t    (local & ADVERTISE_PAUSE_ASYM)){\n\t\tif ((remote & LPA_PAUSE_ASYM) &&\n\t\t    !(remote & LPA_PAUSE_CAP))\n\t\t\tpause_enab |= B44_FLAG_RX_PAUSE;\n\t}\n\n\t__b44_set_flow_ctrl(bp, pause_enab);\n}\n\n#ifdef CONFIG_BCM47XX\n#include <linux/bcm47xx_nvram.h>\nstatic void b44_wap54g10_workaround(struct b44 *bp)\n{\n\tchar buf[20];\n\tu32 val;\n\tint err;\n\n\t \n\tif (bcm47xx_nvram_getenv(\"boardnum\", buf, sizeof(buf)) < 0)\n\t\treturn;\n\tif (simple_strtoul(buf, NULL, 0) == 2) {\n\t\terr = __b44_readphy(bp, 0, MII_BMCR, &val);\n\t\tif (err)\n\t\t\tgoto error;\n\t\tif (!(val & BMCR_ISOLATE))\n\t\t\treturn;\n\t\tval &= ~BMCR_ISOLATE;\n\t\terr = __b44_writephy(bp, 0, MII_BMCR, val);\n\t\tif (err)\n\t\t\tgoto error;\n\t}\n\treturn;\nerror:\n\tpr_warn(\"PHY: cannot reset MII transceiver isolate bit\\n\");\n}\n#else\nstatic inline void b44_wap54g10_workaround(struct b44 *bp)\n{\n}\n#endif\n\nstatic int b44_setup_phy(struct b44 *bp)\n{\n\tu32 val;\n\tint err;\n\n\tb44_wap54g10_workaround(bp);\n\n\tif (bp->flags & B44_FLAG_EXTERNAL_PHY)\n\t\treturn 0;\n\tif ((err = b44_readphy(bp, B44_MII_ALEDCTRL, &val)) != 0)\n\t\tgoto out;\n\tif ((err = b44_writephy(bp, B44_MII_ALEDCTRL,\n\t\t\t\tval & MII_ALEDCTRL_ALLMSK)) != 0)\n\t\tgoto out;\n\tif ((err = b44_readphy(bp, B44_MII_TLEDCTRL, &val)) != 0)\n\t\tgoto out;\n\tif ((err = b44_writephy(bp, B44_MII_TLEDCTRL,\n\t\t\t\tval | MII_TLEDCTRL_ENABLE)) != 0)\n\t\tgoto out;\n\n\tif (!(bp->flags & B44_FLAG_FORCE_LINK)) {\n\t\tu32 adv = ADVERTISE_CSMA;\n\n\t\tif (bp->flags & B44_FLAG_ADV_10HALF)\n\t\t\tadv |= ADVERTISE_10HALF;\n\t\tif (bp->flags & B44_FLAG_ADV_10FULL)\n\t\t\tadv |= ADVERTISE_10FULL;\n\t\tif (bp->flags & B44_FLAG_ADV_100HALF)\n\t\t\tadv |= ADVERTISE_100HALF;\n\t\tif (bp->flags & B44_FLAG_ADV_100FULL)\n\t\t\tadv |= ADVERTISE_100FULL;\n\n\t\tif (bp->flags & B44_FLAG_PAUSE_AUTO)\n\t\t\tadv |= ADVERTISE_PAUSE_CAP | ADVERTISE_PAUSE_ASYM;\n\n\t\tif ((err = b44_writephy(bp, MII_ADVERTISE, adv)) != 0)\n\t\t\tgoto out;\n\t\tif ((err = b44_writephy(bp, MII_BMCR, (BMCR_ANENABLE |\n\t\t\t\t\t\t       BMCR_ANRESTART))) != 0)\n\t\t\tgoto out;\n\t} else {\n\t\tu32 bmcr;\n\n\t\tif ((err = b44_readphy(bp, MII_BMCR, &bmcr)) != 0)\n\t\t\tgoto out;\n\t\tbmcr &= ~(BMCR_FULLDPLX | BMCR_ANENABLE | BMCR_SPEED100);\n\t\tif (bp->flags & B44_FLAG_100_BASE_T)\n\t\t\tbmcr |= BMCR_SPEED100;\n\t\tif (bp->flags & B44_FLAG_FULL_DUPLEX)\n\t\t\tbmcr |= BMCR_FULLDPLX;\n\t\tif ((err = b44_writephy(bp, MII_BMCR, bmcr)) != 0)\n\t\t\tgoto out;\n\n\t\t \n\t\tb44_set_flow_ctrl(bp, 0, 0);\n\t}\n\nout:\n\treturn err;\n}\n\nstatic void b44_stats_update(struct b44 *bp)\n{\n\tunsigned long reg;\n\tu64 *val;\n\n\tval = &bp->hw_stats.tx_good_octets;\n\tu64_stats_update_begin(&bp->hw_stats.syncp);\n\n\tfor (reg = B44_TX_GOOD_O; reg <= B44_TX_PAUSE; reg += 4UL) {\n\t\t*val++ += br32(bp, reg);\n\t}\n\n\tfor (reg = B44_RX_GOOD_O; reg <= B44_RX_NPAUSE; reg += 4UL) {\n\t\t*val++ += br32(bp, reg);\n\t}\n\n\tu64_stats_update_end(&bp->hw_stats.syncp);\n}\n\nstatic void b44_link_report(struct b44 *bp)\n{\n\tif (!netif_carrier_ok(bp->dev)) {\n\t\tnetdev_info(bp->dev, \"Link is down\\n\");\n\t} else {\n\t\tnetdev_info(bp->dev, \"Link is up at %d Mbps, %s duplex\\n\",\n\t\t\t    (bp->flags & B44_FLAG_100_BASE_T) ? 100 : 10,\n\t\t\t    (bp->flags & B44_FLAG_FULL_DUPLEX) ? \"full\" : \"half\");\n\n\t\tnetdev_info(bp->dev, \"Flow control is %s for TX and %s for RX\\n\",\n\t\t\t    (bp->flags & B44_FLAG_TX_PAUSE) ? \"on\" : \"off\",\n\t\t\t    (bp->flags & B44_FLAG_RX_PAUSE) ? \"on\" : \"off\");\n\t}\n}\n\nstatic void b44_check_phy(struct b44 *bp)\n{\n\tu32 bmsr, aux;\n\n\tif (bp->flags & B44_FLAG_EXTERNAL_PHY) {\n\t\tbp->flags |= B44_FLAG_100_BASE_T;\n\t\tif (!netif_carrier_ok(bp->dev)) {\n\t\t\tu32 val = br32(bp, B44_TX_CTRL);\n\t\t\tif (bp->flags & B44_FLAG_FULL_DUPLEX)\n\t\t\t\tval |= TX_CTRL_DUPLEX;\n\t\t\telse\n\t\t\t\tval &= ~TX_CTRL_DUPLEX;\n\t\t\tbw32(bp, B44_TX_CTRL, val);\n\t\t\tnetif_carrier_on(bp->dev);\n\t\t\tb44_link_report(bp);\n\t\t}\n\t\treturn;\n\t}\n\n\tif (!b44_readphy(bp, MII_BMSR, &bmsr) &&\n\t    !b44_readphy(bp, B44_MII_AUXCTRL, &aux) &&\n\t    (bmsr != 0xffff)) {\n\t\tif (aux & MII_AUXCTRL_SPEED)\n\t\t\tbp->flags |= B44_FLAG_100_BASE_T;\n\t\telse\n\t\t\tbp->flags &= ~B44_FLAG_100_BASE_T;\n\t\tif (aux & MII_AUXCTRL_DUPLEX)\n\t\t\tbp->flags |= B44_FLAG_FULL_DUPLEX;\n\t\telse\n\t\t\tbp->flags &= ~B44_FLAG_FULL_DUPLEX;\n\n\t\tif (!netif_carrier_ok(bp->dev) &&\n\t\t    (bmsr & BMSR_LSTATUS)) {\n\t\t\tu32 val = br32(bp, B44_TX_CTRL);\n\t\t\tu32 local_adv, remote_adv;\n\n\t\t\tif (bp->flags & B44_FLAG_FULL_DUPLEX)\n\t\t\t\tval |= TX_CTRL_DUPLEX;\n\t\t\telse\n\t\t\t\tval &= ~TX_CTRL_DUPLEX;\n\t\t\tbw32(bp, B44_TX_CTRL, val);\n\n\t\t\tif (!(bp->flags & B44_FLAG_FORCE_LINK) &&\n\t\t\t    !b44_readphy(bp, MII_ADVERTISE, &local_adv) &&\n\t\t\t    !b44_readphy(bp, MII_LPA, &remote_adv))\n\t\t\t\tb44_set_flow_ctrl(bp, local_adv, remote_adv);\n\n\t\t\t \n\t\t\tnetif_carrier_on(bp->dev);\n\t\t\tb44_link_report(bp);\n\t\t} else if (netif_carrier_ok(bp->dev) && !(bmsr & BMSR_LSTATUS)) {\n\t\t\t \n\t\t\tnetif_carrier_off(bp->dev);\n\t\t\tb44_link_report(bp);\n\t\t}\n\n\t\tif (bmsr & BMSR_RFAULT)\n\t\t\tnetdev_warn(bp->dev, \"Remote fault detected in PHY\\n\");\n\t\tif (bmsr & BMSR_JCD)\n\t\t\tnetdev_warn(bp->dev, \"Jabber detected in PHY\\n\");\n\t}\n}\n\nstatic void b44_timer(struct timer_list *t)\n{\n\tstruct b44 *bp = from_timer(bp, t, timer);\n\n\tspin_lock_irq(&bp->lock);\n\n\tb44_check_phy(bp);\n\n\tb44_stats_update(bp);\n\n\tspin_unlock_irq(&bp->lock);\n\n\tmod_timer(&bp->timer, round_jiffies(jiffies + HZ));\n}\n\nstatic void b44_tx(struct b44 *bp)\n{\n\tu32 cur, cons;\n\tunsigned bytes_compl = 0, pkts_compl = 0;\n\n\tcur  = br32(bp, B44_DMATX_STAT) & DMATX_STAT_CDMASK;\n\tcur /= sizeof(struct dma_desc);\n\n\t \n\tfor (cons = bp->tx_cons; cons != cur; cons = NEXT_TX(cons)) {\n\t\tstruct ring_info *rp = &bp->tx_buffers[cons];\n\t\tstruct sk_buff *skb = rp->skb;\n\n\t\tBUG_ON(skb == NULL);\n\n\t\tdma_unmap_single(bp->sdev->dma_dev,\n\t\t\t\t rp->mapping,\n\t\t\t\t skb->len,\n\t\t\t\t DMA_TO_DEVICE);\n\t\trp->skb = NULL;\n\n\t\tbytes_compl += skb->len;\n\t\tpkts_compl++;\n\n\t\tdev_consume_skb_irq(skb);\n\t}\n\n\tnetdev_completed_queue(bp->dev, pkts_compl, bytes_compl);\n\tbp->tx_cons = cons;\n\tif (netif_queue_stopped(bp->dev) &&\n\t    TX_BUFFS_AVAIL(bp) > B44_TX_WAKEUP_THRESH)\n\t\tnetif_wake_queue(bp->dev);\n\n\tbw32(bp, B44_GPTIMER, 0);\n}\n\n \nstatic int b44_alloc_rx_skb(struct b44 *bp, int src_idx, u32 dest_idx_unmasked)\n{\n\tstruct dma_desc *dp;\n\tstruct ring_info *src_map, *map;\n\tstruct rx_header *rh;\n\tstruct sk_buff *skb;\n\tdma_addr_t mapping;\n\tint dest_idx;\n\tu32 ctrl;\n\n\tsrc_map = NULL;\n\tif (src_idx >= 0)\n\t\tsrc_map = &bp->rx_buffers[src_idx];\n\tdest_idx = dest_idx_unmasked & (B44_RX_RING_SIZE - 1);\n\tmap = &bp->rx_buffers[dest_idx];\n\tskb = netdev_alloc_skb(bp->dev, RX_PKT_BUF_SZ);\n\tif (skb == NULL)\n\t\treturn -ENOMEM;\n\n\tmapping = dma_map_single(bp->sdev->dma_dev, skb->data,\n\t\t\t\t RX_PKT_BUF_SZ,\n\t\t\t\t DMA_FROM_DEVICE);\n\n\t \n\tif (dma_mapping_error(bp->sdev->dma_dev, mapping) ||\n\t\tmapping + RX_PKT_BUF_SZ > DMA_BIT_MASK(30)) {\n\t\t \n\t\tif (!dma_mapping_error(bp->sdev->dma_dev, mapping))\n\t\t\tdma_unmap_single(bp->sdev->dma_dev, mapping,\n\t\t\t\t\t     RX_PKT_BUF_SZ, DMA_FROM_DEVICE);\n\t\tdev_kfree_skb_any(skb);\n\t\tskb = alloc_skb(RX_PKT_BUF_SZ, GFP_ATOMIC | GFP_DMA);\n\t\tif (skb == NULL)\n\t\t\treturn -ENOMEM;\n\t\tmapping = dma_map_single(bp->sdev->dma_dev, skb->data,\n\t\t\t\t\t RX_PKT_BUF_SZ,\n\t\t\t\t\t DMA_FROM_DEVICE);\n\t\tif (dma_mapping_error(bp->sdev->dma_dev, mapping) ||\n\t\t    mapping + RX_PKT_BUF_SZ > DMA_BIT_MASK(30)) {\n\t\t\tif (!dma_mapping_error(bp->sdev->dma_dev, mapping))\n\t\t\t\tdma_unmap_single(bp->sdev->dma_dev, mapping, RX_PKT_BUF_SZ,DMA_FROM_DEVICE);\n\t\t\tdev_kfree_skb_any(skb);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tbp->force_copybreak = 1;\n\t}\n\n\trh = (struct rx_header *) skb->data;\n\n\trh->len = 0;\n\trh->flags = 0;\n\n\tmap->skb = skb;\n\tmap->mapping = mapping;\n\n\tif (src_map != NULL)\n\t\tsrc_map->skb = NULL;\n\n\tctrl = (DESC_CTRL_LEN & RX_PKT_BUF_SZ);\n\tif (dest_idx == (B44_RX_RING_SIZE - 1))\n\t\tctrl |= DESC_CTRL_EOT;\n\n\tdp = &bp->rx_ring[dest_idx];\n\tdp->ctrl = cpu_to_le32(ctrl);\n\tdp->addr = cpu_to_le32((u32) mapping + bp->dma_offset);\n\n\tif (bp->flags & B44_FLAG_RX_RING_HACK)\n\t\tb44_sync_dma_desc_for_device(bp->sdev, bp->rx_ring_dma,\n\t\t\t                    dest_idx * sizeof(*dp),\n\t\t\t                    DMA_BIDIRECTIONAL);\n\n\treturn RX_PKT_BUF_SZ;\n}\n\nstatic void b44_recycle_rx(struct b44 *bp, int src_idx, u32 dest_idx_unmasked)\n{\n\tstruct dma_desc *src_desc, *dest_desc;\n\tstruct ring_info *src_map, *dest_map;\n\tstruct rx_header *rh;\n\tint dest_idx;\n\t__le32 ctrl;\n\n\tdest_idx = dest_idx_unmasked & (B44_RX_RING_SIZE - 1);\n\tdest_desc = &bp->rx_ring[dest_idx];\n\tdest_map = &bp->rx_buffers[dest_idx];\n\tsrc_desc = &bp->rx_ring[src_idx];\n\tsrc_map = &bp->rx_buffers[src_idx];\n\n\tdest_map->skb = src_map->skb;\n\trh = (struct rx_header *) src_map->skb->data;\n\trh->len = 0;\n\trh->flags = 0;\n\tdest_map->mapping = src_map->mapping;\n\n\tif (bp->flags & B44_FLAG_RX_RING_HACK)\n\t\tb44_sync_dma_desc_for_cpu(bp->sdev, bp->rx_ring_dma,\n\t\t\t                 src_idx * sizeof(*src_desc),\n\t\t\t                 DMA_BIDIRECTIONAL);\n\n\tctrl = src_desc->ctrl;\n\tif (dest_idx == (B44_RX_RING_SIZE - 1))\n\t\tctrl |= cpu_to_le32(DESC_CTRL_EOT);\n\telse\n\t\tctrl &= cpu_to_le32(~DESC_CTRL_EOT);\n\n\tdest_desc->ctrl = ctrl;\n\tdest_desc->addr = src_desc->addr;\n\n\tsrc_map->skb = NULL;\n\n\tif (bp->flags & B44_FLAG_RX_RING_HACK)\n\t\tb44_sync_dma_desc_for_device(bp->sdev, bp->rx_ring_dma,\n\t\t\t\t\t     dest_idx * sizeof(*dest_desc),\n\t\t\t\t\t     DMA_BIDIRECTIONAL);\n\n\tdma_sync_single_for_device(bp->sdev->dma_dev, dest_map->mapping,\n\t\t\t\t   RX_PKT_BUF_SZ,\n\t\t\t\t   DMA_FROM_DEVICE);\n}\n\nstatic int b44_rx(struct b44 *bp, int budget)\n{\n\tint received;\n\tu32 cons, prod;\n\n\treceived = 0;\n\tprod  = br32(bp, B44_DMARX_STAT) & DMARX_STAT_CDMASK;\n\tprod /= sizeof(struct dma_desc);\n\tcons = bp->rx_cons;\n\n\twhile (cons != prod && budget > 0) {\n\t\tstruct ring_info *rp = &bp->rx_buffers[cons];\n\t\tstruct sk_buff *skb = rp->skb;\n\t\tdma_addr_t map = rp->mapping;\n\t\tstruct rx_header *rh;\n\t\tu16 len;\n\n\t\tdma_sync_single_for_cpu(bp->sdev->dma_dev, map,\n\t\t\t\t\tRX_PKT_BUF_SZ,\n\t\t\t\t\tDMA_FROM_DEVICE);\n\t\trh = (struct rx_header *) skb->data;\n\t\tlen = le16_to_cpu(rh->len);\n\t\tif ((len > (RX_PKT_BUF_SZ - RX_PKT_OFFSET)) ||\n\t\t    (rh->flags & cpu_to_le16(RX_FLAG_ERRORS))) {\n\t\tdrop_it:\n\t\t\tb44_recycle_rx(bp, cons, bp->rx_prod);\n\t\tdrop_it_no_recycle:\n\t\t\tbp->dev->stats.rx_dropped++;\n\t\t\tgoto next_pkt;\n\t\t}\n\n\t\tif (len == 0) {\n\t\t\tint i = 0;\n\n\t\t\tdo {\n\t\t\t\tudelay(2);\n\t\t\t\tbarrier();\n\t\t\t\tlen = le16_to_cpu(rh->len);\n\t\t\t} while (len == 0 && i++ < 5);\n\t\t\tif (len == 0)\n\t\t\t\tgoto drop_it;\n\t\t}\n\n\t\t \n\t\tlen -= 4;\n\n\t\tif (!bp->force_copybreak && len > RX_COPY_THRESHOLD) {\n\t\t\tint skb_size;\n\t\t\tskb_size = b44_alloc_rx_skb(bp, cons, bp->rx_prod);\n\t\t\tif (skb_size < 0)\n\t\t\t\tgoto drop_it;\n\t\t\tdma_unmap_single(bp->sdev->dma_dev, map,\n\t\t\t\t\t skb_size, DMA_FROM_DEVICE);\n\t\t\t \n\t\t\tskb_put(skb, len + RX_PKT_OFFSET);\n\t\t\tskb_pull(skb, RX_PKT_OFFSET);\n\t\t} else {\n\t\t\tstruct sk_buff *copy_skb;\n\n\t\t\tb44_recycle_rx(bp, cons, bp->rx_prod);\n\t\t\tcopy_skb = napi_alloc_skb(&bp->napi, len);\n\t\t\tif (copy_skb == NULL)\n\t\t\t\tgoto drop_it_no_recycle;\n\n\t\t\tskb_put(copy_skb, len);\n\t\t\t \n\t\t\tskb_copy_from_linear_data_offset(skb, RX_PKT_OFFSET,\n\t\t\t\t\t\t\t copy_skb->data, len);\n\t\t\tskb = copy_skb;\n\t\t}\n\t\tskb_checksum_none_assert(skb);\n\t\tskb->protocol = eth_type_trans(skb, bp->dev);\n\t\tnetif_receive_skb(skb);\n\t\treceived++;\n\t\tbudget--;\n\tnext_pkt:\n\t\tbp->rx_prod = (bp->rx_prod + 1) &\n\t\t\t(B44_RX_RING_SIZE - 1);\n\t\tcons = (cons + 1) & (B44_RX_RING_SIZE - 1);\n\t}\n\n\tbp->rx_cons = cons;\n\tbw32(bp, B44_DMARX_PTR, cons * sizeof(struct dma_desc));\n\n\treturn received;\n}\n\nstatic int b44_poll(struct napi_struct *napi, int budget)\n{\n\tstruct b44 *bp = container_of(napi, struct b44, napi);\n\tint work_done;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&bp->lock, flags);\n\n\tif (bp->istat & (ISTAT_TX | ISTAT_TO)) {\n\t\t \n\t\tb44_tx(bp);\n\t\t \n\t}\n\tif (bp->istat & ISTAT_RFO) {\t \n\t\tbp->istat &= ~ISTAT_RFO;\n\t\tb44_disable_ints(bp);\n\t\tssb_device_enable(bp->sdev, 0);  \n\t\tb44_init_rings(bp);\n\t\tb44_init_hw(bp, B44_FULL_RESET_SKIP_PHY);\n\t\tnetif_wake_queue(bp->dev);\n\t}\n\n\tspin_unlock_irqrestore(&bp->lock, flags);\n\n\twork_done = 0;\n\tif (bp->istat & ISTAT_RX)\n\t\twork_done += b44_rx(bp, budget);\n\n\tif (bp->istat & ISTAT_ERRORS) {\n\t\tspin_lock_irqsave(&bp->lock, flags);\n\t\tb44_halt(bp);\n\t\tb44_init_rings(bp);\n\t\tb44_init_hw(bp, B44_FULL_RESET_SKIP_PHY);\n\t\tnetif_wake_queue(bp->dev);\n\t\tspin_unlock_irqrestore(&bp->lock, flags);\n\t\twork_done = 0;\n\t}\n\n\tif (work_done < budget) {\n\t\tnapi_complete_done(napi, work_done);\n\t\tb44_enable_ints(bp);\n\t}\n\n\treturn work_done;\n}\n\nstatic irqreturn_t b44_interrupt(int irq, void *dev_id)\n{\n\tstruct net_device *dev = dev_id;\n\tstruct b44 *bp = netdev_priv(dev);\n\tu32 istat, imask;\n\tint handled = 0;\n\n\tspin_lock(&bp->lock);\n\n\tistat = br32(bp, B44_ISTAT);\n\timask = br32(bp, B44_IMASK);\n\n\t \n\tistat &= imask;\n\tif (istat) {\n\t\thandled = 1;\n\n\t\tif (unlikely(!netif_running(dev))) {\n\t\t\tnetdev_info(dev, \"late interrupt\\n\");\n\t\t\tgoto irq_ack;\n\t\t}\n\n\t\tif (napi_schedule_prep(&bp->napi)) {\n\t\t\t \n\t\t\tbp->istat = istat;\n\t\t\t__b44_disable_ints(bp);\n\t\t\t__napi_schedule(&bp->napi);\n\t\t}\n\nirq_ack:\n\t\tbw32(bp, B44_ISTAT, istat);\n\t\tbr32(bp, B44_ISTAT);\n\t}\n\tspin_unlock(&bp->lock);\n\treturn IRQ_RETVAL(handled);\n}\n\nstatic void b44_tx_timeout(struct net_device *dev, unsigned int txqueue)\n{\n\tstruct b44 *bp = netdev_priv(dev);\n\n\tnetdev_err(dev, \"transmit timed out, resetting\\n\");\n\n\tspin_lock_irq(&bp->lock);\n\n\tb44_halt(bp);\n\tb44_init_rings(bp);\n\tb44_init_hw(bp, B44_FULL_RESET);\n\n\tspin_unlock_irq(&bp->lock);\n\n\tb44_enable_ints(bp);\n\n\tnetif_wake_queue(dev);\n}\n\nstatic netdev_tx_t b44_start_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct b44 *bp = netdev_priv(dev);\n\tint rc = NETDEV_TX_OK;\n\tdma_addr_t mapping;\n\tu32 len, entry, ctrl;\n\tunsigned long flags;\n\n\tlen = skb->len;\n\tspin_lock_irqsave(&bp->lock, flags);\n\n\t \n\tif (unlikely(TX_BUFFS_AVAIL(bp) < 1)) {\n\t\tnetif_stop_queue(dev);\n\t\tnetdev_err(dev, \"BUG! Tx Ring full when queue awake!\\n\");\n\t\tgoto err_out;\n\t}\n\n\tmapping = dma_map_single(bp->sdev->dma_dev, skb->data, len, DMA_TO_DEVICE);\n\tif (dma_mapping_error(bp->sdev->dma_dev, mapping) || mapping + len > DMA_BIT_MASK(30)) {\n\t\tstruct sk_buff *bounce_skb;\n\n\t\t \n\t\tif (!dma_mapping_error(bp->sdev->dma_dev, mapping))\n\t\t\tdma_unmap_single(bp->sdev->dma_dev, mapping, len,\n\t\t\t\t\t     DMA_TO_DEVICE);\n\n\t\tbounce_skb = alloc_skb(len, GFP_ATOMIC | GFP_DMA);\n\t\tif (!bounce_skb)\n\t\t\tgoto err_out;\n\n\t\tmapping = dma_map_single(bp->sdev->dma_dev, bounce_skb->data,\n\t\t\t\t\t len, DMA_TO_DEVICE);\n\t\tif (dma_mapping_error(bp->sdev->dma_dev, mapping) || mapping + len > DMA_BIT_MASK(30)) {\n\t\t\tif (!dma_mapping_error(bp->sdev->dma_dev, mapping))\n\t\t\t\tdma_unmap_single(bp->sdev->dma_dev, mapping,\n\t\t\t\t\t\t     len, DMA_TO_DEVICE);\n\t\t\tdev_kfree_skb_any(bounce_skb);\n\t\t\tgoto err_out;\n\t\t}\n\n\t\tskb_copy_from_linear_data(skb, skb_put(bounce_skb, len), len);\n\t\tdev_consume_skb_any(skb);\n\t\tskb = bounce_skb;\n\t}\n\n\tentry = bp->tx_prod;\n\tbp->tx_buffers[entry].skb = skb;\n\tbp->tx_buffers[entry].mapping = mapping;\n\n\tctrl  = (len & DESC_CTRL_LEN);\n\tctrl |= DESC_CTRL_IOC | DESC_CTRL_SOF | DESC_CTRL_EOF;\n\tif (entry == (B44_TX_RING_SIZE - 1))\n\t\tctrl |= DESC_CTRL_EOT;\n\n\tbp->tx_ring[entry].ctrl = cpu_to_le32(ctrl);\n\tbp->tx_ring[entry].addr = cpu_to_le32((u32) mapping+bp->dma_offset);\n\n\tif (bp->flags & B44_FLAG_TX_RING_HACK)\n\t\tb44_sync_dma_desc_for_device(bp->sdev, bp->tx_ring_dma,\n\t\t\t                    entry * sizeof(bp->tx_ring[0]),\n\t\t\t                    DMA_TO_DEVICE);\n\n\tentry = NEXT_TX(entry);\n\n\tbp->tx_prod = entry;\n\n\twmb();\n\n\tbw32(bp, B44_DMATX_PTR, entry * sizeof(struct dma_desc));\n\tif (bp->flags & B44_FLAG_BUGGY_TXPTR)\n\t\tbw32(bp, B44_DMATX_PTR, entry * sizeof(struct dma_desc));\n\tif (bp->flags & B44_FLAG_REORDER_BUG)\n\t\tbr32(bp, B44_DMATX_PTR);\n\n\tnetdev_sent_queue(dev, skb->len);\n\n\tif (TX_BUFFS_AVAIL(bp) < 1)\n\t\tnetif_stop_queue(dev);\n\nout_unlock:\n\tspin_unlock_irqrestore(&bp->lock, flags);\n\n\treturn rc;\n\nerr_out:\n\trc = NETDEV_TX_BUSY;\n\tgoto out_unlock;\n}\n\nstatic int b44_change_mtu(struct net_device *dev, int new_mtu)\n{\n\tstruct b44 *bp = netdev_priv(dev);\n\n\tif (!netif_running(dev)) {\n\t\t \n\t\tdev->mtu = new_mtu;\n\t\treturn 0;\n\t}\n\n\tspin_lock_irq(&bp->lock);\n\tb44_halt(bp);\n\tdev->mtu = new_mtu;\n\tb44_init_rings(bp);\n\tb44_init_hw(bp, B44_FULL_RESET);\n\tspin_unlock_irq(&bp->lock);\n\n\tb44_enable_ints(bp);\n\n\treturn 0;\n}\n\n \nstatic void b44_free_rings(struct b44 *bp)\n{\n\tstruct ring_info *rp;\n\tint i;\n\n\tfor (i = 0; i < B44_RX_RING_SIZE; i++) {\n\t\trp = &bp->rx_buffers[i];\n\n\t\tif (rp->skb == NULL)\n\t\t\tcontinue;\n\t\tdma_unmap_single(bp->sdev->dma_dev, rp->mapping, RX_PKT_BUF_SZ,\n\t\t\t\t DMA_FROM_DEVICE);\n\t\tdev_kfree_skb_any(rp->skb);\n\t\trp->skb = NULL;\n\t}\n\n\t \n\tfor (i = 0; i < B44_TX_RING_SIZE; i++) {\n\t\trp = &bp->tx_buffers[i];\n\n\t\tif (rp->skb == NULL)\n\t\t\tcontinue;\n\t\tdma_unmap_single(bp->sdev->dma_dev, rp->mapping, rp->skb->len,\n\t\t\t\t DMA_TO_DEVICE);\n\t\tdev_kfree_skb_any(rp->skb);\n\t\trp->skb = NULL;\n\t}\n}\n\n \nstatic void b44_init_rings(struct b44 *bp)\n{\n\tint i;\n\n\tb44_free_rings(bp);\n\n\tmemset(bp->rx_ring, 0, B44_RX_RING_BYTES);\n\tmemset(bp->tx_ring, 0, B44_TX_RING_BYTES);\n\n\tif (bp->flags & B44_FLAG_RX_RING_HACK)\n\t\tdma_sync_single_for_device(bp->sdev->dma_dev, bp->rx_ring_dma,\n\t\t\t\t\t   DMA_TABLE_BYTES, DMA_BIDIRECTIONAL);\n\n\tif (bp->flags & B44_FLAG_TX_RING_HACK)\n\t\tdma_sync_single_for_device(bp->sdev->dma_dev, bp->tx_ring_dma,\n\t\t\t\t\t   DMA_TABLE_BYTES, DMA_TO_DEVICE);\n\n\tfor (i = 0; i < bp->rx_pending; i++) {\n\t\tif (b44_alloc_rx_skb(bp, -1, i) < 0)\n\t\t\tbreak;\n\t}\n}\n\n \nstatic void b44_free_consistent(struct b44 *bp)\n{\n\tkfree(bp->rx_buffers);\n\tbp->rx_buffers = NULL;\n\tkfree(bp->tx_buffers);\n\tbp->tx_buffers = NULL;\n\tif (bp->rx_ring) {\n\t\tif (bp->flags & B44_FLAG_RX_RING_HACK) {\n\t\t\tdma_unmap_single(bp->sdev->dma_dev, bp->rx_ring_dma,\n\t\t\t\t\t DMA_TABLE_BYTES, DMA_BIDIRECTIONAL);\n\t\t\tkfree(bp->rx_ring);\n\t\t} else\n\t\t\tdma_free_coherent(bp->sdev->dma_dev, DMA_TABLE_BYTES,\n\t\t\t\t\t  bp->rx_ring, bp->rx_ring_dma);\n\t\tbp->rx_ring = NULL;\n\t\tbp->flags &= ~B44_FLAG_RX_RING_HACK;\n\t}\n\tif (bp->tx_ring) {\n\t\tif (bp->flags & B44_FLAG_TX_RING_HACK) {\n\t\t\tdma_unmap_single(bp->sdev->dma_dev, bp->tx_ring_dma,\n\t\t\t\t\t DMA_TABLE_BYTES, DMA_TO_DEVICE);\n\t\t\tkfree(bp->tx_ring);\n\t\t} else\n\t\t\tdma_free_coherent(bp->sdev->dma_dev, DMA_TABLE_BYTES,\n\t\t\t\t\t  bp->tx_ring, bp->tx_ring_dma);\n\t\tbp->tx_ring = NULL;\n\t\tbp->flags &= ~B44_FLAG_TX_RING_HACK;\n\t}\n}\n\n \nstatic int b44_alloc_consistent(struct b44 *bp, gfp_t gfp)\n{\n\tint size;\n\n\tsize  = B44_RX_RING_SIZE * sizeof(struct ring_info);\n\tbp->rx_buffers = kzalloc(size, gfp);\n\tif (!bp->rx_buffers)\n\t\tgoto out_err;\n\n\tsize = B44_TX_RING_SIZE * sizeof(struct ring_info);\n\tbp->tx_buffers = kzalloc(size, gfp);\n\tif (!bp->tx_buffers)\n\t\tgoto out_err;\n\n\tsize = DMA_TABLE_BYTES;\n\tbp->rx_ring = dma_alloc_coherent(bp->sdev->dma_dev, size,\n\t\t\t\t\t &bp->rx_ring_dma, gfp);\n\tif (!bp->rx_ring) {\n\t\t \n\t\tstruct dma_desc *rx_ring;\n\t\tdma_addr_t rx_ring_dma;\n\n\t\trx_ring = kzalloc(size, gfp);\n\t\tif (!rx_ring)\n\t\t\tgoto out_err;\n\n\t\trx_ring_dma = dma_map_single(bp->sdev->dma_dev, rx_ring,\n\t\t\t\t\t     DMA_TABLE_BYTES,\n\t\t\t\t\t     DMA_BIDIRECTIONAL);\n\n\t\tif (dma_mapping_error(bp->sdev->dma_dev, rx_ring_dma) ||\n\t\t\trx_ring_dma + size > DMA_BIT_MASK(30)) {\n\t\t\tkfree(rx_ring);\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tbp->rx_ring = rx_ring;\n\t\tbp->rx_ring_dma = rx_ring_dma;\n\t\tbp->flags |= B44_FLAG_RX_RING_HACK;\n\t}\n\n\tbp->tx_ring = dma_alloc_coherent(bp->sdev->dma_dev, size,\n\t\t\t\t\t &bp->tx_ring_dma, gfp);\n\tif (!bp->tx_ring) {\n\t\t \n\t\tstruct dma_desc *tx_ring;\n\t\tdma_addr_t tx_ring_dma;\n\n\t\ttx_ring = kzalloc(size, gfp);\n\t\tif (!tx_ring)\n\t\t\tgoto out_err;\n\n\t\ttx_ring_dma = dma_map_single(bp->sdev->dma_dev, tx_ring,\n\t\t\t\t\t     DMA_TABLE_BYTES,\n\t\t\t\t\t     DMA_TO_DEVICE);\n\n\t\tif (dma_mapping_error(bp->sdev->dma_dev, tx_ring_dma) ||\n\t\t\ttx_ring_dma + size > DMA_BIT_MASK(30)) {\n\t\t\tkfree(tx_ring);\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tbp->tx_ring = tx_ring;\n\t\tbp->tx_ring_dma = tx_ring_dma;\n\t\tbp->flags |= B44_FLAG_TX_RING_HACK;\n\t}\n\n\treturn 0;\n\nout_err:\n\tb44_free_consistent(bp);\n\treturn -ENOMEM;\n}\n\n \nstatic void b44_clear_stats(struct b44 *bp)\n{\n\tunsigned long reg;\n\n\tbw32(bp, B44_MIB_CTRL, MIB_CTRL_CLR_ON_READ);\n\tfor (reg = B44_TX_GOOD_O; reg <= B44_TX_PAUSE; reg += 4UL)\n\t\tbr32(bp, reg);\n\tfor (reg = B44_RX_GOOD_O; reg <= B44_RX_NPAUSE; reg += 4UL)\n\t\tbr32(bp, reg);\n}\n\n \nstatic void b44_chip_reset(struct b44 *bp, int reset_kind)\n{\n\tstruct ssb_device *sdev = bp->sdev;\n\tbool was_enabled;\n\n\twas_enabled = ssb_device_is_enabled(bp->sdev);\n\n\tssb_device_enable(bp->sdev, 0);\n\tssb_pcicore_dev_irqvecs_enable(&sdev->bus->pcicore, sdev);\n\n\tif (was_enabled) {\n\t\tbw32(bp, B44_RCV_LAZY, 0);\n\t\tbw32(bp, B44_ENET_CTRL, ENET_CTRL_DISABLE);\n\t\tb44_wait_bit(bp, B44_ENET_CTRL, ENET_CTRL_DISABLE, 200, 1);\n\t\tbw32(bp, B44_DMATX_CTRL, 0);\n\t\tbp->tx_prod = bp->tx_cons = 0;\n\t\tif (br32(bp, B44_DMARX_STAT) & DMARX_STAT_EMASK) {\n\t\t\tb44_wait_bit(bp, B44_DMARX_STAT, DMARX_STAT_SIDLE,\n\t\t\t\t     100, 0);\n\t\t}\n\t\tbw32(bp, B44_DMARX_CTRL, 0);\n\t\tbp->rx_prod = bp->rx_cons = 0;\n\t}\n\n\tb44_clear_stats(bp);\n\n\t \n\tif (reset_kind == B44_CHIP_RESET_PARTIAL)\n\t\treturn;\n\n\tswitch (sdev->bus->bustype) {\n\tcase SSB_BUSTYPE_SSB:\n\t\tbw32(bp, B44_MDIO_CTRL, (MDIO_CTRL_PREAMBLE |\n\t\t     (DIV_ROUND_CLOSEST(ssb_clockspeed(sdev->bus),\n\t\t\t\t\tB44_MDC_RATIO)\n\t\t     & MDIO_CTRL_MAXF_MASK)));\n\t\tbreak;\n\tcase SSB_BUSTYPE_PCI:\n\t\tbw32(bp, B44_MDIO_CTRL, (MDIO_CTRL_PREAMBLE |\n\t\t     (0x0d & MDIO_CTRL_MAXF_MASK)));\n\t\tbreak;\n\tcase SSB_BUSTYPE_PCMCIA:\n\tcase SSB_BUSTYPE_SDIO:\n\t\tWARN_ON(1);  \n\t\tbreak;\n\t}\n\n\tbr32(bp, B44_MDIO_CTRL);\n\n\tif (!(br32(bp, B44_DEVCTRL) & DEVCTRL_IPP)) {\n\t\tbw32(bp, B44_ENET_CTRL, ENET_CTRL_EPSEL);\n\t\tbr32(bp, B44_ENET_CTRL);\n\t\tbp->flags |= B44_FLAG_EXTERNAL_PHY;\n\t} else {\n\t\tu32 val = br32(bp, B44_DEVCTRL);\n\n\t\tif (val & DEVCTRL_EPR) {\n\t\t\tbw32(bp, B44_DEVCTRL, (val & ~DEVCTRL_EPR));\n\t\t\tbr32(bp, B44_DEVCTRL);\n\t\t\tudelay(100);\n\t\t}\n\t\tbp->flags &= ~B44_FLAG_EXTERNAL_PHY;\n\t}\n}\n\n \nstatic void b44_halt(struct b44 *bp)\n{\n\tb44_disable_ints(bp);\n\t \n\tb44_phy_reset(bp);\n\t \n\tnetdev_info(bp->dev, \"powering down PHY\\n\");\n\tbw32(bp, B44_MAC_CTRL, MAC_CTRL_PHY_PDOWN);\n\t \n\tif (bp->flags & B44_FLAG_EXTERNAL_PHY)\n\t\tb44_chip_reset(bp, B44_CHIP_RESET_FULL);\n\telse\n\t\tb44_chip_reset(bp, B44_CHIP_RESET_PARTIAL);\n}\n\n \nstatic void __b44_set_mac_addr(struct b44 *bp)\n{\n\tbw32(bp, B44_CAM_CTRL, 0);\n\tif (!(bp->dev->flags & IFF_PROMISC)) {\n\t\tu32 val;\n\n\t\t__b44_cam_write(bp, bp->dev->dev_addr, 0);\n\t\tval = br32(bp, B44_CAM_CTRL);\n\t\tbw32(bp, B44_CAM_CTRL, val | CAM_CTRL_ENABLE);\n\t}\n}\n\nstatic int b44_set_mac_addr(struct net_device *dev, void *p)\n{\n\tstruct b44 *bp = netdev_priv(dev);\n\tstruct sockaddr *addr = p;\n\tu32 val;\n\n\tif (netif_running(dev))\n\t\treturn -EBUSY;\n\n\tif (!is_valid_ether_addr(addr->sa_data))\n\t\treturn -EINVAL;\n\n\teth_hw_addr_set(dev, addr->sa_data);\n\n\tspin_lock_irq(&bp->lock);\n\n\tval = br32(bp, B44_RXCONFIG);\n\tif (!(val & RXCONFIG_CAM_ABSENT))\n\t\t__b44_set_mac_addr(bp);\n\n\tspin_unlock_irq(&bp->lock);\n\n\treturn 0;\n}\n\n \nstatic void __b44_set_rx_mode(struct net_device *);\nstatic void b44_init_hw(struct b44 *bp, int reset_kind)\n{\n\tu32 val;\n\n\tb44_chip_reset(bp, B44_CHIP_RESET_FULL);\n\tif (reset_kind == B44_FULL_RESET) {\n\t\tb44_phy_reset(bp);\n\t\tb44_setup_phy(bp);\n\t}\n\n\t \n\tbw32(bp, B44_MAC_CTRL, MAC_CTRL_CRC32_ENAB | MAC_CTRL_PHY_LEDCTRL);\n\tbw32(bp, B44_RCV_LAZY, (1 << RCV_LAZY_FC_SHIFT));\n\n\t \n\t__b44_set_rx_mode(bp->dev);\n\n\t \n\tbw32(bp, B44_RXMAXLEN, bp->dev->mtu + ETH_HLEN + 8 + RX_HEADER_LEN);\n\tbw32(bp, B44_TXMAXLEN, bp->dev->mtu + ETH_HLEN + 8 + RX_HEADER_LEN);\n\n\tbw32(bp, B44_TX_WMARK, 56);  \n\tif (reset_kind == B44_PARTIAL_RESET) {\n\t\tbw32(bp, B44_DMARX_CTRL, (DMARX_CTRL_ENABLE |\n\t\t\t\t      (RX_PKT_OFFSET << DMARX_CTRL_ROSHIFT)));\n\t} else {\n\t\tbw32(bp, B44_DMATX_CTRL, DMATX_CTRL_ENABLE);\n\t\tbw32(bp, B44_DMATX_ADDR, bp->tx_ring_dma + bp->dma_offset);\n\t\tbw32(bp, B44_DMARX_CTRL, (DMARX_CTRL_ENABLE |\n\t\t\t\t      (RX_PKT_OFFSET << DMARX_CTRL_ROSHIFT)));\n\t\tbw32(bp, B44_DMARX_ADDR, bp->rx_ring_dma + bp->dma_offset);\n\n\t\tbw32(bp, B44_DMARX_PTR, bp->rx_pending);\n\t\tbp->rx_prod = bp->rx_pending;\n\n\t\tbw32(bp, B44_MIB_CTRL, MIB_CTRL_CLR_ON_READ);\n\t}\n\n\tval = br32(bp, B44_ENET_CTRL);\n\tbw32(bp, B44_ENET_CTRL, (val | ENET_CTRL_ENABLE));\n\n\tnetdev_reset_queue(bp->dev);\n}\n\nstatic int b44_open(struct net_device *dev)\n{\n\tstruct b44 *bp = netdev_priv(dev);\n\tint err;\n\n\terr = b44_alloc_consistent(bp, GFP_KERNEL);\n\tif (err)\n\t\tgoto out;\n\n\tnapi_enable(&bp->napi);\n\n\tb44_init_rings(bp);\n\tb44_init_hw(bp, B44_FULL_RESET);\n\n\tb44_check_phy(bp);\n\n\terr = request_irq(dev->irq, b44_interrupt, IRQF_SHARED, dev->name, dev);\n\tif (unlikely(err < 0)) {\n\t\tnapi_disable(&bp->napi);\n\t\tb44_chip_reset(bp, B44_CHIP_RESET_PARTIAL);\n\t\tb44_free_rings(bp);\n\t\tb44_free_consistent(bp);\n\t\tgoto out;\n\t}\n\n\ttimer_setup(&bp->timer, b44_timer, 0);\n\tbp->timer.expires = jiffies + HZ;\n\tadd_timer(&bp->timer);\n\n\tb44_enable_ints(bp);\n\n\tif (bp->flags & B44_FLAG_EXTERNAL_PHY)\n\t\tphy_start(dev->phydev);\n\n\tnetif_start_queue(dev);\nout:\n\treturn err;\n}\n\n#ifdef CONFIG_NET_POLL_CONTROLLER\n \nstatic void b44_poll_controller(struct net_device *dev)\n{\n\tdisable_irq(dev->irq);\n\tb44_interrupt(dev->irq, dev);\n\tenable_irq(dev->irq);\n}\n#endif\n\nstatic void bwfilter_table(struct b44 *bp, u8 *pp, u32 bytes, u32 table_offset)\n{\n\tu32 i;\n\tu32 *pattern = (u32 *) pp;\n\n\tfor (i = 0; i < bytes; i += sizeof(u32)) {\n\t\tbw32(bp, B44_FILT_ADDR, table_offset + i);\n\t\tbw32(bp, B44_FILT_DATA, pattern[i / sizeof(u32)]);\n\t}\n}\n\nstatic int b44_magic_pattern(const u8 *macaddr, u8 *ppattern, u8 *pmask,\n\t\t\t     int offset)\n{\n\tint magicsync = 6;\n\tint k, j, len = offset;\n\tint ethaddr_bytes = ETH_ALEN;\n\n\tmemset(ppattern + offset, 0xff, magicsync);\n\tfor (j = 0; j < magicsync; j++) {\n\t\tpmask[len >> 3] |= BIT(len & 7);\n\t\tlen++;\n\t}\n\n\tfor (j = 0; j < B44_MAX_PATTERNS; j++) {\n\t\tif ((B44_PATTERN_SIZE - len) >= ETH_ALEN)\n\t\t\tethaddr_bytes = ETH_ALEN;\n\t\telse\n\t\t\tethaddr_bytes = B44_PATTERN_SIZE - len;\n\t\tif (ethaddr_bytes <=0)\n\t\t\tbreak;\n\t\tfor (k = 0; k< ethaddr_bytes; k++) {\n\t\t\tppattern[offset + magicsync +\n\t\t\t\t(j * ETH_ALEN) + k] = macaddr[k];\n\t\t\tpmask[len >> 3] |= BIT(len & 7);\n\t\t\tlen++;\n\t\t}\n\t}\n\treturn len - 1;\n}\n\n \nstatic void b44_setup_pseudo_magicp(struct b44 *bp)\n{\n\n\tu32 val;\n\tint plen0, plen1, plen2;\n\tu8 *pwol_pattern;\n\tu8 pwol_mask[B44_PMASK_SIZE];\n\n\tpwol_pattern = kzalloc(B44_PATTERN_SIZE, GFP_KERNEL);\n\tif (!pwol_pattern)\n\t\treturn;\n\n\t \n\tmemset(pwol_mask, 0, B44_PMASK_SIZE);\n\tplen0 = b44_magic_pattern(bp->dev->dev_addr, pwol_pattern, pwol_mask,\n\t\t\t\t  B44_ETHIPV4UDP_HLEN);\n\n\tbwfilter_table(bp, pwol_pattern, B44_PATTERN_SIZE, B44_PATTERN_BASE);\n\tbwfilter_table(bp, pwol_mask, B44_PMASK_SIZE, B44_PMASK_BASE);\n\n\t \n\tmemset(pwol_pattern, 0, B44_PATTERN_SIZE);\n\tmemset(pwol_mask, 0, B44_PMASK_SIZE);\n\tplen1 = b44_magic_pattern(bp->dev->dev_addr, pwol_pattern, pwol_mask,\n\t\t\t\t  ETH_HLEN);\n\n\tbwfilter_table(bp, pwol_pattern, B44_PATTERN_SIZE,\n\t\t       B44_PATTERN_BASE + B44_PATTERN_SIZE);\n\tbwfilter_table(bp, pwol_mask, B44_PMASK_SIZE,\n\t\t       B44_PMASK_BASE + B44_PMASK_SIZE);\n\n\t \n\tmemset(pwol_pattern, 0, B44_PATTERN_SIZE);\n\tmemset(pwol_mask, 0, B44_PMASK_SIZE);\n\tplen2 = b44_magic_pattern(bp->dev->dev_addr, pwol_pattern, pwol_mask,\n\t\t\t\t  B44_ETHIPV6UDP_HLEN);\n\n\tbwfilter_table(bp, pwol_pattern, B44_PATTERN_SIZE,\n\t\t       B44_PATTERN_BASE + B44_PATTERN_SIZE + B44_PATTERN_SIZE);\n\tbwfilter_table(bp, pwol_mask, B44_PMASK_SIZE,\n\t\t       B44_PMASK_BASE + B44_PMASK_SIZE + B44_PMASK_SIZE);\n\n\tkfree(pwol_pattern);\n\n\t \n\tval = plen0 | (plen1 << 8) | (plen2 << 16) | WKUP_LEN_ENABLE_THREE;\n\tbw32(bp, B44_WKUP_LEN, val);\n\n\t \n\tval = br32(bp, B44_DEVCTRL);\n\tbw32(bp, B44_DEVCTRL, val | DEVCTRL_PFE);\n\n}\n\n#ifdef CONFIG_B44_PCI\nstatic void b44_setup_wol_pci(struct b44 *bp)\n{\n\tu16 val;\n\n\tif (bp->sdev->bus->bustype != SSB_BUSTYPE_SSB) {\n\t\tbw32(bp, SSB_TMSLOW, br32(bp, SSB_TMSLOW) | SSB_TMSLOW_PE);\n\t\tpci_read_config_word(bp->sdev->bus->host_pci, SSB_PMCSR, &val);\n\t\tpci_write_config_word(bp->sdev->bus->host_pci, SSB_PMCSR, val | SSB_PE);\n\t}\n}\n#else\nstatic inline void b44_setup_wol_pci(struct b44 *bp) { }\n#endif  \n\nstatic void b44_setup_wol(struct b44 *bp)\n{\n\tu32 val;\n\n\tbw32(bp, B44_RXCONFIG, RXCONFIG_ALLMULTI);\n\n\tif (bp->flags & B44_FLAG_B0_ANDLATER) {\n\n\t\tbw32(bp, B44_WKUP_LEN, WKUP_LEN_DISABLE);\n\n\t\tval = bp->dev->dev_addr[2] << 24 |\n\t\t\tbp->dev->dev_addr[3] << 16 |\n\t\t\tbp->dev->dev_addr[4] << 8 |\n\t\t\tbp->dev->dev_addr[5];\n\t\tbw32(bp, B44_ADDR_LO, val);\n\n\t\tval = bp->dev->dev_addr[0] << 8 |\n\t\t\tbp->dev->dev_addr[1];\n\t\tbw32(bp, B44_ADDR_HI, val);\n\n\t\tval = br32(bp, B44_DEVCTRL);\n\t\tbw32(bp, B44_DEVCTRL, val | DEVCTRL_MPM | DEVCTRL_PFE);\n\n\t} else {\n\t\tb44_setup_pseudo_magicp(bp);\n\t}\n\tb44_setup_wol_pci(bp);\n}\n\nstatic int b44_close(struct net_device *dev)\n{\n\tstruct b44 *bp = netdev_priv(dev);\n\n\tnetif_stop_queue(dev);\n\n\tif (bp->flags & B44_FLAG_EXTERNAL_PHY)\n\t\tphy_stop(dev->phydev);\n\n\tnapi_disable(&bp->napi);\n\n\tdel_timer_sync(&bp->timer);\n\n\tspin_lock_irq(&bp->lock);\n\n\tb44_halt(bp);\n\tb44_free_rings(bp);\n\tnetif_carrier_off(dev);\n\n\tspin_unlock_irq(&bp->lock);\n\n\tfree_irq(dev->irq, dev);\n\n\tif (bp->flags & B44_FLAG_WOL_ENABLE) {\n\t\tb44_init_hw(bp, B44_PARTIAL_RESET);\n\t\tb44_setup_wol(bp);\n\t}\n\n\tb44_free_consistent(bp);\n\n\treturn 0;\n}\n\nstatic void b44_get_stats64(struct net_device *dev,\n\t\t\t    struct rtnl_link_stats64 *nstat)\n{\n\tstruct b44 *bp = netdev_priv(dev);\n\tstruct b44_hw_stats *hwstat = &bp->hw_stats;\n\tunsigned int start;\n\n\tdo {\n\t\tstart = u64_stats_fetch_begin(&hwstat->syncp);\n\n\t\t \n\t\tnstat->rx_packets = hwstat->rx_pkts;\n\t\tnstat->tx_packets = hwstat->tx_pkts;\n\t\tnstat->rx_bytes   = hwstat->rx_octets;\n\t\tnstat->tx_bytes   = hwstat->tx_octets;\n\t\tnstat->tx_errors  = (hwstat->tx_jabber_pkts +\n\t\t\t\t     hwstat->tx_oversize_pkts +\n\t\t\t\t     hwstat->tx_underruns +\n\t\t\t\t     hwstat->tx_excessive_cols +\n\t\t\t\t     hwstat->tx_late_cols);\n\t\tnstat->multicast  = hwstat->rx_multicast_pkts;\n\t\tnstat->collisions = hwstat->tx_total_cols;\n\n\t\tnstat->rx_length_errors = (hwstat->rx_oversize_pkts +\n\t\t\t\t\t   hwstat->rx_undersize);\n\t\tnstat->rx_over_errors   = hwstat->rx_missed_pkts;\n\t\tnstat->rx_frame_errors  = hwstat->rx_align_errs;\n\t\tnstat->rx_crc_errors    = hwstat->rx_crc_errs;\n\t\tnstat->rx_errors        = (hwstat->rx_jabber_pkts +\n\t\t\t\t\t   hwstat->rx_oversize_pkts +\n\t\t\t\t\t   hwstat->rx_missed_pkts +\n\t\t\t\t\t   hwstat->rx_crc_align_errs +\n\t\t\t\t\t   hwstat->rx_undersize +\n\t\t\t\t\t   hwstat->rx_crc_errs +\n\t\t\t\t\t   hwstat->rx_align_errs +\n\t\t\t\t\t   hwstat->rx_symbol_errs);\n\n\t\tnstat->tx_aborted_errors = hwstat->tx_underruns;\n#if 0\n\t\t \n\t\tnstat->tx_carrier_errors = hwstat->tx_carrier_lost;\n#endif\n\t} while (u64_stats_fetch_retry(&hwstat->syncp, start));\n\n}\n\nstatic int __b44_load_mcast(struct b44 *bp, struct net_device *dev)\n{\n\tstruct netdev_hw_addr *ha;\n\tint i, num_ents;\n\n\tnum_ents = min_t(int, netdev_mc_count(dev), B44_MCAST_TABLE_SIZE);\n\ti = 0;\n\tnetdev_for_each_mc_addr(ha, dev) {\n\t\tif (i == num_ents)\n\t\t\tbreak;\n\t\t__b44_cam_write(bp, ha->addr, i++ + 1);\n\t}\n\treturn i+1;\n}\n\nstatic void __b44_set_rx_mode(struct net_device *dev)\n{\n\tstruct b44 *bp = netdev_priv(dev);\n\tu32 val;\n\n\tval = br32(bp, B44_RXCONFIG);\n\tval &= ~(RXCONFIG_PROMISC | RXCONFIG_ALLMULTI);\n\tif ((dev->flags & IFF_PROMISC) || (val & RXCONFIG_CAM_ABSENT)) {\n\t\tval |= RXCONFIG_PROMISC;\n\t\tbw32(bp, B44_RXCONFIG, val);\n\t} else {\n\t\tunsigned char zero[6] = {0, 0, 0, 0, 0, 0};\n\t\tint i = 1;\n\n\t\t__b44_set_mac_addr(bp);\n\n\t\tif ((dev->flags & IFF_ALLMULTI) ||\n\t\t    (netdev_mc_count(dev) > B44_MCAST_TABLE_SIZE))\n\t\t\tval |= RXCONFIG_ALLMULTI;\n\t\telse\n\t\t\ti = __b44_load_mcast(bp, dev);\n\n\t\tfor (; i < 64; i++)\n\t\t\t__b44_cam_write(bp, zero, i);\n\n\t\tbw32(bp, B44_RXCONFIG, val);\n\t\tval = br32(bp, B44_CAM_CTRL);\n\t        bw32(bp, B44_CAM_CTRL, val | CAM_CTRL_ENABLE);\n\t}\n}\n\nstatic void b44_set_rx_mode(struct net_device *dev)\n{\n\tstruct b44 *bp = netdev_priv(dev);\n\n\tspin_lock_irq(&bp->lock);\n\t__b44_set_rx_mode(dev);\n\tspin_unlock_irq(&bp->lock);\n}\n\nstatic u32 b44_get_msglevel(struct net_device *dev)\n{\n\tstruct b44 *bp = netdev_priv(dev);\n\treturn bp->msg_enable;\n}\n\nstatic void b44_set_msglevel(struct net_device *dev, u32 value)\n{\n\tstruct b44 *bp = netdev_priv(dev);\n\tbp->msg_enable = value;\n}\n\nstatic void b44_get_drvinfo (struct net_device *dev, struct ethtool_drvinfo *info)\n{\n\tstruct b44 *bp = netdev_priv(dev);\n\tstruct ssb_bus *bus = bp->sdev->bus;\n\n\tstrscpy(info->driver, DRV_MODULE_NAME, sizeof(info->driver));\n\tswitch (bus->bustype) {\n\tcase SSB_BUSTYPE_PCI:\n\t\tstrscpy(info->bus_info, pci_name(bus->host_pci), sizeof(info->bus_info));\n\t\tbreak;\n\tcase SSB_BUSTYPE_SSB:\n\t\tstrscpy(info->bus_info, \"SSB\", sizeof(info->bus_info));\n\t\tbreak;\n\tcase SSB_BUSTYPE_PCMCIA:\n\tcase SSB_BUSTYPE_SDIO:\n\t\tWARN_ON(1);  \n\t\tbreak;\n\t}\n}\n\nstatic int b44_nway_reset(struct net_device *dev)\n{\n\tstruct b44 *bp = netdev_priv(dev);\n\tu32 bmcr;\n\tint r;\n\n\tspin_lock_irq(&bp->lock);\n\tb44_readphy(bp, MII_BMCR, &bmcr);\n\tb44_readphy(bp, MII_BMCR, &bmcr);\n\tr = -EINVAL;\n\tif (bmcr & BMCR_ANENABLE)\n\t\tr = b44_writephy(bp, MII_BMCR,\n\t\t\t\t bmcr | BMCR_ANRESTART);\n\tspin_unlock_irq(&bp->lock);\n\n\treturn r;\n}\n\nstatic int b44_get_link_ksettings(struct net_device *dev,\n\t\t\t\t  struct ethtool_link_ksettings *cmd)\n{\n\tstruct b44 *bp = netdev_priv(dev);\n\tu32 supported, advertising;\n\n\tif (bp->flags & B44_FLAG_EXTERNAL_PHY) {\n\t\tBUG_ON(!dev->phydev);\n\t\tphy_ethtool_ksettings_get(dev->phydev, cmd);\n\n\t\treturn 0;\n\t}\n\n\tsupported = (SUPPORTED_Autoneg);\n\tsupported |= (SUPPORTED_100baseT_Half |\n\t\t      SUPPORTED_100baseT_Full |\n\t\t      SUPPORTED_10baseT_Half |\n\t\t      SUPPORTED_10baseT_Full |\n\t\t      SUPPORTED_MII);\n\n\tadvertising = 0;\n\tif (bp->flags & B44_FLAG_ADV_10HALF)\n\t\tadvertising |= ADVERTISED_10baseT_Half;\n\tif (bp->flags & B44_FLAG_ADV_10FULL)\n\t\tadvertising |= ADVERTISED_10baseT_Full;\n\tif (bp->flags & B44_FLAG_ADV_100HALF)\n\t\tadvertising |= ADVERTISED_100baseT_Half;\n\tif (bp->flags & B44_FLAG_ADV_100FULL)\n\t\tadvertising |= ADVERTISED_100baseT_Full;\n\tadvertising |= ADVERTISED_Pause | ADVERTISED_Asym_Pause;\n\tcmd->base.speed = (bp->flags & B44_FLAG_100_BASE_T) ?\n\t\tSPEED_100 : SPEED_10;\n\tcmd->base.duplex = (bp->flags & B44_FLAG_FULL_DUPLEX) ?\n\t\tDUPLEX_FULL : DUPLEX_HALF;\n\tcmd->base.port = 0;\n\tcmd->base.phy_address = bp->phy_addr;\n\tcmd->base.autoneg = (bp->flags & B44_FLAG_FORCE_LINK) ?\n\t\tAUTONEG_DISABLE : AUTONEG_ENABLE;\n\tif (cmd->base.autoneg == AUTONEG_ENABLE)\n\t\tadvertising |= ADVERTISED_Autoneg;\n\n\tethtool_convert_legacy_u32_to_link_mode(cmd->link_modes.supported,\n\t\t\t\t\t\tsupported);\n\tethtool_convert_legacy_u32_to_link_mode(cmd->link_modes.advertising,\n\t\t\t\t\t\tadvertising);\n\n\tif (!netif_running(dev)){\n\t\tcmd->base.speed = 0;\n\t\tcmd->base.duplex = 0xff;\n\t}\n\n\treturn 0;\n}\n\nstatic int b44_set_link_ksettings(struct net_device *dev,\n\t\t\t\t  const struct ethtool_link_ksettings *cmd)\n{\n\tstruct b44 *bp = netdev_priv(dev);\n\tu32 speed;\n\tint ret;\n\tu32 advertising;\n\n\tif (bp->flags & B44_FLAG_EXTERNAL_PHY) {\n\t\tBUG_ON(!dev->phydev);\n\t\tspin_lock_irq(&bp->lock);\n\t\tif (netif_running(dev))\n\t\t\tb44_setup_phy(bp);\n\n\t\tret = phy_ethtool_ksettings_set(dev->phydev, cmd);\n\n\t\tspin_unlock_irq(&bp->lock);\n\n\t\treturn ret;\n\t}\n\n\tspeed = cmd->base.speed;\n\n\tethtool_convert_link_mode_to_legacy_u32(&advertising,\n\t\t\t\t\t\tcmd->link_modes.advertising);\n\n\t \n\tif (cmd->base.autoneg == AUTONEG_ENABLE) {\n\t\tif (advertising &\n\t\t    (ADVERTISED_1000baseT_Half |\n\t\t     ADVERTISED_1000baseT_Full))\n\t\t\treturn -EINVAL;\n\t} else if ((speed != SPEED_100 &&\n\t\t    speed != SPEED_10) ||\n\t\t   (cmd->base.duplex != DUPLEX_HALF &&\n\t\t    cmd->base.duplex != DUPLEX_FULL)) {\n\t\t\treturn -EINVAL;\n\t}\n\n\tspin_lock_irq(&bp->lock);\n\n\tif (cmd->base.autoneg == AUTONEG_ENABLE) {\n\t\tbp->flags &= ~(B44_FLAG_FORCE_LINK |\n\t\t\t       B44_FLAG_100_BASE_T |\n\t\t\t       B44_FLAG_FULL_DUPLEX |\n\t\t\t       B44_FLAG_ADV_10HALF |\n\t\t\t       B44_FLAG_ADV_10FULL |\n\t\t\t       B44_FLAG_ADV_100HALF |\n\t\t\t       B44_FLAG_ADV_100FULL);\n\t\tif (advertising == 0) {\n\t\t\tbp->flags |= (B44_FLAG_ADV_10HALF |\n\t\t\t\t      B44_FLAG_ADV_10FULL |\n\t\t\t\t      B44_FLAG_ADV_100HALF |\n\t\t\t\t      B44_FLAG_ADV_100FULL);\n\t\t} else {\n\t\t\tif (advertising & ADVERTISED_10baseT_Half)\n\t\t\t\tbp->flags |= B44_FLAG_ADV_10HALF;\n\t\t\tif (advertising & ADVERTISED_10baseT_Full)\n\t\t\t\tbp->flags |= B44_FLAG_ADV_10FULL;\n\t\t\tif (advertising & ADVERTISED_100baseT_Half)\n\t\t\t\tbp->flags |= B44_FLAG_ADV_100HALF;\n\t\t\tif (advertising & ADVERTISED_100baseT_Full)\n\t\t\t\tbp->flags |= B44_FLAG_ADV_100FULL;\n\t\t}\n\t} else {\n\t\tbp->flags |= B44_FLAG_FORCE_LINK;\n\t\tbp->flags &= ~(B44_FLAG_100_BASE_T | B44_FLAG_FULL_DUPLEX);\n\t\tif (speed == SPEED_100)\n\t\t\tbp->flags |= B44_FLAG_100_BASE_T;\n\t\tif (cmd->base.duplex == DUPLEX_FULL)\n\t\t\tbp->flags |= B44_FLAG_FULL_DUPLEX;\n\t}\n\n\tif (netif_running(dev))\n\t\tb44_setup_phy(bp);\n\n\tspin_unlock_irq(&bp->lock);\n\n\treturn 0;\n}\n\nstatic void b44_get_ringparam(struct net_device *dev,\n\t\t\t      struct ethtool_ringparam *ering,\n\t\t\t      struct kernel_ethtool_ringparam *kernel_ering,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct b44 *bp = netdev_priv(dev);\n\n\tering->rx_max_pending = B44_RX_RING_SIZE - 1;\n\tering->rx_pending = bp->rx_pending;\n\n\t \n}\n\nstatic int b44_set_ringparam(struct net_device *dev,\n\t\t\t     struct ethtool_ringparam *ering,\n\t\t\t     struct kernel_ethtool_ringparam *kernel_ering,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct b44 *bp = netdev_priv(dev);\n\n\tif ((ering->rx_pending > B44_RX_RING_SIZE - 1) ||\n\t    (ering->rx_mini_pending != 0) ||\n\t    (ering->rx_jumbo_pending != 0) ||\n\t    (ering->tx_pending > B44_TX_RING_SIZE - 1))\n\t\treturn -EINVAL;\n\n\tspin_lock_irq(&bp->lock);\n\n\tbp->rx_pending = ering->rx_pending;\n\tbp->tx_pending = ering->tx_pending;\n\n\tb44_halt(bp);\n\tb44_init_rings(bp);\n\tb44_init_hw(bp, B44_FULL_RESET);\n\tnetif_wake_queue(bp->dev);\n\tspin_unlock_irq(&bp->lock);\n\n\tb44_enable_ints(bp);\n\n\treturn 0;\n}\n\nstatic void b44_get_pauseparam(struct net_device *dev,\n\t\t\t\tstruct ethtool_pauseparam *epause)\n{\n\tstruct b44 *bp = netdev_priv(dev);\n\n\tepause->autoneg =\n\t\t(bp->flags & B44_FLAG_PAUSE_AUTO) != 0;\n\tepause->rx_pause =\n\t\t(bp->flags & B44_FLAG_RX_PAUSE) != 0;\n\tepause->tx_pause =\n\t\t(bp->flags & B44_FLAG_TX_PAUSE) != 0;\n}\n\nstatic int b44_set_pauseparam(struct net_device *dev,\n\t\t\t\tstruct ethtool_pauseparam *epause)\n{\n\tstruct b44 *bp = netdev_priv(dev);\n\n\tspin_lock_irq(&bp->lock);\n\tif (epause->autoneg)\n\t\tbp->flags |= B44_FLAG_PAUSE_AUTO;\n\telse\n\t\tbp->flags &= ~B44_FLAG_PAUSE_AUTO;\n\tif (epause->rx_pause)\n\t\tbp->flags |= B44_FLAG_RX_PAUSE;\n\telse\n\t\tbp->flags &= ~B44_FLAG_RX_PAUSE;\n\tif (epause->tx_pause)\n\t\tbp->flags |= B44_FLAG_TX_PAUSE;\n\telse\n\t\tbp->flags &= ~B44_FLAG_TX_PAUSE;\n\tif (bp->flags & B44_FLAG_PAUSE_AUTO) {\n\t\tb44_halt(bp);\n\t\tb44_init_rings(bp);\n\t\tb44_init_hw(bp, B44_FULL_RESET);\n\t} else {\n\t\t__b44_set_flow_ctrl(bp, bp->flags);\n\t}\n\tspin_unlock_irq(&bp->lock);\n\n\tb44_enable_ints(bp);\n\n\treturn 0;\n}\n\nstatic void b44_get_strings(struct net_device *dev, u32 stringset, u8 *data)\n{\n\tswitch(stringset) {\n\tcase ETH_SS_STATS:\n\t\tmemcpy(data, *b44_gstrings, sizeof(b44_gstrings));\n\t\tbreak;\n\t}\n}\n\nstatic int b44_get_sset_count(struct net_device *dev, int sset)\n{\n\tswitch (sset) {\n\tcase ETH_SS_STATS:\n\t\treturn ARRAY_SIZE(b44_gstrings);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic void b44_get_ethtool_stats(struct net_device *dev,\n\t\t\t\t  struct ethtool_stats *stats, u64 *data)\n{\n\tstruct b44 *bp = netdev_priv(dev);\n\tstruct b44_hw_stats *hwstat = &bp->hw_stats;\n\tu64 *data_src, *data_dst;\n\tunsigned int start;\n\tu32 i;\n\n\tspin_lock_irq(&bp->lock);\n\tb44_stats_update(bp);\n\tspin_unlock_irq(&bp->lock);\n\n\tdo {\n\t\tdata_src = &hwstat->tx_good_octets;\n\t\tdata_dst = data;\n\t\tstart = u64_stats_fetch_begin(&hwstat->syncp);\n\n\t\tfor (i = 0; i < ARRAY_SIZE(b44_gstrings); i++)\n\t\t\t*data_dst++ = *data_src++;\n\n\t} while (u64_stats_fetch_retry(&hwstat->syncp, start));\n}\n\nstatic void b44_get_wol(struct net_device *dev, struct ethtool_wolinfo *wol)\n{\n\tstruct b44 *bp = netdev_priv(dev);\n\n\twol->supported = WAKE_MAGIC;\n\tif (bp->flags & B44_FLAG_WOL_ENABLE)\n\t\twol->wolopts = WAKE_MAGIC;\n\telse\n\t\twol->wolopts = 0;\n\tmemset(&wol->sopass, 0, sizeof(wol->sopass));\n}\n\nstatic int b44_set_wol(struct net_device *dev, struct ethtool_wolinfo *wol)\n{\n\tstruct b44 *bp = netdev_priv(dev);\n\n\tspin_lock_irq(&bp->lock);\n\tif (wol->wolopts & WAKE_MAGIC)\n\t\tbp->flags |= B44_FLAG_WOL_ENABLE;\n\telse\n\t\tbp->flags &= ~B44_FLAG_WOL_ENABLE;\n\tspin_unlock_irq(&bp->lock);\n\n\tdevice_set_wakeup_enable(bp->sdev->dev, wol->wolopts & WAKE_MAGIC);\n\treturn 0;\n}\n\nstatic const struct ethtool_ops b44_ethtool_ops = {\n\t.get_drvinfo\t\t= b44_get_drvinfo,\n\t.nway_reset\t\t= b44_nway_reset,\n\t.get_link\t\t= ethtool_op_get_link,\n\t.get_wol\t\t= b44_get_wol,\n\t.set_wol\t\t= b44_set_wol,\n\t.get_ringparam\t\t= b44_get_ringparam,\n\t.set_ringparam\t\t= b44_set_ringparam,\n\t.get_pauseparam\t\t= b44_get_pauseparam,\n\t.set_pauseparam\t\t= b44_set_pauseparam,\n\t.get_msglevel\t\t= b44_get_msglevel,\n\t.set_msglevel\t\t= b44_set_msglevel,\n\t.get_strings\t\t= b44_get_strings,\n\t.get_sset_count\t\t= b44_get_sset_count,\n\t.get_ethtool_stats\t= b44_get_ethtool_stats,\n\t.get_link_ksettings\t= b44_get_link_ksettings,\n\t.set_link_ksettings\t= b44_set_link_ksettings,\n};\n\nstatic int b44_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\n{\n\tstruct b44 *bp = netdev_priv(dev);\n\tint err = -EINVAL;\n\n\tif (!netif_running(dev))\n\t\tgoto out;\n\n\tspin_lock_irq(&bp->lock);\n\tif (bp->flags & B44_FLAG_EXTERNAL_PHY) {\n\t\tBUG_ON(!dev->phydev);\n\t\terr = phy_mii_ioctl(dev->phydev, ifr, cmd);\n\t} else {\n\t\terr = generic_mii_ioctl(&bp->mii_if, if_mii(ifr), cmd, NULL);\n\t}\n\tspin_unlock_irq(&bp->lock);\nout:\n\treturn err;\n}\n\nstatic int b44_get_invariants(struct b44 *bp)\n{\n\tstruct ssb_device *sdev = bp->sdev;\n\tint err = 0;\n\tu8 *addr;\n\n\tbp->dma_offset = ssb_dma_translation(sdev);\n\n\tif (sdev->bus->bustype == SSB_BUSTYPE_SSB &&\n\t    instance > 1) {\n\t\taddr = sdev->bus->sprom.et1mac;\n\t\tbp->phy_addr = sdev->bus->sprom.et1phyaddr;\n\t} else {\n\t\taddr = sdev->bus->sprom.et0mac;\n\t\tbp->phy_addr = sdev->bus->sprom.et0phyaddr;\n\t}\n\t \n\tbp->phy_addr &= 0x1F;\n\n\teth_hw_addr_set(bp->dev, addr);\n\n\tif (!is_valid_ether_addr(&bp->dev->dev_addr[0])){\n\t\tpr_err(\"Invalid MAC address found in EEPROM\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tbp->imask = IMASK_DEF;\n\n\t \n\n\tif (bp->sdev->id.revision >= 7)\n\t\tbp->flags |= B44_FLAG_B0_ANDLATER;\n\n\treturn err;\n}\n\nstatic const struct net_device_ops b44_netdev_ops = {\n\t.ndo_open\t\t= b44_open,\n\t.ndo_stop\t\t= b44_close,\n\t.ndo_start_xmit\t\t= b44_start_xmit,\n\t.ndo_get_stats64\t= b44_get_stats64,\n\t.ndo_set_rx_mode\t= b44_set_rx_mode,\n\t.ndo_set_mac_address\t= b44_set_mac_addr,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_eth_ioctl\t\t= b44_ioctl,\n\t.ndo_tx_timeout\t\t= b44_tx_timeout,\n\t.ndo_change_mtu\t\t= b44_change_mtu,\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\t.ndo_poll_controller\t= b44_poll_controller,\n#endif\n};\n\nstatic void b44_adjust_link(struct net_device *dev)\n{\n\tstruct b44 *bp = netdev_priv(dev);\n\tstruct phy_device *phydev = dev->phydev;\n\tbool status_changed = false;\n\n\tBUG_ON(!phydev);\n\n\tif (bp->old_link != phydev->link) {\n\t\tstatus_changed = true;\n\t\tbp->old_link = phydev->link;\n\t}\n\n\t \n\tif (phydev->link) {\n\t\tif ((phydev->duplex == DUPLEX_HALF) &&\n\t\t    (bp->flags & B44_FLAG_FULL_DUPLEX)) {\n\t\t\tstatus_changed = true;\n\t\t\tbp->flags &= ~B44_FLAG_FULL_DUPLEX;\n\t\t} else if ((phydev->duplex == DUPLEX_FULL) &&\n\t\t\t   !(bp->flags & B44_FLAG_FULL_DUPLEX)) {\n\t\t\tstatus_changed = true;\n\t\t\tbp->flags |= B44_FLAG_FULL_DUPLEX;\n\t\t}\n\t}\n\n\tif (status_changed) {\n\t\tu32 val = br32(bp, B44_TX_CTRL);\n\t\tif (bp->flags & B44_FLAG_FULL_DUPLEX)\n\t\t\tval |= TX_CTRL_DUPLEX;\n\t\telse\n\t\t\tval &= ~TX_CTRL_DUPLEX;\n\t\tbw32(bp, B44_TX_CTRL, val);\n\t\tphy_print_status(phydev);\n\t}\n}\n\nstatic int b44_register_phy_one(struct b44 *bp)\n{\n\t__ETHTOOL_DECLARE_LINK_MODE_MASK(mask) = { 0, };\n\tstruct mii_bus *mii_bus;\n\tstruct ssb_device *sdev = bp->sdev;\n\tstruct phy_device *phydev;\n\tchar bus_id[MII_BUS_ID_SIZE + 3];\n\tstruct ssb_sprom *sprom = &sdev->bus->sprom;\n\tint err;\n\n\tmii_bus = mdiobus_alloc();\n\tif (!mii_bus) {\n\t\tdev_err(sdev->dev, \"mdiobus_alloc() failed\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\n\tmii_bus->priv = bp;\n\tmii_bus->read = b44_mdio_read_phylib;\n\tmii_bus->write = b44_mdio_write_phylib;\n\tmii_bus->name = \"b44_eth_mii\";\n\tmii_bus->parent = sdev->dev;\n\tmii_bus->phy_mask = ~(1 << bp->phy_addr);\n\tsnprintf(mii_bus->id, MII_BUS_ID_SIZE, \"%x\", instance);\n\n\tbp->mii_bus = mii_bus;\n\n\terr = mdiobus_register(mii_bus);\n\tif (err) {\n\t\tdev_err(sdev->dev, \"failed to register MII bus\\n\");\n\t\tgoto err_out_mdiobus;\n\t}\n\n\tif (!mdiobus_is_registered_device(bp->mii_bus, bp->phy_addr) &&\n\t    (sprom->boardflags_lo & (B44_BOARDFLAG_ROBO | B44_BOARDFLAG_ADM))) {\n\n\t\tdev_info(sdev->dev,\n\t\t\t \"could not find PHY at %i, use fixed one\\n\",\n\t\t\t bp->phy_addr);\n\n\t\tbp->phy_addr = 0;\n\t\tsnprintf(bus_id, sizeof(bus_id), PHY_ID_FMT, \"fixed-0\",\n\t\t\t bp->phy_addr);\n\t} else {\n\t\tsnprintf(bus_id, sizeof(bus_id), PHY_ID_FMT, mii_bus->id,\n\t\t\t bp->phy_addr);\n\t}\n\n\tphydev = phy_connect(bp->dev, bus_id, &b44_adjust_link,\n\t\t\t     PHY_INTERFACE_MODE_MII);\n\tif (IS_ERR(phydev)) {\n\t\tdev_err(sdev->dev, \"could not attach PHY at %i\\n\",\n\t\t\tbp->phy_addr);\n\t\terr = PTR_ERR(phydev);\n\t\tgoto err_out_mdiobus_unregister;\n\t}\n\n\t \n\tlinkmode_set_bit(ETHTOOL_LINK_MODE_100baseT_Half_BIT, mask);\n\tlinkmode_set_bit(ETHTOOL_LINK_MODE_100baseT_Full_BIT, mask);\n\tlinkmode_set_bit(ETHTOOL_LINK_MODE_Autoneg_BIT, mask);\n\tlinkmode_set_bit(ETHTOOL_LINK_MODE_MII_BIT, mask);\n\tlinkmode_and(phydev->supported, phydev->supported, mask);\n\tlinkmode_copy(phydev->advertising, phydev->supported);\n\n\tbp->old_link = 0;\n\tbp->phy_addr = phydev->mdio.addr;\n\n\tphy_attached_info(phydev);\n\n\treturn 0;\n\nerr_out_mdiobus_unregister:\n\tmdiobus_unregister(mii_bus);\n\nerr_out_mdiobus:\n\tmdiobus_free(mii_bus);\n\nerr_out:\n\treturn err;\n}\n\nstatic void b44_unregister_phy_one(struct b44 *bp)\n{\n\tstruct net_device *dev = bp->dev;\n\tstruct mii_bus *mii_bus = bp->mii_bus;\n\n\tphy_disconnect(dev->phydev);\n\tmdiobus_unregister(mii_bus);\n\tmdiobus_free(mii_bus);\n}\n\nstatic int b44_init_one(struct ssb_device *sdev,\n\t\t\tconst struct ssb_device_id *ent)\n{\n\tstruct net_device *dev;\n\tstruct b44 *bp;\n\tint err;\n\n\tinstance++;\n\n\tdev = alloc_etherdev(sizeof(*bp));\n\tif (!dev) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tSET_NETDEV_DEV(dev, sdev->dev);\n\n\t \n\tdev->features |= 0;\n\n\tbp = netdev_priv(dev);\n\tbp->sdev = sdev;\n\tbp->dev = dev;\n\tbp->force_copybreak = 0;\n\n\tbp->msg_enable = netif_msg_init(b44_debug, B44_DEF_MSG_ENABLE);\n\n\tspin_lock_init(&bp->lock);\n\tu64_stats_init(&bp->hw_stats.syncp);\n\n\tbp->rx_pending = B44_DEF_RX_RING_PENDING;\n\tbp->tx_pending = B44_DEF_TX_RING_PENDING;\n\n\tdev->netdev_ops = &b44_netdev_ops;\n\tnetif_napi_add(dev, &bp->napi, b44_poll);\n\tdev->watchdog_timeo = B44_TX_TIMEOUT;\n\tdev->min_mtu = B44_MIN_MTU;\n\tdev->max_mtu = B44_MAX_MTU;\n\tdev->irq = sdev->irq;\n\tdev->ethtool_ops = &b44_ethtool_ops;\n\n\terr = ssb_bus_powerup(sdev->bus, 0);\n\tif (err) {\n\t\tdev_err(sdev->dev,\n\t\t\t\"Failed to powerup the bus\\n\");\n\t\tgoto err_out_free_dev;\n\t}\n\n\terr = dma_set_mask_and_coherent(sdev->dma_dev, DMA_BIT_MASK(30));\n\tif (err) {\n\t\tdev_err(sdev->dev,\n\t\t\t\"Required 30BIT DMA mask unsupported by the system\\n\");\n\t\tgoto err_out_powerdown;\n\t}\n\n\terr = b44_get_invariants(bp);\n\tif (err) {\n\t\tdev_err(sdev->dev,\n\t\t\t\"Problem fetching invariants of chip, aborting\\n\");\n\t\tgoto err_out_powerdown;\n\t}\n\n\tif (bp->phy_addr == B44_PHY_ADDR_NO_PHY) {\n\t\tdev_err(sdev->dev, \"No PHY present on this MAC, aborting\\n\");\n\t\terr = -ENODEV;\n\t\tgoto err_out_powerdown;\n\t}\n\n\tbp->mii_if.dev = dev;\n\tbp->mii_if.mdio_read = b44_mdio_read_mii;\n\tbp->mii_if.mdio_write = b44_mdio_write_mii;\n\tbp->mii_if.phy_id = bp->phy_addr;\n\tbp->mii_if.phy_id_mask = 0x1f;\n\tbp->mii_if.reg_num_mask = 0x1f;\n\n\t \n\tbp->flags |= (B44_FLAG_ADV_10HALF | B44_FLAG_ADV_10FULL |\n\t\t      B44_FLAG_ADV_100HALF | B44_FLAG_ADV_100FULL);\n\n\t \n\tbp->flags |= B44_FLAG_PAUSE_AUTO;\n\n\terr = register_netdev(dev);\n\tif (err) {\n\t\tdev_err(sdev->dev, \"Cannot register net device, aborting\\n\");\n\t\tgoto err_out_powerdown;\n\t}\n\n\tnetif_carrier_off(dev);\n\n\tssb_set_drvdata(sdev, dev);\n\n\t \n\tb44_chip_reset(bp, B44_CHIP_RESET_FULL);\n\n\t \n\terr = b44_phy_reset(bp);\n\tif (err < 0) {\n\t\tdev_err(sdev->dev, \"phy reset failed\\n\");\n\t\tgoto err_out_unregister_netdev;\n\t}\n\n\tif (bp->flags & B44_FLAG_EXTERNAL_PHY) {\n\t\terr = b44_register_phy_one(bp);\n\t\tif (err) {\n\t\t\tdev_err(sdev->dev, \"Cannot register PHY, aborting\\n\");\n\t\t\tgoto err_out_unregister_netdev;\n\t\t}\n\t}\n\n\tdevice_set_wakeup_capable(sdev->dev, true);\n\tnetdev_info(dev, \"%s %pM\\n\", DRV_DESCRIPTION, dev->dev_addr);\n\n\treturn 0;\n\nerr_out_unregister_netdev:\n\tunregister_netdev(dev);\nerr_out_powerdown:\n\tssb_bus_may_powerdown(sdev->bus);\n\nerr_out_free_dev:\n\tnetif_napi_del(&bp->napi);\n\tfree_netdev(dev);\n\nout:\n\treturn err;\n}\n\nstatic void b44_remove_one(struct ssb_device *sdev)\n{\n\tstruct net_device *dev = ssb_get_drvdata(sdev);\n\tstruct b44 *bp = netdev_priv(dev);\n\n\tunregister_netdev(dev);\n\tif (bp->flags & B44_FLAG_EXTERNAL_PHY)\n\t\tb44_unregister_phy_one(bp);\n\tssb_device_disable(sdev, 0);\n\tssb_bus_may_powerdown(sdev->bus);\n\tnetif_napi_del(&bp->napi);\n\tfree_netdev(dev);\n\tssb_pcihost_set_power_state(sdev, PCI_D3hot);\n\tssb_set_drvdata(sdev, NULL);\n}\n\nstatic int b44_suspend(struct ssb_device *sdev, pm_message_t state)\n{\n\tstruct net_device *dev = ssb_get_drvdata(sdev);\n\tstruct b44 *bp = netdev_priv(dev);\n\n\tif (!netif_running(dev))\n\t\treturn 0;\n\n\tdel_timer_sync(&bp->timer);\n\n\tspin_lock_irq(&bp->lock);\n\n\tb44_halt(bp);\n\tnetif_carrier_off(bp->dev);\n\tnetif_device_detach(bp->dev);\n\tb44_free_rings(bp);\n\n\tspin_unlock_irq(&bp->lock);\n\n\tfree_irq(dev->irq, dev);\n\tif (bp->flags & B44_FLAG_WOL_ENABLE) {\n\t\tb44_init_hw(bp, B44_PARTIAL_RESET);\n\t\tb44_setup_wol(bp);\n\t}\n\n\tssb_pcihost_set_power_state(sdev, PCI_D3hot);\n\treturn 0;\n}\n\nstatic int b44_resume(struct ssb_device *sdev)\n{\n\tstruct net_device *dev = ssb_get_drvdata(sdev);\n\tstruct b44 *bp = netdev_priv(dev);\n\tint rc = 0;\n\n\trc = ssb_bus_powerup(sdev->bus, 0);\n\tif (rc) {\n\t\tdev_err(sdev->dev,\n\t\t\t\"Failed to powerup the bus\\n\");\n\t\treturn rc;\n\t}\n\n\tif (!netif_running(dev))\n\t\treturn 0;\n\n\tspin_lock_irq(&bp->lock);\n\tb44_init_rings(bp);\n\tb44_init_hw(bp, B44_FULL_RESET);\n\tspin_unlock_irq(&bp->lock);\n\n\t \n\trc = request_irq(dev->irq, b44_interrupt, IRQF_SHARED, dev->name, dev);\n\tif (rc) {\n\t\tnetdev_err(dev, \"request_irq failed\\n\");\n\t\tspin_lock_irq(&bp->lock);\n\t\tb44_halt(bp);\n\t\tb44_free_rings(bp);\n\t\tspin_unlock_irq(&bp->lock);\n\t\treturn rc;\n\t}\n\n\tnetif_device_attach(bp->dev);\n\n\tb44_enable_ints(bp);\n\tnetif_wake_queue(dev);\n\n\tmod_timer(&bp->timer, jiffies + 1);\n\n\treturn 0;\n}\n\nstatic struct ssb_driver b44_ssb_driver = {\n\t.name\t\t= DRV_MODULE_NAME,\n\t.id_table\t= b44_ssb_tbl,\n\t.probe\t\t= b44_init_one,\n\t.remove\t\t= b44_remove_one,\n\t.suspend\t= b44_suspend,\n\t.resume\t\t= b44_resume,\n};\n\nstatic inline int __init b44_pci_init(void)\n{\n\tint err = 0;\n#ifdef CONFIG_B44_PCI\n\terr = ssb_pcihost_register(&b44_pci_driver);\n#endif\n\treturn err;\n}\n\nstatic inline void b44_pci_exit(void)\n{\n#ifdef CONFIG_B44_PCI\n\tssb_pcihost_unregister(&b44_pci_driver);\n#endif\n}\n\nstatic int __init b44_init(void)\n{\n\tunsigned int dma_desc_align_size = dma_get_cache_alignment();\n\tint err;\n\n\t \n\tdma_desc_sync_size = max_t(unsigned int, dma_desc_align_size, sizeof(struct dma_desc));\n\n\terr = b44_pci_init();\n\tif (err)\n\t\treturn err;\n\terr = ssb_driver_register(&b44_ssb_driver);\n\tif (err)\n\t\tb44_pci_exit();\n\treturn err;\n}\n\nstatic void __exit b44_cleanup(void)\n{\n\tssb_driver_unregister(&b44_ssb_driver);\n\tb44_pci_exit();\n}\n\nmodule_init(b44_init);\nmodule_exit(b44_cleanup);\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}