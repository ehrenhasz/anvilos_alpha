{
  "module_name": "cnic.c",
  "hash_id": "2cc845608f790372827c06b8bf778504ed1016c65e922ae680b7c41e4893d641",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/broadcom/cnic.c",
  "human_readable_source": " \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/init.h>\n#include <linux/netdevice.h>\n#include <linux/uio_driver.h>\n#include <linux/in.h>\n#include <linux/dma-mapping.h>\n#include <linux/delay.h>\n#include <linux/ethtool.h>\n#include <linux/if_vlan.h>\n#include <linux/prefetch.h>\n#include <linux/random.h>\n#if IS_ENABLED(CONFIG_VLAN_8021Q)\n#define BCM_VLAN 1\n#endif\n#include <net/ip.h>\n#include <net/tcp.h>\n#include <net/route.h>\n#include <net/ipv6.h>\n#include <net/ip6_route.h>\n#include <net/ip6_checksum.h>\n#include <scsi/iscsi_if.h>\n\n#define BCM_CNIC\t1\n#include \"cnic_if.h\"\n#include \"bnx2.h\"\n#include \"bnx2x/bnx2x.h\"\n#include \"bnx2x/bnx2x_reg.h\"\n#include \"bnx2x/bnx2x_fw_defs.h\"\n#include \"bnx2x/bnx2x_hsi.h\"\n#include \"../../../scsi/bnx2i/57xx_iscsi_constants.h\"\n#include \"../../../scsi/bnx2i/57xx_iscsi_hsi.h\"\n#include \"../../../scsi/bnx2fc/bnx2fc_constants.h\"\n#include \"cnic.h\"\n#include \"cnic_defs.h\"\n\n#define CNIC_MODULE_NAME\t\"cnic\"\n\nstatic char version[] =\n\t\"QLogic \" CNIC_MODULE_NAME \"Driver v\" CNIC_MODULE_VERSION \" (\" CNIC_MODULE_RELDATE \")\\n\";\n\nMODULE_AUTHOR(\"Michael Chan <mchan@broadcom.com> and John(Zongxi) \"\n\t      \"Chen (zongxi@broadcom.com\");\nMODULE_DESCRIPTION(\"QLogic cnic Driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(CNIC_MODULE_VERSION);\n\n \nstatic LIST_HEAD(cnic_dev_list);\nstatic LIST_HEAD(cnic_udev_list);\nstatic DEFINE_RWLOCK(cnic_dev_lock);\nstatic DEFINE_MUTEX(cnic_lock);\n\nstatic struct cnic_ulp_ops __rcu *cnic_ulp_tbl[MAX_CNIC_ULP_TYPE];\n\n \nstatic inline struct cnic_ulp_ops *cnic_ulp_tbl_prot(int type)\n{\n\treturn rcu_dereference_protected(cnic_ulp_tbl[type],\n\t\t\t\t\t lockdep_is_held(&cnic_lock));\n}\n\nstatic int cnic_service_bnx2(void *, void *);\nstatic int cnic_service_bnx2x(void *, void *);\nstatic int cnic_ctl(void *, struct cnic_ctl_info *);\n\nstatic struct cnic_ops cnic_bnx2_ops = {\n\t.cnic_owner\t= THIS_MODULE,\n\t.cnic_handler\t= cnic_service_bnx2,\n\t.cnic_ctl\t= cnic_ctl,\n};\n\nstatic struct cnic_ops cnic_bnx2x_ops = {\n\t.cnic_owner\t= THIS_MODULE,\n\t.cnic_handler\t= cnic_service_bnx2x,\n\t.cnic_ctl\t= cnic_ctl,\n};\n\nstatic struct workqueue_struct *cnic_wq;\n\nstatic void cnic_shutdown_rings(struct cnic_dev *);\nstatic void cnic_init_rings(struct cnic_dev *);\nstatic int cnic_cm_set_pg(struct cnic_sock *);\n\nstatic int cnic_uio_open(struct uio_info *uinfo, struct inode *inode)\n{\n\tstruct cnic_uio_dev *udev = uinfo->priv;\n\tstruct cnic_dev *dev;\n\n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tif (udev->uio_dev != -1)\n\t\treturn -EBUSY;\n\n\trtnl_lock();\n\tdev = udev->dev;\n\n\tif (!dev || !test_bit(CNIC_F_CNIC_UP, &dev->flags)) {\n\t\trtnl_unlock();\n\t\treturn -ENODEV;\n\t}\n\n\tudev->uio_dev = iminor(inode);\n\n\tcnic_shutdown_rings(dev);\n\tcnic_init_rings(dev);\n\trtnl_unlock();\n\n\treturn 0;\n}\n\nstatic int cnic_uio_close(struct uio_info *uinfo, struct inode *inode)\n{\n\tstruct cnic_uio_dev *udev = uinfo->priv;\n\n\tudev->uio_dev = -1;\n\treturn 0;\n}\n\nstatic inline void cnic_hold(struct cnic_dev *dev)\n{\n\tatomic_inc(&dev->ref_count);\n}\n\nstatic inline void cnic_put(struct cnic_dev *dev)\n{\n\tatomic_dec(&dev->ref_count);\n}\n\nstatic inline void csk_hold(struct cnic_sock *csk)\n{\n\tatomic_inc(&csk->ref_count);\n}\n\nstatic inline void csk_put(struct cnic_sock *csk)\n{\n\tatomic_dec(&csk->ref_count);\n}\n\nstatic struct cnic_dev *cnic_from_netdev(struct net_device *netdev)\n{\n\tstruct cnic_dev *cdev;\n\n\tread_lock(&cnic_dev_lock);\n\tlist_for_each_entry(cdev, &cnic_dev_list, list) {\n\t\tif (netdev == cdev->netdev) {\n\t\t\tcnic_hold(cdev);\n\t\t\tread_unlock(&cnic_dev_lock);\n\t\t\treturn cdev;\n\t\t}\n\t}\n\tread_unlock(&cnic_dev_lock);\n\treturn NULL;\n}\n\nstatic inline void ulp_get(struct cnic_ulp_ops *ulp_ops)\n{\n\tatomic_inc(&ulp_ops->ref_count);\n}\n\nstatic inline void ulp_put(struct cnic_ulp_ops *ulp_ops)\n{\n\tatomic_dec(&ulp_ops->ref_count);\n}\n\nstatic void cnic_ctx_wr(struct cnic_dev *dev, u32 cid_addr, u32 off, u32 val)\n{\n\tstruct cnic_local *cp = dev->cnic_priv;\n\tstruct cnic_eth_dev *ethdev = cp->ethdev;\n\tstruct drv_ctl_info info;\n\tstruct drv_ctl_io *io = &info.data.io;\n\n\tmemset(&info, 0, sizeof(struct drv_ctl_info));\n\tinfo.cmd = DRV_CTL_CTX_WR_CMD;\n\tio->cid_addr = cid_addr;\n\tio->offset = off;\n\tio->data = val;\n\tethdev->drv_ctl(dev->netdev, &info);\n}\n\nstatic void cnic_ctx_tbl_wr(struct cnic_dev *dev, u32 off, dma_addr_t addr)\n{\n\tstruct cnic_local *cp = dev->cnic_priv;\n\tstruct cnic_eth_dev *ethdev = cp->ethdev;\n\tstruct drv_ctl_info info;\n\tstruct drv_ctl_io *io = &info.data.io;\n\n\tmemset(&info, 0, sizeof(struct drv_ctl_info));\n\tinfo.cmd = DRV_CTL_CTXTBL_WR_CMD;\n\tio->offset = off;\n\tio->dma_addr = addr;\n\tethdev->drv_ctl(dev->netdev, &info);\n}\n\nstatic void cnic_ring_ctl(struct cnic_dev *dev, u32 cid, u32 cl_id, int start)\n{\n\tstruct cnic_local *cp = dev->cnic_priv;\n\tstruct cnic_eth_dev *ethdev = cp->ethdev;\n\tstruct drv_ctl_info info;\n\tstruct drv_ctl_l2_ring *ring = &info.data.ring;\n\n\tmemset(&info, 0, sizeof(struct drv_ctl_info));\n\tif (start)\n\t\tinfo.cmd = DRV_CTL_START_L2_CMD;\n\telse\n\t\tinfo.cmd = DRV_CTL_STOP_L2_CMD;\n\n\tring->cid = cid;\n\tring->client_id = cl_id;\n\tethdev->drv_ctl(dev->netdev, &info);\n}\n\nstatic void cnic_reg_wr_ind(struct cnic_dev *dev, u32 off, u32 val)\n{\n\tstruct cnic_local *cp = dev->cnic_priv;\n\tstruct cnic_eth_dev *ethdev = cp->ethdev;\n\tstruct drv_ctl_info info;\n\tstruct drv_ctl_io *io = &info.data.io;\n\n\tmemset(&info, 0, sizeof(struct drv_ctl_info));\n\tinfo.cmd = DRV_CTL_IO_WR_CMD;\n\tio->offset = off;\n\tio->data = val;\n\tethdev->drv_ctl(dev->netdev, &info);\n}\n\nstatic u32 cnic_reg_rd_ind(struct cnic_dev *dev, u32 off)\n{\n\tstruct cnic_local *cp = dev->cnic_priv;\n\tstruct cnic_eth_dev *ethdev = cp->ethdev;\n\tstruct drv_ctl_info info;\n\tstruct drv_ctl_io *io = &info.data.io;\n\n\tmemset(&info, 0, sizeof(struct drv_ctl_info));\n\tinfo.cmd = DRV_CTL_IO_RD_CMD;\n\tio->offset = off;\n\tethdev->drv_ctl(dev->netdev, &info);\n\treturn io->data;\n}\n\nstatic void cnic_ulp_ctl(struct cnic_dev *dev, int ulp_type, bool reg, int state)\n{\n\tstruct cnic_local *cp = dev->cnic_priv;\n\tstruct cnic_eth_dev *ethdev = cp->ethdev;\n\tstruct drv_ctl_info info;\n\tstruct fcoe_capabilities *fcoe_cap =\n\t\t&info.data.register_data.fcoe_features;\n\n\tmemset(&info, 0, sizeof(struct drv_ctl_info));\n\tif (reg) {\n\t\tinfo.cmd = DRV_CTL_ULP_REGISTER_CMD;\n\t\tif (ulp_type == CNIC_ULP_FCOE && dev->fcoe_cap)\n\t\t\tmemcpy(fcoe_cap, dev->fcoe_cap, sizeof(*fcoe_cap));\n\t} else {\n\t\tinfo.cmd = DRV_CTL_ULP_UNREGISTER_CMD;\n\t}\n\n\tinfo.data.ulp_type = ulp_type;\n\tinfo.drv_state = state;\n\tethdev->drv_ctl(dev->netdev, &info);\n}\n\nstatic int cnic_in_use(struct cnic_sock *csk)\n{\n\treturn test_bit(SK_F_INUSE, &csk->flags);\n}\n\nstatic void cnic_spq_completion(struct cnic_dev *dev, int cmd, u32 count)\n{\n\tstruct cnic_local *cp = dev->cnic_priv;\n\tstruct cnic_eth_dev *ethdev = cp->ethdev;\n\tstruct drv_ctl_info info;\n\n\tmemset(&info, 0, sizeof(struct drv_ctl_info));\n\tinfo.cmd = cmd;\n\tinfo.data.credit.credit_count = count;\n\tethdev->drv_ctl(dev->netdev, &info);\n}\n\nstatic int cnic_get_l5_cid(struct cnic_local *cp, u32 cid, u32 *l5_cid)\n{\n\tu32 i;\n\n\tif (!cp->ctx_tbl)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < cp->max_cid_space; i++) {\n\t\tif (cp->ctx_tbl[i].cid == cid) {\n\t\t\t*l5_cid = i;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -EINVAL;\n}\n\nstatic int cnic_send_nlmsg(struct cnic_local *cp, u32 type,\n\t\t\t   struct cnic_sock *csk)\n{\n\tstruct iscsi_path path_req;\n\tchar *buf = NULL;\n\tu16 len = 0;\n\tu32 msg_type = ISCSI_KEVENT_IF_DOWN;\n\tstruct cnic_ulp_ops *ulp_ops;\n\tstruct cnic_uio_dev *udev = cp->udev;\n\tint rc = 0, retry = 0;\n\n\tif (!udev || udev->uio_dev == -1)\n\t\treturn -ENODEV;\n\n\tif (csk) {\n\t\tlen = sizeof(path_req);\n\t\tbuf = (char *) &path_req;\n\t\tmemset(&path_req, 0, len);\n\n\t\tmsg_type = ISCSI_KEVENT_PATH_REQ;\n\t\tpath_req.handle = (u64) csk->l5_cid;\n\t\tif (test_bit(SK_F_IPV6, &csk->flags)) {\n\t\t\tmemcpy(&path_req.dst.v6_addr, &csk->dst_ip[0],\n\t\t\t       sizeof(struct in6_addr));\n\t\t\tpath_req.ip_addr_len = 16;\n\t\t} else {\n\t\t\tmemcpy(&path_req.dst.v4_addr, &csk->dst_ip[0],\n\t\t\t       sizeof(struct in_addr));\n\t\t\tpath_req.ip_addr_len = 4;\n\t\t}\n\t\tpath_req.vlan_id = csk->vlan_id;\n\t\tpath_req.pmtu = csk->mtu;\n\t}\n\n\twhile (retry < 3) {\n\t\trc = 0;\n\t\trcu_read_lock();\n\t\tulp_ops = rcu_dereference(cp->ulp_ops[CNIC_ULP_ISCSI]);\n\t\tif (ulp_ops)\n\t\t\trc = ulp_ops->iscsi_nl_send_msg(\n\t\t\t\tcp->ulp_handle[CNIC_ULP_ISCSI],\n\t\t\t\tmsg_type, buf, len);\n\t\trcu_read_unlock();\n\t\tif (rc == 0 || msg_type != ISCSI_KEVENT_PATH_REQ)\n\t\t\tbreak;\n\n\t\tmsleep(100);\n\t\tretry++;\n\t}\n\treturn rc;\n}\n\nstatic void cnic_cm_upcall(struct cnic_local *, struct cnic_sock *, u8);\n\nstatic int cnic_iscsi_nl_msg_recv(struct cnic_dev *dev, u32 msg_type,\n\t\t\t\t  char *buf, u16 len)\n{\n\tint rc = -EINVAL;\n\n\tswitch (msg_type) {\n\tcase ISCSI_UEVENT_PATH_UPDATE: {\n\t\tstruct cnic_local *cp;\n\t\tu32 l5_cid;\n\t\tstruct cnic_sock *csk;\n\t\tstruct iscsi_path *path_resp;\n\n\t\tif (len < sizeof(*path_resp))\n\t\t\tbreak;\n\n\t\tpath_resp = (struct iscsi_path *) buf;\n\t\tcp = dev->cnic_priv;\n\t\tl5_cid = (u32) path_resp->handle;\n\t\tif (l5_cid >= MAX_CM_SK_TBL_SZ)\n\t\t\tbreak;\n\n\t\tif (!rcu_access_pointer(cp->ulp_ops[CNIC_ULP_L4])) {\n\t\t\trc = -ENODEV;\n\t\t\tbreak;\n\t\t}\n\t\tcsk = &cp->csk_tbl[l5_cid];\n\t\tcsk_hold(csk);\n\t\tif (cnic_in_use(csk) &&\n\t\t    test_bit(SK_F_CONNECT_START, &csk->flags)) {\n\n\t\t\tcsk->vlan_id = path_resp->vlan_id;\n\n\t\t\tmemcpy(csk->ha, path_resp->mac_addr, ETH_ALEN);\n\t\t\tif (test_bit(SK_F_IPV6, &csk->flags))\n\t\t\t\tmemcpy(&csk->src_ip[0], &path_resp->src.v6_addr,\n\t\t\t\t       sizeof(struct in6_addr));\n\t\t\telse\n\t\t\t\tmemcpy(&csk->src_ip[0], &path_resp->src.v4_addr,\n\t\t\t\t       sizeof(struct in_addr));\n\n\t\t\tif (is_valid_ether_addr(csk->ha)) {\n\t\t\t\tcnic_cm_set_pg(csk);\n\t\t\t} else if (!test_bit(SK_F_OFFLD_SCHED, &csk->flags) &&\n\t\t\t\t!test_bit(SK_F_OFFLD_COMPLETE, &csk->flags)) {\n\n\t\t\t\tcnic_cm_upcall(cp, csk,\n\t\t\t\t\tL4_KCQE_OPCODE_VALUE_CONNECT_COMPLETE);\n\t\t\t\tclear_bit(SK_F_CONNECT_START, &csk->flags);\n\t\t\t}\n\t\t}\n\t\tcsk_put(csk);\n\t\trc = 0;\n\t}\n\t}\n\n\treturn rc;\n}\n\nstatic int cnic_offld_prep(struct cnic_sock *csk)\n{\n\tif (test_and_set_bit(SK_F_OFFLD_SCHED, &csk->flags))\n\t\treturn 0;\n\n\tif (!test_bit(SK_F_CONNECT_START, &csk->flags)) {\n\t\tclear_bit(SK_F_OFFLD_SCHED, &csk->flags);\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic int cnic_close_prep(struct cnic_sock *csk)\n{\n\tclear_bit(SK_F_CONNECT_START, &csk->flags);\n\tsmp_mb__after_atomic();\n\n\tif (test_and_clear_bit(SK_F_OFFLD_COMPLETE, &csk->flags)) {\n\t\twhile (test_and_set_bit(SK_F_OFFLD_SCHED, &csk->flags))\n\t\t\tmsleep(1);\n\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int cnic_abort_prep(struct cnic_sock *csk)\n{\n\tclear_bit(SK_F_CONNECT_START, &csk->flags);\n\tsmp_mb__after_atomic();\n\n\twhile (test_and_set_bit(SK_F_OFFLD_SCHED, &csk->flags))\n\t\tmsleep(1);\n\n\tif (test_and_clear_bit(SK_F_OFFLD_COMPLETE, &csk->flags)) {\n\t\tcsk->state = L4_KCQE_OPCODE_VALUE_RESET_COMP;\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nint cnic_register_driver(int ulp_type, struct cnic_ulp_ops *ulp_ops)\n{\n\tstruct cnic_dev *dev;\n\n\tif (ulp_type < 0 || ulp_type >= MAX_CNIC_ULP_TYPE) {\n\t\tpr_err(\"%s: Bad type %d\\n\", __func__, ulp_type);\n\t\treturn -EINVAL;\n\t}\n\tmutex_lock(&cnic_lock);\n\tif (cnic_ulp_tbl_prot(ulp_type)) {\n\t\tpr_err(\"%s: Type %d has already been registered\\n\",\n\t\t       __func__, ulp_type);\n\t\tmutex_unlock(&cnic_lock);\n\t\treturn -EBUSY;\n\t}\n\n\tread_lock(&cnic_dev_lock);\n\tlist_for_each_entry(dev, &cnic_dev_list, list) {\n\t\tstruct cnic_local *cp = dev->cnic_priv;\n\n\t\tclear_bit(ULP_F_INIT, &cp->ulp_flags[ulp_type]);\n\t}\n\tread_unlock(&cnic_dev_lock);\n\n\tatomic_set(&ulp_ops->ref_count, 0);\n\trcu_assign_pointer(cnic_ulp_tbl[ulp_type], ulp_ops);\n\tmutex_unlock(&cnic_lock);\n\n\t \n\trtnl_lock();\n\tlist_for_each_entry(dev, &cnic_dev_list, list) {\n\t\tstruct cnic_local *cp = dev->cnic_priv;\n\n\t\tif (!test_and_set_bit(ULP_F_INIT, &cp->ulp_flags[ulp_type]))\n\t\t\tulp_ops->cnic_init(dev);\n\t}\n\trtnl_unlock();\n\n\treturn 0;\n}\n\nint cnic_unregister_driver(int ulp_type)\n{\n\tstruct cnic_dev *dev;\n\tstruct cnic_ulp_ops *ulp_ops;\n\tint i = 0;\n\n\tif (ulp_type < 0 || ulp_type >= MAX_CNIC_ULP_TYPE) {\n\t\tpr_err(\"%s: Bad type %d\\n\", __func__, ulp_type);\n\t\treturn -EINVAL;\n\t}\n\tmutex_lock(&cnic_lock);\n\tulp_ops = cnic_ulp_tbl_prot(ulp_type);\n\tif (!ulp_ops) {\n\t\tpr_err(\"%s: Type %d has not been registered\\n\",\n\t\t       __func__, ulp_type);\n\t\tgoto out_unlock;\n\t}\n\tread_lock(&cnic_dev_lock);\n\tlist_for_each_entry(dev, &cnic_dev_list, list) {\n\t\tstruct cnic_local *cp = dev->cnic_priv;\n\n\t\tif (rcu_access_pointer(cp->ulp_ops[ulp_type])) {\n\t\t\tpr_err(\"%s: Type %d still has devices registered\\n\",\n\t\t\t       __func__, ulp_type);\n\t\t\tread_unlock(&cnic_dev_lock);\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\tread_unlock(&cnic_dev_lock);\n\n\tRCU_INIT_POINTER(cnic_ulp_tbl[ulp_type], NULL);\n\n\tmutex_unlock(&cnic_lock);\n\tsynchronize_rcu();\n\twhile ((atomic_read(&ulp_ops->ref_count) != 0) && (i < 20)) {\n\t\tmsleep(100);\n\t\ti++;\n\t}\n\n\tif (atomic_read(&ulp_ops->ref_count) != 0)\n\t\tpr_warn(\"%s: Failed waiting for ref count to go to zero\\n\",\n\t\t\t__func__);\n\treturn 0;\n\nout_unlock:\n\tmutex_unlock(&cnic_lock);\n\treturn -EINVAL;\n}\n\nstatic int cnic_start_hw(struct cnic_dev *);\nstatic void cnic_stop_hw(struct cnic_dev *);\n\nstatic int cnic_register_device(struct cnic_dev *dev, int ulp_type,\n\t\t\t\tvoid *ulp_ctx)\n{\n\tstruct cnic_local *cp = dev->cnic_priv;\n\tstruct cnic_ulp_ops *ulp_ops;\n\n\tif (ulp_type < 0 || ulp_type >= MAX_CNIC_ULP_TYPE) {\n\t\tpr_err(\"%s: Bad type %d\\n\", __func__, ulp_type);\n\t\treturn -EINVAL;\n\t}\n\tmutex_lock(&cnic_lock);\n\tif (cnic_ulp_tbl_prot(ulp_type) == NULL) {\n\t\tpr_err(\"%s: Driver with type %d has not been registered\\n\",\n\t\t       __func__, ulp_type);\n\t\tmutex_unlock(&cnic_lock);\n\t\treturn -EAGAIN;\n\t}\n\tif (rcu_access_pointer(cp->ulp_ops[ulp_type])) {\n\t\tpr_err(\"%s: Type %d has already been registered to this device\\n\",\n\t\t       __func__, ulp_type);\n\t\tmutex_unlock(&cnic_lock);\n\t\treturn -EBUSY;\n\t}\n\n\tclear_bit(ULP_F_START, &cp->ulp_flags[ulp_type]);\n\tcp->ulp_handle[ulp_type] = ulp_ctx;\n\tulp_ops = cnic_ulp_tbl_prot(ulp_type);\n\trcu_assign_pointer(cp->ulp_ops[ulp_type], ulp_ops);\n\tcnic_hold(dev);\n\n\tif (test_bit(CNIC_F_CNIC_UP, &dev->flags))\n\t\tif (!test_and_set_bit(ULP_F_START, &cp->ulp_flags[ulp_type]))\n\t\t\tulp_ops->cnic_start(cp->ulp_handle[ulp_type]);\n\n\tmutex_unlock(&cnic_lock);\n\n\tcnic_ulp_ctl(dev, ulp_type, true, DRV_ACTIVE);\n\n\treturn 0;\n\n}\nEXPORT_SYMBOL(cnic_register_driver);\n\nstatic int cnic_unregister_device(struct cnic_dev *dev, int ulp_type)\n{\n\tstruct cnic_local *cp = dev->cnic_priv;\n\tint i = 0;\n\n\tif (ulp_type < 0 || ulp_type >= MAX_CNIC_ULP_TYPE) {\n\t\tpr_err(\"%s: Bad type %d\\n\", __func__, ulp_type);\n\t\treturn -EINVAL;\n\t}\n\n\tif (ulp_type == CNIC_ULP_ISCSI)\n\t\tcnic_send_nlmsg(cp, ISCSI_KEVENT_IF_DOWN, NULL);\n\n\tmutex_lock(&cnic_lock);\n\tif (rcu_access_pointer(cp->ulp_ops[ulp_type])) {\n\t\tRCU_INIT_POINTER(cp->ulp_ops[ulp_type], NULL);\n\t\tcnic_put(dev);\n\t} else {\n\t\tpr_err(\"%s: device not registered to this ulp type %d\\n\",\n\t\t       __func__, ulp_type);\n\t\tmutex_unlock(&cnic_lock);\n\t\treturn -EINVAL;\n\t}\n\tmutex_unlock(&cnic_lock);\n\n\tif (ulp_type == CNIC_ULP_FCOE)\n\t\tdev->fcoe_cap = NULL;\n\n\tsynchronize_rcu();\n\n\twhile (test_bit(ULP_F_CALL_PENDING, &cp->ulp_flags[ulp_type]) &&\n\t       i < 20) {\n\t\tmsleep(100);\n\t\ti++;\n\t}\n\tif (test_bit(ULP_F_CALL_PENDING, &cp->ulp_flags[ulp_type]))\n\t\tnetdev_warn(dev->netdev, \"Failed waiting for ULP up call to complete\\n\");\n\n\tif (test_bit(ULP_F_INIT, &cp->ulp_flags[ulp_type]))\n\t\tcnic_ulp_ctl(dev, ulp_type, false, DRV_UNLOADED);\n\telse\n\t\tcnic_ulp_ctl(dev, ulp_type, false, DRV_INACTIVE);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(cnic_unregister_driver);\n\nstatic int cnic_init_id_tbl(struct cnic_id_tbl *id_tbl, u32 size, u32 start_id,\n\t\t\t    u32 next)\n{\n\tid_tbl->start = start_id;\n\tid_tbl->max = size;\n\tid_tbl->next = next;\n\tspin_lock_init(&id_tbl->lock);\n\tid_tbl->table = bitmap_zalloc(size, GFP_KERNEL);\n\tif (!id_tbl->table)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic void cnic_free_id_tbl(struct cnic_id_tbl *id_tbl)\n{\n\tbitmap_free(id_tbl->table);\n\tid_tbl->table = NULL;\n}\n\nstatic int cnic_alloc_id(struct cnic_id_tbl *id_tbl, u32 id)\n{\n\tint ret = -1;\n\n\tid -= id_tbl->start;\n\tif (id >= id_tbl->max)\n\t\treturn ret;\n\n\tspin_lock(&id_tbl->lock);\n\tif (!test_bit(id, id_tbl->table)) {\n\t\tset_bit(id, id_tbl->table);\n\t\tret = 0;\n\t}\n\tspin_unlock(&id_tbl->lock);\n\treturn ret;\n}\n\n \nstatic u32 cnic_alloc_new_id(struct cnic_id_tbl *id_tbl)\n{\n\tu32 id;\n\n\tspin_lock(&id_tbl->lock);\n\tid = find_next_zero_bit(id_tbl->table, id_tbl->max, id_tbl->next);\n\tif (id >= id_tbl->max) {\n\t\tid = -1;\n\t\tif (id_tbl->next != 0) {\n\t\t\tid = find_first_zero_bit(id_tbl->table, id_tbl->next);\n\t\t\tif (id >= id_tbl->next)\n\t\t\t\tid = -1;\n\t\t}\n\t}\n\n\tif (id < id_tbl->max) {\n\t\tset_bit(id, id_tbl->table);\n\t\tid_tbl->next = (id + 1) & (id_tbl->max - 1);\n\t\tid += id_tbl->start;\n\t}\n\n\tspin_unlock(&id_tbl->lock);\n\n\treturn id;\n}\n\nstatic void cnic_free_id(struct cnic_id_tbl *id_tbl, u32 id)\n{\n\tif (id == -1)\n\t\treturn;\n\n\tid -= id_tbl->start;\n\tif (id >= id_tbl->max)\n\t\treturn;\n\n\tclear_bit(id, id_tbl->table);\n}\n\nstatic void cnic_free_dma(struct cnic_dev *dev, struct cnic_dma *dma)\n{\n\tint i;\n\n\tif (!dma->pg_arr)\n\t\treturn;\n\n\tfor (i = 0; i < dma->num_pages; i++) {\n\t\tif (dma->pg_arr[i]) {\n\t\t\tdma_free_coherent(&dev->pcidev->dev, CNIC_PAGE_SIZE,\n\t\t\t\t\t  dma->pg_arr[i], dma->pg_map_arr[i]);\n\t\t\tdma->pg_arr[i] = NULL;\n\t\t}\n\t}\n\tif (dma->pgtbl) {\n\t\tdma_free_coherent(&dev->pcidev->dev, dma->pgtbl_size,\n\t\t\t\t  dma->pgtbl, dma->pgtbl_map);\n\t\tdma->pgtbl = NULL;\n\t}\n\tkfree(dma->pg_arr);\n\tdma->pg_arr = NULL;\n\tdma->num_pages = 0;\n}\n\nstatic void cnic_setup_page_tbl(struct cnic_dev *dev, struct cnic_dma *dma)\n{\n\tint i;\n\t__le32 *page_table = (__le32 *) dma->pgtbl;\n\n\tfor (i = 0; i < dma->num_pages; i++) {\n\t\t \n\t\t*page_table = cpu_to_le32((u64) dma->pg_map_arr[i] >> 32);\n\t\tpage_table++;\n\t\t*page_table = cpu_to_le32(dma->pg_map_arr[i] & 0xffffffff);\n\t\tpage_table++;\n\t}\n}\n\nstatic void cnic_setup_page_tbl_le(struct cnic_dev *dev, struct cnic_dma *dma)\n{\n\tint i;\n\t__le32 *page_table = (__le32 *) dma->pgtbl;\n\n\tfor (i = 0; i < dma->num_pages; i++) {\n\t\t \n\t\t*page_table = cpu_to_le32(dma->pg_map_arr[i] & 0xffffffff);\n\t\tpage_table++;\n\t\t*page_table = cpu_to_le32((u64) dma->pg_map_arr[i] >> 32);\n\t\tpage_table++;\n\t}\n}\n\nstatic int cnic_alloc_dma(struct cnic_dev *dev, struct cnic_dma *dma,\n\t\t\t  int pages, int use_pg_tbl)\n{\n\tint i, size;\n\tstruct cnic_local *cp = dev->cnic_priv;\n\n\tsize = pages * (sizeof(void *) + sizeof(dma_addr_t));\n\tdma->pg_arr = kzalloc(size, GFP_ATOMIC);\n\tif (dma->pg_arr == NULL)\n\t\treturn -ENOMEM;\n\n\tdma->pg_map_arr = (dma_addr_t *) (dma->pg_arr + pages);\n\tdma->num_pages = pages;\n\n\tfor (i = 0; i < pages; i++) {\n\t\tdma->pg_arr[i] = dma_alloc_coherent(&dev->pcidev->dev,\n\t\t\t\t\t\t    CNIC_PAGE_SIZE,\n\t\t\t\t\t\t    &dma->pg_map_arr[i],\n\t\t\t\t\t\t    GFP_ATOMIC);\n\t\tif (dma->pg_arr[i] == NULL)\n\t\t\tgoto error;\n\t}\n\tif (!use_pg_tbl)\n\t\treturn 0;\n\n\tdma->pgtbl_size = ((pages * 8) + CNIC_PAGE_SIZE - 1) &\n\t\t\t  ~(CNIC_PAGE_SIZE - 1);\n\tdma->pgtbl = dma_alloc_coherent(&dev->pcidev->dev, dma->pgtbl_size,\n\t\t\t\t\t&dma->pgtbl_map, GFP_ATOMIC);\n\tif (dma->pgtbl == NULL)\n\t\tgoto error;\n\n\tcp->setup_pgtbl(dev, dma);\n\n\treturn 0;\n\nerror:\n\tcnic_free_dma(dev, dma);\n\treturn -ENOMEM;\n}\n\nstatic void cnic_free_context(struct cnic_dev *dev)\n{\n\tstruct cnic_local *cp = dev->cnic_priv;\n\tint i;\n\n\tfor (i = 0; i < cp->ctx_blks; i++) {\n\t\tif (cp->ctx_arr[i].ctx) {\n\t\t\tdma_free_coherent(&dev->pcidev->dev, cp->ctx_blk_size,\n\t\t\t\t\t  cp->ctx_arr[i].ctx,\n\t\t\t\t\t  cp->ctx_arr[i].mapping);\n\t\t\tcp->ctx_arr[i].ctx = NULL;\n\t\t}\n\t}\n}\n\nstatic void __cnic_free_uio_rings(struct cnic_uio_dev *udev)\n{\n\tif (udev->l2_buf) {\n\t\tdma_free_coherent(&udev->pdev->dev, udev->l2_buf_size,\n\t\t\t\t  udev->l2_buf, udev->l2_buf_map);\n\t\tudev->l2_buf = NULL;\n\t}\n\n\tif (udev->l2_ring) {\n\t\tdma_free_coherent(&udev->pdev->dev, udev->l2_ring_size,\n\t\t\t\t  udev->l2_ring, udev->l2_ring_map);\n\t\tudev->l2_ring = NULL;\n\t}\n\n}\n\nstatic void __cnic_free_uio(struct cnic_uio_dev *udev)\n{\n\tuio_unregister_device(&udev->cnic_uinfo);\n\n\t__cnic_free_uio_rings(udev);\n\n\tpci_dev_put(udev->pdev);\n\tkfree(udev);\n}\n\nstatic void cnic_free_uio(struct cnic_uio_dev *udev)\n{\n\tif (!udev)\n\t\treturn;\n\n\twrite_lock(&cnic_dev_lock);\n\tlist_del_init(&udev->list);\n\twrite_unlock(&cnic_dev_lock);\n\t__cnic_free_uio(udev);\n}\n\nstatic void cnic_free_resc(struct cnic_dev *dev)\n{\n\tstruct cnic_local *cp = dev->cnic_priv;\n\tstruct cnic_uio_dev *udev = cp->udev;\n\n\tif (udev) {\n\t\tudev->dev = NULL;\n\t\tcp->udev = NULL;\n\t\tif (udev->uio_dev == -1)\n\t\t\t__cnic_free_uio_rings(udev);\n\t}\n\n\tcnic_free_context(dev);\n\tkfree(cp->ctx_arr);\n\tcp->ctx_arr = NULL;\n\tcp->ctx_blks = 0;\n\n\tcnic_free_dma(dev, &cp->gbl_buf_info);\n\tcnic_free_dma(dev, &cp->kwq_info);\n\tcnic_free_dma(dev, &cp->kwq_16_data_info);\n\tcnic_free_dma(dev, &cp->kcq2.dma);\n\tcnic_free_dma(dev, &cp->kcq1.dma);\n\tkfree(cp->iscsi_tbl);\n\tcp->iscsi_tbl = NULL;\n\tkfree(cp->ctx_tbl);\n\tcp->ctx_tbl = NULL;\n\n\tcnic_free_id_tbl(&cp->fcoe_cid_tbl);\n\tcnic_free_id_tbl(&cp->cid_tbl);\n}\n\nstatic int cnic_alloc_context(struct cnic_dev *dev)\n{\n\tstruct cnic_local *cp = dev->cnic_priv;\n\n\tif (BNX2_CHIP(cp) == BNX2_CHIP_5709) {\n\t\tint i, k, arr_size;\n\n\t\tcp->ctx_blk_size = CNIC_PAGE_SIZE;\n\t\tcp->cids_per_blk = CNIC_PAGE_SIZE / 128;\n\t\tarr_size = BNX2_MAX_CID / cp->cids_per_blk *\n\t\t\t   sizeof(struct cnic_ctx);\n\t\tcp->ctx_arr = kzalloc(arr_size, GFP_KERNEL);\n\t\tif (cp->ctx_arr == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\tk = 0;\n\t\tfor (i = 0; i < 2; i++) {\n\t\t\tu32 j, reg, off, lo, hi;\n\n\t\t\tif (i == 0)\n\t\t\t\toff = BNX2_PG_CTX_MAP;\n\t\t\telse\n\t\t\t\toff = BNX2_ISCSI_CTX_MAP;\n\n\t\t\treg = cnic_reg_rd_ind(dev, off);\n\t\t\tlo = reg >> 16;\n\t\t\thi = reg & 0xffff;\n\t\t\tfor (j = lo; j < hi; j += cp->cids_per_blk, k++)\n\t\t\t\tcp->ctx_arr[k].cid = j;\n\t\t}\n\n\t\tcp->ctx_blks = k;\n\t\tif (cp->ctx_blks >= (BNX2_MAX_CID / cp->cids_per_blk)) {\n\t\t\tcp->ctx_blks = 0;\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tfor (i = 0; i < cp->ctx_blks; i++) {\n\t\t\tcp->ctx_arr[i].ctx =\n\t\t\t\tdma_alloc_coherent(&dev->pcidev->dev,\n\t\t\t\t\t\t   CNIC_PAGE_SIZE,\n\t\t\t\t\t\t   &cp->ctx_arr[i].mapping,\n\t\t\t\t\t\t   GFP_KERNEL);\n\t\t\tif (cp->ctx_arr[i].ctx == NULL)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic u16 cnic_bnx2_next_idx(u16 idx)\n{\n\treturn idx + 1;\n}\n\nstatic u16 cnic_bnx2_hw_idx(u16 idx)\n{\n\treturn idx;\n}\n\nstatic u16 cnic_bnx2x_next_idx(u16 idx)\n{\n\tidx++;\n\tif ((idx & MAX_KCQE_CNT) == MAX_KCQE_CNT)\n\t\tidx++;\n\n\treturn idx;\n}\n\nstatic u16 cnic_bnx2x_hw_idx(u16 idx)\n{\n\tif ((idx & MAX_KCQE_CNT) == MAX_KCQE_CNT)\n\t\tidx++;\n\treturn idx;\n}\n\nstatic int cnic_alloc_kcq(struct cnic_dev *dev, struct kcq_info *info,\n\t\t\t  bool use_pg_tbl)\n{\n\tint err, i, use_page_tbl = 0;\n\tstruct kcqe **kcq;\n\n\tif (use_pg_tbl)\n\t\tuse_page_tbl = 1;\n\n\terr = cnic_alloc_dma(dev, &info->dma, KCQ_PAGE_CNT, use_page_tbl);\n\tif (err)\n\t\treturn err;\n\n\tkcq = (struct kcqe **) info->dma.pg_arr;\n\tinfo->kcq = kcq;\n\n\tinfo->next_idx = cnic_bnx2_next_idx;\n\tinfo->hw_idx = cnic_bnx2_hw_idx;\n\tif (use_pg_tbl)\n\t\treturn 0;\n\n\tinfo->next_idx = cnic_bnx2x_next_idx;\n\tinfo->hw_idx = cnic_bnx2x_hw_idx;\n\n\tfor (i = 0; i < KCQ_PAGE_CNT; i++) {\n\t\tstruct bnx2x_bd_chain_next *next =\n\t\t\t(struct bnx2x_bd_chain_next *) &kcq[i][MAX_KCQE_CNT];\n\t\tint j = i + 1;\n\n\t\tif (j >= KCQ_PAGE_CNT)\n\t\t\tj = 0;\n\t\tnext->addr_hi = (u64) info->dma.pg_map_arr[j] >> 32;\n\t\tnext->addr_lo = info->dma.pg_map_arr[j] & 0xffffffff;\n\t}\n\treturn 0;\n}\n\nstatic int __cnic_alloc_uio_rings(struct cnic_uio_dev *udev, int pages)\n{\n\tstruct cnic_local *cp = udev->dev->cnic_priv;\n\n\tif (udev->l2_ring)\n\t\treturn 0;\n\n\tudev->l2_ring_size = pages * CNIC_PAGE_SIZE;\n\tudev->l2_ring = dma_alloc_coherent(&udev->pdev->dev, udev->l2_ring_size,\n\t\t\t\t\t   &udev->l2_ring_map, GFP_KERNEL);\n\tif (!udev->l2_ring)\n\t\treturn -ENOMEM;\n\n\tudev->l2_buf_size = (cp->l2_rx_ring_size + 1) * cp->l2_single_buf_size;\n\tudev->l2_buf_size = CNIC_PAGE_ALIGN(udev->l2_buf_size);\n\tudev->l2_buf = dma_alloc_coherent(&udev->pdev->dev, udev->l2_buf_size,\n\t\t\t\t\t  &udev->l2_buf_map, GFP_KERNEL);\n\tif (!udev->l2_buf) {\n\t\t__cnic_free_uio_rings(udev);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n\n}\n\nstatic int cnic_alloc_uio_rings(struct cnic_dev *dev, int pages)\n{\n\tstruct cnic_local *cp = dev->cnic_priv;\n\tstruct cnic_uio_dev *udev;\n\n\tlist_for_each_entry(udev, &cnic_udev_list, list) {\n\t\tif (udev->pdev == dev->pcidev) {\n\t\t\tudev->dev = dev;\n\t\t\tif (__cnic_alloc_uio_rings(udev, pages)) {\n\t\t\t\tudev->dev = NULL;\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tcp->udev = udev;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tudev = kzalloc(sizeof(struct cnic_uio_dev), GFP_ATOMIC);\n\tif (!udev)\n\t\treturn -ENOMEM;\n\n\tudev->uio_dev = -1;\n\n\tudev->dev = dev;\n\tudev->pdev = dev->pcidev;\n\n\tif (__cnic_alloc_uio_rings(udev, pages))\n\t\tgoto err_udev;\n\n\tlist_add(&udev->list, &cnic_udev_list);\n\n\tpci_dev_get(udev->pdev);\n\n\tcp->udev = udev;\n\n\treturn 0;\n\n err_udev:\n\tkfree(udev);\n\treturn -ENOMEM;\n}\n\nstatic int cnic_init_uio(struct cnic_dev *dev)\n{\n\tstruct cnic_local *cp = dev->cnic_priv;\n\tstruct cnic_uio_dev *udev = cp->udev;\n\tstruct uio_info *uinfo;\n\tint ret = 0;\n\n\tif (!udev)\n\t\treturn -ENOMEM;\n\n\tuinfo = &udev->cnic_uinfo;\n\n\tuinfo->mem[0].addr = pci_resource_start(dev->pcidev, 0);\n\tuinfo->mem[0].internal_addr = dev->regview;\n\tuinfo->mem[0].memtype = UIO_MEM_PHYS;\n\n\tif (test_bit(CNIC_F_BNX2_CLASS, &dev->flags)) {\n\t\tuinfo->mem[0].size = MB_GET_CID_ADDR(TX_TSS_CID +\n\t\t\t\t\t\t     TX_MAX_TSS_RINGS + 1);\n\t\tuinfo->mem[1].addr = (unsigned long) cp->status_blk.gen &\n\t\t\t\t\tCNIC_PAGE_MASK;\n\t\tif (cp->ethdev->drv_state & CNIC_DRV_STATE_USING_MSIX)\n\t\t\tuinfo->mem[1].size = BNX2_SBLK_MSIX_ALIGN_SIZE * 9;\n\t\telse\n\t\t\tuinfo->mem[1].size = BNX2_SBLK_MSIX_ALIGN_SIZE;\n\n\t\tuinfo->name = \"bnx2_cnic\";\n\t} else if (test_bit(CNIC_F_BNX2X_CLASS, &dev->flags)) {\n\t\tuinfo->mem[0].size = pci_resource_len(dev->pcidev, 0);\n\n\t\tuinfo->mem[1].addr = (unsigned long) cp->bnx2x_def_status_blk &\n\t\t\tCNIC_PAGE_MASK;\n\t\tuinfo->mem[1].size = sizeof(*cp->bnx2x_def_status_blk);\n\n\t\tuinfo->name = \"bnx2x_cnic\";\n\t}\n\n\tuinfo->mem[1].memtype = UIO_MEM_LOGICAL;\n\n\tuinfo->mem[2].addr = (unsigned long) udev->l2_ring;\n\tuinfo->mem[2].size = udev->l2_ring_size;\n\tuinfo->mem[2].memtype = UIO_MEM_LOGICAL;\n\n\tuinfo->mem[3].addr = (unsigned long) udev->l2_buf;\n\tuinfo->mem[3].size = udev->l2_buf_size;\n\tuinfo->mem[3].memtype = UIO_MEM_LOGICAL;\n\n\tuinfo->version = CNIC_MODULE_VERSION;\n\tuinfo->irq = UIO_IRQ_CUSTOM;\n\n\tuinfo->open = cnic_uio_open;\n\tuinfo->release = cnic_uio_close;\n\n\tif (udev->uio_dev == -1) {\n\t\tif (!uinfo->priv) {\n\t\t\tuinfo->priv = udev;\n\n\t\t\tret = uio_register_device(&udev->pdev->dev, uinfo);\n\t\t}\n\t} else {\n\t\tcnic_init_rings(dev);\n\t}\n\n\treturn ret;\n}\n\nstatic int cnic_alloc_bnx2_resc(struct cnic_dev *dev)\n{\n\tstruct cnic_local *cp = dev->cnic_priv;\n\tint ret;\n\n\tret = cnic_alloc_dma(dev, &cp->kwq_info, KWQ_PAGE_CNT, 1);\n\tif (ret)\n\t\tgoto error;\n\tcp->kwq = (struct kwqe **) cp->kwq_info.pg_arr;\n\n\tret = cnic_alloc_kcq(dev, &cp->kcq1, true);\n\tif (ret)\n\t\tgoto error;\n\n\tret = cnic_alloc_context(dev);\n\tif (ret)\n\t\tgoto error;\n\n\tret = cnic_alloc_uio_rings(dev, 2);\n\tif (ret)\n\t\tgoto error;\n\n\tret = cnic_init_uio(dev);\n\tif (ret)\n\t\tgoto error;\n\n\treturn 0;\n\nerror:\n\tcnic_free_resc(dev);\n\treturn ret;\n}\n\nstatic int cnic_alloc_bnx2x_context(struct cnic_dev *dev)\n{\n\tstruct cnic_local *cp = dev->cnic_priv;\n\tstruct bnx2x *bp = netdev_priv(dev->netdev);\n\tint ctx_blk_size = cp->ethdev->ctx_blk_size;\n\tint total_mem, blks, i;\n\n\ttotal_mem = BNX2X_CONTEXT_MEM_SIZE * cp->max_cid_space;\n\tblks = total_mem / ctx_blk_size;\n\tif (total_mem % ctx_blk_size)\n\t\tblks++;\n\n\tif (blks > cp->ethdev->ctx_tbl_len)\n\t\treturn -ENOMEM;\n\n\tcp->ctx_arr = kcalloc(blks, sizeof(struct cnic_ctx), GFP_KERNEL);\n\tif (cp->ctx_arr == NULL)\n\t\treturn -ENOMEM;\n\n\tcp->ctx_blks = blks;\n\tcp->ctx_blk_size = ctx_blk_size;\n\tif (!CHIP_IS_E1(bp))\n\t\tcp->ctx_align = 0;\n\telse\n\t\tcp->ctx_align = ctx_blk_size;\n\n\tcp->cids_per_blk = ctx_blk_size / BNX2X_CONTEXT_MEM_SIZE;\n\n\tfor (i = 0; i < blks; i++) {\n\t\tcp->ctx_arr[i].ctx =\n\t\t\tdma_alloc_coherent(&dev->pcidev->dev, cp->ctx_blk_size,\n\t\t\t\t\t   &cp->ctx_arr[i].mapping,\n\t\t\t\t\t   GFP_KERNEL);\n\t\tif (cp->ctx_arr[i].ctx == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\tif (cp->ctx_align && cp->ctx_blk_size == ctx_blk_size) {\n\t\t\tif (cp->ctx_arr[i].mapping & (cp->ctx_align - 1)) {\n\t\t\t\tcnic_free_context(dev);\n\t\t\t\tcp->ctx_blk_size += cp->ctx_align;\n\t\t\t\ti = -1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int cnic_alloc_bnx2x_resc(struct cnic_dev *dev)\n{\n\tstruct cnic_local *cp = dev->cnic_priv;\n\tstruct bnx2x *bp = netdev_priv(dev->netdev);\n\tstruct cnic_eth_dev *ethdev = cp->ethdev;\n\tu32 start_cid = ethdev->starting_cid;\n\tint i, j, n, ret, pages;\n\tstruct cnic_dma *kwq_16_dma = &cp->kwq_16_data_info;\n\n\tcp->max_cid_space = MAX_ISCSI_TBL_SZ;\n\tcp->iscsi_start_cid = start_cid;\n\tcp->fcoe_start_cid = start_cid + MAX_ISCSI_TBL_SZ;\n\n\tif (BNX2X_CHIP_IS_E2_PLUS(bp)) {\n\t\tcp->max_cid_space += dev->max_fcoe_conn;\n\t\tcp->fcoe_init_cid = ethdev->fcoe_init_cid;\n\t\tif (!cp->fcoe_init_cid)\n\t\t\tcp->fcoe_init_cid = 0x10;\n\t}\n\n\tcp->iscsi_tbl = kcalloc(MAX_ISCSI_TBL_SZ, sizeof(struct cnic_iscsi),\n\t\t\t\tGFP_KERNEL);\n\tif (!cp->iscsi_tbl)\n\t\tgoto error;\n\n\tcp->ctx_tbl = kcalloc(cp->max_cid_space, sizeof(struct cnic_context),\n\t\t\t      GFP_KERNEL);\n\tif (!cp->ctx_tbl)\n\t\tgoto error;\n\n\tfor (i = 0; i < MAX_ISCSI_TBL_SZ; i++) {\n\t\tcp->ctx_tbl[i].proto.iscsi = &cp->iscsi_tbl[i];\n\t\tcp->ctx_tbl[i].ulp_proto_id = CNIC_ULP_ISCSI;\n\t}\n\n\tfor (i = MAX_ISCSI_TBL_SZ; i < cp->max_cid_space; i++)\n\t\tcp->ctx_tbl[i].ulp_proto_id = CNIC_ULP_FCOE;\n\n\tpages = CNIC_PAGE_ALIGN(cp->max_cid_space * CNIC_KWQ16_DATA_SIZE) /\n\t\tCNIC_PAGE_SIZE;\n\n\tret = cnic_alloc_dma(dev, kwq_16_dma, pages, 0);\n\tif (ret)\n\t\tgoto error;\n\n\tn = CNIC_PAGE_SIZE / CNIC_KWQ16_DATA_SIZE;\n\tfor (i = 0, j = 0; i < cp->max_cid_space; i++) {\n\t\tlong off = CNIC_KWQ16_DATA_SIZE * (i % n);\n\n\t\tcp->ctx_tbl[i].kwqe_data = kwq_16_dma->pg_arr[j] + off;\n\t\tcp->ctx_tbl[i].kwqe_data_mapping = kwq_16_dma->pg_map_arr[j] +\n\t\t\t\t\t\t   off;\n\n\t\tif ((i % n) == (n - 1))\n\t\t\tj++;\n\t}\n\n\tret = cnic_alloc_kcq(dev, &cp->kcq1, false);\n\tif (ret)\n\t\tgoto error;\n\n\tif (CNIC_SUPPORTS_FCOE(bp)) {\n\t\tret = cnic_alloc_kcq(dev, &cp->kcq2, true);\n\t\tif (ret)\n\t\t\tgoto error;\n\t}\n\n\tpages = CNIC_PAGE_ALIGN(BNX2X_ISCSI_GLB_BUF_SIZE) / CNIC_PAGE_SIZE;\n\tret = cnic_alloc_dma(dev, &cp->gbl_buf_info, pages, 0);\n\tif (ret)\n\t\tgoto error;\n\n\tret = cnic_alloc_bnx2x_context(dev);\n\tif (ret)\n\t\tgoto error;\n\n\tif (cp->ethdev->drv_state & CNIC_DRV_STATE_NO_ISCSI)\n\t\treturn 0;\n\n\tcp->bnx2x_def_status_blk = cp->ethdev->irq_arr[1].status_blk;\n\n\tcp->l2_rx_ring_size = 15;\n\n\tret = cnic_alloc_uio_rings(dev, 4);\n\tif (ret)\n\t\tgoto error;\n\n\tret = cnic_init_uio(dev);\n\tif (ret)\n\t\tgoto error;\n\n\treturn 0;\n\nerror:\n\tcnic_free_resc(dev);\n\treturn -ENOMEM;\n}\n\nstatic inline u32 cnic_kwq_avail(struct cnic_local *cp)\n{\n\treturn cp->max_kwq_idx -\n\t\t((cp->kwq_prod_idx - cp->kwq_con_idx) & cp->max_kwq_idx);\n}\n\nstatic int cnic_submit_bnx2_kwqes(struct cnic_dev *dev, struct kwqe *wqes[],\n\t\t\t\t  u32 num_wqes)\n{\n\tstruct cnic_local *cp = dev->cnic_priv;\n\tstruct kwqe *prod_qe;\n\tu16 prod, sw_prod, i;\n\n\tif (!test_bit(CNIC_F_CNIC_UP, &dev->flags))\n\t\treturn -EAGAIN;\t\t \n\n\tspin_lock_bh(&cp->cnic_ulp_lock);\n\tif (num_wqes > cnic_kwq_avail(cp) &&\n\t    !test_bit(CNIC_LCL_FL_KWQ_INIT, &cp->cnic_local_flags)) {\n\t\tspin_unlock_bh(&cp->cnic_ulp_lock);\n\t\treturn -EAGAIN;\n\t}\n\n\tclear_bit(CNIC_LCL_FL_KWQ_INIT, &cp->cnic_local_flags);\n\n\tprod = cp->kwq_prod_idx;\n\tsw_prod = prod & MAX_KWQ_IDX;\n\tfor (i = 0; i < num_wqes; i++) {\n\t\tprod_qe = &cp->kwq[KWQ_PG(sw_prod)][KWQ_IDX(sw_prod)];\n\t\tmemcpy(prod_qe, wqes[i], sizeof(struct kwqe));\n\t\tprod++;\n\t\tsw_prod = prod & MAX_KWQ_IDX;\n\t}\n\tcp->kwq_prod_idx = prod;\n\n\tCNIC_WR16(dev, cp->kwq_io_addr, cp->kwq_prod_idx);\n\n\tspin_unlock_bh(&cp->cnic_ulp_lock);\n\treturn 0;\n}\n\nstatic void *cnic_get_kwqe_16_data(struct cnic_local *cp, u32 l5_cid,\n\t\t\t\t   union l5cm_specific_data *l5_data)\n{\n\tstruct cnic_context *ctx = &cp->ctx_tbl[l5_cid];\n\tdma_addr_t map;\n\n\tmap = ctx->kwqe_data_mapping;\n\tl5_data->phy_address.lo = (u64) map & 0xffffffff;\n\tl5_data->phy_address.hi = (u64) map >> 32;\n\treturn ctx->kwqe_data;\n}\n\nstatic int cnic_submit_kwqe_16(struct cnic_dev *dev, u32 cmd, u32 cid,\n\t\t\t\tu32 type, union l5cm_specific_data *l5_data)\n{\n\tstruct cnic_local *cp = dev->cnic_priv;\n\tstruct bnx2x *bp = netdev_priv(dev->netdev);\n\tstruct l5cm_spe kwqe;\n\tstruct kwqe_16 *kwq[1];\n\tu16 type_16;\n\tint ret;\n\n\tkwqe.hdr.conn_and_cmd_data =\n\t\tcpu_to_le32(((cmd << SPE_HDR_CMD_ID_SHIFT) |\n\t\t\t     BNX2X_HW_CID(bp, cid)));\n\n\ttype_16 = (type << SPE_HDR_CONN_TYPE_SHIFT) & SPE_HDR_CONN_TYPE;\n\ttype_16 |= (bp->pfid << SPE_HDR_FUNCTION_ID_SHIFT) &\n\t\t   SPE_HDR_FUNCTION_ID;\n\n\tkwqe.hdr.type = cpu_to_le16(type_16);\n\tkwqe.hdr.reserved1 = 0;\n\tkwqe.data.phy_address.lo = cpu_to_le32(l5_data->phy_address.lo);\n\tkwqe.data.phy_address.hi = cpu_to_le32(l5_data->phy_address.hi);\n\n\tkwq[0] = (struct kwqe_16 *) &kwqe;\n\n\tspin_lock_bh(&cp->cnic_ulp_lock);\n\tret = cp->ethdev->drv_submit_kwqes_16(dev->netdev, kwq, 1);\n\tspin_unlock_bh(&cp->cnic_ulp_lock);\n\n\tif (ret == 1)\n\t\treturn 0;\n\n\treturn ret;\n}\n\nstatic void cnic_reply_bnx2x_kcqes(struct cnic_dev *dev, int ulp_type,\n\t\t\t\t   struct kcqe *cqes[], u32 num_cqes)\n{\n\tstruct cnic_local *cp = dev->cnic_priv;\n\tstruct cnic_ulp_ops *ulp_ops;\n\n\trcu_read_lock();\n\tulp_ops = rcu_dereference(cp->ulp_ops[ulp_type]);\n\tif (likely(ulp_ops)) {\n\t\tulp_ops->indicate_kcqes(cp->ulp_handle[ulp_type],\n\t\t\t\t\t  cqes, num_cqes);\n\t}\n\trcu_read_unlock();\n}\n\nstatic void cnic_bnx2x_set_tcp_options(struct cnic_dev *dev, int time_stamps,\n\t\t\t\t       int en_tcp_dack)\n{\n\tstruct bnx2x *bp = netdev_priv(dev->netdev);\n\tu8 xstorm_flags = XSTORM_L5CM_TCP_FLAGS_WND_SCL_EN;\n\tu16 tstorm_flags = 0;\n\n\tif (time_stamps) {\n\t\txstorm_flags |= XSTORM_L5CM_TCP_FLAGS_TS_ENABLED;\n\t\ttstorm_flags |= TSTORM_L5CM_TCP_FLAGS_TS_ENABLED;\n\t}\n\tif (en_tcp_dack)\n\t\ttstorm_flags |= TSTORM_L5CM_TCP_FLAGS_DELAYED_ACK_EN;\n\n\tCNIC_WR8(dev, BAR_XSTRORM_INTMEM +\n\t\t XSTORM_ISCSI_TCP_VARS_FLAGS_OFFSET(bp->pfid), xstorm_flags);\n\n\tCNIC_WR16(dev, BAR_TSTRORM_INTMEM +\n\t\t  TSTORM_ISCSI_TCP_VARS_FLAGS_OFFSET(bp->pfid), tstorm_flags);\n}\n\nstatic int cnic_bnx2x_iscsi_init1(struct cnic_dev *dev, struct kwqe *kwqe)\n{\n\tstruct cnic_local *cp = dev->cnic_priv;\n\tstruct bnx2x *bp = netdev_priv(dev->netdev);\n\tstruct iscsi_kwqe_init1 *req1 = (struct iscsi_kwqe_init1 *) kwqe;\n\tint hq_bds, pages;\n\tu32 pfid = bp->pfid;\n\n\tcp->num_iscsi_tasks = req1->num_tasks_per_conn;\n\tcp->num_ccells = req1->num_ccells_per_conn;\n\tcp->task_array_size = BNX2X_ISCSI_TASK_CONTEXT_SIZE *\n\t\t\t      cp->num_iscsi_tasks;\n\tcp->r2tq_size = cp->num_iscsi_tasks * BNX2X_ISCSI_MAX_PENDING_R2TS *\n\t\t\tBNX2X_ISCSI_R2TQE_SIZE;\n\tcp->hq_size = cp->num_ccells * BNX2X_ISCSI_HQ_BD_SIZE;\n\tpages = CNIC_PAGE_ALIGN(cp->hq_size) / CNIC_PAGE_SIZE;\n\thq_bds = pages * (CNIC_PAGE_SIZE / BNX2X_ISCSI_HQ_BD_SIZE);\n\tcp->num_cqs = req1->num_cqs;\n\n\tif (!dev->max_iscsi_conn)\n\t\treturn 0;\n\n\t \n\tCNIC_WR16(dev, BAR_TSTRORM_INTMEM + TSTORM_ISCSI_RQ_SIZE_OFFSET(pfid),\n\t\t  req1->rq_num_wqes);\n\tCNIC_WR16(dev, BAR_TSTRORM_INTMEM + TSTORM_ISCSI_PAGE_SIZE_OFFSET(pfid),\n\t\t  CNIC_PAGE_SIZE);\n\tCNIC_WR8(dev, BAR_TSTRORM_INTMEM +\n\t\t TSTORM_ISCSI_PAGE_SIZE_LOG_OFFSET(pfid), CNIC_PAGE_BITS);\n\tCNIC_WR16(dev, BAR_TSTRORM_INTMEM +\n\t\t  TSTORM_ISCSI_NUM_OF_TASKS_OFFSET(pfid),\n\t\t  req1->num_tasks_per_conn);\n\n\t \n\tCNIC_WR16(dev, BAR_USTRORM_INTMEM +\n\t\t  USTORM_ISCSI_RQ_BUFFER_SIZE_OFFSET(pfid),\n\t\t  req1->rq_buffer_size);\n\tCNIC_WR16(dev, BAR_USTRORM_INTMEM + USTORM_ISCSI_PAGE_SIZE_OFFSET(pfid),\n\t\t  CNIC_PAGE_SIZE);\n\tCNIC_WR8(dev, BAR_USTRORM_INTMEM +\n\t\t USTORM_ISCSI_PAGE_SIZE_LOG_OFFSET(pfid), CNIC_PAGE_BITS);\n\tCNIC_WR16(dev, BAR_USTRORM_INTMEM +\n\t\t  USTORM_ISCSI_NUM_OF_TASKS_OFFSET(pfid),\n\t\t  req1->num_tasks_per_conn);\n\tCNIC_WR16(dev, BAR_USTRORM_INTMEM + USTORM_ISCSI_RQ_SIZE_OFFSET(pfid),\n\t\t  req1->rq_num_wqes);\n\tCNIC_WR16(dev, BAR_USTRORM_INTMEM + USTORM_ISCSI_CQ_SIZE_OFFSET(pfid),\n\t\t  req1->cq_num_wqes);\n\tCNIC_WR16(dev, BAR_USTRORM_INTMEM + USTORM_ISCSI_R2TQ_SIZE_OFFSET(pfid),\n\t\t  cp->num_iscsi_tasks * BNX2X_ISCSI_MAX_PENDING_R2TS);\n\n\t \n\tCNIC_WR16(dev, BAR_XSTRORM_INTMEM + XSTORM_ISCSI_PAGE_SIZE_OFFSET(pfid),\n\t\t  CNIC_PAGE_SIZE);\n\tCNIC_WR8(dev, BAR_XSTRORM_INTMEM +\n\t\t XSTORM_ISCSI_PAGE_SIZE_LOG_OFFSET(pfid), CNIC_PAGE_BITS);\n\tCNIC_WR16(dev, BAR_XSTRORM_INTMEM +\n\t\t  XSTORM_ISCSI_NUM_OF_TASKS_OFFSET(pfid),\n\t\t  req1->num_tasks_per_conn);\n\tCNIC_WR16(dev, BAR_XSTRORM_INTMEM + XSTORM_ISCSI_HQ_SIZE_OFFSET(pfid),\n\t\t  hq_bds);\n\tCNIC_WR16(dev, BAR_XSTRORM_INTMEM + XSTORM_ISCSI_SQ_SIZE_OFFSET(pfid),\n\t\t  req1->num_tasks_per_conn);\n\tCNIC_WR16(dev, BAR_XSTRORM_INTMEM + XSTORM_ISCSI_R2TQ_SIZE_OFFSET(pfid),\n\t\t  cp->num_iscsi_tasks * BNX2X_ISCSI_MAX_PENDING_R2TS);\n\n\t \n\tCNIC_WR16(dev, BAR_CSTRORM_INTMEM + CSTORM_ISCSI_PAGE_SIZE_OFFSET(pfid),\n\t\t  CNIC_PAGE_SIZE);\n\tCNIC_WR8(dev, BAR_CSTRORM_INTMEM +\n\t\t CSTORM_ISCSI_PAGE_SIZE_LOG_OFFSET(pfid), CNIC_PAGE_BITS);\n\tCNIC_WR16(dev, BAR_CSTRORM_INTMEM +\n\t\t  CSTORM_ISCSI_NUM_OF_TASKS_OFFSET(pfid),\n\t\t  req1->num_tasks_per_conn);\n\tCNIC_WR16(dev, BAR_CSTRORM_INTMEM + CSTORM_ISCSI_CQ_SIZE_OFFSET(pfid),\n\t\t  req1->cq_num_wqes);\n\tCNIC_WR16(dev, BAR_CSTRORM_INTMEM + CSTORM_ISCSI_HQ_SIZE_OFFSET(pfid),\n\t\t  hq_bds);\n\n\tcnic_bnx2x_set_tcp_options(dev,\n\t\t\treq1->flags & ISCSI_KWQE_INIT1_TIME_STAMPS_ENABLE,\n\t\t\treq1->flags & ISCSI_KWQE_INIT1_DELAYED_ACK_ENABLE);\n\n\treturn 0;\n}\n\nstatic int cnic_bnx2x_iscsi_init2(struct cnic_dev *dev, struct kwqe *kwqe)\n{\n\tstruct iscsi_kwqe_init2 *req2 = (struct iscsi_kwqe_init2 *) kwqe;\n\tstruct bnx2x *bp = netdev_priv(dev->netdev);\n\tu32 pfid = bp->pfid;\n\tstruct iscsi_kcqe kcqe;\n\tstruct kcqe *cqes[1];\n\n\tmemset(&kcqe, 0, sizeof(kcqe));\n\tif (!dev->max_iscsi_conn) {\n\t\tkcqe.completion_status =\n\t\t\tISCSI_KCQE_COMPLETION_STATUS_ISCSI_NOT_SUPPORTED;\n\t\tgoto done;\n\t}\n\n\tCNIC_WR(dev, BAR_TSTRORM_INTMEM +\n\t\tTSTORM_ISCSI_ERROR_BITMAP_OFFSET(pfid), req2->error_bit_map[0]);\n\tCNIC_WR(dev, BAR_TSTRORM_INTMEM +\n\t\tTSTORM_ISCSI_ERROR_BITMAP_OFFSET(pfid) + 4,\n\t\treq2->error_bit_map[1]);\n\n\tCNIC_WR16(dev, BAR_USTRORM_INTMEM +\n\t\t  USTORM_ISCSI_CQ_SQN_SIZE_OFFSET(pfid), req2->max_cq_sqn);\n\tCNIC_WR(dev, BAR_USTRORM_INTMEM +\n\t\tUSTORM_ISCSI_ERROR_BITMAP_OFFSET(pfid), req2->error_bit_map[0]);\n\tCNIC_WR(dev, BAR_USTRORM_INTMEM +\n\t\tUSTORM_ISCSI_ERROR_BITMAP_OFFSET(pfid) + 4,\n\t\treq2->error_bit_map[1]);\n\n\tCNIC_WR16(dev, BAR_CSTRORM_INTMEM +\n\t\t  CSTORM_ISCSI_CQ_SQN_SIZE_OFFSET(pfid), req2->max_cq_sqn);\n\n\tkcqe.completion_status = ISCSI_KCQE_COMPLETION_STATUS_SUCCESS;\n\ndone:\n\tkcqe.op_code = ISCSI_KCQE_OPCODE_INIT;\n\tcqes[0] = (struct kcqe *) &kcqe;\n\tcnic_reply_bnx2x_kcqes(dev, CNIC_ULP_ISCSI, cqes, 1);\n\n\treturn 0;\n}\n\nstatic void cnic_free_bnx2x_conn_resc(struct cnic_dev *dev, u32 l5_cid)\n{\n\tstruct cnic_local *cp = dev->cnic_priv;\n\tstruct cnic_context *ctx = &cp->ctx_tbl[l5_cid];\n\n\tif (ctx->ulp_proto_id == CNIC_ULP_ISCSI) {\n\t\tstruct cnic_iscsi *iscsi = ctx->proto.iscsi;\n\n\t\tcnic_free_dma(dev, &iscsi->hq_info);\n\t\tcnic_free_dma(dev, &iscsi->r2tq_info);\n\t\tcnic_free_dma(dev, &iscsi->task_array_info);\n\t\tcnic_free_id(&cp->cid_tbl, ctx->cid);\n\t} else {\n\t\tcnic_free_id(&cp->fcoe_cid_tbl, ctx->cid);\n\t}\n\n\tctx->cid = 0;\n}\n\nstatic int cnic_alloc_bnx2x_conn_resc(struct cnic_dev *dev, u32 l5_cid)\n{\n\tu32 cid;\n\tint ret, pages;\n\tstruct cnic_local *cp = dev->cnic_priv;\n\tstruct cnic_context *ctx = &cp->ctx_tbl[l5_cid];\n\tstruct cnic_iscsi *iscsi = ctx->proto.iscsi;\n\n\tif (ctx->ulp_proto_id == CNIC_ULP_FCOE) {\n\t\tcid = cnic_alloc_new_id(&cp->fcoe_cid_tbl);\n\t\tif (cid == -1) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto error;\n\t\t}\n\t\tctx->cid = cid;\n\t\treturn 0;\n\t}\n\n\tcid = cnic_alloc_new_id(&cp->cid_tbl);\n\tif (cid == -1) {\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\tctx->cid = cid;\n\tpages = CNIC_PAGE_ALIGN(cp->task_array_size) / CNIC_PAGE_SIZE;\n\n\tret = cnic_alloc_dma(dev, &iscsi->task_array_info, pages, 1);\n\tif (ret)\n\t\tgoto error;\n\n\tpages = CNIC_PAGE_ALIGN(cp->r2tq_size) / CNIC_PAGE_SIZE;\n\tret = cnic_alloc_dma(dev, &iscsi->r2tq_info, pages, 1);\n\tif (ret)\n\t\tgoto error;\n\n\tpages = CNIC_PAGE_ALIGN(cp->hq_size) / CNIC_PAGE_SIZE;\n\tret = cnic_alloc_dma(dev, &iscsi->hq_info, pages, 1);\n\tif (ret)\n\t\tgoto error;\n\n\treturn 0;\n\nerror:\n\tcnic_free_bnx2x_conn_resc(dev, l5_cid);\n\treturn ret;\n}\n\nstatic void *cnic_get_bnx2x_ctx(struct cnic_dev *dev, u32 cid, int init,\n\t\t\t\tstruct regpair *ctx_addr)\n{\n\tstruct cnic_local *cp = dev->cnic_priv;\n\tstruct cnic_eth_dev *ethdev = cp->ethdev;\n\tint blk = (cid - ethdev->starting_cid) / cp->cids_per_blk;\n\tint off = (cid - ethdev->starting_cid) % cp->cids_per_blk;\n\tunsigned long align_off = 0;\n\tdma_addr_t ctx_map;\n\tvoid *ctx;\n\n\tif (cp->ctx_align) {\n\t\tunsigned long mask = cp->ctx_align - 1;\n\n\t\tif (cp->ctx_arr[blk].mapping & mask)\n\t\t\talign_off = cp->ctx_align -\n\t\t\t\t    (cp->ctx_arr[blk].mapping & mask);\n\t}\n\tctx_map = cp->ctx_arr[blk].mapping + align_off +\n\t\t(off * BNX2X_CONTEXT_MEM_SIZE);\n\tctx = cp->ctx_arr[blk].ctx + align_off +\n\t      (off * BNX2X_CONTEXT_MEM_SIZE);\n\tif (init)\n\t\tmemset(ctx, 0, BNX2X_CONTEXT_MEM_SIZE);\n\n\tctx_addr->lo = ctx_map & 0xffffffff;\n\tctx_addr->hi = (u64) ctx_map >> 32;\n\treturn ctx;\n}\n\nstatic int cnic_setup_bnx2x_ctx(struct cnic_dev *dev, struct kwqe *wqes[],\n\t\t\t\tu32 num)\n{\n\tstruct cnic_local *cp = dev->cnic_priv;\n\tstruct bnx2x *bp = netdev_priv(dev->netdev);\n\tstruct iscsi_kwqe_conn_offload1 *req1 =\n\t\t\t(struct iscsi_kwqe_conn_offload1 *) wqes[0];\n\tstruct iscsi_kwqe_conn_offload2 *req2 =\n\t\t\t(struct iscsi_kwqe_conn_offload2 *) wqes[1];\n\tstruct iscsi_kwqe_conn_offload3 *req3;\n\tstruct cnic_context *ctx = &cp->ctx_tbl[req1->iscsi_conn_id];\n\tstruct cnic_iscsi *iscsi = ctx->proto.iscsi;\n\tu32 cid = ctx->cid;\n\tu32 hw_cid = BNX2X_HW_CID(bp, cid);\n\tstruct iscsi_context *ictx;\n\tstruct regpair context_addr;\n\tint i, j, n = 2, n_max;\n\tu8 port = BP_PORT(bp);\n\n\tctx->ctx_flags = 0;\n\tif (!req2->num_additional_wqes)\n\t\treturn -EINVAL;\n\n\tn_max = req2->num_additional_wqes + 2;\n\n\tictx = cnic_get_bnx2x_ctx(dev, cid, 1, &context_addr);\n\tif (ictx == NULL)\n\t\treturn -ENOMEM;\n\n\treq3 = (struct iscsi_kwqe_conn_offload3 *) wqes[n++];\n\n\tictx->xstorm_ag_context.hq_prod = 1;\n\n\tictx->xstorm_st_context.iscsi.first_burst_length =\n\t\tISCSI_DEF_FIRST_BURST_LEN;\n\tictx->xstorm_st_context.iscsi.max_send_pdu_length =\n\t\tISCSI_DEF_MAX_RECV_SEG_LEN;\n\tictx->xstorm_st_context.iscsi.sq_pbl_base.lo =\n\t\treq1->sq_page_table_addr_lo;\n\tictx->xstorm_st_context.iscsi.sq_pbl_base.hi =\n\t\treq1->sq_page_table_addr_hi;\n\tictx->xstorm_st_context.iscsi.sq_curr_pbe.lo = req2->sq_first_pte.hi;\n\tictx->xstorm_st_context.iscsi.sq_curr_pbe.hi = req2->sq_first_pte.lo;\n\tictx->xstorm_st_context.iscsi.hq_pbl_base.lo =\n\t\tiscsi->hq_info.pgtbl_map & 0xffffffff;\n\tictx->xstorm_st_context.iscsi.hq_pbl_base.hi =\n\t\t(u64) iscsi->hq_info.pgtbl_map >> 32;\n\tictx->xstorm_st_context.iscsi.hq_curr_pbe_base.lo =\n\t\tiscsi->hq_info.pgtbl[0];\n\tictx->xstorm_st_context.iscsi.hq_curr_pbe_base.hi =\n\t\tiscsi->hq_info.pgtbl[1];\n\tictx->xstorm_st_context.iscsi.r2tq_pbl_base.lo =\n\t\tiscsi->r2tq_info.pgtbl_map & 0xffffffff;\n\tictx->xstorm_st_context.iscsi.r2tq_pbl_base.hi =\n\t\t(u64) iscsi->r2tq_info.pgtbl_map >> 32;\n\tictx->xstorm_st_context.iscsi.r2tq_curr_pbe_base.lo =\n\t\tiscsi->r2tq_info.pgtbl[0];\n\tictx->xstorm_st_context.iscsi.r2tq_curr_pbe_base.hi =\n\t\tiscsi->r2tq_info.pgtbl[1];\n\tictx->xstorm_st_context.iscsi.task_pbl_base.lo =\n\t\tiscsi->task_array_info.pgtbl_map & 0xffffffff;\n\tictx->xstorm_st_context.iscsi.task_pbl_base.hi =\n\t\t(u64) iscsi->task_array_info.pgtbl_map >> 32;\n\tictx->xstorm_st_context.iscsi.task_pbl_cache_idx =\n\t\tBNX2X_ISCSI_PBL_NOT_CACHED;\n\tictx->xstorm_st_context.iscsi.flags.flags |=\n\t\tXSTORM_ISCSI_CONTEXT_FLAGS_B_IMMEDIATE_DATA;\n\tictx->xstorm_st_context.iscsi.flags.flags |=\n\t\tXSTORM_ISCSI_CONTEXT_FLAGS_B_INITIAL_R2T;\n\tictx->xstorm_st_context.common.ethernet.reserved_vlan_type =\n\t\tETH_P_8021Q;\n\tif (BNX2X_CHIP_IS_E2_PLUS(bp) &&\n\t    bp->common.chip_port_mode == CHIP_2_PORT_MODE) {\n\n\t\tport = 0;\n\t}\n\tictx->xstorm_st_context.common.flags =\n\t\t1 << XSTORM_COMMON_CONTEXT_SECTION_PHYSQ_INITIALIZED_SHIFT;\n\tictx->xstorm_st_context.common.flags =\n\t\tport << XSTORM_COMMON_CONTEXT_SECTION_PBF_PORT_SHIFT;\n\n\tictx->tstorm_st_context.iscsi.hdr_bytes_2_fetch = ISCSI_HEADER_SIZE;\n\t \n\tictx->tstorm_st_context.iscsi.rq_db_phy_addr.lo =\n\t\treq2->rq_page_table_addr_lo & CNIC_PAGE_MASK;\n\tictx->tstorm_st_context.iscsi.rq_db_phy_addr.hi =\n\t\treq2->rq_page_table_addr_hi;\n\tictx->tstorm_st_context.iscsi.iscsi_conn_id = req1->iscsi_conn_id;\n\tictx->tstorm_st_context.tcp.cwnd = 0x5A8;\n\tictx->tstorm_st_context.tcp.flags2 |=\n\t\tTSTORM_TCP_ST_CONTEXT_SECTION_DA_EN;\n\tictx->tstorm_st_context.tcp.ooo_support_mode =\n\t\tTCP_TSTORM_OOO_DROP_AND_PROC_ACK;\n\n\tictx->timers_context.flags |= TIMERS_BLOCK_CONTEXT_CONN_VALID_FLG;\n\n\tictx->ustorm_st_context.ring.rq.pbl_base.lo =\n\t\treq2->rq_page_table_addr_lo;\n\tictx->ustorm_st_context.ring.rq.pbl_base.hi =\n\t\treq2->rq_page_table_addr_hi;\n\tictx->ustorm_st_context.ring.rq.curr_pbe.lo = req3->qp_first_pte[0].hi;\n\tictx->ustorm_st_context.ring.rq.curr_pbe.hi = req3->qp_first_pte[0].lo;\n\tictx->ustorm_st_context.ring.r2tq.pbl_base.lo =\n\t\tiscsi->r2tq_info.pgtbl_map & 0xffffffff;\n\tictx->ustorm_st_context.ring.r2tq.pbl_base.hi =\n\t\t(u64) iscsi->r2tq_info.pgtbl_map >> 32;\n\tictx->ustorm_st_context.ring.r2tq.curr_pbe.lo =\n\t\tiscsi->r2tq_info.pgtbl[0];\n\tictx->ustorm_st_context.ring.r2tq.curr_pbe.hi =\n\t\tiscsi->r2tq_info.pgtbl[1];\n\tictx->ustorm_st_context.ring.cq_pbl_base.lo =\n\t\treq1->cq_page_table_addr_lo;\n\tictx->ustorm_st_context.ring.cq_pbl_base.hi =\n\t\treq1->cq_page_table_addr_hi;\n\tictx->ustorm_st_context.ring.cq[0].cq_sn = ISCSI_INITIAL_SN;\n\tictx->ustorm_st_context.ring.cq[0].curr_pbe.lo = req2->cq_first_pte.hi;\n\tictx->ustorm_st_context.ring.cq[0].curr_pbe.hi = req2->cq_first_pte.lo;\n\tictx->ustorm_st_context.task_pbe_cache_index =\n\t\tBNX2X_ISCSI_PBL_NOT_CACHED;\n\tictx->ustorm_st_context.task_pdu_cache_index =\n\t\tBNX2X_ISCSI_PDU_HEADER_NOT_CACHED;\n\n\tfor (i = 1, j = 1; i < cp->num_cqs; i++, j++) {\n\t\tif (j == 3) {\n\t\t\tif (n >= n_max)\n\t\t\t\tbreak;\n\t\t\treq3 = (struct iscsi_kwqe_conn_offload3 *) wqes[n++];\n\t\t\tj = 0;\n\t\t}\n\t\tictx->ustorm_st_context.ring.cq[i].cq_sn = ISCSI_INITIAL_SN;\n\t\tictx->ustorm_st_context.ring.cq[i].curr_pbe.lo =\n\t\t\treq3->qp_first_pte[j].hi;\n\t\tictx->ustorm_st_context.ring.cq[i].curr_pbe.hi =\n\t\t\treq3->qp_first_pte[j].lo;\n\t}\n\n\tictx->ustorm_st_context.task_pbl_base.lo =\n\t\tiscsi->task_array_info.pgtbl_map & 0xffffffff;\n\tictx->ustorm_st_context.task_pbl_base.hi =\n\t\t(u64) iscsi->task_array_info.pgtbl_map >> 32;\n\tictx->ustorm_st_context.tce_phy_addr.lo =\n\t\tiscsi->task_array_info.pgtbl[0];\n\tictx->ustorm_st_context.tce_phy_addr.hi =\n\t\tiscsi->task_array_info.pgtbl[1];\n\tictx->ustorm_st_context.iscsi_conn_id = req1->iscsi_conn_id;\n\tictx->ustorm_st_context.num_cqs = cp->num_cqs;\n\tictx->ustorm_st_context.negotiated_rx |= ISCSI_DEF_MAX_RECV_SEG_LEN;\n\tictx->ustorm_st_context.negotiated_rx_and_flags |=\n\t\tISCSI_DEF_MAX_BURST_LEN;\n\tictx->ustorm_st_context.negotiated_rx |=\n\t\tISCSI_DEFAULT_MAX_OUTSTANDING_R2T <<\n\t\tUSTORM_ISCSI_ST_CONTEXT_MAX_OUTSTANDING_R2TS_SHIFT;\n\n\tictx->cstorm_st_context.hq_pbl_base.lo =\n\t\tiscsi->hq_info.pgtbl_map & 0xffffffff;\n\tictx->cstorm_st_context.hq_pbl_base.hi =\n\t\t(u64) iscsi->hq_info.pgtbl_map >> 32;\n\tictx->cstorm_st_context.hq_curr_pbe.lo = iscsi->hq_info.pgtbl[0];\n\tictx->cstorm_st_context.hq_curr_pbe.hi = iscsi->hq_info.pgtbl[1];\n\tictx->cstorm_st_context.task_pbl_base.lo =\n\t\tiscsi->task_array_info.pgtbl_map & 0xffffffff;\n\tictx->cstorm_st_context.task_pbl_base.hi =\n\t\t(u64) iscsi->task_array_info.pgtbl_map >> 32;\n\t \n\tictx->cstorm_st_context.cq_db_base.lo =\n\t\treq1->cq_page_table_addr_lo & CNIC_PAGE_MASK;\n\tictx->cstorm_st_context.cq_db_base.hi = req1->cq_page_table_addr_hi;\n\tictx->cstorm_st_context.iscsi_conn_id = req1->iscsi_conn_id;\n\tictx->cstorm_st_context.cq_proc_en_bit_map = (1 << cp->num_cqs) - 1;\n\tfor (i = 0; i < cp->num_cqs; i++) {\n\t\tictx->cstorm_st_context.cq_c_prod_sqn_arr.sqn[i] =\n\t\t\tISCSI_INITIAL_SN;\n\t\tictx->cstorm_st_context.cq_c_sqn_2_notify_arr.sqn[i] =\n\t\t\tISCSI_INITIAL_SN;\n\t}\n\n\tictx->xstorm_ag_context.cdu_reserved =\n\t\tCDU_RSRVD_VALUE_TYPE_A(hw_cid, CDU_REGION_NUMBER_XCM_AG,\n\t\t\t\t       ISCSI_CONNECTION_TYPE);\n\tictx->ustorm_ag_context.cdu_usage =\n\t\tCDU_RSRVD_VALUE_TYPE_A(hw_cid, CDU_REGION_NUMBER_UCM_AG,\n\t\t\t\t       ISCSI_CONNECTION_TYPE);\n\treturn 0;\n\n}\n\nstatic int cnic_bnx2x_iscsi_ofld1(struct cnic_dev *dev, struct kwqe *wqes[],\n\t\t\t\t   u32 num, int *work)\n{\n\tstruct iscsi_kwqe_conn_offload1 *req1;\n\tstruct iscsi_kwqe_conn_offload2 *req2;\n\tstruct cnic_local *cp = dev->cnic_priv;\n\tstruct bnx2x *bp = netdev_priv(dev->netdev);\n\tstruct cnic_context *ctx;\n\tstruct iscsi_kcqe kcqe;\n\tstruct kcqe *cqes[1];\n\tu32 l5_cid;\n\tint ret = 0;\n\n\tif (num < 2) {\n\t\t*work = num;\n\t\treturn -EINVAL;\n\t}\n\n\treq1 = (struct iscsi_kwqe_conn_offload1 *) wqes[0];\n\treq2 = (struct iscsi_kwqe_conn_offload2 *) wqes[1];\n\tif ((num - 2) < req2->num_additional_wqes) {\n\t\t*work = num;\n\t\treturn -EINVAL;\n\t}\n\t*work = 2 + req2->num_additional_wqes;\n\n\tl5_cid = req1->iscsi_conn_id;\n\tif (l5_cid >= MAX_ISCSI_TBL_SZ)\n\t\treturn -EINVAL;\n\n\tmemset(&kcqe, 0, sizeof(kcqe));\n\tkcqe.op_code = ISCSI_KCQE_OPCODE_OFFLOAD_CONN;\n\tkcqe.iscsi_conn_id = l5_cid;\n\tkcqe.completion_status = ISCSI_KCQE_COMPLETION_STATUS_CTX_ALLOC_FAILURE;\n\n\tctx = &cp->ctx_tbl[l5_cid];\n\tif (test_bit(CTX_FL_OFFLD_START, &ctx->ctx_flags)) {\n\t\tkcqe.completion_status =\n\t\t\tISCSI_KCQE_COMPLETION_STATUS_CID_BUSY;\n\t\tgoto done;\n\t}\n\n\tif (atomic_inc_return(&cp->iscsi_conn) > dev->max_iscsi_conn) {\n\t\tatomic_dec(&cp->iscsi_conn);\n\t\tgoto done;\n\t}\n\tret = cnic_alloc_bnx2x_conn_resc(dev, l5_cid);\n\tif (ret) {\n\t\tatomic_dec(&cp->iscsi_conn);\n\t\tgoto done;\n\t}\n\tret = cnic_setup_bnx2x_ctx(dev, wqes, num);\n\tif (ret < 0) {\n\t\tcnic_free_bnx2x_conn_resc(dev, l5_cid);\n\t\tatomic_dec(&cp->iscsi_conn);\n\t\tgoto done;\n\t}\n\n\tkcqe.completion_status = ISCSI_KCQE_COMPLETION_STATUS_SUCCESS;\n\tkcqe.iscsi_conn_context_id = BNX2X_HW_CID(bp, cp->ctx_tbl[l5_cid].cid);\n\ndone:\n\tcqes[0] = (struct kcqe *) &kcqe;\n\tcnic_reply_bnx2x_kcqes(dev, CNIC_ULP_ISCSI, cqes, 1);\n\treturn 0;\n}\n\n\nstatic int cnic_bnx2x_iscsi_update(struct cnic_dev *dev, struct kwqe *kwqe)\n{\n\tstruct cnic_local *cp = dev->cnic_priv;\n\tstruct iscsi_kwqe_conn_update *req =\n\t\t(struct iscsi_kwqe_conn_update *) kwqe;\n\tvoid *data;\n\tunion l5cm_specific_data l5_data;\n\tu32 l5_cid, cid = BNX2X_SW_CID(req->context_id);\n\tint ret;\n\n\tif (cnic_get_l5_cid(cp, cid, &l5_cid) != 0)\n\t\treturn -EINVAL;\n\n\tdata = cnic_get_kwqe_16_data(cp, l5_cid, &l5_data);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tmemcpy(data, kwqe, sizeof(struct kwqe));\n\n\tret = cnic_submit_kwqe_16(dev, ISCSI_RAMROD_CMD_ID_UPDATE_CONN,\n\t\t\treq->context_id, ISCSI_CONNECTION_TYPE, &l5_data);\n\treturn ret;\n}\n\nstatic int cnic_bnx2x_destroy_ramrod(struct cnic_dev *dev, u32 l5_cid)\n{\n\tstruct cnic_local *cp = dev->cnic_priv;\n\tstruct bnx2x *bp = netdev_priv(dev->netdev);\n\tstruct cnic_context *ctx = &cp->ctx_tbl[l5_cid];\n\tunion l5cm_specific_data l5_data;\n\tint ret;\n\tu32 hw_cid;\n\n\tinit_waitqueue_head(&ctx->waitq);\n\tctx->wait_cond = 0;\n\tmemset(&l5_data, 0, sizeof(l5_data));\n\thw_cid = BNX2X_HW_CID(bp, ctx->cid);\n\n\tret = cnic_submit_kwqe_16(dev, RAMROD_CMD_ID_COMMON_CFC_DEL,\n\t\t\t\t  hw_cid, NONE_CONNECTION_TYPE, &l5_data);\n\n\tif (ret == 0) {\n\t\twait_event_timeout(ctx->waitq, ctx->wait_cond, CNIC_RAMROD_TMO);\n\t\tif (unlikely(test_bit(CTX_FL_CID_ERROR, &ctx->ctx_flags)))\n\t\t\treturn -EBUSY;\n\t}\n\n\treturn 0;\n}\n\nstatic int cnic_bnx2x_iscsi_destroy(struct cnic_dev *dev, struct kwqe *kwqe)\n{\n\tstruct cnic_local *cp = dev->cnic_priv;\n\tstruct iscsi_kwqe_conn_destroy *req =\n\t\t(struct iscsi_kwqe_conn_destroy *) kwqe;\n\tu32 l5_cid = req->reserved0;\n\tstruct cnic_context *ctx = &cp->ctx_tbl[l5_cid];\n\tint ret = 0;\n\tstruct iscsi_kcqe kcqe;\n\tstruct kcqe *cqes[1];\n\n\tif (!test_bit(CTX_FL_OFFLD_START, &ctx->ctx_flags))\n\t\tgoto skip_cfc_delete;\n\n\tif (!time_after(jiffies, ctx->timestamp + (2 * HZ))) {\n\t\tunsigned long delta = ctx->timestamp + (2 * HZ) - jiffies;\n\n\t\tif (delta > (2 * HZ))\n\t\t\tdelta = 0;\n\n\t\tset_bit(CTX_FL_DELETE_WAIT, &ctx->ctx_flags);\n\t\tqueue_delayed_work(cnic_wq, &cp->delete_task, delta);\n\t\tgoto destroy_reply;\n\t}\n\n\tret = cnic_bnx2x_destroy_ramrod(dev, l5_cid);\n\nskip_cfc_delete:\n\tcnic_free_bnx2x_conn_resc(dev, l5_cid);\n\n\tif (!ret) {\n\t\tatomic_dec(&cp->iscsi_conn);\n\t\tclear_bit(CTX_FL_OFFLD_START, &ctx->ctx_flags);\n\t}\n\ndestroy_reply:\n\tmemset(&kcqe, 0, sizeof(kcqe));\n\tkcqe.op_code = ISCSI_KCQE_OPCODE_DESTROY_CONN;\n\tkcqe.iscsi_conn_id = l5_cid;\n\tkcqe.completion_status = ISCSI_KCQE_COMPLETION_STATUS_SUCCESS;\n\tkcqe.iscsi_conn_context_id = req->context_id;\n\n\tcqes[0] = (struct kcqe *) &kcqe;\n\tcnic_reply_bnx2x_kcqes(dev, CNIC_ULP_ISCSI, cqes, 1);\n\n\treturn 0;\n}\n\nstatic void cnic_init_storm_conn_bufs(struct cnic_dev *dev,\n\t\t\t\t      struct l4_kwq_connect_req1 *kwqe1,\n\t\t\t\t      struct l4_kwq_connect_req3 *kwqe3,\n\t\t\t\t      struct l5cm_active_conn_buffer *conn_buf)\n{\n\tstruct l5cm_conn_addr_params *conn_addr = &conn_buf->conn_addr_buf;\n\tstruct l5cm_xstorm_conn_buffer *xstorm_buf =\n\t\t&conn_buf->xstorm_conn_buffer;\n\tstruct l5cm_tstorm_conn_buffer *tstorm_buf =\n\t\t&conn_buf->tstorm_conn_buffer;\n\tstruct regpair context_addr;\n\tu32 cid = BNX2X_SW_CID(kwqe1->cid);\n\tstruct in6_addr src_ip, dst_ip;\n\tint i;\n\tu32 *addrp;\n\n\taddrp = (u32 *) &conn_addr->local_ip_addr;\n\tfor (i = 0; i < 4; i++, addrp++)\n\t\tsrc_ip.in6_u.u6_addr32[i] = cpu_to_be32(*addrp);\n\n\taddrp = (u32 *) &conn_addr->remote_ip_addr;\n\tfor (i = 0; i < 4; i++, addrp++)\n\t\tdst_ip.in6_u.u6_addr32[i] = cpu_to_be32(*addrp);\n\n\tcnic_get_bnx2x_ctx(dev, cid, 0, &context_addr);\n\n\txstorm_buf->context_addr.hi = context_addr.hi;\n\txstorm_buf->context_addr.lo = context_addr.lo;\n\txstorm_buf->mss = 0xffff;\n\txstorm_buf->rcv_buf = kwqe3->rcv_buf;\n\tif (kwqe1->tcp_flags & L4_KWQ_CONNECT_REQ1_NAGLE_ENABLE)\n\t\txstorm_buf->params |= L5CM_XSTORM_CONN_BUFFER_NAGLE_ENABLE;\n\txstorm_buf->pseudo_header_checksum =\n\t\tswab16(~csum_ipv6_magic(&src_ip, &dst_ip, 0, IPPROTO_TCP, 0));\n\n\tif (kwqe3->ka_timeout) {\n\t\ttstorm_buf->ka_enable = 1;\n\t\ttstorm_buf->ka_timeout = kwqe3->ka_timeout;\n\t\ttstorm_buf->ka_interval = kwqe3->ka_interval;\n\t\ttstorm_buf->ka_max_probe_count = kwqe3->ka_max_probe_count;\n\t}\n\ttstorm_buf->max_rt_time = 0xffffffff;\n}\n\nstatic void cnic_init_bnx2x_mac(struct cnic_dev *dev)\n{\n\tstruct bnx2x *bp = netdev_priv(dev->netdev);\n\tu32 pfid = bp->pfid;\n\tu8 *mac = dev->mac_addr;\n\n\tCNIC_WR8(dev, BAR_XSTRORM_INTMEM +\n\t\t XSTORM_ISCSI_LOCAL_MAC_ADDR0_OFFSET(pfid), mac[0]);\n\tCNIC_WR8(dev, BAR_XSTRORM_INTMEM +\n\t\t XSTORM_ISCSI_LOCAL_MAC_ADDR1_OFFSET(pfid), mac[1]);\n\tCNIC_WR8(dev, BAR_XSTRORM_INTMEM +\n\t\t XSTORM_ISCSI_LOCAL_MAC_ADDR2_OFFSET(pfid), mac[2]);\n\tCNIC_WR8(dev, BAR_XSTRORM_INTMEM +\n\t\t XSTORM_ISCSI_LOCAL_MAC_ADDR3_OFFSET(pfid), mac[3]);\n\tCNIC_WR8(dev, BAR_XSTRORM_INTMEM +\n\t\t XSTORM_ISCSI_LOCAL_MAC_ADDR4_OFFSET(pfid), mac[4]);\n\tCNIC_WR8(dev, BAR_XSTRORM_INTMEM +\n\t\t XSTORM_ISCSI_LOCAL_MAC_ADDR5_OFFSET(pfid), mac[5]);\n\n\tCNIC_WR8(dev, BAR_TSTRORM_INTMEM +\n\t\t TSTORM_ISCSI_TCP_VARS_LSB_LOCAL_MAC_ADDR_OFFSET(pfid), mac[5]);\n\tCNIC_WR8(dev, BAR_TSTRORM_INTMEM +\n\t\t TSTORM_ISCSI_TCP_VARS_LSB_LOCAL_MAC_ADDR_OFFSET(pfid) + 1,\n\t\t mac[4]);\n\tCNIC_WR8(dev, BAR_TSTRORM_INTMEM +\n\t\t TSTORM_ISCSI_TCP_VARS_MID_LOCAL_MAC_ADDR_OFFSET(pfid), mac[3]);\n\tCNIC_WR8(dev, BAR_TSTRORM_INTMEM +\n\t\t TSTORM_ISCSI_TCP_VARS_MID_LOCAL_MAC_ADDR_OFFSET(pfid) + 1,\n\t\t mac[2]);\n\tCNIC_WR8(dev, BAR_TSTRORM_INTMEM +\n\t\t TSTORM_ISCSI_TCP_VARS_MSB_LOCAL_MAC_ADDR_OFFSET(pfid), mac[1]);\n\tCNIC_WR8(dev, BAR_TSTRORM_INTMEM +\n\t\t TSTORM_ISCSI_TCP_VARS_MSB_LOCAL_MAC_ADDR_OFFSET(pfid) + 1,\n\t\t mac[0]);\n}\n\nstatic int cnic_bnx2x_connect(struct cnic_dev *dev, struct kwqe *wqes[],\n\t\t\t      u32 num, int *work)\n{\n\tstruct cnic_local *cp = dev->cnic_priv;\n\tstruct bnx2x *bp = netdev_priv(dev->netdev);\n\tstruct l4_kwq_connect_req1 *kwqe1 =\n\t\t(struct l4_kwq_connect_req1 *) wqes[0];\n\tstruct l4_kwq_connect_req3 *kwqe3;\n\tstruct l5cm_active_conn_buffer *conn_buf;\n\tstruct l5cm_conn_addr_params *conn_addr;\n\tunion l5cm_specific_data l5_data;\n\tu32 l5_cid = kwqe1->pg_cid;\n\tstruct cnic_sock *csk = &cp->csk_tbl[l5_cid];\n\tstruct cnic_context *ctx = &cp->ctx_tbl[l5_cid];\n\tint ret;\n\n\tif (num < 2) {\n\t\t*work = num;\n\t\treturn -EINVAL;\n\t}\n\n\tif (kwqe1->conn_flags & L4_KWQ_CONNECT_REQ1_IP_V6)\n\t\t*work = 3;\n\telse\n\t\t*work = 2;\n\n\tif (num < *work) {\n\t\t*work = num;\n\t\treturn -EINVAL;\n\t}\n\n\tif (sizeof(*conn_buf) > CNIC_KWQ16_DATA_SIZE) {\n\t\tnetdev_err(dev->netdev, \"conn_buf size too big\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tconn_buf = cnic_get_kwqe_16_data(cp, l5_cid, &l5_data);\n\tif (!conn_buf)\n\t\treturn -ENOMEM;\n\n\tmemset(conn_buf, 0, sizeof(*conn_buf));\n\n\tconn_addr = &conn_buf->conn_addr_buf;\n\tconn_addr->remote_addr_0 = csk->ha[0];\n\tconn_addr->remote_addr_1 = csk->ha[1];\n\tconn_addr->remote_addr_2 = csk->ha[2];\n\tconn_addr->remote_addr_3 = csk->ha[3];\n\tconn_addr->remote_addr_4 = csk->ha[4];\n\tconn_addr->remote_addr_5 = csk->ha[5];\n\n\tif (kwqe1->conn_flags & L4_KWQ_CONNECT_REQ1_IP_V6) {\n\t\tstruct l4_kwq_connect_req2 *kwqe2 =\n\t\t\t(struct l4_kwq_connect_req2 *) wqes[1];\n\n\t\tconn_addr->local_ip_addr.ip_addr_hi_hi = kwqe2->src_ip_v6_4;\n\t\tconn_addr->local_ip_addr.ip_addr_hi_lo = kwqe2->src_ip_v6_3;\n\t\tconn_addr->local_ip_addr.ip_addr_lo_hi = kwqe2->src_ip_v6_2;\n\n\t\tconn_addr->remote_ip_addr.ip_addr_hi_hi = kwqe2->dst_ip_v6_4;\n\t\tconn_addr->remote_ip_addr.ip_addr_hi_lo = kwqe2->dst_ip_v6_3;\n\t\tconn_addr->remote_ip_addr.ip_addr_lo_hi = kwqe2->dst_ip_v6_2;\n\t\tconn_addr->params |= L5CM_CONN_ADDR_PARAMS_IP_VERSION;\n\t}\n\tkwqe3 = (struct l4_kwq_connect_req3 *) wqes[*work - 1];\n\n\tconn_addr->local_ip_addr.ip_addr_lo_lo = kwqe1->src_ip;\n\tconn_addr->remote_ip_addr.ip_addr_lo_lo = kwqe1->dst_ip;\n\tconn_addr->local_tcp_port = kwqe1->src_port;\n\tconn_addr->remote_tcp_port = kwqe1->dst_port;\n\n\tconn_addr->pmtu = kwqe3->pmtu;\n\tcnic_init_storm_conn_bufs(dev, kwqe1, kwqe3, conn_buf);\n\n\tCNIC_WR16(dev, BAR_XSTRORM_INTMEM +\n\t\t  XSTORM_ISCSI_LOCAL_VLAN_OFFSET(bp->pfid), csk->vlan_id);\n\n\tret = cnic_submit_kwqe_16(dev, L5CM_RAMROD_CMD_ID_TCP_CONNECT,\n\t\t\tkwqe1->cid, ISCSI_CONNECTION_TYPE, &l5_data);\n\tif (!ret)\n\t\tset_bit(CTX_FL_OFFLD_START, &ctx->ctx_flags);\n\n\treturn ret;\n}\n\nstatic int cnic_bnx2x_close(struct cnic_dev *dev, struct kwqe *kwqe)\n{\n\tstruct l4_kwq_close_req *req = (struct l4_kwq_close_req *) kwqe;\n\tunion l5cm_specific_data l5_data;\n\tint ret;\n\n\tmemset(&l5_data, 0, sizeof(l5_data));\n\tret = cnic_submit_kwqe_16(dev, L5CM_RAMROD_CMD_ID_CLOSE,\n\t\t\treq->cid, ISCSI_CONNECTION_TYPE, &l5_data);\n\treturn ret;\n}\n\nstatic int cnic_bnx2x_reset(struct cnic_dev *dev, struct kwqe *kwqe)\n{\n\tstruct l4_kwq_reset_req *req = (struct l4_kwq_reset_req *) kwqe;\n\tunion l5cm_specific_data l5_data;\n\tint ret;\n\n\tmemset(&l5_data, 0, sizeof(l5_data));\n\tret = cnic_submit_kwqe_16(dev, L5CM_RAMROD_CMD_ID_ABORT,\n\t\t\treq->cid, ISCSI_CONNECTION_TYPE, &l5_data);\n\treturn ret;\n}\nstatic int cnic_bnx2x_offload_pg(struct cnic_dev *dev, struct kwqe *kwqe)\n{\n\tstruct l4_kwq_offload_pg *req = (struct l4_kwq_offload_pg *) kwqe;\n\tstruct l4_kcq kcqe;\n\tstruct kcqe *cqes[1];\n\n\tmemset(&kcqe, 0, sizeof(kcqe));\n\tkcqe.pg_host_opaque = req->host_opaque;\n\tkcqe.pg_cid = req->host_opaque;\n\tkcqe.op_code = L4_KCQE_OPCODE_VALUE_OFFLOAD_PG;\n\tcqes[0] = (struct kcqe *) &kcqe;\n\tcnic_reply_bnx2x_kcqes(dev, CNIC_ULP_L4, cqes, 1);\n\treturn 0;\n}\n\nstatic int cnic_bnx2x_update_pg(struct cnic_dev *dev, struct kwqe *kwqe)\n{\n\tstruct l4_kwq_update_pg *req = (struct l4_kwq_update_pg *) kwqe;\n\tstruct l4_kcq kcqe;\n\tstruct kcqe *cqes[1];\n\n\tmemset(&kcqe, 0, sizeof(kcqe));\n\tkcqe.pg_host_opaque = req->pg_host_opaque;\n\tkcqe.pg_cid = req->pg_cid;\n\tkcqe.op_code = L4_KCQE_OPCODE_VALUE_UPDATE_PG;\n\tcqes[0] = (struct kcqe *) &kcqe;\n\tcnic_reply_bnx2x_kcqes(dev, CNIC_ULP_L4, cqes, 1);\n\treturn 0;\n}\n\nstatic int cnic_bnx2x_fcoe_stat(struct cnic_dev *dev, struct kwqe *kwqe)\n{\n\tstruct fcoe_kwqe_stat *req;\n\tstruct fcoe_stat_ramrod_params *fcoe_stat;\n\tunion l5cm_specific_data l5_data;\n\tstruct cnic_local *cp = dev->cnic_priv;\n\tstruct bnx2x *bp = netdev_priv(dev->netdev);\n\tint ret;\n\tu32 cid;\n\n\treq = (struct fcoe_kwqe_stat *) kwqe;\n\tcid = BNX2X_HW_CID(bp, cp->fcoe_init_cid);\n\n\tfcoe_stat = cnic_get_kwqe_16_data(cp, BNX2X_FCOE_L5_CID_BASE, &l5_data);\n\tif (!fcoe_stat)\n\t\treturn -ENOMEM;\n\n\tmemset(fcoe_stat, 0, sizeof(*fcoe_stat));\n\tmemcpy(&fcoe_stat->stat_kwqe, req, sizeof(*req));\n\n\tret = cnic_submit_kwqe_16(dev, FCOE_RAMROD_CMD_ID_STAT_FUNC, cid,\n\t\t\t\t  FCOE_CONNECTION_TYPE, &l5_data);\n\treturn ret;\n}\n\nstatic int cnic_bnx2x_fcoe_init1(struct cnic_dev *dev, struct kwqe *wqes[],\n\t\t\t\t u32 num, int *work)\n{\n\tint ret;\n\tstruct cnic_local *cp = dev->cnic_priv;\n\tstruct bnx2x *bp = netdev_priv(dev->netdev);\n\tu32 cid;\n\tstruct fcoe_init_ramrod_params *fcoe_init;\n\tstruct fcoe_kwqe_init1 *req1;\n\tstruct fcoe_kwqe_init2 *req2;\n\tstruct fcoe_kwqe_init3 *req3;\n\tunion l5cm_specific_data l5_data;\n\n\tif (num < 3) {\n\t\t*work = num;\n\t\treturn -EINVAL;\n\t}\n\treq1 = (struct fcoe_kwqe_init1 *) wqes[0];\n\treq2 = (struct fcoe_kwqe_init2 *) wqes[1];\n\treq3 = (struct fcoe_kwqe_init3 *) wqes[2];\n\tif (req2->hdr.op_code != FCOE_KWQE_OPCODE_INIT2) {\n\t\t*work = 1;\n\t\treturn -EINVAL;\n\t}\n\tif (req3->hdr.op_code != FCOE_KWQE_OPCODE_INIT3) {\n\t\t*work = 2;\n\t\treturn -EINVAL;\n\t}\n\n\tif (sizeof(*fcoe_init) > CNIC_KWQ16_DATA_SIZE) {\n\t\tnetdev_err(dev->netdev, \"fcoe_init size too big\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tfcoe_init = cnic_get_kwqe_16_data(cp, BNX2X_FCOE_L5_CID_BASE, &l5_data);\n\tif (!fcoe_init)\n\t\treturn -ENOMEM;\n\n\tmemset(fcoe_init, 0, sizeof(*fcoe_init));\n\tmemcpy(&fcoe_init->init_kwqe1, req1, sizeof(*req1));\n\tmemcpy(&fcoe_init->init_kwqe2, req2, sizeof(*req2));\n\tmemcpy(&fcoe_init->init_kwqe3, req3, sizeof(*req3));\n\tfcoe_init->eq_pbl_base.lo = cp->kcq2.dma.pgtbl_map & 0xffffffff;\n\tfcoe_init->eq_pbl_base.hi = (u64) cp->kcq2.dma.pgtbl_map >> 32;\n\tfcoe_init->eq_pbl_size = cp->kcq2.dma.num_pages;\n\n\tfcoe_init->sb_num = cp->status_blk_num;\n\tfcoe_init->eq_prod = MAX_KCQ_IDX;\n\tfcoe_init->sb_id = HC_INDEX_FCOE_EQ_CONS;\n\tcp->kcq2.sw_prod_idx = 0;\n\n\tcid = BNX2X_HW_CID(bp, cp->fcoe_init_cid);\n\tret = cnic_submit_kwqe_16(dev, FCOE_RAMROD_CMD_ID_INIT_FUNC, cid,\n\t\t\t\t  FCOE_CONNECTION_TYPE, &l5_data);\n\t*work = 3;\n\treturn ret;\n}\n\nstatic int cnic_bnx2x_fcoe_ofld1(struct cnic_dev *dev, struct kwqe *wqes[],\n\t\t\t\t u32 num, int *work)\n{\n\tint ret = 0;\n\tu32 cid = -1, l5_cid;\n\tstruct cnic_local *cp = dev->cnic_priv;\n\tstruct bnx2x *bp = netdev_priv(dev->netdev);\n\tstruct fcoe_kwqe_conn_offload1 *req1;\n\tstruct fcoe_kwqe_conn_offload2 *req2;\n\tstruct fcoe_kwqe_conn_offload3 *req3;\n\tstruct fcoe_kwqe_conn_offload4 *req4;\n\tstruct fcoe_conn_offload_ramrod_params *fcoe_offload;\n\tstruct cnic_context *ctx;\n\tstruct fcoe_context *fctx;\n\tstruct regpair ctx_addr;\n\tunion l5cm_specific_data l5_data;\n\tstruct fcoe_kcqe kcqe;\n\tstruct kcqe *cqes[1];\n\n\tif (num < 4) {\n\t\t*work = num;\n\t\treturn -EINVAL;\n\t}\n\treq1 = (struct fcoe_kwqe_conn_offload1 *) wqes[0];\n\treq2 = (struct fcoe_kwqe_conn_offload2 *) wqes[1];\n\treq3 = (struct fcoe_kwqe_conn_offload3 *) wqes[2];\n\treq4 = (struct fcoe_kwqe_conn_offload4 *) wqes[3];\n\n\t*work = 4;\n\n\tl5_cid = req1->fcoe_conn_id;\n\tif (l5_cid >= dev->max_fcoe_conn)\n\t\tgoto err_reply;\n\n\tl5_cid += BNX2X_FCOE_L5_CID_BASE;\n\n\tctx = &cp->ctx_tbl[l5_cid];\n\tif (test_bit(CTX_FL_OFFLD_START, &ctx->ctx_flags))\n\t\tgoto err_reply;\n\n\tret = cnic_alloc_bnx2x_conn_resc(dev, l5_cid);\n\tif (ret) {\n\t\tret = 0;\n\t\tgoto err_reply;\n\t}\n\tcid = ctx->cid;\n\n\tfctx = cnic_get_bnx2x_ctx(dev, cid, 1, &ctx_addr);\n\tif (fctx) {\n\t\tu32 hw_cid = BNX2X_HW_CID(bp, cid);\n\t\tu32 val;\n\n\t\tval = CDU_RSRVD_VALUE_TYPE_A(hw_cid, CDU_REGION_NUMBER_XCM_AG,\n\t\t\t\t\t     FCOE_CONNECTION_TYPE);\n\t\tfctx->xstorm_ag_context.cdu_reserved = val;\n\t\tval = CDU_RSRVD_VALUE_TYPE_A(hw_cid, CDU_REGION_NUMBER_UCM_AG,\n\t\t\t\t\t     FCOE_CONNECTION_TYPE);\n\t\tfctx->ustorm_ag_context.cdu_usage = val;\n\t}\n\tif (sizeof(*fcoe_offload) > CNIC_KWQ16_DATA_SIZE) {\n\t\tnetdev_err(dev->netdev, \"fcoe_offload size too big\\n\");\n\t\tgoto err_reply;\n\t}\n\tfcoe_offload = cnic_get_kwqe_16_data(cp, l5_cid, &l5_data);\n\tif (!fcoe_offload)\n\t\tgoto err_reply;\n\n\tmemset(fcoe_offload, 0, sizeof(*fcoe_offload));\n\tmemcpy(&fcoe_offload->offload_kwqe1, req1, sizeof(*req1));\n\tmemcpy(&fcoe_offload->offload_kwqe2, req2, sizeof(*req2));\n\tmemcpy(&fcoe_offload->offload_kwqe3, req3, sizeof(*req3));\n\tmemcpy(&fcoe_offload->offload_kwqe4, req4, sizeof(*req4));\n\n\tcid = BNX2X_HW_CID(bp, cid);\n\tret = cnic_submit_kwqe_16(dev, FCOE_RAMROD_CMD_ID_OFFLOAD_CONN, cid,\n\t\t\t\t  FCOE_CONNECTION_TYPE, &l5_data);\n\tif (!ret)\n\t\tset_bit(CTX_FL_OFFLD_START, &ctx->ctx_flags);\n\n\treturn ret;\n\nerr_reply:\n\tif (cid != -1)\n\t\tcnic_free_bnx2x_conn_resc(dev, l5_cid);\n\n\tmemset(&kcqe, 0, sizeof(kcqe));\n\tkcqe.op_code = FCOE_KCQE_OPCODE_OFFLOAD_CONN;\n\tkcqe.fcoe_conn_id = req1->fcoe_conn_id;\n\tkcqe.completion_status = FCOE_KCQE_COMPLETION_STATUS_CTX_ALLOC_FAILURE;\n\n\tcqes[0] = (struct kcqe *) &kcqe;\n\tcnic_reply_bnx2x_kcqes(dev, CNIC_ULP_FCOE, cqes, 1);\n\treturn ret;\n}\n\nstatic int cnic_bnx2x_fcoe_enable(struct cnic_dev *dev, struct kwqe *kwqe)\n{\n\tstruct fcoe_kwqe_conn_enable_disable *req;\n\tstruct fcoe_conn_enable_disable_ramrod_params *fcoe_enable;\n\tunion l5cm_specific_data l5_data;\n\tint ret;\n\tu32 cid, l5_cid;\n\tstruct cnic_local *cp = dev->cnic_priv;\n\n\treq = (struct fcoe_kwqe_conn_enable_disable *) kwqe;\n\tcid = req->context_id;\n\tl5_cid = req->conn_id + BNX2X_FCOE_L5_CID_BASE;\n\n\tif (sizeof(*fcoe_enable) > CNIC_KWQ16_DATA_SIZE) {\n\t\tnetdev_err(dev->netdev, \"fcoe_enable size too big\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tfcoe_enable = cnic_get_kwqe_16_data(cp, l5_cid, &l5_data);\n\tif (!fcoe_enable)\n\t\treturn -ENOMEM;\n\n\tmemset(fcoe_enable, 0, sizeof(*fcoe_enable));\n\tmemcpy(&fcoe_enable->enable_disable_kwqe, req, sizeof(*req));\n\tret = cnic_submit_kwqe_16(dev, FCOE_RAMROD_CMD_ID_ENABLE_CONN, cid,\n\t\t\t\t  FCOE_CONNECTION_TYPE, &l5_data);\n\treturn ret;\n}\n\nstatic int cnic_bnx2x_fcoe_disable(struct cnic_dev *dev, struct kwqe *kwqe)\n{\n\tstruct fcoe_kwqe_conn_enable_disable *req;\n\tstruct fcoe_conn_enable_disable_ramrod_params *fcoe_disable;\n\tunion l5cm_specific_data l5_data;\n\tint ret;\n\tu32 cid, l5_cid;\n\tstruct cnic_local *cp = dev->cnic_priv;\n\n\treq = (struct fcoe_kwqe_conn_enable_disable *) kwqe;\n\tcid = req->context_id;\n\tl5_cid = req->conn_id;\n\tif (l5_cid >= dev->max_fcoe_conn)\n\t\treturn -EINVAL;\n\n\tl5_cid += BNX2X_FCOE_L5_CID_BASE;\n\n\tif (sizeof(*fcoe_disable) > CNIC_KWQ16_DATA_SIZE) {\n\t\tnetdev_err(dev->netdev, \"fcoe_disable size too big\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tfcoe_disable = cnic_get_kwqe_16_data(cp, l5_cid, &l5_data);\n\tif (!fcoe_disable)\n\t\treturn -ENOMEM;\n\n\tmemset(fcoe_disable, 0, sizeof(*fcoe_disable));\n\tmemcpy(&fcoe_disable->enable_disable_kwqe, req, sizeof(*req));\n\tret = cnic_submit_kwqe_16(dev, FCOE_RAMROD_CMD_ID_DISABLE_CONN, cid,\n\t\t\t\t  FCOE_CONNECTION_TYPE, &l5_data);\n\treturn ret;\n}\n\nstatic int cnic_bnx2x_fcoe_destroy(struct cnic_dev *dev, struct kwqe *kwqe)\n{\n\tstruct fcoe_kwqe_conn_destroy *req;\n\tunion l5cm_specific_data l5_data;\n\tint ret;\n\tu32 cid, l5_cid;\n\tstruct cnic_local *cp = dev->cnic_priv;\n\tstruct cnic_context *ctx;\n\tstruct fcoe_kcqe kcqe;\n\tstruct kcqe *cqes[1];\n\n\treq = (struct fcoe_kwqe_conn_destroy *) kwqe;\n\tcid = req->context_id;\n\tl5_cid = req->conn_id;\n\tif (l5_cid >= dev->max_fcoe_conn)\n\t\treturn -EINVAL;\n\n\tl5_cid += BNX2X_FCOE_L5_CID_BASE;\n\n\tctx = &cp->ctx_tbl[l5_cid];\n\n\tinit_waitqueue_head(&ctx->waitq);\n\tctx->wait_cond = 0;\n\n\tmemset(&kcqe, 0, sizeof(kcqe));\n\tkcqe.completion_status = FCOE_KCQE_COMPLETION_STATUS_ERROR;\n\tmemset(&l5_data, 0, sizeof(l5_data));\n\tret = cnic_submit_kwqe_16(dev, FCOE_RAMROD_CMD_ID_TERMINATE_CONN, cid,\n\t\t\t\t  FCOE_CONNECTION_TYPE, &l5_data);\n\tif (ret == 0) {\n\t\twait_event_timeout(ctx->waitq, ctx->wait_cond, CNIC_RAMROD_TMO);\n\t\tif (ctx->wait_cond)\n\t\t\tkcqe.completion_status = 0;\n\t}\n\n\tset_bit(CTX_FL_DELETE_WAIT, &ctx->ctx_flags);\n\tqueue_delayed_work(cnic_wq, &cp->delete_task, msecs_to_jiffies(2000));\n\n\tkcqe.op_code = FCOE_KCQE_OPCODE_DESTROY_CONN;\n\tkcqe.fcoe_conn_id = req->conn_id;\n\tkcqe.fcoe_conn_context_id = cid;\n\n\tcqes[0] = (struct kcqe *) &kcqe;\n\tcnic_reply_bnx2x_kcqes(dev, CNIC_ULP_FCOE, cqes, 1);\n\treturn ret;\n}\n\nstatic void cnic_bnx2x_delete_wait(struct cnic_dev *dev, u32 start_cid)\n{\n\tstruct cnic_local *cp = dev->cnic_priv;\n\tu32 i;\n\n\tfor (i = start_cid; i < cp->max_cid_space; i++) {\n\t\tstruct cnic_context *ctx = &cp->ctx_tbl[i];\n\t\tint j;\n\n\t\twhile (test_bit(CTX_FL_DELETE_WAIT, &ctx->ctx_flags))\n\t\t\tmsleep(10);\n\n\t\tfor (j = 0; j < 5; j++) {\n\t\t\tif (!test_bit(CTX_FL_OFFLD_START, &ctx->ctx_flags))\n\t\t\t\tbreak;\n\t\t\tmsleep(20);\n\t\t}\n\n\t\tif (test_bit(CTX_FL_OFFLD_START, &ctx->ctx_flags))\n\t\t\tnetdev_warn(dev->netdev, \"CID %x not deleted\\n\",\n\t\t\t\t   ctx->cid);\n\t}\n}\n\nstatic int cnic_bnx2x_fcoe_fw_destroy(struct cnic_dev *dev, struct kwqe *kwqe)\n{\n\tunion l5cm_specific_data l5_data;\n\tstruct cnic_local *cp = dev->cnic_priv;\n\tstruct bnx2x *bp = netdev_priv(dev->netdev);\n\tint ret;\n\tu32 cid;\n\n\tcnic_bnx2x_delete_wait(dev, MAX_ISCSI_TBL_SZ);\n\n\tcid = BNX2X_HW_CID(bp, cp->fcoe_init_cid);\n\n\tmemset(&l5_data, 0, sizeof(l5_data));\n\tret = cnic_submit_kwqe_16(dev, FCOE_RAMROD_CMD_ID_DESTROY_FUNC, cid,\n\t\t\t\t  FCOE_CONNECTION_TYPE, &l5_data);\n\treturn ret;\n}\n\nstatic void cnic_bnx2x_kwqe_err(struct cnic_dev *dev, struct kwqe *kwqe)\n{\n\tstruct cnic_local *cp = dev->cnic_priv;\n\tstruct kcqe kcqe;\n\tstruct kcqe *cqes[1];\n\tu32 cid;\n\tu32 opcode = KWQE_OPCODE(kwqe->kwqe_op_flag);\n\tu32 layer_code = kwqe->kwqe_op_flag & KWQE_LAYER_MASK;\n\tu32 kcqe_op;\n\tint ulp_type;\n\n\tcid = kwqe->kwqe_info0;\n\tmemset(&kcqe, 0, sizeof(kcqe));\n\n\tif (layer_code == KWQE_FLAGS_LAYER_MASK_L5_FCOE) {\n\t\tu32 l5_cid = 0;\n\n\t\tulp_type = CNIC_ULP_FCOE;\n\t\tif (opcode == FCOE_KWQE_OPCODE_DISABLE_CONN) {\n\t\t\tstruct fcoe_kwqe_conn_enable_disable *req;\n\n\t\t\treq = (struct fcoe_kwqe_conn_enable_disable *) kwqe;\n\t\t\tkcqe_op = FCOE_KCQE_OPCODE_DISABLE_CONN;\n\t\t\tcid = req->context_id;\n\t\t\tl5_cid = req->conn_id;\n\t\t} else if (opcode == FCOE_KWQE_OPCODE_DESTROY) {\n\t\t\tkcqe_op = FCOE_KCQE_OPCODE_DESTROY_FUNC;\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\t\tkcqe.kcqe_op_flag = kcqe_op << KCQE_FLAGS_OPCODE_SHIFT;\n\t\tkcqe.kcqe_op_flag |= KCQE_FLAGS_LAYER_MASK_L5_FCOE;\n\t\tkcqe.kcqe_info1 = FCOE_KCQE_COMPLETION_STATUS_PARITY_ERROR;\n\t\tkcqe.kcqe_info2 = cid;\n\t\tkcqe.kcqe_info0 = l5_cid;\n\n\t} else if (layer_code == KWQE_FLAGS_LAYER_MASK_L5_ISCSI) {\n\t\tulp_type = CNIC_ULP_ISCSI;\n\t\tif (opcode == ISCSI_KWQE_OPCODE_UPDATE_CONN)\n\t\t\tcid = kwqe->kwqe_info1;\n\n\t\tkcqe.kcqe_op_flag = (opcode + 0x10) << KCQE_FLAGS_OPCODE_SHIFT;\n\t\tkcqe.kcqe_op_flag |= KCQE_FLAGS_LAYER_MASK_L5_ISCSI;\n\t\tkcqe.kcqe_info1 = ISCSI_KCQE_COMPLETION_STATUS_PARITY_ERR;\n\t\tkcqe.kcqe_info2 = cid;\n\t\tcnic_get_l5_cid(cp, BNX2X_SW_CID(cid), &kcqe.kcqe_info0);\n\n\t} else if (layer_code == KWQE_FLAGS_LAYER_MASK_L4) {\n\t\tstruct l4_kcq *l4kcqe = (struct l4_kcq *) &kcqe;\n\n\t\tulp_type = CNIC_ULP_L4;\n\t\tif (opcode == L4_KWQE_OPCODE_VALUE_CONNECT1)\n\t\t\tkcqe_op = L4_KCQE_OPCODE_VALUE_CONNECT_COMPLETE;\n\t\telse if (opcode == L4_KWQE_OPCODE_VALUE_RESET)\n\t\t\tkcqe_op = L4_KCQE_OPCODE_VALUE_RESET_COMP;\n\t\telse if (opcode == L4_KWQE_OPCODE_VALUE_CLOSE)\n\t\t\tkcqe_op = L4_KCQE_OPCODE_VALUE_CLOSE_COMP;\n\t\telse\n\t\t\treturn;\n\n\t\tkcqe.kcqe_op_flag = (kcqe_op << KCQE_FLAGS_OPCODE_SHIFT) |\n\t\t\t\t    KCQE_FLAGS_LAYER_MASK_L4;\n\t\tl4kcqe->status = L4_KCQE_COMPLETION_STATUS_PARITY_ERROR;\n\t\tl4kcqe->cid = cid;\n\t\tcnic_get_l5_cid(cp, BNX2X_SW_CID(cid), &l4kcqe->conn_id);\n\t} else {\n\t\treturn;\n\t}\n\n\tcqes[0] = &kcqe;\n\tcnic_reply_bnx2x_kcqes(dev, ulp_type, cqes, 1);\n}\n\nstatic int cnic_submit_bnx2x_iscsi_kwqes(struct cnic_dev *dev,\n\t\t\t\t\t struct kwqe *wqes[], u32 num_wqes)\n{\n\tint i, work, ret;\n\tu32 opcode;\n\tstruct kwqe *kwqe;\n\n\tif (!test_bit(CNIC_F_CNIC_UP, &dev->flags))\n\t\treturn -EAGAIN;\t\t \n\n\tfor (i = 0; i < num_wqes; ) {\n\t\tkwqe = wqes[i];\n\t\topcode = KWQE_OPCODE(kwqe->kwqe_op_flag);\n\t\twork = 1;\n\n\t\tswitch (opcode) {\n\t\tcase ISCSI_KWQE_OPCODE_INIT1:\n\t\t\tret = cnic_bnx2x_iscsi_init1(dev, kwqe);\n\t\t\tbreak;\n\t\tcase ISCSI_KWQE_OPCODE_INIT2:\n\t\t\tret = cnic_bnx2x_iscsi_init2(dev, kwqe);\n\t\t\tbreak;\n\t\tcase ISCSI_KWQE_OPCODE_OFFLOAD_CONN1:\n\t\t\tret = cnic_bnx2x_iscsi_ofld1(dev, &wqes[i],\n\t\t\t\t\t\t     num_wqes - i, &work);\n\t\t\tbreak;\n\t\tcase ISCSI_KWQE_OPCODE_UPDATE_CONN:\n\t\t\tret = cnic_bnx2x_iscsi_update(dev, kwqe);\n\t\t\tbreak;\n\t\tcase ISCSI_KWQE_OPCODE_DESTROY_CONN:\n\t\t\tret = cnic_bnx2x_iscsi_destroy(dev, kwqe);\n\t\t\tbreak;\n\t\tcase L4_KWQE_OPCODE_VALUE_CONNECT1:\n\t\t\tret = cnic_bnx2x_connect(dev, &wqes[i], num_wqes - i,\n\t\t\t\t\t\t &work);\n\t\t\tbreak;\n\t\tcase L4_KWQE_OPCODE_VALUE_CLOSE:\n\t\t\tret = cnic_bnx2x_close(dev, kwqe);\n\t\t\tbreak;\n\t\tcase L4_KWQE_OPCODE_VALUE_RESET:\n\t\t\tret = cnic_bnx2x_reset(dev, kwqe);\n\t\t\tbreak;\n\t\tcase L4_KWQE_OPCODE_VALUE_OFFLOAD_PG:\n\t\t\tret = cnic_bnx2x_offload_pg(dev, kwqe);\n\t\t\tbreak;\n\t\tcase L4_KWQE_OPCODE_VALUE_UPDATE_PG:\n\t\t\tret = cnic_bnx2x_update_pg(dev, kwqe);\n\t\t\tbreak;\n\t\tcase L4_KWQE_OPCODE_VALUE_UPLOAD_PG:\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = 0;\n\t\t\tnetdev_err(dev->netdev, \"Unknown type of KWQE(0x%x)\\n\",\n\t\t\t\t   opcode);\n\t\t\tbreak;\n\t\t}\n\t\tif (ret < 0) {\n\t\t\tnetdev_err(dev->netdev, \"KWQE(0x%x) failed\\n\",\n\t\t\t\t   opcode);\n\n\t\t\t \n\t\t\tif (ret == -EIO || ret == -EAGAIN)\n\t\t\t\tcnic_bnx2x_kwqe_err(dev, kwqe);\n\t\t}\n\t\ti += work;\n\t}\n\treturn 0;\n}\n\nstatic int cnic_submit_bnx2x_fcoe_kwqes(struct cnic_dev *dev,\n\t\t\t\t\tstruct kwqe *wqes[], u32 num_wqes)\n{\n\tstruct bnx2x *bp = netdev_priv(dev->netdev);\n\tint i, work, ret;\n\tu32 opcode;\n\tstruct kwqe *kwqe;\n\n\tif (!test_bit(CNIC_F_CNIC_UP, &dev->flags))\n\t\treturn -EAGAIN;\t\t \n\n\tif (!BNX2X_CHIP_IS_E2_PLUS(bp))\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < num_wqes; ) {\n\t\tkwqe = wqes[i];\n\t\topcode = KWQE_OPCODE(kwqe->kwqe_op_flag);\n\t\twork = 1;\n\n\t\tswitch (opcode) {\n\t\tcase FCOE_KWQE_OPCODE_INIT1:\n\t\t\tret = cnic_bnx2x_fcoe_init1(dev, &wqes[i],\n\t\t\t\t\t\t    num_wqes - i, &work);\n\t\t\tbreak;\n\t\tcase FCOE_KWQE_OPCODE_OFFLOAD_CONN1:\n\t\t\tret = cnic_bnx2x_fcoe_ofld1(dev, &wqes[i],\n\t\t\t\t\t\t    num_wqes - i, &work);\n\t\t\tbreak;\n\t\tcase FCOE_KWQE_OPCODE_ENABLE_CONN:\n\t\t\tret = cnic_bnx2x_fcoe_enable(dev, kwqe);\n\t\t\tbreak;\n\t\tcase FCOE_KWQE_OPCODE_DISABLE_CONN:\n\t\t\tret = cnic_bnx2x_fcoe_disable(dev, kwqe);\n\t\t\tbreak;\n\t\tcase FCOE_KWQE_OPCODE_DESTROY_CONN:\n\t\t\tret = cnic_bnx2x_fcoe_destroy(dev, kwqe);\n\t\t\tbreak;\n\t\tcase FCOE_KWQE_OPCODE_DESTROY:\n\t\t\tret = cnic_bnx2x_fcoe_fw_destroy(dev, kwqe);\n\t\t\tbreak;\n\t\tcase FCOE_KWQE_OPCODE_STAT:\n\t\t\tret = cnic_bnx2x_fcoe_stat(dev, kwqe);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = 0;\n\t\t\tnetdev_err(dev->netdev, \"Unknown type of KWQE(0x%x)\\n\",\n\t\t\t\t   opcode);\n\t\t\tbreak;\n\t\t}\n\t\tif (ret < 0) {\n\t\t\tnetdev_err(dev->netdev, \"KWQE(0x%x) failed\\n\",\n\t\t\t\t   opcode);\n\n\t\t\t \n\t\t\tif (ret == -EIO || ret == -EAGAIN)\n\t\t\t\tcnic_bnx2x_kwqe_err(dev, kwqe);\n\t\t}\n\t\ti += work;\n\t}\n\treturn 0;\n}\n\nstatic int cnic_submit_bnx2x_kwqes(struct cnic_dev *dev, struct kwqe *wqes[],\n\t\t\t\t   u32 num_wqes)\n{\n\tint ret = -EINVAL;\n\tu32 layer_code;\n\n\tif (!test_bit(CNIC_F_CNIC_UP, &dev->flags))\n\t\treturn -EAGAIN;\t\t \n\n\tif (!num_wqes)\n\t\treturn 0;\n\n\tlayer_code = wqes[0]->kwqe_op_flag & KWQE_LAYER_MASK;\n\tswitch (layer_code) {\n\tcase KWQE_FLAGS_LAYER_MASK_L5_ISCSI:\n\tcase KWQE_FLAGS_LAYER_MASK_L4:\n\tcase KWQE_FLAGS_LAYER_MASK_L2:\n\t\tret = cnic_submit_bnx2x_iscsi_kwqes(dev, wqes, num_wqes);\n\t\tbreak;\n\n\tcase KWQE_FLAGS_LAYER_MASK_L5_FCOE:\n\t\tret = cnic_submit_bnx2x_fcoe_kwqes(dev, wqes, num_wqes);\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic inline u32 cnic_get_kcqe_layer_mask(u32 opflag)\n{\n\tif (unlikely(KCQE_OPCODE(opflag) == FCOE_RAMROD_CMD_ID_TERMINATE_CONN))\n\t\treturn KCQE_FLAGS_LAYER_MASK_L4;\n\n\treturn opflag & KCQE_FLAGS_LAYER_MASK;\n}\n\nstatic void service_kcqes(struct cnic_dev *dev, int num_cqes)\n{\n\tstruct cnic_local *cp = dev->cnic_priv;\n\tint i, j, comp = 0;\n\n\ti = 0;\n\tj = 1;\n\twhile (num_cqes) {\n\t\tstruct cnic_ulp_ops *ulp_ops;\n\t\tint ulp_type;\n\t\tu32 kcqe_op_flag = cp->completed_kcq[i]->kcqe_op_flag;\n\t\tu32 kcqe_layer = cnic_get_kcqe_layer_mask(kcqe_op_flag);\n\n\t\tif (unlikely(kcqe_op_flag & KCQE_RAMROD_COMPLETION))\n\t\t\tcomp++;\n\n\t\twhile (j < num_cqes) {\n\t\t\tu32 next_op = cp->completed_kcq[i + j]->kcqe_op_flag;\n\n\t\t\tif (cnic_get_kcqe_layer_mask(next_op) != kcqe_layer)\n\t\t\t\tbreak;\n\n\t\t\tif (unlikely(next_op & KCQE_RAMROD_COMPLETION))\n\t\t\t\tcomp++;\n\t\t\tj++;\n\t\t}\n\n\t\tif (kcqe_layer == KCQE_FLAGS_LAYER_MASK_L5_RDMA)\n\t\t\tulp_type = CNIC_ULP_RDMA;\n\t\telse if (kcqe_layer == KCQE_FLAGS_LAYER_MASK_L5_ISCSI)\n\t\t\tulp_type = CNIC_ULP_ISCSI;\n\t\telse if (kcqe_layer == KCQE_FLAGS_LAYER_MASK_L5_FCOE)\n\t\t\tulp_type = CNIC_ULP_FCOE;\n\t\telse if (kcqe_layer == KCQE_FLAGS_LAYER_MASK_L4)\n\t\t\tulp_type = CNIC_ULP_L4;\n\t\telse if (kcqe_layer == KCQE_FLAGS_LAYER_MASK_L2)\n\t\t\tgoto end;\n\t\telse {\n\t\t\tnetdev_err(dev->netdev, \"Unknown type of KCQE(0x%x)\\n\",\n\t\t\t\t   kcqe_op_flag);\n\t\t\tgoto end;\n\t\t}\n\n\t\trcu_read_lock();\n\t\tulp_ops = rcu_dereference(cp->ulp_ops[ulp_type]);\n\t\tif (likely(ulp_ops)) {\n\t\t\tulp_ops->indicate_kcqes(cp->ulp_handle[ulp_type],\n\t\t\t\t\t\t  cp->completed_kcq + i, j);\n\t\t}\n\t\trcu_read_unlock();\nend:\n\t\tnum_cqes -= j;\n\t\ti += j;\n\t\tj = 1;\n\t}\n\tif (unlikely(comp))\n\t\tcnic_spq_completion(dev, DRV_CTL_RET_L5_SPQ_CREDIT_CMD, comp);\n}\n\nstatic int cnic_get_kcqes(struct cnic_dev *dev, struct kcq_info *info)\n{\n\tstruct cnic_local *cp = dev->cnic_priv;\n\tu16 i, ri, hw_prod, last;\n\tstruct kcqe *kcqe;\n\tint kcqe_cnt = 0, last_cnt = 0;\n\n\ti = ri = last = info->sw_prod_idx;\n\tri &= MAX_KCQ_IDX;\n\thw_prod = *info->hw_prod_idx_ptr;\n\thw_prod = info->hw_idx(hw_prod);\n\n\twhile ((i != hw_prod) && (kcqe_cnt < MAX_COMPLETED_KCQE)) {\n\t\tkcqe = &info->kcq[KCQ_PG(ri)][KCQ_IDX(ri)];\n\t\tcp->completed_kcq[kcqe_cnt++] = kcqe;\n\t\ti = info->next_idx(i);\n\t\tri = i & MAX_KCQ_IDX;\n\t\tif (likely(!(kcqe->kcqe_op_flag & KCQE_FLAGS_NEXT))) {\n\t\t\tlast_cnt = kcqe_cnt;\n\t\t\tlast = i;\n\t\t}\n\t}\n\n\tinfo->sw_prod_idx = last;\n\treturn last_cnt;\n}\n\nstatic int cnic_l2_completion(struct cnic_local *cp)\n{\n\tu16 hw_cons, sw_cons;\n\tstruct cnic_uio_dev *udev = cp->udev;\n\tunion eth_rx_cqe *cqe, *cqe_ring = (union eth_rx_cqe *)\n\t\t\t\t\t(udev->l2_ring + (2 * CNIC_PAGE_SIZE));\n\tu32 cmd;\n\tint comp = 0;\n\n\tif (!test_bit(CNIC_F_BNX2X_CLASS, &cp->dev->flags))\n\t\treturn 0;\n\n\thw_cons = *cp->rx_cons_ptr;\n\tif ((hw_cons & BNX2X_MAX_RCQ_DESC_CNT) == BNX2X_MAX_RCQ_DESC_CNT)\n\t\thw_cons++;\n\n\tsw_cons = cp->rx_cons;\n\twhile (sw_cons != hw_cons) {\n\t\tu8 cqe_fp_flags;\n\n\t\tcqe = &cqe_ring[sw_cons & BNX2X_MAX_RCQ_DESC_CNT];\n\t\tcqe_fp_flags = cqe->fast_path_cqe.type_error_flags;\n\t\tif (cqe_fp_flags & ETH_FAST_PATH_RX_CQE_TYPE) {\n\t\t\tcmd = le32_to_cpu(cqe->ramrod_cqe.conn_and_cmd_data);\n\t\t\tcmd >>= COMMON_RAMROD_ETH_RX_CQE_CMD_ID_SHIFT;\n\t\t\tif (cmd == RAMROD_CMD_ID_ETH_CLIENT_SETUP ||\n\t\t\t    cmd == RAMROD_CMD_ID_ETH_HALT)\n\t\t\t\tcomp++;\n\t\t}\n\t\tsw_cons = BNX2X_NEXT_RCQE(sw_cons);\n\t}\n\treturn comp;\n}\n\nstatic void cnic_chk_pkt_rings(struct cnic_local *cp)\n{\n\tu16 rx_cons, tx_cons;\n\tint comp = 0;\n\n\tif (!test_bit(CNIC_LCL_FL_RINGS_INITED, &cp->cnic_local_flags))\n\t\treturn;\n\n\trx_cons = *cp->rx_cons_ptr;\n\ttx_cons = *cp->tx_cons_ptr;\n\tif (cp->tx_cons != tx_cons || cp->rx_cons != rx_cons) {\n\t\tif (test_bit(CNIC_LCL_FL_L2_WAIT, &cp->cnic_local_flags))\n\t\t\tcomp = cnic_l2_completion(cp);\n\n\t\tcp->tx_cons = tx_cons;\n\t\tcp->rx_cons = rx_cons;\n\n\t\tif (cp->udev)\n\t\t\tuio_event_notify(&cp->udev->cnic_uinfo);\n\t}\n\tif (comp)\n\t\tclear_bit(CNIC_LCL_FL_L2_WAIT, &cp->cnic_local_flags);\n}\n\nstatic u32 cnic_service_bnx2_queues(struct cnic_dev *dev)\n{\n\tstruct cnic_local *cp = dev->cnic_priv;\n\tu32 status_idx = (u16) *cp->kcq1.status_idx_ptr;\n\tint kcqe_cnt;\n\n\t \n\trmb();\n\tcp->kwq_con_idx = *cp->kwq_con_idx_ptr;\n\n\twhile ((kcqe_cnt = cnic_get_kcqes(dev, &cp->kcq1))) {\n\n\t\tservice_kcqes(dev, kcqe_cnt);\n\n\t\t \n\t\tbarrier();\n\t\tstatus_idx = (u16) *cp->kcq1.status_idx_ptr;\n\t\t \n\t\trmb();\n\t\tcp->kwq_con_idx = *cp->kwq_con_idx_ptr;\n\t}\n\n\tCNIC_WR16(dev, cp->kcq1.io_addr, cp->kcq1.sw_prod_idx);\n\n\tcnic_chk_pkt_rings(cp);\n\n\treturn status_idx;\n}\n\nstatic int cnic_service_bnx2(void *data, void *status_blk)\n{\n\tstruct cnic_dev *dev = data;\n\n\tif (unlikely(!test_bit(CNIC_F_CNIC_UP, &dev->flags))) {\n\t\tstruct status_block *sblk = status_blk;\n\n\t\treturn sblk->status_idx;\n\t}\n\n\treturn cnic_service_bnx2_queues(dev);\n}\n\nstatic void cnic_service_bnx2_msix(struct tasklet_struct *t)\n{\n\tstruct cnic_local *cp = from_tasklet(cp, t, cnic_irq_task);\n\tstruct cnic_dev *dev = cp->dev;\n\n\tcp->last_status_idx = cnic_service_bnx2_queues(dev);\n\n\tCNIC_WR(dev, BNX2_PCICFG_INT_ACK_CMD, cp->int_num |\n\t\tBNX2_PCICFG_INT_ACK_CMD_INDEX_VALID | cp->last_status_idx);\n}\n\nstatic void cnic_doirq(struct cnic_dev *dev)\n{\n\tstruct cnic_local *cp = dev->cnic_priv;\n\n\tif (likely(test_bit(CNIC_F_CNIC_UP, &dev->flags))) {\n\t\tu16 prod = cp->kcq1.sw_prod_idx & MAX_KCQ_IDX;\n\n\t\tprefetch(cp->status_blk.gen);\n\t\tprefetch(&cp->kcq1.kcq[KCQ_PG(prod)][KCQ_IDX(prod)]);\n\n\t\ttasklet_schedule(&cp->cnic_irq_task);\n\t}\n}\n\nstatic irqreturn_t cnic_irq(int irq, void *dev_instance)\n{\n\tstruct cnic_dev *dev = dev_instance;\n\tstruct cnic_local *cp = dev->cnic_priv;\n\n\tif (cp->ack_int)\n\t\tcp->ack_int(dev);\n\n\tcnic_doirq(dev);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic inline void cnic_ack_bnx2x_int(struct cnic_dev *dev, u8 id, u8 storm,\n\t\t\t\t      u16 index, u8 op, u8 update)\n{\n\tstruct bnx2x *bp = netdev_priv(dev->netdev);\n\tu32 hc_addr = (HC_REG_COMMAND_REG + BP_PORT(bp) * 32 +\n\t\t       COMMAND_REG_INT_ACK);\n\tstruct igu_ack_register igu_ack;\n\n\tigu_ack.status_block_index = index;\n\tigu_ack.sb_id_and_flags =\n\t\t\t((id << IGU_ACK_REGISTER_STATUS_BLOCK_ID_SHIFT) |\n\t\t\t (storm << IGU_ACK_REGISTER_STORM_ID_SHIFT) |\n\t\t\t (update << IGU_ACK_REGISTER_UPDATE_INDEX_SHIFT) |\n\t\t\t (op << IGU_ACK_REGISTER_INTERRUPT_MODE_SHIFT));\n\n\tCNIC_WR(dev, hc_addr, (*(u32 *)&igu_ack));\n}\n\nstatic void cnic_ack_igu_sb(struct cnic_dev *dev, u8 igu_sb_id, u8 segment,\n\t\t\t    u16 index, u8 op, u8 update)\n{\n\tstruct igu_regular cmd_data;\n\tu32 igu_addr = BAR_IGU_INTMEM + (IGU_CMD_INT_ACK_BASE + igu_sb_id) * 8;\n\n\tcmd_data.sb_id_and_flags =\n\t\t(index << IGU_REGULAR_SB_INDEX_SHIFT) |\n\t\t(segment << IGU_REGULAR_SEGMENT_ACCESS_SHIFT) |\n\t\t(update << IGU_REGULAR_BUPDATE_SHIFT) |\n\t\t(op << IGU_REGULAR_ENABLE_INT_SHIFT);\n\n\n\tCNIC_WR(dev, igu_addr, cmd_data.sb_id_and_flags);\n}\n\nstatic void cnic_ack_bnx2x_msix(struct cnic_dev *dev)\n{\n\tstruct cnic_local *cp = dev->cnic_priv;\n\n\tcnic_ack_bnx2x_int(dev, cp->bnx2x_igu_sb_id, CSTORM_ID, 0,\n\t\t\t   IGU_INT_DISABLE, 0);\n}\n\nstatic void cnic_ack_bnx2x_e2_msix(struct cnic_dev *dev)\n{\n\tstruct cnic_local *cp = dev->cnic_priv;\n\n\tcnic_ack_igu_sb(dev, cp->bnx2x_igu_sb_id, IGU_SEG_ACCESS_DEF, 0,\n\t\t\tIGU_INT_DISABLE, 0);\n}\n\nstatic void cnic_arm_bnx2x_msix(struct cnic_dev *dev, u32 idx)\n{\n\tstruct cnic_local *cp = dev->cnic_priv;\n\n\tcnic_ack_bnx2x_int(dev, cp->bnx2x_igu_sb_id, CSTORM_ID, idx,\n\t\t\t   IGU_INT_ENABLE, 1);\n}\n\nstatic void cnic_arm_bnx2x_e2_msix(struct cnic_dev *dev, u32 idx)\n{\n\tstruct cnic_local *cp = dev->cnic_priv;\n\n\tcnic_ack_igu_sb(dev, cp->bnx2x_igu_sb_id, IGU_SEG_ACCESS_DEF, idx,\n\t\t\tIGU_INT_ENABLE, 1);\n}\n\nstatic u32 cnic_service_bnx2x_kcq(struct cnic_dev *dev, struct kcq_info *info)\n{\n\tu32 last_status = *info->status_idx_ptr;\n\tint kcqe_cnt;\n\n\t \n\trmb();\n\twhile ((kcqe_cnt = cnic_get_kcqes(dev, info))) {\n\n\t\tservice_kcqes(dev, kcqe_cnt);\n\n\t\t \n\t\tbarrier();\n\n\t\tlast_status = *info->status_idx_ptr;\n\t\t \n\t\trmb();\n\t}\n\treturn last_status;\n}\n\nstatic void cnic_service_bnx2x_bh(struct tasklet_struct *t)\n{\n\tstruct cnic_local *cp = from_tasklet(cp, t, cnic_irq_task);\n\tstruct cnic_dev *dev = cp->dev;\n\tstruct bnx2x *bp = netdev_priv(dev->netdev);\n\tu32 status_idx, new_status_idx;\n\n\tif (unlikely(!test_bit(CNIC_F_CNIC_UP, &dev->flags)))\n\t\treturn;\n\n\twhile (1) {\n\t\tstatus_idx = cnic_service_bnx2x_kcq(dev, &cp->kcq1);\n\n\t\tCNIC_WR16(dev, cp->kcq1.io_addr,\n\t\t\t  cp->kcq1.sw_prod_idx + MAX_KCQ_IDX);\n\n\t\tif (!CNIC_SUPPORTS_FCOE(bp)) {\n\t\t\tcp->arm_int(dev, status_idx);\n\t\t\tbreak;\n\t\t}\n\n\t\tnew_status_idx = cnic_service_bnx2x_kcq(dev, &cp->kcq2);\n\n\t\tif (new_status_idx != status_idx)\n\t\t\tcontinue;\n\n\t\tCNIC_WR16(dev, cp->kcq2.io_addr, cp->kcq2.sw_prod_idx +\n\t\t\t  MAX_KCQ_IDX);\n\n\t\tcnic_ack_igu_sb(dev, cp->bnx2x_igu_sb_id, IGU_SEG_ACCESS_DEF,\n\t\t\t\tstatus_idx, IGU_INT_ENABLE, 1);\n\n\t\tbreak;\n\t}\n}\n\nstatic int cnic_service_bnx2x(void *data, void *status_blk)\n{\n\tstruct cnic_dev *dev = data;\n\tstruct cnic_local *cp = dev->cnic_priv;\n\n\tif (!(cp->ethdev->drv_state & CNIC_DRV_STATE_USING_MSIX))\n\t\tcnic_doirq(dev);\n\n\tcnic_chk_pkt_rings(cp);\n\n\treturn 0;\n}\n\nstatic void cnic_ulp_stop_one(struct cnic_local *cp, int if_type)\n{\n\tstruct cnic_ulp_ops *ulp_ops;\n\n\tif (if_type == CNIC_ULP_ISCSI)\n\t\tcnic_send_nlmsg(cp, ISCSI_KEVENT_IF_DOWN, NULL);\n\n\tmutex_lock(&cnic_lock);\n\tulp_ops = rcu_dereference_protected(cp->ulp_ops[if_type],\n\t\t\t\t\t    lockdep_is_held(&cnic_lock));\n\tif (!ulp_ops) {\n\t\tmutex_unlock(&cnic_lock);\n\t\treturn;\n\t}\n\tset_bit(ULP_F_CALL_PENDING, &cp->ulp_flags[if_type]);\n\tmutex_unlock(&cnic_lock);\n\n\tif (test_and_clear_bit(ULP_F_START, &cp->ulp_flags[if_type]))\n\t\tulp_ops->cnic_stop(cp->ulp_handle[if_type]);\n\n\tclear_bit(ULP_F_CALL_PENDING, &cp->ulp_flags[if_type]);\n}\n\nstatic void cnic_ulp_stop(struct cnic_dev *dev)\n{\n\tstruct cnic_local *cp = dev->cnic_priv;\n\tint if_type;\n\n\tfor (if_type = 0; if_type < MAX_CNIC_ULP_TYPE; if_type++)\n\t\tcnic_ulp_stop_one(cp, if_type);\n}\n\nstatic void cnic_ulp_start(struct cnic_dev *dev)\n{\n\tstruct cnic_local *cp = dev->cnic_priv;\n\tint if_type;\n\n\tfor (if_type = 0; if_type < MAX_CNIC_ULP_TYPE; if_type++) {\n\t\tstruct cnic_ulp_ops *ulp_ops;\n\n\t\tmutex_lock(&cnic_lock);\n\t\tulp_ops = rcu_dereference_protected(cp->ulp_ops[if_type],\n\t\t\t\t\t\t    lockdep_is_held(&cnic_lock));\n\t\tif (!ulp_ops || !ulp_ops->cnic_start) {\n\t\t\tmutex_unlock(&cnic_lock);\n\t\t\tcontinue;\n\t\t}\n\t\tset_bit(ULP_F_CALL_PENDING, &cp->ulp_flags[if_type]);\n\t\tmutex_unlock(&cnic_lock);\n\n\t\tif (!test_and_set_bit(ULP_F_START, &cp->ulp_flags[if_type]))\n\t\t\tulp_ops->cnic_start(cp->ulp_handle[if_type]);\n\n\t\tclear_bit(ULP_F_CALL_PENDING, &cp->ulp_flags[if_type]);\n\t}\n}\n\nstatic int cnic_copy_ulp_stats(struct cnic_dev *dev, int ulp_type)\n{\n\tstruct cnic_local *cp = dev->cnic_priv;\n\tstruct cnic_ulp_ops *ulp_ops;\n\tint rc;\n\n\tmutex_lock(&cnic_lock);\n\tulp_ops = rcu_dereference_protected(cp->ulp_ops[ulp_type],\n\t\t\t\t\t    lockdep_is_held(&cnic_lock));\n\tif (ulp_ops && ulp_ops->cnic_get_stats)\n\t\trc = ulp_ops->cnic_get_stats(cp->ulp_handle[ulp_type]);\n\telse\n\t\trc = -ENODEV;\n\tmutex_unlock(&cnic_lock);\n\treturn rc;\n}\n\nstatic int cnic_ctl(void *data, struct cnic_ctl_info *info)\n{\n\tstruct cnic_dev *dev = data;\n\tint ulp_type = CNIC_ULP_ISCSI;\n\n\tswitch (info->cmd) {\n\tcase CNIC_CTL_STOP_CMD:\n\t\tcnic_hold(dev);\n\n\t\tcnic_ulp_stop(dev);\n\t\tcnic_stop_hw(dev);\n\n\t\tcnic_put(dev);\n\t\tbreak;\n\tcase CNIC_CTL_START_CMD:\n\t\tcnic_hold(dev);\n\n\t\tif (!cnic_start_hw(dev))\n\t\t\tcnic_ulp_start(dev);\n\n\t\tcnic_put(dev);\n\t\tbreak;\n\tcase CNIC_CTL_STOP_ISCSI_CMD: {\n\t\tstruct cnic_local *cp = dev->cnic_priv;\n\t\tset_bit(CNIC_LCL_FL_STOP_ISCSI, &cp->cnic_local_flags);\n\t\tqueue_delayed_work(cnic_wq, &cp->delete_task, 0);\n\t\tbreak;\n\t}\n\tcase CNIC_CTL_COMPLETION_CMD: {\n\t\tstruct cnic_ctl_completion *comp = &info->data.comp;\n\t\tu32 cid = BNX2X_SW_CID(comp->cid);\n\t\tu32 l5_cid;\n\t\tstruct cnic_local *cp = dev->cnic_priv;\n\n\t\tif (!test_bit(CNIC_F_CNIC_UP, &dev->flags))\n\t\t\tbreak;\n\n\t\tif (cnic_get_l5_cid(cp, cid, &l5_cid) == 0) {\n\t\t\tstruct cnic_context *ctx = &cp->ctx_tbl[l5_cid];\n\n\t\t\tif (unlikely(comp->error)) {\n\t\t\t\tset_bit(CTX_FL_CID_ERROR, &ctx->ctx_flags);\n\t\t\t\tnetdev_err(dev->netdev,\n\t\t\t\t\t   \"CID %x CFC delete comp error %x\\n\",\n\t\t\t\t\t   cid, comp->error);\n\t\t\t}\n\n\t\t\tctx->wait_cond = 1;\n\t\t\twake_up(&ctx->waitq);\n\t\t}\n\t\tbreak;\n\t}\n\tcase CNIC_CTL_FCOE_STATS_GET_CMD:\n\t\tulp_type = CNIC_ULP_FCOE;\n\t\tfallthrough;\n\tcase CNIC_CTL_ISCSI_STATS_GET_CMD:\n\t\tcnic_hold(dev);\n\t\tcnic_copy_ulp_stats(dev, ulp_type);\n\t\tcnic_put(dev);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic void cnic_ulp_init(struct cnic_dev *dev)\n{\n\tint i;\n\tstruct cnic_local *cp = dev->cnic_priv;\n\n\tfor (i = 0; i < MAX_CNIC_ULP_TYPE_EXT; i++) {\n\t\tstruct cnic_ulp_ops *ulp_ops;\n\n\t\tmutex_lock(&cnic_lock);\n\t\tulp_ops = cnic_ulp_tbl_prot(i);\n\t\tif (!ulp_ops || !ulp_ops->cnic_init) {\n\t\t\tmutex_unlock(&cnic_lock);\n\t\t\tcontinue;\n\t\t}\n\t\tulp_get(ulp_ops);\n\t\tmutex_unlock(&cnic_lock);\n\n\t\tif (!test_and_set_bit(ULP_F_INIT, &cp->ulp_flags[i]))\n\t\t\tulp_ops->cnic_init(dev);\n\n\t\tulp_put(ulp_ops);\n\t}\n}\n\nstatic void cnic_ulp_exit(struct cnic_dev *dev)\n{\n\tint i;\n\tstruct cnic_local *cp = dev->cnic_priv;\n\n\tfor (i = 0; i < MAX_CNIC_ULP_TYPE_EXT; i++) {\n\t\tstruct cnic_ulp_ops *ulp_ops;\n\n\t\tmutex_lock(&cnic_lock);\n\t\tulp_ops = cnic_ulp_tbl_prot(i);\n\t\tif (!ulp_ops || !ulp_ops->cnic_exit) {\n\t\t\tmutex_unlock(&cnic_lock);\n\t\t\tcontinue;\n\t\t}\n\t\tulp_get(ulp_ops);\n\t\tmutex_unlock(&cnic_lock);\n\n\t\tif (test_and_clear_bit(ULP_F_INIT, &cp->ulp_flags[i]))\n\t\t\tulp_ops->cnic_exit(dev);\n\n\t\tulp_put(ulp_ops);\n\t}\n}\n\nstatic int cnic_cm_offload_pg(struct cnic_sock *csk)\n{\n\tstruct cnic_dev *dev = csk->dev;\n\tstruct l4_kwq_offload_pg *l4kwqe;\n\tstruct kwqe *wqes[1];\n\n\tl4kwqe = (struct l4_kwq_offload_pg *) &csk->kwqe1;\n\tmemset(l4kwqe, 0, sizeof(*l4kwqe));\n\twqes[0] = (struct kwqe *) l4kwqe;\n\n\tl4kwqe->op_code = L4_KWQE_OPCODE_VALUE_OFFLOAD_PG;\n\tl4kwqe->flags =\n\t\tL4_LAYER_CODE << L4_KWQ_OFFLOAD_PG_LAYER_CODE_SHIFT;\n\tl4kwqe->l2hdr_nbytes = ETH_HLEN;\n\n\tl4kwqe->da0 = csk->ha[0];\n\tl4kwqe->da1 = csk->ha[1];\n\tl4kwqe->da2 = csk->ha[2];\n\tl4kwqe->da3 = csk->ha[3];\n\tl4kwqe->da4 = csk->ha[4];\n\tl4kwqe->da5 = csk->ha[5];\n\n\tl4kwqe->sa0 = dev->mac_addr[0];\n\tl4kwqe->sa1 = dev->mac_addr[1];\n\tl4kwqe->sa2 = dev->mac_addr[2];\n\tl4kwqe->sa3 = dev->mac_addr[3];\n\tl4kwqe->sa4 = dev->mac_addr[4];\n\tl4kwqe->sa5 = dev->mac_addr[5];\n\n\tl4kwqe->etype = ETH_P_IP;\n\tl4kwqe->ipid_start = DEF_IPID_START;\n\tl4kwqe->host_opaque = csk->l5_cid;\n\n\tif (csk->vlan_id) {\n\t\tl4kwqe->pg_flags |= L4_KWQ_OFFLOAD_PG_VLAN_TAGGING;\n\t\tl4kwqe->vlan_tag = csk->vlan_id;\n\t\tl4kwqe->l2hdr_nbytes += 4;\n\t}\n\n\treturn dev->submit_kwqes(dev, wqes, 1);\n}\n\nstatic int cnic_cm_update_pg(struct cnic_sock *csk)\n{\n\tstruct cnic_dev *dev = csk->dev;\n\tstruct l4_kwq_update_pg *l4kwqe;\n\tstruct kwqe *wqes[1];\n\n\tl4kwqe = (struct l4_kwq_update_pg *) &csk->kwqe1;\n\tmemset(l4kwqe, 0, sizeof(*l4kwqe));\n\twqes[0] = (struct kwqe *) l4kwqe;\n\n\tl4kwqe->opcode = L4_KWQE_OPCODE_VALUE_UPDATE_PG;\n\tl4kwqe->flags =\n\t\tL4_LAYER_CODE << L4_KWQ_UPDATE_PG_LAYER_CODE_SHIFT;\n\tl4kwqe->pg_cid = csk->pg_cid;\n\n\tl4kwqe->da0 = csk->ha[0];\n\tl4kwqe->da1 = csk->ha[1];\n\tl4kwqe->da2 = csk->ha[2];\n\tl4kwqe->da3 = csk->ha[3];\n\tl4kwqe->da4 = csk->ha[4];\n\tl4kwqe->da5 = csk->ha[5];\n\n\tl4kwqe->pg_host_opaque = csk->l5_cid;\n\tl4kwqe->pg_valids = L4_KWQ_UPDATE_PG_VALIDS_DA;\n\n\treturn dev->submit_kwqes(dev, wqes, 1);\n}\n\nstatic int cnic_cm_upload_pg(struct cnic_sock *csk)\n{\n\tstruct cnic_dev *dev = csk->dev;\n\tstruct l4_kwq_upload *l4kwqe;\n\tstruct kwqe *wqes[1];\n\n\tl4kwqe = (struct l4_kwq_upload *) &csk->kwqe1;\n\tmemset(l4kwqe, 0, sizeof(*l4kwqe));\n\twqes[0] = (struct kwqe *) l4kwqe;\n\n\tl4kwqe->opcode = L4_KWQE_OPCODE_VALUE_UPLOAD_PG;\n\tl4kwqe->flags =\n\t\tL4_LAYER_CODE << L4_KWQ_UPLOAD_LAYER_CODE_SHIFT;\n\tl4kwqe->cid = csk->pg_cid;\n\n\treturn dev->submit_kwqes(dev, wqes, 1);\n}\n\nstatic int cnic_cm_conn_req(struct cnic_sock *csk)\n{\n\tstruct cnic_dev *dev = csk->dev;\n\tstruct l4_kwq_connect_req1 *l4kwqe1;\n\tstruct l4_kwq_connect_req2 *l4kwqe2;\n\tstruct l4_kwq_connect_req3 *l4kwqe3;\n\tstruct kwqe *wqes[3];\n\tu8 tcp_flags = 0;\n\tint num_wqes = 2;\n\n\tl4kwqe1 = (struct l4_kwq_connect_req1 *) &csk->kwqe1;\n\tl4kwqe2 = (struct l4_kwq_connect_req2 *) &csk->kwqe2;\n\tl4kwqe3 = (struct l4_kwq_connect_req3 *) &csk->kwqe3;\n\tmemset(l4kwqe1, 0, sizeof(*l4kwqe1));\n\tmemset(l4kwqe2, 0, sizeof(*l4kwqe2));\n\tmemset(l4kwqe3, 0, sizeof(*l4kwqe3));\n\n\tl4kwqe3->op_code = L4_KWQE_OPCODE_VALUE_CONNECT3;\n\tl4kwqe3->flags =\n\t\tL4_LAYER_CODE << L4_KWQ_CONNECT_REQ3_LAYER_CODE_SHIFT;\n\tl4kwqe3->ka_timeout = csk->ka_timeout;\n\tl4kwqe3->ka_interval = csk->ka_interval;\n\tl4kwqe3->ka_max_probe_count = csk->ka_max_probe_count;\n\tl4kwqe3->tos = csk->tos;\n\tl4kwqe3->ttl = csk->ttl;\n\tl4kwqe3->snd_seq_scale = csk->snd_seq_scale;\n\tl4kwqe3->pmtu = csk->mtu;\n\tl4kwqe3->rcv_buf = csk->rcv_buf;\n\tl4kwqe3->snd_buf = csk->snd_buf;\n\tl4kwqe3->seed = csk->seed;\n\n\twqes[0] = (struct kwqe *) l4kwqe1;\n\tif (test_bit(SK_F_IPV6, &csk->flags)) {\n\t\twqes[1] = (struct kwqe *) l4kwqe2;\n\t\twqes[2] = (struct kwqe *) l4kwqe3;\n\t\tnum_wqes = 3;\n\n\t\tl4kwqe1->conn_flags = L4_KWQ_CONNECT_REQ1_IP_V6;\n\t\tl4kwqe2->op_code = L4_KWQE_OPCODE_VALUE_CONNECT2;\n\t\tl4kwqe2->flags =\n\t\t\tL4_KWQ_CONNECT_REQ2_LINKED_WITH_NEXT |\n\t\t\tL4_LAYER_CODE << L4_KWQ_CONNECT_REQ2_LAYER_CODE_SHIFT;\n\t\tl4kwqe2->src_ip_v6_2 = be32_to_cpu(csk->src_ip[1]);\n\t\tl4kwqe2->src_ip_v6_3 = be32_to_cpu(csk->src_ip[2]);\n\t\tl4kwqe2->src_ip_v6_4 = be32_to_cpu(csk->src_ip[3]);\n\t\tl4kwqe2->dst_ip_v6_2 = be32_to_cpu(csk->dst_ip[1]);\n\t\tl4kwqe2->dst_ip_v6_3 = be32_to_cpu(csk->dst_ip[2]);\n\t\tl4kwqe2->dst_ip_v6_4 = be32_to_cpu(csk->dst_ip[3]);\n\t\tl4kwqe3->mss = l4kwqe3->pmtu - sizeof(struct ipv6hdr) -\n\t\t\t       sizeof(struct tcphdr);\n\t} else {\n\t\twqes[1] = (struct kwqe *) l4kwqe3;\n\t\tl4kwqe3->mss = l4kwqe3->pmtu - sizeof(struct iphdr) -\n\t\t\t       sizeof(struct tcphdr);\n\t}\n\n\tl4kwqe1->op_code = L4_KWQE_OPCODE_VALUE_CONNECT1;\n\tl4kwqe1->flags =\n\t\t(L4_LAYER_CODE << L4_KWQ_CONNECT_REQ1_LAYER_CODE_SHIFT) |\n\t\t L4_KWQ_CONNECT_REQ3_LINKED_WITH_NEXT;\n\tl4kwqe1->cid = csk->cid;\n\tl4kwqe1->pg_cid = csk->pg_cid;\n\tl4kwqe1->src_ip = be32_to_cpu(csk->src_ip[0]);\n\tl4kwqe1->dst_ip = be32_to_cpu(csk->dst_ip[0]);\n\tl4kwqe1->src_port = be16_to_cpu(csk->src_port);\n\tl4kwqe1->dst_port = be16_to_cpu(csk->dst_port);\n\tif (csk->tcp_flags & SK_TCP_NO_DELAY_ACK)\n\t\ttcp_flags |= L4_KWQ_CONNECT_REQ1_NO_DELAY_ACK;\n\tif (csk->tcp_flags & SK_TCP_KEEP_ALIVE)\n\t\ttcp_flags |= L4_KWQ_CONNECT_REQ1_KEEP_ALIVE;\n\tif (csk->tcp_flags & SK_TCP_NAGLE)\n\t\ttcp_flags |= L4_KWQ_CONNECT_REQ1_NAGLE_ENABLE;\n\tif (csk->tcp_flags & SK_TCP_TIMESTAMP)\n\t\ttcp_flags |= L4_KWQ_CONNECT_REQ1_TIME_STAMP;\n\tif (csk->tcp_flags & SK_TCP_SACK)\n\t\ttcp_flags |= L4_KWQ_CONNECT_REQ1_SACK;\n\tif (csk->tcp_flags & SK_TCP_SEG_SCALING)\n\t\ttcp_flags |= L4_KWQ_CONNECT_REQ1_SEG_SCALING;\n\n\tl4kwqe1->tcp_flags = tcp_flags;\n\n\treturn dev->submit_kwqes(dev, wqes, num_wqes);\n}\n\nstatic int cnic_cm_close_req(struct cnic_sock *csk)\n{\n\tstruct cnic_dev *dev = csk->dev;\n\tstruct l4_kwq_close_req *l4kwqe;\n\tstruct kwqe *wqes[1];\n\n\tl4kwqe = (struct l4_kwq_close_req *) &csk->kwqe2;\n\tmemset(l4kwqe, 0, sizeof(*l4kwqe));\n\twqes[0] = (struct kwqe *) l4kwqe;\n\n\tl4kwqe->op_code = L4_KWQE_OPCODE_VALUE_CLOSE;\n\tl4kwqe->flags = L4_LAYER_CODE << L4_KWQ_CLOSE_REQ_LAYER_CODE_SHIFT;\n\tl4kwqe->cid = csk->cid;\n\n\treturn dev->submit_kwqes(dev, wqes, 1);\n}\n\nstatic int cnic_cm_abort_req(struct cnic_sock *csk)\n{\n\tstruct cnic_dev *dev = csk->dev;\n\tstruct l4_kwq_reset_req *l4kwqe;\n\tstruct kwqe *wqes[1];\n\n\tl4kwqe = (struct l4_kwq_reset_req *) &csk->kwqe2;\n\tmemset(l4kwqe, 0, sizeof(*l4kwqe));\n\twqes[0] = (struct kwqe *) l4kwqe;\n\n\tl4kwqe->op_code = L4_KWQE_OPCODE_VALUE_RESET;\n\tl4kwqe->flags = L4_LAYER_CODE << L4_KWQ_RESET_REQ_LAYER_CODE_SHIFT;\n\tl4kwqe->cid = csk->cid;\n\n\treturn dev->submit_kwqes(dev, wqes, 1);\n}\n\nstatic int cnic_cm_create(struct cnic_dev *dev, int ulp_type, u32 cid,\n\t\t\t  u32 l5_cid, struct cnic_sock **csk, void *context)\n{\n\tstruct cnic_local *cp = dev->cnic_priv;\n\tstruct cnic_sock *csk1;\n\n\tif (l5_cid >= MAX_CM_SK_TBL_SZ)\n\t\treturn -EINVAL;\n\n\tif (cp->ctx_tbl) {\n\t\tstruct cnic_context *ctx = &cp->ctx_tbl[l5_cid];\n\n\t\tif (test_bit(CTX_FL_OFFLD_START, &ctx->ctx_flags))\n\t\t\treturn -EAGAIN;\n\t}\n\n\tcsk1 = &cp->csk_tbl[l5_cid];\n\tif (atomic_read(&csk1->ref_count))\n\t\treturn -EAGAIN;\n\n\tif (test_and_set_bit(SK_F_INUSE, &csk1->flags))\n\t\treturn -EBUSY;\n\n\tcsk1->dev = dev;\n\tcsk1->cid = cid;\n\tcsk1->l5_cid = l5_cid;\n\tcsk1->ulp_type = ulp_type;\n\tcsk1->context = context;\n\n\tcsk1->ka_timeout = DEF_KA_TIMEOUT;\n\tcsk1->ka_interval = DEF_KA_INTERVAL;\n\tcsk1->ka_max_probe_count = DEF_KA_MAX_PROBE_COUNT;\n\tcsk1->tos = DEF_TOS;\n\tcsk1->ttl = DEF_TTL;\n\tcsk1->snd_seq_scale = DEF_SND_SEQ_SCALE;\n\tcsk1->rcv_buf = DEF_RCV_BUF;\n\tcsk1->snd_buf = DEF_SND_BUF;\n\tcsk1->seed = DEF_SEED;\n\tcsk1->tcp_flags = 0;\n\n\t*csk = csk1;\n\treturn 0;\n}\n\nstatic void cnic_cm_cleanup(struct cnic_sock *csk)\n{\n\tif (csk->src_port) {\n\t\tstruct cnic_dev *dev = csk->dev;\n\t\tstruct cnic_local *cp = dev->cnic_priv;\n\n\t\tcnic_free_id(&cp->csk_port_tbl, be16_to_cpu(csk->src_port));\n\t\tcsk->src_port = 0;\n\t}\n}\n\nstatic void cnic_close_conn(struct cnic_sock *csk)\n{\n\tif (test_bit(SK_F_PG_OFFLD_COMPLETE, &csk->flags)) {\n\t\tcnic_cm_upload_pg(csk);\n\t\tclear_bit(SK_F_PG_OFFLD_COMPLETE, &csk->flags);\n\t}\n\tcnic_cm_cleanup(csk);\n}\n\nstatic int cnic_cm_destroy(struct cnic_sock *csk)\n{\n\tif (!cnic_in_use(csk))\n\t\treturn -EINVAL;\n\n\tcsk_hold(csk);\n\tclear_bit(SK_F_INUSE, &csk->flags);\n\tsmp_mb__after_atomic();\n\twhile (atomic_read(&csk->ref_count) != 1)\n\t\tmsleep(1);\n\tcnic_cm_cleanup(csk);\n\n\tcsk->flags = 0;\n\tcsk_put(csk);\n\treturn 0;\n}\n\nstatic inline u16 cnic_get_vlan(struct net_device *dev,\n\t\t\t\tstruct net_device **vlan_dev)\n{\n\tif (is_vlan_dev(dev)) {\n\t\t*vlan_dev = vlan_dev_real_dev(dev);\n\t\treturn vlan_dev_vlan_id(dev);\n\t}\n\t*vlan_dev = dev;\n\treturn 0;\n}\n\nstatic int cnic_get_v4_route(struct sockaddr_in *dst_addr,\n\t\t\t     struct dst_entry **dst)\n{\n#if defined(CONFIG_INET)\n\tstruct rtable *rt;\n\n\trt = ip_route_output(&init_net, dst_addr->sin_addr.s_addr, 0, 0, 0);\n\tif (!IS_ERR(rt)) {\n\t\t*dst = &rt->dst;\n\t\treturn 0;\n\t}\n\treturn PTR_ERR(rt);\n#else\n\treturn -ENETUNREACH;\n#endif\n}\n\nstatic int cnic_get_v6_route(struct sockaddr_in6 *dst_addr,\n\t\t\t     struct dst_entry **dst)\n{\n#if IS_ENABLED(CONFIG_IPV6)\n\tstruct flowi6 fl6;\n\n\tmemset(&fl6, 0, sizeof(fl6));\n\tfl6.daddr = dst_addr->sin6_addr;\n\tif (ipv6_addr_type(&fl6.daddr) & IPV6_ADDR_LINKLOCAL)\n\t\tfl6.flowi6_oif = dst_addr->sin6_scope_id;\n\n\t*dst = ip6_route_output(&init_net, NULL, &fl6);\n\tif ((*dst)->error) {\n\t\tdst_release(*dst);\n\t\t*dst = NULL;\n\t\treturn -ENETUNREACH;\n\t} else\n\t\treturn 0;\n#endif\n\n\treturn -ENETUNREACH;\n}\n\nstatic struct cnic_dev *cnic_cm_select_dev(struct sockaddr_in *dst_addr,\n\t\t\t\t\t   int ulp_type)\n{\n\tstruct cnic_dev *dev = NULL;\n\tstruct dst_entry *dst;\n\tstruct net_device *netdev = NULL;\n\tint err = -ENETUNREACH;\n\n\tif (dst_addr->sin_family == AF_INET)\n\t\terr = cnic_get_v4_route(dst_addr, &dst);\n\telse if (dst_addr->sin_family == AF_INET6) {\n\t\tstruct sockaddr_in6 *dst_addr6 =\n\t\t\t(struct sockaddr_in6 *) dst_addr;\n\n\t\terr = cnic_get_v6_route(dst_addr6, &dst);\n\t} else\n\t\treturn NULL;\n\n\tif (err)\n\t\treturn NULL;\n\n\tif (!dst->dev)\n\t\tgoto done;\n\n\tcnic_get_vlan(dst->dev, &netdev);\n\n\tdev = cnic_from_netdev(netdev);\n\ndone:\n\tdst_release(dst);\n\tif (dev)\n\t\tcnic_put(dev);\n\treturn dev;\n}\n\nstatic int cnic_resolve_addr(struct cnic_sock *csk, struct cnic_sockaddr *saddr)\n{\n\tstruct cnic_dev *dev = csk->dev;\n\tstruct cnic_local *cp = dev->cnic_priv;\n\n\treturn cnic_send_nlmsg(cp, ISCSI_KEVENT_PATH_REQ, csk);\n}\n\nstatic int cnic_get_route(struct cnic_sock *csk, struct cnic_sockaddr *saddr)\n{\n\tstruct cnic_dev *dev = csk->dev;\n\tstruct cnic_local *cp = dev->cnic_priv;\n\tint is_v6, rc = 0;\n\tstruct dst_entry *dst = NULL;\n\tstruct net_device *realdev;\n\t__be16 local_port;\n\tu32 port_id;\n\n\tif (saddr->local.v6.sin6_family == AF_INET6 &&\n\t    saddr->remote.v6.sin6_family == AF_INET6)\n\t\tis_v6 = 1;\n\telse if (saddr->local.v4.sin_family == AF_INET &&\n\t\t saddr->remote.v4.sin_family == AF_INET)\n\t\tis_v6 = 0;\n\telse\n\t\treturn -EINVAL;\n\n\tclear_bit(SK_F_IPV6, &csk->flags);\n\n\tif (is_v6) {\n\t\tset_bit(SK_F_IPV6, &csk->flags);\n\t\tcnic_get_v6_route(&saddr->remote.v6, &dst);\n\n\t\tmemcpy(&csk->dst_ip[0], &saddr->remote.v6.sin6_addr,\n\t\t       sizeof(struct in6_addr));\n\t\tcsk->dst_port = saddr->remote.v6.sin6_port;\n\t\tlocal_port = saddr->local.v6.sin6_port;\n\n\t} else {\n\t\tcnic_get_v4_route(&saddr->remote.v4, &dst);\n\n\t\tcsk->dst_ip[0] = saddr->remote.v4.sin_addr.s_addr;\n\t\tcsk->dst_port = saddr->remote.v4.sin_port;\n\t\tlocal_port = saddr->local.v4.sin_port;\n\t}\n\n\tcsk->vlan_id = 0;\n\tcsk->mtu = dev->netdev->mtu;\n\tif (dst && dst->dev) {\n\t\tu16 vlan = cnic_get_vlan(dst->dev, &realdev);\n\t\tif (realdev == dev->netdev) {\n\t\t\tcsk->vlan_id = vlan;\n\t\t\tcsk->mtu = dst_mtu(dst);\n\t\t}\n\t}\n\n\tport_id = be16_to_cpu(local_port);\n\tif (port_id >= CNIC_LOCAL_PORT_MIN &&\n\t    port_id < CNIC_LOCAL_PORT_MAX) {\n\t\tif (cnic_alloc_id(&cp->csk_port_tbl, port_id))\n\t\t\tport_id = 0;\n\t} else\n\t\tport_id = 0;\n\n\tif (!port_id) {\n\t\tport_id = cnic_alloc_new_id(&cp->csk_port_tbl);\n\t\tif (port_id == -1) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto err_out;\n\t\t}\n\t\tlocal_port = cpu_to_be16(port_id);\n\t}\n\tcsk->src_port = local_port;\n\nerr_out:\n\tdst_release(dst);\n\treturn rc;\n}\n\nstatic void cnic_init_csk_state(struct cnic_sock *csk)\n{\n\tcsk->state = 0;\n\tclear_bit(SK_F_OFFLD_SCHED, &csk->flags);\n\tclear_bit(SK_F_CLOSING, &csk->flags);\n}\n\nstatic int cnic_cm_connect(struct cnic_sock *csk, struct cnic_sockaddr *saddr)\n{\n\tstruct cnic_local *cp = csk->dev->cnic_priv;\n\tint err = 0;\n\n\tif (cp->ethdev->drv_state & CNIC_DRV_STATE_NO_ISCSI)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!cnic_in_use(csk))\n\t\treturn -EINVAL;\n\n\tif (test_and_set_bit(SK_F_CONNECT_START, &csk->flags))\n\t\treturn -EINVAL;\n\n\tcnic_init_csk_state(csk);\n\n\terr = cnic_get_route(csk, saddr);\n\tif (err)\n\t\tgoto err_out;\n\n\terr = cnic_resolve_addr(csk, saddr);\n\tif (!err)\n\t\treturn 0;\n\nerr_out:\n\tclear_bit(SK_F_CONNECT_START, &csk->flags);\n\treturn err;\n}\n\nstatic int cnic_cm_abort(struct cnic_sock *csk)\n{\n\tstruct cnic_local *cp = csk->dev->cnic_priv;\n\tu32 opcode = L4_KCQE_OPCODE_VALUE_RESET_COMP;\n\n\tif (!cnic_in_use(csk))\n\t\treturn -EINVAL;\n\n\tif (cnic_abort_prep(csk))\n\t\treturn cnic_cm_abort_req(csk);\n\n\t \n\n\tcp->close_conn(csk, opcode);\n\tif (csk->state != opcode) {\n\t\t \n\t\twhile (test_bit(SK_F_PG_OFFLD_COMPLETE, &csk->flags))\n\t\t\tmsleep(1);\n\n\t\treturn -EALREADY;\n\t}\n\n\treturn 0;\n}\n\nstatic int cnic_cm_close(struct cnic_sock *csk)\n{\n\tif (!cnic_in_use(csk))\n\t\treturn -EINVAL;\n\n\tif (cnic_close_prep(csk)) {\n\t\tcsk->state = L4_KCQE_OPCODE_VALUE_CLOSE_COMP;\n\t\treturn cnic_cm_close_req(csk);\n\t} else {\n\t\t \n\t\twhile (test_bit(SK_F_PG_OFFLD_COMPLETE, &csk->flags))\n\t\t\tmsleep(1);\n\n\t\treturn -EALREADY;\n\t}\n\treturn 0;\n}\n\nstatic void cnic_cm_upcall(struct cnic_local *cp, struct cnic_sock *csk,\n\t\t\t   u8 opcode)\n{\n\tstruct cnic_ulp_ops *ulp_ops;\n\tint ulp_type = csk->ulp_type;\n\n\trcu_read_lock();\n\tulp_ops = rcu_dereference(cp->ulp_ops[ulp_type]);\n\tif (ulp_ops) {\n\t\tif (opcode == L4_KCQE_OPCODE_VALUE_CONNECT_COMPLETE)\n\t\t\tulp_ops->cm_connect_complete(csk);\n\t\telse if (opcode == L4_KCQE_OPCODE_VALUE_CLOSE_COMP)\n\t\t\tulp_ops->cm_close_complete(csk);\n\t\telse if (opcode == L4_KCQE_OPCODE_VALUE_RESET_RECEIVED)\n\t\t\tulp_ops->cm_remote_abort(csk);\n\t\telse if (opcode == L4_KCQE_OPCODE_VALUE_RESET_COMP)\n\t\t\tulp_ops->cm_abort_complete(csk);\n\t\telse if (opcode == L4_KCQE_OPCODE_VALUE_CLOSE_RECEIVED)\n\t\t\tulp_ops->cm_remote_close(csk);\n\t}\n\trcu_read_unlock();\n}\n\nstatic int cnic_cm_set_pg(struct cnic_sock *csk)\n{\n\tif (cnic_offld_prep(csk)) {\n\t\tif (test_bit(SK_F_PG_OFFLD_COMPLETE, &csk->flags))\n\t\t\tcnic_cm_update_pg(csk);\n\t\telse\n\t\t\tcnic_cm_offload_pg(csk);\n\t}\n\treturn 0;\n}\n\nstatic void cnic_cm_process_offld_pg(struct cnic_dev *dev, struct l4_kcq *kcqe)\n{\n\tstruct cnic_local *cp = dev->cnic_priv;\n\tu32 l5_cid = kcqe->pg_host_opaque;\n\tu8 opcode = kcqe->op_code;\n\tstruct cnic_sock *csk = &cp->csk_tbl[l5_cid];\n\n\tcsk_hold(csk);\n\tif (!cnic_in_use(csk))\n\t\tgoto done;\n\n\tif (opcode == L4_KCQE_OPCODE_VALUE_UPDATE_PG) {\n\t\tclear_bit(SK_F_OFFLD_SCHED, &csk->flags);\n\t\tgoto done;\n\t}\n\t \n\tif (kcqe->status == L4_KCQE_COMPLETION_STATUS_CTX_ALLOC_FAIL) {\n\t\tclear_bit(SK_F_OFFLD_SCHED, &csk->flags);\n\t\tcnic_cm_upcall(cp, csk,\n\t\t\t       L4_KCQE_OPCODE_VALUE_CONNECT_COMPLETE);\n\t\tgoto done;\n\t}\n\n\tcsk->pg_cid = kcqe->pg_cid;\n\tset_bit(SK_F_PG_OFFLD_COMPLETE, &csk->flags);\n\tcnic_cm_conn_req(csk);\n\ndone:\n\tcsk_put(csk);\n}\n\nstatic void cnic_process_fcoe_term_conn(struct cnic_dev *dev, struct kcqe *kcqe)\n{\n\tstruct cnic_local *cp = dev->cnic_priv;\n\tstruct fcoe_kcqe *fc_kcqe = (struct fcoe_kcqe *) kcqe;\n\tu32 l5_cid = fc_kcqe->fcoe_conn_id + BNX2X_FCOE_L5_CID_BASE;\n\tstruct cnic_context *ctx = &cp->ctx_tbl[l5_cid];\n\n\tctx->timestamp = jiffies;\n\tctx->wait_cond = 1;\n\twake_up(&ctx->waitq);\n}\n\nstatic void cnic_cm_process_kcqe(struct cnic_dev *dev, struct kcqe *kcqe)\n{\n\tstruct cnic_local *cp = dev->cnic_priv;\n\tstruct l4_kcq *l4kcqe = (struct l4_kcq *) kcqe;\n\tu8 opcode = l4kcqe->op_code;\n\tu32 l5_cid;\n\tstruct cnic_sock *csk;\n\n\tif (opcode == FCOE_RAMROD_CMD_ID_TERMINATE_CONN) {\n\t\tcnic_process_fcoe_term_conn(dev, kcqe);\n\t\treturn;\n\t}\n\tif (opcode == L4_KCQE_OPCODE_VALUE_OFFLOAD_PG ||\n\t    opcode == L4_KCQE_OPCODE_VALUE_UPDATE_PG) {\n\t\tcnic_cm_process_offld_pg(dev, l4kcqe);\n\t\treturn;\n\t}\n\n\tl5_cid = l4kcqe->conn_id;\n\tif (opcode & 0x80)\n\t\tl5_cid = l4kcqe->cid;\n\tif (l5_cid >= MAX_CM_SK_TBL_SZ)\n\t\treturn;\n\n\tcsk = &cp->csk_tbl[l5_cid];\n\tcsk_hold(csk);\n\n\tif (!cnic_in_use(csk)) {\n\t\tcsk_put(csk);\n\t\treturn;\n\t}\n\n\tswitch (opcode) {\n\tcase L5CM_RAMROD_CMD_ID_TCP_CONNECT:\n\t\tif (l4kcqe->status != 0) {\n\t\t\tclear_bit(SK_F_OFFLD_SCHED, &csk->flags);\n\t\t\tcnic_cm_upcall(cp, csk,\n\t\t\t\t       L4_KCQE_OPCODE_VALUE_CONNECT_COMPLETE);\n\t\t}\n\t\tbreak;\n\tcase L4_KCQE_OPCODE_VALUE_CONNECT_COMPLETE:\n\t\tif (l4kcqe->status == 0)\n\t\t\tset_bit(SK_F_OFFLD_COMPLETE, &csk->flags);\n\t\telse if (l4kcqe->status ==\n\t\t\t L4_KCQE_COMPLETION_STATUS_PARITY_ERROR)\n\t\t\tset_bit(SK_F_HW_ERR, &csk->flags);\n\n\t\tsmp_mb__before_atomic();\n\t\tclear_bit(SK_F_OFFLD_SCHED, &csk->flags);\n\t\tcnic_cm_upcall(cp, csk, opcode);\n\t\tbreak;\n\n\tcase L5CM_RAMROD_CMD_ID_CLOSE: {\n\t\tstruct iscsi_kcqe *l5kcqe = (struct iscsi_kcqe *) kcqe;\n\n\t\tif (l4kcqe->status == 0 && l5kcqe->completion_status == 0)\n\t\t\tbreak;\n\n\t\tnetdev_warn(dev->netdev, \"RAMROD CLOSE compl with status 0x%x completion status 0x%x\\n\",\n\t\t\t    l4kcqe->status, l5kcqe->completion_status);\n\t\topcode = L4_KCQE_OPCODE_VALUE_CLOSE_COMP;\n\t}\n\t\tfallthrough;\n\tcase L4_KCQE_OPCODE_VALUE_RESET_RECEIVED:\n\tcase L4_KCQE_OPCODE_VALUE_CLOSE_COMP:\n\tcase L4_KCQE_OPCODE_VALUE_RESET_COMP:\n\tcase L5CM_RAMROD_CMD_ID_SEARCHER_DELETE:\n\tcase L5CM_RAMROD_CMD_ID_TERMINATE_OFFLOAD:\n\t\tif (l4kcqe->status == L4_KCQE_COMPLETION_STATUS_PARITY_ERROR)\n\t\t\tset_bit(SK_F_HW_ERR, &csk->flags);\n\n\t\tcp->close_conn(csk, opcode);\n\t\tbreak;\n\n\tcase L4_KCQE_OPCODE_VALUE_CLOSE_RECEIVED:\n\t\t \n\t\tif (test_bit(CNIC_F_BNX2X_CLASS, &dev->flags) &&\n\t\t    !test_bit(SK_F_OFFLD_COMPLETE, &csk->flags) &&\n\t\t    csk->state == L4_KCQE_OPCODE_VALUE_CLOSE_COMP)\n\t\t\tcp->close_conn(csk, L4_KCQE_OPCODE_VALUE_RESET_COMP);\n\t\telse\n\t\t\tcnic_cm_upcall(cp, csk, opcode);\n\t\tbreak;\n\t}\n\tcsk_put(csk);\n}\n\nstatic void cnic_cm_indicate_kcqe(void *data, struct kcqe *kcqe[], u32 num)\n{\n\tstruct cnic_dev *dev = data;\n\tint i;\n\n\tfor (i = 0; i < num; i++)\n\t\tcnic_cm_process_kcqe(dev, kcqe[i]);\n}\n\nstatic struct cnic_ulp_ops cm_ulp_ops = {\n\t.indicate_kcqes\t\t= cnic_cm_indicate_kcqe,\n};\n\nstatic void cnic_cm_free_mem(struct cnic_dev *dev)\n{\n\tstruct cnic_local *cp = dev->cnic_priv;\n\n\tkvfree(cp->csk_tbl);\n\tcp->csk_tbl = NULL;\n\tcnic_free_id_tbl(&cp->csk_port_tbl);\n}\n\nstatic int cnic_cm_alloc_mem(struct cnic_dev *dev)\n{\n\tstruct cnic_local *cp = dev->cnic_priv;\n\tu32 port_id;\n\tint i;\n\n\tcp->csk_tbl = kvcalloc(MAX_CM_SK_TBL_SZ, sizeof(struct cnic_sock),\n\t\t\t       GFP_KERNEL);\n\tif (!cp->csk_tbl)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < MAX_CM_SK_TBL_SZ; i++)\n\t\tatomic_set(&cp->csk_tbl[i].ref_count, 0);\n\n\tport_id = get_random_u32_below(CNIC_LOCAL_PORT_RANGE);\n\tif (cnic_init_id_tbl(&cp->csk_port_tbl, CNIC_LOCAL_PORT_RANGE,\n\t\t\t     CNIC_LOCAL_PORT_MIN, port_id)) {\n\t\tcnic_cm_free_mem(dev);\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}\n\nstatic int cnic_ready_to_close(struct cnic_sock *csk, u32 opcode)\n{\n\tif (test_and_clear_bit(SK_F_OFFLD_COMPLETE, &csk->flags)) {\n\t\t \n\t\topcode = L4_KCQE_OPCODE_VALUE_RESET_RECEIVED;\n\t\tcsk->state = opcode;\n\t}\n\n\t \n\tif (opcode == csk->state || csk->state == 0 ||\n\t    csk->state == L4_KCQE_OPCODE_VALUE_CLOSE_COMP ||\n\t    csk->state == L4_KCQE_OPCODE_VALUE_RESET_COMP) {\n\t\tif (!test_and_set_bit(SK_F_CLOSING, &csk->flags)) {\n\t\t\tif (csk->state == 0)\n\t\t\t\tcsk->state = opcode;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void cnic_close_bnx2_conn(struct cnic_sock *csk, u32 opcode)\n{\n\tstruct cnic_dev *dev = csk->dev;\n\tstruct cnic_local *cp = dev->cnic_priv;\n\n\tif (opcode == L4_KCQE_OPCODE_VALUE_RESET_RECEIVED) {\n\t\tcnic_cm_upcall(cp, csk, opcode);\n\t\treturn;\n\t}\n\n\tclear_bit(SK_F_CONNECT_START, &csk->flags);\n\tcnic_close_conn(csk);\n\tcsk->state = opcode;\n\tcnic_cm_upcall(cp, csk, opcode);\n}\n\nstatic void cnic_cm_stop_bnx2_hw(struct cnic_dev *dev)\n{\n}\n\nstatic int cnic_cm_init_bnx2_hw(struct cnic_dev *dev)\n{\n\tu32 seed;\n\n\tseed = get_random_u32();\n\tcnic_ctx_wr(dev, 45, 0, seed);\n\treturn 0;\n}\n\nstatic void cnic_close_bnx2x_conn(struct cnic_sock *csk, u32 opcode)\n{\n\tstruct cnic_dev *dev = csk->dev;\n\tstruct cnic_local *cp = dev->cnic_priv;\n\tstruct cnic_context *ctx = &cp->ctx_tbl[csk->l5_cid];\n\tunion l5cm_specific_data l5_data;\n\tu32 cmd = 0;\n\tint close_complete = 0;\n\n\tswitch (opcode) {\n\tcase L4_KCQE_OPCODE_VALUE_RESET_RECEIVED:\n\tcase L4_KCQE_OPCODE_VALUE_CLOSE_COMP:\n\tcase L4_KCQE_OPCODE_VALUE_RESET_COMP:\n\t\tif (cnic_ready_to_close(csk, opcode)) {\n\t\t\tif (test_bit(SK_F_HW_ERR, &csk->flags))\n\t\t\t\tclose_complete = 1;\n\t\t\telse if (test_bit(SK_F_PG_OFFLD_COMPLETE, &csk->flags))\n\t\t\t\tcmd = L5CM_RAMROD_CMD_ID_SEARCHER_DELETE;\n\t\t\telse\n\t\t\t\tclose_complete = 1;\n\t\t}\n\t\tbreak;\n\tcase L5CM_RAMROD_CMD_ID_SEARCHER_DELETE:\n\t\tcmd = L5CM_RAMROD_CMD_ID_TERMINATE_OFFLOAD;\n\t\tbreak;\n\tcase L5CM_RAMROD_CMD_ID_TERMINATE_OFFLOAD:\n\t\tclose_complete = 1;\n\t\tbreak;\n\t}\n\tif (cmd) {\n\t\tmemset(&l5_data, 0, sizeof(l5_data));\n\n\t\tcnic_submit_kwqe_16(dev, cmd, csk->cid, ISCSI_CONNECTION_TYPE,\n\t\t\t\t    &l5_data);\n\t} else if (close_complete) {\n\t\tctx->timestamp = jiffies;\n\t\tcnic_close_conn(csk);\n\t\tcnic_cm_upcall(cp, csk, csk->state);\n\t}\n}\n\nstatic void cnic_cm_stop_bnx2x_hw(struct cnic_dev *dev)\n{\n\tstruct cnic_local *cp = dev->cnic_priv;\n\n\tif (!cp->ctx_tbl)\n\t\treturn;\n\n\tif (!netif_running(dev->netdev))\n\t\treturn;\n\n\tcnic_bnx2x_delete_wait(dev, 0);\n\n\tcancel_delayed_work(&cp->delete_task);\n\tflush_workqueue(cnic_wq);\n\n\tif (atomic_read(&cp->iscsi_conn) != 0)\n\t\tnetdev_warn(dev->netdev, \"%d iSCSI connections not destroyed\\n\",\n\t\t\t    atomic_read(&cp->iscsi_conn));\n}\n\nstatic int cnic_cm_init_bnx2x_hw(struct cnic_dev *dev)\n{\n\tstruct bnx2x *bp = netdev_priv(dev->netdev);\n\tu32 pfid = bp->pfid;\n\tu32 port = BP_PORT(bp);\n\n\tcnic_init_bnx2x_mac(dev);\n\tcnic_bnx2x_set_tcp_options(dev, 0, 1);\n\n\tCNIC_WR16(dev, BAR_XSTRORM_INTMEM +\n\t\t  XSTORM_ISCSI_LOCAL_VLAN_OFFSET(pfid), 0);\n\n\tCNIC_WR(dev, BAR_XSTRORM_INTMEM +\n\t\tXSTORM_TCP_GLOBAL_DEL_ACK_COUNTER_ENABLED_OFFSET(port), 1);\n\tCNIC_WR(dev, BAR_XSTRORM_INTMEM +\n\t\tXSTORM_TCP_GLOBAL_DEL_ACK_COUNTER_MAX_COUNT_OFFSET(port),\n\t\tDEF_MAX_DA_COUNT);\n\n\tCNIC_WR8(dev, BAR_XSTRORM_INTMEM +\n\t\t XSTORM_ISCSI_TCP_VARS_TTL_OFFSET(pfid), DEF_TTL);\n\tCNIC_WR8(dev, BAR_XSTRORM_INTMEM +\n\t\t XSTORM_ISCSI_TCP_VARS_TOS_OFFSET(pfid), DEF_TOS);\n\tCNIC_WR8(dev, BAR_XSTRORM_INTMEM +\n\t\t XSTORM_ISCSI_TCP_VARS_ADV_WND_SCL_OFFSET(pfid), 2);\n\tCNIC_WR(dev, BAR_XSTRORM_INTMEM +\n\t\tXSTORM_TCP_TX_SWS_TIMER_VAL_OFFSET(pfid), DEF_SWS_TIMER);\n\n\tCNIC_WR(dev, BAR_TSTRORM_INTMEM + TSTORM_TCP_MAX_CWND_OFFSET(pfid),\n\t\tDEF_MAX_CWND);\n\treturn 0;\n}\n\nstatic void cnic_delete_task(struct work_struct *work)\n{\n\tstruct cnic_local *cp;\n\tstruct cnic_dev *dev;\n\tu32 i;\n\tint need_resched = 0;\n\n\tcp = container_of(work, struct cnic_local, delete_task.work);\n\tdev = cp->dev;\n\n\tif (test_and_clear_bit(CNIC_LCL_FL_STOP_ISCSI, &cp->cnic_local_flags)) {\n\t\tstruct drv_ctl_info info;\n\n\t\tcnic_ulp_stop_one(cp, CNIC_ULP_ISCSI);\n\n\t\tmemset(&info, 0, sizeof(struct drv_ctl_info));\n\t\tinfo.cmd = DRV_CTL_ISCSI_STOPPED_CMD;\n\t\tcp->ethdev->drv_ctl(dev->netdev, &info);\n\t}\n\n\tfor (i = 0; i < cp->max_cid_space; i++) {\n\t\tstruct cnic_context *ctx = &cp->ctx_tbl[i];\n\t\tint err;\n\n\t\tif (!test_bit(CTX_FL_OFFLD_START, &ctx->ctx_flags) ||\n\t\t    !test_bit(CTX_FL_DELETE_WAIT, &ctx->ctx_flags))\n\t\t\tcontinue;\n\n\t\tif (!time_after(jiffies, ctx->timestamp + (2 * HZ))) {\n\t\t\tneed_resched = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!test_and_clear_bit(CTX_FL_DELETE_WAIT, &ctx->ctx_flags))\n\t\t\tcontinue;\n\n\t\terr = cnic_bnx2x_destroy_ramrod(dev, i);\n\n\t\tcnic_free_bnx2x_conn_resc(dev, i);\n\t\tif (!err) {\n\t\t\tif (ctx->ulp_proto_id == CNIC_ULP_ISCSI)\n\t\t\t\tatomic_dec(&cp->iscsi_conn);\n\n\t\t\tclear_bit(CTX_FL_OFFLD_START, &ctx->ctx_flags);\n\t\t}\n\t}\n\n\tif (need_resched)\n\t\tqueue_delayed_work(cnic_wq, &cp->delete_task,\n\t\t\t\t   msecs_to_jiffies(10));\n\n}\n\nstatic int cnic_cm_open(struct cnic_dev *dev)\n{\n\tstruct cnic_local *cp = dev->cnic_priv;\n\tint err;\n\n\terr = cnic_cm_alloc_mem(dev);\n\tif (err)\n\t\treturn err;\n\n\terr = cp->start_cm(dev);\n\n\tif (err)\n\t\tgoto err_out;\n\n\tINIT_DELAYED_WORK(&cp->delete_task, cnic_delete_task);\n\n\tdev->cm_create = cnic_cm_create;\n\tdev->cm_destroy = cnic_cm_destroy;\n\tdev->cm_connect = cnic_cm_connect;\n\tdev->cm_abort = cnic_cm_abort;\n\tdev->cm_close = cnic_cm_close;\n\tdev->cm_select_dev = cnic_cm_select_dev;\n\n\tcp->ulp_handle[CNIC_ULP_L4] = dev;\n\trcu_assign_pointer(cp->ulp_ops[CNIC_ULP_L4], &cm_ulp_ops);\n\treturn 0;\n\nerr_out:\n\tcnic_cm_free_mem(dev);\n\treturn err;\n}\n\nstatic int cnic_cm_shutdown(struct cnic_dev *dev)\n{\n\tstruct cnic_local *cp = dev->cnic_priv;\n\tint i;\n\n\tif (!cp->csk_tbl)\n\t\treturn 0;\n\n\tfor (i = 0; i < MAX_CM_SK_TBL_SZ; i++) {\n\t\tstruct cnic_sock *csk = &cp->csk_tbl[i];\n\n\t\tclear_bit(SK_F_INUSE, &csk->flags);\n\t\tcnic_cm_cleanup(csk);\n\t}\n\tcnic_cm_free_mem(dev);\n\n\treturn 0;\n}\n\nstatic void cnic_init_context(struct cnic_dev *dev, u32 cid)\n{\n\tu32 cid_addr;\n\tint i;\n\n\tcid_addr = GET_CID_ADDR(cid);\n\n\tfor (i = 0; i < CTX_SIZE; i += 4)\n\t\tcnic_ctx_wr(dev, cid_addr, i, 0);\n}\n\nstatic int cnic_setup_5709_context(struct cnic_dev *dev, int valid)\n{\n\tstruct cnic_local *cp = dev->cnic_priv;\n\tint ret = 0, i;\n\tu32 valid_bit = valid ? BNX2_CTX_HOST_PAGE_TBL_DATA0_VALID : 0;\n\n\tif (BNX2_CHIP(cp) != BNX2_CHIP_5709)\n\t\treturn 0;\n\n\tfor (i = 0; i < cp->ctx_blks; i++) {\n\t\tint j;\n\t\tu32 idx = cp->ctx_arr[i].cid / cp->cids_per_blk;\n\t\tu32 val;\n\n\t\tmemset(cp->ctx_arr[i].ctx, 0, CNIC_PAGE_SIZE);\n\n\t\tCNIC_WR(dev, BNX2_CTX_HOST_PAGE_TBL_DATA0,\n\t\t\t(cp->ctx_arr[i].mapping & 0xffffffff) | valid_bit);\n\t\tCNIC_WR(dev, BNX2_CTX_HOST_PAGE_TBL_DATA1,\n\t\t\t(u64) cp->ctx_arr[i].mapping >> 32);\n\t\tCNIC_WR(dev, BNX2_CTX_HOST_PAGE_TBL_CTRL, idx |\n\t\t\tBNX2_CTX_HOST_PAGE_TBL_CTRL_WRITE_REQ);\n\t\tfor (j = 0; j < 10; j++) {\n\n\t\t\tval = CNIC_RD(dev, BNX2_CTX_HOST_PAGE_TBL_CTRL);\n\t\t\tif (!(val & BNX2_CTX_HOST_PAGE_TBL_CTRL_WRITE_REQ))\n\t\t\t\tbreak;\n\t\t\tudelay(5);\n\t\t}\n\t\tif (val & BNX2_CTX_HOST_PAGE_TBL_CTRL_WRITE_REQ) {\n\t\t\tret = -EBUSY;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\nstatic void cnic_free_irq(struct cnic_dev *dev)\n{\n\tstruct cnic_local *cp = dev->cnic_priv;\n\tstruct cnic_eth_dev *ethdev = cp->ethdev;\n\n\tif (ethdev->drv_state & CNIC_DRV_STATE_USING_MSIX) {\n\t\tcp->disable_int_sync(dev);\n\t\ttasklet_kill(&cp->cnic_irq_task);\n\t\tfree_irq(ethdev->irq_arr[0].vector, dev);\n\t}\n}\n\nstatic int cnic_request_irq(struct cnic_dev *dev)\n{\n\tstruct cnic_local *cp = dev->cnic_priv;\n\tstruct cnic_eth_dev *ethdev = cp->ethdev;\n\tint err;\n\n\terr = request_irq(ethdev->irq_arr[0].vector, cnic_irq, 0, \"cnic\", dev);\n\tif (err)\n\t\ttasklet_disable(&cp->cnic_irq_task);\n\n\treturn err;\n}\n\nstatic int cnic_init_bnx2_irq(struct cnic_dev *dev)\n{\n\tstruct cnic_local *cp = dev->cnic_priv;\n\tstruct cnic_eth_dev *ethdev = cp->ethdev;\n\n\tif (ethdev->drv_state & CNIC_DRV_STATE_USING_MSIX) {\n\t\tint err, i = 0;\n\t\tint sblk_num = cp->status_blk_num;\n\t\tu32 base = ((sblk_num - 1) * BNX2_HC_SB_CONFIG_SIZE) +\n\t\t\t   BNX2_HC_SB_CONFIG_1;\n\n\t\tCNIC_WR(dev, base, BNX2_HC_SB_CONFIG_1_ONE_SHOT);\n\n\t\tCNIC_WR(dev, base + BNX2_HC_COMP_PROD_TRIP_OFF, (2 << 16) | 8);\n\t\tCNIC_WR(dev, base + BNX2_HC_COM_TICKS_OFF, (64 << 16) | 220);\n\t\tCNIC_WR(dev, base + BNX2_HC_CMD_TICKS_OFF, (64 << 16) | 220);\n\n\t\tcp->last_status_idx = cp->status_blk.bnx2->status_idx;\n\t\ttasklet_setup(&cp->cnic_irq_task, cnic_service_bnx2_msix);\n\t\terr = cnic_request_irq(dev);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\twhile (cp->status_blk.bnx2->status_completion_producer_index &&\n\t\t       i < 10) {\n\t\t\tCNIC_WR(dev, BNX2_HC_COALESCE_NOW,\n\t\t\t\t1 << (11 + sblk_num));\n\t\t\tudelay(10);\n\t\t\ti++;\n\t\t\tbarrier();\n\t\t}\n\t\tif (cp->status_blk.bnx2->status_completion_producer_index) {\n\t\t\tcnic_free_irq(dev);\n\t\t\tgoto failed;\n\t\t}\n\n\t} else {\n\t\tstruct status_block *sblk = cp->status_blk.gen;\n\t\tu32 hc_cmd = CNIC_RD(dev, BNX2_HC_COMMAND);\n\t\tint i = 0;\n\n\t\twhile (sblk->status_completion_producer_index && i < 10) {\n\t\t\tCNIC_WR(dev, BNX2_HC_COMMAND,\n\t\t\t\thc_cmd | BNX2_HC_COMMAND_COAL_NOW_WO_INT);\n\t\t\tudelay(10);\n\t\t\ti++;\n\t\t\tbarrier();\n\t\t}\n\t\tif (sblk->status_completion_producer_index)\n\t\t\tgoto failed;\n\n\t}\n\treturn 0;\n\nfailed:\n\tnetdev_err(dev->netdev, \"KCQ index not resetting to 0\\n\");\n\treturn -EBUSY;\n}\n\nstatic void cnic_enable_bnx2_int(struct cnic_dev *dev)\n{\n\tstruct cnic_local *cp = dev->cnic_priv;\n\tstruct cnic_eth_dev *ethdev = cp->ethdev;\n\n\tif (!(ethdev->drv_state & CNIC_DRV_STATE_USING_MSIX))\n\t\treturn;\n\n\tCNIC_WR(dev, BNX2_PCICFG_INT_ACK_CMD, cp->int_num |\n\t\tBNX2_PCICFG_INT_ACK_CMD_INDEX_VALID | cp->last_status_idx);\n}\n\nstatic void cnic_disable_bnx2_int_sync(struct cnic_dev *dev)\n{\n\tstruct cnic_local *cp = dev->cnic_priv;\n\tstruct cnic_eth_dev *ethdev = cp->ethdev;\n\n\tif (!(ethdev->drv_state & CNIC_DRV_STATE_USING_MSIX))\n\t\treturn;\n\n\tCNIC_WR(dev, BNX2_PCICFG_INT_ACK_CMD, cp->int_num |\n\t\tBNX2_PCICFG_INT_ACK_CMD_MASK_INT);\n\tCNIC_RD(dev, BNX2_PCICFG_INT_ACK_CMD);\n\tsynchronize_irq(ethdev->irq_arr[0].vector);\n}\n\nstatic void cnic_init_bnx2_tx_ring(struct cnic_dev *dev)\n{\n\tstruct cnic_local *cp = dev->cnic_priv;\n\tstruct cnic_eth_dev *ethdev = cp->ethdev;\n\tstruct cnic_uio_dev *udev = cp->udev;\n\tu32 cid_addr, tx_cid, sb_id;\n\tu32 val, offset0, offset1, offset2, offset3;\n\tint i;\n\tstruct bnx2_tx_bd *txbd;\n\tdma_addr_t buf_map, ring_map = udev->l2_ring_map;\n\tstruct status_block *s_blk = cp->status_blk.gen;\n\n\tsb_id = cp->status_blk_num;\n\ttx_cid = 20;\n\tcp->tx_cons_ptr = &s_blk->status_tx_quick_consumer_index2;\n\tif (ethdev->drv_state & CNIC_DRV_STATE_USING_MSIX) {\n\t\tstruct status_block_msix *sblk = cp->status_blk.bnx2;\n\n\t\ttx_cid = TX_TSS_CID + sb_id - 1;\n\t\tCNIC_WR(dev, BNX2_TSCH_TSS_CFG, (sb_id << 24) |\n\t\t\t(TX_TSS_CID << 7));\n\t\tcp->tx_cons_ptr = &sblk->status_tx_quick_consumer_index;\n\t}\n\tcp->tx_cons = *cp->tx_cons_ptr;\n\n\tcid_addr = GET_CID_ADDR(tx_cid);\n\tif (BNX2_CHIP(cp) == BNX2_CHIP_5709) {\n\t\tu32 cid_addr2 = GET_CID_ADDR(tx_cid + 4) + 0x40;\n\n\t\tfor (i = 0; i < PHY_CTX_SIZE; i += 4)\n\t\t\tcnic_ctx_wr(dev, cid_addr2, i, 0);\n\n\t\toffset0 = BNX2_L2CTX_TYPE_XI;\n\t\toffset1 = BNX2_L2CTX_CMD_TYPE_XI;\n\t\toffset2 = BNX2_L2CTX_TBDR_BHADDR_HI_XI;\n\t\toffset3 = BNX2_L2CTX_TBDR_BHADDR_LO_XI;\n\t} else {\n\t\tcnic_init_context(dev, tx_cid);\n\t\tcnic_init_context(dev, tx_cid + 1);\n\n\t\toffset0 = BNX2_L2CTX_TYPE;\n\t\toffset1 = BNX2_L2CTX_CMD_TYPE;\n\t\toffset2 = BNX2_L2CTX_TBDR_BHADDR_HI;\n\t\toffset3 = BNX2_L2CTX_TBDR_BHADDR_LO;\n\t}\n\tval = BNX2_L2CTX_TYPE_TYPE_L2 | BNX2_L2CTX_TYPE_SIZE_L2;\n\tcnic_ctx_wr(dev, cid_addr, offset0, val);\n\n\tval = BNX2_L2CTX_CMD_TYPE_TYPE_L2 | (8 << 16);\n\tcnic_ctx_wr(dev, cid_addr, offset1, val);\n\n\ttxbd = udev->l2_ring;\n\n\tbuf_map = udev->l2_buf_map;\n\tfor (i = 0; i < BNX2_MAX_TX_DESC_CNT; i++, txbd++) {\n\t\ttxbd->tx_bd_haddr_hi = (u64) buf_map >> 32;\n\t\ttxbd->tx_bd_haddr_lo = (u64) buf_map & 0xffffffff;\n\t}\n\tval = (u64) ring_map >> 32;\n\tcnic_ctx_wr(dev, cid_addr, offset2, val);\n\ttxbd->tx_bd_haddr_hi = val;\n\n\tval = (u64) ring_map & 0xffffffff;\n\tcnic_ctx_wr(dev, cid_addr, offset3, val);\n\ttxbd->tx_bd_haddr_lo = val;\n}\n\nstatic void cnic_init_bnx2_rx_ring(struct cnic_dev *dev)\n{\n\tstruct cnic_local *cp = dev->cnic_priv;\n\tstruct cnic_eth_dev *ethdev = cp->ethdev;\n\tstruct cnic_uio_dev *udev = cp->udev;\n\tu32 cid_addr, sb_id, val, coal_reg, coal_val;\n\tint i;\n\tstruct bnx2_rx_bd *rxbd;\n\tstruct status_block *s_blk = cp->status_blk.gen;\n\tdma_addr_t ring_map = udev->l2_ring_map;\n\n\tsb_id = cp->status_blk_num;\n\tcnic_init_context(dev, 2);\n\tcp->rx_cons_ptr = &s_blk->status_rx_quick_consumer_index2;\n\tcoal_reg = BNX2_HC_COMMAND;\n\tcoal_val = CNIC_RD(dev, coal_reg);\n\tif (ethdev->drv_state & CNIC_DRV_STATE_USING_MSIX) {\n\t\tstruct status_block_msix *sblk = cp->status_blk.bnx2;\n\n\t\tcp->rx_cons_ptr = &sblk->status_rx_quick_consumer_index;\n\t\tcoal_reg = BNX2_HC_COALESCE_NOW;\n\t\tcoal_val = 1 << (11 + sb_id);\n\t}\n\ti = 0;\n\twhile (!(*cp->rx_cons_ptr != 0) && i < 10) {\n\t\tCNIC_WR(dev, coal_reg, coal_val);\n\t\tudelay(10);\n\t\ti++;\n\t\tbarrier();\n\t}\n\tcp->rx_cons = *cp->rx_cons_ptr;\n\n\tcid_addr = GET_CID_ADDR(2);\n\tval = BNX2_L2CTX_CTX_TYPE_CTX_BD_CHN_TYPE_VALUE |\n\t      BNX2_L2CTX_CTX_TYPE_SIZE_L2 | (0x02 << 8);\n\tcnic_ctx_wr(dev, cid_addr, BNX2_L2CTX_CTX_TYPE, val);\n\n\tif (sb_id == 0)\n\t\tval = 2 << BNX2_L2CTX_L2_STATUSB_NUM_SHIFT;\n\telse\n\t\tval = BNX2_L2CTX_L2_STATUSB_NUM(sb_id);\n\tcnic_ctx_wr(dev, cid_addr, BNX2_L2CTX_HOST_BDIDX, val);\n\n\trxbd = udev->l2_ring + CNIC_PAGE_SIZE;\n\tfor (i = 0; i < BNX2_MAX_RX_DESC_CNT; i++, rxbd++) {\n\t\tdma_addr_t buf_map;\n\t\tint n = (i % cp->l2_rx_ring_size) + 1;\n\n\t\tbuf_map = udev->l2_buf_map + (n * cp->l2_single_buf_size);\n\t\trxbd->rx_bd_len = cp->l2_single_buf_size;\n\t\trxbd->rx_bd_flags = RX_BD_FLAGS_START | RX_BD_FLAGS_END;\n\t\trxbd->rx_bd_haddr_hi = (u64) buf_map >> 32;\n\t\trxbd->rx_bd_haddr_lo = (u64) buf_map & 0xffffffff;\n\t}\n\tval = (u64) (ring_map + CNIC_PAGE_SIZE) >> 32;\n\tcnic_ctx_wr(dev, cid_addr, BNX2_L2CTX_NX_BDHADDR_HI, val);\n\trxbd->rx_bd_haddr_hi = val;\n\n\tval = (u64) (ring_map + CNIC_PAGE_SIZE) & 0xffffffff;\n\tcnic_ctx_wr(dev, cid_addr, BNX2_L2CTX_NX_BDHADDR_LO, val);\n\trxbd->rx_bd_haddr_lo = val;\n\n\tval = cnic_reg_rd_ind(dev, BNX2_RXP_SCRATCH_RXP_FLOOD);\n\tcnic_reg_wr_ind(dev, BNX2_RXP_SCRATCH_RXP_FLOOD, val | (1 << 2));\n}\n\nstatic void cnic_shutdown_bnx2_rx_ring(struct cnic_dev *dev)\n{\n\tstruct kwqe *wqes[1], l2kwqe;\n\n\tmemset(&l2kwqe, 0, sizeof(l2kwqe));\n\twqes[0] = &l2kwqe;\n\tl2kwqe.kwqe_op_flag = (L2_LAYER_CODE << KWQE_LAYER_SHIFT) |\n\t\t\t      (L2_KWQE_OPCODE_VALUE_FLUSH <<\n\t\t\t       KWQE_OPCODE_SHIFT) | 2;\n\tdev->submit_kwqes(dev, wqes, 1);\n}\n\nstatic void cnic_set_bnx2_mac(struct cnic_dev *dev)\n{\n\tstruct cnic_local *cp = dev->cnic_priv;\n\tu32 val;\n\n\tval = cp->func << 2;\n\n\tcp->shmem_base = cnic_reg_rd_ind(dev, BNX2_SHM_HDR_ADDR_0 + val);\n\n\tval = cnic_reg_rd_ind(dev, cp->shmem_base +\n\t\t\t      BNX2_PORT_HW_CFG_ISCSI_MAC_UPPER);\n\tdev->mac_addr[0] = (u8) (val >> 8);\n\tdev->mac_addr[1] = (u8) val;\n\n\tCNIC_WR(dev, BNX2_EMAC_MAC_MATCH4, val);\n\n\tval = cnic_reg_rd_ind(dev, cp->shmem_base +\n\t\t\t      BNX2_PORT_HW_CFG_ISCSI_MAC_LOWER);\n\tdev->mac_addr[2] = (u8) (val >> 24);\n\tdev->mac_addr[3] = (u8) (val >> 16);\n\tdev->mac_addr[4] = (u8) (val >> 8);\n\tdev->mac_addr[5] = (u8) val;\n\n\tCNIC_WR(dev, BNX2_EMAC_MAC_MATCH5, val);\n\n\tval = 4 | BNX2_RPM_SORT_USER2_BC_EN;\n\tif (BNX2_CHIP(cp) != BNX2_CHIP_5709)\n\t\tval |= BNX2_RPM_SORT_USER2_PROM_VLAN;\n\n\tCNIC_WR(dev, BNX2_RPM_SORT_USER2, 0x0);\n\tCNIC_WR(dev, BNX2_RPM_SORT_USER2, val);\n\tCNIC_WR(dev, BNX2_RPM_SORT_USER2, val | BNX2_RPM_SORT_USER2_ENA);\n}\n\nstatic int cnic_start_bnx2_hw(struct cnic_dev *dev)\n{\n\tstruct cnic_local *cp = dev->cnic_priv;\n\tstruct cnic_eth_dev *ethdev = cp->ethdev;\n\tstruct status_block *sblk = cp->status_blk.gen;\n\tu32 val, kcq_cid_addr, kwq_cid_addr;\n\tint err;\n\n\tcnic_set_bnx2_mac(dev);\n\n\tval = CNIC_RD(dev, BNX2_MQ_CONFIG);\n\tval &= ~BNX2_MQ_CONFIG_KNL_BYP_BLK_SIZE;\n\tif (CNIC_PAGE_BITS > 12)\n\t\tval |= (12 - 8)  << 4;\n\telse\n\t\tval |= (CNIC_PAGE_BITS - 8)  << 4;\n\n\tCNIC_WR(dev, BNX2_MQ_CONFIG, val);\n\n\tCNIC_WR(dev, BNX2_HC_COMP_PROD_TRIP, (2 << 16) | 8);\n\tCNIC_WR(dev, BNX2_HC_COM_TICKS, (64 << 16) | 220);\n\tCNIC_WR(dev, BNX2_HC_CMD_TICKS, (64 << 16) | 220);\n\n\terr = cnic_setup_5709_context(dev, 1);\n\tif (err)\n\t\treturn err;\n\n\tcnic_init_context(dev, KWQ_CID);\n\tcnic_init_context(dev, KCQ_CID);\n\n\tkwq_cid_addr = GET_CID_ADDR(KWQ_CID);\n\tcp->kwq_io_addr = MB_GET_CID_ADDR(KWQ_CID) + L5_KRNLQ_HOST_QIDX;\n\n\tcp->max_kwq_idx = MAX_KWQ_IDX;\n\tcp->kwq_prod_idx = 0;\n\tcp->kwq_con_idx = 0;\n\tset_bit(CNIC_LCL_FL_KWQ_INIT, &cp->cnic_local_flags);\n\n\tif (BNX2_CHIP(cp) == BNX2_CHIP_5706 || BNX2_CHIP(cp) == BNX2_CHIP_5708)\n\t\tcp->kwq_con_idx_ptr = &sblk->status_rx_quick_consumer_index15;\n\telse\n\t\tcp->kwq_con_idx_ptr = &sblk->status_cmd_consumer_index;\n\n\t \n\tval = KRNLQ_TYPE_TYPE_KRNLQ | KRNLQ_SIZE_TYPE_SIZE |\n\t      (CNIC_PAGE_BITS - 8) | KRNLQ_FLAGS_QE_SELF_SEQ;\n\tcnic_ctx_wr(dev, kwq_cid_addr, L5_KRNLQ_TYPE, val);\n\n\tval = (CNIC_PAGE_SIZE / sizeof(struct kwqe) - 1) << 16;\n\tcnic_ctx_wr(dev, kwq_cid_addr, L5_KRNLQ_QE_SELF_SEQ_MAX, val);\n\n\tval = ((CNIC_PAGE_SIZE / sizeof(struct kwqe)) << 16) | KWQ_PAGE_CNT;\n\tcnic_ctx_wr(dev, kwq_cid_addr, L5_KRNLQ_PGTBL_NPAGES, val);\n\n\tval = (u32) ((u64) cp->kwq_info.pgtbl_map >> 32);\n\tcnic_ctx_wr(dev, kwq_cid_addr, L5_KRNLQ_PGTBL_HADDR_HI, val);\n\n\tval = (u32) cp->kwq_info.pgtbl_map;\n\tcnic_ctx_wr(dev, kwq_cid_addr, L5_KRNLQ_PGTBL_HADDR_LO, val);\n\n\tkcq_cid_addr = GET_CID_ADDR(KCQ_CID);\n\tcp->kcq1.io_addr = MB_GET_CID_ADDR(KCQ_CID) + L5_KRNLQ_HOST_QIDX;\n\n\tcp->kcq1.sw_prod_idx = 0;\n\tcp->kcq1.hw_prod_idx_ptr =\n\t\t&sblk->status_completion_producer_index;\n\n\tcp->kcq1.status_idx_ptr = &sblk->status_idx;\n\n\t \n\tval = KRNLQ_TYPE_TYPE_KRNLQ | KRNLQ_SIZE_TYPE_SIZE |\n\t      (CNIC_PAGE_BITS - 8) | KRNLQ_FLAGS_QE_SELF_SEQ;\n\tcnic_ctx_wr(dev, kcq_cid_addr, L5_KRNLQ_TYPE, val);\n\n\tval = (CNIC_PAGE_SIZE / sizeof(struct kcqe) - 1) << 16;\n\tcnic_ctx_wr(dev, kcq_cid_addr, L5_KRNLQ_QE_SELF_SEQ_MAX, val);\n\n\tval = ((CNIC_PAGE_SIZE / sizeof(struct kcqe)) << 16) | KCQ_PAGE_CNT;\n\tcnic_ctx_wr(dev, kcq_cid_addr, L5_KRNLQ_PGTBL_NPAGES, val);\n\n\tval = (u32) ((u64) cp->kcq1.dma.pgtbl_map >> 32);\n\tcnic_ctx_wr(dev, kcq_cid_addr, L5_KRNLQ_PGTBL_HADDR_HI, val);\n\n\tval = (u32) cp->kcq1.dma.pgtbl_map;\n\tcnic_ctx_wr(dev, kcq_cid_addr, L5_KRNLQ_PGTBL_HADDR_LO, val);\n\n\tcp->int_num = 0;\n\tif (ethdev->drv_state & CNIC_DRV_STATE_USING_MSIX) {\n\t\tstruct status_block_msix *msblk = cp->status_blk.bnx2;\n\t\tu32 sb_id = cp->status_blk_num;\n\t\tu32 sb = BNX2_L2CTX_L5_STATUSB_NUM(sb_id);\n\n\t\tcp->kcq1.hw_prod_idx_ptr =\n\t\t\t&msblk->status_completion_producer_index;\n\t\tcp->kcq1.status_idx_ptr = &msblk->status_idx;\n\t\tcp->kwq_con_idx_ptr = &msblk->status_cmd_consumer_index;\n\t\tcp->int_num = sb_id << BNX2_PCICFG_INT_ACK_CMD_INT_NUM_SHIFT;\n\t\tcnic_ctx_wr(dev, kwq_cid_addr, L5_KRNLQ_HOST_QIDX, sb);\n\t\tcnic_ctx_wr(dev, kcq_cid_addr, L5_KRNLQ_HOST_QIDX, sb);\n\t}\n\n\t \n\tCNIC_WR(dev, BNX2_MQ_KNL_CMD_MASK1, 2);\n\n\t \n\tCNIC_WR(dev, BNX2_MQ_KNL_BYP_CMD_MASK1, 7);\n\tCNIC_WR(dev, BNX2_MQ_KNL_BYP_WRITE_MASK1, 7);\n\n\t \n\tCNIC_WR(dev, BNX2_MQ_KNL_RX_V2P_MASK2, 0x2000);\n\n\t \n\tcnic_reg_wr_ind(dev, BNX2_CP_SCRATCH + 0x20, 1);\n\tcnic_reg_wr_ind(dev, BNX2_COM_SCRATCH + 0x20, 1);\n\n\tcnic_init_bnx2_tx_ring(dev);\n\tcnic_init_bnx2_rx_ring(dev);\n\n\terr = cnic_init_bnx2_irq(dev);\n\tif (err) {\n\t\tnetdev_err(dev->netdev, \"cnic_init_irq failed\\n\");\n\t\tcnic_reg_wr_ind(dev, BNX2_CP_SCRATCH + 0x20, 0);\n\t\tcnic_reg_wr_ind(dev, BNX2_COM_SCRATCH + 0x20, 0);\n\t\treturn err;\n\t}\n\n\tethdev->drv_state |= CNIC_DRV_STATE_HANDLES_IRQ;\n\n\treturn 0;\n}\n\nstatic void cnic_setup_bnx2x_context(struct cnic_dev *dev)\n{\n\tstruct cnic_local *cp = dev->cnic_priv;\n\tstruct cnic_eth_dev *ethdev = cp->ethdev;\n\tu32 start_offset = ethdev->ctx_tbl_offset;\n\tint i;\n\n\tfor (i = 0; i < cp->ctx_blks; i++) {\n\t\tstruct cnic_ctx *ctx = &cp->ctx_arr[i];\n\t\tdma_addr_t map = ctx->mapping;\n\n\t\tif (cp->ctx_align) {\n\t\t\tunsigned long mask = cp->ctx_align - 1;\n\n\t\t\tmap = (map + mask) & ~mask;\n\t\t}\n\n\t\tcnic_ctx_tbl_wr(dev, start_offset + i, map);\n\t}\n}\n\nstatic int cnic_init_bnx2x_irq(struct cnic_dev *dev)\n{\n\tstruct cnic_local *cp = dev->cnic_priv;\n\tstruct cnic_eth_dev *ethdev = cp->ethdev;\n\tint err = 0;\n\n\ttasklet_setup(&cp->cnic_irq_task, cnic_service_bnx2x_bh);\n\tif (ethdev->drv_state & CNIC_DRV_STATE_USING_MSIX)\n\t\terr = cnic_request_irq(dev);\n\n\treturn err;\n}\n\nstatic inline void cnic_storm_memset_hc_disable(struct cnic_dev *dev,\n\t\t\t\t\t\tu16 sb_id, u8 sb_index,\n\t\t\t\t\t\tu8 disable)\n{\n\tstruct bnx2x *bp = netdev_priv(dev->netdev);\n\n\tu32 addr = BAR_CSTRORM_INTMEM +\n\t\t\tCSTORM_STATUS_BLOCK_DATA_OFFSET(sb_id) +\n\t\t\toffsetof(struct hc_status_block_data_e1x, index_data) +\n\t\t\tsizeof(struct hc_index_data)*sb_index +\n\t\t\toffsetof(struct hc_index_data, flags);\n\tu16 flags = CNIC_RD16(dev, addr);\n\t \n\tflags &= ~HC_INDEX_DATA_HC_ENABLED;\n\tflags |= (((~disable) << HC_INDEX_DATA_HC_ENABLED_SHIFT) &\n\t\t  HC_INDEX_DATA_HC_ENABLED);\n\tCNIC_WR16(dev, addr, flags);\n}\n\nstatic void cnic_enable_bnx2x_int(struct cnic_dev *dev)\n{\n\tstruct cnic_local *cp = dev->cnic_priv;\n\tstruct bnx2x *bp = netdev_priv(dev->netdev);\n\tu8 sb_id = cp->status_blk_num;\n\n\tCNIC_WR8(dev, BAR_CSTRORM_INTMEM +\n\t\t\tCSTORM_STATUS_BLOCK_DATA_OFFSET(sb_id) +\n\t\t\toffsetof(struct hc_status_block_data_e1x, index_data) +\n\t\t\tsizeof(struct hc_index_data)*HC_INDEX_ISCSI_EQ_CONS +\n\t\t\toffsetof(struct hc_index_data, timeout), 64 / 4);\n\tcnic_storm_memset_hc_disable(dev, sb_id, HC_INDEX_ISCSI_EQ_CONS, 0);\n}\n\nstatic void cnic_disable_bnx2x_int_sync(struct cnic_dev *dev)\n{\n}\n\nstatic void cnic_init_bnx2x_tx_ring(struct cnic_dev *dev,\n\t\t\t\t    struct client_init_ramrod_data *data)\n{\n\tstruct cnic_local *cp = dev->cnic_priv;\n\tstruct bnx2x *bp = netdev_priv(dev->netdev);\n\tstruct cnic_uio_dev *udev = cp->udev;\n\tunion eth_tx_bd_types *txbd = (union eth_tx_bd_types *) udev->l2_ring;\n\tdma_addr_t buf_map, ring_map = udev->l2_ring_map;\n\tstruct host_sp_status_block *sb = cp->bnx2x_def_status_blk;\n\tint i;\n\tu32 cli = cp->ethdev->iscsi_l2_client_id;\n\tu32 val;\n\n\tmemset(txbd, 0, CNIC_PAGE_SIZE);\n\n\tbuf_map = udev->l2_buf_map;\n\tfor (i = 0; i < BNX2_MAX_TX_DESC_CNT; i += 3, txbd += 3) {\n\t\tstruct eth_tx_start_bd *start_bd = &txbd->start_bd;\n\t\tstruct eth_tx_parse_bd_e1x *pbd_e1x =\n\t\t\t&((txbd + 1)->parse_bd_e1x);\n\t\tstruct eth_tx_parse_bd_e2 *pbd_e2 = &((txbd + 1)->parse_bd_e2);\n\t\tstruct eth_tx_bd *reg_bd = &((txbd + 2)->reg_bd);\n\n\t\tstart_bd->addr_hi = cpu_to_le32((u64) buf_map >> 32);\n\t\tstart_bd->addr_lo = cpu_to_le32(buf_map & 0xffffffff);\n\t\treg_bd->addr_hi = start_bd->addr_hi;\n\t\treg_bd->addr_lo = start_bd->addr_lo + 0x10;\n\t\tstart_bd->nbytes = cpu_to_le16(0x10);\n\t\tstart_bd->nbd = cpu_to_le16(3);\n\t\tstart_bd->bd_flags.as_bitfield = ETH_TX_BD_FLAGS_START_BD;\n\t\tstart_bd->general_data &= ~ETH_TX_START_BD_PARSE_NBDS;\n\t\tstart_bd->general_data |= (1 << ETH_TX_START_BD_HDR_NBDS_SHIFT);\n\n\t\tif (BNX2X_CHIP_IS_E2_PLUS(bp))\n\t\t\tpbd_e2->parsing_data = (UNICAST_ADDRESS <<\n\t\t\t\tETH_TX_PARSE_BD_E2_ETH_ADDR_TYPE_SHIFT);\n\t\telse\n\t\t\tpbd_e1x->global_data = (UNICAST_ADDRESS <<\n\t\t\t\tETH_TX_PARSE_BD_E1X_ETH_ADDR_TYPE_SHIFT);\n\t}\n\n\tval = (u64) ring_map >> 32;\n\ttxbd->next_bd.addr_hi = cpu_to_le32(val);\n\n\tdata->tx.tx_bd_page_base.hi = cpu_to_le32(val);\n\n\tval = (u64) ring_map & 0xffffffff;\n\ttxbd->next_bd.addr_lo = cpu_to_le32(val);\n\n\tdata->tx.tx_bd_page_base.lo = cpu_to_le32(val);\n\n\t \n\tdata->tx.tx_sb_index_number = HC_SP_INDEX_ETH_ISCSI_CQ_CONS;\n\tdata->tx.tx_status_block_id = BNX2X_DEF_SB_ID;\n\n\t \n\tif (cli < MAX_STAT_COUNTER_ID) {\n\t\tdata->general.statistics_zero_flg = 1;\n\t\tdata->general.statistics_en_flg = 1;\n\t\tdata->general.statistics_counter_id = cli;\n\t}\n\n\tcp->tx_cons_ptr =\n\t\t&sb->sp_sb.index_values[HC_SP_INDEX_ETH_ISCSI_CQ_CONS];\n}\n\nstatic void cnic_init_bnx2x_rx_ring(struct cnic_dev *dev,\n\t\t\t\t    struct client_init_ramrod_data *data)\n{\n\tstruct cnic_local *cp = dev->cnic_priv;\n\tstruct bnx2x *bp = netdev_priv(dev->netdev);\n\tstruct cnic_uio_dev *udev = cp->udev;\n\tstruct eth_rx_bd *rxbd = (struct eth_rx_bd *) (udev->l2_ring +\n\t\t\t\tCNIC_PAGE_SIZE);\n\tstruct eth_rx_cqe_next_page *rxcqe = (struct eth_rx_cqe_next_page *)\n\t\t\t\t(udev->l2_ring + (2 * CNIC_PAGE_SIZE));\n\tstruct host_sp_status_block *sb = cp->bnx2x_def_status_blk;\n\tint i;\n\tu32 cli = cp->ethdev->iscsi_l2_client_id;\n\tint cl_qzone_id = BNX2X_CL_QZONE_ID(bp, cli);\n\tu32 val;\n\tdma_addr_t ring_map = udev->l2_ring_map;\n\n\t \n\tdata->general.client_id = cli;\n\tdata->general.activate_flg = 1;\n\tdata->general.sp_client_id = cli;\n\tdata->general.mtu = cpu_to_le16(cp->l2_single_buf_size - 14);\n\tdata->general.func_id = bp->pfid;\n\n\tfor (i = 0; i < BNX2X_MAX_RX_DESC_CNT; i++, rxbd++) {\n\t\tdma_addr_t buf_map;\n\t\tint n = (i % cp->l2_rx_ring_size) + 1;\n\n\t\tbuf_map = udev->l2_buf_map + (n * cp->l2_single_buf_size);\n\t\trxbd->addr_hi = cpu_to_le32((u64) buf_map >> 32);\n\t\trxbd->addr_lo = cpu_to_le32(buf_map & 0xffffffff);\n\t}\n\n\tval = (u64) (ring_map + CNIC_PAGE_SIZE) >> 32;\n\trxbd->addr_hi = cpu_to_le32(val);\n\tdata->rx.bd_page_base.hi = cpu_to_le32(val);\n\n\tval = (u64) (ring_map + CNIC_PAGE_SIZE) & 0xffffffff;\n\trxbd->addr_lo = cpu_to_le32(val);\n\tdata->rx.bd_page_base.lo = cpu_to_le32(val);\n\n\trxcqe += BNX2X_MAX_RCQ_DESC_CNT;\n\tval = (u64) (ring_map + (2 * CNIC_PAGE_SIZE)) >> 32;\n\trxcqe->addr_hi = cpu_to_le32(val);\n\tdata->rx.cqe_page_base.hi = cpu_to_le32(val);\n\n\tval = (u64) (ring_map + (2 * CNIC_PAGE_SIZE)) & 0xffffffff;\n\trxcqe->addr_lo = cpu_to_le32(val);\n\tdata->rx.cqe_page_base.lo = cpu_to_le32(val);\n\n\t \n\tdata->rx.client_qzone_id = cl_qzone_id;\n\tdata->rx.rx_sb_index_number = HC_SP_INDEX_ETH_ISCSI_RX_CQ_CONS;\n\tdata->rx.status_block_id = BNX2X_DEF_SB_ID;\n\n\tdata->rx.cache_line_alignment_log_size = L1_CACHE_SHIFT;\n\n\tdata->rx.max_bytes_on_bd = cpu_to_le16(cp->l2_single_buf_size);\n\tdata->rx.outer_vlan_removal_enable_flg = 1;\n\tdata->rx.silent_vlan_removal_flg = 1;\n\tdata->rx.silent_vlan_value = 0;\n\tdata->rx.silent_vlan_mask = 0xffff;\n\n\tcp->rx_cons_ptr =\n\t\t&sb->sp_sb.index_values[HC_SP_INDEX_ETH_ISCSI_RX_CQ_CONS];\n\tcp->rx_cons = *cp->rx_cons_ptr;\n}\n\nstatic void cnic_init_bnx2x_kcq(struct cnic_dev *dev)\n{\n\tstruct cnic_local *cp = dev->cnic_priv;\n\tstruct bnx2x *bp = netdev_priv(dev->netdev);\n\tu32 pfid = bp->pfid;\n\n\tcp->kcq1.io_addr = BAR_CSTRORM_INTMEM +\n\t\t\t   CSTORM_ISCSI_EQ_PROD_OFFSET(pfid, 0);\n\tcp->kcq1.sw_prod_idx = 0;\n\n\tif (BNX2X_CHIP_IS_E2_PLUS(bp)) {\n\t\tstruct host_hc_status_block_e2 *sb = cp->status_blk.gen;\n\n\t\tcp->kcq1.hw_prod_idx_ptr =\n\t\t\t&sb->sb.index_values[HC_INDEX_ISCSI_EQ_CONS];\n\t\tcp->kcq1.status_idx_ptr =\n\t\t\t&sb->sb.running_index[SM_RX_ID];\n\t} else {\n\t\tstruct host_hc_status_block_e1x *sb = cp->status_blk.gen;\n\n\t\tcp->kcq1.hw_prod_idx_ptr =\n\t\t\t&sb->sb.index_values[HC_INDEX_ISCSI_EQ_CONS];\n\t\tcp->kcq1.status_idx_ptr =\n\t\t\t&sb->sb.running_index[SM_RX_ID];\n\t}\n\n\tif (BNX2X_CHIP_IS_E2_PLUS(bp)) {\n\t\tstruct host_hc_status_block_e2 *sb = cp->status_blk.gen;\n\n\t\tcp->kcq2.io_addr = BAR_USTRORM_INTMEM +\n\t\t\t\t\tUSTORM_FCOE_EQ_PROD_OFFSET(pfid);\n\t\tcp->kcq2.sw_prod_idx = 0;\n\t\tcp->kcq2.hw_prod_idx_ptr =\n\t\t\t&sb->sb.index_values[HC_INDEX_FCOE_EQ_CONS];\n\t\tcp->kcq2.status_idx_ptr =\n\t\t\t&sb->sb.running_index[SM_RX_ID];\n\t}\n}\n\nstatic int cnic_start_bnx2x_hw(struct cnic_dev *dev)\n{\n\tstruct cnic_local *cp = dev->cnic_priv;\n\tstruct bnx2x *bp = netdev_priv(dev->netdev);\n\tstruct cnic_eth_dev *ethdev = cp->ethdev;\n\tint ret;\n\tu32 pfid;\n\n\tdev->stats_addr = ethdev->addr_drv_info_to_mcp;\n\tcp->func = bp->pf_num;\n\n\tpfid = bp->pfid;\n\n\tret = cnic_init_id_tbl(&cp->cid_tbl, MAX_ISCSI_TBL_SZ,\n\t\t\t       cp->iscsi_start_cid, 0);\n\n\tif (ret)\n\t\treturn -ENOMEM;\n\n\tif (BNX2X_CHIP_IS_E2_PLUS(bp)) {\n\t\tret = cnic_init_id_tbl(&cp->fcoe_cid_tbl, dev->max_fcoe_conn,\n\t\t\t\t\tcp->fcoe_start_cid, 0);\n\n\t\tif (ret)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tcp->bnx2x_igu_sb_id = ethdev->irq_arr[0].status_blk_num2;\n\n\tcnic_init_bnx2x_kcq(dev);\n\n\t \n\tCNIC_WR16(dev, cp->kcq1.io_addr, MAX_KCQ_IDX);\n\tCNIC_WR(dev, BAR_CSTRORM_INTMEM +\n\t\tCSTORM_ISCSI_EQ_CONS_OFFSET(pfid, 0), 0);\n\tCNIC_WR(dev, BAR_CSTRORM_INTMEM +\n\t\tCSTORM_ISCSI_EQ_NEXT_PAGE_ADDR_OFFSET(pfid, 0),\n\t\tcp->kcq1.dma.pg_map_arr[1] & 0xffffffff);\n\tCNIC_WR(dev, BAR_CSTRORM_INTMEM +\n\t\tCSTORM_ISCSI_EQ_NEXT_PAGE_ADDR_OFFSET(pfid, 0) + 4,\n\t\t(u64) cp->kcq1.dma.pg_map_arr[1] >> 32);\n\tCNIC_WR(dev, BAR_CSTRORM_INTMEM +\n\t\tCSTORM_ISCSI_EQ_NEXT_EQE_ADDR_OFFSET(pfid, 0),\n\t\tcp->kcq1.dma.pg_map_arr[0] & 0xffffffff);\n\tCNIC_WR(dev, BAR_CSTRORM_INTMEM +\n\t\tCSTORM_ISCSI_EQ_NEXT_EQE_ADDR_OFFSET(pfid, 0) + 4,\n\t\t(u64) cp->kcq1.dma.pg_map_arr[0] >> 32);\n\tCNIC_WR8(dev, BAR_CSTRORM_INTMEM +\n\t\tCSTORM_ISCSI_EQ_NEXT_PAGE_ADDR_VALID_OFFSET(pfid, 0), 1);\n\tCNIC_WR16(dev, BAR_CSTRORM_INTMEM +\n\t\tCSTORM_ISCSI_EQ_SB_NUM_OFFSET(pfid, 0), cp->status_blk_num);\n\tCNIC_WR8(dev, BAR_CSTRORM_INTMEM +\n\t\tCSTORM_ISCSI_EQ_SB_INDEX_OFFSET(pfid, 0),\n\t\tHC_INDEX_ISCSI_EQ_CONS);\n\n\tCNIC_WR(dev, BAR_USTRORM_INTMEM +\n\t\tUSTORM_ISCSI_GLOBAL_BUF_PHYS_ADDR_OFFSET(pfid),\n\t\tcp->gbl_buf_info.pg_map_arr[0] & 0xffffffff);\n\tCNIC_WR(dev, BAR_USTRORM_INTMEM +\n\t\tUSTORM_ISCSI_GLOBAL_BUF_PHYS_ADDR_OFFSET(pfid) + 4,\n\t\t(u64) cp->gbl_buf_info.pg_map_arr[0] >> 32);\n\n\tCNIC_WR(dev, BAR_TSTRORM_INTMEM +\n\t\tTSTORM_ISCSI_TCP_LOCAL_ADV_WND_OFFSET(pfid), DEF_RCV_BUF);\n\n\tcnic_setup_bnx2x_context(dev);\n\n\tret = cnic_init_bnx2x_irq(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tethdev->drv_state |= CNIC_DRV_STATE_HANDLES_IRQ;\n\treturn 0;\n}\n\nstatic void cnic_init_rings(struct cnic_dev *dev)\n{\n\tstruct cnic_local *cp = dev->cnic_priv;\n\tstruct bnx2x *bp = netdev_priv(dev->netdev);\n\tstruct cnic_uio_dev *udev = cp->udev;\n\n\tif (test_bit(CNIC_LCL_FL_RINGS_INITED, &cp->cnic_local_flags))\n\t\treturn;\n\n\tif (test_bit(CNIC_F_BNX2_CLASS, &dev->flags)) {\n\t\tcnic_init_bnx2_tx_ring(dev);\n\t\tcnic_init_bnx2_rx_ring(dev);\n\t\tset_bit(CNIC_LCL_FL_RINGS_INITED, &cp->cnic_local_flags);\n\t} else if (test_bit(CNIC_F_BNX2X_CLASS, &dev->flags)) {\n\t\tu32 cli = cp->ethdev->iscsi_l2_client_id;\n\t\tu32 cid = cp->ethdev->iscsi_l2_cid;\n\t\tu32 cl_qzone_id;\n\t\tstruct client_init_ramrod_data *data;\n\t\tunion l5cm_specific_data l5_data;\n\t\tstruct ustorm_eth_rx_producers rx_prods = {0};\n\t\tu32 off, i, *cid_ptr;\n\n\t\trx_prods.bd_prod = 0;\n\t\trx_prods.cqe_prod = BNX2X_MAX_RCQ_DESC_CNT;\n\t\tbarrier();\n\n\t\tcl_qzone_id = BNX2X_CL_QZONE_ID(bp, cli);\n\n\t\toff = BAR_USTRORM_INTMEM +\n\t\t\t(BNX2X_CHIP_IS_E2_PLUS(bp) ?\n\t\t\t USTORM_RX_PRODS_E2_OFFSET(cl_qzone_id) :\n\t\t\t USTORM_RX_PRODS_E1X_OFFSET(BP_PORT(bp), cli));\n\n\t\tfor (i = 0; i < sizeof(struct ustorm_eth_rx_producers) / 4; i++)\n\t\t\tCNIC_WR(dev, off + i * 4, ((u32 *) &rx_prods)[i]);\n\n\t\tset_bit(CNIC_LCL_FL_L2_WAIT, &cp->cnic_local_flags);\n\n\t\tdata = udev->l2_buf;\n\t\tcid_ptr = udev->l2_buf + 12;\n\n\t\tmemset(data, 0, sizeof(*data));\n\n\t\tcnic_init_bnx2x_tx_ring(dev, data);\n\t\tcnic_init_bnx2x_rx_ring(dev, data);\n\n\t\tdata->general.fp_hsi_ver =  ETH_FP_HSI_VERSION;\n\n\t\tl5_data.phy_address.lo = udev->l2_buf_map & 0xffffffff;\n\t\tl5_data.phy_address.hi = (u64) udev->l2_buf_map >> 32;\n\n\t\tset_bit(CNIC_LCL_FL_RINGS_INITED, &cp->cnic_local_flags);\n\n\t\tcnic_submit_kwqe_16(dev, RAMROD_CMD_ID_ETH_CLIENT_SETUP,\n\t\t\tcid, ETH_CONNECTION_TYPE, &l5_data);\n\n\t\ti = 0;\n\t\twhile (test_bit(CNIC_LCL_FL_L2_WAIT, &cp->cnic_local_flags) &&\n\t\t       ++i < 10)\n\t\t\tmsleep(1);\n\n\t\tif (test_bit(CNIC_LCL_FL_L2_WAIT, &cp->cnic_local_flags))\n\t\t\tnetdev_err(dev->netdev,\n\t\t\t\t\"iSCSI CLIENT_SETUP did not complete\\n\");\n\t\tcnic_spq_completion(dev, DRV_CTL_RET_L2_SPQ_CREDIT_CMD, 1);\n\t\tcnic_ring_ctl(dev, cid, cli, 1);\n\t\t*cid_ptr = cid >> 4;\n\t\t*(cid_ptr + 1) = cid * bp->db_size;\n\t\t*(cid_ptr + 2) = UIO_USE_TX_DOORBELL;\n\t}\n}\n\nstatic void cnic_shutdown_rings(struct cnic_dev *dev)\n{\n\tstruct cnic_local *cp = dev->cnic_priv;\n\tstruct cnic_uio_dev *udev = cp->udev;\n\tvoid *rx_ring;\n\n\tif (!test_bit(CNIC_LCL_FL_RINGS_INITED, &cp->cnic_local_flags))\n\t\treturn;\n\n\tif (test_bit(CNIC_F_BNX2_CLASS, &dev->flags)) {\n\t\tcnic_shutdown_bnx2_rx_ring(dev);\n\t} else if (test_bit(CNIC_F_BNX2X_CLASS, &dev->flags)) {\n\t\tu32 cli = cp->ethdev->iscsi_l2_client_id;\n\t\tu32 cid = cp->ethdev->iscsi_l2_cid;\n\t\tunion l5cm_specific_data l5_data;\n\t\tint i;\n\n\t\tcnic_ring_ctl(dev, cid, cli, 0);\n\n\t\tset_bit(CNIC_LCL_FL_L2_WAIT, &cp->cnic_local_flags);\n\n\t\tl5_data.phy_address.lo = cli;\n\t\tl5_data.phy_address.hi = 0;\n\t\tcnic_submit_kwqe_16(dev, RAMROD_CMD_ID_ETH_HALT,\n\t\t\tcid, ETH_CONNECTION_TYPE, &l5_data);\n\t\ti = 0;\n\t\twhile (test_bit(CNIC_LCL_FL_L2_WAIT, &cp->cnic_local_flags) &&\n\t\t       ++i < 10)\n\t\t\tmsleep(1);\n\n\t\tif (test_bit(CNIC_LCL_FL_L2_WAIT, &cp->cnic_local_flags))\n\t\t\tnetdev_err(dev->netdev,\n\t\t\t\t\"iSCSI CLIENT_HALT did not complete\\n\");\n\t\tcnic_spq_completion(dev, DRV_CTL_RET_L2_SPQ_CREDIT_CMD, 1);\n\n\t\tmemset(&l5_data, 0, sizeof(l5_data));\n\t\tcnic_submit_kwqe_16(dev, RAMROD_CMD_ID_COMMON_CFC_DEL,\n\t\t\tcid, NONE_CONNECTION_TYPE, &l5_data);\n\t\tmsleep(10);\n\t}\n\tclear_bit(CNIC_LCL_FL_RINGS_INITED, &cp->cnic_local_flags);\n\trx_ring = udev->l2_ring + CNIC_PAGE_SIZE;\n\tmemset(rx_ring, 0, CNIC_PAGE_SIZE);\n}\n\nstatic int cnic_register_netdev(struct cnic_dev *dev)\n{\n\tstruct cnic_local *cp = dev->cnic_priv;\n\tstruct cnic_eth_dev *ethdev = cp->ethdev;\n\tint err;\n\n\tif (!ethdev)\n\t\treturn -ENODEV;\n\n\tif (ethdev->drv_state & CNIC_DRV_STATE_REGD)\n\t\treturn 0;\n\n\terr = ethdev->drv_register_cnic(dev->netdev, cp->cnic_ops, dev);\n\tif (err)\n\t\tnetdev_err(dev->netdev, \"register_cnic failed\\n\");\n\n\t \n\tdev->max_iscsi_conn = ethdev->max_iscsi_conn;\n\tif (ethdev->drv_state & CNIC_DRV_STATE_NO_ISCSI)\n\t\tdev->max_iscsi_conn = 0;\n\n\treturn err;\n}\n\nstatic void cnic_unregister_netdev(struct cnic_dev *dev)\n{\n\tstruct cnic_local *cp = dev->cnic_priv;\n\tstruct cnic_eth_dev *ethdev = cp->ethdev;\n\n\tif (!ethdev)\n\t\treturn;\n\n\tethdev->drv_unregister_cnic(dev->netdev);\n}\n\nstatic int cnic_start_hw(struct cnic_dev *dev)\n{\n\tstruct cnic_local *cp = dev->cnic_priv;\n\tstruct cnic_eth_dev *ethdev = cp->ethdev;\n\tint err;\n\n\tif (test_bit(CNIC_F_CNIC_UP, &dev->flags))\n\t\treturn -EALREADY;\n\n\tdev->regview = ethdev->io_base;\n\tpci_dev_get(dev->pcidev);\n\tcp->func = PCI_FUNC(dev->pcidev->devfn);\n\tcp->status_blk.gen = ethdev->irq_arr[0].status_blk;\n\tcp->status_blk_num = ethdev->irq_arr[0].status_blk_num;\n\n\terr = cp->alloc_resc(dev);\n\tif (err) {\n\t\tnetdev_err(dev->netdev, \"allocate resource failure\\n\");\n\t\tgoto err1;\n\t}\n\n\terr = cp->start_hw(dev);\n\tif (err)\n\t\tgoto err1;\n\n\terr = cnic_cm_open(dev);\n\tif (err)\n\t\tgoto err1;\n\n\tset_bit(CNIC_F_CNIC_UP, &dev->flags);\n\n\tcp->enable_int(dev);\n\n\treturn 0;\n\nerr1:\n\tif (ethdev->drv_state & CNIC_DRV_STATE_HANDLES_IRQ)\n\t\tcp->stop_hw(dev);\n\telse\n\t\tcp->free_resc(dev);\n\tpci_dev_put(dev->pcidev);\n\treturn err;\n}\n\nstatic void cnic_stop_bnx2_hw(struct cnic_dev *dev)\n{\n\tcnic_disable_bnx2_int_sync(dev);\n\n\tcnic_reg_wr_ind(dev, BNX2_CP_SCRATCH + 0x20, 0);\n\tcnic_reg_wr_ind(dev, BNX2_COM_SCRATCH + 0x20, 0);\n\n\tcnic_init_context(dev, KWQ_CID);\n\tcnic_init_context(dev, KCQ_CID);\n\n\tcnic_setup_5709_context(dev, 0);\n\tcnic_free_irq(dev);\n\n\tcnic_free_resc(dev);\n}\n\n\nstatic void cnic_stop_bnx2x_hw(struct cnic_dev *dev)\n{\n\tstruct cnic_local *cp = dev->cnic_priv;\n\tstruct bnx2x *bp = netdev_priv(dev->netdev);\n\tu32 hc_index = HC_INDEX_ISCSI_EQ_CONS;\n\tu32 sb_id = cp->status_blk_num;\n\tu32 idx_off, syn_off;\n\n\tcnic_free_irq(dev);\n\n\tif (BNX2X_CHIP_IS_E2_PLUS(bp)) {\n\t\tidx_off = offsetof(struct hc_status_block_e2, index_values) +\n\t\t\t  (hc_index * sizeof(u16));\n\n\t\tsyn_off = CSTORM_HC_SYNC_LINE_INDEX_E2_OFFSET(hc_index, sb_id);\n\t} else {\n\t\tidx_off = offsetof(struct hc_status_block_e1x, index_values) +\n\t\t\t  (hc_index * sizeof(u16));\n\n\t\tsyn_off = CSTORM_HC_SYNC_LINE_INDEX_E1X_OFFSET(hc_index, sb_id);\n\t}\n\tCNIC_WR16(dev, BAR_CSTRORM_INTMEM + syn_off, 0);\n\tCNIC_WR16(dev, BAR_CSTRORM_INTMEM + CSTORM_STATUS_BLOCK_OFFSET(sb_id) +\n\t\t  idx_off, 0);\n\n\t*cp->kcq1.hw_prod_idx_ptr = 0;\n\tCNIC_WR(dev, BAR_CSTRORM_INTMEM +\n\t\tCSTORM_ISCSI_EQ_CONS_OFFSET(bp->pfid, 0), 0);\n\tCNIC_WR16(dev, cp->kcq1.io_addr, 0);\n\tcnic_free_resc(dev);\n}\n\nstatic void cnic_stop_hw(struct cnic_dev *dev)\n{\n\tif (test_bit(CNIC_F_CNIC_UP, &dev->flags)) {\n\t\tstruct cnic_local *cp = dev->cnic_priv;\n\t\tint i = 0;\n\n\t\t \n\t\twhile (cp->udev && cp->udev->uio_dev != -1 && i < 15) {\n\t\t\tmsleep(100);\n\t\t\ti++;\n\t\t}\n\t\tcnic_shutdown_rings(dev);\n\t\tcp->stop_cm(dev);\n\t\tcp->ethdev->drv_state &= ~CNIC_DRV_STATE_HANDLES_IRQ;\n\t\tclear_bit(CNIC_F_CNIC_UP, &dev->flags);\n\t\tRCU_INIT_POINTER(cp->ulp_ops[CNIC_ULP_L4], NULL);\n\t\tsynchronize_rcu();\n\t\tcnic_cm_shutdown(dev);\n\t\tcp->stop_hw(dev);\n\t\tpci_dev_put(dev->pcidev);\n\t}\n}\n\nstatic void cnic_free_dev(struct cnic_dev *dev)\n{\n\tint i = 0;\n\n\twhile ((atomic_read(&dev->ref_count) != 0) && i < 10) {\n\t\tmsleep(100);\n\t\ti++;\n\t}\n\tif (atomic_read(&dev->ref_count) != 0)\n\t\tnetdev_err(dev->netdev, \"Failed waiting for ref count to go to zero\\n\");\n\n\tnetdev_info(dev->netdev, \"Removed CNIC device\\n\");\n\tdev_put(dev->netdev);\n\tkfree(dev);\n}\n\nstatic int cnic_get_fc_npiv_tbl(struct cnic_dev *dev,\n\t\t\t\tstruct cnic_fc_npiv_tbl *npiv_tbl)\n{\n\tstruct cnic_local *cp = dev->cnic_priv;\n\tstruct bnx2x *bp = netdev_priv(dev->netdev);\n\tint ret;\n\n\tif (!test_bit(CNIC_F_CNIC_UP, &dev->flags))\n\t\treturn -EAGAIN;      \n\n\tif (!BNX2X_CHIP_IS_E2_PLUS(bp))\n\t\treturn -EINVAL;\n\n\tret = cp->ethdev->drv_get_fc_npiv_tbl(dev->netdev, npiv_tbl);\n\treturn ret;\n}\n\nstatic struct cnic_dev *cnic_alloc_dev(struct net_device *dev,\n\t\t\t\t       struct pci_dev *pdev)\n{\n\tstruct cnic_dev *cdev;\n\tstruct cnic_local *cp;\n\tint alloc_size;\n\n\talloc_size = sizeof(struct cnic_dev) + sizeof(struct cnic_local);\n\n\tcdev = kzalloc(alloc_size, GFP_KERNEL);\n\tif (cdev == NULL)\n\t\treturn NULL;\n\n\tcdev->netdev = dev;\n\tcdev->cnic_priv = (char *)cdev + sizeof(struct cnic_dev);\n\tcdev->register_device = cnic_register_device;\n\tcdev->unregister_device = cnic_unregister_device;\n\tcdev->iscsi_nl_msg_recv = cnic_iscsi_nl_msg_recv;\n\tcdev->get_fc_npiv_tbl = cnic_get_fc_npiv_tbl;\n\tatomic_set(&cdev->ref_count, 0);\n\n\tcp = cdev->cnic_priv;\n\tcp->dev = cdev;\n\tcp->l2_single_buf_size = 0x400;\n\tcp->l2_rx_ring_size = 3;\n\n\tspin_lock_init(&cp->cnic_ulp_lock);\n\n\tnetdev_info(dev, \"Added CNIC device\\n\");\n\n\treturn cdev;\n}\n\nstatic struct cnic_dev *init_bnx2_cnic(struct net_device *dev)\n{\n\tstruct pci_dev *pdev;\n\tstruct cnic_dev *cdev;\n\tstruct cnic_local *cp;\n\tstruct bnx2 *bp = netdev_priv(dev);\n\tstruct cnic_eth_dev *ethdev = NULL;\n\n\tif (bp->cnic_probe)\n\t\tethdev = (bp->cnic_probe)(dev);\n\n\tif (!ethdev)\n\t\treturn NULL;\n\n\tpdev = ethdev->pdev;\n\tif (!pdev)\n\t\treturn NULL;\n\n\tdev_hold(dev);\n\tpci_dev_get(pdev);\n\tif ((pdev->device == PCI_DEVICE_ID_NX2_5709 ||\n\t     pdev->device == PCI_DEVICE_ID_NX2_5709S) &&\n\t    (pdev->revision < 0x10)) {\n\t\tpci_dev_put(pdev);\n\t\tgoto cnic_err;\n\t}\n\tpci_dev_put(pdev);\n\n\tcdev = cnic_alloc_dev(dev, pdev);\n\tif (cdev == NULL)\n\t\tgoto cnic_err;\n\n\tset_bit(CNIC_F_BNX2_CLASS, &cdev->flags);\n\tcdev->submit_kwqes = cnic_submit_bnx2_kwqes;\n\n\tcp = cdev->cnic_priv;\n\tcp->ethdev = ethdev;\n\tcdev->pcidev = pdev;\n\tcp->chip_id = ethdev->chip_id;\n\n\tcdev->max_iscsi_conn = ethdev->max_iscsi_conn;\n\n\tcp->cnic_ops = &cnic_bnx2_ops;\n\tcp->start_hw = cnic_start_bnx2_hw;\n\tcp->stop_hw = cnic_stop_bnx2_hw;\n\tcp->setup_pgtbl = cnic_setup_page_tbl;\n\tcp->alloc_resc = cnic_alloc_bnx2_resc;\n\tcp->free_resc = cnic_free_resc;\n\tcp->start_cm = cnic_cm_init_bnx2_hw;\n\tcp->stop_cm = cnic_cm_stop_bnx2_hw;\n\tcp->enable_int = cnic_enable_bnx2_int;\n\tcp->disable_int_sync = cnic_disable_bnx2_int_sync;\n\tcp->close_conn = cnic_close_bnx2_conn;\n\treturn cdev;\n\ncnic_err:\n\tdev_put(dev);\n\treturn NULL;\n}\n\nstatic struct cnic_dev *init_bnx2x_cnic(struct net_device *dev)\n{\n\tstruct pci_dev *pdev;\n\tstruct cnic_dev *cdev;\n\tstruct cnic_local *cp;\n\tstruct bnx2x *bp = netdev_priv(dev);\n\tstruct cnic_eth_dev *ethdev = NULL;\n\n\tif (bp->cnic_probe)\n\t\tethdev = bp->cnic_probe(dev);\n\n\tif (!ethdev)\n\t\treturn NULL;\n\n\tpdev = ethdev->pdev;\n\tif (!pdev)\n\t\treturn NULL;\n\n\tdev_hold(dev);\n\tcdev = cnic_alloc_dev(dev, pdev);\n\tif (cdev == NULL) {\n\t\tdev_put(dev);\n\t\treturn NULL;\n\t}\n\n\tset_bit(CNIC_F_BNX2X_CLASS, &cdev->flags);\n\tcdev->submit_kwqes = cnic_submit_bnx2x_kwqes;\n\n\tcp = cdev->cnic_priv;\n\tcp->ethdev = ethdev;\n\tcdev->pcidev = pdev;\n\tcp->chip_id = ethdev->chip_id;\n\n\tcdev->stats_addr = ethdev->addr_drv_info_to_mcp;\n\n\tif (!(ethdev->drv_state & CNIC_DRV_STATE_NO_ISCSI))\n\t\tcdev->max_iscsi_conn = ethdev->max_iscsi_conn;\n\tif (CNIC_SUPPORTS_FCOE(bp)) {\n\t\tcdev->max_fcoe_conn = ethdev->max_fcoe_conn;\n\t\tcdev->max_fcoe_exchanges = ethdev->max_fcoe_exchanges;\n\t}\n\n\tif (cdev->max_fcoe_conn > BNX2X_FCOE_NUM_CONNECTIONS)\n\t\tcdev->max_fcoe_conn = BNX2X_FCOE_NUM_CONNECTIONS;\n\n\tmemcpy(cdev->mac_addr, ethdev->iscsi_mac, ETH_ALEN);\n\n\tcp->cnic_ops = &cnic_bnx2x_ops;\n\tcp->start_hw = cnic_start_bnx2x_hw;\n\tcp->stop_hw = cnic_stop_bnx2x_hw;\n\tcp->setup_pgtbl = cnic_setup_page_tbl_le;\n\tcp->alloc_resc = cnic_alloc_bnx2x_resc;\n\tcp->free_resc = cnic_free_resc;\n\tcp->start_cm = cnic_cm_init_bnx2x_hw;\n\tcp->stop_cm = cnic_cm_stop_bnx2x_hw;\n\tcp->enable_int = cnic_enable_bnx2x_int;\n\tcp->disable_int_sync = cnic_disable_bnx2x_int_sync;\n\tif (BNX2X_CHIP_IS_E2_PLUS(bp)) {\n\t\tcp->ack_int = cnic_ack_bnx2x_e2_msix;\n\t\tcp->arm_int = cnic_arm_bnx2x_e2_msix;\n\t} else {\n\t\tcp->ack_int = cnic_ack_bnx2x_msix;\n\t\tcp->arm_int = cnic_arm_bnx2x_msix;\n\t}\n\tcp->close_conn = cnic_close_bnx2x_conn;\n\treturn cdev;\n}\n\nstatic struct cnic_dev *is_cnic_dev(struct net_device *dev)\n{\n\tstruct ethtool_drvinfo drvinfo;\n\tstruct cnic_dev *cdev = NULL;\n\n\tif (dev->ethtool_ops && dev->ethtool_ops->get_drvinfo) {\n\t\tmemset(&drvinfo, 0, sizeof(drvinfo));\n\t\tdev->ethtool_ops->get_drvinfo(dev, &drvinfo);\n\n\t\tif (!strcmp(drvinfo.driver, \"bnx2\"))\n\t\t\tcdev = init_bnx2_cnic(dev);\n\t\tif (!strcmp(drvinfo.driver, \"bnx2x\"))\n\t\t\tcdev = init_bnx2x_cnic(dev);\n\t\tif (cdev) {\n\t\t\twrite_lock(&cnic_dev_lock);\n\t\t\tlist_add(&cdev->list, &cnic_dev_list);\n\t\t\twrite_unlock(&cnic_dev_lock);\n\t\t}\n\t}\n\treturn cdev;\n}\n\nstatic void cnic_rcv_netevent(struct cnic_local *cp, unsigned long event,\n\t\t\t      u16 vlan_id)\n{\n\tint if_type;\n\n\tfor (if_type = 0; if_type < MAX_CNIC_ULP_TYPE; if_type++) {\n\t\tstruct cnic_ulp_ops *ulp_ops;\n\t\tvoid *ctx;\n\n\t\tmutex_lock(&cnic_lock);\n\t\tulp_ops = rcu_dereference_protected(cp->ulp_ops[if_type],\n\t\t\t\t\t\tlockdep_is_held(&cnic_lock));\n\t\tif (!ulp_ops || !ulp_ops->indicate_netevent) {\n\t\t\tmutex_unlock(&cnic_lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\tctx = cp->ulp_handle[if_type];\n\n\t\tset_bit(ULP_F_CALL_PENDING, &cp->ulp_flags[if_type]);\n\t\tmutex_unlock(&cnic_lock);\n\n\t\tulp_ops->indicate_netevent(ctx, event, vlan_id);\n\n\t\tclear_bit(ULP_F_CALL_PENDING, &cp->ulp_flags[if_type]);\n\t}\n}\n\n \nstatic int cnic_netdev_event(struct notifier_block *this, unsigned long event,\n\t\t\t\t\t\t\t void *ptr)\n{\n\tstruct net_device *netdev = netdev_notifier_info_to_dev(ptr);\n\tstruct cnic_dev *dev;\n\tint new_dev = 0;\n\n\tdev = cnic_from_netdev(netdev);\n\n\tif (!dev && event == NETDEV_REGISTER) {\n\t\t \n\t\tdev = is_cnic_dev(netdev);\n\t\tif (dev) {\n\t\t\tnew_dev = 1;\n\t\t\tcnic_hold(dev);\n\t\t}\n\t}\n\tif (dev) {\n\t\tstruct cnic_local *cp = dev->cnic_priv;\n\n\t\tif (new_dev)\n\t\t\tcnic_ulp_init(dev);\n\t\telse if (event == NETDEV_UNREGISTER)\n\t\t\tcnic_ulp_exit(dev);\n\n\t\tif (event == NETDEV_UP) {\n\t\t\tif (cnic_register_netdev(dev) != 0) {\n\t\t\t\tcnic_put(dev);\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tif (!cnic_start_hw(dev))\n\t\t\t\tcnic_ulp_start(dev);\n\t\t}\n\n\t\tcnic_rcv_netevent(cp, event, 0);\n\n\t\tif (event == NETDEV_GOING_DOWN) {\n\t\t\tcnic_ulp_stop(dev);\n\t\t\tcnic_stop_hw(dev);\n\t\t\tcnic_unregister_netdev(dev);\n\t\t} else if (event == NETDEV_UNREGISTER) {\n\t\t\twrite_lock(&cnic_dev_lock);\n\t\t\tlist_del_init(&dev->list);\n\t\t\twrite_unlock(&cnic_dev_lock);\n\n\t\t\tcnic_put(dev);\n\t\t\tcnic_free_dev(dev);\n\t\t\tgoto done;\n\t\t}\n\t\tcnic_put(dev);\n\t} else {\n\t\tstruct net_device *realdev;\n\t\tu16 vid;\n\n\t\tvid = cnic_get_vlan(netdev, &realdev);\n\t\tif (realdev) {\n\t\t\tdev = cnic_from_netdev(realdev);\n\t\t\tif (dev) {\n\t\t\t\tvid |= VLAN_CFI_MASK;\t \n\t\t\t\tcnic_rcv_netevent(dev->cnic_priv, event, vid);\n\t\t\t\tcnic_put(dev);\n\t\t\t}\n\t\t}\n\t}\ndone:\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block cnic_netdev_notifier = {\n\t.notifier_call = cnic_netdev_event\n};\n\nstatic void cnic_release(void)\n{\n\tstruct cnic_uio_dev *udev;\n\n\twhile (!list_empty(&cnic_udev_list)) {\n\t\tudev = list_entry(cnic_udev_list.next, struct cnic_uio_dev,\n\t\t\t\t  list);\n\t\tcnic_free_uio(udev);\n\t}\n}\n\nstatic int __init cnic_init(void)\n{\n\tint rc = 0;\n\n\tpr_info(\"%s\", version);\n\n\trc = register_netdevice_notifier(&cnic_netdev_notifier);\n\tif (rc) {\n\t\tcnic_release();\n\t\treturn rc;\n\t}\n\n\tcnic_wq = create_singlethread_workqueue(\"cnic_wq\");\n\tif (!cnic_wq) {\n\t\tcnic_release();\n\t\tunregister_netdevice_notifier(&cnic_netdev_notifier);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic void __exit cnic_exit(void)\n{\n\tunregister_netdevice_notifier(&cnic_netdev_notifier);\n\tcnic_release();\n\tdestroy_workqueue(cnic_wq);\n}\n\nmodule_init(cnic_init);\nmodule_exit(cnic_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}