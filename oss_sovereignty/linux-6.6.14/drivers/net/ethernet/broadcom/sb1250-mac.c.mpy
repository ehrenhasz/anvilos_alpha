{
  "module_name": "sb1250-mac.c",
  "hash_id": "8d699b25009b6f94dc3e3d6fe53135be6bd1098aa5107a3818b8ba44428e63b9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/broadcom/sb1250-mac.c",
  "human_readable_source": "\n \n\n#include <linux/bug.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/timer.h>\n#include <linux/errno.h>\n#include <linux/ioport.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/skbuff.h>\n#include <linux/bitops.h>\n#include <linux/err.h>\n#include <linux/ethtool.h>\n#include <linux/mii.h>\n#include <linux/phy.h>\n#include <linux/platform_device.h>\n#include <linux/prefetch.h>\n\n#include <asm/cache.h>\n#include <asm/io.h>\n#include <asm/processor.h>\t \n\n \n\n#define CONFIG_SBMAC_COALESCE\n\n \n#define TX_TIMEOUT  (2*HZ)\n\n\nMODULE_AUTHOR(\"Mitch Lichtenberg (Broadcom Corp.)\");\nMODULE_DESCRIPTION(\"Broadcom SiByte SOC GB Ethernet driver\");\n\n \n\n \nstatic int debug = 1;\nmodule_param(debug, int, 0444);\nMODULE_PARM_DESC(debug, \"Debug messages\");\n\n#ifdef CONFIG_SBMAC_COALESCE\nstatic int int_pktcnt_tx = 255;\nmodule_param(int_pktcnt_tx, int, 0444);\nMODULE_PARM_DESC(int_pktcnt_tx, \"TX packet count\");\n\nstatic int int_timeout_tx = 255;\nmodule_param(int_timeout_tx, int, 0444);\nMODULE_PARM_DESC(int_timeout_tx, \"TX timeout value\");\n\nstatic int int_pktcnt_rx = 64;\nmodule_param(int_pktcnt_rx, int, 0444);\nMODULE_PARM_DESC(int_pktcnt_rx, \"RX packet count\");\n\nstatic int int_timeout_rx = 64;\nmodule_param(int_timeout_rx, int, 0444);\nMODULE_PARM_DESC(int_timeout_rx, \"RX timeout value\");\n#endif\n\n#include <asm/sibyte/board.h>\n#include <asm/sibyte/sb1250.h>\n#if defined(CONFIG_SIBYTE_BCM1x80)\n#include <asm/sibyte/bcm1480_regs.h>\n#include <asm/sibyte/bcm1480_int.h>\n#define R_MAC_DMA_OODPKTLOST_RX\tR_MAC_DMA_OODPKTLOST\n#elif defined(CONFIG_SIBYTE_SB1250) || defined(CONFIG_SIBYTE_BCM112X)\n#include <asm/sibyte/sb1250_regs.h>\n#include <asm/sibyte/sb1250_int.h>\n#else\n#error invalid SiByte MAC configuration\n#endif\n#include <asm/sibyte/sb1250_scd.h>\n#include <asm/sibyte/sb1250_mac.h>\n#include <asm/sibyte/sb1250_dma.h>\n\n#if defined(CONFIG_SIBYTE_BCM1x80)\n#define UNIT_INT(n)\t\t(K_BCM1480_INT_MAC_0 + ((n) * 2))\n#elif defined(CONFIG_SIBYTE_SB1250) || defined(CONFIG_SIBYTE_BCM112X)\n#define UNIT_INT(n)\t\t(K_INT_MAC_0 + (n))\n#else\n#error invalid SiByte MAC configuration\n#endif\n\n#ifdef K_INT_PHY\n#define SBMAC_PHY_INT\t\t\tK_INT_PHY\n#else\n#define SBMAC_PHY_INT\t\t\tPHY_POLL\n#endif\n\n \n\nenum sbmac_speed {\n\tsbmac_speed_none = 0,\n\tsbmac_speed_10 = SPEED_10,\n\tsbmac_speed_100 = SPEED_100,\n\tsbmac_speed_1000 = SPEED_1000,\n};\n\nenum sbmac_duplex {\n\tsbmac_duplex_none = -1,\n\tsbmac_duplex_half = DUPLEX_HALF,\n\tsbmac_duplex_full = DUPLEX_FULL,\n};\n\nenum sbmac_fc {\n\tsbmac_fc_none,\n\tsbmac_fc_disabled,\n\tsbmac_fc_frame,\n\tsbmac_fc_collision,\n\tsbmac_fc_carrier,\n};\n\nenum sbmac_state {\n\tsbmac_state_uninit,\n\tsbmac_state_off,\n\tsbmac_state_on,\n\tsbmac_state_broken,\n};\n\n\n \n\n\n#define SBDMA_NEXTBUF(d,f) ((((d)->f+1) == (d)->sbdma_dscrtable_end) ? \\\n\t\t\t  (d)->sbdma_dscrtable : (d)->f+1)\n\n\n#define NUMCACHEBLKS(x) DIV_ROUND_UP(x, SMP_CACHE_BYTES)\n\n#define SBMAC_MAX_TXDESCR\t256\n#define SBMAC_MAX_RXDESCR\t256\n\n#define ENET_PACKET_SIZE\t1518\n \n\n \n\nstruct sbdmadscr {\n\tuint64_t  dscr_a;\n\tuint64_t  dscr_b;\n};\n\n \n\nstruct sbmacdma {\n\n\t \n\tstruct sbmac_softc\t*sbdma_eth;\t \n\tint\t\t\tsbdma_channel;\t \n\tint\t\t\tsbdma_txdir;\t \n\tint\t\t\tsbdma_maxdescr;\t \n#ifdef CONFIG_SBMAC_COALESCE\n\tint\t\t\tsbdma_int_pktcnt;\n\t\t\t\t\t\t \n\tint\t\t\tsbdma_int_timeout;\n\t\t\t\t\t\t \n#endif\n\tvoid __iomem\t\t*sbdma_config0;\t \n\tvoid __iomem\t\t*sbdma_config1;\t \n\tvoid __iomem\t\t*sbdma_dscrbase;\n\t\t\t\t\t\t \n\tvoid __iomem\t\t*sbdma_dscrcnt;\t \n\tvoid __iomem\t\t*sbdma_curdscr;\t \n\tvoid __iomem\t\t*sbdma_oodpktlost;\n\t\t\t\t\t\t \n\n\t \n\tvoid\t\t\t*sbdma_dscrtable_unaligned;\n\tstruct sbdmadscr\t*sbdma_dscrtable;\n\t\t\t\t\t\t \n\tstruct sbdmadscr\t*sbdma_dscrtable_end;\n\t\t\t\t\t\t \n\tstruct sk_buff\t\t**sbdma_ctxtable;\n\t\t\t\t\t\t \n\tdma_addr_t\t\tsbdma_dscrtable_phys;\n\t\t\t\t\t\t \n\tstruct sbdmadscr\t*sbdma_addptr;\t \n\tstruct sbdmadscr\t*sbdma_remptr;\t \n};\n\n\n \n\nstruct sbmac_softc {\n\n\t \n\tstruct net_device\t*sbm_dev;\t \n\tstruct napi_struct\tnapi;\n\tstruct phy_device\t*phy_dev;\t \n\tstruct mii_bus\t\t*mii_bus;\t \n\tspinlock_t\t\tsbm_lock;\t \n\tint\t\t\tsbm_devflags;\t \n\n\t \n\tvoid __iomem\t\t*sbm_base;\t \n\tenum sbmac_state\tsbm_state;\t \n\n\tvoid __iomem\t\t*sbm_macenable;\t \n\tvoid __iomem\t\t*sbm_maccfg;\t \n\tvoid __iomem\t\t*sbm_fifocfg;\t \n\tvoid __iomem\t\t*sbm_framecfg;\t \n\tvoid __iomem\t\t*sbm_rxfilter;\t \n\tvoid __iomem\t\t*sbm_isr;\t \n\tvoid __iomem\t\t*sbm_imr;\t \n\tvoid __iomem\t\t*sbm_mdio;\t \n\n\tenum sbmac_speed\tsbm_speed;\t \n\tenum sbmac_duplex\tsbm_duplex;\t \n\tenum sbmac_fc\t\tsbm_fc;\t\t \n\tint\t\t\tsbm_pause;\t \n\tint\t\t\tsbm_link;\t \n\n\tunsigned char\t\tsbm_hwaddr[ETH_ALEN];\n\n\tstruct sbmacdma\t\tsbm_txdma;\t \n\tstruct sbmacdma\t\tsbm_rxdma;\n\tint\t\t\trx_hw_checksum;\n\tint\t\t\tsbe_idx;\n};\n\n\n \n\n \n\nstatic void sbdma_initctx(struct sbmacdma *d, struct sbmac_softc *s, int chan,\n\t\t\t  int txrx, int maxdescr);\nstatic void sbdma_channel_start(struct sbmacdma *d, int rxtx);\nstatic int sbdma_add_rcvbuffer(struct sbmac_softc *sc, struct sbmacdma *d,\n\t\t\t       struct sk_buff *m);\nstatic int sbdma_add_txbuffer(struct sbmacdma *d, struct sk_buff *m);\nstatic void sbdma_emptyring(struct sbmacdma *d);\nstatic void sbdma_fillring(struct sbmac_softc *sc, struct sbmacdma *d);\nstatic int sbdma_rx_process(struct sbmac_softc *sc, struct sbmacdma *d,\n\t\t\t    int work_to_do, int poll);\nstatic void sbdma_tx_process(struct sbmac_softc *sc, struct sbmacdma *d,\n\t\t\t     int poll);\nstatic int sbmac_initctx(struct sbmac_softc *s);\nstatic void sbmac_channel_start(struct sbmac_softc *s);\nstatic void sbmac_channel_stop(struct sbmac_softc *s);\nstatic enum sbmac_state sbmac_set_channel_state(struct sbmac_softc *,\n\t\t\t\t\t\tenum sbmac_state);\nstatic void sbmac_promiscuous_mode(struct sbmac_softc *sc, int onoff);\nstatic uint64_t sbmac_addr2reg(unsigned char *ptr);\nstatic irqreturn_t sbmac_intr(int irq, void *dev_instance);\nstatic netdev_tx_t sbmac_start_tx(struct sk_buff *skb, struct net_device *dev);\nstatic void sbmac_setmulti(struct sbmac_softc *sc);\nstatic int sbmac_init(struct platform_device *pldev, long long base);\nstatic int sbmac_set_speed(struct sbmac_softc *s, enum sbmac_speed speed);\nstatic int sbmac_set_duplex(struct sbmac_softc *s, enum sbmac_duplex duplex,\n\t\t\t    enum sbmac_fc fc);\n\nstatic int sbmac_open(struct net_device *dev);\nstatic void sbmac_tx_timeout (struct net_device *dev, unsigned int txqueue);\nstatic void sbmac_set_rx_mode(struct net_device *dev);\nstatic int sbmac_mii_ioctl(struct net_device *dev, struct ifreq *rq, int cmd);\nstatic int sbmac_close(struct net_device *dev);\nstatic int sbmac_poll(struct napi_struct *napi, int budget);\n\nstatic void sbmac_mii_poll(struct net_device *dev);\nstatic int sbmac_mii_probe(struct net_device *dev);\n\nstatic void sbmac_mii_sync(void __iomem *sbm_mdio);\nstatic void sbmac_mii_senddata(void __iomem *sbm_mdio, unsigned int data,\n\t\t\t       int bitcnt);\nstatic int sbmac_mii_read(struct mii_bus *bus, int phyaddr, int regidx);\nstatic int sbmac_mii_write(struct mii_bus *bus, int phyaddr, int regidx,\n\t\t\t   u16 val);\n\n\n \n\nstatic char sbmac_string[] = \"sb1250-mac\";\n\nstatic char sbmac_mdio_string[] = \"sb1250-mac-mdio\";\n\n\n \n\n#define\tMII_COMMAND_START\t0x01\n#define\tMII_COMMAND_READ\t0x02\n#define\tMII_COMMAND_WRITE\t0x01\n#define\tMII_COMMAND_ACK\t\t0x02\n\n#define M_MAC_MDIO_DIR_OUTPUT\t0\t\t \n\n#define ENABLE \t\t1\n#define DISABLE\t\t0\n\n \n\nstatic void sbmac_mii_sync(void __iomem *sbm_mdio)\n{\n\tint cnt;\n\tuint64_t bits;\n\tint mac_mdio_genc;\n\n\tmac_mdio_genc = __raw_readq(sbm_mdio) & M_MAC_GENC;\n\n\tbits = M_MAC_MDIO_DIR_OUTPUT | M_MAC_MDIO_OUT;\n\n\t__raw_writeq(bits | mac_mdio_genc, sbm_mdio);\n\n\tfor (cnt = 0; cnt < 32; cnt++) {\n\t\t__raw_writeq(bits | M_MAC_MDC | mac_mdio_genc, sbm_mdio);\n\t\t__raw_writeq(bits | mac_mdio_genc, sbm_mdio);\n\t}\n}\n\n \n\nstatic void sbmac_mii_senddata(void __iomem *sbm_mdio, unsigned int data,\n\t\t\t       int bitcnt)\n{\n\tint i;\n\tuint64_t bits;\n\tunsigned int curmask;\n\tint mac_mdio_genc;\n\n\tmac_mdio_genc = __raw_readq(sbm_mdio) & M_MAC_GENC;\n\n\tbits = M_MAC_MDIO_DIR_OUTPUT;\n\t__raw_writeq(bits | mac_mdio_genc, sbm_mdio);\n\n\tcurmask = 1 << (bitcnt - 1);\n\n\tfor (i = 0; i < bitcnt; i++) {\n\t\tif (data & curmask)\n\t\t\tbits |= M_MAC_MDIO_OUT;\n\t\telse bits &= ~M_MAC_MDIO_OUT;\n\t\t__raw_writeq(bits | mac_mdio_genc, sbm_mdio);\n\t\t__raw_writeq(bits | M_MAC_MDC | mac_mdio_genc, sbm_mdio);\n\t\t__raw_writeq(bits | mac_mdio_genc, sbm_mdio);\n\t\tcurmask >>= 1;\n\t}\n}\n\n\n\n \n\nstatic int sbmac_mii_read(struct mii_bus *bus, int phyaddr, int regidx)\n{\n\tstruct sbmac_softc *sc = (struct sbmac_softc *)bus->priv;\n\tvoid __iomem *sbm_mdio = sc->sbm_mdio;\n\tint idx;\n\tint error;\n\tint regval;\n\tint mac_mdio_genc;\n\n\t \n\tsbmac_mii_sync(sbm_mdio);\n\n\t \n\tsbmac_mii_senddata(sbm_mdio, MII_COMMAND_START, 2);\n\tsbmac_mii_senddata(sbm_mdio, MII_COMMAND_READ, 2);\n\tsbmac_mii_senddata(sbm_mdio, phyaddr, 5);\n\tsbmac_mii_senddata(sbm_mdio, regidx, 5);\n\n\tmac_mdio_genc = __raw_readq(sbm_mdio) & M_MAC_GENC;\n\n\t \n\t__raw_writeq(M_MAC_MDIO_DIR_INPUT | mac_mdio_genc, sbm_mdio);\n\n\t \n\t__raw_writeq(M_MAC_MDIO_DIR_INPUT | M_MAC_MDC | mac_mdio_genc,\n\t\t     sbm_mdio);\n\t__raw_writeq(M_MAC_MDIO_DIR_INPUT | mac_mdio_genc, sbm_mdio);\n\n\t \n\terror = __raw_readq(sbm_mdio) & M_MAC_MDIO_IN;\n\n\t \n\t__raw_writeq(M_MAC_MDIO_DIR_INPUT | M_MAC_MDC | mac_mdio_genc,\n\t\t     sbm_mdio);\n\t__raw_writeq(M_MAC_MDIO_DIR_INPUT | mac_mdio_genc, sbm_mdio);\n\n\tregval = 0;\n\n\tfor (idx = 0; idx < 16; idx++) {\n\t\tregval <<= 1;\n\n\t\tif (error == 0) {\n\t\t\tif (__raw_readq(sbm_mdio) & M_MAC_MDIO_IN)\n\t\t\t\tregval |= 1;\n\t\t}\n\n\t\t__raw_writeq(M_MAC_MDIO_DIR_INPUT | M_MAC_MDC | mac_mdio_genc,\n\t\t\t     sbm_mdio);\n\t\t__raw_writeq(M_MAC_MDIO_DIR_INPUT | mac_mdio_genc, sbm_mdio);\n\t}\n\n\t \n\t__raw_writeq(M_MAC_MDIO_DIR_OUTPUT | mac_mdio_genc, sbm_mdio);\n\n\tif (error == 0)\n\t\treturn regval;\n\treturn 0xffff;\n}\n\n\n \n\nstatic int sbmac_mii_write(struct mii_bus *bus, int phyaddr, int regidx,\n\t\t\t   u16 regval)\n{\n\tstruct sbmac_softc *sc = (struct sbmac_softc *)bus->priv;\n\tvoid __iomem *sbm_mdio = sc->sbm_mdio;\n\tint mac_mdio_genc;\n\n\tsbmac_mii_sync(sbm_mdio);\n\n\tsbmac_mii_senddata(sbm_mdio, MII_COMMAND_START, 2);\n\tsbmac_mii_senddata(sbm_mdio, MII_COMMAND_WRITE, 2);\n\tsbmac_mii_senddata(sbm_mdio, phyaddr, 5);\n\tsbmac_mii_senddata(sbm_mdio, regidx, 5);\n\tsbmac_mii_senddata(sbm_mdio, MII_COMMAND_ACK, 2);\n\tsbmac_mii_senddata(sbm_mdio, regval, 16);\n\n\tmac_mdio_genc = __raw_readq(sbm_mdio) & M_MAC_GENC;\n\n\t__raw_writeq(M_MAC_MDIO_DIR_OUTPUT | mac_mdio_genc, sbm_mdio);\n\n\treturn 0;\n}\n\n\n\n \n\nstatic void sbdma_initctx(struct sbmacdma *d, struct sbmac_softc *s, int chan,\n\t\t\t  int txrx, int maxdescr)\n{\n#ifdef CONFIG_SBMAC_COALESCE\n\tint int_pktcnt, int_timeout;\n#endif\n\n\t \n\n\td->sbdma_eth       = s;\n\td->sbdma_channel   = chan;\n\td->sbdma_txdir     = txrx;\n\n#if 0\n\t \n\ts->sbe_idx =(s->sbm_base - A_MAC_BASE_0)/MAC_SPACING;\n#endif\n\n\t__raw_writeq(0, s->sbm_base + R_MAC_RMON_TX_BYTES);\n\t__raw_writeq(0, s->sbm_base + R_MAC_RMON_COLLISIONS);\n\t__raw_writeq(0, s->sbm_base + R_MAC_RMON_LATE_COL);\n\t__raw_writeq(0, s->sbm_base + R_MAC_RMON_EX_COL);\n\t__raw_writeq(0, s->sbm_base + R_MAC_RMON_FCS_ERROR);\n\t__raw_writeq(0, s->sbm_base + R_MAC_RMON_TX_ABORT);\n\t__raw_writeq(0, s->sbm_base + R_MAC_RMON_TX_BAD);\n\t__raw_writeq(0, s->sbm_base + R_MAC_RMON_TX_GOOD);\n\t__raw_writeq(0, s->sbm_base + R_MAC_RMON_TX_RUNT);\n\t__raw_writeq(0, s->sbm_base + R_MAC_RMON_TX_OVERSIZE);\n\t__raw_writeq(0, s->sbm_base + R_MAC_RMON_RX_BYTES);\n\t__raw_writeq(0, s->sbm_base + R_MAC_RMON_RX_MCAST);\n\t__raw_writeq(0, s->sbm_base + R_MAC_RMON_RX_BCAST);\n\t__raw_writeq(0, s->sbm_base + R_MAC_RMON_RX_BAD);\n\t__raw_writeq(0, s->sbm_base + R_MAC_RMON_RX_GOOD);\n\t__raw_writeq(0, s->sbm_base + R_MAC_RMON_RX_RUNT);\n\t__raw_writeq(0, s->sbm_base + R_MAC_RMON_RX_OVERSIZE);\n\t__raw_writeq(0, s->sbm_base + R_MAC_RMON_RX_FCS_ERROR);\n\t__raw_writeq(0, s->sbm_base + R_MAC_RMON_RX_LENGTH_ERROR);\n\t__raw_writeq(0, s->sbm_base + R_MAC_RMON_RX_CODE_ERROR);\n\t__raw_writeq(0, s->sbm_base + R_MAC_RMON_RX_ALIGN_ERROR);\n\n\t \n\n\td->sbdma_config0 =\n\t\ts->sbm_base + R_MAC_DMA_REGISTER(txrx,chan,R_MAC_DMA_CONFIG0);\n\td->sbdma_config1 =\n\t\ts->sbm_base + R_MAC_DMA_REGISTER(txrx,chan,R_MAC_DMA_CONFIG1);\n\td->sbdma_dscrbase =\n\t\ts->sbm_base + R_MAC_DMA_REGISTER(txrx,chan,R_MAC_DMA_DSCR_BASE);\n\td->sbdma_dscrcnt =\n\t\ts->sbm_base + R_MAC_DMA_REGISTER(txrx,chan,R_MAC_DMA_DSCR_CNT);\n\td->sbdma_curdscr =\n\t\ts->sbm_base + R_MAC_DMA_REGISTER(txrx,chan,R_MAC_DMA_CUR_DSCRADDR);\n\tif (d->sbdma_txdir)\n\t\td->sbdma_oodpktlost = NULL;\n\telse\n\t\td->sbdma_oodpktlost =\n\t\t\ts->sbm_base + R_MAC_DMA_REGISTER(txrx,chan,R_MAC_DMA_OODPKTLOST_RX);\n\n\t \n\n\td->sbdma_maxdescr = maxdescr;\n\n\td->sbdma_dscrtable_unaligned = kcalloc(d->sbdma_maxdescr + 1,\n\t\t\t\t\t       sizeof(*d->sbdma_dscrtable),\n\t\t\t\t\t       GFP_KERNEL);\n\n\t \n\td->sbdma_dscrtable = (struct sbdmadscr *)\n\t\t\t     ALIGN((unsigned long)d->sbdma_dscrtable_unaligned,\n\t\t\t\t   sizeof(*d->sbdma_dscrtable));\n\n\td->sbdma_dscrtable_end = d->sbdma_dscrtable + d->sbdma_maxdescr;\n\n\td->sbdma_dscrtable_phys = virt_to_phys(d->sbdma_dscrtable);\n\n\t \n\n\td->sbdma_ctxtable = kcalloc(d->sbdma_maxdescr,\n\t\t\t\t    sizeof(*d->sbdma_ctxtable), GFP_KERNEL);\n\n#ifdef CONFIG_SBMAC_COALESCE\n\t \n\n\tint_pktcnt = (txrx == DMA_TX) ? int_pktcnt_tx : int_pktcnt_rx;\n\tif ( int_pktcnt ) {\n\t\td->sbdma_int_pktcnt = int_pktcnt;\n\t} else {\n\t\td->sbdma_int_pktcnt = 1;\n\t}\n\n\tint_timeout = (txrx == DMA_TX) ? int_timeout_tx : int_timeout_rx;\n\tif ( int_timeout ) {\n\t\td->sbdma_int_timeout = int_timeout;\n\t} else {\n\t\td->sbdma_int_timeout = 0;\n\t}\n#endif\n\n}\n\n \n\nstatic void sbdma_channel_start(struct sbmacdma *d, int rxtx)\n{\n\t \n\n#ifdef CONFIG_SBMAC_COALESCE\n\t__raw_writeq(V_DMA_INT_TIMEOUT(d->sbdma_int_timeout) |\n\t\t       0, d->sbdma_config1);\n\t__raw_writeq(M_DMA_EOP_INT_EN |\n\t\t       V_DMA_RINGSZ(d->sbdma_maxdescr) |\n\t\t       V_DMA_INT_PKTCNT(d->sbdma_int_pktcnt) |\n\t\t       0, d->sbdma_config0);\n#else\n\t__raw_writeq(0, d->sbdma_config1);\n\t__raw_writeq(V_DMA_RINGSZ(d->sbdma_maxdescr) |\n\t\t       0, d->sbdma_config0);\n#endif\n\n\t__raw_writeq(d->sbdma_dscrtable_phys, d->sbdma_dscrbase);\n\n\t \n\n\td->sbdma_addptr = d->sbdma_dscrtable;\n\td->sbdma_remptr = d->sbdma_dscrtable;\n}\n\n \n\nstatic void sbdma_channel_stop(struct sbmacdma *d)\n{\n\t \n\n\t__raw_writeq(0, d->sbdma_config1);\n\n\t__raw_writeq(0, d->sbdma_dscrbase);\n\n\t__raw_writeq(0, d->sbdma_config0);\n\n\t \n\n\td->sbdma_addptr = NULL;\n\td->sbdma_remptr = NULL;\n}\n\nstatic inline void sbdma_align_skb(struct sk_buff *skb,\n\t\t\t\t   unsigned int power2, unsigned int offset)\n{\n\tunsigned char *addr = skb->data;\n\tunsigned char *newaddr = PTR_ALIGN(addr, power2);\n\n\tskb_reserve(skb, newaddr - addr + offset);\n}\n\n\n \n\n\nstatic int sbdma_add_rcvbuffer(struct sbmac_softc *sc, struct sbmacdma *d,\n\t\t\t       struct sk_buff *sb)\n{\n\tstruct net_device *dev = sc->sbm_dev;\n\tstruct sbdmadscr *dsc;\n\tstruct sbdmadscr *nextdsc;\n\tstruct sk_buff *sb_new = NULL;\n\tint pktsize = ENET_PACKET_SIZE;\n\n\t \n\n\tdsc = d->sbdma_addptr;\n\tnextdsc = SBDMA_NEXTBUF(d,sbdma_addptr);\n\n\t \n\n\tif (nextdsc == d->sbdma_remptr) {\n\t\treturn -ENOSPC;\n\t}\n\n\t \n\n\tif (sb == NULL) {\n\t\tsb_new = netdev_alloc_skb(dev, ENET_PACKET_SIZE +\n\t\t\t\t\t       SMP_CACHE_BYTES * 2 +\n\t\t\t\t\t       NET_IP_ALIGN);\n\t\tif (sb_new == NULL)\n\t\t\treturn -ENOBUFS;\n\n\t\tsbdma_align_skb(sb_new, SMP_CACHE_BYTES, NET_IP_ALIGN);\n\t}\n\telse {\n\t\tsb_new = sb;\n\t\t \n\t}\n\n\t \n\n#ifdef CONFIG_SBMAC_COALESCE\n\t \n\tdsc->dscr_a = virt_to_phys(sb_new->data) |\n\t\tV_DMA_DSCRA_A_SIZE(NUMCACHEBLKS(pktsize + NET_IP_ALIGN)) | 0;\n#else\n\tdsc->dscr_a = virt_to_phys(sb_new->data) |\n\t\tV_DMA_DSCRA_A_SIZE(NUMCACHEBLKS(pktsize + NET_IP_ALIGN)) |\n\t\tM_DMA_DSCRA_INTERRUPT;\n#endif\n\n\t \n\tdsc->dscr_b = 0;\n\n\t \n\n\td->sbdma_ctxtable[dsc-d->sbdma_dscrtable] = sb_new;\n\n\t \n\n\td->sbdma_addptr = nextdsc;\n\n\t \n\n\t__raw_writeq(1, d->sbdma_dscrcnt);\n\n\treturn 0;\t\t\t\t\t \n}\n\n \n\n\nstatic int sbdma_add_txbuffer(struct sbmacdma *d, struct sk_buff *sb)\n{\n\tstruct sbdmadscr *dsc;\n\tstruct sbdmadscr *nextdsc;\n\tuint64_t phys;\n\tuint64_t ncb;\n\tint length;\n\n\t \n\n\tdsc = d->sbdma_addptr;\n\tnextdsc = SBDMA_NEXTBUF(d,sbdma_addptr);\n\n\t \n\n\tif (nextdsc == d->sbdma_remptr) {\n\t\treturn -ENOSPC;\n\t}\n\n\t \n\n\tlength = sb->len;\n\n\t \n\n\tphys = virt_to_phys(sb->data);\n\tncb = NUMCACHEBLKS(length+(phys & (SMP_CACHE_BYTES - 1)));\n\n\tdsc->dscr_a = phys |\n\t\tV_DMA_DSCRA_A_SIZE(ncb) |\n#ifndef CONFIG_SBMAC_COALESCE\n\t\tM_DMA_DSCRA_INTERRUPT |\n#endif\n\t\tM_DMA_ETHTX_SOP;\n\n\t \n\n\tdsc->dscr_b = V_DMA_DSCRB_OPTIONS(K_DMA_ETHTX_APPENDCRC_APPENDPAD) |\n\t\tV_DMA_DSCRB_PKT_SIZE(length);\n\n\t \n\n\td->sbdma_ctxtable[dsc-d->sbdma_dscrtable] = sb;\n\n\t \n\n\td->sbdma_addptr = nextdsc;\n\n\t \n\n\t__raw_writeq(1, d->sbdma_dscrcnt);\n\n\treturn 0;\t\t\t\t\t \n}\n\n\n\n\n \n\nstatic void sbdma_emptyring(struct sbmacdma *d)\n{\n\tint idx;\n\tstruct sk_buff *sb;\n\n\tfor (idx = 0; idx < d->sbdma_maxdescr; idx++) {\n\t\tsb = d->sbdma_ctxtable[idx];\n\t\tif (sb) {\n\t\t\tdev_kfree_skb(sb);\n\t\t\td->sbdma_ctxtable[idx] = NULL;\n\t\t}\n\t}\n}\n\n\n \n\nstatic void sbdma_fillring(struct sbmac_softc *sc, struct sbmacdma *d)\n{\n\tint idx;\n\n\tfor (idx = 0; idx < SBMAC_MAX_RXDESCR - 1; idx++) {\n\t\tif (sbdma_add_rcvbuffer(sc, d, NULL) != 0)\n\t\t\tbreak;\n\t}\n}\n\n#ifdef CONFIG_NET_POLL_CONTROLLER\nstatic void sbmac_netpoll(struct net_device *netdev)\n{\n\tstruct sbmac_softc *sc = netdev_priv(netdev);\n\tint irq = sc->sbm_dev->irq;\n\n\t__raw_writeq(0, sc->sbm_imr);\n\n\tsbmac_intr(irq, netdev);\n\n#ifdef CONFIG_SBMAC_COALESCE\n\t__raw_writeq(((M_MAC_INT_EOP_COUNT | M_MAC_INT_EOP_TIMER) << S_MAC_TX_CH0) |\n\t((M_MAC_INT_EOP_COUNT | M_MAC_INT_EOP_TIMER) << S_MAC_RX_CH0),\n\tsc->sbm_imr);\n#else\n\t__raw_writeq((M_MAC_INT_CHANNEL << S_MAC_TX_CH0) |\n\t(M_MAC_INT_CHANNEL << S_MAC_RX_CH0), sc->sbm_imr);\n#endif\n}\n#endif\n\n \n\nstatic int sbdma_rx_process(struct sbmac_softc *sc, struct sbmacdma *d,\n\t\t\t    int work_to_do, int poll)\n{\n\tstruct net_device *dev = sc->sbm_dev;\n\tint curidx;\n\tint hwidx;\n\tstruct sbdmadscr *dsc;\n\tstruct sk_buff *sb;\n\tint len;\n\tint work_done = 0;\n\tint dropped = 0;\n\n\tprefetch(d);\n\nagain:\n\t \n\tdev->stats.rx_fifo_errors\n\t    += __raw_readq(sc->sbm_rxdma.sbdma_oodpktlost) & 0xffff;\n\t__raw_writeq(0, sc->sbm_rxdma.sbdma_oodpktlost);\n\n\twhile (work_to_do-- > 0) {\n\t\t \n\n\t\tdsc = d->sbdma_remptr;\n\t\tcuridx = dsc - d->sbdma_dscrtable;\n\n\t\tprefetch(dsc);\n\t\tprefetch(&d->sbdma_ctxtable[curidx]);\n\n\t\thwidx = ((__raw_readq(d->sbdma_curdscr) & M_DMA_CURDSCR_ADDR) -\n\t\t\t d->sbdma_dscrtable_phys) /\n\t\t\tsizeof(*d->sbdma_dscrtable);\n\n\t\t \n\n\t\tif (curidx == hwidx)\n\t\t\tgoto done;\n\n\t\t \n\n\t\tsb = d->sbdma_ctxtable[curidx];\n\t\td->sbdma_ctxtable[curidx] = NULL;\n\n\t\tlen = (int)G_DMA_DSCRB_PKT_SIZE(dsc->dscr_b) - 4;\n\n\t\t \n\n\t\tif (likely (!(dsc->dscr_a & M_DMA_ETHRX_BAD))) {\n\n\t\t\t \n\n\t\t\tif (unlikely(sbdma_add_rcvbuffer(sc, d, NULL) ==\n\t\t\t\t     -ENOBUFS)) {\n\t\t\t\tdev->stats.rx_dropped++;\n\t\t\t\t \n\t\t\t\tsbdma_add_rcvbuffer(sc, d, sb);\n\t\t\t\t \n\t\t\t\tprintk(KERN_ERR \"dropped packet (1)\\n\");\n\t\t\t\td->sbdma_remptr = SBDMA_NEXTBUF(d,sbdma_remptr);\n\t\t\t\tgoto done;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tskb_put(sb,len);\n\n\t\t\t\t \n\t\t\t\tsb->protocol = eth_type_trans(sb,d->sbdma_eth->sbm_dev);\n\t\t\t\t \n\t\t\t\tif (sc->rx_hw_checksum == ENABLE) {\n\t\t\t\t\tif (!((dsc->dscr_a) & M_DMA_ETHRX_BADIP4CS) &&\n\t\t\t\t\t    !((dsc->dscr_a) & M_DMA_ETHRX_BADTCPCS)) {\n\t\t\t\t\t\tsb->ip_summed = CHECKSUM_UNNECESSARY;\n\t\t\t\t\t\t \n\t\t\t\t\t} else {\n\t\t\t\t\t\tskb_checksum_none_assert(sb);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tprefetch(sb->data);\n\t\t\t\tprefetch((const void *)(((char *)sb->data)+32));\n\t\t\t\tif (poll)\n\t\t\t\t\tdropped = netif_receive_skb(sb);\n\t\t\t\telse\n\t\t\t\t\tdropped = netif_rx(sb);\n\n\t\t\t\tif (dropped == NET_RX_DROP) {\n\t\t\t\t\tdev->stats.rx_dropped++;\n\t\t\t\t\td->sbdma_remptr = SBDMA_NEXTBUF(d,sbdma_remptr);\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdev->stats.rx_bytes += len;\n\t\t\t\t\tdev->stats.rx_packets++;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tdev->stats.rx_errors++;\n\t\t\tsbdma_add_rcvbuffer(sc, d, sb);\n\t\t}\n\n\n\t\t \n\n\t\td->sbdma_remptr = SBDMA_NEXTBUF(d,sbdma_remptr);\n\t\twork_done++;\n\t}\n\tif (!poll) {\n\t\twork_to_do = 32;\n\t\tgoto again;  \n\t}\ndone:\n\treturn work_done;\n}\n\n \n\nstatic void sbdma_tx_process(struct sbmac_softc *sc, struct sbmacdma *d,\n\t\t\t     int poll)\n{\n\tstruct net_device *dev = sc->sbm_dev;\n\tint curidx;\n\tint hwidx;\n\tstruct sbdmadscr *dsc;\n\tstruct sk_buff *sb;\n\tunsigned long flags;\n\tint packets_handled = 0;\n\n\tspin_lock_irqsave(&(sc->sbm_lock), flags);\n\n\tif (d->sbdma_remptr == d->sbdma_addptr)\n\t  goto end_unlock;\n\n\thwidx = ((__raw_readq(d->sbdma_curdscr) & M_DMA_CURDSCR_ADDR) -\n\t\t d->sbdma_dscrtable_phys) / sizeof(*d->sbdma_dscrtable);\n\n\tfor (;;) {\n\t\t \n\n\t\tcuridx = d->sbdma_remptr - d->sbdma_dscrtable;\n\n\t\t \n\n\t\tif (curidx == hwidx)\n\t\t\tbreak;\n\n\t\t \n\n\t\tdsc = &(d->sbdma_dscrtable[curidx]);\n\t\tsb = d->sbdma_ctxtable[curidx];\n\t\td->sbdma_ctxtable[curidx] = NULL;\n\n\t\t \n\n\t\tdev->stats.tx_bytes += sb->len;\n\t\tdev->stats.tx_packets++;\n\n\t\t \n\n\t\tdev_consume_skb_irq(sb);\n\n\t\t \n\n\t\td->sbdma_remptr = SBDMA_NEXTBUF(d,sbdma_remptr);\n\n\t\tpackets_handled++;\n\n\t}\n\n\t \n\n\tif (packets_handled)\n\t\tnetif_wake_queue(d->sbdma_eth->sbm_dev);\n\nend_unlock:\n\tspin_unlock_irqrestore(&(sc->sbm_lock), flags);\n\n}\n\n\n\n \n\nstatic int sbmac_initctx(struct sbmac_softc *s)\n{\n\n\t \n\n\ts->sbm_macenable = s->sbm_base + R_MAC_ENABLE;\n\ts->sbm_maccfg    = s->sbm_base + R_MAC_CFG;\n\ts->sbm_fifocfg   = s->sbm_base + R_MAC_THRSH_CFG;\n\ts->sbm_framecfg  = s->sbm_base + R_MAC_FRAMECFG;\n\ts->sbm_rxfilter  = s->sbm_base + R_MAC_ADFILTER_CFG;\n\ts->sbm_isr       = s->sbm_base + R_MAC_STATUS;\n\ts->sbm_imr       = s->sbm_base + R_MAC_INT_MASK;\n\ts->sbm_mdio      = s->sbm_base + R_MAC_MDIO;\n\n\t \n\n\tsbdma_initctx(&(s->sbm_txdma),s,0,DMA_TX,SBMAC_MAX_TXDESCR);\n\tsbdma_initctx(&(s->sbm_rxdma),s,0,DMA_RX,SBMAC_MAX_RXDESCR);\n\n\t \n\n\ts->sbm_state = sbmac_state_off;\n\n\treturn 0;\n}\n\n\nstatic void sbdma_uninitctx(struct sbmacdma *d)\n{\n\tkfree(d->sbdma_dscrtable_unaligned);\n\td->sbdma_dscrtable_unaligned = d->sbdma_dscrtable = NULL;\n\n\tkfree(d->sbdma_ctxtable);\n\td->sbdma_ctxtable = NULL;\n}\n\n\nstatic void sbmac_uninitctx(struct sbmac_softc *sc)\n{\n\tsbdma_uninitctx(&(sc->sbm_txdma));\n\tsbdma_uninitctx(&(sc->sbm_rxdma));\n}\n\n\n \n\nstatic void sbmac_channel_start(struct sbmac_softc *s)\n{\n\tuint64_t reg;\n\tvoid __iomem *port;\n\tuint64_t cfg,fifo,framecfg;\n\tint idx, th_value;\n\n\t \n\n\tif (s->sbm_state == sbmac_state_on)\n\t\treturn;\n\n\t \n\n\t__raw_writeq(0, s->sbm_macenable);\n\n\t \n\n\t__raw_writeq(0, s->sbm_rxfilter);\n\n\t \n\n\tcfg = M_MAC_RETRY_EN |\n\t\tM_MAC_TX_HOLD_SOP_EN |\n\t\tV_MAC_TX_PAUSE_CNT_16K |\n\t\tM_MAC_AP_STAT_EN |\n\t\tM_MAC_FAST_SYNC |\n\t\tM_MAC_SS_EN |\n\t\t0;\n\n\t \n\tif (soc_type == K_SYS_SOC_TYPE_BCM1250 && periph_rev < 2)\n\t\tth_value = 28;\n\telse\n\t\tth_value = 64;\n\n\tfifo = V_MAC_TX_WR_THRSH(4) |\t \n\t\t((s->sbm_speed == sbmac_speed_1000)\n\t\t ? V_MAC_TX_RD_THRSH(th_value) : V_MAC_TX_RD_THRSH(4)) |\n\t\tV_MAC_TX_RL_THRSH(4) |\n\t\tV_MAC_RX_PL_THRSH(4) |\n\t\tV_MAC_RX_RD_THRSH(4) |\t \n\t\tV_MAC_RX_RL_THRSH(8) |\n\t\t0;\n\n\tframecfg = V_MAC_MIN_FRAMESZ_DEFAULT |\n\t\tV_MAC_MAX_FRAMESZ_DEFAULT |\n\t\tV_MAC_BACKOFF_SEL(1);\n\n\t \n\n\tport = s->sbm_base + R_MAC_HASH_BASE;\n\tfor (idx = 0; idx < MAC_HASH_COUNT; idx++) {\n\t\t__raw_writeq(0, port);\n\t\tport += sizeof(uint64_t);\n\t}\n\n\t \n\n\tport = s->sbm_base + R_MAC_ADDR_BASE;\n\tfor (idx = 0; idx < MAC_ADDR_COUNT; idx++) {\n\t\t__raw_writeq(0, port);\n\t\tport += sizeof(uint64_t);\n\t}\n\n\t \n\n\tport = s->sbm_base + R_MAC_CHUP0_BASE;\n\tfor (idx = 0; idx < MAC_CHMAP_COUNT; idx++) {\n\t\t__raw_writeq(0, port);\n\t\tport += sizeof(uint64_t);\n\t}\n\n\n\tport = s->sbm_base + R_MAC_CHLO0_BASE;\n\tfor (idx = 0; idx < MAC_CHMAP_COUNT; idx++) {\n\t\t__raw_writeq(0, port);\n\t\tport += sizeof(uint64_t);\n\t}\n\n\t \n\n\treg = sbmac_addr2reg(s->sbm_hwaddr);\n\n\tport = s->sbm_base + R_MAC_ADDR_BASE;\n\t__raw_writeq(reg, port);\n\tport = s->sbm_base + R_MAC_ETHERNET_ADDR;\n\n\t__raw_writeq(reg, port);\n\n\t \n\n\t__raw_writeq(0, s->sbm_rxfilter);\n\t__raw_writeq(0, s->sbm_imr);\n\t__raw_writeq(framecfg, s->sbm_framecfg);\n\t__raw_writeq(fifo, s->sbm_fifocfg);\n\t__raw_writeq(cfg, s->sbm_maccfg);\n\n\t \n\n\tsbdma_channel_start(&(s->sbm_rxdma), DMA_RX);\n\tsbdma_channel_start(&(s->sbm_txdma), DMA_TX);\n\n\t \n\n\tsbmac_set_speed(s,s->sbm_speed);\n\tsbmac_set_duplex(s,s->sbm_duplex,s->sbm_fc);\n\n\t \n\n\tsbdma_fillring(s, &(s->sbm_rxdma));\n\n\t \n\n#if defined(CONFIG_SIBYTE_BCM1x80)\n\t__raw_writeq(M_MAC_RXDMA_EN0 |\n\t\t       M_MAC_TXDMA_EN0, s->sbm_macenable);\n#elif defined(CONFIG_SIBYTE_SB1250) || defined(CONFIG_SIBYTE_BCM112X)\n\t__raw_writeq(M_MAC_RXDMA_EN0 |\n\t\t       M_MAC_TXDMA_EN0 |\n\t\t       M_MAC_RX_ENABLE |\n\t\t       M_MAC_TX_ENABLE, s->sbm_macenable);\n#else\n#error invalid SiByte MAC configuration\n#endif\n\n#ifdef CONFIG_SBMAC_COALESCE\n\t__raw_writeq(((M_MAC_INT_EOP_COUNT | M_MAC_INT_EOP_TIMER) << S_MAC_TX_CH0) |\n\t\t       ((M_MAC_INT_EOP_COUNT | M_MAC_INT_EOP_TIMER) << S_MAC_RX_CH0), s->sbm_imr);\n#else\n\t__raw_writeq((M_MAC_INT_CHANNEL << S_MAC_TX_CH0) |\n\t\t       (M_MAC_INT_CHANNEL << S_MAC_RX_CH0), s->sbm_imr);\n#endif\n\n\t \n\n\t__raw_writeq(M_MAC_UCAST_EN | M_MAC_BCAST_EN, s->sbm_rxfilter);\n\n\t \n\n\ts->sbm_state = sbmac_state_on;\n\n\t \n\n\tsbmac_setmulti(s);\n\n\t \n\n\tif (s->sbm_devflags & IFF_PROMISC) {\n\t\tsbmac_promiscuous_mode(s,1);\n\t}\n\n}\n\n\n \n\nstatic void sbmac_channel_stop(struct sbmac_softc *s)\n{\n\t \n\n\tif (s->sbm_state == sbmac_state_off)\n\t\treturn;\n\n\t \n\n\t__raw_writeq(0, s->sbm_rxfilter);\n\t__raw_writeq(0, s->sbm_imr);\n\n\t \n\n\t \n\n\t \n\n\t__raw_writeq(0, s->sbm_macenable);\n\n\t \n\n\ts->sbm_state = sbmac_state_off;\n\n\t \n\n\tsbdma_channel_stop(&(s->sbm_rxdma));\n\tsbdma_channel_stop(&(s->sbm_txdma));\n\n\t \n\n\tsbdma_emptyring(&(s->sbm_rxdma));\n\tsbdma_emptyring(&(s->sbm_txdma));\n\n}\n\n \nstatic enum sbmac_state sbmac_set_channel_state(struct sbmac_softc *sc,\n\t\t\t\t\t\tenum sbmac_state state)\n{\n\tenum sbmac_state oldstate = sc->sbm_state;\n\n\t \n\n\tif (state == oldstate) {\n\t\treturn oldstate;\n\t}\n\n\t \n\n\tif (state == sbmac_state_on) {\n\t\tsbmac_channel_start(sc);\n\t}\n\telse {\n\t\tsbmac_channel_stop(sc);\n\t}\n\n\t \n\n\treturn oldstate;\n}\n\n\n \n\nstatic void sbmac_promiscuous_mode(struct sbmac_softc *sc,int onoff)\n{\n\tuint64_t reg;\n\n\tif (sc->sbm_state != sbmac_state_on)\n\t\treturn;\n\n\tif (onoff) {\n\t\treg = __raw_readq(sc->sbm_rxfilter);\n\t\treg |= M_MAC_ALLPKT_EN;\n\t\t__raw_writeq(reg, sc->sbm_rxfilter);\n\t}\n\telse {\n\t\treg = __raw_readq(sc->sbm_rxfilter);\n\t\treg &= ~M_MAC_ALLPKT_EN;\n\t\t__raw_writeq(reg, sc->sbm_rxfilter);\n\t}\n}\n\n \n\nstatic void sbmac_set_iphdr_offset(struct sbmac_softc *sc)\n{\n\tuint64_t reg;\n\n\t \n\treg = __raw_readq(sc->sbm_rxfilter);\n\treg &= ~M_MAC_IPHDR_OFFSET | V_MAC_IPHDR_OFFSET(15);\n\t__raw_writeq(reg, sc->sbm_rxfilter);\n\n\t \n\tif (soc_type == K_SYS_SOC_TYPE_BCM1250 && periph_rev < 2) {\n\t\tsc->rx_hw_checksum = DISABLE;\n\t} else {\n\t\tsc->rx_hw_checksum = ENABLE;\n\t}\n}\n\n\n \n\nstatic uint64_t sbmac_addr2reg(unsigned char *ptr)\n{\n\tuint64_t reg = 0;\n\n\tptr += 6;\n\n\treg |= (uint64_t) *(--ptr);\n\treg <<= 8;\n\treg |= (uint64_t) *(--ptr);\n\treg <<= 8;\n\treg |= (uint64_t) *(--ptr);\n\treg <<= 8;\n\treg |= (uint64_t) *(--ptr);\n\treg <<= 8;\n\treg |= (uint64_t) *(--ptr);\n\treg <<= 8;\n\treg |= (uint64_t) *(--ptr);\n\n\treturn reg;\n}\n\n\n \n\nstatic int sbmac_set_speed(struct sbmac_softc *s, enum sbmac_speed speed)\n{\n\tuint64_t cfg;\n\tuint64_t framecfg;\n\n\t \n\n\ts->sbm_speed = speed;\n\n\tif (s->sbm_state == sbmac_state_on)\n\t\treturn 0;\t \n\n\t \n\n\tcfg = __raw_readq(s->sbm_maccfg);\n\tframecfg = __raw_readq(s->sbm_framecfg);\n\n\t \n\n\tcfg &= ~(M_MAC_BURST_EN | M_MAC_SPEED_SEL);\n\tframecfg &= ~(M_MAC_IFG_RX | M_MAC_IFG_TX | M_MAC_IFG_THRSH |\n\t\t      M_MAC_SLOT_SIZE);\n\n\t \n\n\tswitch (speed) {\n\tcase sbmac_speed_10:\n\t\tframecfg |= V_MAC_IFG_RX_10 |\n\t\t\tV_MAC_IFG_TX_10 |\n\t\t\tK_MAC_IFG_THRSH_10 |\n\t\t\tV_MAC_SLOT_SIZE_10;\n\t\tcfg |= V_MAC_SPEED_SEL_10MBPS;\n\t\tbreak;\n\n\tcase sbmac_speed_100:\n\t\tframecfg |= V_MAC_IFG_RX_100 |\n\t\t\tV_MAC_IFG_TX_100 |\n\t\t\tV_MAC_IFG_THRSH_100 |\n\t\t\tV_MAC_SLOT_SIZE_100;\n\t\tcfg |= V_MAC_SPEED_SEL_100MBPS ;\n\t\tbreak;\n\n\tcase sbmac_speed_1000:\n\t\tframecfg |= V_MAC_IFG_RX_1000 |\n\t\t\tV_MAC_IFG_TX_1000 |\n\t\t\tV_MAC_IFG_THRSH_1000 |\n\t\t\tV_MAC_SLOT_SIZE_1000;\n\t\tcfg |= V_MAC_SPEED_SEL_1000MBPS | M_MAC_BURST_EN;\n\t\tbreak;\n\n\tdefault:\n\t\treturn 0;\n\t}\n\n\t \n\n\t__raw_writeq(framecfg, s->sbm_framecfg);\n\t__raw_writeq(cfg, s->sbm_maccfg);\n\n\treturn 1;\n}\n\n \n\nstatic int sbmac_set_duplex(struct sbmac_softc *s, enum sbmac_duplex duplex,\n\t\t\t    enum sbmac_fc fc)\n{\n\tuint64_t cfg;\n\n\t \n\n\ts->sbm_duplex = duplex;\n\ts->sbm_fc = fc;\n\n\tif (s->sbm_state == sbmac_state_on)\n\t\treturn 0;\t \n\n\t \n\n\tcfg = __raw_readq(s->sbm_maccfg);\n\n\t \n\n\tcfg &= ~(M_MAC_FC_SEL | M_MAC_FC_CMD | M_MAC_HDX_EN);\n\n\n\tswitch (duplex) {\n\tcase sbmac_duplex_half:\n\t\tswitch (fc) {\n\t\tcase sbmac_fc_disabled:\n\t\t\tcfg |= M_MAC_HDX_EN | V_MAC_FC_CMD_DISABLED;\n\t\t\tbreak;\n\n\t\tcase sbmac_fc_collision:\n\t\t\tcfg |= M_MAC_HDX_EN | V_MAC_FC_CMD_ENABLED;\n\t\t\tbreak;\n\n\t\tcase sbmac_fc_carrier:\n\t\t\tcfg |= M_MAC_HDX_EN | V_MAC_FC_CMD_ENAB_FALSECARR;\n\t\t\tbreak;\n\n\t\tcase sbmac_fc_frame:\t\t \n\t\tdefault:\t\t\t \n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\n\tcase sbmac_duplex_full:\n\t\tswitch (fc) {\n\t\tcase sbmac_fc_disabled:\n\t\t\tcfg |= V_MAC_FC_CMD_DISABLED;\n\t\t\tbreak;\n\n\t\tcase sbmac_fc_frame:\n\t\t\tcfg |= V_MAC_FC_CMD_ENABLED;\n\t\t\tbreak;\n\n\t\tcase sbmac_fc_collision:\t \n\t\tcase sbmac_fc_carrier:\t\t \n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\t \n\n\t__raw_writeq(cfg, s->sbm_maccfg);\n\n\treturn 1;\n}\n\n\n\n\n \nstatic irqreturn_t sbmac_intr(int irq,void *dev_instance)\n{\n\tstruct net_device *dev = (struct net_device *) dev_instance;\n\tstruct sbmac_softc *sc = netdev_priv(dev);\n\tuint64_t isr;\n\tint handled = 0;\n\n\t \n\n\tisr = __raw_readq(sc->sbm_isr) & ~M_MAC_COUNTER_ADDR;\n\n\tif (isr == 0)\n\t\treturn IRQ_RETVAL(0);\n\thandled = 1;\n\n\t \n\n\tif (isr & (M_MAC_INT_CHANNEL << S_MAC_TX_CH0))\n\t\tsbdma_tx_process(sc,&(sc->sbm_txdma), 0);\n\n\tif (isr & (M_MAC_INT_CHANNEL << S_MAC_RX_CH0)) {\n\t\tif (napi_schedule_prep(&sc->napi)) {\n\t\t\t__raw_writeq(0, sc->sbm_imr);\n\t\t\t__napi_schedule(&sc->napi);\n\t\t\t \n\t\t}\n\t\telse {\n\t\t\t \n\t\t\tsbdma_rx_process(sc,&(sc->sbm_rxdma),\n\t\t\t\t\t SBMAC_MAX_RXDESCR * 2, 0);\n\t\t}\n\t}\n\treturn IRQ_RETVAL(handled);\n}\n\n \nstatic netdev_tx_t sbmac_start_tx(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct sbmac_softc *sc = netdev_priv(dev);\n\tunsigned long flags;\n\n\t \n\tspin_lock_irqsave(&sc->sbm_lock, flags);\n\n\t \n\n\tif (sbdma_add_txbuffer(&(sc->sbm_txdma),skb)) {\n\t\t \n\t\tnetif_stop_queue(dev);\n\t\tspin_unlock_irqrestore(&sc->sbm_lock, flags);\n\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\n\tspin_unlock_irqrestore(&sc->sbm_lock, flags);\n\n\treturn NETDEV_TX_OK;\n}\n\n \n\nstatic void sbmac_setmulti(struct sbmac_softc *sc)\n{\n\tuint64_t reg;\n\tvoid __iomem *port;\n\tint idx;\n\tstruct netdev_hw_addr *ha;\n\tstruct net_device *dev = sc->sbm_dev;\n\n\t \n\n\tfor (idx = 1; idx < MAC_ADDR_COUNT; idx++) {\n\t\tport = sc->sbm_base + R_MAC_ADDR_BASE+(idx*sizeof(uint64_t));\n\t\t__raw_writeq(0, port);\n\t}\n\n\tfor (idx = 0; idx < MAC_HASH_COUNT; idx++) {\n\t\tport = sc->sbm_base + R_MAC_HASH_BASE+(idx*sizeof(uint64_t));\n\t\t__raw_writeq(0, port);\n\t}\n\n\t \n\n\treg = __raw_readq(sc->sbm_rxfilter);\n\treg &= ~(M_MAC_MCAST_INV | M_MAC_MCAST_EN);\n\t__raw_writeq(reg, sc->sbm_rxfilter);\n\n\tif (dev->flags & IFF_ALLMULTI) {\n\t\t \n\t\treg = __raw_readq(sc->sbm_rxfilter);\n\t\treg |= (M_MAC_MCAST_INV | M_MAC_MCAST_EN);\n\t\t__raw_writeq(reg, sc->sbm_rxfilter);\n\t\treturn;\n\t}\n\n\n\t \n\n\t \n\n\tidx = 1;\t\t \n\tnetdev_for_each_mc_addr(ha, dev) {\n\t\tif (idx == MAC_ADDR_COUNT)\n\t\t\tbreak;\n\t\treg = sbmac_addr2reg(ha->addr);\n\t\tport = sc->sbm_base + R_MAC_ADDR_BASE+(idx * sizeof(uint64_t));\n\t\t__raw_writeq(reg, port);\n\t\tidx++;\n\t}\n\n\t \n\n\tif (idx > 1) {\n\t\treg = __raw_readq(sc->sbm_rxfilter);\n\t\treg |= M_MAC_MCAST_EN;\n\t\t__raw_writeq(reg, sc->sbm_rxfilter);\n\t}\n}\n\nstatic const struct net_device_ops sbmac_netdev_ops = {\n\t.ndo_open\t\t= sbmac_open,\n\t.ndo_stop\t\t= sbmac_close,\n\t.ndo_start_xmit\t\t= sbmac_start_tx,\n\t.ndo_set_rx_mode\t= sbmac_set_rx_mode,\n\t.ndo_tx_timeout\t\t= sbmac_tx_timeout,\n\t.ndo_eth_ioctl\t\t= sbmac_mii_ioctl,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_set_mac_address\t= eth_mac_addr,\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\t.ndo_poll_controller\t= sbmac_netpoll,\n#endif\n};\n\n \n\nstatic int sbmac_init(struct platform_device *pldev, long long base)\n{\n\tstruct net_device *dev = platform_get_drvdata(pldev);\n\tint idx = pldev->id;\n\tstruct sbmac_softc *sc = netdev_priv(dev);\n\tunsigned char *eaddr;\n\tuint64_t ea_reg;\n\tint i;\n\tint err;\n\n\tsc->sbm_dev = dev;\n\tsc->sbe_idx = idx;\n\n\teaddr = sc->sbm_hwaddr;\n\n\t \n\n\tea_reg = __raw_readq(sc->sbm_base + R_MAC_ETHERNET_ADDR);\n\t__raw_writeq(0, sc->sbm_base + R_MAC_ETHERNET_ADDR);\n\tfor (i = 0; i < 6; i++) {\n\t\teaddr[i] = (uint8_t) (ea_reg & 0xFF);\n\t\tea_reg >>= 8;\n\t}\n\n\teth_hw_addr_set(dev, eaddr);\n\n\t \n\n\tsbmac_initctx(sc);\n\n\t \n\n\tspin_lock_init(&(sc->sbm_lock));\n\n\tdev->netdev_ops = &sbmac_netdev_ops;\n\tdev->watchdog_timeo = TX_TIMEOUT;\n\tdev->min_mtu = 0;\n\tdev->max_mtu = ENET_PACKET_SIZE;\n\n\tnetif_napi_add_weight(dev, &sc->napi, sbmac_poll, 16);\n\n\tdev->irq\t\t= UNIT_INT(idx);\n\n\t \n\tsbmac_set_iphdr_offset(sc);\n\n\tsc->mii_bus = mdiobus_alloc();\n\tif (sc->mii_bus == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto uninit_ctx;\n\t}\n\n\tsc->mii_bus->name = sbmac_mdio_string;\n\tsnprintf(sc->mii_bus->id, MII_BUS_ID_SIZE, \"%s-%x\",\n\t\tpldev->name, idx);\n\tsc->mii_bus->priv = sc;\n\tsc->mii_bus->read = sbmac_mii_read;\n\tsc->mii_bus->write = sbmac_mii_write;\n\n\tsc->mii_bus->parent = &pldev->dev;\n\t \n\terr = mdiobus_register(sc->mii_bus);\n\tif (err) {\n\t\tprintk(KERN_ERR \"%s: unable to register MDIO bus\\n\",\n\t\t       dev->name);\n\t\tgoto free_mdio;\n\t}\n\tplatform_set_drvdata(pldev, sc->mii_bus);\n\n\terr = register_netdev(dev);\n\tif (err) {\n\t\tprintk(KERN_ERR \"%s.%d: unable to register netdev\\n\",\n\t\t       sbmac_string, idx);\n\t\tgoto unreg_mdio;\n\t}\n\n\tpr_info(\"%s.%d: registered as %s\\n\", sbmac_string, idx, dev->name);\n\n\tif (sc->rx_hw_checksum == ENABLE)\n\t\tpr_info(\"%s: enabling TCP rcv checksum\\n\", dev->name);\n\n\t \n\tpr_info(\"%s: SiByte Ethernet at 0x%08Lx, address: %pM\\n\",\n\t       dev->name, base, eaddr);\n\n\treturn 0;\nunreg_mdio:\n\tmdiobus_unregister(sc->mii_bus);\nfree_mdio:\n\tmdiobus_free(sc->mii_bus);\nuninit_ctx:\n\tsbmac_uninitctx(sc);\n\treturn err;\n}\n\n\nstatic int sbmac_open(struct net_device *dev)\n{\n\tstruct sbmac_softc *sc = netdev_priv(dev);\n\tint err;\n\n\tif (debug > 1)\n\t\tpr_debug(\"%s: sbmac_open() irq %d.\\n\", dev->name, dev->irq);\n\n\t \n\n\t__raw_readq(sc->sbm_isr);\n\terr = request_irq(dev->irq, sbmac_intr, IRQF_SHARED, dev->name, dev);\n\tif (err) {\n\t\tprintk(KERN_ERR \"%s: unable to get IRQ %d\\n\", dev->name,\n\t\t       dev->irq);\n\t\tgoto out_err;\n\t}\n\n\tsc->sbm_speed = sbmac_speed_none;\n\tsc->sbm_duplex = sbmac_duplex_none;\n\tsc->sbm_fc = sbmac_fc_none;\n\tsc->sbm_pause = -1;\n\tsc->sbm_link = 0;\n\n\t \n\terr = sbmac_mii_probe(dev);\n\tif (err)\n\t\tgoto out_unregister;\n\n\t \n\n\tsbmac_set_channel_state(sc,sbmac_state_on);\n\n\tnetif_start_queue(dev);\n\n\tsbmac_set_rx_mode(dev);\n\n\tphy_start(sc->phy_dev);\n\n\tnapi_enable(&sc->napi);\n\n\treturn 0;\n\nout_unregister:\n\tfree_irq(dev->irq, dev);\nout_err:\n\treturn err;\n}\n\nstatic int sbmac_mii_probe(struct net_device *dev)\n{\n\tstruct sbmac_softc *sc = netdev_priv(dev);\n\tstruct phy_device *phy_dev;\n\n\tphy_dev = phy_find_first(sc->mii_bus);\n\tif (!phy_dev) {\n\t\tprintk(KERN_ERR \"%s: no PHY found\\n\", dev->name);\n\t\treturn -ENXIO;\n\t}\n\n\tphy_dev = phy_connect(dev, dev_name(&phy_dev->mdio.dev),\n\t\t\t      &sbmac_mii_poll, PHY_INTERFACE_MODE_GMII);\n\tif (IS_ERR(phy_dev)) {\n\t\tprintk(KERN_ERR \"%s: could not attach to PHY\\n\", dev->name);\n\t\treturn PTR_ERR(phy_dev);\n\t}\n\n\t \n\tphy_set_max_speed(phy_dev, SPEED_1000);\n\tphy_support_asym_pause(phy_dev);\n\n\tphy_attached_info(phy_dev);\n\n\tsc->phy_dev = phy_dev;\n\n\treturn 0;\n}\n\n\nstatic void sbmac_mii_poll(struct net_device *dev)\n{\n\tstruct sbmac_softc *sc = netdev_priv(dev);\n\tstruct phy_device *phy_dev = sc->phy_dev;\n\tunsigned long flags;\n\tenum sbmac_fc fc;\n\tint link_chg, speed_chg, duplex_chg, pause_chg, fc_chg;\n\n\tlink_chg = (sc->sbm_link != phy_dev->link);\n\tspeed_chg = (sc->sbm_speed != phy_dev->speed);\n\tduplex_chg = (sc->sbm_duplex != phy_dev->duplex);\n\tpause_chg = (sc->sbm_pause != phy_dev->pause);\n\n\tif (!link_chg && !speed_chg && !duplex_chg && !pause_chg)\n\t\treturn;\t\t\t\t\t \n\n\tif (!phy_dev->link) {\n\t\tif (link_chg) {\n\t\t\tsc->sbm_link = phy_dev->link;\n\t\t\tsc->sbm_speed = sbmac_speed_none;\n\t\t\tsc->sbm_duplex = sbmac_duplex_none;\n\t\t\tsc->sbm_fc = sbmac_fc_disabled;\n\t\t\tsc->sbm_pause = -1;\n\t\t\tpr_info(\"%s: link unavailable\\n\", dev->name);\n\t\t}\n\t\treturn;\n\t}\n\n\tif (phy_dev->duplex == DUPLEX_FULL) {\n\t\tif (phy_dev->pause)\n\t\t\tfc = sbmac_fc_frame;\n\t\telse\n\t\t\tfc = sbmac_fc_disabled;\n\t} else\n\t\tfc = sbmac_fc_collision;\n\tfc_chg = (sc->sbm_fc != fc);\n\n\tpr_info(\"%s: link available: %dbase-%cD\\n\", dev->name, phy_dev->speed,\n\t\tphy_dev->duplex == DUPLEX_FULL ? 'F' : 'H');\n\n\tspin_lock_irqsave(&sc->sbm_lock, flags);\n\n\tsc->sbm_speed = phy_dev->speed;\n\tsc->sbm_duplex = phy_dev->duplex;\n\tsc->sbm_fc = fc;\n\tsc->sbm_pause = phy_dev->pause;\n\tsc->sbm_link = phy_dev->link;\n\n\tif ((speed_chg || duplex_chg || fc_chg) &&\n\t    sc->sbm_state != sbmac_state_off) {\n\t\t \n\t\tif (debug > 1)\n\t\t\tpr_debug(\"%s: restarting channel \"\n\t\t\t\t \"because PHY state changed\\n\", dev->name);\n\t\tsbmac_channel_stop(sc);\n\t\tsbmac_channel_start(sc);\n\t}\n\n\tspin_unlock_irqrestore(&sc->sbm_lock, flags);\n}\n\n\nstatic void sbmac_tx_timeout (struct net_device *dev, unsigned int txqueue)\n{\n\tstruct sbmac_softc *sc = netdev_priv(dev);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&sc->sbm_lock, flags);\n\n\n\tnetif_trans_update(dev);  \n\tdev->stats.tx_errors++;\n\n\tspin_unlock_irqrestore(&sc->sbm_lock, flags);\n\n\tprintk (KERN_WARNING \"%s: Transmit timed out\\n\",dev->name);\n}\n\n\n\n\nstatic void sbmac_set_rx_mode(struct net_device *dev)\n{\n\tunsigned long flags;\n\tstruct sbmac_softc *sc = netdev_priv(dev);\n\n\tspin_lock_irqsave(&sc->sbm_lock, flags);\n\tif ((dev->flags ^ sc->sbm_devflags) & IFF_PROMISC) {\n\t\t \n\n\t\tif (dev->flags & IFF_PROMISC) {\n\t\t\tsbmac_promiscuous_mode(sc,1);\n\t\t}\n\t\telse {\n\t\t\tsbmac_promiscuous_mode(sc,0);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&sc->sbm_lock, flags);\n\n\t \n\n\tsbmac_setmulti(sc);\n\n}\n\nstatic int sbmac_mii_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)\n{\n\tstruct sbmac_softc *sc = netdev_priv(dev);\n\n\tif (!netif_running(dev) || !sc->phy_dev)\n\t\treturn -EINVAL;\n\n\treturn phy_mii_ioctl(sc->phy_dev, rq, cmd);\n}\n\nstatic int sbmac_close(struct net_device *dev)\n{\n\tstruct sbmac_softc *sc = netdev_priv(dev);\n\n\tnapi_disable(&sc->napi);\n\n\tphy_stop(sc->phy_dev);\n\n\tsbmac_set_channel_state(sc, sbmac_state_off);\n\n\tnetif_stop_queue(dev);\n\n\tif (debug > 1)\n\t\tpr_debug(\"%s: Shutting down ethercard\\n\", dev->name);\n\n\tphy_disconnect(sc->phy_dev);\n\tsc->phy_dev = NULL;\n\tfree_irq(dev->irq, dev);\n\n\tsbdma_emptyring(&(sc->sbm_txdma));\n\tsbdma_emptyring(&(sc->sbm_rxdma));\n\n\treturn 0;\n}\n\nstatic int sbmac_poll(struct napi_struct *napi, int budget)\n{\n\tstruct sbmac_softc *sc = container_of(napi, struct sbmac_softc, napi);\n\tint work_done;\n\n\twork_done = sbdma_rx_process(sc, &(sc->sbm_rxdma), budget, 1);\n\tsbdma_tx_process(sc, &(sc->sbm_txdma), 1);\n\n\tif (work_done < budget) {\n\t\tnapi_complete_done(napi, work_done);\n\n#ifdef CONFIG_SBMAC_COALESCE\n\t\t__raw_writeq(((M_MAC_INT_EOP_COUNT | M_MAC_INT_EOP_TIMER) << S_MAC_TX_CH0) |\n\t\t\t     ((M_MAC_INT_EOP_COUNT | M_MAC_INT_EOP_TIMER) << S_MAC_RX_CH0),\n\t\t\t     sc->sbm_imr);\n#else\n\t\t__raw_writeq((M_MAC_INT_CHANNEL << S_MAC_TX_CH0) |\n\t\t\t     (M_MAC_INT_CHANNEL << S_MAC_RX_CH0), sc->sbm_imr);\n#endif\n\t}\n\n\treturn work_done;\n}\n\n\nstatic int sbmac_probe(struct platform_device *pldev)\n{\n\tstruct net_device *dev;\n\tstruct sbmac_softc *sc;\n\tvoid __iomem *sbm_base;\n\tstruct resource *res;\n\tu64 sbmac_orig_hwaddr;\n\tint err;\n\n\tres = platform_get_resource(pldev, IORESOURCE_MEM, 0);\n\tif (!res) {\n\t\tprintk(KERN_ERR \"%s: failed to get resource\\n\",\n\t\t       dev_name(&pldev->dev));\n\t\terr = -EINVAL;\n\t\tgoto out_out;\n\t}\n\tsbm_base = ioremap(res->start, resource_size(res));\n\tif (!sbm_base) {\n\t\tprintk(KERN_ERR \"%s: unable to map device registers\\n\",\n\t\t       dev_name(&pldev->dev));\n\t\terr = -ENOMEM;\n\t\tgoto out_out;\n\t}\n\n\t \n\tsbmac_orig_hwaddr = __raw_readq(sbm_base + R_MAC_ETHERNET_ADDR);\n\tpr_debug(\"%s: %sconfiguring MAC at 0x%08Lx\\n\", dev_name(&pldev->dev),\n\t\t sbmac_orig_hwaddr ? \"\" : \"not \", (long long)res->start);\n\tif (sbmac_orig_hwaddr == 0) {\n\t\terr = 0;\n\t\tgoto out_unmap;\n\t}\n\n\t \n\tdev = alloc_etherdev(sizeof(struct sbmac_softc));\n\tif (!dev) {\n\t\terr = -ENOMEM;\n\t\tgoto out_unmap;\n\t}\n\n\tplatform_set_drvdata(pldev, dev);\n\tSET_NETDEV_DEV(dev, &pldev->dev);\n\n\tsc = netdev_priv(dev);\n\tsc->sbm_base = sbm_base;\n\n\terr = sbmac_init(pldev, res->start);\n\tif (err)\n\t\tgoto out_kfree;\n\n\treturn 0;\n\nout_kfree:\n\tfree_netdev(dev);\n\t__raw_writeq(sbmac_orig_hwaddr, sbm_base + R_MAC_ETHERNET_ADDR);\n\nout_unmap:\n\tiounmap(sbm_base);\n\nout_out:\n\treturn err;\n}\n\nstatic int sbmac_remove(struct platform_device *pldev)\n{\n\tstruct net_device *dev = platform_get_drvdata(pldev);\n\tstruct sbmac_softc *sc = netdev_priv(dev);\n\n\tunregister_netdev(dev);\n\tsbmac_uninitctx(sc);\n\tmdiobus_unregister(sc->mii_bus);\n\tmdiobus_free(sc->mii_bus);\n\tiounmap(sc->sbm_base);\n\tfree_netdev(dev);\n\n\treturn 0;\n}\n\nstatic struct platform_driver sbmac_driver = {\n\t.probe = sbmac_probe,\n\t.remove = sbmac_remove,\n\t.driver = {\n\t\t.name = sbmac_string,\n\t},\n};\n\nmodule_platform_driver(sbmac_driver);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}