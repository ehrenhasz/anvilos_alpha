{
  "module_name": "bcm4908_enet.c",
  "hash_id": "05afa2514c9341ba008852996129595af1ea0e2c13c375aae6daf2fe1dbd187f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/broadcom/bcm4908_enet.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/etherdevice.h>\n#include <linux/if_vlan.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_net.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\n#include \"bcm4908_enet.h\"\n#include \"unimac.h\"\n\n#define ENET_DMA_CH_RX_CFG\t\t\tENET_DMA_CH0_CFG\n#define ENET_DMA_CH_TX_CFG\t\t\tENET_DMA_CH1_CFG\n#define ENET_DMA_CH_RX_STATE_RAM\t\tENET_DMA_CH0_STATE_RAM\n#define ENET_DMA_CH_TX_STATE_RAM\t\tENET_DMA_CH1_STATE_RAM\n\n#define ENET_TX_BDS_NUM\t\t\t\t200\n#define ENET_RX_BDS_NUM\t\t\t\t200\n#define ENET_RX_BDS_NUM_MAX\t\t\t8192\n\n#define ENET_DMA_INT_DEFAULTS\t\t\t(ENET_DMA_CH_CFG_INT_DONE | \\\n\t\t\t\t\t\t ENET_DMA_CH_CFG_INT_NO_DESC | \\\n\t\t\t\t\t\t ENET_DMA_CH_CFG_INT_BUFF_DONE)\n#define ENET_DMA_MAX_BURST_LEN\t\t\t8  \n\n#define ENET_MTU_MAX\t\t\t\tETH_DATA_LEN  \n#define BRCM_MAX_TAG_LEN\t\t\t6\n#define ENET_MAX_ETH_OVERHEAD\t\t\t(ETH_HLEN + BRCM_MAX_TAG_LEN + VLAN_HLEN + \\\n\t\t\t\t\t\t ETH_FCS_LEN + 4)  \n\n#define ENET_RX_SKB_BUF_SIZE\t\t\t(NET_SKB_PAD + NET_IP_ALIGN + \\\n\t\t\t\t\t\t ETH_HLEN + BRCM_MAX_TAG_LEN + VLAN_HLEN + \\\n\t\t\t\t\t\t ENET_MTU_MAX + ETH_FCS_LEN + 4)\n#define ENET_RX_SKB_BUF_ALLOC_SIZE\t\t(SKB_DATA_ALIGN(ENET_RX_SKB_BUF_SIZE) + \\\n\t\t\t\t\t\t SKB_DATA_ALIGN(sizeof(struct skb_shared_info)))\n#define ENET_RX_BUF_DMA_OFFSET\t\t\t(NET_SKB_PAD + NET_IP_ALIGN)\n#define ENET_RX_BUF_DMA_SIZE\t\t\t(ENET_RX_SKB_BUF_SIZE - ENET_RX_BUF_DMA_OFFSET)\n\nstruct bcm4908_enet_dma_ring_bd {\n\t__le32 ctl;\n\t__le32 addr;\n} __packed;\n\nstruct bcm4908_enet_dma_ring_slot {\n\tunion {\n\t\tvoid *buf;\t\t\t \n\t\tstruct sk_buff *skb;\t\t \n\t};\n\tunsigned int len;\n\tdma_addr_t dma_addr;\n};\n\nstruct bcm4908_enet_dma_ring {\n\tint is_tx;\n\tint read_idx;\n\tint write_idx;\n\tint length;\n\tu16 cfg_block;\n\tu16 st_ram_block;\n\tstruct napi_struct napi;\n\n\tunion {\n\t\tvoid *cpu_addr;\n\t\tstruct bcm4908_enet_dma_ring_bd *buf_desc;\n\t};\n\tdma_addr_t dma_addr;\n\n\tstruct bcm4908_enet_dma_ring_slot *slots;\n};\n\nstruct bcm4908_enet {\n\tstruct device *dev;\n\tstruct net_device *netdev;\n\tvoid __iomem *base;\n\tint irq_tx;\n\n\tstruct bcm4908_enet_dma_ring tx_ring;\n\tstruct bcm4908_enet_dma_ring rx_ring;\n};\n\n \n\nstatic u32 enet_read(struct bcm4908_enet *enet, u16 offset)\n{\n\treturn readl(enet->base + offset);\n}\n\nstatic void enet_write(struct bcm4908_enet *enet, u16 offset, u32 value)\n{\n\twritel(value, enet->base + offset);\n}\n\nstatic void enet_maskset(struct bcm4908_enet *enet, u16 offset, u32 mask, u32 set)\n{\n\tu32 val;\n\n\tWARN_ON(set & ~mask);\n\n\tval = enet_read(enet, offset);\n\tval = (val & ~mask) | (set & mask);\n\tenet_write(enet, offset, val);\n}\n\nstatic void enet_set(struct bcm4908_enet *enet, u16 offset, u32 set)\n{\n\tenet_maskset(enet, offset, set, set);\n}\n\nstatic u32 enet_umac_read(struct bcm4908_enet *enet, u16 offset)\n{\n\treturn enet_read(enet, ENET_UNIMAC + offset);\n}\n\nstatic void enet_umac_write(struct bcm4908_enet *enet, u16 offset, u32 value)\n{\n\tenet_write(enet, ENET_UNIMAC + offset, value);\n}\n\nstatic void enet_umac_set(struct bcm4908_enet *enet, u16 offset, u32 set)\n{\n\tenet_set(enet, ENET_UNIMAC + offset, set);\n}\n\n \n\nstatic void bcm4908_enet_set_mtu(struct bcm4908_enet *enet, int mtu)\n{\n\tenet_umac_write(enet, UMAC_MAX_FRAME_LEN, mtu + ENET_MAX_ETH_OVERHEAD);\n}\n\n \n\nstatic void bcm4908_enet_dma_ring_intrs_on(struct bcm4908_enet *enet,\n\t\t\t\t\t   struct bcm4908_enet_dma_ring *ring)\n{\n\tenet_write(enet, ring->cfg_block + ENET_DMA_CH_CFG_INT_MASK, ENET_DMA_INT_DEFAULTS);\n}\n\nstatic void bcm4908_enet_dma_ring_intrs_off(struct bcm4908_enet *enet,\n\t\t\t\t\t    struct bcm4908_enet_dma_ring *ring)\n{\n\tenet_write(enet, ring->cfg_block + ENET_DMA_CH_CFG_INT_MASK, 0);\n}\n\nstatic void bcm4908_enet_dma_ring_intrs_ack(struct bcm4908_enet *enet,\n\t\t\t\t\t    struct bcm4908_enet_dma_ring *ring)\n{\n\tenet_write(enet, ring->cfg_block + ENET_DMA_CH_CFG_INT_STAT, ENET_DMA_INT_DEFAULTS);\n}\n\n \n\nstatic int bcm4908_dma_alloc_buf_descs(struct bcm4908_enet *enet,\n\t\t\t\t       struct bcm4908_enet_dma_ring *ring)\n{\n\tint size = ring->length * sizeof(struct bcm4908_enet_dma_ring_bd);\n\tstruct device *dev = enet->dev;\n\n\tring->cpu_addr = dma_alloc_coherent(dev, size, &ring->dma_addr, GFP_KERNEL);\n\tif (!ring->cpu_addr)\n\t\treturn -ENOMEM;\n\n\tif (((uintptr_t)ring->cpu_addr) & (0x40 - 1)) {\n\t\tdev_err(dev, \"Invalid DMA ring alignment\\n\");\n\t\tgoto err_free_buf_descs;\n\t}\n\n\tring->slots = kcalloc(ring->length, sizeof(*ring->slots), GFP_KERNEL);\n\tif (!ring->slots)\n\t\tgoto err_free_buf_descs;\n\n\treturn 0;\n\nerr_free_buf_descs:\n\tdma_free_coherent(dev, size, ring->cpu_addr, ring->dma_addr);\n\tring->cpu_addr = NULL;\n\treturn -ENOMEM;\n}\n\nstatic void bcm4908_enet_dma_free(struct bcm4908_enet *enet)\n{\n\tstruct bcm4908_enet_dma_ring *tx_ring = &enet->tx_ring;\n\tstruct bcm4908_enet_dma_ring *rx_ring = &enet->rx_ring;\n\tstruct device *dev = enet->dev;\n\tint size;\n\n\tsize = rx_ring->length * sizeof(struct bcm4908_enet_dma_ring_bd);\n\tif (rx_ring->cpu_addr)\n\t\tdma_free_coherent(dev, size, rx_ring->cpu_addr, rx_ring->dma_addr);\n\tkfree(rx_ring->slots);\n\n\tsize = tx_ring->length * sizeof(struct bcm4908_enet_dma_ring_bd);\n\tif (tx_ring->cpu_addr)\n\t\tdma_free_coherent(dev, size, tx_ring->cpu_addr, tx_ring->dma_addr);\n\tkfree(tx_ring->slots);\n}\n\nstatic int bcm4908_enet_dma_alloc(struct bcm4908_enet *enet)\n{\n\tstruct bcm4908_enet_dma_ring *tx_ring = &enet->tx_ring;\n\tstruct bcm4908_enet_dma_ring *rx_ring = &enet->rx_ring;\n\tstruct device *dev = enet->dev;\n\tint err;\n\n\ttx_ring->length = ENET_TX_BDS_NUM;\n\ttx_ring->is_tx = 1;\n\ttx_ring->cfg_block = ENET_DMA_CH_TX_CFG;\n\ttx_ring->st_ram_block = ENET_DMA_CH_TX_STATE_RAM;\n\terr = bcm4908_dma_alloc_buf_descs(enet, tx_ring);\n\tif (err) {\n\t\tdev_err(dev, \"Failed to alloc TX buf descriptors: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\trx_ring->length = ENET_RX_BDS_NUM;\n\trx_ring->is_tx = 0;\n\trx_ring->cfg_block = ENET_DMA_CH_RX_CFG;\n\trx_ring->st_ram_block = ENET_DMA_CH_RX_STATE_RAM;\n\terr = bcm4908_dma_alloc_buf_descs(enet, rx_ring);\n\tif (err) {\n\t\tdev_err(dev, \"Failed to alloc RX buf descriptors: %d\\n\", err);\n\t\tbcm4908_enet_dma_free(enet);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic void bcm4908_enet_dma_reset(struct bcm4908_enet *enet)\n{\n\tstruct bcm4908_enet_dma_ring *rings[] = { &enet->rx_ring, &enet->tx_ring };\n\tint i;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(rings); i++)\n\t\tenet_write(enet, rings[i]->cfg_block + ENET_DMA_CH_CFG, 0);\n\tenet_maskset(enet, ENET_DMA_CONTROLLER_CFG, ENET_DMA_CTRL_CFG_MASTER_EN, 0);\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(rings); i++) {\n\t\tstruct bcm4908_enet_dma_ring *ring = rings[i];\n\n\t\tenet_write(enet, ring->st_ram_block + ENET_DMA_CH_STATE_RAM_BASE_DESC_PTR, 0);\n\t\tenet_write(enet, ring->st_ram_block + ENET_DMA_CH_STATE_RAM_STATE_DATA, 0);\n\t\tenet_write(enet, ring->st_ram_block + ENET_DMA_CH_STATE_RAM_DESC_LEN_STATUS, 0);\n\t\tenet_write(enet, ring->st_ram_block + ENET_DMA_CH_STATE_RAM_DESC_BASE_BUFPTR, 0);\n\t}\n}\n\nstatic int bcm4908_enet_dma_alloc_rx_buf(struct bcm4908_enet *enet, unsigned int idx)\n{\n\tstruct bcm4908_enet_dma_ring_bd *buf_desc = &enet->rx_ring.buf_desc[idx];\n\tstruct bcm4908_enet_dma_ring_slot *slot = &enet->rx_ring.slots[idx];\n\tstruct device *dev = enet->dev;\n\tu32 tmp;\n\tint err;\n\n\tslot->buf = napi_alloc_frag(ENET_RX_SKB_BUF_ALLOC_SIZE);\n\tif (!slot->buf)\n\t\treturn -ENOMEM;\n\n\tslot->dma_addr = dma_map_single(dev, slot->buf + ENET_RX_BUF_DMA_OFFSET,\n\t\t\t\t\tENET_RX_BUF_DMA_SIZE, DMA_FROM_DEVICE);\n\terr = dma_mapping_error(dev, slot->dma_addr);\n\tif (err) {\n\t\tdev_err(dev, \"Failed to map DMA buffer: %d\\n\", err);\n\t\tskb_free_frag(slot->buf);\n\t\tslot->buf = NULL;\n\t\treturn err;\n\t}\n\n\ttmp = ENET_RX_BUF_DMA_SIZE << DMA_CTL_LEN_DESC_BUFLENGTH_SHIFT;\n\ttmp |= DMA_CTL_STATUS_OWN;\n\tif (idx == enet->rx_ring.length - 1)\n\t\ttmp |= DMA_CTL_STATUS_WRAP;\n\tbuf_desc->ctl = cpu_to_le32(tmp);\n\tbuf_desc->addr = cpu_to_le32(slot->dma_addr);\n\n\treturn 0;\n}\n\nstatic void bcm4908_enet_dma_ring_init(struct bcm4908_enet *enet,\n\t\t\t\t       struct bcm4908_enet_dma_ring *ring)\n{\n\tint reset_channel = 0;  \n\tint reset_subch = ring->is_tx ? 1 : 0;\n\n\t \n\tenet_write(enet, ENET_DMA_CTRL_CHANNEL_RESET, BIT(reset_channel * 2 + reset_subch));\n\tenet_write(enet, ENET_DMA_CTRL_CHANNEL_RESET, 0);\n\n\tenet_write(enet, ring->cfg_block + ENET_DMA_CH_CFG, 0);\n\tenet_write(enet, ring->cfg_block + ENET_DMA_CH_CFG_MAX_BURST, ENET_DMA_MAX_BURST_LEN);\n\tenet_write(enet, ring->cfg_block + ENET_DMA_CH_CFG_INT_MASK, 0);\n\n\tenet_write(enet, ring->st_ram_block + ENET_DMA_CH_STATE_RAM_BASE_DESC_PTR,\n\t\t   (uint32_t)ring->dma_addr);\n\n\tring->read_idx = 0;\n\tring->write_idx = 0;\n}\n\nstatic void bcm4908_enet_dma_uninit(struct bcm4908_enet *enet)\n{\n\tstruct bcm4908_enet_dma_ring *rx_ring = &enet->rx_ring;\n\tstruct bcm4908_enet_dma_ring_slot *slot;\n\tstruct device *dev = enet->dev;\n\tint i;\n\n\tfor (i = rx_ring->length - 1; i >= 0; i--) {\n\t\tslot = &rx_ring->slots[i];\n\t\tif (!slot->buf)\n\t\t\tcontinue;\n\t\tdma_unmap_single(dev, slot->dma_addr, slot->len, DMA_FROM_DEVICE);\n\t\tskb_free_frag(slot->buf);\n\t\tslot->buf = NULL;\n\t}\n}\n\nstatic int bcm4908_enet_dma_init(struct bcm4908_enet *enet)\n{\n\tstruct bcm4908_enet_dma_ring *rx_ring = &enet->rx_ring;\n\tstruct device *dev = enet->dev;\n\tint err;\n\tint i;\n\n\tfor (i = 0; i < rx_ring->length; i++) {\n\t\terr = bcm4908_enet_dma_alloc_rx_buf(enet, i);\n\t\tif (err) {\n\t\t\tdev_err(dev, \"Failed to alloc RX buffer: %d\\n\", err);\n\t\t\tbcm4908_enet_dma_uninit(enet);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tbcm4908_enet_dma_ring_init(enet, &enet->tx_ring);\n\tbcm4908_enet_dma_ring_init(enet, &enet->rx_ring);\n\n\treturn 0;\n}\n\nstatic void bcm4908_enet_dma_tx_ring_enable(struct bcm4908_enet *enet,\n\t\t\t\t\t    struct bcm4908_enet_dma_ring *ring)\n{\n\tenet_write(enet, ring->cfg_block + ENET_DMA_CH_CFG, ENET_DMA_CH_CFG_ENABLE);\n}\n\nstatic void bcm4908_enet_dma_tx_ring_disable(struct bcm4908_enet *enet,\n\t\t\t\t\t     struct bcm4908_enet_dma_ring *ring)\n{\n\tenet_write(enet, ring->cfg_block + ENET_DMA_CH_CFG, 0);\n}\n\nstatic void bcm4908_enet_dma_rx_ring_enable(struct bcm4908_enet *enet,\n\t\t\t\t\t    struct bcm4908_enet_dma_ring *ring)\n{\n\tenet_set(enet, ring->cfg_block + ENET_DMA_CH_CFG, ENET_DMA_CH_CFG_ENABLE);\n}\n\nstatic void bcm4908_enet_dma_rx_ring_disable(struct bcm4908_enet *enet,\n\t\t\t\t\t     struct bcm4908_enet_dma_ring *ring)\n{\n\tunsigned long deadline;\n\tu32 tmp;\n\n\tenet_maskset(enet, ring->cfg_block + ENET_DMA_CH_CFG, ENET_DMA_CH_CFG_ENABLE, 0);\n\n\tdeadline = jiffies + usecs_to_jiffies(2000);\n\tdo {\n\t\ttmp = enet_read(enet, ring->cfg_block + ENET_DMA_CH_CFG);\n\t\tif (!(tmp & ENET_DMA_CH_CFG_ENABLE))\n\t\t\treturn;\n\t\tenet_maskset(enet, ring->cfg_block + ENET_DMA_CH_CFG, ENET_DMA_CH_CFG_ENABLE, 0);\n\t\tusleep_range(10, 30);\n\t} while (!time_after_eq(jiffies, deadline));\n\n\tdev_warn(enet->dev, \"Timeout waiting for DMA TX stop\\n\");\n}\n\n \n\nstatic void bcm4908_enet_gmac_init(struct bcm4908_enet *enet)\n{\n\tu32 cmd;\n\n\tbcm4908_enet_set_mtu(enet, enet->netdev->mtu);\n\n\tcmd = enet_umac_read(enet, UMAC_CMD);\n\tenet_umac_write(enet, UMAC_CMD, cmd | CMD_SW_RESET);\n\tenet_umac_write(enet, UMAC_CMD, cmd & ~CMD_SW_RESET);\n\n\tenet_set(enet, ENET_FLUSH, ENET_FLUSH_RXFIFO_FLUSH | ENET_FLUSH_TXFIFO_FLUSH);\n\tenet_maskset(enet, ENET_FLUSH, ENET_FLUSH_RXFIFO_FLUSH | ENET_FLUSH_TXFIFO_FLUSH, 0);\n\n\tenet_set(enet, ENET_MIB_CTRL, ENET_MIB_CTRL_CLR_MIB);\n\tenet_maskset(enet, ENET_MIB_CTRL, ENET_MIB_CTRL_CLR_MIB, 0);\n\n\tcmd = enet_umac_read(enet, UMAC_CMD);\n\tcmd &= ~(CMD_SPEED_MASK << CMD_SPEED_SHIFT);\n\tcmd &= ~CMD_TX_EN;\n\tcmd &= ~CMD_RX_EN;\n\tcmd |= CMD_SPEED_1000 << CMD_SPEED_SHIFT;\n\tenet_umac_write(enet, UMAC_CMD, cmd);\n\n\tenet_maskset(enet, ENET_GMAC_STATUS,\n\t\t     ENET_GMAC_STATUS_ETH_SPEED_MASK |\n\t\t     ENET_GMAC_STATUS_HD |\n\t\t     ENET_GMAC_STATUS_AUTO_CFG_EN |\n\t\t     ENET_GMAC_STATUS_LINK_UP,\n\t\t     ENET_GMAC_STATUS_ETH_SPEED_1000 |\n\t\t     ENET_GMAC_STATUS_AUTO_CFG_EN |\n\t\t     ENET_GMAC_STATUS_LINK_UP);\n}\n\nstatic irqreturn_t bcm4908_enet_irq_handler(int irq, void *dev_id)\n{\n\tstruct bcm4908_enet *enet = dev_id;\n\tstruct bcm4908_enet_dma_ring *ring;\n\n\tring = (irq == enet->irq_tx) ? &enet->tx_ring : &enet->rx_ring;\n\n\tbcm4908_enet_dma_ring_intrs_off(enet, ring);\n\tbcm4908_enet_dma_ring_intrs_ack(enet, ring);\n\n\tnapi_schedule(&ring->napi);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int bcm4908_enet_open(struct net_device *netdev)\n{\n\tstruct bcm4908_enet *enet = netdev_priv(netdev);\n\tstruct bcm4908_enet_dma_ring *tx_ring = &enet->tx_ring;\n\tstruct bcm4908_enet_dma_ring *rx_ring = &enet->rx_ring;\n\tstruct device *dev = enet->dev;\n\tint err;\n\n\terr = request_irq(netdev->irq, bcm4908_enet_irq_handler, 0, \"enet\", enet);\n\tif (err) {\n\t\tdev_err(dev, \"Failed to request IRQ %d: %d\\n\", netdev->irq, err);\n\t\treturn err;\n\t}\n\n\tif (enet->irq_tx > 0) {\n\t\terr = request_irq(enet->irq_tx, bcm4908_enet_irq_handler, 0,\n\t\t\t\t  \"tx\", enet);\n\t\tif (err) {\n\t\t\tdev_err(dev, \"Failed to request IRQ %d: %d\\n\",\n\t\t\t\tenet->irq_tx, err);\n\t\t\tfree_irq(netdev->irq, enet);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tbcm4908_enet_gmac_init(enet);\n\tbcm4908_enet_dma_reset(enet);\n\tbcm4908_enet_dma_init(enet);\n\n\tenet_umac_set(enet, UMAC_CMD, CMD_TX_EN | CMD_RX_EN);\n\n\tenet_set(enet, ENET_DMA_CONTROLLER_CFG, ENET_DMA_CTRL_CFG_MASTER_EN);\n\tenet_maskset(enet, ENET_DMA_CONTROLLER_CFG, ENET_DMA_CTRL_CFG_FLOWC_CH1_EN, 0);\n\n\tif (enet->irq_tx > 0) {\n\t\tnapi_enable(&tx_ring->napi);\n\t\tbcm4908_enet_dma_ring_intrs_ack(enet, tx_ring);\n\t\tbcm4908_enet_dma_ring_intrs_on(enet, tx_ring);\n\t}\n\n\tbcm4908_enet_dma_rx_ring_enable(enet, rx_ring);\n\tnapi_enable(&rx_ring->napi);\n\tnetif_carrier_on(netdev);\n\tnetif_start_queue(netdev);\n\tbcm4908_enet_dma_ring_intrs_ack(enet, rx_ring);\n\tbcm4908_enet_dma_ring_intrs_on(enet, rx_ring);\n\n\treturn 0;\n}\n\nstatic int bcm4908_enet_stop(struct net_device *netdev)\n{\n\tstruct bcm4908_enet *enet = netdev_priv(netdev);\n\tstruct bcm4908_enet_dma_ring *tx_ring = &enet->tx_ring;\n\tstruct bcm4908_enet_dma_ring *rx_ring = &enet->rx_ring;\n\n\tnetif_stop_queue(netdev);\n\tnetif_carrier_off(netdev);\n\tnapi_disable(&rx_ring->napi);\n\tnapi_disable(&tx_ring->napi);\n\tnetdev_reset_queue(netdev);\n\n\tbcm4908_enet_dma_rx_ring_disable(enet, &enet->rx_ring);\n\tbcm4908_enet_dma_tx_ring_disable(enet, &enet->tx_ring);\n\n\tbcm4908_enet_dma_uninit(enet);\n\n\tfree_irq(enet->irq_tx, enet);\n\tfree_irq(enet->netdev->irq, enet);\n\n\treturn 0;\n}\n\nstatic netdev_tx_t bcm4908_enet_start_xmit(struct sk_buff *skb, struct net_device *netdev)\n{\n\tstruct bcm4908_enet *enet = netdev_priv(netdev);\n\tstruct bcm4908_enet_dma_ring *ring = &enet->tx_ring;\n\tstruct bcm4908_enet_dma_ring_slot *slot;\n\tstruct device *dev = enet->dev;\n\tstruct bcm4908_enet_dma_ring_bd *buf_desc;\n\tint free_buf_descs;\n\tu32 tmp;\n\n\t \n\tif (enet->irq_tx < 0 &&\n\t    !(le32_to_cpu(ring->buf_desc[ring->read_idx].ctl) & DMA_CTL_STATUS_OWN))\n\t\tnapi_schedule(&enet->tx_ring.napi);\n\n\t \n\tif (ring->read_idx <= ring->write_idx)\n\t\tfree_buf_descs = ring->read_idx - ring->write_idx + ring->length;\n\telse\n\t\tfree_buf_descs = ring->read_idx - ring->write_idx;\n\tif (free_buf_descs < 2) {\n\t\tnetif_stop_queue(netdev);\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\n\t \n\tbuf_desc = &ring->buf_desc[ring->write_idx];\n\tif (unlikely(le32_to_cpu(buf_desc->ctl) & DMA_CTL_STATUS_OWN)) {\n\t\tnetif_stop_queue(netdev);\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\n\tslot = &ring->slots[ring->write_idx];\n\tslot->skb = skb;\n\tslot->len = skb->len;\n\tslot->dma_addr = dma_map_single(dev, skb->data, skb->len, DMA_TO_DEVICE);\n\tif (unlikely(dma_mapping_error(dev, slot->dma_addr)))\n\t\treturn NETDEV_TX_BUSY;\n\n\ttmp = skb->len << DMA_CTL_LEN_DESC_BUFLENGTH_SHIFT;\n\ttmp |= DMA_CTL_STATUS_OWN;\n\ttmp |= DMA_CTL_STATUS_SOP;\n\ttmp |= DMA_CTL_STATUS_EOP;\n\ttmp |= DMA_CTL_STATUS_APPEND_CRC;\n\tif (ring->write_idx + 1 == ring->length - 1)\n\t\ttmp |= DMA_CTL_STATUS_WRAP;\n\n\tnetdev_sent_queue(enet->netdev, skb->len);\n\n\tbuf_desc->addr = cpu_to_le32((uint32_t)slot->dma_addr);\n\tbuf_desc->ctl = cpu_to_le32(tmp);\n\n\tbcm4908_enet_dma_tx_ring_enable(enet, &enet->tx_ring);\n\n\tif (++ring->write_idx == ring->length - 1)\n\t\tring->write_idx = 0;\n\n\treturn NETDEV_TX_OK;\n}\n\nstatic int bcm4908_enet_poll_rx(struct napi_struct *napi, int weight)\n{\n\tstruct bcm4908_enet_dma_ring *rx_ring = container_of(napi, struct bcm4908_enet_dma_ring, napi);\n\tstruct bcm4908_enet *enet = container_of(rx_ring, struct bcm4908_enet, rx_ring);\n\tstruct device *dev = enet->dev;\n\tint handled = 0;\n\n\twhile (handled < weight) {\n\t\tstruct bcm4908_enet_dma_ring_bd *buf_desc;\n\t\tstruct bcm4908_enet_dma_ring_slot slot;\n\t\tstruct sk_buff *skb;\n\t\tu32 ctl;\n\t\tint len;\n\t\tint err;\n\n\t\tbuf_desc = &enet->rx_ring.buf_desc[enet->rx_ring.read_idx];\n\t\tctl = le32_to_cpu(buf_desc->ctl);\n\t\tif (ctl & DMA_CTL_STATUS_OWN)\n\t\t\tbreak;\n\n\t\tslot = enet->rx_ring.slots[enet->rx_ring.read_idx];\n\n\t\t \n\t\terr = bcm4908_enet_dma_alloc_rx_buf(enet, enet->rx_ring.read_idx);\n\t\tif (err)\n\t\t\tbreak;\n\n\t\tif (++enet->rx_ring.read_idx == enet->rx_ring.length)\n\t\t\tenet->rx_ring.read_idx = 0;\n\n\t\tlen = (ctl & DMA_CTL_LEN_DESC_BUFLENGTH) >> DMA_CTL_LEN_DESC_BUFLENGTH_SHIFT;\n\n\t\tif (len < ETH_ZLEN ||\n\t\t    (ctl & (DMA_CTL_STATUS_SOP | DMA_CTL_STATUS_EOP)) != (DMA_CTL_STATUS_SOP | DMA_CTL_STATUS_EOP)) {\n\t\t\tskb_free_frag(slot.buf);\n\t\t\tenet->netdev->stats.rx_dropped++;\n\t\t\tbreak;\n\t\t}\n\n\t\tdma_unmap_single(dev, slot.dma_addr, ENET_RX_BUF_DMA_SIZE, DMA_FROM_DEVICE);\n\n\t\tskb = build_skb(slot.buf, ENET_RX_SKB_BUF_ALLOC_SIZE);\n\t\tif (unlikely(!skb)) {\n\t\t\tskb_free_frag(slot.buf);\n\t\t\tenet->netdev->stats.rx_dropped++;\n\t\t\tbreak;\n\t\t}\n\t\tskb_reserve(skb, ENET_RX_BUF_DMA_OFFSET);\n\t\tskb_put(skb, len - ETH_FCS_LEN);\n\t\tskb->protocol = eth_type_trans(skb, enet->netdev);\n\n\t\tnetif_receive_skb(skb);\n\n\t\tenet->netdev->stats.rx_packets++;\n\t\tenet->netdev->stats.rx_bytes += len;\n\n\t\thandled++;\n\t}\n\n\tif (handled < weight) {\n\t\tnapi_complete_done(napi, handled);\n\t\tbcm4908_enet_dma_ring_intrs_on(enet, rx_ring);\n\t}\n\n\t \n\tbcm4908_enet_dma_rx_ring_enable(enet, &enet->rx_ring);\n\n\treturn handled;\n}\n\nstatic int bcm4908_enet_poll_tx(struct napi_struct *napi, int weight)\n{\n\tstruct bcm4908_enet_dma_ring *tx_ring = container_of(napi, struct bcm4908_enet_dma_ring, napi);\n\tstruct bcm4908_enet *enet = container_of(tx_ring, struct bcm4908_enet, tx_ring);\n\tstruct bcm4908_enet_dma_ring_bd *buf_desc;\n\tstruct bcm4908_enet_dma_ring_slot *slot;\n\tstruct device *dev = enet->dev;\n\tunsigned int bytes = 0;\n\tint handled = 0;\n\n\twhile (handled < weight && tx_ring->read_idx != tx_ring->write_idx) {\n\t\tbuf_desc = &tx_ring->buf_desc[tx_ring->read_idx];\n\t\tif (le32_to_cpu(buf_desc->ctl) & DMA_CTL_STATUS_OWN)\n\t\t\tbreak;\n\t\tslot = &tx_ring->slots[tx_ring->read_idx];\n\n\t\tdma_unmap_single(dev, slot->dma_addr, slot->len, DMA_TO_DEVICE);\n\t\tdev_kfree_skb(slot->skb);\n\n\t\thandled++;\n\t\tbytes += slot->len;\n\n\t\tif (++tx_ring->read_idx == tx_ring->length)\n\t\t\ttx_ring->read_idx = 0;\n\t}\n\n\tnetdev_completed_queue(enet->netdev, handled, bytes);\n\tenet->netdev->stats.tx_packets += handled;\n\tenet->netdev->stats.tx_bytes += bytes;\n\n\tif (handled < weight) {\n\t\tnapi_complete_done(napi, handled);\n\t\tbcm4908_enet_dma_ring_intrs_on(enet, tx_ring);\n\t}\n\n\tif (netif_queue_stopped(enet->netdev))\n\t\tnetif_wake_queue(enet->netdev);\n\n\treturn handled;\n}\n\nstatic int bcm4908_enet_change_mtu(struct net_device *netdev, int new_mtu)\n{\n\tstruct bcm4908_enet *enet = netdev_priv(netdev);\n\n\tbcm4908_enet_set_mtu(enet, new_mtu);\n\n\treturn 0;\n}\n\nstatic const struct net_device_ops bcm4908_enet_netdev_ops = {\n\t.ndo_open = bcm4908_enet_open,\n\t.ndo_stop = bcm4908_enet_stop,\n\t.ndo_start_xmit = bcm4908_enet_start_xmit,\n\t.ndo_set_mac_address = eth_mac_addr,\n\t.ndo_change_mtu = bcm4908_enet_change_mtu,\n};\n\nstatic int bcm4908_enet_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct net_device *netdev;\n\tstruct bcm4908_enet *enet;\n\tint err;\n\n\tnetdev = devm_alloc_etherdev(dev, sizeof(*enet));\n\tif (!netdev)\n\t\treturn -ENOMEM;\n\n\tenet = netdev_priv(netdev);\n\tenet->dev = dev;\n\tenet->netdev = netdev;\n\n\tenet->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(enet->base)) {\n\t\tdev_err(dev, \"Failed to map registers: %ld\\n\", PTR_ERR(enet->base));\n\t\treturn PTR_ERR(enet->base);\n\t}\n\n\tnetdev->irq = platform_get_irq_byname(pdev, \"rx\");\n\tif (netdev->irq < 0)\n\t\treturn netdev->irq;\n\n\tenet->irq_tx = platform_get_irq_byname(pdev, \"tx\");\n\n\terr = dma_set_coherent_mask(dev, DMA_BIT_MASK(32));\n\tif (err)\n\t\treturn err;\n\n\terr = bcm4908_enet_dma_alloc(enet);\n\tif (err)\n\t\treturn err;\n\n\tSET_NETDEV_DEV(netdev, &pdev->dev);\n\terr = of_get_ethdev_address(dev->of_node, netdev);\n\tif (err == -EPROBE_DEFER)\n\t\tgoto err_dma_free;\n\tif (err)\n\t\teth_hw_addr_random(netdev);\n\tnetdev->netdev_ops = &bcm4908_enet_netdev_ops;\n\tnetdev->min_mtu = ETH_ZLEN;\n\tnetdev->mtu = ETH_DATA_LEN;\n\tnetdev->max_mtu = ENET_MTU_MAX;\n\tnetif_napi_add_tx(netdev, &enet->tx_ring.napi, bcm4908_enet_poll_tx);\n\tnetif_napi_add(netdev, &enet->rx_ring.napi, bcm4908_enet_poll_rx);\n\n\terr = register_netdev(netdev);\n\tif (err)\n\t\tgoto err_dma_free;\n\n\tplatform_set_drvdata(pdev, enet);\n\n\treturn 0;\n\nerr_dma_free:\n\tbcm4908_enet_dma_free(enet);\n\n\treturn err;\n}\n\nstatic int bcm4908_enet_remove(struct platform_device *pdev)\n{\n\tstruct bcm4908_enet *enet = platform_get_drvdata(pdev);\n\n\tunregister_netdev(enet->netdev);\n\tnetif_napi_del(&enet->rx_ring.napi);\n\tnetif_napi_del(&enet->tx_ring.napi);\n\tbcm4908_enet_dma_free(enet);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id bcm4908_enet_of_match[] = {\n\t{ .compatible = \"brcm,bcm4908-enet\"},\n\t{},\n};\n\nstatic struct platform_driver bcm4908_enet_driver = {\n\t.driver = {\n\t\t.name = \"bcm4908_enet\",\n\t\t.of_match_table = bcm4908_enet_of_match,\n\t},\n\t.probe\t= bcm4908_enet_probe,\n\t.remove = bcm4908_enet_remove,\n};\nmodule_platform_driver(bcm4908_enet_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DEVICE_TABLE(of, bcm4908_enet_of_match);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}