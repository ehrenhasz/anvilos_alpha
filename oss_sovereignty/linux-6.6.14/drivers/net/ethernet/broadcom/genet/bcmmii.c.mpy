{
  "module_name": "bcmmii.c",
  "hash_id": "9d5eaac9493e55f32ab2f41e34992702e59ef9d455409b2101cc4b99021af427",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/broadcom/genet/bcmmii.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/types.h>\n#include <linux/delay.h>\n#include <linux/wait.h>\n#include <linux/mii.h>\n#include <linux/ethtool.h>\n#include <linux/bitops.h>\n#include <linux/netdevice.h>\n#include <linux/platform_device.h>\n#include <linux/phy.h>\n#include <linux/phy_fixed.h>\n#include <linux/brcmphy.h>\n#include <linux/of.h>\n#include <linux/of_net.h>\n#include <linux/of_mdio.h>\n#include <linux/platform_data/bcmgenet.h>\n#include <linux/platform_data/mdio-bcm-unimac.h>\n\n#include \"bcmgenet.h\"\n\nstatic void bcmgenet_mac_config(struct net_device *dev)\n{\n\tstruct bcmgenet_priv *priv = netdev_priv(dev);\n\tstruct phy_device *phydev = dev->phydev;\n\tu32 reg, cmd_bits = 0;\n\n\t \n\tif (phydev->speed == SPEED_1000)\n\t\tcmd_bits = CMD_SPEED_1000;\n\telse if (phydev->speed == SPEED_100)\n\t\tcmd_bits = CMD_SPEED_100;\n\telse\n\t\tcmd_bits = CMD_SPEED_10;\n\tcmd_bits <<= CMD_SPEED_SHIFT;\n\n\t \n\tif (phydev->duplex != DUPLEX_FULL) {\n\t\tcmd_bits |= CMD_HD_EN |\n\t\t\tCMD_RX_PAUSE_IGNORE | CMD_TX_PAUSE_IGNORE;\n\t} else {\n\t\t \n\t\tif (priv->autoneg_pause) {\n\t\t\tbool tx_pause = 0, rx_pause = 0;\n\n\t\t\tif (phydev->autoneg)\n\t\t\t\tphy_get_pause(phydev, &tx_pause, &rx_pause);\n\n\t\t\tif (!tx_pause)\n\t\t\t\tcmd_bits |= CMD_TX_PAUSE_IGNORE;\n\t\t\tif (!rx_pause)\n\t\t\t\tcmd_bits |= CMD_RX_PAUSE_IGNORE;\n\t\t}\n\n\t\t \n\t\tif (!priv->rx_pause)\n\t\t\tcmd_bits |= CMD_RX_PAUSE_IGNORE;\n\t\tif (!priv->tx_pause)\n\t\t\tcmd_bits |= CMD_TX_PAUSE_IGNORE;\n\t}\n\n\t \n\treg = bcmgenet_ext_readl(priv, EXT_RGMII_OOB_CTRL);\n\treg |= RGMII_LINK;\n\tbcmgenet_ext_writel(priv, reg, EXT_RGMII_OOB_CTRL);\n\n\treg = bcmgenet_umac_readl(priv, UMAC_CMD);\n\treg &= ~((CMD_SPEED_MASK << CMD_SPEED_SHIFT) |\n\t\t       CMD_HD_EN |\n\t\t       CMD_RX_PAUSE_IGNORE | CMD_TX_PAUSE_IGNORE);\n\treg |= cmd_bits;\n\tif (reg & CMD_SW_RESET) {\n\t\treg &= ~CMD_SW_RESET;\n\t\tbcmgenet_umac_writel(priv, reg, UMAC_CMD);\n\t\tudelay(2);\n\t\treg |= CMD_TX_EN | CMD_RX_EN;\n\t}\n\tbcmgenet_umac_writel(priv, reg, UMAC_CMD);\n\n\tpriv->eee.eee_active = phy_init_eee(phydev, 0) >= 0;\n\tbcmgenet_eee_enable_set(dev,\n\t\t\t\tpriv->eee.eee_enabled && priv->eee.eee_active,\n\t\t\t\tpriv->eee.tx_lpi_enabled);\n}\n\n \nvoid bcmgenet_mii_setup(struct net_device *dev)\n{\n\tstruct bcmgenet_priv *priv = netdev_priv(dev);\n\tstruct phy_device *phydev = dev->phydev;\n\tu32 reg;\n\n\tif (phydev->link) {\n\t\tbcmgenet_mac_config(dev);\n\t} else {\n\t\treg = bcmgenet_ext_readl(priv, EXT_RGMII_OOB_CTRL);\n\t\treg &= ~RGMII_LINK;\n\t\tbcmgenet_ext_writel(priv, reg, EXT_RGMII_OOB_CTRL);\n\t}\n\n\tphy_print_status(phydev);\n}\n\n\nstatic int bcmgenet_fixed_phy_link_update(struct net_device *dev,\n\t\t\t\t\t  struct fixed_phy_status *status)\n{\n\tstruct bcmgenet_priv *priv;\n\tu32 reg;\n\n\tif (dev && dev->phydev && status) {\n\t\tpriv = netdev_priv(dev);\n\t\treg = bcmgenet_umac_readl(priv, UMAC_MODE);\n\t\tstatus->link = !!(reg & MODE_LINK_STATUS);\n\t}\n\n\treturn 0;\n}\n\nvoid bcmgenet_phy_pause_set(struct net_device *dev, bool rx, bool tx)\n{\n\tstruct phy_device *phydev = dev->phydev;\n\n\tlinkmode_mod_bit(ETHTOOL_LINK_MODE_Pause_BIT, phydev->advertising, rx);\n\tlinkmode_mod_bit(ETHTOOL_LINK_MODE_Asym_Pause_BIT, phydev->advertising,\n\t\t\t rx | tx);\n\tphy_start_aneg(phydev);\n\n\tmutex_lock(&phydev->lock);\n\tif (phydev->link)\n\t\tbcmgenet_mac_config(dev);\n\tmutex_unlock(&phydev->lock);\n}\n\nvoid bcmgenet_phy_power_set(struct net_device *dev, bool enable)\n{\n\tstruct bcmgenet_priv *priv = netdev_priv(dev);\n\tu32 reg = 0;\n\n\t \n\tif (GENET_IS_V4(priv) || priv->ephy_16nm) {\n\t\treg = bcmgenet_ext_readl(priv, EXT_GPHY_CTRL);\n\t\tif (enable) {\n\t\t\treg &= ~EXT_CK25_DIS;\n\t\t\tbcmgenet_ext_writel(priv, reg, EXT_GPHY_CTRL);\n\t\t\tmdelay(1);\n\n\t\t\treg &= ~(EXT_CFG_IDDQ_BIAS | EXT_CFG_PWR_DOWN |\n\t\t\t\t EXT_CFG_IDDQ_GLOBAL_PWR);\n\t\t\treg |= EXT_GPHY_RESET;\n\t\t\tbcmgenet_ext_writel(priv, reg, EXT_GPHY_CTRL);\n\t\t\tmdelay(1);\n\n\t\t\treg &= ~EXT_GPHY_RESET;\n\t\t} else {\n\t\t\treg |= EXT_CFG_IDDQ_BIAS | EXT_CFG_PWR_DOWN |\n\t\t\t       EXT_GPHY_RESET | EXT_CFG_IDDQ_GLOBAL_PWR;\n\t\t\tbcmgenet_ext_writel(priv, reg, EXT_GPHY_CTRL);\n\t\t\tmdelay(1);\n\t\t\treg |= EXT_CK25_DIS;\n\t\t}\n\t\tbcmgenet_ext_writel(priv, reg, EXT_GPHY_CTRL);\n\t\tudelay(60);\n\t} else {\n\t\tmdelay(1);\n\t}\n}\n\nstatic void bcmgenet_moca_phy_setup(struct bcmgenet_priv *priv)\n{\n\tif (priv->hw_params->flags & GENET_HAS_MOCA_LINK_DET)\n\t\tfixed_phy_set_link_update(priv->dev->phydev,\n\t\t\t\t\t  bcmgenet_fixed_phy_link_update);\n}\n\nint bcmgenet_mii_config(struct net_device *dev, bool init)\n{\n\tstruct bcmgenet_priv *priv = netdev_priv(dev);\n\tstruct phy_device *phydev = dev->phydev;\n\tstruct device *kdev = &priv->pdev->dev;\n\tconst char *phy_name = NULL;\n\tu32 id_mode_dis = 0;\n\tu32 port_ctrl;\n\tu32 reg;\n\n\tswitch (priv->phy_interface) {\n\tcase PHY_INTERFACE_MODE_INTERNAL:\n\t\tphy_name = \"internal PHY\";\n\t\tfallthrough;\n\tcase PHY_INTERFACE_MODE_MOCA:\n\t\t \n\t\tif (GENET_IS_V4(priv))\n\t\t\tport_ctrl = PORT_MODE_INT_GPHY;\n\t\telse\n\t\t\tport_ctrl = PORT_MODE_INT_EPHY;\n\n\t\tif (!phy_name) {\n\t\t\tphy_name = \"MoCA\";\n\t\t\tif (!GENET_IS_V5(priv))\n\t\t\t\tport_ctrl |= LED_ACT_SOURCE_MAC;\n\t\t\tbcmgenet_moca_phy_setup(priv);\n\t\t}\n\t\tbreak;\n\n\tcase PHY_INTERFACE_MODE_MII:\n\t\tphy_name = \"external MII\";\n\t\tphy_set_max_speed(phydev, SPEED_100);\n\t\tport_ctrl = PORT_MODE_EXT_EPHY;\n\t\tbreak;\n\n\tcase PHY_INTERFACE_MODE_REVMII:\n\t\tphy_name = \"external RvMII\";\n\t\t \n\t\tif (linkmode_test_bit(ETHTOOL_LINK_MODE_1000baseT_Full_BIT,\n\t\t\t\t      dev->phydev->supported))\n\t\t\tport_ctrl = PORT_MODE_EXT_RVMII_50;\n\t\telse\n\t\t\tport_ctrl = PORT_MODE_EXT_RVMII_25;\n\t\tbreak;\n\n\tcase PHY_INTERFACE_MODE_RGMII:\n\t\t \n\t\tphy_name = \"external RGMII (no delay)\";\n\t\tid_mode_dis = BIT(16);\n\t\tport_ctrl = PORT_MODE_EXT_GPHY;\n\t\tbreak;\n\n\tcase PHY_INTERFACE_MODE_RGMII_TXID:\n\t\t \n\t\tphy_name = \"external RGMII (TX delay)\";\n\t\tport_ctrl = PORT_MODE_EXT_GPHY;\n\t\tbreak;\n\n\tcase PHY_INTERFACE_MODE_RGMII_RXID:\n\t\tphy_name = \"external RGMII (RX delay)\";\n\t\tport_ctrl = PORT_MODE_EXT_GPHY;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(kdev, \"unknown phy mode: %d\\n\", priv->phy_interface);\n\t\treturn -EINVAL;\n\t}\n\n\tbcmgenet_sys_writel(priv, port_ctrl, SYS_PORT_CTRL);\n\n\tpriv->ext_phy = !priv->internal_phy &&\n\t\t\t(priv->phy_interface != PHY_INTERFACE_MODE_MOCA);\n\n\t \n\treg = bcmgenet_ext_readl(priv, EXT_RGMII_OOB_CTRL);\n\treg &= ~OOB_DISABLE;\n\tif (priv->ext_phy) {\n\t\treg &= ~ID_MODE_DIS;\n\t\treg |= id_mode_dis;\n\t\tif (GENET_IS_V1(priv) || GENET_IS_V2(priv) || GENET_IS_V3(priv))\n\t\t\treg |= RGMII_MODE_EN_V123;\n\t\telse\n\t\t\treg |= RGMII_MODE_EN;\n\t}\n\tbcmgenet_ext_writel(priv, reg, EXT_RGMII_OOB_CTRL);\n\n\tif (init)\n\t\tdev_info(kdev, \"configuring instance for %s\\n\", phy_name);\n\n\treturn 0;\n}\n\nint bcmgenet_mii_probe(struct net_device *dev)\n{\n\tstruct bcmgenet_priv *priv = netdev_priv(dev);\n\tstruct device *kdev = &priv->pdev->dev;\n\tstruct device_node *dn = kdev->of_node;\n\tphy_interface_t phy_iface = priv->phy_interface;\n\tstruct phy_device *phydev;\n\tu32 phy_flags = PHY_BRCM_AUTO_PWRDWN_ENABLE |\n\t\t\tPHY_BRCM_DIS_TXCRXC_NOENRGY |\n\t\t\tPHY_BRCM_IDDQ_SUSPEND;\n\tint ret;\n\n\t \n\tif (priv->internal_phy)\n\t\tphy_flags = priv->gphy_rev;\n\n\t \n\tswitch (priv->phy_interface) {\n\tcase PHY_INTERFACE_MODE_RGMII:\n\t\tphy_iface = PHY_INTERFACE_MODE_RGMII_ID;\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_RGMII_TXID:\n\t\tphy_iface = PHY_INTERFACE_MODE_RGMII_RXID;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (dn) {\n\t\tphydev = of_phy_connect(dev, priv->phy_dn, bcmgenet_mii_setup,\n\t\t\t\t\tphy_flags, phy_iface);\n\t\tif (!phydev) {\n\t\t\tpr_err(\"could not attach to PHY\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t} else {\n\t\tif (has_acpi_companion(kdev)) {\n\t\t\tchar mdio_bus_id[MII_BUS_ID_SIZE];\n\t\t\tstruct mii_bus *unimacbus;\n\n\t\t\tsnprintf(mdio_bus_id, MII_BUS_ID_SIZE, \"%s-%d\",\n\t\t\t\t UNIMAC_MDIO_DRV_NAME, priv->pdev->id);\n\n\t\t\tunimacbus = mdio_find_bus(mdio_bus_id);\n\t\t\tif (!unimacbus) {\n\t\t\t\tpr_err(\"Unable to find mii\\n\");\n\t\t\t\treturn -ENODEV;\n\t\t\t}\n\t\t\tphydev = phy_find_first(unimacbus);\n\t\t\tput_device(&unimacbus->dev);\n\t\t\tif (!phydev) {\n\t\t\t\tpr_err(\"Unable to find PHY\\n\");\n\t\t\t\treturn -ENODEV;\n\t\t\t}\n\t\t} else {\n\t\t\tphydev = dev->phydev;\n\t\t}\n\t\tphydev->dev_flags = phy_flags;\n\n\t\tret = phy_connect_direct(dev, phydev, bcmgenet_mii_setup,\n\t\t\t\t\t phy_iface);\n\t\tif (ret) {\n\t\t\tpr_err(\"could not attach to PHY\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\t \n\tret = bcmgenet_mii_config(dev, true);\n\tif (ret) {\n\t\tphy_disconnect(dev->phydev);\n\t\treturn ret;\n\t}\n\n\t \n\tif (priv->internal_phy && !GENET_IS_V5(priv))\n\t\tdev->phydev->irq = PHY_MAC_INTERRUPT;\n\n\t \n\tdev->phydev->mac_managed_pm = true;\n\n\treturn 0;\n}\n\nstatic struct device_node *bcmgenet_mii_of_find_mdio(struct bcmgenet_priv *priv)\n{\n\tstruct device_node *dn = priv->pdev->dev.of_node;\n\tstruct device *kdev = &priv->pdev->dev;\n\tchar *compat;\n\n\tcompat = kasprintf(GFP_KERNEL, \"brcm,genet-mdio-v%d\", priv->version);\n\tif (!compat)\n\t\treturn NULL;\n\n\tpriv->mdio_dn = of_get_compatible_child(dn, compat);\n\tkfree(compat);\n\tif (!priv->mdio_dn) {\n\t\tdev_err(kdev, \"unable to find MDIO bus node\\n\");\n\t\treturn NULL;\n\t}\n\n\treturn priv->mdio_dn;\n}\n\nstatic void bcmgenet_mii_pdata_init(struct bcmgenet_priv *priv,\n\t\t\t\t    struct unimac_mdio_pdata *ppd)\n{\n\tstruct device *kdev = &priv->pdev->dev;\n\tstruct bcmgenet_platform_data *pd = kdev->platform_data;\n\n\tif (pd->phy_interface != PHY_INTERFACE_MODE_MOCA && pd->mdio_enabled) {\n\t\t \n\t\tif (pd->phy_address >= 0 && pd->phy_address < PHY_MAX_ADDR)\n\t\t\tppd->phy_mask = 1 << pd->phy_address;\n\t\telse\n\t\t\tppd->phy_mask = 0;\n\t}\n}\n\nstatic int bcmgenet_mii_wait(void *wait_func_data)\n{\n\tstruct bcmgenet_priv *priv = wait_func_data;\n\n\twait_event_timeout(priv->wq,\n\t\t\t   !(bcmgenet_umac_readl(priv, UMAC_MDIO_CMD)\n\t\t\t   & MDIO_START_BUSY),\n\t\t\t   HZ / 100);\n\treturn 0;\n}\n\nstatic int bcmgenet_mii_register(struct bcmgenet_priv *priv)\n{\n\tstruct platform_device *pdev = priv->pdev;\n\tstruct bcmgenet_platform_data *pdata = pdev->dev.platform_data;\n\tstruct device_node *dn = pdev->dev.of_node;\n\tstruct unimac_mdio_pdata ppd;\n\tstruct platform_device *ppdev;\n\tstruct resource *pres, res;\n\tint id, ret;\n\n\tpres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!pres) {\n\t\tdev_err(&pdev->dev, \"Invalid resource\\n\");\n\t\treturn -EINVAL;\n\t}\n\tmemset(&res, 0, sizeof(res));\n\tmemset(&ppd, 0, sizeof(ppd));\n\n\tppd.wait_func = bcmgenet_mii_wait;\n\tppd.wait_func_data = priv;\n\tppd.bus_name = \"bcmgenet MII bus\";\n\n\t \n\tres.start = pres->start + GENET_UMAC_OFF + UMAC_MDIO_CMD;\n\tres.end = res.start + 8;\n\tres.flags = IORESOURCE_MEM;\n\n\tif (dn)\n\t\tid = of_alias_get_id(dn, \"eth\");\n\telse\n\t\tid = pdev->id;\n\n\tppdev = platform_device_alloc(UNIMAC_MDIO_DRV_NAME, id);\n\tif (!ppdev)\n\t\treturn -ENOMEM;\n\n\t \n\tpriv->mii_pdev = ppdev;\n\tppdev->dev.parent = &pdev->dev;\n\tif (dn)\n\t\tppdev->dev.of_node = bcmgenet_mii_of_find_mdio(priv);\n\telse if (pdata)\n\t\tbcmgenet_mii_pdata_init(priv, &ppd);\n\telse\n\t\tppd.phy_mask = ~0;\n\n\tret = platform_device_add_resources(ppdev, &res, 1);\n\tif (ret)\n\t\tgoto out;\n\n\tret = platform_device_add_data(ppdev, &ppd, sizeof(ppd));\n\tif (ret)\n\t\tgoto out;\n\n\tret = platform_device_add(ppdev);\n\tif (ret)\n\t\tgoto out;\n\n\treturn 0;\nout:\n\tplatform_device_put(ppdev);\n\treturn ret;\n}\n\nstatic int bcmgenet_phy_interface_init(struct bcmgenet_priv *priv)\n{\n\tstruct device *kdev = &priv->pdev->dev;\n\tint phy_mode = device_get_phy_mode(kdev);\n\n\tif (phy_mode < 0) {\n\t\tdev_err(kdev, \"invalid PHY mode property\\n\");\n\t\treturn phy_mode;\n\t}\n\n\tpriv->phy_interface = phy_mode;\n\n\t \n\tif (priv->phy_interface == PHY_INTERFACE_MODE_INTERNAL)\n\t\tpriv->internal_phy = true;\n\n\treturn 0;\n}\n\nstatic int bcmgenet_mii_of_init(struct bcmgenet_priv *priv)\n{\n\tstruct device_node *dn = priv->pdev->dev.of_node;\n\tstruct phy_device *phydev;\n\tint ret;\n\n\t \n\tpriv->phy_dn = of_parse_phandle(dn, \"phy-handle\", 0);\n\n\t \n\tif (!priv->phy_dn && of_phy_is_fixed_link(dn)) {\n\t\tret = of_phy_register_fixed_link(dn);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tpriv->phy_dn = of_node_get(dn);\n\t}\n\n\t \n\tret = bcmgenet_phy_interface_init(priv);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (priv->phy_interface == PHY_INTERFACE_MODE_MOCA) {\n\t\tphydev = of_phy_find_device(dn);\n\t\tif (phydev) {\n\t\t\tphydev->link = 0;\n\t\t\tput_device(&phydev->mdio.dev);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int bcmgenet_mii_pd_init(struct bcmgenet_priv *priv)\n{\n\tstruct device *kdev = &priv->pdev->dev;\n\tstruct bcmgenet_platform_data *pd = kdev->platform_data;\n\tchar phy_name[MII_BUS_ID_SIZE + 3];\n\tchar mdio_bus_id[MII_BUS_ID_SIZE];\n\tstruct phy_device *phydev;\n\n\tsnprintf(mdio_bus_id, MII_BUS_ID_SIZE, \"%s-%d\",\n\t\t UNIMAC_MDIO_DRV_NAME, priv->pdev->id);\n\n\tif (pd->phy_interface != PHY_INTERFACE_MODE_MOCA && pd->mdio_enabled) {\n\t\tsnprintf(phy_name, MII_BUS_ID_SIZE, PHY_ID_FMT,\n\t\t\t mdio_bus_id, pd->phy_address);\n\n\t\t \n\t\tphydev = phy_attach(priv->dev, phy_name, pd->phy_interface);\n\t\tif (IS_ERR(phydev)) {\n\t\t\tdev_err(kdev, \"failed to register PHY device\\n\");\n\t\t\treturn PTR_ERR(phydev);\n\t\t}\n\t} else {\n\t\t \n\t\tstruct fixed_phy_status fphy_status = {\n\t\t\t.link = 1,\n\t\t\t.speed = pd->phy_speed,\n\t\t\t.duplex = pd->phy_duplex,\n\t\t\t.pause = 0,\n\t\t\t.asym_pause = 0,\n\t\t};\n\n\t\tphydev = fixed_phy_register(PHY_POLL, &fphy_status, NULL);\n\t\tif (IS_ERR(phydev)) {\n\t\t\tdev_err(kdev, \"failed to register fixed PHY device\\n\");\n\t\t\treturn PTR_ERR(phydev);\n\t\t}\n\n\t\t \n\t\tphydev->link = 0;\n\n\t}\n\n\tpriv->phy_interface = pd->phy_interface;\n\n\treturn 0;\n}\n\nstatic int bcmgenet_mii_bus_init(struct bcmgenet_priv *priv)\n{\n\tstruct device *kdev = &priv->pdev->dev;\n\tstruct device_node *dn = kdev->of_node;\n\n\tif (dn)\n\t\treturn bcmgenet_mii_of_init(priv);\n\telse if (has_acpi_companion(kdev))\n\t\treturn bcmgenet_phy_interface_init(priv);\n\telse\n\t\treturn bcmgenet_mii_pd_init(priv);\n}\n\nint bcmgenet_mii_init(struct net_device *dev)\n{\n\tstruct bcmgenet_priv *priv = netdev_priv(dev);\n\tint ret;\n\n\tret = bcmgenet_mii_register(priv);\n\tif (ret)\n\t\treturn ret;\n\n\tret = bcmgenet_mii_bus_init(priv);\n\tif (ret)\n\t\tgoto out;\n\n\treturn 0;\n\nout:\n\tbcmgenet_mii_exit(dev);\n\treturn ret;\n}\n\nvoid bcmgenet_mii_exit(struct net_device *dev)\n{\n\tstruct bcmgenet_priv *priv = netdev_priv(dev);\n\tstruct device_node *dn = priv->pdev->dev.of_node;\n\n\tif (of_phy_is_fixed_link(dn))\n\t\tof_phy_deregister_fixed_link(dn);\n\tof_node_put(priv->phy_dn);\n\tclk_prepare_enable(priv->clk);\n\tplatform_device_unregister(priv->mii_pdev);\n\tclk_disable_unprepare(priv->clk);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}