{
  "module_name": "bcmgenet_wol.c",
  "hash_id": "a15206609932eeb0c0c545d23287c0e57aec266be74865f5d28e67eb51b4a326",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/broadcom/genet/bcmgenet_wol.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt)\t\t\t\t\"bcmgenet_wol: \" fmt\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/interrupt.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/errno.h>\n#include <linux/delay.h>\n#include <linux/pm.h>\n#include <linux/clk.h>\n#include <linux/platform_device.h>\n#include <net/arp.h>\n\n#include <linux/mii.h>\n#include <linux/ethtool.h>\n#include <linux/netdevice.h>\n#include <linux/inetdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/skbuff.h>\n#include <linux/in.h>\n#include <linux/ip.h>\n#include <linux/ipv6.h>\n#include <linux/phy.h>\n\n#include \"bcmgenet.h\"\n\n \nvoid bcmgenet_get_wol(struct net_device *dev, struct ethtool_wolinfo *wol)\n{\n\tstruct bcmgenet_priv *priv = netdev_priv(dev);\n\tstruct device *kdev = &priv->pdev->dev;\n\n\tif (dev->phydev) {\n\t\tphy_ethtool_get_wol(dev->phydev, wol);\n\t\tif (wol->supported)\n\t\t\treturn;\n\t}\n\n\tif (!device_can_wakeup(kdev)) {\n\t\twol->supported = 0;\n\t\twol->wolopts = 0;\n\t\treturn;\n\t}\n\n\twol->supported = WAKE_MAGIC | WAKE_MAGICSECURE | WAKE_FILTER;\n\twol->wolopts = priv->wolopts;\n\tmemset(wol->sopass, 0, sizeof(wol->sopass));\n\n\tif (wol->wolopts & WAKE_MAGICSECURE)\n\t\tmemcpy(wol->sopass, priv->sopass, sizeof(priv->sopass));\n}\n\n \nint bcmgenet_set_wol(struct net_device *dev, struct ethtool_wolinfo *wol)\n{\n\tstruct bcmgenet_priv *priv = netdev_priv(dev);\n\tstruct device *kdev = &priv->pdev->dev;\n\tint ret;\n\n\t \n\tif (dev->phydev) {\n\t\tret = phy_ethtool_set_wol(dev->phydev, wol);\n\t\tif (ret != -EOPNOTSUPP)\n\t\t\treturn ret;\n\t}\n\n\tif (!device_can_wakeup(kdev))\n\t\treturn -ENOTSUPP;\n\n\tif (wol->wolopts & ~(WAKE_MAGIC | WAKE_MAGICSECURE | WAKE_FILTER))\n\t\treturn -EINVAL;\n\n\tif (wol->wolopts & WAKE_MAGICSECURE)\n\t\tmemcpy(priv->sopass, wol->sopass, sizeof(priv->sopass));\n\n\t \n\tif (wol->wolopts) {\n\t\tdevice_set_wakeup_enable(kdev, 1);\n\t\t \n\t\tif (priv->wol_irq_disabled) {\n\t\t\tenable_irq_wake(priv->wol_irq);\n\t\t\tenable_irq_wake(priv->irq0);\n\t\t}\n\t\tpriv->wol_irq_disabled = false;\n\t} else {\n\t\tdevice_set_wakeup_enable(kdev, 0);\n\t\t \n\t\tif (!priv->wol_irq_disabled) {\n\t\t\tdisable_irq_wake(priv->wol_irq);\n\t\t\tdisable_irq_wake(priv->irq0);\n\t\t}\n\t\tpriv->wol_irq_disabled = true;\n\t}\n\n\tpriv->wolopts = wol->wolopts;\n\n\treturn 0;\n}\n\nstatic int bcmgenet_poll_wol_status(struct bcmgenet_priv *priv)\n{\n\tstruct net_device *dev = priv->dev;\n\tint retries = 0;\n\n\twhile (!(bcmgenet_rbuf_readl(priv, RBUF_STATUS)\n\t\t& RBUF_STATUS_WOL)) {\n\t\tretries++;\n\t\tif (retries > 5) {\n\t\t\tnetdev_crit(dev, \"polling wol mode timeout\\n\");\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t\tmdelay(1);\n\t}\n\n\treturn retries;\n}\n\nstatic void bcmgenet_set_mpd_password(struct bcmgenet_priv *priv)\n{\n\tbcmgenet_umac_writel(priv, get_unaligned_be16(&priv->sopass[0]),\n\t\t\t     UMAC_MPD_PW_MS);\n\tbcmgenet_umac_writel(priv, get_unaligned_be32(&priv->sopass[2]),\n\t\t\t     UMAC_MPD_PW_LS);\n}\n\nint bcmgenet_wol_power_down_cfg(struct bcmgenet_priv *priv,\n\t\t\t\tenum bcmgenet_power_mode mode)\n{\n\tstruct net_device *dev = priv->dev;\n\tstruct bcmgenet_rxnfc_rule *rule;\n\tu32 reg, hfb_ctrl_reg, hfb_enable = 0;\n\tint retries = 0;\n\n\tif (mode != GENET_POWER_WOL_MAGIC) {\n\t\tnetif_err(priv, wol, dev, \"unsupported mode: %d\\n\", mode);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\treg = bcmgenet_umac_readl(priv, UMAC_CMD);\n\tif (reg & CMD_SW_RESET)\n\t\treg &= ~CMD_SW_RESET;\n\n\t \n\treg &= ~CMD_RX_EN;\n\tbcmgenet_umac_writel(priv, reg, UMAC_CMD);\n\tmdelay(10);\n\n\tif (priv->wolopts & (WAKE_MAGIC | WAKE_MAGICSECURE)) {\n\t\treg = bcmgenet_umac_readl(priv, UMAC_MPD_CTRL);\n\t\treg |= MPD_EN;\n\t\tif (priv->wolopts & WAKE_MAGICSECURE) {\n\t\t\tbcmgenet_set_mpd_password(priv);\n\t\t\treg |= MPD_PW_EN;\n\t\t}\n\t\tbcmgenet_umac_writel(priv, reg, UMAC_MPD_CTRL);\n\t}\n\n\thfb_ctrl_reg = bcmgenet_hfb_reg_readl(priv, HFB_CTRL);\n\tif (priv->wolopts & WAKE_FILTER) {\n\t\tlist_for_each_entry(rule, &priv->rxnfc_list, list)\n\t\t\tif (rule->fs.ring_cookie == RX_CLS_FLOW_WAKE)\n\t\t\t\thfb_enable |= (1 << rule->fs.location);\n\t\treg = (hfb_ctrl_reg & ~RBUF_HFB_EN) | RBUF_ACPI_EN;\n\t\tbcmgenet_hfb_reg_writel(priv, reg, HFB_CTRL);\n\t}\n\n\t \n\tretries = bcmgenet_poll_wol_status(priv);\n\tif (retries < 0) {\n\t\treg = bcmgenet_umac_readl(priv, UMAC_MPD_CTRL);\n\t\treg &= ~(MPD_EN | MPD_PW_EN);\n\t\tbcmgenet_umac_writel(priv, reg, UMAC_MPD_CTRL);\n\t\tbcmgenet_hfb_reg_writel(priv, hfb_ctrl_reg, HFB_CTRL);\n\t\treturn retries;\n\t}\n\n\tnetif_dbg(priv, wol, dev, \"MPD WOL-ready status set after %d msec\\n\",\n\t\t  retries);\n\n\tclk_prepare_enable(priv->clk_wol);\n\tpriv->wol_active = 1;\n\n\tif (hfb_enable) {\n\t\tbcmgenet_hfb_reg_writel(priv, hfb_enable,\n\t\t\t\t\tHFB_FLT_ENABLE_V3PLUS + 4);\n\t\thfb_ctrl_reg = RBUF_HFB_EN | RBUF_ACPI_EN;\n\t\tbcmgenet_hfb_reg_writel(priv, hfb_ctrl_reg, HFB_CTRL);\n\t}\n\n\t \n\treg = bcmgenet_umac_readl(priv, UMAC_CMD);\n\tpriv->crc_fwd_en = 1;\n\treg |= CMD_CRC_FWD;\n\n\t \n\treg |= CMD_RX_EN;\n\tbcmgenet_umac_writel(priv, reg, UMAC_CMD);\n\n\treg = UMAC_IRQ_MPD_R;\n\tif (hfb_enable)\n\t\treg |=  UMAC_IRQ_HFB_SM | UMAC_IRQ_HFB_MM;\n\n\tbcmgenet_intrl2_0_writel(priv, reg, INTRL2_CPU_MASK_CLEAR);\n\n\treturn 0;\n}\n\nvoid bcmgenet_wol_power_up_cfg(struct bcmgenet_priv *priv,\n\t\t\t       enum bcmgenet_power_mode mode)\n{\n\tu32 reg;\n\n\tif (mode != GENET_POWER_WOL_MAGIC) {\n\t\tnetif_err(priv, wol, priv->dev, \"invalid mode: %d\\n\", mode);\n\t\treturn;\n\t}\n\n\tif (!priv->wol_active)\n\t\treturn;\t \n\n\tpriv->wol_active = 0;\n\tclk_disable_unprepare(priv->clk_wol);\n\tpriv->crc_fwd_en = 0;\n\n\t \n\tif (priv->wolopts & (WAKE_MAGIC | WAKE_MAGICSECURE)) {\n\t\treg = bcmgenet_umac_readl(priv, UMAC_MPD_CTRL);\n\t\tif (!(reg & MPD_EN))\n\t\t\treturn;\t \n\t\treg &= ~(MPD_EN | MPD_PW_EN);\n\t\tbcmgenet_umac_writel(priv, reg, UMAC_MPD_CTRL);\n\t}\n\n\t \n\tif (priv->wolopts & WAKE_FILTER) {\n\t\treg = bcmgenet_hfb_reg_readl(priv, HFB_CTRL);\n\t\tif (!(reg & RBUF_ACPI_EN))\n\t\t\treturn;\t \n\t\treg &= ~(RBUF_HFB_EN | RBUF_ACPI_EN);\n\t\tbcmgenet_hfb_reg_writel(priv, reg, HFB_CTRL);\n\t}\n\n\t \n\treg = bcmgenet_umac_readl(priv, UMAC_CMD);\n\treg &= ~CMD_CRC_FWD;\n\tbcmgenet_umac_writel(priv, reg, UMAC_CMD);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}