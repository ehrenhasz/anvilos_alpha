{
  "module_name": "bgmac.c",
  "hash_id": "4e21300966cd58ff7c395c4e6b9aea7613503be637c105894dd0dd3773df2525",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/broadcom/bgmac.c",
  "human_readable_source": " \n\n\n#define pr_fmt(fmt)\t\tKBUILD_MODNAME \": \" fmt\n\n#include <linux/bcma/bcma.h>\n#include <linux/etherdevice.h>\n#include <linux/interrupt.h>\n#include <linux/bcm47xx_nvram.h>\n#include <linux/phy.h>\n#include <linux/phy_fixed.h>\n#include <net/dsa.h>\n#include \"bgmac.h\"\n\nstatic bool bgmac_wait_value(struct bgmac *bgmac, u16 reg, u32 mask,\n\t\t\t     u32 value, int timeout)\n{\n\tu32 val;\n\tint i;\n\n\tfor (i = 0; i < timeout / 10; i++) {\n\t\tval = bgmac_read(bgmac, reg);\n\t\tif ((val & mask) == value)\n\t\t\treturn true;\n\t\tudelay(10);\n\t}\n\tdev_err(bgmac->dev, \"Timeout waiting for reg 0x%X\\n\", reg);\n\treturn false;\n}\n\n \n\nstatic void bgmac_dma_tx_reset(struct bgmac *bgmac, struct bgmac_dma_ring *ring)\n{\n\tu32 val;\n\tint i;\n\n\tif (!ring->mmio_base)\n\t\treturn;\n\n\t \n\tbgmac_write(bgmac, ring->mmio_base + BGMAC_DMA_TX_CTL,\n\t\t    BGMAC_DMA_TX_SUSPEND);\n\tfor (i = 0; i < 10000 / 10; i++) {\n\t\tval = bgmac_read(bgmac, ring->mmio_base + BGMAC_DMA_TX_STATUS);\n\t\tval &= BGMAC_DMA_TX_STAT;\n\t\tif (val == BGMAC_DMA_TX_STAT_DISABLED ||\n\t\t    val == BGMAC_DMA_TX_STAT_IDLEWAIT ||\n\t\t    val == BGMAC_DMA_TX_STAT_STOPPED) {\n\t\t\ti = 0;\n\t\t\tbreak;\n\t\t}\n\t\tudelay(10);\n\t}\n\tif (i)\n\t\tdev_err(bgmac->dev, \"Timeout suspending DMA TX ring 0x%X (BGMAC_DMA_TX_STAT: 0x%08X)\\n\",\n\t\t\tring->mmio_base, val);\n\n\t \n\tbgmac_write(bgmac, ring->mmio_base + BGMAC_DMA_TX_CTL, 0);\n\tif (!bgmac_wait_value(bgmac,\n\t\t\t      ring->mmio_base + BGMAC_DMA_TX_STATUS,\n\t\t\t      BGMAC_DMA_TX_STAT, BGMAC_DMA_TX_STAT_DISABLED,\n\t\t\t      10000)) {\n\t\tdev_warn(bgmac->dev, \"DMA TX ring 0x%X wasn't disabled on time, waiting additional 300us\\n\",\n\t\t\t ring->mmio_base);\n\t\tudelay(300);\n\t\tval = bgmac_read(bgmac, ring->mmio_base + BGMAC_DMA_TX_STATUS);\n\t\tif ((val & BGMAC_DMA_TX_STAT) != BGMAC_DMA_TX_STAT_DISABLED)\n\t\t\tdev_err(bgmac->dev, \"Reset of DMA TX ring 0x%X failed\\n\",\n\t\t\t\tring->mmio_base);\n\t}\n}\n\nstatic void bgmac_dma_tx_enable(struct bgmac *bgmac,\n\t\t\t\tstruct bgmac_dma_ring *ring)\n{\n\tu32 ctl;\n\n\tctl = bgmac_read(bgmac, ring->mmio_base + BGMAC_DMA_TX_CTL);\n\tif (bgmac->feature_flags & BGMAC_FEAT_TX_MASK_SETUP) {\n\t\tctl &= ~BGMAC_DMA_TX_BL_MASK;\n\t\tctl |= BGMAC_DMA_TX_BL_128 << BGMAC_DMA_TX_BL_SHIFT;\n\n\t\tctl &= ~BGMAC_DMA_TX_MR_MASK;\n\t\tctl |= BGMAC_DMA_TX_MR_2 << BGMAC_DMA_TX_MR_SHIFT;\n\n\t\tctl &= ~BGMAC_DMA_TX_PC_MASK;\n\t\tctl |= BGMAC_DMA_TX_PC_16 << BGMAC_DMA_TX_PC_SHIFT;\n\n\t\tctl &= ~BGMAC_DMA_TX_PT_MASK;\n\t\tctl |= BGMAC_DMA_TX_PT_8 << BGMAC_DMA_TX_PT_SHIFT;\n\t}\n\tctl |= BGMAC_DMA_TX_ENABLE;\n\tctl |= BGMAC_DMA_TX_PARITY_DISABLE;\n\tbgmac_write(bgmac, ring->mmio_base + BGMAC_DMA_TX_CTL, ctl);\n}\n\nstatic void\nbgmac_dma_tx_add_buf(struct bgmac *bgmac, struct bgmac_dma_ring *ring,\n\t\t     int i, int len, u32 ctl0)\n{\n\tstruct bgmac_slot_info *slot;\n\tstruct bgmac_dma_desc *dma_desc;\n\tu32 ctl1;\n\n\tif (i == BGMAC_TX_RING_SLOTS - 1)\n\t\tctl0 |= BGMAC_DESC_CTL0_EOT;\n\n\tctl1 = len & BGMAC_DESC_CTL1_LEN;\n\n\tslot = &ring->slots[i];\n\tdma_desc = &ring->cpu_base[i];\n\tdma_desc->addr_low = cpu_to_le32(lower_32_bits(slot->dma_addr));\n\tdma_desc->addr_high = cpu_to_le32(upper_32_bits(slot->dma_addr));\n\tdma_desc->ctl0 = cpu_to_le32(ctl0);\n\tdma_desc->ctl1 = cpu_to_le32(ctl1);\n}\n\nstatic netdev_tx_t bgmac_dma_tx_add(struct bgmac *bgmac,\n\t\t\t\t    struct bgmac_dma_ring *ring,\n\t\t\t\t    struct sk_buff *skb)\n{\n\tstruct device *dma_dev = bgmac->dma_dev;\n\tstruct net_device *net_dev = bgmac->net_dev;\n\tint index = ring->end % BGMAC_TX_RING_SLOTS;\n\tstruct bgmac_slot_info *slot = &ring->slots[index];\n\tint nr_frags;\n\tu32 flags;\n\tint i;\n\n\tif (skb->len > BGMAC_DESC_CTL1_LEN) {\n\t\tnetdev_err(bgmac->net_dev, \"Too long skb (%d)\\n\", skb->len);\n\t\tgoto err_drop;\n\t}\n\n\tif (skb->ip_summed == CHECKSUM_PARTIAL)\n\t\tskb_checksum_help(skb);\n\n\tnr_frags = skb_shinfo(skb)->nr_frags;\n\n\t \n\tif (ring->end - ring->start + nr_frags + 1 >= BGMAC_TX_RING_SLOTS) {\n\t\tnetdev_err(bgmac->net_dev, \"TX ring is full, queue should be stopped!\\n\");\n\t\tnetif_stop_queue(net_dev);\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\n\tslot->dma_addr = dma_map_single(dma_dev, skb->data, skb_headlen(skb),\n\t\t\t\t\tDMA_TO_DEVICE);\n\tif (unlikely(dma_mapping_error(dma_dev, slot->dma_addr)))\n\t\tgoto err_dma_head;\n\n\tflags = BGMAC_DESC_CTL0_SOF;\n\tif (!nr_frags)\n\t\tflags |= BGMAC_DESC_CTL0_EOF | BGMAC_DESC_CTL0_IOC;\n\n\tbgmac_dma_tx_add_buf(bgmac, ring, index, skb_headlen(skb), flags);\n\tflags = 0;\n\n\tfor (i = 0; i < nr_frags; i++) {\n\t\tskb_frag_t *frag = &skb_shinfo(skb)->frags[i];\n\t\tint len = skb_frag_size(frag);\n\n\t\tindex = (index + 1) % BGMAC_TX_RING_SLOTS;\n\t\tslot = &ring->slots[index];\n\t\tslot->dma_addr = skb_frag_dma_map(dma_dev, frag, 0,\n\t\t\t\t\t\t  len, DMA_TO_DEVICE);\n\t\tif (unlikely(dma_mapping_error(dma_dev, slot->dma_addr)))\n\t\t\tgoto err_dma;\n\n\t\tif (i == nr_frags - 1)\n\t\t\tflags |= BGMAC_DESC_CTL0_EOF | BGMAC_DESC_CTL0_IOC;\n\n\t\tbgmac_dma_tx_add_buf(bgmac, ring, index, len, flags);\n\t}\n\n\tslot->skb = skb;\n\tnetdev_sent_queue(net_dev, skb->len);\n\tring->end += nr_frags + 1;\n\n\twmb();\n\n\t \n\tbgmac_write(bgmac, ring->mmio_base + BGMAC_DMA_TX_INDEX,\n\t\t    ring->index_base +\n\t\t    (ring->end % BGMAC_TX_RING_SLOTS) *\n\t\t    sizeof(struct bgmac_dma_desc));\n\n\tif (ring->end - ring->start >= BGMAC_TX_RING_SLOTS - 8)\n\t\tnetif_stop_queue(net_dev);\n\n\treturn NETDEV_TX_OK;\n\nerr_dma:\n\tdma_unmap_single(dma_dev, slot->dma_addr, skb_headlen(skb),\n\t\t\t DMA_TO_DEVICE);\n\n\twhile (i-- > 0) {\n\t\tint index = (ring->end + i) % BGMAC_TX_RING_SLOTS;\n\t\tstruct bgmac_slot_info *slot = &ring->slots[index];\n\t\tu32 ctl1 = le32_to_cpu(ring->cpu_base[index].ctl1);\n\t\tint len = ctl1 & BGMAC_DESC_CTL1_LEN;\n\n\t\tdma_unmap_page(dma_dev, slot->dma_addr, len, DMA_TO_DEVICE);\n\t}\n\nerr_dma_head:\n\tnetdev_err(bgmac->net_dev, \"Mapping error of skb on ring 0x%X\\n\",\n\t\t   ring->mmio_base);\n\nerr_drop:\n\tdev_kfree_skb(skb);\n\tnet_dev->stats.tx_dropped++;\n\tnet_dev->stats.tx_errors++;\n\treturn NETDEV_TX_OK;\n}\n\n \nstatic void bgmac_dma_tx_free(struct bgmac *bgmac, struct bgmac_dma_ring *ring)\n{\n\tstruct device *dma_dev = bgmac->dma_dev;\n\tint empty_slot;\n\tunsigned bytes_compl = 0, pkts_compl = 0;\n\n\t \n\tempty_slot = bgmac_read(bgmac, ring->mmio_base + BGMAC_DMA_TX_STATUS);\n\tempty_slot &= BGMAC_DMA_TX_STATDPTR;\n\tempty_slot -= ring->index_base;\n\tempty_slot &= BGMAC_DMA_TX_STATDPTR;\n\tempty_slot /= sizeof(struct bgmac_dma_desc);\n\n\twhile (ring->start != ring->end) {\n\t\tint slot_idx = ring->start % BGMAC_TX_RING_SLOTS;\n\t\tstruct bgmac_slot_info *slot = &ring->slots[slot_idx];\n\t\tu32 ctl0, ctl1;\n\t\tint len;\n\n\t\tif (slot_idx == empty_slot)\n\t\t\tbreak;\n\n\t\tctl0 = le32_to_cpu(ring->cpu_base[slot_idx].ctl0);\n\t\tctl1 = le32_to_cpu(ring->cpu_base[slot_idx].ctl1);\n\t\tlen = ctl1 & BGMAC_DESC_CTL1_LEN;\n\t\tif (ctl0 & BGMAC_DESC_CTL0_SOF)\n\t\t\t \n\t\t\tdma_unmap_single(dma_dev, slot->dma_addr, len,\n\t\t\t\t\t DMA_TO_DEVICE);\n\t\telse\n\t\t\tdma_unmap_page(dma_dev, slot->dma_addr, len,\n\t\t\t\t       DMA_TO_DEVICE);\n\n\t\tif (slot->skb) {\n\t\t\tbgmac->net_dev->stats.tx_bytes += slot->skb->len;\n\t\t\tbgmac->net_dev->stats.tx_packets++;\n\t\t\tbytes_compl += slot->skb->len;\n\t\t\tpkts_compl++;\n\n\t\t\t \n\t\t\tdev_kfree_skb(slot->skb);\n\t\t\tslot->skb = NULL;\n\t\t}\n\n\t\tslot->dma_addr = 0;\n\t\tring->start++;\n\t}\n\n\tif (!pkts_compl)\n\t\treturn;\n\n\tnetdev_completed_queue(bgmac->net_dev, pkts_compl, bytes_compl);\n\n\tif (netif_queue_stopped(bgmac->net_dev))\n\t\tnetif_wake_queue(bgmac->net_dev);\n}\n\nstatic void bgmac_dma_rx_reset(struct bgmac *bgmac, struct bgmac_dma_ring *ring)\n{\n\tif (!ring->mmio_base)\n\t\treturn;\n\n\tbgmac_write(bgmac, ring->mmio_base + BGMAC_DMA_RX_CTL, 0);\n\tif (!bgmac_wait_value(bgmac,\n\t\t\t      ring->mmio_base + BGMAC_DMA_RX_STATUS,\n\t\t\t      BGMAC_DMA_RX_STAT, BGMAC_DMA_RX_STAT_DISABLED,\n\t\t\t      10000))\n\t\tdev_err(bgmac->dev, \"Reset of ring 0x%X RX failed\\n\",\n\t\t\tring->mmio_base);\n}\n\nstatic void bgmac_dma_rx_enable(struct bgmac *bgmac,\n\t\t\t\tstruct bgmac_dma_ring *ring)\n{\n\tu32 ctl;\n\n\tctl = bgmac_read(bgmac, ring->mmio_base + BGMAC_DMA_RX_CTL);\n\n\t \n\tctl &= BGMAC_DMA_RX_ADDREXT_MASK;\n\n\tif (bgmac->feature_flags & BGMAC_FEAT_RX_MASK_SETUP) {\n\t\tctl &= ~BGMAC_DMA_RX_BL_MASK;\n\t\tctl |= BGMAC_DMA_RX_BL_128 << BGMAC_DMA_RX_BL_SHIFT;\n\n\t\tctl &= ~BGMAC_DMA_RX_PC_MASK;\n\t\tctl |= BGMAC_DMA_RX_PC_8 << BGMAC_DMA_RX_PC_SHIFT;\n\n\t\tctl &= ~BGMAC_DMA_RX_PT_MASK;\n\t\tctl |= BGMAC_DMA_RX_PT_1 << BGMAC_DMA_RX_PT_SHIFT;\n\t}\n\tctl |= BGMAC_DMA_RX_ENABLE;\n\tctl |= BGMAC_DMA_RX_PARITY_DISABLE;\n\tctl |= BGMAC_DMA_RX_OVERFLOW_CONT;\n\tctl |= BGMAC_RX_FRAME_OFFSET << BGMAC_DMA_RX_FRAME_OFFSET_SHIFT;\n\tbgmac_write(bgmac, ring->mmio_base + BGMAC_DMA_RX_CTL, ctl);\n}\n\nstatic int bgmac_dma_rx_skb_for_slot(struct bgmac *bgmac,\n\t\t\t\t     struct bgmac_slot_info *slot)\n{\n\tstruct device *dma_dev = bgmac->dma_dev;\n\tdma_addr_t dma_addr;\n\tstruct bgmac_rx_header *rx;\n\tvoid *buf;\n\n\t \n\tbuf = netdev_alloc_frag(BGMAC_RX_ALLOC_SIZE);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\t \n\trx = buf + BGMAC_RX_BUF_OFFSET;\n\trx->len = cpu_to_le16(0xdead);\n\trx->flags = cpu_to_le16(0xbeef);\n\n\t \n\tdma_addr = dma_map_single(dma_dev, buf + BGMAC_RX_BUF_OFFSET,\n\t\t\t\t  BGMAC_RX_BUF_SIZE, DMA_FROM_DEVICE);\n\tif (dma_mapping_error(dma_dev, dma_addr)) {\n\t\tnetdev_err(bgmac->net_dev, \"DMA mapping error\\n\");\n\t\tput_page(virt_to_head_page(buf));\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tslot->buf = buf;\n\tslot->dma_addr = dma_addr;\n\n\treturn 0;\n}\n\nstatic void bgmac_dma_rx_update_index(struct bgmac *bgmac,\n\t\t\t\t      struct bgmac_dma_ring *ring)\n{\n\tdma_wmb();\n\n\tbgmac_write(bgmac, ring->mmio_base + BGMAC_DMA_RX_INDEX,\n\t\t    ring->index_base +\n\t\t    ring->end * sizeof(struct bgmac_dma_desc));\n}\n\nstatic void bgmac_dma_rx_setup_desc(struct bgmac *bgmac,\n\t\t\t\t    struct bgmac_dma_ring *ring, int desc_idx)\n{\n\tstruct bgmac_dma_desc *dma_desc = ring->cpu_base + desc_idx;\n\tu32 ctl0 = 0, ctl1 = 0;\n\n\tif (desc_idx == BGMAC_RX_RING_SLOTS - 1)\n\t\tctl0 |= BGMAC_DESC_CTL0_EOT;\n\tctl1 |= BGMAC_RX_BUF_SIZE & BGMAC_DESC_CTL1_LEN;\n\t \n\t \n\n\tdma_desc->addr_low = cpu_to_le32(lower_32_bits(ring->slots[desc_idx].dma_addr));\n\tdma_desc->addr_high = cpu_to_le32(upper_32_bits(ring->slots[desc_idx].dma_addr));\n\tdma_desc->ctl0 = cpu_to_le32(ctl0);\n\tdma_desc->ctl1 = cpu_to_le32(ctl1);\n\n\tring->end = desc_idx;\n}\n\nstatic void bgmac_dma_rx_poison_buf(struct device *dma_dev,\n\t\t\t\t    struct bgmac_slot_info *slot)\n{\n\tstruct bgmac_rx_header *rx = slot->buf + BGMAC_RX_BUF_OFFSET;\n\n\tdma_sync_single_for_cpu(dma_dev, slot->dma_addr, BGMAC_RX_BUF_SIZE,\n\t\t\t\tDMA_FROM_DEVICE);\n\trx->len = cpu_to_le16(0xdead);\n\trx->flags = cpu_to_le16(0xbeef);\n\tdma_sync_single_for_device(dma_dev, slot->dma_addr, BGMAC_RX_BUF_SIZE,\n\t\t\t\t   DMA_FROM_DEVICE);\n}\n\nstatic int bgmac_dma_rx_read(struct bgmac *bgmac, struct bgmac_dma_ring *ring,\n\t\t\t     int weight)\n{\n\tu32 end_slot;\n\tint handled = 0;\n\n\tend_slot = bgmac_read(bgmac, ring->mmio_base + BGMAC_DMA_RX_STATUS);\n\tend_slot &= BGMAC_DMA_RX_STATDPTR;\n\tend_slot -= ring->index_base;\n\tend_slot &= BGMAC_DMA_RX_STATDPTR;\n\tend_slot /= sizeof(struct bgmac_dma_desc);\n\n\twhile (ring->start != end_slot) {\n\t\tstruct device *dma_dev = bgmac->dma_dev;\n\t\tstruct bgmac_slot_info *slot = &ring->slots[ring->start];\n\t\tstruct bgmac_rx_header *rx = slot->buf + BGMAC_RX_BUF_OFFSET;\n\t\tstruct sk_buff *skb;\n\t\tvoid *buf = slot->buf;\n\t\tdma_addr_t dma_addr = slot->dma_addr;\n\t\tu16 len, flags;\n\n\t\tdo {\n\t\t\t \n\t\t\tif (bgmac_dma_rx_skb_for_slot(bgmac, slot)) {\n\t\t\t\tbgmac_dma_rx_poison_buf(dma_dev, slot);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\t\t\tdma_unmap_single(dma_dev, dma_addr,\n\t\t\t\t\t BGMAC_RX_BUF_SIZE, DMA_FROM_DEVICE);\n\n\t\t\t \n\t\t\tlen = le16_to_cpu(rx->len);\n\t\t\tflags = le16_to_cpu(rx->flags);\n\n\t\t\t \n\t\t\tif (len == 0xdead && flags == 0xbeef) {\n\t\t\t\tnetdev_err(bgmac->net_dev, \"Found poisoned packet at slot %d, DMA issue!\\n\",\n\t\t\t\t\t   ring->start);\n\t\t\t\tput_page(virt_to_head_page(buf));\n\t\t\t\tbgmac->net_dev->stats.rx_errors++;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (len > BGMAC_RX_ALLOC_SIZE) {\n\t\t\t\tnetdev_err(bgmac->net_dev, \"Found oversized packet at slot %d, DMA issue!\\n\",\n\t\t\t\t\t   ring->start);\n\t\t\t\tput_page(virt_to_head_page(buf));\n\t\t\t\tbgmac->net_dev->stats.rx_length_errors++;\n\t\t\t\tbgmac->net_dev->stats.rx_errors++;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\t\t\tlen -= ETH_FCS_LEN;\n\n\t\t\tskb = build_skb(buf, BGMAC_RX_ALLOC_SIZE);\n\t\t\tif (unlikely(!skb)) {\n\t\t\t\tnetdev_err(bgmac->net_dev, \"build_skb failed\\n\");\n\t\t\t\tput_page(virt_to_head_page(buf));\n\t\t\t\tbgmac->net_dev->stats.rx_errors++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tskb_put(skb, BGMAC_RX_FRAME_OFFSET +\n\t\t\t\tBGMAC_RX_BUF_OFFSET + len);\n\t\t\tskb_pull(skb, BGMAC_RX_FRAME_OFFSET +\n\t\t\t\t BGMAC_RX_BUF_OFFSET);\n\n\t\t\tskb_checksum_none_assert(skb);\n\t\t\tskb->protocol = eth_type_trans(skb, bgmac->net_dev);\n\t\t\tbgmac->net_dev->stats.rx_bytes += len;\n\t\t\tbgmac->net_dev->stats.rx_packets++;\n\t\t\tnapi_gro_receive(&bgmac->napi, skb);\n\t\t\thandled++;\n\t\t} while (0);\n\n\t\tbgmac_dma_rx_setup_desc(bgmac, ring, ring->start);\n\n\t\tif (++ring->start >= BGMAC_RX_RING_SLOTS)\n\t\t\tring->start = 0;\n\n\t\tif (handled >= weight)  \n\t\t\tbreak;\n\t}\n\n\tbgmac_dma_rx_update_index(bgmac, ring);\n\n\treturn handled;\n}\n\n \nstatic bool bgmac_dma_unaligned(struct bgmac *bgmac,\n\t\t\t\tstruct bgmac_dma_ring *ring,\n\t\t\t\tenum bgmac_dma_ring_type ring_type)\n{\n\tswitch (ring_type) {\n\tcase BGMAC_DMA_RING_TX:\n\t\tbgmac_write(bgmac, ring->mmio_base + BGMAC_DMA_TX_RINGLO,\n\t\t\t    0xff0);\n\t\tif (bgmac_read(bgmac, ring->mmio_base + BGMAC_DMA_TX_RINGLO))\n\t\t\treturn true;\n\t\tbreak;\n\tcase BGMAC_DMA_RING_RX:\n\t\tbgmac_write(bgmac, ring->mmio_base + BGMAC_DMA_RX_RINGLO,\n\t\t\t    0xff0);\n\t\tif (bgmac_read(bgmac, ring->mmio_base + BGMAC_DMA_RX_RINGLO))\n\t\t\treturn true;\n\t\tbreak;\n\t}\n\treturn false;\n}\n\nstatic void bgmac_dma_tx_ring_free(struct bgmac *bgmac,\n\t\t\t\t   struct bgmac_dma_ring *ring)\n{\n\tstruct device *dma_dev = bgmac->dma_dev;\n\tstruct bgmac_dma_desc *dma_desc = ring->cpu_base;\n\tstruct bgmac_slot_info *slot;\n\tint i;\n\n\tfor (i = 0; i < BGMAC_TX_RING_SLOTS; i++) {\n\t\tu32 ctl1 = le32_to_cpu(dma_desc[i].ctl1);\n\t\tunsigned int len = ctl1 & BGMAC_DESC_CTL1_LEN;\n\n\t\tslot = &ring->slots[i];\n\t\tdev_kfree_skb(slot->skb);\n\n\t\tif (!slot->dma_addr)\n\t\t\tcontinue;\n\n\t\tif (slot->skb)\n\t\t\tdma_unmap_single(dma_dev, slot->dma_addr,\n\t\t\t\t\t len, DMA_TO_DEVICE);\n\t\telse\n\t\t\tdma_unmap_page(dma_dev, slot->dma_addr,\n\t\t\t\t       len, DMA_TO_DEVICE);\n\t}\n}\n\nstatic void bgmac_dma_rx_ring_free(struct bgmac *bgmac,\n\t\t\t\t   struct bgmac_dma_ring *ring)\n{\n\tstruct device *dma_dev = bgmac->dma_dev;\n\tstruct bgmac_slot_info *slot;\n\tint i;\n\n\tfor (i = 0; i < BGMAC_RX_RING_SLOTS; i++) {\n\t\tslot = &ring->slots[i];\n\t\tif (!slot->dma_addr)\n\t\t\tcontinue;\n\n\t\tdma_unmap_single(dma_dev, slot->dma_addr,\n\t\t\t\t BGMAC_RX_BUF_SIZE,\n\t\t\t\t DMA_FROM_DEVICE);\n\t\tput_page(virt_to_head_page(slot->buf));\n\t\tslot->dma_addr = 0;\n\t}\n}\n\nstatic void bgmac_dma_ring_desc_free(struct bgmac *bgmac,\n\t\t\t\t     struct bgmac_dma_ring *ring,\n\t\t\t\t     int num_slots)\n{\n\tstruct device *dma_dev = bgmac->dma_dev;\n\tint size;\n\n\tif (!ring->cpu_base)\n\t    return;\n\n\t \n\tsize = num_slots * sizeof(struct bgmac_dma_desc);\n\tdma_free_coherent(dma_dev, size, ring->cpu_base,\n\t\t\t  ring->dma_base);\n}\n\nstatic void bgmac_dma_cleanup(struct bgmac *bgmac)\n{\n\tint i;\n\n\tfor (i = 0; i < BGMAC_MAX_TX_RINGS; i++)\n\t\tbgmac_dma_tx_ring_free(bgmac, &bgmac->tx_ring[i]);\n\n\tfor (i = 0; i < BGMAC_MAX_RX_RINGS; i++)\n\t\tbgmac_dma_rx_ring_free(bgmac, &bgmac->rx_ring[i]);\n}\n\nstatic void bgmac_dma_free(struct bgmac *bgmac)\n{\n\tint i;\n\n\tfor (i = 0; i < BGMAC_MAX_TX_RINGS; i++)\n\t\tbgmac_dma_ring_desc_free(bgmac, &bgmac->tx_ring[i],\n\t\t\t\t\t BGMAC_TX_RING_SLOTS);\n\n\tfor (i = 0; i < BGMAC_MAX_RX_RINGS; i++)\n\t\tbgmac_dma_ring_desc_free(bgmac, &bgmac->rx_ring[i],\n\t\t\t\t\t BGMAC_RX_RING_SLOTS);\n}\n\nstatic int bgmac_dma_alloc(struct bgmac *bgmac)\n{\n\tstruct device *dma_dev = bgmac->dma_dev;\n\tstruct bgmac_dma_ring *ring;\n\tstatic const u16 ring_base[] = { BGMAC_DMA_BASE0, BGMAC_DMA_BASE1,\n\t\t\t\t\t BGMAC_DMA_BASE2, BGMAC_DMA_BASE3, };\n\tint size;  \n\tint i;\n\n\tBUILD_BUG_ON(BGMAC_MAX_TX_RINGS > ARRAY_SIZE(ring_base));\n\tBUILD_BUG_ON(BGMAC_MAX_RX_RINGS > ARRAY_SIZE(ring_base));\n\n\tif (!(bgmac->feature_flags & BGMAC_FEAT_IDM_MASK)) {\n\t\tif (!(bgmac_idm_read(bgmac, BCMA_IOST) & BCMA_IOST_DMA64)) {\n\t\t\tdev_err(bgmac->dev, \"Core does not report 64-bit DMA\\n\");\n\t\t\treturn -ENOTSUPP;\n\t\t}\n\t}\n\n\tfor (i = 0; i < BGMAC_MAX_TX_RINGS; i++) {\n\t\tring = &bgmac->tx_ring[i];\n\t\tring->mmio_base = ring_base[i];\n\n\t\t \n\t\tsize = BGMAC_TX_RING_SLOTS * sizeof(struct bgmac_dma_desc);\n\t\tring->cpu_base = dma_alloc_coherent(dma_dev, size,\n\t\t\t\t\t\t    &ring->dma_base,\n\t\t\t\t\t\t    GFP_KERNEL);\n\t\tif (!ring->cpu_base) {\n\t\t\tdev_err(bgmac->dev, \"Allocation of TX ring 0x%X failed\\n\",\n\t\t\t\tring->mmio_base);\n\t\t\tgoto err_dma_free;\n\t\t}\n\n\t\tring->unaligned = bgmac_dma_unaligned(bgmac, ring,\n\t\t\t\t\t\t      BGMAC_DMA_RING_TX);\n\t\tif (ring->unaligned)\n\t\t\tring->index_base = lower_32_bits(ring->dma_base);\n\t\telse\n\t\t\tring->index_base = 0;\n\n\t\t \n\t}\n\n\tfor (i = 0; i < BGMAC_MAX_RX_RINGS; i++) {\n\t\tring = &bgmac->rx_ring[i];\n\t\tring->mmio_base = ring_base[i];\n\n\t\t \n\t\tsize = BGMAC_RX_RING_SLOTS * sizeof(struct bgmac_dma_desc);\n\t\tring->cpu_base = dma_alloc_coherent(dma_dev, size,\n\t\t\t\t\t\t    &ring->dma_base,\n\t\t\t\t\t\t    GFP_KERNEL);\n\t\tif (!ring->cpu_base) {\n\t\t\tdev_err(bgmac->dev, \"Allocation of RX ring 0x%X failed\\n\",\n\t\t\t\tring->mmio_base);\n\t\t\tgoto err_dma_free;\n\t\t}\n\n\t\tring->unaligned = bgmac_dma_unaligned(bgmac, ring,\n\t\t\t\t\t\t      BGMAC_DMA_RING_RX);\n\t\tif (ring->unaligned)\n\t\t\tring->index_base = lower_32_bits(ring->dma_base);\n\t\telse\n\t\t\tring->index_base = 0;\n\t}\n\n\treturn 0;\n\nerr_dma_free:\n\tbgmac_dma_free(bgmac);\n\treturn -ENOMEM;\n}\n\nstatic int bgmac_dma_init(struct bgmac *bgmac)\n{\n\tstruct bgmac_dma_ring *ring;\n\tint i, err;\n\n\tfor (i = 0; i < BGMAC_MAX_TX_RINGS; i++) {\n\t\tring = &bgmac->tx_ring[i];\n\n\t\tif (!ring->unaligned)\n\t\t\tbgmac_dma_tx_enable(bgmac, ring);\n\t\tbgmac_write(bgmac, ring->mmio_base + BGMAC_DMA_TX_RINGLO,\n\t\t\t    lower_32_bits(ring->dma_base));\n\t\tbgmac_write(bgmac, ring->mmio_base + BGMAC_DMA_TX_RINGHI,\n\t\t\t    upper_32_bits(ring->dma_base));\n\t\tif (ring->unaligned)\n\t\t\tbgmac_dma_tx_enable(bgmac, ring);\n\n\t\tring->start = 0;\n\t\tring->end = 0;\t \n\t}\n\n\tfor (i = 0; i < BGMAC_MAX_RX_RINGS; i++) {\n\t\tint j;\n\n\t\tring = &bgmac->rx_ring[i];\n\n\t\tif (!ring->unaligned)\n\t\t\tbgmac_dma_rx_enable(bgmac, ring);\n\t\tbgmac_write(bgmac, ring->mmio_base + BGMAC_DMA_RX_RINGLO,\n\t\t\t    lower_32_bits(ring->dma_base));\n\t\tbgmac_write(bgmac, ring->mmio_base + BGMAC_DMA_RX_RINGHI,\n\t\t\t    upper_32_bits(ring->dma_base));\n\t\tif (ring->unaligned)\n\t\t\tbgmac_dma_rx_enable(bgmac, ring);\n\n\t\tring->start = 0;\n\t\tring->end = 0;\n\t\tfor (j = 0; j < BGMAC_RX_RING_SLOTS; j++) {\n\t\t\terr = bgmac_dma_rx_skb_for_slot(bgmac, &ring->slots[j]);\n\t\t\tif (err)\n\t\t\t\tgoto error;\n\n\t\t\tbgmac_dma_rx_setup_desc(bgmac, ring, j);\n\t\t}\n\n\t\tbgmac_dma_rx_update_index(bgmac, ring);\n\t}\n\n\treturn 0;\n\nerror:\n\tbgmac_dma_cleanup(bgmac);\n\treturn err;\n}\n\n\n \n\n \nstatic void bgmac_umac_cmd_maskset(struct bgmac *bgmac, u32 mask, u32 set,\n\t\t\t\t   bool force)\n{\n\tu32 cmdcfg = bgmac_umac_read(bgmac, UMAC_CMD);\n\tu32 new_val = (cmdcfg & mask) | set;\n\tu32 cmdcfg_sr;\n\n\tif (bgmac->feature_flags & BGMAC_FEAT_CMDCFG_SR_REV4)\n\t\tcmdcfg_sr = CMD_SW_RESET;\n\telse\n\t\tcmdcfg_sr = CMD_SW_RESET_OLD;\n\n\tbgmac_umac_maskset(bgmac, UMAC_CMD, ~0, cmdcfg_sr);\n\tudelay(2);\n\n\tif (new_val != cmdcfg || force)\n\t\tbgmac_umac_write(bgmac, UMAC_CMD, new_val);\n\n\tbgmac_umac_maskset(bgmac, UMAC_CMD, ~cmdcfg_sr, 0);\n\tudelay(2);\n}\n\nstatic void bgmac_write_mac_address(struct bgmac *bgmac, const u8 *addr)\n{\n\tu32 tmp;\n\n\ttmp = (addr[0] << 24) | (addr[1] << 16) | (addr[2] << 8) | addr[3];\n\tbgmac_umac_write(bgmac, UMAC_MAC0, tmp);\n\ttmp = (addr[4] << 8) | addr[5];\n\tbgmac_umac_write(bgmac, UMAC_MAC1, tmp);\n}\n\nstatic void bgmac_set_rx_mode(struct net_device *net_dev)\n{\n\tstruct bgmac *bgmac = netdev_priv(net_dev);\n\n\tif (net_dev->flags & IFF_PROMISC)\n\t\tbgmac_umac_cmd_maskset(bgmac, ~0, CMD_PROMISC, true);\n\telse\n\t\tbgmac_umac_cmd_maskset(bgmac, ~CMD_PROMISC, 0, true);\n}\n\n#if 0  \nstatic void bgmac_chip_stats_update(struct bgmac *bgmac)\n{\n\tint i;\n\n\tif (!(bgmac->feature_flags & BGMAC_FEAT_NO_CLR_MIB)) {\n\t\tfor (i = 0; i < BGMAC_NUM_MIB_TX_REGS; i++)\n\t\t\tbgmac->mib_tx_regs[i] =\n\t\t\t\tbgmac_read(bgmac,\n\t\t\t\t\t   BGMAC_TX_GOOD_OCTETS + (i * 4));\n\t\tfor (i = 0; i < BGMAC_NUM_MIB_RX_REGS; i++)\n\t\t\tbgmac->mib_rx_regs[i] =\n\t\t\t\tbgmac_read(bgmac,\n\t\t\t\t\t   BGMAC_RX_GOOD_OCTETS + (i * 4));\n\t}\n\n\t \n}\n#endif\n\nstatic void bgmac_clear_mib(struct bgmac *bgmac)\n{\n\tint i;\n\n\tif (bgmac->feature_flags & BGMAC_FEAT_NO_CLR_MIB)\n\t\treturn;\n\n\tbgmac_set(bgmac, BGMAC_DEV_CTL, BGMAC_DC_MROR);\n\tfor (i = 0; i < BGMAC_NUM_MIB_TX_REGS; i++)\n\t\tbgmac_read(bgmac, BGMAC_TX_GOOD_OCTETS + (i * 4));\n\tfor (i = 0; i < BGMAC_NUM_MIB_RX_REGS; i++)\n\t\tbgmac_read(bgmac, BGMAC_RX_GOOD_OCTETS + (i * 4));\n}\n\n \nstatic void bgmac_mac_speed(struct bgmac *bgmac)\n{\n\tu32 mask = ~(CMD_SPEED_MASK << CMD_SPEED_SHIFT | CMD_HD_EN);\n\tu32 set = 0;\n\n\tswitch (bgmac->mac_speed) {\n\tcase SPEED_10:\n\t\tset |= CMD_SPEED_10 << CMD_SPEED_SHIFT;\n\t\tbreak;\n\tcase SPEED_100:\n\t\tset |= CMD_SPEED_100 << CMD_SPEED_SHIFT;\n\t\tbreak;\n\tcase SPEED_1000:\n\t\tset |= CMD_SPEED_1000 << CMD_SPEED_SHIFT;\n\t\tbreak;\n\tcase SPEED_2500:\n\t\tset |= CMD_SPEED_2500 << CMD_SPEED_SHIFT;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(bgmac->dev, \"Unsupported speed: %d\\n\",\n\t\t\tbgmac->mac_speed);\n\t}\n\n\tif (bgmac->mac_duplex == DUPLEX_HALF)\n\t\tset |= CMD_HD_EN;\n\n\tbgmac_umac_cmd_maskset(bgmac, mask, set, true);\n}\n\nstatic void bgmac_miiconfig(struct bgmac *bgmac)\n{\n\tif (bgmac->feature_flags & BGMAC_FEAT_FORCE_SPEED_2500) {\n\t\tif (!(bgmac->feature_flags & BGMAC_FEAT_IDM_MASK)) {\n\t\t\tbgmac_idm_write(bgmac, BCMA_IOCTL,\n\t\t\t\t\tbgmac_idm_read(bgmac, BCMA_IOCTL) |\n\t\t\t\t\t0x40 | BGMAC_BCMA_IOCTL_SW_CLKEN);\n\t\t}\n\t\tbgmac->mac_speed = SPEED_2500;\n\t\tbgmac->mac_duplex = DUPLEX_FULL;\n\t\tbgmac_mac_speed(bgmac);\n\t} else {\n\t\tu8 imode;\n\n\t\timode = (bgmac_read(bgmac, BGMAC_DEV_STATUS) &\n\t\t\tBGMAC_DS_MM_MASK) >> BGMAC_DS_MM_SHIFT;\n\t\tif (imode == 0 || imode == 1) {\n\t\t\tbgmac->mac_speed = SPEED_100;\n\t\t\tbgmac->mac_duplex = DUPLEX_FULL;\n\t\t\tbgmac_mac_speed(bgmac);\n\t\t}\n\t}\n}\n\nstatic void bgmac_chip_reset_idm_config(struct bgmac *bgmac)\n{\n\tu32 iost;\n\n\tiost = bgmac_idm_read(bgmac, BCMA_IOST);\n\tif (bgmac->feature_flags & BGMAC_FEAT_IOST_ATTACHED)\n\t\tiost &= ~BGMAC_BCMA_IOST_ATTACHED;\n\n\t \n\tif (!(bgmac->feature_flags & BGMAC_FEAT_NO_RESET)) {\n\t\tu32 flags = 0;\n\n\t\tif (iost & BGMAC_BCMA_IOST_ATTACHED) {\n\t\t\tflags = BGMAC_BCMA_IOCTL_SW_CLKEN;\n\t\t\tif (bgmac->in_init || !bgmac->has_robosw)\n\t\t\t\tflags |= BGMAC_BCMA_IOCTL_SW_RESET;\n\t\t}\n\t\tbgmac_clk_enable(bgmac, flags);\n\t}\n\n\tif (iost & BGMAC_BCMA_IOST_ATTACHED && (bgmac->in_init || !bgmac->has_robosw))\n\t\tbgmac_idm_write(bgmac, BCMA_IOCTL,\n\t\t\t\tbgmac_idm_read(bgmac, BCMA_IOCTL) &\n\t\t\t\t~BGMAC_BCMA_IOCTL_SW_RESET);\n}\n\n \nstatic void bgmac_chip_reset(struct bgmac *bgmac)\n{\n\tu32 cmdcfg_sr;\n\tint i;\n\n\tif (bgmac_clk_enabled(bgmac)) {\n\t\tif (!bgmac->stats_grabbed) {\n\t\t\t \n\t\t\tbgmac->stats_grabbed = true;\n\t\t}\n\n\t\tfor (i = 0; i < BGMAC_MAX_TX_RINGS; i++)\n\t\t\tbgmac_dma_tx_reset(bgmac, &bgmac->tx_ring[i]);\n\n\t\tbgmac_umac_cmd_maskset(bgmac, ~0, CMD_LCL_LOOP_EN, false);\n\t\tudelay(1);\n\n\t\tfor (i = 0; i < BGMAC_MAX_RX_RINGS; i++)\n\t\t\tbgmac_dma_rx_reset(bgmac, &bgmac->rx_ring[i]);\n\n\t\t \n\t}\n\n\tif (!(bgmac->feature_flags & BGMAC_FEAT_IDM_MASK))\n\t\tbgmac_chip_reset_idm_config(bgmac);\n\n\t \n\tif (bgmac->feature_flags & BGMAC_FEAT_MISC_PLL_REQ) {\n\t\tbgmac_set(bgmac, BCMA_CLKCTLST,\n\t\t\t  BGMAC_BCMA_CLKCTLST_MISC_PLL_REQ);\n\t\tbgmac_wait_value(bgmac, BCMA_CLKCTLST,\n\t\t\t\t BGMAC_BCMA_CLKCTLST_MISC_PLL_ST,\n\t\t\t\t BGMAC_BCMA_CLKCTLST_MISC_PLL_ST,\n\t\t\t\t 1000);\n\t}\n\n\tif (bgmac->feature_flags & BGMAC_FEAT_SW_TYPE_PHY) {\n\t\tu8 et_swtype = 0;\n\t\tu8 sw_type = BGMAC_CHIPCTL_1_SW_TYPE_EPHY |\n\t\t\t     BGMAC_CHIPCTL_1_IF_TYPE_MII;\n\t\tchar buf[4];\n\n\t\tif (bcm47xx_nvram_getenv(\"et_swtype\", buf, sizeof(buf)) > 0) {\n\t\t\tif (kstrtou8(buf, 0, &et_swtype))\n\t\t\t\tdev_err(bgmac->dev, \"Failed to parse et_swtype (%s)\\n\",\n\t\t\t\t\tbuf);\n\t\t\tet_swtype &= 0x0f;\n\t\t\tet_swtype <<= 4;\n\t\t\tsw_type = et_swtype;\n\t\t} else if (bgmac->feature_flags & BGMAC_FEAT_SW_TYPE_EPHYRMII) {\n\t\t\tsw_type = BGMAC_CHIPCTL_1_IF_TYPE_RMII |\n\t\t\t\t  BGMAC_CHIPCTL_1_SW_TYPE_EPHYRMII;\n\t\t} else if (bgmac->feature_flags & BGMAC_FEAT_SW_TYPE_RGMII) {\n\t\t\tsw_type = BGMAC_CHIPCTL_1_IF_TYPE_RGMII |\n\t\t\t\t  BGMAC_CHIPCTL_1_SW_TYPE_RGMII;\n\t\t}\n\t\tbgmac_cco_ctl_maskset(bgmac, 1, ~(BGMAC_CHIPCTL_1_IF_TYPE_MASK |\n\t\t\t\t\t\t  BGMAC_CHIPCTL_1_SW_TYPE_MASK),\n\t\t\t\t      sw_type);\n\t} else if (bgmac->feature_flags & BGMAC_FEAT_CC4_IF_SW_TYPE) {\n\t\tu32 sw_type = BGMAC_CHIPCTL_4_IF_TYPE_MII |\n\t\t\t      BGMAC_CHIPCTL_4_SW_TYPE_EPHY;\n\t\tu8 et_swtype = 0;\n\t\tchar buf[4];\n\n\t\tif (bcm47xx_nvram_getenv(\"et_swtype\", buf, sizeof(buf)) > 0) {\n\t\t\tif (kstrtou8(buf, 0, &et_swtype))\n\t\t\t\tdev_err(bgmac->dev, \"Failed to parse et_swtype (%s)\\n\",\n\t\t\t\t\tbuf);\n\t\t\tsw_type = (et_swtype & 0x0f) << 12;\n\t\t} else if (bgmac->feature_flags & BGMAC_FEAT_CC4_IF_SW_TYPE_RGMII) {\n\t\t\tsw_type = BGMAC_CHIPCTL_4_IF_TYPE_RGMII |\n\t\t\t\t  BGMAC_CHIPCTL_4_SW_TYPE_RGMII;\n\t\t}\n\t\tbgmac_cco_ctl_maskset(bgmac, 4, ~(BGMAC_CHIPCTL_4_IF_TYPE_MASK |\n\t\t\t\t\t\t  BGMAC_CHIPCTL_4_SW_TYPE_MASK),\n\t\t\t\t      sw_type);\n\t} else if (bgmac->feature_flags & BGMAC_FEAT_CC7_IF_TYPE_RGMII) {\n\t\tbgmac_cco_ctl_maskset(bgmac, 7, ~BGMAC_CHIPCTL_7_IF_TYPE_MASK,\n\t\t\t\t      BGMAC_CHIPCTL_7_IF_TYPE_RGMII);\n\t}\n\n\t \n\tif (bgmac->feature_flags & BGMAC_FEAT_CMDCFG_SR_REV4)\n\t\tcmdcfg_sr = CMD_SW_RESET;\n\telse\n\t\tcmdcfg_sr = CMD_SW_RESET_OLD;\n\n\tbgmac_umac_cmd_maskset(bgmac,\n\t\t\t       ~(CMD_TX_EN |\n\t\t\t\t CMD_RX_EN |\n\t\t\t\t CMD_RX_PAUSE_IGNORE |\n\t\t\t\t CMD_TX_ADDR_INS |\n\t\t\t\t CMD_HD_EN |\n\t\t\t\t CMD_LCL_LOOP_EN |\n\t\t\t\t CMD_CNTL_FRM_EN |\n\t\t\t\t CMD_RMT_LOOP_EN |\n\t\t\t\t CMD_RX_ERR_DISC |\n\t\t\t\t CMD_PRBL_EN |\n\t\t\t\t CMD_TX_PAUSE_IGNORE |\n\t\t\t\t CMD_PAD_EN |\n\t\t\t\t CMD_PAUSE_FWD),\n\t\t\t       CMD_PROMISC |\n\t\t\t       CMD_NO_LEN_CHK |\n\t\t\t       CMD_CNTL_FRM_EN |\n\t\t\t       cmdcfg_sr,\n\t\t\t       false);\n\tbgmac->mac_speed = SPEED_UNKNOWN;\n\tbgmac->mac_duplex = DUPLEX_UNKNOWN;\n\n\tbgmac_clear_mib(bgmac);\n\tif (bgmac->feature_flags & BGMAC_FEAT_CMN_PHY_CTL)\n\t\tbgmac_cmn_maskset32(bgmac, BCMA_GMAC_CMN_PHY_CTL, ~0,\n\t\t\t\t    BCMA_GMAC_CMN_PC_MTE);\n\telse\n\t\tbgmac_set(bgmac, BGMAC_PHY_CNTL, BGMAC_PC_MTE);\n\tbgmac_miiconfig(bgmac);\n\tif (bgmac->mii_bus)\n\t\tbgmac->mii_bus->reset(bgmac->mii_bus);\n\n\tnetdev_reset_queue(bgmac->net_dev);\n}\n\nstatic void bgmac_chip_intrs_on(struct bgmac *bgmac)\n{\n\tbgmac_write(bgmac, BGMAC_INT_MASK, bgmac->int_mask);\n}\n\nstatic void bgmac_chip_intrs_off(struct bgmac *bgmac)\n{\n\tbgmac_write(bgmac, BGMAC_INT_MASK, 0);\n\tbgmac_read(bgmac, BGMAC_INT_MASK);\n}\n\n \nstatic void bgmac_enable(struct bgmac *bgmac)\n{\n\tu32 cmdcfg_sr;\n\tu32 cmdcfg;\n\tu32 mode;\n\n\tif (bgmac->feature_flags & BGMAC_FEAT_CMDCFG_SR_REV4)\n\t\tcmdcfg_sr = CMD_SW_RESET;\n\telse\n\t\tcmdcfg_sr = CMD_SW_RESET_OLD;\n\n\tcmdcfg = bgmac_umac_read(bgmac, UMAC_CMD);\n\tbgmac_umac_cmd_maskset(bgmac, ~(CMD_TX_EN | CMD_RX_EN),\n\t\t\t       cmdcfg_sr, true);\n\tudelay(2);\n\tcmdcfg |= CMD_TX_EN | CMD_RX_EN;\n\tbgmac_umac_write(bgmac, UMAC_CMD, cmdcfg);\n\n\tmode = (bgmac_read(bgmac, BGMAC_DEV_STATUS) & BGMAC_DS_MM_MASK) >>\n\t\tBGMAC_DS_MM_SHIFT;\n\tif (bgmac->feature_flags & BGMAC_FEAT_CLKCTLST || mode != 0)\n\t\tbgmac_set(bgmac, BCMA_CLKCTLST, BCMA_CLKCTLST_FORCEHT);\n\tif (!(bgmac->feature_flags & BGMAC_FEAT_CLKCTLST) && mode == 2)\n\t\tbgmac_cco_ctl_maskset(bgmac, 1, ~0,\n\t\t\t\t      BGMAC_CHIPCTL_1_RXC_DLL_BYPASS);\n\n\tif (bgmac->feature_flags & (BGMAC_FEAT_FLW_CTRL1 |\n\t\t\t\t    BGMAC_FEAT_FLW_CTRL2)) {\n\t\tu32 fl_ctl;\n\n\t\tif (bgmac->feature_flags & BGMAC_FEAT_FLW_CTRL1)\n\t\t\tfl_ctl = 0x2300e1;\n\t\telse\n\t\t\tfl_ctl = 0x03cb04cb;\n\n\t\tbgmac_write(bgmac, BGMAC_FLOW_CTL_THRESH, fl_ctl);\n\t\tbgmac_umac_write(bgmac, UMAC_PAUSE_CTRL, 0x27fff);\n\t}\n\n\tif (bgmac->feature_flags & BGMAC_FEAT_SET_RXQ_CLK) {\n\t\tu32 rxq_ctl;\n\t\tu16 bp_clk;\n\t\tu8 mdp;\n\n\t\trxq_ctl = bgmac_read(bgmac, BGMAC_RXQ_CTL);\n\t\trxq_ctl &= ~BGMAC_RXQ_CTL_MDP_MASK;\n\t\tbp_clk = bgmac_get_bus_clock(bgmac) / 1000000;\n\t\tmdp = (bp_clk * 128 / 1000) - 3;\n\t\trxq_ctl |= (mdp << BGMAC_RXQ_CTL_MDP_SHIFT);\n\t\tbgmac_write(bgmac, BGMAC_RXQ_CTL, rxq_ctl);\n\t}\n}\n\n \nstatic void bgmac_chip_init(struct bgmac *bgmac)\n{\n\t \n\tbgmac_write(bgmac, BGMAC_INT_STATUS, ~0);\n\n\t \n\tbgmac_write(bgmac, BGMAC_INT_RECV_LAZY, 1 << BGMAC_IRL_FC_SHIFT);\n\n\t \n\tbgmac_umac_cmd_maskset(bgmac, ~CMD_RX_PAUSE_IGNORE, 0, true);\n\n\tbgmac_set_rx_mode(bgmac->net_dev);\n\n\tbgmac_write_mac_address(bgmac, bgmac->net_dev->dev_addr);\n\n\tif (bgmac->loopback)\n\t\tbgmac_umac_cmd_maskset(bgmac, ~0, CMD_LCL_LOOP_EN, false);\n\telse\n\t\tbgmac_umac_cmd_maskset(bgmac, ~CMD_LCL_LOOP_EN, 0, false);\n\n\tbgmac_umac_write(bgmac, UMAC_MAX_FRAME_LEN, 32 + ETHER_MAX_LEN);\n\n\tbgmac_chip_intrs_on(bgmac);\n\n\tbgmac_enable(bgmac);\n}\n\nstatic irqreturn_t bgmac_interrupt(int irq, void *dev_id)\n{\n\tstruct bgmac *bgmac = netdev_priv(dev_id);\n\n\tu32 int_status = bgmac_read(bgmac, BGMAC_INT_STATUS);\n\tint_status &= bgmac->int_mask;\n\n\tif (!int_status)\n\t\treturn IRQ_NONE;\n\n\tint_status &= ~(BGMAC_IS_TX0 | BGMAC_IS_RX);\n\tif (int_status)\n\t\tdev_err(bgmac->dev, \"Unknown IRQs: 0x%08X\\n\", int_status);\n\n\t \n\tbgmac_chip_intrs_off(bgmac);\n\n\tnapi_schedule(&bgmac->napi);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int bgmac_poll(struct napi_struct *napi, int weight)\n{\n\tstruct bgmac *bgmac = container_of(napi, struct bgmac, napi);\n\tint handled = 0;\n\n\t \n\tbgmac_write(bgmac, BGMAC_INT_STATUS, ~0);\n\n\tbgmac_dma_tx_free(bgmac, &bgmac->tx_ring[0]);\n\thandled += bgmac_dma_rx_read(bgmac, &bgmac->rx_ring[0], weight);\n\n\t \n\tif (bgmac_read(bgmac, BGMAC_INT_STATUS) & (BGMAC_IS_TX0 | BGMAC_IS_RX))\n\t\treturn weight;\n\n\tif (handled < weight) {\n\t\tnapi_complete_done(napi, handled);\n\t\tbgmac_chip_intrs_on(bgmac);\n\t}\n\n\treturn handled;\n}\n\n \n\nstatic int bgmac_open(struct net_device *net_dev)\n{\n\tstruct bgmac *bgmac = netdev_priv(net_dev);\n\tint err = 0;\n\n\tbgmac_chip_reset(bgmac);\n\n\terr = bgmac_dma_init(bgmac);\n\tif (err)\n\t\treturn err;\n\n\t \n\tbgmac_chip_init(bgmac);\n\n\terr = request_irq(bgmac->irq, bgmac_interrupt, IRQF_SHARED,\n\t\t\t  net_dev->name, net_dev);\n\tif (err < 0) {\n\t\tdev_err(bgmac->dev, \"IRQ request error: %d!\\n\", err);\n\t\tbgmac_dma_cleanup(bgmac);\n\t\treturn err;\n\t}\n\tnapi_enable(&bgmac->napi);\n\n\tphy_start(net_dev->phydev);\n\n\tnetif_start_queue(net_dev);\n\n\treturn 0;\n}\n\nstatic int bgmac_stop(struct net_device *net_dev)\n{\n\tstruct bgmac *bgmac = netdev_priv(net_dev);\n\n\tnetif_carrier_off(net_dev);\n\n\tphy_stop(net_dev->phydev);\n\n\tnapi_disable(&bgmac->napi);\n\tbgmac_chip_intrs_off(bgmac);\n\tfree_irq(bgmac->irq, net_dev);\n\n\tbgmac_chip_reset(bgmac);\n\tbgmac_dma_cleanup(bgmac);\n\n\treturn 0;\n}\n\nstatic netdev_tx_t bgmac_start_xmit(struct sk_buff *skb,\n\t\t\t\t    struct net_device *net_dev)\n{\n\tstruct bgmac *bgmac = netdev_priv(net_dev);\n\tstruct bgmac_dma_ring *ring;\n\n\t \n\tring = &bgmac->tx_ring[0];\n\treturn bgmac_dma_tx_add(bgmac, ring, skb);\n}\n\nstatic int bgmac_set_mac_address(struct net_device *net_dev, void *addr)\n{\n\tstruct bgmac *bgmac = netdev_priv(net_dev);\n\tstruct sockaddr *sa = addr;\n\tint ret;\n\n\tret = eth_prepare_mac_addr_change(net_dev, addr);\n\tif (ret < 0)\n\t\treturn ret;\n\n\teth_hw_addr_set(net_dev, sa->sa_data);\n\tbgmac_write_mac_address(bgmac, net_dev->dev_addr);\n\n\teth_commit_mac_addr_change(net_dev, addr);\n\treturn 0;\n}\n\nstatic int bgmac_change_mtu(struct net_device *net_dev, int mtu)\n{\n\tstruct bgmac *bgmac = netdev_priv(net_dev);\n\n\tbgmac_umac_write(bgmac, UMAC_MAX_FRAME_LEN, 32 + mtu);\n\treturn 0;\n}\n\nstatic const struct net_device_ops bgmac_netdev_ops = {\n\t.ndo_open\t\t= bgmac_open,\n\t.ndo_stop\t\t= bgmac_stop,\n\t.ndo_start_xmit\t\t= bgmac_start_xmit,\n\t.ndo_set_rx_mode\t= bgmac_set_rx_mode,\n\t.ndo_set_mac_address\t= bgmac_set_mac_address,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_eth_ioctl           = phy_do_ioctl_running,\n\t.ndo_change_mtu\t\t= bgmac_change_mtu,\n};\n\n \n\nstruct bgmac_stat {\n\tu8 size;\n\tu32 offset;\n\tconst char *name;\n};\n\nstatic struct bgmac_stat bgmac_get_strings_stats[] = {\n\t{ 8, BGMAC_TX_GOOD_OCTETS, \"tx_good_octets\" },\n\t{ 4, BGMAC_TX_GOOD_PKTS, \"tx_good\" },\n\t{ 8, BGMAC_TX_OCTETS, \"tx_octets\" },\n\t{ 4, BGMAC_TX_PKTS, \"tx_pkts\" },\n\t{ 4, BGMAC_TX_BROADCAST_PKTS, \"tx_broadcast\" },\n\t{ 4, BGMAC_TX_MULTICAST_PKTS, \"tx_multicast\" },\n\t{ 4, BGMAC_TX_LEN_64, \"tx_64\" },\n\t{ 4, BGMAC_TX_LEN_65_TO_127, \"tx_65_127\" },\n\t{ 4, BGMAC_TX_LEN_128_TO_255, \"tx_128_255\" },\n\t{ 4, BGMAC_TX_LEN_256_TO_511, \"tx_256_511\" },\n\t{ 4, BGMAC_TX_LEN_512_TO_1023, \"tx_512_1023\" },\n\t{ 4, BGMAC_TX_LEN_1024_TO_1522, \"tx_1024_1522\" },\n\t{ 4, BGMAC_TX_LEN_1523_TO_2047, \"tx_1523_2047\" },\n\t{ 4, BGMAC_TX_LEN_2048_TO_4095, \"tx_2048_4095\" },\n\t{ 4, BGMAC_TX_LEN_4096_TO_8191, \"tx_4096_8191\" },\n\t{ 4, BGMAC_TX_LEN_8192_TO_MAX, \"tx_8192_max\" },\n\t{ 4, BGMAC_TX_JABBER_PKTS, \"tx_jabber\" },\n\t{ 4, BGMAC_TX_OVERSIZE_PKTS, \"tx_oversize\" },\n\t{ 4, BGMAC_TX_FRAGMENT_PKTS, \"tx_fragment\" },\n\t{ 4, BGMAC_TX_UNDERRUNS, \"tx_underruns\" },\n\t{ 4, BGMAC_TX_TOTAL_COLS, \"tx_total_cols\" },\n\t{ 4, BGMAC_TX_SINGLE_COLS, \"tx_single_cols\" },\n\t{ 4, BGMAC_TX_MULTIPLE_COLS, \"tx_multiple_cols\" },\n\t{ 4, BGMAC_TX_EXCESSIVE_COLS, \"tx_excessive_cols\" },\n\t{ 4, BGMAC_TX_LATE_COLS, \"tx_late_cols\" },\n\t{ 4, BGMAC_TX_DEFERED, \"tx_defered\" },\n\t{ 4, BGMAC_TX_CARRIER_LOST, \"tx_carrier_lost\" },\n\t{ 4, BGMAC_TX_PAUSE_PKTS, \"tx_pause\" },\n\t{ 4, BGMAC_TX_UNI_PKTS, \"tx_unicast\" },\n\t{ 4, BGMAC_TX_Q0_PKTS, \"tx_q0\" },\n\t{ 8, BGMAC_TX_Q0_OCTETS, \"tx_q0_octets\" },\n\t{ 4, BGMAC_TX_Q1_PKTS, \"tx_q1\" },\n\t{ 8, BGMAC_TX_Q1_OCTETS, \"tx_q1_octets\" },\n\t{ 4, BGMAC_TX_Q2_PKTS, \"tx_q2\" },\n\t{ 8, BGMAC_TX_Q2_OCTETS, \"tx_q2_octets\" },\n\t{ 4, BGMAC_TX_Q3_PKTS, \"tx_q3\" },\n\t{ 8, BGMAC_TX_Q3_OCTETS, \"tx_q3_octets\" },\n\t{ 8, BGMAC_RX_GOOD_OCTETS, \"rx_good_octets\" },\n\t{ 4, BGMAC_RX_GOOD_PKTS, \"rx_good\" },\n\t{ 8, BGMAC_RX_OCTETS, \"rx_octets\" },\n\t{ 4, BGMAC_RX_PKTS, \"rx_pkts\" },\n\t{ 4, BGMAC_RX_BROADCAST_PKTS, \"rx_broadcast\" },\n\t{ 4, BGMAC_RX_MULTICAST_PKTS, \"rx_multicast\" },\n\t{ 4, BGMAC_RX_LEN_64, \"rx_64\" },\n\t{ 4, BGMAC_RX_LEN_65_TO_127, \"rx_65_127\" },\n\t{ 4, BGMAC_RX_LEN_128_TO_255, \"rx_128_255\" },\n\t{ 4, BGMAC_RX_LEN_256_TO_511, \"rx_256_511\" },\n\t{ 4, BGMAC_RX_LEN_512_TO_1023, \"rx_512_1023\" },\n\t{ 4, BGMAC_RX_LEN_1024_TO_1522, \"rx_1024_1522\" },\n\t{ 4, BGMAC_RX_LEN_1523_TO_2047, \"rx_1523_2047\" },\n\t{ 4, BGMAC_RX_LEN_2048_TO_4095, \"rx_2048_4095\" },\n\t{ 4, BGMAC_RX_LEN_4096_TO_8191, \"rx_4096_8191\" },\n\t{ 4, BGMAC_RX_LEN_8192_TO_MAX, \"rx_8192_max\" },\n\t{ 4, BGMAC_RX_JABBER_PKTS, \"rx_jabber\" },\n\t{ 4, BGMAC_RX_OVERSIZE_PKTS, \"rx_oversize\" },\n\t{ 4, BGMAC_RX_FRAGMENT_PKTS, \"rx_fragment\" },\n\t{ 4, BGMAC_RX_MISSED_PKTS, \"rx_missed\" },\n\t{ 4, BGMAC_RX_CRC_ALIGN_ERRS, \"rx_crc_align\" },\n\t{ 4, BGMAC_RX_UNDERSIZE, \"rx_undersize\" },\n\t{ 4, BGMAC_RX_CRC_ERRS, \"rx_crc\" },\n\t{ 4, BGMAC_RX_ALIGN_ERRS, \"rx_align\" },\n\t{ 4, BGMAC_RX_SYMBOL_ERRS, \"rx_symbol\" },\n\t{ 4, BGMAC_RX_PAUSE_PKTS, \"rx_pause\" },\n\t{ 4, BGMAC_RX_NONPAUSE_PKTS, \"rx_nonpause\" },\n\t{ 4, BGMAC_RX_SACHANGES, \"rx_sa_changes\" },\n\t{ 4, BGMAC_RX_UNI_PKTS, \"rx_unicast\" },\n};\n\n#define BGMAC_STATS_LEN\tARRAY_SIZE(bgmac_get_strings_stats)\n\nstatic int bgmac_get_sset_count(struct net_device *dev, int string_set)\n{\n\tswitch (string_set) {\n\tcase ETH_SS_STATS:\n\t\treturn BGMAC_STATS_LEN;\n\t}\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic void bgmac_get_strings(struct net_device *dev, u32 stringset,\n\t\t\t      u8 *data)\n{\n\tint i;\n\n\tif (stringset != ETH_SS_STATS)\n\t\treturn;\n\n\tfor (i = 0; i < BGMAC_STATS_LEN; i++)\n\t\tstrscpy(data + i * ETH_GSTRING_LEN,\n\t\t\tbgmac_get_strings_stats[i].name, ETH_GSTRING_LEN);\n}\n\nstatic void bgmac_get_ethtool_stats(struct net_device *dev,\n\t\t\t\t    struct ethtool_stats *ss, uint64_t *data)\n{\n\tstruct bgmac *bgmac = netdev_priv(dev);\n\tconst struct bgmac_stat *s;\n\tunsigned int i;\n\tu64 val;\n\n\tif (!netif_running(dev))\n\t\treturn;\n\n\tfor (i = 0; i < BGMAC_STATS_LEN; i++) {\n\t\ts = &bgmac_get_strings_stats[i];\n\t\tval = 0;\n\t\tif (s->size == 8)\n\t\t\tval = (u64)bgmac_read(bgmac, s->offset + 4) << 32;\n\t\tval |= bgmac_read(bgmac, s->offset);\n\t\tdata[i] = val;\n\t}\n}\n\nstatic void bgmac_get_drvinfo(struct net_device *net_dev,\n\t\t\t      struct ethtool_drvinfo *info)\n{\n\tstrscpy(info->driver, KBUILD_MODNAME, sizeof(info->driver));\n\tstrscpy(info->bus_info, \"AXI\", sizeof(info->bus_info));\n}\n\nstatic const struct ethtool_ops bgmac_ethtool_ops = {\n\t.get_strings\t\t= bgmac_get_strings,\n\t.get_sset_count\t\t= bgmac_get_sset_count,\n\t.get_ethtool_stats\t= bgmac_get_ethtool_stats,\n\t.get_drvinfo\t\t= bgmac_get_drvinfo,\n\t.get_link_ksettings     = phy_ethtool_get_link_ksettings,\n\t.set_link_ksettings     = phy_ethtool_set_link_ksettings,\n};\n\n \n\nvoid bgmac_adjust_link(struct net_device *net_dev)\n{\n\tstruct bgmac *bgmac = netdev_priv(net_dev);\n\tstruct phy_device *phy_dev = net_dev->phydev;\n\tbool update = false;\n\n\tif (phy_dev->link) {\n\t\tif (phy_dev->speed != bgmac->mac_speed) {\n\t\t\tbgmac->mac_speed = phy_dev->speed;\n\t\t\tupdate = true;\n\t\t}\n\n\t\tif (phy_dev->duplex != bgmac->mac_duplex) {\n\t\t\tbgmac->mac_duplex = phy_dev->duplex;\n\t\t\tupdate = true;\n\t\t}\n\t}\n\n\tif (update) {\n\t\tbgmac_mac_speed(bgmac);\n\t\tphy_print_status(phy_dev);\n\t}\n}\nEXPORT_SYMBOL_GPL(bgmac_adjust_link);\n\nint bgmac_phy_connect_direct(struct bgmac *bgmac)\n{\n\tstruct fixed_phy_status fphy_status = {\n\t\t.link = 1,\n\t\t.speed = SPEED_1000,\n\t\t.duplex = DUPLEX_FULL,\n\t};\n\tstruct phy_device *phy_dev;\n\tint err;\n\n\tphy_dev = fixed_phy_register(PHY_POLL, &fphy_status, NULL);\n\tif (IS_ERR(phy_dev)) {\n\t\tdev_err(bgmac->dev, \"Failed to register fixed PHY device\\n\");\n\t\treturn PTR_ERR(phy_dev);\n\t}\n\n\terr = phy_connect_direct(bgmac->net_dev, phy_dev, bgmac_adjust_link,\n\t\t\t\t PHY_INTERFACE_MODE_MII);\n\tif (err) {\n\t\tdev_err(bgmac->dev, \"Connecting PHY failed\\n\");\n\t\treturn err;\n\t}\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(bgmac_phy_connect_direct);\n\nstruct bgmac *bgmac_alloc(struct device *dev)\n{\n\tstruct net_device *net_dev;\n\tstruct bgmac *bgmac;\n\n\t \n\tnet_dev = devm_alloc_etherdev(dev, sizeof(*bgmac));\n\tif (!net_dev)\n\t\treturn NULL;\n\n\tnet_dev->netdev_ops = &bgmac_netdev_ops;\n\tnet_dev->ethtool_ops = &bgmac_ethtool_ops;\n\n\tbgmac = netdev_priv(net_dev);\n\tbgmac->dev = dev;\n\tbgmac->net_dev = net_dev;\n\n\treturn bgmac;\n}\nEXPORT_SYMBOL_GPL(bgmac_alloc);\n\nint bgmac_enet_probe(struct bgmac *bgmac)\n{\n\tstruct net_device *net_dev = bgmac->net_dev;\n\tint err;\n\n\tbgmac->in_init = true;\n\n\tnet_dev->irq = bgmac->irq;\n\tSET_NETDEV_DEV(net_dev, bgmac->dev);\n\tdev_set_drvdata(bgmac->dev, bgmac);\n\n\tif (!is_valid_ether_addr(net_dev->dev_addr)) {\n\t\tdev_err(bgmac->dev, \"Invalid MAC addr: %pM\\n\",\n\t\t\tnet_dev->dev_addr);\n\t\teth_hw_addr_random(net_dev);\n\t\tdev_warn(bgmac->dev, \"Using random MAC: %pM\\n\",\n\t\t\t net_dev->dev_addr);\n\t}\n\n\t \n\tbgmac_clk_enable(bgmac, 0);\n\n\tbgmac_chip_intrs_off(bgmac);\n\n\t \n\tif (!(bgmac->feature_flags & BGMAC_FEAT_IDM_MASK)) {\n\t\tif (bgmac->feature_flags & BGMAC_FEAT_IRQ_ID_OOB_6)\n\t\t\tbgmac_idm_write(bgmac, BCMA_OOB_SEL_OUT_A30, 0x86);\n\t}\n\n\tbgmac_chip_reset(bgmac);\n\n\terr = bgmac_dma_alloc(bgmac);\n\tif (err) {\n\t\tdev_err(bgmac->dev, \"Unable to alloc memory for DMA\\n\");\n\t\tgoto err_out;\n\t}\n\n\tbgmac->int_mask = BGMAC_IS_ERRMASK | BGMAC_IS_RX | BGMAC_IS_TX_MASK;\n\tif (bcm47xx_nvram_getenv(\"et0_no_txint\", NULL, 0) == 0)\n\t\tbgmac->int_mask &= ~BGMAC_IS_TX_MASK;\n\n\tnetif_napi_add(net_dev, &bgmac->napi, bgmac_poll);\n\n\terr = bgmac_phy_connect(bgmac);\n\tif (err) {\n\t\tdev_err(bgmac->dev, \"Cannot connect to phy\\n\");\n\t\tgoto err_dma_free;\n\t}\n\n\tnet_dev->features = NETIF_F_SG | NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM;\n\tnet_dev->hw_features = net_dev->features;\n\tnet_dev->vlan_features = net_dev->features;\n\n\t \n\tnet_dev->max_mtu = BGMAC_RX_MAX_FRAME_SIZE - ETH_FCS_LEN;\n\n\tbgmac->in_init = false;\n\n\terr = register_netdev(bgmac->net_dev);\n\tif (err) {\n\t\tdev_err(bgmac->dev, \"Cannot register net device\\n\");\n\t\tgoto err_phy_disconnect;\n\t}\n\n\tnetif_carrier_off(net_dev);\n\n\treturn 0;\n\nerr_phy_disconnect:\n\tphy_disconnect(net_dev->phydev);\nerr_dma_free:\n\tbgmac_dma_free(bgmac);\nerr_out:\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(bgmac_enet_probe);\n\nvoid bgmac_enet_remove(struct bgmac *bgmac)\n{\n\tunregister_netdev(bgmac->net_dev);\n\tphy_disconnect(bgmac->net_dev->phydev);\n\tnetif_napi_del(&bgmac->napi);\n\tbgmac_dma_free(bgmac);\n}\nEXPORT_SYMBOL_GPL(bgmac_enet_remove);\n\nint bgmac_enet_suspend(struct bgmac *bgmac)\n{\n\tif (!netif_running(bgmac->net_dev))\n\t\treturn 0;\n\n\tphy_stop(bgmac->net_dev->phydev);\n\n\tnetif_stop_queue(bgmac->net_dev);\n\n\tnapi_disable(&bgmac->napi);\n\n\tnetif_tx_lock(bgmac->net_dev);\n\tnetif_device_detach(bgmac->net_dev);\n\tnetif_tx_unlock(bgmac->net_dev);\n\n\tbgmac_chip_intrs_off(bgmac);\n\tbgmac_chip_reset(bgmac);\n\tbgmac_dma_cleanup(bgmac);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(bgmac_enet_suspend);\n\nint bgmac_enet_resume(struct bgmac *bgmac)\n{\n\tint rc;\n\n\tif (!netif_running(bgmac->net_dev))\n\t\treturn 0;\n\n\trc = bgmac_dma_init(bgmac);\n\tif (rc)\n\t\treturn rc;\n\n\tbgmac_chip_init(bgmac);\n\n\tnapi_enable(&bgmac->napi);\n\n\tnetif_tx_lock(bgmac->net_dev);\n\tnetif_device_attach(bgmac->net_dev);\n\tnetif_tx_unlock(bgmac->net_dev);\n\n\tnetif_start_queue(bgmac->net_dev);\n\n\tphy_start(bgmac->net_dev->phydev);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(bgmac_enet_resume);\n\nMODULE_AUTHOR(\"Rafa\u0142 Mi\u0142ecki\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}