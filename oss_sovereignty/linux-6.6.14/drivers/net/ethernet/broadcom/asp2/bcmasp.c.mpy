{
  "module_name": "bcmasp.c",
  "hash_id": "b33b32d4ebdb3eca5888788239e03b5688372b085e66ea0bb3e5cce81fd07999",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/broadcom/asp2/bcmasp.c",
  "human_readable_source": "\n \n#include <linux/etherdevice.h>\n#include <linux/if_vlan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/platform_device.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_platform.h>\n#include <linux/clk.h>\n\n#include \"bcmasp.h\"\n#include \"bcmasp_intf_defs.h\"\n\nstatic void _intr2_mask_clear(struct bcmasp_priv *priv, u32 mask)\n{\n\tintr2_core_wl(priv, mask, ASP_INTR2_MASK_CLEAR);\n\tpriv->irq_mask &= ~mask;\n}\n\nstatic void _intr2_mask_set(struct bcmasp_priv *priv, u32 mask)\n{\n\tintr2_core_wl(priv, mask, ASP_INTR2_MASK_SET);\n\tpriv->irq_mask |= mask;\n}\n\nvoid bcmasp_enable_tx_irq(struct bcmasp_intf *intf, int en)\n{\n\tstruct bcmasp_priv *priv = intf->parent;\n\n\tif (en)\n\t\t_intr2_mask_clear(priv, ASP_INTR2_TX_DESC(intf->channel));\n\telse\n\t\t_intr2_mask_set(priv, ASP_INTR2_TX_DESC(intf->channel));\n}\nEXPORT_SYMBOL_GPL(bcmasp_enable_tx_irq);\n\nvoid bcmasp_enable_rx_irq(struct bcmasp_intf *intf, int en)\n{\n\tstruct bcmasp_priv *priv = intf->parent;\n\n\tif (en)\n\t\t_intr2_mask_clear(priv, ASP_INTR2_RX_ECH(intf->channel));\n\telse\n\t\t_intr2_mask_set(priv, ASP_INTR2_RX_ECH(intf->channel));\n}\nEXPORT_SYMBOL_GPL(bcmasp_enable_rx_irq);\n\nstatic void bcmasp_intr2_mask_set_all(struct bcmasp_priv *priv)\n{\n\t_intr2_mask_set(priv, 0xffffffff);\n\tpriv->irq_mask = 0xffffffff;\n}\n\nstatic void bcmasp_intr2_clear_all(struct bcmasp_priv *priv)\n{\n\tintr2_core_wl(priv, 0xffffffff, ASP_INTR2_CLEAR);\n}\n\nstatic void bcmasp_intr2_handling(struct bcmasp_intf *intf, u32 status)\n{\n\tif (status & ASP_INTR2_RX_ECH(intf->channel)) {\n\t\tif (likely(napi_schedule_prep(&intf->rx_napi))) {\n\t\t\tbcmasp_enable_rx_irq(intf, 0);\n\t\t\t__napi_schedule_irqoff(&intf->rx_napi);\n\t\t}\n\t}\n\n\tif (status & ASP_INTR2_TX_DESC(intf->channel)) {\n\t\tif (likely(napi_schedule_prep(&intf->tx_napi))) {\n\t\t\tbcmasp_enable_tx_irq(intf, 0);\n\t\t\t__napi_schedule_irqoff(&intf->tx_napi);\n\t\t}\n\t}\n}\n\nstatic irqreturn_t bcmasp_isr(int irq, void *data)\n{\n\tstruct bcmasp_priv *priv = data;\n\tstruct bcmasp_intf *intf;\n\tu32 status;\n\n\tstatus = intr2_core_rl(priv, ASP_INTR2_STATUS) &\n\t\t~intr2_core_rl(priv, ASP_INTR2_MASK_STATUS);\n\n\tintr2_core_wl(priv, status, ASP_INTR2_CLEAR);\n\n\tif (unlikely(status == 0)) {\n\t\tdev_warn(&priv->pdev->dev, \"l2 spurious interrupt\\n\");\n\t\treturn IRQ_NONE;\n\t}\n\n\t \n\tlist_for_each_entry(intf, &priv->intfs, list)\n\t\tbcmasp_intr2_handling(intf, status);\n\n\treturn IRQ_HANDLED;\n}\n\nvoid bcmasp_flush_rx_port(struct bcmasp_intf *intf)\n{\n\tstruct bcmasp_priv *priv = intf->parent;\n\tu32 mask;\n\n\tswitch (intf->port) {\n\tcase 0:\n\t\tmask = ASP_CTRL_UMAC0_FLUSH_MASK;\n\t\tbreak;\n\tcase 1:\n\t\tmask = ASP_CTRL_UMAC1_FLUSH_MASK;\n\t\tbreak;\n\tcase 2:\n\t\tmask = ASP_CTRL_SPB_FLUSH_MASK;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\treturn;\n\t}\n\n\trx_ctrl_core_wl(priv, mask, priv->hw_info->rx_ctrl_flush);\n}\n\nstatic void bcmasp_netfilt_hw_en_wake(struct bcmasp_priv *priv,\n\t\t\t\t      struct bcmasp_net_filter *nfilt)\n{\n\trx_filter_core_wl(priv, ASP_RX_FILTER_NET_OFFSET_L3_1(64),\n\t\t\t  ASP_RX_FILTER_NET_OFFSET(nfilt->hw_index));\n\n\trx_filter_core_wl(priv, ASP_RX_FILTER_NET_OFFSET_L2(32) |\n\t\t\t  ASP_RX_FILTER_NET_OFFSET_L3_0(32) |\n\t\t\t  ASP_RX_FILTER_NET_OFFSET_L3_1(96) |\n\t\t\t  ASP_RX_FILTER_NET_OFFSET_L4(32),\n\t\t\t  ASP_RX_FILTER_NET_OFFSET(nfilt->hw_index + 1));\n\n\trx_filter_core_wl(priv, ASP_RX_FILTER_NET_CFG_CH(nfilt->port + 8) |\n\t\t\t  ASP_RX_FILTER_NET_CFG_EN |\n\t\t\t  ASP_RX_FILTER_NET_CFG_L2_EN |\n\t\t\t  ASP_RX_FILTER_NET_CFG_L3_EN |\n\t\t\t  ASP_RX_FILTER_NET_CFG_L4_EN |\n\t\t\t  ASP_RX_FILTER_NET_CFG_L3_FRM(2) |\n\t\t\t  ASP_RX_FILTER_NET_CFG_L4_FRM(2) |\n\t\t\t  ASP_RX_FILTER_NET_CFG_UMC(nfilt->port),\n\t\t\t  ASP_RX_FILTER_NET_CFG(nfilt->hw_index));\n\n\trx_filter_core_wl(priv, ASP_RX_FILTER_NET_CFG_CH(nfilt->port + 8) |\n\t\t\t  ASP_RX_FILTER_NET_CFG_EN |\n\t\t\t  ASP_RX_FILTER_NET_CFG_L2_EN |\n\t\t\t  ASP_RX_FILTER_NET_CFG_L3_EN |\n\t\t\t  ASP_RX_FILTER_NET_CFG_L4_EN |\n\t\t\t  ASP_RX_FILTER_NET_CFG_L3_FRM(2) |\n\t\t\t  ASP_RX_FILTER_NET_CFG_L4_FRM(2) |\n\t\t\t  ASP_RX_FILTER_NET_CFG_UMC(nfilt->port),\n\t\t\t  ASP_RX_FILTER_NET_CFG(nfilt->hw_index + 1));\n}\n\n#define MAX_WAKE_FILTER_SIZE\t\t256\nenum asp_netfilt_reg_type {\n\tASP_NETFILT_MATCH = 0,\n\tASP_NETFILT_MASK,\n\tASP_NETFILT_MAX\n};\n\nstatic int bcmasp_netfilt_get_reg_offset(struct bcmasp_priv *priv,\n\t\t\t\t\t struct bcmasp_net_filter *nfilt,\n\t\t\t\t\t enum asp_netfilt_reg_type reg_type,\n\t\t\t\t\t u32 offset)\n{\n\tu32 block_index, filter_sel;\n\n\tif (offset < 32) {\n\t\tblock_index = ASP_RX_FILTER_NET_L2;\n\t\tfilter_sel = nfilt->hw_index;\n\t} else if (offset < 64) {\n\t\tblock_index = ASP_RX_FILTER_NET_L2;\n\t\tfilter_sel = nfilt->hw_index + 1;\n\t} else if (offset < 96) {\n\t\tblock_index = ASP_RX_FILTER_NET_L3_0;\n\t\tfilter_sel = nfilt->hw_index;\n\t} else if (offset < 128) {\n\t\tblock_index = ASP_RX_FILTER_NET_L3_0;\n\t\tfilter_sel = nfilt->hw_index + 1;\n\t} else if (offset < 160) {\n\t\tblock_index = ASP_RX_FILTER_NET_L3_1;\n\t\tfilter_sel = nfilt->hw_index;\n\t} else if (offset < 192) {\n\t\tblock_index = ASP_RX_FILTER_NET_L3_1;\n\t\tfilter_sel = nfilt->hw_index + 1;\n\t} else if (offset < 224) {\n\t\tblock_index = ASP_RX_FILTER_NET_L4;\n\t\tfilter_sel = nfilt->hw_index;\n\t} else if (offset < 256) {\n\t\tblock_index = ASP_RX_FILTER_NET_L4;\n\t\tfilter_sel = nfilt->hw_index + 1;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (reg_type) {\n\tcase ASP_NETFILT_MATCH:\n\t\treturn ASP_RX_FILTER_NET_PAT(filter_sel, block_index,\n\t\t\t\t\t     (offset % 32));\n\tcase ASP_NETFILT_MASK:\n\t\treturn ASP_RX_FILTER_NET_MASK(filter_sel, block_index,\n\t\t\t\t\t      (offset % 32));\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic void bcmasp_netfilt_wr(struct bcmasp_priv *priv,\n\t\t\t      struct bcmasp_net_filter *nfilt,\n\t\t\t      enum asp_netfilt_reg_type reg_type,\n\t\t\t      u32 val, u32 offset)\n{\n\tint reg_offset;\n\n\t \n\tif (!IS_ALIGNED(offset, 4) || offset > MAX_WAKE_FILTER_SIZE)\n\t\treturn;\n\n\treg_offset = bcmasp_netfilt_get_reg_offset(priv, nfilt, reg_type,\n\t\t\t\t\t\t   offset);\n\n\trx_filter_core_wl(priv, val, reg_offset);\n}\n\nstatic u32 bcmasp_netfilt_rd(struct bcmasp_priv *priv,\n\t\t\t     struct bcmasp_net_filter *nfilt,\n\t\t\t     enum asp_netfilt_reg_type reg_type,\n\t\t\t     u32 offset)\n{\n\tint reg_offset;\n\n\t \n\tif (!IS_ALIGNED(offset, 4) || offset > MAX_WAKE_FILTER_SIZE)\n\t\treturn 0;\n\n\treg_offset = bcmasp_netfilt_get_reg_offset(priv, nfilt, reg_type,\n\t\t\t\t\t\t   offset);\n\n\treturn rx_filter_core_rl(priv, reg_offset);\n}\n\nstatic int bcmasp_netfilt_wr_m_wake(struct bcmasp_priv *priv,\n\t\t\t\t    struct bcmasp_net_filter *nfilt,\n\t\t\t\t    u32 offset, void *match, void *mask,\n\t\t\t\t    size_t size)\n{\n\tu32 shift, mask_val = 0, match_val = 0;\n\tbool first_byte = true;\n\n\tif ((offset + size) > MAX_WAKE_FILTER_SIZE)\n\t\treturn -EINVAL;\n\n\twhile (size--) {\n\t\t \n\t\tif (first_byte && (!IS_ALIGNED(offset, 4) || size < 3)) {\n\t\t\tmatch_val = bcmasp_netfilt_rd(priv, nfilt,\n\t\t\t\t\t\t      ASP_NETFILT_MATCH,\n\t\t\t\t\t\t      ALIGN_DOWN(offset, 4));\n\t\t\tmask_val = bcmasp_netfilt_rd(priv, nfilt,\n\t\t\t\t\t\t     ASP_NETFILT_MASK,\n\t\t\t\t\t\t     ALIGN_DOWN(offset, 4));\n\t\t}\n\n\t\tshift = (3 - (offset % 4)) * 8;\n\t\tmatch_val &= ~GENMASK(shift + 7, shift);\n\t\tmask_val &= ~GENMASK(shift + 7, shift);\n\t\tmatch_val |= (u32)(*((u8 *)match) << shift);\n\t\tmask_val |= (u32)(*((u8 *)mask) << shift);\n\n\t\t \n\t\tif (!size || ((offset % 4) == 3)) {\n\t\t\tbcmasp_netfilt_wr(priv, nfilt, ASP_NETFILT_MATCH,\n\t\t\t\t\t  match_val, ALIGN_DOWN(offset, 4));\n\t\t\tbcmasp_netfilt_wr(priv, nfilt, ASP_NETFILT_MASK,\n\t\t\t\t\t  mask_val, ALIGN_DOWN(offset, 4));\n\t\t\tfirst_byte = true;\n\t\t} else {\n\t\t\tfirst_byte = false;\n\t\t}\n\n\t\toffset++;\n\t\tmatch++;\n\t\tmask++;\n\t}\n\n\treturn 0;\n}\n\nstatic void bcmasp_netfilt_reset_hw(struct bcmasp_priv *priv,\n\t\t\t\t    struct bcmasp_net_filter *nfilt)\n{\n\tint i;\n\n\tfor (i = 0; i < MAX_WAKE_FILTER_SIZE; i += 4) {\n\t\tbcmasp_netfilt_wr(priv, nfilt, ASP_NETFILT_MATCH, 0, i);\n\t\tbcmasp_netfilt_wr(priv, nfilt, ASP_NETFILT_MASK, 0, i);\n\t}\n}\n\nstatic void bcmasp_netfilt_tcpip4_wr(struct bcmasp_priv *priv,\n\t\t\t\t     struct bcmasp_net_filter *nfilt,\n\t\t\t\t     struct ethtool_tcpip4_spec *match,\n\t\t\t\t     struct ethtool_tcpip4_spec *mask,\n\t\t\t\t     u32 offset)\n{\n\t__be16 val_16, mask_16;\n\n\tval_16 = htons(ETH_P_IP);\n\tmask_16 = htons(0xFFFF);\n\tbcmasp_netfilt_wr_m_wake(priv, nfilt, (ETH_ALEN * 2) + offset,\n\t\t\t\t &val_16, &mask_16, sizeof(val_16));\n\tbcmasp_netfilt_wr_m_wake(priv, nfilt, ETH_HLEN + offset + 1,\n\t\t\t\t &match->tos, &mask->tos,\n\t\t\t\t sizeof(match->tos));\n\tbcmasp_netfilt_wr_m_wake(priv, nfilt, ETH_HLEN + offset + 12,\n\t\t\t\t &match->ip4src, &mask->ip4src,\n\t\t\t\t sizeof(match->ip4src));\n\tbcmasp_netfilt_wr_m_wake(priv, nfilt, ETH_HLEN + offset + 16,\n\t\t\t\t &match->ip4dst, &mask->ip4dst,\n\t\t\t\t sizeof(match->ip4dst));\n\tbcmasp_netfilt_wr_m_wake(priv, nfilt, ETH_HLEN + offset + 20,\n\t\t\t\t &match->psrc, &mask->psrc,\n\t\t\t\t sizeof(match->psrc));\n\tbcmasp_netfilt_wr_m_wake(priv, nfilt, ETH_HLEN + offset + 22,\n\t\t\t\t &match->pdst, &mask->pdst,\n\t\t\t\t sizeof(match->pdst));\n}\n\nstatic void bcmasp_netfilt_tcpip6_wr(struct bcmasp_priv *priv,\n\t\t\t\t     struct bcmasp_net_filter *nfilt,\n\t\t\t\t     struct ethtool_tcpip6_spec *match,\n\t\t\t\t     struct ethtool_tcpip6_spec *mask,\n\t\t\t\t     u32 offset)\n{\n\t__be16 val_16, mask_16;\n\n\tval_16 = htons(ETH_P_IPV6);\n\tmask_16 = htons(0xFFFF);\n\tbcmasp_netfilt_wr_m_wake(priv, nfilt, (ETH_ALEN * 2) + offset,\n\t\t\t\t &val_16, &mask_16, sizeof(val_16));\n\tval_16 = htons(match->tclass << 4);\n\tmask_16 = htons(mask->tclass << 4);\n\tbcmasp_netfilt_wr_m_wake(priv, nfilt, ETH_HLEN + offset,\n\t\t\t\t &val_16, &mask_16, sizeof(val_16));\n\tbcmasp_netfilt_wr_m_wake(priv, nfilt, ETH_HLEN + offset + 8,\n\t\t\t\t &match->ip6src, &mask->ip6src,\n\t\t\t\t sizeof(match->ip6src));\n\tbcmasp_netfilt_wr_m_wake(priv, nfilt, ETH_HLEN + offset + 24,\n\t\t\t\t &match->ip6dst, &mask->ip6dst,\n\t\t\t\t sizeof(match->ip6dst));\n\tbcmasp_netfilt_wr_m_wake(priv, nfilt, ETH_HLEN + offset + 40,\n\t\t\t\t &match->psrc, &mask->psrc,\n\t\t\t\t sizeof(match->psrc));\n\tbcmasp_netfilt_wr_m_wake(priv, nfilt, ETH_HLEN + offset + 42,\n\t\t\t\t &match->pdst, &mask->pdst,\n\t\t\t\t sizeof(match->pdst));\n}\n\nstatic int bcmasp_netfilt_wr_to_hw(struct bcmasp_priv *priv,\n\t\t\t\t   struct bcmasp_net_filter *nfilt)\n{\n\tstruct ethtool_rx_flow_spec *fs = &nfilt->fs;\n\tunsigned int offset = 0;\n\t__be16 val_16, mask_16;\n\tu8 val_8, mask_8;\n\n\t \n\tif (!nfilt->wake_filter)\n\t\treturn -EINVAL;\n\n\tbcmasp_netfilt_reset_hw(priv, nfilt);\n\n\tif (fs->flow_type & FLOW_MAC_EXT) {\n\t\tbcmasp_netfilt_wr_m_wake(priv, nfilt, 0, &fs->h_ext.h_dest,\n\t\t\t\t\t &fs->m_ext.h_dest,\n\t\t\t\t\t sizeof(fs->h_ext.h_dest));\n\t}\n\n\tif ((fs->flow_type & FLOW_EXT) &&\n\t    (fs->m_ext.vlan_etype || fs->m_ext.vlan_tci)) {\n\t\tbcmasp_netfilt_wr_m_wake(priv, nfilt, (ETH_ALEN * 2),\n\t\t\t\t\t &fs->h_ext.vlan_etype,\n\t\t\t\t\t &fs->m_ext.vlan_etype,\n\t\t\t\t\t sizeof(fs->h_ext.vlan_etype));\n\t\tbcmasp_netfilt_wr_m_wake(priv, nfilt, ((ETH_ALEN * 2) + 2),\n\t\t\t\t\t &fs->h_ext.vlan_tci,\n\t\t\t\t\t &fs->m_ext.vlan_tci,\n\t\t\t\t\t sizeof(fs->h_ext.vlan_tci));\n\t\toffset += VLAN_HLEN;\n\t}\n\n\tswitch (fs->flow_type & ~(FLOW_EXT | FLOW_MAC_EXT)) {\n\tcase ETHER_FLOW:\n\t\tbcmasp_netfilt_wr_m_wake(priv, nfilt, 0,\n\t\t\t\t\t &fs->h_u.ether_spec.h_dest,\n\t\t\t\t\t &fs->m_u.ether_spec.h_dest,\n\t\t\t\t\t sizeof(fs->h_u.ether_spec.h_dest));\n\t\tbcmasp_netfilt_wr_m_wake(priv, nfilt, ETH_ALEN,\n\t\t\t\t\t &fs->h_u.ether_spec.h_source,\n\t\t\t\t\t &fs->m_u.ether_spec.h_source,\n\t\t\t\t\t sizeof(fs->h_u.ether_spec.h_source));\n\t\tbcmasp_netfilt_wr_m_wake(priv, nfilt, (ETH_ALEN * 2) + offset,\n\t\t\t\t\t &fs->h_u.ether_spec.h_proto,\n\t\t\t\t\t &fs->m_u.ether_spec.h_proto,\n\t\t\t\t\t sizeof(fs->h_u.ether_spec.h_proto));\n\n\t\tbreak;\n\tcase IP_USER_FLOW:\n\t\tval_16 = htons(ETH_P_IP);\n\t\tmask_16 = htons(0xFFFF);\n\t\tbcmasp_netfilt_wr_m_wake(priv, nfilt, (ETH_ALEN * 2) + offset,\n\t\t\t\t\t &val_16, &mask_16, sizeof(val_16));\n\t\tbcmasp_netfilt_wr_m_wake(priv, nfilt, ETH_HLEN + offset + 1,\n\t\t\t\t\t &fs->h_u.usr_ip4_spec.tos,\n\t\t\t\t\t &fs->m_u.usr_ip4_spec.tos,\n\t\t\t\t\t sizeof(fs->h_u.usr_ip4_spec.tos));\n\t\tbcmasp_netfilt_wr_m_wake(priv, nfilt, ETH_HLEN + offset + 9,\n\t\t\t\t\t &fs->h_u.usr_ip4_spec.proto,\n\t\t\t\t\t &fs->m_u.usr_ip4_spec.proto,\n\t\t\t\t\t sizeof(fs->h_u.usr_ip4_spec.proto));\n\t\tbcmasp_netfilt_wr_m_wake(priv, nfilt, ETH_HLEN + offset + 12,\n\t\t\t\t\t &fs->h_u.usr_ip4_spec.ip4src,\n\t\t\t\t\t &fs->m_u.usr_ip4_spec.ip4src,\n\t\t\t\t\t sizeof(fs->h_u.usr_ip4_spec.ip4src));\n\t\tbcmasp_netfilt_wr_m_wake(priv, nfilt, ETH_HLEN + offset + 16,\n\t\t\t\t\t &fs->h_u.usr_ip4_spec.ip4dst,\n\t\t\t\t\t &fs->m_u.usr_ip4_spec.ip4dst,\n\t\t\t\t\t sizeof(fs->h_u.usr_ip4_spec.ip4dst));\n\t\tif (!fs->m_u.usr_ip4_spec.l4_4_bytes)\n\t\t\tbreak;\n\n\t\t \n\t\tval_8 = 0x45;\n\t\tmask_8 = 0xFF;\n\t\tbcmasp_netfilt_wr_m_wake(priv, nfilt, ETH_HLEN + offset,\n\t\t\t\t\t &val_8, &mask_8, sizeof(val_8));\n\t\tbcmasp_netfilt_wr_m_wake(priv, nfilt,\n\t\t\t\t\t ETH_HLEN + 20 + offset,\n\t\t\t\t\t &fs->h_u.usr_ip4_spec.l4_4_bytes,\n\t\t\t\t\t &fs->m_u.usr_ip4_spec.l4_4_bytes,\n\t\t\t\t\t sizeof(fs->h_u.usr_ip4_spec.l4_4_bytes)\n\t\t\t\t\t );\n\t\tbreak;\n\tcase TCP_V4_FLOW:\n\t\tval_8 = IPPROTO_TCP;\n\t\tmask_8 = 0xFF;\n\t\tbcmasp_netfilt_tcpip4_wr(priv, nfilt, &fs->h_u.tcp_ip4_spec,\n\t\t\t\t\t &fs->m_u.tcp_ip4_spec, offset);\n\t\tbcmasp_netfilt_wr_m_wake(priv, nfilt, ETH_HLEN + offset + 9,\n\t\t\t\t\t &val_8, &mask_8, sizeof(val_8));\n\t\tbreak;\n\tcase UDP_V4_FLOW:\n\t\tval_8 = IPPROTO_UDP;\n\t\tmask_8 = 0xFF;\n\t\tbcmasp_netfilt_tcpip4_wr(priv, nfilt, &fs->h_u.udp_ip4_spec,\n\t\t\t\t\t &fs->m_u.udp_ip4_spec, offset);\n\n\t\tbcmasp_netfilt_wr_m_wake(priv, nfilt, ETH_HLEN + offset + 9,\n\t\t\t\t\t &val_8, &mask_8, sizeof(val_8));\n\t\tbreak;\n\tcase TCP_V6_FLOW:\n\t\tval_8 = IPPROTO_TCP;\n\t\tmask_8 = 0xFF;\n\t\tbcmasp_netfilt_tcpip6_wr(priv, nfilt, &fs->h_u.tcp_ip6_spec,\n\t\t\t\t\t &fs->m_u.tcp_ip6_spec, offset);\n\t\tbcmasp_netfilt_wr_m_wake(priv, nfilt, ETH_HLEN + offset + 6,\n\t\t\t\t\t &val_8, &mask_8, sizeof(val_8));\n\t\tbreak;\n\tcase UDP_V6_FLOW:\n\t\tval_8 = IPPROTO_UDP;\n\t\tmask_8 = 0xFF;\n\t\tbcmasp_netfilt_tcpip6_wr(priv, nfilt, &fs->h_u.udp_ip6_spec,\n\t\t\t\t\t &fs->m_u.udp_ip6_spec, offset);\n\t\tbcmasp_netfilt_wr_m_wake(priv, nfilt, ETH_HLEN + offset + 6,\n\t\t\t\t\t &val_8, &mask_8, sizeof(val_8));\n\t\tbreak;\n\t}\n\n\tbcmasp_netfilt_hw_en_wake(priv, nfilt);\n\n\treturn 0;\n}\n\nvoid bcmasp_netfilt_suspend(struct bcmasp_intf *intf)\n{\n\tstruct bcmasp_priv *priv = intf->parent;\n\tbool write = false;\n\tint ret, i;\n\n\t \n\tfor (i = 0; i < NUM_NET_FILTERS; i++) {\n\t\t \n\t\tif (!priv->net_filters[i].claimed ||\n\t\t    priv->net_filters[i].port != intf->port)\n\t\t\tcontinue;\n\n\t\tif (i > 0 && (i % 2) &&\n\t\t    priv->net_filters[i].wake_filter &&\n\t\t    priv->net_filters[i - 1].wake_filter)\n\t\t\tcontinue;\n\n\t\tret = bcmasp_netfilt_wr_to_hw(priv, &priv->net_filters[i]);\n\t\tif (!ret)\n\t\t\twrite = true;\n\t}\n\n\t \n\tif (write)\n\t\trx_filter_core_wl(priv, (ASP_RX_FILTER_OPUT_EN |\n\t\t\t\t  ASP_RX_FILTER_LNR_MD |\n\t\t\t\t  ASP_RX_FILTER_GEN_WK_EN |\n\t\t\t\t  ASP_RX_FILTER_NT_FLT_EN),\n\t\t\t\t  ASP_RX_FILTER_BLK_CTRL);\n}\n\nint bcmasp_netfilt_get_all_active(struct bcmasp_intf *intf, u32 *rule_locs,\n\t\t\t\t  u32 *rule_cnt)\n{\n\tstruct bcmasp_priv *priv = intf->parent;\n\tint j = 0, i;\n\n\tfor (i = 0; i < NUM_NET_FILTERS; i++) {\n\t\tif (j == *rule_cnt)\n\t\t\treturn -EMSGSIZE;\n\n\t\tif (!priv->net_filters[i].claimed ||\n\t\t    priv->net_filters[i].port != intf->port)\n\t\t\tcontinue;\n\n\t\tif (i > 0 && (i % 2) &&\n\t\t    priv->net_filters[i].wake_filter &&\n\t\t    priv->net_filters[i - 1].wake_filter)\n\t\t\tcontinue;\n\n\t\trule_locs[j++] = priv->net_filters[i].fs.location;\n\t}\n\n\t*rule_cnt = j;\n\n\treturn 0;\n}\n\nint bcmasp_netfilt_get_active(struct bcmasp_intf *intf)\n{\n\tstruct bcmasp_priv *priv = intf->parent;\n\tint cnt = 0, i;\n\n\tfor (i = 0; i < NUM_NET_FILTERS; i++) {\n\t\tif (!priv->net_filters[i].claimed ||\n\t\t    priv->net_filters[i].port != intf->port)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (i > 0 && (i % 2) &&\n\t\t    priv->net_filters[i].wake_filter &&\n\t\t    priv->net_filters[i - 1].wake_filter)\n\t\t\tcontinue;\n\n\t\tcnt++;\n\t}\n\n\treturn cnt;\n}\n\nbool bcmasp_netfilt_check_dup(struct bcmasp_intf *intf,\n\t\t\t      struct ethtool_rx_flow_spec *fs)\n{\n\tstruct bcmasp_priv *priv = intf->parent;\n\tstruct ethtool_rx_flow_spec *cur;\n\tsize_t fs_size = 0;\n\tint i;\n\n\tfor (i = 0; i < NUM_NET_FILTERS; i++) {\n\t\tif (!priv->net_filters[i].claimed ||\n\t\t    priv->net_filters[i].port != intf->port)\n\t\t\tcontinue;\n\n\t\tcur = &priv->net_filters[i].fs;\n\n\t\tif (cur->flow_type != fs->flow_type ||\n\t\t    cur->ring_cookie != fs->ring_cookie)\n\t\t\tcontinue;\n\n\t\tswitch (fs->flow_type & ~(FLOW_EXT | FLOW_MAC_EXT)) {\n\t\tcase ETHER_FLOW:\n\t\t\tfs_size = sizeof(struct ethhdr);\n\t\t\tbreak;\n\t\tcase IP_USER_FLOW:\n\t\t\tfs_size = sizeof(struct ethtool_usrip4_spec);\n\t\t\tbreak;\n\t\tcase TCP_V6_FLOW:\n\t\tcase UDP_V6_FLOW:\n\t\t\tfs_size = sizeof(struct ethtool_tcpip6_spec);\n\t\t\tbreak;\n\t\tcase TCP_V4_FLOW:\n\t\tcase UDP_V4_FLOW:\n\t\t\tfs_size = sizeof(struct ethtool_tcpip4_spec);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (memcmp(&cur->h_u, &fs->h_u, fs_size) ||\n\t\t    memcmp(&cur->m_u, &fs->m_u, fs_size))\n\t\t\tcontinue;\n\n\t\tif (cur->flow_type & FLOW_EXT) {\n\t\t\tif (cur->h_ext.vlan_etype != fs->h_ext.vlan_etype ||\n\t\t\t    cur->m_ext.vlan_etype != fs->m_ext.vlan_etype ||\n\t\t\t    cur->h_ext.vlan_tci != fs->h_ext.vlan_tci ||\n\t\t\t    cur->m_ext.vlan_tci != fs->m_ext.vlan_tci ||\n\t\t\t    cur->h_ext.data[0] != fs->h_ext.data[0])\n\t\t\t\tcontinue;\n\t\t}\n\t\tif (cur->flow_type & FLOW_MAC_EXT) {\n\t\t\tif (memcmp(&cur->h_ext.h_dest,\n\t\t\t\t   &fs->h_ext.h_dest, ETH_ALEN) ||\n\t\t\t    memcmp(&cur->m_ext.h_dest,\n\t\t\t\t   &fs->m_ext.h_dest, ETH_ALEN))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n \nstruct bcmasp_net_filter *bcmasp_netfilt_get_init(struct bcmasp_intf *intf,\n\t\t\t\t\t\t  u32 loc, bool wake_filter,\n\t\t\t\t\t\t  bool init)\n{\n\tstruct bcmasp_net_filter *nfilter = NULL;\n\tstruct bcmasp_priv *priv = intf->parent;\n\tint i, open_index = -1;\n\n\t \n\tif (loc != RX_CLS_LOC_ANY && loc >= NUM_NET_FILTERS)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t \n\tif (loc != RX_CLS_LOC_ANY && init && priv->net_filters[loc].claimed)\n\t\treturn ERR_PTR(-EBUSY);\n\n\t \n\tif (wake_filter && loc != RX_CLS_LOC_ANY && (loc % 2))\n\t\treturn ERR_PTR(-EINVAL);\n\n\t \n\ti = loc == RX_CLS_LOC_ANY ? 0 : loc;\n\n\tfor ( ; i < NUM_NET_FILTERS; i++) {\n\t\t \n\t\tif (!init &&\n\t\t    priv->net_filters[i].claimed &&\n\t\t    priv->net_filters[i].hw_index == i &&\n\t\t    priv->net_filters[i].port == intf->port)\n\t\t\treturn &priv->net_filters[i];\n\n\t\t \n\t\tif (!init || open_index >= 0)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (wake_filter && !(i % 2) && !priv->net_filters[i].claimed &&\n\t\t    !priv->net_filters[i + 1].claimed)\n\t\t\topen_index = i;\n\t\telse if (!priv->net_filters[i].claimed)\n\t\t\topen_index = i;\n\t}\n\n\tif (open_index >= 0) {\n\t\tnfilter = &priv->net_filters[open_index];\n\t\tnfilter->claimed = true;\n\t\tnfilter->port = intf->port;\n\t\tnfilter->hw_index = open_index;\n\t}\n\n\tif (wake_filter && open_index >= 0) {\n\t\t \n\t\tpriv->net_filters[open_index + 1].claimed = true;\n\t\tpriv->net_filters[open_index + 1].wake_filter = true;\n\t\tnfilter->wake_filter = true;\n\t}\n\n\treturn nfilter ? nfilter : ERR_PTR(-EINVAL);\n}\n\nvoid bcmasp_netfilt_release(struct bcmasp_intf *intf,\n\t\t\t    struct bcmasp_net_filter *nfilt)\n{\n\tstruct bcmasp_priv *priv = intf->parent;\n\n\tif (nfilt->wake_filter) {\n\t\tmemset(&priv->net_filters[nfilt->hw_index + 1], 0,\n\t\t       sizeof(struct bcmasp_net_filter));\n\t}\n\n\tmemset(nfilt, 0, sizeof(struct bcmasp_net_filter));\n}\n\nstatic void bcmasp_addr_to_uint(unsigned char *addr, u32 *high, u32 *low)\n{\n\t*high = (u32)(addr[0] << 8 | addr[1]);\n\t*low = (u32)(addr[2] << 24 | addr[3] << 16 | addr[4] << 8 |\n\t\t     addr[5]);\n}\n\nstatic void bcmasp_set_mda_filter(struct bcmasp_intf *intf,\n\t\t\t\t  const unsigned char *addr,\n\t\t\t\t  unsigned char *mask,\n\t\t\t\t  unsigned int i)\n{\n\tstruct bcmasp_priv *priv = intf->parent;\n\tu32 addr_h, addr_l, mask_h, mask_l;\n\n\t \n\tether_addr_copy(priv->mda_filters[i].mask, mask);\n\tether_addr_copy(priv->mda_filters[i].addr, addr);\n\n\t \n\tbcmasp_addr_to_uint(priv->mda_filters[i].mask, &mask_h, &mask_l);\n\tbcmasp_addr_to_uint(priv->mda_filters[i].addr, &addr_h, &addr_l);\n\trx_filter_core_wl(priv, addr_h, ASP_RX_FILTER_MDA_PAT_H(i));\n\trx_filter_core_wl(priv, addr_l, ASP_RX_FILTER_MDA_PAT_L(i));\n\trx_filter_core_wl(priv, mask_h, ASP_RX_FILTER_MDA_MSK_H(i));\n\trx_filter_core_wl(priv, mask_l, ASP_RX_FILTER_MDA_MSK_L(i));\n}\n\nstatic void bcmasp_en_mda_filter(struct bcmasp_intf *intf, bool en,\n\t\t\t\t unsigned int i)\n{\n\tstruct bcmasp_priv *priv = intf->parent;\n\n\tif (priv->mda_filters[i].en == en)\n\t\treturn;\n\n\tpriv->mda_filters[i].en = en;\n\tpriv->mda_filters[i].port = intf->port;\n\n\trx_filter_core_wl(priv, ((intf->channel + 8) |\n\t\t\t  (en << ASP_RX_FILTER_MDA_CFG_EN_SHIFT) |\n\t\t\t  ASP_RX_FILTER_MDA_CFG_UMC_SEL(intf->port)),\n\t\t\t  ASP_RX_FILTER_MDA_CFG(i));\n}\n\n \nenum asp_rx_filter_id {\n\tASP_RX_FILTER_MDA_PROMISC = 0,\n\tASP_RX_FILTER_MDA_ALLMULTI,\n\tASP_RX_FILTER_MDA_BROADCAST,\n\tASP_RX_FILTER_MDA_OWN_ADDR,\n\tASP_RX_FILTER_MDA_RES_MAX,\n};\n\n#define ASP_RX_FILT_MDA(intf, name)\t(((intf)->index * \\\n\t\t\t\t\t  ASP_RX_FILTER_MDA_RES_MAX) \\\n\t\t\t\t\t + ASP_RX_FILTER_MDA_##name)\n\nstatic int bcmasp_total_res_mda_cnt(struct bcmasp_priv *priv)\n{\n\treturn list_count_nodes(&priv->intfs) * ASP_RX_FILTER_MDA_RES_MAX;\n}\n\nvoid bcmasp_set_promisc(struct bcmasp_intf *intf, bool en)\n{\n\tunsigned int i = ASP_RX_FILT_MDA(intf, PROMISC);\n\tunsigned char promisc[ETH_ALEN];\n\n\teth_zero_addr(promisc);\n\t \n\tbcmasp_set_mda_filter(intf, promisc, promisc, i);\n\tbcmasp_en_mda_filter(intf, en, i);\n}\n\nvoid bcmasp_set_allmulti(struct bcmasp_intf *intf, bool en)\n{\n\tunsigned char allmulti[] = {0x01, 0x00, 0x00, 0x00, 0x00, 0x00};\n\tunsigned int i = ASP_RX_FILT_MDA(intf, ALLMULTI);\n\n\t \n\tbcmasp_set_mda_filter(intf, allmulti, allmulti, i);\n\tbcmasp_en_mda_filter(intf, en, i);\n}\n\nvoid bcmasp_set_broad(struct bcmasp_intf *intf, bool en)\n{\n\tunsigned int i = ASP_RX_FILT_MDA(intf, BROADCAST);\n\tunsigned char addr[ETH_ALEN];\n\n\teth_broadcast_addr(addr);\n\tbcmasp_set_mda_filter(intf, addr, addr, i);\n\tbcmasp_en_mda_filter(intf, en, i);\n}\n\nvoid bcmasp_set_oaddr(struct bcmasp_intf *intf, const unsigned char *addr,\n\t\t      bool en)\n{\n\tunsigned char mask[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};\n\tunsigned int i = ASP_RX_FILT_MDA(intf, OWN_ADDR);\n\n\tbcmasp_set_mda_filter(intf, addr, mask, i);\n\tbcmasp_en_mda_filter(intf, en, i);\n}\n\nvoid bcmasp_disable_all_filters(struct bcmasp_intf *intf)\n{\n\tstruct bcmasp_priv *priv = intf->parent;\n\tunsigned int i;\n\tint res_count;\n\n\tres_count = bcmasp_total_res_mda_cnt(intf->parent);\n\n\t \n\tfor (i = res_count; i < NUM_MDA_FILTERS; i++) {\n\t\tif (priv->mda_filters[i].en &&\n\t\t    priv->mda_filters[i].port == intf->port)\n\t\t\tbcmasp_en_mda_filter(intf, 0, i);\n\t}\n}\n\nstatic int bcmasp_combine_set_filter(struct bcmasp_intf *intf,\n\t\t\t\t     unsigned char *addr, unsigned char *mask,\n\t\t\t\t     int i)\n{\n\tstruct bcmasp_priv *priv = intf->parent;\n\tu64 addr1, addr2, mask1, mask2, mask3;\n\n\t \n\taddr1 = ether_addr_to_u64(priv->mda_filters[i].addr);\n\tmask1 = ether_addr_to_u64(priv->mda_filters[i].mask);\n\taddr2 = ether_addr_to_u64(addr);\n\tmask2 = ether_addr_to_u64(mask);\n\n\t \n\tmask3 = mask1 & mask2;\n\tif (mask3 == mask1 && ((addr1 & mask1) == (addr2 & mask1))) {\n\t\t \n\t\treturn 0;\n\t} else if (mask3 == mask2 && ((addr1 & mask2) == (addr2 & mask2))) {\n\t\t \n\t\tbcmasp_set_mda_filter(intf, addr, mask, i);\n\t\treturn 0;\n\t}\n\n\t \n\treturn -EINVAL;\n}\n\nint bcmasp_set_en_mda_filter(struct bcmasp_intf *intf, unsigned char *addr,\n\t\t\t     unsigned char *mask)\n{\n\tstruct bcmasp_priv *priv = intf->parent;\n\tint ret, res_count;\n\tunsigned int i;\n\n\tres_count = bcmasp_total_res_mda_cnt(intf->parent);\n\n\tfor (i = res_count; i < NUM_MDA_FILTERS; i++) {\n\t\t \n\t\tif (!priv->mda_filters[i].en ||\n\t\t    priv->mda_filters[i].port != intf->port)\n\t\t\tcontinue;\n\n\t\t \n\t\tret = bcmasp_combine_set_filter(intf, addr, mask, i);\n\t\tif (!ret) {\n\t\t\tintf->mib.filters_combine_cnt++;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t \n\tfor (i = res_count; i < NUM_MDA_FILTERS; i++) {\n\t\tif (priv->mda_filters[i].en)\n\t\t\tcontinue;\n\n\t\tbcmasp_set_mda_filter(intf, addr, mask, i);\n\t\tbcmasp_en_mda_filter(intf, 1, i);\n\t\treturn 0;\n\t}\n\n\t \n\treturn -EINVAL;\n}\n\nstatic void bcmasp_core_init_filters(struct bcmasp_priv *priv)\n{\n\tunsigned int i;\n\n\t \n\tfor (i = 0; i < NUM_MDA_FILTERS; i++) {\n\t\trx_filter_core_wl(priv, 0x0, ASP_RX_FILTER_MDA_CFG(i));\n\t\tpriv->mda_filters[i].en = 0;\n\t}\n\n\tfor (i = 0; i < NUM_NET_FILTERS; i++)\n\t\trx_filter_core_wl(priv, 0x0, ASP_RX_FILTER_NET_CFG(i));\n\n\t \n\trx_filter_core_wl(priv, (ASP_RX_FILTER_OPUT_EN |\n\t\t\t  ASP_RX_FILTER_MDA_EN |\n\t\t\t  ASP_RX_FILTER_GEN_WK_CLR |\n\t\t\t  ASP_RX_FILTER_NT_FLT_EN),\n\t\t\t  ASP_RX_FILTER_BLK_CTRL);\n}\n\n \nstatic void bcmasp_core_init(struct bcmasp_priv *priv)\n{\n\ttx_analytics_core_wl(priv, 0x0, ASP_TX_ANALYTICS_CTRL);\n\trx_analytics_core_wl(priv, 0x4, ASP_RX_ANALYTICS_CTRL);\n\n\trx_edpkt_core_wl(priv, (ASP_EDPKT_HDR_SZ_128 << ASP_EDPKT_HDR_SZ_SHIFT),\n\t\t\t ASP_EDPKT_HDR_CFG);\n\trx_edpkt_core_wl(priv,\n\t\t\t (ASP_EDPKT_ENDI_BT_SWP_WD << ASP_EDPKT_ENDI_DESC_SHIFT),\n\t\t\t ASP_EDPKT_ENDI);\n\n\trx_edpkt_core_wl(priv, 0x1b, ASP_EDPKT_BURST_BUF_PSCAL_TOUT);\n\trx_edpkt_core_wl(priv, 0x3e8, ASP_EDPKT_BURST_BUF_WRITE_TOUT);\n\trx_edpkt_core_wl(priv, 0x3e8, ASP_EDPKT_BURST_BUF_READ_TOUT);\n\n\trx_edpkt_core_wl(priv, ASP_EDPKT_ENABLE_EN, ASP_EDPKT_ENABLE);\n\n\t \n\t_intr2_mask_set(priv, ASP_INTR2_UMC0_WAKE | ASP_INTR2_UMC1_WAKE);\n\tintr2_core_wl(priv, ASP_INTR2_UMC0_WAKE | ASP_INTR2_UMC1_WAKE,\n\t\t      ASP_INTR2_CLEAR);\n}\n\nstatic void bcmasp_core_clock_select(struct bcmasp_priv *priv, bool slow)\n{\n\tu32 reg;\n\n\treg = ctrl_core_rl(priv, ASP_CTRL_CORE_CLOCK_SELECT);\n\tif (slow)\n\t\treg &= ~ASP_CTRL_CORE_CLOCK_SELECT_MAIN;\n\telse\n\t\treg |= ASP_CTRL_CORE_CLOCK_SELECT_MAIN;\n\tctrl_core_wl(priv, reg, ASP_CTRL_CORE_CLOCK_SELECT);\n}\n\nstatic void bcmasp_core_clock_set_ll(struct bcmasp_priv *priv, u32 clr, u32 set)\n{\n\tu32 reg;\n\n\treg = ctrl_core_rl(priv, ASP_CTRL_CLOCK_CTRL);\n\treg &= ~clr;\n\treg |= set;\n\tctrl_core_wl(priv, reg, ASP_CTRL_CLOCK_CTRL);\n\n\treg = ctrl_core_rl(priv, ASP_CTRL_SCRATCH_0);\n\treg &= ~clr;\n\treg |= set;\n\tctrl_core_wl(priv, reg, ASP_CTRL_SCRATCH_0);\n}\n\nstatic void bcmasp_core_clock_set(struct bcmasp_priv *priv, u32 clr, u32 set)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&priv->clk_lock, flags);\n\tbcmasp_core_clock_set_ll(priv, clr, set);\n\tspin_unlock_irqrestore(&priv->clk_lock, flags);\n}\n\nvoid bcmasp_core_clock_set_intf(struct bcmasp_intf *intf, bool en)\n{\n\tu32 intf_mask = ASP_CTRL_CLOCK_CTRL_ASP_RGMII_DIS(intf->port);\n\tstruct bcmasp_priv *priv = intf->parent;\n\tunsigned long flags;\n\tu32 reg;\n\n\t \n\tspin_lock_irqsave(&priv->clk_lock, flags);\n\tif (en) {\n\t\tintf_mask |= ASP_CTRL_CLOCK_CTRL_ASP_TX_DISABLE |\n\t\t\t     ASP_CTRL_CLOCK_CTRL_ASP_RX_DISABLE;\n\t\tbcmasp_core_clock_set_ll(priv, intf_mask, 0);\n\t} else {\n\t\treg = ctrl_core_rl(priv, ASP_CTRL_SCRATCH_0) | intf_mask;\n\t\tif ((reg & ASP_CTRL_CLOCK_CTRL_ASP_RGMII_MASK) ==\n\t\t    ASP_CTRL_CLOCK_CTRL_ASP_RGMII_MASK)\n\t\t\tintf_mask |= ASP_CTRL_CLOCK_CTRL_ASP_TX_DISABLE |\n\t\t\t\t     ASP_CTRL_CLOCK_CTRL_ASP_RX_DISABLE;\n\t\tbcmasp_core_clock_set_ll(priv, 0, intf_mask);\n\t}\n\tspin_unlock_irqrestore(&priv->clk_lock, flags);\n}\n\nstatic irqreturn_t bcmasp_isr_wol(int irq, void *data)\n{\n\tstruct bcmasp_priv *priv = data;\n\tu32 status;\n\n\t \n\tif (priv->wol_irq <= 0)\n\t\tgoto irq_handled;\n\n\tstatus = wakeup_intr2_core_rl(priv, ASP_WAKEUP_INTR2_STATUS) &\n\t\t~wakeup_intr2_core_rl(priv, ASP_WAKEUP_INTR2_MASK_STATUS);\n\twakeup_intr2_core_wl(priv, status, ASP_WAKEUP_INTR2_CLEAR);\n\nirq_handled:\n\tpm_wakeup_event(&priv->pdev->dev, 0);\n\treturn IRQ_HANDLED;\n}\n\nstatic int bcmasp_get_and_request_irq(struct bcmasp_priv *priv, int i)\n{\n\tstruct platform_device *pdev = priv->pdev;\n\tint irq, ret;\n\n\tirq = platform_get_irq_optional(pdev, i);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tret = devm_request_irq(&pdev->dev, irq, bcmasp_isr_wol, 0,\n\t\t\t       pdev->name, priv);\n\tif (ret)\n\t\treturn ret;\n\n\treturn irq;\n}\n\nstatic void bcmasp_init_wol_shared(struct bcmasp_priv *priv)\n{\n\tstruct platform_device *pdev = priv->pdev;\n\tstruct device *dev = &pdev->dev;\n\tint irq;\n\n\tirq = bcmasp_get_and_request_irq(priv, 1);\n\tif (irq < 0) {\n\t\tdev_warn(dev, \"Failed to init WoL irq: %d\\n\", irq);\n\t\treturn;\n\t}\n\n\tpriv->wol_irq = irq;\n\tpriv->wol_irq_enabled_mask = 0;\n\tdevice_set_wakeup_capable(&pdev->dev, 1);\n}\n\nstatic void bcmasp_enable_wol_shared(struct bcmasp_intf *intf, bool en)\n{\n\tstruct bcmasp_priv *priv = intf->parent;\n\tstruct device *dev = &priv->pdev->dev;\n\n\tif (en) {\n\t\tif (priv->wol_irq_enabled_mask) {\n\t\t\tset_bit(intf->port, &priv->wol_irq_enabled_mask);\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tset_bit(intf->port, &priv->wol_irq_enabled_mask);\n\t\tenable_irq_wake(priv->wol_irq);\n\t\tdevice_set_wakeup_enable(dev, 1);\n\t} else {\n\t\tif (!priv->wol_irq_enabled_mask)\n\t\t\treturn;\n\n\t\tclear_bit(intf->port, &priv->wol_irq_enabled_mask);\n\t\tif (priv->wol_irq_enabled_mask)\n\t\t\treturn;\n\n\t\t \n\t\tdisable_irq_wake(priv->wol_irq);\n\t\tdevice_set_wakeup_enable(dev, 0);\n\t}\n}\n\nstatic void bcmasp_wol_irq_destroy_shared(struct bcmasp_priv *priv)\n{\n\tif (priv->wol_irq > 0)\n\t\tfree_irq(priv->wol_irq, priv);\n}\n\nstatic void bcmasp_init_wol_per_intf(struct bcmasp_priv *priv)\n{\n\tstruct platform_device *pdev = priv->pdev;\n\tstruct device *dev = &pdev->dev;\n\tstruct bcmasp_intf *intf;\n\tint irq;\n\n\tlist_for_each_entry(intf, &priv->intfs, list) {\n\t\tirq = bcmasp_get_and_request_irq(priv, intf->port + 1);\n\t\tif (irq < 0) {\n\t\t\tdev_warn(dev, \"Failed to init WoL irq(port %d): %d\\n\",\n\t\t\t\t intf->port, irq);\n\t\t\tcontinue;\n\t\t}\n\n\t\tintf->wol_irq = irq;\n\t\tintf->wol_irq_enabled = false;\n\t\tdevice_set_wakeup_capable(&pdev->dev, 1);\n\t}\n}\n\nstatic void bcmasp_enable_wol_per_intf(struct bcmasp_intf *intf, bool en)\n{\n\tstruct device *dev = &intf->parent->pdev->dev;\n\n\tif (en ^ intf->wol_irq_enabled)\n\t\tirq_set_irq_wake(intf->wol_irq, en);\n\n\tintf->wol_irq_enabled = en;\n\tdevice_set_wakeup_enable(dev, en);\n}\n\nstatic void bcmasp_wol_irq_destroy_per_intf(struct bcmasp_priv *priv)\n{\n\tstruct bcmasp_intf *intf;\n\n\tlist_for_each_entry(intf, &priv->intfs, list) {\n\t\tif (intf->wol_irq > 0)\n\t\t\tfree_irq(intf->wol_irq, priv);\n\t}\n}\n\nstatic struct bcmasp_hw_info v20_hw_info = {\n\t.rx_ctrl_flush = ASP_RX_CTRL_FLUSH,\n\t.umac2fb = UMAC2FB_OFFSET,\n\t.rx_ctrl_fb_out_frame_count = ASP_RX_CTRL_FB_OUT_FRAME_COUNT,\n\t.rx_ctrl_fb_filt_out_frame_count = ASP_RX_CTRL_FB_FILT_OUT_FRAME_COUNT,\n\t.rx_ctrl_fb_rx_fifo_depth = ASP_RX_CTRL_FB_RX_FIFO_DEPTH,\n};\n\nstatic const struct bcmasp_plat_data v20_plat_data = {\n\t.init_wol = bcmasp_init_wol_per_intf,\n\t.enable_wol = bcmasp_enable_wol_per_intf,\n\t.destroy_wol = bcmasp_wol_irq_destroy_per_intf,\n\t.hw_info = &v20_hw_info,\n};\n\nstatic struct bcmasp_hw_info v21_hw_info = {\n\t.rx_ctrl_flush = ASP_RX_CTRL_FLUSH_2_1,\n\t.umac2fb = UMAC2FB_OFFSET_2_1,\n\t.rx_ctrl_fb_out_frame_count = ASP_RX_CTRL_FB_OUT_FRAME_COUNT_2_1,\n\t.rx_ctrl_fb_filt_out_frame_count =\n\t\tASP_RX_CTRL_FB_FILT_OUT_FRAME_COUNT_2_1,\n\t.rx_ctrl_fb_rx_fifo_depth = ASP_RX_CTRL_FB_RX_FIFO_DEPTH_2_1,\n};\n\nstatic const struct bcmasp_plat_data v21_plat_data = {\n\t.init_wol = bcmasp_init_wol_shared,\n\t.enable_wol = bcmasp_enable_wol_shared,\n\t.destroy_wol = bcmasp_wol_irq_destroy_shared,\n\t.hw_info = &v21_hw_info,\n};\n\nstatic const struct of_device_id bcmasp_of_match[] = {\n\t{ .compatible = \"brcm,asp-v2.0\", .data = &v20_plat_data },\n\t{ .compatible = \"brcm,asp-v2.1\", .data = &v21_plat_data },\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, bcmasp_of_match);\n\nstatic const struct of_device_id bcmasp_mdio_of_match[] = {\n\t{ .compatible = \"brcm,asp-v2.1-mdio\", },\n\t{ .compatible = \"brcm,asp-v2.0-mdio\", },\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, bcmasp_mdio_of_match);\n\nstatic void bcmasp_remove_intfs(struct bcmasp_priv *priv)\n{\n\tstruct bcmasp_intf *intf, *n;\n\n\tlist_for_each_entry_safe(intf, n, &priv->intfs, list) {\n\t\tlist_del(&intf->list);\n\t\tbcmasp_interface_destroy(intf);\n\t}\n}\n\nstatic int bcmasp_probe(struct platform_device *pdev)\n{\n\tstruct device_node *ports_node, *intf_node;\n\tconst struct bcmasp_plat_data *pdata;\n\tstruct device *dev = &pdev->dev;\n\tstruct bcmasp_priv *priv;\n\tstruct bcmasp_intf *intf;\n\tint ret = 0, count = 0;\n\tunsigned int i;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->irq = platform_get_irq(pdev, 0);\n\tif (priv->irq <= 0)\n\t\treturn -EINVAL;\n\n\tpriv->clk = devm_clk_get_optional_enabled(dev, \"sw_asp\");\n\tif (IS_ERR(priv->clk))\n\t\treturn dev_err_probe(dev, PTR_ERR(priv->clk),\n\t\t\t\t     \"failed to request clock\\n\");\n\n\t \n\tpriv->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(priv->base))\n\t\treturn dev_err_probe(dev, PTR_ERR(priv->base), \"failed to iomap\\n\");\n\n\tret = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(40));\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"unable to set DMA mask: %d\\n\", ret);\n\n\tdev_set_drvdata(&pdev->dev, priv);\n\tpriv->pdev = pdev;\n\tspin_lock_init(&priv->mda_lock);\n\tspin_lock_init(&priv->clk_lock);\n\tmutex_init(&priv->wol_lock);\n\tmutex_init(&priv->net_lock);\n\tINIT_LIST_HEAD(&priv->intfs);\n\n\tpdata = device_get_match_data(&pdev->dev);\n\tif (!pdata)\n\t\treturn dev_err_probe(dev, -EINVAL, \"unable to find platform data\\n\");\n\n\tpriv->init_wol = pdata->init_wol;\n\tpriv->enable_wol = pdata->enable_wol;\n\tpriv->destroy_wol = pdata->destroy_wol;\n\tpriv->hw_info = pdata->hw_info;\n\n\t \n\tbcmasp_core_clock_set(priv, ASP_CTRL_CLOCK_CTRL_ASP_ALL_DISABLE, 0);\n\n\t \n\tbcmasp_core_clock_select(priv, false);\n\n\tbcmasp_intr2_mask_set_all(priv);\n\tbcmasp_intr2_clear_all(priv);\n\n\tret = devm_request_irq(&pdev->dev, priv->irq, bcmasp_isr, 0,\n\t\t\t       pdev->name, priv);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"failed to request ASP interrupt: %d\", ret);\n\n\t \n\tof_platform_populate(dev->of_node, bcmasp_mdio_of_match, NULL, dev);\n\n\t \n\tbcmasp_core_init(priv);\n\tbcmasp_core_init_filters(priv);\n\n\tports_node = of_find_node_by_name(dev->of_node, \"ethernet-ports\");\n\tif (!ports_node) {\n\t\tdev_warn(dev, \"No ports found\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\ti = 0;\n\tfor_each_available_child_of_node(ports_node, intf_node) {\n\t\tintf = bcmasp_interface_create(priv, intf_node, i);\n\t\tif (!intf) {\n\t\t\tdev_err(dev, \"Cannot create eth interface %d\\n\", i);\n\t\t\tbcmasp_remove_intfs(priv);\n\t\t\tof_node_put(intf_node);\n\t\t\tgoto of_put_exit;\n\t\t}\n\t\tlist_add_tail(&intf->list, &priv->intfs);\n\t\ti++;\n\t}\n\n\t \n\tpriv->init_wol(priv);\n\n\t \n\tbcmasp_core_clock_set(priv, 0, ASP_CTRL_CLOCK_CTRL_ASP_ALL_DISABLE);\n\n\tclk_disable_unprepare(priv->clk);\n\n\t \n\tlist_for_each_entry(intf, &priv->intfs, list) {\n\t\tret = register_netdev(intf->ndev);\n\t\tif (ret) {\n\t\t\tnetdev_err(intf->ndev,\n\t\t\t\t   \"failed to register net_device: %d\\n\", ret);\n\t\t\tpriv->destroy_wol(priv);\n\t\t\tbcmasp_remove_intfs(priv);\n\t\t\tgoto of_put_exit;\n\t\t}\n\t\tcount++;\n\t}\n\n\tdev_info(dev, \"Initialized %d port(s)\\n\", count);\n\nof_put_exit:\n\tof_node_put(ports_node);\n\treturn ret;\n}\n\nstatic int bcmasp_remove(struct platform_device *pdev)\n{\n\tstruct bcmasp_priv *priv = dev_get_drvdata(&pdev->dev);\n\n\tif (!priv)\n\t\treturn 0;\n\n\tpriv->destroy_wol(priv);\n\tbcmasp_remove_intfs(priv);\n\n\treturn 0;\n}\n\nstatic void bcmasp_shutdown(struct platform_device *pdev)\n{\n\tbcmasp_remove(pdev);\n}\n\nstatic int __maybe_unused bcmasp_suspend(struct device *d)\n{\n\tstruct bcmasp_priv *priv = dev_get_drvdata(d);\n\tstruct bcmasp_intf *intf;\n\tint ret;\n\n\tlist_for_each_entry(intf, &priv->intfs, list) {\n\t\tret = bcmasp_interface_suspend(intf);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\tret = clk_prepare_enable(priv->clk);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tbcmasp_core_clock_set(priv, 0, ASP_CTRL_CLOCK_CTRL_ASP_TX_DISABLE);\n\n\tbcmasp_core_clock_select(priv, true);\n\n\tclk_disable_unprepare(priv->clk);\n\n\treturn ret;\n}\n\nstatic int __maybe_unused bcmasp_resume(struct device *d)\n{\n\tstruct bcmasp_priv *priv = dev_get_drvdata(d);\n\tstruct bcmasp_intf *intf;\n\tint ret;\n\n\tret = clk_prepare_enable(priv->clk);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tbcmasp_core_clock_select(priv, false);\n\n\t \n\tbcmasp_core_clock_set(priv, ASP_CTRL_CLOCK_CTRL_ASP_ALL_DISABLE, 0);\n\n\tbcmasp_core_init(priv);\n\tbcmasp_core_init_filters(priv);\n\n\t \n\tbcmasp_core_clock_set(priv, 0, ASP_CTRL_CLOCK_CTRL_ASP_ALL_DISABLE);\n\n\tclk_disable_unprepare(priv->clk);\n\n\tlist_for_each_entry(intf, &priv->intfs, list) {\n\t\tret = bcmasp_interface_resume(intf);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic SIMPLE_DEV_PM_OPS(bcmasp_pm_ops,\n\t\t\t bcmasp_suspend, bcmasp_resume);\n\nstatic struct platform_driver bcmasp_driver = {\n\t.probe = bcmasp_probe,\n\t.remove = bcmasp_remove,\n\t.shutdown = bcmasp_shutdown,\n\t.driver = {\n\t\t.name = \"brcm,asp-v2\",\n\t\t.of_match_table = bcmasp_of_match,\n\t\t.pm = &bcmasp_pm_ops,\n\t},\n};\nmodule_platform_driver(bcmasp_driver);\n\nMODULE_DESCRIPTION(\"Broadcom ASP 2.0 Ethernet controller driver\");\nMODULE_ALIAS(\"platform:brcm,asp-v2\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}