{
  "module_name": "bcmasp_ethtool.c",
  "hash_id": "166a58044bd98983cd1ac37ae6b354f855c53882e8b5ea3d1c1fac33603502dd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/broadcom/asp2/bcmasp_ethtool.c",
  "human_readable_source": "\n#define pr_fmt(fmt)\t\t\t\t\"bcmasp_ethtool: \" fmt\n\n#include <asm-generic/unaligned.h>\n#include <linux/ethtool.h>\n#include <linux/netdevice.h>\n#include <linux/platform_device.h>\n\n#include \"bcmasp.h\"\n#include \"bcmasp_intf_defs.h\"\n\nenum bcmasp_stat_type {\n\tBCMASP_STAT_RX_EDPKT,\n\tBCMASP_STAT_RX_CTRL,\n\tBCMASP_STAT_RX_CTRL_PER_INTF,\n\tBCMASP_STAT_SOFT,\n};\n\nstruct bcmasp_stats {\n\tchar stat_string[ETH_GSTRING_LEN];\n\tenum bcmasp_stat_type type;\n\tu32 reg_offset;\n};\n\n#define STAT_BCMASP_SOFT_MIB(str) { \\\n\t.stat_string = str, \\\n\t.type = BCMASP_STAT_SOFT, \\\n}\n\n#define STAT_BCMASP_OFFSET(str, _type, offset) { \\\n\t.stat_string = str, \\\n\t.type = _type, \\\n\t.reg_offset = offset, \\\n}\n\n#define STAT_BCMASP_RX_EDPKT(str, offset) \\\n\tSTAT_BCMASP_OFFSET(str, BCMASP_STAT_RX_EDPKT, offset)\n#define STAT_BCMASP_RX_CTRL(str, offset) \\\n\tSTAT_BCMASP_OFFSET(str, BCMASP_STAT_RX_CTRL, offset)\n#define STAT_BCMASP_RX_CTRL_PER_INTF(str, offset) \\\n\tSTAT_BCMASP_OFFSET(str, BCMASP_STAT_RX_CTRL_PER_INTF, offset)\n\n \nstatic const struct bcmasp_stats bcmasp_gstrings_stats[] = {\n\t \n\tSTAT_BCMASP_RX_EDPKT(\"RX Time Stamp\", ASP_EDPKT_RX_TS_COUNTER),\n\tSTAT_BCMASP_RX_EDPKT(\"RX PKT Count\", ASP_EDPKT_RX_PKT_CNT),\n\tSTAT_BCMASP_RX_EDPKT(\"RX PKT Buffered\", ASP_EDPKT_HDR_EXTR_CNT),\n\tSTAT_BCMASP_RX_EDPKT(\"RX PKT Pushed to DRAM\", ASP_EDPKT_HDR_OUT_CNT),\n\t \n\tSTAT_BCMASP_RX_CTRL_PER_INTF(\"Frames From Unimac\",\n\t\t\t\t     ASP_RX_CTRL_UMAC_0_FRAME_COUNT),\n\tSTAT_BCMASP_RX_CTRL_PER_INTF(\"Frames From Port\",\n\t\t\t\t     ASP_RX_CTRL_FB_0_FRAME_COUNT),\n\tSTAT_BCMASP_RX_CTRL_PER_INTF(\"RX Buffer FIFO Depth\",\n\t\t\t\t     ASP_RX_CTRL_FB_RX_FIFO_DEPTH),\n\tSTAT_BCMASP_RX_CTRL(\"Frames Out(Buffer)\",\n\t\t\t    ASP_RX_CTRL_FB_OUT_FRAME_COUNT),\n\tSTAT_BCMASP_RX_CTRL(\"Frames Out(Filters)\",\n\t\t\t    ASP_RX_CTRL_FB_FILT_OUT_FRAME_COUNT),\n\t \n\tSTAT_BCMASP_SOFT_MIB(\"RX SKB Alloc Failed\"),\n\tSTAT_BCMASP_SOFT_MIB(\"TX DMA Failed\"),\n\tSTAT_BCMASP_SOFT_MIB(\"Multicast Filters Full\"),\n\tSTAT_BCMASP_SOFT_MIB(\"Unicast Filters Full\"),\n\tSTAT_BCMASP_SOFT_MIB(\"MDA Filters Combined\"),\n\tSTAT_BCMASP_SOFT_MIB(\"Promisc Filter Set\"),\n\tSTAT_BCMASP_SOFT_MIB(\"TX Realloc For Offload Failed\"),\n\tSTAT_BCMASP_SOFT_MIB(\"Tx Timeout Count\"),\n};\n\n#define BCMASP_STATS_LEN\tARRAY_SIZE(bcmasp_gstrings_stats)\n\nstatic u16 bcmasp_stat_fixup_offset(struct bcmasp_intf *intf,\n\t\t\t\t    const struct bcmasp_stats *s)\n{\n\tstruct bcmasp_priv *priv = intf->parent;\n\n\tif (!strcmp(\"Frames Out(Buffer)\", s->stat_string))\n\t\treturn priv->hw_info->rx_ctrl_fb_out_frame_count;\n\n\tif (!strcmp(\"Frames Out(Filters)\", s->stat_string))\n\t\treturn priv->hw_info->rx_ctrl_fb_filt_out_frame_count;\n\n\tif (!strcmp(\"RX Buffer FIFO Depth\", s->stat_string))\n\t\treturn priv->hw_info->rx_ctrl_fb_rx_fifo_depth;\n\n\treturn s->reg_offset;\n}\n\nstatic int bcmasp_get_sset_count(struct net_device *dev, int string_set)\n{\n\tswitch (string_set) {\n\tcase ETH_SS_STATS:\n\t\treturn BCMASP_STATS_LEN;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic void bcmasp_get_strings(struct net_device *dev, u32 stringset,\n\t\t\t       u8 *data)\n{\n\tunsigned int i;\n\n\tswitch (stringset) {\n\tcase ETH_SS_STATS:\n\t\tfor (i = 0; i < BCMASP_STATS_LEN; i++) {\n\t\t\tmemcpy(data + i * ETH_GSTRING_LEN,\n\t\t\t       bcmasp_gstrings_stats[i].stat_string,\n\t\t\t       ETH_GSTRING_LEN);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n}\n\nstatic void bcmasp_update_mib_counters(struct bcmasp_intf *intf)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < BCMASP_STATS_LEN; i++) {\n\t\tconst struct bcmasp_stats *s;\n\t\tu32 offset, val;\n\t\tchar *p;\n\n\t\ts = &bcmasp_gstrings_stats[i];\n\t\toffset = bcmasp_stat_fixup_offset(intf, s);\n\t\tswitch (s->type) {\n\t\tcase BCMASP_STAT_SOFT:\n\t\t\tcontinue;\n\t\tcase BCMASP_STAT_RX_EDPKT:\n\t\t\tval = rx_edpkt_core_rl(intf->parent, offset);\n\t\t\tbreak;\n\t\tcase BCMASP_STAT_RX_CTRL:\n\t\t\tval = rx_ctrl_core_rl(intf->parent, offset);\n\t\t\tbreak;\n\t\tcase BCMASP_STAT_RX_CTRL_PER_INTF:\n\t\t\toffset += sizeof(u32) * intf->port;\n\t\t\tval = rx_ctrl_core_rl(intf->parent, offset);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\t\tp = (char *)(&intf->mib) + (i * sizeof(u32));\n\t\tput_unaligned(val, (u32 *)p);\n\t}\n}\n\nstatic void bcmasp_get_ethtool_stats(struct net_device *dev,\n\t\t\t\t     struct ethtool_stats *stats,\n\t\t\t\t     u64 *data)\n{\n\tstruct bcmasp_intf *intf = netdev_priv(dev);\n\tunsigned int i;\n\tchar *p;\n\n\tif (netif_running(dev))\n\t\tbcmasp_update_mib_counters(intf);\n\n\tfor (i = 0; i < BCMASP_STATS_LEN; i++) {\n\t\tp = (char *)(&intf->mib) + (i * sizeof(u32));\n\t\tdata[i] = *(u32 *)p;\n\t}\n}\n\nstatic void bcmasp_get_drvinfo(struct net_device *dev,\n\t\t\t       struct ethtool_drvinfo *info)\n{\n\tstrscpy(info->driver, \"bcmasp\", sizeof(info->driver));\n\tstrscpy(info->bus_info, dev_name(dev->dev.parent),\n\t\tsizeof(info->bus_info));\n}\n\nstatic u32 bcmasp_get_msglevel(struct net_device *dev)\n{\n\tstruct bcmasp_intf *intf = netdev_priv(dev);\n\n\treturn intf->msg_enable;\n}\n\nstatic void bcmasp_set_msglevel(struct net_device *dev, u32 level)\n{\n\tstruct bcmasp_intf *intf = netdev_priv(dev);\n\n\tintf->msg_enable = level;\n}\n\n#define BCMASP_SUPPORTED_WAKE   (WAKE_MAGIC | WAKE_MAGICSECURE | WAKE_FILTER)\nstatic void bcmasp_get_wol(struct net_device *dev, struct ethtool_wolinfo *wol)\n{\n\tstruct bcmasp_intf *intf = netdev_priv(dev);\n\n\twol->supported = BCMASP_SUPPORTED_WAKE;\n\twol->wolopts = intf->wolopts;\n\tmemset(wol->sopass, 0, sizeof(wol->sopass));\n\n\tif (wol->wolopts & WAKE_MAGICSECURE)\n\t\tmemcpy(wol->sopass, intf->sopass, sizeof(intf->sopass));\n}\n\nstatic int bcmasp_set_wol(struct net_device *dev, struct ethtool_wolinfo *wol)\n{\n\tstruct bcmasp_intf *intf = netdev_priv(dev);\n\tstruct bcmasp_priv *priv = intf->parent;\n\tstruct device *kdev = &priv->pdev->dev;\n\n\tif (!device_can_wakeup(kdev))\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tintf->wolopts = wol->wolopts;\n\tif (intf->wolopts & WAKE_MAGICSECURE)\n\t\tmemcpy(intf->sopass, wol->sopass, sizeof(wol->sopass));\n\n\tmutex_lock(&priv->wol_lock);\n\tpriv->enable_wol(intf, !!intf->wolopts);\n\tmutex_unlock(&priv->wol_lock);\n\n\treturn 0;\n}\n\nstatic int bcmasp_flow_insert(struct net_device *dev, struct ethtool_rxnfc *cmd)\n{\n\tstruct bcmasp_intf *intf = netdev_priv(dev);\n\tstruct bcmasp_net_filter *nfilter;\n\tu32 loc = cmd->fs.location;\n\tbool wake = false;\n\n\tif (cmd->fs.ring_cookie == RX_CLS_FLOW_WAKE)\n\t\twake = true;\n\n\t \n\tif (!wake)\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (cmd->fs.flow_type & ~(FLOW_EXT | FLOW_MAC_EXT)) {\n\tcase ETHER_FLOW:\n\tcase IP_USER_FLOW:\n\tcase TCP_V4_FLOW:\n\tcase UDP_V4_FLOW:\n\tcase TCP_V6_FLOW:\n\tcase UDP_V6_FLOW:\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t \n\tif (bcmasp_netfilt_check_dup(intf, &cmd->fs))\n\t\treturn -EINVAL;\n\n\tnfilter = bcmasp_netfilt_get_init(intf, loc, wake, true);\n\tif (IS_ERR(nfilter))\n\t\treturn PTR_ERR(nfilter);\n\n\t \n\tcmd->fs.location = nfilter->hw_index;\n\tmemcpy(&nfilter->fs, &cmd->fs, sizeof(struct ethtool_rx_flow_spec));\n\n\t \n\treturn 0;\n}\n\nstatic int bcmasp_flow_delete(struct net_device *dev, struct ethtool_rxnfc *cmd)\n{\n\tstruct bcmasp_intf *intf = netdev_priv(dev);\n\tstruct bcmasp_net_filter *nfilter;\n\n\tnfilter = bcmasp_netfilt_get_init(intf, cmd->fs.location, false, false);\n\tif (IS_ERR(nfilter))\n\t\treturn PTR_ERR(nfilter);\n\n\tbcmasp_netfilt_release(intf, nfilter);\n\n\treturn 0;\n}\n\nstatic int bcmasp_flow_get(struct bcmasp_intf *intf, struct ethtool_rxnfc *cmd)\n{\n\tstruct bcmasp_net_filter *nfilter;\n\n\tnfilter = bcmasp_netfilt_get_init(intf, cmd->fs.location, false, false);\n\tif (IS_ERR(nfilter))\n\t\treturn PTR_ERR(nfilter);\n\n\tmemcpy(&cmd->fs, &nfilter->fs, sizeof(nfilter->fs));\n\n\tcmd->data = NUM_NET_FILTERS;\n\n\treturn 0;\n}\n\nstatic int bcmasp_set_rxnfc(struct net_device *dev, struct ethtool_rxnfc *cmd)\n{\n\tstruct bcmasp_intf *intf = netdev_priv(dev);\n\tint ret = -EOPNOTSUPP;\n\n\tmutex_lock(&intf->parent->net_lock);\n\n\tswitch (cmd->cmd) {\n\tcase ETHTOOL_SRXCLSRLINS:\n\t\tret = bcmasp_flow_insert(dev, cmd);\n\t\tbreak;\n\tcase ETHTOOL_SRXCLSRLDEL:\n\t\tret = bcmasp_flow_delete(dev, cmd);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tmutex_unlock(&intf->parent->net_lock);\n\n\treturn ret;\n}\n\nstatic int bcmasp_get_rxnfc(struct net_device *dev, struct ethtool_rxnfc *cmd,\n\t\t\t    u32 *rule_locs)\n{\n\tstruct bcmasp_intf *intf = netdev_priv(dev);\n\tint err = 0;\n\n\tmutex_lock(&intf->parent->net_lock);\n\n\tswitch (cmd->cmd) {\n\tcase ETHTOOL_GRXCLSRLCNT:\n\t\tcmd->rule_cnt = bcmasp_netfilt_get_active(intf);\n\t\t \n\t\tcmd->data |= RX_CLS_LOC_SPECIAL;\n\t\tbreak;\n\tcase ETHTOOL_GRXCLSRULE:\n\t\terr = bcmasp_flow_get(intf, cmd);\n\t\tbreak;\n\tcase ETHTOOL_GRXCLSRLALL:\n\t\terr = bcmasp_netfilt_get_all_active(intf, rule_locs, &cmd->rule_cnt);\n\t\tcmd->data = NUM_NET_FILTERS;\n\t\tbreak;\n\tdefault:\n\t\terr = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\n\tmutex_unlock(&intf->parent->net_lock);\n\n\treturn err;\n}\n\nvoid bcmasp_eee_enable_set(struct bcmasp_intf *intf, bool enable)\n{\n\tu32 reg;\n\n\treg = umac_rl(intf, UMC_EEE_CTRL);\n\tif (enable)\n\t\treg |= EEE_EN;\n\telse\n\t\treg &= ~EEE_EN;\n\tumac_wl(intf, reg, UMC_EEE_CTRL);\n\n\tintf->eee.eee_enabled = enable;\n\tintf->eee.eee_active = enable;\n}\n\nstatic int bcmasp_get_eee(struct net_device *dev, struct ethtool_eee *e)\n{\n\tstruct bcmasp_intf *intf = netdev_priv(dev);\n\tstruct ethtool_eee *p = &intf->eee;\n\n\tif (!dev->phydev)\n\t\treturn -ENODEV;\n\n\te->eee_enabled = p->eee_enabled;\n\te->eee_active = p->eee_active;\n\te->tx_lpi_enabled = p->tx_lpi_enabled;\n\te->tx_lpi_timer = umac_rl(intf, UMC_EEE_LPI_TIMER);\n\n\treturn phy_ethtool_get_eee(dev->phydev, e);\n}\n\nstatic int bcmasp_set_eee(struct net_device *dev, struct ethtool_eee *e)\n{\n\tstruct bcmasp_intf *intf = netdev_priv(dev);\n\tstruct ethtool_eee *p = &intf->eee;\n\tint ret;\n\n\tif (!dev->phydev)\n\t\treturn -ENODEV;\n\n\tif (!p->eee_enabled) {\n\t\tbcmasp_eee_enable_set(intf, false);\n\t} else {\n\t\tret = phy_init_eee(dev->phydev, 0);\n\t\tif (ret) {\n\t\t\tnetif_err(intf, hw, dev,\n\t\t\t\t  \"EEE initialization failed: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tumac_wl(intf, e->tx_lpi_timer, UMC_EEE_LPI_TIMER);\n\t\tintf->eee.eee_active = ret >= 0;\n\t\tintf->eee.tx_lpi_enabled = e->tx_lpi_enabled;\n\t\tbcmasp_eee_enable_set(intf, true);\n\t}\n\n\treturn phy_ethtool_set_eee(dev->phydev, e);\n}\n\nstatic void bcmasp_get_eth_mac_stats(struct net_device *dev,\n\t\t\t\t     struct ethtool_eth_mac_stats *mac_stats)\n{\n\tstruct bcmasp_intf *intf = netdev_priv(dev);\n\n\tmac_stats->FramesTransmittedOK = umac_rl(intf, UMC_GTPOK);\n\tmac_stats->SingleCollisionFrames = umac_rl(intf, UMC_GTSCL);\n\tmac_stats->MultipleCollisionFrames = umac_rl(intf, UMC_GTMCL);\n\tmac_stats->FramesReceivedOK = umac_rl(intf, UMC_GRPOK);\n\tmac_stats->FrameCheckSequenceErrors = umac_rl(intf, UMC_GRFCS);\n\tmac_stats->AlignmentErrors = umac_rl(intf, UMC_GRALN);\n\tmac_stats->OctetsTransmittedOK = umac_rl(intf, UMC_GTBYT);\n\tmac_stats->FramesWithDeferredXmissions = umac_rl(intf, UMC_GTDRF);\n\tmac_stats->LateCollisions = umac_rl(intf, UMC_GTLCL);\n\tmac_stats->FramesAbortedDueToXSColls = umac_rl(intf, UMC_GTXCL);\n\tmac_stats->OctetsReceivedOK = umac_rl(intf, UMC_GRBYT);\n\tmac_stats->MulticastFramesXmittedOK = umac_rl(intf, UMC_GTMCA);\n\tmac_stats->BroadcastFramesXmittedOK = umac_rl(intf, UMC_GTBCA);\n\tmac_stats->FramesWithExcessiveDeferral = umac_rl(intf, UMC_GTEDF);\n\tmac_stats->MulticastFramesReceivedOK = umac_rl(intf, UMC_GRMCA);\n\tmac_stats->BroadcastFramesReceivedOK = umac_rl(intf, UMC_GRBCA);\n}\n\nstatic const struct ethtool_rmon_hist_range bcmasp_rmon_ranges[] = {\n\t{    0,   64},\n\t{   65,  127},\n\t{  128,  255},\n\t{  256,  511},\n\t{  512, 1023},\n\t{ 1024, 1518},\n\t{ 1519, 1522},\n\t{}\n};\n\nstatic void bcmasp_get_rmon_stats(struct net_device *dev,\n\t\t\t\t  struct ethtool_rmon_stats *rmon_stats,\n\t\t\t\t  const struct ethtool_rmon_hist_range **ranges)\n{\n\tstruct bcmasp_intf *intf = netdev_priv(dev);\n\n\t*ranges = bcmasp_rmon_ranges;\n\n\trmon_stats->undersize_pkts = umac_rl(intf, UMC_RRUND);\n\trmon_stats->oversize_pkts = umac_rl(intf, UMC_GROVR);\n\trmon_stats->fragments = umac_rl(intf, UMC_RRFRG);\n\trmon_stats->jabbers = umac_rl(intf, UMC_GRJBR);\n\n\trmon_stats->hist[0] = umac_rl(intf, UMC_GR64);\n\trmon_stats->hist[1] = umac_rl(intf, UMC_GR127);\n\trmon_stats->hist[2] = umac_rl(intf, UMC_GR255);\n\trmon_stats->hist[3] = umac_rl(intf, UMC_GR511);\n\trmon_stats->hist[4] = umac_rl(intf, UMC_GR1023);\n\trmon_stats->hist[5] = umac_rl(intf, UMC_GR1518);\n\trmon_stats->hist[6] = umac_rl(intf, UMC_GRMGV);\n\n\trmon_stats->hist_tx[0] = umac_rl(intf, UMC_TR64);\n\trmon_stats->hist_tx[1] = umac_rl(intf, UMC_TR127);\n\trmon_stats->hist_tx[2] = umac_rl(intf, UMC_TR255);\n\trmon_stats->hist_tx[3] = umac_rl(intf, UMC_TR511);\n\trmon_stats->hist_tx[4] = umac_rl(intf, UMC_TR1023);\n\trmon_stats->hist_tx[5] = umac_rl(intf, UMC_TR1518);\n\trmon_stats->hist_tx[6] = umac_rl(intf, UMC_TRMGV);\n}\n\nstatic void bcmasp_get_eth_ctrl_stats(struct net_device *dev,\n\t\t\t\t      struct ethtool_eth_ctrl_stats *ctrl_stats)\n{\n\tstruct bcmasp_intf *intf = netdev_priv(dev);\n\n\tctrl_stats->MACControlFramesTransmitted = umac_rl(intf, UMC_GTXCF);\n\tctrl_stats->MACControlFramesReceived = umac_rl(intf, UMC_GRXCF);\n\tctrl_stats->UnsupportedOpcodesReceived = umac_rl(intf, UMC_GRXUO);\n}\n\nconst struct ethtool_ops bcmasp_ethtool_ops = {\n\t.get_drvinfo\t\t= bcmasp_get_drvinfo,\n\t.get_link\t\t= ethtool_op_get_link,\n\t.get_link_ksettings\t= phy_ethtool_get_link_ksettings,\n\t.set_link_ksettings\t= phy_ethtool_set_link_ksettings,\n\t.get_msglevel\t\t= bcmasp_get_msglevel,\n\t.set_msglevel\t\t= bcmasp_set_msglevel,\n\t.get_wol\t\t= bcmasp_get_wol,\n\t.set_wol\t\t= bcmasp_set_wol,\n\t.get_rxnfc\t\t= bcmasp_get_rxnfc,\n\t.set_rxnfc\t\t= bcmasp_set_rxnfc,\n\t.set_eee\t\t= bcmasp_set_eee,\n\t.get_eee\t\t= bcmasp_get_eee,\n\t.get_eth_mac_stats\t= bcmasp_get_eth_mac_stats,\n\t.get_rmon_stats\t\t= bcmasp_get_rmon_stats,\n\t.get_eth_ctrl_stats\t= bcmasp_get_eth_ctrl_stats,\n\t.get_strings\t\t= bcmasp_get_strings,\n\t.get_ethtool_stats\t= bcmasp_get_ethtool_stats,\n\t.get_sset_count\t\t= bcmasp_get_sset_count,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}