{
  "module_name": "bgmac-bcma-mdio.c",
  "hash_id": "135ec44af357755c38c0475549919b2a5db5d159214e1c02dedd5fbf94000e38",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/broadcom/bgmac-bcma-mdio.c",
  "human_readable_source": " \n\n#define pr_fmt(fmt)\t\tKBUILD_MODNAME \": \" fmt\n\n#include <linux/bcma/bcma.h>\n#include <linux/brcmphy.h>\n#include <linux/of_mdio.h>\n#include \"bgmac.h\"\n\nstatic bool bcma_mdio_wait_value(struct bcma_device *core, u16 reg, u32 mask,\n\t\t\t\t u32 value, int timeout)\n{\n\tu32 val;\n\tint i;\n\n\tfor (i = 0; i < timeout / 10; i++) {\n\t\tval = bcma_read32(core, reg);\n\t\tif ((val & mask) == value)\n\t\t\treturn true;\n\t\tudelay(10);\n\t}\n\tdev_err(&core->dev, \"Timeout waiting for reg 0x%X\\n\", reg);\n\treturn false;\n}\n\n \n\nstatic u16 bcma_mdio_phy_read(struct bgmac *bgmac, u8 phyaddr, u8 reg)\n{\n\tstruct bcma_device *core;\n\tu16 phy_access_addr;\n\tu16 phy_ctl_addr;\n\tu32 tmp;\n\n\tBUILD_BUG_ON(BGMAC_PA_DATA_MASK != BCMA_GMAC_CMN_PA_DATA_MASK);\n\tBUILD_BUG_ON(BGMAC_PA_ADDR_MASK != BCMA_GMAC_CMN_PA_ADDR_MASK);\n\tBUILD_BUG_ON(BGMAC_PA_ADDR_SHIFT != BCMA_GMAC_CMN_PA_ADDR_SHIFT);\n\tBUILD_BUG_ON(BGMAC_PA_REG_MASK != BCMA_GMAC_CMN_PA_REG_MASK);\n\tBUILD_BUG_ON(BGMAC_PA_REG_SHIFT != BCMA_GMAC_CMN_PA_REG_SHIFT);\n\tBUILD_BUG_ON(BGMAC_PA_WRITE != BCMA_GMAC_CMN_PA_WRITE);\n\tBUILD_BUG_ON(BGMAC_PA_START != BCMA_GMAC_CMN_PA_START);\n\tBUILD_BUG_ON(BGMAC_PC_EPA_MASK != BCMA_GMAC_CMN_PC_EPA_MASK);\n\tBUILD_BUG_ON(BGMAC_PC_MCT_MASK != BCMA_GMAC_CMN_PC_MCT_MASK);\n\tBUILD_BUG_ON(BGMAC_PC_MCT_SHIFT != BCMA_GMAC_CMN_PC_MCT_SHIFT);\n\tBUILD_BUG_ON(BGMAC_PC_MTE != BCMA_GMAC_CMN_PC_MTE);\n\n\tif (bgmac->bcma.core->id.id == BCMA_CORE_4706_MAC_GBIT) {\n\t\tcore = bgmac->bcma.core->bus->drv_gmac_cmn.core;\n\t\tphy_access_addr = BCMA_GMAC_CMN_PHY_ACCESS;\n\t\tphy_ctl_addr = BCMA_GMAC_CMN_PHY_CTL;\n\t} else {\n\t\tcore = bgmac->bcma.core;\n\t\tphy_access_addr = BGMAC_PHY_ACCESS;\n\t\tphy_ctl_addr = BGMAC_PHY_CNTL;\n\t}\n\n\ttmp = bcma_read32(core, phy_ctl_addr);\n\ttmp &= ~BGMAC_PC_EPA_MASK;\n\ttmp |= phyaddr;\n\tbcma_write32(core, phy_ctl_addr, tmp);\n\n\ttmp = BGMAC_PA_START;\n\ttmp |= phyaddr << BGMAC_PA_ADDR_SHIFT;\n\ttmp |= reg << BGMAC_PA_REG_SHIFT;\n\tbcma_write32(core, phy_access_addr, tmp);\n\n\tif (!bcma_mdio_wait_value(core, phy_access_addr, BGMAC_PA_START, 0,\n\t\t\t\t  1000)) {\n\t\tdev_err(&core->dev, \"Reading PHY %d register 0x%X failed\\n\",\n\t\t\tphyaddr, reg);\n\t\treturn 0xffff;\n\t}\n\n\treturn bcma_read32(core, phy_access_addr) & BGMAC_PA_DATA_MASK;\n}\n\n \n\tif (ci->id == BCMA_CHIP_ID_BCM5356) {\n\t\tfor (i = 0; i < 5; i++) {\n\t\t\tbcma_mdio_phy_write(bgmac, i, 0x1f, 0x008b);\n\t\t\tbcma_mdio_phy_write(bgmac, i, 0x15, 0x0100);\n\t\t\tbcma_mdio_phy_write(bgmac, i, 0x1f, 0x000f);\n\t\t\tbcma_mdio_phy_write(bgmac, i, 0x12, 0x2aaa);\n\t\t\tbcma_mdio_phy_write(bgmac, i, 0x1f, 0x000b);\n\t\t}\n\t\treturn;\n\t}\n\tif ((ci->id == BCMA_CHIP_ID_BCM5357 && ci->pkg != 10) ||\n\t    (ci->id == BCMA_CHIP_ID_BCM4749 && ci->pkg != 10) ||\n\t    (ci->id == BCMA_CHIP_ID_BCM53572 && ci->pkg != 9)) {\n\t\tstruct bcma_drv_cc *cc = &bgmac->bcma.core->bus->drv_cc;\n\n\t\tbcma_chipco_chipctl_maskset(cc, 2, ~0xc0000000, 0);\n\t\tbcma_chipco_chipctl_maskset(cc, 4, ~0x80000000, 0);\n\t\tfor (i = 0; i < 5; i++) {\n\t\t\tbcma_mdio_phy_write(bgmac, i, 0x1f, 0x000f);\n\t\t\tbcma_mdio_phy_write(bgmac, i, 0x16, 0x5284);\n\t\t\tbcma_mdio_phy_write(bgmac, i, 0x1f, 0x000b);\n\t\t\tbcma_mdio_phy_write(bgmac, i, 0x17, 0x0010);\n\t\t\tbcma_mdio_phy_write(bgmac, i, 0x1f, 0x000f);\n\t\t\tbcma_mdio_phy_write(bgmac, i, 0x16, 0x5296);\n\t\t\tbcma_mdio_phy_write(bgmac, i, 0x17, 0x1073);\n\t\t\tbcma_mdio_phy_write(bgmac, i, 0x17, 0x9073);\n\t\t\tbcma_mdio_phy_write(bgmac, i, 0x16, 0x52b6);\n\t\t\tbcma_mdio_phy_write(bgmac, i, 0x17, 0x9273);\n\t\t\tbcma_mdio_phy_write(bgmac, i, 0x1f, 0x000b);\n\t\t}\n\t\treturn;\n\t}\n\n\t \n\tif (bgmac->net_dev && bgmac->net_dev->phydev)\n\t\tphy_init_hw(bgmac->net_dev->phydev);\n}\n\n \n\nstatic int bcma_mdio_mii_read(struct mii_bus *bus, int mii_id, int regnum)\n{\n\treturn bcma_mdio_phy_read(bus->priv, mii_id, regnum);\n}\n\nstatic int bcma_mdio_mii_write(struct mii_bus *bus, int mii_id, int regnum,\n\t\t\t       u16 value)\n{\n\treturn bcma_mdio_phy_write(bus->priv, mii_id, regnum, value);\n}\n\nstruct mii_bus *bcma_mdio_mii_register(struct bgmac *bgmac)\n{\n\tstruct bcma_device *core = bgmac->bcma.core;\n\tstruct mii_bus *mii_bus;\n\tstruct device_node *np;\n\tint err;\n\n\tmii_bus = mdiobus_alloc();\n\tif (!mii_bus) {\n\t\terr = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tmii_bus->name = \"bcma_mdio mii bus\";\n\tsprintf(mii_bus->id, \"%s-%d-%d\", \"bcma_mdio\", core->bus->num,\n\t\tcore->core_unit);\n\tmii_bus->priv = bgmac;\n\tmii_bus->read = bcma_mdio_mii_read;\n\tmii_bus->write = bcma_mdio_mii_write;\n\tmii_bus->reset = bcma_mdio_phy_reset;\n\tmii_bus->parent = &core->dev;\n\tmii_bus->phy_mask = ~(1 << bgmac->phyaddr);\n\n\tnp = of_get_child_by_name(core->dev.of_node, \"mdio\");\n\n\terr = of_mdiobus_register(mii_bus, np);\n\tof_node_put(np);\n\tif (err) {\n\t\tdev_err(&core->dev, \"Registration of mii bus failed\\n\");\n\t\tgoto err_free_bus;\n\t}\n\n\treturn mii_bus;\n\nerr_free_bus:\n\tmdiobus_free(mii_bus);\nerr:\n\treturn ERR_PTR(err);\n}\nEXPORT_SYMBOL_GPL(bcma_mdio_mii_register);\n\nvoid bcma_mdio_mii_unregister(struct mii_bus *mii_bus)\n{\n\tif (!mii_bus)\n\t\treturn;\n\n\tmdiobus_unregister(mii_bus);\n\tmdiobus_free(mii_bus);\n}\nEXPORT_SYMBOL_GPL(bcma_mdio_mii_unregister);\n\nMODULE_AUTHOR(\"Rafa\u0142 Mi\u0142ecki\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}