{
  "module_name": "bnx2x_dcb.c",
  "hash_id": "58c2bae3f7dadafcb320f0b7e74daa2433c598b1147b121f4b820665dc2e5067",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/broadcom/bnx2x/bnx2x_dcb.c",
  "human_readable_source": " \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/netdevice.h>\n#include <linux/types.h>\n#include <linux/errno.h>\n#include <linux/rtnetlink.h>\n#include <net/dcbnl.h>\n\n#include \"bnx2x.h\"\n#include \"bnx2x_cmn.h\"\n#include \"bnx2x_dcb.h\"\n\n \nstatic void bnx2x_pfc_set_pfc(struct bnx2x *bp);\nstatic void bnx2x_dcbx_update_ets_params(struct bnx2x *bp);\nstatic void bnx2x_dcbx_get_ets_pri_pg_tbl(struct bnx2x *bp,\n\t\t\t\t\t  u32 *set_configuration_ets_pg,\n\t\t\t\t\t  u32 *pri_pg_tbl);\nstatic void bnx2x_dcbx_get_num_pg_traf_type(struct bnx2x *bp,\n\t\t\t\t\t    u32 *pg_pri_orginal_spread,\n\t\t\t\t\t    struct pg_help_data *help_data);\nstatic void bnx2x_dcbx_fill_cos_params(struct bnx2x *bp,\n\t\t\t\t       struct pg_help_data *help_data,\n\t\t\t\t       struct dcbx_ets_feature *ets,\n\t\t\t\t       u32 *pg_pri_orginal_spread);\nstatic void bnx2x_dcbx_separate_pauseable_from_non(struct bnx2x *bp,\n\t\t\t\tstruct cos_help_data *cos_data,\n\t\t\t\tu32 *pg_pri_orginal_spread,\n\t\t\t\tstruct dcbx_ets_feature *ets);\nstatic void bnx2x_dcbx_fw_struct(struct bnx2x *bp,\n\t\t\t\t struct bnx2x_func_tx_start_params*);\n\n \nstatic void bnx2x_read_data(struct bnx2x *bp, u32 *buff,\n\t\t\t\t   u32 addr, u32 len)\n{\n\tint i;\n\tfor (i = 0; i < len; i += 4, buff++)\n\t\t*buff = REG_RD(bp, addr + i);\n}\n\nstatic void bnx2x_write_data(struct bnx2x *bp, u32 *buff,\n\t\t\t\t    u32 addr, u32 len)\n{\n\tint i;\n\tfor (i = 0; i < len; i += 4, buff++)\n\t\tREG_WR(bp, addr + i, *buff);\n}\n\nstatic void bnx2x_pfc_set(struct bnx2x *bp)\n{\n\tstruct bnx2x_nig_brb_pfc_port_params pfc_params = {0};\n\tu32 pri_bit, val = 0;\n\tint i;\n\n\tpfc_params.num_of_rx_cos_priority_mask =\n\t\t\t\t\tbp->dcbx_port_params.ets.num_of_cos;\n\n\t \n\tfor (i = 0; i < bp->dcbx_port_params.ets.num_of_cos; i++)\n\t\t \n\t\tpfc_params.rx_cos_priority_mask[i] =\n\t\t\tbp->dcbx_port_params.ets.cos_params[i].pri_bitmask\n\t\t\t\t& DCBX_PFC_PRI_PAUSE_MASK(bp);\n\n\t \n\tfor (i = 0 ; i < MAX_PFC_PRIORITIES ; i++) {\n\t\tpri_bit = 1 << i;\n\n\t\tif (!(pri_bit & DCBX_PFC_PRI_PAUSE_MASK(bp)))\n\t\t\tval |= 1 << (i * 4);\n\t}\n\n\tpfc_params.pkt_priority_to_cos = val;\n\n\t \n\tpfc_params.llfc_low_priority_classes = DCBX_PFC_PRI_PAUSE_MASK(bp);\n\t \n\tpfc_params.llfc_high_priority_classes = 0;\n\n\tbnx2x_acquire_phy_lock(bp);\n\tbp->link_params.feature_config_flags |= FEATURE_CONFIG_PFC_ENABLED;\n\tbnx2x_update_pfc(&bp->link_params, &bp->link_vars, &pfc_params);\n\tbnx2x_release_phy_lock(bp);\n}\n\nstatic void bnx2x_pfc_clear(struct bnx2x *bp)\n{\n\tstruct bnx2x_nig_brb_pfc_port_params nig_params = {0};\n\tnig_params.pause_enable = 1;\n\tbnx2x_acquire_phy_lock(bp);\n\tbp->link_params.feature_config_flags &= ~FEATURE_CONFIG_PFC_ENABLED;\n\tbnx2x_update_pfc(&bp->link_params, &bp->link_vars, &nig_params);\n\tbnx2x_release_phy_lock(bp);\n}\n\nstatic void  bnx2x_dump_dcbx_drv_param(struct bnx2x *bp,\n\t\t\t\t       struct dcbx_features *features,\n\t\t\t\t       u32 error)\n{\n\tu8 i = 0;\n\tDP(NETIF_MSG_LINK, \"local_mib.error %x\\n\", error);\n\n\t \n\tDP(NETIF_MSG_LINK,\n\t   \"local_mib.features.ets.enabled %x\\n\", features->ets.enabled);\n\tfor (i = 0; i < DCBX_MAX_NUM_PG_BW_ENTRIES; i++)\n\t\tDP(NETIF_MSG_LINK,\n\t\t   \"local_mib.features.ets.pg_bw_tbl[%d] %d\\n\", i,\n\t\t   DCBX_PG_BW_GET(features->ets.pg_bw_tbl, i));\n\tfor (i = 0; i < DCBX_MAX_NUM_PRI_PG_ENTRIES; i++)\n\t\tDP(NETIF_MSG_LINK,\n\t\t   \"local_mib.features.ets.pri_pg_tbl[%d] %d\\n\", i,\n\t\t   DCBX_PRI_PG_GET(features->ets.pri_pg_tbl, i));\n\n\t \n\tDP(BNX2X_MSG_DCB, \"dcbx_features.pfc.pri_en_bitmap %x\\n\",\n\t\t\t\t\tfeatures->pfc.pri_en_bitmap);\n\tDP(BNX2X_MSG_DCB, \"dcbx_features.pfc.pfc_caps %x\\n\",\n\t\t\t\t\tfeatures->pfc.pfc_caps);\n\tDP(BNX2X_MSG_DCB, \"dcbx_features.pfc.enabled %x\\n\",\n\t\t\t\t\tfeatures->pfc.enabled);\n\n\tDP(BNX2X_MSG_DCB, \"dcbx_features.app.default_pri %x\\n\",\n\t\t\t\t\tfeatures->app.default_pri);\n\tDP(BNX2X_MSG_DCB, \"dcbx_features.app.tc_supported %x\\n\",\n\t\t\t\t\tfeatures->app.tc_supported);\n\tDP(BNX2X_MSG_DCB, \"dcbx_features.app.enabled %x\\n\",\n\t\t\t\t\tfeatures->app.enabled);\n\tfor (i = 0; i < DCBX_MAX_APP_PROTOCOL; i++) {\n\t\tDP(BNX2X_MSG_DCB,\n\t\t   \"dcbx_features.app.app_pri_tbl[%x].app_id %x\\n\",\n\t\t   i, features->app.app_pri_tbl[i].app_id);\n\t\tDP(BNX2X_MSG_DCB,\n\t\t   \"dcbx_features.app.app_pri_tbl[%x].pri_bitmap %x\\n\",\n\t\t   i, features->app.app_pri_tbl[i].pri_bitmap);\n\t\tDP(BNX2X_MSG_DCB,\n\t\t   \"dcbx_features.app.app_pri_tbl[%x].appBitfield %x\\n\",\n\t\t   i, features->app.app_pri_tbl[i].appBitfield);\n\t}\n}\n\nstatic void bnx2x_dcbx_get_ap_priority(struct bnx2x *bp,\n\t\t\t\t       u8 pri_bitmap,\n\t\t\t\t       u8 llfc_traf_type)\n{\n\tu32 pri = MAX_PFC_PRIORITIES;\n\tu32 index = MAX_PFC_PRIORITIES - 1;\n\tu32 pri_mask;\n\tu32 *ttp = bp->dcbx_port_params.app.traffic_type_priority;\n\n\t \n\twhile ((MAX_PFC_PRIORITIES == pri) && (0 != index)) {\n\t\tpri_mask = 1 << index;\n\t\tif (GET_FLAGS(pri_bitmap, pri_mask))\n\t\t\tpri = index ;\n\t\tindex--;\n\t}\n\n\tif (pri < MAX_PFC_PRIORITIES)\n\t\tttp[llfc_traf_type] = max_t(u32, ttp[llfc_traf_type], pri);\n}\n\nstatic void bnx2x_dcbx_get_ap_feature(struct bnx2x *bp,\n\t\t\t\t   struct dcbx_app_priority_feature *app,\n\t\t\t\t   u32 error) {\n\tu8 index;\n\tu32 *ttp = bp->dcbx_port_params.app.traffic_type_priority;\n\tu8 iscsi_pri_found = 0, fcoe_pri_found = 0;\n\n\tif (GET_FLAGS(error, DCBX_LOCAL_APP_ERROR))\n\t\tDP(BNX2X_MSG_DCB, \"DCBX_LOCAL_APP_ERROR\\n\");\n\n\tif (GET_FLAGS(error, DCBX_LOCAL_APP_MISMATCH))\n\t\tDP(BNX2X_MSG_DCB, \"DCBX_LOCAL_APP_MISMATCH\\n\");\n\n\tif (GET_FLAGS(error, DCBX_REMOTE_APP_TLV_NOT_FOUND))\n\t\tDP(BNX2X_MSG_DCB, \"DCBX_REMOTE_APP_TLV_NOT_FOUND\\n\");\n\tif (app->enabled &&\n\t    !GET_FLAGS(error, DCBX_LOCAL_APP_ERROR | DCBX_LOCAL_APP_MISMATCH |\n\t\t\t      DCBX_REMOTE_APP_TLV_NOT_FOUND)) {\n\n\t\tbp->dcbx_port_params.app.enabled = true;\n\n\t\t \n\t\tfor (index = 0 ; index < LLFC_DRIVER_TRAFFIC_TYPE_MAX; index++)\n\t\t\tttp[index] = 0;\n\n\t\tfor (index = 0 ; index < DCBX_MAX_APP_PROTOCOL; index++) {\n\t\t\tstruct dcbx_app_priority_entry *entry =\n\t\t\t\t\t\t\tapp->app_pri_tbl;\n\t\t\tenum traffic_type type = MAX_TRAFFIC_TYPE;\n\n\t\t\tif (GET_FLAGS(entry[index].appBitfield,\n\t\t\t\t      DCBX_APP_SF_DEFAULT) &&\n\t\t\t    GET_FLAGS(entry[index].appBitfield,\n\t\t\t\t      DCBX_APP_SF_ETH_TYPE)) {\n\t\t\t\ttype = LLFC_TRAFFIC_TYPE_NW;\n\t\t\t} else if (GET_FLAGS(entry[index].appBitfield,\n\t\t\t\t\t     DCBX_APP_SF_PORT) &&\n\t\t\t\t   TCP_PORT_ISCSI == entry[index].app_id) {\n\t\t\t\ttype = LLFC_TRAFFIC_TYPE_ISCSI;\n\t\t\t\tiscsi_pri_found = 1;\n\t\t\t} else if (GET_FLAGS(entry[index].appBitfield,\n\t\t\t\t\t     DCBX_APP_SF_ETH_TYPE) &&\n\t\t\t\t   ETH_TYPE_FCOE == entry[index].app_id) {\n\t\t\t\ttype = LLFC_TRAFFIC_TYPE_FCOE;\n\t\t\t\tfcoe_pri_found = 1;\n\t\t\t}\n\n\t\t\tif (type == MAX_TRAFFIC_TYPE)\n\t\t\t\tcontinue;\n\n\t\t\tbnx2x_dcbx_get_ap_priority(bp,\n\t\t\t\t\t\t   entry[index].pri_bitmap,\n\t\t\t\t\t\t   type);\n\t\t}\n\n\t\t \n\t\tif (ttp[LLFC_TRAFFIC_TYPE_NW] != 0) {\n\t\t\tif (!iscsi_pri_found) {\n\t\t\t\tttp[LLFC_TRAFFIC_TYPE_ISCSI] =\n\t\t\t\t\tttp[LLFC_TRAFFIC_TYPE_NW];\n\t\t\t\tDP(BNX2X_MSG_DCB,\n\t\t\t\t   \"ISCSI is using default priority.\\n\");\n\t\t\t}\n\t\t\tif (!fcoe_pri_found) {\n\t\t\t\tttp[LLFC_TRAFFIC_TYPE_FCOE] =\n\t\t\t\t\tttp[LLFC_TRAFFIC_TYPE_NW];\n\t\t\t\tDP(BNX2X_MSG_DCB,\n\t\t\t\t   \"FCoE is using default priority.\\n\");\n\t\t\t}\n\t\t}\n\t} else {\n\t\tDP(BNX2X_MSG_DCB, \"DCBX_LOCAL_APP_DISABLED\\n\");\n\t\tbp->dcbx_port_params.app.enabled = false;\n\t\tfor (index = 0 ; index < LLFC_DRIVER_TRAFFIC_TYPE_MAX; index++)\n\t\t\tttp[index] = INVALID_TRAFFIC_TYPE_PRIORITY;\n\t}\n}\n\nstatic void bnx2x_dcbx_get_ets_feature(struct bnx2x *bp,\n\t\t\t\t       struct dcbx_ets_feature *ets,\n\t\t\t\t       u32 error) {\n\tint i = 0;\n\tu32 pg_pri_orginal_spread[DCBX_MAX_NUM_PG_BW_ENTRIES] = {0};\n\tstruct pg_help_data pg_help_data;\n\tstruct bnx2x_dcbx_cos_params *cos_params =\n\t\t\tbp->dcbx_port_params.ets.cos_params;\n\n\tmemset(&pg_help_data, 0, sizeof(struct pg_help_data));\n\n\tif (GET_FLAGS(error, DCBX_LOCAL_ETS_ERROR))\n\t\tDP(BNX2X_MSG_DCB, \"DCBX_LOCAL_ETS_ERROR\\n\");\n\n\tif (GET_FLAGS(error, DCBX_REMOTE_ETS_TLV_NOT_FOUND))\n\t\tDP(BNX2X_MSG_DCB, \"DCBX_REMOTE_ETS_TLV_NOT_FOUND\\n\");\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(bp->dcbx_port_params.ets.cos_params) ; i++) {\n\t\tcos_params[i].pauseable = false;\n\t\tcos_params[i].strict = BNX2X_DCBX_STRICT_INVALID;\n\t\tcos_params[i].bw_tbl = DCBX_INVALID_COS_BW;\n\t\tcos_params[i].pri_bitmask = 0;\n\t}\n\n\tif (bp->dcbx_port_params.app.enabled && ets->enabled &&\n\t   !GET_FLAGS(error,\n\t\t      DCBX_LOCAL_ETS_ERROR | DCBX_REMOTE_ETS_TLV_NOT_FOUND)) {\n\t\tDP(BNX2X_MSG_DCB, \"DCBX_LOCAL_ETS_ENABLE\\n\");\n\t\tbp->dcbx_port_params.ets.enabled = true;\n\n\t\tbnx2x_dcbx_get_ets_pri_pg_tbl(bp,\n\t\t\t\t\t      pg_pri_orginal_spread,\n\t\t\t\t\t      ets->pri_pg_tbl);\n\n\t\tbnx2x_dcbx_get_num_pg_traf_type(bp,\n\t\t\t\t\t\tpg_pri_orginal_spread,\n\t\t\t\t\t\t&pg_help_data);\n\n\t\tbnx2x_dcbx_fill_cos_params(bp, &pg_help_data,\n\t\t\t\t\t   ets, pg_pri_orginal_spread);\n\n\t} else {\n\t\tDP(BNX2X_MSG_DCB, \"DCBX_LOCAL_ETS_DISABLED\\n\");\n\t\tbp->dcbx_port_params.ets.enabled = false;\n\t\tets->pri_pg_tbl[0] = 0;\n\n\t\tfor (i = 0; i < DCBX_MAX_NUM_PRI_PG_ENTRIES ; i++)\n\t\t\tDCBX_PG_BW_SET(ets->pg_bw_tbl, i, 1);\n\t}\n}\n\nstatic void  bnx2x_dcbx_get_pfc_feature(struct bnx2x *bp,\n\t\t\t\t\tstruct dcbx_pfc_feature *pfc, u32 error)\n{\n\tif (GET_FLAGS(error, DCBX_LOCAL_PFC_ERROR))\n\t\tDP(BNX2X_MSG_DCB, \"DCBX_LOCAL_PFC_ERROR\\n\");\n\n\tif (GET_FLAGS(error, DCBX_REMOTE_PFC_TLV_NOT_FOUND))\n\t\tDP(BNX2X_MSG_DCB, \"DCBX_REMOTE_PFC_TLV_NOT_FOUND\\n\");\n\tif (bp->dcbx_port_params.app.enabled && pfc->enabled &&\n\t   !GET_FLAGS(error, DCBX_LOCAL_PFC_ERROR | DCBX_LOCAL_PFC_MISMATCH |\n\t\t\t     DCBX_REMOTE_PFC_TLV_NOT_FOUND)) {\n\t\tbp->dcbx_port_params.pfc.enabled = true;\n\t\tbp->dcbx_port_params.pfc.priority_non_pauseable_mask =\n\t\t\t~(pfc->pri_en_bitmap);\n\t} else {\n\t\tDP(BNX2X_MSG_DCB, \"DCBX_LOCAL_PFC_DISABLED\\n\");\n\t\tbp->dcbx_port_params.pfc.enabled = false;\n\t\tbp->dcbx_port_params.pfc.priority_non_pauseable_mask = 0;\n\t}\n}\n\n \nstatic void bnx2x_dcbx_map_nw(struct bnx2x *bp)\n{\n\tint i;\n\tu32 unmapped = (1 << MAX_PFC_PRIORITIES) - 1;  \n\tu32 *ttp = bp->dcbx_port_params.app.traffic_type_priority;\n\tu32 nw_prio = 1 << ttp[LLFC_TRAFFIC_TYPE_NW];\n\tstruct bnx2x_dcbx_cos_params *cos_params =\n\t\t\tbp->dcbx_port_params.ets.cos_params;\n\n\t \n\tfor (i = 0; i < LLFC_DRIVER_TRAFFIC_TYPE_MAX; i++)\n\t\tunmapped &= ~(1 << ttp[i]);\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(bp->dcbx_port_params.ets.cos_params); i++) {\n\t\tif (cos_params[i].pri_bitmask & nw_prio) {\n\t\t\t \n\t\t\tDP(BNX2X_MSG_DCB,\n\t\t\t   \"cos %d extended with 0x%08x\\n\", i, unmapped);\n\t\t\tcos_params[i].pri_bitmask |= unmapped;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void bnx2x_get_dcbx_drv_param(struct bnx2x *bp,\n\t\t\t\t     struct dcbx_features *features,\n\t\t\t\t     u32 error)\n{\n\tbnx2x_dcbx_get_ap_feature(bp, &features->app, error);\n\n\tbnx2x_dcbx_get_pfc_feature(bp, &features->pfc, error);\n\n\tbnx2x_dcbx_get_ets_feature(bp, &features->ets, error);\n\n\tbnx2x_dcbx_map_nw(bp);\n}\n\n#define DCBX_LOCAL_MIB_MAX_TRY_READ\t\t(100)\nstatic int bnx2x_dcbx_read_mib(struct bnx2x *bp,\n\t\t\t       u32 *base_mib_addr,\n\t\t\t       u32 offset,\n\t\t\t       int read_mib_type)\n{\n\tint max_try_read = 0;\n\tu32 mib_size, prefix_seq_num, suffix_seq_num;\n\tstruct lldp_remote_mib *remote_mib ;\n\tstruct lldp_local_mib  *local_mib;\n\n\tswitch (read_mib_type) {\n\tcase DCBX_READ_LOCAL_MIB:\n\t\tmib_size = sizeof(struct lldp_local_mib);\n\t\tbreak;\n\tcase DCBX_READ_REMOTE_MIB:\n\t\tmib_size = sizeof(struct lldp_remote_mib);\n\t\tbreak;\n\tdefault:\n\t\treturn 1;  \n\t}\n\n\toffset += BP_PORT(bp) * mib_size;\n\n\tdo {\n\t\tbnx2x_read_data(bp, base_mib_addr, offset, mib_size);\n\n\t\tmax_try_read++;\n\n\t\tswitch (read_mib_type) {\n\t\tcase DCBX_READ_LOCAL_MIB:\n\t\t\tlocal_mib = (struct lldp_local_mib *) base_mib_addr;\n\t\t\tprefix_seq_num = local_mib->prefix_seq_num;\n\t\t\tsuffix_seq_num = local_mib->suffix_seq_num;\n\t\t\tbreak;\n\t\tcase DCBX_READ_REMOTE_MIB:\n\t\t\tremote_mib = (struct lldp_remote_mib *) base_mib_addr;\n\t\t\tprefix_seq_num = remote_mib->prefix_seq_num;\n\t\t\tsuffix_seq_num = remote_mib->suffix_seq_num;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn 1;  \n\t\t}\n\t} while ((prefix_seq_num != suffix_seq_num) &&\n\t       (max_try_read < DCBX_LOCAL_MIB_MAX_TRY_READ));\n\n\tif (max_try_read >= DCBX_LOCAL_MIB_MAX_TRY_READ) {\n\t\tBNX2X_ERR(\"MIB could not be read\\n\");\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic void bnx2x_pfc_set_pfc(struct bnx2x *bp)\n{\n\tint mfw_configured = SHMEM2_HAS(bp, drv_flags) &&\n\t\t\t     GET_FLAGS(SHMEM2_RD(bp, drv_flags),\n\t\t\t\t       1 << DRV_FLAGS_DCB_MFW_CONFIGURED);\n\n\tif (bp->dcbx_port_params.pfc.enabled &&\n\t    (!(bp->dcbx_error & DCBX_REMOTE_MIB_ERROR) || mfw_configured))\n\t\t \n\t\tbnx2x_pfc_set(bp);\n\telse\n\t\tbnx2x_pfc_clear(bp);\n}\n\nint bnx2x_dcbx_stop_hw_tx(struct bnx2x *bp)\n{\n\tstruct bnx2x_func_state_params func_params = {NULL};\n\tint rc;\n\n\tfunc_params.f_obj = &bp->func_obj;\n\tfunc_params.cmd = BNX2X_F_CMD_TX_STOP;\n\n\t__set_bit(RAMROD_COMP_WAIT, &func_params.ramrod_flags);\n\t__set_bit(RAMROD_RETRY, &func_params.ramrod_flags);\n\n\tDP(BNX2X_MSG_DCB, \"STOP TRAFFIC\\n\");\n\n\trc = bnx2x_func_state_change(bp, &func_params);\n\tif (rc) {\n\t\tBNX2X_ERR(\"Unable to hold traffic for HW configuration\\n\");\n\t\tbnx2x_panic();\n\t}\n\n\treturn rc;\n}\n\nint bnx2x_dcbx_resume_hw_tx(struct bnx2x *bp)\n{\n\tstruct bnx2x_func_state_params func_params = {NULL};\n\tstruct bnx2x_func_tx_start_params *tx_params =\n\t\t&func_params.params.tx_start;\n\tint rc;\n\n\tfunc_params.f_obj = &bp->func_obj;\n\tfunc_params.cmd = BNX2X_F_CMD_TX_START;\n\n\t__set_bit(RAMROD_COMP_WAIT, &func_params.ramrod_flags);\n\t__set_bit(RAMROD_RETRY, &func_params.ramrod_flags);\n\n\tbnx2x_dcbx_fw_struct(bp, tx_params);\n\n\tDP(BNX2X_MSG_DCB, \"START TRAFFIC\\n\");\n\n\trc = bnx2x_func_state_change(bp, &func_params);\n\tif (rc) {\n\t\tBNX2X_ERR(\"Unable to resume traffic after HW configuration\\n\");\n\t\tbnx2x_panic();\n\t}\n\n\treturn rc;\n}\n\nstatic void bnx2x_dcbx_2cos_limit_update_ets_config(struct bnx2x *bp)\n{\n\tstruct bnx2x_dcbx_pg_params *ets = &(bp->dcbx_port_params.ets);\n\tint rc = 0;\n\n\tif (ets->num_of_cos == 0 || ets->num_of_cos > DCBX_COS_MAX_NUM_E2) {\n\t\tBNX2X_ERR(\"Illegal number of COSes %d\\n\", ets->num_of_cos);\n\t\treturn;\n\t}\n\n\t \n\tif (ets->num_of_cos == 1)    \n\t\treturn;\n\n\t \n\tif (((BNX2X_DCBX_STRICT_INVALID == ets->cos_params[0].strict) &&\n\t     (DCBX_INVALID_COS_BW == ets->cos_params[0].bw_tbl)) ||\n\t    ((BNX2X_DCBX_STRICT_INVALID == ets->cos_params[1].strict) &&\n\t     (DCBX_INVALID_COS_BW == ets->cos_params[1].bw_tbl))) {\n\t\tBNX2X_ERR(\"all COS should have at least bw_limit or strict\"\n\t\t\t    \"ets->cos_params[0].strict= %x\"\n\t\t\t    \"ets->cos_params[0].bw_tbl= %x\"\n\t\t\t    \"ets->cos_params[1].strict= %x\"\n\t\t\t    \"ets->cos_params[1].bw_tbl= %x\",\n\t\t\t  ets->cos_params[0].strict,\n\t\t\t  ets->cos_params[0].bw_tbl,\n\t\t\t  ets->cos_params[1].strict,\n\t\t\t  ets->cos_params[1].bw_tbl);\n\t\treturn;\n\t}\n\t \n\tif ((DCBX_INVALID_COS_BW != ets->cos_params[0].bw_tbl) &&\n\t    (DCBX_INVALID_COS_BW != ets->cos_params[1].bw_tbl)) {\n\t\tu32 bw_tbl_0 = ets->cos_params[0].bw_tbl;\n\t\tu32 bw_tbl_1 = ets->cos_params[1].bw_tbl;\n\t\t \n\t\tif (bw_tbl_0 == 0) {\n\t\t\tbw_tbl_0 = 1;\n\t\t\tbw_tbl_1 = 99;\n\t\t} else if (bw_tbl_1 == 0) {\n\t\t\tbw_tbl_1 = 1;\n\t\t\tbw_tbl_0 = 99;\n\t\t}\n\n\t\tbnx2x_ets_bw_limit(&bp->link_params, bw_tbl_0, bw_tbl_1);\n\t} else {\n\t\tif (ets->cos_params[0].strict == BNX2X_DCBX_STRICT_COS_HIGHEST)\n\t\t\trc = bnx2x_ets_strict(&bp->link_params, 0);\n\t\telse if (ets->cos_params[1].strict\n\t\t\t\t\t== BNX2X_DCBX_STRICT_COS_HIGHEST)\n\t\t\trc = bnx2x_ets_strict(&bp->link_params, 1);\n\t\tif (rc)\n\t\t\tBNX2X_ERR(\"update_ets_params failed\\n\");\n\t}\n}\n\n \nstatic void bnx2x_dcbx_update_ets_config(struct bnx2x *bp)\n{\n\tstruct bnx2x_dcbx_pg_params *ets = &(bp->dcbx_port_params.ets);\n\tstruct bnx2x_ets_params ets_params = { 0 };\n\tu8 i;\n\n\tets_params.num_of_cos = ets->num_of_cos;\n\n\tfor (i = 0; i < ets->num_of_cos; i++) {\n\t\t \n\t\tif (ets->cos_params[i].strict != BNX2X_DCBX_STRICT_INVALID) {\n\t\t\tif (ets->cos_params[i].bw_tbl != DCBX_INVALID_COS_BW) {\n\t\t\t\tBNX2X_ERR(\"COS can't be not BW and not SP\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tets_params.cos[i].state = bnx2x_cos_state_strict;\n\t\t\tets_params.cos[i].params.sp_params.pri =\n\t\t\t\t\t\tets->cos_params[i].strict;\n\t\t} else {  \n\t\t\tif (ets->cos_params[i].bw_tbl == DCBX_INVALID_COS_BW) {\n\t\t\t\tBNX2X_ERR(\"COS can't be not BW and not SP\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tets_params.cos[i].state = bnx2x_cos_state_bw;\n\t\t\tets_params.cos[i].params.bw_params.bw =\n\t\t\t\t\t\t(u8)ets->cos_params[i].bw_tbl;\n\t\t}\n\t}\n\n\t \n\tif (bnx2x_ets_e3b0_config(&bp->link_params, &bp->link_vars,\n\t\t\t\t  &ets_params)) {\n\t\tBNX2X_ERR(\"bnx2x_ets_e3b0_config failed\\n\");\n\t\tbnx2x_ets_disabled(&bp->link_params, &bp->link_vars);\n\t}\n}\n\nstatic void bnx2x_dcbx_update_ets_params(struct bnx2x *bp)\n{\n\tint mfw_configured = SHMEM2_HAS(bp, drv_flags) &&\n\t\t\t     GET_FLAGS(SHMEM2_RD(bp, drv_flags),\n\t\t\t\t       1 << DRV_FLAGS_DCB_MFW_CONFIGURED);\n\n\tbnx2x_ets_disabled(&bp->link_params, &bp->link_vars);\n\n\tif (!bp->dcbx_port_params.ets.enabled ||\n\t    ((bp->dcbx_error & DCBX_REMOTE_MIB_ERROR) && !mfw_configured))\n\t\treturn;\n\n\tif (CHIP_IS_E3B0(bp))\n\t\tbnx2x_dcbx_update_ets_config(bp);\n\telse\n\t\tbnx2x_dcbx_2cos_limit_update_ets_config(bp);\n}\n\n#ifdef BCM_DCBNL\nstatic int bnx2x_dcbx_read_shmem_remote_mib(struct bnx2x *bp)\n{\n\tstruct lldp_remote_mib remote_mib = {0};\n\tu32 dcbx_remote_mib_offset = SHMEM2_RD(bp, dcbx_remote_mib_offset);\n\tint rc;\n\n\tDP(BNX2X_MSG_DCB, \"dcbx_remote_mib_offset 0x%x\\n\",\n\t   dcbx_remote_mib_offset);\n\n\tif (SHMEM_DCBX_REMOTE_MIB_NONE == dcbx_remote_mib_offset) {\n\t\tBNX2X_ERR(\"FW doesn't support dcbx_remote_mib_offset\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\trc = bnx2x_dcbx_read_mib(bp, (u32 *)&remote_mib, dcbx_remote_mib_offset,\n\t\t\t\t DCBX_READ_REMOTE_MIB);\n\n\tif (rc) {\n\t\tBNX2X_ERR(\"Failed to read remote mib from FW\\n\");\n\t\treturn rc;\n\t}\n\n\t \n\tbp->dcbx_remote_feat = remote_mib.features;\n\tbp->dcbx_remote_flags = remote_mib.flags;\n\treturn 0;\n}\n#endif\n\nstatic int bnx2x_dcbx_read_shmem_neg_results(struct bnx2x *bp)\n{\n\tstruct lldp_local_mib local_mib = {0};\n\tu32 dcbx_neg_res_offset = SHMEM2_RD(bp, dcbx_neg_res_offset);\n\tint rc;\n\n\tDP(BNX2X_MSG_DCB, \"dcbx_neg_res_offset 0x%x\\n\", dcbx_neg_res_offset);\n\n\tif (SHMEM_DCBX_NEG_RES_NONE == dcbx_neg_res_offset) {\n\t\tBNX2X_ERR(\"FW doesn't support dcbx_neg_res_offset\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\trc = bnx2x_dcbx_read_mib(bp, (u32 *)&local_mib, dcbx_neg_res_offset,\n\t\t\t\t DCBX_READ_LOCAL_MIB);\n\n\tif (rc) {\n\t\tBNX2X_ERR(\"Failed to read local mib from FW\\n\");\n\t\treturn rc;\n\t}\n\n\t \n\tbp->dcbx_local_feat = local_mib.features;\n\tbp->dcbx_error = local_mib.error;\n\treturn 0;\n}\n\n#ifdef BCM_DCBNL\nstatic inline\nu8 bnx2x_dcbx_dcbnl_app_up(struct dcbx_app_priority_entry *ent)\n{\n\tu8 pri;\n\n\t \n\tfor (pri = MAX_PFC_PRIORITIES - 1; pri > 0; pri--)\n\t\tif (ent->pri_bitmap & (1 << pri))\n\t\t\tbreak;\n\treturn pri;\n}\n\nstatic inline\nu8 bnx2x_dcbx_dcbnl_app_idtype(struct dcbx_app_priority_entry *ent)\n{\n\treturn ((ent->appBitfield & DCBX_APP_ENTRY_SF_MASK) ==\n\t\tDCBX_APP_SF_PORT) ? DCB_APP_IDTYPE_PORTNUM :\n\t\tDCB_APP_IDTYPE_ETHTYPE;\n}\n\nint bnx2x_dcbnl_update_applist(struct bnx2x *bp, bool delall)\n{\n\tint i, err = 0;\n\n\tfor (i = 0; i < DCBX_MAX_APP_PROTOCOL && err == 0; i++) {\n\t\tstruct dcbx_app_priority_entry *ent =\n\t\t\t&bp->dcbx_local_feat.app.app_pri_tbl[i];\n\n\t\tif (ent->appBitfield & DCBX_APP_ENTRY_VALID) {\n\t\t\tu8 up = bnx2x_dcbx_dcbnl_app_up(ent);\n\n\t\t\t \n\t\t\tif (up) {\n\t\t\t\tstruct dcb_app app;\n\t\t\t\tapp.selector = bnx2x_dcbx_dcbnl_app_idtype(ent);\n\t\t\t\tapp.protocol = ent->app_id;\n\t\t\t\tapp.priority = delall ? 0 : up;\n\t\t\t\terr = dcb_setapp(bp->dev, &app);\n\t\t\t}\n\t\t}\n\t}\n\treturn err;\n}\n#endif\n\nstatic inline void bnx2x_dcbx_update_tc_mapping(struct bnx2x *bp)\n{\n\tu8 prio, cos;\n\tfor (cos = 0; cos < bp->dcbx_port_params.ets.num_of_cos; cos++) {\n\t\tfor (prio = 0; prio < BNX2X_MAX_PRIORITY; prio++) {\n\t\t\tif (bp->dcbx_port_params.ets.cos_params[cos].pri_bitmask\n\t\t\t    & (1 << prio)) {\n\t\t\t\tbp->prio_to_cos[prio] = cos;\n\t\t\t\tDP(BNX2X_MSG_DCB,\n\t\t\t\t   \"tx_mapping %d --> %d\\n\", prio, cos);\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tbnx2x_schedule_sp_rtnl(bp, BNX2X_SP_RTNL_SETUP_TC, 0);\n}\n\nvoid bnx2x_dcbx_set_params(struct bnx2x *bp, u32 state)\n{\n\tswitch (state) {\n\tcase BNX2X_DCBX_STATE_NEG_RECEIVED:\n\t\t{\n\t\t\tDP(BNX2X_MSG_DCB, \"BNX2X_DCBX_STATE_NEG_RECEIVED\\n\");\n#ifdef BCM_DCBNL\n\t\t\t \n\t\t\tbnx2x_dcbnl_update_applist(bp, true);\n\n\t\t\t \n\t\t\tif (bnx2x_dcbx_read_shmem_remote_mib(bp))\n\t\t\t\treturn;\n#endif\n\t\t\t \n\t\t\tif (bnx2x_dcbx_read_shmem_neg_results(bp))\n\t\t\t\treturn;\n\n\t\t\tbnx2x_dump_dcbx_drv_param(bp, &bp->dcbx_local_feat,\n\t\t\t\t\t\t  bp->dcbx_error);\n\n\t\t\tbnx2x_get_dcbx_drv_param(bp, &bp->dcbx_local_feat,\n\t\t\t\t\t\t bp->dcbx_error);\n\n\t\t\t \n\t\t\tbnx2x_update_drv_flags(bp,\n\t\t\t\t\t       1 << DRV_FLAGS_DCB_CONFIGURED,\n\t\t\t\t\t       1);\n#ifdef BCM_DCBNL\n\t\t\t \n\t\t\tbnx2x_dcbnl_update_applist(bp, false);\n#endif\n\t\t\t \n\t\t\tbnx2x_dcbx_update_tc_mapping(bp);\n\n\t\t\t \n\t\t\tif (IS_MF(bp))\n\t\t\t\tbnx2x_link_sync_notify(bp);\n\n\t\t\tbnx2x_schedule_sp_rtnl(bp, BNX2X_SP_RTNL_TX_STOP, 0);\n\t\t\treturn;\n\t\t}\n\tcase BNX2X_DCBX_STATE_TX_PAUSED:\n\t\tDP(BNX2X_MSG_DCB, \"BNX2X_DCBX_STATE_TX_PAUSED\\n\");\n\t\tbnx2x_pfc_set_pfc(bp);\n\n\t\tbnx2x_dcbx_update_ets_params(bp);\n\n\t\t \n\t\tbnx2x_set_local_cmng(bp);\n\t\treturn;\n\tcase BNX2X_DCBX_STATE_TX_RELEASED:\n\t\tDP(BNX2X_MSG_DCB, \"BNX2X_DCBX_STATE_TX_RELEASED\\n\");\n\t\tbnx2x_fw_command(bp, DRV_MSG_CODE_DCBX_PMF_DRV_OK, 0);\n#ifdef BCM_DCBNL\n\t\t \n\t\tdcbnl_cee_notify(bp->dev, RTM_GETDCB, DCB_CMD_CEE_GET, 0, 0);\n#endif\n\t\treturn;\n\tdefault:\n\t\tBNX2X_ERR(\"Unknown DCBX_STATE\\n\");\n\t}\n}\n\n#define LLDP_ADMIN_MIB_OFFSET(bp)\t(PORT_MAX*sizeof(struct lldp_params) + \\\n\t\t\t\t      BP_PORT(bp)*sizeof(struct lldp_admin_mib))\n\nstatic void bnx2x_dcbx_admin_mib_updated_params(struct bnx2x *bp,\n\t\t\t\tu32 dcbx_lldp_params_offset)\n{\n\tstruct lldp_admin_mib admin_mib;\n\tu32 i, other_traf_type = PREDEFINED_APP_IDX_MAX, traf_type = 0;\n\tu32 offset = dcbx_lldp_params_offset + LLDP_ADMIN_MIB_OFFSET(bp);\n\n\t \n\tstruct dcbx_features *af = &admin_mib.features;\n\tstruct bnx2x_config_dcbx_params *dp = &bp->dcbx_config_params;\n\n\tmemset(&admin_mib, 0, sizeof(struct lldp_admin_mib));\n\n\t \n\tbnx2x_read_data(bp, (u32 *)&admin_mib, offset,\n\t\t\tsizeof(struct lldp_admin_mib));\n\n\tif (bp->dcbx_enabled == BNX2X_DCBX_ENABLED_ON_NEG_ON)\n\t\tSET_FLAGS(admin_mib.ver_cfg_flags, DCBX_DCBX_ENABLED);\n\telse\n\t\tRESET_FLAGS(admin_mib.ver_cfg_flags, DCBX_DCBX_ENABLED);\n\n\tif (dp->overwrite_settings == BNX2X_DCBX_OVERWRITE_SETTINGS_ENABLE) {\n\n\t\tRESET_FLAGS(admin_mib.ver_cfg_flags, DCBX_CEE_VERSION_MASK);\n\t\tadmin_mib.ver_cfg_flags |=\n\t\t\t(dp->admin_dcbx_version << DCBX_CEE_VERSION_SHIFT) &\n\t\t\t DCBX_CEE_VERSION_MASK;\n\n\t\taf->ets.enabled = (u8)dp->admin_ets_enable;\n\n\t\taf->pfc.enabled = (u8)dp->admin_pfc_enable;\n\n\t\t \n\t\tif (dp->admin_ets_configuration_tx_enable)\n\t\t\tSET_FLAGS(admin_mib.ver_cfg_flags,\n\t\t\t\t  DCBX_ETS_CONFIG_TX_ENABLED);\n\t\telse\n\t\t\tRESET_FLAGS(admin_mib.ver_cfg_flags,\n\t\t\t\t    DCBX_ETS_CONFIG_TX_ENABLED);\n\t\t \n\t\tif (dp->admin_pfc_tx_enable)\n\t\t\tSET_FLAGS(admin_mib.ver_cfg_flags,\n\t\t\t\t  DCBX_PFC_CONFIG_TX_ENABLED);\n\t\telse\n\t\t\tRESET_FLAGS(admin_mib.ver_cfg_flags,\n\t\t\t\t  DCBX_PFC_CONFIG_TX_ENABLED);\n\n\t\tif (dp->admin_application_priority_tx_enable)\n\t\t\tSET_FLAGS(admin_mib.ver_cfg_flags,\n\t\t\t\t  DCBX_APP_CONFIG_TX_ENABLED);\n\t\telse\n\t\t\tRESET_FLAGS(admin_mib.ver_cfg_flags,\n\t\t\t\t  DCBX_APP_CONFIG_TX_ENABLED);\n\n\t\tif (dp->admin_ets_willing)\n\t\t\tSET_FLAGS(admin_mib.ver_cfg_flags, DCBX_ETS_WILLING);\n\t\telse\n\t\t\tRESET_FLAGS(admin_mib.ver_cfg_flags, DCBX_ETS_WILLING);\n\t\t \n\t\tif (dp->admin_pfc_willing)\n\t\t\tSET_FLAGS(admin_mib.ver_cfg_flags, DCBX_PFC_WILLING);\n\t\telse\n\t\t\tRESET_FLAGS(admin_mib.ver_cfg_flags, DCBX_PFC_WILLING);\n\n\t\tif (dp->admin_app_priority_willing)\n\t\t\tSET_FLAGS(admin_mib.ver_cfg_flags, DCBX_APP_WILLING);\n\t\telse\n\t\t\tRESET_FLAGS(admin_mib.ver_cfg_flags, DCBX_APP_WILLING);\n\n\t\tfor (i = 0 ; i < DCBX_MAX_NUM_PG_BW_ENTRIES; i++) {\n\t\t\tDCBX_PG_BW_SET(af->ets.pg_bw_tbl, i,\n\t\t\t\t(u8)dp->admin_configuration_bw_precentage[i]);\n\n\t\t\tDP(BNX2X_MSG_DCB, \"pg_bw_tbl[%d] = %02x\\n\",\n\t\t\t   i, DCBX_PG_BW_GET(af->ets.pg_bw_tbl, i));\n\t\t}\n\n\t\tfor (i = 0; i < DCBX_MAX_NUM_PRI_PG_ENTRIES; i++) {\n\t\t\tDCBX_PRI_PG_SET(af->ets.pri_pg_tbl, i,\n\t\t\t\t\t(u8)dp->admin_configuration_ets_pg[i]);\n\n\t\t\tDP(BNX2X_MSG_DCB, \"pri_pg_tbl[%d] = %02x\\n\",\n\t\t\t   i, DCBX_PRI_PG_GET(af->ets.pri_pg_tbl, i));\n\t\t}\n\n\t\t \n\t\taf->pfc.pri_en_bitmap = (u8)dp->admin_pfc_bitmap;\n\t\tfor (i = 0; i < DCBX_CONFIG_MAX_APP_PROTOCOL; i++) {\n\t\t\tif (dp->admin_priority_app_table[i].valid) {\n\t\t\t\tstruct bnx2x_admin_priority_app_table *table =\n\t\t\t\t\tdp->admin_priority_app_table;\n\t\t\t\tif ((ETH_TYPE_FCOE == table[i].app_id) &&\n\t\t\t\t   (TRAFFIC_TYPE_ETH == table[i].traffic_type))\n\t\t\t\t\ttraf_type = FCOE_APP_IDX;\n\t\t\t\telse if ((TCP_PORT_ISCSI == table[i].app_id) &&\n\t\t\t\t   (TRAFFIC_TYPE_PORT == table[i].traffic_type))\n\t\t\t\t\ttraf_type = ISCSI_APP_IDX;\n\t\t\t\telse\n\t\t\t\t\ttraf_type = other_traf_type++;\n\n\t\t\t\taf->app.app_pri_tbl[traf_type].app_id =\n\t\t\t\t\ttable[i].app_id;\n\n\t\t\t\taf->app.app_pri_tbl[traf_type].pri_bitmap =\n\t\t\t\t\t(u8)(1 << table[i].priority);\n\n\t\t\t\taf->app.app_pri_tbl[traf_type].appBitfield =\n\t\t\t\t    (DCBX_APP_ENTRY_VALID);\n\n\t\t\t\taf->app.app_pri_tbl[traf_type].appBitfield |=\n\t\t\t\t   (TRAFFIC_TYPE_ETH == table[i].traffic_type) ?\n\t\t\t\t\tDCBX_APP_SF_ETH_TYPE : DCBX_APP_SF_PORT;\n\t\t\t}\n\t\t}\n\n\t\taf->app.default_pri = (u8)dp->admin_default_priority;\n\t}\n\n\t \n\tbnx2x_write_data(bp, (u32 *)&admin_mib, offset,\n\t\t\t sizeof(struct lldp_admin_mib));\n}\n\nvoid bnx2x_dcbx_set_state(struct bnx2x *bp, bool dcb_on, u32 dcbx_enabled)\n{\n\tif (!CHIP_IS_E1x(bp)) {\n\t\tbp->dcb_state = dcb_on;\n\t\tbp->dcbx_enabled = dcbx_enabled;\n\t} else {\n\t\tbp->dcb_state = false;\n\t\tbp->dcbx_enabled = BNX2X_DCBX_ENABLED_INVALID;\n\t}\n\tDP(BNX2X_MSG_DCB, \"DCB state [%s:%s]\\n\",\n\t   dcb_on ? \"ON\" : \"OFF\",\n\t   dcbx_enabled == BNX2X_DCBX_ENABLED_OFF ? \"user-mode\" :\n\t   dcbx_enabled == BNX2X_DCBX_ENABLED_ON_NEG_OFF ? \"on-chip static\" :\n\t   dcbx_enabled == BNX2X_DCBX_ENABLED_ON_NEG_ON ?\n\t   \"on-chip with negotiation\" : \"invalid\");\n}\n\nvoid bnx2x_dcbx_init_params(struct bnx2x *bp)\n{\n\tbp->dcbx_config_params.admin_dcbx_version = 0x0;  \n\tbp->dcbx_config_params.admin_ets_willing = 1;\n\tbp->dcbx_config_params.admin_pfc_willing = 1;\n\tbp->dcbx_config_params.overwrite_settings = 1;\n\tbp->dcbx_config_params.admin_ets_enable = 1;\n\tbp->dcbx_config_params.admin_pfc_enable = 1;\n\tbp->dcbx_config_params.admin_tc_supported_tx_enable = 1;\n\tbp->dcbx_config_params.admin_ets_configuration_tx_enable = 1;\n\tbp->dcbx_config_params.admin_pfc_tx_enable = 1;\n\tbp->dcbx_config_params.admin_application_priority_tx_enable = 1;\n\tbp->dcbx_config_params.admin_ets_reco_valid = 1;\n\tbp->dcbx_config_params.admin_app_priority_willing = 1;\n\tbp->dcbx_config_params.admin_configuration_bw_precentage[0] = 100;\n\tbp->dcbx_config_params.admin_configuration_bw_precentage[1] = 0;\n\tbp->dcbx_config_params.admin_configuration_bw_precentage[2] = 0;\n\tbp->dcbx_config_params.admin_configuration_bw_precentage[3] = 0;\n\tbp->dcbx_config_params.admin_configuration_bw_precentage[4] = 0;\n\tbp->dcbx_config_params.admin_configuration_bw_precentage[5] = 0;\n\tbp->dcbx_config_params.admin_configuration_bw_precentage[6] = 0;\n\tbp->dcbx_config_params.admin_configuration_bw_precentage[7] = 0;\n\tbp->dcbx_config_params.admin_configuration_ets_pg[0] = 0;\n\tbp->dcbx_config_params.admin_configuration_ets_pg[1] = 0;\n\tbp->dcbx_config_params.admin_configuration_ets_pg[2] = 0;\n\tbp->dcbx_config_params.admin_configuration_ets_pg[3] = 0;\n\tbp->dcbx_config_params.admin_configuration_ets_pg[4] = 0;\n\tbp->dcbx_config_params.admin_configuration_ets_pg[5] = 0;\n\tbp->dcbx_config_params.admin_configuration_ets_pg[6] = 0;\n\tbp->dcbx_config_params.admin_configuration_ets_pg[7] = 0;\n\tbp->dcbx_config_params.admin_recommendation_bw_precentage[0] = 100;\n\tbp->dcbx_config_params.admin_recommendation_bw_precentage[1] = 0;\n\tbp->dcbx_config_params.admin_recommendation_bw_precentage[2] = 0;\n\tbp->dcbx_config_params.admin_recommendation_bw_precentage[3] = 0;\n\tbp->dcbx_config_params.admin_recommendation_bw_precentage[4] = 0;\n\tbp->dcbx_config_params.admin_recommendation_bw_precentage[5] = 0;\n\tbp->dcbx_config_params.admin_recommendation_bw_precentage[6] = 0;\n\tbp->dcbx_config_params.admin_recommendation_bw_precentage[7] = 0;\n\tbp->dcbx_config_params.admin_recommendation_ets_pg[0] = 0;\n\tbp->dcbx_config_params.admin_recommendation_ets_pg[1] = 1;\n\tbp->dcbx_config_params.admin_recommendation_ets_pg[2] = 2;\n\tbp->dcbx_config_params.admin_recommendation_ets_pg[3] = 3;\n\tbp->dcbx_config_params.admin_recommendation_ets_pg[4] = 4;\n\tbp->dcbx_config_params.admin_recommendation_ets_pg[5] = 5;\n\tbp->dcbx_config_params.admin_recommendation_ets_pg[6] = 6;\n\tbp->dcbx_config_params.admin_recommendation_ets_pg[7] = 7;\n\tbp->dcbx_config_params.admin_pfc_bitmap = 0x0;\n\tbp->dcbx_config_params.admin_priority_app_table[0].valid = 0;\n\tbp->dcbx_config_params.admin_priority_app_table[1].valid = 0;\n\tbp->dcbx_config_params.admin_priority_app_table[2].valid = 0;\n\tbp->dcbx_config_params.admin_priority_app_table[3].valid = 0;\n\tbp->dcbx_config_params.admin_default_priority = 0;\n}\n\nvoid bnx2x_dcbx_init(struct bnx2x *bp, bool update_shmem)\n{\n\tu32 dcbx_lldp_params_offset = SHMEM_LLDP_DCBX_PARAMS_NONE;\n\n\t \n\tif ((!bp->port.pmf) && (!(bp->flags & BC_SUPPORTS_DCBX_MSG_NON_PMF)))\n\t\treturn;\n\n\tif (bp->dcbx_enabled <= 0)\n\t\treturn;\n\n\t \n\tDP(BNX2X_MSG_DCB, \"dcb_state %d bp->port.pmf %d\\n\",\n\t   bp->dcb_state, bp->port.pmf);\n\n\tif (bp->dcb_state == BNX2X_DCB_STATE_ON &&\n\t    SHMEM2_HAS(bp, dcbx_lldp_params_offset)) {\n\t\tdcbx_lldp_params_offset =\n\t\t\tSHMEM2_RD(bp, dcbx_lldp_params_offset);\n\n\t\tDP(BNX2X_MSG_DCB, \"dcbx_lldp_params_offset 0x%x\\n\",\n\t\t   dcbx_lldp_params_offset);\n\n\t\tbnx2x_update_drv_flags(bp, 1 << DRV_FLAGS_DCB_CONFIGURED, 0);\n\n\t\tif (SHMEM_LLDP_DCBX_PARAMS_NONE != dcbx_lldp_params_offset) {\n\t\t\t \n\t\t\tbnx2x_acquire_hw_lock(bp,\n\t\t\t\t\t      HW_LOCK_RESOURCE_DCBX_ADMIN_MIB);\n\t\t\tif (update_shmem)\n\t\t\t\tbnx2x_dcbx_admin_mib_updated_params(bp,\n\t\t\t\t\tdcbx_lldp_params_offset);\n\n\t\t\t \n\t\t\tbnx2x_fw_command(bp,\n\t\t\t\t\t DRV_MSG_CODE_DCBX_ADMIN_PMF_MSG, 0);\n\t\t\t \n\t\t\tbnx2x_release_hw_lock(bp,\n\t\t\t\t\t      HW_LOCK_RESOURCE_DCBX_ADMIN_MIB);\n\t\t}\n\t}\n}\nstatic void\nbnx2x_dcbx_print_cos_params(struct bnx2x *bp,\n\t\t\t    struct bnx2x_func_tx_start_params *pfc_fw_cfg)\n{\n\tu8 pri = 0;\n\tu8 cos = 0;\n\n\tDP(BNX2X_MSG_DCB,\n\t   \"pfc_fw_cfg->dcb_version %x\\n\", pfc_fw_cfg->dcb_version);\n\tDP(BNX2X_MSG_DCB,\n\t   \"pdev->params.dcbx_port_params.pfc.priority_non_pauseable_mask %x\\n\",\n\t   bp->dcbx_port_params.pfc.priority_non_pauseable_mask);\n\n\tfor (cos = 0 ; cos < bp->dcbx_port_params.ets.num_of_cos ; cos++) {\n\t\tDP(BNX2X_MSG_DCB,\n\t\t   \"pdev->params.dcbx_port_params.ets.cos_params[%d].pri_bitmask %x\\n\",\n\t\t   cos, bp->dcbx_port_params.ets.cos_params[cos].pri_bitmask);\n\n\t\tDP(BNX2X_MSG_DCB,\n\t\t   \"pdev->params.dcbx_port_params.ets.cos_params[%d].bw_tbl %x\\n\",\n\t\t   cos, bp->dcbx_port_params.ets.cos_params[cos].bw_tbl);\n\n\t\tDP(BNX2X_MSG_DCB,\n\t\t   \"pdev->params.dcbx_port_params.ets.cos_params[%d].strict %x\\n\",\n\t\t   cos, bp->dcbx_port_params.ets.cos_params[cos].strict);\n\n\t\tDP(BNX2X_MSG_DCB,\n\t\t   \"pdev->params.dcbx_port_params.ets.cos_params[%d].pauseable %x\\n\",\n\t\t   cos, bp->dcbx_port_params.ets.cos_params[cos].pauseable);\n\t}\n\n\tfor (pri = 0; pri < LLFC_DRIVER_TRAFFIC_TYPE_MAX; pri++) {\n\t\tDP(BNX2X_MSG_DCB,\n\t\t   \"pfc_fw_cfg->traffic_type_to_priority_cos[%d].priority %x\\n\",\n\t\t   pri, pfc_fw_cfg->traffic_type_to_priority_cos[pri].priority);\n\n\t\tDP(BNX2X_MSG_DCB,\n\t\t   \"pfc_fw_cfg->traffic_type_to_priority_cos[%d].cos %x\\n\",\n\t\t   pri, pfc_fw_cfg->traffic_type_to_priority_cos[pri].cos);\n\t}\n}\n\n \nstatic void bnx2x_dcbx_get_num_pg_traf_type(struct bnx2x *bp,\n\t\t\t\t\t    u32 *pg_pri_orginal_spread,\n\t\t\t\t\t    struct pg_help_data *help_data)\n{\n\tbool pg_found  = false;\n\tu32 i, traf_type, add_traf_type, add_pg;\n\tu32 *ttp = bp->dcbx_port_params.app.traffic_type_priority;\n\tstruct pg_entry_help_data *data = help_data->data;  \n\n\t \n\tfor (i = 0; i < LLFC_DRIVER_TRAFFIC_TYPE_MAX; i++)\n\t\tdata[i].pg = DCBX_ILLEGAL_PG;\n\n\tfor (add_traf_type = 0;\n\t     add_traf_type < LLFC_DRIVER_TRAFFIC_TYPE_MAX; add_traf_type++) {\n\t\tpg_found = false;\n\t\tif (ttp[add_traf_type] < MAX_PFC_PRIORITIES) {\n\t\t\tadd_pg = (u8)pg_pri_orginal_spread[ttp[add_traf_type]];\n\t\t\tfor (traf_type = 0;\n\t\t\t     traf_type < LLFC_DRIVER_TRAFFIC_TYPE_MAX;\n\t\t\t     traf_type++) {\n\t\t\t\tif (data[traf_type].pg == add_pg) {\n\t\t\t\t\tif (!(data[traf_type].pg_priority &\n\t\t\t\t\t     (1 << ttp[add_traf_type])))\n\t\t\t\t\t\tdata[traf_type].\n\t\t\t\t\t\t\tnum_of_dif_pri++;\n\t\t\t\t\tdata[traf_type].pg_priority |=\n\t\t\t\t\t\t(1 << ttp[add_traf_type]);\n\t\t\t\t\tpg_found = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!pg_found) {\n\t\t\t\tdata[help_data->num_of_pg].pg = add_pg;\n\t\t\t\tdata[help_data->num_of_pg].pg_priority =\n\t\t\t\t\t\t(1 << ttp[add_traf_type]);\n\t\t\t\tdata[help_data->num_of_pg].num_of_dif_pri = 1;\n\t\t\t\thelp_data->num_of_pg++;\n\t\t\t}\n\t\t}\n\t\tDP(BNX2X_MSG_DCB,\n\t\t   \"add_traf_type %d pg_found %s num_of_pg %d\\n\",\n\t\t   add_traf_type, !pg_found ? \"NO\" : \"YES\",\n\t\t   help_data->num_of_pg);\n\t}\n}\n\nstatic void bnx2x_dcbx_ets_disabled_entry_data(struct bnx2x *bp,\n\t\t\t\t\t       struct cos_help_data *cos_data,\n\t\t\t\t\t       u32 pri_join_mask)\n{\n\t \n\tcos_data->data[0].pausable =\n\t\tIS_DCBX_PFC_PRI_ONLY_PAUSE(bp, pri_join_mask);\n\tcos_data->data[0].pri_join_mask = pri_join_mask;\n\tcos_data->data[0].cos_bw = 100;\n\tcos_data->num_of_cos = 1;\n}\n\nstatic inline void bnx2x_dcbx_add_to_cos_bw(struct bnx2x *bp,\n\t\t\t\t\t    struct cos_entry_help_data *data,\n\t\t\t\t\t    u8 pg_bw)\n{\n\tif (data->cos_bw == DCBX_INVALID_COS_BW)\n\t\tdata->cos_bw = pg_bw;\n\telse\n\t\tdata->cos_bw += pg_bw;\n}\n\nstatic void bnx2x_dcbx_separate_pauseable_from_non(struct bnx2x *bp,\n\t\t\tstruct cos_help_data *cos_data,\n\t\t\tu32 *pg_pri_orginal_spread,\n\t\t\tstruct dcbx_ets_feature *ets)\n{\n\tu32\tpri_tested\t= 0;\n\tu8\ti\t\t= 0;\n\tu8\tentry\t\t= 0;\n\tu8\tpg_entry\t= 0;\n\tu8\tnum_of_pri\t= LLFC_DRIVER_TRAFFIC_TYPE_MAX;\n\n\tcos_data->data[0].pausable = true;\n\tcos_data->data[1].pausable = false;\n\tcos_data->data[0].pri_join_mask = cos_data->data[1].pri_join_mask = 0;\n\n\tfor (i = 0 ; i < num_of_pri ; i++) {\n\t\tpri_tested = 1 << bp->dcbx_port_params.\n\t\t\t\t\tapp.traffic_type_priority[i];\n\n\t\tif (pri_tested & DCBX_PFC_PRI_NON_PAUSE_MASK(bp)) {\n\t\t\tcos_data->data[1].pri_join_mask |= pri_tested;\n\t\t\tentry = 1;\n\t\t} else {\n\t\t\tcos_data->data[0].pri_join_mask |= pri_tested;\n\t\t\tentry = 0;\n\t\t}\n\t\tpg_entry = (u8)pg_pri_orginal_spread[bp->dcbx_port_params.\n\t\t\t\t\t\tapp.traffic_type_priority[i]];\n\t\t \n\t\tif (pg_entry < DCBX_MAX_NUM_PG_BW_ENTRIES)\n\t\t\tbnx2x_dcbx_add_to_cos_bw(bp, &cos_data->data[entry],\n\t\t\t\tDCBX_PG_BW_GET(ets->pg_bw_tbl, pg_entry));\n\t\telse\n\t\t\t \n\t\t\tcos_data->data[entry].strict =\n\t\t\t\t\t\tBNX2X_DCBX_STRICT_COS_HIGHEST;\n\t}\n\tif ((0 == cos_data->data[0].pri_join_mask) &&\n\t    (0 == cos_data->data[1].pri_join_mask))\n\t\tBNX2X_ERR(\"dcbx error: Both groups must have priorities\\n\");\n}\n\n#ifndef POWER_OF_2\n#define POWER_OF_2(x)\t((0 != x) && (0 == (x & (x-1))))\n#endif\n\nstatic void bnx2x_dcbx_2cos_limit_cee_single_pg_to_cos_params(struct bnx2x *bp,\n\t\t\t\t\t      struct pg_help_data *pg_help_data,\n\t\t\t\t\t      struct cos_help_data *cos_data,\n\t\t\t\t\t      u32 pri_join_mask,\n\t\t\t\t\t      u8 num_of_dif_pri)\n{\n\tu8 i = 0;\n\tu32 pri_tested = 0;\n\tu32 pri_mask_without_pri = 0;\n\tu32 *ttp = bp->dcbx_port_params.app.traffic_type_priority;\n\t \n\tif (num_of_dif_pri == 1) {\n\t\tbnx2x_dcbx_ets_disabled_entry_data(bp, cos_data, pri_join_mask);\n\t\treturn;\n\t}\n\t \n\tif (pg_help_data->data[0].pg < DCBX_MAX_NUM_PG_BW_ENTRIES) {\n\t\t \n\t\tif (IS_DCBX_PFC_PRI_MIX_PAUSE(bp, pri_join_mask)) {\n\t\t\t \n\t\t\tcos_data->data[0].pausable = true;\n\t\t\t \n\t\t\tcos_data->data[1].pausable = false;\n\n\t\t\tif (2 == num_of_dif_pri) {\n\t\t\t\tcos_data->data[0].cos_bw = 50;\n\t\t\t\tcos_data->data[1].cos_bw = 50;\n\t\t\t}\n\n\t\t\tif (3 == num_of_dif_pri) {\n\t\t\t\tif (POWER_OF_2(DCBX_PFC_PRI_GET_PAUSE(bp,\n\t\t\t\t\t\t\tpri_join_mask))) {\n\t\t\t\t\tcos_data->data[0].cos_bw = 33;\n\t\t\t\t\tcos_data->data[1].cos_bw = 67;\n\t\t\t\t} else {\n\t\t\t\t\tcos_data->data[0].cos_bw = 67;\n\t\t\t\t\tcos_data->data[1].cos_bw = 33;\n\t\t\t\t}\n\t\t\t}\n\n\t\t} else if (IS_DCBX_PFC_PRI_ONLY_PAUSE(bp, pri_join_mask)) {\n\t\t\t \n\t\t\tif (2 == num_of_dif_pri) {\n\t\t\t\tcos_data->data[0].cos_bw = 50;\n\t\t\t\tcos_data->data[1].cos_bw = 50;\n\t\t\t} else {\n\t\t\t\tcos_data->data[0].cos_bw = 67;\n\t\t\t\tcos_data->data[1].cos_bw = 33;\n\t\t\t}\n\t\t\tcos_data->data[1].pausable = true;\n\t\t\tcos_data->data[0].pausable = true;\n\t\t\t \n\t\t\tcos_data->data[0].pri_join_mask = (pri_join_mask &\n\t\t\t\t((u8)~(1 << ttp[LLFC_TRAFFIC_TYPE_FCOE])));\n\t\t\t \n\t\t\tcos_data->data[1].pri_join_mask =\n\t\t\t\t(1 << ttp[LLFC_TRAFFIC_TYPE_FCOE]);\n\t\t} else\n\t\t\t \n\t\t\tbnx2x_dcbx_ets_disabled_entry_data(bp,\n\t\t\t\t\t\tcos_data, pri_join_mask);\n\t} else {\n\t\t \n\t\tif (IS_DCBX_PFC_PRI_MIX_PAUSE(bp, pri_join_mask)) {\n\t\t\t \n\t\t\tif (DCBX_PFC_PRI_GET_PAUSE(bp, pri_join_mask) >\n\t\t\t    DCBX_PFC_PRI_GET_NON_PAUSE(bp, pri_join_mask)) {\n\t\t\t\tcos_data->data[0].strict =\n\t\t\t\t\tBNX2X_DCBX_STRICT_COS_HIGHEST;\n\t\t\t\tcos_data->data[1].strict =\n\t\t\t\t\tBNX2X_DCBX_STRICT_COS_NEXT_LOWER_PRI(\n\t\t\t\t\t\tBNX2X_DCBX_STRICT_COS_HIGHEST);\n\t\t\t} else {\n\t\t\t\tcos_data->data[0].strict =\n\t\t\t\t\tBNX2X_DCBX_STRICT_COS_NEXT_LOWER_PRI(\n\t\t\t\t\t\tBNX2X_DCBX_STRICT_COS_HIGHEST);\n\t\t\t\tcos_data->data[1].strict =\n\t\t\t\t\tBNX2X_DCBX_STRICT_COS_HIGHEST;\n\t\t\t}\n\t\t\t \n\t\t\tcos_data->data[0].pausable = true;\n\t\t\t \n\t\t\tcos_data->data[1].pausable = false;\n\t\t} else {\n\t\t\t \n\t\t\tcos_data->data[0].pausable =\n\t\t\t\tcos_data->data[1].pausable =\n\t\t\t\tIS_DCBX_PFC_PRI_ONLY_PAUSE(bp, pri_join_mask);\n\n\t\t\tfor (i = 0 ; i < LLFC_DRIVER_TRAFFIC_TYPE_MAX; i++) {\n\t\t\t\tpri_tested = 1 << bp->dcbx_port_params.\n\t\t\t\t\tapp.traffic_type_priority[i];\n\t\t\t\t \n\t\t\t\tpri_mask_without_pri =\n\t\t\t\t\t(pri_join_mask & ((u8)(~pri_tested)));\n\t\t\t\tif (pri_mask_without_pri < pri_tested)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (i == LLFC_DRIVER_TRAFFIC_TYPE_MAX)\n\t\t\t\tBNX2X_ERR(\"Invalid value for pri_join_mask - could not find a priority\\n\");\n\n\t\t\tcos_data->data[0].pri_join_mask = pri_mask_without_pri;\n\t\t\tcos_data->data[1].pri_join_mask = pri_tested;\n\t\t\t \n\t\t\tcos_data->data[0].strict =\n\t\t\t\t\tBNX2X_DCBX_STRICT_COS_NEXT_LOWER_PRI(\n\t\t\t\t\t\tBNX2X_DCBX_STRICT_COS_HIGHEST);\n\t\t\tcos_data->data[1].strict =\n\t\t\t\t\tBNX2X_DCBX_STRICT_COS_HIGHEST;\n\t\t}\n\t}\n}\n\nstatic void bnx2x_dcbx_2cos_limit_cee_two_pg_to_cos_params(\n\t\t\t    struct bnx2x\t\t*bp,\n\t\t\t    struct  pg_help_data\t*pg_help_data,\n\t\t\t    struct dcbx_ets_feature\t*ets,\n\t\t\t    struct cos_help_data\t*cos_data,\n\t\t\t    u32\t\t\t*pg_pri_orginal_spread,\n\t\t\t    u32\t\t\t\tpri_join_mask,\n\t\t\t    u8\t\t\t\tnum_of_dif_pri)\n{\n\tu8 i = 0;\n\tu8 pg[DCBX_COS_MAX_NUM_E2] = { 0 };\n\n\t \n\tif (IS_DCBX_PFC_PRI_MIX_PAUSE(bp, pri_join_mask)) {\n\t\tif (IS_DCBX_PFC_PRI_MIX_PAUSE(bp,\n\t\t\t\t\t pg_help_data->data[0].pg_priority) ||\n\t\t    IS_DCBX_PFC_PRI_MIX_PAUSE(bp,\n\t\t\t\t\t pg_help_data->data[1].pg_priority)) {\n\t\t\t \n\t\t\tbnx2x_dcbx_separate_pauseable_from_non(bp, cos_data,\n\t\t\t\t\tpg_pri_orginal_spread, ets);\n\t\t\tbp->dcbx_port_params.ets.enabled = false;\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tcos_data->data[0].pausable = true;\n\t\t \n\t\tcos_data->data[1].pausable = false;\n\t\tif (IS_DCBX_PFC_PRI_ONLY_PAUSE(bp,\n\t\t\t\tpg_help_data->data[0].pg_priority)) {\n\t\t\t \n\t\t\tcos_data->data[0].pri_join_mask =\n\t\t\t\tpg_help_data->data[0].pg_priority;\n\t\t\tpg[0] = pg_help_data->data[0].pg;\n\t\t\tcos_data->data[1].pri_join_mask =\n\t\t\t\tpg_help_data->data[1].pg_priority;\n\t\t\tpg[1] = pg_help_data->data[1].pg;\n\t\t} else { \n\t\t\tcos_data->data[0].pri_join_mask =\n\t\t\t\tpg_help_data->data[1].pg_priority;\n\t\t\tpg[0] = pg_help_data->data[1].pg;\n\t\t\tcos_data->data[1].pri_join_mask =\n\t\t\t\tpg_help_data->data[0].pg_priority;\n\t\t\tpg[1] = pg_help_data->data[0].pg;\n\t\t}\n\t} else {\n\t\t \n\t\tcos_data->data[0].pausable = cos_data->data[1].pausable =\n\t\t\tIS_DCBX_PFC_PRI_ONLY_PAUSE(bp, pri_join_mask);\n\t\tcos_data->data[0].pri_join_mask =\n\t\t\tpg_help_data->data[0].pg_priority;\n\t\tpg[0] = pg_help_data->data[0].pg;\n\t\tcos_data->data[1].pri_join_mask =\n\t\t\tpg_help_data->data[1].pg_priority;\n\t\tpg[1] = pg_help_data->data[1].pg;\n\t}\n\n\t \n\tfor (i = 0 ; i < ARRAY_SIZE(pg); i++) {\n\t\tif (pg[i] < DCBX_MAX_NUM_PG_BW_ENTRIES)\n\t\t\tcos_data->data[i].cos_bw =\n\t\t\t\tDCBX_PG_BW_GET(ets->pg_bw_tbl, pg[i]);\n\t\telse\n\t\t\tcos_data->data[i].strict =\n\t\t\t\t\t\tBNX2X_DCBX_STRICT_COS_HIGHEST;\n\t}\n}\n\nstatic int bnx2x_dcbx_join_pgs(\n\t\t\t      struct bnx2x            *bp,\n\t\t\t      struct dcbx_ets_feature *ets,\n\t\t\t      struct pg_help_data     *pg_help_data,\n\t\t\t      u8                      required_num_of_pg)\n{\n\tu8 entry_joined    = pg_help_data->num_of_pg - 1;\n\tu8 entry_removed   = entry_joined + 1;\n\tu8 pg_joined       = 0;\n\n\tif (required_num_of_pg == 0 || ARRAY_SIZE(pg_help_data->data)\n\t\t\t\t\t\t<= pg_help_data->num_of_pg) {\n\n\t\tBNX2X_ERR(\"required_num_of_pg can't be zero\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\twhile (required_num_of_pg < pg_help_data->num_of_pg) {\n\t\tentry_joined = pg_help_data->num_of_pg - 2;\n\t\tentry_removed = entry_joined + 1;\n\t\t \n\t\tentry_removed %= ARRAY_SIZE(pg_help_data->data);\n\n\t\tpg_help_data->data[entry_joined].pg_priority |=\n\t\t\tpg_help_data->data[entry_removed].pg_priority;\n\n\t\tpg_help_data->data[entry_joined].num_of_dif_pri +=\n\t\t\tpg_help_data->data[entry_removed].num_of_dif_pri;\n\n\t\tif (pg_help_data->data[entry_joined].pg == DCBX_STRICT_PRI_PG ||\n\t\t    pg_help_data->data[entry_removed].pg == DCBX_STRICT_PRI_PG)\n\t\t\t \n\t\t\tpg_help_data->data[entry_joined].pg =\n\t\t\t\t\t\t\tDCBX_STRICT_PRI_PG;\n\t\telse {\n\t\t\t \n\t\t\tpg_joined = DCBX_PG_BW_GET(ets->pg_bw_tbl,\n\t\t\t\t\tpg_help_data->data[entry_joined].pg) +\n\t\t\t\t    DCBX_PG_BW_GET(ets->pg_bw_tbl,\n\t\t\t\t\tpg_help_data->data[entry_removed].pg);\n\n\t\t\tDCBX_PG_BW_SET(ets->pg_bw_tbl,\n\t\t\t\tpg_help_data->data[entry_joined].pg, pg_joined);\n\t\t}\n\t\t \n\t\tpg_help_data->num_of_pg--;\n\t}\n\n\treturn 0;\n}\n\nstatic void bnx2x_dcbx_2cos_limit_cee_three_pg_to_cos_params(\n\t\t\t      struct bnx2x\t\t*bp,\n\t\t\t      struct pg_help_data\t*pg_help_data,\n\t\t\t      struct dcbx_ets_feature\t*ets,\n\t\t\t      struct cos_help_data\t*cos_data,\n\t\t\t      u32\t\t\t*pg_pri_orginal_spread,\n\t\t\t      u32\t\t\tpri_join_mask,\n\t\t\t      u8\t\t\tnum_of_dif_pri)\n{\n\tu8 i = 0;\n\tu32 pri_tested = 0;\n\tu8 entry = 0;\n\tu8 pg_entry = 0;\n\tbool b_found_strict = false;\n\tu8 num_of_pri = LLFC_DRIVER_TRAFFIC_TYPE_MAX;\n\n\tcos_data->data[0].pri_join_mask = cos_data->data[1].pri_join_mask = 0;\n\t \n\tif (IS_DCBX_PFC_PRI_MIX_PAUSE(bp, pri_join_mask))\n\t\tbnx2x_dcbx_separate_pauseable_from_non(bp,\n\t\t\t\tcos_data, pg_pri_orginal_spread, ets);\n\telse {\n\t\t \n\n\t\tcos_data->data[0].pausable = cos_data->data[1].pausable =\n\t\t\tIS_DCBX_PFC_PRI_ONLY_PAUSE(bp, pri_join_mask);\n\n\t\tfor (i = 0 ; i < num_of_pri; i++) {\n\t\t\tpri_tested = 1 << bp->dcbx_port_params.\n\t\t\t\tapp.traffic_type_priority[i];\n\t\t\tpg_entry = (u8)pg_pri_orginal_spread[bp->\n\t\t\t\tdcbx_port_params.app.traffic_type_priority[i]];\n\n\t\t\tif (pg_entry < DCBX_MAX_NUM_PG_BW_ENTRIES) {\n\t\t\t\tentry = 0;\n\n\t\t\t\tif (i == (num_of_pri-1) && !b_found_strict)\n\t\t\t\t\t \n\t\t\t\t\tentry = 1;\n\t\t\t\tcos_data->data[entry].pri_join_mask |=\n\t\t\t\t\t\t\t\tpri_tested;\n\t\t\t\tbnx2x_dcbx_add_to_cos_bw(bp,\n\t\t\t\t\t&cos_data->data[entry],\n\t\t\t\t\tDCBX_PG_BW_GET(ets->pg_bw_tbl,\n\t\t\t\t\t\t       pg_entry));\n\t\t\t} else {\n\t\t\t\tb_found_strict = true;\n\t\t\t\tcos_data->data[1].pri_join_mask |= pri_tested;\n\t\t\t\t \n\t\t\t\tcos_data->data[1].strict =\n\t\t\t\t\tBNX2X_DCBX_STRICT_COS_HIGHEST;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void bnx2x_dcbx_2cos_limit_cee_fill_cos_params(struct bnx2x *bp,\n\t\t\t\t       struct pg_help_data *help_data,\n\t\t\t\t       struct dcbx_ets_feature *ets,\n\t\t\t\t       struct cos_help_data *cos_data,\n\t\t\t\t       u32 *pg_pri_orginal_spread,\n\t\t\t\t       u32 pri_join_mask,\n\t\t\t\t       u8 num_of_dif_pri)\n{\n\t \n\tcos_data->num_of_cos = DCBX_COS_MAX_NUM_E2;\n\n\tswitch (help_data->num_of_pg) {\n\tcase 1:\n\t\tbnx2x_dcbx_2cos_limit_cee_single_pg_to_cos_params(\n\t\t\t\t\t       bp,\n\t\t\t\t\t       help_data,\n\t\t\t\t\t       cos_data,\n\t\t\t\t\t       pri_join_mask,\n\t\t\t\t\t       num_of_dif_pri);\n\t\tbreak;\n\tcase 2:\n\t\tbnx2x_dcbx_2cos_limit_cee_two_pg_to_cos_params(\n\t\t\t\t\t    bp,\n\t\t\t\t\t    help_data,\n\t\t\t\t\t    ets,\n\t\t\t\t\t    cos_data,\n\t\t\t\t\t    pg_pri_orginal_spread,\n\t\t\t\t\t    pri_join_mask,\n\t\t\t\t\t    num_of_dif_pri);\n\t\tbreak;\n\n\tcase 3:\n\t\tbnx2x_dcbx_2cos_limit_cee_three_pg_to_cos_params(\n\t\t\t\t\t      bp,\n\t\t\t\t\t      help_data,\n\t\t\t\t\t      ets,\n\t\t\t\t\t      cos_data,\n\t\t\t\t\t      pg_pri_orginal_spread,\n\t\t\t\t\t      pri_join_mask,\n\t\t\t\t\t      num_of_dif_pri);\n\t\tbreak;\n\tdefault:\n\t\tBNX2X_ERR(\"Wrong pg_help_data.num_of_pg\\n\");\n\t\tbnx2x_dcbx_ets_disabled_entry_data(bp,\n\t\t\t\t\t\t   cos_data, pri_join_mask);\n\t}\n}\n\nstatic int bnx2x_dcbx_spread_strict_pri(struct bnx2x *bp,\n\t\t\t\t\tstruct cos_help_data *cos_data,\n\t\t\t\t\tu8 entry,\n\t\t\t\t\tu8 num_spread_of_entries,\n\t\t\t\t\tu8 strict_app_pris)\n{\n\tu8 strict_pri = BNX2X_DCBX_STRICT_COS_HIGHEST;\n\tu8 num_of_app_pri = MAX_PFC_PRIORITIES;\n\tu8 app_pri_bit = 0;\n\n\twhile (num_spread_of_entries && num_of_app_pri > 0) {\n\t\tapp_pri_bit = 1 << (num_of_app_pri - 1);\n\t\tif (app_pri_bit & strict_app_pris) {\n\t\t\tstruct cos_entry_help_data *data = &cos_data->\n\t\t\t\t\t\t\t\tdata[entry];\n\t\t\tnum_spread_of_entries--;\n\t\t\tif (num_spread_of_entries == 0) {\n\t\t\t\t \n\t\t\t\tdata->cos_bw = DCBX_INVALID_COS_BW;\n\t\t\t\tdata->strict = strict_pri;\n\t\t\t\tdata->pri_join_mask = strict_app_pris;\n\t\t\t\tdata->pausable = DCBX_IS_PFC_PRI_SOME_PAUSE(bp,\n\t\t\t\t\t\t\tdata->pri_join_mask);\n\t\t\t} else {\n\t\t\t\tstrict_app_pris &= ~app_pri_bit;\n\n\t\t\t\tdata->cos_bw = DCBX_INVALID_COS_BW;\n\t\t\t\tdata->strict = strict_pri;\n\t\t\t\tdata->pri_join_mask = app_pri_bit;\n\t\t\t\tdata->pausable = DCBX_IS_PFC_PRI_SOME_PAUSE(bp,\n\t\t\t\t\t\t\tdata->pri_join_mask);\n\t\t\t}\n\n\t\t\tstrict_pri =\n\t\t\t    BNX2X_DCBX_STRICT_COS_NEXT_LOWER_PRI(strict_pri);\n\t\t\tentry++;\n\t\t}\n\n\t\tnum_of_app_pri--;\n\t}\n\n\tif (num_spread_of_entries) {\n\t\tBNX2X_ERR(\"Didn't succeed to spread strict priorities\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic u8 bnx2x_dcbx_cee_fill_strict_pri(struct bnx2x *bp,\n\t\t\t\t\t struct cos_help_data *cos_data,\n\t\t\t\t\t u8 entry,\n\t\t\t\t\t u8 num_spread_of_entries,\n\t\t\t\t\t u8 strict_app_pris)\n{\n\tif (bnx2x_dcbx_spread_strict_pri(bp, cos_data, entry,\n\t\t\t\t\t num_spread_of_entries,\n\t\t\t\t\t strict_app_pris)) {\n\t\tstruct cos_entry_help_data *data = &cos_data->\n\t\t\t\t\t\t    data[entry];\n\t\t \n\t\tdata->cos_bw = DCBX_INVALID_COS_BW;\n\t\tdata->strict = BNX2X_DCBX_STRICT_COS_HIGHEST;\n\t\tdata->pri_join_mask = strict_app_pris;\n\t\tdata->pausable = DCBX_IS_PFC_PRI_SOME_PAUSE(bp,\n\t\t\t\t data->pri_join_mask);\n\t\treturn 1;\n\t}\n\n\treturn num_spread_of_entries;\n}\n\nstatic void bnx2x_dcbx_cee_fill_cos_params(struct bnx2x *bp,\n\t\t\t\t\t   struct pg_help_data *help_data,\n\t\t\t\t\t   struct dcbx_ets_feature *ets,\n\t\t\t\t\t   struct cos_help_data *cos_data,\n\t\t\t\t\t   u32 pri_join_mask)\n\n{\n\tu8 need_num_of_entries = 0;\n\tu8 i = 0;\n\tu8 entry = 0;\n\n\t \n\tif (help_data->num_of_pg > DCBX_COS_MAX_NUM_E3B0) {\n\t\tif (bnx2x_dcbx_join_pgs(bp, ets, help_data,\n\t\t\t\t\tDCBX_COS_MAX_NUM_E3B0)) {\n\t\t\tBNX2X_ERR(\"Unable to reduce the number of PGs - we will disables ETS\\n\");\n\t\t\tbnx2x_dcbx_ets_disabled_entry_data(bp, cos_data,\n\t\t\t\t\t\t\t   pri_join_mask);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tfor (i = 0 ; i < help_data->num_of_pg; i++) {\n\t\tstruct pg_entry_help_data *pg =  &help_data->data[i];\n\t\tif (pg->pg < DCBX_MAX_NUM_PG_BW_ENTRIES) {\n\t\t\tstruct cos_entry_help_data *data = &cos_data->\n\t\t\t\t\t\t\t    data[entry];\n\t\t\t \n\t\t\tdata->cos_bw = DCBX_PG_BW_GET(ets->pg_bw_tbl, pg->pg);\n\t\t\tdata->strict = BNX2X_DCBX_STRICT_INVALID;\n\t\t\tdata->pri_join_mask = pg->pg_priority;\n\t\t\tdata->pausable = DCBX_IS_PFC_PRI_SOME_PAUSE(bp,\n\t\t\t\t\t\tdata->pri_join_mask);\n\n\t\t\tentry++;\n\t\t} else {\n\t\t\tneed_num_of_entries =  min_t(u8,\n\t\t\t\t(u8)pg->num_of_dif_pri,\n\t\t\t\t(u8)DCBX_COS_MAX_NUM_E3B0 -\n\t\t\t\t\t\t help_data->num_of_pg + 1);\n\t\t\t \n\t\t\tentry += bnx2x_dcbx_cee_fill_strict_pri(bp, cos_data,\n\t\t\t\tentry, need_num_of_entries, pg->pg_priority);\n\t\t}\n\t}\n\n\t \n\tcos_data->num_of_cos = entry;\n}\nstatic void bnx2x_dcbx_fill_cos_params(struct bnx2x *bp,\n\t\t\t\t       struct pg_help_data *help_data,\n\t\t\t\t       struct dcbx_ets_feature *ets,\n\t\t\t\t       u32 *pg_pri_orginal_spread)\n{\n\tstruct cos_help_data         cos_data;\n\tu8                    i                           = 0;\n\tu32                   pri_join_mask               = 0;\n\tu8                    num_of_dif_pri              = 0;\n\n\tmemset(&cos_data, 0, sizeof(cos_data));\n\n\t \n\tfor (i = 0; i < help_data->num_of_pg ; i++) {\n\t\tif (DCBX_STRICT_PRIORITY != help_data->data[i].pg &&\n\t\t    DCBX_MAX_NUM_PG_BW_ENTRIES <= help_data->data[i].pg)\n\t\t\tBNX2X_ERR(\"Invalid pg[%d] data %x\\n\", i,\n\t\t\t\t  help_data->data[i].pg);\n\t\tpri_join_mask   |=  help_data->data[i].pg_priority;\n\t\tnum_of_dif_pri  += help_data->data[i].num_of_dif_pri;\n\t}\n\n\t \n\tcos_data.num_of_cos = 1;\n\tfor (i = 0; i < ARRAY_SIZE(cos_data.data); i++) {\n\t\tcos_data.data[i].pri_join_mask = 0;\n\t\tcos_data.data[i].pausable = false;\n\t\tcos_data.data[i].strict = BNX2X_DCBX_STRICT_INVALID;\n\t\tcos_data.data[i].cos_bw = DCBX_INVALID_COS_BW;\n\t}\n\n\tif (CHIP_IS_E3B0(bp))\n\t\tbnx2x_dcbx_cee_fill_cos_params(bp, help_data, ets,\n\t\t\t\t\t       &cos_data, pri_join_mask);\n\telse  \n\t\tbnx2x_dcbx_2cos_limit_cee_fill_cos_params(bp,\n\t\t\t\t\t\t\t  help_data, ets,\n\t\t\t\t\t\t\t  &cos_data,\n\t\t\t\t\t\t\t  pg_pri_orginal_spread,\n\t\t\t\t\t\t\t  pri_join_mask,\n\t\t\t\t\t\t\t  num_of_dif_pri);\n\n\tfor (i = 0; i < cos_data.num_of_cos ; i++) {\n\t\tstruct bnx2x_dcbx_cos_params *p =\n\t\t\t&bp->dcbx_port_params.ets.cos_params[i];\n\n\t\tp->strict = cos_data.data[i].strict;\n\t\tp->bw_tbl = cos_data.data[i].cos_bw;\n\t\tp->pri_bitmask = cos_data.data[i].pri_join_mask;\n\t\tp->pauseable = cos_data.data[i].pausable;\n\n\t\t \n\t\tif (p->bw_tbl != DCBX_INVALID_COS_BW ||\n\t\t    p->strict != BNX2X_DCBX_STRICT_INVALID) {\n\t\t\tif (p->pri_bitmask == 0)\n\t\t\t\tBNX2X_ERR(\"Invalid pri_bitmask for %d\\n\", i);\n\n\t\t\tif (CHIP_IS_E2(bp) || CHIP_IS_E3A0(bp)) {\n\n\t\t\t\tif (p->pauseable &&\n\t\t\t\t    DCBX_PFC_PRI_GET_NON_PAUSE(bp,\n\t\t\t\t\t\tp->pri_bitmask) != 0)\n\t\t\t\t\tBNX2X_ERR(\"Inconsistent config for pausable COS %d\\n\",\n\t\t\t\t\t\t  i);\n\n\t\t\t\tif (!p->pauseable &&\n\t\t\t\t    DCBX_PFC_PRI_GET_PAUSE(bp,\n\t\t\t\t\t\tp->pri_bitmask) != 0)\n\t\t\t\t\tBNX2X_ERR(\"Inconsistent config for nonpausable COS %d\\n\",\n\t\t\t\t\t\t  i);\n\t\t\t}\n\t\t}\n\n\t\tif (p->pauseable)\n\t\t\tDP(BNX2X_MSG_DCB, \"COS %d PAUSABLE prijoinmask 0x%x\\n\",\n\t\t\t\t  i, cos_data.data[i].pri_join_mask);\n\t\telse\n\t\t\tDP(BNX2X_MSG_DCB,\n\t\t\t   \"COS %d NONPAUSABLE prijoinmask 0x%x\\n\",\n\t\t\t   i, cos_data.data[i].pri_join_mask);\n\t}\n\n\tbp->dcbx_port_params.ets.num_of_cos = cos_data.num_of_cos ;\n}\n\nstatic void bnx2x_dcbx_get_ets_pri_pg_tbl(struct bnx2x *bp,\n\t\t\t\tu32 *set_configuration_ets_pg,\n\t\t\t\tu32 *pri_pg_tbl)\n{\n\tint i;\n\n\tfor (i = 0; i < DCBX_MAX_NUM_PRI_PG_ENTRIES; i++) {\n\t\tset_configuration_ets_pg[i] = DCBX_PRI_PG_GET(pri_pg_tbl, i);\n\n\t\tDP(BNX2X_MSG_DCB, \"set_configuration_ets_pg[%d] = 0x%x\\n\",\n\t\t   i, set_configuration_ets_pg[i]);\n\t}\n}\n\nstatic void bnx2x_dcbx_fw_struct(struct bnx2x *bp,\n\t\t\t\t struct bnx2x_func_tx_start_params *pfc_fw_cfg)\n{\n\tu16 pri_bit = 0;\n\tu8 cos = 0, pri = 0;\n\tstruct priority_cos *tt2cos;\n\tu32 *ttp = bp->dcbx_port_params.app.traffic_type_priority;\n\tint mfw_configured = SHMEM2_HAS(bp, drv_flags) &&\n\t\t\t     GET_FLAGS(SHMEM2_RD(bp, drv_flags),\n\t\t\t\t       1 << DRV_FLAGS_DCB_MFW_CONFIGURED);\n\n\tmemset(pfc_fw_cfg, 0, sizeof(*pfc_fw_cfg));\n\n\t \n\tif ((bp->dcbx_error & DCBX_REMOTE_MIB_ERROR) && !mfw_configured)\n\t\treturn;\n\n\t \n\ttt2cos = pfc_fw_cfg->traffic_type_to_priority_cos;\n\n\t \n\tpfc_fw_cfg->dcb_version = ++bp->dcb_version;\n\tpfc_fw_cfg->dcb_enabled = 1;\n\n\t \n\tfor (pri = 0; pri < LLFC_DRIVER_TRAFFIC_TYPE_MAX; pri++) {\n\t\ttt2cos[pri].priority = ttp[pri];\n\t\tpri_bit = 1 << tt2cos[pri].priority;\n\n\t\t \n\t\tfor (cos = 0; cos < bp->dcbx_port_params.ets.num_of_cos; cos++)\n\t\t\tif (bp->dcbx_port_params.ets.cos_params[cos].\n\t\t\t\t\t\tpri_bitmask & pri_bit)\n\t\t\t\t\ttt2cos[pri].cos = cos;\n\n\t\tpfc_fw_cfg->dcb_outer_pri[pri]  = ttp[pri];\n\t}\n\n\t \n\tpfc_fw_cfg->dont_add_pri_0_en = 1;\n\n\tbnx2x_dcbx_print_cos_params(bp,\tpfc_fw_cfg);\n}\n\nvoid bnx2x_dcbx_pmf_update(struct bnx2x *bp)\n{\n\t \n\tif (SHMEM2_HAS(bp, drv_flags) &&\n\t   GET_FLAGS(SHMEM2_RD(bp, drv_flags), 1 << DRV_FLAGS_DCB_CONFIGURED)) {\n\t\t \n\t\tif (bnx2x_dcbx_read_shmem_neg_results(bp))\n\t\t\treturn;\n\n\t\tbnx2x_dump_dcbx_drv_param(bp, &bp->dcbx_local_feat,\n\t\t\t\t\t  bp->dcbx_error);\n\t\tbnx2x_get_dcbx_drv_param(bp, &bp->dcbx_local_feat,\n\t\t\t\t\t bp->dcbx_error);\n#ifdef BCM_DCBNL\n\t\t \n\t\tbnx2x_dcbnl_update_applist(bp, false);\n\t\t \n\t\tdcbnl_cee_notify(bp->dev, RTM_GETDCB, DCB_CMD_CEE_GET, 0, 0);\n#endif\n\t\t \n\t\tbnx2x_dcbx_update_tc_mapping(bp);\n\t}\n}\n\n \n#ifdef BCM_DCBNL\n\n#define BNX2X_DCBX_CAPS\t\t(DCB_CAP_DCBX_LLD_MANAGED | \\\n\t\t\t\tDCB_CAP_DCBX_VER_CEE | DCB_CAP_DCBX_STATIC)\n\nstatic inline bool bnx2x_dcbnl_set_valid(struct bnx2x *bp)\n{\n\t \n\treturn bp->dcb_state && bp->dcbx_mode_uset;\n}\n\nstatic u8 bnx2x_dcbnl_get_state(struct net_device *netdev)\n{\n\tstruct bnx2x *bp = netdev_priv(netdev);\n\tDP(BNX2X_MSG_DCB, \"state = %d\\n\", bp->dcb_state);\n\treturn bp->dcb_state;\n}\n\nstatic u8 bnx2x_dcbnl_set_state(struct net_device *netdev, u8 state)\n{\n\tstruct bnx2x *bp = netdev_priv(netdev);\n\tDP(BNX2X_MSG_DCB, \"state = %s\\n\", state ? \"on\" : \"off\");\n\n\t \n\tif (state && ((bp->dcbx_enabled == BNX2X_DCBX_ENABLED_OFF) ||\n\t\t      (bp->dcbx_enabled == BNX2X_DCBX_ENABLED_INVALID))) {\n\t\tDP(BNX2X_MSG_DCB, \"Can not set dcbx to enabled while it is disabled in nvm\\n\");\n\t\treturn 1;\n\t}\n\n\tbnx2x_dcbx_set_state(bp, (state ? true : false), bp->dcbx_enabled);\n\treturn 0;\n}\n\nstatic void bnx2x_dcbnl_get_perm_hw_addr(struct net_device *netdev,\n\t\t\t\t\t u8 *perm_addr)\n{\n\tstruct bnx2x *bp = netdev_priv(netdev);\n\tDP(BNX2X_MSG_DCB, \"GET-PERM-ADDR\\n\");\n\n\t \n\tmemcpy(perm_addr, netdev->dev_addr, netdev->addr_len);\n\n\tif (CNIC_LOADED(bp))\n\t\t \n\t\tmemcpy(perm_addr+netdev->addr_len, bp->fip_mac,\n\t\t       netdev->addr_len);\n}\n\nstatic void bnx2x_dcbnl_set_pg_tccfg_tx(struct net_device *netdev, int prio,\n\t\t\t\t\tu8 prio_type, u8 pgid, u8 bw_pct,\n\t\t\t\t\tu8 up_map)\n{\n\tstruct bnx2x *bp = netdev_priv(netdev);\n\n\tDP(BNX2X_MSG_DCB, \"prio[%d] = %d\\n\", prio, pgid);\n\tif (!bnx2x_dcbnl_set_valid(bp) || prio >= DCBX_MAX_NUM_PRI_PG_ENTRIES)\n\t\treturn;\n\n\t \n\n\tbp->dcbx_config_params.admin_configuration_ets_pg[prio] = pgid;\n\tbp->dcbx_config_params.admin_ets_configuration_tx_enable = 1;\n}\n\nstatic void bnx2x_dcbnl_set_pg_bwgcfg_tx(struct net_device *netdev,\n\t\t\t\t\t int pgid, u8 bw_pct)\n{\n\tstruct bnx2x *bp = netdev_priv(netdev);\n\tDP(BNX2X_MSG_DCB, \"pgid[%d] = %d\\n\", pgid, bw_pct);\n\n\tif (!bnx2x_dcbnl_set_valid(bp) || pgid >= DCBX_MAX_NUM_PG_BW_ENTRIES)\n\t\treturn;\n\n\tbp->dcbx_config_params.admin_configuration_bw_precentage[pgid] = bw_pct;\n\tbp->dcbx_config_params.admin_ets_configuration_tx_enable = 1;\n}\n\nstatic void bnx2x_dcbnl_set_pg_tccfg_rx(struct net_device *netdev, int prio,\n\t\t\t\t\tu8 prio_type, u8 pgid, u8 bw_pct,\n\t\t\t\t\tu8 up_map)\n{\n\tstruct bnx2x *bp = netdev_priv(netdev);\n\tDP(BNX2X_MSG_DCB, \"Nothing to set; No RX support\\n\");\n}\n\nstatic void bnx2x_dcbnl_set_pg_bwgcfg_rx(struct net_device *netdev,\n\t\t\t\t\t int pgid, u8 bw_pct)\n{\n\tstruct bnx2x *bp = netdev_priv(netdev);\n\tDP(BNX2X_MSG_DCB, \"Nothing to set; No RX support\\n\");\n}\n\nstatic void bnx2x_dcbnl_get_pg_tccfg_tx(struct net_device *netdev, int prio,\n\t\t\t\t\tu8 *prio_type, u8 *pgid, u8 *bw_pct,\n\t\t\t\t\tu8 *up_map)\n{\n\tstruct bnx2x *bp = netdev_priv(netdev);\n\tDP(BNX2X_MSG_DCB, \"prio = %d\\n\", prio);\n\n\t \n\t*up_map = *bw_pct = *prio_type = *pgid = 0;\n\n\tif (!bp->dcb_state || prio >= DCBX_MAX_NUM_PRI_PG_ENTRIES)\n\t\treturn;\n\n\t*pgid = DCBX_PRI_PG_GET(bp->dcbx_local_feat.ets.pri_pg_tbl, prio);\n}\n\nstatic void bnx2x_dcbnl_get_pg_bwgcfg_tx(struct net_device *netdev,\n\t\t\t\t\t int pgid, u8 *bw_pct)\n{\n\tstruct bnx2x *bp = netdev_priv(netdev);\n\tDP(BNX2X_MSG_DCB, \"pgid = %d\\n\", pgid);\n\n\t*bw_pct = 0;\n\n\tif (!bp->dcb_state || pgid >= DCBX_MAX_NUM_PG_BW_ENTRIES)\n\t\treturn;\n\n\t*bw_pct = DCBX_PG_BW_GET(bp->dcbx_local_feat.ets.pg_bw_tbl, pgid);\n}\n\nstatic void bnx2x_dcbnl_get_pg_tccfg_rx(struct net_device *netdev, int prio,\n\t\t\t\t\tu8 *prio_type, u8 *pgid, u8 *bw_pct,\n\t\t\t\t\tu8 *up_map)\n{\n\tstruct bnx2x *bp = netdev_priv(netdev);\n\tDP(BNX2X_MSG_DCB, \"Nothing to get; No RX support\\n\");\n\n\t*prio_type = *pgid = *bw_pct = *up_map = 0;\n}\n\nstatic void bnx2x_dcbnl_get_pg_bwgcfg_rx(struct net_device *netdev,\n\t\t\t\t\t int pgid, u8 *bw_pct)\n{\n\tstruct bnx2x *bp = netdev_priv(netdev);\n\tDP(BNX2X_MSG_DCB, \"Nothing to get; No RX support\\n\");\n\n\t*bw_pct = 0;\n}\n\nstatic void bnx2x_dcbnl_set_pfc_cfg(struct net_device *netdev, int prio,\n\t\t\t\t    u8 setting)\n{\n\tstruct bnx2x *bp = netdev_priv(netdev);\n\tDP(BNX2X_MSG_DCB, \"prio[%d] = %d\\n\", prio, setting);\n\n\tif (!bnx2x_dcbnl_set_valid(bp) || prio >= MAX_PFC_PRIORITIES)\n\t\treturn;\n\n\tif (setting) {\n\t\tbp->dcbx_config_params.admin_pfc_bitmap |= (1 << prio);\n\t\tbp->dcbx_config_params.admin_pfc_tx_enable = 1;\n\t} else {\n\t\tbp->dcbx_config_params.admin_pfc_bitmap &= ~(1 << prio);\n\t}\n}\n\nstatic void bnx2x_dcbnl_get_pfc_cfg(struct net_device *netdev, int prio,\n\t\t\t\t    u8 *setting)\n{\n\tstruct bnx2x *bp = netdev_priv(netdev);\n\tDP(BNX2X_MSG_DCB, \"prio = %d\\n\", prio);\n\n\t*setting = 0;\n\n\tif (!bp->dcb_state || prio >= MAX_PFC_PRIORITIES)\n\t\treturn;\n\n\t*setting = (bp->dcbx_local_feat.pfc.pri_en_bitmap >> prio) & 0x1;\n}\n\nstatic u8 bnx2x_dcbnl_set_all(struct net_device *netdev)\n{\n\tstruct bnx2x *bp = netdev_priv(netdev);\n\n\tDP(BNX2X_MSG_DCB, \"SET-ALL\\n\");\n\n\tif (!bnx2x_dcbnl_set_valid(bp))\n\t\treturn 1;\n\n\tif (bp->recovery_state != BNX2X_RECOVERY_DONE) {\n\t\tnetdev_err(bp->dev,\n\t\t\t   \"Handling parity error recovery. Try again later\\n\");\n\t\treturn 1;\n\t}\n\tif (netif_running(bp->dev)) {\n\t\tbnx2x_update_drv_flags(bp,\n\t\t\t\t       1 << DRV_FLAGS_DCB_MFW_CONFIGURED,\n\t\t\t\t       1);\n\t\tbnx2x_dcbx_init(bp, true);\n\t}\n\tDP(BNX2X_MSG_DCB, \"set_dcbx_params done\\n\");\n\n\treturn 0;\n}\n\nstatic u8 bnx2x_dcbnl_get_cap(struct net_device *netdev, int capid, u8 *cap)\n{\n\tstruct bnx2x *bp = netdev_priv(netdev);\n\tu8 rval = 0;\n\n\tif (bp->dcb_state) {\n\t\tswitch (capid) {\n\t\tcase DCB_CAP_ATTR_PG:\n\t\t\t*cap = true;\n\t\t\tbreak;\n\t\tcase DCB_CAP_ATTR_PFC:\n\t\t\t*cap = true;\n\t\t\tbreak;\n\t\tcase DCB_CAP_ATTR_UP2TC:\n\t\t\t*cap = false;\n\t\t\tbreak;\n\t\tcase DCB_CAP_ATTR_PG_TCS:\n\t\t\t*cap = 0x80;\t \n\t\t\tbreak;\n\t\tcase DCB_CAP_ATTR_PFC_TCS:\n\t\t\t*cap = 0x80;\t \n\t\t\tbreak;\n\t\tcase DCB_CAP_ATTR_GSP:\n\t\t\t*cap = true;\n\t\t\tbreak;\n\t\tcase DCB_CAP_ATTR_BCN:\n\t\t\t*cap = false;\n\t\t\tbreak;\n\t\tcase DCB_CAP_ATTR_DCBX:\n\t\t\t*cap = BNX2X_DCBX_CAPS;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBNX2X_ERR(\"Non valid capability ID\\n\");\n\t\t\trval = 1;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tDP(BNX2X_MSG_DCB, \"DCB disabled\\n\");\n\t\trval = 1;\n\t}\n\n\tDP(BNX2X_MSG_DCB, \"capid %d:%x\\n\", capid, *cap);\n\treturn rval;\n}\n\nstatic int bnx2x_dcbnl_get_numtcs(struct net_device *netdev, int tcid, u8 *num)\n{\n\tstruct bnx2x *bp = netdev_priv(netdev);\n\tu8 rval = 0;\n\n\tDP(BNX2X_MSG_DCB, \"tcid %d\\n\", tcid);\n\n\tif (bp->dcb_state) {\n\t\tswitch (tcid) {\n\t\tcase DCB_NUMTCS_ATTR_PG:\n\t\t\t*num = CHIP_IS_E3B0(bp) ? DCBX_COS_MAX_NUM_E3B0 :\n\t\t\t\t\t\t  DCBX_COS_MAX_NUM_E2;\n\t\t\tbreak;\n\t\tcase DCB_NUMTCS_ATTR_PFC:\n\t\t\t*num = CHIP_IS_E3B0(bp) ? DCBX_COS_MAX_NUM_E3B0 :\n\t\t\t\t\t\t  DCBX_COS_MAX_NUM_E2;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBNX2X_ERR(\"Non valid TC-ID\\n\");\n\t\t\trval = 1;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tDP(BNX2X_MSG_DCB, \"DCB disabled\\n\");\n\t\trval = 1;\n\t}\n\n\treturn rval;\n}\n\nstatic int bnx2x_dcbnl_set_numtcs(struct net_device *netdev, int tcid, u8 num)\n{\n\tstruct bnx2x *bp = netdev_priv(netdev);\n\tDP(BNX2X_MSG_DCB, \"num tcs = %d; Not supported\\n\", num);\n\treturn -EINVAL;\n}\n\nstatic u8 bnx2x_dcbnl_get_pfc_state(struct net_device *netdev)\n{\n\tstruct bnx2x *bp = netdev_priv(netdev);\n\tDP(BNX2X_MSG_DCB, \"state = %d\\n\", bp->dcbx_local_feat.pfc.enabled);\n\n\tif (!bp->dcb_state)\n\t\treturn 0;\n\n\treturn bp->dcbx_local_feat.pfc.enabled;\n}\n\nstatic void bnx2x_dcbnl_set_pfc_state(struct net_device *netdev, u8 state)\n{\n\tstruct bnx2x *bp = netdev_priv(netdev);\n\tDP(BNX2X_MSG_DCB, \"state = %s\\n\", state ? \"on\" : \"off\");\n\n\tif (!bnx2x_dcbnl_set_valid(bp))\n\t\treturn;\n\n\tbp->dcbx_config_params.admin_pfc_tx_enable =\n\tbp->dcbx_config_params.admin_pfc_enable = (state ? 1 : 0);\n}\n\nstatic void bnx2x_admin_app_set_ent(\n\tstruct bnx2x_admin_priority_app_table *app_ent,\n\tu8 idtype, u16 idval, u8 up)\n{\n\tapp_ent->valid = 1;\n\n\tswitch (idtype) {\n\tcase DCB_APP_IDTYPE_ETHTYPE:\n\t\tapp_ent->traffic_type = TRAFFIC_TYPE_ETH;\n\t\tbreak;\n\tcase DCB_APP_IDTYPE_PORTNUM:\n\t\tapp_ent->traffic_type = TRAFFIC_TYPE_PORT;\n\t\tbreak;\n\tdefault:\n\t\tbreak;  \n\t}\n\tapp_ent->app_id = idval;\n\tapp_ent->priority = up;\n}\n\nstatic bool bnx2x_admin_app_is_equal(\n\tstruct bnx2x_admin_priority_app_table *app_ent,\n\tu8 idtype, u16 idval)\n{\n\tif (!app_ent->valid)\n\t\treturn false;\n\n\tswitch (idtype) {\n\tcase DCB_APP_IDTYPE_ETHTYPE:\n\t\tif (app_ent->traffic_type != TRAFFIC_TYPE_ETH)\n\t\t\treturn false;\n\t\tbreak;\n\tcase DCB_APP_IDTYPE_PORTNUM:\n\t\tif (app_ent->traffic_type != TRAFFIC_TYPE_PORT)\n\t\t\treturn false;\n\t\tbreak;\n\tdefault:\n\t\treturn false;\n\t}\n\tif (app_ent->app_id != idval)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic int bnx2x_set_admin_app_up(struct bnx2x *bp, u8 idtype, u16 idval, u8 up)\n{\n\tint i, ff;\n\n\t \n\tfor (i = 0, ff = -1; i < DCBX_CONFIG_MAX_APP_PROTOCOL; i++) {\n\t\tstruct bnx2x_admin_priority_app_table *app_ent =\n\t\t\t&bp->dcbx_config_params.admin_priority_app_table[i];\n\t\tif (bnx2x_admin_app_is_equal(app_ent, idtype, idval))\n\t\t\tbreak;\n\n\t\tif (ff < 0 && !app_ent->valid)\n\t\t\tff = i;\n\t}\n\tif (i < DCBX_CONFIG_MAX_APP_PROTOCOL)\n\t\t \n\t\tbp->dcbx_config_params.\n\t\t\tadmin_priority_app_table[i].priority = up;\n\telse if (ff >= 0)\n\t\t \n\t\tbnx2x_admin_app_set_ent(\n\t\t\t&bp->dcbx_config_params.admin_priority_app_table[ff],\n\t\t\tidtype, idval, up);\n\telse {\n\t\t \n\t\tBNX2X_ERR(\"Application table is too large\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\t \n\tif (up)\n\t\tbp->dcbx_config_params.admin_application_priority_tx_enable = 1;\n\n\treturn 0;\n}\n\nstatic int bnx2x_dcbnl_set_app_up(struct net_device *netdev, u8 idtype,\n\t\t\t\t  u16 idval, u8 up)\n{\n\tstruct bnx2x *bp = netdev_priv(netdev);\n\n\tDP(BNX2X_MSG_DCB, \"app_type %d, app_id %x, prio bitmap %d\\n\",\n\t   idtype, idval, up);\n\n\tif (!bnx2x_dcbnl_set_valid(bp)) {\n\t\tDP(BNX2X_MSG_DCB, \"dcbnl call not valid\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (idtype) {\n\tcase DCB_APP_IDTYPE_ETHTYPE:\n\tcase DCB_APP_IDTYPE_PORTNUM:\n\t\tbreak;\n\tdefault:\n\t\tDP(BNX2X_MSG_DCB, \"Wrong ID type\\n\");\n\t\treturn -EINVAL;\n\t}\n\treturn bnx2x_set_admin_app_up(bp, idtype, idval, up);\n}\n\nstatic u8 bnx2x_dcbnl_get_dcbx(struct net_device *netdev)\n{\n\tstruct bnx2x *bp = netdev_priv(netdev);\n\tu8 state;\n\n\tstate = DCB_CAP_DCBX_LLD_MANAGED | DCB_CAP_DCBX_VER_CEE;\n\n\tif (bp->dcbx_enabled == BNX2X_DCBX_ENABLED_ON_NEG_OFF)\n\t\tstate |= DCB_CAP_DCBX_STATIC;\n\n\treturn state;\n}\n\nstatic u8 bnx2x_dcbnl_set_dcbx(struct net_device *netdev, u8 state)\n{\n\tstruct bnx2x *bp = netdev_priv(netdev);\n\tDP(BNX2X_MSG_DCB, \"state = %02x\\n\", state);\n\n\t \n\n\tif ((state & BNX2X_DCBX_CAPS) != state) {\n\t\tBNX2X_ERR(\"Requested DCBX mode %x is beyond advertised capabilities\\n\",\n\t\t\t  state);\n\t\treturn 1;\n\t}\n\n\tif (bp->dcb_state != BNX2X_DCB_STATE_ON) {\n\t\tBNX2X_ERR(\"DCB turned off, DCBX configuration is invalid\\n\");\n\t\treturn 1;\n\t}\n\n\tif (state & DCB_CAP_DCBX_STATIC)\n\t\tbp->dcbx_enabled = BNX2X_DCBX_ENABLED_ON_NEG_OFF;\n\telse\n\t\tbp->dcbx_enabled = BNX2X_DCBX_ENABLED_ON_NEG_ON;\n\n\tbp->dcbx_mode_uset = true;\n\treturn 0;\n}\n\nstatic u8 bnx2x_dcbnl_get_featcfg(struct net_device *netdev, int featid,\n\t\t\t\t  u8 *flags)\n{\n\tstruct bnx2x *bp = netdev_priv(netdev);\n\tu8 rval = 0;\n\n\tDP(BNX2X_MSG_DCB, \"featid %d\\n\", featid);\n\n\tif (bp->dcb_state) {\n\t\t*flags = 0;\n\t\tswitch (featid) {\n\t\tcase DCB_FEATCFG_ATTR_PG:\n\t\t\tif (bp->dcbx_local_feat.ets.enabled)\n\t\t\t\t*flags |= DCB_FEATCFG_ENABLE;\n\t\t\tif (bp->dcbx_error & (DCBX_LOCAL_ETS_ERROR |\n\t\t\t\t\t      DCBX_REMOTE_MIB_ERROR))\n\t\t\t\t*flags |= DCB_FEATCFG_ERROR;\n\t\t\tbreak;\n\t\tcase DCB_FEATCFG_ATTR_PFC:\n\t\t\tif (bp->dcbx_local_feat.pfc.enabled)\n\t\t\t\t*flags |= DCB_FEATCFG_ENABLE;\n\t\t\tif (bp->dcbx_error & (DCBX_LOCAL_PFC_ERROR |\n\t\t\t\t\t      DCBX_LOCAL_PFC_MISMATCH |\n\t\t\t\t\t      DCBX_REMOTE_MIB_ERROR))\n\t\t\t\t*flags |= DCB_FEATCFG_ERROR;\n\t\t\tbreak;\n\t\tcase DCB_FEATCFG_ATTR_APP:\n\t\t\tif (bp->dcbx_local_feat.app.enabled)\n\t\t\t\t*flags |= DCB_FEATCFG_ENABLE;\n\t\t\tif (bp->dcbx_error & (DCBX_LOCAL_APP_ERROR |\n\t\t\t\t\t      DCBX_LOCAL_APP_MISMATCH |\n\t\t\t\t\t      DCBX_REMOTE_MIB_ERROR))\n\t\t\t\t*flags |= DCB_FEATCFG_ERROR;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBNX2X_ERR(\"Non valid feature-ID\\n\");\n\t\t\trval = 1;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tDP(BNX2X_MSG_DCB, \"DCB disabled\\n\");\n\t\trval = 1;\n\t}\n\n\treturn rval;\n}\n\nstatic u8 bnx2x_dcbnl_set_featcfg(struct net_device *netdev, int featid,\n\t\t\t\t  u8 flags)\n{\n\tstruct bnx2x *bp = netdev_priv(netdev);\n\tu8 rval = 0;\n\n\tDP(BNX2X_MSG_DCB, \"featid = %d flags = %02x\\n\", featid, flags);\n\n\t \n\tif (bnx2x_dcbnl_set_valid(bp)) {\n\t\tswitch (featid) {\n\t\tcase DCB_FEATCFG_ATTR_PG:\n\t\t\tbp->dcbx_config_params.admin_ets_enable =\n\t\t\t\tflags & DCB_FEATCFG_ENABLE ? 1 : 0;\n\t\t\tbp->dcbx_config_params.admin_ets_willing =\n\t\t\t\tflags & DCB_FEATCFG_WILLING ? 1 : 0;\n\t\t\tbreak;\n\t\tcase DCB_FEATCFG_ATTR_PFC:\n\t\t\tbp->dcbx_config_params.admin_pfc_enable =\n\t\t\t\tflags & DCB_FEATCFG_ENABLE ? 1 : 0;\n\t\t\tbp->dcbx_config_params.admin_pfc_willing =\n\t\t\t\tflags & DCB_FEATCFG_WILLING ? 1 : 0;\n\t\t\tbreak;\n\t\tcase DCB_FEATCFG_ATTR_APP:\n\t\t\t \n\t\t\tbp->dcbx_config_params.admin_app_priority_willing =\n\t\t\t\tflags & DCB_FEATCFG_WILLING ? 1 : 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBNX2X_ERR(\"Non valid feature-ID\\n\");\n\t\t\trval = 1;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tDP(BNX2X_MSG_DCB, \"dcbnl call not valid\\n\");\n\t\trval = 1;\n\t}\n\n\treturn rval;\n}\n\nstatic int bnx2x_peer_appinfo(struct net_device *netdev,\n\t\t\t      struct dcb_peer_app_info *info, u16* app_count)\n{\n\tint i;\n\tstruct bnx2x *bp = netdev_priv(netdev);\n\n\tDP(BNX2X_MSG_DCB, \"APP-INFO\\n\");\n\n\tinfo->willing = (bp->dcbx_remote_flags & DCBX_APP_REM_WILLING) ?: 0;\n\tinfo->error = (bp->dcbx_remote_flags & DCBX_APP_RX_ERROR) ?: 0;\n\t*app_count = 0;\n\n\tfor (i = 0; i < DCBX_MAX_APP_PROTOCOL; i++)\n\t\tif (bp->dcbx_remote_feat.app.app_pri_tbl[i].appBitfield &\n\t\t    DCBX_APP_ENTRY_VALID)\n\t\t\t(*app_count)++;\n\treturn 0;\n}\n\nstatic int bnx2x_peer_apptable(struct net_device *netdev,\n\t\t\t       struct dcb_app *table)\n{\n\tint i, j;\n\tstruct bnx2x *bp = netdev_priv(netdev);\n\n\tDP(BNX2X_MSG_DCB, \"APP-TABLE\\n\");\n\n\tfor (i = 0, j = 0; i < DCBX_MAX_APP_PROTOCOL; i++) {\n\t\tstruct dcbx_app_priority_entry *ent =\n\t\t\t&bp->dcbx_remote_feat.app.app_pri_tbl[i];\n\n\t\tif (ent->appBitfield & DCBX_APP_ENTRY_VALID) {\n\t\t\ttable[j].selector = bnx2x_dcbx_dcbnl_app_idtype(ent);\n\t\t\ttable[j].priority = bnx2x_dcbx_dcbnl_app_up(ent);\n\t\t\ttable[j++].protocol = ent->app_id;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int bnx2x_cee_peer_getpg(struct net_device *netdev, struct cee_pg *pg)\n{\n\tint i;\n\tstruct bnx2x *bp = netdev_priv(netdev);\n\n\tpg->willing = (bp->dcbx_remote_flags & DCBX_ETS_REM_WILLING) ?: 0;\n\n\tfor (i = 0; i < CEE_DCBX_MAX_PGS; i++) {\n\t\tpg->pg_bw[i] =\n\t\t\tDCBX_PG_BW_GET(bp->dcbx_remote_feat.ets.pg_bw_tbl, i);\n\t\tpg->prio_pg[i] =\n\t\t\tDCBX_PRI_PG_GET(bp->dcbx_remote_feat.ets.pri_pg_tbl, i);\n\t}\n\treturn 0;\n}\n\nstatic int bnx2x_cee_peer_getpfc(struct net_device *netdev,\n\t\t\t\t struct cee_pfc *pfc)\n{\n\tstruct bnx2x *bp = netdev_priv(netdev);\n\tpfc->tcs_supported = bp->dcbx_remote_feat.pfc.pfc_caps;\n\tpfc->pfc_en = bp->dcbx_remote_feat.pfc.pri_en_bitmap;\n\treturn 0;\n}\n\nconst struct dcbnl_rtnl_ops bnx2x_dcbnl_ops = {\n\t.getstate\t\t= bnx2x_dcbnl_get_state,\n\t.setstate\t\t= bnx2x_dcbnl_set_state,\n\t.getpermhwaddr\t\t= bnx2x_dcbnl_get_perm_hw_addr,\n\t.setpgtccfgtx\t\t= bnx2x_dcbnl_set_pg_tccfg_tx,\n\t.setpgbwgcfgtx\t\t= bnx2x_dcbnl_set_pg_bwgcfg_tx,\n\t.setpgtccfgrx\t\t= bnx2x_dcbnl_set_pg_tccfg_rx,\n\t.setpgbwgcfgrx\t\t= bnx2x_dcbnl_set_pg_bwgcfg_rx,\n\t.getpgtccfgtx\t\t= bnx2x_dcbnl_get_pg_tccfg_tx,\n\t.getpgbwgcfgtx\t\t= bnx2x_dcbnl_get_pg_bwgcfg_tx,\n\t.getpgtccfgrx\t\t= bnx2x_dcbnl_get_pg_tccfg_rx,\n\t.getpgbwgcfgrx\t\t= bnx2x_dcbnl_get_pg_bwgcfg_rx,\n\t.setpfccfg\t\t= bnx2x_dcbnl_set_pfc_cfg,\n\t.getpfccfg\t\t= bnx2x_dcbnl_get_pfc_cfg,\n\t.setall\t\t\t= bnx2x_dcbnl_set_all,\n\t.getcap\t\t\t= bnx2x_dcbnl_get_cap,\n\t.getnumtcs\t\t= bnx2x_dcbnl_get_numtcs,\n\t.setnumtcs\t\t= bnx2x_dcbnl_set_numtcs,\n\t.getpfcstate\t\t= bnx2x_dcbnl_get_pfc_state,\n\t.setpfcstate\t\t= bnx2x_dcbnl_set_pfc_state,\n\t.setapp\t\t\t= bnx2x_dcbnl_set_app_up,\n\t.getdcbx\t\t= bnx2x_dcbnl_get_dcbx,\n\t.setdcbx\t\t= bnx2x_dcbnl_set_dcbx,\n\t.getfeatcfg\t\t= bnx2x_dcbnl_get_featcfg,\n\t.setfeatcfg\t\t= bnx2x_dcbnl_set_featcfg,\n\t.peer_getappinfo\t= bnx2x_peer_appinfo,\n\t.peer_getapptable\t= bnx2x_peer_apptable,\n\t.cee_peer_getpg\t\t= bnx2x_cee_peer_getpg,\n\t.cee_peer_getpfc\t= bnx2x_cee_peer_getpfc,\n};\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}