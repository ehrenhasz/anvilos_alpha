{
  "module_name": "bnx2x.h",
  "hash_id": "bd0165f26a03b5b662e7d98561ce81a08c8dd10d3cc9411b1755f6a9d01f4fb4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/broadcom/bnx2x/bnx2x.h",
  "human_readable_source": " \n\n#ifndef BNX2X_H\n#define BNX2X_H\n\n#include <linux/pci.h>\n#include <linux/netdevice.h>\n#include <linux/dma-mapping.h>\n#include <linux/types.h>\n#include <linux/pci_regs.h>\n\n#include <linux/ptp_clock_kernel.h>\n#include <linux/net_tstamp.h>\n#include <linux/timecounter.h>\n\n \n\n \n \n\n \n#define DRV_MODULE_VERSION      \"1.713.36-0\"\n#define BNX2X_BC_VER            0x040200\n\n#if defined(CONFIG_DCB)\n#define BCM_DCBNL\n#endif\n\n#include \"bnx2x_hsi.h\"\n\n#include \"../cnic_if.h\"\n\n#define BNX2X_MIN_MSIX_VEC_CNT(bp)\t\t((bp)->min_msix_vec_cnt)\n\n#include <linux/mdio.h>\n\n#include \"bnx2x_reg.h\"\n#include \"bnx2x_fw_defs.h\"\n#include \"bnx2x_mfw_req.h\"\n#include \"bnx2x_link.h\"\n#include \"bnx2x_sp.h\"\n#include \"bnx2x_dcb.h\"\n#include \"bnx2x_stats.h\"\n#include \"bnx2x_vfpf.h\"\n\nenum bnx2x_int_mode {\n\tBNX2X_INT_MODE_MSIX,\n\tBNX2X_INT_MODE_INTX,\n\tBNX2X_INT_MODE_MSI\n};\n\n \n\n#define DRV_MODULE_NAME\t\t\"bnx2x\"\n\n \n#define BNX2X_MSG_OFF\t\t\t0x0\n#define BNX2X_MSG_MCP\t\t\t0x0010000  \n#define BNX2X_MSG_STATS\t\t\t0x0020000  \n#define BNX2X_MSG_NVM\t\t\t0x0040000  \n#define BNX2X_MSG_DMAE\t\t\t0x0080000  \n#define BNX2X_MSG_SP\t\t\t0x0100000  \n#define BNX2X_MSG_FP\t\t\t0x0200000  \n#define BNX2X_MSG_IOV\t\t\t0x0800000\n#define BNX2X_MSG_PTP\t\t\t0x1000000\n#define BNX2X_MSG_IDLE\t\t\t0x2000000  \n#define BNX2X_MSG_ETHTOOL\t\t0x4000000\n#define BNX2X_MSG_DCB\t\t\t0x8000000\n\n \n#define DP_INNER(fmt, ...)\t\t\t\t\t\\\n\tpr_notice(\"[%s:%d(%s)]\" fmt,\t\t\t\t\\\n\t\t  __func__, __LINE__,\t\t\t\t\\\n\t\t  bp->dev ? (bp->dev->name) : \"?\",\t\t\\\n\t\t  ##__VA_ARGS__);\n\n#define DP(__mask, fmt, ...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tif (unlikely(bp->msg_enable & (__mask)))\t\t\\\n\t\tDP_INNER(fmt, ##__VA_ARGS__);\t\t\t\\\n} while (0)\n\n#define DP_AND(__mask, fmt, ...)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tif (unlikely((bp->msg_enable & (__mask)) == __mask))\t\\\n\t\tDP_INNER(fmt, ##__VA_ARGS__);\t\t\t\\\n} while (0)\n\n#define DP_CONT(__mask, fmt, ...)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tif (unlikely(bp->msg_enable & (__mask)))\t\t\\\n\t\tpr_cont(fmt, ##__VA_ARGS__);\t\t\t\\\n} while (0)\n\n \n#define BNX2X_DBG_ERR(fmt, ...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tif (unlikely(netif_msg_probe(bp)))\t\t\t\\\n\t\tpr_err(\"[%s:%d(%s)]\" fmt,\t\t\t\\\n\t\t       __func__, __LINE__,\t\t\t\\\n\t\t       bp->dev ? (bp->dev->name) : \"?\",\t\t\\\n\t\t       ##__VA_ARGS__);\t\t\t\t\\\n} while (0)\n\n \n#define BNX2X_ERR(fmt, ...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tpr_err(\"[%s:%d(%s)]\" fmt,\t\t\t\t\\\n\t       __func__, __LINE__,\t\t\t\t\\\n\t       bp->dev ? (bp->dev->name) : \"?\",\t\t\t\\\n\t       ##__VA_ARGS__);\t\t\t\t\t\\\n} while (0)\n\n#define BNX2X_ERROR(fmt, ...)\t\t\t\t\t\\\n\tpr_err(\"[%s:%d]\" fmt, __func__, __LINE__, ##__VA_ARGS__)\n\n \n#define BNX2X_DEV_INFO(fmt, ...)\t\t\t\t \\\ndo {\t\t\t\t\t\t\t\t \\\n\tif (unlikely(netif_msg_probe(bp)))\t\t\t \\\n\t\tdev_info(&bp->pdev->dev, fmt, ##__VA_ARGS__);\t \\\n} while (0)\n\n \nvoid bnx2x_panic_dump(struct bnx2x *bp, bool disable_int);\n#ifdef BNX2X_STOP_ON_ERROR\n#define bnx2x_panic()\t\t\t\t\\\ndo {\t\t\t\t\t\t\\\n\tbp->panic = 1;\t\t\t\t\\\n\tBNX2X_ERR(\"driver assert\\n\");\t\t\\\n\tbnx2x_panic_dump(bp, true);\t\t\\\n} while (0)\n#else\n#define bnx2x_panic()\t\t\t\t\\\ndo {\t\t\t\t\t\t\\\n\tbp->panic = 1;\t\t\t\t\\\n\tBNX2X_ERR(\"driver assert\\n\");\t\t\\\n\tbnx2x_panic_dump(bp, false);\t\t\\\n} while (0)\n#endif\n\n#define bnx2x_mc_addr(ha)      ((ha)->addr)\n#define bnx2x_uc_addr(ha)      ((ha)->addr)\n\n#define U64_LO(x)\t\t\t((u32)(((u64)(x)) & 0xffffffff))\n#define U64_HI(x)\t\t\t((u32)(((u64)(x)) >> 32))\n#define HILO_U64(hi, lo)\t\t((((u64)(hi)) << 32) + (lo))\n\n#define REG_ADDR(bp, offset)\t\t((bp->regview) + (offset))\n\n#define REG_RD(bp, offset)\t\treadl(REG_ADDR(bp, offset))\n#define REG_RD8(bp, offset)\t\treadb(REG_ADDR(bp, offset))\n#define REG_RD16(bp, offset)\t\treadw(REG_ADDR(bp, offset))\n\n#define REG_WR_RELAXED(bp, offset, val)\t\\\n\twritel_relaxed((u32)val, REG_ADDR(bp, offset))\n\n#define REG_WR16_RELAXED(bp, offset, val) \\\n\twritew_relaxed((u16)val, REG_ADDR(bp, offset))\n\n#define REG_WR(bp, offset, val)\t\twritel((u32)val, REG_ADDR(bp, offset))\n#define REG_WR8(bp, offset, val)\twriteb((u8)val, REG_ADDR(bp, offset))\n#define REG_WR16(bp, offset, val)\twritew((u16)val, REG_ADDR(bp, offset))\n\n#define REG_RD_IND(bp, offset)\t\tbnx2x_reg_rd_ind(bp, offset)\n#define REG_WR_IND(bp, offset, val)\tbnx2x_reg_wr_ind(bp, offset, val)\n\n#define REG_RD_DMAE(bp, offset, valp, len32) \\\n\tdo { \\\n\t\tbnx2x_read_dmae(bp, offset, len32);\\\n\t\tmemcpy(valp, bnx2x_sp(bp, wb_data[0]), (len32) * 4); \\\n\t} while (0)\n\n#define REG_WR_DMAE(bp, offset, valp, len32) \\\n\tdo { \\\n\t\tmemcpy(bnx2x_sp(bp, wb_data[0]), valp, (len32) * 4); \\\n\t\tbnx2x_write_dmae(bp, bnx2x_sp_mapping(bp, wb_data), \\\n\t\t\t\t offset, len32); \\\n\t} while (0)\n\n#define REG_WR_DMAE_LEN(bp, offset, valp, len32) \\\n\tREG_WR_DMAE(bp, offset, valp, len32)\n\n#define VIRT_WR_DMAE_LEN(bp, data, addr, len32, le32_swap) \\\n\tdo { \\\n\t\tmemcpy(GUNZIP_BUF(bp), data, (len32) * 4); \\\n\t\tbnx2x_write_big_buf_wb(bp, addr, len32); \\\n\t} while (0)\n\n#define SHMEM_ADDR(bp, field)\t\t(bp->common.shmem_base + \\\n\t\t\t\t\t offsetof(struct shmem_region, field))\n#define SHMEM_RD(bp, field)\t\tREG_RD(bp, SHMEM_ADDR(bp, field))\n#define SHMEM_WR(bp, field, val)\tREG_WR(bp, SHMEM_ADDR(bp, field), val)\n\n#define SHMEM2_ADDR(bp, field)\t\t(bp->common.shmem2_base + \\\n\t\t\t\t\t offsetof(struct shmem2_region, field))\n#define SHMEM2_RD(bp, field)\t\tREG_RD(bp, SHMEM2_ADDR(bp, field))\n#define SHMEM2_WR(bp, field, val)\tREG_WR(bp, SHMEM2_ADDR(bp, field), val)\n#define MF_CFG_ADDR(bp, field)\t\t(bp->common.mf_cfg_base + \\\n\t\t\t\t\t offsetof(struct mf_cfg, field))\n#define MF2_CFG_ADDR(bp, field)\t\t(bp->common.mf2_cfg_base + \\\n\t\t\t\t\t offsetof(struct mf2_cfg, field))\n\n#define MF_CFG_RD(bp, field)\t\tREG_RD(bp, MF_CFG_ADDR(bp, field))\n#define MF_CFG_WR(bp, field, val)\tREG_WR(bp,\\\n\t\t\t\t\t       MF_CFG_ADDR(bp, field), (val))\n#define MF2_CFG_RD(bp, field)\t\tREG_RD(bp, MF2_CFG_ADDR(bp, field))\n\n#define SHMEM2_HAS(bp, field)\t\t((bp)->common.shmem2_base &&\t\\\n\t\t\t\t\t (SHMEM2_RD((bp), size) >\t\\\n\t\t\t\t\t offsetof(struct shmem2_region, field)))\n\n#define EMAC_RD(bp, reg)\t\tREG_RD(bp, emac_base + reg)\n#define EMAC_WR(bp, reg, val)\t\tREG_WR(bp, emac_base + reg, val)\n\n \n\n \n#define HC_SP_INDEX_ETH_DEF_CONS\t\t3\n\n \n#define HC_SP_INDEX_EQ_CONS\t\t\t7\n\n \n#define HC_SP_INDEX_ETH_FCOE_TX_CQ_CONS\t\t6\n#define HC_SP_INDEX_ETH_FCOE_RX_CQ_CONS\t\t4\n \n#define HC_SP_INDEX_ETH_ISCSI_CQ_CONS\t\t5\n#define HC_SP_INDEX_ETH_ISCSI_RX_CQ_CONS\t1\n\n \n\n \n \n#define BNX2X_FCOE_L2_RX_INDEX \\\n\t(&bp->def_status_blk->sp_sb.\\\n\tindex_values[HC_SP_INDEX_ETH_FCOE_RX_CQ_CONS])\n\n#define BNX2X_FCOE_L2_TX_INDEX \\\n\t(&bp->def_status_blk->sp_sb.\\\n\tindex_values[HC_SP_INDEX_ETH_FCOE_TX_CQ_CONS])\n\n \nenum {\n\tBNX2X_ISCSI_ETH_CL_ID_IDX,\n\tBNX2X_FCOE_ETH_CL_ID_IDX,\n\tBNX2X_MAX_CNIC_ETH_CL_ID_IDX,\n};\n\n \n\n#define BNX2X_1st_NON_L2_ETH_CID(bp)\t(BNX2X_NUM_NON_CNIC_QUEUES(bp) * \\\n\t\t\t\t\t (bp)->max_cos)\n \n#define UIO_DPM\t\t\t\t8\n \n#define UIO_ROUNDUP(bp)\t\t\t(roundup(BNX2X_1st_NON_L2_ETH_CID(bp), \\\n\t\t\t\t\t UIO_DPM))\n \n#define UIO_CID_OFFSET(bp)\t\t((UIO_ROUNDUP(bp) + UIO_DPM) % \\\n\t\t\t\t\t (UIO_DPM * 2))\n \n#define UIO_DPM_ALIGN(bp)\t\t(UIO_ROUNDUP(bp) + UIO_CID_OFFSET(bp))\n \n#define UIO_DPM_CID0_OFFSET(bp)\t\t((UIO_DPM * 2) * \\\n\t\t\t\t\t (UIO_DPM_ALIGN(bp) == UIO_DPM))\n \n#define BNX2X_CNIC_START_ETH_CID(bp)\t(UIO_DPM_ALIGN(bp) + \\\n\t\t\t\t\t (UIO_DPM_CID0_OFFSET(bp)))\n \n#define UIO_CID_PAD(bp)\t\t\t(BNX2X_CNIC_START_ETH_CID(bp) - \\\n\t\t\t\t\t BNX2X_1st_NON_L2_ETH_CID(bp))\n\t \n#define\tBNX2X_ISCSI_ETH_CID(bp)\t\t(BNX2X_CNIC_START_ETH_CID(bp))\n\t \n#define\tBNX2X_FCOE_ETH_CID(bp)\t\t(BNX2X_CNIC_START_ETH_CID(bp) + 1)\n\n#define CNIC_SUPPORT(bp)\t\t((bp)->cnic_support)\n#define CNIC_ENABLED(bp)\t\t((bp)->cnic_enabled)\n#define CNIC_LOADED(bp)\t\t\t((bp)->cnic_loaded)\n#define FCOE_INIT(bp)\t\t\t((bp)->fcoe_init)\n\n#define AEU_IN_ATTN_BITS_PXPPCICLOCKCLIENT_PARITY_ERROR \\\n\tAEU_INPUTS_ATTN_BITS_PXPPCICLOCKCLIENT_PARITY_ERROR\n\n#define SM_RX_ID\t\t\t0\n#define SM_TX_ID\t\t\t1\n\n \n#define FIRST_TX_ONLY_COS_INDEX\t\t1\n#define FIRST_TX_COS_INDEX\t\t0\n\n \n#define CID_TO_FP(cid, bp)\t\t((cid) % BNX2X_NUM_NON_CNIC_QUEUES(bp))\n#define CID_COS_TO_TX_ONLY_CID(cid, cos, bp) \\\n\t\t\t\t(cid + cos * BNX2X_NUM_NON_CNIC_QUEUES(bp))\n\n \n#define FP_COS_TO_TXQ(fp, cos, bp) \\\n\t\t\t((fp)->index + cos * BNX2X_NUM_NON_CNIC_QUEUES(bp))\n\n \nenum {\n\tFCOE_TXQ_IDX_OFFSET,\n\tFWD_TXQ_IDX_OFFSET,\n\tOOO_TXQ_IDX_OFFSET,\n};\n#define MAX_ETH_TXQ_IDX(bp)\t(BNX2X_NUM_NON_CNIC_QUEUES(bp) * (bp)->max_cos)\n#define FCOE_TXQ_IDX(bp)\t(MAX_ETH_TXQ_IDX(bp) + FCOE_TXQ_IDX_OFFSET)\n\n \n \nstruct sw_rx_bd {\n\tu8\t\t*data;\n\tDEFINE_DMA_UNMAP_ADDR(mapping);\n};\n\nstruct sw_tx_bd {\n\tstruct sk_buff\t*skb;\n\tu16\t\tfirst_bd;\n\tu8\t\tflags;\n \n#define BNX2X_TSO_SPLIT_BD\t\t(1<<0)\n#define BNX2X_HAS_SECOND_PBD\t\t(1<<1)\n};\n\nstruct sw_rx_page {\n\tstruct page\t*page;\n\tDEFINE_DMA_UNMAP_ADDR(mapping);\n\tunsigned int\toffset;\n};\n\nunion db_prod {\n\tstruct doorbell_set_prod data;\n\tu32\t\traw;\n};\n\n \n#define BRB_SIZE(bp)\t\t(CHIP_IS_E3(bp) ? 1024 : 512)\n#define MAX_AGG_QS(bp)\t\t(CHIP_IS_E1(bp) ? \\\n\t\t\t\t\tETH_MAX_AGGREGATION_QUEUES_E1 :\\\n\t\t\t\t\tETH_MAX_AGGREGATION_QUEUES_E1H_E2)\n#define FW_DROP_LEVEL(bp)\t(3 + MAX_SPQ_PENDING + MAX_AGG_QS(bp))\n#define FW_PREFETCH_CNT\t\t16\n#define DROPLESS_FC_HEADROOM\t100\n\n \n#define BCM_PAGE_SHIFT\t\t12\n#define BCM_PAGE_SIZE\t\t(1 << BCM_PAGE_SHIFT)\n#define BCM_PAGE_MASK\t\t(~(BCM_PAGE_SIZE - 1))\n#define BCM_PAGE_ALIGN(addr)\t(((addr) + BCM_PAGE_SIZE - 1) & BCM_PAGE_MASK)\n\n#define PAGES_PER_SGE_SHIFT\t0\n#define PAGES_PER_SGE\t\t(1 << PAGES_PER_SGE_SHIFT)\n#define SGE_PAGE_SHIFT\t\t12\n#define SGE_PAGE_SIZE\t\t(1 << SGE_PAGE_SHIFT)\n#define SGE_PAGE_MASK\t\t(~(SGE_PAGE_SIZE - 1))\n#define SGE_PAGE_ALIGN(addr)\t(((addr) + SGE_PAGE_SIZE - 1) & SGE_PAGE_MASK)\n#define SGE_PAGES\t\t(SGE_PAGE_SIZE * PAGES_PER_SGE)\n#define TPA_AGG_SIZE\t\tmin_t(u32, (min_t(u32, 8, MAX_SKB_FRAGS) * \\\n\t\t\t\t\t    SGE_PAGES), 0xffff)\n\n \n#define NUM_RX_SGE_PAGES\t2\n#define RX_SGE_CNT\t\t(BCM_PAGE_SIZE / sizeof(struct eth_rx_sge))\n#define NEXT_PAGE_SGE_DESC_CNT\t2\n#define MAX_RX_SGE_CNT\t\t(RX_SGE_CNT - NEXT_PAGE_SGE_DESC_CNT)\n \n#define RX_SGE_MASK\t\t(RX_SGE_CNT - 1)\n#define NUM_RX_SGE\t\t(RX_SGE_CNT * NUM_RX_SGE_PAGES)\n#define MAX_RX_SGE\t\t(NUM_RX_SGE - 1)\n#define NEXT_SGE_IDX(x)\t\t((((x) & RX_SGE_MASK) == \\\n\t\t\t\t  (MAX_RX_SGE_CNT - 1)) ? \\\n\t\t\t\t\t(x) + 1 + NEXT_PAGE_SGE_DESC_CNT : \\\n\t\t\t\t\t(x) + 1)\n#define RX_SGE(x)\t\t((x) & MAX_RX_SGE)\n\n \n#define NUM_SGE_REQ\t\t(MAX_AGG_QS(bp) + \\\n\t\t\t\t\t(BRB_SIZE(bp) - MAX_AGG_QS(bp)) / 2)\n#define NUM_SGE_PG_REQ\t\t((NUM_SGE_REQ + MAX_RX_SGE_CNT - 1) / \\\n\t\t\t\t\t\tMAX_RX_SGE_CNT)\n#define SGE_TH_LO(bp)\t\t(NUM_SGE_REQ + \\\n\t\t\t\t NUM_SGE_PG_REQ * NEXT_PAGE_SGE_DESC_CNT)\n#define SGE_TH_HI(bp)\t\t(SGE_TH_LO(bp) + DROPLESS_FC_HEADROOM)\n\n \n\n \n#define BIT_VEC64_ELEM_SZ\t\t64\n#define BIT_VEC64_ELEM_SHIFT\t\t6\n#define BIT_VEC64_ELEM_MASK\t\t((u64)BIT_VEC64_ELEM_SZ - 1)\n\n#define __BIT_VEC64_SET_BIT(el, bit) \\\n\tdo { \\\n\t\tel = ((el) | ((u64)0x1 << (bit))); \\\n\t} while (0)\n\n#define __BIT_VEC64_CLEAR_BIT(el, bit) \\\n\tdo { \\\n\t\tel = ((el) & (~((u64)0x1 << (bit)))); \\\n\t} while (0)\n\n#define BIT_VEC64_SET_BIT(vec64, idx) \\\n\t__BIT_VEC64_SET_BIT((vec64)[(idx) >> BIT_VEC64_ELEM_SHIFT], \\\n\t\t\t   (idx) & BIT_VEC64_ELEM_MASK)\n\n#define BIT_VEC64_CLEAR_BIT(vec64, idx) \\\n\t__BIT_VEC64_CLEAR_BIT((vec64)[(idx) >> BIT_VEC64_ELEM_SHIFT], \\\n\t\t\t     (idx) & BIT_VEC64_ELEM_MASK)\n\n#define BIT_VEC64_TEST_BIT(vec64, idx) \\\n\t(((vec64)[(idx) >> BIT_VEC64_ELEM_SHIFT] >> \\\n\t((idx) & BIT_VEC64_ELEM_MASK)) & 0x1)\n\n \n#define BIT_VEC64_ONES_MASK(idx) \\\n\t\t(((u64)0x1 << (((idx) & BIT_VEC64_ELEM_MASK) + 1)) - 1)\n#define BIT_VEC64_ELEM_ONE_MASK\t((u64)(~0))\n\n \n\n \n#define RX_SGE_MASK_LEN\t\t\t(NUM_RX_SGE / BIT_VEC64_ELEM_SZ)\n#define RX_SGE_MASK_LEN_MASK\t\t(RX_SGE_MASK_LEN - 1)\n#define NEXT_SGE_MASK_ELEM(el)\t\t(((el) + 1) & RX_SGE_MASK_LEN_MASK)\n\nunion host_hc_status_block {\n\t \n\tstruct host_hc_status_block_e1x *e1x_sb;\n\t \n\tstruct host_hc_status_block_e2  *e2_sb;\n};\n\nstruct bnx2x_agg_info {\n\t \n\tstruct sw_rx_bd\t\tfirst_buf;\n\tu8\t\t\ttpa_state;\n#define BNX2X_TPA_START\t\t\t1\n#define BNX2X_TPA_STOP\t\t\t2\n#define BNX2X_TPA_ERROR\t\t\t3\n\tu8\t\t\tplacement_offset;\n\tu16\t\t\tparsing_flags;\n\tu16\t\t\tvlan_tag;\n\tu16\t\t\tlen_on_bd;\n\tu32\t\t\trxhash;\n\tenum pkt_hash_types\trxhash_type;\n\tu16\t\t\tgro_size;\n\tu16\t\t\tfull_page;\n};\n\n#define Q_STATS_OFFSET32(stat_name) \\\n\t\t\t(offsetof(struct bnx2x_eth_q_stats, stat_name) / 4)\n\nstruct bnx2x_fp_txdata {\n\n\tstruct sw_tx_bd\t\t*tx_buf_ring;\n\n\tunion eth_tx_bd_types\t*tx_desc_ring;\n\tdma_addr_t\t\ttx_desc_mapping;\n\n\tu32\t\t\tcid;\n\n\tunion db_prod\t\ttx_db;\n\n\tu16\t\t\ttx_pkt_prod;\n\tu16\t\t\ttx_pkt_cons;\n\tu16\t\t\ttx_bd_prod;\n\tu16\t\t\ttx_bd_cons;\n\n\tunsigned long\t\ttx_pkt;\n\n\t__le16\t\t\t*tx_cons_sb;\n\n\tint\t\t\ttxq_index;\n\tstruct bnx2x_fastpath\t*parent_fp;\n\tint\t\t\ttx_ring_size;\n};\n\nenum bnx2x_tpa_mode_t {\n\tTPA_MODE_DISABLED,\n\tTPA_MODE_LRO,\n\tTPA_MODE_GRO\n};\n\nstruct bnx2x_alloc_pool {\n\tstruct page\t*page;\n\tunsigned int\toffset;\n};\n\nstruct bnx2x_fastpath {\n\tstruct bnx2x\t\t*bp;  \n\n\tstruct napi_struct\tnapi;\n\n\tunion host_hc_status_block\tstatus_blk;\n\t \n\t__le16\t\t\t*sb_index_values;\n\t__le16\t\t\t*sb_running_index;\n\t \n\tu32\t\t\tustorm_rx_prods_offset;\n\n\tu32\t\t\trx_buf_size;\n\tu32\t\t\trx_frag_size;  \n\tdma_addr_t\t\tstatus_blk_mapping;\n\n\tenum bnx2x_tpa_mode_t\tmode;\n\n\tu8\t\t\tmax_cos;  \n\tstruct bnx2x_fp_txdata\t*txdata_ptr[BNX2X_MULTI_TX_COS];\n\n\tstruct sw_rx_bd\t\t*rx_buf_ring;\t \n\tstruct sw_rx_page\t*rx_page_ring;\t \n\n\tstruct eth_rx_bd\t*rx_desc_ring;\n\tdma_addr_t\t\trx_desc_mapping;\n\n\tunion eth_rx_cqe\t*rx_comp_ring;\n\tdma_addr_t\t\trx_comp_mapping;\n\n\t \n\tstruct eth_rx_sge\t*rx_sge_ring;\n\tdma_addr_t\t\trx_sge_mapping;\n\n\tu64\t\t\tsge_mask[RX_SGE_MASK_LEN];\n\n\tu32\t\t\tcid;\n\n\t__le16\t\t\tfp_hc_idx;\n\n\tu8\t\t\tindex;\t\t \n\tu8\t\t\trx_queue;\t \n\tu8\t\t\tcl_id;\t\t \n\tu8\t\t\tcl_qzone_id;\n\tu8\t\t\tfw_sb_id;\t \n\tu8\t\t\tigu_sb_id;\t \n\n\tu16\t\t\trx_bd_prod;\n\tu16\t\t\trx_bd_cons;\n\tu16\t\t\trx_comp_prod;\n\tu16\t\t\trx_comp_cons;\n\tu16\t\t\trx_sge_prod;\n\t \n\tu16\t\t\tlast_max_sge;\n\t__le16\t\t\t*rx_cons_sb;\n\n\t \n\tstruct bnx2x_agg_info\t*tpa_info;\n#ifdef BNX2X_STOP_ON_ERROR\n\tu64\t\t\ttpa_queue_used;\n#endif\n\t \n#define FP_NAME_SIZE\t\t(sizeof(((struct net_device *)0)->name) + 8)\n\tchar\t\t\tname[FP_NAME_SIZE];\n\n\tstruct bnx2x_alloc_pool\tpage_pool;\n};\n\n#define bnx2x_fp(bp, nr, var)\t((bp)->fp[(nr)].var)\n#define bnx2x_sp_obj(bp, fp)\t((bp)->sp_objs[(fp)->index])\n#define bnx2x_fp_stats(bp, fp)\t(&((bp)->fp_stats[(fp)->index]))\n#define bnx2x_fp_qstats(bp, fp)\t(&((bp)->fp_stats[(fp)->index].eth_q_stats))\n\n \n#define BNX2X_FCOE_MINI_JUMBO_MTU\t2500\n\n#define\tFCOE_IDX_OFFSET\t\t0\n\n#define FCOE_IDX(bp)\t\t(BNX2X_NUM_NON_CNIC_QUEUES(bp) + \\\n\t\t\t\t FCOE_IDX_OFFSET)\n#define bnx2x_fcoe_fp(bp)\t(&bp->fp[FCOE_IDX(bp)])\n#define bnx2x_fcoe(bp, var)\t(bnx2x_fcoe_fp(bp)->var)\n#define bnx2x_fcoe_inner_sp_obj(bp)\t(&bp->sp_objs[FCOE_IDX(bp)])\n#define bnx2x_fcoe_sp_obj(bp, var)\t(bnx2x_fcoe_inner_sp_obj(bp)->var)\n#define bnx2x_fcoe_tx(bp, var)\t(bnx2x_fcoe_fp(bp)-> \\\n\t\t\t\t\t\ttxdata_ptr[FIRST_TX_COS_INDEX] \\\n\t\t\t\t\t\t->var)\n\n#define IS_ETH_FP(fp)\t\t((fp)->index < BNX2X_NUM_ETH_QUEUES((fp)->bp))\n#define IS_FCOE_FP(fp)\t\t((fp)->index == FCOE_IDX((fp)->bp))\n#define IS_FCOE_IDX(idx)\t((idx) == FCOE_IDX(bp))\n\n \n#define MAX_FETCH_BD\t\t13\t \n#define RX_COPY_THRESH\t\t92\n\n#define NUM_TX_RINGS\t\t16\n#define TX_DESC_CNT\t\t(BCM_PAGE_SIZE / sizeof(union eth_tx_bd_types))\n#define NEXT_PAGE_TX_DESC_CNT\t1\n#define MAX_TX_DESC_CNT\t\t(TX_DESC_CNT - NEXT_PAGE_TX_DESC_CNT)\n#define NUM_TX_BD\t\t(TX_DESC_CNT * NUM_TX_RINGS)\n#define MAX_TX_BD\t\t(NUM_TX_BD - 1)\n#define MAX_TX_AVAIL\t\t(MAX_TX_DESC_CNT * NUM_TX_RINGS - 2)\n#define NEXT_TX_IDX(x)\t\t((((x) & MAX_TX_DESC_CNT) == \\\n\t\t\t\t  (MAX_TX_DESC_CNT - 1)) ? \\\n\t\t\t\t\t(x) + 1 + NEXT_PAGE_TX_DESC_CNT : \\\n\t\t\t\t\t(x) + 1)\n#define TX_BD(x)\t\t((x) & MAX_TX_BD)\n#define TX_BD_POFF(x)\t\t((x) & MAX_TX_DESC_CNT)\n\n \n#define NEXT_CNT_PER_TX_PKT(bds)\t\\\n\t\t\t\t(((bds) + MAX_TX_DESC_CNT - 1) / \\\n\t\t\t\t MAX_TX_DESC_CNT * NEXT_PAGE_TX_DESC_CNT)\n \n#define BDS_PER_TX_PKT\t\t4\n#define MAX_BDS_PER_TX_PKT\t(MAX_SKB_FRAGS + BDS_PER_TX_PKT)\n \n#define MAX_DESC_PER_TX_PKT\t(MAX_BDS_PER_TX_PKT + \\\n\t\t\t\t NEXT_CNT_PER_TX_PKT(MAX_BDS_PER_TX_PKT))\n\n \n#define NUM_RX_RINGS\t\t8\n#define RX_DESC_CNT\t\t(BCM_PAGE_SIZE / sizeof(struct eth_rx_bd))\n#define NEXT_PAGE_RX_DESC_CNT\t2\n#define MAX_RX_DESC_CNT\t\t(RX_DESC_CNT - NEXT_PAGE_RX_DESC_CNT)\n#define RX_DESC_MASK\t\t(RX_DESC_CNT - 1)\n#define NUM_RX_BD\t\t(RX_DESC_CNT * NUM_RX_RINGS)\n#define MAX_RX_BD\t\t(NUM_RX_BD - 1)\n#define MAX_RX_AVAIL\t\t(MAX_RX_DESC_CNT * NUM_RX_RINGS - 2)\n\n \n#define NUM_BD_REQ\t\tBRB_SIZE(bp)\n#define NUM_BD_PG_REQ\t\t((NUM_BD_REQ + MAX_RX_DESC_CNT - 1) / \\\n\t\t\t\t\t      MAX_RX_DESC_CNT)\n#define BD_TH_LO(bp)\t\t(NUM_BD_REQ + \\\n\t\t\t\t NUM_BD_PG_REQ * NEXT_PAGE_RX_DESC_CNT + \\\n\t\t\t\t FW_DROP_LEVEL(bp))\n#define BD_TH_HI(bp)\t\t(BD_TH_LO(bp) + DROPLESS_FC_HEADROOM)\n\n#define MIN_RX_AVAIL\t\t((bp)->dropless_fc ? BD_TH_HI(bp) + 128 : 128)\n\n#define MIN_RX_SIZE_TPA_HW\t(CHIP_IS_E1(bp) ? \\\n\t\t\t\t\tETH_MIN_RX_CQES_WITH_TPA_E1 : \\\n\t\t\t\t\tETH_MIN_RX_CQES_WITH_TPA_E1H_E2)\n#define MIN_RX_SIZE_NONTPA_HW   ETH_MIN_RX_CQES_WITHOUT_TPA\n#define MIN_RX_SIZE_TPA\t\t(max_t(u32, MIN_RX_SIZE_TPA_HW, MIN_RX_AVAIL))\n#define MIN_RX_SIZE_NONTPA\t(max_t(u32, MIN_RX_SIZE_NONTPA_HW,\\\n\t\t\t\t\t\t\t\tMIN_RX_AVAIL))\n\n#define NEXT_RX_IDX(x)\t\t((((x) & RX_DESC_MASK) == \\\n\t\t\t\t  (MAX_RX_DESC_CNT - 1)) ? \\\n\t\t\t\t\t(x) + 1 + NEXT_PAGE_RX_DESC_CNT : \\\n\t\t\t\t\t(x) + 1)\n#define RX_BD(x)\t\t((x) & MAX_RX_BD)\n\n \n#define CQE_BD_REL\t(sizeof(union eth_rx_cqe) / sizeof(struct eth_rx_bd))\n#define NUM_RCQ_RINGS\t\t(NUM_RX_RINGS * CQE_BD_REL)\n#define RCQ_DESC_CNT\t\t(BCM_PAGE_SIZE / sizeof(union eth_rx_cqe))\n#define NEXT_PAGE_RCQ_DESC_CNT\t1\n#define MAX_RCQ_DESC_CNT\t(RCQ_DESC_CNT - NEXT_PAGE_RCQ_DESC_CNT)\n#define NUM_RCQ_BD\t\t(RCQ_DESC_CNT * NUM_RCQ_RINGS)\n#define MAX_RCQ_BD\t\t(NUM_RCQ_BD - 1)\n#define MAX_RCQ_AVAIL\t\t(MAX_RCQ_DESC_CNT * NUM_RCQ_RINGS - 2)\n#define NEXT_RCQ_IDX(x)\t\t((((x) & MAX_RCQ_DESC_CNT) == \\\n\t\t\t\t  (MAX_RCQ_DESC_CNT - 1)) ? \\\n\t\t\t\t\t(x) + 1 + NEXT_PAGE_RCQ_DESC_CNT : \\\n\t\t\t\t\t(x) + 1)\n#define RCQ_BD(x)\t\t((x) & MAX_RCQ_BD)\n\n \n#define NUM_RCQ_REQ\t\tBRB_SIZE(bp)\n#define NUM_RCQ_PG_REQ\t\t((NUM_BD_REQ + MAX_RCQ_DESC_CNT - 1) / \\\n\t\t\t\t\t      MAX_RCQ_DESC_CNT)\n#define RCQ_TH_LO(bp)\t\t(NUM_RCQ_REQ + \\\n\t\t\t\t NUM_RCQ_PG_REQ * NEXT_PAGE_RCQ_DESC_CNT + \\\n\t\t\t\t FW_DROP_LEVEL(bp))\n#define RCQ_TH_HI(bp)\t\t(RCQ_TH_LO(bp) + DROPLESS_FC_HEADROOM)\n\n \n#define SUB_S16(a, b)\t\t(s16)((s16)(a) - (s16)(b))\n#define SUB_S32(a, b)\t\t(s32)((s32)(a) - (s32)(b))\n\n#define BNX2X_SWCID_SHIFT\t17\n#define BNX2X_SWCID_MASK\t((0x1 << BNX2X_SWCID_SHIFT) - 1)\n\n \n#define SW_CID(x)\t\t\t(le32_to_cpu(x) & BNX2X_SWCID_MASK)\n#define CQE_CMD(x)\t\t\t(le32_to_cpu(x) >> \\\n\t\t\t\t\tCOMMON_RAMROD_ETH_RX_CQE_CMD_ID_SHIFT)\n\n#define BD_UNMAP_ADDR(bd)\t\tHILO_U64(le32_to_cpu((bd)->addr_hi), \\\n\t\t\t\t\t\t le32_to_cpu((bd)->addr_lo))\n#define BD_UNMAP_LEN(bd)\t\t(le16_to_cpu((bd)->nbytes))\n\n#define BNX2X_DB_MIN_SHIFT\t\t3\t \n#define BNX2X_DB_SHIFT\t\t\t3\t \n#if (BNX2X_DB_SHIFT < BNX2X_DB_MIN_SHIFT)\n#error \"Min DB doorbell stride is 8\"\n#endif\n#define DOORBELL_RELAXED(bp, cid, val) \\\n\twritel_relaxed((u32)(val), (bp)->doorbells + ((bp)->db_size * (cid)))\n\n \n#define SKB_CS_OFF(skb)\t\t(offsetof(struct tcphdr, check) - \\\n\t\t\t\t skb->csum_offset)\n#define SKB_CS(skb)\t\t(*(u16 *)(skb_transport_header(skb) + \\\n\t\t\t\t\t  skb->csum_offset))\n\n#define pbd_tcp_flags(tcp_hdr)\t(ntohl(tcp_flag_word(tcp_hdr))>>16 & 0xff)\n\n#define XMIT_PLAIN\t\t0\n#define XMIT_CSUM_V4\t\t(1 << 0)\n#define XMIT_CSUM_V6\t\t(1 << 1)\n#define XMIT_CSUM_TCP\t\t(1 << 2)\n#define XMIT_GSO_V4\t\t(1 << 3)\n#define XMIT_GSO_V6\t\t(1 << 4)\n#define XMIT_CSUM_ENC_V4\t(1 << 5)\n#define XMIT_CSUM_ENC_V6\t(1 << 6)\n#define XMIT_GSO_ENC_V4\t\t(1 << 7)\n#define XMIT_GSO_ENC_V6\t\t(1 << 8)\n\n#define XMIT_CSUM_ENC\t\t(XMIT_CSUM_ENC_V4 | XMIT_CSUM_ENC_V6)\n#define XMIT_GSO_ENC\t\t(XMIT_GSO_ENC_V4 | XMIT_GSO_ENC_V6)\n\n#define XMIT_CSUM\t\t(XMIT_CSUM_V4 | XMIT_CSUM_V6 | XMIT_CSUM_ENC)\n#define XMIT_GSO\t\t(XMIT_GSO_V4 | XMIT_GSO_V6 | XMIT_GSO_ENC)\n\n \n#define CQE_TYPE(cqe_fp_flags)\t ((cqe_fp_flags) & ETH_FAST_PATH_RX_CQE_TYPE)\n#define CQE_TYPE_START(cqe_type) ((cqe_type) == RX_ETH_CQE_TYPE_ETH_START_AGG)\n#define CQE_TYPE_STOP(cqe_type)  ((cqe_type) == RX_ETH_CQE_TYPE_ETH_STOP_AGG)\n#define CQE_TYPE_SLOW(cqe_type)  ((cqe_type) == RX_ETH_CQE_TYPE_ETH_RAMROD)\n#define CQE_TYPE_FAST(cqe_type)  ((cqe_type) == RX_ETH_CQE_TYPE_ETH_FASTPATH)\n\n#define ETH_RX_ERROR_FALGS\t\tETH_FAST_PATH_RX_CQE_PHY_DECODE_ERR_FLG\n\n#define BNX2X_PRS_FLAG_OVERETH_IPV4(flags) \\\n\t\t\t\t(((le16_to_cpu(flags) & \\\n\t\t\t\t   PARSING_FLAGS_OVER_ETHERNET_PROTOCOL) >> \\\n\t\t\t\t  PARSING_FLAGS_OVER_ETHERNET_PROTOCOL_SHIFT) \\\n\t\t\t\t == PRS_FLAG_OVERETH_IPV4)\n#define BNX2X_RX_SUM_FIX(cqe) \\\n\tBNX2X_PRS_FLAG_OVERETH_IPV4(cqe->fast_path_cqe.pars_flags.flags)\n\n#define FP_USB_FUNC_OFF\t\\\n\t\t\toffsetof(struct cstorm_status_block_u, func)\n#define FP_CSB_FUNC_OFF\t\\\n\t\t\toffsetof(struct cstorm_status_block_c, func)\n\n#define HC_INDEX_ETH_RX_CQ_CONS\t\t1\n\n#define HC_INDEX_OOO_TX_CQ_CONS\t\t4\n\n#define HC_INDEX_ETH_TX_CQ_CONS_COS0\t5\n\n#define HC_INDEX_ETH_TX_CQ_CONS_COS1\t6\n\n#define HC_INDEX_ETH_TX_CQ_CONS_COS2\t7\n\n#define HC_INDEX_ETH_FIRST_TX_CQ_CONS\tHC_INDEX_ETH_TX_CQ_CONS_COS0\n\n#define BNX2X_RX_SB_INDEX \\\n\t(&fp->sb_index_values[HC_INDEX_ETH_RX_CQ_CONS])\n\n#define BNX2X_TX_SB_INDEX_BASE BNX2X_TX_SB_INDEX_COS0\n\n#define BNX2X_TX_SB_INDEX_COS0 \\\n\t(&fp->sb_index_values[HC_INDEX_ETH_TX_CQ_CONS_COS0])\n\n \n\n \n\nstruct bnx2x_common {\n\n\tu32\t\t\tchip_id;\n \n#define CHIP_ID(bp)\t\t\t(bp->common.chip_id & 0xfffffff0)\n\n#define CHIP_NUM(bp)\t\t\t(bp->common.chip_id >> 16)\n#define CHIP_NUM_57710\t\t\t0x164e\n#define CHIP_NUM_57711\t\t\t0x164f\n#define CHIP_NUM_57711E\t\t\t0x1650\n#define CHIP_NUM_57712\t\t\t0x1662\n#define CHIP_NUM_57712_MF\t\t0x1663\n#define CHIP_NUM_57712_VF\t\t0x166f\n#define CHIP_NUM_57713\t\t\t0x1651\n#define CHIP_NUM_57713E\t\t\t0x1652\n#define CHIP_NUM_57800\t\t\t0x168a\n#define CHIP_NUM_57800_MF\t\t0x16a5\n#define CHIP_NUM_57800_VF\t\t0x16a9\n#define CHIP_NUM_57810\t\t\t0x168e\n#define CHIP_NUM_57810_MF\t\t0x16ae\n#define CHIP_NUM_57810_VF\t\t0x16af\n#define CHIP_NUM_57811\t\t\t0x163d\n#define CHIP_NUM_57811_MF\t\t0x163e\n#define CHIP_NUM_57811_VF\t\t0x163f\n#define CHIP_NUM_57840_OBSOLETE\t\t0x168d\n#define CHIP_NUM_57840_MF_OBSOLETE\t0x16ab\n#define CHIP_NUM_57840_4_10\t\t0x16a1\n#define CHIP_NUM_57840_2_20\t\t0x16a2\n#define CHIP_NUM_57840_MF\t\t0x16a4\n#define CHIP_NUM_57840_VF\t\t0x16ad\n#define CHIP_IS_E1(bp)\t\t\t(CHIP_NUM(bp) == CHIP_NUM_57710)\n#define CHIP_IS_57711(bp)\t\t(CHIP_NUM(bp) == CHIP_NUM_57711)\n#define CHIP_IS_57711E(bp)\t\t(CHIP_NUM(bp) == CHIP_NUM_57711E)\n#define CHIP_IS_57712(bp)\t\t(CHIP_NUM(bp) == CHIP_NUM_57712)\n#define CHIP_IS_57712_VF(bp)\t\t(CHIP_NUM(bp) == CHIP_NUM_57712_VF)\n#define CHIP_IS_57712_MF(bp)\t\t(CHIP_NUM(bp) == CHIP_NUM_57712_MF)\n#define CHIP_IS_57800(bp)\t\t(CHIP_NUM(bp) == CHIP_NUM_57800)\n#define CHIP_IS_57800_MF(bp)\t\t(CHIP_NUM(bp) == CHIP_NUM_57800_MF)\n#define CHIP_IS_57800_VF(bp)\t\t(CHIP_NUM(bp) == CHIP_NUM_57800_VF)\n#define CHIP_IS_57810(bp)\t\t(CHIP_NUM(bp) == CHIP_NUM_57810)\n#define CHIP_IS_57810_MF(bp)\t\t(CHIP_NUM(bp) == CHIP_NUM_57810_MF)\n#define CHIP_IS_57810_VF(bp)\t\t(CHIP_NUM(bp) == CHIP_NUM_57810_VF)\n#define CHIP_IS_57811(bp)\t\t(CHIP_NUM(bp) == CHIP_NUM_57811)\n#define CHIP_IS_57811_MF(bp)\t\t(CHIP_NUM(bp) == CHIP_NUM_57811_MF)\n#define CHIP_IS_57811_VF(bp)\t\t(CHIP_NUM(bp) == CHIP_NUM_57811_VF)\n#define CHIP_IS_57840(bp)\t\t\\\n\t\t((CHIP_NUM(bp) == CHIP_NUM_57840_4_10) || \\\n\t\t (CHIP_NUM(bp) == CHIP_NUM_57840_2_20) || \\\n\t\t (CHIP_NUM(bp) == CHIP_NUM_57840_OBSOLETE))\n#define CHIP_IS_57840_MF(bp)\t((CHIP_NUM(bp) == CHIP_NUM_57840_MF) || \\\n\t\t\t\t (CHIP_NUM(bp) == CHIP_NUM_57840_MF_OBSOLETE))\n#define CHIP_IS_57840_VF(bp)\t\t(CHIP_NUM(bp) == CHIP_NUM_57840_VF)\n#define CHIP_IS_E1H(bp)\t\t\t(CHIP_IS_57711(bp) || \\\n\t\t\t\t\t CHIP_IS_57711E(bp))\n#define CHIP_IS_57811xx(bp)\t\t(CHIP_IS_57811(bp) || \\\n\t\t\t\t\t CHIP_IS_57811_MF(bp) || \\\n\t\t\t\t\t CHIP_IS_57811_VF(bp))\n#define CHIP_IS_E2(bp)\t\t\t(CHIP_IS_57712(bp) || \\\n\t\t\t\t\t CHIP_IS_57712_MF(bp) || \\\n\t\t\t\t\t CHIP_IS_57712_VF(bp))\n#define CHIP_IS_E3(bp)\t\t\t(CHIP_IS_57800(bp) || \\\n\t\t\t\t\t CHIP_IS_57800_MF(bp) || \\\n\t\t\t\t\t CHIP_IS_57800_VF(bp) || \\\n\t\t\t\t\t CHIP_IS_57810(bp) || \\\n\t\t\t\t\t CHIP_IS_57810_MF(bp) || \\\n\t\t\t\t\t CHIP_IS_57810_VF(bp) || \\\n\t\t\t\t\t CHIP_IS_57811xx(bp) || \\\n\t\t\t\t\t CHIP_IS_57840(bp) || \\\n\t\t\t\t\t CHIP_IS_57840_MF(bp) || \\\n\t\t\t\t\t CHIP_IS_57840_VF(bp))\n#define CHIP_IS_E1x(bp)\t\t\t(CHIP_IS_E1((bp)) || CHIP_IS_E1H((bp)))\n#define USES_WARPCORE(bp)\t\t(CHIP_IS_E3(bp))\n#define IS_E1H_OFFSET\t\t\t(!CHIP_IS_E1(bp))\n\n#define CHIP_REV_SHIFT\t\t\t12\n#define CHIP_REV_MASK\t\t\t(0xF << CHIP_REV_SHIFT)\n#define CHIP_REV_VAL(bp)\t\t(bp->common.chip_id & CHIP_REV_MASK)\n#define CHIP_REV_Ax\t\t\t(0x0 << CHIP_REV_SHIFT)\n#define CHIP_REV_Bx\t\t\t(0x1 << CHIP_REV_SHIFT)\n \n#define CHIP_REV_IS_SLOW(bp)\t\t(CHIP_REV_VAL(bp) > 0x00005000)\n \n#define CHIP_REV_IS_EMUL(bp)\t\t((CHIP_REV_IS_SLOW(bp)) && \\\n\t\t\t\t\t !(CHIP_REV_VAL(bp) & 0x00001000))\n \n#define CHIP_REV_IS_FPGA(bp)\t\t((CHIP_REV_IS_SLOW(bp)) && \\\n\t\t\t\t\t (CHIP_REV_VAL(bp) & 0x00001000))\n\n#define CHIP_TIME(bp)\t\t\t((CHIP_REV_IS_EMUL(bp)) ? 2000 : \\\n\t\t\t\t\t((CHIP_REV_IS_FPGA(bp)) ? 200 : 1))\n\n#define CHIP_METAL(bp)\t\t\t(bp->common.chip_id & 0x00000ff0)\n#define CHIP_BOND_ID(bp)\t\t(bp->common.chip_id & 0x0000000f)\n#define CHIP_REV_SIM(bp)\t\t(((CHIP_REV_MASK - CHIP_REV_VAL(bp)) >>\\\n\t\t\t\t\t   (CHIP_REV_SHIFT + 1)) \\\n\t\t\t\t\t\t<< CHIP_REV_SHIFT)\n#define CHIP_REV(bp)\t\t\t(CHIP_REV_IS_SLOW(bp) ? \\\n\t\t\t\t\t\tCHIP_REV_SIM(bp) :\\\n\t\t\t\t\t\tCHIP_REV_VAL(bp))\n#define CHIP_IS_E3B0(bp)\t\t(CHIP_IS_E3(bp) && \\\n\t\t\t\t\t (CHIP_REV(bp) == CHIP_REV_Bx))\n#define CHIP_IS_E3A0(bp)\t\t(CHIP_IS_E3(bp) && \\\n\t\t\t\t\t (CHIP_REV(bp) == CHIP_REV_Ax))\n \n#define CONFIGURE_NIC_MODE(bp)\t\t(!CHIP_IS_E1x(bp) && !CNIC_ENABLED(bp))\n\n\tint\t\t\tflash_size;\n#define BNX2X_NVRAM_1MB_SIZE\t\t\t0x20000\t \n#define BNX2X_NVRAM_TIMEOUT_COUNT\t\t30000\n#define BNX2X_NVRAM_PAGE_SIZE\t\t\t256\n\n\tu32\t\t\tshmem_base;\n\tu32\t\t\tshmem2_base;\n\tu32\t\t\tmf_cfg_base;\n\tu32\t\t\tmf2_cfg_base;\n\n\tu32\t\t\thw_config;\n\n\tu32\t\t\tbc_ver;\n\n\tu8\t\t\tint_block;\n#define INT_BLOCK_HC\t\t\t0\n#define INT_BLOCK_IGU\t\t\t1\n#define INT_BLOCK_MODE_NORMAL\t\t0\n#define INT_BLOCK_MODE_BW_COMP\t\t2\n#define CHIP_INT_MODE_IS_NBC(bp)\t\t\\\n\t\t\t(!CHIP_IS_E1x(bp) &&\t\\\n\t\t\t!((bp)->common.int_block & INT_BLOCK_MODE_BW_COMP))\n#define CHIP_INT_MODE_IS_BC(bp) (!CHIP_INT_MODE_IS_NBC(bp))\n\n\tu8\t\t\tchip_port_mode;\n#define CHIP_4_PORT_MODE\t\t\t0x0\n#define CHIP_2_PORT_MODE\t\t\t0x1\n#define CHIP_PORT_MODE_NONE\t\t\t0x2\n#define CHIP_MODE(bp)\t\t\t(bp->common.chip_port_mode)\n#define CHIP_MODE_IS_4_PORT(bp) (CHIP_MODE(bp) == CHIP_4_PORT_MODE)\n\n\tu32\t\t\tboot_mode;\n};\n\n \n#define BNX2X_IGU_STAS_MSG_VF_CNT 64\n#define BNX2X_IGU_STAS_MSG_PF_CNT 4\n\n#define MAX_IGU_ATTN_ACK_TO       100\n \n\n \n\nstruct bnx2x_port {\n\tu32\t\t\tpmf;\n\n\tu32\t\t\tlink_config[LINK_CONFIG_SIZE];\n\n\tu32\t\t\tsupported[LINK_CONFIG_SIZE];\n\n\tu32\t\t\tadvertising[LINK_CONFIG_SIZE];\n\n\tu32\t\t\tphy_addr;\n\n\t \n\tstruct mutex\t\tphy_mutex;\n\n\tu32\t\t\tport_stx;\n\n\tstruct nig_stats\told_nig_stats;\n};\n\n \n\n#define STATS_OFFSET32(stat_name) \\\n\t\t\t(offsetof(struct bnx2x_eth_stats, stat_name) / 4)\n\n \n#define BNX2X_MAX_NUM_OF_VFS\t64\n#define BNX2X_VF_CID_WND\t4  \n#define BNX2X_CIDS_PER_VF\t(1 << BNX2X_VF_CID_WND)\n\n \n#define BNX2X_VF_CIDS\t\t(BNX2X_MAX_NUM_OF_VFS * BNX2X_CIDS_PER_VF)\n\n \n#define BNX2X_FIRST_VF_CID\tBNX2X_VF_CIDS\n#define BNX2X_MAX_NUM_VF_QUEUES\t64\n#define BNX2X_VF_ID_INVALID\t0xFF\n\n \n#define BNX2X_VF_BAR_SIZE\t512\n#if (BNX2X_VF_BAR_SIZE < BNX2X_CIDS_PER_VF * (1 << BNX2X_DB_SHIFT))\n#error \"VF doorbell bar size is 512\"\n#endif\n\n \n\n \n#define FP_SB_MAX_E1x\t\t16\n \n#define FP_SB_MAX_E2\t\tHC_SB_MAX_SB_E2\n\nunion cdu_context {\n\tstruct eth_context eth;\n\tchar pad[1024];\n};\n\n \n#define CDU_ILT_PAGE_SZ_HW\t2\n#define CDU_ILT_PAGE_SZ\t\t(8192 << CDU_ILT_PAGE_SZ_HW)  \n#define ILT_PAGE_CIDS\t\t(CDU_ILT_PAGE_SZ / sizeof(union cdu_context))\n\n#define CNIC_ISCSI_CID_MAX\t256\n#define CNIC_FCOE_CID_MAX\t2048\n#define CNIC_CID_MAX\t\t(CNIC_ISCSI_CID_MAX + CNIC_FCOE_CID_MAX)\n#define CNIC_ILT_LINES\t\tDIV_ROUND_UP(CNIC_CID_MAX, ILT_PAGE_CIDS)\n\n#define QM_ILT_PAGE_SZ_HW\t0\n#define QM_ILT_PAGE_SZ\t\t(4096 << QM_ILT_PAGE_SZ_HW)  \n#define QM_CID_ROUND\t\t1024\n\n \n#define TM_ILT_PAGE_SZ_HW\t0\n#define TM_ILT_PAGE_SZ\t\t(4096 << TM_ILT_PAGE_SZ_HW)  \n#define TM_CONN_NUM\t\t(BNX2X_FIRST_VF_CID + \\\n\t\t\t\t BNX2X_VF_CIDS + \\\n\t\t\t\t CNIC_ISCSI_CID_MAX)\n#define TM_ILT_SZ\t\t(8 * TM_CONN_NUM)\n#define TM_ILT_LINES\t\tDIV_ROUND_UP(TM_ILT_SZ, TM_ILT_PAGE_SZ)\n\n \n#define SRC_ILT_PAGE_SZ_HW\t0\n#define SRC_ILT_PAGE_SZ\t\t(4096 << SRC_ILT_PAGE_SZ_HW)  \n#define SRC_HASH_BITS\t\t10\n#define SRC_CONN_NUM\t\t(1 << SRC_HASH_BITS)  \n#define SRC_ILT_SZ\t\t(sizeof(struct src_ent) * SRC_CONN_NUM)\n#define SRC_T2_SZ\t\tSRC_ILT_SZ\n#define SRC_ILT_LINES\t\tDIV_ROUND_UP(SRC_ILT_SZ, SRC_ILT_PAGE_SZ)\n\n#define MAX_DMAE_C\t\t8\n\n \nstruct bnx2x_slowpath {\n\tunion {\n\t\tstruct mac_configuration_cmd\t\te1x;\n\t\tstruct eth_classify_rules_ramrod_data\te2;\n\t} mac_rdata;\n\n\tunion {\n\t\tstruct eth_classify_rules_ramrod_data\te2;\n\t} vlan_rdata;\n\n\tunion {\n\t\tstruct tstorm_eth_mac_filter_config\te1x;\n\t\tstruct eth_filter_rules_ramrod_data\te2;\n\t} rx_mode_rdata;\n\n\tunion {\n\t\tstruct mac_configuration_cmd\t\te1;\n\t\tstruct eth_multicast_rules_ramrod_data  e2;\n\t} mcast_rdata;\n\n\tstruct eth_rss_update_ramrod_data\trss_rdata;\n\n\t \n\tunion {\n\t\tstruct client_init_ramrod_data  init_data;\n\t\tstruct client_update_ramrod_data update_data;\n\t\tstruct tpa_update_ramrod_data tpa_data;\n\t} q_rdata;\n\n\tunion {\n\t\tstruct function_start_data\tfunc_start;\n\t\t \n\t\tstruct flow_control_configuration pfc_config;\n\t} func_rdata;\n\n\t \n\tunion {\n\t\tstruct afex_vif_list_ramrod_data\tviflist_data;\n\t\tstruct function_update_data\t\tfunc_update;\n\t} func_afex_rdata;\n\n\t \n\tstruct dmae_command\t\tdmae[MAX_DMAE_C];\n\n\tu32\t\t\t\tstats_comp;\n\tunion mac_stats\t\t\tmac_stats;\n\tstruct nig_stats\t\tnig_stats;\n\tstruct host_port_stats\t\tport_stats;\n\tstruct host_func_stats\t\tfunc_stats;\n\n\tu32\t\t\t\twb_comp;\n\tu32\t\t\t\twb_data[4];\n\n\tunion drv_info_to_mcp\t\tdrv_info_to_mcp;\n};\n\n#define bnx2x_sp(bp, var)\t\t(&bp->slowpath->var)\n#define bnx2x_sp_mapping(bp, var) \\\n\t\t(bp->slowpath_mapping + offsetof(struct bnx2x_slowpath, var))\n\n \n#define MAX_DYNAMIC_ATTN_GRPS\t\t8\n\nstruct attn_route {\n\tu32 sig[5];\n};\n\nstruct iro {\n\tu32 base;\n\tu16 m1;\n\tu16 m2;\n\tu16 m3;\n\tu16 size;\n};\n\nstruct hw_context {\n\tunion cdu_context *vcxt;\n\tdma_addr_t cxt_mapping;\n\tsize_t size;\n};\n\n \nstruct bnx2x_ilt;\n\nstruct bnx2x_vfdb;\n\nenum bnx2x_recovery_state {\n\tBNX2X_RECOVERY_DONE,\n\tBNX2X_RECOVERY_INIT,\n\tBNX2X_RECOVERY_WAIT,\n\tBNX2X_RECOVERY_FAILED,\n\tBNX2X_RECOVERY_NIC_LOADING\n};\n\n \n#define NUM_EQ_PAGES\t\t1\n#define EQ_DESC_CNT_PAGE\t(BCM_PAGE_SIZE / sizeof(union event_ring_elem))\n#define EQ_DESC_MAX_PAGE\t(EQ_DESC_CNT_PAGE - 1)\n#define NUM_EQ_DESC\t\t(EQ_DESC_CNT_PAGE * NUM_EQ_PAGES)\n#define EQ_DESC_MASK\t\t(NUM_EQ_DESC - 1)\n#define MAX_EQ_AVAIL\t\t(EQ_DESC_MAX_PAGE * NUM_EQ_PAGES - 2)\n\n \n#define NEXT_EQ_IDX(x)\t\t((((x) & EQ_DESC_MAX_PAGE) == \\\n\t\t\t\t  (EQ_DESC_MAX_PAGE - 1)) ? (x) + 2 : (x) + 1)\n\n \n#define EQ_DESC(x)\t\t((x) & EQ_DESC_MASK)\n\n#define BNX2X_EQ_INDEX \\\n\t(&bp->def_status_blk->sp_sb.\\\n\tindex_values[HC_SP_INDEX_EQ_CONS])\n\n \nstruct bnx2x_link_report_data {\n\tu16 line_speed;\t\t\t \n\tunsigned long link_report_flags; \n};\n\nenum {\n\tBNX2X_LINK_REPORT_FD,\t\t \n\tBNX2X_LINK_REPORT_LINK_DOWN,\n\tBNX2X_LINK_REPORT_RX_FC_ON,\n\tBNX2X_LINK_REPORT_TX_FC_ON,\n};\n\nenum {\n\tBNX2X_PORT_QUERY_IDX,\n\tBNX2X_PF_QUERY_IDX,\n\tBNX2X_FCOE_QUERY_IDX,\n\tBNX2X_FIRST_QUEUE_QUERY_IDX,\n};\n\nstruct bnx2x_fw_stats_req {\n\tstruct stats_query_header hdr;\n\tstruct stats_query_entry query[FP_SB_MAX_E1x+\n\t\tBNX2X_FIRST_QUEUE_QUERY_IDX];\n};\n\nstruct bnx2x_fw_stats_data {\n\tstruct stats_counter\t\tstorm_counters;\n\tstruct per_port_stats\t\tport;\n\tstruct per_pf_stats\t\tpf;\n\tstruct fcoe_statistics_params\tfcoe;\n\tstruct per_queue_stats\t\tqueue_stats[];\n};\n\n \nenum sp_rtnl_flag {\n\tBNX2X_SP_RTNL_SETUP_TC,\n\tBNX2X_SP_RTNL_TX_TIMEOUT,\n\tBNX2X_SP_RTNL_FAN_FAILURE,\n\tBNX2X_SP_RTNL_AFEX_F_UPDATE,\n\tBNX2X_SP_RTNL_ENABLE_SRIOV,\n\tBNX2X_SP_RTNL_VFPF_MCAST,\n\tBNX2X_SP_RTNL_VFPF_CHANNEL_DOWN,\n\tBNX2X_SP_RTNL_RX_MODE,\n\tBNX2X_SP_RTNL_HYPERVISOR_VLAN,\n\tBNX2X_SP_RTNL_TX_STOP,\n\tBNX2X_SP_RTNL_GET_DRV_VERSION,\n\tBNX2X_SP_RTNL_UPDATE_SVID,\n};\n\nenum bnx2x_iov_flag {\n\tBNX2X_IOV_HANDLE_VF_MSG,\n\tBNX2X_IOV_HANDLE_FLR,\n};\n\nstruct bnx2x_prev_path_list {\n\tstruct list_head list;\n\tu8 bus;\n\tu8 slot;\n\tu8 path;\n\tu8 aer;\n\tu8 undi;\n};\n\nstruct bnx2x_sp_objs {\n\t \n\tstruct bnx2x_vlan_mac_obj mac_obj;\n\n\t \n\tstruct bnx2x_queue_sp_obj q_obj;\n\n\t \n\tstruct bnx2x_vlan_mac_obj vlan_obj;\n};\n\nstruct bnx2x_fp_stats {\n\tstruct tstorm_per_queue_stats old_tclient;\n\tstruct ustorm_per_queue_stats old_uclient;\n\tstruct xstorm_per_queue_stats old_xclient;\n\tstruct bnx2x_eth_q_stats eth_q_stats;\n\tstruct bnx2x_eth_q_stats_old eth_q_stats_old;\n};\n\nenum {\n\tSUB_MF_MODE_UNKNOWN = 0,\n\tSUB_MF_MODE_UFP,\n\tSUB_MF_MODE_NPAR1_DOT_5,\n\tSUB_MF_MODE_BD,\n};\n\nstruct bnx2x_vlan_entry {\n\tstruct list_head link;\n\tu16 vid;\n\tbool hw;\n};\n\nenum bnx2x_udp_port_type {\n\tBNX2X_UDP_PORT_VXLAN,\n\tBNX2X_UDP_PORT_GENEVE,\n\tBNX2X_UDP_PORT_MAX,\n};\n\nstruct bnx2x {\n\t \n\tstruct bnx2x_fastpath\t*fp;\n\tstruct bnx2x_sp_objs\t*sp_objs;\n\tstruct bnx2x_fp_stats\t*fp_stats;\n\tstruct bnx2x_fp_txdata\t*bnx2x_txq;\n\tvoid __iomem\t\t*regview;\n\tvoid __iomem\t\t*doorbells;\n\tu16\t\t\tdb_size;\n\n\tu8\t\t\tpf_num;\t \n\tu8\t\t\tpfid;\t \n\tint\t\t\tbase_fw_ndsb;  \n#define BP_PATH(bp)\t\t\t(CHIP_IS_E1x(bp) ? 0 : (bp->pf_num & 1))\n#define BP_PORT(bp)\t\t\t(bp->pfid & 1)\n#define BP_FUNC(bp)\t\t\t(bp->pfid)\n#define BP_ABS_FUNC(bp)\t\t\t(bp->pf_num)\n#define BP_VN(bp)\t\t\t((bp)->pfid >> 1)\n#define BP_MAX_VN_NUM(bp)\t\t(CHIP_MODE_IS_4_PORT(bp) ? 2 : 4)\n#define BP_L_ID(bp)\t\t\t(BP_VN(bp) << 2)\n#define BP_FW_MB_IDX_VN(bp, vn)\t\t(BP_PORT(bp) +\\\n\t  (vn) * ((CHIP_IS_E1x(bp) || (CHIP_MODE_IS_4_PORT(bp))) ? 2  : 1))\n#define BP_FW_MB_IDX(bp)\t\tBP_FW_MB_IDX_VN(bp, BP_VN(bp))\n\n#ifdef CONFIG_BNX2X_SRIOV\n\t \n\tstruct mutex\t\tvf2pf_mutex;\n\t \n\tstruct bnx2x_vf_mbx_msg\t*vf2pf_mbox;\n\tdma_addr_t\t\tvf2pf_mbox_mapping;\n\n\t \n\tstruct pfvf_acquire_resp_tlv acquire_resp;\n\n\t \n\tunion pf_vf_bulletin   *pf2vf_bulletin;\n\tdma_addr_t\t\tpf2vf_bulletin_mapping;\n\n\tunion pf_vf_bulletin\t\tshadow_bulletin;\n\tstruct pf_vf_bulletin_content\told_bulletin;\n\n\tu16 requested_nr_virtfn;\n#endif  \n\n\tstruct net_device\t*dev;\n\tstruct pci_dev\t\t*pdev;\n\n\tconst struct iro\t*iro_arr;\n#define IRO (bp->iro_arr)\n\n\tenum bnx2x_recovery_state recovery_state;\n\tint\t\t\tis_leader;\n\tstruct msix_entry\t*msix_table;\n\n\tint\t\t\ttx_ring_size;\n\n \n#define ETH_OVERHEAD\t\t(ETH_HLEN + 8 + 8)\n#define ETH_MIN_PACKET_SIZE\t\t(ETH_ZLEN - ETH_HLEN)\n#define ETH_MAX_PACKET_SIZE\t\tETH_DATA_LEN\n#define ETH_MAX_JUMBO_PACKET_SIZE\t9600\n \n#define ETH_MAX_TPA_HEADER_SIZE\t\t72\n\n\t \n#define BNX2X_RX_ALIGN_SHIFT\t\tmax(6, min(8, L1_CACHE_SHIFT))\n\n\t \n#define BNX2X_FW_RX_ALIGN_START\t(1UL << BNX2X_RX_ALIGN_SHIFT)\n\n#define BNX2X_FW_RX_ALIGN_END\t\t\t\t\t\\\n\tmax_t(u64, 1UL << BNX2X_RX_ALIGN_SHIFT,\t\t\t\\\n\t    SKB_DATA_ALIGN(sizeof(struct skb_shared_info)))\n\n#define BNX2X_PXP_DRAM_ALIGN\t\t(BNX2X_RX_ALIGN_SHIFT - 5)\n\n\tstruct host_sp_status_block *def_status_blk;\n#define DEF_SB_IGU_ID\t\t\t16\n#define DEF_SB_ID\t\t\tHC_SP_SB_ID\n\t__le16\t\t\tdef_idx;\n\t__le16\t\t\tdef_att_idx;\n\tu32\t\t\tattn_state;\n\tstruct attn_route\tattn_group[MAX_DYNAMIC_ATTN_GRPS];\n\n\t \n\tstruct eth_spe\t\t*spq;\n\tdma_addr_t\t\tspq_mapping;\n\tu16\t\t\tspq_prod_idx;\n\tstruct eth_spe\t\t*spq_prod_bd;\n\tstruct eth_spe\t\t*spq_last_bd;\n\t__le16\t\t\t*dsb_sp_prod;\n\tatomic_t\t\tcq_spq_left;  \n\t \n\tspinlock_t\t\tspq_lock;\n\n\t \n\tunion event_ring_elem\t*eq_ring;\n\tdma_addr_t\t\teq_mapping;\n\tu16\t\t\teq_prod;\n\tu16\t\t\teq_cons;\n\t__le16\t\t\t*eq_cons_sb;\n\tatomic_t\t\teq_spq_left;  \n\n\t \n\tu16\t\t\tstats_pending;\n\t \n\tu16\t\t\tstats_comp;\n\n\t \n\n\tint\t\t\tpanic;\n\tint\t\t\tmsg_enable;\n\n\tu32\t\t\tflags;\n#define PCIX_FLAG\t\t\t(1 << 0)\n#define PCI_32BIT_FLAG\t\t\t(1 << 1)\n#define ONE_PORT_FLAG\t\t\t(1 << 2)\n#define NO_WOL_FLAG\t\t\t(1 << 3)\n#define USING_MSIX_FLAG\t\t\t(1 << 5)\n#define USING_MSI_FLAG\t\t\t(1 << 6)\n#define DISABLE_MSI_FLAG\t\t(1 << 7)\n#define NO_MCP_FLAG\t\t\t(1 << 9)\n#define MF_FUNC_DIS\t\t\t(1 << 11)\n#define OWN_CNIC_IRQ\t\t\t(1 << 12)\n#define NO_ISCSI_OOO_FLAG\t\t(1 << 13)\n#define NO_ISCSI_FLAG\t\t\t(1 << 14)\n#define NO_FCOE_FLAG\t\t\t(1 << 15)\n#define BC_SUPPORTS_PFC_STATS\t\t(1 << 17)\n#define TX_SWITCHING\t\t\t(1 << 18)\n#define BC_SUPPORTS_FCOE_FEATURES\t(1 << 19)\n#define USING_SINGLE_MSIX_FLAG\t\t(1 << 20)\n#define BC_SUPPORTS_DCBX_MSG_NON_PMF\t(1 << 21)\n#define IS_VF_FLAG\t\t\t(1 << 22)\n#define BC_SUPPORTS_RMMOD_CMD\t\t(1 << 23)\n#define HAS_PHYS_PORT_ID\t\t(1 << 24)\n#define PTP_SUPPORTED\t\t\t(1 << 26)\n#define TX_TIMESTAMPING_EN\t\t(1 << 27)\n\n#define BP_NOMCP(bp)\t\t\t((bp)->flags & NO_MCP_FLAG)\n\n#ifdef CONFIG_BNX2X_SRIOV\n#define IS_VF(bp)\t\t\t((bp)->flags & IS_VF_FLAG)\n#define IS_PF(bp)\t\t\t(!((bp)->flags & IS_VF_FLAG))\n#else\n#define IS_VF(bp)\t\t\tfalse\n#define IS_PF(bp)\t\t\ttrue\n#endif\n\n#define NO_ISCSI(bp)\t\t((bp)->flags & NO_ISCSI_FLAG)\n#define NO_ISCSI_OOO(bp)\t((bp)->flags & NO_ISCSI_OOO_FLAG)\n#define NO_FCOE(bp)\t\t((bp)->flags & NO_FCOE_FLAG)\n\n\tu8\t\t\tcnic_support;\n\tbool\t\t\tcnic_enabled;\n\tbool\t\t\tcnic_loaded;\n\tstruct cnic_eth_dev\t*(*cnic_probe)(struct net_device *);\n\n\tbool                    nic_stopped;\n\n\t \n\tbool\t\t\tfcoe_init;\n\n\tint\t\t\tmrrs;\n\n\tstruct delayed_work\tsp_task;\n\tstruct delayed_work\tiov_task;\n\n\tatomic_t\t\tinterrupt_occurred;\n\tstruct delayed_work\tsp_rtnl_task;\n\n\tstruct delayed_work\tperiod_task;\n\tstruct timer_list\ttimer;\n\tint\t\t\tcurrent_interval;\n\n\tu16\t\t\tfw_seq;\n\tu16\t\t\tfw_drv_pulse_wr_seq;\n\tu32\t\t\tfunc_stx;\n\n\tstruct link_params\tlink_params;\n\tstruct link_vars\tlink_vars;\n\tu32\t\t\tlink_cnt;\n\tstruct bnx2x_link_report_data last_reported_link;\n\tbool\t\t\tforce_link_down;\n\n\tstruct mdio_if_info\tmdio;\n\n\tstruct bnx2x_common\tcommon;\n\tstruct bnx2x_port\tport;\n\n\tstruct cmng_init\tcmng;\n\n\tu32\t\t\tmf_config[E1HVN_MAX];\n\tu32\t\t\tmf_ext_config;\n\tu32\t\t\tpath_has_ovlan;  \n\tu16\t\t\tmf_ov;\n\tu8\t\t\tmf_mode;\n#define IS_MF(bp)\t\t(bp->mf_mode != 0)\n#define IS_MF_SI(bp)\t\t(bp->mf_mode == MULTI_FUNCTION_SI)\n#define IS_MF_SD(bp)\t\t(bp->mf_mode == MULTI_FUNCTION_SD)\n#define IS_MF_AFEX(bp)\t\t(bp->mf_mode == MULTI_FUNCTION_AFEX)\n\tu8\t\t\tmf_sub_mode;\n#define IS_MF_UFP(bp)\t\t(IS_MF_SD(bp) && \\\n\t\t\t\t bp->mf_sub_mode == SUB_MF_MODE_UFP)\n#define IS_MF_BD(bp)\t\t(IS_MF_SD(bp) && \\\n\t\t\t\t bp->mf_sub_mode == SUB_MF_MODE_BD)\n\n\tu8\t\t\twol;\n\n\tint\t\t\trx_ring_size;\n\n\tu16\t\t\ttx_quick_cons_trip_int;\n\tu16\t\t\ttx_quick_cons_trip;\n\tu16\t\t\ttx_ticks_int;\n\tu16\t\t\ttx_ticks;\n\n\tu16\t\t\trx_quick_cons_trip_int;\n\tu16\t\t\trx_quick_cons_trip;\n\tu16\t\t\trx_ticks_int;\n\tu16\t\t\trx_ticks;\n \n#define BNX2X_MAX_COALESCE_TOUT\t\t(0xff*BNX2X_BTR)\n\n\tu32\t\t\tlin_cnt;\n\n\tu16\t\t\tstate;\n#define BNX2X_STATE_CLOSED\t\t0\n#define BNX2X_STATE_OPENING_WAIT4_LOAD\t0x1000\n#define BNX2X_STATE_OPENING_WAIT4_PORT\t0x2000\n#define BNX2X_STATE_OPEN\t\t0x3000\n#define BNX2X_STATE_CLOSING_WAIT4_HALT\t0x4000\n#define BNX2X_STATE_CLOSING_WAIT4_DELETE 0x5000\n\n#define BNX2X_STATE_DIAG\t\t0xe000\n#define BNX2X_STATE_ERROR\t\t0xf000\n\n#define BNX2X_MAX_PRIORITY\t\t8\n\tint\t\t\tnum_queues;\n\tuint\t\t\tnum_ethernet_queues;\n\tuint\t\t\tnum_cnic_queues;\n\tint\t\t\tdisable_tpa;\n\n\tu32\t\t\trx_mode;\n#define BNX2X_RX_MODE_NONE\t\t0\n#define BNX2X_RX_MODE_NORMAL\t\t1\n#define BNX2X_RX_MODE_ALLMULTI\t\t2\n#define BNX2X_RX_MODE_PROMISC\t\t3\n#define BNX2X_MAX_MULTICAST\t\t64\n\n\tu8\t\t\tigu_dsb_id;\n\tu8\t\t\tigu_base_sb;\n\tu8\t\t\tigu_sb_cnt;\n\tu8\t\t\tmin_msix_vec_cnt;\n\n\tu32\t\t\tigu_base_addr;\n\tdma_addr_t\t\tdef_status_blk_mapping;\n\n\tstruct bnx2x_slowpath\t*slowpath;\n\tdma_addr_t\t\tslowpath_mapping;\n\n\t \n\tstruct mutex\t\tdrv_info_mutex;\n\tbool\t\t\tdrv_info_mng_owner;\n\n\t \n\tu8\t\t\tfw_stats_num;\n\n\t \n\tvoid\t\t\t*fw_stats;\n\tdma_addr_t\t\tfw_stats_mapping;\n\n\t \n\tstruct bnx2x_fw_stats_req\t*fw_stats_req;\n\tdma_addr_t\t\t\tfw_stats_req_mapping;\n\tint\t\t\t\tfw_stats_req_sz;\n\n\t \n\tstruct bnx2x_fw_stats_data\t*fw_stats_data;\n\tdma_addr_t\t\t\tfw_stats_data_mapping;\n\tint\t\t\t\tfw_stats_data_sz;\n\n\t \n#define ILT_MAX_L2_LINES\t32\n\tstruct hw_context\tcontext[ILT_MAX_L2_LINES];\n\n\tstruct bnx2x_ilt\t*ilt;\n#define BP_ILT(bp)\t\t((bp)->ilt)\n#define ILT_MAX_LINES\t\t256\n \n#define BNX2X_MAX_RSS_COUNT(bp)\t((bp)->igu_sb_cnt - CNIC_SUPPORT(bp))\n\n \n\n#define BNX2X_L2_CID_COUNT(bp)\t(BNX2X_NUM_ETH_QUEUES(bp) * BNX2X_MULTI_TX_COS \\\n\t\t\t\t+ CNIC_SUPPORT(bp) * (2 + UIO_CID_PAD(bp)))\n#define BNX2X_L2_MAX_CID(bp)\t(BNX2X_MAX_RSS_COUNT(bp) * BNX2X_MULTI_TX_COS \\\n\t\t\t\t+ CNIC_SUPPORT(bp) * (2 + UIO_CID_PAD(bp)))\n#define L2_ILT_LINES(bp)\t(DIV_ROUND_UP(BNX2X_L2_CID_COUNT(bp),\\\n\t\t\t\t\tILT_PAGE_CIDS))\n\n\tint\t\t\tqm_cid_count;\n\n\tbool\t\t\tdropless_fc;\n\n\tvoid\t\t\t*t2;\n\tdma_addr_t\t\tt2_mapping;\n\tstruct cnic_ops\t__rcu\t*cnic_ops;\n\tvoid\t\t\t*cnic_data;\n\tu32\t\t\tcnic_tag;\n\tstruct cnic_eth_dev\tcnic_eth_dev;\n\tunion host_hc_status_block cnic_sb;\n\tdma_addr_t\t\tcnic_sb_mapping;\n\tstruct eth_spe\t\t*cnic_kwq;\n\tstruct eth_spe\t\t*cnic_kwq_prod;\n\tstruct eth_spe\t\t*cnic_kwq_cons;\n\tstruct eth_spe\t\t*cnic_kwq_last;\n\tu16\t\t\tcnic_kwq_pending;\n\tu16\t\t\tcnic_spq_pending;\n\tu8\t\t\tfip_mac[ETH_ALEN];\n\tstruct mutex\t\tcnic_mutex;\n\tstruct bnx2x_vlan_mac_obj iscsi_l2_mac_obj;\n\n\t \n\tu8\t\t\t\tcnic_base_cl_id;\n\n\tint\t\t\tdmae_ready;\n\t \n\tspinlock_t\t\tdmae_lock;\n\n\t \n\tstruct mutex\t\tfw_mb_mutex;\n\n\t \n\tint\t\t\tstats_state;\n\n\t \n\tstruct semaphore\tstats_lock;\n\n\t \n\tstruct dmae_command\tstats_dmae;\n\tint\t\t\texecuter_idx;\n\n\tu16\t\t\tstats_counter;\n\tstruct bnx2x_eth_stats\teth_stats;\n\tstruct host_func_stats\t\tfunc_stats;\n\tstruct bnx2x_eth_stats_old\teth_stats_old;\n\tstruct bnx2x_net_stats_old\tnet_stats_old;\n\tstruct bnx2x_fw_port_stats_old\tfw_stats_old;\n\tbool\t\t\tstats_init;\n\n\tstruct z_stream_s\t*strm;\n\tvoid\t\t\t*gunzip_buf;\n\tdma_addr_t\t\tgunzip_mapping;\n\tint\t\t\tgunzip_outlen;\n#define FW_BUF_SIZE\t\t\t0x8000\n#define GUNZIP_BUF(bp)\t\t\t(bp->gunzip_buf)\n#define GUNZIP_PHYS(bp)\t\t\t(bp->gunzip_mapping)\n#define GUNZIP_OUTLEN(bp)\t\t(bp->gunzip_outlen)\n\n\tstruct raw_op\t\t*init_ops;\n\t \n\tu16\t\t\t*init_ops_offsets;\n\t \n\tu32\t\t\t*init_data;\n\tu32\t\t\tinit_mode_flags;\n#define INIT_MODE_FLAGS(bp)\t(bp->init_mode_flags)\n\t \n\tconst u8\t\t*tsem_int_table_data;\n\tconst u8\t\t*tsem_pram_data;\n\tconst u8\t\t*usem_int_table_data;\n\tconst u8\t\t*usem_pram_data;\n\tconst u8\t\t*xsem_int_table_data;\n\tconst u8\t\t*xsem_pram_data;\n\tconst u8\t\t*csem_int_table_data;\n\tconst u8\t\t*csem_pram_data;\n#define INIT_OPS(bp)\t\t\t(bp->init_ops)\n#define INIT_OPS_OFFSETS(bp)\t\t(bp->init_ops_offsets)\n#define INIT_DATA(bp)\t\t\t(bp->init_data)\n#define INIT_TSEM_INT_TABLE_DATA(bp)\t(bp->tsem_int_table_data)\n#define INIT_TSEM_PRAM_DATA(bp)\t\t(bp->tsem_pram_data)\n#define INIT_USEM_INT_TABLE_DATA(bp)\t(bp->usem_int_table_data)\n#define INIT_USEM_PRAM_DATA(bp)\t\t(bp->usem_pram_data)\n#define INIT_XSEM_INT_TABLE_DATA(bp)\t(bp->xsem_int_table_data)\n#define INIT_XSEM_PRAM_DATA(bp)\t\t(bp->xsem_pram_data)\n#define INIT_CSEM_INT_TABLE_DATA(bp)\t(bp->csem_int_table_data)\n#define INIT_CSEM_PRAM_DATA(bp)\t\t(bp->csem_pram_data)\n\n#define PHY_FW_VER_LEN\t\t\t20\n\tchar\t\t\tfw_ver[32];\n\tconst struct firmware\t*firmware;\n\n\tstruct bnx2x_vfdb\t*vfdb;\n#define IS_SRIOV(bp)\t\t((bp)->vfdb)\n\n\t \n\tu16 dcb_state;\n#define BNX2X_DCB_STATE_OFF\t\t\t0\n#define BNX2X_DCB_STATE_ON\t\t\t1\n\n\t \n\tint dcbx_enabled;\n#define BNX2X_DCBX_ENABLED_OFF\t\t\t0\n#define BNX2X_DCBX_ENABLED_ON_NEG_OFF\t\t1\n#define BNX2X_DCBX_ENABLED_ON_NEG_ON\t\t2\n#define BNX2X_DCBX_ENABLED_INVALID\t\t(-1)\n\n\tbool dcbx_mode_uset;\n\n\tstruct bnx2x_config_dcbx_params\t\tdcbx_config_params;\n\tstruct bnx2x_dcbx_port_params\t\tdcbx_port_params;\n\tint\t\t\t\t\tdcb_version;\n\n\t \n\tstruct bnx2x_credit_pool_obj\t\tvlans_pool;\n\n\tstruct bnx2x_credit_pool_obj\t\tmacs_pool;\n\n\t \n\tstruct bnx2x_rx_mode_obj\t\trx_mode_obj;\n\n\t \n\tstruct bnx2x_mcast_obj\t\t\tmcast_obj;\n\n\t \n\tstruct bnx2x_rss_config_obj\t\trss_conf_obj;\n\n\t \n\tstruct bnx2x_func_sp_obj\t\tfunc_obj;\n\n\tunsigned long\t\t\t\tsp_state;\n\n\t \n\tunsigned long\t\t\t\tsp_rtnl_state;\n\n\t \n\tunsigned long\t\t\t\tiov_task_state;\n\n\t \n\tstruct dcbx_features\t\t\tdcbx_local_feat;\n\tu32\t\t\t\t\tdcbx_error;\n\n#ifdef BCM_DCBNL\n\tstruct dcbx_features\t\t\tdcbx_remote_feat;\n\tu32\t\t\t\t\tdcbx_remote_flags;\n#endif\n\t \n\tint\t\t\t\t\tafex_def_vlan_tag;\n\tenum mf_cfg_afex_vlan_mode\t\tafex_vlan_mode;\n\tu32\t\t\t\t\tpending_max;\n\n\t \n\tu8\t\t\t\t\tmax_cos;\n\n\t \n\tu8\t\t\t\t\tprio_to_cos[8];\n\n\tint fp_array_size;\n\tu32 dump_preset_idx;\n\n\tu8\t\t\t\t\tphys_port_id[ETH_ALEN];\n\n\t \n\tstruct ptp_clock *ptp_clock;\n\tstruct ptp_clock_info ptp_clock_info;\n\tstruct work_struct ptp_task;\n\tstruct cyclecounter cyclecounter;\n\tstruct timecounter timecounter;\n\tbool timecounter_init_done;\n\tstruct sk_buff *ptp_tx_skb;\n\tunsigned long ptp_tx_start;\n\tbool hwtstamp_ioctl_called;\n\tu16 tx_type;\n\tu16 rx_filter;\n\n\tstruct bnx2x_link_report_data\t\tvf_link_vars;\n\tstruct list_head vlan_reg;\n\tu16 vlan_cnt;\n\tu16 vlan_credit;\n\tbool accept_any_vlan;\n\n\t \n\tu16 udp_tunnel_ports[BNX2X_UDP_PORT_MAX];\n\n#define FW_CAP_INVALIDATE_VF_FP_HSI\tBIT(0)\n\tu32 fw_cap;\n\n\tu32 fw_major;\n\tu32 fw_minor;\n\tu32 fw_rev;\n\tu32 fw_eng;\n};\n\n \nextern int num_queues;\n#define BNX2X_NUM_QUEUES(bp)\t(bp->num_queues)\n#define BNX2X_NUM_ETH_QUEUES(bp) ((bp)->num_ethernet_queues)\n#define BNX2X_NUM_NON_CNIC_QUEUES(bp)\t(BNX2X_NUM_QUEUES(bp) - \\\n\t\t\t\t\t (bp)->num_cnic_queues)\n#define BNX2X_NUM_RX_QUEUES(bp)\tBNX2X_NUM_QUEUES(bp)\n\n#define is_multi(bp)\t\t(BNX2X_NUM_QUEUES(bp) > 1)\n\n#define BNX2X_MAX_QUEUES(bp)\tBNX2X_MAX_RSS_COUNT(bp)\n \n\n#define RSS_IPV4_CAP_MASK\t\t\t\t\t\t\\\n\tTSTORM_ETH_FUNCTION_COMMON_CONFIG_RSS_IPV4_CAPABILITY\n\n#define RSS_IPV4_TCP_CAP_MASK\t\t\t\t\t\t\\\n\tTSTORM_ETH_FUNCTION_COMMON_CONFIG_RSS_IPV4_TCP_CAPABILITY\n\n#define RSS_IPV6_CAP_MASK\t\t\t\t\t\t\\\n\tTSTORM_ETH_FUNCTION_COMMON_CONFIG_RSS_IPV6_CAPABILITY\n\n#define RSS_IPV6_TCP_CAP_MASK\t\t\t\t\t\t\\\n\tTSTORM_ETH_FUNCTION_COMMON_CONFIG_RSS_IPV6_TCP_CAPABILITY\n\nstruct bnx2x_func_init_params {\n\t \n\tbool\t\tspq_active;\n\tdma_addr_t\tspq_map;\n\tu16\t\tspq_prod;\n\n\tu16\t\tfunc_id;\t \n\tu16\t\tpf_id;\n};\n\n#define for_each_cnic_queue(bp, var) \\\n\tfor ((var) = BNX2X_NUM_ETH_QUEUES(bp); (var) < BNX2X_NUM_QUEUES(bp); \\\n\t     (var)++) \\\n\t\tif (skip_queue(bp, var))\t\\\n\t\t\tcontinue;\t\t\\\n\t\telse\n\n#define for_each_eth_queue(bp, var) \\\n\tfor ((var) = 0; (var) < BNX2X_NUM_ETH_QUEUES(bp); (var)++)\n\n#define for_each_nondefault_eth_queue(bp, var) \\\n\tfor ((var) = 1; (var) < BNX2X_NUM_ETH_QUEUES(bp); (var)++)\n\n#define for_each_queue(bp, var) \\\n\tfor ((var) = 0; (var) < BNX2X_NUM_QUEUES(bp); (var)++) \\\n\t\tif (skip_queue(bp, var))\t\\\n\t\t\tcontinue;\t\t\\\n\t\telse\n\n \n#define for_each_valid_rx_queue(bp, var)\t\t\t\\\n\tfor ((var) = 0;\t\t\t\t\t\t\\\n\t     (var) < (CNIC_LOADED(bp) ? BNX2X_NUM_QUEUES(bp) :\t\\\n\t\t      BNX2X_NUM_ETH_QUEUES(bp));\t\t\\\n\t     (var)++)\t\t\t\t\t\t\\\n\t\tif (skip_rx_queue(bp, var))\t\t\t\\\n\t\t\tcontinue;\t\t\t\t\\\n\t\telse\n\n#define for_each_rx_queue_cnic(bp, var) \\\n\tfor ((var) = BNX2X_NUM_ETH_QUEUES(bp); (var) < BNX2X_NUM_QUEUES(bp); \\\n\t     (var)++) \\\n\t\tif (skip_rx_queue(bp, var))\t\\\n\t\t\tcontinue;\t\t\\\n\t\telse\n\n#define for_each_rx_queue(bp, var) \\\n\tfor ((var) = 0; (var) < BNX2X_NUM_QUEUES(bp); (var)++) \\\n\t\tif (skip_rx_queue(bp, var))\t\\\n\t\t\tcontinue;\t\t\\\n\t\telse\n\n \n#define for_each_valid_tx_queue(bp, var)\t\t\t\\\n\tfor ((var) = 0;\t\t\t\t\t\t\\\n\t     (var) < (CNIC_LOADED(bp) ? BNX2X_NUM_QUEUES(bp) :\t\\\n\t\t      BNX2X_NUM_ETH_QUEUES(bp));\t\t\\\n\t     (var)++)\t\t\t\t\t\t\\\n\t\tif (skip_tx_queue(bp, var))\t\t\t\\\n\t\t\tcontinue;\t\t\t\t\\\n\t\telse\n\n#define for_each_tx_queue_cnic(bp, var) \\\n\tfor ((var) = BNX2X_NUM_ETH_QUEUES(bp); (var) < BNX2X_NUM_QUEUES(bp); \\\n\t     (var)++) \\\n\t\tif (skip_tx_queue(bp, var))\t\\\n\t\t\tcontinue;\t\t\\\n\t\telse\n\n#define for_each_tx_queue(bp, var) \\\n\tfor ((var) = 0; (var) < BNX2X_NUM_QUEUES(bp); (var)++) \\\n\t\tif (skip_tx_queue(bp, var))\t\\\n\t\t\tcontinue;\t\t\\\n\t\telse\n\n#define for_each_nondefault_queue(bp, var) \\\n\tfor ((var) = 1; (var) < BNX2X_NUM_QUEUES(bp); (var)++) \\\n\t\tif (skip_queue(bp, var))\t\\\n\t\t\tcontinue;\t\t\\\n\t\telse\n\n#define for_each_cos_in_tx_queue(fp, var) \\\n\tfor ((var) = 0; (var) < (fp)->max_cos; (var)++)\n\n \n#define skip_rx_queue(bp, idx)\t(NO_FCOE(bp) && IS_FCOE_IDX(idx))\n\n \n#define skip_tx_queue(bp, idx)\t(NO_FCOE(bp) && IS_FCOE_IDX(idx))\n\n#define skip_queue(bp, idx)\t(NO_FCOE(bp) && IS_FCOE_IDX(idx))\n\n \nint bnx2x_idle_chk(struct bnx2x *bp);\n\n \nint bnx2x_set_mac_one(struct bnx2x *bp, const u8 *mac,\n\t\t      struct bnx2x_vlan_mac_obj *obj, bool set,\n\t\t      int mac_type, unsigned long *ramrod_flags);\n\nint bnx2x_set_vlan_one(struct bnx2x *bp, u16 vlan,\n\t\t       struct bnx2x_vlan_mac_obj *obj, bool set,\n\t\t       unsigned long *ramrod_flags);\n\n \nint bnx2x_del_all_macs(struct bnx2x *bp,\n\t\t       struct bnx2x_vlan_mac_obj *mac_obj,\n\t\t       int mac_type, bool wait_for_comp);\n\n \nvoid bnx2x_func_init(struct bnx2x *bp, struct bnx2x_func_init_params *p);\nvoid bnx2x_init_sb(struct bnx2x *bp, dma_addr_t mapping, int vfid,\n\t\t    u8 vf_valid, int fw_sb_id, int igu_sb_id);\nint bnx2x_get_gpio(struct bnx2x *bp, int gpio_num, u8 port);\nint bnx2x_set_gpio(struct bnx2x *bp, int gpio_num, u32 mode, u8 port);\nint bnx2x_set_mult_gpio(struct bnx2x *bp, u8 pins, u32 mode);\nint bnx2x_set_gpio_int(struct bnx2x *bp, int gpio_num, u32 mode, u8 port);\nvoid bnx2x_read_mf_cfg(struct bnx2x *bp);\n\nint bnx2x_pretend_func(struct bnx2x *bp, u16 pretend_func_val);\n\n \nvoid bnx2x_read_dmae(struct bnx2x *bp, u32 src_addr, u32 len32);\nvoid bnx2x_write_dmae(struct bnx2x *bp, dma_addr_t dma_addr, u32 dst_addr,\n\t\t      u32 len32);\nvoid bnx2x_post_dmae(struct bnx2x *bp, struct dmae_command *dmae, int idx);\nu32 bnx2x_dmae_opcode_add_comp(u32 opcode, u8 comp_type);\nu32 bnx2x_dmae_opcode_clr_src_reset(u32 opcode);\nu32 bnx2x_dmae_opcode(struct bnx2x *bp, u8 src_type, u8 dst_type,\n\t\t      bool with_comp, u8 comp_type);\n\nvoid bnx2x_prep_dmae_with_comp(struct bnx2x *bp, struct dmae_command *dmae,\n\t\t\t       u8 src_type, u8 dst_type);\nint bnx2x_issue_dmae_with_comp(struct bnx2x *bp, struct dmae_command *dmae,\n\t\t\t       u32 *comp);\n\n \nu32 bnx2x_flr_clnup_poll_count(struct bnx2x *bp);\nvoid bnx2x_tx_hw_flushed(struct bnx2x *bp, u32 poll_count);\nint bnx2x_send_final_clnup(struct bnx2x *bp, u8 clnup_func, u32 poll_cnt);\nu8 bnx2x_is_pcie_pending(struct pci_dev *dev);\nint bnx2x_flr_clnup_poll_hw_counter(struct bnx2x *bp, u32 reg,\n\t\t\t\t    char *msg, u32 poll_cnt);\n\nvoid bnx2x_calc_fc_adv(struct bnx2x *bp);\nint bnx2x_sp_post(struct bnx2x *bp, int command, int cid,\n\t\t  u32 data_hi, u32 data_lo, int cmd_type);\nvoid bnx2x_update_coalesce(struct bnx2x *bp);\nint bnx2x_get_cur_phy_idx(struct bnx2x *bp);\n\nbool bnx2x_port_after_undi(struct bnx2x *bp);\n\nstatic inline u32 reg_poll(struct bnx2x *bp, u32 reg, u32 expected, int ms,\n\t\t\t   int wait)\n{\n\tu32 val;\n\n\tdo {\n\t\tval = REG_RD(bp, reg);\n\t\tif (val == expected)\n\t\t\tbreak;\n\t\tms -= wait;\n\t\tmsleep(wait);\n\n\t} while (ms > 0);\n\n\treturn val;\n}\n\nvoid bnx2x_igu_clear_sb_gen(struct bnx2x *bp, u8 func, u8 idu_sb_id,\n\t\t\t    bool is_pf);\n\n#define BNX2X_ILT_ZALLOC(x, y, size)\t\t\t\t\t\\\n\tx = dma_alloc_coherent(&bp->pdev->dev, size, y, GFP_KERNEL)\n\n#define BNX2X_ILT_FREE(x, y, size) \\\n\tdo { \\\n\t\tif (x) { \\\n\t\t\tdma_free_coherent(&bp->pdev->dev, size, x, y); \\\n\t\t\tx = NULL; \\\n\t\t\ty = 0; \\\n\t\t} \\\n\t} while (0)\n\n#define ILOG2(x)\t(ilog2((x)))\n\n#define ILT_NUM_PAGE_ENTRIES\t(3072)\n \n#define ILT_PER_FUNC\t\t(ILT_NUM_PAGE_ENTRIES/8)\n\n#define FUNC_ILT_BASE(func)\t(func * ILT_PER_FUNC)\n \n#define ONCHIP_ADDR1(x)\t\t((u32)(((u64)x >> 12) & 0xFFFFFFFF))\n#define ONCHIP_ADDR2(x)\t\t((u32)((1 << 20) | ((u64)x >> 44)))\n\n \n#define LOAD_NORMAL\t\t\t0\n#define LOAD_OPEN\t\t\t1\n#define LOAD_DIAG\t\t\t2\n#define LOAD_LOOPBACK_EXT\t\t3\n#define UNLOAD_NORMAL\t\t\t0\n#define UNLOAD_CLOSE\t\t\t1\n#define UNLOAD_RECOVERY\t\t\t2\n\n \n#define DMAE_TIMEOUT\t\t\t-1\n#define DMAE_PCI_ERROR\t\t\t-2\t \n#define DMAE_NOT_RDY\t\t\t-3\n#define DMAE_PCI_ERR_FLAG\t\t0x80000000\n\n#define DMAE_SRC_PCI\t\t\t0\n#define DMAE_SRC_GRC\t\t\t1\n\n#define DMAE_DST_NONE\t\t\t0\n#define DMAE_DST_PCI\t\t\t1\n#define DMAE_DST_GRC\t\t\t2\n\n#define DMAE_COMP_PCI\t\t\t0\n#define DMAE_COMP_GRC\t\t\t1\n\n \n\n#define DMAE_COMP_REGULAR\t\t0\n#define DMAE_COM_SET_ERR\t\t1\n\n#define DMAE_CMD_SRC_PCI\t\t(DMAE_SRC_PCI << \\\n\t\t\t\t\t\tDMAE_COMMAND_SRC_SHIFT)\n#define DMAE_CMD_SRC_GRC\t\t(DMAE_SRC_GRC << \\\n\t\t\t\t\t\tDMAE_COMMAND_SRC_SHIFT)\n\n#define DMAE_CMD_DST_PCI\t\t(DMAE_DST_PCI << \\\n\t\t\t\t\t\tDMAE_COMMAND_DST_SHIFT)\n#define DMAE_CMD_DST_GRC\t\t(DMAE_DST_GRC << \\\n\t\t\t\t\t\tDMAE_COMMAND_DST_SHIFT)\n\n#define DMAE_CMD_C_DST_PCI\t\t(DMAE_COMP_PCI << \\\n\t\t\t\t\t\tDMAE_COMMAND_C_DST_SHIFT)\n#define DMAE_CMD_C_DST_GRC\t\t(DMAE_COMP_GRC << \\\n\t\t\t\t\t\tDMAE_COMMAND_C_DST_SHIFT)\n\n#define DMAE_CMD_C_ENABLE\t\tDMAE_COMMAND_C_TYPE_ENABLE\n\n#define DMAE_CMD_ENDIANITY_NO_SWAP\t(0 << DMAE_COMMAND_ENDIANITY_SHIFT)\n#define DMAE_CMD_ENDIANITY_B_SWAP\t(1 << DMAE_COMMAND_ENDIANITY_SHIFT)\n#define DMAE_CMD_ENDIANITY_DW_SWAP\t(2 << DMAE_COMMAND_ENDIANITY_SHIFT)\n#define DMAE_CMD_ENDIANITY_B_DW_SWAP\t(3 << DMAE_COMMAND_ENDIANITY_SHIFT)\n\n#define DMAE_CMD_PORT_0\t\t\t0\n#define DMAE_CMD_PORT_1\t\t\tDMAE_COMMAND_PORT\n\n#define DMAE_CMD_SRC_RESET\t\tDMAE_COMMAND_SRC_RESET\n#define DMAE_CMD_DST_RESET\t\tDMAE_COMMAND_DST_RESET\n#define DMAE_CMD_E1HVN_SHIFT\t\tDMAE_COMMAND_E1HVN_SHIFT\n\n#define DMAE_SRC_PF\t\t\t0\n#define DMAE_SRC_VF\t\t\t1\n\n#define DMAE_DST_PF\t\t\t0\n#define DMAE_DST_VF\t\t\t1\n\n#define DMAE_C_SRC\t\t\t0\n#define DMAE_C_DST\t\t\t1\n\n#define DMAE_LEN32_RD_MAX\t\t0x80\n#define DMAE_LEN32_WR_MAX(bp)\t\t(CHIP_IS_E1(bp) ? 0x400 : 0x2000)\n\n#define DMAE_COMP_VAL\t\t\t0x60d0d0ae  \n\n#define MAX_DMAE_C_PER_PORT\t\t8\n#define INIT_DMAE_C(bp)\t\t\t(BP_PORT(bp) * MAX_DMAE_C_PER_PORT + \\\n\t\t\t\t\t BP_VN(bp))\n#define PMF_DMAE_C(bp)\t\t\t(BP_PORT(bp) * MAX_DMAE_C_PER_PORT + \\\n\t\t\t\t\t E1HVN_MAX)\n\n \n#define BNX2X_FW_DMAE_C                 13  \n\n \n#define PCICFG_LINK_WIDTH\t\t0x1f00000\n#define PCICFG_LINK_WIDTH_SHIFT\t\t20\n#define PCICFG_LINK_SPEED\t\t0xf0000\n#define PCICFG_LINK_SPEED_SHIFT\t\t16\n\n#define BNX2X_NUM_TESTS_SF\t\t7\n#define BNX2X_NUM_TESTS_MF\t\t3\n#define BNX2X_NUM_TESTS(bp)\t\t(IS_MF(bp) ? BNX2X_NUM_TESTS_MF : \\\n\t\t\t\t\t     IS_VF(bp) ? 0 : BNX2X_NUM_TESTS_SF)\n\n#define BNX2X_PHY_LOOPBACK\t\t0\n#define BNX2X_MAC_LOOPBACK\t\t1\n#define BNX2X_EXT_LOOPBACK\t\t2\n#define BNX2X_PHY_LOOPBACK_FAILED\t1\n#define BNX2X_MAC_LOOPBACK_FAILED\t2\n#define BNX2X_EXT_LOOPBACK_FAILED\t3\n#define BNX2X_LOOPBACK_FAILED\t\t(BNX2X_MAC_LOOPBACK_FAILED | \\\n\t\t\t\t\t BNX2X_PHY_LOOPBACK_FAILED)\n\n#define STROM_ASSERT_ARRAY_SIZE\t\t50\n\n \n#define HW_CID(bp, x)\t\t\t((BP_PORT(bp) << 23) | \\\n\t\t\t\t\t (BP_VN(bp) << BNX2X_SWCID_SHIFT) | \\\n\t\t\t\t\t (x))\n\n#define SP_DESC_CNT\t\t(BCM_PAGE_SIZE / sizeof(struct eth_spe))\n#define MAX_SP_DESC_CNT\t\t\t(SP_DESC_CNT - 1)\n\n#define BNX2X_BTR\t\t\t4\n#define MAX_SPQ_PENDING\t\t\t8\n\n \n \n#define DEF_MIN_RATE\t\t\t\t\t100\n \n#define RS_PERIODIC_TIMEOUT_USEC\t\t\t400\n \n#define QM_ARB_BYTES\t\t\t\t\t160000\n \n#define MIN_RES\t\t\t\t\t\t100\n \n#define MIN_ABOVE_THRESH\t\t\t\t32768\n \n#define T_FAIR_COEF\t((MIN_ABOVE_THRESH +  QM_ARB_BYTES) * 8 * MIN_RES)\n \n#define FAIR_MEM\t\t\t\t\t2\n\n#define ATTN_NIG_FOR_FUNC\t\t(1L << 8)\n#define ATTN_SW_TIMER_4_FUNC\t\t(1L << 9)\n#define GPIO_2_FUNC\t\t\t(1L << 10)\n#define GPIO_3_FUNC\t\t\t(1L << 11)\n#define GPIO_4_FUNC\t\t\t(1L << 12)\n#define ATTN_GENERAL_ATTN_1\t\t(1L << 13)\n#define ATTN_GENERAL_ATTN_2\t\t(1L << 14)\n#define ATTN_GENERAL_ATTN_3\t\t(1L << 15)\n#define ATTN_GENERAL_ATTN_4\t\t(1L << 13)\n#define ATTN_GENERAL_ATTN_5\t\t(1L << 14)\n#define ATTN_GENERAL_ATTN_6\t\t(1L << 15)\n\n#define ATTN_HARD_WIRED_MASK\t\t0xff00\n#define ATTENTION_ID\t\t\t4\n\n#define IS_MF_STORAGE_ONLY(bp) (IS_MF_STORAGE_PERSONALITY_ONLY(bp) || \\\n\t\t\t\t IS_MF_FCOE_AFEX(bp))\n\n \n\n#define BNX2X_PMF_LINK_ASSERT \\\n\tGENERAL_ATTEN_OFFSET(LINK_SYNC_ATTENTION_BIT_FUNC_0 + BP_FUNC(bp))\n\n#define BNX2X_MC_ASSERT_BITS \\\n\t(GENERAL_ATTEN_OFFSET(TSTORM_FATAL_ASSERT_ATTENTION_BIT) | \\\n\t GENERAL_ATTEN_OFFSET(USTORM_FATAL_ASSERT_ATTENTION_BIT) | \\\n\t GENERAL_ATTEN_OFFSET(CSTORM_FATAL_ASSERT_ATTENTION_BIT) | \\\n\t GENERAL_ATTEN_OFFSET(XSTORM_FATAL_ASSERT_ATTENTION_BIT))\n\n#define BNX2X_MCP_ASSERT \\\n\tGENERAL_ATTEN_OFFSET(MCP_FATAL_ASSERT_ATTENTION_BIT)\n\n#define BNX2X_GRC_TIMEOUT\tGENERAL_ATTEN_OFFSET(LATCHED_ATTN_TIMEOUT_GRC)\n#define BNX2X_GRC_RSV\t\t(GENERAL_ATTEN_OFFSET(LATCHED_ATTN_RBCR) | \\\n\t\t\t\t GENERAL_ATTEN_OFFSET(LATCHED_ATTN_RBCT) | \\\n\t\t\t\t GENERAL_ATTEN_OFFSET(LATCHED_ATTN_RBCN) | \\\n\t\t\t\t GENERAL_ATTEN_OFFSET(LATCHED_ATTN_RBCU) | \\\n\t\t\t\t GENERAL_ATTEN_OFFSET(LATCHED_ATTN_RBCP) | \\\n\t\t\t\t GENERAL_ATTEN_OFFSET(LATCHED_ATTN_RSVD_GRC))\n\n#define HW_INTERRUPT_ASSERT_SET_0 \\\n\t\t\t\t(AEU_INPUTS_ATTN_BITS_TSDM_HW_INTERRUPT | \\\n\t\t\t\t AEU_INPUTS_ATTN_BITS_TCM_HW_INTERRUPT | \\\n\t\t\t\t AEU_INPUTS_ATTN_BITS_TSEMI_HW_INTERRUPT | \\\n\t\t\t\t AEU_INPUTS_ATTN_BITS_BRB_HW_INTERRUPT | \\\n\t\t\t\t AEU_INPUTS_ATTN_BITS_PBCLIENT_HW_INTERRUPT)\n#define HW_PRTY_ASSERT_SET_0\t(AEU_INPUTS_ATTN_BITS_BRB_PARITY_ERROR | \\\n\t\t\t\t AEU_INPUTS_ATTN_BITS_PARSER_PARITY_ERROR | \\\n\t\t\t\t AEU_INPUTS_ATTN_BITS_TSDM_PARITY_ERROR | \\\n\t\t\t\t AEU_INPUTS_ATTN_BITS_SEARCHER_PARITY_ERROR |\\\n\t\t\t\t AEU_INPUTS_ATTN_BITS_TSEMI_PARITY_ERROR |\\\n\t\t\t\t AEU_INPUTS_ATTN_BITS_TCM_PARITY_ERROR |\\\n\t\t\t\t AEU_INPUTS_ATTN_BITS_PBCLIENT_PARITY_ERROR)\n#define HW_INTERRUPT_ASSERT_SET_1 \\\n\t\t\t\t(AEU_INPUTS_ATTN_BITS_QM_HW_INTERRUPT | \\\n\t\t\t\t AEU_INPUTS_ATTN_BITS_TIMERS_HW_INTERRUPT | \\\n\t\t\t\t AEU_INPUTS_ATTN_BITS_XSDM_HW_INTERRUPT | \\\n\t\t\t\t AEU_INPUTS_ATTN_BITS_XCM_HW_INTERRUPT | \\\n\t\t\t\t AEU_INPUTS_ATTN_BITS_XSEMI_HW_INTERRUPT | \\\n\t\t\t\t AEU_INPUTS_ATTN_BITS_USDM_HW_INTERRUPT | \\\n\t\t\t\t AEU_INPUTS_ATTN_BITS_UCM_HW_INTERRUPT | \\\n\t\t\t\t AEU_INPUTS_ATTN_BITS_USEMI_HW_INTERRUPT | \\\n\t\t\t\t AEU_INPUTS_ATTN_BITS_UPB_HW_INTERRUPT | \\\n\t\t\t\t AEU_INPUTS_ATTN_BITS_CSDM_HW_INTERRUPT | \\\n\t\t\t\t AEU_INPUTS_ATTN_BITS_CCM_HW_INTERRUPT)\n#define HW_PRTY_ASSERT_SET_1\t(AEU_INPUTS_ATTN_BITS_PBF_PARITY_ERROR |\\\n\t\t\t\t AEU_INPUTS_ATTN_BITS_QM_PARITY_ERROR | \\\n\t\t\t\t AEU_INPUTS_ATTN_BITS_TIMERS_PARITY_ERROR |\\\n\t\t\t\t AEU_INPUTS_ATTN_BITS_XSDM_PARITY_ERROR | \\\n\t\t\t\t AEU_INPUTS_ATTN_BITS_XCM_PARITY_ERROR |\\\n\t\t\t\t AEU_INPUTS_ATTN_BITS_XSEMI_PARITY_ERROR | \\\n\t\t\t\t AEU_INPUTS_ATTN_BITS_DOORBELLQ_PARITY_ERROR |\\\n\t\t\t\t AEU_INPUTS_ATTN_BITS_NIG_PARITY_ERROR |\\\n\t\t\t     AEU_INPUTS_ATTN_BITS_VAUX_PCI_CORE_PARITY_ERROR |\\\n\t\t\t\t AEU_INPUTS_ATTN_BITS_DEBUG_PARITY_ERROR | \\\n\t\t\t\t AEU_INPUTS_ATTN_BITS_USDM_PARITY_ERROR | \\\n\t\t\t\t AEU_INPUTS_ATTN_BITS_UCM_PARITY_ERROR |\\\n\t\t\t\t AEU_INPUTS_ATTN_BITS_USEMI_PARITY_ERROR | \\\n\t\t\t\t AEU_INPUTS_ATTN_BITS_UPB_PARITY_ERROR | \\\n\t\t\t\t AEU_INPUTS_ATTN_BITS_CSDM_PARITY_ERROR |\\\n\t\t\t\t AEU_INPUTS_ATTN_BITS_CCM_PARITY_ERROR)\n#define HW_INTERRUPT_ASSERT_SET_2 \\\n\t\t\t\t(AEU_INPUTS_ATTN_BITS_CSEMI_HW_INTERRUPT | \\\n\t\t\t\t AEU_INPUTS_ATTN_BITS_CDU_HW_INTERRUPT | \\\n\t\t\t\t AEU_INPUTS_ATTN_BITS_DMAE_HW_INTERRUPT | \\\n\t\t\tAEU_INPUTS_ATTN_BITS_PXPPCICLOCKCLIENT_HW_INTERRUPT |\\\n\t\t\t\t AEU_INPUTS_ATTN_BITS_MISC_HW_INTERRUPT)\n#define HW_PRTY_ASSERT_SET_2\t(AEU_INPUTS_ATTN_BITS_CSEMI_PARITY_ERROR | \\\n\t\t\t\t AEU_INPUTS_ATTN_BITS_PXP_PARITY_ERROR | \\\n\t\t\tAEU_INPUTS_ATTN_BITS_PXPPCICLOCKCLIENT_PARITY_ERROR |\\\n\t\t\t\t AEU_INPUTS_ATTN_BITS_CFC_PARITY_ERROR | \\\n\t\t\t\t AEU_INPUTS_ATTN_BITS_CDU_PARITY_ERROR | \\\n\t\t\t\t AEU_INPUTS_ATTN_BITS_DMAE_PARITY_ERROR |\\\n\t\t\t\t AEU_INPUTS_ATTN_BITS_IGU_PARITY_ERROR | \\\n\t\t\t\t AEU_INPUTS_ATTN_BITS_MISC_PARITY_ERROR)\n\n#define HW_PRTY_ASSERT_SET_3_WITHOUT_SCPAD \\\n\t\t(AEU_INPUTS_ATTN_BITS_MCP_LATCHED_ROM_PARITY | \\\n\t\t AEU_INPUTS_ATTN_BITS_MCP_LATCHED_UMP_RX_PARITY | \\\n\t\t AEU_INPUTS_ATTN_BITS_MCP_LATCHED_UMP_TX_PARITY)\n\n#define HW_PRTY_ASSERT_SET_3 (HW_PRTY_ASSERT_SET_3_WITHOUT_SCPAD | \\\n\t\t\t      AEU_INPUTS_ATTN_BITS_MCP_LATCHED_SCPAD_PARITY)\n\n#define HW_PRTY_ASSERT_SET_4 (AEU_INPUTS_ATTN_BITS_PGLUE_PARITY_ERROR | \\\n\t\t\t      AEU_INPUTS_ATTN_BITS_ATC_PARITY_ERROR)\n\n#define MULTI_MASK\t\t\t0x7f\n\n#define DEF_USB_FUNC_OFF\toffsetof(struct cstorm_def_status_block_u, func)\n#define DEF_CSB_FUNC_OFF\toffsetof(struct cstorm_def_status_block_c, func)\n#define DEF_XSB_FUNC_OFF\toffsetof(struct xstorm_def_status_block, func)\n#define DEF_TSB_FUNC_OFF\toffsetof(struct tstorm_def_status_block, func)\n\n#define DEF_USB_IGU_INDEX_OFF \\\n\t\t\toffsetof(struct cstorm_def_status_block_u, igu_index)\n#define DEF_CSB_IGU_INDEX_OFF \\\n\t\t\toffsetof(struct cstorm_def_status_block_c, igu_index)\n#define DEF_XSB_IGU_INDEX_OFF \\\n\t\t\toffsetof(struct xstorm_def_status_block, igu_index)\n#define DEF_TSB_IGU_INDEX_OFF \\\n\t\t\toffsetof(struct tstorm_def_status_block, igu_index)\n\n#define DEF_USB_SEGMENT_OFF \\\n\t\t\toffsetof(struct cstorm_def_status_block_u, segment)\n#define DEF_CSB_SEGMENT_OFF \\\n\t\t\toffsetof(struct cstorm_def_status_block_c, segment)\n#define DEF_XSB_SEGMENT_OFF \\\n\t\t\toffsetof(struct xstorm_def_status_block, segment)\n#define DEF_TSB_SEGMENT_OFF \\\n\t\t\toffsetof(struct tstorm_def_status_block, segment)\n\n#define BNX2X_SP_DSB_INDEX \\\n\t\t(&bp->def_status_blk->sp_sb.\\\n\t\t\t\t\tindex_values[HC_SP_INDEX_ETH_DEF_CONS])\n\n#define CAM_IS_INVALID(x) \\\n\t(GET_FLAG(x.flags, \\\n\tMAC_CONFIGURATION_ENTRY_ACTION_TYPE) == \\\n\t(T_ETH_MAC_COMMAND_INVALIDATE))\n\n \n#define MC_HASH_SIZE\t\t\t8\n#define MC_HASH_OFFSET(bp, i)\t\t(BAR_TSTRORM_INTMEM + \\\n\tTSTORM_APPROXIMATE_MATCH_MULTICAST_FILTERING_OFFSET(BP_FUNC(bp)) + i*4)\n\n#ifndef PXP2_REG_PXP2_INT_STS\n#define PXP2_REG_PXP2_INT_STS\t\tPXP2_REG_PXP2_INT_STS_0\n#endif\n\n#ifndef ETH_MAX_RX_CLIENTS_E2\n#define ETH_MAX_RX_CLIENTS_E2\t\tETH_MAX_RX_CLIENTS_E1H\n#endif\n\n#define VENDOR_ID_LEN\t\t\t4\n\n#define VF_ACQUIRE_THRESH\t\t3\n#define VF_ACQUIRE_MAC_FILTERS\t\t1\n#define VF_ACQUIRE_MC_FILTERS\t\t10\n#define VF_ACQUIRE_VLAN_FILTERS\t\t2  \n\n#define GOOD_ME_REG(me_reg) (((me_reg) & ME_REG_VF_VALID) && \\\n\t\t\t    (!((me_reg) & ME_REG_VF_ERR)))\nint bnx2x_compare_fw_ver(struct bnx2x *bp, u32 load_code, bool print_err);\n\n \n#define CMNG_FNS_NONE\t\t\t0\n#define CMNG_FNS_MINMAX\t\t\t1\n\n#define HC_SEG_ACCESS_DEF\t\t0    \n#define HC_SEG_ACCESS_ATTN\t\t4\n#define HC_SEG_ACCESS_NORM\t\t0    \n\nvoid bnx2x_set_ethtool_ops(struct bnx2x *bp, struct net_device *netdev);\nvoid bnx2x_notify_link_changed(struct bnx2x *bp);\n\n#define BNX2X_MF_SD_PROTOCOL(bp) \\\n\t((bp)->mf_config[BP_VN(bp)] & FUNC_MF_CFG_PROTOCOL_MASK)\n\n#define BNX2X_IS_MF_SD_PROTOCOL_ISCSI(bp) \\\n\t(BNX2X_MF_SD_PROTOCOL(bp) == FUNC_MF_CFG_PROTOCOL_ISCSI)\n\n#define BNX2X_IS_MF_SD_PROTOCOL_FCOE(bp) \\\n\t(BNX2X_MF_SD_PROTOCOL(bp) == FUNC_MF_CFG_PROTOCOL_FCOE)\n\n#define IS_MF_ISCSI_SD(bp) (IS_MF_SD(bp) && BNX2X_IS_MF_SD_PROTOCOL_ISCSI(bp))\n#define IS_MF_FCOE_SD(bp) (IS_MF_SD(bp) && BNX2X_IS_MF_SD_PROTOCOL_FCOE(bp))\n#define IS_MF_ISCSI_SI(bp) (IS_MF_SI(bp) && BNX2X_IS_MF_EXT_PROTOCOL_ISCSI(bp))\n\n#define IS_MF_ISCSI_ONLY(bp)    (IS_MF_ISCSI_SD(bp) ||  IS_MF_ISCSI_SI(bp))\n\n#define BNX2X_MF_EXT_PROTOCOL_MASK\t\t\t\t\t\\\n\t\t\t\t(MACP_FUNC_CFG_FLAGS_ETHERNET |\t\t\\\n\t\t\t\t MACP_FUNC_CFG_FLAGS_ISCSI_OFFLOAD |\t\\\n\t\t\t\t MACP_FUNC_CFG_FLAGS_FCOE_OFFLOAD)\n\n#define BNX2X_MF_EXT_PROT(bp)\t((bp)->mf_ext_config &\t\t\t\\\n\t\t\t\t BNX2X_MF_EXT_PROTOCOL_MASK)\n\n#define BNX2X_HAS_MF_EXT_PROTOCOL_FCOE(bp)\t\t\t\t\\\n\t\t(BNX2X_MF_EXT_PROT(bp) & MACP_FUNC_CFG_FLAGS_FCOE_OFFLOAD)\n\n#define BNX2X_IS_MF_EXT_PROTOCOL_FCOE(bp)\t\t\t\t\\\n\t\t(BNX2X_MF_EXT_PROT(bp) == MACP_FUNC_CFG_FLAGS_FCOE_OFFLOAD)\n\n#define BNX2X_IS_MF_EXT_PROTOCOL_ISCSI(bp)\t\t\t\t\\\n\t\t(BNX2X_MF_EXT_PROT(bp) == MACP_FUNC_CFG_FLAGS_ISCSI_OFFLOAD)\n\n#define IS_MF_FCOE_AFEX(bp)\t\t\t\t\t\t\\\n\t\t(IS_MF_AFEX(bp) && BNX2X_IS_MF_EXT_PROTOCOL_FCOE(bp))\n\n#define IS_MF_SD_STORAGE_PERSONALITY_ONLY(bp)\t\t\t\t\\\n\t\t\t\t(IS_MF_SD(bp) &&\t\t\t\\\n\t\t\t\t (BNX2X_IS_MF_SD_PROTOCOL_ISCSI(bp) ||\t\\\n\t\t\t\t  BNX2X_IS_MF_SD_PROTOCOL_FCOE(bp)))\n\n#define IS_MF_SI_STORAGE_PERSONALITY_ONLY(bp)\t\t\t\t\\\n\t\t\t\t(IS_MF_SI(bp) &&\t\t\t\\\n\t\t\t\t (BNX2X_IS_MF_EXT_PROTOCOL_ISCSI(bp) ||\t\\\n\t\t\t\t  BNX2X_IS_MF_EXT_PROTOCOL_FCOE(bp)))\n\n#define IS_MF_STORAGE_PERSONALITY_ONLY(bp)\t\t\t\t\\\n\t\t\t(IS_MF_SD_STORAGE_PERSONALITY_ONLY(bp) ||\t\\\n\t\t\t IS_MF_SI_STORAGE_PERSONALITY_ONLY(bp))\n\n \n#define IS_MF_PERCENT_BW(bp) (IS_MF_SI(bp) || IS_MF_UFP(bp) || IS_MF_BD(bp))\n\n#define SET_FLAG(value, mask, flag) \\\n\tdo {\\\n\t\t(value) &= ~(mask);\\\n\t\t(value) |= ((flag) << (mask##_SHIFT));\\\n\t} while (0)\n\n#define GET_FLAG(value, mask) \\\n\t(((value) & (mask)) >> (mask##_SHIFT))\n\n#define GET_FIELD(value, fname) \\\n\t(((value) & (fname##_MASK)) >> (fname##_SHIFT))\n\nenum {\n\tSWITCH_UPDATE,\n\tAFEX_UPDATE,\n};\n\n#define NUM_MACS\t8\n\nvoid bnx2x_set_local_cmng(struct bnx2x *bp);\n\nvoid bnx2x_update_mng_version(struct bnx2x *bp);\n\nvoid bnx2x_update_mfw_dump(struct bnx2x *bp);\n\n#define MCPR_SCRATCH_BASE(bp) \\\n\t(CHIP_IS_E1x(bp) ? MCP_REG_MCPR_SCRATCH : MCP_A_REG_MCPR_SCRATCH)\n\n#define E1H_MAX_MF_SB_COUNT (HC_SB_MAX_SB_E1X/(E1HVN_MAX * PORT_MAX))\n\nvoid bnx2x_init_ptp(struct bnx2x *bp);\nint bnx2x_configure_ptp_filters(struct bnx2x *bp);\nvoid bnx2x_set_rx_ts(struct bnx2x *bp, struct sk_buff *skb);\nvoid bnx2x_register_phc(struct bnx2x *bp);\n\n#define BNX2X_MAX_PHC_DRIFT 31000000\n#define BNX2X_PTP_TX_TIMEOUT\n\n \nint bnx2x_vlan_reconfigure_vid(struct bnx2x *bp);\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}