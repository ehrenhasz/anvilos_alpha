{
  "module_name": "bnx2x_init.h",
  "hash_id": "1277fb2b958a3374694aae17c407f1b6c48c3a3a341506e63cbc03481f81d07c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/broadcom/bnx2x/bnx2x_init.h",
  "human_readable_source": " \n\n#ifndef BNX2X_INIT_H\n#define BNX2X_INIT_H\n\n \nenum {\n\tOP_RD = 0x1,\t \n\tOP_WR,\t\t \n\tOP_SW,\t\t \n\tOP_ZR,\t\t \n\tOP_ZP,\t\t \n\tOP_WR_64,\t \n\tOP_WB,\t\t \n\tOP_WB_ZR,\t \n\t \n\tOP_IF_MODE_OR,\n\t \n\tOP_IF_MODE_AND,\n\tOP_MAX\n};\n\nenum {\n\tSTAGE_START,\n\tSTAGE_END,\n};\n\n \n#define BLOCK_OPS_IDX(block, stage, end) \\\n\t(2*(((block)*NUM_OF_INIT_PHASES) + (stage)) + (end))\n\n\n \nstruct raw_op {\n\tu32 op:8;\n\tu32 offset:24;\n\tu32 raw_data;\n};\n\nstruct op_read {\n\tu32 op:8;\n\tu32 offset:24;\n\tu32 val;\n};\n\nstruct op_write {\n\tu32 op:8;\n\tu32 offset:24;\n\tu32 val;\n};\n\nstruct op_arr_write {\n\tu32 op:8;\n\tu32 offset:24;\n#ifdef __BIG_ENDIAN\n\tu16 data_len;\n\tu16 data_off;\n#else  \n\tu16 data_off;\n\tu16 data_len;\n#endif\n};\n\nstruct op_zero {\n\tu32 op:8;\n\tu32 offset:24;\n\tu32 len;\n};\n\nstruct op_if_mode {\n\tu32 op:8;\n\tu32 cmd_offset:24;\n\tu32 mode_bit_map;\n};\n\n\nunion init_op {\n\tstruct op_read\t\tread;\n\tstruct op_write\t\twrite;\n\tstruct op_arr_write\tarr_wr;\n\tstruct op_zero\t\tzero;\n\tstruct raw_op\t\traw;\n\tstruct op_if_mode\tif_mode;\n};\n\n\n \nenum {\n\tPHASE_COMMON,\n\tPHASE_PORT0,\n\tPHASE_PORT1,\n\tPHASE_PF0,\n\tPHASE_PF1,\n\tPHASE_PF2,\n\tPHASE_PF3,\n\tPHASE_PF4,\n\tPHASE_PF5,\n\tPHASE_PF6,\n\tPHASE_PF7,\n\tNUM_OF_INIT_PHASES\n};\n\n \nenum {\n\tMODE_ASIC                      = 0x00000001,\n\tMODE_FPGA                      = 0x00000002,\n\tMODE_EMUL                      = 0x00000004,\n\tMODE_E2                        = 0x00000008,\n\tMODE_E3                        = 0x00000010,\n\tMODE_PORT2                     = 0x00000020,\n\tMODE_PORT4                     = 0x00000040,\n\tMODE_SF                        = 0x00000080,\n\tMODE_MF                        = 0x00000100,\n\tMODE_MF_SD                     = 0x00000200,\n\tMODE_MF_SI                     = 0x00000400,\n\tMODE_MF_AFEX                   = 0x00000800,\n\tMODE_E3_A0                     = 0x00001000,\n\tMODE_E3_B0                     = 0x00002000,\n\tMODE_COS3                      = 0x00004000,\n\tMODE_COS6                      = 0x00008000,\n\tMODE_LITTLE_ENDIAN             = 0x00010000,\n\tMODE_BIG_ENDIAN                = 0x00020000,\n};\n\n \nenum {\n\tBLOCK_ATC,\n\tBLOCK_BRB1,\n\tBLOCK_CCM,\n\tBLOCK_CDU,\n\tBLOCK_CFC,\n\tBLOCK_CSDM,\n\tBLOCK_CSEM,\n\tBLOCK_DBG,\n\tBLOCK_DMAE,\n\tBLOCK_DORQ,\n\tBLOCK_HC,\n\tBLOCK_IGU,\n\tBLOCK_MISC,\n\tBLOCK_NIG,\n\tBLOCK_PBF,\n\tBLOCK_PGLUE_B,\n\tBLOCK_PRS,\n\tBLOCK_PXP2,\n\tBLOCK_PXP,\n\tBLOCK_QM,\n\tBLOCK_SRC,\n\tBLOCK_TCM,\n\tBLOCK_TM,\n\tBLOCK_TSDM,\n\tBLOCK_TSEM,\n\tBLOCK_UCM,\n\tBLOCK_UPB,\n\tBLOCK_USDM,\n\tBLOCK_USEM,\n\tBLOCK_XCM,\n\tBLOCK_XPB,\n\tBLOCK_XSDM,\n\tBLOCK_XSEM,\n\tBLOCK_MISC_AEU,\n\tNUM_OF_INIT_BLOCKS\n};\n\n \n#define BNX2X_ETH_Q\t\t0\n#define BNX2X_TOE_Q\t\t3\n#define BNX2X_TOE_ACK_Q\t\t6\n#define BNX2X_ISCSI_Q\t\t9\n#define BNX2X_ISCSI_ACK_Q\t11\n#define BNX2X_FCOE_Q\t\t10\n\n \n#define BNX2X_PORT2_MODE_NUM_VNICS 4\n#define BNX2X_PORT4_MODE_NUM_VNICS 2\n\n \n#define BNX2X_E3B0_PORT1_COS_OFFSET 3\n\n \n#define BNX2X_Q_VOQ_REG_ADDR(pf_q_num)\\\n\t(QM_REG_QVOQIDX_0 + 4 * (pf_q_num))\n#define BNX2X_VOQ_Q_REG_ADDR(cos, pf_q_num)\\\n\t(QM_REG_VOQQMASK_0_LSB + 4 * ((cos) * 2 + ((pf_q_num) >> 5)))\n#define BNX2X_Q_CMDQ_REG_ADDR(pf_q_num)\\\n\t(QM_REG_BYTECRDCMDQ_0 + 4 * ((pf_q_num) >> 4))\n\n \n#define BNX2X_PF_Q_NUM(q_num, port, vnic)\\\n\t((((port) << 1) | (vnic)) * 16 + (q_num))\n\n\n \nstatic inline void bnx2x_map_q_cos(struct bnx2x *bp, u32 q_num, u32 new_cos)\n{\n\t \n\tu32 curr_cos = REG_RD(bp, QM_REG_QVOQIDX_0 + q_num * 4);\n\n\t \n\tif (curr_cos != new_cos) {\n\t\tu32 num_vnics = BNX2X_PORT2_MODE_NUM_VNICS;\n\t\tu32 reg_addr, reg_bit_map, vnic;\n\n\t\t \n\t\tif (INIT_MODE_FLAGS(bp) & MODE_PORT4) {\n\t\t\tnum_vnics = BNX2X_PORT4_MODE_NUM_VNICS;\n\t\t\tif (BP_PORT(bp)) {\n\t\t\t\tcurr_cos += BNX2X_E3B0_PORT1_COS_OFFSET;\n\t\t\t\tnew_cos += BNX2X_E3B0_PORT1_COS_OFFSET;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tfor (vnic = 0; vnic < num_vnics; vnic++) {\n\t\t\tu32 pf_q_num =\n\t\t\t\tBNX2X_PF_Q_NUM(q_num, BP_PORT(bp), vnic);\n\t\t\tu32 q_bit_map = 1 << (pf_q_num & 0x1f);\n\n\t\t\t \n\t\t\tREG_WR(bp, BNX2X_Q_VOQ_REG_ADDR(pf_q_num), new_cos);\n\n\t\t\t \n\t\t\treg_addr = BNX2X_VOQ_Q_REG_ADDR(curr_cos, pf_q_num);\n\t\t\treg_bit_map = REG_RD(bp, reg_addr);\n\t\t\tREG_WR(bp, reg_addr, reg_bit_map & (~q_bit_map));\n\n\t\t\t \n\t\t\treg_addr = BNX2X_VOQ_Q_REG_ADDR(new_cos, pf_q_num);\n\t\t\treg_bit_map = REG_RD(bp, reg_addr);\n\t\t\tREG_WR(bp, reg_addr, reg_bit_map | q_bit_map);\n\n\t\t\t \n\t\t\tif (!(INIT_MODE_FLAGS(bp) & MODE_E3_B0)) {\n\t\t\t\treg_addr = BNX2X_Q_CMDQ_REG_ADDR(pf_q_num);\n\t\t\t\treg_bit_map = REG_RD(bp, reg_addr);\n\t\t\t\tq_bit_map = 1 << (2 * (pf_q_num & 0xf));\n\t\t\t\treg_bit_map = new_cos ?\n\t\t\t\t\t      (reg_bit_map | q_bit_map) :\n\t\t\t\t\t      (reg_bit_map & (~q_bit_map));\n\t\t\t\tREG_WR(bp, reg_addr, reg_bit_map);\n\t\t\t}\n\t\t}\n\t}\n}\n\n \nstatic inline void bnx2x_dcb_config_qm(struct bnx2x *bp, enum cos_mode mode,\n\t\t\t\t       struct priority_cos *traffic_cos)\n{\n\tbnx2x_map_q_cos(bp, BNX2X_FCOE_Q,\n\t\t\ttraffic_cos[LLFC_TRAFFIC_TYPE_FCOE].cos);\n\tbnx2x_map_q_cos(bp, BNX2X_ISCSI_Q,\n\t\t\ttraffic_cos[LLFC_TRAFFIC_TYPE_ISCSI].cos);\n\tbnx2x_map_q_cos(bp, BNX2X_ISCSI_ACK_Q,\n\t\ttraffic_cos[LLFC_TRAFFIC_TYPE_ISCSI].cos);\n\tif (mode != STATIC_COS) {\n\t\t \n\t\tbnx2x_map_q_cos(bp, BNX2X_ETH_Q,\n\t\t\t\ttraffic_cos[LLFC_TRAFFIC_TYPE_NW].cos);\n\t\tbnx2x_map_q_cos(bp, BNX2X_TOE_Q,\n\t\t\t\ttraffic_cos[LLFC_TRAFFIC_TYPE_NW].cos);\n\t\tbnx2x_map_q_cos(bp, BNX2X_TOE_ACK_Q,\n\t\t\t\ttraffic_cos[LLFC_TRAFFIC_TYPE_NW].cos);\n\t}\n}\n\n\n \n\n \n\n \n#define DEF_MIN_RATE 100\n\n \n#define RS_PERIODIC_TIMEOUT_USEC 400\n\n \n#define QM_ARB_BYTES 160000\n\n \n#define MIN_RES 100\n\n \n#define MIN_ABOVE_THRESH 32768\n\n \n#define T_FAIR_COEF ((MIN_ABOVE_THRESH + QM_ARB_BYTES) * 8 * MIN_RES)\n\n \n#define FAIR_MEM 2\n#define SAFC_TIMEOUT_USEC 52\n\n#define SDM_TICKS 4\n\n\nstatic inline void bnx2x_init_max(const struct cmng_init_input *input_data,\n\t\t\t\t  u32 r_param, struct cmng_init *ram_data)\n{\n\tu32 vnic;\n\tstruct cmng_vnic *vdata = &ram_data->vnic;\n\tstruct cmng_struct_per_port *pdata = &ram_data->port;\n\t \n\n\tpdata->rs_vars.rs_periodic_timeout =\n\tRS_PERIODIC_TIMEOUT_USEC / SDM_TICKS;\n\n\t \n\tpdata->rs_vars.rs_threshold =\n\t(5 * RS_PERIODIC_TIMEOUT_USEC * r_param)/4;\n\n\t \n\tfor (vnic = 0; vnic < BNX2X_PORT2_MODE_NUM_VNICS; vnic++) {\n\t\t \n\t\tvdata->vnic_max_rate[vnic].vn_counter.rate =\n\t\tinput_data->vnic_max_rate[vnic];\n\t\t \n\t\tvdata->vnic_max_rate[vnic].vn_counter.quota =\n\t\t\tRS_PERIODIC_TIMEOUT_USEC *\n\t\t\t(u32)vdata->vnic_max_rate[vnic].vn_counter.rate / 8;\n\t}\n\n}\n\nstatic inline void bnx2x_init_min(const struct cmng_init_input *input_data,\n\t\t\t\t  u32 r_param, struct cmng_init *ram_data)\n{\n\tu32 vnic, fair_periodic_timeout_usec, vnicWeightSum, tFair;\n\tstruct cmng_vnic *vdata = &ram_data->vnic;\n\tstruct cmng_struct_per_port *pdata = &ram_data->port;\n\n\t \n\tfair_periodic_timeout_usec = QM_ARB_BYTES / r_param;\n\n\t \n\ttFair = T_FAIR_COEF / input_data->port_rate;\n\n\t \n\tpdata->fair_vars.fair_threshold = QM_ARB_BYTES;\n\n\t \n\tpdata->fair_vars.upper_bound = r_param * tFair * FAIR_MEM;\n\n\t \n\tpdata->fair_vars.fairness_timeout =\n\t\t\t\tfair_periodic_timeout_usec / SDM_TICKS;\n\n\t \n\tvnicWeightSum = 0;\n\n\tfor (vnic = 0; vnic < BNX2X_PORT2_MODE_NUM_VNICS; vnic++)\n\t\tvnicWeightSum += input_data->vnic_min_rate[vnic];\n\n\t \n\tif (vnicWeightSum > 0) {\n\t\t \n\t\tfor (vnic = 0; vnic < BNX2X_PORT2_MODE_NUM_VNICS; vnic++) {\n\t\t\t \n\t\t\tvdata->vnic_min_rate[vnic].vn_credit_delta =\n\t\t\t\t(u32)input_data->vnic_min_rate[vnic] * 100 *\n\t\t\t\t(T_FAIR_COEF / (8 * 100 * vnicWeightSum));\n\t\t\tif (vdata->vnic_min_rate[vnic].vn_credit_delta <\n\t\t\t    pdata->fair_vars.fair_threshold +\n\t\t\t    MIN_ABOVE_THRESH) {\n\t\t\t\tvdata->vnic_min_rate[vnic].vn_credit_delta =\n\t\t\t\t\tpdata->fair_vars.fair_threshold +\n\t\t\t\t\tMIN_ABOVE_THRESH;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic inline void bnx2x_init_fw_wrr(const struct cmng_init_input *input_data,\n\t\t\t\t     u32 r_param, struct cmng_init *ram_data)\n{\n\tu32 vnic, cos;\n\tu32 cosWeightSum = 0;\n\tstruct cmng_vnic *vdata = &ram_data->vnic;\n\tstruct cmng_struct_per_port *pdata = &ram_data->port;\n\n\tfor (cos = 0; cos < MAX_COS_NUMBER; cos++)\n\t\tcosWeightSum += input_data->cos_min_rate[cos];\n\n\tif (cosWeightSum > 0) {\n\n\t\tfor (vnic = 0; vnic < BNX2X_PORT2_MODE_NUM_VNICS; vnic++) {\n\t\t\t \n\t\t\tu32 *ccd = vdata->vnic_min_rate[vnic].cos_credit_delta;\n\t\t\tfor (cos = 0; cos < MAX_COS_NUMBER; cos++) {\n\t\t\t\t \n\t\t\t\tccd[cos] =\n\t\t\t\t    (u32)input_data->cos_min_rate[cos] * 100 *\n\t\t\t\t    (T_FAIR_COEF / (8 * 100 * cosWeightSum));\n\t\t\t\tif (ccd[cos] < pdata->fair_vars.fair_threshold\n\t\t\t\t\t\t+ MIN_ABOVE_THRESH) {\n\t\t\t\t\tccd[cos] =\n\t\t\t\t\t    pdata->fair_vars.fair_threshold +\n\t\t\t\t\t    MIN_ABOVE_THRESH;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic inline void bnx2x_init_safc(const struct cmng_init_input *input_data,\n\t\t\t\t   struct cmng_init *ram_data)\n{\n\t \n\tram_data->port.safc_vars.safc_timeout_usec = SAFC_TIMEOUT_USEC;\n}\n\n \nstatic inline void bnx2x_init_cmng(const struct cmng_init_input *input_data,\n\t\t\t\t   struct cmng_init *ram_data)\n{\n\tu32 r_param;\n\tmemset(ram_data, 0, sizeof(struct cmng_init));\n\n\tram_data->port.flags = input_data->flags;\n\n\t \n\tr_param = BITS_TO_BYTES(input_data->port_rate);\n\tbnx2x_init_max(input_data, r_param, ram_data);\n\tbnx2x_init_min(input_data, r_param, ram_data);\n\tbnx2x_init_fw_wrr(input_data, r_param, ram_data);\n\tbnx2x_init_safc(input_data, ram_data);\n}\n\n\n\n \n#define BLOCK_OPS_IDX(block, stage, end) \\\n\t\t\t(2*(((block)*NUM_OF_INIT_PHASES) + (stage)) + (end))\n\n\n#define INITOP_SET\t\t0\t \n#define INITOP_CLEAR\t\t1\t \n#define INITOP_INIT\t\t2\t \n\n \nstruct ilt_line {\n\tdma_addr_t page_mapping;\n\tvoid *page;\n\tu32 size;\n};\n\nstruct ilt_client_info {\n\tu32 page_size;\n\tu16 start;\n\tu16 end;\n\tu16 client_num;\n\tu16 flags;\n#define ILT_CLIENT_SKIP_INIT\t0x1\n#define ILT_CLIENT_SKIP_MEM\t0x2\n};\n\nstruct bnx2x_ilt {\n\tu32 start_line;\n\tstruct ilt_line\t\t*lines;\n\tstruct ilt_client_info\tclients[4];\n#define ILT_CLIENT_CDU\t0\n#define ILT_CLIENT_QM\t1\n#define ILT_CLIENT_SRC\t2\n#define ILT_CLIENT_TM\t3\n};\n\n \nstruct src_ent {\n\tu8 opaque[56];\n\tu64 next;\n};\n\n \n#define BLOCK_PRTY_INFO(block, en_mask, m1, m1h, m2, m3) \\\n{ \\\n\tblock##_REG_##block##_PRTY_MASK, \\\n\tblock##_REG_##block##_PRTY_STS_CLR, \\\n\ten_mask, {m1, m1h, m2, m3}, #block \\\n}\n\n#define BLOCK_PRTY_INFO_0(block, en_mask, m1, m1h, m2, m3) \\\n{ \\\n\tblock##_REG_##block##_PRTY_MASK_0, \\\n\tblock##_REG_##block##_PRTY_STS_CLR_0, \\\n\ten_mask, {m1, m1h, m2, m3}, #block\"_0\" \\\n}\n\n#define BLOCK_PRTY_INFO_1(block, en_mask, m1, m1h, m2, m3) \\\n{ \\\n\tblock##_REG_##block##_PRTY_MASK_1, \\\n\tblock##_REG_##block##_PRTY_STS_CLR_1, \\\n\ten_mask, {m1, m1h, m2, m3}, #block\"_1\" \\\n}\n\nstatic const struct {\n\tu32 mask_addr;\n\tu32 sts_clr_addr;\n\tu32 en_mask;\t\t \n\tstruct {\n\t\tu32 e1;\t\t \n\t\tu32 e1h;\t \n\t\tu32 e2;\t\t \n\t\tu32 e3;\t\t \n\t} reg_mask;\t\t \n\tchar name[8];\t\t \n} bnx2x_blocks_parity_data[] = {\n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\n\t \n\tBLOCK_PRTY_INFO(PXP, 0x7ffffff, 0x3ffffff, 0x3ffffff, 0x7ffffff,\n\t\t\t0x7ffffff),\n\tBLOCK_PRTY_INFO_0(PXP2,\t0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,\n\t\t\t  0xffffffff),\n\tBLOCK_PRTY_INFO_1(PXP2,\t0x1ffffff, 0x7f, 0x7f, 0x7ff, 0x1ffffff),\n\tBLOCK_PRTY_INFO(HC, 0x7, 0x7, 0x7, 0, 0),\n\tBLOCK_PRTY_INFO(NIG, 0xffffffff, 0x3fffffff, 0xffffffff, 0, 0),\n\tBLOCK_PRTY_INFO_0(NIG,\t0xffffffff, 0, 0, 0xffffffff, 0xffffffff),\n\tBLOCK_PRTY_INFO_1(NIG,\t0xffff, 0, 0, 0xff, 0xffff),\n\tBLOCK_PRTY_INFO(IGU, 0x7ff, 0, 0, 0x7ff, 0x7ff),\n\tBLOCK_PRTY_INFO(MISC, 0x1, 0x1, 0x1, 0x1, 0x1),\n\tBLOCK_PRTY_INFO(QM, 0, 0x1ff, 0xfff, 0xfff, 0xfff),\n\tBLOCK_PRTY_INFO(ATC, 0x1f, 0, 0, 0x1f, 0x1f),\n\tBLOCK_PRTY_INFO(PGLUE_B, 0x3, 0, 0, 0x3, 0x3),\n\tBLOCK_PRTY_INFO(DORQ, 0, 0x3, 0x3, 0x3, 0x3),\n\t{GRCBASE_UPB + PB_REG_PB_PRTY_MASK,\n\t\tGRCBASE_UPB + PB_REG_PB_PRTY_STS_CLR, 0xf,\n\t\t{0xf, 0xf, 0xf, 0xf}, \"UPB\"},\n\t{GRCBASE_XPB + PB_REG_PB_PRTY_MASK,\n\t\tGRCBASE_XPB + PB_REG_PB_PRTY_STS_CLR, 0,\n\t\t{0xf, 0xf, 0xf, 0xf}, \"XPB\"},\n\tBLOCK_PRTY_INFO(SRC, 0x4, 0x7, 0x7, 0x7, 0x7),\n\tBLOCK_PRTY_INFO(CDU, 0, 0x1f, 0x1f, 0x1f, 0x1f),\n\tBLOCK_PRTY_INFO(CFC, 0, 0xf, 0xf, 0xf, 0x3f),\n\tBLOCK_PRTY_INFO(DBG, 0, 0x1, 0x1, 0x1, 0x1),\n\tBLOCK_PRTY_INFO(DMAE, 0, 0xf, 0xf, 0xf, 0xf),\n\tBLOCK_PRTY_INFO(BRB1, 0, 0xf, 0xf, 0xf, 0xf),\n\tBLOCK_PRTY_INFO(PRS, (1<<6), 0xff, 0xff, 0xff, 0xff),\n\tBLOCK_PRTY_INFO(PBF, 0, 0, 0x3ffff, 0xfffff, 0xfffffff),\n\tBLOCK_PRTY_INFO(TM, 0, 0, 0x7f, 0x7f, 0x7f),\n\tBLOCK_PRTY_INFO(TSDM, 0x18, 0x7ff, 0x7ff, 0x7ff, 0x7ff),\n\tBLOCK_PRTY_INFO(CSDM, 0x8, 0x7ff, 0x7ff, 0x7ff, 0x7ff),\n\tBLOCK_PRTY_INFO(USDM, 0x38, 0x7ff, 0x7ff, 0x7ff, 0x7ff),\n\tBLOCK_PRTY_INFO(XSDM, 0x8, 0x7ff, 0x7ff, 0x7ff, 0x7ff),\n\tBLOCK_PRTY_INFO(TCM, 0, 0, 0x7ffffff, 0x7ffffff, 0x7ffffff),\n\tBLOCK_PRTY_INFO(CCM, 0, 0, 0x7ffffff, 0x7ffffff, 0x7ffffff),\n\tBLOCK_PRTY_INFO(UCM, 0, 0, 0x7ffffff, 0x7ffffff, 0x7ffffff),\n\tBLOCK_PRTY_INFO(XCM, 0, 0, 0x3fffffff, 0x3fffffff, 0x3fffffff),\n\tBLOCK_PRTY_INFO_0(TSEM, 0, 0xffffffff, 0xffffffff, 0xffffffff,\n\t\t\t  0xffffffff),\n\tBLOCK_PRTY_INFO_1(TSEM, 0, 0x3, 0x1f, 0x3f, 0x3f),\n\tBLOCK_PRTY_INFO_0(USEM, 0, 0xffffffff, 0xffffffff, 0xffffffff,\n\t\t\t  0xffffffff),\n\tBLOCK_PRTY_INFO_1(USEM, 0, 0x3, 0x1f, 0x1f, 0x1f),\n\tBLOCK_PRTY_INFO_0(CSEM, 0, 0xffffffff, 0xffffffff, 0xffffffff,\n\t\t\t  0xffffffff),\n\tBLOCK_PRTY_INFO_1(CSEM, 0, 0x3, 0x1f, 0x1f, 0x1f),\n\tBLOCK_PRTY_INFO_0(XSEM, 0, 0xffffffff, 0xffffffff, 0xffffffff,\n\t\t\t  0xffffffff),\n\tBLOCK_PRTY_INFO_1(XSEM, 0, 0x3, 0x1f, 0x3f, 0x3f),\n};\n\n\n \n#define MISC_AEU_ENABLE_MCP_PRTY_SUB_BITS\t\\\n\t(AEU_INPUTS_ATTN_BITS_MCP_LATCHED_ROM_PARITY | \\\n\t AEU_INPUTS_ATTN_BITS_MCP_LATCHED_UMP_RX_PARITY | \\\n\t AEU_INPUTS_ATTN_BITS_MCP_LATCHED_UMP_TX_PARITY)\n\n#define MISC_AEU_ENABLE_MCP_PRTY_BITS\t\\\n\t(MISC_AEU_ENABLE_MCP_PRTY_SUB_BITS | \\\n\t AEU_INPUTS_ATTN_BITS_MCP_LATCHED_SCPAD_PARITY)\n\n \nstatic const struct {\n\tu32 addr;\n\tu32 bits;\n} mcp_attn_ctl_regs[] = {\n\t{ MISC_REG_AEU_ENABLE4_FUNC_0_OUT_0,\n\t\tMISC_AEU_ENABLE_MCP_PRTY_BITS },\n\t{ MISC_REG_AEU_ENABLE4_NIG_0,\n\t\tMISC_AEU_ENABLE_MCP_PRTY_SUB_BITS },\n\t{ MISC_REG_AEU_ENABLE4_PXP_0,\n\t\tMISC_AEU_ENABLE_MCP_PRTY_SUB_BITS },\n\t{ MISC_REG_AEU_ENABLE4_FUNC_1_OUT_0,\n\t\tMISC_AEU_ENABLE_MCP_PRTY_BITS },\n\t{ MISC_REG_AEU_ENABLE4_NIG_1,\n\t\tMISC_AEU_ENABLE_MCP_PRTY_SUB_BITS },\n\t{ MISC_REG_AEU_ENABLE4_PXP_1,\n\t\tMISC_AEU_ENABLE_MCP_PRTY_SUB_BITS }\n};\n\nstatic inline void bnx2x_set_mcp_parity(struct bnx2x *bp, u8 enable)\n{\n\tint i;\n\tu32 reg_val;\n\n\tfor (i = 0; i < ARRAY_SIZE(mcp_attn_ctl_regs); i++) {\n\t\treg_val = REG_RD(bp, mcp_attn_ctl_regs[i].addr);\n\n\t\tif (enable)\n\t\t\treg_val |= mcp_attn_ctl_regs[i].bits;\n\t\telse\n\t\t\treg_val &= ~mcp_attn_ctl_regs[i].bits;\n\n\t\tREG_WR(bp, mcp_attn_ctl_regs[i].addr, reg_val);\n\t}\n}\n\nstatic inline u32 bnx2x_parity_reg_mask(struct bnx2x *bp, int idx)\n{\n\tif (CHIP_IS_E1(bp))\n\t\treturn bnx2x_blocks_parity_data[idx].reg_mask.e1;\n\telse if (CHIP_IS_E1H(bp))\n\t\treturn bnx2x_blocks_parity_data[idx].reg_mask.e1h;\n\telse if (CHIP_IS_E2(bp))\n\t\treturn bnx2x_blocks_parity_data[idx].reg_mask.e2;\n\telse  \n\t\treturn bnx2x_blocks_parity_data[idx].reg_mask.e3;\n}\n\nstatic inline void bnx2x_disable_blocks_parity(struct bnx2x *bp)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(bnx2x_blocks_parity_data); i++) {\n\t\tu32 dis_mask = bnx2x_parity_reg_mask(bp, i);\n\n\t\tif (dis_mask) {\n\t\t\tREG_WR(bp, bnx2x_blocks_parity_data[i].mask_addr,\n\t\t\t       dis_mask);\n\t\t\tDP(NETIF_MSG_HW, \"Setting parity mask \"\n\t\t\t\t\t\t \"for %s to\\t\\t0x%x\\n\",\n\t\t\t\t    bnx2x_blocks_parity_data[i].name, dis_mask);\n\t\t}\n\t}\n\n\t \n\tbnx2x_set_mcp_parity(bp, false);\n}\n\n \nstatic inline void bnx2x_clear_blocks_parity(struct bnx2x *bp)\n{\n\tint i;\n\tu32 reg_val, mcp_aeu_bits =\n\t\tAEU_INPUTS_ATTN_BITS_MCP_LATCHED_ROM_PARITY |\n\t\tAEU_INPUTS_ATTN_BITS_MCP_LATCHED_SCPAD_PARITY |\n\t\tAEU_INPUTS_ATTN_BITS_MCP_LATCHED_UMP_RX_PARITY |\n\t\tAEU_INPUTS_ATTN_BITS_MCP_LATCHED_UMP_TX_PARITY;\n\n\t \n\tREG_WR(bp, XSEM_REG_FAST_MEMORY + SEM_FAST_REG_PARITY_RST, 0x1);\n\tREG_WR(bp, TSEM_REG_FAST_MEMORY + SEM_FAST_REG_PARITY_RST, 0x1);\n\tREG_WR(bp, USEM_REG_FAST_MEMORY + SEM_FAST_REG_PARITY_RST, 0x1);\n\tREG_WR(bp, CSEM_REG_FAST_MEMORY + SEM_FAST_REG_PARITY_RST, 0x1);\n\n\tfor (i = 0; i < ARRAY_SIZE(bnx2x_blocks_parity_data); i++) {\n\t\tu32 reg_mask = bnx2x_parity_reg_mask(bp, i);\n\n\t\tif (reg_mask) {\n\t\t\treg_val = REG_RD(bp, bnx2x_blocks_parity_data[i].\n\t\t\t\t\t sts_clr_addr);\n\t\t\tif (reg_val & reg_mask)\n\t\t\t\tDP(NETIF_MSG_HW,\n\t\t\t\t\t    \"Parity errors in %s: 0x%x\\n\",\n\t\t\t\t\t    bnx2x_blocks_parity_data[i].name,\n\t\t\t\t\t    reg_val & reg_mask);\n\t\t}\n\t}\n\n\t \n\treg_val = REG_RD(bp, MISC_REG_AEU_AFTER_INVERT_4_MCP);\n\tif (reg_val & mcp_aeu_bits)\n\t\tDP(NETIF_MSG_HW, \"Parity error in MCP: 0x%x\\n\",\n\t\t   reg_val & mcp_aeu_bits);\n\n\t \n\tREG_WR(bp, MISC_REG_AEU_CLR_LATCH_SIGNAL, 0x780);\n}\n\nstatic inline void bnx2x_enable_blocks_parity(struct bnx2x *bp)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(bnx2x_blocks_parity_data); i++) {\n\t\tu32 reg_mask = bnx2x_parity_reg_mask(bp, i);\n\n\t\tif (reg_mask)\n\t\t\tREG_WR(bp, bnx2x_blocks_parity_data[i].mask_addr,\n\t\t\t\tbnx2x_blocks_parity_data[i].en_mask & reg_mask);\n\t}\n\n\t \n\tbnx2x_set_mcp_parity(bp, true);\n}\n\n\n#endif  \n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}