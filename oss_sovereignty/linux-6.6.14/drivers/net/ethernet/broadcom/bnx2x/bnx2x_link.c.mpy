{
  "module_name": "bnx2x_link.c",
  "hash_id": "8a44ee43d2dbf2ee0242715c8395e58e1ce2b141b3d6cae76ee6e722bf630941",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/broadcom/bnx2x/bnx2x_link.c",
  "human_readable_source": " \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/pci.h>\n#include <linux/netdevice.h>\n#include <linux/delay.h>\n#include <linux/ethtool.h>\n#include <linux/mutex.h>\n\n#include \"bnx2x.h\"\n#include \"bnx2x_cmn.h\"\n\ntypedef int (*read_sfp_module_eeprom_func_p)(struct bnx2x_phy *phy,\n\t\t\t\t\t     struct link_params *params,\n\t\t\t\t\t     u8 dev_addr, u16 addr, u8 byte_cnt,\n\t\t\t\t\t     u8 *o_buf, u8);\n \n#define MDIO_ACCESS_TIMEOUT\t\t1000\n#define WC_LANE_MAX\t\t\t4\n#define I2C_SWITCH_WIDTH\t\t2\n#define I2C_BSC0\t\t\t0\n#define I2C_BSC1\t\t\t1\n#define I2C_WA_RETRY_CNT\t\t3\n#define I2C_WA_PWR_ITER\t\t\t(I2C_WA_RETRY_CNT - 1)\n#define MCPR_IMC_COMMAND_READ_OP\t1\n#define MCPR_IMC_COMMAND_WRITE_OP\t2\n\n \n#define LED_BLINK_RATE_VAL_E3\t\t354\n#define LED_BLINK_RATE_VAL_E1X_E2\t480\n \n \n \n\n#define NIG_LATCH_BC_ENABLE_MI_INT 0\n\n#define NIG_STATUS_EMAC0_MI_INT \\\n\t\tNIG_STATUS_INTERRUPT_PORT0_REG_STATUS_EMAC0_MISC_MI_INT\n#define NIG_STATUS_XGXS0_LINK10G \\\n\t\tNIG_STATUS_INTERRUPT_PORT0_REG_STATUS_XGXS0_LINK10G\n#define NIG_STATUS_XGXS0_LINK_STATUS \\\n\t\tNIG_STATUS_INTERRUPT_PORT0_REG_STATUS_XGXS0_LINK_STATUS\n#define NIG_STATUS_XGXS0_LINK_STATUS_SIZE \\\n\t\tNIG_STATUS_INTERRUPT_PORT0_REG_STATUS_XGXS0_LINK_STATUS_SIZE\n#define NIG_STATUS_SERDES0_LINK_STATUS \\\n\t\tNIG_STATUS_INTERRUPT_PORT0_REG_STATUS_SERDES0_LINK_STATUS\n#define NIG_MASK_MI_INT \\\n\t\tNIG_MASK_INTERRUPT_PORT0_REG_MASK_EMAC0_MISC_MI_INT\n#define NIG_MASK_XGXS0_LINK10G \\\n\t\tNIG_MASK_INTERRUPT_PORT0_REG_MASK_XGXS0_LINK10G\n#define NIG_MASK_XGXS0_LINK_STATUS \\\n\t\tNIG_MASK_INTERRUPT_PORT0_REG_MASK_XGXS0_LINK_STATUS\n#define NIG_MASK_SERDES0_LINK_STATUS \\\n\t\tNIG_MASK_INTERRUPT_PORT0_REG_MASK_SERDES0_LINK_STATUS\n\n#define MDIO_AN_CL73_OR_37_COMPLETE \\\n\t\t(MDIO_GP_STATUS_TOP_AN_STATUS1_CL73_AUTONEG_COMPLETE | \\\n\t\t MDIO_GP_STATUS_TOP_AN_STATUS1_CL37_AUTONEG_COMPLETE)\n\n#define XGXS_RESET_BITS \\\n\t(MISC_REGISTERS_RESET_REG_3_MISC_NIG_MUX_XGXS0_RSTB_HW |   \\\n\t MISC_REGISTERS_RESET_REG_3_MISC_NIG_MUX_XGXS0_IDDQ |      \\\n\t MISC_REGISTERS_RESET_REG_3_MISC_NIG_MUX_XGXS0_PWRDWN |    \\\n\t MISC_REGISTERS_RESET_REG_3_MISC_NIG_MUX_XGXS0_PWRDWN_SD | \\\n\t MISC_REGISTERS_RESET_REG_3_MISC_NIG_MUX_XGXS0_TXD_FIFO_RSTB)\n\n#define SERDES_RESET_BITS \\\n\t(MISC_REGISTERS_RESET_REG_3_MISC_NIG_MUX_SERDES0_RSTB_HW | \\\n\t MISC_REGISTERS_RESET_REG_3_MISC_NIG_MUX_SERDES0_IDDQ |    \\\n\t MISC_REGISTERS_RESET_REG_3_MISC_NIG_MUX_SERDES0_PWRDWN |  \\\n\t MISC_REGISTERS_RESET_REG_3_MISC_NIG_MUX_SERDES0_PWRDWN_SD)\n\n#define AUTONEG_CL37\t\tSHARED_HW_CFG_AN_ENABLE_CL37\n#define AUTONEG_CL73\t\tSHARED_HW_CFG_AN_ENABLE_CL73\n#define AUTONEG_BAM\t\tSHARED_HW_CFG_AN_ENABLE_BAM\n#define AUTONEG_PARALLEL \\\n\t\t\t\tSHARED_HW_CFG_AN_ENABLE_PARALLEL_DETECTION\n#define AUTONEG_SGMII_FIBER_AUTODET \\\n\t\t\t\tSHARED_HW_CFG_AN_EN_SGMII_FIBER_AUTO_DETECT\n#define AUTONEG_REMOTE_PHY\tSHARED_HW_CFG_AN_ENABLE_REMOTE_PHY\n\n#define GP_STATUS_PAUSE_RSOLUTION_TXSIDE \\\n\t\t\tMDIO_GP_STATUS_TOP_AN_STATUS1_PAUSE_RSOLUTION_TXSIDE\n#define GP_STATUS_PAUSE_RSOLUTION_RXSIDE \\\n\t\t\tMDIO_GP_STATUS_TOP_AN_STATUS1_PAUSE_RSOLUTION_RXSIDE\n#define GP_STATUS_SPEED_MASK \\\n\t\t\tMDIO_GP_STATUS_TOP_AN_STATUS1_ACTUAL_SPEED_MASK\n#define GP_STATUS_10M\tMDIO_GP_STATUS_TOP_AN_STATUS1_ACTUAL_SPEED_10M\n#define GP_STATUS_100M\tMDIO_GP_STATUS_TOP_AN_STATUS1_ACTUAL_SPEED_100M\n#define GP_STATUS_1G\tMDIO_GP_STATUS_TOP_AN_STATUS1_ACTUAL_SPEED_1G\n#define GP_STATUS_2_5G\tMDIO_GP_STATUS_TOP_AN_STATUS1_ACTUAL_SPEED_2_5G\n#define GP_STATUS_5G\tMDIO_GP_STATUS_TOP_AN_STATUS1_ACTUAL_SPEED_5G\n#define GP_STATUS_6G\tMDIO_GP_STATUS_TOP_AN_STATUS1_ACTUAL_SPEED_6G\n#define GP_STATUS_10G_HIG \\\n\t\t\tMDIO_GP_STATUS_TOP_AN_STATUS1_ACTUAL_SPEED_10G_HIG\n#define GP_STATUS_10G_CX4 \\\n\t\t\tMDIO_GP_STATUS_TOP_AN_STATUS1_ACTUAL_SPEED_10G_CX4\n#define GP_STATUS_1G_KX MDIO_GP_STATUS_TOP_AN_STATUS1_ACTUAL_SPEED_1G_KX\n#define GP_STATUS_10G_KX4 \\\n\t\t\tMDIO_GP_STATUS_TOP_AN_STATUS1_ACTUAL_SPEED_10G_KX4\n#define\tGP_STATUS_10G_KR MDIO_GP_STATUS_TOP_AN_STATUS1_ACTUAL_SPEED_10G_KR\n#define\tGP_STATUS_10G_XFI   MDIO_GP_STATUS_TOP_AN_STATUS1_ACTUAL_SPEED_10G_XFI\n#define\tGP_STATUS_20G_DXGXS MDIO_GP_STATUS_TOP_AN_STATUS1_ACTUAL_SPEED_20G_DXGXS\n#define\tGP_STATUS_10G_SFI   MDIO_GP_STATUS_TOP_AN_STATUS1_ACTUAL_SPEED_10G_SFI\n#define\tGP_STATUS_20G_KR2 MDIO_GP_STATUS_TOP_AN_STATUS1_ACTUAL_SPEED_20G_KR2\n#define LINK_10THD\t\tLINK_STATUS_SPEED_AND_DUPLEX_10THD\n#define LINK_10TFD\t\tLINK_STATUS_SPEED_AND_DUPLEX_10TFD\n#define LINK_100TXHD\t\tLINK_STATUS_SPEED_AND_DUPLEX_100TXHD\n#define LINK_100T4\t\tLINK_STATUS_SPEED_AND_DUPLEX_100T4\n#define LINK_100TXFD\t\tLINK_STATUS_SPEED_AND_DUPLEX_100TXFD\n#define LINK_1000THD\t\tLINK_STATUS_SPEED_AND_DUPLEX_1000THD\n#define LINK_1000TFD\t\tLINK_STATUS_SPEED_AND_DUPLEX_1000TFD\n#define LINK_1000XFD\t\tLINK_STATUS_SPEED_AND_DUPLEX_1000XFD\n#define LINK_2500THD\t\tLINK_STATUS_SPEED_AND_DUPLEX_2500THD\n#define LINK_2500TFD\t\tLINK_STATUS_SPEED_AND_DUPLEX_2500TFD\n#define LINK_2500XFD\t\tLINK_STATUS_SPEED_AND_DUPLEX_2500XFD\n#define LINK_10GTFD\t\tLINK_STATUS_SPEED_AND_DUPLEX_10GTFD\n#define LINK_10GXFD\t\tLINK_STATUS_SPEED_AND_DUPLEX_10GXFD\n#define LINK_20GTFD\t\tLINK_STATUS_SPEED_AND_DUPLEX_20GTFD\n#define LINK_20GXFD\t\tLINK_STATUS_SPEED_AND_DUPLEX_20GXFD\n\n#define LINK_UPDATE_MASK \\\n\t\t\t(LINK_STATUS_SPEED_AND_DUPLEX_MASK | \\\n\t\t\t LINK_STATUS_LINK_UP | \\\n\t\t\t LINK_STATUS_PHYSICAL_LINK_FLAG | \\\n\t\t\t LINK_STATUS_AUTO_NEGOTIATE_COMPLETE | \\\n\t\t\t LINK_STATUS_RX_FLOW_CONTROL_FLAG_MASK | \\\n\t\t\t LINK_STATUS_TX_FLOW_CONTROL_FLAG_MASK | \\\n\t\t\t LINK_STATUS_PARALLEL_DETECTION_FLAG_MASK | \\\n\t\t\t LINK_STATUS_LINK_PARTNER_SYMMETRIC_PAUSE | \\\n\t\t\t LINK_STATUS_LINK_PARTNER_ASYMMETRIC_PAUSE)\n\n#define SFP_EEPROM_CON_TYPE_ADDR\t\t0x2\n\t#define SFP_EEPROM_CON_TYPE_VAL_UNKNOWN\t0x0\n\t#define SFP_EEPROM_CON_TYPE_VAL_LC\t0x7\n\t#define SFP_EEPROM_CON_TYPE_VAL_COPPER\t0x21\n\t#define SFP_EEPROM_CON_TYPE_VAL_RJ45\t0x22\n\n\n#define SFP_EEPROM_10G_COMP_CODE_ADDR\t\t0x3\n\t#define SFP_EEPROM_10G_COMP_CODE_SR_MASK\t(1<<4)\n\t#define SFP_EEPROM_10G_COMP_CODE_LR_MASK\t(1<<5)\n\t#define SFP_EEPROM_10G_COMP_CODE_LRM_MASK\t(1<<6)\n\n#define SFP_EEPROM_1G_COMP_CODE_ADDR\t\t0x6\n\t#define SFP_EEPROM_1G_COMP_CODE_SX\t(1<<0)\n\t#define SFP_EEPROM_1G_COMP_CODE_LX\t(1<<1)\n\t#define SFP_EEPROM_1G_COMP_CODE_CX\t(1<<2)\n\t#define SFP_EEPROM_1G_COMP_CODE_BASE_T\t(1<<3)\n\n#define SFP_EEPROM_FC_TX_TECH_ADDR\t\t0x8\n\t#define SFP_EEPROM_FC_TX_TECH_BITMASK_COPPER_PASSIVE 0x4\n\t#define SFP_EEPROM_FC_TX_TECH_BITMASK_COPPER_ACTIVE  0x8\n\n#define SFP_EEPROM_OPTIONS_ADDR\t\t\t0x40\n\t#define SFP_EEPROM_OPTIONS_LINEAR_RX_OUT_MASK 0x1\n#define SFP_EEPROM_OPTIONS_SIZE\t\t\t2\n\n#define EDC_MODE_LINEAR\t\t\t\t0x0022\n#define EDC_MODE_LIMITING\t\t\t\t0x0044\n#define EDC_MODE_PASSIVE_DAC\t\t\t0x0055\n#define EDC_MODE_ACTIVE_DAC\t\t\t0x0066\n\n \n#define DCBX_INVALID_COS\t\t\t\t\t(0xFF)\n\n#define ETS_BW_LIMIT_CREDIT_UPPER_BOUND\t\t(0x5000)\n#define ETS_BW_LIMIT_CREDIT_WEIGHT\t\t(0x5000)\n#define ETS_E3B0_NIG_MIN_W_VAL_UP_TO_10GBPS\t\t(1360)\n#define ETS_E3B0_NIG_MIN_W_VAL_20GBPS\t\t\t(2720)\n#define ETS_E3B0_PBF_MIN_W_VAL\t\t\t\t(10000)\n\n#define MAX_PACKET_SIZE\t\t\t\t\t(9700)\n#define MAX_KR_LINK_RETRY\t\t\t\t4\n#define DEFAULT_TX_DRV_BRDCT\t\t2\n#define DEFAULT_TX_DRV_IFIR\t\t0\n#define DEFAULT_TX_DRV_POST2\t\t3\n#define DEFAULT_TX_DRV_IPRE_DRIVER\t6\n\n \n \n \n\n#define CL22_WR_OVER_CL45(_bp, _phy, _bank, _addr, _val) \\\n\tbnx2x_cl45_write(_bp, _phy, \\\n\t\t(_phy)->def_md_devad, \\\n\t\t(_bank + (_addr & 0xf)), \\\n\t\t_val)\n\n#define CL22_RD_OVER_CL45(_bp, _phy, _bank, _addr, _val) \\\n\tbnx2x_cl45_read(_bp, _phy, \\\n\t\t(_phy)->def_md_devad, \\\n\t\t(_bank + (_addr & 0xf)), \\\n\t\t_val)\n\nstatic int bnx2x_check_half_open_conn(struct link_params *params,\n\t\t\t\t      struct link_vars *vars, u8 notify);\nstatic int bnx2x_sfp_module_detection(struct bnx2x_phy *phy,\n\t\t\t\t      struct link_params *params);\n\nstatic u32 bnx2x_bits_en(struct bnx2x *bp, u32 reg, u32 bits)\n{\n\tu32 val = REG_RD(bp, reg);\n\n\tval |= bits;\n\tREG_WR(bp, reg, val);\n\treturn val;\n}\n\nstatic u32 bnx2x_bits_dis(struct bnx2x *bp, u32 reg, u32 bits)\n{\n\tu32 val = REG_RD(bp, reg);\n\n\tval &= ~bits;\n\tREG_WR(bp, reg, val);\n\treturn val;\n}\n\n \nstatic int bnx2x_check_lfa(struct link_params *params)\n{\n\tu32 link_status, cfg_idx, lfa_mask, cfg_size;\n\tu32 cur_speed_cap_mask, cur_req_fc_auto_adv, additional_config;\n\tu32 saved_val, req_val, eee_status;\n\tstruct bnx2x *bp = params->bp;\n\n\tadditional_config =\n\t\tREG_RD(bp, params->lfa_base +\n\t\t\t   offsetof(struct shmem_lfa, additional_config));\n\n\t \n\tif (additional_config & NO_LFA_DUE_TO_DCC_MASK) {\n\t\tDP(NETIF_MSG_LINK, \"No LFA due to DCC flap after clp exit\\n\");\n\t\tREG_WR(bp, params->lfa_base +\n\t\t\t   offsetof(struct shmem_lfa, additional_config),\n\t\t       additional_config & ~NO_LFA_DUE_TO_DCC_MASK);\n\t\treturn LFA_DCC_LFA_DISABLED;\n\t}\n\n\t \n\tlink_status = REG_RD(bp, params->shmem_base +\n\t\t\t     offsetof(struct shmem_region,\n\t\t\t\t      port_mb[params->port].link_status));\n\tif (!(link_status & LINK_STATUS_LINK_UP))\n\t\treturn LFA_LINK_DOWN;\n\n\t \n\tif (params->feature_config_flags & FEATURE_CONFIG_BOOT_FROM_SAN)\n\t\treturn 0;\n\n\t \n\tif (params->loopback_mode)\n\t\treturn LFA_LOOPBACK_ENABLED;\n\n\t \n\tif (!params->lfa_base)\n\t\treturn LFA_MFW_IS_TOO_OLD;\n\n\tif (params->num_phys == 3) {\n\t\tcfg_size = 2;\n\t\tlfa_mask = 0xffffffff;\n\t} else {\n\t\tcfg_size = 1;\n\t\tlfa_mask = 0xffff;\n\t}\n\n\t \n\tsaved_val = REG_RD(bp, params->lfa_base +\n\t\t\t   offsetof(struct shmem_lfa, req_duplex));\n\treq_val = params->req_duplex[0] | (params->req_duplex[1] << 16);\n\tif ((saved_val & lfa_mask) != (req_val & lfa_mask)) {\n\t\tDP(NETIF_MSG_LINK, \"Duplex mismatch %x vs. %x\\n\",\n\t\t\t       (saved_val & lfa_mask), (req_val & lfa_mask));\n\t\treturn LFA_DUPLEX_MISMATCH;\n\t}\n\t \n\tsaved_val = REG_RD(bp, params->lfa_base +\n\t\t\t   offsetof(struct shmem_lfa, req_flow_ctrl));\n\treq_val = params->req_flow_ctrl[0] | (params->req_flow_ctrl[1] << 16);\n\tif ((saved_val & lfa_mask) != (req_val & lfa_mask)) {\n\t\tDP(NETIF_MSG_LINK, \"Flow control mismatch %x vs. %x\\n\",\n\t\t\t       (saved_val & lfa_mask), (req_val & lfa_mask));\n\t\treturn LFA_FLOW_CTRL_MISMATCH;\n\t}\n\t \n\tsaved_val = REG_RD(bp, params->lfa_base +\n\t\t\t   offsetof(struct shmem_lfa, req_line_speed));\n\treq_val = params->req_line_speed[0] | (params->req_line_speed[1] << 16);\n\tif ((saved_val & lfa_mask) != (req_val & lfa_mask)) {\n\t\tDP(NETIF_MSG_LINK, \"Link speed mismatch %x vs. %x\\n\",\n\t\t\t       (saved_val & lfa_mask), (req_val & lfa_mask));\n\t\treturn LFA_LINK_SPEED_MISMATCH;\n\t}\n\n\tfor (cfg_idx = 0; cfg_idx < cfg_size; cfg_idx++) {\n\t\tcur_speed_cap_mask = REG_RD(bp, params->lfa_base +\n\t\t\t\t\t    offsetof(struct shmem_lfa,\n\t\t\t\t\t\t     speed_cap_mask[cfg_idx]));\n\n\t\tif (cur_speed_cap_mask != params->speed_cap_mask[cfg_idx]) {\n\t\t\tDP(NETIF_MSG_LINK, \"Speed Cap mismatch %x vs. %x\\n\",\n\t\t\t\t       cur_speed_cap_mask,\n\t\t\t\t       params->speed_cap_mask[cfg_idx]);\n\t\t\treturn LFA_SPEED_CAP_MISMATCH;\n\t\t}\n\t}\n\n\tcur_req_fc_auto_adv =\n\t\tREG_RD(bp, params->lfa_base +\n\t\t       offsetof(struct shmem_lfa, additional_config)) &\n\t\tREQ_FC_AUTO_ADV_MASK;\n\n\tif ((u16)cur_req_fc_auto_adv != params->req_fc_auto_adv) {\n\t\tDP(NETIF_MSG_LINK, \"Flow Ctrl AN mismatch %x vs. %x\\n\",\n\t\t\t       cur_req_fc_auto_adv, params->req_fc_auto_adv);\n\t\treturn LFA_FLOW_CTRL_MISMATCH;\n\t}\n\n\teee_status = REG_RD(bp, params->shmem2_base +\n\t\t\t    offsetof(struct shmem2_region,\n\t\t\t\t     eee_status[params->port]));\n\n\tif (((eee_status & SHMEM_EEE_LPI_REQUESTED_BIT) ^\n\t     (params->eee_mode & EEE_MODE_ENABLE_LPI)) ||\n\t    ((eee_status & SHMEM_EEE_REQUESTED_BIT) ^\n\t     (params->eee_mode & EEE_MODE_ADV_LPI))) {\n\t\tDP(NETIF_MSG_LINK, \"EEE mismatch %x vs. %x\\n\", params->eee_mode,\n\t\t\t       eee_status);\n\t\treturn LFA_EEE_MISMATCH;\n\t}\n\n\t \n\treturn 0;\n}\n \n \n \nstatic void bnx2x_get_epio(struct bnx2x *bp, u32 epio_pin, u32 *en)\n{\n\tu32 epio_mask, gp_oenable;\n\t*en = 0;\n\t \n\tif (epio_pin > 31) {\n\t\tDP(NETIF_MSG_LINK, \"Invalid EPIO pin %d to get\\n\", epio_pin);\n\t\treturn;\n\t}\n\n\tepio_mask = 1 << epio_pin;\n\t \n\tgp_oenable = REG_RD(bp, MCP_REG_MCPR_GP_OENABLE);\n\tREG_WR(bp, MCP_REG_MCPR_GP_OENABLE, gp_oenable & ~epio_mask);\n\n\t*en = (REG_RD(bp, MCP_REG_MCPR_GP_INPUTS) & epio_mask) >> epio_pin;\n}\nstatic void bnx2x_set_epio(struct bnx2x *bp, u32 epio_pin, u32 en)\n{\n\tu32 epio_mask, gp_output, gp_oenable;\n\n\t \n\tif (epio_pin > 31) {\n\t\tDP(NETIF_MSG_LINK, \"Invalid EPIO pin %d to set\\n\", epio_pin);\n\t\treturn;\n\t}\n\tDP(NETIF_MSG_LINK, \"Setting EPIO pin %d to %d\\n\", epio_pin, en);\n\tepio_mask = 1 << epio_pin;\n\t \n\tgp_output = REG_RD(bp, MCP_REG_MCPR_GP_OUTPUTS);\n\tif (en)\n\t\tgp_output |= epio_mask;\n\telse\n\t\tgp_output &= ~epio_mask;\n\n\tREG_WR(bp, MCP_REG_MCPR_GP_OUTPUTS, gp_output);\n\n\t \n\tgp_oenable = REG_RD(bp, MCP_REG_MCPR_GP_OENABLE);\n\tREG_WR(bp, MCP_REG_MCPR_GP_OENABLE, gp_oenable | epio_mask);\n}\n\nstatic void bnx2x_set_cfg_pin(struct bnx2x *bp, u32 pin_cfg, u32 val)\n{\n\tif (pin_cfg == PIN_CFG_NA)\n\t\treturn;\n\tif (pin_cfg >= PIN_CFG_EPIO0) {\n\t\tbnx2x_set_epio(bp, pin_cfg - PIN_CFG_EPIO0, val);\n\t} else {\n\t\tu8 gpio_num = (pin_cfg - PIN_CFG_GPIO0_P0) & 0x3;\n\t\tu8 gpio_port = (pin_cfg - PIN_CFG_GPIO0_P0) >> 2;\n\t\tbnx2x_set_gpio(bp, gpio_num, (u8)val, gpio_port);\n\t}\n}\n\nstatic u32 bnx2x_get_cfg_pin(struct bnx2x *bp, u32 pin_cfg, u32 *val)\n{\n\tif (pin_cfg == PIN_CFG_NA)\n\t\treturn -EINVAL;\n\tif (pin_cfg >= PIN_CFG_EPIO0) {\n\t\tbnx2x_get_epio(bp, pin_cfg - PIN_CFG_EPIO0, val);\n\t} else {\n\t\tu8 gpio_num = (pin_cfg - PIN_CFG_GPIO0_P0) & 0x3;\n\t\tu8 gpio_port = (pin_cfg - PIN_CFG_GPIO0_P0) >> 2;\n\t\t*val = bnx2x_get_gpio(bp, gpio_num, gpio_port);\n\t}\n\treturn 0;\n\n}\n \n \n \nstatic void bnx2x_ets_e2e3a0_disabled(struct link_params *params)\n{\n\t \n\tstruct bnx2x *bp = params->bp;\n\n\tDP(NETIF_MSG_LINK, \"ETS E2E3 disabled configuration\\n\");\n\n\t \n\n\tREG_WR(bp, NIG_REG_P0_TX_ARB_PRIORITY_CLIENT, 0x4688);\n\t \n\n\tREG_WR(bp, NIG_REG_P0_TX_ARB_CLIENT_IS_STRICT, 0x7);\n\t \n\tREG_WR(bp, NIG_REG_P0_TX_ARB_CLIENT_IS_SUBJECT2WFQ, 0);\n\t \n\tREG_WR(bp, NIG_REG_P0_TX_ARB_NUM_STRICT_ARB_SLOTS, 0x100);\n\t \n\tREG_WR(bp, NIG_REG_P0_TX_ARB_CLIENT_CREDIT_MAP, 0);\n\tREG_WR(bp, NIG_REG_P0_TX_ARB_CREDIT_WEIGHT_0, 0);\n\tREG_WR(bp, NIG_REG_P0_TX_ARB_CREDIT_WEIGHT_1, 0);\n\n\tREG_WR(bp, NIG_REG_P0_TX_ARB_CREDIT_UPPER_BOUND_0, 0);\n\tREG_WR(bp, NIG_REG_P0_TX_ARB_CREDIT_UPPER_BOUND_1, 0);\n\tREG_WR(bp, PBF_REG_HIGH_PRIORITY_COS_NUM, 0);\n\t \n\tREG_WR(bp, PBF_REG_ETS_ENABLED, 0);\n\t \n\tREG_WR(bp, PBF_REG_COS0_WEIGHT, 0x2710);\n\tREG_WR(bp, PBF_REG_COS1_WEIGHT, 0x2710);\n\t \n\tREG_WR(bp, PBF_REG_COS0_UPPER_BOUND, 0x989680);\n\tREG_WR(bp, PBF_REG_COS1_UPPER_BOUND, 0x989680);\n\t \n\tREG_WR(bp, PBF_REG_NUM_STRICT_ARB_SLOTS, 0);\n}\n \nstatic u32 bnx2x_ets_get_min_w_val_nig(const struct link_vars *vars)\n{\n\tu32 min_w_val = 0;\n\t \n\tif (vars->link_up) {\n\t\tif (vars->line_speed == SPEED_20000)\n\t\t\tmin_w_val = ETS_E3B0_NIG_MIN_W_VAL_20GBPS;\n\t\telse\n\t\t\tmin_w_val = ETS_E3B0_NIG_MIN_W_VAL_UP_TO_10GBPS;\n\t} else\n\t\tmin_w_val = ETS_E3B0_NIG_MIN_W_VAL_20GBPS;\n\t \n\treturn min_w_val;\n}\n \nstatic u32 bnx2x_ets_get_credit_upper_bound(const u32 min_w_val)\n{\n\tconst u32 credit_upper_bound = (u32)MAXVAL((150 * min_w_val),\n\t\t\t\t\t\tMAX_PACKET_SIZE);\n\treturn credit_upper_bound;\n}\n \nstatic void bnx2x_ets_e3b0_set_credit_upper_bound_nig(\n\tconst struct link_params *params,\n\tconst u32 min_w_val)\n{\n\tstruct bnx2x *bp = params->bp;\n\tconst u8 port = params->port;\n\tconst u32 credit_upper_bound =\n\t    bnx2x_ets_get_credit_upper_bound(min_w_val);\n\n\tREG_WR(bp, (port) ? NIG_REG_P1_TX_ARB_CREDIT_UPPER_BOUND_0 :\n\t\tNIG_REG_P0_TX_ARB_CREDIT_UPPER_BOUND_0, credit_upper_bound);\n\tREG_WR(bp, (port) ? NIG_REG_P1_TX_ARB_CREDIT_UPPER_BOUND_1 :\n\t\t   NIG_REG_P0_TX_ARB_CREDIT_UPPER_BOUND_1, credit_upper_bound);\n\tREG_WR(bp, (port) ? NIG_REG_P1_TX_ARB_CREDIT_UPPER_BOUND_2 :\n\t\t   NIG_REG_P0_TX_ARB_CREDIT_UPPER_BOUND_2, credit_upper_bound);\n\tREG_WR(bp, (port) ? NIG_REG_P1_TX_ARB_CREDIT_UPPER_BOUND_3 :\n\t\t   NIG_REG_P0_TX_ARB_CREDIT_UPPER_BOUND_3, credit_upper_bound);\n\tREG_WR(bp, (port) ? NIG_REG_P1_TX_ARB_CREDIT_UPPER_BOUND_4 :\n\t\t   NIG_REG_P0_TX_ARB_CREDIT_UPPER_BOUND_4, credit_upper_bound);\n\tREG_WR(bp, (port) ? NIG_REG_P1_TX_ARB_CREDIT_UPPER_BOUND_5 :\n\t\t   NIG_REG_P0_TX_ARB_CREDIT_UPPER_BOUND_5, credit_upper_bound);\n\n\tif (!port) {\n\t\tREG_WR(bp, NIG_REG_P0_TX_ARB_CREDIT_UPPER_BOUND_6,\n\t\t\tcredit_upper_bound);\n\t\tREG_WR(bp, NIG_REG_P0_TX_ARB_CREDIT_UPPER_BOUND_7,\n\t\t\tcredit_upper_bound);\n\t\tREG_WR(bp, NIG_REG_P0_TX_ARB_CREDIT_UPPER_BOUND_8,\n\t\t\tcredit_upper_bound);\n\t}\n}\n \nstatic void bnx2x_ets_e3b0_nig_disabled(const struct link_params *params,\n\t\t\t\t\tconst struct link_vars *vars)\n{\n\tstruct bnx2x *bp = params->bp;\n\tconst u8 port = params->port;\n\tconst u32 min_w_val = bnx2x_ets_get_min_w_val_nig(vars);\n\t \n\tif (port) {\n\t\tREG_WR(bp, NIG_REG_P1_TX_ARB_PRIORITY_CLIENT2_LSB, 0x543210);\n\t\tREG_WR(bp, NIG_REG_P1_TX_ARB_PRIORITY_CLIENT2_MSB, 0x0);\n\t} else {\n\t\tREG_WR(bp, NIG_REG_P0_TX_ARB_PRIORITY_CLIENT2_LSB, 0x76543210);\n\t\tREG_WR(bp, NIG_REG_P0_TX_ARB_PRIORITY_CLIENT2_MSB, 0x8);\n\t}\n\t \n\tREG_WR(bp, (port) ? NIG_REG_P1_TX_ARB_NUM_STRICT_ARB_SLOTS :\n\t\t   NIG_REG_P0_TX_ARB_NUM_STRICT_ARB_SLOTS, 0x100);\n\t \n\tif (port) {\n\t\t \n\t\tREG_WR(bp, NIG_REG_P1_TX_ARB_CLIENT_CREDIT_MAP2_LSB, 0x210543);\n\t\tREG_WR(bp, NIG_REG_P1_TX_ARB_CLIENT_CREDIT_MAP2_MSB, 0x0);\n\t} else {\n\t\t \n\t\tREG_WR(bp, NIG_REG_P0_TX_ARB_CLIENT_CREDIT_MAP2_LSB,\n\t\t       0x43210876);\n\t\tREG_WR(bp, NIG_REG_P0_TX_ARB_CLIENT_CREDIT_MAP2_MSB, 0x5);\n\t}\n\n\t \n\tif (port)\n\t\tREG_WR(bp, NIG_REG_P1_TX_ARB_CLIENT_IS_STRICT, 0x3f);\n\telse\n\t\tREG_WR(bp, NIG_REG_P0_TX_ARB_CLIENT_IS_STRICT, 0x1ff);\n\t \n\tREG_WR(bp, (port) ? NIG_REG_P1_TX_ARB_CLIENT_IS_SUBJECT2WFQ :\n\t\t   NIG_REG_P0_TX_ARB_CLIENT_IS_SUBJECT2WFQ, 0);\n\n\t \n\tREG_WR(bp, (port) ? NIG_REG_P1_TX_ARB_CREDIT_WEIGHT_0 :\n\t\t   NIG_REG_P0_TX_ARB_CREDIT_WEIGHT_0, 0x0);\n\tREG_WR(bp, (port) ? NIG_REG_P1_TX_ARB_CREDIT_WEIGHT_1 :\n\t\t   NIG_REG_P0_TX_ARB_CREDIT_WEIGHT_1, 0x0);\n\tREG_WR(bp, (port) ? NIG_REG_P1_TX_ARB_CREDIT_WEIGHT_2 :\n\t\t   NIG_REG_P0_TX_ARB_CREDIT_WEIGHT_2, 0x0);\n\tREG_WR(bp, (port) ? NIG_REG_P1_TX_ARB_CREDIT_WEIGHT_3 :\n\t\t   NIG_REG_P0_TX_ARB_CREDIT_WEIGHT_3, 0x0);\n\tREG_WR(bp, (port) ? NIG_REG_P1_TX_ARB_CREDIT_WEIGHT_4 :\n\t\t   NIG_REG_P0_TX_ARB_CREDIT_WEIGHT_4, 0x0);\n\tREG_WR(bp, (port) ? NIG_REG_P1_TX_ARB_CREDIT_WEIGHT_5 :\n\t\t   NIG_REG_P0_TX_ARB_CREDIT_WEIGHT_5, 0x0);\n\tif (!port) {\n\t\tREG_WR(bp, NIG_REG_P0_TX_ARB_CREDIT_WEIGHT_6, 0x0);\n\t\tREG_WR(bp, NIG_REG_P0_TX_ARB_CREDIT_WEIGHT_7, 0x0);\n\t\tREG_WR(bp, NIG_REG_P0_TX_ARB_CREDIT_WEIGHT_8, 0x0);\n\t}\n\n\tbnx2x_ets_e3b0_set_credit_upper_bound_nig(params, min_w_val);\n}\n \nstatic void bnx2x_ets_e3b0_set_credit_upper_bound_pbf(\n\tconst struct link_params *params,\n\tconst u32 min_w_val)\n{\n\tstruct bnx2x *bp = params->bp;\n\tconst u32 credit_upper_bound =\n\t    bnx2x_ets_get_credit_upper_bound(min_w_val);\n\tconst u8 port = params->port;\n\tu32 base_upper_bound = 0;\n\tu8 max_cos = 0;\n\tu8 i = 0;\n\t \n\tif (!port) {\n\t\tbase_upper_bound = PBF_REG_COS0_UPPER_BOUND_P0;\n\t\tmax_cos = DCBX_E3B0_MAX_NUM_COS_PORT0;\n\t} else {\n\t\tbase_upper_bound = PBF_REG_COS0_UPPER_BOUND_P1;\n\t\tmax_cos = DCBX_E3B0_MAX_NUM_COS_PORT1;\n\t}\n\n\tfor (i = 0; i < max_cos; i++)\n\t\tREG_WR(bp, base_upper_bound + (i << 2), credit_upper_bound);\n}\n\n \nstatic void bnx2x_ets_e3b0_pbf_disabled(const struct link_params *params)\n{\n\tstruct bnx2x *bp = params->bp;\n\tconst u8 port = params->port;\n\tconst u32 min_w_val_pbf = ETS_E3B0_PBF_MIN_W_VAL;\n\tu8 i = 0;\n\tu32 base_weight = 0;\n\tu8 max_cos = 0;\n\n\t \n\tif (port)\n\t\t \n\t\tREG_WR(bp, PBF_REG_ETS_ARB_PRIORITY_CLIENT_P1 , 0x688);\n\telse\n\t\t \n\t\tREG_WR(bp, PBF_REG_ETS_ARB_PRIORITY_CLIENT_P0 , 0x2C688);\n\n\t \n\tif (port)\n\t\t \n\t\tREG_WR(bp, PBF_REG_ETS_ARB_CLIENT_CREDIT_MAP_P1, 0x688);\n\telse\n\t \n\tREG_WR(bp, PBF_REG_ETS_ARB_CLIENT_CREDIT_MAP_P0, 0x2C688);\n\n\tREG_WR(bp, (port) ? PBF_REG_ETS_ARB_NUM_STRICT_ARB_SLOTS_P1 :\n\t\t   PBF_REG_ETS_ARB_NUM_STRICT_ARB_SLOTS_P0 , 0x100);\n\n\n\tREG_WR(bp, (port) ? PBF_REG_ETS_ARB_CLIENT_IS_STRICT_P1 :\n\t\t   PBF_REG_ETS_ARB_CLIENT_IS_STRICT_P0 , 0);\n\n\tREG_WR(bp, (port) ? PBF_REG_ETS_ARB_CLIENT_IS_SUBJECT2WFQ_P1 :\n\t\t   PBF_REG_ETS_ARB_CLIENT_IS_SUBJECT2WFQ_P0 , 0);\n\t \n\tif (!port) {\n\t\tbase_weight = PBF_REG_COS0_WEIGHT_P0;\n\t\tmax_cos = DCBX_E3B0_MAX_NUM_COS_PORT0;\n\t} else {\n\t\tbase_weight = PBF_REG_COS0_WEIGHT_P1;\n\t\tmax_cos = DCBX_E3B0_MAX_NUM_COS_PORT1;\n\t}\n\n\tfor (i = 0; i < max_cos; i++)\n\t\tREG_WR(bp, base_weight + (0x4 * i), 0);\n\n\tbnx2x_ets_e3b0_set_credit_upper_bound_pbf(params, min_w_val_pbf);\n}\n \nstatic int bnx2x_ets_e3b0_disabled(const struct link_params *params,\n\t\t\t\t   const struct link_vars *vars)\n{\n\tstruct bnx2x *bp = params->bp;\n\n\tif (!CHIP_IS_E3B0(bp)) {\n\t\tDP(NETIF_MSG_LINK,\n\t\t   \"bnx2x_ets_e3b0_disabled the chip isn't E3B0\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tbnx2x_ets_e3b0_nig_disabled(params, vars);\n\n\tbnx2x_ets_e3b0_pbf_disabled(params);\n\n\treturn 0;\n}\n\n \nint bnx2x_ets_disabled(struct link_params *params,\n\t\t      struct link_vars *vars)\n{\n\tstruct bnx2x *bp = params->bp;\n\tint bnx2x_status = 0;\n\n\tif ((CHIP_IS_E2(bp)) || (CHIP_IS_E3A0(bp)))\n\t\tbnx2x_ets_e2e3a0_disabled(params);\n\telse if (CHIP_IS_E3B0(bp))\n\t\tbnx2x_status = bnx2x_ets_e3b0_disabled(params, vars);\n\telse {\n\t\tDP(NETIF_MSG_LINK, \"bnx2x_ets_disabled - chip not supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn bnx2x_status;\n}\n\n \nstatic int bnx2x_ets_e3b0_cli_map(const struct link_params *params,\n\t\t\t\t  const struct bnx2x_ets_params *ets_params,\n\t\t\t\t  const u8 cos_sp_bitmap,\n\t\t\t\t  const u8 cos_bw_bitmap)\n{\n\tstruct bnx2x *bp = params->bp;\n\tconst u8 port = params->port;\n\tconst u8 nig_cli_sp_bitmap = 0x7 | (cos_sp_bitmap << 3);\n\tconst u8 pbf_cli_sp_bitmap = cos_sp_bitmap;\n\tconst u8 nig_cli_subject2wfq_bitmap = cos_bw_bitmap << 3;\n\tconst u8 pbf_cli_subject2wfq_bitmap = cos_bw_bitmap;\n\n\tREG_WR(bp, (port) ? NIG_REG_P1_TX_ARB_CLIENT_IS_STRICT :\n\t       NIG_REG_P0_TX_ARB_CLIENT_IS_STRICT, nig_cli_sp_bitmap);\n\n\tREG_WR(bp, (port) ? PBF_REG_ETS_ARB_CLIENT_IS_STRICT_P1 :\n\t       PBF_REG_ETS_ARB_CLIENT_IS_STRICT_P0 , pbf_cli_sp_bitmap);\n\n\tREG_WR(bp, (port) ? NIG_REG_P1_TX_ARB_CLIENT_IS_SUBJECT2WFQ :\n\t       NIG_REG_P0_TX_ARB_CLIENT_IS_SUBJECT2WFQ,\n\t       nig_cli_subject2wfq_bitmap);\n\n\tREG_WR(bp, (port) ? PBF_REG_ETS_ARB_CLIENT_IS_SUBJECT2WFQ_P1 :\n\t       PBF_REG_ETS_ARB_CLIENT_IS_SUBJECT2WFQ_P0,\n\t       pbf_cli_subject2wfq_bitmap);\n\n\treturn 0;\n}\n\n \nstatic int bnx2x_ets_e3b0_set_cos_bw(struct bnx2x *bp,\n\t\t\t\t     const u8 cos_entry,\n\t\t\t\t     const u32 min_w_val_nig,\n\t\t\t\t     const u32 min_w_val_pbf,\n\t\t\t\t     const u16 total_bw,\n\t\t\t\t     const u8 bw,\n\t\t\t\t     const u8 port)\n{\n\tu32 nig_reg_adress_crd_weight = 0;\n\tu32 pbf_reg_adress_crd_weight = 0;\n\t \n\tconst u32 cos_bw_nig = ((bw ? bw : 1) * min_w_val_nig) / total_bw;\n\tconst u32 cos_bw_pbf = ((bw ? bw : 1) * min_w_val_pbf) / total_bw;\n\n\tswitch (cos_entry) {\n\tcase 0:\n\t\tnig_reg_adress_crd_weight =\n\t\t\t(port) ? NIG_REG_P1_TX_ARB_CREDIT_WEIGHT_0 :\n\t\t\tNIG_REG_P0_TX_ARB_CREDIT_WEIGHT_0;\n\t\tpbf_reg_adress_crd_weight = (port) ?\n\t\t    PBF_REG_COS0_WEIGHT_P1 : PBF_REG_COS0_WEIGHT_P0;\n\t\tbreak;\n\tcase 1:\n\t\tnig_reg_adress_crd_weight = (port) ?\n\t\t\tNIG_REG_P1_TX_ARB_CREDIT_WEIGHT_1 :\n\t\t\tNIG_REG_P0_TX_ARB_CREDIT_WEIGHT_1;\n\t\tpbf_reg_adress_crd_weight = (port) ?\n\t\t\tPBF_REG_COS1_WEIGHT_P1 : PBF_REG_COS1_WEIGHT_P0;\n\t\tbreak;\n\tcase 2:\n\t\tnig_reg_adress_crd_weight = (port) ?\n\t\t\tNIG_REG_P1_TX_ARB_CREDIT_WEIGHT_2 :\n\t\t\tNIG_REG_P0_TX_ARB_CREDIT_WEIGHT_2;\n\n\t\tpbf_reg_adress_crd_weight = (port) ?\n\t\t\tPBF_REG_COS2_WEIGHT_P1 : PBF_REG_COS2_WEIGHT_P0;\n\t\tbreak;\n\tcase 3:\n\t\tif (port)\n\t\t\treturn -EINVAL;\n\t\tnig_reg_adress_crd_weight = NIG_REG_P0_TX_ARB_CREDIT_WEIGHT_3;\n\t\tpbf_reg_adress_crd_weight = PBF_REG_COS3_WEIGHT_P0;\n\t\tbreak;\n\tcase 4:\n\t\tif (port)\n\t\t\treturn -EINVAL;\n\t\tnig_reg_adress_crd_weight = NIG_REG_P0_TX_ARB_CREDIT_WEIGHT_4;\n\t\tpbf_reg_adress_crd_weight = PBF_REG_COS4_WEIGHT_P0;\n\t\tbreak;\n\tcase 5:\n\t\tif (port)\n\t\t\treturn -EINVAL;\n\t\tnig_reg_adress_crd_weight = NIG_REG_P0_TX_ARB_CREDIT_WEIGHT_5;\n\t\tpbf_reg_adress_crd_weight = PBF_REG_COS5_WEIGHT_P0;\n\t\tbreak;\n\t}\n\n\tREG_WR(bp, nig_reg_adress_crd_weight, cos_bw_nig);\n\n\tREG_WR(bp, pbf_reg_adress_crd_weight, cos_bw_pbf);\n\n\treturn 0;\n}\n \nstatic int bnx2x_ets_e3b0_get_total_bw(\n\tconst struct link_params *params,\n\tstruct bnx2x_ets_params *ets_params,\n\tu16 *total_bw)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu8 cos_idx = 0;\n\tu8 is_bw_cos_exist = 0;\n\n\t*total_bw = 0 ;\n\t \n\tfor (cos_idx = 0; cos_idx < ets_params->num_of_cos; cos_idx++) {\n\t\tif (ets_params->cos[cos_idx].state == bnx2x_cos_state_bw) {\n\t\t\tis_bw_cos_exist = 1;\n\t\t\tif (!ets_params->cos[cos_idx].params.bw_params.bw) {\n\t\t\t\tDP(NETIF_MSG_LINK, \"bnx2x_ets_E3B0_config BW\"\n\t\t\t\t\t\t   \"was set to 0\\n\");\n\t\t\t\t \n\t\t\t\tets_params->cos[cos_idx].params.bw_params.bw\n\t\t\t\t\t = 1;\n\t\t\t}\n\t\t\t*total_bw +=\n\t\t\t\tets_params->cos[cos_idx].params.bw_params.bw;\n\t\t}\n\t}\n\n\t \n\tif ((is_bw_cos_exist == 1) && (*total_bw != 100)) {\n\t\tif (*total_bw == 0) {\n\t\t\tDP(NETIF_MSG_LINK,\n\t\t\t   \"bnx2x_ets_E3B0_config total BW shouldn't be 0\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tDP(NETIF_MSG_LINK,\n\t\t   \"bnx2x_ets_E3B0_config total BW should be 100\\n\");\n\t\t \n\t}\n\treturn 0;\n}\n\n \nstatic void bnx2x_ets_e3b0_sp_pri_to_cos_init(u8 *sp_pri_to_cos)\n{\n\tu8 pri = 0;\n\tfor (pri = 0; pri < DCBX_MAX_NUM_COS; pri++)\n\t\tsp_pri_to_cos[pri] = DCBX_INVALID_COS;\n}\n \nstatic int bnx2x_ets_e3b0_sp_pri_to_cos_set(const struct link_params *params,\n\t\t\t\t\t    u8 *sp_pri_to_cos, const u8 pri,\n\t\t\t\t\t    const u8 cos_entry)\n{\n\tstruct bnx2x *bp = params->bp;\n\tconst u8 port = params->port;\n\tconst u8 max_num_of_cos = (port) ? DCBX_E3B0_MAX_NUM_COS_PORT1 :\n\t\tDCBX_E3B0_MAX_NUM_COS_PORT0;\n\n\tif (pri >= max_num_of_cos) {\n\t\tDP(NETIF_MSG_LINK, \"bnx2x_ets_e3b0_sp_pri_to_cos_set invalid \"\n\t\t   \"parameter Illegal strict priority\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (sp_pri_to_cos[pri] != DCBX_INVALID_COS) {\n\t\tDP(NETIF_MSG_LINK, \"bnx2x_ets_e3b0_sp_pri_to_cos_set invalid \"\n\t\t\t\t   \"parameter There can't be two COS's with \"\n\t\t\t\t   \"the same strict pri\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tsp_pri_to_cos[pri] = cos_entry;\n\treturn 0;\n\n}\n\n \nstatic u64 bnx2x_e3b0_sp_get_pri_cli_reg(const u8 cos, const u8 cos_offset,\n\t\t\t\t\t const u8 pri_set,\n\t\t\t\t\t const u8 pri_offset,\n\t\t\t\t\t const u8 entry_size)\n{\n\tu64 pri_cli_nig = 0;\n\tpri_cli_nig = ((u64)(cos + cos_offset)) << (entry_size *\n\t\t\t\t\t\t    (pri_set + pri_offset));\n\n\treturn pri_cli_nig;\n}\n \nstatic u64 bnx2x_e3b0_sp_get_pri_cli_reg_nig(const u8 cos, const u8 pri_set)\n{\n\t \n\tconst u8 nig_cos_offset = 3;\n\tconst u8 nig_pri_offset = 3;\n\n\treturn bnx2x_e3b0_sp_get_pri_cli_reg(cos, nig_cos_offset, pri_set,\n\t\tnig_pri_offset, 4);\n\n}\n \nstatic u64 bnx2x_e3b0_sp_get_pri_cli_reg_pbf(const u8 cos, const u8 pri_set)\n{\n\tconst u8 pbf_cos_offset = 0;\n\tconst u8 pbf_pri_offset = 0;\n\n\treturn bnx2x_e3b0_sp_get_pri_cli_reg(cos, pbf_cos_offset, pri_set,\n\t\tpbf_pri_offset, 3);\n\n}\n\n \nstatic int bnx2x_ets_e3b0_sp_set_pri_cli_reg(const struct link_params *params,\n\t\t\t\t\t     u8 *sp_pri_to_cos)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu8 i = 0;\n\tconst u8 port = params->port;\n\t \n\tu64 pri_cli_nig = 0x210;\n\tu32 pri_cli_pbf = 0x0;\n\tu8 pri_set = 0;\n\tu8 pri_bitmask = 0;\n\tconst u8 max_num_of_cos = (port) ? DCBX_E3B0_MAX_NUM_COS_PORT1 :\n\t\tDCBX_E3B0_MAX_NUM_COS_PORT0;\n\n\tu8 cos_bit_to_set = (1 << max_num_of_cos) - 1;\n\n\t \n\tfor (i = 0; i < max_num_of_cos; i++) {\n\t\tif (sp_pri_to_cos[i] != DCBX_INVALID_COS) {\n\t\t\tif (sp_pri_to_cos[i] >= DCBX_MAX_NUM_COS) {\n\t\t\t\tDP(NETIF_MSG_LINK,\n\t\t\t\t\t   \"bnx2x_ets_e3b0_sp_set_pri_cli_reg \"\n\t\t\t\t\t   \"invalid cos entry\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tpri_cli_nig |= bnx2x_e3b0_sp_get_pri_cli_reg_nig(\n\t\t\t    sp_pri_to_cos[i], pri_set);\n\n\t\t\tpri_cli_pbf |= bnx2x_e3b0_sp_get_pri_cli_reg_pbf(\n\t\t\t    sp_pri_to_cos[i], pri_set);\n\t\t\tpri_bitmask = 1 << sp_pri_to_cos[i];\n\t\t\t \n\t\t\tif (!(pri_bitmask & cos_bit_to_set)) {\n\t\t\t\tDP(NETIF_MSG_LINK,\n\t\t\t\t\t\"bnx2x_ets_e3b0_sp_set_pri_cli_reg \"\n\t\t\t\t\t\"invalid There can't be two COS's with\"\n\t\t\t\t\t\" the same strict pri\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tcos_bit_to_set &= ~pri_bitmask;\n\t\t\tpri_set++;\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < max_num_of_cos; i++) {\n\t\tpri_bitmask = 1 << i;\n\t\t \n\t\tif (pri_bitmask & cos_bit_to_set) {\n\t\t\t \n\t\t\tpri_cli_nig |= bnx2x_e3b0_sp_get_pri_cli_reg_nig(\n\t\t\t    i, pri_set);\n\n\t\t\tpri_cli_pbf |= bnx2x_e3b0_sp_get_pri_cli_reg_pbf(\n\t\t\t    i, pri_set);\n\t\t\t \n\t\t\tcos_bit_to_set &= ~pri_bitmask;\n\t\t\tpri_set++;\n\t\t}\n\t}\n\n\tif (pri_set != max_num_of_cos) {\n\t\tDP(NETIF_MSG_LINK, \"bnx2x_ets_e3b0_sp_set_pri_cli_reg not all \"\n\t\t\t\t   \"entries were set\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (port) {\n\t\t \n\t\tREG_WR(bp, NIG_REG_P1_TX_ARB_PRIORITY_CLIENT2_LSB,\n\t\t       (u32)pri_cli_nig);\n\n\t\tREG_WR(bp, PBF_REG_ETS_ARB_PRIORITY_CLIENT_P1 , pri_cli_pbf);\n\t} else {\n\t\t \n\t\tconst u32 pri_cli_nig_lsb = (u32) (pri_cli_nig);\n\t\tconst u32 pri_cli_nig_msb = (u32) ((pri_cli_nig >> 32) & 0xF);\n\n\t\tREG_WR(bp, NIG_REG_P0_TX_ARB_PRIORITY_CLIENT2_LSB,\n\t\t       pri_cli_nig_lsb);\n\t\tREG_WR(bp, NIG_REG_P0_TX_ARB_PRIORITY_CLIENT2_MSB,\n\t\t       pri_cli_nig_msb);\n\n\t\tREG_WR(bp, PBF_REG_ETS_ARB_PRIORITY_CLIENT_P0 , pri_cli_pbf);\n\t}\n\treturn 0;\n}\n\n \nint bnx2x_ets_e3b0_config(const struct link_params *params,\n\t\t\t const struct link_vars *vars,\n\t\t\t struct bnx2x_ets_params *ets_params)\n{\n\tstruct bnx2x *bp = params->bp;\n\tint bnx2x_status = 0;\n\tconst u8 port = params->port;\n\tu16 total_bw = 0;\n\tconst u32 min_w_val_nig = bnx2x_ets_get_min_w_val_nig(vars);\n\tconst u32 min_w_val_pbf = ETS_E3B0_PBF_MIN_W_VAL;\n\tu8 cos_bw_bitmap = 0;\n\tu8 cos_sp_bitmap = 0;\n\tu8 sp_pri_to_cos[DCBX_MAX_NUM_COS] = {0};\n\tconst u8 max_num_of_cos = (port) ? DCBX_E3B0_MAX_NUM_COS_PORT1 :\n\t\tDCBX_E3B0_MAX_NUM_COS_PORT0;\n\tu8 cos_entry = 0;\n\n\tif (!CHIP_IS_E3B0(bp)) {\n\t\tDP(NETIF_MSG_LINK,\n\t\t   \"bnx2x_ets_e3b0_disabled the chip isn't E3B0\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif ((ets_params->num_of_cos > max_num_of_cos)) {\n\t\tDP(NETIF_MSG_LINK, \"bnx2x_ets_E3B0_config the number of COS \"\n\t\t\t\t   \"isn't supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tbnx2x_ets_e3b0_sp_pri_to_cos_init(sp_pri_to_cos);\n\n\t \n\tbnx2x_status = bnx2x_ets_e3b0_get_total_bw(params, ets_params,\n\t\t\t\t\t\t   &total_bw);\n\tif (bnx2x_status) {\n\t\tDP(NETIF_MSG_LINK,\n\t\t   \"bnx2x_ets_E3B0_config get_total_bw failed\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tbnx2x_ets_e3b0_set_credit_upper_bound_nig(params, min_w_val_nig);\n\tbnx2x_ets_e3b0_set_credit_upper_bound_pbf(params, min_w_val_pbf);\n\n\n\tfor (cos_entry = 0; cos_entry < ets_params->num_of_cos; cos_entry++) {\n\t\tif (bnx2x_cos_state_bw == ets_params->cos[cos_entry].state) {\n\t\t\tcos_bw_bitmap |= (1 << cos_entry);\n\t\t\t \n\t\t\tbnx2x_status = bnx2x_ets_e3b0_set_cos_bw(\n\t\t\t\tbp, cos_entry, min_w_val_nig, min_w_val_pbf,\n\t\t\t\ttotal_bw,\n\t\t\t\tets_params->cos[cos_entry].params.bw_params.bw,\n\t\t\t\t port);\n\t\t} else if (bnx2x_cos_state_strict ==\n\t\t\tets_params->cos[cos_entry].state){\n\t\t\tcos_sp_bitmap |= (1 << cos_entry);\n\n\t\t\tbnx2x_status = bnx2x_ets_e3b0_sp_pri_to_cos_set(\n\t\t\t\tparams,\n\t\t\t\tsp_pri_to_cos,\n\t\t\t\tets_params->cos[cos_entry].params.sp_params.pri,\n\t\t\t\tcos_entry);\n\n\t\t} else {\n\t\t\tDP(NETIF_MSG_LINK,\n\t\t\t   \"bnx2x_ets_e3b0_config cos state not valid\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (bnx2x_status) {\n\t\t\tDP(NETIF_MSG_LINK,\n\t\t\t   \"bnx2x_ets_e3b0_config set cos bw failed\\n\");\n\t\t\treturn bnx2x_status;\n\t\t}\n\t}\n\n\t \n\tbnx2x_status = bnx2x_ets_e3b0_sp_set_pri_cli_reg(params,\n\t\t\t\t\t\t\t sp_pri_to_cos);\n\n\tif (bnx2x_status) {\n\t\tDP(NETIF_MSG_LINK,\n\t\t   \"bnx2x_ets_E3B0_config set_pri_cli_reg failed\\n\");\n\t\treturn bnx2x_status;\n\t}\n\n\t \n\tbnx2x_status = bnx2x_ets_e3b0_cli_map(params, ets_params,\n\t\t\t\t\t      cos_sp_bitmap,\n\t\t\t\t\t      cos_bw_bitmap);\n\n\tif (bnx2x_status) {\n\t\tDP(NETIF_MSG_LINK, \"bnx2x_ets_E3B0_config SP failed\\n\");\n\t\treturn bnx2x_status;\n\t}\n\treturn 0;\n}\nstatic void bnx2x_ets_bw_limit_common(const struct link_params *params)\n{\n\t \n\tstruct bnx2x *bp = params->bp;\n\tDP(NETIF_MSG_LINK, \"ETS enabled BW limit configuration\\n\");\n\t \n\tREG_WR(bp, NIG_REG_P0_TX_ARB_CLIENT_IS_SUBJECT2WFQ, 0x18);\n\t \n\tREG_WR(bp, NIG_REG_P0_TX_ARB_CLIENT_CREDIT_MAP, 0x111A);\n\n\tREG_WR(bp, NIG_REG_P0_TX_ARB_CREDIT_UPPER_BOUND_0,\n\t       ETS_BW_LIMIT_CREDIT_UPPER_BOUND);\n\tREG_WR(bp, NIG_REG_P0_TX_ARB_CREDIT_UPPER_BOUND_1,\n\t       ETS_BW_LIMIT_CREDIT_UPPER_BOUND);\n\n\t \n\tREG_WR(bp, PBF_REG_ETS_ENABLED, 1);\n\n\t \n\tREG_WR(bp, PBF_REG_NUM_STRICT_ARB_SLOTS, 0);\n\t \n\tREG_WR(bp, NIG_REG_P0_TX_ARB_CLIENT_IS_STRICT, 0x7);\n\n\t \n\tREG_WR(bp, PBF_REG_COS0_UPPER_BOUND,\n\t       ETS_BW_LIMIT_CREDIT_UPPER_BOUND);\n\tREG_WR(bp, PBF_REG_COS1_UPPER_BOUND,\n\t       ETS_BW_LIMIT_CREDIT_UPPER_BOUND);\n}\n\nvoid bnx2x_ets_bw_limit(const struct link_params *params, const u32 cos0_bw,\n\t\t\tconst u32 cos1_bw)\n{\n\t \n\tstruct bnx2x *bp = params->bp;\n\tconst u32 total_bw = cos0_bw + cos1_bw;\n\tu32 cos0_credit_weight = 0;\n\tu32 cos1_credit_weight = 0;\n\n\tDP(NETIF_MSG_LINK, \"ETS enabled BW limit configuration\\n\");\n\n\tif ((!total_bw) ||\n\t    (!cos0_bw) ||\n\t    (!cos1_bw)) {\n\t\tDP(NETIF_MSG_LINK, \"Total BW can't be zero\\n\");\n\t\treturn;\n\t}\n\n\tcos0_credit_weight = (cos0_bw * ETS_BW_LIMIT_CREDIT_WEIGHT)/\n\t\ttotal_bw;\n\tcos1_credit_weight = (cos1_bw * ETS_BW_LIMIT_CREDIT_WEIGHT)/\n\t\ttotal_bw;\n\n\tbnx2x_ets_bw_limit_common(params);\n\n\tREG_WR(bp, NIG_REG_P0_TX_ARB_CREDIT_WEIGHT_0, cos0_credit_weight);\n\tREG_WR(bp, NIG_REG_P0_TX_ARB_CREDIT_WEIGHT_1, cos1_credit_weight);\n\n\tREG_WR(bp, PBF_REG_COS0_WEIGHT, cos0_credit_weight);\n\tREG_WR(bp, PBF_REG_COS1_WEIGHT, cos1_credit_weight);\n}\n\nint bnx2x_ets_strict(const struct link_params *params, const u8 strict_cos)\n{\n\t \n\tstruct bnx2x *bp = params->bp;\n\tu32 val\t= 0;\n\n\tDP(NETIF_MSG_LINK, \"ETS enabled strict configuration\\n\");\n\t \n\tREG_WR(bp, NIG_REG_P0_TX_ARB_CLIENT_IS_STRICT, 0x1F);\n\t \n\tREG_WR(bp, NIG_REG_P0_TX_ARB_NUM_STRICT_ARB_SLOTS, 0x100);\n\t \n\tREG_WR(bp, PBF_REG_ETS_ENABLED, 0);\n\t \n\tREG_WR(bp, PBF_REG_NUM_STRICT_ARB_SLOTS, 0x100);\n\n\t \n\tREG_WR(bp, PBF_REG_HIGH_PRIORITY_COS_NUM, strict_cos);\n\n\t \n\tval = (!strict_cos) ? 0x2318 : 0x22E0;\n\tREG_WR(bp, NIG_REG_P0_TX_ARB_PRIORITY_CLIENT, val);\n\n\treturn 0;\n}\n\n \n \n \nstatic void bnx2x_update_pfc_xmac(struct link_params *params,\n\t\t\t\t  struct link_vars *vars,\n\t\t\t\t  u8 is_lb)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu32 xmac_base;\n\tu32 pause_val, pfc0_val, pfc1_val;\n\n\t \n\txmac_base = (params->port) ? GRCBASE_XMAC1 : GRCBASE_XMAC0;\n\n\t \n\tpause_val = 0x18000;\n\tpfc0_val = 0xFFFF8000;\n\tpfc1_val = 0x2;\n\n\t \n\tif (!(params->feature_config_flags &\n\t      FEATURE_CONFIG_PFC_ENABLED)) {\n\n\t\t \n\t\tif (vars->flow_ctrl & BNX2X_FLOW_CTRL_RX)\n\t\t\tpause_val |= XMAC_PAUSE_CTRL_REG_RX_PAUSE_EN;\n\n\t\t \n\t\tif (vars->flow_ctrl & BNX2X_FLOW_CTRL_TX)\n\t\t\tpause_val |= XMAC_PAUSE_CTRL_REG_TX_PAUSE_EN;\n\t} else { \n\t\tpfc1_val |= XMAC_PFC_CTRL_HI_REG_PFC_REFRESH_EN |\n\t\t\tXMAC_PFC_CTRL_HI_REG_PFC_STATS_EN |\n\t\t\tXMAC_PFC_CTRL_HI_REG_RX_PFC_EN |\n\t\t\tXMAC_PFC_CTRL_HI_REG_TX_PFC_EN |\n\t\t\tXMAC_PFC_CTRL_HI_REG_FORCE_PFC_XON;\n\t\t \n\t\tREG_WR(bp, xmac_base + XMAC_REG_PAUSE_CTRL, pause_val);\n\t\tREG_WR(bp, xmac_base + XMAC_REG_PFC_CTRL, pfc0_val);\n\t\tREG_WR(bp, xmac_base + XMAC_REG_PFC_CTRL_HI, pfc1_val);\n\t\tpfc1_val &= ~XMAC_PFC_CTRL_HI_REG_FORCE_PFC_XON;\n\n\t}\n\n\t \n\tREG_WR(bp, xmac_base + XMAC_REG_PAUSE_CTRL, pause_val);\n\tREG_WR(bp, xmac_base + XMAC_REG_PFC_CTRL, pfc0_val);\n\tREG_WR(bp, xmac_base + XMAC_REG_PFC_CTRL_HI, pfc1_val);\n\n\n\t \n\tREG_WR(bp, xmac_base + XMAC_REG_CTRL_SA_LO,\n\t       ((params->mac_addr[2] << 24) |\n\t\t(params->mac_addr[3] << 16) |\n\t\t(params->mac_addr[4] << 8) |\n\t\t(params->mac_addr[5])));\n\tREG_WR(bp, xmac_base + XMAC_REG_CTRL_SA_HI,\n\t       ((params->mac_addr[0] << 8) |\n\t\t(params->mac_addr[1])));\n\n\tudelay(30);\n}\n\n \n \n \nstatic void bnx2x_set_mdio_clk(struct bnx2x *bp, u32 chip_id,\n\t\t\t       u32 emac_base)\n{\n\tu32 new_mode, cur_mode;\n\tu32 clc_cnt;\n\t \n\tcur_mode = REG_RD(bp, emac_base + EMAC_REG_EMAC_MDIO_MODE);\n\n\tif (USES_WARPCORE(bp))\n\t\tclc_cnt = 74L << EMAC_MDIO_MODE_CLOCK_CNT_BITSHIFT;\n\telse\n\t\tclc_cnt = 49L << EMAC_MDIO_MODE_CLOCK_CNT_BITSHIFT;\n\n\tif (((cur_mode & EMAC_MDIO_MODE_CLOCK_CNT) == clc_cnt) &&\n\t    (cur_mode & (EMAC_MDIO_MODE_CLAUSE_45)))\n\t\treturn;\n\n\tnew_mode = cur_mode &\n\t\t~(EMAC_MDIO_MODE_AUTO_POLL | EMAC_MDIO_MODE_CLOCK_CNT);\n\tnew_mode |= clc_cnt;\n\tnew_mode |= (EMAC_MDIO_MODE_CLAUSE_45);\n\n\tDP(NETIF_MSG_LINK, \"Changing emac_mode from 0x%x to 0x%x\\n\",\n\t   cur_mode, new_mode);\n\tREG_WR(bp, emac_base + EMAC_REG_EMAC_MDIO_MODE, new_mode);\n\tudelay(40);\n}\n\nstatic void bnx2x_set_mdio_emac_per_phy(struct bnx2x *bp,\n\t\t\t\t\tstruct link_params *params)\n{\n\tu8 phy_index;\n\t \n\tfor (phy_index = INT_PHY; phy_index < params->num_phys;\n\t      phy_index++)\n\t\tbnx2x_set_mdio_clk(bp, params->chip_id,\n\t\t\t\t   params->phy[phy_index].mdio_ctrl);\n}\n\nstatic u8 bnx2x_is_4_port_mode(struct bnx2x *bp)\n{\n\tu32 port4mode_ovwr_val;\n\t \n\tport4mode_ovwr_val = REG_RD(bp, MISC_REG_PORT4MODE_EN_OVWR);\n\tif (port4mode_ovwr_val & (1<<0)) {\n\t\t \n\t\treturn ((port4mode_ovwr_val & (1<<1)) == (1<<1));\n\t}\n\t \n\treturn (u8)REG_RD(bp, MISC_REG_PORT4MODE_EN);\n}\n\nstatic void bnx2x_emac_init(struct link_params *params,\n\t\t\t    struct link_vars *vars)\n{\n\t \n\tstruct bnx2x *bp = params->bp;\n\tu8 port = params->port;\n\tu32 emac_base = port ? GRCBASE_EMAC1 : GRCBASE_EMAC0;\n\tu32 val;\n\tu16 timeout;\n\n\tREG_WR(bp, GRCBASE_MISC + MISC_REGISTERS_RESET_REG_2_CLEAR,\n\t       (MISC_REGISTERS_RESET_REG_2_RST_EMAC0_HARD_CORE << port));\n\tudelay(5);\n\tREG_WR(bp, GRCBASE_MISC + MISC_REGISTERS_RESET_REG_2_SET,\n\t       (MISC_REGISTERS_RESET_REG_2_RST_EMAC0_HARD_CORE << port));\n\n\t \n\t \n\tval = REG_RD(bp, emac_base + EMAC_REG_EMAC_MODE);\n\tEMAC_WR(bp, EMAC_REG_EMAC_MODE, (val | EMAC_MODE_RESET));\n\n\ttimeout = 200;\n\tdo {\n\t\tval = REG_RD(bp, emac_base + EMAC_REG_EMAC_MODE);\n\t\tDP(NETIF_MSG_LINK, \"EMAC reset reg is %u\\n\", val);\n\t\tif (!timeout) {\n\t\t\tDP(NETIF_MSG_LINK, \"EMAC timeout!\\n\");\n\t\t\treturn;\n\t\t}\n\t\ttimeout--;\n\t} while (val & EMAC_MODE_RESET);\n\n\tbnx2x_set_mdio_emac_per_phy(bp, params);\n\t \n\tval = ((params->mac_addr[0] << 8) |\n\t\tparams->mac_addr[1]);\n\tEMAC_WR(bp, EMAC_REG_EMAC_MAC_MATCH, val);\n\n\tval = ((params->mac_addr[2] << 24) |\n\t       (params->mac_addr[3] << 16) |\n\t       (params->mac_addr[4] << 8) |\n\t\tparams->mac_addr[5]);\n\tEMAC_WR(bp, EMAC_REG_EMAC_MAC_MATCH + 4, val);\n}\n\nstatic void bnx2x_set_xumac_nig(struct link_params *params,\n\t\t\t\tu16 tx_pause_en,\n\t\t\t\tu8 enable)\n{\n\tstruct bnx2x *bp = params->bp;\n\n\tREG_WR(bp, params->port ? NIG_REG_P1_MAC_IN_EN : NIG_REG_P0_MAC_IN_EN,\n\t       enable);\n\tREG_WR(bp, params->port ? NIG_REG_P1_MAC_OUT_EN : NIG_REG_P0_MAC_OUT_EN,\n\t       enable);\n\tREG_WR(bp, params->port ? NIG_REG_P1_MAC_PAUSE_OUT_EN :\n\t       NIG_REG_P0_MAC_PAUSE_OUT_EN, tx_pause_en);\n}\n\nstatic void bnx2x_set_umac_rxtx(struct link_params *params, u8 en)\n{\n\tu32 umac_base = params->port ? GRCBASE_UMAC1 : GRCBASE_UMAC0;\n\tu32 val;\n\tstruct bnx2x *bp = params->bp;\n\tif (!(REG_RD(bp, MISC_REG_RESET_REG_2) &\n\t\t   (MISC_REGISTERS_RESET_REG_2_UMAC0 << params->port)))\n\t\treturn;\n\tval = REG_RD(bp, umac_base + UMAC_REG_COMMAND_CONFIG);\n\tif (en)\n\t\tval |= (UMAC_COMMAND_CONFIG_REG_TX_ENA |\n\t\t\tUMAC_COMMAND_CONFIG_REG_RX_ENA);\n\telse\n\t\tval &= ~(UMAC_COMMAND_CONFIG_REG_TX_ENA |\n\t\t\t UMAC_COMMAND_CONFIG_REG_RX_ENA);\n\t \n\tREG_WR(bp, umac_base + UMAC_REG_COMMAND_CONFIG, val);\n}\n\nstatic void bnx2x_umac_enable(struct link_params *params,\n\t\t\t    struct link_vars *vars, u8 lb)\n{\n\tu32 val;\n\tu32 umac_base = params->port ? GRCBASE_UMAC1 : GRCBASE_UMAC0;\n\tstruct bnx2x *bp = params->bp;\n\t \n\tREG_WR(bp, GRCBASE_MISC + MISC_REGISTERS_RESET_REG_2_CLEAR,\n\t       (MISC_REGISTERS_RESET_REG_2_UMAC0 << params->port));\n\tusleep_range(1000, 2000);\n\n\tREG_WR(bp, GRCBASE_MISC + MISC_REGISTERS_RESET_REG_2_SET,\n\t       (MISC_REGISTERS_RESET_REG_2_UMAC0 << params->port));\n\n\tDP(NETIF_MSG_LINK, \"enabling UMAC\\n\");\n\n\t \n\tREG_WR(bp, NIG_REG_EGRESS_EMAC0_PORT + params->port*4, 1);\n\n\tval = UMAC_COMMAND_CONFIG_REG_PROMIS_EN |\n\t\tUMAC_COMMAND_CONFIG_REG_PAD_EN |\n\t\tUMAC_COMMAND_CONFIG_REG_SW_RESET |\n\t\tUMAC_COMMAND_CONFIG_REG_NO_LGTH_CHECK;\n\tswitch (vars->line_speed) {\n\tcase SPEED_10:\n\t\tval |= (0<<2);\n\t\tbreak;\n\tcase SPEED_100:\n\t\tval |= (1<<2);\n\t\tbreak;\n\tcase SPEED_1000:\n\t\tval |= (2<<2);\n\t\tbreak;\n\tcase SPEED_2500:\n\t\tval |= (3<<2);\n\t\tbreak;\n\tdefault:\n\t\tDP(NETIF_MSG_LINK, \"Invalid speed for UMAC %d\\n\",\n\t\t\t       vars->line_speed);\n\t\tbreak;\n\t}\n\tif (!(vars->flow_ctrl & BNX2X_FLOW_CTRL_TX))\n\t\tval |= UMAC_COMMAND_CONFIG_REG_IGNORE_TX_PAUSE;\n\n\tif (!(vars->flow_ctrl & BNX2X_FLOW_CTRL_RX))\n\t\tval |= UMAC_COMMAND_CONFIG_REG_PAUSE_IGNORE;\n\n\tif (vars->duplex == DUPLEX_HALF)\n\t\tval |= UMAC_COMMAND_CONFIG_REG_HD_ENA;\n\n\tREG_WR(bp, umac_base + UMAC_REG_COMMAND_CONFIG, val);\n\tudelay(50);\n\n\t \n\tif (vars->eee_status & SHMEM_EEE_ADV_STATUS_MASK) {\n\t\tDP(NETIF_MSG_LINK, \"configured UMAC for EEE\\n\");\n\t\tREG_WR(bp, umac_base + UMAC_REG_UMAC_EEE_CTRL,\n\t\t       UMAC_UMAC_EEE_CTRL_REG_EEE_EN);\n\t\tREG_WR(bp, umac_base + UMAC_REG_EEE_WAKE_TIMER, 0x11);\n\t} else {\n\t\tREG_WR(bp, umac_base + UMAC_REG_UMAC_EEE_CTRL, 0x0);\n\t}\n\n\t \n\tREG_WR(bp, umac_base + UMAC_REG_MAC_ADDR0,\n\t       ((params->mac_addr[2] << 24) |\n\t\t(params->mac_addr[3] << 16) |\n\t\t(params->mac_addr[4] << 8) |\n\t\t(params->mac_addr[5])));\n\tREG_WR(bp, umac_base + UMAC_REG_MAC_ADDR1,\n\t       ((params->mac_addr[0] << 8) |\n\t\t(params->mac_addr[1])));\n\n\t \n\tval &= ~UMAC_COMMAND_CONFIG_REG_PAD_EN;\n\tval |= UMAC_COMMAND_CONFIG_REG_TX_ENA |\n\t\tUMAC_COMMAND_CONFIG_REG_RX_ENA;\n\tREG_WR(bp, umac_base + UMAC_REG_COMMAND_CONFIG, val);\n\tudelay(50);\n\n\t \n\tval &= ~UMAC_COMMAND_CONFIG_REG_SW_RESET;\n\n\t \n\tif (lb)\n\t\tval |= UMAC_COMMAND_CONFIG_REG_LOOP_ENA;\n\tREG_WR(bp, umac_base + UMAC_REG_COMMAND_CONFIG, val);\n\n\t \n\tREG_WR(bp, umac_base + UMAC_REG_MAXFR, 0x2710);\n\tbnx2x_set_xumac_nig(params,\n\t\t\t    ((vars->flow_ctrl & BNX2X_FLOW_CTRL_TX) != 0), 1);\n\tvars->mac_type = MAC_TYPE_UMAC;\n\n}\n\n \nstatic void bnx2x_xmac_init(struct link_params *params, u32 max_speed)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu32 is_port4mode = bnx2x_is_4_port_mode(bp);\n\n\t \n\n\tif (((CHIP_NUM(bp) == CHIP_NUM_57840_4_10) ||\n\t     (CHIP_NUM(bp) == CHIP_NUM_57840_2_20) ||\n\t     (CHIP_NUM(bp) == CHIP_NUM_57840_OBSOLETE)) &&\n\t    is_port4mode &&\n\t    (REG_RD(bp, MISC_REG_RESET_REG_2) &\n\t     MISC_REGISTERS_RESET_REG_2_XMAC)) {\n\t\tDP(NETIF_MSG_LINK,\n\t\t   \"XMAC already out of reset in 4-port mode\\n\");\n\t\treturn;\n\t}\n\n\t \n\tREG_WR(bp, GRCBASE_MISC + MISC_REGISTERS_RESET_REG_2_CLEAR,\n\t       MISC_REGISTERS_RESET_REG_2_XMAC);\n\tusleep_range(1000, 2000);\n\n\tREG_WR(bp, GRCBASE_MISC + MISC_REGISTERS_RESET_REG_2_SET,\n\t       MISC_REGISTERS_RESET_REG_2_XMAC);\n\tif (is_port4mode) {\n\t\tDP(NETIF_MSG_LINK, \"Init XMAC to 2 ports x 10G per path\\n\");\n\n\t\t \n\t\tREG_WR(bp, MISC_REG_XMAC_CORE_PORT_MODE, 1);\n\n\t\t \n\t\tREG_WR(bp, MISC_REG_XMAC_PHY_PORT_MODE, 3);\n\t} else {\n\t\t \n\t\tREG_WR(bp, MISC_REG_XMAC_CORE_PORT_MODE, 0);\n\t\tif (max_speed == SPEED_10000) {\n\t\t\tDP(NETIF_MSG_LINK,\n\t\t\t   \"Init XMAC to 10G x 1 port per path\\n\");\n\t\t\t \n\t\t\tREG_WR(bp, MISC_REG_XMAC_PHY_PORT_MODE, 3);\n\t\t} else {\n\t\t\tDP(NETIF_MSG_LINK,\n\t\t\t   \"Init XMAC to 20G x 2 ports per path\\n\");\n\t\t\t \n\t\t\tREG_WR(bp, MISC_REG_XMAC_PHY_PORT_MODE, 1);\n\t\t}\n\t}\n\t \n\tREG_WR(bp, GRCBASE_MISC + MISC_REGISTERS_RESET_REG_2_CLEAR,\n\t       MISC_REGISTERS_RESET_REG_2_XMAC_SOFT);\n\tusleep_range(1000, 2000);\n\n\tREG_WR(bp, GRCBASE_MISC + MISC_REGISTERS_RESET_REG_2_SET,\n\t       MISC_REGISTERS_RESET_REG_2_XMAC_SOFT);\n\n}\n\nstatic void bnx2x_set_xmac_rxtx(struct link_params *params, u8 en)\n{\n\tu8 port = params->port;\n\tstruct bnx2x *bp = params->bp;\n\tu32 pfc_ctrl, xmac_base = (port) ? GRCBASE_XMAC1 : GRCBASE_XMAC0;\n\tu32 val;\n\n\tif (REG_RD(bp, MISC_REG_RESET_REG_2) &\n\t    MISC_REGISTERS_RESET_REG_2_XMAC) {\n\t\t \n\t\tpfc_ctrl = REG_RD(bp, xmac_base + XMAC_REG_PFC_CTRL_HI);\n\t\tREG_WR(bp, xmac_base + XMAC_REG_PFC_CTRL_HI,\n\t\t       (pfc_ctrl & ~(1<<1)));\n\t\tREG_WR(bp, xmac_base + XMAC_REG_PFC_CTRL_HI,\n\t\t       (pfc_ctrl | (1<<1)));\n\t\tDP(NETIF_MSG_LINK, \"Disable XMAC on port %x\\n\", port);\n\t\tval = REG_RD(bp, xmac_base + XMAC_REG_CTRL);\n\t\tif (en)\n\t\t\tval |= (XMAC_CTRL_REG_TX_EN | XMAC_CTRL_REG_RX_EN);\n\t\telse\n\t\t\tval &= ~(XMAC_CTRL_REG_TX_EN | XMAC_CTRL_REG_RX_EN);\n\t\tREG_WR(bp, xmac_base + XMAC_REG_CTRL, val);\n\t}\n}\n\nstatic int bnx2x_xmac_enable(struct link_params *params,\n\t\t\t     struct link_vars *vars, u8 lb)\n{\n\tu32 val, xmac_base;\n\tstruct bnx2x *bp = params->bp;\n\tDP(NETIF_MSG_LINK, \"enabling XMAC\\n\");\n\n\txmac_base = (params->port) ? GRCBASE_XMAC1 : GRCBASE_XMAC0;\n\n\tbnx2x_xmac_init(params, vars->line_speed);\n\n\t \n\n\t \n\tREG_WR(bp, NIG_REG_EGRESS_EMAC0_PORT + params->port*4, 0);\n\n\t \n\tif (!(params->phy[INT_PHY].flags & FLAGS_TX_ERROR_CHECK)) {\n\t\tREG_WR(bp, xmac_base + XMAC_REG_RX_LSS_CTRL,\n\t\t       (XMAC_RX_LSS_CTRL_REG_LOCAL_FAULT_DISABLE |\n\t\t\tXMAC_RX_LSS_CTRL_REG_REMOTE_FAULT_DISABLE));\n\t\tREG_WR(bp, xmac_base + XMAC_REG_CLEAR_RX_LSS_STATUS, 0);\n\t\tREG_WR(bp, xmac_base + XMAC_REG_CLEAR_RX_LSS_STATUS,\n\t\t       XMAC_CLEAR_RX_LSS_STATUS_REG_CLEAR_LOCAL_FAULT_STATUS |\n\t\t       XMAC_CLEAR_RX_LSS_STATUS_REG_CLEAR_REMOTE_FAULT_STATUS);\n\t}\n\t \n\tREG_WR(bp, xmac_base + XMAC_REG_RX_MAX_SIZE, 0x2710);\n\n\t \n\tREG_WR(bp, xmac_base + XMAC_REG_TX_CTRL, 0xC800);\n\n\t \n\tbnx2x_update_pfc_xmac(params, vars, 0);\n\n\tif (vars->eee_status & SHMEM_EEE_ADV_STATUS_MASK) {\n\t\tDP(NETIF_MSG_LINK, \"Setting XMAC for EEE\\n\");\n\t\tREG_WR(bp, xmac_base + XMAC_REG_EEE_TIMERS_HI, 0x1380008);\n\t\tREG_WR(bp, xmac_base + XMAC_REG_EEE_CTRL, 0x1);\n\t} else {\n\t\tREG_WR(bp, xmac_base + XMAC_REG_EEE_CTRL, 0x0);\n\t}\n\n\t \n\tval = XMAC_CTRL_REG_TX_EN | XMAC_CTRL_REG_RX_EN;\n\n\t \n\tif ((vars->line_speed == SPEED_20000) &&\n\t    (params->phy[INT_PHY].supported &\n\t     SUPPORTED_20000baseKR2_Full))\n\t\tval |= XMAC_CTRL_REG_XLGMII_ALIGN_ENB;\n\n\t \n\tif (lb)\n\t\tval |= XMAC_CTRL_REG_LINE_LOCAL_LPBK;\n\tREG_WR(bp, xmac_base + XMAC_REG_CTRL, val);\n\tbnx2x_set_xumac_nig(params,\n\t\t\t    ((vars->flow_ctrl & BNX2X_FLOW_CTRL_TX) != 0), 1);\n\n\tvars->mac_type = MAC_TYPE_XMAC;\n\n\treturn 0;\n}\n\nstatic int bnx2x_emac_enable(struct link_params *params,\n\t\t\t     struct link_vars *vars, u8 lb)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu8 port = params->port;\n\tu32 emac_base = port ? GRCBASE_EMAC1 : GRCBASE_EMAC0;\n\tu32 val;\n\n\tDP(NETIF_MSG_LINK, \"enabling EMAC\\n\");\n\n\t \n\tREG_WR(bp, GRCBASE_MISC + MISC_REGISTERS_RESET_REG_2_CLEAR,\n\t       (MISC_REGISTERS_RESET_REG_2_RST_BMAC0 << port));\n\n\t \n\tREG_WR(bp, NIG_REG_EGRESS_EMAC0_PORT + port*4, 1);\n\n\t \n\tif (vars->phy_flags & PHY_XGXS_FLAG) {\n\t\tu32 ser_lane = ((params->lane_config &\n\t\t\t\t PORT_HW_CFG_LANE_SWAP_CFG_MASTER_MASK) >>\n\t\t\t\tPORT_HW_CFG_LANE_SWAP_CFG_MASTER_SHIFT);\n\n\t\tDP(NETIF_MSG_LINK, \"XGXS\\n\");\n\t\t \n\t\tREG_WR(bp, NIG_REG_XGXS_LANE_SEL_P0 + port*4, ser_lane);\n\t\t \n\t\tREG_WR(bp, NIG_REG_XGXS_SERDES0_MODE_SEL + port*4, 1);\n\n\t} else {  \n\t\tDP(NETIF_MSG_LINK, \"SerDes\\n\");\n\t\t \n\t\tREG_WR(bp, NIG_REG_XGXS_SERDES0_MODE_SEL + port*4, 0);\n\t}\n\n\tbnx2x_bits_en(bp, emac_base + EMAC_REG_EMAC_RX_MODE,\n\t\t      EMAC_RX_MODE_RESET);\n\tbnx2x_bits_en(bp, emac_base + EMAC_REG_EMAC_TX_MODE,\n\t\t      EMAC_TX_MODE_RESET);\n\n\t \n\tbnx2x_bits_dis(bp, emac_base + EMAC_REG_EMAC_RX_MODE,\n\t\t       EMAC_RX_MODE_FLOW_EN);\n\n\tbnx2x_bits_dis(bp,  emac_base + EMAC_REG_EMAC_TX_MODE,\n\t\t       (EMAC_TX_MODE_EXT_PAUSE_EN |\n\t\t\tEMAC_TX_MODE_FLOW_EN));\n\tif (!(params->feature_config_flags &\n\t      FEATURE_CONFIG_PFC_ENABLED)) {\n\t\tif (vars->flow_ctrl & BNX2X_FLOW_CTRL_RX)\n\t\t\tbnx2x_bits_en(bp, emac_base +\n\t\t\t\t      EMAC_REG_EMAC_RX_MODE,\n\t\t\t\t      EMAC_RX_MODE_FLOW_EN);\n\n\t\tif (vars->flow_ctrl & BNX2X_FLOW_CTRL_TX)\n\t\t\tbnx2x_bits_en(bp, emac_base +\n\t\t\t\t      EMAC_REG_EMAC_TX_MODE,\n\t\t\t\t      (EMAC_TX_MODE_EXT_PAUSE_EN |\n\t\t\t\t       EMAC_TX_MODE_FLOW_EN));\n\t} else\n\t\tbnx2x_bits_en(bp, emac_base + EMAC_REG_EMAC_TX_MODE,\n\t\t\t      EMAC_TX_MODE_FLOW_EN);\n\n\t \n\tval = REG_RD(bp, emac_base + EMAC_REG_EMAC_RX_MODE);\n\tval |= EMAC_RX_MODE_KEEP_VLAN_TAG | EMAC_RX_MODE_PROMISCUOUS;\n\n\t \n\tEMAC_WR(bp, EMAC_REG_RX_PFC_MODE, 0);\n\tif (params->feature_config_flags & FEATURE_CONFIG_PFC_ENABLED) {\n\t\tDP(NETIF_MSG_LINK, \"PFC is enabled\\n\");\n\t\t \n\t\tEMAC_WR(bp, EMAC_REG_RX_PFC_MODE,\n\t\t\tEMAC_REG_RX_PFC_MODE_RX_EN |\n\t\t\tEMAC_REG_RX_PFC_MODE_TX_EN |\n\t\t\tEMAC_REG_RX_PFC_MODE_PRIORITIES);\n\n\t\tEMAC_WR(bp, EMAC_REG_RX_PFC_PARAM,\n\t\t\t((0x0101 <<\n\t\t\t  EMAC_REG_RX_PFC_PARAM_OPCODE_BITSHIFT) |\n\t\t\t (0x00ff <<\n\t\t\t  EMAC_REG_RX_PFC_PARAM_PRIORITY_EN_BITSHIFT)));\n\t\tval |= EMAC_RX_MODE_KEEP_MAC_CONTROL;\n\t}\n\tEMAC_WR(bp, EMAC_REG_EMAC_RX_MODE, val);\n\n\t \n\tval = REG_RD(bp, emac_base + EMAC_REG_EMAC_MODE);\n\tif (lb)\n\t\tval |= 0x810;\n\telse\n\t\tval &= ~0x810;\n\tEMAC_WR(bp, EMAC_REG_EMAC_MODE, val);\n\n\t \n\tREG_WR(bp, NIG_REG_NIG_EMAC0_EN + port*4, 1);\n\n\t \n\tEMAC_WR(bp, EMAC_REG_EMAC_RX_MTU_SIZE,\n\t\t(EMAC_RX_MTU_SIZE_JUMBO_ENA |\n\t\t (ETH_MAX_JUMBO_PACKET_SIZE + ETH_OVERHEAD)));\n\n\t \n\tREG_WR(bp, NIG_REG_NIG_INGRESS_EMAC0_NO_CRC + port*4, 0x1);\n\n\t \n\tREG_WR(bp, NIG_REG_BMAC0_IN_EN + port*4, 0x0);\n\tREG_WR(bp, NIG_REG_BMAC0_PAUSE_OUT_EN + port*4, 0x0);\n\tREG_WR(bp, NIG_REG_BMAC0_OUT_EN + port*4, 0x0);\n\n\t \n\tREG_WR(bp, NIG_REG_EMAC0_IN_EN + port*4, 0x1);\n\tval = 0;\n\tif ((params->feature_config_flags &\n\t      FEATURE_CONFIG_PFC_ENABLED) ||\n\t    (vars->flow_ctrl & BNX2X_FLOW_CTRL_TX))\n\t\tval = 1;\n\n\tREG_WR(bp, NIG_REG_EMAC0_PAUSE_OUT_EN + port*4, val);\n\tREG_WR(bp, NIG_REG_EGRESS_EMAC0_OUT_EN + port*4, 0x1);\n\n\tREG_WR(bp, NIG_REG_BMAC0_REGS_OUT_EN + port*4, 0x0);\n\n\tvars->mac_type = MAC_TYPE_EMAC;\n\treturn 0;\n}\n\nstatic void bnx2x_update_pfc_bmac1(struct link_params *params,\n\t\t\t\t   struct link_vars *vars)\n{\n\tu32 wb_data[2];\n\tstruct bnx2x *bp = params->bp;\n\tu32 bmac_addr =  params->port ? NIG_REG_INGRESS_BMAC1_MEM :\n\t\tNIG_REG_INGRESS_BMAC0_MEM;\n\n\tu32 val = 0x14;\n\tif ((!(params->feature_config_flags &\n\t      FEATURE_CONFIG_PFC_ENABLED)) &&\n\t\t(vars->flow_ctrl & BNX2X_FLOW_CTRL_RX))\n\t\t \n\t\tval |= (1<<5);\n\twb_data[0] = val;\n\twb_data[1] = 0;\n\tREG_WR_DMAE(bp, bmac_addr + BIGMAC_REGISTER_RX_CONTROL, wb_data, 2);\n\n\t \n\tval = 0xc0;\n\tif (!(params->feature_config_flags &\n\t      FEATURE_CONFIG_PFC_ENABLED) &&\n\t\t(vars->flow_ctrl & BNX2X_FLOW_CTRL_TX))\n\t\tval |= 0x800000;\n\twb_data[0] = val;\n\twb_data[1] = 0;\n\tREG_WR_DMAE(bp, bmac_addr + BIGMAC_REGISTER_TX_CONTROL, wb_data, 2);\n}\n\nstatic void bnx2x_update_pfc_bmac2(struct link_params *params,\n\t\t\t\t   struct link_vars *vars,\n\t\t\t\t   u8 is_lb)\n{\n\t \n\tu32 wb_data[2];\n\tstruct bnx2x *bp = params->bp;\n\tu32 bmac_addr = params->port ? NIG_REG_INGRESS_BMAC1_MEM :\n\t\tNIG_REG_INGRESS_BMAC0_MEM;\n\tu32 val = 0x14;\n\n\tif ((!(params->feature_config_flags &\n\t      FEATURE_CONFIG_PFC_ENABLED)) &&\n\t\t(vars->flow_ctrl & BNX2X_FLOW_CTRL_RX))\n\t\t \n\t\tval |= (1<<5);\n\twb_data[0] = val;\n\twb_data[1] = 0;\n\tREG_WR_DMAE(bp, bmac_addr + BIGMAC2_REGISTER_RX_CONTROL, wb_data, 2);\n\tudelay(30);\n\n\t \n\tval = 0xc0;\n\tif (!(params->feature_config_flags &\n\t\t\t\tFEATURE_CONFIG_PFC_ENABLED) &&\n\t    (vars->flow_ctrl & BNX2X_FLOW_CTRL_TX))\n\t\tval |= 0x800000;\n\twb_data[0] = val;\n\twb_data[1] = 0;\n\tREG_WR_DMAE(bp, bmac_addr + BIGMAC2_REGISTER_TX_CONTROL, wb_data, 2);\n\n\tif (params->feature_config_flags & FEATURE_CONFIG_PFC_ENABLED) {\n\t\tDP(NETIF_MSG_LINK, \"PFC is enabled\\n\");\n\t\t \n\t\twb_data[0] = 0x0;\n\t\twb_data[0] |= (1<<0);   \n\t\twb_data[0] |= (1<<1);   \n\t\twb_data[0] |= (1<<2);   \n\t\twb_data[0] |= (1<<3);   \n\t\twb_data[0] |= (1<<5);   \n\t\twb_data[1] = 0;\n\t\tREG_WR_DMAE(bp, bmac_addr + BIGMAC2_REGISTER_PFC_CONTROL,\n\t\t\t    wb_data, 2);\n\t\t \n\t\twb_data[0] &= ~(1<<2);\n\t} else {\n\t\tDP(NETIF_MSG_LINK, \"PFC is disabled\\n\");\n\t\t \n\t\twb_data[0] = 0x8;\n\t\twb_data[1] = 0;\n\t}\n\n\tREG_WR_DMAE(bp, bmac_addr + BIGMAC2_REGISTER_PFC_CONTROL, wb_data, 2);\n\n\t \n\tval = 0x8000;\n\tif (params->feature_config_flags & FEATURE_CONFIG_PFC_ENABLED)\n\t\tval |= (1<<16);  \n\n\twb_data[0] = val;\n\twb_data[1] = 0;\n\tREG_WR_DMAE(bp, bmac_addr + BIGMAC2_REGISTER_TX_PAUSE_CONTROL,\n\t\t    wb_data, 2);\n\n\t \n\tval = 0x3;  \n\tif (is_lb) {\n\t\tval |= 0x4;  \n\t\tDP(NETIF_MSG_LINK, \"enable bmac loopback\\n\");\n\t}\n\t \n\tif (params->feature_config_flags & FEATURE_CONFIG_PFC_ENABLED)\n\t\tval |= ((1<<6)|(1<<5));\n\n\twb_data[0] = val;\n\twb_data[1] = 0;\n\tREG_WR_DMAE(bp, bmac_addr + BIGMAC2_REGISTER_BMAC_CONTROL, wb_data, 2);\n}\n\n \nstatic int bnx2x_pfc_nig_rx_priority_mask(struct bnx2x *bp,\n\t\t\t\t\t   u8 cos_entry,\n\t\t\t\t\t   u32 priority_mask, u8 port)\n{\n\tu32 nig_reg_rx_priority_mask_add = 0;\n\n\tswitch (cos_entry) {\n\tcase 0:\n\t     nig_reg_rx_priority_mask_add = (port) ?\n\t\t NIG_REG_P1_RX_COS0_PRIORITY_MASK :\n\t\t NIG_REG_P0_RX_COS0_PRIORITY_MASK;\n\t     break;\n\tcase 1:\n\t    nig_reg_rx_priority_mask_add = (port) ?\n\t\tNIG_REG_P1_RX_COS1_PRIORITY_MASK :\n\t\tNIG_REG_P0_RX_COS1_PRIORITY_MASK;\n\t    break;\n\tcase 2:\n\t    nig_reg_rx_priority_mask_add = (port) ?\n\t\tNIG_REG_P1_RX_COS2_PRIORITY_MASK :\n\t\tNIG_REG_P0_RX_COS2_PRIORITY_MASK;\n\t    break;\n\tcase 3:\n\t    if (port)\n\t\treturn -EINVAL;\n\t    nig_reg_rx_priority_mask_add = NIG_REG_P0_RX_COS3_PRIORITY_MASK;\n\t    break;\n\tcase 4:\n\t    if (port)\n\t\treturn -EINVAL;\n\t    nig_reg_rx_priority_mask_add = NIG_REG_P0_RX_COS4_PRIORITY_MASK;\n\t    break;\n\tcase 5:\n\t    if (port)\n\t\treturn -EINVAL;\n\t    nig_reg_rx_priority_mask_add = NIG_REG_P0_RX_COS5_PRIORITY_MASK;\n\t    break;\n\t}\n\n\tREG_WR(bp, nig_reg_rx_priority_mask_add, priority_mask);\n\n\treturn 0;\n}\nstatic void bnx2x_update_mng(struct link_params *params, u32 link_status)\n{\n\tstruct bnx2x *bp = params->bp;\n\n\tREG_WR(bp, params->shmem_base +\n\t       offsetof(struct shmem_region,\n\t\t\tport_mb[params->port].link_status), link_status);\n}\n\nstatic void bnx2x_update_link_attr(struct link_params *params, u32 link_attr)\n{\n\tstruct bnx2x *bp = params->bp;\n\n\tif (SHMEM2_HAS(bp, link_attr_sync))\n\t\tREG_WR(bp, params->shmem2_base +\n\t\t       offsetof(struct shmem2_region,\n\t\t\t\tlink_attr_sync[params->port]), link_attr);\n}\n\nstatic void bnx2x_update_pfc_nig(struct link_params *params,\n\t\tstruct link_vars *vars,\n\t\tstruct bnx2x_nig_brb_pfc_port_params *nig_params)\n{\n\tu32 xcm_mask = 0, ppp_enable = 0, pause_enable = 0, llfc_out_en = 0;\n\tu32 llfc_enable = 0, xcm_out_en = 0, hwpfc_enable = 0;\n\tu32 pkt_priority_to_cos = 0;\n\tstruct bnx2x *bp = params->bp;\n\tu8 port = params->port;\n\n\tint set_pfc = params->feature_config_flags &\n\t\tFEATURE_CONFIG_PFC_ENABLED;\n\tDP(NETIF_MSG_LINK, \"updating pfc nig parameters\\n\");\n\n\t \n\txcm_mask = REG_RD(bp, port ? NIG_REG_LLH1_XCM_MASK :\n\t\t\t  NIG_REG_LLH0_XCM_MASK);\n\t \n\tif (set_pfc) {\n\t\tpause_enable = 0;\n\t\tllfc_out_en = 0;\n\t\tllfc_enable = 0;\n\t\tif (CHIP_IS_E3(bp))\n\t\t\tppp_enable = 0;\n\t\telse\n\t\t\tppp_enable = 1;\n\t\txcm_mask &= ~(port ? NIG_LLH1_XCM_MASK_REG_LLH1_XCM_MASK_BCN :\n\t\t\t\t     NIG_LLH0_XCM_MASK_REG_LLH0_XCM_MASK_BCN);\n\t\txcm_out_en = 0;\n\t\thwpfc_enable = 1;\n\t} else  {\n\t\tif (nig_params) {\n\t\t\tllfc_out_en = nig_params->llfc_out_en;\n\t\t\tllfc_enable = nig_params->llfc_enable;\n\t\t\tpause_enable = nig_params->pause_enable;\n\t\t} else   \n\t\t\tpause_enable = 1;\n\n\t\txcm_mask |= (port ? NIG_LLH1_XCM_MASK_REG_LLH1_XCM_MASK_BCN :\n\t\t\tNIG_LLH0_XCM_MASK_REG_LLH0_XCM_MASK_BCN);\n\t\txcm_out_en = 1;\n\t}\n\n\tif (CHIP_IS_E3(bp))\n\t\tREG_WR(bp, port ? NIG_REG_BRB1_PAUSE_IN_EN :\n\t\t       NIG_REG_BRB0_PAUSE_IN_EN, pause_enable);\n\tREG_WR(bp, port ? NIG_REG_LLFC_OUT_EN_1 :\n\t       NIG_REG_LLFC_OUT_EN_0, llfc_out_en);\n\tREG_WR(bp, port ? NIG_REG_LLFC_ENABLE_1 :\n\t       NIG_REG_LLFC_ENABLE_0, llfc_enable);\n\tREG_WR(bp, port ? NIG_REG_PAUSE_ENABLE_1 :\n\t       NIG_REG_PAUSE_ENABLE_0, pause_enable);\n\n\tREG_WR(bp, port ? NIG_REG_PPP_ENABLE_1 :\n\t       NIG_REG_PPP_ENABLE_0, ppp_enable);\n\n\tREG_WR(bp, port ? NIG_REG_LLH1_XCM_MASK :\n\t       NIG_REG_LLH0_XCM_MASK, xcm_mask);\n\n\tREG_WR(bp, port ? NIG_REG_LLFC_EGRESS_SRC_ENABLE_1 :\n\t       NIG_REG_LLFC_EGRESS_SRC_ENABLE_0, 0x7);\n\n\t \n\tREG_WR(bp, port ? NIG_REG_XCM1_OUT_EN :\n\t       NIG_REG_XCM0_OUT_EN, xcm_out_en);\n\n\t \n\tREG_WR(bp, port ? NIG_REG_P1_HWPFC_ENABLE :\n\t       NIG_REG_P0_HWPFC_ENABLE, hwpfc_enable);\n\n\tif (nig_params) {\n\t\tu8 i = 0;\n\t\tpkt_priority_to_cos = nig_params->pkt_priority_to_cos;\n\n\t\tfor (i = 0; i < nig_params->num_of_rx_cos_priority_mask; i++)\n\t\t\tbnx2x_pfc_nig_rx_priority_mask(bp, i,\n\t\tnig_params->rx_cos_priority_mask[i], port);\n\n\t\tREG_WR(bp, port ? NIG_REG_LLFC_HIGH_PRIORITY_CLASSES_1 :\n\t\t       NIG_REG_LLFC_HIGH_PRIORITY_CLASSES_0,\n\t\t       nig_params->llfc_high_priority_classes);\n\n\t\tREG_WR(bp, port ? NIG_REG_LLFC_LOW_PRIORITY_CLASSES_1 :\n\t\t       NIG_REG_LLFC_LOW_PRIORITY_CLASSES_0,\n\t\t       nig_params->llfc_low_priority_classes);\n\t}\n\tREG_WR(bp, port ? NIG_REG_P1_PKT_PRIORITY_TO_COS :\n\t       NIG_REG_P0_PKT_PRIORITY_TO_COS,\n\t       pkt_priority_to_cos);\n}\n\nint bnx2x_update_pfc(struct link_params *params,\n\t\t      struct link_vars *vars,\n\t\t      struct bnx2x_nig_brb_pfc_port_params *pfc_params)\n{\n\t \n\tu32 val;\n\tstruct bnx2x *bp = params->bp;\n\tu8 bmac_loopback = (params->loopback_mode == LOOPBACK_BMAC);\n\n\tif (params->feature_config_flags & FEATURE_CONFIG_PFC_ENABLED)\n\t\tvars->link_status |= LINK_STATUS_PFC_ENABLED;\n\telse\n\t\tvars->link_status &= ~LINK_STATUS_PFC_ENABLED;\n\n\tbnx2x_update_mng(params, vars->link_status);\n\n\t \n\tbnx2x_update_pfc_nig(params, vars, pfc_params);\n\n\tif (!vars->link_up)\n\t\treturn 0;\n\n\tDP(NETIF_MSG_LINK, \"About to update PFC in BMAC\\n\");\n\n\tif (CHIP_IS_E3(bp)) {\n\t\tif (vars->mac_type == MAC_TYPE_XMAC)\n\t\t\tbnx2x_update_pfc_xmac(params, vars, 0);\n\t} else {\n\t\tval = REG_RD(bp, MISC_REG_RESET_REG_2);\n\t\tif ((val &\n\t\t     (MISC_REGISTERS_RESET_REG_2_RST_BMAC0 << params->port))\n\t\t    == 0) {\n\t\t\tDP(NETIF_MSG_LINK, \"About to update PFC in EMAC\\n\");\n\t\t\tbnx2x_emac_enable(params, vars, 0);\n\t\t\treturn 0;\n\t\t}\n\t\tif (CHIP_IS_E2(bp))\n\t\t\tbnx2x_update_pfc_bmac2(params, vars, bmac_loopback);\n\t\telse\n\t\t\tbnx2x_update_pfc_bmac1(params, vars);\n\n\t\tval = 0;\n\t\tif ((params->feature_config_flags &\n\t\t     FEATURE_CONFIG_PFC_ENABLED) ||\n\t\t    (vars->flow_ctrl & BNX2X_FLOW_CTRL_TX))\n\t\t\tval = 1;\n\t\tREG_WR(bp, NIG_REG_BMAC0_PAUSE_OUT_EN + params->port*4, val);\n\t}\n\treturn 0;\n}\n\nstatic int bnx2x_bmac1_enable(struct link_params *params,\n\t\t\t      struct link_vars *vars,\n\t\t\t      u8 is_lb)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu8 port = params->port;\n\tu32 bmac_addr = port ? NIG_REG_INGRESS_BMAC1_MEM :\n\t\t\t       NIG_REG_INGRESS_BMAC0_MEM;\n\tu32 wb_data[2];\n\tu32 val;\n\n\tDP(NETIF_MSG_LINK, \"Enabling BigMAC1\\n\");\n\n\t \n\twb_data[0] = 0x3c;\n\twb_data[1] = 0;\n\tREG_WR_DMAE(bp, bmac_addr + BIGMAC_REGISTER_BMAC_XGXS_CONTROL,\n\t\t    wb_data, 2);\n\n\t \n\twb_data[0] = ((params->mac_addr[2] << 24) |\n\t\t       (params->mac_addr[3] << 16) |\n\t\t       (params->mac_addr[4] << 8) |\n\t\t\tparams->mac_addr[5]);\n\twb_data[1] = ((params->mac_addr[0] << 8) |\n\t\t\tparams->mac_addr[1]);\n\tREG_WR_DMAE(bp, bmac_addr + BIGMAC_REGISTER_TX_SOURCE_ADDR, wb_data, 2);\n\n\t \n\tval = 0x3;\n\tif (is_lb) {\n\t\tval |= 0x4;\n\t\tDP(NETIF_MSG_LINK, \"enable bmac loopback\\n\");\n\t}\n\twb_data[0] = val;\n\twb_data[1] = 0;\n\tREG_WR_DMAE(bp, bmac_addr + BIGMAC_REGISTER_BMAC_CONTROL, wb_data, 2);\n\n\t \n\twb_data[0] = ETH_MAX_JUMBO_PACKET_SIZE + ETH_OVERHEAD;\n\twb_data[1] = 0;\n\tREG_WR_DMAE(bp, bmac_addr + BIGMAC_REGISTER_RX_MAX_SIZE, wb_data, 2);\n\n\tbnx2x_update_pfc_bmac1(params, vars);\n\n\t \n\twb_data[0] = ETH_MAX_JUMBO_PACKET_SIZE + ETH_OVERHEAD;\n\twb_data[1] = 0;\n\tREG_WR_DMAE(bp, bmac_addr + BIGMAC_REGISTER_TX_MAX_SIZE, wb_data, 2);\n\n\t \n\twb_data[0] = ETH_MAX_JUMBO_PACKET_SIZE + ETH_OVERHEAD;\n\twb_data[1] = 0;\n\tREG_WR_DMAE(bp, bmac_addr + BIGMAC_REGISTER_CNT_MAX_SIZE, wb_data, 2);\n\n\t \n\twb_data[0] = 0x1000200;\n\twb_data[1] = 0;\n\tREG_WR_DMAE(bp, bmac_addr + BIGMAC_REGISTER_RX_LLFC_MSG_FLDS,\n\t\t    wb_data, 2);\n\n\treturn 0;\n}\n\nstatic int bnx2x_bmac2_enable(struct link_params *params,\n\t\t\t      struct link_vars *vars,\n\t\t\t      u8 is_lb)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu8 port = params->port;\n\tu32 bmac_addr = port ? NIG_REG_INGRESS_BMAC1_MEM :\n\t\t\t       NIG_REG_INGRESS_BMAC0_MEM;\n\tu32 wb_data[2];\n\n\tDP(NETIF_MSG_LINK, \"Enabling BigMAC2\\n\");\n\n\twb_data[0] = 0;\n\twb_data[1] = 0;\n\tREG_WR_DMAE(bp, bmac_addr + BIGMAC2_REGISTER_BMAC_CONTROL, wb_data, 2);\n\tudelay(30);\n\n\t \n\twb_data[0] = 0x3c;\n\twb_data[1] = 0;\n\tREG_WR_DMAE(bp, bmac_addr + BIGMAC2_REGISTER_BMAC_XGXS_CONTROL,\n\t\t    wb_data, 2);\n\n\tudelay(30);\n\n\t \n\twb_data[0] = ((params->mac_addr[2] << 24) |\n\t\t       (params->mac_addr[3] << 16) |\n\t\t       (params->mac_addr[4] << 8) |\n\t\t\tparams->mac_addr[5]);\n\twb_data[1] = ((params->mac_addr[0] << 8) |\n\t\t\tparams->mac_addr[1]);\n\tREG_WR_DMAE(bp, bmac_addr + BIGMAC2_REGISTER_TX_SOURCE_ADDR,\n\t\t    wb_data, 2);\n\n\tudelay(30);\n\n\t \n\twb_data[0] = 0x1000200;\n\twb_data[1] = 0;\n\tREG_WR_DMAE(bp, bmac_addr + BIGMAC2_REGISTER_RX_LLFC_MSG_FLDS,\n\t\t    wb_data, 2);\n\tudelay(30);\n\n\t \n\twb_data[0] = ETH_MAX_JUMBO_PACKET_SIZE + ETH_OVERHEAD;\n\twb_data[1] = 0;\n\tREG_WR_DMAE(bp, bmac_addr + BIGMAC2_REGISTER_RX_MAX_SIZE, wb_data, 2);\n\tudelay(30);\n\n\t \n\twb_data[0] = ETH_MAX_JUMBO_PACKET_SIZE + ETH_OVERHEAD;\n\twb_data[1] = 0;\n\tREG_WR_DMAE(bp, bmac_addr + BIGMAC2_REGISTER_TX_MAX_SIZE, wb_data, 2);\n\tudelay(30);\n\t \n\twb_data[0] = ETH_MAX_JUMBO_PACKET_SIZE + ETH_OVERHEAD - 2;\n\twb_data[1] = 0;\n\tREG_WR_DMAE(bp, bmac_addr + BIGMAC2_REGISTER_CNT_MAX_SIZE, wb_data, 2);\n\tudelay(30);\n\tbnx2x_update_pfc_bmac2(params, vars, is_lb);\n\n\treturn 0;\n}\n\nstatic int bnx2x_bmac_enable(struct link_params *params,\n\t\t\t     struct link_vars *vars,\n\t\t\t     u8 is_lb, u8 reset_bmac)\n{\n\tint rc = 0;\n\tu8 port = params->port;\n\tstruct bnx2x *bp = params->bp;\n\tu32 val;\n\t \n\tif (reset_bmac) {\n\t\tREG_WR(bp, GRCBASE_MISC + MISC_REGISTERS_RESET_REG_2_CLEAR,\n\t\t       (MISC_REGISTERS_RESET_REG_2_RST_BMAC0 << port));\n\t\tusleep_range(1000, 2000);\n\t}\n\n\tREG_WR(bp, GRCBASE_MISC + MISC_REGISTERS_RESET_REG_2_SET,\n\t       (MISC_REGISTERS_RESET_REG_2_RST_BMAC0 << port));\n\n\t \n\tREG_WR(bp, NIG_REG_BMAC0_REGS_OUT_EN + port*4, 0x1);\n\n\t \n\tif (CHIP_IS_E2(bp))\n\t\trc = bnx2x_bmac2_enable(params, vars, is_lb);\n\telse\n\t\trc = bnx2x_bmac1_enable(params, vars, is_lb);\n\tREG_WR(bp, NIG_REG_XGXS_SERDES0_MODE_SEL + port*4, 0x1);\n\tREG_WR(bp, NIG_REG_XGXS_LANE_SEL_P0 + port*4, 0x0);\n\tREG_WR(bp, NIG_REG_EGRESS_EMAC0_PORT + port*4, 0x0);\n\tval = 0;\n\tif ((params->feature_config_flags &\n\t      FEATURE_CONFIG_PFC_ENABLED) ||\n\t    (vars->flow_ctrl & BNX2X_FLOW_CTRL_TX))\n\t\tval = 1;\n\tREG_WR(bp, NIG_REG_BMAC0_PAUSE_OUT_EN + port*4, val);\n\tREG_WR(bp, NIG_REG_EGRESS_EMAC0_OUT_EN + port*4, 0x0);\n\tREG_WR(bp, NIG_REG_EMAC0_IN_EN + port*4, 0x0);\n\tREG_WR(bp, NIG_REG_EMAC0_PAUSE_OUT_EN + port*4, 0x0);\n\tREG_WR(bp, NIG_REG_BMAC0_IN_EN + port*4, 0x1);\n\tREG_WR(bp, NIG_REG_BMAC0_OUT_EN + port*4, 0x1);\n\n\tvars->mac_type = MAC_TYPE_BMAC;\n\treturn rc;\n}\n\nstatic void bnx2x_set_bmac_rx(struct bnx2x *bp, u32 chip_id, u8 port, u8 en)\n{\n\tu32 bmac_addr = port ? NIG_REG_INGRESS_BMAC1_MEM :\n\t\t\tNIG_REG_INGRESS_BMAC0_MEM;\n\tu32 wb_data[2];\n\tu32 nig_bmac_enable = REG_RD(bp, NIG_REG_BMAC0_REGS_OUT_EN + port*4);\n\n\tif (CHIP_IS_E2(bp))\n\t\tbmac_addr += BIGMAC2_REGISTER_BMAC_CONTROL;\n\telse\n\t\tbmac_addr += BIGMAC_REGISTER_BMAC_CONTROL;\n\t \n\tif (REG_RD(bp, MISC_REG_RESET_REG_2) &\n\t\t\t(MISC_REGISTERS_RESET_REG_2_RST_BMAC0 << port) &&\n\t    nig_bmac_enable) {\n\t\t \n\t\tREG_RD_DMAE(bp, bmac_addr, wb_data, 2);\n\t\tif (en)\n\t\t\twb_data[0] |= BMAC_CONTROL_RX_ENABLE;\n\t\telse\n\t\t\twb_data[0] &= ~BMAC_CONTROL_RX_ENABLE;\n\t\tREG_WR_DMAE(bp, bmac_addr, wb_data, 2);\n\t\tusleep_range(1000, 2000);\n\t}\n}\n\nstatic int bnx2x_pbf_update(struct link_params *params, u32 flow_ctrl,\n\t\t\t    u32 line_speed)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu8 port = params->port;\n\tu32 init_crd, crd;\n\tu32 count = 1000;\n\n\t \n\tREG_WR(bp, PBF_REG_DISABLE_NEW_TASK_PROC_P0 + port*4, 0x1);\n\n\t \n\tinit_crd = REG_RD(bp, PBF_REG_P0_INIT_CRD + port*4);\n\tcrd = REG_RD(bp, PBF_REG_P0_CREDIT + port*8);\n\tDP(NETIF_MSG_LINK, \"init_crd 0x%x  crd 0x%x\\n\", init_crd, crd);\n\n\twhile ((init_crd != crd) && count) {\n\t\tusleep_range(5000, 10000);\n\t\tcrd = REG_RD(bp, PBF_REG_P0_CREDIT + port*8);\n\t\tcount--;\n\t}\n\tcrd = REG_RD(bp, PBF_REG_P0_CREDIT + port*8);\n\tif (init_crd != crd) {\n\t\tDP(NETIF_MSG_LINK, \"BUG! init_crd 0x%x != crd 0x%x\\n\",\n\t\t\t  init_crd, crd);\n\t\treturn -EINVAL;\n\t}\n\n\tif (flow_ctrl & BNX2X_FLOW_CTRL_RX ||\n\t    line_speed == SPEED_10 ||\n\t    line_speed == SPEED_100 ||\n\t    line_speed == SPEED_1000 ||\n\t    line_speed == SPEED_2500) {\n\t\tREG_WR(bp, PBF_REG_P0_PAUSE_ENABLE + port*4, 1);\n\t\t \n\t\tREG_WR(bp, PBF_REG_P0_ARB_THRSH + port*4, 0);\n\t\t \n\t\tinit_crd = 778;\t\t \n\n\t} else {\n\t\tu32 thresh = (ETH_MAX_JUMBO_PACKET_SIZE +\n\t\t\t      ETH_OVERHEAD)/16;\n\t\tREG_WR(bp, PBF_REG_P0_PAUSE_ENABLE + port*4, 0);\n\t\t \n\t\tREG_WR(bp, PBF_REG_P0_ARB_THRSH + port*4, thresh);\n\t\t \n\t\tswitch (line_speed) {\n\t\tcase SPEED_10000:\n\t\t\tinit_crd = thresh + 553 - 22;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDP(NETIF_MSG_LINK, \"Invalid line_speed 0x%x\\n\",\n\t\t\t\t  line_speed);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tREG_WR(bp, PBF_REG_P0_INIT_CRD + port*4, init_crd);\n\tDP(NETIF_MSG_LINK, \"PBF updated to speed %d credit %d\\n\",\n\t\t line_speed, init_crd);\n\n\t \n\tREG_WR(bp, PBF_REG_INIT_P0 + port*4, 0x1);\n\tusleep_range(5000, 10000);\n\tREG_WR(bp, PBF_REG_INIT_P0 + port*4, 0x0);\n\n\t \n\tREG_WR(bp, PBF_REG_DISABLE_NEW_TASK_PROC_P0 + port*4, 0x0);\n\treturn 0;\n}\n\n \nstatic u32 bnx2x_get_emac_base(struct bnx2x *bp,\n\t\t\t       u32 mdc_mdio_access, u8 port)\n{\n\tu32 emac_base = 0;\n\tswitch (mdc_mdio_access) {\n\tcase SHARED_HW_CFG_MDC_MDIO_ACCESS1_PHY_TYPE:\n\t\tbreak;\n\tcase SHARED_HW_CFG_MDC_MDIO_ACCESS1_EMAC0:\n\t\tif (REG_RD(bp, NIG_REG_PORT_SWAP))\n\t\t\temac_base = GRCBASE_EMAC1;\n\t\telse\n\t\t\temac_base = GRCBASE_EMAC0;\n\t\tbreak;\n\tcase SHARED_HW_CFG_MDC_MDIO_ACCESS1_EMAC1:\n\t\tif (REG_RD(bp, NIG_REG_PORT_SWAP))\n\t\t\temac_base = GRCBASE_EMAC0;\n\t\telse\n\t\t\temac_base = GRCBASE_EMAC1;\n\t\tbreak;\n\tcase SHARED_HW_CFG_MDC_MDIO_ACCESS1_BOTH:\n\t\temac_base = (port) ? GRCBASE_EMAC1 : GRCBASE_EMAC0;\n\t\tbreak;\n\tcase SHARED_HW_CFG_MDC_MDIO_ACCESS1_SWAPPED:\n\t\temac_base = (port) ? GRCBASE_EMAC0 : GRCBASE_EMAC1;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn emac_base;\n\n}\n\n \n \n \nstatic int bnx2x_cl22_write(struct bnx2x *bp,\n\t\t\t\t       struct bnx2x_phy *phy,\n\t\t\t\t       u16 reg, u16 val)\n{\n\tu32 tmp, mode;\n\tu8 i;\n\tint rc = 0;\n\t \n\tmode = REG_RD(bp, phy->mdio_ctrl + EMAC_REG_EMAC_MDIO_MODE);\n\tREG_WR(bp, phy->mdio_ctrl + EMAC_REG_EMAC_MDIO_MODE,\n\t       mode & ~EMAC_MDIO_MODE_CLAUSE_45);\n\n\t \n\ttmp = ((phy->addr << 21) | (reg << 16) | val |\n\t       EMAC_MDIO_COMM_COMMAND_WRITE_22 |\n\t       EMAC_MDIO_COMM_START_BUSY);\n\tREG_WR(bp, phy->mdio_ctrl + EMAC_REG_EMAC_MDIO_COMM, tmp);\n\n\tfor (i = 0; i < 50; i++) {\n\t\tudelay(10);\n\n\t\ttmp = REG_RD(bp, phy->mdio_ctrl + EMAC_REG_EMAC_MDIO_COMM);\n\t\tif (!(tmp & EMAC_MDIO_COMM_START_BUSY)) {\n\t\t\tudelay(5);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (tmp & EMAC_MDIO_COMM_START_BUSY) {\n\t\tDP(NETIF_MSG_LINK, \"write phy register failed\\n\");\n\t\trc = -EFAULT;\n\t}\n\tREG_WR(bp, phy->mdio_ctrl + EMAC_REG_EMAC_MDIO_MODE, mode);\n\treturn rc;\n}\n\nstatic int bnx2x_cl22_read(struct bnx2x *bp,\n\t\t\t\t      struct bnx2x_phy *phy,\n\t\t\t\t      u16 reg, u16 *ret_val)\n{\n\tu32 val, mode;\n\tu16 i;\n\tint rc = 0;\n\n\t \n\tmode = REG_RD(bp, phy->mdio_ctrl + EMAC_REG_EMAC_MDIO_MODE);\n\tREG_WR(bp, phy->mdio_ctrl + EMAC_REG_EMAC_MDIO_MODE,\n\t       mode & ~EMAC_MDIO_MODE_CLAUSE_45);\n\n\t \n\tval = ((phy->addr << 21) | (reg << 16) |\n\t       EMAC_MDIO_COMM_COMMAND_READ_22 |\n\t       EMAC_MDIO_COMM_START_BUSY);\n\tREG_WR(bp, phy->mdio_ctrl + EMAC_REG_EMAC_MDIO_COMM, val);\n\n\tfor (i = 0; i < 50; i++) {\n\t\tudelay(10);\n\n\t\tval = REG_RD(bp, phy->mdio_ctrl + EMAC_REG_EMAC_MDIO_COMM);\n\t\tif (!(val & EMAC_MDIO_COMM_START_BUSY)) {\n\t\t\t*ret_val = (u16)(val & EMAC_MDIO_COMM_DATA);\n\t\t\tudelay(5);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (val & EMAC_MDIO_COMM_START_BUSY) {\n\t\tDP(NETIF_MSG_LINK, \"read phy register failed\\n\");\n\n\t\t*ret_val = 0;\n\t\trc = -EFAULT;\n\t}\n\tREG_WR(bp, phy->mdio_ctrl + EMAC_REG_EMAC_MDIO_MODE, mode);\n\treturn rc;\n}\n\n \n \n \nstatic int bnx2x_cl45_read(struct bnx2x *bp, struct bnx2x_phy *phy,\n\t\t\t   u8 devad, u16 reg, u16 *ret_val)\n{\n\tu32 val;\n\tu16 i;\n\tint rc = 0;\n\tu32 chip_id;\n\tif (phy->flags & FLAGS_MDC_MDIO_WA_G) {\n\t\tchip_id = (REG_RD(bp, MISC_REG_CHIP_NUM) << 16) |\n\t\t\t  ((REG_RD(bp, MISC_REG_CHIP_REV) & 0xf) << 12);\n\t\tbnx2x_set_mdio_clk(bp, chip_id, phy->mdio_ctrl);\n\t}\n\n\tif (phy->flags & FLAGS_MDC_MDIO_WA_B0)\n\t\tbnx2x_bits_en(bp, phy->mdio_ctrl + EMAC_REG_EMAC_MDIO_STATUS,\n\t\t\t      EMAC_MDIO_STATUS_10MB);\n\t \n\tval = ((phy->addr << 21) | (devad << 16) | reg |\n\t       EMAC_MDIO_COMM_COMMAND_ADDRESS |\n\t       EMAC_MDIO_COMM_START_BUSY);\n\tREG_WR(bp, phy->mdio_ctrl + EMAC_REG_EMAC_MDIO_COMM, val);\n\n\tfor (i = 0; i < 50; i++) {\n\t\tudelay(10);\n\n\t\tval = REG_RD(bp, phy->mdio_ctrl + EMAC_REG_EMAC_MDIO_COMM);\n\t\tif (!(val & EMAC_MDIO_COMM_START_BUSY)) {\n\t\t\tudelay(5);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (val & EMAC_MDIO_COMM_START_BUSY) {\n\t\tDP(NETIF_MSG_LINK, \"read phy register failed\\n\");\n\t\tnetdev_err(bp->dev,  \"MDC/MDIO access timeout\\n\");\n\t\t*ret_val = 0;\n\t\trc = -EFAULT;\n\t} else {\n\t\t \n\t\tval = ((phy->addr << 21) | (devad << 16) |\n\t\t       EMAC_MDIO_COMM_COMMAND_READ_45 |\n\t\t       EMAC_MDIO_COMM_START_BUSY);\n\t\tREG_WR(bp, phy->mdio_ctrl + EMAC_REG_EMAC_MDIO_COMM, val);\n\n\t\tfor (i = 0; i < 50; i++) {\n\t\t\tudelay(10);\n\n\t\t\tval = REG_RD(bp, phy->mdio_ctrl +\n\t\t\t\t     EMAC_REG_EMAC_MDIO_COMM);\n\t\t\tif (!(val & EMAC_MDIO_COMM_START_BUSY)) {\n\t\t\t\t*ret_val = (u16)(val & EMAC_MDIO_COMM_DATA);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (val & EMAC_MDIO_COMM_START_BUSY) {\n\t\t\tDP(NETIF_MSG_LINK, \"read phy register failed\\n\");\n\t\t\tnetdev_err(bp->dev,  \"MDC/MDIO access timeout\\n\");\n\t\t\t*ret_val = 0;\n\t\t\trc = -EFAULT;\n\t\t}\n\t}\n\t \n\tif (phy->flags & FLAGS_MDC_MDIO_WA) {\n\t\tphy->flags ^= FLAGS_DUMMY_READ;\n\t\tif (phy->flags & FLAGS_DUMMY_READ) {\n\t\t\tu16 temp_val;\n\t\t\tbnx2x_cl45_read(bp, phy, devad, 0xf, &temp_val);\n\t\t}\n\t}\n\n\tif (phy->flags & FLAGS_MDC_MDIO_WA_B0)\n\t\tbnx2x_bits_dis(bp, phy->mdio_ctrl + EMAC_REG_EMAC_MDIO_STATUS,\n\t\t\t       EMAC_MDIO_STATUS_10MB);\n\treturn rc;\n}\n\nstatic int bnx2x_cl45_write(struct bnx2x *bp, struct bnx2x_phy *phy,\n\t\t\t    u8 devad, u16 reg, u16 val)\n{\n\tu32 tmp;\n\tu8 i;\n\tint rc = 0;\n\tu32 chip_id;\n\tif (phy->flags & FLAGS_MDC_MDIO_WA_G) {\n\t\tchip_id = (REG_RD(bp, MISC_REG_CHIP_NUM) << 16) |\n\t\t\t  ((REG_RD(bp, MISC_REG_CHIP_REV) & 0xf) << 12);\n\t\tbnx2x_set_mdio_clk(bp, chip_id, phy->mdio_ctrl);\n\t}\n\n\tif (phy->flags & FLAGS_MDC_MDIO_WA_B0)\n\t\tbnx2x_bits_en(bp, phy->mdio_ctrl + EMAC_REG_EMAC_MDIO_STATUS,\n\t\t\t      EMAC_MDIO_STATUS_10MB);\n\n\t \n\ttmp = ((phy->addr << 21) | (devad << 16) | reg |\n\t       EMAC_MDIO_COMM_COMMAND_ADDRESS |\n\t       EMAC_MDIO_COMM_START_BUSY);\n\tREG_WR(bp, phy->mdio_ctrl + EMAC_REG_EMAC_MDIO_COMM, tmp);\n\n\tfor (i = 0; i < 50; i++) {\n\t\tudelay(10);\n\n\t\ttmp = REG_RD(bp, phy->mdio_ctrl + EMAC_REG_EMAC_MDIO_COMM);\n\t\tif (!(tmp & EMAC_MDIO_COMM_START_BUSY)) {\n\t\t\tudelay(5);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (tmp & EMAC_MDIO_COMM_START_BUSY) {\n\t\tDP(NETIF_MSG_LINK, \"write phy register failed\\n\");\n\t\tnetdev_err(bp->dev,  \"MDC/MDIO access timeout\\n\");\n\t\trc = -EFAULT;\n\t} else {\n\t\t \n\t\ttmp = ((phy->addr << 21) | (devad << 16) | val |\n\t\t       EMAC_MDIO_COMM_COMMAND_WRITE_45 |\n\t\t       EMAC_MDIO_COMM_START_BUSY);\n\t\tREG_WR(bp, phy->mdio_ctrl + EMAC_REG_EMAC_MDIO_COMM, tmp);\n\n\t\tfor (i = 0; i < 50; i++) {\n\t\t\tudelay(10);\n\n\t\t\ttmp = REG_RD(bp, phy->mdio_ctrl +\n\t\t\t\t     EMAC_REG_EMAC_MDIO_COMM);\n\t\t\tif (!(tmp & EMAC_MDIO_COMM_START_BUSY)) {\n\t\t\t\tudelay(5);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (tmp & EMAC_MDIO_COMM_START_BUSY) {\n\t\t\tDP(NETIF_MSG_LINK, \"write phy register failed\\n\");\n\t\t\tnetdev_err(bp->dev,  \"MDC/MDIO access timeout\\n\");\n\t\t\trc = -EFAULT;\n\t\t}\n\t}\n\t \n\tif (phy->flags & FLAGS_MDC_MDIO_WA) {\n\t\tphy->flags ^= FLAGS_DUMMY_READ;\n\t\tif (phy->flags & FLAGS_DUMMY_READ) {\n\t\t\tu16 temp_val;\n\t\t\tbnx2x_cl45_read(bp, phy, devad, 0xf, &temp_val);\n\t\t}\n\t}\n\tif (phy->flags & FLAGS_MDC_MDIO_WA_B0)\n\t\tbnx2x_bits_dis(bp, phy->mdio_ctrl + EMAC_REG_EMAC_MDIO_STATUS,\n\t\t\t       EMAC_MDIO_STATUS_10MB);\n\treturn rc;\n}\n\n \n \n \nstatic u8 bnx2x_eee_has_cap(struct link_params *params)\n{\n\tstruct bnx2x *bp = params->bp;\n\n\tif (REG_RD(bp, params->shmem2_base) <=\n\t\t   offsetof(struct shmem2_region, eee_status[params->port]))\n\t\treturn 0;\n\n\treturn 1;\n}\n\nstatic int bnx2x_eee_nvram_to_time(u32 nvram_mode, u32 *idle_timer)\n{\n\tswitch (nvram_mode) {\n\tcase PORT_FEAT_CFG_EEE_POWER_MODE_BALANCED:\n\t\t*idle_timer = EEE_MODE_NVRAM_BALANCED_TIME;\n\t\tbreak;\n\tcase PORT_FEAT_CFG_EEE_POWER_MODE_AGGRESSIVE:\n\t\t*idle_timer = EEE_MODE_NVRAM_AGGRESSIVE_TIME;\n\t\tbreak;\n\tcase PORT_FEAT_CFG_EEE_POWER_MODE_LOW_LATENCY:\n\t\t*idle_timer = EEE_MODE_NVRAM_LATENCY_TIME;\n\t\tbreak;\n\tdefault:\n\t\t*idle_timer = 0;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int bnx2x_eee_time_to_nvram(u32 idle_timer, u32 *nvram_mode)\n{\n\tswitch (idle_timer) {\n\tcase EEE_MODE_NVRAM_BALANCED_TIME:\n\t\t*nvram_mode = PORT_FEAT_CFG_EEE_POWER_MODE_BALANCED;\n\t\tbreak;\n\tcase EEE_MODE_NVRAM_AGGRESSIVE_TIME:\n\t\t*nvram_mode = PORT_FEAT_CFG_EEE_POWER_MODE_AGGRESSIVE;\n\t\tbreak;\n\tcase EEE_MODE_NVRAM_LATENCY_TIME:\n\t\t*nvram_mode = PORT_FEAT_CFG_EEE_POWER_MODE_LOW_LATENCY;\n\t\tbreak;\n\tdefault:\n\t\t*nvram_mode = PORT_FEAT_CFG_EEE_POWER_MODE_DISABLED;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic u32 bnx2x_eee_calc_timer(struct link_params *params)\n{\n\tu32 eee_mode, eee_idle;\n\tstruct bnx2x *bp = params->bp;\n\n\tif (params->eee_mode & EEE_MODE_OVERRIDE_NVRAM) {\n\t\tif (params->eee_mode & EEE_MODE_OUTPUT_TIME) {\n\t\t\t \n\t\t\teee_idle = params->eee_mode & EEE_MODE_TIMER_MASK;\n\t\t} else {\n\t\t\t \n\t\t\tif (bnx2x_eee_nvram_to_time(params->eee_mode &\n\t\t\t\t\t\t    EEE_MODE_NVRAM_MASK,\n\t\t\t\t\t\t    &eee_idle))\n\t\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\t \n\t\teee_mode = ((REG_RD(bp, params->shmem_base +\n\t\t\t\t    offsetof(struct shmem_region, dev_info.\n\t\t\t\t    port_feature_config[params->port].\n\t\t\t\t    eee_power_mode)) &\n\t\t\t     PORT_FEAT_CFG_EEE_POWER_MODE_MASK) >>\n\t\t\t    PORT_FEAT_CFG_EEE_POWER_MODE_SHIFT);\n\n\t\tif (bnx2x_eee_nvram_to_time(eee_mode, &eee_idle))\n\t\t\treturn 0;\n\t}\n\n\treturn eee_idle;\n}\n\nstatic int bnx2x_eee_set_timers(struct link_params *params,\n\t\t\t\t   struct link_vars *vars)\n{\n\tu32 eee_idle = 0, eee_mode;\n\tstruct bnx2x *bp = params->bp;\n\n\teee_idle = bnx2x_eee_calc_timer(params);\n\n\tif (eee_idle) {\n\t\tREG_WR(bp, MISC_REG_CPMU_LP_IDLE_THR_P0 + (params->port << 2),\n\t\t       eee_idle);\n\t} else if ((params->eee_mode & EEE_MODE_ENABLE_LPI) &&\n\t\t   (params->eee_mode & EEE_MODE_OVERRIDE_NVRAM) &&\n\t\t   (params->eee_mode & EEE_MODE_OUTPUT_TIME)) {\n\t\tDP(NETIF_MSG_LINK, \"Error: Tx LPI is enabled with timer 0\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tvars->eee_status &= ~(SHMEM_EEE_TIMER_MASK | SHMEM_EEE_TIME_OUTPUT_BIT);\n\tif (params->eee_mode & EEE_MODE_OUTPUT_TIME) {\n\t\t \n\t\teee_idle >>= 4;\n\t\tvars->eee_status |= (eee_idle & SHMEM_EEE_TIMER_MASK) |\n\t\t\t\t    SHMEM_EEE_TIME_OUTPUT_BIT;\n\t} else {\n\t\tif (bnx2x_eee_time_to_nvram(eee_idle, &eee_mode))\n\t\t\treturn -EINVAL;\n\t\tvars->eee_status |= eee_mode;\n\t}\n\n\treturn 0;\n}\n\nstatic int bnx2x_eee_initial_config(struct link_params *params,\n\t\t\t\t     struct link_vars *vars, u8 mode)\n{\n\tvars->eee_status |= ((u32) mode) << SHMEM_EEE_SUPPORTED_SHIFT;\n\n\t \n\tif (params->eee_mode & EEE_MODE_ENABLE_LPI)\n\t\tvars->eee_status |= SHMEM_EEE_LPI_REQUESTED_BIT;\n\telse\n\t\tvars->eee_status &= ~SHMEM_EEE_LPI_REQUESTED_BIT;\n\n\tif (params->eee_mode & EEE_MODE_ADV_LPI)\n\t\tvars->eee_status |= SHMEM_EEE_REQUESTED_BIT;\n\telse\n\t\tvars->eee_status &= ~SHMEM_EEE_REQUESTED_BIT;\n\n\treturn bnx2x_eee_set_timers(params, vars);\n}\n\nstatic int bnx2x_eee_disable(struct bnx2x_phy *phy,\n\t\t\t\tstruct link_params *params,\n\t\t\t\tstruct link_vars *vars)\n{\n\tstruct bnx2x *bp = params->bp;\n\n\t \n\tREG_WR(bp, MISC_REG_CPMU_LP_FW_ENABLE_P0 + (params->port << 2), 0);\n\n\tbnx2x_cl45_write(bp, phy, MDIO_AN_DEVAD, MDIO_AN_REG_EEE_ADV, 0x0);\n\n\tvars->eee_status &= ~SHMEM_EEE_ADV_STATUS_MASK;\n\n\treturn 0;\n}\n\nstatic int bnx2x_eee_advertise(struct bnx2x_phy *phy,\n\t\t\t\t  struct link_params *params,\n\t\t\t\t  struct link_vars *vars, u8 modes)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu16 val = 0;\n\n\t \n\tREG_WR(bp, MISC_REG_CPMU_LP_MASK_EXT_P0 + (params->port << 2), 0xfc20);\n\n\tif (modes & SHMEM_EEE_10G_ADV) {\n\t\tDP(NETIF_MSG_LINK, \"Advertise 10GBase-T EEE\\n\");\n\t\tval |= 0x8;\n\t}\n\tif (modes & SHMEM_EEE_1G_ADV) {\n\t\tDP(NETIF_MSG_LINK, \"Advertise 1GBase-T EEE\\n\");\n\t\tval |= 0x4;\n\t}\n\n\tbnx2x_cl45_write(bp, phy, MDIO_AN_DEVAD, MDIO_AN_REG_EEE_ADV, val);\n\n\tvars->eee_status &= ~SHMEM_EEE_ADV_STATUS_MASK;\n\tvars->eee_status |= (modes << SHMEM_EEE_ADV_STATUS_SHIFT);\n\n\treturn 0;\n}\n\nstatic void bnx2x_update_mng_eee(struct link_params *params, u32 eee_status)\n{\n\tstruct bnx2x *bp = params->bp;\n\n\tif (bnx2x_eee_has_cap(params))\n\t\tREG_WR(bp, params->shmem2_base +\n\t\t       offsetof(struct shmem2_region,\n\t\t\t\teee_status[params->port]), eee_status);\n}\n\nstatic void bnx2x_eee_an_resolve(struct bnx2x_phy *phy,\n\t\t\t\t  struct link_params *params,\n\t\t\t\t  struct link_vars *vars)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu16 adv = 0, lp = 0;\n\tu32 lp_adv = 0;\n\tu8 neg = 0;\n\n\tbnx2x_cl45_read(bp, phy, MDIO_AN_DEVAD, MDIO_AN_REG_EEE_ADV, &adv);\n\tbnx2x_cl45_read(bp, phy, MDIO_AN_DEVAD, MDIO_AN_REG_LP_EEE_ADV, &lp);\n\n\tif (lp & 0x2) {\n\t\tlp_adv |= SHMEM_EEE_100M_ADV;\n\t\tif (adv & 0x2) {\n\t\t\tif (vars->line_speed == SPEED_100)\n\t\t\t\tneg = 1;\n\t\t\tDP(NETIF_MSG_LINK, \"EEE negotiated - 100M\\n\");\n\t\t}\n\t}\n\tif (lp & 0x14) {\n\t\tlp_adv |= SHMEM_EEE_1G_ADV;\n\t\tif (adv & 0x14) {\n\t\t\tif (vars->line_speed == SPEED_1000)\n\t\t\t\tneg = 1;\n\t\t\tDP(NETIF_MSG_LINK, \"EEE negotiated - 1G\\n\");\n\t\t}\n\t}\n\tif (lp & 0x68) {\n\t\tlp_adv |= SHMEM_EEE_10G_ADV;\n\t\tif (adv & 0x68) {\n\t\t\tif (vars->line_speed == SPEED_10000)\n\t\t\t\tneg = 1;\n\t\t\tDP(NETIF_MSG_LINK, \"EEE negotiated - 10G\\n\");\n\t\t}\n\t}\n\n\tvars->eee_status &= ~SHMEM_EEE_LP_ADV_STATUS_MASK;\n\tvars->eee_status |= (lp_adv << SHMEM_EEE_LP_ADV_STATUS_SHIFT);\n\n\tif (neg) {\n\t\tDP(NETIF_MSG_LINK, \"EEE is active\\n\");\n\t\tvars->eee_status |= SHMEM_EEE_ACTIVE_BIT;\n\t}\n\n}\n\n \n \n \nstatic void bnx2x_bsc_module_sel(struct link_params *params)\n{\n\tint idx;\n\tu32 board_cfg, sfp_ctrl;\n\tu32 i2c_pins[I2C_SWITCH_WIDTH], i2c_val[I2C_SWITCH_WIDTH];\n\tstruct bnx2x *bp = params->bp;\n\tu8 port = params->port;\n\t \n\tboard_cfg = REG_RD(bp, params->shmem_base +\n\t\t\t   offsetof(struct shmem_region,\n\t\t\t\t    dev_info.shared_hw_config.board));\n\ti2c_pins[I2C_BSC0] = board_cfg & SHARED_HW_CFG_E3_I2C_MUX0_MASK;\n\ti2c_pins[I2C_BSC1] = (board_cfg & SHARED_HW_CFG_E3_I2C_MUX1_MASK) >>\n\t\t\tSHARED_HW_CFG_E3_I2C_MUX1_SHIFT;\n\n\t \n\tsfp_ctrl = REG_RD(bp, params->shmem_base +\n\t\t\t  offsetof(struct shmem_region,\n\t\t\t\t dev_info.port_hw_config[port].e3_cmn_pin_cfg));\n\ti2c_val[I2C_BSC0] = (sfp_ctrl & PORT_HW_CFG_E3_I2C_MUX0_MASK) > 0;\n\ti2c_val[I2C_BSC1] = (sfp_ctrl & PORT_HW_CFG_E3_I2C_MUX1_MASK) > 0;\n\tDP(NETIF_MSG_LINK, \"Setting BSC switch\\n\");\n\tfor (idx = 0; idx < I2C_SWITCH_WIDTH; idx++)\n\t\tbnx2x_set_cfg_pin(bp, i2c_pins[idx], i2c_val[idx]);\n}\n\nstatic int bnx2x_bsc_read(struct link_params *params,\n\t\t\t  struct bnx2x *bp,\n\t\t\t  u8 sl_devid,\n\t\t\t  u16 sl_addr,\n\t\t\t  u8 lc_addr,\n\t\t\t  u8 xfer_cnt,\n\t\t\t  u32 *data_array)\n{\n\tu64 t0, delta;\n\tu32 val, i;\n\tint rc = 0;\n\n\tif (xfer_cnt > 16) {\n\t\tDP(NETIF_MSG_LINK, \"invalid xfer_cnt %d. Max is 16 bytes\\n\",\n\t\t\t\t\txfer_cnt);\n\t\treturn -EINVAL;\n\t}\n\tbnx2x_bsc_module_sel(params);\n\n\txfer_cnt = 16 - lc_addr;\n\n\t \n\tval = REG_RD(bp, MCP_REG_MCPR_IMC_COMMAND);\n\tval |= MCPR_IMC_COMMAND_ENABLE;\n\tREG_WR(bp, MCP_REG_MCPR_IMC_COMMAND, val);\n\n\t \n\tval = (sl_devid << 16) | sl_addr;\n\tREG_WR(bp, MCP_REG_MCPR_IMC_SLAVE_CONTROL, val);\n\n\t \n\tval = (MCPR_IMC_COMMAND_ENABLE) |\n\t      (MCPR_IMC_COMMAND_WRITE_OP <<\n\t\tMCPR_IMC_COMMAND_OPERATION_BITSHIFT) |\n\t\t(lc_addr << MCPR_IMC_COMMAND_TRANSFER_ADDRESS_BITSHIFT) | (0);\n\tREG_WR(bp, MCP_REG_MCPR_IMC_COMMAND, val);\n\n\t \n\tt0 = ktime_get_ns();\n\tval = REG_RD(bp, MCP_REG_MCPR_IMC_COMMAND);\n\twhile (((val >> MCPR_IMC_COMMAND_IMC_STATUS_BITSHIFT) & 0x3) != 1) {\n\t\tdelta = ktime_get_ns() - t0;\n\t\tif (delta > 10 * NSEC_PER_MSEC) {\n\t\t\tDP(NETIF_MSG_LINK, \"wr 0 byte timed out after %Lu ns\\n\",\n\t\t\t\t\t   delta);\n\t\t\trc = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tusleep_range(10, 20);\n\t\tval = REG_RD(bp, MCP_REG_MCPR_IMC_COMMAND);\n\t}\n\tif (rc == -EFAULT)\n\t\treturn rc;\n\n\t \n\tval = (MCPR_IMC_COMMAND_ENABLE) |\n\t\t(MCPR_IMC_COMMAND_READ_OP <<\n\t\tMCPR_IMC_COMMAND_OPERATION_BITSHIFT) |\n\t\t(lc_addr << MCPR_IMC_COMMAND_TRANSFER_ADDRESS_BITSHIFT) |\n\t\t  (xfer_cnt);\n\tREG_WR(bp, MCP_REG_MCPR_IMC_COMMAND, val);\n\n\t \n\tt0 = ktime_get_ns();\n\tval = REG_RD(bp, MCP_REG_MCPR_IMC_COMMAND);\n\twhile (((val >> MCPR_IMC_COMMAND_IMC_STATUS_BITSHIFT) & 0x3) != 1) {\n\t\tdelta = ktime_get_ns() - t0;\n\t\tif (delta > 10 * NSEC_PER_MSEC) {\n\t\t\tDP(NETIF_MSG_LINK, \"rd op timed out after %Lu ns\\n\",\n\t\t\t\t\t   delta);\n\t\t\trc = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tusleep_range(10, 20);\n\t\tval = REG_RD(bp, MCP_REG_MCPR_IMC_COMMAND);\n\t}\n\tif (rc == -EFAULT)\n\t\treturn rc;\n\n\tfor (i = (lc_addr >> 2); i < 4; i++) {\n\t\tdata_array[i] = REG_RD(bp, (MCP_REG_MCPR_IMC_DATAREG0 + i*4));\n#ifdef __BIG_ENDIAN\n\t\tdata_array[i] = ((data_array[i] & 0x000000ff) << 24) |\n\t\t\t\t((data_array[i] & 0x0000ff00) << 8) |\n\t\t\t\t((data_array[i] & 0x00ff0000) >> 8) |\n\t\t\t\t((data_array[i] & 0xff000000) >> 24);\n#endif\n\t}\n\treturn rc;\n}\n\nstatic void bnx2x_cl45_read_or_write(struct bnx2x *bp, struct bnx2x_phy *phy,\n\t\t\t\t     u8 devad, u16 reg, u16 or_val)\n{\n\tu16 val;\n\tbnx2x_cl45_read(bp, phy, devad, reg, &val);\n\tbnx2x_cl45_write(bp, phy, devad, reg, val | or_val);\n}\n\nstatic void bnx2x_cl45_read_and_write(struct bnx2x *bp,\n\t\t\t\t      struct bnx2x_phy *phy,\n\t\t\t\t      u8 devad, u16 reg, u16 and_val)\n{\n\tu16 val;\n\tbnx2x_cl45_read(bp, phy, devad, reg, &val);\n\tbnx2x_cl45_write(bp, phy, devad, reg, val & and_val);\n}\n\nint bnx2x_phy_read(struct link_params *params, u8 phy_addr,\n\t\t   u8 devad, u16 reg, u16 *ret_val)\n{\n\tu8 phy_index;\n\t \n\tfor (phy_index = 0; phy_index < params->num_phys; phy_index++) {\n\t\tif (params->phy[phy_index].addr == phy_addr) {\n\t\t\treturn bnx2x_cl45_read(params->bp,\n\t\t\t\t\t       &params->phy[phy_index], devad,\n\t\t\t\t\t       reg, ret_val);\n\t\t}\n\t}\n\treturn -EINVAL;\n}\n\nint bnx2x_phy_write(struct link_params *params, u8 phy_addr,\n\t\t    u8 devad, u16 reg, u16 val)\n{\n\tu8 phy_index;\n\t \n\tfor (phy_index = 0; phy_index < params->num_phys; phy_index++) {\n\t\tif (params->phy[phy_index].addr == phy_addr) {\n\t\t\treturn bnx2x_cl45_write(params->bp,\n\t\t\t\t\t\t&params->phy[phy_index], devad,\n\t\t\t\t\t\treg, val);\n\t\t}\n\t}\n\treturn -EINVAL;\n}\nstatic u8 bnx2x_get_warpcore_lane(struct bnx2x_phy *phy,\n\t\t\t\t  struct link_params *params)\n{\n\tu8 lane = 0;\n\tstruct bnx2x *bp = params->bp;\n\tu32 path_swap, path_swap_ovr;\n\tu8 path, port;\n\n\tpath = BP_PATH(bp);\n\tport = params->port;\n\n\tif (bnx2x_is_4_port_mode(bp)) {\n\t\tu32 port_swap, port_swap_ovr;\n\n\t\t \n\t\tpath_swap_ovr = REG_RD(bp, MISC_REG_FOUR_PORT_PATH_SWAP_OVWR);\n\t\tif (path_swap_ovr & 0x1)\n\t\t\tpath_swap = (path_swap_ovr & 0x2);\n\t\telse\n\t\t\tpath_swap = REG_RD(bp, MISC_REG_FOUR_PORT_PATH_SWAP);\n\n\t\tif (path_swap)\n\t\t\tpath = path ^ 1;\n\n\t\t \n\t\tport_swap_ovr = REG_RD(bp, MISC_REG_FOUR_PORT_PORT_SWAP_OVWR);\n\t\tif (port_swap_ovr & 0x1)\n\t\t\tport_swap = (port_swap_ovr & 0x2);\n\t\telse\n\t\t\tport_swap = REG_RD(bp, MISC_REG_FOUR_PORT_PORT_SWAP);\n\n\t\tif (port_swap)\n\t\t\tport = port ^ 1;\n\n\t\tlane = (port<<1) + path;\n\t} else {  \n\n\t\t \n\t\tpath_swap_ovr =\n\t\t\tREG_RD(bp, MISC_REG_TWO_PORT_PATH_SWAP_OVWR);\n\t\tif (path_swap_ovr & 0x1) {\n\t\t\tpath_swap = (path_swap_ovr & 0x2);\n\t\t} else {\n\t\t\tpath_swap =\n\t\t\t\tREG_RD(bp, MISC_REG_TWO_PORT_PATH_SWAP);\n\t\t}\n\t\tif (path_swap)\n\t\t\tpath = path ^ 1;\n\n\t\tlane = path << 1 ;\n\t}\n\treturn lane;\n}\n\nstatic void bnx2x_set_aer_mmd(struct link_params *params,\n\t\t\t      struct bnx2x_phy *phy)\n{\n\tu32 ser_lane;\n\tu16 offset, aer_val;\n\tstruct bnx2x *bp = params->bp;\n\tser_lane = ((params->lane_config &\n\t\t     PORT_HW_CFG_LANE_SWAP_CFG_MASTER_MASK) >>\n\t\t     PORT_HW_CFG_LANE_SWAP_CFG_MASTER_SHIFT);\n\n\toffset = (phy->type == PORT_HW_CFG_XGXS_EXT_PHY_TYPE_DIRECT) ?\n\t\t(phy->addr + ser_lane) : 0;\n\n\tif (USES_WARPCORE(bp)) {\n\t\taer_val = bnx2x_get_warpcore_lane(phy, params);\n\t\t \n\t\tif (phy->flags & FLAGS_WC_DUAL_MODE)\n\t\t\taer_val = (aer_val >> 1) | 0x200;\n\t} else if (CHIP_IS_E2(bp))\n\t\taer_val = 0x3800 + offset - 1;\n\telse\n\t\taer_val = 0x3800 + offset;\n\n\tCL22_WR_OVER_CL45(bp, phy, MDIO_REG_BANK_AER_BLOCK,\n\t\t\t  MDIO_AER_BLOCK_AER_REG, aer_val);\n\n}\n\n \n \n \n\nstatic void bnx2x_set_serdes_access(struct bnx2x *bp, u8 port)\n{\n\tu32 emac_base = (port) ? GRCBASE_EMAC1 : GRCBASE_EMAC0;\n\n\t \n\tREG_WR(bp, NIG_REG_SERDES0_CTRL_MD_ST + port*0x10, 1);\n\tREG_WR(bp, emac_base + EMAC_REG_EMAC_MDIO_COMM, 0x245f8000);\n\tudelay(500);\n\tREG_WR(bp, emac_base + EMAC_REG_EMAC_MDIO_COMM, 0x245d000f);\n\tudelay(500);\n\t  \n\tREG_WR(bp, NIG_REG_SERDES0_CTRL_MD_ST + port*0x10, 0);\n}\n\nstatic void bnx2x_serdes_deassert(struct bnx2x *bp, u8 port)\n{\n\tu32 val;\n\n\tDP(NETIF_MSG_LINK, \"bnx2x_serdes_deassert\\n\");\n\n\tval = SERDES_RESET_BITS << (port*16);\n\n\t \n\tREG_WR(bp, GRCBASE_MISC + MISC_REGISTERS_RESET_REG_3_CLEAR, val);\n\tudelay(500);\n\tREG_WR(bp, GRCBASE_MISC + MISC_REGISTERS_RESET_REG_3_SET, val);\n\n\tbnx2x_set_serdes_access(bp, port);\n\n\tREG_WR(bp, NIG_REG_SERDES0_CTRL_MD_DEVAD + port*0x10,\n\t       DEFAULT_PHY_DEV_ADDR);\n}\n\nstatic void bnx2x_xgxs_specific_func(struct bnx2x_phy *phy,\n\t\t\t\t     struct link_params *params,\n\t\t\t\t     u32 action)\n{\n\tstruct bnx2x *bp = params->bp;\n\tswitch (action) {\n\tcase PHY_INIT:\n\t\t \n\t\tREG_WR(bp, NIG_REG_XGXS0_CTRL_MD_ST + params->port*0x18, 0);\n\t\tREG_WR(bp, NIG_REG_XGXS0_CTRL_MD_DEVAD + params->port*0x18,\n\t\t       phy->def_md_devad);\n\t\tbreak;\n\t}\n}\n\nstatic void bnx2x_xgxs_deassert(struct link_params *params)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu8 port;\n\tu32 val;\n\tDP(NETIF_MSG_LINK, \"bnx2x_xgxs_deassert\\n\");\n\tport = params->port;\n\n\tval = XGXS_RESET_BITS << (port*16);\n\n\t \n\tREG_WR(bp, GRCBASE_MISC + MISC_REGISTERS_RESET_REG_3_CLEAR, val);\n\tudelay(500);\n\tREG_WR(bp, GRCBASE_MISC + MISC_REGISTERS_RESET_REG_3_SET, val);\n\tbnx2x_xgxs_specific_func(&params->phy[INT_PHY], params,\n\t\t\t\t PHY_INIT);\n}\n\nstatic void bnx2x_calc_ieee_aneg_adv(struct bnx2x_phy *phy,\n\t\t\t\t     struct link_params *params, u16 *ieee_fc)\n{\n\tstruct bnx2x *bp = params->bp;\n\t*ieee_fc = MDIO_COMBO_IEEE0_AUTO_NEG_ADV_FULL_DUPLEX;\n\t \n\n\tswitch (phy->req_flow_ctrl) {\n\tcase BNX2X_FLOW_CTRL_AUTO:\n\t\tswitch (params->req_fc_auto_adv) {\n\t\tcase BNX2X_FLOW_CTRL_BOTH:\n\t\tcase BNX2X_FLOW_CTRL_RX:\n\t\t\t*ieee_fc |= MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_BOTH;\n\t\t\tbreak;\n\t\tcase BNX2X_FLOW_CTRL_TX:\n\t\t\t*ieee_fc |=\n\t\t\t\tMDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_ASYMMETRIC;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase BNX2X_FLOW_CTRL_TX:\n\t\t*ieee_fc |= MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_ASYMMETRIC;\n\t\tbreak;\n\n\tcase BNX2X_FLOW_CTRL_RX:\n\tcase BNX2X_FLOW_CTRL_BOTH:\n\t\t*ieee_fc |= MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_BOTH;\n\t\tbreak;\n\n\tcase BNX2X_FLOW_CTRL_NONE:\n\tdefault:\n\t\t*ieee_fc |= MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_NONE;\n\t\tbreak;\n\t}\n\tDP(NETIF_MSG_LINK, \"ieee_fc = 0x%x\\n\", *ieee_fc);\n}\n\nstatic void set_phy_vars(struct link_params *params,\n\t\t\t struct link_vars *vars)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu8 actual_phy_idx, phy_index, link_cfg_idx;\n\tu8 phy_config_swapped = params->multi_phy_config &\n\t\t\tPORT_HW_CFG_PHY_SWAPPED_ENABLED;\n\tfor (phy_index = INT_PHY; phy_index < params->num_phys;\n\t      phy_index++) {\n\t\tlink_cfg_idx = LINK_CONFIG_IDX(phy_index);\n\t\tactual_phy_idx = phy_index;\n\t\tif (phy_config_swapped) {\n\t\t\tif (phy_index == EXT_PHY1)\n\t\t\t\tactual_phy_idx = EXT_PHY2;\n\t\t\telse if (phy_index == EXT_PHY2)\n\t\t\t\tactual_phy_idx = EXT_PHY1;\n\t\t}\n\t\tparams->phy[actual_phy_idx].req_flow_ctrl =\n\t\t\tparams->req_flow_ctrl[link_cfg_idx];\n\n\t\tparams->phy[actual_phy_idx].req_line_speed =\n\t\t\tparams->req_line_speed[link_cfg_idx];\n\n\t\tparams->phy[actual_phy_idx].speed_cap_mask =\n\t\t\tparams->speed_cap_mask[link_cfg_idx];\n\n\t\tparams->phy[actual_phy_idx].req_duplex =\n\t\t\tparams->req_duplex[link_cfg_idx];\n\n\t\tif (params->req_line_speed[link_cfg_idx] ==\n\t\t    SPEED_AUTO_NEG)\n\t\t\tvars->link_status |= LINK_STATUS_AUTO_NEGOTIATE_ENABLED;\n\n\t\tDP(NETIF_MSG_LINK, \"req_flow_ctrl %x, req_line_speed %x,\"\n\t\t\t   \" speed_cap_mask %x\\n\",\n\t\t\t   params->phy[actual_phy_idx].req_flow_ctrl,\n\t\t\t   params->phy[actual_phy_idx].req_line_speed,\n\t\t\t   params->phy[actual_phy_idx].speed_cap_mask);\n\t}\n}\n\nstatic void bnx2x_ext_phy_set_pause(struct link_params *params,\n\t\t\t\t    struct bnx2x_phy *phy,\n\t\t\t\t    struct link_vars *vars)\n{\n\tu16 val;\n\tstruct bnx2x *bp = params->bp;\n\t \n\tbnx2x_cl45_read(bp, phy, MDIO_AN_DEVAD, MDIO_AN_REG_ADV_PAUSE, &val);\n\n\tval &= ~MDIO_AN_REG_ADV_PAUSE_BOTH;\n\n\t \n\tbnx2x_calc_ieee_aneg_adv(phy, params, &vars->ieee_fc);\n\tif ((vars->ieee_fc &\n\t    MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_ASYMMETRIC) ==\n\t    MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_ASYMMETRIC) {\n\t\tval |= MDIO_AN_REG_ADV_PAUSE_ASYMMETRIC;\n\t}\n\tif ((vars->ieee_fc &\n\t    MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_BOTH) ==\n\t    MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_BOTH) {\n\t\tval |= MDIO_AN_REG_ADV_PAUSE_PAUSE;\n\t}\n\tDP(NETIF_MSG_LINK, \"Ext phy AN advertize 0x%x\\n\", val);\n\tbnx2x_cl45_write(bp, phy, MDIO_AN_DEVAD, MDIO_AN_REG_ADV_PAUSE, val);\n}\n\nstatic void bnx2x_pause_resolve(struct bnx2x_phy *phy,\n\t\t\t\tstruct link_params *params,\n\t\t\t\tstruct link_vars *vars,\n\t\t\t\tu32 pause_result)\n{\n\tstruct bnx2x *bp = params->bp;\n\t\t\t\t\t\t \n\tswitch (pause_result) {\t\t\t \n\tcase 0xb:\t\t\t\t \n\t\tDP(NETIF_MSG_LINK, \"Flow Control: TX only\\n\");\n\t\tvars->flow_ctrl = BNX2X_FLOW_CTRL_TX;\n\t\tbreak;\n\n\tcase 0xe:\t\t\t\t \n\t\tDP(NETIF_MSG_LINK, \"Flow Control: RX only\\n\");\n\t\tvars->flow_ctrl = BNX2X_FLOW_CTRL_RX;\n\t\tbreak;\n\n\tcase 0x5:\t\t\t\t \n\tcase 0x7:\t\t\t\t \n\tcase 0xd:\t\t\t\t \n\tcase 0xf:\t\t\t\t \n\t\t \n\t\tif (params->req_fc_auto_adv == BNX2X_FLOW_CTRL_BOTH) {\n\t\t\tDP(NETIF_MSG_LINK, \"Flow Control: RX & TX\\n\");\n\t\t\tvars->flow_ctrl = BNX2X_FLOW_CTRL_BOTH;\n\t\t} else {\n\t\t\tDP(NETIF_MSG_LINK, \"Flow Control: RX only\\n\");\n\t\t\tvars->flow_ctrl = BNX2X_FLOW_CTRL_RX;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tDP(NETIF_MSG_LINK, \"Flow Control: None\\n\");\n\t\tvars->flow_ctrl = BNX2X_FLOW_CTRL_NONE;\n\t\tbreak;\n\t}\n\tif (pause_result & (1<<0))\n\t\tvars->link_status |= LINK_STATUS_LINK_PARTNER_SYMMETRIC_PAUSE;\n\tif (pause_result & (1<<1))\n\t\tvars->link_status |= LINK_STATUS_LINK_PARTNER_ASYMMETRIC_PAUSE;\n\n}\n\nstatic void bnx2x_ext_phy_update_adv_fc(struct bnx2x_phy *phy,\n\t\t\t\t\tstruct link_params *params,\n\t\t\t\t\tstruct link_vars *vars)\n{\n\tu16 ld_pause;\t\t \n\tu16 lp_pause;\t\t \n\tu16 pause_result;\n\tstruct bnx2x *bp = params->bp;\n\tif (phy->type == PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM54618SE) {\n\t\tbnx2x_cl22_read(bp, phy, 0x4, &ld_pause);\n\t\tbnx2x_cl22_read(bp, phy, 0x5, &lp_pause);\n\t} else if (CHIP_IS_E3(bp) &&\n\t\tSINGLE_MEDIA_DIRECT(params)) {\n\t\tu8 lane = bnx2x_get_warpcore_lane(phy, params);\n\t\tu16 gp_status, gp_mask;\n\t\tbnx2x_cl45_read(bp, phy,\n\t\t\t\tMDIO_AN_DEVAD, MDIO_WC_REG_GP2_STATUS_GP_2_4,\n\t\t\t\t&gp_status);\n\t\tgp_mask = (MDIO_WC_REG_GP2_STATUS_GP_2_4_CL73_AN_CMPL |\n\t\t\t   MDIO_WC_REG_GP2_STATUS_GP_2_4_CL37_LP_AN_CAP) <<\n\t\t\tlane;\n\t\tif ((gp_status & gp_mask) == gp_mask) {\n\t\t\tbnx2x_cl45_read(bp, phy, MDIO_AN_DEVAD,\n\t\t\t\t\tMDIO_AN_REG_ADV_PAUSE, &ld_pause);\n\t\t\tbnx2x_cl45_read(bp, phy, MDIO_AN_DEVAD,\n\t\t\t\t\tMDIO_AN_REG_LP_AUTO_NEG, &lp_pause);\n\t\t} else {\n\t\t\tbnx2x_cl45_read(bp, phy, MDIO_AN_DEVAD,\n\t\t\t\t\tMDIO_AN_REG_CL37_FC_LD, &ld_pause);\n\t\t\tbnx2x_cl45_read(bp, phy, MDIO_AN_DEVAD,\n\t\t\t\t\tMDIO_AN_REG_CL37_FC_LP, &lp_pause);\n\t\t\tld_pause = ((ld_pause &\n\t\t\t\t     MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_BOTH)\n\t\t\t\t    << 3);\n\t\t\tlp_pause = ((lp_pause &\n\t\t\t\t     MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_BOTH)\n\t\t\t\t    << 3);\n\t\t}\n\t} else {\n\t\tbnx2x_cl45_read(bp, phy,\n\t\t\t\tMDIO_AN_DEVAD,\n\t\t\t\tMDIO_AN_REG_ADV_PAUSE, &ld_pause);\n\t\tbnx2x_cl45_read(bp, phy,\n\t\t\t\tMDIO_AN_DEVAD,\n\t\t\t\tMDIO_AN_REG_LP_AUTO_NEG, &lp_pause);\n\t}\n\tpause_result = (ld_pause &\n\t\t\tMDIO_AN_REG_ADV_PAUSE_MASK) >> 8;\n\tpause_result |= (lp_pause &\n\t\t\t MDIO_AN_REG_ADV_PAUSE_MASK) >> 10;\n\tDP(NETIF_MSG_LINK, \"Ext PHY pause result 0x%x\\n\", pause_result);\n\tbnx2x_pause_resolve(phy, params, vars, pause_result);\n\n}\n\nstatic u8 bnx2x_ext_phy_resolve_fc(struct bnx2x_phy *phy,\n\t\t\t\t   struct link_params *params,\n\t\t\t\t   struct link_vars *vars)\n{\n\tu8 ret = 0;\n\tvars->flow_ctrl = BNX2X_FLOW_CTRL_NONE;\n\tif (phy->req_flow_ctrl != BNX2X_FLOW_CTRL_AUTO) {\n\t\t \n\t\tif (phy->req_line_speed == SPEED_AUTO_NEG)\n\t\t\tbnx2x_ext_phy_update_adv_fc(phy, params, vars);\n\t\t \n\t\tvars->flow_ctrl = phy->req_flow_ctrl;\n\t} else if (phy->req_line_speed != SPEED_AUTO_NEG)\n\t\tvars->flow_ctrl = params->req_fc_auto_adv;\n\telse if (vars->link_status & LINK_STATUS_AUTO_NEGOTIATE_COMPLETE) {\n\t\tret = 1;\n\t\tbnx2x_ext_phy_update_adv_fc(phy, params, vars);\n\t}\n\treturn ret;\n}\n \n \n \n \n#define WC_TX_DRIVER(post2, idriver, ipre, ifir) \\\n\t((post2 << MDIO_WC_REG_TX0_TX_DRIVER_POST2_COEFF_OFFSET) | \\\n\t (idriver << MDIO_WC_REG_TX0_TX_DRIVER_IDRIVER_OFFSET) | \\\n\t (ipre << MDIO_WC_REG_TX0_TX_DRIVER_IPRE_DRIVER_OFFSET) | \\\n\t (ifir << MDIO_WC_REG_TX0_TX_DRIVER_IFIR_OFFSET))\n\n#define WC_TX_FIR(post, main, pre) \\\n\t((post << MDIO_WC_REG_TX_FIR_TAP_POST_TAP_OFFSET) | \\\n\t (main << MDIO_WC_REG_TX_FIR_TAP_MAIN_TAP_OFFSET) | \\\n\t (pre << MDIO_WC_REG_TX_FIR_TAP_PRE_TAP_OFFSET))\n\nstatic void bnx2x_warpcore_enable_AN_KR2(struct bnx2x_phy *phy,\n\t\t\t\t\t struct link_params *params,\n\t\t\t\t\t struct link_vars *vars)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu16 i;\n\tstatic struct bnx2x_reg_set reg_set[] = {\n\t\t \n\t\t{MDIO_WC_DEVAD, MDIO_WC_REG_CL82_USERB1_TX_CTRL5, 0xa157},\n\t\t{MDIO_WC_DEVAD, MDIO_WC_REG_CL82_USERB1_TX_CTRL7, 0xcbe2},\n\t\t{MDIO_WC_DEVAD, MDIO_WC_REG_CL82_USERB1_TX_CTRL6, 0x7537},\n\t\t{MDIO_WC_DEVAD, MDIO_WC_REG_CL82_USERB1_TX_CTRL9, 0xa157},\n\t\t{MDIO_WC_DEVAD, MDIO_WC_REG_CL82_USERB1_RX_CTRL11, 0xcbe2},\n\t\t{MDIO_WC_DEVAD, MDIO_WC_REG_CL82_USERB1_RX_CTRL10, 0x7537},\n\t\t \n\t\t{MDIO_WC_DEVAD, MDIO_WC_REG_CL73_USERB0_CTRL, 0x000a},\n\t\t{MDIO_WC_DEVAD, MDIO_WC_REG_CL73_BAM_CTRL1, 0x6400},\n\t\t{MDIO_WC_DEVAD, MDIO_WC_REG_CL73_BAM_CTRL3, 0x0620},\n\t\t{MDIO_WC_DEVAD, MDIO_WC_REG_CL73_BAM_CODE_FIELD, 0x0157},\n\t\t{MDIO_WC_DEVAD, MDIO_WC_REG_ETA_CL73_OUI1, 0x6464},\n\t\t{MDIO_WC_DEVAD, MDIO_WC_REG_ETA_CL73_OUI2, 0x3150},\n\t\t{MDIO_WC_DEVAD, MDIO_WC_REG_ETA_CL73_OUI3, 0x3150},\n\t\t{MDIO_WC_DEVAD, MDIO_WC_REG_ETA_CL73_LD_BAM_CODE, 0x0157},\n\t\t{MDIO_WC_DEVAD, MDIO_WC_REG_ETA_CL73_LD_UD_CODE, 0x0620}\n\t};\n\tDP(NETIF_MSG_LINK, \"Enabling 20G-KR2\\n\");\n\n\tbnx2x_cl45_read_or_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t\t MDIO_WC_REG_CL49_USERB0_CTRL, (3<<6));\n\n\tfor (i = 0; i < ARRAY_SIZE(reg_set); i++)\n\t\tbnx2x_cl45_write(bp, phy, reg_set[i].devad, reg_set[i].reg,\n\t\t\t\t reg_set[i].val);\n\n\t \n\tparams->link_attr_sync |= LINK_ATTR_SYNC_KR2_ENABLE;\n\tbnx2x_update_link_attr(params, params->link_attr_sync);\n}\n\nstatic void bnx2x_disable_kr2(struct link_params *params,\n\t\t\t      struct link_vars *vars,\n\t\t\t      struct bnx2x_phy *phy)\n{\n\tstruct bnx2x *bp = params->bp;\n\tint i;\n\tstatic struct bnx2x_reg_set reg_set[] = {\n\t\t \n\t\t{MDIO_WC_DEVAD, MDIO_WC_REG_CL82_USERB1_TX_CTRL5, 0x7690},\n\t\t{MDIO_WC_DEVAD, MDIO_WC_REG_CL82_USERB1_TX_CTRL7, 0xe647},\n\t\t{MDIO_WC_DEVAD, MDIO_WC_REG_CL82_USERB1_TX_CTRL6, 0xc4f0},\n\t\t{MDIO_WC_DEVAD, MDIO_WC_REG_CL82_USERB1_TX_CTRL9, 0x7690},\n\t\t{MDIO_WC_DEVAD, MDIO_WC_REG_CL82_USERB1_RX_CTRL11, 0xe647},\n\t\t{MDIO_WC_DEVAD, MDIO_WC_REG_CL82_USERB1_RX_CTRL10, 0xc4f0},\n\t\t{MDIO_WC_DEVAD, MDIO_WC_REG_CL73_USERB0_CTRL, 0x000c},\n\t\t{MDIO_WC_DEVAD, MDIO_WC_REG_CL73_BAM_CTRL1, 0x6000},\n\t\t{MDIO_WC_DEVAD, MDIO_WC_REG_CL73_BAM_CTRL3, 0x0000},\n\t\t{MDIO_WC_DEVAD, MDIO_WC_REG_CL73_BAM_CODE_FIELD, 0x0002},\n\t\t{MDIO_WC_DEVAD, MDIO_WC_REG_ETA_CL73_OUI1, 0x0000},\n\t\t{MDIO_WC_DEVAD, MDIO_WC_REG_ETA_CL73_OUI2, 0x0af7},\n\t\t{MDIO_WC_DEVAD, MDIO_WC_REG_ETA_CL73_OUI3, 0x0af7},\n\t\t{MDIO_WC_DEVAD, MDIO_WC_REG_ETA_CL73_LD_BAM_CODE, 0x0002},\n\t\t{MDIO_WC_DEVAD, MDIO_WC_REG_ETA_CL73_LD_UD_CODE, 0x0000}\n\t};\n\tDP(NETIF_MSG_LINK, \"Disabling 20G-KR2\\n\");\n\n\tfor (i = 0; i < ARRAY_SIZE(reg_set); i++)\n\t\tbnx2x_cl45_write(bp, phy, reg_set[i].devad, reg_set[i].reg,\n\t\t\t\t reg_set[i].val);\n\tparams->link_attr_sync &= ~LINK_ATTR_SYNC_KR2_ENABLE;\n\tbnx2x_update_link_attr(params, params->link_attr_sync);\n\n\tvars->check_kr2_recovery_cnt = CHECK_KR2_RECOVERY_CNT;\n}\n\nstatic void bnx2x_warpcore_set_lpi_passthrough(struct bnx2x_phy *phy,\n\t\t\t\t\t       struct link_params *params)\n{\n\tstruct bnx2x *bp = params->bp;\n\n\tDP(NETIF_MSG_LINK, \"Configure WC for LPI pass through\\n\");\n\tbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t MDIO_WC_REG_EEE_COMBO_CONTROL0, 0x7c);\n\tbnx2x_cl45_read_or_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t\t MDIO_WC_REG_DIGITAL4_MISC5, 0xc000);\n}\n\nstatic void bnx2x_warpcore_restart_AN_KR(struct bnx2x_phy *phy,\n\t\t\t\t\t struct link_params *params)\n{\n\t \n\tstruct bnx2x *bp = params->bp;\n\tu16 lane = bnx2x_get_warpcore_lane(phy, params);\n\tCL22_WR_OVER_CL45(bp, phy, MDIO_REG_BANK_AER_BLOCK,\n\t\t\t  MDIO_AER_BLOCK_AER_REG, lane);\n\tbnx2x_cl45_write(bp, phy, MDIO_AN_DEVAD,\n\t\t\t MDIO_WC_REG_IEEE0BLK_MIICNTL, 0x1200);\n\n\t \n\tbnx2x_set_aer_mmd(params, phy);\n}\n\nstatic void bnx2x_warpcore_enable_AN_KR(struct bnx2x_phy *phy,\n\t\t\t\t\tstruct link_params *params,\n\t\t\t\t\tstruct link_vars *vars) {\n\tu16 lane, i, cl72_ctrl, an_adv = 0, val;\n\tu32 wc_lane_config;\n\tstruct bnx2x *bp = params->bp;\n\tstatic struct bnx2x_reg_set reg_set[] = {\n\t\t{MDIO_WC_DEVAD, MDIO_WC_REG_SERDESDIGITAL_CONTROL1000X2, 0x7},\n\t\t{MDIO_PMA_DEVAD, MDIO_WC_REG_IEEE0BLK_AUTONEGNP, 0x0},\n\t\t{MDIO_WC_DEVAD, MDIO_WC_REG_RX66_CONTROL, 0x7415},\n\t\t{MDIO_WC_DEVAD, MDIO_WC_REG_SERDESDIGITAL_MISC2, 0x6190},\n\t\t \n\t\t{MDIO_AN_DEVAD, MDIO_WC_REG_IEEE0BLK_MIICNTL, 0},\n\t\t{MDIO_PMA_DEVAD, MDIO_WC_REG_PMD_KR_CONTROL, 0x2},\n\t\t{MDIO_WC_DEVAD, MDIO_WC_REG_CL72_USERB0_CL72_TX_FIR_TAP, 0},\n\t};\n\tDP(NETIF_MSG_LINK, \"Enable Auto Negotiation for KR\\n\");\n\t \n\tfor (i = 0; i < ARRAY_SIZE(reg_set); i++)\n\t\tbnx2x_cl45_write(bp, phy, reg_set[i].devad, reg_set[i].reg,\n\t\t\t\t reg_set[i].val);\n\n\tbnx2x_cl45_read(bp, phy, MDIO_WC_DEVAD,\n\t\t\tMDIO_WC_REG_CL72_USERB0_CL72_MISC1_CONTROL, &cl72_ctrl);\n\tcl72_ctrl &= 0x08ff;\n\tcl72_ctrl |= 0x3800;\n\tbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t MDIO_WC_REG_CL72_USERB0_CL72_MISC1_CONTROL, cl72_ctrl);\n\n\t \n\tif (((vars->line_speed == SPEED_AUTO_NEG) &&\n\t     (phy->speed_cap_mask & PORT_HW_CFG_SPEED_CAPABILITY_D0_1G)) ||\n\t    (vars->line_speed == SPEED_1000)) {\n\t\tu16 addr = MDIO_WC_REG_SERDESDIGITAL_CONTROL1000X2;\n\t\tan_adv |= (1<<5);\n\n\t\t \n\t\tbnx2x_cl45_read_or_write(bp, phy, MDIO_WC_DEVAD, addr, 0x1);\n\t\tDP(NETIF_MSG_LINK, \"Advertize 1G\\n\");\n\t}\n\tif (((vars->line_speed == SPEED_AUTO_NEG) &&\n\t     (phy->speed_cap_mask & PORT_HW_CFG_SPEED_CAPABILITY_D0_10G)) ||\n\t    (vars->line_speed ==  SPEED_10000)) {\n\t\t \n\t\tan_adv |= (1<<7);\n\t\t \n\t\tCL22_WR_OVER_CL45(bp, phy, MDIO_REG_BANK_AER_BLOCK,\n\t\t\t\t  MDIO_AER_BLOCK_AER_REG, 0);\n\n\t\tbnx2x_cl45_write(bp, phy, MDIO_AN_DEVAD,\n\t\t\t\t MDIO_WC_REG_PAR_DET_10G_CTRL, 1);\n\t\tbnx2x_set_aer_mmd(params, phy);\n\t\tDP(NETIF_MSG_LINK, \"Advertize 10G\\n\");\n\t}\n\n\t \n\tlane = bnx2x_get_warpcore_lane(phy, params);\n\tbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t MDIO_WC_REG_TX0_TX_DRIVER + 0x10*lane,\n\t\t\t WC_TX_DRIVER(0x02, 0x06, 0x09, 0));\n\t \n\tif (phy->flags & FLAGS_WC_DUAL_MODE)\n\t\tbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t\t MDIO_WC_REG_TX0_TX_DRIVER + 0x10*(lane+1),\n\t\t\t\t WC_TX_DRIVER(0x02, 0x06, 0x09, 0));\n\tbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t MDIO_WC_REG_CL72_USERB0_CL72_OS_DEF_CTRL,\n\t\t\t 0x03f0);\n\tbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t MDIO_WC_REG_CL72_USERB0_CL72_2P5_DEF_CTRL,\n\t\t\t 0x03f0);\n\n\t \n\tbnx2x_cl45_write(bp, phy, MDIO_AN_DEVAD,\n\t\t\t MDIO_WC_REG_AN_IEEE1BLK_AN_ADVERTISEMENT1, an_adv);\n\n\t \n\tbnx2x_cl45_write(bp, phy, MDIO_AN_DEVAD,\n\t\t\t MDIO_WC_REG_AN_IEEE1BLK_AN_ADVERTISEMENT2,\n\t\t\t (MDIO_WC_REG_AN_IEEE1BLK_AN_ADV2_FEC_ABILITY |\n\t\t\t  MDIO_WC_REG_AN_IEEE1BLK_AN_ADV2_FEC_REQ));\n\n\t \n\tif (REG_RD(bp, params->shmem_base +\n\t\t   offsetof(struct shmem_region, dev_info.\n\t\t\t    port_hw_config[params->port].default_cfg)) &\n\t    PORT_HW_CFG_ENABLE_BAM_ON_KR_ENABLED) {\n\t\tbnx2x_cl45_read_or_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t\t\t MDIO_WC_REG_DIGITAL6_MP5_NEXTPAGECTRL,\n\t\t\t\t\t 1);\n\t\tDP(NETIF_MSG_LINK, \"Enable CL37 BAM on KR\\n\");\n\t}\n\n\t \n\tbnx2x_ext_phy_set_pause(params, phy, vars);\n\tvars->rx_tx_asic_rst = MAX_KR_LINK_RETRY;\n\tbnx2x_cl45_read_or_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t\t MDIO_WC_REG_DIGITAL5_MISC7, 0x100);\n\n\t \n\tbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\tMDIO_WC_REG_DIGITAL3_UP1, 0x1f);\n\n\tif (((phy->req_line_speed == SPEED_AUTO_NEG) &&\n\t     (phy->speed_cap_mask & PORT_HW_CFG_SPEED_CAPABILITY_D0_20G)) ||\n\t    (phy->req_line_speed == SPEED_20000)) {\n\n\t\tCL22_WR_OVER_CL45(bp, phy, MDIO_REG_BANK_AER_BLOCK,\n\t\t\t\t  MDIO_AER_BLOCK_AER_REG, lane);\n\n\t\tbnx2x_cl45_read_or_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t\t\t MDIO_WC_REG_RX1_PCI_CTRL + (0x10*lane),\n\t\t\t\t\t (1<<11));\n\n\t\tbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t\t MDIO_WC_REG_XGXS_X2_CONTROL3, 0x7);\n\t\tbnx2x_set_aer_mmd(params, phy);\n\n\t\tbnx2x_warpcore_enable_AN_KR2(phy, params, vars);\n\t} else {\n\t\t \n\t\tbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t\t MDIO_WC_REG_SERDESDIGITAL_CONTROL1000X1, 0x10);\n\t\twc_lane_config = REG_RD(bp, params->shmem_base +\n\t\t\t\t\toffsetof(struct shmem_region, dev_info.\n\t\t\t\t\tshared_hw_config.wc_lane_config));\n\t\tbnx2x_cl45_read(bp, phy, MDIO_WC_DEVAD,\n\t\t\t\tMDIO_WC_REG_RX0_PCI_CTRL + (lane << 4), &val);\n\t\t \n\t\tval |= 1 << 11;\n\n\t\t \n\t\tif (wc_lane_config &\n\t\t    (SHARED_HW_CFG_RX_LANE0_POL_FLIP_ENABLED << lane))\n\t\t\tval |= 3 << 2;\n\t\telse\n\t\t\tval &= ~(3 << 2);\n\t\tbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t\t MDIO_WC_REG_RX0_PCI_CTRL + (lane << 4),\n\t\t\t\t val);\n\n\t\tbnx2x_disable_kr2(params, vars, phy);\n\t}\n\n\t \n\tbnx2x_warpcore_restart_AN_KR(phy, params);\n}\n\nstatic void bnx2x_warpcore_set_10G_KR(struct bnx2x_phy *phy,\n\t\t\t\t      struct link_params *params,\n\t\t\t\t      struct link_vars *vars)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu16 val16, i, lane;\n\tstatic struct bnx2x_reg_set reg_set[] = {\n\t\t \n\t\t{MDIO_WC_DEVAD, MDIO_WC_REG_SERDESDIGITAL_CONTROL1000X2, 0x7},\n\t\t{MDIO_WC_DEVAD, MDIO_WC_REG_CL72_USERB0_CL72_MISC1_CONTROL,\n\t\t\t0x3f00},\n\t\t{MDIO_AN_DEVAD, MDIO_WC_REG_AN_IEEE1BLK_AN_ADVERTISEMENT1, 0},\n\t\t{MDIO_AN_DEVAD, MDIO_WC_REG_IEEE0BLK_MIICNTL, 0x0},\n\t\t{MDIO_WC_DEVAD, MDIO_WC_REG_DIGITAL3_UP1, 0x1},\n\t\t{MDIO_WC_DEVAD, MDIO_WC_REG_DIGITAL5_MISC7, 0xa},\n\t\t \n\t\t{MDIO_PMA_DEVAD, MDIO_WC_REG_PMD_KR_CONTROL, 0x2}\n\t};\n\n\tfor (i = 0; i < ARRAY_SIZE(reg_set); i++)\n\t\tbnx2x_cl45_write(bp, phy, reg_set[i].devad, reg_set[i].reg,\n\t\t\t\t reg_set[i].val);\n\n\tlane = bnx2x_get_warpcore_lane(phy, params);\n\t \n\tCL22_WR_OVER_CL45(bp, phy, MDIO_REG_BANK_AER_BLOCK,\n\t\t\t  MDIO_AER_BLOCK_AER_REG, 0);\n\t \n\tbnx2x_cl45_read(bp, phy, MDIO_WC_DEVAD,\n\t\t\tMDIO_WC_REG_XGXSBLK1_LANECTRL0, &val16);\n\tval16 &= ~(0x0011 << lane);\n\tbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t MDIO_WC_REG_XGXSBLK1_LANECTRL0, val16);\n\n\tbnx2x_cl45_read(bp, phy, MDIO_WC_DEVAD,\n\t\t\tMDIO_WC_REG_XGXSBLK1_LANECTRL1, &val16);\n\tval16 |= (0x0303 << (lane << 1));\n\tbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t MDIO_WC_REG_XGXSBLK1_LANECTRL1, val16);\n\t \n\tbnx2x_set_aer_mmd(params, phy);\n\t \n\tbnx2x_cl45_write(bp, phy, MDIO_PMA_DEVAD,\n\t\t\t MDIO_WC_REG_IEEE0BLK_MIICNTL, 0x2040);\n\n\tbnx2x_cl45_write(bp, phy, MDIO_PMA_DEVAD,\n\t\t\t MDIO_WC_REG_IEEE0BLK_AUTONEGNP, 0xB);\n\n\t \n\tbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t MDIO_WC_REG_SERDESDIGITAL_MISC2, 0x30);\n\n\t \n\tbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t MDIO_WC_REG_TX66_CONTROL, 0x9);\n\n\t \n\tbnx2x_cl45_read_or_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t\t MDIO_WC_REG_RX66_CONTROL, 0xF9);\n\n\t \n\tbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t MDIO_WC_REG_IEEE0BLK_MIICNTL, 0x4000);\n\tbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t MDIO_WC_REG_IEEE0BLK_MIICNTL, 0x0);\n\n}\n\nstatic void bnx2x_warpcore_set_10G_XFI(struct bnx2x_phy *phy,\n\t\t\t\t       struct link_params *params,\n\t\t\t\t       u8 is_xfi)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu16 misc1_val, tap_val, tx_driver_val, lane, val;\n\tu32 cfg_tap_val, tx_drv_brdct, tx_equal;\n\tu32 ifir_val, ipost2_val, ipre_driver_val;\n\n\t \n\tbnx2x_cl45_read_or_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t\t MDIO_WC_REG_DSC2B0_DSC_MISC_CTRL0, 0x8000);\n\n\t \n\tbnx2x_cl45_read_or_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t\t MDIO_WC_REG_SERDESDIGITAL_CONTROL1000X3, 0x1);\n\n\t \n\tbnx2x_cl45_write(bp, phy, MDIO_AN_DEVAD, MDIO_AN_REG_CTRL, 0);\n\n\t \n\tbnx2x_cl45_read_and_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t\t  MDIO_WC_REG_FX100_CTRL1, 0xFFFA);\n\n\t \n\tbnx2x_cl45_read_or_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t\t MDIO_WC_REG_FX100_CTRL3, 0x0080);\n\n\t \n\tbnx2x_cl45_read_and_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t\t  MDIO_WC_REG_DIGITAL4_MISC3, 0xFF7F);\n\n\t \n\tbnx2x_cl45_read_and_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t\t  MDIO_WC_REG_SERDESDIGITAL_CONTROL1000X1,\n\t\t\t\t  0xFFEE);\n\n\t \n\tbnx2x_cl45_read(bp, phy, MDIO_WC_DEVAD,\n\t\t\tMDIO_WC_REG_SERDESDIGITAL_CONTROL1000X2, &val);\n\tbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t MDIO_WC_REG_SERDESDIGITAL_CONTROL1000X2,\n\t\t\t ((val | 0x0006) & 0xFFFE));\n\n\t \n\tbnx2x_cl45_read(bp, phy, MDIO_WC_DEVAD,\n\t\t\tMDIO_WC_REG_SERDESDIGITAL_MISC1, &misc1_val);\n\n\tmisc1_val &= ~(0x1f);\n\n\tif (is_xfi) {\n\t\tmisc1_val |= 0x5;\n\t\ttap_val = WC_TX_FIR(0x08, 0x37, 0x00);\n\t\ttx_driver_val = WC_TX_DRIVER(0x00, 0x02, 0x03, 0);\n\t} else {\n\t\tcfg_tap_val = REG_RD(bp, params->shmem_base +\n\t\t\t\t     offsetof(struct shmem_region, dev_info.\n\t\t\t\t\t      port_hw_config[params->port].\n\t\t\t\t\t      sfi_tap_values));\n\n\t\ttx_equal = cfg_tap_val & PORT_HW_CFG_TX_EQUALIZATION_MASK;\n\n\t\tmisc1_val |= 0x9;\n\n\t\t \n\t\tif (tx_equal)\n\t\t\ttap_val = (u16)tx_equal;\n\t\telse\n\t\t\ttap_val = WC_TX_FIR(0x0f, 0x2b, 0x02);\n\n\t\tifir_val = DEFAULT_TX_DRV_IFIR;\n\t\tipost2_val = DEFAULT_TX_DRV_POST2;\n\t\tipre_driver_val = DEFAULT_TX_DRV_IPRE_DRIVER;\n\t\ttx_drv_brdct = DEFAULT_TX_DRV_BRDCT;\n\n\t\t \n\t\tif (cfg_tap_val & (PORT_HW_CFG_TX_DRV_IFIR_MASK |\n\t\t\t\t   PORT_HW_CFG_TX_DRV_IPREDRIVER_MASK |\n\t\t\t\t   PORT_HW_CFG_TX_DRV_POST2_MASK)) {\n\t\t\tifir_val = (cfg_tap_val &\n\t\t\t\t    PORT_HW_CFG_TX_DRV_IFIR_MASK) >>\n\t\t\t\tPORT_HW_CFG_TX_DRV_IFIR_SHIFT;\n\t\t\tipre_driver_val = (cfg_tap_val &\n\t\t\t\t\t   PORT_HW_CFG_TX_DRV_IPREDRIVER_MASK)\n\t\t\t>> PORT_HW_CFG_TX_DRV_IPREDRIVER_SHIFT;\n\t\t\tipost2_val = (cfg_tap_val &\n\t\t\t\t      PORT_HW_CFG_TX_DRV_POST2_MASK) >>\n\t\t\t\tPORT_HW_CFG_TX_DRV_POST2_SHIFT;\n\t\t}\n\n\t\tif (cfg_tap_val & PORT_HW_CFG_TX_DRV_BROADCAST_MASK) {\n\t\t\ttx_drv_brdct = (cfg_tap_val &\n\t\t\t\t\tPORT_HW_CFG_TX_DRV_BROADCAST_MASK) >>\n\t\t\t\tPORT_HW_CFG_TX_DRV_BROADCAST_SHIFT;\n\t\t}\n\n\t\ttx_driver_val = WC_TX_DRIVER(ipost2_val, tx_drv_brdct,\n\t\t\t\t\t     ipre_driver_val, ifir_val);\n\t}\n\tbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t MDIO_WC_REG_SERDESDIGITAL_MISC1, misc1_val);\n\n\t \n\tlane = bnx2x_get_warpcore_lane(phy, params);\n\tbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t MDIO_WC_REG_TX_FIR_TAP,\n\t\t\t tap_val | MDIO_WC_REG_TX_FIR_TAP_ENABLE);\n\tbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t MDIO_WC_REG_TX0_TX_DRIVER + 0x10*lane,\n\t\t\t tx_driver_val);\n\n\t \n\tbnx2x_cl45_read_or_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t\t MDIO_WC_REG_SERDESDIGITAL_CONTROL1000X1, 0xd);\n\n\t \n\tbnx2x_cl45_read_or_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t\t MDIO_WC_REG_DIGITAL4_MISC3, 0x8080);\n\n\tbnx2x_warpcore_set_lpi_passthrough(phy, params);\n\n\t \n\tbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t MDIO_WC_REG_IEEE0BLK_MIICNTL, 0x100);\n\n\t \n\tbnx2x_cl45_read_and_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t\t  MDIO_WC_REG_SERDESDIGITAL_CONTROL1000X3,\n\t\t\t\t  0xFFFE);\n\t \n\tbnx2x_cl45_read_and_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t\t  MDIO_WC_REG_DSC2B0_DSC_MISC_CTRL0, 0x7FFF);\n}\n\nstatic void bnx2x_warpcore_set_20G_force_KR2(struct bnx2x_phy *phy,\n\t\t\t\t\t     struct link_params *params)\n{\n\tu16 val;\n\tstruct bnx2x *bp = params->bp;\n\t \n\tCL22_WR_OVER_CL45(bp, phy, MDIO_REG_BANK_AER_BLOCK,\n\t\t\t  MDIO_AER_BLOCK_AER_REG, 0);\n\n\t \n\tbnx2x_cl45_read_and_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t\t  MDIO_WC_REG_XGXSBLK0_XGXSCONTROL, ~(1<<13));\n\n\tbnx2x_set_aer_mmd(params, phy);\n\n\tbnx2x_cl45_read_and_write(bp, phy, MDIO_PMA_DEVAD,\n\t\t\t\t  MDIO_WC_REG_PMD_KR_CONTROL, ~(1<<1));\n\tbnx2x_cl45_write(bp, phy, MDIO_AN_DEVAD,\n\t\t\t MDIO_AN_REG_CTRL, 0);\n\t \n\tbnx2x_cl45_read(bp, phy, MDIO_WC_DEVAD,\n\t\t\tMDIO_WC_REG_CL73_USERB0_CTRL, &val);\n\tval &= ~(1<<5);\n\tval |= (1<<6);\n\tbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t MDIO_WC_REG_CL73_USERB0_CTRL, val);\n\n\t \n\tbnx2x_cl45_read_or_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t\t MDIO_WC_REG_SERDESDIGITAL_MISC1, 0x1f);\n\n\tbnx2x_cl45_read_or_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t\t MDIO_WC_REG_DIGITAL4_MISC3, (1<<7));\n\n\tbnx2x_cl45_read(bp, phy, MDIO_WC_DEVAD,\n\t\t\tMDIO_WC_REG_CL72_USERB0_CL72_MISC1_CONTROL, &val);\n\tval &= ~(3<<14);\n\tval |= (1<<15);\n\tbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t MDIO_WC_REG_CL72_USERB0_CL72_MISC1_CONTROL, val);\n\tbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t MDIO_WC_REG_CL72_USERB0_CL72_TX_FIR_TAP, 0x835A);\n\n\t \n\tCL22_WR_OVER_CL45(bp, phy, MDIO_REG_BANK_AER_BLOCK,\n\t\t\t  MDIO_AER_BLOCK_AER_REG, 0);\n\n\tbnx2x_cl45_read_or_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t\t MDIO_WC_REG_XGXSBLK0_XGXSCONTROL, (1<<13));\n\n\tbnx2x_set_aer_mmd(params, phy);\n}\n\nstatic void bnx2x_warpcore_set_20G_DXGXS(struct bnx2x *bp,\n\t\t\t\t\t struct bnx2x_phy *phy,\n\t\t\t\t\t u16 lane)\n{\n\t \n\tbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t MDIO_WC_REG_RX0_ANARXCONTROL1G, 0x90);\n\n\t \n\tbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t MDIO_WC_REG_RX2_ANARXCONTROL1G, 0x90);\n\n\tbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t MDIO_WC_REG_RX66_SCW0, 0xE070);\n\n\tbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t MDIO_WC_REG_RX66_SCW1, 0xC0D0);\n\n\tbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t MDIO_WC_REG_RX66_SCW2, 0xA0B0);\n\n\tbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t MDIO_WC_REG_RX66_SCW3, 0x8090);\n\n\tbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t MDIO_WC_REG_RX66_SCW0_MASK, 0xF0F0);\n\n\tbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t MDIO_WC_REG_RX66_SCW1_MASK, 0xF0F0);\n\n\tbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t MDIO_WC_REG_RX66_SCW2_MASK, 0xF0F0);\n\n\tbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t MDIO_WC_REG_RX66_SCW3_MASK, 0xF0F0);\n\n\t \n\tbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t MDIO_WC_REG_SERDESDIGITAL_MISC1, 0x6008);\n\n\t \n\tbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t MDIO_WC_REG_DIGITAL4_MISC3, 0x8088);\n\n\t \n\tbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t MDIO_WC_REG_TX_FIR_TAP,\n\t\t\t (WC_TX_FIR(0x12, 0x2d, 0x00) |\n\t\t\t  MDIO_WC_REG_TX_FIR_TAP_ENABLE));\n\tbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t MDIO_WC_REG_TX0_TX_DRIVER + 0x10*lane,\n\t\t\t WC_TX_DRIVER(0x02, 0x02, 0x02, 0));\n}\n\nstatic void bnx2x_warpcore_set_sgmii_speed(struct bnx2x_phy *phy,\n\t\t\t\t\t   struct link_params *params,\n\t\t\t\t\t   u8 fiber_mode,\n\t\t\t\t\t   u8 always_autoneg)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu16 val16, digctrl_kx1, digctrl_kx2;\n\n\t \n\tbnx2x_cl45_read_and_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t\t  MDIO_WC_REG_RX66_CONTROL, ~(3<<13));\n\n\tbnx2x_warpcore_set_lpi_passthrough(phy, params);\n\n\tif (always_autoneg || phy->req_line_speed == SPEED_AUTO_NEG) {\n\t\t \n\t\tbnx2x_cl45_read_or_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t\t\t MDIO_WC_REG_COMBO_IEEE0_MIICTRL,\n\t\t\t\t\t 0x1000);\n\t\tDP(NETIF_MSG_LINK, \"set SGMII AUTONEG\\n\");\n\t} else {\n\t\tbnx2x_cl45_read(bp, phy, MDIO_WC_DEVAD,\n\t\t\t\tMDIO_WC_REG_COMBO_IEEE0_MIICTRL, &val16);\n\t\tval16 &= 0xcebf;\n\t\tswitch (phy->req_line_speed) {\n\t\tcase SPEED_10:\n\t\t\tbreak;\n\t\tcase SPEED_100:\n\t\t\tval16 |= 0x2000;\n\t\t\tbreak;\n\t\tcase SPEED_1000:\n\t\t\tval16 |= 0x0040;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDP(NETIF_MSG_LINK,\n\t\t\t   \"Speed not supported: 0x%x\\n\", phy->req_line_speed);\n\t\t\treturn;\n\t\t}\n\n\t\tif (phy->req_duplex == DUPLEX_FULL)\n\t\t\tval16 |= 0x0100;\n\n\t\tbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t\tMDIO_WC_REG_COMBO_IEEE0_MIICTRL, val16);\n\n\t\tDP(NETIF_MSG_LINK, \"set SGMII force speed %d\\n\",\n\t\t\t       phy->req_line_speed);\n\t\tbnx2x_cl45_read(bp, phy, MDIO_WC_DEVAD,\n\t\t\t\tMDIO_WC_REG_COMBO_IEEE0_MIICTRL, &val16);\n\t\tDP(NETIF_MSG_LINK, \"  (readback) %x\\n\", val16);\n\t}\n\n\t \n\tbnx2x_cl45_read(bp, phy, MDIO_WC_DEVAD,\n\t\t\tMDIO_WC_REG_SERDESDIGITAL_CONTROL1000X1, &digctrl_kx1);\n\tif (fiber_mode)\n\t\tdigctrl_kx1 = 1;\n\telse\n\t\tdigctrl_kx1 &= 0xff4a;\n\n\tbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\tMDIO_WC_REG_SERDESDIGITAL_CONTROL1000X1,\n\t\t\tdigctrl_kx1);\n\n\t \n\tbnx2x_cl45_read(bp, phy, MDIO_WC_DEVAD,\n\t\t\tMDIO_WC_REG_SERDESDIGITAL_CONTROL1000X2, &digctrl_kx2);\n\tbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\tMDIO_WC_REG_SERDESDIGITAL_CONTROL1000X2,\n\t\t\t(digctrl_kx2 & ~(1<<2)));\n\n\t \n\tbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\tMDIO_WC_REG_SERDESDIGITAL_CONTROL1000X2,\n\t\t\t(digctrl_kx2 | (1<<2)));\n\n\t \n\tbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\tMDIO_WC_REG_SERDESDIGITAL_CONTROL1000X1,\n\t\t\t(digctrl_kx1 | 0x10));\n}\n\nstatic void bnx2x_warpcore_reset_lane(struct bnx2x *bp,\n\t\t\t\t      struct bnx2x_phy *phy,\n\t\t\t\t      u8 reset)\n{\n\tu16 val;\n\t \n\tbnx2x_cl45_read(bp, phy, MDIO_WC_DEVAD,\n\t\t\tMDIO_WC_REG_DIGITAL5_MISC6, &val);\n\tif (reset)\n\t\tval |= 0xC000;\n\telse\n\t\tval &= 0x3FFF;\n\tbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t MDIO_WC_REG_DIGITAL5_MISC6, val);\n\tbnx2x_cl45_read(bp, phy, MDIO_WC_DEVAD,\n\t\t\t MDIO_WC_REG_DIGITAL5_MISC6, &val);\n}\n \nstatic void bnx2x_warpcore_clear_regs(struct bnx2x_phy *phy,\n\t\t\t\t      struct link_params *params,\n\t\t\t\t      u16 lane)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu16 i;\n\tstatic struct bnx2x_reg_set wc_regs[] = {\n\t\t{MDIO_AN_DEVAD, MDIO_AN_REG_CTRL, 0},\n\t\t{MDIO_WC_DEVAD, MDIO_WC_REG_FX100_CTRL1, 0x014a},\n\t\t{MDIO_WC_DEVAD, MDIO_WC_REG_FX100_CTRL3, 0x0800},\n\t\t{MDIO_WC_DEVAD, MDIO_WC_REG_DIGITAL4_MISC3, 0x8008},\n\t\t{MDIO_WC_DEVAD, MDIO_WC_REG_SERDESDIGITAL_CONTROL1000X1,\n\t\t\t0x0195},\n\t\t{MDIO_WC_DEVAD, MDIO_WC_REG_SERDESDIGITAL_CONTROL1000X2,\n\t\t\t0x0007},\n\t\t{MDIO_WC_DEVAD, MDIO_WC_REG_SERDESDIGITAL_CONTROL1000X3,\n\t\t\t0x0002},\n\t\t{MDIO_WC_DEVAD, MDIO_WC_REG_SERDESDIGITAL_MISC1, 0x6000},\n\t\t{MDIO_WC_DEVAD, MDIO_WC_REG_TX_FIR_TAP, 0x0000},\n\t\t{MDIO_WC_DEVAD, MDIO_WC_REG_IEEE0BLK_MIICNTL, 0x2040},\n\t\t{MDIO_WC_DEVAD, MDIO_WC_REG_COMBO_IEEE0_MIICTRL, 0x0140}\n\t};\n\t \n\tbnx2x_cl45_read_or_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t\t MDIO_WC_REG_RX66_CONTROL, (3<<13));\n\n\tfor (i = 0; i < ARRAY_SIZE(wc_regs); i++)\n\t\tbnx2x_cl45_write(bp, phy, wc_regs[i].devad, wc_regs[i].reg,\n\t\t\t\t wc_regs[i].val);\n\n\tlane = bnx2x_get_warpcore_lane(phy, params);\n\tbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t MDIO_WC_REG_TX0_TX_DRIVER + 0x10*lane, 0x0990);\n\n}\n\nstatic int bnx2x_get_mod_abs_int_cfg(struct bnx2x *bp,\n\t\t\t\t\t\tu32 chip_id,\n\t\t\t\t\t\tu32 shmem_base, u8 port,\n\t\t\t\t\t\tu8 *gpio_num, u8 *gpio_port)\n{\n\tu32 cfg_pin;\n\t*gpio_num = 0;\n\t*gpio_port = 0;\n\tif (CHIP_IS_E3(bp)) {\n\t\tcfg_pin = (REG_RD(bp, shmem_base +\n\t\t\t\toffsetof(struct shmem_region,\n\t\t\t\tdev_info.port_hw_config[port].e3_sfp_ctrl)) &\n\t\t\t\tPORT_HW_CFG_E3_MOD_ABS_MASK) >>\n\t\t\t\tPORT_HW_CFG_E3_MOD_ABS_SHIFT;\n\n\t\t \n\t\tif ((cfg_pin < PIN_CFG_GPIO0_P0) ||\n\t\t    (cfg_pin > PIN_CFG_GPIO3_P1)) {\n\t\t\tDP(NETIF_MSG_LINK,\n\t\t\t   \"No cfg pin %x for module detect indication\\n\",\n\t\t\t   cfg_pin);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t*gpio_num = (cfg_pin - PIN_CFG_GPIO0_P0) & 0x3;\n\t\t*gpio_port = (cfg_pin - PIN_CFG_GPIO0_P0) >> 2;\n\t} else {\n\t\t*gpio_num = MISC_REGISTERS_GPIO_3;\n\t\t*gpio_port = port;\n\t}\n\n\treturn 0;\n}\n\nstatic int bnx2x_is_sfp_module_plugged(struct bnx2x_phy *phy,\n\t\t\t\t       struct link_params *params)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu8 gpio_num, gpio_port;\n\tu32 gpio_val;\n\tif (bnx2x_get_mod_abs_int_cfg(bp, params->chip_id,\n\t\t\t\t      params->shmem_base, params->port,\n\t\t\t\t      &gpio_num, &gpio_port) != 0)\n\t\treturn 0;\n\tgpio_val = bnx2x_get_gpio(bp, gpio_num, gpio_port);\n\n\t \n\tif (gpio_val == 0)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\nstatic int bnx2x_warpcore_get_sigdet(struct bnx2x_phy *phy,\n\t\t\t\t     struct link_params *params)\n{\n\tu16 gp2_status_reg0, lane;\n\tstruct bnx2x *bp = params->bp;\n\n\tlane = bnx2x_get_warpcore_lane(phy, params);\n\n\tbnx2x_cl45_read(bp, phy, MDIO_WC_DEVAD, MDIO_WC_REG_GP2_STATUS_GP_2_0,\n\t\t\t\t &gp2_status_reg0);\n\n\treturn (gp2_status_reg0 >> (8+lane)) & 0x1;\n}\n\nstatic void bnx2x_warpcore_config_runtime(struct bnx2x_phy *phy,\n\t\t\t\t\t  struct link_params *params,\n\t\t\t\t\t  struct link_vars *vars)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu32 serdes_net_if;\n\tu16 gp_status1 = 0, lnkup = 0, lnkup_kr = 0;\n\n\tvars->turn_to_run_wc_rt = vars->turn_to_run_wc_rt ? 0 : 1;\n\n\tif (!vars->turn_to_run_wc_rt)\n\t\treturn;\n\n\tif (vars->rx_tx_asic_rst) {\n\t\tu16 lane = bnx2x_get_warpcore_lane(phy, params);\n\t\tserdes_net_if = (REG_RD(bp, params->shmem_base +\n\t\t\t\toffsetof(struct shmem_region, dev_info.\n\t\t\t\tport_hw_config[params->port].default_cfg)) &\n\t\t\t\tPORT_HW_CFG_NET_SERDES_IF_MASK);\n\n\t\tswitch (serdes_net_if) {\n\t\tcase PORT_HW_CFG_NET_SERDES_IF_KR:\n\t\t\t \n\t\t\tbnx2x_cl45_read(bp, phy, MDIO_WC_DEVAD, 0x81d1,\n\t\t\t\t\t&gp_status1);\n\t\t\tlnkup = (gp_status1 >> (8+lane)) & 0x1; \n\t\t\t\t \n\t\t\tlnkup_kr = (gp_status1 >> (12+lane)) & 0x1;\n\n\t\t\tif (lnkup_kr || lnkup) {\n\t\t\t\tvars->rx_tx_asic_rst = 0;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tbnx2x_warpcore_reset_lane(bp, phy, 1);\n\t\t\t\tbnx2x_warpcore_reset_lane(bp, phy, 0);\n\n\t\t\t\t \n\t\t\t\tbnx2x_cl45_write(bp, phy, MDIO_AN_DEVAD,\n\t\t\t\t\tMDIO_WC_REG_IEEE0BLK_MIICNTL, 0x1200);\n\n\t\t\t\tvars->rx_tx_asic_rst--;\n\t\t\t\tDP(NETIF_MSG_LINK, \"0x%x retry left\\n\",\n\t\t\t\tvars->rx_tx_asic_rst);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t}  \n\n}\nstatic void bnx2x_warpcore_config_sfi(struct bnx2x_phy *phy,\n\t\t\t\t      struct link_params *params)\n{\n\tu16 lane = bnx2x_get_warpcore_lane(phy, params);\n\tstruct bnx2x *bp = params->bp;\n\tbnx2x_warpcore_clear_regs(phy, params, lane);\n\tif ((params->req_line_speed[LINK_CONFIG_IDX(INT_PHY)] ==\n\t     SPEED_10000) &&\n\t    (phy->media_type != ETH_PHY_SFP_1G_FIBER)) {\n\t\tDP(NETIF_MSG_LINK, \"Setting 10G SFI\\n\");\n\t\tbnx2x_warpcore_set_10G_XFI(phy, params, 0);\n\t} else {\n\t\tDP(NETIF_MSG_LINK, \"Setting 1G Fiber\\n\");\n\t\tbnx2x_warpcore_set_sgmii_speed(phy, params, 1, 0);\n\t}\n}\n\nstatic void bnx2x_sfp_e3_set_transmitter(struct link_params *params,\n\t\t\t\t\t struct bnx2x_phy *phy,\n\t\t\t\t\t u8 tx_en)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu32 cfg_pin;\n\tu8 port = params->port;\n\n\tcfg_pin = REG_RD(bp, params->shmem_base +\n\t\t\t offsetof(struct shmem_region,\n\t\t\t\t  dev_info.port_hw_config[port].e3_sfp_ctrl)) &\n\t\tPORT_HW_CFG_E3_TX_LASER_MASK;\n\t \n\tDP(NETIF_MSG_LINK, \"Setting WC TX to %d\\n\", tx_en);\n\n\t \n\tbnx2x_set_cfg_pin(bp, cfg_pin, tx_en ^ 1);\n\tif (phy->speed_cap_mask & PORT_HW_CFG_SPEED_CAPABILITY_D0_20G)\n\t\tbnx2x_set_cfg_pin(bp, cfg_pin + 3, tx_en ^ 1);\n}\n\nstatic void bnx2x_warpcore_config_init(struct bnx2x_phy *phy,\n\t\t\t\t       struct link_params *params,\n\t\t\t\t       struct link_vars *vars)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu32 serdes_net_if;\n\tu8 fiber_mode;\n\tu16 lane = bnx2x_get_warpcore_lane(phy, params);\n\tserdes_net_if = (REG_RD(bp, params->shmem_base +\n\t\t\t offsetof(struct shmem_region, dev_info.\n\t\t\t\t  port_hw_config[params->port].default_cfg)) &\n\t\t\t PORT_HW_CFG_NET_SERDES_IF_MASK);\n\tDP(NETIF_MSG_LINK, \"Begin Warpcore init, link_speed %d, \"\n\t\t\t   \"serdes_net_if = 0x%x\\n\",\n\t\t       vars->line_speed, serdes_net_if);\n\tbnx2x_set_aer_mmd(params, phy);\n\tbnx2x_warpcore_reset_lane(bp, phy, 1);\n\tvars->phy_flags |= PHY_XGXS_FLAG;\n\tif ((serdes_net_if == PORT_HW_CFG_NET_SERDES_IF_SGMII) ||\n\t    (phy->req_line_speed &&\n\t     ((phy->req_line_speed == SPEED_100) ||\n\t      (phy->req_line_speed == SPEED_10)))) {\n\t\tvars->phy_flags |= PHY_SGMII_FLAG;\n\t\tDP(NETIF_MSG_LINK, \"Setting SGMII mode\\n\");\n\t\tbnx2x_warpcore_clear_regs(phy, params, lane);\n\t\tbnx2x_warpcore_set_sgmii_speed(phy, params, 0, 1);\n\t} else {\n\t\tswitch (serdes_net_if) {\n\t\tcase PORT_HW_CFG_NET_SERDES_IF_KR:\n\t\t\t \n\t\t\tif (params->loopback_mode != LOOPBACK_EXT)\n\t\t\t\tbnx2x_warpcore_enable_AN_KR(phy, params, vars);\n\t\t\telse {\n\t\t\t\tDP(NETIF_MSG_LINK, \"Setting KR 10G-Force\\n\");\n\t\t\t\tbnx2x_warpcore_set_10G_KR(phy, params, vars);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase PORT_HW_CFG_NET_SERDES_IF_XFI:\n\t\t\tbnx2x_warpcore_clear_regs(phy, params, lane);\n\t\t\tif (vars->line_speed == SPEED_10000) {\n\t\t\t\tDP(NETIF_MSG_LINK, \"Setting 10G XFI\\n\");\n\t\t\t\tbnx2x_warpcore_set_10G_XFI(phy, params, 1);\n\t\t\t} else {\n\t\t\t\tif (SINGLE_MEDIA_DIRECT(params)) {\n\t\t\t\t\tDP(NETIF_MSG_LINK, \"1G Fiber\\n\");\n\t\t\t\t\tfiber_mode = 1;\n\t\t\t\t} else {\n\t\t\t\t\tDP(NETIF_MSG_LINK, \"10/100/1G SGMII\\n\");\n\t\t\t\t\tfiber_mode = 0;\n\t\t\t\t}\n\t\t\t\tbnx2x_warpcore_set_sgmii_speed(phy,\n\t\t\t\t\t\t\t\tparams,\n\t\t\t\t\t\t\t\tfiber_mode,\n\t\t\t\t\t\t\t\t0);\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase PORT_HW_CFG_NET_SERDES_IF_SFI:\n\t\t\t \n\t\t\tif ((params->loopback_mode == LOOPBACK_NONE) ||\n\t\t\t    (params->loopback_mode == LOOPBACK_EXT)) {\n\t\t\t\tif (bnx2x_is_sfp_module_plugged(phy, params))\n\t\t\t\t\tbnx2x_sfp_module_detection(phy, params);\n\t\t\t\telse\n\t\t\t\t\tbnx2x_sfp_e3_set_transmitter(params,\n\t\t\t\t\t\t\t\t     phy, 1);\n\t\t\t}\n\n\t\t\tbnx2x_warpcore_config_sfi(phy, params);\n\t\t\tbreak;\n\n\t\tcase PORT_HW_CFG_NET_SERDES_IF_DXGXS:\n\t\t\tif (vars->line_speed != SPEED_20000) {\n\t\t\t\tDP(NETIF_MSG_LINK, \"Speed not supported yet\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tDP(NETIF_MSG_LINK, \"Setting 20G DXGXS\\n\");\n\t\t\tbnx2x_warpcore_set_20G_DXGXS(bp, phy, lane);\n\t\t\t \n\n\t\t\tbnx2x_sfp_module_detection(phy, params);\n\t\t\tbreak;\n\t\tcase PORT_HW_CFG_NET_SERDES_IF_KR2:\n\t\t\tif (!params->loopback_mode) {\n\t\t\t\tbnx2x_warpcore_enable_AN_KR(phy, params, vars);\n\t\t\t} else {\n\t\t\t\tDP(NETIF_MSG_LINK, \"Setting KR 20G-Force\\n\");\n\t\t\t\tbnx2x_warpcore_set_20G_force_KR2(phy, params);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDP(NETIF_MSG_LINK,\n\t\t\t   \"Unsupported Serdes Net Interface 0x%x\\n\",\n\t\t\t   serdes_net_if);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t \n\tbnx2x_warpcore_reset_lane(bp, phy, 0);\n\tDP(NETIF_MSG_LINK, \"Exit config init\\n\");\n}\n\nstatic void bnx2x_warpcore_link_reset(struct bnx2x_phy *phy,\n\t\t\t\t      struct link_params *params)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu16 val16, lane;\n\tbnx2x_sfp_e3_set_transmitter(params, phy, 0);\n\tbnx2x_set_mdio_emac_per_phy(bp, params);\n\tbnx2x_set_aer_mmd(params, phy);\n\t \n\tbnx2x_warpcore_reset_lane(bp, phy, 1);\n\n\t \n\t \n\tbnx2x_cl45_read_and_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t\t  MDIO_WC_REG_COMBO_IEEE0_MIICTRL, 0xBFFF);\n\n\tbnx2x_cl45_read_and_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t\t  MDIO_WC_REG_IEEE0BLK_MIICNTL, 0xfffe);\n\n\t \n\tCL22_WR_OVER_CL45(bp, phy, MDIO_REG_BANK_AER_BLOCK,\n\t\t\t  MDIO_AER_BLOCK_AER_REG, 0);\n\t \n\tbnx2x_cl45_read_and_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t\t  MDIO_WC_REG_XGXSBLK0_XGXSCONTROL,\n\t\t\t\t  ~0x10);\n\n\tbnx2x_cl45_read_and_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t\t  MDIO_WC_REG_XGXSBLK1_LANECTRL2, 0xff00);\n\tlane = bnx2x_get_warpcore_lane(phy, params);\n\t \n\tbnx2x_cl45_read(bp, phy, MDIO_WC_DEVAD,\n\t\t\tMDIO_WC_REG_XGXSBLK1_LANECTRL0, &val16);\n\tval16 |= (0x11 << lane);\n\tif (phy->flags & FLAGS_WC_DUAL_MODE)\n\t\tval16 |= (0x22 << lane);\n\tbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t MDIO_WC_REG_XGXSBLK1_LANECTRL0, val16);\n\n\tbnx2x_cl45_read(bp, phy, MDIO_WC_DEVAD,\n\t\t\tMDIO_WC_REG_XGXSBLK1_LANECTRL1, &val16);\n\tval16 &= ~(0x0303 << (lane << 1));\n\tval16 |= (0x0101 << (lane << 1));\n\tif (phy->flags & FLAGS_WC_DUAL_MODE) {\n\t\tval16 &= ~(0x0c0c << (lane << 1));\n\t\tval16 |= (0x0404 << (lane << 1));\n\t}\n\n\tbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t MDIO_WC_REG_XGXSBLK1_LANECTRL1, val16);\n\t \n\tbnx2x_set_aer_mmd(params, phy);\n\n}\n\nstatic void bnx2x_set_warpcore_loopback(struct bnx2x_phy *phy,\n\t\t\t\t\tstruct link_params *params)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu16 val16;\n\tu32 lane;\n\tDP(NETIF_MSG_LINK, \"Setting Warpcore loopback type %x, speed %d\\n\",\n\t\t       params->loopback_mode, phy->req_line_speed);\n\n\tif (phy->req_line_speed < SPEED_10000 ||\n\t    phy->supported & SUPPORTED_20000baseKR2_Full) {\n\t\t \n\n\t\t \n\t\tCL22_WR_OVER_CL45(bp, phy, MDIO_REG_BANK_AER_BLOCK,\n\t\t\t\t  MDIO_AER_BLOCK_AER_REG, 0);\n\t\t \n\t\tbnx2x_cl45_read_or_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t\t\t MDIO_WC_REG_XGXSBLK0_XGXSCONTROL,\n\t\t\t\t\t 0x10);\n\t\t \n\t\tlane = bnx2x_get_warpcore_lane(phy, params);\n\t\tbnx2x_cl45_read(bp, phy, MDIO_WC_DEVAD,\n\t\t\t\tMDIO_WC_REG_XGXSBLK1_LANECTRL2, &val16);\n\t\tval16 |= (1<<lane);\n\t\tif (phy->flags & FLAGS_WC_DUAL_MODE)\n\t\t\tval16 |= (2<<lane);\n\t\tbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t\t MDIO_WC_REG_XGXSBLK1_LANECTRL2,\n\t\t\t\t val16);\n\n\t\t \n\t\tbnx2x_set_aer_mmd(params, phy);\n\t} else {\n\t\t \n\t\tbnx2x_cl45_read_or_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t\t\t MDIO_WC_REG_COMBO_IEEE0_MIICTRL,\n\t\t\t\t\t 0x4000);\n\t\tbnx2x_cl45_read_or_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t\t\t MDIO_WC_REG_IEEE0BLK_MIICNTL, 0x1);\n\t}\n}\n\n\n\nstatic void bnx2x_sync_link(struct link_params *params,\n\t\t\t     struct link_vars *vars)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu8 link_10g_plus;\n\tif (vars->link_status & LINK_STATUS_PHYSICAL_LINK_FLAG)\n\t\tvars->phy_flags |= PHY_PHYSICAL_LINK_FLAG;\n\tvars->link_up = (vars->link_status & LINK_STATUS_LINK_UP);\n\tif (vars->link_up) {\n\t\tDP(NETIF_MSG_LINK, \"phy link up\\n\");\n\n\t\tvars->phy_link_up = 1;\n\t\tvars->duplex = DUPLEX_FULL;\n\t\tswitch (vars->link_status &\n\t\t\tLINK_STATUS_SPEED_AND_DUPLEX_MASK) {\n\t\tcase LINK_10THD:\n\t\t\tvars->duplex = DUPLEX_HALF;\n\t\t\tfallthrough;\n\t\tcase LINK_10TFD:\n\t\t\tvars->line_speed = SPEED_10;\n\t\t\tbreak;\n\n\t\tcase LINK_100TXHD:\n\t\t\tvars->duplex = DUPLEX_HALF;\n\t\t\tfallthrough;\n\t\tcase LINK_100T4:\n\t\tcase LINK_100TXFD:\n\t\t\tvars->line_speed = SPEED_100;\n\t\t\tbreak;\n\n\t\tcase LINK_1000THD:\n\t\t\tvars->duplex = DUPLEX_HALF;\n\t\t\tfallthrough;\n\t\tcase LINK_1000TFD:\n\t\t\tvars->line_speed = SPEED_1000;\n\t\t\tbreak;\n\n\t\tcase LINK_2500THD:\n\t\t\tvars->duplex = DUPLEX_HALF;\n\t\t\tfallthrough;\n\t\tcase LINK_2500TFD:\n\t\t\tvars->line_speed = SPEED_2500;\n\t\t\tbreak;\n\n\t\tcase LINK_10GTFD:\n\t\t\tvars->line_speed = SPEED_10000;\n\t\t\tbreak;\n\t\tcase LINK_20GTFD:\n\t\t\tvars->line_speed = SPEED_20000;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tvars->flow_ctrl = 0;\n\t\tif (vars->link_status & LINK_STATUS_TX_FLOW_CONTROL_ENABLED)\n\t\t\tvars->flow_ctrl |= BNX2X_FLOW_CTRL_TX;\n\n\t\tif (vars->link_status & LINK_STATUS_RX_FLOW_CONTROL_ENABLED)\n\t\t\tvars->flow_ctrl |= BNX2X_FLOW_CTRL_RX;\n\n\t\tif (!vars->flow_ctrl)\n\t\t\tvars->flow_ctrl = BNX2X_FLOW_CTRL_NONE;\n\n\t\tif (vars->line_speed &&\n\t\t    ((vars->line_speed == SPEED_10) ||\n\t\t     (vars->line_speed == SPEED_100))) {\n\t\t\tvars->phy_flags |= PHY_SGMII_FLAG;\n\t\t} else {\n\t\t\tvars->phy_flags &= ~PHY_SGMII_FLAG;\n\t\t}\n\t\tif (vars->line_speed &&\n\t\t    USES_WARPCORE(bp) &&\n\t\t    (vars->line_speed == SPEED_1000))\n\t\t\tvars->phy_flags |= PHY_SGMII_FLAG;\n\t\t \n\t\tlink_10g_plus = (vars->line_speed >= SPEED_10000);\n\n\t\tif (link_10g_plus) {\n\t\t\tif (USES_WARPCORE(bp))\n\t\t\t\tvars->mac_type = MAC_TYPE_XMAC;\n\t\t\telse\n\t\t\t\tvars->mac_type = MAC_TYPE_BMAC;\n\t\t} else {\n\t\t\tif (USES_WARPCORE(bp))\n\t\t\t\tvars->mac_type = MAC_TYPE_UMAC;\n\t\t\telse\n\t\t\t\tvars->mac_type = MAC_TYPE_EMAC;\n\t\t}\n\t} else {  \n\t\tDP(NETIF_MSG_LINK, \"phy link down\\n\");\n\n\t\tvars->phy_link_up = 0;\n\n\t\tvars->line_speed = 0;\n\t\tvars->duplex = DUPLEX_FULL;\n\t\tvars->flow_ctrl = BNX2X_FLOW_CTRL_NONE;\n\n\t\t \n\t\tvars->mac_type = MAC_TYPE_NONE;\n\t\tif (vars->link_status & LINK_STATUS_PHYSICAL_LINK_FLAG)\n\t\t\tvars->phy_flags |= PHY_HALF_OPEN_CONN_FLAG;\n\t\tif (vars->link_status & LINK_STATUS_SFP_TX_FAULT)\n\t\t\tvars->phy_flags |= PHY_SFP_TX_FAULT_FLAG;\n\t}\n}\n\nvoid bnx2x_link_status_update(struct link_params *params,\n\t\t\t      struct link_vars *vars)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu8 port = params->port;\n\tu32 sync_offset, media_types;\n\t \n\tset_phy_vars(params, vars);\n\n\tvars->link_status = REG_RD(bp, params->shmem_base +\n\t\t\t\t   offsetof(struct shmem_region,\n\t\t\t\t\t    port_mb[port].link_status));\n\n\t \n\tif (params->loopback_mode != LOOPBACK_NONE &&\n\t    params->loopback_mode != LOOPBACK_EXT)\n\t\tvars->link_status |= LINK_STATUS_LINK_UP;\n\n\tif (bnx2x_eee_has_cap(params))\n\t\tvars->eee_status = REG_RD(bp, params->shmem2_base +\n\t\t\t\t\t  offsetof(struct shmem2_region,\n\t\t\t\t\t\t   eee_status[params->port]));\n\n\tvars->phy_flags = PHY_XGXS_FLAG;\n\tbnx2x_sync_link(params, vars);\n\t \n\tsync_offset = params->shmem_base +\n\t\t\toffsetof(struct shmem_region,\n\t\t\t\t dev_info.port_hw_config[port].media_type);\n\tmedia_types = REG_RD(bp, sync_offset);\n\n\tparams->phy[INT_PHY].media_type =\n\t\t(media_types & PORT_HW_CFG_MEDIA_TYPE_PHY0_MASK) >>\n\t\tPORT_HW_CFG_MEDIA_TYPE_PHY0_SHIFT;\n\tparams->phy[EXT_PHY1].media_type =\n\t\t(media_types & PORT_HW_CFG_MEDIA_TYPE_PHY1_MASK) >>\n\t\tPORT_HW_CFG_MEDIA_TYPE_PHY1_SHIFT;\n\tparams->phy[EXT_PHY2].media_type =\n\t\t(media_types & PORT_HW_CFG_MEDIA_TYPE_PHY2_MASK) >>\n\t\tPORT_HW_CFG_MEDIA_TYPE_PHY2_SHIFT;\n\tDP(NETIF_MSG_LINK, \"media_types = 0x%x\\n\", media_types);\n\n\t \n\tsync_offset = params->shmem_base +\n\t\t\toffsetof(struct shmem_region,\n\t\t\t\t dev_info.port_hw_config[port].aeu_int_mask);\n\n\tvars->aeu_int_mask = REG_RD(bp, sync_offset);\n\n\t \n\tif (vars->link_status & LINK_STATUS_PFC_ENABLED)\n\t\tparams->feature_config_flags |=\n\t\t\t\t\tFEATURE_CONFIG_PFC_ENABLED;\n\telse\n\t\tparams->feature_config_flags &=\n\t\t\t\t\t~FEATURE_CONFIG_PFC_ENABLED;\n\n\tif (SHMEM2_HAS(bp, link_attr_sync))\n\t\tparams->link_attr_sync = SHMEM2_RD(bp,\n\t\t\t\t\t\t link_attr_sync[params->port]);\n\n\tDP(NETIF_MSG_LINK, \"link_status 0x%x  phy_link_up %x int_mask 0x%x\\n\",\n\t\t vars->link_status, vars->phy_link_up, vars->aeu_int_mask);\n\tDP(NETIF_MSG_LINK, \"line_speed %x  duplex %x  flow_ctrl 0x%x\\n\",\n\t\t vars->line_speed, vars->duplex, vars->flow_ctrl);\n}\n\nstatic void bnx2x_set_master_ln(struct link_params *params,\n\t\t\t\tstruct bnx2x_phy *phy)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu16 new_master_ln, ser_lane;\n\tser_lane = ((params->lane_config &\n\t\t     PORT_HW_CFG_LANE_SWAP_CFG_MASTER_MASK) >>\n\t\t    PORT_HW_CFG_LANE_SWAP_CFG_MASTER_SHIFT);\n\n\t \n\tCL22_RD_OVER_CL45(bp, phy,\n\t\t\t  MDIO_REG_BANK_XGXS_BLOCK2,\n\t\t\t  MDIO_XGXS_BLOCK2_TEST_MODE_LANE,\n\t\t\t  &new_master_ln);\n\n\tCL22_WR_OVER_CL45(bp, phy,\n\t\t\t  MDIO_REG_BANK_XGXS_BLOCK2 ,\n\t\t\t  MDIO_XGXS_BLOCK2_TEST_MODE_LANE,\n\t\t\t  (new_master_ln | ser_lane));\n}\n\nstatic int bnx2x_reset_unicore(struct link_params *params,\n\t\t\t       struct bnx2x_phy *phy,\n\t\t\t       u8 set_serdes)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu16 mii_control;\n\tu16 i;\n\tCL22_RD_OVER_CL45(bp, phy,\n\t\t\t  MDIO_REG_BANK_COMBO_IEEE0,\n\t\t\t  MDIO_COMBO_IEEE0_MII_CONTROL, &mii_control);\n\n\t \n\tCL22_WR_OVER_CL45(bp, phy,\n\t\t\t  MDIO_REG_BANK_COMBO_IEEE0,\n\t\t\t  MDIO_COMBO_IEEE0_MII_CONTROL,\n\t\t\t  (mii_control |\n\t\t\t   MDIO_COMBO_IEEO_MII_CONTROL_RESET));\n\tif (set_serdes)\n\t\tbnx2x_set_serdes_access(bp, params->port);\n\n\t \n\tfor (i = 0; i < MDIO_ACCESS_TIMEOUT; i++) {\n\t\tudelay(5);\n\n\t\t \n\t\tCL22_RD_OVER_CL45(bp, phy,\n\t\t\t\t  MDIO_REG_BANK_COMBO_IEEE0,\n\t\t\t\t  MDIO_COMBO_IEEE0_MII_CONTROL,\n\t\t\t\t  &mii_control);\n\n\t\tif (!(mii_control & MDIO_COMBO_IEEO_MII_CONTROL_RESET)) {\n\t\t\tudelay(5);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tnetdev_err(bp->dev,  \"Warning: PHY was not initialized,\"\n\t\t\t      \" Port %d\\n\",\n\t\t\t params->port);\n\tDP(NETIF_MSG_LINK, \"BUG! XGXS is still in reset!\\n\");\n\treturn -EINVAL;\n\n}\n\nstatic void bnx2x_set_swap_lanes(struct link_params *params,\n\t\t\t\t struct bnx2x_phy *phy)\n{\n\tstruct bnx2x *bp = params->bp;\n\t \n\tu16 rx_lane_swap, tx_lane_swap;\n\n\trx_lane_swap = ((params->lane_config &\n\t\t\t PORT_HW_CFG_LANE_SWAP_CFG_RX_MASK) >>\n\t\t\tPORT_HW_CFG_LANE_SWAP_CFG_RX_SHIFT);\n\ttx_lane_swap = ((params->lane_config &\n\t\t\t PORT_HW_CFG_LANE_SWAP_CFG_TX_MASK) >>\n\t\t\tPORT_HW_CFG_LANE_SWAP_CFG_TX_SHIFT);\n\n\tif (rx_lane_swap != 0x1b) {\n\t\tCL22_WR_OVER_CL45(bp, phy,\n\t\t\t\t  MDIO_REG_BANK_XGXS_BLOCK2,\n\t\t\t\t  MDIO_XGXS_BLOCK2_RX_LN_SWAP,\n\t\t\t\t  (rx_lane_swap |\n\t\t\t\t   MDIO_XGXS_BLOCK2_RX_LN_SWAP_ENABLE |\n\t\t\t\t   MDIO_XGXS_BLOCK2_RX_LN_SWAP_FORCE_ENABLE));\n\t} else {\n\t\tCL22_WR_OVER_CL45(bp, phy,\n\t\t\t\t  MDIO_REG_BANK_XGXS_BLOCK2,\n\t\t\t\t  MDIO_XGXS_BLOCK2_RX_LN_SWAP, 0);\n\t}\n\n\tif (tx_lane_swap != 0x1b) {\n\t\tCL22_WR_OVER_CL45(bp, phy,\n\t\t\t\t  MDIO_REG_BANK_XGXS_BLOCK2,\n\t\t\t\t  MDIO_XGXS_BLOCK2_TX_LN_SWAP,\n\t\t\t\t  (tx_lane_swap |\n\t\t\t\t   MDIO_XGXS_BLOCK2_TX_LN_SWAP_ENABLE));\n\t} else {\n\t\tCL22_WR_OVER_CL45(bp, phy,\n\t\t\t\t  MDIO_REG_BANK_XGXS_BLOCK2,\n\t\t\t\t  MDIO_XGXS_BLOCK2_TX_LN_SWAP, 0);\n\t}\n}\n\nstatic void bnx2x_set_parallel_detection(struct bnx2x_phy *phy,\n\t\t\t\t\t struct link_params *params)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu16 control2;\n\tCL22_RD_OVER_CL45(bp, phy,\n\t\t\t  MDIO_REG_BANK_SERDES_DIGITAL,\n\t\t\t  MDIO_SERDES_DIGITAL_A_1000X_CONTROL2,\n\t\t\t  &control2);\n\tif (phy->speed_cap_mask & PORT_HW_CFG_SPEED_CAPABILITY_D0_1G)\n\t\tcontrol2 |= MDIO_SERDES_DIGITAL_A_1000X_CONTROL2_PRL_DT_EN;\n\telse\n\t\tcontrol2 &= ~MDIO_SERDES_DIGITAL_A_1000X_CONTROL2_PRL_DT_EN;\n\tDP(NETIF_MSG_LINK, \"phy->speed_cap_mask = 0x%x, control2 = 0x%x\\n\",\n\t\tphy->speed_cap_mask, control2);\n\tCL22_WR_OVER_CL45(bp, phy,\n\t\t\t  MDIO_REG_BANK_SERDES_DIGITAL,\n\t\t\t  MDIO_SERDES_DIGITAL_A_1000X_CONTROL2,\n\t\t\t  control2);\n\n\tif ((phy->type == PORT_HW_CFG_XGXS_EXT_PHY_TYPE_DIRECT) &&\n\t     (phy->speed_cap_mask &\n\t\t    PORT_HW_CFG_SPEED_CAPABILITY_D0_10G)) {\n\t\tDP(NETIF_MSG_LINK, \"XGXS\\n\");\n\n\t\tCL22_WR_OVER_CL45(bp, phy,\n\t\t\t\t MDIO_REG_BANK_10G_PARALLEL_DETECT,\n\t\t\t\t MDIO_10G_PARALLEL_DETECT_PAR_DET_10G_LINK,\n\t\t\t\t MDIO_10G_PARALLEL_DETECT_PAR_DET_10G_LINK_CNT);\n\n\t\tCL22_RD_OVER_CL45(bp, phy,\n\t\t\t\t  MDIO_REG_BANK_10G_PARALLEL_DETECT,\n\t\t\t\t  MDIO_10G_PARALLEL_DETECT_PAR_DET_10G_CONTROL,\n\t\t\t\t  &control2);\n\n\n\t\tcontrol2 |=\n\t\t    MDIO_10G_PARALLEL_DETECT_PAR_DET_10G_CONTROL_PARDET10G_EN;\n\n\t\tCL22_WR_OVER_CL45(bp, phy,\n\t\t\t\t  MDIO_REG_BANK_10G_PARALLEL_DETECT,\n\t\t\t\t  MDIO_10G_PARALLEL_DETECT_PAR_DET_10G_CONTROL,\n\t\t\t\t  control2);\n\n\t\t \n\t\tCL22_WR_OVER_CL45(bp, phy,\n\t\t\t\t  MDIO_REG_BANK_XGXS_BLOCK2,\n\t\t\t\t  MDIO_XGXS_BLOCK2_UNICORE_MODE_10G,\n\t\t\t\t  MDIO_XGXS_BLOCK2_UNICORE_MODE_10G_CX4_XGXS |\n\t\t\t\t  MDIO_XGXS_BLOCK2_UNICORE_MODE_10G_HIGIG_XGXS);\n\t}\n}\n\nstatic void bnx2x_set_autoneg(struct bnx2x_phy *phy,\n\t\t\t      struct link_params *params,\n\t\t\t      struct link_vars *vars,\n\t\t\t      u8 enable_cl73)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu16 reg_val;\n\n\t \n\tCL22_RD_OVER_CL45(bp, phy,\n\t\t\t  MDIO_REG_BANK_COMBO_IEEE0,\n\t\t\t  MDIO_COMBO_IEEE0_MII_CONTROL, &reg_val);\n\n\t \n\tif (vars->line_speed == SPEED_AUTO_NEG)\n\t\treg_val |= MDIO_COMBO_IEEO_MII_CONTROL_AN_EN;\n\telse  \n\t\treg_val &= ~(MDIO_COMBO_IEEO_MII_CONTROL_AN_EN |\n\t\t\t     MDIO_COMBO_IEEO_MII_CONTROL_RESTART_AN);\n\n\tCL22_WR_OVER_CL45(bp, phy,\n\t\t\t  MDIO_REG_BANK_COMBO_IEEE0,\n\t\t\t  MDIO_COMBO_IEEE0_MII_CONTROL, reg_val);\n\n\t \n\n\tCL22_RD_OVER_CL45(bp, phy,\n\t\t\t  MDIO_REG_BANK_SERDES_DIGITAL,\n\t\t\t  MDIO_SERDES_DIGITAL_A_1000X_CONTROL1, &reg_val);\n\treg_val &= ~(MDIO_SERDES_DIGITAL_A_1000X_CONTROL1_SIGNAL_DETECT_EN |\n\t\t    MDIO_SERDES_DIGITAL_A_1000X_CONTROL1_INVERT_SIGNAL_DETECT);\n\treg_val |= MDIO_SERDES_DIGITAL_A_1000X_CONTROL1_FIBER_MODE;\n\tif (vars->line_speed == SPEED_AUTO_NEG)\n\t\treg_val |= MDIO_SERDES_DIGITAL_A_1000X_CONTROL1_AUTODET;\n\telse\n\t\treg_val &= ~MDIO_SERDES_DIGITAL_A_1000X_CONTROL1_AUTODET;\n\n\tCL22_WR_OVER_CL45(bp, phy,\n\t\t\t  MDIO_REG_BANK_SERDES_DIGITAL,\n\t\t\t  MDIO_SERDES_DIGITAL_A_1000X_CONTROL1, reg_val);\n\n\t \n\tCL22_RD_OVER_CL45(bp, phy,\n\t\t\t  MDIO_REG_BANK_BAM_NEXT_PAGE,\n\t\t\t  MDIO_BAM_NEXT_PAGE_MP5_NEXT_PAGE_CTRL,\n\t\t\t  &reg_val);\n\tif (vars->line_speed == SPEED_AUTO_NEG) {\n\t\t \n\t\treg_val |= (MDIO_BAM_NEXT_PAGE_MP5_NEXT_PAGE_CTRL_BAM_MODE |\n\t\t\t    MDIO_BAM_NEXT_PAGE_MP5_NEXT_PAGE_CTRL_TETON_AN);\n\t} else {\n\t\t \n\t\treg_val &= ~(MDIO_BAM_NEXT_PAGE_MP5_NEXT_PAGE_CTRL_BAM_MODE |\n\t\t\t     MDIO_BAM_NEXT_PAGE_MP5_NEXT_PAGE_CTRL_TETON_AN);\n\t}\n\tCL22_WR_OVER_CL45(bp, phy,\n\t\t\t  MDIO_REG_BANK_BAM_NEXT_PAGE,\n\t\t\t  MDIO_BAM_NEXT_PAGE_MP5_NEXT_PAGE_CTRL,\n\t\t\t  reg_val);\n\n\tif (enable_cl73) {\n\t\t \n\t\tCL22_WR_OVER_CL45(bp, phy,\n\t\t\t\t  MDIO_REG_BANK_CL73_USERB0,\n\t\t\t\t  MDIO_CL73_USERB0_CL73_UCTRL,\n\t\t\t\t  0xe);\n\n\t\t \n\t\tCL22_WR_OVER_CL45(bp, phy,\n\t\t\tMDIO_REG_BANK_CL73_USERB0,\n\t\t\tMDIO_CL73_USERB0_CL73_BAM_CTRL1,\n\t\t\tMDIO_CL73_USERB0_CL73_BAM_CTRL1_BAM_EN |\n\t\t\tMDIO_CL73_USERB0_CL73_BAM_CTRL1_BAM_STATION_MNGR_EN |\n\t\t\tMDIO_CL73_USERB0_CL73_BAM_CTRL1_BAM_NP_AFTER_BP_EN);\n\n\t\t \n\t\tCL22_RD_OVER_CL45(bp, phy,\n\t\t\t\t  MDIO_REG_BANK_CL73_IEEEB1,\n\t\t\t\t  MDIO_CL73_IEEEB1_AN_ADV2,\n\t\t\t\t  &reg_val);\n\t\tif (phy->speed_cap_mask &\n\t\t    PORT_HW_CFG_SPEED_CAPABILITY_D0_10G)\n\t\t\treg_val |= MDIO_CL73_IEEEB1_AN_ADV2_ADVR_10G_KX4;\n\t\tif (phy->speed_cap_mask &\n\t\t    PORT_HW_CFG_SPEED_CAPABILITY_D0_1G)\n\t\t\treg_val |= MDIO_CL73_IEEEB1_AN_ADV2_ADVR_1000M_KX;\n\n\t\tCL22_WR_OVER_CL45(bp, phy,\n\t\t\t\t  MDIO_REG_BANK_CL73_IEEEB1,\n\t\t\t\t  MDIO_CL73_IEEEB1_AN_ADV2,\n\t\t\t\t  reg_val);\n\n\t\t \n\t\treg_val = MDIO_CL73_IEEEB0_CL73_AN_CONTROL_AN_EN;\n\n\t} else  \n\t\treg_val = 0;\n\n\tCL22_WR_OVER_CL45(bp, phy,\n\t\t\t  MDIO_REG_BANK_CL73_IEEEB0,\n\t\t\t  MDIO_CL73_IEEEB0_CL73_AN_CONTROL, reg_val);\n}\n\n \nstatic void bnx2x_program_serdes(struct bnx2x_phy *phy,\n\t\t\t\t struct link_params *params,\n\t\t\t\t struct link_vars *vars)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu16 reg_val;\n\n\t \n\tCL22_RD_OVER_CL45(bp, phy,\n\t\t\t  MDIO_REG_BANK_COMBO_IEEE0,\n\t\t\t  MDIO_COMBO_IEEE0_MII_CONTROL, &reg_val);\n\treg_val &= ~(MDIO_COMBO_IEEO_MII_CONTROL_FULL_DUPLEX |\n\t\t     MDIO_COMBO_IEEO_MII_CONTROL_AN_EN |\n\t\t     MDIO_COMBO_IEEO_MII_CONTROL_MAN_SGMII_SP_MASK);\n\tif (phy->req_duplex == DUPLEX_FULL)\n\t\treg_val |= MDIO_COMBO_IEEO_MII_CONTROL_FULL_DUPLEX;\n\tCL22_WR_OVER_CL45(bp, phy,\n\t\t\t  MDIO_REG_BANK_COMBO_IEEE0,\n\t\t\t  MDIO_COMBO_IEEE0_MII_CONTROL, reg_val);\n\n\t \n\tCL22_RD_OVER_CL45(bp, phy,\n\t\t\t  MDIO_REG_BANK_SERDES_DIGITAL,\n\t\t\t  MDIO_SERDES_DIGITAL_MISC1, &reg_val);\n\t \n\tDP(NETIF_MSG_LINK, \"MDIO_REG_BANK_SERDES_DIGITAL = 0x%x\\n\", reg_val);\n\n\treg_val &= ~(MDIO_SERDES_DIGITAL_MISC1_FORCE_SPEED_MASK |\n\t\t     MDIO_SERDES_DIGITAL_MISC1_FORCE_SPEED_SEL);\n\n\tif (!((vars->line_speed == SPEED_1000) ||\n\t      (vars->line_speed == SPEED_100) ||\n\t      (vars->line_speed == SPEED_10))) {\n\n\t\treg_val |= (MDIO_SERDES_DIGITAL_MISC1_REFCLK_SEL_156_25M |\n\t\t\t    MDIO_SERDES_DIGITAL_MISC1_FORCE_SPEED_SEL);\n\t\tif (vars->line_speed == SPEED_10000)\n\t\t\treg_val |=\n\t\t\t\tMDIO_SERDES_DIGITAL_MISC1_FORCE_SPEED_10G_CX4;\n\t}\n\n\tCL22_WR_OVER_CL45(bp, phy,\n\t\t\t  MDIO_REG_BANK_SERDES_DIGITAL,\n\t\t\t  MDIO_SERDES_DIGITAL_MISC1, reg_val);\n\n}\n\nstatic void bnx2x_set_brcm_cl37_advertisement(struct bnx2x_phy *phy,\n\t\t\t\t\t      struct link_params *params)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu16 val = 0;\n\n\t \n\tif (phy->speed_cap_mask & PORT_HW_CFG_SPEED_CAPABILITY_D0_2_5G)\n\t\tval |= MDIO_OVER_1G_UP1_2_5G;\n\tif (phy->speed_cap_mask & PORT_HW_CFG_SPEED_CAPABILITY_D0_10G)\n\t\tval |= MDIO_OVER_1G_UP1_10G;\n\tCL22_WR_OVER_CL45(bp, phy,\n\t\t\t  MDIO_REG_BANK_OVER_1G,\n\t\t\t  MDIO_OVER_1G_UP1, val);\n\n\tCL22_WR_OVER_CL45(bp, phy,\n\t\t\t  MDIO_REG_BANK_OVER_1G,\n\t\t\t  MDIO_OVER_1G_UP3, 0x400);\n}\n\nstatic void bnx2x_set_ieee_aneg_advertisement(struct bnx2x_phy *phy,\n\t\t\t\t\t      struct link_params *params,\n\t\t\t\t\t      u16 ieee_fc)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu16 val;\n\t \n\n\tCL22_WR_OVER_CL45(bp, phy,\n\t\t\t  MDIO_REG_BANK_COMBO_IEEE0,\n\t\t\t  MDIO_COMBO_IEEE0_AUTO_NEG_ADV, ieee_fc);\n\tCL22_RD_OVER_CL45(bp, phy,\n\t\t\t  MDIO_REG_BANK_CL73_IEEEB1,\n\t\t\t  MDIO_CL73_IEEEB1_AN_ADV1, &val);\n\tval &= ~MDIO_CL73_IEEEB1_AN_ADV1_PAUSE_BOTH;\n\tval |= ((ieee_fc<<3) & MDIO_CL73_IEEEB1_AN_ADV1_PAUSE_MASK);\n\tCL22_WR_OVER_CL45(bp, phy,\n\t\t\t  MDIO_REG_BANK_CL73_IEEEB1,\n\t\t\t  MDIO_CL73_IEEEB1_AN_ADV1, val);\n}\n\nstatic void bnx2x_restart_autoneg(struct bnx2x_phy *phy,\n\t\t\t\t  struct link_params *params,\n\t\t\t\t  u8 enable_cl73)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu16 mii_control;\n\n\tDP(NETIF_MSG_LINK, \"bnx2x_restart_autoneg\\n\");\n\t \n\n\tif (enable_cl73) {\n\t\tCL22_RD_OVER_CL45(bp, phy,\n\t\t\t\t  MDIO_REG_BANK_CL73_IEEEB0,\n\t\t\t\t  MDIO_CL73_IEEEB0_CL73_AN_CONTROL,\n\t\t\t\t  &mii_control);\n\n\t\tCL22_WR_OVER_CL45(bp, phy,\n\t\t\t\t  MDIO_REG_BANK_CL73_IEEEB0,\n\t\t\t\t  MDIO_CL73_IEEEB0_CL73_AN_CONTROL,\n\t\t\t\t  (mii_control |\n\t\t\t\t  MDIO_CL73_IEEEB0_CL73_AN_CONTROL_AN_EN |\n\t\t\t\t  MDIO_CL73_IEEEB0_CL73_AN_CONTROL_RESTART_AN));\n\t} else {\n\n\t\tCL22_RD_OVER_CL45(bp, phy,\n\t\t\t\t  MDIO_REG_BANK_COMBO_IEEE0,\n\t\t\t\t  MDIO_COMBO_IEEE0_MII_CONTROL,\n\t\t\t\t  &mii_control);\n\t\tDP(NETIF_MSG_LINK,\n\t\t\t \"bnx2x_restart_autoneg mii_control before = 0x%x\\n\",\n\t\t\t mii_control);\n\t\tCL22_WR_OVER_CL45(bp, phy,\n\t\t\t\t  MDIO_REG_BANK_COMBO_IEEE0,\n\t\t\t\t  MDIO_COMBO_IEEE0_MII_CONTROL,\n\t\t\t\t  (mii_control |\n\t\t\t\t   MDIO_COMBO_IEEO_MII_CONTROL_AN_EN |\n\t\t\t\t   MDIO_COMBO_IEEO_MII_CONTROL_RESTART_AN));\n\t}\n}\n\nstatic void bnx2x_initialize_sgmii_process(struct bnx2x_phy *phy,\n\t\t\t\t\t   struct link_params *params,\n\t\t\t\t\t   struct link_vars *vars)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu16 control1;\n\n\t \n\n\tCL22_RD_OVER_CL45(bp, phy,\n\t\t\t  MDIO_REG_BANK_SERDES_DIGITAL,\n\t\t\t  MDIO_SERDES_DIGITAL_A_1000X_CONTROL1,\n\t\t\t  &control1);\n\tcontrol1 |= MDIO_SERDES_DIGITAL_A_1000X_CONTROL1_INVERT_SIGNAL_DETECT;\n\t \n\tcontrol1 &= ~(MDIO_SERDES_DIGITAL_A_1000X_CONTROL1_FIBER_MODE |\n\t\t      MDIO_SERDES_DIGITAL_A_1000X_CONTROL1_AUTODET |\n\t\t      MDIO_SERDES_DIGITAL_A_1000X_CONTROL1_MSTR_MODE);\n\tCL22_WR_OVER_CL45(bp, phy,\n\t\t\t  MDIO_REG_BANK_SERDES_DIGITAL,\n\t\t\t  MDIO_SERDES_DIGITAL_A_1000X_CONTROL1,\n\t\t\t  control1);\n\n\t \n\tif (!(vars->line_speed == SPEED_AUTO_NEG)) {\n\t\t \n\t\tu16 mii_control;\n\n\t\tCL22_RD_OVER_CL45(bp, phy,\n\t\t\t\t  MDIO_REG_BANK_COMBO_IEEE0,\n\t\t\t\t  MDIO_COMBO_IEEE0_MII_CONTROL,\n\t\t\t\t  &mii_control);\n\t\tmii_control &= ~(MDIO_COMBO_IEEO_MII_CONTROL_AN_EN |\n\t\t\t\t MDIO_COMBO_IEEO_MII_CONTROL_MAN_SGMII_SP_MASK|\n\t\t\t\t MDIO_COMBO_IEEO_MII_CONTROL_FULL_DUPLEX);\n\n\t\tswitch (vars->line_speed) {\n\t\tcase SPEED_100:\n\t\t\tmii_control |=\n\t\t\t\tMDIO_COMBO_IEEO_MII_CONTROL_MAN_SGMII_SP_100;\n\t\t\tbreak;\n\t\tcase SPEED_1000:\n\t\t\tmii_control |=\n\t\t\t\tMDIO_COMBO_IEEO_MII_CONTROL_MAN_SGMII_SP_1000;\n\t\t\tbreak;\n\t\tcase SPEED_10:\n\t\t\t \n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\tDP(NETIF_MSG_LINK, \"Invalid line_speed 0x%x\\n\",\n\t\t\t\t  vars->line_speed);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (phy->req_duplex == DUPLEX_FULL)\n\t\t\tmii_control |=\n\t\t\t\tMDIO_COMBO_IEEO_MII_CONTROL_FULL_DUPLEX;\n\t\tCL22_WR_OVER_CL45(bp, phy,\n\t\t\t\t  MDIO_REG_BANK_COMBO_IEEE0,\n\t\t\t\t  MDIO_COMBO_IEEE0_MII_CONTROL,\n\t\t\t\t  mii_control);\n\n\t} else {  \n\t\t \n\t\tbnx2x_restart_autoneg(phy, params, 0);\n\t}\n}\n\n \nstatic int bnx2x_direct_parallel_detect_used(struct bnx2x_phy *phy,\n\t\t\t\t\t     struct link_params *params)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu16 pd_10g, status2_1000x;\n\tif (phy->req_line_speed != SPEED_AUTO_NEG)\n\t\treturn 0;\n\tCL22_RD_OVER_CL45(bp, phy,\n\t\t\t  MDIO_REG_BANK_SERDES_DIGITAL,\n\t\t\t  MDIO_SERDES_DIGITAL_A_1000X_STATUS2,\n\t\t\t  &status2_1000x);\n\tCL22_RD_OVER_CL45(bp, phy,\n\t\t\t  MDIO_REG_BANK_SERDES_DIGITAL,\n\t\t\t  MDIO_SERDES_DIGITAL_A_1000X_STATUS2,\n\t\t\t  &status2_1000x);\n\tif (status2_1000x & MDIO_SERDES_DIGITAL_A_1000X_STATUS2_AN_DISABLED) {\n\t\tDP(NETIF_MSG_LINK, \"1G parallel detect link on port %d\\n\",\n\t\t\t params->port);\n\t\treturn 1;\n\t}\n\n\tCL22_RD_OVER_CL45(bp, phy,\n\t\t\t  MDIO_REG_BANK_10G_PARALLEL_DETECT,\n\t\t\t  MDIO_10G_PARALLEL_DETECT_PAR_DET_10G_STATUS,\n\t\t\t  &pd_10g);\n\n\tif (pd_10g & MDIO_10G_PARALLEL_DETECT_PAR_DET_10G_STATUS_PD_LINK) {\n\t\tDP(NETIF_MSG_LINK, \"10G parallel detect link on port %d\\n\",\n\t\t\t params->port);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic void bnx2x_update_adv_fc(struct bnx2x_phy *phy,\n\t\t\t\tstruct link_params *params,\n\t\t\t\tstruct link_vars *vars,\n\t\t\t\tu32 gp_status)\n{\n\tu16 ld_pause;    \n\tu16 lp_pause;    \n\tu16 pause_result;\n\tstruct bnx2x *bp = params->bp;\n\tif ((gp_status &\n\t     (MDIO_GP_STATUS_TOP_AN_STATUS1_CL73_AUTONEG_COMPLETE |\n\t      MDIO_GP_STATUS_TOP_AN_STATUS1_CL73_MR_LP_NP_AN_ABLE)) ==\n\t    (MDIO_GP_STATUS_TOP_AN_STATUS1_CL73_AUTONEG_COMPLETE |\n\t     MDIO_GP_STATUS_TOP_AN_STATUS1_CL73_MR_LP_NP_AN_ABLE)) {\n\n\t\tCL22_RD_OVER_CL45(bp, phy,\n\t\t\t\t  MDIO_REG_BANK_CL73_IEEEB1,\n\t\t\t\t  MDIO_CL73_IEEEB1_AN_ADV1,\n\t\t\t\t  &ld_pause);\n\t\tCL22_RD_OVER_CL45(bp, phy,\n\t\t\t\t  MDIO_REG_BANK_CL73_IEEEB1,\n\t\t\t\t  MDIO_CL73_IEEEB1_AN_LP_ADV1,\n\t\t\t\t  &lp_pause);\n\t\tpause_result = (ld_pause &\n\t\t\t\tMDIO_CL73_IEEEB1_AN_ADV1_PAUSE_MASK) >> 8;\n\t\tpause_result |= (lp_pause &\n\t\t\t\t MDIO_CL73_IEEEB1_AN_LP_ADV1_PAUSE_MASK) >> 10;\n\t\tDP(NETIF_MSG_LINK, \"pause_result CL73 0x%x\\n\", pause_result);\n\t} else {\n\t\tCL22_RD_OVER_CL45(bp, phy,\n\t\t\t\t  MDIO_REG_BANK_COMBO_IEEE0,\n\t\t\t\t  MDIO_COMBO_IEEE0_AUTO_NEG_ADV,\n\t\t\t\t  &ld_pause);\n\t\tCL22_RD_OVER_CL45(bp, phy,\n\t\t\tMDIO_REG_BANK_COMBO_IEEE0,\n\t\t\tMDIO_COMBO_IEEE0_AUTO_NEG_LINK_PARTNER_ABILITY1,\n\t\t\t&lp_pause);\n\t\tpause_result = (ld_pause &\n\t\t\t\tMDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_MASK)>>5;\n\t\tpause_result |= (lp_pause &\n\t\t\t\t MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_MASK)>>7;\n\t\tDP(NETIF_MSG_LINK, \"pause_result CL37 0x%x\\n\", pause_result);\n\t}\n\tbnx2x_pause_resolve(phy, params, vars, pause_result);\n\n}\n\nstatic void bnx2x_flow_ctrl_resolve(struct bnx2x_phy *phy,\n\t\t\t\t    struct link_params *params,\n\t\t\t\t    struct link_vars *vars,\n\t\t\t\t    u32 gp_status)\n{\n\tstruct bnx2x *bp = params->bp;\n\tvars->flow_ctrl = BNX2X_FLOW_CTRL_NONE;\n\n\t \n\tif (phy->req_flow_ctrl != BNX2X_FLOW_CTRL_AUTO) {\n\t\t \n\t\tif (phy->req_line_speed == SPEED_AUTO_NEG)\n\t\t\tbnx2x_update_adv_fc(phy, params, vars, gp_status);\n\t\t \n\t\tvars->flow_ctrl = phy->req_flow_ctrl;\n\t} else if (phy->req_line_speed != SPEED_AUTO_NEG)\n\t\tvars->flow_ctrl = params->req_fc_auto_adv;\n\telse if ((gp_status & MDIO_AN_CL73_OR_37_COMPLETE) &&\n\t\t (!(vars->phy_flags & PHY_SGMII_FLAG))) {\n\t\tif (bnx2x_direct_parallel_detect_used(phy, params)) {\n\t\t\tvars->flow_ctrl = params->req_fc_auto_adv;\n\t\t\treturn;\n\t\t}\n\t\tbnx2x_update_adv_fc(phy, params, vars, gp_status);\n\t}\n\tDP(NETIF_MSG_LINK, \"flow_ctrl 0x%x\\n\", vars->flow_ctrl);\n}\n\nstatic void bnx2x_check_fallback_to_cl37(struct bnx2x_phy *phy,\n\t\t\t\t\t struct link_params *params)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu16 rx_status, ustat_val, cl37_fsm_received;\n\tDP(NETIF_MSG_LINK, \"bnx2x_check_fallback_to_cl37\\n\");\n\t \n\tCL22_RD_OVER_CL45(bp, phy,\n\t\t\t  MDIO_REG_BANK_RX0,\n\t\t\t  MDIO_RX0_RX_STATUS,\n\t\t\t  &rx_status);\n\tif ((rx_status & MDIO_RX0_RX_STATUS_SIGDET) !=\n\t    (MDIO_RX0_RX_STATUS_SIGDET)) {\n\t\tDP(NETIF_MSG_LINK, \"Signal is not detected. Restoring CL73.\"\n\t\t\t     \"rx_status(0x80b0) = 0x%x\\n\", rx_status);\n\t\tCL22_WR_OVER_CL45(bp, phy,\n\t\t\t\t  MDIO_REG_BANK_CL73_IEEEB0,\n\t\t\t\t  MDIO_CL73_IEEEB0_CL73_AN_CONTROL,\n\t\t\t\t  MDIO_CL73_IEEEB0_CL73_AN_CONTROL_AN_EN);\n\t\treturn;\n\t}\n\t \n\tCL22_RD_OVER_CL45(bp, phy,\n\t\t\t  MDIO_REG_BANK_CL73_USERB0,\n\t\t\t  MDIO_CL73_USERB0_CL73_USTAT1,\n\t\t\t  &ustat_val);\n\tif ((ustat_val &\n\t     (MDIO_CL73_USERB0_CL73_USTAT1_LINK_STATUS_CHECK |\n\t      MDIO_CL73_USERB0_CL73_USTAT1_AN_GOOD_CHECK_BAM37)) !=\n\t    (MDIO_CL73_USERB0_CL73_USTAT1_LINK_STATUS_CHECK |\n\t      MDIO_CL73_USERB0_CL73_USTAT1_AN_GOOD_CHECK_BAM37)) {\n\t\tDP(NETIF_MSG_LINK, \"CL73 state-machine is not stable. \"\n\t\t\t     \"ustat_val(0x8371) = 0x%x\\n\", ustat_val);\n\t\treturn;\n\t}\n\t \n\tCL22_RD_OVER_CL45(bp, phy,\n\t\t\t  MDIO_REG_BANK_REMOTE_PHY,\n\t\t\t  MDIO_REMOTE_PHY_MISC_RX_STATUS,\n\t\t\t  &cl37_fsm_received);\n\tif ((cl37_fsm_received &\n\t     (MDIO_REMOTE_PHY_MISC_RX_STATUS_CL37_FSM_RECEIVED_OVER1G_MSG |\n\t     MDIO_REMOTE_PHY_MISC_RX_STATUS_CL37_FSM_RECEIVED_BRCM_OUI_MSG)) !=\n\t    (MDIO_REMOTE_PHY_MISC_RX_STATUS_CL37_FSM_RECEIVED_OVER1G_MSG |\n\t      MDIO_REMOTE_PHY_MISC_RX_STATUS_CL37_FSM_RECEIVED_BRCM_OUI_MSG)) {\n\t\tDP(NETIF_MSG_LINK, \"No CL37 FSM were received. \"\n\t\t\t     \"misc_rx_status(0x8330) = 0x%x\\n\",\n\t\t\t cl37_fsm_received);\n\t\treturn;\n\t}\n\t \n\n\t \n\tCL22_WR_OVER_CL45(bp, phy,\n\t\t\t  MDIO_REG_BANK_CL73_IEEEB0,\n\t\t\t  MDIO_CL73_IEEEB0_CL73_AN_CONTROL,\n\t\t\t  0);\n\t \n\tbnx2x_restart_autoneg(phy, params, 0);\n\tDP(NETIF_MSG_LINK, \"Disabling CL73, and restarting CL37 autoneg\\n\");\n}\n\nstatic void bnx2x_xgxs_an_resolve(struct bnx2x_phy *phy,\n\t\t\t\t  struct link_params *params,\n\t\t\t\t  struct link_vars *vars,\n\t\t\t\t  u32 gp_status)\n{\n\tif (gp_status & MDIO_AN_CL73_OR_37_COMPLETE)\n\t\tvars->link_status |=\n\t\t\tLINK_STATUS_AUTO_NEGOTIATE_COMPLETE;\n\n\tif (bnx2x_direct_parallel_detect_used(phy, params))\n\t\tvars->link_status |=\n\t\t\tLINK_STATUS_PARALLEL_DETECTION_USED;\n}\nstatic int bnx2x_get_link_speed_duplex(struct bnx2x_phy *phy,\n\t\t\t\t     struct link_params *params,\n\t\t\t\t      struct link_vars *vars,\n\t\t\t\t      u16 is_link_up,\n\t\t\t\t      u16 speed_mask,\n\t\t\t\t      u16 is_duplex)\n{\n\tstruct bnx2x *bp = params->bp;\n\tif (phy->req_line_speed == SPEED_AUTO_NEG)\n\t\tvars->link_status |= LINK_STATUS_AUTO_NEGOTIATE_ENABLED;\n\tif (is_link_up) {\n\t\tDP(NETIF_MSG_LINK, \"phy link up\\n\");\n\n\t\tvars->phy_link_up = 1;\n\t\tvars->link_status |= LINK_STATUS_LINK_UP;\n\n\t\tswitch (speed_mask) {\n\t\tcase GP_STATUS_10M:\n\t\t\tvars->line_speed = SPEED_10;\n\t\t\tif (is_duplex == DUPLEX_FULL)\n\t\t\t\tvars->link_status |= LINK_10TFD;\n\t\t\telse\n\t\t\t\tvars->link_status |= LINK_10THD;\n\t\t\tbreak;\n\n\t\tcase GP_STATUS_100M:\n\t\t\tvars->line_speed = SPEED_100;\n\t\t\tif (is_duplex == DUPLEX_FULL)\n\t\t\t\tvars->link_status |= LINK_100TXFD;\n\t\t\telse\n\t\t\t\tvars->link_status |= LINK_100TXHD;\n\t\t\tbreak;\n\n\t\tcase GP_STATUS_1G:\n\t\tcase GP_STATUS_1G_KX:\n\t\t\tvars->line_speed = SPEED_1000;\n\t\t\tif (is_duplex == DUPLEX_FULL)\n\t\t\t\tvars->link_status |= LINK_1000TFD;\n\t\t\telse\n\t\t\t\tvars->link_status |= LINK_1000THD;\n\t\t\tbreak;\n\n\t\tcase GP_STATUS_2_5G:\n\t\t\tvars->line_speed = SPEED_2500;\n\t\t\tif (is_duplex == DUPLEX_FULL)\n\t\t\t\tvars->link_status |= LINK_2500TFD;\n\t\t\telse\n\t\t\t\tvars->link_status |= LINK_2500THD;\n\t\t\tbreak;\n\n\t\tcase GP_STATUS_5G:\n\t\tcase GP_STATUS_6G:\n\t\t\tDP(NETIF_MSG_LINK,\n\t\t\t\t \"link speed unsupported  gp_status 0x%x\\n\",\n\t\t\t\t  speed_mask);\n\t\t\treturn -EINVAL;\n\n\t\tcase GP_STATUS_10G_KX4:\n\t\tcase GP_STATUS_10G_HIG:\n\t\tcase GP_STATUS_10G_CX4:\n\t\tcase GP_STATUS_10G_KR:\n\t\tcase GP_STATUS_10G_SFI:\n\t\tcase GP_STATUS_10G_XFI:\n\t\t\tvars->line_speed = SPEED_10000;\n\t\t\tvars->link_status |= LINK_10GTFD;\n\t\t\tbreak;\n\t\tcase GP_STATUS_20G_DXGXS:\n\t\tcase GP_STATUS_20G_KR2:\n\t\t\tvars->line_speed = SPEED_20000;\n\t\t\tvars->link_status |= LINK_20GTFD;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDP(NETIF_MSG_LINK,\n\t\t\t\t  \"link speed unsupported gp_status 0x%x\\n\",\n\t\t\t\t  speed_mask);\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {  \n\t\tDP(NETIF_MSG_LINK, \"phy link down\\n\");\n\n\t\tvars->phy_link_up = 0;\n\n\t\tvars->duplex = DUPLEX_FULL;\n\t\tvars->flow_ctrl = BNX2X_FLOW_CTRL_NONE;\n\t\tvars->mac_type = MAC_TYPE_NONE;\n\t}\n\tDP(NETIF_MSG_LINK, \" phy_link_up %x line_speed %d\\n\",\n\t\t    vars->phy_link_up, vars->line_speed);\n\treturn 0;\n}\n\nstatic u8 bnx2x_link_settings_status(struct bnx2x_phy *phy,\n\t\t\t\t     struct link_params *params,\n\t\t\t\t     struct link_vars *vars)\n{\n\tstruct bnx2x *bp = params->bp;\n\n\tu16 gp_status, duplex = DUPLEX_HALF, link_up = 0, speed_mask;\n\tint rc = 0;\n\n\t \n\tCL22_RD_OVER_CL45(bp, phy,\n\t\t\t  MDIO_REG_BANK_GP_STATUS,\n\t\t\t  MDIO_GP_STATUS_TOP_AN_STATUS1,\n\t\t\t  &gp_status);\n\tif (gp_status & MDIO_GP_STATUS_TOP_AN_STATUS1_DUPLEX_STATUS)\n\t\tduplex = DUPLEX_FULL;\n\tif (gp_status & MDIO_GP_STATUS_TOP_AN_STATUS1_LINK_STATUS)\n\t\tlink_up = 1;\n\tspeed_mask = gp_status & GP_STATUS_SPEED_MASK;\n\tDP(NETIF_MSG_LINK, \"gp_status 0x%x, is_link_up %d, speed_mask 0x%x\\n\",\n\t\t       gp_status, link_up, speed_mask);\n\trc = bnx2x_get_link_speed_duplex(phy, params, vars, link_up, speed_mask,\n\t\t\t\t\t duplex);\n\tif (rc == -EINVAL)\n\t\treturn rc;\n\n\tif (gp_status & MDIO_GP_STATUS_TOP_AN_STATUS1_LINK_STATUS) {\n\t\tif (SINGLE_MEDIA_DIRECT(params)) {\n\t\t\tvars->duplex = duplex;\n\t\t\tbnx2x_flow_ctrl_resolve(phy, params, vars, gp_status);\n\t\t\tif (phy->req_line_speed == SPEED_AUTO_NEG)\n\t\t\t\tbnx2x_xgxs_an_resolve(phy, params, vars,\n\t\t\t\t\t\t      gp_status);\n\t\t}\n\t} else {  \n\t\tif ((phy->req_line_speed == SPEED_AUTO_NEG) &&\n\t\t    SINGLE_MEDIA_DIRECT(params)) {\n\t\t\t \n\t\t\tbnx2x_check_fallback_to_cl37(phy, params);\n\t\t}\n\t}\n\n\t \n\tif (SINGLE_MEDIA_DIRECT(params) &&\n\t    (vars->link_status & LINK_STATUS_AUTO_NEGOTIATE_COMPLETE)) {\n\t\tu16 val;\n\n\t\tCL22_RD_OVER_CL45(bp, phy, MDIO_REG_BANK_CL73_IEEEB1,\n\t\t\t\t  MDIO_CL73_IEEEB1_AN_LP_ADV2, &val);\n\n\t\tif (val & MDIO_CL73_IEEEB1_AN_ADV2_ADVR_1000M_KX)\n\t\t\tvars->link_status |=\n\t\t\t\tLINK_STATUS_LINK_PARTNER_1000TFD_CAPABLE;\n\t\tif (val & (MDIO_CL73_IEEEB1_AN_ADV2_ADVR_10G_KX4 |\n\t\t\t   MDIO_CL73_IEEEB1_AN_ADV2_ADVR_10G_KR))\n\t\t\tvars->link_status |=\n\t\t\t\tLINK_STATUS_LINK_PARTNER_10GXFD_CAPABLE;\n\n\t\tCL22_RD_OVER_CL45(bp, phy, MDIO_REG_BANK_OVER_1G,\n\t\t\t\t  MDIO_OVER_1G_LP_UP1, &val);\n\n\t\tif (val & MDIO_OVER_1G_UP1_2_5G)\n\t\t\tvars->link_status |=\n\t\t\t\tLINK_STATUS_LINK_PARTNER_2500XFD_CAPABLE;\n\t\tif (val & (MDIO_OVER_1G_UP1_10G | MDIO_OVER_1G_UP1_10GH))\n\t\t\tvars->link_status |=\n\t\t\t\tLINK_STATUS_LINK_PARTNER_10GXFD_CAPABLE;\n\t}\n\n\tDP(NETIF_MSG_LINK, \"duplex %x  flow_ctrl 0x%x link_status 0x%x\\n\",\n\t\t   vars->duplex, vars->flow_ctrl, vars->link_status);\n\treturn rc;\n}\n\nstatic u8 bnx2x_warpcore_read_status(struct bnx2x_phy *phy,\n\t\t\t\t     struct link_params *params,\n\t\t\t\t     struct link_vars *vars)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu8 lane;\n\tu16 gp_status1, gp_speed, link_up, duplex = DUPLEX_FULL;\n\tint rc = 0;\n\tlane = bnx2x_get_warpcore_lane(phy, params);\n\t \n\tif ((params->loopback_mode) &&\n\t    (phy->flags & FLAGS_WC_DUAL_MODE)) {\n\t\tbnx2x_cl45_read(bp, phy, MDIO_WC_DEVAD,\n\t\t\t\tMDIO_WC_REG_DIGITAL5_LINK_STATUS, &link_up);\n\t\tbnx2x_cl45_read(bp, phy, MDIO_WC_DEVAD,\n\t\t\t\tMDIO_WC_REG_DIGITAL5_LINK_STATUS, &link_up);\n\t\tlink_up &= 0x1;\n\t} else if ((phy->req_line_speed > SPEED_10000) &&\n\t\t(phy->supported & SUPPORTED_20000baseMLD2_Full)) {\n\t\tu16 temp_link_up;\n\t\tbnx2x_cl45_read(bp, phy, MDIO_WC_DEVAD,\n\t\t\t\t1, &temp_link_up);\n\t\tbnx2x_cl45_read(bp, phy, MDIO_WC_DEVAD,\n\t\t\t\t1, &link_up);\n\t\tDP(NETIF_MSG_LINK, \"PCS RX link status = 0x%x-->0x%x\\n\",\n\t\t\t       temp_link_up, link_up);\n\t\tlink_up &= (1<<2);\n\t\tif (link_up)\n\t\t\tbnx2x_ext_phy_resolve_fc(phy, params, vars);\n\t} else {\n\t\tbnx2x_cl45_read(bp, phy, MDIO_WC_DEVAD,\n\t\t\t\tMDIO_WC_REG_GP2_STATUS_GP_2_1,\n\t\t\t\t&gp_status1);\n\t\tDP(NETIF_MSG_LINK, \"0x81d1 = 0x%x\\n\", gp_status1);\n\t\t \n\t\tlink_up = ((gp_status1 >> 8) |\n\t\t\t   (gp_status1 >> 12) |\n\t\t\t   (gp_status1)) &\n\t\t\t(1 << lane);\n\t\tif (phy->supported & SUPPORTED_20000baseKR2_Full) {\n\t\t\tu16 an_link;\n\t\t\tbnx2x_cl45_read(bp, phy, MDIO_AN_DEVAD,\n\t\t\t\t\tMDIO_AN_REG_STATUS, &an_link);\n\t\t\tbnx2x_cl45_read(bp, phy, MDIO_AN_DEVAD,\n\t\t\t\t\tMDIO_AN_REG_STATUS, &an_link);\n\t\t\tlink_up |= (an_link & (1<<2));\n\t\t}\n\t\tif (link_up && SINGLE_MEDIA_DIRECT(params)) {\n\t\t\tu16 pd, gp_status4;\n\t\t\tif (phy->req_line_speed == SPEED_AUTO_NEG) {\n\t\t\t\t \n\t\t\t\tbnx2x_cl45_read(bp, phy, MDIO_WC_DEVAD,\n\t\t\t\t\t\tMDIO_WC_REG_GP2_STATUS_GP_2_4,\n\t\t\t\t\t\t&gp_status4);\n\t\t\t\tif (gp_status4 & ((1<<12)<<lane))\n\t\t\t\t\tvars->link_status |=\n\t\t\t\t\tLINK_STATUS_AUTO_NEGOTIATE_COMPLETE;\n\n\t\t\t\t \n\t\t\t\tbnx2x_cl45_read(bp, phy, MDIO_WC_DEVAD,\n\t\t\t\t\t\tMDIO_WC_REG_PAR_DET_10G_STATUS,\n\t\t\t\t\t\t&pd);\n\t\t\t\tif (pd & (1<<15))\n\t\t\t\t\tvars->link_status |=\n\t\t\t\t\tLINK_STATUS_PARALLEL_DETECTION_USED;\n\t\t\t}\n\t\t\tbnx2x_ext_phy_resolve_fc(phy, params, vars);\n\t\t\tvars->duplex = duplex;\n\t\t}\n\t}\n\n\tif ((vars->link_status & LINK_STATUS_AUTO_NEGOTIATE_COMPLETE) &&\n\t    SINGLE_MEDIA_DIRECT(params)) {\n\t\tu16 val;\n\n\t\tbnx2x_cl45_read(bp, phy, MDIO_AN_DEVAD,\n\t\t\t\tMDIO_AN_REG_LP_AUTO_NEG2, &val);\n\n\t\tif (val & MDIO_CL73_IEEEB1_AN_ADV2_ADVR_1000M_KX)\n\t\t\tvars->link_status |=\n\t\t\t\tLINK_STATUS_LINK_PARTNER_1000TFD_CAPABLE;\n\t\tif (val & (MDIO_CL73_IEEEB1_AN_ADV2_ADVR_10G_KX4 |\n\t\t\t   MDIO_CL73_IEEEB1_AN_ADV2_ADVR_10G_KR))\n\t\t\tvars->link_status |=\n\t\t\t\tLINK_STATUS_LINK_PARTNER_10GXFD_CAPABLE;\n\n\t\tbnx2x_cl45_read(bp, phy, MDIO_WC_DEVAD,\n\t\t\t\tMDIO_WC_REG_DIGITAL3_LP_UP1, &val);\n\n\t\tif (val & MDIO_OVER_1G_UP1_2_5G)\n\t\t\tvars->link_status |=\n\t\t\t\tLINK_STATUS_LINK_PARTNER_2500XFD_CAPABLE;\n\t\tif (val & (MDIO_OVER_1G_UP1_10G | MDIO_OVER_1G_UP1_10GH))\n\t\t\tvars->link_status |=\n\t\t\t\tLINK_STATUS_LINK_PARTNER_10GXFD_CAPABLE;\n\n\t}\n\n\n\tif (lane < 2) {\n\t\tbnx2x_cl45_read(bp, phy, MDIO_WC_DEVAD,\n\t\t\t\tMDIO_WC_REG_GP2_STATUS_GP_2_2, &gp_speed);\n\t} else {\n\t\tbnx2x_cl45_read(bp, phy, MDIO_WC_DEVAD,\n\t\t\t\tMDIO_WC_REG_GP2_STATUS_GP_2_3, &gp_speed);\n\t}\n\tDP(NETIF_MSG_LINK, \"lane %d gp_speed 0x%x\\n\", lane, gp_speed);\n\n\tif ((lane & 1) == 0)\n\t\tgp_speed <<= 8;\n\tgp_speed &= 0x3f00;\n\tlink_up = !!link_up;\n\n\trc = bnx2x_get_link_speed_duplex(phy, params, vars, link_up, gp_speed,\n\t\t\t\t\t duplex);\n\n\t \n\tif ((!link_up) && (phy->media_type == ETH_PHY_KR) &&\n\t    (!(phy->flags & FLAGS_WC_DUAL_MODE)))\n\t\tvars->rx_tx_asic_rst = MAX_KR_LINK_RETRY;\n\n\tDP(NETIF_MSG_LINK, \"duplex %x  flow_ctrl 0x%x link_status 0x%x\\n\",\n\t\t   vars->duplex, vars->flow_ctrl, vars->link_status);\n\treturn rc;\n}\nstatic void bnx2x_set_gmii_tx_driver(struct link_params *params)\n{\n\tstruct bnx2x *bp = params->bp;\n\tstruct bnx2x_phy *phy = &params->phy[INT_PHY];\n\tu16 lp_up2;\n\tu16 tx_driver;\n\tu16 bank;\n\n\t \n\tCL22_RD_OVER_CL45(bp, phy,\n\t\t\t  MDIO_REG_BANK_OVER_1G,\n\t\t\t  MDIO_OVER_1G_LP_UP2, &lp_up2);\n\n\t \n\tlp_up2 = (((lp_up2 & MDIO_OVER_1G_LP_UP2_PREEMPHASIS_MASK) >>\n\t\t   MDIO_OVER_1G_LP_UP2_PREEMPHASIS_SHIFT) <<\n\t\t  MDIO_TX0_TX_DRIVER_PREEMPHASIS_SHIFT);\n\n\tif (lp_up2 == 0)\n\t\treturn;\n\n\tfor (bank = MDIO_REG_BANK_TX0; bank <= MDIO_REG_BANK_TX3;\n\t      bank += (MDIO_REG_BANK_TX1 - MDIO_REG_BANK_TX0)) {\n\t\tCL22_RD_OVER_CL45(bp, phy,\n\t\t\t\t  bank,\n\t\t\t\t  MDIO_TX0_TX_DRIVER, &tx_driver);\n\n\t\t \n\t\tif (lp_up2 !=\n\t\t    (tx_driver & MDIO_TX0_TX_DRIVER_PREEMPHASIS_MASK)) {\n\t\t\ttx_driver &= ~MDIO_TX0_TX_DRIVER_PREEMPHASIS_MASK;\n\t\t\ttx_driver |= lp_up2;\n\t\t\tCL22_WR_OVER_CL45(bp, phy,\n\t\t\t\t\t  bank,\n\t\t\t\t\t  MDIO_TX0_TX_DRIVER, tx_driver);\n\t\t}\n\t}\n}\n\nstatic int bnx2x_emac_program(struct link_params *params,\n\t\t\t      struct link_vars *vars)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu8 port = params->port;\n\tu16 mode = 0;\n\n\tDP(NETIF_MSG_LINK, \"setting link speed & duplex\\n\");\n\tbnx2x_bits_dis(bp, GRCBASE_EMAC0 + port*0x400 +\n\t\t       EMAC_REG_EMAC_MODE,\n\t\t       (EMAC_MODE_25G_MODE |\n\t\t\tEMAC_MODE_PORT_MII_10M |\n\t\t\tEMAC_MODE_HALF_DUPLEX));\n\tswitch (vars->line_speed) {\n\tcase SPEED_10:\n\t\tmode |= EMAC_MODE_PORT_MII_10M;\n\t\tbreak;\n\n\tcase SPEED_100:\n\t\tmode |= EMAC_MODE_PORT_MII;\n\t\tbreak;\n\n\tcase SPEED_1000:\n\t\tmode |= EMAC_MODE_PORT_GMII;\n\t\tbreak;\n\n\tcase SPEED_2500:\n\t\tmode |= (EMAC_MODE_25G_MODE | EMAC_MODE_PORT_GMII);\n\t\tbreak;\n\n\tdefault:\n\t\t \n\t\tDP(NETIF_MSG_LINK, \"Invalid line_speed 0x%x\\n\",\n\t\t\t   vars->line_speed);\n\t\treturn -EINVAL;\n\t}\n\n\tif (vars->duplex == DUPLEX_HALF)\n\t\tmode |= EMAC_MODE_HALF_DUPLEX;\n\tbnx2x_bits_en(bp,\n\t\t      GRCBASE_EMAC0 + port*0x400 + EMAC_REG_EMAC_MODE,\n\t\t      mode);\n\n\tbnx2x_set_led(params, vars, LED_MODE_OPER, vars->line_speed);\n\treturn 0;\n}\n\nstatic void bnx2x_set_preemphasis(struct bnx2x_phy *phy,\n\t\t\t\t  struct link_params *params)\n{\n\n\tu16 bank, i = 0;\n\tstruct bnx2x *bp = params->bp;\n\n\tfor (bank = MDIO_REG_BANK_RX0, i = 0; bank <= MDIO_REG_BANK_RX3;\n\t      bank += (MDIO_REG_BANK_RX1-MDIO_REG_BANK_RX0), i++) {\n\t\t\tCL22_WR_OVER_CL45(bp, phy,\n\t\t\t\t\t  bank,\n\t\t\t\t\t  MDIO_RX0_RX_EQ_BOOST,\n\t\t\t\t\t  phy->rx_preemphasis[i]);\n\t}\n\n\tfor (bank = MDIO_REG_BANK_TX0, i = 0; bank <= MDIO_REG_BANK_TX3;\n\t\t      bank += (MDIO_REG_BANK_TX1 - MDIO_REG_BANK_TX0), i++) {\n\t\t\tCL22_WR_OVER_CL45(bp, phy,\n\t\t\t\t\t  bank,\n\t\t\t\t\t  MDIO_TX0_TX_DRIVER,\n\t\t\t\t\t  phy->tx_preemphasis[i]);\n\t}\n}\n\nstatic void bnx2x_xgxs_config_init(struct bnx2x_phy *phy,\n\t\t\t\t   struct link_params *params,\n\t\t\t\t   struct link_vars *vars)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu8 enable_cl73 = (SINGLE_MEDIA_DIRECT(params) ||\n\t\t\t  (params->loopback_mode == LOOPBACK_XGXS));\n\tif (!(vars->phy_flags & PHY_SGMII_FLAG)) {\n\t\tif (SINGLE_MEDIA_DIRECT(params) &&\n\t\t    (params->feature_config_flags &\n\t\t     FEATURE_CONFIG_OVERRIDE_PREEMPHASIS_ENABLED))\n\t\t\tbnx2x_set_preemphasis(phy, params);\n\n\t\t \n\t\tif (vars->line_speed != SPEED_AUTO_NEG ||\n\t\t    (SINGLE_MEDIA_DIRECT(params) &&\n\t\t     params->loopback_mode == LOOPBACK_EXT)) {\n\t\t\tDP(NETIF_MSG_LINK, \"not SGMII, no AN\\n\");\n\n\t\t\t \n\t\t\tbnx2x_set_autoneg(phy, params, vars, 0);\n\n\t\t\t \n\t\t\tbnx2x_program_serdes(phy, params, vars);\n\n\t\t} else {  \n\t\t\tDP(NETIF_MSG_LINK, \"not SGMII, AN\\n\");\n\n\t\t\t \n\t\t\tbnx2x_set_brcm_cl37_advertisement(phy, params);\n\n\t\t\t \n\t\t\tbnx2x_set_ieee_aneg_advertisement(phy, params,\n\t\t\t\t\t\t\t  vars->ieee_fc);\n\n\t\t\t \n\t\t\tbnx2x_set_autoneg(phy, params, vars, enable_cl73);\n\n\t\t\t \n\t\t\tbnx2x_restart_autoneg(phy, params, enable_cl73);\n\t\t}\n\n\t} else {  \n\t\tDP(NETIF_MSG_LINK, \"SGMII\\n\");\n\n\t\tbnx2x_initialize_sgmii_process(phy, params, vars);\n\t}\n}\n\nstatic int bnx2x_prepare_xgxs(struct bnx2x_phy *phy,\n\t\t\t  struct link_params *params,\n\t\t\t  struct link_vars *vars)\n{\n\tint rc;\n\tvars->phy_flags |= PHY_XGXS_FLAG;\n\tif ((phy->req_line_speed &&\n\t     ((phy->req_line_speed == SPEED_100) ||\n\t      (phy->req_line_speed == SPEED_10))) ||\n\t    (!phy->req_line_speed &&\n\t     (phy->speed_cap_mask >=\n\t      PORT_HW_CFG_SPEED_CAPABILITY_D0_10M_FULL) &&\n\t     (phy->speed_cap_mask <\n\t      PORT_HW_CFG_SPEED_CAPABILITY_D0_1G)) ||\n\t    (phy->type == PORT_HW_CFG_SERDES_EXT_PHY_TYPE_DIRECT_SD))\n\t\tvars->phy_flags |= PHY_SGMII_FLAG;\n\telse\n\t\tvars->phy_flags &= ~PHY_SGMII_FLAG;\n\n\tbnx2x_calc_ieee_aneg_adv(phy, params, &vars->ieee_fc);\n\tbnx2x_set_aer_mmd(params, phy);\n\tif (phy->type == PORT_HW_CFG_XGXS_EXT_PHY_TYPE_DIRECT)\n\t\tbnx2x_set_master_ln(params, phy);\n\n\trc = bnx2x_reset_unicore(params, phy, 0);\n\t \n\tif (rc)\n\t\treturn rc;\n\n\tbnx2x_set_aer_mmd(params, phy);\n\t \n\tif (phy->type == PORT_HW_CFG_XGXS_EXT_PHY_TYPE_DIRECT) {\n\t\tbnx2x_set_master_ln(params, phy);\n\t\tbnx2x_set_swap_lanes(params, phy);\n\t}\n\n\treturn rc;\n}\n\nstatic u16 bnx2x_wait_reset_complete(struct bnx2x *bp,\n\t\t\t\t     struct bnx2x_phy *phy,\n\t\t\t\t     struct link_params *params)\n{\n\tu16 cnt, ctrl;\n\t \n\tfor (cnt = 0; cnt < 1000; cnt++) {\n\t\tif (phy->type == PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM54618SE)\n\t\t\tbnx2x_cl22_read(bp, phy,\n\t\t\t\tMDIO_PMA_REG_CTRL, &ctrl);\n\t\telse\n\t\t\tbnx2x_cl45_read(bp, phy,\n\t\t\t\tMDIO_PMA_DEVAD,\n\t\t\t\tMDIO_PMA_REG_CTRL, &ctrl);\n\t\tif (!(ctrl & (1<<15)))\n\t\t\tbreak;\n\t\tusleep_range(1000, 2000);\n\t}\n\n\tif (cnt == 1000)\n\t\tnetdev_err(bp->dev,  \"Warning: PHY was not initialized,\"\n\t\t\t\t      \" Port %d\\n\",\n\t\t\t params->port);\n\tDP(NETIF_MSG_LINK, \"control reg 0x%x (after %d ms)\\n\", ctrl, cnt);\n\treturn cnt;\n}\n\nstatic void bnx2x_link_int_enable(struct link_params *params)\n{\n\tu8 port = params->port;\n\tu32 mask;\n\tstruct bnx2x *bp = params->bp;\n\n\t \n\tif (CHIP_IS_E3(bp)) {\n\t\tmask = NIG_MASK_XGXS0_LINK_STATUS;\n\t\tif (!(SINGLE_MEDIA_DIRECT(params)))\n\t\t\tmask |= NIG_MASK_MI_INT;\n\t} else if (params->switch_cfg == SWITCH_CFG_10G) {\n\t\tmask = (NIG_MASK_XGXS0_LINK10G |\n\t\t\tNIG_MASK_XGXS0_LINK_STATUS);\n\t\tDP(NETIF_MSG_LINK, \"enabled XGXS interrupt\\n\");\n\t\tif (!(SINGLE_MEDIA_DIRECT(params)) &&\n\t\t\tparams->phy[INT_PHY].type !=\n\t\t\t\tPORT_HW_CFG_XGXS_EXT_PHY_TYPE_FAILURE) {\n\t\t\tmask |= NIG_MASK_MI_INT;\n\t\t\tDP(NETIF_MSG_LINK, \"enabled external phy int\\n\");\n\t\t}\n\n\t} else {  \n\t\tmask = NIG_MASK_SERDES0_LINK_STATUS;\n\t\tDP(NETIF_MSG_LINK, \"enabled SerDes interrupt\\n\");\n\t\tif (!(SINGLE_MEDIA_DIRECT(params)) &&\n\t\t\tparams->phy[INT_PHY].type !=\n\t\t\t\tPORT_HW_CFG_SERDES_EXT_PHY_TYPE_NOT_CONN) {\n\t\t\tmask |= NIG_MASK_MI_INT;\n\t\t\tDP(NETIF_MSG_LINK, \"enabled external phy int\\n\");\n\t\t}\n\t}\n\tbnx2x_bits_en(bp,\n\t\t      NIG_REG_MASK_INTERRUPT_PORT0 + port*4,\n\t\t      mask);\n\n\tDP(NETIF_MSG_LINK, \"port %x, is_xgxs %x, int_status 0x%x\\n\", port,\n\t\t (params->switch_cfg == SWITCH_CFG_10G),\n\t\t REG_RD(bp, NIG_REG_STATUS_INTERRUPT_PORT0 + port*4));\n\tDP(NETIF_MSG_LINK, \" int_mask 0x%x, MI_INT %x, SERDES_LINK %x\\n\",\n\t\t REG_RD(bp, NIG_REG_MASK_INTERRUPT_PORT0 + port*4),\n\t\t REG_RD(bp, NIG_REG_EMAC0_STATUS_MISC_MI_INT + port*0x18),\n\t\t REG_RD(bp, NIG_REG_SERDES0_STATUS_LINK_STATUS+port*0x3c));\n\tDP(NETIF_MSG_LINK, \" 10G %x, XGXS_LINK %x\\n\",\n\t   REG_RD(bp, NIG_REG_XGXS0_STATUS_LINK10G + port*0x68),\n\t   REG_RD(bp, NIG_REG_XGXS0_STATUS_LINK_STATUS + port*0x68));\n}\n\nstatic void bnx2x_rearm_latch_signal(struct bnx2x *bp, u8 port,\n\t\t\t\t     u8 exp_mi_int)\n{\n\tu32 latch_status = 0;\n\n\t \n\t \n\tlatch_status = REG_RD(bp,\n\t\t\t\t    NIG_REG_LATCH_STATUS_0 + port*8);\n\tDP(NETIF_MSG_LINK, \"latch_status = 0x%x\\n\", latch_status);\n\t \n\tif (exp_mi_int)\n\t\tbnx2x_bits_en(bp,\n\t\t\t      NIG_REG_STATUS_INTERRUPT_PORT0\n\t\t\t      + port*4,\n\t\t\t      NIG_STATUS_EMAC0_MI_INT);\n\telse\n\t\tbnx2x_bits_dis(bp,\n\t\t\t       NIG_REG_STATUS_INTERRUPT_PORT0\n\t\t\t       + port*4,\n\t\t\t       NIG_STATUS_EMAC0_MI_INT);\n\n\tif (latch_status & 1) {\n\n\t\t \n\t\tREG_WR(bp, NIG_REG_LATCH_STATUS_0 + port*8,\n\t\t       (latch_status & 0xfffe) | (latch_status & 1));\n\t}\n\t \n}\n\nstatic void bnx2x_link_int_ack(struct link_params *params,\n\t\t\t       struct link_vars *vars, u8 is_10g_plus)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu8 port = params->port;\n\tu32 mask;\n\t \n\tbnx2x_bits_dis(bp, NIG_REG_STATUS_INTERRUPT_PORT0 + port*4,\n\t\t       (NIG_STATUS_XGXS0_LINK10G |\n\t\t\tNIG_STATUS_XGXS0_LINK_STATUS |\n\t\t\tNIG_STATUS_SERDES0_LINK_STATUS));\n\tif (vars->phy_link_up) {\n\t\tif (USES_WARPCORE(bp))\n\t\t\tmask = NIG_STATUS_XGXS0_LINK_STATUS;\n\t\telse {\n\t\t\tif (is_10g_plus)\n\t\t\t\tmask = NIG_STATUS_XGXS0_LINK10G;\n\t\t\telse if (params->switch_cfg == SWITCH_CFG_10G) {\n\t\t\t\t \n\t\t\t\tu32 ser_lane =\n\t\t\t\t\t((params->lane_config &\n\t\t\t\t    PORT_HW_CFG_LANE_SWAP_CFG_MASTER_MASK) >>\n\t\t\t\t    PORT_HW_CFG_LANE_SWAP_CFG_MASTER_SHIFT);\n\t\t\t\tmask = ((1 << ser_lane) <<\n\t\t\t\t       NIG_STATUS_XGXS0_LINK_STATUS_SIZE);\n\t\t\t} else\n\t\t\t\tmask = NIG_STATUS_SERDES0_LINK_STATUS;\n\t\t}\n\t\tDP(NETIF_MSG_LINK, \"Ack link up interrupt with mask 0x%x\\n\",\n\t\t\t       mask);\n\t\tbnx2x_bits_en(bp,\n\t\t\t      NIG_REG_STATUS_INTERRUPT_PORT0 + port*4,\n\t\t\t      mask);\n\t}\n}\n\nstatic int bnx2x_null_format_ver(u32 spirom_ver, u8 *str, u16 *len)\n{\n\tstr[0] = '\\0';\n\t(*len)--;\n\treturn 0;\n}\n\nstatic int bnx2x_format_ver(u32 num, u8 *str, u16 *len)\n{\n\tu16 ret;\n\n\tif (*len < 10) {\n\t\t \n\t\tbnx2x_null_format_ver(num, str, len);\n\t\treturn -EINVAL;\n\t}\n\n\tret = scnprintf(str, *len, \"%x.%x\", (num >> 16) & 0xFFFF,\n\t\t\tnum & 0xFFFF);\n\t*len -= ret;\n\treturn 0;\n}\n\nstatic int bnx2x_3_seq_format_ver(u32 num, u8 *str, u16 *len)\n{\n\tu16 ret;\n\n\tif (*len < 10) {\n\t\t \n\t\tbnx2x_null_format_ver(num, str, len);\n\t\treturn -EINVAL;\n\t}\n\n\tret = scnprintf(str, *len, \"%x.%x.%x\", (num >> 16) & 0xFF,\n\t\t\t(num >> 8) & 0xFF, num & 0xFF);\n\t*len -= ret;\n\treturn 0;\n}\n\nint bnx2x_get_ext_phy_fw_version(struct link_params *params, u8 *version,\n\t\t\t\t u16 len)\n{\n\tstruct bnx2x *bp;\n\tu32 spirom_ver = 0;\n\tint status = 0;\n\tu8 *ver_p = version;\n\tu16 remain_len = len;\n\tif (version == NULL || params == NULL)\n\t\treturn -EINVAL;\n\tbp = params->bp;\n\n\t \n\tversion[0] = '\\0';\n\tspirom_ver = REG_RD(bp, params->phy[EXT_PHY1].ver_addr);\n\n\tif (params->phy[EXT_PHY1].format_fw_ver) {\n\t\tstatus |= params->phy[EXT_PHY1].format_fw_ver(spirom_ver,\n\t\t\t\t\t\t\t      ver_p,\n\t\t\t\t\t\t\t      &remain_len);\n\t\tver_p += (len - remain_len);\n\t}\n\tif ((params->num_phys == MAX_PHYS) &&\n\t    (params->phy[EXT_PHY2].ver_addr != 0)) {\n\t\tspirom_ver = REG_RD(bp, params->phy[EXT_PHY2].ver_addr);\n\t\tif (params->phy[EXT_PHY2].format_fw_ver) {\n\t\t\t*ver_p = '/';\n\t\t\tver_p++;\n\t\t\tremain_len--;\n\t\t\tstatus |= params->phy[EXT_PHY2].format_fw_ver(\n\t\t\t\tspirom_ver,\n\t\t\t\tver_p,\n\t\t\t\t&remain_len);\n\t\t\tver_p = version + (len - remain_len);\n\t\t}\n\t}\n\t*ver_p = '\\0';\n\treturn status;\n}\n\nstatic void bnx2x_set_xgxs_loopback(struct bnx2x_phy *phy,\n\t\t\t\t    struct link_params *params)\n{\n\tu8 port = params->port;\n\tstruct bnx2x *bp = params->bp;\n\n\tif (phy->req_line_speed != SPEED_1000) {\n\t\tu32 md_devad = 0;\n\n\t\tDP(NETIF_MSG_LINK, \"XGXS 10G loopback enable\\n\");\n\n\t\tif (!CHIP_IS_E3(bp)) {\n\t\t\t \n\t\t\tmd_devad = REG_RD(bp, (NIG_REG_XGXS0_CTRL_MD_DEVAD +\n\t\t\t\t\t       port*0x18));\n\n\t\t\tREG_WR(bp, NIG_REG_XGXS0_CTRL_MD_DEVAD + port*0x18,\n\t\t\t       0x5);\n\t\t}\n\n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t 5,\n\t\t\t\t (MDIO_REG_BANK_AER_BLOCK +\n\t\t\t\t  (MDIO_AER_BLOCK_AER_REG & 0xf)),\n\t\t\t\t 0x2800);\n\n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t 5,\n\t\t\t\t (MDIO_REG_BANK_CL73_IEEEB0 +\n\t\t\t\t  (MDIO_CL73_IEEEB0_CL73_AN_CONTROL & 0xf)),\n\t\t\t\t 0x6041);\n\t\tmsleep(200);\n\t\t \n\t\tbnx2x_set_aer_mmd(params, phy);\n\n\t\tif (!CHIP_IS_E3(bp)) {\n\t\t\t \n\t\t\tREG_WR(bp, NIG_REG_XGXS0_CTRL_MD_DEVAD + port*0x18,\n\t\t\t       md_devad);\n\t\t}\n\t} else {\n\t\tu16 mii_ctrl;\n\t\tDP(NETIF_MSG_LINK, \"XGXS 1G loopback enable\\n\");\n\t\tbnx2x_cl45_read(bp, phy, 5,\n\t\t\t\t(MDIO_REG_BANK_COMBO_IEEE0 +\n\t\t\t\t(MDIO_COMBO_IEEE0_MII_CONTROL & 0xf)),\n\t\t\t\t&mii_ctrl);\n\t\tbnx2x_cl45_write(bp, phy, 5,\n\t\t\t\t (MDIO_REG_BANK_COMBO_IEEE0 +\n\t\t\t\t (MDIO_COMBO_IEEE0_MII_CONTROL & 0xf)),\n\t\t\t\t mii_ctrl |\n\t\t\t\t MDIO_COMBO_IEEO_MII_CONTROL_LOOPBACK);\n\t}\n}\n\nint bnx2x_set_led(struct link_params *params,\n\t\t  struct link_vars *vars, u8 mode, u32 speed)\n{\n\tu8 port = params->port;\n\tu16 hw_led_mode = params->hw_led_mode;\n\tint rc = 0;\n\tu8 phy_idx;\n\tu32 tmp;\n\tu32 emac_base = port ? GRCBASE_EMAC1 : GRCBASE_EMAC0;\n\tstruct bnx2x *bp = params->bp;\n\tDP(NETIF_MSG_LINK, \"bnx2x_set_led: port %x, mode %d\\n\", port, mode);\n\tDP(NETIF_MSG_LINK, \"speed 0x%x, hw_led_mode 0x%x\\n\",\n\t\t speed, hw_led_mode);\n\t \n\tfor (phy_idx = EXT_PHY1; phy_idx < MAX_PHYS; phy_idx++) {\n\t\tif (params->phy[phy_idx].set_link_led) {\n\t\t\tparams->phy[phy_idx].set_link_led(\n\t\t\t\t&params->phy[phy_idx], params, mode);\n\t\t}\n\t}\n\n\tswitch (mode) {\n\tcase LED_MODE_FRONT_PANEL_OFF:\n\tcase LED_MODE_OFF:\n\t\tREG_WR(bp, NIG_REG_LED_10G_P0 + port*4, 0);\n\t\tREG_WR(bp, NIG_REG_LED_MODE_P0 + port*4,\n\t\t       SHARED_HW_CFG_LED_MAC1);\n\n\t\ttmp = EMAC_RD(bp, EMAC_REG_EMAC_LED);\n\t\tif (params->phy[EXT_PHY1].type ==\n\t\t\tPORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM54618SE)\n\t\t\ttmp &= ~(EMAC_LED_1000MB_OVERRIDE |\n\t\t\t\tEMAC_LED_100MB_OVERRIDE |\n\t\t\t\tEMAC_LED_10MB_OVERRIDE);\n\t\telse\n\t\t\ttmp |= EMAC_LED_OVERRIDE;\n\n\t\tEMAC_WR(bp, EMAC_REG_EMAC_LED, tmp);\n\t\tbreak;\n\n\tcase LED_MODE_OPER:\n\t\t \n\t\tif (!vars->link_up)\n\t\t\tbreak;\n\t\tfallthrough;\n\tcase LED_MODE_ON:\n\t\tif (((params->phy[EXT_PHY1].type ==\n\t\t\t  PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8727) ||\n\t\t\t (params->phy[EXT_PHY1].type ==\n\t\t\t  PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8722)) &&\n\t\t    CHIP_IS_E2(bp) && params->num_phys == 2) {\n\t\t\t \n\t\t\tif (mode == LED_MODE_ON ||\n\t\t\t\tspeed == SPEED_10000){\n\t\t\t\tREG_WR(bp, NIG_REG_LED_MODE_P0 + port*4, 0);\n\t\t\t\tREG_WR(bp, NIG_REG_LED_10G_P0 + port*4, 1);\n\n\t\t\t\ttmp = EMAC_RD(bp, EMAC_REG_EMAC_LED);\n\t\t\t\tEMAC_WR(bp, EMAC_REG_EMAC_LED,\n\t\t\t\t\t(tmp | EMAC_LED_OVERRIDE));\n\t\t\t\t \n\t\t\t\tif (mode == LED_MODE_ON)\n\t\t\t\t\treturn rc;\n\t\t\t}\n\t\t} else if (SINGLE_MEDIA_DIRECT(params)) {\n\t\t\t \n\t\t\tif ((!CHIP_IS_E3(bp)) ||\n\t\t\t    (CHIP_IS_E3(bp) &&\n\t\t\t     mode == LED_MODE_ON))\n\t\t\t\tREG_WR(bp, NIG_REG_LED_10G_P0 + port*4, 1);\n\n\t\t\tif (CHIP_IS_E1x(bp) ||\n\t\t\t    CHIP_IS_E2(bp) ||\n\t\t\t    (mode == LED_MODE_ON))\n\t\t\t\tREG_WR(bp, NIG_REG_LED_MODE_P0 + port*4, 0);\n\t\t\telse\n\t\t\t\tREG_WR(bp, NIG_REG_LED_MODE_P0 + port*4,\n\t\t\t\t       hw_led_mode);\n\t\t} else if ((params->phy[EXT_PHY1].type ==\n\t\t\t    PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM54618SE) &&\n\t\t\t   (mode == LED_MODE_ON)) {\n\t\t\tREG_WR(bp, NIG_REG_LED_MODE_P0 + port*4, 0);\n\t\t\ttmp = EMAC_RD(bp, EMAC_REG_EMAC_LED);\n\t\t\tEMAC_WR(bp, EMAC_REG_EMAC_LED, tmp |\n\t\t\t\tEMAC_LED_OVERRIDE | EMAC_LED_1000MB_OVERRIDE);\n\t\t\t \n\t\t\tbreak;\n\t\t} else {\n\t\t\tu32 nig_led_mode = ((params->hw_led_mode <<\n\t\t\t\t\t     SHARED_HW_CFG_LED_MODE_SHIFT) ==\n\t\t\t\t\t    SHARED_HW_CFG_LED_EXTPHY2) ?\n\t\t\t\t(SHARED_HW_CFG_LED_PHY1 >>\n\t\t\t\t SHARED_HW_CFG_LED_MODE_SHIFT) : hw_led_mode;\n\t\t\tREG_WR(bp, NIG_REG_LED_MODE_P0 + port*4,\n\t\t\t       nig_led_mode);\n\t\t}\n\n\t\tREG_WR(bp, NIG_REG_LED_CONTROL_OVERRIDE_TRAFFIC_P0 + port*4, 0);\n\t\t \n\t\tif (CHIP_IS_E3(bp))\n\t\t\tREG_WR(bp, NIG_REG_LED_CONTROL_BLINK_RATE_P0 + port*4,\n\t\t\t       LED_BLINK_RATE_VAL_E3);\n\t\telse\n\t\t\tREG_WR(bp, NIG_REG_LED_CONTROL_BLINK_RATE_P0 + port*4,\n\t\t\t       LED_BLINK_RATE_VAL_E1X_E2);\n\t\tREG_WR(bp, NIG_REG_LED_CONTROL_BLINK_RATE_ENA_P0 +\n\t\t       port*4, 1);\n\t\ttmp = EMAC_RD(bp, EMAC_REG_EMAC_LED);\n\t\tEMAC_WR(bp, EMAC_REG_EMAC_LED,\n\t\t\t(tmp & (~EMAC_LED_OVERRIDE)));\n\n\t\tif (CHIP_IS_E1(bp) &&\n\t\t    ((speed == SPEED_2500) ||\n\t\t     (speed == SPEED_1000) ||\n\t\t     (speed == SPEED_100) ||\n\t\t     (speed == SPEED_10))) {\n\t\t\t \n\t\t\tREG_WR(bp, NIG_REG_LED_CONTROL_OVERRIDE_TRAFFIC_P0\n\t\t\t       + port*4, 1);\n\t\t\tREG_WR(bp, NIG_REG_LED_CONTROL_TRAFFIC_P0 +\n\t\t\t       port*4, 0);\n\t\t\tREG_WR(bp, NIG_REG_LED_CONTROL_BLINK_TRAFFIC_P0 +\n\t\t\t       port*4, 1);\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\trc = -EINVAL;\n\t\tDP(NETIF_MSG_LINK, \"bnx2x_set_led: Invalid led mode %d\\n\",\n\t\t\t mode);\n\t\tbreak;\n\t}\n\treturn rc;\n\n}\n\n \nint bnx2x_test_link(struct link_params *params, struct link_vars *vars,\n\t\t    u8 is_serdes)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu16 gp_status = 0, phy_index = 0;\n\tu8 ext_phy_link_up = 0, serdes_phy_type;\n\tstruct link_vars temp_vars;\n\tstruct bnx2x_phy *int_phy = &params->phy[INT_PHY];\n\n\tif (CHIP_IS_E3(bp)) {\n\t\tu16 link_up;\n\t\tif (params->req_line_speed[LINK_CONFIG_IDX(INT_PHY)]\n\t\t    > SPEED_10000) {\n\t\t\t \n\t\t\tbnx2x_cl45_read(bp, int_phy, MDIO_WC_DEVAD,\n\t\t\t\t\t1, &link_up);\n\t\t\tbnx2x_cl45_read(bp, int_phy, MDIO_WC_DEVAD,\n\t\t\t\t\t1, &link_up);\n\t\t\tlink_up &= (1<<2);\n\t\t} else {\n\t\t\t \n\t\t\tu8 lane = bnx2x_get_warpcore_lane(int_phy, params);\n\t\t\tbnx2x_cl45_read(bp, int_phy, MDIO_WC_DEVAD,\n\t\t\t\t\tMDIO_WC_REG_GP2_STATUS_GP_2_1,\n\t\t\t\t\t&gp_status);\n\t\t\tgp_status = ((gp_status >> 8) & 0xf) |\n\t\t\t\t((gp_status >> 12) & 0xf);\n\t\t\tlink_up = gp_status & (1 << lane);\n\t\t}\n\t\tif (!link_up)\n\t\t\treturn -ESRCH;\n\t} else {\n\t\tCL22_RD_OVER_CL45(bp, int_phy,\n\t\t\t  MDIO_REG_BANK_GP_STATUS,\n\t\t\t  MDIO_GP_STATUS_TOP_AN_STATUS1,\n\t\t\t  &gp_status);\n\t\t \n\t\tif (!(gp_status & MDIO_GP_STATUS_TOP_AN_STATUS1_LINK_STATUS))\n\t\t\treturn -ESRCH;\n\t}\n\t \n\tif (params->loopback_mode == LOOPBACK_XGXS)\n\t\treturn 0;\n\n\tswitch (params->num_phys) {\n\tcase 1:\n\t\t \n\t\treturn 0;\n\tcase 2:\n\t\text_phy_link_up = params->phy[EXT_PHY1].read_status(\n\t\t\t&params->phy[EXT_PHY1],\n\t\t\tparams, &temp_vars);\n\t\tbreak;\n\tcase 3:  \n\t\tfor (phy_index = EXT_PHY1; phy_index < params->num_phys;\n\t\t      phy_index++) {\n\t\t\tserdes_phy_type = ((params->phy[phy_index].media_type ==\n\t\t\t\t\t    ETH_PHY_SFPP_10G_FIBER) ||\n\t\t\t\t\t   (params->phy[phy_index].media_type ==\n\t\t\t\t\t    ETH_PHY_SFP_1G_FIBER) ||\n\t\t\t\t\t   (params->phy[phy_index].media_type ==\n\t\t\t\t\t    ETH_PHY_XFP_FIBER) ||\n\t\t\t\t\t   (params->phy[phy_index].media_type ==\n\t\t\t\t\t    ETH_PHY_DA_TWINAX));\n\n\t\t\tif (is_serdes != serdes_phy_type)\n\t\t\t\tcontinue;\n\t\t\tif (params->phy[phy_index].read_status) {\n\t\t\t\text_phy_link_up |=\n\t\t\t\t\tparams->phy[phy_index].read_status(\n\t\t\t\t\t\t&params->phy[phy_index],\n\t\t\t\t\t\tparams, &temp_vars);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\tif (ext_phy_link_up)\n\t\treturn 0;\n\treturn -ESRCH;\n}\n\nstatic int bnx2x_link_initialize(struct link_params *params,\n\t\t\t\t struct link_vars *vars)\n{\n\tu8 phy_index, non_ext_phy;\n\tstruct bnx2x *bp = params->bp;\n\t \n\tvars->line_speed = params->phy[INT_PHY].req_line_speed;\n\n\t \n\tif (!USES_WARPCORE(bp))\n\t\tbnx2x_prepare_xgxs(&params->phy[INT_PHY], params, vars);\n\t \n\tnon_ext_phy = (SINGLE_MEDIA_DIRECT(params) ||\n\t\t       (params->loopback_mode == LOOPBACK_XGXS));\n\n\tif (non_ext_phy ||\n\t    (params->phy[EXT_PHY1].flags & FLAGS_INIT_XGXS_FIRST) ||\n\t    (params->loopback_mode == LOOPBACK_EXT_PHY)) {\n\t\tstruct bnx2x_phy *phy = &params->phy[INT_PHY];\n\t\tif (vars->line_speed == SPEED_AUTO_NEG &&\n\t\t    (CHIP_IS_E1x(bp) ||\n\t\t     CHIP_IS_E2(bp)))\n\t\t\tbnx2x_set_parallel_detection(phy, params);\n\t\tif (params->phy[INT_PHY].config_init)\n\t\t\tparams->phy[INT_PHY].config_init(phy, params, vars);\n\t}\n\n\t \n\tvars->line_speed = params->phy[INT_PHY].req_line_speed;\n\n\t \n\tif (non_ext_phy) {\n\t\tif (params->phy[INT_PHY].supported &\n\t\t    SUPPORTED_FIBRE)\n\t\t\tvars->link_status |= LINK_STATUS_SERDES_LINK;\n\t} else {\n\t\tfor (phy_index = EXT_PHY1; phy_index < params->num_phys;\n\t\t      phy_index++) {\n\t\t\t \n\t\t\tif (params->phy[phy_index].supported &\n\t\t\t    SUPPORTED_FIBRE)\n\t\t\t\tvars->link_status |= LINK_STATUS_SERDES_LINK;\n\n\t\t\tif (phy_index == EXT_PHY2 &&\n\t\t\t    (bnx2x_phy_selection(params) ==\n\t\t\t     PORT_HW_CFG_PHY_SELECTION_FIRST_PHY)) {\n\t\t\t\tDP(NETIF_MSG_LINK,\n\t\t\t\t   \"Not initializing second phy\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tparams->phy[phy_index].config_init(\n\t\t\t\t&params->phy[phy_index],\n\t\t\t\tparams, vars);\n\t\t}\n\t}\n\t \n\tbnx2x_bits_dis(bp, NIG_REG_STATUS_INTERRUPT_PORT0 +\n\t\t       params->port*4,\n\t\t       (NIG_STATUS_XGXS0_LINK10G |\n\t\t\tNIG_STATUS_XGXS0_LINK_STATUS |\n\t\t\tNIG_STATUS_SERDES0_LINK_STATUS |\n\t\t\tNIG_MASK_MI_INT));\n\treturn 0;\n}\n\nstatic void bnx2x_int_link_reset(struct bnx2x_phy *phy,\n\t\t\t\t struct link_params *params)\n{\n\t \n\tREG_WR(params->bp, GRCBASE_MISC + MISC_REGISTERS_RESET_REG_3_CLEAR,\n\t       (0x1ff << (params->port*16)));\n}\n\nstatic void bnx2x_common_ext_link_reset(struct bnx2x_phy *phy,\n\t\t\t\t\tstruct link_params *params)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu8 gpio_port;\n\t \n\tif (CHIP_IS_E2(bp))\n\t\tgpio_port = BP_PATH(bp);\n\telse\n\t\tgpio_port = params->port;\n\tbnx2x_set_gpio(bp, MISC_REGISTERS_GPIO_1,\n\t\t       MISC_REGISTERS_GPIO_OUTPUT_LOW,\n\t\t       gpio_port);\n\tbnx2x_set_gpio(bp, MISC_REGISTERS_GPIO_2,\n\t\t       MISC_REGISTERS_GPIO_OUTPUT_LOW,\n\t\t       gpio_port);\n\tDP(NETIF_MSG_LINK, \"reset external PHY\\n\");\n}\n\nstatic int bnx2x_update_link_down(struct link_params *params,\n\t\t\t\t  struct link_vars *vars)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu8 port = params->port;\n\n\tDP(NETIF_MSG_LINK, \"Port %x: Link is down\\n\", port);\n\tbnx2x_set_led(params, vars, LED_MODE_OFF, 0);\n\tvars->phy_flags &= ~PHY_PHYSICAL_LINK_FLAG;\n\t \n\tvars->mac_type = MAC_TYPE_NONE;\n\n\t \n\tvars->link_status &= ~LINK_UPDATE_MASK;\n\tvars->line_speed = 0;\n\tbnx2x_update_mng(params, vars->link_status);\n\n\t \n\tREG_WR(bp, NIG_REG_EGRESS_DRAIN0_MODE + port*4, 1);\n\n\t \n\tif (!CHIP_IS_E3(bp))\n\t\tREG_WR(bp, NIG_REG_NIG_EMAC0_EN + port*4, 0);\n\n\tusleep_range(10000, 20000);\n\t \n\tif (CHIP_IS_E1x(bp) ||\n\t    CHIP_IS_E2(bp))\n\t\tbnx2x_set_bmac_rx(bp, params->chip_id, params->port, 0);\n\n\tif (CHIP_IS_E3(bp)) {\n\t\t \n\t\tREG_WR(bp, MISC_REG_CPMU_LP_FW_ENABLE_P0 + (params->port << 2),\n\t\t       0);\n\t\tREG_WR(bp, MISC_REG_CPMU_LP_MASK_ENT_P0 + (params->port << 2),\n\t\t       0);\n\t\tvars->eee_status &= ~(SHMEM_EEE_LP_ADV_STATUS_MASK |\n\t\t\t\t      SHMEM_EEE_ACTIVE_BIT);\n\n\t\tbnx2x_update_mng_eee(params, vars->eee_status);\n\t\tbnx2x_set_xmac_rxtx(params, 0);\n\t\tbnx2x_set_umac_rxtx(params, 0);\n\t}\n\n\treturn 0;\n}\n\nstatic int bnx2x_update_link_up(struct link_params *params,\n\t\t\t\tstruct link_vars *vars,\n\t\t\t\tu8 link_10g)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu8 phy_idx, port = params->port;\n\tint rc = 0;\n\n\tvars->link_status |= (LINK_STATUS_LINK_UP |\n\t\t\t      LINK_STATUS_PHYSICAL_LINK_FLAG);\n\tvars->phy_flags |= PHY_PHYSICAL_LINK_FLAG;\n\n\tif (vars->flow_ctrl & BNX2X_FLOW_CTRL_TX)\n\t\tvars->link_status |=\n\t\t\tLINK_STATUS_TX_FLOW_CONTROL_ENABLED;\n\n\tif (vars->flow_ctrl & BNX2X_FLOW_CTRL_RX)\n\t\tvars->link_status |=\n\t\t\tLINK_STATUS_RX_FLOW_CONTROL_ENABLED;\n\tif (USES_WARPCORE(bp)) {\n\t\tif (link_10g) {\n\t\t\tif (bnx2x_xmac_enable(params, vars, 0) ==\n\t\t\t    -ESRCH) {\n\t\t\t\tDP(NETIF_MSG_LINK, \"Found errors on XMAC\\n\");\n\t\t\t\tvars->link_up = 0;\n\t\t\t\tvars->phy_flags |= PHY_HALF_OPEN_CONN_FLAG;\n\t\t\t\tvars->link_status &= ~LINK_STATUS_LINK_UP;\n\t\t\t}\n\t\t} else\n\t\t\tbnx2x_umac_enable(params, vars, 0);\n\t\tbnx2x_set_led(params, vars,\n\t\t\t      LED_MODE_OPER, vars->line_speed);\n\n\t\tif ((vars->eee_status & SHMEM_EEE_ACTIVE_BIT) &&\n\t\t    (vars->eee_status & SHMEM_EEE_LPI_REQUESTED_BIT)) {\n\t\t\tDP(NETIF_MSG_LINK, \"Enabling LPI assertion\\n\");\n\t\t\tREG_WR(bp, MISC_REG_CPMU_LP_FW_ENABLE_P0 +\n\t\t\t       (params->port << 2), 1);\n\t\t\tREG_WR(bp, MISC_REG_CPMU_LP_DR_ENABLE, 1);\n\t\t\tREG_WR(bp, MISC_REG_CPMU_LP_MASK_ENT_P0 +\n\t\t\t       (params->port << 2), 0xfc20);\n\t\t}\n\t}\n\tif ((CHIP_IS_E1x(bp) ||\n\t     CHIP_IS_E2(bp))) {\n\t\tif (link_10g) {\n\t\t\tif (bnx2x_bmac_enable(params, vars, 0, 1) ==\n\t\t\t    -ESRCH) {\n\t\t\t\tDP(NETIF_MSG_LINK, \"Found errors on BMAC\\n\");\n\t\t\t\tvars->link_up = 0;\n\t\t\t\tvars->phy_flags |= PHY_HALF_OPEN_CONN_FLAG;\n\t\t\t\tvars->link_status &= ~LINK_STATUS_LINK_UP;\n\t\t\t}\n\n\t\t\tbnx2x_set_led(params, vars,\n\t\t\t\t      LED_MODE_OPER, SPEED_10000);\n\t\t} else {\n\t\t\trc = bnx2x_emac_program(params, vars);\n\t\t\tbnx2x_emac_enable(params, vars, 0);\n\n\t\t\t \n\t\t\tif ((vars->link_status &\n\t\t\t     LINK_STATUS_AUTO_NEGOTIATE_COMPLETE)\n\t\t\t    && (!(vars->phy_flags & PHY_SGMII_FLAG)) &&\n\t\t\t    SINGLE_MEDIA_DIRECT(params))\n\t\t\t\tbnx2x_set_gmii_tx_driver(params);\n\t\t}\n\t}\n\n\t \n\tif (CHIP_IS_E1x(bp))\n\t\trc |= bnx2x_pbf_update(params, vars->flow_ctrl,\n\t\t\t\t       vars->line_speed);\n\n\t \n\tREG_WR(bp, NIG_REG_EGRESS_DRAIN0_MODE + port*4, 0);\n\n\t \n\tbnx2x_update_mng(params, vars->link_status);\n\tbnx2x_update_mng_eee(params, vars->eee_status);\n\t \n\tfor (phy_idx = INT_PHY; phy_idx < MAX_PHYS; phy_idx++) {\n\t\tif (params->phy[phy_idx].flags & FLAGS_TX_ERROR_CHECK) {\n\t\t\tbnx2x_check_half_open_conn(params, vars, 0);\n\t\t\tbreak;\n\t\t}\n\t}\n\tmsleep(20);\n\treturn rc;\n}\n\nstatic void bnx2x_chng_link_count(struct link_params *params, bool clear)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu32 addr, val;\n\n\t \n\tif (!(SHMEM2_HAS(bp, link_change_count)))\n\t\treturn;\n\n\taddr = params->shmem2_base +\n\t\toffsetof(struct shmem2_region, link_change_count[params->port]);\n\tif (clear)\n\t\tval = 0;\n\telse\n\t\tval = REG_RD(bp, addr) + 1;\n\tREG_WR(bp, addr, val);\n}\n\n \nint bnx2x_link_update(struct link_params *params, struct link_vars *vars)\n{\n\tstruct bnx2x *bp = params->bp;\n\tstruct link_vars phy_vars[MAX_PHYS];\n\tu8 port = params->port;\n\tu8 link_10g_plus, phy_index;\n\tu32 prev_link_status = vars->link_status;\n\tu8 ext_phy_link_up = 0, cur_link_up;\n\tint rc = 0;\n\tu8 is_mi_int = 0;\n\tu16 ext_phy_line_speed = 0, prev_line_speed = vars->line_speed;\n\tu8 active_external_phy = INT_PHY;\n\tvars->phy_flags &= ~PHY_HALF_OPEN_CONN_FLAG;\n\tvars->link_status &= ~LINK_UPDATE_MASK;\n\tfor (phy_index = INT_PHY; phy_index < params->num_phys;\n\t      phy_index++) {\n\t\tphy_vars[phy_index].flow_ctrl = 0;\n\t\tphy_vars[phy_index].link_status = 0;\n\t\tphy_vars[phy_index].line_speed = 0;\n\t\tphy_vars[phy_index].duplex = DUPLEX_FULL;\n\t\tphy_vars[phy_index].phy_link_up = 0;\n\t\tphy_vars[phy_index].link_up = 0;\n\t\tphy_vars[phy_index].fault_detected = 0;\n\t\t \n\t\tphy_vars[phy_index].eee_status = vars->eee_status;\n\t}\n\n\tif (USES_WARPCORE(bp))\n\t\tbnx2x_set_aer_mmd(params, &params->phy[INT_PHY]);\n\n\tDP(NETIF_MSG_LINK, \"port %x, XGXS?%x, int_status 0x%x\\n\",\n\t\t port, (vars->phy_flags & PHY_XGXS_FLAG),\n\t\t REG_RD(bp, NIG_REG_STATUS_INTERRUPT_PORT0 + port*4));\n\n\tis_mi_int = (u8)(REG_RD(bp, NIG_REG_EMAC0_STATUS_MISC_MI_INT +\n\t\t\t\tport*0x18) > 0);\n\tDP(NETIF_MSG_LINK, \"int_mask 0x%x MI_INT %x, SERDES_LINK %x\\n\",\n\t\t REG_RD(bp, NIG_REG_MASK_INTERRUPT_PORT0 + port*4),\n\t\t is_mi_int,\n\t\t REG_RD(bp, NIG_REG_SERDES0_STATUS_LINK_STATUS + port*0x3c));\n\n\tDP(NETIF_MSG_LINK, \" 10G %x, XGXS_LINK %x\\n\",\n\t  REG_RD(bp, NIG_REG_XGXS0_STATUS_LINK10G + port*0x68),\n\t  REG_RD(bp, NIG_REG_XGXS0_STATUS_LINK_STATUS + port*0x68));\n\n\t \n\tif (!CHIP_IS_E3(bp))\n\t\tREG_WR(bp, NIG_REG_NIG_EMAC0_EN + port*4, 0);\n\n\t \n\tfor (phy_index = EXT_PHY1; phy_index < params->num_phys;\n\t      phy_index++) {\n\t\tstruct bnx2x_phy *phy = &params->phy[phy_index];\n\t\tif (!phy->read_status)\n\t\t\tcontinue;\n\t\t \n\t\tcur_link_up = phy->read_status(phy, params,\n\t\t\t\t\t       &phy_vars[phy_index]);\n\t\tif (cur_link_up) {\n\t\t\tDP(NETIF_MSG_LINK, \"phy in index %d link is up\\n\",\n\t\t\t\t   phy_index);\n\t\t} else {\n\t\t\tDP(NETIF_MSG_LINK, \"phy in index %d link is down\\n\",\n\t\t\t\t   phy_index);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!ext_phy_link_up) {\n\t\t\text_phy_link_up = 1;\n\t\t\tactive_external_phy = phy_index;\n\t\t} else {\n\t\t\tswitch (bnx2x_phy_selection(params)) {\n\t\t\tcase PORT_HW_CFG_PHY_SELECTION_HARDWARE_DEFAULT:\n\t\t\tcase PORT_HW_CFG_PHY_SELECTION_FIRST_PHY_PRIORITY:\n\t\t\t \n\t\t\t\tactive_external_phy = EXT_PHY1;\n\t\t\t\tbreak;\n\t\t\tcase PORT_HW_CFG_PHY_SELECTION_SECOND_PHY_PRIORITY:\n\t\t\t \n\t\t\t\tactive_external_phy = EXT_PHY2;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t \n\t\t\t\tDP(NETIF_MSG_LINK, \"Invalid link indication\"\n\t\t\t\t\t   \"mpc=0x%x. DISABLING LINK !!!\\n\",\n\t\t\t\t\t   params->multi_phy_config);\n\t\t\t\text_phy_link_up = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tprev_line_speed = vars->line_speed;\n\t \n\tif (params->phy[INT_PHY].read_status)\n\t\tparams->phy[INT_PHY].read_status(\n\t\t\t&params->phy[INT_PHY],\n\t\t\tparams, vars);\n\t \n\tif (active_external_phy > INT_PHY) {\n\t\tvars->flow_ctrl = phy_vars[active_external_phy].flow_ctrl;\n\t\t \n\t\tvars->link_status |= phy_vars[active_external_phy].link_status;\n\n\t\t \n\t\tif (active_external_phy == EXT_PHY1) {\n\t\t\tif (params->phy[EXT_PHY2].phy_specific_func) {\n\t\t\t\tDP(NETIF_MSG_LINK,\n\t\t\t\t   \"Disabling TX on EXT_PHY2\\n\");\n\t\t\t\tparams->phy[EXT_PHY2].phy_specific_func(\n\t\t\t\t\t&params->phy[EXT_PHY2],\n\t\t\t\t\tparams, DISABLE_TX);\n\t\t\t}\n\t\t}\n\n\t\text_phy_line_speed = phy_vars[active_external_phy].line_speed;\n\t\tvars->duplex = phy_vars[active_external_phy].duplex;\n\t\tif (params->phy[active_external_phy].supported &\n\t\t    SUPPORTED_FIBRE)\n\t\t\tvars->link_status |= LINK_STATUS_SERDES_LINK;\n\t\telse\n\t\t\tvars->link_status &= ~LINK_STATUS_SERDES_LINK;\n\n\t\tvars->eee_status = phy_vars[active_external_phy].eee_status;\n\n\t\tDP(NETIF_MSG_LINK, \"Active external phy selected: %x\\n\",\n\t\t\t   active_external_phy);\n\t}\n\n\tfor (phy_index = EXT_PHY1; phy_index < params->num_phys;\n\t      phy_index++) {\n\t\tif (params->phy[phy_index].flags &\n\t\t    FLAGS_REARM_LATCH_SIGNAL) {\n\t\t\tbnx2x_rearm_latch_signal(bp, port,\n\t\t\t\t\t\t phy_index ==\n\t\t\t\t\t\t active_external_phy);\n\t\t\tbreak;\n\t\t}\n\t}\n\tDP(NETIF_MSG_LINK, \"vars->flow_ctrl = 0x%x, vars->link_status = 0x%x,\"\n\t\t   \" ext_phy_line_speed = %d\\n\", vars->flow_ctrl,\n\t\t   vars->link_status, ext_phy_line_speed);\n\t \n\n\tif (vars->phy_link_up) {\n\t\tif (!(SINGLE_MEDIA_DIRECT(params)) && ext_phy_link_up &&\n\t\t    (ext_phy_line_speed != vars->line_speed)) {\n\t\t\tDP(NETIF_MSG_LINK, \"Internal link speed %d is\"\n\t\t\t\t   \" different than the external\"\n\t\t\t\t   \" link speed %d\\n\", vars->line_speed,\n\t\t\t\t   ext_phy_line_speed);\n\t\t\tvars->phy_link_up = 0;\n\t\t} else if (prev_line_speed != vars->line_speed) {\n\t\t\tREG_WR(bp, NIG_REG_EGRESS_DRAIN0_MODE + params->port*4,\n\t\t\t       0);\n\t\t\tusleep_range(1000, 2000);\n\t\t}\n\t}\n\n\t \n\tlink_10g_plus = (vars->line_speed >= SPEED_10000);\n\n\tbnx2x_link_int_ack(params, vars, link_10g_plus);\n\n\t \n\tif (!(SINGLE_MEDIA_DIRECT(params))) {\n\t\tDP(NETIF_MSG_LINK, \"ext_phy_link_up = %d, int_link_up = %d,\"\n\t\t\t   \" init_preceding = %d\\n\", ext_phy_link_up,\n\t\t\t   vars->phy_link_up,\n\t\t\t   params->phy[EXT_PHY1].flags &\n\t\t\t   FLAGS_INIT_XGXS_FIRST);\n\t\tif (!(params->phy[EXT_PHY1].flags &\n\t\t      FLAGS_INIT_XGXS_FIRST)\n\t\t    && ext_phy_link_up && !vars->phy_link_up) {\n\t\t\tvars->line_speed = ext_phy_line_speed;\n\t\t\tif (vars->line_speed < SPEED_1000)\n\t\t\t\tvars->phy_flags |= PHY_SGMII_FLAG;\n\t\t\telse\n\t\t\t\tvars->phy_flags &= ~PHY_SGMII_FLAG;\n\n\t\t\tif (params->phy[INT_PHY].config_init)\n\t\t\t\tparams->phy[INT_PHY].config_init(\n\t\t\t\t\t&params->phy[INT_PHY], params,\n\t\t\t\t\t\tvars);\n\t\t}\n\t}\n\t \n\tvars->link_up = (vars->phy_link_up &&\n\t\t\t (ext_phy_link_up ||\n\t\t\t  SINGLE_MEDIA_DIRECT(params)) &&\n\t\t\t (phy_vars[active_external_phy].fault_detected == 0));\n\n\t \n\tif (params->feature_config_flags & FEATURE_CONFIG_PFC_ENABLED)\n\t\tvars->link_status |= LINK_STATUS_PFC_ENABLED;\n\telse\n\t\tvars->link_status &= ~LINK_STATUS_PFC_ENABLED;\n\n\tif (vars->link_up)\n\t\trc = bnx2x_update_link_up(params, vars, link_10g_plus);\n\telse\n\t\trc = bnx2x_update_link_down(params, vars);\n\n\tif ((prev_link_status ^ vars->link_status) & LINK_STATUS_LINK_UP)\n\t\tbnx2x_chng_link_count(params, false);\n\n\t \n\tif (params->feature_config_flags & FEATURE_CONFIG_BC_SUPPORTS_AFEX)\n\t\tbnx2x_fw_command(bp, DRV_MSG_CODE_LINK_STATUS_CHANGED, 0);\n\n\treturn rc;\n}\n\n \n \n \nvoid bnx2x_ext_phy_hw_reset(struct bnx2x *bp, u8 port)\n{\n\tbnx2x_set_gpio(bp, MISC_REGISTERS_GPIO_1,\n\t\t       MISC_REGISTERS_GPIO_OUTPUT_LOW, port);\n\tusleep_range(1000, 2000);\n\tbnx2x_set_gpio(bp, MISC_REGISTERS_GPIO_1,\n\t\t       MISC_REGISTERS_GPIO_OUTPUT_HIGH, port);\n}\n\nstatic void bnx2x_save_spirom_version(struct bnx2x *bp, u8 port,\n\t\t\t\t      u32 spirom_ver, u32 ver_addr)\n{\n\tDP(NETIF_MSG_LINK, \"FW version 0x%x:0x%x for port %d\\n\",\n\t\t (u16)(spirom_ver>>16), (u16)spirom_ver, port);\n\n\tif (ver_addr)\n\t\tREG_WR(bp, ver_addr, spirom_ver);\n}\n\nstatic void bnx2x_save_bcm_spirom_ver(struct bnx2x *bp,\n\t\t\t\t      struct bnx2x_phy *phy,\n\t\t\t\t      u8 port)\n{\n\tu16 fw_ver1, fw_ver2;\n\n\tbnx2x_cl45_read(bp, phy, MDIO_PMA_DEVAD,\n\t\t\tMDIO_PMA_REG_ROM_VER1, &fw_ver1);\n\tbnx2x_cl45_read(bp, phy, MDIO_PMA_DEVAD,\n\t\t\tMDIO_PMA_REG_ROM_VER2, &fw_ver2);\n\tbnx2x_save_spirom_version(bp, port, (u32)(fw_ver1<<16 | fw_ver2),\n\t\t\t\t  phy->ver_addr);\n}\n\nstatic void bnx2x_ext_phy_10G_an_resolve(struct bnx2x *bp,\n\t\t\t\t       struct bnx2x_phy *phy,\n\t\t\t\t       struct link_vars *vars)\n{\n\tu16 val;\n\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_AN_DEVAD,\n\t\t\tMDIO_AN_REG_STATUS, &val);\n\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_AN_DEVAD,\n\t\t\tMDIO_AN_REG_STATUS, &val);\n\tif (val & (1<<5))\n\t\tvars->link_status |= LINK_STATUS_AUTO_NEGOTIATE_COMPLETE;\n\tif ((val & (1<<0)) == 0)\n\t\tvars->link_status |= LINK_STATUS_PARALLEL_DETECTION_USED;\n}\n\n \n \n \nstatic void bnx2x_8073_resolve_fc(struct bnx2x_phy *phy,\n\t\t\t\t  struct link_params *params,\n\t\t\t\t  struct link_vars *vars)\n{\n\tstruct bnx2x *bp = params->bp;\n\tif (phy->req_line_speed == SPEED_10 ||\n\t    phy->req_line_speed == SPEED_100) {\n\t\tvars->flow_ctrl = phy->req_flow_ctrl;\n\t\treturn;\n\t}\n\n\tif (bnx2x_ext_phy_resolve_fc(phy, params, vars) &&\n\t    (vars->flow_ctrl == BNX2X_FLOW_CTRL_NONE)) {\n\t\tu16 pause_result;\n\t\tu16 ld_pause;\t\t \n\t\tu16 lp_pause;\t\t \n\t\tbnx2x_cl45_read(bp, phy,\n\t\t\t\tMDIO_AN_DEVAD,\n\t\t\t\tMDIO_AN_REG_CL37_FC_LD, &ld_pause);\n\n\t\tbnx2x_cl45_read(bp, phy,\n\t\t\t\tMDIO_AN_DEVAD,\n\t\t\t\tMDIO_AN_REG_CL37_FC_LP, &lp_pause);\n\t\tpause_result = (ld_pause &\n\t\t\t\tMDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_BOTH) >> 5;\n\t\tpause_result |= (lp_pause &\n\t\t\t\t MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_BOTH) >> 7;\n\n\t\tbnx2x_pause_resolve(phy, params, vars, pause_result);\n\t\tDP(NETIF_MSG_LINK, \"Ext PHY CL37 pause result 0x%x\\n\",\n\t\t\t   pause_result);\n\t}\n}\nstatic int bnx2x_8073_8727_external_rom_boot(struct bnx2x *bp,\n\t\t\t\t\t     struct bnx2x_phy *phy,\n\t\t\t\t\t     u8 port)\n{\n\tu32 count = 0;\n\tu16 fw_ver1, fw_msgout;\n\tint rc = 0;\n\n\t \n\t \n\tbnx2x_cl45_write(bp, phy,\n\t\t\t MDIO_PMA_DEVAD,\n\t\t\t MDIO_PMA_REG_GEN_CTRL,\n\t\t\t 0x0001);\n\n\t \n\tbnx2x_cl45_write(bp, phy,\n\t\t\t MDIO_PMA_DEVAD,\n\t\t\t MDIO_PMA_REG_GEN_CTRL,\n\t\t\t 0x008c);\n\n\tbnx2x_cl45_write(bp, phy,\n\t\t\t MDIO_PMA_DEVAD,\n\t\t\t MDIO_PMA_REG_MISC_CTRL1, 0x0001);\n\n\t \n\tbnx2x_cl45_write(bp, phy,\n\t\t\t MDIO_PMA_DEVAD,\n\t\t\t MDIO_PMA_REG_GEN_CTRL,\n\t\t\t MDIO_PMA_REG_GEN_CTRL_ROM_MICRO_RESET);\n\n\t \n\tbnx2x_cl45_write(bp, phy,\n\t\t\t MDIO_PMA_DEVAD,\n\t\t\t MDIO_PMA_REG_GEN_CTRL,\n\t\t\t MDIO_PMA_REG_GEN_CTRL_ROM_RESET_INTERNAL_MP);\n\n\t \n\tmsleep(100);\n\n\t \n\tdo {\n\t\tcount++;\n\t\tif (count > 300) {\n\t\t\tDP(NETIF_MSG_LINK,\n\t\t\t\t \"bnx2x_8073_8727_external_rom_boot port %x:\"\n\t\t\t\t \"Download failed. fw version = 0x%x\\n\",\n\t\t\t\t port, fw_ver1);\n\t\t\trc = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tbnx2x_cl45_read(bp, phy,\n\t\t\t\tMDIO_PMA_DEVAD,\n\t\t\t\tMDIO_PMA_REG_ROM_VER1, &fw_ver1);\n\t\tbnx2x_cl45_read(bp, phy,\n\t\t\t\tMDIO_PMA_DEVAD,\n\t\t\t\tMDIO_PMA_REG_M8051_MSGOUT_REG, &fw_msgout);\n\n\t\tusleep_range(1000, 2000);\n\t} while (fw_ver1 == 0 || fw_ver1 == 0x4321 ||\n\t\t\t((fw_msgout & 0xff) != 0x03 && (phy->type ==\n\t\t\tPORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8073)));\n\n\t \n\tbnx2x_cl45_write(bp, phy,\n\t\t\t MDIO_PMA_DEVAD,\n\t\t\t MDIO_PMA_REG_MISC_CTRL1, 0x0000);\n\tbnx2x_save_bcm_spirom_ver(bp, phy, port);\n\n\tDP(NETIF_MSG_LINK,\n\t\t \"bnx2x_8073_8727_external_rom_boot port %x:\"\n\t\t \"Download complete. fw version = 0x%x\\n\",\n\t\t port, fw_ver1);\n\n\treturn rc;\n}\n\n \n \n \nstatic int bnx2x_8073_is_snr_needed(struct bnx2x *bp, struct bnx2x_phy *phy)\n{\n\t \n\tu16 val;\n\n\t \n\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_PMA_DEVAD,\n\t\t\tMDIO_PMA_REG_8073_CHIP_REV, &val);\n\n\tif (val != 1) {\n\t\t \n\t\treturn 0;\n\t}\n\n\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_PMA_DEVAD,\n\t\t\tMDIO_PMA_REG_ROM_VER2, &val);\n\n\t \n\tif (val != 0x102)\n\t\treturn 0;\n\n\treturn 1;\n}\n\nstatic int bnx2x_8073_xaui_wa(struct bnx2x *bp, struct bnx2x_phy *phy)\n{\n\tu16 val, cnt, cnt1 ;\n\n\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_PMA_DEVAD,\n\t\t\tMDIO_PMA_REG_8073_CHIP_REV, &val);\n\n\tif (val > 0) {\n\t\t \n\t\treturn 0;\n\t}\n\t \n\n\t \n\n\tfor (cnt = 0; cnt < 1000; cnt++) {\n\t\tbnx2x_cl45_read(bp, phy,\n\t\t\t\tMDIO_PMA_DEVAD,\n\t\t\t\tMDIO_PMA_REG_8073_SPEED_LINK_STATUS,\n\t\t\t\t&val);\n\t\t   \n\t\tif (!(val & (1<<14)) || !(val & (1<<13))) {\n\t\t\tDP(NETIF_MSG_LINK, \"XAUI work-around not required\\n\");\n\t\t\treturn 0;\n\t\t} else if (!(val & (1<<15))) {\n\t\t\tDP(NETIF_MSG_LINK, \"bit 15 went off\\n\");\n\t\t\t \n\t\t\tfor (cnt1 = 0; cnt1 < 1000; cnt1++) {\n\t\t\t\tbnx2x_cl45_read(bp, phy,\n\t\t\t\t\tMDIO_PMA_DEVAD,\n\t\t\t\t\tMDIO_PMA_REG_8073_XAUI_WA, &val);\n\t\t\t\tif (val & (1<<15)) {\n\t\t\t\t\tDP(NETIF_MSG_LINK,\n\t\t\t\t\t  \"XAUI workaround has completed\\n\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tusleep_range(3000, 6000);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tusleep_range(3000, 6000);\n\t}\n\tDP(NETIF_MSG_LINK, \"Warning: XAUI work-around timeout !!!\\n\");\n\treturn -EINVAL;\n}\n\nstatic void bnx2x_807x_force_10G(struct bnx2x *bp, struct bnx2x_phy *phy)\n{\n\t \n\tbnx2x_cl45_write(bp, phy,\n\t\t\t MDIO_PMA_DEVAD, MDIO_PMA_REG_CTRL, 0x2040);\n\tbnx2x_cl45_write(bp, phy,\n\t\t\t MDIO_PMA_DEVAD, MDIO_PMA_REG_10G_CTRL2, 0x000b);\n\tbnx2x_cl45_write(bp, phy,\n\t\t\t MDIO_PMA_DEVAD, MDIO_PMA_REG_BCM_CTRL, 0x0000);\n\tbnx2x_cl45_write(bp, phy,\n\t\t\t MDIO_AN_DEVAD, MDIO_AN_REG_CTRL, 0x0000);\n}\n\nstatic void bnx2x_8073_set_pause_cl37(struct link_params *params,\n\t\t\t\t      struct bnx2x_phy *phy,\n\t\t\t\t      struct link_vars *vars)\n{\n\tu16 cl37_val;\n\tstruct bnx2x *bp = params->bp;\n\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_AN_DEVAD, MDIO_AN_REG_CL37_FC_LD, &cl37_val);\n\n\tcl37_val &= ~MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_BOTH;\n\t \n\tbnx2x_calc_ieee_aneg_adv(phy, params, &vars->ieee_fc);\n\tif ((vars->ieee_fc &\n\t    MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_SYMMETRIC) ==\n\t    MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_SYMMETRIC) {\n\t\tcl37_val |=  MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_SYMMETRIC;\n\t}\n\tif ((vars->ieee_fc &\n\t    MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_ASYMMETRIC) ==\n\t    MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_ASYMMETRIC) {\n\t\tcl37_val |=  MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_ASYMMETRIC;\n\t}\n\tif ((vars->ieee_fc &\n\t    MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_BOTH) ==\n\t    MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_BOTH) {\n\t\tcl37_val |= MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_BOTH;\n\t}\n\tDP(NETIF_MSG_LINK,\n\t\t \"Ext phy AN advertize cl37 0x%x\\n\", cl37_val);\n\n\tbnx2x_cl45_write(bp, phy,\n\t\t\t MDIO_AN_DEVAD, MDIO_AN_REG_CL37_FC_LD, cl37_val);\n\tmsleep(500);\n}\n\nstatic void bnx2x_8073_specific_func(struct bnx2x_phy *phy,\n\t\t\t\t     struct link_params *params,\n\t\t\t\t     u32 action)\n{\n\tstruct bnx2x *bp = params->bp;\n\tswitch (action) {\n\tcase PHY_INIT:\n\t\t \n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_PMA_DEVAD, MDIO_PMA_LASI_RXCTRL, (1<<2));\n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_PMA_DEVAD, MDIO_PMA_LASI_CTRL,  0x0004);\n\t\tbreak;\n\t}\n}\n\nstatic void bnx2x_8073_config_init(struct bnx2x_phy *phy,\n\t\t\t\t   struct link_params *params,\n\t\t\t\t   struct link_vars *vars)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu16 val = 0, tmp1;\n\tu8 gpio_port;\n\tDP(NETIF_MSG_LINK, \"Init 8073\\n\");\n\n\tif (CHIP_IS_E2(bp))\n\t\tgpio_port = BP_PATH(bp);\n\telse\n\t\tgpio_port = params->port;\n\t \n\tbnx2x_set_gpio(bp, MISC_REGISTERS_GPIO_2,\n\t\t       MISC_REGISTERS_GPIO_OUTPUT_HIGH, gpio_port);\n\n\tbnx2x_set_gpio(bp, MISC_REGISTERS_GPIO_1,\n\t\t       MISC_REGISTERS_GPIO_OUTPUT_HIGH, gpio_port);\n\n\tbnx2x_8073_specific_func(phy, params, PHY_INIT);\n\tbnx2x_8073_set_pause_cl37(params, phy, vars);\n\n\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_PMA_DEVAD, MDIO_PMA_REG_M8051_MSGOUT_REG, &tmp1);\n\n\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_PMA_DEVAD, MDIO_PMA_LASI_RXSTAT, &tmp1);\n\n\tDP(NETIF_MSG_LINK, \"Before rom RX_ALARM(port1): 0x%x\\n\", tmp1);\n\n\t \n\tif (params->lane_config & PORT_HW_CFG_SWAP_PHY_POLARITY_ENABLED) {\n\t\t \n\t\tDP(NETIF_MSG_LINK, \"Swapping polarity for the 8073\\n\");\n\t\t \n\t\tbnx2x_cl45_read(bp, phy,\n\t\t\t\tMDIO_PMA_DEVAD,\n\t\t\t\tMDIO_PMA_REG_8073_OPT_DIGITAL_CTRL, &val);\n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_PMA_DEVAD,\n\t\t\t\t MDIO_PMA_REG_8073_OPT_DIGITAL_CTRL,\n\t\t\t\t (val | (3<<9)));\n\t}\n\n\n\t \n\tif (REG_RD(bp, params->shmem_base +\n\t\t\t offsetof(struct shmem_region, dev_info.\n\t\t\t\t  port_hw_config[params->port].default_cfg)) &\n\t    PORT_HW_CFG_ENABLE_BAM_ON_KR_ENABLED) {\n\n\t\tbnx2x_cl45_read(bp, phy,\n\t\t\t\tMDIO_AN_DEVAD,\n\t\t\t\tMDIO_AN_REG_8073_BAM, &val);\n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_AN_DEVAD,\n\t\t\t\t MDIO_AN_REG_8073_BAM, val | 1);\n\t\tDP(NETIF_MSG_LINK, \"Enable CL37 BAM on KR\\n\");\n\t}\n\tif (params->loopback_mode == LOOPBACK_EXT) {\n\t\tbnx2x_807x_force_10G(bp, phy);\n\t\tDP(NETIF_MSG_LINK, \"Forced speed 10G on 807X\\n\");\n\t\treturn;\n\t} else {\n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_PMA_DEVAD, MDIO_PMA_REG_BCM_CTRL, 0x0002);\n\t}\n\tif (phy->req_line_speed != SPEED_AUTO_NEG) {\n\t\tif (phy->req_line_speed == SPEED_10000) {\n\t\t\tval = (1<<7);\n\t\t} else if (phy->req_line_speed ==  SPEED_2500) {\n\t\t\tval = (1<<5);\n\t\t\t \n\t\t} else\n\t\t\tval = (1<<5);\n\t} else {\n\t\tval = 0;\n\t\tif (phy->speed_cap_mask &\n\t\t\tPORT_HW_CFG_SPEED_CAPABILITY_D0_10G)\n\t\t\tval |= (1<<7);\n\n\t\t \n\t\tif (phy->speed_cap_mask &\n\t\t\t(PORT_HW_CFG_SPEED_CAPABILITY_D0_1G |\n\t\t\t PORT_HW_CFG_SPEED_CAPABILITY_D0_2_5G))\n\t\t\tval |= (1<<5);\n\t\tDP(NETIF_MSG_LINK, \"807x autoneg val = 0x%x\\n\", val);\n\t}\n\n\tbnx2x_cl45_write(bp, phy, MDIO_AN_DEVAD, MDIO_AN_REG_ADV, val);\n\tbnx2x_cl45_read(bp, phy, MDIO_AN_DEVAD, MDIO_AN_REG_8073_2_5G, &tmp1);\n\n\tif (((phy->speed_cap_mask & PORT_HW_CFG_SPEED_CAPABILITY_D0_2_5G) &&\n\t     (phy->req_line_speed == SPEED_AUTO_NEG)) ||\n\t    (phy->req_line_speed == SPEED_2500)) {\n\t\tu16 phy_ver;\n\t\t \n\t\tbnx2x_cl45_read(bp, phy,\n\t\t\t\tMDIO_PMA_DEVAD, MDIO_PMA_REG_8073_CHIP_REV,\n\t\t\t\t&phy_ver);\n\t\tDP(NETIF_MSG_LINK, \"Add 2.5G\\n\");\n\t\tif (phy_ver > 0)\n\t\t\ttmp1 |= 1;\n\t\telse\n\t\t\ttmp1 &= 0xfffe;\n\t} else {\n\t\tDP(NETIF_MSG_LINK, \"Disable 2.5G\\n\");\n\t\ttmp1 &= 0xfffe;\n\t}\n\n\tbnx2x_cl45_write(bp, phy, MDIO_AN_DEVAD, MDIO_AN_REG_8073_2_5G, tmp1);\n\t \n\n\tbnx2x_cl45_read(bp, phy, MDIO_AN_DEVAD, MDIO_AN_REG_CL37_FC_LD, &tmp1);\n\tbnx2x_cl45_write(bp, phy, MDIO_AN_DEVAD, MDIO_AN_REG_CL37_FC_LD,\n\t\t\t (tmp1 | ((phy->req_duplex == DUPLEX_FULL) ?\n\t\t\t\t  0x20 : 0x40)));\n\n\t \n\tbnx2x_cl45_write(bp, phy, MDIO_AN_DEVAD, MDIO_AN_REG_CL37_AN, 0x1000);\n\n\t \n\tif (bnx2x_8073_is_snr_needed(bp, phy))\n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_PMA_DEVAD, MDIO_PMA_REG_EDC_FFE_MAIN,\n\t\t\t\t 0xFB0C);\n\n\t \n\tbnx2x_cl45_read(bp, phy, MDIO_AN_DEVAD, MDIO_AN_REG_ADV2, &tmp1);\n\ttmp1 |= (1<<15);\n\tbnx2x_cl45_write(bp, phy, MDIO_AN_DEVAD, MDIO_AN_REG_ADV2, tmp1);\n\n\tbnx2x_ext_phy_set_pause(params, phy, vars);\n\n\t \n\tmsleep(500);\n\tbnx2x_cl45_write(bp, phy, MDIO_AN_DEVAD, MDIO_AN_REG_CTRL, 0x1200);\n\tDP(NETIF_MSG_LINK, \"807x Autoneg Restart: Advertise 1G=%x, 10G=%x\\n\",\n\t\t   ((val & (1<<5)) > 0), ((val & (1<<7)) > 0));\n}\n\nstatic u8 bnx2x_8073_read_status(struct bnx2x_phy *phy,\n\t\t\t\t struct link_params *params,\n\t\t\t\t struct link_vars *vars)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu8 link_up = 0;\n\tu16 val1, val2;\n\tu16 link_status = 0;\n\tu16 an1000_status = 0;\n\n\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_PMA_DEVAD, MDIO_PMA_LASI_STAT, &val1);\n\n\tDP(NETIF_MSG_LINK, \"8703 LASI status 0x%x\\n\", val1);\n\n\t \n\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_PCS_DEVAD, MDIO_PCS_REG_STATUS, &val2);\n\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_PCS_DEVAD, MDIO_PCS_REG_STATUS, &val1);\n\tDP(NETIF_MSG_LINK, \"807x PCS status 0x%x->0x%x\\n\", val2, val1);\n\t \n\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_PMA_DEVAD, MDIO_PMA_REG_M8051_MSGOUT_REG, &val1);\n\n\t \n\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_PMA_DEVAD, MDIO_PMA_LASI_RXSTAT, &val2);\n\n\tDP(NETIF_MSG_LINK, \"KR 0x9003 0x%x\\n\", val2);\n\n\t \n\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_PCS_DEVAD, MDIO_PCS_REG_STATUS, &val2);\n\tDP(NETIF_MSG_LINK, \"KR PCS status 0x%x\\n\", val2);\n\n\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_PMA_DEVAD, MDIO_PMA_REG_STATUS, &val2);\n\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_PMA_DEVAD, MDIO_PMA_REG_STATUS, &val1);\n\tlink_up = ((val1 & 4) == 4);\n\tDP(NETIF_MSG_LINK, \"PMA_REG_STATUS=0x%x\\n\", val1);\n\n\tif (link_up &&\n\t     ((phy->req_line_speed != SPEED_10000))) {\n\t\tif (bnx2x_8073_xaui_wa(bp, phy) != 0)\n\t\t\treturn 0;\n\t}\n\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_AN_DEVAD, MDIO_AN_REG_LINK_STATUS, &an1000_status);\n\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_AN_DEVAD, MDIO_AN_REG_LINK_STATUS, &an1000_status);\n\n\t \n\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_PMA_DEVAD, MDIO_PMA_REG_STATUS, &val2);\n\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_PMA_DEVAD, MDIO_PMA_REG_STATUS, &val1);\n\tDP(NETIF_MSG_LINK, \"KR PMA status 0x%x->0x%x,\"\n\t\t   \"an_link_status=0x%x\\n\", val2, val1, an1000_status);\n\n\tlink_up = (((val1 & 4) == 4) || (an1000_status & (1<<1)));\n\tif (link_up && bnx2x_8073_is_snr_needed(bp, phy)) {\n\t\t \n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_PMA_DEVAD, MDIO_PMA_REG_PLL_BANDWIDTH,\n\t\t\t\t 0x26BC);\n\n\t\t \n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_PMA_DEVAD, MDIO_PMA_REG_CDR_BANDWIDTH,\n\t\t\t\t 0x0333);\n\t}\n\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_PMA_DEVAD, MDIO_PMA_REG_8073_SPEED_LINK_STATUS,\n\t\t\t&link_status);\n\n\t \n\tif ((link_status & (1<<2)) && (!(link_status & (1<<15)))) {\n\t\tlink_up = 1;\n\t\tvars->line_speed = SPEED_10000;\n\t\tDP(NETIF_MSG_LINK, \"port %x: External link up in 10G\\n\",\n\t\t\t   params->port);\n\t} else if ((link_status & (1<<1)) && (!(link_status & (1<<14)))) {\n\t\tlink_up = 1;\n\t\tvars->line_speed = SPEED_2500;\n\t\tDP(NETIF_MSG_LINK, \"port %x: External link up in 2.5G\\n\",\n\t\t\t   params->port);\n\t} else if ((link_status & (1<<0)) && (!(link_status & (1<<13)))) {\n\t\tlink_up = 1;\n\t\tvars->line_speed = SPEED_1000;\n\t\tDP(NETIF_MSG_LINK, \"port %x: External link up in 1G\\n\",\n\t\t\t   params->port);\n\t} else {\n\t\tlink_up = 0;\n\t\tDP(NETIF_MSG_LINK, \"port %x: External link is down\\n\",\n\t\t\t   params->port);\n\t}\n\n\tif (link_up) {\n\t\t \n\t\tif (params->lane_config &\n\t\t    PORT_HW_CFG_SWAP_PHY_POLARITY_ENABLED) {\n\t\t\t \n\t\t\tbnx2x_cl45_read(bp, phy,\n\t\t\t\t\tMDIO_XS_DEVAD,\n\t\t\t\t\tMDIO_XS_REG_8073_RX_CTRL_PCIE, &val1);\n\t\t\t \n\t\t\tif (vars->line_speed == SPEED_1000) {\n\t\t\t\tDP(NETIF_MSG_LINK, \"Swapping 1G polarity for\"\n\t\t\t\t\t      \"the 8073\\n\");\n\t\t\t\tval1 |= (1<<3);\n\t\t\t} else\n\t\t\t\tval1 &= ~(1<<3);\n\n\t\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t\t MDIO_XS_DEVAD,\n\t\t\t\t\t MDIO_XS_REG_8073_RX_CTRL_PCIE,\n\t\t\t\t\t val1);\n\t\t}\n\t\tbnx2x_ext_phy_10G_an_resolve(bp, phy, vars);\n\t\tbnx2x_8073_resolve_fc(phy, params, vars);\n\t\tvars->duplex = DUPLEX_FULL;\n\t}\n\n\tif (vars->link_status & LINK_STATUS_AUTO_NEGOTIATE_COMPLETE) {\n\t\tbnx2x_cl45_read(bp, phy, MDIO_AN_DEVAD,\n\t\t\t\tMDIO_AN_REG_LP_AUTO_NEG2, &val1);\n\n\t\tif (val1 & (1<<5))\n\t\t\tvars->link_status |=\n\t\t\t\tLINK_STATUS_LINK_PARTNER_1000TFD_CAPABLE;\n\t\tif (val1 & (1<<7))\n\t\t\tvars->link_status |=\n\t\t\t\tLINK_STATUS_LINK_PARTNER_10GXFD_CAPABLE;\n\t}\n\n\treturn link_up;\n}\n\nstatic void bnx2x_8073_link_reset(struct bnx2x_phy *phy,\n\t\t\t\t  struct link_params *params)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu8 gpio_port;\n\tif (CHIP_IS_E2(bp))\n\t\tgpio_port = BP_PATH(bp);\n\telse\n\t\tgpio_port = params->port;\n\tDP(NETIF_MSG_LINK, \"Setting 8073 port %d into low power mode\\n\",\n\t   gpio_port);\n\tbnx2x_set_gpio(bp, MISC_REGISTERS_GPIO_2,\n\t\t       MISC_REGISTERS_GPIO_OUTPUT_LOW,\n\t\t       gpio_port);\n}\n\n \n \n \nstatic void bnx2x_8705_config_init(struct bnx2x_phy *phy,\n\t\t\t\t   struct link_params *params,\n\t\t\t\t   struct link_vars *vars)\n{\n\tstruct bnx2x *bp = params->bp;\n\tDP(NETIF_MSG_LINK, \"init 8705\\n\");\n\t \n\tbnx2x_set_gpio(bp, MISC_REGISTERS_GPIO_2,\n\t\t       MISC_REGISTERS_GPIO_OUTPUT_HIGH, params->port);\n\t \n\tbnx2x_ext_phy_hw_reset(bp, params->port);\n\tbnx2x_cl45_write(bp, phy, MDIO_PMA_DEVAD, MDIO_PMA_REG_CTRL, 0xa040);\n\tbnx2x_wait_reset_complete(bp, phy, params);\n\n\tbnx2x_cl45_write(bp, phy,\n\t\t\t MDIO_PMA_DEVAD, MDIO_PMA_REG_MISC_CTRL, 0x8288);\n\tbnx2x_cl45_write(bp, phy,\n\t\t\t MDIO_PMA_DEVAD, MDIO_PMA_REG_PHY_IDENTIFIER, 0x7fbf);\n\tbnx2x_cl45_write(bp, phy,\n\t\t\t MDIO_PMA_DEVAD, MDIO_PMA_REG_CMU_PLL_BYPASS, 0x0100);\n\tbnx2x_cl45_write(bp, phy,\n\t\t\t MDIO_WIS_DEVAD, MDIO_WIS_REG_LASI_CNTL, 0x1);\n\t \n\tbnx2x_save_spirom_version(bp, params->port, params->shmem_base, 0);\n}\n\nstatic u8 bnx2x_8705_read_status(struct bnx2x_phy *phy,\n\t\t\t\t struct link_params *params,\n\t\t\t\t struct link_vars *vars)\n{\n\tu8 link_up = 0;\n\tu16 val1, rx_sd;\n\tstruct bnx2x *bp = params->bp;\n\tDP(NETIF_MSG_LINK, \"read status 8705\\n\");\n\tbnx2x_cl45_read(bp, phy,\n\t\t      MDIO_WIS_DEVAD, MDIO_WIS_REG_LASI_STATUS, &val1);\n\tDP(NETIF_MSG_LINK, \"8705 LASI status 0x%x\\n\", val1);\n\n\tbnx2x_cl45_read(bp, phy,\n\t\t      MDIO_WIS_DEVAD, MDIO_WIS_REG_LASI_STATUS, &val1);\n\tDP(NETIF_MSG_LINK, \"8705 LASI status 0x%x\\n\", val1);\n\n\tbnx2x_cl45_read(bp, phy,\n\t\t      MDIO_PMA_DEVAD, MDIO_PMA_REG_RX_SD, &rx_sd);\n\n\tbnx2x_cl45_read(bp, phy,\n\t\t      MDIO_PMA_DEVAD, 0xc809, &val1);\n\tbnx2x_cl45_read(bp, phy,\n\t\t      MDIO_PMA_DEVAD, 0xc809, &val1);\n\n\tDP(NETIF_MSG_LINK, \"8705 1.c809 val=0x%x\\n\", val1);\n\tlink_up = ((rx_sd & 0x1) && (val1 & (1<<9)) && ((val1 & (1<<8)) == 0));\n\tif (link_up) {\n\t\tvars->line_speed = SPEED_10000;\n\t\tbnx2x_ext_phy_resolve_fc(phy, params, vars);\n\t}\n\treturn link_up;\n}\n\n \n \n \nstatic void bnx2x_set_disable_pmd_transmit(struct link_params *params,\n\t\t\t\t\t   struct bnx2x_phy *phy,\n\t\t\t\t\t   u8 pmd_dis)\n{\n\tstruct bnx2x *bp = params->bp;\n\t \n\tif (pmd_dis) {\n\t\tif (params->feature_config_flags &\n\t\t     FEATURE_CONFIG_BC_SUPPORTS_SFP_TX_DISABLED)\n\t\t\tDP(NETIF_MSG_LINK, \"Disabling PMD transmitter\\n\");\n\t\telse {\n\t\t\tDP(NETIF_MSG_LINK, \"NOT disabling PMD transmitter\\n\");\n\t\t\treturn;\n\t\t}\n\t} else\n\t\tDP(NETIF_MSG_LINK, \"Enabling PMD transmitter\\n\");\n\tbnx2x_cl45_write(bp, phy,\n\t\t\t MDIO_PMA_DEVAD,\n\t\t\t MDIO_PMA_REG_TX_DISABLE, pmd_dis);\n}\n\nstatic u8 bnx2x_get_gpio_port(struct link_params *params)\n{\n\tu8 gpio_port;\n\tu32 swap_val, swap_override;\n\tstruct bnx2x *bp = params->bp;\n\tif (CHIP_IS_E2(bp))\n\t\tgpio_port = BP_PATH(bp);\n\telse\n\t\tgpio_port = params->port;\n\tswap_val = REG_RD(bp, NIG_REG_PORT_SWAP);\n\tswap_override = REG_RD(bp, NIG_REG_STRAP_OVERRIDE);\n\treturn gpio_port ^ (swap_val && swap_override);\n}\n\nstatic void bnx2x_sfp_e1e2_set_transmitter(struct link_params *params,\n\t\t\t\t\t   struct bnx2x_phy *phy,\n\t\t\t\t\t   u8 tx_en)\n{\n\tu16 val;\n\tu8 port = params->port;\n\tstruct bnx2x *bp = params->bp;\n\tu32 tx_en_mode;\n\n\t \n\ttx_en_mode = REG_RD(bp, params->shmem_base +\n\t\t\t    offsetof(struct shmem_region,\n\t\t\t\t     dev_info.port_hw_config[port].sfp_ctrl)) &\n\t\tPORT_HW_CFG_TX_LASER_MASK;\n\tDP(NETIF_MSG_LINK, \"Setting transmitter tx_en=%x for port %x \"\n\t\t\t   \"mode = %x\\n\", tx_en, port, tx_en_mode);\n\tswitch (tx_en_mode) {\n\tcase PORT_HW_CFG_TX_LASER_MDIO:\n\n\t\tbnx2x_cl45_read(bp, phy,\n\t\t\t\tMDIO_PMA_DEVAD,\n\t\t\t\tMDIO_PMA_REG_PHY_IDENTIFIER,\n\t\t\t\t&val);\n\n\t\tif (tx_en)\n\t\t\tval &= ~(1<<15);\n\t\telse\n\t\t\tval |= (1<<15);\n\n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_PMA_DEVAD,\n\t\t\t\t MDIO_PMA_REG_PHY_IDENTIFIER,\n\t\t\t\t val);\n\tbreak;\n\tcase PORT_HW_CFG_TX_LASER_GPIO0:\n\tcase PORT_HW_CFG_TX_LASER_GPIO1:\n\tcase PORT_HW_CFG_TX_LASER_GPIO2:\n\tcase PORT_HW_CFG_TX_LASER_GPIO3:\n\t{\n\t\tu16 gpio_pin;\n\t\tu8 gpio_port, gpio_mode;\n\t\tif (tx_en)\n\t\t\tgpio_mode = MISC_REGISTERS_GPIO_OUTPUT_HIGH;\n\t\telse\n\t\t\tgpio_mode = MISC_REGISTERS_GPIO_OUTPUT_LOW;\n\n\t\tgpio_pin = tx_en_mode - PORT_HW_CFG_TX_LASER_GPIO0;\n\t\tgpio_port = bnx2x_get_gpio_port(params);\n\t\tbnx2x_set_gpio(bp, gpio_pin, gpio_mode, gpio_port);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tDP(NETIF_MSG_LINK, \"Invalid TX_LASER_MDIO 0x%x\\n\", tx_en_mode);\n\t\tbreak;\n\t}\n}\n\nstatic void bnx2x_sfp_set_transmitter(struct link_params *params,\n\t\t\t\t      struct bnx2x_phy *phy,\n\t\t\t\t      u8 tx_en)\n{\n\tstruct bnx2x *bp = params->bp;\n\tDP(NETIF_MSG_LINK, \"Setting SFP+ transmitter to %d\\n\", tx_en);\n\tif (CHIP_IS_E3(bp))\n\t\tbnx2x_sfp_e3_set_transmitter(params, phy, tx_en);\n\telse\n\t\tbnx2x_sfp_e1e2_set_transmitter(params, phy, tx_en);\n}\n\nstatic int bnx2x_8726_read_sfp_module_eeprom(struct bnx2x_phy *phy,\n\t\t\t\t\t     struct link_params *params,\n\t\t\t\t\t     u8 dev_addr, u16 addr, u8 byte_cnt,\n\t\t\t\t\t     u8 *o_buf, u8 is_init)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu16 val = 0;\n\tu16 i;\n\tif (byte_cnt > SFP_EEPROM_PAGE_SIZE) {\n\t\tDP(NETIF_MSG_LINK,\n\t\t   \"Reading from eeprom is limited to 0xf\\n\");\n\t\treturn -EINVAL;\n\t}\n\t \n\tbnx2x_cl45_write(bp, phy,\n\t\t\t MDIO_PMA_DEVAD, MDIO_PMA_REG_SFP_TWO_WIRE_BYTE_CNT,\n\t\t\t (byte_cnt | (dev_addr << 8)));\n\n\t \n\tbnx2x_cl45_write(bp, phy,\n\t\t\t MDIO_PMA_DEVAD, MDIO_PMA_REG_SFP_TWO_WIRE_MEM_ADDR,\n\t\t\t addr);\n\n\t \n\tbnx2x_cl45_write(bp, phy,\n\t\t\t MDIO_PMA_DEVAD, MDIO_PMA_REG_SFP_TWO_WIRE_CTRL,\n\t\t\t 0x2c0f);\n\n\t \n\tfor (i = 0; i < 100; i++) {\n\t\tbnx2x_cl45_read(bp, phy,\n\t\t\t\tMDIO_PMA_DEVAD,\n\t\t\t\tMDIO_PMA_REG_SFP_TWO_WIRE_CTRL, &val);\n\t\tif ((val & MDIO_PMA_REG_SFP_TWO_WIRE_CTRL_STATUS_MASK) ==\n\t\t    MDIO_PMA_REG_SFP_TWO_WIRE_STATUS_COMPLETE)\n\t\t\tbreak;\n\t\tudelay(5);\n\t}\n\n\tif ((val & MDIO_PMA_REG_SFP_TWO_WIRE_CTRL_STATUS_MASK) !=\n\t\t    MDIO_PMA_REG_SFP_TWO_WIRE_STATUS_COMPLETE) {\n\t\tDP(NETIF_MSG_LINK,\n\t\t\t \"Got bad status 0x%x when reading from SFP+ EEPROM\\n\",\n\t\t\t (val & MDIO_PMA_REG_SFP_TWO_WIRE_CTRL_STATUS_MASK));\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tfor (i = 0; i < byte_cnt; i++) {\n\t\tbnx2x_cl45_read(bp, phy,\n\t\t\t\tMDIO_PMA_DEVAD,\n\t\t\t\tMDIO_PMA_REG_8726_TWO_WIRE_DATA_BUF + i, &val);\n\t\to_buf[i] = (u8)(val & MDIO_PMA_REG_8726_TWO_WIRE_DATA_MASK);\n\t}\n\n\tfor (i = 0; i < 100; i++) {\n\t\tbnx2x_cl45_read(bp, phy,\n\t\t\t\tMDIO_PMA_DEVAD,\n\t\t\t\tMDIO_PMA_REG_SFP_TWO_WIRE_CTRL, &val);\n\t\tif ((val & MDIO_PMA_REG_SFP_TWO_WIRE_CTRL_STATUS_MASK) ==\n\t\t    MDIO_PMA_REG_SFP_TWO_WIRE_STATUS_IDLE)\n\t\t\treturn 0;\n\t\tusleep_range(1000, 2000);\n\t}\n\treturn -EINVAL;\n}\n\nstatic void bnx2x_warpcore_power_module(struct link_params *params,\n\t\t\t\t\tu8 power)\n{\n\tu32 pin_cfg;\n\tstruct bnx2x *bp = params->bp;\n\n\tpin_cfg = (REG_RD(bp, params->shmem_base +\n\t\t\t  offsetof(struct shmem_region,\n\t\t\tdev_info.port_hw_config[params->port].e3_sfp_ctrl)) &\n\t\t\tPORT_HW_CFG_E3_PWR_DIS_MASK) >>\n\t\t\tPORT_HW_CFG_E3_PWR_DIS_SHIFT;\n\n\tif (pin_cfg == PIN_CFG_NA)\n\t\treturn;\n\tDP(NETIF_MSG_LINK, \"Setting SFP+ module power to %d using pin cfg %d\\n\",\n\t\t       power, pin_cfg);\n\t \n\tbnx2x_set_cfg_pin(bp, pin_cfg, power ^ 1);\n}\nstatic int bnx2x_warpcore_read_sfp_module_eeprom(struct bnx2x_phy *phy,\n\t\t\t\t\t\t struct link_params *params,\n\t\t\t\t\t\t u8 dev_addr,\n\t\t\t\t\t\t u16 addr, u8 byte_cnt,\n\t\t\t\t\t\t u8 *o_buf, u8 is_init)\n{\n\tint rc = 0;\n\tu8 i, j = 0, cnt = 0;\n\tu32 data_array[4];\n\tu16 addr32;\n\tstruct bnx2x *bp = params->bp;\n\n\tif (byte_cnt > SFP_EEPROM_PAGE_SIZE) {\n\t\tDP(NETIF_MSG_LINK,\n\t\t   \"Reading from eeprom is limited to 16 bytes\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\taddr32 = addr & (~0x3);\n\tdo {\n\t\tif ((!is_init) && (cnt == I2C_WA_PWR_ITER)) {\n\t\t\tbnx2x_warpcore_power_module(params, 0);\n\t\t\t \n\t\t\tusleep_range(1000, 2000);\n\t\t\tbnx2x_warpcore_power_module(params, 1);\n\t\t}\n\t\trc = bnx2x_bsc_read(params, bp, dev_addr, addr32, 0, byte_cnt,\n\t\t\t\t    data_array);\n\t} while ((rc != 0) && (++cnt < I2C_WA_RETRY_CNT));\n\n\tif (rc == 0) {\n\t\tfor (i = (addr - addr32); i < byte_cnt + (addr - addr32); i++) {\n\t\t\to_buf[j] = *((u8 *)data_array + i);\n\t\t\tj++;\n\t\t}\n\t}\n\n\treturn rc;\n}\n\nstatic int bnx2x_8727_read_sfp_module_eeprom(struct bnx2x_phy *phy,\n\t\t\t\t\t     struct link_params *params,\n\t\t\t\t\t     u8 dev_addr, u16 addr, u8 byte_cnt,\n\t\t\t\t\t     u8 *o_buf, u8 is_init)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu16 val, i;\n\n\tif (byte_cnt > SFP_EEPROM_PAGE_SIZE) {\n\t\tDP(NETIF_MSG_LINK,\n\t\t   \"Reading from eeprom is limited to 0xf\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tbnx2x_cl45_write(bp, phy,\n\t\t\t MDIO_PMA_DEVAD,\n\t\t\t MDIO_PMA_REG_8727_TWO_WIRE_SLAVE_ADDR,\n\t\t\t ((dev_addr << 8) | 1));\n\n\t \n\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_PMA_DEVAD,\n\t\t\tMDIO_PMA_REG_SFP_TWO_WIRE_CTRL,\n\t\t\t&val);\n\n\t \n\tbnx2x_cl45_write(bp, phy,\n\t\t\t MDIO_PMA_DEVAD,\n\t\t\t MDIO_PMA_REG_SFP_TWO_WIRE_BYTE_CNT,\n\t\t\t ((byte_cnt < 2) ? 2 : byte_cnt));\n\n\t \n\tbnx2x_cl45_write(bp, phy,\n\t\t\t MDIO_PMA_DEVAD,\n\t\t\t MDIO_PMA_REG_SFP_TWO_WIRE_MEM_ADDR,\n\t\t\t addr);\n\t \n\tbnx2x_cl45_write(bp, phy,\n\t\t\t MDIO_PMA_DEVAD,\n\t\t\t 0x8004,\n\t\t\t MDIO_PMA_REG_8727_TWO_WIRE_DATA_BUF);\n\n\t \n\tbnx2x_cl45_write(bp, phy,\n\t\t\t MDIO_PMA_DEVAD,\n\t\t\t MDIO_PMA_REG_SFP_TWO_WIRE_CTRL,\n\t\t\t 0x8002);\n\t \n\tusleep_range(1000, 2000);\n\n\t \n\tfor (i = 0; i < 100; i++) {\n\t\tbnx2x_cl45_read(bp, phy,\n\t\t\t\tMDIO_PMA_DEVAD,\n\t\t\t\tMDIO_PMA_REG_SFP_TWO_WIRE_CTRL, &val);\n\t\tif ((val & MDIO_PMA_REG_SFP_TWO_WIRE_CTRL_STATUS_MASK) ==\n\t\t    MDIO_PMA_REG_SFP_TWO_WIRE_STATUS_COMPLETE)\n\t\t\tbreak;\n\t\tudelay(5);\n\t}\n\n\tif ((val & MDIO_PMA_REG_SFP_TWO_WIRE_CTRL_STATUS_MASK) !=\n\t\t    MDIO_PMA_REG_SFP_TWO_WIRE_STATUS_COMPLETE) {\n\t\tDP(NETIF_MSG_LINK,\n\t\t\t \"Got bad status 0x%x when reading from SFP+ EEPROM\\n\",\n\t\t\t (val & MDIO_PMA_REG_SFP_TWO_WIRE_CTRL_STATUS_MASK));\n\t\treturn -EFAULT;\n\t}\n\n\t \n\tfor (i = 0; i < byte_cnt; i++) {\n\t\tbnx2x_cl45_read(bp, phy,\n\t\t\t\tMDIO_PMA_DEVAD,\n\t\t\t\tMDIO_PMA_REG_8727_TWO_WIRE_DATA_BUF + i, &val);\n\t\to_buf[i] = (u8)(val & MDIO_PMA_REG_8727_TWO_WIRE_DATA_MASK);\n\t}\n\n\tfor (i = 0; i < 100; i++) {\n\t\tbnx2x_cl45_read(bp, phy,\n\t\t\t\tMDIO_PMA_DEVAD,\n\t\t\t\tMDIO_PMA_REG_SFP_TWO_WIRE_CTRL, &val);\n\t\tif ((val & MDIO_PMA_REG_SFP_TWO_WIRE_CTRL_STATUS_MASK) ==\n\t\t    MDIO_PMA_REG_SFP_TWO_WIRE_STATUS_IDLE)\n\t\t\treturn 0;\n\t\tusleep_range(1000, 2000);\n\t}\n\n\treturn -EINVAL;\n}\nint bnx2x_read_sfp_module_eeprom(struct bnx2x_phy *phy,\n\t\t\t\t struct link_params *params, u8 dev_addr,\n\t\t\t\t u16 addr, u16 byte_cnt, u8 *o_buf)\n{\n\tint rc = 0;\n\tstruct bnx2x *bp = params->bp;\n\tu8 xfer_size;\n\tu8 *user_data = o_buf;\n\tread_sfp_module_eeprom_func_p read_func;\n\n\tif ((dev_addr != 0xa0) && (dev_addr != 0xa2)) {\n\t\tDP(NETIF_MSG_LINK, \"invalid dev_addr 0x%x\\n\", dev_addr);\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (phy->type) {\n\tcase PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8726:\n\t\tread_func = bnx2x_8726_read_sfp_module_eeprom;\n\t\tbreak;\n\tcase PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8727:\n\tcase PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8722:\n\t\tread_func = bnx2x_8727_read_sfp_module_eeprom;\n\t\tbreak;\n\tcase PORT_HW_CFG_XGXS_EXT_PHY_TYPE_DIRECT:\n\t\tread_func = bnx2x_warpcore_read_sfp_module_eeprom;\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\twhile (!rc && (byte_cnt > 0)) {\n\t\txfer_size = (byte_cnt > SFP_EEPROM_PAGE_SIZE) ?\n\t\t\tSFP_EEPROM_PAGE_SIZE : byte_cnt;\n\t\trc = read_func(phy, params, dev_addr, addr, xfer_size,\n\t\t\t       user_data, 0);\n\t\tbyte_cnt -= xfer_size;\n\t\tuser_data += xfer_size;\n\t\taddr += xfer_size;\n\t}\n\treturn rc;\n}\n\nstatic int bnx2x_get_edc_mode(struct bnx2x_phy *phy,\n\t\t\t      struct link_params *params,\n\t\t\t      u16 *edc_mode)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu32 sync_offset = 0, phy_idx, media_types;\n\tu8 val[SFP_EEPROM_FC_TX_TECH_ADDR + 1], check_limiting_mode = 0;\n\t*edc_mode = EDC_MODE_LIMITING;\n\tphy->media_type = ETH_PHY_UNSPECIFIED;\n\t \n\tif (bnx2x_read_sfp_module_eeprom(phy,\n\t\t\t\t\t params,\n\t\t\t\t\t I2C_DEV_ADDR_A0,\n\t\t\t\t\t 0,\n\t\t\t\t\t SFP_EEPROM_FC_TX_TECH_ADDR + 1,\n\t\t\t\t\t (u8 *)val) != 0) {\n\t\tDP(NETIF_MSG_LINK, \"Failed to read from SFP+ module EEPROM\\n\");\n\t\treturn -EINVAL;\n\t}\n\tparams->link_attr_sync &= ~LINK_SFP_EEPROM_COMP_CODE_MASK;\n\tparams->link_attr_sync |= val[SFP_EEPROM_10G_COMP_CODE_ADDR] <<\n\t\tLINK_SFP_EEPROM_COMP_CODE_SHIFT;\n\tbnx2x_update_link_attr(params, params->link_attr_sync);\n\tswitch (val[SFP_EEPROM_CON_TYPE_ADDR]) {\n\tcase SFP_EEPROM_CON_TYPE_VAL_COPPER:\n\t{\n\t\tu8 copper_module_type;\n\t\tphy->media_type = ETH_PHY_DA_TWINAX;\n\t\t \n\t\tcopper_module_type = val[SFP_EEPROM_FC_TX_TECH_ADDR];\n\n\t\tif (copper_module_type &\n\t\t    SFP_EEPROM_FC_TX_TECH_BITMASK_COPPER_ACTIVE) {\n\t\t\tDP(NETIF_MSG_LINK, \"Active Copper cable detected\\n\");\n\t\t\tif (phy->type == PORT_HW_CFG_XGXS_EXT_PHY_TYPE_DIRECT)\n\t\t\t\t*edc_mode = EDC_MODE_ACTIVE_DAC;\n\t\t\telse\n\t\t\t\tcheck_limiting_mode = 1;\n\t\t} else {\n\t\t\t*edc_mode = EDC_MODE_PASSIVE_DAC;\n\t\t\t \n\t\t\tif (copper_module_type &\n\t\t\t    SFP_EEPROM_FC_TX_TECH_BITMASK_COPPER_PASSIVE) {\n\t\t\t\tDP(NETIF_MSG_LINK,\n\t\t\t\t   \"Passive Copper cable detected\\n\");\n\t\t\t} else {\n\t\t\t\tDP(NETIF_MSG_LINK,\n\t\t\t\t   \"Unknown copper-cable-type\\n\");\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\tcase SFP_EEPROM_CON_TYPE_VAL_UNKNOWN:\n\tcase SFP_EEPROM_CON_TYPE_VAL_LC:\n\tcase SFP_EEPROM_CON_TYPE_VAL_RJ45:\n\t\tcheck_limiting_mode = 1;\n\t\tif (((val[SFP_EEPROM_10G_COMP_CODE_ADDR] &\n\t\t     (SFP_EEPROM_10G_COMP_CODE_SR_MASK |\n\t\t      SFP_EEPROM_10G_COMP_CODE_LR_MASK |\n\t\t       SFP_EEPROM_10G_COMP_CODE_LRM_MASK)) == 0) &&\n\t\t    (val[SFP_EEPROM_1G_COMP_CODE_ADDR] != 0)) {\n\t\t\tDP(NETIF_MSG_LINK, \"1G SFP module detected\\n\");\n\t\t\tphy->media_type = ETH_PHY_SFP_1G_FIBER;\n\t\t\tif (phy->req_line_speed != SPEED_1000) {\n\t\t\t\tu8 gport = params->port;\n\t\t\t\tphy->req_line_speed = SPEED_1000;\n\t\t\t\tif (!CHIP_IS_E1x(bp)) {\n\t\t\t\t\tgport = BP_PATH(bp) +\n\t\t\t\t\t(params->port << 1);\n\t\t\t\t}\n\t\t\t\tnetdev_err(bp->dev,\n\t\t\t\t\t   \"Warning: Link speed was forced to 1000Mbps. Current SFP module in port %d is not compliant with 10G Ethernet\\n\",\n\t\t\t\t\t   gport);\n\t\t\t}\n\t\t\tif (val[SFP_EEPROM_1G_COMP_CODE_ADDR] &\n\t\t\t    SFP_EEPROM_1G_COMP_CODE_BASE_T) {\n\t\t\t\tbnx2x_sfp_set_transmitter(params, phy, 0);\n\t\t\t\tmsleep(40);\n\t\t\t\tbnx2x_sfp_set_transmitter(params, phy, 1);\n\t\t\t}\n\t\t} else {\n\t\t\tint idx, cfg_idx = 0;\n\t\t\tDP(NETIF_MSG_LINK, \"10G Optic module detected\\n\");\n\t\t\tfor (idx = INT_PHY; idx < MAX_PHYS; idx++) {\n\t\t\t\tif (params->phy[idx].type == phy->type) {\n\t\t\t\t\tcfg_idx = LINK_CONFIG_IDX(idx);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tphy->media_type = ETH_PHY_SFPP_10G_FIBER;\n\t\t\tphy->req_line_speed = params->req_line_speed[cfg_idx];\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tDP(NETIF_MSG_LINK, \"Unable to determine module type 0x%x !!!\\n\",\n\t\t\t val[SFP_EEPROM_CON_TYPE_ADDR]);\n\t\treturn -EINVAL;\n\t}\n\tsync_offset = params->shmem_base +\n\t\toffsetof(struct shmem_region,\n\t\t\t dev_info.port_hw_config[params->port].media_type);\n\tmedia_types = REG_RD(bp, sync_offset);\n\t \n\tfor (phy_idx = INT_PHY; phy_idx < MAX_PHYS; phy_idx++) {\n\t\tif (&(params->phy[phy_idx]) == phy) {\n\t\t\tmedia_types &= ~(PORT_HW_CFG_MEDIA_TYPE_PHY0_MASK <<\n\t\t\t\t(PORT_HW_CFG_MEDIA_TYPE_PHY1_SHIFT * phy_idx));\n\t\t\tmedia_types |= ((phy->media_type &\n\t\t\t\t\tPORT_HW_CFG_MEDIA_TYPE_PHY0_MASK) <<\n\t\t\t\t(PORT_HW_CFG_MEDIA_TYPE_PHY1_SHIFT * phy_idx));\n\t\t\tbreak;\n\t\t}\n\t}\n\tREG_WR(bp, sync_offset, media_types);\n\tif (check_limiting_mode) {\n\t\tu8 options[SFP_EEPROM_OPTIONS_SIZE];\n\t\tif (bnx2x_read_sfp_module_eeprom(phy,\n\t\t\t\t\t\t params,\n\t\t\t\t\t\t I2C_DEV_ADDR_A0,\n\t\t\t\t\t\t SFP_EEPROM_OPTIONS_ADDR,\n\t\t\t\t\t\t SFP_EEPROM_OPTIONS_SIZE,\n\t\t\t\t\t\t options) != 0) {\n\t\t\tDP(NETIF_MSG_LINK,\n\t\t\t   \"Failed to read Option field from module EEPROM\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif ((options[0] & SFP_EEPROM_OPTIONS_LINEAR_RX_OUT_MASK))\n\t\t\t*edc_mode = EDC_MODE_LINEAR;\n\t\telse\n\t\t\t*edc_mode = EDC_MODE_LIMITING;\n\t}\n\tDP(NETIF_MSG_LINK, \"EDC mode is set to 0x%x\\n\", *edc_mode);\n\treturn 0;\n}\n \nstatic int bnx2x_verify_sfp_module(struct bnx2x_phy *phy,\n\t\t\t\t   struct link_params *params)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu32 val, cmd;\n\tu32 fw_resp, fw_cmd_param;\n\tchar vendor_name[SFP_EEPROM_VENDOR_NAME_SIZE+1];\n\tchar vendor_pn[SFP_EEPROM_PART_NO_SIZE+1];\n\tphy->flags &= ~FLAGS_SFP_NOT_APPROVED;\n\tval = REG_RD(bp, params->shmem_base +\n\t\t\t offsetof(struct shmem_region, dev_info.\n\t\t\t\t  port_feature_config[params->port].config));\n\tif ((val & PORT_FEAT_CFG_OPT_MDL_ENFRCMNT_MASK) ==\n\t    PORT_FEAT_CFG_OPT_MDL_ENFRCMNT_NO_ENFORCEMENT) {\n\t\tDP(NETIF_MSG_LINK, \"NOT enforcing module verification\\n\");\n\t\treturn 0;\n\t}\n\n\tif (params->feature_config_flags &\n\t    FEATURE_CONFIG_BC_SUPPORTS_DUAL_PHY_OPT_MDL_VRFY) {\n\t\t \n\t\tcmd = DRV_MSG_CODE_VRFY_SPECIFIC_PHY_OPT_MDL;\n\t} else if (params->feature_config_flags &\n\t\t   FEATURE_CONFIG_BC_SUPPORTS_OPT_MDL_VRFY) {\n\t\t \n\t\tif (DUAL_MEDIA(params)) {\n\t\t\tDP(NETIF_MSG_LINK,\n\t\t\t   \"FW does not support OPT MDL verification\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tcmd = DRV_MSG_CODE_VRFY_FIRST_PHY_OPT_MDL;\n\t} else {\n\t\t \n\t\tDP(NETIF_MSG_LINK,\n\t\t   \"FW does not support OPT MDL verification\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tfw_cmd_param = FW_PARAM_SET(phy->addr, phy->type, phy->mdio_ctrl);\n\tfw_resp = bnx2x_fw_command(bp, cmd, fw_cmd_param);\n\tif (fw_resp == FW_MSG_CODE_VRFY_OPT_MDL_SUCCESS) {\n\t\tDP(NETIF_MSG_LINK, \"Approved module\\n\");\n\t\treturn 0;\n\t}\n\n\t \n\tif (bnx2x_read_sfp_module_eeprom(phy,\n\t\t\t\t\t params,\n\t\t\t\t\t I2C_DEV_ADDR_A0,\n\t\t\t\t\t SFP_EEPROM_VENDOR_NAME_ADDR,\n\t\t\t\t\t SFP_EEPROM_VENDOR_NAME_SIZE,\n\t\t\t\t\t (u8 *)vendor_name))\n\t\tvendor_name[0] = '\\0';\n\telse\n\t\tvendor_name[SFP_EEPROM_VENDOR_NAME_SIZE] = '\\0';\n\tif (bnx2x_read_sfp_module_eeprom(phy,\n\t\t\t\t\t params,\n\t\t\t\t\t I2C_DEV_ADDR_A0,\n\t\t\t\t\t SFP_EEPROM_PART_NO_ADDR,\n\t\t\t\t\t SFP_EEPROM_PART_NO_SIZE,\n\t\t\t\t\t (u8 *)vendor_pn))\n\t\tvendor_pn[0] = '\\0';\n\telse\n\t\tvendor_pn[SFP_EEPROM_PART_NO_SIZE] = '\\0';\n\n\tnetdev_err(bp->dev,  \"Warning: Unqualified SFP+ module detected,\"\n\t\t\t      \" Port %d from %s part number %s\\n\",\n\t\t\t params->port, vendor_name, vendor_pn);\n\tif ((val & PORT_FEAT_CFG_OPT_MDL_ENFRCMNT_MASK) !=\n\t    PORT_FEAT_CFG_OPT_MDL_ENFRCMNT_WARNING_MSG)\n\t\tphy->flags |= FLAGS_SFP_NOT_APPROVED;\n\treturn -EINVAL;\n}\n\nstatic int bnx2x_wait_for_sfp_module_initialized(struct bnx2x_phy *phy,\n\t\t\t\t\t\t struct link_params *params)\n\n{\n\tu8 val;\n\tint rc;\n\tstruct bnx2x *bp = params->bp;\n\tu16 timeout;\n\t \n\n\tfor (timeout = 0; timeout < 60; timeout++) {\n\t\tif (phy->type == PORT_HW_CFG_XGXS_EXT_PHY_TYPE_DIRECT)\n\t\t\trc = bnx2x_warpcore_read_sfp_module_eeprom(\n\t\t\t\tphy, params, I2C_DEV_ADDR_A0, 1, 1, &val,\n\t\t\t\t1);\n\t\telse\n\t\t\trc = bnx2x_read_sfp_module_eeprom(phy, params,\n\t\t\t\t\t\t\t  I2C_DEV_ADDR_A0,\n\t\t\t\t\t\t\t  1, 1, &val);\n\t\tif (rc == 0) {\n\t\t\tDP(NETIF_MSG_LINK,\n\t\t\t   \"SFP+ module initialization took %d ms\\n\",\n\t\t\t   timeout * 5);\n\t\t\treturn 0;\n\t\t}\n\t\tusleep_range(5000, 10000);\n\t}\n\trc = bnx2x_read_sfp_module_eeprom(phy, params, I2C_DEV_ADDR_A0,\n\t\t\t\t\t  1, 1, &val);\n\treturn rc;\n}\n\nstatic void bnx2x_8727_power_module(struct bnx2x *bp,\n\t\t\t\t    struct bnx2x_phy *phy,\n\t\t\t\t    u8 is_power_up) {\n\t \n\tu16 val;\n\t \n\tif (phy->flags & FLAGS_NOC)\n\t\treturn;\n\tif (is_power_up)\n\t\tval = (1<<4);\n\telse\n\t\t \n\t\tval = (1<<1);\n\n\tbnx2x_cl45_write(bp, phy,\n\t\t\t MDIO_PMA_DEVAD,\n\t\t\t MDIO_PMA_REG_8727_GPIO_CTRL,\n\t\t\t val);\n}\n\nstatic int bnx2x_8726_set_limiting_mode(struct bnx2x *bp,\n\t\t\t\t\tstruct bnx2x_phy *phy,\n\t\t\t\t\tu16 edc_mode)\n{\n\tu16 cur_limiting_mode;\n\n\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_PMA_DEVAD,\n\t\t\tMDIO_PMA_REG_ROM_VER2,\n\t\t\t&cur_limiting_mode);\n\tDP(NETIF_MSG_LINK, \"Current Limiting mode is 0x%x\\n\",\n\t\t cur_limiting_mode);\n\n\tif (edc_mode == EDC_MODE_LIMITING) {\n\t\tDP(NETIF_MSG_LINK, \"Setting LIMITING MODE\\n\");\n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_PMA_DEVAD,\n\t\t\t\t MDIO_PMA_REG_ROM_VER2,\n\t\t\t\t EDC_MODE_LIMITING);\n\t} else {  \n\n\t\tDP(NETIF_MSG_LINK, \"Setting LRM MODE\\n\");\n\n\t\t \n\t\tif (cur_limiting_mode != EDC_MODE_LIMITING)\n\t\t\treturn 0;\n\n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_PMA_DEVAD,\n\t\t\t\t MDIO_PMA_REG_LRM_MODE,\n\t\t\t\t 0);\n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_PMA_DEVAD,\n\t\t\t\t MDIO_PMA_REG_ROM_VER2,\n\t\t\t\t 0x128);\n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_PMA_DEVAD,\n\t\t\t\t MDIO_PMA_REG_MISC_CTRL0,\n\t\t\t\t 0x4008);\n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_PMA_DEVAD,\n\t\t\t\t MDIO_PMA_REG_LRM_MODE,\n\t\t\t\t 0xaaaa);\n\t}\n\treturn 0;\n}\n\nstatic int bnx2x_8727_set_limiting_mode(struct bnx2x *bp,\n\t\t\t\t\tstruct bnx2x_phy *phy,\n\t\t\t\t\tu16 edc_mode)\n{\n\tu16 phy_identifier;\n\tu16 rom_ver2_val;\n\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_PMA_DEVAD,\n\t\t\tMDIO_PMA_REG_PHY_IDENTIFIER,\n\t\t\t&phy_identifier);\n\n\tbnx2x_cl45_write(bp, phy,\n\t\t\t MDIO_PMA_DEVAD,\n\t\t\t MDIO_PMA_REG_PHY_IDENTIFIER,\n\t\t\t (phy_identifier & ~(1<<9)));\n\n\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_PMA_DEVAD,\n\t\t\tMDIO_PMA_REG_ROM_VER2,\n\t\t\t&rom_ver2_val);\n\t \n\tbnx2x_cl45_write(bp, phy,\n\t\t\t MDIO_PMA_DEVAD,\n\t\t\t MDIO_PMA_REG_ROM_VER2,\n\t\t\t (rom_ver2_val & 0xff00) | (edc_mode & 0x00ff));\n\n\tbnx2x_cl45_write(bp, phy,\n\t\t\t MDIO_PMA_DEVAD,\n\t\t\t MDIO_PMA_REG_PHY_IDENTIFIER,\n\t\t\t (phy_identifier | (1<<9)));\n\n\treturn 0;\n}\n\nstatic void bnx2x_8727_specific_func(struct bnx2x_phy *phy,\n\t\t\t\t     struct link_params *params,\n\t\t\t\t     u32 action)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu16 val;\n\tswitch (action) {\n\tcase DISABLE_TX:\n\t\tbnx2x_sfp_set_transmitter(params, phy, 0);\n\t\tbreak;\n\tcase ENABLE_TX:\n\t\tif (!(phy->flags & FLAGS_SFP_NOT_APPROVED))\n\t\t\tbnx2x_sfp_set_transmitter(params, phy, 1);\n\t\tbreak;\n\tcase PHY_INIT:\n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_PMA_DEVAD, MDIO_PMA_LASI_RXCTRL,\n\t\t\t\t (1<<2) | (1<<5));\n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_PMA_DEVAD, MDIO_PMA_LASI_TXCTRL,\n\t\t\t\t 0);\n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_PMA_DEVAD, MDIO_PMA_LASI_CTRL, 0x0006);\n\t\t \n\t\tbnx2x_cl45_read(bp, phy, MDIO_PMA_DEVAD,\n\t\t\t\tMDIO_PMA_REG_8727_PCS_OPT_CTRL,\n\t\t\t\t&val);\n\t\tval |= (1<<12);\n\t\tif (phy->flags & FLAGS_NOC)\n\t\t\tval |= (3<<5);\n\t\t \n\t\tif (!(phy->flags & FLAGS_NOC))\n\t\t\tval &= 0xff8f;  \n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_PMA_DEVAD, MDIO_PMA_REG_8727_PCS_OPT_CTRL,\n\t\t\t\t val);\n\t\tbreak;\n\tdefault:\n\t\tDP(NETIF_MSG_LINK, \"Function 0x%x not supported by 8727\\n\",\n\t\t   action);\n\t\treturn;\n\t}\n}\n\nstatic void bnx2x_set_e1e2_module_fault_led(struct link_params *params,\n\t\t\t\t\t   u8 gpio_mode)\n{\n\tstruct bnx2x *bp = params->bp;\n\n\tu32 fault_led_gpio = REG_RD(bp, params->shmem_base +\n\t\t\t    offsetof(struct shmem_region,\n\t\t\tdev_info.port_hw_config[params->port].sfp_ctrl)) &\n\t\tPORT_HW_CFG_FAULT_MODULE_LED_MASK;\n\tswitch (fault_led_gpio) {\n\tcase PORT_HW_CFG_FAULT_MODULE_LED_DISABLED:\n\t\treturn;\n\tcase PORT_HW_CFG_FAULT_MODULE_LED_GPIO0:\n\tcase PORT_HW_CFG_FAULT_MODULE_LED_GPIO1:\n\tcase PORT_HW_CFG_FAULT_MODULE_LED_GPIO2:\n\tcase PORT_HW_CFG_FAULT_MODULE_LED_GPIO3:\n\t{\n\t\tu8 gpio_port = bnx2x_get_gpio_port(params);\n\t\tu16 gpio_pin = fault_led_gpio -\n\t\t\tPORT_HW_CFG_FAULT_MODULE_LED_GPIO0;\n\t\tDP(NETIF_MSG_LINK, \"Set fault module-detected led \"\n\t\t\t\t   \"pin %x port %x mode %x\\n\",\n\t\t\t       gpio_pin, gpio_port, gpio_mode);\n\t\tbnx2x_set_gpio(bp, gpio_pin, gpio_mode, gpio_port);\n\t}\n\tbreak;\n\tdefault:\n\t\tDP(NETIF_MSG_LINK, \"Error: Invalid fault led mode 0x%x\\n\",\n\t\t\t       fault_led_gpio);\n\t}\n}\n\nstatic void bnx2x_set_e3_module_fault_led(struct link_params *params,\n\t\t\t\t\t  u8 gpio_mode)\n{\n\tu32 pin_cfg;\n\tu8 port = params->port;\n\tstruct bnx2x *bp = params->bp;\n\tpin_cfg = (REG_RD(bp, params->shmem_base +\n\t\t\t offsetof(struct shmem_region,\n\t\t\t\t  dev_info.port_hw_config[port].e3_sfp_ctrl)) &\n\t\tPORT_HW_CFG_E3_FAULT_MDL_LED_MASK) >>\n\t\tPORT_HW_CFG_E3_FAULT_MDL_LED_SHIFT;\n\tDP(NETIF_MSG_LINK, \"Setting Fault LED to %d using pin cfg %d\\n\",\n\t\t       gpio_mode, pin_cfg);\n\tbnx2x_set_cfg_pin(bp, pin_cfg, gpio_mode);\n}\n\nstatic void bnx2x_set_sfp_module_fault_led(struct link_params *params,\n\t\t\t\t\t   u8 gpio_mode)\n{\n\tstruct bnx2x *bp = params->bp;\n\tDP(NETIF_MSG_LINK, \"Setting SFP+ module fault LED to %d\\n\", gpio_mode);\n\tif (CHIP_IS_E3(bp)) {\n\t\t \n\t\tbnx2x_set_e3_module_fault_led(params, gpio_mode);\n\t} else\n\t\tbnx2x_set_e1e2_module_fault_led(params, gpio_mode);\n}\n\nstatic void bnx2x_warpcore_hw_reset(struct bnx2x_phy *phy,\n\t\t\t\t    struct link_params *params)\n{\n\tstruct bnx2x *bp = params->bp;\n\tbnx2x_warpcore_power_module(params, 0);\n\t \n\tREG_WR(bp, MISC_REG_WC0_RESET, 0x0c0e);\n\n\t \n\tREG_WR(bp, MISC_REG_LCPLL_E40_PWRDWN, 1);\n\tREG_WR(bp, MISC_REG_LCPLL_E40_RESETB_ANA, 0);\n\tREG_WR(bp, MISC_REG_LCPLL_E40_RESETB_DIG, 0);\n}\n\nstatic void bnx2x_power_sfp_module(struct link_params *params,\n\t\t\t\t   struct bnx2x_phy *phy,\n\t\t\t\t   u8 power)\n{\n\tstruct bnx2x *bp = params->bp;\n\tDP(NETIF_MSG_LINK, \"Setting SFP+ power to %x\\n\", power);\n\n\tswitch (phy->type) {\n\tcase PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8727:\n\tcase PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8722:\n\t\tbnx2x_8727_power_module(params->bp, phy, power);\n\t\tbreak;\n\tcase PORT_HW_CFG_XGXS_EXT_PHY_TYPE_DIRECT:\n\t\tbnx2x_warpcore_power_module(params, power);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\nstatic void bnx2x_warpcore_set_limiting_mode(struct link_params *params,\n\t\t\t\t\t     struct bnx2x_phy *phy,\n\t\t\t\t\t     u16 edc_mode)\n{\n\tu16 val = 0;\n\tu16 mode = MDIO_WC_REG_UC_INFO_B1_FIRMWARE_MODE_DEFAULT;\n\tstruct bnx2x *bp = params->bp;\n\n\tu8 lane = bnx2x_get_warpcore_lane(phy, params);\n\t \n\tbnx2x_cl45_read(bp, phy, MDIO_WC_DEVAD,\n\t\t\tMDIO_WC_REG_UC_INFO_B1_FIRMWARE_MODE, &val);\n\tval &= ~(0xf << (lane << 2));\n\n\tswitch (edc_mode) {\n\tcase EDC_MODE_LINEAR:\n\tcase EDC_MODE_LIMITING:\n\t\tmode = MDIO_WC_REG_UC_INFO_B1_FIRMWARE_MODE_DEFAULT;\n\t\tbreak;\n\tcase EDC_MODE_PASSIVE_DAC:\n\tcase EDC_MODE_ACTIVE_DAC:\n\t\tmode = MDIO_WC_REG_UC_INFO_B1_FIRMWARE_MODE_SFP_DAC;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tval |= (mode << (lane << 2));\n\tbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\n\t\t\t MDIO_WC_REG_UC_INFO_B1_FIRMWARE_MODE, val);\n\t \n\tbnx2x_cl45_read(bp, phy, MDIO_WC_DEVAD,\n\t\t\tMDIO_WC_REG_UC_INFO_B1_FIRMWARE_MODE, &val);\n\n\t \n\tbnx2x_warpcore_reset_lane(bp, phy, 1);\n\tbnx2x_warpcore_reset_lane(bp, phy, 0);\n\n}\n\nstatic void bnx2x_set_limiting_mode(struct link_params *params,\n\t\t\t\t    struct bnx2x_phy *phy,\n\t\t\t\t    u16 edc_mode)\n{\n\tswitch (phy->type) {\n\tcase PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8726:\n\t\tbnx2x_8726_set_limiting_mode(params->bp, phy, edc_mode);\n\t\tbreak;\n\tcase PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8727:\n\tcase PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8722:\n\t\tbnx2x_8727_set_limiting_mode(params->bp, phy, edc_mode);\n\t\tbreak;\n\tcase PORT_HW_CFG_XGXS_EXT_PHY_TYPE_DIRECT:\n\t\tbnx2x_warpcore_set_limiting_mode(params, phy, edc_mode);\n\t\tbreak;\n\t}\n}\n\nstatic int bnx2x_sfp_module_detection(struct bnx2x_phy *phy,\n\t\t\t\t      struct link_params *params)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu16 edc_mode;\n\tint rc = 0;\n\n\tu32 val = REG_RD(bp, params->shmem_base +\n\t\t\t     offsetof(struct shmem_region, dev_info.\n\t\t\t\t     port_feature_config[params->port].config));\n\t \n\tbnx2x_sfp_set_transmitter(params, phy, 1);\n\tDP(NETIF_MSG_LINK, \"SFP+ module plugged in/out detected on port %d\\n\",\n\t\t params->port);\n\t \n\tbnx2x_power_sfp_module(params, phy, 1);\n\tif (bnx2x_get_edc_mode(phy, params, &edc_mode) != 0) {\n\t\tDP(NETIF_MSG_LINK, \"Failed to get valid module type\\n\");\n\t\treturn -EINVAL;\n\t} else if (bnx2x_verify_sfp_module(phy, params) != 0) {\n\t\t \n\t\tDP(NETIF_MSG_LINK, \"Module verification failed!!\\n\");\n\t\trc = -EINVAL;\n\t\t \n\t\tbnx2x_set_sfp_module_fault_led(params,\n\t\t\t\t\t       MISC_REGISTERS_GPIO_HIGH);\n\n\t\t \n\t\tif ((val & PORT_FEAT_CFG_OPT_MDL_ENFRCMNT_MASK) ==\n\t\t     PORT_FEAT_CFG_OPT_MDL_ENFRCMNT_POWER_DOWN) {\n\t\t\tDP(NETIF_MSG_LINK, \"Shutdown SFP+ module!!\\n\");\n\t\t\tbnx2x_power_sfp_module(params, phy, 0);\n\t\t\treturn rc;\n\t\t}\n\t} else {\n\t\t \n\t\tbnx2x_set_sfp_module_fault_led(params, MISC_REGISTERS_GPIO_LOW);\n\t}\n\n\t \n\tbnx2x_set_limiting_mode(params, phy, edc_mode);\n\n\t \n\tif ((rc) &&\n\t    ((val & PORT_FEAT_CFG_OPT_MDL_ENFRCMNT_MASK) ==\n\t     PORT_FEAT_CFG_OPT_MDL_ENFRCMNT_DISABLE_TX_LASER))\n\t\tbnx2x_sfp_set_transmitter(params, phy, 0);\n\n\treturn rc;\n}\n\nvoid bnx2x_handle_module_detect_int(struct link_params *params)\n{\n\tstruct bnx2x *bp = params->bp;\n\tstruct bnx2x_phy *phy;\n\tu32 gpio_val;\n\tu8 gpio_num, gpio_port;\n\tif (CHIP_IS_E3(bp)) {\n\t\tphy = &params->phy[INT_PHY];\n\t\t \n\t\tbnx2x_sfp_set_transmitter(params, phy, 1);\n\t} else {\n\t\tphy = &params->phy[EXT_PHY1];\n\t}\n\tif (bnx2x_get_mod_abs_int_cfg(bp, params->chip_id, params->shmem_base,\n\t\t\t\t      params->port, &gpio_num, &gpio_port) ==\n\t    -EINVAL) {\n\t\tDP(NETIF_MSG_LINK, \"Failed to get MOD_ABS interrupt config\\n\");\n\t\treturn;\n\t}\n\n\t \n\tbnx2x_set_sfp_module_fault_led(params, MISC_REGISTERS_GPIO_HIGH);\n\n\t \n\tgpio_val = bnx2x_get_gpio(bp, gpio_num, gpio_port);\n\n\t \n\tif (gpio_val == 0) {\n\t\tbnx2x_set_mdio_emac_per_phy(bp, params);\n\t\tbnx2x_set_aer_mmd(params, phy);\n\n\t\tbnx2x_power_sfp_module(params, phy, 1);\n\t\tbnx2x_set_gpio_int(bp, gpio_num,\n\t\t\t\t   MISC_REGISTERS_GPIO_INT_OUTPUT_CLR,\n\t\t\t\t   gpio_port);\n\t\tif (bnx2x_wait_for_sfp_module_initialized(phy, params) == 0) {\n\t\t\tbnx2x_sfp_module_detection(phy, params);\n\t\t\tif (CHIP_IS_E3(bp)) {\n\t\t\t\tu16 rx_tx_in_reset;\n\t\t\t\t \n\t\t\t\tbnx2x_cl45_read(bp, phy,\n\t\t\t\t\t\tMDIO_WC_DEVAD,\n\t\t\t\t\t\tMDIO_WC_REG_DIGITAL5_MISC6,\n\t\t\t\t\t\t&rx_tx_in_reset);\n\t\t\t\tif ((!rx_tx_in_reset) &&\n\t\t\t\t    (params->link_flags &\n\t\t\t\t     PHY_INITIALIZED)) {\n\t\t\t\t\tbnx2x_warpcore_reset_lane(bp, phy, 1);\n\t\t\t\t\tbnx2x_warpcore_config_sfi(phy, params);\n\t\t\t\t\tbnx2x_warpcore_reset_lane(bp, phy, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tDP(NETIF_MSG_LINK, \"SFP+ module is not initialized\\n\");\n\t\t}\n\t} else {\n\t\tbnx2x_set_gpio_int(bp, gpio_num,\n\t\t\t\t   MISC_REGISTERS_GPIO_INT_OUTPUT_SET,\n\t\t\t\t   gpio_port);\n\t\t \n\t\tphy->media_type = ETH_PHY_NOT_PRESENT;\n\t}\n}\n\n \n \n \nstatic void bnx2x_sfp_mask_fault(struct bnx2x *bp,\n\t\t\t\t struct bnx2x_phy *phy,\n\t\t\t\t u16 alarm_status_offset,\n\t\t\t\t u16 alarm_ctrl_offset)\n{\n\tu16 alarm_status, val;\n\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_PMA_DEVAD, alarm_status_offset,\n\t\t\t&alarm_status);\n\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_PMA_DEVAD, alarm_status_offset,\n\t\t\t&alarm_status);\n\t \n\tbnx2x_cl45_read(bp, phy, MDIO_PMA_DEVAD, alarm_ctrl_offset, &val);\n\tif (alarm_status & (1<<0))\n\t\tval &= ~(1<<0);\n\telse\n\t\tval |= (1<<0);\n\tbnx2x_cl45_write(bp, phy, MDIO_PMA_DEVAD, alarm_ctrl_offset, val);\n}\n \n \n \nstatic u8 bnx2x_8706_8726_read_status(struct bnx2x_phy *phy,\n\t\t\t\t      struct link_params *params,\n\t\t\t\t      struct link_vars *vars)\n{\n\tu8 link_up = 0;\n\tu16 val1, val2, rx_sd, pcs_status;\n\tstruct bnx2x *bp = params->bp;\n\tDP(NETIF_MSG_LINK, \"XGXS 8706/8726\\n\");\n\t \n\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_PMA_DEVAD, MDIO_PMA_LASI_RXSTAT, &val2);\n\n\tbnx2x_sfp_mask_fault(bp, phy, MDIO_PMA_LASI_TXSTAT,\n\t\t\t     MDIO_PMA_LASI_TXCTRL);\n\n\t \n\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_PMA_DEVAD, MDIO_PMA_LASI_STAT, &val1);\n\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_PMA_DEVAD, MDIO_PMA_LASI_STAT, &val2);\n\tDP(NETIF_MSG_LINK, \"8706/8726 LASI status 0x%x--> 0x%x\\n\", val1, val2);\n\n\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_PMA_DEVAD, MDIO_PMA_REG_RX_SD, &rx_sd);\n\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_PCS_DEVAD, MDIO_PCS_REG_STATUS, &pcs_status);\n\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_AN_DEVAD, MDIO_AN_REG_LINK_STATUS, &val2);\n\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_AN_DEVAD, MDIO_AN_REG_LINK_STATUS, &val2);\n\n\tDP(NETIF_MSG_LINK, \"8706/8726 rx_sd 0x%x pcs_status 0x%x 1Gbps\"\n\t\t\t\" link_status 0x%x\\n\", rx_sd, pcs_status, val2);\n\t \n\tlink_up = ((rx_sd & pcs_status & 0x1) || (val2 & (1<<1)));\n\tif (link_up) {\n\t\tif (val2 & (1<<1))\n\t\t\tvars->line_speed = SPEED_1000;\n\t\telse\n\t\t\tvars->line_speed = SPEED_10000;\n\t\tbnx2x_ext_phy_resolve_fc(phy, params, vars);\n\t\tvars->duplex = DUPLEX_FULL;\n\t}\n\n\t \n\tif (vars->line_speed == SPEED_10000) {\n\t\tbnx2x_cl45_read(bp, phy, MDIO_PMA_DEVAD,\n\t\t\t    MDIO_PMA_LASI_TXSTAT, &val1);\n\t\tbnx2x_cl45_read(bp, phy, MDIO_PMA_DEVAD,\n\t\t\t    MDIO_PMA_LASI_TXSTAT, &val1);\n\t\tif (val1 & (1<<0))\n\t\t\tvars->fault_detected = 1;\n\t}\n\n\treturn link_up;\n}\n\n \n \n \nstatic void bnx2x_8706_config_init(struct bnx2x_phy *phy,\n\t\t\t\t   struct link_params *params,\n\t\t\t\t   struct link_vars *vars)\n{\n\tu32 tx_en_mode;\n\tu16 cnt, val, tmp1;\n\tstruct bnx2x *bp = params->bp;\n\n\tbnx2x_set_gpio(bp, MISC_REGISTERS_GPIO_2,\n\t\t       MISC_REGISTERS_GPIO_OUTPUT_HIGH, params->port);\n\t \n\tbnx2x_ext_phy_hw_reset(bp, params->port);\n\tbnx2x_cl45_write(bp, phy, MDIO_PMA_DEVAD, MDIO_PMA_REG_CTRL, 0xa040);\n\tbnx2x_wait_reset_complete(bp, phy, params);\n\n\t \n\tfor (cnt = 0; cnt < 100; cnt++) {\n\t\tbnx2x_cl45_read(bp, phy,\n\t\t\t\tMDIO_PMA_DEVAD, MDIO_PMA_REG_ROM_VER1, &val);\n\t\tif (val)\n\t\t\tbreak;\n\t\tusleep_range(10000, 20000);\n\t}\n\tDP(NETIF_MSG_LINK, \"XGXS 8706 is initialized after %d ms\\n\", cnt);\n\tif ((params->feature_config_flags &\n\t     FEATURE_CONFIG_OVERRIDE_PREEMPHASIS_ENABLED)) {\n\t\tu8 i;\n\t\tu16 reg;\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\treg = MDIO_XS_8706_REG_BANK_RX0 +\n\t\t\t\ti*(MDIO_XS_8706_REG_BANK_RX1 -\n\t\t\t\t   MDIO_XS_8706_REG_BANK_RX0);\n\t\t\tbnx2x_cl45_read(bp, phy, MDIO_XS_DEVAD, reg, &val);\n\t\t\t \n\t\t\tval &= ~0x7;\n\t\t\t \n\t\t\tval |= (phy->rx_preemphasis[i] & 0x7);\n\t\t\tDP(NETIF_MSG_LINK, \"Setting RX Equalizer to BCM8706\"\n\t\t\t\t   \" reg 0x%x <-- val 0x%x\\n\", reg, val);\n\t\t\tbnx2x_cl45_write(bp, phy, MDIO_XS_DEVAD, reg, val);\n\t\t}\n\t}\n\t \n\tif (phy->req_line_speed == SPEED_10000) {\n\t\tDP(NETIF_MSG_LINK, \"XGXS 8706 force 10Gbps\\n\");\n\n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_PMA_DEVAD,\n\t\t\t\t MDIO_PMA_REG_DIGITAL_CTRL, 0x400);\n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_PMA_DEVAD, MDIO_PMA_LASI_TXCTRL,\n\t\t\t\t 0);\n\t\t \n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_PMA_DEVAD, MDIO_PMA_LASI_CTRL, 3);\n\t} else {\n\t\t \n\n\t\t \n\t\tDP(NETIF_MSG_LINK, \"XGXS 8706 AutoNeg\\n\");\n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_AN_DEVAD, MDIO_AN_REG_CL37_CL73, 0x040c);\n\n\t\t \n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_AN_DEVAD, MDIO_AN_REG_CL37_FC_LP, 0x0020);\n\t\t \n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_AN_DEVAD, MDIO_AN_REG_CL37_AN, 0x1000);\n\t\t \n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_AN_DEVAD, MDIO_AN_REG_ADV, (1<<5));\n\n\t\t \n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_AN_DEVAD, MDIO_AN_REG_CTRL, 0x1200);\n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_PMA_DEVAD, MDIO_PMA_LASI_RXCTRL,\n\t\t\t\t 0x0400);\n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_PMA_DEVAD, MDIO_PMA_LASI_CTRL,\n\t\t\t\t 0x0004);\n\t}\n\tbnx2x_save_bcm_spirom_ver(bp, phy, params->port);\n\n\t \n\n\ttx_en_mode = REG_RD(bp, params->shmem_base +\n\t\t\t    offsetof(struct shmem_region,\n\t\t\t\tdev_info.port_hw_config[params->port].sfp_ctrl))\n\t\t\t& PORT_HW_CFG_TX_LASER_MASK;\n\n\tif (tx_en_mode == PORT_HW_CFG_TX_LASER_GPIO0) {\n\t\tDP(NETIF_MSG_LINK, \"Enabling TXONOFF_PWRDN_DIS\\n\");\n\t\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_PMA_DEVAD, MDIO_PMA_REG_DIGITAL_CTRL, &tmp1);\n\t\ttmp1 |= 0x1;\n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\tMDIO_PMA_DEVAD, MDIO_PMA_REG_DIGITAL_CTRL, tmp1);\n\t}\n}\n\nstatic u8 bnx2x_8706_read_status(struct bnx2x_phy *phy,\n\t\t\t\t struct link_params *params,\n\t\t\t\t struct link_vars *vars)\n{\n\treturn bnx2x_8706_8726_read_status(phy, params, vars);\n}\n\n \n \n \nstatic void bnx2x_8726_config_loopback(struct bnx2x_phy *phy,\n\t\t\t\t       struct link_params *params)\n{\n\tstruct bnx2x *bp = params->bp;\n\tDP(NETIF_MSG_LINK, \"PMA/PMD ext_phy_loopback: 8726\\n\");\n\tbnx2x_cl45_write(bp, phy, MDIO_PMA_DEVAD, MDIO_PMA_REG_CTRL, 0x0001);\n}\n\nstatic void bnx2x_8726_external_rom_boot(struct bnx2x_phy *phy,\n\t\t\t\t\t struct link_params *params)\n{\n\tstruct bnx2x *bp = params->bp;\n\t \n\tmsleep(100);\n\n\t \n\tbnx2x_cl45_write(bp, phy,\n\t\t\t MDIO_PMA_DEVAD, MDIO_PMA_REG_GEN_CTRL, 0x018B);\n\n\t \n\tbnx2x_cl45_write(bp, phy,\n\t\t\t MDIO_PMA_DEVAD,\n\t\t\t MDIO_PMA_REG_GEN_CTRL,\n\t\t\t MDIO_PMA_REG_GEN_CTRL_ROM_MICRO_RESET);\n\n\tbnx2x_cl45_write(bp, phy,\n\t\t\t MDIO_PMA_DEVAD,\n\t\t\t MDIO_PMA_REG_MISC_CTRL1, 0x0001);\n\n\tbnx2x_cl45_write(bp, phy,\n\t\t\t MDIO_PMA_DEVAD,\n\t\t\t MDIO_PMA_REG_GEN_CTRL,\n\t\t\t MDIO_PMA_REG_GEN_CTRL_ROM_RESET_INTERNAL_MP);\n\n\t \n\tmsleep(150);\n\n\t \n\tbnx2x_cl45_write(bp, phy,\n\t\t\t MDIO_PMA_DEVAD,\n\t\t\t MDIO_PMA_REG_MISC_CTRL1, 0x0000);\n\n\tmsleep(200);\n\tbnx2x_save_bcm_spirom_ver(bp, phy, params->port);\n}\n\nstatic u8 bnx2x_8726_read_status(struct bnx2x_phy *phy,\n\t\t\t\t struct link_params *params,\n\t\t\t\t struct link_vars *vars)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu16 val1;\n\tu8 link_up = bnx2x_8706_8726_read_status(phy, params, vars);\n\tif (link_up) {\n\t\tbnx2x_cl45_read(bp, phy,\n\t\t\t\tMDIO_PMA_DEVAD, MDIO_PMA_REG_PHY_IDENTIFIER,\n\t\t\t\t&val1);\n\t\tif (val1 & (1<<15)) {\n\t\t\tDP(NETIF_MSG_LINK, \"Tx is disabled\\n\");\n\t\t\tlink_up = 0;\n\t\t\tvars->line_speed = 0;\n\t\t}\n\t}\n\treturn link_up;\n}\n\n\nstatic void bnx2x_8726_config_init(struct bnx2x_phy *phy,\n\t\t\t\t   struct link_params *params,\n\t\t\t\t   struct link_vars *vars)\n{\n\tstruct bnx2x *bp = params->bp;\n\tDP(NETIF_MSG_LINK, \"Initializing BCM8726\\n\");\n\n\tbnx2x_cl45_write(bp, phy, MDIO_PMA_DEVAD, MDIO_PMA_REG_CTRL, 1<<15);\n\tbnx2x_wait_reset_complete(bp, phy, params);\n\n\tbnx2x_8726_external_rom_boot(phy, params);\n\n\t \n\tbnx2x_sfp_module_detection(phy, params);\n\n\tif (phy->req_line_speed == SPEED_1000) {\n\t\tDP(NETIF_MSG_LINK, \"Setting 1G force\\n\");\n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_PMA_DEVAD, MDIO_PMA_REG_CTRL, 0x40);\n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_PMA_DEVAD, MDIO_PMA_REG_10G_CTRL2, 0xD);\n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_PMA_DEVAD, MDIO_PMA_LASI_CTRL, 0x5);\n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_PMA_DEVAD, MDIO_PMA_LASI_RXCTRL,\n\t\t\t\t 0x400);\n\t} else if ((phy->req_line_speed == SPEED_AUTO_NEG) &&\n\t\t   (phy->speed_cap_mask &\n\t\t      PORT_HW_CFG_SPEED_CAPABILITY_D0_1G) &&\n\t\t   ((phy->speed_cap_mask &\n\t\t      PORT_HW_CFG_SPEED_CAPABILITY_D0_10G) !=\n\t\t    PORT_HW_CFG_SPEED_CAPABILITY_D0_10G)) {\n\t\tDP(NETIF_MSG_LINK, \"Setting 1G clause37\\n\");\n\t\t \n\t\tbnx2x_ext_phy_set_pause(params, phy, vars);\n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_AN_DEVAD, MDIO_AN_REG_ADV, 0x20);\n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_AN_DEVAD, MDIO_AN_REG_CL37_CL73, 0x040c);\n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_AN_DEVAD, MDIO_AN_REG_CL37_FC_LD, 0x0020);\n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_AN_DEVAD, MDIO_AN_REG_CL37_AN, 0x1000);\n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\tMDIO_AN_DEVAD, MDIO_AN_REG_CTRL, 0x1200);\n\t\t \n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_PMA_DEVAD, MDIO_PMA_LASI_CTRL, 0x4);\n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_PMA_DEVAD, MDIO_PMA_LASI_RXCTRL,\n\t\t\t\t 0x400);\n\n\t} else {  \n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_PMA_DEVAD, MDIO_PMA_LASI_CTRL, 1);\n\t}\n\n\t \n\tif ((params->feature_config_flags &\n\t     FEATURE_CONFIG_OVERRIDE_PREEMPHASIS_ENABLED)) {\n\t\tDP(NETIF_MSG_LINK,\n\t\t   \"Setting TX_CTRL1 0x%x, TX_CTRL2 0x%x\\n\",\n\t\t\t phy->tx_preemphasis[0],\n\t\t\t phy->tx_preemphasis[1]);\n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_PMA_DEVAD,\n\t\t\t\t MDIO_PMA_REG_8726_TX_CTRL1,\n\t\t\t\t phy->tx_preemphasis[0]);\n\n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_PMA_DEVAD,\n\t\t\t\t MDIO_PMA_REG_8726_TX_CTRL2,\n\t\t\t\t phy->tx_preemphasis[1]);\n\t}\n}\n\nstatic void bnx2x_8726_link_reset(struct bnx2x_phy *phy,\n\t\t\t\t  struct link_params *params)\n{\n\tstruct bnx2x *bp = params->bp;\n\tDP(NETIF_MSG_LINK, \"bnx2x_8726_link_reset port %d\\n\", params->port);\n\t \n\tbnx2x_cl45_write(bp, phy,\n\t\t\t MDIO_PMA_DEVAD,\n\t\t\t MDIO_PMA_REG_GEN_CTRL, 0x0001);\n}\n\n \n \n \n\nstatic void bnx2x_8727_set_link_led(struct bnx2x_phy *phy,\n\t\t\t\t    struct link_params *params, u8 mode)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu16 led_mode_bitmask = 0;\n\tu16 gpio_pins_bitmask = 0;\n\tu16 val;\n\t \n\tif (!(phy->flags & FLAGS_NOC))\n\t\treturn;\n\tswitch (mode) {\n\tcase LED_MODE_FRONT_PANEL_OFF:\n\tcase LED_MODE_OFF:\n\t\tled_mode_bitmask = 0;\n\t\tgpio_pins_bitmask = 0x03;\n\t\tbreak;\n\tcase LED_MODE_ON:\n\t\tled_mode_bitmask = 0;\n\t\tgpio_pins_bitmask = 0x02;\n\t\tbreak;\n\tcase LED_MODE_OPER:\n\t\tled_mode_bitmask = 0x60;\n\t\tgpio_pins_bitmask = 0x11;\n\t\tbreak;\n\t}\n\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_PMA_DEVAD,\n\t\t\tMDIO_PMA_REG_8727_PCS_OPT_CTRL,\n\t\t\t&val);\n\tval &= 0xff8f;\n\tval |= led_mode_bitmask;\n\tbnx2x_cl45_write(bp, phy,\n\t\t\t MDIO_PMA_DEVAD,\n\t\t\t MDIO_PMA_REG_8727_PCS_OPT_CTRL,\n\t\t\t val);\n\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_PMA_DEVAD,\n\t\t\tMDIO_PMA_REG_8727_GPIO_CTRL,\n\t\t\t&val);\n\tval &= 0xffe0;\n\tval |= gpio_pins_bitmask;\n\tbnx2x_cl45_write(bp, phy,\n\t\t\t MDIO_PMA_DEVAD,\n\t\t\t MDIO_PMA_REG_8727_GPIO_CTRL,\n\t\t\t val);\n}\nstatic void bnx2x_8727_hw_reset(struct bnx2x_phy *phy,\n\t\t\t\tstruct link_params *params) {\n\tu32 swap_val, swap_override;\n\tu8 port;\n\t \n\tstruct bnx2x *bp = params->bp;\n\tswap_val = REG_RD(bp, NIG_REG_PORT_SWAP);\n\tswap_override = REG_RD(bp, NIG_REG_STRAP_OVERRIDE);\n\tport = (swap_val && swap_override) ^ 1;\n\tbnx2x_set_gpio(bp, MISC_REGISTERS_GPIO_1,\n\t\t       MISC_REGISTERS_GPIO_OUTPUT_LOW, port);\n}\n\nstatic void bnx2x_8727_config_speed(struct bnx2x_phy *phy,\n\t\t\t\t    struct link_params *params)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu16 tmp1, val;\n\t \n\tif ((phy->req_line_speed == SPEED_1000) ||\n\t    (phy->media_type == ETH_PHY_SFP_1G_FIBER)) {\n\t\tDP(NETIF_MSG_LINK, \"Setting 1G force\\n\");\n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_PMA_DEVAD, MDIO_PMA_REG_CTRL, 0x40);\n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_PMA_DEVAD, MDIO_PMA_REG_10G_CTRL2, 0xD);\n\t\tbnx2x_cl45_read(bp, phy,\n\t\t\t\tMDIO_PMA_DEVAD, MDIO_PMA_REG_10G_CTRL2, &tmp1);\n\t\tDP(NETIF_MSG_LINK, \"1.7 = 0x%x\\n\", tmp1);\n\t\t \n\t\tif (DUAL_MEDIA(params)) {\n\t\t\tbnx2x_cl45_read(bp, phy,\n\t\t\t\t\tMDIO_PMA_DEVAD,\n\t\t\t\t\tMDIO_PMA_REG_8727_PCS_GP, &val);\n\t\t\tval |= (3<<10);\n\t\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t\t MDIO_PMA_DEVAD,\n\t\t\t\t\t MDIO_PMA_REG_8727_PCS_GP, val);\n\t\t}\n\t} else if ((phy->req_line_speed == SPEED_AUTO_NEG) &&\n\t\t   ((phy->speed_cap_mask &\n\t\t     PORT_HW_CFG_SPEED_CAPABILITY_D0_1G)) &&\n\t\t   ((phy->speed_cap_mask &\n\t\t      PORT_HW_CFG_SPEED_CAPABILITY_D0_10G) !=\n\t\t   PORT_HW_CFG_SPEED_CAPABILITY_D0_10G)) {\n\n\t\tDP(NETIF_MSG_LINK, \"Setting 1G clause37\\n\");\n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_AN_DEVAD, MDIO_AN_REG_8727_MISC_CTRL, 0);\n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_AN_DEVAD, MDIO_AN_REG_CL37_AN, 0x1300);\n\t} else {\n\t\t \n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_AN_DEVAD, MDIO_AN_REG_8727_MISC_CTRL,\n\t\t\t\t 0x0020);\n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_AN_DEVAD, MDIO_AN_REG_CL37_AN, 0x0100);\n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_PMA_DEVAD, MDIO_PMA_REG_CTRL, 0x2040);\n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_PMA_DEVAD, MDIO_PMA_REG_10G_CTRL2,\n\t\t\t\t 0x0008);\n\t}\n}\n\nstatic void bnx2x_8727_config_init(struct bnx2x_phy *phy,\n\t\t\t\t   struct link_params *params,\n\t\t\t\t   struct link_vars *vars)\n{\n\tu32 tx_en_mode;\n\tu16 tmp1, mod_abs, tmp2;\n\tstruct bnx2x *bp = params->bp;\n\t \n\n\tbnx2x_wait_reset_complete(bp, phy, params);\n\n\tDP(NETIF_MSG_LINK, \"Initializing BCM8727\\n\");\n\n\tbnx2x_8727_specific_func(phy, params, PHY_INIT);\n\t \n\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_PMA_DEVAD, MDIO_PMA_REG_PHY_IDENTIFIER, &mod_abs);\n\t \n\tmod_abs &= ~(1<<8);\n\tif (!(phy->flags & FLAGS_NOC))\n\t\tmod_abs &= ~(1<<9);\n\tbnx2x_cl45_write(bp, phy,\n\t\t\t MDIO_PMA_DEVAD, MDIO_PMA_REG_PHY_IDENTIFIER, mod_abs);\n\n\t \n\tbnx2x_set_disable_pmd_transmit(params, phy, 0);\n\n\tbnx2x_8727_power_module(bp, phy, 1);\n\n\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_PMA_DEVAD, MDIO_PMA_REG_M8051_MSGOUT_REG, &tmp1);\n\n\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_PMA_DEVAD, MDIO_PMA_LASI_RXSTAT, &tmp1);\n\n\tbnx2x_8727_config_speed(phy, params);\n\n\n\t \n\tif ((params->feature_config_flags &\n\t     FEATURE_CONFIG_OVERRIDE_PREEMPHASIS_ENABLED)) {\n\t\tDP(NETIF_MSG_LINK, \"Setting TX_CTRL1 0x%x, TX_CTRL2 0x%x\\n\",\n\t\t\t   phy->tx_preemphasis[0],\n\t\t\t   phy->tx_preemphasis[1]);\n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_PMA_DEVAD, MDIO_PMA_REG_8727_TX_CTRL1,\n\t\t\t\t phy->tx_preemphasis[0]);\n\n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_PMA_DEVAD, MDIO_PMA_REG_8727_TX_CTRL2,\n\t\t\t\t phy->tx_preemphasis[1]);\n\t}\n\n\t \n\ttx_en_mode = REG_RD(bp, params->shmem_base +\n\t\t\t    offsetof(struct shmem_region,\n\t\t\t\tdev_info.port_hw_config[params->port].sfp_ctrl))\n\t\t\t& PORT_HW_CFG_TX_LASER_MASK;\n\n\tif (tx_en_mode == PORT_HW_CFG_TX_LASER_GPIO0) {\n\n\t\tDP(NETIF_MSG_LINK, \"Enabling TXONOFF_PWRDN_DIS\\n\");\n\t\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_PMA_DEVAD, MDIO_PMA_REG_8727_OPT_CFG_REG, &tmp2);\n\t\ttmp2 |= 0x1000;\n\t\ttmp2 &= 0xFFEF;\n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\tMDIO_PMA_DEVAD, MDIO_PMA_REG_8727_OPT_CFG_REG, tmp2);\n\t\tbnx2x_cl45_read(bp, phy,\n\t\t\t\tMDIO_PMA_DEVAD, MDIO_PMA_REG_PHY_IDENTIFIER,\n\t\t\t\t&tmp2);\n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_PMA_DEVAD, MDIO_PMA_REG_PHY_IDENTIFIER,\n\t\t\t\t (tmp2 & 0x7fff));\n\t}\n}\n\nstatic void bnx2x_8727_handle_mod_abs(struct bnx2x_phy *phy,\n\t\t\t\t      struct link_params *params)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu16 mod_abs, rx_alarm_status;\n\tu32 val = REG_RD(bp, params->shmem_base +\n\t\t\t     offsetof(struct shmem_region, dev_info.\n\t\t\t\t      port_feature_config[params->port].\n\t\t\t\t      config));\n\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_PMA_DEVAD,\n\t\t\tMDIO_PMA_REG_PHY_IDENTIFIER, &mod_abs);\n\tif (mod_abs & (1<<8)) {\n\n\t\t \n\t\tDP(NETIF_MSG_LINK,\n\t\t   \"MOD_ABS indication show module is absent\\n\");\n\t\tphy->media_type = ETH_PHY_NOT_PRESENT;\n\t\t \n\t\tmod_abs &= ~(1<<8);\n\t\tif (!(phy->flags & FLAGS_NOC))\n\t\t\tmod_abs &= ~(1<<9);\n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_PMA_DEVAD,\n\t\t\t\t MDIO_PMA_REG_PHY_IDENTIFIER, mod_abs);\n\n\t\t \n\t\tbnx2x_cl45_read(bp, phy,\n\t\t\t\tMDIO_PMA_DEVAD,\n\t\t\t\tMDIO_PMA_LASI_RXSTAT, &rx_alarm_status);\n\n\t} else {\n\t\t \n\t\tDP(NETIF_MSG_LINK,\n\t\t   \"MOD_ABS indication show module is present\\n\");\n\t\t \n\t\tmod_abs |= (1<<8);\n\t\tif (!(phy->flags & FLAGS_NOC))\n\t\t\tmod_abs |= (1<<9);\n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_PMA_DEVAD,\n\t\t\t\t MDIO_PMA_REG_PHY_IDENTIFIER, mod_abs);\n\n\t\t \n\t\tbnx2x_cl45_read(bp, phy,\n\t\t\t\tMDIO_PMA_DEVAD,\n\t\t\t\tMDIO_PMA_LASI_RXSTAT, &rx_alarm_status);\n\n\n\t\tif ((val & PORT_FEAT_CFG_OPT_MDL_ENFRCMNT_MASK) ==\n\t\t    PORT_FEAT_CFG_OPT_MDL_ENFRCMNT_DISABLE_TX_LASER)\n\t\t\tbnx2x_sfp_set_transmitter(params, phy, 0);\n\n\t\tif (bnx2x_wait_for_sfp_module_initialized(phy, params) == 0)\n\t\t\tbnx2x_sfp_module_detection(phy, params);\n\t\telse\n\t\t\tDP(NETIF_MSG_LINK, \"SFP+ module is not initialized\\n\");\n\n\t\t \n\t\tbnx2x_8727_config_speed(phy, params);\n\t}\n\n\tDP(NETIF_MSG_LINK, \"8727 RX_ALARM_STATUS 0x%x\\n\",\n\t\t   rx_alarm_status);\n\t \n}\n\nstatic u8 bnx2x_8727_read_status(struct bnx2x_phy *phy,\n\t\t\t\t struct link_params *params,\n\t\t\t\t struct link_vars *vars)\n\n{\n\tstruct bnx2x *bp = params->bp;\n\tu8 link_up = 0, oc_port = params->port;\n\tu16 link_status = 0;\n\tu16 rx_alarm_status, lasi_ctrl, val1;\n\n\t \n\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_PMA_DEVAD, MDIO_PMA_LASI_CTRL,\n\t\t\t&lasi_ctrl);\n\tif (!lasi_ctrl)\n\t\treturn 0;\n\n\t \n\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_PMA_DEVAD, MDIO_PMA_LASI_RXSTAT,\n\t\t\t&rx_alarm_status);\n\tvars->line_speed = 0;\n\tDP(NETIF_MSG_LINK, \"8727 RX_ALARM_STATUS  0x%x\\n\", rx_alarm_status);\n\n\tbnx2x_sfp_mask_fault(bp, phy, MDIO_PMA_LASI_TXSTAT,\n\t\t\t     MDIO_PMA_LASI_TXCTRL);\n\n\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_PMA_DEVAD, MDIO_PMA_LASI_STAT, &val1);\n\n\tDP(NETIF_MSG_LINK, \"8727 LASI status 0x%x\\n\", val1);\n\n\t \n\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_PMA_DEVAD, MDIO_PMA_REG_M8051_MSGOUT_REG, &val1);\n\n\t \n\tif (!(phy->flags & FLAGS_NOC) && !(rx_alarm_status & (1<<5))) {\n\t\t \n\t\tbnx2x_cl45_read(bp, phy,\n\t\t\t\tMDIO_PMA_DEVAD, MDIO_PMA_REG_8727_GPIO_CTRL,\n\t\t\t\t&val1);\n\n\t\tif ((val1 & (1<<8)) == 0) {\n\t\t\tif (!CHIP_IS_E1x(bp))\n\t\t\t\toc_port = BP_PATH(bp) + (params->port << 1);\n\t\t\tDP(NETIF_MSG_LINK,\n\t\t\t   \"8727 Power fault has been detected on port %d\\n\",\n\t\t\t   oc_port);\n\t\t\tnetdev_err(bp->dev, \"Error: Power fault on Port %d has \"\n\t\t\t\t\t    \"been detected and the power to \"\n\t\t\t\t\t    \"that SFP+ module has been removed \"\n\t\t\t\t\t    \"to prevent failure of the card. \"\n\t\t\t\t\t    \"Please remove the SFP+ module and \"\n\t\t\t\t\t    \"restart the system to clear this \"\n\t\t\t\t\t    \"error.\\n\",\n\t\t\t oc_port);\n\t\t\t \n\t\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t\t MDIO_PMA_DEVAD,\n\t\t\t\t\t MDIO_PMA_LASI_RXCTRL, (1<<5));\n\n\t\t\tbnx2x_cl45_read(bp, phy,\n\t\t\t\t\tMDIO_PMA_DEVAD,\n\t\t\t\t\tMDIO_PMA_REG_PHY_IDENTIFIER, &val1);\n\t\t\t \n\t\t\tval1 |= (1<<8);\n\t\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t\t MDIO_PMA_DEVAD,\n\t\t\t\t\t MDIO_PMA_REG_PHY_IDENTIFIER, val1);\n\t\t\t \n\t\t\tbnx2x_cl45_read(bp, phy,\n\t\t\t\tMDIO_PMA_DEVAD,\n\t\t\t\tMDIO_PMA_LASI_RXSTAT, &rx_alarm_status);\n\t\t\tbnx2x_8727_power_module(params->bp, phy, 0);\n\t\t\treturn 0;\n\t\t}\n\t}  \n\n\t \n\tif (rx_alarm_status & (1<<5)) {\n\t\tbnx2x_8727_handle_mod_abs(phy, params);\n\t\t \n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_PMA_DEVAD, MDIO_PMA_LASI_RXCTRL,\n\t\t\t\t ((1<<5) | (1<<2)));\n\t}\n\n\tif (!(phy->flags & FLAGS_SFP_NOT_APPROVED)) {\n\t\tDP(NETIF_MSG_LINK, \"Enabling 8727 TX laser\\n\");\n\t\tbnx2x_sfp_set_transmitter(params, phy, 1);\n\t} else {\n\t\tDP(NETIF_MSG_LINK, \"Tx is disabled\\n\");\n\t\treturn 0;\n\t}\n\n\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_PMA_DEVAD,\n\t\t\tMDIO_PMA_REG_8073_SPEED_LINK_STATUS, &link_status);\n\n\t \n\tif ((link_status & (1<<2)) && (!(link_status & (1<<15)))) {\n\t\tlink_up = 1;\n\t\tvars->line_speed = SPEED_10000;\n\t\tDP(NETIF_MSG_LINK, \"port %x: External link up in 10G\\n\",\n\t\t\t   params->port);\n\t} else if ((link_status & (1<<0)) && (!(link_status & (1<<13)))) {\n\t\tlink_up = 1;\n\t\tvars->line_speed = SPEED_1000;\n\t\tDP(NETIF_MSG_LINK, \"port %x: External link up in 1G\\n\",\n\t\t\t   params->port);\n\t} else {\n\t\tlink_up = 0;\n\t\tDP(NETIF_MSG_LINK, \"port %x: External link is down\\n\",\n\t\t\t   params->port);\n\t}\n\n\t \n\tif (vars->line_speed == SPEED_10000) {\n\t\tbnx2x_cl45_read(bp, phy, MDIO_PMA_DEVAD,\n\t\t\t    MDIO_PMA_LASI_TXSTAT, &val1);\n\n\t\tbnx2x_cl45_read(bp, phy, MDIO_PMA_DEVAD,\n\t\t\t    MDIO_PMA_LASI_TXSTAT, &val1);\n\n\t\tif (val1 & (1<<0)) {\n\t\t\tvars->fault_detected = 1;\n\t\t}\n\t}\n\n\tif (link_up) {\n\t\tbnx2x_ext_phy_resolve_fc(phy, params, vars);\n\t\tvars->duplex = DUPLEX_FULL;\n\t\tDP(NETIF_MSG_LINK, \"duplex = 0x%x\\n\", vars->duplex);\n\t}\n\n\tif ((DUAL_MEDIA(params)) &&\n\t    (phy->req_line_speed == SPEED_1000)) {\n\t\tbnx2x_cl45_read(bp, phy,\n\t\t\t\tMDIO_PMA_DEVAD,\n\t\t\t\tMDIO_PMA_REG_8727_PCS_GP, &val1);\n\t\t \n\t\tif (link_up)\n\t\t\tval1 &= ~(3<<10);\n\t\telse\n\t\t\tval1 |= (3<<10);\n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_PMA_DEVAD,\n\t\t\t\t MDIO_PMA_REG_8727_PCS_GP, val1);\n\t}\n\treturn link_up;\n}\n\nstatic void bnx2x_8727_link_reset(struct bnx2x_phy *phy,\n\t\t\t\t  struct link_params *params)\n{\n\tstruct bnx2x *bp = params->bp;\n\n\t \n\tbnx2x_set_disable_pmd_transmit(params, phy, 1);\n\n\t \n\tbnx2x_sfp_set_transmitter(params, phy, 0);\n\t \n\tbnx2x_cl45_write(bp, phy, MDIO_PMA_DEVAD, MDIO_PMA_LASI_CTRL, 0);\n\n}\n\n \n \n \nstatic int bnx2x_is_8483x_8485x(struct bnx2x_phy *phy)\n{\n\treturn ((phy->type == PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84833) ||\n\t\t(phy->type == PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84834) ||\n\t\t(phy->type == PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84858));\n}\n\nstatic void bnx2x_save_848xx_spirom_version(struct bnx2x_phy *phy,\n\t\t\t\t\t    struct bnx2x *bp,\n\t\t\t\t\t    u8 port)\n{\n\tu16 val, fw_ver2, cnt, i;\n\tstatic struct bnx2x_reg_set reg_set[] = {\n\t\t{MDIO_PMA_DEVAD, 0xA819, 0x0014},\n\t\t{MDIO_PMA_DEVAD, 0xA81A, 0xc200},\n\t\t{MDIO_PMA_DEVAD, 0xA81B, 0x0000},\n\t\t{MDIO_PMA_DEVAD, 0xA81C, 0x0300},\n\t\t{MDIO_PMA_DEVAD, 0xA817, 0x0009}\n\t};\n\tu16 fw_ver1;\n\n\tif (bnx2x_is_8483x_8485x(phy)) {\n\t\tbnx2x_cl45_read(bp, phy, MDIO_CTL_DEVAD, 0x400f, &fw_ver1);\n\t\tif (phy->type != PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84858)\n\t\t\tfw_ver1 &= 0xfff;\n\t\tbnx2x_save_spirom_version(bp, port, fw_ver1, phy->ver_addr);\n\t} else {\n\t\t \n\t\t \n\t\tfor (i = 0; i < ARRAY_SIZE(reg_set); i++)\n\t\t\tbnx2x_cl45_write(bp, phy, reg_set[i].devad,\n\t\t\t\t\t reg_set[i].reg, reg_set[i].val);\n\n\t\tfor (cnt = 0; cnt < 100; cnt++) {\n\t\t\tbnx2x_cl45_read(bp, phy, MDIO_PMA_DEVAD, 0xA818, &val);\n\t\t\tif (val & 1)\n\t\t\t\tbreak;\n\t\t\tudelay(5);\n\t\t}\n\t\tif (cnt == 100) {\n\t\t\tDP(NETIF_MSG_LINK, \"Unable to read 848xx \"\n\t\t\t\t\t\"phy fw version(1)\\n\");\n\t\t\tbnx2x_save_spirom_version(bp, port, 0,\n\t\t\t\t\t\t  phy->ver_addr);\n\t\t\treturn;\n\t\t}\n\n\n\t\t \n\t\tbnx2x_cl45_write(bp, phy, MDIO_PMA_DEVAD, 0xA819, 0x0000);\n\t\tbnx2x_cl45_write(bp, phy, MDIO_PMA_DEVAD, 0xA81A, 0xc200);\n\t\tbnx2x_cl45_write(bp, phy, MDIO_PMA_DEVAD, 0xA817, 0x000A);\n\t\tfor (cnt = 0; cnt < 100; cnt++) {\n\t\t\tbnx2x_cl45_read(bp, phy, MDIO_PMA_DEVAD, 0xA818, &val);\n\t\t\tif (val & 1)\n\t\t\t\tbreak;\n\t\t\tudelay(5);\n\t\t}\n\t\tif (cnt == 100) {\n\t\t\tDP(NETIF_MSG_LINK, \"Unable to read 848xx phy fw \"\n\t\t\t\t\t\"version(2)\\n\");\n\t\t\tbnx2x_save_spirom_version(bp, port, 0,\n\t\t\t\t\t\t  phy->ver_addr);\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tbnx2x_cl45_read(bp, phy, MDIO_PMA_DEVAD, 0xA81B, &fw_ver1);\n\t\t \n\t\tbnx2x_cl45_read(bp, phy, MDIO_PMA_DEVAD, 0xA81C, &fw_ver2);\n\n\t\tbnx2x_save_spirom_version(bp, port, (fw_ver2<<16) | fw_ver1,\n\t\t\t\t\t  phy->ver_addr);\n\t}\n\n}\nstatic void bnx2x_848xx_set_led(struct bnx2x *bp,\n\t\t\t\tstruct bnx2x_phy *phy)\n{\n\tu16 val, led3_blink_rate, offset, i;\n\tstatic struct bnx2x_reg_set reg_set[] = {\n\t\t{MDIO_PMA_DEVAD, MDIO_PMA_REG_8481_LED1_MASK, 0x0080},\n\t\t{MDIO_PMA_DEVAD, MDIO_PMA_REG_8481_LED2_MASK, 0x0018},\n\t\t{MDIO_PMA_DEVAD, MDIO_PMA_REG_8481_LED3_MASK, 0x0006},\n\t\t{MDIO_PMA_DEVAD, MDIO_PMA_REG_84823_CTL_SLOW_CLK_CNT_HIGH,\n\t\t\tMDIO_PMA_REG_84823_BLINK_RATE_VAL_15P9HZ},\n\t\t{MDIO_AN_DEVAD, 0xFFFB, 0xFFFD}\n\t};\n\n\tif (phy->type == PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84858) {\n\t\t \n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_PMA_DEVAD,\n\t\t\t\t MDIO_PMA_REG_8481_LED5_MASK,\n\t\t\t\t 0x90);\n\t\tled3_blink_rate = 0x000f;\n\t} else {\n\t\tled3_blink_rate = 0x0000;\n\t}\n\t \n\tbnx2x_cl45_write(bp, phy,\n\t\t\t MDIO_PMA_DEVAD,\n\t\t\t MDIO_PMA_REG_8481_LED3_BLINK,\n\t\t\t led3_blink_rate);\n\n\t \n\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_PMA_DEVAD,\n\t\t\tMDIO_PMA_REG_8481_LINK_SIGNAL, &val);\n\tval &= 0xFE00;\n\tval |= 0x0092;\n\n\tif (phy->type == PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84858)\n\t\tval |= 2 << 12;  \n\n\tbnx2x_cl45_write(bp, phy,\n\t\t\t MDIO_PMA_DEVAD,\n\t\t\t MDIO_PMA_REG_8481_LINK_SIGNAL, val);\n\n\tfor (i = 0; i < ARRAY_SIZE(reg_set); i++)\n\t\tbnx2x_cl45_write(bp, phy, reg_set[i].devad, reg_set[i].reg,\n\t\t\t\t reg_set[i].val);\n\n\tif (bnx2x_is_8483x_8485x(phy))\n\t\toffset = MDIO_PMA_REG_84833_CTL_LED_CTL_1;\n\telse\n\t\toffset = MDIO_PMA_REG_84823_CTL_LED_CTL_1;\n\n\tif (phy->type == PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84858)\n\t\tval = MDIO_PMA_REG_84858_ALLOW_GPHY_ACT |\n\t\t      MDIO_PMA_REG_84823_LED3_STRETCH_EN;\n\telse\n\t\tval = MDIO_PMA_REG_84823_LED3_STRETCH_EN;\n\n\t \n\tbnx2x_cl45_read_or_write(bp, phy,\n\t\t\t\t MDIO_PMA_DEVAD,\n\t\t\t\t offset,\n\t\t\t\t val);\n}\n\nstatic void bnx2x_848xx_specific_func(struct bnx2x_phy *phy,\n\t\t\t\t      struct link_params *params,\n\t\t\t\t      u32 action)\n{\n\tstruct bnx2x *bp = params->bp;\n\tswitch (action) {\n\tcase PHY_INIT:\n\t\tif (bnx2x_is_8483x_8485x(phy)) {\n\t\t\t \n\t\t\tbnx2x_save_848xx_spirom_version(phy, bp, params->port);\n\t\t}\n\t\t \n\t\tbnx2x_bits_en(bp, NIG_REG_LATCH_BC_0 + params->port*4,\n\t\t\t      1 << NIG_LATCH_BC_ENABLE_MI_INT);\n\n\t\tbnx2x_848xx_set_led(bp, phy);\n\t\tbreak;\n\t}\n}\n\nstatic int bnx2x_848xx_cmn_config_init(struct bnx2x_phy *phy,\n\t\t\t\t       struct link_params *params,\n\t\t\t\t       struct link_vars *vars)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu16 autoneg_val, an_1000_val, an_10_100_val;\n\n\tbnx2x_848xx_specific_func(phy, params, PHY_INIT);\n\tbnx2x_cl45_write(bp, phy,\n\t\t\t MDIO_PMA_DEVAD, MDIO_PMA_REG_CTRL, 0x0000);\n\n\t \n\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_AN_DEVAD, MDIO_AN_REG_8481_1000T_CTRL,\n\t\t\t&an_1000_val);\n\n\tbnx2x_ext_phy_set_pause(params, phy, vars);\n\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_AN_DEVAD,\n\t\t\tMDIO_AN_REG_8481_LEGACY_AN_ADV,\n\t\t\t&an_10_100_val);\n\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_AN_DEVAD, MDIO_AN_REG_8481_LEGACY_MII_CTRL,\n\t\t\t&autoneg_val);\n\t \n\tautoneg_val &= ~((1<<6) | (1<<8) | (1<<9) | (1<<12) | (1<<13));\n\tan_10_100_val &= ~((1<<5) | (1<<6) | (1<<7) | (1<<8));\n\n\tif (((phy->req_line_speed == SPEED_AUTO_NEG) &&\n\t     (phy->speed_cap_mask &\n\t     PORT_HW_CFG_SPEED_CAPABILITY_D0_1G)) ||\n\t    (phy->req_line_speed == SPEED_1000)) {\n\t\tan_1000_val |= (1<<8);\n\t\tautoneg_val |= (1<<9 | 1<<12);\n\t\tif (phy->req_duplex == DUPLEX_FULL)\n\t\t\tan_1000_val |= (1<<9);\n\t\tDP(NETIF_MSG_LINK, \"Advertising 1G\\n\");\n\t} else\n\t\tan_1000_val &= ~((1<<8) | (1<<9));\n\n\tbnx2x_cl45_write(bp, phy,\n\t\t\t MDIO_AN_DEVAD, MDIO_AN_REG_8481_1000T_CTRL,\n\t\t\t an_1000_val);\n\n\t \n\tif (phy->req_line_speed == SPEED_AUTO_NEG) {\n\t\tif (phy->speed_cap_mask &\n\t\t    PORT_HW_CFG_SPEED_CAPABILITY_D0_100M_FULL) {\n\t\t\t \n\t\t\tautoneg_val |= (1<<9 | 1<<12);\n\t\t\tan_10_100_val |= (1<<8);\n\t\t\tDP(NETIF_MSG_LINK, \"Advertising 100M-FD\\n\");\n\t\t}\n\n\t\tif (phy->speed_cap_mask &\n\t\t    PORT_HW_CFG_SPEED_CAPABILITY_D0_100M_HALF) {\n\t\t\t \n\t\t\tautoneg_val |= (1<<9 | 1<<12);\n\t\t\tan_10_100_val |= (1<<7);\n\t\t\tDP(NETIF_MSG_LINK, \"Advertising 100M-HD\\n\");\n\t\t}\n\n\t\tif ((phy->speed_cap_mask &\n\t\t     PORT_HW_CFG_SPEED_CAPABILITY_D0_10M_FULL) &&\n\t\t    (phy->supported & SUPPORTED_10baseT_Full)) {\n\t\t\tan_10_100_val |= (1<<6);\n\t\t\tautoneg_val |= (1<<9 | 1<<12);\n\t\t\tDP(NETIF_MSG_LINK, \"Advertising 10M-FD\\n\");\n\t\t}\n\n\t\tif ((phy->speed_cap_mask &\n\t\t     PORT_HW_CFG_SPEED_CAPABILITY_D0_10M_HALF) &&\n\t\t    (phy->supported & SUPPORTED_10baseT_Half)) {\n\t\t\tan_10_100_val |= (1<<5);\n\t\t\tautoneg_val |= (1<<9 | 1<<12);\n\t\t\tDP(NETIF_MSG_LINK, \"Advertising 10M-HD\\n\");\n\t\t}\n\t}\n\n\t \n\tif ((phy->req_line_speed == SPEED_100) &&\n\t    (phy->supported &\n\t     (SUPPORTED_100baseT_Half |\n\t      SUPPORTED_100baseT_Full))) {\n\t\tautoneg_val |= (1<<13);\n\t\t \n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_AN_DEVAD, MDIO_AN_REG_8481_AUX_CTRL,\n\t\t\t\t (1<<15 | 1<<9 | 7<<0));\n\t\t \n\t\tan_10_100_val |= (1<<8) | (1<<7);\n\t\tDP(NETIF_MSG_LINK, \"Setting 100M force\\n\");\n\t}\n\tif ((phy->req_line_speed == SPEED_10) &&\n\t    (phy->supported &\n\t     (SUPPORTED_10baseT_Half |\n\t      SUPPORTED_10baseT_Full))) {\n\t\t \n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_AN_DEVAD, MDIO_AN_REG_8481_AUX_CTRL,\n\t\t\t\t (1<<15 | 1<<9 | 7<<0));\n\t\tDP(NETIF_MSG_LINK, \"Setting 10M force\\n\");\n\t}\n\n\tbnx2x_cl45_write(bp, phy,\n\t\t\t MDIO_AN_DEVAD, MDIO_AN_REG_8481_LEGACY_AN_ADV,\n\t\t\t an_10_100_val);\n\n\tif (phy->req_duplex == DUPLEX_FULL)\n\t\tautoneg_val |= (1<<8);\n\n\t \n\tif (!bnx2x_is_8483x_8485x(phy) ||\n\t    ((autoneg_val & (1<<12)) == 0))\n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t MDIO_AN_DEVAD,\n\t\t\t MDIO_AN_REG_8481_LEGACY_MII_CTRL, autoneg_val);\n\n\tif (((phy->req_line_speed == SPEED_AUTO_NEG) &&\n\t    (phy->speed_cap_mask &\n\t     PORT_HW_CFG_SPEED_CAPABILITY_D0_10G)) ||\n\t\t(phy->req_line_speed == SPEED_10000)) {\n\t\t\tDP(NETIF_MSG_LINK, \"Advertising 10G\\n\");\n\t\t\t \n\n\t\t\tbnx2x_cl45_read_or_write(\n\t\t\t\tbp, phy,\n\t\t\t\tMDIO_AN_DEVAD,\n\t\t\t\tMDIO_AN_REG_8481_10GBASE_T_AN_CTRL,\n\t\t\t\t0x1000);\n\t\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t\t MDIO_AN_DEVAD, MDIO_AN_REG_CTRL,\n\t\t\t\t\t 0x3200);\n\t} else\n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_AN_DEVAD,\n\t\t\t\t MDIO_AN_REG_8481_10GBASE_T_AN_CTRL,\n\t\t\t\t 1);\n\n\treturn 0;\n}\n\nstatic void bnx2x_8481_config_init(struct bnx2x_phy *phy,\n\t\t\t\t   struct link_params *params,\n\t\t\t\t   struct link_vars *vars)\n{\n\tstruct bnx2x *bp = params->bp;\n\t \n\tbnx2x_set_gpio(bp, MISC_REGISTERS_GPIO_2,\n\t\t       MISC_REGISTERS_GPIO_OUTPUT_HIGH, params->port);\n\n\t \n\tbnx2x_ext_phy_hw_reset(bp, params->port);\n\tbnx2x_wait_reset_complete(bp, phy, params);\n\n\tbnx2x_cl45_write(bp, phy, MDIO_PMA_DEVAD, MDIO_PMA_REG_CTRL, 1<<15);\n\tbnx2x_848xx_cmn_config_init(phy, params, vars);\n}\n\n#define PHY848xx_CMDHDLR_WAIT 300\n#define PHY848xx_CMDHDLR_MAX_ARGS 5\n\nstatic int bnx2x_84858_cmd_hdlr(struct bnx2x_phy *phy,\n\t\t\t\tstruct link_params *params,\n\t\t\t\tu16 fw_cmd,\n\t\t\t\tu16 cmd_args[], int argc)\n{\n\tint idx;\n\tu16 val;\n\tstruct bnx2x *bp = params->bp;\n\n\t \n\n\tfor (idx = 0; idx < PHY848xx_CMDHDLR_WAIT; idx++) {\n\t\tbnx2x_cl45_read(bp, phy, MDIO_CTL_DEVAD,\n\t\t\t\tMDIO_848xx_CMD_HDLR_STATUS, &val);\n\t\tif ((val != PHY84858_STATUS_CMD_IN_PROGRESS) &&\n\t\t    (val != PHY84858_STATUS_CMD_SYSTEM_BUSY))\n\t\t\tbreak;\n\t\tusleep_range(1000, 2000);\n\t}\n\tif (idx >= PHY848xx_CMDHDLR_WAIT) {\n\t\tDP(NETIF_MSG_LINK, \"FW cmd: FW not ready.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\n\tfor (idx = 0; idx < argc; idx++) {\n\t\tbnx2x_cl45_write(bp, phy, MDIO_CTL_DEVAD,\n\t\t\t\t MDIO_848xx_CMD_HDLR_DATA1 + idx,\n\t\t\t\t cmd_args[idx]);\n\t}\n\n\t \n\tbnx2x_cl45_write(bp, phy, MDIO_CTL_DEVAD,\n\t\t\t MDIO_848xx_CMD_HDLR_COMMAND, fw_cmd);\n\n\t \n\n\tfor (idx = 0; idx < PHY848xx_CMDHDLR_WAIT; idx++) {\n\t\tbnx2x_cl45_read(bp, phy, MDIO_CTL_DEVAD,\n\t\t\t\tMDIO_848xx_CMD_HDLR_STATUS, &val);\n\t\tif ((val == PHY84858_STATUS_CMD_COMPLETE_PASS) ||\n\t\t    (val == PHY84858_STATUS_CMD_COMPLETE_ERROR))\n\t\t\tbreak;\n\t\tusleep_range(1000, 2000);\n\t}\n\tif ((idx >= PHY848xx_CMDHDLR_WAIT) ||\n\t    (val == PHY84858_STATUS_CMD_COMPLETE_ERROR)) {\n\t\tDP(NETIF_MSG_LINK, \"FW cmd failed.\\n\");\n\t\treturn -EINVAL;\n\t}\n\t \n\n\t \n\tfor (idx = 0; idx < argc; idx++) {\n\t\tbnx2x_cl45_read(bp, phy, MDIO_CTL_DEVAD,\n\t\t\t\tMDIO_848xx_CMD_HDLR_DATA1 + idx,\n\t\t\t\t&cmd_args[idx]);\n\t}\n\n\treturn 0;\n}\n\nstatic int bnx2x_84833_cmd_hdlr(struct bnx2x_phy *phy,\n\t\t\t\tstruct link_params *params, u16 fw_cmd,\n\t\t\t\tu16 cmd_args[], int argc, int process)\n{\n\tint idx;\n\tu16 val;\n\tstruct bnx2x *bp = params->bp;\n\tint rc = 0;\n\n\tif (process == PHY84833_MB_PROCESS2) {\n\t\t \n\t\tbnx2x_cl45_write(bp, phy, MDIO_CTL_DEVAD,\n\t\t\t\t MDIO_848xx_CMD_HDLR_STATUS,\n\t\t\t\t PHY84833_STATUS_CMD_OPEN_OVERRIDE);\n\t}\n\n\tfor (idx = 0; idx < PHY848xx_CMDHDLR_WAIT; idx++) {\n\t\tbnx2x_cl45_read(bp, phy, MDIO_CTL_DEVAD,\n\t\t\t\tMDIO_848xx_CMD_HDLR_STATUS, &val);\n\t\tif (val == PHY84833_STATUS_CMD_OPEN_FOR_CMDS)\n\t\t\tbreak;\n\t\tusleep_range(1000, 2000);\n\t}\n\tif (idx >= PHY848xx_CMDHDLR_WAIT) {\n\t\tDP(NETIF_MSG_LINK, \"FW cmd: FW not ready.\\n\");\n\t\t \n\t\tif (val == PHY84833_STATUS_CMD_COMPLETE_PASS ||\n\t\t    val == PHY84833_STATUS_CMD_COMPLETE_ERROR) {\n\t\t\tbnx2x_cl45_write(bp, phy, MDIO_CTL_DEVAD,\n\t\t\t\t\t MDIO_848xx_CMD_HDLR_STATUS,\n\t\t\t\t\t PHY84833_STATUS_CMD_CLEAR_COMPLETE);\n\t\t}\n\t\treturn -EINVAL;\n\t}\n\tif (process == PHY84833_MB_PROCESS1 ||\n\t    process == PHY84833_MB_PROCESS2) {\n\t\t \n\t\tfor (idx = 0; idx < argc; idx++) {\n\t\t\tbnx2x_cl45_write(bp, phy, MDIO_CTL_DEVAD,\n\t\t\t\t\t MDIO_848xx_CMD_HDLR_DATA1 + idx,\n\t\t\t\t\t cmd_args[idx]);\n\t\t}\n\t}\n\n\tbnx2x_cl45_write(bp, phy, MDIO_CTL_DEVAD,\n\t\t\tMDIO_848xx_CMD_HDLR_COMMAND, fw_cmd);\n\tfor (idx = 0; idx < PHY848xx_CMDHDLR_WAIT; idx++) {\n\t\tbnx2x_cl45_read(bp, phy, MDIO_CTL_DEVAD,\n\t\t\t\tMDIO_848xx_CMD_HDLR_STATUS, &val);\n\t\tif ((val == PHY84833_STATUS_CMD_COMPLETE_PASS) ||\n\t\t    (val == PHY84833_STATUS_CMD_COMPLETE_ERROR))\n\t\t\tbreak;\n\t\tusleep_range(1000, 2000);\n\t}\n\tif ((idx >= PHY848xx_CMDHDLR_WAIT) ||\n\t    (val == PHY84833_STATUS_CMD_COMPLETE_ERROR)) {\n\t\tDP(NETIF_MSG_LINK, \"FW cmd failed.\\n\");\n\t\trc = -EINVAL;\n\t}\n\tif (process == PHY84833_MB_PROCESS3 && rc == 0) {\n\t\t \n\t\tfor (idx = 0; idx < argc; idx++) {\n\t\t\tbnx2x_cl45_read(bp, phy, MDIO_CTL_DEVAD,\n\t\t\t\t\tMDIO_848xx_CMD_HDLR_DATA1 + idx,\n\t\t\t\t\t&cmd_args[idx]);\n\t\t}\n\t}\n\tif (val == PHY84833_STATUS_CMD_COMPLETE_ERROR ||\n\t    val == PHY84833_STATUS_CMD_COMPLETE_PASS) {\n\t\tbnx2x_cl45_write(bp, phy, MDIO_CTL_DEVAD,\n\t\t\t\t MDIO_848xx_CMD_HDLR_STATUS,\n\t\t\t\t PHY84833_STATUS_CMD_CLEAR_COMPLETE);\n\t}\n\treturn rc;\n}\n\nstatic int bnx2x_848xx_cmd_hdlr(struct bnx2x_phy *phy,\n\t\t\t\tstruct link_params *params,\n\t\t\t\tu16 fw_cmd,\n\t\t\t\t\t   u16 cmd_args[], int argc,\n\t\t\t\t\t   int process)\n{\n\tstruct bnx2x *bp = params->bp;\n\n\tif ((phy->type == PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84858) ||\n\t    (REG_RD(bp, params->shmem2_base +\n\t\t    offsetof(struct shmem2_region,\n\t\t\t     link_attr_sync[params->port])) &\n\t     LINK_ATTR_84858)) {\n\t\treturn bnx2x_84858_cmd_hdlr(phy, params, fw_cmd, cmd_args,\n\t\t\t\t\t    argc);\n\t} else {\n\t\treturn bnx2x_84833_cmd_hdlr(phy, params, fw_cmd, cmd_args,\n\t\t\t\t\t    argc, process);\n\t}\n}\n\nstatic int bnx2x_848xx_pair_swap_cfg(struct bnx2x_phy *phy,\n\t\t\t\t     struct link_params *params,\n\t\t\t\t     struct link_vars *vars)\n{\n\tu32 pair_swap;\n\tu16 data[PHY848xx_CMDHDLR_MAX_ARGS];\n\tint status;\n\tstruct bnx2x *bp = params->bp;\n\n\t \n\tpair_swap = REG_RD(bp, params->shmem_base +\n\t\t\t   offsetof(struct shmem_region,\n\t\t\tdev_info.port_hw_config[params->port].xgbt_phy_cfg)) &\n\t\tPORT_HW_CFG_RJ45_PAIR_SWAP_MASK;\n\n\tif (pair_swap == 0)\n\t\treturn 0;\n\n\t \n\tdata[1] = (u16)pair_swap;\n\n\tstatus = bnx2x_848xx_cmd_hdlr(phy, params,\n\t\t\t\t      PHY848xx_CMD_SET_PAIR_SWAP, data,\n\t\t\t\t      2, PHY84833_MB_PROCESS2);\n\tif (status == 0)\n\t\tDP(NETIF_MSG_LINK, \"Pairswap OK, val=0x%x\\n\", data[1]);\n\n\treturn status;\n}\n\nstatic u8 bnx2x_84833_get_reset_gpios(struct bnx2x *bp,\n\t\t\t\t      u32 shmem_base_path[],\n\t\t\t\t      u32 chip_id)\n{\n\tu32 reset_pin[2];\n\tu32 idx;\n\tu8 reset_gpios;\n\tif (CHIP_IS_E3(bp)) {\n\t\t \n\t\tfor (idx = 0; idx < 2; idx++) {\n\t\t\t \n\t\t\treset_pin[idx] = REG_RD(bp, shmem_base_path[idx] +\n\t\t\t\toffsetof(struct shmem_region,\n\t\t\t\tdev_info.port_hw_config[0].e3_cmn_pin_cfg));\n\t\t\treset_pin[idx] = (reset_pin[idx] &\n\t\t\t\tPORT_HW_CFG_E3_PHY_RESET_MASK) >>\n\t\t\t\tPORT_HW_CFG_E3_PHY_RESET_SHIFT;\n\t\t\treset_pin[idx] -= PIN_CFG_GPIO0_P0;\n\t\t\treset_pin[idx] = (1 << reset_pin[idx]);\n\t\t}\n\t\treset_gpios = (u8)(reset_pin[0] | reset_pin[1]);\n\t} else {\n\t\t \n\t\tfor (idx = 0; idx < 2; idx++) {\n\t\t\treset_pin[idx] = REG_RD(bp, shmem_base_path[idx] +\n\t\t\t\toffsetof(struct shmem_region,\n\t\t\t\tdev_info.port_hw_config[0].default_cfg));\n\t\t\treset_pin[idx] &= PORT_HW_CFG_EXT_PHY_GPIO_RST_MASK;\n\t\t\treset_pin[idx] -= PORT_HW_CFG_EXT_PHY_GPIO_RST_GPIO0_P0;\n\t\t\treset_pin[idx] >>= PORT_HW_CFG_EXT_PHY_GPIO_RST_SHIFT;\n\t\t\treset_pin[idx] = (1 << reset_pin[idx]);\n\t\t}\n\t\treset_gpios = (u8)(reset_pin[0] | reset_pin[1]);\n\t}\n\n\treturn reset_gpios;\n}\n\nstatic void bnx2x_84833_hw_reset_phy(struct bnx2x_phy *phy,\n\t\t\t\t     struct link_params *params)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu8 reset_gpios;\n\tu32 other_shmem_base_addr = REG_RD(bp, params->shmem2_base +\n\t\t\t\toffsetof(struct shmem2_region,\n\t\t\t\tother_shmem_base_addr));\n\n\tu32 shmem_base_path[2];\n\n\t \n\tbnx2x_cl45_write(bp, phy, MDIO_AN_DEVAD,\n\t\tMDIO_AN_REG_8481_LEGACY_MII_CTRL,\n\t\tMDIO_AN_REG_8481_MII_CTRL_FORCE_1G);\n\tbnx2x_cl45_write(bp, phy, MDIO_AN_DEVAD,\n\t\tMDIO_AN_REG_8481_1G_100T_EXT_CTRL,\n\t\tMIDO_AN_REG_8481_EXT_CTRL_FORCE_LEDS_OFF);\n\n\tshmem_base_path[0] = params->shmem_base;\n\tshmem_base_path[1] = other_shmem_base_addr;\n\n\treset_gpios = bnx2x_84833_get_reset_gpios(bp, shmem_base_path,\n\t\t\t\t\t\t  params->chip_id);\n\n\tbnx2x_set_mult_gpio(bp, reset_gpios, MISC_REGISTERS_GPIO_OUTPUT_LOW);\n\tudelay(10);\n\tDP(NETIF_MSG_LINK, \"84833 hw reset on pin values 0x%x\\n\",\n\t\treset_gpios);\n}\n\nstatic int bnx2x_8483x_disable_eee(struct bnx2x_phy *phy,\n\t\t\t\t   struct link_params *params,\n\t\t\t\t   struct link_vars *vars)\n{\n\tint rc;\n\tstruct bnx2x *bp = params->bp;\n\tu16 cmd_args = 0;\n\n\tDP(NETIF_MSG_LINK, \"Don't Advertise 10GBase-T EEE\\n\");\n\n\t \n\trc = bnx2x_848xx_cmd_hdlr(phy, params, PHY848xx_CMD_SET_EEE_MODE,\n\t\t\t\t  &cmd_args, 1, PHY84833_MB_PROCESS1);\n\tif (rc) {\n\t\tDP(NETIF_MSG_LINK, \"EEE disable failed.\\n\");\n\t\treturn rc;\n\t}\n\n\treturn bnx2x_eee_disable(phy, params, vars);\n}\n\nstatic int bnx2x_8483x_enable_eee(struct bnx2x_phy *phy,\n\t\t\t\t   struct link_params *params,\n\t\t\t\t   struct link_vars *vars)\n{\n\tint rc;\n\tstruct bnx2x *bp = params->bp;\n\tu16 cmd_args = 1;\n\n\trc = bnx2x_848xx_cmd_hdlr(phy, params, PHY848xx_CMD_SET_EEE_MODE,\n\t\t\t\t  &cmd_args, 1, PHY84833_MB_PROCESS1);\n\tif (rc) {\n\t\tDP(NETIF_MSG_LINK, \"EEE enable failed.\\n\");\n\t\treturn rc;\n\t}\n\n\treturn bnx2x_eee_advertise(phy, params, vars, SHMEM_EEE_10G_ADV);\n}\n\n#define PHY84833_CONSTANT_LATENCY 1193\nstatic void bnx2x_848x3_config_init(struct bnx2x_phy *phy,\n\t\t\t\t    struct link_params *params,\n\t\t\t\t    struct link_vars *vars)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu8 port, initialize = 1;\n\tu16 val;\n\tu32 actual_phy_selection;\n\tu16 cmd_args[PHY848xx_CMDHDLR_MAX_ARGS];\n\tint rc = 0;\n\n\tusleep_range(1000, 2000);\n\n\tif (!(CHIP_IS_E1x(bp)))\n\t\tport = BP_PATH(bp);\n\telse\n\t\tport = params->port;\n\n\tif (phy->type == PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84823) {\n\t\tbnx2x_set_gpio(bp, MISC_REGISTERS_GPIO_3,\n\t\t\t       MISC_REGISTERS_GPIO_OUTPUT_HIGH,\n\t\t\t       port);\n\t} else {\n\t\t \n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\tMDIO_PMA_DEVAD,\n\t\t\t\tMDIO_PMA_REG_CTRL, 0x8000);\n\t}\n\n\tbnx2x_wait_reset_complete(bp, phy, params);\n\n\t \n\tmsleep(50);\n\tif (!bnx2x_is_8483x_8485x(phy)) {\n\t\t \n\t\tu16 temp;\n\t\ttemp = vars->line_speed;\n\t\tvars->line_speed = SPEED_10000;\n\t\tbnx2x_set_autoneg(&params->phy[INT_PHY], params, vars, 0);\n\t\tbnx2x_program_serdes(&params->phy[INT_PHY], params, vars);\n\t\tvars->line_speed = temp;\n\t}\n\t \n\tif (phy->type != PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84858) {\n\t\tu16 hw_rev;\n\n\t\tbnx2x_cl45_read(bp, phy, MDIO_AN_DEVAD,\n\t\t\t\tMDIO_AN_REG_848xx_ID_MSB, &hw_rev);\n\t\tif (hw_rev == BCM84858_PHY_ID) {\n\t\t\tparams->link_attr_sync |= LINK_ATTR_84858;\n\t\t\tbnx2x_update_link_attr(params, params->link_attr_sync);\n\t\t}\n\t}\n\n\t \n\tbnx2x_cl45_read(bp, phy, MDIO_CTL_DEVAD,\n\t\t\tMDIO_CTL_REG_84823_MEDIA, &val);\n\tval &= ~(MDIO_CTL_REG_84823_MEDIA_MAC_MASK |\n\t\t MDIO_CTL_REG_84823_MEDIA_LINE_MASK |\n\t\t MDIO_CTL_REG_84823_MEDIA_COPPER_CORE_DOWN |\n\t\t MDIO_CTL_REG_84823_MEDIA_PRIORITY_MASK |\n\t\t MDIO_CTL_REG_84823_MEDIA_FIBER_1G);\n\n\tif (CHIP_IS_E3(bp)) {\n\t\tval &= ~(MDIO_CTL_REG_84823_MEDIA_MAC_MASK |\n\t\t\t MDIO_CTL_REG_84823_MEDIA_LINE_MASK);\n\t} else {\n\t\tval |= (MDIO_CTL_REG_84823_CTRL_MAC_XFI |\n\t\t\tMDIO_CTL_REG_84823_MEDIA_LINE_XAUI_L);\n\t}\n\n\tactual_phy_selection = bnx2x_phy_selection(params);\n\n\tswitch (actual_phy_selection) {\n\tcase PORT_HW_CFG_PHY_SELECTION_HARDWARE_DEFAULT:\n\t\t \n\t\tbreak;\n\tcase PORT_HW_CFG_PHY_SELECTION_FIRST_PHY_PRIORITY:\n\t\tval |= MDIO_CTL_REG_84823_MEDIA_PRIORITY_COPPER;\n\t\tbreak;\n\tcase PORT_HW_CFG_PHY_SELECTION_SECOND_PHY_PRIORITY:\n\t\tval |= MDIO_CTL_REG_84823_MEDIA_PRIORITY_FIBER;\n\t\tbreak;\n\tcase PORT_HW_CFG_PHY_SELECTION_FIRST_PHY:\n\t\t \n\t\tbreak;\n\tcase PORT_HW_CFG_PHY_SELECTION_SECOND_PHY:\n\t\tval |= MDIO_CTL_REG_84823_MEDIA_COPPER_CORE_DOWN;\n\t\tinitialize = 0;\n\t\tbreak;\n\t}\n\tif (params->phy[EXT_PHY2].req_line_speed == SPEED_1000)\n\t\tval |= MDIO_CTL_REG_84823_MEDIA_FIBER_1G;\n\n\tbnx2x_cl45_write(bp, phy, MDIO_CTL_DEVAD,\n\t\t\t MDIO_CTL_REG_84823_MEDIA, val);\n\tDP(NETIF_MSG_LINK, \"Multi_phy config = 0x%x, Media control = 0x%x\\n\",\n\t\t   params->multi_phy_config, val);\n\n\tif (bnx2x_is_8483x_8485x(phy)) {\n\t\tbnx2x_848xx_pair_swap_cfg(phy, params, vars);\n\n\t\t \n\t\tcmd_args[0] = 0x0;\n\t\tcmd_args[1] = 0x0;\n\t\tcmd_args[2] = PHY84833_CONSTANT_LATENCY + 1;\n\t\tcmd_args[3] = PHY84833_CONSTANT_LATENCY;\n\t\trc = bnx2x_848xx_cmd_hdlr(phy, params,\n\t\t\t\t\t  PHY848xx_CMD_SET_EEE_MODE, cmd_args,\n\t\t\t\t\t  4, PHY84833_MB_PROCESS1);\n\t\tif (rc)\n\t\t\tDP(NETIF_MSG_LINK, \"Cfg AutogrEEEn failed.\\n\");\n\t}\n\tif (initialize)\n\t\trc = bnx2x_848xx_cmn_config_init(phy, params, vars);\n\telse\n\t\tbnx2x_save_848xx_spirom_version(phy, bp, params->port);\n\t \n\tif (phy->type == PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84823) {\n\t\tu32 cms_enable = REG_RD(bp, params->shmem_base +\n\t\t\toffsetof(struct shmem_region,\n\t\t\tdev_info.port_hw_config[params->port].default_cfg)) &\n\t\t\tPORT_HW_CFG_ENABLE_CMS_MASK;\n\n\t\tbnx2x_cl45_read(bp, phy, MDIO_CTL_DEVAD,\n\t\t\t\tMDIO_CTL_REG_84823_USER_CTRL_REG, &val);\n\t\tif (cms_enable)\n\t\t\tval |= MDIO_CTL_REG_84823_USER_CTRL_CMS;\n\t\telse\n\t\t\tval &= ~MDIO_CTL_REG_84823_USER_CTRL_CMS;\n\t\tbnx2x_cl45_write(bp, phy, MDIO_CTL_DEVAD,\n\t\t\t\t MDIO_CTL_REG_84823_USER_CTRL_REG, val);\n\t}\n\n\tbnx2x_cl45_read(bp, phy, MDIO_CTL_DEVAD,\n\t\t\tMDIO_84833_TOP_CFG_FW_REV, &val);\n\n\t \n\tif ((val >= MDIO_84833_TOP_CFG_FW_EEE) &&\n\t    (val != MDIO_84833_TOP_CFG_FW_NO_EEE) &&\n\t    bnx2x_eee_has_cap(params)) {\n\t\trc = bnx2x_eee_initial_config(params, vars, SHMEM_EEE_10G_ADV);\n\t\tif (rc) {\n\t\t\tDP(NETIF_MSG_LINK, \"Failed to configure EEE timers\\n\");\n\t\t\tbnx2x_8483x_disable_eee(phy, params, vars);\n\t\t\treturn;\n\t\t}\n\n\t\tif ((phy->req_duplex == DUPLEX_FULL) &&\n\t\t    (params->eee_mode & EEE_MODE_ADV_LPI) &&\n\t\t    (bnx2x_eee_calc_timer(params) ||\n\t\t     !(params->eee_mode & EEE_MODE_ENABLE_LPI)))\n\t\t\trc = bnx2x_8483x_enable_eee(phy, params, vars);\n\t\telse\n\t\t\trc = bnx2x_8483x_disable_eee(phy, params, vars);\n\t\tif (rc) {\n\t\t\tDP(NETIF_MSG_LINK, \"Failed to set EEE advertisement\\n\");\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tvars->eee_status &= ~SHMEM_EEE_SUPPORTED_MASK;\n\t}\n\n\tif (phy->type == PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84833) {\n\t\t \n\t\t \n\t\tbnx2x_cl45_read(bp, phy, MDIO_AN_DEVAD,\n\t\t\t\tMDIO_AN_REG_8481_AUX_CTRL, &val);\n\t\tval |= 0x4000;\n\t\tbnx2x_cl45_write(bp, phy, MDIO_AN_DEVAD,\n\t\t\t\t MDIO_AN_REG_8481_AUX_CTRL, val);\n\t\t \n\t\tbnx2x_cl45_read(bp, phy, MDIO_AN_DEVAD,\n\t\t\t\tMDIO_AN_REG_8481_1G_100T_EXT_CTRL, &val);\n\t\tval |= 0x1;\n\t\tbnx2x_cl45_write(bp, phy, MDIO_AN_DEVAD,\n\t\t\t\t MDIO_AN_REG_8481_1G_100T_EXT_CTRL, val);\n\t\t \n\t\t \n\t\tbnx2x_cl45_write(bp, phy, MDIO_AN_DEVAD,\n\t\t\t\t MDIO_AN_REG_8481_EXPANSION_REG_ACCESS, 0xf46);\n\n\t\tbnx2x_cl45_read(bp, phy, MDIO_AN_DEVAD,\n\t\t\t\tMDIO_AN_REG_8481_EXPANSION_REG_RD_RW, &val);\n\t\tval |= 0x4000;\n\t\tbnx2x_cl45_write(bp, phy, MDIO_AN_DEVAD,\n\t\t\t\t MDIO_AN_REG_8481_EXPANSION_REG_RD_RW, val);\n\t}\n\n\tif (bnx2x_is_8483x_8485x(phy)) {\n\t\t \n\t\tbnx2x_cl45_read_and_write(bp, phy,\n\t\t\t\t\t  MDIO_CTL_DEVAD,\n\t\t\t\t\t  MDIO_84833_TOP_CFG_XGPHY_STRAP1,\n\t\t\t\t\t  (u16)~MDIO_84833_SUPER_ISOLATE);\n\t}\n}\n\nstatic u8 bnx2x_848xx_read_status(struct bnx2x_phy *phy,\n\t\t\t\t  struct link_params *params,\n\t\t\t\t  struct link_vars *vars)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu16 val, val1, val2;\n\tu8 link_up = 0;\n\n\n\t \n\t \n\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_AN_DEVAD, 0xFFFA, &val1);\n\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_PMA_DEVAD, MDIO_PMA_REG_8481_PMD_SIGNAL,\n\t\t\t&val2);\n\tDP(NETIF_MSG_LINK, \"BCM848xx: PMD_SIGNAL 1.a811 = 0x%x\\n\", val2);\n\n\t \n\tif (val2 & (1<<11)) {\n\t\tvars->line_speed = SPEED_10000;\n\t\tvars->duplex = DUPLEX_FULL;\n\t\tlink_up = 1;\n\t\tbnx2x_ext_phy_10G_an_resolve(bp, phy, vars);\n\t} else {  \n\t\tu16 legacy_status, legacy_speed;\n\n\t\t \n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_AN_DEVAD,\n\t\t\t\t MDIO_AN_REG_8481_EXPANSION_REG_ACCESS, 0xf42);\n\n\t\t \n\t\tbnx2x_cl45_read(bp, phy,\n\t\t\t\tMDIO_AN_DEVAD,\n\t\t\t\tMDIO_AN_REG_8481_EXPANSION_REG_RD_RW,\n\t\t\t\t&legacy_status);\n\n\t\tDP(NETIF_MSG_LINK, \"Legacy speed status = 0x%x\\n\",\n\t\t   legacy_status);\n\t\tlink_up = ((legacy_status & (1<<11)) == (1<<11));\n\t\tlegacy_speed = (legacy_status & (3<<9));\n\t\tif (legacy_speed == (0<<9))\n\t\t\tvars->line_speed = SPEED_10;\n\t\telse if (legacy_speed == (1<<9))\n\t\t\tvars->line_speed = SPEED_100;\n\t\telse if (legacy_speed == (2<<9))\n\t\t\tvars->line_speed = SPEED_1000;\n\t\telse {  \n\t\t\tvars->line_speed = 0;\n\t\t\tlink_up = 0;\n\t\t}\n\n\t\tif (link_up) {\n\t\t\tif (legacy_status & (1<<8))\n\t\t\t\tvars->duplex = DUPLEX_FULL;\n\t\t\telse\n\t\t\t\tvars->duplex = DUPLEX_HALF;\n\n\t\t\tDP(NETIF_MSG_LINK,\n\t\t\t   \"Link is up in %dMbps, is_duplex_full= %d\\n\",\n\t\t\t   vars->line_speed,\n\t\t\t   (vars->duplex == DUPLEX_FULL));\n\t\t\t \n\t\t\tbnx2x_cl45_read(bp, phy,\n\t\t\t\t\tMDIO_AN_DEVAD,\n\t\t\t\t\tMDIO_AN_REG_8481_LEGACY_MII_STATUS,\n\t\t\t\t\t&val);\n\t\t\tif (val & (1<<5))\n\t\t\t\tvars->link_status |=\n\t\t\t\t\tLINK_STATUS_AUTO_NEGOTIATE_COMPLETE;\n\t\t\tbnx2x_cl45_read(bp, phy,\n\t\t\t\t\tMDIO_AN_DEVAD,\n\t\t\t\t\tMDIO_AN_REG_8481_LEGACY_AN_EXPANSION,\n\t\t\t\t\t&val);\n\t\t\tif ((val & (1<<0)) == 0)\n\t\t\t\tvars->link_status |=\n\t\t\t\t\tLINK_STATUS_PARALLEL_DETECTION_USED;\n\t\t}\n\t}\n\tif (link_up) {\n\t\tDP(NETIF_MSG_LINK, \"BCM848x3: link speed is %d\\n\",\n\t\t\t   vars->line_speed);\n\t\tbnx2x_ext_phy_resolve_fc(phy, params, vars);\n\n\t\t \n\t\tbnx2x_cl45_read(bp, phy, MDIO_AN_DEVAD,\n\t\t\t\tMDIO_AN_REG_CL37_FC_LP, &val);\n\t\tif (val & (1<<5))\n\t\t\tvars->link_status |=\n\t\t\t\tLINK_STATUS_LINK_PARTNER_10THD_CAPABLE;\n\t\tif (val & (1<<6))\n\t\t\tvars->link_status |=\n\t\t\t\tLINK_STATUS_LINK_PARTNER_10TFD_CAPABLE;\n\t\tif (val & (1<<7))\n\t\t\tvars->link_status |=\n\t\t\t\tLINK_STATUS_LINK_PARTNER_100TXHD_CAPABLE;\n\t\tif (val & (1<<8))\n\t\t\tvars->link_status |=\n\t\t\t\tLINK_STATUS_LINK_PARTNER_100TXFD_CAPABLE;\n\t\tif (val & (1<<9))\n\t\t\tvars->link_status |=\n\t\t\t\tLINK_STATUS_LINK_PARTNER_100T4_CAPABLE;\n\n\t\tbnx2x_cl45_read(bp, phy, MDIO_AN_DEVAD,\n\t\t\t\tMDIO_AN_REG_1000T_STATUS, &val);\n\n\t\tif (val & (1<<10))\n\t\t\tvars->link_status |=\n\t\t\t\tLINK_STATUS_LINK_PARTNER_1000THD_CAPABLE;\n\t\tif (val & (1<<11))\n\t\t\tvars->link_status |=\n\t\t\t\tLINK_STATUS_LINK_PARTNER_1000TFD_CAPABLE;\n\n\t\tbnx2x_cl45_read(bp, phy, MDIO_AN_DEVAD,\n\t\t\t\tMDIO_AN_REG_MASTER_STATUS, &val);\n\n\t\tif (val & (1<<11))\n\t\t\tvars->link_status |=\n\t\t\t\tLINK_STATUS_LINK_PARTNER_10GXFD_CAPABLE;\n\n\t\t \n\t\tif (bnx2x_is_8483x_8485x(phy))\n\t\t\tbnx2x_eee_an_resolve(phy, params, vars);\n\t}\n\n\treturn link_up;\n}\n\nstatic int bnx2x_8485x_format_ver(u32 raw_ver, u8 *str, u16 *len)\n{\n\tu32 num;\n\n\tnum = ((raw_ver & 0xF80) >> 7) << 16 | ((raw_ver & 0x7F) << 8) |\n\t      ((raw_ver & 0xF000) >> 12);\n\treturn bnx2x_3_seq_format_ver(num, str, len);\n}\n\nstatic int bnx2x_848xx_format_ver(u32 raw_ver, u8 *str, u16 *len)\n{\n\tu32 spirom_ver;\n\n\tspirom_ver = ((raw_ver & 0xF80) >> 7) << 16 | (raw_ver & 0x7F);\n\treturn bnx2x_format_ver(spirom_ver, str, len);\n}\n\nstatic void bnx2x_8481_hw_reset(struct bnx2x_phy *phy,\n\t\t\t\tstruct link_params *params)\n{\n\tbnx2x_set_gpio(params->bp, MISC_REGISTERS_GPIO_1,\n\t\t       MISC_REGISTERS_GPIO_OUTPUT_LOW, 0);\n\tbnx2x_set_gpio(params->bp, MISC_REGISTERS_GPIO_1,\n\t\t       MISC_REGISTERS_GPIO_OUTPUT_LOW, 1);\n}\n\nstatic void bnx2x_8481_link_reset(struct bnx2x_phy *phy,\n\t\t\t\t\tstruct link_params *params)\n{\n\tbnx2x_cl45_write(params->bp, phy,\n\t\t\t MDIO_AN_DEVAD, MDIO_AN_REG_CTRL, 0x0000);\n\tbnx2x_cl45_write(params->bp, phy,\n\t\t\t MDIO_PMA_DEVAD, MDIO_PMA_REG_CTRL, 1);\n}\n\nstatic void bnx2x_848x3_link_reset(struct bnx2x_phy *phy,\n\t\t\t\t   struct link_params *params)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu8 port;\n\tu16 val16;\n\n\tif (!(CHIP_IS_E1x(bp)))\n\t\tport = BP_PATH(bp);\n\telse\n\t\tport = params->port;\n\n\tif (phy->type == PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84823) {\n\t\tbnx2x_set_gpio(bp, MISC_REGISTERS_GPIO_3,\n\t\t\t       MISC_REGISTERS_GPIO_OUTPUT_LOW,\n\t\t\t       port);\n\t} else {\n\t\tbnx2x_cl45_read(bp, phy,\n\t\t\t\tMDIO_CTL_DEVAD,\n\t\t\t\tMDIO_84833_TOP_CFG_XGPHY_STRAP1, &val16);\n\t\tval16 |= MDIO_84833_SUPER_ISOLATE;\n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_CTL_DEVAD,\n\t\t\t\t MDIO_84833_TOP_CFG_XGPHY_STRAP1, val16);\n\t}\n}\n\nstatic void bnx2x_848xx_set_link_led(struct bnx2x_phy *phy,\n\t\t\t\t     struct link_params *params, u8 mode)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu16 val;\n\tu8 port;\n\n\tif (!(CHIP_IS_E1x(bp)))\n\t\tport = BP_PATH(bp);\n\telse\n\t\tport = params->port;\n\n\tswitch (mode) {\n\tcase LED_MODE_OFF:\n\n\t\tDP(NETIF_MSG_LINK, \"Port 0x%x: LED MODE OFF\\n\", port);\n\n\t\tif ((params->hw_led_mode << SHARED_HW_CFG_LED_MODE_SHIFT) ==\n\t\t    SHARED_HW_CFG_LED_EXTPHY1) {\n\n\t\t\t \n\t\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t\tMDIO_PMA_DEVAD,\n\t\t\t\t\tMDIO_PMA_REG_8481_LED1_MASK,\n\t\t\t\t\t0x0);\n\n\t\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t\tMDIO_PMA_DEVAD,\n\t\t\t\t\tMDIO_PMA_REG_8481_LED2_MASK,\n\t\t\t\t\t0x0);\n\n\t\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t\tMDIO_PMA_DEVAD,\n\t\t\t\t\tMDIO_PMA_REG_8481_LED3_MASK,\n\t\t\t\t\t0x0);\n\n\t\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t\tMDIO_PMA_DEVAD,\n\t\t\t\t\tMDIO_PMA_REG_8481_LED5_MASK,\n\t\t\t\t\t0x0);\n\n\t\t} else {\n\t\t\t \n\t\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t\t MDIO_PMA_DEVAD,\n\t\t\t\t\t MDIO_PMA_REG_8481_LED1_MASK,\n\t\t\t\t\t 0x0);\n\n\t\t\tif (phy->type ==\n\t\t\t\tPORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84858) {\n\t\t\t\t \n\t\t\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t\t\t MDIO_PMA_DEVAD,\n\t\t\t\t\t\t MDIO_PMA_REG_8481_LED2_MASK,\n\t\t\t\t\t\t 0x0);\n\t\t\t\t \n\t\t\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t\t\t MDIO_PMA_DEVAD,\n\t\t\t\t\t\t MDIO_PMA_REG_8481_LED3_MASK,\n\t\t\t\t\t\t 0x0);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase LED_MODE_FRONT_PANEL_OFF:\n\n\t\tDP(NETIF_MSG_LINK, \"Port 0x%x: LED MODE FRONT PANEL OFF\\n\",\n\t\t   port);\n\n\t\tif ((params->hw_led_mode << SHARED_HW_CFG_LED_MODE_SHIFT) ==\n\t\t    SHARED_HW_CFG_LED_EXTPHY1) {\n\n\t\t\t \n\t\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t\t MDIO_PMA_DEVAD,\n\t\t\t\t\t MDIO_PMA_REG_8481_LED1_MASK,\n\t\t\t\t\t 0x0);\n\n\t\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t\t MDIO_PMA_DEVAD,\n\t\t\t\t\t MDIO_PMA_REG_8481_LED2_MASK,\n\t\t\t\t\t 0x0);\n\n\t\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t\t MDIO_PMA_DEVAD,\n\t\t\t\t\t MDIO_PMA_REG_8481_LED3_MASK,\n\t\t\t\t\t 0x0);\n\n\t\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t\t MDIO_PMA_DEVAD,\n\t\t\t\t\t MDIO_PMA_REG_8481_LED5_MASK,\n\t\t\t\t\t 0x20);\n\n\t\t} else {\n\t\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t\t MDIO_PMA_DEVAD,\n\t\t\t\t\t MDIO_PMA_REG_8481_LED1_MASK,\n\t\t\t\t\t 0x0);\n\t\t\tif (phy->type ==\n\t\t\t    PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84834) {\n\t\t\t\t \n\t\t\t\tif (REG_RD(bp, NIG_REG_MASK_INTERRUPT_PORT0 +\n\t\t\t\t\t   params->port*4) &\n\t\t\t\t    NIG_MASK_MI_INT) {\n\t\t\t\t\tparams->link_flags |=\n\t\t\t\t\tLINK_FLAGS_INT_DISABLED;\n\n\t\t\t\t\tbnx2x_bits_dis(\n\t\t\t\t\t\tbp,\n\t\t\t\t\t\tNIG_REG_MASK_INTERRUPT_PORT0 +\n\t\t\t\t\t\tparams->port*4,\n\t\t\t\t\t\tNIG_MASK_MI_INT);\n\t\t\t\t}\n\t\t\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t\t\t MDIO_PMA_DEVAD,\n\t\t\t\t\t\t MDIO_PMA_REG_8481_SIGNAL_MASK,\n\t\t\t\t\t\t 0x0);\n\t\t\t}\n\t\t\tif (phy->type ==\n\t\t\t\tPORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84858) {\n\t\t\t\t \n\t\t\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t\t\t MDIO_PMA_DEVAD,\n\t\t\t\t\t\t MDIO_PMA_REG_8481_LED2_MASK,\n\t\t\t\t\t\t 0x0);\n\t\t\t\t \n\t\t\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t\t\t MDIO_PMA_DEVAD,\n\t\t\t\t\t\t MDIO_PMA_REG_8481_LED3_MASK,\n\t\t\t\t\t\t 0x0);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase LED_MODE_ON:\n\n\t\tDP(NETIF_MSG_LINK, \"Port 0x%x: LED MODE ON\\n\", port);\n\n\t\tif ((params->hw_led_mode << SHARED_HW_CFG_LED_MODE_SHIFT) ==\n\t\t    SHARED_HW_CFG_LED_EXTPHY1) {\n\t\t\t \n\t\t\tbnx2x_cl45_read(bp, phy,\n\t\t\t\t\tMDIO_PMA_DEVAD,\n\t\t\t\t\tMDIO_PMA_REG_8481_LINK_SIGNAL,\n\t\t\t\t\t&val);\n\t\t\tval &= 0x8000;\n\t\t\tval |= 0x2492;\n\n\t\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t\t MDIO_PMA_DEVAD,\n\t\t\t\t\t MDIO_PMA_REG_8481_LINK_SIGNAL,\n\t\t\t\t\t val);\n\n\t\t\t \n\t\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t\t MDIO_PMA_DEVAD,\n\t\t\t\t\t MDIO_PMA_REG_8481_LED1_MASK,\n\t\t\t\t\t 0x0);\n\n\t\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t\t MDIO_PMA_DEVAD,\n\t\t\t\t\t MDIO_PMA_REG_8481_LED2_MASK,\n\t\t\t\t\t 0x20);\n\n\t\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t\t MDIO_PMA_DEVAD,\n\t\t\t\t\t MDIO_PMA_REG_8481_LED3_MASK,\n\t\t\t\t\t 0x20);\n\n\t\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t\t MDIO_PMA_DEVAD,\n\t\t\t\t\t MDIO_PMA_REG_8481_LED5_MASK,\n\t\t\t\t\t 0x0);\n\t\t} else {\n\t\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t\t MDIO_PMA_DEVAD,\n\t\t\t\t\t MDIO_PMA_REG_8481_LED1_MASK,\n\t\t\t\t\t 0x20);\n\t\t\tif (phy->type ==\n\t\t\t    PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84834) {\n\t\t\t\t \n\t\t\t\tif (REG_RD(bp, NIG_REG_MASK_INTERRUPT_PORT0 +\n\t\t\t\t\t   params->port*4) &\n\t\t\t\t    NIG_MASK_MI_INT) {\n\t\t\t\t\tparams->link_flags |=\n\t\t\t\t\tLINK_FLAGS_INT_DISABLED;\n\n\t\t\t\t\tbnx2x_bits_dis(\n\t\t\t\t\t\tbp,\n\t\t\t\t\t\tNIG_REG_MASK_INTERRUPT_PORT0 +\n\t\t\t\t\t\tparams->port*4,\n\t\t\t\t\t\tNIG_MASK_MI_INT);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (phy->type ==\n\t\t\t    PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84858) {\n\t\t\t\t \n\t\t\t\tbnx2x_cl45_read(bp, phy,\n\t\t\t\t\t\tMDIO_PMA_DEVAD,\n\t\t\t\t\t\tMDIO_PMA_REG_8481_LINK_SIGNAL,\n\t\t\t\t\t\t&val);\n\t\t\t\tval &= ~(7<<6);\n\t\t\t\tval |= (2<<6);   \n\t\t\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t\t\t MDIO_PMA_DEVAD,\n\t\t\t\t\t\t MDIO_PMA_REG_8481_LINK_SIGNAL,\n\t\t\t\t\t\t val);\n\t\t\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t\t\t MDIO_PMA_DEVAD,\n\t\t\t\t\t\t MDIO_PMA_REG_8481_LED3_MASK,\n\t\t\t\t\t\t 0x20);\n\t\t\t} else {\n\t\t\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t\t\t MDIO_PMA_DEVAD,\n\t\t\t\t\t\t MDIO_PMA_REG_8481_SIGNAL_MASK,\n\t\t\t\t\t\t 0x20);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase LED_MODE_OPER:\n\n\t\tDP(NETIF_MSG_LINK, \"Port 0x%x: LED MODE OPER\\n\", port);\n\n\t\tif ((params->hw_led_mode << SHARED_HW_CFG_LED_MODE_SHIFT) ==\n\t\t    SHARED_HW_CFG_LED_EXTPHY1) {\n\n\t\t\t \n\t\t\tbnx2x_cl45_read(bp, phy,\n\t\t\t\t\tMDIO_PMA_DEVAD,\n\t\t\t\t\tMDIO_PMA_REG_8481_LINK_SIGNAL,\n\t\t\t\t\t&val);\n\n\t\t\tif (!((val &\n\t\t\t       MDIO_PMA_REG_8481_LINK_SIGNAL_LED4_ENABLE_MASK)\n\t\t\t  >> MDIO_PMA_REG_8481_LINK_SIGNAL_LED4_ENABLE_SHIFT)) {\n\t\t\t\tDP(NETIF_MSG_LINK, \"Setting LINK_SIGNAL\\n\");\n\t\t\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t\t\t MDIO_PMA_DEVAD,\n\t\t\t\t\t\t MDIO_PMA_REG_8481_LINK_SIGNAL,\n\t\t\t\t\t\t 0xa492);\n\t\t\t}\n\n\t\t\t \n\t\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t\t MDIO_PMA_DEVAD,\n\t\t\t\t\t MDIO_PMA_REG_8481_LED1_MASK,\n\t\t\t\t\t 0x10);\n\n\t\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t\t MDIO_PMA_DEVAD,\n\t\t\t\t\t MDIO_PMA_REG_8481_LED2_MASK,\n\t\t\t\t\t 0x80);\n\n\t\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t\t MDIO_PMA_DEVAD,\n\t\t\t\t\t MDIO_PMA_REG_8481_LED3_MASK,\n\t\t\t\t\t 0x98);\n\n\t\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t\t MDIO_PMA_DEVAD,\n\t\t\t\t\t MDIO_PMA_REG_8481_LED5_MASK,\n\t\t\t\t\t 0x40);\n\n\t\t} else {\n\t\t\t \n\t\t\tval = ((params->hw_led_mode <<\n\t\t\t\tSHARED_HW_CFG_LED_MODE_SHIFT) ==\n\t\t\t       SHARED_HW_CFG_LED_EXTPHY2) ? 0x98 : 0x80;\n\n\t\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t\t MDIO_PMA_DEVAD,\n\t\t\t\t\t MDIO_PMA_REG_8481_LED1_MASK,\n\t\t\t\t\t val);\n\n\t\t\t \n\t\t\tbnx2x_cl45_read(bp, phy,\n\t\t\t\t\tMDIO_PMA_DEVAD,\n\t\t\t\t\tMDIO_PMA_REG_8481_LINK_SIGNAL,\n\t\t\t\t\t&val);\n\t\t\tval &= ~(7<<6);\n\t\t\tval |= (1<<6);  \n\t\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t\t MDIO_PMA_DEVAD,\n\t\t\t\t\t MDIO_PMA_REG_8481_LINK_SIGNAL,\n\t\t\t\t\t val);\n\t\t\tif (phy->type ==\n\t\t\t    PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84858) {\n\t\t\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t\t\t MDIO_PMA_DEVAD,\n\t\t\t\t\t\t MDIO_PMA_REG_8481_LED2_MASK,\n\t\t\t\t\t\t 0x18);\n\t\t\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t\t\t MDIO_PMA_DEVAD,\n\t\t\t\t\t\t MDIO_PMA_REG_8481_LED3_MASK,\n\t\t\t\t\t\t 0x06);\n\t\t\t}\n\t\t\tif (phy->type ==\n\t\t\t    PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84834) {\n\t\t\t\t \n\t\t\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t\t\t MDIO_PMA_DEVAD,\n\t\t\t\t\t\t MDIO_PMA_REG_8481_SIGNAL_MASK,\n\t\t\t\t\t\t 0x40);\n\t\t\t\tif (params->link_flags &\n\t\t\t\t    LINK_FLAGS_INT_DISABLED) {\n\t\t\t\t\tbnx2x_link_int_enable(params);\n\t\t\t\t\tparams->link_flags &=\n\t\t\t\t\t\t~LINK_FLAGS_INT_DISABLED;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\n\t \n\tif (CHIP_IS_E3(bp)) {\n\t\tbnx2x_cl45_read(bp, phy, MDIO_WC_DEVAD,\n\t\t\t\tMDIO_WC_REG_GP2_STATUS_GP_2_1, &val);\n\t}\n}\n\n \n \n \nstatic void bnx2x_54618se_specific_func(struct bnx2x_phy *phy,\n\t\t\t\t\tstruct link_params *params,\n\t\t\t\t\tu32 action)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu16 temp;\n\tswitch (action) {\n\tcase PHY_INIT:\n\t\t \n\t\t \n\t\tbnx2x_cl22_write(bp, phy,\n\t\t\t\t MDIO_REG_GPHY_SHADOW,\n\t\t\t\t MDIO_REG_GPHY_SHADOW_LED_SEL2);\n\t\tbnx2x_cl22_read(bp, phy,\n\t\t\t\tMDIO_REG_GPHY_SHADOW,\n\t\t\t\t&temp);\n\t\ttemp &= ~(0xf << 4);\n\t\ttemp |= (0x6 << 4);\n\t\tbnx2x_cl22_write(bp, phy,\n\t\t\t\t MDIO_REG_GPHY_SHADOW,\n\t\t\t\t MDIO_REG_GPHY_SHADOW_WR_ENA | temp);\n\t\t \n\t\tbnx2x_cl22_write(bp, phy,\n\t\t\t\t MDIO_REG_INTR_MASK,\n\t\t\t\t ~MDIO_REG_INTR_MASK_LINK_STATUS);\n\t\tbreak;\n\t}\n}\n\nstatic void bnx2x_54618se_config_init(struct bnx2x_phy *phy,\n\t\t\t\t      struct link_params *params,\n\t\t\t\t      struct link_vars *vars)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu8 port;\n\tu16 autoneg_val, an_1000_val, an_10_100_val, fc_val, temp;\n\tu32 cfg_pin;\n\n\tDP(NETIF_MSG_LINK, \"54618SE cfg init\\n\");\n\tusleep_range(1000, 2000);\n\n\t \n\tport = params->port;\n\n\tcfg_pin = (REG_RD(bp, params->shmem_base +\n\t\t\toffsetof(struct shmem_region,\n\t\t\tdev_info.port_hw_config[port].e3_cmn_pin_cfg)) &\n\t\t\tPORT_HW_CFG_E3_PHY_RESET_MASK) >>\n\t\t\tPORT_HW_CFG_E3_PHY_RESET_SHIFT;\n\n\t \n\tbnx2x_set_cfg_pin(bp, cfg_pin, 1);\n\n\t \n\tmsleep(50);\n\n\t \n\tbnx2x_cl22_write(bp, phy,\n\t\t\t MDIO_PMA_REG_CTRL, 0x8000);\n\tbnx2x_wait_reset_complete(bp, phy, params);\n\n\t \n\tmsleep(50);\n\n\n\tbnx2x_54618se_specific_func(phy, params, PHY_INIT);\n\t \n\tbnx2x_cl22_write(bp, phy,\n\t\t\tMDIO_REG_GPHY_SHADOW,\n\t\t\tMDIO_REG_GPHY_SHADOW_AUTO_DET_MED);\n\tbnx2x_cl22_read(bp, phy,\n\t\t\tMDIO_REG_GPHY_SHADOW,\n\t\t\t&temp);\n\ttemp |= MDIO_REG_GPHY_SHADOW_INVERT_FIB_SD;\n\tbnx2x_cl22_write(bp, phy,\n\t\t\tMDIO_REG_GPHY_SHADOW,\n\t\t\tMDIO_REG_GPHY_SHADOW_WR_ENA | temp);\n\n\t \n\t \n\tbnx2x_calc_ieee_aneg_adv(phy, params, &vars->ieee_fc);\n\tfc_val = 0;\n\tif ((vars->ieee_fc & MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_ASYMMETRIC) ==\n\t\t\tMDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_ASYMMETRIC)\n\t\tfc_val |= MDIO_AN_REG_ADV_PAUSE_ASYMMETRIC;\n\n\tif ((vars->ieee_fc & MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_BOTH) ==\n\t\t\tMDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_BOTH)\n\t\tfc_val |= MDIO_AN_REG_ADV_PAUSE_PAUSE;\n\n\t \n\tbnx2x_cl22_read(bp, phy,\n\t\t\t0x09,\n\t\t\t&an_1000_val);\n\n\tbnx2x_cl22_read(bp, phy,\n\t\t\t0x04,\n\t\t\t&an_10_100_val);\n\n\tbnx2x_cl22_read(bp, phy,\n\t\t\tMDIO_PMA_REG_CTRL,\n\t\t\t&autoneg_val);\n\n\t \n\tautoneg_val &= ~((1<<6) | (1<<8) | (1<<9) | (1<<12) | (1<<13));\n\tan_10_100_val &= ~((1<<5) | (1<<6) | (1<<7) | (1<<8) | (1<<10) |\n\t\t\t   (1<<11));\n\n\tif (((phy->req_line_speed == SPEED_AUTO_NEG) &&\n\t     (phy->speed_cap_mask &\n\t      PORT_HW_CFG_SPEED_CAPABILITY_D0_1G)) ||\n\t    (phy->req_line_speed == SPEED_1000)) {\n\t\tan_1000_val |= (1<<8);\n\t\tautoneg_val |= (1<<9 | 1<<12);\n\t\tif (phy->req_duplex == DUPLEX_FULL)\n\t\t\tan_1000_val |= (1<<9);\n\t\tDP(NETIF_MSG_LINK, \"Advertising 1G\\n\");\n\t} else\n\t\tan_1000_val &= ~((1<<8) | (1<<9));\n\n\tbnx2x_cl22_write(bp, phy,\n\t\t\t0x09,\n\t\t\tan_1000_val);\n\tbnx2x_cl22_read(bp, phy,\n\t\t\t0x09,\n\t\t\t&an_1000_val);\n\n\t \n\tif (phy->req_line_speed == SPEED_AUTO_NEG) {\n\t\tif (phy->speed_cap_mask &\n\t\t    PORT_HW_CFG_SPEED_CAPABILITY_D0_10M_HALF) {\n\t\t\tan_10_100_val |= (1<<5);\n\t\t\tautoneg_val |= (1<<9 | 1<<12);\n\t\t\tDP(NETIF_MSG_LINK, \"Advertising 10M-HD\\n\");\n\t\t}\n\t\tif (phy->speed_cap_mask &\n\t\t    PORT_HW_CFG_SPEED_CAPABILITY_D0_10M_FULL) {\n\t\t\tan_10_100_val |= (1<<6);\n\t\t\tautoneg_val |= (1<<9 | 1<<12);\n\t\t\tDP(NETIF_MSG_LINK, \"Advertising 10M-FD\\n\");\n\t\t}\n\t\tif (phy->speed_cap_mask &\n\t\t    PORT_HW_CFG_SPEED_CAPABILITY_D0_100M_HALF) {\n\t\t\tan_10_100_val |= (1<<7);\n\t\t\tautoneg_val |= (1<<9 | 1<<12);\n\t\t\tDP(NETIF_MSG_LINK, \"Advertising 100M-HD\\n\");\n\t\t}\n\t\tif (phy->speed_cap_mask &\n\t\t    PORT_HW_CFG_SPEED_CAPABILITY_D0_100M_FULL) {\n\t\t\tan_10_100_val |= (1<<8);\n\t\t\tautoneg_val |= (1<<9 | 1<<12);\n\t\t\tDP(NETIF_MSG_LINK, \"Advertising 100M-FD\\n\");\n\t\t}\n\t}\n\n\t \n\tif (phy->req_line_speed == SPEED_100) {\n\t\tautoneg_val |= (1<<13);\n\t\t \n\t\tbnx2x_cl22_write(bp, phy,\n\t\t\t\t0x18,\n\t\t\t\t(1<<15 | 1<<9 | 7<<0));\n\t\tDP(NETIF_MSG_LINK, \"Setting 100M force\\n\");\n\t}\n\tif (phy->req_line_speed == SPEED_10) {\n\t\t \n\t\tbnx2x_cl22_write(bp, phy,\n\t\t\t\t0x18,\n\t\t\t\t(1<<15 | 1<<9 | 7<<0));\n\t\tDP(NETIF_MSG_LINK, \"Setting 10M force\\n\");\n\t}\n\n\tif ((phy->flags & FLAGS_EEE) && bnx2x_eee_has_cap(params)) {\n\t\tint rc;\n\n\t\tbnx2x_cl22_write(bp, phy, MDIO_REG_GPHY_EXP_ACCESS,\n\t\t\t\t MDIO_REG_GPHY_EXP_ACCESS_TOP |\n\t\t\t\t MDIO_REG_GPHY_EXP_TOP_2K_BUF);\n\t\tbnx2x_cl22_read(bp, phy, MDIO_REG_GPHY_EXP_ACCESS_GATE, &temp);\n\t\ttemp &= 0xfffe;\n\t\tbnx2x_cl22_write(bp, phy, MDIO_REG_GPHY_EXP_ACCESS_GATE, temp);\n\n\t\trc = bnx2x_eee_initial_config(params, vars, SHMEM_EEE_1G_ADV);\n\t\tif (rc) {\n\t\t\tDP(NETIF_MSG_LINK, \"Failed to configure EEE timers\\n\");\n\t\t\tbnx2x_eee_disable(phy, params, vars);\n\t\t} else if ((params->eee_mode & EEE_MODE_ADV_LPI) &&\n\t\t\t   (phy->req_duplex == DUPLEX_FULL) &&\n\t\t\t   (bnx2x_eee_calc_timer(params) ||\n\t\t\t    !(params->eee_mode & EEE_MODE_ENABLE_LPI))) {\n\t\t\t \n\t\t\tbnx2x_eee_advertise(phy, params, vars,\n\t\t\t\t\t    SHMEM_EEE_1G_ADV);\n\t\t} else {\n\t\t\tDP(NETIF_MSG_LINK, \"Don't Advertise 1GBase-T EEE\\n\");\n\t\t\tbnx2x_eee_disable(phy, params, vars);\n\t\t}\n\t} else {\n\t\tvars->eee_status &= ~SHMEM_EEE_1G_ADV <<\n\t\t\t\t    SHMEM_EEE_SUPPORTED_SHIFT;\n\n\t\tif (phy->flags & FLAGS_EEE) {\n\t\t\t \n\t\t\tif (params->feature_config_flags &\n\t\t\t    FEATURE_CONFIG_AUTOGREEEN_ENABLED) {\n\t\t\t\ttemp = 6;\n\t\t\t\tDP(NETIF_MSG_LINK, \"Enabling Auto-GrEEEn\\n\");\n\t\t\t} else {\n\t\t\t\ttemp = 0;\n\t\t\t\tDP(NETIF_MSG_LINK, \"Don't Adv. EEE\\n\");\n\t\t\t}\n\t\t\tbnx2x_cl45_write(bp, phy, MDIO_AN_DEVAD,\n\t\t\t\t\t MDIO_AN_REG_EEE_ADV, temp);\n\t\t}\n\t}\n\n\tbnx2x_cl22_write(bp, phy,\n\t\t\t0x04,\n\t\t\tan_10_100_val | fc_val);\n\n\tif (phy->req_duplex == DUPLEX_FULL)\n\t\tautoneg_val |= (1<<8);\n\n\tbnx2x_cl22_write(bp, phy,\n\t\t\tMDIO_PMA_REG_CTRL, autoneg_val);\n}\n\n\nstatic void bnx2x_5461x_set_link_led(struct bnx2x_phy *phy,\n\t\t\t\t       struct link_params *params, u8 mode)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu16 temp;\n\n\tbnx2x_cl22_write(bp, phy,\n\t\tMDIO_REG_GPHY_SHADOW,\n\t\tMDIO_REG_GPHY_SHADOW_LED_SEL1);\n\tbnx2x_cl22_read(bp, phy,\n\t\tMDIO_REG_GPHY_SHADOW,\n\t\t&temp);\n\ttemp &= 0xff00;\n\n\tDP(NETIF_MSG_LINK, \"54618x set link led (mode=%x)\\n\", mode);\n\tswitch (mode) {\n\tcase LED_MODE_FRONT_PANEL_OFF:\n\tcase LED_MODE_OFF:\n\t\ttemp |= 0x00ee;\n\t\tbreak;\n\tcase LED_MODE_OPER:\n\t\ttemp |= 0x0001;\n\t\tbreak;\n\tcase LED_MODE_ON:\n\t\ttemp |= 0x00ff;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tbnx2x_cl22_write(bp, phy,\n\t\tMDIO_REG_GPHY_SHADOW,\n\t\tMDIO_REG_GPHY_SHADOW_WR_ENA | temp);\n\treturn;\n}\n\n\nstatic void bnx2x_54618se_link_reset(struct bnx2x_phy *phy,\n\t\t\t\t     struct link_params *params)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu32 cfg_pin;\n\tu8 port;\n\n\t \n\tbnx2x_cl22_write(bp, phy, MDIO_PMA_REG_CTRL, 0x800);\n\t \n\tport = params->port;\n\tcfg_pin = (REG_RD(bp, params->shmem_base +\n\t\t\toffsetof(struct shmem_region,\n\t\t\tdev_info.port_hw_config[port].e3_cmn_pin_cfg)) &\n\t\t\tPORT_HW_CFG_E3_PHY_RESET_MASK) >>\n\t\t\tPORT_HW_CFG_E3_PHY_RESET_SHIFT;\n\n\t \n\tbnx2x_set_cfg_pin(bp, cfg_pin, 0);\n}\n\nstatic u8 bnx2x_54618se_read_status(struct bnx2x_phy *phy,\n\t\t\t\t    struct link_params *params,\n\t\t\t\t    struct link_vars *vars)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu16 val;\n\tu8 link_up = 0;\n\tu16 legacy_status, legacy_speed;\n\n\t \n\tbnx2x_cl22_read(bp, phy,\n\t\t\tMDIO_REG_GPHY_AUX_STATUS,\n\t\t\t&legacy_status);\n\tDP(NETIF_MSG_LINK, \"54618SE read_status: 0x%x\\n\", legacy_status);\n\n\t \n\tbnx2x_cl22_read(bp, phy,\n\t\t\tMDIO_REG_INTR_STATUS,\n\t\t\t&val);\n\n\tlink_up = ((legacy_status & (1<<2)) == (1<<2));\n\n\tif (link_up) {\n\t\tlegacy_speed = (legacy_status & (7<<8));\n\t\tif (legacy_speed == (7<<8)) {\n\t\t\tvars->line_speed = SPEED_1000;\n\t\t\tvars->duplex = DUPLEX_FULL;\n\t\t} else if (legacy_speed == (6<<8)) {\n\t\t\tvars->line_speed = SPEED_1000;\n\t\t\tvars->duplex = DUPLEX_HALF;\n\t\t} else if (legacy_speed == (5<<8)) {\n\t\t\tvars->line_speed = SPEED_100;\n\t\t\tvars->duplex = DUPLEX_FULL;\n\t\t}\n\t\t \n\t\telse if (legacy_speed == (3<<8)) {\n\t\t\tvars->line_speed = SPEED_100;\n\t\t\tvars->duplex = DUPLEX_HALF;\n\t\t} else if (legacy_speed == (2<<8)) {\n\t\t\tvars->line_speed = SPEED_10;\n\t\t\tvars->duplex = DUPLEX_FULL;\n\t\t} else if (legacy_speed == (1<<8)) {\n\t\t\tvars->line_speed = SPEED_10;\n\t\t\tvars->duplex = DUPLEX_HALF;\n\t\t} else  \n\t\t\tvars->line_speed = 0;\n\n\t\tDP(NETIF_MSG_LINK,\n\t\t   \"Link is up in %dMbps, is_duplex_full= %d\\n\",\n\t\t   vars->line_speed,\n\t\t   (vars->duplex == DUPLEX_FULL));\n\n\t\t \n\t\tbnx2x_cl22_read(bp, phy,\n\t\t\t\t0x01,\n\t\t\t\t&val);\n\t\tif (val & (1<<5))\n\t\t\tvars->link_status |=\n\t\t\t\tLINK_STATUS_AUTO_NEGOTIATE_COMPLETE;\n\t\tbnx2x_cl22_read(bp, phy,\n\t\t\t\t0x06,\n\t\t\t\t&val);\n\t\tif ((val & (1<<0)) == 0)\n\t\t\tvars->link_status |=\n\t\t\t\tLINK_STATUS_PARALLEL_DETECTION_USED;\n\n\t\tDP(NETIF_MSG_LINK, \"BCM54618SE: link speed is %d\\n\",\n\t\t\t   vars->line_speed);\n\n\t\tbnx2x_ext_phy_resolve_fc(phy, params, vars);\n\n\t\tif (vars->link_status & LINK_STATUS_AUTO_NEGOTIATE_COMPLETE) {\n\t\t\t \n\t\t\tbnx2x_cl22_read(bp, phy, 0x5, &val);\n\n\t\t\tif (val & (1<<5))\n\t\t\t\tvars->link_status |=\n\t\t\t\t  LINK_STATUS_LINK_PARTNER_10THD_CAPABLE;\n\t\t\tif (val & (1<<6))\n\t\t\t\tvars->link_status |=\n\t\t\t\t  LINK_STATUS_LINK_PARTNER_10TFD_CAPABLE;\n\t\t\tif (val & (1<<7))\n\t\t\t\tvars->link_status |=\n\t\t\t\t  LINK_STATUS_LINK_PARTNER_100TXHD_CAPABLE;\n\t\t\tif (val & (1<<8))\n\t\t\t\tvars->link_status |=\n\t\t\t\t  LINK_STATUS_LINK_PARTNER_100TXFD_CAPABLE;\n\t\t\tif (val & (1<<9))\n\t\t\t\tvars->link_status |=\n\t\t\t\t  LINK_STATUS_LINK_PARTNER_100T4_CAPABLE;\n\n\t\t\tbnx2x_cl22_read(bp, phy, 0xa, &val);\n\t\t\tif (val & (1<<10))\n\t\t\t\tvars->link_status |=\n\t\t\t\t  LINK_STATUS_LINK_PARTNER_1000THD_CAPABLE;\n\t\t\tif (val & (1<<11))\n\t\t\t\tvars->link_status |=\n\t\t\t\t  LINK_STATUS_LINK_PARTNER_1000TFD_CAPABLE;\n\n\t\t\tif ((phy->flags & FLAGS_EEE) &&\n\t\t\t    bnx2x_eee_has_cap(params))\n\t\t\t\tbnx2x_eee_an_resolve(phy, params, vars);\n\t\t}\n\t}\n\treturn link_up;\n}\n\nstatic void bnx2x_54618se_config_loopback(struct bnx2x_phy *phy,\n\t\t\t\t\t  struct link_params *params)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu16 val;\n\tu32 umac_base = params->port ? GRCBASE_UMAC1 : GRCBASE_UMAC0;\n\n\tDP(NETIF_MSG_LINK, \"2PMA/PMD ext_phy_loopback: 54618se\\n\");\n\n\t \n\t \n\tbnx2x_cl22_write(bp, phy, 0x09, 3<<11);\n\n\t \n\t \n\t \n\t \n\t \n\tbnx2x_cl22_read(bp, phy, 0x00, &val);\n\tval &= ~((1<<6) | (1<<12) | (1<<13));\n\tval |= (1<<6) | (1<<8);\n\tbnx2x_cl22_write(bp, phy, 0x00, val);\n\n\t \n\t \n\t \n\t \n\tbnx2x_cl22_write(bp, phy, 0x18, 7);\n\tbnx2x_cl22_read(bp, phy, 0x18, &val);\n\tbnx2x_cl22_write(bp, phy, 0x18, val | (1<<10) | (1<<15));\n\n\t \n\tREG_WR(bp, NIG_REG_EGRESS_EMAC0_PORT + params->port*4, 1);\n\n\t \n\tREG_WR(bp, umac_base + UMAC_REG_MAXFR, 0x2710);\n}\n\n \n \n \nstatic void bnx2x_7101_config_loopback(struct bnx2x_phy *phy,\n\t\t\t\t       struct link_params *params)\n{\n\tstruct bnx2x *bp = params->bp;\n\t \n\tbnx2x_cl45_write(bp, phy,\n\t\t\t MDIO_XS_DEVAD, MDIO_XS_SFX7101_XGXS_TEST1, 0x100);\n}\n\nstatic void bnx2x_7101_config_init(struct bnx2x_phy *phy,\n\t\t\t\t   struct link_params *params,\n\t\t\t\t   struct link_vars *vars)\n{\n\tu16 fw_ver1, fw_ver2, val;\n\tstruct bnx2x *bp = params->bp;\n\tDP(NETIF_MSG_LINK, \"Setting the SFX7101 LASI indication\\n\");\n\n\t \n\tbnx2x_set_gpio(bp, MISC_REGISTERS_GPIO_2,\n\t\t       MISC_REGISTERS_GPIO_OUTPUT_HIGH, params->port);\n\t \n\tbnx2x_ext_phy_hw_reset(bp, params->port);\n\tbnx2x_wait_reset_complete(bp, phy, params);\n\n\tbnx2x_cl45_write(bp, phy,\n\t\t\t MDIO_PMA_DEVAD, MDIO_PMA_LASI_CTRL, 0x1);\n\tDP(NETIF_MSG_LINK, \"Setting the SFX7101 LED to blink on traffic\\n\");\n\tbnx2x_cl45_write(bp, phy,\n\t\t\t MDIO_PMA_DEVAD, MDIO_PMA_REG_7107_LED_CNTL, (1<<3));\n\n\tbnx2x_ext_phy_set_pause(params, phy, vars);\n\t \n\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_AN_DEVAD, MDIO_AN_REG_CTRL, &val);\n\tval |= 0x200;\n\tbnx2x_cl45_write(bp, phy,\n\t\t\t MDIO_AN_DEVAD, MDIO_AN_REG_CTRL, val);\n\n\t \n\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_PMA_DEVAD, MDIO_PMA_REG_7101_VER1, &fw_ver1);\n\n\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_PMA_DEVAD, MDIO_PMA_REG_7101_VER2, &fw_ver2);\n\tbnx2x_save_spirom_version(bp, params->port,\n\t\t\t\t  (u32)(fw_ver1<<16 | fw_ver2), phy->ver_addr);\n}\n\nstatic u8 bnx2x_7101_read_status(struct bnx2x_phy *phy,\n\t\t\t\t struct link_params *params,\n\t\t\t\t struct link_vars *vars)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu8 link_up;\n\tu16 val1, val2;\n\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_PMA_DEVAD, MDIO_PMA_LASI_STAT, &val2);\n\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_PMA_DEVAD, MDIO_PMA_LASI_STAT, &val1);\n\tDP(NETIF_MSG_LINK, \"10G-base-T LASI status 0x%x->0x%x\\n\",\n\t\t   val2, val1);\n\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_PMA_DEVAD, MDIO_PMA_REG_STATUS, &val2);\n\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_PMA_DEVAD, MDIO_PMA_REG_STATUS, &val1);\n\tDP(NETIF_MSG_LINK, \"10G-base-T PMA status 0x%x->0x%x\\n\",\n\t\t   val2, val1);\n\tlink_up = ((val1 & 4) == 4);\n\t \n\tif (link_up) {\n\t\tbnx2x_cl45_read(bp, phy,\n\t\t\t\tMDIO_AN_DEVAD, MDIO_AN_REG_MASTER_STATUS,\n\t\t\t\t&val2);\n\t\tvars->line_speed = SPEED_10000;\n\t\tvars->duplex = DUPLEX_FULL;\n\t\tDP(NETIF_MSG_LINK, \"SFX7101 AN status 0x%x->Master=%x\\n\",\n\t\t\t   val2, (val2 & (1<<14)));\n\t\tbnx2x_ext_phy_10G_an_resolve(bp, phy, vars);\n\t\tbnx2x_ext_phy_resolve_fc(phy, params, vars);\n\n\t\t \n\t\tif (val2 & (1<<11))\n\t\t\tvars->link_status |=\n\t\t\t\tLINK_STATUS_LINK_PARTNER_10GXFD_CAPABLE;\n\t}\n\treturn link_up;\n}\n\nstatic int bnx2x_7101_format_ver(u32 spirom_ver, u8 *str, u16 *len)\n{\n\tif (*len < 5)\n\t\treturn -EINVAL;\n\tstr[0] = (spirom_ver & 0xFF);\n\tstr[1] = (spirom_ver & 0xFF00) >> 8;\n\tstr[2] = (spirom_ver & 0xFF0000) >> 16;\n\tstr[3] = (spirom_ver & 0xFF000000) >> 24;\n\tstr[4] = '\\0';\n\t*len -= 5;\n\treturn 0;\n}\n\nvoid bnx2x_sfx7101_sp_sw_reset(struct bnx2x *bp, struct bnx2x_phy *phy)\n{\n\tu16 val, cnt;\n\n\tbnx2x_cl45_read(bp, phy,\n\t\t\tMDIO_PMA_DEVAD,\n\t\t\tMDIO_PMA_REG_7101_RESET, &val);\n\n\tfor (cnt = 0; cnt < 10; cnt++) {\n\t\tmsleep(50);\n\t\t \n\t\tbnx2x_cl45_write(bp, phy,\n\t\t\t\t MDIO_PMA_DEVAD,\n\t\t\t\t MDIO_PMA_REG_7101_RESET,\n\t\t\t\t (val | (1<<15)));\n\t\t \n\t\tbnx2x_cl45_read(bp, phy,\n\t\t\t\tMDIO_PMA_DEVAD,\n\t\t\t\tMDIO_PMA_REG_7101_RESET, &val);\n\n\t\tif ((val & (1<<15)) == 0)\n\t\t\tbreak;\n\t}\n}\n\nstatic void bnx2x_7101_hw_reset(struct bnx2x_phy *phy,\n\t\t\t\tstruct link_params *params) {\n\t \n\tbnx2x_set_gpio(params->bp, MISC_REGISTERS_GPIO_2,\n\t\t       MISC_REGISTERS_GPIO_OUTPUT_LOW, params->port);\n\t \n\tbnx2x_set_gpio(params->bp, MISC_REGISTERS_GPIO_1,\n\t\t       MISC_REGISTERS_GPIO_OUTPUT_LOW, params->port);\n}\n\nstatic void bnx2x_7101_set_link_led(struct bnx2x_phy *phy,\n\t\t\t\t    struct link_params *params, u8 mode)\n{\n\tu16 val = 0;\n\tstruct bnx2x *bp = params->bp;\n\tswitch (mode) {\n\tcase LED_MODE_FRONT_PANEL_OFF:\n\tcase LED_MODE_OFF:\n\t\tval = 2;\n\t\tbreak;\n\tcase LED_MODE_ON:\n\t\tval = 1;\n\t\tbreak;\n\tcase LED_MODE_OPER:\n\t\tval = 0;\n\t\tbreak;\n\t}\n\tbnx2x_cl45_write(bp, phy,\n\t\t\t MDIO_PMA_DEVAD,\n\t\t\t MDIO_PMA_REG_7107_LINK_LED_CNTL,\n\t\t\t val);\n}\n\n \n \n \n\nstatic const struct bnx2x_phy phy_null = {\n\t.type\t\t= PORT_HW_CFG_XGXS_EXT_PHY_TYPE_NOT_CONN,\n\t.addr\t\t= 0,\n\t.def_md_devad\t= 0,\n\t.flags\t\t= FLAGS_INIT_XGXS_FIRST,\n\t.rx_preemphasis\t= {0xffff, 0xffff, 0xffff, 0xffff},\n\t.tx_preemphasis\t= {0xffff, 0xffff, 0xffff, 0xffff},\n\t.mdio_ctrl\t= 0,\n\t.supported\t= 0,\n\t.media_type\t= ETH_PHY_NOT_PRESENT,\n\t.ver_addr\t= 0,\n\t.req_flow_ctrl\t= 0,\n\t.req_line_speed\t= 0,\n\t.speed_cap_mask\t= 0,\n\t.req_duplex\t= 0,\n\t.rsrv\t\t= 0,\n\t.config_init\t= NULL,\n\t.read_status\t= NULL,\n\t.link_reset\t= NULL,\n\t.config_loopback = NULL,\n\t.format_fw_ver\t= NULL,\n\t.hw_reset\t= NULL,\n\t.set_link_led\t= NULL,\n\t.phy_specific_func = NULL\n};\n\nstatic const struct bnx2x_phy phy_serdes = {\n\t.type\t\t= PORT_HW_CFG_SERDES_EXT_PHY_TYPE_DIRECT,\n\t.addr\t\t= 0xff,\n\t.def_md_devad\t= 0,\n\t.flags\t\t= 0,\n\t.rx_preemphasis\t= {0xffff, 0xffff, 0xffff, 0xffff},\n\t.tx_preemphasis\t= {0xffff, 0xffff, 0xffff, 0xffff},\n\t.mdio_ctrl\t= 0,\n\t.supported\t= (SUPPORTED_10baseT_Half |\n\t\t\t   SUPPORTED_10baseT_Full |\n\t\t\t   SUPPORTED_100baseT_Half |\n\t\t\t   SUPPORTED_100baseT_Full |\n\t\t\t   SUPPORTED_1000baseT_Full |\n\t\t\t   SUPPORTED_2500baseX_Full |\n\t\t\t   SUPPORTED_TP |\n\t\t\t   SUPPORTED_Autoneg |\n\t\t\t   SUPPORTED_Pause |\n\t\t\t   SUPPORTED_Asym_Pause),\n\t.media_type\t= ETH_PHY_BASE_T,\n\t.ver_addr\t= 0,\n\t.req_flow_ctrl\t= 0,\n\t.req_line_speed\t= 0,\n\t.speed_cap_mask\t= 0,\n\t.req_duplex\t= 0,\n\t.rsrv\t\t= 0,\n\t.config_init\t= bnx2x_xgxs_config_init,\n\t.read_status\t= bnx2x_link_settings_status,\n\t.link_reset\t= bnx2x_int_link_reset,\n\t.config_loopback = NULL,\n\t.format_fw_ver\t= NULL,\n\t.hw_reset\t= NULL,\n\t.set_link_led\t= NULL,\n\t.phy_specific_func = NULL\n};\n\nstatic const struct bnx2x_phy phy_xgxs = {\n\t.type\t\t= PORT_HW_CFG_XGXS_EXT_PHY_TYPE_DIRECT,\n\t.addr\t\t= 0xff,\n\t.def_md_devad\t= 0,\n\t.flags\t\t= 0,\n\t.rx_preemphasis\t= {0xffff, 0xffff, 0xffff, 0xffff},\n\t.tx_preemphasis\t= {0xffff, 0xffff, 0xffff, 0xffff},\n\t.mdio_ctrl\t= 0,\n\t.supported\t= (SUPPORTED_10baseT_Half |\n\t\t\t   SUPPORTED_10baseT_Full |\n\t\t\t   SUPPORTED_100baseT_Half |\n\t\t\t   SUPPORTED_100baseT_Full |\n\t\t\t   SUPPORTED_1000baseT_Full |\n\t\t\t   SUPPORTED_2500baseX_Full |\n\t\t\t   SUPPORTED_10000baseT_Full |\n\t\t\t   SUPPORTED_FIBRE |\n\t\t\t   SUPPORTED_Autoneg |\n\t\t\t   SUPPORTED_Pause |\n\t\t\t   SUPPORTED_Asym_Pause),\n\t.media_type\t= ETH_PHY_CX4,\n\t.ver_addr\t= 0,\n\t.req_flow_ctrl\t= 0,\n\t.req_line_speed\t= 0,\n\t.speed_cap_mask\t= 0,\n\t.req_duplex\t= 0,\n\t.rsrv\t\t= 0,\n\t.config_init\t= bnx2x_xgxs_config_init,\n\t.read_status\t= bnx2x_link_settings_status,\n\t.link_reset\t= bnx2x_int_link_reset,\n\t.config_loopback = bnx2x_set_xgxs_loopback,\n\t.format_fw_ver\t= NULL,\n\t.hw_reset\t= NULL,\n\t.set_link_led\t= NULL,\n\t.phy_specific_func = bnx2x_xgxs_specific_func\n};\nstatic const struct bnx2x_phy phy_warpcore = {\n\t.type\t\t= PORT_HW_CFG_XGXS_EXT_PHY_TYPE_DIRECT,\n\t.addr\t\t= 0xff,\n\t.def_md_devad\t= 0,\n\t.flags\t\t= FLAGS_TX_ERROR_CHECK,\n\t.rx_preemphasis\t= {0xffff, 0xffff, 0xffff, 0xffff},\n\t.tx_preemphasis\t= {0xffff, 0xffff, 0xffff, 0xffff},\n\t.mdio_ctrl\t= 0,\n\t.supported\t= (SUPPORTED_10baseT_Half |\n\t\t\t   SUPPORTED_10baseT_Full |\n\t\t\t   SUPPORTED_100baseT_Half |\n\t\t\t   SUPPORTED_100baseT_Full |\n\t\t\t   SUPPORTED_1000baseT_Full |\n\t\t\t   SUPPORTED_1000baseKX_Full |\n\t\t\t   SUPPORTED_10000baseT_Full |\n\t\t\t   SUPPORTED_10000baseKR_Full |\n\t\t\t   SUPPORTED_20000baseKR2_Full |\n\t\t\t   SUPPORTED_20000baseMLD2_Full |\n\t\t\t   SUPPORTED_FIBRE |\n\t\t\t   SUPPORTED_Autoneg |\n\t\t\t   SUPPORTED_Pause |\n\t\t\t   SUPPORTED_Asym_Pause),\n\t.media_type\t= ETH_PHY_UNSPECIFIED,\n\t.ver_addr\t= 0,\n\t.req_flow_ctrl\t= 0,\n\t.req_line_speed\t= 0,\n\t.speed_cap_mask\t= 0,\n\t 0,\n\t 0,\n\t.config_init\t= bnx2x_warpcore_config_init,\n\t.read_status\t= bnx2x_warpcore_read_status,\n\t.link_reset\t= bnx2x_warpcore_link_reset,\n\t.config_loopback = bnx2x_set_warpcore_loopback,\n\t.format_fw_ver\t= NULL,\n\t.hw_reset\t= bnx2x_warpcore_hw_reset,\n\t.set_link_led\t= NULL,\n\t.phy_specific_func = NULL\n};\n\n\nstatic const struct bnx2x_phy phy_7101 = {\n\t.type\t\t= PORT_HW_CFG_XGXS_EXT_PHY_TYPE_SFX7101,\n\t.addr\t\t= 0xff,\n\t.def_md_devad\t= 0,\n\t.flags\t\t= FLAGS_FAN_FAILURE_DET_REQ,\n\t.rx_preemphasis\t= {0xffff, 0xffff, 0xffff, 0xffff},\n\t.tx_preemphasis\t= {0xffff, 0xffff, 0xffff, 0xffff},\n\t.mdio_ctrl\t= 0,\n\t.supported\t= (SUPPORTED_10000baseT_Full |\n\t\t\t   SUPPORTED_TP |\n\t\t\t   SUPPORTED_Autoneg |\n\t\t\t   SUPPORTED_Pause |\n\t\t\t   SUPPORTED_Asym_Pause),\n\t.media_type\t= ETH_PHY_BASE_T,\n\t.ver_addr\t= 0,\n\t.req_flow_ctrl\t= 0,\n\t.req_line_speed\t= 0,\n\t.speed_cap_mask\t= 0,\n\t.req_duplex\t= 0,\n\t.rsrv\t\t= 0,\n\t.config_init\t= bnx2x_7101_config_init,\n\t.read_status\t= bnx2x_7101_read_status,\n\t.link_reset\t= bnx2x_common_ext_link_reset,\n\t.config_loopback = bnx2x_7101_config_loopback,\n\t.format_fw_ver\t= bnx2x_7101_format_ver,\n\t.hw_reset\t= bnx2x_7101_hw_reset,\n\t.set_link_led\t= bnx2x_7101_set_link_led,\n\t.phy_specific_func = NULL\n};\nstatic const struct bnx2x_phy phy_8073 = {\n\t.type\t\t= PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8073,\n\t.addr\t\t= 0xff,\n\t.def_md_devad\t= 0,\n\t.flags\t\t= 0,\n\t.rx_preemphasis\t= {0xffff, 0xffff, 0xffff, 0xffff},\n\t.tx_preemphasis\t= {0xffff, 0xffff, 0xffff, 0xffff},\n\t.mdio_ctrl\t= 0,\n\t.supported\t= (SUPPORTED_10000baseT_Full |\n\t\t\t   SUPPORTED_2500baseX_Full |\n\t\t\t   SUPPORTED_1000baseT_Full |\n\t\t\t   SUPPORTED_FIBRE |\n\t\t\t   SUPPORTED_Autoneg |\n\t\t\t   SUPPORTED_Pause |\n\t\t\t   SUPPORTED_Asym_Pause),\n\t.media_type\t= ETH_PHY_KR,\n\t.ver_addr\t= 0,\n\t.req_flow_ctrl\t= 0,\n\t.req_line_speed\t= 0,\n\t.speed_cap_mask\t= 0,\n\t.req_duplex\t= 0,\n\t.rsrv\t\t= 0,\n\t.config_init\t= bnx2x_8073_config_init,\n\t.read_status\t= bnx2x_8073_read_status,\n\t.link_reset\t= bnx2x_8073_link_reset,\n\t.config_loopback = NULL,\n\t.format_fw_ver\t= bnx2x_format_ver,\n\t.hw_reset\t= NULL,\n\t.set_link_led\t= NULL,\n\t.phy_specific_func = bnx2x_8073_specific_func\n};\nstatic const struct bnx2x_phy phy_8705 = {\n\t.type\t\t= PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8705,\n\t.addr\t\t= 0xff,\n\t.def_md_devad\t= 0,\n\t.flags\t\t= FLAGS_INIT_XGXS_FIRST,\n\t.rx_preemphasis\t= {0xffff, 0xffff, 0xffff, 0xffff},\n\t.tx_preemphasis\t= {0xffff, 0xffff, 0xffff, 0xffff},\n\t.mdio_ctrl\t= 0,\n\t.supported\t= (SUPPORTED_10000baseT_Full |\n\t\t\t   SUPPORTED_FIBRE |\n\t\t\t   SUPPORTED_Pause |\n\t\t\t   SUPPORTED_Asym_Pause),\n\t.media_type\t= ETH_PHY_XFP_FIBER,\n\t.ver_addr\t= 0,\n\t.req_flow_ctrl\t= 0,\n\t.req_line_speed\t= 0,\n\t.speed_cap_mask\t= 0,\n\t.req_duplex\t= 0,\n\t.rsrv\t\t= 0,\n\t.config_init\t= bnx2x_8705_config_init,\n\t.read_status\t= bnx2x_8705_read_status,\n\t.link_reset\t= bnx2x_common_ext_link_reset,\n\t.config_loopback = NULL,\n\t.format_fw_ver\t= bnx2x_null_format_ver,\n\t.hw_reset\t= NULL,\n\t.set_link_led\t= NULL,\n\t.phy_specific_func = NULL\n};\nstatic const struct bnx2x_phy phy_8706 = {\n\t.type\t\t= PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8706,\n\t.addr\t\t= 0xff,\n\t.def_md_devad\t= 0,\n\t.flags\t\t= FLAGS_INIT_XGXS_FIRST,\n\t.rx_preemphasis\t= {0xffff, 0xffff, 0xffff, 0xffff},\n\t.tx_preemphasis\t= {0xffff, 0xffff, 0xffff, 0xffff},\n\t.mdio_ctrl\t= 0,\n\t.supported\t= (SUPPORTED_10000baseT_Full |\n\t\t\t   SUPPORTED_1000baseT_Full |\n\t\t\t   SUPPORTED_FIBRE |\n\t\t\t   SUPPORTED_Pause |\n\t\t\t   SUPPORTED_Asym_Pause),\n\t.media_type\t= ETH_PHY_SFPP_10G_FIBER,\n\t.ver_addr\t= 0,\n\t.req_flow_ctrl\t= 0,\n\t.req_line_speed\t= 0,\n\t.speed_cap_mask\t= 0,\n\t.req_duplex\t= 0,\n\t.rsrv\t\t= 0,\n\t.config_init\t= bnx2x_8706_config_init,\n\t.read_status\t= bnx2x_8706_read_status,\n\t.link_reset\t= bnx2x_common_ext_link_reset,\n\t.config_loopback = NULL,\n\t.format_fw_ver\t= bnx2x_format_ver,\n\t.hw_reset\t= NULL,\n\t.set_link_led\t= NULL,\n\t.phy_specific_func = NULL\n};\n\nstatic const struct bnx2x_phy phy_8726 = {\n\t.type\t\t= PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8726,\n\t.addr\t\t= 0xff,\n\t.def_md_devad\t= 0,\n\t.flags\t\t= (FLAGS_INIT_XGXS_FIRST |\n\t\t\t   FLAGS_TX_ERROR_CHECK),\n\t.rx_preemphasis\t= {0xffff, 0xffff, 0xffff, 0xffff},\n\t.tx_preemphasis\t= {0xffff, 0xffff, 0xffff, 0xffff},\n\t.mdio_ctrl\t= 0,\n\t.supported\t= (SUPPORTED_10000baseT_Full |\n\t\t\t   SUPPORTED_1000baseT_Full |\n\t\t\t   SUPPORTED_Autoneg |\n\t\t\t   SUPPORTED_FIBRE |\n\t\t\t   SUPPORTED_Pause |\n\t\t\t   SUPPORTED_Asym_Pause),\n\t.media_type\t= ETH_PHY_NOT_PRESENT,\n\t.ver_addr\t= 0,\n\t.req_flow_ctrl\t= 0,\n\t.req_line_speed\t= 0,\n\t.speed_cap_mask\t= 0,\n\t.req_duplex\t= 0,\n\t.rsrv\t\t= 0,\n\t.config_init\t= bnx2x_8726_config_init,\n\t.read_status\t= bnx2x_8726_read_status,\n\t.link_reset\t= bnx2x_8726_link_reset,\n\t.config_loopback = bnx2x_8726_config_loopback,\n\t.format_fw_ver\t= bnx2x_format_ver,\n\t.hw_reset\t= NULL,\n\t.set_link_led\t= NULL,\n\t.phy_specific_func = NULL\n};\n\nstatic const struct bnx2x_phy phy_8727 = {\n\t.type\t\t= PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8727,\n\t.addr\t\t= 0xff,\n\t.def_md_devad\t= 0,\n\t.flags\t\t= (FLAGS_FAN_FAILURE_DET_REQ |\n\t\t\t   FLAGS_TX_ERROR_CHECK),\n\t.rx_preemphasis\t= {0xffff, 0xffff, 0xffff, 0xffff},\n\t.tx_preemphasis\t= {0xffff, 0xffff, 0xffff, 0xffff},\n\t.mdio_ctrl\t= 0,\n\t.supported\t= (SUPPORTED_10000baseT_Full |\n\t\t\t   SUPPORTED_1000baseT_Full |\n\t\t\t   SUPPORTED_FIBRE |\n\t\t\t   SUPPORTED_Pause |\n\t\t\t   SUPPORTED_Asym_Pause),\n\t.media_type\t= ETH_PHY_NOT_PRESENT,\n\t.ver_addr\t= 0,\n\t.req_flow_ctrl\t= 0,\n\t.req_line_speed\t= 0,\n\t.speed_cap_mask\t= 0,\n\t.req_duplex\t= 0,\n\t.rsrv\t\t= 0,\n\t.config_init\t= bnx2x_8727_config_init,\n\t.read_status\t= bnx2x_8727_read_status,\n\t.link_reset\t= bnx2x_8727_link_reset,\n\t.config_loopback = NULL,\n\t.format_fw_ver\t= bnx2x_format_ver,\n\t.hw_reset\t= bnx2x_8727_hw_reset,\n\t.set_link_led\t= bnx2x_8727_set_link_led,\n\t.phy_specific_func = bnx2x_8727_specific_func\n};\nstatic const struct bnx2x_phy phy_8481 = {\n\t.type\t\t= PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8481,\n\t.addr\t\t= 0xff,\n\t.def_md_devad\t= 0,\n\t.flags\t\t= FLAGS_FAN_FAILURE_DET_REQ |\n\t\t\t  FLAGS_REARM_LATCH_SIGNAL,\n\t.rx_preemphasis\t= {0xffff, 0xffff, 0xffff, 0xffff},\n\t.tx_preemphasis\t= {0xffff, 0xffff, 0xffff, 0xffff},\n\t.mdio_ctrl\t= 0,\n\t.supported\t= (SUPPORTED_10baseT_Half |\n\t\t\t   SUPPORTED_10baseT_Full |\n\t\t\t   SUPPORTED_100baseT_Half |\n\t\t\t   SUPPORTED_100baseT_Full |\n\t\t\t   SUPPORTED_1000baseT_Full |\n\t\t\t   SUPPORTED_10000baseT_Full |\n\t\t\t   SUPPORTED_TP |\n\t\t\t   SUPPORTED_Autoneg |\n\t\t\t   SUPPORTED_Pause |\n\t\t\t   SUPPORTED_Asym_Pause),\n\t.media_type\t= ETH_PHY_BASE_T,\n\t.ver_addr\t= 0,\n\t.req_flow_ctrl\t= 0,\n\t.req_line_speed\t= 0,\n\t.speed_cap_mask\t= 0,\n\t.req_duplex\t= 0,\n\t.rsrv\t\t= 0,\n\t.config_init\t= bnx2x_8481_config_init,\n\t.read_status\t= bnx2x_848xx_read_status,\n\t.link_reset\t= bnx2x_8481_link_reset,\n\t.config_loopback = NULL,\n\t.format_fw_ver\t= bnx2x_848xx_format_ver,\n\t.hw_reset\t= bnx2x_8481_hw_reset,\n\t.set_link_led\t= bnx2x_848xx_set_link_led,\n\t.phy_specific_func = NULL\n};\n\nstatic const struct bnx2x_phy phy_84823 = {\n\t.type\t\t= PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84823,\n\t.addr\t\t= 0xff,\n\t.def_md_devad\t= 0,\n\t.flags\t\t= (FLAGS_FAN_FAILURE_DET_REQ |\n\t\t\t   FLAGS_REARM_LATCH_SIGNAL |\n\t\t\t   FLAGS_TX_ERROR_CHECK),\n\t.rx_preemphasis\t= {0xffff, 0xffff, 0xffff, 0xffff},\n\t.tx_preemphasis\t= {0xffff, 0xffff, 0xffff, 0xffff},\n\t.mdio_ctrl\t= 0,\n\t.supported\t= (SUPPORTED_10baseT_Half |\n\t\t\t   SUPPORTED_10baseT_Full |\n\t\t\t   SUPPORTED_100baseT_Half |\n\t\t\t   SUPPORTED_100baseT_Full |\n\t\t\t   SUPPORTED_1000baseT_Full |\n\t\t\t   SUPPORTED_10000baseT_Full |\n\t\t\t   SUPPORTED_TP |\n\t\t\t   SUPPORTED_Autoneg |\n\t\t\t   SUPPORTED_Pause |\n\t\t\t   SUPPORTED_Asym_Pause),\n\t.media_type\t= ETH_PHY_BASE_T,\n\t.ver_addr\t= 0,\n\t.req_flow_ctrl\t= 0,\n\t.req_line_speed\t= 0,\n\t.speed_cap_mask\t= 0,\n\t.req_duplex\t= 0,\n\t.rsrv\t\t= 0,\n\t.config_init\t= bnx2x_848x3_config_init,\n\t.read_status\t= bnx2x_848xx_read_status,\n\t.link_reset\t= bnx2x_848x3_link_reset,\n\t.config_loopback = NULL,\n\t.format_fw_ver\t= bnx2x_848xx_format_ver,\n\t.hw_reset\t= NULL,\n\t.set_link_led\t= bnx2x_848xx_set_link_led,\n\t.phy_specific_func = bnx2x_848xx_specific_func\n};\n\nstatic const struct bnx2x_phy phy_84833 = {\n\t.type\t\t= PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84833,\n\t.addr\t\t= 0xff,\n\t.def_md_devad\t= 0,\n\t.flags\t\t= (FLAGS_FAN_FAILURE_DET_REQ |\n\t\t\t   FLAGS_REARM_LATCH_SIGNAL |\n\t\t\t   FLAGS_TX_ERROR_CHECK),\n\t.rx_preemphasis\t= {0xffff, 0xffff, 0xffff, 0xffff},\n\t.tx_preemphasis\t= {0xffff, 0xffff, 0xffff, 0xffff},\n\t.mdio_ctrl\t= 0,\n\t.supported\t= (SUPPORTED_100baseT_Half |\n\t\t\t   SUPPORTED_100baseT_Full |\n\t\t\t   SUPPORTED_1000baseT_Full |\n\t\t\t   SUPPORTED_10000baseT_Full |\n\t\t\t   SUPPORTED_TP |\n\t\t\t   SUPPORTED_Autoneg |\n\t\t\t   SUPPORTED_Pause |\n\t\t\t   SUPPORTED_Asym_Pause),\n\t.media_type\t= ETH_PHY_BASE_T,\n\t.ver_addr\t= 0,\n\t.req_flow_ctrl\t= 0,\n\t.req_line_speed\t= 0,\n\t.speed_cap_mask\t= 0,\n\t.req_duplex\t= 0,\n\t.rsrv\t\t= 0,\n\t.config_init\t= bnx2x_848x3_config_init,\n\t.read_status\t= bnx2x_848xx_read_status,\n\t.link_reset\t= bnx2x_848x3_link_reset,\n\t.config_loopback = NULL,\n\t.format_fw_ver\t= bnx2x_848xx_format_ver,\n\t.hw_reset\t= bnx2x_84833_hw_reset_phy,\n\t.set_link_led\t= bnx2x_848xx_set_link_led,\n\t.phy_specific_func = bnx2x_848xx_specific_func\n};\n\nstatic const struct bnx2x_phy phy_84834 = {\n\t.type\t\t= PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84834,\n\t.addr\t\t= 0xff,\n\t.def_md_devad\t= 0,\n\t.flags\t\t= FLAGS_FAN_FAILURE_DET_REQ |\n\t\t\t    FLAGS_REARM_LATCH_SIGNAL,\n\t.rx_preemphasis\t= {0xffff, 0xffff, 0xffff, 0xffff},\n\t.tx_preemphasis\t= {0xffff, 0xffff, 0xffff, 0xffff},\n\t.mdio_ctrl\t= 0,\n\t.supported\t= (SUPPORTED_100baseT_Half |\n\t\t\t   SUPPORTED_100baseT_Full |\n\t\t\t   SUPPORTED_1000baseT_Full |\n\t\t\t   SUPPORTED_10000baseT_Full |\n\t\t\t   SUPPORTED_TP |\n\t\t\t   SUPPORTED_Autoneg |\n\t\t\t   SUPPORTED_Pause |\n\t\t\t   SUPPORTED_Asym_Pause),\n\t.media_type\t= ETH_PHY_BASE_T,\n\t.ver_addr\t= 0,\n\t.req_flow_ctrl\t= 0,\n\t.req_line_speed\t= 0,\n\t.speed_cap_mask\t= 0,\n\t.req_duplex\t= 0,\n\t.rsrv\t\t= 0,\n\t.config_init\t= bnx2x_848x3_config_init,\n\t.read_status\t= bnx2x_848xx_read_status,\n\t.link_reset\t= bnx2x_848x3_link_reset,\n\t.config_loopback = NULL,\n\t.format_fw_ver\t= bnx2x_848xx_format_ver,\n\t.hw_reset\t= bnx2x_84833_hw_reset_phy,\n\t.set_link_led\t= bnx2x_848xx_set_link_led,\n\t.phy_specific_func = bnx2x_848xx_specific_func\n};\n\nstatic const struct bnx2x_phy phy_84858 = {\n\t.type\t\t= PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84858,\n\t.addr\t\t= 0xff,\n\t.def_md_devad\t= 0,\n\t.flags\t\t= FLAGS_FAN_FAILURE_DET_REQ |\n\t\t\t    FLAGS_REARM_LATCH_SIGNAL,\n\t.rx_preemphasis\t= {0xffff, 0xffff, 0xffff, 0xffff},\n\t.tx_preemphasis\t= {0xffff, 0xffff, 0xffff, 0xffff},\n\t.mdio_ctrl\t= 0,\n\t.supported\t= (SUPPORTED_100baseT_Half |\n\t\t\t   SUPPORTED_100baseT_Full |\n\t\t\t   SUPPORTED_1000baseT_Full |\n\t\t\t   SUPPORTED_10000baseT_Full |\n\t\t\t   SUPPORTED_TP |\n\t\t\t   SUPPORTED_Autoneg |\n\t\t\t   SUPPORTED_Pause |\n\t\t\t   SUPPORTED_Asym_Pause),\n\t.media_type\t= ETH_PHY_BASE_T,\n\t.ver_addr\t= 0,\n\t.req_flow_ctrl\t= 0,\n\t.req_line_speed\t= 0,\n\t.speed_cap_mask\t= 0,\n\t.req_duplex\t= 0,\n\t.rsrv\t\t= 0,\n\t.config_init\t= bnx2x_848x3_config_init,\n\t.read_status\t= bnx2x_848xx_read_status,\n\t.link_reset\t= bnx2x_848x3_link_reset,\n\t.config_loopback = NULL,\n\t.format_fw_ver\t= bnx2x_8485x_format_ver,\n\t.hw_reset\t= bnx2x_84833_hw_reset_phy,\n\t.set_link_led\t= bnx2x_848xx_set_link_led,\n\t.phy_specific_func = bnx2x_848xx_specific_func\n};\n\nstatic const struct bnx2x_phy phy_54618se = {\n\t.type\t\t= PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM54618SE,\n\t.addr\t\t= 0xff,\n\t.def_md_devad\t= 0,\n\t.flags\t\t= FLAGS_INIT_XGXS_FIRST,\n\t.rx_preemphasis\t= {0xffff, 0xffff, 0xffff, 0xffff},\n\t.tx_preemphasis\t= {0xffff, 0xffff, 0xffff, 0xffff},\n\t.mdio_ctrl\t= 0,\n\t.supported\t= (SUPPORTED_10baseT_Half |\n\t\t\t   SUPPORTED_10baseT_Full |\n\t\t\t   SUPPORTED_100baseT_Half |\n\t\t\t   SUPPORTED_100baseT_Full |\n\t\t\t   SUPPORTED_1000baseT_Full |\n\t\t\t   SUPPORTED_TP |\n\t\t\t   SUPPORTED_Autoneg |\n\t\t\t   SUPPORTED_Pause |\n\t\t\t   SUPPORTED_Asym_Pause),\n\t.media_type\t= ETH_PHY_BASE_T,\n\t.ver_addr\t= 0,\n\t.req_flow_ctrl\t= 0,\n\t.req_line_speed\t= 0,\n\t.speed_cap_mask\t= 0,\n\t 0,\n\t 0,\n\t.config_init\t= bnx2x_54618se_config_init,\n\t.read_status\t= bnx2x_54618se_read_status,\n\t.link_reset\t= bnx2x_54618se_link_reset,\n\t.config_loopback = bnx2x_54618se_config_loopback,\n\t.format_fw_ver\t= NULL,\n\t.hw_reset\t= NULL,\n\t.set_link_led\t= bnx2x_5461x_set_link_led,\n\t.phy_specific_func = bnx2x_54618se_specific_func\n};\n \n \n \n \n \n\nstatic void bnx2x_populate_preemphasis(struct bnx2x *bp, u32 shmem_base,\n\t\t\t\t     struct bnx2x_phy *phy, u8 port,\n\t\t\t\t     u8 phy_index)\n{\n\t \n\tu32 rx = 0, tx = 0, i;\n\tfor (i = 0; i < 2; i++) {\n\t\t \n\t\tif (phy_index == INT_PHY || phy_index == EXT_PHY1) {\n\t\t\trx = REG_RD(bp, shmem_base +\n\t\t\t\t    offsetof(struct shmem_region,\n\t\t\t  dev_info.port_hw_config[port].xgxs_config_rx[i<<1]));\n\n\t\t\ttx = REG_RD(bp, shmem_base +\n\t\t\t\t    offsetof(struct shmem_region,\n\t\t\t  dev_info.port_hw_config[port].xgxs_config_tx[i<<1]));\n\t\t} else {\n\t\t\trx = REG_RD(bp, shmem_base +\n\t\t\t\t    offsetof(struct shmem_region,\n\t\t\t dev_info.port_hw_config[port].xgxs_config2_rx[i<<1]));\n\n\t\t\ttx = REG_RD(bp, shmem_base +\n\t\t\t\t    offsetof(struct shmem_region,\n\t\t\t dev_info.port_hw_config[port].xgxs_config2_rx[i<<1]));\n\t\t}\n\n\t\tphy->rx_preemphasis[i << 1] = ((rx>>16) & 0xffff);\n\t\tphy->rx_preemphasis[(i << 1) + 1] = (rx & 0xffff);\n\n\t\tphy->tx_preemphasis[i << 1] = ((tx>>16) & 0xffff);\n\t\tphy->tx_preemphasis[(i << 1) + 1] = (tx & 0xffff);\n\t}\n}\n\nstatic u32 bnx2x_get_ext_phy_config(struct bnx2x *bp, u32 shmem_base,\n\t\t\t\t    u8 phy_index, u8 port)\n{\n\tu32 ext_phy_config = 0;\n\tswitch (phy_index) {\n\tcase EXT_PHY1:\n\t\text_phy_config = REG_RD(bp, shmem_base +\n\t\t\t\t\t      offsetof(struct shmem_region,\n\t\t\tdev_info.port_hw_config[port].external_phy_config));\n\t\tbreak;\n\tcase EXT_PHY2:\n\t\text_phy_config = REG_RD(bp, shmem_base +\n\t\t\t\t\t      offsetof(struct shmem_region,\n\t\t\tdev_info.port_hw_config[port].external_phy_config2));\n\t\tbreak;\n\tdefault:\n\t\tDP(NETIF_MSG_LINK, \"Invalid phy_index %d\\n\", phy_index);\n\t\treturn -EINVAL;\n\t}\n\n\treturn ext_phy_config;\n}\nstatic int bnx2x_populate_int_phy(struct bnx2x *bp, u32 shmem_base, u8 port,\n\t\t\t\t  struct bnx2x_phy *phy)\n{\n\tu32 phy_addr;\n\tu32 chip_id;\n\tu32 switch_cfg = (REG_RD(bp, shmem_base +\n\t\t\t\t       offsetof(struct shmem_region,\n\t\t\tdev_info.port_feature_config[port].link_config)) &\n\t\t\t  PORT_FEATURE_CONNECTED_SWITCH_MASK);\n\tchip_id = (REG_RD(bp, MISC_REG_CHIP_NUM) << 16) |\n\t\t((REG_RD(bp, MISC_REG_CHIP_REV) & 0xf) << 12);\n\n\tDP(NETIF_MSG_LINK, \":chip_id = 0x%x\\n\", chip_id);\n\tif (USES_WARPCORE(bp)) {\n\t\tu32 serdes_net_if;\n\t\tphy_addr = REG_RD(bp,\n\t\t\t\t  MISC_REG_WC0_CTRL_PHY_ADDR);\n\t\t*phy = phy_warpcore;\n\t\tif (REG_RD(bp, MISC_REG_PORT4MODE_EN_OVWR) == 0x3)\n\t\t\tphy->flags |= FLAGS_4_PORT_MODE;\n\t\telse\n\t\t\tphy->flags &= ~FLAGS_4_PORT_MODE;\n\t\t\t \n\t\tserdes_net_if = (REG_RD(bp, shmem_base +\n\t\t\t\t\toffsetof(struct shmem_region, dev_info.\n\t\t\t\t\tport_hw_config[port].default_cfg)) &\n\t\t\t\t PORT_HW_CFG_NET_SERDES_IF_MASK);\n\t\t \n\t\tswitch (serdes_net_if) {\n\t\tcase PORT_HW_CFG_NET_SERDES_IF_SGMII:\n\t\t\tphy->supported &= (SUPPORTED_10baseT_Half |\n\t\t\t\t\t   SUPPORTED_10baseT_Full |\n\t\t\t\t\t   SUPPORTED_100baseT_Half |\n\t\t\t\t\t   SUPPORTED_100baseT_Full |\n\t\t\t\t\t   SUPPORTED_1000baseT_Full |\n\t\t\t\t\t   SUPPORTED_FIBRE |\n\t\t\t\t\t   SUPPORTED_Autoneg |\n\t\t\t\t\t   SUPPORTED_Pause |\n\t\t\t\t\t   SUPPORTED_Asym_Pause);\n\t\t\tphy->media_type = ETH_PHY_BASE_T;\n\t\t\tbreak;\n\t\tcase PORT_HW_CFG_NET_SERDES_IF_XFI:\n\t\t\tphy->supported &= (SUPPORTED_1000baseT_Full |\n\t\t\t\t\t   SUPPORTED_10000baseT_Full |\n\t\t\t\t\t   SUPPORTED_FIBRE |\n\t\t\t\t\t   SUPPORTED_Pause |\n\t\t\t\t\t   SUPPORTED_Asym_Pause);\n\t\t\tphy->media_type = ETH_PHY_XFP_FIBER;\n\t\t\tbreak;\n\t\tcase PORT_HW_CFG_NET_SERDES_IF_SFI:\n\t\t\tphy->supported &= (SUPPORTED_1000baseT_Full |\n\t\t\t\t\t   SUPPORTED_10000baseT_Full |\n\t\t\t\t\t   SUPPORTED_FIBRE |\n\t\t\t\t\t   SUPPORTED_Pause |\n\t\t\t\t\t   SUPPORTED_Asym_Pause);\n\t\t\tphy->media_type = ETH_PHY_SFPP_10G_FIBER;\n\t\t\tbreak;\n\t\tcase PORT_HW_CFG_NET_SERDES_IF_KR:\n\t\t\tphy->media_type = ETH_PHY_KR;\n\t\t\tphy->supported &= (SUPPORTED_1000baseKX_Full |\n\t\t\t\t\t   SUPPORTED_10000baseKR_Full |\n\t\t\t\t\t   SUPPORTED_FIBRE |\n\t\t\t\t\t   SUPPORTED_Autoneg |\n\t\t\t\t\t   SUPPORTED_Pause |\n\t\t\t\t\t   SUPPORTED_Asym_Pause);\n\t\t\tbreak;\n\t\tcase PORT_HW_CFG_NET_SERDES_IF_DXGXS:\n\t\t\tphy->media_type = ETH_PHY_KR;\n\t\t\tphy->flags |= FLAGS_WC_DUAL_MODE;\n\t\t\tphy->supported &= (SUPPORTED_20000baseMLD2_Full |\n\t\t\t\t\t   SUPPORTED_FIBRE |\n\t\t\t\t\t   SUPPORTED_Pause |\n\t\t\t\t\t   SUPPORTED_Asym_Pause);\n\t\t\tbreak;\n\t\tcase PORT_HW_CFG_NET_SERDES_IF_KR2:\n\t\t\tphy->media_type = ETH_PHY_KR;\n\t\t\tphy->flags |= FLAGS_WC_DUAL_MODE;\n\t\t\tphy->supported &= (SUPPORTED_20000baseKR2_Full |\n\t\t\t\t\t   SUPPORTED_10000baseKR_Full |\n\t\t\t\t\t   SUPPORTED_1000baseKX_Full |\n\t\t\t\t\t   SUPPORTED_Autoneg |\n\t\t\t\t\t   SUPPORTED_FIBRE |\n\t\t\t\t\t   SUPPORTED_Pause |\n\t\t\t\t\t   SUPPORTED_Asym_Pause);\n\t\t\tphy->flags &= ~FLAGS_TX_ERROR_CHECK;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDP(NETIF_MSG_LINK, \"Unknown WC interface type 0x%x\\n\",\n\t\t\t\t       serdes_net_if);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (CHIP_REV(bp) == CHIP_REV_Ax)\n\t\t\tphy->flags |= FLAGS_MDC_MDIO_WA;\n\t\telse\n\t\t\tphy->flags |= FLAGS_MDC_MDIO_WA_B0;\n\t} else {\n\t\tswitch (switch_cfg) {\n\t\tcase SWITCH_CFG_1G:\n\t\t\tphy_addr = REG_RD(bp,\n\t\t\t\t\t  NIG_REG_SERDES0_CTRL_PHY_ADDR +\n\t\t\t\t\t  port * 0x10);\n\t\t\t*phy = phy_serdes;\n\t\t\tbreak;\n\t\tcase SWITCH_CFG_10G:\n\t\t\tphy_addr = REG_RD(bp,\n\t\t\t\t\t  NIG_REG_XGXS0_CTRL_PHY_ADDR +\n\t\t\t\t\t  port * 0x18);\n\t\t\t*phy = phy_xgxs;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDP(NETIF_MSG_LINK, \"Invalid switch_cfg\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tphy->addr = (u8)phy_addr;\n\tphy->mdio_ctrl = bnx2x_get_emac_base(bp,\n\t\t\t\t\t    SHARED_HW_CFG_MDC_MDIO_ACCESS1_BOTH,\n\t\t\t\t\t    port);\n\tif (CHIP_IS_E2(bp))\n\t\tphy->def_md_devad = E2_DEFAULT_PHY_DEV_ADDR;\n\telse\n\t\tphy->def_md_devad = DEFAULT_PHY_DEV_ADDR;\n\n\tDP(NETIF_MSG_LINK, \"Internal phy port=%d, addr=0x%x, mdio_ctl=0x%x\\n\",\n\t\t   port, phy->addr, phy->mdio_ctrl);\n\n\tbnx2x_populate_preemphasis(bp, shmem_base, phy, port, INT_PHY);\n\treturn 0;\n}\n\nstatic int bnx2x_populate_ext_phy(struct bnx2x *bp,\n\t\t\t\t  u8 phy_index,\n\t\t\t\t  u32 shmem_base,\n\t\t\t\t  u32 shmem2_base,\n\t\t\t\t  u8 port,\n\t\t\t\t  struct bnx2x_phy *phy)\n{\n\tu32 ext_phy_config, phy_type, config2;\n\tu32 mdc_mdio_access = SHARED_HW_CFG_MDC_MDIO_ACCESS1_BOTH;\n\text_phy_config = bnx2x_get_ext_phy_config(bp, shmem_base,\n\t\t\t\t\t\t  phy_index, port);\n\tphy_type = XGXS_EXT_PHY_TYPE(ext_phy_config);\n\t \n\tswitch (phy_type) {\n\tcase PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8073:\n\t\tmdc_mdio_access = SHARED_HW_CFG_MDC_MDIO_ACCESS1_SWAPPED;\n\t\t*phy = phy_8073;\n\t\tbreak;\n\tcase PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8705:\n\t\t*phy = phy_8705;\n\t\tbreak;\n\tcase PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8706:\n\t\t*phy = phy_8706;\n\t\tbreak;\n\tcase PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8726:\n\t\tmdc_mdio_access = SHARED_HW_CFG_MDC_MDIO_ACCESS1_EMAC1;\n\t\t*phy = phy_8726;\n\t\tbreak;\n\tcase PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8727_NOC:\n\t\t \n\t\tmdc_mdio_access = SHARED_HW_CFG_MDC_MDIO_ACCESS1_EMAC1;\n\t\t*phy = phy_8727;\n\t\tphy->flags |= FLAGS_NOC;\n\t\tbreak;\n\tcase PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8722:\n\tcase PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8727:\n\t\tmdc_mdio_access = SHARED_HW_CFG_MDC_MDIO_ACCESS1_EMAC1;\n\t\t*phy = phy_8727;\n\t\tbreak;\n\tcase PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8481:\n\t\t*phy = phy_8481;\n\t\tbreak;\n\tcase PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84823:\n\t\t*phy = phy_84823;\n\t\tbreak;\n\tcase PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84833:\n\t\t*phy = phy_84833;\n\t\tbreak;\n\tcase PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84834:\n\t\t*phy = phy_84834;\n\t\tbreak;\n\tcase PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84858:\n\t\t*phy = phy_84858;\n\t\tbreak;\n\tcase PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM54616:\n\tcase PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM54618SE:\n\t\t*phy = phy_54618se;\n\t\tif (phy_type == PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM54618SE)\n\t\t\tphy->flags |= FLAGS_EEE;\n\t\tbreak;\n\tcase PORT_HW_CFG_XGXS_EXT_PHY_TYPE_SFX7101:\n\t\t*phy = phy_7101;\n\t\tbreak;\n\tcase PORT_HW_CFG_XGXS_EXT_PHY_TYPE_FAILURE:\n\t\t*phy = phy_null;\n\t\treturn -EINVAL;\n\tdefault:\n\t\t*phy = phy_null;\n\t\t \n\t\tif ((phy_type != PORT_HW_CFG_XGXS_EXT_PHY_TYPE_DIRECT) &&\n\t\t    (phy_type != PORT_HW_CFG_XGXS_EXT_PHY_TYPE_NOT_CONN))\n\t\t\treturn -EINVAL;\n\t\treturn 0;\n\t}\n\n\tphy->addr = XGXS_EXT_PHY_ADDR(ext_phy_config);\n\tbnx2x_populate_preemphasis(bp, shmem_base, phy, port, phy_index);\n\n\t \n\tconfig2 = REG_RD(bp, shmem_base + offsetof(struct shmem_region,\n\t\t\t\t\tdev_info.shared_hw_config.config2));\n\tif (phy_index == EXT_PHY1) {\n\t\tphy->ver_addr = shmem_base + offsetof(struct shmem_region,\n\t\t\t\tport_mb[port].ext_phy_fw_version);\n\n\t\t \n\t\tif (config2 & SHARED_HW_CFG_MDC_MDIO_ACCESS1_MASK)\n\t\t\tmdc_mdio_access = config2 &\n\t\t\tSHARED_HW_CFG_MDC_MDIO_ACCESS1_MASK;\n\t} else {\n\t\tu32 size = REG_RD(bp, shmem2_base);\n\n\t\tif (size >\n\t\t    offsetof(struct shmem2_region, ext_phy_fw_version2)) {\n\t\t\tphy->ver_addr = shmem2_base +\n\t\t\t    offsetof(struct shmem2_region,\n\t\t\t\t     ext_phy_fw_version2[port]);\n\t\t}\n\t\t \n\t\tif (config2 & SHARED_HW_CFG_MDC_MDIO_ACCESS2_MASK)\n\t\t\tmdc_mdio_access = (config2 &\n\t\t\tSHARED_HW_CFG_MDC_MDIO_ACCESS2_MASK) >>\n\t\t\t(SHARED_HW_CFG_MDC_MDIO_ACCESS2_SHIFT -\n\t\t\t SHARED_HW_CFG_MDC_MDIO_ACCESS1_SHIFT);\n\t}\n\tphy->mdio_ctrl = bnx2x_get_emac_base(bp, mdc_mdio_access, port);\n\n\tif (bnx2x_is_8483x_8485x(phy) && (phy->ver_addr)) {\n\t\t \n\t\tu32 raw_ver = REG_RD(bp, phy->ver_addr);\n\t\tif (((raw_ver & 0x7F) <= 39) &&\n\t\t    (((raw_ver & 0xF80) >> 7) <= 1))\n\t\t\tphy->supported &= ~(SUPPORTED_100baseT_Half |\n\t\t\t\t\t    SUPPORTED_100baseT_Full);\n\t}\n\n\tDP(NETIF_MSG_LINK, \"phy_type 0x%x port %d found in index %d\\n\",\n\t\t   phy_type, port, phy_index);\n\tDP(NETIF_MSG_LINK, \"             addr=0x%x, mdio_ctl=0x%x\\n\",\n\t\t   phy->addr, phy->mdio_ctrl);\n\treturn 0;\n}\n\nstatic int bnx2x_populate_phy(struct bnx2x *bp, u8 phy_index, u32 shmem_base,\n\t\t\t      u32 shmem2_base, u8 port, struct bnx2x_phy *phy)\n{\n\tphy->type = PORT_HW_CFG_XGXS_EXT_PHY_TYPE_NOT_CONN;\n\tif (phy_index == INT_PHY)\n\t\treturn bnx2x_populate_int_phy(bp, shmem_base, port, phy);\n\n\treturn bnx2x_populate_ext_phy(bp, phy_index, shmem_base, shmem2_base,\n\t\t\t\t\tport, phy);\n}\n\nstatic void bnx2x_phy_def_cfg(struct link_params *params,\n\t\t\t      struct bnx2x_phy *phy,\n\t\t\t      u8 phy_index)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu32 link_config;\n\t \n\tif (phy_index == EXT_PHY2) {\n\t\tlink_config = REG_RD(bp, params->shmem_base +\n\t\t\t\t     offsetof(struct shmem_region, dev_info.\n\t\t\tport_feature_config[params->port].link_config2));\n\t\tphy->speed_cap_mask = REG_RD(bp, params->shmem_base +\n\t\t\t\t\t     offsetof(struct shmem_region,\n\t\t\t\t\t\t      dev_info.\n\t\t\tport_hw_config[params->port].speed_capability_mask2));\n\t} else {\n\t\tlink_config = REG_RD(bp, params->shmem_base +\n\t\t\t\t     offsetof(struct shmem_region, dev_info.\n\t\t\t\tport_feature_config[params->port].link_config));\n\t\tphy->speed_cap_mask = REG_RD(bp, params->shmem_base +\n\t\t\t\t\t     offsetof(struct shmem_region,\n\t\t\t\t\t\t      dev_info.\n\t\t\tport_hw_config[params->port].speed_capability_mask));\n\t}\n\tDP(NETIF_MSG_LINK,\n\t   \"Default config phy idx %x cfg 0x%x speed_cap_mask 0x%x\\n\",\n\t   phy_index, link_config, phy->speed_cap_mask);\n\n\tphy->req_duplex = DUPLEX_FULL;\n\tswitch (link_config  & PORT_FEATURE_LINK_SPEED_MASK) {\n\tcase PORT_FEATURE_LINK_SPEED_10M_HALF:\n\t\tphy->req_duplex = DUPLEX_HALF;\n\t\tfallthrough;\n\tcase PORT_FEATURE_LINK_SPEED_10M_FULL:\n\t\tphy->req_line_speed = SPEED_10;\n\t\tbreak;\n\tcase PORT_FEATURE_LINK_SPEED_100M_HALF:\n\t\tphy->req_duplex = DUPLEX_HALF;\n\t\tfallthrough;\n\tcase PORT_FEATURE_LINK_SPEED_100M_FULL:\n\t\tphy->req_line_speed = SPEED_100;\n\t\tbreak;\n\tcase PORT_FEATURE_LINK_SPEED_1G:\n\t\tphy->req_line_speed = SPEED_1000;\n\t\tbreak;\n\tcase PORT_FEATURE_LINK_SPEED_2_5G:\n\t\tphy->req_line_speed = SPEED_2500;\n\t\tbreak;\n\tcase PORT_FEATURE_LINK_SPEED_10G_CX4:\n\t\tphy->req_line_speed = SPEED_10000;\n\t\tbreak;\n\tdefault:\n\t\tphy->req_line_speed = SPEED_AUTO_NEG;\n\t\tbreak;\n\t}\n\n\tswitch (link_config  & PORT_FEATURE_FLOW_CONTROL_MASK) {\n\tcase PORT_FEATURE_FLOW_CONTROL_AUTO:\n\t\tphy->req_flow_ctrl = BNX2X_FLOW_CTRL_AUTO;\n\t\tbreak;\n\tcase PORT_FEATURE_FLOW_CONTROL_TX:\n\t\tphy->req_flow_ctrl = BNX2X_FLOW_CTRL_TX;\n\t\tbreak;\n\tcase PORT_FEATURE_FLOW_CONTROL_RX:\n\t\tphy->req_flow_ctrl = BNX2X_FLOW_CTRL_RX;\n\t\tbreak;\n\tcase PORT_FEATURE_FLOW_CONTROL_BOTH:\n\t\tphy->req_flow_ctrl = BNX2X_FLOW_CTRL_BOTH;\n\t\tbreak;\n\tdefault:\n\t\tphy->req_flow_ctrl = BNX2X_FLOW_CTRL_NONE;\n\t\tbreak;\n\t}\n}\n\nu32 bnx2x_phy_selection(struct link_params *params)\n{\n\tu32 phy_config_swapped, prio_cfg;\n\tu32 return_cfg = PORT_HW_CFG_PHY_SELECTION_HARDWARE_DEFAULT;\n\n\tphy_config_swapped = params->multi_phy_config &\n\t\tPORT_HW_CFG_PHY_SWAPPED_ENABLED;\n\n\tprio_cfg = params->multi_phy_config &\n\t\t\tPORT_HW_CFG_PHY_SELECTION_MASK;\n\n\tif (phy_config_swapped) {\n\t\tswitch (prio_cfg) {\n\t\tcase PORT_HW_CFG_PHY_SELECTION_FIRST_PHY_PRIORITY:\n\t\t     return_cfg = PORT_HW_CFG_PHY_SELECTION_SECOND_PHY_PRIORITY;\n\t\t     break;\n\t\tcase PORT_HW_CFG_PHY_SELECTION_SECOND_PHY_PRIORITY:\n\t\t     return_cfg = PORT_HW_CFG_PHY_SELECTION_FIRST_PHY_PRIORITY;\n\t\t     break;\n\t\tcase PORT_HW_CFG_PHY_SELECTION_SECOND_PHY:\n\t\t     return_cfg = PORT_HW_CFG_PHY_SELECTION_FIRST_PHY;\n\t\t     break;\n\t\tcase PORT_HW_CFG_PHY_SELECTION_FIRST_PHY:\n\t\t     return_cfg = PORT_HW_CFG_PHY_SELECTION_SECOND_PHY;\n\t\t     break;\n\t\t}\n\t} else\n\t\treturn_cfg = prio_cfg;\n\n\treturn return_cfg;\n}\n\nint bnx2x_phy_probe(struct link_params *params)\n{\n\tu8 phy_index, actual_phy_idx;\n\tu32 phy_config_swapped, sync_offset, media_types;\n\tstruct bnx2x *bp = params->bp;\n\tstruct bnx2x_phy *phy;\n\tparams->num_phys = 0;\n\tDP(NETIF_MSG_LINK, \"Begin phy probe\\n\");\n\tphy_config_swapped = params->multi_phy_config &\n\t\tPORT_HW_CFG_PHY_SWAPPED_ENABLED;\n\n\tfor (phy_index = INT_PHY; phy_index < MAX_PHYS;\n\t      phy_index++) {\n\t\tactual_phy_idx = phy_index;\n\t\tif (phy_config_swapped) {\n\t\t\tif (phy_index == EXT_PHY1)\n\t\t\t\tactual_phy_idx = EXT_PHY2;\n\t\t\telse if (phy_index == EXT_PHY2)\n\t\t\t\tactual_phy_idx = EXT_PHY1;\n\t\t}\n\t\tDP(NETIF_MSG_LINK, \"phy_config_swapped %x, phy_index %x,\"\n\t\t\t       \" actual_phy_idx %x\\n\", phy_config_swapped,\n\t\t\t   phy_index, actual_phy_idx);\n\t\tphy = &params->phy[actual_phy_idx];\n\t\tif (bnx2x_populate_phy(bp, phy_index, params->shmem_base,\n\t\t\t\t       params->shmem2_base, params->port,\n\t\t\t\t       phy) != 0) {\n\t\t\tparams->num_phys = 0;\n\t\t\tDP(NETIF_MSG_LINK, \"phy probe failed in phy index %d\\n\",\n\t\t\t\t   phy_index);\n\t\t\tfor (phy_index = INT_PHY;\n\t\t\t      phy_index < MAX_PHYS;\n\t\t\t      phy_index++)\n\t\t\t\t*phy = phy_null;\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (phy->type == PORT_HW_CFG_XGXS_EXT_PHY_TYPE_NOT_CONN)\n\t\t\tbreak;\n\n\t\tif (params->feature_config_flags &\n\t\t    FEATURE_CONFIG_DISABLE_REMOTE_FAULT_DET)\n\t\t\tphy->flags &= ~FLAGS_TX_ERROR_CHECK;\n\n\t\tif (!(params->feature_config_flags &\n\t\t      FEATURE_CONFIG_MT_SUPPORT))\n\t\t\tphy->flags |= FLAGS_MDC_MDIO_WA_G;\n\n\t\tsync_offset = params->shmem_base +\n\t\t\toffsetof(struct shmem_region,\n\t\t\tdev_info.port_hw_config[params->port].media_type);\n\t\tmedia_types = REG_RD(bp, sync_offset);\n\n\t\t \n\t\tif ((media_types & (PORT_HW_CFG_MEDIA_TYPE_PHY0_MASK <<\n\t\t\t\t    (PORT_HW_CFG_MEDIA_TYPE_PHY1_SHIFT *\n\t\t\t\t     actual_phy_idx))) == 0) {\n\t\t\tmedia_types |= ((phy->media_type &\n\t\t\t\t\tPORT_HW_CFG_MEDIA_TYPE_PHY0_MASK) <<\n\t\t\t\t(PORT_HW_CFG_MEDIA_TYPE_PHY1_SHIFT *\n\t\t\t\t actual_phy_idx));\n\t\t}\n\t\tREG_WR(bp, sync_offset, media_types);\n\n\t\tbnx2x_phy_def_cfg(params, phy, phy_index);\n\t\tparams->num_phys++;\n\t}\n\n\tDP(NETIF_MSG_LINK, \"End phy probe. #phys found %x\\n\", params->num_phys);\n\treturn 0;\n}\n\nstatic void bnx2x_init_bmac_loopback(struct link_params *params,\n\t\t\t\t     struct link_vars *vars)\n{\n\tstruct bnx2x *bp = params->bp;\n\tvars->link_up = 1;\n\tvars->line_speed = SPEED_10000;\n\tvars->duplex = DUPLEX_FULL;\n\tvars->flow_ctrl = BNX2X_FLOW_CTRL_NONE;\n\tvars->mac_type = MAC_TYPE_BMAC;\n\n\tvars->phy_flags = PHY_XGXS_FLAG;\n\n\tbnx2x_xgxs_deassert(params);\n\n\t \n\tbnx2x_bmac_enable(params, vars, 1, 1);\n\n\tREG_WR(bp, NIG_REG_EGRESS_DRAIN0_MODE + params->port * 4, 0);\n}\n\nstatic void bnx2x_init_emac_loopback(struct link_params *params,\n\t\t\t\t     struct link_vars *vars)\n{\n\tstruct bnx2x *bp = params->bp;\n\tvars->link_up = 1;\n\tvars->line_speed = SPEED_1000;\n\tvars->duplex = DUPLEX_FULL;\n\tvars->flow_ctrl = BNX2X_FLOW_CTRL_NONE;\n\tvars->mac_type = MAC_TYPE_EMAC;\n\n\tvars->phy_flags = PHY_XGXS_FLAG;\n\n\tbnx2x_xgxs_deassert(params);\n\t \n\tbnx2x_emac_enable(params, vars, 1);\n\tbnx2x_emac_program(params, vars);\n\tREG_WR(bp, NIG_REG_EGRESS_DRAIN0_MODE + params->port * 4, 0);\n}\n\nstatic void bnx2x_init_xmac_loopback(struct link_params *params,\n\t\t\t\t     struct link_vars *vars)\n{\n\tstruct bnx2x *bp = params->bp;\n\tvars->link_up = 1;\n\tif (!params->req_line_speed[0])\n\t\tvars->line_speed = SPEED_10000;\n\telse\n\t\tvars->line_speed = params->req_line_speed[0];\n\tvars->duplex = DUPLEX_FULL;\n\tvars->flow_ctrl = BNX2X_FLOW_CTRL_NONE;\n\tvars->mac_type = MAC_TYPE_XMAC;\n\tvars->phy_flags = PHY_XGXS_FLAG;\n\t \n\tbnx2x_set_aer_mmd(params, &params->phy[0]);\n\tbnx2x_warpcore_reset_lane(bp, &params->phy[0], 0);\n\tparams->phy[INT_PHY].config_loopback(\n\t\t\t&params->phy[INT_PHY],\n\t\t\tparams);\n\n\tbnx2x_xmac_enable(params, vars, 1);\n\tREG_WR(bp, NIG_REG_EGRESS_DRAIN0_MODE + params->port*4, 0);\n}\n\nstatic void bnx2x_init_umac_loopback(struct link_params *params,\n\t\t\t\t     struct link_vars *vars)\n{\n\tstruct bnx2x *bp = params->bp;\n\tvars->link_up = 1;\n\tvars->line_speed = SPEED_1000;\n\tvars->duplex = DUPLEX_FULL;\n\tvars->flow_ctrl = BNX2X_FLOW_CTRL_NONE;\n\tvars->mac_type = MAC_TYPE_UMAC;\n\tvars->phy_flags = PHY_XGXS_FLAG;\n\tbnx2x_umac_enable(params, vars, 1);\n\n\tREG_WR(bp, NIG_REG_EGRESS_DRAIN0_MODE + params->port*4, 0);\n}\n\nstatic void bnx2x_init_xgxs_loopback(struct link_params *params,\n\t\t\t\t     struct link_vars *vars)\n{\n\tstruct bnx2x *bp = params->bp;\n\tstruct bnx2x_phy *int_phy = &params->phy[INT_PHY];\n\tvars->link_up = 1;\n\tvars->flow_ctrl = BNX2X_FLOW_CTRL_NONE;\n\tvars->duplex = DUPLEX_FULL;\n\tif (params->req_line_speed[0] == SPEED_1000)\n\t\tvars->line_speed = SPEED_1000;\n\telse if ((params->req_line_speed[0] == SPEED_20000) ||\n\t\t (int_phy->flags & FLAGS_WC_DUAL_MODE))\n\t\tvars->line_speed = SPEED_20000;\n\telse\n\t\tvars->line_speed = SPEED_10000;\n\n\tif (!USES_WARPCORE(bp))\n\t\tbnx2x_xgxs_deassert(params);\n\tbnx2x_link_initialize(params, vars);\n\n\tif (params->req_line_speed[0] == SPEED_1000) {\n\t\tif (USES_WARPCORE(bp))\n\t\t\tbnx2x_umac_enable(params, vars, 0);\n\t\telse {\n\t\t\tbnx2x_emac_program(params, vars);\n\t\t\tbnx2x_emac_enable(params, vars, 0);\n\t\t}\n\t} else {\n\t\tif (USES_WARPCORE(bp))\n\t\t\tbnx2x_xmac_enable(params, vars, 0);\n\t\telse\n\t\t\tbnx2x_bmac_enable(params, vars, 0, 1);\n\t}\n\n\tif (params->loopback_mode == LOOPBACK_XGXS) {\n\t\t \n\t\tint_phy->config_loopback(int_phy, params);\n\t} else {\n\t\t \n\t\tu8 phy_index;\n\t\tfor (phy_index = EXT_PHY1;\n\t\t      phy_index < params->num_phys; phy_index++)\n\t\t\tif (params->phy[phy_index].config_loopback)\n\t\t\t\tparams->phy[phy_index].config_loopback(\n\t\t\t\t\t&params->phy[phy_index],\n\t\t\t\t\tparams);\n\t}\n\tREG_WR(bp, NIG_REG_EGRESS_DRAIN0_MODE + params->port*4, 0);\n\n\tbnx2x_set_led(params, vars, LED_MODE_OPER, vars->line_speed);\n}\n\nvoid bnx2x_set_rx_filter(struct link_params *params, u8 en)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu8 val = en * 0x1F;\n\n\t \n\tif (!CHIP_IS_E1x(bp))\n\t\tval |= en * 0x20;\n\tREG_WR(bp, NIG_REG_LLH0_BRB1_DRV_MASK + params->port*4, val);\n\n\tif (!CHIP_IS_E1(bp)) {\n\t\tREG_WR(bp, NIG_REG_LLH0_BRB1_DRV_MASK_MF + params->port*4,\n\t\t       en*0x3);\n\t}\n\n\tREG_WR(bp, (params->port ? NIG_REG_LLH1_BRB1_NOT_MCP :\n\t\t    NIG_REG_LLH0_BRB1_NOT_MCP), en);\n}\nstatic int bnx2x_avoid_link_flap(struct link_params *params,\n\t\t\t\t\t    struct link_vars *vars)\n{\n\tu32 phy_idx;\n\tu32 dont_clear_stat, lfa_sts;\n\tstruct bnx2x *bp = params->bp;\n\n\tbnx2x_set_mdio_emac_per_phy(bp, params);\n\t \n\tbnx2x_link_status_update(params, vars);\n\n\t \n\n\tfor (phy_idx = INT_PHY; phy_idx < params->num_phys; phy_idx++) {\n\t\tstruct bnx2x_phy *phy = &params->phy[phy_idx];\n\t\tif (phy->phy_specific_func) {\n\t\t\tDP(NETIF_MSG_LINK, \"Calling PHY specific func\\n\");\n\t\t\tphy->phy_specific_func(phy, params, PHY_INIT);\n\t\t}\n\t\tif ((phy->media_type == ETH_PHY_SFPP_10G_FIBER) ||\n\t\t    (phy->media_type == ETH_PHY_SFP_1G_FIBER) ||\n\t\t    (phy->media_type == ETH_PHY_DA_TWINAX))\n\t\t\tbnx2x_verify_sfp_module(phy, params);\n\t}\n\tlfa_sts = REG_RD(bp, params->lfa_base +\n\t\t\t offsetof(struct shmem_lfa,\n\t\t\t\t  lfa_sts));\n\n\tdont_clear_stat = lfa_sts & SHMEM_LFA_DONT_CLEAR_STAT;\n\n\t \n\tif (CHIP_IS_E3(bp)) {\n\t\tif (!dont_clear_stat) {\n\t\t\tREG_WR(bp, GRCBASE_MISC +\n\t\t\t       MISC_REGISTERS_RESET_REG_2_CLEAR,\n\t\t\t       (MISC_REGISTERS_RESET_REG_2_MSTAT0 <<\n\t\t\t\tparams->port));\n\t\t\tREG_WR(bp, GRCBASE_MISC +\n\t\t\t       MISC_REGISTERS_RESET_REG_2_SET,\n\t\t\t       (MISC_REGISTERS_RESET_REG_2_MSTAT0 <<\n\t\t\t\tparams->port));\n\t\t}\n\t\tif (vars->line_speed < SPEED_10000)\n\t\t\tbnx2x_umac_enable(params, vars, 0);\n\t\telse\n\t\t\tbnx2x_xmac_enable(params, vars, 0);\n\t} else {\n\t\tif (vars->line_speed < SPEED_10000)\n\t\t\tbnx2x_emac_enable(params, vars, 0);\n\t\telse\n\t\t\tbnx2x_bmac_enable(params, vars, 0, !dont_clear_stat);\n\t}\n\n\t \n\tlfa_sts = ((lfa_sts & ~LINK_FLAP_AVOIDANCE_COUNT_MASK) |\n\t\t   (((((lfa_sts & LINK_FLAP_AVOIDANCE_COUNT_MASK) >>\n\t\t       LINK_FLAP_AVOIDANCE_COUNT_OFFSET) + 1) & 0xff)\n\t\t    << LINK_FLAP_AVOIDANCE_COUNT_OFFSET));\n\t \n\tlfa_sts &= ~LFA_LINK_FLAP_REASON_MASK;\n\n\tREG_WR(bp, params->lfa_base +\n\t       offsetof(struct shmem_lfa, lfa_sts), lfa_sts);\n\n\t \n\tREG_WR(bp, NIG_REG_EGRESS_DRAIN0_MODE + params->port*4, 0);\n\n\t \n\tbnx2x_link_int_enable(params);\n\treturn 0;\n}\n\nstatic void bnx2x_cannot_avoid_link_flap(struct link_params *params,\n\t\t\t\t\t struct link_vars *vars,\n\t\t\t\t\t int lfa_status)\n{\n\tu32 lfa_sts, cfg_idx, tmp_val;\n\tstruct bnx2x *bp = params->bp;\n\n\tbnx2x_link_reset(params, vars, 1);\n\n\tif (!params->lfa_base)\n\t\treturn;\n\t \n\tREG_WR(bp, params->lfa_base +\n\t       offsetof(struct shmem_lfa, req_duplex),\n\t       params->req_duplex[0] | (params->req_duplex[1] << 16));\n\n\tREG_WR(bp, params->lfa_base +\n\t       offsetof(struct shmem_lfa, req_flow_ctrl),\n\t       params->req_flow_ctrl[0] | (params->req_flow_ctrl[1] << 16));\n\n\tREG_WR(bp, params->lfa_base +\n\t       offsetof(struct shmem_lfa, req_line_speed),\n\t       params->req_line_speed[0] | (params->req_line_speed[1] << 16));\n\n\tfor (cfg_idx = 0; cfg_idx < SHMEM_LINK_CONFIG_SIZE; cfg_idx++) {\n\t\tREG_WR(bp, params->lfa_base +\n\t\t       offsetof(struct shmem_lfa,\n\t\t\t\tspeed_cap_mask[cfg_idx]),\n\t\t       params->speed_cap_mask[cfg_idx]);\n\t}\n\n\ttmp_val = REG_RD(bp, params->lfa_base +\n\t\t\t offsetof(struct shmem_lfa, additional_config));\n\ttmp_val &= ~REQ_FC_AUTO_ADV_MASK;\n\ttmp_val |= params->req_fc_auto_adv;\n\n\tREG_WR(bp, params->lfa_base +\n\t       offsetof(struct shmem_lfa, additional_config), tmp_val);\n\n\tlfa_sts = REG_RD(bp, params->lfa_base +\n\t\t\t offsetof(struct shmem_lfa, lfa_sts));\n\n\t \n\tlfa_sts &= ~SHMEM_LFA_DONT_CLEAR_STAT;\n\n\t \n\tlfa_sts &= ~LFA_LINK_FLAP_REASON_MASK;\n\tlfa_sts |= ((lfa_status & LFA_LINK_FLAP_REASON_MASK) <<\n\t\t    LFA_LINK_FLAP_REASON_OFFSET);\n\n\t \n\tlfa_sts = ((lfa_sts & ~LINK_FLAP_COUNT_MASK) |\n\t\t   (((((lfa_sts & LINK_FLAP_COUNT_MASK) >>\n\t\t       LINK_FLAP_COUNT_OFFSET) + 1) & 0xff)\n\t\t    << LINK_FLAP_COUNT_OFFSET));\n\tREG_WR(bp, params->lfa_base +\n\t       offsetof(struct shmem_lfa, lfa_sts), lfa_sts);\n\t \n}\n\nint bnx2x_phy_init(struct link_params *params, struct link_vars *vars)\n{\n\tint lfa_status;\n\tstruct bnx2x *bp = params->bp;\n\tDP(NETIF_MSG_LINK, \"Phy Initialization started\\n\");\n\tDP(NETIF_MSG_LINK, \"(1) req_speed %d, req_flowctrl %d\\n\",\n\t\t   params->req_line_speed[0], params->req_flow_ctrl[0]);\n\tDP(NETIF_MSG_LINK, \"(2) req_speed %d, req_flowctrl %d\\n\",\n\t\t   params->req_line_speed[1], params->req_flow_ctrl[1]);\n\tDP(NETIF_MSG_LINK, \"req_adv_flow_ctrl 0x%x\\n\", params->req_fc_auto_adv);\n\tvars->link_status = 0;\n\tvars->phy_link_up = 0;\n\tvars->link_up = 0;\n\tvars->line_speed = 0;\n\tvars->duplex = DUPLEX_FULL;\n\tvars->flow_ctrl = BNX2X_FLOW_CTRL_NONE;\n\tvars->mac_type = MAC_TYPE_NONE;\n\tvars->phy_flags = 0;\n\tvars->check_kr2_recovery_cnt = 0;\n\tparams->link_flags = PHY_INITIALIZED;\n\t \n\tbnx2x_set_rx_filter(params, 1);\n\tbnx2x_chng_link_count(params, true);\n\t \n\tlfa_status = bnx2x_check_lfa(params);\n\n\tif (lfa_status == 0) {\n\t\tDP(NETIF_MSG_LINK, \"Link Flap Avoidance in progress\\n\");\n\t\treturn bnx2x_avoid_link_flap(params, vars);\n\t}\n\n\tDP(NETIF_MSG_LINK, \"Cannot avoid link flap lfa_sta=0x%x\\n\",\n\t\t       lfa_status);\n\tbnx2x_cannot_avoid_link_flap(params, vars, lfa_status);\n\n\t \n\tbnx2x_bits_dis(bp, NIG_REG_MASK_INTERRUPT_PORT0 + params->port*4,\n\t\t       (NIG_MASK_XGXS0_LINK_STATUS |\n\t\t\tNIG_MASK_XGXS0_LINK10G |\n\t\t\tNIG_MASK_SERDES0_LINK_STATUS |\n\t\t\tNIG_MASK_MI_INT));\n\n\tbnx2x_emac_init(params, vars);\n\n\tif (params->feature_config_flags & FEATURE_CONFIG_PFC_ENABLED)\n\t\tvars->link_status |= LINK_STATUS_PFC_ENABLED;\n\n\tif (params->num_phys == 0) {\n\t\tDP(NETIF_MSG_LINK, \"No phy found for initialization !!\\n\");\n\t\treturn -EINVAL;\n\t}\n\tset_phy_vars(params, vars);\n\n\tDP(NETIF_MSG_LINK, \"Num of phys on board: %d\\n\", params->num_phys);\n\tswitch (params->loopback_mode) {\n\tcase LOOPBACK_BMAC:\n\t\tbnx2x_init_bmac_loopback(params, vars);\n\t\tbreak;\n\tcase LOOPBACK_EMAC:\n\t\tbnx2x_init_emac_loopback(params, vars);\n\t\tbreak;\n\tcase LOOPBACK_XMAC:\n\t\tbnx2x_init_xmac_loopback(params, vars);\n\t\tbreak;\n\tcase LOOPBACK_UMAC:\n\t\tbnx2x_init_umac_loopback(params, vars);\n\t\tbreak;\n\tcase LOOPBACK_XGXS:\n\tcase LOOPBACK_EXT_PHY:\n\t\tbnx2x_init_xgxs_loopback(params, vars);\n\t\tbreak;\n\tdefault:\n\t\tif (!CHIP_IS_E3(bp)) {\n\t\t\tif (params->switch_cfg == SWITCH_CFG_10G)\n\t\t\t\tbnx2x_xgxs_deassert(params);\n\t\t\telse\n\t\t\t\tbnx2x_serdes_deassert(bp, params->port);\n\t\t}\n\t\tbnx2x_link_initialize(params, vars);\n\t\tmsleep(30);\n\t\tbnx2x_link_int_enable(params);\n\t\tbreak;\n\t}\n\tbnx2x_update_mng(params, vars->link_status);\n\n\tbnx2x_update_mng_eee(params, vars->eee_status);\n\treturn 0;\n}\n\nint bnx2x_link_reset(struct link_params *params, struct link_vars *vars,\n\t\t     u8 reset_ext_phy)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu8 phy_index, port = params->port, clear_latch_ind = 0;\n\tDP(NETIF_MSG_LINK, \"Resetting the link of port %d\\n\", port);\n\t \n\tvars->link_status = 0;\n\tbnx2x_chng_link_count(params, true);\n\tbnx2x_update_mng(params, vars->link_status);\n\tvars->eee_status &= ~(SHMEM_EEE_LP_ADV_STATUS_MASK |\n\t\t\t      SHMEM_EEE_ACTIVE_BIT);\n\tbnx2x_update_mng_eee(params, vars->eee_status);\n\tbnx2x_bits_dis(bp, NIG_REG_MASK_INTERRUPT_PORT0 + port*4,\n\t\t       (NIG_MASK_XGXS0_LINK_STATUS |\n\t\t\tNIG_MASK_XGXS0_LINK10G |\n\t\t\tNIG_MASK_SERDES0_LINK_STATUS |\n\t\t\tNIG_MASK_MI_INT));\n\n\t \n\tREG_WR(bp, NIG_REG_EGRESS_DRAIN0_MODE + port*4, 1);\n\n\t \n\tif (!CHIP_IS_E3(bp)) {\n\t\tREG_WR(bp, NIG_REG_BMAC0_OUT_EN + port*4, 0);\n\t\tREG_WR(bp, NIG_REG_EGRESS_EMAC0_OUT_EN + port*4, 0);\n\t}\n\n\tif (!CHIP_IS_E3(bp)) {\n\t\tbnx2x_set_bmac_rx(bp, params->chip_id, port, 0);\n\t} else {\n\t\tbnx2x_set_xmac_rxtx(params, 0);\n\t\tbnx2x_set_umac_rxtx(params, 0);\n\t}\n\t \n\tif (!CHIP_IS_E3(bp))\n\t\tREG_WR(bp, NIG_REG_NIG_EMAC0_EN + port*4, 0);\n\n\tusleep_range(10000, 20000);\n\t \n\t  \n\tbnx2x_set_mdio_emac_per_phy(bp, params);\n\tbnx2x_set_led(params, vars, LED_MODE_OFF, 0);\n\n\tif (reset_ext_phy) {\n\t\tfor (phy_index = EXT_PHY1; phy_index < params->num_phys;\n\t\t      phy_index++) {\n\t\t\tif (params->phy[phy_index].link_reset) {\n\t\t\t\tbnx2x_set_aer_mmd(params,\n\t\t\t\t\t\t  &params->phy[phy_index]);\n\t\t\t\tparams->phy[phy_index].link_reset(\n\t\t\t\t\t&params->phy[phy_index],\n\t\t\t\t\tparams);\n\t\t\t}\n\t\t\tif (params->phy[phy_index].flags &\n\t\t\t    FLAGS_REARM_LATCH_SIGNAL)\n\t\t\t\tclear_latch_ind = 1;\n\t\t}\n\t}\n\n\tif (clear_latch_ind) {\n\t\t \n\t\tbnx2x_rearm_latch_signal(bp, port, 0);\n\t\tbnx2x_bits_dis(bp, NIG_REG_LATCH_BC_0 + port*4,\n\t\t\t       1 << NIG_LATCH_BC_ENABLE_MI_INT);\n\t}\n\tif (params->phy[INT_PHY].link_reset)\n\t\tparams->phy[INT_PHY].link_reset(\n\t\t\t&params->phy[INT_PHY], params);\n\n\t \n\tif (!CHIP_IS_E3(bp)) {\n\t\t \n\t\tREG_WR(bp, GRCBASE_MISC + MISC_REGISTERS_RESET_REG_2_CLEAR,\n\t\t       (MISC_REGISTERS_RESET_REG_2_RST_BMAC0 << port));\n\t\tREG_WR(bp, NIG_REG_BMAC0_IN_EN + port*4, 0);\n\t\tREG_WR(bp, NIG_REG_EMAC0_IN_EN + port*4, 0);\n\t} else {\n\t\tu32 xmac_base = (params->port) ? GRCBASE_XMAC1 : GRCBASE_XMAC0;\n\t\tbnx2x_set_xumac_nig(params, 0, 0);\n\t\tif (REG_RD(bp, MISC_REG_RESET_REG_2) &\n\t\t    MISC_REGISTERS_RESET_REG_2_XMAC)\n\t\t\tREG_WR(bp, xmac_base + XMAC_REG_CTRL,\n\t\t\t       XMAC_CTRL_REG_SOFT_RESET);\n\t}\n\tvars->link_up = 0;\n\tvars->phy_flags = 0;\n\treturn 0;\n}\nint bnx2x_lfa_reset(struct link_params *params,\n\t\t\t       struct link_vars *vars)\n{\n\tstruct bnx2x *bp = params->bp;\n\tvars->link_up = 0;\n\tvars->phy_flags = 0;\n\tparams->link_flags &= ~PHY_INITIALIZED;\n\tif (!params->lfa_base)\n\t\treturn bnx2x_link_reset(params, vars, 1);\n\t \n\tREG_WR(bp, NIG_REG_EGRESS_DRAIN0_MODE + params->port*4, 1);\n\n\t \n\tif (!CHIP_IS_E3(bp))\n\t\tbnx2x_set_bmac_rx(bp, params->chip_id, params->port, 0);\n\n\tif (CHIP_IS_E3(bp)) {\n\t\tbnx2x_set_xmac_rxtx(params, 0);\n\t\tbnx2x_set_umac_rxtx(params, 0);\n\t}\n\t \n\tusleep_range(10000, 20000);\n\n\t \n\tbnx2x_set_rx_filter(params, 0);\n\n\t \n\tif (!CHIP_IS_E3(bp))\n\t\tbnx2x_set_bmac_rx(bp, params->chip_id, params->port, 1);\n\n\tif (CHIP_IS_E3(bp)) {\n\t\tbnx2x_set_xmac_rxtx(params, 1);\n\t\tbnx2x_set_umac_rxtx(params, 1);\n\t}\n\t \n\tREG_WR(bp, NIG_REG_EGRESS_DRAIN0_MODE + params->port*4, 0);\n\treturn 0;\n}\n\n \n \n \nstatic int bnx2x_8073_common_init_phy(struct bnx2x *bp,\n\t\t\t\t      u32 shmem_base_path[],\n\t\t\t\t      u32 shmem2_base_path[], u8 phy_index,\n\t\t\t\t      u32 chip_id)\n{\n\tstruct bnx2x_phy phy[PORT_MAX];\n\tstruct bnx2x_phy *phy_blk[PORT_MAX];\n\tu16 val;\n\ts8 port = 0;\n\ts8 port_of_path = 0;\n\tu32 swap_val, swap_override;\n\tswap_val = REG_RD(bp,  NIG_REG_PORT_SWAP);\n\tswap_override = REG_RD(bp,  NIG_REG_STRAP_OVERRIDE);\n\tport ^= (swap_val && swap_override);\n\tbnx2x_ext_phy_hw_reset(bp, port);\n\t \n\tfor (port = PORT_MAX - 1; port >= PORT_0; port--) {\n\t\tu32 shmem_base, shmem2_base;\n\t\t \n\t\tif (CHIP_IS_E1x(bp)) {\n\t\t\tshmem_base = shmem_base_path[0];\n\t\t\tshmem2_base = shmem2_base_path[0];\n\t\t\tport_of_path = port;\n\t\t} else {\n\t\t\tshmem_base = shmem_base_path[port];\n\t\t\tshmem2_base = shmem2_base_path[port];\n\t\t\tport_of_path = 0;\n\t\t}\n\n\t\t \n\t\tif (bnx2x_populate_phy(bp, phy_index, shmem_base, shmem2_base,\n\t\t\t\t       port_of_path, &phy[port]) !=\n\t\t    0) {\n\t\t\tDP(NETIF_MSG_LINK, \"populate_phy failed\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t \n\t\tbnx2x_bits_dis(bp, NIG_REG_MASK_INTERRUPT_PORT0 +\n\t\t\t       port_of_path*4,\n\t\t\t       (NIG_MASK_XGXS0_LINK_STATUS |\n\t\t\t\tNIG_MASK_XGXS0_LINK10G |\n\t\t\t\tNIG_MASK_SERDES0_LINK_STATUS |\n\t\t\t\tNIG_MASK_MI_INT));\n\n\t\t \n\t\tbnx2x_set_gpio(bp, MISC_REGISTERS_GPIO_2,\n\t\t\t       MISC_REGISTERS_GPIO_OUTPUT_HIGH,\n\t\t\t       port);\n\n\t\t \n\t\tbnx2x_cl45_write(bp, &phy[port],\n\t\t\t\t MDIO_PMA_DEVAD,\n\t\t\t\t MDIO_PMA_REG_CTRL,\n\t\t\t\t 1<<15);\n\t}\n\n\t \n\tmsleep(150);\n\n\tif (phy[PORT_0].addr & 0x1) {\n\t\tphy_blk[PORT_0] = &(phy[PORT_1]);\n\t\tphy_blk[PORT_1] = &(phy[PORT_0]);\n\t} else {\n\t\tphy_blk[PORT_0] = &(phy[PORT_0]);\n\t\tphy_blk[PORT_1] = &(phy[PORT_1]);\n\t}\n\n\t \n\tfor (port = PORT_MAX - 1; port >= PORT_0; port--) {\n\t\tif (CHIP_IS_E1x(bp))\n\t\t\tport_of_path = port;\n\t\telse\n\t\t\tport_of_path = 0;\n\n\t\tDP(NETIF_MSG_LINK, \"Loading spirom for phy address 0x%x\\n\",\n\t\t\t   phy_blk[port]->addr);\n\t\tif (bnx2x_8073_8727_external_rom_boot(bp, phy_blk[port],\n\t\t\t\t\t\t      port_of_path))\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tbnx2x_cl45_read(bp, phy_blk[port],\n\t\t\t\tMDIO_PMA_DEVAD,\n\t\t\t\tMDIO_PMA_REG_TX_POWER_DOWN, &val);\n\n\t\t \n\t\tbnx2x_cl45_write(bp, phy_blk[port],\n\t\t\t\t MDIO_PMA_DEVAD,\n\t\t\t\t MDIO_PMA_REG_TX_POWER_DOWN,\n\t\t\t\t (val | 1<<10));\n\t}\n\n\t \n\tmsleep(600);\n\n\t \n\tfor (port = PORT_MAX - 1; port >= PORT_0; port--) {\n\t\t \n\t\t \n\t\tbnx2x_cl45_read(bp, phy_blk[port],\n\t\t\t\tMDIO_PMA_DEVAD,\n\t\t\t\tMDIO_PMA_REG_TX_POWER_DOWN, &val);\n\n\t\tbnx2x_cl45_write(bp, phy_blk[port],\n\t\t\t\tMDIO_PMA_DEVAD,\n\t\t\t\tMDIO_PMA_REG_TX_POWER_DOWN, (val & (~(1<<10))));\n\t\tusleep_range(15000, 30000);\n\n\t\t \n\t\tbnx2x_cl45_read(bp, phy_blk[port],\n\t\t\t\tMDIO_PMA_DEVAD,\n\t\t\t\tMDIO_PMA_REG_EDC_FFE_MAIN, &val);\n\t\tbnx2x_cl45_write(bp, phy_blk[port],\n\t\t\t\t MDIO_PMA_DEVAD,\n\t\t\t\t MDIO_PMA_REG_EDC_FFE_MAIN, (val | (1<<12)));\n\n\t\t \n\t\tbnx2x_set_gpio(bp, MISC_REGISTERS_GPIO_2,\n\t\t\t       MISC_REGISTERS_GPIO_OUTPUT_LOW, port);\n\t}\n\treturn 0;\n}\nstatic int bnx2x_8726_common_init_phy(struct bnx2x *bp,\n\t\t\t\t      u32 shmem_base_path[],\n\t\t\t\t      u32 shmem2_base_path[], u8 phy_index,\n\t\t\t\t      u32 chip_id)\n{\n\tu32 val;\n\ts8 port;\n\tstruct bnx2x_phy phy;\n\t \n\t \n\tval = REG_RD(bp, MISC_REG_GPIO_EVENT_EN);\n\tval |= ((1<<MISC_REGISTERS_GPIO_3)|\n\t\t(1<<(MISC_REGISTERS_GPIO_3 + MISC_REGISTERS_GPIO_PORT_SHIFT)));\n\tREG_WR(bp, MISC_REG_GPIO_EVENT_EN, val);\n\n\tbnx2x_ext_phy_hw_reset(bp, 0);\n\tusleep_range(5000, 10000);\n\tfor (port = 0; port < PORT_MAX; port++) {\n\t\tu32 shmem_base, shmem2_base;\n\n\t\t \n\t\tif (CHIP_IS_E1x(bp)) {\n\t\t\tshmem_base = shmem_base_path[0];\n\t\t\tshmem2_base = shmem2_base_path[0];\n\t\t} else {\n\t\t\tshmem_base = shmem_base_path[port];\n\t\t\tshmem2_base = shmem2_base_path[port];\n\t\t}\n\t\t \n\t\tif (bnx2x_populate_phy(bp, phy_index, shmem_base, shmem2_base,\n\t\t\t\t       port, &phy) !=\n\t\t    0) {\n\t\t\tDP(NETIF_MSG_LINK, \"populate phy failed\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tbnx2x_cl45_write(bp, &phy,\n\t\t\t\t MDIO_PMA_DEVAD, MDIO_PMA_REG_GEN_CTRL, 0x0001);\n\n\n\t\t \n\t\tbnx2x_set_gpio(bp, MISC_REGISTERS_GPIO_0,\n\t\t\t       MISC_REGISTERS_GPIO_HIGH,\n\t\t\t       port);\n\t}\n\n\treturn 0;\n}\nstatic void bnx2x_get_ext_phy_reset_gpio(struct bnx2x *bp, u32 shmem_base,\n\t\t\t\t\t u8 *io_gpio, u8 *io_port)\n{\n\n\tu32 phy_gpio_reset = REG_RD(bp, shmem_base +\n\t\t\t\t\t  offsetof(struct shmem_region,\n\t\t\t\tdev_info.port_hw_config[PORT_0].default_cfg));\n\tswitch (phy_gpio_reset) {\n\tcase PORT_HW_CFG_EXT_PHY_GPIO_RST_GPIO0_P0:\n\t\t*io_gpio = 0;\n\t\t*io_port = 0;\n\t\tbreak;\n\tcase PORT_HW_CFG_EXT_PHY_GPIO_RST_GPIO1_P0:\n\t\t*io_gpio = 1;\n\t\t*io_port = 0;\n\t\tbreak;\n\tcase PORT_HW_CFG_EXT_PHY_GPIO_RST_GPIO2_P0:\n\t\t*io_gpio = 2;\n\t\t*io_port = 0;\n\t\tbreak;\n\tcase PORT_HW_CFG_EXT_PHY_GPIO_RST_GPIO3_P0:\n\t\t*io_gpio = 3;\n\t\t*io_port = 0;\n\t\tbreak;\n\tcase PORT_HW_CFG_EXT_PHY_GPIO_RST_GPIO0_P1:\n\t\t*io_gpio = 0;\n\t\t*io_port = 1;\n\t\tbreak;\n\tcase PORT_HW_CFG_EXT_PHY_GPIO_RST_GPIO1_P1:\n\t\t*io_gpio = 1;\n\t\t*io_port = 1;\n\t\tbreak;\n\tcase PORT_HW_CFG_EXT_PHY_GPIO_RST_GPIO2_P1:\n\t\t*io_gpio = 2;\n\t\t*io_port = 1;\n\t\tbreak;\n\tcase PORT_HW_CFG_EXT_PHY_GPIO_RST_GPIO3_P1:\n\t\t*io_gpio = 3;\n\t\t*io_port = 1;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n}\n\nstatic int bnx2x_8727_common_init_phy(struct bnx2x *bp,\n\t\t\t\t      u32 shmem_base_path[],\n\t\t\t\t      u32 shmem2_base_path[], u8 phy_index,\n\t\t\t\t      u32 chip_id)\n{\n\ts8 port, reset_gpio;\n\tu32 swap_val, swap_override;\n\tstruct bnx2x_phy phy[PORT_MAX];\n\tstruct bnx2x_phy *phy_blk[PORT_MAX];\n\ts8 port_of_path;\n\tswap_val = REG_RD(bp, NIG_REG_PORT_SWAP);\n\tswap_override = REG_RD(bp, NIG_REG_STRAP_OVERRIDE);\n\n\treset_gpio = MISC_REGISTERS_GPIO_1;\n\tport = 1;\n\n\t \n\tbnx2x_get_ext_phy_reset_gpio(bp, shmem_base_path[0],\n\t\t\t\t     (u8 *)&reset_gpio, (u8 *)&port);\n\n\t \n\tport ^= (swap_val && swap_override);\n\n\t \n\tbnx2x_set_gpio(bp, reset_gpio, MISC_REGISTERS_GPIO_OUTPUT_LOW,\n\t\t       port);\n\tusleep_range(1000, 2000);\n\tbnx2x_set_gpio(bp, reset_gpio, MISC_REGISTERS_GPIO_OUTPUT_HIGH,\n\t\t       port);\n\n\tusleep_range(5000, 10000);\n\n\t \n\tfor (port = PORT_MAX - 1; port >= PORT_0; port--) {\n\t\tu32 shmem_base, shmem2_base;\n\n\t\t \n\t\tif (CHIP_IS_E1x(bp)) {\n\t\t\tshmem_base = shmem_base_path[0];\n\t\t\tshmem2_base = shmem2_base_path[0];\n\t\t\tport_of_path = port;\n\t\t} else {\n\t\t\tshmem_base = shmem_base_path[port];\n\t\t\tshmem2_base = shmem2_base_path[port];\n\t\t\tport_of_path = 0;\n\t\t}\n\n\t\t \n\t\tif (bnx2x_populate_phy(bp, phy_index, shmem_base, shmem2_base,\n\t\t\t\t       port_of_path, &phy[port]) !=\n\t\t\t\t       0) {\n\t\t\tDP(NETIF_MSG_LINK, \"populate phy failed\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t \n\t\tbnx2x_bits_dis(bp, NIG_REG_MASK_INTERRUPT_PORT0 +\n\t\t\t       port_of_path*4,\n\t\t\t       (NIG_MASK_XGXS0_LINK_STATUS |\n\t\t\t\tNIG_MASK_XGXS0_LINK10G |\n\t\t\t\tNIG_MASK_SERDES0_LINK_STATUS |\n\t\t\t\tNIG_MASK_MI_INT));\n\n\n\t\t \n\t\tbnx2x_cl45_write(bp, &phy[port],\n\t\t\t\t MDIO_PMA_DEVAD, MDIO_PMA_REG_CTRL, 1<<15);\n\t}\n\n\t \n\tmsleep(150);\n\tif (phy[PORT_0].addr & 0x1) {\n\t\tphy_blk[PORT_0] = &(phy[PORT_1]);\n\t\tphy_blk[PORT_1] = &(phy[PORT_0]);\n\t} else {\n\t\tphy_blk[PORT_0] = &(phy[PORT_0]);\n\t\tphy_blk[PORT_1] = &(phy[PORT_1]);\n\t}\n\t \n\tfor (port = PORT_MAX - 1; port >= PORT_0; port--) {\n\t\tif (CHIP_IS_E1x(bp))\n\t\t\tport_of_path = port;\n\t\telse\n\t\t\tport_of_path = 0;\n\t\tDP(NETIF_MSG_LINK, \"Loading spirom for phy address 0x%x\\n\",\n\t\t\t   phy_blk[port]->addr);\n\t\tif (bnx2x_8073_8727_external_rom_boot(bp, phy_blk[port],\n\t\t\t\t\t\t      port_of_path))\n\t\t\treturn -EINVAL;\n\t\t \n\t\tbnx2x_cl45_write(bp, phy_blk[port],\n\t\t\t\t MDIO_PMA_DEVAD,\n\t\t\t\t MDIO_PMA_REG_TX_DISABLE, 1);\n\n\t}\n\treturn 0;\n}\n\nstatic int bnx2x_84833_common_init_phy(struct bnx2x *bp,\n\t\t\t\t\t\tu32 shmem_base_path[],\n\t\t\t\t\t\tu32 shmem2_base_path[],\n\t\t\t\t\t\tu8 phy_index,\n\t\t\t\t\t\tu32 chip_id)\n{\n\tu8 reset_gpios;\n\treset_gpios = bnx2x_84833_get_reset_gpios(bp, shmem_base_path, chip_id);\n\tbnx2x_set_mult_gpio(bp, reset_gpios, MISC_REGISTERS_GPIO_OUTPUT_LOW);\n\tudelay(10);\n\tbnx2x_set_mult_gpio(bp, reset_gpios, MISC_REGISTERS_GPIO_OUTPUT_HIGH);\n\tDP(NETIF_MSG_LINK, \"84833 reset pulse on pin values 0x%x\\n\",\n\t\treset_gpios);\n\treturn 0;\n}\n\nstatic int bnx2x_ext_phy_common_init(struct bnx2x *bp, u32 shmem_base_path[],\n\t\t\t\t     u32 shmem2_base_path[], u8 phy_index,\n\t\t\t\t     u32 ext_phy_type, u32 chip_id)\n{\n\tint rc = 0;\n\n\tswitch (ext_phy_type) {\n\tcase PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8073:\n\t\trc = bnx2x_8073_common_init_phy(bp, shmem_base_path,\n\t\t\t\t\t\tshmem2_base_path,\n\t\t\t\t\t\tphy_index, chip_id);\n\t\tbreak;\n\tcase PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8722:\n\tcase PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8727:\n\tcase PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8727_NOC:\n\t\trc = bnx2x_8727_common_init_phy(bp, shmem_base_path,\n\t\t\t\t\t\tshmem2_base_path,\n\t\t\t\t\t\tphy_index, chip_id);\n\t\tbreak;\n\n\tcase PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8726:\n\t\t \n\t\trc = bnx2x_8726_common_init_phy(bp, shmem_base_path,\n\t\t\t\t\t\tshmem2_base_path,\n\t\t\t\t\t\tphy_index, chip_id);\n\t\tbreak;\n\tcase PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84833:\n\tcase PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84834:\n\tcase PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84858:\n\t\t \n\t\trc = bnx2x_84833_common_init_phy(bp, shmem_base_path,\n\t\t\t\t\t\tshmem2_base_path,\n\t\t\t\t\t\tphy_index, chip_id);\n\t\tbreak;\n\tcase PORT_HW_CFG_XGXS_EXT_PHY_TYPE_FAILURE:\n\t\trc = -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\tDP(NETIF_MSG_LINK,\n\t\t\t   \"ext_phy 0x%x common init not required\\n\",\n\t\t\t   ext_phy_type);\n\t\tbreak;\n\t}\n\n\tif (rc)\n\t\tnetdev_err(bp->dev,  \"Warning: PHY was not initialized,\"\n\t\t\t\t      \" Port %d\\n\",\n\t\t\t 0);\n\treturn rc;\n}\n\nint bnx2x_common_init_phy(struct bnx2x *bp, u32 shmem_base_path[],\n\t\t\t  u32 shmem2_base_path[], u32 chip_id)\n{\n\tint rc = 0;\n\tu32 phy_ver, val;\n\tu8 phy_index = 0;\n\tu32 ext_phy_type, ext_phy_config;\n\n\tbnx2x_set_mdio_clk(bp, chip_id, GRCBASE_EMAC0);\n\tbnx2x_set_mdio_clk(bp, chip_id, GRCBASE_EMAC1);\n\tDP(NETIF_MSG_LINK, \"Begin common phy init\\n\");\n\tif (CHIP_IS_E3(bp)) {\n\t\t \n\t\tval = REG_RD(bp, MISC_REG_GEN_PURP_HWG);\n\t\tREG_WR(bp, MISC_REG_GEN_PURP_HWG, val | 1);\n\t}\n\t \n\tphy_ver = REG_RD(bp, shmem_base_path[0] +\n\t\t\t offsetof(struct shmem_region,\n\t\t\t\t  port_mb[PORT_0].ext_phy_fw_version));\n\tif (phy_ver) {\n\t\tDP(NETIF_MSG_LINK, \"Not doing common init; phy ver is 0x%x\\n\",\n\t\t\t       phy_ver);\n\t\treturn 0;\n\t}\n\n\t \n\tfor (phy_index = EXT_PHY1; phy_index < MAX_PHYS;\n\t      phy_index++) {\n\t\text_phy_config = bnx2x_get_ext_phy_config(bp,\n\t\t\t\t\t\t\t  shmem_base_path[0],\n\t\t\t\t\t\t\t  phy_index, 0);\n\t\text_phy_type = XGXS_EXT_PHY_TYPE(ext_phy_config);\n\t\trc |= bnx2x_ext_phy_common_init(bp, shmem_base_path,\n\t\t\t\t\t\tshmem2_base_path,\n\t\t\t\t\t\tphy_index, ext_phy_type,\n\t\t\t\t\t\tchip_id);\n\t}\n\treturn rc;\n}\n\nstatic void bnx2x_check_over_curr(struct link_params *params,\n\t\t\t\t  struct link_vars *vars)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu32 cfg_pin;\n\tu8 port = params->port;\n\tu32 pin_val;\n\n\tcfg_pin = (REG_RD(bp, params->shmem_base +\n\t\t\t  offsetof(struct shmem_region,\n\t\t\t       dev_info.port_hw_config[port].e3_cmn_pin_cfg1)) &\n\t\t   PORT_HW_CFG_E3_OVER_CURRENT_MASK) >>\n\t\tPORT_HW_CFG_E3_OVER_CURRENT_SHIFT;\n\n\t \n\tif (bnx2x_get_cfg_pin(bp, cfg_pin, &pin_val) != 0)\n\t\treturn;\n\n\tif (!pin_val) {\n\t\tif ((vars->phy_flags & PHY_OVER_CURRENT_FLAG) == 0) {\n\t\t\tnetdev_err(bp->dev, \"Error:  Power fault on Port %d has\"\n\t\t\t\t\t    \" been detected and the power to \"\n\t\t\t\t\t    \"that SFP+ module has been removed\"\n\t\t\t\t\t    \" to prevent failure of the card.\"\n\t\t\t\t\t    \" Please remove the SFP+ module and\"\n\t\t\t\t\t    \" restart the system to clear this\"\n\t\t\t\t\t    \" error.\\n\",\n\t\t\t params->port);\n\t\t\tvars->phy_flags |= PHY_OVER_CURRENT_FLAG;\n\t\t\tbnx2x_warpcore_power_module(params, 0);\n\t\t}\n\t} else\n\t\tvars->phy_flags &= ~PHY_OVER_CURRENT_FLAG;\n}\n\n \nstatic u8 bnx2x_analyze_link_error(struct link_params *params,\n\t\t\t\t    struct link_vars *vars, u32 status,\n\t\t\t\t    u32 phy_flag, u32 link_flag, u8 notify)\n{\n\tstruct bnx2x *bp = params->bp;\n\t \n\tu8 led_mode;\n\tu32 old_status = (vars->phy_flags & phy_flag) ? 1 : 0;\n\n\tif ((status ^ old_status) == 0)\n\t\treturn 0;\n\n\t \n\tswitch (phy_flag) {\n\tcase PHY_HALF_OPEN_CONN_FLAG:\n\t\tDP(NETIF_MSG_LINK, \"Analyze Remote Fault\\n\");\n\t\tbreak;\n\tcase PHY_SFP_TX_FAULT_FLAG:\n\t\tDP(NETIF_MSG_LINK, \"Analyze TX Fault\\n\");\n\t\tbreak;\n\tdefault:\n\t\tDP(NETIF_MSG_LINK, \"Analyze UNKNOWN\\n\");\n\t}\n\tDP(NETIF_MSG_LINK, \"Link changed:[%x %x]->%x\\n\", vars->link_up,\n\t   old_status, status);\n\n\t \n\tif ((vars->phy_flags & PHY_PHYSICAL_LINK_FLAG) == 0)\n\t\treturn 1;\n\n\t \n\tif (status) {\n\t\tvars->link_status &= ~LINK_STATUS_LINK_UP;\n\t\tvars->link_status |= link_flag;\n\t\tvars->link_up = 0;\n\t\tvars->phy_flags |= phy_flag;\n\n\t\t \n\t\tREG_WR(bp, NIG_REG_EGRESS_DRAIN0_MODE + params->port*4, 1);\n\t\t \n\t\tled_mode = LED_MODE_OFF;\n\t} else {\n\t\tvars->link_status |= LINK_STATUS_LINK_UP;\n\t\tvars->link_status &= ~link_flag;\n\t\tvars->link_up = 1;\n\t\tvars->phy_flags &= ~phy_flag;\n\t\tled_mode = LED_MODE_OPER;\n\n\t\t \n\t\tREG_WR(bp, NIG_REG_EGRESS_DRAIN0_MODE + params->port*4, 0);\n\t}\n\tbnx2x_sync_link(params, vars);\n\t \n\tbnx2x_set_led(params, vars, led_mode, SPEED_10000);\n\n\t \n\tbnx2x_update_mng(params, vars->link_status);\n\n\t \n\tvars->periodic_flags |= PERIODIC_FLAGS_LINK_EVENT;\n\tif (notify)\n\t\tbnx2x_notify_link_changed(bp);\n\n\treturn 1;\n}\n\n \nstatic int bnx2x_check_half_open_conn(struct link_params *params,\n\t\t\t\t      struct link_vars *vars,\n\t\t\t\t      u8 notify)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu32 lss_status = 0;\n\tu32 mac_base;\n\t \n\tif (((vars->phy_flags & PHY_PHYSICAL_LINK_FLAG) == 0) ||\n\t    (REG_RD(bp, NIG_REG_EGRESS_EMAC0_PORT + params->port*4)))\n\t\treturn 0;\n\n\tif (CHIP_IS_E3(bp) &&\n\t    (REG_RD(bp, MISC_REG_RESET_REG_2) &\n\t      (MISC_REGISTERS_RESET_REG_2_XMAC))) {\n\t\t \n\t\t \n\t\tmac_base = (params->port) ? GRCBASE_XMAC1 : GRCBASE_XMAC0;\n\n\t\t \n\t\tREG_WR(bp, mac_base + XMAC_REG_CLEAR_RX_LSS_STATUS, 0);\n\t\tREG_WR(bp, mac_base + XMAC_REG_CLEAR_RX_LSS_STATUS,\n\t\t       XMAC_CLEAR_RX_LSS_STATUS_REG_CLEAR_LOCAL_FAULT_STATUS |\n\t\t       XMAC_CLEAR_RX_LSS_STATUS_REG_CLEAR_REMOTE_FAULT_STATUS);\n\t\tif (REG_RD(bp, mac_base + XMAC_REG_RX_LSS_STATUS))\n\t\t\tlss_status = 1;\n\n\t\tbnx2x_analyze_link_error(params, vars, lss_status,\n\t\t\t\t\t PHY_HALF_OPEN_CONN_FLAG,\n\t\t\t\t\t LINK_STATUS_NONE, notify);\n\t} else if (REG_RD(bp, MISC_REG_RESET_REG_2) &\n\t\t   (MISC_REGISTERS_RESET_REG_2_RST_BMAC0 << params->port)) {\n\t\t \n\t\tu32 lss_status_reg;\n\t\tu32 wb_data[2];\n\t\tmac_base = params->port ? NIG_REG_INGRESS_BMAC1_MEM :\n\t\t\tNIG_REG_INGRESS_BMAC0_MEM;\n\t\t \n\t\tif (CHIP_IS_E2(bp))\n\t\t\tlss_status_reg = BIGMAC2_REGISTER_RX_LSS_STAT;\n\t\telse\n\t\t\tlss_status_reg = BIGMAC_REGISTER_RX_LSS_STATUS;\n\n\t\tREG_RD_DMAE(bp, mac_base + lss_status_reg, wb_data, 2);\n\t\tlss_status = (wb_data[0] > 0);\n\n\t\tbnx2x_analyze_link_error(params, vars, lss_status,\n\t\t\t\t\t PHY_HALF_OPEN_CONN_FLAG,\n\t\t\t\t\t LINK_STATUS_NONE, notify);\n\t}\n\treturn 0;\n}\nstatic void bnx2x_sfp_tx_fault_detection(struct bnx2x_phy *phy,\n\t\t\t\t\t struct link_params *params,\n\t\t\t\t\t struct link_vars *vars)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu32 cfg_pin, value = 0;\n\tu8 led_change, port = params->port;\n\n\t \n\tcfg_pin = (REG_RD(bp, params->shmem_base + offsetof(struct shmem_region,\n\t\t\t  dev_info.port_hw_config[port].e3_cmn_pin_cfg)) &\n\t\t   PORT_HW_CFG_E3_TX_FAULT_MASK) >>\n\t\t  PORT_HW_CFG_E3_TX_FAULT_SHIFT;\n\n\tif (bnx2x_get_cfg_pin(bp, cfg_pin, &value)) {\n\t\tDP(NETIF_MSG_LINK, \"Failed to read pin 0x%02x\\n\", cfg_pin);\n\t\treturn;\n\t}\n\n\tled_change = bnx2x_analyze_link_error(params, vars, value,\n\t\t\t\t\t      PHY_SFP_TX_FAULT_FLAG,\n\t\t\t\t\t      LINK_STATUS_SFP_TX_FAULT, 1);\n\n\tif (led_change) {\n\t\t \n\t\tu8 led_mode;\n\n\t\tif (vars->phy_flags & PHY_SFP_TX_FAULT_FLAG) {\n\t\t\tled_mode = MISC_REGISTERS_GPIO_HIGH;\n\t\t\tvars->link_status |= LINK_STATUS_SFP_TX_FAULT;\n\t\t} else {\n\t\t\tled_mode = MISC_REGISTERS_GPIO_LOW;\n\t\t\tvars->link_status &= ~LINK_STATUS_SFP_TX_FAULT;\n\t\t}\n\n\t\t \n\t\tif (!(phy->flags & FLAGS_SFP_NOT_APPROVED)) {\n\t\t\tDP(NETIF_MSG_LINK, \"Change TX_Fault LED: ->%x\\n\",\n\t\t\t   led_mode);\n\t\t\tbnx2x_set_e3_module_fault_led(params, led_mode);\n\t\t}\n\t}\n}\nstatic void bnx2x_kr2_recovery(struct link_params *params,\n\t\t\t       struct link_vars *vars,\n\t\t\t       struct bnx2x_phy *phy)\n{\n\tstruct bnx2x *bp = params->bp;\n\tDP(NETIF_MSG_LINK, \"KR2 recovery\\n\");\n\tbnx2x_warpcore_enable_AN_KR2(phy, params, vars);\n\tbnx2x_warpcore_restart_AN_KR(phy, params);\n}\n\nstatic void bnx2x_check_kr2_wa(struct link_params *params,\n\t\t\t       struct link_vars *vars,\n\t\t\t       struct bnx2x_phy *phy)\n{\n\tstruct bnx2x *bp = params->bp;\n\tu16 base_page, next_page, not_kr2_device, lane;\n\tint sigdet;\n\n\t \n\tif (vars->check_kr2_recovery_cnt > 0) {\n\t\tvars->check_kr2_recovery_cnt--;\n\t\treturn;\n\t}\n\n\tsigdet = bnx2x_warpcore_get_sigdet(phy, params);\n\tif (!sigdet) {\n\t\tif (!(params->link_attr_sync & LINK_ATTR_SYNC_KR2_ENABLE)) {\n\t\t\tbnx2x_kr2_recovery(params, vars, phy);\n\t\t\tDP(NETIF_MSG_LINK, \"No sigdet\\n\");\n\t\t}\n\t\treturn;\n\t}\n\n\tlane = bnx2x_get_warpcore_lane(phy, params);\n\tCL22_WR_OVER_CL45(bp, phy, MDIO_REG_BANK_AER_BLOCK,\n\t\t\t  MDIO_AER_BLOCK_AER_REG, lane);\n\tbnx2x_cl45_read(bp, phy, MDIO_AN_DEVAD,\n\t\t\tMDIO_AN_REG_LP_AUTO_NEG, &base_page);\n\tbnx2x_cl45_read(bp, phy, MDIO_AN_DEVAD,\n\t\t\tMDIO_AN_REG_LP_AUTO_NEG2, &next_page);\n\tbnx2x_set_aer_mmd(params, phy);\n\n\t \n\tif (base_page == 0) {\n\t\tif (!(params->link_attr_sync & LINK_ATTR_SYNC_KR2_ENABLE)) {\n\t\t\tbnx2x_kr2_recovery(params, vars, phy);\n\t\t\tDP(NETIF_MSG_LINK, \"No BP\\n\");\n\t\t}\n\t\treturn;\n\t}\n\n\t \n\tnot_kr2_device = (((base_page & 0x8000) == 0) ||\n\t\t\t  (((base_page & 0x8000) &&\n\t\t\t    ((next_page & 0xe0) == 0x20))));\n\n\t \n\tif (!(params->link_attr_sync & LINK_ATTR_SYNC_KR2_ENABLE)) {\n\t\tif (!not_kr2_device) {\n\t\t\tDP(NETIF_MSG_LINK, \"BP=0x%x, NP=0x%x\\n\", base_page,\n\t\t\t   next_page);\n\t\t\tbnx2x_kr2_recovery(params, vars, phy);\n\t\t}\n\t\treturn;\n\t}\n\t \n\tif (not_kr2_device) {\n\t\t \n\t\tDP(NETIF_MSG_LINK, \"BP=0x%x, NP=0x%x\\n\", base_page, next_page);\n\t\tbnx2x_disable_kr2(params, vars, phy);\n\t\t \n\t\tbnx2x_warpcore_restart_AN_KR(phy, params);\n\t\treturn;\n\t}\n}\n\nvoid bnx2x_period_func(struct link_params *params, struct link_vars *vars)\n{\n\tu16 phy_idx;\n\tstruct bnx2x *bp = params->bp;\n\tfor (phy_idx = INT_PHY; phy_idx < MAX_PHYS; phy_idx++) {\n\t\tif (params->phy[phy_idx].flags & FLAGS_TX_ERROR_CHECK) {\n\t\t\tbnx2x_set_aer_mmd(params, &params->phy[phy_idx]);\n\t\t\tif (bnx2x_check_half_open_conn(params, vars, 1) !=\n\t\t\t    0)\n\t\t\t\tDP(NETIF_MSG_LINK, \"Fault detection failed\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (CHIP_IS_E3(bp)) {\n\t\tstruct bnx2x_phy *phy = &params->phy[INT_PHY];\n\t\tbnx2x_set_aer_mmd(params, phy);\n\t\tif (((phy->req_line_speed == SPEED_AUTO_NEG) &&\n\t\t     (phy->speed_cap_mask &\n\t\t      PORT_HW_CFG_SPEED_CAPABILITY_D0_20G)) ||\n\t\t    (phy->req_line_speed == SPEED_20000))\n\t\t\tbnx2x_check_kr2_wa(params, vars, phy);\n\t\tbnx2x_check_over_curr(params, vars);\n\t\tif (vars->rx_tx_asic_rst)\n\t\t\tbnx2x_warpcore_config_runtime(phy, params, vars);\n\n\t\tif ((REG_RD(bp, params->shmem_base +\n\t\t\t    offsetof(struct shmem_region, dev_info.\n\t\t\t\tport_hw_config[params->port].default_cfg))\n\t\t    & PORT_HW_CFG_NET_SERDES_IF_MASK) ==\n\t\t    PORT_HW_CFG_NET_SERDES_IF_SFI) {\n\t\t\tif (bnx2x_is_sfp_module_plugged(phy, params)) {\n\t\t\t\tbnx2x_sfp_tx_fault_detection(phy, params, vars);\n\t\t\t} else if (vars->link_status &\n\t\t\t\tLINK_STATUS_SFP_TX_FAULT) {\n\t\t\t\t \n\t\t\t\tvars->link_status &= ~LINK_STATUS_SFP_TX_FAULT;\n\t\t\t\tvars->phy_flags &= ~PHY_SFP_TX_FAULT_FLAG;\n\t\t\t\t \n\t\t\t\tbnx2x_update_mng(params, vars->link_status);\n\t\t\t}\n\t\t}\n\t}\n}\n\nu8 bnx2x_fan_failure_det_req(struct bnx2x *bp,\n\t\t\t     u32 shmem_base,\n\t\t\t     u32 shmem2_base,\n\t\t\t     u8 port)\n{\n\tu8 phy_index, fan_failure_det_req = 0;\n\tstruct bnx2x_phy phy;\n\tfor (phy_index = EXT_PHY1; phy_index < MAX_PHYS;\n\t      phy_index++) {\n\t\tif (bnx2x_populate_phy(bp, phy_index, shmem_base, shmem2_base,\n\t\t\t\t       port, &phy)\n\t\t    != 0) {\n\t\t\tDP(NETIF_MSG_LINK, \"populate phy failed\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tfan_failure_det_req |= (phy.flags &\n\t\t\t\t\tFLAGS_FAN_FAILURE_DET_REQ);\n\t}\n\treturn fan_failure_det_req;\n}\n\nvoid bnx2x_hw_reset_phy(struct link_params *params)\n{\n\tu8 phy_index;\n\tstruct bnx2x *bp = params->bp;\n\tbnx2x_update_mng(params, 0);\n\tbnx2x_bits_dis(bp, NIG_REG_MASK_INTERRUPT_PORT0 + params->port*4,\n\t\t       (NIG_MASK_XGXS0_LINK_STATUS |\n\t\t\tNIG_MASK_XGXS0_LINK10G |\n\t\t\tNIG_MASK_SERDES0_LINK_STATUS |\n\t\t\tNIG_MASK_MI_INT));\n\n\tfor (phy_index = INT_PHY; phy_index < MAX_PHYS;\n\t      phy_index++) {\n\t\tif (params->phy[phy_index].hw_reset) {\n\t\t\tparams->phy[phy_index].hw_reset(\n\t\t\t\t&params->phy[phy_index],\n\t\t\t\tparams);\n\t\t\tparams->phy[phy_index] = phy_null;\n\t\t}\n\t}\n}\n\nvoid bnx2x_init_mod_abs_int(struct bnx2x *bp, struct link_vars *vars,\n\t\t\t    u32 chip_id, u32 shmem_base, u32 shmem2_base,\n\t\t\t    u8 port)\n{\n\tu8 gpio_num = 0xff, gpio_port = 0xff, phy_index;\n\tu32 val;\n\tu32 offset, aeu_mask, swap_val, swap_override, sync_offset;\n\tif (CHIP_IS_E3(bp)) {\n\t\tif (bnx2x_get_mod_abs_int_cfg(bp, chip_id,\n\t\t\t\t\t      shmem_base,\n\t\t\t\t\t      port,\n\t\t\t\t\t      &gpio_num,\n\t\t\t\t\t      &gpio_port) != 0)\n\t\t\treturn;\n\t} else {\n\t\tstruct bnx2x_phy phy;\n\t\tfor (phy_index = EXT_PHY1; phy_index < MAX_PHYS;\n\t\t      phy_index++) {\n\t\t\tif (bnx2x_populate_phy(bp, phy_index, shmem_base,\n\t\t\t\t\t       shmem2_base, port, &phy)\n\t\t\t    != 0) {\n\t\t\t\tDP(NETIF_MSG_LINK, \"populate phy failed\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (phy.type == PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8726) {\n\t\t\t\tgpio_num = MISC_REGISTERS_GPIO_3;\n\t\t\t\tgpio_port = port;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (gpio_num == 0xff)\n\t\treturn;\n\n\t \n\tbnx2x_set_gpio(bp, gpio_num, MISC_REGISTERS_GPIO_INPUT_HI_Z, gpio_port);\n\n\tswap_val = REG_RD(bp, NIG_REG_PORT_SWAP);\n\tswap_override = REG_RD(bp, NIG_REG_STRAP_OVERRIDE);\n\tgpio_port ^= (swap_val && swap_override);\n\n\tvars->aeu_int_mask = AEU_INPUTS_ATTN_BITS_GPIO0_FUNCTION_0 <<\n\t\t(gpio_num + (gpio_port << 2));\n\n\tsync_offset = shmem_base +\n\t\toffsetof(struct shmem_region,\n\t\t\t dev_info.port_hw_config[port].aeu_int_mask);\n\tREG_WR(bp, sync_offset, vars->aeu_int_mask);\n\n\tDP(NETIF_MSG_LINK, \"Setting MOD_ABS (GPIO%d_P%d) AEU to 0x%x\\n\",\n\t\t       gpio_num, gpio_port, vars->aeu_int_mask);\n\n\tif (port == 0)\n\t\toffset = MISC_REG_AEU_ENABLE1_FUNC_0_OUT_0;\n\telse\n\t\toffset = MISC_REG_AEU_ENABLE1_FUNC_1_OUT_0;\n\n\t \n\taeu_mask = REG_RD(bp, offset);\n\taeu_mask |= vars->aeu_int_mask;\n\tREG_WR(bp, offset, aeu_mask);\n\n\t \n\tval = REG_RD(bp, MISC_REG_GPIO_EVENT_EN);\n\tval |= 1 << (gpio_num + (gpio_port << 2));\n\tREG_WR(bp, MISC_REG_GPIO_EVENT_EN, val);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}