{
  "module_name": "bnx2x_vfpf.c",
  "hash_id": "7d687f605421f1af96396aaa4e2d7a9d921dc9729ab5983ba95ed38c04e25a3f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/broadcom/bnx2x/bnx2x_vfpf.c",
  "human_readable_source": " \n\n#include \"bnx2x.h\"\n#include \"bnx2x_cmn.h\"\n#include <linux/crc32.h>\n\nstatic int bnx2x_vfpf_teardown_queue(struct bnx2x *bp, int qidx);\n\n \nstatic void bnx2x_add_tlv(struct bnx2x *bp, void *tlvs_list,\n\t\t\t  u16 offset, u16 type, u16 length)\n{\n\tstruct channel_tlv *tl =\n\t\t(struct channel_tlv *)(tlvs_list + offset);\n\n\ttl->type = type;\n\ttl->length = length;\n}\n\n \nstatic void bnx2x_vfpf_prep(struct bnx2x *bp, struct vfpf_first_tlv *first_tlv,\n\t\t\t    u16 type, u16 length)\n{\n\tmutex_lock(&bp->vf2pf_mutex);\n\n\tDP(BNX2X_MSG_IOV, \"preparing to send %d tlv over vf pf channel\\n\",\n\t   type);\n\n\t \n\tmemset(bp->vf2pf_mbox, 0, sizeof(struct bnx2x_vf_mbx_msg));\n\n\t \n\tbnx2x_add_tlv(bp, &first_tlv->tl, 0, type, length);\n\n\t \n\tfirst_tlv->resp_msg_offset = sizeof(bp->vf2pf_mbox->req);\n}\n\n \nstatic void bnx2x_vfpf_finalize(struct bnx2x *bp,\n\t\t\t\tstruct vfpf_first_tlv *first_tlv)\n{\n\tDP(BNX2X_MSG_IOV, \"done sending [%d] tlv over vf pf channel\\n\",\n\t   first_tlv->tl.type);\n\n\tmutex_unlock(&bp->vf2pf_mutex);\n}\n\n \nstatic void *bnx2x_search_tlv_list(struct bnx2x *bp, void *tlvs_list,\n\t\t\t\t   enum channel_tlvs req_tlv)\n{\n\tstruct channel_tlv *tlv = (struct channel_tlv *)tlvs_list;\n\n\tdo {\n\t\tif (tlv->type == req_tlv)\n\t\t\treturn tlv;\n\n\t\tif (!tlv->length) {\n\t\t\tBNX2X_ERR(\"Found TLV with length 0\\n\");\n\t\t\treturn NULL;\n\t\t}\n\n\t\ttlvs_list += tlv->length;\n\t\ttlv = (struct channel_tlv *)tlvs_list;\n\t} while (tlv->type != CHANNEL_TLV_LIST_END);\n\n\tDP(BNX2X_MSG_IOV, \"TLV list does not contain %d TLV\\n\", req_tlv);\n\n\treturn NULL;\n}\n\n \nstatic void bnx2x_dp_tlv_list(struct bnx2x *bp, void *tlvs_list)\n{\n\tint i = 1;\n\tstruct channel_tlv *tlv = (struct channel_tlv *)tlvs_list;\n\n\twhile (tlv->type != CHANNEL_TLV_LIST_END) {\n\t\t \n\t\tDP(BNX2X_MSG_IOV, \"TLV number %d: type %d, length %d\\n\", i,\n\t\t   tlv->type, tlv->length);\n\n\t\t \n\t\ttlvs_list += tlv->length;\n\n\t\t \n\t\ttlv = (struct channel_tlv *)tlvs_list;\n\n\t\ti++;\n\n\t\t \n\t\tif (i > MAX_TLVS_IN_LIST) {\n\t\t\tWARN(true, \"corrupt tlvs\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t \n\tDP(BNX2X_MSG_IOV, \"TLV number %d: type %d, length %d\\n\", i,\n\t   tlv->type, tlv->length);\n}\n\n \nbool bnx2x_tlv_supported(u16 tlvtype)\n{\n\treturn CHANNEL_TLV_NONE < tlvtype && tlvtype < CHANNEL_TLV_MAX;\n}\n\nstatic inline int bnx2x_pfvf_status_codes(int rc)\n{\n\tswitch (rc) {\n\tcase 0:\n\t\treturn PFVF_STATUS_SUCCESS;\n\tcase -ENOMEM:\n\t\treturn PFVF_STATUS_NO_RESOURCE;\n\tdefault:\n\t\treturn PFVF_STATUS_FAILURE;\n\t}\n}\n\nstatic int bnx2x_send_msg2pf(struct bnx2x *bp, u8 *done, dma_addr_t msg_mapping)\n{\n\tstruct cstorm_vf_zone_data __iomem *zone_data =\n\t\tREG_ADDR(bp, PXP_VF_ADDR_CSDM_GLOBAL_START);\n\tint tout = 100, interval = 100;  \n\n\tif (*done) {\n\t\tBNX2X_ERR(\"done was non zero before message to pf was sent\\n\");\n\t\tWARN_ON(true);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tbnx2x_sample_bulletin(bp);\n\tif (bp->old_bulletin.valid_bitmap & 1 << CHANNEL_DOWN) {\n\t\tDP(BNX2X_MSG_IOV, \"detecting channel down. Aborting message\\n\");\n\t\t*done = PFVF_STATUS_SUCCESS;\n\t\treturn -EINVAL;\n\t}\n\n\t \n\twritel(U64_LO(msg_mapping),\n\t       &zone_data->non_trigger.vf_pf_channel.msg_addr_lo);\n\twritel(U64_HI(msg_mapping),\n\t       &zone_data->non_trigger.vf_pf_channel.msg_addr_hi);\n\n\t \n\twmb();\n\n\t \n\twriteb_relaxed(1, &zone_data->trigger.vf_pf_channel.addr_valid);\n\n\t \n\twhile ((tout >= 0) && (!*done)) {\n\t\tmsleep(interval);\n\t\ttout -= 1;\n\n\t\t \n\t\tDP_CONT(BNX2X_MSG_IOV, \".\");\n\t}\n\n\tif (!*done) {\n\t\tBNX2X_ERR(\"PF response has timed out\\n\");\n\t\treturn -EAGAIN;\n\t}\n\tDP(BNX2X_MSG_SP, \"Got a response from PF\\n\");\n\treturn 0;\n}\n\nstatic int bnx2x_get_vf_id(struct bnx2x *bp, u32 *vf_id)\n{\n\tu32 me_reg;\n\tint tout = 10, interval = 100;  \n\n\tdo {\n\t\t \n\t\tme_reg = readl(bp->doorbells);\n\t\tif (GOOD_ME_REG(me_reg))\n\t\t\tbreak;\n\n\t\tmsleep(interval);\n\n\t\tBNX2X_ERR(\"Invalid ME register value: 0x%08x\\n. Is pf driver up?\",\n\t\t\t  me_reg);\n\t} while (tout-- > 0);\n\n\tif (!GOOD_ME_REG(me_reg)) {\n\t\tBNX2X_ERR(\"Invalid ME register value: 0x%08x\\n\", me_reg);\n\t\treturn -EINVAL;\n\t}\n\n\tDP(BNX2X_MSG_IOV, \"valid ME register value: 0x%08x\\n\", me_reg);\n\n\t*vf_id = (me_reg & ME_REG_VF_NUM_MASK) >> ME_REG_VF_NUM_SHIFT;\n\n\treturn 0;\n}\n\nint bnx2x_vfpf_acquire(struct bnx2x *bp, u8 tx_count, u8 rx_count)\n{\n\tint rc = 0, attempts = 0;\n\tstruct vfpf_acquire_tlv *req = &bp->vf2pf_mbox->req.acquire;\n\tstruct pfvf_acquire_resp_tlv *resp = &bp->vf2pf_mbox->resp.acquire_resp;\n\tstruct vfpf_port_phys_id_resp_tlv *phys_port_resp;\n\tstruct vfpf_fp_hsi_resp_tlv *fp_hsi_resp;\n\tu32 vf_id;\n\tbool resources_acquired = false;\n\n\t \n\tbnx2x_vfpf_prep(bp, &req->first_tlv, CHANNEL_TLV_ACQUIRE, sizeof(*req));\n\n\tif (bnx2x_get_vf_id(bp, &vf_id)) {\n\t\trc = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\treq->vfdev_info.vf_id = vf_id;\n\treq->vfdev_info.vf_os = 0;\n\treq->vfdev_info.fp_hsi_ver = ETH_FP_HSI_VERSION;\n\n\treq->resc_request.num_rxqs = rx_count;\n\treq->resc_request.num_txqs = tx_count;\n\treq->resc_request.num_sbs = bp->igu_sb_cnt;\n\treq->resc_request.num_mac_filters = VF_ACQUIRE_MAC_FILTERS;\n\treq->resc_request.num_mc_filters = VF_ACQUIRE_MC_FILTERS;\n\treq->resc_request.num_vlan_filters = VF_ACQUIRE_VLAN_FILTERS;\n\n\t \n\treq->bulletin_addr = bp->pf2vf_bulletin_mapping;\n\n\t \n\tbnx2x_add_tlv(bp, req, req->first_tlv.tl.length,\n\t\t      CHANNEL_TLV_PHYS_PORT_ID, sizeof(struct channel_tlv));\n\n\t \n\treq->vfdev_info.caps |= VF_CAP_SUPPORT_EXT_BULLETIN;\n\t \n\treq->vfdev_info.caps |= VF_CAP_SUPPORT_VLAN_FILTER;\n\n\t \n\tbnx2x_add_tlv(bp, req,\n\t\t      req->first_tlv.tl.length + sizeof(struct channel_tlv),\n\t\t      CHANNEL_TLV_LIST_END,\n\t\t      sizeof(struct channel_list_end_tlv));\n\n\t \n\tbnx2x_dp_tlv_list(bp, req);\n\n\twhile (!resources_acquired) {\n\t\tDP(BNX2X_MSG_SP, \"attempting to acquire resources\\n\");\n\n\t\t \n\t\trc = bnx2x_send_msg2pf(bp,\n\t\t\t\t       &resp->hdr.status,\n\t\t\t\t       bp->vf2pf_mbox_mapping);\n\n\t\t \n\t\tif (rc)\n\t\t\tgoto out;\n\n\t\t \n\t\tmemcpy(&bp->acquire_resp, resp, sizeof(bp->acquire_resp));\n\n\t\tattempts++;\n\n\t\t \n\t\tif (bp->acquire_resp.hdr.status == PFVF_STATUS_SUCCESS) {\n\t\t\tDP(BNX2X_MSG_SP, \"resources acquired\\n\");\n\t\t\tresources_acquired = true;\n\t\t} else if (bp->acquire_resp.hdr.status ==\n\t\t\t   PFVF_STATUS_NO_RESOURCE &&\n\t\t\t   attempts < VF_ACQUIRE_THRESH) {\n\t\t\tDP(BNX2X_MSG_SP,\n\t\t\t   \"PF unwilling to fulfill resource request. Try PF recommended amount\\n\");\n\n\t\t\t \n\t\t\treq->resc_request.num_txqs =\n\t\t\t\tmin(req->resc_request.num_txqs,\n\t\t\t\t    bp->acquire_resp.resc.num_txqs);\n\t\t\treq->resc_request.num_rxqs =\n\t\t\t\tmin(req->resc_request.num_rxqs,\n\t\t\t\t    bp->acquire_resp.resc.num_rxqs);\n\t\t\treq->resc_request.num_sbs =\n\t\t\t\tmin(req->resc_request.num_sbs,\n\t\t\t\t    bp->acquire_resp.resc.num_sbs);\n\t\t\treq->resc_request.num_mac_filters =\n\t\t\t\tmin(req->resc_request.num_mac_filters,\n\t\t\t\t    bp->acquire_resp.resc.num_mac_filters);\n\t\t\treq->resc_request.num_vlan_filters =\n\t\t\t\tmin(req->resc_request.num_vlan_filters,\n\t\t\t\t    bp->acquire_resp.resc.num_vlan_filters);\n\t\t\treq->resc_request.num_mc_filters =\n\t\t\t\tmin(req->resc_request.num_mc_filters,\n\t\t\t\t    bp->acquire_resp.resc.num_mc_filters);\n\n\t\t\t \n\t\t\tmemset(&bp->vf2pf_mbox->resp, 0,\n\t\t\t       sizeof(union pfvf_tlvs));\n\t\t} else {\n\t\t\t \n\t\t\tfp_hsi_resp = bnx2x_search_tlv_list(bp, resp,\n\t\t\t\t\t\t\t    CHANNEL_TLV_FP_HSI_SUPPORT);\n\t\t\tif (fp_hsi_resp && !fp_hsi_resp->is_supported)\n\t\t\t\tBNX2X_ERR(\"Old hypervisor - doesn't support current fastpath HSI version; Need to downgrade VF driver [or upgrade hypervisor]\\n\");\n\t\t\telse\n\t\t\t\tBNX2X_ERR(\"Failed to get the requested amount of resources: %d. Breaking...\\n\",\n\t\t\t\t\t  bp->acquire_resp.hdr.status);\n\t\t\trc = -EAGAIN;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tphys_port_resp = (struct vfpf_port_phys_id_resp_tlv *)\n\t\t\t bnx2x_search_tlv_list(bp, resp,\n\t\t\t\t\t       CHANNEL_TLV_PHYS_PORT_ID);\n\tif (phys_port_resp) {\n\t\tmemcpy(bp->phys_port_id, phys_port_resp->id, ETH_ALEN);\n\t\tbp->flags |= HAS_PHYS_PORT_ID;\n\t}\n\n\t \n\tfp_hsi_resp = bnx2x_search_tlv_list(bp, resp,\n\t\t\t\t\t    CHANNEL_TLV_FP_HSI_SUPPORT);\n\tif (!fp_hsi_resp && (ETH_FP_HSI_VERSION > ETH_FP_HSI_VER_2)) {\n\t\tBNX2X_ERR(\"Old hypervisor - need to downgrade VF's driver\\n\");\n\n\t\t \n\t\tbnx2x_vfpf_finalize(bp, &req->first_tlv);\n\t\tbnx2x_vfpf_release(bp);\n\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t \n\tbp->common.chip_id |= (bp->acquire_resp.pfdev_info.chip_num & 0xffff);\n\tbp->link_params.chip_id = bp->common.chip_id;\n\tbp->db_size = bp->acquire_resp.pfdev_info.db_size;\n\tbp->common.int_block = INT_BLOCK_IGU;\n\tbp->common.chip_port_mode = CHIP_2_PORT_MODE;\n\tbp->igu_dsb_id = -1;\n\tbp->mf_ov = 0;\n\tbp->mf_mode = 0;\n\tbp->common.flash_size = 0;\n\tbp->flags |=\n\t\tNO_WOL_FLAG | NO_ISCSI_OOO_FLAG | NO_ISCSI_FLAG | NO_FCOE_FLAG;\n\tbp->igu_sb_cnt = bp->acquire_resp.resc.num_sbs;\n\tbp->igu_base_sb = bp->acquire_resp.resc.hw_sbs[0].hw_sb_id;\n\tbp->vlan_credit = bp->acquire_resp.resc.num_vlan_filters;\n\n\tstrscpy(bp->fw_ver, bp->acquire_resp.pfdev_info.fw_ver,\n\t\tsizeof(bp->fw_ver));\n\n\tif (is_valid_ether_addr(bp->acquire_resp.resc.current_mac_addr))\n\t\teth_hw_addr_set(bp->dev,\n\t\t\t\tbp->acquire_resp.resc.current_mac_addr);\n\nout:\n\tbnx2x_vfpf_finalize(bp, &req->first_tlv);\n\treturn rc;\n}\n\nint bnx2x_vfpf_release(struct bnx2x *bp)\n{\n\tstruct vfpf_release_tlv *req = &bp->vf2pf_mbox->req.release;\n\tstruct pfvf_general_resp_tlv *resp = &bp->vf2pf_mbox->resp.general_resp;\n\tu32 rc, vf_id;\n\n\t \n\tbnx2x_vfpf_prep(bp, &req->first_tlv, CHANNEL_TLV_RELEASE, sizeof(*req));\n\n\tif (bnx2x_get_vf_id(bp, &vf_id)) {\n\t\trc = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\treq->vf_id = vf_id;\n\n\t \n\tbnx2x_add_tlv(bp, req, req->first_tlv.tl.length, CHANNEL_TLV_LIST_END,\n\t\t      sizeof(struct channel_list_end_tlv));\n\n\t \n\tbnx2x_dp_tlv_list(bp, req);\n\n\t \n\trc = bnx2x_send_msg2pf(bp, &resp->hdr.status, bp->vf2pf_mbox_mapping);\n\n\tif (rc)\n\t\t \n\t\tgoto out;\n\n\tif (resp->hdr.status == PFVF_STATUS_SUCCESS) {\n\t\t \n\t\tDP(BNX2X_MSG_SP, \"vf released\\n\");\n\t} else {\n\t\t \n\t\tBNX2X_ERR(\"PF failed our release request - are we out of sync? Response status: %d\\n\",\n\t\t\t  resp->hdr.status);\n\t\trc = -EAGAIN;\n\t\tgoto out;\n\t}\nout:\n\tbnx2x_vfpf_finalize(bp, &req->first_tlv);\n\n\treturn rc;\n}\n\n \nint bnx2x_vfpf_init(struct bnx2x *bp)\n{\n\tstruct vfpf_init_tlv *req = &bp->vf2pf_mbox->req.init;\n\tstruct pfvf_general_resp_tlv *resp = &bp->vf2pf_mbox->resp.general_resp;\n\tint rc, i;\n\n\t \n\tbnx2x_vfpf_prep(bp, &req->first_tlv, CHANNEL_TLV_INIT, sizeof(*req));\n\n\t \n\tfor_each_eth_queue(bp, i)\n\t\treq->sb_addr[i] = (dma_addr_t)bnx2x_fp(bp, i,\n\t\t\t\t\t\t       status_blk_mapping);\n\n\t \n\treq->stats_addr = bp->fw_stats_data_mapping +\n\t\t\t  offsetof(struct bnx2x_fw_stats_data, queue_stats);\n\n\treq->stats_stride = sizeof(struct per_queue_stats);\n\n\t \n\tbnx2x_add_tlv(bp, req, req->first_tlv.tl.length, CHANNEL_TLV_LIST_END,\n\t\t      sizeof(struct channel_list_end_tlv));\n\n\t \n\tbnx2x_dp_tlv_list(bp, req);\n\n\trc = bnx2x_send_msg2pf(bp, &resp->hdr.status, bp->vf2pf_mbox_mapping);\n\tif (rc)\n\t\tgoto out;\n\n\tif (resp->hdr.status != PFVF_STATUS_SUCCESS) {\n\t\tBNX2X_ERR(\"INIT VF failed: %d. Breaking...\\n\",\n\t\t\t  resp->hdr.status);\n\t\trc = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\tDP(BNX2X_MSG_SP, \"INIT VF Succeeded\\n\");\nout:\n\tbnx2x_vfpf_finalize(bp, &req->first_tlv);\n\n\treturn rc;\n}\n\n \nvoid bnx2x_vfpf_close_vf(struct bnx2x *bp)\n{\n\tstruct vfpf_close_tlv *req = &bp->vf2pf_mbox->req.close;\n\tstruct pfvf_general_resp_tlv *resp = &bp->vf2pf_mbox->resp.general_resp;\n\tint i, rc;\n\tu32 vf_id;\n\n\t \n\tif (bnx2x_get_vf_id(bp, &vf_id))\n\t\tgoto free_irq;\n\n\t \n\tfor_each_queue(bp, i)\n\t\tbnx2x_vfpf_teardown_queue(bp, i);\n\n\t \n\tbnx2x_vfpf_config_mac(bp, bp->dev->dev_addr, bp->fp->index, false);\n\n\t \n\tbnx2x_vfpf_prep(bp, &req->first_tlv, CHANNEL_TLV_CLOSE, sizeof(*req));\n\n\treq->vf_id = vf_id;\n\n\t \n\tbnx2x_add_tlv(bp, req, req->first_tlv.tl.length, CHANNEL_TLV_LIST_END,\n\t\t      sizeof(struct channel_list_end_tlv));\n\n\t \n\tbnx2x_dp_tlv_list(bp, req);\n\n\trc = bnx2x_send_msg2pf(bp, &resp->hdr.status, bp->vf2pf_mbox_mapping);\n\n\tif (rc)\n\t\tBNX2X_ERR(\"Sending CLOSE failed. rc was: %d\\n\", rc);\n\n\telse if (resp->hdr.status != PFVF_STATUS_SUCCESS)\n\t\tBNX2X_ERR(\"Sending CLOSE failed: pf response was %d\\n\",\n\t\t\t  resp->hdr.status);\n\n\tbnx2x_vfpf_finalize(bp, &req->first_tlv);\n\nfree_irq:\n\tif (!bp->nic_stopped) {\n\t\t \n\t\tbnx2x_netif_stop(bp, 0);\n\t\t \n\t\tbnx2x_del_all_napi(bp);\n\n\t\t \n\t\tbnx2x_free_irq(bp);\n\t\tbp->nic_stopped = true;\n\t}\n}\n\nstatic void bnx2x_leading_vfq_init(struct bnx2x *bp, struct bnx2x_virtf *vf,\n\t\t\t\t   struct bnx2x_vf_queue *q)\n{\n\tu8 cl_id = vfq_cl_id(vf, q);\n\tu8 func_id = FW_VF_HANDLE(vf->abs_vfid);\n\n\t \n\tbnx2x_init_mac_obj(bp, &q->mac_obj,\n\t\t\t   cl_id, q->cid, func_id,\n\t\t\t   bnx2x_vf_sp(bp, vf, mac_rdata),\n\t\t\t   bnx2x_vf_sp_map(bp, vf, mac_rdata),\n\t\t\t   BNX2X_FILTER_MAC_PENDING,\n\t\t\t   &vf->filter_state,\n\t\t\t   BNX2X_OBJ_TYPE_RX_TX,\n\t\t\t   &vf->vf_macs_pool);\n\t \n\tbnx2x_init_vlan_obj(bp, &q->vlan_obj,\n\t\t\t    cl_id, q->cid, func_id,\n\t\t\t    bnx2x_vf_sp(bp, vf, vlan_rdata),\n\t\t\t    bnx2x_vf_sp_map(bp, vf, vlan_rdata),\n\t\t\t    BNX2X_FILTER_VLAN_PENDING,\n\t\t\t    &vf->filter_state,\n\t\t\t    BNX2X_OBJ_TYPE_RX_TX,\n\t\t\t    &vf->vf_vlans_pool);\n\t \n\tbnx2x_init_vlan_mac_obj(bp, &q->vlan_mac_obj,\n\t\t\t\tcl_id, q->cid, func_id,\n\t\t\t\tbnx2x_vf_sp(bp, vf, vlan_mac_rdata),\n\t\t\t\tbnx2x_vf_sp_map(bp, vf, vlan_mac_rdata),\n\t\t\t\tBNX2X_FILTER_VLAN_MAC_PENDING,\n\t\t\t\t&vf->filter_state,\n\t\t\t\tBNX2X_OBJ_TYPE_RX_TX,\n\t\t\t\t&vf->vf_macs_pool,\n\t\t\t\t&vf->vf_vlans_pool);\n\t \n\tbnx2x_init_mcast_obj(bp, &vf->mcast_obj, cl_id,\n\t\t\t     q->cid, func_id, func_id,\n\t\t\t     bnx2x_vf_sp(bp, vf, mcast_rdata),\n\t\t\t     bnx2x_vf_sp_map(bp, vf, mcast_rdata),\n\t\t\t     BNX2X_FILTER_MCAST_PENDING,\n\t\t\t     &vf->filter_state,\n\t\t\t     BNX2X_OBJ_TYPE_RX_TX);\n\n\t \n\tbnx2x_init_rss_config_obj(bp, &vf->rss_conf_obj, cl_id, q->cid,\n\t\t\t\t  func_id, func_id,\n\t\t\t\t  bnx2x_vf_sp(bp, vf, rss_rdata),\n\t\t\t\t  bnx2x_vf_sp_map(bp, vf, rss_rdata),\n\t\t\t\t  BNX2X_FILTER_RSS_CONF_PENDING,\n\t\t\t\t  &vf->filter_state,\n\t\t\t\t  BNX2X_OBJ_TYPE_RX_TX);\n\n\tvf->leading_rss = cl_id;\n\tq->is_leading = true;\n\tq->sp_initialized = true;\n}\n\n \nint bnx2x_vfpf_setup_q(struct bnx2x *bp, struct bnx2x_fastpath *fp,\n\t\t       bool is_leading)\n{\n\tstruct vfpf_setup_q_tlv *req = &bp->vf2pf_mbox->req.setup_q;\n\tstruct pfvf_general_resp_tlv *resp = &bp->vf2pf_mbox->resp.general_resp;\n\tu8 fp_idx = fp->index;\n\tu16 tpa_agg_size = 0, flags = 0;\n\tint rc;\n\n\t \n\tbnx2x_vfpf_prep(bp, &req->first_tlv, CHANNEL_TLV_SETUP_Q, sizeof(*req));\n\n\t \n\tif (fp->mode != TPA_MODE_DISABLED) {\n\t\tflags |= VFPF_QUEUE_FLG_TPA;\n\t\tflags |= VFPF_QUEUE_FLG_TPA_IPV6;\n\t\tif (fp->mode == TPA_MODE_GRO)\n\t\t\tflags |= VFPF_QUEUE_FLG_TPA_GRO;\n\t\ttpa_agg_size = TPA_AGG_SIZE;\n\t}\n\n\tif (is_leading)\n\t\tflags |= VFPF_QUEUE_FLG_LEADING_RSS;\n\n\t \n\tflags |= VFPF_QUEUE_FLG_STATS;\n\tflags |= VFPF_QUEUE_FLG_CACHE_ALIGN;\n\tflags |= VFPF_QUEUE_FLG_VLAN;\n\n\t \n\treq->vf_qid = fp_idx;\n\treq->param_valid = VFPF_RXQ_VALID | VFPF_TXQ_VALID;\n\n\t \n\treq->rxq.rcq_addr = fp->rx_comp_mapping;\n\treq->rxq.rcq_np_addr = fp->rx_comp_mapping + BCM_PAGE_SIZE;\n\treq->rxq.rxq_addr = fp->rx_desc_mapping;\n\treq->rxq.sge_addr = fp->rx_sge_mapping;\n\treq->rxq.vf_sb = fp_idx;\n\treq->rxq.sb_index = HC_INDEX_ETH_RX_CQ_CONS;\n\treq->rxq.hc_rate = bp->rx_ticks ? 1000000/bp->rx_ticks : 0;\n\treq->rxq.mtu = bp->dev->mtu;\n\treq->rxq.buf_sz = fp->rx_buf_size;\n\treq->rxq.sge_buf_sz = BCM_PAGE_SIZE * PAGES_PER_SGE;\n\treq->rxq.tpa_agg_sz = tpa_agg_size;\n\treq->rxq.max_sge_pkt = SGE_PAGE_ALIGN(bp->dev->mtu) >> SGE_PAGE_SHIFT;\n\treq->rxq.max_sge_pkt = ((req->rxq.max_sge_pkt + PAGES_PER_SGE - 1) &\n\t\t\t  (~(PAGES_PER_SGE-1))) >> PAGES_PER_SGE_SHIFT;\n\treq->rxq.flags = flags;\n\treq->rxq.drop_flags = 0;\n\treq->rxq.cache_line_log = BNX2X_RX_ALIGN_SHIFT;\n\treq->rxq.stat_id = -1;  \n\n\t \n\treq->txq.txq_addr = fp->txdata_ptr[FIRST_TX_COS_INDEX]->tx_desc_mapping;\n\treq->txq.vf_sb = fp_idx;\n\treq->txq.sb_index = HC_INDEX_ETH_TX_CQ_CONS_COS0;\n\treq->txq.hc_rate = bp->tx_ticks ? 1000000/bp->tx_ticks : 0;\n\treq->txq.flags = flags;\n\treq->txq.traffic_type = LLFC_TRAFFIC_TYPE_NW;\n\n\t \n\tbnx2x_add_tlv(bp, req, req->first_tlv.tl.length, CHANNEL_TLV_LIST_END,\n\t\t      sizeof(struct channel_list_end_tlv));\n\n\t \n\tbnx2x_dp_tlv_list(bp, req);\n\n\trc = bnx2x_send_msg2pf(bp, &resp->hdr.status, bp->vf2pf_mbox_mapping);\n\tif (rc)\n\t\tBNX2X_ERR(\"Sending SETUP_Q message for queue[%d] failed!\\n\",\n\t\t\t  fp_idx);\n\n\tif (resp->hdr.status != PFVF_STATUS_SUCCESS) {\n\t\tBNX2X_ERR(\"Status of SETUP_Q for queue[%d] is %d\\n\",\n\t\t\t  fp_idx, resp->hdr.status);\n\t\trc = -EINVAL;\n\t}\n\n\tbnx2x_vfpf_finalize(bp, &req->first_tlv);\n\n\treturn rc;\n}\n\nstatic int bnx2x_vfpf_teardown_queue(struct bnx2x *bp, int qidx)\n{\n\tstruct vfpf_q_op_tlv *req = &bp->vf2pf_mbox->req.q_op;\n\tstruct pfvf_general_resp_tlv *resp = &bp->vf2pf_mbox->resp.general_resp;\n\tint rc;\n\n\t \n\tbnx2x_vfpf_prep(bp, &req->first_tlv, CHANNEL_TLV_TEARDOWN_Q,\n\t\t\tsizeof(*req));\n\n\treq->vf_qid = qidx;\n\n\t \n\tbnx2x_add_tlv(bp, req, req->first_tlv.tl.length, CHANNEL_TLV_LIST_END,\n\t\t      sizeof(struct channel_list_end_tlv));\n\n\t \n\tbnx2x_dp_tlv_list(bp, req);\n\n\trc = bnx2x_send_msg2pf(bp, &resp->hdr.status, bp->vf2pf_mbox_mapping);\n\n\tif (rc) {\n\t\tBNX2X_ERR(\"Sending TEARDOWN for queue %d failed: %d\\n\", qidx,\n\t\t\t  rc);\n\t\tgoto out;\n\t}\n\n\t \n\tif (resp->hdr.status != PFVF_STATUS_SUCCESS) {\n\t\tBNX2X_ERR(\"TEARDOWN for queue %d failed: %d\\n\", qidx,\n\t\t\t  resp->hdr.status);\n\t\trc = -EINVAL;\n\t}\n\nout:\n\tbnx2x_vfpf_finalize(bp, &req->first_tlv);\n\n\treturn rc;\n}\n\n \nint bnx2x_vfpf_config_mac(struct bnx2x *bp, const u8 *addr, u8 vf_qid, bool set)\n{\n\tstruct vfpf_set_q_filters_tlv *req = &bp->vf2pf_mbox->req.set_q_filters;\n\tstruct pfvf_general_resp_tlv *resp = &bp->vf2pf_mbox->resp.general_resp;\n\tstruct pf_vf_bulletin_content bulletin = bp->pf2vf_bulletin->content;\n\tint rc = 0;\n\n\t \n\tbnx2x_vfpf_prep(bp, &req->first_tlv, CHANNEL_TLV_SET_Q_FILTERS,\n\t\t\tsizeof(*req));\n\n\treq->flags = VFPF_SET_Q_FILTERS_MAC_VLAN_CHANGED;\n\treq->vf_qid = vf_qid;\n\treq->n_mac_vlan_filters = 1;\n\n\treq->filters[0].flags = VFPF_Q_FILTER_DEST_MAC_VALID;\n\tif (set)\n\t\treq->filters[0].flags |= VFPF_Q_FILTER_SET;\n\n\t \n\tbnx2x_sample_bulletin(bp);\n\n\t \n\tmemcpy(req->filters[0].mac, addr, ETH_ALEN);\n\n\t \n\tbnx2x_add_tlv(bp, req, req->first_tlv.tl.length, CHANNEL_TLV_LIST_END,\n\t\t      sizeof(struct channel_list_end_tlv));\n\n\t \n\tbnx2x_dp_tlv_list(bp, req);\n\n\t \n\trc = bnx2x_send_msg2pf(bp, &resp->hdr.status, bp->vf2pf_mbox_mapping);\n\tif (rc) {\n\t\tBNX2X_ERR(\"failed to send message to pf. rc was %d\\n\", rc);\n\t\tgoto out;\n\t}\n\n\t \n\twhile (resp->hdr.status == PFVF_STATUS_FAILURE) {\n\t\tDP(BNX2X_MSG_IOV,\n\t\t   \"vfpf SET MAC failed. Check bulletin board for new posts\\n\");\n\n\t\t \n\t\teth_hw_addr_set(bp->dev, bulletin.mac);\n\n\t\t \n\t\tif (bnx2x_sample_bulletin(bp) == PFVF_BULLETIN_UPDATED) {\n\t\t\t \n\t\t\tmemcpy(req->filters[0].mac, bp->dev->dev_addr,\n\t\t\t       ETH_ALEN);\n\n\t\t\t \n\t\t\trc = bnx2x_send_msg2pf(bp, &resp->hdr.status,\n\t\t\t\t\t       bp->vf2pf_mbox_mapping);\n\t\t} else {\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (resp->hdr.status != PFVF_STATUS_SUCCESS) {\n\t\tBNX2X_ERR(\"vfpf SET MAC failed: %d\\n\", resp->hdr.status);\n\t\trc = -EINVAL;\n\t}\nout:\n\tbnx2x_vfpf_finalize(bp, &req->first_tlv);\n\n\treturn rc;\n}\n\n \nint bnx2x_vfpf_config_rss(struct bnx2x *bp,\n\t\t\t  struct bnx2x_config_rss_params *params)\n{\n\tstruct pfvf_general_resp_tlv *resp = &bp->vf2pf_mbox->resp.general_resp;\n\tstruct vfpf_rss_tlv *req = &bp->vf2pf_mbox->req.update_rss;\n\tint rc = 0;\n\n\t \n\tbnx2x_vfpf_prep(bp, &req->first_tlv, CHANNEL_TLV_UPDATE_RSS,\n\t\t\tsizeof(*req));\n\n\t \n\tbnx2x_add_tlv(bp, req, req->first_tlv.tl.length, CHANNEL_TLV_LIST_END,\n\t\t      sizeof(struct channel_list_end_tlv));\n\n\tmemcpy(req->ind_table, params->ind_table, T_ETH_INDIRECTION_TABLE_SIZE);\n\tmemcpy(req->rss_key, params->rss_key, sizeof(params->rss_key));\n\treq->ind_table_size = T_ETH_INDIRECTION_TABLE_SIZE;\n\treq->rss_key_size = T_ETH_RSS_KEY;\n\treq->rss_result_mask = params->rss_result_mask;\n\n\t \n\tif (params->rss_flags & (1 << BNX2X_RSS_MODE_DISABLED))\n\t\treq->rss_flags |= VFPF_RSS_MODE_DISABLED;\n\tif (params->rss_flags & (1 << BNX2X_RSS_MODE_REGULAR))\n\t\treq->rss_flags |= VFPF_RSS_MODE_REGULAR;\n\tif (params->rss_flags & (1 << BNX2X_RSS_SET_SRCH))\n\t\treq->rss_flags |= VFPF_RSS_SET_SRCH;\n\tif (params->rss_flags & (1 << BNX2X_RSS_IPV4))\n\t\treq->rss_flags |= VFPF_RSS_IPV4;\n\tif (params->rss_flags & (1 << BNX2X_RSS_IPV4_TCP))\n\t\treq->rss_flags |= VFPF_RSS_IPV4_TCP;\n\tif (params->rss_flags & (1 << BNX2X_RSS_IPV4_UDP))\n\t\treq->rss_flags |= VFPF_RSS_IPV4_UDP;\n\tif (params->rss_flags & (1 << BNX2X_RSS_IPV6))\n\t\treq->rss_flags |= VFPF_RSS_IPV6;\n\tif (params->rss_flags & (1 << BNX2X_RSS_IPV6_TCP))\n\t\treq->rss_flags |= VFPF_RSS_IPV6_TCP;\n\tif (params->rss_flags & (1 << BNX2X_RSS_IPV6_UDP))\n\t\treq->rss_flags |= VFPF_RSS_IPV6_UDP;\n\n\tDP(BNX2X_MSG_IOV, \"rss flags %x\\n\", req->rss_flags);\n\n\t \n\tbnx2x_dp_tlv_list(bp, req);\n\n\t \n\trc = bnx2x_send_msg2pf(bp, &resp->hdr.status, bp->vf2pf_mbox_mapping);\n\tif (rc) {\n\t\tBNX2X_ERR(\"failed to send message to pf. rc was %d\\n\", rc);\n\t\tgoto out;\n\t}\n\n\tif (resp->hdr.status != PFVF_STATUS_SUCCESS) {\n\t\t \n\t\tDP(BNX2X_MSG_IOV,\n\t\t   \"Failed to send rss message to PF over VF-PF channel [%d]\\n\",\n\t\t   resp->hdr.status);\n\t}\nout:\n\tbnx2x_vfpf_finalize(bp, &req->first_tlv);\n\n\treturn rc;\n}\n\nint bnx2x_vfpf_set_mcast(struct net_device *dev)\n{\n\tstruct bnx2x *bp = netdev_priv(dev);\n\tstruct vfpf_set_q_filters_tlv *req = &bp->vf2pf_mbox->req.set_q_filters;\n\tstruct pfvf_general_resp_tlv *resp = &bp->vf2pf_mbox->resp.general_resp;\n\tint rc = 0, i = 0;\n\tstruct netdev_hw_addr *ha;\n\n\tif (bp->state != BNX2X_STATE_OPEN) {\n\t\tDP(NETIF_MSG_IFUP, \"state is %x, returning\\n\", bp->state);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tbnx2x_vfpf_prep(bp, &req->first_tlv, CHANNEL_TLV_SET_Q_FILTERS,\n\t\t\tsizeof(*req));\n\n\t \n\tDP(NETIF_MSG_IFUP, \"dev->flags = %x\\n\", dev->flags);\n\n\t \n\tif (netdev_mc_count(dev) > PFVF_MAX_MULTICAST_PER_VF) {\n\t\tDP(NETIF_MSG_IFUP,\n\t\t   \"VF supports not more than %d multicast MAC addresses\\n\",\n\t\t   PFVF_MAX_MULTICAST_PER_VF);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tnetdev_for_each_mc_addr(ha, dev) {\n\t\tDP(NETIF_MSG_IFUP, \"Adding mcast MAC: %pM\\n\",\n\t\t   bnx2x_mc_addr(ha));\n\t\tmemcpy(req->multicast[i], bnx2x_mc_addr(ha), ETH_ALEN);\n\t\ti++;\n\t}\n\n\treq->n_multicast = i;\n\treq->flags |= VFPF_SET_Q_FILTERS_MULTICAST_CHANGED;\n\treq->vf_qid = 0;\n\n\t \n\tbnx2x_add_tlv(bp, req, req->first_tlv.tl.length, CHANNEL_TLV_LIST_END,\n\t\t      sizeof(struct channel_list_end_tlv));\n\n\t \n\tbnx2x_dp_tlv_list(bp, req);\n\trc = bnx2x_send_msg2pf(bp, &resp->hdr.status, bp->vf2pf_mbox_mapping);\n\tif (rc) {\n\t\tBNX2X_ERR(\"Sending a message failed: %d\\n\", rc);\n\t\tgoto out;\n\t}\n\n\tif (resp->hdr.status != PFVF_STATUS_SUCCESS) {\n\t\tBNX2X_ERR(\"Set Rx mode/multicast failed: %d\\n\",\n\t\t\t  resp->hdr.status);\n\t\trc = -EINVAL;\n\t}\nout:\n\tbnx2x_vfpf_finalize(bp, &req->first_tlv);\n\n\treturn rc;\n}\n\n \nint bnx2x_vfpf_update_vlan(struct bnx2x *bp, u16 vid, u8 vf_qid, bool add)\n{\n\tstruct vfpf_set_q_filters_tlv *req = &bp->vf2pf_mbox->req.set_q_filters;\n\tstruct pfvf_general_resp_tlv *resp = &bp->vf2pf_mbox->resp.general_resp;\n\tint rc = 0;\n\n\tif (!(bp->acquire_resp.pfdev_info.pf_cap & PFVF_CAP_VLAN_FILTER)) {\n\t\tDP(BNX2X_MSG_IOV, \"HV does not support vlan filtering\\n\");\n\t\treturn 0;\n\t}\n\n\t \n\tbnx2x_vfpf_prep(bp, &req->first_tlv, CHANNEL_TLV_SET_Q_FILTERS,\n\t\t\tsizeof(*req));\n\n\treq->flags = VFPF_SET_Q_FILTERS_MAC_VLAN_CHANGED;\n\treq->vf_qid = vf_qid;\n\treq->n_mac_vlan_filters = 1;\n\n\treq->filters[0].flags = VFPF_Q_FILTER_VLAN_TAG_VALID;\n\n\tif (add)\n\t\treq->filters[0].flags |= VFPF_Q_FILTER_SET;\n\n\t \n\tbnx2x_sample_bulletin(bp);\n\n\tif (bp->shadow_bulletin.content.valid_bitmap & 1 << VLAN_VALID) {\n\t\tBNX2X_ERR(\"Hypervisor will decline the request, avoiding\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\treq->filters[0].vlan_tag = vid;\n\n\t \n\tbnx2x_add_tlv(bp, req, req->first_tlv.tl.length, CHANNEL_TLV_LIST_END,\n\t\t      sizeof(struct channel_list_end_tlv));\n\n\t \n\tbnx2x_dp_tlv_list(bp, req);\n\n\t \n\trc = bnx2x_send_msg2pf(bp, &resp->hdr.status, bp->vf2pf_mbox_mapping);\n\tif (rc) {\n\t\tBNX2X_ERR(\"failed to send message to pf. rc was %d\\n\", rc);\n\t\tgoto out;\n\t}\n\n\tif (resp->hdr.status != PFVF_STATUS_SUCCESS) {\n\t\tBNX2X_ERR(\"vfpf %s VLAN %d failed\\n\", add ? \"add\" : \"del\",\n\t\t\t  vid);\n\t\trc = -EINVAL;\n\t}\nout:\n\tbnx2x_vfpf_finalize(bp, &req->first_tlv);\n\n\treturn rc;\n}\n\nint bnx2x_vfpf_storm_rx_mode(struct bnx2x *bp)\n{\n\tint mode = bp->rx_mode;\n\tstruct vfpf_set_q_filters_tlv *req = &bp->vf2pf_mbox->req.set_q_filters;\n\tstruct pfvf_general_resp_tlv *resp = &bp->vf2pf_mbox->resp.general_resp;\n\tint rc;\n\n\t \n\tbnx2x_vfpf_prep(bp, &req->first_tlv, CHANNEL_TLV_SET_Q_FILTERS,\n\t\t\tsizeof(*req));\n\n\tDP(NETIF_MSG_IFUP, \"Rx mode is %d\\n\", mode);\n\n\t \n\tif (mode  == BNX2X_RX_MODE_NONE) {\n\t\treq->rx_mask = VFPF_RX_MASK_ACCEPT_NONE;\n\t} else {\n\t\t \n\t\treq->rx_mask = VFPF_RX_MASK_ACCEPT_MATCHED_MULTICAST;\n\t\treq->rx_mask |= VFPF_RX_MASK_ACCEPT_MATCHED_UNICAST;\n\t\treq->rx_mask |= VFPF_RX_MASK_ACCEPT_BROADCAST;\n\t\tif (mode == BNX2X_RX_MODE_PROMISC)\n\t\t\treq->rx_mask |= VFPF_RX_MASK_ACCEPT_ANY_VLAN;\n\t}\n\n\tif (bp->accept_any_vlan)\n\t\treq->rx_mask |= VFPF_RX_MASK_ACCEPT_ANY_VLAN;\n\n\treq->flags |= VFPF_SET_Q_FILTERS_RX_MASK_CHANGED;\n\treq->vf_qid = 0;\n\n\t \n\tbnx2x_add_tlv(bp, req, req->first_tlv.tl.length, CHANNEL_TLV_LIST_END,\n\t\t      sizeof(struct channel_list_end_tlv));\n\n\t \n\tbnx2x_dp_tlv_list(bp, req);\n\n\trc = bnx2x_send_msg2pf(bp, &resp->hdr.status, bp->vf2pf_mbox_mapping);\n\tif (rc)\n\t\tBNX2X_ERR(\"Sending a message failed: %d\\n\", rc);\n\n\tif (resp->hdr.status != PFVF_STATUS_SUCCESS) {\n\t\tBNX2X_ERR(\"Set Rx mode failed: %d\\n\", resp->hdr.status);\n\t\trc = -EINVAL;\n\t}\n\n\tbnx2x_vfpf_finalize(bp, &req->first_tlv);\n\n\treturn rc;\n}\n\n \nstatic void storm_memset_vf_mbx_ack(struct bnx2x *bp, u16 abs_fid)\n{\n\tu32 addr = BAR_CSTRORM_INTMEM +\n\t\t   CSTORM_VF_PF_CHANNEL_STATE_OFFSET(abs_fid);\n\n\tREG_WR8(bp, addr, VF_PF_CHANNEL_STATE_READY);\n}\n\nstatic void storm_memset_vf_mbx_valid(struct bnx2x *bp, u16 abs_fid)\n{\n\tu32 addr = BAR_CSTRORM_INTMEM +\n\t\t   CSTORM_VF_PF_CHANNEL_VALID_OFFSET(abs_fid);\n\n\tREG_WR8(bp, addr, 1);\n}\n\n \nvoid bnx2x_vf_enable_mbx(struct bnx2x *bp, u8 abs_vfid)\n{\n\tbnx2x_vf_flr_clnup_epilog(bp, abs_vfid);\n\n\t \n\tstorm_memset_vf_mbx_ack(bp, abs_vfid);\n\tstorm_memset_vf_mbx_valid(bp, abs_vfid);\n\n\t \n\tbnx2x_vf_enable_access(bp, abs_vfid);\n}\n\n \nstatic int bnx2x_copy32_vf_dmae(struct bnx2x *bp, u8 from_vf,\n\t\t\t\tdma_addr_t pf_addr, u8 vfid, u32 vf_addr_hi,\n\t\t\t\tu32 vf_addr_lo, u32 len32)\n{\n\tstruct dmae_command dmae;\n\n\tif (CHIP_IS_E1x(bp)) {\n\t\tBNX2X_ERR(\"Chip revision does not support VFs\\n\");\n\t\treturn DMAE_NOT_RDY;\n\t}\n\n\tif (!bp->dmae_ready) {\n\t\tBNX2X_ERR(\"DMAE is not ready, can not copy\\n\");\n\t\treturn DMAE_NOT_RDY;\n\t}\n\n\t \n\tbnx2x_prep_dmae_with_comp(bp, &dmae, DMAE_SRC_PCI, DMAE_DST_PCI);\n\n\tif (from_vf) {\n\t\tdmae.opcode_iov = (vfid << DMAE_COMMAND_SRC_VFID_SHIFT) |\n\t\t\t(DMAE_SRC_VF << DMAE_COMMAND_SRC_VFPF_SHIFT) |\n\t\t\t(DMAE_DST_PF << DMAE_COMMAND_DST_VFPF_SHIFT);\n\n\t\tdmae.opcode |= (DMAE_C_DST << DMAE_COMMAND_C_FUNC_SHIFT);\n\n\t\tdmae.src_addr_lo = vf_addr_lo;\n\t\tdmae.src_addr_hi = vf_addr_hi;\n\t\tdmae.dst_addr_lo = U64_LO(pf_addr);\n\t\tdmae.dst_addr_hi = U64_HI(pf_addr);\n\t} else {\n\t\tdmae.opcode_iov = (vfid << DMAE_COMMAND_DST_VFID_SHIFT) |\n\t\t\t(DMAE_DST_VF << DMAE_COMMAND_DST_VFPF_SHIFT) |\n\t\t\t(DMAE_SRC_PF << DMAE_COMMAND_SRC_VFPF_SHIFT);\n\n\t\tdmae.opcode |= (DMAE_C_SRC << DMAE_COMMAND_C_FUNC_SHIFT);\n\n\t\tdmae.src_addr_lo = U64_LO(pf_addr);\n\t\tdmae.src_addr_hi = U64_HI(pf_addr);\n\t\tdmae.dst_addr_lo = vf_addr_lo;\n\t\tdmae.dst_addr_hi = vf_addr_hi;\n\t}\n\tdmae.len = len32;\n\n\t \n\treturn bnx2x_issue_dmae_with_comp(bp, &dmae, bnx2x_sp(bp, wb_comp));\n}\n\nstatic void bnx2x_vf_mbx_resp_single_tlv(struct bnx2x *bp,\n\t\t\t\t\t struct bnx2x_virtf *vf)\n{\n\tstruct bnx2x_vf_mbx *mbx = BP_VF_MBX(bp, vf->index);\n\tu16 length, type;\n\n\t \n\ttype = mbx->first_tlv.tl.type;\n\tlength = type == CHANNEL_TLV_ACQUIRE ?\n\t\tsizeof(struct pfvf_acquire_resp_tlv) :\n\t\tsizeof(struct pfvf_general_resp_tlv);\n\tbnx2x_add_tlv(bp, &mbx->msg->resp, 0, type, length);\n\tbnx2x_add_tlv(bp, &mbx->msg->resp, length, CHANNEL_TLV_LIST_END,\n\t\t      sizeof(struct channel_list_end_tlv));\n}\n\nstatic void bnx2x_vf_mbx_resp_send_msg(struct bnx2x *bp,\n\t\t\t\t       struct bnx2x_virtf *vf,\n\t\t\t\t       int vf_rc)\n{\n\tstruct bnx2x_vf_mbx *mbx = BP_VF_MBX(bp, vf->index);\n\tstruct pfvf_general_resp_tlv *resp = &mbx->msg->resp.general_resp;\n\tdma_addr_t pf_addr;\n\tu64 vf_addr;\n\tint rc;\n\n\tbnx2x_dp_tlv_list(bp, resp);\n\tDP(BNX2X_MSG_IOV, \"mailbox vf address hi 0x%x, lo 0x%x, offset 0x%x\\n\",\n\t   mbx->vf_addr_hi, mbx->vf_addr_lo, mbx->first_tlv.resp_msg_offset);\n\n\tresp->hdr.status = bnx2x_pfvf_status_codes(vf_rc);\n\n\t \n\tvf_addr = HILO_U64(mbx->vf_addr_hi, mbx->vf_addr_lo) +\n\t\t  mbx->first_tlv.resp_msg_offset;\n\tpf_addr = mbx->msg_mapping +\n\t\t  offsetof(struct bnx2x_vf_mbx_msg, resp);\n\n\t \n\tvf_addr += sizeof(u64);\n\tpf_addr += sizeof(u64);\n\trc = bnx2x_copy32_vf_dmae(bp, false, pf_addr, vf->abs_vfid,\n\t\t\t\t  U64_HI(vf_addr),\n\t\t\t\t  U64_LO(vf_addr),\n\t\t\t\t  (sizeof(union pfvf_tlvs) - sizeof(u64))/4);\n\tif (rc) {\n\t\tBNX2X_ERR(\"Failed to copy response body to VF %d\\n\",\n\t\t\t  vf->abs_vfid);\n\t\tgoto mbx_error;\n\t}\n\tvf_addr -= sizeof(u64);\n\tpf_addr -= sizeof(u64);\n\n\t \n\tstorm_memset_vf_mbx_ack(bp, vf->abs_vfid);\n\n\t \n\trc = bnx2x_copy32_vf_dmae(bp, false, pf_addr, vf->abs_vfid,\n\t\t\t\t  U64_HI(vf_addr),\n\t\t\t\t  U64_LO(vf_addr),\n\t\t\t\t  sizeof(u64)/4);\n\n\t \n\tbnx2x_unlock_vf_pf_channel(bp, vf, mbx->first_tlv.tl.type);\n\n\tif (rc) {\n\t\tBNX2X_ERR(\"Failed to copy response status to VF %d\\n\",\n\t\t\t  vf->abs_vfid);\n\t\tgoto mbx_error;\n\t}\n\treturn;\n\nmbx_error:\n\tbnx2x_vf_release(bp, vf);\n}\n\nstatic void bnx2x_vf_mbx_resp(struct bnx2x *bp,\n\t\t\t      struct bnx2x_virtf *vf,\n\t\t\t      int rc)\n{\n\tbnx2x_vf_mbx_resp_single_tlv(bp, vf);\n\tbnx2x_vf_mbx_resp_send_msg(bp, vf, rc);\n}\n\nstatic void bnx2x_vf_mbx_resp_phys_port(struct bnx2x *bp,\n\t\t\t\t\tstruct bnx2x_virtf *vf,\n\t\t\t\t\tvoid *buffer,\n\t\t\t\t\tu16 *offset)\n{\n\tstruct vfpf_port_phys_id_resp_tlv *port_id;\n\n\tif (!(bp->flags & HAS_PHYS_PORT_ID))\n\t\treturn;\n\n\tbnx2x_add_tlv(bp, buffer, *offset, CHANNEL_TLV_PHYS_PORT_ID,\n\t\t      sizeof(struct vfpf_port_phys_id_resp_tlv));\n\n\tport_id = (struct vfpf_port_phys_id_resp_tlv *)\n\t\t  (((u8 *)buffer) + *offset);\n\tmemcpy(port_id->id, bp->phys_port_id, ETH_ALEN);\n\n\t \n\t*offset += sizeof(struct vfpf_port_phys_id_resp_tlv);\n}\n\nstatic void bnx2x_vf_mbx_resp_fp_hsi_ver(struct bnx2x *bp,\n\t\t\t\t\t struct bnx2x_virtf *vf,\n\t\t\t\t\t void *buffer,\n\t\t\t\t\t u16 *offset)\n{\n\tstruct vfpf_fp_hsi_resp_tlv *fp_hsi;\n\n\tbnx2x_add_tlv(bp, buffer, *offset, CHANNEL_TLV_FP_HSI_SUPPORT,\n\t\t      sizeof(struct vfpf_fp_hsi_resp_tlv));\n\n\tfp_hsi = (struct vfpf_fp_hsi_resp_tlv *)\n\t\t (((u8 *)buffer) + *offset);\n\tfp_hsi->is_supported = (vf->fp_hsi > ETH_FP_HSI_VERSION) ? 0 : 1;\n\n\t \n\t*offset += sizeof(struct vfpf_fp_hsi_resp_tlv);\n}\n\nstatic void bnx2x_vf_mbx_acquire_resp(struct bnx2x *bp, struct bnx2x_virtf *vf,\n\t\t\t\t      struct bnx2x_vf_mbx *mbx, int vfop_status)\n{\n\tint i;\n\tstruct pfvf_acquire_resp_tlv *resp = &mbx->msg->resp.acquire_resp;\n\tstruct pf_vf_resc *resc = &resp->resc;\n\tu8 status = bnx2x_pfvf_status_codes(vfop_status);\n\tu16 length;\n\n\tmemset(resp, 0, sizeof(*resp));\n\n\t \n\tresp->pfdev_info.chip_num = bp->common.chip_id;\n\tresp->pfdev_info.db_size = bp->db_size;\n\tresp->pfdev_info.indices_per_sb = HC_SB_MAX_INDICES_E2;\n\tresp->pfdev_info.pf_cap = (PFVF_CAP_RSS |\n\t\t\t\t   PFVF_CAP_TPA |\n\t\t\t\t   PFVF_CAP_TPA_UPDATE |\n\t\t\t\t   PFVF_CAP_VLAN_FILTER);\n\tbnx2x_fill_fw_str(bp, resp->pfdev_info.fw_ver,\n\t\t\t  sizeof(resp->pfdev_info.fw_ver));\n\n\tif (status == PFVF_STATUS_NO_RESOURCE ||\n\t    status == PFVF_STATUS_SUCCESS) {\n\t\t \n\t\tresc->num_rxqs = vf_rxq_count(vf) ? :\n\t\t\tbnx2x_vf_max_queue_cnt(bp, vf);\n\t\tresc->num_txqs = vf_txq_count(vf) ? :\n\t\t\tbnx2x_vf_max_queue_cnt(bp, vf);\n\t\tresc->num_sbs = vf_sb_count(vf);\n\t\tresc->num_mac_filters = vf_mac_rules_cnt(vf);\n\t\tresc->num_vlan_filters = vf_vlan_rules_cnt(vf);\n\t\tresc->num_mc_filters = 0;\n\n\t\tif (status == PFVF_STATUS_SUCCESS) {\n\t\t\t \n\t\t\tstruct pf_vf_bulletin_content *bulletin =\n\t\t\t\tBP_VF_BULLETIN(bp, vf->index);\n\n\t\t\tfor_each_vfq(vf, i)\n\t\t\t\tresc->hw_qid[i] =\n\t\t\t\t\tvfq_qzone_id(vf, vfq_get(vf, i));\n\n\t\t\tfor_each_vf_sb(vf, i) {\n\t\t\t\tresc->hw_sbs[i].hw_sb_id = vf_igu_sb(vf, i);\n\t\t\t\tresc->hw_sbs[i].sb_qid = vf_hc_qzone(vf, i);\n\t\t\t}\n\n\t\t\t \n\t\t\tif (bulletin->valid_bitmap & 1 << MAC_ADDR_VALID) {\n\t\t\t\tmemcpy(resc->current_mac_addr, bulletin->mac,\n\t\t\t\t       ETH_ALEN);\n\t\t\t}\n\t\t}\n\t}\n\n\tDP(BNX2X_MSG_IOV, \"VF[%d] ACQUIRE_RESPONSE: pfdev_info- chip_num=0x%x, db_size=%d, idx_per_sb=%d, pf_cap=0x%x\\n\"\n\t   \"resources- n_rxq-%d, n_txq-%d, n_sbs-%d, n_macs-%d, n_vlans-%d, n_mcs-%d, fw_ver: '%s'\\n\",\n\t   vf->abs_vfid,\n\t   resp->pfdev_info.chip_num,\n\t   resp->pfdev_info.db_size,\n\t   resp->pfdev_info.indices_per_sb,\n\t   resp->pfdev_info.pf_cap,\n\t   resc->num_rxqs,\n\t   resc->num_txqs,\n\t   resc->num_sbs,\n\t   resc->num_mac_filters,\n\t   resc->num_vlan_filters,\n\t   resc->num_mc_filters,\n\t   resp->pfdev_info.fw_ver);\n\n\tDP_CONT(BNX2X_MSG_IOV, \"hw_qids- [ \");\n\tfor (i = 0; i < vf_rxq_count(vf); i++)\n\t\tDP_CONT(BNX2X_MSG_IOV, \"%d \", resc->hw_qid[i]);\n\tDP_CONT(BNX2X_MSG_IOV, \"], sb_info- [ \");\n\tfor (i = 0; i < vf_sb_count(vf); i++)\n\t\tDP_CONT(BNX2X_MSG_IOV, \"%d:%d \",\n\t\t\tresc->hw_sbs[i].hw_sb_id,\n\t\t\tresc->hw_sbs[i].sb_qid);\n\tDP_CONT(BNX2X_MSG_IOV, \"]\\n\");\n\n\t \n\tlength = sizeof(struct pfvf_acquire_resp_tlv);\n\tbnx2x_add_tlv(bp, &mbx->msg->resp, 0, CHANNEL_TLV_ACQUIRE, length);\n\n\t \n\tif (bnx2x_search_tlv_list(bp, &mbx->msg->req,\n\t\t\t\t  CHANNEL_TLV_PHYS_PORT_ID))\n\t\tbnx2x_vf_mbx_resp_phys_port(bp, vf, &mbx->msg->resp, &length);\n\n\t \n\tbnx2x_vf_mbx_resp_fp_hsi_ver(bp, vf, &mbx->msg->resp, &length);\n\n\tbnx2x_add_tlv(bp, &mbx->msg->resp, length, CHANNEL_TLV_LIST_END,\n\t\t      sizeof(struct channel_list_end_tlv));\n\n\t \n\tbnx2x_vf_mbx_resp_send_msg(bp, vf, vfop_status);\n}\n\nstatic bool bnx2x_vf_mbx_is_windows_vm(struct bnx2x *bp,\n\t\t\t\t       struct vfpf_acquire_tlv *acquire)\n{\n\t \n\tif (!acquire->bulletin_addr ||\n\t    acquire->resc_request.num_mc_filters == 32 ||\n\t    ((acquire->vfdev_info.vf_os & VF_OS_MASK) ==\n\t     VF_OS_WINDOWS))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic int bnx2x_vf_mbx_acquire_chk_dorq(struct bnx2x *bp,\n\t\t\t\t\t struct bnx2x_virtf *vf,\n\t\t\t\t\t struct bnx2x_vf_mbx *mbx)\n{\n\t \n\tif (bnx2x_search_tlv_list(bp, &mbx->msg->req,\n\t\t\t\t  CHANNEL_TLV_PHYS_PORT_ID))\n\t\treturn 0;\n\n\t \n\tif (bnx2x_vf_mbx_is_windows_vm(bp, &mbx->msg->req.acquire))\n\t\treturn 0;\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic void bnx2x_vf_mbx_acquire(struct bnx2x *bp, struct bnx2x_virtf *vf,\n\t\t\t\t struct bnx2x_vf_mbx *mbx)\n{\n\tint rc;\n\tstruct vfpf_acquire_tlv *acquire = &mbx->msg->req.acquire;\n\n\t \n\tDP(BNX2X_MSG_IOV,\n\t   \"VF[%d] ACQUIRE: vfdev_info- vf_id %d, vf_os %d resources- n_rxq-%d, n_txq-%d, n_sbs-%d, n_macs-%d, n_vlans-%d, n_mcs-%d\\n\",\n\t   vf->abs_vfid, acquire->vfdev_info.vf_id, acquire->vfdev_info.vf_os,\n\t   acquire->resc_request.num_rxqs, acquire->resc_request.num_txqs,\n\t   acquire->resc_request.num_sbs, acquire->resc_request.num_mac_filters,\n\t   acquire->resc_request.num_vlan_filters,\n\t   acquire->resc_request.num_mc_filters);\n\n\t \n\trc = bnx2x_vf_mbx_acquire_chk_dorq(bp, vf, mbx);\n\tif (rc) {\n\t\tDP(BNX2X_MSG_IOV,\n\t\t   \"VF [%d] - Can't support acquire request due to doorbell mismatch. Please update VM driver\\n\",\n\t\t   vf->abs_vfid);\n\t\tgoto out;\n\t}\n\n\t \n\tif (bnx2x_vf_mbx_is_windows_vm(bp, &mbx->msg->req.acquire))\n\t\tvf->fp_hsi = acquire->vfdev_info.fp_hsi_ver;\n\telse\n\t\tvf->fp_hsi = max_t(u8, acquire->vfdev_info.fp_hsi_ver,\n\t\t\t\t   ETH_FP_HSI_VER_2);\n\tif (vf->fp_hsi > ETH_FP_HSI_VERSION) {\n\t\tDP(BNX2X_MSG_IOV,\n\t\t   \"VF [%d] - Can't support acquire request since VF requests a FW version which is too new [%02x > %02x]\\n\",\n\t\t   vf->abs_vfid, acquire->vfdev_info.fp_hsi_ver,\n\t\t   ETH_FP_HSI_VERSION);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t \n\trc = bnx2x_vf_acquire(bp, vf, &acquire->resc_request);\n\n\t \n\tvf->bulletin_map = acquire->bulletin_addr;\n\tif (acquire->vfdev_info.caps & VF_CAP_SUPPORT_EXT_BULLETIN) {\n\t\tDP(BNX2X_MSG_IOV, \"VF[%d] supports long bulletin boards\\n\",\n\t\t   vf->abs_vfid);\n\t\tvf->cfg_flags |= VF_CFG_EXT_BULLETIN;\n\t} else {\n\t\tvf->cfg_flags &= ~VF_CFG_EXT_BULLETIN;\n\t}\n\n\tif (acquire->vfdev_info.caps & VF_CAP_SUPPORT_VLAN_FILTER) {\n\t\tDP(BNX2X_MSG_IOV, \"VF[%d] supports vlan filtering\\n\",\n\t\t   vf->abs_vfid);\n\t\tvf->cfg_flags |= VF_CFG_VLAN_FILTER;\n\t} else {\n\t\tvf->cfg_flags &= ~VF_CFG_VLAN_FILTER;\n\t}\n\nout:\n\t \n\tbnx2x_vf_mbx_acquire_resp(bp, vf, mbx, rc);\n}\n\nstatic void bnx2x_vf_mbx_init_vf(struct bnx2x *bp, struct bnx2x_virtf *vf,\n\t\t\t      struct bnx2x_vf_mbx *mbx)\n{\n\tstruct vfpf_init_tlv *init = &mbx->msg->req.init;\n\tint rc;\n\n\t \n\tvf->fw_stat_map = init->stats_addr;\n\tvf->stats_stride = init->stats_stride;\n\trc = bnx2x_vf_init(bp, vf, (dma_addr_t *)init->sb_addr);\n\n\t \n\tif (init->flags & VFPF_INIT_FLG_STATS_COALESCE)\n\t\tvf->cfg_flags |= VF_CFG_STATS_COALESCE;\n\n\t \n\tif (vf->cfg_flags & VF_CFG_EXT_BULLETIN)\n\t\tbnx2x_iov_link_update_vf(bp, vf->index);\n\n\t \n\tbnx2x_vf_mbx_resp(bp, vf, rc);\n}\n\n \nstatic void bnx2x_vf_mbx_set_q_flags(struct bnx2x *bp, u32 mbx_q_flags,\n\t\t\t\t     unsigned long *sp_q_flags)\n{\n\tif (mbx_q_flags & VFPF_QUEUE_FLG_TPA)\n\t\t__set_bit(BNX2X_Q_FLG_TPA, sp_q_flags);\n\tif (mbx_q_flags & VFPF_QUEUE_FLG_TPA_IPV6)\n\t\t__set_bit(BNX2X_Q_FLG_TPA_IPV6, sp_q_flags);\n\tif (mbx_q_flags & VFPF_QUEUE_FLG_TPA_GRO)\n\t\t__set_bit(BNX2X_Q_FLG_TPA_GRO, sp_q_flags);\n\tif (mbx_q_flags & VFPF_QUEUE_FLG_STATS)\n\t\t__set_bit(BNX2X_Q_FLG_STATS, sp_q_flags);\n\tif (mbx_q_flags & VFPF_QUEUE_FLG_VLAN)\n\t\t__set_bit(BNX2X_Q_FLG_VLAN, sp_q_flags);\n\tif (mbx_q_flags & VFPF_QUEUE_FLG_COS)\n\t\t__set_bit(BNX2X_Q_FLG_COS, sp_q_flags);\n\tif (mbx_q_flags & VFPF_QUEUE_FLG_HC)\n\t\t__set_bit(BNX2X_Q_FLG_HC, sp_q_flags);\n\tif (mbx_q_flags & VFPF_QUEUE_FLG_DHC)\n\t\t__set_bit(BNX2X_Q_FLG_DHC, sp_q_flags);\n\tif (mbx_q_flags & VFPF_QUEUE_FLG_LEADING_RSS)\n\t\t__set_bit(BNX2X_Q_FLG_LEADING_RSS, sp_q_flags);\n\n\t \n\tif (IS_MF_SD(bp))\n\t\t__set_bit(BNX2X_Q_FLG_OV, sp_q_flags);\n}\n\nstatic void bnx2x_vf_mbx_setup_q(struct bnx2x *bp, struct bnx2x_virtf *vf,\n\t\t\t\t struct bnx2x_vf_mbx *mbx)\n{\n\tstruct vfpf_setup_q_tlv *setup_q = &mbx->msg->req.setup_q;\n\tstruct bnx2x_vf_queue_construct_params qctor;\n\tint rc = 0;\n\n\t \n\tif (setup_q->vf_qid >= vf_rxq_count(vf)) {\n\t\tBNX2X_ERR(\"vf_qid %d invalid, max queue count is %d\\n\",\n\t\t\t  setup_q->vf_qid, vf_rxq_count(vf));\n\t\trc = -EINVAL;\n\t\tgoto response;\n\t}\n\n\t \n\tif (setup_q->param_valid & (VFPF_RXQ_VALID|VFPF_TXQ_VALID)) {\n\t\tstruct bnx2x_vf_queue *q = vfq_get(vf, setup_q->vf_qid);\n\t\tunsigned long q_type = 0;\n\n\t\tstruct bnx2x_queue_init_params *init_p;\n\t\tstruct bnx2x_queue_setup_params *setup_p;\n\n\t\tif (bnx2x_vfq_is_leading(q))\n\t\t\tbnx2x_leading_vfq_init(bp, vf, q);\n\n\t\t \n\t\tmemset(&qctor, 0 ,\n\t\t       sizeof(struct bnx2x_vf_queue_construct_params));\n\t\tsetup_p = &qctor.prep_qsetup;\n\t\tinit_p =  &qctor.qstate.params.init;\n\n\t\t \n\t\t__set_bit(BNX2X_Q_FLG_ACTIVE, &setup_p->flags);\n\n\t\tif (setup_q->param_valid & VFPF_TXQ_VALID) {\n\t\t\tstruct bnx2x_txq_setup_params *txq_params =\n\t\t\t\t&setup_p->txq_params;\n\n\t\t\t__set_bit(BNX2X_Q_TYPE_HAS_TX, &q_type);\n\n\t\t\t \n\t\t\tq->sb_idx = setup_q->txq.vf_sb;\n\n\t\t\t \n\t\t\tinit_p->tx.hc_rate = setup_q->txq.hc_rate;\n\t\t\tinit_p->tx.sb_cq_index = setup_q->txq.sb_index;\n\n\t\t\tbnx2x_vf_mbx_set_q_flags(bp, setup_q->txq.flags,\n\t\t\t\t\t\t &init_p->tx.flags);\n\n\t\t\t \n\t\t\tbnx2x_vf_mbx_set_q_flags(bp, setup_q->txq.flags,\n\t\t\t\t\t\t &setup_p->flags);\n\n\t\t\t \n\n\t\t\t \n\t\t\ttxq_params->dscr_map = setup_q->txq.txq_addr;\n\t\t\ttxq_params->sb_cq_index = setup_q->txq.sb_index;\n\t\t\ttxq_params->traffic_type = setup_q->txq.traffic_type;\n\n\t\t\tbnx2x_vfop_qctor_dump_tx(bp, vf, init_p, setup_p,\n\t\t\t\t\t\t q->index, q->sb_idx);\n\t\t}\n\n\t\tif (setup_q->param_valid & VFPF_RXQ_VALID) {\n\t\t\tstruct bnx2x_rxq_setup_params *rxq_params =\n\t\t\t\t\t\t\t&setup_p->rxq_params;\n\n\t\t\t__set_bit(BNX2X_Q_TYPE_HAS_RX, &q_type);\n\n\t\t\t \n\t\t\tq->sb_idx = setup_q->rxq.vf_sb;\n\n\t\t\t \n\t\t\tinit_p->rx.hc_rate = setup_q->rxq.hc_rate;\n\t\t\tinit_p->rx.sb_cq_index = setup_q->rxq.sb_index;\n\t\t\tbnx2x_vf_mbx_set_q_flags(bp, setup_q->rxq.flags,\n\t\t\t\t\t\t &init_p->rx.flags);\n\n\t\t\t \n\t\t\tbnx2x_vf_mbx_set_q_flags(bp, setup_q->rxq.flags,\n\t\t\t\t\t\t &setup_p->flags);\n\n\t\t\t \n\t\t\tsetup_p->gen_params.mtu = setup_q->rxq.mtu;\n\n\t\t\t \n\t\t\trxq_params->drop_flags = setup_q->rxq.drop_flags;\n\t\t\trxq_params->dscr_map = setup_q->rxq.rxq_addr;\n\t\t\trxq_params->sge_map = setup_q->rxq.sge_addr;\n\t\t\trxq_params->rcq_map = setup_q->rxq.rcq_addr;\n\t\t\trxq_params->rcq_np_map = setup_q->rxq.rcq_np_addr;\n\t\t\trxq_params->buf_sz = setup_q->rxq.buf_sz;\n\t\t\trxq_params->tpa_agg_sz = setup_q->rxq.tpa_agg_sz;\n\t\t\trxq_params->max_sges_pkt = setup_q->rxq.max_sge_pkt;\n\t\t\trxq_params->sge_buf_sz = setup_q->rxq.sge_buf_sz;\n\t\t\trxq_params->cache_line_log =\n\t\t\t\tsetup_q->rxq.cache_line_log;\n\t\t\trxq_params->sb_cq_index = setup_q->rxq.sb_index;\n\n\t\t\t \n\t\t\tif (bnx2x_vfq_is_leading(q)) {\n\t\t\t\tu8 mcast_id = FW_VF_HANDLE(vf->abs_vfid);\n\n\t\t\t\trxq_params->mcast_engine_id = mcast_id;\n\t\t\t\t__set_bit(BNX2X_Q_FLG_MCAST, &setup_p->flags);\n\t\t\t}\n\n\t\t\tbnx2x_vfop_qctor_dump_rx(bp, vf, init_p, setup_p,\n\t\t\t\t\t\t q->index, q->sb_idx);\n\t\t}\n\t\t \n\t\tbnx2x_vfop_qctor_prep(bp, vf, q, &qctor, q_type);\n\n\t\trc = bnx2x_vf_queue_setup(bp, vf, q->index, &qctor);\n\t\tif (rc)\n\t\t\tgoto response;\n\t}\nresponse:\n\tbnx2x_vf_mbx_resp(bp, vf, rc);\n}\n\nstatic int bnx2x_vf_mbx_macvlan_list(struct bnx2x *bp,\n\t\t\t\t     struct bnx2x_virtf *vf,\n\t\t\t\t     struct vfpf_set_q_filters_tlv *tlv,\n\t\t\t\t     struct bnx2x_vf_mac_vlan_filters **pfl,\n\t\t\t\t     u32 type_flag)\n{\n\tint i, j;\n\tstruct bnx2x_vf_mac_vlan_filters *fl = NULL;\n\n\tfl = kzalloc(struct_size(fl, filters, tlv->n_mac_vlan_filters),\n\t\t     GFP_KERNEL);\n\tif (!fl)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0, j = 0; i < tlv->n_mac_vlan_filters; i++) {\n\t\tstruct vfpf_q_mac_vlan_filter *msg_filter = &tlv->filters[i];\n\n\t\tif ((msg_filter->flags & type_flag) != type_flag)\n\t\t\tcontinue;\n\t\tmemset(&fl->filters[j], 0, sizeof(fl->filters[j]));\n\t\tif (type_flag & VFPF_Q_FILTER_DEST_MAC_VALID) {\n\t\t\tfl->filters[j].mac = msg_filter->mac;\n\t\t\tfl->filters[j].type |= BNX2X_VF_FILTER_MAC;\n\t\t}\n\t\tif (type_flag & VFPF_Q_FILTER_VLAN_TAG_VALID) {\n\t\t\tfl->filters[j].vid = msg_filter->vlan_tag;\n\t\t\tfl->filters[j].type |= BNX2X_VF_FILTER_VLAN;\n\t\t}\n\t\tfl->filters[j].add = !!(msg_filter->flags & VFPF_Q_FILTER_SET);\n\t\tfl->count++;\n\t\tj++;\n\t}\n\tif (!fl->count)\n\t\tkfree(fl);\n\telse\n\t\t*pfl = fl;\n\n\treturn 0;\n}\n\nstatic int bnx2x_vf_filters_contain(struct vfpf_set_q_filters_tlv *filters,\n\t\t\t\t    u32 flags)\n{\n\tint i, cnt = 0;\n\n\tfor (i = 0; i < filters->n_mac_vlan_filters; i++)\n\t\tif  ((filters->filters[i].flags & flags) == flags)\n\t\t\tcnt++;\n\n\treturn cnt;\n}\n\nstatic void bnx2x_vf_mbx_dp_q_filter(struct bnx2x *bp, int msglvl, int idx,\n\t\t\t\t       struct vfpf_q_mac_vlan_filter *filter)\n{\n\tDP(msglvl, \"MAC-VLAN[%d] -- flags=0x%x\\n\", idx, filter->flags);\n\tif (filter->flags & VFPF_Q_FILTER_VLAN_TAG_VALID)\n\t\tDP_CONT(msglvl, \", vlan=%d\", filter->vlan_tag);\n\tif (filter->flags & VFPF_Q_FILTER_DEST_MAC_VALID)\n\t\tDP_CONT(msglvl, \", MAC=%pM\", filter->mac);\n\tDP_CONT(msglvl, \"\\n\");\n}\n\nstatic void bnx2x_vf_mbx_dp_q_filters(struct bnx2x *bp, int msglvl,\n\t\t\t\t       struct vfpf_set_q_filters_tlv *filters)\n{\n\tint i;\n\n\tif (filters->flags & VFPF_SET_Q_FILTERS_MAC_VLAN_CHANGED)\n\t\tfor (i = 0; i < filters->n_mac_vlan_filters; i++)\n\t\t\tbnx2x_vf_mbx_dp_q_filter(bp, msglvl, i,\n\t\t\t\t\t\t &filters->filters[i]);\n\n\tif (filters->flags & VFPF_SET_Q_FILTERS_RX_MASK_CHANGED)\n\t\tDP(msglvl, \"RX-MASK=0x%x\\n\", filters->rx_mask);\n\n\tif (filters->flags & VFPF_SET_Q_FILTERS_MULTICAST_CHANGED)\n\t\tfor (i = 0; i < filters->n_multicast; i++)\n\t\t\tDP(msglvl, \"MULTICAST=%pM\\n\", filters->multicast[i]);\n}\n\n#define VFPF_MAC_FILTER\t\tVFPF_Q_FILTER_DEST_MAC_VALID\n#define VFPF_VLAN_FILTER\tVFPF_Q_FILTER_VLAN_TAG_VALID\n#define VFPF_VLAN_MAC_FILTER\t(VFPF_VLAN_FILTER | VFPF_MAC_FILTER)\n\nstatic int bnx2x_vf_mbx_qfilters(struct bnx2x *bp, struct bnx2x_virtf *vf)\n{\n\tint rc = 0;\n\n\tstruct vfpf_set_q_filters_tlv *msg =\n\t\t&BP_VF_MBX(bp, vf->index)->msg->req.set_q_filters;\n\n\t \n\tif (msg->flags & VFPF_SET_Q_FILTERS_MAC_VLAN_CHANGED) {\n\t\tstruct bnx2x_vf_mac_vlan_filters *fl = NULL;\n\n\t\t \n\t\trc = bnx2x_vf_mbx_macvlan_list(bp, vf, msg, &fl,\n\t\t\t\t\t       VFPF_VLAN_MAC_FILTER);\n\t\tif (rc)\n\t\t\tgoto op_err;\n\n\t\tif (fl) {\n\n\t\t\t \n\t\t\trc = bnx2x_vf_mac_vlan_config_list(bp, vf, fl,\n\t\t\t\t\t\t\t   msg->vf_qid,\n\t\t\t\t\t\t\t   false);\n\t\t\tif (rc)\n\t\t\t\tgoto op_err;\n\t\t}\n\n\t\t \n\t\tfl = NULL;\n\n\t\trc = bnx2x_vf_mbx_macvlan_list(bp, vf, msg, &fl,\n\t\t\t\t\t       VFPF_MAC_FILTER);\n\t\tif (rc)\n\t\t\tgoto op_err;\n\n\t\tif (fl) {\n\t\t\t \n\t\t\trc = bnx2x_vf_mac_vlan_config_list(bp, vf, fl,\n\t\t\t\t\t\t\t   msg->vf_qid,\n\t\t\t\t\t\t\t   false);\n\t\t\tif (rc)\n\t\t\t\tgoto op_err;\n\t\t}\n\n\t\t \n\t\tfl = NULL;\n\n\t\trc = bnx2x_vf_mbx_macvlan_list(bp, vf, msg, &fl,\n\t\t\t\t\t       VFPF_VLAN_FILTER);\n\t\tif (rc)\n\t\t\tgoto op_err;\n\n\t\tif (fl) {\n\t\t\t \n\t\t\trc = bnx2x_vf_mac_vlan_config_list(bp, vf, fl,\n\t\t\t\t\t\t\t   msg->vf_qid,\n\t\t\t\t\t\t\t   false);\n\t\t\tif (rc)\n\t\t\t\tgoto op_err;\n\t\t}\n\n\t}\n\n\tif (msg->flags & VFPF_SET_Q_FILTERS_RX_MASK_CHANGED) {\n\t\tunsigned long accept = 0;\n\t\tstruct pf_vf_bulletin_content *bulletin =\n\t\t\t\t\tBP_VF_BULLETIN(bp, vf->index);\n\n\t\t \n\t\tif (msg->rx_mask !=  VFPF_RX_MASK_ACCEPT_NONE) {\n\t\t\t__set_bit(BNX2X_ACCEPT_UNICAST, &accept);\n\t\t\t__set_bit(BNX2X_ACCEPT_MULTICAST, &accept);\n\t\t\t__set_bit(BNX2X_ACCEPT_BROADCAST, &accept);\n\t\t}\n\n\t\t \n\t\tif (!(bulletin->valid_bitmap & (1 << VLAN_VALID)) &&\n\t\t    (!(vf->cfg_flags & VF_CFG_VLAN_FILTER) ||\n\t\t     msg->rx_mask & VFPF_RX_MASK_ACCEPT_ANY_VLAN))\n\t\t\t__set_bit(BNX2X_ACCEPT_ANY_VLAN, &accept);\n\n\t\t \n\t\trc = bnx2x_vf_rxmode(bp, vf, msg->vf_qid, accept);\n\t\tif (rc)\n\t\t\tgoto op_err;\n\t}\n\n\tif (msg->flags & VFPF_SET_Q_FILTERS_MULTICAST_CHANGED) {\n\t\t \n\t\trc = bnx2x_vf_mcast(bp, vf, msg->multicast,\n\t\t\t\t    msg->n_multicast, false);\n\t\tif (rc)\n\t\t\tgoto op_err;\n\t}\nop_err:\n\tif (rc)\n\t\tBNX2X_ERR(\"QFILTERS[%d:%d] error: rc %d\\n\",\n\t\t\t  vf->abs_vfid, msg->vf_qid, rc);\n\treturn rc;\n}\n\nstatic int bnx2x_filters_validate_mac(struct bnx2x *bp,\n\t\t\t\t      struct bnx2x_virtf *vf,\n\t\t\t\t      struct vfpf_set_q_filters_tlv *filters)\n{\n\tstruct pf_vf_bulletin_content *bulletin = BP_VF_BULLETIN(bp, vf->index);\n\tint rc = 0;\n\n\t \n\tif (bulletin->valid_bitmap & 1 << MAC_ADDR_VALID) {\n\t\tstruct vfpf_q_mac_vlan_filter *filter = NULL;\n\t\tint i;\n\n\t\tfor (i = 0; i < filters->n_mac_vlan_filters; i++) {\n\t\t\tif (!(filters->filters[i].flags &\n\t\t\t      VFPF_Q_FILTER_DEST_MAC_VALID))\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tif (filter) {\n\t\t\t\tBNX2X_ERR(\"VF[%d] requested the addition of multiple macs after set_vf_mac ndo was called [%d filters]\\n\",\n\t\t\t\t\t  vf->abs_vfid,\n\t\t\t\t\t  filters->n_mac_vlan_filters);\n\t\t\t\trc = -EPERM;\n\t\t\t\tgoto response;\n\t\t\t}\n\n\t\t\tfilter = &filters->filters[i];\n\t\t}\n\n\t\t \n\t\tif (filter &&\n\t\t    !ether_addr_equal(filter->mac, bulletin->mac)) {\n\t\t\tBNX2X_ERR(\"VF[%d] requested the addition of a mac address not matching the one configured by set_vf_mac ndo\\n\",\n\t\t\t\t  vf->abs_vfid);\n\n\t\t\trc = -EPERM;\n\t\t\tgoto response;\n\t\t}\n\t}\n\nresponse:\n\treturn rc;\n}\n\nstatic int bnx2x_filters_validate_vlan(struct bnx2x *bp,\n\t\t\t\t       struct bnx2x_virtf *vf,\n\t\t\t\t       struct vfpf_set_q_filters_tlv *filters)\n{\n\tstruct pf_vf_bulletin_content *bulletin = BP_VF_BULLETIN(bp, vf->index);\n\tint rc = 0;\n\n\t \n\tif (bulletin->valid_bitmap & 1 << VLAN_VALID) {\n\t\t \n\n\t\tif (bnx2x_vf_filters_contain(filters,\n\t\t\t\t\t     VFPF_Q_FILTER_VLAN_TAG_VALID)) {\n\t\t\tBNX2X_ERR(\"VF[%d] attempted to configure vlan but one was already set by Hypervisor. Aborting request\\n\",\n\t\t\t\t  vf->abs_vfid);\n\t\t\trc = -EPERM;\n\t\t\tgoto response;\n\t\t}\n\t}\n\n\t \n\tif (filters->vf_qid > vf_rxq_count(vf)) {\n\t\trc = -EPERM;\n\t\tgoto response;\n\t}\n\nresponse:\n\treturn rc;\n}\n\nstatic void bnx2x_vf_mbx_set_q_filters(struct bnx2x *bp,\n\t\t\t\t       struct bnx2x_virtf *vf,\n\t\t\t\t       struct bnx2x_vf_mbx *mbx)\n{\n\tstruct vfpf_set_q_filters_tlv *filters = &mbx->msg->req.set_q_filters;\n\tint rc;\n\n\trc = bnx2x_filters_validate_mac(bp, vf, filters);\n\tif (rc)\n\t\tgoto response;\n\n\trc = bnx2x_filters_validate_vlan(bp, vf, filters);\n\tif (rc)\n\t\tgoto response;\n\n\tDP(BNX2X_MSG_IOV, \"VF[%d] Q_FILTERS: queue[%d]\\n\",\n\t   vf->abs_vfid,\n\t   filters->vf_qid);\n\n\t \n\tbnx2x_vf_mbx_dp_q_filters(bp, BNX2X_MSG_IOV, filters);\n\n\trc = bnx2x_vf_mbx_qfilters(bp, vf);\nresponse:\n\tbnx2x_vf_mbx_resp(bp, vf, rc);\n}\n\nstatic void bnx2x_vf_mbx_teardown_q(struct bnx2x *bp, struct bnx2x_virtf *vf,\n\t\t\t\t    struct bnx2x_vf_mbx *mbx)\n{\n\tint qid = mbx->msg->req.q_op.vf_qid;\n\tint rc;\n\n\tDP(BNX2X_MSG_IOV, \"VF[%d] Q_TEARDOWN: vf_qid=%d\\n\",\n\t   vf->abs_vfid, qid);\n\n\trc = bnx2x_vf_queue_teardown(bp, vf, qid);\n\tbnx2x_vf_mbx_resp(bp, vf, rc);\n}\n\nstatic void bnx2x_vf_mbx_close_vf(struct bnx2x *bp, struct bnx2x_virtf *vf,\n\t\t\t\t  struct bnx2x_vf_mbx *mbx)\n{\n\tint rc;\n\n\tDP(BNX2X_MSG_IOV, \"VF[%d] VF_CLOSE\\n\", vf->abs_vfid);\n\n\trc = bnx2x_vf_close(bp, vf);\n\tbnx2x_vf_mbx_resp(bp, vf, rc);\n}\n\nstatic void bnx2x_vf_mbx_release_vf(struct bnx2x *bp, struct bnx2x_virtf *vf,\n\t\t\t\t    struct bnx2x_vf_mbx *mbx)\n{\n\tint rc;\n\n\tDP(BNX2X_MSG_IOV, \"VF[%d] VF_RELEASE\\n\", vf->abs_vfid);\n\n\trc = bnx2x_vf_free(bp, vf);\n\tbnx2x_vf_mbx_resp(bp, vf, rc);\n}\n\nstatic void bnx2x_vf_mbx_update_rss(struct bnx2x *bp, struct bnx2x_virtf *vf,\n\t\t\t\t    struct bnx2x_vf_mbx *mbx)\n{\n\tstruct bnx2x_config_rss_params rss;\n\tstruct vfpf_rss_tlv *rss_tlv = &mbx->msg->req.update_rss;\n\tint rc = 0;\n\n\tif (rss_tlv->ind_table_size != T_ETH_INDIRECTION_TABLE_SIZE ||\n\t    rss_tlv->rss_key_size != T_ETH_RSS_KEY) {\n\t\tBNX2X_ERR(\"failing rss configuration of vf %d due to size mismatch\\n\",\n\t\t\t  vf->index);\n\t\trc = -EINVAL;\n\t\tgoto mbx_resp;\n\t}\n\n\tmemset(&rss, 0, sizeof(struct bnx2x_config_rss_params));\n\n\t \n\tmemcpy(rss.ind_table, rss_tlv->ind_table,\n\t       T_ETH_INDIRECTION_TABLE_SIZE);\n\tmemcpy(rss.rss_key, rss_tlv->rss_key, sizeof(rss_tlv->rss_key));\n\trss.rss_obj = &vf->rss_conf_obj;\n\trss.rss_result_mask = rss_tlv->rss_result_mask;\n\n\t \n\trss.rss_flags = 0;\n\trss.ramrod_flags = 0;\n\n\tif (rss_tlv->rss_flags & VFPF_RSS_MODE_DISABLED)\n\t\t__set_bit(BNX2X_RSS_MODE_DISABLED, &rss.rss_flags);\n\tif (rss_tlv->rss_flags & VFPF_RSS_MODE_REGULAR)\n\t\t__set_bit(BNX2X_RSS_MODE_REGULAR, &rss.rss_flags);\n\tif (rss_tlv->rss_flags & VFPF_RSS_SET_SRCH)\n\t\t__set_bit(BNX2X_RSS_SET_SRCH, &rss.rss_flags);\n\tif (rss_tlv->rss_flags & VFPF_RSS_IPV4)\n\t\t__set_bit(BNX2X_RSS_IPV4, &rss.rss_flags);\n\tif (rss_tlv->rss_flags & VFPF_RSS_IPV4_TCP)\n\t\t__set_bit(BNX2X_RSS_IPV4_TCP, &rss.rss_flags);\n\tif (rss_tlv->rss_flags & VFPF_RSS_IPV4_UDP)\n\t\t__set_bit(BNX2X_RSS_IPV4_UDP, &rss.rss_flags);\n\tif (rss_tlv->rss_flags & VFPF_RSS_IPV6)\n\t\t__set_bit(BNX2X_RSS_IPV6, &rss.rss_flags);\n\tif (rss_tlv->rss_flags & VFPF_RSS_IPV6_TCP)\n\t\t__set_bit(BNX2X_RSS_IPV6_TCP, &rss.rss_flags);\n\tif (rss_tlv->rss_flags & VFPF_RSS_IPV6_UDP)\n\t\t__set_bit(BNX2X_RSS_IPV6_UDP, &rss.rss_flags);\n\n\tif ((!(rss_tlv->rss_flags & VFPF_RSS_IPV4_TCP) &&\n\t     rss_tlv->rss_flags & VFPF_RSS_IPV4_UDP) ||\n\t    (!(rss_tlv->rss_flags & VFPF_RSS_IPV6_TCP) &&\n\t     rss_tlv->rss_flags & VFPF_RSS_IPV6_UDP)) {\n\t\tBNX2X_ERR(\"about to hit a FW assert. aborting...\\n\");\n\t\trc = -EINVAL;\n\t\tgoto mbx_resp;\n\t}\n\n\trc = bnx2x_vf_rss_update(bp, vf, &rss);\nmbx_resp:\n\tbnx2x_vf_mbx_resp(bp, vf, rc);\n}\n\nstatic int bnx2x_validate_tpa_params(struct bnx2x *bp,\n\t\t\t\t       struct vfpf_tpa_tlv *tpa_tlv)\n{\n\tint rc = 0;\n\n\tif (tpa_tlv->tpa_client_info.max_sges_for_packet >\n\t    U_ETH_MAX_SGES_FOR_PACKET) {\n\t\trc = -EINVAL;\n\t\tBNX2X_ERR(\"TPA update: max_sges received %d, max is %d\\n\",\n\t\t\t  tpa_tlv->tpa_client_info.max_sges_for_packet,\n\t\t\t  U_ETH_MAX_SGES_FOR_PACKET);\n\t}\n\n\tif (tpa_tlv->tpa_client_info.max_tpa_queues > MAX_AGG_QS(bp)) {\n\t\trc = -EINVAL;\n\t\tBNX2X_ERR(\"TPA update: max_tpa_queues received %d, max is %d\\n\",\n\t\t\t  tpa_tlv->tpa_client_info.max_tpa_queues,\n\t\t\t  MAX_AGG_QS(bp));\n\t}\n\n\treturn rc;\n}\n\nstatic void bnx2x_vf_mbx_update_tpa(struct bnx2x *bp, struct bnx2x_virtf *vf,\n\t\t\t\t    struct bnx2x_vf_mbx *mbx)\n{\n\tstruct bnx2x_queue_update_tpa_params vf_op_params;\n\tstruct vfpf_tpa_tlv *tpa_tlv = &mbx->msg->req.update_tpa;\n\tint rc = 0;\n\n\tmemset(&vf_op_params, 0, sizeof(vf_op_params));\n\n\tif (bnx2x_validate_tpa_params(bp, tpa_tlv))\n\t\tgoto mbx_resp;\n\n\tvf_op_params.complete_on_both_clients =\n\t\ttpa_tlv->tpa_client_info.complete_on_both_clients;\n\tvf_op_params.dont_verify_thr =\n\t\ttpa_tlv->tpa_client_info.dont_verify_thr;\n\tvf_op_params.max_agg_sz =\n\t\ttpa_tlv->tpa_client_info.max_agg_size;\n\tvf_op_params.max_sges_pkt =\n\t\ttpa_tlv->tpa_client_info.max_sges_for_packet;\n\tvf_op_params.max_tpa_queues =\n\t\ttpa_tlv->tpa_client_info.max_tpa_queues;\n\tvf_op_params.sge_buff_sz =\n\t\ttpa_tlv->tpa_client_info.sge_buff_size;\n\tvf_op_params.sge_pause_thr_high =\n\t\ttpa_tlv->tpa_client_info.sge_pause_thr_high;\n\tvf_op_params.sge_pause_thr_low =\n\t\ttpa_tlv->tpa_client_info.sge_pause_thr_low;\n\tvf_op_params.tpa_mode =\n\t\ttpa_tlv->tpa_client_info.tpa_mode;\n\tvf_op_params.update_ipv4 =\n\t\ttpa_tlv->tpa_client_info.update_ipv4;\n\tvf_op_params.update_ipv6 =\n\t\ttpa_tlv->tpa_client_info.update_ipv6;\n\n\trc = bnx2x_vf_tpa_update(bp, vf, tpa_tlv, &vf_op_params);\n\nmbx_resp:\n\tbnx2x_vf_mbx_resp(bp, vf, rc);\n}\n\n \nstatic void bnx2x_vf_mbx_request(struct bnx2x *bp, struct bnx2x_virtf *vf,\n\t\t\t\t  struct bnx2x_vf_mbx *mbx)\n{\n\tint i;\n\n\tif (vf->state == VF_LOST) {\n\t\t \n\t\tDP(BNX2X_MSG_IOV,\n\t\t   \"VF 0x%x lost, not handling the request\\n\", vf->abs_vfid);\n\n\t\tstorm_memset_vf_mbx_ack(bp, vf->abs_vfid);\n\t\treturn;\n\t}\n\n\t \n\tif (bnx2x_tlv_supported(mbx->first_tlv.tl.type)) {\n\t\t \n\t\tbnx2x_lock_vf_pf_channel(bp, vf, mbx->first_tlv.tl.type);\n\n\t\t \n\t\tswitch (mbx->first_tlv.tl.type) {\n\t\tcase CHANNEL_TLV_ACQUIRE:\n\t\t\tbnx2x_vf_mbx_acquire(bp, vf, mbx);\n\t\t\treturn;\n\t\tcase CHANNEL_TLV_INIT:\n\t\t\tbnx2x_vf_mbx_init_vf(bp, vf, mbx);\n\t\t\treturn;\n\t\tcase CHANNEL_TLV_SETUP_Q:\n\t\t\tbnx2x_vf_mbx_setup_q(bp, vf, mbx);\n\t\t\treturn;\n\t\tcase CHANNEL_TLV_SET_Q_FILTERS:\n\t\t\tbnx2x_vf_mbx_set_q_filters(bp, vf, mbx);\n\t\t\treturn;\n\t\tcase CHANNEL_TLV_TEARDOWN_Q:\n\t\t\tbnx2x_vf_mbx_teardown_q(bp, vf, mbx);\n\t\t\treturn;\n\t\tcase CHANNEL_TLV_CLOSE:\n\t\t\tbnx2x_vf_mbx_close_vf(bp, vf, mbx);\n\t\t\treturn;\n\t\tcase CHANNEL_TLV_RELEASE:\n\t\t\tbnx2x_vf_mbx_release_vf(bp, vf, mbx);\n\t\t\treturn;\n\t\tcase CHANNEL_TLV_UPDATE_RSS:\n\t\t\tbnx2x_vf_mbx_update_rss(bp, vf, mbx);\n\t\t\treturn;\n\t\tcase CHANNEL_TLV_UPDATE_TPA:\n\t\t\tbnx2x_vf_mbx_update_tpa(bp, vf, mbx);\n\t\t\treturn;\n\t\t}\n\n\t} else {\n\t\t \n\t\tBNX2X_ERR(\"unknown TLV. type %d length %d vf->state was %d. first 20 bytes of mailbox buffer:\\n\",\n\t\t\t  mbx->first_tlv.tl.type, mbx->first_tlv.tl.length,\n\t\t\t  vf->state);\n\t\tfor (i = 0; i < 20; i++)\n\t\t\tDP_CONT(BNX2X_MSG_IOV, \"%x \",\n\t\t\t\tmbx->msg->req.tlv_buf_size.tlv_buffer[i]);\n\t}\n\n\t \n\tif (vf->state == VF_ACQUIRED || vf->state == VF_ENABLED) {\n\t\t \n\t\tbnx2x_vf_mbx_resp(bp, vf, PFVF_STATUS_NOT_SUPPORTED);\n\t} else {\n\t\t \n\t\tstorm_memset_vf_mbx_ack(bp, vf->abs_vfid);\n\t\t \n\t\tbnx2x_unlock_vf_pf_channel(bp, vf, mbx->first_tlv.tl.type);\n\t}\n}\n\nvoid bnx2x_vf_mbx_schedule(struct bnx2x *bp,\n\t\t\t   struct vf_pf_event_data *vfpf_event)\n{\n\tu8 vf_idx;\n\n\tDP(BNX2X_MSG_IOV,\n\t   \"vf pf event received: vfid %d, address_hi %x, address lo %x\",\n\t   vfpf_event->vf_id, vfpf_event->msg_addr_hi, vfpf_event->msg_addr_lo);\n\t \n\n\t \n\tif (vfpf_event->vf_id - BP_VFDB(bp)->sriov.first_vf_in_pf >\n\t    BNX2X_NR_VIRTFN(bp)) {\n\t\tBNX2X_ERR(\"Illegal vf_id %d max allowed: %d\\n\",\n\t\t\t  vfpf_event->vf_id, BNX2X_NR_VIRTFN(bp));\n\t\treturn;\n\t}\n\n\tvf_idx = bnx2x_vf_idx_by_abs_fid(bp, vfpf_event->vf_id);\n\n\t \n\tmutex_lock(&BP_VFDB(bp)->event_mutex);\n\tBP_VF_MBX(bp, vf_idx)->vf_addr_hi =\n\t\tle32_to_cpu(vfpf_event->msg_addr_hi);\n\tBP_VF_MBX(bp, vf_idx)->vf_addr_lo =\n\t\tle32_to_cpu(vfpf_event->msg_addr_lo);\n\tBP_VFDB(bp)->event_occur |= (1ULL << vf_idx);\n\tmutex_unlock(&BP_VFDB(bp)->event_mutex);\n\n\tbnx2x_schedule_iov_task(bp, BNX2X_IOV_HANDLE_VF_MSG);\n}\n\n \nvoid bnx2x_vf_mbx(struct bnx2x *bp)\n{\n\tstruct bnx2x_vfdb *vfdb = BP_VFDB(bp);\n\tu64 events;\n\tu8 vf_idx;\n\tint rc;\n\n\tif (!vfdb)\n\t\treturn;\n\n\tmutex_lock(&vfdb->event_mutex);\n\tevents = vfdb->event_occur;\n\tvfdb->event_occur = 0;\n\tmutex_unlock(&vfdb->event_mutex);\n\n\tfor_each_vf(bp, vf_idx) {\n\t\tstruct bnx2x_vf_mbx *mbx = BP_VF_MBX(bp, vf_idx);\n\t\tstruct bnx2x_virtf *vf = BP_VF(bp, vf_idx);\n\n\t\t \n\t\tif (!(events & (1ULL << vf_idx)))\n\t\t\tcontinue;\n\n\t\tDP(BNX2X_MSG_IOV,\n\t\t   \"Handling vf pf event vfid %d, address: [%x:%x], resp_offset 0x%x\\n\",\n\t\t   vf_idx, mbx->vf_addr_hi, mbx->vf_addr_lo,\n\t\t   mbx->first_tlv.resp_msg_offset);\n\n\t\t \n\t\trc = bnx2x_copy32_vf_dmae(bp, true, mbx->msg_mapping,\n\t\t\t\t\t  vf->abs_vfid, mbx->vf_addr_hi,\n\t\t\t\t\t  mbx->vf_addr_lo,\n\t\t\t\t\t  sizeof(union vfpf_tlvs)/4);\n\t\tif (rc) {\n\t\t\tBNX2X_ERR(\"Failed to copy request VF %d\\n\",\n\t\t\t\t  vf->abs_vfid);\n\t\t\tbnx2x_vf_release(bp, vf);\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tmbx->first_tlv = mbx->msg->req.first_tlv;\n\n\t\t \n\t\tmemset(&mbx->msg->resp, 0, sizeof(union pfvf_tlvs));\n\n\t\t \n\t\tbnx2x_vf_mbx_request(bp, vf, mbx);\n\t}\n}\n\nvoid bnx2x_vf_bulletin_finalize(struct pf_vf_bulletin_content *bulletin,\n\t\t\t\tbool support_long)\n{\n\t \n\tbulletin->length = support_long ? BULLETIN_CONTENT_SIZE :\n\t\t\t\t\t  BULLETIN_CONTENT_LEGACY_SIZE;\n\tbulletin->crc = bnx2x_crc_vf_bulletin(bulletin);\n}\n\n \nint bnx2x_post_vf_bulletin(struct bnx2x *bp, int vf)\n{\n\tstruct pf_vf_bulletin_content *bulletin = BP_VF_BULLETIN(bp, vf);\n\tdma_addr_t pf_addr = BP_VF_BULLETIN_DMA(bp)->mapping +\n\t\tvf * BULLETIN_CONTENT_SIZE;\n\tdma_addr_t vf_addr = bnx2x_vf(bp, vf, bulletin_map);\n\tint rc;\n\n\t \n\tif (bnx2x_vf(bp, vf, state) != VF_ENABLED &&\n\t    bnx2x_vf(bp, vf, state) != VF_ACQUIRED)\n\t\treturn 0;\n\n\t \n\tbulletin->version++;\n\tbnx2x_vf_bulletin_finalize(bulletin,\n\t\t\t\t   (bnx2x_vf(bp, vf, cfg_flags) &\n\t\t\t\t    VF_CFG_EXT_BULLETIN) ? true : false);\n\n\t \n\trc = bnx2x_copy32_vf_dmae(bp, false, pf_addr,\n\t\t\t\t  bnx2x_vf(bp, vf, abs_vfid), U64_HI(vf_addr),\n\t\t\t\t  U64_LO(vf_addr), bulletin->length / 4);\n\treturn rc;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}