{
  "module_name": "bnx2x_sp.c",
  "hash_id": "0acaee5cfa96e8550b52f81b8d0e09babb4e651c007e5173c7f000eee97d0f00",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/broadcom/bnx2x/bnx2x_sp.c",
  "human_readable_source": " \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/crc32.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/crc32c.h>\n#include \"bnx2x.h\"\n#include \"bnx2x_cmn.h\"\n#include \"bnx2x_sp.h\"\n\n#define BNX2X_MAX_EMUL_MULTI\t\t16\n\n \n\n \nstatic inline void bnx2x_exe_queue_init(struct bnx2x *bp,\n\t\t\t\t\tstruct bnx2x_exe_queue_obj *o,\n\t\t\t\t\tint exe_len,\n\t\t\t\t\tunion bnx2x_qable_obj *owner,\n\t\t\t\t\texe_q_validate validate,\n\t\t\t\t\texe_q_remove remove,\n\t\t\t\t\texe_q_optimize optimize,\n\t\t\t\t\texe_q_execute exec,\n\t\t\t\t\texe_q_get get)\n{\n\tmemset(o, 0, sizeof(*o));\n\n\tINIT_LIST_HEAD(&o->exe_queue);\n\tINIT_LIST_HEAD(&o->pending_comp);\n\n\tspin_lock_init(&o->lock);\n\n\to->exe_chunk_len = exe_len;\n\to->owner         = owner;\n\n\t \n\to->validate      = validate;\n\to->remove        = remove;\n\to->optimize      = optimize;\n\to->execute       = exec;\n\to->get           = get;\n\n\tDP(BNX2X_MSG_SP, \"Setup the execution queue with the chunk length of %d\\n\",\n\t   exe_len);\n}\n\nstatic inline void bnx2x_exe_queue_free_elem(struct bnx2x *bp,\n\t\t\t\t\t     struct bnx2x_exeq_elem *elem)\n{\n\tDP(BNX2X_MSG_SP, \"Deleting an exe_queue element\\n\");\n\tkfree(elem);\n}\n\nstatic inline int bnx2x_exe_queue_length(struct bnx2x_exe_queue_obj *o)\n{\n\tstruct bnx2x_exeq_elem *elem;\n\tint cnt = 0;\n\n\tspin_lock_bh(&o->lock);\n\n\tlist_for_each_entry(elem, &o->exe_queue, link)\n\t\tcnt++;\n\n\tspin_unlock_bh(&o->lock);\n\n\treturn cnt;\n}\n\n \nstatic inline int bnx2x_exe_queue_add(struct bnx2x *bp,\n\t\t\t\t      struct bnx2x_exe_queue_obj *o,\n\t\t\t\t      struct bnx2x_exeq_elem *elem,\n\t\t\t\t      bool restore)\n{\n\tint rc;\n\n\tspin_lock_bh(&o->lock);\n\n\tif (!restore) {\n\t\t \n\t\trc = o->optimize(bp, o->owner, elem);\n\t\tif (rc)\n\t\t\tgoto free_and_exit;\n\n\t\t \n\t\trc = o->validate(bp, o->owner, elem);\n\t\tif (rc) {\n\t\t\tDP(BNX2X_MSG_SP, \"Preamble failed: %d\\n\", rc);\n\t\t\tgoto free_and_exit;\n\t\t}\n\t}\n\n\t \n\tlist_add_tail(&elem->link, &o->exe_queue);\n\n\tspin_unlock_bh(&o->lock);\n\n\treturn 0;\n\nfree_and_exit:\n\tbnx2x_exe_queue_free_elem(bp, elem);\n\n\tspin_unlock_bh(&o->lock);\n\n\treturn rc;\n}\n\nstatic inline void __bnx2x_exe_queue_reset_pending(\n\tstruct bnx2x *bp,\n\tstruct bnx2x_exe_queue_obj *o)\n{\n\tstruct bnx2x_exeq_elem *elem;\n\n\twhile (!list_empty(&o->pending_comp)) {\n\t\telem = list_first_entry(&o->pending_comp,\n\t\t\t\t\tstruct bnx2x_exeq_elem, link);\n\n\t\tlist_del(&elem->link);\n\t\tbnx2x_exe_queue_free_elem(bp, elem);\n\t}\n}\n\n \nstatic inline int bnx2x_exe_queue_step(struct bnx2x *bp,\n\t\t\t\t       struct bnx2x_exe_queue_obj *o,\n\t\t\t\t       unsigned long *ramrod_flags)\n{\n\tstruct bnx2x_exeq_elem *elem, spacer;\n\tint cur_len = 0, rc;\n\n\tmemset(&spacer, 0, sizeof(spacer));\n\n\t \n\tif (!list_empty(&o->pending_comp)) {\n\t\tif (test_bit(RAMROD_DRV_CLR_ONLY, ramrod_flags)) {\n\t\t\tDP(BNX2X_MSG_SP, \"RAMROD_DRV_CLR_ONLY requested: resetting a pending_comp list\\n\");\n\t\t\t__bnx2x_exe_queue_reset_pending(bp, o);\n\t\t} else {\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t \n\twhile (!list_empty(&o->exe_queue)) {\n\t\telem = list_first_entry(&o->exe_queue, struct bnx2x_exeq_elem,\n\t\t\t\t\tlink);\n\t\tWARN_ON(!elem->cmd_len);\n\n\t\tif (cur_len + elem->cmd_len <= o->exe_chunk_len) {\n\t\t\tcur_len += elem->cmd_len;\n\t\t\t \n\t\t\tlist_add_tail(&spacer.link, &o->pending_comp);\n\t\t\tmb();\n\t\t\tlist_move_tail(&elem->link, &o->pending_comp);\n\t\t\tlist_del(&spacer.link);\n\t\t} else\n\t\t\tbreak;\n\t}\n\n\t \n\tif (!cur_len)\n\t\treturn 0;\n\n\trc = o->execute(bp, o->owner, &o->pending_comp, ramrod_flags);\n\tif (rc < 0)\n\t\t \n\t\tlist_splice_init(&o->pending_comp, &o->exe_queue);\n\telse if (!rc)\n\t\t \n\t\t__bnx2x_exe_queue_reset_pending(bp, o);\n\n\treturn rc;\n}\n\nstatic inline bool bnx2x_exe_queue_empty(struct bnx2x_exe_queue_obj *o)\n{\n\tbool empty = list_empty(&o->exe_queue);\n\n\t \n\tmb();\n\n\treturn empty && list_empty(&o->pending_comp);\n}\n\nstatic inline struct bnx2x_exeq_elem *bnx2x_exe_queue_alloc_elem(\n\tstruct bnx2x *bp)\n{\n\tDP(BNX2X_MSG_SP, \"Allocating a new exe_queue element\\n\");\n\treturn kzalloc(sizeof(struct bnx2x_exeq_elem), GFP_ATOMIC);\n}\n\n \nstatic bool bnx2x_raw_check_pending(struct bnx2x_raw_obj *o)\n{\n\treturn !!test_bit(o->state, o->pstate);\n}\n\nstatic void bnx2x_raw_clear_pending(struct bnx2x_raw_obj *o)\n{\n\tsmp_mb__before_atomic();\n\tclear_bit(o->state, o->pstate);\n\tsmp_mb__after_atomic();\n}\n\nstatic void bnx2x_raw_set_pending(struct bnx2x_raw_obj *o)\n{\n\tsmp_mb__before_atomic();\n\tset_bit(o->state, o->pstate);\n\tsmp_mb__after_atomic();\n}\n\n \nstatic inline int bnx2x_state_wait(struct bnx2x *bp, int state,\n\t\t\t\t   unsigned long *pstate)\n{\n\t \n\tint cnt = 5000;\n\n\tif (CHIP_REV_IS_EMUL(bp))\n\t\tcnt *= 20;\n\n\tDP(BNX2X_MSG_SP, \"waiting for state to become %d\\n\", state);\n\n\tmight_sleep();\n\twhile (cnt--) {\n\t\tif (!test_bit(state, pstate)) {\n#ifdef BNX2X_STOP_ON_ERROR\n\t\t\tDP(BNX2X_MSG_SP, \"exit  (cnt %d)\\n\", 5000 - cnt);\n#endif\n\t\t\treturn 0;\n\t\t}\n\n\t\tusleep_range(1000, 2000);\n\n\t\tif (bp->panic)\n\t\t\treturn -EIO;\n\t}\n\n\t \n\tBNX2X_ERR(\"timeout waiting for state %d\\n\", state);\n#ifdef BNX2X_STOP_ON_ERROR\n\tbnx2x_panic();\n#endif\n\n\treturn -EBUSY;\n}\n\nstatic int bnx2x_raw_wait(struct bnx2x *bp, struct bnx2x_raw_obj *raw)\n{\n\treturn bnx2x_state_wait(bp, raw->state, raw->pstate);\n}\n\n \n \nstatic bool bnx2x_get_cam_offset_mac(struct bnx2x_vlan_mac_obj *o, int *offset)\n{\n\tstruct bnx2x_credit_pool_obj *mp = o->macs_pool;\n\n\tWARN_ON(!mp);\n\n\treturn mp->get_entry(mp, offset);\n}\n\nstatic bool bnx2x_get_credit_mac(struct bnx2x_vlan_mac_obj *o)\n{\n\tstruct bnx2x_credit_pool_obj *mp = o->macs_pool;\n\n\tWARN_ON(!mp);\n\n\treturn mp->get(mp, 1);\n}\n\nstatic bool bnx2x_get_cam_offset_vlan(struct bnx2x_vlan_mac_obj *o, int *offset)\n{\n\tstruct bnx2x_credit_pool_obj *vp = o->vlans_pool;\n\n\tWARN_ON(!vp);\n\n\treturn vp->get_entry(vp, offset);\n}\n\nstatic bool bnx2x_get_credit_vlan(struct bnx2x_vlan_mac_obj *o)\n{\n\tstruct bnx2x_credit_pool_obj *vp = o->vlans_pool;\n\n\tWARN_ON(!vp);\n\n\treturn vp->get(vp, 1);\n}\n\nstatic bool bnx2x_get_credit_vlan_mac(struct bnx2x_vlan_mac_obj *o)\n{\n\tstruct bnx2x_credit_pool_obj *mp = o->macs_pool;\n\tstruct bnx2x_credit_pool_obj *vp = o->vlans_pool;\n\n\tif (!mp->get(mp, 1))\n\t\treturn false;\n\n\tif (!vp->get(vp, 1)) {\n\t\tmp->put(mp, 1);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic bool bnx2x_put_cam_offset_mac(struct bnx2x_vlan_mac_obj *o, int offset)\n{\n\tstruct bnx2x_credit_pool_obj *mp = o->macs_pool;\n\n\treturn mp->put_entry(mp, offset);\n}\n\nstatic bool bnx2x_put_credit_mac(struct bnx2x_vlan_mac_obj *o)\n{\n\tstruct bnx2x_credit_pool_obj *mp = o->macs_pool;\n\n\treturn mp->put(mp, 1);\n}\n\nstatic bool bnx2x_put_cam_offset_vlan(struct bnx2x_vlan_mac_obj *o, int offset)\n{\n\tstruct bnx2x_credit_pool_obj *vp = o->vlans_pool;\n\n\treturn vp->put_entry(vp, offset);\n}\n\nstatic bool bnx2x_put_credit_vlan(struct bnx2x_vlan_mac_obj *o)\n{\n\tstruct bnx2x_credit_pool_obj *vp = o->vlans_pool;\n\n\treturn vp->put(vp, 1);\n}\n\nstatic bool bnx2x_put_credit_vlan_mac(struct bnx2x_vlan_mac_obj *o)\n{\n\tstruct bnx2x_credit_pool_obj *mp = o->macs_pool;\n\tstruct bnx2x_credit_pool_obj *vp = o->vlans_pool;\n\n\tif (!mp->put(mp, 1))\n\t\treturn false;\n\n\tif (!vp->put(vp, 1)) {\n\t\tmp->get(mp, 1);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n \nstatic int __bnx2x_vlan_mac_h_write_trylock(struct bnx2x *bp,\n\t\t\t\t\t    struct bnx2x_vlan_mac_obj *o)\n{\n\tif (o->head_reader) {\n\t\tDP(BNX2X_MSG_SP, \"vlan_mac_lock writer - There are readers; Busy\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tDP(BNX2X_MSG_SP, \"vlan_mac_lock writer - Taken\\n\");\n\treturn 0;\n}\n\n \nstatic void __bnx2x_vlan_mac_h_exec_pending(struct bnx2x *bp,\n\t\t\t\t\t    struct bnx2x_vlan_mac_obj *o)\n{\n\tint rc;\n\tunsigned long ramrod_flags = o->saved_ramrod_flags;\n\n\tDP(BNX2X_MSG_SP, \"vlan_mac_lock execute pending command with ramrod flags %lu\\n\",\n\t   ramrod_flags);\n\to->head_exe_request = false;\n\to->saved_ramrod_flags = 0;\n\trc = bnx2x_exe_queue_step(bp, &o->exe_queue, &ramrod_flags);\n\tif ((rc != 0) && (rc != 1)) {\n\t\tBNX2X_ERR(\"execution of pending commands failed with rc %d\\n\",\n\t\t\t  rc);\n#ifdef BNX2X_STOP_ON_ERROR\n\t\tbnx2x_panic();\n#endif\n\t}\n}\n\n \nstatic void __bnx2x_vlan_mac_h_pend(struct bnx2x *bp,\n\t\t\t\t    struct bnx2x_vlan_mac_obj *o,\n\t\t\t\t    unsigned long ramrod_flags)\n{\n\to->head_exe_request = true;\n\to->saved_ramrod_flags = ramrod_flags;\n\tDP(BNX2X_MSG_SP, \"Placing pending execution with ramrod flags %lu\\n\",\n\t   ramrod_flags);\n}\n\n \nstatic void __bnx2x_vlan_mac_h_write_unlock(struct bnx2x *bp,\n\t\t\t\t\t    struct bnx2x_vlan_mac_obj *o)\n{\n\t \n\twhile (o->head_exe_request) {\n\t\tDP(BNX2X_MSG_SP, \"vlan_mac_lock - writer release encountered a pending request\\n\");\n\t\t__bnx2x_vlan_mac_h_exec_pending(bp, o);\n\t}\n}\n\n\n \nstatic int __bnx2x_vlan_mac_h_read_lock(struct bnx2x *bp,\n\t\t\t\t\tstruct bnx2x_vlan_mac_obj *o)\n{\n\t \n\to->head_reader++;\n\tDP(BNX2X_MSG_SP, \"vlan_mac_lock - locked reader - number %d\\n\",\n\t   o->head_reader);\n\n\treturn 0;\n}\n\n \nint bnx2x_vlan_mac_h_read_lock(struct bnx2x *bp,\n\t\t\t       struct bnx2x_vlan_mac_obj *o)\n{\n\tint rc;\n\n\tspin_lock_bh(&o->exe_queue.lock);\n\trc = __bnx2x_vlan_mac_h_read_lock(bp, o);\n\tspin_unlock_bh(&o->exe_queue.lock);\n\n\treturn rc;\n}\n\n \nstatic void __bnx2x_vlan_mac_h_read_unlock(struct bnx2x *bp,\n\t\t\t\t\t  struct bnx2x_vlan_mac_obj *o)\n{\n\tif (!o->head_reader) {\n\t\tBNX2X_ERR(\"Need to release vlan mac reader lock, but lock isn't taken\\n\");\n#ifdef BNX2X_STOP_ON_ERROR\n\t\tbnx2x_panic();\n#endif\n\t} else {\n\t\to->head_reader--;\n\t\tDP(BNX2X_MSG_SP, \"vlan_mac_lock - decreased readers to %d\\n\",\n\t\t   o->head_reader);\n\t}\n\n\t \n\tif (!o->head_reader && o->head_exe_request) {\n\t\tDP(BNX2X_MSG_SP, \"vlan_mac_lock - reader release encountered a pending request\\n\");\n\n\t\t \n\t\t__bnx2x_vlan_mac_h_write_unlock(bp, o);\n\t}\n}\n\n \nvoid bnx2x_vlan_mac_h_read_unlock(struct bnx2x *bp,\n\t\t\t\t  struct bnx2x_vlan_mac_obj *o)\n{\n\tspin_lock_bh(&o->exe_queue.lock);\n\t__bnx2x_vlan_mac_h_read_unlock(bp, o);\n\tspin_unlock_bh(&o->exe_queue.lock);\n}\n\nstatic int bnx2x_get_n_elements(struct bnx2x *bp, struct bnx2x_vlan_mac_obj *o,\n\t\t\t\tint n, u8 *base, u8 stride, u8 size)\n{\n\tstruct bnx2x_vlan_mac_registry_elem *pos;\n\tu8 *next = base;\n\tint counter = 0;\n\tint read_lock;\n\n\tDP(BNX2X_MSG_SP, \"get_n_elements - taking vlan_mac_lock (reader)\\n\");\n\tread_lock = bnx2x_vlan_mac_h_read_lock(bp, o);\n\tif (read_lock != 0)\n\t\tBNX2X_ERR(\"get_n_elements failed to get vlan mac reader lock; Access without lock\\n\");\n\n\t \n\tlist_for_each_entry(pos, &o->head, link) {\n\t\tif (counter < n) {\n\t\t\tmemcpy(next, &pos->u, size);\n\t\t\tcounter++;\n\t\t\tDP(BNX2X_MSG_SP, \"copied element number %d to address %p element was:\\n\",\n\t\t\t   counter, next);\n\t\t\tnext += stride + size;\n\t\t}\n\t}\n\n\tif (read_lock == 0) {\n\t\tDP(BNX2X_MSG_SP, \"get_n_elements - releasing vlan_mac_lock (reader)\\n\");\n\t\tbnx2x_vlan_mac_h_read_unlock(bp, o);\n\t}\n\n\treturn counter * ETH_ALEN;\n}\n\n \nstatic int bnx2x_check_mac_add(struct bnx2x *bp,\n\t\t\t       struct bnx2x_vlan_mac_obj *o,\n\t\t\t       union bnx2x_classification_ramrod_data *data)\n{\n\tstruct bnx2x_vlan_mac_registry_elem *pos;\n\n\tDP(BNX2X_MSG_SP, \"Checking MAC %pM for ADD command\\n\", data->mac.mac);\n\n\tif (!is_valid_ether_addr(data->mac.mac))\n\t\treturn -EINVAL;\n\n\t \n\tlist_for_each_entry(pos, &o->head, link)\n\t\tif (ether_addr_equal(data->mac.mac, pos->u.mac.mac) &&\n\t\t    (data->mac.is_inner_mac == pos->u.mac.is_inner_mac))\n\t\t\treturn -EEXIST;\n\n\treturn 0;\n}\n\nstatic int bnx2x_check_vlan_add(struct bnx2x *bp,\n\t\t\t\tstruct bnx2x_vlan_mac_obj *o,\n\t\t\t\tunion bnx2x_classification_ramrod_data *data)\n{\n\tstruct bnx2x_vlan_mac_registry_elem *pos;\n\n\tDP(BNX2X_MSG_SP, \"Checking VLAN %d for ADD command\\n\", data->vlan.vlan);\n\n\tlist_for_each_entry(pos, &o->head, link)\n\t\tif (data->vlan.vlan == pos->u.vlan.vlan)\n\t\t\treturn -EEXIST;\n\n\treturn 0;\n}\n\nstatic int bnx2x_check_vlan_mac_add(struct bnx2x *bp,\n\t\t\t\t    struct bnx2x_vlan_mac_obj *o,\n\t\t\t\t   union bnx2x_classification_ramrod_data *data)\n{\n\tstruct bnx2x_vlan_mac_registry_elem *pos;\n\n\tDP(BNX2X_MSG_SP, \"Checking VLAN_MAC (%pM, %d) for ADD command\\n\",\n\t   data->vlan_mac.mac, data->vlan_mac.vlan);\n\n\tlist_for_each_entry(pos, &o->head, link)\n\t\tif ((data->vlan_mac.vlan == pos->u.vlan_mac.vlan) &&\n\t\t    (!memcmp(data->vlan_mac.mac, pos->u.vlan_mac.mac,\n\t\t\t\t  ETH_ALEN)) &&\n\t\t    (data->vlan_mac.is_inner_mac ==\n\t\t     pos->u.vlan_mac.is_inner_mac))\n\t\t\treturn -EEXIST;\n\n\treturn 0;\n}\n\n \nstatic struct bnx2x_vlan_mac_registry_elem *\n\tbnx2x_check_mac_del(struct bnx2x *bp,\n\t\t\t    struct bnx2x_vlan_mac_obj *o,\n\t\t\t    union bnx2x_classification_ramrod_data *data)\n{\n\tstruct bnx2x_vlan_mac_registry_elem *pos;\n\n\tDP(BNX2X_MSG_SP, \"Checking MAC %pM for DEL command\\n\", data->mac.mac);\n\n\tlist_for_each_entry(pos, &o->head, link)\n\t\tif (ether_addr_equal(data->mac.mac, pos->u.mac.mac) &&\n\t\t    (data->mac.is_inner_mac == pos->u.mac.is_inner_mac))\n\t\t\treturn pos;\n\n\treturn NULL;\n}\n\nstatic struct bnx2x_vlan_mac_registry_elem *\n\tbnx2x_check_vlan_del(struct bnx2x *bp,\n\t\t\t     struct bnx2x_vlan_mac_obj *o,\n\t\t\t     union bnx2x_classification_ramrod_data *data)\n{\n\tstruct bnx2x_vlan_mac_registry_elem *pos;\n\n\tDP(BNX2X_MSG_SP, \"Checking VLAN %d for DEL command\\n\", data->vlan.vlan);\n\n\tlist_for_each_entry(pos, &o->head, link)\n\t\tif (data->vlan.vlan == pos->u.vlan.vlan)\n\t\t\treturn pos;\n\n\treturn NULL;\n}\n\nstatic struct bnx2x_vlan_mac_registry_elem *\n\tbnx2x_check_vlan_mac_del(struct bnx2x *bp,\n\t\t\t\t struct bnx2x_vlan_mac_obj *o,\n\t\t\t\t union bnx2x_classification_ramrod_data *data)\n{\n\tstruct bnx2x_vlan_mac_registry_elem *pos;\n\n\tDP(BNX2X_MSG_SP, \"Checking VLAN_MAC (%pM, %d) for DEL command\\n\",\n\t   data->vlan_mac.mac, data->vlan_mac.vlan);\n\n\tlist_for_each_entry(pos, &o->head, link)\n\t\tif ((data->vlan_mac.vlan == pos->u.vlan_mac.vlan) &&\n\t\t    (!memcmp(data->vlan_mac.mac, pos->u.vlan_mac.mac,\n\t\t\t     ETH_ALEN)) &&\n\t\t    (data->vlan_mac.is_inner_mac ==\n\t\t     pos->u.vlan_mac.is_inner_mac))\n\t\t\treturn pos;\n\n\treturn NULL;\n}\n\n \nstatic bool bnx2x_check_move(struct bnx2x *bp,\n\t\t\t     struct bnx2x_vlan_mac_obj *src_o,\n\t\t\t     struct bnx2x_vlan_mac_obj *dst_o,\n\t\t\t     union bnx2x_classification_ramrod_data *data)\n{\n\tstruct bnx2x_vlan_mac_registry_elem *pos;\n\tint rc;\n\n\t \n\tpos = src_o->check_del(bp, src_o, data);\n\n\t \n\trc = dst_o->check_add(bp, dst_o, data);\n\n\t \n\tif (rc || !pos)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool bnx2x_check_move_always_err(\n\tstruct bnx2x *bp,\n\tstruct bnx2x_vlan_mac_obj *src_o,\n\tstruct bnx2x_vlan_mac_obj *dst_o,\n\tunion bnx2x_classification_ramrod_data *data)\n{\n\treturn false;\n}\n\nstatic inline u8 bnx2x_vlan_mac_get_rx_tx_flag(struct bnx2x_vlan_mac_obj *o)\n{\n\tstruct bnx2x_raw_obj *raw = &o->raw;\n\tu8 rx_tx_flag = 0;\n\n\tif ((raw->obj_type == BNX2X_OBJ_TYPE_TX) ||\n\t    (raw->obj_type == BNX2X_OBJ_TYPE_RX_TX))\n\t\trx_tx_flag |= ETH_CLASSIFY_CMD_HEADER_TX_CMD;\n\n\tif ((raw->obj_type == BNX2X_OBJ_TYPE_RX) ||\n\t    (raw->obj_type == BNX2X_OBJ_TYPE_RX_TX))\n\t\trx_tx_flag |= ETH_CLASSIFY_CMD_HEADER_RX_CMD;\n\n\treturn rx_tx_flag;\n}\n\nstatic void bnx2x_set_mac_in_nig(struct bnx2x *bp,\n\t\t\t\t bool add, unsigned char *dev_addr, int index)\n{\n\tu32 wb_data[2];\n\tu32 reg_offset = BP_PORT(bp) ? NIG_REG_LLH1_FUNC_MEM :\n\t\t\t NIG_REG_LLH0_FUNC_MEM;\n\n\tif (!IS_MF_SI(bp) && !IS_MF_AFEX(bp))\n\t\treturn;\n\n\tif (index > BNX2X_LLH_CAM_MAX_PF_LINE)\n\t\treturn;\n\n\tDP(BNX2X_MSG_SP, \"Going to %s LLH configuration at entry %d\\n\",\n\t\t\t (add ? \"ADD\" : \"DELETE\"), index);\n\n\tif (add) {\n\t\t \n\t\treg_offset += 8*index;\n\n\t\twb_data[0] = ((dev_addr[2] << 24) | (dev_addr[3] << 16) |\n\t\t\t      (dev_addr[4] <<  8) |  dev_addr[5]);\n\t\twb_data[1] = ((dev_addr[0] <<  8) |  dev_addr[1]);\n\n\t\tREG_WR_DMAE(bp, reg_offset, wb_data, 2);\n\t}\n\n\tREG_WR(bp, (BP_PORT(bp) ? NIG_REG_LLH1_FUNC_MEM_ENABLE :\n\t\t\t\t  NIG_REG_LLH0_FUNC_MEM_ENABLE) + 4*index, add);\n}\n\n \nstatic inline void bnx2x_vlan_mac_set_cmd_hdr_e2(struct bnx2x *bp,\n\tstruct bnx2x_vlan_mac_obj *o, bool add, int opcode,\n\tstruct eth_classify_cmd_header *hdr)\n{\n\tstruct bnx2x_raw_obj *raw = &o->raw;\n\n\thdr->client_id = raw->cl_id;\n\thdr->func_id = raw->func_id;\n\n\t \n\thdr->cmd_general_data |=\n\t\tbnx2x_vlan_mac_get_rx_tx_flag(o);\n\n\tif (add)\n\t\thdr->cmd_general_data |= ETH_CLASSIFY_CMD_HEADER_IS_ADD;\n\n\thdr->cmd_general_data |=\n\t\t(opcode << ETH_CLASSIFY_CMD_HEADER_OPCODE_SHIFT);\n}\n\n \nstatic inline void bnx2x_vlan_mac_set_rdata_hdr_e2(u32 cid, int type,\n\t\t\t\tstruct eth_classify_header *hdr, int rule_cnt)\n{\n\thdr->echo = cpu_to_le32((cid & BNX2X_SWCID_MASK) |\n\t\t\t\t(type << BNX2X_SWCID_SHIFT));\n\thdr->rule_cnt = (u8)rule_cnt;\n}\n\n \nstatic void bnx2x_set_one_mac_e2(struct bnx2x *bp,\n\t\t\t\t struct bnx2x_vlan_mac_obj *o,\n\t\t\t\t struct bnx2x_exeq_elem *elem, int rule_idx,\n\t\t\t\t int cam_offset)\n{\n\tstruct bnx2x_raw_obj *raw = &o->raw;\n\tstruct eth_classify_rules_ramrod_data *data =\n\t\t(struct eth_classify_rules_ramrod_data *)(raw->rdata);\n\tint rule_cnt = rule_idx + 1, cmd = elem->cmd_data.vlan_mac.cmd;\n\tunion eth_classify_rule_cmd *rule_entry = &data->rules[rule_idx];\n\tbool add = cmd == BNX2X_VLAN_MAC_ADD;\n\tunsigned long *vlan_mac_flags = &elem->cmd_data.vlan_mac.vlan_mac_flags;\n\tu8 *mac = elem->cmd_data.vlan_mac.u.mac.mac;\n\n\t \n\tif (cmd != BNX2X_VLAN_MAC_MOVE) {\n\t\tif (test_bit(BNX2X_ISCSI_ETH_MAC, vlan_mac_flags))\n\t\t\tbnx2x_set_mac_in_nig(bp, add, mac,\n\t\t\t\t\t     BNX2X_LLH_CAM_ISCSI_ETH_LINE);\n\t\telse if (test_bit(BNX2X_ETH_MAC, vlan_mac_flags))\n\t\t\tbnx2x_set_mac_in_nig(bp, add, mac,\n\t\t\t\t\t     BNX2X_LLH_CAM_ETH_LINE);\n\t}\n\n\t \n\tif (rule_idx == 0)\n\t\tmemset(data, 0, sizeof(*data));\n\n\t \n\tbnx2x_vlan_mac_set_cmd_hdr_e2(bp, o, add, CLASSIFY_RULE_OPCODE_MAC,\n\t\t\t\t      &rule_entry->mac.header);\n\n\tDP(BNX2X_MSG_SP, \"About to %s MAC %pM for Queue %d\\n\",\n\t   (add ? \"add\" : \"delete\"), mac, raw->cl_id);\n\n\t \n\tbnx2x_set_fw_mac_addr(&rule_entry->mac.mac_msb,\n\t\t\t      &rule_entry->mac.mac_mid,\n\t\t\t      &rule_entry->mac.mac_lsb, mac);\n\trule_entry->mac.inner_mac =\n\t\tcpu_to_le16(elem->cmd_data.vlan_mac.u.mac.is_inner_mac);\n\n\t \n\tif (cmd == BNX2X_VLAN_MAC_MOVE) {\n\t\trule_entry++;\n\t\trule_cnt++;\n\n\t\t \n\t\tbnx2x_vlan_mac_set_cmd_hdr_e2(bp,\n\t\t\t\t\telem->cmd_data.vlan_mac.target_obj,\n\t\t\t\t\t      true, CLASSIFY_RULE_OPCODE_MAC,\n\t\t\t\t\t      &rule_entry->mac.header);\n\n\t\t \n\t\tbnx2x_set_fw_mac_addr(&rule_entry->mac.mac_msb,\n\t\t\t\t      &rule_entry->mac.mac_mid,\n\t\t\t\t      &rule_entry->mac.mac_lsb, mac);\n\t\trule_entry->mac.inner_mac =\n\t\t\tcpu_to_le16(elem->cmd_data.vlan_mac.\n\t\t\t\t\t\tu.mac.is_inner_mac);\n\t}\n\n\t \n\t \n\tbnx2x_vlan_mac_set_rdata_hdr_e2(raw->cid, raw->state, &data->header,\n\t\t\t\t\trule_cnt);\n}\n\n \nstatic inline void bnx2x_vlan_mac_set_rdata_hdr_e1x(struct bnx2x *bp,\n\tstruct bnx2x_vlan_mac_obj *o, int type, int cam_offset,\n\tstruct mac_configuration_hdr *hdr)\n{\n\tstruct bnx2x_raw_obj *r = &o->raw;\n\n\thdr->length = 1;\n\thdr->offset = (u8)cam_offset;\n\thdr->client_id = cpu_to_le16(0xff);\n\thdr->echo = cpu_to_le32((r->cid & BNX2X_SWCID_MASK) |\n\t\t\t\t(type << BNX2X_SWCID_SHIFT));\n}\n\nstatic inline void bnx2x_vlan_mac_set_cfg_entry_e1x(struct bnx2x *bp,\n\tstruct bnx2x_vlan_mac_obj *o, bool add, int opcode, u8 *mac,\n\tu16 vlan_id, struct mac_configuration_entry *cfg_entry)\n{\n\tstruct bnx2x_raw_obj *r = &o->raw;\n\tu32 cl_bit_vec = (1 << r->cl_id);\n\n\tcfg_entry->clients_bit_vector = cpu_to_le32(cl_bit_vec);\n\tcfg_entry->pf_id = r->func_id;\n\tcfg_entry->vlan_id = cpu_to_le16(vlan_id);\n\n\tif (add) {\n\t\tSET_FLAG(cfg_entry->flags, MAC_CONFIGURATION_ENTRY_ACTION_TYPE,\n\t\t\t T_ETH_MAC_COMMAND_SET);\n\t\tSET_FLAG(cfg_entry->flags,\n\t\t\t MAC_CONFIGURATION_ENTRY_VLAN_FILTERING_MODE, opcode);\n\n\t\t \n\t\tbnx2x_set_fw_mac_addr(&cfg_entry->msb_mac_addr,\n\t\t\t\t      &cfg_entry->middle_mac_addr,\n\t\t\t\t      &cfg_entry->lsb_mac_addr, mac);\n\t} else\n\t\tSET_FLAG(cfg_entry->flags, MAC_CONFIGURATION_ENTRY_ACTION_TYPE,\n\t\t\t T_ETH_MAC_COMMAND_INVALIDATE);\n}\n\nstatic inline void bnx2x_vlan_mac_set_rdata_e1x(struct bnx2x *bp,\n\tstruct bnx2x_vlan_mac_obj *o, int type, int cam_offset, bool add,\n\tu8 *mac, u16 vlan_id, int opcode, struct mac_configuration_cmd *config)\n{\n\tstruct mac_configuration_entry *cfg_entry = &config->config_table[0];\n\tstruct bnx2x_raw_obj *raw = &o->raw;\n\n\tbnx2x_vlan_mac_set_rdata_hdr_e1x(bp, o, type, cam_offset,\n\t\t\t\t\t &config->hdr);\n\tbnx2x_vlan_mac_set_cfg_entry_e1x(bp, o, add, opcode, mac, vlan_id,\n\t\t\t\t\t cfg_entry);\n\n\tDP(BNX2X_MSG_SP, \"%s MAC %pM CLID %d CAM offset %d\\n\",\n\t\t\t (add ? \"setting\" : \"clearing\"),\n\t\t\t mac, raw->cl_id, cam_offset);\n}\n\n \nstatic void bnx2x_set_one_mac_e1x(struct bnx2x *bp,\n\t\t\t\t  struct bnx2x_vlan_mac_obj *o,\n\t\t\t\t  struct bnx2x_exeq_elem *elem, int rule_idx,\n\t\t\t\t  int cam_offset)\n{\n\tstruct bnx2x_raw_obj *raw = &o->raw;\n\tstruct mac_configuration_cmd *config =\n\t\t(struct mac_configuration_cmd *)(raw->rdata);\n\t \n\tbool add = (elem->cmd_data.vlan_mac.cmd == BNX2X_VLAN_MAC_ADD) ?\n\t\ttrue : false;\n\n\t \n\tmemset(config, 0, sizeof(*config));\n\n\tbnx2x_vlan_mac_set_rdata_e1x(bp, o, raw->state,\n\t\t\t\t     cam_offset, add,\n\t\t\t\t     elem->cmd_data.vlan_mac.u.mac.mac, 0,\n\t\t\t\t     ETH_VLAN_FILTER_ANY_VLAN, config);\n}\n\nstatic void bnx2x_set_one_vlan_e2(struct bnx2x *bp,\n\t\t\t\t  struct bnx2x_vlan_mac_obj *o,\n\t\t\t\t  struct bnx2x_exeq_elem *elem, int rule_idx,\n\t\t\t\t  int cam_offset)\n{\n\tstruct bnx2x_raw_obj *raw = &o->raw;\n\tstruct eth_classify_rules_ramrod_data *data =\n\t\t(struct eth_classify_rules_ramrod_data *)(raw->rdata);\n\tint rule_cnt = rule_idx + 1;\n\tunion eth_classify_rule_cmd *rule_entry = &data->rules[rule_idx];\n\tenum bnx2x_vlan_mac_cmd cmd = elem->cmd_data.vlan_mac.cmd;\n\tbool add = cmd == BNX2X_VLAN_MAC_ADD;\n\tu16 vlan = elem->cmd_data.vlan_mac.u.vlan.vlan;\n\n\t \n\tif (rule_idx == 0)\n\t\tmemset(data, 0, sizeof(*data));\n\n\t \n\tbnx2x_vlan_mac_set_cmd_hdr_e2(bp, o, add, CLASSIFY_RULE_OPCODE_VLAN,\n\t\t\t\t      &rule_entry->vlan.header);\n\n\tDP(BNX2X_MSG_SP, \"About to %s VLAN %d\\n\", (add ? \"add\" : \"delete\"),\n\t\t\t vlan);\n\n\t \n\trule_entry->vlan.vlan = cpu_to_le16(vlan);\n\n\t \n\tif (cmd == BNX2X_VLAN_MAC_MOVE) {\n\t\trule_entry++;\n\t\trule_cnt++;\n\n\t\t \n\t\tbnx2x_vlan_mac_set_cmd_hdr_e2(bp,\n\t\t\t\t\telem->cmd_data.vlan_mac.target_obj,\n\t\t\t\t\t      true, CLASSIFY_RULE_OPCODE_VLAN,\n\t\t\t\t\t      &rule_entry->vlan.header);\n\n\t\t \n\t\trule_entry->vlan.vlan = cpu_to_le16(vlan);\n\t}\n\n\t \n\t \n\tbnx2x_vlan_mac_set_rdata_hdr_e2(raw->cid, raw->state, &data->header,\n\t\t\t\t\trule_cnt);\n}\n\nstatic void bnx2x_set_one_vlan_mac_e2(struct bnx2x *bp,\n\t\t\t\t      struct bnx2x_vlan_mac_obj *o,\n\t\t\t\t      struct bnx2x_exeq_elem *elem,\n\t\t\t\t      int rule_idx, int cam_offset)\n{\n\tstruct bnx2x_raw_obj *raw = &o->raw;\n\tstruct eth_classify_rules_ramrod_data *data =\n\t\t(struct eth_classify_rules_ramrod_data *)(raw->rdata);\n\tint rule_cnt = rule_idx + 1;\n\tunion eth_classify_rule_cmd *rule_entry = &data->rules[rule_idx];\n\tenum bnx2x_vlan_mac_cmd cmd = elem->cmd_data.vlan_mac.cmd;\n\tbool add = cmd == BNX2X_VLAN_MAC_ADD;\n\tu16 vlan = elem->cmd_data.vlan_mac.u.vlan_mac.vlan;\n\tu8 *mac = elem->cmd_data.vlan_mac.u.vlan_mac.mac;\n\tu16 inner_mac;\n\n\t \n\tif (rule_idx == 0)\n\t\tmemset(data, 0, sizeof(*data));\n\n\t \n\tbnx2x_vlan_mac_set_cmd_hdr_e2(bp, o, add, CLASSIFY_RULE_OPCODE_PAIR,\n\t\t\t\t      &rule_entry->pair.header);\n\n\t \n\trule_entry->pair.vlan = cpu_to_le16(vlan);\n\tbnx2x_set_fw_mac_addr(&rule_entry->pair.mac_msb,\n\t\t\t      &rule_entry->pair.mac_mid,\n\t\t\t      &rule_entry->pair.mac_lsb, mac);\n\tinner_mac = elem->cmd_data.vlan_mac.u.vlan_mac.is_inner_mac;\n\trule_entry->pair.inner_mac = cpu_to_le16(inner_mac);\n\t \n\tif (cmd == BNX2X_VLAN_MAC_MOVE) {\n\t\tstruct bnx2x_vlan_mac_obj *target_obj;\n\n\t\trule_entry++;\n\t\trule_cnt++;\n\n\t\t \n\t\ttarget_obj = elem->cmd_data.vlan_mac.target_obj;\n\t\tbnx2x_vlan_mac_set_cmd_hdr_e2(bp, target_obj,\n\t\t\t\t\t      true, CLASSIFY_RULE_OPCODE_PAIR,\n\t\t\t\t\t      &rule_entry->pair.header);\n\n\t\t \n\t\trule_entry->pair.vlan = cpu_to_le16(vlan);\n\t\tbnx2x_set_fw_mac_addr(&rule_entry->pair.mac_msb,\n\t\t\t\t      &rule_entry->pair.mac_mid,\n\t\t\t\t      &rule_entry->pair.mac_lsb, mac);\n\t\trule_entry->pair.inner_mac = cpu_to_le16(inner_mac);\n\t}\n\n\t \n\tbnx2x_vlan_mac_set_rdata_hdr_e2(raw->cid, raw->state, &data->header,\n\t\t\t\t\trule_cnt);\n}\n\n \nstatic void bnx2x_set_one_vlan_mac_e1h(struct bnx2x *bp,\n\t\t\t\t       struct bnx2x_vlan_mac_obj *o,\n\t\t\t\t       struct bnx2x_exeq_elem *elem,\n\t\t\t\t       int rule_idx, int cam_offset)\n{\n\tstruct bnx2x_raw_obj *raw = &o->raw;\n\tstruct mac_configuration_cmd *config =\n\t\t(struct mac_configuration_cmd *)(raw->rdata);\n\t \n\tbool add = (elem->cmd_data.vlan_mac.cmd == BNX2X_VLAN_MAC_ADD) ?\n\t\ttrue : false;\n\n\t \n\tmemset(config, 0, sizeof(*config));\n\n\tbnx2x_vlan_mac_set_rdata_e1x(bp, o, BNX2X_FILTER_VLAN_MAC_PENDING,\n\t\t\t\t     cam_offset, add,\n\t\t\t\t     elem->cmd_data.vlan_mac.u.vlan_mac.mac,\n\t\t\t\t     elem->cmd_data.vlan_mac.u.vlan_mac.vlan,\n\t\t\t\t     ETH_VLAN_FILTER_CLASSIFY, config);\n}\n\n \nstatic int bnx2x_vlan_mac_restore(struct bnx2x *bp,\n\t\t\t   struct bnx2x_vlan_mac_ramrod_params *p,\n\t\t\t   struct bnx2x_vlan_mac_registry_elem **ppos)\n{\n\tstruct bnx2x_vlan_mac_registry_elem *pos;\n\tstruct bnx2x_vlan_mac_obj *o = p->vlan_mac_obj;\n\n\t \n\tif (list_empty(&o->head)) {\n\t\t*ppos = NULL;\n\t\treturn 0;\n\t}\n\n\t \n\tif (*ppos == NULL)\n\t\t*ppos = list_first_entry(&o->head,\n\t\t\t\t\t struct bnx2x_vlan_mac_registry_elem,\n\t\t\t\t\t link);\n\telse\n\t\t*ppos = list_next_entry(*ppos, link);\n\n\tpos = *ppos;\n\n\t \n\tif (list_is_last(&pos->link, &o->head))\n\t\t*ppos = NULL;\n\n\t \n\tmemcpy(&p->user_req.u, &pos->u, sizeof(pos->u));\n\n\t \n\tp->user_req.cmd = BNX2X_VLAN_MAC_ADD;\n\n\t \n\tp->user_req.vlan_mac_flags = pos->vlan_mac_flags;\n\n\t \n\t__set_bit(RAMROD_RESTORE, &p->ramrod_flags);\n\n\treturn bnx2x_config_vlan_mac(bp, p);\n}\n\n \nstatic struct bnx2x_exeq_elem *bnx2x_exeq_get_mac(\n\tstruct bnx2x_exe_queue_obj *o,\n\tstruct bnx2x_exeq_elem *elem)\n{\n\tstruct bnx2x_exeq_elem *pos;\n\tstruct bnx2x_mac_ramrod_data *data = &elem->cmd_data.vlan_mac.u.mac;\n\n\t \n\tlist_for_each_entry(pos, &o->exe_queue, link)\n\t\tif (!memcmp(&pos->cmd_data.vlan_mac.u.mac, data,\n\t\t\t      sizeof(*data)) &&\n\t\t    (pos->cmd_data.vlan_mac.cmd == elem->cmd_data.vlan_mac.cmd))\n\t\t\treturn pos;\n\n\treturn NULL;\n}\n\nstatic struct bnx2x_exeq_elem *bnx2x_exeq_get_vlan(\n\tstruct bnx2x_exe_queue_obj *o,\n\tstruct bnx2x_exeq_elem *elem)\n{\n\tstruct bnx2x_exeq_elem *pos;\n\tstruct bnx2x_vlan_ramrod_data *data = &elem->cmd_data.vlan_mac.u.vlan;\n\n\t \n\tlist_for_each_entry(pos, &o->exe_queue, link)\n\t\tif (!memcmp(&pos->cmd_data.vlan_mac.u.vlan, data,\n\t\t\t      sizeof(*data)) &&\n\t\t    (pos->cmd_data.vlan_mac.cmd == elem->cmd_data.vlan_mac.cmd))\n\t\t\treturn pos;\n\n\treturn NULL;\n}\n\nstatic struct bnx2x_exeq_elem *bnx2x_exeq_get_vlan_mac(\n\tstruct bnx2x_exe_queue_obj *o,\n\tstruct bnx2x_exeq_elem *elem)\n{\n\tstruct bnx2x_exeq_elem *pos;\n\tstruct bnx2x_vlan_mac_ramrod_data *data =\n\t\t&elem->cmd_data.vlan_mac.u.vlan_mac;\n\n\t \n\tlist_for_each_entry(pos, &o->exe_queue, link)\n\t\tif (!memcmp(&pos->cmd_data.vlan_mac.u.vlan_mac, data,\n\t\t\t    sizeof(*data)) &&\n\t\t    (pos->cmd_data.vlan_mac.cmd ==\n\t\t     elem->cmd_data.vlan_mac.cmd))\n\t\t\treturn pos;\n\n\treturn NULL;\n}\n\n \nstatic inline int bnx2x_validate_vlan_mac_add(struct bnx2x *bp,\n\t\t\t\t\t      union bnx2x_qable_obj *qo,\n\t\t\t\t\t      struct bnx2x_exeq_elem *elem)\n{\n\tstruct bnx2x_vlan_mac_obj *o = &qo->vlan_mac;\n\tstruct bnx2x_exe_queue_obj *exeq = &o->exe_queue;\n\tint rc;\n\n\t \n\trc = o->check_add(bp, o, &elem->cmd_data.vlan_mac.u);\n\tif (rc) {\n\t\tDP(BNX2X_MSG_SP, \"ADD command is not allowed considering current registry state.\\n\");\n\t\treturn rc;\n\t}\n\n\t \n\tif (exeq->get(exeq, elem)) {\n\t\tDP(BNX2X_MSG_SP, \"There is a pending ADD command already\\n\");\n\t\treturn -EEXIST;\n\t}\n\n\t \n\n\t \n\tif (!(test_bit(BNX2X_DONT_CONSUME_CAM_CREDIT,\n\t\t       &elem->cmd_data.vlan_mac.vlan_mac_flags) ||\n\t    o->get_credit(o)))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n \nstatic inline int bnx2x_validate_vlan_mac_del(struct bnx2x *bp,\n\t\t\t\t\t      union bnx2x_qable_obj *qo,\n\t\t\t\t\t      struct bnx2x_exeq_elem *elem)\n{\n\tstruct bnx2x_vlan_mac_obj *o = &qo->vlan_mac;\n\tstruct bnx2x_vlan_mac_registry_elem *pos;\n\tstruct bnx2x_exe_queue_obj *exeq = &o->exe_queue;\n\tstruct bnx2x_exeq_elem query_elem;\n\n\t \n\tpos = o->check_del(bp, o, &elem->cmd_data.vlan_mac.u);\n\tif (!pos) {\n\t\tDP(BNX2X_MSG_SP, \"DEL command is not allowed considering current registry state\\n\");\n\t\treturn -EEXIST;\n\t}\n\n\t \n\tmemcpy(&query_elem, elem, sizeof(query_elem));\n\n\t \n\tquery_elem.cmd_data.vlan_mac.cmd = BNX2X_VLAN_MAC_MOVE;\n\tif (exeq->get(exeq, &query_elem)) {\n\t\tBNX2X_ERR(\"There is a pending MOVE command already\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (exeq->get(exeq, elem)) {\n\t\tDP(BNX2X_MSG_SP, \"There is a pending DEL command already\\n\");\n\t\treturn -EEXIST;\n\t}\n\n\t \n\tif (!(test_bit(BNX2X_DONT_CONSUME_CAM_CREDIT,\n\t\t       &elem->cmd_data.vlan_mac.vlan_mac_flags) ||\n\t    o->put_credit(o))) {\n\t\tBNX2X_ERR(\"Failed to return a credit\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic inline int bnx2x_validate_vlan_mac_move(struct bnx2x *bp,\n\t\t\t\t\t       union bnx2x_qable_obj *qo,\n\t\t\t\t\t       struct bnx2x_exeq_elem *elem)\n{\n\tstruct bnx2x_vlan_mac_obj *src_o = &qo->vlan_mac;\n\tstruct bnx2x_vlan_mac_obj *dest_o = elem->cmd_data.vlan_mac.target_obj;\n\tstruct bnx2x_exeq_elem query_elem;\n\tstruct bnx2x_exe_queue_obj *src_exeq = &src_o->exe_queue;\n\tstruct bnx2x_exe_queue_obj *dest_exeq = &dest_o->exe_queue;\n\n\t \n\tif (!src_o->check_move(bp, src_o, dest_o,\n\t\t\t       &elem->cmd_data.vlan_mac.u)) {\n\t\tDP(BNX2X_MSG_SP, \"MOVE command is not allowed considering current registry state\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tmemcpy(&query_elem, elem, sizeof(query_elem));\n\n\t \n\tquery_elem.cmd_data.vlan_mac.cmd = BNX2X_VLAN_MAC_DEL;\n\tif (src_exeq->get(src_exeq, &query_elem)) {\n\t\tBNX2X_ERR(\"There is a pending DEL command on the source queue already\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (src_exeq->get(src_exeq, elem)) {\n\t\tDP(BNX2X_MSG_SP, \"There is a pending MOVE command already\\n\");\n\t\treturn -EEXIST;\n\t}\n\n\t \n\tquery_elem.cmd_data.vlan_mac.cmd = BNX2X_VLAN_MAC_ADD;\n\tif (dest_exeq->get(dest_exeq, &query_elem)) {\n\t\tBNX2X_ERR(\"There is a pending ADD command on the destination queue already\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (!(test_bit(BNX2X_DONT_CONSUME_CAM_CREDIT_DEST,\n\t\t       &elem->cmd_data.vlan_mac.vlan_mac_flags) ||\n\t    dest_o->get_credit(dest_o)))\n\t\treturn -EINVAL;\n\n\tif (!(test_bit(BNX2X_DONT_CONSUME_CAM_CREDIT,\n\t\t       &elem->cmd_data.vlan_mac.vlan_mac_flags) ||\n\t    src_o->put_credit(src_o))) {\n\t\t \n\t\tdest_o->put_credit(dest_o);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int bnx2x_validate_vlan_mac(struct bnx2x *bp,\n\t\t\t\t   union bnx2x_qable_obj *qo,\n\t\t\t\t   struct bnx2x_exeq_elem *elem)\n{\n\tswitch (elem->cmd_data.vlan_mac.cmd) {\n\tcase BNX2X_VLAN_MAC_ADD:\n\t\treturn bnx2x_validate_vlan_mac_add(bp, qo, elem);\n\tcase BNX2X_VLAN_MAC_DEL:\n\t\treturn bnx2x_validate_vlan_mac_del(bp, qo, elem);\n\tcase BNX2X_VLAN_MAC_MOVE:\n\t\treturn bnx2x_validate_vlan_mac_move(bp, qo, elem);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int bnx2x_remove_vlan_mac(struct bnx2x *bp,\n\t\t\t\t  union bnx2x_qable_obj *qo,\n\t\t\t\t  struct bnx2x_exeq_elem *elem)\n{\n\tint rc = 0;\n\n\t \n\tif (test_bit(BNX2X_DONT_CONSUME_CAM_CREDIT,\n\t\t     &elem->cmd_data.vlan_mac.vlan_mac_flags))\n\t\treturn 0;\n\n\tswitch (elem->cmd_data.vlan_mac.cmd) {\n\tcase BNX2X_VLAN_MAC_ADD:\n\tcase BNX2X_VLAN_MAC_MOVE:\n\t\trc = qo->vlan_mac.put_credit(&qo->vlan_mac);\n\t\tbreak;\n\tcase BNX2X_VLAN_MAC_DEL:\n\t\trc = qo->vlan_mac.get_credit(&qo->vlan_mac);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (rc != true)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n \nstatic int bnx2x_wait_vlan_mac(struct bnx2x *bp,\n\t\t\t       struct bnx2x_vlan_mac_obj *o)\n{\n\tint cnt = 5000, rc;\n\tstruct bnx2x_exe_queue_obj *exeq = &o->exe_queue;\n\tstruct bnx2x_raw_obj *raw = &o->raw;\n\n\twhile (cnt--) {\n\t\t \n\t\trc = raw->wait_comp(bp, raw);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\t \n\t\tif (!bnx2x_exe_queue_empty(exeq))\n\t\t\tusleep_range(1000, 2000);\n\t\telse\n\t\t\treturn 0;\n\t}\n\n\treturn -EBUSY;\n}\n\nstatic int __bnx2x_vlan_mac_execute_step(struct bnx2x *bp,\n\t\t\t\t\t struct bnx2x_vlan_mac_obj *o,\n\t\t\t\t\t unsigned long *ramrod_flags)\n{\n\tint rc = 0;\n\n\tspin_lock_bh(&o->exe_queue.lock);\n\n\tDP(BNX2X_MSG_SP, \"vlan_mac_execute_step - trying to take writer lock\\n\");\n\trc = __bnx2x_vlan_mac_h_write_trylock(bp, o);\n\n\tif (rc != 0) {\n\t\t__bnx2x_vlan_mac_h_pend(bp, o, *ramrod_flags);\n\n\t\t \n\t\trc = 1;\n\t} else {\n\t\trc = bnx2x_exe_queue_step(bp, &o->exe_queue, ramrod_flags);\n\t}\n\tspin_unlock_bh(&o->exe_queue.lock);\n\n\treturn rc;\n}\n\n \nstatic int bnx2x_complete_vlan_mac(struct bnx2x *bp,\n\t\t\t\t   struct bnx2x_vlan_mac_obj *o,\n\t\t\t\t   union event_ring_elem *cqe,\n\t\t\t\t   unsigned long *ramrod_flags)\n{\n\tstruct bnx2x_raw_obj *r = &o->raw;\n\tint rc;\n\n\t \n\tspin_lock_bh(&o->exe_queue.lock);\n\n\t \n\t__bnx2x_exe_queue_reset_pending(bp, &o->exe_queue);\n\n\t \n\tr->clear_pending(r);\n\n\tspin_unlock_bh(&o->exe_queue.lock);\n\n\t \n\tif (cqe->message.error)\n\t\treturn -EINVAL;\n\n\t \n\tif (test_bit(RAMROD_CONT, ramrod_flags)) {\n\t\trc = __bnx2x_vlan_mac_execute_step(bp, o, ramrod_flags);\n\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t}\n\n\t \n\tif (!bnx2x_exe_queue_empty(&o->exe_queue))\n\t\treturn 1;\n\n\treturn 0;\n}\n\n \nstatic int bnx2x_optimize_vlan_mac(struct bnx2x *bp,\n\t\t\t\t   union bnx2x_qable_obj *qo,\n\t\t\t\t   struct bnx2x_exeq_elem *elem)\n{\n\tstruct bnx2x_exeq_elem query, *pos;\n\tstruct bnx2x_vlan_mac_obj *o = &qo->vlan_mac;\n\tstruct bnx2x_exe_queue_obj *exeq = &o->exe_queue;\n\n\tmemcpy(&query, elem, sizeof(query));\n\n\tswitch (elem->cmd_data.vlan_mac.cmd) {\n\tcase BNX2X_VLAN_MAC_ADD:\n\t\tquery.cmd_data.vlan_mac.cmd = BNX2X_VLAN_MAC_DEL;\n\t\tbreak;\n\tcase BNX2X_VLAN_MAC_DEL:\n\t\tquery.cmd_data.vlan_mac.cmd = BNX2X_VLAN_MAC_ADD;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\treturn 0;\n\t}\n\n\t \n\tpos = exeq->get(exeq, &query);\n\tif (pos) {\n\n\t\t \n\t\tif (!test_bit(BNX2X_DONT_CONSUME_CAM_CREDIT,\n\t\t\t      &pos->cmd_data.vlan_mac.vlan_mac_flags)) {\n\t\t\tif ((query.cmd_data.vlan_mac.cmd ==\n\t\t\t     BNX2X_VLAN_MAC_ADD) && !o->put_credit(o)) {\n\t\t\t\tBNX2X_ERR(\"Failed to return the credit for the optimized ADD command\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t} else if (!o->get_credit(o)) {  \n\t\t\t\tBNX2X_ERR(\"Failed to recover the credit from the optimized DEL command\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\tDP(BNX2X_MSG_SP, \"Optimizing %s command\\n\",\n\t\t\t   (elem->cmd_data.vlan_mac.cmd == BNX2X_VLAN_MAC_ADD) ?\n\t\t\t   \"ADD\" : \"DEL\");\n\n\t\tlist_del(&pos->link);\n\t\tbnx2x_exe_queue_free_elem(bp, pos);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n \nstatic inline int bnx2x_vlan_mac_get_registry_elem(\n\tstruct bnx2x *bp,\n\tstruct bnx2x_vlan_mac_obj *o,\n\tstruct bnx2x_exeq_elem *elem,\n\tbool restore,\n\tstruct bnx2x_vlan_mac_registry_elem **re)\n{\n\tenum bnx2x_vlan_mac_cmd cmd = elem->cmd_data.vlan_mac.cmd;\n\tstruct bnx2x_vlan_mac_registry_elem *reg_elem;\n\n\t \n\tif (!restore &&\n\t    ((cmd == BNX2X_VLAN_MAC_ADD) || (cmd == BNX2X_VLAN_MAC_MOVE))) {\n\t\treg_elem = kzalloc(sizeof(*reg_elem), GFP_ATOMIC);\n\t\tif (!reg_elem)\n\t\t\treturn -ENOMEM;\n\n\t\t \n\t\tif (!o->get_cam_offset(o, &reg_elem->cam_offset)) {\n\t\t\t \n\t\t\tWARN_ON(1);\n\t\t\tkfree(reg_elem);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tDP(BNX2X_MSG_SP, \"Got cam offset %d\\n\", reg_elem->cam_offset);\n\n\t\t \n\t\tmemcpy(&reg_elem->u, &elem->cmd_data.vlan_mac.u,\n\t\t\t  sizeof(reg_elem->u));\n\n\t\t \n\t\treg_elem->vlan_mac_flags =\n\t\t\telem->cmd_data.vlan_mac.vlan_mac_flags;\n\t} else  \n\t\treg_elem = o->check_del(bp, o, &elem->cmd_data.vlan_mac.u);\n\n\t*re = reg_elem;\n\treturn 0;\n}\n\n \nstatic int bnx2x_execute_vlan_mac(struct bnx2x *bp,\n\t\t\t\t  union bnx2x_qable_obj *qo,\n\t\t\t\t  struct list_head *exe_chunk,\n\t\t\t\t  unsigned long *ramrod_flags)\n{\n\tstruct bnx2x_exeq_elem *elem;\n\tstruct bnx2x_vlan_mac_obj *o = &qo->vlan_mac, *cam_obj;\n\tstruct bnx2x_raw_obj *r = &o->raw;\n\tint rc, idx = 0;\n\tbool restore = test_bit(RAMROD_RESTORE, ramrod_flags);\n\tbool drv_only = test_bit(RAMROD_DRV_CLR_ONLY, ramrod_flags);\n\tstruct bnx2x_vlan_mac_registry_elem *reg_elem;\n\tenum bnx2x_vlan_mac_cmd cmd;\n\n\t \n\tif (!drv_only) {\n\t\tWARN_ON(r->check_pending(r));\n\n\t\t \n\t\tr->set_pending(r);\n\n\t\t \n\t\tlist_for_each_entry(elem, exe_chunk, link) {\n\t\t\tcmd = elem->cmd_data.vlan_mac.cmd;\n\t\t\t \n\t\t\tif (cmd == BNX2X_VLAN_MAC_MOVE)\n\t\t\t\tcam_obj = elem->cmd_data.vlan_mac.target_obj;\n\t\t\telse\n\t\t\t\tcam_obj = o;\n\n\t\t\trc = bnx2x_vlan_mac_get_registry_elem(bp, cam_obj,\n\t\t\t\t\t\t\t      elem, restore,\n\t\t\t\t\t\t\t      &reg_elem);\n\t\t\tif (rc)\n\t\t\t\tgoto error_exit;\n\n\t\t\tWARN_ON(!reg_elem);\n\n\t\t\t \n\t\t\tif (!restore &&\n\t\t\t    ((cmd == BNX2X_VLAN_MAC_ADD) ||\n\t\t\t    (cmd == BNX2X_VLAN_MAC_MOVE)))\n\t\t\t\tlist_add(&reg_elem->link, &cam_obj->head);\n\n\t\t\t \n\t\t\to->set_one_rule(bp, o, elem, idx,\n\t\t\t\t\treg_elem->cam_offset);\n\n\t\t\t \n\t\t\tif (cmd == BNX2X_VLAN_MAC_MOVE)\n\t\t\t\tidx += 2;\n\t\t\telse\n\t\t\t\tidx++;\n\t\t}\n\n\t\t \n\n\t\trc = bnx2x_sp_post(bp, o->ramrod_cmd, r->cid,\n\t\t\t\t   U64_HI(r->rdata_mapping),\n\t\t\t\t   U64_LO(r->rdata_mapping),\n\t\t\t\t   ETH_CONNECTION_TYPE);\n\t\tif (rc)\n\t\t\tgoto error_exit;\n\t}\n\n\t \n\tlist_for_each_entry(elem, exe_chunk, link) {\n\t\tcmd = elem->cmd_data.vlan_mac.cmd;\n\t\tif ((cmd == BNX2X_VLAN_MAC_DEL) ||\n\t\t    (cmd == BNX2X_VLAN_MAC_MOVE)) {\n\t\t\treg_elem = o->check_del(bp, o,\n\t\t\t\t\t\t&elem->cmd_data.vlan_mac.u);\n\n\t\t\tWARN_ON(!reg_elem);\n\n\t\t\to->put_cam_offset(o, reg_elem->cam_offset);\n\t\t\tlist_del(&reg_elem->link);\n\t\t\tkfree(reg_elem);\n\t\t}\n\t}\n\n\tif (!drv_only)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n\nerror_exit:\n\tr->clear_pending(r);\n\n\t \n\tlist_for_each_entry(elem, exe_chunk, link) {\n\t\tcmd = elem->cmd_data.vlan_mac.cmd;\n\n\t\tif (cmd == BNX2X_VLAN_MAC_MOVE)\n\t\t\tcam_obj = elem->cmd_data.vlan_mac.target_obj;\n\t\telse\n\t\t\tcam_obj = o;\n\n\t\t \n\t\tif (!restore &&\n\t\t    ((cmd == BNX2X_VLAN_MAC_ADD) ||\n\t\t    (cmd == BNX2X_VLAN_MAC_MOVE))) {\n\t\t\treg_elem = o->check_del(bp, cam_obj,\n\t\t\t\t\t\t&elem->cmd_data.vlan_mac.u);\n\t\t\tif (reg_elem) {\n\t\t\t\tlist_del(&reg_elem->link);\n\t\t\t\tkfree(reg_elem);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn rc;\n}\n\nstatic inline int bnx2x_vlan_mac_push_new_cmd(\n\tstruct bnx2x *bp,\n\tstruct bnx2x_vlan_mac_ramrod_params *p)\n{\n\tstruct bnx2x_exeq_elem *elem;\n\tstruct bnx2x_vlan_mac_obj *o = p->vlan_mac_obj;\n\tbool restore = test_bit(RAMROD_RESTORE, &p->ramrod_flags);\n\n\t \n\telem = bnx2x_exe_queue_alloc_elem(bp);\n\tif (!elem)\n\t\treturn -ENOMEM;\n\n\t \n\tswitch (p->user_req.cmd) {\n\tcase BNX2X_VLAN_MAC_MOVE:\n\t\telem->cmd_len = 2;\n\t\tbreak;\n\tdefault:\n\t\telem->cmd_len = 1;\n\t}\n\n\t \n\tmemcpy(&elem->cmd_data.vlan_mac, &p->user_req, sizeof(p->user_req));\n\n\t \n\treturn bnx2x_exe_queue_add(bp, &o->exe_queue, elem, restore);\n}\n\n \nint bnx2x_config_vlan_mac(struct bnx2x *bp,\n\t\t\t   struct bnx2x_vlan_mac_ramrod_params *p)\n{\n\tint rc = 0;\n\tstruct bnx2x_vlan_mac_obj *o = p->vlan_mac_obj;\n\tunsigned long *ramrod_flags = &p->ramrod_flags;\n\tbool cont = test_bit(RAMROD_CONT, ramrod_flags);\n\tstruct bnx2x_raw_obj *raw = &o->raw;\n\n\t \n\tif (!cont) {\n\t\trc = bnx2x_vlan_mac_push_new_cmd(bp, p);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\t \n\tif (!bnx2x_exe_queue_empty(&o->exe_queue))\n\t\trc = 1;\n\n\tif (test_bit(RAMROD_DRV_CLR_ONLY, ramrod_flags))  {\n\t\tDP(BNX2X_MSG_SP, \"RAMROD_DRV_CLR_ONLY requested: clearing a pending bit.\\n\");\n\t\traw->clear_pending(raw);\n\t}\n\n\t \n\tif (cont || test_bit(RAMROD_EXEC, ramrod_flags) ||\n\t    test_bit(RAMROD_COMP_WAIT, ramrod_flags)) {\n\t\trc = __bnx2x_vlan_mac_execute_step(bp, p->vlan_mac_obj,\n\t\t\t\t\t\t   &p->ramrod_flags);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t}\n\n\t \n\tif (test_bit(RAMROD_COMP_WAIT, &p->ramrod_flags)) {\n\t\t \n\t\tint max_iterations = bnx2x_exe_queue_length(&o->exe_queue) + 1;\n\n\t\twhile (!bnx2x_exe_queue_empty(&o->exe_queue) &&\n\t\t       max_iterations--) {\n\n\t\t\t \n\t\t\trc = raw->wait_comp(bp, raw);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\n\t\t\t \n\t\t\trc = __bnx2x_vlan_mac_execute_step(bp,\n\t\t\t\t\t\t\t   p->vlan_mac_obj,\n\t\t\t\t\t\t\t   &p->ramrod_flags);\n\t\t\tif (rc < 0)\n\t\t\t\treturn rc;\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\treturn rc;\n}\n\n \nstatic int bnx2x_vlan_mac_del_all(struct bnx2x *bp,\n\t\t\t\t  struct bnx2x_vlan_mac_obj *o,\n\t\t\t\t  unsigned long *vlan_mac_flags,\n\t\t\t\t  unsigned long *ramrod_flags)\n{\n\tstruct bnx2x_vlan_mac_registry_elem *pos = NULL;\n\tstruct bnx2x_vlan_mac_ramrod_params p;\n\tstruct bnx2x_exe_queue_obj *exeq = &o->exe_queue;\n\tstruct bnx2x_exeq_elem *exeq_pos, *exeq_pos_n;\n\tunsigned long flags;\n\tint read_lock;\n\tint rc = 0;\n\n\t \n\n\tspin_lock_bh(&exeq->lock);\n\n\tlist_for_each_entry_safe(exeq_pos, exeq_pos_n, &exeq->exe_queue, link) {\n\t\tflags = exeq_pos->cmd_data.vlan_mac.vlan_mac_flags;\n\t\tif (BNX2X_VLAN_MAC_CMP_FLAGS(flags) ==\n\t\t    BNX2X_VLAN_MAC_CMP_FLAGS(*vlan_mac_flags)) {\n\t\t\trc = exeq->remove(bp, exeq->owner, exeq_pos);\n\t\t\tif (rc) {\n\t\t\t\tBNX2X_ERR(\"Failed to remove command\\n\");\n\t\t\t\tspin_unlock_bh(&exeq->lock);\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t\tlist_del(&exeq_pos->link);\n\t\t\tbnx2x_exe_queue_free_elem(bp, exeq_pos);\n\t\t}\n\t}\n\n\tspin_unlock_bh(&exeq->lock);\n\n\t \n\tmemset(&p, 0, sizeof(p));\n\tp.vlan_mac_obj = o;\n\tp.ramrod_flags = *ramrod_flags;\n\tp.user_req.cmd = BNX2X_VLAN_MAC_DEL;\n\n\t \n\t__clear_bit(RAMROD_COMP_WAIT, &p.ramrod_flags);\n\t__clear_bit(RAMROD_EXEC, &p.ramrod_flags);\n\t__clear_bit(RAMROD_CONT, &p.ramrod_flags);\n\n\tDP(BNX2X_MSG_SP, \"vlan_mac_del_all -- taking vlan_mac_lock (reader)\\n\");\n\tread_lock = bnx2x_vlan_mac_h_read_lock(bp, o);\n\tif (read_lock != 0)\n\t\treturn read_lock;\n\n\tlist_for_each_entry(pos, &o->head, link) {\n\t\tflags = pos->vlan_mac_flags;\n\t\tif (BNX2X_VLAN_MAC_CMP_FLAGS(flags) ==\n\t\t    BNX2X_VLAN_MAC_CMP_FLAGS(*vlan_mac_flags)) {\n\t\t\tp.user_req.vlan_mac_flags = pos->vlan_mac_flags;\n\t\t\tmemcpy(&p.user_req.u, &pos->u, sizeof(pos->u));\n\t\t\trc = bnx2x_config_vlan_mac(bp, &p);\n\t\t\tif (rc < 0) {\n\t\t\t\tBNX2X_ERR(\"Failed to add a new DEL command\\n\");\n\t\t\t\tbnx2x_vlan_mac_h_read_unlock(bp, o);\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\t}\n\n\tDP(BNX2X_MSG_SP, \"vlan_mac_del_all -- releasing vlan_mac_lock (reader)\\n\");\n\tbnx2x_vlan_mac_h_read_unlock(bp, o);\n\n\tp.ramrod_flags = *ramrod_flags;\n\t__set_bit(RAMROD_CONT, &p.ramrod_flags);\n\n\treturn bnx2x_config_vlan_mac(bp, &p);\n}\n\nstatic inline void bnx2x_init_raw_obj(struct bnx2x_raw_obj *raw, u8 cl_id,\n\tu32 cid, u8 func_id, void *rdata, dma_addr_t rdata_mapping, int state,\n\tunsigned long *pstate, bnx2x_obj_type type)\n{\n\traw->func_id = func_id;\n\traw->cid = cid;\n\traw->cl_id = cl_id;\n\traw->rdata = rdata;\n\traw->rdata_mapping = rdata_mapping;\n\traw->state = state;\n\traw->pstate = pstate;\n\traw->obj_type = type;\n\traw->check_pending = bnx2x_raw_check_pending;\n\traw->clear_pending = bnx2x_raw_clear_pending;\n\traw->set_pending = bnx2x_raw_set_pending;\n\traw->wait_comp = bnx2x_raw_wait;\n}\n\nstatic inline void bnx2x_init_vlan_mac_common(struct bnx2x_vlan_mac_obj *o,\n\tu8 cl_id, u32 cid, u8 func_id, void *rdata, dma_addr_t rdata_mapping,\n\tint state, unsigned long *pstate, bnx2x_obj_type type,\n\tstruct bnx2x_credit_pool_obj *macs_pool,\n\tstruct bnx2x_credit_pool_obj *vlans_pool)\n{\n\tINIT_LIST_HEAD(&o->head);\n\to->head_reader = 0;\n\to->head_exe_request = false;\n\to->saved_ramrod_flags = 0;\n\n\to->macs_pool = macs_pool;\n\to->vlans_pool = vlans_pool;\n\n\to->delete_all = bnx2x_vlan_mac_del_all;\n\to->restore = bnx2x_vlan_mac_restore;\n\to->complete = bnx2x_complete_vlan_mac;\n\to->wait = bnx2x_wait_vlan_mac;\n\n\tbnx2x_init_raw_obj(&o->raw, cl_id, cid, func_id, rdata, rdata_mapping,\n\t\t\t   state, pstate, type);\n}\n\nvoid bnx2x_init_mac_obj(struct bnx2x *bp,\n\t\t\tstruct bnx2x_vlan_mac_obj *mac_obj,\n\t\t\tu8 cl_id, u32 cid, u8 func_id, void *rdata,\n\t\t\tdma_addr_t rdata_mapping, int state,\n\t\t\tunsigned long *pstate, bnx2x_obj_type type,\n\t\t\tstruct bnx2x_credit_pool_obj *macs_pool)\n{\n\tunion bnx2x_qable_obj *qable_obj = (union bnx2x_qable_obj *)mac_obj;\n\n\tbnx2x_init_vlan_mac_common(mac_obj, cl_id, cid, func_id, rdata,\n\t\t\t\t   rdata_mapping, state, pstate, type,\n\t\t\t\t   macs_pool, NULL);\n\n\t \n\tmac_obj->get_credit = bnx2x_get_credit_mac;\n\tmac_obj->put_credit = bnx2x_put_credit_mac;\n\tmac_obj->get_cam_offset = bnx2x_get_cam_offset_mac;\n\tmac_obj->put_cam_offset = bnx2x_put_cam_offset_mac;\n\n\tif (CHIP_IS_E1x(bp)) {\n\t\tmac_obj->set_one_rule      = bnx2x_set_one_mac_e1x;\n\t\tmac_obj->check_del         = bnx2x_check_mac_del;\n\t\tmac_obj->check_add         = bnx2x_check_mac_add;\n\t\tmac_obj->check_move        = bnx2x_check_move_always_err;\n\t\tmac_obj->ramrod_cmd        = RAMROD_CMD_ID_ETH_SET_MAC;\n\n\t\t \n\t\tbnx2x_exe_queue_init(bp,\n\t\t\t\t     &mac_obj->exe_queue, 1, qable_obj,\n\t\t\t\t     bnx2x_validate_vlan_mac,\n\t\t\t\t     bnx2x_remove_vlan_mac,\n\t\t\t\t     bnx2x_optimize_vlan_mac,\n\t\t\t\t     bnx2x_execute_vlan_mac,\n\t\t\t\t     bnx2x_exeq_get_mac);\n\t} else {\n\t\tmac_obj->set_one_rule      = bnx2x_set_one_mac_e2;\n\t\tmac_obj->check_del         = bnx2x_check_mac_del;\n\t\tmac_obj->check_add         = bnx2x_check_mac_add;\n\t\tmac_obj->check_move        = bnx2x_check_move;\n\t\tmac_obj->ramrod_cmd        =\n\t\t\tRAMROD_CMD_ID_ETH_CLASSIFICATION_RULES;\n\t\tmac_obj->get_n_elements    = bnx2x_get_n_elements;\n\n\t\t \n\t\tbnx2x_exe_queue_init(bp,\n\t\t\t\t     &mac_obj->exe_queue, CLASSIFY_RULES_COUNT,\n\t\t\t\t     qable_obj, bnx2x_validate_vlan_mac,\n\t\t\t\t     bnx2x_remove_vlan_mac,\n\t\t\t\t     bnx2x_optimize_vlan_mac,\n\t\t\t\t     bnx2x_execute_vlan_mac,\n\t\t\t\t     bnx2x_exeq_get_mac);\n\t}\n}\n\nvoid bnx2x_init_vlan_obj(struct bnx2x *bp,\n\t\t\t struct bnx2x_vlan_mac_obj *vlan_obj,\n\t\t\t u8 cl_id, u32 cid, u8 func_id, void *rdata,\n\t\t\t dma_addr_t rdata_mapping, int state,\n\t\t\t unsigned long *pstate, bnx2x_obj_type type,\n\t\t\t struct bnx2x_credit_pool_obj *vlans_pool)\n{\n\tunion bnx2x_qable_obj *qable_obj = (union bnx2x_qable_obj *)vlan_obj;\n\n\tbnx2x_init_vlan_mac_common(vlan_obj, cl_id, cid, func_id, rdata,\n\t\t\t\t   rdata_mapping, state, pstate, type, NULL,\n\t\t\t\t   vlans_pool);\n\n\tvlan_obj->get_credit = bnx2x_get_credit_vlan;\n\tvlan_obj->put_credit = bnx2x_put_credit_vlan;\n\tvlan_obj->get_cam_offset = bnx2x_get_cam_offset_vlan;\n\tvlan_obj->put_cam_offset = bnx2x_put_cam_offset_vlan;\n\n\tif (CHIP_IS_E1x(bp)) {\n\t\tBNX2X_ERR(\"Do not support chips others than E2 and newer\\n\");\n\t\tBUG();\n\t} else {\n\t\tvlan_obj->set_one_rule      = bnx2x_set_one_vlan_e2;\n\t\tvlan_obj->check_del         = bnx2x_check_vlan_del;\n\t\tvlan_obj->check_add         = bnx2x_check_vlan_add;\n\t\tvlan_obj->check_move        = bnx2x_check_move;\n\t\tvlan_obj->ramrod_cmd        =\n\t\t\tRAMROD_CMD_ID_ETH_CLASSIFICATION_RULES;\n\t\tvlan_obj->get_n_elements    = bnx2x_get_n_elements;\n\n\t\t \n\t\tbnx2x_exe_queue_init(bp,\n\t\t\t\t     &vlan_obj->exe_queue, CLASSIFY_RULES_COUNT,\n\t\t\t\t     qable_obj, bnx2x_validate_vlan_mac,\n\t\t\t\t     bnx2x_remove_vlan_mac,\n\t\t\t\t     bnx2x_optimize_vlan_mac,\n\t\t\t\t     bnx2x_execute_vlan_mac,\n\t\t\t\t     bnx2x_exeq_get_vlan);\n\t}\n}\n\nvoid bnx2x_init_vlan_mac_obj(struct bnx2x *bp,\n\t\t\t     struct bnx2x_vlan_mac_obj *vlan_mac_obj,\n\t\t\t     u8 cl_id, u32 cid, u8 func_id, void *rdata,\n\t\t\t     dma_addr_t rdata_mapping, int state,\n\t\t\t     unsigned long *pstate, bnx2x_obj_type type,\n\t\t\t     struct bnx2x_credit_pool_obj *macs_pool,\n\t\t\t     struct bnx2x_credit_pool_obj *vlans_pool)\n{\n\tunion bnx2x_qable_obj *qable_obj =\n\t\t(union bnx2x_qable_obj *)vlan_mac_obj;\n\n\tbnx2x_init_vlan_mac_common(vlan_mac_obj, cl_id, cid, func_id, rdata,\n\t\t\t\t   rdata_mapping, state, pstate, type,\n\t\t\t\t   macs_pool, vlans_pool);\n\n\t \n\tvlan_mac_obj->get_credit = bnx2x_get_credit_vlan_mac;\n\tvlan_mac_obj->put_credit = bnx2x_put_credit_vlan_mac;\n\t \n\tvlan_mac_obj->get_cam_offset = bnx2x_get_cam_offset_mac;\n\tvlan_mac_obj->put_cam_offset = bnx2x_put_cam_offset_mac;\n\n\tif (CHIP_IS_E1(bp)) {\n\t\tBNX2X_ERR(\"Do not support chips others than E2\\n\");\n\t\tBUG();\n\t} else if (CHIP_IS_E1H(bp)) {\n\t\tvlan_mac_obj->set_one_rule      = bnx2x_set_one_vlan_mac_e1h;\n\t\tvlan_mac_obj->check_del         = bnx2x_check_vlan_mac_del;\n\t\tvlan_mac_obj->check_add         = bnx2x_check_vlan_mac_add;\n\t\tvlan_mac_obj->check_move        = bnx2x_check_move_always_err;\n\t\tvlan_mac_obj->ramrod_cmd        = RAMROD_CMD_ID_ETH_SET_MAC;\n\n\t\t \n\t\tbnx2x_exe_queue_init(bp,\n\t\t\t\t     &vlan_mac_obj->exe_queue, 1, qable_obj,\n\t\t\t\t     bnx2x_validate_vlan_mac,\n\t\t\t\t     bnx2x_remove_vlan_mac,\n\t\t\t\t     bnx2x_optimize_vlan_mac,\n\t\t\t\t     bnx2x_execute_vlan_mac,\n\t\t\t\t     bnx2x_exeq_get_vlan_mac);\n\t} else {\n\t\tvlan_mac_obj->set_one_rule      = bnx2x_set_one_vlan_mac_e2;\n\t\tvlan_mac_obj->check_del         = bnx2x_check_vlan_mac_del;\n\t\tvlan_mac_obj->check_add         = bnx2x_check_vlan_mac_add;\n\t\tvlan_mac_obj->check_move        = bnx2x_check_move;\n\t\tvlan_mac_obj->ramrod_cmd        =\n\t\t\tRAMROD_CMD_ID_ETH_CLASSIFICATION_RULES;\n\n\t\t \n\t\tbnx2x_exe_queue_init(bp,\n\t\t\t\t     &vlan_mac_obj->exe_queue,\n\t\t\t\t     CLASSIFY_RULES_COUNT,\n\t\t\t\t     qable_obj, bnx2x_validate_vlan_mac,\n\t\t\t\t     bnx2x_remove_vlan_mac,\n\t\t\t\t     bnx2x_optimize_vlan_mac,\n\t\t\t\t     bnx2x_execute_vlan_mac,\n\t\t\t\t     bnx2x_exeq_get_vlan_mac);\n\t}\n}\n \nstatic inline void __storm_memset_mac_filters(struct bnx2x *bp,\n\t\t\tstruct tstorm_eth_mac_filter_config *mac_filters,\n\t\t\tu16 pf_id)\n{\n\tsize_t size = sizeof(struct tstorm_eth_mac_filter_config);\n\n\tu32 addr = BAR_TSTRORM_INTMEM +\n\t\t\tTSTORM_MAC_FILTER_CONFIG_OFFSET(pf_id);\n\n\t__storm_memset_struct(bp, addr, size, (u32 *)mac_filters);\n}\n\nstatic int bnx2x_set_rx_mode_e1x(struct bnx2x *bp,\n\t\t\t\t struct bnx2x_rx_mode_ramrod_params *p)\n{\n\t \n\tu32 mask = (1 << p->cl_id);\n\n\tstruct tstorm_eth_mac_filter_config *mac_filters =\n\t\t(struct tstorm_eth_mac_filter_config *)p->rdata;\n\n\t \n\tu8 drop_all_ucast = 1, drop_all_mcast = 1;\n\tu8 accp_all_ucast = 0, accp_all_bcast = 0, accp_all_mcast = 0;\n\tu8 unmatched_unicast = 0;\n\n     \n\tif (test_bit(BNX2X_ACCEPT_UNICAST, &p->rx_accept_flags))\n\t\t \n\t\tdrop_all_ucast = 0;\n\n\tif (test_bit(BNX2X_ACCEPT_MULTICAST, &p->rx_accept_flags))\n\t\t \n\t\tdrop_all_mcast = 0;\n\n\tif (test_bit(BNX2X_ACCEPT_ALL_UNICAST, &p->rx_accept_flags)) {\n\t\t \n\t\tdrop_all_ucast = 0;\n\t\taccp_all_ucast = 1;\n\t}\n\tif (test_bit(BNX2X_ACCEPT_ALL_MULTICAST, &p->rx_accept_flags)) {\n\t\t \n\t\tdrop_all_mcast = 0;\n\t\taccp_all_mcast = 1;\n\t}\n\tif (test_bit(BNX2X_ACCEPT_BROADCAST, &p->rx_accept_flags))\n\t\t \n\t\taccp_all_bcast = 1;\n\tif (test_bit(BNX2X_ACCEPT_UNMATCHED, &p->rx_accept_flags))\n\t\t \n\t\tunmatched_unicast = 1;\n\n\tmac_filters->ucast_drop_all = drop_all_ucast ?\n\t\tmac_filters->ucast_drop_all | mask :\n\t\tmac_filters->ucast_drop_all & ~mask;\n\n\tmac_filters->mcast_drop_all = drop_all_mcast ?\n\t\tmac_filters->mcast_drop_all | mask :\n\t\tmac_filters->mcast_drop_all & ~mask;\n\n\tmac_filters->ucast_accept_all = accp_all_ucast ?\n\t\tmac_filters->ucast_accept_all | mask :\n\t\tmac_filters->ucast_accept_all & ~mask;\n\n\tmac_filters->mcast_accept_all = accp_all_mcast ?\n\t\tmac_filters->mcast_accept_all | mask :\n\t\tmac_filters->mcast_accept_all & ~mask;\n\n\tmac_filters->bcast_accept_all = accp_all_bcast ?\n\t\tmac_filters->bcast_accept_all | mask :\n\t\tmac_filters->bcast_accept_all & ~mask;\n\n\tmac_filters->unmatched_unicast = unmatched_unicast ?\n\t\tmac_filters->unmatched_unicast | mask :\n\t\tmac_filters->unmatched_unicast & ~mask;\n\n\tDP(BNX2X_MSG_SP, \"drop_ucast 0x%x\\ndrop_mcast 0x%x\\n accp_ucast 0x%x\\n\"\n\t\t\t \"accp_mcast 0x%x\\naccp_bcast 0x%x\\n\",\n\t   mac_filters->ucast_drop_all, mac_filters->mcast_drop_all,\n\t   mac_filters->ucast_accept_all, mac_filters->mcast_accept_all,\n\t   mac_filters->bcast_accept_all);\n\n\t \n\t__storm_memset_mac_filters(bp, mac_filters, p->func_id);\n\n\t \n\tclear_bit(p->state, p->pstate);\n\tsmp_mb__after_atomic();\n\n\treturn 0;\n}\n\n \nstatic inline void bnx2x_rx_mode_set_rdata_hdr_e2(u32 cid,\n\t\t\t\tstruct eth_classify_header *hdr,\n\t\t\t\tu8 rule_cnt)\n{\n\thdr->echo = cpu_to_le32(cid);\n\thdr->rule_cnt = rule_cnt;\n}\n\nstatic inline void bnx2x_rx_mode_set_cmd_state_e2(struct bnx2x *bp,\n\t\t\t\tunsigned long *accept_flags,\n\t\t\t\tstruct eth_filter_rules_cmd *cmd,\n\t\t\t\tbool clear_accept_all)\n{\n\tu16 state;\n\n\t \n\tstate = ETH_FILTER_RULES_CMD_UCAST_DROP_ALL |\n\t\tETH_FILTER_RULES_CMD_MCAST_DROP_ALL;\n\n\tif (test_bit(BNX2X_ACCEPT_UNICAST, accept_flags))\n\t\tstate &= ~ETH_FILTER_RULES_CMD_UCAST_DROP_ALL;\n\n\tif (test_bit(BNX2X_ACCEPT_MULTICAST, accept_flags))\n\t\tstate &= ~ETH_FILTER_RULES_CMD_MCAST_DROP_ALL;\n\n\tif (test_bit(BNX2X_ACCEPT_ALL_UNICAST, accept_flags)) {\n\t\tstate &= ~ETH_FILTER_RULES_CMD_UCAST_DROP_ALL;\n\t\tstate |= ETH_FILTER_RULES_CMD_UCAST_ACCEPT_ALL;\n\t}\n\n\tif (test_bit(BNX2X_ACCEPT_ALL_MULTICAST, accept_flags)) {\n\t\tstate |= ETH_FILTER_RULES_CMD_MCAST_ACCEPT_ALL;\n\t\tstate &= ~ETH_FILTER_RULES_CMD_MCAST_DROP_ALL;\n\t}\n\n\tif (test_bit(BNX2X_ACCEPT_BROADCAST, accept_flags))\n\t\tstate |= ETH_FILTER_RULES_CMD_BCAST_ACCEPT_ALL;\n\n\tif (test_bit(BNX2X_ACCEPT_UNMATCHED, accept_flags)) {\n\t\tstate &= ~ETH_FILTER_RULES_CMD_UCAST_DROP_ALL;\n\t\tstate |= ETH_FILTER_RULES_CMD_UCAST_ACCEPT_UNMATCHED;\n\t}\n\n\tif (test_bit(BNX2X_ACCEPT_ANY_VLAN, accept_flags))\n\t\tstate |= ETH_FILTER_RULES_CMD_ACCEPT_ANY_VLAN;\n\n\t \n\tif (clear_accept_all) {\n\t\tstate &= ~ETH_FILTER_RULES_CMD_MCAST_ACCEPT_ALL;\n\t\tstate &= ~ETH_FILTER_RULES_CMD_BCAST_ACCEPT_ALL;\n\t\tstate &= ~ETH_FILTER_RULES_CMD_UCAST_ACCEPT_ALL;\n\t\tstate &= ~ETH_FILTER_RULES_CMD_UCAST_ACCEPT_UNMATCHED;\n\t}\n\n\tcmd->state = cpu_to_le16(state);\n}\n\nstatic int bnx2x_set_rx_mode_e2(struct bnx2x *bp,\n\t\t\t\tstruct bnx2x_rx_mode_ramrod_params *p)\n{\n\tstruct eth_filter_rules_ramrod_data *data = p->rdata;\n\tint rc;\n\tu8 rule_idx = 0;\n\n\t \n\tmemset(data, 0, sizeof(*data));\n\n\t \n\n\t \n\tif (test_bit(RAMROD_TX, &p->ramrod_flags)) {\n\t\tdata->rules[rule_idx].client_id = p->cl_id;\n\t\tdata->rules[rule_idx].func_id = p->func_id;\n\n\t\tdata->rules[rule_idx].cmd_general_data =\n\t\t\tETH_FILTER_RULES_CMD_TX_CMD;\n\n\t\tbnx2x_rx_mode_set_cmd_state_e2(bp, &p->tx_accept_flags,\n\t\t\t\t\t       &(data->rules[rule_idx++]),\n\t\t\t\t\t       false);\n\t}\n\n\t \n\tif (test_bit(RAMROD_RX, &p->ramrod_flags)) {\n\t\tdata->rules[rule_idx].client_id = p->cl_id;\n\t\tdata->rules[rule_idx].func_id = p->func_id;\n\n\t\tdata->rules[rule_idx].cmd_general_data =\n\t\t\tETH_FILTER_RULES_CMD_RX_CMD;\n\n\t\tbnx2x_rx_mode_set_cmd_state_e2(bp, &p->rx_accept_flags,\n\t\t\t\t\t       &(data->rules[rule_idx++]),\n\t\t\t\t\t       false);\n\t}\n\n\t \n\tif (test_bit(BNX2X_RX_MODE_FCOE_ETH, &p->rx_mode_flags)) {\n\t\t \n\t\tif (test_bit(RAMROD_TX, &p->ramrod_flags)) {\n\t\t\tdata->rules[rule_idx].client_id = bnx2x_fcoe(bp, cl_id);\n\t\t\tdata->rules[rule_idx].func_id = p->func_id;\n\n\t\t\tdata->rules[rule_idx].cmd_general_data =\n\t\t\t\t\t\tETH_FILTER_RULES_CMD_TX_CMD;\n\n\t\t\tbnx2x_rx_mode_set_cmd_state_e2(bp, &p->tx_accept_flags,\n\t\t\t\t\t\t       &(data->rules[rule_idx]),\n\t\t\t\t\t\t       true);\n\t\t\trule_idx++;\n\t\t}\n\n\t\t \n\t\tif (test_bit(RAMROD_RX, &p->ramrod_flags)) {\n\t\t\tdata->rules[rule_idx].client_id = bnx2x_fcoe(bp, cl_id);\n\t\t\tdata->rules[rule_idx].func_id = p->func_id;\n\n\t\t\tdata->rules[rule_idx].cmd_general_data =\n\t\t\t\t\t\tETH_FILTER_RULES_CMD_RX_CMD;\n\n\t\t\tbnx2x_rx_mode_set_cmd_state_e2(bp, &p->rx_accept_flags,\n\t\t\t\t\t\t       &(data->rules[rule_idx]),\n\t\t\t\t\t\t       true);\n\t\t\trule_idx++;\n\t\t}\n\t}\n\n\t \n\tbnx2x_rx_mode_set_rdata_hdr_e2(p->cid, &data->header, rule_idx);\n\n\tDP(BNX2X_MSG_SP, \"About to configure %d rules, rx_accept_flags 0x%lx, tx_accept_flags 0x%lx\\n\",\n\t\t\t data->header.rule_cnt, p->rx_accept_flags,\n\t\t\t p->tx_accept_flags);\n\n\t \n\n\t \n\trc = bnx2x_sp_post(bp, RAMROD_CMD_ID_ETH_FILTER_RULES, p->cid,\n\t\t\t   U64_HI(p->rdata_mapping),\n\t\t\t   U64_LO(p->rdata_mapping),\n\t\t\t   ETH_CONNECTION_TYPE);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\treturn 1;\n}\n\nstatic int bnx2x_wait_rx_mode_comp_e2(struct bnx2x *bp,\n\t\t\t\t      struct bnx2x_rx_mode_ramrod_params *p)\n{\n\treturn bnx2x_state_wait(bp, p->state, p->pstate);\n}\n\nstatic int bnx2x_empty_rx_mode_wait(struct bnx2x *bp,\n\t\t\t\t    struct bnx2x_rx_mode_ramrod_params *p)\n{\n\t \n\treturn 0;\n}\n\nint bnx2x_config_rx_mode(struct bnx2x *bp,\n\t\t\t struct bnx2x_rx_mode_ramrod_params *p)\n{\n\tint rc;\n\n\t \n\trc = p->rx_mode_obj->config_rx_mode(bp, p);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t \n\tif (test_bit(RAMROD_COMP_WAIT, &p->ramrod_flags)) {\n\t\trc = p->rx_mode_obj->wait_comp(bp, p);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\treturn rc;\n}\n\nvoid bnx2x_init_rx_mode_obj(struct bnx2x *bp,\n\t\t\t    struct bnx2x_rx_mode_obj *o)\n{\n\tif (CHIP_IS_E1x(bp)) {\n\t\to->wait_comp      = bnx2x_empty_rx_mode_wait;\n\t\to->config_rx_mode = bnx2x_set_rx_mode_e1x;\n\t} else {\n\t\to->wait_comp      = bnx2x_wait_rx_mode_comp_e2;\n\t\to->config_rx_mode = bnx2x_set_rx_mode_e2;\n\t}\n}\n\n \nstatic inline u8 bnx2x_mcast_bin_from_mac(u8 *mac)\n{\n\treturn (crc32c_le(0, mac, ETH_ALEN) >> 24) & 0xff;\n}\n\nstruct bnx2x_mcast_mac_elem {\n\tstruct list_head link;\n\tu8 mac[ETH_ALEN];\n\tu8 pad[2];  \n};\n\nstruct bnx2x_mcast_bin_elem {\n\tstruct list_head link;\n\tint bin;\n\tint type;  \n};\n\nunion bnx2x_mcast_elem {\n\tstruct bnx2x_mcast_bin_elem bin_elem;\n\tstruct bnx2x_mcast_mac_elem mac_elem;\n};\n\nstruct bnx2x_mcast_elem_group {\n\tstruct list_head mcast_group_link;\n\tunion bnx2x_mcast_elem mcast_elems[];\n};\n\n#define MCAST_MAC_ELEMS_PER_PG \\\n\t((PAGE_SIZE - sizeof(struct bnx2x_mcast_elem_group)) / \\\n\tsizeof(union bnx2x_mcast_elem))\n\nstruct bnx2x_pending_mcast_cmd {\n\tstruct list_head link;\n\tstruct list_head group_head;\n\tint type;  \n\tunion {\n\t\tstruct list_head macs_head;\n\t\tu32 macs_num;  \n\t\tint next_bin;  \n\t} data;\n\n\tbool set_convert;  \n\n\tbool done;  \n};\n\nstatic int bnx2x_mcast_wait(struct bnx2x *bp,\n\t\t\t    struct bnx2x_mcast_obj *o)\n{\n\tif (bnx2x_state_wait(bp, o->sched_state, o->raw.pstate) ||\n\t\t\to->raw.wait_comp(bp, &o->raw))\n\t\treturn -EBUSY;\n\n\treturn 0;\n}\n\nstatic void bnx2x_free_groups(struct list_head *mcast_group_list)\n{\n\tstruct bnx2x_mcast_elem_group *current_mcast_group;\n\n\twhile (!list_empty(mcast_group_list)) {\n\t\tcurrent_mcast_group = list_first_entry(mcast_group_list,\n\t\t\t\t      struct bnx2x_mcast_elem_group,\n\t\t\t\t      mcast_group_link);\n\t\tlist_del(&current_mcast_group->mcast_group_link);\n\t\tfree_page((unsigned long)current_mcast_group);\n\t}\n}\n\nstatic int bnx2x_mcast_enqueue_cmd(struct bnx2x *bp,\n\t\t\t\t   struct bnx2x_mcast_obj *o,\n\t\t\t\t   struct bnx2x_mcast_ramrod_params *p,\n\t\t\t\t   enum bnx2x_mcast_cmd cmd)\n{\n\tstruct bnx2x_pending_mcast_cmd *new_cmd;\n\tstruct bnx2x_mcast_list_elem *pos;\n\tstruct bnx2x_mcast_elem_group *elem_group;\n\tstruct bnx2x_mcast_mac_elem *mac_elem;\n\tint total_elems = 0, macs_list_len = 0, offset = 0;\n\n\t \n\tif (cmd == BNX2X_MCAST_CMD_ADD || cmd == BNX2X_MCAST_CMD_SET)\n\t\tmacs_list_len = p->mcast_list_len;\n\n\t \n\tif (!p->mcast_list_len)\n\t\treturn 0;\n\n\t \n\tnew_cmd = kzalloc(sizeof(*new_cmd), GFP_ATOMIC);\n\tif (!new_cmd)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&new_cmd->data.macs_head);\n\tINIT_LIST_HEAD(&new_cmd->group_head);\n\tnew_cmd->type = cmd;\n\tnew_cmd->done = false;\n\n\tDP(BNX2X_MSG_SP, \"About to enqueue a new %d command. macs_list_len=%d\\n\",\n\t   cmd, macs_list_len);\n\n\tswitch (cmd) {\n\tcase BNX2X_MCAST_CMD_ADD:\n\tcase BNX2X_MCAST_CMD_SET:\n\t\t \n\t\ttotal_elems = macs_list_len;\n\t\tif (cmd == BNX2X_MCAST_CMD_SET) {\n\t\t\tif (total_elems < BNX2X_MCAST_BINS_NUM)\n\t\t\t\ttotal_elems = BNX2X_MCAST_BINS_NUM;\n\t\t}\n\t\twhile (total_elems > 0) {\n\t\t\telem_group = (struct bnx2x_mcast_elem_group *)\n\t\t\t\t     __get_free_page(GFP_ATOMIC | __GFP_ZERO);\n\t\t\tif (!elem_group) {\n\t\t\t\tbnx2x_free_groups(&new_cmd->group_head);\n\t\t\t\tkfree(new_cmd);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\ttotal_elems -= MCAST_MAC_ELEMS_PER_PG;\n\t\t\tlist_add_tail(&elem_group->mcast_group_link,\n\t\t\t\t      &new_cmd->group_head);\n\t\t}\n\t\telem_group = list_first_entry(&new_cmd->group_head,\n\t\t\t\t\t      struct bnx2x_mcast_elem_group,\n\t\t\t\t\t      mcast_group_link);\n\t\tlist_for_each_entry(pos, &p->mcast_list, link) {\n\t\t\tmac_elem = &elem_group->mcast_elems[offset].mac_elem;\n\t\t\tmemcpy(mac_elem->mac, pos->mac, ETH_ALEN);\n\t\t\t \n\t\t\tlist_add_tail(&mac_elem->link,\n\t\t\t\t      &new_cmd->data.macs_head);\n\t\t\toffset++;\n\t\t\tif (offset == MCAST_MAC_ELEMS_PER_PG) {\n\t\t\t\toffset = 0;\n\t\t\t\telem_group = list_next_entry(elem_group,\n\t\t\t\t\t\t\t     mcast_group_link);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase BNX2X_MCAST_CMD_DEL:\n\t\tnew_cmd->data.macs_num = p->mcast_list_len;\n\t\tbreak;\n\n\tcase BNX2X_MCAST_CMD_RESTORE:\n\t\tnew_cmd->data.next_bin = 0;\n\t\tbreak;\n\n\tdefault:\n\t\tkfree(new_cmd);\n\t\tBNX2X_ERR(\"Unknown command: %d\\n\", cmd);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tlist_add_tail(&new_cmd->link, &o->pending_cmds_head);\n\n\to->set_sched(o);\n\n\treturn 1;\n}\n\n \nstatic inline int bnx2x_mcast_get_next_bin(struct bnx2x_mcast_obj *o, int last)\n{\n\tint i, j, inner_start = last % BIT_VEC64_ELEM_SZ;\n\n\tfor (i = last / BIT_VEC64_ELEM_SZ; i < BNX2X_MCAST_VEC_SZ; i++) {\n\t\tif (o->registry.aprox_match.vec[i])\n\t\t\tfor (j = inner_start; j < BIT_VEC64_ELEM_SZ; j++) {\n\t\t\t\tint cur_bit = j + BIT_VEC64_ELEM_SZ * i;\n\t\t\t\tif (BIT_VEC64_TEST_BIT(o->registry.aprox_match.\n\t\t\t\t\t\t       vec, cur_bit)) {\n\t\t\t\t\treturn cur_bit;\n\t\t\t\t}\n\t\t\t}\n\t\tinner_start = 0;\n\t}\n\n\t \n\treturn -1;\n}\n\n \nstatic inline int bnx2x_mcast_clear_first_bin(struct bnx2x_mcast_obj *o)\n{\n\tint cur_bit = bnx2x_mcast_get_next_bin(o, 0);\n\n\tif (cur_bit >= 0)\n\t\tBIT_VEC64_CLEAR_BIT(o->registry.aprox_match.vec, cur_bit);\n\n\treturn cur_bit;\n}\n\nstatic inline u8 bnx2x_mcast_get_rx_tx_flag(struct bnx2x_mcast_obj *o)\n{\n\tstruct bnx2x_raw_obj *raw = &o->raw;\n\tu8 rx_tx_flag = 0;\n\n\tif ((raw->obj_type == BNX2X_OBJ_TYPE_TX) ||\n\t    (raw->obj_type == BNX2X_OBJ_TYPE_RX_TX))\n\t\trx_tx_flag |= ETH_MULTICAST_RULES_CMD_TX_CMD;\n\n\tif ((raw->obj_type == BNX2X_OBJ_TYPE_RX) ||\n\t    (raw->obj_type == BNX2X_OBJ_TYPE_RX_TX))\n\t\trx_tx_flag |= ETH_MULTICAST_RULES_CMD_RX_CMD;\n\n\treturn rx_tx_flag;\n}\n\nstatic void bnx2x_mcast_set_one_rule_e2(struct bnx2x *bp,\n\t\t\t\t\tstruct bnx2x_mcast_obj *o, int idx,\n\t\t\t\t\tunion bnx2x_mcast_config_data *cfg_data,\n\t\t\t\t\tenum bnx2x_mcast_cmd cmd)\n{\n\tstruct bnx2x_raw_obj *r = &o->raw;\n\tstruct eth_multicast_rules_ramrod_data *data =\n\t\t(struct eth_multicast_rules_ramrod_data *)(r->rdata);\n\tu8 func_id = r->func_id;\n\tu8 rx_tx_add_flag = bnx2x_mcast_get_rx_tx_flag(o);\n\tint bin;\n\n\tif ((cmd == BNX2X_MCAST_CMD_ADD) || (cmd == BNX2X_MCAST_CMD_RESTORE) ||\n\t    (cmd == BNX2X_MCAST_CMD_SET_ADD))\n\t\trx_tx_add_flag |= ETH_MULTICAST_RULES_CMD_IS_ADD;\n\n\tdata->rules[idx].cmd_general_data |= rx_tx_add_flag;\n\n\t \n\tswitch (cmd) {\n\tcase BNX2X_MCAST_CMD_ADD:\n\t\tbin = bnx2x_mcast_bin_from_mac(cfg_data->mac);\n\t\tBIT_VEC64_SET_BIT(o->registry.aprox_match.vec, bin);\n\t\tbreak;\n\n\tcase BNX2X_MCAST_CMD_DEL:\n\t\t \n\t\tbin = bnx2x_mcast_clear_first_bin(o);\n\t\tbreak;\n\n\tcase BNX2X_MCAST_CMD_RESTORE:\n\t\tbin = cfg_data->bin;\n\t\tbreak;\n\n\tcase BNX2X_MCAST_CMD_SET_ADD:\n\t\tbin = cfg_data->bin;\n\t\tBIT_VEC64_SET_BIT(o->registry.aprox_match.vec, bin);\n\t\tbreak;\n\n\tcase BNX2X_MCAST_CMD_SET_DEL:\n\t\tbin = cfg_data->bin;\n\t\tBIT_VEC64_CLEAR_BIT(o->registry.aprox_match.vec, bin);\n\t\tbreak;\n\n\tdefault:\n\t\tBNX2X_ERR(\"Unknown command: %d\\n\", cmd);\n\t\treturn;\n\t}\n\n\tDP(BNX2X_MSG_SP, \"%s bin %d\\n\",\n\t\t\t ((rx_tx_add_flag & ETH_MULTICAST_RULES_CMD_IS_ADD) ?\n\t\t\t \"Setting\"  : \"Clearing\"), bin);\n\n\tdata->rules[idx].bin_id    = (u8)bin;\n\tdata->rules[idx].func_id   = func_id;\n\tdata->rules[idx].engine_id = o->engine_id;\n}\n\n \nstatic inline int bnx2x_mcast_handle_restore_cmd_e2(\n\tstruct bnx2x *bp, struct bnx2x_mcast_obj *o , int start_bin,\n\tint *rdata_idx)\n{\n\tint cur_bin, cnt = *rdata_idx;\n\tunion bnx2x_mcast_config_data cfg_data = {NULL};\n\n\t \n\tfor (cur_bin = bnx2x_mcast_get_next_bin(o, start_bin); cur_bin >= 0;\n\t    cur_bin = bnx2x_mcast_get_next_bin(o, cur_bin + 1)) {\n\n\t\tcfg_data.bin = (u8)cur_bin;\n\t\to->set_one_rule(bp, o, cnt, &cfg_data,\n\t\t\t\tBNX2X_MCAST_CMD_RESTORE);\n\n\t\tcnt++;\n\n\t\tDP(BNX2X_MSG_SP, \"About to configure a bin %d\\n\", cur_bin);\n\n\t\t \n\t\tif (cnt >= o->max_cmd_len)\n\t\t\tbreak;\n\t}\n\n\t*rdata_idx = cnt;\n\n\treturn cur_bin;\n}\n\nstatic inline void bnx2x_mcast_hdl_pending_add_e2(struct bnx2x *bp,\n\tstruct bnx2x_mcast_obj *o, struct bnx2x_pending_mcast_cmd *cmd_pos,\n\tint *line_idx)\n{\n\tstruct bnx2x_mcast_mac_elem *pmac_pos, *pmac_pos_n;\n\tint cnt = *line_idx;\n\tunion bnx2x_mcast_config_data cfg_data = {NULL};\n\n\tlist_for_each_entry_safe(pmac_pos, pmac_pos_n, &cmd_pos->data.macs_head,\n\t\t\t\t link) {\n\n\t\tcfg_data.mac = &pmac_pos->mac[0];\n\t\to->set_one_rule(bp, o, cnt, &cfg_data, cmd_pos->type);\n\n\t\tcnt++;\n\n\t\tDP(BNX2X_MSG_SP, \"About to configure %pM mcast MAC\\n\",\n\t\t   pmac_pos->mac);\n\n\t\tlist_del(&pmac_pos->link);\n\n\t\t \n\t\tif (cnt >= o->max_cmd_len)\n\t\t\tbreak;\n\t}\n\n\t*line_idx = cnt;\n\n\t \n\tif (list_empty(&cmd_pos->data.macs_head))\n\t\tcmd_pos->done = true;\n}\n\nstatic inline void bnx2x_mcast_hdl_pending_del_e2(struct bnx2x *bp,\n\tstruct bnx2x_mcast_obj *o, struct bnx2x_pending_mcast_cmd *cmd_pos,\n\tint *line_idx)\n{\n\tint cnt = *line_idx;\n\n\twhile (cmd_pos->data.macs_num) {\n\t\to->set_one_rule(bp, o, cnt, NULL, cmd_pos->type);\n\n\t\tcnt++;\n\n\t\tcmd_pos->data.macs_num--;\n\n\t\tDP(BNX2X_MSG_SP, \"Deleting MAC. %d left,cnt is %d\\n\",\n\t\t   cmd_pos->data.macs_num, cnt);\n\n\t\t \n\t\tif (cnt >= o->max_cmd_len)\n\t\t\tbreak;\n\t}\n\n\t*line_idx = cnt;\n\n\t \n\tif (!cmd_pos->data.macs_num)\n\t\tcmd_pos->done = true;\n}\n\nstatic inline void bnx2x_mcast_hdl_pending_restore_e2(struct bnx2x *bp,\n\tstruct bnx2x_mcast_obj *o, struct bnx2x_pending_mcast_cmd *cmd_pos,\n\tint *line_idx)\n{\n\tcmd_pos->data.next_bin = o->hdl_restore(bp, o, cmd_pos->data.next_bin,\n\t\t\t\t\t\tline_idx);\n\n\tif (cmd_pos->data.next_bin < 0)\n\t\t \n\t\tcmd_pos->done = true;\n\telse\n\t\t \n\t\tcmd_pos->data.next_bin++;\n}\n\nstatic void\nbnx2x_mcast_hdl_pending_set_e2_convert(struct bnx2x *bp,\n\t\t\t\t       struct bnx2x_mcast_obj *o,\n\t\t\t\t       struct bnx2x_pending_mcast_cmd *cmd_pos)\n{\n\tu64 cur[BNX2X_MCAST_VEC_SZ], req[BNX2X_MCAST_VEC_SZ];\n\tstruct bnx2x_mcast_mac_elem *pmac_pos, *pmac_pos_n;\n\tstruct bnx2x_mcast_bin_elem *p_item;\n\tstruct bnx2x_mcast_elem_group *elem_group;\n\tint cnt = 0, mac_cnt = 0, offset = 0, i;\n\n\tmemset(req, 0, sizeof(u64) * BNX2X_MCAST_VEC_SZ);\n\tmemcpy(cur, o->registry.aprox_match.vec,\n\t       sizeof(u64) * BNX2X_MCAST_VEC_SZ);\n\n\t \n\tlist_for_each_entry_safe(pmac_pos, pmac_pos_n, &cmd_pos->data.macs_head,\n\t\t\t\t link) {\n\t\tint bin = bnx2x_mcast_bin_from_mac(pmac_pos->mac);\n\n\t\tDP(BNX2X_MSG_SP, \"Set contains %pM mcast MAC\\n\",\n\t\t   pmac_pos->mac);\n\n\t\tBIT_VEC64_SET_BIT(req, bin);\n\t\tlist_del(&pmac_pos->link);\n\t\tmac_cnt++;\n\t}\n\n\t \n\tcmd_pos->set_convert = true;\n\tINIT_LIST_HEAD(&cmd_pos->data.macs_head);\n\telem_group = list_first_entry(&cmd_pos->group_head,\n\t\t\t\t      struct bnx2x_mcast_elem_group,\n\t\t\t\t      mcast_group_link);\n\tfor (i = 0; i < BNX2X_MCAST_BINS_NUM; i++) {\n\t\tbool b_current = !!BIT_VEC64_TEST_BIT(cur, i);\n\t\tbool b_required = !!BIT_VEC64_TEST_BIT(req, i);\n\n\t\tif (b_current == b_required)\n\t\t\tcontinue;\n\n\t\tp_item = &elem_group->mcast_elems[offset].bin_elem;\n\t\tp_item->bin = i;\n\t\tp_item->type = b_required ? BNX2X_MCAST_CMD_SET_ADD\n\t\t\t\t\t  : BNX2X_MCAST_CMD_SET_DEL;\n\t\tlist_add_tail(&p_item->link , &cmd_pos->data.macs_head);\n\t\tcnt++;\n\t\toffset++;\n\t\tif (offset == MCAST_MAC_ELEMS_PER_PG) {\n\t\t\toffset = 0;\n\t\t\telem_group = list_next_entry(elem_group,\n\t\t\t\t\t\t     mcast_group_link);\n\t\t}\n\t}\n\n\t \n\to->total_pending_num -= (o->max_cmd_len + mac_cnt);\n\to->total_pending_num += cnt;\n\n\tDP(BNX2X_MSG_SP, \"o->total_pending_num=%d\\n\", o->total_pending_num);\n}\n\nstatic void\nbnx2x_mcast_hdl_pending_set_e2(struct bnx2x *bp,\n\t\t\t       struct bnx2x_mcast_obj *o,\n\t\t\t       struct bnx2x_pending_mcast_cmd *cmd_pos,\n\t\t\t       int *cnt)\n{\n\tunion bnx2x_mcast_config_data cfg_data = {NULL};\n\tstruct bnx2x_mcast_bin_elem *p_item, *p_item_n;\n\n\t \n\tif (!cmd_pos->set_convert)\n\t\tbnx2x_mcast_hdl_pending_set_e2_convert(bp, o, cmd_pos);\n\n\tlist_for_each_entry_safe(p_item, p_item_n, &cmd_pos->data.macs_head,\n\t\t\t\t link) {\n\t\tcfg_data.bin = (u8)p_item->bin;\n\t\to->set_one_rule(bp, o, *cnt, &cfg_data, p_item->type);\n\t\t(*cnt)++;\n\n\t\tlist_del(&p_item->link);\n\n\t\t \n\t\tif (*cnt >= o->max_cmd_len)\n\t\t\tbreak;\n\t}\n\n\t \n\tif (list_empty(&cmd_pos->data.macs_head))\n\t\tcmd_pos->done = true;\n}\n\nstatic inline int bnx2x_mcast_handle_pending_cmds_e2(struct bnx2x *bp,\n\t\t\t\tstruct bnx2x_mcast_ramrod_params *p)\n{\n\tstruct bnx2x_pending_mcast_cmd *cmd_pos, *cmd_pos_n;\n\tint cnt = 0;\n\tstruct bnx2x_mcast_obj *o = p->mcast_obj;\n\n\tlist_for_each_entry_safe(cmd_pos, cmd_pos_n, &o->pending_cmds_head,\n\t\t\t\t link) {\n\t\tswitch (cmd_pos->type) {\n\t\tcase BNX2X_MCAST_CMD_ADD:\n\t\t\tbnx2x_mcast_hdl_pending_add_e2(bp, o, cmd_pos, &cnt);\n\t\t\tbreak;\n\n\t\tcase BNX2X_MCAST_CMD_DEL:\n\t\t\tbnx2x_mcast_hdl_pending_del_e2(bp, o, cmd_pos, &cnt);\n\t\t\tbreak;\n\n\t\tcase BNX2X_MCAST_CMD_RESTORE:\n\t\t\tbnx2x_mcast_hdl_pending_restore_e2(bp, o, cmd_pos,\n\t\t\t\t\t\t\t   &cnt);\n\t\t\tbreak;\n\n\t\tcase BNX2X_MCAST_CMD_SET:\n\t\t\tbnx2x_mcast_hdl_pending_set_e2(bp, o, cmd_pos, &cnt);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tBNX2X_ERR(\"Unknown command: %d\\n\", cmd_pos->type);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tif (cmd_pos->done) {\n\t\t\tlist_del(&cmd_pos->link);\n\t\t\tbnx2x_free_groups(&cmd_pos->group_head);\n\t\t\tkfree(cmd_pos);\n\t\t}\n\n\t\t \n\t\tif (cnt >= o->max_cmd_len)\n\t\t\tbreak;\n\t}\n\n\treturn cnt;\n}\n\nstatic inline void bnx2x_mcast_hdl_add(struct bnx2x *bp,\n\tstruct bnx2x_mcast_obj *o, struct bnx2x_mcast_ramrod_params *p,\n\tint *line_idx)\n{\n\tstruct bnx2x_mcast_list_elem *mlist_pos;\n\tunion bnx2x_mcast_config_data cfg_data = {NULL};\n\tint cnt = *line_idx;\n\n\tlist_for_each_entry(mlist_pos, &p->mcast_list, link) {\n\t\tcfg_data.mac = mlist_pos->mac;\n\t\to->set_one_rule(bp, o, cnt, &cfg_data, BNX2X_MCAST_CMD_ADD);\n\n\t\tcnt++;\n\n\t\tDP(BNX2X_MSG_SP, \"About to configure %pM mcast MAC\\n\",\n\t\t   mlist_pos->mac);\n\t}\n\n\t*line_idx = cnt;\n}\n\nstatic inline void bnx2x_mcast_hdl_del(struct bnx2x *bp,\n\tstruct bnx2x_mcast_obj *o, struct bnx2x_mcast_ramrod_params *p,\n\tint *line_idx)\n{\n\tint cnt = *line_idx, i;\n\n\tfor (i = 0; i < p->mcast_list_len; i++) {\n\t\to->set_one_rule(bp, o, cnt, NULL, BNX2X_MCAST_CMD_DEL);\n\n\t\tcnt++;\n\n\t\tDP(BNX2X_MSG_SP, \"Deleting MAC. %d left\\n\",\n\t\t\t\t p->mcast_list_len - i - 1);\n\t}\n\n\t*line_idx = cnt;\n}\n\n \nstatic inline int bnx2x_mcast_handle_current_cmd(struct bnx2x *bp,\n\t\t\tstruct bnx2x_mcast_ramrod_params *p,\n\t\t\tenum bnx2x_mcast_cmd cmd,\n\t\t\tint start_cnt)\n{\n\tstruct bnx2x_mcast_obj *o = p->mcast_obj;\n\tint cnt = start_cnt;\n\n\tDP(BNX2X_MSG_SP, \"p->mcast_list_len=%d\\n\", p->mcast_list_len);\n\n\tswitch (cmd) {\n\tcase BNX2X_MCAST_CMD_ADD:\n\t\tbnx2x_mcast_hdl_add(bp, o, p, &cnt);\n\t\tbreak;\n\n\tcase BNX2X_MCAST_CMD_DEL:\n\t\tbnx2x_mcast_hdl_del(bp, o, p, &cnt);\n\t\tbreak;\n\n\tcase BNX2X_MCAST_CMD_RESTORE:\n\t\to->hdl_restore(bp, o, 0, &cnt);\n\t\tbreak;\n\n\tdefault:\n\t\tBNX2X_ERR(\"Unknown command: %d\\n\", cmd);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tp->mcast_list_len = 0;\n\n\treturn cnt;\n}\n\nstatic int bnx2x_mcast_validate_e2(struct bnx2x *bp,\n\t\t\t\t   struct bnx2x_mcast_ramrod_params *p,\n\t\t\t\t   enum bnx2x_mcast_cmd cmd)\n{\n\tstruct bnx2x_mcast_obj *o = p->mcast_obj;\n\tint reg_sz = o->get_registry_size(o);\n\n\tswitch (cmd) {\n\t \n\tcase BNX2X_MCAST_CMD_DEL:\n\t\to->set_registry_size(o, 0);\n\t\tfallthrough;\n\n\t \n\tcase BNX2X_MCAST_CMD_RESTORE:\n\t\t \n\t\tp->mcast_list_len = reg_sz;\n\t\tbreak;\n\n\tcase BNX2X_MCAST_CMD_ADD:\n\tcase BNX2X_MCAST_CMD_CONT:\n\t\t \n\t\to->set_registry_size(o, reg_sz + p->mcast_list_len);\n\t\tbreak;\n\n\tcase BNX2X_MCAST_CMD_SET:\n\t\t \n\t\to->set_registry_size(o, reg_sz + p->mcast_list_len);\n\t\to->total_pending_num += o->max_cmd_len;\n\t\tbreak;\n\n\tdefault:\n\t\tBNX2X_ERR(\"Unknown command: %d\\n\", cmd);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\to->total_pending_num += p->mcast_list_len;\n\n\treturn 0;\n}\n\nstatic void bnx2x_mcast_revert_e2(struct bnx2x *bp,\n\t\t\t\t      struct bnx2x_mcast_ramrod_params *p,\n\t\t\t\t  int old_num_bins,\n\t\t\t\t  enum bnx2x_mcast_cmd cmd)\n{\n\tstruct bnx2x_mcast_obj *o = p->mcast_obj;\n\n\to->set_registry_size(o, old_num_bins);\n\to->total_pending_num -= p->mcast_list_len;\n\n\tif (cmd == BNX2X_MCAST_CMD_SET)\n\t\to->total_pending_num -= o->max_cmd_len;\n}\n\n \nstatic inline void bnx2x_mcast_set_rdata_hdr_e2(struct bnx2x *bp,\n\t\t\t\t\tstruct bnx2x_mcast_ramrod_params *p,\n\t\t\t\t\tu8 len)\n{\n\tstruct bnx2x_raw_obj *r = &p->mcast_obj->raw;\n\tstruct eth_multicast_rules_ramrod_data *data =\n\t\t(struct eth_multicast_rules_ramrod_data *)(r->rdata);\n\n\tdata->header.echo = cpu_to_le32((r->cid & BNX2X_SWCID_MASK) |\n\t\t\t\t\t(BNX2X_FILTER_MCAST_PENDING <<\n\t\t\t\t\t BNX2X_SWCID_SHIFT));\n\tdata->header.rule_cnt = len;\n}\n\n \nstatic inline int bnx2x_mcast_refresh_registry_e2(struct bnx2x *bp,\n\t\t\t\t\t\t  struct bnx2x_mcast_obj *o)\n{\n\tint i, cnt = 0;\n\tu64 elem;\n\n\tfor (i = 0; i < BNX2X_MCAST_VEC_SZ; i++) {\n\t\telem = o->registry.aprox_match.vec[i];\n\t\tfor (; elem; cnt++)\n\t\t\telem &= elem - 1;\n\t}\n\n\to->set_registry_size(o, cnt);\n\n\treturn 0;\n}\n\nstatic int bnx2x_mcast_setup_e2(struct bnx2x *bp,\n\t\t\t\tstruct bnx2x_mcast_ramrod_params *p,\n\t\t\t\tenum bnx2x_mcast_cmd cmd)\n{\n\tstruct bnx2x_raw_obj *raw = &p->mcast_obj->raw;\n\tstruct bnx2x_mcast_obj *o = p->mcast_obj;\n\tstruct eth_multicast_rules_ramrod_data *data =\n\t\t(struct eth_multicast_rules_ramrod_data *)(raw->rdata);\n\tint cnt = 0, rc;\n\n\t \n\tmemset(data, 0, sizeof(*data));\n\n\tcnt = bnx2x_mcast_handle_pending_cmds_e2(bp, p);\n\n\t \n\tif (list_empty(&o->pending_cmds_head))\n\t\to->clear_sched(o);\n\n\t \n\tif (p->mcast_list_len > 0)\n\t\tcnt = bnx2x_mcast_handle_current_cmd(bp, p, cmd, cnt);\n\n\t \n\to->total_pending_num -= cnt;\n\n\t \n\tWARN_ON(o->total_pending_num < 0);\n\tWARN_ON(cnt > o->max_cmd_len);\n\n\tbnx2x_mcast_set_rdata_hdr_e2(bp, p, (u8)cnt);\n\n\t \n\tif (!o->total_pending_num)\n\t\tbnx2x_mcast_refresh_registry_e2(bp, o);\n\n\t \n\tif (test_bit(RAMROD_DRV_CLR_ONLY, &p->ramrod_flags) || !cnt) {\n\t\traw->clear_pending(raw);\n\t\treturn 0;\n\t} else {\n\t\t \n\n\t\t \n\t\trc = bnx2x_sp_post(bp, RAMROD_CMD_ID_ETH_MULTICAST_RULES,\n\t\t\t\t   raw->cid, U64_HI(raw->rdata_mapping),\n\t\t\t\t   U64_LO(raw->rdata_mapping),\n\t\t\t\t   ETH_CONNECTION_TYPE);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\t \n\t\treturn 1;\n\t}\n}\n\nstatic int bnx2x_mcast_validate_e1h(struct bnx2x *bp,\n\t\t\t\t    struct bnx2x_mcast_ramrod_params *p,\n\t\t\t\t    enum bnx2x_mcast_cmd cmd)\n{\n\tif (cmd == BNX2X_MCAST_CMD_SET) {\n\t\tBNX2X_ERR(\"Can't use `set' command on e1h!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif ((cmd == BNX2X_MCAST_CMD_DEL) || (cmd == BNX2X_MCAST_CMD_RESTORE))\n\t\tp->mcast_list_len = 1;\n\n\treturn 0;\n}\n\nstatic void bnx2x_mcast_revert_e1h(struct bnx2x *bp,\n\t\t\t\t       struct bnx2x_mcast_ramrod_params *p,\n\t\t\t\t       int old_num_bins,\n\t\t\t\t       enum bnx2x_mcast_cmd cmd)\n{\n\t \n}\n\n#define BNX2X_57711_SET_MC_FILTER(filter, bit) \\\ndo { \\\n\t(filter)[(bit) >> 5] |= (1 << ((bit) & 0x1f)); \\\n} while (0)\n\nstatic inline void bnx2x_mcast_hdl_add_e1h(struct bnx2x *bp,\n\t\t\t\t\t   struct bnx2x_mcast_obj *o,\n\t\t\t\t\t   struct bnx2x_mcast_ramrod_params *p,\n\t\t\t\t\t   u32 *mc_filter)\n{\n\tstruct bnx2x_mcast_list_elem *mlist_pos;\n\tint bit;\n\n\tlist_for_each_entry(mlist_pos, &p->mcast_list, link) {\n\t\tbit = bnx2x_mcast_bin_from_mac(mlist_pos->mac);\n\t\tBNX2X_57711_SET_MC_FILTER(mc_filter, bit);\n\n\t\tDP(BNX2X_MSG_SP, \"About to configure %pM mcast MAC, bin %d\\n\",\n\t\t   mlist_pos->mac, bit);\n\n\t\t \n\t\tBIT_VEC64_SET_BIT(o->registry.aprox_match.vec,\n\t\t\t\t  bit);\n\t}\n}\n\nstatic inline void bnx2x_mcast_hdl_restore_e1h(struct bnx2x *bp,\n\tstruct bnx2x_mcast_obj *o, struct bnx2x_mcast_ramrod_params *p,\n\tu32 *mc_filter)\n{\n\tint bit;\n\n\tfor (bit = bnx2x_mcast_get_next_bin(o, 0);\n\t     bit >= 0;\n\t     bit = bnx2x_mcast_get_next_bin(o, bit + 1)) {\n\t\tBNX2X_57711_SET_MC_FILTER(mc_filter, bit);\n\t\tDP(BNX2X_MSG_SP, \"About to set bin %d\\n\", bit);\n\t}\n}\n\n \nstatic int bnx2x_mcast_setup_e1h(struct bnx2x *bp,\n\t\t\t\t struct bnx2x_mcast_ramrod_params *p,\n\t\t\t\t enum bnx2x_mcast_cmd cmd)\n{\n\tint i;\n\tstruct bnx2x_mcast_obj *o = p->mcast_obj;\n\tstruct bnx2x_raw_obj *r = &o->raw;\n\n\t \n\tif (!test_bit(RAMROD_DRV_CLR_ONLY, &p->ramrod_flags)) {\n\t\tu32 mc_filter[MC_HASH_SIZE] = {0};\n\n\t\t \n\t\tswitch (cmd) {\n\t\tcase BNX2X_MCAST_CMD_ADD:\n\t\t\tbnx2x_mcast_hdl_add_e1h(bp, o, p, mc_filter);\n\t\t\tbreak;\n\n\t\tcase BNX2X_MCAST_CMD_DEL:\n\t\t\tDP(BNX2X_MSG_SP,\n\t\t\t   \"Invalidating multicast MACs configuration\\n\");\n\n\t\t\t \n\t\t\tmemset(o->registry.aprox_match.vec, 0,\n\t\t\t       sizeof(o->registry.aprox_match.vec));\n\t\t\tbreak;\n\n\t\tcase BNX2X_MCAST_CMD_RESTORE:\n\t\t\tbnx2x_mcast_hdl_restore_e1h(bp, o, p, mc_filter);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tBNX2X_ERR(\"Unknown command: %d\\n\", cmd);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tfor (i = 0; i < MC_HASH_SIZE; i++)\n\t\t\tREG_WR(bp, MC_HASH_OFFSET(bp, i), mc_filter[i]);\n\t} else\n\t\t \n\t\tmemset(o->registry.aprox_match.vec, 0,\n\t\t       sizeof(o->registry.aprox_match.vec));\n\n\t \n\tr->clear_pending(r);\n\n\treturn 0;\n}\n\nstatic int bnx2x_mcast_validate_e1(struct bnx2x *bp,\n\t\t\t\t   struct bnx2x_mcast_ramrod_params *p,\n\t\t\t\t   enum bnx2x_mcast_cmd cmd)\n{\n\tstruct bnx2x_mcast_obj *o = p->mcast_obj;\n\tint reg_sz = o->get_registry_size(o);\n\n\tif (cmd == BNX2X_MCAST_CMD_SET) {\n\t\tBNX2X_ERR(\"Can't use `set' command on e1!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (cmd) {\n\t \n\tcase BNX2X_MCAST_CMD_DEL:\n\t\to->set_registry_size(o, 0);\n\t\tfallthrough;\n\n\t \n\tcase BNX2X_MCAST_CMD_RESTORE:\n\t\tp->mcast_list_len = reg_sz;\n\t\tDP(BNX2X_MSG_SP, \"Command %d, p->mcast_list_len=%d\\n\",\n\t\t   cmd, p->mcast_list_len);\n\t\tbreak;\n\n\tcase BNX2X_MCAST_CMD_ADD:\n\tcase BNX2X_MCAST_CMD_CONT:\n\t\t \n\t\tif (p->mcast_list_len > o->max_cmd_len) {\n\t\t\tBNX2X_ERR(\"Can't configure more than %d multicast MACs on 57710\\n\",\n\t\t\t\t  o->max_cmd_len);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t \n\t\tDP(BNX2X_MSG_SP, \"p->mcast_list_len=%d\\n\", p->mcast_list_len);\n\t\tif (p->mcast_list_len > 0)\n\t\t\to->set_registry_size(o, p->mcast_list_len);\n\n\t\tbreak;\n\n\tdefault:\n\t\tBNX2X_ERR(\"Unknown command: %d\\n\", cmd);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (p->mcast_list_len)\n\t\to->total_pending_num += o->max_cmd_len;\n\n\treturn 0;\n}\n\nstatic void bnx2x_mcast_revert_e1(struct bnx2x *bp,\n\t\t\t\t      struct bnx2x_mcast_ramrod_params *p,\n\t\t\t\t   int old_num_macs,\n\t\t\t\t   enum bnx2x_mcast_cmd cmd)\n{\n\tstruct bnx2x_mcast_obj *o = p->mcast_obj;\n\n\to->set_registry_size(o, old_num_macs);\n\n\t \n\tif (p->mcast_list_len)\n\t\to->total_pending_num -= o->max_cmd_len;\n}\n\nstatic void bnx2x_mcast_set_one_rule_e1(struct bnx2x *bp,\n\t\t\t\t\tstruct bnx2x_mcast_obj *o, int idx,\n\t\t\t\t\tunion bnx2x_mcast_config_data *cfg_data,\n\t\t\t\t\tenum bnx2x_mcast_cmd cmd)\n{\n\tstruct bnx2x_raw_obj *r = &o->raw;\n\tstruct mac_configuration_cmd *data =\n\t\t(struct mac_configuration_cmd *)(r->rdata);\n\n\t \n\tif ((cmd == BNX2X_MCAST_CMD_ADD) || (cmd == BNX2X_MCAST_CMD_RESTORE)) {\n\t\tbnx2x_set_fw_mac_addr(&data->config_table[idx].msb_mac_addr,\n\t\t\t\t      &data->config_table[idx].middle_mac_addr,\n\t\t\t\t      &data->config_table[idx].lsb_mac_addr,\n\t\t\t\t      cfg_data->mac);\n\n\t\tdata->config_table[idx].vlan_id = 0;\n\t\tdata->config_table[idx].pf_id = r->func_id;\n\t\tdata->config_table[idx].clients_bit_vector =\n\t\t\tcpu_to_le32(1 << r->cl_id);\n\n\t\tSET_FLAG(data->config_table[idx].flags,\n\t\t\t MAC_CONFIGURATION_ENTRY_ACTION_TYPE,\n\t\t\t T_ETH_MAC_COMMAND_SET);\n\t}\n}\n\n \nstatic inline void bnx2x_mcast_set_rdata_hdr_e1(struct bnx2x *bp,\n\t\t\t\t\tstruct bnx2x_mcast_ramrod_params *p,\n\t\t\t\t\tu8 len)\n{\n\tstruct bnx2x_raw_obj *r = &p->mcast_obj->raw;\n\tstruct mac_configuration_cmd *data =\n\t\t(struct mac_configuration_cmd *)(r->rdata);\n\n\tu8 offset = (CHIP_REV_IS_SLOW(bp) ?\n\t\t     BNX2X_MAX_EMUL_MULTI*(1 + r->func_id) :\n\t\t     BNX2X_MAX_MULTICAST*(1 + r->func_id));\n\n\tdata->hdr.offset = offset;\n\tdata->hdr.client_id = cpu_to_le16(0xff);\n\tdata->hdr.echo = cpu_to_le32((r->cid & BNX2X_SWCID_MASK) |\n\t\t\t\t     (BNX2X_FILTER_MCAST_PENDING <<\n\t\t\t\t      BNX2X_SWCID_SHIFT));\n\tdata->hdr.length = len;\n}\n\n \nstatic inline int bnx2x_mcast_handle_restore_cmd_e1(\n\tstruct bnx2x *bp, struct bnx2x_mcast_obj *o , int start_idx,\n\tint *rdata_idx)\n{\n\tstruct bnx2x_mcast_mac_elem *elem;\n\tint i = 0;\n\tunion bnx2x_mcast_config_data cfg_data = {NULL};\n\n\t \n\tlist_for_each_entry(elem, &o->registry.exact_match.macs, link) {\n\t\tcfg_data.mac = &elem->mac[0];\n\t\to->set_one_rule(bp, o, i, &cfg_data, BNX2X_MCAST_CMD_RESTORE);\n\n\t\ti++;\n\n\t\tDP(BNX2X_MSG_SP, \"About to configure %pM mcast MAC\\n\",\n\t\t   cfg_data.mac);\n\t}\n\n\t*rdata_idx = i;\n\n\treturn -1;\n}\n\nstatic inline int bnx2x_mcast_handle_pending_cmds_e1(\n\tstruct bnx2x *bp, struct bnx2x_mcast_ramrod_params *p)\n{\n\tstruct bnx2x_pending_mcast_cmd *cmd_pos;\n\tstruct bnx2x_mcast_mac_elem *pmac_pos;\n\tstruct bnx2x_mcast_obj *o = p->mcast_obj;\n\tunion bnx2x_mcast_config_data cfg_data = {NULL};\n\tint cnt = 0;\n\n\t \n\tif (list_empty(&o->pending_cmds_head))\n\t\treturn 0;\n\n\t \n\tcmd_pos = list_first_entry(&o->pending_cmds_head,\n\t\t\t\t   struct bnx2x_pending_mcast_cmd, link);\n\n\tswitch (cmd_pos->type) {\n\tcase BNX2X_MCAST_CMD_ADD:\n\t\tlist_for_each_entry(pmac_pos, &cmd_pos->data.macs_head, link) {\n\t\t\tcfg_data.mac = &pmac_pos->mac[0];\n\t\t\to->set_one_rule(bp, o, cnt, &cfg_data, cmd_pos->type);\n\n\t\t\tcnt++;\n\n\t\t\tDP(BNX2X_MSG_SP, \"About to configure %pM mcast MAC\\n\",\n\t\t\t   pmac_pos->mac);\n\t\t}\n\t\tbreak;\n\n\tcase BNX2X_MCAST_CMD_DEL:\n\t\tcnt = cmd_pos->data.macs_num;\n\t\tDP(BNX2X_MSG_SP, \"About to delete %d multicast MACs\\n\", cnt);\n\t\tbreak;\n\n\tcase BNX2X_MCAST_CMD_RESTORE:\n\t\to->hdl_restore(bp, o, 0, &cnt);\n\t\tbreak;\n\n\tdefault:\n\t\tBNX2X_ERR(\"Unknown command: %d\\n\", cmd_pos->type);\n\t\treturn -EINVAL;\n\t}\n\n\tlist_del(&cmd_pos->link);\n\tbnx2x_free_groups(&cmd_pos->group_head);\n\tkfree(cmd_pos);\n\n\treturn cnt;\n}\n\n \nstatic inline void bnx2x_get_fw_mac_addr(__le16 *fw_hi, __le16 *fw_mid,\n\t\t\t\t\t __le16 *fw_lo, u8 *mac)\n{\n\tmac[1] = ((u8 *)fw_hi)[0];\n\tmac[0] = ((u8 *)fw_hi)[1];\n\tmac[3] = ((u8 *)fw_mid)[0];\n\tmac[2] = ((u8 *)fw_mid)[1];\n\tmac[5] = ((u8 *)fw_lo)[0];\n\tmac[4] = ((u8 *)fw_lo)[1];\n}\n\n \nstatic inline int bnx2x_mcast_refresh_registry_e1(struct bnx2x *bp,\n\t\t\t\t\t\t  struct bnx2x_mcast_obj *o)\n{\n\tstruct bnx2x_raw_obj *raw = &o->raw;\n\tstruct bnx2x_mcast_mac_elem *elem;\n\tstruct mac_configuration_cmd *data =\n\t\t\t(struct mac_configuration_cmd *)(raw->rdata);\n\n\t \n\tif (GET_FLAG(data->config_table[0].flags,\n\t\t\tMAC_CONFIGURATION_ENTRY_ACTION_TYPE)) {\n\t\tint i, len = data->hdr.length;\n\n\t\t \n\t\tif (!list_empty(&o->registry.exact_match.macs))\n\t\t\treturn 0;\n\n\t\telem = kcalloc(len, sizeof(*elem), GFP_ATOMIC);\n\t\tif (!elem) {\n\t\t\tBNX2X_ERR(\"Failed to allocate registry memory\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tfor (i = 0; i < len; i++, elem++) {\n\t\t\tbnx2x_get_fw_mac_addr(\n\t\t\t\t&data->config_table[i].msb_mac_addr,\n\t\t\t\t&data->config_table[i].middle_mac_addr,\n\t\t\t\t&data->config_table[i].lsb_mac_addr,\n\t\t\t\telem->mac);\n\t\t\tDP(BNX2X_MSG_SP, \"Adding registry entry for [%pM]\\n\",\n\t\t\t   elem->mac);\n\t\t\tlist_add_tail(&elem->link,\n\t\t\t\t      &o->registry.exact_match.macs);\n\t\t}\n\t} else {\n\t\telem = list_first_entry(&o->registry.exact_match.macs,\n\t\t\t\t\tstruct bnx2x_mcast_mac_elem, link);\n\t\tDP(BNX2X_MSG_SP, \"Deleting a registry\\n\");\n\t\tkfree(elem);\n\t\tINIT_LIST_HEAD(&o->registry.exact_match.macs);\n\t}\n\n\treturn 0;\n}\n\nstatic int bnx2x_mcast_setup_e1(struct bnx2x *bp,\n\t\t\t\tstruct bnx2x_mcast_ramrod_params *p,\n\t\t\t\tenum bnx2x_mcast_cmd cmd)\n{\n\tstruct bnx2x_mcast_obj *o = p->mcast_obj;\n\tstruct bnx2x_raw_obj *raw = &o->raw;\n\tstruct mac_configuration_cmd *data =\n\t\t(struct mac_configuration_cmd *)(raw->rdata);\n\tint cnt = 0, i, rc;\n\n\t \n\tmemset(data, 0, sizeof(*data));\n\n\t \n\tfor (i = 0; i < o->max_cmd_len ; i++)\n\t\tSET_FLAG(data->config_table[i].flags,\n\t\t\t MAC_CONFIGURATION_ENTRY_ACTION_TYPE,\n\t\t\t T_ETH_MAC_COMMAND_INVALIDATE);\n\n\t \n\tcnt = bnx2x_mcast_handle_pending_cmds_e1(bp, p);\n\n\t \n\tif (list_empty(&o->pending_cmds_head))\n\t\to->clear_sched(o);\n\n\t \n\tif (!cnt)\n\t\tcnt = bnx2x_mcast_handle_current_cmd(bp, p, cmd, 0);\n\n\t \n\to->total_pending_num -= o->max_cmd_len;\n\n\t \n\n\tWARN_ON(cnt > o->max_cmd_len);\n\n\t \n\tbnx2x_mcast_set_rdata_hdr_e1(bp, p, (u8)cnt);\n\n\t \n\trc = bnx2x_mcast_refresh_registry_e1(bp, o);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tif (test_bit(RAMROD_DRV_CLR_ONLY, &p->ramrod_flags)) {\n\t\traw->clear_pending(raw);\n\t\treturn 0;\n\t} else {\n\t\t \n\n\t\t \n\t\trc = bnx2x_sp_post(bp, RAMROD_CMD_ID_ETH_SET_MAC, raw->cid,\n\t\t\t\t   U64_HI(raw->rdata_mapping),\n\t\t\t\t   U64_LO(raw->rdata_mapping),\n\t\t\t\t   ETH_CONNECTION_TYPE);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\t \n\t\treturn 1;\n\t}\n}\n\nstatic int bnx2x_mcast_get_registry_size_exact(struct bnx2x_mcast_obj *o)\n{\n\treturn o->registry.exact_match.num_macs_set;\n}\n\nstatic int bnx2x_mcast_get_registry_size_aprox(struct bnx2x_mcast_obj *o)\n{\n\treturn o->registry.aprox_match.num_bins_set;\n}\n\nstatic void bnx2x_mcast_set_registry_size_exact(struct bnx2x_mcast_obj *o,\n\t\t\t\t\t\tint n)\n{\n\to->registry.exact_match.num_macs_set = n;\n}\n\nstatic void bnx2x_mcast_set_registry_size_aprox(struct bnx2x_mcast_obj *o,\n\t\t\t\t\t\tint n)\n{\n\to->registry.aprox_match.num_bins_set = n;\n}\n\nint bnx2x_config_mcast(struct bnx2x *bp,\n\t\t       struct bnx2x_mcast_ramrod_params *p,\n\t\t       enum bnx2x_mcast_cmd cmd)\n{\n\tstruct bnx2x_mcast_obj *o = p->mcast_obj;\n\tstruct bnx2x_raw_obj *r = &o->raw;\n\tint rc = 0, old_reg_size;\n\n\t \n\told_reg_size = o->get_registry_size(o);\n\n\t \n\trc = o->validate(bp, p, cmd);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tif ((!p->mcast_list_len) && (!o->check_sched(o)))\n\t\treturn 0;\n\n\tDP(BNX2X_MSG_SP, \"o->total_pending_num=%d p->mcast_list_len=%d o->max_cmd_len=%d\\n\",\n\t   o->total_pending_num, p->mcast_list_len, o->max_cmd_len);\n\n\t \n\tif (r->check_pending(r) ||\n\t    ((o->max_cmd_len > 0) && (o->total_pending_num > o->max_cmd_len))) {\n\t\trc = o->enqueue_cmd(bp, p->mcast_obj, p, cmd);\n\t\tif (rc < 0)\n\t\t\tgoto error_exit1;\n\n\t\t \n\t\tp->mcast_list_len = 0;\n\t}\n\n\tif (!r->check_pending(r)) {\n\n\t\t \n\t\tr->set_pending(r);\n\n\t\t \n\t\trc = o->config_mcast(bp, p, cmd);\n\t\tif (rc < 0)\n\t\t\tgoto error_exit2;\n\n\t\t \n\t\tif (test_bit(RAMROD_COMP_WAIT, &p->ramrod_flags))\n\t\t\trc = o->wait_comp(bp, o);\n\t}\n\n\treturn rc;\n\nerror_exit2:\n\tr->clear_pending(r);\n\nerror_exit1:\n\to->revert(bp, p, old_reg_size, cmd);\n\n\treturn rc;\n}\n\nstatic void bnx2x_mcast_clear_sched(struct bnx2x_mcast_obj *o)\n{\n\tsmp_mb__before_atomic();\n\tclear_bit(o->sched_state, o->raw.pstate);\n\tsmp_mb__after_atomic();\n}\n\nstatic void bnx2x_mcast_set_sched(struct bnx2x_mcast_obj *o)\n{\n\tsmp_mb__before_atomic();\n\tset_bit(o->sched_state, o->raw.pstate);\n\tsmp_mb__after_atomic();\n}\n\nstatic bool bnx2x_mcast_check_sched(struct bnx2x_mcast_obj *o)\n{\n\treturn !!test_bit(o->sched_state, o->raw.pstate);\n}\n\nstatic bool bnx2x_mcast_check_pending(struct bnx2x_mcast_obj *o)\n{\n\treturn o->raw.check_pending(&o->raw) || o->check_sched(o);\n}\n\nvoid bnx2x_init_mcast_obj(struct bnx2x *bp,\n\t\t\t  struct bnx2x_mcast_obj *mcast_obj,\n\t\t\t  u8 mcast_cl_id, u32 mcast_cid, u8 func_id,\n\t\t\t  u8 engine_id, void *rdata, dma_addr_t rdata_mapping,\n\t\t\t  int state, unsigned long *pstate, bnx2x_obj_type type)\n{\n\tmemset(mcast_obj, 0, sizeof(*mcast_obj));\n\n\tbnx2x_init_raw_obj(&mcast_obj->raw, mcast_cl_id, mcast_cid, func_id,\n\t\t\t   rdata, rdata_mapping, state, pstate, type);\n\n\tmcast_obj->engine_id = engine_id;\n\n\tINIT_LIST_HEAD(&mcast_obj->pending_cmds_head);\n\n\tmcast_obj->sched_state = BNX2X_FILTER_MCAST_SCHED;\n\tmcast_obj->check_sched = bnx2x_mcast_check_sched;\n\tmcast_obj->set_sched = bnx2x_mcast_set_sched;\n\tmcast_obj->clear_sched = bnx2x_mcast_clear_sched;\n\n\tif (CHIP_IS_E1(bp)) {\n\t\tmcast_obj->config_mcast      = bnx2x_mcast_setup_e1;\n\t\tmcast_obj->enqueue_cmd       = bnx2x_mcast_enqueue_cmd;\n\t\tmcast_obj->hdl_restore       =\n\t\t\tbnx2x_mcast_handle_restore_cmd_e1;\n\t\tmcast_obj->check_pending     = bnx2x_mcast_check_pending;\n\n\t\tif (CHIP_REV_IS_SLOW(bp))\n\t\t\tmcast_obj->max_cmd_len = BNX2X_MAX_EMUL_MULTI;\n\t\telse\n\t\t\tmcast_obj->max_cmd_len = BNX2X_MAX_MULTICAST;\n\n\t\tmcast_obj->wait_comp         = bnx2x_mcast_wait;\n\t\tmcast_obj->set_one_rule      = bnx2x_mcast_set_one_rule_e1;\n\t\tmcast_obj->validate          = bnx2x_mcast_validate_e1;\n\t\tmcast_obj->revert            = bnx2x_mcast_revert_e1;\n\t\tmcast_obj->get_registry_size =\n\t\t\tbnx2x_mcast_get_registry_size_exact;\n\t\tmcast_obj->set_registry_size =\n\t\t\tbnx2x_mcast_set_registry_size_exact;\n\n\t\t \n\t\tINIT_LIST_HEAD(&mcast_obj->registry.exact_match.macs);\n\n\t} else if (CHIP_IS_E1H(bp)) {\n\t\tmcast_obj->config_mcast  = bnx2x_mcast_setup_e1h;\n\t\tmcast_obj->enqueue_cmd   = NULL;\n\t\tmcast_obj->hdl_restore   = NULL;\n\t\tmcast_obj->check_pending = bnx2x_mcast_check_pending;\n\n\t\t \n\t\tmcast_obj->max_cmd_len       = -1;\n\t\tmcast_obj->wait_comp         = bnx2x_mcast_wait;\n\t\tmcast_obj->set_one_rule      = NULL;\n\t\tmcast_obj->validate          = bnx2x_mcast_validate_e1h;\n\t\tmcast_obj->revert            = bnx2x_mcast_revert_e1h;\n\t\tmcast_obj->get_registry_size =\n\t\t\tbnx2x_mcast_get_registry_size_aprox;\n\t\tmcast_obj->set_registry_size =\n\t\t\tbnx2x_mcast_set_registry_size_aprox;\n\t} else {\n\t\tmcast_obj->config_mcast      = bnx2x_mcast_setup_e2;\n\t\tmcast_obj->enqueue_cmd       = bnx2x_mcast_enqueue_cmd;\n\t\tmcast_obj->hdl_restore       =\n\t\t\tbnx2x_mcast_handle_restore_cmd_e2;\n\t\tmcast_obj->check_pending     = bnx2x_mcast_check_pending;\n\t\t \n\t\tmcast_obj->max_cmd_len       = 16;\n\t\tmcast_obj->wait_comp         = bnx2x_mcast_wait;\n\t\tmcast_obj->set_one_rule      = bnx2x_mcast_set_one_rule_e2;\n\t\tmcast_obj->validate          = bnx2x_mcast_validate_e2;\n\t\tmcast_obj->revert            = bnx2x_mcast_revert_e2;\n\t\tmcast_obj->get_registry_size =\n\t\t\tbnx2x_mcast_get_registry_size_aprox;\n\t\tmcast_obj->set_registry_size =\n\t\t\tbnx2x_mcast_set_registry_size_aprox;\n\t}\n}\n\n \n\n \nstatic inline bool __atomic_add_ifless(atomic_t *v, int a, int u)\n{\n\tint c, old;\n\n\tc = atomic_read(v);\n\tfor (;;) {\n\t\tif (unlikely(c + a >= u))\n\t\t\treturn false;\n\n\t\told = atomic_cmpxchg((v), c, c + a);\n\t\tif (likely(old == c))\n\t\t\tbreak;\n\t\tc = old;\n\t}\n\n\treturn true;\n}\n\n \nstatic inline bool __atomic_dec_ifmoe(atomic_t *v, int a, int u)\n{\n\tint c, old;\n\n\tc = atomic_read(v);\n\tfor (;;) {\n\t\tif (unlikely(c - a < u))\n\t\t\treturn false;\n\n\t\told = atomic_cmpxchg((v), c, c - a);\n\t\tif (likely(old == c))\n\t\t\tbreak;\n\t\tc = old;\n\t}\n\n\treturn true;\n}\n\nstatic bool bnx2x_credit_pool_get(struct bnx2x_credit_pool_obj *o, int cnt)\n{\n\tbool rc;\n\n\tsmp_mb();\n\trc = __atomic_dec_ifmoe(&o->credit, cnt, 0);\n\tsmp_mb();\n\n\treturn rc;\n}\n\nstatic bool bnx2x_credit_pool_put(struct bnx2x_credit_pool_obj *o, int cnt)\n{\n\tbool rc;\n\n\tsmp_mb();\n\n\t \n\trc = __atomic_add_ifless(&o->credit, cnt, o->pool_sz + 1);\n\n\tsmp_mb();\n\n\treturn rc;\n}\n\nstatic int bnx2x_credit_pool_check(struct bnx2x_credit_pool_obj *o)\n{\n\tint cur_credit;\n\n\tsmp_mb();\n\tcur_credit = atomic_read(&o->credit);\n\n\treturn cur_credit;\n}\n\nstatic bool bnx2x_credit_pool_always_true(struct bnx2x_credit_pool_obj *o,\n\t\t\t\t\t  int cnt)\n{\n\treturn true;\n}\n\nstatic bool bnx2x_credit_pool_get_entry(\n\tstruct bnx2x_credit_pool_obj *o,\n\tint *offset)\n{\n\tint idx, vec, i;\n\n\t*offset = -1;\n\n\t \n\tfor (vec = 0; vec < BNX2X_POOL_VEC_SIZE; vec++) {\n\n\t\t \n\t\tif (!o->pool_mirror[vec])\n\t\t\tcontinue;\n\n\t\t \n\t\tfor (idx = vec * BIT_VEC64_ELEM_SZ, i = 0;\n\t\t      i < BIT_VEC64_ELEM_SZ; idx++, i++)\n\n\t\t\tif (BIT_VEC64_TEST_BIT(o->pool_mirror, idx)) {\n\t\t\t\t \n\t\t\t\tBIT_VEC64_CLEAR_BIT(o->pool_mirror, idx);\n\t\t\t\t*offset = o->base_pool_offset + idx;\n\t\t\t\treturn true;\n\t\t\t}\n\t}\n\n\treturn false;\n}\n\nstatic bool bnx2x_credit_pool_put_entry(\n\tstruct bnx2x_credit_pool_obj *o,\n\tint offset)\n{\n\tif (offset < o->base_pool_offset)\n\t\treturn false;\n\n\toffset -= o->base_pool_offset;\n\n\tif (offset >= o->pool_sz)\n\t\treturn false;\n\n\t \n\tBIT_VEC64_SET_BIT(o->pool_mirror, offset);\n\n\treturn true;\n}\n\nstatic bool bnx2x_credit_pool_put_entry_always_true(\n\tstruct bnx2x_credit_pool_obj *o,\n\tint offset)\n{\n\treturn true;\n}\n\nstatic bool bnx2x_credit_pool_get_entry_always_true(\n\tstruct bnx2x_credit_pool_obj *o,\n\tint *offset)\n{\n\t*offset = -1;\n\treturn true;\n}\n \nvoid bnx2x_init_credit_pool(struct bnx2x_credit_pool_obj *p,\n\t\t\t    int base, int credit)\n{\n\t \n\tmemset(p, 0, sizeof(*p));\n\n\t \n\tmemset(&p->pool_mirror, 0xff, sizeof(p->pool_mirror));\n\n\t \n\tatomic_set(&p->credit, credit);\n\n\t \n\tp->pool_sz = credit;\n\n\tp->base_pool_offset = base;\n\n\t \n\tsmp_mb();\n\n\tp->check = bnx2x_credit_pool_check;\n\n\t \n\tif (credit >= 0) {\n\t\tp->put      = bnx2x_credit_pool_put;\n\t\tp->get      = bnx2x_credit_pool_get;\n\t\tp->put_entry = bnx2x_credit_pool_put_entry;\n\t\tp->get_entry = bnx2x_credit_pool_get_entry;\n\t} else {\n\t\tp->put      = bnx2x_credit_pool_always_true;\n\t\tp->get      = bnx2x_credit_pool_always_true;\n\t\tp->put_entry = bnx2x_credit_pool_put_entry_always_true;\n\t\tp->get_entry = bnx2x_credit_pool_get_entry_always_true;\n\t}\n\n\t \n\tif (base < 0) {\n\t\tp->put_entry = bnx2x_credit_pool_put_entry_always_true;\n\t\tp->get_entry = bnx2x_credit_pool_get_entry_always_true;\n\t}\n}\n\nvoid bnx2x_init_mac_credit_pool(struct bnx2x *bp,\n\t\t\t\tstruct bnx2x_credit_pool_obj *p, u8 func_id,\n\t\t\t\tu8 func_num)\n{\n \n#define BNX2X_CAM_SIZE_EMUL 5\n\n\tint cam_sz;\n\n\tif (CHIP_IS_E1(bp)) {\n\t\t \n\t\tif (!CHIP_REV_IS_SLOW(bp))\n\t\t\tcam_sz = (MAX_MAC_CREDIT_E1 / 2) - BNX2X_MAX_MULTICAST;\n\t\telse\n\t\t\tcam_sz = BNX2X_CAM_SIZE_EMUL - BNX2X_MAX_EMUL_MULTI;\n\n\t\tbnx2x_init_credit_pool(p, func_id * cam_sz, cam_sz);\n\n\t} else if (CHIP_IS_E1H(bp)) {\n\t\t \n\t\tif ((func_num > 0)) {\n\t\t\tif (!CHIP_REV_IS_SLOW(bp))\n\t\t\t\tcam_sz = (MAX_MAC_CREDIT_E1H / (2*func_num));\n\t\t\telse\n\t\t\t\tcam_sz = BNX2X_CAM_SIZE_EMUL;\n\t\t\tbnx2x_init_credit_pool(p, func_id * cam_sz, cam_sz);\n\t\t} else {\n\t\t\t \n\t\t\tbnx2x_init_credit_pool(p, 0, 0);\n\t\t}\n\n\t} else {\n\n\t\t \n\t\tif (func_num > 0) {\n\t\t\tif (!CHIP_REV_IS_SLOW(bp))\n\t\t\t\tcam_sz = PF_MAC_CREDIT_E2(bp, func_num);\n\t\t\telse\n\t\t\t\tcam_sz = BNX2X_CAM_SIZE_EMUL;\n\n\t\t\t \n\t\t\tbnx2x_init_credit_pool(p, -1, cam_sz);\n\t\t} else {\n\t\t\t \n\t\t\tbnx2x_init_credit_pool(p, 0, 0);\n\t\t}\n\t}\n}\n\nvoid bnx2x_init_vlan_credit_pool(struct bnx2x *bp,\n\t\t\t\t struct bnx2x_credit_pool_obj *p,\n\t\t\t\t u8 func_id,\n\t\t\t\t u8 func_num)\n{\n\tif (CHIP_IS_E1x(bp)) {\n\t\t \n\t\tbnx2x_init_credit_pool(p, 0, -1);\n\t} else {\n\t\t \n\t\tif (func_num > 0) {\n\t\t\tint credit = PF_VLAN_CREDIT_E2(bp, func_num);\n\n\t\t\tbnx2x_init_credit_pool(p, -1 , credit);\n\t\t} else\n\t\t\t \n\t\t\tbnx2x_init_credit_pool(p, 0, 0);\n\t}\n}\n\n \n \nstatic inline void bnx2x_debug_print_ind_table(struct bnx2x *bp,\n\t\t\t\t\tstruct bnx2x_config_rss_params *p)\n{\n\tint i;\n\n\tDP(BNX2X_MSG_SP, \"Setting indirection table to:\\n\");\n\tDP(BNX2X_MSG_SP, \"0x0000: \");\n\tfor (i = 0; i < T_ETH_INDIRECTION_TABLE_SIZE; i++) {\n\t\tDP_CONT(BNX2X_MSG_SP, \"0x%02x \", p->ind_table[i]);\n\n\t\t \n\t\tif ((i + 1 < T_ETH_INDIRECTION_TABLE_SIZE) &&\n\t\t    (((i + 1) & 0x3) == 0)) {\n\t\t\tDP_CONT(BNX2X_MSG_SP, \"\\n\");\n\t\t\tDP(BNX2X_MSG_SP, \"0x%04x: \", i + 1);\n\t\t}\n\t}\n\n\tDP_CONT(BNX2X_MSG_SP, \"\\n\");\n}\n\n \nstatic int bnx2x_setup_rss(struct bnx2x *bp,\n\t\t\t   struct bnx2x_config_rss_params *p)\n{\n\tstruct bnx2x_rss_config_obj *o = p->rss_obj;\n\tstruct bnx2x_raw_obj *r = &o->raw;\n\tstruct eth_rss_update_ramrod_data *data =\n\t\t(struct eth_rss_update_ramrod_data *)(r->rdata);\n\tu16 caps = 0;\n\tu8 rss_mode = 0;\n\tint rc;\n\n\tmemset(data, 0, sizeof(*data));\n\n\tDP(BNX2X_MSG_SP, \"Configuring RSS\\n\");\n\n\t \n\tdata->echo = cpu_to_le32((r->cid & BNX2X_SWCID_MASK) |\n\t\t\t\t (r->state << BNX2X_SWCID_SHIFT));\n\n\t \n\tif (test_bit(BNX2X_RSS_MODE_DISABLED, &p->rss_flags))\n\t\trss_mode = ETH_RSS_MODE_DISABLED;\n\telse if (test_bit(BNX2X_RSS_MODE_REGULAR, &p->rss_flags))\n\t\trss_mode = ETH_RSS_MODE_REGULAR;\n\n\tdata->rss_mode = rss_mode;\n\n\tDP(BNX2X_MSG_SP, \"rss_mode=%d\\n\", rss_mode);\n\n\t \n\tif (test_bit(BNX2X_RSS_IPV4, &p->rss_flags))\n\t\tcaps |= ETH_RSS_UPDATE_RAMROD_DATA_IPV4_CAPABILITY;\n\n\tif (test_bit(BNX2X_RSS_IPV4_TCP, &p->rss_flags))\n\t\tcaps |= ETH_RSS_UPDATE_RAMROD_DATA_IPV4_TCP_CAPABILITY;\n\n\tif (test_bit(BNX2X_RSS_IPV4_UDP, &p->rss_flags))\n\t\tcaps |= ETH_RSS_UPDATE_RAMROD_DATA_IPV4_UDP_CAPABILITY;\n\n\tif (test_bit(BNX2X_RSS_IPV6, &p->rss_flags))\n\t\tcaps |= ETH_RSS_UPDATE_RAMROD_DATA_IPV6_CAPABILITY;\n\n\tif (test_bit(BNX2X_RSS_IPV6_TCP, &p->rss_flags))\n\t\tcaps |= ETH_RSS_UPDATE_RAMROD_DATA_IPV6_TCP_CAPABILITY;\n\n\tif (test_bit(BNX2X_RSS_IPV6_UDP, &p->rss_flags))\n\t\tcaps |= ETH_RSS_UPDATE_RAMROD_DATA_IPV6_UDP_CAPABILITY;\n\n\tif (test_bit(BNX2X_RSS_IPV4_VXLAN, &p->rss_flags))\n\t\tcaps |= ETH_RSS_UPDATE_RAMROD_DATA_IPV4_VXLAN_CAPABILITY;\n\n\tif (test_bit(BNX2X_RSS_IPV6_VXLAN, &p->rss_flags))\n\t\tcaps |= ETH_RSS_UPDATE_RAMROD_DATA_IPV6_VXLAN_CAPABILITY;\n\n\tif (test_bit(BNX2X_RSS_TUNN_INNER_HDRS, &p->rss_flags))\n\t\tcaps |= ETH_RSS_UPDATE_RAMROD_DATA_TUNN_INNER_HDRS_CAPABILITY;\n\n\t \n\tif (test_bit(BNX2X_RSS_SET_SRCH, &p->rss_flags)) {\n\t\tu8 *dst = (u8 *)(data->rss_key) + sizeof(data->rss_key);\n\t\tconst u8 *src = (const u8 *)p->rss_key;\n\t\tint i;\n\n\t\t \n\t\tfor (i = 0; i < sizeof(data->rss_key); i++)\n\t\t\t*--dst = *src++;\n\n\t\tcaps |= ETH_RSS_UPDATE_RAMROD_DATA_UPDATE_RSS_KEY;\n\t}\n\n\tdata->capabilities = cpu_to_le16(caps);\n\n\t \n\tdata->rss_result_mask = p->rss_result_mask;\n\n\t \n\tdata->rss_engine_id = o->engine_id;\n\n\tDP(BNX2X_MSG_SP, \"rss_engine_id=%d\\n\", data->rss_engine_id);\n\n\t \n\tmemcpy(data->indirection_table, p->ind_table,\n\t\t  T_ETH_INDIRECTION_TABLE_SIZE);\n\n\t \n\tmemcpy(o->ind_table, p->ind_table, T_ETH_INDIRECTION_TABLE_SIZE);\n\n\t \n\tif (netif_msg_ifup(bp))\n\t\tbnx2x_debug_print_ind_table(bp, p);\n\n\t \n\n\t \n\trc = bnx2x_sp_post(bp, RAMROD_CMD_ID_ETH_RSS_UPDATE, r->cid,\n\t\t\t   U64_HI(r->rdata_mapping),\n\t\t\t   U64_LO(r->rdata_mapping),\n\t\t\t   ETH_CONNECTION_TYPE);\n\n\tif (rc < 0)\n\t\treturn rc;\n\n\treturn 1;\n}\n\nvoid bnx2x_get_rss_ind_table(struct bnx2x_rss_config_obj *rss_obj,\n\t\t\t     u8 *ind_table)\n{\n\tmemcpy(ind_table, rss_obj->ind_table, sizeof(rss_obj->ind_table));\n}\n\nint bnx2x_config_rss(struct bnx2x *bp,\n\t\t     struct bnx2x_config_rss_params *p)\n{\n\tint rc;\n\tstruct bnx2x_rss_config_obj *o = p->rss_obj;\n\tstruct bnx2x_raw_obj *r = &o->raw;\n\n\t \n\tif (test_bit(RAMROD_DRV_CLR_ONLY, &p->ramrod_flags)) {\n\t\tDP(BNX2X_MSG_SP, \"Not configuring RSS ramrod_flags=%lx\\n\",\n\t\t   p->ramrod_flags);\n\t\treturn 0;\n\t}\n\n\tr->set_pending(r);\n\n\trc = o->config_rss(bp, p);\n\tif (rc < 0) {\n\t\tr->clear_pending(r);\n\t\treturn rc;\n\t}\n\n\tif (test_bit(RAMROD_COMP_WAIT, &p->ramrod_flags))\n\t\trc = r->wait_comp(bp, r);\n\n\treturn rc;\n}\n\nvoid bnx2x_init_rss_config_obj(struct bnx2x *bp,\n\t\t\t       struct bnx2x_rss_config_obj *rss_obj,\n\t\t\t       u8 cl_id, u32 cid, u8 func_id, u8 engine_id,\n\t\t\t       void *rdata, dma_addr_t rdata_mapping,\n\t\t\t       int state, unsigned long *pstate,\n\t\t\t       bnx2x_obj_type type)\n{\n\tbnx2x_init_raw_obj(&rss_obj->raw, cl_id, cid, func_id, rdata,\n\t\t\t   rdata_mapping, state, pstate, type);\n\n\trss_obj->engine_id  = engine_id;\n\trss_obj->config_rss = bnx2x_setup_rss;\n}\n\n \n\n \nint bnx2x_queue_state_change(struct bnx2x *bp,\n\t\t\t     struct bnx2x_queue_state_params *params)\n{\n\tstruct bnx2x_queue_sp_obj *o = params->q_obj;\n\tint rc, pending_bit;\n\tunsigned long *pending = &o->pending;\n\n\t \n\trc = o->check_transition(bp, o, params);\n\tif (rc) {\n\t\tBNX2X_ERR(\"check transition returned an error. rc %d\\n\", rc);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tDP(BNX2X_MSG_SP, \"pending bit was=%lx\\n\", o->pending);\n\tpending_bit = o->set_pending(o, params);\n\tDP(BNX2X_MSG_SP, \"pending bit now=%lx\\n\", o->pending);\n\n\t \n\tif (test_bit(RAMROD_DRV_CLR_ONLY, &params->ramrod_flags))\n\t\to->complete_cmd(bp, o, pending_bit);\n\telse {\n\t\t \n\t\trc = o->send_cmd(bp, params);\n\t\tif (rc) {\n\t\t\to->next_state = BNX2X_Q_STATE_MAX;\n\t\t\tclear_bit(pending_bit, pending);\n\t\t\tsmp_mb__after_atomic();\n\t\t\treturn rc;\n\t\t}\n\n\t\tif (test_bit(RAMROD_COMP_WAIT, &params->ramrod_flags)) {\n\t\t\trc = o->wait_comp(bp, o, pending_bit);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn !!test_bit(pending_bit, pending);\n}\n\nstatic int bnx2x_queue_set_pending(struct bnx2x_queue_sp_obj *obj,\n\t\t\t\t   struct bnx2x_queue_state_params *params)\n{\n\tenum bnx2x_queue_cmd cmd = params->cmd, bit;\n\n\t \n\tif ((cmd == BNX2X_Q_CMD_ACTIVATE) ||\n\t    (cmd == BNX2X_Q_CMD_DEACTIVATE))\n\t\tbit = BNX2X_Q_CMD_UPDATE;\n\telse\n\t\tbit = cmd;\n\n\tset_bit(bit, &obj->pending);\n\treturn bit;\n}\n\nstatic int bnx2x_queue_wait_comp(struct bnx2x *bp,\n\t\t\t\t struct bnx2x_queue_sp_obj *o,\n\t\t\t\t enum bnx2x_queue_cmd cmd)\n{\n\treturn bnx2x_state_wait(bp, cmd, &o->pending);\n}\n\n \nstatic int bnx2x_queue_comp_cmd(struct bnx2x *bp,\n\t\t\t\tstruct bnx2x_queue_sp_obj *o,\n\t\t\t\tenum bnx2x_queue_cmd cmd)\n{\n\tunsigned long cur_pending = o->pending;\n\n\tif (!test_and_clear_bit(cmd, &cur_pending)) {\n\t\tBNX2X_ERR(\"Bad MC reply %d for queue %d in state %d pending 0x%lx, next_state %d\\n\",\n\t\t\t  cmd, o->cids[BNX2X_PRIMARY_CID_INDEX],\n\t\t\t  o->state, cur_pending, o->next_state);\n\t\treturn -EINVAL;\n\t}\n\n\tif (o->next_tx_only >= o->max_cos)\n\t\t \n\t\tBNX2X_ERR(\"illegal value for next tx_only: %d. max cos was %d\",\n\t\t\t   o->next_tx_only, o->max_cos);\n\n\tDP(BNX2X_MSG_SP,\n\t   \"Completing command %d for queue %d, setting state to %d\\n\",\n\t   cmd, o->cids[BNX2X_PRIMARY_CID_INDEX], o->next_state);\n\n\tif (o->next_tx_only)   \n\t\tDP(BNX2X_MSG_SP, \"primary cid %d: num tx-only cons %d\\n\",\n\t\t   o->cids[BNX2X_PRIMARY_CID_INDEX], o->next_tx_only);\n\n\to->state = o->next_state;\n\to->num_tx_only = o->next_tx_only;\n\to->next_state = BNX2X_Q_STATE_MAX;\n\n\t \n\twmb();\n\n\tclear_bit(cmd, &o->pending);\n\tsmp_mb__after_atomic();\n\n\treturn 0;\n}\n\nstatic void bnx2x_q_fill_setup_data_e2(struct bnx2x *bp,\n\t\t\t\tstruct bnx2x_queue_state_params *cmd_params,\n\t\t\t\tstruct client_init_ramrod_data *data)\n{\n\tstruct bnx2x_queue_setup_params *params = &cmd_params->params.setup;\n\n\t \n\n\t \n\tdata->rx.tpa_en |= test_bit(BNX2X_Q_FLG_TPA_IPV6, &params->flags) *\n\t\t\t\tCLIENT_INIT_RX_DATA_TPA_EN_IPV6;\n}\n\nstatic void bnx2x_q_fill_init_general_data(struct bnx2x *bp,\n\t\t\t\tstruct bnx2x_queue_sp_obj *o,\n\t\t\t\tstruct bnx2x_general_setup_params *params,\n\t\t\t\tstruct client_init_general_data *gen_data,\n\t\t\t\tunsigned long *flags)\n{\n\tgen_data->client_id = o->cl_id;\n\n\tif (test_bit(BNX2X_Q_FLG_STATS, flags)) {\n\t\tgen_data->statistics_counter_id =\n\t\t\t\t\tparams->stat_id;\n\t\tgen_data->statistics_en_flg = 1;\n\t\tgen_data->statistics_zero_flg =\n\t\t\ttest_bit(BNX2X_Q_FLG_ZERO_STATS, flags);\n\t} else\n\t\tgen_data->statistics_counter_id =\n\t\t\t\t\tDISABLE_STATISTIC_COUNTER_ID_VALUE;\n\n\tgen_data->is_fcoe_flg = test_bit(BNX2X_Q_FLG_FCOE, flags);\n\tgen_data->activate_flg = test_bit(BNX2X_Q_FLG_ACTIVE, flags);\n\tgen_data->sp_client_id = params->spcl_id;\n\tgen_data->mtu = cpu_to_le16(params->mtu);\n\tgen_data->func_id = o->func_id;\n\n\tgen_data->cos = params->cos;\n\n\tgen_data->traffic_type =\n\t\ttest_bit(BNX2X_Q_FLG_FCOE, flags) ?\n\t\tLLFC_TRAFFIC_TYPE_FCOE : LLFC_TRAFFIC_TYPE_NW;\n\n\tgen_data->fp_hsi_ver = params->fp_hsi;\n\n\tDP(BNX2X_MSG_SP, \"flags: active %d, cos %d, stats en %d\\n\",\n\t   gen_data->activate_flg, gen_data->cos, gen_data->statistics_en_flg);\n}\n\nstatic void bnx2x_q_fill_init_tx_data(struct bnx2x_queue_sp_obj *o,\n\t\t\t\tstruct bnx2x_txq_setup_params *params,\n\t\t\t\tstruct client_init_tx_data *tx_data,\n\t\t\t\tunsigned long *flags)\n{\n\ttx_data->enforce_security_flg =\n\t\ttest_bit(BNX2X_Q_FLG_TX_SEC, flags);\n\ttx_data->default_vlan =\n\t\tcpu_to_le16(params->default_vlan);\n\ttx_data->default_vlan_flg =\n\t\ttest_bit(BNX2X_Q_FLG_DEF_VLAN, flags);\n\ttx_data->tx_switching_flg =\n\t\ttest_bit(BNX2X_Q_FLG_TX_SWITCH, flags);\n\ttx_data->anti_spoofing_flg =\n\t\ttest_bit(BNX2X_Q_FLG_ANTI_SPOOF, flags);\n\ttx_data->force_default_pri_flg =\n\t\ttest_bit(BNX2X_Q_FLG_FORCE_DEFAULT_PRI, flags);\n\ttx_data->refuse_outband_vlan_flg =\n\t\ttest_bit(BNX2X_Q_FLG_REFUSE_OUTBAND_VLAN, flags);\n\ttx_data->tunnel_lso_inc_ip_id =\n\t\ttest_bit(BNX2X_Q_FLG_TUN_INC_INNER_IP_ID, flags);\n\ttx_data->tunnel_non_lso_pcsum_location =\n\t\ttest_bit(BNX2X_Q_FLG_PCSUM_ON_PKT, flags) ? CSUM_ON_PKT :\n\t\t\t\t\t\t\t    CSUM_ON_BD;\n\n\ttx_data->tx_status_block_id = params->fw_sb_id;\n\ttx_data->tx_sb_index_number = params->sb_cq_index;\n\ttx_data->tss_leading_client_id = params->tss_leading_cl_id;\n\n\ttx_data->tx_bd_page_base.lo =\n\t\tcpu_to_le32(U64_LO(params->dscr_map));\n\ttx_data->tx_bd_page_base.hi =\n\t\tcpu_to_le32(U64_HI(params->dscr_map));\n\n\t \n\ttx_data->state = 0;\n}\n\nstatic void bnx2x_q_fill_init_pause_data(struct bnx2x_queue_sp_obj *o,\n\t\t\t\tstruct rxq_pause_params *params,\n\t\t\t\tstruct client_init_rx_data *rx_data)\n{\n\t \n\trx_data->cqe_pause_thr_low = cpu_to_le16(params->rcq_th_lo);\n\trx_data->cqe_pause_thr_high = cpu_to_le16(params->rcq_th_hi);\n\trx_data->bd_pause_thr_low = cpu_to_le16(params->bd_th_lo);\n\trx_data->bd_pause_thr_high = cpu_to_le16(params->bd_th_hi);\n\trx_data->sge_pause_thr_low = cpu_to_le16(params->sge_th_lo);\n\trx_data->sge_pause_thr_high = cpu_to_le16(params->sge_th_hi);\n\trx_data->rx_cos_mask = cpu_to_le16(params->pri_map);\n}\n\nstatic void bnx2x_q_fill_init_rx_data(struct bnx2x_queue_sp_obj *o,\n\t\t\t\tstruct bnx2x_rxq_setup_params *params,\n\t\t\t\tstruct client_init_rx_data *rx_data,\n\t\t\t\tunsigned long *flags)\n{\n\trx_data->tpa_en = test_bit(BNX2X_Q_FLG_TPA, flags) *\n\t\t\t\tCLIENT_INIT_RX_DATA_TPA_EN_IPV4;\n\trx_data->tpa_en |= test_bit(BNX2X_Q_FLG_TPA_GRO, flags) *\n\t\t\t\tCLIENT_INIT_RX_DATA_TPA_MODE;\n\trx_data->vmqueue_mode_en_flg = 0;\n\n\trx_data->cache_line_alignment_log_size =\n\t\tparams->cache_line_log;\n\trx_data->enable_dynamic_hc =\n\t\ttest_bit(BNX2X_Q_FLG_DHC, flags);\n\trx_data->max_sges_for_packet = params->max_sges_pkt;\n\trx_data->client_qzone_id = params->cl_qzone_id;\n\trx_data->max_agg_size = cpu_to_le16(params->tpa_agg_sz);\n\n\t \n\trx_data->state = cpu_to_le16(CLIENT_INIT_RX_DATA_UCAST_DROP_ALL |\n\t\t\t\t     CLIENT_INIT_RX_DATA_MCAST_DROP_ALL);\n\n\t \n\trx_data->drop_ip_cs_err_flg = 0;\n\trx_data->drop_tcp_cs_err_flg = 0;\n\trx_data->drop_ttl0_flg = 0;\n\trx_data->drop_udp_cs_err_flg = 0;\n\trx_data->inner_vlan_removal_enable_flg =\n\t\ttest_bit(BNX2X_Q_FLG_VLAN, flags);\n\trx_data->outer_vlan_removal_enable_flg =\n\t\ttest_bit(BNX2X_Q_FLG_OV, flags);\n\trx_data->status_block_id = params->fw_sb_id;\n\trx_data->rx_sb_index_number = params->sb_cq_index;\n\trx_data->max_tpa_queues = params->max_tpa_queues;\n\trx_data->max_bytes_on_bd = cpu_to_le16(params->buf_sz);\n\trx_data->sge_buff_size = cpu_to_le16(params->sge_buf_sz);\n\trx_data->bd_page_base.lo =\n\t\tcpu_to_le32(U64_LO(params->dscr_map));\n\trx_data->bd_page_base.hi =\n\t\tcpu_to_le32(U64_HI(params->dscr_map));\n\trx_data->sge_page_base.lo =\n\t\tcpu_to_le32(U64_LO(params->sge_map));\n\trx_data->sge_page_base.hi =\n\t\tcpu_to_le32(U64_HI(params->sge_map));\n\trx_data->cqe_page_base.lo =\n\t\tcpu_to_le32(U64_LO(params->rcq_map));\n\trx_data->cqe_page_base.hi =\n\t\tcpu_to_le32(U64_HI(params->rcq_map));\n\trx_data->is_leading_rss = test_bit(BNX2X_Q_FLG_LEADING_RSS, flags);\n\n\tif (test_bit(BNX2X_Q_FLG_MCAST, flags)) {\n\t\trx_data->approx_mcast_engine_id = params->mcast_engine_id;\n\t\trx_data->is_approx_mcast = 1;\n\t}\n\n\trx_data->rss_engine_id = params->rss_engine_id;\n\n\t \n\trx_data->silent_vlan_removal_flg =\n\t\ttest_bit(BNX2X_Q_FLG_SILENT_VLAN_REM, flags);\n\trx_data->silent_vlan_value =\n\t\tcpu_to_le16(params->silent_removal_value);\n\trx_data->silent_vlan_mask =\n\t\tcpu_to_le16(params->silent_removal_mask);\n}\n\n \nstatic void bnx2x_q_fill_setup_data_cmn(struct bnx2x *bp,\n\t\t\t\tstruct bnx2x_queue_state_params *cmd_params,\n\t\t\t\tstruct client_init_ramrod_data *data)\n{\n\tbnx2x_q_fill_init_general_data(bp, cmd_params->q_obj,\n\t\t\t\t       &cmd_params->params.setup.gen_params,\n\t\t\t\t       &data->general,\n\t\t\t\t       &cmd_params->params.setup.flags);\n\n\tbnx2x_q_fill_init_tx_data(cmd_params->q_obj,\n\t\t\t\t  &cmd_params->params.setup.txq_params,\n\t\t\t\t  &data->tx,\n\t\t\t\t  &cmd_params->params.setup.flags);\n\n\tbnx2x_q_fill_init_rx_data(cmd_params->q_obj,\n\t\t\t\t  &cmd_params->params.setup.rxq_params,\n\t\t\t\t  &data->rx,\n\t\t\t\t  &cmd_params->params.setup.flags);\n\n\tbnx2x_q_fill_init_pause_data(cmd_params->q_obj,\n\t\t\t\t     &cmd_params->params.setup.pause_params,\n\t\t\t\t     &data->rx);\n}\n\n \nstatic void bnx2x_q_fill_setup_tx_only(struct bnx2x *bp,\n\t\t\t\tstruct bnx2x_queue_state_params *cmd_params,\n\t\t\t\tstruct tx_queue_init_ramrod_data *data)\n{\n\tbnx2x_q_fill_init_general_data(bp, cmd_params->q_obj,\n\t\t\t\t       &cmd_params->params.tx_only.gen_params,\n\t\t\t\t       &data->general,\n\t\t\t\t       &cmd_params->params.tx_only.flags);\n\n\tbnx2x_q_fill_init_tx_data(cmd_params->q_obj,\n\t\t\t\t  &cmd_params->params.tx_only.txq_params,\n\t\t\t\t  &data->tx,\n\t\t\t\t  &cmd_params->params.tx_only.flags);\n\n\tDP(BNX2X_MSG_SP, \"cid %d, tx bd page lo %x hi %x\",\n\t\t\t cmd_params->q_obj->cids[0],\n\t\t\t data->tx.tx_bd_page_base.lo,\n\t\t\t data->tx.tx_bd_page_base.hi);\n}\n\n \nstatic inline int bnx2x_q_init(struct bnx2x *bp,\n\t\t\t       struct bnx2x_queue_state_params *params)\n{\n\tstruct bnx2x_queue_sp_obj *o = params->q_obj;\n\tstruct bnx2x_queue_init_params *init = &params->params.init;\n\tu16 hc_usec;\n\tu8 cos;\n\n\t \n\tif (test_bit(BNX2X_Q_TYPE_HAS_TX, &o->type) &&\n\t    test_bit(BNX2X_Q_FLG_HC, &init->tx.flags)) {\n\t\thc_usec = init->tx.hc_rate ? 1000000 / init->tx.hc_rate : 0;\n\n\t\tbnx2x_update_coalesce_sb_index(bp, init->tx.fw_sb_id,\n\t\t\tinit->tx.sb_cq_index,\n\t\t\t!test_bit(BNX2X_Q_FLG_HC_EN, &init->tx.flags),\n\t\t\thc_usec);\n\t}\n\n\t \n\tif (test_bit(BNX2X_Q_TYPE_HAS_RX, &o->type) &&\n\t    test_bit(BNX2X_Q_FLG_HC, &init->rx.flags)) {\n\t\thc_usec = init->rx.hc_rate ? 1000000 / init->rx.hc_rate : 0;\n\n\t\tbnx2x_update_coalesce_sb_index(bp, init->rx.fw_sb_id,\n\t\t\tinit->rx.sb_cq_index,\n\t\t\t!test_bit(BNX2X_Q_FLG_HC_EN, &init->rx.flags),\n\t\t\thc_usec);\n\t}\n\n\t \n\tfor (cos = 0; cos < o->max_cos; cos++) {\n\t\tDP(BNX2X_MSG_SP, \"setting context validation. cid %d, cos %d\\n\",\n\t\t\t\t o->cids[cos], cos);\n\t\tDP(BNX2X_MSG_SP, \"context pointer %p\\n\", init->cxts[cos]);\n\t\tbnx2x_set_ctx_validation(bp, init->cxts[cos], o->cids[cos]);\n\t}\n\n\t \n\to->complete_cmd(bp, o, BNX2X_Q_CMD_INIT);\n\n\tsmp_mb();\n\n\treturn 0;\n}\n\nstatic inline int bnx2x_q_send_setup_e1x(struct bnx2x *bp,\n\t\t\t\t\tstruct bnx2x_queue_state_params *params)\n{\n\tstruct bnx2x_queue_sp_obj *o = params->q_obj;\n\tstruct client_init_ramrod_data *rdata =\n\t\t(struct client_init_ramrod_data *)o->rdata;\n\tdma_addr_t data_mapping = o->rdata_mapping;\n\tint ramrod = RAMROD_CMD_ID_ETH_CLIENT_SETUP;\n\n\t \n\tmemset(rdata, 0, sizeof(*rdata));\n\n\t \n\tbnx2x_q_fill_setup_data_cmn(bp, params, rdata);\n\n\t \n\treturn bnx2x_sp_post(bp, ramrod, o->cids[BNX2X_PRIMARY_CID_INDEX],\n\t\t\t     U64_HI(data_mapping),\n\t\t\t     U64_LO(data_mapping), ETH_CONNECTION_TYPE);\n}\n\nstatic inline int bnx2x_q_send_setup_e2(struct bnx2x *bp,\n\t\t\t\t\tstruct bnx2x_queue_state_params *params)\n{\n\tstruct bnx2x_queue_sp_obj *o = params->q_obj;\n\tstruct client_init_ramrod_data *rdata =\n\t\t(struct client_init_ramrod_data *)o->rdata;\n\tdma_addr_t data_mapping = o->rdata_mapping;\n\tint ramrod = RAMROD_CMD_ID_ETH_CLIENT_SETUP;\n\n\t \n\tmemset(rdata, 0, sizeof(*rdata));\n\n\t \n\tbnx2x_q_fill_setup_data_cmn(bp, params, rdata);\n\tbnx2x_q_fill_setup_data_e2(bp, params, rdata);\n\n\t \n\treturn bnx2x_sp_post(bp, ramrod, o->cids[BNX2X_PRIMARY_CID_INDEX],\n\t\t\t     U64_HI(data_mapping),\n\t\t\t     U64_LO(data_mapping), ETH_CONNECTION_TYPE);\n}\n\nstatic inline int bnx2x_q_send_setup_tx_only(struct bnx2x *bp,\n\t\t\t\t  struct bnx2x_queue_state_params *params)\n{\n\tstruct bnx2x_queue_sp_obj *o = params->q_obj;\n\tstruct tx_queue_init_ramrod_data *rdata =\n\t\t(struct tx_queue_init_ramrod_data *)o->rdata;\n\tdma_addr_t data_mapping = o->rdata_mapping;\n\tint ramrod = RAMROD_CMD_ID_ETH_TX_QUEUE_SETUP;\n\tstruct bnx2x_queue_setup_tx_only_params *tx_only_params =\n\t\t&params->params.tx_only;\n\tu8 cid_index = tx_only_params->cid_index;\n\n\tif (cid_index >= o->max_cos) {\n\t\tBNX2X_ERR(\"queue[%d]: cid_index (%d) is out of range\\n\",\n\t\t\t  o->cl_id, cid_index);\n\t\treturn -EINVAL;\n\t}\n\n\tDP(BNX2X_MSG_SP, \"parameters received: cos: %d sp-id: %d\\n\",\n\t\t\t tx_only_params->gen_params.cos,\n\t\t\t tx_only_params->gen_params.spcl_id);\n\n\t \n\tmemset(rdata, 0, sizeof(*rdata));\n\n\t \n\tbnx2x_q_fill_setup_tx_only(bp, params, rdata);\n\n\tDP(BNX2X_MSG_SP, \"sending tx-only ramrod: cid %d, client-id %d, sp-client id %d, cos %d\\n\",\n\t\t\t o->cids[cid_index], rdata->general.client_id,\n\t\t\t rdata->general.sp_client_id, rdata->general.cos);\n\n\t \n\treturn bnx2x_sp_post(bp, ramrod, o->cids[cid_index],\n\t\t\t     U64_HI(data_mapping),\n\t\t\t     U64_LO(data_mapping), ETH_CONNECTION_TYPE);\n}\n\nstatic void bnx2x_q_fill_update_data(struct bnx2x *bp,\n\t\t\t\t     struct bnx2x_queue_sp_obj *obj,\n\t\t\t\t     struct bnx2x_queue_update_params *params,\n\t\t\t\t     struct client_update_ramrod_data *data)\n{\n\t \n\tdata->client_id = obj->cl_id;\n\n\t \n\tdata->func_id = obj->func_id;\n\n\t \n\tdata->default_vlan = cpu_to_le16(params->def_vlan);\n\n\t \n\tdata->inner_vlan_removal_enable_flg =\n\t\ttest_bit(BNX2X_Q_UPDATE_IN_VLAN_REM, &params->update_flags);\n\tdata->inner_vlan_removal_change_flg =\n\t\ttest_bit(BNX2X_Q_UPDATE_IN_VLAN_REM_CHNG,\n\t\t\t &params->update_flags);\n\n\t \n\tdata->outer_vlan_removal_enable_flg =\n\t\ttest_bit(BNX2X_Q_UPDATE_OUT_VLAN_REM, &params->update_flags);\n\tdata->outer_vlan_removal_change_flg =\n\t\ttest_bit(BNX2X_Q_UPDATE_OUT_VLAN_REM_CHNG,\n\t\t\t &params->update_flags);\n\n\t \n\tdata->anti_spoofing_enable_flg =\n\t\ttest_bit(BNX2X_Q_UPDATE_ANTI_SPOOF, &params->update_flags);\n\tdata->anti_spoofing_change_flg =\n\t\ttest_bit(BNX2X_Q_UPDATE_ANTI_SPOOF_CHNG, &params->update_flags);\n\n\t \n\tdata->activate_flg =\n\t\ttest_bit(BNX2X_Q_UPDATE_ACTIVATE, &params->update_flags);\n\tdata->activate_change_flg =\n\t\ttest_bit(BNX2X_Q_UPDATE_ACTIVATE_CHNG, &params->update_flags);\n\n\t \n\tdata->default_vlan_enable_flg =\n\t\ttest_bit(BNX2X_Q_UPDATE_DEF_VLAN_EN, &params->update_flags);\n\tdata->default_vlan_change_flg =\n\t\ttest_bit(BNX2X_Q_UPDATE_DEF_VLAN_EN_CHNG,\n\t\t\t &params->update_flags);\n\n\t \n\tdata->silent_vlan_change_flg =\n\t\ttest_bit(BNX2X_Q_UPDATE_SILENT_VLAN_REM_CHNG,\n\t\t\t &params->update_flags);\n\tdata->silent_vlan_removal_flg =\n\t\ttest_bit(BNX2X_Q_UPDATE_SILENT_VLAN_REM, &params->update_flags);\n\tdata->silent_vlan_value = cpu_to_le16(params->silent_removal_value);\n\tdata->silent_vlan_mask = cpu_to_le16(params->silent_removal_mask);\n\n\t \n\tdata->tx_switching_flg =\n\t\ttest_bit(BNX2X_Q_UPDATE_TX_SWITCHING, &params->update_flags);\n\tdata->tx_switching_change_flg =\n\t\ttest_bit(BNX2X_Q_UPDATE_TX_SWITCHING_CHNG,\n\t\t\t &params->update_flags);\n\n\t \n\tdata->handle_ptp_pkts_flg =\n\t\ttest_bit(BNX2X_Q_UPDATE_PTP_PKTS, &params->update_flags);\n\tdata->handle_ptp_pkts_change_flg =\n\t\ttest_bit(BNX2X_Q_UPDATE_PTP_PKTS_CHNG, &params->update_flags);\n}\n\nstatic inline int bnx2x_q_send_update(struct bnx2x *bp,\n\t\t\t\t      struct bnx2x_queue_state_params *params)\n{\n\tstruct bnx2x_queue_sp_obj *o = params->q_obj;\n\tstruct client_update_ramrod_data *rdata =\n\t\t(struct client_update_ramrod_data *)o->rdata;\n\tdma_addr_t data_mapping = o->rdata_mapping;\n\tstruct bnx2x_queue_update_params *update_params =\n\t\t&params->params.update;\n\tu8 cid_index = update_params->cid_index;\n\n\tif (cid_index >= o->max_cos) {\n\t\tBNX2X_ERR(\"queue[%d]: cid_index (%d) is out of range\\n\",\n\t\t\t  o->cl_id, cid_index);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tmemset(rdata, 0, sizeof(*rdata));\n\n\t \n\tbnx2x_q_fill_update_data(bp, o, update_params, rdata);\n\n\t \n\treturn bnx2x_sp_post(bp, RAMROD_CMD_ID_ETH_CLIENT_UPDATE,\n\t\t\t     o->cids[cid_index], U64_HI(data_mapping),\n\t\t\t     U64_LO(data_mapping), ETH_CONNECTION_TYPE);\n}\n\n \nstatic inline int bnx2x_q_send_deactivate(struct bnx2x *bp,\n\t\t\t\t\tstruct bnx2x_queue_state_params *params)\n{\n\tstruct bnx2x_queue_update_params *update = &params->params.update;\n\n\tmemset(update, 0, sizeof(*update));\n\n\t__set_bit(BNX2X_Q_UPDATE_ACTIVATE_CHNG, &update->update_flags);\n\n\treturn bnx2x_q_send_update(bp, params);\n}\n\n \nstatic inline int bnx2x_q_send_activate(struct bnx2x *bp,\n\t\t\t\t\tstruct bnx2x_queue_state_params *params)\n{\n\tstruct bnx2x_queue_update_params *update = &params->params.update;\n\n\tmemset(update, 0, sizeof(*update));\n\n\t__set_bit(BNX2X_Q_UPDATE_ACTIVATE, &update->update_flags);\n\t__set_bit(BNX2X_Q_UPDATE_ACTIVATE_CHNG, &update->update_flags);\n\n\treturn bnx2x_q_send_update(bp, params);\n}\n\nstatic void bnx2x_q_fill_update_tpa_data(struct bnx2x *bp,\n\t\t\t\tstruct bnx2x_queue_sp_obj *obj,\n\t\t\t\tstruct bnx2x_queue_update_tpa_params *params,\n\t\t\t\tstruct tpa_update_ramrod_data *data)\n{\n\tdata->client_id = obj->cl_id;\n\tdata->complete_on_both_clients = params->complete_on_both_clients;\n\tdata->dont_verify_rings_pause_thr_flg =\n\t\tparams->dont_verify_thr;\n\tdata->max_agg_size = cpu_to_le16(params->max_agg_sz);\n\tdata->max_sges_for_packet = params->max_sges_pkt;\n\tdata->max_tpa_queues = params->max_tpa_queues;\n\tdata->sge_buff_size = cpu_to_le16(params->sge_buff_sz);\n\tdata->sge_page_base_hi = cpu_to_le32(U64_HI(params->sge_map));\n\tdata->sge_page_base_lo = cpu_to_le32(U64_LO(params->sge_map));\n\tdata->sge_pause_thr_high = cpu_to_le16(params->sge_pause_thr_high);\n\tdata->sge_pause_thr_low = cpu_to_le16(params->sge_pause_thr_low);\n\tdata->tpa_mode = params->tpa_mode;\n\tdata->update_ipv4 = params->update_ipv4;\n\tdata->update_ipv6 = params->update_ipv6;\n}\n\nstatic inline int bnx2x_q_send_update_tpa(struct bnx2x *bp,\n\t\t\t\t\tstruct bnx2x_queue_state_params *params)\n{\n\tstruct bnx2x_queue_sp_obj *o = params->q_obj;\n\tstruct tpa_update_ramrod_data *rdata =\n\t\t(struct tpa_update_ramrod_data *)o->rdata;\n\tdma_addr_t data_mapping = o->rdata_mapping;\n\tstruct bnx2x_queue_update_tpa_params *update_tpa_params =\n\t\t&params->params.update_tpa;\n\tu16 type;\n\n\t \n\tmemset(rdata, 0, sizeof(*rdata));\n\n\t \n\tbnx2x_q_fill_update_tpa_data(bp, o, update_tpa_params, rdata);\n\n\t \n\ttype = ETH_CONNECTION_TYPE |\n\t\t((o->func_id) << SPE_HDR_FUNCTION_ID_SHIFT);\n\n\t \n\treturn bnx2x_sp_post(bp, RAMROD_CMD_ID_ETH_TPA_UPDATE,\n\t\t\t     o->cids[BNX2X_PRIMARY_CID_INDEX],\n\t\t\t     U64_HI(data_mapping),\n\t\t\t     U64_LO(data_mapping), type);\n}\n\nstatic inline int bnx2x_q_send_halt(struct bnx2x *bp,\n\t\t\t\t    struct bnx2x_queue_state_params *params)\n{\n\tstruct bnx2x_queue_sp_obj *o = params->q_obj;\n\n\treturn bnx2x_sp_post(bp, RAMROD_CMD_ID_ETH_HALT,\n\t\t\t     o->cids[BNX2X_PRIMARY_CID_INDEX], 0, o->cl_id,\n\t\t\t     ETH_CONNECTION_TYPE);\n}\n\nstatic inline int bnx2x_q_send_cfc_del(struct bnx2x *bp,\n\t\t\t\t       struct bnx2x_queue_state_params *params)\n{\n\tstruct bnx2x_queue_sp_obj *o = params->q_obj;\n\tu8 cid_idx = params->params.cfc_del.cid_index;\n\n\tif (cid_idx >= o->max_cos) {\n\t\tBNX2X_ERR(\"queue[%d]: cid_index (%d) is out of range\\n\",\n\t\t\t  o->cl_id, cid_idx);\n\t\treturn -EINVAL;\n\t}\n\n\treturn bnx2x_sp_post(bp, RAMROD_CMD_ID_COMMON_CFC_DEL,\n\t\t\t     o->cids[cid_idx], 0, 0, NONE_CONNECTION_TYPE);\n}\n\nstatic inline int bnx2x_q_send_terminate(struct bnx2x *bp,\n\t\t\t\t\tstruct bnx2x_queue_state_params *params)\n{\n\tstruct bnx2x_queue_sp_obj *o = params->q_obj;\n\tu8 cid_index = params->params.terminate.cid_index;\n\n\tif (cid_index >= o->max_cos) {\n\t\tBNX2X_ERR(\"queue[%d]: cid_index (%d) is out of range\\n\",\n\t\t\t  o->cl_id, cid_index);\n\t\treturn -EINVAL;\n\t}\n\n\treturn bnx2x_sp_post(bp, RAMROD_CMD_ID_ETH_TERMINATE,\n\t\t\t     o->cids[cid_index], 0, 0, ETH_CONNECTION_TYPE);\n}\n\nstatic inline int bnx2x_q_send_empty(struct bnx2x *bp,\n\t\t\t\t     struct bnx2x_queue_state_params *params)\n{\n\tstruct bnx2x_queue_sp_obj *o = params->q_obj;\n\n\treturn bnx2x_sp_post(bp, RAMROD_CMD_ID_ETH_EMPTY,\n\t\t\t     o->cids[BNX2X_PRIMARY_CID_INDEX], 0, 0,\n\t\t\t     ETH_CONNECTION_TYPE);\n}\n\nstatic inline int bnx2x_queue_send_cmd_cmn(struct bnx2x *bp,\n\t\t\t\t\tstruct bnx2x_queue_state_params *params)\n{\n\tswitch (params->cmd) {\n\tcase BNX2X_Q_CMD_INIT:\n\t\treturn bnx2x_q_init(bp, params);\n\tcase BNX2X_Q_CMD_SETUP_TX_ONLY:\n\t\treturn bnx2x_q_send_setup_tx_only(bp, params);\n\tcase BNX2X_Q_CMD_DEACTIVATE:\n\t\treturn bnx2x_q_send_deactivate(bp, params);\n\tcase BNX2X_Q_CMD_ACTIVATE:\n\t\treturn bnx2x_q_send_activate(bp, params);\n\tcase BNX2X_Q_CMD_UPDATE:\n\t\treturn bnx2x_q_send_update(bp, params);\n\tcase BNX2X_Q_CMD_UPDATE_TPA:\n\t\treturn bnx2x_q_send_update_tpa(bp, params);\n\tcase BNX2X_Q_CMD_HALT:\n\t\treturn bnx2x_q_send_halt(bp, params);\n\tcase BNX2X_Q_CMD_CFC_DEL:\n\t\treturn bnx2x_q_send_cfc_del(bp, params);\n\tcase BNX2X_Q_CMD_TERMINATE:\n\t\treturn bnx2x_q_send_terminate(bp, params);\n\tcase BNX2X_Q_CMD_EMPTY:\n\t\treturn bnx2x_q_send_empty(bp, params);\n\tdefault:\n\t\tBNX2X_ERR(\"Unknown command: %d\\n\", params->cmd);\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int bnx2x_queue_send_cmd_e1x(struct bnx2x *bp,\n\t\t\t\t    struct bnx2x_queue_state_params *params)\n{\n\tswitch (params->cmd) {\n\tcase BNX2X_Q_CMD_SETUP:\n\t\treturn bnx2x_q_send_setup_e1x(bp, params);\n\tcase BNX2X_Q_CMD_INIT:\n\tcase BNX2X_Q_CMD_SETUP_TX_ONLY:\n\tcase BNX2X_Q_CMD_DEACTIVATE:\n\tcase BNX2X_Q_CMD_ACTIVATE:\n\tcase BNX2X_Q_CMD_UPDATE:\n\tcase BNX2X_Q_CMD_UPDATE_TPA:\n\tcase BNX2X_Q_CMD_HALT:\n\tcase BNX2X_Q_CMD_CFC_DEL:\n\tcase BNX2X_Q_CMD_TERMINATE:\n\tcase BNX2X_Q_CMD_EMPTY:\n\t\treturn bnx2x_queue_send_cmd_cmn(bp, params);\n\tdefault:\n\t\tBNX2X_ERR(\"Unknown command: %d\\n\", params->cmd);\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int bnx2x_queue_send_cmd_e2(struct bnx2x *bp,\n\t\t\t\t   struct bnx2x_queue_state_params *params)\n{\n\tswitch (params->cmd) {\n\tcase BNX2X_Q_CMD_SETUP:\n\t\treturn bnx2x_q_send_setup_e2(bp, params);\n\tcase BNX2X_Q_CMD_INIT:\n\tcase BNX2X_Q_CMD_SETUP_TX_ONLY:\n\tcase BNX2X_Q_CMD_DEACTIVATE:\n\tcase BNX2X_Q_CMD_ACTIVATE:\n\tcase BNX2X_Q_CMD_UPDATE:\n\tcase BNX2X_Q_CMD_UPDATE_TPA:\n\tcase BNX2X_Q_CMD_HALT:\n\tcase BNX2X_Q_CMD_CFC_DEL:\n\tcase BNX2X_Q_CMD_TERMINATE:\n\tcase BNX2X_Q_CMD_EMPTY:\n\t\treturn bnx2x_queue_send_cmd_cmn(bp, params);\n\tdefault:\n\t\tBNX2X_ERR(\"Unknown command: %d\\n\", params->cmd);\n\t\treturn -EINVAL;\n\t}\n}\n\n \nstatic int bnx2x_queue_chk_transition(struct bnx2x *bp,\n\t\t\t\t      struct bnx2x_queue_sp_obj *o,\n\t\t\t\t      struct bnx2x_queue_state_params *params)\n{\n\tenum bnx2x_q_state state = o->state, next_state = BNX2X_Q_STATE_MAX;\n\tenum bnx2x_queue_cmd cmd = params->cmd;\n\tstruct bnx2x_queue_update_params *update_params =\n\t\t &params->params.update;\n\tu8 next_tx_only = o->num_tx_only;\n\n\t \n\tif (test_bit(RAMROD_DRV_CLR_ONLY, &params->ramrod_flags)) {\n\t\to->pending = 0;\n\t\to->next_state = BNX2X_Q_STATE_MAX;\n\t}\n\n\t \n\tif (o->pending) {\n\t\tBNX2X_ERR(\"Blocking transition since pending was %lx\\n\",\n\t\t\t  o->pending);\n\t\treturn -EBUSY;\n\t}\n\n\tswitch (state) {\n\tcase BNX2X_Q_STATE_RESET:\n\t\tif (cmd == BNX2X_Q_CMD_INIT)\n\t\t\tnext_state = BNX2X_Q_STATE_INITIALIZED;\n\n\t\tbreak;\n\tcase BNX2X_Q_STATE_INITIALIZED:\n\t\tif (cmd == BNX2X_Q_CMD_SETUP) {\n\t\t\tif (test_bit(BNX2X_Q_FLG_ACTIVE,\n\t\t\t\t     &params->params.setup.flags))\n\t\t\t\tnext_state = BNX2X_Q_STATE_ACTIVE;\n\t\t\telse\n\t\t\t\tnext_state = BNX2X_Q_STATE_INACTIVE;\n\t\t}\n\n\t\tbreak;\n\tcase BNX2X_Q_STATE_ACTIVE:\n\t\tif (cmd == BNX2X_Q_CMD_DEACTIVATE)\n\t\t\tnext_state = BNX2X_Q_STATE_INACTIVE;\n\n\t\telse if ((cmd == BNX2X_Q_CMD_EMPTY) ||\n\t\t\t (cmd == BNX2X_Q_CMD_UPDATE_TPA))\n\t\t\tnext_state = BNX2X_Q_STATE_ACTIVE;\n\n\t\telse if (cmd == BNX2X_Q_CMD_SETUP_TX_ONLY) {\n\t\t\tnext_state = BNX2X_Q_STATE_MULTI_COS;\n\t\t\tnext_tx_only = 1;\n\t\t}\n\n\t\telse if (cmd == BNX2X_Q_CMD_HALT)\n\t\t\tnext_state = BNX2X_Q_STATE_STOPPED;\n\n\t\telse if (cmd == BNX2X_Q_CMD_UPDATE) {\n\t\t\t \n\t\t\tif (test_bit(BNX2X_Q_UPDATE_ACTIVATE_CHNG,\n\t\t\t\t     &update_params->update_flags) &&\n\t\t\t    !test_bit(BNX2X_Q_UPDATE_ACTIVATE,\n\t\t\t\t      &update_params->update_flags))\n\t\t\t\tnext_state = BNX2X_Q_STATE_INACTIVE;\n\t\t\telse\n\t\t\t\tnext_state = BNX2X_Q_STATE_ACTIVE;\n\t\t}\n\n\t\tbreak;\n\tcase BNX2X_Q_STATE_MULTI_COS:\n\t\tif (cmd == BNX2X_Q_CMD_TERMINATE)\n\t\t\tnext_state = BNX2X_Q_STATE_MCOS_TERMINATED;\n\n\t\telse if (cmd == BNX2X_Q_CMD_SETUP_TX_ONLY) {\n\t\t\tnext_state = BNX2X_Q_STATE_MULTI_COS;\n\t\t\tnext_tx_only = o->num_tx_only + 1;\n\t\t}\n\n\t\telse if ((cmd == BNX2X_Q_CMD_EMPTY) ||\n\t\t\t (cmd == BNX2X_Q_CMD_UPDATE_TPA))\n\t\t\tnext_state = BNX2X_Q_STATE_MULTI_COS;\n\n\t\telse if (cmd == BNX2X_Q_CMD_UPDATE) {\n\t\t\t \n\t\t\tif (test_bit(BNX2X_Q_UPDATE_ACTIVATE_CHNG,\n\t\t\t\t     &update_params->update_flags) &&\n\t\t\t    !test_bit(BNX2X_Q_UPDATE_ACTIVATE,\n\t\t\t\t      &update_params->update_flags))\n\t\t\t\tnext_state = BNX2X_Q_STATE_INACTIVE;\n\t\t\telse\n\t\t\t\tnext_state = BNX2X_Q_STATE_MULTI_COS;\n\t\t}\n\n\t\tbreak;\n\tcase BNX2X_Q_STATE_MCOS_TERMINATED:\n\t\tif (cmd == BNX2X_Q_CMD_CFC_DEL) {\n\t\t\tnext_tx_only = o->num_tx_only - 1;\n\t\t\tif (next_tx_only == 0)\n\t\t\t\tnext_state = BNX2X_Q_STATE_ACTIVE;\n\t\t\telse\n\t\t\t\tnext_state = BNX2X_Q_STATE_MULTI_COS;\n\t\t}\n\n\t\tbreak;\n\tcase BNX2X_Q_STATE_INACTIVE:\n\t\tif (cmd == BNX2X_Q_CMD_ACTIVATE)\n\t\t\tnext_state = BNX2X_Q_STATE_ACTIVE;\n\n\t\telse if ((cmd == BNX2X_Q_CMD_EMPTY) ||\n\t\t\t (cmd == BNX2X_Q_CMD_UPDATE_TPA))\n\t\t\tnext_state = BNX2X_Q_STATE_INACTIVE;\n\n\t\telse if (cmd == BNX2X_Q_CMD_HALT)\n\t\t\tnext_state = BNX2X_Q_STATE_STOPPED;\n\n\t\telse if (cmd == BNX2X_Q_CMD_UPDATE) {\n\t\t\t \n\t\t\tif (test_bit(BNX2X_Q_UPDATE_ACTIVATE_CHNG,\n\t\t\t\t     &update_params->update_flags) &&\n\t\t\t    test_bit(BNX2X_Q_UPDATE_ACTIVATE,\n\t\t\t\t     &update_params->update_flags)){\n\t\t\t\tif (o->num_tx_only == 0)\n\t\t\t\t\tnext_state = BNX2X_Q_STATE_ACTIVE;\n\t\t\t\telse  \n\t\t\t\t\tnext_state = BNX2X_Q_STATE_MULTI_COS;\n\t\t\t} else\n\t\t\t\tnext_state = BNX2X_Q_STATE_INACTIVE;\n\t\t}\n\n\t\tbreak;\n\tcase BNX2X_Q_STATE_STOPPED:\n\t\tif (cmd == BNX2X_Q_CMD_TERMINATE)\n\t\t\tnext_state = BNX2X_Q_STATE_TERMINATED;\n\n\t\tbreak;\n\tcase BNX2X_Q_STATE_TERMINATED:\n\t\tif (cmd == BNX2X_Q_CMD_CFC_DEL)\n\t\t\tnext_state = BNX2X_Q_STATE_RESET;\n\n\t\tbreak;\n\tdefault:\n\t\tBNX2X_ERR(\"Illegal state: %d\\n\", state);\n\t}\n\n\t \n\tif (next_state != BNX2X_Q_STATE_MAX) {\n\t\tDP(BNX2X_MSG_SP, \"Good state transition: %d(%d)->%d\\n\",\n\t\t\t\t state, cmd, next_state);\n\t\to->next_state = next_state;\n\t\to->next_tx_only = next_tx_only;\n\t\treturn 0;\n\t}\n\n\tDP(BNX2X_MSG_SP, \"Bad state transition request: %d %d\\n\", state, cmd);\n\n\treturn -EINVAL;\n}\n\nvoid bnx2x_init_queue_obj(struct bnx2x *bp,\n\t\t\t  struct bnx2x_queue_sp_obj *obj,\n\t\t\t  u8 cl_id, u32 *cids, u8 cid_cnt, u8 func_id,\n\t\t\t  void *rdata,\n\t\t\t  dma_addr_t rdata_mapping, unsigned long type)\n{\n\tmemset(obj, 0, sizeof(*obj));\n\n\t \n\tBUG_ON(BNX2X_MULTI_TX_COS < cid_cnt);\n\n\tmemcpy(obj->cids, cids, sizeof(obj->cids[0]) * cid_cnt);\n\tobj->max_cos = cid_cnt;\n\tobj->cl_id = cl_id;\n\tobj->func_id = func_id;\n\tobj->rdata = rdata;\n\tobj->rdata_mapping = rdata_mapping;\n\tobj->type = type;\n\tobj->next_state = BNX2X_Q_STATE_MAX;\n\n\tif (CHIP_IS_E1x(bp))\n\t\tobj->send_cmd = bnx2x_queue_send_cmd_e1x;\n\telse\n\t\tobj->send_cmd = bnx2x_queue_send_cmd_e2;\n\n\tobj->check_transition = bnx2x_queue_chk_transition;\n\n\tobj->complete_cmd = bnx2x_queue_comp_cmd;\n\tobj->wait_comp = bnx2x_queue_wait_comp;\n\tobj->set_pending = bnx2x_queue_set_pending;\n}\n\n \nint bnx2x_get_q_logical_state(struct bnx2x *bp,\n\t\t\t       struct bnx2x_queue_sp_obj *obj)\n{\n\tswitch (obj->state) {\n\tcase BNX2X_Q_STATE_ACTIVE:\n\tcase BNX2X_Q_STATE_MULTI_COS:\n\t\treturn BNX2X_Q_LOGICAL_STATE_ACTIVE;\n\tcase BNX2X_Q_STATE_RESET:\n\tcase BNX2X_Q_STATE_INITIALIZED:\n\tcase BNX2X_Q_STATE_MCOS_TERMINATED:\n\tcase BNX2X_Q_STATE_INACTIVE:\n\tcase BNX2X_Q_STATE_STOPPED:\n\tcase BNX2X_Q_STATE_TERMINATED:\n\tcase BNX2X_Q_STATE_FLRED:\n\t\treturn BNX2X_Q_LOGICAL_STATE_STOPPED;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\n \nenum bnx2x_func_state bnx2x_func_get_state(struct bnx2x *bp,\n\t\t\t\t\t   struct bnx2x_func_sp_obj *o)\n{\n\t \n\tif (o->pending)\n\t\treturn BNX2X_F_STATE_MAX;\n\n\t \n\trmb();\n\n\treturn o->state;\n}\n\nstatic int bnx2x_func_wait_comp(struct bnx2x *bp,\n\t\t\t\tstruct bnx2x_func_sp_obj *o,\n\t\t\t\tenum bnx2x_func_cmd cmd)\n{\n\treturn bnx2x_state_wait(bp, cmd, &o->pending);\n}\n\n \nstatic inline int bnx2x_func_state_change_comp(struct bnx2x *bp,\n\t\t\t\t\t       struct bnx2x_func_sp_obj *o,\n\t\t\t\t\t       enum bnx2x_func_cmd cmd)\n{\n\tunsigned long cur_pending = o->pending;\n\n\tif (!test_and_clear_bit(cmd, &cur_pending)) {\n\t\tBNX2X_ERR(\"Bad MC reply %d for func %d in state %d pending 0x%lx, next_state %d\\n\",\n\t\t\t  cmd, BP_FUNC(bp), o->state,\n\t\t\t  cur_pending, o->next_state);\n\t\treturn -EINVAL;\n\t}\n\n\tDP(BNX2X_MSG_SP,\n\t   \"Completing command %d for func %d, setting state to %d\\n\",\n\t   cmd, BP_FUNC(bp), o->next_state);\n\n\to->state = o->next_state;\n\to->next_state = BNX2X_F_STATE_MAX;\n\n\t \n\twmb();\n\n\tclear_bit(cmd, &o->pending);\n\tsmp_mb__after_atomic();\n\n\treturn 0;\n}\n\n \nstatic int bnx2x_func_comp_cmd(struct bnx2x *bp,\n\t\t\t       struct bnx2x_func_sp_obj *o,\n\t\t\t       enum bnx2x_func_cmd cmd)\n{\n\t \n\tint rc = bnx2x_func_state_change_comp(bp, o, cmd);\n\treturn rc;\n}\n\n \nstatic int bnx2x_func_chk_transition(struct bnx2x *bp,\n\t\t\t\t     struct bnx2x_func_sp_obj *o,\n\t\t\t\t     struct bnx2x_func_state_params *params)\n{\n\tenum bnx2x_func_state state = o->state, next_state = BNX2X_F_STATE_MAX;\n\tenum bnx2x_func_cmd cmd = params->cmd;\n\n\t \n\tif (test_bit(RAMROD_DRV_CLR_ONLY, &params->ramrod_flags)) {\n\t\to->pending = 0;\n\t\to->next_state = BNX2X_F_STATE_MAX;\n\t}\n\n\t \n\tif (o->pending)\n\t\treturn -EBUSY;\n\n\tswitch (state) {\n\tcase BNX2X_F_STATE_RESET:\n\t\tif (cmd == BNX2X_F_CMD_HW_INIT)\n\t\t\tnext_state = BNX2X_F_STATE_INITIALIZED;\n\n\t\tbreak;\n\tcase BNX2X_F_STATE_INITIALIZED:\n\t\tif (cmd == BNX2X_F_CMD_START)\n\t\t\tnext_state = BNX2X_F_STATE_STARTED;\n\n\t\telse if (cmd == BNX2X_F_CMD_HW_RESET)\n\t\t\tnext_state = BNX2X_F_STATE_RESET;\n\n\t\tbreak;\n\tcase BNX2X_F_STATE_STARTED:\n\t\tif (cmd == BNX2X_F_CMD_STOP)\n\t\t\tnext_state = BNX2X_F_STATE_INITIALIZED;\n\t\t \n\t\telse if ((cmd == BNX2X_F_CMD_AFEX_UPDATE) &&\n\t\t\t (!test_bit(BNX2X_F_CMD_STOP, &o->pending)))\n\t\t\tnext_state = BNX2X_F_STATE_STARTED;\n\n\t\telse if ((cmd == BNX2X_F_CMD_AFEX_VIFLISTS) &&\n\t\t\t (!test_bit(BNX2X_F_CMD_STOP, &o->pending)))\n\t\t\tnext_state = BNX2X_F_STATE_STARTED;\n\n\t\t \n\t\telse if ((cmd == BNX2X_F_CMD_SWITCH_UPDATE) &&\n\t\t\t (!test_bit(BNX2X_F_CMD_STOP, &o->pending)))\n\t\t\tnext_state = BNX2X_F_STATE_STARTED;\n\n\t\telse if ((cmd == BNX2X_F_CMD_SET_TIMESYNC) &&\n\t\t\t (!test_bit(BNX2X_F_CMD_STOP, &o->pending)))\n\t\t\tnext_state = BNX2X_F_STATE_STARTED;\n\n\t\telse if (cmd == BNX2X_F_CMD_TX_STOP)\n\t\t\tnext_state = BNX2X_F_STATE_TX_STOPPED;\n\n\t\tbreak;\n\tcase BNX2X_F_STATE_TX_STOPPED:\n\t\tif ((cmd == BNX2X_F_CMD_SWITCH_UPDATE) &&\n\t\t    (!test_bit(BNX2X_F_CMD_STOP, &o->pending)))\n\t\t\tnext_state = BNX2X_F_STATE_TX_STOPPED;\n\n\t\telse if ((cmd == BNX2X_F_CMD_SET_TIMESYNC) &&\n\t\t\t (!test_bit(BNX2X_F_CMD_STOP, &o->pending)))\n\t\t\tnext_state = BNX2X_F_STATE_TX_STOPPED;\n\n\t\telse if (cmd == BNX2X_F_CMD_TX_START)\n\t\t\tnext_state = BNX2X_F_STATE_STARTED;\n\n\t\tbreak;\n\tdefault:\n\t\tBNX2X_ERR(\"Unknown state: %d\\n\", state);\n\t}\n\n\t \n\tif (next_state != BNX2X_F_STATE_MAX) {\n\t\tDP(BNX2X_MSG_SP, \"Good function state transition: %d(%d)->%d\\n\",\n\t\t\t\t state, cmd, next_state);\n\t\to->next_state = next_state;\n\t\treturn 0;\n\t}\n\n\tDP(BNX2X_MSG_SP, \"Bad function state transition request: %d %d\\n\",\n\t\t\t state, cmd);\n\n\treturn -EINVAL;\n}\n\n \nstatic inline int bnx2x_func_init_func(struct bnx2x *bp,\n\t\t\t\t       const struct bnx2x_func_sp_drv_ops *drv)\n{\n\treturn drv->init_hw_func(bp);\n}\n\n \nstatic inline int bnx2x_func_init_port(struct bnx2x *bp,\n\t\t\t\t       const struct bnx2x_func_sp_drv_ops *drv)\n{\n\tint rc = drv->init_hw_port(bp);\n\tif (rc)\n\t\treturn rc;\n\n\treturn bnx2x_func_init_func(bp, drv);\n}\n\n \nstatic inline int bnx2x_func_init_cmn_chip(struct bnx2x *bp,\n\t\t\t\t\tconst struct bnx2x_func_sp_drv_ops *drv)\n{\n\tint rc = drv->init_hw_cmn_chip(bp);\n\tif (rc)\n\t\treturn rc;\n\n\treturn bnx2x_func_init_port(bp, drv);\n}\n\n \nstatic inline int bnx2x_func_init_cmn(struct bnx2x *bp,\n\t\t\t\t      const struct bnx2x_func_sp_drv_ops *drv)\n{\n\tint rc = drv->init_hw_cmn(bp);\n\tif (rc)\n\t\treturn rc;\n\n\treturn bnx2x_func_init_port(bp, drv);\n}\n\nstatic int bnx2x_func_hw_init(struct bnx2x *bp,\n\t\t\t      struct bnx2x_func_state_params *params)\n{\n\tu32 load_code = params->params.hw_init.load_phase;\n\tstruct bnx2x_func_sp_obj *o = params->f_obj;\n\tconst struct bnx2x_func_sp_drv_ops *drv = o->drv;\n\tint rc = 0;\n\n\tDP(BNX2X_MSG_SP, \"function %d  load_code %x\\n\",\n\t\t\t BP_ABS_FUNC(bp), load_code);\n\n\t \n\trc = drv->gunzip_init(bp);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\trc = drv->init_fw(bp);\n\tif (rc) {\n\t\tBNX2X_ERR(\"Error loading firmware\\n\");\n\t\tgoto init_err;\n\t}\n\n\t \n\tswitch (load_code) {\n\tcase FW_MSG_CODE_DRV_LOAD_COMMON_CHIP:\n\t\trc = bnx2x_func_init_cmn_chip(bp, drv);\n\t\tif (rc)\n\t\t\tgoto init_err;\n\n\t\tbreak;\n\tcase FW_MSG_CODE_DRV_LOAD_COMMON:\n\t\trc = bnx2x_func_init_cmn(bp, drv);\n\t\tif (rc)\n\t\t\tgoto init_err;\n\n\t\tbreak;\n\tcase FW_MSG_CODE_DRV_LOAD_PORT:\n\t\trc = bnx2x_func_init_port(bp, drv);\n\t\tif (rc)\n\t\t\tgoto init_err;\n\n\t\tbreak;\n\tcase FW_MSG_CODE_DRV_LOAD_FUNCTION:\n\t\trc = bnx2x_func_init_func(bp, drv);\n\t\tif (rc)\n\t\t\tgoto init_err;\n\n\t\tbreak;\n\tdefault:\n\t\tBNX2X_ERR(\"Unknown load_code (0x%x) from MCP\\n\", load_code);\n\t\trc = -EINVAL;\n\t}\n\ninit_err:\n\tdrv->gunzip_end(bp);\n\n\t \n\tif (!rc)\n\t\to->complete_cmd(bp, o, BNX2X_F_CMD_HW_INIT);\n\n\treturn rc;\n}\n\n \nstatic inline void bnx2x_func_reset_func(struct bnx2x *bp,\n\t\t\t\t\tconst struct bnx2x_func_sp_drv_ops *drv)\n{\n\tdrv->reset_hw_func(bp);\n}\n\n \nstatic inline void bnx2x_func_reset_port(struct bnx2x *bp,\n\t\t\t\t\tconst struct bnx2x_func_sp_drv_ops *drv)\n{\n\tdrv->reset_hw_port(bp);\n\tbnx2x_func_reset_func(bp, drv);\n}\n\n \nstatic inline void bnx2x_func_reset_cmn(struct bnx2x *bp,\n\t\t\t\t\tconst struct bnx2x_func_sp_drv_ops *drv)\n{\n\tbnx2x_func_reset_port(bp, drv);\n\tdrv->reset_hw_cmn(bp);\n}\n\nstatic inline int bnx2x_func_hw_reset(struct bnx2x *bp,\n\t\t\t\t      struct bnx2x_func_state_params *params)\n{\n\tu32 reset_phase = params->params.hw_reset.reset_phase;\n\tstruct bnx2x_func_sp_obj *o = params->f_obj;\n\tconst struct bnx2x_func_sp_drv_ops *drv = o->drv;\n\n\tDP(BNX2X_MSG_SP, \"function %d  reset_phase %x\\n\", BP_ABS_FUNC(bp),\n\t\t\t reset_phase);\n\n\tswitch (reset_phase) {\n\tcase FW_MSG_CODE_DRV_UNLOAD_COMMON:\n\t\tbnx2x_func_reset_cmn(bp, drv);\n\t\tbreak;\n\tcase FW_MSG_CODE_DRV_UNLOAD_PORT:\n\t\tbnx2x_func_reset_port(bp, drv);\n\t\tbreak;\n\tcase FW_MSG_CODE_DRV_UNLOAD_FUNCTION:\n\t\tbnx2x_func_reset_func(bp, drv);\n\t\tbreak;\n\tdefault:\n\t\tBNX2X_ERR(\"Unknown reset_phase (0x%x) from MCP\\n\",\n\t\t\t   reset_phase);\n\t\tbreak;\n\t}\n\n\t \n\to->complete_cmd(bp, o, BNX2X_F_CMD_HW_RESET);\n\n\treturn 0;\n}\n\nstatic inline int bnx2x_func_send_start(struct bnx2x *bp,\n\t\t\t\t\tstruct bnx2x_func_state_params *params)\n{\n\tstruct bnx2x_func_sp_obj *o = params->f_obj;\n\tstruct function_start_data *rdata =\n\t\t(struct function_start_data *)o->rdata;\n\tdma_addr_t data_mapping = o->rdata_mapping;\n\tstruct bnx2x_func_start_params *start_params = &params->params.start;\n\n\tmemset(rdata, 0, sizeof(*rdata));\n\n\t \n\trdata->function_mode\t= (u8)start_params->mf_mode;\n\trdata->sd_vlan_tag\t= cpu_to_le16(start_params->sd_vlan_tag);\n\trdata->path_id\t\t= BP_PATH(bp);\n\trdata->network_cos_mode\t= start_params->network_cos_mode;\n\trdata->dmae_cmd_id\t= BNX2X_FW_DMAE_C;\n\n\trdata->vxlan_dst_port\t= cpu_to_le16(start_params->vxlan_dst_port);\n\trdata->geneve_dst_port\t= cpu_to_le16(start_params->geneve_dst_port);\n\trdata->inner_clss_l2gre\t= start_params->inner_clss_l2gre;\n\trdata->inner_clss_l2geneve = start_params->inner_clss_l2geneve;\n\trdata->inner_clss_vxlan\t= start_params->inner_clss_vxlan;\n\trdata->inner_rss\t= start_params->inner_rss;\n\n\trdata->sd_accept_mf_clss_fail = start_params->class_fail;\n\tif (start_params->class_fail_ethtype) {\n\t\trdata->sd_accept_mf_clss_fail_match_ethtype = 1;\n\t\trdata->sd_accept_mf_clss_fail_ethtype =\n\t\t\tcpu_to_le16(start_params->class_fail_ethtype);\n\t}\n\n\trdata->sd_vlan_force_pri_flg = start_params->sd_vlan_force_pri;\n\trdata->sd_vlan_force_pri_val = start_params->sd_vlan_force_pri_val;\n\tif (start_params->sd_vlan_eth_type)\n\t\trdata->sd_vlan_eth_type =\n\t\t\tcpu_to_le16(start_params->sd_vlan_eth_type);\n\telse\n\t\trdata->sd_vlan_eth_type =\n\t\t\tcpu_to_le16(0x8100);\n\n\trdata->no_added_tags = start_params->no_added_tags;\n\n\trdata->c2s_pri_tt_valid = start_params->c2s_pri_valid;\n\tif (rdata->c2s_pri_tt_valid) {\n\t\tmemcpy(rdata->c2s_pri_trans_table.val,\n\t\t       start_params->c2s_pri,\n\t\t       MAX_VLAN_PRIORITIES);\n\t\trdata->c2s_pri_default = start_params->c2s_pri_default;\n\t}\n\t \n\n\treturn bnx2x_sp_post(bp, RAMROD_CMD_ID_COMMON_FUNCTION_START, 0,\n\t\t\t     U64_HI(data_mapping),\n\t\t\t     U64_LO(data_mapping), NONE_CONNECTION_TYPE);\n}\n\nstatic inline int bnx2x_func_send_switch_update(struct bnx2x *bp,\n\t\t\t\t\tstruct bnx2x_func_state_params *params)\n{\n\tstruct bnx2x_func_sp_obj *o = params->f_obj;\n\tstruct function_update_data *rdata =\n\t\t(struct function_update_data *)o->rdata;\n\tdma_addr_t data_mapping = o->rdata_mapping;\n\tstruct bnx2x_func_switch_update_params *switch_update_params =\n\t\t&params->params.switch_update;\n\n\tmemset(rdata, 0, sizeof(*rdata));\n\n\t \n\tif (test_bit(BNX2X_F_UPDATE_TX_SWITCH_SUSPEND_CHNG,\n\t\t     &switch_update_params->changes)) {\n\t\trdata->tx_switch_suspend_change_flg = 1;\n\t\trdata->tx_switch_suspend =\n\t\t\ttest_bit(BNX2X_F_UPDATE_TX_SWITCH_SUSPEND,\n\t\t\t\t &switch_update_params->changes);\n\t}\n\n\tif (test_bit(BNX2X_F_UPDATE_SD_VLAN_TAG_CHNG,\n\t\t     &switch_update_params->changes)) {\n\t\trdata->sd_vlan_tag_change_flg = 1;\n\t\trdata->sd_vlan_tag =\n\t\t\tcpu_to_le16(switch_update_params->vlan);\n\t}\n\n\tif (test_bit(BNX2X_F_UPDATE_SD_VLAN_ETH_TYPE_CHNG,\n\t\t     &switch_update_params->changes)) {\n\t\trdata->sd_vlan_eth_type_change_flg = 1;\n\t\trdata->sd_vlan_eth_type =\n\t\t\tcpu_to_le16(switch_update_params->vlan_eth_type);\n\t}\n\n\tif (test_bit(BNX2X_F_UPDATE_VLAN_FORCE_PRIO_CHNG,\n\t\t     &switch_update_params->changes)) {\n\t\trdata->sd_vlan_force_pri_change_flg = 1;\n\t\tif (test_bit(BNX2X_F_UPDATE_VLAN_FORCE_PRIO_FLAG,\n\t\t\t     &switch_update_params->changes))\n\t\t\trdata->sd_vlan_force_pri_flg = 1;\n\t\trdata->sd_vlan_force_pri_flg =\n\t\t\tswitch_update_params->vlan_force_prio;\n\t}\n\n\tif (test_bit(BNX2X_F_UPDATE_TUNNEL_CFG_CHNG,\n\t\t     &switch_update_params->changes)) {\n\t\trdata->update_tunn_cfg_flg = 1;\n\t\tif (test_bit(BNX2X_F_UPDATE_TUNNEL_INNER_CLSS_L2GRE,\n\t\t\t     &switch_update_params->changes))\n\t\t\trdata->inner_clss_l2gre = 1;\n\t\tif (test_bit(BNX2X_F_UPDATE_TUNNEL_INNER_CLSS_VXLAN,\n\t\t\t     &switch_update_params->changes))\n\t\t\trdata->inner_clss_vxlan = 1;\n\t\tif (test_bit(BNX2X_F_UPDATE_TUNNEL_INNER_CLSS_L2GENEVE,\n\t\t\t     &switch_update_params->changes))\n\t\t\trdata->inner_clss_l2geneve = 1;\n\t\tif (test_bit(BNX2X_F_UPDATE_TUNNEL_INNER_RSS,\n\t\t\t     &switch_update_params->changes))\n\t\t\trdata->inner_rss = 1;\n\t\trdata->vxlan_dst_port =\n\t\t\tcpu_to_le16(switch_update_params->vxlan_dst_port);\n\t\trdata->geneve_dst_port =\n\t\t\tcpu_to_le16(switch_update_params->geneve_dst_port);\n\t}\n\n\trdata->echo = SWITCH_UPDATE;\n\n\t \n\treturn bnx2x_sp_post(bp, RAMROD_CMD_ID_COMMON_FUNCTION_UPDATE, 0,\n\t\t\t     U64_HI(data_mapping),\n\t\t\t     U64_LO(data_mapping), NONE_CONNECTION_TYPE);\n}\n\nstatic inline int bnx2x_func_send_afex_update(struct bnx2x *bp,\n\t\t\t\t\t struct bnx2x_func_state_params *params)\n{\n\tstruct bnx2x_func_sp_obj *o = params->f_obj;\n\tstruct function_update_data *rdata =\n\t\t(struct function_update_data *)o->afex_rdata;\n\tdma_addr_t data_mapping = o->afex_rdata_mapping;\n\tstruct bnx2x_func_afex_update_params *afex_update_params =\n\t\t&params->params.afex_update;\n\n\tmemset(rdata, 0, sizeof(*rdata));\n\n\t \n\trdata->vif_id_change_flg = 1;\n\trdata->vif_id = cpu_to_le16(afex_update_params->vif_id);\n\trdata->afex_default_vlan_change_flg = 1;\n\trdata->afex_default_vlan =\n\t\tcpu_to_le16(afex_update_params->afex_default_vlan);\n\trdata->allowed_priorities_change_flg = 1;\n\trdata->allowed_priorities = afex_update_params->allowed_priorities;\n\trdata->echo = AFEX_UPDATE;\n\n\t \n\tDP(BNX2X_MSG_SP,\n\t   \"afex: sending func_update vif_id 0x%x dvlan 0x%x prio 0x%x\\n\",\n\t   rdata->vif_id,\n\t   rdata->afex_default_vlan, rdata->allowed_priorities);\n\n\treturn bnx2x_sp_post(bp, RAMROD_CMD_ID_COMMON_FUNCTION_UPDATE, 0,\n\t\t\t     U64_HI(data_mapping),\n\t\t\t     U64_LO(data_mapping), NONE_CONNECTION_TYPE);\n}\n\nstatic\ninline int bnx2x_func_send_afex_viflists(struct bnx2x *bp,\n\t\t\t\t\t struct bnx2x_func_state_params *params)\n{\n\tstruct bnx2x_func_sp_obj *o = params->f_obj;\n\tstruct afex_vif_list_ramrod_data *rdata =\n\t\t(struct afex_vif_list_ramrod_data *)o->afex_rdata;\n\tstruct bnx2x_func_afex_viflists_params *afex_vif_params =\n\t\t&params->params.afex_viflists;\n\tu64 *p_rdata = (u64 *)rdata;\n\n\tmemset(rdata, 0, sizeof(*rdata));\n\n\t \n\trdata->vif_list_index = cpu_to_le16(afex_vif_params->vif_list_index);\n\trdata->func_bit_map          = afex_vif_params->func_bit_map;\n\trdata->afex_vif_list_command = afex_vif_params->afex_vif_list_command;\n\trdata->func_to_clear         = afex_vif_params->func_to_clear;\n\n\t \n\trdata->echo = afex_vif_params->afex_vif_list_command;\n\n\t \n\n\tDP(BNX2X_MSG_SP, \"afex: ramrod lists, cmd 0x%x index 0x%x func_bit_map 0x%x func_to_clr 0x%x\\n\",\n\t   rdata->afex_vif_list_command, rdata->vif_list_index,\n\t   rdata->func_bit_map, rdata->func_to_clear);\n\n\t \n\treturn bnx2x_sp_post(bp, RAMROD_CMD_ID_COMMON_AFEX_VIF_LISTS, 0,\n\t\t\t     U64_HI(*p_rdata), U64_LO(*p_rdata),\n\t\t\t     NONE_CONNECTION_TYPE);\n}\n\nstatic inline int bnx2x_func_send_stop(struct bnx2x *bp,\n\t\t\t\t       struct bnx2x_func_state_params *params)\n{\n\treturn bnx2x_sp_post(bp, RAMROD_CMD_ID_COMMON_FUNCTION_STOP, 0, 0, 0,\n\t\t\t     NONE_CONNECTION_TYPE);\n}\n\nstatic inline int bnx2x_func_send_tx_stop(struct bnx2x *bp,\n\t\t\t\t       struct bnx2x_func_state_params *params)\n{\n\treturn bnx2x_sp_post(bp, RAMROD_CMD_ID_COMMON_STOP_TRAFFIC, 0, 0, 0,\n\t\t\t     NONE_CONNECTION_TYPE);\n}\nstatic inline int bnx2x_func_send_tx_start(struct bnx2x *bp,\n\t\t\t\t       struct bnx2x_func_state_params *params)\n{\n\tstruct bnx2x_func_sp_obj *o = params->f_obj;\n\tstruct flow_control_configuration *rdata =\n\t\t(struct flow_control_configuration *)o->rdata;\n\tdma_addr_t data_mapping = o->rdata_mapping;\n\tstruct bnx2x_func_tx_start_params *tx_start_params =\n\t\t&params->params.tx_start;\n\tint i;\n\n\tmemset(rdata, 0, sizeof(*rdata));\n\n\trdata->dcb_enabled = tx_start_params->dcb_enabled;\n\trdata->dcb_version = tx_start_params->dcb_version;\n\trdata->dont_add_pri_0_en = tx_start_params->dont_add_pri_0_en;\n\n\tfor (i = 0; i < ARRAY_SIZE(rdata->traffic_type_to_priority_cos); i++)\n\t\trdata->traffic_type_to_priority_cos[i] =\n\t\t\ttx_start_params->traffic_type_to_priority_cos[i];\n\n\tfor (i = 0; i < MAX_TRAFFIC_TYPES; i++)\n\t\trdata->dcb_outer_pri[i] = tx_start_params->dcb_outer_pri[i];\n\t \n\treturn bnx2x_sp_post(bp, RAMROD_CMD_ID_COMMON_START_TRAFFIC, 0,\n\t\t\t     U64_HI(data_mapping),\n\t\t\t     U64_LO(data_mapping), NONE_CONNECTION_TYPE);\n}\n\nstatic inline\nint bnx2x_func_send_set_timesync(struct bnx2x *bp,\n\t\t\t\t struct bnx2x_func_state_params *params)\n{\n\tstruct bnx2x_func_sp_obj *o = params->f_obj;\n\tstruct set_timesync_ramrod_data *rdata =\n\t\t(struct set_timesync_ramrod_data *)o->rdata;\n\tdma_addr_t data_mapping = o->rdata_mapping;\n\tstruct bnx2x_func_set_timesync_params *set_timesync_params =\n\t\t&params->params.set_timesync;\n\n\tmemset(rdata, 0, sizeof(*rdata));\n\n\t \n\trdata->drift_adjust_cmd = set_timesync_params->drift_adjust_cmd;\n\trdata->offset_cmd = set_timesync_params->offset_cmd;\n\trdata->add_sub_drift_adjust_value =\n\t\tset_timesync_params->add_sub_drift_adjust_value;\n\trdata->drift_adjust_value = set_timesync_params->drift_adjust_value;\n\trdata->drift_adjust_period = set_timesync_params->drift_adjust_period;\n\trdata->offset_delta.lo =\n\t\tcpu_to_le32(U64_LO(set_timesync_params->offset_delta));\n\trdata->offset_delta.hi =\n\t\tcpu_to_le32(U64_HI(set_timesync_params->offset_delta));\n\n\tDP(BNX2X_MSG_SP, \"Set timesync command params: drift_cmd = %d, offset_cmd = %d, add_sub_drift = %d, drift_val = %d, drift_period = %d, offset_lo = %d, offset_hi = %d\\n\",\n\t   rdata->drift_adjust_cmd, rdata->offset_cmd,\n\t   rdata->add_sub_drift_adjust_value, rdata->drift_adjust_value,\n\t   rdata->drift_adjust_period, rdata->offset_delta.lo,\n\t   rdata->offset_delta.hi);\n\n\treturn bnx2x_sp_post(bp, RAMROD_CMD_ID_COMMON_SET_TIMESYNC, 0,\n\t\t\t     U64_HI(data_mapping),\n\t\t\t     U64_LO(data_mapping), NONE_CONNECTION_TYPE);\n}\n\nstatic int bnx2x_func_send_cmd(struct bnx2x *bp,\n\t\t\t       struct bnx2x_func_state_params *params)\n{\n\tswitch (params->cmd) {\n\tcase BNX2X_F_CMD_HW_INIT:\n\t\treturn bnx2x_func_hw_init(bp, params);\n\tcase BNX2X_F_CMD_START:\n\t\treturn bnx2x_func_send_start(bp, params);\n\tcase BNX2X_F_CMD_STOP:\n\t\treturn bnx2x_func_send_stop(bp, params);\n\tcase BNX2X_F_CMD_HW_RESET:\n\t\treturn bnx2x_func_hw_reset(bp, params);\n\tcase BNX2X_F_CMD_AFEX_UPDATE:\n\t\treturn bnx2x_func_send_afex_update(bp, params);\n\tcase BNX2X_F_CMD_AFEX_VIFLISTS:\n\t\treturn bnx2x_func_send_afex_viflists(bp, params);\n\tcase BNX2X_F_CMD_TX_STOP:\n\t\treturn bnx2x_func_send_tx_stop(bp, params);\n\tcase BNX2X_F_CMD_TX_START:\n\t\treturn bnx2x_func_send_tx_start(bp, params);\n\tcase BNX2X_F_CMD_SWITCH_UPDATE:\n\t\treturn bnx2x_func_send_switch_update(bp, params);\n\tcase BNX2X_F_CMD_SET_TIMESYNC:\n\t\treturn bnx2x_func_send_set_timesync(bp, params);\n\tdefault:\n\t\tBNX2X_ERR(\"Unknown command: %d\\n\", params->cmd);\n\t\treturn -EINVAL;\n\t}\n}\n\nvoid bnx2x_init_func_obj(struct bnx2x *bp,\n\t\t\t struct bnx2x_func_sp_obj *obj,\n\t\t\t void *rdata, dma_addr_t rdata_mapping,\n\t\t\t void *afex_rdata, dma_addr_t afex_rdata_mapping,\n\t\t\t struct bnx2x_func_sp_drv_ops *drv_iface)\n{\n\tmemset(obj, 0, sizeof(*obj));\n\n\tmutex_init(&obj->one_pending_mutex);\n\n\tobj->rdata = rdata;\n\tobj->rdata_mapping = rdata_mapping;\n\tobj->afex_rdata = afex_rdata;\n\tobj->afex_rdata_mapping = afex_rdata_mapping;\n\tobj->send_cmd = bnx2x_func_send_cmd;\n\tobj->check_transition = bnx2x_func_chk_transition;\n\tobj->complete_cmd = bnx2x_func_comp_cmd;\n\tobj->wait_comp = bnx2x_func_wait_comp;\n\n\tobj->drv = drv_iface;\n}\n\n \nint bnx2x_func_state_change(struct bnx2x *bp,\n\t\t\t    struct bnx2x_func_state_params *params)\n{\n\tstruct bnx2x_func_sp_obj *o = params->f_obj;\n\tint rc, cnt = 300;\n\tenum bnx2x_func_cmd cmd = params->cmd;\n\tunsigned long *pending = &o->pending;\n\n\tmutex_lock(&o->one_pending_mutex);\n\n\t \n\trc = o->check_transition(bp, o, params);\n\tif ((rc == -EBUSY) &&\n\t    (test_bit(RAMROD_RETRY, &params->ramrod_flags))) {\n\t\twhile ((rc == -EBUSY) && (--cnt > 0)) {\n\t\t\tmutex_unlock(&o->one_pending_mutex);\n\t\t\tmsleep(10);\n\t\t\tmutex_lock(&o->one_pending_mutex);\n\t\t\trc = o->check_transition(bp, o, params);\n\t\t}\n\t\tif (rc == -EBUSY) {\n\t\t\tmutex_unlock(&o->one_pending_mutex);\n\t\t\tBNX2X_ERR(\"timeout waiting for previous ramrod completion\\n\");\n\t\t\treturn rc;\n\t\t}\n\t} else if (rc) {\n\t\tmutex_unlock(&o->one_pending_mutex);\n\t\treturn rc;\n\t}\n\n\t \n\tset_bit(cmd, pending);\n\n\t \n\tif (test_bit(RAMROD_DRV_CLR_ONLY, &params->ramrod_flags)) {\n\t\tbnx2x_func_state_change_comp(bp, o, cmd);\n\t\tmutex_unlock(&o->one_pending_mutex);\n\t} else {\n\t\t \n\t\trc = o->send_cmd(bp, params);\n\n\t\tmutex_unlock(&o->one_pending_mutex);\n\n\t\tif (rc) {\n\t\t\to->next_state = BNX2X_F_STATE_MAX;\n\t\t\tclear_bit(cmd, pending);\n\t\t\tsmp_mb__after_atomic();\n\t\t\treturn rc;\n\t\t}\n\n\t\tif (test_bit(RAMROD_COMP_WAIT, &params->ramrod_flags)) {\n\t\t\trc = o->wait_comp(bp, o, cmd);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn !!test_bit(cmd, pending);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}