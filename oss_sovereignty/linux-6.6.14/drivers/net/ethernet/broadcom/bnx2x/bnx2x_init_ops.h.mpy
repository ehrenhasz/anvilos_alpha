{
  "module_name": "bnx2x_init_ops.h",
  "hash_id": "f1d97adb1dda5144c36969ecb9fb197e76c7e21d52011c73767da9351d678653",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/broadcom/bnx2x/bnx2x_init_ops.h",
  "human_readable_source": " \n\n#ifndef BNX2X_INIT_OPS_H\n#define BNX2X_INIT_OPS_H\n\n\n#ifndef BP_ILT\n#define BP_ILT(bp)\tNULL\n#endif\n\n#ifndef BP_FUNC\n#define BP_FUNC(bp)\t0\n#endif\n\n#ifndef BP_PORT\n#define BP_PORT(bp)\t0\n#endif\n\n#ifndef BNX2X_ILT_FREE\n#define BNX2X_ILT_FREE(x, y, sz)\n#endif\n\n#ifndef BNX2X_ILT_ZALLOC\n#define BNX2X_ILT_ZALLOC(x, y, sz)\n#endif\n\n#ifndef ILOG2\n#define ILOG2(x)\tx\n#endif\n\nstatic int bnx2x_gunzip(struct bnx2x *bp, const u8 *zbuf, int len);\nstatic void bnx2x_reg_wr_ind(struct bnx2x *bp, u32 addr, u32 val);\nstatic void bnx2x_write_dmae_phys_len(struct bnx2x *bp,\n\t\t\t\t      dma_addr_t phys_addr, u32 addr,\n\t\t\t\t      u32 len);\n\nstatic void bnx2x_init_str_wr(struct bnx2x *bp, u32 addr,\n\t\t\t      const u32 *data, u32 len)\n{\n\tu32 i;\n\n\tfor (i = 0; i < len; i++)\n\t\tREG_WR(bp, addr + i*4, data[i]);\n}\n\nstatic void bnx2x_init_ind_wr(struct bnx2x *bp, u32 addr,\n\t\t\t      const u32 *data, u32 len)\n{\n\tu32 i;\n\n\tfor (i = 0; i < len; i++)\n\t\tbnx2x_reg_wr_ind(bp, addr + i*4, data[i]);\n}\n\nstatic void bnx2x_write_big_buf(struct bnx2x *bp, u32 addr, u32 len,\n\t\t\t\tu8 wb)\n{\n\tif (bp->dmae_ready)\n\t\tbnx2x_write_dmae_phys_len(bp, GUNZIP_PHYS(bp), addr, len);\n\n\t \n\telse if (wb && CHIP_IS_E1(bp))\n\t\tbnx2x_init_ind_wr(bp, addr, GUNZIP_BUF(bp), len);\n\n\t \n\telse\n\t\tbnx2x_init_str_wr(bp, addr, GUNZIP_BUF(bp), len);\n}\n\nstatic void bnx2x_init_fill(struct bnx2x *bp, u32 addr, int fill,\n\t\t\t    u32 len, u8 wb)\n{\n\tu32 buf_len = (((len*4) > FW_BUF_SIZE) ? FW_BUF_SIZE : (len*4));\n\tu32 buf_len32 = buf_len/4;\n\tu32 i;\n\n\tmemset(GUNZIP_BUF(bp), (u8)fill, buf_len);\n\n\tfor (i = 0; i < len; i += buf_len32) {\n\t\tu32 cur_len = min(buf_len32, len - i);\n\n\t\tbnx2x_write_big_buf(bp, addr + i*4, cur_len, wb);\n\t}\n}\n\nstatic void bnx2x_write_big_buf_wb(struct bnx2x *bp, u32 addr, u32 len)\n{\n\tif (bp->dmae_ready)\n\t\tbnx2x_write_dmae_phys_len(bp, GUNZIP_PHYS(bp), addr, len);\n\n\t \n\telse if (CHIP_IS_E1(bp))\n\t\tbnx2x_init_ind_wr(bp, addr, GUNZIP_BUF(bp), len);\n\n\t \n\telse\n\t\tbnx2x_init_str_wr(bp, addr, GUNZIP_BUF(bp), len);\n}\n\nstatic void bnx2x_init_wr_64(struct bnx2x *bp, u32 addr,\n\t\t\t     const u32 *data, u32 len64)\n{\n\tu32 buf_len32 = FW_BUF_SIZE/4;\n\tu32 len = len64*2;\n\tu64 data64 = 0;\n\tu32 i;\n\n\t \n\tdata64 = HILO_U64((*(data + 1)), (*data));\n\n\tlen64 = min((u32)(FW_BUF_SIZE/8), len64);\n\tfor (i = 0; i < len64; i++) {\n\t\tu64 *pdata = ((u64 *)(GUNZIP_BUF(bp))) + i;\n\n\t\t*pdata = data64;\n\t}\n\n\tfor (i = 0; i < len; i += buf_len32) {\n\t\tu32 cur_len = min(buf_len32, len - i);\n\n\t\tbnx2x_write_big_buf_wb(bp, addr + i*4, cur_len);\n\t}\n}\n\n \n#define IF_IS_INT_TABLE_ADDR(base, addr) \\\n\t\t\tif (((base) <= (addr)) && ((base) + 0x400 >= (addr)))\n\n#define IF_IS_PRAM_ADDR(base, addr) \\\n\t\t\tif (((base) <= (addr)) && ((base) + 0x40000 >= (addr)))\n\nstatic const u8 *bnx2x_sel_blob(struct bnx2x *bp, u32 addr,\n\t\t\t\tconst u8 *data)\n{\n\tIF_IS_INT_TABLE_ADDR(TSEM_REG_INT_TABLE, addr)\n\t\tdata = INIT_TSEM_INT_TABLE_DATA(bp);\n\telse\n\t\tIF_IS_INT_TABLE_ADDR(CSEM_REG_INT_TABLE, addr)\n\t\t\tdata = INIT_CSEM_INT_TABLE_DATA(bp);\n\telse\n\t\tIF_IS_INT_TABLE_ADDR(USEM_REG_INT_TABLE, addr)\n\t\t\tdata = INIT_USEM_INT_TABLE_DATA(bp);\n\telse\n\t\tIF_IS_INT_TABLE_ADDR(XSEM_REG_INT_TABLE, addr)\n\t\t\tdata = INIT_XSEM_INT_TABLE_DATA(bp);\n\telse\n\t\tIF_IS_PRAM_ADDR(TSEM_REG_PRAM, addr)\n\t\t\tdata = INIT_TSEM_PRAM_DATA(bp);\n\telse\n\t\tIF_IS_PRAM_ADDR(CSEM_REG_PRAM, addr)\n\t\t\tdata = INIT_CSEM_PRAM_DATA(bp);\n\telse\n\t\tIF_IS_PRAM_ADDR(USEM_REG_PRAM, addr)\n\t\t\tdata = INIT_USEM_PRAM_DATA(bp);\n\telse\n\t\tIF_IS_PRAM_ADDR(XSEM_REG_PRAM, addr)\n\t\t\tdata = INIT_XSEM_PRAM_DATA(bp);\n\n\treturn data;\n}\n\nstatic void bnx2x_init_wr_wb(struct bnx2x *bp, u32 addr,\n\t\t\t     const u32 *data, u32 len)\n{\n\tif (bp->dmae_ready)\n\t\tVIRT_WR_DMAE_LEN(bp, data, addr, len, 0);\n\n\t \n\telse if (CHIP_IS_E1(bp))\n\t\tbnx2x_init_ind_wr(bp, addr, data, len);\n\n\t \n\telse\n\t\tbnx2x_init_str_wr(bp, addr, data, len);\n}\n\nstatic void bnx2x_wr_64(struct bnx2x *bp, u32 reg, u32 val_lo,\n\t\t\tu32 val_hi)\n{\n\tu32 wb_write[2];\n\n\twb_write[0] = val_lo;\n\twb_write[1] = val_hi;\n\tREG_WR_DMAE_LEN(bp, reg, wb_write, 2);\n}\nstatic void bnx2x_init_wr_zp(struct bnx2x *bp, u32 addr, u32 len,\n\t\t\t     u32 blob_off)\n{\n\tconst u8 *data = NULL;\n\tint rc;\n\tu32 i;\n\n\tdata = bnx2x_sel_blob(bp, addr, data) + blob_off*4;\n\n\trc = bnx2x_gunzip(bp, data, len);\n\tif (rc)\n\t\treturn;\n\n\t \n\tlen = GUNZIP_OUTLEN(bp);\n\tfor (i = 0; i < len; i++)\n\t\t((u32 *)GUNZIP_BUF(bp))[i] = (__force u32)\n\t\t\t\tcpu_to_le32(((u32 *)GUNZIP_BUF(bp))[i]);\n\n\tbnx2x_write_big_buf_wb(bp, addr, len);\n}\n\nstatic void bnx2x_init_block(struct bnx2x *bp, u32 block, u32 stage)\n{\n\tu16 op_start =\n\t\tINIT_OPS_OFFSETS(bp)[BLOCK_OPS_IDX(block, stage,\n\t\t\t\t\t\t     STAGE_START)];\n\tu16 op_end =\n\t\tINIT_OPS_OFFSETS(bp)[BLOCK_OPS_IDX(block, stage,\n\t\t\t\t\t\t     STAGE_END)];\n\tconst union init_op *op;\n\tu32 op_idx, op_type, addr, len;\n\tconst u32 *data, *data_base;\n\n\t \n\tif (op_start == op_end)\n\t\treturn;\n\n\tdata_base = INIT_DATA(bp);\n\n\tfor (op_idx = op_start; op_idx < op_end; op_idx++) {\n\n\t\top = (const union init_op *)&(INIT_OPS(bp)[op_idx]);\n\t\t \n\t\top_type = op->raw.op;\n\t\taddr = op->raw.offset;\n\t\t \n\t\tlen = op->arr_wr.data_len;\n\t\tdata = data_base + op->arr_wr.data_off;\n\n\t\tswitch (op_type) {\n\t\tcase OP_RD:\n\t\t\tREG_RD(bp, addr);\n\t\t\tbreak;\n\t\tcase OP_WR:\n\t\t\tREG_WR(bp, addr, op->write.val);\n\t\t\tbreak;\n\t\tcase OP_SW:\n\t\t\tbnx2x_init_str_wr(bp, addr, data, len);\n\t\t\tbreak;\n\t\tcase OP_WB:\n\t\t\tbnx2x_init_wr_wb(bp, addr, data, len);\n\t\t\tbreak;\n\t\tcase OP_ZR:\n\t\t\tbnx2x_init_fill(bp, addr, 0, op->zero.len, 0);\n\t\t\tbreak;\n\t\tcase OP_WB_ZR:\n\t\t\tbnx2x_init_fill(bp, addr, 0, op->zero.len, 1);\n\t\t\tbreak;\n\t\tcase OP_ZP:\n\t\t\tbnx2x_init_wr_zp(bp, addr, len,\n\t\t\t\t\t op->arr_wr.data_off);\n\t\t\tbreak;\n\t\tcase OP_WR_64:\n\t\t\tbnx2x_init_wr_64(bp, addr, data, len);\n\t\t\tbreak;\n\t\tcase OP_IF_MODE_AND:\n\t\t\t \n\t\t\tif ((INIT_MODE_FLAGS(bp) &\n\t\t\t\top->if_mode.mode_bit_map) !=\n\t\t\t\top->if_mode.mode_bit_map)\n\t\t\t\top_idx += op->if_mode.cmd_offset;\n\t\t\tbreak;\n\t\tcase OP_IF_MODE_OR:\n\t\t\t \n\t\t\tif ((INIT_MODE_FLAGS(bp) &\n\t\t\t\top->if_mode.mode_bit_map) == 0)\n\t\t\t\top_idx += op->if_mode.cmd_offset;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n\n \n \n\n#define NUM_WR_Q\t\t\t13\n#define NUM_RD_Q\t\t\t29\n#define MAX_RD_ORD\t\t\t3\n#define MAX_WR_ORD\t\t\t2\n\n \nstruct arb_line {\n\tint l;\n\tint add;\n\tint ubound;\n};\n\n \nstatic const struct arb_line read_arb_data[NUM_RD_Q][MAX_RD_ORD + 1] = {\n \t{ {8, 64, 25}, {16, 64, 25}, {32, 64, 25}, {64, 64, 41} },\n\t{ {4, 8,  4},  {4,  8,  4},  {4,  8,  4},  {4,  8,  4}  },\n\t{ {4, 3,  3},  {4,  3,  3},  {4,  3,  3},  {4,  3,  3}  },\n\t{ {8, 3,  6},  {16, 3,  11}, {16, 3,  11}, {16, 3,  11} },\n\t{ {8, 64, 25}, {16, 64, 25}, {32, 64, 25}, {64, 64, 41} },\n\t{ {8, 3,  6},  {16, 3,  11}, {32, 3,  21}, {64, 3,  41} },\n\t{ {8, 3,  6},  {16, 3,  11}, {32, 3,  21}, {64, 3,  41} },\n\t{ {8, 3,  6},  {16, 3,  11}, {32, 3,  21}, {64, 3,  41} },\n\t{ {8, 3,  6},  {16, 3,  11}, {32, 3,  21}, {64, 3,  41} },\n { {8, 3,  6},  {16, 3,  11}, {32, 3,  21}, {32, 3,  21} },\n\t{ {8, 3,  6},  {16, 3,  11}, {32, 3,  21}, {32, 3,  21} },\n\t{ {8, 3,  6},  {16, 3,  11}, {32, 3,  21}, {32, 3,  21} },\n\t{ {8, 3,  6},  {16, 3,  11}, {32, 3,  21}, {32, 3,  21} },\n\t{ {8, 3,  6},  {16, 3,  11}, {32, 3,  21}, {32, 3,  21} },\n\t{ {8, 3,  6},  {16, 3,  11}, {32, 3,  21}, {32, 3,  21} },\n\t{ {8, 3,  6},  {16, 3,  11}, {32, 3,  21}, {32, 3,  21} },\n\t{ {8, 64, 6},  {16, 64, 11}, {32, 64, 21}, {32, 64, 21} },\n\t{ {8, 3,  6},  {16, 3,  11}, {32, 3,  21}, {32, 3,  21} },\n\t{ {8, 3,  6},  {16, 3,  11}, {32, 3,  21}, {32, 3,  21} },\n { {8, 3,  6},  {16, 3,  11}, {32, 3,  21}, {32, 3,  21} },\n\t{ {8, 3,  6},  {16, 3,  11}, {32, 3,  21}, {32, 3,  21} },\n\t{ {8, 3,  6},  {16, 3,  11}, {32, 3,  21}, {32, 3,  21} },\n\t{ {8, 3,  6},  {16, 3,  11}, {32, 3,  21}, {32, 3,  21} },\n\t{ {8, 3,  6},  {16, 3,  11}, {32, 3,  21}, {32, 3,  21} },\n\t{ {8, 3,  6},  {16, 3,  11}, {32, 3,  21}, {32, 3,  21} },\n\t{ {8, 3,  6},  {16, 3,  11}, {32, 3,  21}, {32, 3,  21} },\n\t{ {8, 3,  6},  {16, 3,  11}, {32, 3,  21}, {32, 3,  21} },\n\t{ {8, 3,  6},  {16, 3,  11}, {32, 3,  21}, {32, 3,  21} },\n\t{ {8, 64, 25}, {16, 64, 41}, {32, 64, 81}, {64, 64, 120} }\n};\n\n \nstatic const struct arb_line write_arb_data[NUM_WR_Q][MAX_WR_ORD + 1] = {\n \t{ {4, 6,  3},  {4,  6,  3},  {4,  6,  3} },\n\t{ {4, 2,  3},  {4,  2,  3},  {4,  2,  3} },\n\t{ {8, 2,  6},  {16, 2,  11}, {16, 2,  11} },\n\t{ {8, 2,  6},  {16, 2,  11}, {32, 2,  21} },\n\t{ {8, 2,  6},  {16, 2,  11}, {32, 2,  21} },\n\t{ {8, 2,  6},  {16, 2,  11}, {32, 2,  21} },\n\t{ {8, 64, 25}, {16, 64, 25}, {32, 64, 25} },\n\t{ {8, 2,  6},  {16, 2,  11}, {16, 2,  11} },\n\t{ {8, 2,  6},  {16, 2,  11}, {16, 2,  11} },\n { {8, 9,  6},  {16, 9,  11}, {32, 9,  21} },\n\t{ {8, 47, 19}, {16, 47, 19}, {32, 47, 21} },\n\t{ {8, 9,  6},  {16, 9,  11}, {16, 9,  11} },\n\t{ {8, 64, 25}, {16, 64, 41}, {32, 64, 81} }\n};\n\n \nstatic const struct arb_line read_arb_addr[NUM_RD_Q-1] = {\n \t{PXP2_REG_RQ_BW_RD_L0, PXP2_REG_RQ_BW_RD_ADD0,\n\t\tPXP2_REG_RQ_BW_RD_UBOUND0},\n\t{PXP2_REG_PSWRQ_BW_L1, PXP2_REG_PSWRQ_BW_ADD1,\n\t\tPXP2_REG_PSWRQ_BW_UB1},\n\t{PXP2_REG_PSWRQ_BW_L2, PXP2_REG_PSWRQ_BW_ADD2,\n\t\tPXP2_REG_PSWRQ_BW_UB2},\n\t{PXP2_REG_PSWRQ_BW_L3, PXP2_REG_PSWRQ_BW_ADD3,\n\t\tPXP2_REG_PSWRQ_BW_UB3},\n\t{PXP2_REG_RQ_BW_RD_L4, PXP2_REG_RQ_BW_RD_ADD4,\n\t\tPXP2_REG_RQ_BW_RD_UBOUND4},\n\t{PXP2_REG_RQ_BW_RD_L5, PXP2_REG_RQ_BW_RD_ADD5,\n\t\tPXP2_REG_RQ_BW_RD_UBOUND5},\n\t{PXP2_REG_PSWRQ_BW_L6, PXP2_REG_PSWRQ_BW_ADD6,\n\t\tPXP2_REG_PSWRQ_BW_UB6},\n\t{PXP2_REG_PSWRQ_BW_L7, PXP2_REG_PSWRQ_BW_ADD7,\n\t\tPXP2_REG_PSWRQ_BW_UB7},\n\t{PXP2_REG_PSWRQ_BW_L8, PXP2_REG_PSWRQ_BW_ADD8,\n\t\tPXP2_REG_PSWRQ_BW_UB8},\n {PXP2_REG_PSWRQ_BW_L9, PXP2_REG_PSWRQ_BW_ADD9,\n\t\tPXP2_REG_PSWRQ_BW_UB9},\n\t{PXP2_REG_PSWRQ_BW_L10, PXP2_REG_PSWRQ_BW_ADD10,\n\t\tPXP2_REG_PSWRQ_BW_UB10},\n\t{PXP2_REG_PSWRQ_BW_L11, PXP2_REG_PSWRQ_BW_ADD11,\n\t\tPXP2_REG_PSWRQ_BW_UB11},\n\t{PXP2_REG_RQ_BW_RD_L12, PXP2_REG_RQ_BW_RD_ADD12,\n\t\tPXP2_REG_RQ_BW_RD_UBOUND12},\n\t{PXP2_REG_RQ_BW_RD_L13, PXP2_REG_RQ_BW_RD_ADD13,\n\t\tPXP2_REG_RQ_BW_RD_UBOUND13},\n\t{PXP2_REG_RQ_BW_RD_L14, PXP2_REG_RQ_BW_RD_ADD14,\n\t\tPXP2_REG_RQ_BW_RD_UBOUND14},\n\t{PXP2_REG_RQ_BW_RD_L15, PXP2_REG_RQ_BW_RD_ADD15,\n\t\tPXP2_REG_RQ_BW_RD_UBOUND15},\n\t{PXP2_REG_RQ_BW_RD_L16, PXP2_REG_RQ_BW_RD_ADD16,\n\t\tPXP2_REG_RQ_BW_RD_UBOUND16},\n\t{PXP2_REG_RQ_BW_RD_L17, PXP2_REG_RQ_BW_RD_ADD17,\n\t\tPXP2_REG_RQ_BW_RD_UBOUND17},\n\t{PXP2_REG_RQ_BW_RD_L18, PXP2_REG_RQ_BW_RD_ADD18,\n\t\tPXP2_REG_RQ_BW_RD_UBOUND18},\n {PXP2_REG_RQ_BW_RD_L19, PXP2_REG_RQ_BW_RD_ADD19,\n\t\tPXP2_REG_RQ_BW_RD_UBOUND19},\n\t{PXP2_REG_RQ_BW_RD_L20, PXP2_REG_RQ_BW_RD_ADD20,\n\t\tPXP2_REG_RQ_BW_RD_UBOUND20},\n\t{PXP2_REG_RQ_BW_RD_L22, PXP2_REG_RQ_BW_RD_ADD22,\n\t\tPXP2_REG_RQ_BW_RD_UBOUND22},\n\t{PXP2_REG_RQ_BW_RD_L23, PXP2_REG_RQ_BW_RD_ADD23,\n\t\tPXP2_REG_RQ_BW_RD_UBOUND23},\n\t{PXP2_REG_RQ_BW_RD_L24, PXP2_REG_RQ_BW_RD_ADD24,\n\t\tPXP2_REG_RQ_BW_RD_UBOUND24},\n\t{PXP2_REG_RQ_BW_RD_L25, PXP2_REG_RQ_BW_RD_ADD25,\n\t\tPXP2_REG_RQ_BW_RD_UBOUND25},\n\t{PXP2_REG_RQ_BW_RD_L26, PXP2_REG_RQ_BW_RD_ADD26,\n\t\tPXP2_REG_RQ_BW_RD_UBOUND26},\n\t{PXP2_REG_RQ_BW_RD_L27, PXP2_REG_RQ_BW_RD_ADD27,\n\t\tPXP2_REG_RQ_BW_RD_UBOUND27},\n\t{PXP2_REG_PSWRQ_BW_L28, PXP2_REG_PSWRQ_BW_ADD28,\n\t\tPXP2_REG_PSWRQ_BW_UB28}\n};\n\n \nstatic const struct arb_line write_arb_addr[NUM_WR_Q-1] = {\n \t{PXP2_REG_PSWRQ_BW_L1, PXP2_REG_PSWRQ_BW_ADD1,\n\t\tPXP2_REG_PSWRQ_BW_UB1},\n\t{PXP2_REG_PSWRQ_BW_L2, PXP2_REG_PSWRQ_BW_ADD2,\n\t\tPXP2_REG_PSWRQ_BW_UB2},\n\t{PXP2_REG_PSWRQ_BW_L3, PXP2_REG_PSWRQ_BW_ADD3,\n\t\tPXP2_REG_PSWRQ_BW_UB3},\n\t{PXP2_REG_PSWRQ_BW_L6, PXP2_REG_PSWRQ_BW_ADD6,\n\t\tPXP2_REG_PSWRQ_BW_UB6},\n\t{PXP2_REG_PSWRQ_BW_L7, PXP2_REG_PSWRQ_BW_ADD7,\n\t\tPXP2_REG_PSWRQ_BW_UB7},\n\t{PXP2_REG_PSWRQ_BW_L8, PXP2_REG_PSWRQ_BW_ADD8,\n\t\tPXP2_REG_PSWRQ_BW_UB8},\n\t{PXP2_REG_PSWRQ_BW_L9, PXP2_REG_PSWRQ_BW_ADD9,\n\t\tPXP2_REG_PSWRQ_BW_UB9},\n\t{PXP2_REG_PSWRQ_BW_L10, PXP2_REG_PSWRQ_BW_ADD10,\n\t\tPXP2_REG_PSWRQ_BW_UB10},\n\t{PXP2_REG_PSWRQ_BW_L11, PXP2_REG_PSWRQ_BW_ADD11,\n\t\tPXP2_REG_PSWRQ_BW_UB11},\n {PXP2_REG_PSWRQ_BW_L28, PXP2_REG_PSWRQ_BW_ADD28,\n\t\tPXP2_REG_PSWRQ_BW_UB28},\n\t{PXP2_REG_RQ_BW_WR_L29, PXP2_REG_RQ_BW_WR_ADD29,\n\t\tPXP2_REG_RQ_BW_WR_UBOUND29},\n\t{PXP2_REG_RQ_BW_WR_L30, PXP2_REG_RQ_BW_WR_ADD30,\n\t\tPXP2_REG_RQ_BW_WR_UBOUND30}\n};\n\nstatic void bnx2x_init_pxp_arb(struct bnx2x *bp, int r_order,\n\t\t\t       int w_order)\n{\n\tu32 val, i;\n\n\tif (r_order > MAX_RD_ORD) {\n\t\tDP(NETIF_MSG_HW, \"read order of %d  order adjusted to %d\\n\",\n\t\t   r_order, MAX_RD_ORD);\n\t\tr_order = MAX_RD_ORD;\n\t}\n\tif (w_order > MAX_WR_ORD) {\n\t\tDP(NETIF_MSG_HW, \"write order of %d  order adjusted to %d\\n\",\n\t\t   w_order, MAX_WR_ORD);\n\t\tw_order = MAX_WR_ORD;\n\t}\n\tif (CHIP_REV_IS_FPGA(bp)) {\n\t\tDP(NETIF_MSG_HW, \"write order adjusted to 1 for FPGA\\n\");\n\t\tw_order = 0;\n\t}\n\tDP(NETIF_MSG_HW, \"read order %d  write order %d\\n\", r_order, w_order);\n\n\tfor (i = 0; i < NUM_RD_Q-1; i++) {\n\t\tREG_WR(bp, read_arb_addr[i].l, read_arb_data[i][r_order].l);\n\t\tREG_WR(bp, read_arb_addr[i].add,\n\t\t       read_arb_data[i][r_order].add);\n\t\tREG_WR(bp, read_arb_addr[i].ubound,\n\t\t       read_arb_data[i][r_order].ubound);\n\t}\n\n\tfor (i = 0; i < NUM_WR_Q-1; i++) {\n\t\tif ((write_arb_addr[i].l == PXP2_REG_RQ_BW_WR_L29) ||\n\t\t    (write_arb_addr[i].l == PXP2_REG_RQ_BW_WR_L30)) {\n\n\t\t\tREG_WR(bp, write_arb_addr[i].l,\n\t\t\t       write_arb_data[i][w_order].l);\n\n\t\t\tREG_WR(bp, write_arb_addr[i].add,\n\t\t\t       write_arb_data[i][w_order].add);\n\n\t\t\tREG_WR(bp, write_arb_addr[i].ubound,\n\t\t\t       write_arb_data[i][w_order].ubound);\n\t\t} else {\n\n\t\t\tval = REG_RD(bp, write_arb_addr[i].l);\n\t\t\tREG_WR(bp, write_arb_addr[i].l,\n\t\t\t       val | (write_arb_data[i][w_order].l << 10));\n\n\t\t\tval = REG_RD(bp, write_arb_addr[i].add);\n\t\t\tREG_WR(bp, write_arb_addr[i].add,\n\t\t\t       val | (write_arb_data[i][w_order].add << 10));\n\n\t\t\tval = REG_RD(bp, write_arb_addr[i].ubound);\n\t\t\tREG_WR(bp, write_arb_addr[i].ubound,\n\t\t\t       val | (write_arb_data[i][w_order].ubound << 7));\n\t\t}\n\t}\n\n\tval =  write_arb_data[NUM_WR_Q-1][w_order].add;\n\tval += write_arb_data[NUM_WR_Q-1][w_order].ubound << 10;\n\tval += write_arb_data[NUM_WR_Q-1][w_order].l << 17;\n\tREG_WR(bp, PXP2_REG_PSWRQ_BW_RD, val);\n\n\tval =  read_arb_data[NUM_RD_Q-1][r_order].add;\n\tval += read_arb_data[NUM_RD_Q-1][r_order].ubound << 10;\n\tval += read_arb_data[NUM_RD_Q-1][r_order].l << 17;\n\tREG_WR(bp, PXP2_REG_PSWRQ_BW_WR, val);\n\n\tREG_WR(bp, PXP2_REG_RQ_WR_MBS0, w_order);\n\tREG_WR(bp, PXP2_REG_RQ_WR_MBS1, w_order);\n\tREG_WR(bp, PXP2_REG_RQ_RD_MBS0, r_order);\n\tREG_WR(bp, PXP2_REG_RQ_RD_MBS1, r_order);\n\n\tif ((CHIP_IS_E1(bp) || CHIP_IS_E1H(bp)) && (r_order == MAX_RD_ORD))\n\t\tREG_WR(bp, PXP2_REG_RQ_PDR_LIMIT, 0xe00);\n\n\tif (CHIP_IS_E3(bp))\n\t\tREG_WR(bp, PXP2_REG_WR_USDMDP_TH, (0x4 << w_order));\n\telse if (CHIP_IS_E2(bp))\n\t\tREG_WR(bp, PXP2_REG_WR_USDMDP_TH, (0x8 << w_order));\n\telse\n\t\tREG_WR(bp, PXP2_REG_WR_USDMDP_TH, (0x18 << w_order));\n\n\tif (!CHIP_IS_E1(bp)) {\n\t\t \n\t\t \n\t\tif (!CHIP_IS_E1H(bp)) {\n\t\t\t \n\t\t\tval = w_order;\n\t\t\tREG_WR(bp, PXP2_REG_WR_DMAE_MPS, val);\n\t\t} else {\n\t\t\tval = ((w_order == 0) ? 2 : 3);\n\t\t\tREG_WR(bp, PXP2_REG_WR_DMAE_MPS, 2);\n\t\t}\n\n\t\tREG_WR(bp, PXP2_REG_WR_HC_MPS, val);\n\t\tREG_WR(bp, PXP2_REG_WR_USDM_MPS, val);\n\t\tREG_WR(bp, PXP2_REG_WR_CSDM_MPS, val);\n\t\tREG_WR(bp, PXP2_REG_WR_TSDM_MPS, val);\n\t\tREG_WR(bp, PXP2_REG_WR_XSDM_MPS, val);\n\t\tREG_WR(bp, PXP2_REG_WR_QM_MPS, val);\n\t\tREG_WR(bp, PXP2_REG_WR_TM_MPS, val);\n\t\tREG_WR(bp, PXP2_REG_WR_SRC_MPS, val);\n\t\tREG_WR(bp, PXP2_REG_WR_DBG_MPS, val);\n\t\tREG_WR(bp, PXP2_REG_WR_CDU_MPS, val);\n\t}\n\n\t \n#define PCIE_REG_PCIER_TL_HDR_FC_ST\t\t0x2980\n\tval = REG_RD(bp, PCIE_REG_PCIER_TL_HDR_FC_ST);\n\tval &= 0xFF;\n\tif (val <= 0x20)\n\t\tREG_WR(bp, PXP2_REG_PGL_TAGS_LIMIT, 0x20);\n}\n\n \n \n\n \n\n \n#define ILT_MEMOP_ALLOC\t\t0\n#define ILT_MEMOP_FREE\t\t1\n\n \n#define ILT_ADDR1(x)\t\t((u32)(((u64)x >> 12) & 0xFFFFFFFF))\n#define ILT_ADDR2(x)\t\t((u32)((1 << 20) | ((u64)x >> 44)))\n#define ILT_RANGE(f, l)\t\t(((l) << 10) | f)\n\nstatic int bnx2x_ilt_line_mem_op(struct bnx2x *bp,\n\t\t\t\t struct ilt_line *line, u32 size, u8 memop)\n{\n\tif (memop == ILT_MEMOP_FREE) {\n\t\tBNX2X_ILT_FREE(line->page, line->page_mapping, line->size);\n\t\treturn 0;\n\t}\n\tBNX2X_ILT_ZALLOC(line->page, &line->page_mapping, size);\n\tif (!line->page)\n\t\treturn -1;\n\tline->size = size;\n\treturn 0;\n}\n\n\nstatic int bnx2x_ilt_client_mem_op(struct bnx2x *bp, int cli_num,\n\t\t\t\t   u8 memop)\n{\n\tint i, rc;\n\tstruct bnx2x_ilt *ilt = BP_ILT(bp);\n\tstruct ilt_client_info *ilt_cli;\n\n\tif (!ilt || !ilt->lines)\n\t\treturn -1;\n\n\tilt_cli = &ilt->clients[cli_num];\n\n\tif (ilt_cli->flags & (ILT_CLIENT_SKIP_INIT | ILT_CLIENT_SKIP_MEM))\n\t\treturn 0;\n\n\tfor (rc = 0, i = ilt_cli->start; i <= ilt_cli->end && !rc; i++) {\n\t\trc = bnx2x_ilt_line_mem_op(bp, &ilt->lines[i],\n\t\t\t\t\t   ilt_cli->page_size, memop);\n\t}\n\treturn rc;\n}\n\nstatic int bnx2x_ilt_mem_op_cnic(struct bnx2x *bp, u8 memop)\n{\n\tint rc = 0;\n\n\tif (CONFIGURE_NIC_MODE(bp))\n\t\trc = bnx2x_ilt_client_mem_op(bp, ILT_CLIENT_SRC, memop);\n\tif (!rc)\n\t\trc = bnx2x_ilt_client_mem_op(bp, ILT_CLIENT_TM, memop);\n\n\treturn rc;\n}\n\nstatic int bnx2x_ilt_mem_op(struct bnx2x *bp, u8 memop)\n{\n\tint rc = bnx2x_ilt_client_mem_op(bp, ILT_CLIENT_CDU, memop);\n\tif (!rc)\n\t\trc = bnx2x_ilt_client_mem_op(bp, ILT_CLIENT_QM, memop);\n\tif (!rc && CNIC_SUPPORT(bp) && !CONFIGURE_NIC_MODE(bp))\n\t\trc = bnx2x_ilt_client_mem_op(bp, ILT_CLIENT_SRC, memop);\n\n\treturn rc;\n}\n\nstatic void bnx2x_ilt_line_wr(struct bnx2x *bp, int abs_idx,\n\t\t\t      dma_addr_t page_mapping)\n{\n\tu32 reg;\n\n\tif (CHIP_IS_E1(bp))\n\t\treg = PXP2_REG_RQ_ONCHIP_AT + abs_idx*8;\n\telse\n\t\treg = PXP2_REG_RQ_ONCHIP_AT_B0 + abs_idx*8;\n\n\tbnx2x_wr_64(bp, reg, ILT_ADDR1(page_mapping), ILT_ADDR2(page_mapping));\n}\n\nstatic void bnx2x_ilt_line_init_op(struct bnx2x *bp,\n\t\t\t\t   struct bnx2x_ilt *ilt, int idx, u8 initop)\n{\n\tdma_addr_t\tnull_mapping;\n\tint abs_idx = ilt->start_line + idx;\n\n\n\tswitch (initop) {\n\tcase INITOP_INIT:\n\t\t \n\tcase INITOP_SET:\n\t\tbnx2x_ilt_line_wr(bp, abs_idx, ilt->lines[idx].page_mapping);\n\t\tbreak;\n\tcase INITOP_CLEAR:\n\t\tnull_mapping = 0;\n\t\tbnx2x_ilt_line_wr(bp, abs_idx, null_mapping);\n\t\tbreak;\n\t}\n}\n\nstatic void bnx2x_ilt_boundry_init_op(struct bnx2x *bp,\n\t\t\t\t      struct ilt_client_info *ilt_cli,\n\t\t\t\t      u32 ilt_start, u8 initop)\n{\n\tu32 start_reg = 0;\n\tu32 end_reg = 0;\n\n\t \n\n\t \n\tif (CHIP_IS_E1(bp)) {\n\t\tswitch (ilt_cli->client_num) {\n\t\tcase ILT_CLIENT_CDU:\n\t\t\tstart_reg = PXP2_REG_PSWRQ_CDU0_L2P;\n\t\t\tbreak;\n\t\tcase ILT_CLIENT_QM:\n\t\t\tstart_reg = PXP2_REG_PSWRQ_QM0_L2P;\n\t\t\tbreak;\n\t\tcase ILT_CLIENT_SRC:\n\t\t\tstart_reg = PXP2_REG_PSWRQ_SRC0_L2P;\n\t\t\tbreak;\n\t\tcase ILT_CLIENT_TM:\n\t\t\tstart_reg = PXP2_REG_PSWRQ_TM0_L2P;\n\t\t\tbreak;\n\t\t}\n\t\tREG_WR(bp, start_reg + BP_FUNC(bp)*4,\n\t\t       ILT_RANGE((ilt_start + ilt_cli->start),\n\t\t\t\t (ilt_start + ilt_cli->end)));\n\t} else {\n\t\tswitch (ilt_cli->client_num) {\n\t\tcase ILT_CLIENT_CDU:\n\t\t\tstart_reg = PXP2_REG_RQ_CDU_FIRST_ILT;\n\t\t\tend_reg = PXP2_REG_RQ_CDU_LAST_ILT;\n\t\t\tbreak;\n\t\tcase ILT_CLIENT_QM:\n\t\t\tstart_reg = PXP2_REG_RQ_QM_FIRST_ILT;\n\t\t\tend_reg = PXP2_REG_RQ_QM_LAST_ILT;\n\t\t\tbreak;\n\t\tcase ILT_CLIENT_SRC:\n\t\t\tstart_reg = PXP2_REG_RQ_SRC_FIRST_ILT;\n\t\t\tend_reg = PXP2_REG_RQ_SRC_LAST_ILT;\n\t\t\tbreak;\n\t\tcase ILT_CLIENT_TM:\n\t\t\tstart_reg = PXP2_REG_RQ_TM_FIRST_ILT;\n\t\t\tend_reg = PXP2_REG_RQ_TM_LAST_ILT;\n\t\t\tbreak;\n\t\t}\n\t\tREG_WR(bp, start_reg, (ilt_start + ilt_cli->start));\n\t\tREG_WR(bp, end_reg, (ilt_start + ilt_cli->end));\n\t}\n}\n\nstatic void bnx2x_ilt_client_init_op_ilt(struct bnx2x *bp,\n\t\t\t\t\t struct bnx2x_ilt *ilt,\n\t\t\t\t\t struct ilt_client_info *ilt_cli,\n\t\t\t\t\t u8 initop)\n{\n\tint i;\n\n\tif (ilt_cli->flags & ILT_CLIENT_SKIP_INIT)\n\t\treturn;\n\n\tfor (i = ilt_cli->start; i <= ilt_cli->end; i++)\n\t\tbnx2x_ilt_line_init_op(bp, ilt, i, initop);\n\n\t \n\tbnx2x_ilt_boundry_init_op(bp, ilt_cli, ilt->start_line, initop);\n}\n\nstatic void bnx2x_ilt_client_init_op(struct bnx2x *bp,\n\t\t\t\t     struct ilt_client_info *ilt_cli, u8 initop)\n{\n\tstruct bnx2x_ilt *ilt = BP_ILT(bp);\n\n\tbnx2x_ilt_client_init_op_ilt(bp, ilt, ilt_cli, initop);\n}\n\nstatic void bnx2x_ilt_client_id_init_op(struct bnx2x *bp,\n\t\t\t\t\tint cli_num, u8 initop)\n{\n\tstruct bnx2x_ilt *ilt = BP_ILT(bp);\n\tstruct ilt_client_info *ilt_cli = &ilt->clients[cli_num];\n\n\tbnx2x_ilt_client_init_op(bp, ilt_cli, initop);\n}\n\nstatic void bnx2x_ilt_init_op_cnic(struct bnx2x *bp, u8 initop)\n{\n\tif (CONFIGURE_NIC_MODE(bp))\n\t\tbnx2x_ilt_client_id_init_op(bp, ILT_CLIENT_SRC, initop);\n\tbnx2x_ilt_client_id_init_op(bp, ILT_CLIENT_TM, initop);\n}\n\nstatic void bnx2x_ilt_init_op(struct bnx2x *bp, u8 initop)\n{\n\tbnx2x_ilt_client_id_init_op(bp, ILT_CLIENT_CDU, initop);\n\tbnx2x_ilt_client_id_init_op(bp, ILT_CLIENT_QM, initop);\n\tif (CNIC_SUPPORT(bp) && !CONFIGURE_NIC_MODE(bp))\n\t\tbnx2x_ilt_client_id_init_op(bp, ILT_CLIENT_SRC, initop);\n}\n\nstatic void bnx2x_ilt_init_client_psz(struct bnx2x *bp, int cli_num,\n\t\t\t\t      u32 psz_reg, u8 initop)\n{\n\tstruct bnx2x_ilt *ilt = BP_ILT(bp);\n\tstruct ilt_client_info *ilt_cli = &ilt->clients[cli_num];\n\n\tif (ilt_cli->flags & ILT_CLIENT_SKIP_INIT)\n\t\treturn;\n\n\tswitch (initop) {\n\tcase INITOP_INIT:\n\t\t \n\tcase INITOP_SET:\n\t\tREG_WR(bp, psz_reg, ILOG2(ilt_cli->page_size >> 12));\n\t\tbreak;\n\tcase INITOP_CLEAR:\n\t\tbreak;\n\t}\n}\n\n \nstatic void bnx2x_ilt_init_page_size(struct bnx2x *bp, u8 initop)\n{\n\tbnx2x_ilt_init_client_psz(bp, ILT_CLIENT_CDU,\n\t\t\t\t  PXP2_REG_RQ_CDU_P_SIZE, initop);\n\tbnx2x_ilt_init_client_psz(bp, ILT_CLIENT_QM,\n\t\t\t\t  PXP2_REG_RQ_QM_P_SIZE, initop);\n\tbnx2x_ilt_init_client_psz(bp, ILT_CLIENT_SRC,\n\t\t\t\t  PXP2_REG_RQ_SRC_P_SIZE, initop);\n\tbnx2x_ilt_init_client_psz(bp, ILT_CLIENT_TM,\n\t\t\t\t  PXP2_REG_RQ_TM_P_SIZE, initop);\n}\n\n \n#define QM_QUEUES_PER_FUNC\t16  \n#define QM_INIT_MIN_CID_COUNT\t31\n#define QM_INIT(cid_cnt)\t(cid_cnt > QM_INIT_MIN_CID_COUNT)\n\n \nstatic void bnx2x_qm_init_cid_count(struct bnx2x *bp, int qm_cid_count,\n\t\t\t\t    u8 initop)\n{\n\tint port = BP_PORT(bp);\n\n\tif (QM_INIT(qm_cid_count)) {\n\t\tswitch (initop) {\n\t\tcase INITOP_INIT:\n\t\t\t \n\t\tcase INITOP_SET:\n\t\t\tREG_WR(bp, QM_REG_CONNNUM_0 + port*4,\n\t\t\t       qm_cid_count/16 - 1);\n\t\t\tbreak;\n\t\tcase INITOP_CLEAR:\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void bnx2x_qm_set_ptr_table(struct bnx2x *bp, int qm_cid_count,\n\t\t\t\t   u32 base_reg, u32 reg)\n{\n\tint i;\n\tu32 wb_data[2] = {0, 0};\n\tfor (i = 0; i < 4 * QM_QUEUES_PER_FUNC; i++) {\n\t\tREG_WR(bp, base_reg + i*4,\n\t\t       qm_cid_count * 4 * (i % QM_QUEUES_PER_FUNC));\n\t\tbnx2x_init_wr_wb(bp, reg + i*8,\t wb_data, 2);\n\t}\n}\n\n \nstatic void bnx2x_qm_init_ptr_table(struct bnx2x *bp, int qm_cid_count,\n\t\t\t\t    u8 initop)\n{\n\tif (!QM_INIT(qm_cid_count))\n\t\treturn;\n\n\tswitch (initop) {\n\tcase INITOP_INIT:\n\t\t \n\tcase INITOP_SET:\n\t\tbnx2x_qm_set_ptr_table(bp, qm_cid_count,\n\t\t\t\t       QM_REG_BASEADDR, QM_REG_PTRTBL);\n\t\tif (CHIP_IS_E1H(bp))\n\t\t\tbnx2x_qm_set_ptr_table(bp, qm_cid_count,\n\t\t\t\t\t       QM_REG_BASEADDR_EXT_A,\n\t\t\t\t\t       QM_REG_PTRTBL_EXT_A);\n\t\tbreak;\n\tcase INITOP_CLEAR:\n\t\tbreak;\n\t}\n}\n\n \n \nstatic void bnx2x_src_init_t2(struct bnx2x *bp, struct src_ent *t2,\n\t\t\t      dma_addr_t t2_mapping, int src_cid_count)\n{\n\tint i;\n\tint port = BP_PORT(bp);\n\n\t \n\tfor (i = 0; i < src_cid_count-1; i++)\n\t\tt2[i].next = (u64)(t2_mapping +\n\t\t\t     (i+1)*sizeof(struct src_ent));\n\n\t \n\tREG_WR(bp, SRC_REG_COUNTFREE0 + port*4, src_cid_count);\n\n\tbnx2x_wr_64(bp, SRC_REG_FIRSTFREE0 + port*16,\n\t\t    U64_LO(t2_mapping), U64_HI(t2_mapping));\n\n\tbnx2x_wr_64(bp, SRC_REG_LASTFREE0 + port*16,\n\t\t    U64_LO((u64)t2_mapping +\n\t\t\t   (src_cid_count-1) * sizeof(struct src_ent)),\n\t\t    U64_HI((u64)t2_mapping +\n\t\t\t   (src_cid_count-1) * sizeof(struct src_ent)));\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}