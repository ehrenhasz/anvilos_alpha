{
  "module_name": "bnx2x_cmn.h",
  "hash_id": "a53c74e38d7b9f6836556885cc6237232d6b3527ef99aab107fd121855469310",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/broadcom/bnx2x/bnx2x_cmn.h",
  "human_readable_source": " \n#ifndef BNX2X_CMN_H\n#define BNX2X_CMN_H\n\n#include <linux/types.h>\n#include <linux/pci.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/irq.h>\n\n#include \"bnx2x.h\"\n#include \"bnx2x_sriov.h\"\n\n \nextern int bnx2x_load_count[2][3];  \nextern int bnx2x_num_queues;\n\n \n#define BNX2X_PCI_FREE(x, y, size) \\\n\tdo { \\\n\t\tif (x) { \\\n\t\t\tdma_free_coherent(&bp->pdev->dev, size, (void *)x, y); \\\n\t\t\tx = NULL; \\\n\t\t\ty = 0; \\\n\t\t} \\\n\t} while (0)\n\n#define BNX2X_FREE(x) \\\n\tdo { \\\n\t\tif (x) { \\\n\t\t\tkfree((void *)x); \\\n\t\t\tx = NULL; \\\n\t\t} \\\n\t} while (0)\n\n#define BNX2X_PCI_ALLOC(y, size)\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tvoid *x = dma_alloc_coherent(&bp->pdev->dev, size, y, GFP_KERNEL); \\\n\tif (x)\t\t\t\t\t\t\t\t\\\n\t\tDP(NETIF_MSG_HW,\t\t\t\t\t\\\n\t\t   \"BNX2X_PCI_ALLOC: Physical %Lx Virtual %p\\n\",\t\\\n\t\t   (unsigned long long)(*y), x);\t\t\t\\\n\tx;\t\t\t\t\t\t\t\t\\\n})\n#define BNX2X_PCI_FALLOC(y, size)\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tvoid *x = dma_alloc_coherent(&bp->pdev->dev, size, y, GFP_KERNEL); \\\n\tif (x) {\t\t\t\t\t\t\t\\\n\t\tmemset(x, 0xff, size);\t\t\t\t\t\\\n\t\tDP(NETIF_MSG_HW,\t\t\t\t\t\\\n\t\t   \"BNX2X_PCI_FALLOC: Physical %Lx Virtual %p\\n\",\t\\\n\t\t   (unsigned long long)(*y), x);\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tx;\t\t\t\t\t\t\t\t\\\n})\n\n \n \n\n \nu32 bnx2x_send_unload_req(struct bnx2x *bp, int unload_mode);\n\n \nvoid bnx2x_send_unload_done(struct bnx2x *bp, bool keep_link);\n\n \nint bnx2x_rss(struct bnx2x *bp, struct bnx2x_rss_config_obj *rss_obj,\n\t      bool config_hash, bool enable);\n\n \nvoid bnx2x__init_func_obj(struct bnx2x *bp);\n\n \nint bnx2x_setup_queue(struct bnx2x *bp, struct bnx2x_fastpath *fp,\n\t\t       bool leading);\n\n \nint bnx2x_setup_leading(struct bnx2x *bp);\n\n \nu32 bnx2x_fw_command(struct bnx2x *bp, u32 command, u32 param);\n\n \nint bnx2x_initial_phy_init(struct bnx2x *bp, int load_mode);\n\n \nvoid bnx2x_link_set(struct bnx2x *bp);\n\n \nvoid bnx2x_force_link_reset(struct bnx2x *bp);\n\n \nu8 bnx2x_link_test(struct bnx2x *bp, u8 is_serdes);\n\n \nvoid bnx2x_drv_pulse(struct bnx2x *bp);\n\n \nvoid bnx2x_igu_ack_sb(struct bnx2x *bp, u8 igu_sb_id, u8 segment,\n\t\t      u16 index, u8 op, u8 update);\n\n \nvoid bnx2x_pf_disable(struct bnx2x *bp);\nint bnx2x_pretend_func(struct bnx2x *bp, u16 pretend_func_val);\n\n \nvoid bnx2x__link_status_update(struct bnx2x *bp);\n\n \nvoid bnx2x_link_report(struct bnx2x *bp);\n\n \nvoid __bnx2x_link_report(struct bnx2x *bp);\n\n \nu16 bnx2x_get_mf_speed(struct bnx2x *bp);\n\n \nirqreturn_t bnx2x_msix_sp_int(int irq, void *dev_instance);\n\n \nirqreturn_t bnx2x_interrupt(int irq, void *dev_instance);\n\n \nint bnx2x_cnic_notify(struct bnx2x *bp, int cmd);\n\n \nvoid bnx2x_setup_cnic_irq_info(struct bnx2x *bp);\n\n \nvoid bnx2x_setup_cnic_info(struct bnx2x *bp);\n\n \nvoid bnx2x_int_enable(struct bnx2x *bp);\n\n \nvoid bnx2x_int_disable_sync(struct bnx2x *bp, int disable_hw);\n\n \nvoid bnx2x_nic_init_cnic(struct bnx2x *bp);\n\n \nvoid bnx2x_pre_irq_nic_init(struct bnx2x *bp);\n\n \nvoid bnx2x_post_irq_nic_init(struct bnx2x *bp, u32 load_code);\n \nint bnx2x_alloc_mem_cnic(struct bnx2x *bp);\n \nint bnx2x_alloc_mem(struct bnx2x *bp);\n\n \nvoid bnx2x_free_mem_cnic(struct bnx2x *bp);\n \nvoid bnx2x_free_mem(struct bnx2x *bp);\n\n \nvoid bnx2x_set_num_queues(struct bnx2x *bp);\n\n \nvoid bnx2x_chip_cleanup(struct bnx2x *bp, int unload_mode, bool keep_link);\n\n \nint bnx2x_acquire_hw_lock(struct bnx2x *bp, u32 resource);\n\n \nint bnx2x_release_hw_lock(struct bnx2x *bp, u32 resource);\n\n \nint bnx2x_release_leader_lock(struct bnx2x *bp);\n\n \nint bnx2x_set_eth_mac(struct bnx2x *bp, bool set);\n\n \nvoid bnx2x_set_rx_mode_inner(struct bnx2x *bp);\n\n \nvoid bnx2x_set_pf_load(struct bnx2x *bp);\nbool bnx2x_clear_pf_load(struct bnx2x *bp);\nbool bnx2x_chk_parity_attn(struct bnx2x *bp, bool *global, bool print);\nbool bnx2x_reset_is_done(struct bnx2x *bp, int engine);\nvoid bnx2x_set_reset_in_progress(struct bnx2x *bp);\nvoid bnx2x_set_reset_global(struct bnx2x *bp);\nvoid bnx2x_disable_close_the_gate(struct bnx2x *bp);\nint bnx2x_init_hw_func_cnic(struct bnx2x *bp);\n\nvoid bnx2x_clear_vlan_info(struct bnx2x *bp);\n\n \nvoid bnx2x_sp_event(struct bnx2x_fastpath *fp, union eth_rx_cqe *rr_cqe);\n\n \nvoid bnx2x_ilt_set_info(struct bnx2x *bp);\n\n \nvoid bnx2x_ilt_set_info_cnic(struct bnx2x *bp);\n\n \nvoid bnx2x_dcbx_init(struct bnx2x *bp, bool update_shmem);\n\n \nint bnx2x_set_power_state(struct bnx2x *bp, pci_power_t state);\n\n \nvoid bnx2x_update_max_mf_config(struct bnx2x *bp, u32 value);\n \nvoid bnx2x_fw_dump_lvl(struct bnx2x *bp, const char *lvl);\n\n \nint bnx2x_nic_unload(struct bnx2x *bp, int unload_mode, bool keep_link);\n\n \nint bnx2x_nic_load(struct bnx2x *bp, int load_mode);\n\n \nnetdev_tx_t bnx2x_start_xmit(struct sk_buff *skb, struct net_device *dev);\n\n \nint bnx2x_setup_tc(struct net_device *dev, u8 num_tc);\nint __bnx2x_setup_tc(struct net_device *dev, enum tc_setup_type type,\n\t\t     void *type_data);\n\nint bnx2x_get_vf_config(struct net_device *dev, int vf,\n\t\t\tstruct ifla_vf_info *ivi);\nint bnx2x_set_vf_mac(struct net_device *dev, int queue, u8 *mac);\nint bnx2x_set_vf_vlan(struct net_device *netdev, int vf, u16 vlan, u8 qos,\n\t\t      __be16 vlan_proto);\nint bnx2x_set_vf_spoofchk(struct net_device *dev, int idx, bool val);\n\n \nu16 bnx2x_select_queue(struct net_device *dev, struct sk_buff *skb,\n\t\t       struct net_device *sb_dev);\n\nstatic inline void bnx2x_update_rx_prod(struct bnx2x *bp,\n\t\t\t\t\tstruct bnx2x_fastpath *fp,\n\t\t\t\t\tu16 bd_prod, u16 rx_comp_prod,\n\t\t\t\t\tu16 rx_sge_prod)\n{\n\tstruct ustorm_eth_rx_producers rx_prods = {0};\n\tu32 i;\n\n\t \n\trx_prods.bd_prod = bd_prod;\n\trx_prods.cqe_prod = rx_comp_prod;\n\trx_prods.sge_prod = rx_sge_prod;\n\n\t \n\twmb();\n\n\tfor (i = 0; i < sizeof(rx_prods)/4; i++)\n\t\tREG_WR_RELAXED(bp, fp->ustorm_rx_prods_offset + i * 4,\n\t\t\t       ((u32 *)&rx_prods)[i]);\n\n\tDP(NETIF_MSG_RX_STATUS,\n\t   \"queue[%d]:  wrote  bd_prod %u  cqe_prod %u  sge_prod %u\\n\",\n\t   fp->index, bd_prod, rx_comp_prod, rx_sge_prod);\n}\n\n \nint bnx2x_reload_if_running(struct net_device *dev);\n\nint bnx2x_change_mac_addr(struct net_device *dev, void *p);\n\n \nint bnx2x_tx_int(struct bnx2x *bp, struct bnx2x_fp_txdata *txdata);\n\nextern const struct dev_pm_ops bnx2x_pm_ops;\n\n \nvoid bnx2x_free_irq(struct bnx2x *bp);\n\nvoid bnx2x_free_fp_mem(struct bnx2x *bp);\nvoid bnx2x_init_rx_rings(struct bnx2x *bp);\nvoid bnx2x_init_rx_rings_cnic(struct bnx2x *bp);\nvoid bnx2x_free_skbs(struct bnx2x *bp);\nvoid bnx2x_netif_stop(struct bnx2x *bp, int disable_hw);\nvoid bnx2x_netif_start(struct bnx2x *bp);\nint bnx2x_load_cnic(struct bnx2x *bp);\n\n \nint bnx2x_enable_msix(struct bnx2x *bp);\n\n \nint bnx2x_enable_msi(struct bnx2x *bp);\n\n \nint bnx2x_alloc_mem_bp(struct bnx2x *bp);\n\n \nvoid bnx2x_free_mem_bp(struct bnx2x *bp);\n\n \nint bnx2x_change_mtu(struct net_device *dev, int new_mtu);\n\n#ifdef NETDEV_FCOE_WWNN\n \nint bnx2x_fcoe_get_wwn(struct net_device *dev, u64 *wwn, int type);\n#endif\n\nnetdev_features_t bnx2x_fix_features(struct net_device *dev,\n\t\t\t\t     netdev_features_t features);\nint bnx2x_set_features(struct net_device *dev, netdev_features_t features);\n\n \nvoid bnx2x_tx_timeout(struct net_device *dev, unsigned int txqueue);\n\n \nvoid bnx2x_get_c2s_mapping(struct bnx2x *bp, u8 *c2s_map, u8 *c2s_default);\n\n \n \nstatic inline void bnx2x_update_fpsb_idx(struct bnx2x_fastpath *fp)\n{\n\tbarrier();  \n\tfp->fp_hc_idx = fp->sb_running_index[SM_RX_ID];\n}\n\nstatic inline void bnx2x_igu_ack_sb_gen(struct bnx2x *bp, u8 igu_sb_id,\n\t\t\t\t\tu8 segment, u16 index, u8 op,\n\t\t\t\t\tu8 update, u32 igu_addr)\n{\n\tstruct igu_regular cmd_data = {0};\n\n\tcmd_data.sb_id_and_flags =\n\t\t\t((index << IGU_REGULAR_SB_INDEX_SHIFT) |\n\t\t\t (segment << IGU_REGULAR_SEGMENT_ACCESS_SHIFT) |\n\t\t\t (update << IGU_REGULAR_BUPDATE_SHIFT) |\n\t\t\t (op << IGU_REGULAR_ENABLE_INT_SHIFT));\n\n\tDP(NETIF_MSG_INTR, \"write 0x%08x to IGU addr 0x%x\\n\",\n\t   cmd_data.sb_id_and_flags, igu_addr);\n\tREG_WR(bp, igu_addr, cmd_data.sb_id_and_flags);\n\n\t \n\tbarrier();\n}\n\nstatic inline void bnx2x_hc_ack_sb(struct bnx2x *bp, u8 sb_id,\n\t\t\t\t   u8 storm, u16 index, u8 op, u8 update)\n{\n\tu32 hc_addr = (HC_REG_COMMAND_REG + BP_PORT(bp)*32 +\n\t\t       COMMAND_REG_INT_ACK);\n\tstruct igu_ack_register igu_ack;\n\n\tigu_ack.status_block_index = index;\n\tigu_ack.sb_id_and_flags =\n\t\t\t((sb_id << IGU_ACK_REGISTER_STATUS_BLOCK_ID_SHIFT) |\n\t\t\t (storm << IGU_ACK_REGISTER_STORM_ID_SHIFT) |\n\t\t\t (update << IGU_ACK_REGISTER_UPDATE_INDEX_SHIFT) |\n\t\t\t (op << IGU_ACK_REGISTER_INTERRUPT_MODE_SHIFT));\n\n\tREG_WR(bp, hc_addr, (*(u32 *)&igu_ack));\n\n\t \n\tbarrier();\n}\n\nstatic inline void bnx2x_ack_sb(struct bnx2x *bp, u8 igu_sb_id, u8 storm,\n\t\t\t\tu16 index, u8 op, u8 update)\n{\n\tif (bp->common.int_block == INT_BLOCK_HC)\n\t\tbnx2x_hc_ack_sb(bp, igu_sb_id, storm, index, op, update);\n\telse {\n\t\tu8 segment;\n\n\t\tif (CHIP_INT_MODE_IS_BC(bp))\n\t\t\tsegment = storm;\n\t\telse if (igu_sb_id != bp->igu_dsb_id)\n\t\t\tsegment = IGU_SEG_ACCESS_DEF;\n\t\telse if (storm == ATTENTION_ID)\n\t\t\tsegment = IGU_SEG_ACCESS_ATTN;\n\t\telse\n\t\t\tsegment = IGU_SEG_ACCESS_DEF;\n\t\tbnx2x_igu_ack_sb(bp, igu_sb_id, segment, index, op, update);\n\t}\n}\n\nstatic inline u16 bnx2x_hc_ack_int(struct bnx2x *bp)\n{\n\tu32 hc_addr = (HC_REG_COMMAND_REG + BP_PORT(bp)*32 +\n\t\t       COMMAND_REG_SIMD_MASK);\n\tu32 result = REG_RD(bp, hc_addr);\n\n\tbarrier();\n\treturn result;\n}\n\nstatic inline u16 bnx2x_igu_ack_int(struct bnx2x *bp)\n{\n\tu32 igu_addr = (BAR_IGU_INTMEM + IGU_REG_SISR_MDPC_WMASK_LSB_UPPER*8);\n\tu32 result = REG_RD(bp, igu_addr);\n\n\tDP(NETIF_MSG_INTR, \"read 0x%08x from IGU addr 0x%x\\n\",\n\t   result, igu_addr);\n\n\tbarrier();\n\treturn result;\n}\n\nstatic inline u16 bnx2x_ack_int(struct bnx2x *bp)\n{\n\tbarrier();\n\tif (bp->common.int_block == INT_BLOCK_HC)\n\t\treturn bnx2x_hc_ack_int(bp);\n\telse\n\t\treturn bnx2x_igu_ack_int(bp);\n}\n\nstatic inline int bnx2x_has_tx_work_unload(struct bnx2x_fp_txdata *txdata)\n{\n\t \n\tbarrier();\n\treturn txdata->tx_pkt_prod != txdata->tx_pkt_cons;\n}\n\nstatic inline u16 bnx2x_tx_avail(struct bnx2x *bp,\n\t\t\t\t struct bnx2x_fp_txdata *txdata)\n{\n\ts16 used;\n\tu16 prod;\n\tu16 cons;\n\n\tprod = txdata->tx_bd_prod;\n\tcons = txdata->tx_bd_cons;\n\n\tused = SUB_S16(prod, cons);\n\n#ifdef BNX2X_STOP_ON_ERROR\n\tWARN_ON(used < 0);\n\tWARN_ON(used > txdata->tx_ring_size);\n\tWARN_ON((txdata->tx_ring_size - used) > MAX_TX_AVAIL);\n#endif\n\n\treturn (s16)(txdata->tx_ring_size) - used;\n}\n\nstatic inline int bnx2x_tx_queue_has_work(struct bnx2x_fp_txdata *txdata)\n{\n\tu16 hw_cons;\n\n\t \n\tbarrier();\n\thw_cons = le16_to_cpu(*txdata->tx_cons_sb);\n\treturn hw_cons != txdata->tx_pkt_cons;\n}\n\nstatic inline bool bnx2x_has_tx_work(struct bnx2x_fastpath *fp)\n{\n\tu8 cos;\n\tfor_each_cos_in_tx_queue(fp, cos)\n\t\tif (bnx2x_tx_queue_has_work(fp->txdata_ptr[cos]))\n\t\t\treturn true;\n\treturn false;\n}\n\n#define BNX2X_IS_CQE_COMPLETED(cqe_fp) (cqe_fp->marker == 0x0)\n#define BNX2X_SEED_CQE(cqe_fp) (cqe_fp->marker = 0xFFFFFFFF)\nstatic inline int bnx2x_has_rx_work(struct bnx2x_fastpath *fp)\n{\n\tu16 cons;\n\tunion eth_rx_cqe *cqe;\n\tstruct eth_fast_path_rx_cqe *cqe_fp;\n\n\tcons = RCQ_BD(fp->rx_comp_cons);\n\tcqe = &fp->rx_comp_ring[cons];\n\tcqe_fp = &cqe->fast_path_cqe;\n\treturn BNX2X_IS_CQE_COMPLETED(cqe_fp);\n}\n\n \nstatic inline void bnx2x_tx_disable(struct bnx2x *bp)\n{\n\tnetif_tx_disable(bp->dev);\n\tnetif_carrier_off(bp->dev);\n}\n\nstatic inline void bnx2x_free_rx_sge(struct bnx2x *bp,\n\t\t\t\t     struct bnx2x_fastpath *fp, u16 index)\n{\n\tstruct sw_rx_page *sw_buf = &fp->rx_page_ring[index];\n\tstruct page *page = sw_buf->page;\n\tstruct eth_rx_sge *sge = &fp->rx_sge_ring[index];\n\n\t \n\tif (!page)\n\t\treturn;\n\n\t \n\tdma_unmap_page(&bp->pdev->dev, dma_unmap_addr(sw_buf, mapping),\n\t\t       SGE_PAGE_SIZE, DMA_FROM_DEVICE);\n\n\tput_page(page);\n\n\tsw_buf->page = NULL;\n\tsge->addr_hi = 0;\n\tsge->addr_lo = 0;\n}\n\nstatic inline void bnx2x_del_all_napi_cnic(struct bnx2x *bp)\n{\n\tint i;\n\n\tfor_each_rx_queue_cnic(bp, i) {\n\t\t__netif_napi_del(&bnx2x_fp(bp, i, napi));\n\t}\n\tsynchronize_net();\n}\n\nstatic inline void bnx2x_del_all_napi(struct bnx2x *bp)\n{\n\tint i;\n\n\tfor_each_eth_queue(bp, i) {\n\t\t__netif_napi_del(&bnx2x_fp(bp, i, napi));\n\t}\n\tsynchronize_net();\n}\n\nint bnx2x_set_int_mode(struct bnx2x *bp);\n\nstatic inline void bnx2x_disable_msi(struct bnx2x *bp)\n{\n\tif (bp->flags & USING_MSIX_FLAG) {\n\t\tpci_disable_msix(bp->pdev);\n\t\tbp->flags &= ~(USING_MSIX_FLAG | USING_SINGLE_MSIX_FLAG);\n\t} else if (bp->flags & USING_MSI_FLAG) {\n\t\tpci_disable_msi(bp->pdev);\n\t\tbp->flags &= ~USING_MSI_FLAG;\n\t}\n}\n\nstatic inline void bnx2x_clear_sge_mask_next_elems(struct bnx2x_fastpath *fp)\n{\n\tint i, j;\n\n\tfor (i = 1; i <= NUM_RX_SGE_PAGES; i++) {\n\t\tint idx = RX_SGE_CNT * i - 1;\n\n\t\tfor (j = 0; j < 2; j++) {\n\t\t\tBIT_VEC64_CLEAR_BIT(fp->sge_mask, idx);\n\t\t\tidx--;\n\t\t}\n\t}\n}\n\nstatic inline void bnx2x_init_sge_ring_bit_mask(struct bnx2x_fastpath *fp)\n{\n\t \n\tmemset(fp->sge_mask, 0xff, sizeof(fp->sge_mask));\n\n\t \n\tbnx2x_clear_sge_mask_next_elems(fp);\n}\n\n \nstatic inline void bnx2x_reuse_rx_data(struct bnx2x_fastpath *fp,\n\t\t\t\t      u16 cons, u16 prod)\n{\n\tstruct sw_rx_bd *cons_rx_buf = &fp->rx_buf_ring[cons];\n\tstruct sw_rx_bd *prod_rx_buf = &fp->rx_buf_ring[prod];\n\tstruct eth_rx_bd *cons_bd = &fp->rx_desc_ring[cons];\n\tstruct eth_rx_bd *prod_bd = &fp->rx_desc_ring[prod];\n\n\tdma_unmap_addr_set(prod_rx_buf, mapping,\n\t\t\t   dma_unmap_addr(cons_rx_buf, mapping));\n\tprod_rx_buf->data = cons_rx_buf->data;\n\t*prod_bd = *cons_bd;\n}\n\n \n\n \nstatic inline int func_by_vn(struct bnx2x *bp, int vn)\n{\n\treturn 2 * vn + BP_PORT(bp);\n}\n\nstatic inline int bnx2x_config_rss_eth(struct bnx2x *bp, bool config_hash)\n{\n\treturn bnx2x_rss(bp, &bp->rss_conf_obj, config_hash, true);\n}\n\n \nstatic inline int bnx2x_func_start(struct bnx2x *bp)\n{\n\tstruct bnx2x_func_state_params func_params = {NULL};\n\tstruct bnx2x_func_start_params *start_params =\n\t\t&func_params.params.start;\n\tu16 port;\n\n\t \n\t__set_bit(RAMROD_COMP_WAIT, &func_params.ramrod_flags);\n\n\tfunc_params.f_obj = &bp->func_obj;\n\tfunc_params.cmd = BNX2X_F_CMD_START;\n\n\t \n\tstart_params->mf_mode = bp->mf_mode;\n\tstart_params->sd_vlan_tag = bp->mf_ov;\n\n\t \n\tif (IS_MF_BD(bp)) {\n\t\tDP(NETIF_MSG_IFUP, \"Configuring ethertype 0x88a8 for BD\\n\");\n\t\tstart_params->sd_vlan_eth_type = ETH_P_8021AD;\n\t\tREG_WR(bp, PRS_REG_VLAN_TYPE_0, ETH_P_8021AD);\n\t\tREG_WR(bp, PBF_REG_VLAN_TYPE_0, ETH_P_8021AD);\n\t\tREG_WR(bp, NIG_REG_LLH_E1HOV_TYPE_1, ETH_P_8021AD);\n\n\t\tbnx2x_get_c2s_mapping(bp, start_params->c2s_pri,\n\t\t\t\t      &start_params->c2s_pri_default);\n\t\tstart_params->c2s_pri_valid = 1;\n\n\t\tDP(NETIF_MSG_IFUP,\n\t\t   \"Inner-to-Outer priority: %02x %02x %02x %02x %02x %02x %02x %02x [Default %02x]\\n\",\n\t\t   start_params->c2s_pri[0], start_params->c2s_pri[1],\n\t\t   start_params->c2s_pri[2], start_params->c2s_pri[3],\n\t\t   start_params->c2s_pri[4], start_params->c2s_pri[5],\n\t\t   start_params->c2s_pri[6], start_params->c2s_pri[7],\n\t\t   start_params->c2s_pri_default);\n\t}\n\n\tif (CHIP_IS_E2(bp) || CHIP_IS_E3(bp))\n\t\tstart_params->network_cos_mode = STATIC_COS;\n\telse  \n\t\tstart_params->network_cos_mode = FW_WRR;\n\tif (bp->udp_tunnel_ports[BNX2X_UDP_PORT_VXLAN]) {\n\t\tport = bp->udp_tunnel_ports[BNX2X_UDP_PORT_VXLAN];\n\t\tstart_params->vxlan_dst_port = port;\n\t}\n\tif (bp->udp_tunnel_ports[BNX2X_UDP_PORT_GENEVE]) {\n\t\tport = bp->udp_tunnel_ports[BNX2X_UDP_PORT_GENEVE];\n\t\tstart_params->geneve_dst_port = port;\n\t}\n\n\tstart_params->inner_rss = 1;\n\n\tif (IS_MF_UFP(bp) && BNX2X_IS_MF_SD_PROTOCOL_FCOE(bp)) {\n\t\tstart_params->class_fail_ethtype = ETH_P_FIP;\n\t\tstart_params->class_fail = 1;\n\t\tstart_params->no_added_tags = 1;\n\t}\n\n\treturn bnx2x_func_state_change(bp, &func_params);\n}\n\n \nstatic inline void bnx2x_set_fw_mac_addr(__le16 *fw_hi, __le16 *fw_mid,\n\t\t\t\t\t __le16 *fw_lo, u8 *mac)\n{\n\t((u8 *)fw_hi)[0]  = mac[1];\n\t((u8 *)fw_hi)[1]  = mac[0];\n\t((u8 *)fw_mid)[0] = mac[3];\n\t((u8 *)fw_mid)[1] = mac[2];\n\t((u8 *)fw_lo)[0]  = mac[5];\n\t((u8 *)fw_lo)[1]  = mac[4];\n}\n\nstatic inline void bnx2x_free_rx_mem_pool(struct bnx2x *bp,\n\t\t\t\t\t  struct bnx2x_alloc_pool *pool)\n{\n\tif (!pool->page)\n\t\treturn;\n\n\tput_page(pool->page);\n\n\tpool->page = NULL;\n}\n\nstatic inline void bnx2x_free_rx_sge_range(struct bnx2x *bp,\n\t\t\t\t\t   struct bnx2x_fastpath *fp, int last)\n{\n\tint i;\n\n\tif (fp->mode == TPA_MODE_DISABLED)\n\t\treturn;\n\n\tfor (i = 0; i < last; i++)\n\t\tbnx2x_free_rx_sge(bp, fp, i);\n\n\tbnx2x_free_rx_mem_pool(bp, &fp->page_pool);\n}\n\nstatic inline void bnx2x_set_next_page_rx_bd(struct bnx2x_fastpath *fp)\n{\n\tint i;\n\n\tfor (i = 1; i <= NUM_RX_RINGS; i++) {\n\t\tstruct eth_rx_bd *rx_bd;\n\n\t\trx_bd = &fp->rx_desc_ring[RX_DESC_CNT * i - 2];\n\t\trx_bd->addr_hi =\n\t\t\tcpu_to_le32(U64_HI(fp->rx_desc_mapping +\n\t\t\t\t    BCM_PAGE_SIZE*(i % NUM_RX_RINGS)));\n\t\trx_bd->addr_lo =\n\t\t\tcpu_to_le32(U64_LO(fp->rx_desc_mapping +\n\t\t\t\t    BCM_PAGE_SIZE*(i % NUM_RX_RINGS)));\n\t}\n}\n\n \nstatic inline u8 bnx2x_stats_id(struct bnx2x_fastpath *fp)\n{\n\tstruct bnx2x *bp = fp->bp;\n\tif (!CHIP_IS_E1x(bp)) {\n\t\t \n\t\tif (IS_FCOE_FP(fp))\n\t\t\treturn bp->cnic_base_cl_id + (bp->pf_num >> 1);\n\t\treturn fp->cl_id;\n\t}\n\treturn fp->cl_id + BP_PORT(bp) * FP_SB_MAX_E1x;\n}\n\nstatic inline void bnx2x_init_vlan_mac_fp_objs(struct bnx2x_fastpath *fp,\n\t\t\t\t\t       bnx2x_obj_type obj_type)\n{\n\tstruct bnx2x *bp = fp->bp;\n\n\t \n\tbnx2x_init_mac_obj(bp, &bnx2x_sp_obj(bp, fp).mac_obj, fp->cl_id,\n\t\t\t   fp->cid, BP_FUNC(bp), bnx2x_sp(bp, mac_rdata),\n\t\t\t   bnx2x_sp_mapping(bp, mac_rdata),\n\t\t\t   BNX2X_FILTER_MAC_PENDING,\n\t\t\t   &bp->sp_state, obj_type,\n\t\t\t   &bp->macs_pool);\n\n\tif (!CHIP_IS_E1x(bp))\n\t\tbnx2x_init_vlan_obj(bp, &bnx2x_sp_obj(bp, fp).vlan_obj,\n\t\t\t\t    fp->cl_id, fp->cid, BP_FUNC(bp),\n\t\t\t\t    bnx2x_sp(bp, vlan_rdata),\n\t\t\t\t    bnx2x_sp_mapping(bp, vlan_rdata),\n\t\t\t\t    BNX2X_FILTER_VLAN_PENDING,\n\t\t\t\t    &bp->sp_state, obj_type,\n\t\t\t\t    &bp->vlans_pool);\n}\n\n \nstatic inline u8 bnx2x_get_path_func_num(struct bnx2x *bp)\n{\n\tu8 func_num = 0, i;\n\n\t \n\tif (CHIP_IS_E1(bp))\n\t\treturn 1;\n\n\t \n\tif (CHIP_REV_IS_SLOW(bp)) {\n\t\tif (IS_MF(bp))\n\t\t\tfunc_num = 4;\n\t\telse\n\t\t\tfunc_num = 2;\n\t} else {\n\t\tfor (i = 0; i < E1H_FUNC_MAX / 2; i++) {\n\t\t\tu32 func_config =\n\t\t\t\tMF_CFG_RD(bp,\n\t\t\t\t\t  func_mf_config[BP_PATH(bp) + 2 * i].\n\t\t\t\t\t  config);\n\t\t\tfunc_num +=\n\t\t\t\t((func_config & FUNC_MF_CFG_FUNC_HIDE) ? 0 : 1);\n\t\t}\n\t}\n\n\tWARN_ON(!func_num);\n\n\treturn func_num;\n}\n\nstatic inline void bnx2x_init_bp_objs(struct bnx2x *bp)\n{\n\t \n\tbnx2x_init_rx_mode_obj(bp, &bp->rx_mode_obj);\n\n\t \n\tbnx2x_init_mcast_obj(bp, &bp->mcast_obj, bp->fp->cl_id, bp->fp->cid,\n\t\t\t     BP_FUNC(bp), BP_FUNC(bp),\n\t\t\t     bnx2x_sp(bp, mcast_rdata),\n\t\t\t     bnx2x_sp_mapping(bp, mcast_rdata),\n\t\t\t     BNX2X_FILTER_MCAST_PENDING, &bp->sp_state,\n\t\t\t     BNX2X_OBJ_TYPE_RX);\n\n\t \n\tbnx2x_init_mac_credit_pool(bp, &bp->macs_pool, BP_FUNC(bp),\n\t\t\t\t   bnx2x_get_path_func_num(bp));\n\n\tbnx2x_init_vlan_credit_pool(bp, &bp->vlans_pool, BP_FUNC(bp),\n\t\t\t\t    bnx2x_get_path_func_num(bp));\n\n\t \n\tbnx2x_init_rss_config_obj(bp, &bp->rss_conf_obj, bp->fp->cl_id,\n\t\t\t\t  bp->fp->cid, BP_FUNC(bp), BP_FUNC(bp),\n\t\t\t\t  bnx2x_sp(bp, rss_rdata),\n\t\t\t\t  bnx2x_sp_mapping(bp, rss_rdata),\n\t\t\t\t  BNX2X_FILTER_RSS_CONF_PENDING, &bp->sp_state,\n\t\t\t\t  BNX2X_OBJ_TYPE_RX);\n\n\tbp->vlan_credit = PF_VLAN_CREDIT_E2(bp, bnx2x_get_path_func_num(bp));\n}\n\nstatic inline u8 bnx2x_fp_qzone_id(struct bnx2x_fastpath *fp)\n{\n\tif (CHIP_IS_E1x(fp->bp))\n\t\treturn fp->cl_id + BP_PORT(fp->bp) * ETH_MAX_RX_CLIENTS_E1H;\n\telse\n\t\treturn fp->cl_id;\n}\n\nstatic inline void bnx2x_init_txdata(struct bnx2x *bp,\n\t\t\t\t     struct bnx2x_fp_txdata *txdata, u32 cid,\n\t\t\t\t     int txq_index, __le16 *tx_cons_sb,\n\t\t\t\t     struct bnx2x_fastpath *fp)\n{\n\ttxdata->cid = cid;\n\ttxdata->txq_index = txq_index;\n\ttxdata->tx_cons_sb = tx_cons_sb;\n\ttxdata->parent_fp = fp;\n\ttxdata->tx_ring_size = IS_FCOE_FP(fp) ? MAX_TX_AVAIL : bp->tx_ring_size;\n\n\tDP(NETIF_MSG_IFUP, \"created tx data cid %d, txq %d\\n\",\n\t   txdata->cid, txdata->txq_index);\n}\n\nstatic inline u8 bnx2x_cnic_eth_cl_id(struct bnx2x *bp, u8 cl_idx)\n{\n\treturn bp->cnic_base_cl_id + cl_idx +\n\t\t(bp->pf_num >> 1) * BNX2X_MAX_CNIC_ETH_CL_ID_IDX;\n}\n\nstatic inline u8 bnx2x_cnic_fw_sb_id(struct bnx2x *bp)\n{\n\t \n\treturn bp->base_fw_ndsb;\n}\n\nstatic inline u8 bnx2x_cnic_igu_sb_id(struct bnx2x *bp)\n{\n\treturn bp->igu_base_sb;\n}\n\nstatic inline int bnx2x_clean_tx_queue(struct bnx2x *bp,\n\t\t\t\t       struct bnx2x_fp_txdata *txdata)\n{\n\tint cnt = 1000;\n\n\twhile (bnx2x_has_tx_work_unload(txdata)) {\n\t\tif (!cnt) {\n\t\t\tBNX2X_ERR(\"timeout waiting for queue[%d]: txdata->tx_pkt_prod(%d) != txdata->tx_pkt_cons(%d)\\n\",\n\t\t\t\t  txdata->txq_index, txdata->tx_pkt_prod,\n\t\t\t\t  txdata->tx_pkt_cons);\n#ifdef BNX2X_STOP_ON_ERROR\n\t\t\tbnx2x_panic();\n\t\t\treturn -EBUSY;\n#else\n\t\t\tbreak;\n#endif\n\t\t}\n\t\tcnt--;\n\t\tusleep_range(1000, 2000);\n\t}\n\n\treturn 0;\n}\n\nint bnx2x_get_link_cfg_idx(struct bnx2x *bp);\n\nstatic inline void __storm_memset_struct(struct bnx2x *bp,\n\t\t\t\t\t u32 addr, size_t size, u32 *data)\n{\n\tint i;\n\tfor (i = 0; i < size/4; i++)\n\t\tREG_WR(bp, addr + (i * 4), data[i]);\n}\n\n \nstatic inline bool bnx2x_wait_sp_comp(struct bnx2x *bp, unsigned long mask)\n{\n\tint tout = 5000;  \n\n\twhile (tout--) {\n\t\tsmp_mb();\n\t\tnetif_addr_lock_bh(bp->dev);\n\t\tif (!(bp->sp_state & mask)) {\n\t\t\tnetif_addr_unlock_bh(bp->dev);\n\t\t\treturn true;\n\t\t}\n\t\tnetif_addr_unlock_bh(bp->dev);\n\n\t\tusleep_range(1000, 2000);\n\t}\n\n\tsmp_mb();\n\n\tnetif_addr_lock_bh(bp->dev);\n\tif (bp->sp_state & mask) {\n\t\tBNX2X_ERR(\"Filtering completion timed out. sp_state 0x%lx, mask 0x%lx\\n\",\n\t\t\t  bp->sp_state, mask);\n\t\tnetif_addr_unlock_bh(bp->dev);\n\t\treturn false;\n\t}\n\tnetif_addr_unlock_bh(bp->dev);\n\n\treturn true;\n}\n\n \nvoid bnx2x_set_ctx_validation(struct bnx2x *bp, struct eth_context *cxt,\n\t\t\t      u32 cid);\n\nvoid bnx2x_update_coalesce_sb_index(struct bnx2x *bp, u8 fw_sb_id,\n\t\t\t\t    u8 sb_index, u8 disable, u16 usec);\nvoid bnx2x_acquire_phy_lock(struct bnx2x *bp);\nvoid bnx2x_release_phy_lock(struct bnx2x *bp);\n\n \nstatic inline u16 bnx2x_extract_max_cfg(struct bnx2x *bp, u32 mf_cfg)\n{\n\tu16 max_cfg = (mf_cfg & FUNC_MF_CFG_MAX_BW_MASK) >>\n\t\t\t      FUNC_MF_CFG_MAX_BW_SHIFT;\n\tif (!max_cfg) {\n\t\tDP(NETIF_MSG_IFUP | BNX2X_MSG_ETHTOOL,\n\t\t   \"Max BW configured to 0 - using 100 instead\\n\");\n\t\tmax_cfg = 100;\n\t}\n\treturn max_cfg;\n}\n\n \nstatic inline bool bnx2x_mtu_allows_gro(int mtu)\n{\n\t \n\tint fpp = SGE_PAGE_SIZE / (mtu - ETH_MAX_TPA_HEADER_SIZE);\n\n\t \n\treturn mtu <= SGE_PAGE_SIZE && (U_ETH_SGL_SIZE * fpp) <= MAX_SKB_FRAGS;\n}\n\n \nvoid bnx2x_get_iscsi_info(struct bnx2x *bp);\n\n \nstatic inline void bnx2x_link_sync_notify(struct bnx2x *bp)\n{\n\tint func;\n\tint vn;\n\n\t \n\tfor (vn = VN_0; vn < BP_MAX_VN_NUM(bp); vn++) {\n\t\tif (vn == BP_VN(bp))\n\t\t\tcontinue;\n\n\t\tfunc = func_by_vn(bp, vn);\n\t\tREG_WR(bp, MISC_REG_AEU_GENERAL_ATTN_0 +\n\t\t       (LINK_SYNC_ATTENTION_BIT_FUNC_0 + func)*4, 1);\n\t}\n}\n\n \nstatic inline void bnx2x_update_drv_flags(struct bnx2x *bp, u32 flags, u32 set)\n{\n\tif (SHMEM2_HAS(bp, drv_flags)) {\n\t\tu32 drv_flags;\n\t\tbnx2x_acquire_hw_lock(bp, HW_LOCK_RESOURCE_DRV_FLAGS);\n\t\tdrv_flags = SHMEM2_RD(bp, drv_flags);\n\n\t\tif (set)\n\t\t\tSET_FLAGS(drv_flags, flags);\n\t\telse\n\t\t\tRESET_FLAGS(drv_flags, flags);\n\n\t\tSHMEM2_WR(bp, drv_flags, drv_flags);\n\t\tDP(NETIF_MSG_IFUP, \"drv_flags 0x%08x\\n\", drv_flags);\n\t\tbnx2x_release_hw_lock(bp, HW_LOCK_RESOURCE_DRV_FLAGS);\n\t}\n}\n\n\n\n \nvoid bnx2x_fill_fw_str(struct bnx2x *bp, char *buf, size_t buf_len);\n\nint bnx2x_drain_tx_queues(struct bnx2x *bp);\nvoid bnx2x_squeeze_objects(struct bnx2x *bp);\n\nvoid bnx2x_schedule_sp_rtnl(struct bnx2x*, enum sp_rtnl_flag,\n\t\t\t    u32 verbose);\n\n \nvoid bnx2x_set_os_driver_state(struct bnx2x *bp, u32 state);\n\n \nint bnx2x_nvram_read(struct bnx2x *bp, u32 offset, u8 *ret_buf,\n\t\t     int buf_size);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}