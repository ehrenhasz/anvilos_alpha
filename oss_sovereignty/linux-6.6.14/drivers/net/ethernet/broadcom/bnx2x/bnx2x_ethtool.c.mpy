{
  "module_name": "bnx2x_ethtool.c",
  "hash_id": "d2ed80510a3bc6facd2c885b3d8a7ea5ef5d0ed6e92398ac3cc2db8740b4e540",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/broadcom/bnx2x/bnx2x_ethtool.c",
  "human_readable_source": " \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/ethtool.h>\n#include <linux/netdevice.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/crc32.h>\n#include \"bnx2x.h\"\n#include \"bnx2x_cmn.h\"\n#include \"bnx2x_dump.h\"\n#include \"bnx2x_init.h\"\n\n \n#define MAX_QUEUE_NAME_LEN\t4\nstatic const struct {\n\tlong offset;\n\tint size;\n\tchar string[ETH_GSTRING_LEN];\n} bnx2x_q_stats_arr[] = {\n \t{ Q_STATS_OFFSET32(total_bytes_received_hi), 8, \"[%s]: rx_bytes\" },\n\t{ Q_STATS_OFFSET32(total_unicast_packets_received_hi),\n\t\t\t\t\t\t8, \"[%s]: rx_ucast_packets\" },\n\t{ Q_STATS_OFFSET32(total_multicast_packets_received_hi),\n\t\t\t\t\t\t8, \"[%s]: rx_mcast_packets\" },\n\t{ Q_STATS_OFFSET32(total_broadcast_packets_received_hi),\n\t\t\t\t\t\t8, \"[%s]: rx_bcast_packets\" },\n\t{ Q_STATS_OFFSET32(no_buff_discard_hi),\t8, \"[%s]: rx_discards\" },\n\t{ Q_STATS_OFFSET32(rx_err_discard_pkt),\n\t\t\t\t\t 4, \"[%s]: rx_phy_ip_err_discards\"},\n\t{ Q_STATS_OFFSET32(rx_skb_alloc_failed),\n\t\t\t\t\t 4, \"[%s]: rx_skb_alloc_discard\" },\n\t{ Q_STATS_OFFSET32(hw_csum_err), 4, \"[%s]: rx_csum_offload_errors\" },\n\t{ Q_STATS_OFFSET32(driver_xoff), 4, \"[%s]: tx_exhaustion_events\" },\n\t{ Q_STATS_OFFSET32(total_bytes_transmitted_hi),\t8, \"[%s]: tx_bytes\" },\n { Q_STATS_OFFSET32(total_unicast_packets_transmitted_hi),\n\t\t\t\t\t\t8, \"[%s]: tx_ucast_packets\" },\n\t{ Q_STATS_OFFSET32(total_multicast_packets_transmitted_hi),\n\t\t\t\t\t\t8, \"[%s]: tx_mcast_packets\" },\n\t{ Q_STATS_OFFSET32(total_broadcast_packets_transmitted_hi),\n\t\t\t\t\t\t8, \"[%s]: tx_bcast_packets\" },\n\t{ Q_STATS_OFFSET32(total_tpa_aggregations_hi),\n\t\t\t\t\t\t8, \"[%s]: tpa_aggregations\" },\n\t{ Q_STATS_OFFSET32(total_tpa_aggregated_frames_hi),\n\t\t\t\t\t8, \"[%s]: tpa_aggregated_frames\"},\n\t{ Q_STATS_OFFSET32(total_tpa_bytes_hi),\t8, \"[%s]: tpa_bytes\"},\n\t{ Q_STATS_OFFSET32(driver_filtered_tx_pkt),\n\t\t\t\t\t4, \"[%s]: driver_filtered_tx_pkt\" }\n};\n\n#define BNX2X_NUM_Q_STATS ARRAY_SIZE(bnx2x_q_stats_arr)\n\nstatic const struct {\n\tlong offset;\n\tint size;\n\tbool is_port_stat;\n\tchar string[ETH_GSTRING_LEN];\n} bnx2x_stats_arr[] = {\n \t{ STATS_OFFSET32(total_bytes_received_hi),\n\t\t\t\t8, false, \"rx_bytes\" },\n\t{ STATS_OFFSET32(error_bytes_received_hi),\n\t\t\t\t8, false, \"rx_error_bytes\" },\n\t{ STATS_OFFSET32(total_unicast_packets_received_hi),\n\t\t\t\t8, false, \"rx_ucast_packets\" },\n\t{ STATS_OFFSET32(total_multicast_packets_received_hi),\n\t\t\t\t8, false, \"rx_mcast_packets\" },\n\t{ STATS_OFFSET32(total_broadcast_packets_received_hi),\n\t\t\t\t8, false, \"rx_bcast_packets\" },\n\t{ STATS_OFFSET32(rx_stat_dot3statsfcserrors_hi),\n\t\t\t\t8, true, \"rx_crc_errors\" },\n\t{ STATS_OFFSET32(rx_stat_dot3statsalignmenterrors_hi),\n\t\t\t\t8, true, \"rx_align_errors\" },\n\t{ STATS_OFFSET32(rx_stat_etherstatsundersizepkts_hi),\n\t\t\t\t8, true, \"rx_undersize_packets\" },\n\t{ STATS_OFFSET32(etherstatsoverrsizepkts_hi),\n\t\t\t\t8, true, \"rx_oversize_packets\" },\n { STATS_OFFSET32(rx_stat_etherstatsfragments_hi),\n\t\t\t\t8, true, \"rx_fragments\" },\n\t{ STATS_OFFSET32(rx_stat_etherstatsjabbers_hi),\n\t\t\t\t8, true, \"rx_jabbers\" },\n\t{ STATS_OFFSET32(no_buff_discard_hi),\n\t\t\t\t8, false, \"rx_discards\" },\n\t{ STATS_OFFSET32(mac_filter_discard),\n\t\t\t\t4, true, \"rx_filtered_packets\" },\n\t{ STATS_OFFSET32(mf_tag_discard),\n\t\t\t\t4, true, \"rx_mf_tag_discard\" },\n\t{ STATS_OFFSET32(pfc_frames_received_hi),\n\t\t\t\t8, true, \"pfc_frames_received\" },\n\t{ STATS_OFFSET32(pfc_frames_sent_hi),\n\t\t\t\t8, true, \"pfc_frames_sent\" },\n\t{ STATS_OFFSET32(brb_drop_hi),\n\t\t\t\t8, true, \"rx_brb_discard\" },\n\t{ STATS_OFFSET32(brb_truncate_hi),\n\t\t\t\t8, true, \"rx_brb_truncate\" },\n\t{ STATS_OFFSET32(pause_frames_received_hi),\n\t\t\t\t8, true, \"rx_pause_frames\" },\n\t{ STATS_OFFSET32(rx_stat_maccontrolframesreceived_hi),\n\t\t\t\t8, true, \"rx_mac_ctrl_frames\" },\n\t{ STATS_OFFSET32(nig_timer_max),\n\t\t\t\t4, true, \"rx_constant_pause_events\" },\n { STATS_OFFSET32(rx_err_discard_pkt),\n\t\t\t\t4, false, \"rx_phy_ip_err_discards\"},\n\t{ STATS_OFFSET32(rx_skb_alloc_failed),\n\t\t\t\t4, false, \"rx_skb_alloc_discard\" },\n\t{ STATS_OFFSET32(hw_csum_err),\n\t\t\t\t4, false, \"rx_csum_offload_errors\" },\n\t{ STATS_OFFSET32(driver_xoff),\n\t\t\t\t4, false, \"tx_exhaustion_events\" },\n\t{ STATS_OFFSET32(total_bytes_transmitted_hi),\n\t\t\t\t8, false, \"tx_bytes\" },\n\t{ STATS_OFFSET32(tx_stat_ifhcoutbadoctets_hi),\n\t\t\t\t8, true, \"tx_error_bytes\" },\n\t{ STATS_OFFSET32(total_unicast_packets_transmitted_hi),\n\t\t\t\t8, false, \"tx_ucast_packets\" },\n\t{ STATS_OFFSET32(total_multicast_packets_transmitted_hi),\n\t\t\t\t8, false, \"tx_mcast_packets\" },\n\t{ STATS_OFFSET32(total_broadcast_packets_transmitted_hi),\n\t\t\t\t8, false, \"tx_bcast_packets\" },\n\t{ STATS_OFFSET32(tx_stat_dot3statsinternalmactransmiterrors_hi),\n\t\t\t\t8, true, \"tx_mac_errors\" },\n\t{ STATS_OFFSET32(rx_stat_dot3statscarriersenseerrors_hi),\n\t\t\t\t8, true, \"tx_carrier_errors\" },\n { STATS_OFFSET32(tx_stat_dot3statssinglecollisionframes_hi),\n\t\t\t\t8, true, \"tx_single_collisions\" },\n\t{ STATS_OFFSET32(tx_stat_dot3statsmultiplecollisionframes_hi),\n\t\t\t\t8, true, \"tx_multi_collisions\" },\n\t{ STATS_OFFSET32(tx_stat_dot3statsdeferredtransmissions_hi),\n\t\t\t\t8, true, \"tx_deferred\" },\n\t{ STATS_OFFSET32(tx_stat_dot3statsexcessivecollisions_hi),\n\t\t\t\t8, true, \"tx_excess_collisions\" },\n\t{ STATS_OFFSET32(tx_stat_dot3statslatecollisions_hi),\n\t\t\t\t8, true, \"tx_late_collisions\" },\n\t{ STATS_OFFSET32(tx_stat_etherstatscollisions_hi),\n\t\t\t\t8, true, \"tx_total_collisions\" },\n\t{ STATS_OFFSET32(tx_stat_etherstatspkts64octets_hi),\n\t\t\t\t8, true, \"tx_64_byte_packets\" },\n\t{ STATS_OFFSET32(tx_stat_etherstatspkts65octetsto127octets_hi),\n\t\t\t\t8, true, \"tx_65_to_127_byte_packets\" },\n\t{ STATS_OFFSET32(tx_stat_etherstatspkts128octetsto255octets_hi),\n\t\t\t\t8, true, \"tx_128_to_255_byte_packets\" },\n\t{ STATS_OFFSET32(tx_stat_etherstatspkts256octetsto511octets_hi),\n\t\t\t\t8, true, \"tx_256_to_511_byte_packets\" },\n { STATS_OFFSET32(tx_stat_etherstatspkts512octetsto1023octets_hi),\n\t\t\t\t8, true, \"tx_512_to_1023_byte_packets\" },\n\t{ STATS_OFFSET32(etherstatspkts1024octetsto1522octets_hi),\n\t\t\t\t8, true, \"tx_1024_to_1522_byte_packets\" },\n\t{ STATS_OFFSET32(etherstatspktsover1522octets_hi),\n\t\t\t\t8, true, \"tx_1523_to_9022_byte_packets\" },\n\t{ STATS_OFFSET32(pause_frames_sent_hi),\n\t\t\t\t8, true, \"tx_pause_frames\" },\n\t{ STATS_OFFSET32(total_tpa_aggregations_hi),\n\t\t\t\t8, false, \"tpa_aggregations\" },\n\t{ STATS_OFFSET32(total_tpa_aggregated_frames_hi),\n\t\t\t\t8, false, \"tpa_aggregated_frames\"},\n\t{ STATS_OFFSET32(total_tpa_bytes_hi),\n\t\t\t\t8, false, \"tpa_bytes\"},\n\t{ STATS_OFFSET32(recoverable_error),\n\t\t\t\t4, false, \"recoverable_errors\" },\n\t{ STATS_OFFSET32(unrecoverable_error),\n\t\t\t\t4, false, \"unrecoverable_errors\" },\n\t{ STATS_OFFSET32(driver_filtered_tx_pkt),\n\t\t\t\t4, false, \"driver_filtered_tx_pkt\" },\n\t{ STATS_OFFSET32(eee_tx_lpi),\n\t\t\t\t4, true, \"Tx LPI entry count\"},\n\t{ STATS_OFFSET32(ptp_skip_tx_ts),\n\t\t\t\t4, false, \"ptp_skipped_tx_tstamp\" },\n};\n\n#define BNX2X_NUM_STATS\t\tARRAY_SIZE(bnx2x_stats_arr)\n\nstatic int bnx2x_get_port_type(struct bnx2x *bp)\n{\n\tint port_type;\n\tu32 phy_idx = bnx2x_get_cur_phy_idx(bp);\n\tswitch (bp->link_params.phy[phy_idx].media_type) {\n\tcase ETH_PHY_SFPP_10G_FIBER:\n\tcase ETH_PHY_SFP_1G_FIBER:\n\tcase ETH_PHY_XFP_FIBER:\n\tcase ETH_PHY_KR:\n\tcase ETH_PHY_CX4:\n\t\tport_type = PORT_FIBRE;\n\t\tbreak;\n\tcase ETH_PHY_DA_TWINAX:\n\t\tport_type = PORT_DA;\n\t\tbreak;\n\tcase ETH_PHY_BASE_T:\n\t\tport_type = PORT_TP;\n\t\tbreak;\n\tcase ETH_PHY_NOT_PRESENT:\n\t\tport_type = PORT_NONE;\n\t\tbreak;\n\tcase ETH_PHY_UNSPECIFIED:\n\tdefault:\n\t\tport_type = PORT_OTHER;\n\t\tbreak;\n\t}\n\treturn port_type;\n}\n\nstatic int bnx2x_get_vf_link_ksettings(struct net_device *dev,\n\t\t\t\t       struct ethtool_link_ksettings *cmd)\n{\n\tstruct bnx2x *bp = netdev_priv(dev);\n\tu32 supported, advertising;\n\n\tethtool_convert_link_mode_to_legacy_u32(&supported,\n\t\t\t\t\t\tcmd->link_modes.supported);\n\tethtool_convert_link_mode_to_legacy_u32(&advertising,\n\t\t\t\t\t\tcmd->link_modes.advertising);\n\n\tif (bp->state == BNX2X_STATE_OPEN) {\n\t\tif (test_bit(BNX2X_LINK_REPORT_FD,\n\t\t\t     &bp->vf_link_vars.link_report_flags))\n\t\t\tcmd->base.duplex = DUPLEX_FULL;\n\t\telse\n\t\t\tcmd->base.duplex = DUPLEX_HALF;\n\n\t\tcmd->base.speed = bp->vf_link_vars.line_speed;\n\t} else {\n\t\tcmd->base.duplex = DUPLEX_UNKNOWN;\n\t\tcmd->base.speed = SPEED_UNKNOWN;\n\t}\n\n\tcmd->base.port\t\t= PORT_OTHER;\n\tcmd->base.phy_address\t= 0;\n\tcmd->base.autoneg\t= AUTONEG_DISABLE;\n\n\tDP(BNX2X_MSG_ETHTOOL, \"ethtool_cmd: cmd %d\\n\"\n\t   \"  supported 0x%x  advertising 0x%x  speed %u\\n\"\n\t   \"  duplex %d  port %d  phy_address %d\\n\"\n\t   \"  autoneg %d\\n\",\n\t   cmd->base.cmd, supported, advertising,\n\t   cmd->base.speed,\n\t   cmd->base.duplex, cmd->base.port, cmd->base.phy_address,\n\t   cmd->base.autoneg);\n\n\treturn 0;\n}\n\nstatic int bnx2x_get_link_ksettings(struct net_device *dev,\n\t\t\t\t    struct ethtool_link_ksettings *cmd)\n{\n\tstruct bnx2x *bp = netdev_priv(dev);\n\tint cfg_idx = bnx2x_get_link_cfg_idx(bp);\n\tu32 media_type;\n\tu32 supported, advertising, lp_advertising;\n\n\tethtool_convert_link_mode_to_legacy_u32(&lp_advertising,\n\t\t\t\t\t\tcmd->link_modes.lp_advertising);\n\n\t \n\tsupported = bp->port.supported[cfg_idx] |\n\t\t(bp->port.supported[cfg_idx ^ 1] &\n\t\t (SUPPORTED_TP | SUPPORTED_FIBRE));\n\tadvertising = bp->port.advertising[cfg_idx];\n\tmedia_type = bp->link_params.phy[bnx2x_get_cur_phy_idx(bp)].media_type;\n\tif (media_type == ETH_PHY_SFP_1G_FIBER) {\n\t\tsupported &= ~(SUPPORTED_10000baseT_Full);\n\t\tadvertising &= ~(ADVERTISED_10000baseT_Full);\n\t}\n\n\tif ((bp->state == BNX2X_STATE_OPEN) && bp->link_vars.link_up &&\n\t    !(bp->flags & MF_FUNC_DIS)) {\n\t\tcmd->base.duplex = bp->link_vars.duplex;\n\n\t\tif (IS_MF(bp) && !BP_NOMCP(bp))\n\t\t\tcmd->base.speed = bnx2x_get_mf_speed(bp);\n\t\telse\n\t\t\tcmd->base.speed = bp->link_vars.line_speed;\n\t} else {\n\t\tcmd->base.duplex = DUPLEX_UNKNOWN;\n\t\tcmd->base.speed = SPEED_UNKNOWN;\n\t}\n\n\tcmd->base.port = bnx2x_get_port_type(bp);\n\n\tcmd->base.phy_address = bp->mdio.prtad;\n\n\tif (bp->link_params.req_line_speed[cfg_idx] == SPEED_AUTO_NEG)\n\t\tcmd->base.autoneg = AUTONEG_ENABLE;\n\telse\n\t\tcmd->base.autoneg = AUTONEG_DISABLE;\n\n\t \n\tif (bp->link_vars.link_status & LINK_STATUS_AUTO_NEGOTIATE_COMPLETE) {\n\t\tu32 status = bp->link_vars.link_status;\n\n\t\tlp_advertising |= ADVERTISED_Autoneg;\n\t\tif (status & LINK_STATUS_LINK_PARTNER_SYMMETRIC_PAUSE)\n\t\t\tlp_advertising |= ADVERTISED_Pause;\n\t\tif (status & LINK_STATUS_LINK_PARTNER_ASYMMETRIC_PAUSE)\n\t\t\tlp_advertising |= ADVERTISED_Asym_Pause;\n\n\t\tif (status & LINK_STATUS_LINK_PARTNER_10THD_CAPABLE)\n\t\t\tlp_advertising |= ADVERTISED_10baseT_Half;\n\t\tif (status & LINK_STATUS_LINK_PARTNER_10TFD_CAPABLE)\n\t\t\tlp_advertising |= ADVERTISED_10baseT_Full;\n\t\tif (status & LINK_STATUS_LINK_PARTNER_100TXHD_CAPABLE)\n\t\t\tlp_advertising |= ADVERTISED_100baseT_Half;\n\t\tif (status & LINK_STATUS_LINK_PARTNER_100TXFD_CAPABLE)\n\t\t\tlp_advertising |= ADVERTISED_100baseT_Full;\n\t\tif (status & LINK_STATUS_LINK_PARTNER_1000THD_CAPABLE)\n\t\t\tlp_advertising |= ADVERTISED_1000baseT_Half;\n\t\tif (status & LINK_STATUS_LINK_PARTNER_1000TFD_CAPABLE) {\n\t\t\tif (media_type == ETH_PHY_KR) {\n\t\t\t\tlp_advertising |=\n\t\t\t\t\tADVERTISED_1000baseKX_Full;\n\t\t\t} else {\n\t\t\t\tlp_advertising |=\n\t\t\t\t\tADVERTISED_1000baseT_Full;\n\t\t\t}\n\t\t}\n\t\tif (status & LINK_STATUS_LINK_PARTNER_2500XFD_CAPABLE)\n\t\t\tlp_advertising |= ADVERTISED_2500baseX_Full;\n\t\tif (status & LINK_STATUS_LINK_PARTNER_10GXFD_CAPABLE) {\n\t\t\tif (media_type == ETH_PHY_KR) {\n\t\t\t\tlp_advertising |=\n\t\t\t\t\tADVERTISED_10000baseKR_Full;\n\t\t\t} else {\n\t\t\t\tlp_advertising |=\n\t\t\t\t\tADVERTISED_10000baseT_Full;\n\t\t\t}\n\t\t}\n\t\tif (status & LINK_STATUS_LINK_PARTNER_20GXFD_CAPABLE)\n\t\t\tlp_advertising |= ADVERTISED_20000baseKR2_Full;\n\t}\n\n\tethtool_convert_legacy_u32_to_link_mode(cmd->link_modes.supported,\n\t\t\t\t\t\tsupported);\n\tethtool_convert_legacy_u32_to_link_mode(cmd->link_modes.advertising,\n\t\t\t\t\t\tadvertising);\n\tethtool_convert_legacy_u32_to_link_mode(cmd->link_modes.lp_advertising,\n\t\t\t\t\t\tlp_advertising);\n\n\tDP(BNX2X_MSG_ETHTOOL, \"ethtool_cmd: cmd %d\\n\"\n\t   \"  supported 0x%x  advertising 0x%x  speed %u\\n\"\n\t   \"  duplex %d  port %d  phy_address %d\\n\"\n\t   \"  autoneg %d\\n\",\n\t   cmd->base.cmd, supported, advertising,\n\t   cmd->base.speed,\n\t   cmd->base.duplex, cmd->base.port, cmd->base.phy_address,\n\t   cmd->base.autoneg);\n\n\treturn 0;\n}\n\nstatic int bnx2x_set_link_ksettings(struct net_device *dev,\n\t\t\t\t    const struct ethtool_link_ksettings *cmd)\n{\n\tstruct bnx2x *bp = netdev_priv(dev);\n\tu32 advertising, cfg_idx, old_multi_phy_config, new_multi_phy_config;\n\tu32 speed, phy_idx;\n\tu32 supported;\n\tu8 duplex = cmd->base.duplex;\n\n\tethtool_convert_link_mode_to_legacy_u32(&supported,\n\t\t\t\t\t\tcmd->link_modes.supported);\n\tethtool_convert_link_mode_to_legacy_u32(&advertising,\n\t\t\t\t\t\tcmd->link_modes.advertising);\n\n\tif (IS_MF_SD(bp))\n\t\treturn 0;\n\n\tDP(BNX2X_MSG_ETHTOOL, \"ethtool_cmd: cmd %d\\n\"\n\t   \"  supported 0x%x  advertising 0x%x  speed %u\\n\"\n\t   \"  duplex %d  port %d  phy_address %d\\n\"\n\t   \"  autoneg %d\\n\",\n\t   cmd->base.cmd, supported, advertising,\n\t   cmd->base.speed,\n\t   cmd->base.duplex, cmd->base.port, cmd->base.phy_address,\n\t   cmd->base.autoneg);\n\n\tspeed = cmd->base.speed;\n\n\t \n\tif (duplex == DUPLEX_UNKNOWN)\n\t\tduplex = DUPLEX_FULL;\n\n\tif (IS_MF_SI(bp)) {\n\t\tu32 part;\n\t\tu32 line_speed = bp->link_vars.line_speed;\n\n\t\t \n\t\tif (!line_speed)\n\t\t\tline_speed = 10000;\n\n\t\tif (bp->common.bc_ver < REQ_BC_VER_4_SET_MF_BW) {\n\t\t\tDP(BNX2X_MSG_ETHTOOL,\n\t\t\t   \"To set speed BC %X or higher is required, please upgrade BC\\n\",\n\t\t\t   REQ_BC_VER_4_SET_MF_BW);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tpart = (speed * 100) / line_speed;\n\n\t\tif (line_speed < speed || !part) {\n\t\t\tDP(BNX2X_MSG_ETHTOOL,\n\t\t\t   \"Speed setting should be in a range from 1%% to 100%% of actual line speed\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (bp->state != BNX2X_STATE_OPEN)\n\t\t\t \n\t\t\tbp->pending_max = part;\n\t\telse\n\t\t\tbnx2x_update_max_mf_config(bp, part);\n\n\t\treturn 0;\n\t}\n\n\tcfg_idx = bnx2x_get_link_cfg_idx(bp);\n\told_multi_phy_config = bp->link_params.multi_phy_config;\n\tif (cmd->base.port != bnx2x_get_port_type(bp)) {\n\t\tswitch (cmd->base.port) {\n\t\tcase PORT_TP:\n\t\t\tif (!(bp->port.supported[0] & SUPPORTED_TP ||\n\t\t\t      bp->port.supported[1] & SUPPORTED_TP)) {\n\t\t\t\tDP(BNX2X_MSG_ETHTOOL,\n\t\t\t\t   \"Unsupported port type\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tbp->link_params.multi_phy_config &=\n\t\t\t\t~PORT_HW_CFG_PHY_SELECTION_MASK;\n\t\t\tif (bp->link_params.multi_phy_config &\n\t\t\t    PORT_HW_CFG_PHY_SWAPPED_ENABLED)\n\t\t\t\tbp->link_params.multi_phy_config |=\n\t\t\t\tPORT_HW_CFG_PHY_SELECTION_SECOND_PHY;\n\t\t\telse\n\t\t\t\tbp->link_params.multi_phy_config |=\n\t\t\t\tPORT_HW_CFG_PHY_SELECTION_FIRST_PHY;\n\t\t\tbreak;\n\t\tcase PORT_FIBRE:\n\t\tcase PORT_DA:\n\t\tcase PORT_NONE:\n\t\t\tif (!(bp->port.supported[0] & SUPPORTED_FIBRE ||\n\t\t\t      bp->port.supported[1] & SUPPORTED_FIBRE)) {\n\t\t\t\tDP(BNX2X_MSG_ETHTOOL,\n\t\t\t\t   \"Unsupported port type\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tbp->link_params.multi_phy_config &=\n\t\t\t\t~PORT_HW_CFG_PHY_SELECTION_MASK;\n\t\t\tif (bp->link_params.multi_phy_config &\n\t\t\t    PORT_HW_CFG_PHY_SWAPPED_ENABLED)\n\t\t\t\tbp->link_params.multi_phy_config |=\n\t\t\t\tPORT_HW_CFG_PHY_SELECTION_FIRST_PHY;\n\t\t\telse\n\t\t\t\tbp->link_params.multi_phy_config |=\n\t\t\t\tPORT_HW_CFG_PHY_SELECTION_SECOND_PHY;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDP(BNX2X_MSG_ETHTOOL, \"Unsupported port type\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\t \n\tnew_multi_phy_config = bp->link_params.multi_phy_config;\n\t \n\tcfg_idx = bnx2x_get_link_cfg_idx(bp);\n\t \n\tbp->link_params.multi_phy_config = old_multi_phy_config;\n\tDP(BNX2X_MSG_ETHTOOL, \"cfg_idx = %x\\n\", cfg_idx);\n\n\tif (cmd->base.autoneg == AUTONEG_ENABLE) {\n\t\tu32 an_supported_speed = bp->port.supported[cfg_idx];\n\t\tif (bp->link_params.phy[EXT_PHY1].type ==\n\t\t    PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84833)\n\t\t\tan_supported_speed |= (SUPPORTED_100baseT_Half |\n\t\t\t\t\t       SUPPORTED_100baseT_Full);\n\t\tif (!(bp->port.supported[cfg_idx] & SUPPORTED_Autoneg)) {\n\t\t\tDP(BNX2X_MSG_ETHTOOL, \"Autoneg not supported\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tif (advertising & ~an_supported_speed) {\n\t\t\tDP(BNX2X_MSG_ETHTOOL,\n\t\t\t   \"Advertisement parameters are not supported\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tbp->link_params.req_line_speed[cfg_idx] = SPEED_AUTO_NEG;\n\t\tbp->link_params.req_duplex[cfg_idx] = duplex;\n\t\tbp->port.advertising[cfg_idx] = (ADVERTISED_Autoneg |\n\t\t\t\t\t advertising);\n\t\tif (advertising) {\n\n\t\t\tbp->link_params.speed_cap_mask[cfg_idx] = 0;\n\t\t\tif (advertising & ADVERTISED_10baseT_Half) {\n\t\t\t\tbp->link_params.speed_cap_mask[cfg_idx] |=\n\t\t\t\tPORT_HW_CFG_SPEED_CAPABILITY_D0_10M_HALF;\n\t\t\t}\n\t\t\tif (advertising & ADVERTISED_10baseT_Full)\n\t\t\t\tbp->link_params.speed_cap_mask[cfg_idx] |=\n\t\t\t\tPORT_HW_CFG_SPEED_CAPABILITY_D0_10M_FULL;\n\n\t\t\tif (advertising & ADVERTISED_100baseT_Full)\n\t\t\t\tbp->link_params.speed_cap_mask[cfg_idx] |=\n\t\t\t\tPORT_HW_CFG_SPEED_CAPABILITY_D0_100M_FULL;\n\n\t\t\tif (advertising & ADVERTISED_100baseT_Half) {\n\t\t\t\tbp->link_params.speed_cap_mask[cfg_idx] |=\n\t\t\t\t     PORT_HW_CFG_SPEED_CAPABILITY_D0_100M_HALF;\n\t\t\t}\n\t\t\tif (advertising & ADVERTISED_1000baseT_Half) {\n\t\t\t\tbp->link_params.speed_cap_mask[cfg_idx] |=\n\t\t\t\t\tPORT_HW_CFG_SPEED_CAPABILITY_D0_1G;\n\t\t\t}\n\t\t\tif (advertising & (ADVERTISED_1000baseT_Full |\n\t\t\t\t\t\tADVERTISED_1000baseKX_Full))\n\t\t\t\tbp->link_params.speed_cap_mask[cfg_idx] |=\n\t\t\t\t\tPORT_HW_CFG_SPEED_CAPABILITY_D0_1G;\n\n\t\t\tif (advertising & (ADVERTISED_10000baseT_Full |\n\t\t\t\t\t\tADVERTISED_10000baseKX4_Full |\n\t\t\t\t\t\tADVERTISED_10000baseKR_Full))\n\t\t\t\tbp->link_params.speed_cap_mask[cfg_idx] |=\n\t\t\t\t\tPORT_HW_CFG_SPEED_CAPABILITY_D0_10G;\n\n\t\t\tif (advertising & ADVERTISED_20000baseKR2_Full)\n\t\t\t\tbp->link_params.speed_cap_mask[cfg_idx] |=\n\t\t\t\t\tPORT_HW_CFG_SPEED_CAPABILITY_D0_20G;\n\t\t}\n\t} else {  \n\t\t \n\t\tswitch (speed) {\n\t\tcase SPEED_10:\n\t\t\tif (duplex == DUPLEX_FULL) {\n\t\t\t\tif (!(bp->port.supported[cfg_idx] &\n\t\t\t\t      SUPPORTED_10baseT_Full)) {\n\t\t\t\t\tDP(BNX2X_MSG_ETHTOOL,\n\t\t\t\t\t   \"10M full not supported\\n\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\n\t\t\t\tadvertising = (ADVERTISED_10baseT_Full |\n\t\t\t\t\t       ADVERTISED_TP);\n\t\t\t} else {\n\t\t\t\tif (!(bp->port.supported[cfg_idx] &\n\t\t\t\t      SUPPORTED_10baseT_Half)) {\n\t\t\t\t\tDP(BNX2X_MSG_ETHTOOL,\n\t\t\t\t\t   \"10M half not supported\\n\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\n\t\t\t\tadvertising = (ADVERTISED_10baseT_Half |\n\t\t\t\t\t       ADVERTISED_TP);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase SPEED_100:\n\t\t\tif (duplex == DUPLEX_FULL) {\n\t\t\t\tif (!(bp->port.supported[cfg_idx] &\n\t\t\t\t\t\tSUPPORTED_100baseT_Full)) {\n\t\t\t\t\tDP(BNX2X_MSG_ETHTOOL,\n\t\t\t\t\t   \"100M full not supported\\n\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\n\t\t\t\tadvertising = (ADVERTISED_100baseT_Full |\n\t\t\t\t\t       ADVERTISED_TP);\n\t\t\t} else {\n\t\t\t\tif (!(bp->port.supported[cfg_idx] &\n\t\t\t\t\t\tSUPPORTED_100baseT_Half)) {\n\t\t\t\t\tDP(BNX2X_MSG_ETHTOOL,\n\t\t\t\t\t   \"100M half not supported\\n\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\n\t\t\t\tadvertising = (ADVERTISED_100baseT_Half |\n\t\t\t\t\t       ADVERTISED_TP);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase SPEED_1000:\n\t\t\tif (duplex != DUPLEX_FULL) {\n\t\t\t\tDP(BNX2X_MSG_ETHTOOL,\n\t\t\t\t   \"1G half not supported\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tif (bp->port.supported[cfg_idx] &\n\t\t\t     SUPPORTED_1000baseT_Full) {\n\t\t\t\tadvertising = (ADVERTISED_1000baseT_Full |\n\t\t\t\t\t       ADVERTISED_TP);\n\n\t\t\t} else if (bp->port.supported[cfg_idx] &\n\t\t\t\t   SUPPORTED_1000baseKX_Full) {\n\t\t\t\tadvertising = ADVERTISED_1000baseKX_Full;\n\t\t\t} else {\n\t\t\t\tDP(BNX2X_MSG_ETHTOOL,\n\t\t\t\t   \"1G full not supported\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase SPEED_2500:\n\t\t\tif (duplex != DUPLEX_FULL) {\n\t\t\t\tDP(BNX2X_MSG_ETHTOOL,\n\t\t\t\t   \"2.5G half not supported\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tif (!(bp->port.supported[cfg_idx]\n\t\t\t      & SUPPORTED_2500baseX_Full)) {\n\t\t\t\tDP(BNX2X_MSG_ETHTOOL,\n\t\t\t\t   \"2.5G full not supported\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tadvertising = (ADVERTISED_2500baseX_Full |\n\t\t\t\t       ADVERTISED_TP);\n\t\t\tbreak;\n\n\t\tcase SPEED_10000:\n\t\t\tif (duplex != DUPLEX_FULL) {\n\t\t\t\tDP(BNX2X_MSG_ETHTOOL,\n\t\t\t\t   \"10G half not supported\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tphy_idx = bnx2x_get_cur_phy_idx(bp);\n\t\t\tif ((bp->port.supported[cfg_idx] &\n\t\t\t     SUPPORTED_10000baseT_Full) &&\n\t\t\t    (bp->link_params.phy[phy_idx].media_type !=\n\t\t\t     ETH_PHY_SFP_1G_FIBER)) {\n\t\t\t\tadvertising = (ADVERTISED_10000baseT_Full |\n\t\t\t\t\t       ADVERTISED_FIBRE);\n\t\t\t} else if (bp->port.supported[cfg_idx] &\n\t\t\t       SUPPORTED_10000baseKR_Full) {\n\t\t\t\tadvertising = (ADVERTISED_10000baseKR_Full |\n\t\t\t\t\t       ADVERTISED_FIBRE);\n\t\t\t} else {\n\t\t\t\tDP(BNX2X_MSG_ETHTOOL,\n\t\t\t\t   \"10G full not supported\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tDP(BNX2X_MSG_ETHTOOL, \"Unsupported speed %u\\n\", speed);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tbp->link_params.req_line_speed[cfg_idx] = speed;\n\t\tbp->link_params.req_duplex[cfg_idx] = duplex;\n\t\tbp->port.advertising[cfg_idx] = advertising;\n\t}\n\n\tDP(BNX2X_MSG_ETHTOOL, \"req_line_speed %d\\n\"\n\t   \"  req_duplex %d  advertising 0x%x\\n\",\n\t   bp->link_params.req_line_speed[cfg_idx],\n\t   bp->link_params.req_duplex[cfg_idx],\n\t   bp->port.advertising[cfg_idx]);\n\n\t \n\tbp->link_params.multi_phy_config = new_multi_phy_config;\n\tif (netif_running(dev)) {\n\t\tbnx2x_stats_handle(bp, STATS_EVENT_STOP);\n\t\tbnx2x_force_link_reset(bp);\n\t\tbnx2x_link_set(bp);\n\t}\n\n\treturn 0;\n}\n\n#define DUMP_ALL_PRESETS\t\t0x1FFF\n#define DUMP_MAX_PRESETS\t\t13\n\nstatic int __bnx2x_get_preset_regs_len(struct bnx2x *bp, u32 preset)\n{\n\tif (CHIP_IS_E1(bp))\n\t\treturn dump_num_registers[0][preset-1];\n\telse if (CHIP_IS_E1H(bp))\n\t\treturn dump_num_registers[1][preset-1];\n\telse if (CHIP_IS_E2(bp))\n\t\treturn dump_num_registers[2][preset-1];\n\telse if (CHIP_IS_E3A0(bp))\n\t\treturn dump_num_registers[3][preset-1];\n\telse if (CHIP_IS_E3B0(bp))\n\t\treturn dump_num_registers[4][preset-1];\n\telse\n\t\treturn 0;\n}\n\nstatic int __bnx2x_get_regs_len(struct bnx2x *bp)\n{\n\tu32 preset_idx;\n\tint regdump_len = 0;\n\n\t \n\tfor (preset_idx = 1; preset_idx <= DUMP_MAX_PRESETS; preset_idx++)\n\t\tregdump_len += __bnx2x_get_preset_regs_len(bp, preset_idx);\n\n\treturn regdump_len;\n}\n\nstatic int bnx2x_get_regs_len(struct net_device *dev)\n{\n\tstruct bnx2x *bp = netdev_priv(dev);\n\tint regdump_len = 0;\n\n\tif (IS_VF(bp))\n\t\treturn 0;\n\n\tregdump_len = __bnx2x_get_regs_len(bp);\n\tregdump_len *= 4;\n\tregdump_len += sizeof(struct dump_header);\n\n\treturn regdump_len;\n}\n\n#define IS_E1_REG(chips)\t((chips & DUMP_CHIP_E1) == DUMP_CHIP_E1)\n#define IS_E1H_REG(chips)\t((chips & DUMP_CHIP_E1H) == DUMP_CHIP_E1H)\n#define IS_E2_REG(chips)\t((chips & DUMP_CHIP_E2) == DUMP_CHIP_E2)\n#define IS_E3A0_REG(chips)\t((chips & DUMP_CHIP_E3A0) == DUMP_CHIP_E3A0)\n#define IS_E3B0_REG(chips)\t((chips & DUMP_CHIP_E3B0) == DUMP_CHIP_E3B0)\n\n#define IS_REG_IN_PRESET(presets, idx)  \\\n\t\t((presets & (1 << (idx-1))) == (1 << (idx-1)))\n\n \nstatic const u32 *__bnx2x_get_page_addr_ar(struct bnx2x *bp)\n{\n\tif (CHIP_IS_E2(bp))\n\t\treturn page_vals_e2;\n\telse if (CHIP_IS_E3(bp))\n\t\treturn page_vals_e3;\n\telse\n\t\treturn NULL;\n}\n\nstatic u32 __bnx2x_get_page_reg_num(struct bnx2x *bp)\n{\n\tif (CHIP_IS_E2(bp))\n\t\treturn PAGE_MODE_VALUES_E2;\n\telse if (CHIP_IS_E3(bp))\n\t\treturn PAGE_MODE_VALUES_E3;\n\telse\n\t\treturn 0;\n}\n\nstatic const u32 *__bnx2x_get_page_write_ar(struct bnx2x *bp)\n{\n\tif (CHIP_IS_E2(bp))\n\t\treturn page_write_regs_e2;\n\telse if (CHIP_IS_E3(bp))\n\t\treturn page_write_regs_e3;\n\telse\n\t\treturn NULL;\n}\n\nstatic u32 __bnx2x_get_page_write_num(struct bnx2x *bp)\n{\n\tif (CHIP_IS_E2(bp))\n\t\treturn PAGE_WRITE_REGS_E2;\n\telse if (CHIP_IS_E3(bp))\n\t\treturn PAGE_WRITE_REGS_E3;\n\telse\n\t\treturn 0;\n}\n\nstatic const struct reg_addr *__bnx2x_get_page_read_ar(struct bnx2x *bp)\n{\n\tif (CHIP_IS_E2(bp))\n\t\treturn page_read_regs_e2;\n\telse if (CHIP_IS_E3(bp))\n\t\treturn page_read_regs_e3;\n\telse\n\t\treturn NULL;\n}\n\nstatic u32 __bnx2x_get_page_read_num(struct bnx2x *bp)\n{\n\tif (CHIP_IS_E2(bp))\n\t\treturn PAGE_READ_REGS_E2;\n\telse if (CHIP_IS_E3(bp))\n\t\treturn PAGE_READ_REGS_E3;\n\telse\n\t\treturn 0;\n}\n\nstatic bool bnx2x_is_reg_in_chip(struct bnx2x *bp,\n\t\t\t\t       const struct reg_addr *reg_info)\n{\n\tif (CHIP_IS_E1(bp))\n\t\treturn IS_E1_REG(reg_info->chips);\n\telse if (CHIP_IS_E1H(bp))\n\t\treturn IS_E1H_REG(reg_info->chips);\n\telse if (CHIP_IS_E2(bp))\n\t\treturn IS_E2_REG(reg_info->chips);\n\telse if (CHIP_IS_E3A0(bp))\n\t\treturn IS_E3A0_REG(reg_info->chips);\n\telse if (CHIP_IS_E3B0(bp))\n\t\treturn IS_E3B0_REG(reg_info->chips);\n\telse\n\t\treturn false;\n}\n\nstatic bool bnx2x_is_wreg_in_chip(struct bnx2x *bp,\n\tconst struct wreg_addr *wreg_info)\n{\n\tif (CHIP_IS_E1(bp))\n\t\treturn IS_E1_REG(wreg_info->chips);\n\telse if (CHIP_IS_E1H(bp))\n\t\treturn IS_E1H_REG(wreg_info->chips);\n\telse if (CHIP_IS_E2(bp))\n\t\treturn IS_E2_REG(wreg_info->chips);\n\telse if (CHIP_IS_E3A0(bp))\n\t\treturn IS_E3A0_REG(wreg_info->chips);\n\telse if (CHIP_IS_E3B0(bp))\n\t\treturn IS_E3B0_REG(wreg_info->chips);\n\telse\n\t\treturn false;\n}\n\n \nstatic void bnx2x_read_pages_regs(struct bnx2x *bp, u32 *p, u32 preset)\n{\n\tu32 i, j, k, n;\n\n\t \n\tconst u32 *page_addr = __bnx2x_get_page_addr_ar(bp);\n\t \n\tint num_pages = __bnx2x_get_page_reg_num(bp);\n\t \n\tconst u32 *write_addr = __bnx2x_get_page_write_ar(bp);\n\t \n\tint write_num = __bnx2x_get_page_write_num(bp);\n\t \n\tconst struct reg_addr *read_addr = __bnx2x_get_page_read_ar(bp);\n\t \n\tint read_num = __bnx2x_get_page_read_num(bp);\n\tu32 addr, size;\n\n\tfor (i = 0; i < num_pages; i++) {\n\t\tfor (j = 0; j < write_num; j++) {\n\t\t\tREG_WR(bp, write_addr[j], page_addr[i]);\n\n\t\t\tfor (k = 0; k < read_num; k++) {\n\t\t\t\tif (IS_REG_IN_PRESET(read_addr[k].presets,\n\t\t\t\t\t\t     preset)) {\n\t\t\t\t\tsize = read_addr[k].size;\n\t\t\t\t\tfor (n = 0; n < size; n++) {\n\t\t\t\t\t\taddr = read_addr[k].addr + n*4;\n\t\t\t\t\t\t*p++ = REG_RD(bp, addr);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic int __bnx2x_get_preset_regs(struct bnx2x *bp, u32 *p, u32 preset)\n{\n\tu32 i, j, addr;\n\tconst struct wreg_addr *wreg_addr_p = NULL;\n\n\tif (CHIP_IS_E1(bp))\n\t\twreg_addr_p = &wreg_addr_e1;\n\telse if (CHIP_IS_E1H(bp))\n\t\twreg_addr_p = &wreg_addr_e1h;\n\telse if (CHIP_IS_E2(bp))\n\t\twreg_addr_p = &wreg_addr_e2;\n\telse if (CHIP_IS_E3A0(bp))\n\t\twreg_addr_p = &wreg_addr_e3;\n\telse if (CHIP_IS_E3B0(bp))\n\t\twreg_addr_p = &wreg_addr_e3b0;\n\n\t \n\tfor (i = 0; i < IDLE_REGS_COUNT; i++) {\n\t\tif (bnx2x_is_reg_in_chip(bp, &idle_reg_addrs[i]) &&\n\t\t    IS_REG_IN_PRESET(idle_reg_addrs[i].presets, preset)) {\n\t\t\tfor (j = 0; j < idle_reg_addrs[i].size; j++)\n\t\t\t\t*p++ = REG_RD(bp, idle_reg_addrs[i].addr + j*4);\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < REGS_COUNT; i++) {\n\t\tif (bnx2x_is_reg_in_chip(bp, &reg_addrs[i]) &&\n\t\t    IS_REG_IN_PRESET(reg_addrs[i].presets, preset)) {\n\t\t\tfor (j = 0; j < reg_addrs[i].size; j++)\n\t\t\t\t*p++ = REG_RD(bp, reg_addrs[i].addr + j*4);\n\t\t}\n\t}\n\n\t \n\tif (bnx2x_is_wreg_in_chip(bp, wreg_addr_p) &&\n\t    IS_REG_IN_PRESET(wreg_addr_p->presets, preset)) {\n\t\tfor (i = 0; i < wreg_addr_p->size; i++) {\n\t\t\t*p++ = REG_RD(bp, wreg_addr_p->addr + i*4);\n\n\t\t\t \n\t\t\tfor (j = 0; j < wreg_addr_p->read_regs_count; j++) {\n\t\t\t\taddr = *(wreg_addr_p->read_regs);\n\t\t\t\t*p++ = REG_RD(bp, addr + j*4);\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (CHIP_IS_E2(bp) || CHIP_IS_E3(bp)) {\n\t\t \n\t\tbnx2x_read_pages_regs(bp, p, preset);\n\t}\n\n\treturn 0;\n}\n\nstatic void __bnx2x_get_regs(struct bnx2x *bp, u32 *p)\n{\n\tu32 preset_idx;\n\n\t \n\tfor (preset_idx = 1; preset_idx <= DUMP_MAX_PRESETS; preset_idx++) {\n\t\t \n\t\tif ((preset_idx == 2) ||\n\t\t    (preset_idx == 5) ||\n\t\t    (preset_idx == 8) ||\n\t\t    (preset_idx == 11))\n\t\t\tcontinue;\n\t\t__bnx2x_get_preset_regs(bp, p, preset_idx);\n\t\tp += __bnx2x_get_preset_regs_len(bp, preset_idx);\n\t}\n}\n\nstatic void bnx2x_get_regs(struct net_device *dev,\n\t\t\t   struct ethtool_regs *regs, void *_p)\n{\n\tu32 *p = _p;\n\tstruct bnx2x *bp = netdev_priv(dev);\n\tstruct dump_header dump_hdr = {0};\n\n\tregs->version = 2;\n\tmemset(p, 0, regs->len);\n\n\tif (!netif_running(bp->dev))\n\t\treturn;\n\n\t \n\n\tbnx2x_disable_blocks_parity(bp);\n\n\tdump_hdr.header_size = (sizeof(struct dump_header) / 4) - 1;\n\tdump_hdr.preset = DUMP_ALL_PRESETS;\n\tdump_hdr.version = BNX2X_DUMP_VERSION;\n\n\t \n\tif (CHIP_IS_E1(bp)) {\n\t\tdump_hdr.dump_meta_data = DUMP_CHIP_E1;\n\t} else if (CHIP_IS_E1H(bp)) {\n\t\tdump_hdr.dump_meta_data = DUMP_CHIP_E1H;\n\t} else if (CHIP_IS_E2(bp)) {\n\t\tdump_hdr.dump_meta_data = DUMP_CHIP_E2 |\n\t\t(BP_PATH(bp) ? DUMP_PATH_1 : DUMP_PATH_0);\n\t} else if (CHIP_IS_E3A0(bp)) {\n\t\tdump_hdr.dump_meta_data = DUMP_CHIP_E3A0 |\n\t\t(BP_PATH(bp) ? DUMP_PATH_1 : DUMP_PATH_0);\n\t} else if (CHIP_IS_E3B0(bp)) {\n\t\tdump_hdr.dump_meta_data = DUMP_CHIP_E3B0 |\n\t\t(BP_PATH(bp) ? DUMP_PATH_1 : DUMP_PATH_0);\n\t}\n\n\tmemcpy(p, &dump_hdr, sizeof(struct dump_header));\n\tp += dump_hdr.header_size + 1;\n\n\t \n\tBNX2X_ERR(\"Generating register dump. Might trigger harmless GRC timeouts\\n\");\n\n\t \n\t__bnx2x_get_regs(bp, p);\n\n\t \n\tbnx2x_clear_blocks_parity(bp);\n\tbnx2x_enable_blocks_parity(bp);\n}\n\nstatic int bnx2x_get_preset_regs_len(struct net_device *dev, u32 preset)\n{\n\tstruct bnx2x *bp = netdev_priv(dev);\n\tint regdump_len = 0;\n\n\tregdump_len = __bnx2x_get_preset_regs_len(bp, preset);\n\tregdump_len *= 4;\n\tregdump_len += sizeof(struct dump_header);\n\n\treturn regdump_len;\n}\n\nstatic int bnx2x_set_dump(struct net_device *dev, struct ethtool_dump *val)\n{\n\tstruct bnx2x *bp = netdev_priv(dev);\n\n\t \n\tif (val->flag < 1 || val->flag > DUMP_MAX_PRESETS)\n\t\treturn -EINVAL;\n\n\tbp->dump_preset_idx = val->flag;\n\treturn 0;\n}\n\nstatic int bnx2x_get_dump_flag(struct net_device *dev,\n\t\t\t       struct ethtool_dump *dump)\n{\n\tstruct bnx2x *bp = netdev_priv(dev);\n\n\tdump->version = BNX2X_DUMP_VERSION;\n\tdump->flag = bp->dump_preset_idx;\n\t \n\tdump->len = bnx2x_get_preset_regs_len(dev, bp->dump_preset_idx);\n\tDP(BNX2X_MSG_ETHTOOL, \"Get dump preset %d length=%d\\n\",\n\t   bp->dump_preset_idx, dump->len);\n\treturn 0;\n}\n\nstatic int bnx2x_get_dump_data(struct net_device *dev,\n\t\t\t       struct ethtool_dump *dump,\n\t\t\t       void *buffer)\n{\n\tu32 *p = buffer;\n\tstruct bnx2x *bp = netdev_priv(dev);\n\tstruct dump_header dump_hdr = {0};\n\n\t \n\n\tbnx2x_disable_blocks_parity(bp);\n\n\tdump_hdr.header_size = (sizeof(struct dump_header) / 4) - 1;\n\tdump_hdr.preset = bp->dump_preset_idx;\n\tdump_hdr.version = BNX2X_DUMP_VERSION;\n\n\tDP(BNX2X_MSG_ETHTOOL, \"Get dump data of preset %d\\n\", dump_hdr.preset);\n\n\t \n\tif (CHIP_IS_E1(bp)) {\n\t\tdump_hdr.dump_meta_data = DUMP_CHIP_E1;\n\t} else if (CHIP_IS_E1H(bp)) {\n\t\tdump_hdr.dump_meta_data = DUMP_CHIP_E1H;\n\t} else if (CHIP_IS_E2(bp)) {\n\t\tdump_hdr.dump_meta_data = DUMP_CHIP_E2 |\n\t\t(BP_PATH(bp) ? DUMP_PATH_1 : DUMP_PATH_0);\n\t} else if (CHIP_IS_E3A0(bp)) {\n\t\tdump_hdr.dump_meta_data = DUMP_CHIP_E3A0 |\n\t\t(BP_PATH(bp) ? DUMP_PATH_1 : DUMP_PATH_0);\n\t} else if (CHIP_IS_E3B0(bp)) {\n\t\tdump_hdr.dump_meta_data = DUMP_CHIP_E3B0 |\n\t\t(BP_PATH(bp) ? DUMP_PATH_1 : DUMP_PATH_0);\n\t}\n\n\tmemcpy(p, &dump_hdr, sizeof(struct dump_header));\n\tp += dump_hdr.header_size + 1;\n\n\t \n\t__bnx2x_get_preset_regs(bp, p, dump_hdr.preset);\n\n\t \n\tbnx2x_clear_blocks_parity(bp);\n\tbnx2x_enable_blocks_parity(bp);\n\n\treturn 0;\n}\n\nstatic void bnx2x_get_drvinfo(struct net_device *dev,\n\t\t\t      struct ethtool_drvinfo *info)\n{\n\tstruct bnx2x *bp = netdev_priv(dev);\n\tchar version[ETHTOOL_FWVERS_LEN];\n\tint ext_dev_info_offset;\n\tu32 mbi;\n\n\tstrscpy(info->driver, DRV_MODULE_NAME, sizeof(info->driver));\n\n\tif (SHMEM2_HAS(bp, extended_dev_info_shared_addr)) {\n\t\text_dev_info_offset = SHMEM2_RD(bp,\n\t\t\t\t\t\textended_dev_info_shared_addr);\n\t\tmbi = REG_RD(bp, ext_dev_info_offset +\n\t\t\t     offsetof(struct extended_dev_info_shared_cfg,\n\t\t\t\t      mbi_version));\n\t\tif (mbi) {\n\t\t\tmemset(version, 0, sizeof(version));\n\t\t\tsnprintf(version, ETHTOOL_FWVERS_LEN, \"mbi %d.%d.%d \",\n\t\t\t\t (mbi & 0xff000000) >> 24,\n\t\t\t\t (mbi & 0x00ff0000) >> 16,\n\t\t\t\t (mbi & 0x0000ff00) >> 8);\n\t\t\tstrscpy(info->fw_version, version,\n\t\t\t\tsizeof(info->fw_version));\n\t\t}\n\t}\n\n\tmemset(version, 0, sizeof(version));\n\tbnx2x_fill_fw_str(bp, version, ETHTOOL_FWVERS_LEN);\n\tstrlcat(info->fw_version, version, sizeof(info->fw_version));\n\n\tstrscpy(info->bus_info, pci_name(bp->pdev), sizeof(info->bus_info));\n}\n\nstatic void bnx2x_get_wol(struct net_device *dev, struct ethtool_wolinfo *wol)\n{\n\tstruct bnx2x *bp = netdev_priv(dev);\n\n\tif (bp->flags & NO_WOL_FLAG) {\n\t\twol->supported = 0;\n\t\twol->wolopts = 0;\n\t} else {\n\t\twol->supported = WAKE_MAGIC;\n\t\tif (bp->wol)\n\t\t\twol->wolopts = WAKE_MAGIC;\n\t\telse\n\t\t\twol->wolopts = 0;\n\t}\n\tmemset(&wol->sopass, 0, sizeof(wol->sopass));\n}\n\nstatic int bnx2x_set_wol(struct net_device *dev, struct ethtool_wolinfo *wol)\n{\n\tstruct bnx2x *bp = netdev_priv(dev);\n\n\tif (wol->wolopts & ~WAKE_MAGIC) {\n\t\tDP(BNX2X_MSG_ETHTOOL, \"WOL not supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (wol->wolopts & WAKE_MAGIC) {\n\t\tif (bp->flags & NO_WOL_FLAG) {\n\t\t\tDP(BNX2X_MSG_ETHTOOL, \"WOL not supported\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbp->wol = 1;\n\t} else\n\t\tbp->wol = 0;\n\n\tif (SHMEM2_HAS(bp, curr_cfg))\n\t\tSHMEM2_WR(bp, curr_cfg, CURR_CFG_MET_OS);\n\n\treturn 0;\n}\n\nstatic u32 bnx2x_get_msglevel(struct net_device *dev)\n{\n\tstruct bnx2x *bp = netdev_priv(dev);\n\n\treturn bp->msg_enable;\n}\n\nstatic void bnx2x_set_msglevel(struct net_device *dev, u32 level)\n{\n\tstruct bnx2x *bp = netdev_priv(dev);\n\n\tif (capable(CAP_NET_ADMIN)) {\n\t\t \n\t\tif (IS_PF(bp) && (level & BNX2X_MSG_MCP))\n\t\t\tbnx2x_fw_dump_lvl(bp, KERN_INFO);\n\t\tbp->msg_enable = level;\n\t}\n}\n\nstatic int bnx2x_nway_reset(struct net_device *dev)\n{\n\tstruct bnx2x *bp = netdev_priv(dev);\n\n\tif (!bp->port.pmf)\n\t\treturn 0;\n\n\tif (netif_running(dev)) {\n\t\tbnx2x_stats_handle(bp, STATS_EVENT_STOP);\n\t\tbnx2x_force_link_reset(bp);\n\t\tbnx2x_link_set(bp);\n\t}\n\n\treturn 0;\n}\n\nstatic u32 bnx2x_get_link(struct net_device *dev)\n{\n\tstruct bnx2x *bp = netdev_priv(dev);\n\n\tif (bp->flags & MF_FUNC_DIS || (bp->state != BNX2X_STATE_OPEN))\n\t\treturn 0;\n\n\tif (IS_VF(bp))\n\t\treturn !test_bit(BNX2X_LINK_REPORT_LINK_DOWN,\n\t\t\t\t &bp->vf_link_vars.link_report_flags);\n\n\treturn bp->link_vars.link_up;\n}\n\nstatic int bnx2x_get_eeprom_len(struct net_device *dev)\n{\n\tstruct bnx2x *bp = netdev_priv(dev);\n\n\treturn bp->common.flash_size;\n}\n\n \nstatic int bnx2x_acquire_nvram_lock(struct bnx2x *bp)\n{\n\tint port = BP_PORT(bp);\n\tint count, i;\n\tu32 val;\n\n\t \n\tbnx2x_acquire_hw_lock(bp, HW_LOCK_RESOURCE_NVRAM);\n\n\t \n\tcount = BNX2X_NVRAM_TIMEOUT_COUNT;\n\tif (CHIP_REV_IS_SLOW(bp))\n\t\tcount *= 100;\n\n\t \n\tREG_WR(bp, MCP_REG_MCPR_NVM_SW_ARB,\n\t       (MCPR_NVM_SW_ARB_ARB_REQ_SET1 << port));\n\n\tfor (i = 0; i < count*10; i++) {\n\t\tval = REG_RD(bp, MCP_REG_MCPR_NVM_SW_ARB);\n\t\tif (val & (MCPR_NVM_SW_ARB_ARB_ARB1 << port))\n\t\t\tbreak;\n\n\t\tudelay(5);\n\t}\n\n\tif (!(val & (MCPR_NVM_SW_ARB_ARB_ARB1 << port))) {\n\t\tDP(BNX2X_MSG_ETHTOOL | BNX2X_MSG_NVM,\n\t\t   \"cannot get access to nvram interface\\n\");\n\t\tbnx2x_release_hw_lock(bp, HW_LOCK_RESOURCE_NVRAM);\n\t\treturn -EBUSY;\n\t}\n\n\treturn 0;\n}\n\nstatic int bnx2x_release_nvram_lock(struct bnx2x *bp)\n{\n\tint port = BP_PORT(bp);\n\tint count, i;\n\tu32 val;\n\n\t \n\tcount = BNX2X_NVRAM_TIMEOUT_COUNT;\n\tif (CHIP_REV_IS_SLOW(bp))\n\t\tcount *= 100;\n\n\t \n\tREG_WR(bp, MCP_REG_MCPR_NVM_SW_ARB,\n\t       (MCPR_NVM_SW_ARB_ARB_REQ_CLR1 << port));\n\n\tfor (i = 0; i < count*10; i++) {\n\t\tval = REG_RD(bp, MCP_REG_MCPR_NVM_SW_ARB);\n\t\tif (!(val & (MCPR_NVM_SW_ARB_ARB_ARB1 << port)))\n\t\t\tbreak;\n\n\t\tudelay(5);\n\t}\n\n\tif (val & (MCPR_NVM_SW_ARB_ARB_ARB1 << port)) {\n\t\tDP(BNX2X_MSG_ETHTOOL | BNX2X_MSG_NVM,\n\t\t   \"cannot free access to nvram interface\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\t \n\tbnx2x_release_hw_lock(bp, HW_LOCK_RESOURCE_NVRAM);\n\treturn 0;\n}\n\nstatic void bnx2x_enable_nvram_access(struct bnx2x *bp)\n{\n\tu32 val;\n\n\tval = REG_RD(bp, MCP_REG_MCPR_NVM_ACCESS_ENABLE);\n\n\t \n\tREG_WR(bp, MCP_REG_MCPR_NVM_ACCESS_ENABLE,\n\t       (val | MCPR_NVM_ACCESS_ENABLE_EN |\n\t\t      MCPR_NVM_ACCESS_ENABLE_WR_EN));\n}\n\nstatic void bnx2x_disable_nvram_access(struct bnx2x *bp)\n{\n\tu32 val;\n\n\tval = REG_RD(bp, MCP_REG_MCPR_NVM_ACCESS_ENABLE);\n\n\t \n\tREG_WR(bp, MCP_REG_MCPR_NVM_ACCESS_ENABLE,\n\t       (val & ~(MCPR_NVM_ACCESS_ENABLE_EN |\n\t\t\tMCPR_NVM_ACCESS_ENABLE_WR_EN)));\n}\n\nstatic int bnx2x_nvram_read_dword(struct bnx2x *bp, u32 offset, __be32 *ret_val,\n\t\t\t\t  u32 cmd_flags)\n{\n\tint count, i, rc;\n\tu32 val;\n\n\t \n\tcmd_flags |= MCPR_NVM_COMMAND_DOIT;\n\n\t \n\tREG_WR(bp, MCP_REG_MCPR_NVM_COMMAND, MCPR_NVM_COMMAND_DONE);\n\n\t \n\tREG_WR(bp, MCP_REG_MCPR_NVM_ADDR,\n\t       (offset & MCPR_NVM_ADDR_NVM_ADDR_VALUE));\n\n\t \n\tREG_WR(bp, MCP_REG_MCPR_NVM_COMMAND, cmd_flags);\n\n\t \n\tcount = BNX2X_NVRAM_TIMEOUT_COUNT;\n\tif (CHIP_REV_IS_SLOW(bp))\n\t\tcount *= 100;\n\n\t \n\t*ret_val = 0;\n\trc = -EBUSY;\n\tfor (i = 0; i < count; i++) {\n\t\tudelay(5);\n\t\tval = REG_RD(bp, MCP_REG_MCPR_NVM_COMMAND);\n\n\t\tif (val & MCPR_NVM_COMMAND_DONE) {\n\t\t\tval = REG_RD(bp, MCP_REG_MCPR_NVM_READ);\n\t\t\t \n\t\t\t*ret_val = cpu_to_be32(val);\n\t\t\trc = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (rc == -EBUSY)\n\t\tDP(BNX2X_MSG_ETHTOOL | BNX2X_MSG_NVM,\n\t\t   \"nvram read timeout expired\\n\");\n\treturn rc;\n}\n\nint bnx2x_nvram_read(struct bnx2x *bp, u32 offset, u8 *ret_buf,\n\t\t     int buf_size)\n{\n\tint rc;\n\tu32 cmd_flags;\n\t__be32 val;\n\n\tif ((offset & 0x03) || (buf_size & 0x03) || (buf_size == 0)) {\n\t\tDP(BNX2X_MSG_ETHTOOL | BNX2X_MSG_NVM,\n\t\t   \"Invalid parameter: offset 0x%x  buf_size 0x%x\\n\",\n\t\t   offset, buf_size);\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + buf_size > bp->common.flash_size) {\n\t\tDP(BNX2X_MSG_ETHTOOL | BNX2X_MSG_NVM,\n\t\t   \"Invalid parameter: offset (0x%x) + buf_size (0x%x) > flash_size (0x%x)\\n\",\n\t\t   offset, buf_size, bp->common.flash_size);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\trc = bnx2x_acquire_nvram_lock(bp);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tbnx2x_enable_nvram_access(bp);\n\n\t \n\tcmd_flags = MCPR_NVM_COMMAND_FIRST;\n\twhile ((buf_size > sizeof(u32)) && (rc == 0)) {\n\t\trc = bnx2x_nvram_read_dword(bp, offset, &val, cmd_flags);\n\t\tmemcpy(ret_buf, &val, 4);\n\n\t\t \n\t\toffset += sizeof(u32);\n\t\tret_buf += sizeof(u32);\n\t\tbuf_size -= sizeof(u32);\n\t\tcmd_flags = 0;\n\t}\n\n\tif (rc == 0) {\n\t\tcmd_flags |= MCPR_NVM_COMMAND_LAST;\n\t\trc = bnx2x_nvram_read_dword(bp, offset, &val, cmd_flags);\n\t\tmemcpy(ret_buf, &val, 4);\n\t}\n\n\t \n\tbnx2x_disable_nvram_access(bp);\n\tbnx2x_release_nvram_lock(bp);\n\n\treturn rc;\n}\n\nstatic int bnx2x_nvram_read32(struct bnx2x *bp, u32 offset, u32 *buf,\n\t\t\t      int buf_size)\n{\n\tint rc;\n\n\trc = bnx2x_nvram_read(bp, offset, (u8 *)buf, buf_size);\n\n\tif (!rc) {\n\t\t__be32 *be = (__be32 *)buf;\n\n\t\twhile ((buf_size -= 4) >= 0)\n\t\t\t*buf++ = be32_to_cpu(*be++);\n\t}\n\n\treturn rc;\n}\n\nstatic bool bnx2x_is_nvm_accessible(struct bnx2x *bp)\n{\n\tint rc = 1;\n\tu16 pm = 0;\n\tstruct net_device *dev = pci_get_drvdata(bp->pdev);\n\n\tif (bp->pdev->pm_cap)\n\t\trc = pci_read_config_word(bp->pdev,\n\t\t\t\t\t  bp->pdev->pm_cap + PCI_PM_CTRL, &pm);\n\n\tif ((rc && !netif_running(dev)) ||\n\t    (!rc && ((pm & PCI_PM_CTRL_STATE_MASK) != (__force u16)PCI_D0)))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic int bnx2x_get_eeprom(struct net_device *dev,\n\t\t\t    struct ethtool_eeprom *eeprom, u8 *eebuf)\n{\n\tstruct bnx2x *bp = netdev_priv(dev);\n\n\tif (!bnx2x_is_nvm_accessible(bp)) {\n\t\tDP(BNX2X_MSG_ETHTOOL  | BNX2X_MSG_NVM,\n\t\t   \"cannot access eeprom when the interface is down\\n\");\n\t\treturn -EAGAIN;\n\t}\n\n\tDP(BNX2X_MSG_ETHTOOL | BNX2X_MSG_NVM, \"ethtool_eeprom: cmd %d\\n\"\n\t   \"  magic 0x%x  offset 0x%x (%d)  len 0x%x (%d)\\n\",\n\t   eeprom->cmd, eeprom->magic, eeprom->offset, eeprom->offset,\n\t   eeprom->len, eeprom->len);\n\n\t \n\n\treturn bnx2x_nvram_read(bp, eeprom->offset, eebuf, eeprom->len);\n}\n\nstatic int bnx2x_get_module_eeprom(struct net_device *dev,\n\t\t\t\t   struct ethtool_eeprom *ee,\n\t\t\t\t   u8 *data)\n{\n\tstruct bnx2x *bp = netdev_priv(dev);\n\tint rc = -EINVAL, phy_idx;\n\tu8 *user_data = data;\n\tunsigned int start_addr = ee->offset, xfer_size = 0;\n\n\tif (!bnx2x_is_nvm_accessible(bp)) {\n\t\tDP(BNX2X_MSG_ETHTOOL | BNX2X_MSG_NVM,\n\t\t   \"cannot access eeprom when the interface is down\\n\");\n\t\treturn -EAGAIN;\n\t}\n\n\tphy_idx = bnx2x_get_cur_phy_idx(bp);\n\n\t \n\tif (start_addr < ETH_MODULE_SFF_8079_LEN) {\n\t\t \n\t\tif (start_addr + ee->len > ETH_MODULE_SFF_8079_LEN)\n\t\t\txfer_size = ETH_MODULE_SFF_8079_LEN - start_addr;\n\t\telse\n\t\t\txfer_size = ee->len;\n\t\tbnx2x_acquire_phy_lock(bp);\n\t\trc = bnx2x_read_sfp_module_eeprom(&bp->link_params.phy[phy_idx],\n\t\t\t\t\t\t  &bp->link_params,\n\t\t\t\t\t\t  I2C_DEV_ADDR_A0,\n\t\t\t\t\t\t  start_addr,\n\t\t\t\t\t\t  xfer_size,\n\t\t\t\t\t\t  user_data);\n\t\tbnx2x_release_phy_lock(bp);\n\t\tif (rc) {\n\t\t\tDP(BNX2X_MSG_ETHTOOL, \"Failed reading A0 section\\n\");\n\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tuser_data += xfer_size;\n\t\tstart_addr += xfer_size;\n\t}\n\n\t \n\tif ((start_addr >= ETH_MODULE_SFF_8079_LEN) &&\n\t    (start_addr < ETH_MODULE_SFF_8472_LEN)) {\n\t\txfer_size = ee->len - xfer_size;\n\t\t \n\t\tif (start_addr + xfer_size > ETH_MODULE_SFF_8472_LEN)\n\t\t\txfer_size = ETH_MODULE_SFF_8472_LEN - start_addr;\n\t\tstart_addr -= ETH_MODULE_SFF_8079_LEN;\n\t\tbnx2x_acquire_phy_lock(bp);\n\t\trc = bnx2x_read_sfp_module_eeprom(&bp->link_params.phy[phy_idx],\n\t\t\t\t\t\t  &bp->link_params,\n\t\t\t\t\t\t  I2C_DEV_ADDR_A2,\n\t\t\t\t\t\t  start_addr,\n\t\t\t\t\t\t  xfer_size,\n\t\t\t\t\t\t  user_data);\n\t\tbnx2x_release_phy_lock(bp);\n\t\tif (rc) {\n\t\t\tDP(BNX2X_MSG_ETHTOOL, \"Failed reading A2 section\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\treturn rc;\n}\n\nstatic int bnx2x_get_module_info(struct net_device *dev,\n\t\t\t\t struct ethtool_modinfo *modinfo)\n{\n\tstruct bnx2x *bp = netdev_priv(dev);\n\tint phy_idx, rc;\n\tu8 sff8472_comp, diag_type;\n\n\tif (!bnx2x_is_nvm_accessible(bp)) {\n\t\tDP(BNX2X_MSG_ETHTOOL | BNX2X_MSG_NVM,\n\t\t   \"cannot access eeprom when the interface is down\\n\");\n\t\treturn -EAGAIN;\n\t}\n\tphy_idx = bnx2x_get_cur_phy_idx(bp);\n\tbnx2x_acquire_phy_lock(bp);\n\trc = bnx2x_read_sfp_module_eeprom(&bp->link_params.phy[phy_idx],\n\t\t\t\t\t  &bp->link_params,\n\t\t\t\t\t  I2C_DEV_ADDR_A0,\n\t\t\t\t\t  SFP_EEPROM_SFF_8472_COMP_ADDR,\n\t\t\t\t\t  SFP_EEPROM_SFF_8472_COMP_SIZE,\n\t\t\t\t\t  &sff8472_comp);\n\tbnx2x_release_phy_lock(bp);\n\tif (rc) {\n\t\tDP(BNX2X_MSG_ETHTOOL, \"Failed reading SFF-8472 comp field\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tbnx2x_acquire_phy_lock(bp);\n\trc = bnx2x_read_sfp_module_eeprom(&bp->link_params.phy[phy_idx],\n\t\t\t\t\t  &bp->link_params,\n\t\t\t\t\t  I2C_DEV_ADDR_A0,\n\t\t\t\t\t  SFP_EEPROM_DIAG_TYPE_ADDR,\n\t\t\t\t\t  SFP_EEPROM_DIAG_TYPE_SIZE,\n\t\t\t\t\t  &diag_type);\n\tbnx2x_release_phy_lock(bp);\n\tif (rc) {\n\t\tDP(BNX2X_MSG_ETHTOOL, \"Failed reading Diag Type field\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!sff8472_comp ||\n\t    (diag_type & SFP_EEPROM_DIAG_ADDR_CHANGE_REQ) ||\n\t    !(diag_type & SFP_EEPROM_DDM_IMPLEMENTED)) {\n\t\tmodinfo->type = ETH_MODULE_SFF_8079;\n\t\tmodinfo->eeprom_len = ETH_MODULE_SFF_8079_LEN;\n\t} else {\n\t\tmodinfo->type = ETH_MODULE_SFF_8472;\n\t\tmodinfo->eeprom_len = ETH_MODULE_SFF_8472_LEN;\n\t}\n\treturn 0;\n}\n\nstatic int bnx2x_nvram_write_dword(struct bnx2x *bp, u32 offset, u32 val,\n\t\t\t\t   u32 cmd_flags)\n{\n\tint count, i, rc;\n\n\t \n\tcmd_flags |= MCPR_NVM_COMMAND_DOIT | MCPR_NVM_COMMAND_WR;\n\n\t \n\tREG_WR(bp, MCP_REG_MCPR_NVM_COMMAND, MCPR_NVM_COMMAND_DONE);\n\n\t \n\tREG_WR(bp, MCP_REG_MCPR_NVM_WRITE, val);\n\n\t \n\tREG_WR(bp, MCP_REG_MCPR_NVM_ADDR,\n\t       (offset & MCPR_NVM_ADDR_NVM_ADDR_VALUE));\n\n\t \n\tREG_WR(bp, MCP_REG_MCPR_NVM_COMMAND, cmd_flags);\n\n\t \n\tcount = BNX2X_NVRAM_TIMEOUT_COUNT;\n\tif (CHIP_REV_IS_SLOW(bp))\n\t\tcount *= 100;\n\n\t \n\trc = -EBUSY;\n\tfor (i = 0; i < count; i++) {\n\t\tudelay(5);\n\t\tval = REG_RD(bp, MCP_REG_MCPR_NVM_COMMAND);\n\t\tif (val & MCPR_NVM_COMMAND_DONE) {\n\t\t\trc = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (rc == -EBUSY)\n\t\tDP(BNX2X_MSG_ETHTOOL | BNX2X_MSG_NVM,\n\t\t   \"nvram write timeout expired\\n\");\n\treturn rc;\n}\n\n#define BYTE_OFFSET(offset)\t\t(8 * (offset & 0x03))\n\nstatic int bnx2x_nvram_write1(struct bnx2x *bp, u32 offset, u8 *data_buf,\n\t\t\t      int buf_size)\n{\n\tint rc;\n\tu32 cmd_flags, align_offset, val;\n\t__be32 val_be;\n\n\tif (offset + buf_size > bp->common.flash_size) {\n\t\tDP(BNX2X_MSG_ETHTOOL | BNX2X_MSG_NVM,\n\t\t   \"Invalid parameter: offset (0x%x) + buf_size (0x%x) > flash_size (0x%x)\\n\",\n\t\t   offset, buf_size, bp->common.flash_size);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\trc = bnx2x_acquire_nvram_lock(bp);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tbnx2x_enable_nvram_access(bp);\n\n\tcmd_flags = (MCPR_NVM_COMMAND_FIRST | MCPR_NVM_COMMAND_LAST);\n\talign_offset = (offset & ~0x03);\n\trc = bnx2x_nvram_read_dword(bp, align_offset, &val_be, cmd_flags);\n\n\tif (rc == 0) {\n\t\t \n\t\tval = be32_to_cpu(val_be);\n\n\t\tval &= ~le32_to_cpu((__force __le32)\n\t\t\t\t    (0xff << BYTE_OFFSET(offset)));\n\t\tval |= le32_to_cpu((__force __le32)\n\t\t\t\t   (*data_buf << BYTE_OFFSET(offset)));\n\n\t\trc = bnx2x_nvram_write_dword(bp, align_offset, val,\n\t\t\t\t\t     cmd_flags);\n\t}\n\n\t \n\tbnx2x_disable_nvram_access(bp);\n\tbnx2x_release_nvram_lock(bp);\n\n\treturn rc;\n}\n\nstatic int bnx2x_nvram_write(struct bnx2x *bp, u32 offset, u8 *data_buf,\n\t\t\t     int buf_size)\n{\n\tint rc;\n\tu32 cmd_flags;\n\tu32 val;\n\tu32 written_so_far;\n\n\tif (buf_size == 1)\t \n\t\treturn bnx2x_nvram_write1(bp, offset, data_buf, buf_size);\n\n\tif ((offset & 0x03) || (buf_size & 0x03) || (buf_size == 0)) {\n\t\tDP(BNX2X_MSG_ETHTOOL | BNX2X_MSG_NVM,\n\t\t   \"Invalid parameter: offset 0x%x  buf_size 0x%x\\n\",\n\t\t   offset, buf_size);\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + buf_size > bp->common.flash_size) {\n\t\tDP(BNX2X_MSG_ETHTOOL | BNX2X_MSG_NVM,\n\t\t   \"Invalid parameter: offset (0x%x) + buf_size (0x%x) > flash_size (0x%x)\\n\",\n\t\t   offset, buf_size, bp->common.flash_size);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\trc = bnx2x_acquire_nvram_lock(bp);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tbnx2x_enable_nvram_access(bp);\n\n\twritten_so_far = 0;\n\tcmd_flags = MCPR_NVM_COMMAND_FIRST;\n\twhile ((written_so_far < buf_size) && (rc == 0)) {\n\t\tif (written_so_far == (buf_size - sizeof(u32)))\n\t\t\tcmd_flags |= MCPR_NVM_COMMAND_LAST;\n\t\telse if (((offset + 4) % BNX2X_NVRAM_PAGE_SIZE) == 0)\n\t\t\tcmd_flags |= MCPR_NVM_COMMAND_LAST;\n\t\telse if ((offset % BNX2X_NVRAM_PAGE_SIZE) == 0)\n\t\t\tcmd_flags |= MCPR_NVM_COMMAND_FIRST;\n\n\t\tmemcpy(&val, data_buf, 4);\n\n\t\t \n\t\trc = bnx2x_nvram_write_dword(bp, offset, val, cmd_flags);\n\n\t\t \n\t\toffset += sizeof(u32);\n\t\tdata_buf += sizeof(u32);\n\t\twritten_so_far += sizeof(u32);\n\n\t\t \n\t\tif ((cmd_flags & MCPR_NVM_COMMAND_LAST) &&\n\t\t    (written_so_far < buf_size)) {\n\t\t\tDP(BNX2X_MSG_ETHTOOL | BNX2X_MSG_NVM,\n\t\t\t   \"Releasing NVM lock after offset 0x%x\\n\",\n\t\t\t   (u32)(offset - sizeof(u32)));\n\t\t\tbnx2x_release_nvram_lock(bp);\n\t\t\tusleep_range(1000, 2000);\n\t\t\trc = bnx2x_acquire_nvram_lock(bp);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t}\n\n\t\tcmd_flags = 0;\n\t}\n\n\t \n\tbnx2x_disable_nvram_access(bp);\n\tbnx2x_release_nvram_lock(bp);\n\n\treturn rc;\n}\n\nstatic int bnx2x_set_eeprom(struct net_device *dev,\n\t\t\t    struct ethtool_eeprom *eeprom, u8 *eebuf)\n{\n\tstruct bnx2x *bp = netdev_priv(dev);\n\tint port = BP_PORT(bp);\n\tint rc = 0;\n\tu32 ext_phy_config;\n\n\tif (!bnx2x_is_nvm_accessible(bp)) {\n\t\tDP(BNX2X_MSG_ETHTOOL | BNX2X_MSG_NVM,\n\t\t   \"cannot access eeprom when the interface is down\\n\");\n\t\treturn -EAGAIN;\n\t}\n\n\tDP(BNX2X_MSG_ETHTOOL | BNX2X_MSG_NVM, \"ethtool_eeprom: cmd %d\\n\"\n\t   \"  magic 0x%x  offset 0x%x (%d)  len 0x%x (%d)\\n\",\n\t   eeprom->cmd, eeprom->magic, eeprom->offset, eeprom->offset,\n\t   eeprom->len, eeprom->len);\n\n\t \n\n\t \n\tif ((eeprom->magic >= 0x50485900) && (eeprom->magic <= 0x504859FF) &&\n\t    !bp->port.pmf) {\n\t\tDP(BNX2X_MSG_ETHTOOL | BNX2X_MSG_NVM,\n\t\t   \"wrong magic or interface is not pmf\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\text_phy_config =\n\t\tSHMEM_RD(bp,\n\t\t\t dev_info.port_hw_config[port].external_phy_config);\n\n\tif (eeprom->magic == 0x50485950) {\n\t\t \n\t\tbnx2x_stats_handle(bp, STATS_EVENT_STOP);\n\n\t\tbnx2x_acquire_phy_lock(bp);\n\t\trc |= bnx2x_link_reset(&bp->link_params,\n\t\t\t\t       &bp->link_vars, 0);\n\t\tif (XGXS_EXT_PHY_TYPE(ext_phy_config) ==\n\t\t\t\t\tPORT_HW_CFG_XGXS_EXT_PHY_TYPE_SFX7101)\n\t\t\tbnx2x_set_gpio(bp, MISC_REGISTERS_GPIO_0,\n\t\t\t\t       MISC_REGISTERS_GPIO_HIGH, port);\n\t\tbnx2x_release_phy_lock(bp);\n\t\tbnx2x_link_report(bp);\n\n\t} else if (eeprom->magic == 0x50485952) {\n\t\t \n\t\tif (bp->state == BNX2X_STATE_OPEN) {\n\t\t\tbnx2x_acquire_phy_lock(bp);\n\t\t\trc |= bnx2x_link_reset(&bp->link_params,\n\t\t\t\t\t       &bp->link_vars, 1);\n\n\t\t\trc |= bnx2x_phy_init(&bp->link_params,\n\t\t\t\t\t     &bp->link_vars);\n\t\t\tbnx2x_release_phy_lock(bp);\n\t\t\tbnx2x_calc_fc_adv(bp);\n\t\t}\n\t} else if (eeprom->magic == 0x53985943) {\n\t\t \n\t\tif (XGXS_EXT_PHY_TYPE(ext_phy_config) ==\n\t\t\t\t       PORT_HW_CFG_XGXS_EXT_PHY_TYPE_SFX7101) {\n\n\t\t\t \n\t\t\tbnx2x_set_gpio(bp, MISC_REGISTERS_GPIO_0,\n\t\t\t\t       MISC_REGISTERS_GPIO_LOW, port);\n\n\t\t\tbnx2x_acquire_phy_lock(bp);\n\n\t\t\tbnx2x_sfx7101_sp_sw_reset(bp,\n\t\t\t\t\t\t&bp->link_params.phy[EXT_PHY1]);\n\n\t\t\t \n\t\t\tmsleep(500);\n\t\t\tbnx2x_ext_phy_hw_reset(bp, port);\n\t\t\tmsleep(500);\n\t\t\tbnx2x_release_phy_lock(bp);\n\t\t}\n\t} else\n\t\trc = bnx2x_nvram_write(bp, eeprom->offset, eebuf, eeprom->len);\n\n\treturn rc;\n}\n\nstatic int bnx2x_get_coalesce(struct net_device *dev,\n\t\t\t      struct ethtool_coalesce *coal,\n\t\t\t      struct kernel_ethtool_coalesce *kernel_coal,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct bnx2x *bp = netdev_priv(dev);\n\n\tmemset(coal, 0, sizeof(struct ethtool_coalesce));\n\n\tcoal->rx_coalesce_usecs = bp->rx_ticks;\n\tcoal->tx_coalesce_usecs = bp->tx_ticks;\n\n\treturn 0;\n}\n\nstatic int bnx2x_set_coalesce(struct net_device *dev,\n\t\t\t      struct ethtool_coalesce *coal,\n\t\t\t      struct kernel_ethtool_coalesce *kernel_coal,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct bnx2x *bp = netdev_priv(dev);\n\n\tbp->rx_ticks = (u16)coal->rx_coalesce_usecs;\n\tif (bp->rx_ticks > BNX2X_MAX_COALESCE_TOUT)\n\t\tbp->rx_ticks = BNX2X_MAX_COALESCE_TOUT;\n\n\tbp->tx_ticks = (u16)coal->tx_coalesce_usecs;\n\tif (bp->tx_ticks > BNX2X_MAX_COALESCE_TOUT)\n\t\tbp->tx_ticks = BNX2X_MAX_COALESCE_TOUT;\n\n\tif (netif_running(dev))\n\t\tbnx2x_update_coalesce(bp);\n\n\treturn 0;\n}\n\nstatic void bnx2x_get_ringparam(struct net_device *dev,\n\t\t\t\tstruct ethtool_ringparam *ering,\n\t\t\t\tstruct kernel_ethtool_ringparam *kernel_ering,\n\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct bnx2x *bp = netdev_priv(dev);\n\n\tering->rx_max_pending = MAX_RX_AVAIL;\n\n\t \n\tif (bp->rx_ring_size)\n\t\tering->rx_pending = bp->rx_ring_size;\n\telse if (BNX2X_NUM_RX_QUEUES(bp))\n\t\tering->rx_pending = MAX_RX_AVAIL / BNX2X_NUM_RX_QUEUES(bp);\n\telse\n\t\tering->rx_pending = MAX_RX_AVAIL;\n\n\tering->tx_max_pending = IS_MF_FCOE_AFEX(bp) ? 0 : MAX_TX_AVAIL;\n\tering->tx_pending = bp->tx_ring_size;\n}\n\nstatic int bnx2x_set_ringparam(struct net_device *dev,\n\t\t\t       struct ethtool_ringparam *ering,\n\t\t\t       struct kernel_ethtool_ringparam *kernel_ering,\n\t\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct bnx2x *bp = netdev_priv(dev);\n\n\tDP(BNX2X_MSG_ETHTOOL,\n\t   \"set ring params command parameters: rx_pending = %d, tx_pending = %d\\n\",\n\t   ering->rx_pending, ering->tx_pending);\n\n\tif (pci_num_vf(bp->pdev)) {\n\t\tDP(BNX2X_MSG_IOV,\n\t\t   \"VFs are enabled, can not change ring parameters\\n\");\n\t\treturn -EPERM;\n\t}\n\n\tif (bp->recovery_state != BNX2X_RECOVERY_DONE) {\n\t\tDP(BNX2X_MSG_ETHTOOL,\n\t\t   \"Handling parity error recovery. Try again later\\n\");\n\t\treturn -EAGAIN;\n\t}\n\n\tif ((ering->rx_pending > MAX_RX_AVAIL) ||\n\t    (ering->rx_pending < (bp->disable_tpa ? MIN_RX_SIZE_NONTPA :\n\t\t\t\t\t\t    MIN_RX_SIZE_TPA)) ||\n\t    (ering->tx_pending > (IS_MF_STORAGE_ONLY(bp) ? 0 : MAX_TX_AVAIL)) ||\n\t    (ering->tx_pending <= MAX_SKB_FRAGS + 4)) {\n\t\tDP(BNX2X_MSG_ETHTOOL, \"Command parameters not supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tbp->rx_ring_size = ering->rx_pending;\n\tbp->tx_ring_size = ering->tx_pending;\n\n\treturn bnx2x_reload_if_running(dev);\n}\n\nstatic void bnx2x_get_pauseparam(struct net_device *dev,\n\t\t\t\t struct ethtool_pauseparam *epause)\n{\n\tstruct bnx2x *bp = netdev_priv(dev);\n\tint cfg_idx = bnx2x_get_link_cfg_idx(bp);\n\tint cfg_reg;\n\n\tepause->autoneg = (bp->link_params.req_flow_ctrl[cfg_idx] ==\n\t\t\t   BNX2X_FLOW_CTRL_AUTO);\n\n\tif (!epause->autoneg)\n\t\tcfg_reg = bp->link_params.req_flow_ctrl[cfg_idx];\n\telse\n\t\tcfg_reg = bp->link_params.req_fc_auto_adv;\n\n\tepause->rx_pause = ((cfg_reg & BNX2X_FLOW_CTRL_RX) ==\n\t\t\t    BNX2X_FLOW_CTRL_RX);\n\tepause->tx_pause = ((cfg_reg & BNX2X_FLOW_CTRL_TX) ==\n\t\t\t    BNX2X_FLOW_CTRL_TX);\n\n\tDP(BNX2X_MSG_ETHTOOL, \"ethtool_pauseparam: cmd %d\\n\"\n\t   \"  autoneg %d  rx_pause %d  tx_pause %d\\n\",\n\t   epause->cmd, epause->autoneg, epause->rx_pause, epause->tx_pause);\n}\n\nstatic int bnx2x_set_pauseparam(struct net_device *dev,\n\t\t\t\tstruct ethtool_pauseparam *epause)\n{\n\tstruct bnx2x *bp = netdev_priv(dev);\n\tu32 cfg_idx = bnx2x_get_link_cfg_idx(bp);\n\tif (IS_MF(bp))\n\t\treturn 0;\n\n\tDP(BNX2X_MSG_ETHTOOL, \"ethtool_pauseparam: cmd %d\\n\"\n\t   \"  autoneg %d  rx_pause %d  tx_pause %d\\n\",\n\t   epause->cmd, epause->autoneg, epause->rx_pause, epause->tx_pause);\n\n\tbp->link_params.req_flow_ctrl[cfg_idx] = BNX2X_FLOW_CTRL_AUTO;\n\n\tif (epause->rx_pause)\n\t\tbp->link_params.req_flow_ctrl[cfg_idx] |= BNX2X_FLOW_CTRL_RX;\n\n\tif (epause->tx_pause)\n\t\tbp->link_params.req_flow_ctrl[cfg_idx] |= BNX2X_FLOW_CTRL_TX;\n\n\tif (bp->link_params.req_flow_ctrl[cfg_idx] == BNX2X_FLOW_CTRL_AUTO)\n\t\tbp->link_params.req_flow_ctrl[cfg_idx] = BNX2X_FLOW_CTRL_NONE;\n\n\tif (epause->autoneg) {\n\t\tif (!(bp->port.supported[cfg_idx] & SUPPORTED_Autoneg)) {\n\t\t\tDP(BNX2X_MSG_ETHTOOL, \"autoneg not supported\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (bp->link_params.req_line_speed[cfg_idx] == SPEED_AUTO_NEG) {\n\t\t\tbp->link_params.req_flow_ctrl[cfg_idx] =\n\t\t\t\tBNX2X_FLOW_CTRL_AUTO;\n\t\t}\n\t\tbp->link_params.req_fc_auto_adv = 0;\n\t\tif (epause->rx_pause)\n\t\t\tbp->link_params.req_fc_auto_adv |= BNX2X_FLOW_CTRL_RX;\n\n\t\tif (epause->tx_pause)\n\t\t\tbp->link_params.req_fc_auto_adv |= BNX2X_FLOW_CTRL_TX;\n\n\t\tif (!bp->link_params.req_fc_auto_adv)\n\t\t\tbp->link_params.req_fc_auto_adv |= BNX2X_FLOW_CTRL_NONE;\n\t}\n\n\tDP(BNX2X_MSG_ETHTOOL,\n\t   \"req_flow_ctrl 0x%x\\n\", bp->link_params.req_flow_ctrl[cfg_idx]);\n\n\tif (netif_running(dev)) {\n\t\tbnx2x_stats_handle(bp, STATS_EVENT_STOP);\n\t\tbnx2x_force_link_reset(bp);\n\t\tbnx2x_link_set(bp);\n\t}\n\n\treturn 0;\n}\n\nstatic const char bnx2x_tests_str_arr[BNX2X_NUM_TESTS_SF][ETH_GSTRING_LEN] = {\n\t\"register_test (offline)    \",\n\t\"memory_test (offline)      \",\n\t\"int_loopback_test (offline)\",\n\t\"ext_loopback_test (offline)\",\n\t\"nvram_test (online)        \",\n\t\"interrupt_test (online)    \",\n\t\"link_test (online)         \"\n};\n\nenum {\n\tBNX2X_PRI_FLAG_ISCSI,\n\tBNX2X_PRI_FLAG_FCOE,\n\tBNX2X_PRI_FLAG_STORAGE,\n\tBNX2X_PRI_FLAG_LEN,\n};\n\nstatic const char bnx2x_private_arr[BNX2X_PRI_FLAG_LEN][ETH_GSTRING_LEN] = {\n\t\"iSCSI offload support\",\n\t\"FCoE offload support\",\n\t\"Storage only interface\"\n};\n\nstatic u32 bnx2x_eee_to_adv(u32 eee_adv)\n{\n\tu32 modes = 0;\n\n\tif (eee_adv & SHMEM_EEE_100M_ADV)\n\t\tmodes |= ADVERTISED_100baseT_Full;\n\tif (eee_adv & SHMEM_EEE_1G_ADV)\n\t\tmodes |= ADVERTISED_1000baseT_Full;\n\tif (eee_adv & SHMEM_EEE_10G_ADV)\n\t\tmodes |= ADVERTISED_10000baseT_Full;\n\n\treturn modes;\n}\n\nstatic u32 bnx2x_adv_to_eee(u32 modes, u32 shift)\n{\n\tu32 eee_adv = 0;\n\tif (modes & ADVERTISED_100baseT_Full)\n\t\teee_adv |= SHMEM_EEE_100M_ADV;\n\tif (modes & ADVERTISED_1000baseT_Full)\n\t\teee_adv |= SHMEM_EEE_1G_ADV;\n\tif (modes & ADVERTISED_10000baseT_Full)\n\t\teee_adv |= SHMEM_EEE_10G_ADV;\n\n\treturn eee_adv << shift;\n}\n\nstatic int bnx2x_get_eee(struct net_device *dev, struct ethtool_eee *edata)\n{\n\tstruct bnx2x *bp = netdev_priv(dev);\n\tu32 eee_cfg;\n\n\tif (!SHMEM2_HAS(bp, eee_status[BP_PORT(bp)])) {\n\t\tDP(BNX2X_MSG_ETHTOOL, \"BC Version does not support EEE\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\teee_cfg = bp->link_vars.eee_status;\n\n\tedata->supported =\n\t\tbnx2x_eee_to_adv((eee_cfg & SHMEM_EEE_SUPPORTED_MASK) >>\n\t\t\t\t SHMEM_EEE_SUPPORTED_SHIFT);\n\n\tedata->advertised =\n\t\tbnx2x_eee_to_adv((eee_cfg & SHMEM_EEE_ADV_STATUS_MASK) >>\n\t\t\t\t SHMEM_EEE_ADV_STATUS_SHIFT);\n\tedata->lp_advertised =\n\t\tbnx2x_eee_to_adv((eee_cfg & SHMEM_EEE_LP_ADV_STATUS_MASK) >>\n\t\t\t\t SHMEM_EEE_LP_ADV_STATUS_SHIFT);\n\n\t \n\tedata->tx_lpi_timer = (eee_cfg & SHMEM_EEE_TIMER_MASK) << 4;\n\n\tedata->eee_enabled    = (eee_cfg & SHMEM_EEE_REQUESTED_BIT)\t? 1 : 0;\n\tedata->eee_active     = (eee_cfg & SHMEM_EEE_ACTIVE_BIT)\t? 1 : 0;\n\tedata->tx_lpi_enabled = (eee_cfg & SHMEM_EEE_LPI_REQUESTED_BIT) ? 1 : 0;\n\n\treturn 0;\n}\n\nstatic int bnx2x_set_eee(struct net_device *dev, struct ethtool_eee *edata)\n{\n\tstruct bnx2x *bp = netdev_priv(dev);\n\tu32 eee_cfg;\n\tu32 advertised;\n\n\tif (IS_MF(bp))\n\t\treturn 0;\n\n\tif (!SHMEM2_HAS(bp, eee_status[BP_PORT(bp)])) {\n\t\tDP(BNX2X_MSG_ETHTOOL, \"BC Version does not support EEE\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\teee_cfg = bp->link_vars.eee_status;\n\n\tif (!(eee_cfg & SHMEM_EEE_SUPPORTED_MASK)) {\n\t\tDP(BNX2X_MSG_ETHTOOL, \"Board does not support EEE!\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tadvertised = bnx2x_adv_to_eee(edata->advertised,\n\t\t\t\t      SHMEM_EEE_ADV_STATUS_SHIFT);\n\tif ((advertised != (eee_cfg & SHMEM_EEE_ADV_STATUS_MASK))) {\n\t\tDP(BNX2X_MSG_ETHTOOL,\n\t\t   \"Direct manipulation of EEE advertisement is not supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (edata->tx_lpi_timer > EEE_MODE_TIMER_MASK) {\n\t\tDP(BNX2X_MSG_ETHTOOL,\n\t\t   \"Maximal Tx Lpi timer supported is %x(u)\\n\",\n\t\t   EEE_MODE_TIMER_MASK);\n\t\treturn -EINVAL;\n\t}\n\tif (edata->tx_lpi_enabled &&\n\t    (edata->tx_lpi_timer < EEE_MODE_NVRAM_AGGRESSIVE_TIME)) {\n\t\tDP(BNX2X_MSG_ETHTOOL,\n\t\t   \"Minimal Tx Lpi timer supported is %d(u)\\n\",\n\t\t   EEE_MODE_NVRAM_AGGRESSIVE_TIME);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (edata->eee_enabled)\n\t\tbp->link_params.eee_mode |= EEE_MODE_ADV_LPI;\n\telse\n\t\tbp->link_params.eee_mode &= ~EEE_MODE_ADV_LPI;\n\n\tif (edata->tx_lpi_enabled)\n\t\tbp->link_params.eee_mode |= EEE_MODE_ENABLE_LPI;\n\telse\n\t\tbp->link_params.eee_mode &= ~EEE_MODE_ENABLE_LPI;\n\n\tbp->link_params.eee_mode &= ~EEE_MODE_TIMER_MASK;\n\tbp->link_params.eee_mode |= (edata->tx_lpi_timer &\n\t\t\t\t    EEE_MODE_TIMER_MASK) |\n\t\t\t\t    EEE_MODE_OVERRIDE_NVRAM |\n\t\t\t\t    EEE_MODE_OUTPUT_TIME;\n\n\t \n\tif (netif_running(dev)) {\n\t\tbnx2x_stats_handle(bp, STATS_EVENT_STOP);\n\t\tbnx2x_force_link_reset(bp);\n\t\tbnx2x_link_set(bp);\n\t}\n\n\treturn 0;\n}\n\nenum {\n\tBNX2X_CHIP_E1_OFST = 0,\n\tBNX2X_CHIP_E1H_OFST,\n\tBNX2X_CHIP_E2_OFST,\n\tBNX2X_CHIP_E3_OFST,\n\tBNX2X_CHIP_E3B0_OFST,\n\tBNX2X_CHIP_MAX_OFST\n};\n\n#define BNX2X_CHIP_MASK_E1\t(1 << BNX2X_CHIP_E1_OFST)\n#define BNX2X_CHIP_MASK_E1H\t(1 << BNX2X_CHIP_E1H_OFST)\n#define BNX2X_CHIP_MASK_E2\t(1 << BNX2X_CHIP_E2_OFST)\n#define BNX2X_CHIP_MASK_E3\t(1 << BNX2X_CHIP_E3_OFST)\n#define BNX2X_CHIP_MASK_E3B0\t(1 << BNX2X_CHIP_E3B0_OFST)\n\n#define BNX2X_CHIP_MASK_ALL\t((1 << BNX2X_CHIP_MAX_OFST) - 1)\n#define BNX2X_CHIP_MASK_E1X\t(BNX2X_CHIP_MASK_E1 | BNX2X_CHIP_MASK_E1H)\n\nstatic int bnx2x_test_registers(struct bnx2x *bp)\n{\n\tint idx, i, rc = -ENODEV;\n\tu32 wr_val = 0, hw;\n\tint port = BP_PORT(bp);\n\tstatic const struct {\n\t\tu32 hw;\n\t\tu32 offset0;\n\t\tu32 offset1;\n\t\tu32 mask;\n\t} reg_tbl[] = {\n \t\t{ BNX2X_CHIP_MASK_ALL,\n\t\t\tBRB1_REG_PAUSE_LOW_THRESHOLD_0,\t4, 0x000003ff },\n\t\t{ BNX2X_CHIP_MASK_ALL,\n\t\t\tDORQ_REG_DB_ADDR0,\t\t4, 0xffffffff },\n\t\t{ BNX2X_CHIP_MASK_E1X,\n\t\t\tHC_REG_AGG_INT_0,\t\t4, 0x000003ff },\n\t\t{ BNX2X_CHIP_MASK_ALL,\n\t\t\tPBF_REG_MAC_IF0_ENABLE,\t\t4, 0x00000001 },\n\t\t{ BNX2X_CHIP_MASK_E1X | BNX2X_CHIP_MASK_E2 | BNX2X_CHIP_MASK_E3,\n\t\t\tPBF_REG_P0_INIT_CRD,\t\t4, 0x000007ff },\n\t\t{ BNX2X_CHIP_MASK_E3B0,\n\t\t\tPBF_REG_INIT_CRD_Q0,\t\t4, 0x000007ff },\n\t\t{ BNX2X_CHIP_MASK_ALL,\n\t\t\tPRS_REG_CID_PORT_0,\t\t4, 0x00ffffff },\n\t\t{ BNX2X_CHIP_MASK_ALL,\n\t\t\tPXP2_REG_PSWRQ_CDU0_L2P,\t4, 0x000fffff },\n\t\t{ BNX2X_CHIP_MASK_ALL,\n\t\t\tPXP2_REG_RQ_CDU0_EFIRST_MEM_ADDR, 8, 0x0003ffff },\n\t\t{ BNX2X_CHIP_MASK_ALL,\n\t\t\tPXP2_REG_PSWRQ_TM0_L2P,\t\t4, 0x000fffff },\n \t{ BNX2X_CHIP_MASK_ALL,\n\t\t\tPXP2_REG_RQ_USDM0_EFIRST_MEM_ADDR, 8, 0x0003ffff },\n\t\t{ BNX2X_CHIP_MASK_ALL,\n\t\t\tPXP2_REG_PSWRQ_TSDM0_L2P,\t4, 0x000fffff },\n\t\t{ BNX2X_CHIP_MASK_ALL,\n\t\t\tQM_REG_CONNNUM_0,\t\t4, 0x000fffff },\n\t\t{ BNX2X_CHIP_MASK_ALL,\n\t\t\tTM_REG_LIN0_MAX_ACTIVE_CID,\t4, 0x0003ffff },\n\t\t{ BNX2X_CHIP_MASK_ALL,\n\t\t\tSRC_REG_KEYRSS0_0,\t\t40, 0xffffffff },\n\t\t{ BNX2X_CHIP_MASK_ALL,\n\t\t\tSRC_REG_KEYRSS0_7,\t\t40, 0xffffffff },\n\t\t{ BNX2X_CHIP_MASK_ALL,\n\t\t\tXCM_REG_WU_DA_SET_TMR_CNT_FLG_CMD00, 4, 0x00000001 },\n\t\t{ BNX2X_CHIP_MASK_ALL,\n\t\t\tXCM_REG_WU_DA_CNT_CMD00,\t4, 0x00000003 },\n\t\t{ BNX2X_CHIP_MASK_ALL,\n\t\t\tXCM_REG_GLB_DEL_ACK_MAX_CNT_0,\t4, 0x000000ff },\n\t\t{ BNX2X_CHIP_MASK_ALL,\n\t\t\tNIG_REG_LLH0_T_BIT,\t\t4, 0x00000001 },\n \t{ BNX2X_CHIP_MASK_E1X | BNX2X_CHIP_MASK_E2,\n\t\t\tNIG_REG_EMAC0_IN_EN,\t\t4, 0x00000001 },\n\t\t{ BNX2X_CHIP_MASK_E1X | BNX2X_CHIP_MASK_E2,\n\t\t\tNIG_REG_BMAC0_IN_EN,\t\t4, 0x00000001 },\n\t\t{ BNX2X_CHIP_MASK_ALL,\n\t\t\tNIG_REG_XCM0_OUT_EN,\t\t4, 0x00000001 },\n\t\t{ BNX2X_CHIP_MASK_ALL,\n\t\t\tNIG_REG_BRB0_OUT_EN,\t\t4, 0x00000001 },\n\t\t{ BNX2X_CHIP_MASK_ALL,\n\t\t\tNIG_REG_LLH0_XCM_MASK,\t\t4, 0x00000007 },\n\t\t{ BNX2X_CHIP_MASK_ALL,\n\t\t\tNIG_REG_LLH0_ACPI_PAT_6_LEN,\t68, 0x000000ff },\n\t\t{ BNX2X_CHIP_MASK_ALL,\n\t\t\tNIG_REG_LLH0_ACPI_PAT_0_CRC,\t68, 0xffffffff },\n\t\t{ BNX2X_CHIP_MASK_ALL,\n\t\t\tNIG_REG_LLH0_DEST_MAC_0_0,\t160, 0xffffffff },\n\t\t{ BNX2X_CHIP_MASK_ALL,\n\t\t\tNIG_REG_LLH0_DEST_IP_0_1,\t160, 0xffffffff },\n\t\t{ BNX2X_CHIP_MASK_ALL,\n\t\t\tNIG_REG_LLH0_IPV4_IPV6_0,\t160, 0x00000001 },\n \t{ BNX2X_CHIP_MASK_ALL,\n\t\t\tNIG_REG_LLH0_DEST_UDP_0,\t160, 0x0000ffff },\n\t\t{ BNX2X_CHIP_MASK_ALL,\n\t\t\tNIG_REG_LLH0_DEST_TCP_0,\t160, 0x0000ffff },\n\t\t{ BNX2X_CHIP_MASK_ALL,\n\t\t\tNIG_REG_LLH0_VLAN_ID_0,\t160, 0x00000fff },\n\t\t{ BNX2X_CHIP_MASK_E1X | BNX2X_CHIP_MASK_E2,\n\t\t\tNIG_REG_XGXS_SERDES0_MODE_SEL,\t4, 0x00000001 },\n\t\t{ BNX2X_CHIP_MASK_ALL,\n\t\t\tNIG_REG_LED_CONTROL_OVERRIDE_TRAFFIC_P0, 4, 0x00000001},\n\t\t{ BNX2X_CHIP_MASK_ALL,\n\t\t\tNIG_REG_STATUS_INTERRUPT_PORT0,\t4, 0x07ffffff },\n\t\t{ BNX2X_CHIP_MASK_E1X | BNX2X_CHIP_MASK_E2,\n\t\t\tNIG_REG_XGXS0_CTRL_EXTREMOTEMDIOST, 24, 0x00000001 },\n\t\t{ BNX2X_CHIP_MASK_E1X | BNX2X_CHIP_MASK_E2,\n\t\t\tNIG_REG_SERDES0_CTRL_PHY_ADDR,\t16, 0x0000001f },\n\n\t\t{ BNX2X_CHIP_MASK_ALL, 0xffffffff, 0, 0x00000000 }\n\t};\n\n\tif (!bnx2x_is_nvm_accessible(bp)) {\n\t\tDP(BNX2X_MSG_ETHTOOL | BNX2X_MSG_NVM,\n\t\t   \"cannot access eeprom when the interface is down\\n\");\n\t\treturn rc;\n\t}\n\n\tif (CHIP_IS_E1(bp))\n\t\thw = BNX2X_CHIP_MASK_E1;\n\telse if (CHIP_IS_E1H(bp))\n\t\thw = BNX2X_CHIP_MASK_E1H;\n\telse if (CHIP_IS_E2(bp))\n\t\thw = BNX2X_CHIP_MASK_E2;\n\telse if (CHIP_IS_E3B0(bp))\n\t\thw = BNX2X_CHIP_MASK_E3B0;\n\telse  \n\t\thw = BNX2X_CHIP_MASK_E3;\n\n\t \n\tfor (idx = 0; idx < 2; idx++) {\n\n\t\tswitch (idx) {\n\t\tcase 0:\n\t\t\twr_val = 0;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\twr_val = 0xffffffff;\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (i = 0; reg_tbl[i].offset0 != 0xffffffff; i++) {\n\t\t\tu32 offset, mask, save_val, val;\n\t\t\tif (!(hw & reg_tbl[i].hw))\n\t\t\t\tcontinue;\n\n\t\t\toffset = reg_tbl[i].offset0 + port*reg_tbl[i].offset1;\n\t\t\tmask = reg_tbl[i].mask;\n\n\t\t\tsave_val = REG_RD(bp, offset);\n\n\t\t\tREG_WR(bp, offset, wr_val & mask);\n\n\t\t\tval = REG_RD(bp, offset);\n\n\t\t\t \n\t\t\tREG_WR(bp, offset, save_val);\n\n\t\t\t \n\t\t\tif ((val & mask) != (wr_val & mask)) {\n\t\t\t\tDP(BNX2X_MSG_ETHTOOL,\n\t\t\t\t   \"offset 0x%x: val 0x%x != 0x%x mask 0x%x\\n\",\n\t\t\t\t   offset, val, wr_val, mask);\n\t\t\t\tgoto test_reg_exit;\n\t\t\t}\n\t\t}\n\t}\n\n\trc = 0;\n\ntest_reg_exit:\n\treturn rc;\n}\n\nstatic int bnx2x_test_memory(struct bnx2x *bp)\n{\n\tint i, j, rc = -ENODEV;\n\tu32 val, index;\n\tstatic const struct {\n\t\tu32 offset;\n\t\tint size;\n\t} mem_tbl[] = {\n\t\t{ CCM_REG_XX_DESCR_TABLE,   CCM_REG_XX_DESCR_TABLE_SIZE },\n\t\t{ CFC_REG_ACTIVITY_COUNTER, CFC_REG_ACTIVITY_COUNTER_SIZE },\n\t\t{ CFC_REG_LINK_LIST,        CFC_REG_LINK_LIST_SIZE },\n\t\t{ DMAE_REG_CMD_MEM,         DMAE_REG_CMD_MEM_SIZE },\n\t\t{ TCM_REG_XX_DESCR_TABLE,   TCM_REG_XX_DESCR_TABLE_SIZE },\n\t\t{ UCM_REG_XX_DESCR_TABLE,   UCM_REG_XX_DESCR_TABLE_SIZE },\n\t\t{ XCM_REG_XX_DESCR_TABLE,   XCM_REG_XX_DESCR_TABLE_SIZE },\n\n\t\t{ 0xffffffff, 0 }\n\t};\n\n\tstatic const struct {\n\t\tchar *name;\n\t\tu32 offset;\n\t\tu32 hw_mask[BNX2X_CHIP_MAX_OFST];\n\t} prty_tbl[] = {\n\t\t{ \"CCM_PRTY_STS\",  CCM_REG_CCM_PRTY_STS,\n\t\t\t{0x3ffc0, 0,   0, 0} },\n\t\t{ \"CFC_PRTY_STS\",  CFC_REG_CFC_PRTY_STS,\n\t\t\t{0x2,     0x2, 0, 0} },\n\t\t{ \"DMAE_PRTY_STS\", DMAE_REG_DMAE_PRTY_STS,\n\t\t\t{0,       0,   0, 0} },\n\t\t{ \"TCM_PRTY_STS\",  TCM_REG_TCM_PRTY_STS,\n\t\t\t{0x3ffc0, 0,   0, 0} },\n\t\t{ \"UCM_PRTY_STS\",  UCM_REG_UCM_PRTY_STS,\n\t\t\t{0x3ffc0, 0,   0, 0} },\n\t\t{ \"XCM_PRTY_STS\",  XCM_REG_XCM_PRTY_STS,\n\t\t\t{0x3ffc1, 0,   0, 0} },\n\n\t\t{ NULL, 0xffffffff, {0, 0, 0, 0} }\n\t};\n\n\tif (!bnx2x_is_nvm_accessible(bp)) {\n\t\tDP(BNX2X_MSG_ETHTOOL | BNX2X_MSG_NVM,\n\t\t   \"cannot access eeprom when the interface is down\\n\");\n\t\treturn rc;\n\t}\n\n\tif (CHIP_IS_E1(bp))\n\t\tindex = BNX2X_CHIP_E1_OFST;\n\telse if (CHIP_IS_E1H(bp))\n\t\tindex = BNX2X_CHIP_E1H_OFST;\n\telse if (CHIP_IS_E2(bp))\n\t\tindex = BNX2X_CHIP_E2_OFST;\n\telse  \n\t\tindex = BNX2X_CHIP_E3_OFST;\n\n\t \n\tfor (i = 0; prty_tbl[i].offset != 0xffffffff; i++) {\n\t\tval = REG_RD(bp, prty_tbl[i].offset);\n\t\tif (val & ~(prty_tbl[i].hw_mask[index])) {\n\t\t\tDP(BNX2X_MSG_ETHTOOL,\n\t\t\t   \"%s is 0x%x\\n\", prty_tbl[i].name, val);\n\t\t\tgoto test_mem_exit;\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; mem_tbl[i].offset != 0xffffffff; i++)\n\t\tfor (j = 0; j < mem_tbl[i].size; j++)\n\t\t\tREG_RD(bp, mem_tbl[i].offset + j*4);\n\n\t \n\tfor (i = 0; prty_tbl[i].offset != 0xffffffff; i++) {\n\t\tval = REG_RD(bp, prty_tbl[i].offset);\n\t\tif (val & ~(prty_tbl[i].hw_mask[index])) {\n\t\t\tDP(BNX2X_MSG_ETHTOOL,\n\t\t\t   \"%s is 0x%x\\n\", prty_tbl[i].name, val);\n\t\t\tgoto test_mem_exit;\n\t\t}\n\t}\n\n\trc = 0;\n\ntest_mem_exit:\n\treturn rc;\n}\n\nstatic void bnx2x_wait_for_link(struct bnx2x *bp, u8 link_up, u8 is_serdes)\n{\n\tint cnt = 1400;\n\n\tif (link_up) {\n\t\twhile (bnx2x_link_test(bp, is_serdes) && cnt--)\n\t\t\tmsleep(20);\n\n\t\tif (cnt <= 0 && bnx2x_link_test(bp, is_serdes))\n\t\t\tDP(BNX2X_MSG_ETHTOOL, \"Timeout waiting for link up\\n\");\n\n\t\tcnt = 1400;\n\t\twhile (!bp->link_vars.link_up && cnt--)\n\t\t\tmsleep(20);\n\n\t\tif (cnt <= 0 && !bp->link_vars.link_up)\n\t\t\tDP(BNX2X_MSG_ETHTOOL,\n\t\t\t   \"Timeout waiting for link init\\n\");\n\t}\n}\n\nstatic int bnx2x_run_loopback(struct bnx2x *bp, int loopback_mode)\n{\n\tunsigned int pkt_size, num_pkts, i;\n\tstruct sk_buff *skb;\n\tunsigned char *packet;\n\tstruct bnx2x_fastpath *fp_rx = &bp->fp[0];\n\tstruct bnx2x_fastpath *fp_tx = &bp->fp[0];\n\tstruct bnx2x_fp_txdata *txdata = fp_tx->txdata_ptr[0];\n\tu16 tx_start_idx, tx_idx;\n\tu16 rx_start_idx, rx_idx;\n\tu16 pkt_prod, bd_prod;\n\tstruct sw_tx_bd *tx_buf;\n\tstruct eth_tx_start_bd *tx_start_bd;\n\tdma_addr_t mapping;\n\tunion eth_rx_cqe *cqe;\n\tu8 cqe_fp_flags, cqe_fp_type;\n\tstruct sw_rx_bd *rx_buf;\n\tu16 len;\n\tint rc = -ENODEV;\n\tu8 *data;\n\tstruct netdev_queue *txq = netdev_get_tx_queue(bp->dev,\n\t\t\t\t\t\t       txdata->txq_index);\n\n\t \n\tswitch (loopback_mode) {\n\tcase BNX2X_PHY_LOOPBACK:\n\t\tif (bp->link_params.loopback_mode != LOOPBACK_XGXS) {\n\t\t\tDP(BNX2X_MSG_ETHTOOL, \"PHY loopback not supported\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase BNX2X_MAC_LOOPBACK:\n\t\tif (CHIP_IS_E3(bp)) {\n\t\t\tint cfg_idx = bnx2x_get_link_cfg_idx(bp);\n\t\t\tif (bp->port.supported[cfg_idx] &\n\t\t\t    (SUPPORTED_10000baseT_Full |\n\t\t\t     SUPPORTED_20000baseMLD2_Full |\n\t\t\t     SUPPORTED_20000baseKR2_Full))\n\t\t\t\tbp->link_params.loopback_mode = LOOPBACK_XMAC;\n\t\t\telse\n\t\t\t\tbp->link_params.loopback_mode = LOOPBACK_UMAC;\n\t\t} else\n\t\t\tbp->link_params.loopback_mode = LOOPBACK_BMAC;\n\n\t\tbnx2x_phy_init(&bp->link_params, &bp->link_vars);\n\t\tbreak;\n\tcase BNX2X_EXT_LOOPBACK:\n\t\tif (bp->link_params.loopback_mode != LOOPBACK_EXT) {\n\t\t\tDP(BNX2X_MSG_ETHTOOL,\n\t\t\t   \"Can't configure external loopback\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tDP(BNX2X_MSG_ETHTOOL, \"Command parameters not supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tpkt_size = (((bp->dev->mtu < ETH_MAX_PACKET_SIZE) ?\n\t\t     bp->dev->mtu : ETH_MAX_PACKET_SIZE) + ETH_HLEN);\n\tskb = netdev_alloc_skb(bp->dev, fp_rx->rx_buf_size);\n\tif (!skb) {\n\t\tDP(BNX2X_MSG_ETHTOOL, \"Can't allocate skb\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto test_loopback_exit;\n\t}\n\tpacket = skb_put(skb, pkt_size);\n\tmemcpy(packet, bp->dev->dev_addr, ETH_ALEN);\n\teth_zero_addr(packet + ETH_ALEN);\n\tmemset(packet + 2*ETH_ALEN, 0x77, (ETH_HLEN - 2*ETH_ALEN));\n\tfor (i = ETH_HLEN; i < pkt_size; i++)\n\t\tpacket[i] = (unsigned char) (i & 0xff);\n\tmapping = dma_map_single(&bp->pdev->dev, skb->data,\n\t\t\t\t skb_headlen(skb), DMA_TO_DEVICE);\n\tif (unlikely(dma_mapping_error(&bp->pdev->dev, mapping))) {\n\t\trc = -ENOMEM;\n\t\tdev_kfree_skb(skb);\n\t\tDP(BNX2X_MSG_ETHTOOL, \"Unable to map SKB\\n\");\n\t\tgoto test_loopback_exit;\n\t}\n\n\t \n\tnum_pkts = 0;\n\ttx_start_idx = le16_to_cpu(*txdata->tx_cons_sb);\n\trx_start_idx = le16_to_cpu(*fp_rx->rx_cons_sb);\n\n\tnetdev_tx_sent_queue(txq, skb->len);\n\n\tpkt_prod = txdata->tx_pkt_prod++;\n\ttx_buf = &txdata->tx_buf_ring[TX_BD(pkt_prod)];\n\ttx_buf->first_bd = txdata->tx_bd_prod;\n\ttx_buf->skb = skb;\n\ttx_buf->flags = 0;\n\n\tbd_prod = TX_BD(txdata->tx_bd_prod);\n\ttx_start_bd = &txdata->tx_desc_ring[bd_prod].start_bd;\n\ttx_start_bd->addr_hi = cpu_to_le32(U64_HI(mapping));\n\ttx_start_bd->addr_lo = cpu_to_le32(U64_LO(mapping));\n\ttx_start_bd->nbd = cpu_to_le16(2);  \n\ttx_start_bd->nbytes = cpu_to_le16(skb_headlen(skb));\n\ttx_start_bd->vlan_or_ethertype = cpu_to_le16(pkt_prod);\n\ttx_start_bd->bd_flags.as_bitfield = ETH_TX_BD_FLAGS_START_BD;\n\tSET_FLAG(tx_start_bd->general_data,\n\t\t ETH_TX_START_BD_HDR_NBDS,\n\t\t 1);\n\tSET_FLAG(tx_start_bd->general_data,\n\t\t ETH_TX_START_BD_PARSE_NBDS,\n\t\t 0);\n\n\t \n\tbd_prod = TX_BD(NEXT_TX_IDX(bd_prod));\n\n\tif (CHIP_IS_E1x(bp)) {\n\t\tu16 global_data = 0;\n\t\tstruct eth_tx_parse_bd_e1x  *pbd_e1x =\n\t\t\t&txdata->tx_desc_ring[bd_prod].parse_bd_e1x;\n\t\tmemset(pbd_e1x, 0, sizeof(struct eth_tx_parse_bd_e1x));\n\t\tSET_FLAG(global_data,\n\t\t\t ETH_TX_PARSE_BD_E1X_ETH_ADDR_TYPE, UNICAST_ADDRESS);\n\t\tpbd_e1x->global_data = cpu_to_le16(global_data);\n\t} else {\n\t\tu32 parsing_data = 0;\n\t\tstruct eth_tx_parse_bd_e2  *pbd_e2 =\n\t\t\t&txdata->tx_desc_ring[bd_prod].parse_bd_e2;\n\t\tmemset(pbd_e2, 0, sizeof(struct eth_tx_parse_bd_e2));\n\t\tSET_FLAG(parsing_data,\n\t\t\t ETH_TX_PARSE_BD_E2_ETH_ADDR_TYPE, UNICAST_ADDRESS);\n\t\tpbd_e2->parsing_data = cpu_to_le32(parsing_data);\n\t}\n\twmb();\n\n\ttxdata->tx_db.data.prod += 2;\n\t \n\twmb();\n\tDOORBELL_RELAXED(bp, txdata->cid, txdata->tx_db.raw);\n\n\tbarrier();\n\n\tnum_pkts++;\n\ttxdata->tx_bd_prod += 2;  \n\n\tudelay(100);\n\n\ttx_idx = le16_to_cpu(*txdata->tx_cons_sb);\n\tif (tx_idx != tx_start_idx + num_pkts)\n\t\tgoto test_loopback_exit;\n\n\t \n\tif (bp->common.int_block == INT_BLOCK_IGU) {\n\t\t \n\t\tlocal_bh_disable();\n\t\tbnx2x_tx_int(bp, txdata);\n\t\tlocal_bh_enable();\n\t}\n\n\trx_idx = le16_to_cpu(*fp_rx->rx_cons_sb);\n\tif (rx_idx != rx_start_idx + num_pkts)\n\t\tgoto test_loopback_exit;\n\n\tcqe = &fp_rx->rx_comp_ring[RCQ_BD(fp_rx->rx_comp_cons)];\n\tcqe_fp_flags = cqe->fast_path_cqe.type_error_flags;\n\tcqe_fp_type = cqe_fp_flags & ETH_FAST_PATH_RX_CQE_TYPE;\n\tif (!CQE_TYPE_FAST(cqe_fp_type) || (cqe_fp_flags & ETH_RX_ERROR_FALGS))\n\t\tgoto test_loopback_rx_exit;\n\n\tlen = le16_to_cpu(cqe->fast_path_cqe.pkt_len_or_gro_seg_len);\n\tif (len != pkt_size)\n\t\tgoto test_loopback_rx_exit;\n\n\trx_buf = &fp_rx->rx_buf_ring[RX_BD(fp_rx->rx_bd_cons)];\n\tdma_sync_single_for_cpu(&bp->pdev->dev,\n\t\t\t\t   dma_unmap_addr(rx_buf, mapping),\n\t\t\t\t   fp_rx->rx_buf_size, DMA_FROM_DEVICE);\n\tdata = rx_buf->data + NET_SKB_PAD + cqe->fast_path_cqe.placement_offset;\n\tfor (i = ETH_HLEN; i < pkt_size; i++)\n\t\tif (*(data + i) != (unsigned char) (i & 0xff))\n\t\t\tgoto test_loopback_rx_exit;\n\n\trc = 0;\n\ntest_loopback_rx_exit:\n\n\tfp_rx->rx_bd_cons = NEXT_RX_IDX(fp_rx->rx_bd_cons);\n\tfp_rx->rx_bd_prod = NEXT_RX_IDX(fp_rx->rx_bd_prod);\n\tfp_rx->rx_comp_cons = NEXT_RCQ_IDX(fp_rx->rx_comp_cons);\n\tfp_rx->rx_comp_prod = NEXT_RCQ_IDX(fp_rx->rx_comp_prod);\n\n\t \n\tbnx2x_update_rx_prod(bp, fp_rx, fp_rx->rx_bd_prod, fp_rx->rx_comp_prod,\n\t\t\t     fp_rx->rx_sge_prod);\n\ntest_loopback_exit:\n\tbp->link_params.loopback_mode = LOOPBACK_NONE;\n\n\treturn rc;\n}\n\nstatic int bnx2x_test_loopback(struct bnx2x *bp)\n{\n\tint rc = 0, res;\n\n\tif (BP_NOMCP(bp))\n\t\treturn rc;\n\n\tif (!netif_running(bp->dev))\n\t\treturn BNX2X_LOOPBACK_FAILED;\n\n\tbnx2x_netif_stop(bp, 1);\n\tbnx2x_acquire_phy_lock(bp);\n\n\tres = bnx2x_run_loopback(bp, BNX2X_PHY_LOOPBACK);\n\tif (res) {\n\t\tDP(BNX2X_MSG_ETHTOOL, \"  PHY loopback failed  (res %d)\\n\", res);\n\t\trc |= BNX2X_PHY_LOOPBACK_FAILED;\n\t}\n\n\tres = bnx2x_run_loopback(bp, BNX2X_MAC_LOOPBACK);\n\tif (res) {\n\t\tDP(BNX2X_MSG_ETHTOOL, \"  MAC loopback failed  (res %d)\\n\", res);\n\t\trc |= BNX2X_MAC_LOOPBACK_FAILED;\n\t}\n\n\tbnx2x_release_phy_lock(bp);\n\tbnx2x_netif_start(bp);\n\n\treturn rc;\n}\n\nstatic int bnx2x_test_ext_loopback(struct bnx2x *bp)\n{\n\tint rc;\n\tu8 is_serdes =\n\t\t(bp->link_vars.link_status & LINK_STATUS_SERDES_LINK) > 0;\n\n\tif (BP_NOMCP(bp))\n\t\treturn -ENODEV;\n\n\tif (!netif_running(bp->dev))\n\t\treturn BNX2X_EXT_LOOPBACK_FAILED;\n\n\tbnx2x_nic_unload(bp, UNLOAD_NORMAL, false);\n\trc = bnx2x_nic_load(bp, LOAD_LOOPBACK_EXT);\n\tif (rc) {\n\t\tDP(BNX2X_MSG_ETHTOOL,\n\t\t   \"Can't perform self-test, nic_load (for external lb) failed\\n\");\n\t\treturn -ENODEV;\n\t}\n\tbnx2x_wait_for_link(bp, 1, is_serdes);\n\n\tbnx2x_netif_stop(bp, 1);\n\n\trc = bnx2x_run_loopback(bp, BNX2X_EXT_LOOPBACK);\n\tif (rc)\n\t\tDP(BNX2X_MSG_ETHTOOL, \"EXT loopback failed  (res %d)\\n\", rc);\n\n\tbnx2x_netif_start(bp);\n\n\treturn rc;\n}\n\nstruct code_entry {\n\tu32 sram_start_addr;\n\tu32 code_attribute;\n#define CODE_IMAGE_TYPE_MASK\t\t\t0xf0800003\n#define CODE_IMAGE_VNTAG_PROFILES_DATA\t\t0xd0000003\n#define CODE_IMAGE_LENGTH_MASK\t\t\t0x007ffffc\n#define CODE_IMAGE_TYPE_EXTENDED_DIR\t\t0xe0000000\n\tu32 nvm_start_addr;\n};\n\n#define CODE_ENTRY_MAX\t\t\t16\n#define CODE_ENTRY_EXTENDED_DIR_IDX\t15\n#define MAX_IMAGES_IN_EXTENDED_DIR\t64\n#define NVRAM_DIR_OFFSET\t\t0x14\n\n#define EXTENDED_DIR_EXISTS(code)\t\t\t\t\t  \\\n\t((code & CODE_IMAGE_TYPE_MASK) == CODE_IMAGE_TYPE_EXTENDED_DIR && \\\n\t (code & CODE_IMAGE_LENGTH_MASK) != 0)\n\n#define CRC32_RESIDUAL\t\t\t0xdebb20e3\n#define CRC_BUFF_SIZE\t\t\t256\n\nstatic int bnx2x_nvram_crc(struct bnx2x *bp,\n\t\t\t   int offset,\n\t\t\t   int size,\n\t\t\t   u8 *buff)\n{\n\tu32 crc = ~0;\n\tint rc = 0, done = 0;\n\n\tDP(BNX2X_MSG_ETHTOOL | BNX2X_MSG_NVM,\n\t   \"NVRAM CRC from 0x%08x to 0x%08x\\n\", offset, offset + size);\n\n\twhile (done < size) {\n\t\tint count = min_t(int, size - done, CRC_BUFF_SIZE);\n\n\t\trc = bnx2x_nvram_read(bp, offset + done, buff, count);\n\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\tcrc = crc32_le(crc, buff, count);\n\t\tdone += count;\n\t}\n\n\tif (crc != CRC32_RESIDUAL)\n\t\trc = -EINVAL;\n\n\treturn rc;\n}\n\nstatic int bnx2x_test_nvram_dir(struct bnx2x *bp,\n\t\t\t\tstruct code_entry *entry,\n\t\t\t\tu8 *buff)\n{\n\tsize_t size = entry->code_attribute & CODE_IMAGE_LENGTH_MASK;\n\tu32 type = entry->code_attribute & CODE_IMAGE_TYPE_MASK;\n\tint rc;\n\n\t \n\tif (size == 0 || type == CODE_IMAGE_VNTAG_PROFILES_DATA)\n\t\treturn 0;\n\n\trc = bnx2x_nvram_crc(bp, entry->nvm_start_addr, size, buff);\n\tif (rc)\n\t\tDP(BNX2X_MSG_ETHTOOL | BNX2X_MSG_NVM,\n\t\t   \"image %x has failed crc test (rc %d)\\n\", type, rc);\n\n\treturn rc;\n}\n\nstatic int bnx2x_test_dir_entry(struct bnx2x *bp, u32 addr, u8 *buff)\n{\n\tint rc;\n\tstruct code_entry entry;\n\n\trc = bnx2x_nvram_read32(bp, addr, (u32 *)&entry, sizeof(entry));\n\tif (rc)\n\t\treturn rc;\n\n\treturn bnx2x_test_nvram_dir(bp, &entry, buff);\n}\n\nstatic int bnx2x_test_nvram_ext_dirs(struct bnx2x *bp, u8 *buff)\n{\n\tu32 rc, cnt, dir_offset = NVRAM_DIR_OFFSET;\n\tstruct code_entry entry;\n\tint i;\n\n\trc = bnx2x_nvram_read32(bp,\n\t\t\t\tdir_offset +\n\t\t\t\tsizeof(entry) * CODE_ENTRY_EXTENDED_DIR_IDX,\n\t\t\t\t(u32 *)&entry, sizeof(entry));\n\tif (rc)\n\t\treturn rc;\n\n\tif (!EXTENDED_DIR_EXISTS(entry.code_attribute))\n\t\treturn 0;\n\n\trc = bnx2x_nvram_read32(bp, entry.nvm_start_addr,\n\t\t\t\t&cnt, sizeof(u32));\n\tif (rc)\n\t\treturn rc;\n\n\tdir_offset = entry.nvm_start_addr + 8;\n\n\tfor (i = 0; i < cnt && i < MAX_IMAGES_IN_EXTENDED_DIR; i++) {\n\t\trc = bnx2x_test_dir_entry(bp, dir_offset +\n\t\t\t\t\t      sizeof(struct code_entry) * i,\n\t\t\t\t\t  buff);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\treturn 0;\n}\n\nstatic int bnx2x_test_nvram_dirs(struct bnx2x *bp, u8 *buff)\n{\n\tu32 rc, dir_offset = NVRAM_DIR_OFFSET;\n\tint i;\n\n\tDP(BNX2X_MSG_ETHTOOL | BNX2X_MSG_NVM, \"NVRAM DIRS CRC test-set\\n\");\n\n\tfor (i = 0; i < CODE_ENTRY_EXTENDED_DIR_IDX; i++) {\n\t\trc = bnx2x_test_dir_entry(bp, dir_offset +\n\t\t\t\t\t      sizeof(struct code_entry) * i,\n\t\t\t\t\t  buff);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\treturn bnx2x_test_nvram_ext_dirs(bp, buff);\n}\n\nstruct crc_pair {\n\tint offset;\n\tint size;\n};\n\nstatic int bnx2x_test_nvram_tbl(struct bnx2x *bp,\n\t\t\t\tconst struct crc_pair *nvram_tbl, u8 *buf)\n{\n\tint i;\n\n\tfor (i = 0; nvram_tbl[i].size; i++) {\n\t\tint rc = bnx2x_nvram_crc(bp, nvram_tbl[i].offset,\n\t\t\t\t\t nvram_tbl[i].size, buf);\n\t\tif (rc) {\n\t\t\tDP(BNX2X_MSG_ETHTOOL | BNX2X_MSG_NVM,\n\t\t\t   \"nvram_tbl[%d] has failed crc test (rc %d)\\n\",\n\t\t\t   i, rc);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int bnx2x_test_nvram(struct bnx2x *bp)\n{\n\tstatic const struct crc_pair nvram_tbl[] = {\n\t\t{     0,  0x14 },  \n\t\t{  0x14,  0xec },  \n\t\t{ 0x100, 0x350 },  \n\t\t{ 0x450,  0xf0 },  \n\t\t{ 0x640,  0x64 },  \n\t\t{ 0x708,  0x70 },  \n\t\t{     0,     0 }\n\t};\n\tstatic const struct crc_pair nvram_tbl2[] = {\n\t\t{ 0x7e8, 0x350 },  \n\t\t{ 0xb38,  0xf0 },  \n\t\t{     0,     0 }\n\t};\n\n\tu8 *buf;\n\tint rc;\n\tu32 magic;\n\n\tif (BP_NOMCP(bp))\n\t\treturn 0;\n\n\tbuf = kmalloc(CRC_BUFF_SIZE, GFP_KERNEL);\n\tif (!buf) {\n\t\tDP(BNX2X_MSG_ETHTOOL | BNX2X_MSG_NVM, \"kmalloc failed\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto test_nvram_exit;\n\t}\n\n\trc = bnx2x_nvram_read32(bp, 0, &magic, sizeof(magic));\n\tif (rc) {\n\t\tDP(BNX2X_MSG_ETHTOOL | BNX2X_MSG_NVM,\n\t\t   \"magic value read (rc %d)\\n\", rc);\n\t\tgoto test_nvram_exit;\n\t}\n\n\tif (magic != 0x669955aa) {\n\t\tDP(BNX2X_MSG_ETHTOOL | BNX2X_MSG_NVM,\n\t\t   \"wrong magic value (0x%08x)\\n\", magic);\n\t\trc = -ENODEV;\n\t\tgoto test_nvram_exit;\n\t}\n\n\tDP(BNX2X_MSG_ETHTOOL | BNX2X_MSG_NVM, \"Port 0 CRC test-set\\n\");\n\trc = bnx2x_test_nvram_tbl(bp, nvram_tbl, buf);\n\tif (rc)\n\t\tgoto test_nvram_exit;\n\n\tif (!CHIP_IS_E1x(bp) && !CHIP_IS_57811xx(bp)) {\n\t\tu32 hide = SHMEM_RD(bp, dev_info.shared_hw_config.config2) &\n\t\t\t   SHARED_HW_CFG_HIDE_PORT1;\n\n\t\tif (!hide) {\n\t\t\tDP(BNX2X_MSG_ETHTOOL | BNX2X_MSG_NVM,\n\t\t\t   \"Port 1 CRC test-set\\n\");\n\t\t\trc = bnx2x_test_nvram_tbl(bp, nvram_tbl2, buf);\n\t\t\tif (rc)\n\t\t\t\tgoto test_nvram_exit;\n\t\t}\n\t}\n\n\trc = bnx2x_test_nvram_dirs(bp, buf);\n\ntest_nvram_exit:\n\tkfree(buf);\n\treturn rc;\n}\n\n \nstatic int bnx2x_test_intr(struct bnx2x *bp)\n{\n\tstruct bnx2x_queue_state_params params = {NULL};\n\n\tif (!netif_running(bp->dev)) {\n\t\tDP(BNX2X_MSG_ETHTOOL | BNX2X_MSG_NVM,\n\t\t   \"cannot access eeprom when the interface is down\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tparams.q_obj = &bp->sp_objs->q_obj;\n\tparams.cmd = BNX2X_Q_CMD_EMPTY;\n\n\t__set_bit(RAMROD_COMP_WAIT, &params.ramrod_flags);\n\n\treturn bnx2x_queue_state_change(bp, &params);\n}\n\nstatic void bnx2x_self_test(struct net_device *dev,\n\t\t\t    struct ethtool_test *etest, u64 *buf)\n{\n\tstruct bnx2x *bp = netdev_priv(dev);\n\tu8 is_serdes, link_up;\n\tint rc, cnt = 0;\n\n\tif (pci_num_vf(bp->pdev)) {\n\t\tDP(BNX2X_MSG_IOV,\n\t\t   \"VFs are enabled, can not perform self test\\n\");\n\t\treturn;\n\t}\n\n\tif (bp->recovery_state != BNX2X_RECOVERY_DONE) {\n\t\tnetdev_err(bp->dev,\n\t\t\t   \"Handling parity error recovery. Try again later\\n\");\n\t\tetest->flags |= ETH_TEST_FL_FAILED;\n\t\treturn;\n\t}\n\n\tDP(BNX2X_MSG_ETHTOOL,\n\t   \"Self-test command parameters: offline = %d, external_lb = %d\\n\",\n\t   (etest->flags & ETH_TEST_FL_OFFLINE),\n\t   (etest->flags & ETH_TEST_FL_EXTERNAL_LB)>>2);\n\n\tmemset(buf, 0, sizeof(u64) * BNX2X_NUM_TESTS(bp));\n\n\tif (bnx2x_test_nvram(bp) != 0) {\n\t\tif (!IS_MF(bp))\n\t\t\tbuf[4] = 1;\n\t\telse\n\t\t\tbuf[0] = 1;\n\t\tetest->flags |= ETH_TEST_FL_FAILED;\n\t}\n\n\tif (!netif_running(dev)) {\n\t\tDP(BNX2X_MSG_ETHTOOL, \"Interface is down\\n\");\n\t\treturn;\n\t}\n\n\tis_serdes = (bp->link_vars.link_status & LINK_STATUS_SERDES_LINK) > 0;\n\tlink_up = bp->link_vars.link_up;\n\t \n\tif ((etest->flags & ETH_TEST_FL_OFFLINE) && !IS_MF(bp)) {\n\t\tint port = BP_PORT(bp);\n\t\tu32 val;\n\n\t\t \n\t\tval = REG_RD(bp, NIG_REG_EGRESS_UMP0_IN_EN + port*4);\n\t\t \n\t\tREG_WR(bp, NIG_REG_EGRESS_UMP0_IN_EN + port*4, 0);\n\n\t\tbnx2x_nic_unload(bp, UNLOAD_NORMAL, false);\n\t\trc = bnx2x_nic_load(bp, LOAD_DIAG);\n\t\tif (rc) {\n\t\t\tetest->flags |= ETH_TEST_FL_FAILED;\n\t\t\tDP(BNX2X_MSG_ETHTOOL,\n\t\t\t   \"Can't perform self-test, nic_load (for offline) failed\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tbnx2x_wait_for_link(bp, 1, is_serdes);\n\n\t\tif (bnx2x_test_registers(bp) != 0) {\n\t\t\tbuf[0] = 1;\n\t\t\tetest->flags |= ETH_TEST_FL_FAILED;\n\t\t}\n\t\tif (bnx2x_test_memory(bp) != 0) {\n\t\t\tbuf[1] = 1;\n\t\t\tetest->flags |= ETH_TEST_FL_FAILED;\n\t\t}\n\n\t\tbuf[2] = bnx2x_test_loopback(bp);  \n\t\tif (buf[2] != 0)\n\t\t\tetest->flags |= ETH_TEST_FL_FAILED;\n\n\t\tif (etest->flags & ETH_TEST_FL_EXTERNAL_LB) {\n\t\t\tbuf[3] = bnx2x_test_ext_loopback(bp);  \n\t\t\tif (buf[3] != 0)\n\t\t\t\tetest->flags |= ETH_TEST_FL_FAILED;\n\t\t\tetest->flags |= ETH_TEST_FL_EXTERNAL_LB_DONE;\n\t\t}\n\n\t\tbnx2x_nic_unload(bp, UNLOAD_NORMAL, false);\n\n\t\t \n\t\tREG_WR(bp, NIG_REG_EGRESS_UMP0_IN_EN + port*4, val);\n\t\trc = bnx2x_nic_load(bp, LOAD_NORMAL);\n\t\tif (rc) {\n\t\t\tetest->flags |= ETH_TEST_FL_FAILED;\n\t\t\tDP(BNX2X_MSG_ETHTOOL,\n\t\t\t   \"Can't perform self-test, nic_load (for online) failed\\n\");\n\t\t\treturn;\n\t\t}\n\t\t \n\t\tbnx2x_wait_for_link(bp, link_up, is_serdes);\n\t}\n\n\tif (bnx2x_test_intr(bp) != 0) {\n\t\tif (!IS_MF(bp))\n\t\t\tbuf[5] = 1;\n\t\telse\n\t\t\tbuf[1] = 1;\n\t\tetest->flags |= ETH_TEST_FL_FAILED;\n\t}\n\n\tif (link_up) {\n\t\tcnt = 100;\n\t\twhile (bnx2x_link_test(bp, is_serdes) && --cnt)\n\t\t\tmsleep(20);\n\t}\n\n\tif (!cnt) {\n\t\tif (!IS_MF(bp))\n\t\t\tbuf[6] = 1;\n\t\telse\n\t\t\tbuf[2] = 1;\n\t\tetest->flags |= ETH_TEST_FL_FAILED;\n\t}\n}\n\n#define IS_PORT_STAT(i)\t\t(bnx2x_stats_arr[i].is_port_stat)\n#define HIDE_PORT_STAT(bp)\tIS_VF(bp)\n\n \nstatic int bnx2x_num_stat_queues(struct bnx2x *bp)\n{\n\treturn BNX2X_NUM_ETH_QUEUES(bp);\n}\n\nstatic int bnx2x_get_sset_count(struct net_device *dev, int stringset)\n{\n\tstruct bnx2x *bp = netdev_priv(dev);\n\tint i, num_strings = 0;\n\n\tswitch (stringset) {\n\tcase ETH_SS_STATS:\n\t\tif (is_multi(bp)) {\n\t\t\tnum_strings = bnx2x_num_stat_queues(bp) *\n\t\t\t\t      BNX2X_NUM_Q_STATS;\n\t\t} else\n\t\t\tnum_strings = 0;\n\t\tif (HIDE_PORT_STAT(bp)) {\n\t\t\tfor (i = 0; i < BNX2X_NUM_STATS; i++)\n\t\t\t\tif (!IS_PORT_STAT(i))\n\t\t\t\t\tnum_strings++;\n\t\t} else\n\t\t\tnum_strings += BNX2X_NUM_STATS;\n\n\t\treturn num_strings;\n\n\tcase ETH_SS_TEST:\n\t\treturn BNX2X_NUM_TESTS(bp);\n\n\tcase ETH_SS_PRIV_FLAGS:\n\t\treturn BNX2X_PRI_FLAG_LEN;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic u32 bnx2x_get_private_flags(struct net_device *dev)\n{\n\tstruct bnx2x *bp = netdev_priv(dev);\n\tu32 flags = 0;\n\n\tflags |= (!(bp->flags & NO_ISCSI_FLAG) ? 1 : 0) << BNX2X_PRI_FLAG_ISCSI;\n\tflags |= (!(bp->flags & NO_FCOE_FLAG)  ? 1 : 0) << BNX2X_PRI_FLAG_FCOE;\n\tflags |= (!!IS_MF_STORAGE_ONLY(bp)) << BNX2X_PRI_FLAG_STORAGE;\n\n\treturn flags;\n}\n\nstatic void bnx2x_get_strings(struct net_device *dev, u32 stringset, u8 *buf)\n{\n\tstruct bnx2x *bp = netdev_priv(dev);\n\tint i, j, k, start;\n\tchar queue_name[MAX_QUEUE_NAME_LEN+1];\n\n\tswitch (stringset) {\n\tcase ETH_SS_STATS:\n\t\tk = 0;\n\t\tif (is_multi(bp)) {\n\t\t\tfor_each_eth_queue(bp, i) {\n\t\t\t\tmemset(queue_name, 0, sizeof(queue_name));\n\t\t\t\tsnprintf(queue_name, sizeof(queue_name),\n\t\t\t\t\t \"%d\", i);\n\t\t\t\tfor (j = 0; j < BNX2X_NUM_Q_STATS; j++)\n\t\t\t\t\tsnprintf(buf + (k + j)*ETH_GSTRING_LEN,\n\t\t\t\t\t\tETH_GSTRING_LEN,\n\t\t\t\t\t\tbnx2x_q_stats_arr[j].string,\n\t\t\t\t\t\tqueue_name);\n\t\t\t\tk += BNX2X_NUM_Q_STATS;\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0, j = 0; i < BNX2X_NUM_STATS; i++) {\n\t\t\tif (HIDE_PORT_STAT(bp) && IS_PORT_STAT(i))\n\t\t\t\tcontinue;\n\t\t\tstrcpy(buf + (k + j)*ETH_GSTRING_LEN,\n\t\t\t\t   bnx2x_stats_arr[i].string);\n\t\t\tj++;\n\t\t}\n\n\t\tbreak;\n\n\tcase ETH_SS_TEST:\n\t\t \n\t\tif (!IS_MF(bp))\n\t\t\tstart = 0;\n\t\telse\n\t\t\tstart = 4;\n\t\tmemcpy(buf, bnx2x_tests_str_arr + start,\n\t\t       ETH_GSTRING_LEN * BNX2X_NUM_TESTS(bp));\n\t\tbreak;\n\n\tcase ETH_SS_PRIV_FLAGS:\n\t\tmemcpy(buf, bnx2x_private_arr,\n\t\t       ETH_GSTRING_LEN * BNX2X_PRI_FLAG_LEN);\n\t\tbreak;\n\t}\n}\n\nstatic void bnx2x_get_ethtool_stats(struct net_device *dev,\n\t\t\t\t    struct ethtool_stats *stats, u64 *buf)\n{\n\tstruct bnx2x *bp = netdev_priv(dev);\n\tu32 *hw_stats, *offset;\n\tint i, j, k = 0;\n\n\tif (is_multi(bp)) {\n\t\tfor_each_eth_queue(bp, i) {\n\t\t\thw_stats = (u32 *)&bp->fp_stats[i].eth_q_stats;\n\t\t\tfor (j = 0; j < BNX2X_NUM_Q_STATS; j++) {\n\t\t\t\tif (bnx2x_q_stats_arr[j].size == 0) {\n\t\t\t\t\t \n\t\t\t\t\tbuf[k + j] = 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\toffset = (hw_stats +\n\t\t\t\t\t  bnx2x_q_stats_arr[j].offset);\n\t\t\t\tif (bnx2x_q_stats_arr[j].size == 4) {\n\t\t\t\t\t \n\t\t\t\t\tbuf[k + j] = (u64) *offset;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t \n\t\t\t\tbuf[k + j] = HILO_U64(*offset, *(offset + 1));\n\t\t\t}\n\t\t\tk += BNX2X_NUM_Q_STATS;\n\t\t}\n\t}\n\n\thw_stats = (u32 *)&bp->eth_stats;\n\tfor (i = 0, j = 0; i < BNX2X_NUM_STATS; i++) {\n\t\tif (HIDE_PORT_STAT(bp) && IS_PORT_STAT(i))\n\t\t\tcontinue;\n\t\tif (bnx2x_stats_arr[i].size == 0) {\n\t\t\t \n\t\t\tbuf[k + j] = 0;\n\t\t\tj++;\n\t\t\tcontinue;\n\t\t}\n\t\toffset = (hw_stats + bnx2x_stats_arr[i].offset);\n\t\tif (bnx2x_stats_arr[i].size == 4) {\n\t\t\t \n\t\t\tbuf[k + j] = (u64) *offset;\n\t\t\tj++;\n\t\t\tcontinue;\n\t\t}\n\t\t \n\t\tbuf[k + j] = HILO_U64(*offset, *(offset + 1));\n\t\tj++;\n\t}\n}\n\nstatic int bnx2x_set_phys_id(struct net_device *dev,\n\t\t\t     enum ethtool_phys_id_state state)\n{\n\tstruct bnx2x *bp = netdev_priv(dev);\n\n\tif (!bnx2x_is_nvm_accessible(bp)) {\n\t\tDP(BNX2X_MSG_ETHTOOL | BNX2X_MSG_NVM,\n\t\t   \"cannot access eeprom when the interface is down\\n\");\n\t\treturn -EAGAIN;\n\t}\n\n\tswitch (state) {\n\tcase ETHTOOL_ID_ACTIVE:\n\t\treturn 1;\t \n\n\tcase ETHTOOL_ID_ON:\n\t\tbnx2x_acquire_phy_lock(bp);\n\t\tbnx2x_set_led(&bp->link_params, &bp->link_vars,\n\t\t\t      LED_MODE_ON, SPEED_1000);\n\t\tbnx2x_release_phy_lock(bp);\n\t\tbreak;\n\n\tcase ETHTOOL_ID_OFF:\n\t\tbnx2x_acquire_phy_lock(bp);\n\t\tbnx2x_set_led(&bp->link_params, &bp->link_vars,\n\t\t\t      LED_MODE_FRONT_PANEL_OFF, 0);\n\t\tbnx2x_release_phy_lock(bp);\n\t\tbreak;\n\n\tcase ETHTOOL_ID_INACTIVE:\n\t\tbnx2x_acquire_phy_lock(bp);\n\t\tbnx2x_set_led(&bp->link_params, &bp->link_vars,\n\t\t\t      LED_MODE_OPER,\n\t\t\t      bp->link_vars.line_speed);\n\t\tbnx2x_release_phy_lock(bp);\n\t}\n\n\treturn 0;\n}\n\nstatic int bnx2x_get_rss_flags(struct bnx2x *bp, struct ethtool_rxnfc *info)\n{\n\tswitch (info->flow_type) {\n\tcase TCP_V4_FLOW:\n\tcase TCP_V6_FLOW:\n\t\tinfo->data = RXH_IP_SRC | RXH_IP_DST |\n\t\t\t     RXH_L4_B_0_1 | RXH_L4_B_2_3;\n\t\tbreak;\n\tcase UDP_V4_FLOW:\n\t\tif (bp->rss_conf_obj.udp_rss_v4)\n\t\t\tinfo->data = RXH_IP_SRC | RXH_IP_DST |\n\t\t\t\t     RXH_L4_B_0_1 | RXH_L4_B_2_3;\n\t\telse\n\t\t\tinfo->data = RXH_IP_SRC | RXH_IP_DST;\n\t\tbreak;\n\tcase UDP_V6_FLOW:\n\t\tif (bp->rss_conf_obj.udp_rss_v6)\n\t\t\tinfo->data = RXH_IP_SRC | RXH_IP_DST |\n\t\t\t\t     RXH_L4_B_0_1 | RXH_L4_B_2_3;\n\t\telse\n\t\t\tinfo->data = RXH_IP_SRC | RXH_IP_DST;\n\t\tbreak;\n\tcase IPV4_FLOW:\n\tcase IPV6_FLOW:\n\t\tinfo->data = RXH_IP_SRC | RXH_IP_DST;\n\t\tbreak;\n\tdefault:\n\t\tinfo->data = 0;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int bnx2x_get_rxnfc(struct net_device *dev, struct ethtool_rxnfc *info,\n\t\t\t   u32 *rules __always_unused)\n{\n\tstruct bnx2x *bp = netdev_priv(dev);\n\n\tswitch (info->cmd) {\n\tcase ETHTOOL_GRXRINGS:\n\t\tinfo->data = BNX2X_NUM_ETH_QUEUES(bp);\n\t\treturn 0;\n\tcase ETHTOOL_GRXFH:\n\t\treturn bnx2x_get_rss_flags(bp, info);\n\tdefault:\n\t\tDP(BNX2X_MSG_ETHTOOL, \"Command parameters not supported\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int bnx2x_set_rss_flags(struct bnx2x *bp, struct ethtool_rxnfc *info)\n{\n\tint udp_rss_requested;\n\n\tDP(BNX2X_MSG_ETHTOOL,\n\t   \"Set rss flags command parameters: flow type = %d, data = %llu\\n\",\n\t   info->flow_type, info->data);\n\n\tswitch (info->flow_type) {\n\tcase TCP_V4_FLOW:\n\tcase TCP_V6_FLOW:\n\t\t \n\t\tif (info->data ^ (RXH_IP_SRC | RXH_IP_DST |\n\t\t\t\t  RXH_L4_B_0_1 | RXH_L4_B_2_3)) {\n\t\t\tDP(BNX2X_MSG_ETHTOOL,\n\t\t\t   \"Command parameters not supported\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\treturn 0;\n\n\tcase UDP_V4_FLOW:\n\tcase UDP_V6_FLOW:\n\t\t \n\t\tif (info->data == (RXH_IP_SRC | RXH_IP_DST |\n\t\t\t\t   RXH_L4_B_0_1 | RXH_L4_B_2_3))\n\t\t\tudp_rss_requested = 1;\n\t\telse if (info->data == (RXH_IP_SRC | RXH_IP_DST))\n\t\t\tudp_rss_requested = 0;\n\t\telse\n\t\t\treturn -EINVAL;\n\n\t\tif (CHIP_IS_E1x(bp) && udp_rss_requested) {\n\t\t\tDP(BNX2X_MSG_ETHTOOL,\n\t\t\t   \"57710, 57711 boards don't support RSS according to UDP 4-tuple\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif ((info->flow_type == UDP_V4_FLOW) &&\n\t\t    (bp->rss_conf_obj.udp_rss_v4 != udp_rss_requested)) {\n\t\t\tbp->rss_conf_obj.udp_rss_v4 = udp_rss_requested;\n\t\t\tDP(BNX2X_MSG_ETHTOOL,\n\t\t\t   \"rss re-configured, UDP 4-tupple %s\\n\",\n\t\t\t   udp_rss_requested ? \"enabled\" : \"disabled\");\n\t\t\tif (bp->state == BNX2X_STATE_OPEN)\n\t\t\t\treturn bnx2x_rss(bp, &bp->rss_conf_obj, false,\n\t\t\t\t\t\t true);\n\t\t} else if ((info->flow_type == UDP_V6_FLOW) &&\n\t\t\t   (bp->rss_conf_obj.udp_rss_v6 != udp_rss_requested)) {\n\t\t\tbp->rss_conf_obj.udp_rss_v6 = udp_rss_requested;\n\t\t\tDP(BNX2X_MSG_ETHTOOL,\n\t\t\t   \"rss re-configured, UDP 4-tupple %s\\n\",\n\t\t\t   udp_rss_requested ? \"enabled\" : \"disabled\");\n\t\t\tif (bp->state == BNX2X_STATE_OPEN)\n\t\t\t\treturn bnx2x_rss(bp, &bp->rss_conf_obj, false,\n\t\t\t\t\t\t true);\n\t\t}\n\t\treturn 0;\n\n\tcase IPV4_FLOW:\n\tcase IPV6_FLOW:\n\t\t \n\t\tif (info->data ^ (RXH_IP_SRC | RXH_IP_DST)) {\n\t\t\tDP(BNX2X_MSG_ETHTOOL,\n\t\t\t   \"Command parameters not supported\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\treturn 0;\n\n\tcase SCTP_V4_FLOW:\n\tcase AH_ESP_V4_FLOW:\n\tcase AH_V4_FLOW:\n\tcase ESP_V4_FLOW:\n\tcase SCTP_V6_FLOW:\n\tcase AH_ESP_V6_FLOW:\n\tcase AH_V6_FLOW:\n\tcase ESP_V6_FLOW:\n\tcase IP_USER_FLOW:\n\tcase ETHER_FLOW:\n\t\t \n\t\tif (info->data) {\n\t\t\tDP(BNX2X_MSG_ETHTOOL,\n\t\t\t   \"Command parameters not supported\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\treturn 0;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int bnx2x_set_rxnfc(struct net_device *dev, struct ethtool_rxnfc *info)\n{\n\tstruct bnx2x *bp = netdev_priv(dev);\n\n\tswitch (info->cmd) {\n\tcase ETHTOOL_SRXFH:\n\t\treturn bnx2x_set_rss_flags(bp, info);\n\tdefault:\n\t\tDP(BNX2X_MSG_ETHTOOL, \"Command parameters not supported\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic u32 bnx2x_get_rxfh_indir_size(struct net_device *dev)\n{\n\treturn T_ETH_INDIRECTION_TABLE_SIZE;\n}\n\nstatic int bnx2x_get_rxfh(struct net_device *dev, u32 *indir, u8 *key,\n\t\t\t  u8 *hfunc)\n{\n\tstruct bnx2x *bp = netdev_priv(dev);\n\tu8 ind_table[T_ETH_INDIRECTION_TABLE_SIZE] = {0};\n\tsize_t i;\n\n\tif (hfunc)\n\t\t*hfunc = ETH_RSS_HASH_TOP;\n\tif (!indir)\n\t\treturn 0;\n\n\t \n\tbnx2x_get_rss_ind_table(&bp->rss_conf_obj, ind_table);\n\n\t \n\tfor (i = 0; i < T_ETH_INDIRECTION_TABLE_SIZE; i++)\n\t\tindir[i] = ind_table[i] - bp->fp->cl_id;\n\n\treturn 0;\n}\n\nstatic int bnx2x_set_rxfh(struct net_device *dev, const u32 *indir,\n\t\t\t  const u8 *key, const u8 hfunc)\n{\n\tstruct bnx2x *bp = netdev_priv(dev);\n\tsize_t i;\n\n\t \n\tif (key ||\n\t    (hfunc != ETH_RSS_HASH_NO_CHANGE && hfunc != ETH_RSS_HASH_TOP))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!indir)\n\t\treturn 0;\n\n\tfor (i = 0; i < T_ETH_INDIRECTION_TABLE_SIZE; i++) {\n\t\t \n\t\tbp->rss_conf_obj.ind_table[i] = indir[i] + bp->fp->cl_id;\n\t}\n\n\tif (bp->state == BNX2X_STATE_OPEN)\n\t\treturn bnx2x_config_rss_eth(bp, false);\n\n\treturn 0;\n}\n\n \nstatic void bnx2x_get_channels(struct net_device *dev,\n\t\t\t       struct ethtool_channels *channels)\n{\n\tstruct bnx2x *bp = netdev_priv(dev);\n\n\tchannels->max_combined = BNX2X_MAX_RSS_COUNT(bp);\n\tchannels->combined_count = BNX2X_NUM_ETH_QUEUES(bp);\n}\n\n \nstatic void bnx2x_change_num_queues(struct bnx2x *bp, int num_rss)\n{\n\tbnx2x_disable_msi(bp);\n\tbp->num_ethernet_queues = num_rss;\n\tbp->num_queues = bp->num_ethernet_queues + bp->num_cnic_queues;\n\tBNX2X_DEV_INFO(\"set number of queues to %d\\n\", bp->num_queues);\n\tbnx2x_set_int_mode(bp);\n}\n\n \nstatic int bnx2x_set_channels(struct net_device *dev,\n\t\t\t      struct ethtool_channels *channels)\n{\n\tstruct bnx2x *bp = netdev_priv(dev);\n\n\tDP(BNX2X_MSG_ETHTOOL,\n\t   \"set-channels command parameters: rx = %d, tx = %d, other = %d, combined = %d\\n\",\n\t   channels->rx_count, channels->tx_count, channels->other_count,\n\t   channels->combined_count);\n\n\tif (pci_num_vf(bp->pdev)) {\n\t\tDP(BNX2X_MSG_IOV, \"VFs are enabled, can not set channels\\n\");\n\t\treturn -EPERM;\n\t}\n\n\t \n\tif (channels->rx_count || channels->tx_count || channels->other_count\n\t    || (channels->combined_count == 0) ||\n\t    (channels->combined_count > BNX2X_MAX_RSS_COUNT(bp))) {\n\t\tDP(BNX2X_MSG_ETHTOOL, \"command parameters not supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (channels->combined_count == BNX2X_NUM_ETH_QUEUES(bp)) {\n\t\tDP(BNX2X_MSG_ETHTOOL, \"No change in active parameters\\n\");\n\t\treturn 0;\n\t}\n\n\t \n\tif (unlikely(!netif_running(dev))) {\n\t\tbnx2x_change_num_queues(bp, channels->combined_count);\n\t\treturn 0;\n\t}\n\tbnx2x_nic_unload(bp, UNLOAD_NORMAL, true);\n\tbnx2x_change_num_queues(bp, channels->combined_count);\n\treturn bnx2x_nic_load(bp, LOAD_NORMAL);\n}\n\nstatic int bnx2x_get_ts_info(struct net_device *dev,\n\t\t\t     struct ethtool_ts_info *info)\n{\n\tstruct bnx2x *bp = netdev_priv(dev);\n\n\tif (bp->flags & PTP_SUPPORTED) {\n\t\tinfo->so_timestamping = SOF_TIMESTAMPING_TX_SOFTWARE |\n\t\t\t\t\tSOF_TIMESTAMPING_RX_SOFTWARE |\n\t\t\t\t\tSOF_TIMESTAMPING_SOFTWARE |\n\t\t\t\t\tSOF_TIMESTAMPING_TX_HARDWARE |\n\t\t\t\t\tSOF_TIMESTAMPING_RX_HARDWARE |\n\t\t\t\t\tSOF_TIMESTAMPING_RAW_HARDWARE;\n\n\t\tif (bp->ptp_clock)\n\t\t\tinfo->phc_index = ptp_clock_index(bp->ptp_clock);\n\t\telse\n\t\t\tinfo->phc_index = -1;\n\n\t\tinfo->rx_filters = (1 << HWTSTAMP_FILTER_NONE) |\n\t\t\t\t   (1 << HWTSTAMP_FILTER_PTP_V1_L4_EVENT) |\n\t\t\t\t   (1 << HWTSTAMP_FILTER_PTP_V2_L4_EVENT) |\n\t\t\t\t   (1 << HWTSTAMP_FILTER_PTP_V2_EVENT);\n\n\t\tinfo->tx_types = (1 << HWTSTAMP_TX_OFF)|(1 << HWTSTAMP_TX_ON);\n\n\t\treturn 0;\n\t}\n\n\treturn ethtool_op_get_ts_info(dev, info);\n}\n\nstatic const struct ethtool_ops bnx2x_ethtool_ops = {\n\t.supported_coalesce_params = ETHTOOL_COALESCE_USECS,\n\t.get_drvinfo\t\t= bnx2x_get_drvinfo,\n\t.get_regs_len\t\t= bnx2x_get_regs_len,\n\t.get_regs\t\t= bnx2x_get_regs,\n\t.get_dump_flag\t\t= bnx2x_get_dump_flag,\n\t.get_dump_data\t\t= bnx2x_get_dump_data,\n\t.set_dump\t\t= bnx2x_set_dump,\n\t.get_wol\t\t= bnx2x_get_wol,\n\t.set_wol\t\t= bnx2x_set_wol,\n\t.get_msglevel\t\t= bnx2x_get_msglevel,\n\t.set_msglevel\t\t= bnx2x_set_msglevel,\n\t.nway_reset\t\t= bnx2x_nway_reset,\n\t.get_link\t\t= bnx2x_get_link,\n\t.get_eeprom_len\t\t= bnx2x_get_eeprom_len,\n\t.get_eeprom\t\t= bnx2x_get_eeprom,\n\t.set_eeprom\t\t= bnx2x_set_eeprom,\n\t.get_coalesce\t\t= bnx2x_get_coalesce,\n\t.set_coalesce\t\t= bnx2x_set_coalesce,\n\t.get_ringparam\t\t= bnx2x_get_ringparam,\n\t.set_ringparam\t\t= bnx2x_set_ringparam,\n\t.get_pauseparam\t\t= bnx2x_get_pauseparam,\n\t.set_pauseparam\t\t= bnx2x_set_pauseparam,\n\t.self_test\t\t= bnx2x_self_test,\n\t.get_sset_count\t\t= bnx2x_get_sset_count,\n\t.get_priv_flags\t\t= bnx2x_get_private_flags,\n\t.get_strings\t\t= bnx2x_get_strings,\n\t.set_phys_id\t\t= bnx2x_set_phys_id,\n\t.get_ethtool_stats\t= bnx2x_get_ethtool_stats,\n\t.get_rxnfc\t\t= bnx2x_get_rxnfc,\n\t.set_rxnfc\t\t= bnx2x_set_rxnfc,\n\t.get_rxfh_indir_size\t= bnx2x_get_rxfh_indir_size,\n\t.get_rxfh\t\t= bnx2x_get_rxfh,\n\t.set_rxfh\t\t= bnx2x_set_rxfh,\n\t.get_channels\t\t= bnx2x_get_channels,\n\t.set_channels\t\t= bnx2x_set_channels,\n\t.get_module_info\t= bnx2x_get_module_info,\n\t.get_module_eeprom\t= bnx2x_get_module_eeprom,\n\t.get_eee\t\t= bnx2x_get_eee,\n\t.set_eee\t\t= bnx2x_set_eee,\n\t.get_ts_info\t\t= bnx2x_get_ts_info,\n\t.get_link_ksettings\t= bnx2x_get_link_ksettings,\n\t.set_link_ksettings\t= bnx2x_set_link_ksettings,\n};\n\nstatic const struct ethtool_ops bnx2x_vf_ethtool_ops = {\n\t.get_drvinfo\t\t= bnx2x_get_drvinfo,\n\t.get_msglevel\t\t= bnx2x_get_msglevel,\n\t.set_msglevel\t\t= bnx2x_set_msglevel,\n\t.get_link\t\t= bnx2x_get_link,\n\t.get_coalesce\t\t= bnx2x_get_coalesce,\n\t.get_ringparam\t\t= bnx2x_get_ringparam,\n\t.set_ringparam\t\t= bnx2x_set_ringparam,\n\t.get_sset_count\t\t= bnx2x_get_sset_count,\n\t.get_strings\t\t= bnx2x_get_strings,\n\t.get_ethtool_stats\t= bnx2x_get_ethtool_stats,\n\t.get_rxnfc\t\t= bnx2x_get_rxnfc,\n\t.set_rxnfc\t\t= bnx2x_set_rxnfc,\n\t.get_rxfh_indir_size\t= bnx2x_get_rxfh_indir_size,\n\t.get_rxfh\t\t= bnx2x_get_rxfh,\n\t.set_rxfh\t\t= bnx2x_set_rxfh,\n\t.get_channels\t\t= bnx2x_get_channels,\n\t.set_channels\t\t= bnx2x_set_channels,\n\t.get_link_ksettings\t= bnx2x_get_vf_link_ksettings,\n};\n\nvoid bnx2x_set_ethtool_ops(struct bnx2x *bp, struct net_device *netdev)\n{\n\tnetdev->ethtool_ops = (IS_PF(bp)) ?\n\t\t&bnx2x_ethtool_ops : &bnx2x_vf_ethtool_ops;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}