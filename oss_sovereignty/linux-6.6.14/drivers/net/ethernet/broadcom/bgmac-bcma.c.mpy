{
  "module_name": "bgmac-bcma.c",
  "hash_id": "ead4495b629e9d9802546b2c826e3c5d5071a620735b940b120ee41ff4453a55",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/broadcom/bgmac-bcma.c",
  "human_readable_source": " \n\n#define pr_fmt(fmt)\t\tKBUILD_MODNAME \": \" fmt\n\n#include <linux/bcma/bcma.h>\n#include <linux/brcmphy.h>\n#include <linux/etherdevice.h>\n#include <linux/of_mdio.h>\n#include <linux/of_net.h>\n#include \"bgmac.h\"\n\nstatic inline bool bgmac_is_bcm4707_family(struct bcma_device *core)\n{\n\tswitch (core->bus->chipinfo.id) {\n\tcase BCMA_CHIP_ID_BCM4707:\n\tcase BCMA_CHIP_ID_BCM47094:\n\tcase BCMA_CHIP_ID_BCM53018:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\n \n\nstatic u32 bcma_bgmac_read(struct bgmac *bgmac, u16 offset)\n{\n\treturn bcma_read32(bgmac->bcma.core, offset);\n}\n\nstatic void bcma_bgmac_write(struct bgmac *bgmac, u16 offset, u32 value)\n{\n\tbcma_write32(bgmac->bcma.core, offset, value);\n}\n\nstatic u32 bcma_bgmac_idm_read(struct bgmac *bgmac, u16 offset)\n{\n\treturn bcma_aread32(bgmac->bcma.core, offset);\n}\n\nstatic void bcma_bgmac_idm_write(struct bgmac *bgmac, u16 offset, u32 value)\n{\n\treturn bcma_awrite32(bgmac->bcma.core, offset, value);\n}\n\nstatic bool bcma_bgmac_clk_enabled(struct bgmac *bgmac)\n{\n\treturn bcma_core_is_enabled(bgmac->bcma.core);\n}\n\nstatic void bcma_bgmac_clk_enable(struct bgmac *bgmac, u32 flags)\n{\n\tbcma_core_enable(bgmac->bcma.core, flags);\n}\n\nstatic void bcma_bgmac_cco_ctl_maskset(struct bgmac *bgmac, u32 offset,\n\t\t\t\t       u32 mask, u32 set)\n{\n\tstruct bcma_drv_cc *cc = &bgmac->bcma.core->bus->drv_cc;\n\n\tbcma_chipco_chipctl_maskset(cc, offset, mask, set);\n}\n\nstatic u32 bcma_bgmac_get_bus_clock(struct bgmac *bgmac)\n{\n\tstruct bcma_drv_cc *cc = &bgmac->bcma.core->bus->drv_cc;\n\n\treturn bcma_pmu_get_bus_clock(cc);\n}\n\nstatic void bcma_bgmac_cmn_maskset32(struct bgmac *bgmac, u16 offset, u32 mask,\n\t\t\t\t     u32 set)\n{\n\tbcma_maskset32(bgmac->bcma.cmn, offset, mask, set);\n}\n\nstatic int bcma_phy_connect(struct bgmac *bgmac)\n{\n\tstruct phy_device *phy_dev;\n\tchar bus_id[MII_BUS_ID_SIZE + 3];\n\n\t \n\tphy_dev = of_phy_get_and_connect(bgmac->net_dev, bgmac->dev->of_node,\n\t\t\t\t\t bgmac_adjust_link);\n\tif (phy_dev)\n\t\treturn 0;\n\n\t \n\tif (bgmac->mii_bus && bgmac->phyaddr != BGMAC_PHY_NOREGS) {\n\t\tsnprintf(bus_id, sizeof(bus_id), PHY_ID_FMT, bgmac->mii_bus->id,\n\t\t\t bgmac->phyaddr);\n\t\tphy_dev = phy_connect(bgmac->net_dev, bus_id, bgmac_adjust_link,\n\t\t\t\t      PHY_INTERFACE_MODE_MII);\n\t\tif (IS_ERR(phy_dev)) {\n\t\t\tdev_err(bgmac->dev, \"PHY connection failed\\n\");\n\t\t\treturn PTR_ERR(phy_dev);\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\t \n\treturn bgmac_phy_connect_direct(bgmac);\n}\n\nstatic const struct bcma_device_id bgmac_bcma_tbl[] = {\n\tBCMA_CORE(BCMA_MANUF_BCM, BCMA_CORE_4706_MAC_GBIT,\n\t\t  BCMA_ANY_REV, BCMA_ANY_CLASS),\n\tBCMA_CORE(BCMA_MANUF_BCM, BCMA_CORE_MAC_GBIT, BCMA_ANY_REV,\n\t\t  BCMA_ANY_CLASS),\n\t{},\n};\nMODULE_DEVICE_TABLE(bcma, bgmac_bcma_tbl);\n\n \n\tif (err) {\n\t\tswitch (core->core_unit) {\n\t\tcase 0:\n\t\t\tmac = sprom->et0mac;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tmac = sprom->et1mac;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tmac = sprom->et2mac;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(bgmac->dev, \"Unsupported core_unit %d\\n\",\n\t\t\t\tcore->core_unit);\n\t\t\terr = -ENOTSUPP;\n\t\t\tgoto err;\n\t\t}\n\t\teth_hw_addr_set(bgmac->net_dev, mac);\n\t}\n\n\t \n\tif (core->id.id == BCMA_CORE_4706_MAC_GBIT &&\n\t    !core->bus->drv_gmac_cmn.core) {\n\t\tdev_err(bgmac->dev, \"GMAC CMN core not found (required for BCM4706)\\n\");\n\t\terr = -ENODEV;\n\t\tgoto err;\n\t}\n\tbgmac->bcma.cmn = core->bus->drv_gmac_cmn.core;\n\n\tswitch (core->core_unit) {\n\tcase 0:\n\t\tbgmac->phyaddr = sprom->et0phyaddr;\n\t\tbreak;\n\tcase 1:\n\t\tbgmac->phyaddr = sprom->et1phyaddr;\n\t\tbreak;\n\tcase 2:\n\t\tbgmac->phyaddr = sprom->et2phyaddr;\n\t\tbreak;\n\t}\n\tbgmac->phyaddr &= BGMAC_PHY_MASK;\n\tif (bgmac->phyaddr == BGMAC_PHY_MASK) {\n\t\tdev_err(bgmac->dev, \"No PHY found\\n\");\n\t\terr = -ENODEV;\n\t\tgoto err;\n\t}\n\tdev_info(bgmac->dev, \"Found PHY addr: %d%s\\n\", bgmac->phyaddr,\n\t\t bgmac->phyaddr == BGMAC_PHY_NOREGS ? \" (NOREGS)\" : \"\");\n\n\tif (!bgmac_is_bcm4707_family(core) &&\n\t    !(ci->id == BCMA_CHIP_ID_BCM53573 && core->core_unit == 1)) {\n\t\tstruct phy_device *phydev;\n\n\t\tmii_bus = bcma_mdio_mii_register(bgmac);\n\t\tif (IS_ERR(mii_bus)) {\n\t\t\terr = PTR_ERR(mii_bus);\n\t\t\tgoto err;\n\t\t}\n\t\tbgmac->mii_bus = mii_bus;\n\n\t\tphydev = mdiobus_get_phy(bgmac->mii_bus, bgmac->phyaddr);\n\t\tif (ci->id == BCMA_CHIP_ID_BCM53573 && phydev &&\n\t\t    (phydev->drv->phy_id & phydev->drv->phy_id_mask) == PHY_ID_BCM54210E)\n\t\t\tphydev->dev_flags |= PHY_BRCM_EN_MASTER_MODE;\n\t}\n\n\tif (core->bus->hosttype == BCMA_HOSTTYPE_PCI) {\n\t\tdev_err(bgmac->dev, \"PCI setup not implemented\\n\");\n\t\terr = -ENOTSUPP;\n\t\tgoto err1;\n\t}\n\n\tbgmac->has_robosw = !!(sprom->boardflags_lo & BGMAC_BFL_ENETROBO);\n\tif (bgmac->has_robosw)\n\t\tdev_warn(bgmac->dev, \"Support for Roboswitch not implemented\\n\");\n\n\tif (sprom->boardflags_lo & BGMAC_BFL_ENETADM)\n\t\tdev_warn(bgmac->dev, \"Support for ADMtek ethernet switch not implemented\\n\");\n\n\t \n\tswitch (ci->id) {\n\t \n\tcase BCMA_CHIP_ID_BCM4716:\n\t\tbgmac->feature_flags |= BGMAC_FEAT_CLKCTLST;\n\t\tfallthrough;\n\tcase BCMA_CHIP_ID_BCM47162:\n\t\tbgmac->feature_flags |= BGMAC_FEAT_FLW_CTRL2;\n\t\tbgmac->feature_flags |= BGMAC_FEAT_SET_RXQ_CLK;\n\t\tbreak;\n\tcase BCMA_CHIP_ID_BCM5357:\n\tcase BCMA_CHIP_ID_BCM53572:\n\t\tbgmac->feature_flags |= BGMAC_FEAT_SET_RXQ_CLK;\n\t\tbgmac->feature_flags |= BGMAC_FEAT_CLKCTLST;\n\t\tbgmac->feature_flags |= BGMAC_FEAT_FLW_CTRL1;\n\t\tbgmac->feature_flags |= BGMAC_FEAT_SW_TYPE_PHY;\n\t\tif ((ci->id == BCMA_CHIP_ID_BCM5357 && ci->pkg == BCMA_PKG_ID_BCM47186) ||\n\t\t    (ci->id == BCMA_CHIP_ID_BCM53572 && ci->pkg == BCMA_PKG_ID_BCM47188)) {\n\t\t\tbgmac->feature_flags |= BGMAC_FEAT_SW_TYPE_RGMII;\n\t\t\tbgmac->feature_flags |= BGMAC_FEAT_IOST_ATTACHED;\n\t\t}\n\t\tif (ci->id == BCMA_CHIP_ID_BCM5357 && ci->pkg == BCMA_PKG_ID_BCM5358)\n\t\t\tbgmac->feature_flags |= BGMAC_FEAT_SW_TYPE_EPHYRMII;\n\t\tbreak;\n\tcase BCMA_CHIP_ID_BCM53573:\n\t\tbgmac->feature_flags |= BGMAC_FEAT_CLKCTLST;\n\t\tbgmac->feature_flags |= BGMAC_FEAT_SET_RXQ_CLK;\n\t\tif (ci->pkg == BCMA_PKG_ID_BCM47189)\n\t\t\tbgmac->feature_flags |= BGMAC_FEAT_IOST_ATTACHED;\n\t\tif (core->core_unit == 0) {\n\t\t\tbgmac->feature_flags |= BGMAC_FEAT_CC4_IF_SW_TYPE;\n\t\t\tif (ci->pkg == BCMA_PKG_ID_BCM47189)\n\t\t\t\tbgmac->feature_flags |=\n\t\t\t\t\tBGMAC_FEAT_CC4_IF_SW_TYPE_RGMII;\n\t\t} else if (core->core_unit == 1) {\n\t\t\tbgmac->feature_flags |= BGMAC_FEAT_IRQ_ID_OOB_6;\n\t\t\tbgmac->feature_flags |= BGMAC_FEAT_CC7_IF_TYPE_RGMII;\n\t\t}\n\t\tbreak;\n\tcase BCMA_CHIP_ID_BCM4749:\n\t\tbgmac->feature_flags |= BGMAC_FEAT_SET_RXQ_CLK;\n\t\tbgmac->feature_flags |= BGMAC_FEAT_CLKCTLST;\n\t\tbgmac->feature_flags |= BGMAC_FEAT_FLW_CTRL1;\n\t\tbgmac->feature_flags |= BGMAC_FEAT_SW_TYPE_PHY;\n\t\tif (ci->pkg == 10) {\n\t\t\tbgmac->feature_flags |= BGMAC_FEAT_SW_TYPE_RGMII;\n\t\t\tbgmac->feature_flags |= BGMAC_FEAT_IOST_ATTACHED;\n\t\t}\n\t\tbreak;\n\t \n\tcase BCMA_CHIP_ID_BCM4707:\n\tcase BCMA_CHIP_ID_BCM47094:\n\tcase BCMA_CHIP_ID_BCM53018:\n\t\tbgmac->feature_flags |= BGMAC_FEAT_CLKCTLST;\n\t\tbgmac->feature_flags |= BGMAC_FEAT_NO_RESET;\n\t\tbgmac->feature_flags |= BGMAC_FEAT_FORCE_SPEED_2500;\n\t\tbreak;\n\tdefault:\n\t\tbgmac->feature_flags |= BGMAC_FEAT_CLKCTLST;\n\t\tbgmac->feature_flags |= BGMAC_FEAT_SET_RXQ_CLK;\n\t}\n\n\tif (!bgmac_is_bcm4707_family(core) && core->id.rev > 2)\n\t\tbgmac->feature_flags |= BGMAC_FEAT_MISC_PLL_REQ;\n\n\tif (core->id.id == BCMA_CORE_4706_MAC_GBIT) {\n\t\tbgmac->feature_flags |= BGMAC_FEAT_CMN_PHY_CTL;\n\t\tbgmac->feature_flags |= BGMAC_FEAT_NO_CLR_MIB;\n\t}\n\n\tif (core->id.rev >= 4) {\n\t\tbgmac->feature_flags |= BGMAC_FEAT_CMDCFG_SR_REV4;\n\t\tbgmac->feature_flags |= BGMAC_FEAT_TX_MASK_SETUP;\n\t\tbgmac->feature_flags |= BGMAC_FEAT_RX_MASK_SETUP;\n\t}\n\n\tbgmac->read = bcma_bgmac_read;\n\tbgmac->write = bcma_bgmac_write;\n\tbgmac->idm_read = bcma_bgmac_idm_read;\n\tbgmac->idm_write = bcma_bgmac_idm_write;\n\tbgmac->clk_enabled = bcma_bgmac_clk_enabled;\n\tbgmac->clk_enable = bcma_bgmac_clk_enable;\n\tbgmac->cco_ctl_maskset = bcma_bgmac_cco_ctl_maskset;\n\tbgmac->get_bus_clock = bcma_bgmac_get_bus_clock;\n\tbgmac->cmn_maskset32 = bcma_bgmac_cmn_maskset32;\n\tbgmac->phy_connect = bcma_phy_connect;\n\n\terr = bgmac_enet_probe(bgmac);\n\tif (err)\n\t\tgoto err1;\n\n\treturn 0;\n\nerr1:\n\tbcma_mdio_mii_unregister(bgmac->mii_bus);\nerr:\n\tbcma_set_drvdata(core, NULL);\n\n\treturn err;\n}\n\nstatic void bgmac_remove(struct bcma_device *core)\n{\n\tstruct bgmac *bgmac = bcma_get_drvdata(core);\n\n\tbcma_mdio_mii_unregister(bgmac->mii_bus);\n\tbgmac_enet_remove(bgmac);\n\tbcma_set_drvdata(core, NULL);\n}\n\nstatic struct bcma_driver bgmac_bcma_driver = {\n\t.name\t\t= KBUILD_MODNAME,\n\t.id_table\t= bgmac_bcma_tbl,\n\t.probe\t\t= bgmac_probe,\n\t.remove\t\t= bgmac_remove,\n};\n\nstatic int __init bgmac_init(void)\n{\n\tint err;\n\n\terr = bcma_driver_register(&bgmac_bcma_driver);\n\tif (err)\n\t\treturn err;\n\tpr_info(\"Broadcom 47xx GBit MAC driver loaded\\n\");\n\n\treturn 0;\n}\n\nstatic void __exit bgmac_exit(void)\n{\n\tbcma_driver_unregister(&bgmac_bcma_driver);\n}\n\nmodule_init(bgmac_init)\nmodule_exit(bgmac_exit)\n\nMODULE_AUTHOR(\"Rafa\u0142 Mi\u0142ecki\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}