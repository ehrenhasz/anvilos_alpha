{
  "module_name": "cnic_if.h",
  "hash_id": "795de222b38290067d1b404ef52fce9f13b1dd27b531126553cbdf7fbc9ec41c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/broadcom/cnic_if.h",
  "human_readable_source": " \n\n\n#ifndef CNIC_IF_H\n#define CNIC_IF_H\n\n#include \"bnx2x/bnx2x_mfw_req.h\"\n\n#define CNIC_MODULE_VERSION\t\"2.5.22\"\n#define CNIC_MODULE_RELDATE\t\"July 20, 2015\"\n\n#define CNIC_ULP_RDMA\t\t0\n#define CNIC_ULP_ISCSI\t\t1\n#define CNIC_ULP_FCOE\t\t2\n#define CNIC_ULP_L4\t\t3\n#define MAX_CNIC_ULP_TYPE_EXT\t3\n#define MAX_CNIC_ULP_TYPE\t4\n\n \n#if (PAGE_SHIFT > 14)\n#define CNIC_PAGE_BITS\t14\n#else\n#define CNIC_PAGE_BITS\tPAGE_SHIFT\n#endif\n#define CNIC_PAGE_SIZE\t(1 << (CNIC_PAGE_BITS))\n#define CNIC_PAGE_ALIGN(addr) ALIGN(addr, CNIC_PAGE_SIZE)\n#define CNIC_PAGE_MASK\t(~((CNIC_PAGE_SIZE) - 1))\n\nstruct kwqe {\n\tu32 kwqe_op_flag;\n\n#define KWQE_QID_SHIFT\t\t8\n#define KWQE_OPCODE_MASK\t0x00ff0000\n#define KWQE_OPCODE_SHIFT\t16\n#define KWQE_OPCODE(x)\t\t((x & KWQE_OPCODE_MASK) >> KWQE_OPCODE_SHIFT)\n#define KWQE_LAYER_MASK\t\t\t0x70000000\n#define KWQE_LAYER_SHIFT\t\t28\n#define KWQE_FLAGS_LAYER_MASK_L2\t(2<<28)\n#define KWQE_FLAGS_LAYER_MASK_L3\t(3<<28)\n#define KWQE_FLAGS_LAYER_MASK_L4\t(4<<28)\n#define KWQE_FLAGS_LAYER_MASK_L5_RDMA\t(5<<28)\n#define KWQE_FLAGS_LAYER_MASK_L5_ISCSI\t(6<<28)\n#define KWQE_FLAGS_LAYER_MASK_L5_FCOE\t(7<<28)\n\n\tu32 kwqe_info0;\n\tu32 kwqe_info1;\n\tu32 kwqe_info2;\n\tu32 kwqe_info3;\n\tu32 kwqe_info4;\n\tu32 kwqe_info5;\n\tu32 kwqe_info6;\n};\n\nstruct kwqe_16 {\n\tu32 kwqe_info0;\n\tu32 kwqe_info1;\n\tu32 kwqe_info2;\n\tu32 kwqe_info3;\n};\n\nstruct kcqe {\n\tu32 kcqe_info0;\n\tu32 kcqe_info1;\n\tu32 kcqe_info2;\n\tu32 kcqe_info3;\n\tu32 kcqe_info4;\n\tu32 kcqe_info5;\n\tu32 kcqe_info6;\n\tu32 kcqe_op_flag;\n\t\t#define KCQE_RAMROD_COMPLETION\t\t(0x1<<27)  \n\t\t#define KCQE_FLAGS_LAYER_MASK\t\t(0x7<<28)\n\t\t#define KCQE_FLAGS_LAYER_MASK_MISC\t(0<<28)\n\t\t#define KCQE_FLAGS_LAYER_MASK_L2\t(2<<28)\n\t\t#define KCQE_FLAGS_LAYER_MASK_L3\t(3<<28)\n\t\t#define KCQE_FLAGS_LAYER_MASK_L4\t(4<<28)\n\t\t#define KCQE_FLAGS_LAYER_MASK_L5_RDMA\t(5<<28)\n\t\t#define KCQE_FLAGS_LAYER_MASK_L5_ISCSI\t(6<<28)\n\t\t#define KCQE_FLAGS_LAYER_MASK_L5_FCOE\t(7<<28)\n\t\t#define KCQE_FLAGS_NEXT \t\t(1<<31)\n\t\t#define KCQE_FLAGS_OPCODE_MASK\t\t(0xff<<16)\n\t\t#define KCQE_FLAGS_OPCODE_SHIFT\t\t(16)\n\t\t#define KCQE_OPCODE(op)\t\t\t\\\n\t\t(((op) & KCQE_FLAGS_OPCODE_MASK) >> KCQE_FLAGS_OPCODE_SHIFT)\n};\n\n#define MAX_CNIC_CTL_DATA\t64\n#define MAX_DRV_CTL_DATA\t64\n\n#define CNIC_CTL_STOP_CMD\t\t1\n#define CNIC_CTL_START_CMD\t\t2\n#define CNIC_CTL_COMPLETION_CMD\t\t3\n#define CNIC_CTL_STOP_ISCSI_CMD\t\t4\n#define CNIC_CTL_FCOE_STATS_GET_CMD\t5\n#define CNIC_CTL_ISCSI_STATS_GET_CMD\t6\n\n#define DRV_CTL_IO_WR_CMD\t\t0x101\n#define DRV_CTL_IO_RD_CMD\t\t0x102\n#define DRV_CTL_CTX_WR_CMD\t\t0x103\n#define DRV_CTL_CTXTBL_WR_CMD\t\t0x104\n#define DRV_CTL_RET_L5_SPQ_CREDIT_CMD\t0x105\n#define DRV_CTL_START_L2_CMD\t\t0x106\n#define DRV_CTL_STOP_L2_CMD\t\t0x107\n#define DRV_CTL_RET_L2_SPQ_CREDIT_CMD\t0x10c\n#define DRV_CTL_ISCSI_STOPPED_CMD\t0x10d\n#define DRV_CTL_ULP_REGISTER_CMD\t0x10e\n#define DRV_CTL_ULP_UNREGISTER_CMD\t0x10f\n\nstruct cnic_ctl_completion {\n\tu32\tcid;\n\tu8\topcode;\n\tu8\terror;\n};\n\nstruct cnic_ctl_info {\n\tint\tcmd;\n\tunion {\n\t\tstruct cnic_ctl_completion comp;\n\t\tchar bytes[MAX_CNIC_CTL_DATA];\n\t} data;\n};\n\nstruct drv_ctl_spq_credit {\n\tu32\tcredit_count;\n};\n\nstruct drv_ctl_io {\n\tu32\t\tcid_addr;\n\tu32\t\toffset;\n\tu32\t\tdata;\n\tdma_addr_t\tdma_addr;\n};\n\nstruct drv_ctl_l2_ring {\n\tu32\t\tclient_id;\n\tu32\t\tcid;\n};\n\nstruct drv_ctl_register_data {\n\tint ulp_type;\n\tstruct fcoe_capabilities fcoe_features;\n};\n\nstruct drv_ctl_info {\n\tint\tcmd;\n\tint     drv_state;\n#define DRV_NOP\t\t0\n#define DRV_ACTIVE\t1\n#define DRV_INACTIVE\t2\n#define DRV_UNLOADED\t3\n\tunion {\n\t\tstruct drv_ctl_spq_credit credit;\n\t\tstruct drv_ctl_io io;\n\t\tstruct drv_ctl_l2_ring ring;\n\t\tint ulp_type;\n\t\tstruct drv_ctl_register_data register_data;\n\t\tchar bytes[MAX_DRV_CTL_DATA];\n\t} data;\n};\n\n#define MAX_NPIV_ENTRIES 64\n#define FC_NPIV_WWN_SIZE 8\n\nstruct cnic_fc_npiv_tbl {\n\tu8 wwpn[MAX_NPIV_ENTRIES][FC_NPIV_WWN_SIZE];\n\tu8 wwnn[MAX_NPIV_ENTRIES][FC_NPIV_WWN_SIZE];\n\tu32 count;\n};\n\nstruct cnic_ops {\n\tstruct module\t*cnic_owner;\n\t \n\tint\t\t(*cnic_handler)(void *, void *);\n\tint\t\t(*cnic_ctl)(void *, struct cnic_ctl_info *);\n};\n\n#define MAX_CNIC_VEC\t8\n\nstruct cnic_irq {\n\tunsigned int\tvector;\n\tvoid\t\t*status_blk;\n\tu32\t\tstatus_blk_num;\n\tu32\t\tstatus_blk_num2;\n\tu32\t\tirq_flags;\n#define CNIC_IRQ_FL_MSIX\t\t0x00000001\n};\n\nstruct cnic_eth_dev {\n\tstruct module\t*drv_owner;\n\tu32\t\tdrv_state;\n#define CNIC_DRV_STATE_REGD\t\t0x00000001\n#define CNIC_DRV_STATE_USING_MSIX\t0x00000002\n#define CNIC_DRV_STATE_NO_ISCSI_OOO\t0x00000004\n#define CNIC_DRV_STATE_NO_ISCSI\t\t0x00000008\n#define CNIC_DRV_STATE_NO_FCOE\t\t0x00000010\n#define CNIC_DRV_STATE_HANDLES_IRQ\t0x00000020\n\tu32\t\tchip_id;\n\tu32\t\tmax_kwqe_pending;\n\tstruct pci_dev\t*pdev;\n\tvoid __iomem\t*io_base;\n\tvoid __iomem\t*io_base2;\n\tconst void\t*iro_arr;\n\n\tu32\t\tctx_tbl_offset;\n\tu32\t\tctx_tbl_len;\n\tint\t\tctx_blk_size;\n\tu32\t\tstarting_cid;\n\tu32\t\tmax_iscsi_conn;\n\tu32\t\tmax_fcoe_conn;\n\tu32\t\tmax_rdma_conn;\n\tu32\t\tfcoe_init_cid;\n\tu32\t\tmax_fcoe_exchanges;\n\tu32\t\tfcoe_wwn_port_name_hi;\n\tu32\t\tfcoe_wwn_port_name_lo;\n\tu32\t\tfcoe_wwn_node_name_hi;\n\tu32\t\tfcoe_wwn_node_name_lo;\n\n\tu16\t\tiscsi_l2_client_id;\n\tu16\t\tiscsi_l2_cid;\n\tu8\t\tiscsi_mac[ETH_ALEN];\n\n\tint\t\tnum_irq;\n\tstruct cnic_irq\tirq_arr[MAX_CNIC_VEC];\n\tint\t\t(*drv_register_cnic)(struct net_device *,\n\t\t\t\t\t     struct cnic_ops *, void *);\n\tint\t\t(*drv_unregister_cnic)(struct net_device *);\n\tint\t\t(*drv_submit_kwqes_32)(struct net_device *,\n\t\t\t\t\t       struct kwqe *[], u32);\n\tint\t\t(*drv_submit_kwqes_16)(struct net_device *,\n\t\t\t\t\t       struct kwqe_16 *[], u32);\n\tint\t\t(*drv_ctl)(struct net_device *, struct drv_ctl_info *);\n\tint\t\t(*drv_get_fc_npiv_tbl)(struct net_device *,\n\t\t\t\t\t       struct cnic_fc_npiv_tbl *);\n\tunsigned long\treserved1[2];\n\tunion drv_info_to_mcp\t*addr_drv_info_to_mcp;\n};\n\nstruct cnic_sockaddr {\n\tunion {\n\t\tstruct sockaddr_in\tv4;\n\t\tstruct sockaddr_in6\tv6;\n\t} local;\n\tunion {\n\t\tstruct sockaddr_in\tv4;\n\t\tstruct sockaddr_in6\tv6;\n\t} remote;\n};\n\nstruct cnic_sock {\n\tstruct cnic_dev *dev;\n\tvoid\t*context;\n\tu32\tsrc_ip[4];\n\tu32\tdst_ip[4];\n\tu16\tsrc_port;\n\tu16\tdst_port;\n\tu16\tvlan_id;\n\tunsigned char old_ha[ETH_ALEN];\n\tunsigned char ha[ETH_ALEN];\n\tu32\tmtu;\n\tu32\tcid;\n\tu32\tl5_cid;\n\tu32\tpg_cid;\n\tint\tulp_type;\n\n\tu32\tka_timeout;\n\tu32\tka_interval;\n\tu8\tka_max_probe_count;\n\tu8\ttos;\n\tu8\tttl;\n\tu8\tsnd_seq_scale;\n\tu32\trcv_buf;\n\tu32\tsnd_buf;\n\tu32\tseed;\n\n\tunsigned long\ttcp_flags;\n#define SK_TCP_NO_DELAY_ACK\t0x1\n#define SK_TCP_KEEP_ALIVE\t0x2\n#define SK_TCP_NAGLE\t\t0x4\n#define SK_TCP_TIMESTAMP\t0x8\n#define SK_TCP_SACK\t\t0x10\n#define SK_TCP_SEG_SCALING\t0x20\n\tunsigned long\tflags;\n#define SK_F_INUSE\t\t0\n#define SK_F_OFFLD_COMPLETE\t1\n#define SK_F_OFFLD_SCHED\t2\n#define SK_F_PG_OFFLD_COMPLETE\t3\n#define SK_F_CONNECT_START\t4\n#define SK_F_IPV6\t\t5\n#define SK_F_CLOSING\t\t7\n#define SK_F_HW_ERR\t\t8\n\n\tatomic_t ref_count;\n\tu32 state;\n\tstruct kwqe kwqe1;\n\tstruct kwqe kwqe2;\n\tstruct kwqe kwqe3;\n};\n\nstruct cnic_dev {\n\tstruct net_device\t*netdev;\n\tstruct pci_dev\t\t*pcidev;\n\tvoid __iomem\t\t*regview;\n\tstruct list_head\tlist;\n\n\tint (*register_device)(struct cnic_dev *dev, int ulp_type,\n\t\t\t       void *ulp_ctx);\n\tint (*unregister_device)(struct cnic_dev *dev, int ulp_type);\n\tint (*submit_kwqes)(struct cnic_dev *dev, struct kwqe *wqes[],\n\t\t\t\tu32 num_wqes);\n\tint (*submit_kwqes_16)(struct cnic_dev *dev, struct kwqe_16 *wqes[],\n\t\t\t\tu32 num_wqes);\n\n\tint (*cm_create)(struct cnic_dev *, int, u32, u32, struct cnic_sock **,\n\t\t\t void *);\n\tint (*cm_destroy)(struct cnic_sock *);\n\tint (*cm_connect)(struct cnic_sock *, struct cnic_sockaddr *);\n\tint (*cm_abort)(struct cnic_sock *);\n\tint (*cm_close)(struct cnic_sock *);\n\tstruct cnic_dev *(*cm_select_dev)(struct sockaddr_in *, int ulp_type);\n\tint (*iscsi_nl_msg_recv)(struct cnic_dev *dev, u32 msg_type,\n\t\t\t\t char *data, u16 data_size);\n\tint (*get_fc_npiv_tbl)(struct cnic_dev *, struct cnic_fc_npiv_tbl *);\n\tunsigned long\tflags;\n#define CNIC_F_CNIC_UP\t\t1\n#define CNIC_F_BNX2_CLASS\t3\n#define CNIC_F_BNX2X_CLASS\t4\n\tatomic_t\tref_count;\n\tu8\t\tmac_addr[ETH_ALEN];\n\n\tint\t\tmax_iscsi_conn;\n\tint\t\tmax_fcoe_conn;\n\tint\t\tmax_rdma_conn;\n\n\tint\t\tmax_fcoe_exchanges;\n\n\tunion drv_info_to_mcp\t*stats_addr;\n\tstruct fcoe_capabilities\t*fcoe_cap;\n\n\tvoid\t\t*cnic_priv;\n};\n\n#define CNIC_WR(dev, off, val)\t\twritel(val, dev->regview + off)\n#define CNIC_WR16(dev, off, val)\twritew(val, dev->regview + off)\n#define CNIC_WR8(dev, off, val)\t\twriteb(val, dev->regview + off)\n#define CNIC_RD(dev, off)\t\treadl(dev->regview + off)\n#define CNIC_RD16(dev, off)\t\treadw(dev->regview + off)\n\nstruct cnic_ulp_ops {\n\t \n\n\tvoid (*cnic_init)(struct cnic_dev *dev);\n\tvoid (*cnic_exit)(struct cnic_dev *dev);\n\tvoid (*cnic_start)(void *ulp_ctx);\n\tvoid (*cnic_stop)(void *ulp_ctx);\n\tvoid (*indicate_kcqes)(void *ulp_ctx, struct kcqe *cqes[],\n\t\t\t\tu32 num_cqes);\n\tvoid (*indicate_netevent)(void *ulp_ctx, unsigned long event, u16 vid);\n\tvoid (*cm_connect_complete)(struct cnic_sock *);\n\tvoid (*cm_close_complete)(struct cnic_sock *);\n\tvoid (*cm_abort_complete)(struct cnic_sock *);\n\tvoid (*cm_remote_close)(struct cnic_sock *);\n\tvoid (*cm_remote_abort)(struct cnic_sock *);\n\tint (*iscsi_nl_send_msg)(void *ulp_ctx, u32 msg_type,\n\t\t\t\t  char *data, u16 data_size);\n\tint (*cnic_get_stats)(void *ulp_ctx);\n\tstruct module *owner;\n\tatomic_t ref_count;\n};\n\nint cnic_register_driver(int ulp_type, struct cnic_ulp_ops *ulp_ops);\n\nint cnic_unregister_driver(int ulp_type);\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}