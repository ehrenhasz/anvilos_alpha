{
  "module_name": "bnx2.c",
  "hash_id": "2b2e09b235a6d57cb4b5db92199a6ed5a04172ada4374b5d6137b96a80b13e01",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/broadcom/bnx2.c",
  "human_readable_source": " \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n\n#include <linux/stringify.h>\n#include <linux/kernel.h>\n#include <linux/timer.h>\n#include <linux/errno.h>\n#include <linux/ioport.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/skbuff.h>\n#include <linux/dma-mapping.h>\n#include <linux/bitops.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <linux/delay.h>\n#include <asm/byteorder.h>\n#include <asm/page.h>\n#include <linux/time.h>\n#include <linux/ethtool.h>\n#include <linux/mii.h>\n#include <linux/if.h>\n#include <linux/if_vlan.h>\n#include <net/ip.h>\n#include <net/tcp.h>\n#include <net/checksum.h>\n#include <linux/workqueue.h>\n#include <linux/crc32.h>\n#include <linux/prefetch.h>\n#include <linux/cache.h>\n#include <linux/firmware.h>\n#include <linux/log2.h>\n#include <linux/crash_dump.h>\n\n#if IS_ENABLED(CONFIG_CNIC)\n#define BCM_CNIC 1\n#include \"cnic_if.h\"\n#endif\n#include \"bnx2.h\"\n#include \"bnx2_fw.h\"\n\n#define DRV_MODULE_NAME\t\t\"bnx2\"\n#define FW_MIPS_FILE_06\t\t\"bnx2/bnx2-mips-06-6.2.3.fw\"\n#define FW_RV2P_FILE_06\t\t\"bnx2/bnx2-rv2p-06-6.0.15.fw\"\n#define FW_MIPS_FILE_09\t\t\"bnx2/bnx2-mips-09-6.2.1b.fw\"\n#define FW_RV2P_FILE_09_Ax\t\"bnx2/bnx2-rv2p-09ax-6.0.17.fw\"\n#define FW_RV2P_FILE_09\t\t\"bnx2/bnx2-rv2p-09-6.0.17.fw\"\n\n#define RUN_AT(x) (jiffies + (x))\n\n \n#define TX_TIMEOUT  (5*HZ)\n\nMODULE_AUTHOR(\"Michael Chan <mchan@broadcom.com>\");\nMODULE_DESCRIPTION(\"QLogic BCM5706/5708/5709/5716 Driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_FIRMWARE(FW_MIPS_FILE_06);\nMODULE_FIRMWARE(FW_RV2P_FILE_06);\nMODULE_FIRMWARE(FW_MIPS_FILE_09);\nMODULE_FIRMWARE(FW_RV2P_FILE_09);\nMODULE_FIRMWARE(FW_RV2P_FILE_09_Ax);\n\nstatic int disable_msi = 0;\n\nmodule_param(disable_msi, int, 0444);\nMODULE_PARM_DESC(disable_msi, \"Disable Message Signaled Interrupt (MSI)\");\n\ntypedef enum {\n\tBCM5706 = 0,\n\tNC370T,\n\tNC370I,\n\tBCM5706S,\n\tNC370F,\n\tBCM5708,\n\tBCM5708S,\n\tBCM5709,\n\tBCM5709S,\n\tBCM5716,\n\tBCM5716S,\n} board_t;\n\n \nstatic struct {\n\tchar *name;\n} board_info[] = {\n\t{ \"Broadcom NetXtreme II BCM5706 1000Base-T\" },\n\t{ \"HP NC370T Multifunction Gigabit Server Adapter\" },\n\t{ \"HP NC370i Multifunction Gigabit Server Adapter\" },\n\t{ \"Broadcom NetXtreme II BCM5706 1000Base-SX\" },\n\t{ \"HP NC370F Multifunction Gigabit Server Adapter\" },\n\t{ \"Broadcom NetXtreme II BCM5708 1000Base-T\" },\n\t{ \"Broadcom NetXtreme II BCM5708 1000Base-SX\" },\n\t{ \"Broadcom NetXtreme II BCM5709 1000Base-T\" },\n\t{ \"Broadcom NetXtreme II BCM5709 1000Base-SX\" },\n\t{ \"Broadcom NetXtreme II BCM5716 1000Base-T\" },\n\t{ \"Broadcom NetXtreme II BCM5716 1000Base-SX\" },\n\t};\n\nstatic const struct pci_device_id bnx2_pci_tbl[] = {\n\t{ PCI_VENDOR_ID_BROADCOM, PCI_DEVICE_ID_NX2_5706,\n\t  PCI_VENDOR_ID_HP, 0x3101, 0, 0, NC370T },\n\t{ PCI_VENDOR_ID_BROADCOM, PCI_DEVICE_ID_NX2_5706,\n\t  PCI_VENDOR_ID_HP, 0x3106, 0, 0, NC370I },\n\t{ PCI_VENDOR_ID_BROADCOM, PCI_DEVICE_ID_NX2_5706,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, BCM5706 },\n\t{ PCI_VENDOR_ID_BROADCOM, PCI_DEVICE_ID_NX2_5708,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, BCM5708 },\n\t{ PCI_VENDOR_ID_BROADCOM, PCI_DEVICE_ID_NX2_5706S,\n\t  PCI_VENDOR_ID_HP, 0x3102, 0, 0, NC370F },\n\t{ PCI_VENDOR_ID_BROADCOM, PCI_DEVICE_ID_NX2_5706S,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, BCM5706S },\n\t{ PCI_VENDOR_ID_BROADCOM, PCI_DEVICE_ID_NX2_5708S,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, BCM5708S },\n\t{ PCI_VENDOR_ID_BROADCOM, PCI_DEVICE_ID_NX2_5709,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, BCM5709 },\n\t{ PCI_VENDOR_ID_BROADCOM, PCI_DEVICE_ID_NX2_5709S,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, BCM5709S },\n\t{ PCI_VENDOR_ID_BROADCOM, 0x163b,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, BCM5716 },\n\t{ PCI_VENDOR_ID_BROADCOM, 0x163c,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, BCM5716S },\n\t{ 0, }\n};\n\nstatic const struct flash_spec flash_table[] =\n{\n#define BUFFERED_FLAGS\t\t(BNX2_NV_BUFFERED | BNX2_NV_TRANSLATE)\n#define NONBUFFERED_FLAGS\t(BNX2_NV_WREN)\n\t \n\t{0x00000000, 0x40830380, 0x009f0081, 0xa184a053, 0xaf000400,\n\t BUFFERED_FLAGS, SEEPROM_PAGE_BITS, SEEPROM_PAGE_SIZE,\n\t SEEPROM_BYTE_ADDR_MASK, SEEPROM_TOTAL_SIZE,\n\t \"EEPROM - slow\"},\n\t \n\t{0x08000002, 0x4b808201, 0x00050081, 0x03840253, 0xaf020406,\n\t NONBUFFERED_FLAGS, SAIFUN_FLASH_PAGE_BITS, SAIFUN_FLASH_PAGE_SIZE,\n\t SAIFUN_FLASH_BYTE_ADDR_MASK, 0,\n\t \"Entry 0001\"},\n\t \n\t \n\t{0x04000001, 0x47808201, 0x00050081, 0x03840253, 0xaf020406,\n\t NONBUFFERED_FLAGS, SAIFUN_FLASH_PAGE_BITS, SAIFUN_FLASH_PAGE_SIZE,\n\t SAIFUN_FLASH_BYTE_ADDR_MASK, SAIFUN_FLASH_BASE_TOTAL_SIZE*2,\n\t \"Non-buffered flash (128kB)\"},\n\t \n\t \n\t{0x0c000003, 0x4f808201, 0x00050081, 0x03840253, 0xaf020406,\n\t NONBUFFERED_FLAGS, SAIFUN_FLASH_PAGE_BITS, SAIFUN_FLASH_PAGE_SIZE,\n\t SAIFUN_FLASH_BYTE_ADDR_MASK, SAIFUN_FLASH_BASE_TOTAL_SIZE*4,\n\t \"Non-buffered flash (256kB)\"},\n\t \n\t{0x11000000, 0x53808201, 0x00050081, 0x03840253, 0xaf020406,\n\t NONBUFFERED_FLAGS, SAIFUN_FLASH_PAGE_BITS, SAIFUN_FLASH_PAGE_SIZE,\n\t SAIFUN_FLASH_BYTE_ADDR_MASK, 0,\n\t \"Entry 0100\"},\n\t \n\t{0x19000002, 0x5b808201, 0x000500db, 0x03840253, 0xaf020406,\n\t NONBUFFERED_FLAGS, ST_MICRO_FLASH_PAGE_BITS, ST_MICRO_FLASH_PAGE_SIZE,\n\t ST_MICRO_FLASH_BYTE_ADDR_MASK, ST_MICRO_FLASH_BASE_TOTAL_SIZE*2,\n\t \"Entry 0101: ST M45PE10 (128kB non-buffered)\"},\n\t \n\t{0x15000001, 0x57808201, 0x000500db, 0x03840253, 0xaf020406,\n\t NONBUFFERED_FLAGS, ST_MICRO_FLASH_PAGE_BITS, ST_MICRO_FLASH_PAGE_SIZE,\n\t ST_MICRO_FLASH_BYTE_ADDR_MASK, ST_MICRO_FLASH_BASE_TOTAL_SIZE*4,\n\t \"Entry 0110: ST M45PE20 (256kB non-buffered)\"},\n\t \n\t \n\t{0x1d000003, 0x5f808201, 0x00050081, 0x03840253, 0xaf020406,\n\t NONBUFFERED_FLAGS, SAIFUN_FLASH_PAGE_BITS, SAIFUN_FLASH_PAGE_SIZE,\n\t SAIFUN_FLASH_BYTE_ADDR_MASK, SAIFUN_FLASH_BASE_TOTAL_SIZE,\n\t \"Non-buffered flash (64kB)\"},\n\t \n\t{0x22000000, 0x62808380, 0x009f0081, 0xa184a053, 0xaf000400,\n\t BUFFERED_FLAGS, SEEPROM_PAGE_BITS, SEEPROM_PAGE_SIZE,\n\t SEEPROM_BYTE_ADDR_MASK, SEEPROM_TOTAL_SIZE,\n\t \"EEPROM - fast\"},\n\t \n\t{0x2a000002, 0x6b808201, 0x00050081, 0x03840253, 0xaf020406,\n\t NONBUFFERED_FLAGS, SAIFUN_FLASH_PAGE_BITS, SAIFUN_FLASH_PAGE_SIZE,\n\t SAIFUN_FLASH_BYTE_ADDR_MASK, 0,\n\t \"Entry 1001\"},\n\t \n\t{0x26000001, 0x67808201, 0x00050081, 0x03840253, 0xaf020406,\n\t NONBUFFERED_FLAGS, SAIFUN_FLASH_PAGE_BITS, SAIFUN_FLASH_PAGE_SIZE,\n\t SAIFUN_FLASH_BYTE_ADDR_MASK, 0,\n\t \"Entry 1010\"},\n\t \n\t{0x2e000003, 0x6e808273, 0x00570081, 0x68848353, 0xaf000400,\n\t BUFFERED_FLAGS, BUFFERED_FLASH_PAGE_BITS, BUFFERED_FLASH_PAGE_SIZE,\n\t BUFFERED_FLASH_BYTE_ADDR_MASK, BUFFERED_FLASH_TOTAL_SIZE,\n\t \"Buffered flash (128kB)\"},\n\t \n\t{0x33000000, 0x73808201, 0x00050081, 0x03840253, 0xaf020406,\n\t NONBUFFERED_FLAGS, SAIFUN_FLASH_PAGE_BITS, SAIFUN_FLASH_PAGE_SIZE,\n\t SAIFUN_FLASH_BYTE_ADDR_MASK, 0,\n\t \"Entry 1100\"},\n\t \n\t{0x3b000002, 0x7b808201, 0x00050081, 0x03840253, 0xaf020406,\n\t NONBUFFERED_FLAGS, SAIFUN_FLASH_PAGE_BITS, SAIFUN_FLASH_PAGE_SIZE,\n\t SAIFUN_FLASH_BYTE_ADDR_MASK, 0,\n\t \"Entry 1101\"},\n\t \n\t{0x37000001, 0x76808273, 0x00570081, 0x68848353, 0xaf000400,\n\t BUFFERED_FLAGS, BUFFERED_FLASH_PAGE_BITS, BUFFERED_FLASH_PAGE_SIZE,\n\t BUFFERED_FLASH_BYTE_ADDR_MASK, 0,\n\t \"Entry 1110 (Atmel)\"},\n\t \n\t{0x3f000003, 0x7e808273, 0x00570081, 0x68848353, 0xaf000400,\n\t BUFFERED_FLAGS, BUFFERED_FLASH_PAGE_BITS, BUFFERED_FLASH_PAGE_SIZE,\n\t BUFFERED_FLASH_BYTE_ADDR_MASK, BUFFERED_FLASH_TOTAL_SIZE*2,\n\t \"Buffered flash (256kB)\"},\n};\n\nstatic const struct flash_spec flash_5709 = {\n\t.flags\t\t= BNX2_NV_BUFFERED,\n\t.page_bits\t= BCM5709_FLASH_PAGE_BITS,\n\t.page_size\t= BCM5709_FLASH_PAGE_SIZE,\n\t.addr_mask\t= BCM5709_FLASH_BYTE_ADDR_MASK,\n\t.total_size\t= BUFFERED_FLASH_TOTAL_SIZE*2,\n\t.name\t\t= \"5709 Buffered flash (256kB)\",\n};\n\nMODULE_DEVICE_TABLE(pci, bnx2_pci_tbl);\n\nstatic void bnx2_init_napi(struct bnx2 *bp);\nstatic void bnx2_del_napi(struct bnx2 *bp);\n\nstatic inline u32 bnx2_tx_avail(struct bnx2 *bp, struct bnx2_tx_ring_info *txr)\n{\n\tu32 diff;\n\n\t \n\tdiff = READ_ONCE(txr->tx_prod) - READ_ONCE(txr->tx_cons);\n\tif (unlikely(diff >= BNX2_TX_DESC_CNT)) {\n\t\tdiff &= 0xffff;\n\t\tif (diff == BNX2_TX_DESC_CNT)\n\t\t\tdiff = BNX2_MAX_TX_DESC_CNT;\n\t}\n\treturn bp->tx_ring_size - diff;\n}\n\nstatic u32\nbnx2_reg_rd_ind(struct bnx2 *bp, u32 offset)\n{\n\tunsigned long flags;\n\tu32 val;\n\n\tspin_lock_irqsave(&bp->indirect_lock, flags);\n\tBNX2_WR(bp, BNX2_PCICFG_REG_WINDOW_ADDRESS, offset);\n\tval = BNX2_RD(bp, BNX2_PCICFG_REG_WINDOW);\n\tspin_unlock_irqrestore(&bp->indirect_lock, flags);\n\treturn val;\n}\n\nstatic void\nbnx2_reg_wr_ind(struct bnx2 *bp, u32 offset, u32 val)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&bp->indirect_lock, flags);\n\tBNX2_WR(bp, BNX2_PCICFG_REG_WINDOW_ADDRESS, offset);\n\tBNX2_WR(bp, BNX2_PCICFG_REG_WINDOW, val);\n\tspin_unlock_irqrestore(&bp->indirect_lock, flags);\n}\n\nstatic void\nbnx2_shmem_wr(struct bnx2 *bp, u32 offset, u32 val)\n{\n\tbnx2_reg_wr_ind(bp, bp->shmem_base + offset, val);\n}\n\nstatic u32\nbnx2_shmem_rd(struct bnx2 *bp, u32 offset)\n{\n\treturn bnx2_reg_rd_ind(bp, bp->shmem_base + offset);\n}\n\nstatic void\nbnx2_ctx_wr(struct bnx2 *bp, u32 cid_addr, u32 offset, u32 val)\n{\n\tunsigned long flags;\n\n\toffset += cid_addr;\n\tspin_lock_irqsave(&bp->indirect_lock, flags);\n\tif (BNX2_CHIP(bp) == BNX2_CHIP_5709) {\n\t\tint i;\n\n\t\tBNX2_WR(bp, BNX2_CTX_CTX_DATA, val);\n\t\tBNX2_WR(bp, BNX2_CTX_CTX_CTRL,\n\t\t\toffset | BNX2_CTX_CTX_CTRL_WRITE_REQ);\n\t\tfor (i = 0; i < 5; i++) {\n\t\t\tval = BNX2_RD(bp, BNX2_CTX_CTX_CTRL);\n\t\t\tif ((val & BNX2_CTX_CTX_CTRL_WRITE_REQ) == 0)\n\t\t\t\tbreak;\n\t\t\tudelay(5);\n\t\t}\n\t} else {\n\t\tBNX2_WR(bp, BNX2_CTX_DATA_ADR, offset);\n\t\tBNX2_WR(bp, BNX2_CTX_DATA, val);\n\t}\n\tspin_unlock_irqrestore(&bp->indirect_lock, flags);\n}\n\n#ifdef BCM_CNIC\nstatic int\nbnx2_drv_ctl(struct net_device *dev, struct drv_ctl_info *info)\n{\n\tstruct bnx2 *bp = netdev_priv(dev);\n\tstruct drv_ctl_io *io = &info->data.io;\n\n\tswitch (info->cmd) {\n\tcase DRV_CTL_IO_WR_CMD:\n\t\tbnx2_reg_wr_ind(bp, io->offset, io->data);\n\t\tbreak;\n\tcase DRV_CTL_IO_RD_CMD:\n\t\tio->data = bnx2_reg_rd_ind(bp, io->offset);\n\t\tbreak;\n\tcase DRV_CTL_CTX_WR_CMD:\n\t\tbnx2_ctx_wr(bp, io->cid_addr, io->offset, io->data);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic void bnx2_setup_cnic_irq_info(struct bnx2 *bp)\n{\n\tstruct cnic_eth_dev *cp = &bp->cnic_eth_dev;\n\tstruct bnx2_napi *bnapi = &bp->bnx2_napi[0];\n\tint sb_id;\n\n\tif (bp->flags & BNX2_FLAG_USING_MSIX) {\n\t\tcp->drv_state |= CNIC_DRV_STATE_USING_MSIX;\n\t\tbnapi->cnic_present = 0;\n\t\tsb_id = bp->irq_nvecs;\n\t\tcp->irq_arr[0].irq_flags |= CNIC_IRQ_FL_MSIX;\n\t} else {\n\t\tcp->drv_state &= ~CNIC_DRV_STATE_USING_MSIX;\n\t\tbnapi->cnic_tag = bnapi->last_status_idx;\n\t\tbnapi->cnic_present = 1;\n\t\tsb_id = 0;\n\t\tcp->irq_arr[0].irq_flags &= ~CNIC_IRQ_FL_MSIX;\n\t}\n\n\tcp->irq_arr[0].vector = bp->irq_tbl[sb_id].vector;\n\tcp->irq_arr[0].status_blk = (void *)\n\t\t((unsigned long) bnapi->status_blk.msi +\n\t\t(BNX2_SBLK_MSIX_ALIGN_SIZE * sb_id));\n\tcp->irq_arr[0].status_blk_num = sb_id;\n\tcp->num_irq = 1;\n}\n\nstatic int bnx2_register_cnic(struct net_device *dev, struct cnic_ops *ops,\n\t\t\t      void *data)\n{\n\tstruct bnx2 *bp = netdev_priv(dev);\n\tstruct cnic_eth_dev *cp = &bp->cnic_eth_dev;\n\n\tif (!ops)\n\t\treturn -EINVAL;\n\n\tif (cp->drv_state & CNIC_DRV_STATE_REGD)\n\t\treturn -EBUSY;\n\n\tif (!bnx2_reg_rd_ind(bp, BNX2_FW_MAX_ISCSI_CONN))\n\t\treturn -ENODEV;\n\n\tbp->cnic_data = data;\n\trcu_assign_pointer(bp->cnic_ops, ops);\n\n\tcp->num_irq = 0;\n\tcp->drv_state = CNIC_DRV_STATE_REGD;\n\n\tbnx2_setup_cnic_irq_info(bp);\n\n\treturn 0;\n}\n\nstatic int bnx2_unregister_cnic(struct net_device *dev)\n{\n\tstruct bnx2 *bp = netdev_priv(dev);\n\tstruct bnx2_napi *bnapi = &bp->bnx2_napi[0];\n\tstruct cnic_eth_dev *cp = &bp->cnic_eth_dev;\n\n\tmutex_lock(&bp->cnic_lock);\n\tcp->drv_state = 0;\n\tbnapi->cnic_present = 0;\n\tRCU_INIT_POINTER(bp->cnic_ops, NULL);\n\tmutex_unlock(&bp->cnic_lock);\n\tsynchronize_rcu();\n\treturn 0;\n}\n\nstatic struct cnic_eth_dev *bnx2_cnic_probe(struct net_device *dev)\n{\n\tstruct bnx2 *bp = netdev_priv(dev);\n\tstruct cnic_eth_dev *cp = &bp->cnic_eth_dev;\n\n\tif (!cp->max_iscsi_conn)\n\t\treturn NULL;\n\n\tcp->drv_owner = THIS_MODULE;\n\tcp->chip_id = bp->chip_id;\n\tcp->pdev = bp->pdev;\n\tcp->io_base = bp->regview;\n\tcp->drv_ctl = bnx2_drv_ctl;\n\tcp->drv_register_cnic = bnx2_register_cnic;\n\tcp->drv_unregister_cnic = bnx2_unregister_cnic;\n\n\treturn cp;\n}\n\nstatic void\nbnx2_cnic_stop(struct bnx2 *bp)\n{\n\tstruct cnic_ops *c_ops;\n\tstruct cnic_ctl_info info;\n\n\tmutex_lock(&bp->cnic_lock);\n\tc_ops = rcu_dereference_protected(bp->cnic_ops,\n\t\t\t\t\t  lockdep_is_held(&bp->cnic_lock));\n\tif (c_ops) {\n\t\tinfo.cmd = CNIC_CTL_STOP_CMD;\n\t\tc_ops->cnic_ctl(bp->cnic_data, &info);\n\t}\n\tmutex_unlock(&bp->cnic_lock);\n}\n\nstatic void\nbnx2_cnic_start(struct bnx2 *bp)\n{\n\tstruct cnic_ops *c_ops;\n\tstruct cnic_ctl_info info;\n\n\tmutex_lock(&bp->cnic_lock);\n\tc_ops = rcu_dereference_protected(bp->cnic_ops,\n\t\t\t\t\t  lockdep_is_held(&bp->cnic_lock));\n\tif (c_ops) {\n\t\tif (!(bp->flags & BNX2_FLAG_USING_MSIX)) {\n\t\t\tstruct bnx2_napi *bnapi = &bp->bnx2_napi[0];\n\n\t\t\tbnapi->cnic_tag = bnapi->last_status_idx;\n\t\t}\n\t\tinfo.cmd = CNIC_CTL_START_CMD;\n\t\tc_ops->cnic_ctl(bp->cnic_data, &info);\n\t}\n\tmutex_unlock(&bp->cnic_lock);\n}\n\n#else\n\nstatic void\nbnx2_cnic_stop(struct bnx2 *bp)\n{\n}\n\nstatic void\nbnx2_cnic_start(struct bnx2 *bp)\n{\n}\n\n#endif\n\nstatic int\nbnx2_read_phy(struct bnx2 *bp, u32 reg, u32 *val)\n{\n\tu32 val1;\n\tint i, ret;\n\n\tif (bp->phy_flags & BNX2_PHY_FLAG_INT_MODE_AUTO_POLLING) {\n\t\tval1 = BNX2_RD(bp, BNX2_EMAC_MDIO_MODE);\n\t\tval1 &= ~BNX2_EMAC_MDIO_MODE_AUTO_POLL;\n\n\t\tBNX2_WR(bp, BNX2_EMAC_MDIO_MODE, val1);\n\t\tBNX2_RD(bp, BNX2_EMAC_MDIO_MODE);\n\n\t\tudelay(40);\n\t}\n\n\tval1 = (bp->phy_addr << 21) | (reg << 16) |\n\t\tBNX2_EMAC_MDIO_COMM_COMMAND_READ | BNX2_EMAC_MDIO_COMM_DISEXT |\n\t\tBNX2_EMAC_MDIO_COMM_START_BUSY;\n\tBNX2_WR(bp, BNX2_EMAC_MDIO_COMM, val1);\n\n\tfor (i = 0; i < 50; i++) {\n\t\tudelay(10);\n\n\t\tval1 = BNX2_RD(bp, BNX2_EMAC_MDIO_COMM);\n\t\tif (!(val1 & BNX2_EMAC_MDIO_COMM_START_BUSY)) {\n\t\t\tudelay(5);\n\n\t\t\tval1 = BNX2_RD(bp, BNX2_EMAC_MDIO_COMM);\n\t\t\tval1 &= BNX2_EMAC_MDIO_COMM_DATA;\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (val1 & BNX2_EMAC_MDIO_COMM_START_BUSY) {\n\t\t*val = 0x0;\n\t\tret = -EBUSY;\n\t}\n\telse {\n\t\t*val = val1;\n\t\tret = 0;\n\t}\n\n\tif (bp->phy_flags & BNX2_PHY_FLAG_INT_MODE_AUTO_POLLING) {\n\t\tval1 = BNX2_RD(bp, BNX2_EMAC_MDIO_MODE);\n\t\tval1 |= BNX2_EMAC_MDIO_MODE_AUTO_POLL;\n\n\t\tBNX2_WR(bp, BNX2_EMAC_MDIO_MODE, val1);\n\t\tBNX2_RD(bp, BNX2_EMAC_MDIO_MODE);\n\n\t\tudelay(40);\n\t}\n\n\treturn ret;\n}\n\nstatic int\nbnx2_write_phy(struct bnx2 *bp, u32 reg, u32 val)\n{\n\tu32 val1;\n\tint i, ret;\n\n\tif (bp->phy_flags & BNX2_PHY_FLAG_INT_MODE_AUTO_POLLING) {\n\t\tval1 = BNX2_RD(bp, BNX2_EMAC_MDIO_MODE);\n\t\tval1 &= ~BNX2_EMAC_MDIO_MODE_AUTO_POLL;\n\n\t\tBNX2_WR(bp, BNX2_EMAC_MDIO_MODE, val1);\n\t\tBNX2_RD(bp, BNX2_EMAC_MDIO_MODE);\n\n\t\tudelay(40);\n\t}\n\n\tval1 = (bp->phy_addr << 21) | (reg << 16) | val |\n\t\tBNX2_EMAC_MDIO_COMM_COMMAND_WRITE |\n\t\tBNX2_EMAC_MDIO_COMM_START_BUSY | BNX2_EMAC_MDIO_COMM_DISEXT;\n\tBNX2_WR(bp, BNX2_EMAC_MDIO_COMM, val1);\n\n\tfor (i = 0; i < 50; i++) {\n\t\tudelay(10);\n\n\t\tval1 = BNX2_RD(bp, BNX2_EMAC_MDIO_COMM);\n\t\tif (!(val1 & BNX2_EMAC_MDIO_COMM_START_BUSY)) {\n\t\t\tudelay(5);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (val1 & BNX2_EMAC_MDIO_COMM_START_BUSY)\n\t\tret = -EBUSY;\n\telse\n\t\tret = 0;\n\n\tif (bp->phy_flags & BNX2_PHY_FLAG_INT_MODE_AUTO_POLLING) {\n\t\tval1 = BNX2_RD(bp, BNX2_EMAC_MDIO_MODE);\n\t\tval1 |= BNX2_EMAC_MDIO_MODE_AUTO_POLL;\n\n\t\tBNX2_WR(bp, BNX2_EMAC_MDIO_MODE, val1);\n\t\tBNX2_RD(bp, BNX2_EMAC_MDIO_MODE);\n\n\t\tudelay(40);\n\t}\n\n\treturn ret;\n}\n\nstatic void\nbnx2_disable_int(struct bnx2 *bp)\n{\n\tint i;\n\tstruct bnx2_napi *bnapi;\n\n\tfor (i = 0; i < bp->irq_nvecs; i++) {\n\t\tbnapi = &bp->bnx2_napi[i];\n\t\tBNX2_WR(bp, BNX2_PCICFG_INT_ACK_CMD, bnapi->int_num |\n\t\t       BNX2_PCICFG_INT_ACK_CMD_MASK_INT);\n\t}\n\tBNX2_RD(bp, BNX2_PCICFG_INT_ACK_CMD);\n}\n\nstatic void\nbnx2_enable_int(struct bnx2 *bp)\n{\n\tint i;\n\tstruct bnx2_napi *bnapi;\n\n\tfor (i = 0; i < bp->irq_nvecs; i++) {\n\t\tbnapi = &bp->bnx2_napi[i];\n\n\t\tBNX2_WR(bp, BNX2_PCICFG_INT_ACK_CMD, bnapi->int_num |\n\t\t\tBNX2_PCICFG_INT_ACK_CMD_INDEX_VALID |\n\t\t\tBNX2_PCICFG_INT_ACK_CMD_MASK_INT |\n\t\t\tbnapi->last_status_idx);\n\n\t\tBNX2_WR(bp, BNX2_PCICFG_INT_ACK_CMD, bnapi->int_num |\n\t\t\tBNX2_PCICFG_INT_ACK_CMD_INDEX_VALID |\n\t\t\tbnapi->last_status_idx);\n\t}\n\tBNX2_WR(bp, BNX2_HC_COMMAND, bp->hc_cmd | BNX2_HC_COMMAND_COAL_NOW);\n}\n\nstatic void\nbnx2_disable_int_sync(struct bnx2 *bp)\n{\n\tint i;\n\n\tatomic_inc(&bp->intr_sem);\n\tif (!netif_running(bp->dev))\n\t\treturn;\n\n\tbnx2_disable_int(bp);\n\tfor (i = 0; i < bp->irq_nvecs; i++)\n\t\tsynchronize_irq(bp->irq_tbl[i].vector);\n}\n\nstatic void\nbnx2_napi_disable(struct bnx2 *bp)\n{\n\tint i;\n\n\tfor (i = 0; i < bp->irq_nvecs; i++)\n\t\tnapi_disable(&bp->bnx2_napi[i].napi);\n}\n\nstatic void\nbnx2_napi_enable(struct bnx2 *bp)\n{\n\tint i;\n\n\tfor (i = 0; i < bp->irq_nvecs; i++)\n\t\tnapi_enable(&bp->bnx2_napi[i].napi);\n}\n\nstatic void\nbnx2_netif_stop(struct bnx2 *bp, bool stop_cnic)\n{\n\tif (stop_cnic)\n\t\tbnx2_cnic_stop(bp);\n\tif (netif_running(bp->dev)) {\n\t\tbnx2_napi_disable(bp);\n\t\tnetif_tx_disable(bp->dev);\n\t}\n\tbnx2_disable_int_sync(bp);\n\tnetif_carrier_off(bp->dev);\t \n}\n\nstatic void\nbnx2_netif_start(struct bnx2 *bp, bool start_cnic)\n{\n\tif (atomic_dec_and_test(&bp->intr_sem)) {\n\t\tif (netif_running(bp->dev)) {\n\t\t\tnetif_tx_wake_all_queues(bp->dev);\n\t\t\tspin_lock_bh(&bp->phy_lock);\n\t\t\tif (bp->link_up)\n\t\t\t\tnetif_carrier_on(bp->dev);\n\t\t\tspin_unlock_bh(&bp->phy_lock);\n\t\t\tbnx2_napi_enable(bp);\n\t\t\tbnx2_enable_int(bp);\n\t\t\tif (start_cnic)\n\t\t\t\tbnx2_cnic_start(bp);\n\t\t}\n\t}\n}\n\nstatic void\nbnx2_free_tx_mem(struct bnx2 *bp)\n{\n\tint i;\n\n\tfor (i = 0; i < bp->num_tx_rings; i++) {\n\t\tstruct bnx2_napi *bnapi = &bp->bnx2_napi[i];\n\t\tstruct bnx2_tx_ring_info *txr = &bnapi->tx_ring;\n\n\t\tif (txr->tx_desc_ring) {\n\t\t\tdma_free_coherent(&bp->pdev->dev, TXBD_RING_SIZE,\n\t\t\t\t\t  txr->tx_desc_ring,\n\t\t\t\t\t  txr->tx_desc_mapping);\n\t\t\ttxr->tx_desc_ring = NULL;\n\t\t}\n\t\tkfree(txr->tx_buf_ring);\n\t\ttxr->tx_buf_ring = NULL;\n\t}\n}\n\nstatic void\nbnx2_free_rx_mem(struct bnx2 *bp)\n{\n\tint i;\n\n\tfor (i = 0; i < bp->num_rx_rings; i++) {\n\t\tstruct bnx2_napi *bnapi = &bp->bnx2_napi[i];\n\t\tstruct bnx2_rx_ring_info *rxr = &bnapi->rx_ring;\n\t\tint j;\n\n\t\tfor (j = 0; j < bp->rx_max_ring; j++) {\n\t\t\tif (rxr->rx_desc_ring[j])\n\t\t\t\tdma_free_coherent(&bp->pdev->dev, RXBD_RING_SIZE,\n\t\t\t\t\t\t  rxr->rx_desc_ring[j],\n\t\t\t\t\t\t  rxr->rx_desc_mapping[j]);\n\t\t\trxr->rx_desc_ring[j] = NULL;\n\t\t}\n\t\tvfree(rxr->rx_buf_ring);\n\t\trxr->rx_buf_ring = NULL;\n\n\t\tfor (j = 0; j < bp->rx_max_pg_ring; j++) {\n\t\t\tif (rxr->rx_pg_desc_ring[j])\n\t\t\t\tdma_free_coherent(&bp->pdev->dev, RXBD_RING_SIZE,\n\t\t\t\t\t\t  rxr->rx_pg_desc_ring[j],\n\t\t\t\t\t\t  rxr->rx_pg_desc_mapping[j]);\n\t\t\trxr->rx_pg_desc_ring[j] = NULL;\n\t\t}\n\t\tvfree(rxr->rx_pg_ring);\n\t\trxr->rx_pg_ring = NULL;\n\t}\n}\n\nstatic int\nbnx2_alloc_tx_mem(struct bnx2 *bp)\n{\n\tint i;\n\n\tfor (i = 0; i < bp->num_tx_rings; i++) {\n\t\tstruct bnx2_napi *bnapi = &bp->bnx2_napi[i];\n\t\tstruct bnx2_tx_ring_info *txr = &bnapi->tx_ring;\n\n\t\ttxr->tx_buf_ring = kzalloc(SW_TXBD_RING_SIZE, GFP_KERNEL);\n\t\tif (!txr->tx_buf_ring)\n\t\t\treturn -ENOMEM;\n\n\t\ttxr->tx_desc_ring =\n\t\t\tdma_alloc_coherent(&bp->pdev->dev, TXBD_RING_SIZE,\n\t\t\t\t\t   &txr->tx_desc_mapping, GFP_KERNEL);\n\t\tif (!txr->tx_desc_ring)\n\t\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}\n\nstatic int\nbnx2_alloc_rx_mem(struct bnx2 *bp)\n{\n\tint i;\n\n\tfor (i = 0; i < bp->num_rx_rings; i++) {\n\t\tstruct bnx2_napi *bnapi = &bp->bnx2_napi[i];\n\t\tstruct bnx2_rx_ring_info *rxr = &bnapi->rx_ring;\n\t\tint j;\n\n\t\trxr->rx_buf_ring =\n\t\t\tvzalloc(array_size(SW_RXBD_RING_SIZE, bp->rx_max_ring));\n\t\tif (!rxr->rx_buf_ring)\n\t\t\treturn -ENOMEM;\n\n\t\tfor (j = 0; j < bp->rx_max_ring; j++) {\n\t\t\trxr->rx_desc_ring[j] =\n\t\t\t\tdma_alloc_coherent(&bp->pdev->dev,\n\t\t\t\t\t\t   RXBD_RING_SIZE,\n\t\t\t\t\t\t   &rxr->rx_desc_mapping[j],\n\t\t\t\t\t\t   GFP_KERNEL);\n\t\t\tif (!rxr->rx_desc_ring[j])\n\t\t\t\treturn -ENOMEM;\n\n\t\t}\n\n\t\tif (bp->rx_pg_ring_size) {\n\t\t\trxr->rx_pg_ring =\n\t\t\t\tvzalloc(array_size(SW_RXPG_RING_SIZE,\n\t\t\t\t\t\t   bp->rx_max_pg_ring));\n\t\t\tif (!rxr->rx_pg_ring)\n\t\t\t\treturn -ENOMEM;\n\n\t\t}\n\n\t\tfor (j = 0; j < bp->rx_max_pg_ring; j++) {\n\t\t\trxr->rx_pg_desc_ring[j] =\n\t\t\t\tdma_alloc_coherent(&bp->pdev->dev,\n\t\t\t\t\t\t   RXBD_RING_SIZE,\n\t\t\t\t\t\t   &rxr->rx_pg_desc_mapping[j],\n\t\t\t\t\t\t   GFP_KERNEL);\n\t\t\tif (!rxr->rx_pg_desc_ring[j])\n\t\t\t\treturn -ENOMEM;\n\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void\nbnx2_free_stats_blk(struct net_device *dev)\n{\n\tstruct bnx2 *bp = netdev_priv(dev);\n\n\tif (bp->status_blk) {\n\t\tdma_free_coherent(&bp->pdev->dev, bp->status_stats_size,\n\t\t\t\t  bp->status_blk,\n\t\t\t\t  bp->status_blk_mapping);\n\t\tbp->status_blk = NULL;\n\t\tbp->stats_blk = NULL;\n\t}\n}\n\nstatic int\nbnx2_alloc_stats_blk(struct net_device *dev)\n{\n\tint status_blk_size;\n\tvoid *status_blk;\n\tstruct bnx2 *bp = netdev_priv(dev);\n\n\t \n\tstatus_blk_size = L1_CACHE_ALIGN(sizeof(struct status_block));\n\tif (bp->flags & BNX2_FLAG_MSIX_CAP)\n\t\tstatus_blk_size = L1_CACHE_ALIGN(BNX2_MAX_MSIX_HW_VEC *\n\t\t\t\t\t\t BNX2_SBLK_MSIX_ALIGN_SIZE);\n\tbp->status_stats_size = status_blk_size +\n\t\t\t\tsizeof(struct statistics_block);\n\tstatus_blk = dma_alloc_coherent(&bp->pdev->dev, bp->status_stats_size,\n\t\t\t\t\t&bp->status_blk_mapping, GFP_KERNEL);\n\tif (!status_blk)\n\t\treturn -ENOMEM;\n\n\tbp->status_blk = status_blk;\n\tbp->stats_blk = status_blk + status_blk_size;\n\tbp->stats_blk_mapping = bp->status_blk_mapping + status_blk_size;\n\n\treturn 0;\n}\n\nstatic void\nbnx2_free_mem(struct bnx2 *bp)\n{\n\tint i;\n\tstruct bnx2_napi *bnapi = &bp->bnx2_napi[0];\n\n\tbnx2_free_tx_mem(bp);\n\tbnx2_free_rx_mem(bp);\n\n\tfor (i = 0; i < bp->ctx_pages; i++) {\n\t\tif (bp->ctx_blk[i]) {\n\t\t\tdma_free_coherent(&bp->pdev->dev, BNX2_PAGE_SIZE,\n\t\t\t\t\t  bp->ctx_blk[i],\n\t\t\t\t\t  bp->ctx_blk_mapping[i]);\n\t\t\tbp->ctx_blk[i] = NULL;\n\t\t}\n\t}\n\n\tif (bnapi->status_blk.msi)\n\t\tbnapi->status_blk.msi = NULL;\n}\n\nstatic int\nbnx2_alloc_mem(struct bnx2 *bp)\n{\n\tint i, err;\n\tstruct bnx2_napi *bnapi;\n\n\tbnapi = &bp->bnx2_napi[0];\n\tbnapi->status_blk.msi = bp->status_blk;\n\tbnapi->hw_tx_cons_ptr =\n\t\t&bnapi->status_blk.msi->status_tx_quick_consumer_index0;\n\tbnapi->hw_rx_cons_ptr =\n\t\t&bnapi->status_blk.msi->status_rx_quick_consumer_index0;\n\tif (bp->flags & BNX2_FLAG_MSIX_CAP) {\n\t\tfor (i = 1; i < bp->irq_nvecs; i++) {\n\t\t\tstruct status_block_msix *sblk;\n\n\t\t\tbnapi = &bp->bnx2_napi[i];\n\n\t\t\tsblk = (bp->status_blk + BNX2_SBLK_MSIX_ALIGN_SIZE * i);\n\t\t\tbnapi->status_blk.msix = sblk;\n\t\t\tbnapi->hw_tx_cons_ptr =\n\t\t\t\t&sblk->status_tx_quick_consumer_index;\n\t\t\tbnapi->hw_rx_cons_ptr =\n\t\t\t\t&sblk->status_rx_quick_consumer_index;\n\t\t\tbnapi->int_num = i << 24;\n\t\t}\n\t}\n\n\tif (BNX2_CHIP(bp) == BNX2_CHIP_5709) {\n\t\tbp->ctx_pages = 0x2000 / BNX2_PAGE_SIZE;\n\t\tif (bp->ctx_pages == 0)\n\t\t\tbp->ctx_pages = 1;\n\t\tfor (i = 0; i < bp->ctx_pages; i++) {\n\t\t\tbp->ctx_blk[i] = dma_alloc_coherent(&bp->pdev->dev,\n\t\t\t\t\t\tBNX2_PAGE_SIZE,\n\t\t\t\t\t\t&bp->ctx_blk_mapping[i],\n\t\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (!bp->ctx_blk[i])\n\t\t\t\tgoto alloc_mem_err;\n\t\t}\n\t}\n\n\terr = bnx2_alloc_rx_mem(bp);\n\tif (err)\n\t\tgoto alloc_mem_err;\n\n\terr = bnx2_alloc_tx_mem(bp);\n\tif (err)\n\t\tgoto alloc_mem_err;\n\n\treturn 0;\n\nalloc_mem_err:\n\tbnx2_free_mem(bp);\n\treturn -ENOMEM;\n}\n\nstatic void\nbnx2_report_fw_link(struct bnx2 *bp)\n{\n\tu32 fw_link_status = 0;\n\n\tif (bp->phy_flags & BNX2_PHY_FLAG_REMOTE_PHY_CAP)\n\t\treturn;\n\n\tif (bp->link_up) {\n\t\tu32 bmsr;\n\n\t\tswitch (bp->line_speed) {\n\t\tcase SPEED_10:\n\t\t\tif (bp->duplex == DUPLEX_HALF)\n\t\t\t\tfw_link_status = BNX2_LINK_STATUS_10HALF;\n\t\t\telse\n\t\t\t\tfw_link_status = BNX2_LINK_STATUS_10FULL;\n\t\t\tbreak;\n\t\tcase SPEED_100:\n\t\t\tif (bp->duplex == DUPLEX_HALF)\n\t\t\t\tfw_link_status = BNX2_LINK_STATUS_100HALF;\n\t\t\telse\n\t\t\t\tfw_link_status = BNX2_LINK_STATUS_100FULL;\n\t\t\tbreak;\n\t\tcase SPEED_1000:\n\t\t\tif (bp->duplex == DUPLEX_HALF)\n\t\t\t\tfw_link_status = BNX2_LINK_STATUS_1000HALF;\n\t\t\telse\n\t\t\t\tfw_link_status = BNX2_LINK_STATUS_1000FULL;\n\t\t\tbreak;\n\t\tcase SPEED_2500:\n\t\t\tif (bp->duplex == DUPLEX_HALF)\n\t\t\t\tfw_link_status = BNX2_LINK_STATUS_2500HALF;\n\t\t\telse\n\t\t\t\tfw_link_status = BNX2_LINK_STATUS_2500FULL;\n\t\t\tbreak;\n\t\t}\n\n\t\tfw_link_status |= BNX2_LINK_STATUS_LINK_UP;\n\n\t\tif (bp->autoneg) {\n\t\t\tfw_link_status |= BNX2_LINK_STATUS_AN_ENABLED;\n\n\t\t\tbnx2_read_phy(bp, bp->mii_bmsr, &bmsr);\n\t\t\tbnx2_read_phy(bp, bp->mii_bmsr, &bmsr);\n\n\t\t\tif (!(bmsr & BMSR_ANEGCOMPLETE) ||\n\t\t\t    bp->phy_flags & BNX2_PHY_FLAG_PARALLEL_DETECT)\n\t\t\t\tfw_link_status |= BNX2_LINK_STATUS_PARALLEL_DET;\n\t\t\telse\n\t\t\t\tfw_link_status |= BNX2_LINK_STATUS_AN_COMPLETE;\n\t\t}\n\t}\n\telse\n\t\tfw_link_status = BNX2_LINK_STATUS_LINK_DOWN;\n\n\tbnx2_shmem_wr(bp, BNX2_LINK_STATUS, fw_link_status);\n}\n\nstatic char *\nbnx2_xceiver_str(struct bnx2 *bp)\n{\n\treturn (bp->phy_port == PORT_FIBRE) ? \"SerDes\" :\n\t\t((bp->phy_flags & BNX2_PHY_FLAG_SERDES) ? \"Remote Copper\" :\n\t\t \"Copper\");\n}\n\nstatic void\nbnx2_report_link(struct bnx2 *bp)\n{\n\tif (bp->link_up) {\n\t\tnetif_carrier_on(bp->dev);\n\t\tnetdev_info(bp->dev, \"NIC %s Link is Up, %d Mbps %s duplex\",\n\t\t\t    bnx2_xceiver_str(bp),\n\t\t\t    bp->line_speed,\n\t\t\t    bp->duplex == DUPLEX_FULL ? \"full\" : \"half\");\n\n\t\tif (bp->flow_ctrl) {\n\t\t\tif (bp->flow_ctrl & FLOW_CTRL_RX) {\n\t\t\t\tpr_cont(\", receive \");\n\t\t\t\tif (bp->flow_ctrl & FLOW_CTRL_TX)\n\t\t\t\t\tpr_cont(\"& transmit \");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tpr_cont(\", transmit \");\n\t\t\t}\n\t\t\tpr_cont(\"flow control ON\");\n\t\t}\n\t\tpr_cont(\"\\n\");\n\t} else {\n\t\tnetif_carrier_off(bp->dev);\n\t\tnetdev_err(bp->dev, \"NIC %s Link is Down\\n\",\n\t\t\t   bnx2_xceiver_str(bp));\n\t}\n\n\tbnx2_report_fw_link(bp);\n}\n\nstatic void\nbnx2_resolve_flow_ctrl(struct bnx2 *bp)\n{\n\tu32 local_adv, remote_adv;\n\n\tbp->flow_ctrl = 0;\n\tif ((bp->autoneg & (AUTONEG_SPEED | AUTONEG_FLOW_CTRL)) !=\n\t\t(AUTONEG_SPEED | AUTONEG_FLOW_CTRL)) {\n\n\t\tif (bp->duplex == DUPLEX_FULL) {\n\t\t\tbp->flow_ctrl = bp->req_flow_ctrl;\n\t\t}\n\t\treturn;\n\t}\n\n\tif (bp->duplex != DUPLEX_FULL) {\n\t\treturn;\n\t}\n\n\tif ((bp->phy_flags & BNX2_PHY_FLAG_SERDES) &&\n\t    (BNX2_CHIP(bp) == BNX2_CHIP_5708)) {\n\t\tu32 val;\n\n\t\tbnx2_read_phy(bp, BCM5708S_1000X_STAT1, &val);\n\t\tif (val & BCM5708S_1000X_STAT1_TX_PAUSE)\n\t\t\tbp->flow_ctrl |= FLOW_CTRL_TX;\n\t\tif (val & BCM5708S_1000X_STAT1_RX_PAUSE)\n\t\t\tbp->flow_ctrl |= FLOW_CTRL_RX;\n\t\treturn;\n\t}\n\n\tbnx2_read_phy(bp, bp->mii_adv, &local_adv);\n\tbnx2_read_phy(bp, bp->mii_lpa, &remote_adv);\n\n\tif (bp->phy_flags & BNX2_PHY_FLAG_SERDES) {\n\t\tu32 new_local_adv = 0;\n\t\tu32 new_remote_adv = 0;\n\n\t\tif (local_adv & ADVERTISE_1000XPAUSE)\n\t\t\tnew_local_adv |= ADVERTISE_PAUSE_CAP;\n\t\tif (local_adv & ADVERTISE_1000XPSE_ASYM)\n\t\t\tnew_local_adv |= ADVERTISE_PAUSE_ASYM;\n\t\tif (remote_adv & ADVERTISE_1000XPAUSE)\n\t\t\tnew_remote_adv |= ADVERTISE_PAUSE_CAP;\n\t\tif (remote_adv & ADVERTISE_1000XPSE_ASYM)\n\t\t\tnew_remote_adv |= ADVERTISE_PAUSE_ASYM;\n\n\t\tlocal_adv = new_local_adv;\n\t\tremote_adv = new_remote_adv;\n\t}\n\n\t \n\tif (local_adv & ADVERTISE_PAUSE_CAP) {\n\t\tif(local_adv & ADVERTISE_PAUSE_ASYM) {\n\t                if (remote_adv & ADVERTISE_PAUSE_CAP) {\n\t\t\t\tbp->flow_ctrl = FLOW_CTRL_TX | FLOW_CTRL_RX;\n\t\t\t}\n\t\t\telse if (remote_adv & ADVERTISE_PAUSE_ASYM) {\n\t\t\t\tbp->flow_ctrl = FLOW_CTRL_RX;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (remote_adv & ADVERTISE_PAUSE_CAP) {\n\t\t\t\tbp->flow_ctrl = FLOW_CTRL_TX | FLOW_CTRL_RX;\n\t\t\t}\n\t\t}\n\t}\n\telse if (local_adv & ADVERTISE_PAUSE_ASYM) {\n\t\tif ((remote_adv & ADVERTISE_PAUSE_CAP) &&\n\t\t\t(remote_adv & ADVERTISE_PAUSE_ASYM)) {\n\n\t\t\tbp->flow_ctrl = FLOW_CTRL_TX;\n\t\t}\n\t}\n}\n\nstatic int\nbnx2_5709s_linkup(struct bnx2 *bp)\n{\n\tu32 val, speed;\n\n\tbp->link_up = 1;\n\n\tbnx2_write_phy(bp, MII_BNX2_BLK_ADDR, MII_BNX2_BLK_ADDR_GP_STATUS);\n\tbnx2_read_phy(bp, MII_BNX2_GP_TOP_AN_STATUS1, &val);\n\tbnx2_write_phy(bp, MII_BNX2_BLK_ADDR, MII_BNX2_BLK_ADDR_COMBO_IEEEB0);\n\n\tif ((bp->autoneg & AUTONEG_SPEED) == 0) {\n\t\tbp->line_speed = bp->req_line_speed;\n\t\tbp->duplex = bp->req_duplex;\n\t\treturn 0;\n\t}\n\tspeed = val & MII_BNX2_GP_TOP_AN_SPEED_MSK;\n\tswitch (speed) {\n\t\tcase MII_BNX2_GP_TOP_AN_SPEED_10:\n\t\t\tbp->line_speed = SPEED_10;\n\t\t\tbreak;\n\t\tcase MII_BNX2_GP_TOP_AN_SPEED_100:\n\t\t\tbp->line_speed = SPEED_100;\n\t\t\tbreak;\n\t\tcase MII_BNX2_GP_TOP_AN_SPEED_1G:\n\t\tcase MII_BNX2_GP_TOP_AN_SPEED_1GKV:\n\t\t\tbp->line_speed = SPEED_1000;\n\t\t\tbreak;\n\t\tcase MII_BNX2_GP_TOP_AN_SPEED_2_5G:\n\t\t\tbp->line_speed = SPEED_2500;\n\t\t\tbreak;\n\t}\n\tif (val & MII_BNX2_GP_TOP_AN_FD)\n\t\tbp->duplex = DUPLEX_FULL;\n\telse\n\t\tbp->duplex = DUPLEX_HALF;\n\treturn 0;\n}\n\nstatic int\nbnx2_5708s_linkup(struct bnx2 *bp)\n{\n\tu32 val;\n\n\tbp->link_up = 1;\n\tbnx2_read_phy(bp, BCM5708S_1000X_STAT1, &val);\n\tswitch (val & BCM5708S_1000X_STAT1_SPEED_MASK) {\n\t\tcase BCM5708S_1000X_STAT1_SPEED_10:\n\t\t\tbp->line_speed = SPEED_10;\n\t\t\tbreak;\n\t\tcase BCM5708S_1000X_STAT1_SPEED_100:\n\t\t\tbp->line_speed = SPEED_100;\n\t\t\tbreak;\n\t\tcase BCM5708S_1000X_STAT1_SPEED_1G:\n\t\t\tbp->line_speed = SPEED_1000;\n\t\t\tbreak;\n\t\tcase BCM5708S_1000X_STAT1_SPEED_2G5:\n\t\t\tbp->line_speed = SPEED_2500;\n\t\t\tbreak;\n\t}\n\tif (val & BCM5708S_1000X_STAT1_FD)\n\t\tbp->duplex = DUPLEX_FULL;\n\telse\n\t\tbp->duplex = DUPLEX_HALF;\n\n\treturn 0;\n}\n\nstatic int\nbnx2_5706s_linkup(struct bnx2 *bp)\n{\n\tu32 bmcr, local_adv, remote_adv, common;\n\n\tbp->link_up = 1;\n\tbp->line_speed = SPEED_1000;\n\n\tbnx2_read_phy(bp, bp->mii_bmcr, &bmcr);\n\tif (bmcr & BMCR_FULLDPLX) {\n\t\tbp->duplex = DUPLEX_FULL;\n\t}\n\telse {\n\t\tbp->duplex = DUPLEX_HALF;\n\t}\n\n\tif (!(bmcr & BMCR_ANENABLE)) {\n\t\treturn 0;\n\t}\n\n\tbnx2_read_phy(bp, bp->mii_adv, &local_adv);\n\tbnx2_read_phy(bp, bp->mii_lpa, &remote_adv);\n\n\tcommon = local_adv & remote_adv;\n\tif (common & (ADVERTISE_1000XHALF | ADVERTISE_1000XFULL)) {\n\n\t\tif (common & ADVERTISE_1000XFULL) {\n\t\t\tbp->duplex = DUPLEX_FULL;\n\t\t}\n\t\telse {\n\t\t\tbp->duplex = DUPLEX_HALF;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int\nbnx2_copper_linkup(struct bnx2 *bp)\n{\n\tu32 bmcr;\n\n\tbp->phy_flags &= ~BNX2_PHY_FLAG_MDIX;\n\n\tbnx2_read_phy(bp, bp->mii_bmcr, &bmcr);\n\tif (bmcr & BMCR_ANENABLE) {\n\t\tu32 local_adv, remote_adv, common;\n\n\t\tbnx2_read_phy(bp, MII_CTRL1000, &local_adv);\n\t\tbnx2_read_phy(bp, MII_STAT1000, &remote_adv);\n\n\t\tcommon = local_adv & (remote_adv >> 2);\n\t\tif (common & ADVERTISE_1000FULL) {\n\t\t\tbp->line_speed = SPEED_1000;\n\t\t\tbp->duplex = DUPLEX_FULL;\n\t\t}\n\t\telse if (common & ADVERTISE_1000HALF) {\n\t\t\tbp->line_speed = SPEED_1000;\n\t\t\tbp->duplex = DUPLEX_HALF;\n\t\t}\n\t\telse {\n\t\t\tbnx2_read_phy(bp, bp->mii_adv, &local_adv);\n\t\t\tbnx2_read_phy(bp, bp->mii_lpa, &remote_adv);\n\n\t\t\tcommon = local_adv & remote_adv;\n\t\t\tif (common & ADVERTISE_100FULL) {\n\t\t\t\tbp->line_speed = SPEED_100;\n\t\t\t\tbp->duplex = DUPLEX_FULL;\n\t\t\t}\n\t\t\telse if (common & ADVERTISE_100HALF) {\n\t\t\t\tbp->line_speed = SPEED_100;\n\t\t\t\tbp->duplex = DUPLEX_HALF;\n\t\t\t}\n\t\t\telse if (common & ADVERTISE_10FULL) {\n\t\t\t\tbp->line_speed = SPEED_10;\n\t\t\t\tbp->duplex = DUPLEX_FULL;\n\t\t\t}\n\t\t\telse if (common & ADVERTISE_10HALF) {\n\t\t\t\tbp->line_speed = SPEED_10;\n\t\t\t\tbp->duplex = DUPLEX_HALF;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbp->line_speed = 0;\n\t\t\t\tbp->link_up = 0;\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\tif (bmcr & BMCR_SPEED100) {\n\t\t\tbp->line_speed = SPEED_100;\n\t\t}\n\t\telse {\n\t\t\tbp->line_speed = SPEED_10;\n\t\t}\n\t\tif (bmcr & BMCR_FULLDPLX) {\n\t\t\tbp->duplex = DUPLEX_FULL;\n\t\t}\n\t\telse {\n\t\t\tbp->duplex = DUPLEX_HALF;\n\t\t}\n\t}\n\n\tif (bp->link_up) {\n\t\tu32 ext_status;\n\n\t\tbnx2_read_phy(bp, MII_BNX2_EXT_STATUS, &ext_status);\n\t\tif (ext_status & EXT_STATUS_MDIX)\n\t\t\tbp->phy_flags |= BNX2_PHY_FLAG_MDIX;\n\t}\n\n\treturn 0;\n}\n\nstatic void\nbnx2_init_rx_context(struct bnx2 *bp, u32 cid)\n{\n\tu32 val, rx_cid_addr = GET_CID_ADDR(cid);\n\n\tval = BNX2_L2CTX_CTX_TYPE_CTX_BD_CHN_TYPE_VALUE;\n\tval |= BNX2_L2CTX_CTX_TYPE_SIZE_L2;\n\tval |= 0x02 << 8;\n\n\tif (bp->flow_ctrl & FLOW_CTRL_TX)\n\t\tval |= BNX2_L2CTX_FLOW_CTRL_ENABLE;\n\n\tbnx2_ctx_wr(bp, rx_cid_addr, BNX2_L2CTX_CTX_TYPE, val);\n}\n\nstatic void\nbnx2_init_all_rx_contexts(struct bnx2 *bp)\n{\n\tint i;\n\tu32 cid;\n\n\tfor (i = 0, cid = RX_CID; i < bp->num_rx_rings; i++, cid++) {\n\t\tif (i == 1)\n\t\t\tcid = RX_RSS_CID;\n\t\tbnx2_init_rx_context(bp, cid);\n\t}\n}\n\nstatic void\nbnx2_set_mac_link(struct bnx2 *bp)\n{\n\tu32 val;\n\n\tBNX2_WR(bp, BNX2_EMAC_TX_LENGTHS, 0x2620);\n\tif (bp->link_up && (bp->line_speed == SPEED_1000) &&\n\t\t(bp->duplex == DUPLEX_HALF)) {\n\t\tBNX2_WR(bp, BNX2_EMAC_TX_LENGTHS, 0x26ff);\n\t}\n\n\t \n\tval = BNX2_RD(bp, BNX2_EMAC_MODE);\n\n\tval &= ~(BNX2_EMAC_MODE_PORT | BNX2_EMAC_MODE_HALF_DUPLEX |\n\t\tBNX2_EMAC_MODE_MAC_LOOP | BNX2_EMAC_MODE_FORCE_LINK |\n\t\tBNX2_EMAC_MODE_25G_MODE);\n\n\tif (bp->link_up) {\n\t\tswitch (bp->line_speed) {\n\t\t\tcase SPEED_10:\n\t\t\t\tif (BNX2_CHIP(bp) != BNX2_CHIP_5706) {\n\t\t\t\t\tval |= BNX2_EMAC_MODE_PORT_MII_10M;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfallthrough;\n\t\t\tcase SPEED_100:\n\t\t\t\tval |= BNX2_EMAC_MODE_PORT_MII;\n\t\t\t\tbreak;\n\t\t\tcase SPEED_2500:\n\t\t\t\tval |= BNX2_EMAC_MODE_25G_MODE;\n\t\t\t\tfallthrough;\n\t\t\tcase SPEED_1000:\n\t\t\t\tval |= BNX2_EMAC_MODE_PORT_GMII;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\telse {\n\t\tval |= BNX2_EMAC_MODE_PORT_GMII;\n\t}\n\n\t \n\tif (bp->duplex == DUPLEX_HALF)\n\t\tval |= BNX2_EMAC_MODE_HALF_DUPLEX;\n\tBNX2_WR(bp, BNX2_EMAC_MODE, val);\n\n\t \n\tbp->rx_mode &= ~BNX2_EMAC_RX_MODE_FLOW_EN;\n\n\tif (bp->flow_ctrl & FLOW_CTRL_RX)\n\t\tbp->rx_mode |= BNX2_EMAC_RX_MODE_FLOW_EN;\n\tBNX2_WR(bp, BNX2_EMAC_RX_MODE, bp->rx_mode);\n\n\t \n\tval = BNX2_RD(bp, BNX2_EMAC_TX_MODE);\n\tval &= ~BNX2_EMAC_TX_MODE_FLOW_EN;\n\n\tif (bp->flow_ctrl & FLOW_CTRL_TX)\n\t\tval |= BNX2_EMAC_TX_MODE_FLOW_EN;\n\tBNX2_WR(bp, BNX2_EMAC_TX_MODE, val);\n\n\t \n\tBNX2_WR(bp, BNX2_EMAC_STATUS, BNX2_EMAC_STATUS_LINK_CHANGE);\n\n\tbnx2_init_all_rx_contexts(bp);\n}\n\nstatic void\nbnx2_enable_bmsr1(struct bnx2 *bp)\n{\n\tif ((bp->phy_flags & BNX2_PHY_FLAG_SERDES) &&\n\t    (BNX2_CHIP(bp) == BNX2_CHIP_5709))\n\t\tbnx2_write_phy(bp, MII_BNX2_BLK_ADDR,\n\t\t\t       MII_BNX2_BLK_ADDR_GP_STATUS);\n}\n\nstatic void\nbnx2_disable_bmsr1(struct bnx2 *bp)\n{\n\tif ((bp->phy_flags & BNX2_PHY_FLAG_SERDES) &&\n\t    (BNX2_CHIP(bp) == BNX2_CHIP_5709))\n\t\tbnx2_write_phy(bp, MII_BNX2_BLK_ADDR,\n\t\t\t       MII_BNX2_BLK_ADDR_COMBO_IEEEB0);\n}\n\nstatic int\nbnx2_test_and_enable_2g5(struct bnx2 *bp)\n{\n\tu32 up1;\n\tint ret = 1;\n\n\tif (!(bp->phy_flags & BNX2_PHY_FLAG_2_5G_CAPABLE))\n\t\treturn 0;\n\n\tif (bp->autoneg & AUTONEG_SPEED)\n\t\tbp->advertising |= ADVERTISED_2500baseX_Full;\n\n\tif (BNX2_CHIP(bp) == BNX2_CHIP_5709)\n\t\tbnx2_write_phy(bp, MII_BNX2_BLK_ADDR, MII_BNX2_BLK_ADDR_OVER1G);\n\n\tbnx2_read_phy(bp, bp->mii_up1, &up1);\n\tif (!(up1 & BCM5708S_UP1_2G5)) {\n\t\tup1 |= BCM5708S_UP1_2G5;\n\t\tbnx2_write_phy(bp, bp->mii_up1, up1);\n\t\tret = 0;\n\t}\n\n\tif (BNX2_CHIP(bp) == BNX2_CHIP_5709)\n\t\tbnx2_write_phy(bp, MII_BNX2_BLK_ADDR,\n\t\t\t       MII_BNX2_BLK_ADDR_COMBO_IEEEB0);\n\n\treturn ret;\n}\n\nstatic int\nbnx2_test_and_disable_2g5(struct bnx2 *bp)\n{\n\tu32 up1;\n\tint ret = 0;\n\n\tif (!(bp->phy_flags & BNX2_PHY_FLAG_2_5G_CAPABLE))\n\t\treturn 0;\n\n\tif (BNX2_CHIP(bp) == BNX2_CHIP_5709)\n\t\tbnx2_write_phy(bp, MII_BNX2_BLK_ADDR, MII_BNX2_BLK_ADDR_OVER1G);\n\n\tbnx2_read_phy(bp, bp->mii_up1, &up1);\n\tif (up1 & BCM5708S_UP1_2G5) {\n\t\tup1 &= ~BCM5708S_UP1_2G5;\n\t\tbnx2_write_phy(bp, bp->mii_up1, up1);\n\t\tret = 1;\n\t}\n\n\tif (BNX2_CHIP(bp) == BNX2_CHIP_5709)\n\t\tbnx2_write_phy(bp, MII_BNX2_BLK_ADDR,\n\t\t\t       MII_BNX2_BLK_ADDR_COMBO_IEEEB0);\n\n\treturn ret;\n}\n\nstatic void\nbnx2_enable_forced_2g5(struct bnx2 *bp)\n{\n\tu32 bmcr;\n\tint err;\n\n\tif (!(bp->phy_flags & BNX2_PHY_FLAG_2_5G_CAPABLE))\n\t\treturn;\n\n\tif (BNX2_CHIP(bp) == BNX2_CHIP_5709) {\n\t\tu32 val;\n\n\t\tbnx2_write_phy(bp, MII_BNX2_BLK_ADDR,\n\t\t\t       MII_BNX2_BLK_ADDR_SERDES_DIG);\n\t\tif (!bnx2_read_phy(bp, MII_BNX2_SERDES_DIG_MISC1, &val)) {\n\t\t\tval &= ~MII_BNX2_SD_MISC1_FORCE_MSK;\n\t\t\tval |= MII_BNX2_SD_MISC1_FORCE |\n\t\t\t\tMII_BNX2_SD_MISC1_FORCE_2_5G;\n\t\t\tbnx2_write_phy(bp, MII_BNX2_SERDES_DIG_MISC1, val);\n\t\t}\n\n\t\tbnx2_write_phy(bp, MII_BNX2_BLK_ADDR,\n\t\t\t       MII_BNX2_BLK_ADDR_COMBO_IEEEB0);\n\t\terr = bnx2_read_phy(bp, bp->mii_bmcr, &bmcr);\n\n\t} else if (BNX2_CHIP(bp) == BNX2_CHIP_5708) {\n\t\terr = bnx2_read_phy(bp, bp->mii_bmcr, &bmcr);\n\t\tif (!err)\n\t\t\tbmcr |= BCM5708S_BMCR_FORCE_2500;\n\t} else {\n\t\treturn;\n\t}\n\n\tif (err)\n\t\treturn;\n\n\tif (bp->autoneg & AUTONEG_SPEED) {\n\t\tbmcr &= ~BMCR_ANENABLE;\n\t\tif (bp->req_duplex == DUPLEX_FULL)\n\t\t\tbmcr |= BMCR_FULLDPLX;\n\t}\n\tbnx2_write_phy(bp, bp->mii_bmcr, bmcr);\n}\n\nstatic void\nbnx2_disable_forced_2g5(struct bnx2 *bp)\n{\n\tu32 bmcr;\n\tint err;\n\n\tif (!(bp->phy_flags & BNX2_PHY_FLAG_2_5G_CAPABLE))\n\t\treturn;\n\n\tif (BNX2_CHIP(bp) == BNX2_CHIP_5709) {\n\t\tu32 val;\n\n\t\tbnx2_write_phy(bp, MII_BNX2_BLK_ADDR,\n\t\t\t       MII_BNX2_BLK_ADDR_SERDES_DIG);\n\t\tif (!bnx2_read_phy(bp, MII_BNX2_SERDES_DIG_MISC1, &val)) {\n\t\t\tval &= ~MII_BNX2_SD_MISC1_FORCE;\n\t\t\tbnx2_write_phy(bp, MII_BNX2_SERDES_DIG_MISC1, val);\n\t\t}\n\n\t\tbnx2_write_phy(bp, MII_BNX2_BLK_ADDR,\n\t\t\t       MII_BNX2_BLK_ADDR_COMBO_IEEEB0);\n\t\terr = bnx2_read_phy(bp, bp->mii_bmcr, &bmcr);\n\n\t} else if (BNX2_CHIP(bp) == BNX2_CHIP_5708) {\n\t\terr = bnx2_read_phy(bp, bp->mii_bmcr, &bmcr);\n\t\tif (!err)\n\t\t\tbmcr &= ~BCM5708S_BMCR_FORCE_2500;\n\t} else {\n\t\treturn;\n\t}\n\n\tif (err)\n\t\treturn;\n\n\tif (bp->autoneg & AUTONEG_SPEED)\n\t\tbmcr |= BMCR_SPEED1000 | BMCR_ANENABLE | BMCR_ANRESTART;\n\tbnx2_write_phy(bp, bp->mii_bmcr, bmcr);\n}\n\nstatic void\nbnx2_5706s_force_link_dn(struct bnx2 *bp, int start)\n{\n\tu32 val;\n\n\tbnx2_write_phy(bp, MII_BNX2_DSP_ADDRESS, MII_EXPAND_SERDES_CTL);\n\tbnx2_read_phy(bp, MII_BNX2_DSP_RW_PORT, &val);\n\tif (start)\n\t\tbnx2_write_phy(bp, MII_BNX2_DSP_RW_PORT, val & 0xff0f);\n\telse\n\t\tbnx2_write_phy(bp, MII_BNX2_DSP_RW_PORT, val | 0xc0);\n}\n\nstatic int\nbnx2_set_link(struct bnx2 *bp)\n{\n\tu32 bmsr;\n\tu8 link_up;\n\n\tif (bp->loopback == MAC_LOOPBACK || bp->loopback == PHY_LOOPBACK) {\n\t\tbp->link_up = 1;\n\t\treturn 0;\n\t}\n\n\tif (bp->phy_flags & BNX2_PHY_FLAG_REMOTE_PHY_CAP)\n\t\treturn 0;\n\n\tlink_up = bp->link_up;\n\n\tbnx2_enable_bmsr1(bp);\n\tbnx2_read_phy(bp, bp->mii_bmsr1, &bmsr);\n\tbnx2_read_phy(bp, bp->mii_bmsr1, &bmsr);\n\tbnx2_disable_bmsr1(bp);\n\n\tif ((bp->phy_flags & BNX2_PHY_FLAG_SERDES) &&\n\t    (BNX2_CHIP(bp) == BNX2_CHIP_5706)) {\n\t\tu32 val, an_dbg;\n\n\t\tif (bp->phy_flags & BNX2_PHY_FLAG_FORCED_DOWN) {\n\t\t\tbnx2_5706s_force_link_dn(bp, 0);\n\t\t\tbp->phy_flags &= ~BNX2_PHY_FLAG_FORCED_DOWN;\n\t\t}\n\t\tval = BNX2_RD(bp, BNX2_EMAC_STATUS);\n\n\t\tbnx2_write_phy(bp, MII_BNX2_MISC_SHADOW, MISC_SHDW_AN_DBG);\n\t\tbnx2_read_phy(bp, MII_BNX2_MISC_SHADOW, &an_dbg);\n\t\tbnx2_read_phy(bp, MII_BNX2_MISC_SHADOW, &an_dbg);\n\n\t\tif ((val & BNX2_EMAC_STATUS_LINK) &&\n\t\t    !(an_dbg & MISC_SHDW_AN_DBG_NOSYNC))\n\t\t\tbmsr |= BMSR_LSTATUS;\n\t\telse\n\t\t\tbmsr &= ~BMSR_LSTATUS;\n\t}\n\n\tif (bmsr & BMSR_LSTATUS) {\n\t\tbp->link_up = 1;\n\n\t\tif (bp->phy_flags & BNX2_PHY_FLAG_SERDES) {\n\t\t\tif (BNX2_CHIP(bp) == BNX2_CHIP_5706)\n\t\t\t\tbnx2_5706s_linkup(bp);\n\t\t\telse if (BNX2_CHIP(bp) == BNX2_CHIP_5708)\n\t\t\t\tbnx2_5708s_linkup(bp);\n\t\t\telse if (BNX2_CHIP(bp) == BNX2_CHIP_5709)\n\t\t\t\tbnx2_5709s_linkup(bp);\n\t\t}\n\t\telse {\n\t\t\tbnx2_copper_linkup(bp);\n\t\t}\n\t\tbnx2_resolve_flow_ctrl(bp);\n\t}\n\telse {\n\t\tif ((bp->phy_flags & BNX2_PHY_FLAG_SERDES) &&\n\t\t    (bp->autoneg & AUTONEG_SPEED))\n\t\t\tbnx2_disable_forced_2g5(bp);\n\n\t\tif (bp->phy_flags & BNX2_PHY_FLAG_PARALLEL_DETECT) {\n\t\t\tu32 bmcr;\n\n\t\t\tbnx2_read_phy(bp, bp->mii_bmcr, &bmcr);\n\t\t\tbmcr |= BMCR_ANENABLE;\n\t\t\tbnx2_write_phy(bp, bp->mii_bmcr, bmcr);\n\n\t\t\tbp->phy_flags &= ~BNX2_PHY_FLAG_PARALLEL_DETECT;\n\t\t}\n\t\tbp->link_up = 0;\n\t}\n\n\tif (bp->link_up != link_up) {\n\t\tbnx2_report_link(bp);\n\t}\n\n\tbnx2_set_mac_link(bp);\n\n\treturn 0;\n}\n\nstatic int\nbnx2_reset_phy(struct bnx2 *bp)\n{\n\tint i;\n\tu32 reg;\n\n        bnx2_write_phy(bp, bp->mii_bmcr, BMCR_RESET);\n\n#define PHY_RESET_MAX_WAIT 100\n\tfor (i = 0; i < PHY_RESET_MAX_WAIT; i++) {\n\t\tudelay(10);\n\n\t\tbnx2_read_phy(bp, bp->mii_bmcr, &reg);\n\t\tif (!(reg & BMCR_RESET)) {\n\t\t\tudelay(20);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i == PHY_RESET_MAX_WAIT) {\n\t\treturn -EBUSY;\n\t}\n\treturn 0;\n}\n\nstatic u32\nbnx2_phy_get_pause_adv(struct bnx2 *bp)\n{\n\tu32 adv = 0;\n\n\tif ((bp->req_flow_ctrl & (FLOW_CTRL_RX | FLOW_CTRL_TX)) ==\n\t\t(FLOW_CTRL_RX | FLOW_CTRL_TX)) {\n\n\t\tif (bp->phy_flags & BNX2_PHY_FLAG_SERDES) {\n\t\t\tadv = ADVERTISE_1000XPAUSE;\n\t\t}\n\t\telse {\n\t\t\tadv = ADVERTISE_PAUSE_CAP;\n\t\t}\n\t}\n\telse if (bp->req_flow_ctrl & FLOW_CTRL_TX) {\n\t\tif (bp->phy_flags & BNX2_PHY_FLAG_SERDES) {\n\t\t\tadv = ADVERTISE_1000XPSE_ASYM;\n\t\t}\n\t\telse {\n\t\t\tadv = ADVERTISE_PAUSE_ASYM;\n\t\t}\n\t}\n\telse if (bp->req_flow_ctrl & FLOW_CTRL_RX) {\n\t\tif (bp->phy_flags & BNX2_PHY_FLAG_SERDES) {\n\t\t\tadv = ADVERTISE_1000XPAUSE | ADVERTISE_1000XPSE_ASYM;\n\t\t}\n\t\telse {\n\t\t\tadv = ADVERTISE_PAUSE_CAP | ADVERTISE_PAUSE_ASYM;\n\t\t}\n\t}\n\treturn adv;\n}\n\nstatic int bnx2_fw_sync(struct bnx2 *, u32, int, int);\n\nstatic int\nbnx2_setup_remote_phy(struct bnx2 *bp, u8 port)\n__releases(&bp->phy_lock)\n__acquires(&bp->phy_lock)\n{\n\tu32 speed_arg = 0, pause_adv;\n\n\tpause_adv = bnx2_phy_get_pause_adv(bp);\n\n\tif (bp->autoneg & AUTONEG_SPEED) {\n\t\tspeed_arg |= BNX2_NETLINK_SET_LINK_ENABLE_AUTONEG;\n\t\tif (bp->advertising & ADVERTISED_10baseT_Half)\n\t\t\tspeed_arg |= BNX2_NETLINK_SET_LINK_SPEED_10HALF;\n\t\tif (bp->advertising & ADVERTISED_10baseT_Full)\n\t\t\tspeed_arg |= BNX2_NETLINK_SET_LINK_SPEED_10FULL;\n\t\tif (bp->advertising & ADVERTISED_100baseT_Half)\n\t\t\tspeed_arg |= BNX2_NETLINK_SET_LINK_SPEED_100HALF;\n\t\tif (bp->advertising & ADVERTISED_100baseT_Full)\n\t\t\tspeed_arg |= BNX2_NETLINK_SET_LINK_SPEED_100FULL;\n\t\tif (bp->advertising & ADVERTISED_1000baseT_Full)\n\t\t\tspeed_arg |= BNX2_NETLINK_SET_LINK_SPEED_1GFULL;\n\t\tif (bp->advertising & ADVERTISED_2500baseX_Full)\n\t\t\tspeed_arg |= BNX2_NETLINK_SET_LINK_SPEED_2G5FULL;\n\t} else {\n\t\tif (bp->req_line_speed == SPEED_2500)\n\t\t\tspeed_arg = BNX2_NETLINK_SET_LINK_SPEED_2G5FULL;\n\t\telse if (bp->req_line_speed == SPEED_1000)\n\t\t\tspeed_arg = BNX2_NETLINK_SET_LINK_SPEED_1GFULL;\n\t\telse if (bp->req_line_speed == SPEED_100) {\n\t\t\tif (bp->req_duplex == DUPLEX_FULL)\n\t\t\t\tspeed_arg = BNX2_NETLINK_SET_LINK_SPEED_100FULL;\n\t\t\telse\n\t\t\t\tspeed_arg = BNX2_NETLINK_SET_LINK_SPEED_100HALF;\n\t\t} else if (bp->req_line_speed == SPEED_10) {\n\t\t\tif (bp->req_duplex == DUPLEX_FULL)\n\t\t\t\tspeed_arg = BNX2_NETLINK_SET_LINK_SPEED_10FULL;\n\t\t\telse\n\t\t\t\tspeed_arg = BNX2_NETLINK_SET_LINK_SPEED_10HALF;\n\t\t}\n\t}\n\n\tif (pause_adv & (ADVERTISE_1000XPAUSE | ADVERTISE_PAUSE_CAP))\n\t\tspeed_arg |= BNX2_NETLINK_SET_LINK_FC_SYM_PAUSE;\n\tif (pause_adv & (ADVERTISE_1000XPSE_ASYM | ADVERTISE_PAUSE_ASYM))\n\t\tspeed_arg |= BNX2_NETLINK_SET_LINK_FC_ASYM_PAUSE;\n\n\tif (port == PORT_TP)\n\t\tspeed_arg |= BNX2_NETLINK_SET_LINK_PHY_APP_REMOTE |\n\t\t\t     BNX2_NETLINK_SET_LINK_ETH_AT_WIRESPEED;\n\n\tbnx2_shmem_wr(bp, BNX2_DRV_MB_ARG0, speed_arg);\n\n\tspin_unlock_bh(&bp->phy_lock);\n\tbnx2_fw_sync(bp, BNX2_DRV_MSG_CODE_CMD_SET_LINK, 1, 0);\n\tspin_lock_bh(&bp->phy_lock);\n\n\treturn 0;\n}\n\nstatic int\nbnx2_setup_serdes_phy(struct bnx2 *bp, u8 port)\n__releases(&bp->phy_lock)\n__acquires(&bp->phy_lock)\n{\n\tu32 adv, bmcr;\n\tu32 new_adv = 0;\n\n\tif (bp->phy_flags & BNX2_PHY_FLAG_REMOTE_PHY_CAP)\n\t\treturn bnx2_setup_remote_phy(bp, port);\n\n\tif (!(bp->autoneg & AUTONEG_SPEED)) {\n\t\tu32 new_bmcr;\n\t\tint force_link_down = 0;\n\n\t\tif (bp->req_line_speed == SPEED_2500) {\n\t\t\tif (!bnx2_test_and_enable_2g5(bp))\n\t\t\t\tforce_link_down = 1;\n\t\t} else if (bp->req_line_speed == SPEED_1000) {\n\t\t\tif (bnx2_test_and_disable_2g5(bp))\n\t\t\t\tforce_link_down = 1;\n\t\t}\n\t\tbnx2_read_phy(bp, bp->mii_adv, &adv);\n\t\tadv &= ~(ADVERTISE_1000XFULL | ADVERTISE_1000XHALF);\n\n\t\tbnx2_read_phy(bp, bp->mii_bmcr, &bmcr);\n\t\tnew_bmcr = bmcr & ~BMCR_ANENABLE;\n\t\tnew_bmcr |= BMCR_SPEED1000;\n\n\t\tif (BNX2_CHIP(bp) == BNX2_CHIP_5709) {\n\t\t\tif (bp->req_line_speed == SPEED_2500)\n\t\t\t\tbnx2_enable_forced_2g5(bp);\n\t\t\telse if (bp->req_line_speed == SPEED_1000) {\n\t\t\t\tbnx2_disable_forced_2g5(bp);\n\t\t\t\tnew_bmcr &= ~0x2000;\n\t\t\t}\n\n\t\t} else if (BNX2_CHIP(bp) == BNX2_CHIP_5708) {\n\t\t\tif (bp->req_line_speed == SPEED_2500)\n\t\t\t\tnew_bmcr |= BCM5708S_BMCR_FORCE_2500;\n\t\t\telse\n\t\t\t\tnew_bmcr = bmcr & ~BCM5708S_BMCR_FORCE_2500;\n\t\t}\n\n\t\tif (bp->req_duplex == DUPLEX_FULL) {\n\t\t\tadv |= ADVERTISE_1000XFULL;\n\t\t\tnew_bmcr |= BMCR_FULLDPLX;\n\t\t}\n\t\telse {\n\t\t\tadv |= ADVERTISE_1000XHALF;\n\t\t\tnew_bmcr &= ~BMCR_FULLDPLX;\n\t\t}\n\t\tif ((new_bmcr != bmcr) || (force_link_down)) {\n\t\t\t \n\t\t\tif (bp->link_up) {\n\t\t\t\tbnx2_write_phy(bp, bp->mii_adv, adv &\n\t\t\t\t\t       ~(ADVERTISE_1000XFULL |\n\t\t\t\t\t\t ADVERTISE_1000XHALF));\n\t\t\t\tbnx2_write_phy(bp, bp->mii_bmcr, bmcr |\n\t\t\t\t\tBMCR_ANRESTART | BMCR_ANENABLE);\n\n\t\t\t\tbp->link_up = 0;\n\t\t\t\tnetif_carrier_off(bp->dev);\n\t\t\t\tbnx2_write_phy(bp, bp->mii_bmcr, new_bmcr);\n\t\t\t\tbnx2_report_link(bp);\n\t\t\t}\n\t\t\tbnx2_write_phy(bp, bp->mii_adv, adv);\n\t\t\tbnx2_write_phy(bp, bp->mii_bmcr, new_bmcr);\n\t\t} else {\n\t\t\tbnx2_resolve_flow_ctrl(bp);\n\t\t\tbnx2_set_mac_link(bp);\n\t\t}\n\t\treturn 0;\n\t}\n\n\tbnx2_test_and_enable_2g5(bp);\n\n\tif (bp->advertising & ADVERTISED_1000baseT_Full)\n\t\tnew_adv |= ADVERTISE_1000XFULL;\n\n\tnew_adv |= bnx2_phy_get_pause_adv(bp);\n\n\tbnx2_read_phy(bp, bp->mii_adv, &adv);\n\tbnx2_read_phy(bp, bp->mii_bmcr, &bmcr);\n\n\tbp->serdes_an_pending = 0;\n\tif ((adv != new_adv) || ((bmcr & BMCR_ANENABLE) == 0)) {\n\t\t \n\t\tif (bp->link_up) {\n\t\t\tbnx2_write_phy(bp, bp->mii_bmcr, BMCR_LOOPBACK);\n\t\t\tspin_unlock_bh(&bp->phy_lock);\n\t\t\tmsleep(20);\n\t\t\tspin_lock_bh(&bp->phy_lock);\n\t\t}\n\n\t\tbnx2_write_phy(bp, bp->mii_adv, new_adv);\n\t\tbnx2_write_phy(bp, bp->mii_bmcr, bmcr | BMCR_ANRESTART |\n\t\t\tBMCR_ANENABLE);\n\t\t \n\t\tbp->current_interval = BNX2_SERDES_AN_TIMEOUT;\n\t\tbp->serdes_an_pending = 1;\n\t\tmod_timer(&bp->timer, jiffies + bp->current_interval);\n\t} else {\n\t\tbnx2_resolve_flow_ctrl(bp);\n\t\tbnx2_set_mac_link(bp);\n\t}\n\n\treturn 0;\n}\n\n#define ETHTOOL_ALL_FIBRE_SPEED\t\t\t\t\t\t\\\n\t(bp->phy_flags & BNX2_PHY_FLAG_2_5G_CAPABLE) ?\t\t\t\\\n\t\t(ADVERTISED_2500baseX_Full | ADVERTISED_1000baseT_Full) :\\\n\t\t(ADVERTISED_1000baseT_Full)\n\n#define ETHTOOL_ALL_COPPER_SPEED\t\t\t\t\t\\\n\t(ADVERTISED_10baseT_Half | ADVERTISED_10baseT_Full |\t\t\\\n\tADVERTISED_100baseT_Half | ADVERTISED_100baseT_Full |\t\t\\\n\tADVERTISED_1000baseT_Full)\n\n#define PHY_ALL_10_100_SPEED (ADVERTISE_10HALF | ADVERTISE_10FULL | \\\n\tADVERTISE_100HALF | ADVERTISE_100FULL | ADVERTISE_CSMA)\n\n#define PHY_ALL_1000_SPEED (ADVERTISE_1000HALF | ADVERTISE_1000FULL)\n\nstatic void\nbnx2_set_default_remote_link(struct bnx2 *bp)\n{\n\tu32 link;\n\n\tif (bp->phy_port == PORT_TP)\n\t\tlink = bnx2_shmem_rd(bp, BNX2_RPHY_COPPER_LINK);\n\telse\n\t\tlink = bnx2_shmem_rd(bp, BNX2_RPHY_SERDES_LINK);\n\n\tif (link & BNX2_NETLINK_SET_LINK_ENABLE_AUTONEG) {\n\t\tbp->req_line_speed = 0;\n\t\tbp->autoneg |= AUTONEG_SPEED;\n\t\tbp->advertising = ADVERTISED_Autoneg;\n\t\tif (link & BNX2_NETLINK_SET_LINK_SPEED_10HALF)\n\t\t\tbp->advertising |= ADVERTISED_10baseT_Half;\n\t\tif (link & BNX2_NETLINK_SET_LINK_SPEED_10FULL)\n\t\t\tbp->advertising |= ADVERTISED_10baseT_Full;\n\t\tif (link & BNX2_NETLINK_SET_LINK_SPEED_100HALF)\n\t\t\tbp->advertising |= ADVERTISED_100baseT_Half;\n\t\tif (link & BNX2_NETLINK_SET_LINK_SPEED_100FULL)\n\t\t\tbp->advertising |= ADVERTISED_100baseT_Full;\n\t\tif (link & BNX2_NETLINK_SET_LINK_SPEED_1GFULL)\n\t\t\tbp->advertising |= ADVERTISED_1000baseT_Full;\n\t\tif (link & BNX2_NETLINK_SET_LINK_SPEED_2G5FULL)\n\t\t\tbp->advertising |= ADVERTISED_2500baseX_Full;\n\t} else {\n\t\tbp->autoneg = 0;\n\t\tbp->advertising = 0;\n\t\tbp->req_duplex = DUPLEX_FULL;\n\t\tif (link & BNX2_NETLINK_SET_LINK_SPEED_10) {\n\t\t\tbp->req_line_speed = SPEED_10;\n\t\t\tif (link & BNX2_NETLINK_SET_LINK_SPEED_10HALF)\n\t\t\t\tbp->req_duplex = DUPLEX_HALF;\n\t\t}\n\t\tif (link & BNX2_NETLINK_SET_LINK_SPEED_100) {\n\t\t\tbp->req_line_speed = SPEED_100;\n\t\t\tif (link & BNX2_NETLINK_SET_LINK_SPEED_100HALF)\n\t\t\t\tbp->req_duplex = DUPLEX_HALF;\n\t\t}\n\t\tif (link & BNX2_NETLINK_SET_LINK_SPEED_1GFULL)\n\t\t\tbp->req_line_speed = SPEED_1000;\n\t\tif (link & BNX2_NETLINK_SET_LINK_SPEED_2G5FULL)\n\t\t\tbp->req_line_speed = SPEED_2500;\n\t}\n}\n\nstatic void\nbnx2_set_default_link(struct bnx2 *bp)\n{\n\tif (bp->phy_flags & BNX2_PHY_FLAG_REMOTE_PHY_CAP) {\n\t\tbnx2_set_default_remote_link(bp);\n\t\treturn;\n\t}\n\n\tbp->autoneg = AUTONEG_SPEED | AUTONEG_FLOW_CTRL;\n\tbp->req_line_speed = 0;\n\tif (bp->phy_flags & BNX2_PHY_FLAG_SERDES) {\n\t\tu32 reg;\n\n\t\tbp->advertising = ETHTOOL_ALL_FIBRE_SPEED | ADVERTISED_Autoneg;\n\n\t\treg = bnx2_shmem_rd(bp, BNX2_PORT_HW_CFG_CONFIG);\n\t\treg &= BNX2_PORT_HW_CFG_CFG_DFLT_LINK_MASK;\n\t\tif (reg == BNX2_PORT_HW_CFG_CFG_DFLT_LINK_1G) {\n\t\t\tbp->autoneg = 0;\n\t\t\tbp->req_line_speed = bp->line_speed = SPEED_1000;\n\t\t\tbp->req_duplex = DUPLEX_FULL;\n\t\t}\n\t} else\n\t\tbp->advertising = ETHTOOL_ALL_COPPER_SPEED | ADVERTISED_Autoneg;\n}\n\nstatic void\nbnx2_send_heart_beat(struct bnx2 *bp)\n{\n\tu32 msg;\n\tu32 addr;\n\n\tspin_lock(&bp->indirect_lock);\n\tmsg = (u32) (++bp->fw_drv_pulse_wr_seq & BNX2_DRV_PULSE_SEQ_MASK);\n\taddr = bp->shmem_base + BNX2_DRV_PULSE_MB;\n\tBNX2_WR(bp, BNX2_PCICFG_REG_WINDOW_ADDRESS, addr);\n\tBNX2_WR(bp, BNX2_PCICFG_REG_WINDOW, msg);\n\tspin_unlock(&bp->indirect_lock);\n}\n\nstatic void\nbnx2_remote_phy_event(struct bnx2 *bp)\n{\n\tu32 msg;\n\tu8 link_up = bp->link_up;\n\tu8 old_port;\n\n\tmsg = bnx2_shmem_rd(bp, BNX2_LINK_STATUS);\n\n\tif (msg & BNX2_LINK_STATUS_HEART_BEAT_EXPIRED)\n\t\tbnx2_send_heart_beat(bp);\n\n\tmsg &= ~BNX2_LINK_STATUS_HEART_BEAT_EXPIRED;\n\n\tif ((msg & BNX2_LINK_STATUS_LINK_UP) == BNX2_LINK_STATUS_LINK_DOWN)\n\t\tbp->link_up = 0;\n\telse {\n\t\tu32 speed;\n\n\t\tbp->link_up = 1;\n\t\tspeed = msg & BNX2_LINK_STATUS_SPEED_MASK;\n\t\tbp->duplex = DUPLEX_FULL;\n\t\tswitch (speed) {\n\t\t\tcase BNX2_LINK_STATUS_10HALF:\n\t\t\t\tbp->duplex = DUPLEX_HALF;\n\t\t\t\tfallthrough;\n\t\t\tcase BNX2_LINK_STATUS_10FULL:\n\t\t\t\tbp->line_speed = SPEED_10;\n\t\t\t\tbreak;\n\t\t\tcase BNX2_LINK_STATUS_100HALF:\n\t\t\t\tbp->duplex = DUPLEX_HALF;\n\t\t\t\tfallthrough;\n\t\t\tcase BNX2_LINK_STATUS_100BASE_T4:\n\t\t\tcase BNX2_LINK_STATUS_100FULL:\n\t\t\t\tbp->line_speed = SPEED_100;\n\t\t\t\tbreak;\n\t\t\tcase BNX2_LINK_STATUS_1000HALF:\n\t\t\t\tbp->duplex = DUPLEX_HALF;\n\t\t\t\tfallthrough;\n\t\t\tcase BNX2_LINK_STATUS_1000FULL:\n\t\t\t\tbp->line_speed = SPEED_1000;\n\t\t\t\tbreak;\n\t\t\tcase BNX2_LINK_STATUS_2500HALF:\n\t\t\t\tbp->duplex = DUPLEX_HALF;\n\t\t\t\tfallthrough;\n\t\t\tcase BNX2_LINK_STATUS_2500FULL:\n\t\t\t\tbp->line_speed = SPEED_2500;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbp->line_speed = 0;\n\t\t\t\tbreak;\n\t\t}\n\n\t\tbp->flow_ctrl = 0;\n\t\tif ((bp->autoneg & (AUTONEG_SPEED | AUTONEG_FLOW_CTRL)) !=\n\t\t    (AUTONEG_SPEED | AUTONEG_FLOW_CTRL)) {\n\t\t\tif (bp->duplex == DUPLEX_FULL)\n\t\t\t\tbp->flow_ctrl = bp->req_flow_ctrl;\n\t\t} else {\n\t\t\tif (msg & BNX2_LINK_STATUS_TX_FC_ENABLED)\n\t\t\t\tbp->flow_ctrl |= FLOW_CTRL_TX;\n\t\t\tif (msg & BNX2_LINK_STATUS_RX_FC_ENABLED)\n\t\t\t\tbp->flow_ctrl |= FLOW_CTRL_RX;\n\t\t}\n\n\t\told_port = bp->phy_port;\n\t\tif (msg & BNX2_LINK_STATUS_SERDES_LINK)\n\t\t\tbp->phy_port = PORT_FIBRE;\n\t\telse\n\t\t\tbp->phy_port = PORT_TP;\n\n\t\tif (old_port != bp->phy_port)\n\t\t\tbnx2_set_default_link(bp);\n\n\t}\n\tif (bp->link_up != link_up)\n\t\tbnx2_report_link(bp);\n\n\tbnx2_set_mac_link(bp);\n}\n\nstatic int\nbnx2_set_remote_link(struct bnx2 *bp)\n{\n\tu32 evt_code;\n\n\tevt_code = bnx2_shmem_rd(bp, BNX2_FW_EVT_CODE_MB);\n\tswitch (evt_code) {\n\t\tcase BNX2_FW_EVT_CODE_LINK_EVENT:\n\t\t\tbnx2_remote_phy_event(bp);\n\t\t\tbreak;\n\t\tcase BNX2_FW_EVT_CODE_SW_TIMER_EXPIRATION_EVENT:\n\t\tdefault:\n\t\t\tbnx2_send_heart_beat(bp);\n\t\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int\nbnx2_setup_copper_phy(struct bnx2 *bp)\n__releases(&bp->phy_lock)\n__acquires(&bp->phy_lock)\n{\n\tu32 bmcr, adv_reg, new_adv = 0;\n\tu32 new_bmcr;\n\n\tbnx2_read_phy(bp, bp->mii_bmcr, &bmcr);\n\n\tbnx2_read_phy(bp, bp->mii_adv, &adv_reg);\n\tadv_reg &= (PHY_ALL_10_100_SPEED | ADVERTISE_PAUSE_CAP |\n\t\t    ADVERTISE_PAUSE_ASYM);\n\n\tnew_adv = ADVERTISE_CSMA | ethtool_adv_to_mii_adv_t(bp->advertising);\n\n\tif (bp->autoneg & AUTONEG_SPEED) {\n\t\tu32 adv1000_reg;\n\t\tu32 new_adv1000 = 0;\n\n\t\tnew_adv |= bnx2_phy_get_pause_adv(bp);\n\n\t\tbnx2_read_phy(bp, MII_CTRL1000, &adv1000_reg);\n\t\tadv1000_reg &= PHY_ALL_1000_SPEED;\n\n\t\tnew_adv1000 |= ethtool_adv_to_mii_ctrl1000_t(bp->advertising);\n\t\tif ((adv1000_reg != new_adv1000) ||\n\t\t\t(adv_reg != new_adv) ||\n\t\t\t((bmcr & BMCR_ANENABLE) == 0)) {\n\n\t\t\tbnx2_write_phy(bp, bp->mii_adv, new_adv);\n\t\t\tbnx2_write_phy(bp, MII_CTRL1000, new_adv1000);\n\t\t\tbnx2_write_phy(bp, bp->mii_bmcr, BMCR_ANRESTART |\n\t\t\t\tBMCR_ANENABLE);\n\t\t}\n\t\telse if (bp->link_up) {\n\t\t\t \n\t\t\t \n\n\t\t\tbnx2_resolve_flow_ctrl(bp);\n\t\t\tbnx2_set_mac_link(bp);\n\t\t}\n\t\treturn 0;\n\t}\n\n\t \n\tif (adv_reg != new_adv)\n\t\tbnx2_write_phy(bp, bp->mii_adv, new_adv);\n\n\tnew_bmcr = 0;\n\tif (bp->req_line_speed == SPEED_100) {\n\t\tnew_bmcr |= BMCR_SPEED100;\n\t}\n\tif (bp->req_duplex == DUPLEX_FULL) {\n\t\tnew_bmcr |= BMCR_FULLDPLX;\n\t}\n\tif (new_bmcr != bmcr) {\n\t\tu32 bmsr;\n\n\t\tbnx2_read_phy(bp, bp->mii_bmsr, &bmsr);\n\t\tbnx2_read_phy(bp, bp->mii_bmsr, &bmsr);\n\n\t\tif (bmsr & BMSR_LSTATUS) {\n\t\t\t \n\t\t\tbnx2_write_phy(bp, bp->mii_bmcr, BMCR_LOOPBACK);\n\t\t\tspin_unlock_bh(&bp->phy_lock);\n\t\t\tmsleep(50);\n\t\t\tspin_lock_bh(&bp->phy_lock);\n\n\t\t\tbnx2_read_phy(bp, bp->mii_bmsr, &bmsr);\n\t\t\tbnx2_read_phy(bp, bp->mii_bmsr, &bmsr);\n\t\t}\n\n\t\tbnx2_write_phy(bp, bp->mii_bmcr, new_bmcr);\n\n\t\t \n\t\tif (bmsr & BMSR_LSTATUS) {\n\t\t\tbp->line_speed = bp->req_line_speed;\n\t\t\tbp->duplex = bp->req_duplex;\n\t\t\tbnx2_resolve_flow_ctrl(bp);\n\t\t\tbnx2_set_mac_link(bp);\n\t\t}\n\t} else {\n\t\tbnx2_resolve_flow_ctrl(bp);\n\t\tbnx2_set_mac_link(bp);\n\t}\n\treturn 0;\n}\n\nstatic int\nbnx2_setup_phy(struct bnx2 *bp, u8 port)\n__releases(&bp->phy_lock)\n__acquires(&bp->phy_lock)\n{\n\tif (bp->loopback == MAC_LOOPBACK)\n\t\treturn 0;\n\n\tif (bp->phy_flags & BNX2_PHY_FLAG_SERDES) {\n\t\treturn bnx2_setup_serdes_phy(bp, port);\n\t}\n\telse {\n\t\treturn bnx2_setup_copper_phy(bp);\n\t}\n}\n\nstatic int\nbnx2_init_5709s_phy(struct bnx2 *bp, int reset_phy)\n{\n\tu32 val;\n\n\tbp->mii_bmcr = MII_BMCR + 0x10;\n\tbp->mii_bmsr = MII_BMSR + 0x10;\n\tbp->mii_bmsr1 = MII_BNX2_GP_TOP_AN_STATUS1;\n\tbp->mii_adv = MII_ADVERTISE + 0x10;\n\tbp->mii_lpa = MII_LPA + 0x10;\n\tbp->mii_up1 = MII_BNX2_OVER1G_UP1;\n\n\tbnx2_write_phy(bp, MII_BNX2_BLK_ADDR, MII_BNX2_BLK_ADDR_AER);\n\tbnx2_write_phy(bp, MII_BNX2_AER_AER, MII_BNX2_AER_AER_AN_MMD);\n\n\tbnx2_write_phy(bp, MII_BNX2_BLK_ADDR, MII_BNX2_BLK_ADDR_COMBO_IEEEB0);\n\tif (reset_phy)\n\t\tbnx2_reset_phy(bp);\n\n\tbnx2_write_phy(bp, MII_BNX2_BLK_ADDR, MII_BNX2_BLK_ADDR_SERDES_DIG);\n\n\tbnx2_read_phy(bp, MII_BNX2_SERDES_DIG_1000XCTL1, &val);\n\tval &= ~MII_BNX2_SD_1000XCTL1_AUTODET;\n\tval |= MII_BNX2_SD_1000XCTL1_FIBER;\n\tbnx2_write_phy(bp, MII_BNX2_SERDES_DIG_1000XCTL1, val);\n\n\tbnx2_write_phy(bp, MII_BNX2_BLK_ADDR, MII_BNX2_BLK_ADDR_OVER1G);\n\tbnx2_read_phy(bp, MII_BNX2_OVER1G_UP1, &val);\n\tif (bp->phy_flags & BNX2_PHY_FLAG_2_5G_CAPABLE)\n\t\tval |= BCM5708S_UP1_2G5;\n\telse\n\t\tval &= ~BCM5708S_UP1_2G5;\n\tbnx2_write_phy(bp, MII_BNX2_OVER1G_UP1, val);\n\n\tbnx2_write_phy(bp, MII_BNX2_BLK_ADDR, MII_BNX2_BLK_ADDR_BAM_NXTPG);\n\tbnx2_read_phy(bp, MII_BNX2_BAM_NXTPG_CTL, &val);\n\tval |= MII_BNX2_NXTPG_CTL_T2 | MII_BNX2_NXTPG_CTL_BAM;\n\tbnx2_write_phy(bp, MII_BNX2_BAM_NXTPG_CTL, val);\n\n\tbnx2_write_phy(bp, MII_BNX2_BLK_ADDR, MII_BNX2_BLK_ADDR_CL73_USERB0);\n\n\tval = MII_BNX2_CL73_BAM_EN | MII_BNX2_CL73_BAM_STA_MGR_EN |\n\t      MII_BNX2_CL73_BAM_NP_AFT_BP_EN;\n\tbnx2_write_phy(bp, MII_BNX2_CL73_BAM_CTL1, val);\n\n\tbnx2_write_phy(bp, MII_BNX2_BLK_ADDR, MII_BNX2_BLK_ADDR_COMBO_IEEEB0);\n\n\treturn 0;\n}\n\nstatic int\nbnx2_init_5708s_phy(struct bnx2 *bp, int reset_phy)\n{\n\tu32 val;\n\n\tif (reset_phy)\n\t\tbnx2_reset_phy(bp);\n\n\tbp->mii_up1 = BCM5708S_UP1;\n\n\tbnx2_write_phy(bp, BCM5708S_BLK_ADDR, BCM5708S_BLK_ADDR_DIG3);\n\tbnx2_write_phy(bp, BCM5708S_DIG_3_0, BCM5708S_DIG_3_0_USE_IEEE);\n\tbnx2_write_phy(bp, BCM5708S_BLK_ADDR, BCM5708S_BLK_ADDR_DIG);\n\n\tbnx2_read_phy(bp, BCM5708S_1000X_CTL1, &val);\n\tval |= BCM5708S_1000X_CTL1_FIBER_MODE | BCM5708S_1000X_CTL1_AUTODET_EN;\n\tbnx2_write_phy(bp, BCM5708S_1000X_CTL1, val);\n\n\tbnx2_read_phy(bp, BCM5708S_1000X_CTL2, &val);\n\tval |= BCM5708S_1000X_CTL2_PLLEL_DET_EN;\n\tbnx2_write_phy(bp, BCM5708S_1000X_CTL2, val);\n\n\tif (bp->phy_flags & BNX2_PHY_FLAG_2_5G_CAPABLE) {\n\t\tbnx2_read_phy(bp, BCM5708S_UP1, &val);\n\t\tval |= BCM5708S_UP1_2G5;\n\t\tbnx2_write_phy(bp, BCM5708S_UP1, val);\n\t}\n\n\tif ((BNX2_CHIP_ID(bp) == BNX2_CHIP_ID_5708_A0) ||\n\t    (BNX2_CHIP_ID(bp) == BNX2_CHIP_ID_5708_B0) ||\n\t    (BNX2_CHIP_ID(bp) == BNX2_CHIP_ID_5708_B1)) {\n\t\t \n\t\tbnx2_write_phy(bp, BCM5708S_BLK_ADDR,\n\t\t\t       BCM5708S_BLK_ADDR_TX_MISC);\n\t\tbnx2_read_phy(bp, BCM5708S_TX_ACTL1, &val);\n\t\tval &= ~BCM5708S_TX_ACTL1_DRIVER_VCM;\n\t\tbnx2_write_phy(bp, BCM5708S_TX_ACTL1, val);\n\t\tbnx2_write_phy(bp, BCM5708S_BLK_ADDR, BCM5708S_BLK_ADDR_DIG);\n\t}\n\n\tval = bnx2_shmem_rd(bp, BNX2_PORT_HW_CFG_CONFIG) &\n\t      BNX2_PORT_HW_CFG_CFG_TXCTL3_MASK;\n\n\tif (val) {\n\t\tu32 is_backplane;\n\n\t\tis_backplane = bnx2_shmem_rd(bp, BNX2_SHARED_HW_CFG_CONFIG);\n\t\tif (is_backplane & BNX2_SHARED_HW_CFG_PHY_BACKPLANE) {\n\t\t\tbnx2_write_phy(bp, BCM5708S_BLK_ADDR,\n\t\t\t\t       BCM5708S_BLK_ADDR_TX_MISC);\n\t\t\tbnx2_write_phy(bp, BCM5708S_TX_ACTL3, val);\n\t\t\tbnx2_write_phy(bp, BCM5708S_BLK_ADDR,\n\t\t\t\t       BCM5708S_BLK_ADDR_DIG);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int\nbnx2_init_5706s_phy(struct bnx2 *bp, int reset_phy)\n{\n\tif (reset_phy)\n\t\tbnx2_reset_phy(bp);\n\n\tbp->phy_flags &= ~BNX2_PHY_FLAG_PARALLEL_DETECT;\n\n\tif (BNX2_CHIP(bp) == BNX2_CHIP_5706)\n\t\tBNX2_WR(bp, BNX2_MISC_GP_HW_CTL0, 0x300);\n\n\tif (bp->dev->mtu > ETH_DATA_LEN) {\n\t\tu32 val;\n\n\t\t \n\t\tbnx2_write_phy(bp, 0x18, 0x7);\n\t\tbnx2_read_phy(bp, 0x18, &val);\n\t\tbnx2_write_phy(bp, 0x18, (val & 0xfff8) | 0x4000);\n\n\t\tbnx2_write_phy(bp, 0x1c, 0x6c00);\n\t\tbnx2_read_phy(bp, 0x1c, &val);\n\t\tbnx2_write_phy(bp, 0x1c, (val & 0x3ff) | 0xec02);\n\t}\n\telse {\n\t\tu32 val;\n\n\t\tbnx2_write_phy(bp, 0x18, 0x7);\n\t\tbnx2_read_phy(bp, 0x18, &val);\n\t\tbnx2_write_phy(bp, 0x18, val & ~0x4007);\n\n\t\tbnx2_write_phy(bp, 0x1c, 0x6c00);\n\t\tbnx2_read_phy(bp, 0x1c, &val);\n\t\tbnx2_write_phy(bp, 0x1c, (val & 0x3fd) | 0xec00);\n\t}\n\n\treturn 0;\n}\n\nstatic int\nbnx2_init_copper_phy(struct bnx2 *bp, int reset_phy)\n{\n\tu32 val;\n\n\tif (reset_phy)\n\t\tbnx2_reset_phy(bp);\n\n\tif (bp->phy_flags & BNX2_PHY_FLAG_CRC_FIX) {\n\t\tbnx2_write_phy(bp, 0x18, 0x0c00);\n\t\tbnx2_write_phy(bp, 0x17, 0x000a);\n\t\tbnx2_write_phy(bp, 0x15, 0x310b);\n\t\tbnx2_write_phy(bp, 0x17, 0x201f);\n\t\tbnx2_write_phy(bp, 0x15, 0x9506);\n\t\tbnx2_write_phy(bp, 0x17, 0x401f);\n\t\tbnx2_write_phy(bp, 0x15, 0x14e2);\n\t\tbnx2_write_phy(bp, 0x18, 0x0400);\n\t}\n\n\tif (bp->phy_flags & BNX2_PHY_FLAG_DIS_EARLY_DAC) {\n\t\tbnx2_write_phy(bp, MII_BNX2_DSP_ADDRESS,\n\t\t\t       MII_BNX2_DSP_EXPAND_REG | 0x8);\n\t\tbnx2_read_phy(bp, MII_BNX2_DSP_RW_PORT, &val);\n\t\tval &= ~(1 << 8);\n\t\tbnx2_write_phy(bp, MII_BNX2_DSP_RW_PORT, val);\n\t}\n\n\tif (bp->dev->mtu > ETH_DATA_LEN) {\n\t\t \n\t\tbnx2_write_phy(bp, 0x18, 0x7);\n\t\tbnx2_read_phy(bp, 0x18, &val);\n\t\tbnx2_write_phy(bp, 0x18, val | 0x4000);\n\n\t\tbnx2_read_phy(bp, 0x10, &val);\n\t\tbnx2_write_phy(bp, 0x10, val | 0x1);\n\t}\n\telse {\n\t\tbnx2_write_phy(bp, 0x18, 0x7);\n\t\tbnx2_read_phy(bp, 0x18, &val);\n\t\tbnx2_write_phy(bp, 0x18, val & ~0x4007);\n\n\t\tbnx2_read_phy(bp, 0x10, &val);\n\t\tbnx2_write_phy(bp, 0x10, val & ~0x1);\n\t}\n\n\t \n\tbnx2_write_phy(bp, MII_BNX2_AUX_CTL, AUX_CTL_MISC_CTL);\n\tbnx2_read_phy(bp, MII_BNX2_AUX_CTL, &val);\n\tval |=  AUX_CTL_MISC_CTL_WR | AUX_CTL_MISC_CTL_WIRESPEED;\n\n\t \n\tif (BNX2_CHIP(bp) == BNX2_CHIP_5709)\n\t\tval |=  AUX_CTL_MISC_CTL_AUTOMDIX;\n\n\tbnx2_write_phy(bp, MII_BNX2_AUX_CTL, val);\n\treturn 0;\n}\n\n\nstatic int\nbnx2_init_phy(struct bnx2 *bp, int reset_phy)\n__releases(&bp->phy_lock)\n__acquires(&bp->phy_lock)\n{\n\tu32 val;\n\tint rc = 0;\n\n\tbp->phy_flags &= ~BNX2_PHY_FLAG_INT_MODE_MASK;\n\tbp->phy_flags |= BNX2_PHY_FLAG_INT_MODE_LINK_READY;\n\n\tbp->mii_bmcr = MII_BMCR;\n\tbp->mii_bmsr = MII_BMSR;\n\tbp->mii_bmsr1 = MII_BMSR;\n\tbp->mii_adv = MII_ADVERTISE;\n\tbp->mii_lpa = MII_LPA;\n\n\tBNX2_WR(bp, BNX2_EMAC_ATTENTION_ENA, BNX2_EMAC_ATTENTION_ENA_LINK);\n\n\tif (bp->phy_flags & BNX2_PHY_FLAG_REMOTE_PHY_CAP)\n\t\tgoto setup_phy;\n\n\tbnx2_read_phy(bp, MII_PHYSID1, &val);\n\tbp->phy_id = val << 16;\n\tbnx2_read_phy(bp, MII_PHYSID2, &val);\n\tbp->phy_id |= val & 0xffff;\n\n\tif (bp->phy_flags & BNX2_PHY_FLAG_SERDES) {\n\t\tif (BNX2_CHIP(bp) == BNX2_CHIP_5706)\n\t\t\trc = bnx2_init_5706s_phy(bp, reset_phy);\n\t\telse if (BNX2_CHIP(bp) == BNX2_CHIP_5708)\n\t\t\trc = bnx2_init_5708s_phy(bp, reset_phy);\n\t\telse if (BNX2_CHIP(bp) == BNX2_CHIP_5709)\n\t\t\trc = bnx2_init_5709s_phy(bp, reset_phy);\n\t}\n\telse {\n\t\trc = bnx2_init_copper_phy(bp, reset_phy);\n\t}\n\nsetup_phy:\n\tif (!rc)\n\t\trc = bnx2_setup_phy(bp, bp->phy_port);\n\n\treturn rc;\n}\n\nstatic int\nbnx2_set_mac_loopback(struct bnx2 *bp)\n{\n\tu32 mac_mode;\n\n\tmac_mode = BNX2_RD(bp, BNX2_EMAC_MODE);\n\tmac_mode &= ~BNX2_EMAC_MODE_PORT;\n\tmac_mode |= BNX2_EMAC_MODE_MAC_LOOP | BNX2_EMAC_MODE_FORCE_LINK;\n\tBNX2_WR(bp, BNX2_EMAC_MODE, mac_mode);\n\tbp->link_up = 1;\n\treturn 0;\n}\n\nstatic int bnx2_test_link(struct bnx2 *);\n\nstatic int\nbnx2_set_phy_loopback(struct bnx2 *bp)\n{\n\tu32 mac_mode;\n\tint rc, i;\n\n\tspin_lock_bh(&bp->phy_lock);\n\trc = bnx2_write_phy(bp, bp->mii_bmcr, BMCR_LOOPBACK | BMCR_FULLDPLX |\n\t\t\t    BMCR_SPEED1000);\n\tspin_unlock_bh(&bp->phy_lock);\n\tif (rc)\n\t\treturn rc;\n\n\tfor (i = 0; i < 10; i++) {\n\t\tif (bnx2_test_link(bp) == 0)\n\t\t\tbreak;\n\t\tmsleep(100);\n\t}\n\n\tmac_mode = BNX2_RD(bp, BNX2_EMAC_MODE);\n\tmac_mode &= ~(BNX2_EMAC_MODE_PORT | BNX2_EMAC_MODE_HALF_DUPLEX |\n\t\t      BNX2_EMAC_MODE_MAC_LOOP | BNX2_EMAC_MODE_FORCE_LINK |\n\t\t      BNX2_EMAC_MODE_25G_MODE);\n\n\tmac_mode |= BNX2_EMAC_MODE_PORT_GMII;\n\tBNX2_WR(bp, BNX2_EMAC_MODE, mac_mode);\n\tbp->link_up = 1;\n\treturn 0;\n}\n\nstatic void\nbnx2_dump_mcp_state(struct bnx2 *bp)\n{\n\tstruct net_device *dev = bp->dev;\n\tu32 mcp_p0, mcp_p1;\n\n\tnetdev_err(dev, \"<--- start MCP states dump --->\\n\");\n\tif (BNX2_CHIP(bp) == BNX2_CHIP_5709) {\n\t\tmcp_p0 = BNX2_MCP_STATE_P0;\n\t\tmcp_p1 = BNX2_MCP_STATE_P1;\n\t} else {\n\t\tmcp_p0 = BNX2_MCP_STATE_P0_5708;\n\t\tmcp_p1 = BNX2_MCP_STATE_P1_5708;\n\t}\n\tnetdev_err(dev, \"DEBUG: MCP_STATE_P0[%08x] MCP_STATE_P1[%08x]\\n\",\n\t\t   bnx2_reg_rd_ind(bp, mcp_p0), bnx2_reg_rd_ind(bp, mcp_p1));\n\tnetdev_err(dev, \"DEBUG: MCP mode[%08x] state[%08x] evt_mask[%08x]\\n\",\n\t\t   bnx2_reg_rd_ind(bp, BNX2_MCP_CPU_MODE),\n\t\t   bnx2_reg_rd_ind(bp, BNX2_MCP_CPU_STATE),\n\t\t   bnx2_reg_rd_ind(bp, BNX2_MCP_CPU_EVENT_MASK));\n\tnetdev_err(dev, \"DEBUG: pc[%08x] pc[%08x] instr[%08x]\\n\",\n\t\t   bnx2_reg_rd_ind(bp, BNX2_MCP_CPU_PROGRAM_COUNTER),\n\t\t   bnx2_reg_rd_ind(bp, BNX2_MCP_CPU_PROGRAM_COUNTER),\n\t\t   bnx2_reg_rd_ind(bp, BNX2_MCP_CPU_INSTRUCTION));\n\tnetdev_err(dev, \"DEBUG: shmem states:\\n\");\n\tnetdev_err(dev, \"DEBUG: drv_mb[%08x] fw_mb[%08x] link_status[%08x]\",\n\t\t   bnx2_shmem_rd(bp, BNX2_DRV_MB),\n\t\t   bnx2_shmem_rd(bp, BNX2_FW_MB),\n\t\t   bnx2_shmem_rd(bp, BNX2_LINK_STATUS));\n\tpr_cont(\" drv_pulse_mb[%08x]\\n\", bnx2_shmem_rd(bp, BNX2_DRV_PULSE_MB));\n\tnetdev_err(dev, \"DEBUG: dev_info_signature[%08x] reset_type[%08x]\",\n\t\t   bnx2_shmem_rd(bp, BNX2_DEV_INFO_SIGNATURE),\n\t\t   bnx2_shmem_rd(bp, BNX2_BC_STATE_RESET_TYPE));\n\tpr_cont(\" condition[%08x]\\n\",\n\t\tbnx2_shmem_rd(bp, BNX2_BC_STATE_CONDITION));\n\tDP_SHMEM_LINE(bp, BNX2_BC_RESET_TYPE);\n\tDP_SHMEM_LINE(bp, 0x3cc);\n\tDP_SHMEM_LINE(bp, 0x3dc);\n\tDP_SHMEM_LINE(bp, 0x3ec);\n\tnetdev_err(dev, \"DEBUG: 0x3fc[%08x]\\n\", bnx2_shmem_rd(bp, 0x3fc));\n\tnetdev_err(dev, \"<--- end MCP states dump --->\\n\");\n}\n\nstatic int\nbnx2_fw_sync(struct bnx2 *bp, u32 msg_data, int ack, int silent)\n{\n\tint i;\n\tu32 val;\n\n\tbp->fw_wr_seq++;\n\tmsg_data |= bp->fw_wr_seq;\n\tbp->fw_last_msg = msg_data;\n\n\tbnx2_shmem_wr(bp, BNX2_DRV_MB, msg_data);\n\n\tif (!ack)\n\t\treturn 0;\n\n\t \n\tfor (i = 0; i < (BNX2_FW_ACK_TIME_OUT_MS / 10); i++) {\n\t\tmsleep(10);\n\n\t\tval = bnx2_shmem_rd(bp, BNX2_FW_MB);\n\n\t\tif ((val & BNX2_FW_MSG_ACK) == (msg_data & BNX2_DRV_MSG_SEQ))\n\t\t\tbreak;\n\t}\n\tif ((msg_data & BNX2_DRV_MSG_DATA) == BNX2_DRV_MSG_DATA_WAIT0)\n\t\treturn 0;\n\n\t \n\tif ((val & BNX2_FW_MSG_ACK) != (msg_data & BNX2_DRV_MSG_SEQ)) {\n\t\tmsg_data &= ~BNX2_DRV_MSG_CODE;\n\t\tmsg_data |= BNX2_DRV_MSG_CODE_FW_TIMEOUT;\n\n\t\tbnx2_shmem_wr(bp, BNX2_DRV_MB, msg_data);\n\t\tif (!silent) {\n\t\t\tpr_err(\"fw sync timeout, reset code = %x\\n\", msg_data);\n\t\t\tbnx2_dump_mcp_state(bp);\n\t\t}\n\n\t\treturn -EBUSY;\n\t}\n\n\tif ((val & BNX2_FW_MSG_STATUS_MASK) != BNX2_FW_MSG_STATUS_OK)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic int\nbnx2_init_5709_context(struct bnx2 *bp)\n{\n\tint i, ret = 0;\n\tu32 val;\n\n\tval = BNX2_CTX_COMMAND_ENABLED | BNX2_CTX_COMMAND_MEM_INIT | (1 << 12);\n\tval |= (BNX2_PAGE_BITS - 8) << 16;\n\tBNX2_WR(bp, BNX2_CTX_COMMAND, val);\n\tfor (i = 0; i < 10; i++) {\n\t\tval = BNX2_RD(bp, BNX2_CTX_COMMAND);\n\t\tif (!(val & BNX2_CTX_COMMAND_MEM_INIT))\n\t\t\tbreak;\n\t\tudelay(2);\n\t}\n\tif (val & BNX2_CTX_COMMAND_MEM_INIT)\n\t\treturn -EBUSY;\n\n\tfor (i = 0; i < bp->ctx_pages; i++) {\n\t\tint j;\n\n\t\tif (bp->ctx_blk[i])\n\t\t\tmemset(bp->ctx_blk[i], 0, BNX2_PAGE_SIZE);\n\t\telse\n\t\t\treturn -ENOMEM;\n\n\t\tBNX2_WR(bp, BNX2_CTX_HOST_PAGE_TBL_DATA0,\n\t\t\t(bp->ctx_blk_mapping[i] & 0xffffffff) |\n\t\t\tBNX2_CTX_HOST_PAGE_TBL_DATA0_VALID);\n\t\tBNX2_WR(bp, BNX2_CTX_HOST_PAGE_TBL_DATA1,\n\t\t\t(u64) bp->ctx_blk_mapping[i] >> 32);\n\t\tBNX2_WR(bp, BNX2_CTX_HOST_PAGE_TBL_CTRL, i |\n\t\t\tBNX2_CTX_HOST_PAGE_TBL_CTRL_WRITE_REQ);\n\t\tfor (j = 0; j < 10; j++) {\n\n\t\t\tval = BNX2_RD(bp, BNX2_CTX_HOST_PAGE_TBL_CTRL);\n\t\t\tif (!(val & BNX2_CTX_HOST_PAGE_TBL_CTRL_WRITE_REQ))\n\t\t\t\tbreak;\n\t\t\tudelay(5);\n\t\t}\n\t\tif (val & BNX2_CTX_HOST_PAGE_TBL_CTRL_WRITE_REQ) {\n\t\t\tret = -EBUSY;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\nstatic void\nbnx2_init_context(struct bnx2 *bp)\n{\n\tu32 vcid;\n\n\tvcid = 96;\n\twhile (vcid) {\n\t\tu32 vcid_addr, pcid_addr, offset;\n\t\tint i;\n\n\t\tvcid--;\n\n\t\tif (BNX2_CHIP_ID(bp) == BNX2_CHIP_ID_5706_A0) {\n\t\t\tu32 new_vcid;\n\n\t\t\tvcid_addr = GET_PCID_ADDR(vcid);\n\t\t\tif (vcid & 0x8) {\n\t\t\t\tnew_vcid = 0x60 + (vcid & 0xf0) + (vcid & 0x7);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnew_vcid = vcid;\n\t\t\t}\n\t\t\tpcid_addr = GET_PCID_ADDR(new_vcid);\n\t\t}\n\t\telse {\n\t    \t\tvcid_addr = GET_CID_ADDR(vcid);\n\t\t\tpcid_addr = vcid_addr;\n\t\t}\n\n\t\tfor (i = 0; i < (CTX_SIZE / PHY_CTX_SIZE); i++) {\n\t\t\tvcid_addr += (i << PHY_CTX_SHIFT);\n\t\t\tpcid_addr += (i << PHY_CTX_SHIFT);\n\n\t\t\tBNX2_WR(bp, BNX2_CTX_VIRT_ADDR, vcid_addr);\n\t\t\tBNX2_WR(bp, BNX2_CTX_PAGE_TBL, pcid_addr);\n\n\t\t\t \n\t\t\tfor (offset = 0; offset < PHY_CTX_SIZE; offset += 4)\n\t\t\t\tbnx2_ctx_wr(bp, vcid_addr, offset, 0);\n\t\t}\n\t}\n}\n\nstatic int\nbnx2_alloc_bad_rbuf(struct bnx2 *bp)\n{\n\tu16 *good_mbuf;\n\tu32 good_mbuf_cnt;\n\tu32 val;\n\n\tgood_mbuf = kmalloc_array(512, sizeof(u16), GFP_KERNEL);\n\tif (!good_mbuf)\n\t\treturn -ENOMEM;\n\n\tBNX2_WR(bp, BNX2_MISC_ENABLE_SET_BITS,\n\t\tBNX2_MISC_ENABLE_SET_BITS_RX_MBUF_ENABLE);\n\n\tgood_mbuf_cnt = 0;\n\n\t \n\tval = bnx2_reg_rd_ind(bp, BNX2_RBUF_STATUS1);\n\twhile (val & BNX2_RBUF_STATUS1_FREE_COUNT) {\n\t\tbnx2_reg_wr_ind(bp, BNX2_RBUF_COMMAND,\n\t\t\t\tBNX2_RBUF_COMMAND_ALLOC_REQ);\n\n\t\tval = bnx2_reg_rd_ind(bp, BNX2_RBUF_FW_BUF_ALLOC);\n\n\t\tval &= BNX2_RBUF_FW_BUF_ALLOC_VALUE;\n\n\t\t \n\t\tif (!(val & (1 << 9))) {\n\t\t\tgood_mbuf[good_mbuf_cnt] = (u16) val;\n\t\t\tgood_mbuf_cnt++;\n\t\t}\n\n\t\tval = bnx2_reg_rd_ind(bp, BNX2_RBUF_STATUS1);\n\t}\n\n\t \n\twhile (good_mbuf_cnt) {\n\t\tgood_mbuf_cnt--;\n\n\t\tval = good_mbuf[good_mbuf_cnt];\n\t\tval = (val << 9) | val | 1;\n\n\t\tbnx2_reg_wr_ind(bp, BNX2_RBUF_FW_BUF_FREE, val);\n\t}\n\tkfree(good_mbuf);\n\treturn 0;\n}\n\nstatic void\nbnx2_set_mac_addr(struct bnx2 *bp, const u8 *mac_addr, u32 pos)\n{\n\tu32 val;\n\n\tval = (mac_addr[0] << 8) | mac_addr[1];\n\n\tBNX2_WR(bp, BNX2_EMAC_MAC_MATCH0 + (pos * 8), val);\n\n\tval = (mac_addr[2] << 24) | (mac_addr[3] << 16) |\n\t\t(mac_addr[4] << 8) | mac_addr[5];\n\n\tBNX2_WR(bp, BNX2_EMAC_MAC_MATCH1 + (pos * 8), val);\n}\n\nstatic inline int\nbnx2_alloc_rx_page(struct bnx2 *bp, struct bnx2_rx_ring_info *rxr, u16 index, gfp_t gfp)\n{\n\tdma_addr_t mapping;\n\tstruct bnx2_sw_pg *rx_pg = &rxr->rx_pg_ring[index];\n\tstruct bnx2_rx_bd *rxbd =\n\t\t&rxr->rx_pg_desc_ring[BNX2_RX_RING(index)][BNX2_RX_IDX(index)];\n\tstruct page *page = alloc_page(gfp);\n\n\tif (!page)\n\t\treturn -ENOMEM;\n\tmapping = dma_map_page(&bp->pdev->dev, page, 0, PAGE_SIZE,\n\t\t\t       DMA_FROM_DEVICE);\n\tif (dma_mapping_error(&bp->pdev->dev, mapping)) {\n\t\t__free_page(page);\n\t\treturn -EIO;\n\t}\n\n\trx_pg->page = page;\n\tdma_unmap_addr_set(rx_pg, mapping, mapping);\n\trxbd->rx_bd_haddr_hi = (u64) mapping >> 32;\n\trxbd->rx_bd_haddr_lo = (u64) mapping & 0xffffffff;\n\treturn 0;\n}\n\nstatic void\nbnx2_free_rx_page(struct bnx2 *bp, struct bnx2_rx_ring_info *rxr, u16 index)\n{\n\tstruct bnx2_sw_pg *rx_pg = &rxr->rx_pg_ring[index];\n\tstruct page *page = rx_pg->page;\n\n\tif (!page)\n\t\treturn;\n\n\tdma_unmap_page(&bp->pdev->dev, dma_unmap_addr(rx_pg, mapping),\n\t\t       PAGE_SIZE, DMA_FROM_DEVICE);\n\n\t__free_page(page);\n\trx_pg->page = NULL;\n}\n\nstatic inline int\nbnx2_alloc_rx_data(struct bnx2 *bp, struct bnx2_rx_ring_info *rxr, u16 index, gfp_t gfp)\n{\n\tu8 *data;\n\tstruct bnx2_sw_bd *rx_buf = &rxr->rx_buf_ring[index];\n\tdma_addr_t mapping;\n\tstruct bnx2_rx_bd *rxbd =\n\t\t&rxr->rx_desc_ring[BNX2_RX_RING(index)][BNX2_RX_IDX(index)];\n\n\tdata = kmalloc(bp->rx_buf_size, gfp);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tmapping = dma_map_single(&bp->pdev->dev,\n\t\t\t\t get_l2_fhdr(data),\n\t\t\t\t bp->rx_buf_use_size,\n\t\t\t\t DMA_FROM_DEVICE);\n\tif (dma_mapping_error(&bp->pdev->dev, mapping)) {\n\t\tkfree(data);\n\t\treturn -EIO;\n\t}\n\n\trx_buf->data = data;\n\tdma_unmap_addr_set(rx_buf, mapping, mapping);\n\n\trxbd->rx_bd_haddr_hi = (u64) mapping >> 32;\n\trxbd->rx_bd_haddr_lo = (u64) mapping & 0xffffffff;\n\n\trxr->rx_prod_bseq += bp->rx_buf_use_size;\n\n\treturn 0;\n}\n\nstatic int\nbnx2_phy_event_is_set(struct bnx2 *bp, struct bnx2_napi *bnapi, u32 event)\n{\n\tstruct status_block *sblk = bnapi->status_blk.msi;\n\tu32 new_link_state, old_link_state;\n\tint is_set = 1;\n\n\tnew_link_state = sblk->status_attn_bits & event;\n\told_link_state = sblk->status_attn_bits_ack & event;\n\tif (new_link_state != old_link_state) {\n\t\tif (new_link_state)\n\t\t\tBNX2_WR(bp, BNX2_PCICFG_STATUS_BIT_SET_CMD, event);\n\t\telse\n\t\t\tBNX2_WR(bp, BNX2_PCICFG_STATUS_BIT_CLEAR_CMD, event);\n\t} else\n\t\tis_set = 0;\n\n\treturn is_set;\n}\n\nstatic void\nbnx2_phy_int(struct bnx2 *bp, struct bnx2_napi *bnapi)\n{\n\tspin_lock(&bp->phy_lock);\n\n\tif (bnx2_phy_event_is_set(bp, bnapi, STATUS_ATTN_BITS_LINK_STATE))\n\t\tbnx2_set_link(bp);\n\tif (bnx2_phy_event_is_set(bp, bnapi, STATUS_ATTN_BITS_TIMER_ABORT))\n\t\tbnx2_set_remote_link(bp);\n\n\tspin_unlock(&bp->phy_lock);\n\n}\n\nstatic inline u16\nbnx2_get_hw_tx_cons(struct bnx2_napi *bnapi)\n{\n\tu16 cons;\n\n\tcons = READ_ONCE(*bnapi->hw_tx_cons_ptr);\n\n\tif (unlikely((cons & BNX2_MAX_TX_DESC_CNT) == BNX2_MAX_TX_DESC_CNT))\n\t\tcons++;\n\treturn cons;\n}\n\nstatic int\nbnx2_tx_int(struct bnx2 *bp, struct bnx2_napi *bnapi, int budget)\n{\n\tstruct bnx2_tx_ring_info *txr = &bnapi->tx_ring;\n\tu16 hw_cons, sw_cons, sw_ring_cons;\n\tint tx_pkt = 0, index;\n\tunsigned int tx_bytes = 0;\n\tstruct netdev_queue *txq;\n\n\tindex = (bnapi - bp->bnx2_napi);\n\ttxq = netdev_get_tx_queue(bp->dev, index);\n\n\thw_cons = bnx2_get_hw_tx_cons(bnapi);\n\tsw_cons = txr->tx_cons;\n\n\twhile (sw_cons != hw_cons) {\n\t\tstruct bnx2_sw_tx_bd *tx_buf;\n\t\tstruct sk_buff *skb;\n\t\tint i, last;\n\n\t\tsw_ring_cons = BNX2_TX_RING_IDX(sw_cons);\n\n\t\ttx_buf = &txr->tx_buf_ring[sw_ring_cons];\n\t\tskb = tx_buf->skb;\n\n\t\t \n\t\tprefetch(&skb->end);\n\n\t\t \n\t\tif (tx_buf->is_gso) {\n\t\t\tu16 last_idx, last_ring_idx;\n\n\t\t\tlast_idx = sw_cons + tx_buf->nr_frags + 1;\n\t\t\tlast_ring_idx = sw_ring_cons + tx_buf->nr_frags + 1;\n\t\t\tif (unlikely(last_ring_idx >= BNX2_MAX_TX_DESC_CNT)) {\n\t\t\t\tlast_idx++;\n\t\t\t}\n\t\t\tif (((s16) ((s16) last_idx - (s16) hw_cons)) > 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tdma_unmap_single(&bp->pdev->dev, dma_unmap_addr(tx_buf, mapping),\n\t\t\tskb_headlen(skb), DMA_TO_DEVICE);\n\n\t\ttx_buf->skb = NULL;\n\t\tlast = tx_buf->nr_frags;\n\n\t\tfor (i = 0; i < last; i++) {\n\t\t\tstruct bnx2_sw_tx_bd *tx_buf;\n\n\t\t\tsw_cons = BNX2_NEXT_TX_BD(sw_cons);\n\n\t\t\ttx_buf = &txr->tx_buf_ring[BNX2_TX_RING_IDX(sw_cons)];\n\t\t\tdma_unmap_page(&bp->pdev->dev,\n\t\t\t\tdma_unmap_addr(tx_buf, mapping),\n\t\t\t\tskb_frag_size(&skb_shinfo(skb)->frags[i]),\n\t\t\t\tDMA_TO_DEVICE);\n\t\t}\n\n\t\tsw_cons = BNX2_NEXT_TX_BD(sw_cons);\n\n\t\ttx_bytes += skb->len;\n\t\tdev_kfree_skb_any(skb);\n\t\ttx_pkt++;\n\t\tif (tx_pkt == budget)\n\t\t\tbreak;\n\n\t\tif (hw_cons == sw_cons)\n\t\t\thw_cons = bnx2_get_hw_tx_cons(bnapi);\n\t}\n\n\tnetdev_tx_completed_queue(txq, tx_pkt, tx_bytes);\n\ttxr->hw_tx_cons = hw_cons;\n\ttxr->tx_cons = sw_cons;\n\n\t \n\tsmp_mb();\n\n\tif (unlikely(netif_tx_queue_stopped(txq)) &&\n\t\t     (bnx2_tx_avail(bp, txr) > bp->tx_wake_thresh)) {\n\t\t__netif_tx_lock(txq, smp_processor_id());\n\t\tif ((netif_tx_queue_stopped(txq)) &&\n\t\t    (bnx2_tx_avail(bp, txr) > bp->tx_wake_thresh))\n\t\t\tnetif_tx_wake_queue(txq);\n\t\t__netif_tx_unlock(txq);\n\t}\n\n\treturn tx_pkt;\n}\n\nstatic void\nbnx2_reuse_rx_skb_pages(struct bnx2 *bp, struct bnx2_rx_ring_info *rxr,\n\t\t\tstruct sk_buff *skb, int count)\n{\n\tstruct bnx2_sw_pg *cons_rx_pg, *prod_rx_pg;\n\tstruct bnx2_rx_bd *cons_bd, *prod_bd;\n\tint i;\n\tu16 hw_prod, prod;\n\tu16 cons = rxr->rx_pg_cons;\n\n\tcons_rx_pg = &rxr->rx_pg_ring[cons];\n\n\t \n\tif (skb) {\n\t\tstruct page *page;\n\t\tstruct skb_shared_info *shinfo;\n\n\t\tshinfo = skb_shinfo(skb);\n\t\tshinfo->nr_frags--;\n\t\tpage = skb_frag_page(&shinfo->frags[shinfo->nr_frags]);\n\n\t\tcons_rx_pg->page = page;\n\t\tdev_kfree_skb(skb);\n\t}\n\n\thw_prod = rxr->rx_pg_prod;\n\n\tfor (i = 0; i < count; i++) {\n\t\tprod = BNX2_RX_PG_RING_IDX(hw_prod);\n\n\t\tprod_rx_pg = &rxr->rx_pg_ring[prod];\n\t\tcons_rx_pg = &rxr->rx_pg_ring[cons];\n\t\tcons_bd = &rxr->rx_pg_desc_ring[BNX2_RX_RING(cons)]\n\t\t\t\t\t\t[BNX2_RX_IDX(cons)];\n\t\tprod_bd = &rxr->rx_pg_desc_ring[BNX2_RX_RING(prod)]\n\t\t\t\t\t\t[BNX2_RX_IDX(prod)];\n\n\t\tif (prod != cons) {\n\t\t\tprod_rx_pg->page = cons_rx_pg->page;\n\t\t\tcons_rx_pg->page = NULL;\n\t\t\tdma_unmap_addr_set(prod_rx_pg, mapping,\n\t\t\t\tdma_unmap_addr(cons_rx_pg, mapping));\n\n\t\t\tprod_bd->rx_bd_haddr_hi = cons_bd->rx_bd_haddr_hi;\n\t\t\tprod_bd->rx_bd_haddr_lo = cons_bd->rx_bd_haddr_lo;\n\n\t\t}\n\t\tcons = BNX2_RX_PG_RING_IDX(BNX2_NEXT_RX_BD(cons));\n\t\thw_prod = BNX2_NEXT_RX_BD(hw_prod);\n\t}\n\trxr->rx_pg_prod = hw_prod;\n\trxr->rx_pg_cons = cons;\n}\n\nstatic inline void\nbnx2_reuse_rx_data(struct bnx2 *bp, struct bnx2_rx_ring_info *rxr,\n\t\t   u8 *data, u16 cons, u16 prod)\n{\n\tstruct bnx2_sw_bd *cons_rx_buf, *prod_rx_buf;\n\tstruct bnx2_rx_bd *cons_bd, *prod_bd;\n\n\tcons_rx_buf = &rxr->rx_buf_ring[cons];\n\tprod_rx_buf = &rxr->rx_buf_ring[prod];\n\n\tdma_sync_single_for_device(&bp->pdev->dev,\n\t\tdma_unmap_addr(cons_rx_buf, mapping),\n\t\tBNX2_RX_OFFSET + BNX2_RX_COPY_THRESH, DMA_FROM_DEVICE);\n\n\trxr->rx_prod_bseq += bp->rx_buf_use_size;\n\n\tprod_rx_buf->data = data;\n\n\tif (cons == prod)\n\t\treturn;\n\n\tdma_unmap_addr_set(prod_rx_buf, mapping,\n\t\t\tdma_unmap_addr(cons_rx_buf, mapping));\n\n\tcons_bd = &rxr->rx_desc_ring[BNX2_RX_RING(cons)][BNX2_RX_IDX(cons)];\n\tprod_bd = &rxr->rx_desc_ring[BNX2_RX_RING(prod)][BNX2_RX_IDX(prod)];\n\tprod_bd->rx_bd_haddr_hi = cons_bd->rx_bd_haddr_hi;\n\tprod_bd->rx_bd_haddr_lo = cons_bd->rx_bd_haddr_lo;\n}\n\nstatic struct sk_buff *\nbnx2_rx_skb(struct bnx2 *bp, struct bnx2_rx_ring_info *rxr, u8 *data,\n\t    unsigned int len, unsigned int hdr_len, dma_addr_t dma_addr,\n\t    u32 ring_idx)\n{\n\tint err;\n\tu16 prod = ring_idx & 0xffff;\n\tstruct sk_buff *skb;\n\n\terr = bnx2_alloc_rx_data(bp, rxr, prod, GFP_ATOMIC);\n\tif (unlikely(err)) {\n\t\tbnx2_reuse_rx_data(bp, rxr, data, (u16) (ring_idx >> 16), prod);\nerror:\n\t\tif (hdr_len) {\n\t\t\tunsigned int raw_len = len + 4;\n\t\t\tint pages = PAGE_ALIGN(raw_len - hdr_len) >> PAGE_SHIFT;\n\n\t\t\tbnx2_reuse_rx_skb_pages(bp, rxr, NULL, pages);\n\t\t}\n\t\treturn NULL;\n\t}\n\n\tdma_unmap_single(&bp->pdev->dev, dma_addr, bp->rx_buf_use_size,\n\t\t\t DMA_FROM_DEVICE);\n\tskb = slab_build_skb(data);\n\tif (!skb) {\n\t\tkfree(data);\n\t\tgoto error;\n\t}\n\tskb_reserve(skb, ((u8 *)get_l2_fhdr(data) - data) + BNX2_RX_OFFSET);\n\tif (hdr_len == 0) {\n\t\tskb_put(skb, len);\n\t\treturn skb;\n\t} else {\n\t\tunsigned int i, frag_len, frag_size, pages;\n\t\tstruct bnx2_sw_pg *rx_pg;\n\t\tu16 pg_cons = rxr->rx_pg_cons;\n\t\tu16 pg_prod = rxr->rx_pg_prod;\n\n\t\tfrag_size = len + 4 - hdr_len;\n\t\tpages = PAGE_ALIGN(frag_size) >> PAGE_SHIFT;\n\t\tskb_put(skb, hdr_len);\n\n\t\tfor (i = 0; i < pages; i++) {\n\t\t\tdma_addr_t mapping_old;\n\n\t\t\tfrag_len = min(frag_size, (unsigned int) PAGE_SIZE);\n\t\t\tif (unlikely(frag_len <= 4)) {\n\t\t\t\tunsigned int tail = 4 - frag_len;\n\n\t\t\t\trxr->rx_pg_cons = pg_cons;\n\t\t\t\trxr->rx_pg_prod = pg_prod;\n\t\t\t\tbnx2_reuse_rx_skb_pages(bp, rxr, NULL,\n\t\t\t\t\t\t\tpages - i);\n\t\t\t\tskb->len -= tail;\n\t\t\t\tif (i == 0) {\n\t\t\t\t\tskb->tail -= tail;\n\t\t\t\t} else {\n\t\t\t\t\tskb_frag_t *frag =\n\t\t\t\t\t\t&skb_shinfo(skb)->frags[i - 1];\n\t\t\t\t\tskb_frag_size_sub(frag, tail);\n\t\t\t\t\tskb->data_len -= tail;\n\t\t\t\t}\n\t\t\t\treturn skb;\n\t\t\t}\n\t\t\trx_pg = &rxr->rx_pg_ring[pg_cons];\n\n\t\t\t \n\t\t\tmapping_old = dma_unmap_addr(rx_pg, mapping);\n\t\t\tif (i == pages - 1)\n\t\t\t\tfrag_len -= 4;\n\n\t\t\tskb_fill_page_desc(skb, i, rx_pg->page, 0, frag_len);\n\t\t\trx_pg->page = NULL;\n\n\t\t\terr = bnx2_alloc_rx_page(bp, rxr,\n\t\t\t\t\t\t BNX2_RX_PG_RING_IDX(pg_prod),\n\t\t\t\t\t\t GFP_ATOMIC);\n\t\t\tif (unlikely(err)) {\n\t\t\t\trxr->rx_pg_cons = pg_cons;\n\t\t\t\trxr->rx_pg_prod = pg_prod;\n\t\t\t\tbnx2_reuse_rx_skb_pages(bp, rxr, skb,\n\t\t\t\t\t\t\tpages - i);\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\tdma_unmap_page(&bp->pdev->dev, mapping_old,\n\t\t\t\t       PAGE_SIZE, DMA_FROM_DEVICE);\n\n\t\t\tfrag_size -= frag_len;\n\t\t\tskb->data_len += frag_len;\n\t\t\tskb->truesize += PAGE_SIZE;\n\t\t\tskb->len += frag_len;\n\n\t\t\tpg_prod = BNX2_NEXT_RX_BD(pg_prod);\n\t\t\tpg_cons = BNX2_RX_PG_RING_IDX(BNX2_NEXT_RX_BD(pg_cons));\n\t\t}\n\t\trxr->rx_pg_prod = pg_prod;\n\t\trxr->rx_pg_cons = pg_cons;\n\t}\n\treturn skb;\n}\n\nstatic inline u16\nbnx2_get_hw_rx_cons(struct bnx2_napi *bnapi)\n{\n\tu16 cons;\n\n\tcons = READ_ONCE(*bnapi->hw_rx_cons_ptr);\n\n\tif (unlikely((cons & BNX2_MAX_RX_DESC_CNT) == BNX2_MAX_RX_DESC_CNT))\n\t\tcons++;\n\treturn cons;\n}\n\nstatic int\nbnx2_rx_int(struct bnx2 *bp, struct bnx2_napi *bnapi, int budget)\n{\n\tstruct bnx2_rx_ring_info *rxr = &bnapi->rx_ring;\n\tu16 hw_cons, sw_cons, sw_ring_cons, sw_prod, sw_ring_prod;\n\tstruct l2_fhdr *rx_hdr;\n\tint rx_pkt = 0, pg_ring_used = 0;\n\n\tif (budget <= 0)\n\t\treturn rx_pkt;\n\n\thw_cons = bnx2_get_hw_rx_cons(bnapi);\n\tsw_cons = rxr->rx_cons;\n\tsw_prod = rxr->rx_prod;\n\n\t \n\trmb();\n\twhile (sw_cons != hw_cons) {\n\t\tunsigned int len, hdr_len;\n\t\tu32 status;\n\t\tstruct bnx2_sw_bd *rx_buf, *next_rx_buf;\n\t\tstruct sk_buff *skb;\n\t\tdma_addr_t dma_addr;\n\t\tu8 *data;\n\t\tu16 next_ring_idx;\n\n\t\tsw_ring_cons = BNX2_RX_RING_IDX(sw_cons);\n\t\tsw_ring_prod = BNX2_RX_RING_IDX(sw_prod);\n\n\t\trx_buf = &rxr->rx_buf_ring[sw_ring_cons];\n\t\tdata = rx_buf->data;\n\t\trx_buf->data = NULL;\n\n\t\trx_hdr = get_l2_fhdr(data);\n\t\tprefetch(rx_hdr);\n\n\t\tdma_addr = dma_unmap_addr(rx_buf, mapping);\n\n\t\tdma_sync_single_for_cpu(&bp->pdev->dev, dma_addr,\n\t\t\tBNX2_RX_OFFSET + BNX2_RX_COPY_THRESH,\n\t\t\tDMA_FROM_DEVICE);\n\n\t\tnext_ring_idx = BNX2_RX_RING_IDX(BNX2_NEXT_RX_BD(sw_cons));\n\t\tnext_rx_buf = &rxr->rx_buf_ring[next_ring_idx];\n\t\tprefetch(get_l2_fhdr(next_rx_buf->data));\n\n\t\tlen = rx_hdr->l2_fhdr_pkt_len;\n\t\tstatus = rx_hdr->l2_fhdr_status;\n\n\t\thdr_len = 0;\n\t\tif (status & L2_FHDR_STATUS_SPLIT) {\n\t\t\thdr_len = rx_hdr->l2_fhdr_ip_xsum;\n\t\t\tpg_ring_used = 1;\n\t\t} else if (len > bp->rx_jumbo_thresh) {\n\t\t\thdr_len = bp->rx_jumbo_thresh;\n\t\t\tpg_ring_used = 1;\n\t\t}\n\n\t\tif (unlikely(status & (L2_FHDR_ERRORS_BAD_CRC |\n\t\t\t\t       L2_FHDR_ERRORS_PHY_DECODE |\n\t\t\t\t       L2_FHDR_ERRORS_ALIGNMENT |\n\t\t\t\t       L2_FHDR_ERRORS_TOO_SHORT |\n\t\t\t\t       L2_FHDR_ERRORS_GIANT_FRAME))) {\n\n\t\t\tbnx2_reuse_rx_data(bp, rxr, data, sw_ring_cons,\n\t\t\t\t\t  sw_ring_prod);\n\t\t\tif (pg_ring_used) {\n\t\t\t\tint pages;\n\n\t\t\t\tpages = PAGE_ALIGN(len - hdr_len) >> PAGE_SHIFT;\n\n\t\t\t\tbnx2_reuse_rx_skb_pages(bp, rxr, NULL, pages);\n\t\t\t}\n\t\t\tgoto next_rx;\n\t\t}\n\n\t\tlen -= 4;\n\n\t\tif (len <= bp->rx_copy_thresh) {\n\t\t\tskb = netdev_alloc_skb(bp->dev, len + 6);\n\t\t\tif (!skb) {\n\t\t\t\tbnx2_reuse_rx_data(bp, rxr, data, sw_ring_cons,\n\t\t\t\t\t\t  sw_ring_prod);\n\t\t\t\tgoto next_rx;\n\t\t\t}\n\n\t\t\t \n\t\t\tmemcpy(skb->data,\n\t\t\t       (u8 *)rx_hdr + BNX2_RX_OFFSET - 6,\n\t\t\t       len + 6);\n\t\t\tskb_reserve(skb, 6);\n\t\t\tskb_put(skb, len);\n\n\t\t\tbnx2_reuse_rx_data(bp, rxr, data,\n\t\t\t\tsw_ring_cons, sw_ring_prod);\n\n\t\t} else {\n\t\t\tskb = bnx2_rx_skb(bp, rxr, data, len, hdr_len, dma_addr,\n\t\t\t\t\t  (sw_ring_cons << 16) | sw_ring_prod);\n\t\t\tif (!skb)\n\t\t\t\tgoto next_rx;\n\t\t}\n\t\tif ((status & L2_FHDR_STATUS_L2_VLAN_TAG) &&\n\t\t    !(bp->rx_mode & BNX2_EMAC_RX_MODE_KEEP_VLAN_TAG))\n\t\t\t__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q), rx_hdr->l2_fhdr_vlan_tag);\n\n\t\tskb->protocol = eth_type_trans(skb, bp->dev);\n\n\t\tif (len > (bp->dev->mtu + ETH_HLEN) &&\n\t\t    skb->protocol != htons(0x8100) &&\n\t\t    skb->protocol != htons(ETH_P_8021AD)) {\n\n\t\t\tdev_kfree_skb(skb);\n\t\t\tgoto next_rx;\n\n\t\t}\n\n\t\tskb_checksum_none_assert(skb);\n\t\tif ((bp->dev->features & NETIF_F_RXCSUM) &&\n\t\t\t(status & (L2_FHDR_STATUS_TCP_SEGMENT |\n\t\t\tL2_FHDR_STATUS_UDP_DATAGRAM))) {\n\n\t\t\tif (likely((status & (L2_FHDR_ERRORS_TCP_XSUM |\n\t\t\t\t\t      L2_FHDR_ERRORS_UDP_XSUM)) == 0))\n\t\t\t\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\t\t}\n\t\tif ((bp->dev->features & NETIF_F_RXHASH) &&\n\t\t    ((status & L2_FHDR_STATUS_USE_RXHASH) ==\n\t\t     L2_FHDR_STATUS_USE_RXHASH))\n\t\t\tskb_set_hash(skb, rx_hdr->l2_fhdr_hash,\n\t\t\t\t     PKT_HASH_TYPE_L3);\n\n\t\tskb_record_rx_queue(skb, bnapi - &bp->bnx2_napi[0]);\n\t\tnapi_gro_receive(&bnapi->napi, skb);\n\t\trx_pkt++;\n\nnext_rx:\n\t\tsw_cons = BNX2_NEXT_RX_BD(sw_cons);\n\t\tsw_prod = BNX2_NEXT_RX_BD(sw_prod);\n\n\t\tif (rx_pkt == budget)\n\t\t\tbreak;\n\n\t\t \n\t\tif (sw_cons == hw_cons) {\n\t\t\thw_cons = bnx2_get_hw_rx_cons(bnapi);\n\t\t\trmb();\n\t\t}\n\t}\n\trxr->rx_cons = sw_cons;\n\trxr->rx_prod = sw_prod;\n\n\tif (pg_ring_used)\n\t\tBNX2_WR16(bp, rxr->rx_pg_bidx_addr, rxr->rx_pg_prod);\n\n\tBNX2_WR16(bp, rxr->rx_bidx_addr, sw_prod);\n\n\tBNX2_WR(bp, rxr->rx_bseq_addr, rxr->rx_prod_bseq);\n\n\treturn rx_pkt;\n\n}\n\n \nstatic irqreturn_t\nbnx2_msi(int irq, void *dev_instance)\n{\n\tstruct bnx2_napi *bnapi = dev_instance;\n\tstruct bnx2 *bp = bnapi->bp;\n\n\tprefetch(bnapi->status_blk.msi);\n\tBNX2_WR(bp, BNX2_PCICFG_INT_ACK_CMD,\n\t\tBNX2_PCICFG_INT_ACK_CMD_USE_INT_HC_PARAM |\n\t\tBNX2_PCICFG_INT_ACK_CMD_MASK_INT);\n\n\t \n\tif (unlikely(atomic_read(&bp->intr_sem) != 0))\n\t\treturn IRQ_HANDLED;\n\n\tnapi_schedule(&bnapi->napi);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t\nbnx2_msi_1shot(int irq, void *dev_instance)\n{\n\tstruct bnx2_napi *bnapi = dev_instance;\n\tstruct bnx2 *bp = bnapi->bp;\n\n\tprefetch(bnapi->status_blk.msi);\n\n\t \n\tif (unlikely(atomic_read(&bp->intr_sem) != 0))\n\t\treturn IRQ_HANDLED;\n\n\tnapi_schedule(&bnapi->napi);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t\nbnx2_interrupt(int irq, void *dev_instance)\n{\n\tstruct bnx2_napi *bnapi = dev_instance;\n\tstruct bnx2 *bp = bnapi->bp;\n\tstruct status_block *sblk = bnapi->status_blk.msi;\n\n\t \n\tif ((sblk->status_idx == bnapi->last_status_idx) &&\n\t    (BNX2_RD(bp, BNX2_PCICFG_MISC_STATUS) &\n\t     BNX2_PCICFG_MISC_STATUS_INTA_VALUE))\n\t\treturn IRQ_NONE;\n\n\tBNX2_WR(bp, BNX2_PCICFG_INT_ACK_CMD,\n\t\tBNX2_PCICFG_INT_ACK_CMD_USE_INT_HC_PARAM |\n\t\tBNX2_PCICFG_INT_ACK_CMD_MASK_INT);\n\n\t \n\tBNX2_RD(bp, BNX2_PCICFG_INT_ACK_CMD);\n\n\t \n\tif (unlikely(atomic_read(&bp->intr_sem) != 0))\n\t\treturn IRQ_HANDLED;\n\n\tif (napi_schedule_prep(&bnapi->napi)) {\n\t\tbnapi->last_status_idx = sblk->status_idx;\n\t\t__napi_schedule(&bnapi->napi);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic inline int\nbnx2_has_fast_work(struct bnx2_napi *bnapi)\n{\n\tstruct bnx2_tx_ring_info *txr = &bnapi->tx_ring;\n\tstruct bnx2_rx_ring_info *rxr = &bnapi->rx_ring;\n\n\tif ((bnx2_get_hw_rx_cons(bnapi) != rxr->rx_cons) ||\n\t    (bnx2_get_hw_tx_cons(bnapi) != txr->hw_tx_cons))\n\t\treturn 1;\n\treturn 0;\n}\n\n#define STATUS_ATTN_EVENTS\t(STATUS_ATTN_BITS_LINK_STATE | \\\n\t\t\t\t STATUS_ATTN_BITS_TIMER_ABORT)\n\nstatic inline int\nbnx2_has_work(struct bnx2_napi *bnapi)\n{\n\tstruct status_block *sblk = bnapi->status_blk.msi;\n\n\tif (bnx2_has_fast_work(bnapi))\n\t\treturn 1;\n\n#ifdef BCM_CNIC\n\tif (bnapi->cnic_present && (bnapi->cnic_tag != sblk->status_idx))\n\t\treturn 1;\n#endif\n\n\tif ((sblk->status_attn_bits & STATUS_ATTN_EVENTS) !=\n\t    (sblk->status_attn_bits_ack & STATUS_ATTN_EVENTS))\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic void\nbnx2_chk_missed_msi(struct bnx2 *bp)\n{\n\tstruct bnx2_napi *bnapi = &bp->bnx2_napi[0];\n\tu32 msi_ctrl;\n\n\tif (bnx2_has_work(bnapi)) {\n\t\tmsi_ctrl = BNX2_RD(bp, BNX2_PCICFG_MSI_CONTROL);\n\t\tif (!(msi_ctrl & BNX2_PCICFG_MSI_CONTROL_ENABLE))\n\t\t\treturn;\n\n\t\tif (bnapi->last_status_idx == bp->idle_chk_status_idx) {\n\t\t\tBNX2_WR(bp, BNX2_PCICFG_MSI_CONTROL, msi_ctrl &\n\t\t\t\t~BNX2_PCICFG_MSI_CONTROL_ENABLE);\n\t\t\tBNX2_WR(bp, BNX2_PCICFG_MSI_CONTROL, msi_ctrl);\n\t\t\tbnx2_msi(bp->irq_tbl[0].vector, bnapi);\n\t\t}\n\t}\n\n\tbp->idle_chk_status_idx = bnapi->last_status_idx;\n}\n\n#ifdef BCM_CNIC\nstatic void bnx2_poll_cnic(struct bnx2 *bp, struct bnx2_napi *bnapi)\n{\n\tstruct cnic_ops *c_ops;\n\n\tif (!bnapi->cnic_present)\n\t\treturn;\n\n\trcu_read_lock();\n\tc_ops = rcu_dereference(bp->cnic_ops);\n\tif (c_ops)\n\t\tbnapi->cnic_tag = c_ops->cnic_handler(bp->cnic_data,\n\t\t\t\t\t\t      bnapi->status_blk.msi);\n\trcu_read_unlock();\n}\n#endif\n\nstatic void bnx2_poll_link(struct bnx2 *bp, struct bnx2_napi *bnapi)\n{\n\tstruct status_block *sblk = bnapi->status_blk.msi;\n\tu32 status_attn_bits = sblk->status_attn_bits;\n\tu32 status_attn_bits_ack = sblk->status_attn_bits_ack;\n\n\tif ((status_attn_bits & STATUS_ATTN_EVENTS) !=\n\t    (status_attn_bits_ack & STATUS_ATTN_EVENTS)) {\n\n\t\tbnx2_phy_int(bp, bnapi);\n\n\t\t \n\t\tBNX2_WR(bp, BNX2_HC_COMMAND,\n\t\t\tbp->hc_cmd | BNX2_HC_COMMAND_COAL_NOW_WO_INT);\n\t\tBNX2_RD(bp, BNX2_HC_COMMAND);\n\t}\n}\n\nstatic int bnx2_poll_work(struct bnx2 *bp, struct bnx2_napi *bnapi,\n\t\t\t  int work_done, int budget)\n{\n\tstruct bnx2_tx_ring_info *txr = &bnapi->tx_ring;\n\tstruct bnx2_rx_ring_info *rxr = &bnapi->rx_ring;\n\n\tif (bnx2_get_hw_tx_cons(bnapi) != txr->hw_tx_cons)\n\t\tbnx2_tx_int(bp, bnapi, 0);\n\n\tif (bnx2_get_hw_rx_cons(bnapi) != rxr->rx_cons)\n\t\twork_done += bnx2_rx_int(bp, bnapi, budget - work_done);\n\n\treturn work_done;\n}\n\nstatic int bnx2_poll_msix(struct napi_struct *napi, int budget)\n{\n\tstruct bnx2_napi *bnapi = container_of(napi, struct bnx2_napi, napi);\n\tstruct bnx2 *bp = bnapi->bp;\n\tint work_done = 0;\n\tstruct status_block_msix *sblk = bnapi->status_blk.msix;\n\n\twhile (1) {\n\t\twork_done = bnx2_poll_work(bp, bnapi, work_done, budget);\n\t\tif (unlikely(work_done >= budget))\n\t\t\tbreak;\n\n\t\tbnapi->last_status_idx = sblk->status_idx;\n\t\t \n\t\trmb();\n\t\tif (likely(!bnx2_has_fast_work(bnapi))) {\n\n\t\t\tnapi_complete_done(napi, work_done);\n\t\t\tBNX2_WR(bp, BNX2_PCICFG_INT_ACK_CMD, bnapi->int_num |\n\t\t\t\tBNX2_PCICFG_INT_ACK_CMD_INDEX_VALID |\n\t\t\t\tbnapi->last_status_idx);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn work_done;\n}\n\nstatic int bnx2_poll(struct napi_struct *napi, int budget)\n{\n\tstruct bnx2_napi *bnapi = container_of(napi, struct bnx2_napi, napi);\n\tstruct bnx2 *bp = bnapi->bp;\n\tint work_done = 0;\n\tstruct status_block *sblk = bnapi->status_blk.msi;\n\n\twhile (1) {\n\t\tbnx2_poll_link(bp, bnapi);\n\n\t\twork_done = bnx2_poll_work(bp, bnapi, work_done, budget);\n\n#ifdef BCM_CNIC\n\t\tbnx2_poll_cnic(bp, bnapi);\n#endif\n\n\t\t \n\t\tbnapi->last_status_idx = sblk->status_idx;\n\n\t\tif (unlikely(work_done >= budget))\n\t\t\tbreak;\n\n\t\trmb();\n\t\tif (likely(!bnx2_has_work(bnapi))) {\n\t\t\tnapi_complete_done(napi, work_done);\n\t\t\tif (likely(bp->flags & BNX2_FLAG_USING_MSI_OR_MSIX)) {\n\t\t\t\tBNX2_WR(bp, BNX2_PCICFG_INT_ACK_CMD,\n\t\t\t\t\tBNX2_PCICFG_INT_ACK_CMD_INDEX_VALID |\n\t\t\t\t\tbnapi->last_status_idx);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tBNX2_WR(bp, BNX2_PCICFG_INT_ACK_CMD,\n\t\t\t\tBNX2_PCICFG_INT_ACK_CMD_INDEX_VALID |\n\t\t\t\tBNX2_PCICFG_INT_ACK_CMD_MASK_INT |\n\t\t\t\tbnapi->last_status_idx);\n\n\t\t\tBNX2_WR(bp, BNX2_PCICFG_INT_ACK_CMD,\n\t\t\t\tBNX2_PCICFG_INT_ACK_CMD_INDEX_VALID |\n\t\t\t\tbnapi->last_status_idx);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn work_done;\n}\n\n \nstatic void\nbnx2_set_rx_mode(struct net_device *dev)\n{\n\tstruct bnx2 *bp = netdev_priv(dev);\n\tu32 rx_mode, sort_mode;\n\tstruct netdev_hw_addr *ha;\n\tint i;\n\n\tif (!netif_running(dev))\n\t\treturn;\n\n\tspin_lock_bh(&bp->phy_lock);\n\n\trx_mode = bp->rx_mode & ~(BNX2_EMAC_RX_MODE_PROMISCUOUS |\n\t\t\t\t  BNX2_EMAC_RX_MODE_KEEP_VLAN_TAG);\n\tsort_mode = 1 | BNX2_RPM_SORT_USER0_BC_EN;\n\tif (!(dev->features & NETIF_F_HW_VLAN_CTAG_RX) &&\n\t     (bp->flags & BNX2_FLAG_CAN_KEEP_VLAN))\n\t\trx_mode |= BNX2_EMAC_RX_MODE_KEEP_VLAN_TAG;\n\tif (dev->flags & IFF_PROMISC) {\n\t\t \n\t\trx_mode |= BNX2_EMAC_RX_MODE_PROMISCUOUS;\n\t\tsort_mode |= BNX2_RPM_SORT_USER0_PROM_EN |\n\t\t\t     BNX2_RPM_SORT_USER0_PROM_VLAN;\n\t}\n\telse if (dev->flags & IFF_ALLMULTI) {\n\t\tfor (i = 0; i < NUM_MC_HASH_REGISTERS; i++) {\n\t\t\tBNX2_WR(bp, BNX2_EMAC_MULTICAST_HASH0 + (i * 4),\n\t\t\t\t0xffffffff);\n\t\t}\n\t\tsort_mode |= BNX2_RPM_SORT_USER0_MC_EN;\n\t}\n\telse {\n\t\t \n\t\tu32 mc_filter[NUM_MC_HASH_REGISTERS];\n\t\tu32 regidx;\n\t\tu32 bit;\n\t\tu32 crc;\n\n\t\tmemset(mc_filter, 0, 4 * NUM_MC_HASH_REGISTERS);\n\n\t\tnetdev_for_each_mc_addr(ha, dev) {\n\t\t\tcrc = ether_crc_le(ETH_ALEN, ha->addr);\n\t\t\tbit = crc & 0xff;\n\t\t\tregidx = (bit & 0xe0) >> 5;\n\t\t\tbit &= 0x1f;\n\t\t\tmc_filter[regidx] |= (1 << bit);\n\t\t}\n\n\t\tfor (i = 0; i < NUM_MC_HASH_REGISTERS; i++) {\n\t\t\tBNX2_WR(bp, BNX2_EMAC_MULTICAST_HASH0 + (i * 4),\n\t\t\t\tmc_filter[i]);\n\t\t}\n\n\t\tsort_mode |= BNX2_RPM_SORT_USER0_MC_HSH_EN;\n\t}\n\n\tif (netdev_uc_count(dev) > BNX2_MAX_UNICAST_ADDRESSES) {\n\t\trx_mode |= BNX2_EMAC_RX_MODE_PROMISCUOUS;\n\t\tsort_mode |= BNX2_RPM_SORT_USER0_PROM_EN |\n\t\t\t     BNX2_RPM_SORT_USER0_PROM_VLAN;\n\t} else if (!(dev->flags & IFF_PROMISC)) {\n\t\t \n\t\ti = 0;\n\t\tnetdev_for_each_uc_addr(ha, dev) {\n\t\t\tbnx2_set_mac_addr(bp, ha->addr,\n\t\t\t\t\t  i + BNX2_START_UNICAST_ADDRESS_INDEX);\n\t\t\tsort_mode |= (1 <<\n\t\t\t\t      (i + BNX2_START_UNICAST_ADDRESS_INDEX));\n\t\t\ti++;\n\t\t}\n\n\t}\n\n\tif (rx_mode != bp->rx_mode) {\n\t\tbp->rx_mode = rx_mode;\n\t\tBNX2_WR(bp, BNX2_EMAC_RX_MODE, rx_mode);\n\t}\n\n\tBNX2_WR(bp, BNX2_RPM_SORT_USER0, 0x0);\n\tBNX2_WR(bp, BNX2_RPM_SORT_USER0, sort_mode);\n\tBNX2_WR(bp, BNX2_RPM_SORT_USER0, sort_mode | BNX2_RPM_SORT_USER0_ENA);\n\n\tspin_unlock_bh(&bp->phy_lock);\n}\n\nstatic int\ncheck_fw_section(const struct firmware *fw,\n\t\t const struct bnx2_fw_file_section *section,\n\t\t u32 alignment, bool non_empty)\n{\n\tu32 offset = be32_to_cpu(section->offset);\n\tu32 len = be32_to_cpu(section->len);\n\n\tif ((offset == 0 && len != 0) || offset >= fw->size || offset & 3)\n\t\treturn -EINVAL;\n\tif ((non_empty && len == 0) || len > fw->size - offset ||\n\t    len & (alignment - 1))\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic int\ncheck_mips_fw_entry(const struct firmware *fw,\n\t\t    const struct bnx2_mips_fw_file_entry *entry)\n{\n\tif (check_fw_section(fw, &entry->text, 4, true) ||\n\t    check_fw_section(fw, &entry->data, 4, false) ||\n\t    check_fw_section(fw, &entry->rodata, 4, false))\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic void bnx2_release_firmware(struct bnx2 *bp)\n{\n\tif (bp->rv2p_firmware) {\n\t\trelease_firmware(bp->mips_firmware);\n\t\trelease_firmware(bp->rv2p_firmware);\n\t\tbp->rv2p_firmware = NULL;\n\t}\n}\n\nstatic int bnx2_request_uncached_firmware(struct bnx2 *bp)\n{\n\tconst char *mips_fw_file, *rv2p_fw_file;\n\tconst struct bnx2_mips_fw_file *mips_fw;\n\tconst struct bnx2_rv2p_fw_file *rv2p_fw;\n\tint rc;\n\n\tif (BNX2_CHIP(bp) == BNX2_CHIP_5709) {\n\t\tmips_fw_file = FW_MIPS_FILE_09;\n\t\tif ((BNX2_CHIP_ID(bp) == BNX2_CHIP_ID_5709_A0) ||\n\t\t    (BNX2_CHIP_ID(bp) == BNX2_CHIP_ID_5709_A1))\n\t\t\trv2p_fw_file = FW_RV2P_FILE_09_Ax;\n\t\telse\n\t\t\trv2p_fw_file = FW_RV2P_FILE_09;\n\t} else {\n\t\tmips_fw_file = FW_MIPS_FILE_06;\n\t\trv2p_fw_file = FW_RV2P_FILE_06;\n\t}\n\n\trc = request_firmware(&bp->mips_firmware, mips_fw_file, &bp->pdev->dev);\n\tif (rc) {\n\t\tpr_err(\"Can't load firmware file \\\"%s\\\"\\n\", mips_fw_file);\n\t\tgoto out;\n\t}\n\n\trc = request_firmware(&bp->rv2p_firmware, rv2p_fw_file, &bp->pdev->dev);\n\tif (rc) {\n\t\tpr_err(\"Can't load firmware file \\\"%s\\\"\\n\", rv2p_fw_file);\n\t\tgoto err_release_mips_firmware;\n\t}\n\tmips_fw = (const struct bnx2_mips_fw_file *) bp->mips_firmware->data;\n\trv2p_fw = (const struct bnx2_rv2p_fw_file *) bp->rv2p_firmware->data;\n\tif (bp->mips_firmware->size < sizeof(*mips_fw) ||\n\t    check_mips_fw_entry(bp->mips_firmware, &mips_fw->com) ||\n\t    check_mips_fw_entry(bp->mips_firmware, &mips_fw->cp) ||\n\t    check_mips_fw_entry(bp->mips_firmware, &mips_fw->rxp) ||\n\t    check_mips_fw_entry(bp->mips_firmware, &mips_fw->tpat) ||\n\t    check_mips_fw_entry(bp->mips_firmware, &mips_fw->txp)) {\n\t\tpr_err(\"Firmware file \\\"%s\\\" is invalid\\n\", mips_fw_file);\n\t\trc = -EINVAL;\n\t\tgoto err_release_firmware;\n\t}\n\tif (bp->rv2p_firmware->size < sizeof(*rv2p_fw) ||\n\t    check_fw_section(bp->rv2p_firmware, &rv2p_fw->proc1.rv2p, 8, true) ||\n\t    check_fw_section(bp->rv2p_firmware, &rv2p_fw->proc2.rv2p, 8, true)) {\n\t\tpr_err(\"Firmware file \\\"%s\\\" is invalid\\n\", rv2p_fw_file);\n\t\trc = -EINVAL;\n\t\tgoto err_release_firmware;\n\t}\nout:\n\treturn rc;\n\nerr_release_firmware:\n\trelease_firmware(bp->rv2p_firmware);\n\tbp->rv2p_firmware = NULL;\nerr_release_mips_firmware:\n\trelease_firmware(bp->mips_firmware);\n\tgoto out;\n}\n\nstatic int bnx2_request_firmware(struct bnx2 *bp)\n{\n\treturn bp->rv2p_firmware ? 0 : bnx2_request_uncached_firmware(bp);\n}\n\nstatic u32\nrv2p_fw_fixup(u32 rv2p_proc, int idx, u32 loc, u32 rv2p_code)\n{\n\tswitch (idx) {\n\tcase RV2P_P1_FIXUP_PAGE_SIZE_IDX:\n\t\trv2p_code &= ~RV2P_BD_PAGE_SIZE_MSK;\n\t\trv2p_code |= RV2P_BD_PAGE_SIZE;\n\t\tbreak;\n\t}\n\treturn rv2p_code;\n}\n\nstatic int\nload_rv2p_fw(struct bnx2 *bp, u32 rv2p_proc,\n\t     const struct bnx2_rv2p_fw_file_entry *fw_entry)\n{\n\tu32 rv2p_code_len, file_offset;\n\t__be32 *rv2p_code;\n\tint i;\n\tu32 val, cmd, addr;\n\n\trv2p_code_len = be32_to_cpu(fw_entry->rv2p.len);\n\tfile_offset = be32_to_cpu(fw_entry->rv2p.offset);\n\n\trv2p_code = (__be32 *)(bp->rv2p_firmware->data + file_offset);\n\n\tif (rv2p_proc == RV2P_PROC1) {\n\t\tcmd = BNX2_RV2P_PROC1_ADDR_CMD_RDWR;\n\t\taddr = BNX2_RV2P_PROC1_ADDR_CMD;\n\t} else {\n\t\tcmd = BNX2_RV2P_PROC2_ADDR_CMD_RDWR;\n\t\taddr = BNX2_RV2P_PROC2_ADDR_CMD;\n\t}\n\n\tfor (i = 0; i < rv2p_code_len; i += 8) {\n\t\tBNX2_WR(bp, BNX2_RV2P_INSTR_HIGH, be32_to_cpu(*rv2p_code));\n\t\trv2p_code++;\n\t\tBNX2_WR(bp, BNX2_RV2P_INSTR_LOW, be32_to_cpu(*rv2p_code));\n\t\trv2p_code++;\n\n\t\tval = (i / 8) | cmd;\n\t\tBNX2_WR(bp, addr, val);\n\t}\n\n\trv2p_code = (__be32 *)(bp->rv2p_firmware->data + file_offset);\n\tfor (i = 0; i < 8; i++) {\n\t\tu32 loc, code;\n\n\t\tloc = be32_to_cpu(fw_entry->fixup[i]);\n\t\tif (loc && ((loc * 4) < rv2p_code_len)) {\n\t\t\tcode = be32_to_cpu(*(rv2p_code + loc - 1));\n\t\t\tBNX2_WR(bp, BNX2_RV2P_INSTR_HIGH, code);\n\t\t\tcode = be32_to_cpu(*(rv2p_code + loc));\n\t\t\tcode = rv2p_fw_fixup(rv2p_proc, i, loc, code);\n\t\t\tBNX2_WR(bp, BNX2_RV2P_INSTR_LOW, code);\n\n\t\t\tval = (loc / 2) | cmd;\n\t\t\tBNX2_WR(bp, addr, val);\n\t\t}\n\t}\n\n\t \n\tif (rv2p_proc == RV2P_PROC1) {\n\t\tBNX2_WR(bp, BNX2_RV2P_COMMAND, BNX2_RV2P_COMMAND_PROC1_RESET);\n\t}\n\telse {\n\t\tBNX2_WR(bp, BNX2_RV2P_COMMAND, BNX2_RV2P_COMMAND_PROC2_RESET);\n\t}\n\n\treturn 0;\n}\n\nstatic void\nload_cpu_fw(struct bnx2 *bp, const struct cpu_reg *cpu_reg,\n\t    const struct bnx2_mips_fw_file_entry *fw_entry)\n{\n\tu32 addr, len, file_offset;\n\t__be32 *data;\n\tu32 offset;\n\tu32 val;\n\n\t \n\tval = bnx2_reg_rd_ind(bp, cpu_reg->mode);\n\tval |= cpu_reg->mode_value_halt;\n\tbnx2_reg_wr_ind(bp, cpu_reg->mode, val);\n\tbnx2_reg_wr_ind(bp, cpu_reg->state, cpu_reg->state_value_clear);\n\n\t \n\taddr = be32_to_cpu(fw_entry->text.addr);\n\tlen = be32_to_cpu(fw_entry->text.len);\n\tfile_offset = be32_to_cpu(fw_entry->text.offset);\n\tdata = (__be32 *)(bp->mips_firmware->data + file_offset);\n\n\toffset = cpu_reg->spad_base + (addr - cpu_reg->mips_view_base);\n\tif (len) {\n\t\tint j;\n\n\t\tfor (j = 0; j < (len / 4); j++, offset += 4)\n\t\t\tbnx2_reg_wr_ind(bp, offset, be32_to_cpu(data[j]));\n\t}\n\n\t \n\taddr = be32_to_cpu(fw_entry->data.addr);\n\tlen = be32_to_cpu(fw_entry->data.len);\n\tfile_offset = be32_to_cpu(fw_entry->data.offset);\n\tdata = (__be32 *)(bp->mips_firmware->data + file_offset);\n\n\toffset = cpu_reg->spad_base + (addr - cpu_reg->mips_view_base);\n\tif (len) {\n\t\tint j;\n\n\t\tfor (j = 0; j < (len / 4); j++, offset += 4)\n\t\t\tbnx2_reg_wr_ind(bp, offset, be32_to_cpu(data[j]));\n\t}\n\n\t \n\taddr = be32_to_cpu(fw_entry->rodata.addr);\n\tlen = be32_to_cpu(fw_entry->rodata.len);\n\tfile_offset = be32_to_cpu(fw_entry->rodata.offset);\n\tdata = (__be32 *)(bp->mips_firmware->data + file_offset);\n\n\toffset = cpu_reg->spad_base + (addr - cpu_reg->mips_view_base);\n\tif (len) {\n\t\tint j;\n\n\t\tfor (j = 0; j < (len / 4); j++, offset += 4)\n\t\t\tbnx2_reg_wr_ind(bp, offset, be32_to_cpu(data[j]));\n\t}\n\n\t \n\tbnx2_reg_wr_ind(bp, cpu_reg->inst, 0);\n\n\tval = be32_to_cpu(fw_entry->start_addr);\n\tbnx2_reg_wr_ind(bp, cpu_reg->pc, val);\n\n\t \n\tval = bnx2_reg_rd_ind(bp, cpu_reg->mode);\n\tval &= ~cpu_reg->mode_value_halt;\n\tbnx2_reg_wr_ind(bp, cpu_reg->state, cpu_reg->state_value_clear);\n\tbnx2_reg_wr_ind(bp, cpu_reg->mode, val);\n}\n\nstatic void\nbnx2_init_cpus(struct bnx2 *bp)\n{\n\tconst struct bnx2_mips_fw_file *mips_fw =\n\t\t(const struct bnx2_mips_fw_file *) bp->mips_firmware->data;\n\tconst struct bnx2_rv2p_fw_file *rv2p_fw =\n\t\t(const struct bnx2_rv2p_fw_file *) bp->rv2p_firmware->data;\n\n\t \n\tload_rv2p_fw(bp, RV2P_PROC1, &rv2p_fw->proc1);\n\tload_rv2p_fw(bp, RV2P_PROC2, &rv2p_fw->proc2);\n\n\t \n\tload_cpu_fw(bp, &cpu_reg_rxp, &mips_fw->rxp);\n\n\t \n\tload_cpu_fw(bp, &cpu_reg_txp, &mips_fw->txp);\n\n\t \n\tload_cpu_fw(bp, &cpu_reg_tpat, &mips_fw->tpat);\n\n\t \n\tload_cpu_fw(bp, &cpu_reg_com, &mips_fw->com);\n\n\t \n\tload_cpu_fw(bp, &cpu_reg_cp, &mips_fw->cp);\n}\n\nstatic void\nbnx2_setup_wol(struct bnx2 *bp)\n{\n\tint i;\n\tu32 val, wol_msg;\n\n\tif (bp->wol) {\n\t\tu32 advertising;\n\t\tu8 autoneg;\n\n\t\tautoneg = bp->autoneg;\n\t\tadvertising = bp->advertising;\n\n\t\tif (bp->phy_port == PORT_TP) {\n\t\t\tbp->autoneg = AUTONEG_SPEED;\n\t\t\tbp->advertising = ADVERTISED_10baseT_Half |\n\t\t\t\tADVERTISED_10baseT_Full |\n\t\t\t\tADVERTISED_100baseT_Half |\n\t\t\t\tADVERTISED_100baseT_Full |\n\t\t\t\tADVERTISED_Autoneg;\n\t\t}\n\n\t\tspin_lock_bh(&bp->phy_lock);\n\t\tbnx2_setup_phy(bp, bp->phy_port);\n\t\tspin_unlock_bh(&bp->phy_lock);\n\n\t\tbp->autoneg = autoneg;\n\t\tbp->advertising = advertising;\n\n\t\tbnx2_set_mac_addr(bp, bp->dev->dev_addr, 0);\n\n\t\tval = BNX2_RD(bp, BNX2_EMAC_MODE);\n\n\t\t \n\t\tval &= ~BNX2_EMAC_MODE_PORT;\n\t\tval |= BNX2_EMAC_MODE_MPKT_RCVD |\n\t\t       BNX2_EMAC_MODE_ACPI_RCVD |\n\t\t       BNX2_EMAC_MODE_MPKT;\n\t\tif (bp->phy_port == PORT_TP) {\n\t\t\tval |= BNX2_EMAC_MODE_PORT_MII;\n\t\t} else {\n\t\t\tval |= BNX2_EMAC_MODE_PORT_GMII;\n\t\t\tif (bp->line_speed == SPEED_2500)\n\t\t\t\tval |= BNX2_EMAC_MODE_25G_MODE;\n\t\t}\n\n\t\tBNX2_WR(bp, BNX2_EMAC_MODE, val);\n\n\t\t \n\t\tfor (i = 0; i < NUM_MC_HASH_REGISTERS; i++) {\n\t\t\tBNX2_WR(bp, BNX2_EMAC_MULTICAST_HASH0 + (i * 4),\n\t\t\t\t0xffffffff);\n\t\t}\n\t\tBNX2_WR(bp, BNX2_EMAC_RX_MODE, BNX2_EMAC_RX_MODE_SORT_MODE);\n\n\t\tval = 1 | BNX2_RPM_SORT_USER0_BC_EN | BNX2_RPM_SORT_USER0_MC_EN;\n\t\tBNX2_WR(bp, BNX2_RPM_SORT_USER0, 0x0);\n\t\tBNX2_WR(bp, BNX2_RPM_SORT_USER0, val);\n\t\tBNX2_WR(bp, BNX2_RPM_SORT_USER0, val | BNX2_RPM_SORT_USER0_ENA);\n\n\t\t \n\t\tBNX2_WR(bp, BNX2_MISC_ENABLE_SET_BITS,\n\t\t\tBNX2_MISC_ENABLE_SET_BITS_RX_PARSER_MAC_ENABLE |\n\t\t\tBNX2_MISC_ENABLE_SET_BITS_TX_HEADER_Q_ENABLE |\n\t\t\tBNX2_MISC_ENABLE_SET_BITS_EMAC_ENABLE);\n\n\t\tval = BNX2_RD(bp, BNX2_RPM_CONFIG);\n\t\tval &= ~BNX2_RPM_CONFIG_ACPI_ENA;\n\t\tBNX2_WR(bp, BNX2_RPM_CONFIG, val);\n\n\t\twol_msg = BNX2_DRV_MSG_CODE_SUSPEND_WOL;\n\t} else {\n\t\t\twol_msg = BNX2_DRV_MSG_CODE_SUSPEND_NO_WOL;\n\t}\n\n\tif (!(bp->flags & BNX2_FLAG_NO_WOL)) {\n\t\tu32 val;\n\n\t\twol_msg |= BNX2_DRV_MSG_DATA_WAIT3;\n\t\tif (bp->fw_last_msg || BNX2_CHIP(bp) != BNX2_CHIP_5709) {\n\t\t\tbnx2_fw_sync(bp, wol_msg, 1, 0);\n\t\t\treturn;\n\t\t}\n\t\t \n\t\tval = bnx2_shmem_rd(bp, BNX2_PORT_FEATURE);\n\t\tbnx2_shmem_wr(bp, BNX2_PORT_FEATURE,\n\t\t\t      val | BNX2_PORT_FEATURE_ASF_ENABLED);\n\t\tbnx2_fw_sync(bp, wol_msg, 1, 0);\n\t\tbnx2_shmem_wr(bp, BNX2_PORT_FEATURE, val);\n\t}\n\n}\n\nstatic int\nbnx2_set_power_state(struct bnx2 *bp, pci_power_t state)\n{\n\tswitch (state) {\n\tcase PCI_D0: {\n\t\tu32 val;\n\n\t\tpci_enable_wake(bp->pdev, PCI_D0, false);\n\t\tpci_set_power_state(bp->pdev, PCI_D0);\n\n\t\tval = BNX2_RD(bp, BNX2_EMAC_MODE);\n\t\tval |= BNX2_EMAC_MODE_MPKT_RCVD | BNX2_EMAC_MODE_ACPI_RCVD;\n\t\tval &= ~BNX2_EMAC_MODE_MPKT;\n\t\tBNX2_WR(bp, BNX2_EMAC_MODE, val);\n\n\t\tval = BNX2_RD(bp, BNX2_RPM_CONFIG);\n\t\tval &= ~BNX2_RPM_CONFIG_ACPI_ENA;\n\t\tBNX2_WR(bp, BNX2_RPM_CONFIG, val);\n\t\tbreak;\n\t}\n\tcase PCI_D3hot: {\n\t\tbnx2_setup_wol(bp);\n\t\tpci_wake_from_d3(bp->pdev, bp->wol);\n\t\tif ((BNX2_CHIP_ID(bp) == BNX2_CHIP_ID_5706_A0) ||\n\t\t    (BNX2_CHIP_ID(bp) == BNX2_CHIP_ID_5706_A1)) {\n\n\t\t\tif (bp->wol)\n\t\t\t\tpci_set_power_state(bp->pdev, PCI_D3hot);\n\t\t\tbreak;\n\n\t\t}\n\t\tif (!bp->fw_last_msg && BNX2_CHIP(bp) == BNX2_CHIP_5709) {\n\t\t\tu32 val;\n\n\t\t\t \n\t\t\tval = bnx2_shmem_rd(bp, BNX2_BC_STATE_CONDITION);\n\t\t\tval &= ~BNX2_CONDITION_PM_STATE_MASK;\n\t\t\tval |= BNX2_CONDITION_PM_STATE_UNPREP;\n\t\t\tbnx2_shmem_wr(bp, BNX2_BC_STATE_CONDITION, val);\n\t\t}\n\t\tpci_set_power_state(bp->pdev, PCI_D3hot);\n\n\t\t \n\t\tbreak;\n\t}\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int\nbnx2_acquire_nvram_lock(struct bnx2 *bp)\n{\n\tu32 val;\n\tint j;\n\n\t \n\tBNX2_WR(bp, BNX2_NVM_SW_ARB, BNX2_NVM_SW_ARB_ARB_REQ_SET2);\n\tfor (j = 0; j < NVRAM_TIMEOUT_COUNT; j++) {\n\t\tval = BNX2_RD(bp, BNX2_NVM_SW_ARB);\n\t\tif (val & BNX2_NVM_SW_ARB_ARB_ARB2)\n\t\t\tbreak;\n\n\t\tudelay(5);\n\t}\n\n\tif (j >= NVRAM_TIMEOUT_COUNT)\n\t\treturn -EBUSY;\n\n\treturn 0;\n}\n\nstatic int\nbnx2_release_nvram_lock(struct bnx2 *bp)\n{\n\tint j;\n\tu32 val;\n\n\t \n\tBNX2_WR(bp, BNX2_NVM_SW_ARB, BNX2_NVM_SW_ARB_ARB_REQ_CLR2);\n\n\tfor (j = 0; j < NVRAM_TIMEOUT_COUNT; j++) {\n\t\tval = BNX2_RD(bp, BNX2_NVM_SW_ARB);\n\t\tif (!(val & BNX2_NVM_SW_ARB_ARB_ARB2))\n\t\t\tbreak;\n\n\t\tudelay(5);\n\t}\n\n\tif (j >= NVRAM_TIMEOUT_COUNT)\n\t\treturn -EBUSY;\n\n\treturn 0;\n}\n\n\nstatic int\nbnx2_enable_nvram_write(struct bnx2 *bp)\n{\n\tu32 val;\n\n\tval = BNX2_RD(bp, BNX2_MISC_CFG);\n\tBNX2_WR(bp, BNX2_MISC_CFG, val | BNX2_MISC_CFG_NVM_WR_EN_PCI);\n\n\tif (bp->flash_info->flags & BNX2_NV_WREN) {\n\t\tint j;\n\n\t\tBNX2_WR(bp, BNX2_NVM_COMMAND, BNX2_NVM_COMMAND_DONE);\n\t\tBNX2_WR(bp, BNX2_NVM_COMMAND,\n\t\t\tBNX2_NVM_COMMAND_WREN | BNX2_NVM_COMMAND_DOIT);\n\n\t\tfor (j = 0; j < NVRAM_TIMEOUT_COUNT; j++) {\n\t\t\tudelay(5);\n\n\t\t\tval = BNX2_RD(bp, BNX2_NVM_COMMAND);\n\t\t\tif (val & BNX2_NVM_COMMAND_DONE)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (j >= NVRAM_TIMEOUT_COUNT)\n\t\t\treturn -EBUSY;\n\t}\n\treturn 0;\n}\n\nstatic void\nbnx2_disable_nvram_write(struct bnx2 *bp)\n{\n\tu32 val;\n\n\tval = BNX2_RD(bp, BNX2_MISC_CFG);\n\tBNX2_WR(bp, BNX2_MISC_CFG, val & ~BNX2_MISC_CFG_NVM_WR_EN);\n}\n\n\nstatic void\nbnx2_enable_nvram_access(struct bnx2 *bp)\n{\n\tu32 val;\n\n\tval = BNX2_RD(bp, BNX2_NVM_ACCESS_ENABLE);\n\t \n\tBNX2_WR(bp, BNX2_NVM_ACCESS_ENABLE,\n\t\tval | BNX2_NVM_ACCESS_ENABLE_EN | BNX2_NVM_ACCESS_ENABLE_WR_EN);\n}\n\nstatic void\nbnx2_disable_nvram_access(struct bnx2 *bp)\n{\n\tu32 val;\n\n\tval = BNX2_RD(bp, BNX2_NVM_ACCESS_ENABLE);\n\t \n\tBNX2_WR(bp, BNX2_NVM_ACCESS_ENABLE,\n\t\tval & ~(BNX2_NVM_ACCESS_ENABLE_EN |\n\t\t\tBNX2_NVM_ACCESS_ENABLE_WR_EN));\n}\n\nstatic int\nbnx2_nvram_erase_page(struct bnx2 *bp, u32 offset)\n{\n\tu32 cmd;\n\tint j;\n\n\tif (bp->flash_info->flags & BNX2_NV_BUFFERED)\n\t\t \n\t\treturn 0;\n\n\t \n\tcmd = BNX2_NVM_COMMAND_ERASE | BNX2_NVM_COMMAND_WR |\n\t      BNX2_NVM_COMMAND_DOIT;\n\n\t \n\tBNX2_WR(bp, BNX2_NVM_COMMAND, BNX2_NVM_COMMAND_DONE);\n\n\t \n\tBNX2_WR(bp, BNX2_NVM_ADDR, offset & BNX2_NVM_ADDR_NVM_ADDR_VALUE);\n\n\t \n\tBNX2_WR(bp, BNX2_NVM_COMMAND, cmd);\n\n\t \n\tfor (j = 0; j < NVRAM_TIMEOUT_COUNT; j++) {\n\t\tu32 val;\n\n\t\tudelay(5);\n\n\t\tval = BNX2_RD(bp, BNX2_NVM_COMMAND);\n\t\tif (val & BNX2_NVM_COMMAND_DONE)\n\t\t\tbreak;\n\t}\n\n\tif (j >= NVRAM_TIMEOUT_COUNT)\n\t\treturn -EBUSY;\n\n\treturn 0;\n}\n\nstatic int\nbnx2_nvram_read_dword(struct bnx2 *bp, u32 offset, u8 *ret_val, u32 cmd_flags)\n{\n\tu32 cmd;\n\tint j;\n\n\t \n\tcmd = BNX2_NVM_COMMAND_DOIT | cmd_flags;\n\n\t \n\tif (bp->flash_info->flags & BNX2_NV_TRANSLATE) {\n\t\toffset = ((offset / bp->flash_info->page_size) <<\n\t\t\t   bp->flash_info->page_bits) +\n\t\t\t  (offset % bp->flash_info->page_size);\n\t}\n\n\t \n\tBNX2_WR(bp, BNX2_NVM_COMMAND, BNX2_NVM_COMMAND_DONE);\n\n\t \n\tBNX2_WR(bp, BNX2_NVM_ADDR, offset & BNX2_NVM_ADDR_NVM_ADDR_VALUE);\n\n\t \n\tBNX2_WR(bp, BNX2_NVM_COMMAND, cmd);\n\n\t \n\tfor (j = 0; j < NVRAM_TIMEOUT_COUNT; j++) {\n\t\tu32 val;\n\n\t\tudelay(5);\n\n\t\tval = BNX2_RD(bp, BNX2_NVM_COMMAND);\n\t\tif (val & BNX2_NVM_COMMAND_DONE) {\n\t\t\t__be32 v = cpu_to_be32(BNX2_RD(bp, BNX2_NVM_READ));\n\t\t\tmemcpy(ret_val, &v, 4);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (j >= NVRAM_TIMEOUT_COUNT)\n\t\treturn -EBUSY;\n\n\treturn 0;\n}\n\n\nstatic int\nbnx2_nvram_write_dword(struct bnx2 *bp, u32 offset, u8 *val, u32 cmd_flags)\n{\n\tu32 cmd;\n\t__be32 val32;\n\tint j;\n\n\t \n\tcmd = BNX2_NVM_COMMAND_DOIT | BNX2_NVM_COMMAND_WR | cmd_flags;\n\n\t \n\tif (bp->flash_info->flags & BNX2_NV_TRANSLATE) {\n\t\toffset = ((offset / bp->flash_info->page_size) <<\n\t\t\t  bp->flash_info->page_bits) +\n\t\t\t (offset % bp->flash_info->page_size);\n\t}\n\n\t \n\tBNX2_WR(bp, BNX2_NVM_COMMAND, BNX2_NVM_COMMAND_DONE);\n\n\tmemcpy(&val32, val, 4);\n\n\t \n\tBNX2_WR(bp, BNX2_NVM_WRITE, be32_to_cpu(val32));\n\n\t \n\tBNX2_WR(bp, BNX2_NVM_ADDR, offset & BNX2_NVM_ADDR_NVM_ADDR_VALUE);\n\n\t \n\tBNX2_WR(bp, BNX2_NVM_COMMAND, cmd);\n\n\t \n\tfor (j = 0; j < NVRAM_TIMEOUT_COUNT; j++) {\n\t\tudelay(5);\n\n\t\tif (BNX2_RD(bp, BNX2_NVM_COMMAND) & BNX2_NVM_COMMAND_DONE)\n\t\t\tbreak;\n\t}\n\tif (j >= NVRAM_TIMEOUT_COUNT)\n\t\treturn -EBUSY;\n\n\treturn 0;\n}\n\nstatic int\nbnx2_init_nvram(struct bnx2 *bp)\n{\n\tu32 val;\n\tint j, entry_count, rc = 0;\n\tconst struct flash_spec *flash;\n\n\tif (BNX2_CHIP(bp) == BNX2_CHIP_5709) {\n\t\tbp->flash_info = &flash_5709;\n\t\tgoto get_flash_size;\n\t}\n\n\t \n\tval = BNX2_RD(bp, BNX2_NVM_CFG1);\n\n\tentry_count = ARRAY_SIZE(flash_table);\n\n\tif (val & 0x40000000) {\n\n\t\t \n\t\tfor (j = 0, flash = &flash_table[0]; j < entry_count;\n\t\t     j++, flash++) {\n\t\t\tif ((val & FLASH_BACKUP_STRAP_MASK) ==\n\t\t\t    (flash->config1 & FLASH_BACKUP_STRAP_MASK)) {\n\t\t\t\tbp->flash_info = flash;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\tu32 mask;\n\t\t \n\n\t\tif (val & (1 << 23))\n\t\t\tmask = FLASH_BACKUP_STRAP_MASK;\n\t\telse\n\t\t\tmask = FLASH_STRAP_MASK;\n\n\t\tfor (j = 0, flash = &flash_table[0]; j < entry_count;\n\t\t\tj++, flash++) {\n\n\t\t\tif ((val & mask) == (flash->strapping & mask)) {\n\t\t\t\tbp->flash_info = flash;\n\n\t\t\t\t \n\t\t\t\tif ((rc = bnx2_acquire_nvram_lock(bp)) != 0)\n\t\t\t\t\treturn rc;\n\n\t\t\t\t \n\t\t\t\tbnx2_enable_nvram_access(bp);\n\n\t\t\t\t \n\t\t\t\tBNX2_WR(bp, BNX2_NVM_CFG1, flash->config1);\n\t\t\t\tBNX2_WR(bp, BNX2_NVM_CFG2, flash->config2);\n\t\t\t\tBNX2_WR(bp, BNX2_NVM_CFG3, flash->config3);\n\t\t\t\tBNX2_WR(bp, BNX2_NVM_WRITE1, flash->write1);\n\n\t\t\t\t \n\t\t\t\tbnx2_disable_nvram_access(bp);\n\t\t\t\tbnx2_release_nvram_lock(bp);\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}  \n\n\tif (j == entry_count) {\n\t\tbp->flash_info = NULL;\n\t\tpr_alert(\"Unknown flash/EEPROM type\\n\");\n\t\treturn -ENODEV;\n\t}\n\nget_flash_size:\n\tval = bnx2_shmem_rd(bp, BNX2_SHARED_HW_CFG_CONFIG2);\n\tval &= BNX2_SHARED_HW_CFG2_NVM_SIZE_MASK;\n\tif (val)\n\t\tbp->flash_size = val;\n\telse\n\t\tbp->flash_size = bp->flash_info->total_size;\n\n\treturn rc;\n}\n\nstatic int\nbnx2_nvram_read(struct bnx2 *bp, u32 offset, u8 *ret_buf,\n\t\tint buf_size)\n{\n\tint rc = 0;\n\tu32 cmd_flags, offset32, len32, extra;\n\n\tif (buf_size == 0)\n\t\treturn 0;\n\n\t \n\tif ((rc = bnx2_acquire_nvram_lock(bp)) != 0)\n\t\treturn rc;\n\n\t \n\tbnx2_enable_nvram_access(bp);\n\n\tlen32 = buf_size;\n\toffset32 = offset;\n\textra = 0;\n\n\tcmd_flags = 0;\n\n\tif (offset32 & 3) {\n\t\tu8 buf[4];\n\t\tu32 pre_len;\n\n\t\toffset32 &= ~3;\n\t\tpre_len = 4 - (offset & 3);\n\n\t\tif (pre_len >= len32) {\n\t\t\tpre_len = len32;\n\t\t\tcmd_flags = BNX2_NVM_COMMAND_FIRST |\n\t\t\t\t    BNX2_NVM_COMMAND_LAST;\n\t\t}\n\t\telse {\n\t\t\tcmd_flags = BNX2_NVM_COMMAND_FIRST;\n\t\t}\n\n\t\trc = bnx2_nvram_read_dword(bp, offset32, buf, cmd_flags);\n\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\tmemcpy(ret_buf, buf + (offset & 3), pre_len);\n\n\t\toffset32 += 4;\n\t\tret_buf += pre_len;\n\t\tlen32 -= pre_len;\n\t}\n\tif (len32 & 3) {\n\t\textra = 4 - (len32 & 3);\n\t\tlen32 = (len32 + 4) & ~3;\n\t}\n\n\tif (len32 == 4) {\n\t\tu8 buf[4];\n\n\t\tif (cmd_flags)\n\t\t\tcmd_flags = BNX2_NVM_COMMAND_LAST;\n\t\telse\n\t\t\tcmd_flags = BNX2_NVM_COMMAND_FIRST |\n\t\t\t\t    BNX2_NVM_COMMAND_LAST;\n\n\t\trc = bnx2_nvram_read_dword(bp, offset32, buf, cmd_flags);\n\n\t\tmemcpy(ret_buf, buf, 4 - extra);\n\t}\n\telse if (len32 > 0) {\n\t\tu8 buf[4];\n\n\t\t \n\t\tif (cmd_flags)\n\t\t\tcmd_flags = 0;\n\t\telse\n\t\t\tcmd_flags = BNX2_NVM_COMMAND_FIRST;\n\n\t\trc = bnx2_nvram_read_dword(bp, offset32, ret_buf, cmd_flags);\n\n\t\t \n\t\toffset32 += 4;\n\t\tret_buf += 4;\n\t\tlen32 -= 4;\n\n\t\twhile (len32 > 4 && rc == 0) {\n\t\t\trc = bnx2_nvram_read_dword(bp, offset32, ret_buf, 0);\n\n\t\t\t \n\t\t\toffset32 += 4;\n\t\t\tret_buf += 4;\n\t\t\tlen32 -= 4;\n\t\t}\n\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\tcmd_flags = BNX2_NVM_COMMAND_LAST;\n\t\trc = bnx2_nvram_read_dword(bp, offset32, buf, cmd_flags);\n\n\t\tmemcpy(ret_buf, buf, 4 - extra);\n\t}\n\n\t \n\tbnx2_disable_nvram_access(bp);\n\n\tbnx2_release_nvram_lock(bp);\n\n\treturn rc;\n}\n\nstatic int\nbnx2_nvram_write(struct bnx2 *bp, u32 offset, u8 *data_buf,\n\t\tint buf_size)\n{\n\tu32 written, offset32, len32;\n\tu8 *buf, start[4], end[4], *align_buf = NULL, *flash_buffer = NULL;\n\tint rc = 0;\n\tint align_start, align_end;\n\n\tbuf = data_buf;\n\toffset32 = offset;\n\tlen32 = buf_size;\n\talign_start = align_end = 0;\n\n\tif ((align_start = (offset32 & 3))) {\n\t\toffset32 &= ~3;\n\t\tlen32 += align_start;\n\t\tif (len32 < 4)\n\t\t\tlen32 = 4;\n\t\tif ((rc = bnx2_nvram_read(bp, offset32, start, 4)))\n\t\t\treturn rc;\n\t}\n\n\tif (len32 & 3) {\n\t\talign_end = 4 - (len32 & 3);\n\t\tlen32 += align_end;\n\t\tif ((rc = bnx2_nvram_read(bp, offset32 + len32 - 4, end, 4)))\n\t\t\treturn rc;\n\t}\n\n\tif (align_start || align_end) {\n\t\talign_buf = kmalloc(len32, GFP_KERNEL);\n\t\tif (!align_buf)\n\t\t\treturn -ENOMEM;\n\t\tif (align_start) {\n\t\t\tmemcpy(align_buf, start, 4);\n\t\t}\n\t\tif (align_end) {\n\t\t\tmemcpy(align_buf + len32 - 4, end, 4);\n\t\t}\n\t\tmemcpy(align_buf + align_start, data_buf, buf_size);\n\t\tbuf = align_buf;\n\t}\n\n\tif (!(bp->flash_info->flags & BNX2_NV_BUFFERED)) {\n\t\tflash_buffer = kmalloc(264, GFP_KERNEL);\n\t\tif (!flash_buffer) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto nvram_write_end;\n\t\t}\n\t}\n\n\twritten = 0;\n\twhile ((written < len32) && (rc == 0)) {\n\t\tu32 page_start, page_end, data_start, data_end;\n\t\tu32 addr, cmd_flags;\n\t\tint i;\n\n\t         \n\t\tpage_start = offset32 + written;\n\t\tpage_start -= (page_start % bp->flash_info->page_size);\n\t\t \n\t\tpage_end = page_start + bp->flash_info->page_size;\n\t\t \n\t\tdata_start = (written == 0) ? offset32 : page_start;\n\t\t \n\t\tdata_end = (page_end > offset32 + len32) ?\n\t\t\t(offset32 + len32) : page_end;\n\n\t\t \n\t\tif ((rc = bnx2_acquire_nvram_lock(bp)) != 0)\n\t\t\tgoto nvram_write_end;\n\n\t\t \n\t\tbnx2_enable_nvram_access(bp);\n\n\t\tcmd_flags = BNX2_NVM_COMMAND_FIRST;\n\t\tif (!(bp->flash_info->flags & BNX2_NV_BUFFERED)) {\n\t\t\tint j;\n\n\t\t\t \n\t\t\tfor (j = 0; j < bp->flash_info->page_size; j += 4) {\n\t\t\t\tif (j == (bp->flash_info->page_size - 4)) {\n\t\t\t\t\tcmd_flags |= BNX2_NVM_COMMAND_LAST;\n\t\t\t\t}\n\t\t\t\trc = bnx2_nvram_read_dword(bp,\n\t\t\t\t\tpage_start + j,\n\t\t\t\t\t&flash_buffer[j],\n\t\t\t\t\tcmd_flags);\n\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto nvram_write_end;\n\n\t\t\t\tcmd_flags = 0;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif ((rc = bnx2_enable_nvram_write(bp)) != 0)\n\t\t\tgoto nvram_write_end;\n\n\t\t \n\t\ti = 0;\n\t\tif (!(bp->flash_info->flags & BNX2_NV_BUFFERED)) {\n\t\t\t \n\t\t\tif ((rc = bnx2_nvram_erase_page(bp, page_start)) != 0)\n\t\t\t\tgoto nvram_write_end;\n\n\t\t\t \n\t\t\tbnx2_enable_nvram_write(bp);\n\n\t\t\tfor (addr = page_start; addr < data_start;\n\t\t\t\taddr += 4, i += 4) {\n\n\t\t\t\trc = bnx2_nvram_write_dword(bp, addr,\n\t\t\t\t\t&flash_buffer[i], cmd_flags);\n\n\t\t\t\tif (rc != 0)\n\t\t\t\t\tgoto nvram_write_end;\n\n\t\t\t\tcmd_flags = 0;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tfor (addr = data_start; addr < data_end; addr += 4, i += 4) {\n\t\t\tif ((addr == page_end - 4) ||\n\t\t\t\t((bp->flash_info->flags & BNX2_NV_BUFFERED) &&\n\t\t\t\t (addr == data_end - 4))) {\n\n\t\t\t\tcmd_flags |= BNX2_NVM_COMMAND_LAST;\n\t\t\t}\n\t\t\trc = bnx2_nvram_write_dword(bp, addr, buf,\n\t\t\t\tcmd_flags);\n\n\t\t\tif (rc != 0)\n\t\t\t\tgoto nvram_write_end;\n\n\t\t\tcmd_flags = 0;\n\t\t\tbuf += 4;\n\t\t}\n\n\t\t \n\t\tif (!(bp->flash_info->flags & BNX2_NV_BUFFERED)) {\n\t\t\tfor (addr = data_end; addr < page_end;\n\t\t\t\taddr += 4, i += 4) {\n\n\t\t\t\tif (addr == page_end-4) {\n\t\t\t\t\tcmd_flags = BNX2_NVM_COMMAND_LAST;\n\t\t\t\t}\n\t\t\t\trc = bnx2_nvram_write_dword(bp, addr,\n\t\t\t\t\t&flash_buffer[i], cmd_flags);\n\n\t\t\t\tif (rc != 0)\n\t\t\t\t\tgoto nvram_write_end;\n\n\t\t\t\tcmd_flags = 0;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tbnx2_disable_nvram_write(bp);\n\n\t\t \n\t\tbnx2_disable_nvram_access(bp);\n\t\tbnx2_release_nvram_lock(bp);\n\n\t\t \n\t\twritten += data_end - data_start;\n\t}\n\nnvram_write_end:\n\tkfree(flash_buffer);\n\tkfree(align_buf);\n\treturn rc;\n}\n\nstatic void\nbnx2_init_fw_cap(struct bnx2 *bp)\n{\n\tu32 val, sig = 0;\n\n\tbp->phy_flags &= ~BNX2_PHY_FLAG_REMOTE_PHY_CAP;\n\tbp->flags &= ~BNX2_FLAG_CAN_KEEP_VLAN;\n\n\tif (!(bp->flags & BNX2_FLAG_ASF_ENABLE))\n\t\tbp->flags |= BNX2_FLAG_CAN_KEEP_VLAN;\n\n\tval = bnx2_shmem_rd(bp, BNX2_FW_CAP_MB);\n\tif ((val & BNX2_FW_CAP_SIGNATURE_MASK) != BNX2_FW_CAP_SIGNATURE)\n\t\treturn;\n\n\tif ((val & BNX2_FW_CAP_CAN_KEEP_VLAN) == BNX2_FW_CAP_CAN_KEEP_VLAN) {\n\t\tbp->flags |= BNX2_FLAG_CAN_KEEP_VLAN;\n\t\tsig |= BNX2_DRV_ACK_CAP_SIGNATURE | BNX2_FW_CAP_CAN_KEEP_VLAN;\n\t}\n\n\tif ((bp->phy_flags & BNX2_PHY_FLAG_SERDES) &&\n\t    (val & BNX2_FW_CAP_REMOTE_PHY_CAPABLE)) {\n\t\tu32 link;\n\n\t\tbp->phy_flags |= BNX2_PHY_FLAG_REMOTE_PHY_CAP;\n\n\t\tlink = bnx2_shmem_rd(bp, BNX2_LINK_STATUS);\n\t\tif (link & BNX2_LINK_STATUS_SERDES_LINK)\n\t\t\tbp->phy_port = PORT_FIBRE;\n\t\telse\n\t\t\tbp->phy_port = PORT_TP;\n\n\t\tsig |= BNX2_DRV_ACK_CAP_SIGNATURE |\n\t\t       BNX2_FW_CAP_REMOTE_PHY_CAPABLE;\n\t}\n\n\tif (netif_running(bp->dev) && sig)\n\t\tbnx2_shmem_wr(bp, BNX2_DRV_ACK_CAP_MB, sig);\n}\n\nstatic void\nbnx2_setup_msix_tbl(struct bnx2 *bp)\n{\n\tBNX2_WR(bp, BNX2_PCI_GRC_WINDOW_ADDR, BNX2_PCI_GRC_WINDOW_ADDR_SEP_WIN);\n\n\tBNX2_WR(bp, BNX2_PCI_GRC_WINDOW2_ADDR, BNX2_MSIX_TABLE_ADDR);\n\tBNX2_WR(bp, BNX2_PCI_GRC_WINDOW3_ADDR, BNX2_MSIX_PBA_ADDR);\n}\n\nstatic void\nbnx2_wait_dma_complete(struct bnx2 *bp)\n{\n\tu32 val;\n\tint i;\n\n\t \n\tif ((BNX2_CHIP(bp) == BNX2_CHIP_5706) ||\n\t    (BNX2_CHIP(bp) == BNX2_CHIP_5708)) {\n\t\tBNX2_WR(bp, BNX2_MISC_ENABLE_CLR_BITS,\n\t\t\tBNX2_MISC_ENABLE_CLR_BITS_TX_DMA_ENABLE |\n\t\t\tBNX2_MISC_ENABLE_CLR_BITS_DMA_ENGINE_ENABLE |\n\t\t\tBNX2_MISC_ENABLE_CLR_BITS_RX_DMA_ENABLE |\n\t\t\tBNX2_MISC_ENABLE_CLR_BITS_HOST_COALESCE_ENABLE);\n\t\tval = BNX2_RD(bp, BNX2_MISC_ENABLE_CLR_BITS);\n\t\tudelay(5);\n\t} else {   \n\t\tval = BNX2_RD(bp, BNX2_MISC_NEW_CORE_CTL);\n\t\tval &= ~BNX2_MISC_NEW_CORE_CTL_DMA_ENABLE;\n\t\tBNX2_WR(bp, BNX2_MISC_NEW_CORE_CTL, val);\n\t\tval = BNX2_RD(bp, BNX2_MISC_NEW_CORE_CTL);\n\n\t\tfor (i = 0; i < 100; i++) {\n\t\t\tmsleep(1);\n\t\t\tval = BNX2_RD(bp, BNX2_PCICFG_DEVICE_CONTROL);\n\t\t\tif (!(val & BNX2_PCICFG_DEVICE_STATUS_NO_PEND))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn;\n}\n\n\nstatic int\nbnx2_reset_chip(struct bnx2 *bp, u32 reset_code)\n{\n\tu32 val;\n\tint i, rc = 0;\n\tu8 old_port;\n\n\t \n\tbnx2_wait_dma_complete(bp);\n\n\t \n\tbnx2_fw_sync(bp, BNX2_DRV_MSG_DATA_WAIT0 | reset_code, 1, 1);\n\n\t \n\tbnx2_shmem_wr(bp, BNX2_DRV_RESET_SIGNATURE,\n\t\t      BNX2_DRV_RESET_SIGNATURE_MAGIC);\n\n\t \n\tval = BNX2_RD(bp, BNX2_MISC_ID);\n\n\tif (BNX2_CHIP(bp) == BNX2_CHIP_5709) {\n\t\tBNX2_WR(bp, BNX2_MISC_COMMAND, BNX2_MISC_COMMAND_SW_RESET);\n\t\tBNX2_RD(bp, BNX2_MISC_COMMAND);\n\t\tudelay(5);\n\n\t\tval = BNX2_PCICFG_MISC_CONFIG_REG_WINDOW_ENA |\n\t\t      BNX2_PCICFG_MISC_CONFIG_TARGET_MB_WORD_SWAP;\n\n\t\tBNX2_WR(bp, BNX2_PCICFG_MISC_CONFIG, val);\n\n\t} else {\n\t\tval = BNX2_PCICFG_MISC_CONFIG_CORE_RST_REQ |\n\t\t      BNX2_PCICFG_MISC_CONFIG_REG_WINDOW_ENA |\n\t\t      BNX2_PCICFG_MISC_CONFIG_TARGET_MB_WORD_SWAP;\n\n\t\t \n\t\tBNX2_WR(bp, BNX2_PCICFG_MISC_CONFIG, val);\n\n\t\t \n\t\tif ((BNX2_CHIP_ID(bp) == BNX2_CHIP_ID_5706_A0) ||\n\t\t    (BNX2_CHIP_ID(bp) == BNX2_CHIP_ID_5706_A1))\n\t\t\tmsleep(20);\n\n\t\t \n\t\tfor (i = 0; i < 10; i++) {\n\t\t\tval = BNX2_RD(bp, BNX2_PCICFG_MISC_CONFIG);\n\t\t\tif ((val & (BNX2_PCICFG_MISC_CONFIG_CORE_RST_REQ |\n\t\t\t\t    BNX2_PCICFG_MISC_CONFIG_CORE_RST_BSY)) == 0)\n\t\t\t\tbreak;\n\t\t\tudelay(10);\n\t\t}\n\n\t\tif (val & (BNX2_PCICFG_MISC_CONFIG_CORE_RST_REQ |\n\t\t\t   BNX2_PCICFG_MISC_CONFIG_CORE_RST_BSY)) {\n\t\t\tpr_err(\"Chip reset did not complete\\n\");\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\n\t \n\tval = BNX2_RD(bp, BNX2_PCI_SWAP_DIAG0);\n\tif (val != 0x01020304) {\n\t\tpr_err(\"Chip not in correct endian mode\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\trc = bnx2_fw_sync(bp, BNX2_DRV_MSG_DATA_WAIT1 | reset_code, 1, 0);\n\tif (rc)\n\t\treturn rc;\n\n\tspin_lock_bh(&bp->phy_lock);\n\told_port = bp->phy_port;\n\tbnx2_init_fw_cap(bp);\n\tif ((bp->phy_flags & BNX2_PHY_FLAG_REMOTE_PHY_CAP) &&\n\t    old_port != bp->phy_port)\n\t\tbnx2_set_default_remote_link(bp);\n\tspin_unlock_bh(&bp->phy_lock);\n\n\tif (BNX2_CHIP_ID(bp) == BNX2_CHIP_ID_5706_A0) {\n\t\t \n\t\tBNX2_WR(bp, BNX2_MISC_VREG_CONTROL, 0x000000fa);\n\n\t\t \n\t\trc = bnx2_alloc_bad_rbuf(bp);\n\t}\n\n\tif (bp->flags & BNX2_FLAG_USING_MSIX) {\n\t\tbnx2_setup_msix_tbl(bp);\n\t\t \n\t\tBNX2_WR(bp, BNX2_MISC_ECO_HW_CTL,\n\t\t\tBNX2_MISC_ECO_HW_CTL_LARGE_GRC_TMOUT_EN);\n\t}\n\n\treturn rc;\n}\n\nstatic int\nbnx2_init_chip(struct bnx2 *bp)\n{\n\tu32 val, mtu;\n\tint rc, i;\n\n\t \n\tBNX2_WR(bp, BNX2_PCICFG_INT_ACK_CMD, BNX2_PCICFG_INT_ACK_CMD_MASK_INT);\n\n\tval = BNX2_DMA_CONFIG_DATA_BYTE_SWAP |\n\t      BNX2_DMA_CONFIG_DATA_WORD_SWAP |\n#ifdef __BIG_ENDIAN\n\t      BNX2_DMA_CONFIG_CNTL_BYTE_SWAP |\n#endif\n\t      BNX2_DMA_CONFIG_CNTL_WORD_SWAP |\n\t      DMA_READ_CHANS << 12 |\n\t      DMA_WRITE_CHANS << 16;\n\n\tval |= (0x2 << 20) | (1 << 11);\n\n\tif ((bp->flags & BNX2_FLAG_PCIX) && (bp->bus_speed_mhz == 133))\n\t\tval |= (1 << 23);\n\n\tif ((BNX2_CHIP(bp) == BNX2_CHIP_5706) &&\n\t    (BNX2_CHIP_ID(bp) != BNX2_CHIP_ID_5706_A0) &&\n\t    !(bp->flags & BNX2_FLAG_PCIX))\n\t\tval |= BNX2_DMA_CONFIG_CNTL_PING_PONG_DMA;\n\n\tBNX2_WR(bp, BNX2_DMA_CONFIG, val);\n\n\tif (BNX2_CHIP_ID(bp) == BNX2_CHIP_ID_5706_A0) {\n\t\tval = BNX2_RD(bp, BNX2_TDMA_CONFIG);\n\t\tval |= BNX2_TDMA_CONFIG_ONE_DMA;\n\t\tBNX2_WR(bp, BNX2_TDMA_CONFIG, val);\n\t}\n\n\tif (bp->flags & BNX2_FLAG_PCIX) {\n\t\tu16 val16;\n\n\t\tpci_read_config_word(bp->pdev, bp->pcix_cap + PCI_X_CMD,\n\t\t\t\t     &val16);\n\t\tpci_write_config_word(bp->pdev, bp->pcix_cap + PCI_X_CMD,\n\t\t\t\t      val16 & ~PCI_X_CMD_ERO);\n\t}\n\n\tBNX2_WR(bp, BNX2_MISC_ENABLE_SET_BITS,\n\t\tBNX2_MISC_ENABLE_SET_BITS_HOST_COALESCE_ENABLE |\n\t\tBNX2_MISC_ENABLE_STATUS_BITS_RX_V2P_ENABLE |\n\t\tBNX2_MISC_ENABLE_STATUS_BITS_CONTEXT_ENABLE);\n\n\t \n\tif (BNX2_CHIP(bp) == BNX2_CHIP_5709) {\n\t\trc = bnx2_init_5709_context(bp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t} else\n\t\tbnx2_init_context(bp);\n\n\tbnx2_init_cpus(bp);\n\n\tbnx2_init_nvram(bp);\n\n\tbnx2_set_mac_addr(bp, bp->dev->dev_addr, 0);\n\n\tval = BNX2_RD(bp, BNX2_MQ_CONFIG);\n\tval &= ~BNX2_MQ_CONFIG_KNL_BYP_BLK_SIZE;\n\tval |= BNX2_MQ_CONFIG_KNL_BYP_BLK_SIZE_256;\n\tif (BNX2_CHIP(bp) == BNX2_CHIP_5709) {\n\t\tval |= BNX2_MQ_CONFIG_BIN_MQ_MODE;\n\t\tif (BNX2_CHIP_REV(bp) == BNX2_CHIP_REV_Ax)\n\t\t\tval |= BNX2_MQ_CONFIG_HALT_DIS;\n\t}\n\n\tBNX2_WR(bp, BNX2_MQ_CONFIG, val);\n\n\tval = 0x10000 + (MAX_CID_CNT * MB_KERNEL_CTX_SIZE);\n\tBNX2_WR(bp, BNX2_MQ_KNL_BYP_WIND_START, val);\n\tBNX2_WR(bp, BNX2_MQ_KNL_WIND_END, val);\n\n\tval = (BNX2_PAGE_BITS - 8) << 24;\n\tBNX2_WR(bp, BNX2_RV2P_CONFIG, val);\n\n\t \n\tval = BNX2_RD(bp, BNX2_TBDR_CONFIG);\n\tval &= ~BNX2_TBDR_CONFIG_PAGE_SIZE;\n\tval |= (BNX2_PAGE_BITS - 8) << 24 | 0x40;\n\tBNX2_WR(bp, BNX2_TBDR_CONFIG, val);\n\n\tval = bp->mac_addr[0] +\n\t      (bp->mac_addr[1] << 8) +\n\t      (bp->mac_addr[2] << 16) +\n\t      bp->mac_addr[3] +\n\t      (bp->mac_addr[4] << 8) +\n\t      (bp->mac_addr[5] << 16);\n\tBNX2_WR(bp, BNX2_EMAC_BACKOFF_SEED, val);\n\n\t \n\tmtu = bp->dev->mtu;\n\tval = mtu + ETH_HLEN + ETH_FCS_LEN;\n\tif (val > (MAX_ETHERNET_PACKET_SIZE + ETH_HLEN + 4))\n\t\tval |= BNX2_EMAC_RX_MTU_SIZE_JUMBO_ENA;\n\tBNX2_WR(bp, BNX2_EMAC_RX_MTU_SIZE, val);\n\n\tif (mtu < ETH_DATA_LEN)\n\t\tmtu = ETH_DATA_LEN;\n\n\tbnx2_reg_wr_ind(bp, BNX2_RBUF_CONFIG, BNX2_RBUF_CONFIG_VAL(mtu));\n\tbnx2_reg_wr_ind(bp, BNX2_RBUF_CONFIG2, BNX2_RBUF_CONFIG2_VAL(mtu));\n\tbnx2_reg_wr_ind(bp, BNX2_RBUF_CONFIG3, BNX2_RBUF_CONFIG3_VAL(mtu));\n\n\tmemset(bp->bnx2_napi[0].status_blk.msi, 0, bp->status_stats_size);\n\tfor (i = 0; i < BNX2_MAX_MSIX_VEC; i++)\n\t\tbp->bnx2_napi[i].last_status_idx = 0;\n\n\tbp->idle_chk_status_idx = 0xffff;\n\n\t \n\tBNX2_WR(bp, BNX2_EMAC_ATTENTION_ENA, BNX2_EMAC_ATTENTION_ENA_LINK);\n\n\tBNX2_WR(bp, BNX2_HC_STATUS_ADDR_L,\n\t\t(u64) bp->status_blk_mapping & 0xffffffff);\n\tBNX2_WR(bp, BNX2_HC_STATUS_ADDR_H, (u64) bp->status_blk_mapping >> 32);\n\n\tBNX2_WR(bp, BNX2_HC_STATISTICS_ADDR_L,\n\t\t(u64) bp->stats_blk_mapping & 0xffffffff);\n\tBNX2_WR(bp, BNX2_HC_STATISTICS_ADDR_H,\n\t\t(u64) bp->stats_blk_mapping >> 32);\n\n\tBNX2_WR(bp, BNX2_HC_TX_QUICK_CONS_TRIP,\n\t\t(bp->tx_quick_cons_trip_int << 16) | bp->tx_quick_cons_trip);\n\n\tBNX2_WR(bp, BNX2_HC_RX_QUICK_CONS_TRIP,\n\t\t(bp->rx_quick_cons_trip_int << 16) | bp->rx_quick_cons_trip);\n\n\tBNX2_WR(bp, BNX2_HC_COMP_PROD_TRIP,\n\t\t(bp->comp_prod_trip_int << 16) | bp->comp_prod_trip);\n\n\tBNX2_WR(bp, BNX2_HC_TX_TICKS, (bp->tx_ticks_int << 16) | bp->tx_ticks);\n\n\tBNX2_WR(bp, BNX2_HC_RX_TICKS, (bp->rx_ticks_int << 16) | bp->rx_ticks);\n\n\tBNX2_WR(bp, BNX2_HC_COM_TICKS,\n\t\t(bp->com_ticks_int << 16) | bp->com_ticks);\n\n\tBNX2_WR(bp, BNX2_HC_CMD_TICKS,\n\t\t(bp->cmd_ticks_int << 16) | bp->cmd_ticks);\n\n\tif (bp->flags & BNX2_FLAG_BROKEN_STATS)\n\t\tBNX2_WR(bp, BNX2_HC_STATS_TICKS, 0);\n\telse\n\t\tBNX2_WR(bp, BNX2_HC_STATS_TICKS, bp->stats_ticks);\n\tBNX2_WR(bp, BNX2_HC_STAT_COLLECT_TICKS, 0xbb8);   \n\n\tif (BNX2_CHIP_ID(bp) == BNX2_CHIP_ID_5706_A1)\n\t\tval = BNX2_HC_CONFIG_COLLECT_STATS;\n\telse {\n\t\tval = BNX2_HC_CONFIG_RX_TMR_MODE | BNX2_HC_CONFIG_TX_TMR_MODE |\n\t\t      BNX2_HC_CONFIG_COLLECT_STATS;\n\t}\n\n\tif (bp->flags & BNX2_FLAG_USING_MSIX) {\n\t\tBNX2_WR(bp, BNX2_HC_MSIX_BIT_VECTOR,\n\t\t\tBNX2_HC_MSIX_BIT_VECTOR_VAL);\n\n\t\tval |= BNX2_HC_CONFIG_SB_ADDR_INC_128B;\n\t}\n\n\tif (bp->flags & BNX2_FLAG_ONE_SHOT_MSI)\n\t\tval |= BNX2_HC_CONFIG_ONE_SHOT | BNX2_HC_CONFIG_USE_INT_PARAM;\n\n\tBNX2_WR(bp, BNX2_HC_CONFIG, val);\n\n\tif (bp->rx_ticks < 25)\n\t\tbnx2_reg_wr_ind(bp, BNX2_FW_RX_LOW_LATENCY, 1);\n\telse\n\t\tbnx2_reg_wr_ind(bp, BNX2_FW_RX_LOW_LATENCY, 0);\n\n\tfor (i = 1; i < bp->irq_nvecs; i++) {\n\t\tu32 base = ((i - 1) * BNX2_HC_SB_CONFIG_SIZE) +\n\t\t\t   BNX2_HC_SB_CONFIG_1;\n\n\t\tBNX2_WR(bp, base,\n\t\t\tBNX2_HC_SB_CONFIG_1_TX_TMR_MODE |\n\t\t\tBNX2_HC_SB_CONFIG_1_RX_TMR_MODE |\n\t\t\tBNX2_HC_SB_CONFIG_1_ONE_SHOT);\n\n\t\tBNX2_WR(bp, base + BNX2_HC_TX_QUICK_CONS_TRIP_OFF,\n\t\t\t(bp->tx_quick_cons_trip_int << 16) |\n\t\t\t bp->tx_quick_cons_trip);\n\n\t\tBNX2_WR(bp, base + BNX2_HC_TX_TICKS_OFF,\n\t\t\t(bp->tx_ticks_int << 16) | bp->tx_ticks);\n\n\t\tBNX2_WR(bp, base + BNX2_HC_RX_QUICK_CONS_TRIP_OFF,\n\t\t\t(bp->rx_quick_cons_trip_int << 16) |\n\t\t\tbp->rx_quick_cons_trip);\n\n\t\tBNX2_WR(bp, base + BNX2_HC_RX_TICKS_OFF,\n\t\t\t(bp->rx_ticks_int << 16) | bp->rx_ticks);\n\t}\n\n\t \n\tBNX2_WR(bp, BNX2_HC_COMMAND, BNX2_HC_COMMAND_CLR_STAT_NOW);\n\n\tBNX2_WR(bp, BNX2_HC_ATTN_BITS_ENABLE, STATUS_ATTN_EVENTS);\n\n\t \n\tbnx2_set_rx_mode(bp->dev);\n\n\tif (BNX2_CHIP(bp) == BNX2_CHIP_5709) {\n\t\tval = BNX2_RD(bp, BNX2_MISC_NEW_CORE_CTL);\n\t\tval |= BNX2_MISC_NEW_CORE_CTL_DMA_ENABLE;\n\t\tBNX2_WR(bp, BNX2_MISC_NEW_CORE_CTL, val);\n\t}\n\trc = bnx2_fw_sync(bp, BNX2_DRV_MSG_DATA_WAIT2 | BNX2_DRV_MSG_CODE_RESET,\n\t\t\t  1, 0);\n\n\tBNX2_WR(bp, BNX2_MISC_ENABLE_SET_BITS, BNX2_MISC_ENABLE_DEFAULT);\n\tBNX2_RD(bp, BNX2_MISC_ENABLE_SET_BITS);\n\n\tudelay(20);\n\n\tbp->hc_cmd = BNX2_RD(bp, BNX2_HC_COMMAND);\n\n\treturn rc;\n}\n\nstatic void\nbnx2_clear_ring_states(struct bnx2 *bp)\n{\n\tstruct bnx2_napi *bnapi;\n\tstruct bnx2_tx_ring_info *txr;\n\tstruct bnx2_rx_ring_info *rxr;\n\tint i;\n\n\tfor (i = 0; i < BNX2_MAX_MSIX_VEC; i++) {\n\t\tbnapi = &bp->bnx2_napi[i];\n\t\ttxr = &bnapi->tx_ring;\n\t\trxr = &bnapi->rx_ring;\n\n\t\ttxr->tx_cons = 0;\n\t\ttxr->hw_tx_cons = 0;\n\t\trxr->rx_prod_bseq = 0;\n\t\trxr->rx_prod = 0;\n\t\trxr->rx_cons = 0;\n\t\trxr->rx_pg_prod = 0;\n\t\trxr->rx_pg_cons = 0;\n\t}\n}\n\nstatic void\nbnx2_init_tx_context(struct bnx2 *bp, u32 cid, struct bnx2_tx_ring_info *txr)\n{\n\tu32 val, offset0, offset1, offset2, offset3;\n\tu32 cid_addr = GET_CID_ADDR(cid);\n\n\tif (BNX2_CHIP(bp) == BNX2_CHIP_5709) {\n\t\toffset0 = BNX2_L2CTX_TYPE_XI;\n\t\toffset1 = BNX2_L2CTX_CMD_TYPE_XI;\n\t\toffset2 = BNX2_L2CTX_TBDR_BHADDR_HI_XI;\n\t\toffset3 = BNX2_L2CTX_TBDR_BHADDR_LO_XI;\n\t} else {\n\t\toffset0 = BNX2_L2CTX_TYPE;\n\t\toffset1 = BNX2_L2CTX_CMD_TYPE;\n\t\toffset2 = BNX2_L2CTX_TBDR_BHADDR_HI;\n\t\toffset3 = BNX2_L2CTX_TBDR_BHADDR_LO;\n\t}\n\tval = BNX2_L2CTX_TYPE_TYPE_L2 | BNX2_L2CTX_TYPE_SIZE_L2;\n\tbnx2_ctx_wr(bp, cid_addr, offset0, val);\n\n\tval = BNX2_L2CTX_CMD_TYPE_TYPE_L2 | (8 << 16);\n\tbnx2_ctx_wr(bp, cid_addr, offset1, val);\n\n\tval = (u64) txr->tx_desc_mapping >> 32;\n\tbnx2_ctx_wr(bp, cid_addr, offset2, val);\n\n\tval = (u64) txr->tx_desc_mapping & 0xffffffff;\n\tbnx2_ctx_wr(bp, cid_addr, offset3, val);\n}\n\nstatic void\nbnx2_init_tx_ring(struct bnx2 *bp, int ring_num)\n{\n\tstruct bnx2_tx_bd *txbd;\n\tu32 cid = TX_CID;\n\tstruct bnx2_napi *bnapi;\n\tstruct bnx2_tx_ring_info *txr;\n\n\tbnapi = &bp->bnx2_napi[ring_num];\n\ttxr = &bnapi->tx_ring;\n\n\tif (ring_num == 0)\n\t\tcid = TX_CID;\n\telse\n\t\tcid = TX_TSS_CID + ring_num - 1;\n\n\tbp->tx_wake_thresh = bp->tx_ring_size / 2;\n\n\ttxbd = &txr->tx_desc_ring[BNX2_MAX_TX_DESC_CNT];\n\n\ttxbd->tx_bd_haddr_hi = (u64) txr->tx_desc_mapping >> 32;\n\ttxbd->tx_bd_haddr_lo = (u64) txr->tx_desc_mapping & 0xffffffff;\n\n\ttxr->tx_prod = 0;\n\ttxr->tx_prod_bseq = 0;\n\n\ttxr->tx_bidx_addr = MB_GET_CID_ADDR(cid) + BNX2_L2CTX_TX_HOST_BIDX;\n\ttxr->tx_bseq_addr = MB_GET_CID_ADDR(cid) + BNX2_L2CTX_TX_HOST_BSEQ;\n\n\tbnx2_init_tx_context(bp, cid, txr);\n}\n\nstatic void\nbnx2_init_rxbd_rings(struct bnx2_rx_bd *rx_ring[], dma_addr_t dma[],\n\t\t     u32 buf_size, int num_rings)\n{\n\tint i;\n\tstruct bnx2_rx_bd *rxbd;\n\n\tfor (i = 0; i < num_rings; i++) {\n\t\tint j;\n\n\t\trxbd = &rx_ring[i][0];\n\t\tfor (j = 0; j < BNX2_MAX_RX_DESC_CNT; j++, rxbd++) {\n\t\t\trxbd->rx_bd_len = buf_size;\n\t\t\trxbd->rx_bd_flags = RX_BD_FLAGS_START | RX_BD_FLAGS_END;\n\t\t}\n\t\tif (i == (num_rings - 1))\n\t\t\tj = 0;\n\t\telse\n\t\t\tj = i + 1;\n\t\trxbd->rx_bd_haddr_hi = (u64) dma[j] >> 32;\n\t\trxbd->rx_bd_haddr_lo = (u64) dma[j] & 0xffffffff;\n\t}\n}\n\nstatic void\nbnx2_init_rx_ring(struct bnx2 *bp, int ring_num)\n{\n\tint i;\n\tu16 prod, ring_prod;\n\tu32 cid, rx_cid_addr, val;\n\tstruct bnx2_napi *bnapi = &bp->bnx2_napi[ring_num];\n\tstruct bnx2_rx_ring_info *rxr = &bnapi->rx_ring;\n\n\tif (ring_num == 0)\n\t\tcid = RX_CID;\n\telse\n\t\tcid = RX_RSS_CID + ring_num - 1;\n\n\trx_cid_addr = GET_CID_ADDR(cid);\n\n\tbnx2_init_rxbd_rings(rxr->rx_desc_ring, rxr->rx_desc_mapping,\n\t\t\t     bp->rx_buf_use_size, bp->rx_max_ring);\n\n\tbnx2_init_rx_context(bp, cid);\n\n\tif (BNX2_CHIP(bp) == BNX2_CHIP_5709) {\n\t\tval = BNX2_RD(bp, BNX2_MQ_MAP_L2_5);\n\t\tBNX2_WR(bp, BNX2_MQ_MAP_L2_5, val | BNX2_MQ_MAP_L2_5_ARM);\n\t}\n\n\tbnx2_ctx_wr(bp, rx_cid_addr, BNX2_L2CTX_PG_BUF_SIZE, 0);\n\tif (bp->rx_pg_ring_size) {\n\t\tbnx2_init_rxbd_rings(rxr->rx_pg_desc_ring,\n\t\t\t\t     rxr->rx_pg_desc_mapping,\n\t\t\t\t     PAGE_SIZE, bp->rx_max_pg_ring);\n\t\tval = (bp->rx_buf_use_size << 16) | PAGE_SIZE;\n\t\tbnx2_ctx_wr(bp, rx_cid_addr, BNX2_L2CTX_PG_BUF_SIZE, val);\n\t\tbnx2_ctx_wr(bp, rx_cid_addr, BNX2_L2CTX_RBDC_KEY,\n\t\t       BNX2_L2CTX_RBDC_JUMBO_KEY - ring_num);\n\n\t\tval = (u64) rxr->rx_pg_desc_mapping[0] >> 32;\n\t\tbnx2_ctx_wr(bp, rx_cid_addr, BNX2_L2CTX_NX_PG_BDHADDR_HI, val);\n\n\t\tval = (u64) rxr->rx_pg_desc_mapping[0] & 0xffffffff;\n\t\tbnx2_ctx_wr(bp, rx_cid_addr, BNX2_L2CTX_NX_PG_BDHADDR_LO, val);\n\n\t\tif (BNX2_CHIP(bp) == BNX2_CHIP_5709)\n\t\t\tBNX2_WR(bp, BNX2_MQ_MAP_L2_3, BNX2_MQ_MAP_L2_3_DEFAULT);\n\t}\n\n\tval = (u64) rxr->rx_desc_mapping[0] >> 32;\n\tbnx2_ctx_wr(bp, rx_cid_addr, BNX2_L2CTX_NX_BDHADDR_HI, val);\n\n\tval = (u64) rxr->rx_desc_mapping[0] & 0xffffffff;\n\tbnx2_ctx_wr(bp, rx_cid_addr, BNX2_L2CTX_NX_BDHADDR_LO, val);\n\n\tring_prod = prod = rxr->rx_pg_prod;\n\tfor (i = 0; i < bp->rx_pg_ring_size; i++) {\n\t\tif (bnx2_alloc_rx_page(bp, rxr, ring_prod, GFP_KERNEL) < 0) {\n\t\t\tnetdev_warn(bp->dev, \"init'ed rx page ring %d with %d/%d pages only\\n\",\n\t\t\t\t    ring_num, i, bp->rx_pg_ring_size);\n\t\t\tbreak;\n\t\t}\n\t\tprod = BNX2_NEXT_RX_BD(prod);\n\t\tring_prod = BNX2_RX_PG_RING_IDX(prod);\n\t}\n\trxr->rx_pg_prod = prod;\n\n\tring_prod = prod = rxr->rx_prod;\n\tfor (i = 0; i < bp->rx_ring_size; i++) {\n\t\tif (bnx2_alloc_rx_data(bp, rxr, ring_prod, GFP_KERNEL) < 0) {\n\t\t\tnetdev_warn(bp->dev, \"init'ed rx ring %d with %d/%d skbs only\\n\",\n\t\t\t\t    ring_num, i, bp->rx_ring_size);\n\t\t\tbreak;\n\t\t}\n\t\tprod = BNX2_NEXT_RX_BD(prod);\n\t\tring_prod = BNX2_RX_RING_IDX(prod);\n\t}\n\trxr->rx_prod = prod;\n\n\trxr->rx_bidx_addr = MB_GET_CID_ADDR(cid) + BNX2_L2CTX_HOST_BDIDX;\n\trxr->rx_bseq_addr = MB_GET_CID_ADDR(cid) + BNX2_L2CTX_HOST_BSEQ;\n\trxr->rx_pg_bidx_addr = MB_GET_CID_ADDR(cid) + BNX2_L2CTX_HOST_PG_BDIDX;\n\n\tBNX2_WR16(bp, rxr->rx_pg_bidx_addr, rxr->rx_pg_prod);\n\tBNX2_WR16(bp, rxr->rx_bidx_addr, prod);\n\n\tBNX2_WR(bp, rxr->rx_bseq_addr, rxr->rx_prod_bseq);\n}\n\nstatic void\nbnx2_init_all_rings(struct bnx2 *bp)\n{\n\tint i;\n\tu32 val;\n\n\tbnx2_clear_ring_states(bp);\n\n\tBNX2_WR(bp, BNX2_TSCH_TSS_CFG, 0);\n\tfor (i = 0; i < bp->num_tx_rings; i++)\n\t\tbnx2_init_tx_ring(bp, i);\n\n\tif (bp->num_tx_rings > 1)\n\t\tBNX2_WR(bp, BNX2_TSCH_TSS_CFG, ((bp->num_tx_rings - 1) << 24) |\n\t\t\t(TX_TSS_CID << 7));\n\n\tBNX2_WR(bp, BNX2_RLUP_RSS_CONFIG, 0);\n\tbnx2_reg_wr_ind(bp, BNX2_RXP_SCRATCH_RSS_TBL_SZ, 0);\n\n\tfor (i = 0; i < bp->num_rx_rings; i++)\n\t\tbnx2_init_rx_ring(bp, i);\n\n\tif (bp->num_rx_rings > 1) {\n\t\tu32 tbl_32 = 0;\n\n\t\tfor (i = 0; i < BNX2_RXP_SCRATCH_RSS_TBL_MAX_ENTRIES; i++) {\n\t\t\tint shift = (i % 8) << 2;\n\n\t\t\ttbl_32 |= (i % (bp->num_rx_rings - 1)) << shift;\n\t\t\tif ((i % 8) == 7) {\n\t\t\t\tBNX2_WR(bp, BNX2_RLUP_RSS_DATA, tbl_32);\n\t\t\t\tBNX2_WR(bp, BNX2_RLUP_RSS_COMMAND, (i >> 3) |\n\t\t\t\t\tBNX2_RLUP_RSS_COMMAND_RSS_WRITE_MASK |\n\t\t\t\t\tBNX2_RLUP_RSS_COMMAND_WRITE |\n\t\t\t\t\tBNX2_RLUP_RSS_COMMAND_HASH_MASK);\n\t\t\t\ttbl_32 = 0;\n\t\t\t}\n\t\t}\n\n\t\tval = BNX2_RLUP_RSS_CONFIG_IPV4_RSS_TYPE_ALL_XI |\n\t\t      BNX2_RLUP_RSS_CONFIG_IPV6_RSS_TYPE_ALL_XI;\n\n\t\tBNX2_WR(bp, BNX2_RLUP_RSS_CONFIG, val);\n\n\t}\n}\n\nstatic u32 bnx2_find_max_ring(u32 ring_size, u32 max_size)\n{\n\tu32 max, num_rings = 1;\n\n\twhile (ring_size > BNX2_MAX_RX_DESC_CNT) {\n\t\tring_size -= BNX2_MAX_RX_DESC_CNT;\n\t\tnum_rings++;\n\t}\n\t \n\tmax = max_size;\n\twhile ((max & num_rings) == 0)\n\t\tmax >>= 1;\n\n\tif (num_rings != max)\n\t\tmax <<= 1;\n\n\treturn max;\n}\n\nstatic void\nbnx2_set_rx_ring_size(struct bnx2 *bp, u32 size)\n{\n\tu32 rx_size, rx_space, jumbo_size;\n\n\t \n\trx_size = bp->dev->mtu + ETH_HLEN + BNX2_RX_OFFSET + 8;\n\n\trx_space = SKB_DATA_ALIGN(rx_size + BNX2_RX_ALIGN) + NET_SKB_PAD +\n\t\tSKB_DATA_ALIGN(sizeof(struct skb_shared_info));\n\n\tbp->rx_copy_thresh = BNX2_RX_COPY_THRESH;\n\tbp->rx_pg_ring_size = 0;\n\tbp->rx_max_pg_ring = 0;\n\tbp->rx_max_pg_ring_idx = 0;\n\tif ((rx_space > PAGE_SIZE) && !(bp->flags & BNX2_FLAG_JUMBO_BROKEN)) {\n\t\tint pages = PAGE_ALIGN(bp->dev->mtu - 40) >> PAGE_SHIFT;\n\n\t\tjumbo_size = size * pages;\n\t\tif (jumbo_size > BNX2_MAX_TOTAL_RX_PG_DESC_CNT)\n\t\t\tjumbo_size = BNX2_MAX_TOTAL_RX_PG_DESC_CNT;\n\n\t\tbp->rx_pg_ring_size = jumbo_size;\n\t\tbp->rx_max_pg_ring = bnx2_find_max_ring(jumbo_size,\n\t\t\t\t\t\t\tBNX2_MAX_RX_PG_RINGS);\n\t\tbp->rx_max_pg_ring_idx =\n\t\t\t(bp->rx_max_pg_ring * BNX2_RX_DESC_CNT) - 1;\n\t\trx_size = BNX2_RX_COPY_THRESH + BNX2_RX_OFFSET;\n\t\tbp->rx_copy_thresh = 0;\n\t}\n\n\tbp->rx_buf_use_size = rx_size;\n\t \n\tbp->rx_buf_size = kmalloc_size_roundup(\n\t\tSKB_DATA_ALIGN(bp->rx_buf_use_size + BNX2_RX_ALIGN) +\n\t\tNET_SKB_PAD + SKB_DATA_ALIGN(sizeof(struct skb_shared_info)));\n\tbp->rx_jumbo_thresh = rx_size - BNX2_RX_OFFSET;\n\tbp->rx_ring_size = size;\n\tbp->rx_max_ring = bnx2_find_max_ring(size, BNX2_MAX_RX_RINGS);\n\tbp->rx_max_ring_idx = (bp->rx_max_ring * BNX2_RX_DESC_CNT) - 1;\n}\n\nstatic void\nbnx2_free_tx_skbs(struct bnx2 *bp)\n{\n\tint i;\n\n\tfor (i = 0; i < bp->num_tx_rings; i++) {\n\t\tstruct bnx2_napi *bnapi = &bp->bnx2_napi[i];\n\t\tstruct bnx2_tx_ring_info *txr = &bnapi->tx_ring;\n\t\tint j;\n\n\t\tif (!txr->tx_buf_ring)\n\t\t\tcontinue;\n\n\t\tfor (j = 0; j < BNX2_TX_DESC_CNT; ) {\n\t\t\tstruct bnx2_sw_tx_bd *tx_buf = &txr->tx_buf_ring[j];\n\t\t\tstruct sk_buff *skb = tx_buf->skb;\n\t\t\tint k, last;\n\n\t\t\tif (!skb) {\n\t\t\t\tj = BNX2_NEXT_TX_BD(j);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tdma_unmap_single(&bp->pdev->dev,\n\t\t\t\t\t dma_unmap_addr(tx_buf, mapping),\n\t\t\t\t\t skb_headlen(skb),\n\t\t\t\t\t DMA_TO_DEVICE);\n\n\t\t\ttx_buf->skb = NULL;\n\n\t\t\tlast = tx_buf->nr_frags;\n\t\t\tj = BNX2_NEXT_TX_BD(j);\n\t\t\tfor (k = 0; k < last; k++, j = BNX2_NEXT_TX_BD(j)) {\n\t\t\t\ttx_buf = &txr->tx_buf_ring[BNX2_TX_RING_IDX(j)];\n\t\t\t\tdma_unmap_page(&bp->pdev->dev,\n\t\t\t\t\tdma_unmap_addr(tx_buf, mapping),\n\t\t\t\t\tskb_frag_size(&skb_shinfo(skb)->frags[k]),\n\t\t\t\t\tDMA_TO_DEVICE);\n\t\t\t}\n\t\t\tdev_kfree_skb(skb);\n\t\t}\n\t\tnetdev_tx_reset_queue(netdev_get_tx_queue(bp->dev, i));\n\t}\n}\n\nstatic void\nbnx2_free_rx_skbs(struct bnx2 *bp)\n{\n\tint i;\n\n\tfor (i = 0; i < bp->num_rx_rings; i++) {\n\t\tstruct bnx2_napi *bnapi = &bp->bnx2_napi[i];\n\t\tstruct bnx2_rx_ring_info *rxr = &bnapi->rx_ring;\n\t\tint j;\n\n\t\tif (!rxr->rx_buf_ring)\n\t\t\treturn;\n\n\t\tfor (j = 0; j < bp->rx_max_ring_idx; j++) {\n\t\t\tstruct bnx2_sw_bd *rx_buf = &rxr->rx_buf_ring[j];\n\t\t\tu8 *data = rx_buf->data;\n\n\t\t\tif (!data)\n\t\t\t\tcontinue;\n\n\t\t\tdma_unmap_single(&bp->pdev->dev,\n\t\t\t\t\t dma_unmap_addr(rx_buf, mapping),\n\t\t\t\t\t bp->rx_buf_use_size,\n\t\t\t\t\t DMA_FROM_DEVICE);\n\n\t\t\trx_buf->data = NULL;\n\n\t\t\tkfree(data);\n\t\t}\n\t\tfor (j = 0; j < bp->rx_max_pg_ring_idx; j++)\n\t\t\tbnx2_free_rx_page(bp, rxr, j);\n\t}\n}\n\nstatic void\nbnx2_free_skbs(struct bnx2 *bp)\n{\n\tbnx2_free_tx_skbs(bp);\n\tbnx2_free_rx_skbs(bp);\n}\n\nstatic int\nbnx2_reset_nic(struct bnx2 *bp, u32 reset_code)\n{\n\tint rc;\n\n\trc = bnx2_reset_chip(bp, reset_code);\n\tbnx2_free_skbs(bp);\n\tif (rc)\n\t\treturn rc;\n\n\tif ((rc = bnx2_init_chip(bp)) != 0)\n\t\treturn rc;\n\n\tbnx2_init_all_rings(bp);\n\treturn 0;\n}\n\nstatic int\nbnx2_init_nic(struct bnx2 *bp, int reset_phy)\n{\n\tint rc;\n\n\tif ((rc = bnx2_reset_nic(bp, BNX2_DRV_MSG_CODE_RESET)) != 0)\n\t\treturn rc;\n\n\tspin_lock_bh(&bp->phy_lock);\n\tbnx2_init_phy(bp, reset_phy);\n\tbnx2_set_link(bp);\n\tif (bp->phy_flags & BNX2_PHY_FLAG_REMOTE_PHY_CAP)\n\t\tbnx2_remote_phy_event(bp);\n\tspin_unlock_bh(&bp->phy_lock);\n\treturn 0;\n}\n\nstatic int\nbnx2_shutdown_chip(struct bnx2 *bp)\n{\n\tu32 reset_code;\n\n\tif (bp->flags & BNX2_FLAG_NO_WOL)\n\t\treset_code = BNX2_DRV_MSG_CODE_UNLOAD_LNK_DN;\n\telse if (bp->wol)\n\t\treset_code = BNX2_DRV_MSG_CODE_SUSPEND_WOL;\n\telse\n\t\treset_code = BNX2_DRV_MSG_CODE_SUSPEND_NO_WOL;\n\n\treturn bnx2_reset_chip(bp, reset_code);\n}\n\nstatic int\nbnx2_test_registers(struct bnx2 *bp)\n{\n\tint ret;\n\tint i, is_5709;\n\tstatic const struct {\n\t\tu16   offset;\n\t\tu16   flags;\n#define BNX2_FL_NOT_5709\t1\n\t\tu32   rw_mask;\n\t\tu32   ro_mask;\n\t} reg_tbl[] = {\n\t\t{ 0x006c, 0, 0x00000000, 0x0000003f },\n\t\t{ 0x0090, 0, 0xffffffff, 0x00000000 },\n\t\t{ 0x0094, 0, 0x00000000, 0x00000000 },\n\n\t\t{ 0x0404, BNX2_FL_NOT_5709, 0x00003f00, 0x00000000 },\n\t\t{ 0x0418, BNX2_FL_NOT_5709, 0x00000000, 0xffffffff },\n\t\t{ 0x041c, BNX2_FL_NOT_5709, 0x00000000, 0xffffffff },\n\t\t{ 0x0420, BNX2_FL_NOT_5709, 0x00000000, 0x80ffffff },\n\t\t{ 0x0424, BNX2_FL_NOT_5709, 0x00000000, 0x00000000 },\n\t\t{ 0x0428, BNX2_FL_NOT_5709, 0x00000000, 0x00000001 },\n\t\t{ 0x0450, BNX2_FL_NOT_5709, 0x00000000, 0x0000ffff },\n\t\t{ 0x0454, BNX2_FL_NOT_5709, 0x00000000, 0xffffffff },\n\t\t{ 0x0458, BNX2_FL_NOT_5709, 0x00000000, 0xffffffff },\n\n\t\t{ 0x0808, BNX2_FL_NOT_5709, 0x00000000, 0xffffffff },\n\t\t{ 0x0854, BNX2_FL_NOT_5709, 0x00000000, 0xffffffff },\n\t\t{ 0x0868, BNX2_FL_NOT_5709, 0x00000000, 0x77777777 },\n\t\t{ 0x086c, BNX2_FL_NOT_5709, 0x00000000, 0x77777777 },\n\t\t{ 0x0870, BNX2_FL_NOT_5709, 0x00000000, 0x77777777 },\n\t\t{ 0x0874, BNX2_FL_NOT_5709, 0x00000000, 0x77777777 },\n\n\t\t{ 0x0c00, BNX2_FL_NOT_5709, 0x00000000, 0x00000001 },\n\t\t{ 0x0c04, BNX2_FL_NOT_5709, 0x00000000, 0x03ff0001 },\n\t\t{ 0x0c08, BNX2_FL_NOT_5709,  0x0f0ff073, 0x00000000 },\n\n\t\t{ 0x1000, 0, 0x00000000, 0x00000001 },\n\t\t{ 0x1004, BNX2_FL_NOT_5709, 0x00000000, 0x000f0001 },\n\n\t\t{ 0x1408, 0, 0x01c00800, 0x00000000 },\n\t\t{ 0x149c, 0, 0x8000ffff, 0x00000000 },\n\t\t{ 0x14a8, 0, 0x00000000, 0x000001ff },\n\t\t{ 0x14ac, 0, 0x0fffffff, 0x10000000 },\n\t\t{ 0x14b0, 0, 0x00000002, 0x00000001 },\n\t\t{ 0x14b8, 0, 0x00000000, 0x00000000 },\n\t\t{ 0x14c0, 0, 0x00000000, 0x00000009 },\n\t\t{ 0x14c4, 0, 0x00003fff, 0x00000000 },\n\t\t{ 0x14cc, 0, 0x00000000, 0x00000001 },\n\t\t{ 0x14d0, 0, 0xffffffff, 0x00000000 },\n\n\t\t{ 0x1800, 0, 0x00000000, 0x00000001 },\n\t\t{ 0x1804, 0, 0x00000000, 0x00000003 },\n\n\t\t{ 0x2800, 0, 0x00000000, 0x00000001 },\n\t\t{ 0x2804, 0, 0x00000000, 0x00003f01 },\n\t\t{ 0x2808, 0, 0x0f3f3f03, 0x00000000 },\n\t\t{ 0x2810, 0, 0xffff0000, 0x00000000 },\n\t\t{ 0x2814, 0, 0xffff0000, 0x00000000 },\n\t\t{ 0x2818, 0, 0xffff0000, 0x00000000 },\n\t\t{ 0x281c, 0, 0xffff0000, 0x00000000 },\n\t\t{ 0x2834, 0, 0xffffffff, 0x00000000 },\n\t\t{ 0x2840, 0, 0x00000000, 0xffffffff },\n\t\t{ 0x2844, 0, 0x00000000, 0xffffffff },\n\t\t{ 0x2848, 0, 0xffffffff, 0x00000000 },\n\t\t{ 0x284c, 0, 0xf800f800, 0x07ff07ff },\n\n\t\t{ 0x2c00, 0, 0x00000000, 0x00000011 },\n\t\t{ 0x2c04, 0, 0x00000000, 0x00030007 },\n\n\t\t{ 0x3c00, 0, 0x00000000, 0x00000001 },\n\t\t{ 0x3c04, 0, 0x00000000, 0x00070000 },\n\t\t{ 0x3c08, 0, 0x00007f71, 0x07f00000 },\n\t\t{ 0x3c0c, 0, 0x1f3ffffc, 0x00000000 },\n\t\t{ 0x3c10, 0, 0xffffffff, 0x00000000 },\n\t\t{ 0x3c14, 0, 0x00000000, 0xffffffff },\n\t\t{ 0x3c18, 0, 0x00000000, 0xffffffff },\n\t\t{ 0x3c1c, 0, 0xfffff000, 0x00000000 },\n\t\t{ 0x3c20, 0, 0xffffff00, 0x00000000 },\n\n\t\t{ 0x5004, 0, 0x00000000, 0x0000007f },\n\t\t{ 0x5008, 0, 0x0f0007ff, 0x00000000 },\n\n\t\t{ 0x5c00, 0, 0x00000000, 0x00000001 },\n\t\t{ 0x5c04, 0, 0x00000000, 0x0003000f },\n\t\t{ 0x5c08, 0, 0x00000003, 0x00000000 },\n\t\t{ 0x5c0c, 0, 0x0000fff8, 0x00000000 },\n\t\t{ 0x5c10, 0, 0x00000000, 0xffffffff },\n\t\t{ 0x5c80, 0, 0x00000000, 0x0f7113f1 },\n\t\t{ 0x5c84, 0, 0x00000000, 0x0000f333 },\n\t\t{ 0x5c88, 0, 0x00000000, 0x00077373 },\n\t\t{ 0x5c8c, 0, 0x00000000, 0x0007f737 },\n\n\t\t{ 0x6808, 0, 0x0000ff7f, 0x00000000 },\n\t\t{ 0x680c, 0, 0xffffffff, 0x00000000 },\n\t\t{ 0x6810, 0, 0xffffffff, 0x00000000 },\n\t\t{ 0x6814, 0, 0xffffffff, 0x00000000 },\n\t\t{ 0x6818, 0, 0xffffffff, 0x00000000 },\n\t\t{ 0x681c, 0, 0xffffffff, 0x00000000 },\n\t\t{ 0x6820, 0, 0x00ff00ff, 0x00000000 },\n\t\t{ 0x6824, 0, 0x00ff00ff, 0x00000000 },\n\t\t{ 0x6828, 0, 0x00ff00ff, 0x00000000 },\n\t\t{ 0x682c, 0, 0x03ff03ff, 0x00000000 },\n\t\t{ 0x6830, 0, 0x03ff03ff, 0x00000000 },\n\t\t{ 0x6834, 0, 0x03ff03ff, 0x00000000 },\n\t\t{ 0x6838, 0, 0x03ff03ff, 0x00000000 },\n\t\t{ 0x683c, 0, 0x0000ffff, 0x00000000 },\n\t\t{ 0x6840, 0, 0x00000ff0, 0x00000000 },\n\t\t{ 0x6844, 0, 0x00ffff00, 0x00000000 },\n\t\t{ 0x684c, 0, 0xffffffff, 0x00000000 },\n\t\t{ 0x6850, 0, 0x7f7f7f7f, 0x00000000 },\n\t\t{ 0x6854, 0, 0x7f7f7f7f, 0x00000000 },\n\t\t{ 0x6858, 0, 0x7f7f7f7f, 0x00000000 },\n\t\t{ 0x685c, 0, 0x7f7f7f7f, 0x00000000 },\n\t\t{ 0x6908, 0, 0x00000000, 0x0001ff0f },\n\t\t{ 0x690c, 0, 0x00000000, 0x0ffe00f0 },\n\n\t\t{ 0xffff, 0, 0x00000000, 0x00000000 },\n\t};\n\n\tret = 0;\n\tis_5709 = 0;\n\tif (BNX2_CHIP(bp) == BNX2_CHIP_5709)\n\t\tis_5709 = 1;\n\n\tfor (i = 0; reg_tbl[i].offset != 0xffff; i++) {\n\t\tu32 offset, rw_mask, ro_mask, save_val, val;\n\t\tu16 flags = reg_tbl[i].flags;\n\n\t\tif (is_5709 && (flags & BNX2_FL_NOT_5709))\n\t\t\tcontinue;\n\n\t\toffset = (u32) reg_tbl[i].offset;\n\t\trw_mask = reg_tbl[i].rw_mask;\n\t\tro_mask = reg_tbl[i].ro_mask;\n\n\t\tsave_val = readl(bp->regview + offset);\n\n\t\twritel(0, bp->regview + offset);\n\n\t\tval = readl(bp->regview + offset);\n\t\tif ((val & rw_mask) != 0) {\n\t\t\tgoto reg_test_err;\n\t\t}\n\n\t\tif ((val & ro_mask) != (save_val & ro_mask)) {\n\t\t\tgoto reg_test_err;\n\t\t}\n\n\t\twritel(0xffffffff, bp->regview + offset);\n\n\t\tval = readl(bp->regview + offset);\n\t\tif ((val & rw_mask) != rw_mask) {\n\t\t\tgoto reg_test_err;\n\t\t}\n\n\t\tif ((val & ro_mask) != (save_val & ro_mask)) {\n\t\t\tgoto reg_test_err;\n\t\t}\n\n\t\twritel(save_val, bp->regview + offset);\n\t\tcontinue;\n\nreg_test_err:\n\t\twritel(save_val, bp->regview + offset);\n\t\tret = -ENODEV;\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic int\nbnx2_do_mem_test(struct bnx2 *bp, u32 start, u32 size)\n{\n\tstatic const u32 test_pattern[] = { 0x00000000, 0xffffffff, 0x55555555,\n\t\t0xaaaaaaaa , 0xaa55aa55, 0x55aa55aa };\n\tint i;\n\n\tfor (i = 0; i < sizeof(test_pattern) / 4; i++) {\n\t\tu32 offset;\n\n\t\tfor (offset = 0; offset < size; offset += 4) {\n\n\t\t\tbnx2_reg_wr_ind(bp, start + offset, test_pattern[i]);\n\n\t\t\tif (bnx2_reg_rd_ind(bp, start + offset) !=\n\t\t\t\ttest_pattern[i]) {\n\t\t\t\treturn -ENODEV;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int\nbnx2_test_memory(struct bnx2 *bp)\n{\n\tint ret = 0;\n\tint i;\n\tstatic struct mem_entry {\n\t\tu32   offset;\n\t\tu32   len;\n\t} mem_tbl_5706[] = {\n\t\t{ 0x60000,  0x4000 },\n\t\t{ 0xa0000,  0x3000 },\n\t\t{ 0xe0000,  0x4000 },\n\t\t{ 0x120000, 0x4000 },\n\t\t{ 0x1a0000, 0x4000 },\n\t\t{ 0x160000, 0x4000 },\n\t\t{ 0xffffffff, 0    },\n\t},\n\tmem_tbl_5709[] = {\n\t\t{ 0x60000,  0x4000 },\n\t\t{ 0xa0000,  0x3000 },\n\t\t{ 0xe0000,  0x4000 },\n\t\t{ 0x120000, 0x4000 },\n\t\t{ 0x1a0000, 0x4000 },\n\t\t{ 0xffffffff, 0    },\n\t};\n\tstruct mem_entry *mem_tbl;\n\n\tif (BNX2_CHIP(bp) == BNX2_CHIP_5709)\n\t\tmem_tbl = mem_tbl_5709;\n\telse\n\t\tmem_tbl = mem_tbl_5706;\n\n\tfor (i = 0; mem_tbl[i].offset != 0xffffffff; i++) {\n\t\tif ((ret = bnx2_do_mem_test(bp, mem_tbl[i].offset,\n\t\t\tmem_tbl[i].len)) != 0) {\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n#define BNX2_MAC_LOOPBACK\t0\n#define BNX2_PHY_LOOPBACK\t1\n\nstatic int\nbnx2_run_loopback(struct bnx2 *bp, int loopback_mode)\n{\n\tunsigned int pkt_size, num_pkts, i;\n\tstruct sk_buff *skb;\n\tu8 *data;\n\tunsigned char *packet;\n\tu16 rx_start_idx, rx_idx;\n\tdma_addr_t map;\n\tstruct bnx2_tx_bd *txbd;\n\tstruct bnx2_sw_bd *rx_buf;\n\tstruct l2_fhdr *rx_hdr;\n\tint ret = -ENODEV;\n\tstruct bnx2_napi *bnapi = &bp->bnx2_napi[0], *tx_napi;\n\tstruct bnx2_tx_ring_info *txr;\n\tstruct bnx2_rx_ring_info *rxr;\n\n\ttx_napi = bnapi;\n\n\ttxr = &tx_napi->tx_ring;\n\trxr = &bnapi->rx_ring;\n\tif (loopback_mode == BNX2_MAC_LOOPBACK) {\n\t\tbp->loopback = MAC_LOOPBACK;\n\t\tbnx2_set_mac_loopback(bp);\n\t}\n\telse if (loopback_mode == BNX2_PHY_LOOPBACK) {\n\t\tif (bp->phy_flags & BNX2_PHY_FLAG_REMOTE_PHY_CAP)\n\t\t\treturn 0;\n\n\t\tbp->loopback = PHY_LOOPBACK;\n\t\tbnx2_set_phy_loopback(bp);\n\t}\n\telse\n\t\treturn -EINVAL;\n\n\tpkt_size = min(bp->dev->mtu + ETH_HLEN, bp->rx_jumbo_thresh - 4);\n\tskb = netdev_alloc_skb(bp->dev, pkt_size);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\tpacket = skb_put(skb, pkt_size);\n\tmemcpy(packet, bp->dev->dev_addr, ETH_ALEN);\n\tmemset(packet + ETH_ALEN, 0x0, 8);\n\tfor (i = 14; i < pkt_size; i++)\n\t\tpacket[i] = (unsigned char) (i & 0xff);\n\n\tmap = dma_map_single(&bp->pdev->dev, skb->data, pkt_size,\n\t\t\t     DMA_TO_DEVICE);\n\tif (dma_mapping_error(&bp->pdev->dev, map)) {\n\t\tdev_kfree_skb(skb);\n\t\treturn -EIO;\n\t}\n\n\tBNX2_WR(bp, BNX2_HC_COMMAND,\n\t\tbp->hc_cmd | BNX2_HC_COMMAND_COAL_NOW_WO_INT);\n\n\tBNX2_RD(bp, BNX2_HC_COMMAND);\n\n\tudelay(5);\n\trx_start_idx = bnx2_get_hw_rx_cons(bnapi);\n\n\tnum_pkts = 0;\n\n\ttxbd = &txr->tx_desc_ring[BNX2_TX_RING_IDX(txr->tx_prod)];\n\n\ttxbd->tx_bd_haddr_hi = (u64) map >> 32;\n\ttxbd->tx_bd_haddr_lo = (u64) map & 0xffffffff;\n\ttxbd->tx_bd_mss_nbytes = pkt_size;\n\ttxbd->tx_bd_vlan_tag_flags = TX_BD_FLAGS_START | TX_BD_FLAGS_END;\n\n\tnum_pkts++;\n\ttxr->tx_prod = BNX2_NEXT_TX_BD(txr->tx_prod);\n\ttxr->tx_prod_bseq += pkt_size;\n\n\tBNX2_WR16(bp, txr->tx_bidx_addr, txr->tx_prod);\n\tBNX2_WR(bp, txr->tx_bseq_addr, txr->tx_prod_bseq);\n\n\tudelay(100);\n\n\tBNX2_WR(bp, BNX2_HC_COMMAND,\n\t\tbp->hc_cmd | BNX2_HC_COMMAND_COAL_NOW_WO_INT);\n\n\tBNX2_RD(bp, BNX2_HC_COMMAND);\n\n\tudelay(5);\n\n\tdma_unmap_single(&bp->pdev->dev, map, pkt_size, DMA_TO_DEVICE);\n\tdev_kfree_skb(skb);\n\n\tif (bnx2_get_hw_tx_cons(tx_napi) != txr->tx_prod)\n\t\tgoto loopback_test_done;\n\n\trx_idx = bnx2_get_hw_rx_cons(bnapi);\n\tif (rx_idx != rx_start_idx + num_pkts) {\n\t\tgoto loopback_test_done;\n\t}\n\n\trx_buf = &rxr->rx_buf_ring[rx_start_idx];\n\tdata = rx_buf->data;\n\n\trx_hdr = get_l2_fhdr(data);\n\tdata = (u8 *)rx_hdr + BNX2_RX_OFFSET;\n\n\tdma_sync_single_for_cpu(&bp->pdev->dev,\n\t\tdma_unmap_addr(rx_buf, mapping),\n\t\tbp->rx_buf_use_size, DMA_FROM_DEVICE);\n\n\tif (rx_hdr->l2_fhdr_status &\n\t\t(L2_FHDR_ERRORS_BAD_CRC |\n\t\tL2_FHDR_ERRORS_PHY_DECODE |\n\t\tL2_FHDR_ERRORS_ALIGNMENT |\n\t\tL2_FHDR_ERRORS_TOO_SHORT |\n\t\tL2_FHDR_ERRORS_GIANT_FRAME)) {\n\n\t\tgoto loopback_test_done;\n\t}\n\n\tif ((rx_hdr->l2_fhdr_pkt_len - 4) != pkt_size) {\n\t\tgoto loopback_test_done;\n\t}\n\n\tfor (i = 14; i < pkt_size; i++) {\n\t\tif (*(data + i) != (unsigned char) (i & 0xff)) {\n\t\t\tgoto loopback_test_done;\n\t\t}\n\t}\n\n\tret = 0;\n\nloopback_test_done:\n\tbp->loopback = 0;\n\treturn ret;\n}\n\n#define BNX2_MAC_LOOPBACK_FAILED\t1\n#define BNX2_PHY_LOOPBACK_FAILED\t2\n#define BNX2_LOOPBACK_FAILED\t\t(BNX2_MAC_LOOPBACK_FAILED |\t\\\n\t\t\t\t\t BNX2_PHY_LOOPBACK_FAILED)\n\nstatic int\nbnx2_test_loopback(struct bnx2 *bp)\n{\n\tint rc = 0;\n\n\tif (!netif_running(bp->dev))\n\t\treturn BNX2_LOOPBACK_FAILED;\n\n\tbnx2_reset_nic(bp, BNX2_DRV_MSG_CODE_RESET);\n\tspin_lock_bh(&bp->phy_lock);\n\tbnx2_init_phy(bp, 1);\n\tspin_unlock_bh(&bp->phy_lock);\n\tif (bnx2_run_loopback(bp, BNX2_MAC_LOOPBACK))\n\t\trc |= BNX2_MAC_LOOPBACK_FAILED;\n\tif (bnx2_run_loopback(bp, BNX2_PHY_LOOPBACK))\n\t\trc |= BNX2_PHY_LOOPBACK_FAILED;\n\treturn rc;\n}\n\n#define NVRAM_SIZE 0x200\n#define CRC32_RESIDUAL 0xdebb20e3\n\nstatic int\nbnx2_test_nvram(struct bnx2 *bp)\n{\n\t__be32 buf[NVRAM_SIZE / 4];\n\tu8 *data = (u8 *) buf;\n\tint rc = 0;\n\tu32 magic, csum;\n\n\tif ((rc = bnx2_nvram_read(bp, 0, data, 4)) != 0)\n\t\tgoto test_nvram_done;\n\n        magic = be32_to_cpu(buf[0]);\n\tif (magic != 0x669955aa) {\n\t\trc = -ENODEV;\n\t\tgoto test_nvram_done;\n\t}\n\n\tif ((rc = bnx2_nvram_read(bp, 0x100, data, NVRAM_SIZE)) != 0)\n\t\tgoto test_nvram_done;\n\n\tcsum = ether_crc_le(0x100, data);\n\tif (csum != CRC32_RESIDUAL) {\n\t\trc = -ENODEV;\n\t\tgoto test_nvram_done;\n\t}\n\n\tcsum = ether_crc_le(0x100, data + 0x100);\n\tif (csum != CRC32_RESIDUAL) {\n\t\trc = -ENODEV;\n\t}\n\ntest_nvram_done:\n\treturn rc;\n}\n\nstatic int\nbnx2_test_link(struct bnx2 *bp)\n{\n\tu32 bmsr;\n\n\tif (!netif_running(bp->dev))\n\t\treturn -ENODEV;\n\n\tif (bp->phy_flags & BNX2_PHY_FLAG_REMOTE_PHY_CAP) {\n\t\tif (bp->link_up)\n\t\t\treturn 0;\n\t\treturn -ENODEV;\n\t}\n\tspin_lock_bh(&bp->phy_lock);\n\tbnx2_enable_bmsr1(bp);\n\tbnx2_read_phy(bp, bp->mii_bmsr1, &bmsr);\n\tbnx2_read_phy(bp, bp->mii_bmsr1, &bmsr);\n\tbnx2_disable_bmsr1(bp);\n\tspin_unlock_bh(&bp->phy_lock);\n\n\tif (bmsr & BMSR_LSTATUS) {\n\t\treturn 0;\n\t}\n\treturn -ENODEV;\n}\n\nstatic int\nbnx2_test_intr(struct bnx2 *bp)\n{\n\tint i;\n\tu16 status_idx;\n\n\tif (!netif_running(bp->dev))\n\t\treturn -ENODEV;\n\n\tstatus_idx = BNX2_RD(bp, BNX2_PCICFG_INT_ACK_CMD) & 0xffff;\n\n\t \n\tBNX2_WR(bp, BNX2_HC_COMMAND, bp->hc_cmd | BNX2_HC_COMMAND_COAL_NOW);\n\tBNX2_RD(bp, BNX2_HC_COMMAND);\n\n\tfor (i = 0; i < 10; i++) {\n\t\tif ((BNX2_RD(bp, BNX2_PCICFG_INT_ACK_CMD) & 0xffff) !=\n\t\t\tstatus_idx) {\n\n\t\t\tbreak;\n\t\t}\n\n\t\tmsleep_interruptible(10);\n\t}\n\tif (i < 10)\n\t\treturn 0;\n\n\treturn -ENODEV;\n}\n\n \nstatic int\nbnx2_5706_serdes_has_link(struct bnx2 *bp)\n{\n\tu32 mode_ctl, an_dbg, exp;\n\n\tif (bp->phy_flags & BNX2_PHY_FLAG_NO_PARALLEL)\n\t\treturn 0;\n\n\tbnx2_write_phy(bp, MII_BNX2_MISC_SHADOW, MISC_SHDW_MODE_CTL);\n\tbnx2_read_phy(bp, MII_BNX2_MISC_SHADOW, &mode_ctl);\n\n\tif (!(mode_ctl & MISC_SHDW_MODE_CTL_SIG_DET))\n\t\treturn 0;\n\n\tbnx2_write_phy(bp, MII_BNX2_MISC_SHADOW, MISC_SHDW_AN_DBG);\n\tbnx2_read_phy(bp, MII_BNX2_MISC_SHADOW, &an_dbg);\n\tbnx2_read_phy(bp, MII_BNX2_MISC_SHADOW, &an_dbg);\n\n\tif (an_dbg & (MISC_SHDW_AN_DBG_NOSYNC | MISC_SHDW_AN_DBG_RUDI_INVALID))\n\t\treturn 0;\n\n\tbnx2_write_phy(bp, MII_BNX2_DSP_ADDRESS, MII_EXPAND_REG1);\n\tbnx2_read_phy(bp, MII_BNX2_DSP_RW_PORT, &exp);\n\tbnx2_read_phy(bp, MII_BNX2_DSP_RW_PORT, &exp);\n\n\tif (exp & MII_EXPAND_REG1_RUDI_C)\t \n\t\treturn 0;\n\n\treturn 1;\n}\n\nstatic void\nbnx2_5706_serdes_timer(struct bnx2 *bp)\n{\n\tint check_link = 1;\n\n\tspin_lock(&bp->phy_lock);\n\tif (bp->serdes_an_pending) {\n\t\tbp->serdes_an_pending--;\n\t\tcheck_link = 0;\n\t} else if ((bp->link_up == 0) && (bp->autoneg & AUTONEG_SPEED)) {\n\t\tu32 bmcr;\n\n\t\tbp->current_interval = BNX2_TIMER_INTERVAL;\n\n\t\tbnx2_read_phy(bp, bp->mii_bmcr, &bmcr);\n\n\t\tif (bmcr & BMCR_ANENABLE) {\n\t\t\tif (bnx2_5706_serdes_has_link(bp)) {\n\t\t\t\tbmcr &= ~BMCR_ANENABLE;\n\t\t\t\tbmcr |= BMCR_SPEED1000 | BMCR_FULLDPLX;\n\t\t\t\tbnx2_write_phy(bp, bp->mii_bmcr, bmcr);\n\t\t\t\tbp->phy_flags |= BNX2_PHY_FLAG_PARALLEL_DETECT;\n\t\t\t}\n\t\t}\n\t}\n\telse if ((bp->link_up) && (bp->autoneg & AUTONEG_SPEED) &&\n\t\t (bp->phy_flags & BNX2_PHY_FLAG_PARALLEL_DETECT)) {\n\t\tu32 phy2;\n\n\t\tbnx2_write_phy(bp, 0x17, 0x0f01);\n\t\tbnx2_read_phy(bp, 0x15, &phy2);\n\t\tif (phy2 & 0x20) {\n\t\t\tu32 bmcr;\n\n\t\t\tbnx2_read_phy(bp, bp->mii_bmcr, &bmcr);\n\t\t\tbmcr |= BMCR_ANENABLE;\n\t\t\tbnx2_write_phy(bp, bp->mii_bmcr, bmcr);\n\n\t\t\tbp->phy_flags &= ~BNX2_PHY_FLAG_PARALLEL_DETECT;\n\t\t}\n\t} else\n\t\tbp->current_interval = BNX2_TIMER_INTERVAL;\n\n\tif (check_link) {\n\t\tu32 val;\n\n\t\tbnx2_write_phy(bp, MII_BNX2_MISC_SHADOW, MISC_SHDW_AN_DBG);\n\t\tbnx2_read_phy(bp, MII_BNX2_MISC_SHADOW, &val);\n\t\tbnx2_read_phy(bp, MII_BNX2_MISC_SHADOW, &val);\n\n\t\tif (bp->link_up && (val & MISC_SHDW_AN_DBG_NOSYNC)) {\n\t\t\tif (!(bp->phy_flags & BNX2_PHY_FLAG_FORCED_DOWN)) {\n\t\t\t\tbnx2_5706s_force_link_dn(bp, 1);\n\t\t\t\tbp->phy_flags |= BNX2_PHY_FLAG_FORCED_DOWN;\n\t\t\t} else\n\t\t\t\tbnx2_set_link(bp);\n\t\t} else if (!bp->link_up && !(val & MISC_SHDW_AN_DBG_NOSYNC))\n\t\t\tbnx2_set_link(bp);\n\t}\n\tspin_unlock(&bp->phy_lock);\n}\n\nstatic void\nbnx2_5708_serdes_timer(struct bnx2 *bp)\n{\n\tif (bp->phy_flags & BNX2_PHY_FLAG_REMOTE_PHY_CAP)\n\t\treturn;\n\n\tif ((bp->phy_flags & BNX2_PHY_FLAG_2_5G_CAPABLE) == 0) {\n\t\tbp->serdes_an_pending = 0;\n\t\treturn;\n\t}\n\n\tspin_lock(&bp->phy_lock);\n\tif (bp->serdes_an_pending)\n\t\tbp->serdes_an_pending--;\n\telse if ((bp->link_up == 0) && (bp->autoneg & AUTONEG_SPEED)) {\n\t\tu32 bmcr;\n\n\t\tbnx2_read_phy(bp, bp->mii_bmcr, &bmcr);\n\t\tif (bmcr & BMCR_ANENABLE) {\n\t\t\tbnx2_enable_forced_2g5(bp);\n\t\t\tbp->current_interval = BNX2_SERDES_FORCED_TIMEOUT;\n\t\t} else {\n\t\t\tbnx2_disable_forced_2g5(bp);\n\t\t\tbp->serdes_an_pending = 2;\n\t\t\tbp->current_interval = BNX2_TIMER_INTERVAL;\n\t\t}\n\n\t} else\n\t\tbp->current_interval = BNX2_TIMER_INTERVAL;\n\n\tspin_unlock(&bp->phy_lock);\n}\n\nstatic void\nbnx2_timer(struct timer_list *t)\n{\n\tstruct bnx2 *bp = from_timer(bp, t, timer);\n\n\tif (!netif_running(bp->dev))\n\t\treturn;\n\n\tif (atomic_read(&bp->intr_sem) != 0)\n\t\tgoto bnx2_restart_timer;\n\n\tif ((bp->flags & (BNX2_FLAG_USING_MSI | BNX2_FLAG_ONE_SHOT_MSI)) ==\n\t     BNX2_FLAG_USING_MSI)\n\t\tbnx2_chk_missed_msi(bp);\n\n\tbnx2_send_heart_beat(bp);\n\n\tbp->stats_blk->stat_FwRxDrop =\n\t\tbnx2_reg_rd_ind(bp, BNX2_FW_RX_DROP_COUNT);\n\n\t \n\tif ((bp->flags & BNX2_FLAG_BROKEN_STATS) && bp->stats_ticks)\n\t\tBNX2_WR(bp, BNX2_HC_COMMAND, bp->hc_cmd |\n\t\t\tBNX2_HC_COMMAND_STATS_NOW);\n\n\tif (bp->phy_flags & BNX2_PHY_FLAG_SERDES) {\n\t\tif (BNX2_CHIP(bp) == BNX2_CHIP_5706)\n\t\t\tbnx2_5706_serdes_timer(bp);\n\t\telse\n\t\t\tbnx2_5708_serdes_timer(bp);\n\t}\n\nbnx2_restart_timer:\n\tmod_timer(&bp->timer, jiffies + bp->current_interval);\n}\n\nstatic int\nbnx2_request_irq(struct bnx2 *bp)\n{\n\tunsigned long flags;\n\tstruct bnx2_irq *irq;\n\tint rc = 0, i;\n\n\tif (bp->flags & BNX2_FLAG_USING_MSI_OR_MSIX)\n\t\tflags = 0;\n\telse\n\t\tflags = IRQF_SHARED;\n\n\tfor (i = 0; i < bp->irq_nvecs; i++) {\n\t\tirq = &bp->irq_tbl[i];\n\t\trc = request_irq(irq->vector, irq->handler, flags, irq->name,\n\t\t\t\t &bp->bnx2_napi[i]);\n\t\tif (rc)\n\t\t\tbreak;\n\t\tirq->requested = 1;\n\t}\n\treturn rc;\n}\n\nstatic void\n__bnx2_free_irq(struct bnx2 *bp)\n{\n\tstruct bnx2_irq *irq;\n\tint i;\n\n\tfor (i = 0; i < bp->irq_nvecs; i++) {\n\t\tirq = &bp->irq_tbl[i];\n\t\tif (irq->requested)\n\t\t\tfree_irq(irq->vector, &bp->bnx2_napi[i]);\n\t\tirq->requested = 0;\n\t}\n}\n\nstatic void\nbnx2_free_irq(struct bnx2 *bp)\n{\n\n\t__bnx2_free_irq(bp);\n\tif (bp->flags & BNX2_FLAG_USING_MSI)\n\t\tpci_disable_msi(bp->pdev);\n\telse if (bp->flags & BNX2_FLAG_USING_MSIX)\n\t\tpci_disable_msix(bp->pdev);\n\n\tbp->flags &= ~(BNX2_FLAG_USING_MSI_OR_MSIX | BNX2_FLAG_ONE_SHOT_MSI);\n}\n\nstatic void\nbnx2_enable_msix(struct bnx2 *bp, int msix_vecs)\n{\n\tint i, total_vecs;\n\tstruct msix_entry msix_ent[BNX2_MAX_MSIX_VEC];\n\tstruct net_device *dev = bp->dev;\n\tconst int len = sizeof(bp->irq_tbl[0].name);\n\n\tbnx2_setup_msix_tbl(bp);\n\tBNX2_WR(bp, BNX2_PCI_MSIX_CONTROL, BNX2_MAX_MSIX_HW_VEC - 1);\n\tBNX2_WR(bp, BNX2_PCI_MSIX_TBL_OFF_BIR, BNX2_PCI_GRC_WINDOW2_BASE);\n\tBNX2_WR(bp, BNX2_PCI_MSIX_PBA_OFF_BIT, BNX2_PCI_GRC_WINDOW3_BASE);\n\n\t \n\tBNX2_RD(bp, BNX2_PCI_MSIX_CONTROL);\n\n\tfor (i = 0; i < BNX2_MAX_MSIX_VEC; i++) {\n\t\tmsix_ent[i].entry = i;\n\t\tmsix_ent[i].vector = 0;\n\t}\n\n\ttotal_vecs = msix_vecs;\n#ifdef BCM_CNIC\n\ttotal_vecs++;\n#endif\n\ttotal_vecs = pci_enable_msix_range(bp->pdev, msix_ent,\n\t\t\t\t\t   BNX2_MIN_MSIX_VEC, total_vecs);\n\tif (total_vecs < 0)\n\t\treturn;\n\n\tmsix_vecs = total_vecs;\n#ifdef BCM_CNIC\n\tmsix_vecs--;\n#endif\n\tbp->irq_nvecs = msix_vecs;\n\tbp->flags |= BNX2_FLAG_USING_MSIX | BNX2_FLAG_ONE_SHOT_MSI;\n\tfor (i = 0; i < total_vecs; i++) {\n\t\tbp->irq_tbl[i].vector = msix_ent[i].vector;\n\t\tsnprintf(bp->irq_tbl[i].name, len, \"%s-%d\", dev->name, i);\n\t\tbp->irq_tbl[i].handler = bnx2_msi_1shot;\n\t}\n}\n\nstatic int\nbnx2_setup_int_mode(struct bnx2 *bp, int dis_msi)\n{\n\tint cpus = netif_get_num_default_rss_queues();\n\tint msix_vecs;\n\n\tif (!bp->num_req_rx_rings)\n\t\tmsix_vecs = max(cpus + 1, bp->num_req_tx_rings);\n\telse if (!bp->num_req_tx_rings)\n\t\tmsix_vecs = max(cpus, bp->num_req_rx_rings);\n\telse\n\t\tmsix_vecs = max(bp->num_req_rx_rings, bp->num_req_tx_rings);\n\n\tmsix_vecs = min(msix_vecs, RX_MAX_RINGS);\n\n\tbp->irq_tbl[0].handler = bnx2_interrupt;\n\tstrcpy(bp->irq_tbl[0].name, bp->dev->name);\n\tbp->irq_nvecs = 1;\n\tbp->irq_tbl[0].vector = bp->pdev->irq;\n\n\tif ((bp->flags & BNX2_FLAG_MSIX_CAP) && !dis_msi)\n\t\tbnx2_enable_msix(bp, msix_vecs);\n\n\tif ((bp->flags & BNX2_FLAG_MSI_CAP) && !dis_msi &&\n\t    !(bp->flags & BNX2_FLAG_USING_MSIX)) {\n\t\tif (pci_enable_msi(bp->pdev) == 0) {\n\t\t\tbp->flags |= BNX2_FLAG_USING_MSI;\n\t\t\tif (BNX2_CHIP(bp) == BNX2_CHIP_5709) {\n\t\t\t\tbp->flags |= BNX2_FLAG_ONE_SHOT_MSI;\n\t\t\t\tbp->irq_tbl[0].handler = bnx2_msi_1shot;\n\t\t\t} else\n\t\t\t\tbp->irq_tbl[0].handler = bnx2_msi;\n\n\t\t\tbp->irq_tbl[0].vector = bp->pdev->irq;\n\t\t}\n\t}\n\n\tif (!bp->num_req_tx_rings)\n\t\tbp->num_tx_rings = rounddown_pow_of_two(bp->irq_nvecs);\n\telse\n\t\tbp->num_tx_rings = min(bp->irq_nvecs, bp->num_req_tx_rings);\n\n\tif (!bp->num_req_rx_rings)\n\t\tbp->num_rx_rings = bp->irq_nvecs;\n\telse\n\t\tbp->num_rx_rings = min(bp->irq_nvecs, bp->num_req_rx_rings);\n\n\tnetif_set_real_num_tx_queues(bp->dev, bp->num_tx_rings);\n\n\treturn netif_set_real_num_rx_queues(bp->dev, bp->num_rx_rings);\n}\n\n \nstatic int\nbnx2_open(struct net_device *dev)\n{\n\tstruct bnx2 *bp = netdev_priv(dev);\n\tint rc;\n\n\trc = bnx2_request_firmware(bp);\n\tif (rc < 0)\n\t\tgoto out;\n\n\tnetif_carrier_off(dev);\n\n\tbnx2_disable_int(bp);\n\n\trc = bnx2_setup_int_mode(bp, disable_msi);\n\tif (rc)\n\t\tgoto open_err;\n\tbnx2_init_napi(bp);\n\tbnx2_napi_enable(bp);\n\trc = bnx2_alloc_mem(bp);\n\tif (rc)\n\t\tgoto open_err;\n\n\trc = bnx2_request_irq(bp);\n\tif (rc)\n\t\tgoto open_err;\n\n\trc = bnx2_init_nic(bp, 1);\n\tif (rc)\n\t\tgoto open_err;\n\n\tmod_timer(&bp->timer, jiffies + bp->current_interval);\n\n\tatomic_set(&bp->intr_sem, 0);\n\n\tmemset(bp->temp_stats_blk, 0, sizeof(struct statistics_block));\n\n\tbnx2_enable_int(bp);\n\n\tif (bp->flags & BNX2_FLAG_USING_MSI) {\n\t\t \n\t\tif (bnx2_test_intr(bp) != 0) {\n\t\t\tnetdev_warn(bp->dev, \"No interrupt was generated using MSI, switching to INTx mode. Please report this failure to the PCI maintainer and include system chipset information.\\n\");\n\n\t\t\tbnx2_disable_int(bp);\n\t\t\tbnx2_free_irq(bp);\n\n\t\t\tbnx2_setup_int_mode(bp, 1);\n\n\t\t\trc = bnx2_init_nic(bp, 0);\n\n\t\t\tif (!rc)\n\t\t\t\trc = bnx2_request_irq(bp);\n\n\t\t\tif (rc) {\n\t\t\t\tdel_timer_sync(&bp->timer);\n\t\t\t\tgoto open_err;\n\t\t\t}\n\t\t\tbnx2_enable_int(bp);\n\t\t}\n\t}\n\tif (bp->flags & BNX2_FLAG_USING_MSI)\n\t\tnetdev_info(dev, \"using MSI\\n\");\n\telse if (bp->flags & BNX2_FLAG_USING_MSIX)\n\t\tnetdev_info(dev, \"using MSIX\\n\");\n\n\tnetif_tx_start_all_queues(dev);\nout:\n\treturn rc;\n\nopen_err:\n\tbnx2_napi_disable(bp);\n\tbnx2_free_skbs(bp);\n\tbnx2_free_irq(bp);\n\tbnx2_free_mem(bp);\n\tbnx2_del_napi(bp);\n\tbnx2_release_firmware(bp);\n\tgoto out;\n}\n\nstatic void\nbnx2_reset_task(struct work_struct *work)\n{\n\tstruct bnx2 *bp = container_of(work, struct bnx2, reset_task);\n\tint rc;\n\tu16 pcicmd;\n\n\trtnl_lock();\n\tif (!netif_running(bp->dev)) {\n\t\trtnl_unlock();\n\t\treturn;\n\t}\n\n\tbnx2_netif_stop(bp, true);\n\n\tpci_read_config_word(bp->pdev, PCI_COMMAND, &pcicmd);\n\tif (!(pcicmd & PCI_COMMAND_MEMORY)) {\n\t\t \n\t\tpci_restore_state(bp->pdev);\n\t\tpci_save_state(bp->pdev);\n\t}\n\trc = bnx2_init_nic(bp, 1);\n\tif (rc) {\n\t\tnetdev_err(bp->dev, \"failed to reset NIC, closing\\n\");\n\t\tbnx2_napi_enable(bp);\n\t\tdev_close(bp->dev);\n\t\trtnl_unlock();\n\t\treturn;\n\t}\n\n\tatomic_set(&bp->intr_sem, 1);\n\tbnx2_netif_start(bp, true);\n\trtnl_unlock();\n}\n\n#define BNX2_FTQ_ENTRY(ftq) { __stringify(ftq##FTQ_CTL), BNX2_##ftq##FTQ_CTL }\n\nstatic void\nbnx2_dump_ftq(struct bnx2 *bp)\n{\n\tint i;\n\tu32 reg, bdidx, cid, valid;\n\tstruct net_device *dev = bp->dev;\n\tstatic const struct ftq_reg {\n\t\tchar *name;\n\t\tu32 off;\n\t} ftq_arr[] = {\n\t\tBNX2_FTQ_ENTRY(RV2P_P),\n\t\tBNX2_FTQ_ENTRY(RV2P_T),\n\t\tBNX2_FTQ_ENTRY(RV2P_M),\n\t\tBNX2_FTQ_ENTRY(TBDR_),\n\t\tBNX2_FTQ_ENTRY(TDMA_),\n\t\tBNX2_FTQ_ENTRY(TXP_),\n\t\tBNX2_FTQ_ENTRY(TXP_),\n\t\tBNX2_FTQ_ENTRY(TPAT_),\n\t\tBNX2_FTQ_ENTRY(RXP_C),\n\t\tBNX2_FTQ_ENTRY(RXP_),\n\t\tBNX2_FTQ_ENTRY(COM_COMXQ_),\n\t\tBNX2_FTQ_ENTRY(COM_COMTQ_),\n\t\tBNX2_FTQ_ENTRY(COM_COMQ_),\n\t\tBNX2_FTQ_ENTRY(CP_CPQ_),\n\t};\n\n\tnetdev_err(dev, \"<--- start FTQ dump --->\\n\");\n\tfor (i = 0; i < ARRAY_SIZE(ftq_arr); i++)\n\t\tnetdev_err(dev, \"%s %08x\\n\", ftq_arr[i].name,\n\t\t\t   bnx2_reg_rd_ind(bp, ftq_arr[i].off));\n\n\tnetdev_err(dev, \"CPU states:\\n\");\n\tfor (reg = BNX2_TXP_CPU_MODE; reg <= BNX2_CP_CPU_MODE; reg += 0x40000)\n\t\tnetdev_err(dev, \"%06x mode %x state %x evt_mask %x pc %x pc %x instr %x\\n\",\n\t\t\t   reg, bnx2_reg_rd_ind(bp, reg),\n\t\t\t   bnx2_reg_rd_ind(bp, reg + 4),\n\t\t\t   bnx2_reg_rd_ind(bp, reg + 8),\n\t\t\t   bnx2_reg_rd_ind(bp, reg + 0x1c),\n\t\t\t   bnx2_reg_rd_ind(bp, reg + 0x1c),\n\t\t\t   bnx2_reg_rd_ind(bp, reg + 0x20));\n\n\tnetdev_err(dev, \"<--- end FTQ dump --->\\n\");\n\tnetdev_err(dev, \"<--- start TBDC dump --->\\n\");\n\tnetdev_err(dev, \"TBDC free cnt: %ld\\n\",\n\t\t   BNX2_RD(bp, BNX2_TBDC_STATUS) & BNX2_TBDC_STATUS_FREE_CNT);\n\tnetdev_err(dev, \"LINE     CID  BIDX   CMD  VALIDS\\n\");\n\tfor (i = 0; i < 0x20; i++) {\n\t\tint j = 0;\n\n\t\tBNX2_WR(bp, BNX2_TBDC_BD_ADDR, i);\n\t\tBNX2_WR(bp, BNX2_TBDC_CAM_OPCODE,\n\t\t\tBNX2_TBDC_CAM_OPCODE_OPCODE_CAM_READ);\n\t\tBNX2_WR(bp, BNX2_TBDC_COMMAND, BNX2_TBDC_COMMAND_CMD_REG_ARB);\n\t\twhile ((BNX2_RD(bp, BNX2_TBDC_COMMAND) &\n\t\t\tBNX2_TBDC_COMMAND_CMD_REG_ARB) && j < 100)\n\t\t\tj++;\n\n\t\tcid = BNX2_RD(bp, BNX2_TBDC_CID);\n\t\tbdidx = BNX2_RD(bp, BNX2_TBDC_BIDX);\n\t\tvalid = BNX2_RD(bp, BNX2_TBDC_CAM_OPCODE);\n\t\tnetdev_err(dev, \"%02x    %06x  %04lx   %02x    [%x]\\n\",\n\t\t\t   i, cid, bdidx & BNX2_TBDC_BDIDX_BDIDX,\n\t\t\t   bdidx >> 24, (valid >> 8) & 0x0ff);\n\t}\n\tnetdev_err(dev, \"<--- end TBDC dump --->\\n\");\n}\n\nstatic void\nbnx2_dump_state(struct bnx2 *bp)\n{\n\tstruct net_device *dev = bp->dev;\n\tu32 val1, val2;\n\n\tpci_read_config_dword(bp->pdev, PCI_COMMAND, &val1);\n\tnetdev_err(dev, \"DEBUG: intr_sem[%x] PCI_CMD[%08x]\\n\",\n\t\t   atomic_read(&bp->intr_sem), val1);\n\tpci_read_config_dword(bp->pdev, bp->pm_cap + PCI_PM_CTRL, &val1);\n\tpci_read_config_dword(bp->pdev, BNX2_PCICFG_MISC_CONFIG, &val2);\n\tnetdev_err(dev, \"DEBUG: PCI_PM[%08x] PCI_MISC_CFG[%08x]\\n\", val1, val2);\n\tnetdev_err(dev, \"DEBUG: EMAC_TX_STATUS[%08x] EMAC_RX_STATUS[%08x]\\n\",\n\t\t   BNX2_RD(bp, BNX2_EMAC_TX_STATUS),\n\t\t   BNX2_RD(bp, BNX2_EMAC_RX_STATUS));\n\tnetdev_err(dev, \"DEBUG: RPM_MGMT_PKT_CTRL[%08x]\\n\",\n\t\t   BNX2_RD(bp, BNX2_RPM_MGMT_PKT_CTRL));\n\tnetdev_err(dev, \"DEBUG: HC_STATS_INTERRUPT_STATUS[%08x]\\n\",\n\t\t   BNX2_RD(bp, BNX2_HC_STATS_INTERRUPT_STATUS));\n\tif (bp->flags & BNX2_FLAG_USING_MSIX)\n\t\tnetdev_err(dev, \"DEBUG: PBA[%08x]\\n\",\n\t\t\t   BNX2_RD(bp, BNX2_PCI_GRC_WINDOW3_BASE));\n}\n\nstatic void\nbnx2_tx_timeout(struct net_device *dev, unsigned int txqueue)\n{\n\tstruct bnx2 *bp = netdev_priv(dev);\n\n\tbnx2_dump_ftq(bp);\n\tbnx2_dump_state(bp);\n\tbnx2_dump_mcp_state(bp);\n\n\t \n\tschedule_work(&bp->reset_task);\n}\n\n \nstatic netdev_tx_t\nbnx2_start_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct bnx2 *bp = netdev_priv(dev);\n\tdma_addr_t mapping;\n\tstruct bnx2_tx_bd *txbd;\n\tstruct bnx2_sw_tx_bd *tx_buf;\n\tu32 len, vlan_tag_flags, last_frag, mss;\n\tu16 prod, ring_prod;\n\tint i;\n\tstruct bnx2_napi *bnapi;\n\tstruct bnx2_tx_ring_info *txr;\n\tstruct netdev_queue *txq;\n\n\t \n\ti = skb_get_queue_mapping(skb);\n\tbnapi = &bp->bnx2_napi[i];\n\ttxr = &bnapi->tx_ring;\n\ttxq = netdev_get_tx_queue(dev, i);\n\n\tif (unlikely(bnx2_tx_avail(bp, txr) <\n\t    (skb_shinfo(skb)->nr_frags + 1))) {\n\t\tnetif_tx_stop_queue(txq);\n\t\tnetdev_err(dev, \"BUG! Tx ring full when queue awake!\\n\");\n\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\tlen = skb_headlen(skb);\n\tprod = txr->tx_prod;\n\tring_prod = BNX2_TX_RING_IDX(prod);\n\n\tvlan_tag_flags = 0;\n\tif (skb->ip_summed == CHECKSUM_PARTIAL) {\n\t\tvlan_tag_flags |= TX_BD_FLAGS_TCP_UDP_CKSUM;\n\t}\n\n\tif (skb_vlan_tag_present(skb)) {\n\t\tvlan_tag_flags |=\n\t\t\t(TX_BD_FLAGS_VLAN_TAG | (skb_vlan_tag_get(skb) << 16));\n\t}\n\n\tif ((mss = skb_shinfo(skb)->gso_size)) {\n\t\tu32 tcp_opt_len;\n\t\tstruct iphdr *iph;\n\n\t\tvlan_tag_flags |= TX_BD_FLAGS_SW_LSO;\n\n\t\ttcp_opt_len = tcp_optlen(skb);\n\n\t\tif (skb_shinfo(skb)->gso_type & SKB_GSO_TCPV6) {\n\t\t\tu32 tcp_off = skb_transport_offset(skb) -\n\t\t\t\t      sizeof(struct ipv6hdr) - ETH_HLEN;\n\n\t\t\tvlan_tag_flags |= ((tcp_opt_len >> 2) << 8) |\n\t\t\t\t\t  TX_BD_FLAGS_SW_FLAGS;\n\t\t\tif (likely(tcp_off == 0))\n\t\t\t\tvlan_tag_flags &= ~TX_BD_FLAGS_TCP6_OFF0_MSK;\n\t\t\telse {\n\t\t\t\ttcp_off >>= 3;\n\t\t\t\tvlan_tag_flags |= ((tcp_off & 0x3) <<\n\t\t\t\t\t\t   TX_BD_FLAGS_TCP6_OFF0_SHL) |\n\t\t\t\t\t\t  ((tcp_off & 0x10) <<\n\t\t\t\t\t\t   TX_BD_FLAGS_TCP6_OFF4_SHL);\n\t\t\t\tmss |= (tcp_off & 0xc) << TX_BD_TCP6_OFF2_SHL;\n\t\t\t}\n\t\t} else {\n\t\t\tiph = ip_hdr(skb);\n\t\t\tif (tcp_opt_len || (iph->ihl > 5)) {\n\t\t\t\tvlan_tag_flags |= ((iph->ihl - 5) +\n\t\t\t\t\t\t   (tcp_opt_len >> 2)) << 8;\n\t\t\t}\n\t\t}\n\t} else\n\t\tmss = 0;\n\n\tmapping = dma_map_single(&bp->pdev->dev, skb->data, len,\n\t\t\t\t DMA_TO_DEVICE);\n\tif (dma_mapping_error(&bp->pdev->dev, mapping)) {\n\t\tdev_kfree_skb_any(skb);\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\ttx_buf = &txr->tx_buf_ring[ring_prod];\n\ttx_buf->skb = skb;\n\tdma_unmap_addr_set(tx_buf, mapping, mapping);\n\n\ttxbd = &txr->tx_desc_ring[ring_prod];\n\n\ttxbd->tx_bd_haddr_hi = (u64) mapping >> 32;\n\ttxbd->tx_bd_haddr_lo = (u64) mapping & 0xffffffff;\n\ttxbd->tx_bd_mss_nbytes = len | (mss << 16);\n\ttxbd->tx_bd_vlan_tag_flags = vlan_tag_flags | TX_BD_FLAGS_START;\n\n\tlast_frag = skb_shinfo(skb)->nr_frags;\n\ttx_buf->nr_frags = last_frag;\n\ttx_buf->is_gso = skb_is_gso(skb);\n\n\tfor (i = 0; i < last_frag; i++) {\n\t\tconst skb_frag_t *frag = &skb_shinfo(skb)->frags[i];\n\n\t\tprod = BNX2_NEXT_TX_BD(prod);\n\t\tring_prod = BNX2_TX_RING_IDX(prod);\n\t\ttxbd = &txr->tx_desc_ring[ring_prod];\n\n\t\tlen = skb_frag_size(frag);\n\t\tmapping = skb_frag_dma_map(&bp->pdev->dev, frag, 0, len,\n\t\t\t\t\t   DMA_TO_DEVICE);\n\t\tif (dma_mapping_error(&bp->pdev->dev, mapping))\n\t\t\tgoto dma_error;\n\t\tdma_unmap_addr_set(&txr->tx_buf_ring[ring_prod], mapping,\n\t\t\t\t   mapping);\n\n\t\ttxbd->tx_bd_haddr_hi = (u64) mapping >> 32;\n\t\ttxbd->tx_bd_haddr_lo = (u64) mapping & 0xffffffff;\n\t\ttxbd->tx_bd_mss_nbytes = len | (mss << 16);\n\t\ttxbd->tx_bd_vlan_tag_flags = vlan_tag_flags;\n\n\t}\n\ttxbd->tx_bd_vlan_tag_flags |= TX_BD_FLAGS_END;\n\n\t \n\twmb();\n\n\tnetdev_tx_sent_queue(txq, skb->len);\n\n\tprod = BNX2_NEXT_TX_BD(prod);\n\ttxr->tx_prod_bseq += skb->len;\n\n\tBNX2_WR16(bp, txr->tx_bidx_addr, prod);\n\tBNX2_WR(bp, txr->tx_bseq_addr, txr->tx_prod_bseq);\n\n\ttxr->tx_prod = prod;\n\n\tif (unlikely(bnx2_tx_avail(bp, txr) <= MAX_SKB_FRAGS)) {\n\t\tnetif_tx_stop_queue(txq);\n\n\t\t \n\t\tsmp_mb();\n\t\tif (bnx2_tx_avail(bp, txr) > bp->tx_wake_thresh)\n\t\t\tnetif_tx_wake_queue(txq);\n\t}\n\n\treturn NETDEV_TX_OK;\ndma_error:\n\t \n\tlast_frag = i;\n\n\t \n\tprod = txr->tx_prod;\n\tring_prod = BNX2_TX_RING_IDX(prod);\n\ttx_buf = &txr->tx_buf_ring[ring_prod];\n\ttx_buf->skb = NULL;\n\tdma_unmap_single(&bp->pdev->dev, dma_unmap_addr(tx_buf, mapping),\n\t\t\t skb_headlen(skb), DMA_TO_DEVICE);\n\n\t \n\tfor (i = 0; i < last_frag; i++) {\n\t\tprod = BNX2_NEXT_TX_BD(prod);\n\t\tring_prod = BNX2_TX_RING_IDX(prod);\n\t\ttx_buf = &txr->tx_buf_ring[ring_prod];\n\t\tdma_unmap_page(&bp->pdev->dev, dma_unmap_addr(tx_buf, mapping),\n\t\t\t       skb_frag_size(&skb_shinfo(skb)->frags[i]),\n\t\t\t       DMA_TO_DEVICE);\n\t}\n\n\tdev_kfree_skb_any(skb);\n\treturn NETDEV_TX_OK;\n}\n\n \nstatic int\nbnx2_close(struct net_device *dev)\n{\n\tstruct bnx2 *bp = netdev_priv(dev);\n\n\tbnx2_disable_int_sync(bp);\n\tbnx2_napi_disable(bp);\n\tnetif_tx_disable(dev);\n\tdel_timer_sync(&bp->timer);\n\tbnx2_shutdown_chip(bp);\n\tbnx2_free_irq(bp);\n\tbnx2_free_skbs(bp);\n\tbnx2_free_mem(bp);\n\tbnx2_del_napi(bp);\n\tbp->link_up = 0;\n\tnetif_carrier_off(bp->dev);\n\treturn 0;\n}\n\nstatic void\nbnx2_save_stats(struct bnx2 *bp)\n{\n\tu32 *hw_stats = (u32 *) bp->stats_blk;\n\tu32 *temp_stats = (u32 *) bp->temp_stats_blk;\n\tint i;\n\n\t \n\tfor (i = 0; i < 20; i += 2) {\n\t\tu32 hi;\n\t\tu64 lo;\n\n\t\thi = temp_stats[i] + hw_stats[i];\n\t\tlo = (u64) temp_stats[i + 1] + (u64) hw_stats[i + 1];\n\t\tif (lo > 0xffffffff)\n\t\t\thi++;\n\t\ttemp_stats[i] = hi;\n\t\ttemp_stats[i + 1] = lo & 0xffffffff;\n\t}\n\n\tfor ( ; i < sizeof(struct statistics_block) / 4; i++)\n\t\ttemp_stats[i] += hw_stats[i];\n}\n\n#define GET_64BIT_NET_STATS64(ctr)\t\t\\\n\t(((u64) (ctr##_hi) << 32) + (u64) (ctr##_lo))\n\n#define GET_64BIT_NET_STATS(ctr)\t\t\t\t\\\n\tGET_64BIT_NET_STATS64(bp->stats_blk->ctr) +\t\t\\\n\tGET_64BIT_NET_STATS64(bp->temp_stats_blk->ctr)\n\n#define GET_32BIT_NET_STATS(ctr)\t\t\t\t\\\n\t(unsigned long) (bp->stats_blk->ctr +\t\t\t\\\n\t\t\t bp->temp_stats_blk->ctr)\n\nstatic void\nbnx2_get_stats64(struct net_device *dev, struct rtnl_link_stats64 *net_stats)\n{\n\tstruct bnx2 *bp = netdev_priv(dev);\n\n\tif (!bp->stats_blk)\n\t\treturn;\n\n\tnet_stats->rx_packets =\n\t\tGET_64BIT_NET_STATS(stat_IfHCInUcastPkts) +\n\t\tGET_64BIT_NET_STATS(stat_IfHCInMulticastPkts) +\n\t\tGET_64BIT_NET_STATS(stat_IfHCInBroadcastPkts);\n\n\tnet_stats->tx_packets =\n\t\tGET_64BIT_NET_STATS(stat_IfHCOutUcastPkts) +\n\t\tGET_64BIT_NET_STATS(stat_IfHCOutMulticastPkts) +\n\t\tGET_64BIT_NET_STATS(stat_IfHCOutBroadcastPkts);\n\n\tnet_stats->rx_bytes =\n\t\tGET_64BIT_NET_STATS(stat_IfHCInOctets);\n\n\tnet_stats->tx_bytes =\n\t\tGET_64BIT_NET_STATS(stat_IfHCOutOctets);\n\n\tnet_stats->multicast =\n\t\tGET_64BIT_NET_STATS(stat_IfHCInMulticastPkts);\n\n\tnet_stats->collisions =\n\t\tGET_32BIT_NET_STATS(stat_EtherStatsCollisions);\n\n\tnet_stats->rx_length_errors =\n\t\tGET_32BIT_NET_STATS(stat_EtherStatsUndersizePkts) +\n\t\tGET_32BIT_NET_STATS(stat_EtherStatsOverrsizePkts);\n\n\tnet_stats->rx_over_errors =\n\t\tGET_32BIT_NET_STATS(stat_IfInFTQDiscards) +\n\t\tGET_32BIT_NET_STATS(stat_IfInMBUFDiscards);\n\n\tnet_stats->rx_frame_errors =\n\t\tGET_32BIT_NET_STATS(stat_Dot3StatsAlignmentErrors);\n\n\tnet_stats->rx_crc_errors =\n\t\tGET_32BIT_NET_STATS(stat_Dot3StatsFCSErrors);\n\n\tnet_stats->rx_errors = net_stats->rx_length_errors +\n\t\tnet_stats->rx_over_errors + net_stats->rx_frame_errors +\n\t\tnet_stats->rx_crc_errors;\n\n\tnet_stats->tx_aborted_errors =\n\t\tGET_32BIT_NET_STATS(stat_Dot3StatsExcessiveCollisions) +\n\t\tGET_32BIT_NET_STATS(stat_Dot3StatsLateCollisions);\n\n\tif ((BNX2_CHIP(bp) == BNX2_CHIP_5706) ||\n\t    (BNX2_CHIP_ID(bp) == BNX2_CHIP_ID_5708_A0))\n\t\tnet_stats->tx_carrier_errors = 0;\n\telse {\n\t\tnet_stats->tx_carrier_errors =\n\t\t\tGET_32BIT_NET_STATS(stat_Dot3StatsCarrierSenseErrors);\n\t}\n\n\tnet_stats->tx_errors =\n\t\tGET_32BIT_NET_STATS(stat_emac_tx_stat_dot3statsinternalmactransmiterrors) +\n\t\tnet_stats->tx_aborted_errors +\n\t\tnet_stats->tx_carrier_errors;\n\n\tnet_stats->rx_missed_errors =\n\t\tGET_32BIT_NET_STATS(stat_IfInFTQDiscards) +\n\t\tGET_32BIT_NET_STATS(stat_IfInMBUFDiscards) +\n\t\tGET_32BIT_NET_STATS(stat_FwRxDrop);\n\n}\n\n \n\nstatic int\nbnx2_get_link_ksettings(struct net_device *dev,\n\t\t\tstruct ethtool_link_ksettings *cmd)\n{\n\tstruct bnx2 *bp = netdev_priv(dev);\n\tint support_serdes = 0, support_copper = 0;\n\tu32 supported, advertising;\n\n\tsupported = SUPPORTED_Autoneg;\n\tif (bp->phy_flags & BNX2_PHY_FLAG_REMOTE_PHY_CAP) {\n\t\tsupport_serdes = 1;\n\t\tsupport_copper = 1;\n\t} else if (bp->phy_port == PORT_FIBRE)\n\t\tsupport_serdes = 1;\n\telse\n\t\tsupport_copper = 1;\n\n\tif (support_serdes) {\n\t\tsupported |= SUPPORTED_1000baseT_Full |\n\t\t\tSUPPORTED_FIBRE;\n\t\tif (bp->phy_flags & BNX2_PHY_FLAG_2_5G_CAPABLE)\n\t\t\tsupported |= SUPPORTED_2500baseX_Full;\n\t}\n\tif (support_copper) {\n\t\tsupported |= SUPPORTED_10baseT_Half |\n\t\t\tSUPPORTED_10baseT_Full |\n\t\t\tSUPPORTED_100baseT_Half |\n\t\t\tSUPPORTED_100baseT_Full |\n\t\t\tSUPPORTED_1000baseT_Full |\n\t\t\tSUPPORTED_TP;\n\t}\n\n\tspin_lock_bh(&bp->phy_lock);\n\tcmd->base.port = bp->phy_port;\n\tadvertising = bp->advertising;\n\n\tif (bp->autoneg & AUTONEG_SPEED) {\n\t\tcmd->base.autoneg = AUTONEG_ENABLE;\n\t} else {\n\t\tcmd->base.autoneg = AUTONEG_DISABLE;\n\t}\n\n\tif (netif_carrier_ok(dev)) {\n\t\tcmd->base.speed = bp->line_speed;\n\t\tcmd->base.duplex = bp->duplex;\n\t\tif (!(bp->phy_flags & BNX2_PHY_FLAG_SERDES)) {\n\t\t\tif (bp->phy_flags & BNX2_PHY_FLAG_MDIX)\n\t\t\t\tcmd->base.eth_tp_mdix = ETH_TP_MDI_X;\n\t\t\telse\n\t\t\t\tcmd->base.eth_tp_mdix = ETH_TP_MDI;\n\t\t}\n\t}\n\telse {\n\t\tcmd->base.speed = SPEED_UNKNOWN;\n\t\tcmd->base.duplex = DUPLEX_UNKNOWN;\n\t}\n\tspin_unlock_bh(&bp->phy_lock);\n\n\tcmd->base.phy_address = bp->phy_addr;\n\n\tethtool_convert_legacy_u32_to_link_mode(cmd->link_modes.supported,\n\t\t\t\t\t\tsupported);\n\tethtool_convert_legacy_u32_to_link_mode(cmd->link_modes.advertising,\n\t\t\t\t\t\tadvertising);\n\n\treturn 0;\n}\n\nstatic int\nbnx2_set_link_ksettings(struct net_device *dev,\n\t\t\tconst struct ethtool_link_ksettings *cmd)\n{\n\tstruct bnx2 *bp = netdev_priv(dev);\n\tu8 autoneg = bp->autoneg;\n\tu8 req_duplex = bp->req_duplex;\n\tu16 req_line_speed = bp->req_line_speed;\n\tu32 advertising = bp->advertising;\n\tint err = -EINVAL;\n\n\tspin_lock_bh(&bp->phy_lock);\n\n\tif (cmd->base.port != PORT_TP && cmd->base.port != PORT_FIBRE)\n\t\tgoto err_out_unlock;\n\n\tif (cmd->base.port != bp->phy_port &&\n\t    !(bp->phy_flags & BNX2_PHY_FLAG_REMOTE_PHY_CAP))\n\t\tgoto err_out_unlock;\n\n\t \n\tif (!netif_running(dev) && cmd->base.port != bp->phy_port)\n\t\tgoto err_out_unlock;\n\n\tif (cmd->base.autoneg == AUTONEG_ENABLE) {\n\t\tautoneg |= AUTONEG_SPEED;\n\n\t\tethtool_convert_link_mode_to_legacy_u32(\n\t\t\t&advertising, cmd->link_modes.advertising);\n\n\t\tif (cmd->base.port == PORT_TP) {\n\t\t\tadvertising &= ETHTOOL_ALL_COPPER_SPEED;\n\t\t\tif (!advertising)\n\t\t\t\tadvertising = ETHTOOL_ALL_COPPER_SPEED;\n\t\t} else {\n\t\t\tadvertising &= ETHTOOL_ALL_FIBRE_SPEED;\n\t\t\tif (!advertising)\n\t\t\t\tadvertising = ETHTOOL_ALL_FIBRE_SPEED;\n\t\t}\n\t\tadvertising |= ADVERTISED_Autoneg;\n\t}\n\telse {\n\t\tu32 speed = cmd->base.speed;\n\n\t\tif (cmd->base.port == PORT_FIBRE) {\n\t\t\tif ((speed != SPEED_1000 &&\n\t\t\t     speed != SPEED_2500) ||\n\t\t\t    (cmd->base.duplex != DUPLEX_FULL))\n\t\t\t\tgoto err_out_unlock;\n\n\t\t\tif (speed == SPEED_2500 &&\n\t\t\t    !(bp->phy_flags & BNX2_PHY_FLAG_2_5G_CAPABLE))\n\t\t\t\tgoto err_out_unlock;\n\t\t} else if (speed == SPEED_1000 || speed == SPEED_2500)\n\t\t\tgoto err_out_unlock;\n\n\t\tautoneg &= ~AUTONEG_SPEED;\n\t\treq_line_speed = speed;\n\t\treq_duplex = cmd->base.duplex;\n\t\tadvertising = 0;\n\t}\n\n\tbp->autoneg = autoneg;\n\tbp->advertising = advertising;\n\tbp->req_line_speed = req_line_speed;\n\tbp->req_duplex = req_duplex;\n\n\terr = 0;\n\t \n\tif (netif_running(dev))\n\t\terr = bnx2_setup_phy(bp, cmd->base.port);\n\nerr_out_unlock:\n\tspin_unlock_bh(&bp->phy_lock);\n\n\treturn err;\n}\n\nstatic void\nbnx2_get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *info)\n{\n\tstruct bnx2 *bp = netdev_priv(dev);\n\n\tstrscpy(info->driver, DRV_MODULE_NAME, sizeof(info->driver));\n\tstrscpy(info->bus_info, pci_name(bp->pdev), sizeof(info->bus_info));\n\tstrscpy(info->fw_version, bp->fw_version, sizeof(info->fw_version));\n}\n\n#define BNX2_REGDUMP_LEN\t\t(32 * 1024)\n\nstatic int\nbnx2_get_regs_len(struct net_device *dev)\n{\n\treturn BNX2_REGDUMP_LEN;\n}\n\nstatic void\nbnx2_get_regs(struct net_device *dev, struct ethtool_regs *regs, void *_p)\n{\n\tu32 *p = _p, i, offset;\n\tu8 *orig_p = _p;\n\tstruct bnx2 *bp = netdev_priv(dev);\n\tstatic const u32 reg_boundaries[] = {\n\t\t0x0000, 0x0098, 0x0400, 0x045c,\n\t\t0x0800, 0x0880, 0x0c00, 0x0c10,\n\t\t0x0c30, 0x0d08, 0x1000, 0x101c,\n\t\t0x1040, 0x1048, 0x1080, 0x10a4,\n\t\t0x1400, 0x1490, 0x1498, 0x14f0,\n\t\t0x1500, 0x155c, 0x1580, 0x15dc,\n\t\t0x1600, 0x1658, 0x1680, 0x16d8,\n\t\t0x1800, 0x1820, 0x1840, 0x1854,\n\t\t0x1880, 0x1894, 0x1900, 0x1984,\n\t\t0x1c00, 0x1c0c, 0x1c40, 0x1c54,\n\t\t0x1c80, 0x1c94, 0x1d00, 0x1d84,\n\t\t0x2000, 0x2030, 0x23c0, 0x2400,\n\t\t0x2800, 0x2820, 0x2830, 0x2850,\n\t\t0x2b40, 0x2c10, 0x2fc0, 0x3058,\n\t\t0x3c00, 0x3c94, 0x4000, 0x4010,\n\t\t0x4080, 0x4090, 0x43c0, 0x4458,\n\t\t0x4c00, 0x4c18, 0x4c40, 0x4c54,\n\t\t0x4fc0, 0x5010, 0x53c0, 0x5444,\n\t\t0x5c00, 0x5c18, 0x5c80, 0x5c90,\n\t\t0x5fc0, 0x6000, 0x6400, 0x6428,\n\t\t0x6800, 0x6848, 0x684c, 0x6860,\n\t\t0x6888, 0x6910, 0x8000\n\t};\n\n\tregs->version = 0;\n\n\tmemset(p, 0, BNX2_REGDUMP_LEN);\n\n\tif (!netif_running(bp->dev))\n\t\treturn;\n\n\ti = 0;\n\toffset = reg_boundaries[0];\n\tp += offset;\n\twhile (offset < BNX2_REGDUMP_LEN) {\n\t\t*p++ = BNX2_RD(bp, offset);\n\t\toffset += 4;\n\t\tif (offset == reg_boundaries[i + 1]) {\n\t\t\toffset = reg_boundaries[i + 2];\n\t\t\tp = (u32 *) (orig_p + offset);\n\t\t\ti += 2;\n\t\t}\n\t}\n}\n\nstatic void\nbnx2_get_wol(struct net_device *dev, struct ethtool_wolinfo *wol)\n{\n\tstruct bnx2 *bp = netdev_priv(dev);\n\n\tif (bp->flags & BNX2_FLAG_NO_WOL) {\n\t\twol->supported = 0;\n\t\twol->wolopts = 0;\n\t}\n\telse {\n\t\twol->supported = WAKE_MAGIC;\n\t\tif (bp->wol)\n\t\t\twol->wolopts = WAKE_MAGIC;\n\t\telse\n\t\t\twol->wolopts = 0;\n\t}\n\tmemset(&wol->sopass, 0, sizeof(wol->sopass));\n}\n\nstatic int\nbnx2_set_wol(struct net_device *dev, struct ethtool_wolinfo *wol)\n{\n\tstruct bnx2 *bp = netdev_priv(dev);\n\n\tif (wol->wolopts & ~WAKE_MAGIC)\n\t\treturn -EINVAL;\n\n\tif (wol->wolopts & WAKE_MAGIC) {\n\t\tif (bp->flags & BNX2_FLAG_NO_WOL)\n\t\t\treturn -EINVAL;\n\n\t\tbp->wol = 1;\n\t}\n\telse {\n\t\tbp->wol = 0;\n\t}\n\n\tdevice_set_wakeup_enable(&bp->pdev->dev, bp->wol);\n\n\treturn 0;\n}\n\nstatic int\nbnx2_nway_reset(struct net_device *dev)\n{\n\tstruct bnx2 *bp = netdev_priv(dev);\n\tu32 bmcr;\n\n\tif (!netif_running(dev))\n\t\treturn -EAGAIN;\n\n\tif (!(bp->autoneg & AUTONEG_SPEED)) {\n\t\treturn -EINVAL;\n\t}\n\n\tspin_lock_bh(&bp->phy_lock);\n\n\tif (bp->phy_flags & BNX2_PHY_FLAG_REMOTE_PHY_CAP) {\n\t\tint rc;\n\n\t\trc = bnx2_setup_remote_phy(bp, bp->phy_port);\n\t\tspin_unlock_bh(&bp->phy_lock);\n\t\treturn rc;\n\t}\n\n\t \n\tif (bp->phy_flags & BNX2_PHY_FLAG_SERDES) {\n\t\tbnx2_write_phy(bp, bp->mii_bmcr, BMCR_LOOPBACK);\n\t\tspin_unlock_bh(&bp->phy_lock);\n\n\t\tmsleep(20);\n\n\t\tspin_lock_bh(&bp->phy_lock);\n\n\t\tbp->current_interval = BNX2_SERDES_AN_TIMEOUT;\n\t\tbp->serdes_an_pending = 1;\n\t\tmod_timer(&bp->timer, jiffies + bp->current_interval);\n\t}\n\n\tbnx2_read_phy(bp, bp->mii_bmcr, &bmcr);\n\tbmcr &= ~BMCR_LOOPBACK;\n\tbnx2_write_phy(bp, bp->mii_bmcr, bmcr | BMCR_ANRESTART | BMCR_ANENABLE);\n\n\tspin_unlock_bh(&bp->phy_lock);\n\n\treturn 0;\n}\n\nstatic u32\nbnx2_get_link(struct net_device *dev)\n{\n\tstruct bnx2 *bp = netdev_priv(dev);\n\n\treturn bp->link_up;\n}\n\nstatic int\nbnx2_get_eeprom_len(struct net_device *dev)\n{\n\tstruct bnx2 *bp = netdev_priv(dev);\n\n\tif (!bp->flash_info)\n\t\treturn 0;\n\n\treturn (int) bp->flash_size;\n}\n\nstatic int\nbnx2_get_eeprom(struct net_device *dev, struct ethtool_eeprom *eeprom,\n\t\tu8 *eebuf)\n{\n\tstruct bnx2 *bp = netdev_priv(dev);\n\tint rc;\n\n\t \n\n\trc = bnx2_nvram_read(bp, eeprom->offset, eebuf, eeprom->len);\n\n\treturn rc;\n}\n\nstatic int\nbnx2_set_eeprom(struct net_device *dev, struct ethtool_eeprom *eeprom,\n\t\tu8 *eebuf)\n{\n\tstruct bnx2 *bp = netdev_priv(dev);\n\tint rc;\n\n\t \n\n\trc = bnx2_nvram_write(bp, eeprom->offset, eebuf, eeprom->len);\n\n\treturn rc;\n}\n\nstatic int bnx2_get_coalesce(struct net_device *dev,\n\t\t\t     struct ethtool_coalesce *coal,\n\t\t\t     struct kernel_ethtool_coalesce *kernel_coal,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct bnx2 *bp = netdev_priv(dev);\n\n\tmemset(coal, 0, sizeof(struct ethtool_coalesce));\n\n\tcoal->rx_coalesce_usecs = bp->rx_ticks;\n\tcoal->rx_max_coalesced_frames = bp->rx_quick_cons_trip;\n\tcoal->rx_coalesce_usecs_irq = bp->rx_ticks_int;\n\tcoal->rx_max_coalesced_frames_irq = bp->rx_quick_cons_trip_int;\n\n\tcoal->tx_coalesce_usecs = bp->tx_ticks;\n\tcoal->tx_max_coalesced_frames = bp->tx_quick_cons_trip;\n\tcoal->tx_coalesce_usecs_irq = bp->tx_ticks_int;\n\tcoal->tx_max_coalesced_frames_irq = bp->tx_quick_cons_trip_int;\n\n\tcoal->stats_block_coalesce_usecs = bp->stats_ticks;\n\n\treturn 0;\n}\n\nstatic int bnx2_set_coalesce(struct net_device *dev,\n\t\t\t     struct ethtool_coalesce *coal,\n\t\t\t     struct kernel_ethtool_coalesce *kernel_coal,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct bnx2 *bp = netdev_priv(dev);\n\n\tbp->rx_ticks = (u16) coal->rx_coalesce_usecs;\n\tif (bp->rx_ticks > 0x3ff) bp->rx_ticks = 0x3ff;\n\n\tbp->rx_quick_cons_trip = (u16) coal->rx_max_coalesced_frames;\n\tif (bp->rx_quick_cons_trip > 0xff) bp->rx_quick_cons_trip = 0xff;\n\n\tbp->rx_ticks_int = (u16) coal->rx_coalesce_usecs_irq;\n\tif (bp->rx_ticks_int > 0x3ff) bp->rx_ticks_int = 0x3ff;\n\n\tbp->rx_quick_cons_trip_int = (u16) coal->rx_max_coalesced_frames_irq;\n\tif (bp->rx_quick_cons_trip_int > 0xff)\n\t\tbp->rx_quick_cons_trip_int = 0xff;\n\n\tbp->tx_ticks = (u16) coal->tx_coalesce_usecs;\n\tif (bp->tx_ticks > 0x3ff) bp->tx_ticks = 0x3ff;\n\n\tbp->tx_quick_cons_trip = (u16) coal->tx_max_coalesced_frames;\n\tif (bp->tx_quick_cons_trip > 0xff) bp->tx_quick_cons_trip = 0xff;\n\n\tbp->tx_ticks_int = (u16) coal->tx_coalesce_usecs_irq;\n\tif (bp->tx_ticks_int > 0x3ff) bp->tx_ticks_int = 0x3ff;\n\n\tbp->tx_quick_cons_trip_int = (u16) coal->tx_max_coalesced_frames_irq;\n\tif (bp->tx_quick_cons_trip_int > 0xff) bp->tx_quick_cons_trip_int =\n\t\t0xff;\n\n\tbp->stats_ticks = coal->stats_block_coalesce_usecs;\n\tif (bp->flags & BNX2_FLAG_BROKEN_STATS) {\n\t\tif (bp->stats_ticks != 0 && bp->stats_ticks != USEC_PER_SEC)\n\t\t\tbp->stats_ticks = USEC_PER_SEC;\n\t}\n\tif (bp->stats_ticks > BNX2_HC_STATS_TICKS_HC_STAT_TICKS)\n\t\tbp->stats_ticks = BNX2_HC_STATS_TICKS_HC_STAT_TICKS;\n\tbp->stats_ticks &= BNX2_HC_STATS_TICKS_HC_STAT_TICKS;\n\n\tif (netif_running(bp->dev)) {\n\t\tbnx2_netif_stop(bp, true);\n\t\tbnx2_init_nic(bp, 0);\n\t\tbnx2_netif_start(bp, true);\n\t}\n\n\treturn 0;\n}\n\nstatic void\nbnx2_get_ringparam(struct net_device *dev, struct ethtool_ringparam *ering,\n\t\t   struct kernel_ethtool_ringparam *kernel_ering,\n\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct bnx2 *bp = netdev_priv(dev);\n\n\tering->rx_max_pending = BNX2_MAX_TOTAL_RX_DESC_CNT;\n\tering->rx_jumbo_max_pending = BNX2_MAX_TOTAL_RX_PG_DESC_CNT;\n\n\tering->rx_pending = bp->rx_ring_size;\n\tering->rx_jumbo_pending = bp->rx_pg_ring_size;\n\n\tering->tx_max_pending = BNX2_MAX_TX_DESC_CNT;\n\tering->tx_pending = bp->tx_ring_size;\n}\n\nstatic int\nbnx2_change_ring_size(struct bnx2 *bp, u32 rx, u32 tx, bool reset_irq)\n{\n\tif (netif_running(bp->dev)) {\n\t\t \n\t\tbnx2_save_stats(bp);\n\n\t\tbnx2_netif_stop(bp, true);\n\t\tbnx2_reset_chip(bp, BNX2_DRV_MSG_CODE_RESET);\n\t\tif (reset_irq) {\n\t\t\tbnx2_free_irq(bp);\n\t\t\tbnx2_del_napi(bp);\n\t\t} else {\n\t\t\t__bnx2_free_irq(bp);\n\t\t}\n\t\tbnx2_free_skbs(bp);\n\t\tbnx2_free_mem(bp);\n\t}\n\n\tbnx2_set_rx_ring_size(bp, rx);\n\tbp->tx_ring_size = tx;\n\n\tif (netif_running(bp->dev)) {\n\t\tint rc = 0;\n\n\t\tif (reset_irq) {\n\t\t\trc = bnx2_setup_int_mode(bp, disable_msi);\n\t\t\tbnx2_init_napi(bp);\n\t\t}\n\n\t\tif (!rc)\n\t\t\trc = bnx2_alloc_mem(bp);\n\n\t\tif (!rc)\n\t\t\trc = bnx2_request_irq(bp);\n\n\t\tif (!rc)\n\t\t\trc = bnx2_init_nic(bp, 0);\n\n\t\tif (rc) {\n\t\t\tbnx2_napi_enable(bp);\n\t\t\tdev_close(bp->dev);\n\t\t\treturn rc;\n\t\t}\n#ifdef BCM_CNIC\n\t\tmutex_lock(&bp->cnic_lock);\n\t\t \n\t\tif (bp->cnic_eth_dev.drv_state & CNIC_DRV_STATE_REGD)\n\t\t\tbnx2_setup_cnic_irq_info(bp);\n\t\tmutex_unlock(&bp->cnic_lock);\n#endif\n\t\tbnx2_netif_start(bp, true);\n\t}\n\treturn 0;\n}\n\nstatic int\nbnx2_set_ringparam(struct net_device *dev, struct ethtool_ringparam *ering,\n\t\t   struct kernel_ethtool_ringparam *kernel_ering,\n\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct bnx2 *bp = netdev_priv(dev);\n\tint rc;\n\n\tif ((ering->rx_pending > BNX2_MAX_TOTAL_RX_DESC_CNT) ||\n\t\t(ering->tx_pending > BNX2_MAX_TX_DESC_CNT) ||\n\t\t(ering->tx_pending <= MAX_SKB_FRAGS)) {\n\n\t\treturn -EINVAL;\n\t}\n\trc = bnx2_change_ring_size(bp, ering->rx_pending, ering->tx_pending,\n\t\t\t\t   false);\n\treturn rc;\n}\n\nstatic void\nbnx2_get_pauseparam(struct net_device *dev, struct ethtool_pauseparam *epause)\n{\n\tstruct bnx2 *bp = netdev_priv(dev);\n\n\tepause->autoneg = ((bp->autoneg & AUTONEG_FLOW_CTRL) != 0);\n\tepause->rx_pause = ((bp->flow_ctrl & FLOW_CTRL_RX) != 0);\n\tepause->tx_pause = ((bp->flow_ctrl & FLOW_CTRL_TX) != 0);\n}\n\nstatic int\nbnx2_set_pauseparam(struct net_device *dev, struct ethtool_pauseparam *epause)\n{\n\tstruct bnx2 *bp = netdev_priv(dev);\n\n\tbp->req_flow_ctrl = 0;\n\tif (epause->rx_pause)\n\t\tbp->req_flow_ctrl |= FLOW_CTRL_RX;\n\tif (epause->tx_pause)\n\t\tbp->req_flow_ctrl |= FLOW_CTRL_TX;\n\n\tif (epause->autoneg) {\n\t\tbp->autoneg |= AUTONEG_FLOW_CTRL;\n\t}\n\telse {\n\t\tbp->autoneg &= ~AUTONEG_FLOW_CTRL;\n\t}\n\n\tif (netif_running(dev)) {\n\t\tspin_lock_bh(&bp->phy_lock);\n\t\tbnx2_setup_phy(bp, bp->phy_port);\n\t\tspin_unlock_bh(&bp->phy_lock);\n\t}\n\n\treturn 0;\n}\n\nstatic struct {\n\tchar string[ETH_GSTRING_LEN];\n} bnx2_stats_str_arr[] = {\n\t{ \"rx_bytes\" },\n\t{ \"rx_error_bytes\" },\n\t{ \"tx_bytes\" },\n\t{ \"tx_error_bytes\" },\n\t{ \"rx_ucast_packets\" },\n\t{ \"rx_mcast_packets\" },\n\t{ \"rx_bcast_packets\" },\n\t{ \"tx_ucast_packets\" },\n\t{ \"tx_mcast_packets\" },\n\t{ \"tx_bcast_packets\" },\n\t{ \"tx_mac_errors\" },\n\t{ \"tx_carrier_errors\" },\n\t{ \"rx_crc_errors\" },\n\t{ \"rx_align_errors\" },\n\t{ \"tx_single_collisions\" },\n\t{ \"tx_multi_collisions\" },\n\t{ \"tx_deferred\" },\n\t{ \"tx_excess_collisions\" },\n\t{ \"tx_late_collisions\" },\n\t{ \"tx_total_collisions\" },\n\t{ \"rx_fragments\" },\n\t{ \"rx_jabbers\" },\n\t{ \"rx_undersize_packets\" },\n\t{ \"rx_oversize_packets\" },\n\t{ \"rx_64_byte_packets\" },\n\t{ \"rx_65_to_127_byte_packets\" },\n\t{ \"rx_128_to_255_byte_packets\" },\n\t{ \"rx_256_to_511_byte_packets\" },\n\t{ \"rx_512_to_1023_byte_packets\" },\n\t{ \"rx_1024_to_1522_byte_packets\" },\n\t{ \"rx_1523_to_9022_byte_packets\" },\n\t{ \"tx_64_byte_packets\" },\n\t{ \"tx_65_to_127_byte_packets\" },\n\t{ \"tx_128_to_255_byte_packets\" },\n\t{ \"tx_256_to_511_byte_packets\" },\n\t{ \"tx_512_to_1023_byte_packets\" },\n\t{ \"tx_1024_to_1522_byte_packets\" },\n\t{ \"tx_1523_to_9022_byte_packets\" },\n\t{ \"rx_xon_frames\" },\n\t{ \"rx_xoff_frames\" },\n\t{ \"tx_xon_frames\" },\n\t{ \"tx_xoff_frames\" },\n\t{ \"rx_mac_ctrl_frames\" },\n\t{ \"rx_filtered_packets\" },\n\t{ \"rx_ftq_discards\" },\n\t{ \"rx_discards\" },\n\t{ \"rx_fw_discards\" },\n};\n\n#define BNX2_NUM_STATS ARRAY_SIZE(bnx2_stats_str_arr)\n\n#define STATS_OFFSET32(offset_name) (offsetof(struct statistics_block, offset_name) / 4)\n\nstatic const unsigned long bnx2_stats_offset_arr[BNX2_NUM_STATS] = {\n    STATS_OFFSET32(stat_IfHCInOctets_hi),\n    STATS_OFFSET32(stat_IfHCInBadOctets_hi),\n    STATS_OFFSET32(stat_IfHCOutOctets_hi),\n    STATS_OFFSET32(stat_IfHCOutBadOctets_hi),\n    STATS_OFFSET32(stat_IfHCInUcastPkts_hi),\n    STATS_OFFSET32(stat_IfHCInMulticastPkts_hi),\n    STATS_OFFSET32(stat_IfHCInBroadcastPkts_hi),\n    STATS_OFFSET32(stat_IfHCOutUcastPkts_hi),\n    STATS_OFFSET32(stat_IfHCOutMulticastPkts_hi),\n    STATS_OFFSET32(stat_IfHCOutBroadcastPkts_hi),\n    STATS_OFFSET32(stat_emac_tx_stat_dot3statsinternalmactransmiterrors),\n    STATS_OFFSET32(stat_Dot3StatsCarrierSenseErrors),\n    STATS_OFFSET32(stat_Dot3StatsFCSErrors),\n    STATS_OFFSET32(stat_Dot3StatsAlignmentErrors),\n    STATS_OFFSET32(stat_Dot3StatsSingleCollisionFrames),\n    STATS_OFFSET32(stat_Dot3StatsMultipleCollisionFrames),\n    STATS_OFFSET32(stat_Dot3StatsDeferredTransmissions),\n    STATS_OFFSET32(stat_Dot3StatsExcessiveCollisions),\n    STATS_OFFSET32(stat_Dot3StatsLateCollisions),\n    STATS_OFFSET32(stat_EtherStatsCollisions),\n    STATS_OFFSET32(stat_EtherStatsFragments),\n    STATS_OFFSET32(stat_EtherStatsJabbers),\n    STATS_OFFSET32(stat_EtherStatsUndersizePkts),\n    STATS_OFFSET32(stat_EtherStatsOverrsizePkts),\n    STATS_OFFSET32(stat_EtherStatsPktsRx64Octets),\n    STATS_OFFSET32(stat_EtherStatsPktsRx65Octetsto127Octets),\n    STATS_OFFSET32(stat_EtherStatsPktsRx128Octetsto255Octets),\n    STATS_OFFSET32(stat_EtherStatsPktsRx256Octetsto511Octets),\n    STATS_OFFSET32(stat_EtherStatsPktsRx512Octetsto1023Octets),\n    STATS_OFFSET32(stat_EtherStatsPktsRx1024Octetsto1522Octets),\n    STATS_OFFSET32(stat_EtherStatsPktsRx1523Octetsto9022Octets),\n    STATS_OFFSET32(stat_EtherStatsPktsTx64Octets),\n    STATS_OFFSET32(stat_EtherStatsPktsTx65Octetsto127Octets),\n    STATS_OFFSET32(stat_EtherStatsPktsTx128Octetsto255Octets),\n    STATS_OFFSET32(stat_EtherStatsPktsTx256Octetsto511Octets),\n    STATS_OFFSET32(stat_EtherStatsPktsTx512Octetsto1023Octets),\n    STATS_OFFSET32(stat_EtherStatsPktsTx1024Octetsto1522Octets),\n    STATS_OFFSET32(stat_EtherStatsPktsTx1523Octetsto9022Octets),\n    STATS_OFFSET32(stat_XonPauseFramesReceived),\n    STATS_OFFSET32(stat_XoffPauseFramesReceived),\n    STATS_OFFSET32(stat_OutXonSent),\n    STATS_OFFSET32(stat_OutXoffSent),\n    STATS_OFFSET32(stat_MacControlFramesReceived),\n    STATS_OFFSET32(stat_IfInFramesL2FilterDiscards),\n    STATS_OFFSET32(stat_IfInFTQDiscards),\n    STATS_OFFSET32(stat_IfInMBUFDiscards),\n    STATS_OFFSET32(stat_FwRxDrop),\n};\n\n \nstatic u8 bnx2_5706_stats_len_arr[BNX2_NUM_STATS] = {\n\t8,0,8,8,8,8,8,8,8,8,\n\t4,0,4,4,4,4,4,4,4,4,\n\t4,4,4,4,4,4,4,4,4,4,\n\t4,4,4,4,4,4,4,4,4,4,\n\t4,4,4,4,4,4,4,\n};\n\nstatic u8 bnx2_5708_stats_len_arr[BNX2_NUM_STATS] = {\n\t8,0,8,8,8,8,8,8,8,8,\n\t4,4,4,4,4,4,4,4,4,4,\n\t4,4,4,4,4,4,4,4,4,4,\n\t4,4,4,4,4,4,4,4,4,4,\n\t4,4,4,4,4,4,4,\n};\n\n#define BNX2_NUM_TESTS 6\n\nstatic struct {\n\tchar string[ETH_GSTRING_LEN];\n} bnx2_tests_str_arr[BNX2_NUM_TESTS] = {\n\t{ \"register_test (offline)\" },\n\t{ \"memory_test (offline)\" },\n\t{ \"loopback_test (offline)\" },\n\t{ \"nvram_test (online)\" },\n\t{ \"interrupt_test (online)\" },\n\t{ \"link_test (online)\" },\n};\n\nstatic int\nbnx2_get_sset_count(struct net_device *dev, int sset)\n{\n\tswitch (sset) {\n\tcase ETH_SS_TEST:\n\t\treturn BNX2_NUM_TESTS;\n\tcase ETH_SS_STATS:\n\t\treturn BNX2_NUM_STATS;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic void\nbnx2_self_test(struct net_device *dev, struct ethtool_test *etest, u64 *buf)\n{\n\tstruct bnx2 *bp = netdev_priv(dev);\n\n\tmemset(buf, 0, sizeof(u64) * BNX2_NUM_TESTS);\n\tif (etest->flags & ETH_TEST_FL_OFFLINE) {\n\t\tint i;\n\n\t\tbnx2_netif_stop(bp, true);\n\t\tbnx2_reset_chip(bp, BNX2_DRV_MSG_CODE_DIAG);\n\t\tbnx2_free_skbs(bp);\n\n\t\tif (bnx2_test_registers(bp) != 0) {\n\t\t\tbuf[0] = 1;\n\t\t\tetest->flags |= ETH_TEST_FL_FAILED;\n\t\t}\n\t\tif (bnx2_test_memory(bp) != 0) {\n\t\t\tbuf[1] = 1;\n\t\t\tetest->flags |= ETH_TEST_FL_FAILED;\n\t\t}\n\t\tif ((buf[2] = bnx2_test_loopback(bp)) != 0)\n\t\t\tetest->flags |= ETH_TEST_FL_FAILED;\n\n\t\tif (!netif_running(bp->dev))\n\t\t\tbnx2_shutdown_chip(bp);\n\t\telse {\n\t\t\tbnx2_init_nic(bp, 1);\n\t\t\tbnx2_netif_start(bp, true);\n\t\t}\n\n\t\t \n\t\tfor (i = 0; i < 7; i++) {\n\t\t\tif (bp->link_up)\n\t\t\t\tbreak;\n\t\t\tmsleep_interruptible(1000);\n\t\t}\n\t}\n\n\tif (bnx2_test_nvram(bp) != 0) {\n\t\tbuf[3] = 1;\n\t\tetest->flags |= ETH_TEST_FL_FAILED;\n\t}\n\tif (bnx2_test_intr(bp) != 0) {\n\t\tbuf[4] = 1;\n\t\tetest->flags |= ETH_TEST_FL_FAILED;\n\t}\n\n\tif (bnx2_test_link(bp) != 0) {\n\t\tbuf[5] = 1;\n\t\tetest->flags |= ETH_TEST_FL_FAILED;\n\n\t}\n}\n\nstatic void\nbnx2_get_strings(struct net_device *dev, u32 stringset, u8 *buf)\n{\n\tswitch (stringset) {\n\tcase ETH_SS_STATS:\n\t\tmemcpy(buf, bnx2_stats_str_arr,\n\t\t\tsizeof(bnx2_stats_str_arr));\n\t\tbreak;\n\tcase ETH_SS_TEST:\n\t\tmemcpy(buf, bnx2_tests_str_arr,\n\t\t\tsizeof(bnx2_tests_str_arr));\n\t\tbreak;\n\t}\n}\n\nstatic void\nbnx2_get_ethtool_stats(struct net_device *dev,\n\t\tstruct ethtool_stats *stats, u64 *buf)\n{\n\tstruct bnx2 *bp = netdev_priv(dev);\n\tint i;\n\tu32 *hw_stats = (u32 *) bp->stats_blk;\n\tu32 *temp_stats = (u32 *) bp->temp_stats_blk;\n\tu8 *stats_len_arr = NULL;\n\n\tif (!hw_stats) {\n\t\tmemset(buf, 0, sizeof(u64) * BNX2_NUM_STATS);\n\t\treturn;\n\t}\n\n\tif ((BNX2_CHIP_ID(bp) == BNX2_CHIP_ID_5706_A0) ||\n\t    (BNX2_CHIP_ID(bp) == BNX2_CHIP_ID_5706_A1) ||\n\t    (BNX2_CHIP_ID(bp) == BNX2_CHIP_ID_5706_A2) ||\n\t    (BNX2_CHIP_ID(bp) == BNX2_CHIP_ID_5708_A0))\n\t\tstats_len_arr = bnx2_5706_stats_len_arr;\n\telse\n\t\tstats_len_arr = bnx2_5708_stats_len_arr;\n\n\tfor (i = 0; i < BNX2_NUM_STATS; i++) {\n\t\tunsigned long offset;\n\n\t\tif (stats_len_arr[i] == 0) {\n\t\t\t \n\t\t\tbuf[i] = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\toffset = bnx2_stats_offset_arr[i];\n\t\tif (stats_len_arr[i] == 4) {\n\t\t\t \n\t\t\tbuf[i] = (u64) *(hw_stats + offset) +\n\t\t\t\t *(temp_stats + offset);\n\t\t\tcontinue;\n\t\t}\n\t\t \n\t\tbuf[i] = (((u64) *(hw_stats + offset)) << 32) +\n\t\t\t *(hw_stats + offset + 1) +\n\t\t\t (((u64) *(temp_stats + offset)) << 32) +\n\t\t\t *(temp_stats + offset + 1);\n\t}\n}\n\nstatic int\nbnx2_set_phys_id(struct net_device *dev, enum ethtool_phys_id_state state)\n{\n\tstruct bnx2 *bp = netdev_priv(dev);\n\n\tswitch (state) {\n\tcase ETHTOOL_ID_ACTIVE:\n\t\tbp->leds_save = BNX2_RD(bp, BNX2_MISC_CFG);\n\t\tBNX2_WR(bp, BNX2_MISC_CFG, BNX2_MISC_CFG_LEDMODE_MAC);\n\t\treturn 1;\t \n\n\tcase ETHTOOL_ID_ON:\n\t\tBNX2_WR(bp, BNX2_EMAC_LED, BNX2_EMAC_LED_OVERRIDE |\n\t\t\tBNX2_EMAC_LED_1000MB_OVERRIDE |\n\t\t\tBNX2_EMAC_LED_100MB_OVERRIDE |\n\t\t\tBNX2_EMAC_LED_10MB_OVERRIDE |\n\t\t\tBNX2_EMAC_LED_TRAFFIC_OVERRIDE |\n\t\t\tBNX2_EMAC_LED_TRAFFIC);\n\t\tbreak;\n\n\tcase ETHTOOL_ID_OFF:\n\t\tBNX2_WR(bp, BNX2_EMAC_LED, BNX2_EMAC_LED_OVERRIDE);\n\t\tbreak;\n\n\tcase ETHTOOL_ID_INACTIVE:\n\t\tBNX2_WR(bp, BNX2_EMAC_LED, 0);\n\t\tBNX2_WR(bp, BNX2_MISC_CFG, bp->leds_save);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nbnx2_set_features(struct net_device *dev, netdev_features_t features)\n{\n\tstruct bnx2 *bp = netdev_priv(dev);\n\n\t \n\tif (features & NETIF_F_HW_VLAN_CTAG_TX)\n\t\tdev->vlan_features |= (dev->hw_features & NETIF_F_ALL_TSO);\n\telse\n\t\tdev->vlan_features &= ~NETIF_F_ALL_TSO;\n\n\tif ((!!(features & NETIF_F_HW_VLAN_CTAG_RX) !=\n\t    !!(bp->rx_mode & BNX2_EMAC_RX_MODE_KEEP_VLAN_TAG)) &&\n\t    netif_running(dev)) {\n\t\tbnx2_netif_stop(bp, false);\n\t\tdev->features = features;\n\t\tbnx2_set_rx_mode(dev);\n\t\tbnx2_fw_sync(bp, BNX2_DRV_MSG_CODE_KEEP_VLAN_UPDATE, 0, 1);\n\t\tbnx2_netif_start(bp, false);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic void bnx2_get_channels(struct net_device *dev,\n\t\t\t      struct ethtool_channels *channels)\n{\n\tstruct bnx2 *bp = netdev_priv(dev);\n\tu32 max_rx_rings = 1;\n\tu32 max_tx_rings = 1;\n\n\tif ((bp->flags & BNX2_FLAG_MSIX_CAP) && !disable_msi) {\n\t\tmax_rx_rings = RX_MAX_RINGS;\n\t\tmax_tx_rings = TX_MAX_RINGS;\n\t}\n\n\tchannels->max_rx = max_rx_rings;\n\tchannels->max_tx = max_tx_rings;\n\tchannels->max_other = 0;\n\tchannels->max_combined = 0;\n\tchannels->rx_count = bp->num_rx_rings;\n\tchannels->tx_count = bp->num_tx_rings;\n\tchannels->other_count = 0;\n\tchannels->combined_count = 0;\n}\n\nstatic int bnx2_set_channels(struct net_device *dev,\n\t\t\t      struct ethtool_channels *channels)\n{\n\tstruct bnx2 *bp = netdev_priv(dev);\n\tu32 max_rx_rings = 1;\n\tu32 max_tx_rings = 1;\n\tint rc = 0;\n\n\tif ((bp->flags & BNX2_FLAG_MSIX_CAP) && !disable_msi) {\n\t\tmax_rx_rings = RX_MAX_RINGS;\n\t\tmax_tx_rings = TX_MAX_RINGS;\n\t}\n\tif (channels->rx_count > max_rx_rings ||\n\t    channels->tx_count > max_tx_rings)\n\t\treturn -EINVAL;\n\n\tbp->num_req_rx_rings = channels->rx_count;\n\tbp->num_req_tx_rings = channels->tx_count;\n\n\tif (netif_running(dev))\n\t\trc = bnx2_change_ring_size(bp, bp->rx_ring_size,\n\t\t\t\t\t   bp->tx_ring_size, true);\n\n\treturn rc;\n}\n\nstatic const struct ethtool_ops bnx2_ethtool_ops = {\n\t.supported_coalesce_params = ETHTOOL_COALESCE_USECS |\n\t\t\t\t     ETHTOOL_COALESCE_MAX_FRAMES |\n\t\t\t\t     ETHTOOL_COALESCE_USECS_IRQ |\n\t\t\t\t     ETHTOOL_COALESCE_MAX_FRAMES_IRQ |\n\t\t\t\t     ETHTOOL_COALESCE_STATS_BLOCK_USECS,\n\t.get_drvinfo\t\t= bnx2_get_drvinfo,\n\t.get_regs_len\t\t= bnx2_get_regs_len,\n\t.get_regs\t\t= bnx2_get_regs,\n\t.get_wol\t\t= bnx2_get_wol,\n\t.set_wol\t\t= bnx2_set_wol,\n\t.nway_reset\t\t= bnx2_nway_reset,\n\t.get_link\t\t= bnx2_get_link,\n\t.get_eeprom_len\t\t= bnx2_get_eeprom_len,\n\t.get_eeprom\t\t= bnx2_get_eeprom,\n\t.set_eeprom\t\t= bnx2_set_eeprom,\n\t.get_coalesce\t\t= bnx2_get_coalesce,\n\t.set_coalesce\t\t= bnx2_set_coalesce,\n\t.get_ringparam\t\t= bnx2_get_ringparam,\n\t.set_ringparam\t\t= bnx2_set_ringparam,\n\t.get_pauseparam\t\t= bnx2_get_pauseparam,\n\t.set_pauseparam\t\t= bnx2_set_pauseparam,\n\t.self_test\t\t= bnx2_self_test,\n\t.get_strings\t\t= bnx2_get_strings,\n\t.set_phys_id\t\t= bnx2_set_phys_id,\n\t.get_ethtool_stats\t= bnx2_get_ethtool_stats,\n\t.get_sset_count\t\t= bnx2_get_sset_count,\n\t.get_channels\t\t= bnx2_get_channels,\n\t.set_channels\t\t= bnx2_set_channels,\n\t.get_link_ksettings\t= bnx2_get_link_ksettings,\n\t.set_link_ksettings\t= bnx2_set_link_ksettings,\n};\n\n \nstatic int\nbnx2_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\n{\n\tstruct mii_ioctl_data *data = if_mii(ifr);\n\tstruct bnx2 *bp = netdev_priv(dev);\n\tint err;\n\n\tswitch(cmd) {\n\tcase SIOCGMIIPHY:\n\t\tdata->phy_id = bp->phy_addr;\n\n\t\tfallthrough;\n\tcase SIOCGMIIREG: {\n\t\tu32 mii_regval;\n\n\t\tif (bp->phy_flags & BNX2_PHY_FLAG_REMOTE_PHY_CAP)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tif (!netif_running(dev))\n\t\t\treturn -EAGAIN;\n\n\t\tspin_lock_bh(&bp->phy_lock);\n\t\terr = bnx2_read_phy(bp, data->reg_num & 0x1f, &mii_regval);\n\t\tspin_unlock_bh(&bp->phy_lock);\n\n\t\tdata->val_out = mii_regval;\n\n\t\treturn err;\n\t}\n\n\tcase SIOCSMIIREG:\n\t\tif (bp->phy_flags & BNX2_PHY_FLAG_REMOTE_PHY_CAP)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tif (!netif_running(dev))\n\t\t\treturn -EAGAIN;\n\n\t\tspin_lock_bh(&bp->phy_lock);\n\t\terr = bnx2_write_phy(bp, data->reg_num & 0x1f, data->val_in);\n\t\tspin_unlock_bh(&bp->phy_lock);\n\n\t\treturn err;\n\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n\treturn -EOPNOTSUPP;\n}\n\n \nstatic int\nbnx2_change_mac_addr(struct net_device *dev, void *p)\n{\n\tstruct sockaddr *addr = p;\n\tstruct bnx2 *bp = netdev_priv(dev);\n\n\tif (!is_valid_ether_addr(addr->sa_data))\n\t\treturn -EADDRNOTAVAIL;\n\n\teth_hw_addr_set(dev, addr->sa_data);\n\tif (netif_running(dev))\n\t\tbnx2_set_mac_addr(bp, bp->dev->dev_addr, 0);\n\n\treturn 0;\n}\n\n \nstatic int\nbnx2_change_mtu(struct net_device *dev, int new_mtu)\n{\n\tstruct bnx2 *bp = netdev_priv(dev);\n\n\tdev->mtu = new_mtu;\n\treturn bnx2_change_ring_size(bp, bp->rx_ring_size, bp->tx_ring_size,\n\t\t\t\t     false);\n}\n\n#ifdef CONFIG_NET_POLL_CONTROLLER\nstatic void\npoll_bnx2(struct net_device *dev)\n{\n\tstruct bnx2 *bp = netdev_priv(dev);\n\tint i;\n\n\tfor (i = 0; i < bp->irq_nvecs; i++) {\n\t\tstruct bnx2_irq *irq = &bp->irq_tbl[i];\n\n\t\tdisable_irq(irq->vector);\n\t\tirq->handler(irq->vector, &bp->bnx2_napi[i]);\n\t\tenable_irq(irq->vector);\n\t}\n}\n#endif\n\nstatic void\nbnx2_get_5709_media(struct bnx2 *bp)\n{\n\tu32 val = BNX2_RD(bp, BNX2_MISC_DUAL_MEDIA_CTRL);\n\tu32 bond_id = val & BNX2_MISC_DUAL_MEDIA_CTRL_BOND_ID;\n\tu32 strap;\n\n\tif (bond_id == BNX2_MISC_DUAL_MEDIA_CTRL_BOND_ID_C)\n\t\treturn;\n\telse if (bond_id == BNX2_MISC_DUAL_MEDIA_CTRL_BOND_ID_S) {\n\t\tbp->phy_flags |= BNX2_PHY_FLAG_SERDES;\n\t\treturn;\n\t}\n\n\tif (val & BNX2_MISC_DUAL_MEDIA_CTRL_STRAP_OVERRIDE)\n\t\tstrap = (val & BNX2_MISC_DUAL_MEDIA_CTRL_PHY_CTRL) >> 21;\n\telse\n\t\tstrap = (val & BNX2_MISC_DUAL_MEDIA_CTRL_PHY_CTRL_STRAP) >> 8;\n\n\tif (bp->func == 0) {\n\t\tswitch (strap) {\n\t\tcase 0x4:\n\t\tcase 0x5:\n\t\tcase 0x6:\n\t\t\tbp->phy_flags |= BNX2_PHY_FLAG_SERDES;\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tswitch (strap) {\n\t\tcase 0x1:\n\t\tcase 0x2:\n\t\tcase 0x4:\n\t\t\tbp->phy_flags |= BNX2_PHY_FLAG_SERDES;\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nstatic void\nbnx2_get_pci_speed(struct bnx2 *bp)\n{\n\tu32 reg;\n\n\treg = BNX2_RD(bp, BNX2_PCICFG_MISC_STATUS);\n\tif (reg & BNX2_PCICFG_MISC_STATUS_PCIX_DET) {\n\t\tu32 clkreg;\n\n\t\tbp->flags |= BNX2_FLAG_PCIX;\n\n\t\tclkreg = BNX2_RD(bp, BNX2_PCICFG_PCI_CLOCK_CONTROL_BITS);\n\n\t\tclkreg &= BNX2_PCICFG_PCI_CLOCK_CONTROL_BITS_PCI_CLK_SPD_DET;\n\t\tswitch (clkreg) {\n\t\tcase BNX2_PCICFG_PCI_CLOCK_CONTROL_BITS_PCI_CLK_SPD_DET_133MHZ:\n\t\t\tbp->bus_speed_mhz = 133;\n\t\t\tbreak;\n\n\t\tcase BNX2_PCICFG_PCI_CLOCK_CONTROL_BITS_PCI_CLK_SPD_DET_95MHZ:\n\t\t\tbp->bus_speed_mhz = 100;\n\t\t\tbreak;\n\n\t\tcase BNX2_PCICFG_PCI_CLOCK_CONTROL_BITS_PCI_CLK_SPD_DET_66MHZ:\n\t\tcase BNX2_PCICFG_PCI_CLOCK_CONTROL_BITS_PCI_CLK_SPD_DET_80MHZ:\n\t\t\tbp->bus_speed_mhz = 66;\n\t\t\tbreak;\n\n\t\tcase BNX2_PCICFG_PCI_CLOCK_CONTROL_BITS_PCI_CLK_SPD_DET_48MHZ:\n\t\tcase BNX2_PCICFG_PCI_CLOCK_CONTROL_BITS_PCI_CLK_SPD_DET_55MHZ:\n\t\t\tbp->bus_speed_mhz = 50;\n\t\t\tbreak;\n\n\t\tcase BNX2_PCICFG_PCI_CLOCK_CONTROL_BITS_PCI_CLK_SPD_DET_LOW:\n\t\tcase BNX2_PCICFG_PCI_CLOCK_CONTROL_BITS_PCI_CLK_SPD_DET_32MHZ:\n\t\tcase BNX2_PCICFG_PCI_CLOCK_CONTROL_BITS_PCI_CLK_SPD_DET_38MHZ:\n\t\t\tbp->bus_speed_mhz = 33;\n\t\t\tbreak;\n\t\t}\n\t}\n\telse {\n\t\tif (reg & BNX2_PCICFG_MISC_STATUS_M66EN)\n\t\t\tbp->bus_speed_mhz = 66;\n\t\telse\n\t\t\tbp->bus_speed_mhz = 33;\n\t}\n\n\tif (reg & BNX2_PCICFG_MISC_STATUS_32BIT_DET)\n\t\tbp->flags |= BNX2_FLAG_PCI_32BIT;\n\n}\n\nstatic void\nbnx2_read_vpd_fw_ver(struct bnx2 *bp)\n{\n\tunsigned int len;\n\tint rc, i, j;\n\tu8 *data;\n\n#define BNX2_VPD_NVRAM_OFFSET\t0x300\n#define BNX2_VPD_LEN\t\t128\n#define BNX2_MAX_VER_SLEN\t30\n\n\tdata = kmalloc(BNX2_VPD_LEN, GFP_KERNEL);\n\tif (!data)\n\t\treturn;\n\n\trc = bnx2_nvram_read(bp, BNX2_VPD_NVRAM_OFFSET, data, BNX2_VPD_LEN);\n\tif (rc)\n\t\tgoto vpd_done;\n\n\tfor (i = 0; i < BNX2_VPD_LEN; i += 4)\n\t\tswab32s((u32 *)&data[i]);\n\n\tj = pci_vpd_find_ro_info_keyword(data, BNX2_VPD_LEN,\n\t\t\t\t\t PCI_VPD_RO_KEYWORD_MFR_ID, &len);\n\tif (j < 0)\n\t\tgoto vpd_done;\n\n\tif (len != 4 || memcmp(&data[j], \"1028\", 4))\n\t\tgoto vpd_done;\n\n\tj = pci_vpd_find_ro_info_keyword(data, BNX2_VPD_LEN,\n\t\t\t\t\t PCI_VPD_RO_KEYWORD_VENDOR0,\n\t\t\t\t\t &len);\n\tif (j < 0)\n\t\tgoto vpd_done;\n\n\tif (len > BNX2_MAX_VER_SLEN)\n\t\tgoto vpd_done;\n\n\tmemcpy(bp->fw_version, &data[j], len);\n\tbp->fw_version[len] = ' ';\n\nvpd_done:\n\tkfree(data);\n}\n\nstatic int\nbnx2_init_board(struct pci_dev *pdev, struct net_device *dev)\n{\n\tstruct bnx2 *bp;\n\tint rc, i, j;\n\tu32 reg;\n\tu64 dma_mask, persist_dma_mask;\n\n\tSET_NETDEV_DEV(dev, &pdev->dev);\n\tbp = netdev_priv(dev);\n\n\tbp->flags = 0;\n\tbp->phy_flags = 0;\n\n\tbp->temp_stats_blk =\n\t\tkzalloc(sizeof(struct statistics_block), GFP_KERNEL);\n\n\tif (!bp->temp_stats_blk) {\n\t\trc = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\n\t \n\trc = pci_enable_device(pdev);\n\tif (rc) {\n\t\tdev_err(&pdev->dev, \"Cannot enable PCI device, aborting\\n\");\n\t\tgoto err_out;\n\t}\n\n\tif (!(pci_resource_flags(pdev, 0) & IORESOURCE_MEM)) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Cannot find PCI device base address, aborting\\n\");\n\t\trc = -ENODEV;\n\t\tgoto err_out_disable;\n\t}\n\n\trc = pci_request_regions(pdev, DRV_MODULE_NAME);\n\tif (rc) {\n\t\tdev_err(&pdev->dev, \"Cannot obtain PCI resources, aborting\\n\");\n\t\tgoto err_out_disable;\n\t}\n\n\tpci_set_master(pdev);\n\n\tbp->pm_cap = pdev->pm_cap;\n\tif (bp->pm_cap == 0) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Cannot find power management capability, aborting\\n\");\n\t\trc = -EIO;\n\t\tgoto err_out_release;\n\t}\n\n\tbp->dev = dev;\n\tbp->pdev = pdev;\n\n\tspin_lock_init(&bp->phy_lock);\n\tspin_lock_init(&bp->indirect_lock);\n#ifdef BCM_CNIC\n\tmutex_init(&bp->cnic_lock);\n#endif\n\tINIT_WORK(&bp->reset_task, bnx2_reset_task);\n\n\tbp->regview = pci_iomap(pdev, 0, MB_GET_CID_ADDR(TX_TSS_CID +\n\t\t\t\t\t\t\t TX_MAX_TSS_RINGS + 1));\n\tif (!bp->regview) {\n\t\tdev_err(&pdev->dev, \"Cannot map register space, aborting\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto err_out_release;\n\t}\n\n\t \n\tBNX2_WR(bp, BNX2_PCICFG_MISC_CONFIG,\n\t\tBNX2_PCICFG_MISC_CONFIG_REG_WINDOW_ENA |\n\t\tBNX2_PCICFG_MISC_CONFIG_TARGET_MB_WORD_SWAP);\n\n\tbp->chip_id = BNX2_RD(bp, BNX2_MISC_ID);\n\n\tif (BNX2_CHIP(bp) == BNX2_CHIP_5709) {\n\t\tif (!pci_is_pcie(pdev)) {\n\t\t\tdev_err(&pdev->dev, \"Not PCIE, aborting\\n\");\n\t\t\trc = -EIO;\n\t\t\tgoto err_out_unmap;\n\t\t}\n\t\tbp->flags |= BNX2_FLAG_PCIE;\n\t\tif (BNX2_CHIP_REV(bp) == BNX2_CHIP_REV_Ax)\n\t\t\tbp->flags |= BNX2_FLAG_JUMBO_BROKEN;\n\t} else {\n\t\tbp->pcix_cap = pci_find_capability(pdev, PCI_CAP_ID_PCIX);\n\t\tif (bp->pcix_cap == 0) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"Cannot find PCIX capability, aborting\\n\");\n\t\t\trc = -EIO;\n\t\t\tgoto err_out_unmap;\n\t\t}\n\t\tbp->flags |= BNX2_FLAG_BROKEN_STATS;\n\t}\n\n\tif (BNX2_CHIP(bp) == BNX2_CHIP_5709 &&\n\t    BNX2_CHIP_REV(bp) != BNX2_CHIP_REV_Ax) {\n\t\tif (pdev->msix_cap)\n\t\t\tbp->flags |= BNX2_FLAG_MSIX_CAP;\n\t}\n\n\tif (BNX2_CHIP_ID(bp) != BNX2_CHIP_ID_5706_A0 &&\n\t    BNX2_CHIP_ID(bp) != BNX2_CHIP_ID_5706_A1) {\n\t\tif (pdev->msi_cap)\n\t\t\tbp->flags |= BNX2_FLAG_MSI_CAP;\n\t}\n\n\t \n\tif (BNX2_CHIP(bp) == BNX2_CHIP_5708)\n\t\tpersist_dma_mask = dma_mask = DMA_BIT_MASK(40);\n\telse\n\t\tpersist_dma_mask = dma_mask = DMA_BIT_MASK(64);\n\n\t \n\tif (dma_set_mask(&pdev->dev, dma_mask) == 0) {\n\t\tdev->features |= NETIF_F_HIGHDMA;\n\t\trc = dma_set_coherent_mask(&pdev->dev, persist_dma_mask);\n\t\tif (rc) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"dma_set_coherent_mask failed, aborting\\n\");\n\t\t\tgoto err_out_unmap;\n\t\t}\n\t} else if ((rc = dma_set_mask(&pdev->dev, DMA_BIT_MASK(32))) != 0) {\n\t\tdev_err(&pdev->dev, \"System does not support DMA, aborting\\n\");\n\t\tgoto err_out_unmap;\n\t}\n\n\tif (!(bp->flags & BNX2_FLAG_PCIE))\n\t\tbnx2_get_pci_speed(bp);\n\n\t \n\tif (BNX2_CHIP_ID(bp) == BNX2_CHIP_ID_5706_A0) {\n\t\treg = BNX2_RD(bp, PCI_COMMAND);\n\t\treg &= ~(PCI_COMMAND_SERR | PCI_COMMAND_PARITY);\n\t\tBNX2_WR(bp, PCI_COMMAND, reg);\n\t} else if ((BNX2_CHIP_ID(bp) == BNX2_CHIP_ID_5706_A1) &&\n\t\t!(bp->flags & BNX2_FLAG_PCIX)) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"5706 A1 can only be used in a PCIX bus, aborting\\n\");\n\t\trc = -EPERM;\n\t\tgoto err_out_unmap;\n\t}\n\n\tbnx2_init_nvram(bp);\n\n\treg = bnx2_reg_rd_ind(bp, BNX2_SHM_HDR_SIGNATURE);\n\n\tif (bnx2_reg_rd_ind(bp, BNX2_MCP_TOE_ID) & BNX2_MCP_TOE_ID_FUNCTION_ID)\n\t\tbp->func = 1;\n\n\tif ((reg & BNX2_SHM_HDR_SIGNATURE_SIG_MASK) ==\n\t    BNX2_SHM_HDR_SIGNATURE_SIG) {\n\t\tu32 off = bp->func << 2;\n\n\t\tbp->shmem_base = bnx2_reg_rd_ind(bp, BNX2_SHM_HDR_ADDR_0 + off);\n\t} else\n\t\tbp->shmem_base = HOST_VIEW_SHMEM_BASE;\n\n\t \n\treg = bnx2_shmem_rd(bp, BNX2_DEV_INFO_SIGNATURE);\n\n\tif ((reg & BNX2_DEV_INFO_SIGNATURE_MAGIC_MASK) !=\n\t    BNX2_DEV_INFO_SIGNATURE_MAGIC) {\n\t\tdev_err(&pdev->dev, \"Firmware not running, aborting\\n\");\n\t\trc = -ENODEV;\n\t\tgoto err_out_unmap;\n\t}\n\n\tbnx2_read_vpd_fw_ver(bp);\n\n\tj = strlen(bp->fw_version);\n\treg = bnx2_shmem_rd(bp, BNX2_DEV_INFO_BC_REV);\n\tfor (i = 0; i < 3 && j < 24; i++) {\n\t\tu8 num, k, skip0;\n\n\t\tif (i == 0) {\n\t\t\tbp->fw_version[j++] = 'b';\n\t\t\tbp->fw_version[j++] = 'c';\n\t\t\tbp->fw_version[j++] = ' ';\n\t\t}\n\t\tnum = (u8) (reg >> (24 - (i * 8)));\n\t\tfor (k = 100, skip0 = 1; k >= 1; num %= k, k /= 10) {\n\t\t\tif (num >= k || !skip0 || k == 1) {\n\t\t\t\tbp->fw_version[j++] = (num / k) + '0';\n\t\t\t\tskip0 = 0;\n\t\t\t}\n\t\t}\n\t\tif (i != 2)\n\t\t\tbp->fw_version[j++] = '.';\n\t}\n\treg = bnx2_shmem_rd(bp, BNX2_PORT_FEATURE);\n\tif (reg & BNX2_PORT_FEATURE_WOL_ENABLED)\n\t\tbp->wol = 1;\n\n\tif (reg & BNX2_PORT_FEATURE_ASF_ENABLED) {\n\t\tbp->flags |= BNX2_FLAG_ASF_ENABLE;\n\n\t\tfor (i = 0; i < 30; i++) {\n\t\t\treg = bnx2_shmem_rd(bp, BNX2_BC_STATE_CONDITION);\n\t\t\tif (reg & BNX2_CONDITION_MFW_RUN_MASK)\n\t\t\t\tbreak;\n\t\t\tmsleep(10);\n\t\t}\n\t}\n\treg = bnx2_shmem_rd(bp, BNX2_BC_STATE_CONDITION);\n\treg &= BNX2_CONDITION_MFW_RUN_MASK;\n\tif (reg != BNX2_CONDITION_MFW_RUN_UNKNOWN &&\n\t    reg != BNX2_CONDITION_MFW_RUN_NONE) {\n\t\tu32 addr = bnx2_shmem_rd(bp, BNX2_MFW_VER_PTR);\n\n\t\tif (j < 32)\n\t\t\tbp->fw_version[j++] = ' ';\n\t\tfor (i = 0; i < 3 && j < 28; i++) {\n\t\t\treg = bnx2_reg_rd_ind(bp, addr + i * 4);\n\t\t\treg = be32_to_cpu(reg);\n\t\t\tmemcpy(&bp->fw_version[j], &reg, 4);\n\t\t\tj += 4;\n\t\t}\n\t}\n\n\treg = bnx2_shmem_rd(bp, BNX2_PORT_HW_CFG_MAC_UPPER);\n\tbp->mac_addr[0] = (u8) (reg >> 8);\n\tbp->mac_addr[1] = (u8) reg;\n\n\treg = bnx2_shmem_rd(bp, BNX2_PORT_HW_CFG_MAC_LOWER);\n\tbp->mac_addr[2] = (u8) (reg >> 24);\n\tbp->mac_addr[3] = (u8) (reg >> 16);\n\tbp->mac_addr[4] = (u8) (reg >> 8);\n\tbp->mac_addr[5] = (u8) reg;\n\n\tbp->tx_ring_size = BNX2_MAX_TX_DESC_CNT;\n\tbnx2_set_rx_ring_size(bp, 255);\n\n\tbp->tx_quick_cons_trip_int = 2;\n\tbp->tx_quick_cons_trip = 20;\n\tbp->tx_ticks_int = 18;\n\tbp->tx_ticks = 80;\n\n\tbp->rx_quick_cons_trip_int = 2;\n\tbp->rx_quick_cons_trip = 12;\n\tbp->rx_ticks_int = 18;\n\tbp->rx_ticks = 18;\n\n\tbp->stats_ticks = USEC_PER_SEC & BNX2_HC_STATS_TICKS_HC_STAT_TICKS;\n\n\tbp->current_interval = BNX2_TIMER_INTERVAL;\n\n\tbp->phy_addr = 1;\n\n\t \n\trc = bnx2_alloc_stats_blk(dev);\n\tif (rc)\n\t\tgoto err_out_unmap;\n\n\t \n\tif (BNX2_CHIP(bp) == BNX2_CHIP_5709)\n\t\tbnx2_get_5709_media(bp);\n\telse if (BNX2_CHIP_BOND(bp) & BNX2_CHIP_BOND_SERDES_BIT)\n\t\tbp->phy_flags |= BNX2_PHY_FLAG_SERDES;\n\n\tbp->phy_port = PORT_TP;\n\tif (bp->phy_flags & BNX2_PHY_FLAG_SERDES) {\n\t\tbp->phy_port = PORT_FIBRE;\n\t\treg = bnx2_shmem_rd(bp, BNX2_SHARED_HW_CFG_CONFIG);\n\t\tif (!(reg & BNX2_SHARED_HW_CFG_GIG_LINK_ON_VAUX)) {\n\t\t\tbp->flags |= BNX2_FLAG_NO_WOL;\n\t\t\tbp->wol = 0;\n\t\t}\n\t\tif (BNX2_CHIP(bp) == BNX2_CHIP_5706) {\n\t\t\t \n\t\t\tif (pdev->subsystem_vendor == PCI_VENDOR_ID_HP &&\n\t\t\t    pdev->subsystem_device == 0x310c)\n\t\t\t\tbp->phy_flags |= BNX2_PHY_FLAG_NO_PARALLEL;\n\t\t} else {\n\t\t\tbp->phy_addr = 2;\n\t\t\tif (reg & BNX2_SHARED_HW_CFG_PHY_2_5G)\n\t\t\t\tbp->phy_flags |= BNX2_PHY_FLAG_2_5G_CAPABLE;\n\t\t}\n\t} else if (BNX2_CHIP(bp) == BNX2_CHIP_5706 ||\n\t\t   BNX2_CHIP(bp) == BNX2_CHIP_5708)\n\t\tbp->phy_flags |= BNX2_PHY_FLAG_CRC_FIX;\n\telse if (BNX2_CHIP(bp) == BNX2_CHIP_5709 &&\n\t\t (BNX2_CHIP_REV(bp) == BNX2_CHIP_REV_Ax ||\n\t\t  BNX2_CHIP_REV(bp) == BNX2_CHIP_REV_Bx))\n\t\tbp->phy_flags |= BNX2_PHY_FLAG_DIS_EARLY_DAC;\n\n\tbnx2_init_fw_cap(bp);\n\n\tif ((BNX2_CHIP_ID(bp) == BNX2_CHIP_ID_5708_A0) ||\n\t    (BNX2_CHIP_ID(bp) == BNX2_CHIP_ID_5708_B0) ||\n\t    (BNX2_CHIP_ID(bp) == BNX2_CHIP_ID_5708_B1) ||\n\t    !(BNX2_RD(bp, BNX2_PCI_CONFIG_3) & BNX2_PCI_CONFIG_3_VAUX_PRESET)) {\n\t\tbp->flags |= BNX2_FLAG_NO_WOL;\n\t\tbp->wol = 0;\n\t}\n\n\tif (bp->flags & BNX2_FLAG_NO_WOL)\n\t\tdevice_set_wakeup_capable(&bp->pdev->dev, false);\n\telse\n\t\tdevice_set_wakeup_enable(&bp->pdev->dev, bp->wol);\n\n\tif (BNX2_CHIP_ID(bp) == BNX2_CHIP_ID_5706_A0) {\n\t\tbp->tx_quick_cons_trip_int =\n\t\t\tbp->tx_quick_cons_trip;\n\t\tbp->tx_ticks_int = bp->tx_ticks;\n\t\tbp->rx_quick_cons_trip_int =\n\t\t\tbp->rx_quick_cons_trip;\n\t\tbp->rx_ticks_int = bp->rx_ticks;\n\t\tbp->comp_prod_trip_int = bp->comp_prod_trip;\n\t\tbp->com_ticks_int = bp->com_ticks;\n\t\tbp->cmd_ticks_int = bp->cmd_ticks;\n\t}\n\n\t \n\tif (BNX2_CHIP(bp) == BNX2_CHIP_5706 && disable_msi == 0) {\n\t\tstruct pci_dev *amd_8132 = NULL;\n\n\t\twhile ((amd_8132 = pci_get_device(PCI_VENDOR_ID_AMD,\n\t\t\t\t\t\t  PCI_DEVICE_ID_AMD_8132_BRIDGE,\n\t\t\t\t\t\t  amd_8132))) {\n\n\t\t\tif (amd_8132->revision >= 0x10 &&\n\t\t\t    amd_8132->revision <= 0x13) {\n\t\t\t\tdisable_msi = 1;\n\t\t\t\tpci_dev_put(amd_8132);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tbnx2_set_default_link(bp);\n\tbp->req_flow_ctrl = FLOW_CTRL_RX | FLOW_CTRL_TX;\n\n\ttimer_setup(&bp->timer, bnx2_timer, 0);\n\tbp->timer.expires = RUN_AT(BNX2_TIMER_INTERVAL);\n\n#ifdef BCM_CNIC\n\tif (bnx2_shmem_rd(bp, BNX2_ISCSI_INITIATOR) & BNX2_ISCSI_INITIATOR_EN)\n\t\tbp->cnic_eth_dev.max_iscsi_conn =\n\t\t\t(bnx2_shmem_rd(bp, BNX2_ISCSI_MAX_CONN) &\n\t\t\t BNX2_ISCSI_MAX_CONN_MASK) >> BNX2_ISCSI_MAX_CONN_SHIFT;\n\tbp->cnic_probe = bnx2_cnic_probe;\n#endif\n\tpci_save_state(pdev);\n\n\treturn 0;\n\nerr_out_unmap:\n\tpci_iounmap(pdev, bp->regview);\n\tbp->regview = NULL;\n\nerr_out_release:\n\tpci_release_regions(pdev);\n\nerr_out_disable:\n\tpci_disable_device(pdev);\n\nerr_out:\n\tkfree(bp->temp_stats_blk);\n\n\treturn rc;\n}\n\nstatic char *\nbnx2_bus_string(struct bnx2 *bp, char *str)\n{\n\tchar *s = str;\n\n\tif (bp->flags & BNX2_FLAG_PCIE) {\n\t\ts += sprintf(s, \"PCI Express\");\n\t} else {\n\t\ts += sprintf(s, \"PCI\");\n\t\tif (bp->flags & BNX2_FLAG_PCIX)\n\t\t\ts += sprintf(s, \"-X\");\n\t\tif (bp->flags & BNX2_FLAG_PCI_32BIT)\n\t\t\ts += sprintf(s, \" 32-bit\");\n\t\telse\n\t\t\ts += sprintf(s, \" 64-bit\");\n\t\ts += sprintf(s, \" %dMHz\", bp->bus_speed_mhz);\n\t}\n\treturn str;\n}\n\nstatic void\nbnx2_del_napi(struct bnx2 *bp)\n{\n\tint i;\n\n\tfor (i = 0; i < bp->irq_nvecs; i++)\n\t\tnetif_napi_del(&bp->bnx2_napi[i].napi);\n}\n\nstatic void\nbnx2_init_napi(struct bnx2 *bp)\n{\n\tint i;\n\n\tfor (i = 0; i < bp->irq_nvecs; i++) {\n\t\tstruct bnx2_napi *bnapi = &bp->bnx2_napi[i];\n\t\tint (*poll)(struct napi_struct *, int);\n\n\t\tif (i == 0)\n\t\t\tpoll = bnx2_poll;\n\t\telse\n\t\t\tpoll = bnx2_poll_msix;\n\n\t\tnetif_napi_add(bp->dev, &bp->bnx2_napi[i].napi, poll);\n\t\tbnapi->bp = bp;\n\t}\n}\n\nstatic const struct net_device_ops bnx2_netdev_ops = {\n\t.ndo_open\t\t= bnx2_open,\n\t.ndo_start_xmit\t\t= bnx2_start_xmit,\n\t.ndo_stop\t\t= bnx2_close,\n\t.ndo_get_stats64\t= bnx2_get_stats64,\n\t.ndo_set_rx_mode\t= bnx2_set_rx_mode,\n\t.ndo_eth_ioctl\t\t= bnx2_ioctl,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_set_mac_address\t= bnx2_change_mac_addr,\n\t.ndo_change_mtu\t\t= bnx2_change_mtu,\n\t.ndo_set_features\t= bnx2_set_features,\n\t.ndo_tx_timeout\t\t= bnx2_tx_timeout,\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\t.ndo_poll_controller\t= poll_bnx2,\n#endif\n};\n\nstatic int\nbnx2_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tstruct net_device *dev;\n\tstruct bnx2 *bp;\n\tint rc;\n\tchar str[40];\n\n\t \n\tdev = alloc_etherdev_mq(sizeof(*bp), TX_MAX_RINGS);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\trc = bnx2_init_board(pdev, dev);\n\tif (rc < 0)\n\t\tgoto err_free;\n\n\tdev->netdev_ops = &bnx2_netdev_ops;\n\tdev->watchdog_timeo = TX_TIMEOUT;\n\tdev->ethtool_ops = &bnx2_ethtool_ops;\n\n\tbp = netdev_priv(dev);\n\n\tpci_set_drvdata(pdev, dev);\n\n\t \n\tif (is_kdump_kernel())\n\t\tbnx2_wait_dma_complete(bp);\n\n\teth_hw_addr_set(dev, bp->mac_addr);\n\n\tdev->hw_features = NETIF_F_IP_CSUM | NETIF_F_SG |\n\t\tNETIF_F_TSO | NETIF_F_TSO_ECN |\n\t\tNETIF_F_RXHASH | NETIF_F_RXCSUM;\n\n\tif (BNX2_CHIP(bp) == BNX2_CHIP_5709)\n\t\tdev->hw_features |= NETIF_F_IPV6_CSUM | NETIF_F_TSO6;\n\n\tdev->vlan_features = dev->hw_features;\n\tdev->hw_features |= NETIF_F_HW_VLAN_CTAG_TX | NETIF_F_HW_VLAN_CTAG_RX;\n\tdev->features |= dev->hw_features;\n\tdev->priv_flags |= IFF_UNICAST_FLT;\n\tdev->min_mtu = MIN_ETHERNET_PACKET_SIZE;\n\tdev->max_mtu = MAX_ETHERNET_JUMBO_PACKET_SIZE;\n\n\tif (!(bp->flags & BNX2_FLAG_CAN_KEEP_VLAN))\n\t\tdev->hw_features &= ~NETIF_F_HW_VLAN_CTAG_RX;\n\n\tif ((rc = register_netdev(dev))) {\n\t\tdev_err(&pdev->dev, \"Cannot register net device\\n\");\n\t\tgoto error;\n\t}\n\n\tnetdev_info(dev, \"%s (%c%d) %s found at mem %lx, IRQ %d, \"\n\t\t    \"node addr %pM\\n\", board_info[ent->driver_data].name,\n\t\t    ((BNX2_CHIP_ID(bp) & 0xf000) >> 12) + 'A',\n\t\t    ((BNX2_CHIP_ID(bp) & 0x0ff0) >> 4),\n\t\t    bnx2_bus_string(bp, str), (long)pci_resource_start(pdev, 0),\n\t\t    pdev->irq, dev->dev_addr);\n\n\treturn 0;\n\nerror:\n\tpci_iounmap(pdev, bp->regview);\n\tpci_release_regions(pdev);\n\tpci_disable_device(pdev);\nerr_free:\n\tbnx2_free_stats_blk(dev);\n\tfree_netdev(dev);\n\treturn rc;\n}\n\nstatic void\nbnx2_remove_one(struct pci_dev *pdev)\n{\n\tstruct net_device *dev = pci_get_drvdata(pdev);\n\tstruct bnx2 *bp = netdev_priv(dev);\n\n\tunregister_netdev(dev);\n\n\tdel_timer_sync(&bp->timer);\n\tcancel_work_sync(&bp->reset_task);\n\n\tpci_iounmap(bp->pdev, bp->regview);\n\n\tbnx2_free_stats_blk(dev);\n\tkfree(bp->temp_stats_blk);\n\n\tbnx2_release_firmware(bp);\n\n\tfree_netdev(dev);\n\n\tpci_release_regions(pdev);\n\tpci_disable_device(pdev);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int\nbnx2_suspend(struct device *device)\n{\n\tstruct net_device *dev = dev_get_drvdata(device);\n\tstruct bnx2 *bp = netdev_priv(dev);\n\n\tif (netif_running(dev)) {\n\t\tcancel_work_sync(&bp->reset_task);\n\t\tbnx2_netif_stop(bp, true);\n\t\tnetif_device_detach(dev);\n\t\tdel_timer_sync(&bp->timer);\n\t\tbnx2_shutdown_chip(bp);\n\t\t__bnx2_free_irq(bp);\n\t\tbnx2_free_skbs(bp);\n\t}\n\tbnx2_setup_wol(bp);\n\treturn 0;\n}\n\nstatic int\nbnx2_resume(struct device *device)\n{\n\tstruct net_device *dev = dev_get_drvdata(device);\n\tstruct bnx2 *bp = netdev_priv(dev);\n\n\tif (!netif_running(dev))\n\t\treturn 0;\n\n\tbnx2_set_power_state(bp, PCI_D0);\n\tnetif_device_attach(dev);\n\tbnx2_request_irq(bp);\n\tbnx2_init_nic(bp, 1);\n\tbnx2_netif_start(bp, true);\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(bnx2_pm_ops, bnx2_suspend, bnx2_resume);\n#define BNX2_PM_OPS (&bnx2_pm_ops)\n\n#else\n\n#define BNX2_PM_OPS NULL\n\n#endif  \n \nstatic pci_ers_result_t bnx2_io_error_detected(struct pci_dev *pdev,\n\t\t\t\t\t       pci_channel_state_t state)\n{\n\tstruct net_device *dev = pci_get_drvdata(pdev);\n\tstruct bnx2 *bp = netdev_priv(dev);\n\n\trtnl_lock();\n\tnetif_device_detach(dev);\n\n\tif (state == pci_channel_io_perm_failure) {\n\t\trtnl_unlock();\n\t\treturn PCI_ERS_RESULT_DISCONNECT;\n\t}\n\n\tif (netif_running(dev)) {\n\t\tbnx2_netif_stop(bp, true);\n\t\tdel_timer_sync(&bp->timer);\n\t\tbnx2_reset_nic(bp, BNX2_DRV_MSG_CODE_RESET);\n\t}\n\n\tpci_disable_device(pdev);\n\trtnl_unlock();\n\n\t \n\treturn PCI_ERS_RESULT_NEED_RESET;\n}\n\n \nstatic pci_ers_result_t bnx2_io_slot_reset(struct pci_dev *pdev)\n{\n\tstruct net_device *dev = pci_get_drvdata(pdev);\n\tstruct bnx2 *bp = netdev_priv(dev);\n\tpci_ers_result_t result = PCI_ERS_RESULT_DISCONNECT;\n\tint err = 0;\n\n\trtnl_lock();\n\tif (pci_enable_device(pdev)) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Cannot re-enable PCI device after reset\\n\");\n\t} else {\n\t\tpci_set_master(pdev);\n\t\tpci_restore_state(pdev);\n\t\tpci_save_state(pdev);\n\n\t\tif (netif_running(dev))\n\t\t\terr = bnx2_init_nic(bp, 1);\n\n\t\tif (!err)\n\t\t\tresult = PCI_ERS_RESULT_RECOVERED;\n\t}\n\n\tif (result != PCI_ERS_RESULT_RECOVERED && netif_running(dev)) {\n\t\tbnx2_napi_enable(bp);\n\t\tdev_close(dev);\n\t}\n\trtnl_unlock();\n\n\treturn result;\n}\n\n \nstatic void bnx2_io_resume(struct pci_dev *pdev)\n{\n\tstruct net_device *dev = pci_get_drvdata(pdev);\n\tstruct bnx2 *bp = netdev_priv(dev);\n\n\trtnl_lock();\n\tif (netif_running(dev))\n\t\tbnx2_netif_start(bp, true);\n\n\tnetif_device_attach(dev);\n\trtnl_unlock();\n}\n\nstatic void bnx2_shutdown(struct pci_dev *pdev)\n{\n\tstruct net_device *dev = pci_get_drvdata(pdev);\n\tstruct bnx2 *bp;\n\n\tif (!dev)\n\t\treturn;\n\n\tbp = netdev_priv(dev);\n\tif (!bp)\n\t\treturn;\n\n\trtnl_lock();\n\tif (netif_running(dev))\n\t\tdev_close(bp->dev);\n\n\tif (system_state == SYSTEM_POWER_OFF)\n\t\tbnx2_set_power_state(bp, PCI_D3hot);\n\n\trtnl_unlock();\n}\n\nstatic const struct pci_error_handlers bnx2_err_handler = {\n\t.error_detected\t= bnx2_io_error_detected,\n\t.slot_reset\t= bnx2_io_slot_reset,\n\t.resume\t\t= bnx2_io_resume,\n};\n\nstatic struct pci_driver bnx2_pci_driver = {\n\t.name\t\t= DRV_MODULE_NAME,\n\t.id_table\t= bnx2_pci_tbl,\n\t.probe\t\t= bnx2_init_one,\n\t.remove\t\t= bnx2_remove_one,\n\t.driver.pm\t= BNX2_PM_OPS,\n\t.err_handler\t= &bnx2_err_handler,\n\t.shutdown\t= bnx2_shutdown,\n};\n\nmodule_pci_driver(bnx2_pci_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}