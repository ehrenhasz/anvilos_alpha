{
  "module_name": "bnxt_vfr.c",
  "hash_id": "2503ad698d60f1ee02c528ac3f3d56bcbf8793d2f3cf14864187a76d8eca7d72",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/broadcom/bnxt/bnxt_vfr.c",
  "human_readable_source": " \n#include <linux/pci.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/rtnetlink.h>\n#include <linux/jhash.h>\n#include <net/pkt_cls.h>\n\n#include \"bnxt_hsi.h\"\n#include \"bnxt.h\"\n#include \"bnxt_hwrm.h\"\n#include \"bnxt_vfr.h\"\n#include \"bnxt_devlink.h\"\n#include \"bnxt_tc.h\"\n\n#ifdef CONFIG_BNXT_SRIOV\n\n#define CFA_HANDLE_INVALID\t\t0xffff\n#define VF_IDX_INVALID\t\t\t0xffff\n\nstatic int hwrm_cfa_vfr_alloc(struct bnxt *bp, u16 vf_idx,\n\t\t\t      u16 *tx_cfa_action, u16 *rx_cfa_code)\n{\n\tstruct hwrm_cfa_vfr_alloc_output *resp;\n\tstruct hwrm_cfa_vfr_alloc_input *req;\n\tint rc;\n\n\trc = hwrm_req_init(bp, req, HWRM_CFA_VFR_ALLOC);\n\tif (!rc) {\n\t\treq->vf_id = cpu_to_le16(vf_idx);\n\t\tsprintf(req->vfr_name, \"vfr%d\", vf_idx);\n\n\t\tresp = hwrm_req_hold(bp, req);\n\t\trc = hwrm_req_send(bp, req);\n\t\tif (!rc) {\n\t\t\t*tx_cfa_action = le16_to_cpu(resp->tx_cfa_action);\n\t\t\t*rx_cfa_code = le16_to_cpu(resp->rx_cfa_code);\n\t\t\tnetdev_dbg(bp->dev, \"tx_cfa_action=0x%x, rx_cfa_code=0x%x\",\n\t\t\t\t   *tx_cfa_action, *rx_cfa_code);\n\t\t}\n\t\thwrm_req_drop(bp, req);\n\t}\n\tif (rc)\n\t\tnetdev_info(bp->dev, \"%s error rc=%d\\n\", __func__, rc);\n\treturn rc;\n}\n\nstatic int hwrm_cfa_vfr_free(struct bnxt *bp, u16 vf_idx)\n{\n\tstruct hwrm_cfa_vfr_free_input *req;\n\tint rc;\n\n\trc = hwrm_req_init(bp, req, HWRM_CFA_VFR_FREE);\n\tif (!rc) {\n\t\tsprintf(req->vfr_name, \"vfr%d\", vf_idx);\n\t\trc = hwrm_req_send(bp, req);\n\t}\n\tif (rc)\n\t\tnetdev_info(bp->dev, \"%s error rc=%d\\n\", __func__, rc);\n\treturn rc;\n}\n\nstatic int bnxt_hwrm_vfr_qcfg(struct bnxt *bp, struct bnxt_vf_rep *vf_rep,\n\t\t\t      u16 *max_mtu)\n{\n\tstruct hwrm_func_qcfg_output *resp;\n\tstruct hwrm_func_qcfg_input *req;\n\tu16 mtu;\n\tint rc;\n\n\trc = hwrm_req_init(bp, req, HWRM_FUNC_QCFG);\n\tif (rc)\n\t\treturn rc;\n\n\treq->fid = cpu_to_le16(bp->pf.vf[vf_rep->vf_idx].fw_fid);\n\tresp = hwrm_req_hold(bp, req);\n\trc = hwrm_req_send(bp, req);\n\tif (!rc) {\n\t\tmtu = le16_to_cpu(resp->max_mtu_configured);\n\t\tif (!mtu)\n\t\t\t*max_mtu = BNXT_MAX_MTU;\n\t\telse\n\t\t\t*max_mtu = mtu;\n\t}\n\thwrm_req_drop(bp, req);\n\treturn rc;\n}\n\nstatic int bnxt_vf_rep_open(struct net_device *dev)\n{\n\tstruct bnxt_vf_rep *vf_rep = netdev_priv(dev);\n\tstruct bnxt *bp = vf_rep->bp;\n\n\t \n\tif (netif_running(bp->dev)) {\n\t\tnetif_carrier_on(dev);\n\t\tnetif_tx_start_all_queues(dev);\n\t}\n\treturn 0;\n}\n\nstatic int bnxt_vf_rep_close(struct net_device *dev)\n{\n\tnetif_carrier_off(dev);\n\tnetif_tx_disable(dev);\n\n\treturn 0;\n}\n\nstatic netdev_tx_t bnxt_vf_rep_xmit(struct sk_buff *skb,\n\t\t\t\t    struct net_device *dev)\n{\n\tstruct bnxt_vf_rep *vf_rep = netdev_priv(dev);\n\tint rc, len = skb->len;\n\n\tskb_dst_drop(skb);\n\tdst_hold((struct dst_entry *)vf_rep->dst);\n\tskb_dst_set(skb, (struct dst_entry *)vf_rep->dst);\n\tskb->dev = vf_rep->dst->u.port_info.lower_dev;\n\n\trc = dev_queue_xmit(skb);\n\tif (!rc) {\n\t\tvf_rep->tx_stats.packets++;\n\t\tvf_rep->tx_stats.bytes += len;\n\t}\n\treturn rc;\n}\n\nstatic void\nbnxt_vf_rep_get_stats64(struct net_device *dev,\n\t\t\tstruct rtnl_link_stats64 *stats)\n{\n\tstruct bnxt_vf_rep *vf_rep = netdev_priv(dev);\n\n\tstats->rx_packets = vf_rep->rx_stats.packets;\n\tstats->rx_bytes = vf_rep->rx_stats.bytes;\n\tstats->tx_packets = vf_rep->tx_stats.packets;\n\tstats->tx_bytes = vf_rep->tx_stats.bytes;\n}\n\nstatic int bnxt_vf_rep_setup_tc_block_cb(enum tc_setup_type type,\n\t\t\t\t\t void *type_data,\n\t\t\t\t\t void *cb_priv)\n{\n\tstruct bnxt_vf_rep *vf_rep = cb_priv;\n\tstruct bnxt *bp = vf_rep->bp;\n\tint vf_fid = bp->pf.vf[vf_rep->vf_idx].fw_fid;\n\n\tif (!bnxt_tc_flower_enabled(vf_rep->bp) ||\n\t    !tc_cls_can_offload_and_chain0(bp->dev, type_data))\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (type) {\n\tcase TC_SETUP_CLSFLOWER:\n\t\treturn bnxt_tc_setup_flower(bp, vf_fid, type_data);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic LIST_HEAD(bnxt_vf_block_cb_list);\n\nstatic int bnxt_vf_rep_setup_tc(struct net_device *dev, enum tc_setup_type type,\n\t\t\t\tvoid *type_data)\n{\n\tstruct bnxt_vf_rep *vf_rep = netdev_priv(dev);\n\n\tswitch (type) {\n\tcase TC_SETUP_BLOCK:\n\t\treturn flow_block_cb_setup_simple(type_data,\n\t\t\t\t\t\t  &bnxt_vf_block_cb_list,\n\t\t\t\t\t\t  bnxt_vf_rep_setup_tc_block_cb,\n\t\t\t\t\t\t  vf_rep, vf_rep, true);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstruct net_device *bnxt_get_vf_rep(struct bnxt *bp, u16 cfa_code)\n{\n\tu16 vf_idx;\n\n\tif (cfa_code && bp->cfa_code_map && BNXT_PF(bp)) {\n\t\tvf_idx = bp->cfa_code_map[cfa_code];\n\t\tif (vf_idx != VF_IDX_INVALID)\n\t\t\treturn bp->vf_reps[vf_idx]->dev;\n\t}\n\treturn NULL;\n}\n\nvoid bnxt_vf_rep_rx(struct bnxt *bp, struct sk_buff *skb)\n{\n\tstruct bnxt_vf_rep *vf_rep = netdev_priv(skb->dev);\n\n\tvf_rep->rx_stats.bytes += skb->len;\n\tvf_rep->rx_stats.packets++;\n\n\tnetif_receive_skb(skb);\n}\n\nstatic int bnxt_vf_rep_get_phys_port_name(struct net_device *dev, char *buf,\n\t\t\t\t\t  size_t len)\n{\n\tstruct bnxt_vf_rep *vf_rep = netdev_priv(dev);\n\tstruct pci_dev *pf_pdev = vf_rep->bp->pdev;\n\tint rc;\n\n\trc = snprintf(buf, len, \"pf%dvf%d\", PCI_FUNC(pf_pdev->devfn),\n\t\t      vf_rep->vf_idx);\n\tif (rc >= len)\n\t\treturn -EOPNOTSUPP;\n\treturn 0;\n}\n\nstatic void bnxt_vf_rep_get_drvinfo(struct net_device *dev,\n\t\t\t\t    struct ethtool_drvinfo *info)\n{\n\tstrscpy(info->driver, DRV_MODULE_NAME, sizeof(info->driver));\n}\n\nstatic int bnxt_vf_rep_get_port_parent_id(struct net_device *dev,\n\t\t\t\t\t  struct netdev_phys_item_id *ppid)\n{\n\tstruct bnxt_vf_rep *vf_rep = netdev_priv(dev);\n\n\t \n\treturn bnxt_get_port_parent_id(vf_rep->bp->dev, ppid);\n}\n\nstatic const struct ethtool_ops bnxt_vf_rep_ethtool_ops = {\n\t.get_drvinfo\t\t= bnxt_vf_rep_get_drvinfo\n};\n\nstatic const struct net_device_ops bnxt_vf_rep_netdev_ops = {\n\t.ndo_open\t\t= bnxt_vf_rep_open,\n\t.ndo_stop\t\t= bnxt_vf_rep_close,\n\t.ndo_start_xmit\t\t= bnxt_vf_rep_xmit,\n\t.ndo_get_stats64\t= bnxt_vf_rep_get_stats64,\n\t.ndo_setup_tc\t\t= bnxt_vf_rep_setup_tc,\n\t.ndo_get_port_parent_id\t= bnxt_vf_rep_get_port_parent_id,\n\t.ndo_get_phys_port_name = bnxt_vf_rep_get_phys_port_name\n};\n\nbool bnxt_dev_is_vf_rep(struct net_device *dev)\n{\n\treturn dev->netdev_ops == &bnxt_vf_rep_netdev_ops;\n}\n\n \nvoid bnxt_vf_reps_close(struct bnxt *bp)\n{\n\tstruct bnxt_vf_rep *vf_rep;\n\tu16 num_vfs, i;\n\n\tif (bp->eswitch_mode != DEVLINK_ESWITCH_MODE_SWITCHDEV)\n\t\treturn;\n\n\tnum_vfs = pci_num_vf(bp->pdev);\n\tfor (i = 0; i < num_vfs; i++) {\n\t\tvf_rep = bp->vf_reps[i];\n\t\tif (netif_running(vf_rep->dev))\n\t\t\tbnxt_vf_rep_close(vf_rep->dev);\n\t}\n}\n\n \nvoid bnxt_vf_reps_open(struct bnxt *bp)\n{\n\tint i;\n\n\tif (bp->eswitch_mode != DEVLINK_ESWITCH_MODE_SWITCHDEV)\n\t\treturn;\n\n\tfor (i = 0; i < pci_num_vf(bp->pdev); i++) {\n\t\t \n\t\tif (bp->vf_reps[i]->tx_cfa_action != CFA_HANDLE_INVALID)\n\t\t\tbnxt_vf_rep_open(bp->vf_reps[i]->dev);\n\t}\n}\n\nstatic void __bnxt_free_one_vf_rep(struct bnxt *bp, struct bnxt_vf_rep *vf_rep)\n{\n\tif (!vf_rep)\n\t\treturn;\n\n\tif (vf_rep->dst) {\n\t\tdst_release((struct dst_entry *)vf_rep->dst);\n\t\tvf_rep->dst = NULL;\n\t}\n\tif (vf_rep->tx_cfa_action != CFA_HANDLE_INVALID) {\n\t\thwrm_cfa_vfr_free(bp, vf_rep->vf_idx);\n\t\tvf_rep->tx_cfa_action = CFA_HANDLE_INVALID;\n\t}\n}\n\nstatic void __bnxt_vf_reps_destroy(struct bnxt *bp)\n{\n\tu16 num_vfs = pci_num_vf(bp->pdev);\n\tstruct bnxt_vf_rep *vf_rep;\n\tint i;\n\n\tfor (i = 0; i < num_vfs; i++) {\n\t\tvf_rep = bp->vf_reps[i];\n\t\tif (vf_rep) {\n\t\t\t__bnxt_free_one_vf_rep(bp, vf_rep);\n\t\t\tif (vf_rep->dev) {\n\t\t\t\t \n\t\t\t\tif (vf_rep->dev->netdev_ops)\n\t\t\t\t\tunregister_netdev(vf_rep->dev);\n\t\t\t\tfree_netdev(vf_rep->dev);\n\t\t\t}\n\t\t}\n\t}\n\n\tkfree(bp->vf_reps);\n\tbp->vf_reps = NULL;\n}\n\nvoid bnxt_vf_reps_destroy(struct bnxt *bp)\n{\n\tbool closed = false;\n\n\tif (bp->eswitch_mode != DEVLINK_ESWITCH_MODE_SWITCHDEV)\n\t\treturn;\n\n\tif (!bp->vf_reps)\n\t\treturn;\n\n\t \n\trtnl_lock();\n\tif (netif_running(bp->dev)) {\n\t\tbnxt_close_nic(bp, false, false);\n\t\tclosed = true;\n\t}\n\t \n\tkfree(bp->cfa_code_map);\n\tbp->cfa_code_map = NULL;\n\n\tif (closed) {\n\t\t \n\t\tbp->eswitch_mode = DEVLINK_ESWITCH_MODE_LEGACY;\n\t\tbnxt_open_nic(bp, false, false);\n\t\tbp->eswitch_mode = DEVLINK_ESWITCH_MODE_SWITCHDEV;\n\t}\n\trtnl_unlock();\n\n\t \n\t__bnxt_vf_reps_destroy(bp);\n}\n\n \nvoid bnxt_vf_reps_free(struct bnxt *bp)\n{\n\tu16 num_vfs = pci_num_vf(bp->pdev);\n\tint i;\n\n\tif (bp->eswitch_mode != DEVLINK_ESWITCH_MODE_SWITCHDEV)\n\t\treturn;\n\n\tfor (i = 0; i < num_vfs; i++)\n\t\t__bnxt_free_one_vf_rep(bp, bp->vf_reps[i]);\n}\n\nstatic int bnxt_alloc_vf_rep(struct bnxt *bp, struct bnxt_vf_rep *vf_rep,\n\t\t\t     u16 *cfa_code_map)\n{\n\t \n\tif (hwrm_cfa_vfr_alloc(bp, vf_rep->vf_idx, &vf_rep->tx_cfa_action,\n\t\t\t       &vf_rep->rx_cfa_code))\n\t\treturn -ENOLINK;\n\n\tcfa_code_map[vf_rep->rx_cfa_code] = vf_rep->vf_idx;\n\tvf_rep->dst = metadata_dst_alloc(0, METADATA_HW_PORT_MUX, GFP_KERNEL);\n\tif (!vf_rep->dst)\n\t\treturn -ENOMEM;\n\n\t \n\tvf_rep->dst->u.port_info.port_id = vf_rep->tx_cfa_action;\n\tvf_rep->dst->u.port_info.lower_dev = bp->dev;\n\n\treturn 0;\n}\n\n \nint bnxt_vf_reps_alloc(struct bnxt *bp)\n{\n\tu16 *cfa_code_map = bp->cfa_code_map, num_vfs = pci_num_vf(bp->pdev);\n\tstruct bnxt_vf_rep *vf_rep;\n\tint rc, i;\n\n\tif (bp->eswitch_mode != DEVLINK_ESWITCH_MODE_SWITCHDEV)\n\t\treturn 0;\n\n\tif (!cfa_code_map)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < MAX_CFA_CODE; i++)\n\t\tcfa_code_map[i] = VF_IDX_INVALID;\n\n\tfor (i = 0; i < num_vfs; i++) {\n\t\tvf_rep = bp->vf_reps[i];\n\t\tvf_rep->vf_idx = i;\n\n\t\trc = bnxt_alloc_vf_rep(bp, vf_rep, cfa_code_map);\n\t\tif (rc)\n\t\t\tgoto err;\n\t}\n\n\treturn 0;\n\nerr:\n\tnetdev_info(bp->dev, \"%s error=%d\\n\", __func__, rc);\n\tbnxt_vf_reps_free(bp);\n\treturn rc;\n}\n\n \nstatic void bnxt_vf_rep_eth_addr_gen(u8 *src_mac, u16 vf_idx, u8 *mac)\n{\n\tu32 addr;\n\n\tether_addr_copy(mac, src_mac);\n\n\taddr = jhash(src_mac, ETH_ALEN, 0) + vf_idx;\n\tmac[3] = (u8)(addr & 0xFF);\n\tmac[4] = (u8)((addr >> 8) & 0xFF);\n\tmac[5] = (u8)((addr >> 16) & 0xFF);\n}\n\nstatic void bnxt_vf_rep_netdev_init(struct bnxt *bp, struct bnxt_vf_rep *vf_rep,\n\t\t\t\t    struct net_device *dev)\n{\n\tstruct net_device *pf_dev = bp->dev;\n\tu16 max_mtu;\n\n\tSET_NETDEV_DEV(dev, &bp->pdev->dev);\n\tdev->netdev_ops = &bnxt_vf_rep_netdev_ops;\n\tdev->ethtool_ops = &bnxt_vf_rep_ethtool_ops;\n\t \n\tdev->hw_features = pf_dev->hw_features;\n\tdev->gso_partial_features = pf_dev->gso_partial_features;\n\tdev->vlan_features = pf_dev->vlan_features;\n\tdev->hw_enc_features = pf_dev->hw_enc_features;\n\tdev->features |= pf_dev->features;\n\tbnxt_vf_rep_eth_addr_gen(bp->pf.mac_addr, vf_rep->vf_idx,\n\t\t\t\t dev->perm_addr);\n\teth_hw_addr_set(dev, dev->perm_addr);\n\t \n\tif (!bnxt_hwrm_vfr_qcfg(bp, vf_rep, &max_mtu))\n\t\tdev->max_mtu = max_mtu;\n\tdev->min_mtu = ETH_ZLEN;\n}\n\nint bnxt_vf_reps_create(struct bnxt *bp)\n{\n\tu16 *cfa_code_map = NULL, num_vfs = pci_num_vf(bp->pdev);\n\tstruct bnxt_vf_rep *vf_rep;\n\tstruct net_device *dev;\n\tint rc, i;\n\n\tif (!(bp->flags & BNXT_FLAG_DSN_VALID))\n\t\treturn -ENODEV;\n\n\tbp->vf_reps = kcalloc(num_vfs, sizeof(vf_rep), GFP_KERNEL);\n\tif (!bp->vf_reps)\n\t\treturn -ENOMEM;\n\n\t \n\tcfa_code_map = kmalloc_array(MAX_CFA_CODE, sizeof(*bp->cfa_code_map),\n\t\t\t\t     GFP_KERNEL);\n\tif (!cfa_code_map) {\n\t\trc = -ENOMEM;\n\t\tgoto err;\n\t}\n\tfor (i = 0; i < MAX_CFA_CODE; i++)\n\t\tcfa_code_map[i] = VF_IDX_INVALID;\n\n\tfor (i = 0; i < num_vfs; i++) {\n\t\tdev = alloc_etherdev(sizeof(*vf_rep));\n\t\tif (!dev) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\n\t\tvf_rep = netdev_priv(dev);\n\t\tbp->vf_reps[i] = vf_rep;\n\t\tvf_rep->dev = dev;\n\t\tvf_rep->bp = bp;\n\t\tvf_rep->vf_idx = i;\n\t\tvf_rep->tx_cfa_action = CFA_HANDLE_INVALID;\n\n\t\trc = bnxt_alloc_vf_rep(bp, vf_rep, cfa_code_map);\n\t\tif (rc)\n\t\t\tgoto err;\n\n\t\tbnxt_vf_rep_netdev_init(bp, vf_rep, dev);\n\t\trc = register_netdev(dev);\n\t\tif (rc) {\n\t\t\t \n\t\t\tdev->netdev_ops = NULL;\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\t \n\tbp->cfa_code_map = cfa_code_map;\n\tnetif_keep_dst(bp->dev);\n\treturn 0;\n\nerr:\n\tnetdev_info(bp->dev, \"%s error=%d\\n\", __func__, rc);\n\tkfree(cfa_code_map);\n\t__bnxt_vf_reps_destroy(bp);\n\treturn rc;\n}\n\n \nint bnxt_dl_eswitch_mode_get(struct devlink *devlink, u16 *mode)\n{\n\tstruct bnxt *bp = bnxt_get_bp_from_dl(devlink);\n\n\t*mode = bp->eswitch_mode;\n\treturn 0;\n}\n\nint bnxt_dl_eswitch_mode_set(struct devlink *devlink, u16 mode,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct bnxt *bp = bnxt_get_bp_from_dl(devlink);\n\tint ret = 0;\n\n\tif (bp->eswitch_mode == mode) {\n\t\tnetdev_info(bp->dev, \"already in %s eswitch mode\\n\",\n\t\t\t    mode == DEVLINK_ESWITCH_MODE_LEGACY ?\n\t\t\t    \"legacy\" : \"switchdev\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (mode) {\n\tcase DEVLINK_ESWITCH_MODE_LEGACY:\n\t\tbnxt_vf_reps_destroy(bp);\n\t\tbreak;\n\n\tcase DEVLINK_ESWITCH_MODE_SWITCHDEV:\n\t\tif (bp->hwrm_spec_code < 0x10803) {\n\t\t\tnetdev_warn(bp->dev, \"FW does not support SRIOV E-Switch SWITCHDEV mode\\n\");\n\t\t\treturn -ENOTSUPP;\n\t\t}\n\n\t\t \n\t\tif (pci_num_vf(bp->pdev) > 0)\n\t\t\tret = bnxt_vf_reps_create(bp);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (!ret)\n\t\tbp->eswitch_mode = mode;\n\n\treturn ret;\n}\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}