{
  "module_name": "bnxt_ulp.c",
  "hash_id": "ccafd782825fb74ff56899a8c6bbd45b0b4879f713af8a1b87196c794b6353af",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/broadcom/bnxt/bnxt_ulp.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/netdevice.h>\n#include <linux/rtnetlink.h>\n#include <linux/bitops.h>\n#include <linux/irq.h>\n#include <asm/byteorder.h>\n#include <linux/bitmap.h>\n#include <linux/auxiliary_bus.h>\n\n#include \"bnxt_hsi.h\"\n#include \"bnxt.h\"\n#include \"bnxt_hwrm.h\"\n#include \"bnxt_ulp.h\"\n\nstatic DEFINE_IDA(bnxt_aux_dev_ids);\n\nstatic void bnxt_fill_msix_vecs(struct bnxt *bp, struct bnxt_msix_entry *ent)\n{\n\tstruct bnxt_en_dev *edev = bp->edev;\n\tint num_msix, idx, i;\n\n\tif (!edev->ulp_tbl->msix_requested) {\n\t\tnetdev_warn(bp->dev, \"Requested MSI-X vectors insufficient\\n\");\n\t\treturn;\n\t}\n\tnum_msix = edev->ulp_tbl->msix_requested;\n\tidx = edev->ulp_tbl->msix_base;\n\tfor (i = 0; i < num_msix; i++) {\n\t\tent[i].vector = bp->irq_tbl[idx + i].vector;\n\t\tent[i].ring_idx = idx + i;\n\t\tif (bp->flags & BNXT_FLAG_CHIP_P5) {\n\t\t\tent[i].db_offset = DB_PF_OFFSET_P5;\n\t\t\tif (BNXT_VF(bp))\n\t\t\t\tent[i].db_offset = DB_VF_OFFSET_P5;\n\t\t} else {\n\t\t\tent[i].db_offset = (idx + i) * 0x80;\n\t\t}\n\t}\n}\n\nint bnxt_register_dev(struct bnxt_en_dev *edev,\n\t\t      struct bnxt_ulp_ops *ulp_ops,\n\t\t      void *handle)\n{\n\tstruct net_device *dev = edev->net;\n\tstruct bnxt *bp = netdev_priv(dev);\n\tunsigned int max_stat_ctxs;\n\tstruct bnxt_ulp *ulp;\n\n\tmax_stat_ctxs = bnxt_get_max_func_stat_ctxs(bp);\n\tif (max_stat_ctxs <= BNXT_MIN_ROCE_STAT_CTXS ||\n\t    bp->cp_nr_rings == max_stat_ctxs)\n\t\treturn -ENOMEM;\n\n\tulp = edev->ulp_tbl;\n\tif (!ulp)\n\t\treturn -ENOMEM;\n\n\tulp->handle = handle;\n\trcu_assign_pointer(ulp->ulp_ops, ulp_ops);\n\n\tif (test_bit(BNXT_STATE_OPEN, &bp->state))\n\t\tbnxt_hwrm_vnic_cfg(bp, 0);\n\n\tbnxt_fill_msix_vecs(bp, bp->edev->msix_entries);\n\tedev->flags |= BNXT_EN_FLAG_MSIX_REQUESTED;\n\treturn 0;\n}\nEXPORT_SYMBOL(bnxt_register_dev);\n\nvoid bnxt_unregister_dev(struct bnxt_en_dev *edev)\n{\n\tstruct net_device *dev = edev->net;\n\tstruct bnxt *bp = netdev_priv(dev);\n\tstruct bnxt_ulp *ulp;\n\tint i = 0;\n\n\tulp = edev->ulp_tbl;\n\tif (ulp->msix_requested)\n\t\tedev->flags &= ~BNXT_EN_FLAG_MSIX_REQUESTED;\n\n\tif (ulp->max_async_event_id)\n\t\tbnxt_hwrm_func_drv_rgtr(bp, NULL, 0, true);\n\n\tRCU_INIT_POINTER(ulp->ulp_ops, NULL);\n\tsynchronize_rcu();\n\tulp->max_async_event_id = 0;\n\tulp->async_events_bmap = NULL;\n\twhile (atomic_read(&ulp->ref_count) != 0 && i < 10) {\n\t\tmsleep(100);\n\t\ti++;\n\t}\n\treturn;\n}\nEXPORT_SYMBOL(bnxt_unregister_dev);\n\nint bnxt_get_ulp_msix_num(struct bnxt *bp)\n{\n\tu32 roce_msix = BNXT_VF(bp) ?\n\t\t\tBNXT_MAX_VF_ROCE_MSIX : BNXT_MAX_ROCE_MSIX;\n\n\treturn ((bp->flags & BNXT_FLAG_ROCE_CAP) ?\n\t\tmin_t(u32, roce_msix, num_online_cpus()) : 0);\n}\n\nint bnxt_get_ulp_msix_base(struct bnxt *bp)\n{\n\tif (bnxt_ulp_registered(bp->edev)) {\n\t\tstruct bnxt_en_dev *edev = bp->edev;\n\n\t\tif (edev->ulp_tbl->msix_requested)\n\t\t\treturn edev->ulp_tbl->msix_base;\n\t}\n\treturn 0;\n}\n\nint bnxt_get_ulp_stat_ctxs(struct bnxt *bp)\n{\n\tif (bnxt_ulp_registered(bp->edev)) {\n\t\tstruct bnxt_en_dev *edev = bp->edev;\n\n\t\tif (edev->ulp_tbl->msix_requested)\n\t\t\treturn BNXT_MIN_ROCE_STAT_CTXS;\n\t}\n\n\treturn 0;\n}\n\nint bnxt_send_msg(struct bnxt_en_dev *edev,\n\t\t\t struct bnxt_fw_msg *fw_msg)\n{\n\tstruct net_device *dev = edev->net;\n\tstruct bnxt *bp = netdev_priv(dev);\n\tstruct output *resp;\n\tstruct input *req;\n\tu32 resp_len;\n\tint rc;\n\n\tif (bp->fw_reset_state)\n\t\treturn -EBUSY;\n\n\trc = hwrm_req_init(bp, req, 0  );\n\tif (rc)\n\t\treturn rc;\n\n\trc = hwrm_req_replace(bp, req, fw_msg->msg, fw_msg->msg_len);\n\tif (rc)\n\t\treturn rc;\n\n\thwrm_req_timeout(bp, req, fw_msg->timeout);\n\tresp = hwrm_req_hold(bp, req);\n\trc = hwrm_req_send(bp, req);\n\tresp_len = le16_to_cpu(resp->resp_len);\n\tif (resp_len) {\n\t\tif (fw_msg->resp_max_len < resp_len)\n\t\t\tresp_len = fw_msg->resp_max_len;\n\n\t\tmemcpy(fw_msg->resp, resp, resp_len);\n\t}\n\thwrm_req_drop(bp, req);\n\treturn rc;\n}\nEXPORT_SYMBOL(bnxt_send_msg);\n\nvoid bnxt_ulp_stop(struct bnxt *bp)\n{\n\tstruct bnxt_aux_priv *aux_priv = bp->aux_priv;\n\tstruct bnxt_en_dev *edev = bp->edev;\n\n\tif (!edev)\n\t\treturn;\n\n\tedev->flags |= BNXT_EN_FLAG_ULP_STOPPED;\n\tif (aux_priv) {\n\t\tstruct auxiliary_device *adev;\n\n\t\tadev = &aux_priv->aux_dev;\n\t\tif (adev->dev.driver) {\n\t\t\tstruct auxiliary_driver *adrv;\n\t\t\tpm_message_t pm = {};\n\n\t\t\tadrv = to_auxiliary_drv(adev->dev.driver);\n\t\t\tedev->en_state = bp->state;\n\t\t\tadrv->suspend(adev, pm);\n\t\t}\n\t}\n}\n\nvoid bnxt_ulp_start(struct bnxt *bp, int err)\n{\n\tstruct bnxt_aux_priv *aux_priv = bp->aux_priv;\n\tstruct bnxt_en_dev *edev = bp->edev;\n\n\tif (!edev)\n\t\treturn;\n\n\tedev->flags &= ~BNXT_EN_FLAG_ULP_STOPPED;\n\n\tif (err)\n\t\treturn;\n\n\tif (aux_priv) {\n\t\tstruct auxiliary_device *adev;\n\n\t\tadev = &aux_priv->aux_dev;\n\t\tif (adev->dev.driver) {\n\t\t\tstruct auxiliary_driver *adrv;\n\n\t\t\tadrv = to_auxiliary_drv(adev->dev.driver);\n\t\t\tedev->en_state = bp->state;\n\t\t\tadrv->resume(adev);\n\t\t}\n\t}\n\n}\n\nvoid bnxt_ulp_irq_stop(struct bnxt *bp)\n{\n\tstruct bnxt_en_dev *edev = bp->edev;\n\tstruct bnxt_ulp_ops *ops;\n\n\tif (!edev || !(edev->flags & BNXT_EN_FLAG_MSIX_REQUESTED))\n\t\treturn;\n\n\tif (bnxt_ulp_registered(bp->edev)) {\n\t\tstruct bnxt_ulp *ulp = edev->ulp_tbl;\n\n\t\tif (!ulp->msix_requested)\n\t\t\treturn;\n\n\t\tops = rtnl_dereference(ulp->ulp_ops);\n\t\tif (!ops || !ops->ulp_irq_stop)\n\t\t\treturn;\n\t\tops->ulp_irq_stop(ulp->handle);\n\t}\n}\n\nvoid bnxt_ulp_irq_restart(struct bnxt *bp, int err)\n{\n\tstruct bnxt_en_dev *edev = bp->edev;\n\tstruct bnxt_ulp_ops *ops;\n\n\tif (!edev || !(edev->flags & BNXT_EN_FLAG_MSIX_REQUESTED))\n\t\treturn;\n\n\tif (bnxt_ulp_registered(bp->edev)) {\n\t\tstruct bnxt_ulp *ulp = edev->ulp_tbl;\n\t\tstruct bnxt_msix_entry *ent = NULL;\n\n\t\tif (!ulp->msix_requested)\n\t\t\treturn;\n\n\t\tops = rtnl_dereference(ulp->ulp_ops);\n\t\tif (!ops || !ops->ulp_irq_restart)\n\t\t\treturn;\n\n\t\tif (!err) {\n\t\t\tent = kcalloc(ulp->msix_requested, sizeof(*ent),\n\t\t\t\t      GFP_KERNEL);\n\t\t\tif (!ent)\n\t\t\t\treturn;\n\t\t\tbnxt_fill_msix_vecs(bp, ent);\n\t\t}\n\t\tops->ulp_irq_restart(ulp->handle, ent);\n\t\tkfree(ent);\n\t}\n}\n\nint bnxt_register_async_events(struct bnxt_en_dev *edev,\n\t\t\t       unsigned long *events_bmap,\n\t\t\t       u16 max_id)\n{\n\tstruct net_device *dev = edev->net;\n\tstruct bnxt *bp = netdev_priv(dev);\n\tstruct bnxt_ulp *ulp;\n\n\tulp = edev->ulp_tbl;\n\tulp->async_events_bmap = events_bmap;\n\t \n\tsmp_wmb();\n\tulp->max_async_event_id = max_id;\n\tbnxt_hwrm_func_drv_rgtr(bp, events_bmap, max_id + 1, true);\n\treturn 0;\n}\nEXPORT_SYMBOL(bnxt_register_async_events);\n\nvoid bnxt_rdma_aux_device_uninit(struct bnxt *bp)\n{\n\tstruct bnxt_aux_priv *aux_priv;\n\tstruct auxiliary_device *adev;\n\n\t \n\tif (!bp->aux_priv)\n\t\treturn;\n\n\taux_priv = bp->aux_priv;\n\tadev = &aux_priv->aux_dev;\n\tauxiliary_device_delete(adev);\n\tauxiliary_device_uninit(adev);\n}\n\nstatic void bnxt_aux_dev_release(struct device *dev)\n{\n\tstruct bnxt_aux_priv *aux_priv =\n\t\tcontainer_of(dev, struct bnxt_aux_priv, aux_dev.dev);\n\tstruct bnxt *bp = netdev_priv(aux_priv->edev->net);\n\n\tida_free(&bnxt_aux_dev_ids, aux_priv->id);\n\tkfree(aux_priv->edev->ulp_tbl);\n\tbp->edev = NULL;\n\tkfree(aux_priv->edev);\n\tkfree(aux_priv);\n\tbp->aux_priv = NULL;\n}\n\nstatic void bnxt_set_edev_info(struct bnxt_en_dev *edev, struct bnxt *bp)\n{\n\tedev->net = bp->dev;\n\tedev->pdev = bp->pdev;\n\tedev->l2_db_size = bp->db_size;\n\tedev->l2_db_size_nc = bp->db_size;\n\n\tif (bp->flags & BNXT_FLAG_ROCEV1_CAP)\n\t\tedev->flags |= BNXT_EN_FLAG_ROCEV1_CAP;\n\tif (bp->flags & BNXT_FLAG_ROCEV2_CAP)\n\t\tedev->flags |= BNXT_EN_FLAG_ROCEV2_CAP;\n\tif (bp->flags & BNXT_FLAG_VF)\n\t\tedev->flags |= BNXT_EN_FLAG_VF;\n\n\tedev->chip_num = bp->chip_num;\n\tedev->hw_ring_stats_size = bp->hw_ring_stats_size;\n\tedev->pf_port_id = bp->pf.port_id;\n\tedev->en_state = bp->state;\n\tedev->bar0 = bp->bar0;\n\tedev->ulp_tbl->msix_requested = bnxt_get_ulp_msix_num(bp);\n}\n\nvoid bnxt_rdma_aux_device_init(struct bnxt *bp)\n{\n\tstruct auxiliary_device *aux_dev;\n\tstruct bnxt_aux_priv *aux_priv;\n\tstruct bnxt_en_dev *edev;\n\tstruct bnxt_ulp *ulp;\n\tint rc;\n\n\tif (!(bp->flags & BNXT_FLAG_ROCE_CAP))\n\t\treturn;\n\n\taux_priv = kzalloc(sizeof(*bp->aux_priv), GFP_KERNEL);\n\tif (!aux_priv)\n\t\tgoto exit;\n\n\taux_priv->id = ida_alloc(&bnxt_aux_dev_ids, GFP_KERNEL);\n\tif (aux_priv->id < 0) {\n\t\tnetdev_warn(bp->dev,\n\t\t\t    \"ida alloc failed for ROCE auxiliary device\\n\");\n\t\tkfree(aux_priv);\n\t\tgoto exit;\n\t}\n\n\taux_dev = &aux_priv->aux_dev;\n\taux_dev->id = aux_priv->id;\n\taux_dev->name = \"rdma\";\n\taux_dev->dev.parent = &bp->pdev->dev;\n\taux_dev->dev.release = bnxt_aux_dev_release;\n\n\trc = auxiliary_device_init(aux_dev);\n\tif (rc) {\n\t\tida_free(&bnxt_aux_dev_ids, aux_priv->id);\n\t\tkfree(aux_priv);\n\t\tgoto exit;\n\t}\n\tbp->aux_priv = aux_priv;\n\n\t \n\tedev = kzalloc(sizeof(*edev), GFP_KERNEL);\n\tif (!edev)\n\t\tgoto aux_dev_uninit;\n\n\tulp = kzalloc(sizeof(*ulp), GFP_KERNEL);\n\tif (!ulp)\n\t\tgoto aux_dev_uninit;\n\n\tedev->ulp_tbl = ulp;\n\taux_priv->edev = edev;\n\tbp->edev = edev;\n\tbnxt_set_edev_info(edev, bp);\n\n\trc = auxiliary_device_add(aux_dev);\n\tif (rc) {\n\t\tnetdev_warn(bp->dev,\n\t\t\t    \"Failed to add auxiliary device for ROCE\\n\");\n\t\tgoto aux_dev_uninit;\n\t}\n\n\treturn;\n\naux_dev_uninit:\n\tauxiliary_device_uninit(aux_dev);\nexit:\n\tbp->flags &= ~BNXT_FLAG_ROCE_CAP;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}