{
  "module_name": "bnxt_coredump.c",
  "hash_id": "e501d1a8aa7044c65b12dbf2c0635d2c186b081226f53528518e413989356875",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/broadcom/bnxt/bnxt_coredump.c",
  "human_readable_source": " \n\n#include <linux/types.h>\n#include <linux/errno.h>\n#include <linux/pci.h>\n#include \"bnxt_hsi.h\"\n#include \"bnxt.h\"\n#include \"bnxt_hwrm.h\"\n#include \"bnxt_coredump.h\"\n\nstatic int bnxt_hwrm_dbg_dma_data(struct bnxt *bp, void *msg,\n\t\t\t\t  struct bnxt_hwrm_dbg_dma_info *info)\n{\n\tstruct hwrm_dbg_cmn_input *cmn_req = msg;\n\t__le16 *seq_ptr = msg + info->seq_off;\n\tstruct hwrm_dbg_cmn_output *cmn_resp;\n\tu16 seq = 0, len, segs_off;\n\tdma_addr_t dma_handle;\n\tvoid *dma_buf, *resp;\n\tint rc, off = 0;\n\n\tdma_buf = hwrm_req_dma_slice(bp, msg, info->dma_len, &dma_handle);\n\tif (!dma_buf) {\n\t\thwrm_req_drop(bp, msg);\n\t\treturn -ENOMEM;\n\t}\n\n\thwrm_req_timeout(bp, msg, bp->hwrm_cmd_max_timeout);\n\tcmn_resp = hwrm_req_hold(bp, msg);\n\tresp = cmn_resp;\n\n\tsegs_off = offsetof(struct hwrm_dbg_coredump_list_output,\n\t\t\t    total_segments);\n\tcmn_req->host_dest_addr = cpu_to_le64(dma_handle);\n\tcmn_req->host_buf_len = cpu_to_le32(info->dma_len);\n\twhile (1) {\n\t\t*seq_ptr = cpu_to_le16(seq);\n\t\trc = hwrm_req_send(bp, msg);\n\t\tif (rc)\n\t\t\tbreak;\n\n\t\tlen = le16_to_cpu(*((__le16 *)(resp + info->data_len_off)));\n\t\tif (!seq &&\n\t\t    cmn_req->req_type == cpu_to_le16(HWRM_DBG_COREDUMP_LIST)) {\n\t\t\tinfo->segs = le16_to_cpu(*((__le16 *)(resp +\n\t\t\t\t\t\t\t      segs_off)));\n\t\t\tif (!info->segs) {\n\t\t\t\trc = -EIO;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tinfo->dest_buf_size = info->segs *\n\t\t\t\t\tsizeof(struct coredump_segment_record);\n\t\t\tinfo->dest_buf = kmalloc(info->dest_buf_size,\n\t\t\t\t\t\t GFP_KERNEL);\n\t\t\tif (!info->dest_buf) {\n\t\t\t\trc = -ENOMEM;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (info->dest_buf) {\n\t\t\tif ((info->seg_start + off + len) <=\n\t\t\t    BNXT_COREDUMP_BUF_LEN(info->buf_len)) {\n\t\t\t\tmemcpy(info->dest_buf + off, dma_buf, len);\n\t\t\t} else {\n\t\t\t\trc = -ENOBUFS;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (cmn_req->req_type ==\n\t\t\t\tcpu_to_le16(HWRM_DBG_COREDUMP_RETRIEVE))\n\t\t\tinfo->dest_buf_size += len;\n\n\t\tif (!(cmn_resp->flags & HWRM_DBG_CMN_FLAGS_MORE))\n\t\t\tbreak;\n\n\t\tseq++;\n\t\toff += len;\n\t}\n\thwrm_req_drop(bp, msg);\n\treturn rc;\n}\n\nstatic int bnxt_hwrm_dbg_coredump_list(struct bnxt *bp,\n\t\t\t\t       struct bnxt_coredump *coredump)\n{\n\tstruct bnxt_hwrm_dbg_dma_info info = {NULL};\n\tstruct hwrm_dbg_coredump_list_input *req;\n\tint rc;\n\n\trc = hwrm_req_init(bp, req, HWRM_DBG_COREDUMP_LIST);\n\tif (rc)\n\t\treturn rc;\n\n\tinfo.dma_len = COREDUMP_LIST_BUF_LEN;\n\tinfo.seq_off = offsetof(struct hwrm_dbg_coredump_list_input, seq_no);\n\tinfo.data_len_off = offsetof(struct hwrm_dbg_coredump_list_output,\n\t\t\t\t     data_len);\n\n\trc = bnxt_hwrm_dbg_dma_data(bp, req, &info);\n\tif (!rc) {\n\t\tcoredump->data = info.dest_buf;\n\t\tcoredump->data_size = info.dest_buf_size;\n\t\tcoredump->total_segs = info.segs;\n\t}\n\treturn rc;\n}\n\nstatic int bnxt_hwrm_dbg_coredump_initiate(struct bnxt *bp, u16 component_id,\n\t\t\t\t\t   u16 segment_id)\n{\n\tstruct hwrm_dbg_coredump_initiate_input *req;\n\tint rc;\n\n\trc = hwrm_req_init(bp, req, HWRM_DBG_COREDUMP_INITIATE);\n\tif (rc)\n\t\treturn rc;\n\n\thwrm_req_timeout(bp, req, bp->hwrm_cmd_max_timeout);\n\treq->component_id = cpu_to_le16(component_id);\n\treq->segment_id = cpu_to_le16(segment_id);\n\n\treturn hwrm_req_send(bp, req);\n}\n\nstatic int bnxt_hwrm_dbg_coredump_retrieve(struct bnxt *bp, u16 component_id,\n\t\t\t\t\t   u16 segment_id, u32 *seg_len,\n\t\t\t\t\t   void *buf, u32 buf_len, u32 offset)\n{\n\tstruct hwrm_dbg_coredump_retrieve_input *req;\n\tstruct bnxt_hwrm_dbg_dma_info info = {NULL};\n\tint rc;\n\n\trc = hwrm_req_init(bp, req, HWRM_DBG_COREDUMP_RETRIEVE);\n\tif (rc)\n\t\treturn rc;\n\n\treq->component_id = cpu_to_le16(component_id);\n\treq->segment_id = cpu_to_le16(segment_id);\n\n\tinfo.dma_len = COREDUMP_RETRIEVE_BUF_LEN;\n\tinfo.seq_off = offsetof(struct hwrm_dbg_coredump_retrieve_input,\n\t\t\t\tseq_no);\n\tinfo.data_len_off = offsetof(struct hwrm_dbg_coredump_retrieve_output,\n\t\t\t\t     data_len);\n\tif (buf) {\n\t\tinfo.dest_buf = buf + offset;\n\t\tinfo.buf_len = buf_len;\n\t\tinfo.seg_start = offset;\n\t}\n\n\trc = bnxt_hwrm_dbg_dma_data(bp, req, &info);\n\tif (!rc)\n\t\t*seg_len = info.dest_buf_size;\n\n\treturn rc;\n}\n\nstatic void\nbnxt_fill_coredump_seg_hdr(struct bnxt *bp,\n\t\t\t   struct bnxt_coredump_segment_hdr *seg_hdr,\n\t\t\t   struct coredump_segment_record *seg_rec, u32 seg_len,\n\t\t\t   int status, u32 duration, u32 instance)\n{\n\tmemset(seg_hdr, 0, sizeof(*seg_hdr));\n\tmemcpy(seg_hdr->signature, \"sEgM\", 4);\n\tif (seg_rec) {\n\t\tseg_hdr->component_id = (__force __le32)seg_rec->component_id;\n\t\tseg_hdr->segment_id = (__force __le32)seg_rec->segment_id;\n\t\tseg_hdr->low_version = seg_rec->version_low;\n\t\tseg_hdr->high_version = seg_rec->version_hi;\n\t\tseg_hdr->flags = cpu_to_le32(seg_rec->compress_flags);\n\t} else {\n\t\t \n\t\tseg_hdr->component_id = cpu_to_le32(2);\n\t\tseg_hdr->segment_id = 0;\n\t}\n\tseg_hdr->function_id = cpu_to_le16(bp->pdev->devfn);\n\tseg_hdr->length = cpu_to_le32(seg_len);\n\tseg_hdr->status = cpu_to_le32(status);\n\tseg_hdr->duration = cpu_to_le32(duration);\n\tseg_hdr->data_offset = cpu_to_le32(sizeof(*seg_hdr));\n\tseg_hdr->instance = cpu_to_le32(instance);\n}\n\nstatic void bnxt_fill_cmdline(struct bnxt_coredump_record *record)\n{\n\tstruct mm_struct *mm = current->mm;\n\tint i, len, last = 0;\n\n\tif (mm) {\n\t\tlen = min_t(int, mm->arg_end - mm->arg_start,\n\t\t\t    sizeof(record->commandline) - 1);\n\t\tif (len && !copy_from_user(record->commandline,\n\t\t\t\t\t   (char __user *)mm->arg_start, len)) {\n\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\tif (record->commandline[i])\n\t\t\t\t\tlast = i;\n\t\t\t\telse\n\t\t\t\t\trecord->commandline[i] = ' ';\n\t\t\t}\n\t\t\trecord->commandline[last + 1] = 0;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tstrscpy(record->commandline, current->comm, TASK_COMM_LEN);\n}\n\nstatic void\nbnxt_fill_coredump_record(struct bnxt *bp, struct bnxt_coredump_record *record,\n\t\t\t  time64_t start, s16 start_utc, u16 total_segs,\n\t\t\t  int status)\n{\n\ttime64_t end = ktime_get_real_seconds();\n\tu32 os_ver_major = 0, os_ver_minor = 0;\n\tstruct tm tm;\n\n\ttime64_to_tm(start, 0, &tm);\n\tmemset(record, 0, sizeof(*record));\n\tmemcpy(record->signature, \"cOrE\", 4);\n\trecord->flags = 0;\n\trecord->low_version = 0;\n\trecord->high_version = 1;\n\trecord->asic_state = 0;\n\tstrscpy(record->system_name, utsname()->nodename,\n\t\tsizeof(record->system_name));\n\trecord->year = cpu_to_le16(tm.tm_year + 1900);\n\trecord->month = cpu_to_le16(tm.tm_mon + 1);\n\trecord->day = cpu_to_le16(tm.tm_mday);\n\trecord->hour = cpu_to_le16(tm.tm_hour);\n\trecord->minute = cpu_to_le16(tm.tm_min);\n\trecord->second = cpu_to_le16(tm.tm_sec);\n\trecord->utc_bias = cpu_to_le16(start_utc);\n\tbnxt_fill_cmdline(record);\n\trecord->total_segments = cpu_to_le32(total_segs);\n\n\tif (sscanf(utsname()->release, \"%u.%u\", &os_ver_major, &os_ver_minor) != 2)\n\t\tnetdev_warn(bp->dev, \"Unknown OS release in coredump\\n\");\n\trecord->os_ver_major = cpu_to_le32(os_ver_major);\n\trecord->os_ver_minor = cpu_to_le32(os_ver_minor);\n\n\tstrscpy(record->os_name, utsname()->sysname, sizeof(record->os_name));\n\ttime64_to_tm(end, 0, &tm);\n\trecord->end_year = cpu_to_le16(tm.tm_year + 1900);\n\trecord->end_month = cpu_to_le16(tm.tm_mon + 1);\n\trecord->end_day = cpu_to_le16(tm.tm_mday);\n\trecord->end_hour = cpu_to_le16(tm.tm_hour);\n\trecord->end_minute = cpu_to_le16(tm.tm_min);\n\trecord->end_second = cpu_to_le16(tm.tm_sec);\n\trecord->end_utc_bias = cpu_to_le16(sys_tz.tz_minuteswest * 60);\n\trecord->asic_id1 = cpu_to_le32(bp->chip_num << 16 |\n\t\t\t\t       bp->ver_resp.chip_rev << 8 |\n\t\t\t\t       bp->ver_resp.chip_metal);\n\trecord->asic_id2 = 0;\n\trecord->coredump_status = cpu_to_le32(status);\n\trecord->ioctl_low_version = 0;\n\trecord->ioctl_high_version = 0;\n}\n\nstatic int __bnxt_get_coredump(struct bnxt *bp, void *buf, u32 *dump_len)\n{\n\tu32 ver_get_resp_len = sizeof(struct hwrm_ver_get_output);\n\tu32 offset = 0, seg_hdr_len, seg_record_len, buf_len = 0;\n\tstruct coredump_segment_record *seg_record = NULL;\n\tstruct bnxt_coredump_segment_hdr seg_hdr;\n\tstruct bnxt_coredump coredump = {NULL};\n\ttime64_t start_time;\n\tu16 start_utc;\n\tint rc = 0, i;\n\n\tif (buf)\n\t\tbuf_len = *dump_len;\n\n\tstart_time = ktime_get_real_seconds();\n\tstart_utc = sys_tz.tz_minuteswest * 60;\n\tseg_hdr_len = sizeof(seg_hdr);\n\n\t \n\t*dump_len = seg_hdr_len + ver_get_resp_len;\n\tif (buf) {\n\t\tbnxt_fill_coredump_seg_hdr(bp, &seg_hdr, NULL, ver_get_resp_len,\n\t\t\t\t\t   0, 0, 0);\n\t\tmemcpy(buf + offset, &seg_hdr, seg_hdr_len);\n\t\toffset += seg_hdr_len;\n\t\tmemcpy(buf + offset, &bp->ver_resp, ver_get_resp_len);\n\t\toffset += ver_get_resp_len;\n\t}\n\n\trc = bnxt_hwrm_dbg_coredump_list(bp, &coredump);\n\tif (rc) {\n\t\tnetdev_err(bp->dev, \"Failed to get coredump segment list\\n\");\n\t\tgoto err;\n\t}\n\n\t*dump_len += seg_hdr_len * coredump.total_segs;\n\n\tseg_record = (struct coredump_segment_record *)coredump.data;\n\tseg_record_len = sizeof(*seg_record);\n\n\tfor (i = 0; i < coredump.total_segs; i++) {\n\t\tu16 comp_id = le16_to_cpu(seg_record->component_id);\n\t\tu16 seg_id = le16_to_cpu(seg_record->segment_id);\n\t\tu32 duration = 0, seg_len = 0;\n\t\tunsigned long start, end;\n\n\t\tif (buf && ((offset + seg_hdr_len) >\n\t\t\t    BNXT_COREDUMP_BUF_LEN(buf_len))) {\n\t\t\trc = -ENOBUFS;\n\t\t\tgoto err;\n\t\t}\n\n\t\tstart = jiffies;\n\n\t\trc = bnxt_hwrm_dbg_coredump_initiate(bp, comp_id, seg_id);\n\t\tif (rc) {\n\t\t\tnetdev_err(bp->dev,\n\t\t\t\t   \"Failed to initiate coredump for seg = %d\\n\",\n\t\t\t\t   seg_record->segment_id);\n\t\t\tgoto next_seg;\n\t\t}\n\n\t\t \n\t\trc = bnxt_hwrm_dbg_coredump_retrieve(bp, comp_id, seg_id,\n\t\t\t\t\t\t     &seg_len, buf, buf_len,\n\t\t\t\t\t\t     offset + seg_hdr_len);\n\t\tif (rc && rc == -ENOBUFS)\n\t\t\tgoto err;\n\t\telse if (rc)\n\t\t\tnetdev_err(bp->dev,\n\t\t\t\t   \"Failed to retrieve coredump for seg = %d\\n\",\n\t\t\t\t   seg_record->segment_id);\n\nnext_seg:\n\t\tend = jiffies;\n\t\tduration = jiffies_to_msecs(end - start);\n\t\tbnxt_fill_coredump_seg_hdr(bp, &seg_hdr, seg_record, seg_len,\n\t\t\t\t\t   rc, duration, 0);\n\n\t\tif (buf) {\n\t\t\t \n\t\t\tmemcpy(buf + offset, &seg_hdr, seg_hdr_len);\n\t\t\toffset += seg_hdr_len + seg_len;\n\t\t}\n\n\t\t*dump_len += seg_len;\n\t\tseg_record =\n\t\t\t(struct coredump_segment_record *)((u8 *)seg_record +\n\t\t\t\t\t\t\t   seg_record_len);\n\t}\n\nerr:\n\tif (buf)\n\t\tbnxt_fill_coredump_record(bp, buf + offset, start_time,\n\t\t\t\t\t  start_utc, coredump.total_segs + 1,\n\t\t\t\t\t  rc);\n\tkfree(coredump.data);\n\t*dump_len += sizeof(struct bnxt_coredump_record);\n\tif (rc == -ENOBUFS)\n\t\tnetdev_err(bp->dev, \"Firmware returned large coredump buffer\\n\");\n\treturn rc;\n}\n\nint bnxt_get_coredump(struct bnxt *bp, u16 dump_type, void *buf, u32 *dump_len)\n{\n\tif (dump_type == BNXT_DUMP_CRASH) {\n#ifdef CONFIG_TEE_BNXT_FW\n\t\treturn tee_bnxt_copy_coredump(buf, 0, *dump_len);\n#else\n\t\treturn -EOPNOTSUPP;\n#endif\n\t} else {\n\t\treturn __bnxt_get_coredump(bp, buf, dump_len);\n\t}\n}\n\nstatic int bnxt_hwrm_get_dump_len(struct bnxt *bp, u16 dump_type, u32 *dump_len)\n{\n\tstruct hwrm_dbg_qcfg_output *resp;\n\tstruct hwrm_dbg_qcfg_input *req;\n\tint rc, hdr_len = 0;\n\n\tif (!(bp->fw_cap & BNXT_FW_CAP_DBG_QCAPS))\n\t\treturn -EOPNOTSUPP;\n\n\tif (dump_type == BNXT_DUMP_CRASH &&\n\t    !(bp->fw_dbg_cap & DBG_QCAPS_RESP_FLAGS_CRASHDUMP_SOC_DDR))\n\t\treturn -EOPNOTSUPP;\n\n\trc = hwrm_req_init(bp, req, HWRM_DBG_QCFG);\n\tif (rc)\n\t\treturn rc;\n\n\treq->fid = cpu_to_le16(0xffff);\n\tif (dump_type == BNXT_DUMP_CRASH)\n\t\treq->flags = cpu_to_le16(DBG_QCFG_REQ_FLAGS_CRASHDUMP_SIZE_FOR_DEST_DEST_SOC_DDR);\n\n\tresp = hwrm_req_hold(bp, req);\n\trc = hwrm_req_send(bp, req);\n\tif (rc)\n\t\tgoto get_dump_len_exit;\n\n\tif (dump_type == BNXT_DUMP_CRASH) {\n\t\t*dump_len = le32_to_cpu(resp->crashdump_size);\n\t} else {\n\t\t \n\t\thdr_len = sizeof(struct bnxt_coredump_segment_hdr) +\n\t\tsizeof(struct hwrm_ver_get_output) +\n\t\tsizeof(struct bnxt_coredump_record);\n\t\t*dump_len = le32_to_cpu(resp->coredump_size) + hdr_len;\n\t}\n\tif (*dump_len <= hdr_len)\n\t\trc = -EINVAL;\n\nget_dump_len_exit:\n\thwrm_req_drop(bp, req);\n\treturn rc;\n}\n\nu32 bnxt_get_coredump_length(struct bnxt *bp, u16 dump_type)\n{\n\tu32 len = 0;\n\n\tif (bnxt_hwrm_get_dump_len(bp, dump_type, &len)) {\n\t\tif (dump_type == BNXT_DUMP_CRASH)\n\t\t\tlen = BNXT_CRASH_DUMP_LEN;\n\t\telse\n\t\t\t__bnxt_get_coredump(bp, NULL, &len);\n\t}\n\treturn len;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}