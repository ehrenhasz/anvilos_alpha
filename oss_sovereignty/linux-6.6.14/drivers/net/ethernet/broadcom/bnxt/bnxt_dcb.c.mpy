{
  "module_name": "bnxt_dcb.c",
  "hash_id": "a9da47671bfb2ea45e630cb328269835c2303d93c1c79e9350c8eb24d97d4519",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/broadcom/bnxt/bnxt_dcb.c",
  "human_readable_source": " \n\n#include <linux/netdevice.h>\n#include <linux/types.h>\n#include <linux/errno.h>\n#include <linux/rtnetlink.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/etherdevice.h>\n#include <rdma/ib_verbs.h>\n#include \"bnxt_hsi.h\"\n#include \"bnxt.h\"\n#include \"bnxt_hwrm.h\"\n#include \"bnxt_dcb.h\"\n\n#ifdef CONFIG_BNXT_DCB\nstatic int bnxt_queue_to_tc(struct bnxt *bp, u8 queue_id)\n{\n\tint i, j;\n\n\tfor (i = 0; i < bp->max_tc; i++) {\n\t\tif (bp->q_info[i].queue_id == queue_id) {\n\t\t\tfor (j = 0; j < bp->max_tc; j++) {\n\t\t\t\tif (bp->tc_to_qidx[j] == i)\n\t\t\t\t\treturn j;\n\t\t\t}\n\t\t}\n\t}\n\treturn -EINVAL;\n}\n\nstatic int bnxt_hwrm_queue_pri2cos_cfg(struct bnxt *bp, struct ieee_ets *ets)\n{\n\tstruct hwrm_queue_pri2cos_cfg_input *req;\n\tu8 *pri2cos;\n\tint rc, i;\n\n\trc = hwrm_req_init(bp, req, HWRM_QUEUE_PRI2COS_CFG);\n\tif (rc)\n\t\treturn rc;\n\n\treq->flags = cpu_to_le32(QUEUE_PRI2COS_CFG_REQ_FLAGS_PATH_BIDIR |\n\t\t\t\t QUEUE_PRI2COS_CFG_REQ_FLAGS_IVLAN);\n\n\tpri2cos = &req->pri0_cos_queue_id;\n\tfor (i = 0; i < IEEE_8021QAZ_MAX_TCS; i++) {\n\t\tu8 qidx;\n\n\t\treq->enables |= cpu_to_le32(\n\t\t\tQUEUE_PRI2COS_CFG_REQ_ENABLES_PRI0_COS_QUEUE_ID << i);\n\n\t\tqidx = bp->tc_to_qidx[ets->prio_tc[i]];\n\t\tpri2cos[i] = bp->q_info[qidx].queue_id;\n\t}\n\treturn hwrm_req_send(bp, req);\n}\n\nstatic int bnxt_hwrm_queue_pri2cos_qcfg(struct bnxt *bp, struct ieee_ets *ets)\n{\n\tstruct hwrm_queue_pri2cos_qcfg_output *resp;\n\tstruct hwrm_queue_pri2cos_qcfg_input *req;\n\tint rc;\n\n\trc = hwrm_req_init(bp, req, HWRM_QUEUE_PRI2COS_QCFG);\n\tif (rc)\n\t\treturn rc;\n\n\treq->flags = cpu_to_le32(QUEUE_PRI2COS_QCFG_REQ_FLAGS_IVLAN);\n\tresp = hwrm_req_hold(bp, req);\n\trc = hwrm_req_send(bp, req);\n\tif (!rc) {\n\t\tu8 *pri2cos = &resp->pri0_cos_queue_id;\n\t\tint i;\n\n\t\tfor (i = 0; i < IEEE_8021QAZ_MAX_TCS; i++) {\n\t\t\tu8 queue_id = pri2cos[i];\n\t\t\tint tc;\n\n\t\t\ttc = bnxt_queue_to_tc(bp, queue_id);\n\t\t\tif (tc >= 0)\n\t\t\t\tets->prio_tc[i] = tc;\n\t\t}\n\t}\n\thwrm_req_drop(bp, req);\n\treturn rc;\n}\n\nstatic int bnxt_hwrm_queue_cos2bw_cfg(struct bnxt *bp, struct ieee_ets *ets,\n\t\t\t\t      u8 max_tc)\n{\n\tstruct hwrm_queue_cos2bw_cfg_input *req;\n\tstruct bnxt_cos2bw_cfg cos2bw;\n\tint rc, i;\n\n\trc = hwrm_req_init(bp, req, HWRM_QUEUE_COS2BW_CFG);\n\tif (rc)\n\t\treturn rc;\n\n\tfor (i = 0; i < max_tc; i++) {\n\t\tu8 qidx = bp->tc_to_qidx[i];\n\n\t\treq->enables |= cpu_to_le32(\n\t\t\tQUEUE_COS2BW_CFG_REQ_ENABLES_COS_QUEUE_ID0_VALID <<\n\t\t\tqidx);\n\n\t\tmemset(&cos2bw, 0, sizeof(cos2bw));\n\t\tcos2bw.queue_id = bp->q_info[qidx].queue_id;\n\t\tif (ets->tc_tsa[i] == IEEE_8021QAZ_TSA_STRICT) {\n\t\t\tcos2bw.tsa =\n\t\t\t\tQUEUE_COS2BW_QCFG_RESP_QUEUE_ID0_TSA_ASSIGN_SP;\n\t\t\tcos2bw.pri_lvl = i;\n\t\t} else {\n\t\t\tcos2bw.tsa =\n\t\t\t\tQUEUE_COS2BW_QCFG_RESP_QUEUE_ID0_TSA_ASSIGN_ETS;\n\t\t\tcos2bw.bw_weight = ets->tc_tx_bw[i];\n\t\t\t \n\t\t\tcos2bw.min_bw =\n\t\t\t\tcpu_to_le32((ets->tc_tx_bw[i] * 100) |\n\t\t\t\t\t    BW_VALUE_UNIT_PERCENT1_100);\n\t\t}\n\t\tif (qidx == 0) {\n\t\t\treq->queue_id0 = cos2bw.queue_id;\n\t\t\treq->queue_id0_min_bw = cos2bw.min_bw;\n\t\t\treq->queue_id0_max_bw = cos2bw.max_bw;\n\t\t\treq->queue_id0_tsa_assign = cos2bw.tsa;\n\t\t\treq->queue_id0_pri_lvl = cos2bw.pri_lvl;\n\t\t\treq->queue_id0_bw_weight = cos2bw.bw_weight;\n\t\t} else {\n\t\t\tmemcpy(&req->cfg[i - 1], &cos2bw.cfg, sizeof(cos2bw.cfg));\n\t\t}\n\t}\n\treturn hwrm_req_send(bp, req);\n}\n\nstatic int bnxt_hwrm_queue_cos2bw_qcfg(struct bnxt *bp, struct ieee_ets *ets)\n{\n\tstruct hwrm_queue_cos2bw_qcfg_output *resp;\n\tstruct hwrm_queue_cos2bw_qcfg_input *req;\n\tstruct bnxt_cos2bw_cfg cos2bw;\n\tint rc, i;\n\n\trc = hwrm_req_init(bp, req, HWRM_QUEUE_COS2BW_QCFG);\n\tif (rc)\n\t\treturn rc;\n\n\tresp = hwrm_req_hold(bp, req);\n\trc = hwrm_req_send(bp, req);\n\tif (rc) {\n\t\thwrm_req_drop(bp, req);\n\t\treturn rc;\n\t}\n\n\tfor (i = 0; i < bp->max_tc; i++) {\n\t\tint tc;\n\n\t\tif (i == 0) {\n\t\t\tcos2bw.queue_id = resp->queue_id0;\n\t\t\tcos2bw.min_bw = resp->queue_id0_min_bw;\n\t\t\tcos2bw.max_bw = resp->queue_id0_max_bw;\n\t\t\tcos2bw.tsa = resp->queue_id0_tsa_assign;\n\t\t\tcos2bw.pri_lvl = resp->queue_id0_pri_lvl;\n\t\t\tcos2bw.bw_weight = resp->queue_id0_bw_weight;\n\t\t} else {\n\t\t\tmemcpy(&cos2bw.cfg, &resp->cfg[i - 1], sizeof(cos2bw.cfg));\n\t\t}\n\n\t\ttc = bnxt_queue_to_tc(bp, cos2bw.queue_id);\n\t\tif (tc < 0)\n\t\t\tcontinue;\n\n\t\tif (cos2bw.tsa ==\n\t\t    QUEUE_COS2BW_QCFG_RESP_QUEUE_ID0_TSA_ASSIGN_SP) {\n\t\t\tets->tc_tsa[tc] = IEEE_8021QAZ_TSA_STRICT;\n\t\t} else {\n\t\t\tets->tc_tsa[tc] = IEEE_8021QAZ_TSA_ETS;\n\t\t\tets->tc_tx_bw[tc] = cos2bw.bw_weight;\n\t\t}\n\t}\n\thwrm_req_drop(bp, req);\n\treturn 0;\n}\n\nstatic int bnxt_queue_remap(struct bnxt *bp, unsigned int lltc_mask)\n{\n\tunsigned long qmap = 0;\n\tint max = bp->max_tc;\n\tint i, j, rc;\n\n\t \n\tfor (i = 0, j = 0; i < max; ) {\n\t\tif (lltc_mask & (1 << i)) {\n\t\t\tif (BNXT_LLQ(bp->q_info[j].queue_profile)) {\n\t\t\t\tbp->tc_to_qidx[i] = j;\n\t\t\t\t__set_bit(j, &qmap);\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tj++;\n\t\t\tcontinue;\n\t\t}\n\t\ti++;\n\t}\n\n\tfor (i = 0, j = 0; i < max; i++) {\n\t\tif (lltc_mask & (1 << i))\n\t\t\tcontinue;\n\t\tj = find_next_zero_bit(&qmap, max, j);\n\t\tbp->tc_to_qidx[i] = j;\n\t\t__set_bit(j, &qmap);\n\t\tj++;\n\t}\n\n\tif (netif_running(bp->dev)) {\n\t\tbnxt_close_nic(bp, false, false);\n\t\trc = bnxt_open_nic(bp, false, false);\n\t\tif (rc) {\n\t\t\tnetdev_warn(bp->dev, \"failed to open NIC, rc = %d\\n\", rc);\n\t\t\treturn rc;\n\t\t}\n\t}\n\tif (bp->ieee_ets) {\n\t\tint tc = netdev_get_num_tc(bp->dev);\n\n\t\tif (!tc)\n\t\t\ttc = 1;\n\t\trc = bnxt_hwrm_queue_cos2bw_cfg(bp, bp->ieee_ets, tc);\n\t\tif (rc) {\n\t\t\tnetdev_warn(bp->dev, \"failed to config BW, rc = %d\\n\", rc);\n\t\t\treturn rc;\n\t\t}\n\t\trc = bnxt_hwrm_queue_pri2cos_cfg(bp, bp->ieee_ets);\n\t\tif (rc) {\n\t\t\tnetdev_warn(bp->dev, \"failed to config prio, rc = %d\\n\", rc);\n\t\t\treturn rc;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int bnxt_hwrm_queue_pfc_cfg(struct bnxt *bp, struct ieee_pfc *pfc)\n{\n\tstruct hwrm_queue_pfcenable_cfg_input *req;\n\tstruct ieee_ets *my_ets = bp->ieee_ets;\n\tunsigned int tc_mask = 0, pri_mask = 0;\n\tu8 i, pri, lltc_count = 0;\n\tbool need_q_remap = false;\n\tint rc;\n\n\tif (!my_ets)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < bp->max_tc; i++) {\n\t\tfor (pri = 0; pri < IEEE_8021QAZ_MAX_TCS; pri++) {\n\t\t\tif ((pfc->pfc_en & (1 << pri)) &&\n\t\t\t    (my_ets->prio_tc[pri] == i)) {\n\t\t\t\tpri_mask |= 1 << pri;\n\t\t\t\ttc_mask |= 1 << i;\n\t\t\t}\n\t\t}\n\t\tif (tc_mask & (1 << i))\n\t\t\tlltc_count++;\n\t}\n\tif (lltc_count > bp->max_lltc)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < bp->max_tc; i++) {\n\t\tif (tc_mask & (1 << i)) {\n\t\t\tu8 qidx = bp->tc_to_qidx[i];\n\n\t\t\tif (!BNXT_LLQ(bp->q_info[qidx].queue_profile)) {\n\t\t\t\tneed_q_remap = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (need_q_remap)\n\t\tbnxt_queue_remap(bp, tc_mask);\n\n\trc = hwrm_req_init(bp, req, HWRM_QUEUE_PFCENABLE_CFG);\n\tif (rc)\n\t\treturn rc;\n\n\treq->flags = cpu_to_le32(pri_mask);\n\treturn hwrm_req_send(bp, req);\n}\n\nstatic int bnxt_hwrm_queue_pfc_qcfg(struct bnxt *bp, struct ieee_pfc *pfc)\n{\n\tstruct hwrm_queue_pfcenable_qcfg_output *resp;\n\tstruct hwrm_queue_pfcenable_qcfg_input *req;\n\tu8 pri_mask;\n\tint rc;\n\n\trc = hwrm_req_init(bp, req, HWRM_QUEUE_PFCENABLE_QCFG);\n\tif (rc)\n\t\treturn rc;\n\n\tresp = hwrm_req_hold(bp, req);\n\trc = hwrm_req_send(bp, req);\n\tif (rc) {\n\t\thwrm_req_drop(bp, req);\n\t\treturn rc;\n\t}\n\n\tpri_mask = le32_to_cpu(resp->flags);\n\tpfc->pfc_en = pri_mask;\n\thwrm_req_drop(bp, req);\n\treturn 0;\n}\n\nstatic int bnxt_hwrm_set_dcbx_app(struct bnxt *bp, struct dcb_app *app,\n\t\t\t\t  bool add)\n{\n\tstruct hwrm_fw_set_structured_data_input *set;\n\tstruct hwrm_fw_get_structured_data_input *get;\n\tstruct hwrm_struct_data_dcbx_app *fw_app;\n\tstruct hwrm_struct_hdr *data;\n\tdma_addr_t mapping;\n\tsize_t data_len;\n\tint rc, n, i;\n\n\tif (bp->hwrm_spec_code < 0x10601)\n\t\treturn 0;\n\n\trc = hwrm_req_init(bp, get, HWRM_FW_GET_STRUCTURED_DATA);\n\tif (rc)\n\t\treturn rc;\n\n\thwrm_req_hold(bp, get);\n\thwrm_req_alloc_flags(bp, get, GFP_KERNEL | __GFP_ZERO);\n\n\tn = IEEE_8021QAZ_MAX_TCS;\n\tdata_len = sizeof(*data) + sizeof(*fw_app) * n;\n\tdata = hwrm_req_dma_slice(bp, get, data_len, &mapping);\n\tif (!data) {\n\t\trc = -ENOMEM;\n\t\tgoto set_app_exit;\n\t}\n\n\tget->dest_data_addr = cpu_to_le64(mapping);\n\tget->structure_id = cpu_to_le16(STRUCT_HDR_STRUCT_ID_DCBX_APP);\n\tget->subtype = cpu_to_le16(HWRM_STRUCT_DATA_SUBTYPE_HOST_OPERATIONAL);\n\tget->count = 0;\n\trc = hwrm_req_send(bp, get);\n\tif (rc)\n\t\tgoto set_app_exit;\n\n\tfw_app = (struct hwrm_struct_data_dcbx_app *)(data + 1);\n\n\tif (data->struct_id != cpu_to_le16(STRUCT_HDR_STRUCT_ID_DCBX_APP)) {\n\t\trc = -ENODEV;\n\t\tgoto set_app_exit;\n\t}\n\n\tn = data->count;\n\tfor (i = 0; i < n; i++, fw_app++) {\n\t\tif (fw_app->protocol_id == cpu_to_be16(app->protocol) &&\n\t\t    fw_app->protocol_selector == app->selector &&\n\t\t    fw_app->priority == app->priority) {\n\t\t\tif (add)\n\t\t\t\tgoto set_app_exit;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tif (add) {\n\t\t \n\t\tn++;\n\t\tfw_app->protocol_id = cpu_to_be16(app->protocol);\n\t\tfw_app->protocol_selector = app->selector;\n\t\tfw_app->priority = app->priority;\n\t\tfw_app->valid = 1;\n\t} else {\n\t\tsize_t len = 0;\n\n\t\t \n\t\tif (n == i)\n\t\t\tgoto set_app_exit;\n\n\t\tlen = (n - 1 - i) * sizeof(*fw_app);\n\t\tif (len)\n\t\t\tmemmove(fw_app, fw_app + 1, len);\n\t\tn--;\n\t\tmemset(fw_app + n, 0, sizeof(*fw_app));\n\t}\n\tdata->count = n;\n\tdata->len = cpu_to_le16(sizeof(*fw_app) * n);\n\tdata->subtype = cpu_to_le16(HWRM_STRUCT_DATA_SUBTYPE_HOST_OPERATIONAL);\n\n\trc = hwrm_req_init(bp, set, HWRM_FW_SET_STRUCTURED_DATA);\n\tif (rc)\n\t\tgoto set_app_exit;\n\n\tset->src_data_addr = cpu_to_le64(mapping);\n\tset->data_len = cpu_to_le16(sizeof(*data) + sizeof(*fw_app) * n);\n\tset->hdr_cnt = 1;\n\trc = hwrm_req_send(bp, set);\n\nset_app_exit:\n\thwrm_req_drop(bp, get);  \n\treturn rc;\n}\n\nstatic int bnxt_hwrm_queue_dscp_qcaps(struct bnxt *bp)\n{\n\tstruct hwrm_queue_dscp_qcaps_output *resp;\n\tstruct hwrm_queue_dscp_qcaps_input *req;\n\tint rc;\n\n\tbp->max_dscp_value = 0;\n\tif (bp->hwrm_spec_code < 0x10800 || BNXT_VF(bp))\n\t\treturn 0;\n\n\trc = hwrm_req_init(bp, req, HWRM_QUEUE_DSCP_QCAPS);\n\tif (rc)\n\t\treturn rc;\n\n\tresp = hwrm_req_hold(bp, req);\n\trc = hwrm_req_send_silent(bp, req);\n\tif (!rc) {\n\t\tbp->max_dscp_value = (1 << resp->num_dscp_bits) - 1;\n\t\tif (bp->max_dscp_value < 0x3f)\n\t\t\tbp->max_dscp_value = 0;\n\t}\n\thwrm_req_drop(bp, req);\n\treturn rc;\n}\n\nstatic int bnxt_hwrm_queue_dscp2pri_cfg(struct bnxt *bp, struct dcb_app *app,\n\t\t\t\t\tbool add)\n{\n\tstruct hwrm_queue_dscp2pri_cfg_input *req;\n\tstruct bnxt_dscp2pri_entry *dscp2pri;\n\tdma_addr_t mapping;\n\tint rc;\n\n\tif (bp->hwrm_spec_code < 0x10800)\n\t\treturn 0;\n\n\trc = hwrm_req_init(bp, req, HWRM_QUEUE_DSCP2PRI_CFG);\n\tif (rc)\n\t\treturn rc;\n\n\tdscp2pri = hwrm_req_dma_slice(bp, req, sizeof(*dscp2pri), &mapping);\n\tif (!dscp2pri) {\n\t\thwrm_req_drop(bp, req);\n\t\treturn -ENOMEM;\n\t}\n\n\treq->src_data_addr = cpu_to_le64(mapping);\n\tdscp2pri->dscp = app->protocol;\n\tif (add)\n\t\tdscp2pri->mask = 0x3f;\n\telse\n\t\tdscp2pri->mask = 0;\n\tdscp2pri->pri = app->priority;\n\treq->entry_cnt = cpu_to_le16(1);\n\trc = hwrm_req_send(bp, req);\n\treturn rc;\n}\n\nstatic int bnxt_ets_validate(struct bnxt *bp, struct ieee_ets *ets, u8 *tc)\n{\n\tint total_ets_bw = 0;\n\tbool zero = false;\n\tu8 max_tc = 0;\n\tint i;\n\n\tfor (i = 0; i < IEEE_8021QAZ_MAX_TCS; i++) {\n\t\tif (ets->prio_tc[i] > bp->max_tc) {\n\t\t\tnetdev_err(bp->dev, \"priority to TC mapping exceeds TC count %d\\n\",\n\t\t\t\t   ets->prio_tc[i]);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (ets->prio_tc[i] > max_tc)\n\t\t\tmax_tc = ets->prio_tc[i];\n\n\t\tif ((ets->tc_tx_bw[i] || ets->tc_tsa[i]) && i > bp->max_tc)\n\t\t\treturn -EINVAL;\n\n\t\tswitch (ets->tc_tsa[i]) {\n\t\tcase IEEE_8021QAZ_TSA_STRICT:\n\t\t\tbreak;\n\t\tcase IEEE_8021QAZ_TSA_ETS:\n\t\t\ttotal_ets_bw += ets->tc_tx_bw[i];\n\t\t\tzero = zero || !ets->tc_tx_bw[i];\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -ENOTSUPP;\n\t\t}\n\t}\n\tif (total_ets_bw > 100) {\n\t\tnetdev_warn(bp->dev, \"rejecting ETS config exceeding available bandwidth\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (zero && total_ets_bw == 100) {\n\t\tnetdev_warn(bp->dev, \"rejecting ETS config starving a TC\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (max_tc >= bp->max_tc)\n\t\t*tc = bp->max_tc;\n\telse\n\t\t*tc = max_tc + 1;\n\treturn 0;\n}\n\nstatic int bnxt_dcbnl_ieee_getets(struct net_device *dev, struct ieee_ets *ets)\n{\n\tstruct bnxt *bp = netdev_priv(dev);\n\tstruct ieee_ets *my_ets = bp->ieee_ets;\n\tint rc;\n\n\tets->ets_cap = bp->max_tc;\n\n\tif (!my_ets) {\n\t\tif (bp->dcbx_cap & DCB_CAP_DCBX_HOST)\n\t\t\treturn 0;\n\n\t\tmy_ets = kzalloc(sizeof(*my_ets), GFP_KERNEL);\n\t\tif (!my_ets)\n\t\t\treturn -ENOMEM;\n\t\trc = bnxt_hwrm_queue_cos2bw_qcfg(bp, my_ets);\n\t\tif (rc)\n\t\t\tgoto error;\n\t\trc = bnxt_hwrm_queue_pri2cos_qcfg(bp, my_ets);\n\t\tif (rc)\n\t\t\tgoto error;\n\n\t\t \n\t\tbp->ieee_ets = my_ets;\n\t}\n\n\tets->cbs = my_ets->cbs;\n\tmemcpy(ets->tc_tx_bw, my_ets->tc_tx_bw, sizeof(ets->tc_tx_bw));\n\tmemcpy(ets->tc_rx_bw, my_ets->tc_rx_bw, sizeof(ets->tc_rx_bw));\n\tmemcpy(ets->tc_tsa, my_ets->tc_tsa, sizeof(ets->tc_tsa));\n\tmemcpy(ets->prio_tc, my_ets->prio_tc, sizeof(ets->prio_tc));\n\treturn 0;\nerror:\n\tkfree(my_ets);\n\treturn rc;\n}\n\nstatic int bnxt_dcbnl_ieee_setets(struct net_device *dev, struct ieee_ets *ets)\n{\n\tstruct bnxt *bp = netdev_priv(dev);\n\tstruct ieee_ets *my_ets = bp->ieee_ets;\n\tu8 max_tc = 0;\n\tint rc, i;\n\n\tif (!(bp->dcbx_cap & DCB_CAP_DCBX_VER_IEEE) ||\n\t    !(bp->dcbx_cap & DCB_CAP_DCBX_HOST))\n\t\treturn -EINVAL;\n\n\trc = bnxt_ets_validate(bp, ets, &max_tc);\n\tif (!rc) {\n\t\tif (!my_ets) {\n\t\t\tmy_ets = kzalloc(sizeof(*my_ets), GFP_KERNEL);\n\t\t\tif (!my_ets)\n\t\t\t\treturn -ENOMEM;\n\t\t\t \n\t\t\tfor (i = 0; i < IEEE_8021QAZ_MAX_TCS; i++)\n\t\t\t\tmy_ets->prio_tc[i] = IEEE_8021QAZ_MAX_TCS;\n\t\t\tbp->ieee_ets = my_ets;\n\t\t}\n\t\trc = bnxt_setup_mq_tc(dev, max_tc);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\trc = bnxt_hwrm_queue_cos2bw_cfg(bp, ets, max_tc);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\trc = bnxt_hwrm_queue_pri2cos_cfg(bp, ets);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tmemcpy(my_ets, ets, sizeof(*my_ets));\n\t}\n\treturn rc;\n}\n\nstatic int bnxt_dcbnl_ieee_getpfc(struct net_device *dev, struct ieee_pfc *pfc)\n{\n\tstruct bnxt *bp = netdev_priv(dev);\n\t__le64 *stats = bp->port_stats.hw_stats;\n\tstruct ieee_pfc *my_pfc = bp->ieee_pfc;\n\tlong rx_off, tx_off;\n\tint i, rc;\n\n\tpfc->pfc_cap = bp->max_lltc;\n\n\tif (!my_pfc) {\n\t\tif (bp->dcbx_cap & DCB_CAP_DCBX_HOST)\n\t\t\treturn 0;\n\n\t\tmy_pfc = kzalloc(sizeof(*my_pfc), GFP_KERNEL);\n\t\tif (!my_pfc)\n\t\t\treturn 0;\n\t\tbp->ieee_pfc = my_pfc;\n\t\trc = bnxt_hwrm_queue_pfc_qcfg(bp, my_pfc);\n\t\tif (rc)\n\t\t\treturn 0;\n\t}\n\n\tpfc->pfc_en = my_pfc->pfc_en;\n\tpfc->mbc = my_pfc->mbc;\n\tpfc->delay = my_pfc->delay;\n\n\tif (!stats)\n\t\treturn 0;\n\n\trx_off = BNXT_RX_STATS_OFFSET(rx_pfc_ena_frames_pri0);\n\ttx_off = BNXT_TX_STATS_OFFSET(tx_pfc_ena_frames_pri0);\n\tfor (i = 0; i < IEEE_8021QAZ_MAX_TCS; i++, rx_off++, tx_off++) {\n\t\tpfc->requests[i] = le64_to_cpu(*(stats + tx_off));\n\t\tpfc->indications[i] = le64_to_cpu(*(stats + rx_off));\n\t}\n\n\treturn 0;\n}\n\nstatic int bnxt_dcbnl_ieee_setpfc(struct net_device *dev, struct ieee_pfc *pfc)\n{\n\tstruct bnxt *bp = netdev_priv(dev);\n\tstruct ieee_pfc *my_pfc = bp->ieee_pfc;\n\tint rc;\n\n\tif (!(bp->dcbx_cap & DCB_CAP_DCBX_VER_IEEE) ||\n\t    !(bp->dcbx_cap & DCB_CAP_DCBX_HOST) ||\n\t    (bp->phy_flags & BNXT_PHY_FL_NO_PAUSE))\n\t\treturn -EINVAL;\n\n\tif (!my_pfc) {\n\t\tmy_pfc = kzalloc(sizeof(*my_pfc), GFP_KERNEL);\n\t\tif (!my_pfc)\n\t\t\treturn -ENOMEM;\n\t\tbp->ieee_pfc = my_pfc;\n\t}\n\trc = bnxt_hwrm_queue_pfc_cfg(bp, pfc);\n\tif (!rc)\n\t\tmemcpy(my_pfc, pfc, sizeof(*my_pfc));\n\n\treturn rc;\n}\n\nstatic int bnxt_dcbnl_ieee_dscp_app_prep(struct bnxt *bp, struct dcb_app *app)\n{\n\tif (app->selector == IEEE_8021QAZ_APP_SEL_DSCP) {\n\t\tif (!bp->max_dscp_value)\n\t\t\treturn -ENOTSUPP;\n\t\tif (app->protocol > bp->max_dscp_value)\n\t\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int bnxt_dcbnl_ieee_setapp(struct net_device *dev, struct dcb_app *app)\n{\n\tstruct bnxt *bp = netdev_priv(dev);\n\tint rc;\n\n\tif (!(bp->dcbx_cap & DCB_CAP_DCBX_VER_IEEE) ||\n\t    !(bp->dcbx_cap & DCB_CAP_DCBX_HOST))\n\t\treturn -EINVAL;\n\n\trc = bnxt_dcbnl_ieee_dscp_app_prep(bp, app);\n\tif (rc)\n\t\treturn rc;\n\n\trc = dcb_ieee_setapp(dev, app);\n\tif (rc)\n\t\treturn rc;\n\n\tif ((app->selector == IEEE_8021QAZ_APP_SEL_ETHERTYPE &&\n\t     app->protocol == ETH_P_IBOE) ||\n\t    (app->selector == IEEE_8021QAZ_APP_SEL_DGRAM &&\n\t     app->protocol == ROCE_V2_UDP_DPORT))\n\t\trc = bnxt_hwrm_set_dcbx_app(bp, app, true);\n\n\tif (app->selector == IEEE_8021QAZ_APP_SEL_DSCP)\n\t\trc = bnxt_hwrm_queue_dscp2pri_cfg(bp, app, true);\n\n\treturn rc;\n}\n\nstatic int bnxt_dcbnl_ieee_delapp(struct net_device *dev, struct dcb_app *app)\n{\n\tstruct bnxt *bp = netdev_priv(dev);\n\tint rc;\n\n\tif (!(bp->dcbx_cap & DCB_CAP_DCBX_VER_IEEE) ||\n\t    !(bp->dcbx_cap & DCB_CAP_DCBX_HOST))\n\t\treturn -EINVAL;\n\n\trc = bnxt_dcbnl_ieee_dscp_app_prep(bp, app);\n\tif (rc)\n\t\treturn rc;\n\n\trc = dcb_ieee_delapp(dev, app);\n\tif (rc)\n\t\treturn rc;\n\tif ((app->selector == IEEE_8021QAZ_APP_SEL_ETHERTYPE &&\n\t     app->protocol == ETH_P_IBOE) ||\n\t    (app->selector == IEEE_8021QAZ_APP_SEL_DGRAM &&\n\t     app->protocol == ROCE_V2_UDP_DPORT))\n\t\trc = bnxt_hwrm_set_dcbx_app(bp, app, false);\n\n\tif (app->selector == IEEE_8021QAZ_APP_SEL_DSCP)\n\t\trc = bnxt_hwrm_queue_dscp2pri_cfg(bp, app, false);\n\n\treturn rc;\n}\n\nstatic u8 bnxt_dcbnl_getdcbx(struct net_device *dev)\n{\n\tstruct bnxt *bp = netdev_priv(dev);\n\n\treturn bp->dcbx_cap;\n}\n\nstatic u8 bnxt_dcbnl_setdcbx(struct net_device *dev, u8 mode)\n{\n\tstruct bnxt *bp = netdev_priv(dev);\n\n\t \n\tif (bp->dcbx_cap & DCB_CAP_DCBX_LLD_MANAGED)\n\t\treturn 1;\n\n\tif (mode & DCB_CAP_DCBX_HOST) {\n\t\tif (BNXT_VF(bp) || (bp->fw_cap & BNXT_FW_CAP_LLDP_AGENT))\n\t\t\treturn 1;\n\n\t\t \n\t\tif ((mode & DCB_CAP_DCBX_VER_CEE) ||\n\t\t    !(mode & DCB_CAP_DCBX_VER_IEEE))\n\t\t\treturn 1;\n\t}\n\n\tif (mode == bp->dcbx_cap)\n\t\treturn 0;\n\n\tbp->dcbx_cap = mode;\n\treturn 0;\n}\n\nstatic const struct dcbnl_rtnl_ops dcbnl_ops = {\n\t.ieee_getets\t= bnxt_dcbnl_ieee_getets,\n\t.ieee_setets\t= bnxt_dcbnl_ieee_setets,\n\t.ieee_getpfc\t= bnxt_dcbnl_ieee_getpfc,\n\t.ieee_setpfc\t= bnxt_dcbnl_ieee_setpfc,\n\t.ieee_setapp\t= bnxt_dcbnl_ieee_setapp,\n\t.ieee_delapp\t= bnxt_dcbnl_ieee_delapp,\n\t.getdcbx\t= bnxt_dcbnl_getdcbx,\n\t.setdcbx\t= bnxt_dcbnl_setdcbx,\n};\n\nvoid bnxt_dcb_init(struct bnxt *bp)\n{\n\tbp->dcbx_cap = 0;\n\tif (bp->hwrm_spec_code < 0x10501)\n\t\treturn;\n\n\tbnxt_hwrm_queue_dscp_qcaps(bp);\n\tbp->dcbx_cap = DCB_CAP_DCBX_VER_IEEE;\n\tif (BNXT_PF(bp) && !(bp->fw_cap & BNXT_FW_CAP_LLDP_AGENT))\n\t\tbp->dcbx_cap |= DCB_CAP_DCBX_HOST;\n\telse if (bp->fw_cap & BNXT_FW_CAP_DCBX_AGENT)\n\t\tbp->dcbx_cap |= DCB_CAP_DCBX_LLD_MANAGED;\n\tbp->dev->dcbnl_ops = &dcbnl_ops;\n}\n\nvoid bnxt_dcb_free(struct bnxt *bp)\n{\n\tkfree(bp->ieee_pfc);\n\tkfree(bp->ieee_ets);\n\tbp->ieee_pfc = NULL;\n\tbp->ieee_ets = NULL;\n}\n\n#else\n\nvoid bnxt_dcb_init(struct bnxt *bp)\n{\n}\n\nvoid bnxt_dcb_free(struct bnxt *bp)\n{\n}\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}