{
  "module_name": "bnxt_ethtool.c",
  "hash_id": "60e6ba068c5b37814f10773e3704e5b6f6dfc717971f394f468c91f85c417e72",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/broadcom/bnxt/bnxt_ethtool.c",
  "human_readable_source": " \n\n#include <linux/ctype.h>\n#include <linux/stringify.h>\n#include <linux/ethtool.h>\n#include <linux/ethtool_netlink.h>\n#include <linux/linkmode.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/etherdevice.h>\n#include <linux/crc32.h>\n#include <linux/firmware.h>\n#include <linux/utsname.h>\n#include <linux/time.h>\n#include <linux/ptp_clock_kernel.h>\n#include <linux/net_tstamp.h>\n#include <linux/timecounter.h>\n#include <net/netlink.h>\n#include \"bnxt_hsi.h\"\n#include \"bnxt.h\"\n#include \"bnxt_hwrm.h\"\n#include \"bnxt_ulp.h\"\n#include \"bnxt_xdp.h\"\n#include \"bnxt_ptp.h\"\n#include \"bnxt_ethtool.h\"\n#include \"bnxt_nvm_defs.h\"\t \n#include \"bnxt_fw_hdr.h\"\t \n#include \"bnxt_coredump.h\"\n\n#define BNXT_NVM_ERR_MSG(dev, extack, msg)\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\\\n\t\tif (extack)\t\t\t\t\t\\\n\t\t\tNL_SET_ERR_MSG_MOD(extack, msg);\t\\\n\t\tnetdev_err(dev, \"%s\\n\", msg);\t\t\t\\\n\t} while (0)\n\nstatic u32 bnxt_get_msglevel(struct net_device *dev)\n{\n\tstruct bnxt *bp = netdev_priv(dev);\n\n\treturn bp->msg_enable;\n}\n\nstatic void bnxt_set_msglevel(struct net_device *dev, u32 value)\n{\n\tstruct bnxt *bp = netdev_priv(dev);\n\n\tbp->msg_enable = value;\n}\n\nstatic int bnxt_get_coalesce(struct net_device *dev,\n\t\t\t     struct ethtool_coalesce *coal,\n\t\t\t     struct kernel_ethtool_coalesce *kernel_coal,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct bnxt *bp = netdev_priv(dev);\n\tstruct bnxt_coal *hw_coal;\n\tu16 mult;\n\n\tmemset(coal, 0, sizeof(*coal));\n\n\tcoal->use_adaptive_rx_coalesce = bp->flags & BNXT_FLAG_DIM;\n\n\thw_coal = &bp->rx_coal;\n\tmult = hw_coal->bufs_per_record;\n\tcoal->rx_coalesce_usecs = hw_coal->coal_ticks;\n\tcoal->rx_max_coalesced_frames = hw_coal->coal_bufs / mult;\n\tcoal->rx_coalesce_usecs_irq = hw_coal->coal_ticks_irq;\n\tcoal->rx_max_coalesced_frames_irq = hw_coal->coal_bufs_irq / mult;\n\tif (hw_coal->flags &\n\t    RING_CMPL_RING_CFG_AGGINT_PARAMS_REQ_FLAGS_TIMER_RESET)\n\t\tkernel_coal->use_cqe_mode_rx = true;\n\n\thw_coal = &bp->tx_coal;\n\tmult = hw_coal->bufs_per_record;\n\tcoal->tx_coalesce_usecs = hw_coal->coal_ticks;\n\tcoal->tx_max_coalesced_frames = hw_coal->coal_bufs / mult;\n\tcoal->tx_coalesce_usecs_irq = hw_coal->coal_ticks_irq;\n\tcoal->tx_max_coalesced_frames_irq = hw_coal->coal_bufs_irq / mult;\n\tif (hw_coal->flags &\n\t    RING_CMPL_RING_CFG_AGGINT_PARAMS_REQ_FLAGS_TIMER_RESET)\n\t\tkernel_coal->use_cqe_mode_tx = true;\n\n\tcoal->stats_block_coalesce_usecs = bp->stats_coal_ticks;\n\n\treturn 0;\n}\n\nstatic int bnxt_set_coalesce(struct net_device *dev,\n\t\t\t     struct ethtool_coalesce *coal,\n\t\t\t     struct kernel_ethtool_coalesce *kernel_coal,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct bnxt *bp = netdev_priv(dev);\n\tbool update_stats = false;\n\tstruct bnxt_coal *hw_coal;\n\tint rc = 0;\n\tu16 mult;\n\n\tif (coal->use_adaptive_rx_coalesce) {\n\t\tbp->flags |= BNXT_FLAG_DIM;\n\t} else {\n\t\tif (bp->flags & BNXT_FLAG_DIM) {\n\t\t\tbp->flags &= ~(BNXT_FLAG_DIM);\n\t\t\tgoto reset_coalesce;\n\t\t}\n\t}\n\n\tif ((kernel_coal->use_cqe_mode_rx || kernel_coal->use_cqe_mode_tx) &&\n\t    !(bp->coal_cap.cmpl_params &\n\t      RING_AGGINT_QCAPS_RESP_CMPL_PARAMS_TIMER_RESET))\n\t\treturn -EOPNOTSUPP;\n\n\thw_coal = &bp->rx_coal;\n\tmult = hw_coal->bufs_per_record;\n\thw_coal->coal_ticks = coal->rx_coalesce_usecs;\n\thw_coal->coal_bufs = coal->rx_max_coalesced_frames * mult;\n\thw_coal->coal_ticks_irq = coal->rx_coalesce_usecs_irq;\n\thw_coal->coal_bufs_irq = coal->rx_max_coalesced_frames_irq * mult;\n\thw_coal->flags &=\n\t\t~RING_CMPL_RING_CFG_AGGINT_PARAMS_REQ_FLAGS_TIMER_RESET;\n\tif (kernel_coal->use_cqe_mode_rx)\n\t\thw_coal->flags |=\n\t\t\tRING_CMPL_RING_CFG_AGGINT_PARAMS_REQ_FLAGS_TIMER_RESET;\n\n\thw_coal = &bp->tx_coal;\n\tmult = hw_coal->bufs_per_record;\n\thw_coal->coal_ticks = coal->tx_coalesce_usecs;\n\thw_coal->coal_bufs = coal->tx_max_coalesced_frames * mult;\n\thw_coal->coal_ticks_irq = coal->tx_coalesce_usecs_irq;\n\thw_coal->coal_bufs_irq = coal->tx_max_coalesced_frames_irq * mult;\n\thw_coal->flags &=\n\t\t~RING_CMPL_RING_CFG_AGGINT_PARAMS_REQ_FLAGS_TIMER_RESET;\n\tif (kernel_coal->use_cqe_mode_tx)\n\t\thw_coal->flags |=\n\t\t\tRING_CMPL_RING_CFG_AGGINT_PARAMS_REQ_FLAGS_TIMER_RESET;\n\n\tif (bp->stats_coal_ticks != coal->stats_block_coalesce_usecs) {\n\t\tu32 stats_ticks = coal->stats_block_coalesce_usecs;\n\n\t\t \n\t\tif (stats_ticks)\n\t\t\tstats_ticks = clamp_t(u32, stats_ticks,\n\t\t\t\t\t      BNXT_MIN_STATS_COAL_TICKS,\n\t\t\t\t\t      BNXT_MAX_STATS_COAL_TICKS);\n\t\tstats_ticks = rounddown(stats_ticks, BNXT_MIN_STATS_COAL_TICKS);\n\t\tbp->stats_coal_ticks = stats_ticks;\n\t\tif (bp->stats_coal_ticks)\n\t\t\tbp->current_interval =\n\t\t\t\tbp->stats_coal_ticks * HZ / 1000000;\n\t\telse\n\t\t\tbp->current_interval = BNXT_TIMER_INTERVAL;\n\t\tupdate_stats = true;\n\t}\n\nreset_coalesce:\n\tif (test_bit(BNXT_STATE_OPEN, &bp->state)) {\n\t\tif (update_stats) {\n\t\t\tbnxt_close_nic(bp, true, false);\n\t\t\trc = bnxt_open_nic(bp, true, false);\n\t\t} else {\n\t\t\trc = bnxt_hwrm_set_coal(bp);\n\t\t}\n\t}\n\n\treturn rc;\n}\n\nstatic const char * const bnxt_ring_rx_stats_str[] = {\n\t\"rx_ucast_packets\",\n\t\"rx_mcast_packets\",\n\t\"rx_bcast_packets\",\n\t\"rx_discards\",\n\t\"rx_errors\",\n\t\"rx_ucast_bytes\",\n\t\"rx_mcast_bytes\",\n\t\"rx_bcast_bytes\",\n};\n\nstatic const char * const bnxt_ring_tx_stats_str[] = {\n\t\"tx_ucast_packets\",\n\t\"tx_mcast_packets\",\n\t\"tx_bcast_packets\",\n\t\"tx_errors\",\n\t\"tx_discards\",\n\t\"tx_ucast_bytes\",\n\t\"tx_mcast_bytes\",\n\t\"tx_bcast_bytes\",\n};\n\nstatic const char * const bnxt_ring_tpa_stats_str[] = {\n\t\"tpa_packets\",\n\t\"tpa_bytes\",\n\t\"tpa_events\",\n\t\"tpa_aborts\",\n};\n\nstatic const char * const bnxt_ring_tpa2_stats_str[] = {\n\t\"rx_tpa_eligible_pkt\",\n\t\"rx_tpa_eligible_bytes\",\n\t\"rx_tpa_pkt\",\n\t\"rx_tpa_bytes\",\n\t\"rx_tpa_errors\",\n\t\"rx_tpa_events\",\n};\n\nstatic const char * const bnxt_rx_sw_stats_str[] = {\n\t\"rx_l4_csum_errors\",\n\t\"rx_resets\",\n\t\"rx_buf_errors\",\n};\n\nstatic const char * const bnxt_cmn_sw_stats_str[] = {\n\t\"missed_irqs\",\n};\n\n#define BNXT_RX_STATS_ENTRY(counter)\t\\\n\t{ BNXT_RX_STATS_OFFSET(counter), __stringify(counter) }\n\n#define BNXT_TX_STATS_ENTRY(counter)\t\\\n\t{ BNXT_TX_STATS_OFFSET(counter), __stringify(counter) }\n\n#define BNXT_RX_STATS_EXT_ENTRY(counter)\t\\\n\t{ BNXT_RX_STATS_EXT_OFFSET(counter), __stringify(counter) }\n\n#define BNXT_TX_STATS_EXT_ENTRY(counter)\t\\\n\t{ BNXT_TX_STATS_EXT_OFFSET(counter), __stringify(counter) }\n\n#define BNXT_RX_STATS_EXT_PFC_ENTRY(n)\t\t\t\t\\\n\tBNXT_RX_STATS_EXT_ENTRY(pfc_pri##n##_rx_duration_us),\t\\\n\tBNXT_RX_STATS_EXT_ENTRY(pfc_pri##n##_rx_transitions)\n\n#define BNXT_TX_STATS_EXT_PFC_ENTRY(n)\t\t\t\t\\\n\tBNXT_TX_STATS_EXT_ENTRY(pfc_pri##n##_tx_duration_us),\t\\\n\tBNXT_TX_STATS_EXT_ENTRY(pfc_pri##n##_tx_transitions)\n\n#define BNXT_RX_STATS_EXT_PFC_ENTRIES\t\t\t\t\\\n\tBNXT_RX_STATS_EXT_PFC_ENTRY(0),\t\t\t\t\\\n\tBNXT_RX_STATS_EXT_PFC_ENTRY(1),\t\t\t\t\\\n\tBNXT_RX_STATS_EXT_PFC_ENTRY(2),\t\t\t\t\\\n\tBNXT_RX_STATS_EXT_PFC_ENTRY(3),\t\t\t\t\\\n\tBNXT_RX_STATS_EXT_PFC_ENTRY(4),\t\t\t\t\\\n\tBNXT_RX_STATS_EXT_PFC_ENTRY(5),\t\t\t\t\\\n\tBNXT_RX_STATS_EXT_PFC_ENTRY(6),\t\t\t\t\\\n\tBNXT_RX_STATS_EXT_PFC_ENTRY(7)\n\n#define BNXT_TX_STATS_EXT_PFC_ENTRIES\t\t\t\t\\\n\tBNXT_TX_STATS_EXT_PFC_ENTRY(0),\t\t\t\t\\\n\tBNXT_TX_STATS_EXT_PFC_ENTRY(1),\t\t\t\t\\\n\tBNXT_TX_STATS_EXT_PFC_ENTRY(2),\t\t\t\t\\\n\tBNXT_TX_STATS_EXT_PFC_ENTRY(3),\t\t\t\t\\\n\tBNXT_TX_STATS_EXT_PFC_ENTRY(4),\t\t\t\t\\\n\tBNXT_TX_STATS_EXT_PFC_ENTRY(5),\t\t\t\t\\\n\tBNXT_TX_STATS_EXT_PFC_ENTRY(6),\t\t\t\t\\\n\tBNXT_TX_STATS_EXT_PFC_ENTRY(7)\n\n#define BNXT_RX_STATS_EXT_COS_ENTRY(n)\t\t\t\t\\\n\tBNXT_RX_STATS_EXT_ENTRY(rx_bytes_cos##n),\t\t\\\n\tBNXT_RX_STATS_EXT_ENTRY(rx_packets_cos##n)\n\n#define BNXT_TX_STATS_EXT_COS_ENTRY(n)\t\t\t\t\\\n\tBNXT_TX_STATS_EXT_ENTRY(tx_bytes_cos##n),\t\t\\\n\tBNXT_TX_STATS_EXT_ENTRY(tx_packets_cos##n)\n\n#define BNXT_RX_STATS_EXT_COS_ENTRIES\t\t\t\t\\\n\tBNXT_RX_STATS_EXT_COS_ENTRY(0),\t\t\t\t\\\n\tBNXT_RX_STATS_EXT_COS_ENTRY(1),\t\t\t\t\\\n\tBNXT_RX_STATS_EXT_COS_ENTRY(2),\t\t\t\t\\\n\tBNXT_RX_STATS_EXT_COS_ENTRY(3),\t\t\t\t\\\n\tBNXT_RX_STATS_EXT_COS_ENTRY(4),\t\t\t\t\\\n\tBNXT_RX_STATS_EXT_COS_ENTRY(5),\t\t\t\t\\\n\tBNXT_RX_STATS_EXT_COS_ENTRY(6),\t\t\t\t\\\n\tBNXT_RX_STATS_EXT_COS_ENTRY(7)\t\t\t\t\\\n\n#define BNXT_TX_STATS_EXT_COS_ENTRIES\t\t\t\t\\\n\tBNXT_TX_STATS_EXT_COS_ENTRY(0),\t\t\t\t\\\n\tBNXT_TX_STATS_EXT_COS_ENTRY(1),\t\t\t\t\\\n\tBNXT_TX_STATS_EXT_COS_ENTRY(2),\t\t\t\t\\\n\tBNXT_TX_STATS_EXT_COS_ENTRY(3),\t\t\t\t\\\n\tBNXT_TX_STATS_EXT_COS_ENTRY(4),\t\t\t\t\\\n\tBNXT_TX_STATS_EXT_COS_ENTRY(5),\t\t\t\t\\\n\tBNXT_TX_STATS_EXT_COS_ENTRY(6),\t\t\t\t\\\n\tBNXT_TX_STATS_EXT_COS_ENTRY(7)\t\t\t\t\\\n\n#define BNXT_RX_STATS_EXT_DISCARD_COS_ENTRY(n)\t\t\t\\\n\tBNXT_RX_STATS_EXT_ENTRY(rx_discard_bytes_cos##n),\t\\\n\tBNXT_RX_STATS_EXT_ENTRY(rx_discard_packets_cos##n)\n\n#define BNXT_RX_STATS_EXT_DISCARD_COS_ENTRIES\t\t\t\t\\\n\tBNXT_RX_STATS_EXT_DISCARD_COS_ENTRY(0),\t\t\t\t\\\n\tBNXT_RX_STATS_EXT_DISCARD_COS_ENTRY(1),\t\t\t\t\\\n\tBNXT_RX_STATS_EXT_DISCARD_COS_ENTRY(2),\t\t\t\t\\\n\tBNXT_RX_STATS_EXT_DISCARD_COS_ENTRY(3),\t\t\t\t\\\n\tBNXT_RX_STATS_EXT_DISCARD_COS_ENTRY(4),\t\t\t\t\\\n\tBNXT_RX_STATS_EXT_DISCARD_COS_ENTRY(5),\t\t\t\t\\\n\tBNXT_RX_STATS_EXT_DISCARD_COS_ENTRY(6),\t\t\t\t\\\n\tBNXT_RX_STATS_EXT_DISCARD_COS_ENTRY(7)\n\n#define BNXT_RX_STATS_PRI_ENTRY(counter, n)\t\t\\\n\t{ BNXT_RX_STATS_EXT_OFFSET(counter##_cos0),\t\\\n\t  __stringify(counter##_pri##n) }\n\n#define BNXT_TX_STATS_PRI_ENTRY(counter, n)\t\t\\\n\t{ BNXT_TX_STATS_EXT_OFFSET(counter##_cos0),\t\\\n\t  __stringify(counter##_pri##n) }\n\n#define BNXT_RX_STATS_PRI_ENTRIES(counter)\t\t\\\n\tBNXT_RX_STATS_PRI_ENTRY(counter, 0),\t\t\\\n\tBNXT_RX_STATS_PRI_ENTRY(counter, 1),\t\t\\\n\tBNXT_RX_STATS_PRI_ENTRY(counter, 2),\t\t\\\n\tBNXT_RX_STATS_PRI_ENTRY(counter, 3),\t\t\\\n\tBNXT_RX_STATS_PRI_ENTRY(counter, 4),\t\t\\\n\tBNXT_RX_STATS_PRI_ENTRY(counter, 5),\t\t\\\n\tBNXT_RX_STATS_PRI_ENTRY(counter, 6),\t\t\\\n\tBNXT_RX_STATS_PRI_ENTRY(counter, 7)\n\n#define BNXT_TX_STATS_PRI_ENTRIES(counter)\t\t\\\n\tBNXT_TX_STATS_PRI_ENTRY(counter, 0),\t\t\\\n\tBNXT_TX_STATS_PRI_ENTRY(counter, 1),\t\t\\\n\tBNXT_TX_STATS_PRI_ENTRY(counter, 2),\t\t\\\n\tBNXT_TX_STATS_PRI_ENTRY(counter, 3),\t\t\\\n\tBNXT_TX_STATS_PRI_ENTRY(counter, 4),\t\t\\\n\tBNXT_TX_STATS_PRI_ENTRY(counter, 5),\t\t\\\n\tBNXT_TX_STATS_PRI_ENTRY(counter, 6),\t\t\\\n\tBNXT_TX_STATS_PRI_ENTRY(counter, 7)\n\nenum {\n\tRX_TOTAL_DISCARDS,\n\tTX_TOTAL_DISCARDS,\n\tRX_NETPOLL_DISCARDS,\n};\n\nstatic const char *const bnxt_ring_err_stats_arr[] = {\n\t\"rx_total_l4_csum_errors\",\n\t\"rx_total_resets\",\n\t\"rx_total_buf_errors\",\n\t\"rx_total_oom_discards\",\n\t\"rx_total_netpoll_discards\",\n\t\"rx_total_ring_discards\",\n\t\"tx_total_resets\",\n\t\"tx_total_ring_discards\",\n\t\"total_missed_irqs\",\n};\n\n#define NUM_RING_RX_SW_STATS\t\tARRAY_SIZE(bnxt_rx_sw_stats_str)\n#define NUM_RING_CMN_SW_STATS\t\tARRAY_SIZE(bnxt_cmn_sw_stats_str)\n#define NUM_RING_RX_HW_STATS\t\tARRAY_SIZE(bnxt_ring_rx_stats_str)\n#define NUM_RING_TX_HW_STATS\t\tARRAY_SIZE(bnxt_ring_tx_stats_str)\n\nstatic const struct {\n\tlong offset;\n\tchar string[ETH_GSTRING_LEN];\n} bnxt_port_stats_arr[] = {\n\tBNXT_RX_STATS_ENTRY(rx_64b_frames),\n\tBNXT_RX_STATS_ENTRY(rx_65b_127b_frames),\n\tBNXT_RX_STATS_ENTRY(rx_128b_255b_frames),\n\tBNXT_RX_STATS_ENTRY(rx_256b_511b_frames),\n\tBNXT_RX_STATS_ENTRY(rx_512b_1023b_frames),\n\tBNXT_RX_STATS_ENTRY(rx_1024b_1518b_frames),\n\tBNXT_RX_STATS_ENTRY(rx_good_vlan_frames),\n\tBNXT_RX_STATS_ENTRY(rx_1519b_2047b_frames),\n\tBNXT_RX_STATS_ENTRY(rx_2048b_4095b_frames),\n\tBNXT_RX_STATS_ENTRY(rx_4096b_9216b_frames),\n\tBNXT_RX_STATS_ENTRY(rx_9217b_16383b_frames),\n\tBNXT_RX_STATS_ENTRY(rx_total_frames),\n\tBNXT_RX_STATS_ENTRY(rx_ucast_frames),\n\tBNXT_RX_STATS_ENTRY(rx_mcast_frames),\n\tBNXT_RX_STATS_ENTRY(rx_bcast_frames),\n\tBNXT_RX_STATS_ENTRY(rx_fcs_err_frames),\n\tBNXT_RX_STATS_ENTRY(rx_ctrl_frames),\n\tBNXT_RX_STATS_ENTRY(rx_pause_frames),\n\tBNXT_RX_STATS_ENTRY(rx_pfc_frames),\n\tBNXT_RX_STATS_ENTRY(rx_align_err_frames),\n\tBNXT_RX_STATS_ENTRY(rx_ovrsz_frames),\n\tBNXT_RX_STATS_ENTRY(rx_jbr_frames),\n\tBNXT_RX_STATS_ENTRY(rx_mtu_err_frames),\n\tBNXT_RX_STATS_ENTRY(rx_tagged_frames),\n\tBNXT_RX_STATS_ENTRY(rx_double_tagged_frames),\n\tBNXT_RX_STATS_ENTRY(rx_good_frames),\n\tBNXT_RX_STATS_ENTRY(rx_pfc_ena_frames_pri0),\n\tBNXT_RX_STATS_ENTRY(rx_pfc_ena_frames_pri1),\n\tBNXT_RX_STATS_ENTRY(rx_pfc_ena_frames_pri2),\n\tBNXT_RX_STATS_ENTRY(rx_pfc_ena_frames_pri3),\n\tBNXT_RX_STATS_ENTRY(rx_pfc_ena_frames_pri4),\n\tBNXT_RX_STATS_ENTRY(rx_pfc_ena_frames_pri5),\n\tBNXT_RX_STATS_ENTRY(rx_pfc_ena_frames_pri6),\n\tBNXT_RX_STATS_ENTRY(rx_pfc_ena_frames_pri7),\n\tBNXT_RX_STATS_ENTRY(rx_undrsz_frames),\n\tBNXT_RX_STATS_ENTRY(rx_eee_lpi_events),\n\tBNXT_RX_STATS_ENTRY(rx_eee_lpi_duration),\n\tBNXT_RX_STATS_ENTRY(rx_bytes),\n\tBNXT_RX_STATS_ENTRY(rx_runt_bytes),\n\tBNXT_RX_STATS_ENTRY(rx_runt_frames),\n\tBNXT_RX_STATS_ENTRY(rx_stat_discard),\n\tBNXT_RX_STATS_ENTRY(rx_stat_err),\n\n\tBNXT_TX_STATS_ENTRY(tx_64b_frames),\n\tBNXT_TX_STATS_ENTRY(tx_65b_127b_frames),\n\tBNXT_TX_STATS_ENTRY(tx_128b_255b_frames),\n\tBNXT_TX_STATS_ENTRY(tx_256b_511b_frames),\n\tBNXT_TX_STATS_ENTRY(tx_512b_1023b_frames),\n\tBNXT_TX_STATS_ENTRY(tx_1024b_1518b_frames),\n\tBNXT_TX_STATS_ENTRY(tx_good_vlan_frames),\n\tBNXT_TX_STATS_ENTRY(tx_1519b_2047b_frames),\n\tBNXT_TX_STATS_ENTRY(tx_2048b_4095b_frames),\n\tBNXT_TX_STATS_ENTRY(tx_4096b_9216b_frames),\n\tBNXT_TX_STATS_ENTRY(tx_9217b_16383b_frames),\n\tBNXT_TX_STATS_ENTRY(tx_good_frames),\n\tBNXT_TX_STATS_ENTRY(tx_total_frames),\n\tBNXT_TX_STATS_ENTRY(tx_ucast_frames),\n\tBNXT_TX_STATS_ENTRY(tx_mcast_frames),\n\tBNXT_TX_STATS_ENTRY(tx_bcast_frames),\n\tBNXT_TX_STATS_ENTRY(tx_pause_frames),\n\tBNXT_TX_STATS_ENTRY(tx_pfc_frames),\n\tBNXT_TX_STATS_ENTRY(tx_jabber_frames),\n\tBNXT_TX_STATS_ENTRY(tx_fcs_err_frames),\n\tBNXT_TX_STATS_ENTRY(tx_err),\n\tBNXT_TX_STATS_ENTRY(tx_fifo_underruns),\n\tBNXT_TX_STATS_ENTRY(tx_pfc_ena_frames_pri0),\n\tBNXT_TX_STATS_ENTRY(tx_pfc_ena_frames_pri1),\n\tBNXT_TX_STATS_ENTRY(tx_pfc_ena_frames_pri2),\n\tBNXT_TX_STATS_ENTRY(tx_pfc_ena_frames_pri3),\n\tBNXT_TX_STATS_ENTRY(tx_pfc_ena_frames_pri4),\n\tBNXT_TX_STATS_ENTRY(tx_pfc_ena_frames_pri5),\n\tBNXT_TX_STATS_ENTRY(tx_pfc_ena_frames_pri6),\n\tBNXT_TX_STATS_ENTRY(tx_pfc_ena_frames_pri7),\n\tBNXT_TX_STATS_ENTRY(tx_eee_lpi_events),\n\tBNXT_TX_STATS_ENTRY(tx_eee_lpi_duration),\n\tBNXT_TX_STATS_ENTRY(tx_total_collisions),\n\tBNXT_TX_STATS_ENTRY(tx_bytes),\n\tBNXT_TX_STATS_ENTRY(tx_xthol_frames),\n\tBNXT_TX_STATS_ENTRY(tx_stat_discard),\n\tBNXT_TX_STATS_ENTRY(tx_stat_error),\n};\n\nstatic const struct {\n\tlong offset;\n\tchar string[ETH_GSTRING_LEN];\n} bnxt_port_stats_ext_arr[] = {\n\tBNXT_RX_STATS_EXT_ENTRY(link_down_events),\n\tBNXT_RX_STATS_EXT_ENTRY(continuous_pause_events),\n\tBNXT_RX_STATS_EXT_ENTRY(resume_pause_events),\n\tBNXT_RX_STATS_EXT_ENTRY(continuous_roce_pause_events),\n\tBNXT_RX_STATS_EXT_ENTRY(resume_roce_pause_events),\n\tBNXT_RX_STATS_EXT_COS_ENTRIES,\n\tBNXT_RX_STATS_EXT_PFC_ENTRIES,\n\tBNXT_RX_STATS_EXT_ENTRY(rx_bits),\n\tBNXT_RX_STATS_EXT_ENTRY(rx_buffer_passed_threshold),\n\tBNXT_RX_STATS_EXT_ENTRY(rx_pcs_symbol_err),\n\tBNXT_RX_STATS_EXT_ENTRY(rx_corrected_bits),\n\tBNXT_RX_STATS_EXT_DISCARD_COS_ENTRIES,\n\tBNXT_RX_STATS_EXT_ENTRY(rx_fec_corrected_blocks),\n\tBNXT_RX_STATS_EXT_ENTRY(rx_fec_uncorrectable_blocks),\n};\n\nstatic const struct {\n\tlong offset;\n\tchar string[ETH_GSTRING_LEN];\n} bnxt_tx_port_stats_ext_arr[] = {\n\tBNXT_TX_STATS_EXT_COS_ENTRIES,\n\tBNXT_TX_STATS_EXT_PFC_ENTRIES,\n};\n\nstatic const struct {\n\tlong base_off;\n\tchar string[ETH_GSTRING_LEN];\n} bnxt_rx_bytes_pri_arr[] = {\n\tBNXT_RX_STATS_PRI_ENTRIES(rx_bytes),\n};\n\nstatic const struct {\n\tlong base_off;\n\tchar string[ETH_GSTRING_LEN];\n} bnxt_rx_pkts_pri_arr[] = {\n\tBNXT_RX_STATS_PRI_ENTRIES(rx_packets),\n};\n\nstatic const struct {\n\tlong base_off;\n\tchar string[ETH_GSTRING_LEN];\n} bnxt_tx_bytes_pri_arr[] = {\n\tBNXT_TX_STATS_PRI_ENTRIES(tx_bytes),\n};\n\nstatic const struct {\n\tlong base_off;\n\tchar string[ETH_GSTRING_LEN];\n} bnxt_tx_pkts_pri_arr[] = {\n\tBNXT_TX_STATS_PRI_ENTRIES(tx_packets),\n};\n\n#define BNXT_NUM_RING_ERR_STATS\tARRAY_SIZE(bnxt_ring_err_stats_arr)\n#define BNXT_NUM_PORT_STATS ARRAY_SIZE(bnxt_port_stats_arr)\n#define BNXT_NUM_STATS_PRI\t\t\t\\\n\t(ARRAY_SIZE(bnxt_rx_bytes_pri_arr) +\t\\\n\t ARRAY_SIZE(bnxt_rx_pkts_pri_arr) +\t\\\n\t ARRAY_SIZE(bnxt_tx_bytes_pri_arr) +\t\\\n\t ARRAY_SIZE(bnxt_tx_pkts_pri_arr))\n\nstatic int bnxt_get_num_tpa_ring_stats(struct bnxt *bp)\n{\n\tif (BNXT_SUPPORTS_TPA(bp)) {\n\t\tif (bp->max_tpa_v2) {\n\t\t\tif (BNXT_CHIP_P5_THOR(bp))\n\t\t\t\treturn BNXT_NUM_TPA_RING_STATS_P5;\n\t\t\treturn BNXT_NUM_TPA_RING_STATS_P5_SR2;\n\t\t}\n\t\treturn BNXT_NUM_TPA_RING_STATS;\n\t}\n\treturn 0;\n}\n\nstatic int bnxt_get_num_ring_stats(struct bnxt *bp)\n{\n\tint rx, tx, cmn;\n\n\trx = NUM_RING_RX_HW_STATS + NUM_RING_RX_SW_STATS +\n\t     bnxt_get_num_tpa_ring_stats(bp);\n\ttx = NUM_RING_TX_HW_STATS;\n\tcmn = NUM_RING_CMN_SW_STATS;\n\treturn rx * bp->rx_nr_rings + tx * bp->tx_nr_rings +\n\t       cmn * bp->cp_nr_rings;\n}\n\nstatic int bnxt_get_num_stats(struct bnxt *bp)\n{\n\tint num_stats = bnxt_get_num_ring_stats(bp);\n\n\tnum_stats += BNXT_NUM_RING_ERR_STATS;\n\n\tif (bp->flags & BNXT_FLAG_PORT_STATS)\n\t\tnum_stats += BNXT_NUM_PORT_STATS;\n\n\tif (bp->flags & BNXT_FLAG_PORT_STATS_EXT) {\n\t\tnum_stats += bp->fw_rx_stats_ext_size +\n\t\t\t     bp->fw_tx_stats_ext_size;\n\t\tif (bp->pri2cos_valid)\n\t\t\tnum_stats += BNXT_NUM_STATS_PRI;\n\t}\n\n\treturn num_stats;\n}\n\nstatic int bnxt_get_sset_count(struct net_device *dev, int sset)\n{\n\tstruct bnxt *bp = netdev_priv(dev);\n\n\tswitch (sset) {\n\tcase ETH_SS_STATS:\n\t\treturn bnxt_get_num_stats(bp);\n\tcase ETH_SS_TEST:\n\t\tif (!bp->num_tests)\n\t\t\treturn -EOPNOTSUPP;\n\t\treturn bp->num_tests;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic bool is_rx_ring(struct bnxt *bp, int ring_num)\n{\n\treturn ring_num < bp->rx_nr_rings;\n}\n\nstatic bool is_tx_ring(struct bnxt *bp, int ring_num)\n{\n\tint tx_base = 0;\n\n\tif (!(bp->flags & BNXT_FLAG_SHARED_RINGS))\n\t\ttx_base = bp->rx_nr_rings;\n\n\tif (ring_num >= tx_base && ring_num < (tx_base + bp->tx_nr_rings))\n\t\treturn true;\n\treturn false;\n}\n\nstatic void bnxt_get_ethtool_stats(struct net_device *dev,\n\t\t\t\t   struct ethtool_stats *stats, u64 *buf)\n{\n\tstruct bnxt_total_ring_err_stats ring_err_stats = {0};\n\tstruct bnxt *bp = netdev_priv(dev);\n\tu64 *curr, *prev;\n\tu32 tpa_stats;\n\tu32 i, j = 0;\n\n\tif (!bp->bnapi) {\n\t\tj += bnxt_get_num_ring_stats(bp);\n\t\tgoto skip_ring_stats;\n\t}\n\n\ttpa_stats = bnxt_get_num_tpa_ring_stats(bp);\n\tfor (i = 0; i < bp->cp_nr_rings; i++) {\n\t\tstruct bnxt_napi *bnapi = bp->bnapi[i];\n\t\tstruct bnxt_cp_ring_info *cpr = &bnapi->cp_ring;\n\t\tu64 *sw_stats = cpr->stats.sw_stats;\n\t\tu64 *sw;\n\t\tint k;\n\n\t\tif (is_rx_ring(bp, i)) {\n\t\t\tfor (k = 0; k < NUM_RING_RX_HW_STATS; j++, k++)\n\t\t\t\tbuf[j] = sw_stats[k];\n\t\t}\n\t\tif (is_tx_ring(bp, i)) {\n\t\t\tk = NUM_RING_RX_HW_STATS;\n\t\t\tfor (; k < NUM_RING_RX_HW_STATS + NUM_RING_TX_HW_STATS;\n\t\t\t       j++, k++)\n\t\t\t\tbuf[j] = sw_stats[k];\n\t\t}\n\t\tif (!tpa_stats || !is_rx_ring(bp, i))\n\t\t\tgoto skip_tpa_ring_stats;\n\n\t\tk = NUM_RING_RX_HW_STATS + NUM_RING_TX_HW_STATS;\n\t\tfor (; k < NUM_RING_RX_HW_STATS + NUM_RING_TX_HW_STATS +\n\t\t\t   tpa_stats; j++, k++)\n\t\t\tbuf[j] = sw_stats[k];\n\nskip_tpa_ring_stats:\n\t\tsw = (u64 *)&cpr->sw_stats.rx;\n\t\tif (is_rx_ring(bp, i)) {\n\t\t\tfor (k = 0; k < NUM_RING_RX_SW_STATS; j++, k++)\n\t\t\t\tbuf[j] = sw[k];\n\t\t}\n\n\t\tsw = (u64 *)&cpr->sw_stats.cmn;\n\t\tfor (k = 0; k < NUM_RING_CMN_SW_STATS; j++, k++)\n\t\t\tbuf[j] = sw[k];\n\t}\n\n\tbnxt_get_ring_err_stats(bp, &ring_err_stats);\n\nskip_ring_stats:\n\tcurr = &ring_err_stats.rx_total_l4_csum_errors;\n\tprev = &bp->ring_err_stats_prev.rx_total_l4_csum_errors;\n\tfor (i = 0; i < BNXT_NUM_RING_ERR_STATS; i++, j++, curr++, prev++)\n\t\tbuf[j] = *curr + *prev;\n\n\tif (bp->flags & BNXT_FLAG_PORT_STATS) {\n\t\tu64 *port_stats = bp->port_stats.sw_stats;\n\n\t\tfor (i = 0; i < BNXT_NUM_PORT_STATS; i++, j++)\n\t\t\tbuf[j] = *(port_stats + bnxt_port_stats_arr[i].offset);\n\t}\n\tif (bp->flags & BNXT_FLAG_PORT_STATS_EXT) {\n\t\tu64 *rx_port_stats_ext = bp->rx_port_stats_ext.sw_stats;\n\t\tu64 *tx_port_stats_ext = bp->tx_port_stats_ext.sw_stats;\n\n\t\tfor (i = 0; i < bp->fw_rx_stats_ext_size; i++, j++) {\n\t\t\tbuf[j] = *(rx_port_stats_ext +\n\t\t\t\t   bnxt_port_stats_ext_arr[i].offset);\n\t\t}\n\t\tfor (i = 0; i < bp->fw_tx_stats_ext_size; i++, j++) {\n\t\t\tbuf[j] = *(tx_port_stats_ext +\n\t\t\t\t   bnxt_tx_port_stats_ext_arr[i].offset);\n\t\t}\n\t\tif (bp->pri2cos_valid) {\n\t\t\tfor (i = 0; i < 8; i++, j++) {\n\t\t\t\tlong n = bnxt_rx_bytes_pri_arr[i].base_off +\n\t\t\t\t\t bp->pri2cos_idx[i];\n\n\t\t\t\tbuf[j] = *(rx_port_stats_ext + n);\n\t\t\t}\n\t\t\tfor (i = 0; i < 8; i++, j++) {\n\t\t\t\tlong n = bnxt_rx_pkts_pri_arr[i].base_off +\n\t\t\t\t\t bp->pri2cos_idx[i];\n\n\t\t\t\tbuf[j] = *(rx_port_stats_ext + n);\n\t\t\t}\n\t\t\tfor (i = 0; i < 8; i++, j++) {\n\t\t\t\tlong n = bnxt_tx_bytes_pri_arr[i].base_off +\n\t\t\t\t\t bp->pri2cos_idx[i];\n\n\t\t\t\tbuf[j] = *(tx_port_stats_ext + n);\n\t\t\t}\n\t\t\tfor (i = 0; i < 8; i++, j++) {\n\t\t\t\tlong n = bnxt_tx_pkts_pri_arr[i].base_off +\n\t\t\t\t\t bp->pri2cos_idx[i];\n\n\t\t\t\tbuf[j] = *(tx_port_stats_ext + n);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void bnxt_get_strings(struct net_device *dev, u32 stringset, u8 *buf)\n{\n\tstruct bnxt *bp = netdev_priv(dev);\n\tstatic const char * const *str;\n\tu32 i, j, num_str;\n\n\tswitch (stringset) {\n\tcase ETH_SS_STATS:\n\t\tfor (i = 0; i < bp->cp_nr_rings; i++) {\n\t\t\tif (is_rx_ring(bp, i)) {\n\t\t\t\tnum_str = NUM_RING_RX_HW_STATS;\n\t\t\t\tfor (j = 0; j < num_str; j++) {\n\t\t\t\t\tsprintf(buf, \"[%d]: %s\", i,\n\t\t\t\t\t\tbnxt_ring_rx_stats_str[j]);\n\t\t\t\t\tbuf += ETH_GSTRING_LEN;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (is_tx_ring(bp, i)) {\n\t\t\t\tnum_str = NUM_RING_TX_HW_STATS;\n\t\t\t\tfor (j = 0; j < num_str; j++) {\n\t\t\t\t\tsprintf(buf, \"[%d]: %s\", i,\n\t\t\t\t\t\tbnxt_ring_tx_stats_str[j]);\n\t\t\t\t\tbuf += ETH_GSTRING_LEN;\n\t\t\t\t}\n\t\t\t}\n\t\t\tnum_str = bnxt_get_num_tpa_ring_stats(bp);\n\t\t\tif (!num_str || !is_rx_ring(bp, i))\n\t\t\t\tgoto skip_tpa_stats;\n\n\t\t\tif (bp->max_tpa_v2)\n\t\t\t\tstr = bnxt_ring_tpa2_stats_str;\n\t\t\telse\n\t\t\t\tstr = bnxt_ring_tpa_stats_str;\n\n\t\t\tfor (j = 0; j < num_str; j++) {\n\t\t\t\tsprintf(buf, \"[%d]: %s\", i, str[j]);\n\t\t\t\tbuf += ETH_GSTRING_LEN;\n\t\t\t}\nskip_tpa_stats:\n\t\t\tif (is_rx_ring(bp, i)) {\n\t\t\t\tnum_str = NUM_RING_RX_SW_STATS;\n\t\t\t\tfor (j = 0; j < num_str; j++) {\n\t\t\t\t\tsprintf(buf, \"[%d]: %s\", i,\n\t\t\t\t\t\tbnxt_rx_sw_stats_str[j]);\n\t\t\t\t\tbuf += ETH_GSTRING_LEN;\n\t\t\t\t}\n\t\t\t}\n\t\t\tnum_str = NUM_RING_CMN_SW_STATS;\n\t\t\tfor (j = 0; j < num_str; j++) {\n\t\t\t\tsprintf(buf, \"[%d]: %s\", i,\n\t\t\t\t\tbnxt_cmn_sw_stats_str[j]);\n\t\t\t\tbuf += ETH_GSTRING_LEN;\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < BNXT_NUM_RING_ERR_STATS; i++) {\n\t\t\tstrscpy(buf, bnxt_ring_err_stats_arr[i], ETH_GSTRING_LEN);\n\t\t\tbuf += ETH_GSTRING_LEN;\n\t\t}\n\n\t\tif (bp->flags & BNXT_FLAG_PORT_STATS) {\n\t\t\tfor (i = 0; i < BNXT_NUM_PORT_STATS; i++) {\n\t\t\t\tstrcpy(buf, bnxt_port_stats_arr[i].string);\n\t\t\t\tbuf += ETH_GSTRING_LEN;\n\t\t\t}\n\t\t}\n\t\tif (bp->flags & BNXT_FLAG_PORT_STATS_EXT) {\n\t\t\tfor (i = 0; i < bp->fw_rx_stats_ext_size; i++) {\n\t\t\t\tstrcpy(buf, bnxt_port_stats_ext_arr[i].string);\n\t\t\t\tbuf += ETH_GSTRING_LEN;\n\t\t\t}\n\t\t\tfor (i = 0; i < bp->fw_tx_stats_ext_size; i++) {\n\t\t\t\tstrcpy(buf,\n\t\t\t\t       bnxt_tx_port_stats_ext_arr[i].string);\n\t\t\t\tbuf += ETH_GSTRING_LEN;\n\t\t\t}\n\t\t\tif (bp->pri2cos_valid) {\n\t\t\t\tfor (i = 0; i < 8; i++) {\n\t\t\t\t\tstrcpy(buf,\n\t\t\t\t\t       bnxt_rx_bytes_pri_arr[i].string);\n\t\t\t\t\tbuf += ETH_GSTRING_LEN;\n\t\t\t\t}\n\t\t\t\tfor (i = 0; i < 8; i++) {\n\t\t\t\t\tstrcpy(buf,\n\t\t\t\t\t       bnxt_rx_pkts_pri_arr[i].string);\n\t\t\t\t\tbuf += ETH_GSTRING_LEN;\n\t\t\t\t}\n\t\t\t\tfor (i = 0; i < 8; i++) {\n\t\t\t\t\tstrcpy(buf,\n\t\t\t\t\t       bnxt_tx_bytes_pri_arr[i].string);\n\t\t\t\t\tbuf += ETH_GSTRING_LEN;\n\t\t\t\t}\n\t\t\t\tfor (i = 0; i < 8; i++) {\n\t\t\t\t\tstrcpy(buf,\n\t\t\t\t\t       bnxt_tx_pkts_pri_arr[i].string);\n\t\t\t\t\tbuf += ETH_GSTRING_LEN;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase ETH_SS_TEST:\n\t\tif (bp->num_tests)\n\t\t\tmemcpy(buf, bp->test_info->string,\n\t\t\t       bp->num_tests * ETH_GSTRING_LEN);\n\t\tbreak;\n\tdefault:\n\t\tnetdev_err(bp->dev, \"bnxt_get_strings invalid request %x\\n\",\n\t\t\t   stringset);\n\t\tbreak;\n\t}\n}\n\nstatic void bnxt_get_ringparam(struct net_device *dev,\n\t\t\t       struct ethtool_ringparam *ering,\n\t\t\t       struct kernel_ethtool_ringparam *kernel_ering,\n\t\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct bnxt *bp = netdev_priv(dev);\n\n\tif (bp->flags & BNXT_FLAG_AGG_RINGS) {\n\t\tering->rx_max_pending = BNXT_MAX_RX_DESC_CNT_JUM_ENA;\n\t\tering->rx_jumbo_max_pending = BNXT_MAX_RX_JUM_DESC_CNT;\n\t\tkernel_ering->tcp_data_split = ETHTOOL_TCP_DATA_SPLIT_ENABLED;\n\t} else {\n\t\tering->rx_max_pending = BNXT_MAX_RX_DESC_CNT;\n\t\tering->rx_jumbo_max_pending = 0;\n\t\tkernel_ering->tcp_data_split = ETHTOOL_TCP_DATA_SPLIT_DISABLED;\n\t}\n\tering->tx_max_pending = BNXT_MAX_TX_DESC_CNT;\n\n\tering->rx_pending = bp->rx_ring_size;\n\tering->rx_jumbo_pending = bp->rx_agg_ring_size;\n\tering->tx_pending = bp->tx_ring_size;\n}\n\nstatic int bnxt_set_ringparam(struct net_device *dev,\n\t\t\t      struct ethtool_ringparam *ering,\n\t\t\t      struct kernel_ethtool_ringparam *kernel_ering,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct bnxt *bp = netdev_priv(dev);\n\n\tif ((ering->rx_pending > BNXT_MAX_RX_DESC_CNT) ||\n\t    (ering->tx_pending > BNXT_MAX_TX_DESC_CNT) ||\n\t    (ering->tx_pending < BNXT_MIN_TX_DESC_CNT))\n\t\treturn -EINVAL;\n\n\tif (netif_running(dev))\n\t\tbnxt_close_nic(bp, false, false);\n\n\tbp->rx_ring_size = ering->rx_pending;\n\tbp->tx_ring_size = ering->tx_pending;\n\tbnxt_set_ring_params(bp);\n\n\tif (netif_running(dev))\n\t\treturn bnxt_open_nic(bp, false, false);\n\n\treturn 0;\n}\n\nstatic void bnxt_get_channels(struct net_device *dev,\n\t\t\t      struct ethtool_channels *channel)\n{\n\tstruct bnxt *bp = netdev_priv(dev);\n\tstruct bnxt_hw_resc *hw_resc = &bp->hw_resc;\n\tint max_rx_rings, max_tx_rings, tcs;\n\tint max_tx_sch_inputs, tx_grps;\n\n\t \n\tif (netif_running(dev) && BNXT_NEW_RM(bp))\n\t\tbnxt_hwrm_func_resc_qcaps(bp, false);\n\tmax_tx_sch_inputs = hw_resc->max_tx_sch_inputs;\n\n\tbnxt_get_max_rings(bp, &max_rx_rings, &max_tx_rings, true);\n\tif (max_tx_sch_inputs)\n\t\tmax_tx_rings = min_t(int, max_tx_rings, max_tx_sch_inputs);\n\n\ttcs = netdev_get_num_tc(dev);\n\ttx_grps = max(tcs, 1);\n\tif (bp->tx_nr_rings_xdp)\n\t\ttx_grps++;\n\tmax_tx_rings /= tx_grps;\n\tchannel->max_combined = min_t(int, max_rx_rings, max_tx_rings);\n\n\tif (bnxt_get_max_rings(bp, &max_rx_rings, &max_tx_rings, false)) {\n\t\tmax_rx_rings = 0;\n\t\tmax_tx_rings = 0;\n\t}\n\tif (max_tx_sch_inputs)\n\t\tmax_tx_rings = min_t(int, max_tx_rings, max_tx_sch_inputs);\n\n\tif (tcs > 1)\n\t\tmax_tx_rings /= tcs;\n\n\tchannel->max_rx = max_rx_rings;\n\tchannel->max_tx = max_tx_rings;\n\tchannel->max_other = 0;\n\tif (bp->flags & BNXT_FLAG_SHARED_RINGS) {\n\t\tchannel->combined_count = bp->rx_nr_rings;\n\t\tif (BNXT_CHIP_TYPE_NITRO_A0(bp))\n\t\t\tchannel->combined_count--;\n\t} else {\n\t\tif (!BNXT_CHIP_TYPE_NITRO_A0(bp)) {\n\t\t\tchannel->rx_count = bp->rx_nr_rings;\n\t\t\tchannel->tx_count = bp->tx_nr_rings_per_tc;\n\t\t}\n\t}\n}\n\nstatic int bnxt_set_channels(struct net_device *dev,\n\t\t\t     struct ethtool_channels *channel)\n{\n\tstruct bnxt *bp = netdev_priv(dev);\n\tint req_tx_rings, req_rx_rings, tcs;\n\tbool sh = false;\n\tint tx_xdp = 0;\n\tint rc = 0;\n\n\tif (channel->other_count)\n\t\treturn -EINVAL;\n\n\tif (!channel->combined_count &&\n\t    (!channel->rx_count || !channel->tx_count))\n\t\treturn -EINVAL;\n\n\tif (channel->combined_count &&\n\t    (channel->rx_count || channel->tx_count))\n\t\treturn -EINVAL;\n\n\tif (BNXT_CHIP_TYPE_NITRO_A0(bp) && (channel->rx_count ||\n\t\t\t\t\t    channel->tx_count))\n\t\treturn -EINVAL;\n\n\tif (channel->combined_count)\n\t\tsh = true;\n\n\ttcs = netdev_get_num_tc(dev);\n\n\treq_tx_rings = sh ? channel->combined_count : channel->tx_count;\n\treq_rx_rings = sh ? channel->combined_count : channel->rx_count;\n\tif (bp->tx_nr_rings_xdp) {\n\t\tif (!sh) {\n\t\t\tnetdev_err(dev, \"Only combined mode supported when XDP is enabled.\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\ttx_xdp = req_rx_rings;\n\t}\n\trc = bnxt_check_rings(bp, req_tx_rings, req_rx_rings, sh, tcs, tx_xdp);\n\tif (rc) {\n\t\tnetdev_warn(dev, \"Unable to allocate the requested rings\\n\");\n\t\treturn rc;\n\t}\n\n\tif (bnxt_get_nr_rss_ctxs(bp, req_rx_rings) !=\n\t    bnxt_get_nr_rss_ctxs(bp, bp->rx_nr_rings) &&\n\t    netif_is_rxfh_configured(dev)) {\n\t\tnetdev_warn(dev, \"RSS table size change required, RSS table entries must be default to proceed\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (netif_running(dev)) {\n\t\tif (BNXT_PF(bp)) {\n\t\t\t \n\t\t}\n\t\tbnxt_close_nic(bp, true, false);\n\t}\n\n\tif (sh) {\n\t\tbp->flags |= BNXT_FLAG_SHARED_RINGS;\n\t\tbp->rx_nr_rings = channel->combined_count;\n\t\tbp->tx_nr_rings_per_tc = channel->combined_count;\n\t} else {\n\t\tbp->flags &= ~BNXT_FLAG_SHARED_RINGS;\n\t\tbp->rx_nr_rings = channel->rx_count;\n\t\tbp->tx_nr_rings_per_tc = channel->tx_count;\n\t}\n\tbp->tx_nr_rings_xdp = tx_xdp;\n\tbp->tx_nr_rings = bp->tx_nr_rings_per_tc + tx_xdp;\n\tif (tcs > 1)\n\t\tbp->tx_nr_rings = bp->tx_nr_rings_per_tc * tcs + tx_xdp;\n\n\tbp->cp_nr_rings = sh ? max_t(int, bp->tx_nr_rings, bp->rx_nr_rings) :\n\t\t\t       bp->tx_nr_rings + bp->rx_nr_rings;\n\n\t \n\tnetdev_update_features(dev);\n\tif (netif_running(dev)) {\n\t\trc = bnxt_open_nic(bp, true, false);\n\t\tif ((!rc) && BNXT_PF(bp)) {\n\t\t\t \n\t\t}\n\t} else {\n\t\trc = bnxt_reserve_rings(bp, true);\n\t}\n\n\treturn rc;\n}\n\n#ifdef CONFIG_RFS_ACCEL\nstatic int bnxt_grxclsrlall(struct bnxt *bp, struct ethtool_rxnfc *cmd,\n\t\t\t    u32 *rule_locs)\n{\n\tint i, j = 0;\n\n\tcmd->data = bp->ntp_fltr_count;\n\tfor (i = 0; i < BNXT_NTP_FLTR_HASH_SIZE; i++) {\n\t\tstruct hlist_head *head;\n\t\tstruct bnxt_ntuple_filter *fltr;\n\n\t\thead = &bp->ntp_fltr_hash_tbl[i];\n\t\trcu_read_lock();\n\t\thlist_for_each_entry_rcu(fltr, head, hash) {\n\t\t\tif (j == cmd->rule_cnt)\n\t\t\t\tbreak;\n\t\t\trule_locs[j++] = fltr->sw_id;\n\t\t}\n\t\trcu_read_unlock();\n\t\tif (j == cmd->rule_cnt)\n\t\t\tbreak;\n\t}\n\tcmd->rule_cnt = j;\n\treturn 0;\n}\n\nstatic int bnxt_grxclsrule(struct bnxt *bp, struct ethtool_rxnfc *cmd)\n{\n\tstruct ethtool_rx_flow_spec *fs =\n\t\t(struct ethtool_rx_flow_spec *)&cmd->fs;\n\tstruct bnxt_ntuple_filter *fltr;\n\tstruct flow_keys *fkeys;\n\tint i, rc = -EINVAL;\n\n\tif (fs->location >= BNXT_NTP_FLTR_MAX_FLTR)\n\t\treturn rc;\n\n\tfor (i = 0; i < BNXT_NTP_FLTR_HASH_SIZE; i++) {\n\t\tstruct hlist_head *head;\n\n\t\thead = &bp->ntp_fltr_hash_tbl[i];\n\t\trcu_read_lock();\n\t\thlist_for_each_entry_rcu(fltr, head, hash) {\n\t\t\tif (fltr->sw_id == fs->location)\n\t\t\t\tgoto fltr_found;\n\t\t}\n\t\trcu_read_unlock();\n\t}\n\treturn rc;\n\nfltr_found:\n\tfkeys = &fltr->fkeys;\n\tif (fkeys->basic.n_proto == htons(ETH_P_IP)) {\n\t\tif (fkeys->basic.ip_proto == IPPROTO_TCP)\n\t\t\tfs->flow_type = TCP_V4_FLOW;\n\t\telse if (fkeys->basic.ip_proto == IPPROTO_UDP)\n\t\t\tfs->flow_type = UDP_V4_FLOW;\n\t\telse\n\t\t\tgoto fltr_err;\n\n\t\tfs->h_u.tcp_ip4_spec.ip4src = fkeys->addrs.v4addrs.src;\n\t\tfs->m_u.tcp_ip4_spec.ip4src = cpu_to_be32(~0);\n\n\t\tfs->h_u.tcp_ip4_spec.ip4dst = fkeys->addrs.v4addrs.dst;\n\t\tfs->m_u.tcp_ip4_spec.ip4dst = cpu_to_be32(~0);\n\n\t\tfs->h_u.tcp_ip4_spec.psrc = fkeys->ports.src;\n\t\tfs->m_u.tcp_ip4_spec.psrc = cpu_to_be16(~0);\n\n\t\tfs->h_u.tcp_ip4_spec.pdst = fkeys->ports.dst;\n\t\tfs->m_u.tcp_ip4_spec.pdst = cpu_to_be16(~0);\n\t} else {\n\t\tint i;\n\n\t\tif (fkeys->basic.ip_proto == IPPROTO_TCP)\n\t\t\tfs->flow_type = TCP_V6_FLOW;\n\t\telse if (fkeys->basic.ip_proto == IPPROTO_UDP)\n\t\t\tfs->flow_type = UDP_V6_FLOW;\n\t\telse\n\t\t\tgoto fltr_err;\n\n\t\t*(struct in6_addr *)&fs->h_u.tcp_ip6_spec.ip6src[0] =\n\t\t\tfkeys->addrs.v6addrs.src;\n\t\t*(struct in6_addr *)&fs->h_u.tcp_ip6_spec.ip6dst[0] =\n\t\t\tfkeys->addrs.v6addrs.dst;\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tfs->m_u.tcp_ip6_spec.ip6src[i] = cpu_to_be32(~0);\n\t\t\tfs->m_u.tcp_ip6_spec.ip6dst[i] = cpu_to_be32(~0);\n\t\t}\n\t\tfs->h_u.tcp_ip6_spec.psrc = fkeys->ports.src;\n\t\tfs->m_u.tcp_ip6_spec.psrc = cpu_to_be16(~0);\n\n\t\tfs->h_u.tcp_ip6_spec.pdst = fkeys->ports.dst;\n\t\tfs->m_u.tcp_ip6_spec.pdst = cpu_to_be16(~0);\n\t}\n\n\tfs->ring_cookie = fltr->rxq;\n\trc = 0;\n\nfltr_err:\n\trcu_read_unlock();\n\n\treturn rc;\n}\n#endif\n\nstatic u64 get_ethtool_ipv4_rss(struct bnxt *bp)\n{\n\tif (bp->rss_hash_cfg & VNIC_RSS_CFG_REQ_HASH_TYPE_IPV4)\n\t\treturn RXH_IP_SRC | RXH_IP_DST;\n\treturn 0;\n}\n\nstatic u64 get_ethtool_ipv6_rss(struct bnxt *bp)\n{\n\tif (bp->rss_hash_cfg & VNIC_RSS_CFG_REQ_HASH_TYPE_IPV6)\n\t\treturn RXH_IP_SRC | RXH_IP_DST;\n\treturn 0;\n}\n\nstatic int bnxt_grxfh(struct bnxt *bp, struct ethtool_rxnfc *cmd)\n{\n\tcmd->data = 0;\n\tswitch (cmd->flow_type) {\n\tcase TCP_V4_FLOW:\n\t\tif (bp->rss_hash_cfg & VNIC_RSS_CFG_REQ_HASH_TYPE_TCP_IPV4)\n\t\t\tcmd->data |= RXH_IP_SRC | RXH_IP_DST |\n\t\t\t\t     RXH_L4_B_0_1 | RXH_L4_B_2_3;\n\t\tcmd->data |= get_ethtool_ipv4_rss(bp);\n\t\tbreak;\n\tcase UDP_V4_FLOW:\n\t\tif (bp->rss_hash_cfg & VNIC_RSS_CFG_REQ_HASH_TYPE_UDP_IPV4)\n\t\t\tcmd->data |= RXH_IP_SRC | RXH_IP_DST |\n\t\t\t\t     RXH_L4_B_0_1 | RXH_L4_B_2_3;\n\t\tfallthrough;\n\tcase SCTP_V4_FLOW:\n\tcase AH_ESP_V4_FLOW:\n\tcase AH_V4_FLOW:\n\tcase ESP_V4_FLOW:\n\tcase IPV4_FLOW:\n\t\tcmd->data |= get_ethtool_ipv4_rss(bp);\n\t\tbreak;\n\n\tcase TCP_V6_FLOW:\n\t\tif (bp->rss_hash_cfg & VNIC_RSS_CFG_REQ_HASH_TYPE_TCP_IPV6)\n\t\t\tcmd->data |= RXH_IP_SRC | RXH_IP_DST |\n\t\t\t\t     RXH_L4_B_0_1 | RXH_L4_B_2_3;\n\t\tcmd->data |= get_ethtool_ipv6_rss(bp);\n\t\tbreak;\n\tcase UDP_V6_FLOW:\n\t\tif (bp->rss_hash_cfg & VNIC_RSS_CFG_REQ_HASH_TYPE_UDP_IPV6)\n\t\t\tcmd->data |= RXH_IP_SRC | RXH_IP_DST |\n\t\t\t\t     RXH_L4_B_0_1 | RXH_L4_B_2_3;\n\t\tfallthrough;\n\tcase SCTP_V6_FLOW:\n\tcase AH_ESP_V6_FLOW:\n\tcase AH_V6_FLOW:\n\tcase ESP_V6_FLOW:\n\tcase IPV6_FLOW:\n\t\tcmd->data |= get_ethtool_ipv6_rss(bp);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\n#define RXH_4TUPLE (RXH_IP_SRC | RXH_IP_DST | RXH_L4_B_0_1 | RXH_L4_B_2_3)\n#define RXH_2TUPLE (RXH_IP_SRC | RXH_IP_DST)\n\nstatic int bnxt_srxfh(struct bnxt *bp, struct ethtool_rxnfc *cmd)\n{\n\tu32 rss_hash_cfg = bp->rss_hash_cfg;\n\tint tuple, rc = 0;\n\n\tif (cmd->data == RXH_4TUPLE)\n\t\ttuple = 4;\n\telse if (cmd->data == RXH_2TUPLE)\n\t\ttuple = 2;\n\telse if (!cmd->data)\n\t\ttuple = 0;\n\telse\n\t\treturn -EINVAL;\n\n\tif (cmd->flow_type == TCP_V4_FLOW) {\n\t\trss_hash_cfg &= ~VNIC_RSS_CFG_REQ_HASH_TYPE_TCP_IPV4;\n\t\tif (tuple == 4)\n\t\t\trss_hash_cfg |= VNIC_RSS_CFG_REQ_HASH_TYPE_TCP_IPV4;\n\t} else if (cmd->flow_type == UDP_V4_FLOW) {\n\t\tif (tuple == 4 && !(bp->flags & BNXT_FLAG_UDP_RSS_CAP))\n\t\t\treturn -EINVAL;\n\t\trss_hash_cfg &= ~VNIC_RSS_CFG_REQ_HASH_TYPE_UDP_IPV4;\n\t\tif (tuple == 4)\n\t\t\trss_hash_cfg |= VNIC_RSS_CFG_REQ_HASH_TYPE_UDP_IPV4;\n\t} else if (cmd->flow_type == TCP_V6_FLOW) {\n\t\trss_hash_cfg &= ~VNIC_RSS_CFG_REQ_HASH_TYPE_TCP_IPV6;\n\t\tif (tuple == 4)\n\t\t\trss_hash_cfg |= VNIC_RSS_CFG_REQ_HASH_TYPE_TCP_IPV6;\n\t} else if (cmd->flow_type == UDP_V6_FLOW) {\n\t\tif (tuple == 4 && !(bp->flags & BNXT_FLAG_UDP_RSS_CAP))\n\t\t\treturn -EINVAL;\n\t\trss_hash_cfg &= ~VNIC_RSS_CFG_REQ_HASH_TYPE_UDP_IPV6;\n\t\tif (tuple == 4)\n\t\t\trss_hash_cfg |= VNIC_RSS_CFG_REQ_HASH_TYPE_UDP_IPV6;\n\t} else if (tuple == 4) {\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (cmd->flow_type) {\n\tcase TCP_V4_FLOW:\n\tcase UDP_V4_FLOW:\n\tcase SCTP_V4_FLOW:\n\tcase AH_ESP_V4_FLOW:\n\tcase AH_V4_FLOW:\n\tcase ESP_V4_FLOW:\n\tcase IPV4_FLOW:\n\t\tif (tuple == 2)\n\t\t\trss_hash_cfg |= VNIC_RSS_CFG_REQ_HASH_TYPE_IPV4;\n\t\telse if (!tuple)\n\t\t\trss_hash_cfg &= ~VNIC_RSS_CFG_REQ_HASH_TYPE_IPV4;\n\t\tbreak;\n\n\tcase TCP_V6_FLOW:\n\tcase UDP_V6_FLOW:\n\tcase SCTP_V6_FLOW:\n\tcase AH_ESP_V6_FLOW:\n\tcase AH_V6_FLOW:\n\tcase ESP_V6_FLOW:\n\tcase IPV6_FLOW:\n\t\tif (tuple == 2)\n\t\t\trss_hash_cfg |= VNIC_RSS_CFG_REQ_HASH_TYPE_IPV6;\n\t\telse if (!tuple)\n\t\t\trss_hash_cfg &= ~VNIC_RSS_CFG_REQ_HASH_TYPE_IPV6;\n\t\tbreak;\n\t}\n\n\tif (bp->rss_hash_cfg == rss_hash_cfg)\n\t\treturn 0;\n\n\tif (bp->fw_cap & BNXT_FW_CAP_RSS_HASH_TYPE_DELTA)\n\t\tbp->rss_hash_delta = bp->rss_hash_cfg ^ rss_hash_cfg;\n\tbp->rss_hash_cfg = rss_hash_cfg;\n\tif (netif_running(bp->dev)) {\n\t\tbnxt_close_nic(bp, false, false);\n\t\trc = bnxt_open_nic(bp, false, false);\n\t}\n\treturn rc;\n}\n\nstatic int bnxt_get_rxnfc(struct net_device *dev, struct ethtool_rxnfc *cmd,\n\t\t\t  u32 *rule_locs)\n{\n\tstruct bnxt *bp = netdev_priv(dev);\n\tint rc = 0;\n\n\tswitch (cmd->cmd) {\n#ifdef CONFIG_RFS_ACCEL\n\tcase ETHTOOL_GRXRINGS:\n\t\tcmd->data = bp->rx_nr_rings;\n\t\tbreak;\n\n\tcase ETHTOOL_GRXCLSRLCNT:\n\t\tcmd->rule_cnt = bp->ntp_fltr_count;\n\t\tcmd->data = BNXT_NTP_FLTR_MAX_FLTR;\n\t\tbreak;\n\n\tcase ETHTOOL_GRXCLSRLALL:\n\t\trc = bnxt_grxclsrlall(bp, cmd, (u32 *)rule_locs);\n\t\tbreak;\n\n\tcase ETHTOOL_GRXCLSRULE:\n\t\trc = bnxt_grxclsrule(bp, cmd);\n\t\tbreak;\n#endif\n\n\tcase ETHTOOL_GRXFH:\n\t\trc = bnxt_grxfh(bp, cmd);\n\t\tbreak;\n\n\tdefault:\n\t\trc = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\n\treturn rc;\n}\n\nstatic int bnxt_set_rxnfc(struct net_device *dev, struct ethtool_rxnfc *cmd)\n{\n\tstruct bnxt *bp = netdev_priv(dev);\n\tint rc;\n\n\tswitch (cmd->cmd) {\n\tcase ETHTOOL_SRXFH:\n\t\trc = bnxt_srxfh(bp, cmd);\n\t\tbreak;\n\n\tdefault:\n\t\trc = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\treturn rc;\n}\n\nu32 bnxt_get_rxfh_indir_size(struct net_device *dev)\n{\n\tstruct bnxt *bp = netdev_priv(dev);\n\n\tif (bp->flags & BNXT_FLAG_CHIP_P5)\n\t\treturn ALIGN(bp->rx_nr_rings, BNXT_RSS_TABLE_ENTRIES_P5);\n\treturn HW_HASH_INDEX_SIZE;\n}\n\nstatic u32 bnxt_get_rxfh_key_size(struct net_device *dev)\n{\n\treturn HW_HASH_KEY_SIZE;\n}\n\nstatic int bnxt_get_rxfh(struct net_device *dev, u32 *indir, u8 *key,\n\t\t\t u8 *hfunc)\n{\n\tstruct bnxt *bp = netdev_priv(dev);\n\tstruct bnxt_vnic_info *vnic;\n\tu32 i, tbl_size;\n\n\tif (hfunc)\n\t\t*hfunc = ETH_RSS_HASH_TOP;\n\n\tif (!bp->vnic_info)\n\t\treturn 0;\n\n\tvnic = &bp->vnic_info[0];\n\tif (indir && bp->rss_indir_tbl) {\n\t\ttbl_size = bnxt_get_rxfh_indir_size(dev);\n\t\tfor (i = 0; i < tbl_size; i++)\n\t\t\tindir[i] = bp->rss_indir_tbl[i];\n\t}\n\n\tif (key && vnic->rss_hash_key)\n\t\tmemcpy(key, vnic->rss_hash_key, HW_HASH_KEY_SIZE);\n\n\treturn 0;\n}\n\nstatic int bnxt_set_rxfh(struct net_device *dev, const u32 *indir,\n\t\t\t const u8 *key, const u8 hfunc)\n{\n\tstruct bnxt *bp = netdev_priv(dev);\n\tint rc = 0;\n\n\tif (hfunc && hfunc != ETH_RSS_HASH_TOP)\n\t\treturn -EOPNOTSUPP;\n\n\tif (key)\n\t\treturn -EOPNOTSUPP;\n\n\tif (indir) {\n\t\tu32 i, pad, tbl_size = bnxt_get_rxfh_indir_size(dev);\n\n\t\tfor (i = 0; i < tbl_size; i++)\n\t\t\tbp->rss_indir_tbl[i] = indir[i];\n\t\tpad = bp->rss_indir_tbl_entries - tbl_size;\n\t\tif (pad)\n\t\t\tmemset(&bp->rss_indir_tbl[i], 0, pad * sizeof(u16));\n\t}\n\n\tif (netif_running(bp->dev)) {\n\t\tbnxt_close_nic(bp, false, false);\n\t\trc = bnxt_open_nic(bp, false, false);\n\t}\n\treturn rc;\n}\n\nstatic void bnxt_get_drvinfo(struct net_device *dev,\n\t\t\t     struct ethtool_drvinfo *info)\n{\n\tstruct bnxt *bp = netdev_priv(dev);\n\n\tstrscpy(info->driver, DRV_MODULE_NAME, sizeof(info->driver));\n\tstrscpy(info->fw_version, bp->fw_ver_str, sizeof(info->fw_version));\n\tstrscpy(info->bus_info, pci_name(bp->pdev), sizeof(info->bus_info));\n\tinfo->n_stats = bnxt_get_num_stats(bp);\n\tinfo->testinfo_len = bp->num_tests;\n\t \n\tinfo->eedump_len = 0;\n\t \n\tinfo->regdump_len = 0;\n}\n\nstatic int bnxt_get_regs_len(struct net_device *dev)\n{\n\tstruct bnxt *bp = netdev_priv(dev);\n\tint reg_len;\n\n\tif (!BNXT_PF(bp))\n\t\treturn -EOPNOTSUPP;\n\n\treg_len = BNXT_PXP_REG_LEN;\n\n\tif (bp->fw_cap & BNXT_FW_CAP_PCIE_STATS_SUPPORTED)\n\t\treg_len += sizeof(struct pcie_ctx_hw_stats);\n\n\treturn reg_len;\n}\n\nstatic void bnxt_get_regs(struct net_device *dev, struct ethtool_regs *regs,\n\t\t\t  void *_p)\n{\n\tstruct pcie_ctx_hw_stats *hw_pcie_stats;\n\tstruct hwrm_pcie_qstats_input *req;\n\tstruct bnxt *bp = netdev_priv(dev);\n\tdma_addr_t hw_pcie_stats_addr;\n\tint rc;\n\n\tregs->version = 0;\n\tbnxt_dbg_hwrm_rd_reg(bp, 0, BNXT_PXP_REG_LEN / 4, _p);\n\n\tif (!(bp->fw_cap & BNXT_FW_CAP_PCIE_STATS_SUPPORTED))\n\t\treturn;\n\n\tif (hwrm_req_init(bp, req, HWRM_PCIE_QSTATS))\n\t\treturn;\n\n\thw_pcie_stats = hwrm_req_dma_slice(bp, req, sizeof(*hw_pcie_stats),\n\t\t\t\t\t   &hw_pcie_stats_addr);\n\tif (!hw_pcie_stats) {\n\t\thwrm_req_drop(bp, req);\n\t\treturn;\n\t}\n\n\tregs->version = 1;\n\thwrm_req_hold(bp, req);  \n\treq->pcie_stat_size = cpu_to_le16(sizeof(*hw_pcie_stats));\n\treq->pcie_stat_host_addr = cpu_to_le64(hw_pcie_stats_addr);\n\trc = hwrm_req_send(bp, req);\n\tif (!rc) {\n\t\t__le64 *src = (__le64 *)hw_pcie_stats;\n\t\tu64 *dst = (u64 *)(_p + BNXT_PXP_REG_LEN);\n\t\tint i;\n\n\t\tfor (i = 0; i < sizeof(*hw_pcie_stats) / sizeof(__le64); i++)\n\t\t\tdst[i] = le64_to_cpu(src[i]);\n\t}\n\thwrm_req_drop(bp, req);\n}\n\nstatic void bnxt_get_wol(struct net_device *dev, struct ethtool_wolinfo *wol)\n{\n\tstruct bnxt *bp = netdev_priv(dev);\n\n\twol->supported = 0;\n\twol->wolopts = 0;\n\tmemset(&wol->sopass, 0, sizeof(wol->sopass));\n\tif (bp->flags & BNXT_FLAG_WOL_CAP) {\n\t\twol->supported = WAKE_MAGIC;\n\t\tif (bp->wol)\n\t\t\twol->wolopts = WAKE_MAGIC;\n\t}\n}\n\nstatic int bnxt_set_wol(struct net_device *dev, struct ethtool_wolinfo *wol)\n{\n\tstruct bnxt *bp = netdev_priv(dev);\n\n\tif (wol->wolopts & ~WAKE_MAGIC)\n\t\treturn -EINVAL;\n\n\tif (wol->wolopts & WAKE_MAGIC) {\n\t\tif (!(bp->flags & BNXT_FLAG_WOL_CAP))\n\t\t\treturn -EINVAL;\n\t\tif (!bp->wol) {\n\t\t\tif (bnxt_hwrm_alloc_wol_fltr(bp))\n\t\t\t\treturn -EBUSY;\n\t\t\tbp->wol = 1;\n\t\t}\n\t} else {\n\t\tif (bp->wol) {\n\t\t\tif (bnxt_hwrm_free_wol_fltr(bp))\n\t\t\t\treturn -EBUSY;\n\t\t\tbp->wol = 0;\n\t\t}\n\t}\n\treturn 0;\n}\n\nu32 _bnxt_fw_to_ethtool_adv_spds(u16 fw_speeds, u8 fw_pause)\n{\n\tu32 speed_mask = 0;\n\n\t \n\t \n\tif (fw_speeds & BNXT_LINK_SPEED_MSK_100MB)\n\t\tspeed_mask |= ADVERTISED_100baseT_Full;\n\tif (fw_speeds & BNXT_LINK_SPEED_MSK_1GB)\n\t\tspeed_mask |= ADVERTISED_1000baseT_Full;\n\tif (fw_speeds & BNXT_LINK_SPEED_MSK_2_5GB)\n\t\tspeed_mask |= ADVERTISED_2500baseX_Full;\n\tif (fw_speeds & BNXT_LINK_SPEED_MSK_10GB)\n\t\tspeed_mask |= ADVERTISED_10000baseT_Full;\n\tif (fw_speeds & BNXT_LINK_SPEED_MSK_40GB)\n\t\tspeed_mask |= ADVERTISED_40000baseCR4_Full;\n\n\tif ((fw_pause & BNXT_LINK_PAUSE_BOTH) == BNXT_LINK_PAUSE_BOTH)\n\t\tspeed_mask |= ADVERTISED_Pause;\n\telse if (fw_pause & BNXT_LINK_PAUSE_TX)\n\t\tspeed_mask |= ADVERTISED_Asym_Pause;\n\telse if (fw_pause & BNXT_LINK_PAUSE_RX)\n\t\tspeed_mask |= ADVERTISED_Pause | ADVERTISED_Asym_Pause;\n\n\treturn speed_mask;\n}\n\n#define BNXT_FW_TO_ETHTOOL_SPDS(fw_speeds, fw_pause, lk_ksettings, name)\\\n{\t\t\t\t\t\t\t\t\t\\\n\tif ((fw_speeds) & BNXT_LINK_SPEED_MSK_100MB)\t\t\t\\\n\t\tethtool_link_ksettings_add_link_mode(lk_ksettings, name,\\\n\t\t\t\t\t\t     100baseT_Full);\t\\\n\tif ((fw_speeds) & BNXT_LINK_SPEED_MSK_1GB)\t\t\t\\\n\t\tethtool_link_ksettings_add_link_mode(lk_ksettings, name,\\\n\t\t\t\t\t\t     1000baseT_Full);\t\\\n\tif ((fw_speeds) & BNXT_LINK_SPEED_MSK_10GB)\t\t\t\\\n\t\tethtool_link_ksettings_add_link_mode(lk_ksettings, name,\\\n\t\t\t\t\t\t     10000baseT_Full);\t\\\n\tif ((fw_speeds) & BNXT_LINK_SPEED_MSK_25GB)\t\t\t\\\n\t\tethtool_link_ksettings_add_link_mode(lk_ksettings, name,\\\n\t\t\t\t\t\t     25000baseCR_Full);\t\\\n\tif ((fw_speeds) & BNXT_LINK_SPEED_MSK_40GB)\t\t\t\\\n\t\tethtool_link_ksettings_add_link_mode(lk_ksettings, name,\\\n\t\t\t\t\t\t     40000baseCR4_Full);\\\n\tif ((fw_speeds) & BNXT_LINK_SPEED_MSK_50GB)\t\t\t\\\n\t\tethtool_link_ksettings_add_link_mode(lk_ksettings, name,\\\n\t\t\t\t\t\t     50000baseCR2_Full);\\\n\tif ((fw_speeds) & BNXT_LINK_SPEED_MSK_100GB)\t\t\t\\\n\t\tethtool_link_ksettings_add_link_mode(lk_ksettings, name,\\\n\t\t\t\t\t\t     100000baseCR4_Full);\\\n\tif ((fw_pause) & BNXT_LINK_PAUSE_RX) {\t\t\t\t\\\n\t\tethtool_link_ksettings_add_link_mode(lk_ksettings, name,\\\n\t\t\t\t\t\t     Pause);\t\t\\\n\t\tif (!((fw_pause) & BNXT_LINK_PAUSE_TX))\t\t\t\\\n\t\t\tethtool_link_ksettings_add_link_mode(\t\t\\\n\t\t\t\t\tlk_ksettings, name, Asym_Pause);\\\n\t} else if ((fw_pause) & BNXT_LINK_PAUSE_TX) {\t\t\t\\\n\t\tethtool_link_ksettings_add_link_mode(lk_ksettings, name,\\\n\t\t\t\t\t\t     Asym_Pause);\t\\\n\t}\t\t\t\t\t\t\t\t\\\n}\n\n#define BNXT_ETHTOOL_TO_FW_SPDS(fw_speeds, lk_ksettings, name)\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tif (ethtool_link_ksettings_test_link_mode(lk_ksettings, name,\t\\\n\t\t\t\t\t\t  100baseT_Full) ||\t\\\n\t    ethtool_link_ksettings_test_link_mode(lk_ksettings, name,\t\\\n\t\t\t\t\t\t  100baseT_Half))\t\\\n\t\t(fw_speeds) |= BNXT_LINK_SPEED_MSK_100MB;\t\t\\\n\tif (ethtool_link_ksettings_test_link_mode(lk_ksettings, name,\t\\\n\t\t\t\t\t\t  1000baseT_Full) ||\t\\\n\t    ethtool_link_ksettings_test_link_mode(lk_ksettings, name,\t\\\n\t\t\t\t\t\t  1000baseT_Half))\t\\\n\t\t(fw_speeds) |= BNXT_LINK_SPEED_MSK_1GB;\t\t\t\\\n\tif (ethtool_link_ksettings_test_link_mode(lk_ksettings, name,\t\\\n\t\t\t\t\t\t  10000baseT_Full))\t\\\n\t\t(fw_speeds) |= BNXT_LINK_SPEED_MSK_10GB;\t\t\\\n\tif (ethtool_link_ksettings_test_link_mode(lk_ksettings, name,\t\\\n\t\t\t\t\t\t  25000baseCR_Full))\t\\\n\t\t(fw_speeds) |= BNXT_LINK_SPEED_MSK_25GB;\t\t\\\n\tif (ethtool_link_ksettings_test_link_mode(lk_ksettings, name,\t\\\n\t\t\t\t\t\t  40000baseCR4_Full))\t\\\n\t\t(fw_speeds) |= BNXT_LINK_SPEED_MSK_40GB;\t\t\\\n\tif (ethtool_link_ksettings_test_link_mode(lk_ksettings, name,\t\\\n\t\t\t\t\t\t  50000baseCR2_Full))\t\\\n\t\t(fw_speeds) |= BNXT_LINK_SPEED_MSK_50GB;\t\t\\\n\tif (ethtool_link_ksettings_test_link_mode(lk_ksettings, name,\t\\\n\t\t\t\t\t\t  100000baseCR4_Full))\t\\\n\t\t(fw_speeds) |= BNXT_LINK_SPEED_MSK_100GB;\t\t\\\n}\n\n#define BNXT_FW_TO_ETHTOOL_PAM4_SPDS(fw_speeds, lk_ksettings, name)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tif ((fw_speeds) & BNXT_LINK_PAM4_SPEED_MSK_50GB)\t\t\\\n\t\tethtool_link_ksettings_add_link_mode(lk_ksettings, name,\\\n\t\t\t\t\t\t     50000baseCR_Full);\t\\\n\tif ((fw_speeds) & BNXT_LINK_PAM4_SPEED_MSK_100GB)\t\t\\\n\t\tethtool_link_ksettings_add_link_mode(lk_ksettings, name,\\\n\t\t\t\t\t\t     100000baseCR2_Full);\\\n\tif ((fw_speeds) & BNXT_LINK_PAM4_SPEED_MSK_200GB)\t\t\\\n\t\tethtool_link_ksettings_add_link_mode(lk_ksettings, name,\\\n\t\t\t\t\t\t     200000baseCR4_Full);\\\n}\n\n#define BNXT_ETHTOOL_TO_FW_PAM4_SPDS(fw_speeds, lk_ksettings, name)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tif (ethtool_link_ksettings_test_link_mode(lk_ksettings, name,\t\\\n\t\t\t\t\t\t  50000baseCR_Full))\t\\\n\t\t(fw_speeds) |= BNXT_LINK_PAM4_SPEED_MSK_50GB;\t\t\\\n\tif (ethtool_link_ksettings_test_link_mode(lk_ksettings, name,\t\\\n\t\t\t\t\t\t  100000baseCR2_Full))\t\\\n\t\t(fw_speeds) |= BNXT_LINK_PAM4_SPEED_MSK_100GB;\t\t\\\n\tif (ethtool_link_ksettings_test_link_mode(lk_ksettings, name,\t\\\n\t\t\t\t\t\t  200000baseCR4_Full))\t\\\n\t\t(fw_speeds) |= BNXT_LINK_PAM4_SPEED_MSK_200GB;\t\t\\\n}\n\nstatic void bnxt_fw_to_ethtool_advertised_fec(struct bnxt_link_info *link_info,\n\t\t\t\tstruct ethtool_link_ksettings *lk_ksettings)\n{\n\tu16 fec_cfg = link_info->fec_cfg;\n\n\tif ((fec_cfg & BNXT_FEC_NONE) || !(fec_cfg & BNXT_FEC_AUTONEG)) {\n\t\tlinkmode_set_bit(ETHTOOL_LINK_MODE_FEC_NONE_BIT,\n\t\t\t\t lk_ksettings->link_modes.advertising);\n\t\treturn;\n\t}\n\tif (fec_cfg & BNXT_FEC_ENC_BASE_R)\n\t\tlinkmode_set_bit(ETHTOOL_LINK_MODE_FEC_BASER_BIT,\n\t\t\t\t lk_ksettings->link_modes.advertising);\n\tif (fec_cfg & BNXT_FEC_ENC_RS)\n\t\tlinkmode_set_bit(ETHTOOL_LINK_MODE_FEC_RS_BIT,\n\t\t\t\t lk_ksettings->link_modes.advertising);\n\tif (fec_cfg & BNXT_FEC_ENC_LLRS)\n\t\tlinkmode_set_bit(ETHTOOL_LINK_MODE_FEC_LLRS_BIT,\n\t\t\t\t lk_ksettings->link_modes.advertising);\n}\n\nstatic void bnxt_fw_to_ethtool_advertised_spds(struct bnxt_link_info *link_info,\n\t\t\t\tstruct ethtool_link_ksettings *lk_ksettings)\n{\n\tu16 fw_speeds = link_info->advertising;\n\tu8 fw_pause = 0;\n\n\tif (link_info->autoneg & BNXT_AUTONEG_FLOW_CTRL)\n\t\tfw_pause = link_info->auto_pause_setting;\n\n\tBNXT_FW_TO_ETHTOOL_SPDS(fw_speeds, fw_pause, lk_ksettings, advertising);\n\tfw_speeds = link_info->advertising_pam4;\n\tBNXT_FW_TO_ETHTOOL_PAM4_SPDS(fw_speeds, lk_ksettings, advertising);\n\tbnxt_fw_to_ethtool_advertised_fec(link_info, lk_ksettings);\n}\n\nstatic void bnxt_fw_to_ethtool_lp_adv(struct bnxt_link_info *link_info,\n\t\t\t\tstruct ethtool_link_ksettings *lk_ksettings)\n{\n\tu16 fw_speeds = link_info->lp_auto_link_speeds;\n\tu8 fw_pause = 0;\n\n\tif (link_info->autoneg & BNXT_AUTONEG_FLOW_CTRL)\n\t\tfw_pause = link_info->lp_pause;\n\n\tBNXT_FW_TO_ETHTOOL_SPDS(fw_speeds, fw_pause, lk_ksettings,\n\t\t\t\tlp_advertising);\n\tfw_speeds = link_info->lp_auto_pam4_link_speeds;\n\tBNXT_FW_TO_ETHTOOL_PAM4_SPDS(fw_speeds, lk_ksettings, lp_advertising);\n}\n\nstatic void bnxt_fw_to_ethtool_support_fec(struct bnxt_link_info *link_info,\n\t\t\t\tstruct ethtool_link_ksettings *lk_ksettings)\n{\n\tu16 fec_cfg = link_info->fec_cfg;\n\n\tif (fec_cfg & BNXT_FEC_NONE) {\n\t\tlinkmode_set_bit(ETHTOOL_LINK_MODE_FEC_NONE_BIT,\n\t\t\t\t lk_ksettings->link_modes.supported);\n\t\treturn;\n\t}\n\tif (fec_cfg & BNXT_FEC_ENC_BASE_R_CAP)\n\t\tlinkmode_set_bit(ETHTOOL_LINK_MODE_FEC_BASER_BIT,\n\t\t\t\t lk_ksettings->link_modes.supported);\n\tif (fec_cfg & BNXT_FEC_ENC_RS_CAP)\n\t\tlinkmode_set_bit(ETHTOOL_LINK_MODE_FEC_RS_BIT,\n\t\t\t\t lk_ksettings->link_modes.supported);\n\tif (fec_cfg & BNXT_FEC_ENC_LLRS_CAP)\n\t\tlinkmode_set_bit(ETHTOOL_LINK_MODE_FEC_LLRS_BIT,\n\t\t\t\t lk_ksettings->link_modes.supported);\n}\n\nstatic void bnxt_fw_to_ethtool_support_spds(struct bnxt_link_info *link_info,\n\t\t\t\tstruct ethtool_link_ksettings *lk_ksettings)\n{\n\tstruct bnxt *bp = container_of(link_info, struct bnxt, link_info);\n\tu16 fw_speeds = link_info->support_speeds;\n\n\tBNXT_FW_TO_ETHTOOL_SPDS(fw_speeds, 0, lk_ksettings, supported);\n\tfw_speeds = link_info->support_pam4_speeds;\n\tBNXT_FW_TO_ETHTOOL_PAM4_SPDS(fw_speeds, lk_ksettings, supported);\n\n\tif (!(bp->phy_flags & BNXT_PHY_FL_NO_PAUSE)) {\n\t\tethtool_link_ksettings_add_link_mode(lk_ksettings, supported,\n\t\t\t\t\t\t     Pause);\n\t\tethtool_link_ksettings_add_link_mode(lk_ksettings, supported,\n\t\t\t\t\t\t     Asym_Pause);\n\t}\n\n\tif (link_info->support_auto_speeds ||\n\t    link_info->support_pam4_auto_speeds)\n\t\tethtool_link_ksettings_add_link_mode(lk_ksettings, supported,\n\t\t\t\t\t\t     Autoneg);\n\tbnxt_fw_to_ethtool_support_fec(link_info, lk_ksettings);\n}\n\nu32 bnxt_fw_to_ethtool_speed(u16 fw_link_speed)\n{\n\tswitch (fw_link_speed) {\n\tcase BNXT_LINK_SPEED_100MB:\n\t\treturn SPEED_100;\n\tcase BNXT_LINK_SPEED_1GB:\n\t\treturn SPEED_1000;\n\tcase BNXT_LINK_SPEED_2_5GB:\n\t\treturn SPEED_2500;\n\tcase BNXT_LINK_SPEED_10GB:\n\t\treturn SPEED_10000;\n\tcase BNXT_LINK_SPEED_20GB:\n\t\treturn SPEED_20000;\n\tcase BNXT_LINK_SPEED_25GB:\n\t\treturn SPEED_25000;\n\tcase BNXT_LINK_SPEED_40GB:\n\t\treturn SPEED_40000;\n\tcase BNXT_LINK_SPEED_50GB:\n\t\treturn SPEED_50000;\n\tcase BNXT_LINK_SPEED_100GB:\n\t\treturn SPEED_100000;\n\tcase BNXT_LINK_SPEED_200GB:\n\t\treturn SPEED_200000;\n\tdefault:\n\t\treturn SPEED_UNKNOWN;\n\t}\n}\n\nstatic int bnxt_get_link_ksettings(struct net_device *dev,\n\t\t\t\t   struct ethtool_link_ksettings *lk_ksettings)\n{\n\tstruct bnxt *bp = netdev_priv(dev);\n\tstruct bnxt_link_info *link_info = &bp->link_info;\n\tstruct ethtool_link_settings *base = &lk_ksettings->base;\n\tu32 ethtool_speed;\n\n\tethtool_link_ksettings_zero_link_mode(lk_ksettings, supported);\n\tmutex_lock(&bp->link_lock);\n\tbnxt_fw_to_ethtool_support_spds(link_info, lk_ksettings);\n\n\tethtool_link_ksettings_zero_link_mode(lk_ksettings, advertising);\n\tif (link_info->autoneg) {\n\t\tbnxt_fw_to_ethtool_advertised_spds(link_info, lk_ksettings);\n\t\tethtool_link_ksettings_add_link_mode(lk_ksettings,\n\t\t\t\t\t\t     advertising, Autoneg);\n\t\tbase->autoneg = AUTONEG_ENABLE;\n\t\tbase->duplex = DUPLEX_UNKNOWN;\n\t\tif (link_info->phy_link_status == BNXT_LINK_LINK) {\n\t\t\tbnxt_fw_to_ethtool_lp_adv(link_info, lk_ksettings);\n\t\t\tif (link_info->duplex & BNXT_LINK_DUPLEX_FULL)\n\t\t\t\tbase->duplex = DUPLEX_FULL;\n\t\t\telse\n\t\t\t\tbase->duplex = DUPLEX_HALF;\n\t\t}\n\t\tethtool_speed = bnxt_fw_to_ethtool_speed(link_info->link_speed);\n\t} else {\n\t\tbase->autoneg = AUTONEG_DISABLE;\n\t\tethtool_speed =\n\t\t\tbnxt_fw_to_ethtool_speed(link_info->req_link_speed);\n\t\tbase->duplex = DUPLEX_HALF;\n\t\tif (link_info->req_duplex == BNXT_LINK_DUPLEX_FULL)\n\t\t\tbase->duplex = DUPLEX_FULL;\n\t}\n\tbase->speed = ethtool_speed;\n\n\tbase->port = PORT_NONE;\n\tif (link_info->media_type == PORT_PHY_QCFG_RESP_MEDIA_TYPE_TP) {\n\t\tbase->port = PORT_TP;\n\t\tethtool_link_ksettings_add_link_mode(lk_ksettings, supported,\n\t\t\t\t\t\t     TP);\n\t\tethtool_link_ksettings_add_link_mode(lk_ksettings, advertising,\n\t\t\t\t\t\t     TP);\n\t} else {\n\t\tethtool_link_ksettings_add_link_mode(lk_ksettings, supported,\n\t\t\t\t\t\t     FIBRE);\n\t\tethtool_link_ksettings_add_link_mode(lk_ksettings, advertising,\n\t\t\t\t\t\t     FIBRE);\n\n\t\tif (link_info->media_type == PORT_PHY_QCFG_RESP_MEDIA_TYPE_DAC)\n\t\t\tbase->port = PORT_DA;\n\t\telse if (link_info->media_type ==\n\t\t\t PORT_PHY_QCFG_RESP_MEDIA_TYPE_FIBRE)\n\t\t\tbase->port = PORT_FIBRE;\n\t}\n\tbase->phy_address = link_info->phy_addr;\n\tmutex_unlock(&bp->link_lock);\n\n\treturn 0;\n}\n\nstatic int bnxt_force_link_speed(struct net_device *dev, u32 ethtool_speed)\n{\n\tstruct bnxt *bp = netdev_priv(dev);\n\tstruct bnxt_link_info *link_info = &bp->link_info;\n\tu16 support_pam4_spds = link_info->support_pam4_speeds;\n\tu16 support_spds = link_info->support_speeds;\n\tu8 sig_mode = BNXT_SIG_MODE_NRZ;\n\tu16 fw_speed = 0;\n\n\tswitch (ethtool_speed) {\n\tcase SPEED_100:\n\t\tif (support_spds & BNXT_LINK_SPEED_MSK_100MB)\n\t\t\tfw_speed = PORT_PHY_CFG_REQ_FORCE_LINK_SPEED_100MB;\n\t\tbreak;\n\tcase SPEED_1000:\n\t\tif (support_spds & BNXT_LINK_SPEED_MSK_1GB)\n\t\t\tfw_speed = PORT_PHY_CFG_REQ_FORCE_LINK_SPEED_1GB;\n\t\tbreak;\n\tcase SPEED_2500:\n\t\tif (support_spds & BNXT_LINK_SPEED_MSK_2_5GB)\n\t\t\tfw_speed = PORT_PHY_CFG_REQ_FORCE_LINK_SPEED_2_5GB;\n\t\tbreak;\n\tcase SPEED_10000:\n\t\tif (support_spds & BNXT_LINK_SPEED_MSK_10GB)\n\t\t\tfw_speed = PORT_PHY_CFG_REQ_FORCE_LINK_SPEED_10GB;\n\t\tbreak;\n\tcase SPEED_20000:\n\t\tif (support_spds & BNXT_LINK_SPEED_MSK_20GB)\n\t\t\tfw_speed = PORT_PHY_CFG_REQ_FORCE_LINK_SPEED_20GB;\n\t\tbreak;\n\tcase SPEED_25000:\n\t\tif (support_spds & BNXT_LINK_SPEED_MSK_25GB)\n\t\t\tfw_speed = PORT_PHY_CFG_REQ_FORCE_LINK_SPEED_25GB;\n\t\tbreak;\n\tcase SPEED_40000:\n\t\tif (support_spds & BNXT_LINK_SPEED_MSK_40GB)\n\t\t\tfw_speed = PORT_PHY_CFG_REQ_FORCE_LINK_SPEED_40GB;\n\t\tbreak;\n\tcase SPEED_50000:\n\t\tif (support_spds & BNXT_LINK_SPEED_MSK_50GB) {\n\t\t\tfw_speed = PORT_PHY_CFG_REQ_FORCE_LINK_SPEED_50GB;\n\t\t} else if (support_pam4_spds & BNXT_LINK_PAM4_SPEED_MSK_50GB) {\n\t\t\tfw_speed = PORT_PHY_CFG_REQ_FORCE_PAM4_LINK_SPEED_50GB;\n\t\t\tsig_mode = BNXT_SIG_MODE_PAM4;\n\t\t}\n\t\tbreak;\n\tcase SPEED_100000:\n\t\tif (support_spds & BNXT_LINK_SPEED_MSK_100GB) {\n\t\t\tfw_speed = PORT_PHY_CFG_REQ_FORCE_LINK_SPEED_100GB;\n\t\t} else if (support_pam4_spds & BNXT_LINK_PAM4_SPEED_MSK_100GB) {\n\t\t\tfw_speed = PORT_PHY_CFG_REQ_FORCE_PAM4_LINK_SPEED_100GB;\n\t\t\tsig_mode = BNXT_SIG_MODE_PAM4;\n\t\t}\n\t\tbreak;\n\tcase SPEED_200000:\n\t\tif (support_pam4_spds & BNXT_LINK_PAM4_SPEED_MSK_200GB) {\n\t\t\tfw_speed = PORT_PHY_CFG_REQ_FORCE_PAM4_LINK_SPEED_200GB;\n\t\t\tsig_mode = BNXT_SIG_MODE_PAM4;\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (!fw_speed) {\n\t\tnetdev_err(dev, \"unsupported speed!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (link_info->req_link_speed == fw_speed &&\n\t    link_info->req_signal_mode == sig_mode &&\n\t    link_info->autoneg == 0)\n\t\treturn -EALREADY;\n\n\tlink_info->req_link_speed = fw_speed;\n\tlink_info->req_signal_mode = sig_mode;\n\tlink_info->req_duplex = BNXT_LINK_DUPLEX_FULL;\n\tlink_info->autoneg = 0;\n\tlink_info->advertising = 0;\n\tlink_info->advertising_pam4 = 0;\n\n\treturn 0;\n}\n\nu16 bnxt_get_fw_auto_link_speeds(u32 advertising)\n{\n\tu16 fw_speed_mask = 0;\n\n\t \n\tif (advertising & (ADVERTISED_100baseT_Full |\n\t\t\t   ADVERTISED_100baseT_Half)) {\n\t\tfw_speed_mask |= BNXT_LINK_SPEED_MSK_100MB;\n\t}\n\tif (advertising & (ADVERTISED_1000baseT_Full |\n\t\t\t   ADVERTISED_1000baseT_Half)) {\n\t\tfw_speed_mask |= BNXT_LINK_SPEED_MSK_1GB;\n\t}\n\tif (advertising & ADVERTISED_10000baseT_Full)\n\t\tfw_speed_mask |= BNXT_LINK_SPEED_MSK_10GB;\n\n\tif (advertising & ADVERTISED_40000baseCR4_Full)\n\t\tfw_speed_mask |= BNXT_LINK_SPEED_MSK_40GB;\n\n\treturn fw_speed_mask;\n}\n\nstatic int bnxt_set_link_ksettings(struct net_device *dev,\n\t\t\t   const struct ethtool_link_ksettings *lk_ksettings)\n{\n\tstruct bnxt *bp = netdev_priv(dev);\n\tstruct bnxt_link_info *link_info = &bp->link_info;\n\tconst struct ethtool_link_settings *base = &lk_ksettings->base;\n\tbool set_pause = false;\n\tu32 speed;\n\tint rc = 0;\n\n\tif (!BNXT_PHY_CFG_ABLE(bp))\n\t\treturn -EOPNOTSUPP;\n\n\tmutex_lock(&bp->link_lock);\n\tif (base->autoneg == AUTONEG_ENABLE) {\n\t\tlink_info->advertising = 0;\n\t\tlink_info->advertising_pam4 = 0;\n\t\tBNXT_ETHTOOL_TO_FW_SPDS(link_info->advertising, lk_ksettings,\n\t\t\t\t\tadvertising);\n\t\tBNXT_ETHTOOL_TO_FW_PAM4_SPDS(link_info->advertising_pam4,\n\t\t\t\t\t     lk_ksettings, advertising);\n\t\tlink_info->autoneg |= BNXT_AUTONEG_SPEED;\n\t\tif (!link_info->advertising && !link_info->advertising_pam4) {\n\t\t\tlink_info->advertising = link_info->support_auto_speeds;\n\t\t\tlink_info->advertising_pam4 =\n\t\t\t\tlink_info->support_pam4_auto_speeds;\n\t\t}\n\t\t \n\t\tif (!(bp->phy_flags & BNXT_PHY_FL_NO_PAUSE))\n\t\t\tset_pause = true;\n\t} else {\n\t\tu8 phy_type = link_info->phy_type;\n\n\t\tif (phy_type == PORT_PHY_QCFG_RESP_PHY_TYPE_BASET  ||\n\t\t    phy_type == PORT_PHY_QCFG_RESP_PHY_TYPE_BASETE ||\n\t\t    link_info->media_type == PORT_PHY_QCFG_RESP_MEDIA_TYPE_TP) {\n\t\t\tnetdev_err(dev, \"10GBase-T devices must autoneg\\n\");\n\t\t\trc = -EINVAL;\n\t\t\tgoto set_setting_exit;\n\t\t}\n\t\tif (base->duplex == DUPLEX_HALF) {\n\t\t\tnetdev_err(dev, \"HALF DUPLEX is not supported!\\n\");\n\t\t\trc = -EINVAL;\n\t\t\tgoto set_setting_exit;\n\t\t}\n\t\tspeed = base->speed;\n\t\trc = bnxt_force_link_speed(dev, speed);\n\t\tif (rc) {\n\t\t\tif (rc == -EALREADY)\n\t\t\t\trc = 0;\n\t\t\tgoto set_setting_exit;\n\t\t}\n\t}\n\n\tif (netif_running(dev))\n\t\trc = bnxt_hwrm_set_link_setting(bp, set_pause, false);\n\nset_setting_exit:\n\tmutex_unlock(&bp->link_lock);\n\treturn rc;\n}\n\nstatic int bnxt_get_fecparam(struct net_device *dev,\n\t\t\t     struct ethtool_fecparam *fec)\n{\n\tstruct bnxt *bp = netdev_priv(dev);\n\tstruct bnxt_link_info *link_info;\n\tu8 active_fec;\n\tu16 fec_cfg;\n\n\tlink_info = &bp->link_info;\n\tfec_cfg = link_info->fec_cfg;\n\tactive_fec = link_info->active_fec_sig_mode &\n\t\t     PORT_PHY_QCFG_RESP_ACTIVE_FEC_MASK;\n\tif (fec_cfg & BNXT_FEC_NONE) {\n\t\tfec->fec = ETHTOOL_FEC_NONE;\n\t\tfec->active_fec = ETHTOOL_FEC_NONE;\n\t\treturn 0;\n\t}\n\tif (fec_cfg & BNXT_FEC_AUTONEG)\n\t\tfec->fec |= ETHTOOL_FEC_AUTO;\n\tif (fec_cfg & BNXT_FEC_ENC_BASE_R)\n\t\tfec->fec |= ETHTOOL_FEC_BASER;\n\tif (fec_cfg & BNXT_FEC_ENC_RS)\n\t\tfec->fec |= ETHTOOL_FEC_RS;\n\tif (fec_cfg & BNXT_FEC_ENC_LLRS)\n\t\tfec->fec |= ETHTOOL_FEC_LLRS;\n\n\tswitch (active_fec) {\n\tcase PORT_PHY_QCFG_RESP_ACTIVE_FEC_FEC_CLAUSE74_ACTIVE:\n\t\tfec->active_fec |= ETHTOOL_FEC_BASER;\n\t\tbreak;\n\tcase PORT_PHY_QCFG_RESP_ACTIVE_FEC_FEC_CLAUSE91_ACTIVE:\n\tcase PORT_PHY_QCFG_RESP_ACTIVE_FEC_FEC_RS544_1XN_ACTIVE:\n\tcase PORT_PHY_QCFG_RESP_ACTIVE_FEC_FEC_RS544_IEEE_ACTIVE:\n\t\tfec->active_fec |= ETHTOOL_FEC_RS;\n\t\tbreak;\n\tcase PORT_PHY_QCFG_RESP_ACTIVE_FEC_FEC_RS272_1XN_ACTIVE:\n\tcase PORT_PHY_QCFG_RESP_ACTIVE_FEC_FEC_RS272_IEEE_ACTIVE:\n\t\tfec->active_fec |= ETHTOOL_FEC_LLRS;\n\t\tbreak;\n\tcase PORT_PHY_QCFG_RESP_ACTIVE_FEC_FEC_NONE_ACTIVE:\n\t\tfec->active_fec |= ETHTOOL_FEC_OFF;\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic void bnxt_get_fec_stats(struct net_device *dev,\n\t\t\t       struct ethtool_fec_stats *fec_stats)\n{\n\tstruct bnxt *bp = netdev_priv(dev);\n\tu64 *rx;\n\n\tif (BNXT_VF(bp) || !(bp->flags & BNXT_FLAG_PORT_STATS_EXT))\n\t\treturn;\n\n\trx = bp->rx_port_stats_ext.sw_stats;\n\tfec_stats->corrected_bits.total =\n\t\t*(rx + BNXT_RX_STATS_EXT_OFFSET(rx_corrected_bits));\n\n\tif (bp->fw_rx_stats_ext_size <= BNXT_RX_STATS_EXT_NUM_LEGACY)\n\t\treturn;\n\n\tfec_stats->corrected_blocks.total =\n\t\t*(rx + BNXT_RX_STATS_EXT_OFFSET(rx_fec_corrected_blocks));\n\tfec_stats->uncorrectable_blocks.total =\n\t\t*(rx + BNXT_RX_STATS_EXT_OFFSET(rx_fec_uncorrectable_blocks));\n}\n\nstatic u32 bnxt_ethtool_forced_fec_to_fw(struct bnxt_link_info *link_info,\n\t\t\t\t\t u32 fec)\n{\n\tu32 fw_fec = PORT_PHY_CFG_REQ_FLAGS_FEC_AUTONEG_DISABLE;\n\n\tif (fec & ETHTOOL_FEC_BASER)\n\t\tfw_fec |= BNXT_FEC_BASE_R_ON(link_info);\n\telse if (fec & ETHTOOL_FEC_RS)\n\t\tfw_fec |= BNXT_FEC_RS_ON(link_info);\n\telse if (fec & ETHTOOL_FEC_LLRS)\n\t\tfw_fec |= BNXT_FEC_LLRS_ON;\n\treturn fw_fec;\n}\n\nstatic int bnxt_set_fecparam(struct net_device *dev,\n\t\t\t     struct ethtool_fecparam *fecparam)\n{\n\tstruct hwrm_port_phy_cfg_input *req;\n\tstruct bnxt *bp = netdev_priv(dev);\n\tstruct bnxt_link_info *link_info;\n\tu32 new_cfg, fec = fecparam->fec;\n\tu16 fec_cfg;\n\tint rc;\n\n\tlink_info = &bp->link_info;\n\tfec_cfg = link_info->fec_cfg;\n\tif (fec_cfg & BNXT_FEC_NONE)\n\t\treturn -EOPNOTSUPP;\n\n\tif (fec & ETHTOOL_FEC_OFF) {\n\t\tnew_cfg = PORT_PHY_CFG_REQ_FLAGS_FEC_AUTONEG_DISABLE |\n\t\t\t  BNXT_FEC_ALL_OFF(link_info);\n\t\tgoto apply_fec;\n\t}\n\tif (((fec & ETHTOOL_FEC_AUTO) && !(fec_cfg & BNXT_FEC_AUTONEG_CAP)) ||\n\t    ((fec & ETHTOOL_FEC_RS) && !(fec_cfg & BNXT_FEC_ENC_RS_CAP)) ||\n\t    ((fec & ETHTOOL_FEC_LLRS) && !(fec_cfg & BNXT_FEC_ENC_LLRS_CAP)) ||\n\t    ((fec & ETHTOOL_FEC_BASER) && !(fec_cfg & BNXT_FEC_ENC_BASE_R_CAP)))\n\t\treturn -EINVAL;\n\n\tif (fec & ETHTOOL_FEC_AUTO) {\n\t\tif (!link_info->autoneg)\n\t\t\treturn -EINVAL;\n\t\tnew_cfg = PORT_PHY_CFG_REQ_FLAGS_FEC_AUTONEG_ENABLE;\n\t} else {\n\t\tnew_cfg = bnxt_ethtool_forced_fec_to_fw(link_info, fec);\n\t}\n\napply_fec:\n\trc = hwrm_req_init(bp, req, HWRM_PORT_PHY_CFG);\n\tif (rc)\n\t\treturn rc;\n\treq->flags = cpu_to_le32(new_cfg | PORT_PHY_CFG_REQ_FLAGS_RESET_PHY);\n\trc = hwrm_req_send(bp, req);\n\t \n\tif (!rc) {\n\t\tmutex_lock(&bp->link_lock);\n\t\tbnxt_update_link(bp, false);\n\t\tmutex_unlock(&bp->link_lock);\n\t}\n\treturn rc;\n}\n\nstatic void bnxt_get_pauseparam(struct net_device *dev,\n\t\t\t\tstruct ethtool_pauseparam *epause)\n{\n\tstruct bnxt *bp = netdev_priv(dev);\n\tstruct bnxt_link_info *link_info = &bp->link_info;\n\n\tif (BNXT_VF(bp))\n\t\treturn;\n\tepause->autoneg = !!(link_info->autoneg & BNXT_AUTONEG_FLOW_CTRL);\n\tepause->rx_pause = !!(link_info->req_flow_ctrl & BNXT_LINK_PAUSE_RX);\n\tepause->tx_pause = !!(link_info->req_flow_ctrl & BNXT_LINK_PAUSE_TX);\n}\n\nstatic void bnxt_get_pause_stats(struct net_device *dev,\n\t\t\t\t struct ethtool_pause_stats *epstat)\n{\n\tstruct bnxt *bp = netdev_priv(dev);\n\tu64 *rx, *tx;\n\n\tif (BNXT_VF(bp) || !(bp->flags & BNXT_FLAG_PORT_STATS))\n\t\treturn;\n\n\trx = bp->port_stats.sw_stats;\n\ttx = bp->port_stats.sw_stats + BNXT_TX_PORT_STATS_BYTE_OFFSET / 8;\n\n\tepstat->rx_pause_frames = BNXT_GET_RX_PORT_STATS64(rx, rx_pause_frames);\n\tepstat->tx_pause_frames = BNXT_GET_TX_PORT_STATS64(tx, tx_pause_frames);\n}\n\nstatic int bnxt_set_pauseparam(struct net_device *dev,\n\t\t\t       struct ethtool_pauseparam *epause)\n{\n\tint rc = 0;\n\tstruct bnxt *bp = netdev_priv(dev);\n\tstruct bnxt_link_info *link_info = &bp->link_info;\n\n\tif (!BNXT_PHY_CFG_ABLE(bp) || (bp->phy_flags & BNXT_PHY_FL_NO_PAUSE))\n\t\treturn -EOPNOTSUPP;\n\n\tmutex_lock(&bp->link_lock);\n\tif (epause->autoneg) {\n\t\tif (!(link_info->autoneg & BNXT_AUTONEG_SPEED)) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto pause_exit;\n\t\t}\n\n\t\tlink_info->autoneg |= BNXT_AUTONEG_FLOW_CTRL;\n\t\tlink_info->req_flow_ctrl = 0;\n\t} else {\n\t\t \n\t\tif (link_info->autoneg & BNXT_AUTONEG_FLOW_CTRL)\n\t\t\tlink_info->force_link_chng = true;\n\t\tlink_info->autoneg &= ~BNXT_AUTONEG_FLOW_CTRL;\n\t\tlink_info->req_flow_ctrl = 0;\n\t}\n\tif (epause->rx_pause)\n\t\tlink_info->req_flow_ctrl |= BNXT_LINK_PAUSE_RX;\n\n\tif (epause->tx_pause)\n\t\tlink_info->req_flow_ctrl |= BNXT_LINK_PAUSE_TX;\n\n\tif (netif_running(dev))\n\t\trc = bnxt_hwrm_set_pause(bp);\n\npause_exit:\n\tmutex_unlock(&bp->link_lock);\n\treturn rc;\n}\n\nstatic u32 bnxt_get_link(struct net_device *dev)\n{\n\tstruct bnxt *bp = netdev_priv(dev);\n\n\t \n\treturn BNXT_LINK_IS_UP(bp);\n}\n\nint bnxt_hwrm_nvm_get_dev_info(struct bnxt *bp,\n\t\t\t       struct hwrm_nvm_get_dev_info_output *nvm_dev_info)\n{\n\tstruct hwrm_nvm_get_dev_info_output *resp;\n\tstruct hwrm_nvm_get_dev_info_input *req;\n\tint rc;\n\n\tif (BNXT_VF(bp))\n\t\treturn -EOPNOTSUPP;\n\n\trc = hwrm_req_init(bp, req, HWRM_NVM_GET_DEV_INFO);\n\tif (rc)\n\t\treturn rc;\n\n\tresp = hwrm_req_hold(bp, req);\n\trc = hwrm_req_send(bp, req);\n\tif (!rc)\n\t\tmemcpy(nvm_dev_info, resp, sizeof(*resp));\n\thwrm_req_drop(bp, req);\n\treturn rc;\n}\n\nstatic void bnxt_print_admin_err(struct bnxt *bp)\n{\n\tnetdev_info(bp->dev, \"PF does not have admin privileges to flash or reset the device\\n\");\n}\n\nint bnxt_find_nvram_item(struct net_device *dev, u16 type, u16 ordinal,\n\t\t\t u16 ext, u16 *index, u32 *item_length,\n\t\t\t u32 *data_length);\n\nint bnxt_flash_nvram(struct net_device *dev, u16 dir_type,\n\t\t     u16 dir_ordinal, u16 dir_ext, u16 dir_attr,\n\t\t     u32 dir_item_len, const u8 *data,\n\t\t     size_t data_len)\n{\n\tstruct bnxt *bp = netdev_priv(dev);\n\tstruct hwrm_nvm_write_input *req;\n\tint rc;\n\n\trc = hwrm_req_init(bp, req, HWRM_NVM_WRITE);\n\tif (rc)\n\t\treturn rc;\n\n\tif (data_len && data) {\n\t\tdma_addr_t dma_handle;\n\t\tu8 *kmem;\n\n\t\tkmem = hwrm_req_dma_slice(bp, req, data_len, &dma_handle);\n\t\tif (!kmem) {\n\t\t\thwrm_req_drop(bp, req);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\treq->dir_data_length = cpu_to_le32(data_len);\n\n\t\tmemcpy(kmem, data, data_len);\n\t\treq->host_src_addr = cpu_to_le64(dma_handle);\n\t}\n\n\thwrm_req_timeout(bp, req, bp->hwrm_cmd_max_timeout);\n\treq->dir_type = cpu_to_le16(dir_type);\n\treq->dir_ordinal = cpu_to_le16(dir_ordinal);\n\treq->dir_ext = cpu_to_le16(dir_ext);\n\treq->dir_attr = cpu_to_le16(dir_attr);\n\treq->dir_item_length = cpu_to_le32(dir_item_len);\n\trc = hwrm_req_send(bp, req);\n\n\tif (rc == -EACCES)\n\t\tbnxt_print_admin_err(bp);\n\treturn rc;\n}\n\nint bnxt_hwrm_firmware_reset(struct net_device *dev, u8 proc_type,\n\t\t\t     u8 self_reset, u8 flags)\n{\n\tstruct bnxt *bp = netdev_priv(dev);\n\tstruct hwrm_fw_reset_input *req;\n\tint rc;\n\n\tif (!bnxt_hwrm_reset_permitted(bp)) {\n\t\tnetdev_warn(bp->dev, \"Reset denied by firmware, it may be inhibited by remote driver\");\n\t\treturn -EPERM;\n\t}\n\n\trc = hwrm_req_init(bp, req, HWRM_FW_RESET);\n\tif (rc)\n\t\treturn rc;\n\n\treq->embedded_proc_type = proc_type;\n\treq->selfrst_status = self_reset;\n\treq->flags = flags;\n\n\tif (proc_type == FW_RESET_REQ_EMBEDDED_PROC_TYPE_AP) {\n\t\trc = hwrm_req_send_silent(bp, req);\n\t} else {\n\t\trc = hwrm_req_send(bp, req);\n\t\tif (rc == -EACCES)\n\t\t\tbnxt_print_admin_err(bp);\n\t}\n\treturn rc;\n}\n\nstatic int bnxt_firmware_reset(struct net_device *dev,\n\t\t\t       enum bnxt_nvm_directory_type dir_type)\n{\n\tu8 self_reset = FW_RESET_REQ_SELFRST_STATUS_SELFRSTNONE;\n\tu8 proc_type, flags = 0;\n\n\t \n\t \n\tswitch (dir_type) {\n\tcase BNX_DIR_TYPE_CHIMP_PATCH:\n\tcase BNX_DIR_TYPE_BOOTCODE:\n\tcase BNX_DIR_TYPE_BOOTCODE_2:\n\t\tproc_type = FW_RESET_REQ_EMBEDDED_PROC_TYPE_BOOT;\n\t\t \n\t\tself_reset = FW_RESET_REQ_SELFRST_STATUS_SELFRSTPCIERST;\n\t\tbreak;\n\tcase BNX_DIR_TYPE_APE_FW:\n\tcase BNX_DIR_TYPE_APE_PATCH:\n\t\tproc_type = FW_RESET_REQ_EMBEDDED_PROC_TYPE_MGMT;\n\t\t \n\t\tself_reset = FW_RESET_REQ_SELFRST_STATUS_SELFRSTPCIERST;\n\t\tbreak;\n\tcase BNX_DIR_TYPE_KONG_FW:\n\tcase BNX_DIR_TYPE_KONG_PATCH:\n\t\tproc_type = FW_RESET_REQ_EMBEDDED_PROC_TYPE_NETCTRL;\n\t\tbreak;\n\tcase BNX_DIR_TYPE_BONO_FW:\n\tcase BNX_DIR_TYPE_BONO_PATCH:\n\t\tproc_type = FW_RESET_REQ_EMBEDDED_PROC_TYPE_ROCE;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn bnxt_hwrm_firmware_reset(dev, proc_type, self_reset, flags);\n}\n\nstatic int bnxt_firmware_reset_chip(struct net_device *dev)\n{\n\tstruct bnxt *bp = netdev_priv(dev);\n\tu8 flags = 0;\n\n\tif (bp->fw_cap & BNXT_FW_CAP_HOT_RESET)\n\t\tflags = FW_RESET_REQ_FLAGS_RESET_GRACEFUL;\n\n\treturn bnxt_hwrm_firmware_reset(dev,\n\t\t\t\t\tFW_RESET_REQ_EMBEDDED_PROC_TYPE_CHIP,\n\t\t\t\t\tFW_RESET_REQ_SELFRST_STATUS_SELFRSTASAP,\n\t\t\t\t\tflags);\n}\n\nstatic int bnxt_firmware_reset_ap(struct net_device *dev)\n{\n\treturn bnxt_hwrm_firmware_reset(dev, FW_RESET_REQ_EMBEDDED_PROC_TYPE_AP,\n\t\t\t\t\tFW_RESET_REQ_SELFRST_STATUS_SELFRSTNONE,\n\t\t\t\t\t0);\n}\n\nstatic int bnxt_flash_firmware(struct net_device *dev,\n\t\t\t       u16 dir_type,\n\t\t\t       const u8 *fw_data,\n\t\t\t       size_t fw_size)\n{\n\tint\trc = 0;\n\tu16\tcode_type;\n\tu32\tstored_crc;\n\tu32\tcalculated_crc;\n\tstruct bnxt_fw_header *header = (struct bnxt_fw_header *)fw_data;\n\n\tswitch (dir_type) {\n\tcase BNX_DIR_TYPE_BOOTCODE:\n\tcase BNX_DIR_TYPE_BOOTCODE_2:\n\t\tcode_type = CODE_BOOT;\n\t\tbreak;\n\tcase BNX_DIR_TYPE_CHIMP_PATCH:\n\t\tcode_type = CODE_CHIMP_PATCH;\n\t\tbreak;\n\tcase BNX_DIR_TYPE_APE_FW:\n\t\tcode_type = CODE_MCTP_PASSTHRU;\n\t\tbreak;\n\tcase BNX_DIR_TYPE_APE_PATCH:\n\t\tcode_type = CODE_APE_PATCH;\n\t\tbreak;\n\tcase BNX_DIR_TYPE_KONG_FW:\n\t\tcode_type = CODE_KONG_FW;\n\t\tbreak;\n\tcase BNX_DIR_TYPE_KONG_PATCH:\n\t\tcode_type = CODE_KONG_PATCH;\n\t\tbreak;\n\tcase BNX_DIR_TYPE_BONO_FW:\n\t\tcode_type = CODE_BONO_FW;\n\t\tbreak;\n\tcase BNX_DIR_TYPE_BONO_PATCH:\n\t\tcode_type = CODE_BONO_PATCH;\n\t\tbreak;\n\tdefault:\n\t\tnetdev_err(dev, \"Unsupported directory entry type: %u\\n\",\n\t\t\t   dir_type);\n\t\treturn -EINVAL;\n\t}\n\tif (fw_size < sizeof(struct bnxt_fw_header)) {\n\t\tnetdev_err(dev, \"Invalid firmware file size: %u\\n\",\n\t\t\t   (unsigned int)fw_size);\n\t\treturn -EINVAL;\n\t}\n\tif (header->signature != cpu_to_le32(BNXT_FIRMWARE_BIN_SIGNATURE)) {\n\t\tnetdev_err(dev, \"Invalid firmware signature: %08X\\n\",\n\t\t\t   le32_to_cpu(header->signature));\n\t\treturn -EINVAL;\n\t}\n\tif (header->code_type != code_type) {\n\t\tnetdev_err(dev, \"Expected firmware type: %d, read: %d\\n\",\n\t\t\t   code_type, header->code_type);\n\t\treturn -EINVAL;\n\t}\n\tif (header->device != DEVICE_CUMULUS_FAMILY) {\n\t\tnetdev_err(dev, \"Expected firmware device family %d, read: %d\\n\",\n\t\t\t   DEVICE_CUMULUS_FAMILY, header->device);\n\t\treturn -EINVAL;\n\t}\n\t \n\tstored_crc = le32_to_cpu(*(__le32 *)(fw_data + fw_size -\n\t\t\t\t\t     sizeof(stored_crc)));\n\tcalculated_crc = ~crc32(~0, fw_data, fw_size - sizeof(stored_crc));\n\tif (calculated_crc != stored_crc) {\n\t\tnetdev_err(dev, \"Firmware file CRC32 checksum (%08lX) does not match calculated checksum (%08lX)\\n\",\n\t\t\t   (unsigned long)stored_crc,\n\t\t\t   (unsigned long)calculated_crc);\n\t\treturn -EINVAL;\n\t}\n\trc = bnxt_flash_nvram(dev, dir_type, BNX_DIR_ORDINAL_FIRST,\n\t\t\t      0, 0, 0, fw_data, fw_size);\n\tif (rc == 0)\t \n\t\trc = bnxt_firmware_reset(dev, dir_type);\n\n\treturn rc;\n}\n\nstatic int bnxt_flash_microcode(struct net_device *dev,\n\t\t\t\tu16 dir_type,\n\t\t\t\tconst u8 *fw_data,\n\t\t\t\tsize_t fw_size)\n{\n\tstruct bnxt_ucode_trailer *trailer;\n\tu32 calculated_crc;\n\tu32 stored_crc;\n\tint rc = 0;\n\n\tif (fw_size < sizeof(struct bnxt_ucode_trailer)) {\n\t\tnetdev_err(dev, \"Invalid microcode file size: %u\\n\",\n\t\t\t   (unsigned int)fw_size);\n\t\treturn -EINVAL;\n\t}\n\ttrailer = (struct bnxt_ucode_trailer *)(fw_data + (fw_size -\n\t\t\t\t\t\tsizeof(*trailer)));\n\tif (trailer->sig != cpu_to_le32(BNXT_UCODE_TRAILER_SIGNATURE)) {\n\t\tnetdev_err(dev, \"Invalid microcode trailer signature: %08X\\n\",\n\t\t\t   le32_to_cpu(trailer->sig));\n\t\treturn -EINVAL;\n\t}\n\tif (le16_to_cpu(trailer->dir_type) != dir_type) {\n\t\tnetdev_err(dev, \"Expected microcode type: %d, read: %d\\n\",\n\t\t\t   dir_type, le16_to_cpu(trailer->dir_type));\n\t\treturn -EINVAL;\n\t}\n\tif (le16_to_cpu(trailer->trailer_length) <\n\t\tsizeof(struct bnxt_ucode_trailer)) {\n\t\tnetdev_err(dev, \"Invalid microcode trailer length: %d\\n\",\n\t\t\t   le16_to_cpu(trailer->trailer_length));\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tstored_crc = le32_to_cpu(*(__le32 *)(fw_data + fw_size -\n\t\t\t\t\t     sizeof(stored_crc)));\n\tcalculated_crc = ~crc32(~0, fw_data, fw_size - sizeof(stored_crc));\n\tif (calculated_crc != stored_crc) {\n\t\tnetdev_err(dev,\n\t\t\t   \"CRC32 (%08lX) does not match calculated: %08lX\\n\",\n\t\t\t   (unsigned long)stored_crc,\n\t\t\t   (unsigned long)calculated_crc);\n\t\treturn -EINVAL;\n\t}\n\trc = bnxt_flash_nvram(dev, dir_type, BNX_DIR_ORDINAL_FIRST,\n\t\t\t      0, 0, 0, fw_data, fw_size);\n\n\treturn rc;\n}\n\nstatic bool bnxt_dir_type_is_ape_bin_format(u16 dir_type)\n{\n\tswitch (dir_type) {\n\tcase BNX_DIR_TYPE_CHIMP_PATCH:\n\tcase BNX_DIR_TYPE_BOOTCODE:\n\tcase BNX_DIR_TYPE_BOOTCODE_2:\n\tcase BNX_DIR_TYPE_APE_FW:\n\tcase BNX_DIR_TYPE_APE_PATCH:\n\tcase BNX_DIR_TYPE_KONG_FW:\n\tcase BNX_DIR_TYPE_KONG_PATCH:\n\tcase BNX_DIR_TYPE_BONO_FW:\n\tcase BNX_DIR_TYPE_BONO_PATCH:\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic bool bnxt_dir_type_is_other_exec_format(u16 dir_type)\n{\n\tswitch (dir_type) {\n\tcase BNX_DIR_TYPE_AVS:\n\tcase BNX_DIR_TYPE_EXP_ROM_MBA:\n\tcase BNX_DIR_TYPE_PCIE:\n\tcase BNX_DIR_TYPE_TSCF_UCODE:\n\tcase BNX_DIR_TYPE_EXT_PHY:\n\tcase BNX_DIR_TYPE_CCM:\n\tcase BNX_DIR_TYPE_ISCSI_BOOT:\n\tcase BNX_DIR_TYPE_ISCSI_BOOT_IPV6:\n\tcase BNX_DIR_TYPE_ISCSI_BOOT_IPV4N6:\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic bool bnxt_dir_type_is_executable(u16 dir_type)\n{\n\treturn bnxt_dir_type_is_ape_bin_format(dir_type) ||\n\t\tbnxt_dir_type_is_other_exec_format(dir_type);\n}\n\nstatic int bnxt_flash_firmware_from_file(struct net_device *dev,\n\t\t\t\t\t u16 dir_type,\n\t\t\t\t\t const char *filename)\n{\n\tconst struct firmware  *fw;\n\tint\t\t\trc;\n\n\trc = request_firmware(&fw, filename, &dev->dev);\n\tif (rc != 0) {\n\t\tnetdev_err(dev, \"Error %d requesting firmware file: %s\\n\",\n\t\t\t   rc, filename);\n\t\treturn rc;\n\t}\n\tif (bnxt_dir_type_is_ape_bin_format(dir_type))\n\t\trc = bnxt_flash_firmware(dev, dir_type, fw->data, fw->size);\n\telse if (bnxt_dir_type_is_other_exec_format(dir_type))\n\t\trc = bnxt_flash_microcode(dev, dir_type, fw->data, fw->size);\n\telse\n\t\trc = bnxt_flash_nvram(dev, dir_type, BNX_DIR_ORDINAL_FIRST,\n\t\t\t\t      0, 0, 0, fw->data, fw->size);\n\trelease_firmware(fw);\n\treturn rc;\n}\n\n#define MSG_INTEGRITY_ERR \"PKG install error : Data integrity on NVM\"\n#define MSG_INVALID_PKG \"PKG install error : Invalid package\"\n#define MSG_AUTHENTICATION_ERR \"PKG install error : Authentication error\"\n#define MSG_INVALID_DEV \"PKG install error : Invalid device\"\n#define MSG_INTERNAL_ERR \"PKG install error : Internal error\"\n#define MSG_NO_PKG_UPDATE_AREA_ERR \"PKG update area not created in nvram\"\n#define MSG_NO_SPACE_ERR \"PKG insufficient update area in nvram\"\n#define MSG_RESIZE_UPDATE_ERR \"Resize UPDATE entry error\"\n#define MSG_ANTI_ROLLBACK_ERR \"HWRM_NVM_INSTALL_UPDATE failure due to Anti-rollback detected\"\n#define MSG_GENERIC_FAILURE_ERR \"HWRM_NVM_INSTALL_UPDATE failure\"\n\nstatic int nvm_update_err_to_stderr(struct net_device *dev, u8 result,\n\t\t\t\t    struct netlink_ext_ack *extack)\n{\n\tswitch (result) {\n\tcase NVM_INSTALL_UPDATE_RESP_RESULT_INVALID_TYPE_PARAMETER:\n\tcase NVM_INSTALL_UPDATE_RESP_RESULT_INVALID_INDEX_PARAMETER:\n\tcase NVM_INSTALL_UPDATE_RESP_RESULT_INSTALL_DATA_ERROR:\n\tcase NVM_INSTALL_UPDATE_RESP_RESULT_INSTALL_CHECKSUM_ERROR:\n\tcase NVM_INSTALL_UPDATE_RESP_RESULT_ITEM_NOT_FOUND:\n\tcase NVM_INSTALL_UPDATE_RESP_RESULT_ITEM_LOCKED:\n\t\tBNXT_NVM_ERR_MSG(dev, extack, MSG_INTEGRITY_ERR);\n\t\treturn -EINVAL;\n\tcase NVM_INSTALL_UPDATE_RESP_RESULT_INVALID_PREREQUISITE:\n\tcase NVM_INSTALL_UPDATE_RESP_RESULT_INVALID_FILE_HEADER:\n\tcase NVM_INSTALL_UPDATE_RESP_RESULT_INVALID_SIGNATURE:\n\tcase NVM_INSTALL_UPDATE_RESP_RESULT_INVALID_PROP_STREAM:\n\tcase NVM_INSTALL_UPDATE_RESP_RESULT_INVALID_PROP_LENGTH:\n\tcase NVM_INSTALL_UPDATE_RESP_RESULT_INVALID_MANIFEST:\n\tcase NVM_INSTALL_UPDATE_RESP_RESULT_INVALID_TRAILER:\n\tcase NVM_INSTALL_UPDATE_RESP_RESULT_INVALID_CHECKSUM:\n\tcase NVM_INSTALL_UPDATE_RESP_RESULT_INVALID_ITEM_CHECKSUM:\n\tcase NVM_INSTALL_UPDATE_RESP_RESULT_INVALID_DATA_LENGTH:\n\tcase NVM_INSTALL_UPDATE_RESP_RESULT_INVALID_DIRECTIVE:\n\tcase NVM_INSTALL_UPDATE_RESP_RESULT_DUPLICATE_ITEM:\n\tcase NVM_INSTALL_UPDATE_RESP_RESULT_ZERO_LENGTH_ITEM:\n\t\tBNXT_NVM_ERR_MSG(dev, extack, MSG_INVALID_PKG);\n\t\treturn -ENOPKG;\n\tcase NVM_INSTALL_UPDATE_RESP_RESULT_INSTALL_AUTHENTICATION_ERROR:\n\t\tBNXT_NVM_ERR_MSG(dev, extack, MSG_AUTHENTICATION_ERR);\n\t\treturn -EPERM;\n\tcase NVM_INSTALL_UPDATE_RESP_RESULT_UNSUPPORTED_CHIP_REV:\n\tcase NVM_INSTALL_UPDATE_RESP_RESULT_UNSUPPORTED_DEVICE_ID:\n\tcase NVM_INSTALL_UPDATE_RESP_RESULT_UNSUPPORTED_SUBSYS_VENDOR:\n\tcase NVM_INSTALL_UPDATE_RESP_RESULT_UNSUPPORTED_SUBSYS_ID:\n\tcase NVM_INSTALL_UPDATE_RESP_RESULT_UNSUPPORTED_PLATFORM:\n\t\tBNXT_NVM_ERR_MSG(dev, extack, MSG_INVALID_DEV);\n\t\treturn -EOPNOTSUPP;\n\tdefault:\n\t\tBNXT_NVM_ERR_MSG(dev, extack, MSG_INTERNAL_ERR);\n\t\treturn -EIO;\n\t}\n}\n\n#define BNXT_PKG_DMA_SIZE\t0x40000\n#define BNXT_NVM_MORE_FLAG\t(cpu_to_le16(NVM_MODIFY_REQ_FLAGS_BATCH_MODE))\n#define BNXT_NVM_LAST_FLAG\t(cpu_to_le16(NVM_MODIFY_REQ_FLAGS_BATCH_LAST))\n\nstatic int bnxt_resize_update_entry(struct net_device *dev, size_t fw_size,\n\t\t\t\t    struct netlink_ext_ack *extack)\n{\n\tu32 item_len;\n\tint rc;\n\n\trc = bnxt_find_nvram_item(dev, BNX_DIR_TYPE_UPDATE,\n\t\t\t\t  BNX_DIR_ORDINAL_FIRST, BNX_DIR_EXT_NONE, NULL,\n\t\t\t\t  &item_len, NULL);\n\tif (rc) {\n\t\tBNXT_NVM_ERR_MSG(dev, extack, MSG_NO_PKG_UPDATE_AREA_ERR);\n\t\treturn rc;\n\t}\n\n\tif (fw_size > item_len) {\n\t\trc = bnxt_flash_nvram(dev, BNX_DIR_TYPE_UPDATE,\n\t\t\t\t      BNX_DIR_ORDINAL_FIRST, 0, 1,\n\t\t\t\t      round_up(fw_size, 4096), NULL, 0);\n\t\tif (rc) {\n\t\t\tBNXT_NVM_ERR_MSG(dev, extack, MSG_RESIZE_UPDATE_ERR);\n\t\t\treturn rc;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint bnxt_flash_package_from_fw_obj(struct net_device *dev, const struct firmware *fw,\n\t\t\t\t   u32 install_type, struct netlink_ext_ack *extack)\n{\n\tstruct hwrm_nvm_install_update_input *install;\n\tstruct hwrm_nvm_install_update_output *resp;\n\tstruct hwrm_nvm_modify_input *modify;\n\tstruct bnxt *bp = netdev_priv(dev);\n\tbool defrag_attempted = false;\n\tdma_addr_t dma_handle;\n\tu8 *kmem = NULL;\n\tu32 modify_len;\n\tu32 item_len;\n\tu8 cmd_err;\n\tu16 index;\n\tint rc;\n\n\t \n\trc = bnxt_resize_update_entry(dev, fw->size, extack);\n\tif (rc)\n\t\treturn rc;\n\n\tbnxt_hwrm_fw_set_time(bp);\n\n\trc = hwrm_req_init(bp, modify, HWRM_NVM_MODIFY);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tmodify_len = roundup_pow_of_two(fw->size);\n\tmodify_len = min_t(u32, modify_len, BNXT_PKG_DMA_SIZE);\n\twhile (1) {\n\t\tkmem = hwrm_req_dma_slice(bp, modify, modify_len, &dma_handle);\n\t\tif (!kmem && modify_len > PAGE_SIZE)\n\t\t\tmodify_len /= 2;\n\t\telse\n\t\t\tbreak;\n\t}\n\tif (!kmem) {\n\t\thwrm_req_drop(bp, modify);\n\t\treturn -ENOMEM;\n\t}\n\n\trc = hwrm_req_init(bp, install, HWRM_NVM_INSTALL_UPDATE);\n\tif (rc) {\n\t\thwrm_req_drop(bp, modify);\n\t\treturn rc;\n\t}\n\n\thwrm_req_timeout(bp, modify, bp->hwrm_cmd_max_timeout);\n\thwrm_req_timeout(bp, install, bp->hwrm_cmd_max_timeout);\n\n\thwrm_req_hold(bp, modify);\n\tmodify->host_src_addr = cpu_to_le64(dma_handle);\n\n\tresp = hwrm_req_hold(bp, install);\n\tif ((install_type & 0xffff) == 0)\n\t\tinstall_type >>= 16;\n\tinstall->install_type = cpu_to_le32(install_type);\n\n\tdo {\n\t\tu32 copied = 0, len = modify_len;\n\n\t\trc = bnxt_find_nvram_item(dev, BNX_DIR_TYPE_UPDATE,\n\t\t\t\t\t  BNX_DIR_ORDINAL_FIRST,\n\t\t\t\t\t  BNX_DIR_EXT_NONE,\n\t\t\t\t\t  &index, &item_len, NULL);\n\t\tif (rc) {\n\t\t\tBNXT_NVM_ERR_MSG(dev, extack, MSG_NO_PKG_UPDATE_AREA_ERR);\n\t\t\tbreak;\n\t\t}\n\t\tif (fw->size > item_len) {\n\t\t\tBNXT_NVM_ERR_MSG(dev, extack, MSG_NO_SPACE_ERR);\n\t\t\trc = -EFBIG;\n\t\t\tbreak;\n\t\t}\n\n\t\tmodify->dir_idx = cpu_to_le16(index);\n\n\t\tif (fw->size > modify_len)\n\t\t\tmodify->flags = BNXT_NVM_MORE_FLAG;\n\t\twhile (copied < fw->size) {\n\t\t\tu32 balance = fw->size - copied;\n\n\t\t\tif (balance <= modify_len) {\n\t\t\t\tlen = balance;\n\t\t\t\tif (copied)\n\t\t\t\t\tmodify->flags |= BNXT_NVM_LAST_FLAG;\n\t\t\t}\n\t\t\tmemcpy(kmem, fw->data + copied, len);\n\t\t\tmodify->len = cpu_to_le32(len);\n\t\t\tmodify->offset = cpu_to_le32(copied);\n\t\t\trc = hwrm_req_send(bp, modify);\n\t\t\tif (rc)\n\t\t\t\tgoto pkg_abort;\n\t\t\tcopied += len;\n\t\t}\n\n\t\trc = hwrm_req_send_silent(bp, install);\n\t\tif (!rc)\n\t\t\tbreak;\n\n\t\tif (defrag_attempted) {\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\n\t\tcmd_err = ((struct hwrm_err_output *)resp)->cmd_err;\n\n\t\tswitch (cmd_err) {\n\t\tcase NVM_INSTALL_UPDATE_CMD_ERR_CODE_ANTI_ROLLBACK:\n\t\t\tBNXT_NVM_ERR_MSG(dev, extack, MSG_ANTI_ROLLBACK_ERR);\n\t\t\trc = -EALREADY;\n\t\t\tbreak;\n\t\tcase NVM_INSTALL_UPDATE_CMD_ERR_CODE_FRAG_ERR:\n\t\t\tinstall->flags =\n\t\t\t\tcpu_to_le16(NVM_INSTALL_UPDATE_REQ_FLAGS_ALLOWED_TO_DEFRAG);\n\n\t\t\trc = hwrm_req_send_silent(bp, install);\n\t\t\tif (!rc)\n\t\t\t\tbreak;\n\n\t\t\tcmd_err = ((struct hwrm_err_output *)resp)->cmd_err;\n\n\t\t\tif (cmd_err == NVM_INSTALL_UPDATE_CMD_ERR_CODE_NO_SPACE) {\n\t\t\t\t \n\t\t\t\tdefrag_attempted = true;\n\t\t\t\tinstall->flags = 0;\n\t\t\t\trc = bnxt_flash_nvram(bp->dev,\n\t\t\t\t\t\t      BNX_DIR_TYPE_UPDATE,\n\t\t\t\t\t\t      BNX_DIR_ORDINAL_FIRST,\n\t\t\t\t\t\t      0, 0, item_len, NULL, 0);\n\t\t\t\tif (!rc)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfallthrough;\n\t\tdefault:\n\t\t\tBNXT_NVM_ERR_MSG(dev, extack, MSG_GENERIC_FAILURE_ERR);\n\t\t}\n\t} while (defrag_attempted && !rc);\n\npkg_abort:\n\thwrm_req_drop(bp, modify);\n\thwrm_req_drop(bp, install);\n\n\tif (resp->result) {\n\t\tnetdev_err(dev, \"PKG install error = %d, problem_item = %d\\n\",\n\t\t\t   (s8)resp->result, (int)resp->problem_item);\n\t\trc = nvm_update_err_to_stderr(dev, resp->result, extack);\n\t}\n\tif (rc == -EACCES)\n\t\tbnxt_print_admin_err(bp);\n\treturn rc;\n}\n\nstatic int bnxt_flash_package_from_file(struct net_device *dev, const char *filename,\n\t\t\t\t\tu32 install_type, struct netlink_ext_ack *extack)\n{\n\tconst struct firmware *fw;\n\tint rc;\n\n\trc = request_firmware(&fw, filename, &dev->dev);\n\tif (rc != 0) {\n\t\tnetdev_err(dev, \"PKG error %d requesting file: %s\\n\",\n\t\t\t   rc, filename);\n\t\treturn rc;\n\t}\n\n\trc = bnxt_flash_package_from_fw_obj(dev, fw, install_type, extack);\n\n\trelease_firmware(fw);\n\n\treturn rc;\n}\n\nstatic int bnxt_flash_device(struct net_device *dev,\n\t\t\t     struct ethtool_flash *flash)\n{\n\tif (!BNXT_PF((struct bnxt *)netdev_priv(dev))) {\n\t\tnetdev_err(dev, \"flashdev not supported from a virtual function\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (flash->region == ETHTOOL_FLASH_ALL_REGIONS ||\n\t    flash->region > 0xffff)\n\t\treturn bnxt_flash_package_from_file(dev, flash->data,\n\t\t\t\t\t\t    flash->region, NULL);\n\n\treturn bnxt_flash_firmware_from_file(dev, flash->region, flash->data);\n}\n\nstatic int nvm_get_dir_info(struct net_device *dev, u32 *entries, u32 *length)\n{\n\tstruct hwrm_nvm_get_dir_info_output *output;\n\tstruct hwrm_nvm_get_dir_info_input *req;\n\tstruct bnxt *bp = netdev_priv(dev);\n\tint rc;\n\n\trc = hwrm_req_init(bp, req, HWRM_NVM_GET_DIR_INFO);\n\tif (rc)\n\t\treturn rc;\n\n\toutput = hwrm_req_hold(bp, req);\n\trc = hwrm_req_send(bp, req);\n\tif (!rc) {\n\t\t*entries = le32_to_cpu(output->entries);\n\t\t*length = le32_to_cpu(output->entry_length);\n\t}\n\thwrm_req_drop(bp, req);\n\treturn rc;\n}\n\nstatic int bnxt_get_eeprom_len(struct net_device *dev)\n{\n\tstruct bnxt *bp = netdev_priv(dev);\n\n\tif (BNXT_VF(bp))\n\t\treturn 0;\n\n\t \n\treturn -1;\n}\n\nstatic int bnxt_get_nvram_directory(struct net_device *dev, u32 len, u8 *data)\n{\n\tstruct bnxt *bp = netdev_priv(dev);\n\tint rc;\n\tu32 dir_entries;\n\tu32 entry_length;\n\tu8 *buf;\n\tsize_t buflen;\n\tdma_addr_t dma_handle;\n\tstruct hwrm_nvm_get_dir_entries_input *req;\n\n\trc = nvm_get_dir_info(dev, &dir_entries, &entry_length);\n\tif (rc != 0)\n\t\treturn rc;\n\n\tif (!dir_entries || !entry_length)\n\t\treturn -EIO;\n\n\t \n\tif (len < 2)\n\t\treturn -EINVAL;\n\n\t*data++ = dir_entries;\n\t*data++ = entry_length;\n\tlen -= 2;\n\tmemset(data, 0xff, len);\n\n\trc = hwrm_req_init(bp, req, HWRM_NVM_GET_DIR_ENTRIES);\n\tif (rc)\n\t\treturn rc;\n\n\tbuflen = mul_u32_u32(dir_entries, entry_length);\n\tbuf = hwrm_req_dma_slice(bp, req, buflen, &dma_handle);\n\tif (!buf) {\n\t\thwrm_req_drop(bp, req);\n\t\treturn -ENOMEM;\n\t}\n\treq->host_dest_addr = cpu_to_le64(dma_handle);\n\n\thwrm_req_hold(bp, req);  \n\trc = hwrm_req_send(bp, req);\n\tif (rc == 0)\n\t\tmemcpy(data, buf, len > buflen ? buflen : len);\n\thwrm_req_drop(bp, req);\n\treturn rc;\n}\n\nint bnxt_get_nvram_item(struct net_device *dev, u32 index, u32 offset,\n\t\t\tu32 length, u8 *data)\n{\n\tstruct bnxt *bp = netdev_priv(dev);\n\tint rc;\n\tu8 *buf;\n\tdma_addr_t dma_handle;\n\tstruct hwrm_nvm_read_input *req;\n\n\tif (!length)\n\t\treturn -EINVAL;\n\n\trc = hwrm_req_init(bp, req, HWRM_NVM_READ);\n\tif (rc)\n\t\treturn rc;\n\n\tbuf = hwrm_req_dma_slice(bp, req, length, &dma_handle);\n\tif (!buf) {\n\t\thwrm_req_drop(bp, req);\n\t\treturn -ENOMEM;\n\t}\n\n\treq->host_dest_addr = cpu_to_le64(dma_handle);\n\treq->dir_idx = cpu_to_le16(index);\n\treq->offset = cpu_to_le32(offset);\n\treq->len = cpu_to_le32(length);\n\n\thwrm_req_hold(bp, req);  \n\trc = hwrm_req_send(bp, req);\n\tif (rc == 0)\n\t\tmemcpy(data, buf, length);\n\thwrm_req_drop(bp, req);\n\treturn rc;\n}\n\nint bnxt_find_nvram_item(struct net_device *dev, u16 type, u16 ordinal,\n\t\t\t u16 ext, u16 *index, u32 *item_length,\n\t\t\t u32 *data_length)\n{\n\tstruct hwrm_nvm_find_dir_entry_output *output;\n\tstruct hwrm_nvm_find_dir_entry_input *req;\n\tstruct bnxt *bp = netdev_priv(dev);\n\tint rc;\n\n\trc = hwrm_req_init(bp, req, HWRM_NVM_FIND_DIR_ENTRY);\n\tif (rc)\n\t\treturn rc;\n\n\treq->enables = 0;\n\treq->dir_idx = 0;\n\treq->dir_type = cpu_to_le16(type);\n\treq->dir_ordinal = cpu_to_le16(ordinal);\n\treq->dir_ext = cpu_to_le16(ext);\n\treq->opt_ordinal = NVM_FIND_DIR_ENTRY_REQ_OPT_ORDINAL_EQ;\n\toutput = hwrm_req_hold(bp, req);\n\trc = hwrm_req_send_silent(bp, req);\n\tif (rc == 0) {\n\t\tif (index)\n\t\t\t*index = le16_to_cpu(output->dir_idx);\n\t\tif (item_length)\n\t\t\t*item_length = le32_to_cpu(output->dir_item_length);\n\t\tif (data_length)\n\t\t\t*data_length = le32_to_cpu(output->dir_data_length);\n\t}\n\thwrm_req_drop(bp, req);\n\treturn rc;\n}\n\nstatic char *bnxt_parse_pkglog(int desired_field, u8 *data, size_t datalen)\n{\n\tchar\t*retval = NULL;\n\tchar\t*p;\n\tchar\t*value;\n\tint\tfield = 0;\n\n\tif (datalen < 1)\n\t\treturn NULL;\n\t \n\tdata[datalen - 1] = 0;\n\tfor (p = data; *p != 0; p++) {\n\t\tfield = 0;\n\t\tretval = NULL;\n\t\twhile (*p != 0 && *p != '\\n') {\n\t\t\tvalue = p;\n\t\t\twhile (*p != 0 && *p != '\\t' && *p != '\\n')\n\t\t\t\tp++;\n\t\t\tif (field == desired_field)\n\t\t\t\tretval = value;\n\t\t\tif (*p != '\\t')\n\t\t\t\tbreak;\n\t\t\t*p = 0;\n\t\t\tfield++;\n\t\t\tp++;\n\t\t}\n\t\tif (*p == 0)\n\t\t\tbreak;\n\t\t*p = 0;\n\t}\n\treturn retval;\n}\n\nint bnxt_get_pkginfo(struct net_device *dev, char *ver, int size)\n{\n\tstruct bnxt *bp = netdev_priv(dev);\n\tu16 index = 0;\n\tchar *pkgver;\n\tu32 pkglen;\n\tu8 *pkgbuf;\n\tint rc;\n\n\trc = bnxt_find_nvram_item(dev, BNX_DIR_TYPE_PKG_LOG,\n\t\t\t\t  BNX_DIR_ORDINAL_FIRST, BNX_DIR_EXT_NONE,\n\t\t\t\t  &index, NULL, &pkglen);\n\tif (rc)\n\t\treturn rc;\n\n\tpkgbuf = kzalloc(pkglen, GFP_KERNEL);\n\tif (!pkgbuf) {\n\t\tdev_err(&bp->pdev->dev, \"Unable to allocate memory for pkg version, length = %u\\n\",\n\t\t\tpkglen);\n\t\treturn -ENOMEM;\n\t}\n\n\trc = bnxt_get_nvram_item(dev, index, 0, pkglen, pkgbuf);\n\tif (rc)\n\t\tgoto err;\n\n\tpkgver = bnxt_parse_pkglog(BNX_PKG_LOG_FIELD_IDX_PKG_VERSION, pkgbuf,\n\t\t\t\t   pkglen);\n\tif (pkgver && *pkgver != 0 && isdigit(*pkgver))\n\t\tstrscpy(ver, pkgver, size);\n\telse\n\t\trc = -ENOENT;\n\nerr:\n\tkfree(pkgbuf);\n\n\treturn rc;\n}\n\nstatic void bnxt_get_pkgver(struct net_device *dev)\n{\n\tstruct bnxt *bp = netdev_priv(dev);\n\tchar buf[FW_VER_STR_LEN];\n\tint len;\n\n\tif (!bnxt_get_pkginfo(dev, buf, sizeof(buf))) {\n\t\tlen = strlen(bp->fw_ver_str);\n\t\tsnprintf(bp->fw_ver_str + len, FW_VER_STR_LEN - len - 1,\n\t\t\t \"/pkg %s\", buf);\n\t}\n}\n\nstatic int bnxt_get_eeprom(struct net_device *dev,\n\t\t\t   struct ethtool_eeprom *eeprom,\n\t\t\t   u8 *data)\n{\n\tu32 index;\n\tu32 offset;\n\n\tif (eeprom->offset == 0)  \n\t\treturn bnxt_get_nvram_directory(dev, eeprom->len, data);\n\n\tindex = eeprom->offset >> 24;\n\toffset = eeprom->offset & 0xffffff;\n\n\tif (index == 0) {\n\t\tnetdev_err(dev, \"unsupported index value: %d\\n\", index);\n\t\treturn -EINVAL;\n\t}\n\n\treturn bnxt_get_nvram_item(dev, index - 1, offset, eeprom->len, data);\n}\n\nstatic int bnxt_erase_nvram_directory(struct net_device *dev, u8 index)\n{\n\tstruct hwrm_nvm_erase_dir_entry_input *req;\n\tstruct bnxt *bp = netdev_priv(dev);\n\tint rc;\n\n\trc = hwrm_req_init(bp, req, HWRM_NVM_ERASE_DIR_ENTRY);\n\tif (rc)\n\t\treturn rc;\n\n\treq->dir_idx = cpu_to_le16(index);\n\treturn hwrm_req_send(bp, req);\n}\n\nstatic int bnxt_set_eeprom(struct net_device *dev,\n\t\t\t   struct ethtool_eeprom *eeprom,\n\t\t\t   u8 *data)\n{\n\tstruct bnxt *bp = netdev_priv(dev);\n\tu8 index, dir_op;\n\tu16 type, ext, ordinal, attr;\n\n\tif (!BNXT_PF(bp)) {\n\t\tnetdev_err(dev, \"NVM write not supported from a virtual function\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\ttype = eeprom->magic >> 16;\n\n\tif (type == 0xffff) {  \n\t\tindex = eeprom->magic & 0xff;\n\t\tdir_op = eeprom->magic >> 8;\n\t\tif (index == 0)\n\t\t\treturn -EINVAL;\n\t\tswitch (dir_op) {\n\t\tcase 0x0e:  \n\t\t\tif (eeprom->offset != ~eeprom->magic)\n\t\t\t\treturn -EINVAL;\n\t\t\treturn bnxt_erase_nvram_directory(dev, index - 1);\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t \n\tif (bnxt_dir_type_is_executable(type))\n\t\treturn -EOPNOTSUPP;\n\text = eeprom->magic & 0xffff;\n\tordinal = eeprom->offset >> 16;\n\tattr = eeprom->offset & 0xffff;\n\n\treturn bnxt_flash_nvram(dev, type, ordinal, ext, attr, 0, data,\n\t\t\t\teeprom->len);\n}\n\nstatic int bnxt_set_eee(struct net_device *dev, struct ethtool_eee *edata)\n{\n\tstruct bnxt *bp = netdev_priv(dev);\n\tstruct ethtool_eee *eee = &bp->eee;\n\tstruct bnxt_link_info *link_info = &bp->link_info;\n\tu32 advertising;\n\tint rc = 0;\n\n\tif (!BNXT_PHY_CFG_ABLE(bp))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!(bp->phy_flags & BNXT_PHY_FL_EEE_CAP))\n\t\treturn -EOPNOTSUPP;\n\n\tmutex_lock(&bp->link_lock);\n\tadvertising = _bnxt_fw_to_ethtool_adv_spds(link_info->advertising, 0);\n\tif (!edata->eee_enabled)\n\t\tgoto eee_ok;\n\n\tif (!(link_info->autoneg & BNXT_AUTONEG_SPEED)) {\n\t\tnetdev_warn(dev, \"EEE requires autoneg\\n\");\n\t\trc = -EINVAL;\n\t\tgoto eee_exit;\n\t}\n\tif (edata->tx_lpi_enabled) {\n\t\tif (bp->lpi_tmr_hi && (edata->tx_lpi_timer > bp->lpi_tmr_hi ||\n\t\t\t\t       edata->tx_lpi_timer < bp->lpi_tmr_lo)) {\n\t\t\tnetdev_warn(dev, \"Valid LPI timer range is %d and %d microsecs\\n\",\n\t\t\t\t    bp->lpi_tmr_lo, bp->lpi_tmr_hi);\n\t\t\trc = -EINVAL;\n\t\t\tgoto eee_exit;\n\t\t} else if (!bp->lpi_tmr_hi) {\n\t\t\tedata->tx_lpi_timer = eee->tx_lpi_timer;\n\t\t}\n\t}\n\tif (!edata->advertised) {\n\t\tedata->advertised = advertising & eee->supported;\n\t} else if (edata->advertised & ~advertising) {\n\t\tnetdev_warn(dev, \"EEE advertised %x must be a subset of autoneg advertised speeds %x\\n\",\n\t\t\t    edata->advertised, advertising);\n\t\trc = -EINVAL;\n\t\tgoto eee_exit;\n\t}\n\n\teee->advertised = edata->advertised;\n\teee->tx_lpi_enabled = edata->tx_lpi_enabled;\n\teee->tx_lpi_timer = edata->tx_lpi_timer;\neee_ok:\n\teee->eee_enabled = edata->eee_enabled;\n\n\tif (netif_running(dev))\n\t\trc = bnxt_hwrm_set_link_setting(bp, false, true);\n\neee_exit:\n\tmutex_unlock(&bp->link_lock);\n\treturn rc;\n}\n\nstatic int bnxt_get_eee(struct net_device *dev, struct ethtool_eee *edata)\n{\n\tstruct bnxt *bp = netdev_priv(dev);\n\n\tif (!(bp->phy_flags & BNXT_PHY_FL_EEE_CAP))\n\t\treturn -EOPNOTSUPP;\n\n\t*edata = bp->eee;\n\tif (!bp->eee.eee_enabled) {\n\t\t \n\t\tedata->advertised = 0;\n\t\tedata->tx_lpi_enabled = 0;\n\t}\n\n\tif (!bp->eee.eee_active)\n\t\tedata->lp_advertised = 0;\n\n\treturn 0;\n}\n\nstatic int bnxt_read_sfp_module_eeprom_info(struct bnxt *bp, u16 i2c_addr,\n\t\t\t\t\t    u16 page_number, u8 bank,\n\t\t\t\t\t    u16 start_addr, u16 data_length,\n\t\t\t\t\t    u8 *buf)\n{\n\tstruct hwrm_port_phy_i2c_read_output *output;\n\tstruct hwrm_port_phy_i2c_read_input *req;\n\tint rc, byte_offset = 0;\n\n\trc = hwrm_req_init(bp, req, HWRM_PORT_PHY_I2C_READ);\n\tif (rc)\n\t\treturn rc;\n\n\toutput = hwrm_req_hold(bp, req);\n\treq->i2c_slave_addr = i2c_addr;\n\treq->page_number = cpu_to_le16(page_number);\n\treq->port_id = cpu_to_le16(bp->pf.port_id);\n\tdo {\n\t\tu16 xfer_size;\n\n\t\txfer_size = min_t(u16, data_length, BNXT_MAX_PHY_I2C_RESP_SIZE);\n\t\tdata_length -= xfer_size;\n\t\treq->page_offset = cpu_to_le16(start_addr + byte_offset);\n\t\treq->data_length = xfer_size;\n\t\treq->enables =\n\t\t\tcpu_to_le32((start_addr + byte_offset ?\n\t\t\t\t     PORT_PHY_I2C_READ_REQ_ENABLES_PAGE_OFFSET :\n\t\t\t\t     0) |\n\t\t\t\t    (bank ?\n\t\t\t\t     PORT_PHY_I2C_READ_REQ_ENABLES_BANK_NUMBER :\n\t\t\t\t     0));\n\t\trc = hwrm_req_send(bp, req);\n\t\tif (!rc)\n\t\t\tmemcpy(buf + byte_offset, output->data, xfer_size);\n\t\tbyte_offset += xfer_size;\n\t} while (!rc && data_length > 0);\n\thwrm_req_drop(bp, req);\n\n\treturn rc;\n}\n\nstatic int bnxt_get_module_info(struct net_device *dev,\n\t\t\t\tstruct ethtool_modinfo *modinfo)\n{\n\tu8 data[SFF_DIAG_SUPPORT_OFFSET + 1];\n\tstruct bnxt *bp = netdev_priv(dev);\n\tint rc;\n\n\t \n\tif (bp->link_info.module_status >\n\t\tPORT_PHY_QCFG_RESP_MODULE_STATUS_WARNINGMSG)\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tif (bp->hwrm_spec_code < 0x10202)\n\t\treturn -EOPNOTSUPP;\n\n\trc = bnxt_read_sfp_module_eeprom_info(bp, I2C_DEV_ADDR_A0, 0, 0, 0,\n\t\t\t\t\t      SFF_DIAG_SUPPORT_OFFSET + 1,\n\t\t\t\t\t      data);\n\tif (!rc) {\n\t\tu8 module_id = data[0];\n\t\tu8 diag_supported = data[SFF_DIAG_SUPPORT_OFFSET];\n\n\t\tswitch (module_id) {\n\t\tcase SFF_MODULE_ID_SFP:\n\t\t\tmodinfo->type = ETH_MODULE_SFF_8472;\n\t\t\tmodinfo->eeprom_len = ETH_MODULE_SFF_8472_LEN;\n\t\t\tif (!diag_supported)\n\t\t\t\tmodinfo->eeprom_len = ETH_MODULE_SFF_8436_LEN;\n\t\t\tbreak;\n\t\tcase SFF_MODULE_ID_QSFP:\n\t\tcase SFF_MODULE_ID_QSFP_PLUS:\n\t\t\tmodinfo->type = ETH_MODULE_SFF_8436;\n\t\t\tmodinfo->eeprom_len = ETH_MODULE_SFF_8436_LEN;\n\t\t\tbreak;\n\t\tcase SFF_MODULE_ID_QSFP28:\n\t\t\tmodinfo->type = ETH_MODULE_SFF_8636;\n\t\t\tmodinfo->eeprom_len = ETH_MODULE_SFF_8636_LEN;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\trc = -EOPNOTSUPP;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn rc;\n}\n\nstatic int bnxt_get_module_eeprom(struct net_device *dev,\n\t\t\t\t  struct ethtool_eeprom *eeprom,\n\t\t\t\t  u8 *data)\n{\n\tstruct bnxt *bp = netdev_priv(dev);\n\tu16  start = eeprom->offset, length = eeprom->len;\n\tint rc = 0;\n\n\tmemset(data, 0, eeprom->len);\n\n\t \n\tif (start < ETH_MODULE_SFF_8436_LEN) {\n\t\tif (start + eeprom->len > ETH_MODULE_SFF_8436_LEN)\n\t\t\tlength = ETH_MODULE_SFF_8436_LEN - start;\n\t\trc = bnxt_read_sfp_module_eeprom_info(bp, I2C_DEV_ADDR_A0, 0, 0,\n\t\t\t\t\t\t      start, length, data);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tstart += length;\n\t\tdata += length;\n\t\tlength = eeprom->len - length;\n\t}\n\n\t \n\tif (length) {\n\t\tstart -= ETH_MODULE_SFF_8436_LEN;\n\t\trc = bnxt_read_sfp_module_eeprom_info(bp, I2C_DEV_ADDR_A2, 0, 0,\n\t\t\t\t\t\t      start, length, data);\n\t}\n\treturn rc;\n}\n\nstatic int bnxt_get_module_status(struct bnxt *bp, struct netlink_ext_ack *extack)\n{\n\tif (bp->link_info.module_status <=\n\t    PORT_PHY_QCFG_RESP_MODULE_STATUS_WARNINGMSG)\n\t\treturn 0;\n\n\tswitch (bp->link_info.module_status) {\n\tcase PORT_PHY_QCFG_RESP_MODULE_STATUS_PWRDOWN:\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Transceiver module is powering down\");\n\t\tbreak;\n\tcase PORT_PHY_QCFG_RESP_MODULE_STATUS_NOTINSERTED:\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Transceiver module not inserted\");\n\t\tbreak;\n\tcase PORT_PHY_QCFG_RESP_MODULE_STATUS_CURRENTFAULT:\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Transceiver module disabled due to current fault\");\n\t\tbreak;\n\tdefault:\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Unknown error\");\n\t\tbreak;\n\t}\n\treturn -EINVAL;\n}\n\nstatic int bnxt_get_module_eeprom_by_page(struct net_device *dev,\n\t\t\t\t\t  const struct ethtool_module_eeprom *page_data,\n\t\t\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct bnxt *bp = netdev_priv(dev);\n\tint rc;\n\n\trc = bnxt_get_module_status(bp, extack);\n\tif (rc)\n\t\treturn rc;\n\n\tif (bp->hwrm_spec_code < 0x10202) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Firmware version too old\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (page_data->bank && !(bp->phy_flags & BNXT_PHY_FL_BANK_SEL)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Firmware not capable for bank selection\");\n\t\treturn -EINVAL;\n\t}\n\n\trc = bnxt_read_sfp_module_eeprom_info(bp, page_data->i2c_address << 1,\n\t\t\t\t\t      page_data->page, page_data->bank,\n\t\t\t\t\t      page_data->offset,\n\t\t\t\t\t      page_data->length,\n\t\t\t\t\t      page_data->data);\n\tif (rc) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Module`s eeprom read failed\");\n\t\treturn rc;\n\t}\n\treturn page_data->length;\n}\n\nstatic int bnxt_nway_reset(struct net_device *dev)\n{\n\tint rc = 0;\n\n\tstruct bnxt *bp = netdev_priv(dev);\n\tstruct bnxt_link_info *link_info = &bp->link_info;\n\n\tif (!BNXT_PHY_CFG_ABLE(bp))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!(link_info->autoneg & BNXT_AUTONEG_SPEED))\n\t\treturn -EINVAL;\n\n\tif (netif_running(dev))\n\t\trc = bnxt_hwrm_set_link_setting(bp, true, false);\n\n\treturn rc;\n}\n\nstatic int bnxt_set_phys_id(struct net_device *dev,\n\t\t\t    enum ethtool_phys_id_state state)\n{\n\tstruct hwrm_port_led_cfg_input *req;\n\tstruct bnxt *bp = netdev_priv(dev);\n\tstruct bnxt_pf_info *pf = &bp->pf;\n\tstruct bnxt_led_cfg *led_cfg;\n\tu8 led_state;\n\t__le16 duration;\n\tint rc, i;\n\n\tif (!bp->num_leds || BNXT_VF(bp))\n\t\treturn -EOPNOTSUPP;\n\n\tif (state == ETHTOOL_ID_ACTIVE) {\n\t\tled_state = PORT_LED_CFG_REQ_LED0_STATE_BLINKALT;\n\t\tduration = cpu_to_le16(500);\n\t} else if (state == ETHTOOL_ID_INACTIVE) {\n\t\tled_state = PORT_LED_CFG_REQ_LED1_STATE_DEFAULT;\n\t\tduration = cpu_to_le16(0);\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\trc = hwrm_req_init(bp, req, HWRM_PORT_LED_CFG);\n\tif (rc)\n\t\treturn rc;\n\n\treq->port_id = cpu_to_le16(pf->port_id);\n\treq->num_leds = bp->num_leds;\n\tled_cfg = (struct bnxt_led_cfg *)&req->led0_id;\n\tfor (i = 0; i < bp->num_leds; i++, led_cfg++) {\n\t\treq->enables |= BNXT_LED_DFLT_ENABLES(i);\n\t\tled_cfg->led_id = bp->leds[i].led_id;\n\t\tled_cfg->led_state = led_state;\n\t\tled_cfg->led_blink_on = duration;\n\t\tled_cfg->led_blink_off = duration;\n\t\tled_cfg->led_group_id = bp->leds[i].led_group_id;\n\t}\n\treturn hwrm_req_send(bp, req);\n}\n\nstatic int bnxt_hwrm_selftest_irq(struct bnxt *bp, u16 cmpl_ring)\n{\n\tstruct hwrm_selftest_irq_input *req;\n\tint rc;\n\n\trc = hwrm_req_init(bp, req, HWRM_SELFTEST_IRQ);\n\tif (rc)\n\t\treturn rc;\n\n\treq->cmpl_ring = cpu_to_le16(cmpl_ring);\n\treturn hwrm_req_send(bp, req);\n}\n\nstatic int bnxt_test_irq(struct bnxt *bp)\n{\n\tint i;\n\n\tfor (i = 0; i < bp->cp_nr_rings; i++) {\n\t\tu16 cmpl_ring = bp->grp_info[i].cp_fw_ring_id;\n\t\tint rc;\n\n\t\trc = bnxt_hwrm_selftest_irq(bp, cmpl_ring);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\treturn 0;\n}\n\nstatic int bnxt_hwrm_mac_loopback(struct bnxt *bp, bool enable)\n{\n\tstruct hwrm_port_mac_cfg_input *req;\n\tint rc;\n\n\trc = hwrm_req_init(bp, req, HWRM_PORT_MAC_CFG);\n\tif (rc)\n\t\treturn rc;\n\n\treq->enables = cpu_to_le32(PORT_MAC_CFG_REQ_ENABLES_LPBK);\n\tif (enable)\n\t\treq->lpbk = PORT_MAC_CFG_REQ_LPBK_LOCAL;\n\telse\n\t\treq->lpbk = PORT_MAC_CFG_REQ_LPBK_NONE;\n\treturn hwrm_req_send(bp, req);\n}\n\nstatic int bnxt_query_force_speeds(struct bnxt *bp, u16 *force_speeds)\n{\n\tstruct hwrm_port_phy_qcaps_output *resp;\n\tstruct hwrm_port_phy_qcaps_input *req;\n\tint rc;\n\n\trc = hwrm_req_init(bp, req, HWRM_PORT_PHY_QCAPS);\n\tif (rc)\n\t\treturn rc;\n\n\tresp = hwrm_req_hold(bp, req);\n\trc = hwrm_req_send(bp, req);\n\tif (!rc)\n\t\t*force_speeds = le16_to_cpu(resp->supported_speeds_force_mode);\n\n\thwrm_req_drop(bp, req);\n\treturn rc;\n}\n\nstatic int bnxt_disable_an_for_lpbk(struct bnxt *bp,\n\t\t\t\t    struct hwrm_port_phy_cfg_input *req)\n{\n\tstruct bnxt_link_info *link_info = &bp->link_info;\n\tu16 fw_advertising;\n\tu16 fw_speed;\n\tint rc;\n\n\tif (!link_info->autoneg ||\n\t    (bp->phy_flags & BNXT_PHY_FL_AN_PHY_LPBK))\n\t\treturn 0;\n\n\trc = bnxt_query_force_speeds(bp, &fw_advertising);\n\tif (rc)\n\t\treturn rc;\n\n\tfw_speed = PORT_PHY_CFG_REQ_FORCE_LINK_SPEED_1GB;\n\tif (BNXT_LINK_IS_UP(bp))\n\t\tfw_speed = bp->link_info.link_speed;\n\telse if (fw_advertising & BNXT_LINK_SPEED_MSK_10GB)\n\t\tfw_speed = PORT_PHY_CFG_REQ_FORCE_LINK_SPEED_10GB;\n\telse if (fw_advertising & BNXT_LINK_SPEED_MSK_25GB)\n\t\tfw_speed = PORT_PHY_CFG_REQ_FORCE_LINK_SPEED_25GB;\n\telse if (fw_advertising & BNXT_LINK_SPEED_MSK_40GB)\n\t\tfw_speed = PORT_PHY_CFG_REQ_FORCE_LINK_SPEED_40GB;\n\telse if (fw_advertising & BNXT_LINK_SPEED_MSK_50GB)\n\t\tfw_speed = PORT_PHY_CFG_REQ_FORCE_LINK_SPEED_50GB;\n\n\treq->force_link_speed = cpu_to_le16(fw_speed);\n\treq->flags |= cpu_to_le32(PORT_PHY_CFG_REQ_FLAGS_FORCE |\n\t\t\t\t  PORT_PHY_CFG_REQ_FLAGS_RESET_PHY);\n\trc = hwrm_req_send(bp, req);\n\treq->flags = 0;\n\treq->force_link_speed = cpu_to_le16(0);\n\treturn rc;\n}\n\nstatic int bnxt_hwrm_phy_loopback(struct bnxt *bp, bool enable, bool ext)\n{\n\tstruct hwrm_port_phy_cfg_input *req;\n\tint rc;\n\n\trc = hwrm_req_init(bp, req, HWRM_PORT_PHY_CFG);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\thwrm_req_hold(bp, req);\n\n\tif (enable) {\n\t\tbnxt_disable_an_for_lpbk(bp, req);\n\t\tif (ext)\n\t\t\treq->lpbk = PORT_PHY_CFG_REQ_LPBK_EXTERNAL;\n\t\telse\n\t\t\treq->lpbk = PORT_PHY_CFG_REQ_LPBK_LOCAL;\n\t} else {\n\t\treq->lpbk = PORT_PHY_CFG_REQ_LPBK_NONE;\n\t}\n\treq->enables = cpu_to_le32(PORT_PHY_CFG_REQ_ENABLES_LPBK);\n\trc = hwrm_req_send(bp, req);\n\thwrm_req_drop(bp, req);\n\treturn rc;\n}\n\nstatic int bnxt_rx_loopback(struct bnxt *bp, struct bnxt_cp_ring_info *cpr,\n\t\t\t    u32 raw_cons, int pkt_size)\n{\n\tstruct bnxt_napi *bnapi = cpr->bnapi;\n\tstruct bnxt_rx_ring_info *rxr;\n\tstruct bnxt_sw_rx_bd *rx_buf;\n\tstruct rx_cmp *rxcmp;\n\tu16 cp_cons, cons;\n\tu8 *data;\n\tu32 len;\n\tint i;\n\n\trxr = bnapi->rx_ring;\n\tcp_cons = RING_CMP(raw_cons);\n\trxcmp = (struct rx_cmp *)\n\t\t&cpr->cp_desc_ring[CP_RING(cp_cons)][CP_IDX(cp_cons)];\n\tcons = rxcmp->rx_cmp_opaque;\n\trx_buf = &rxr->rx_buf_ring[cons];\n\tdata = rx_buf->data_ptr;\n\tlen = le32_to_cpu(rxcmp->rx_cmp_len_flags_type) >> RX_CMP_LEN_SHIFT;\n\tif (len != pkt_size)\n\t\treturn -EIO;\n\ti = ETH_ALEN;\n\tif (!ether_addr_equal(data + i, bnapi->bp->dev->dev_addr))\n\t\treturn -EIO;\n\ti += ETH_ALEN;\n\tfor (  ; i < pkt_size; i++) {\n\t\tif (data[i] != (u8)(i & 0xff))\n\t\t\treturn -EIO;\n\t}\n\treturn 0;\n}\n\nstatic int bnxt_poll_loopback(struct bnxt *bp, struct bnxt_cp_ring_info *cpr,\n\t\t\t      int pkt_size)\n{\n\tstruct tx_cmp *txcmp;\n\tint rc = -EIO;\n\tu32 raw_cons;\n\tu32 cons;\n\tint i;\n\n\traw_cons = cpr->cp_raw_cons;\n\tfor (i = 0; i < 200; i++) {\n\t\tcons = RING_CMP(raw_cons);\n\t\ttxcmp = &cpr->cp_desc_ring[CP_RING(cons)][CP_IDX(cons)];\n\n\t\tif (!TX_CMP_VALID(txcmp, raw_cons)) {\n\t\t\tudelay(5);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tdma_rmb();\n\t\tif (TX_CMP_TYPE(txcmp) == CMP_TYPE_RX_L2_CMP) {\n\t\t\trc = bnxt_rx_loopback(bp, cpr, raw_cons, pkt_size);\n\t\t\traw_cons = NEXT_RAW_CMP(raw_cons);\n\t\t\traw_cons = NEXT_RAW_CMP(raw_cons);\n\t\t\tbreak;\n\t\t}\n\t\traw_cons = NEXT_RAW_CMP(raw_cons);\n\t}\n\tcpr->cp_raw_cons = raw_cons;\n\treturn rc;\n}\n\nstatic int bnxt_run_loopback(struct bnxt *bp)\n{\n\tstruct bnxt_tx_ring_info *txr = &bp->tx_ring[0];\n\tstruct bnxt_rx_ring_info *rxr = &bp->rx_ring[0];\n\tstruct bnxt_cp_ring_info *cpr;\n\tint pkt_size, i = 0;\n\tstruct sk_buff *skb;\n\tdma_addr_t map;\n\tu8 *data;\n\tint rc;\n\n\tcpr = &rxr->bnapi->cp_ring;\n\tif (bp->flags & BNXT_FLAG_CHIP_P5)\n\t\tcpr = cpr->cp_ring_arr[BNXT_RX_HDL];\n\tpkt_size = min(bp->dev->mtu + ETH_HLEN, bp->rx_copy_thresh);\n\tskb = netdev_alloc_skb(bp->dev, pkt_size);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\tdata = skb_put(skb, pkt_size);\n\tether_addr_copy(&data[i], bp->dev->dev_addr);\n\ti += ETH_ALEN;\n\tether_addr_copy(&data[i], bp->dev->dev_addr);\n\ti += ETH_ALEN;\n\tfor ( ; i < pkt_size; i++)\n\t\tdata[i] = (u8)(i & 0xff);\n\n\tmap = dma_map_single(&bp->pdev->dev, skb->data, pkt_size,\n\t\t\t     DMA_TO_DEVICE);\n\tif (dma_mapping_error(&bp->pdev->dev, map)) {\n\t\tdev_kfree_skb(skb);\n\t\treturn -EIO;\n\t}\n\tbnxt_xmit_bd(bp, txr, map, pkt_size, NULL);\n\n\t \n\twmb();\n\n\tbnxt_db_write(bp, &txr->tx_db, txr->tx_prod);\n\trc = bnxt_poll_loopback(bp, cpr, pkt_size);\n\n\tdma_unmap_single(&bp->pdev->dev, map, pkt_size, DMA_TO_DEVICE);\n\tdev_kfree_skb(skb);\n\treturn rc;\n}\n\nstatic int bnxt_run_fw_tests(struct bnxt *bp, u8 test_mask, u8 *test_results)\n{\n\tstruct hwrm_selftest_exec_output *resp;\n\tstruct hwrm_selftest_exec_input *req;\n\tint rc;\n\n\trc = hwrm_req_init(bp, req, HWRM_SELFTEST_EXEC);\n\tif (rc)\n\t\treturn rc;\n\n\thwrm_req_timeout(bp, req, bp->test_info->timeout);\n\treq->flags = test_mask;\n\n\tresp = hwrm_req_hold(bp, req);\n\trc = hwrm_req_send(bp, req);\n\t*test_results = resp->test_success;\n\thwrm_req_drop(bp, req);\n\treturn rc;\n}\n\n#define BNXT_DRV_TESTS\t\t\t4\n#define BNXT_MACLPBK_TEST_IDX\t\t(bp->num_tests - BNXT_DRV_TESTS)\n#define BNXT_PHYLPBK_TEST_IDX\t\t(BNXT_MACLPBK_TEST_IDX + 1)\n#define BNXT_EXTLPBK_TEST_IDX\t\t(BNXT_MACLPBK_TEST_IDX + 2)\n#define BNXT_IRQ_TEST_IDX\t\t(BNXT_MACLPBK_TEST_IDX + 3)\n\nstatic void bnxt_self_test(struct net_device *dev, struct ethtool_test *etest,\n\t\t\t   u64 *buf)\n{\n\tstruct bnxt *bp = netdev_priv(dev);\n\tbool do_ext_lpbk = false;\n\tbool offline = false;\n\tu8 test_results = 0;\n\tu8 test_mask = 0;\n\tint rc = 0, i;\n\n\tif (!bp->num_tests || !BNXT_PF(bp))\n\t\treturn;\n\tmemset(buf, 0, sizeof(u64) * bp->num_tests);\n\tif (!netif_running(dev)) {\n\t\tetest->flags |= ETH_TEST_FL_FAILED;\n\t\treturn;\n\t}\n\n\tif ((etest->flags & ETH_TEST_FL_EXTERNAL_LB) &&\n\t    (bp->phy_flags & BNXT_PHY_FL_EXT_LPBK))\n\t\tdo_ext_lpbk = true;\n\n\tif (etest->flags & ETH_TEST_FL_OFFLINE) {\n\t\tif (bp->pf.active_vfs || !BNXT_SINGLE_PF(bp)) {\n\t\t\tetest->flags |= ETH_TEST_FL_FAILED;\n\t\t\tnetdev_warn(dev, \"Offline tests cannot be run with active VFs or on shared PF\\n\");\n\t\t\treturn;\n\t\t}\n\t\toffline = true;\n\t}\n\n\tfor (i = 0; i < bp->num_tests - BNXT_DRV_TESTS; i++) {\n\t\tu8 bit_val = 1 << i;\n\n\t\tif (!(bp->test_info->offline_mask & bit_val))\n\t\t\ttest_mask |= bit_val;\n\t\telse if (offline)\n\t\t\ttest_mask |= bit_val;\n\t}\n\tif (!offline) {\n\t\tbnxt_run_fw_tests(bp, test_mask, &test_results);\n\t} else {\n\t\tbnxt_ulp_stop(bp);\n\t\tbnxt_close_nic(bp, true, false);\n\t\tbnxt_run_fw_tests(bp, test_mask, &test_results);\n\n\t\tbuf[BNXT_MACLPBK_TEST_IDX] = 1;\n\t\tbnxt_hwrm_mac_loopback(bp, true);\n\t\tmsleep(250);\n\t\trc = bnxt_half_open_nic(bp);\n\t\tif (rc) {\n\t\t\tbnxt_hwrm_mac_loopback(bp, false);\n\t\t\tetest->flags |= ETH_TEST_FL_FAILED;\n\t\t\tbnxt_ulp_start(bp, rc);\n\t\t\treturn;\n\t\t}\n\t\tif (bnxt_run_loopback(bp))\n\t\t\tetest->flags |= ETH_TEST_FL_FAILED;\n\t\telse\n\t\t\tbuf[BNXT_MACLPBK_TEST_IDX] = 0;\n\n\t\tbnxt_hwrm_mac_loopback(bp, false);\n\t\tbnxt_hwrm_phy_loopback(bp, true, false);\n\t\tmsleep(1000);\n\t\tif (bnxt_run_loopback(bp)) {\n\t\t\tbuf[BNXT_PHYLPBK_TEST_IDX] = 1;\n\t\t\tetest->flags |= ETH_TEST_FL_FAILED;\n\t\t}\n\t\tif (do_ext_lpbk) {\n\t\t\tetest->flags |= ETH_TEST_FL_EXTERNAL_LB_DONE;\n\t\t\tbnxt_hwrm_phy_loopback(bp, true, true);\n\t\t\tmsleep(1000);\n\t\t\tif (bnxt_run_loopback(bp)) {\n\t\t\t\tbuf[BNXT_EXTLPBK_TEST_IDX] = 1;\n\t\t\t\tetest->flags |= ETH_TEST_FL_FAILED;\n\t\t\t}\n\t\t}\n\t\tbnxt_hwrm_phy_loopback(bp, false, false);\n\t\tbnxt_half_close_nic(bp);\n\t\trc = bnxt_open_nic(bp, true, true);\n\t\tbnxt_ulp_start(bp, rc);\n\t}\n\tif (rc || bnxt_test_irq(bp)) {\n\t\tbuf[BNXT_IRQ_TEST_IDX] = 1;\n\t\tetest->flags |= ETH_TEST_FL_FAILED;\n\t}\n\tfor (i = 0; i < bp->num_tests - BNXT_DRV_TESTS; i++) {\n\t\tu8 bit_val = 1 << i;\n\n\t\tif ((test_mask & bit_val) && !(test_results & bit_val)) {\n\t\t\tbuf[i] = 1;\n\t\t\tetest->flags |= ETH_TEST_FL_FAILED;\n\t\t}\n\t}\n}\n\nstatic int bnxt_reset(struct net_device *dev, u32 *flags)\n{\n\tstruct bnxt *bp = netdev_priv(dev);\n\tbool reload = false;\n\tu32 req = *flags;\n\n\tif (!req)\n\t\treturn -EINVAL;\n\n\tif (!BNXT_PF(bp)) {\n\t\tnetdev_err(dev, \"Reset is not supported from a VF\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (pci_vfs_assigned(bp->pdev) &&\n\t    !(bp->fw_cap & BNXT_FW_CAP_HOT_RESET)) {\n\t\tnetdev_err(dev,\n\t\t\t   \"Reset not allowed when VFs are assigned to VMs\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tif ((req & BNXT_FW_RESET_CHIP) == BNXT_FW_RESET_CHIP) {\n\t\t \n\t\tif (bp->hwrm_spec_code >= 0x10803) {\n\t\t\tif (!bnxt_firmware_reset_chip(dev)) {\n\t\t\t\tnetdev_info(dev, \"Firmware reset request successful.\\n\");\n\t\t\t\tif (!(bp->fw_cap & BNXT_FW_CAP_HOT_RESET))\n\t\t\t\t\treload = true;\n\t\t\t\t*flags &= ~BNXT_FW_RESET_CHIP;\n\t\t\t}\n\t\t} else if (req == BNXT_FW_RESET_CHIP) {\n\t\t\treturn -EOPNOTSUPP;  \n\t\t}\n\t}\n\n\tif (!BNXT_CHIP_P4_PLUS(bp) && (req & BNXT_FW_RESET_AP)) {\n\t\t \n\t\tif (bp->hwrm_spec_code >= 0x10803) {\n\t\t\tif (!bnxt_firmware_reset_ap(dev)) {\n\t\t\t\tnetdev_info(dev, \"Reset application processor successful.\\n\");\n\t\t\t\treload = true;\n\t\t\t\t*flags &= ~BNXT_FW_RESET_AP;\n\t\t\t}\n\t\t} else if (req == BNXT_FW_RESET_AP) {\n\t\t\treturn -EOPNOTSUPP;  \n\t\t}\n\t}\n\n\tif (reload)\n\t\tnetdev_info(dev, \"Reload driver to complete reset\\n\");\n\n\treturn 0;\n}\n\nstatic int bnxt_set_dump(struct net_device *dev, struct ethtool_dump *dump)\n{\n\tstruct bnxt *bp = netdev_priv(dev);\n\n\tif (dump->flag > BNXT_DUMP_CRASH) {\n\t\tnetdev_info(dev, \"Supports only Live(0) and Crash(1) dumps.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!IS_ENABLED(CONFIG_TEE_BNXT_FW) && dump->flag == BNXT_DUMP_CRASH) {\n\t\tnetdev_info(dev, \"Cannot collect crash dump as TEE_BNXT_FW config option is not enabled.\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tbp->dump_flag = dump->flag;\n\treturn 0;\n}\n\nstatic int bnxt_get_dump_flag(struct net_device *dev, struct ethtool_dump *dump)\n{\n\tstruct bnxt *bp = netdev_priv(dev);\n\n\tif (bp->hwrm_spec_code < 0x10801)\n\t\treturn -EOPNOTSUPP;\n\n\tdump->version = bp->ver_resp.hwrm_fw_maj_8b << 24 |\n\t\t\tbp->ver_resp.hwrm_fw_min_8b << 16 |\n\t\t\tbp->ver_resp.hwrm_fw_bld_8b << 8 |\n\t\t\tbp->ver_resp.hwrm_fw_rsvd_8b;\n\n\tdump->flag = bp->dump_flag;\n\tdump->len = bnxt_get_coredump_length(bp, bp->dump_flag);\n\treturn 0;\n}\n\nstatic int bnxt_get_dump_data(struct net_device *dev, struct ethtool_dump *dump,\n\t\t\t      void *buf)\n{\n\tstruct bnxt *bp = netdev_priv(dev);\n\n\tif (bp->hwrm_spec_code < 0x10801)\n\t\treturn -EOPNOTSUPP;\n\n\tmemset(buf, 0, dump->len);\n\n\tdump->flag = bp->dump_flag;\n\treturn bnxt_get_coredump(bp, dump->flag, buf, &dump->len);\n}\n\nstatic int bnxt_get_ts_info(struct net_device *dev,\n\t\t\t    struct ethtool_ts_info *info)\n{\n\tstruct bnxt *bp = netdev_priv(dev);\n\tstruct bnxt_ptp_cfg *ptp;\n\n\tptp = bp->ptp_cfg;\n\tinfo->so_timestamping = SOF_TIMESTAMPING_TX_SOFTWARE |\n\t\t\t\tSOF_TIMESTAMPING_RX_SOFTWARE |\n\t\t\t\tSOF_TIMESTAMPING_SOFTWARE;\n\n\tinfo->phc_index = -1;\n\tif (!ptp)\n\t\treturn 0;\n\n\tinfo->so_timestamping |= SOF_TIMESTAMPING_TX_HARDWARE |\n\t\t\t\t SOF_TIMESTAMPING_RX_HARDWARE |\n\t\t\t\t SOF_TIMESTAMPING_RAW_HARDWARE;\n\tif (ptp->ptp_clock)\n\t\tinfo->phc_index = ptp_clock_index(ptp->ptp_clock);\n\n\tinfo->tx_types = (1 << HWTSTAMP_TX_OFF) | (1 << HWTSTAMP_TX_ON);\n\n\tinfo->rx_filters = (1 << HWTSTAMP_FILTER_NONE) |\n\t\t\t   (1 << HWTSTAMP_FILTER_PTP_V2_L2_EVENT) |\n\t\t\t   (1 << HWTSTAMP_FILTER_PTP_V2_L4_EVENT);\n\n\tif (bp->fw_cap & BNXT_FW_CAP_RX_ALL_PKT_TS)\n\t\tinfo->rx_filters |= (1 << HWTSTAMP_FILTER_ALL);\n\treturn 0;\n}\n\nvoid bnxt_ethtool_init(struct bnxt *bp)\n{\n\tstruct hwrm_selftest_qlist_output *resp;\n\tstruct hwrm_selftest_qlist_input *req;\n\tstruct bnxt_test_info *test_info;\n\tstruct net_device *dev = bp->dev;\n\tint i, rc;\n\n\tif (!(bp->fw_cap & BNXT_FW_CAP_PKG_VER))\n\t\tbnxt_get_pkgver(dev);\n\n\tbp->num_tests = 0;\n\tif (bp->hwrm_spec_code < 0x10704 || !BNXT_PF(bp))\n\t\treturn;\n\n\ttest_info = bp->test_info;\n\tif (!test_info) {\n\t\ttest_info = kzalloc(sizeof(*bp->test_info), GFP_KERNEL);\n\t\tif (!test_info)\n\t\t\treturn;\n\t\tbp->test_info = test_info;\n\t}\n\n\tif (hwrm_req_init(bp, req, HWRM_SELFTEST_QLIST))\n\t\treturn;\n\n\tresp = hwrm_req_hold(bp, req);\n\trc = hwrm_req_send_silent(bp, req);\n\tif (rc)\n\t\tgoto ethtool_init_exit;\n\n\tbp->num_tests = resp->num_tests + BNXT_DRV_TESTS;\n\tif (bp->num_tests > BNXT_MAX_TEST)\n\t\tbp->num_tests = BNXT_MAX_TEST;\n\n\ttest_info->offline_mask = resp->offline_tests;\n\ttest_info->timeout = le16_to_cpu(resp->test_timeout);\n\tif (!test_info->timeout)\n\t\ttest_info->timeout = HWRM_CMD_TIMEOUT;\n\tfor (i = 0; i < bp->num_tests; i++) {\n\t\tchar *str = test_info->string[i];\n\t\tchar *fw_str = resp->test_name[i];\n\n\t\tif (i == BNXT_MACLPBK_TEST_IDX) {\n\t\t\tstrcpy(str, \"Mac loopback test (offline)\");\n\t\t} else if (i == BNXT_PHYLPBK_TEST_IDX) {\n\t\t\tstrcpy(str, \"Phy loopback test (offline)\");\n\t\t} else if (i == BNXT_EXTLPBK_TEST_IDX) {\n\t\t\tstrcpy(str, \"Ext loopback test (offline)\");\n\t\t} else if (i == BNXT_IRQ_TEST_IDX) {\n\t\t\tstrcpy(str, \"Interrupt_test (offline)\");\n\t\t} else {\n\t\t\tsnprintf(str, ETH_GSTRING_LEN, \"%s test (%s)\",\n\t\t\t\t fw_str, test_info->offline_mask & (1 << i) ?\n\t\t\t\t\t\"offline\" : \"online\");\n\t\t}\n\t}\n\nethtool_init_exit:\n\thwrm_req_drop(bp, req);\n}\n\nstatic void bnxt_get_eth_phy_stats(struct net_device *dev,\n\t\t\t\t   struct ethtool_eth_phy_stats *phy_stats)\n{\n\tstruct bnxt *bp = netdev_priv(dev);\n\tu64 *rx;\n\n\tif (BNXT_VF(bp) || !(bp->flags & BNXT_FLAG_PORT_STATS_EXT))\n\t\treturn;\n\n\trx = bp->rx_port_stats_ext.sw_stats;\n\tphy_stats->SymbolErrorDuringCarrier =\n\t\t*(rx + BNXT_RX_STATS_EXT_OFFSET(rx_pcs_symbol_err));\n}\n\nstatic void bnxt_get_eth_mac_stats(struct net_device *dev,\n\t\t\t\t   struct ethtool_eth_mac_stats *mac_stats)\n{\n\tstruct bnxt *bp = netdev_priv(dev);\n\tu64 *rx, *tx;\n\n\tif (BNXT_VF(bp) || !(bp->flags & BNXT_FLAG_PORT_STATS))\n\t\treturn;\n\n\trx = bp->port_stats.sw_stats;\n\ttx = bp->port_stats.sw_stats + BNXT_TX_PORT_STATS_BYTE_OFFSET / 8;\n\n\tmac_stats->FramesReceivedOK =\n\t\tBNXT_GET_RX_PORT_STATS64(rx, rx_good_frames);\n\tmac_stats->FramesTransmittedOK =\n\t\tBNXT_GET_TX_PORT_STATS64(tx, tx_good_frames);\n\tmac_stats->FrameCheckSequenceErrors =\n\t\tBNXT_GET_RX_PORT_STATS64(rx, rx_fcs_err_frames);\n\tmac_stats->AlignmentErrors =\n\t\tBNXT_GET_RX_PORT_STATS64(rx, rx_align_err_frames);\n\tmac_stats->OutOfRangeLengthField =\n\t\tBNXT_GET_RX_PORT_STATS64(rx, rx_oor_len_frames);\n}\n\nstatic void bnxt_get_eth_ctrl_stats(struct net_device *dev,\n\t\t\t\t    struct ethtool_eth_ctrl_stats *ctrl_stats)\n{\n\tstruct bnxt *bp = netdev_priv(dev);\n\tu64 *rx;\n\n\tif (BNXT_VF(bp) || !(bp->flags & BNXT_FLAG_PORT_STATS))\n\t\treturn;\n\n\trx = bp->port_stats.sw_stats;\n\tctrl_stats->MACControlFramesReceived =\n\t\tBNXT_GET_RX_PORT_STATS64(rx, rx_ctrl_frames);\n}\n\nstatic const struct ethtool_rmon_hist_range bnxt_rmon_ranges[] = {\n\t{    0,    64 },\n\t{   65,   127 },\n\t{  128,   255 },\n\t{  256,   511 },\n\t{  512,  1023 },\n\t{ 1024,  1518 },\n\t{ 1519,  2047 },\n\t{ 2048,  4095 },\n\t{ 4096,  9216 },\n\t{ 9217, 16383 },\n\t{}\n};\n\nstatic void bnxt_get_rmon_stats(struct net_device *dev,\n\t\t\t\tstruct ethtool_rmon_stats *rmon_stats,\n\t\t\t\tconst struct ethtool_rmon_hist_range **ranges)\n{\n\tstruct bnxt *bp = netdev_priv(dev);\n\tu64 *rx, *tx;\n\n\tif (BNXT_VF(bp) || !(bp->flags & BNXT_FLAG_PORT_STATS))\n\t\treturn;\n\n\trx = bp->port_stats.sw_stats;\n\ttx = bp->port_stats.sw_stats + BNXT_TX_PORT_STATS_BYTE_OFFSET / 8;\n\n\trmon_stats->jabbers =\n\t\tBNXT_GET_RX_PORT_STATS64(rx, rx_jbr_frames);\n\trmon_stats->oversize_pkts =\n\t\tBNXT_GET_RX_PORT_STATS64(rx, rx_ovrsz_frames);\n\trmon_stats->undersize_pkts =\n\t\tBNXT_GET_RX_PORT_STATS64(rx, rx_undrsz_frames);\n\n\trmon_stats->hist[0] = BNXT_GET_RX_PORT_STATS64(rx, rx_64b_frames);\n\trmon_stats->hist[1] = BNXT_GET_RX_PORT_STATS64(rx, rx_65b_127b_frames);\n\trmon_stats->hist[2] = BNXT_GET_RX_PORT_STATS64(rx, rx_128b_255b_frames);\n\trmon_stats->hist[3] = BNXT_GET_RX_PORT_STATS64(rx, rx_256b_511b_frames);\n\trmon_stats->hist[4] =\n\t\tBNXT_GET_RX_PORT_STATS64(rx, rx_512b_1023b_frames);\n\trmon_stats->hist[5] =\n\t\tBNXT_GET_RX_PORT_STATS64(rx, rx_1024b_1518b_frames);\n\trmon_stats->hist[6] =\n\t\tBNXT_GET_RX_PORT_STATS64(rx, rx_1519b_2047b_frames);\n\trmon_stats->hist[7] =\n\t\tBNXT_GET_RX_PORT_STATS64(rx, rx_2048b_4095b_frames);\n\trmon_stats->hist[8] =\n\t\tBNXT_GET_RX_PORT_STATS64(rx, rx_4096b_9216b_frames);\n\trmon_stats->hist[9] =\n\t\tBNXT_GET_RX_PORT_STATS64(rx, rx_9217b_16383b_frames);\n\n\trmon_stats->hist_tx[0] =\n\t\tBNXT_GET_TX_PORT_STATS64(tx, tx_64b_frames);\n\trmon_stats->hist_tx[1] =\n\t\tBNXT_GET_TX_PORT_STATS64(tx, tx_65b_127b_frames);\n\trmon_stats->hist_tx[2] =\n\t\tBNXT_GET_TX_PORT_STATS64(tx, tx_128b_255b_frames);\n\trmon_stats->hist_tx[3] =\n\t\tBNXT_GET_TX_PORT_STATS64(tx, tx_256b_511b_frames);\n\trmon_stats->hist_tx[4] =\n\t\tBNXT_GET_TX_PORT_STATS64(tx, tx_512b_1023b_frames);\n\trmon_stats->hist_tx[5] =\n\t\tBNXT_GET_TX_PORT_STATS64(tx, tx_1024b_1518b_frames);\n\trmon_stats->hist_tx[6] =\n\t\tBNXT_GET_TX_PORT_STATS64(tx, tx_1519b_2047b_frames);\n\trmon_stats->hist_tx[7] =\n\t\tBNXT_GET_TX_PORT_STATS64(tx, tx_2048b_4095b_frames);\n\trmon_stats->hist_tx[8] =\n\t\tBNXT_GET_TX_PORT_STATS64(tx, tx_4096b_9216b_frames);\n\trmon_stats->hist_tx[9] =\n\t\tBNXT_GET_TX_PORT_STATS64(tx, tx_9217b_16383b_frames);\n\n\t*ranges = bnxt_rmon_ranges;\n}\n\nstatic void bnxt_get_link_ext_stats(struct net_device *dev,\n\t\t\t\t    struct ethtool_link_ext_stats *stats)\n{\n\tstruct bnxt *bp = netdev_priv(dev);\n\tu64 *rx;\n\n\tif (BNXT_VF(bp) || !(bp->flags & BNXT_FLAG_PORT_STATS_EXT))\n\t\treturn;\n\n\trx = bp->rx_port_stats_ext.sw_stats;\n\tstats->link_down_events =\n\t\t*(rx + BNXT_RX_STATS_EXT_OFFSET(link_down_events));\n}\n\nvoid bnxt_ethtool_free(struct bnxt *bp)\n{\n\tkfree(bp->test_info);\n\tbp->test_info = NULL;\n}\n\nconst struct ethtool_ops bnxt_ethtool_ops = {\n\t.supported_coalesce_params = ETHTOOL_COALESCE_USECS |\n\t\t\t\t     ETHTOOL_COALESCE_MAX_FRAMES |\n\t\t\t\t     ETHTOOL_COALESCE_USECS_IRQ |\n\t\t\t\t     ETHTOOL_COALESCE_MAX_FRAMES_IRQ |\n\t\t\t\t     ETHTOOL_COALESCE_STATS_BLOCK_USECS |\n\t\t\t\t     ETHTOOL_COALESCE_USE_ADAPTIVE_RX |\n\t\t\t\t     ETHTOOL_COALESCE_USE_CQE,\n\t.get_link_ksettings\t= bnxt_get_link_ksettings,\n\t.set_link_ksettings\t= bnxt_set_link_ksettings,\n\t.get_fec_stats\t\t= bnxt_get_fec_stats,\n\t.get_fecparam\t\t= bnxt_get_fecparam,\n\t.set_fecparam\t\t= bnxt_set_fecparam,\n\t.get_pause_stats\t= bnxt_get_pause_stats,\n\t.get_pauseparam\t\t= bnxt_get_pauseparam,\n\t.set_pauseparam\t\t= bnxt_set_pauseparam,\n\t.get_drvinfo\t\t= bnxt_get_drvinfo,\n\t.get_regs_len\t\t= bnxt_get_regs_len,\n\t.get_regs\t\t= bnxt_get_regs,\n\t.get_wol\t\t= bnxt_get_wol,\n\t.set_wol\t\t= bnxt_set_wol,\n\t.get_coalesce\t\t= bnxt_get_coalesce,\n\t.set_coalesce\t\t= bnxt_set_coalesce,\n\t.get_msglevel\t\t= bnxt_get_msglevel,\n\t.set_msglevel\t\t= bnxt_set_msglevel,\n\t.get_sset_count\t\t= bnxt_get_sset_count,\n\t.get_strings\t\t= bnxt_get_strings,\n\t.get_ethtool_stats\t= bnxt_get_ethtool_stats,\n\t.set_ringparam\t\t= bnxt_set_ringparam,\n\t.get_ringparam\t\t= bnxt_get_ringparam,\n\t.get_channels\t\t= bnxt_get_channels,\n\t.set_channels\t\t= bnxt_set_channels,\n\t.get_rxnfc\t\t= bnxt_get_rxnfc,\n\t.set_rxnfc\t\t= bnxt_set_rxnfc,\n\t.get_rxfh_indir_size    = bnxt_get_rxfh_indir_size,\n\t.get_rxfh_key_size      = bnxt_get_rxfh_key_size,\n\t.get_rxfh               = bnxt_get_rxfh,\n\t.set_rxfh\t\t= bnxt_set_rxfh,\n\t.flash_device\t\t= bnxt_flash_device,\n\t.get_eeprom_len         = bnxt_get_eeprom_len,\n\t.get_eeprom             = bnxt_get_eeprom,\n\t.set_eeprom\t\t= bnxt_set_eeprom,\n\t.get_link\t\t= bnxt_get_link,\n\t.get_link_ext_stats\t= bnxt_get_link_ext_stats,\n\t.get_eee\t\t= bnxt_get_eee,\n\t.set_eee\t\t= bnxt_set_eee,\n\t.get_module_info\t= bnxt_get_module_info,\n\t.get_module_eeprom\t= bnxt_get_module_eeprom,\n\t.get_module_eeprom_by_page = bnxt_get_module_eeprom_by_page,\n\t.nway_reset\t\t= bnxt_nway_reset,\n\t.set_phys_id\t\t= bnxt_set_phys_id,\n\t.self_test\t\t= bnxt_self_test,\n\t.get_ts_info\t\t= bnxt_get_ts_info,\n\t.reset\t\t\t= bnxt_reset,\n\t.set_dump\t\t= bnxt_set_dump,\n\t.get_dump_flag\t\t= bnxt_get_dump_flag,\n\t.get_dump_data\t\t= bnxt_get_dump_data,\n\t.get_eth_phy_stats\t= bnxt_get_eth_phy_stats,\n\t.get_eth_mac_stats\t= bnxt_get_eth_mac_stats,\n\t.get_eth_ctrl_stats\t= bnxt_get_eth_ctrl_stats,\n\t.get_rmon_stats\t\t= bnxt_get_rmon_stats,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}