{
  "module_name": "bnxt_ptp.c",
  "hash_id": "910adb245d004711b8154fbca3b51304fd3246b0c4bbe5a2e4fc5681db76f173",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/broadcom/bnxt/bnxt_ptp.c",
  "human_readable_source": " \n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/pci.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/net_tstamp.h>\n#include <linux/timekeeping.h>\n#include <linux/ptp_classify.h>\n#include <linux/clocksource.h>\n#include \"bnxt_hsi.h\"\n#include \"bnxt.h\"\n#include \"bnxt_hwrm.h\"\n#include \"bnxt_ptp.h\"\n\nstatic int bnxt_ptp_cfg_settime(struct bnxt *bp, u64 time)\n{\n\tstruct hwrm_func_ptp_cfg_input *req;\n\tint rc;\n\n\trc = hwrm_req_init(bp, req, HWRM_FUNC_PTP_CFG);\n\tif (rc)\n\t\treturn rc;\n\n\treq->enables = cpu_to_le16(FUNC_PTP_CFG_REQ_ENABLES_PTP_SET_TIME);\n\treq->ptp_set_time = cpu_to_le64(time);\n\treturn hwrm_req_send(bp, req);\n}\n\nint bnxt_ptp_parse(struct sk_buff *skb, u16 *seq_id, u16 *hdr_off)\n{\n\tunsigned int ptp_class;\n\tstruct ptp_header *hdr;\n\n\tptp_class = ptp_classify_raw(skb);\n\n\tswitch (ptp_class & PTP_CLASS_VMASK) {\n\tcase PTP_CLASS_V1:\n\tcase PTP_CLASS_V2:\n\t\thdr = ptp_parse_header(skb, ptp_class);\n\t\tif (!hdr)\n\t\t\treturn -EINVAL;\n\n\t\t*hdr_off = (u8 *)hdr - skb->data;\n\t\t*seq_id\t = ntohs(hdr->sequence_id);\n\t\treturn 0;\n\tdefault:\n\t\treturn -ERANGE;\n\t}\n}\n\nstatic int bnxt_ptp_settime(struct ptp_clock_info *ptp_info,\n\t\t\t    const struct timespec64 *ts)\n{\n\tstruct bnxt_ptp_cfg *ptp = container_of(ptp_info, struct bnxt_ptp_cfg,\n\t\t\t\t\t\tptp_info);\n\tu64 ns = timespec64_to_ns(ts);\n\n\tif (BNXT_PTP_USE_RTC(ptp->bp))\n\t\treturn bnxt_ptp_cfg_settime(ptp->bp, ns);\n\n\tspin_lock_bh(&ptp->ptp_lock);\n\ttimecounter_init(&ptp->tc, &ptp->cc, ns);\n\tspin_unlock_bh(&ptp->ptp_lock);\n\treturn 0;\n}\n\n \nstatic int bnxt_refclk_read(struct bnxt *bp, struct ptp_system_timestamp *sts,\n\t\t\t    u64 *ns)\n{\n\tstruct bnxt_ptp_cfg *ptp = bp->ptp_cfg;\n\tu32 high_before, high_now, low;\n\n\tif (test_bit(BNXT_STATE_IN_FW_RESET, &bp->state))\n\t\treturn -EIO;\n\n\thigh_before = readl(bp->bar0 + ptp->refclk_mapped_regs[1]);\n\tptp_read_system_prets(sts);\n\tlow = readl(bp->bar0 + ptp->refclk_mapped_regs[0]);\n\tptp_read_system_postts(sts);\n\thigh_now = readl(bp->bar0 + ptp->refclk_mapped_regs[1]);\n\tif (high_now != high_before) {\n\t\tptp_read_system_prets(sts);\n\t\tlow = readl(bp->bar0 + ptp->refclk_mapped_regs[0]);\n\t\tptp_read_system_postts(sts);\n\t}\n\t*ns = ((u64)high_now << 32) | low;\n\n\treturn 0;\n}\n\nstatic void bnxt_ptp_get_current_time(struct bnxt *bp)\n{\n\tstruct bnxt_ptp_cfg *ptp = bp->ptp_cfg;\n\n\tif (!ptp)\n\t\treturn;\n\tspin_lock_bh(&ptp->ptp_lock);\n\tWRITE_ONCE(ptp->old_time, ptp->current_time);\n\tbnxt_refclk_read(bp, NULL, &ptp->current_time);\n\tspin_unlock_bh(&ptp->ptp_lock);\n}\n\nstatic int bnxt_hwrm_port_ts_query(struct bnxt *bp, u32 flags, u64 *ts)\n{\n\tstruct hwrm_port_ts_query_output *resp;\n\tstruct hwrm_port_ts_query_input *req;\n\tint rc;\n\n\trc = hwrm_req_init(bp, req, HWRM_PORT_TS_QUERY);\n\tif (rc)\n\t\treturn rc;\n\n\treq->flags = cpu_to_le32(flags);\n\tif ((flags & PORT_TS_QUERY_REQ_FLAGS_PATH) ==\n\t    PORT_TS_QUERY_REQ_FLAGS_PATH_TX) {\n\t\treq->enables = cpu_to_le16(BNXT_PTP_QTS_TX_ENABLES);\n\t\treq->ptp_seq_id = cpu_to_le32(bp->ptp_cfg->tx_seqid);\n\t\treq->ptp_hdr_offset = cpu_to_le16(bp->ptp_cfg->tx_hdr_off);\n\t\treq->ts_req_timeout = cpu_to_le16(BNXT_PTP_QTS_TIMEOUT);\n\t}\n\tresp = hwrm_req_hold(bp, req);\n\n\trc = hwrm_req_send(bp, req);\n\tif (!rc)\n\t\t*ts = le64_to_cpu(resp->ptp_msg_ts);\n\thwrm_req_drop(bp, req);\n\treturn rc;\n}\n\nstatic int bnxt_ptp_gettimex(struct ptp_clock_info *ptp_info,\n\t\t\t     struct timespec64 *ts,\n\t\t\t     struct ptp_system_timestamp *sts)\n{\n\tstruct bnxt_ptp_cfg *ptp = container_of(ptp_info, struct bnxt_ptp_cfg,\n\t\t\t\t\t\tptp_info);\n\tu64 ns, cycles;\n\tint rc;\n\n\tspin_lock_bh(&ptp->ptp_lock);\n\trc = bnxt_refclk_read(ptp->bp, sts, &cycles);\n\tif (rc) {\n\t\tspin_unlock_bh(&ptp->ptp_lock);\n\t\treturn rc;\n\t}\n\tns = timecounter_cyc2time(&ptp->tc, cycles);\n\tspin_unlock_bh(&ptp->ptp_lock);\n\t*ts = ns_to_timespec64(ns);\n\n\treturn 0;\n}\n\n \nvoid bnxt_ptp_update_current_time(struct bnxt *bp)\n{\n\tstruct bnxt_ptp_cfg *ptp = bp->ptp_cfg;\n\n\tbnxt_refclk_read(ptp->bp, NULL, &ptp->current_time);\n\tWRITE_ONCE(ptp->old_time, ptp->current_time);\n}\n\nstatic int bnxt_ptp_adjphc(struct bnxt_ptp_cfg *ptp, s64 delta)\n{\n\tstruct hwrm_port_mac_cfg_input *req;\n\tint rc;\n\n\trc = hwrm_req_init(ptp->bp, req, HWRM_PORT_MAC_CFG);\n\tif (rc)\n\t\treturn rc;\n\n\treq->enables = cpu_to_le32(PORT_MAC_CFG_REQ_ENABLES_PTP_ADJ_PHASE);\n\treq->ptp_adj_phase = cpu_to_le64(delta);\n\n\trc = hwrm_req_send(ptp->bp, req);\n\tif (rc) {\n\t\tnetdev_err(ptp->bp->dev, \"ptp adjphc failed. rc = %x\\n\", rc);\n\t} else {\n\t\tspin_lock_bh(&ptp->ptp_lock);\n\t\tbnxt_ptp_update_current_time(ptp->bp);\n\t\tspin_unlock_bh(&ptp->ptp_lock);\n\t}\n\n\treturn rc;\n}\n\nstatic int bnxt_ptp_adjtime(struct ptp_clock_info *ptp_info, s64 delta)\n{\n\tstruct bnxt_ptp_cfg *ptp = container_of(ptp_info, struct bnxt_ptp_cfg,\n\t\t\t\t\t\tptp_info);\n\n\tif (BNXT_PTP_USE_RTC(ptp->bp))\n\t\treturn bnxt_ptp_adjphc(ptp, delta);\n\n\tspin_lock_bh(&ptp->ptp_lock);\n\ttimecounter_adjtime(&ptp->tc, delta);\n\tspin_unlock_bh(&ptp->ptp_lock);\n\treturn 0;\n}\n\nstatic int bnxt_ptp_adjfine_rtc(struct bnxt *bp, long scaled_ppm)\n{\n\ts32 ppb = scaled_ppm_to_ppb(scaled_ppm);\n\tstruct hwrm_port_mac_cfg_input *req;\n\tint rc;\n\n\trc = hwrm_req_init(bp, req, HWRM_PORT_MAC_CFG);\n\tif (rc)\n\t\treturn rc;\n\n\treq->ptp_freq_adj_ppb = cpu_to_le32(ppb);\n\treq->enables = cpu_to_le32(PORT_MAC_CFG_REQ_ENABLES_PTP_FREQ_ADJ_PPB);\n\trc = hwrm_req_send(bp, req);\n\tif (rc)\n\t\tnetdev_err(bp->dev,\n\t\t\t   \"ptp adjfine failed. rc = %d\\n\", rc);\n\treturn rc;\n}\n\nstatic int bnxt_ptp_adjfine(struct ptp_clock_info *ptp_info, long scaled_ppm)\n{\n\tstruct bnxt_ptp_cfg *ptp = container_of(ptp_info, struct bnxt_ptp_cfg,\n\t\t\t\t\t\tptp_info);\n\tstruct bnxt *bp = ptp->bp;\n\n\tif (!BNXT_MH(bp))\n\t\treturn bnxt_ptp_adjfine_rtc(bp, scaled_ppm);\n\n\tspin_lock_bh(&ptp->ptp_lock);\n\ttimecounter_read(&ptp->tc);\n\tptp->cc.mult = adjust_by_scaled_ppm(ptp->cmult, scaled_ppm);\n\tspin_unlock_bh(&ptp->ptp_lock);\n\treturn 0;\n}\n\nvoid bnxt_ptp_pps_event(struct bnxt *bp, u32 data1, u32 data2)\n{\n\tstruct bnxt_ptp_cfg *ptp = bp->ptp_cfg;\n\tstruct ptp_clock_event event;\n\tu64 ns, pps_ts;\n\n\tpps_ts = EVENT_PPS_TS(data2, data1);\n\tspin_lock_bh(&ptp->ptp_lock);\n\tns = timecounter_cyc2time(&ptp->tc, pps_ts);\n\tspin_unlock_bh(&ptp->ptp_lock);\n\n\tswitch (EVENT_DATA2_PPS_EVENT_TYPE(data2)) {\n\tcase ASYNC_EVENT_CMPL_PPS_TIMESTAMP_EVENT_DATA2_EVENT_TYPE_INTERNAL:\n\t\tevent.pps_times.ts_real = ns_to_timespec64(ns);\n\t\tevent.type = PTP_CLOCK_PPSUSR;\n\t\tevent.index = EVENT_DATA2_PPS_PIN_NUM(data2);\n\t\tbreak;\n\tcase ASYNC_EVENT_CMPL_PPS_TIMESTAMP_EVENT_DATA2_EVENT_TYPE_EXTERNAL:\n\t\tevent.timestamp = ns;\n\t\tevent.type = PTP_CLOCK_EXTTS;\n\t\tevent.index = EVENT_DATA2_PPS_PIN_NUM(data2);\n\t\tbreak;\n\t}\n\n\tptp_clock_event(bp->ptp_cfg->ptp_clock, &event);\n}\n\nstatic int bnxt_ptp_cfg_pin(struct bnxt *bp, u8 pin, u8 usage)\n{\n\tstruct hwrm_func_ptp_pin_cfg_input *req;\n\tstruct bnxt_ptp_cfg *ptp = bp->ptp_cfg;\n\tu8 state = usage != BNXT_PPS_PIN_NONE;\n\tu8 *pin_state, *pin_usg;\n\tu32 enables;\n\tint rc;\n\n\tif (!TSIO_PIN_VALID(pin)) {\n\t\tnetdev_err(ptp->bp->dev, \"1PPS: Invalid pin. Check pin-function configuration\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\trc = hwrm_req_init(ptp->bp, req, HWRM_FUNC_PTP_PIN_CFG);\n\tif (rc)\n\t\treturn rc;\n\n\tenables = (FUNC_PTP_PIN_CFG_REQ_ENABLES_PIN0_STATE |\n\t\t   FUNC_PTP_PIN_CFG_REQ_ENABLES_PIN0_USAGE) << (pin * 2);\n\treq->enables = cpu_to_le32(enables);\n\n\tpin_state = &req->pin0_state;\n\tpin_usg = &req->pin0_usage;\n\n\t*(pin_state + (pin * 2)) = state;\n\t*(pin_usg + (pin * 2)) = usage;\n\n\trc = hwrm_req_send(ptp->bp, req);\n\tif (rc)\n\t\treturn rc;\n\n\tptp->pps_info.pins[pin].usage = usage;\n\tptp->pps_info.pins[pin].state = state;\n\n\treturn 0;\n}\n\nstatic int bnxt_ptp_cfg_event(struct bnxt *bp, u8 event)\n{\n\tstruct hwrm_func_ptp_cfg_input *req;\n\tint rc;\n\n\trc = hwrm_req_init(bp, req, HWRM_FUNC_PTP_CFG);\n\tif (rc)\n\t\treturn rc;\n\n\treq->enables = cpu_to_le16(FUNC_PTP_CFG_REQ_ENABLES_PTP_PPS_EVENT);\n\treq->ptp_pps_event = event;\n\treturn hwrm_req_send(bp, req);\n}\n\nvoid bnxt_ptp_cfg_tstamp_filters(struct bnxt *bp)\n{\n\tstruct bnxt_ptp_cfg *ptp = bp->ptp_cfg;\n\tstruct hwrm_port_mac_cfg_input *req;\n\n\tif (!ptp || !ptp->tstamp_filters)\n\t\treturn;\n\n\tif (hwrm_req_init(bp, req, HWRM_PORT_MAC_CFG))\n\t\tgoto out;\n\n\tif (!(bp->fw_cap & BNXT_FW_CAP_RX_ALL_PKT_TS) && (ptp->tstamp_filters &\n\t    (PORT_MAC_CFG_REQ_FLAGS_ALL_RX_TS_CAPTURE_ENABLE |\n\t     PORT_MAC_CFG_REQ_FLAGS_ALL_RX_TS_CAPTURE_DISABLE))) {\n\t\tptp->tstamp_filters &= ~(PORT_MAC_CFG_REQ_FLAGS_ALL_RX_TS_CAPTURE_ENABLE |\n\t\t\t\t\t PORT_MAC_CFG_REQ_FLAGS_ALL_RX_TS_CAPTURE_DISABLE);\n\t\tnetdev_warn(bp->dev, \"Unsupported FW for all RX pkts timestamp filter\\n\");\n\t}\n\n\treq->flags = cpu_to_le32(ptp->tstamp_filters);\n\treq->enables = cpu_to_le32(PORT_MAC_CFG_REQ_ENABLES_RX_TS_CAPTURE_PTP_MSG_TYPE);\n\treq->rx_ts_capture_ptp_msg_type = cpu_to_le16(ptp->rxctl);\n\n\tif (!hwrm_req_send(bp, req)) {\n\t\tbp->ptp_all_rx_tstamp = !!(ptp->tstamp_filters &\n\t\t\t\t\t   PORT_MAC_CFG_REQ_FLAGS_ALL_RX_TS_CAPTURE_ENABLE);\n\t\treturn;\n\t}\n\tptp->tstamp_filters = 0;\nout:\n\tbp->ptp_all_rx_tstamp = 0;\n\tnetdev_warn(bp->dev, \"Failed to configure HW packet timestamp filters\\n\");\n}\n\nvoid bnxt_ptp_reapply_pps(struct bnxt *bp)\n{\n\tstruct bnxt_ptp_cfg *ptp = bp->ptp_cfg;\n\tstruct bnxt_pps *pps;\n\tu32 pin = 0;\n\tint rc;\n\n\tif (!ptp || !(bp->fw_cap & BNXT_FW_CAP_PTP_PPS) ||\n\t    !(ptp->ptp_info.pin_config))\n\t\treturn;\n\tpps = &ptp->pps_info;\n\tfor (pin = 0; pin < BNXT_MAX_TSIO_PINS; pin++) {\n\t\tif (pps->pins[pin].state) {\n\t\t\trc = bnxt_ptp_cfg_pin(bp, pin, pps->pins[pin].usage);\n\t\t\tif (!rc && pps->pins[pin].event)\n\t\t\t\trc = bnxt_ptp_cfg_event(bp,\n\t\t\t\t\t\t\tpps->pins[pin].event);\n\t\t\tif (rc)\n\t\t\t\tnetdev_err(bp->dev, \"1PPS: Failed to configure pin%d\\n\",\n\t\t\t\t\t   pin);\n\t\t}\n\t}\n}\n\nstatic int bnxt_get_target_cycles(struct bnxt_ptp_cfg *ptp, u64 target_ns,\n\t\t\t\t  u64 *cycles_delta)\n{\n\tu64 cycles_now;\n\tu64 nsec_now, nsec_delta;\n\tint rc;\n\n\tspin_lock_bh(&ptp->ptp_lock);\n\trc = bnxt_refclk_read(ptp->bp, NULL, &cycles_now);\n\tif (rc) {\n\t\tspin_unlock_bh(&ptp->ptp_lock);\n\t\treturn rc;\n\t}\n\tnsec_now = timecounter_cyc2time(&ptp->tc, cycles_now);\n\tspin_unlock_bh(&ptp->ptp_lock);\n\n\tnsec_delta = target_ns - nsec_now;\n\t*cycles_delta = div64_u64(nsec_delta << ptp->cc.shift, ptp->cc.mult);\n\treturn 0;\n}\n\nstatic int bnxt_ptp_perout_cfg(struct bnxt_ptp_cfg *ptp,\n\t\t\t       struct ptp_clock_request *rq)\n{\n\tstruct hwrm_func_ptp_cfg_input *req;\n\tstruct bnxt *bp = ptp->bp;\n\tstruct timespec64 ts;\n\tu64 target_ns, delta;\n\tu16 enables;\n\tint rc;\n\n\tts.tv_sec = rq->perout.start.sec;\n\tts.tv_nsec = rq->perout.start.nsec;\n\ttarget_ns = timespec64_to_ns(&ts);\n\n\trc = bnxt_get_target_cycles(ptp, target_ns, &delta);\n\tif (rc)\n\t\treturn rc;\n\n\trc = hwrm_req_init(bp, req, HWRM_FUNC_PTP_CFG);\n\tif (rc)\n\t\treturn rc;\n\n\tenables = FUNC_PTP_CFG_REQ_ENABLES_PTP_FREQ_ADJ_EXT_PERIOD |\n\t\t  FUNC_PTP_CFG_REQ_ENABLES_PTP_FREQ_ADJ_EXT_UP |\n\t\t  FUNC_PTP_CFG_REQ_ENABLES_PTP_FREQ_ADJ_EXT_PHASE;\n\treq->enables = cpu_to_le16(enables);\n\treq->ptp_pps_event = 0;\n\treq->ptp_freq_adj_dll_source = 0;\n\treq->ptp_freq_adj_dll_phase = 0;\n\treq->ptp_freq_adj_ext_period = cpu_to_le32(NSEC_PER_SEC);\n\treq->ptp_freq_adj_ext_up = 0;\n\treq->ptp_freq_adj_ext_phase_lower = cpu_to_le32(delta);\n\n\treturn hwrm_req_send(bp, req);\n}\n\nstatic int bnxt_ptp_enable(struct ptp_clock_info *ptp_info,\n\t\t\t   struct ptp_clock_request *rq, int on)\n{\n\tstruct bnxt_ptp_cfg *ptp = container_of(ptp_info, struct bnxt_ptp_cfg,\n\t\t\t\t\t\tptp_info);\n\tstruct bnxt *bp = ptp->bp;\n\tint pin_id;\n\tint rc;\n\n\tswitch (rq->type) {\n\tcase PTP_CLK_REQ_EXTTS:\n\t\t \n\t\tpin_id = ptp_find_pin(ptp->ptp_clock, PTP_PF_EXTTS,\n\t\t\t\t      rq->extts.index);\n\t\tif (!TSIO_PIN_VALID(pin_id))\n\t\t\treturn -EOPNOTSUPP;\n\t\tif (!on)\n\t\t\tbreak;\n\t\trc = bnxt_ptp_cfg_pin(bp, pin_id, BNXT_PPS_PIN_PPS_IN);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\trc = bnxt_ptp_cfg_event(bp, BNXT_PPS_EVENT_EXTERNAL);\n\t\tif (!rc)\n\t\t\tptp->pps_info.pins[pin_id].event = BNXT_PPS_EVENT_EXTERNAL;\n\t\treturn rc;\n\tcase PTP_CLK_REQ_PEROUT:\n\t\t \n\t\tpin_id = ptp_find_pin(ptp->ptp_clock, PTP_PF_PEROUT,\n\t\t\t\t      rq->perout.index);\n\t\tif (!TSIO_PIN_VALID(pin_id))\n\t\t\treturn -EOPNOTSUPP;\n\t\tif (!on)\n\t\t\tbreak;\n\n\t\trc = bnxt_ptp_cfg_pin(bp, pin_id, BNXT_PPS_PIN_PPS_OUT);\n\t\tif (!rc)\n\t\t\trc = bnxt_ptp_perout_cfg(ptp, rq);\n\n\t\treturn rc;\n\tcase PTP_CLK_REQ_PPS:\n\t\t \n\t\trc = bnxt_ptp_cfg_pin(bp, 0, BNXT_PPS_PIN_PPS_IN);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\trc = bnxt_ptp_cfg_event(bp, BNXT_PPS_EVENT_INTERNAL);\n\t\tif (!rc)\n\t\t\tptp->pps_info.pins[0].event = BNXT_PPS_EVENT_INTERNAL;\n\t\treturn rc;\n\tdefault:\n\t\tnetdev_err(ptp->bp->dev, \"Unrecognized PIN function\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn bnxt_ptp_cfg_pin(bp, pin_id, BNXT_PPS_PIN_NONE);\n}\n\nstatic int bnxt_hwrm_ptp_cfg(struct bnxt *bp)\n{\n\tstruct bnxt_ptp_cfg *ptp = bp->ptp_cfg;\n\tu32 flags = 0;\n\tint rc = 0;\n\n\tswitch (ptp->rx_filter) {\n\tcase HWTSTAMP_FILTER_ALL:\n\t\tflags = PORT_MAC_CFG_REQ_FLAGS_ALL_RX_TS_CAPTURE_ENABLE;\n\t\tbreak;\n\tcase HWTSTAMP_FILTER_NONE:\n\t\tflags = PORT_MAC_CFG_REQ_FLAGS_PTP_RX_TS_CAPTURE_DISABLE;\n\t\tif (bp->fw_cap & BNXT_FW_CAP_RX_ALL_PKT_TS)\n\t\t\tflags |= PORT_MAC_CFG_REQ_FLAGS_ALL_RX_TS_CAPTURE_DISABLE;\n\t\tbreak;\n\tcase HWTSTAMP_FILTER_PTP_V2_EVENT:\n\tcase HWTSTAMP_FILTER_PTP_V2_SYNC:\n\tcase HWTSTAMP_FILTER_PTP_V2_DELAY_REQ:\n\t\tflags = PORT_MAC_CFG_REQ_FLAGS_PTP_RX_TS_CAPTURE_ENABLE;\n\t\tbreak;\n\t}\n\n\tif (ptp->tx_tstamp_en)\n\t\tflags |= PORT_MAC_CFG_REQ_FLAGS_PTP_TX_TS_CAPTURE_ENABLE;\n\telse\n\t\tflags |= PORT_MAC_CFG_REQ_FLAGS_PTP_TX_TS_CAPTURE_DISABLE;\n\n\tptp->tstamp_filters = flags;\n\n\tif (netif_running(bp->dev)) {\n\t\tif (ptp->rx_filter == HWTSTAMP_FILTER_ALL) {\n\t\t\tbnxt_close_nic(bp, false, false);\n\t\t\trc = bnxt_open_nic(bp, false, false);\n\t\t} else {\n\t\t\tbnxt_ptp_cfg_tstamp_filters(bp);\n\t\t}\n\t\tif (!rc && !ptp->tstamp_filters)\n\t\t\trc = -EIO;\n\t}\n\n\treturn rc;\n}\n\nint bnxt_hwtstamp_set(struct net_device *dev, struct ifreq *ifr)\n{\n\tstruct bnxt *bp = netdev_priv(dev);\n\tstruct hwtstamp_config stmpconf;\n\tstruct bnxt_ptp_cfg *ptp;\n\tu16 old_rxctl;\n\tint old_rx_filter, rc;\n\tu8 old_tx_tstamp_en;\n\n\tptp = bp->ptp_cfg;\n\tif (!ptp)\n\t\treturn -EOPNOTSUPP;\n\n\tif (copy_from_user(&stmpconf, ifr->ifr_data, sizeof(stmpconf)))\n\t\treturn -EFAULT;\n\n\tif (stmpconf.tx_type != HWTSTAMP_TX_ON &&\n\t    stmpconf.tx_type != HWTSTAMP_TX_OFF)\n\t\treturn -ERANGE;\n\n\told_rx_filter = ptp->rx_filter;\n\told_rxctl = ptp->rxctl;\n\told_tx_tstamp_en = ptp->tx_tstamp_en;\n\tswitch (stmpconf.rx_filter) {\n\tcase HWTSTAMP_FILTER_NONE:\n\t\tptp->rxctl = 0;\n\t\tptp->rx_filter = HWTSTAMP_FILTER_NONE;\n\t\tbreak;\n\tcase HWTSTAMP_FILTER_ALL:\n\t\tif (bp->fw_cap & BNXT_FW_CAP_RX_ALL_PKT_TS) {\n\t\t\tptp->rx_filter = HWTSTAMP_FILTER_ALL;\n\t\t\tbreak;\n\t\t}\n\t\treturn -EOPNOTSUPP;\n\tcase HWTSTAMP_FILTER_PTP_V2_EVENT:\n\tcase HWTSTAMP_FILTER_PTP_V2_L2_EVENT:\n\tcase HWTSTAMP_FILTER_PTP_V2_L4_EVENT:\n\t\tptp->rxctl = BNXT_PTP_MSG_EVENTS;\n\t\tptp->rx_filter = HWTSTAMP_FILTER_PTP_V2_EVENT;\n\t\tbreak;\n\tcase HWTSTAMP_FILTER_PTP_V2_SYNC:\n\tcase HWTSTAMP_FILTER_PTP_V2_L2_SYNC:\n\tcase HWTSTAMP_FILTER_PTP_V2_L4_SYNC:\n\t\tptp->rxctl = BNXT_PTP_MSG_SYNC;\n\t\tptp->rx_filter = HWTSTAMP_FILTER_PTP_V2_SYNC;\n\t\tbreak;\n\tcase HWTSTAMP_FILTER_PTP_V2_DELAY_REQ:\n\tcase HWTSTAMP_FILTER_PTP_V2_L2_DELAY_REQ:\n\tcase HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ:\n\t\tptp->rxctl = BNXT_PTP_MSG_DELAY_REQ;\n\t\tptp->rx_filter = HWTSTAMP_FILTER_PTP_V2_DELAY_REQ;\n\t\tbreak;\n\tdefault:\n\t\treturn -ERANGE;\n\t}\n\n\tif (stmpconf.tx_type == HWTSTAMP_TX_ON)\n\t\tptp->tx_tstamp_en = 1;\n\telse\n\t\tptp->tx_tstamp_en = 0;\n\n\trc = bnxt_hwrm_ptp_cfg(bp);\n\tif (rc)\n\t\tgoto ts_set_err;\n\n\tstmpconf.rx_filter = ptp->rx_filter;\n\treturn copy_to_user(ifr->ifr_data, &stmpconf, sizeof(stmpconf)) ?\n\t\t-EFAULT : 0;\n\nts_set_err:\n\tptp->rx_filter = old_rx_filter;\n\tptp->rxctl = old_rxctl;\n\tptp->tx_tstamp_en = old_tx_tstamp_en;\n\treturn rc;\n}\n\nint bnxt_hwtstamp_get(struct net_device *dev, struct ifreq *ifr)\n{\n\tstruct bnxt *bp = netdev_priv(dev);\n\tstruct hwtstamp_config stmpconf;\n\tstruct bnxt_ptp_cfg *ptp;\n\n\tptp = bp->ptp_cfg;\n\tif (!ptp)\n\t\treturn -EOPNOTSUPP;\n\n\tstmpconf.flags = 0;\n\tstmpconf.tx_type = ptp->tx_tstamp_en ? HWTSTAMP_TX_ON : HWTSTAMP_TX_OFF;\n\n\tstmpconf.rx_filter = ptp->rx_filter;\n\treturn copy_to_user(ifr->ifr_data, &stmpconf, sizeof(stmpconf)) ?\n\t\t-EFAULT : 0;\n}\n\nstatic int bnxt_map_regs(struct bnxt *bp, u32 *reg_arr, int count, int reg_win)\n{\n\tu32 reg_base = *reg_arr & BNXT_GRC_BASE_MASK;\n\tu32 win_off;\n\tint i;\n\n\tfor (i = 0; i < count; i++) {\n\t\tif ((reg_arr[i] & BNXT_GRC_BASE_MASK) != reg_base)\n\t\t\treturn -ERANGE;\n\t}\n\twin_off = BNXT_GRCPF_REG_WINDOW_BASE_OUT + (reg_win - 1) * 4;\n\twritel(reg_base, bp->bar0 + win_off);\n\treturn 0;\n}\n\nstatic int bnxt_map_ptp_regs(struct bnxt *bp)\n{\n\tstruct bnxt_ptp_cfg *ptp = bp->ptp_cfg;\n\tu32 *reg_arr;\n\tint rc, i;\n\n\treg_arr = ptp->refclk_regs;\n\tif (bp->flags & BNXT_FLAG_CHIP_P5) {\n\t\trc = bnxt_map_regs(bp, reg_arr, 2, BNXT_PTP_GRC_WIN);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tfor (i = 0; i < 2; i++)\n\t\t\tptp->refclk_mapped_regs[i] = BNXT_PTP_GRC_WIN_BASE +\n\t\t\t\t(ptp->refclk_regs[i] & BNXT_GRC_OFFSET_MASK);\n\t\treturn 0;\n\t}\n\treturn -ENODEV;\n}\n\nstatic void bnxt_unmap_ptp_regs(struct bnxt *bp)\n{\n\twritel(0, bp->bar0 + BNXT_GRCPF_REG_WINDOW_BASE_OUT +\n\t\t  (BNXT_PTP_GRC_WIN - 1) * 4);\n}\n\nstatic u64 bnxt_cc_read(const struct cyclecounter *cc)\n{\n\tstruct bnxt_ptp_cfg *ptp = container_of(cc, struct bnxt_ptp_cfg, cc);\n\tu64 ns = 0;\n\n\tbnxt_refclk_read(ptp->bp, NULL, &ns);\n\treturn ns;\n}\n\nstatic void bnxt_stamp_tx_skb(struct bnxt *bp, struct sk_buff *skb)\n{\n\tstruct bnxt_ptp_cfg *ptp = bp->ptp_cfg;\n\tstruct skb_shared_hwtstamps timestamp;\n\tu64 ts = 0, ns = 0;\n\tint rc;\n\n\trc = bnxt_hwrm_port_ts_query(bp, PORT_TS_QUERY_REQ_FLAGS_PATH_TX, &ts);\n\tif (!rc) {\n\t\tmemset(&timestamp, 0, sizeof(timestamp));\n\t\tspin_lock_bh(&ptp->ptp_lock);\n\t\tns = timecounter_cyc2time(&ptp->tc, ts);\n\t\tspin_unlock_bh(&ptp->ptp_lock);\n\t\ttimestamp.hwtstamp = ns_to_ktime(ns);\n\t\tskb_tstamp_tx(ptp->tx_skb, &timestamp);\n\t} else {\n\t\tnetdev_err(bp->dev, \"TS query for TX timer failed rc = %x\\n\",\n\t\t\t   rc);\n\t}\n\n\tdev_kfree_skb_any(ptp->tx_skb);\n\tptp->tx_skb = NULL;\n\tatomic_inc(&ptp->tx_avail);\n}\n\nstatic long bnxt_ptp_ts_aux_work(struct ptp_clock_info *ptp_info)\n{\n\tstruct bnxt_ptp_cfg *ptp = container_of(ptp_info, struct bnxt_ptp_cfg,\n\t\t\t\t\t\tptp_info);\n\tunsigned long now = jiffies;\n\tstruct bnxt *bp = ptp->bp;\n\n\tif (ptp->tx_skb)\n\t\tbnxt_stamp_tx_skb(bp, ptp->tx_skb);\n\n\tif (!time_after_eq(now, ptp->next_period))\n\t\treturn ptp->next_period - now;\n\n\tbnxt_ptp_get_current_time(bp);\n\tptp->next_period = now + HZ;\n\tif (time_after_eq(now, ptp->next_overflow_check)) {\n\t\tspin_lock_bh(&ptp->ptp_lock);\n\t\ttimecounter_read(&ptp->tc);\n\t\tspin_unlock_bh(&ptp->ptp_lock);\n\t\tptp->next_overflow_check = now + BNXT_PHC_OVERFLOW_PERIOD;\n\t}\n\treturn HZ;\n}\n\nint bnxt_get_tx_ts_p5(struct bnxt *bp, struct sk_buff *skb)\n{\n\tstruct bnxt_ptp_cfg *ptp = bp->ptp_cfg;\n\n\tif (ptp->tx_skb) {\n\t\tnetdev_err(bp->dev, \"deferring skb:one SKB is still outstanding\\n\");\n\t\treturn -EBUSY;\n\t}\n\tptp->tx_skb = skb;\n\tptp_schedule_worker(ptp->ptp_clock, 0);\n\treturn 0;\n}\n\nint bnxt_get_rx_ts_p5(struct bnxt *bp, u64 *ts, u32 pkt_ts)\n{\n\tstruct bnxt_ptp_cfg *ptp = bp->ptp_cfg;\n\tu64 time;\n\n\tif (!ptp)\n\t\treturn -ENODEV;\n\n\tBNXT_READ_TIME64(ptp, time, ptp->old_time);\n\t*ts = (time & BNXT_HI_TIMER_MASK) | pkt_ts;\n\tif (pkt_ts < (time & BNXT_LO_TIMER_MASK))\n\t\t*ts += BNXT_LO_TIMER_MASK + 1;\n\n\treturn 0;\n}\n\nstatic const struct ptp_clock_info bnxt_ptp_caps = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"bnxt clock\",\n\t.max_adj\t= BNXT_MAX_PHC_DRIFT,\n\t.n_alarm\t= 0,\n\t.n_ext_ts\t= 0,\n\t.n_per_out\t= 0,\n\t.n_pins\t\t= 0,\n\t.pps\t\t= 0,\n\t.adjfine\t= bnxt_ptp_adjfine,\n\t.adjtime\t= bnxt_ptp_adjtime,\n\t.do_aux_work\t= bnxt_ptp_ts_aux_work,\n\t.gettimex64\t= bnxt_ptp_gettimex,\n\t.settime64\t= bnxt_ptp_settime,\n\t.enable\t\t= bnxt_ptp_enable,\n};\n\nstatic int bnxt_ptp_verify(struct ptp_clock_info *ptp_info, unsigned int pin,\n\t\t\t   enum ptp_pin_function func, unsigned int chan)\n{\n\tstruct bnxt_ptp_cfg *ptp = container_of(ptp_info, struct bnxt_ptp_cfg,\n\t\t\t\t\t\tptp_info);\n\t \n\tif (ptp->pps_info.pins[pin].usage <= BNXT_PPS_PIN_PPS_OUT &&\n\t    func != PTP_PF_PHYSYNC)\n\t\treturn 0;\n\telse\n\t\treturn -EOPNOTSUPP;\n}\n\nstatic int bnxt_ptp_pps_init(struct bnxt *bp)\n{\n\tstruct hwrm_func_ptp_pin_qcfg_output *resp;\n\tstruct hwrm_func_ptp_pin_qcfg_input *req;\n\tstruct bnxt_ptp_cfg *ptp = bp->ptp_cfg;\n\tstruct ptp_clock_info *ptp_info;\n\tstruct bnxt_pps *pps_info;\n\tu8 *pin_usg;\n\tu32 i, rc;\n\n\t \n\trc = hwrm_req_init(bp, req, HWRM_FUNC_PTP_PIN_QCFG);\n\tif (rc)\n\t\treturn rc;\n\n\tresp = hwrm_req_hold(bp, req);\n\trc = hwrm_req_send(bp, req);\n\tif (rc || !resp->num_pins) {\n\t\thwrm_req_drop(bp, req);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tptp_info = &ptp->ptp_info;\n\tpps_info = &ptp->pps_info;\n\tpps_info->num_pins = resp->num_pins;\n\tptp_info->n_pins = pps_info->num_pins;\n\tptp_info->pin_config = kcalloc(ptp_info->n_pins,\n\t\t\t\t       sizeof(*ptp_info->pin_config),\n\t\t\t\t       GFP_KERNEL);\n\tif (!ptp_info->pin_config) {\n\t\thwrm_req_drop(bp, req);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tpin_usg = &resp->pin0_usage;\n\tfor (i = 0; i < pps_info->num_pins; i++, pin_usg++) {\n\t\tsnprintf(ptp_info->pin_config[i].name,\n\t\t\t sizeof(ptp_info->pin_config[i].name), \"bnxt_pps%d\", i);\n\t\tptp_info->pin_config[i].index = i;\n\t\tptp_info->pin_config[i].chan = i;\n\t\tif (*pin_usg == BNXT_PPS_PIN_PPS_IN)\n\t\t\tptp_info->pin_config[i].func = PTP_PF_EXTTS;\n\t\telse if (*pin_usg == BNXT_PPS_PIN_PPS_OUT)\n\t\t\tptp_info->pin_config[i].func = PTP_PF_PEROUT;\n\t\telse\n\t\t\tptp_info->pin_config[i].func = PTP_PF_NONE;\n\n\t\tpps_info->pins[i].usage = *pin_usg;\n\t}\n\thwrm_req_drop(bp, req);\n\n\t \n\tptp_info->n_ext_ts = 1;\n\tptp_info->n_per_out = 1;\n\tptp_info->pps = 1;\n\tptp_info->verify = bnxt_ptp_verify;\n\n\treturn 0;\n}\n\nstatic bool bnxt_pps_config_ok(struct bnxt *bp)\n{\n\tstruct bnxt_ptp_cfg *ptp = bp->ptp_cfg;\n\n\treturn !(bp->fw_cap & BNXT_FW_CAP_PTP_PPS) == !ptp->ptp_info.pin_config;\n}\n\nstatic void bnxt_ptp_timecounter_init(struct bnxt *bp, bool init_tc)\n{\n\tstruct bnxt_ptp_cfg *ptp = bp->ptp_cfg;\n\n\tif (!ptp->ptp_clock) {\n\t\tmemset(&ptp->cc, 0, sizeof(ptp->cc));\n\t\tptp->cc.read = bnxt_cc_read;\n\t\tptp->cc.mask = CYCLECOUNTER_MASK(48);\n\t\tif (BNXT_MH(bp)) {\n\t\t\t \n\t\t\tptp->cc.shift = BNXT_CYCLES_SHIFT;\n\t\t\tptp->cc.mult = clocksource_khz2mult(BNXT_DEVCLK_FREQ, ptp->cc.shift);\n\t\t\tptp->cmult = ptp->cc.mult;\n\t\t} else {\n\t\t\tptp->cc.shift = 0;\n\t\t\tptp->cc.mult = 1;\n\t\t}\n\t\tptp->next_overflow_check = jiffies + BNXT_PHC_OVERFLOW_PERIOD;\n\t}\n\tif (init_tc)\n\t\ttimecounter_init(&ptp->tc, &ptp->cc, ktime_to_ns(ktime_get_real()));\n}\n\n \nvoid bnxt_ptp_rtc_timecounter_init(struct bnxt_ptp_cfg *ptp, u64 ns)\n{\n\ttimecounter_init(&ptp->tc, &ptp->cc, ns);\n\t \n\tptp->tc.cycle_last = ns & ptp->cc.mask;\n}\n\nint bnxt_ptp_init_rtc(struct bnxt *bp, bool phc_cfg)\n{\n\tstruct timespec64 tsp;\n\tu64 ns;\n\tint rc;\n\n\tif (!bp->ptp_cfg || !BNXT_PTP_USE_RTC(bp))\n\t\treturn -ENODEV;\n\n\tif (!phc_cfg) {\n\t\tktime_get_real_ts64(&tsp);\n\t\tns = timespec64_to_ns(&tsp);\n\t\trc = bnxt_ptp_cfg_settime(bp, ns);\n\t\tif (rc)\n\t\t\treturn rc;\n\t} else {\n\t\trc = bnxt_hwrm_port_ts_query(bp, PORT_TS_QUERY_REQ_FLAGS_CURRENT_TIME, &ns);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\tspin_lock_bh(&bp->ptp_cfg->ptp_lock);\n\tbnxt_ptp_rtc_timecounter_init(bp->ptp_cfg, ns);\n\tspin_unlock_bh(&bp->ptp_cfg->ptp_lock);\n\n\treturn 0;\n}\n\nstatic void bnxt_ptp_free(struct bnxt *bp)\n{\n\tstruct bnxt_ptp_cfg *ptp = bp->ptp_cfg;\n\n\tif (ptp->ptp_clock) {\n\t\tptp_clock_unregister(ptp->ptp_clock);\n\t\tptp->ptp_clock = NULL;\n\t\tkfree(ptp->ptp_info.pin_config);\n\t\tptp->ptp_info.pin_config = NULL;\n\t}\n}\n\nint bnxt_ptp_init(struct bnxt *bp, bool phc_cfg)\n{\n\tstruct bnxt_ptp_cfg *ptp = bp->ptp_cfg;\n\tint rc;\n\n\tif (!ptp)\n\t\treturn 0;\n\n\trc = bnxt_map_ptp_regs(bp);\n\tif (rc)\n\t\treturn rc;\n\n\tif (ptp->ptp_clock && bnxt_pps_config_ok(bp))\n\t\treturn 0;\n\n\tbnxt_ptp_free(bp);\n\n\tatomic_set(&ptp->tx_avail, BNXT_MAX_TX_TS);\n\tspin_lock_init(&ptp->ptp_lock);\n\n\tif (BNXT_PTP_USE_RTC(bp)) {\n\t\tbnxt_ptp_timecounter_init(bp, false);\n\t\trc = bnxt_ptp_init_rtc(bp, phc_cfg);\n\t\tif (rc)\n\t\t\tgoto out;\n\t} else {\n\t\tbnxt_ptp_timecounter_init(bp, true);\n\t\tbnxt_ptp_adjfine_rtc(bp, 0);\n\t}\n\tbnxt_hwrm_func_drv_rgtr(bp, NULL, 0, true);\n\n\tptp->ptp_info = bnxt_ptp_caps;\n\tif ((bp->fw_cap & BNXT_FW_CAP_PTP_PPS)) {\n\t\tif (bnxt_ptp_pps_init(bp))\n\t\t\tnetdev_err(bp->dev, \"1pps not initialized, continuing without 1pps support\\n\");\n\t}\n\tptp->ptp_clock = ptp_clock_register(&ptp->ptp_info, &bp->pdev->dev);\n\tif (IS_ERR(ptp->ptp_clock)) {\n\t\tint err = PTR_ERR(ptp->ptp_clock);\n\n\t\tptp->ptp_clock = NULL;\n\t\trc = err;\n\t\tgoto out;\n\t}\n\tif (bp->flags & BNXT_FLAG_CHIP_P5) {\n\t\tspin_lock_bh(&ptp->ptp_lock);\n\t\tbnxt_refclk_read(bp, NULL, &ptp->current_time);\n\t\tWRITE_ONCE(ptp->old_time, ptp->current_time);\n\t\tspin_unlock_bh(&ptp->ptp_lock);\n\t\tptp_schedule_worker(ptp->ptp_clock, 0);\n\t}\n\treturn 0;\n\nout:\n\tbnxt_ptp_free(bp);\n\tbnxt_unmap_ptp_regs(bp);\n\treturn rc;\n}\n\nvoid bnxt_ptp_clear(struct bnxt *bp)\n{\n\tstruct bnxt_ptp_cfg *ptp = bp->ptp_cfg;\n\n\tif (!ptp)\n\t\treturn;\n\n\tif (ptp->ptp_clock)\n\t\tptp_clock_unregister(ptp->ptp_clock);\n\n\tptp->ptp_clock = NULL;\n\tkfree(ptp->ptp_info.pin_config);\n\tptp->ptp_info.pin_config = NULL;\n\n\tif (ptp->tx_skb) {\n\t\tdev_kfree_skb_any(ptp->tx_skb);\n\t\tptp->tx_skb = NULL;\n\t}\n\tbnxt_unmap_ptp_regs(bp);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}