{
  "module_name": "bnxt_devlink.c",
  "hash_id": "197ff3aa99376b1660c5f366a03a47ed64f44118eebb1de6be4ebac594f32eeb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/broadcom/bnxt/bnxt_devlink.c",
  "human_readable_source": " \n\n#include <linux/pci.h>\n#include <linux/netdevice.h>\n#include <linux/vmalloc.h>\n#include <net/devlink.h>\n#include \"bnxt_hsi.h\"\n#include \"bnxt.h\"\n#include \"bnxt_hwrm.h\"\n#include \"bnxt_vfr.h\"\n#include \"bnxt_devlink.h\"\n#include \"bnxt_ethtool.h\"\n#include \"bnxt_ulp.h\"\n#include \"bnxt_ptp.h\"\n#include \"bnxt_coredump.h\"\n#include \"bnxt_nvm_defs.h\"\n\nstatic void __bnxt_fw_recover(struct bnxt *bp)\n{\n\tif (test_bit(BNXT_STATE_FW_FATAL_COND, &bp->state) ||\n\t    test_bit(BNXT_STATE_FW_NON_FATAL_COND, &bp->state))\n\t\tbnxt_fw_reset(bp);\n\telse\n\t\tbnxt_fw_exception(bp);\n}\n\nstatic int\nbnxt_dl_flash_update(struct devlink *dl,\n\t\t     struct devlink_flash_update_params *params,\n\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct bnxt *bp = bnxt_get_bp_from_dl(dl);\n\tint rc;\n\n\tif (!BNXT_PF(bp)) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"flash update not supported from a VF\");\n\t\treturn -EPERM;\n\t}\n\n\tdevlink_flash_update_status_notify(dl, \"Preparing to flash\", NULL, 0, 0);\n\trc = bnxt_flash_package_from_fw_obj(bp->dev, params->fw, 0, extack);\n\tif (!rc)\n\t\tdevlink_flash_update_status_notify(dl, \"Flashing done\", NULL, 0, 0);\n\telse\n\t\tdevlink_flash_update_status_notify(dl, \"Flashing failed\", NULL, 0, 0);\n\treturn rc;\n}\n\nstatic int bnxt_hwrm_remote_dev_reset_set(struct bnxt *bp, bool remote_reset)\n{\n\tstruct hwrm_func_cfg_input *req;\n\tint rc;\n\n\tif (~bp->fw_cap & BNXT_FW_CAP_HOT_RESET_IF)\n\t\treturn -EOPNOTSUPP;\n\n\trc = hwrm_req_init(bp, req, HWRM_FUNC_CFG);\n\tif (rc)\n\t\treturn rc;\n\n\treq->fid = cpu_to_le16(0xffff);\n\treq->enables = cpu_to_le32(FUNC_CFG_REQ_ENABLES_HOT_RESET_IF_SUPPORT);\n\tif (remote_reset)\n\t\treq->flags = cpu_to_le32(FUNC_CFG_REQ_FLAGS_HOT_RESET_IF_EN_DIS);\n\n\treturn hwrm_req_send(bp, req);\n}\n\nstatic char *bnxt_health_severity_str(enum bnxt_health_severity severity)\n{\n\tswitch (severity) {\n\tcase SEVERITY_NORMAL: return \"normal\";\n\tcase SEVERITY_WARNING: return \"warning\";\n\tcase SEVERITY_RECOVERABLE: return \"recoverable\";\n\tcase SEVERITY_FATAL: return \"fatal\";\n\tdefault: return \"unknown\";\n\t}\n}\n\nstatic char *bnxt_health_remedy_str(enum bnxt_health_remedy remedy)\n{\n\tswitch (remedy) {\n\tcase REMEDY_DEVLINK_RECOVER: return \"devlink recover\";\n\tcase REMEDY_POWER_CYCLE_DEVICE: return \"device power cycle\";\n\tcase REMEDY_POWER_CYCLE_HOST: return \"host power cycle\";\n\tcase REMEDY_FW_UPDATE: return \"update firmware\";\n\tcase REMEDY_HW_REPLACE: return \"replace hardware\";\n\tdefault: return \"unknown\";\n\t}\n}\n\nstatic int bnxt_fw_diagnose(struct devlink_health_reporter *reporter,\n\t\t\t    struct devlink_fmsg *fmsg,\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct bnxt *bp = devlink_health_reporter_priv(reporter);\n\tstruct bnxt_fw_health *h = bp->fw_health;\n\tu32 fw_status, fw_resets;\n\tint rc;\n\n\tif (test_bit(BNXT_STATE_IN_FW_RESET, &bp->state))\n\t\treturn devlink_fmsg_string_pair_put(fmsg, \"Status\", \"recovering\");\n\n\tif (!h->status_reliable)\n\t\treturn devlink_fmsg_string_pair_put(fmsg, \"Status\", \"unknown\");\n\n\tmutex_lock(&h->lock);\n\tfw_status = bnxt_fw_health_readl(bp, BNXT_FW_HEALTH_REG);\n\tif (BNXT_FW_IS_BOOTING(fw_status)) {\n\t\trc = devlink_fmsg_string_pair_put(fmsg, \"Status\", \"initializing\");\n\t\tif (rc)\n\t\t\tgoto unlock;\n\t} else if (h->severity || fw_status != BNXT_FW_STATUS_HEALTHY) {\n\t\tif (!h->severity) {\n\t\t\th->severity = SEVERITY_FATAL;\n\t\t\th->remedy = REMEDY_POWER_CYCLE_DEVICE;\n\t\t\th->diagnoses++;\n\t\t\tdevlink_health_report(h->fw_reporter,\n\t\t\t\t\t      \"FW error diagnosed\", h);\n\t\t}\n\t\trc = devlink_fmsg_string_pair_put(fmsg, \"Status\", \"error\");\n\t\tif (rc)\n\t\t\tgoto unlock;\n\t\trc = devlink_fmsg_u32_pair_put(fmsg, \"Syndrome\", fw_status);\n\t\tif (rc)\n\t\t\tgoto unlock;\n\t} else {\n\t\trc = devlink_fmsg_string_pair_put(fmsg, \"Status\", \"healthy\");\n\t\tif (rc)\n\t\t\tgoto unlock;\n\t}\n\n\trc = devlink_fmsg_string_pair_put(fmsg, \"Severity\",\n\t\t\t\t\t  bnxt_health_severity_str(h->severity));\n\tif (rc)\n\t\tgoto unlock;\n\n\tif (h->severity) {\n\t\trc = devlink_fmsg_string_pair_put(fmsg, \"Remedy\",\n\t\t\t\t\t\t  bnxt_health_remedy_str(h->remedy));\n\t\tif (rc)\n\t\t\tgoto unlock;\n\t\tif (h->remedy == REMEDY_DEVLINK_RECOVER) {\n\t\t\trc = devlink_fmsg_string_pair_put(fmsg, \"Impact\",\n\t\t\t\t\t\t\t  \"traffic+ntuple_cfg\");\n\t\t\tif (rc)\n\t\t\t\tgoto unlock;\n\t\t}\n\t}\n\nunlock:\n\tmutex_unlock(&h->lock);\n\tif (rc || !h->resets_reliable)\n\t\treturn rc;\n\n\tfw_resets = bnxt_fw_health_readl(bp, BNXT_FW_RESET_CNT_REG);\n\trc = devlink_fmsg_u32_pair_put(fmsg, \"Resets\", fw_resets);\n\tif (rc)\n\t\treturn rc;\n\trc = devlink_fmsg_u32_pair_put(fmsg, \"Arrests\", h->arrests);\n\tif (rc)\n\t\treturn rc;\n\trc = devlink_fmsg_u32_pair_put(fmsg, \"Survivals\", h->survivals);\n\tif (rc)\n\t\treturn rc;\n\trc = devlink_fmsg_u32_pair_put(fmsg, \"Discoveries\", h->discoveries);\n\tif (rc)\n\t\treturn rc;\n\trc = devlink_fmsg_u32_pair_put(fmsg, \"Fatalities\", h->fatalities);\n\tif (rc)\n\t\treturn rc;\n\treturn devlink_fmsg_u32_pair_put(fmsg, \"Diagnoses\", h->diagnoses);\n}\n\nstatic int bnxt_fw_dump(struct devlink_health_reporter *reporter,\n\t\t\tstruct devlink_fmsg *fmsg, void *priv_ctx,\n\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct bnxt *bp = devlink_health_reporter_priv(reporter);\n\tu32 dump_len;\n\tvoid *data;\n\tint rc;\n\n\t \n\tif (priv_ctx)\n\t\treturn -EOPNOTSUPP;\n\n\tdump_len = bnxt_get_coredump_length(bp, BNXT_DUMP_LIVE);\n\tif (!dump_len)\n\t\treturn -EIO;\n\n\tdata = vmalloc(dump_len);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\trc = bnxt_get_coredump(bp, BNXT_DUMP_LIVE, data, &dump_len);\n\tif (!rc) {\n\t\trc = devlink_fmsg_pair_nest_start(fmsg, \"core\");\n\t\tif (rc)\n\t\t\tgoto exit;\n\t\trc = devlink_fmsg_binary_pair_put(fmsg, \"data\", data, dump_len);\n\t\tif (rc)\n\t\t\tgoto exit;\n\t\trc = devlink_fmsg_u32_pair_put(fmsg, \"size\", dump_len);\n\t\tif (rc)\n\t\t\tgoto exit;\n\t\trc = devlink_fmsg_pair_nest_end(fmsg);\n\t}\n\nexit:\n\tvfree(data);\n\treturn rc;\n}\n\nstatic int bnxt_fw_recover(struct devlink_health_reporter *reporter,\n\t\t\t   void *priv_ctx,\n\t\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct bnxt *bp = devlink_health_reporter_priv(reporter);\n\n\tif (bp->fw_health->severity == SEVERITY_FATAL)\n\t\treturn -ENODEV;\n\n\tset_bit(BNXT_STATE_RECOVER, &bp->state);\n\t__bnxt_fw_recover(bp);\n\n\treturn -EINPROGRESS;\n}\n\nstatic const struct devlink_health_reporter_ops bnxt_dl_fw_reporter_ops = {\n\t.name = \"fw\",\n\t.diagnose = bnxt_fw_diagnose,\n\t.dump = bnxt_fw_dump,\n\t.recover = bnxt_fw_recover,\n};\n\nstatic struct devlink_health_reporter *\n__bnxt_dl_reporter_create(struct bnxt *bp,\n\t\t\t  const struct devlink_health_reporter_ops *ops)\n{\n\tstruct devlink_health_reporter *reporter;\n\n\treporter = devlink_health_reporter_create(bp->dl, ops, 0, bp);\n\tif (IS_ERR(reporter)) {\n\t\tnetdev_warn(bp->dev, \"Failed to create %s health reporter, rc = %ld\\n\",\n\t\t\t    ops->name, PTR_ERR(reporter));\n\t\treturn NULL;\n\t}\n\n\treturn reporter;\n}\n\nvoid bnxt_dl_fw_reporters_create(struct bnxt *bp)\n{\n\tstruct bnxt_fw_health *fw_health = bp->fw_health;\n\n\tif (fw_health && !fw_health->fw_reporter)\n\t\tfw_health->fw_reporter = __bnxt_dl_reporter_create(bp, &bnxt_dl_fw_reporter_ops);\n}\n\nvoid bnxt_dl_fw_reporters_destroy(struct bnxt *bp)\n{\n\tstruct bnxt_fw_health *fw_health = bp->fw_health;\n\n\tif (fw_health && fw_health->fw_reporter) {\n\t\tdevlink_health_reporter_destroy(fw_health->fw_reporter);\n\t\tfw_health->fw_reporter = NULL;\n\t}\n}\n\nvoid bnxt_devlink_health_fw_report(struct bnxt *bp)\n{\n\tstruct bnxt_fw_health *fw_health = bp->fw_health;\n\tint rc;\n\n\tif (!fw_health)\n\t\treturn;\n\n\tif (!fw_health->fw_reporter) {\n\t\t__bnxt_fw_recover(bp);\n\t\treturn;\n\t}\n\n\tmutex_lock(&fw_health->lock);\n\tfw_health->severity = SEVERITY_RECOVERABLE;\n\tfw_health->remedy = REMEDY_DEVLINK_RECOVER;\n\tmutex_unlock(&fw_health->lock);\n\trc = devlink_health_report(fw_health->fw_reporter, \"FW error reported\",\n\t\t\t\t   fw_health);\n\tif (rc == -ECANCELED)\n\t\t__bnxt_fw_recover(bp);\n}\n\nvoid bnxt_dl_health_fw_status_update(struct bnxt *bp, bool healthy)\n{\n\tstruct bnxt_fw_health *fw_health = bp->fw_health;\n\tu8 state;\n\n\tmutex_lock(&fw_health->lock);\n\tif (healthy) {\n\t\tfw_health->severity = SEVERITY_NORMAL;\n\t\tstate = DEVLINK_HEALTH_REPORTER_STATE_HEALTHY;\n\t} else {\n\t\tfw_health->severity = SEVERITY_FATAL;\n\t\tfw_health->remedy = REMEDY_POWER_CYCLE_DEVICE;\n\t\tstate = DEVLINK_HEALTH_REPORTER_STATE_ERROR;\n\t}\n\tmutex_unlock(&fw_health->lock);\n\tdevlink_health_reporter_state_update(fw_health->fw_reporter, state);\n}\n\nvoid bnxt_dl_health_fw_recovery_done(struct bnxt *bp)\n{\n\tstruct bnxt_dl *dl = devlink_priv(bp->dl);\n\n\tdevlink_health_reporter_recovery_done(bp->fw_health->fw_reporter);\n\tbnxt_hwrm_remote_dev_reset_set(bp, dl->remote_reset);\n}\n\nstatic int bnxt_dl_info_get(struct devlink *dl, struct devlink_info_req *req,\n\t\t\t    struct netlink_ext_ack *extack);\n\nstatic void\nbnxt_dl_livepatch_report_err(struct bnxt *bp, struct netlink_ext_ack *extack,\n\t\t\t     struct hwrm_fw_livepatch_output *resp)\n{\n\tint err = ((struct hwrm_err_output *)resp)->cmd_err;\n\n\tswitch (err) {\n\tcase FW_LIVEPATCH_CMD_ERR_CODE_INVALID_OPCODE:\n\t\tnetdev_err(bp->dev, \"Illegal live patch opcode\");\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Invalid opcode\");\n\t\tbreak;\n\tcase FW_LIVEPATCH_CMD_ERR_CODE_NOT_SUPPORTED:\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Live patch operation not supported\");\n\t\tbreak;\n\tcase FW_LIVEPATCH_CMD_ERR_CODE_NOT_INSTALLED:\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Live patch not found\");\n\t\tbreak;\n\tcase FW_LIVEPATCH_CMD_ERR_CODE_NOT_PATCHED:\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Live patch deactivation failed. Firmware not patched.\");\n\t\tbreak;\n\tcase FW_LIVEPATCH_CMD_ERR_CODE_AUTH_FAIL:\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Live patch not authenticated\");\n\t\tbreak;\n\tcase FW_LIVEPATCH_CMD_ERR_CODE_INVALID_HEADER:\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Incompatible live patch\");\n\t\tbreak;\n\tcase FW_LIVEPATCH_CMD_ERR_CODE_INVALID_SIZE:\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Live patch has invalid size\");\n\t\tbreak;\n\tcase FW_LIVEPATCH_CMD_ERR_CODE_ALREADY_PATCHED:\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Live patch already applied\");\n\t\tbreak;\n\tdefault:\n\t\tnetdev_err(bp->dev, \"Unexpected live patch error: %d\\n\", err);\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Failed to activate live patch\");\n\t\tbreak;\n\t}\n}\n\n \n#define BNXT_LIVEPATCH_NOT_INSTALLED\t0\n#define BNXT_LIVEPATCH_INSTALLED\tFW_LIVEPATCH_QUERY_RESP_STATUS_FLAGS_INSTALL\n#define BNXT_LIVEPATCH_REMOVED\t\tFW_LIVEPATCH_QUERY_RESP_STATUS_FLAGS_ACTIVE\n#define BNXT_LIVEPATCH_MASK\t\t(FW_LIVEPATCH_QUERY_RESP_STATUS_FLAGS_INSTALL | \\\n\t\t\t\t\t FW_LIVEPATCH_QUERY_RESP_STATUS_FLAGS_ACTIVE)\n#define BNXT_LIVEPATCH_ACTIVATED\tBNXT_LIVEPATCH_MASK\n\n#define BNXT_LIVEPATCH_STATE(flags)\t((flags) & BNXT_LIVEPATCH_MASK)\n\nstatic int\nbnxt_dl_livepatch_activate(struct bnxt *bp, struct netlink_ext_ack *extack)\n{\n\tstruct hwrm_fw_livepatch_query_output *query_resp;\n\tstruct hwrm_fw_livepatch_query_input *query_req;\n\tstruct hwrm_fw_livepatch_output *patch_resp;\n\tstruct hwrm_fw_livepatch_input *patch_req;\n\tu16 flags, live_patch_state;\n\tbool activated = false;\n\tu32 installed = 0;\n\tu8 target;\n\tint rc;\n\n\tif (~bp->fw_cap & BNXT_FW_CAP_LIVEPATCH) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Device does not support live patch\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\trc = hwrm_req_init(bp, query_req, HWRM_FW_LIVEPATCH_QUERY);\n\tif (rc)\n\t\treturn rc;\n\tquery_resp = hwrm_req_hold(bp, query_req);\n\n\trc = hwrm_req_init(bp, patch_req, HWRM_FW_LIVEPATCH);\n\tif (rc) {\n\t\thwrm_req_drop(bp, query_req);\n\t\treturn rc;\n\t}\n\tpatch_req->loadtype = FW_LIVEPATCH_REQ_LOADTYPE_NVM_INSTALL;\n\tpatch_resp = hwrm_req_hold(bp, patch_req);\n\n\tfor (target = 1; target <= FW_LIVEPATCH_REQ_FW_TARGET_LAST; target++) {\n\t\tquery_req->fw_target = target;\n\t\trc = hwrm_req_send(bp, query_req);\n\t\tif (rc) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Failed to query packages\");\n\t\t\tbreak;\n\t\t}\n\n\t\tflags = le16_to_cpu(query_resp->status_flags);\n\t\tlive_patch_state = BNXT_LIVEPATCH_STATE(flags);\n\n\t\tif (live_patch_state == BNXT_LIVEPATCH_NOT_INSTALLED)\n\t\t\tcontinue;\n\n\t\tif (live_patch_state == BNXT_LIVEPATCH_ACTIVATED) {\n\t\t\tactivated = true;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (live_patch_state == BNXT_LIVEPATCH_INSTALLED)\n\t\t\tpatch_req->opcode = FW_LIVEPATCH_REQ_OPCODE_ACTIVATE;\n\t\telse if (live_patch_state == BNXT_LIVEPATCH_REMOVED)\n\t\t\tpatch_req->opcode = FW_LIVEPATCH_REQ_OPCODE_DEACTIVATE;\n\n\t\tpatch_req->fw_target = target;\n\t\trc = hwrm_req_send(bp, patch_req);\n\t\tif (rc) {\n\t\t\tbnxt_dl_livepatch_report_err(bp, extack, patch_resp);\n\t\t\tbreak;\n\t\t}\n\t\tinstalled++;\n\t}\n\n\tif (!rc && !installed) {\n\t\tif (activated) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Live patch already activated\");\n\t\t\trc = -EEXIST;\n\t\t} else {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"No live patches found\");\n\t\t\trc = -ENOENT;\n\t\t}\n\t}\n\thwrm_req_drop(bp, query_req);\n\thwrm_req_drop(bp, patch_req);\n\treturn rc;\n}\n\nstatic int bnxt_dl_reload_down(struct devlink *dl, bool netns_change,\n\t\t\t       enum devlink_reload_action action,\n\t\t\t       enum devlink_reload_limit limit,\n\t\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct bnxt *bp = bnxt_get_bp_from_dl(dl);\n\tint rc = 0;\n\n\tswitch (action) {\n\tcase DEVLINK_RELOAD_ACTION_DRIVER_REINIT: {\n\t\trtnl_lock();\n\t\tif (bnxt_sriov_cfg(bp)) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t   \"reload is unsupported while VFs are allocated or being configured\");\n\t\t\trtnl_unlock();\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tif (bp->dev->reg_state == NETREG_UNREGISTERED) {\n\t\t\trtnl_unlock();\n\t\t\treturn -ENODEV;\n\t\t}\n\t\tbnxt_ulp_stop(bp);\n\t\tif (netif_running(bp->dev))\n\t\t\tbnxt_close_nic(bp, true, true);\n\t\tbnxt_vf_reps_free(bp);\n\t\trc = bnxt_hwrm_func_drv_unrgtr(bp);\n\t\tif (rc) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Failed to deregister\");\n\t\t\tif (netif_running(bp->dev))\n\t\t\t\tdev_close(bp->dev);\n\t\t\trtnl_unlock();\n\t\t\tbreak;\n\t\t}\n\t\tbnxt_cancel_reservations(bp, false);\n\t\tbnxt_free_ctx_mem(bp);\n\t\tkfree(bp->ctx);\n\t\tbp->ctx = NULL;\n\t\tbreak;\n\t}\n\tcase DEVLINK_RELOAD_ACTION_FW_ACTIVATE: {\n\t\tif (limit == DEVLINK_RELOAD_LIMIT_NO_RESET)\n\t\t\treturn bnxt_dl_livepatch_activate(bp, extack);\n\t\tif (~bp->fw_cap & BNXT_FW_CAP_HOT_RESET) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Device not capable, requires reboot\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tif (!bnxt_hwrm_reset_permitted(bp)) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t   \"Reset denied by firmware, it may be inhibited by remote driver\");\n\t\t\treturn -EPERM;\n\t\t}\n\t\trtnl_lock();\n\t\tif (bp->dev->reg_state == NETREG_UNREGISTERED) {\n\t\t\trtnl_unlock();\n\t\t\treturn -ENODEV;\n\t\t}\n\t\tif (netif_running(bp->dev))\n\t\t\tset_bit(BNXT_STATE_FW_ACTIVATE, &bp->state);\n\t\trc = bnxt_hwrm_firmware_reset(bp->dev,\n\t\t\t\t\t      FW_RESET_REQ_EMBEDDED_PROC_TYPE_CHIP,\n\t\t\t\t\t      FW_RESET_REQ_SELFRST_STATUS_SELFRSTASAP,\n\t\t\t\t\t      FW_RESET_REQ_FLAGS_RESET_GRACEFUL |\n\t\t\t\t\t      FW_RESET_REQ_FLAGS_FW_ACTIVATION);\n\t\tif (rc) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Failed to activate firmware\");\n\t\t\tclear_bit(BNXT_STATE_FW_ACTIVATE, &bp->state);\n\t\t\trtnl_unlock();\n\t\t}\n\t\tbreak;\n\t}\n\tdefault:\n\t\trc = -EOPNOTSUPP;\n\t}\n\n\treturn rc;\n}\n\nstatic int bnxt_dl_reload_up(struct devlink *dl, enum devlink_reload_action action,\n\t\t\t     enum devlink_reload_limit limit, u32 *actions_performed,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct bnxt *bp = bnxt_get_bp_from_dl(dl);\n\tint rc = 0;\n\n\t*actions_performed = 0;\n\tswitch (action) {\n\tcase DEVLINK_RELOAD_ACTION_DRIVER_REINIT: {\n\t\tbnxt_fw_init_one(bp);\n\t\tbnxt_vf_reps_alloc(bp);\n\t\tif (netif_running(bp->dev))\n\t\t\trc = bnxt_open_nic(bp, true, true);\n\t\tbnxt_ulp_start(bp, rc);\n\t\tif (!rc) {\n\t\t\tbnxt_reenable_sriov(bp);\n\t\t\tbnxt_ptp_reapply_pps(bp);\n\t\t}\n\t\tbreak;\n\t}\n\tcase DEVLINK_RELOAD_ACTION_FW_ACTIVATE: {\n\t\tunsigned long start = jiffies;\n\t\tunsigned long timeout = start + BNXT_DFLT_FW_RST_MAX_DSECS * HZ / 10;\n\n\t\tif (limit == DEVLINK_RELOAD_LIMIT_NO_RESET)\n\t\t\tbreak;\n\t\tif (bp->fw_cap & BNXT_FW_CAP_ERROR_RECOVERY)\n\t\t\ttimeout = start + bp->fw_health->normal_func_wait_dsecs * HZ / 10;\n\t\tif (!netif_running(bp->dev))\n\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t   \"Device is closed, not waiting for reset notice that will never come\");\n\t\trtnl_unlock();\n\t\twhile (test_bit(BNXT_STATE_FW_ACTIVATE, &bp->state)) {\n\t\t\tif (time_after(jiffies, timeout)) {\n\t\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Activation incomplete\");\n\t\t\t\trc = -ETIMEDOUT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (test_bit(BNXT_STATE_ABORT_ERR, &bp->state)) {\n\t\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Activation aborted\");\n\t\t\t\trc = -ENODEV;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmsleep(50);\n\t\t}\n\t\trtnl_lock();\n\t\tif (!rc)\n\t\t\t*actions_performed |= BIT(DEVLINK_RELOAD_ACTION_DRIVER_REINIT);\n\t\tclear_bit(BNXT_STATE_FW_ACTIVATE, &bp->state);\n\t\tbreak;\n\t}\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (!rc) {\n\t\tbnxt_print_device_info(bp);\n\t\tif (netif_running(bp->dev)) {\n\t\t\tmutex_lock(&bp->link_lock);\n\t\t\tbnxt_report_link(bp);\n\t\t\tmutex_unlock(&bp->link_lock);\n\t\t}\n\t\t*actions_performed |= BIT(action);\n\t} else if (netif_running(bp->dev)) {\n\t\tdev_close(bp->dev);\n\t}\n\trtnl_unlock();\n\treturn rc;\n}\n\nstatic bool bnxt_nvm_test(struct bnxt *bp, struct netlink_ext_ack *extack)\n{\n\tbool rc = false;\n\tu32 datalen;\n\tu16 index;\n\tu8 *buf;\n\n\tif (bnxt_find_nvram_item(bp->dev, BNX_DIR_TYPE_VPD,\n\t\t\t\t BNX_DIR_ORDINAL_FIRST, BNX_DIR_EXT_NONE,\n\t\t\t\t &index, NULL, &datalen) || !datalen) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"nvm test vpd entry error\");\n\t\treturn false;\n\t}\n\n\tbuf = kzalloc(datalen, GFP_KERNEL);\n\tif (!buf) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"insufficient memory for nvm test\");\n\t\treturn false;\n\t}\n\n\tif (bnxt_get_nvram_item(bp->dev, index, 0, datalen, buf)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"nvm test vpd read error\");\n\t\tgoto done;\n\t}\n\n\tif (bnxt_flash_nvram(bp->dev, BNX_DIR_TYPE_VPD, BNX_DIR_ORDINAL_FIRST,\n\t\t\t     BNX_DIR_EXT_NONE, 0, 0, buf, datalen)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"nvm test vpd write error\");\n\t\tgoto done;\n\t}\n\n\trc = true;\n\ndone:\n\tkfree(buf);\n\treturn rc;\n}\n\nstatic bool bnxt_dl_selftest_check(struct devlink *dl, unsigned int id,\n\t\t\t\t   struct netlink_ext_ack *extack)\n{\n\treturn id == DEVLINK_ATTR_SELFTEST_ID_FLASH;\n}\n\nstatic enum devlink_selftest_status bnxt_dl_selftest_run(struct devlink *dl,\n\t\t\t\t\t\t\t unsigned int id,\n\t\t\t\t\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct bnxt *bp = bnxt_get_bp_from_dl(dl);\n\n\tif (id == DEVLINK_ATTR_SELFTEST_ID_FLASH)\n\t\treturn bnxt_nvm_test(bp, extack) ?\n\t\t\t\tDEVLINK_SELFTEST_STATUS_PASS :\n\t\t\t\tDEVLINK_SELFTEST_STATUS_FAIL;\n\n\treturn DEVLINK_SELFTEST_STATUS_SKIP;\n}\n\nstatic const struct devlink_ops bnxt_dl_ops = {\n#ifdef CONFIG_BNXT_SRIOV\n\t.eswitch_mode_set = bnxt_dl_eswitch_mode_set,\n\t.eswitch_mode_get = bnxt_dl_eswitch_mode_get,\n#endif  \n\t.info_get\t  = bnxt_dl_info_get,\n\t.flash_update\t  = bnxt_dl_flash_update,\n\t.reload_actions\t  = BIT(DEVLINK_RELOAD_ACTION_DRIVER_REINIT) |\n\t\t\t    BIT(DEVLINK_RELOAD_ACTION_FW_ACTIVATE),\n\t.reload_limits\t  = BIT(DEVLINK_RELOAD_LIMIT_NO_RESET),\n\t.reload_down\t  = bnxt_dl_reload_down,\n\t.reload_up\t  = bnxt_dl_reload_up,\n\t.selftest_check\t  = bnxt_dl_selftest_check,\n\t.selftest_run\t  = bnxt_dl_selftest_run,\n};\n\nstatic const struct devlink_ops bnxt_vf_dl_ops;\n\nenum bnxt_dl_param_id {\n\tBNXT_DEVLINK_PARAM_ID_BASE = DEVLINK_PARAM_GENERIC_ID_MAX,\n\tBNXT_DEVLINK_PARAM_ID_GRE_VER_CHECK,\n};\n\nstatic const struct bnxt_dl_nvm_param nvm_params[] = {\n\t{DEVLINK_PARAM_GENERIC_ID_ENABLE_SRIOV, NVM_OFF_ENABLE_SRIOV,\n\t BNXT_NVM_SHARED_CFG, 1, 1},\n\t{DEVLINK_PARAM_GENERIC_ID_IGNORE_ARI, NVM_OFF_IGNORE_ARI,\n\t BNXT_NVM_SHARED_CFG, 1, 1},\n\t{DEVLINK_PARAM_GENERIC_ID_MSIX_VEC_PER_PF_MAX,\n\t NVM_OFF_MSIX_VEC_PER_PF_MAX, BNXT_NVM_SHARED_CFG, 10, 4},\n\t{DEVLINK_PARAM_GENERIC_ID_MSIX_VEC_PER_PF_MIN,\n\t NVM_OFF_MSIX_VEC_PER_PF_MIN, BNXT_NVM_SHARED_CFG, 7, 4},\n\t{BNXT_DEVLINK_PARAM_ID_GRE_VER_CHECK, NVM_OFF_DIS_GRE_VER_CHECK,\n\t BNXT_NVM_SHARED_CFG, 1, 1},\n};\n\nunion bnxt_nvm_data {\n\tu8\tval8;\n\t__le32\tval32;\n};\n\nstatic void bnxt_copy_to_nvm_data(union bnxt_nvm_data *dst,\n\t\t\t\t  union devlink_param_value *src,\n\t\t\t\t  int nvm_num_bits, int dl_num_bytes)\n{\n\tu32 val32 = 0;\n\n\tif (nvm_num_bits == 1) {\n\t\tdst->val8 = src->vbool;\n\t\treturn;\n\t}\n\tif (dl_num_bytes == 4)\n\t\tval32 = src->vu32;\n\telse if (dl_num_bytes == 2)\n\t\tval32 = (u32)src->vu16;\n\telse if (dl_num_bytes == 1)\n\t\tval32 = (u32)src->vu8;\n\tdst->val32 = cpu_to_le32(val32);\n}\n\nstatic void bnxt_copy_from_nvm_data(union devlink_param_value *dst,\n\t\t\t\t    union bnxt_nvm_data *src,\n\t\t\t\t    int nvm_num_bits, int dl_num_bytes)\n{\n\tu32 val32;\n\n\tif (nvm_num_bits == 1) {\n\t\tdst->vbool = src->val8;\n\t\treturn;\n\t}\n\tval32 = le32_to_cpu(src->val32);\n\tif (dl_num_bytes == 4)\n\t\tdst->vu32 = val32;\n\telse if (dl_num_bytes == 2)\n\t\tdst->vu16 = (u16)val32;\n\telse if (dl_num_bytes == 1)\n\t\tdst->vu8 = (u8)val32;\n}\n\nstatic int bnxt_hwrm_get_nvm_cfg_ver(struct bnxt *bp, u32 *nvm_cfg_ver)\n{\n\tstruct hwrm_nvm_get_variable_input *req;\n\tu16 bytes = BNXT_NVM_CFG_VER_BYTES;\n\tu16 bits = BNXT_NVM_CFG_VER_BITS;\n\tunion devlink_param_value ver;\n\tunion bnxt_nvm_data *data;\n\tdma_addr_t data_dma_addr;\n\tint rc, i = 2;\n\tu16 dim = 1;\n\n\trc = hwrm_req_init(bp, req, HWRM_NVM_GET_VARIABLE);\n\tif (rc)\n\t\treturn rc;\n\n\tdata = hwrm_req_dma_slice(bp, req, sizeof(*data), &data_dma_addr);\n\tif (!data) {\n\t\trc = -ENOMEM;\n\t\tgoto exit;\n\t}\n\n\t \n\tif (!BNXT_CHIP_P5(bp)) {\n\t\tdim = 0;\n\t\ti = 0;\n\t\tbits *= 3;   \n\t\tbytes *= 4;  \n\t}\n\n\thwrm_req_hold(bp, req);\n\treq->dest_data_addr = cpu_to_le64(data_dma_addr);\n\treq->data_len = cpu_to_le16(bits);\n\treq->option_num = cpu_to_le16(NVM_OFF_NVM_CFG_VER);\n\treq->dimensions = cpu_to_le16(dim);\n\n\twhile (i >= 0) {\n\t\treq->index_0 = cpu_to_le16(i--);\n\t\trc = hwrm_req_send_silent(bp, req);\n\t\tif (rc)\n\t\t\tgoto exit;\n\t\tbnxt_copy_from_nvm_data(&ver, data, bits, bytes);\n\n\t\tif (BNXT_CHIP_P5(bp)) {\n\t\t\t*nvm_cfg_ver <<= 8;\n\t\t\t*nvm_cfg_ver |= ver.vu8;\n\t\t} else {\n\t\t\t*nvm_cfg_ver = ver.vu32;\n\t\t}\n\t}\n\nexit:\n\thwrm_req_drop(bp, req);\n\treturn rc;\n}\n\nstatic int bnxt_dl_info_put(struct bnxt *bp, struct devlink_info_req *req,\n\t\t\t    enum bnxt_dl_version_type type, const char *key,\n\t\t\t    char *buf)\n{\n\tif (!strlen(buf))\n\t\treturn 0;\n\n\tif ((bp->flags & BNXT_FLAG_CHIP_P5) &&\n\t    (!strcmp(key, DEVLINK_INFO_VERSION_GENERIC_FW_NCSI) ||\n\t     !strcmp(key, DEVLINK_INFO_VERSION_GENERIC_FW_ROCE)))\n\t\treturn 0;\n\n\tswitch (type) {\n\tcase BNXT_VERSION_FIXED:\n\t\treturn devlink_info_version_fixed_put(req, key, buf);\n\tcase BNXT_VERSION_RUNNING:\n\t\treturn devlink_info_version_running_put(req, key, buf);\n\tcase BNXT_VERSION_STORED:\n\t\treturn devlink_info_version_stored_put(req, key, buf);\n\t}\n\treturn 0;\n}\n\n#define BNXT_FW_SRT_PATCH\t\"fw.srt.patch\"\n#define BNXT_FW_CRT_PATCH\t\"fw.crt.patch\"\n\nstatic int bnxt_dl_livepatch_info_put(struct bnxt *bp,\n\t\t\t\t      struct devlink_info_req *req,\n\t\t\t\t      const char *key)\n{\n\tstruct hwrm_fw_livepatch_query_input *query;\n\tstruct hwrm_fw_livepatch_query_output *resp;\n\tu16 flags;\n\tint rc;\n\n\tif (~bp->fw_cap & BNXT_FW_CAP_LIVEPATCH)\n\t\treturn 0;\n\n\trc = hwrm_req_init(bp, query, HWRM_FW_LIVEPATCH_QUERY);\n\tif (rc)\n\t\treturn rc;\n\n\tif (!strcmp(key, BNXT_FW_SRT_PATCH))\n\t\tquery->fw_target = FW_LIVEPATCH_QUERY_REQ_FW_TARGET_SECURE_FW;\n\telse if (!strcmp(key, BNXT_FW_CRT_PATCH))\n\t\tquery->fw_target = FW_LIVEPATCH_QUERY_REQ_FW_TARGET_COMMON_FW;\n\telse\n\t\tgoto exit;\n\n\tresp = hwrm_req_hold(bp, query);\n\trc = hwrm_req_send(bp, query);\n\tif (rc)\n\t\tgoto exit;\n\n\tflags = le16_to_cpu(resp->status_flags);\n\tif (flags & FW_LIVEPATCH_QUERY_RESP_STATUS_FLAGS_ACTIVE) {\n\t\tresp->active_ver[sizeof(resp->active_ver) - 1] = '\\0';\n\t\trc = devlink_info_version_running_put(req, key, resp->active_ver);\n\t\tif (rc)\n\t\t\tgoto exit;\n\t}\n\n\tif (flags & FW_LIVEPATCH_QUERY_RESP_STATUS_FLAGS_INSTALL) {\n\t\tresp->install_ver[sizeof(resp->install_ver) - 1] = '\\0';\n\t\trc = devlink_info_version_stored_put(req, key, resp->install_ver);\n\t\tif (rc)\n\t\t\tgoto exit;\n\t}\n\nexit:\n\thwrm_req_drop(bp, query);\n\treturn rc;\n}\n\n#define HWRM_FW_VER_STR_LEN\t16\n\nstatic int bnxt_dl_info_get(struct devlink *dl, struct devlink_info_req *req,\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct hwrm_nvm_get_dev_info_output nvm_dev_info;\n\tstruct bnxt *bp = bnxt_get_bp_from_dl(dl);\n\tstruct hwrm_ver_get_output *ver_resp;\n\tchar mgmt_ver[FW_VER_STR_LEN];\n\tchar roce_ver[FW_VER_STR_LEN];\n\tchar ncsi_ver[FW_VER_STR_LEN];\n\tchar buf[32];\n\tu32 ver = 0;\n\tint rc;\n\n\tif (BNXT_PF(bp) && (bp->flags & BNXT_FLAG_DSN_VALID)) {\n\t\tsprintf(buf, \"%02X-%02X-%02X-%02X-%02X-%02X-%02X-%02X\",\n\t\t\tbp->dsn[7], bp->dsn[6], bp->dsn[5], bp->dsn[4],\n\t\t\tbp->dsn[3], bp->dsn[2], bp->dsn[1], bp->dsn[0]);\n\t\trc = devlink_info_serial_number_put(req, buf);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\tif (strlen(bp->board_serialno)) {\n\t\trc = devlink_info_board_serial_number_put(req, bp->board_serialno);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\trc = bnxt_dl_info_put(bp, req, BNXT_VERSION_FIXED,\n\t\t\t      DEVLINK_INFO_VERSION_GENERIC_BOARD_ID,\n\t\t\t      bp->board_partno);\n\tif (rc)\n\t\treturn rc;\n\n\tsprintf(buf, \"%X\", bp->chip_num);\n\trc = bnxt_dl_info_put(bp, req, BNXT_VERSION_FIXED,\n\t\t\t      DEVLINK_INFO_VERSION_GENERIC_ASIC_ID, buf);\n\tif (rc)\n\t\treturn rc;\n\n\tver_resp = &bp->ver_resp;\n\tsprintf(buf, \"%c%d\", 'A' + ver_resp->chip_rev, ver_resp->chip_metal);\n\trc = bnxt_dl_info_put(bp, req, BNXT_VERSION_FIXED,\n\t\t\t      DEVLINK_INFO_VERSION_GENERIC_ASIC_REV, buf);\n\tif (rc)\n\t\treturn rc;\n\n\trc = bnxt_dl_info_put(bp, req, BNXT_VERSION_RUNNING,\n\t\t\t      DEVLINK_INFO_VERSION_GENERIC_FW_PSID,\n\t\t\t      bp->nvm_cfg_ver);\n\tif (rc)\n\t\treturn rc;\n\n\tbuf[0] = 0;\n\tstrncat(buf, ver_resp->active_pkg_name, HWRM_FW_VER_STR_LEN);\n\trc = bnxt_dl_info_put(bp, req, BNXT_VERSION_RUNNING,\n\t\t\t      DEVLINK_INFO_VERSION_GENERIC_FW, buf);\n\tif (rc)\n\t\treturn rc;\n\n\tif (BNXT_PF(bp) && !bnxt_hwrm_get_nvm_cfg_ver(bp, &ver)) {\n\t\tsprintf(buf, \"%d.%d.%d\", (ver >> 16) & 0xff, (ver >> 8) & 0xff,\n\t\t\tver & 0xff);\n\t\trc = bnxt_dl_info_put(bp, req, BNXT_VERSION_STORED,\n\t\t\t\t      DEVLINK_INFO_VERSION_GENERIC_FW_PSID,\n\t\t\t\t      buf);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\tif (ver_resp->flags & VER_GET_RESP_FLAGS_EXT_VER_AVAIL) {\n\t\tsnprintf(mgmt_ver, FW_VER_STR_LEN, \"%d.%d.%d.%d\",\n\t\t\t ver_resp->hwrm_fw_major, ver_resp->hwrm_fw_minor,\n\t\t\t ver_resp->hwrm_fw_build, ver_resp->hwrm_fw_patch);\n\n\t\tsnprintf(ncsi_ver, FW_VER_STR_LEN, \"%d.%d.%d.%d\",\n\t\t\t ver_resp->mgmt_fw_major, ver_resp->mgmt_fw_minor,\n\t\t\t ver_resp->mgmt_fw_build, ver_resp->mgmt_fw_patch);\n\n\t\tsnprintf(roce_ver, FW_VER_STR_LEN, \"%d.%d.%d.%d\",\n\t\t\t ver_resp->roce_fw_major, ver_resp->roce_fw_minor,\n\t\t\t ver_resp->roce_fw_build, ver_resp->roce_fw_patch);\n\t} else {\n\t\tsnprintf(mgmt_ver, FW_VER_STR_LEN, \"%d.%d.%d.%d\",\n\t\t\t ver_resp->hwrm_fw_maj_8b, ver_resp->hwrm_fw_min_8b,\n\t\t\t ver_resp->hwrm_fw_bld_8b, ver_resp->hwrm_fw_rsvd_8b);\n\n\t\tsnprintf(ncsi_ver, FW_VER_STR_LEN, \"%d.%d.%d.%d\",\n\t\t\t ver_resp->mgmt_fw_maj_8b, ver_resp->mgmt_fw_min_8b,\n\t\t\t ver_resp->mgmt_fw_bld_8b, ver_resp->mgmt_fw_rsvd_8b);\n\n\t\tsnprintf(roce_ver, FW_VER_STR_LEN, \"%d.%d.%d.%d\",\n\t\t\t ver_resp->roce_fw_maj_8b, ver_resp->roce_fw_min_8b,\n\t\t\t ver_resp->roce_fw_bld_8b, ver_resp->roce_fw_rsvd_8b);\n\t}\n\trc = bnxt_dl_info_put(bp, req, BNXT_VERSION_RUNNING,\n\t\t\t      DEVLINK_INFO_VERSION_GENERIC_FW_MGMT, mgmt_ver);\n\tif (rc)\n\t\treturn rc;\n\n\trc = bnxt_dl_info_put(bp, req, BNXT_VERSION_RUNNING,\n\t\t\t      DEVLINK_INFO_VERSION_GENERIC_FW_MGMT_API,\n\t\t\t      bp->hwrm_ver_supp);\n\tif (rc)\n\t\treturn rc;\n\n\trc = bnxt_dl_info_put(bp, req, BNXT_VERSION_RUNNING,\n\t\t\t      DEVLINK_INFO_VERSION_GENERIC_FW_NCSI, ncsi_ver);\n\tif (rc)\n\t\treturn rc;\n\n\trc = bnxt_dl_info_put(bp, req, BNXT_VERSION_RUNNING,\n\t\t\t      DEVLINK_INFO_VERSION_GENERIC_FW_ROCE, roce_ver);\n\tif (rc)\n\t\treturn rc;\n\n\trc = bnxt_hwrm_nvm_get_dev_info(bp, &nvm_dev_info);\n\tif (rc ||\n\t    !(nvm_dev_info.flags & NVM_GET_DEV_INFO_RESP_FLAGS_FW_VER_VALID)) {\n\t\tif (!bnxt_get_pkginfo(bp->dev, buf, sizeof(buf)))\n\t\t\treturn bnxt_dl_info_put(bp, req, BNXT_VERSION_STORED,\n\t\t\t\t\t\tDEVLINK_INFO_VERSION_GENERIC_FW,\n\t\t\t\t\t\tbuf);\n\t\treturn 0;\n\t}\n\n\tbuf[0] = 0;\n\tstrncat(buf, nvm_dev_info.pkg_name, HWRM_FW_VER_STR_LEN);\n\trc = bnxt_dl_info_put(bp, req, BNXT_VERSION_STORED,\n\t\t\t      DEVLINK_INFO_VERSION_GENERIC_FW, buf);\n\tif (rc)\n\t\treturn rc;\n\n\tsnprintf(mgmt_ver, FW_VER_STR_LEN, \"%d.%d.%d.%d\",\n\t\t nvm_dev_info.hwrm_fw_major, nvm_dev_info.hwrm_fw_minor,\n\t\t nvm_dev_info.hwrm_fw_build, nvm_dev_info.hwrm_fw_patch);\n\trc = bnxt_dl_info_put(bp, req, BNXT_VERSION_STORED,\n\t\t\t      DEVLINK_INFO_VERSION_GENERIC_FW_MGMT, mgmt_ver);\n\tif (rc)\n\t\treturn rc;\n\n\tsnprintf(ncsi_ver, FW_VER_STR_LEN, \"%d.%d.%d.%d\",\n\t\t nvm_dev_info.mgmt_fw_major, nvm_dev_info.mgmt_fw_minor,\n\t\t nvm_dev_info.mgmt_fw_build, nvm_dev_info.mgmt_fw_patch);\n\trc = bnxt_dl_info_put(bp, req, BNXT_VERSION_STORED,\n\t\t\t      DEVLINK_INFO_VERSION_GENERIC_FW_NCSI, ncsi_ver);\n\tif (rc)\n\t\treturn rc;\n\n\tsnprintf(roce_ver, FW_VER_STR_LEN, \"%d.%d.%d.%d\",\n\t\t nvm_dev_info.roce_fw_major, nvm_dev_info.roce_fw_minor,\n\t\t nvm_dev_info.roce_fw_build, nvm_dev_info.roce_fw_patch);\n\trc = bnxt_dl_info_put(bp, req, BNXT_VERSION_STORED,\n\t\t\t      DEVLINK_INFO_VERSION_GENERIC_FW_ROCE, roce_ver);\n\tif (rc)\n\t\treturn rc;\n\n\tif (BNXT_CHIP_P5(bp)) {\n\t\trc = bnxt_dl_livepatch_info_put(bp, req, BNXT_FW_SRT_PATCH);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\treturn bnxt_dl_livepatch_info_put(bp, req, BNXT_FW_CRT_PATCH);\n\n}\n\nstatic int bnxt_hwrm_nvm_req(struct bnxt *bp, u32 param_id, void *msg,\n\t\t\t     union devlink_param_value *val)\n{\n\tstruct hwrm_nvm_get_variable_input *req = msg;\n\tstruct bnxt_dl_nvm_param nvm_param;\n\tstruct hwrm_err_output *resp;\n\tunion bnxt_nvm_data *data;\n\tdma_addr_t data_dma_addr;\n\tint idx = 0, rc, i;\n\n\t \n\tif (BNXT_VF(bp)) {\n\t\thwrm_req_drop(bp, req);\n\t\treturn -EPERM;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(nvm_params); i++) {\n\t\tif (nvm_params[i].id == param_id) {\n\t\t\tnvm_param = nvm_params[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i == ARRAY_SIZE(nvm_params)) {\n\t\thwrm_req_drop(bp, req);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (nvm_param.dir_type == BNXT_NVM_PORT_CFG)\n\t\tidx = bp->pf.port_id;\n\telse if (nvm_param.dir_type == BNXT_NVM_FUNC_CFG)\n\t\tidx = bp->pf.fw_fid - BNXT_FIRST_PF_FID;\n\n\tdata = hwrm_req_dma_slice(bp, req, sizeof(*data), &data_dma_addr);\n\n\tif (!data) {\n\t\thwrm_req_drop(bp, req);\n\t\treturn -ENOMEM;\n\t}\n\n\treq->dest_data_addr = cpu_to_le64(data_dma_addr);\n\treq->data_len = cpu_to_le16(nvm_param.nvm_num_bits);\n\treq->option_num = cpu_to_le16(nvm_param.offset);\n\treq->index_0 = cpu_to_le16(idx);\n\tif (idx)\n\t\treq->dimensions = cpu_to_le16(1);\n\n\tresp = hwrm_req_hold(bp, req);\n\tif (req->req_type == cpu_to_le16(HWRM_NVM_SET_VARIABLE)) {\n\t\tbnxt_copy_to_nvm_data(data, val, nvm_param.nvm_num_bits,\n\t\t\t\t      nvm_param.dl_num_bytes);\n\t\trc = hwrm_req_send(bp, msg);\n\t} else {\n\t\trc = hwrm_req_send_silent(bp, msg);\n\t\tif (!rc) {\n\t\t\tbnxt_copy_from_nvm_data(val, data,\n\t\t\t\t\t\tnvm_param.nvm_num_bits,\n\t\t\t\t\t\tnvm_param.dl_num_bytes);\n\t\t} else {\n\t\t\tif (resp->cmd_err ==\n\t\t\t\tNVM_GET_VARIABLE_CMD_ERR_CODE_VAR_NOT_EXIST)\n\t\t\t\trc = -EOPNOTSUPP;\n\t\t}\n\t}\n\thwrm_req_drop(bp, req);\n\tif (rc == -EACCES)\n\t\tnetdev_err(bp->dev, \"PF does not have admin privileges to modify NVM config\\n\");\n\treturn rc;\n}\n\nstatic int bnxt_dl_nvm_param_get(struct devlink *dl, u32 id,\n\t\t\t\t struct devlink_param_gset_ctx *ctx)\n{\n\tstruct bnxt *bp = bnxt_get_bp_from_dl(dl);\n\tstruct hwrm_nvm_get_variable_input *req;\n\tint rc;\n\n\trc = hwrm_req_init(bp, req, HWRM_NVM_GET_VARIABLE);\n\tif (rc)\n\t\treturn rc;\n\n\trc = bnxt_hwrm_nvm_req(bp, id, req, &ctx->val);\n\tif (!rc && id == BNXT_DEVLINK_PARAM_ID_GRE_VER_CHECK)\n\t\tctx->val.vbool = !ctx->val.vbool;\n\n\treturn rc;\n}\n\nstatic int bnxt_dl_nvm_param_set(struct devlink *dl, u32 id,\n\t\t\t\t struct devlink_param_gset_ctx *ctx)\n{\n\tstruct bnxt *bp = bnxt_get_bp_from_dl(dl);\n\tstruct hwrm_nvm_set_variable_input *req;\n\tint rc;\n\n\trc = hwrm_req_init(bp, req, HWRM_NVM_SET_VARIABLE);\n\tif (rc)\n\t\treturn rc;\n\n\tif (id == BNXT_DEVLINK_PARAM_ID_GRE_VER_CHECK)\n\t\tctx->val.vbool = !ctx->val.vbool;\n\n\treturn bnxt_hwrm_nvm_req(bp, id, req, &ctx->val);\n}\n\nstatic int bnxt_dl_msix_validate(struct devlink *dl, u32 id,\n\t\t\t\t union devlink_param_value val,\n\t\t\t\t struct netlink_ext_ack *extack)\n{\n\tint max_val = -1;\n\n\tif (id == DEVLINK_PARAM_GENERIC_ID_MSIX_VEC_PER_PF_MAX)\n\t\tmax_val = BNXT_MSIX_VEC_MAX;\n\n\tif (id == DEVLINK_PARAM_GENERIC_ID_MSIX_VEC_PER_PF_MIN)\n\t\tmax_val = BNXT_MSIX_VEC_MIN_MAX;\n\n\tif (val.vu32 > max_val) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"MSIX value is exceeding the range\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int bnxt_remote_dev_reset_get(struct devlink *dl, u32 id,\n\t\t\t\t     struct devlink_param_gset_ctx *ctx)\n{\n\tstruct bnxt *bp = bnxt_get_bp_from_dl(dl);\n\n\tif (~bp->fw_cap & BNXT_FW_CAP_HOT_RESET_IF)\n\t\treturn -EOPNOTSUPP;\n\n\tctx->val.vbool = bnxt_dl_get_remote_reset(dl);\n\treturn 0;\n}\n\nstatic int bnxt_remote_dev_reset_set(struct devlink *dl, u32 id,\n\t\t\t\t     struct devlink_param_gset_ctx *ctx)\n{\n\tstruct bnxt *bp = bnxt_get_bp_from_dl(dl);\n\tint rc;\n\n\trc = bnxt_hwrm_remote_dev_reset_set(bp, ctx->val.vbool);\n\tif (rc)\n\t\treturn rc;\n\n\tbnxt_dl_set_remote_reset(dl, ctx->val.vbool);\n\treturn rc;\n}\n\nstatic const struct devlink_param bnxt_dl_params[] = {\n\tDEVLINK_PARAM_GENERIC(ENABLE_SRIOV,\n\t\t\t      BIT(DEVLINK_PARAM_CMODE_PERMANENT),\n\t\t\t      bnxt_dl_nvm_param_get, bnxt_dl_nvm_param_set,\n\t\t\t      NULL),\n\tDEVLINK_PARAM_GENERIC(IGNORE_ARI,\n\t\t\t      BIT(DEVLINK_PARAM_CMODE_PERMANENT),\n\t\t\t      bnxt_dl_nvm_param_get, bnxt_dl_nvm_param_set,\n\t\t\t      NULL),\n\tDEVLINK_PARAM_GENERIC(MSIX_VEC_PER_PF_MAX,\n\t\t\t      BIT(DEVLINK_PARAM_CMODE_PERMANENT),\n\t\t\t      bnxt_dl_nvm_param_get, bnxt_dl_nvm_param_set,\n\t\t\t      bnxt_dl_msix_validate),\n\tDEVLINK_PARAM_GENERIC(MSIX_VEC_PER_PF_MIN,\n\t\t\t      BIT(DEVLINK_PARAM_CMODE_PERMANENT),\n\t\t\t      bnxt_dl_nvm_param_get, bnxt_dl_nvm_param_set,\n\t\t\t      bnxt_dl_msix_validate),\n\tDEVLINK_PARAM_DRIVER(BNXT_DEVLINK_PARAM_ID_GRE_VER_CHECK,\n\t\t\t     \"gre_ver_check\", DEVLINK_PARAM_TYPE_BOOL,\n\t\t\t     BIT(DEVLINK_PARAM_CMODE_PERMANENT),\n\t\t\t     bnxt_dl_nvm_param_get, bnxt_dl_nvm_param_set,\n\t\t\t     NULL),\n\t \n\tDEVLINK_PARAM_GENERIC(ENABLE_REMOTE_DEV_RESET,\n\t\t\t      BIT(DEVLINK_PARAM_CMODE_RUNTIME),\n\t\t\t      bnxt_remote_dev_reset_get,\n\t\t\t      bnxt_remote_dev_reset_set, NULL),\n};\n\nstatic int bnxt_dl_params_register(struct bnxt *bp)\n{\n\tint num_params = ARRAY_SIZE(bnxt_dl_params);\n\tint rc;\n\n\tif (bp->hwrm_spec_code < 0x10600)\n\t\treturn 0;\n\n\tif (~bp->fw_cap & BNXT_FW_CAP_HOT_RESET_IF)\n\t\tnum_params--;\n\n\trc = devlink_params_register(bp->dl, bnxt_dl_params, num_params);\n\tif (rc)\n\t\tnetdev_warn(bp->dev, \"devlink_params_register failed. rc=%d\\n\",\n\t\t\t    rc);\n\treturn rc;\n}\n\nstatic void bnxt_dl_params_unregister(struct bnxt *bp)\n{\n\tint num_params = ARRAY_SIZE(bnxt_dl_params);\n\n\tif (bp->hwrm_spec_code < 0x10600)\n\t\treturn;\n\n\tif (~bp->fw_cap & BNXT_FW_CAP_HOT_RESET_IF)\n\t\tnum_params--;\n\n\tdevlink_params_unregister(bp->dl, bnxt_dl_params, num_params);\n}\n\nint bnxt_dl_register(struct bnxt *bp)\n{\n\tconst struct devlink_ops *devlink_ops;\n\tstruct devlink_port_attrs attrs = {};\n\tstruct bnxt_dl *bp_dl;\n\tstruct devlink *dl;\n\tint rc;\n\n\tif (BNXT_PF(bp))\n\t\tdevlink_ops = &bnxt_dl_ops;\n\telse\n\t\tdevlink_ops = &bnxt_vf_dl_ops;\n\n\tdl = devlink_alloc(devlink_ops, sizeof(struct bnxt_dl), &bp->pdev->dev);\n\tif (!dl) {\n\t\tnetdev_warn(bp->dev, \"devlink_alloc failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tbp->dl = dl;\n\tbp_dl = devlink_priv(dl);\n\tbp_dl->bp = bp;\n\tbnxt_dl_set_remote_reset(dl, true);\n\n\t \n\tif (pci_find_ext_capability(bp->pdev, PCI_EXT_CAP_ID_SRIOV) &&\n\t    bp->hwrm_spec_code > 0x10803)\n\t\tbp->eswitch_mode = DEVLINK_ESWITCH_MODE_LEGACY;\n\n\tif (!BNXT_PF(bp))\n\t\tgoto out;\n\n\tattrs.flavour = DEVLINK_PORT_FLAVOUR_PHYSICAL;\n\tattrs.phys.port_number = bp->pf.port_id;\n\tmemcpy(attrs.switch_id.id, bp->dsn, sizeof(bp->dsn));\n\tattrs.switch_id.id_len = sizeof(bp->dsn);\n\tdevlink_port_attrs_set(&bp->dl_port, &attrs);\n\trc = devlink_port_register(dl, &bp->dl_port, bp->pf.port_id);\n\tif (rc) {\n\t\tnetdev_err(bp->dev, \"devlink_port_register failed\\n\");\n\t\tgoto err_dl_free;\n\t}\n\n\trc = bnxt_dl_params_register(bp);\n\tif (rc)\n\t\tgoto err_dl_port_unreg;\n\nout:\n\tdevlink_register(dl);\n\treturn 0;\n\nerr_dl_port_unreg:\n\tdevlink_port_unregister(&bp->dl_port);\nerr_dl_free:\n\tdevlink_free(dl);\n\treturn rc;\n}\n\nvoid bnxt_dl_unregister(struct bnxt *bp)\n{\n\tstruct devlink *dl = bp->dl;\n\n\tdevlink_unregister(dl);\n\tif (BNXT_PF(bp)) {\n\t\tbnxt_dl_params_unregister(bp);\n\t\tdevlink_port_unregister(&bp->dl_port);\n\t}\n\tdevlink_free(dl);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}