{
  "module_name": "bnxt.c",
  "hash_id": "831d29c98bc8f8492f18f652431e3fcf41e7511f637e57e5f33031c4a899834a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/broadcom/bnxt/bnxt.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n\n#include <linux/stringify.h>\n#include <linux/kernel.h>\n#include <linux/timer.h>\n#include <linux/errno.h>\n#include <linux/ioport.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/skbuff.h>\n#include <linux/dma-mapping.h>\n#include <linux/bitops.h>\n#include <linux/io.h>\n#include <linux/irq.h>\n#include <linux/delay.h>\n#include <asm/byteorder.h>\n#include <asm/page.h>\n#include <linux/time.h>\n#include <linux/mii.h>\n#include <linux/mdio.h>\n#include <linux/if.h>\n#include <linux/if_vlan.h>\n#include <linux/if_bridge.h>\n#include <linux/rtc.h>\n#include <linux/bpf.h>\n#include <net/gro.h>\n#include <net/ip.h>\n#include <net/tcp.h>\n#include <net/udp.h>\n#include <net/checksum.h>\n#include <net/ip6_checksum.h>\n#include <net/udp_tunnel.h>\n#include <linux/workqueue.h>\n#include <linux/prefetch.h>\n#include <linux/cache.h>\n#include <linux/log2.h>\n#include <linux/bitmap.h>\n#include <linux/cpu_rmap.h>\n#include <linux/cpumask.h>\n#include <net/pkt_cls.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <net/page_pool/helpers.h>\n#include <linux/align.h>\n#include <net/netdev_queues.h>\n\n#include \"bnxt_hsi.h\"\n#include \"bnxt.h\"\n#include \"bnxt_hwrm.h\"\n#include \"bnxt_ulp.h\"\n#include \"bnxt_sriov.h\"\n#include \"bnxt_ethtool.h\"\n#include \"bnxt_dcb.h\"\n#include \"bnxt_xdp.h\"\n#include \"bnxt_ptp.h\"\n#include \"bnxt_vfr.h\"\n#include \"bnxt_tc.h\"\n#include \"bnxt_devlink.h\"\n#include \"bnxt_debugfs.h\"\n\n#define BNXT_TX_TIMEOUT\t\t(5 * HZ)\n#define BNXT_DEF_MSG_ENABLE\t(NETIF_MSG_DRV | NETIF_MSG_HW | \\\n\t\t\t\t NETIF_MSG_TX_ERR)\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Broadcom BCM573xx network driver\");\n\n#define BNXT_RX_OFFSET (NET_SKB_PAD + NET_IP_ALIGN)\n#define BNXT_RX_DMA_OFFSET NET_SKB_PAD\n#define BNXT_RX_COPY_THRESH 256\n\n#define BNXT_TX_PUSH_THRESH 164\n\n \nstatic const struct {\n\tchar *name;\n} board_info[] = {\n\t[BCM57301] = { \"Broadcom BCM57301 NetXtreme-C 10Gb Ethernet\" },\n\t[BCM57302] = { \"Broadcom BCM57302 NetXtreme-C 10Gb/25Gb Ethernet\" },\n\t[BCM57304] = { \"Broadcom BCM57304 NetXtreme-C 10Gb/25Gb/40Gb/50Gb Ethernet\" },\n\t[BCM57417_NPAR] = { \"Broadcom BCM57417 NetXtreme-E Ethernet Partition\" },\n\t[BCM58700] = { \"Broadcom BCM58700 Nitro 1Gb/2.5Gb/10Gb Ethernet\" },\n\t[BCM57311] = { \"Broadcom BCM57311 NetXtreme-C 10Gb Ethernet\" },\n\t[BCM57312] = { \"Broadcom BCM57312 NetXtreme-C 10Gb/25Gb Ethernet\" },\n\t[BCM57402] = { \"Broadcom BCM57402 NetXtreme-E 10Gb Ethernet\" },\n\t[BCM57404] = { \"Broadcom BCM57404 NetXtreme-E 10Gb/25Gb Ethernet\" },\n\t[BCM57406] = { \"Broadcom BCM57406 NetXtreme-E 10GBase-T Ethernet\" },\n\t[BCM57402_NPAR] = { \"Broadcom BCM57402 NetXtreme-E Ethernet Partition\" },\n\t[BCM57407] = { \"Broadcom BCM57407 NetXtreme-E 10GBase-T Ethernet\" },\n\t[BCM57412] = { \"Broadcom BCM57412 NetXtreme-E 10Gb Ethernet\" },\n\t[BCM57414] = { \"Broadcom BCM57414 NetXtreme-E 10Gb/25Gb Ethernet\" },\n\t[BCM57416] = { \"Broadcom BCM57416 NetXtreme-E 10GBase-T Ethernet\" },\n\t[BCM57417] = { \"Broadcom BCM57417 NetXtreme-E 10GBase-T Ethernet\" },\n\t[BCM57412_NPAR] = { \"Broadcom BCM57412 NetXtreme-E Ethernet Partition\" },\n\t[BCM57314] = { \"Broadcom BCM57314 NetXtreme-C 10Gb/25Gb/40Gb/50Gb Ethernet\" },\n\t[BCM57417_SFP] = { \"Broadcom BCM57417 NetXtreme-E 10Gb/25Gb Ethernet\" },\n\t[BCM57416_SFP] = { \"Broadcom BCM57416 NetXtreme-E 10Gb Ethernet\" },\n\t[BCM57404_NPAR] = { \"Broadcom BCM57404 NetXtreme-E Ethernet Partition\" },\n\t[BCM57406_NPAR] = { \"Broadcom BCM57406 NetXtreme-E Ethernet Partition\" },\n\t[BCM57407_SFP] = { \"Broadcom BCM57407 NetXtreme-E 25Gb Ethernet\" },\n\t[BCM57407_NPAR] = { \"Broadcom BCM57407 NetXtreme-E Ethernet Partition\" },\n\t[BCM57414_NPAR] = { \"Broadcom BCM57414 NetXtreme-E Ethernet Partition\" },\n\t[BCM57416_NPAR] = { \"Broadcom BCM57416 NetXtreme-E Ethernet Partition\" },\n\t[BCM57452] = { \"Broadcom BCM57452 NetXtreme-E 10Gb/25Gb/40Gb/50Gb Ethernet\" },\n\t[BCM57454] = { \"Broadcom BCM57454 NetXtreme-E 10Gb/25Gb/40Gb/50Gb/100Gb Ethernet\" },\n\t[BCM5745x_NPAR] = { \"Broadcom BCM5745x NetXtreme-E Ethernet Partition\" },\n\t[BCM57508] = { \"Broadcom BCM57508 NetXtreme-E 10Gb/25Gb/50Gb/100Gb/200Gb Ethernet\" },\n\t[BCM57504] = { \"Broadcom BCM57504 NetXtreme-E 10Gb/25Gb/50Gb/100Gb/200Gb Ethernet\" },\n\t[BCM57502] = { \"Broadcom BCM57502 NetXtreme-E 10Gb/25Gb/50Gb Ethernet\" },\n\t[BCM57508_NPAR] = { \"Broadcom BCM57508 NetXtreme-E Ethernet Partition\" },\n\t[BCM57504_NPAR] = { \"Broadcom BCM57504 NetXtreme-E Ethernet Partition\" },\n\t[BCM57502_NPAR] = { \"Broadcom BCM57502 NetXtreme-E Ethernet Partition\" },\n\t[BCM58802] = { \"Broadcom BCM58802 NetXtreme-S 10Gb/25Gb/40Gb/50Gb Ethernet\" },\n\t[BCM58804] = { \"Broadcom BCM58804 NetXtreme-S 10Gb/25Gb/40Gb/50Gb/100Gb Ethernet\" },\n\t[BCM58808] = { \"Broadcom BCM58808 NetXtreme-S 10Gb/25Gb/40Gb/50Gb/100Gb Ethernet\" },\n\t[NETXTREME_E_VF] = { \"Broadcom NetXtreme-E Ethernet Virtual Function\" },\n\t[NETXTREME_C_VF] = { \"Broadcom NetXtreme-C Ethernet Virtual Function\" },\n\t[NETXTREME_S_VF] = { \"Broadcom NetXtreme-S Ethernet Virtual Function\" },\n\t[NETXTREME_C_VF_HV] = { \"Broadcom NetXtreme-C Virtual Function for Hyper-V\" },\n\t[NETXTREME_E_VF_HV] = { \"Broadcom NetXtreme-E Virtual Function for Hyper-V\" },\n\t[NETXTREME_E_P5_VF] = { \"Broadcom BCM5750X NetXtreme-E Ethernet Virtual Function\" },\n\t[NETXTREME_E_P5_VF_HV] = { \"Broadcom BCM5750X NetXtreme-E Virtual Function for Hyper-V\" },\n};\n\nstatic const struct pci_device_id bnxt_pci_tbl[] = {\n\t{ PCI_VDEVICE(BROADCOM, 0x1604), .driver_data = BCM5745x_NPAR },\n\t{ PCI_VDEVICE(BROADCOM, 0x1605), .driver_data = BCM5745x_NPAR },\n\t{ PCI_VDEVICE(BROADCOM, 0x1614), .driver_data = BCM57454 },\n\t{ PCI_VDEVICE(BROADCOM, 0x16c0), .driver_data = BCM57417_NPAR },\n\t{ PCI_VDEVICE(BROADCOM, 0x16c8), .driver_data = BCM57301 },\n\t{ PCI_VDEVICE(BROADCOM, 0x16c9), .driver_data = BCM57302 },\n\t{ PCI_VDEVICE(BROADCOM, 0x16ca), .driver_data = BCM57304 },\n\t{ PCI_VDEVICE(BROADCOM, 0x16cc), .driver_data = BCM57417_NPAR },\n\t{ PCI_VDEVICE(BROADCOM, 0x16cd), .driver_data = BCM58700 },\n\t{ PCI_VDEVICE(BROADCOM, 0x16ce), .driver_data = BCM57311 },\n\t{ PCI_VDEVICE(BROADCOM, 0x16cf), .driver_data = BCM57312 },\n\t{ PCI_VDEVICE(BROADCOM, 0x16d0), .driver_data = BCM57402 },\n\t{ PCI_VDEVICE(BROADCOM, 0x16d1), .driver_data = BCM57404 },\n\t{ PCI_VDEVICE(BROADCOM, 0x16d2), .driver_data = BCM57406 },\n\t{ PCI_VDEVICE(BROADCOM, 0x16d4), .driver_data = BCM57402_NPAR },\n\t{ PCI_VDEVICE(BROADCOM, 0x16d5), .driver_data = BCM57407 },\n\t{ PCI_VDEVICE(BROADCOM, 0x16d6), .driver_data = BCM57412 },\n\t{ PCI_VDEVICE(BROADCOM, 0x16d7), .driver_data = BCM57414 },\n\t{ PCI_VDEVICE(BROADCOM, 0x16d8), .driver_data = BCM57416 },\n\t{ PCI_VDEVICE(BROADCOM, 0x16d9), .driver_data = BCM57417 },\n\t{ PCI_VDEVICE(BROADCOM, 0x16de), .driver_data = BCM57412_NPAR },\n\t{ PCI_VDEVICE(BROADCOM, 0x16df), .driver_data = BCM57314 },\n\t{ PCI_VDEVICE(BROADCOM, 0x16e2), .driver_data = BCM57417_SFP },\n\t{ PCI_VDEVICE(BROADCOM, 0x16e3), .driver_data = BCM57416_SFP },\n\t{ PCI_VDEVICE(BROADCOM, 0x16e7), .driver_data = BCM57404_NPAR },\n\t{ PCI_VDEVICE(BROADCOM, 0x16e8), .driver_data = BCM57406_NPAR },\n\t{ PCI_VDEVICE(BROADCOM, 0x16e9), .driver_data = BCM57407_SFP },\n\t{ PCI_VDEVICE(BROADCOM, 0x16ea), .driver_data = BCM57407_NPAR },\n\t{ PCI_VDEVICE(BROADCOM, 0x16eb), .driver_data = BCM57412_NPAR },\n\t{ PCI_VDEVICE(BROADCOM, 0x16ec), .driver_data = BCM57414_NPAR },\n\t{ PCI_VDEVICE(BROADCOM, 0x16ed), .driver_data = BCM57414_NPAR },\n\t{ PCI_VDEVICE(BROADCOM, 0x16ee), .driver_data = BCM57416_NPAR },\n\t{ PCI_VDEVICE(BROADCOM, 0x16ef), .driver_data = BCM57416_NPAR },\n\t{ PCI_VDEVICE(BROADCOM, 0x16f0), .driver_data = BCM58808 },\n\t{ PCI_VDEVICE(BROADCOM, 0x16f1), .driver_data = BCM57452 },\n\t{ PCI_VDEVICE(BROADCOM, 0x1750), .driver_data = BCM57508 },\n\t{ PCI_VDEVICE(BROADCOM, 0x1751), .driver_data = BCM57504 },\n\t{ PCI_VDEVICE(BROADCOM, 0x1752), .driver_data = BCM57502 },\n\t{ PCI_VDEVICE(BROADCOM, 0x1800), .driver_data = BCM57502_NPAR },\n\t{ PCI_VDEVICE(BROADCOM, 0x1801), .driver_data = BCM57504_NPAR },\n\t{ PCI_VDEVICE(BROADCOM, 0x1802), .driver_data = BCM57508_NPAR },\n\t{ PCI_VDEVICE(BROADCOM, 0x1803), .driver_data = BCM57502_NPAR },\n\t{ PCI_VDEVICE(BROADCOM, 0x1804), .driver_data = BCM57504_NPAR },\n\t{ PCI_VDEVICE(BROADCOM, 0x1805), .driver_data = BCM57508_NPAR },\n\t{ PCI_VDEVICE(BROADCOM, 0xd802), .driver_data = BCM58802 },\n\t{ PCI_VDEVICE(BROADCOM, 0xd804), .driver_data = BCM58804 },\n#ifdef CONFIG_BNXT_SRIOV\n\t{ PCI_VDEVICE(BROADCOM, 0x1606), .driver_data = NETXTREME_E_VF },\n\t{ PCI_VDEVICE(BROADCOM, 0x1607), .driver_data = NETXTREME_E_VF_HV },\n\t{ PCI_VDEVICE(BROADCOM, 0x1608), .driver_data = NETXTREME_E_VF_HV },\n\t{ PCI_VDEVICE(BROADCOM, 0x1609), .driver_data = NETXTREME_E_VF },\n\t{ PCI_VDEVICE(BROADCOM, 0x16bd), .driver_data = NETXTREME_E_VF_HV },\n\t{ PCI_VDEVICE(BROADCOM, 0x16c1), .driver_data = NETXTREME_E_VF },\n\t{ PCI_VDEVICE(BROADCOM, 0x16c2), .driver_data = NETXTREME_C_VF_HV },\n\t{ PCI_VDEVICE(BROADCOM, 0x16c3), .driver_data = NETXTREME_C_VF_HV },\n\t{ PCI_VDEVICE(BROADCOM, 0x16c4), .driver_data = NETXTREME_E_VF_HV },\n\t{ PCI_VDEVICE(BROADCOM, 0x16c5), .driver_data = NETXTREME_E_VF_HV },\n\t{ PCI_VDEVICE(BROADCOM, 0x16cb), .driver_data = NETXTREME_C_VF },\n\t{ PCI_VDEVICE(BROADCOM, 0x16d3), .driver_data = NETXTREME_E_VF },\n\t{ PCI_VDEVICE(BROADCOM, 0x16dc), .driver_data = NETXTREME_E_VF },\n\t{ PCI_VDEVICE(BROADCOM, 0x16e1), .driver_data = NETXTREME_C_VF },\n\t{ PCI_VDEVICE(BROADCOM, 0x16e5), .driver_data = NETXTREME_C_VF },\n\t{ PCI_VDEVICE(BROADCOM, 0x16e6), .driver_data = NETXTREME_C_VF_HV },\n\t{ PCI_VDEVICE(BROADCOM, 0x1806), .driver_data = NETXTREME_E_P5_VF },\n\t{ PCI_VDEVICE(BROADCOM, 0x1807), .driver_data = NETXTREME_E_P5_VF },\n\t{ PCI_VDEVICE(BROADCOM, 0x1808), .driver_data = NETXTREME_E_P5_VF_HV },\n\t{ PCI_VDEVICE(BROADCOM, 0x1809), .driver_data = NETXTREME_E_P5_VF_HV },\n\t{ PCI_VDEVICE(BROADCOM, 0xd800), .driver_data = NETXTREME_S_VF },\n#endif\n\t{ 0 }\n};\n\nMODULE_DEVICE_TABLE(pci, bnxt_pci_tbl);\n\nstatic const u16 bnxt_vf_req_snif[] = {\n\tHWRM_FUNC_CFG,\n\tHWRM_FUNC_VF_CFG,\n\tHWRM_PORT_PHY_QCFG,\n\tHWRM_CFA_L2_FILTER_ALLOC,\n};\n\nstatic const u16 bnxt_async_events_arr[] = {\n\tASYNC_EVENT_CMPL_EVENT_ID_LINK_STATUS_CHANGE,\n\tASYNC_EVENT_CMPL_EVENT_ID_LINK_SPEED_CHANGE,\n\tASYNC_EVENT_CMPL_EVENT_ID_PF_DRVR_UNLOAD,\n\tASYNC_EVENT_CMPL_EVENT_ID_PORT_CONN_NOT_ALLOWED,\n\tASYNC_EVENT_CMPL_EVENT_ID_VF_CFG_CHANGE,\n\tASYNC_EVENT_CMPL_EVENT_ID_LINK_SPEED_CFG_CHANGE,\n\tASYNC_EVENT_CMPL_EVENT_ID_PORT_PHY_CFG_CHANGE,\n\tASYNC_EVENT_CMPL_EVENT_ID_RESET_NOTIFY,\n\tASYNC_EVENT_CMPL_EVENT_ID_ERROR_RECOVERY,\n\tASYNC_EVENT_CMPL_EVENT_ID_DEBUG_NOTIFICATION,\n\tASYNC_EVENT_CMPL_EVENT_ID_DEFERRED_RESPONSE,\n\tASYNC_EVENT_CMPL_EVENT_ID_RING_MONITOR_MSG,\n\tASYNC_EVENT_CMPL_EVENT_ID_ECHO_REQUEST,\n\tASYNC_EVENT_CMPL_EVENT_ID_PPS_TIMESTAMP,\n\tASYNC_EVENT_CMPL_EVENT_ID_ERROR_REPORT,\n\tASYNC_EVENT_CMPL_EVENT_ID_PHC_UPDATE,\n};\n\nstatic struct workqueue_struct *bnxt_pf_wq;\n\nstatic bool bnxt_vf_pciid(enum board_idx idx)\n{\n\treturn (idx == NETXTREME_C_VF || idx == NETXTREME_E_VF ||\n\t\tidx == NETXTREME_S_VF || idx == NETXTREME_C_VF_HV ||\n\t\tidx == NETXTREME_E_VF_HV || idx == NETXTREME_E_P5_VF ||\n\t\tidx == NETXTREME_E_P5_VF_HV);\n}\n\n#define DB_CP_REARM_FLAGS\t(DB_KEY_CP | DB_IDX_VALID)\n#define DB_CP_FLAGS\t\t(DB_KEY_CP | DB_IDX_VALID | DB_IRQ_DIS)\n#define DB_CP_IRQ_DIS_FLAGS\t(DB_KEY_CP | DB_IRQ_DIS)\n\n#define BNXT_CP_DB_IRQ_DIS(db)\t\t\t\t\t\t\\\n\t\twritel(DB_CP_IRQ_DIS_FLAGS, db)\n\n#define BNXT_DB_CQ(db, idx)\t\t\t\t\t\t\\\n\twritel(DB_CP_FLAGS | RING_CMP(idx), (db)->doorbell)\n\n#define BNXT_DB_NQ_P5(db, idx)\t\t\t\t\t\t\\\n\tbnxt_writeq(bp, (db)->db_key64 | DBR_TYPE_NQ | RING_CMP(idx),\t\\\n\t\t    (db)->doorbell)\n\n#define BNXT_DB_CQ_ARM(db, idx)\t\t\t\t\t\t\\\n\twritel(DB_CP_REARM_FLAGS | RING_CMP(idx), (db)->doorbell)\n\n#define BNXT_DB_NQ_ARM_P5(db, idx)\t\t\t\t\t\\\n\tbnxt_writeq(bp, (db)->db_key64 | DBR_TYPE_NQ_ARM | RING_CMP(idx),\\\n\t\t    (db)->doorbell)\n\nstatic void bnxt_db_nq(struct bnxt *bp, struct bnxt_db_info *db, u32 idx)\n{\n\tif (bp->flags & BNXT_FLAG_CHIP_P5)\n\t\tBNXT_DB_NQ_P5(db, idx);\n\telse\n\t\tBNXT_DB_CQ(db, idx);\n}\n\nstatic void bnxt_db_nq_arm(struct bnxt *bp, struct bnxt_db_info *db, u32 idx)\n{\n\tif (bp->flags & BNXT_FLAG_CHIP_P5)\n\t\tBNXT_DB_NQ_ARM_P5(db, idx);\n\telse\n\t\tBNXT_DB_CQ_ARM(db, idx);\n}\n\nstatic void bnxt_db_cq(struct bnxt *bp, struct bnxt_db_info *db, u32 idx)\n{\n\tif (bp->flags & BNXT_FLAG_CHIP_P5)\n\t\tbnxt_writeq(bp, db->db_key64 | DBR_TYPE_CQ_ARMALL |\n\t\t\t    RING_CMP(idx), db->doorbell);\n\telse\n\t\tBNXT_DB_CQ(db, idx);\n}\n\nstatic void bnxt_queue_fw_reset_work(struct bnxt *bp, unsigned long delay)\n{\n\tif (!(test_bit(BNXT_STATE_IN_FW_RESET, &bp->state)))\n\t\treturn;\n\n\tif (BNXT_PF(bp))\n\t\tqueue_delayed_work(bnxt_pf_wq, &bp->fw_reset_task, delay);\n\telse\n\t\tschedule_delayed_work(&bp->fw_reset_task, delay);\n}\n\nstatic void __bnxt_queue_sp_work(struct bnxt *bp)\n{\n\tif (BNXT_PF(bp))\n\t\tqueue_work(bnxt_pf_wq, &bp->sp_task);\n\telse\n\t\tschedule_work(&bp->sp_task);\n}\n\nstatic void bnxt_queue_sp_work(struct bnxt *bp, unsigned int event)\n{\n\tset_bit(event, &bp->sp_event);\n\t__bnxt_queue_sp_work(bp);\n}\n\nstatic void bnxt_sched_reset_rxr(struct bnxt *bp, struct bnxt_rx_ring_info *rxr)\n{\n\tif (!rxr->bnapi->in_reset) {\n\t\trxr->bnapi->in_reset = true;\n\t\tif (bp->flags & BNXT_FLAG_CHIP_P5)\n\t\t\tset_bit(BNXT_RESET_TASK_SP_EVENT, &bp->sp_event);\n\t\telse\n\t\t\tset_bit(BNXT_RST_RING_SP_EVENT, &bp->sp_event);\n\t\t__bnxt_queue_sp_work(bp);\n\t}\n\trxr->rx_next_cons = 0xffff;\n}\n\nvoid bnxt_sched_reset_txr(struct bnxt *bp, struct bnxt_tx_ring_info *txr,\n\t\t\t  int idx)\n{\n\tstruct bnxt_napi *bnapi = txr->bnapi;\n\n\tif (bnapi->tx_fault)\n\t\treturn;\n\n\tnetdev_err(bp->dev, \"Invalid Tx completion (ring:%d tx_pkts:%d cons:%u prod:%u i:%d)\",\n\t\t   txr->txq_index, bnapi->tx_pkts,\n\t\t   txr->tx_cons, txr->tx_prod, idx);\n\tWARN_ON_ONCE(1);\n\tbnapi->tx_fault = 1;\n\tbnxt_queue_sp_work(bp, BNXT_RESET_TASK_SP_EVENT);\n}\n\nconst u16 bnxt_lhint_arr[] = {\n\tTX_BD_FLAGS_LHINT_512_AND_SMALLER,\n\tTX_BD_FLAGS_LHINT_512_TO_1023,\n\tTX_BD_FLAGS_LHINT_1024_TO_2047,\n\tTX_BD_FLAGS_LHINT_1024_TO_2047,\n\tTX_BD_FLAGS_LHINT_2048_AND_LARGER,\n\tTX_BD_FLAGS_LHINT_2048_AND_LARGER,\n\tTX_BD_FLAGS_LHINT_2048_AND_LARGER,\n\tTX_BD_FLAGS_LHINT_2048_AND_LARGER,\n\tTX_BD_FLAGS_LHINT_2048_AND_LARGER,\n\tTX_BD_FLAGS_LHINT_2048_AND_LARGER,\n\tTX_BD_FLAGS_LHINT_2048_AND_LARGER,\n\tTX_BD_FLAGS_LHINT_2048_AND_LARGER,\n\tTX_BD_FLAGS_LHINT_2048_AND_LARGER,\n\tTX_BD_FLAGS_LHINT_2048_AND_LARGER,\n\tTX_BD_FLAGS_LHINT_2048_AND_LARGER,\n\tTX_BD_FLAGS_LHINT_2048_AND_LARGER,\n\tTX_BD_FLAGS_LHINT_2048_AND_LARGER,\n\tTX_BD_FLAGS_LHINT_2048_AND_LARGER,\n\tTX_BD_FLAGS_LHINT_2048_AND_LARGER,\n};\n\nstatic u16 bnxt_xmit_get_cfa_action(struct sk_buff *skb)\n{\n\tstruct metadata_dst *md_dst = skb_metadata_dst(skb);\n\n\tif (!md_dst || md_dst->type != METADATA_HW_PORT_MUX)\n\t\treturn 0;\n\n\treturn md_dst->u.port_info.port_id;\n}\n\nstatic void bnxt_txr_db_kick(struct bnxt *bp, struct bnxt_tx_ring_info *txr,\n\t\t\t     u16 prod)\n{\n\tbnxt_db_write(bp, &txr->tx_db, prod);\n\ttxr->kick_pending = 0;\n}\n\nstatic netdev_tx_t bnxt_start_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct bnxt *bp = netdev_priv(dev);\n\tstruct tx_bd *txbd;\n\tstruct tx_bd_ext *txbd1;\n\tstruct netdev_queue *txq;\n\tint i;\n\tdma_addr_t mapping;\n\tunsigned int length, pad = 0;\n\tu32 len, free_size, vlan_tag_flags, cfa_action, flags;\n\tu16 prod, last_frag;\n\tstruct pci_dev *pdev = bp->pdev;\n\tstruct bnxt_tx_ring_info *txr;\n\tstruct bnxt_sw_tx_bd *tx_buf;\n\t__le32 lflags = 0;\n\n\ti = skb_get_queue_mapping(skb);\n\tif (unlikely(i >= bp->tx_nr_rings)) {\n\t\tdev_kfree_skb_any(skb);\n\t\tdev_core_stats_tx_dropped_inc(dev);\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\ttxq = netdev_get_tx_queue(dev, i);\n\ttxr = &bp->tx_ring[bp->tx_ring_map[i]];\n\tprod = txr->tx_prod;\n\n\tfree_size = bnxt_tx_avail(bp, txr);\n\tif (unlikely(free_size < skb_shinfo(skb)->nr_frags + 2)) {\n\t\t \n\t\tif (net_ratelimit() && txr->kick_pending)\n\t\t\tnetif_warn(bp, tx_err, dev,\n\t\t\t\t   \"bnxt: ring busy w/ flush pending!\\n\");\n\t\tif (!netif_txq_try_stop(txq, bnxt_tx_avail(bp, txr),\n\t\t\t\t\tbp->tx_wake_thresh))\n\t\t\treturn NETDEV_TX_BUSY;\n\t}\n\n\tif (unlikely(ipv6_hopopt_jumbo_remove(skb)))\n\t\tgoto tx_free;\n\n\tlength = skb->len;\n\tlen = skb_headlen(skb);\n\tlast_frag = skb_shinfo(skb)->nr_frags;\n\n\ttxbd = &txr->tx_desc_ring[TX_RING(prod)][TX_IDX(prod)];\n\n\ttxbd->tx_bd_opaque = prod;\n\n\ttx_buf = &txr->tx_buf_ring[prod];\n\ttx_buf->skb = skb;\n\ttx_buf->nr_frags = last_frag;\n\n\tvlan_tag_flags = 0;\n\tcfa_action = bnxt_xmit_get_cfa_action(skb);\n\tif (skb_vlan_tag_present(skb)) {\n\t\tvlan_tag_flags = TX_BD_CFA_META_KEY_VLAN |\n\t\t\t\t skb_vlan_tag_get(skb);\n\t\t \n\t\tif (skb->vlan_proto == htons(ETH_P_8021Q))\n\t\t\tvlan_tag_flags |= 1 << TX_BD_CFA_META_TPID_SHIFT;\n\t}\n\n\tif (unlikely(skb_shinfo(skb)->tx_flags & SKBTX_HW_TSTAMP)) {\n\t\tstruct bnxt_ptp_cfg *ptp = bp->ptp_cfg;\n\n\t\tif (ptp && ptp->tx_tstamp_en && !skb_is_gso(skb) &&\n\t\t    atomic_dec_if_positive(&ptp->tx_avail) >= 0) {\n\t\t\tif (!bnxt_ptp_parse(skb, &ptp->tx_seqid,\n\t\t\t\t\t    &ptp->tx_hdr_off)) {\n\t\t\t\tif (vlan_tag_flags)\n\t\t\t\t\tptp->tx_hdr_off += VLAN_HLEN;\n\t\t\t\tlflags |= cpu_to_le32(TX_BD_FLAGS_STAMP);\n\t\t\t\tskb_shinfo(skb)->tx_flags |= SKBTX_IN_PROGRESS;\n\t\t\t} else {\n\t\t\t\tatomic_inc(&bp->ptp_cfg->tx_avail);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (unlikely(skb->no_fcs))\n\t\tlflags |= cpu_to_le32(TX_BD_FLAGS_NO_CRC);\n\n\tif (free_size == bp->tx_ring_size && length <= bp->tx_push_thresh &&\n\t    !lflags) {\n\t\tstruct tx_push_buffer *tx_push_buf = txr->tx_push;\n\t\tstruct tx_push_bd *tx_push = &tx_push_buf->push_bd;\n\t\tstruct tx_bd_ext *tx_push1 = &tx_push->txbd2;\n\t\tvoid __iomem *db = txr->tx_db.doorbell;\n\t\tvoid *pdata = tx_push_buf->data;\n\t\tu64 *end;\n\t\tint j, push_len;\n\n\t\t \n\t\ttx_push->tx_bd_len_flags_type =\n\t\t\tcpu_to_le32((length << TX_BD_LEN_SHIFT) |\n\t\t\t\t\tTX_BD_TYPE_LONG_TX_BD |\n\t\t\t\t\tTX_BD_FLAGS_LHINT_512_AND_SMALLER |\n\t\t\t\t\tTX_BD_FLAGS_COAL_NOW |\n\t\t\t\t\tTX_BD_FLAGS_PACKET_END |\n\t\t\t\t\t(2 << TX_BD_FLAGS_BD_CNT_SHIFT));\n\n\t\tif (skb->ip_summed == CHECKSUM_PARTIAL)\n\t\t\ttx_push1->tx_bd_hsize_lflags =\n\t\t\t\t\tcpu_to_le32(TX_BD_FLAGS_TCP_UDP_CHKSUM);\n\t\telse\n\t\t\ttx_push1->tx_bd_hsize_lflags = 0;\n\n\t\ttx_push1->tx_bd_cfa_meta = cpu_to_le32(vlan_tag_flags);\n\t\ttx_push1->tx_bd_cfa_action =\n\t\t\tcpu_to_le32(cfa_action << TX_BD_CFA_ACTION_SHIFT);\n\n\t\tend = pdata + length;\n\t\tend = PTR_ALIGN(end, 8) - 1;\n\t\t*end = 0;\n\n\t\tskb_copy_from_linear_data(skb, pdata, len);\n\t\tpdata += len;\n\t\tfor (j = 0; j < last_frag; j++) {\n\t\t\tskb_frag_t *frag = &skb_shinfo(skb)->frags[j];\n\t\t\tvoid *fptr;\n\n\t\t\tfptr = skb_frag_address_safe(frag);\n\t\t\tif (!fptr)\n\t\t\t\tgoto normal_tx;\n\n\t\t\tmemcpy(pdata, fptr, skb_frag_size(frag));\n\t\t\tpdata += skb_frag_size(frag);\n\t\t}\n\n\t\ttxbd->tx_bd_len_flags_type = tx_push->tx_bd_len_flags_type;\n\t\ttxbd->tx_bd_haddr = txr->data_mapping;\n\t\tprod = NEXT_TX(prod);\n\t\ttxbd = &txr->tx_desc_ring[TX_RING(prod)][TX_IDX(prod)];\n\t\tmemcpy(txbd, tx_push1, sizeof(*txbd));\n\t\tprod = NEXT_TX(prod);\n\t\ttx_push->doorbell =\n\t\t\tcpu_to_le32(DB_KEY_TX_PUSH | DB_LONG_TX_PUSH | prod);\n\t\tWRITE_ONCE(txr->tx_prod, prod);\n\n\t\ttx_buf->is_push = 1;\n\t\tnetdev_tx_sent_queue(txq, skb->len);\n\t\twmb();\t \n\n\t\tpush_len = (length + sizeof(*tx_push) + 7) / 8;\n\t\tif (push_len > 16) {\n\t\t\t__iowrite64_copy(db, tx_push_buf, 16);\n\t\t\t__iowrite32_copy(db + 4, tx_push_buf + 1,\n\t\t\t\t\t (push_len - 16) << 1);\n\t\t} else {\n\t\t\t__iowrite64_copy(db, tx_push_buf, push_len);\n\t\t}\n\n\t\tgoto tx_done;\n\t}\n\nnormal_tx:\n\tif (length < BNXT_MIN_PKT_SIZE) {\n\t\tpad = BNXT_MIN_PKT_SIZE - length;\n\t\tif (skb_pad(skb, pad))\n\t\t\t \n\t\t\tgoto tx_kick_pending;\n\t\tlength = BNXT_MIN_PKT_SIZE;\n\t}\n\n\tmapping = dma_map_single(&pdev->dev, skb->data, len, DMA_TO_DEVICE);\n\n\tif (unlikely(dma_mapping_error(&pdev->dev, mapping)))\n\t\tgoto tx_free;\n\n\tdma_unmap_addr_set(tx_buf, mapping, mapping);\n\tflags = (len << TX_BD_LEN_SHIFT) | TX_BD_TYPE_LONG_TX_BD |\n\t\t((last_frag + 2) << TX_BD_FLAGS_BD_CNT_SHIFT);\n\n\ttxbd->tx_bd_haddr = cpu_to_le64(mapping);\n\n\tprod = NEXT_TX(prod);\n\ttxbd1 = (struct tx_bd_ext *)\n\t\t&txr->tx_desc_ring[TX_RING(prod)][TX_IDX(prod)];\n\n\ttxbd1->tx_bd_hsize_lflags = lflags;\n\tif (skb_is_gso(skb)) {\n\t\tu32 hdr_len;\n\n\t\tif (skb->encapsulation)\n\t\t\thdr_len = skb_inner_tcp_all_headers(skb);\n\t\telse\n\t\t\thdr_len = skb_tcp_all_headers(skb);\n\n\t\ttxbd1->tx_bd_hsize_lflags |= cpu_to_le32(TX_BD_FLAGS_LSO |\n\t\t\t\t\tTX_BD_FLAGS_T_IPID |\n\t\t\t\t\t(hdr_len << (TX_BD_HSIZE_SHIFT - 1)));\n\t\tlength = skb_shinfo(skb)->gso_size;\n\t\ttxbd1->tx_bd_mss = cpu_to_le32(length);\n\t\tlength += hdr_len;\n\t} else if (skb->ip_summed == CHECKSUM_PARTIAL) {\n\t\ttxbd1->tx_bd_hsize_lflags |=\n\t\t\tcpu_to_le32(TX_BD_FLAGS_TCP_UDP_CHKSUM);\n\t\ttxbd1->tx_bd_mss = 0;\n\t}\n\n\tlength >>= 9;\n\tif (unlikely(length >= ARRAY_SIZE(bnxt_lhint_arr))) {\n\t\tdev_warn_ratelimited(&pdev->dev, \"Dropped oversize %d bytes TX packet.\\n\",\n\t\t\t\t     skb->len);\n\t\ti = 0;\n\t\tgoto tx_dma_error;\n\t}\n\tflags |= bnxt_lhint_arr[length];\n\ttxbd->tx_bd_len_flags_type = cpu_to_le32(flags);\n\n\ttxbd1->tx_bd_cfa_meta = cpu_to_le32(vlan_tag_flags);\n\ttxbd1->tx_bd_cfa_action =\n\t\t\tcpu_to_le32(cfa_action << TX_BD_CFA_ACTION_SHIFT);\n\tfor (i = 0; i < last_frag; i++) {\n\t\tskb_frag_t *frag = &skb_shinfo(skb)->frags[i];\n\n\t\tprod = NEXT_TX(prod);\n\t\ttxbd = &txr->tx_desc_ring[TX_RING(prod)][TX_IDX(prod)];\n\n\t\tlen = skb_frag_size(frag);\n\t\tmapping = skb_frag_dma_map(&pdev->dev, frag, 0, len,\n\t\t\t\t\t   DMA_TO_DEVICE);\n\n\t\tif (unlikely(dma_mapping_error(&pdev->dev, mapping)))\n\t\t\tgoto tx_dma_error;\n\n\t\ttx_buf = &txr->tx_buf_ring[prod];\n\t\tdma_unmap_addr_set(tx_buf, mapping, mapping);\n\n\t\ttxbd->tx_bd_haddr = cpu_to_le64(mapping);\n\n\t\tflags = len << TX_BD_LEN_SHIFT;\n\t\ttxbd->tx_bd_len_flags_type = cpu_to_le32(flags);\n\t}\n\n\tflags &= ~TX_BD_LEN;\n\ttxbd->tx_bd_len_flags_type =\n\t\tcpu_to_le32(((len + pad) << TX_BD_LEN_SHIFT) | flags |\n\t\t\t    TX_BD_FLAGS_PACKET_END);\n\n\tnetdev_tx_sent_queue(txq, skb->len);\n\n\tskb_tx_timestamp(skb);\n\n\t \n\twmb();\n\n\tprod = NEXT_TX(prod);\n\tWRITE_ONCE(txr->tx_prod, prod);\n\n\tif (!netdev_xmit_more() || netif_xmit_stopped(txq))\n\t\tbnxt_txr_db_kick(bp, txr, prod);\n\telse\n\t\ttxr->kick_pending = 1;\n\ntx_done:\n\n\tif (unlikely(bnxt_tx_avail(bp, txr) <= MAX_SKB_FRAGS + 1)) {\n\t\tif (netdev_xmit_more() && !tx_buf->is_push)\n\t\t\tbnxt_txr_db_kick(bp, txr, prod);\n\n\t\tnetif_txq_try_stop(txq, bnxt_tx_avail(bp, txr),\n\t\t\t\t   bp->tx_wake_thresh);\n\t}\n\treturn NETDEV_TX_OK;\n\ntx_dma_error:\n\tif (BNXT_TX_PTP_IS_SET(lflags))\n\t\tatomic_inc(&bp->ptp_cfg->tx_avail);\n\n\tlast_frag = i;\n\n\t \n\tprod = txr->tx_prod;\n\ttx_buf = &txr->tx_buf_ring[prod];\n\tdma_unmap_single(&pdev->dev, dma_unmap_addr(tx_buf, mapping),\n\t\t\t skb_headlen(skb), DMA_TO_DEVICE);\n\tprod = NEXT_TX(prod);\n\n\t \n\tfor (i = 0; i < last_frag; i++) {\n\t\tprod = NEXT_TX(prod);\n\t\ttx_buf = &txr->tx_buf_ring[prod];\n\t\tdma_unmap_page(&pdev->dev, dma_unmap_addr(tx_buf, mapping),\n\t\t\t       skb_frag_size(&skb_shinfo(skb)->frags[i]),\n\t\t\t       DMA_TO_DEVICE);\n\t}\n\ntx_free:\n\tdev_kfree_skb_any(skb);\ntx_kick_pending:\n\tif (txr->kick_pending)\n\t\tbnxt_txr_db_kick(bp, txr, txr->tx_prod);\n\ttxr->tx_buf_ring[txr->tx_prod].skb = NULL;\n\tdev_core_stats_tx_dropped_inc(dev);\n\treturn NETDEV_TX_OK;\n}\n\nstatic void bnxt_tx_int(struct bnxt *bp, struct bnxt_napi *bnapi, int budget)\n{\n\tstruct bnxt_tx_ring_info *txr = bnapi->tx_ring;\n\tstruct netdev_queue *txq = netdev_get_tx_queue(bp->dev, txr->txq_index);\n\tu16 cons = txr->tx_cons;\n\tstruct pci_dev *pdev = bp->pdev;\n\tint nr_pkts = bnapi->tx_pkts;\n\tint i;\n\tunsigned int tx_bytes = 0;\n\n\tfor (i = 0; i < nr_pkts; i++) {\n\t\tstruct bnxt_sw_tx_bd *tx_buf;\n\t\tstruct sk_buff *skb;\n\t\tint j, last;\n\n\t\ttx_buf = &txr->tx_buf_ring[cons];\n\t\tcons = NEXT_TX(cons);\n\t\tskb = tx_buf->skb;\n\t\ttx_buf->skb = NULL;\n\n\t\tif (unlikely(!skb)) {\n\t\t\tbnxt_sched_reset_txr(bp, txr, i);\n\t\t\treturn;\n\t\t}\n\n\t\ttx_bytes += skb->len;\n\n\t\tif (tx_buf->is_push) {\n\t\t\ttx_buf->is_push = 0;\n\t\t\tgoto next_tx_int;\n\t\t}\n\n\t\tdma_unmap_single(&pdev->dev, dma_unmap_addr(tx_buf, mapping),\n\t\t\t\t skb_headlen(skb), DMA_TO_DEVICE);\n\t\tlast = tx_buf->nr_frags;\n\n\t\tfor (j = 0; j < last; j++) {\n\t\t\tcons = NEXT_TX(cons);\n\t\t\ttx_buf = &txr->tx_buf_ring[cons];\n\t\t\tdma_unmap_page(\n\t\t\t\t&pdev->dev,\n\t\t\t\tdma_unmap_addr(tx_buf, mapping),\n\t\t\t\tskb_frag_size(&skb_shinfo(skb)->frags[j]),\n\t\t\t\tDMA_TO_DEVICE);\n\t\t}\n\t\tif (unlikely(skb_shinfo(skb)->tx_flags & SKBTX_IN_PROGRESS)) {\n\t\t\tif (bp->flags & BNXT_FLAG_CHIP_P5) {\n\t\t\t\t \n\t\t\t\tif (!bnxt_get_tx_ts_p5(bp, skb))\n\t\t\t\t\tskb = NULL;\n\t\t\t\telse\n\t\t\t\t\tatomic_inc(&bp->ptp_cfg->tx_avail);\n\t\t\t}\n\t\t}\n\nnext_tx_int:\n\t\tcons = NEXT_TX(cons);\n\n\t\tdev_consume_skb_any(skb);\n\t}\n\n\tbnapi->tx_pkts = 0;\n\tWRITE_ONCE(txr->tx_cons, cons);\n\n\t__netif_txq_completed_wake(txq, nr_pkts, tx_bytes,\n\t\t\t\t   bnxt_tx_avail(bp, txr), bp->tx_wake_thresh,\n\t\t\t\t   READ_ONCE(txr->dev_state) == BNXT_DEV_STATE_CLOSING);\n}\n\nstatic struct page *__bnxt_alloc_rx_page(struct bnxt *bp, dma_addr_t *mapping,\n\t\t\t\t\t struct bnxt_rx_ring_info *rxr,\n\t\t\t\t\t unsigned int *offset,\n\t\t\t\t\t gfp_t gfp)\n{\n\tstruct page *page;\n\n\tif (PAGE_SIZE > BNXT_RX_PAGE_SIZE) {\n\t\tpage = page_pool_dev_alloc_frag(rxr->page_pool, offset,\n\t\t\t\t\t\tBNXT_RX_PAGE_SIZE);\n\t} else {\n\t\tpage = page_pool_dev_alloc_pages(rxr->page_pool);\n\t\t*offset = 0;\n\t}\n\tif (!page)\n\t\treturn NULL;\n\n\t*mapping = page_pool_get_dma_addr(page) + *offset;\n\treturn page;\n}\n\nstatic inline u8 *__bnxt_alloc_rx_frag(struct bnxt *bp, dma_addr_t *mapping,\n\t\t\t\t       gfp_t gfp)\n{\n\tu8 *data;\n\tstruct pci_dev *pdev = bp->pdev;\n\n\tif (gfp == GFP_ATOMIC)\n\t\tdata = napi_alloc_frag(bp->rx_buf_size);\n\telse\n\t\tdata = netdev_alloc_frag(bp->rx_buf_size);\n\tif (!data)\n\t\treturn NULL;\n\n\t*mapping = dma_map_single_attrs(&pdev->dev, data + bp->rx_dma_offset,\n\t\t\t\t\tbp->rx_buf_use_size, bp->rx_dir,\n\t\t\t\t\tDMA_ATTR_WEAK_ORDERING);\n\n\tif (dma_mapping_error(&pdev->dev, *mapping)) {\n\t\tskb_free_frag(data);\n\t\tdata = NULL;\n\t}\n\treturn data;\n}\n\nint bnxt_alloc_rx_data(struct bnxt *bp, struct bnxt_rx_ring_info *rxr,\n\t\t       u16 prod, gfp_t gfp)\n{\n\tstruct rx_bd *rxbd = &rxr->rx_desc_ring[RX_RING(prod)][RX_IDX(prod)];\n\tstruct bnxt_sw_rx_bd *rx_buf = &rxr->rx_buf_ring[prod];\n\tdma_addr_t mapping;\n\n\tif (BNXT_RX_PAGE_MODE(bp)) {\n\t\tunsigned int offset;\n\t\tstruct page *page =\n\t\t\t__bnxt_alloc_rx_page(bp, &mapping, rxr, &offset, gfp);\n\n\t\tif (!page)\n\t\t\treturn -ENOMEM;\n\n\t\tmapping += bp->rx_dma_offset;\n\t\trx_buf->data = page;\n\t\trx_buf->data_ptr = page_address(page) + offset + bp->rx_offset;\n\t} else {\n\t\tu8 *data = __bnxt_alloc_rx_frag(bp, &mapping, gfp);\n\n\t\tif (!data)\n\t\t\treturn -ENOMEM;\n\n\t\trx_buf->data = data;\n\t\trx_buf->data_ptr = data + bp->rx_offset;\n\t}\n\trx_buf->mapping = mapping;\n\n\trxbd->rx_bd_haddr = cpu_to_le64(mapping);\n\treturn 0;\n}\n\nvoid bnxt_reuse_rx_data(struct bnxt_rx_ring_info *rxr, u16 cons, void *data)\n{\n\tu16 prod = rxr->rx_prod;\n\tstruct bnxt_sw_rx_bd *cons_rx_buf, *prod_rx_buf;\n\tstruct rx_bd *cons_bd, *prod_bd;\n\n\tprod_rx_buf = &rxr->rx_buf_ring[prod];\n\tcons_rx_buf = &rxr->rx_buf_ring[cons];\n\n\tprod_rx_buf->data = data;\n\tprod_rx_buf->data_ptr = cons_rx_buf->data_ptr;\n\n\tprod_rx_buf->mapping = cons_rx_buf->mapping;\n\n\tprod_bd = &rxr->rx_desc_ring[RX_RING(prod)][RX_IDX(prod)];\n\tcons_bd = &rxr->rx_desc_ring[RX_RING(cons)][RX_IDX(cons)];\n\n\tprod_bd->rx_bd_haddr = cons_bd->rx_bd_haddr;\n}\n\nstatic inline u16 bnxt_find_next_agg_idx(struct bnxt_rx_ring_info *rxr, u16 idx)\n{\n\tu16 next, max = rxr->rx_agg_bmap_size;\n\n\tnext = find_next_zero_bit(rxr->rx_agg_bmap, max, idx);\n\tif (next >= max)\n\t\tnext = find_first_zero_bit(rxr->rx_agg_bmap, max);\n\treturn next;\n}\n\nstatic inline int bnxt_alloc_rx_page(struct bnxt *bp,\n\t\t\t\t     struct bnxt_rx_ring_info *rxr,\n\t\t\t\t     u16 prod, gfp_t gfp)\n{\n\tstruct rx_bd *rxbd =\n\t\t&rxr->rx_agg_desc_ring[RX_RING(prod)][RX_IDX(prod)];\n\tstruct bnxt_sw_rx_agg_bd *rx_agg_buf;\n\tstruct page *page;\n\tdma_addr_t mapping;\n\tu16 sw_prod = rxr->rx_sw_agg_prod;\n\tunsigned int offset = 0;\n\n\tpage = __bnxt_alloc_rx_page(bp, &mapping, rxr, &offset, gfp);\n\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tif (unlikely(test_bit(sw_prod, rxr->rx_agg_bmap)))\n\t\tsw_prod = bnxt_find_next_agg_idx(rxr, sw_prod);\n\n\t__set_bit(sw_prod, rxr->rx_agg_bmap);\n\trx_agg_buf = &rxr->rx_agg_ring[sw_prod];\n\trxr->rx_sw_agg_prod = NEXT_RX_AGG(sw_prod);\n\n\trx_agg_buf->page = page;\n\trx_agg_buf->offset = offset;\n\trx_agg_buf->mapping = mapping;\n\trxbd->rx_bd_haddr = cpu_to_le64(mapping);\n\trxbd->rx_bd_opaque = sw_prod;\n\treturn 0;\n}\n\nstatic struct rx_agg_cmp *bnxt_get_agg(struct bnxt *bp,\n\t\t\t\t       struct bnxt_cp_ring_info *cpr,\n\t\t\t\t       u16 cp_cons, u16 curr)\n{\n\tstruct rx_agg_cmp *agg;\n\n\tcp_cons = RING_CMP(ADV_RAW_CMP(cp_cons, curr));\n\tagg = (struct rx_agg_cmp *)\n\t\t&cpr->cp_desc_ring[CP_RING(cp_cons)][CP_IDX(cp_cons)];\n\treturn agg;\n}\n\nstatic struct rx_agg_cmp *bnxt_get_tpa_agg_p5(struct bnxt *bp,\n\t\t\t\t\t      struct bnxt_rx_ring_info *rxr,\n\t\t\t\t\t      u16 agg_id, u16 curr)\n{\n\tstruct bnxt_tpa_info *tpa_info = &rxr->rx_tpa[agg_id];\n\n\treturn &tpa_info->agg_arr[curr];\n}\n\nstatic void bnxt_reuse_rx_agg_bufs(struct bnxt_cp_ring_info *cpr, u16 idx,\n\t\t\t\t   u16 start, u32 agg_bufs, bool tpa)\n{\n\tstruct bnxt_napi *bnapi = cpr->bnapi;\n\tstruct bnxt *bp = bnapi->bp;\n\tstruct bnxt_rx_ring_info *rxr = bnapi->rx_ring;\n\tu16 prod = rxr->rx_agg_prod;\n\tu16 sw_prod = rxr->rx_sw_agg_prod;\n\tbool p5_tpa = false;\n\tu32 i;\n\n\tif ((bp->flags & BNXT_FLAG_CHIP_P5) && tpa)\n\t\tp5_tpa = true;\n\n\tfor (i = 0; i < agg_bufs; i++) {\n\t\tu16 cons;\n\t\tstruct rx_agg_cmp *agg;\n\t\tstruct bnxt_sw_rx_agg_bd *cons_rx_buf, *prod_rx_buf;\n\t\tstruct rx_bd *prod_bd;\n\t\tstruct page *page;\n\n\t\tif (p5_tpa)\n\t\t\tagg = bnxt_get_tpa_agg_p5(bp, rxr, idx, start + i);\n\t\telse\n\t\t\tagg = bnxt_get_agg(bp, cpr, idx, start + i);\n\t\tcons = agg->rx_agg_cmp_opaque;\n\t\t__clear_bit(cons, rxr->rx_agg_bmap);\n\n\t\tif (unlikely(test_bit(sw_prod, rxr->rx_agg_bmap)))\n\t\t\tsw_prod = bnxt_find_next_agg_idx(rxr, sw_prod);\n\n\t\t__set_bit(sw_prod, rxr->rx_agg_bmap);\n\t\tprod_rx_buf = &rxr->rx_agg_ring[sw_prod];\n\t\tcons_rx_buf = &rxr->rx_agg_ring[cons];\n\n\t\t \n\t\tpage = cons_rx_buf->page;\n\t\tcons_rx_buf->page = NULL;\n\t\tprod_rx_buf->page = page;\n\t\tprod_rx_buf->offset = cons_rx_buf->offset;\n\n\t\tprod_rx_buf->mapping = cons_rx_buf->mapping;\n\n\t\tprod_bd = &rxr->rx_agg_desc_ring[RX_RING(prod)][RX_IDX(prod)];\n\n\t\tprod_bd->rx_bd_haddr = cpu_to_le64(cons_rx_buf->mapping);\n\t\tprod_bd->rx_bd_opaque = sw_prod;\n\n\t\tprod = NEXT_RX_AGG(prod);\n\t\tsw_prod = NEXT_RX_AGG(sw_prod);\n\t}\n\trxr->rx_agg_prod = prod;\n\trxr->rx_sw_agg_prod = sw_prod;\n}\n\nstatic struct sk_buff *bnxt_rx_multi_page_skb(struct bnxt *bp,\n\t\t\t\t\t      struct bnxt_rx_ring_info *rxr,\n\t\t\t\t\t      u16 cons, void *data, u8 *data_ptr,\n\t\t\t\t\t      dma_addr_t dma_addr,\n\t\t\t\t\t      unsigned int offset_and_len)\n{\n\tunsigned int len = offset_and_len & 0xffff;\n\tstruct page *page = data;\n\tu16 prod = rxr->rx_prod;\n\tstruct sk_buff *skb;\n\tint err;\n\n\terr = bnxt_alloc_rx_data(bp, rxr, prod, GFP_ATOMIC);\n\tif (unlikely(err)) {\n\t\tbnxt_reuse_rx_data(rxr, cons, data);\n\t\treturn NULL;\n\t}\n\tdma_addr -= bp->rx_dma_offset;\n\tdma_sync_single_for_cpu(&bp->pdev->dev, dma_addr, BNXT_RX_PAGE_SIZE,\n\t\t\t\tbp->rx_dir);\n\tskb = napi_build_skb(data_ptr - bp->rx_offset, BNXT_RX_PAGE_SIZE);\n\tif (!skb) {\n\t\tpage_pool_recycle_direct(rxr->page_pool, page);\n\t\treturn NULL;\n\t}\n\tskb_mark_for_recycle(skb);\n\tskb_reserve(skb, bp->rx_offset);\n\t__skb_put(skb, len);\n\n\treturn skb;\n}\n\nstatic struct sk_buff *bnxt_rx_page_skb(struct bnxt *bp,\n\t\t\t\t\tstruct bnxt_rx_ring_info *rxr,\n\t\t\t\t\tu16 cons, void *data, u8 *data_ptr,\n\t\t\t\t\tdma_addr_t dma_addr,\n\t\t\t\t\tunsigned int offset_and_len)\n{\n\tunsigned int payload = offset_and_len >> 16;\n\tunsigned int len = offset_and_len & 0xffff;\n\tskb_frag_t *frag;\n\tstruct page *page = data;\n\tu16 prod = rxr->rx_prod;\n\tstruct sk_buff *skb;\n\tint off, err;\n\n\terr = bnxt_alloc_rx_data(bp, rxr, prod, GFP_ATOMIC);\n\tif (unlikely(err)) {\n\t\tbnxt_reuse_rx_data(rxr, cons, data);\n\t\treturn NULL;\n\t}\n\tdma_addr -= bp->rx_dma_offset;\n\tdma_sync_single_for_cpu(&bp->pdev->dev, dma_addr, BNXT_RX_PAGE_SIZE,\n\t\t\t\tbp->rx_dir);\n\n\tif (unlikely(!payload))\n\t\tpayload = eth_get_headlen(bp->dev, data_ptr, len);\n\n\tskb = napi_alloc_skb(&rxr->bnapi->napi, payload);\n\tif (!skb) {\n\t\tpage_pool_recycle_direct(rxr->page_pool, page);\n\t\treturn NULL;\n\t}\n\n\tskb_mark_for_recycle(skb);\n\toff = (void *)data_ptr - page_address(page);\n\tskb_add_rx_frag(skb, 0, page, off, len, BNXT_RX_PAGE_SIZE);\n\tmemcpy(skb->data - NET_IP_ALIGN, data_ptr - NET_IP_ALIGN,\n\t       payload + NET_IP_ALIGN);\n\n\tfrag = &skb_shinfo(skb)->frags[0];\n\tskb_frag_size_sub(frag, payload);\n\tskb_frag_off_add(frag, payload);\n\tskb->data_len -= payload;\n\tskb->tail += payload;\n\n\treturn skb;\n}\n\nstatic struct sk_buff *bnxt_rx_skb(struct bnxt *bp,\n\t\t\t\t   struct bnxt_rx_ring_info *rxr, u16 cons,\n\t\t\t\t   void *data, u8 *data_ptr,\n\t\t\t\t   dma_addr_t dma_addr,\n\t\t\t\t   unsigned int offset_and_len)\n{\n\tu16 prod = rxr->rx_prod;\n\tstruct sk_buff *skb;\n\tint err;\n\n\terr = bnxt_alloc_rx_data(bp, rxr, prod, GFP_ATOMIC);\n\tif (unlikely(err)) {\n\t\tbnxt_reuse_rx_data(rxr, cons, data);\n\t\treturn NULL;\n\t}\n\n\tskb = napi_build_skb(data, bp->rx_buf_size);\n\tdma_unmap_single_attrs(&bp->pdev->dev, dma_addr, bp->rx_buf_use_size,\n\t\t\t       bp->rx_dir, DMA_ATTR_WEAK_ORDERING);\n\tif (!skb) {\n\t\tskb_free_frag(data);\n\t\treturn NULL;\n\t}\n\n\tskb_reserve(skb, bp->rx_offset);\n\tskb_put(skb, offset_and_len & 0xffff);\n\treturn skb;\n}\n\nstatic u32 __bnxt_rx_agg_pages(struct bnxt *bp,\n\t\t\t       struct bnxt_cp_ring_info *cpr,\n\t\t\t       struct skb_shared_info *shinfo,\n\t\t\t       u16 idx, u32 agg_bufs, bool tpa,\n\t\t\t       struct xdp_buff *xdp)\n{\n\tstruct bnxt_napi *bnapi = cpr->bnapi;\n\tstruct pci_dev *pdev = bp->pdev;\n\tstruct bnxt_rx_ring_info *rxr = bnapi->rx_ring;\n\tu16 prod = rxr->rx_agg_prod;\n\tu32 i, total_frag_len = 0;\n\tbool p5_tpa = false;\n\n\tif ((bp->flags & BNXT_FLAG_CHIP_P5) && tpa)\n\t\tp5_tpa = true;\n\n\tfor (i = 0; i < agg_bufs; i++) {\n\t\tskb_frag_t *frag = &shinfo->frags[i];\n\t\tu16 cons, frag_len;\n\t\tstruct rx_agg_cmp *agg;\n\t\tstruct bnxt_sw_rx_agg_bd *cons_rx_buf;\n\t\tstruct page *page;\n\t\tdma_addr_t mapping;\n\n\t\tif (p5_tpa)\n\t\t\tagg = bnxt_get_tpa_agg_p5(bp, rxr, idx, i);\n\t\telse\n\t\t\tagg = bnxt_get_agg(bp, cpr, idx, i);\n\t\tcons = agg->rx_agg_cmp_opaque;\n\t\tfrag_len = (le32_to_cpu(agg->rx_agg_cmp_len_flags_type) &\n\t\t\t    RX_AGG_CMP_LEN) >> RX_AGG_CMP_LEN_SHIFT;\n\n\t\tcons_rx_buf = &rxr->rx_agg_ring[cons];\n\t\tskb_frag_fill_page_desc(frag, cons_rx_buf->page,\n\t\t\t\t\tcons_rx_buf->offset, frag_len);\n\t\tshinfo->nr_frags = i + 1;\n\t\t__clear_bit(cons, rxr->rx_agg_bmap);\n\n\t\t \n\t\tmapping = cons_rx_buf->mapping;\n\t\tpage = cons_rx_buf->page;\n\t\tcons_rx_buf->page = NULL;\n\n\t\tif (xdp && page_is_pfmemalloc(page))\n\t\t\txdp_buff_set_frag_pfmemalloc(xdp);\n\n\t\tif (bnxt_alloc_rx_page(bp, rxr, prod, GFP_ATOMIC) != 0) {\n\t\t\t--shinfo->nr_frags;\n\t\t\tcons_rx_buf->page = page;\n\n\t\t\t \n\t\t\trxr->rx_agg_prod = prod;\n\t\t\tbnxt_reuse_rx_agg_bufs(cpr, idx, i, agg_bufs - i, tpa);\n\t\t\treturn 0;\n\t\t}\n\n\t\tdma_sync_single_for_cpu(&pdev->dev, mapping, BNXT_RX_PAGE_SIZE,\n\t\t\t\t\tbp->rx_dir);\n\n\t\ttotal_frag_len += frag_len;\n\t\tprod = NEXT_RX_AGG(prod);\n\t}\n\trxr->rx_agg_prod = prod;\n\treturn total_frag_len;\n}\n\nstatic struct sk_buff *bnxt_rx_agg_pages_skb(struct bnxt *bp,\n\t\t\t\t\t     struct bnxt_cp_ring_info *cpr,\n\t\t\t\t\t     struct sk_buff *skb, u16 idx,\n\t\t\t\t\t     u32 agg_bufs, bool tpa)\n{\n\tstruct skb_shared_info *shinfo = skb_shinfo(skb);\n\tu32 total_frag_len = 0;\n\n\ttotal_frag_len = __bnxt_rx_agg_pages(bp, cpr, shinfo, idx,\n\t\t\t\t\t     agg_bufs, tpa, NULL);\n\tif (!total_frag_len) {\n\t\tskb_mark_for_recycle(skb);\n\t\tdev_kfree_skb(skb);\n\t\treturn NULL;\n\t}\n\n\tskb->data_len += total_frag_len;\n\tskb->len += total_frag_len;\n\tskb->truesize += BNXT_RX_PAGE_SIZE * agg_bufs;\n\treturn skb;\n}\n\nstatic u32 bnxt_rx_agg_pages_xdp(struct bnxt *bp,\n\t\t\t\t struct bnxt_cp_ring_info *cpr,\n\t\t\t\t struct xdp_buff *xdp, u16 idx,\n\t\t\t\t u32 agg_bufs, bool tpa)\n{\n\tstruct skb_shared_info *shinfo = xdp_get_shared_info_from_buff(xdp);\n\tu32 total_frag_len = 0;\n\n\tif (!xdp_buff_has_frags(xdp))\n\t\tshinfo->nr_frags = 0;\n\n\ttotal_frag_len = __bnxt_rx_agg_pages(bp, cpr, shinfo,\n\t\t\t\t\t     idx, agg_bufs, tpa, xdp);\n\tif (total_frag_len) {\n\t\txdp_buff_set_frags_flag(xdp);\n\t\tshinfo->nr_frags = agg_bufs;\n\t\tshinfo->xdp_frags_size = total_frag_len;\n\t}\n\treturn total_frag_len;\n}\n\nstatic int bnxt_agg_bufs_valid(struct bnxt *bp, struct bnxt_cp_ring_info *cpr,\n\t\t\t       u8 agg_bufs, u32 *raw_cons)\n{\n\tu16 last;\n\tstruct rx_agg_cmp *agg;\n\n\t*raw_cons = ADV_RAW_CMP(*raw_cons, agg_bufs);\n\tlast = RING_CMP(*raw_cons);\n\tagg = (struct rx_agg_cmp *)\n\t\t&cpr->cp_desc_ring[CP_RING(last)][CP_IDX(last)];\n\treturn RX_AGG_CMP_VALID(agg, *raw_cons);\n}\n\nstatic inline struct sk_buff *bnxt_copy_skb(struct bnxt_napi *bnapi, u8 *data,\n\t\t\t\t\t    unsigned int len,\n\t\t\t\t\t    dma_addr_t mapping)\n{\n\tstruct bnxt *bp = bnapi->bp;\n\tstruct pci_dev *pdev = bp->pdev;\n\tstruct sk_buff *skb;\n\n\tskb = napi_alloc_skb(&bnapi->napi, len);\n\tif (!skb)\n\t\treturn NULL;\n\n\tdma_sync_single_for_cpu(&pdev->dev, mapping, bp->rx_copy_thresh,\n\t\t\t\tbp->rx_dir);\n\n\tmemcpy(skb->data - NET_IP_ALIGN, data - NET_IP_ALIGN,\n\t       len + NET_IP_ALIGN);\n\n\tdma_sync_single_for_device(&pdev->dev, mapping, bp->rx_copy_thresh,\n\t\t\t\t   bp->rx_dir);\n\n\tskb_put(skb, len);\n\treturn skb;\n}\n\nstatic int bnxt_discard_rx(struct bnxt *bp, struct bnxt_cp_ring_info *cpr,\n\t\t\t   u32 *raw_cons, void *cmp)\n{\n\tstruct rx_cmp *rxcmp = cmp;\n\tu32 tmp_raw_cons = *raw_cons;\n\tu8 cmp_type, agg_bufs = 0;\n\n\tcmp_type = RX_CMP_TYPE(rxcmp);\n\n\tif (cmp_type == CMP_TYPE_RX_L2_CMP) {\n\t\tagg_bufs = (le32_to_cpu(rxcmp->rx_cmp_misc_v1) &\n\t\t\t    RX_CMP_AGG_BUFS) >>\n\t\t\t   RX_CMP_AGG_BUFS_SHIFT;\n\t} else if (cmp_type == CMP_TYPE_RX_L2_TPA_END_CMP) {\n\t\tstruct rx_tpa_end_cmp *tpa_end = cmp;\n\n\t\tif (bp->flags & BNXT_FLAG_CHIP_P5)\n\t\t\treturn 0;\n\n\t\tagg_bufs = TPA_END_AGG_BUFS(tpa_end);\n\t}\n\n\tif (agg_bufs) {\n\t\tif (!bnxt_agg_bufs_valid(bp, cpr, agg_bufs, &tmp_raw_cons))\n\t\t\treturn -EBUSY;\n\t}\n\t*raw_cons = tmp_raw_cons;\n\treturn 0;\n}\n\nstatic u16 bnxt_alloc_agg_idx(struct bnxt_rx_ring_info *rxr, u16 agg_id)\n{\n\tstruct bnxt_tpa_idx_map *map = rxr->rx_tpa_idx_map;\n\tu16 idx = agg_id & MAX_TPA_P5_MASK;\n\n\tif (test_bit(idx, map->agg_idx_bmap))\n\t\tidx = find_first_zero_bit(map->agg_idx_bmap,\n\t\t\t\t\t  BNXT_AGG_IDX_BMAP_SIZE);\n\t__set_bit(idx, map->agg_idx_bmap);\n\tmap->agg_id_tbl[agg_id] = idx;\n\treturn idx;\n}\n\nstatic void bnxt_free_agg_idx(struct bnxt_rx_ring_info *rxr, u16 idx)\n{\n\tstruct bnxt_tpa_idx_map *map = rxr->rx_tpa_idx_map;\n\n\t__clear_bit(idx, map->agg_idx_bmap);\n}\n\nstatic u16 bnxt_lookup_agg_idx(struct bnxt_rx_ring_info *rxr, u16 agg_id)\n{\n\tstruct bnxt_tpa_idx_map *map = rxr->rx_tpa_idx_map;\n\n\treturn map->agg_id_tbl[agg_id];\n}\n\nstatic void bnxt_tpa_start(struct bnxt *bp, struct bnxt_rx_ring_info *rxr,\n\t\t\t   struct rx_tpa_start_cmp *tpa_start,\n\t\t\t   struct rx_tpa_start_cmp_ext *tpa_start1)\n{\n\tstruct bnxt_sw_rx_bd *cons_rx_buf, *prod_rx_buf;\n\tstruct bnxt_tpa_info *tpa_info;\n\tu16 cons, prod, agg_id;\n\tstruct rx_bd *prod_bd;\n\tdma_addr_t mapping;\n\n\tif (bp->flags & BNXT_FLAG_CHIP_P5) {\n\t\tagg_id = TPA_START_AGG_ID_P5(tpa_start);\n\t\tagg_id = bnxt_alloc_agg_idx(rxr, agg_id);\n\t} else {\n\t\tagg_id = TPA_START_AGG_ID(tpa_start);\n\t}\n\tcons = tpa_start->rx_tpa_start_cmp_opaque;\n\tprod = rxr->rx_prod;\n\tcons_rx_buf = &rxr->rx_buf_ring[cons];\n\tprod_rx_buf = &rxr->rx_buf_ring[prod];\n\ttpa_info = &rxr->rx_tpa[agg_id];\n\n\tif (unlikely(cons != rxr->rx_next_cons ||\n\t\t     TPA_START_ERROR(tpa_start))) {\n\t\tnetdev_warn(bp->dev, \"TPA cons %x, expected cons %x, error code %x\\n\",\n\t\t\t    cons, rxr->rx_next_cons,\n\t\t\t    TPA_START_ERROR_CODE(tpa_start1));\n\t\tbnxt_sched_reset_rxr(bp, rxr);\n\t\treturn;\n\t}\n\t \n\ttpa_info->cfa_code = TPA_START_CFA_CODE(tpa_start1);\n\tprod_rx_buf->data = tpa_info->data;\n\tprod_rx_buf->data_ptr = tpa_info->data_ptr;\n\n\tmapping = tpa_info->mapping;\n\tprod_rx_buf->mapping = mapping;\n\n\tprod_bd = &rxr->rx_desc_ring[RX_RING(prod)][RX_IDX(prod)];\n\n\tprod_bd->rx_bd_haddr = cpu_to_le64(mapping);\n\n\ttpa_info->data = cons_rx_buf->data;\n\ttpa_info->data_ptr = cons_rx_buf->data_ptr;\n\tcons_rx_buf->data = NULL;\n\ttpa_info->mapping = cons_rx_buf->mapping;\n\n\ttpa_info->len =\n\t\tle32_to_cpu(tpa_start->rx_tpa_start_cmp_len_flags_type) >>\n\t\t\t\tRX_TPA_START_CMP_LEN_SHIFT;\n\tif (likely(TPA_START_HASH_VALID(tpa_start))) {\n\t\tu32 hash_type = TPA_START_HASH_TYPE(tpa_start);\n\n\t\ttpa_info->hash_type = PKT_HASH_TYPE_L4;\n\t\ttpa_info->gso_type = SKB_GSO_TCPV4;\n\t\t \n\t\tif (hash_type == 3 || TPA_START_IS_IPV6(tpa_start1))\n\t\t\ttpa_info->gso_type = SKB_GSO_TCPV6;\n\t\ttpa_info->rss_hash =\n\t\t\tle32_to_cpu(tpa_start->rx_tpa_start_cmp_rss_hash);\n\t} else {\n\t\ttpa_info->hash_type = PKT_HASH_TYPE_NONE;\n\t\ttpa_info->gso_type = 0;\n\t\tnetif_warn(bp, rx_err, bp->dev, \"TPA packet without valid hash\\n\");\n\t}\n\ttpa_info->flags2 = le32_to_cpu(tpa_start1->rx_tpa_start_cmp_flags2);\n\ttpa_info->metadata = le32_to_cpu(tpa_start1->rx_tpa_start_cmp_metadata);\n\ttpa_info->hdr_info = le32_to_cpu(tpa_start1->rx_tpa_start_cmp_hdr_info);\n\ttpa_info->agg_count = 0;\n\n\trxr->rx_prod = NEXT_RX(prod);\n\tcons = NEXT_RX(cons);\n\trxr->rx_next_cons = NEXT_RX(cons);\n\tcons_rx_buf = &rxr->rx_buf_ring[cons];\n\n\tbnxt_reuse_rx_data(rxr, cons, cons_rx_buf->data);\n\trxr->rx_prod = NEXT_RX(rxr->rx_prod);\n\tcons_rx_buf->data = NULL;\n}\n\nstatic void bnxt_abort_tpa(struct bnxt_cp_ring_info *cpr, u16 idx, u32 agg_bufs)\n{\n\tif (agg_bufs)\n\t\tbnxt_reuse_rx_agg_bufs(cpr, idx, 0, agg_bufs, true);\n}\n\n#ifdef CONFIG_INET\nstatic void bnxt_gro_tunnel(struct sk_buff *skb, __be16 ip_proto)\n{\n\tstruct udphdr *uh = NULL;\n\n\tif (ip_proto == htons(ETH_P_IP)) {\n\t\tstruct iphdr *iph = (struct iphdr *)skb->data;\n\n\t\tif (iph->protocol == IPPROTO_UDP)\n\t\t\tuh = (struct udphdr *)(iph + 1);\n\t} else {\n\t\tstruct ipv6hdr *iph = (struct ipv6hdr *)skb->data;\n\n\t\tif (iph->nexthdr == IPPROTO_UDP)\n\t\t\tuh = (struct udphdr *)(iph + 1);\n\t}\n\tif (uh) {\n\t\tif (uh->check)\n\t\t\tskb_shinfo(skb)->gso_type |= SKB_GSO_UDP_TUNNEL_CSUM;\n\t\telse\n\t\t\tskb_shinfo(skb)->gso_type |= SKB_GSO_UDP_TUNNEL;\n\t}\n}\n#endif\n\nstatic struct sk_buff *bnxt_gro_func_5731x(struct bnxt_tpa_info *tpa_info,\n\t\t\t\t\t   int payload_off, int tcp_ts,\n\t\t\t\t\t   struct sk_buff *skb)\n{\n#ifdef CONFIG_INET\n\tstruct tcphdr *th;\n\tint len, nw_off;\n\tu16 outer_ip_off, inner_ip_off, inner_mac_off;\n\tu32 hdr_info = tpa_info->hdr_info;\n\tbool loopback = false;\n\n\tinner_ip_off = BNXT_TPA_INNER_L3_OFF(hdr_info);\n\tinner_mac_off = BNXT_TPA_INNER_L2_OFF(hdr_info);\n\touter_ip_off = BNXT_TPA_OUTER_L3_OFF(hdr_info);\n\n\t \n\tif (inner_mac_off == 4) {\n\t\tloopback = true;\n\t} else if (inner_mac_off > 4) {\n\t\t__be16 proto = *((__be16 *)(skb->data + inner_ip_off -\n\t\t\t\t\t    ETH_HLEN - 2));\n\n\t\t \n\t\tif (proto != htons(ETH_P_IP) && proto != htons(ETH_P_IPV6))\n\t\t\tloopback = true;\n\t}\n\tif (loopback) {\n\t\t \n\t\tinner_ip_off -= 4;\n\t\tinner_mac_off -= 4;\n\t\touter_ip_off -= 4;\n\t}\n\n\tnw_off = inner_ip_off - ETH_HLEN;\n\tskb_set_network_header(skb, nw_off);\n\tif (tpa_info->flags2 & RX_TPA_START_CMP_FLAGS2_IP_TYPE) {\n\t\tstruct ipv6hdr *iph = ipv6_hdr(skb);\n\n\t\tskb_set_transport_header(skb, nw_off + sizeof(struct ipv6hdr));\n\t\tlen = skb->len - skb_transport_offset(skb);\n\t\tth = tcp_hdr(skb);\n\t\tth->check = ~tcp_v6_check(len, &iph->saddr, &iph->daddr, 0);\n\t} else {\n\t\tstruct iphdr *iph = ip_hdr(skb);\n\n\t\tskb_set_transport_header(skb, nw_off + sizeof(struct iphdr));\n\t\tlen = skb->len - skb_transport_offset(skb);\n\t\tth = tcp_hdr(skb);\n\t\tth->check = ~tcp_v4_check(len, iph->saddr, iph->daddr, 0);\n\t}\n\n\tif (inner_mac_off) {  \n\t\t__be16 proto = *((__be16 *)(skb->data + outer_ip_off -\n\t\t\t\t\t    ETH_HLEN - 2));\n\n\t\tbnxt_gro_tunnel(skb, proto);\n\t}\n#endif\n\treturn skb;\n}\n\nstatic struct sk_buff *bnxt_gro_func_5750x(struct bnxt_tpa_info *tpa_info,\n\t\t\t\t\t   int payload_off, int tcp_ts,\n\t\t\t\t\t   struct sk_buff *skb)\n{\n#ifdef CONFIG_INET\n\tu16 outer_ip_off, inner_ip_off, inner_mac_off;\n\tu32 hdr_info = tpa_info->hdr_info;\n\tint iphdr_len, nw_off;\n\n\tinner_ip_off = BNXT_TPA_INNER_L3_OFF(hdr_info);\n\tinner_mac_off = BNXT_TPA_INNER_L2_OFF(hdr_info);\n\touter_ip_off = BNXT_TPA_OUTER_L3_OFF(hdr_info);\n\n\tnw_off = inner_ip_off - ETH_HLEN;\n\tskb_set_network_header(skb, nw_off);\n\tiphdr_len = (tpa_info->flags2 & RX_TPA_START_CMP_FLAGS2_IP_TYPE) ?\n\t\t     sizeof(struct ipv6hdr) : sizeof(struct iphdr);\n\tskb_set_transport_header(skb, nw_off + iphdr_len);\n\n\tif (inner_mac_off) {  \n\t\t__be16 proto = *((__be16 *)(skb->data + outer_ip_off -\n\t\t\t\t\t    ETH_HLEN - 2));\n\n\t\tbnxt_gro_tunnel(skb, proto);\n\t}\n#endif\n\treturn skb;\n}\n\n#define BNXT_IPV4_HDR_SIZE\t(sizeof(struct iphdr) + sizeof(struct tcphdr))\n#define BNXT_IPV6_HDR_SIZE\t(sizeof(struct ipv6hdr) + sizeof(struct tcphdr))\n\nstatic struct sk_buff *bnxt_gro_func_5730x(struct bnxt_tpa_info *tpa_info,\n\t\t\t\t\t   int payload_off, int tcp_ts,\n\t\t\t\t\t   struct sk_buff *skb)\n{\n#ifdef CONFIG_INET\n\tstruct tcphdr *th;\n\tint len, nw_off, tcp_opt_len = 0;\n\n\tif (tcp_ts)\n\t\ttcp_opt_len = 12;\n\n\tif (tpa_info->gso_type == SKB_GSO_TCPV4) {\n\t\tstruct iphdr *iph;\n\n\t\tnw_off = payload_off - BNXT_IPV4_HDR_SIZE - tcp_opt_len -\n\t\t\t ETH_HLEN;\n\t\tskb_set_network_header(skb, nw_off);\n\t\tiph = ip_hdr(skb);\n\t\tskb_set_transport_header(skb, nw_off + sizeof(struct iphdr));\n\t\tlen = skb->len - skb_transport_offset(skb);\n\t\tth = tcp_hdr(skb);\n\t\tth->check = ~tcp_v4_check(len, iph->saddr, iph->daddr, 0);\n\t} else if (tpa_info->gso_type == SKB_GSO_TCPV6) {\n\t\tstruct ipv6hdr *iph;\n\n\t\tnw_off = payload_off - BNXT_IPV6_HDR_SIZE - tcp_opt_len -\n\t\t\t ETH_HLEN;\n\t\tskb_set_network_header(skb, nw_off);\n\t\tiph = ipv6_hdr(skb);\n\t\tskb_set_transport_header(skb, nw_off + sizeof(struct ipv6hdr));\n\t\tlen = skb->len - skb_transport_offset(skb);\n\t\tth = tcp_hdr(skb);\n\t\tth->check = ~tcp_v6_check(len, &iph->saddr, &iph->daddr, 0);\n\t} else {\n\t\tdev_kfree_skb_any(skb);\n\t\treturn NULL;\n\t}\n\n\tif (nw_off)  \n\t\tbnxt_gro_tunnel(skb, skb->protocol);\n#endif\n\treturn skb;\n}\n\nstatic inline struct sk_buff *bnxt_gro_skb(struct bnxt *bp,\n\t\t\t\t\t   struct bnxt_tpa_info *tpa_info,\n\t\t\t\t\t   struct rx_tpa_end_cmp *tpa_end,\n\t\t\t\t\t   struct rx_tpa_end_cmp_ext *tpa_end1,\n\t\t\t\t\t   struct sk_buff *skb)\n{\n#ifdef CONFIG_INET\n\tint payload_off;\n\tu16 segs;\n\n\tsegs = TPA_END_TPA_SEGS(tpa_end);\n\tif (segs == 1)\n\t\treturn skb;\n\n\tNAPI_GRO_CB(skb)->count = segs;\n\tskb_shinfo(skb)->gso_size =\n\t\tle32_to_cpu(tpa_end1->rx_tpa_end_cmp_seg_len);\n\tskb_shinfo(skb)->gso_type = tpa_info->gso_type;\n\tif (bp->flags & BNXT_FLAG_CHIP_P5)\n\t\tpayload_off = TPA_END_PAYLOAD_OFF_P5(tpa_end1);\n\telse\n\t\tpayload_off = TPA_END_PAYLOAD_OFF(tpa_end);\n\tskb = bp->gro_func(tpa_info, payload_off, TPA_END_GRO_TS(tpa_end), skb);\n\tif (likely(skb))\n\t\ttcp_gro_complete(skb);\n#endif\n\treturn skb;\n}\n\n \nstatic struct net_device *bnxt_get_pkt_dev(struct bnxt *bp, u16 cfa_code)\n{\n\tstruct net_device *dev = bnxt_get_vf_rep(bp, cfa_code);\n\n\t \n\treturn dev ? dev : bp->dev;\n}\n\nstatic inline struct sk_buff *bnxt_tpa_end(struct bnxt *bp,\n\t\t\t\t\t   struct bnxt_cp_ring_info *cpr,\n\t\t\t\t\t   u32 *raw_cons,\n\t\t\t\t\t   struct rx_tpa_end_cmp *tpa_end,\n\t\t\t\t\t   struct rx_tpa_end_cmp_ext *tpa_end1,\n\t\t\t\t\t   u8 *event)\n{\n\tstruct bnxt_napi *bnapi = cpr->bnapi;\n\tstruct bnxt_rx_ring_info *rxr = bnapi->rx_ring;\n\tu8 *data_ptr, agg_bufs;\n\tunsigned int len;\n\tstruct bnxt_tpa_info *tpa_info;\n\tdma_addr_t mapping;\n\tstruct sk_buff *skb;\n\tu16 idx = 0, agg_id;\n\tvoid *data;\n\tbool gro;\n\n\tif (unlikely(bnapi->in_reset)) {\n\t\tint rc = bnxt_discard_rx(bp, cpr, raw_cons, tpa_end);\n\n\t\tif (rc < 0)\n\t\t\treturn ERR_PTR(-EBUSY);\n\t\treturn NULL;\n\t}\n\n\tif (bp->flags & BNXT_FLAG_CHIP_P5) {\n\t\tagg_id = TPA_END_AGG_ID_P5(tpa_end);\n\t\tagg_id = bnxt_lookup_agg_idx(rxr, agg_id);\n\t\tagg_bufs = TPA_END_AGG_BUFS_P5(tpa_end1);\n\t\ttpa_info = &rxr->rx_tpa[agg_id];\n\t\tif (unlikely(agg_bufs != tpa_info->agg_count)) {\n\t\t\tnetdev_warn(bp->dev, \"TPA end agg_buf %d != expected agg_bufs %d\\n\",\n\t\t\t\t    agg_bufs, tpa_info->agg_count);\n\t\t\tagg_bufs = tpa_info->agg_count;\n\t\t}\n\t\ttpa_info->agg_count = 0;\n\t\t*event |= BNXT_AGG_EVENT;\n\t\tbnxt_free_agg_idx(rxr, agg_id);\n\t\tidx = agg_id;\n\t\tgro = !!(bp->flags & BNXT_FLAG_GRO);\n\t} else {\n\t\tagg_id = TPA_END_AGG_ID(tpa_end);\n\t\tagg_bufs = TPA_END_AGG_BUFS(tpa_end);\n\t\ttpa_info = &rxr->rx_tpa[agg_id];\n\t\tidx = RING_CMP(*raw_cons);\n\t\tif (agg_bufs) {\n\t\t\tif (!bnxt_agg_bufs_valid(bp, cpr, agg_bufs, raw_cons))\n\t\t\t\treturn ERR_PTR(-EBUSY);\n\n\t\t\t*event |= BNXT_AGG_EVENT;\n\t\t\tidx = NEXT_CMP(idx);\n\t\t}\n\t\tgro = !!TPA_END_GRO(tpa_end);\n\t}\n\tdata = tpa_info->data;\n\tdata_ptr = tpa_info->data_ptr;\n\tprefetch(data_ptr);\n\tlen = tpa_info->len;\n\tmapping = tpa_info->mapping;\n\n\tif (unlikely(agg_bufs > MAX_SKB_FRAGS || TPA_END_ERRORS(tpa_end1))) {\n\t\tbnxt_abort_tpa(cpr, idx, agg_bufs);\n\t\tif (agg_bufs > MAX_SKB_FRAGS)\n\t\t\tnetdev_warn(bp->dev, \"TPA frags %d exceeded MAX_SKB_FRAGS %d\\n\",\n\t\t\t\t    agg_bufs, (int)MAX_SKB_FRAGS);\n\t\treturn NULL;\n\t}\n\n\tif (len <= bp->rx_copy_thresh) {\n\t\tskb = bnxt_copy_skb(bnapi, data_ptr, len, mapping);\n\t\tif (!skb) {\n\t\t\tbnxt_abort_tpa(cpr, idx, agg_bufs);\n\t\t\tcpr->sw_stats.rx.rx_oom_discards += 1;\n\t\t\treturn NULL;\n\t\t}\n\t} else {\n\t\tu8 *new_data;\n\t\tdma_addr_t new_mapping;\n\n\t\tnew_data = __bnxt_alloc_rx_frag(bp, &new_mapping, GFP_ATOMIC);\n\t\tif (!new_data) {\n\t\t\tbnxt_abort_tpa(cpr, idx, agg_bufs);\n\t\t\tcpr->sw_stats.rx.rx_oom_discards += 1;\n\t\t\treturn NULL;\n\t\t}\n\n\t\ttpa_info->data = new_data;\n\t\ttpa_info->data_ptr = new_data + bp->rx_offset;\n\t\ttpa_info->mapping = new_mapping;\n\n\t\tskb = napi_build_skb(data, bp->rx_buf_size);\n\t\tdma_unmap_single_attrs(&bp->pdev->dev, mapping,\n\t\t\t\t       bp->rx_buf_use_size, bp->rx_dir,\n\t\t\t\t       DMA_ATTR_WEAK_ORDERING);\n\n\t\tif (!skb) {\n\t\t\tskb_free_frag(data);\n\t\t\tbnxt_abort_tpa(cpr, idx, agg_bufs);\n\t\t\tcpr->sw_stats.rx.rx_oom_discards += 1;\n\t\t\treturn NULL;\n\t\t}\n\t\tskb_reserve(skb, bp->rx_offset);\n\t\tskb_put(skb, len);\n\t}\n\n\tif (agg_bufs) {\n\t\tskb = bnxt_rx_agg_pages_skb(bp, cpr, skb, idx, agg_bufs, true);\n\t\tif (!skb) {\n\t\t\t \n\t\t\tcpr->sw_stats.rx.rx_oom_discards += 1;\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tskb->protocol =\n\t\teth_type_trans(skb, bnxt_get_pkt_dev(bp, tpa_info->cfa_code));\n\n\tif (tpa_info->hash_type != PKT_HASH_TYPE_NONE)\n\t\tskb_set_hash(skb, tpa_info->rss_hash, tpa_info->hash_type);\n\n\tif ((tpa_info->flags2 & RX_CMP_FLAGS2_META_FORMAT_VLAN) &&\n\t    (skb->dev->features & BNXT_HW_FEATURE_VLAN_ALL_RX)) {\n\t\t__be16 vlan_proto = htons(tpa_info->metadata >>\n\t\t\t\t\t  RX_CMP_FLAGS2_METADATA_TPID_SFT);\n\t\tu16 vtag = tpa_info->metadata & RX_CMP_FLAGS2_METADATA_TCI_MASK;\n\n\t\tif (eth_type_vlan(vlan_proto)) {\n\t\t\t__vlan_hwaccel_put_tag(skb, vlan_proto, vtag);\n\t\t} else {\n\t\t\tdev_kfree_skb(skb);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tskb_checksum_none_assert(skb);\n\tif (likely(tpa_info->flags2 & RX_TPA_START_CMP_FLAGS2_L4_CS_CALC)) {\n\t\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\t\tskb->csum_level =\n\t\t\t(tpa_info->flags2 & RX_CMP_FLAGS2_T_L4_CS_CALC) >> 3;\n\t}\n\n\tif (gro)\n\t\tskb = bnxt_gro_skb(bp, tpa_info, tpa_end, tpa_end1, skb);\n\n\treturn skb;\n}\n\nstatic void bnxt_tpa_agg(struct bnxt *bp, struct bnxt_rx_ring_info *rxr,\n\t\t\t struct rx_agg_cmp *rx_agg)\n{\n\tu16 agg_id = TPA_AGG_AGG_ID(rx_agg);\n\tstruct bnxt_tpa_info *tpa_info;\n\n\tagg_id = bnxt_lookup_agg_idx(rxr, agg_id);\n\ttpa_info = &rxr->rx_tpa[agg_id];\n\tBUG_ON(tpa_info->agg_count >= MAX_SKB_FRAGS);\n\ttpa_info->agg_arr[tpa_info->agg_count++] = *rx_agg;\n}\n\nstatic void bnxt_deliver_skb(struct bnxt *bp, struct bnxt_napi *bnapi,\n\t\t\t     struct sk_buff *skb)\n{\n\tskb_mark_for_recycle(skb);\n\n\tif (skb->dev != bp->dev) {\n\t\t \n\t\tbnxt_vf_rep_rx(bp, skb);\n\t\treturn;\n\t}\n\tskb_record_rx_queue(skb, bnapi->index);\n\tnapi_gro_receive(&bnapi->napi, skb);\n}\n\nstatic bool bnxt_rx_ts_valid(struct bnxt *bp, u32 flags,\n\t\t\t     struct rx_cmp_ext *rxcmp1, u32 *cmpl_ts)\n{\n\tu32 ts = le32_to_cpu(rxcmp1->rx_cmp_timestamp);\n\n\tif (BNXT_PTP_RX_TS_VALID(flags))\n\t\tgoto ts_valid;\n\tif (!bp->ptp_all_rx_tstamp || !ts || !BNXT_ALL_RX_TS_VALID(flags))\n\t\treturn false;\n\nts_valid:\n\t*cmpl_ts = ts;\n\treturn true;\n}\n\n \nstatic int bnxt_rx_pkt(struct bnxt *bp, struct bnxt_cp_ring_info *cpr,\n\t\t       u32 *raw_cons, u8 *event)\n{\n\tstruct bnxt_napi *bnapi = cpr->bnapi;\n\tstruct bnxt_rx_ring_info *rxr = bnapi->rx_ring;\n\tstruct net_device *dev = bp->dev;\n\tstruct rx_cmp *rxcmp;\n\tstruct rx_cmp_ext *rxcmp1;\n\tu32 tmp_raw_cons = *raw_cons;\n\tu16 cfa_code, cons, prod, cp_cons = RING_CMP(tmp_raw_cons);\n\tstruct bnxt_sw_rx_bd *rx_buf;\n\tunsigned int len;\n\tu8 *data_ptr, agg_bufs, cmp_type;\n\tbool xdp_active = false;\n\tdma_addr_t dma_addr;\n\tstruct sk_buff *skb;\n\tstruct xdp_buff xdp;\n\tu32 flags, misc;\n\tu32 cmpl_ts;\n\tvoid *data;\n\tint rc = 0;\n\n\trxcmp = (struct rx_cmp *)\n\t\t\t&cpr->cp_desc_ring[CP_RING(cp_cons)][CP_IDX(cp_cons)];\n\n\tcmp_type = RX_CMP_TYPE(rxcmp);\n\n\tif (cmp_type == CMP_TYPE_RX_TPA_AGG_CMP) {\n\t\tbnxt_tpa_agg(bp, rxr, (struct rx_agg_cmp *)rxcmp);\n\t\tgoto next_rx_no_prod_no_len;\n\t}\n\n\ttmp_raw_cons = NEXT_RAW_CMP(tmp_raw_cons);\n\tcp_cons = RING_CMP(tmp_raw_cons);\n\trxcmp1 = (struct rx_cmp_ext *)\n\t\t\t&cpr->cp_desc_ring[CP_RING(cp_cons)][CP_IDX(cp_cons)];\n\n\tif (!RX_CMP_VALID(rxcmp1, tmp_raw_cons))\n\t\treturn -EBUSY;\n\n\t \n\tdma_rmb();\n\tprod = rxr->rx_prod;\n\n\tif (cmp_type == CMP_TYPE_RX_L2_TPA_START_CMP) {\n\t\tbnxt_tpa_start(bp, rxr, (struct rx_tpa_start_cmp *)rxcmp,\n\t\t\t       (struct rx_tpa_start_cmp_ext *)rxcmp1);\n\n\t\t*event |= BNXT_RX_EVENT;\n\t\tgoto next_rx_no_prod_no_len;\n\n\t} else if (cmp_type == CMP_TYPE_RX_L2_TPA_END_CMP) {\n\t\tskb = bnxt_tpa_end(bp, cpr, &tmp_raw_cons,\n\t\t\t\t   (struct rx_tpa_end_cmp *)rxcmp,\n\t\t\t\t   (struct rx_tpa_end_cmp_ext *)rxcmp1, event);\n\n\t\tif (IS_ERR(skb))\n\t\t\treturn -EBUSY;\n\n\t\trc = -ENOMEM;\n\t\tif (likely(skb)) {\n\t\t\tbnxt_deliver_skb(bp, bnapi, skb);\n\t\t\trc = 1;\n\t\t}\n\t\t*event |= BNXT_RX_EVENT;\n\t\tgoto next_rx_no_prod_no_len;\n\t}\n\n\tcons = rxcmp->rx_cmp_opaque;\n\tif (unlikely(cons != rxr->rx_next_cons)) {\n\t\tint rc1 = bnxt_discard_rx(bp, cpr, &tmp_raw_cons, rxcmp);\n\n\t\t \n\t\tif (rxr->rx_next_cons != 0xffff)\n\t\t\tnetdev_warn(bp->dev, \"RX cons %x != expected cons %x\\n\",\n\t\t\t\t    cons, rxr->rx_next_cons);\n\t\tbnxt_sched_reset_rxr(bp, rxr);\n\t\tif (rc1)\n\t\t\treturn rc1;\n\t\tgoto next_rx_no_prod_no_len;\n\t}\n\trx_buf = &rxr->rx_buf_ring[cons];\n\tdata = rx_buf->data;\n\tdata_ptr = rx_buf->data_ptr;\n\tprefetch(data_ptr);\n\n\tmisc = le32_to_cpu(rxcmp->rx_cmp_misc_v1);\n\tagg_bufs = (misc & RX_CMP_AGG_BUFS) >> RX_CMP_AGG_BUFS_SHIFT;\n\n\tif (agg_bufs) {\n\t\tif (!bnxt_agg_bufs_valid(bp, cpr, agg_bufs, &tmp_raw_cons))\n\t\t\treturn -EBUSY;\n\n\t\tcp_cons = NEXT_CMP(cp_cons);\n\t\t*event |= BNXT_AGG_EVENT;\n\t}\n\t*event |= BNXT_RX_EVENT;\n\n\trx_buf->data = NULL;\n\tif (rxcmp1->rx_cmp_cfa_code_errors_v2 & RX_CMP_L2_ERRORS) {\n\t\tu32 rx_err = le32_to_cpu(rxcmp1->rx_cmp_cfa_code_errors_v2);\n\n\t\tbnxt_reuse_rx_data(rxr, cons, data);\n\t\tif (agg_bufs)\n\t\t\tbnxt_reuse_rx_agg_bufs(cpr, cp_cons, 0, agg_bufs,\n\t\t\t\t\t       false);\n\n\t\trc = -EIO;\n\t\tif (rx_err & RX_CMPL_ERRORS_BUFFER_ERROR_MASK) {\n\t\t\tbnapi->cp_ring.sw_stats.rx.rx_buf_errors++;\n\t\t\tif (!(bp->flags & BNXT_FLAG_CHIP_P5) &&\n\t\t\t    !(bp->fw_cap & BNXT_FW_CAP_RING_MONITOR)) {\n\t\t\t\tnetdev_warn_once(bp->dev, \"RX buffer error %x\\n\",\n\t\t\t\t\t\t rx_err);\n\t\t\t\tbnxt_sched_reset_rxr(bp, rxr);\n\t\t\t}\n\t\t}\n\t\tgoto next_rx_no_len;\n\t}\n\n\tflags = le32_to_cpu(rxcmp->rx_cmp_len_flags_type);\n\tlen = flags >> RX_CMP_LEN_SHIFT;\n\tdma_addr = rx_buf->mapping;\n\n\tif (bnxt_xdp_attached(bp, rxr)) {\n\t\tbnxt_xdp_buff_init(bp, rxr, cons, data_ptr, len, &xdp);\n\t\tif (agg_bufs) {\n\t\t\tu32 frag_len = bnxt_rx_agg_pages_xdp(bp, cpr, &xdp,\n\t\t\t\t\t\t\t     cp_cons, agg_bufs,\n\t\t\t\t\t\t\t     false);\n\t\t\tif (!frag_len) {\n\t\t\t\tcpr->sw_stats.rx.rx_oom_discards += 1;\n\t\t\t\trc = -ENOMEM;\n\t\t\t\tgoto next_rx;\n\t\t\t}\n\t\t}\n\t\txdp_active = true;\n\t}\n\n\tif (xdp_active) {\n\t\tif (bnxt_rx_xdp(bp, rxr, cons, xdp, data, &data_ptr, &len, event)) {\n\t\t\trc = 1;\n\t\t\tgoto next_rx;\n\t\t}\n\t}\n\n\tif (len <= bp->rx_copy_thresh) {\n\t\tskb = bnxt_copy_skb(bnapi, data_ptr, len, dma_addr);\n\t\tbnxt_reuse_rx_data(rxr, cons, data);\n\t\tif (!skb) {\n\t\t\tif (agg_bufs) {\n\t\t\t\tif (!xdp_active)\n\t\t\t\t\tbnxt_reuse_rx_agg_bufs(cpr, cp_cons, 0,\n\t\t\t\t\t\t\t       agg_bufs, false);\n\t\t\t\telse\n\t\t\t\t\tbnxt_xdp_buff_frags_free(rxr, &xdp);\n\t\t\t}\n\t\t\tcpr->sw_stats.rx.rx_oom_discards += 1;\n\t\t\trc = -ENOMEM;\n\t\t\tgoto next_rx;\n\t\t}\n\t} else {\n\t\tu32 payload;\n\n\t\tif (rx_buf->data_ptr == data_ptr)\n\t\t\tpayload = misc & RX_CMP_PAYLOAD_OFFSET;\n\t\telse\n\t\t\tpayload = 0;\n\t\tskb = bp->rx_skb_func(bp, rxr, cons, data, data_ptr, dma_addr,\n\t\t\t\t      payload | len);\n\t\tif (!skb) {\n\t\t\tcpr->sw_stats.rx.rx_oom_discards += 1;\n\t\t\trc = -ENOMEM;\n\t\t\tgoto next_rx;\n\t\t}\n\t}\n\n\tif (agg_bufs) {\n\t\tif (!xdp_active) {\n\t\t\tskb = bnxt_rx_agg_pages_skb(bp, cpr, skb, cp_cons, agg_bufs, false);\n\t\t\tif (!skb) {\n\t\t\t\tcpr->sw_stats.rx.rx_oom_discards += 1;\n\t\t\t\trc = -ENOMEM;\n\t\t\t\tgoto next_rx;\n\t\t\t}\n\t\t} else {\n\t\t\tskb = bnxt_xdp_build_skb(bp, skb, agg_bufs, rxr->page_pool, &xdp, rxcmp1);\n\t\t\tif (!skb) {\n\t\t\t\t \n\t\t\t\tbnxt_xdp_buff_frags_free(rxr, &xdp);\n\t\t\t\tcpr->sw_stats.rx.rx_oom_discards += 1;\n\t\t\t\trc = -ENOMEM;\n\t\t\t\tgoto next_rx;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (RX_CMP_HASH_VALID(rxcmp)) {\n\t\tu32 hash_type = RX_CMP_HASH_TYPE(rxcmp);\n\t\tenum pkt_hash_types type = PKT_HASH_TYPE_L4;\n\n\t\t \n\t\tif (hash_type != 1 && hash_type != 3)\n\t\t\ttype = PKT_HASH_TYPE_L3;\n\t\tskb_set_hash(skb, le32_to_cpu(rxcmp->rx_cmp_rss_hash), type);\n\t}\n\n\tcfa_code = RX_CMP_CFA_CODE(rxcmp1);\n\tskb->protocol = eth_type_trans(skb, bnxt_get_pkt_dev(bp, cfa_code));\n\n\tif ((rxcmp1->rx_cmp_flags2 &\n\t     cpu_to_le32(RX_CMP_FLAGS2_META_FORMAT_VLAN)) &&\n\t    (skb->dev->features & BNXT_HW_FEATURE_VLAN_ALL_RX)) {\n\t\tu32 meta_data = le32_to_cpu(rxcmp1->rx_cmp_meta_data);\n\t\tu16 vtag = meta_data & RX_CMP_FLAGS2_METADATA_TCI_MASK;\n\t\t__be16 vlan_proto = htons(meta_data >>\n\t\t\t\t\t  RX_CMP_FLAGS2_METADATA_TPID_SFT);\n\n\t\tif (eth_type_vlan(vlan_proto)) {\n\t\t\t__vlan_hwaccel_put_tag(skb, vlan_proto, vtag);\n\t\t} else {\n\t\t\tdev_kfree_skb(skb);\n\t\t\tgoto next_rx;\n\t\t}\n\t}\n\n\tskb_checksum_none_assert(skb);\n\tif (RX_CMP_L4_CS_OK(rxcmp1)) {\n\t\tif (dev->features & NETIF_F_RXCSUM) {\n\t\t\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\t\t\tskb->csum_level = RX_CMP_ENCAP(rxcmp1);\n\t\t}\n\t} else {\n\t\tif (rxcmp1->rx_cmp_cfa_code_errors_v2 & RX_CMP_L4_CS_ERR_BITS) {\n\t\t\tif (dev->features & NETIF_F_RXCSUM)\n\t\t\t\tbnapi->cp_ring.sw_stats.rx.rx_l4_csum_errors++;\n\t\t}\n\t}\n\n\tif (bnxt_rx_ts_valid(bp, flags, rxcmp1, &cmpl_ts)) {\n\t\tif (bp->flags & BNXT_FLAG_CHIP_P5) {\n\t\t\tu64 ns, ts;\n\n\t\t\tif (!bnxt_get_rx_ts_p5(bp, &ts, cmpl_ts)) {\n\t\t\t\tstruct bnxt_ptp_cfg *ptp = bp->ptp_cfg;\n\n\t\t\t\tspin_lock_bh(&ptp->ptp_lock);\n\t\t\t\tns = timecounter_cyc2time(&ptp->tc, ts);\n\t\t\t\tspin_unlock_bh(&ptp->ptp_lock);\n\t\t\t\tmemset(skb_hwtstamps(skb), 0,\n\t\t\t\t       sizeof(*skb_hwtstamps(skb)));\n\t\t\t\tskb_hwtstamps(skb)->hwtstamp = ns_to_ktime(ns);\n\t\t\t}\n\t\t}\n\t}\n\tbnxt_deliver_skb(bp, bnapi, skb);\n\trc = 1;\n\nnext_rx:\n\tcpr->rx_packets += 1;\n\tcpr->rx_bytes += len;\n\nnext_rx_no_len:\n\trxr->rx_prod = NEXT_RX(prod);\n\trxr->rx_next_cons = NEXT_RX(cons);\n\nnext_rx_no_prod_no_len:\n\t*raw_cons = tmp_raw_cons;\n\n\treturn rc;\n}\n\n \nstatic int bnxt_force_rx_discard(struct bnxt *bp,\n\t\t\t\t struct bnxt_cp_ring_info *cpr,\n\t\t\t\t u32 *raw_cons, u8 *event)\n{\n\tu32 tmp_raw_cons = *raw_cons;\n\tstruct rx_cmp_ext *rxcmp1;\n\tstruct rx_cmp *rxcmp;\n\tu16 cp_cons;\n\tu8 cmp_type;\n\tint rc;\n\n\tcp_cons = RING_CMP(tmp_raw_cons);\n\trxcmp = (struct rx_cmp *)\n\t\t\t&cpr->cp_desc_ring[CP_RING(cp_cons)][CP_IDX(cp_cons)];\n\n\ttmp_raw_cons = NEXT_RAW_CMP(tmp_raw_cons);\n\tcp_cons = RING_CMP(tmp_raw_cons);\n\trxcmp1 = (struct rx_cmp_ext *)\n\t\t\t&cpr->cp_desc_ring[CP_RING(cp_cons)][CP_IDX(cp_cons)];\n\n\tif (!RX_CMP_VALID(rxcmp1, tmp_raw_cons))\n\t\treturn -EBUSY;\n\n\t \n\tdma_rmb();\n\tcmp_type = RX_CMP_TYPE(rxcmp);\n\tif (cmp_type == CMP_TYPE_RX_L2_CMP) {\n\t\trxcmp1->rx_cmp_cfa_code_errors_v2 |=\n\t\t\tcpu_to_le32(RX_CMPL_ERRORS_CRC_ERROR);\n\t} else if (cmp_type == CMP_TYPE_RX_L2_TPA_END_CMP) {\n\t\tstruct rx_tpa_end_cmp_ext *tpa_end1;\n\n\t\ttpa_end1 = (struct rx_tpa_end_cmp_ext *)rxcmp1;\n\t\ttpa_end1->rx_tpa_end_cmp_errors_v2 |=\n\t\t\tcpu_to_le32(RX_TPA_END_CMP_ERRORS);\n\t}\n\trc = bnxt_rx_pkt(bp, cpr, raw_cons, event);\n\tif (rc && rc != -EBUSY)\n\t\tcpr->sw_stats.rx.rx_netpoll_discards += 1;\n\treturn rc;\n}\n\nu32 bnxt_fw_health_readl(struct bnxt *bp, int reg_idx)\n{\n\tstruct bnxt_fw_health *fw_health = bp->fw_health;\n\tu32 reg = fw_health->regs[reg_idx];\n\tu32 reg_type, reg_off, val = 0;\n\n\treg_type = BNXT_FW_HEALTH_REG_TYPE(reg);\n\treg_off = BNXT_FW_HEALTH_REG_OFF(reg);\n\tswitch (reg_type) {\n\tcase BNXT_FW_HEALTH_REG_TYPE_CFG:\n\t\tpci_read_config_dword(bp->pdev, reg_off, &val);\n\t\tbreak;\n\tcase BNXT_FW_HEALTH_REG_TYPE_GRC:\n\t\treg_off = fw_health->mapped_regs[reg_idx];\n\t\tfallthrough;\n\tcase BNXT_FW_HEALTH_REG_TYPE_BAR0:\n\t\tval = readl(bp->bar0 + reg_off);\n\t\tbreak;\n\tcase BNXT_FW_HEALTH_REG_TYPE_BAR1:\n\t\tval = readl(bp->bar1 + reg_off);\n\t\tbreak;\n\t}\n\tif (reg_idx == BNXT_FW_RESET_INPROG_REG)\n\t\tval &= fw_health->fw_reset_inprog_reg_mask;\n\treturn val;\n}\n\nstatic u16 bnxt_agg_ring_id_to_grp_idx(struct bnxt *bp, u16 ring_id)\n{\n\tint i;\n\n\tfor (i = 0; i < bp->rx_nr_rings; i++) {\n\t\tu16 grp_idx = bp->rx_ring[i].bnapi->index;\n\t\tstruct bnxt_ring_grp_info *grp_info;\n\n\t\tgrp_info = &bp->grp_info[grp_idx];\n\t\tif (grp_info->agg_fw_ring_id == ring_id)\n\t\t\treturn grp_idx;\n\t}\n\treturn INVALID_HW_RING_ID;\n}\n\nstatic void bnxt_event_error_report(struct bnxt *bp, u32 data1, u32 data2)\n{\n\tu32 err_type = BNXT_EVENT_ERROR_REPORT_TYPE(data1);\n\n\tswitch (err_type) {\n\tcase ASYNC_EVENT_CMPL_ERROR_REPORT_BASE_EVENT_DATA1_ERROR_TYPE_INVALID_SIGNAL:\n\t\tnetdev_err(bp->dev, \"1PPS: Received invalid signal on pin%lu from the external source. Please fix the signal and reconfigure the pin\\n\",\n\t\t\t   BNXT_EVENT_INVALID_SIGNAL_DATA(data2));\n\t\tbreak;\n\tcase ASYNC_EVENT_CMPL_ERROR_REPORT_BASE_EVENT_DATA1_ERROR_TYPE_PAUSE_STORM:\n\t\tnetdev_warn(bp->dev, \"Pause Storm detected!\\n\");\n\t\tbreak;\n\tcase ASYNC_EVENT_CMPL_ERROR_REPORT_BASE_EVENT_DATA1_ERROR_TYPE_DOORBELL_DROP_THRESHOLD:\n\t\tnetdev_warn(bp->dev, \"One or more MMIO doorbells dropped by the device!\\n\");\n\t\tbreak;\n\tdefault:\n\t\tnetdev_err(bp->dev, \"FW reported unknown error type %u\\n\",\n\t\t\t   err_type);\n\t\tbreak;\n\t}\n}\n\n#define BNXT_GET_EVENT_PORT(data)\t\\\n\t((data) &\t\t\t\\\n\t ASYNC_EVENT_CMPL_PORT_CONN_NOT_ALLOWED_EVENT_DATA1_PORT_ID_MASK)\n\n#define BNXT_EVENT_RING_TYPE(data2)\t\\\n\t((data2) &\t\t\t\\\n\t ASYNC_EVENT_CMPL_RING_MONITOR_MSG_EVENT_DATA2_DISABLE_RING_TYPE_MASK)\n\n#define BNXT_EVENT_RING_TYPE_RX(data2)\t\\\n\t(BNXT_EVENT_RING_TYPE(data2) ==\t\\\n\t ASYNC_EVENT_CMPL_RING_MONITOR_MSG_EVENT_DATA2_DISABLE_RING_TYPE_RX)\n\n#define BNXT_EVENT_PHC_EVENT_TYPE(data1)\t\\\n\t(((data1) & ASYNC_EVENT_CMPL_PHC_UPDATE_EVENT_DATA1_FLAGS_MASK) >>\\\n\t ASYNC_EVENT_CMPL_PHC_UPDATE_EVENT_DATA1_FLAGS_SFT)\n\n#define BNXT_EVENT_PHC_RTC_UPDATE(data1)\t\\\n\t(((data1) & ASYNC_EVENT_CMPL_PHC_UPDATE_EVENT_DATA1_PHC_TIME_MSB_MASK) >>\\\n\t ASYNC_EVENT_CMPL_PHC_UPDATE_EVENT_DATA1_PHC_TIME_MSB_SFT)\n\n#define BNXT_PHC_BITS\t48\n\nstatic int bnxt_async_event_process(struct bnxt *bp,\n\t\t\t\t    struct hwrm_async_event_cmpl *cmpl)\n{\n\tu16 event_id = le16_to_cpu(cmpl->event_id);\n\tu32 data1 = le32_to_cpu(cmpl->event_data1);\n\tu32 data2 = le32_to_cpu(cmpl->event_data2);\n\n\tnetdev_dbg(bp->dev, \"hwrm event 0x%x {0x%x, 0x%x}\\n\",\n\t\t   event_id, data1, data2);\n\n\t \n\tswitch (event_id) {\n\tcase ASYNC_EVENT_CMPL_EVENT_ID_LINK_SPEED_CFG_CHANGE: {\n\t\tstruct bnxt_link_info *link_info = &bp->link_info;\n\n\t\tif (BNXT_VF(bp))\n\t\t\tgoto async_event_process_exit;\n\n\t\t \n\t\tif (!(link_info->autoneg & BNXT_AUTONEG_SPEED) &&\n\t\t    (data1 & 0x20000)) {\n\t\t\tu16 fw_speed = link_info->force_link_speed;\n\t\t\tu32 speed = bnxt_fw_to_ethtool_speed(fw_speed);\n\n\t\t\tif (speed != SPEED_UNKNOWN)\n\t\t\t\tnetdev_warn(bp->dev, \"Link speed %d no longer supported\\n\",\n\t\t\t\t\t    speed);\n\t\t}\n\t\tset_bit(BNXT_LINK_SPEED_CHNG_SP_EVENT, &bp->sp_event);\n\t}\n\t\tfallthrough;\n\tcase ASYNC_EVENT_CMPL_EVENT_ID_LINK_SPEED_CHANGE:\n\tcase ASYNC_EVENT_CMPL_EVENT_ID_PORT_PHY_CFG_CHANGE:\n\t\tset_bit(BNXT_LINK_CFG_CHANGE_SP_EVENT, &bp->sp_event);\n\t\tfallthrough;\n\tcase ASYNC_EVENT_CMPL_EVENT_ID_LINK_STATUS_CHANGE:\n\t\tset_bit(BNXT_LINK_CHNG_SP_EVENT, &bp->sp_event);\n\t\tbreak;\n\tcase ASYNC_EVENT_CMPL_EVENT_ID_PF_DRVR_UNLOAD:\n\t\tset_bit(BNXT_HWRM_PF_UNLOAD_SP_EVENT, &bp->sp_event);\n\t\tbreak;\n\tcase ASYNC_EVENT_CMPL_EVENT_ID_PORT_CONN_NOT_ALLOWED: {\n\t\tu16 port_id = BNXT_GET_EVENT_PORT(data1);\n\n\t\tif (BNXT_VF(bp))\n\t\t\tbreak;\n\n\t\tif (bp->pf.port_id != port_id)\n\t\t\tbreak;\n\n\t\tset_bit(BNXT_HWRM_PORT_MODULE_SP_EVENT, &bp->sp_event);\n\t\tbreak;\n\t}\n\tcase ASYNC_EVENT_CMPL_EVENT_ID_VF_CFG_CHANGE:\n\t\tif (BNXT_PF(bp))\n\t\t\tgoto async_event_process_exit;\n\t\tset_bit(BNXT_RESET_TASK_SILENT_SP_EVENT, &bp->sp_event);\n\t\tbreak;\n\tcase ASYNC_EVENT_CMPL_EVENT_ID_RESET_NOTIFY: {\n\t\tchar *type_str = \"Solicited\";\n\n\t\tif (!bp->fw_health)\n\t\t\tgoto async_event_process_exit;\n\n\t\tbp->fw_reset_timestamp = jiffies;\n\t\tbp->fw_reset_min_dsecs = cmpl->timestamp_lo;\n\t\tif (!bp->fw_reset_min_dsecs)\n\t\t\tbp->fw_reset_min_dsecs = BNXT_DFLT_FW_RST_MIN_DSECS;\n\t\tbp->fw_reset_max_dsecs = le16_to_cpu(cmpl->timestamp_hi);\n\t\tif (!bp->fw_reset_max_dsecs)\n\t\t\tbp->fw_reset_max_dsecs = BNXT_DFLT_FW_RST_MAX_DSECS;\n\t\tif (EVENT_DATA1_RESET_NOTIFY_FW_ACTIVATION(data1)) {\n\t\t\tset_bit(BNXT_STATE_FW_ACTIVATE_RESET, &bp->state);\n\t\t} else if (EVENT_DATA1_RESET_NOTIFY_FATAL(data1)) {\n\t\t\ttype_str = \"Fatal\";\n\t\t\tbp->fw_health->fatalities++;\n\t\t\tset_bit(BNXT_STATE_FW_FATAL_COND, &bp->state);\n\t\t} else if (data2 && BNXT_FW_STATUS_HEALTHY !=\n\t\t\t   EVENT_DATA2_RESET_NOTIFY_FW_STATUS_CODE(data2)) {\n\t\t\ttype_str = \"Non-fatal\";\n\t\t\tbp->fw_health->survivals++;\n\t\t\tset_bit(BNXT_STATE_FW_NON_FATAL_COND, &bp->state);\n\t\t}\n\t\tnetif_warn(bp, hw, bp->dev,\n\t\t\t   \"%s firmware reset event, data1: 0x%x, data2: 0x%x, min wait %u ms, max wait %u ms\\n\",\n\t\t\t   type_str, data1, data2,\n\t\t\t   bp->fw_reset_min_dsecs * 100,\n\t\t\t   bp->fw_reset_max_dsecs * 100);\n\t\tset_bit(BNXT_FW_RESET_NOTIFY_SP_EVENT, &bp->sp_event);\n\t\tbreak;\n\t}\n\tcase ASYNC_EVENT_CMPL_EVENT_ID_ERROR_RECOVERY: {\n\t\tstruct bnxt_fw_health *fw_health = bp->fw_health;\n\t\tchar *status_desc = \"healthy\";\n\t\tu32 status;\n\n\t\tif (!fw_health)\n\t\t\tgoto async_event_process_exit;\n\n\t\tif (!EVENT_DATA1_RECOVERY_ENABLED(data1)) {\n\t\t\tfw_health->enabled = false;\n\t\t\tnetif_info(bp, drv, bp->dev, \"Driver recovery watchdog is disabled\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tfw_health->primary = EVENT_DATA1_RECOVERY_MASTER_FUNC(data1);\n\t\tfw_health->tmr_multiplier =\n\t\t\tDIV_ROUND_UP(fw_health->polling_dsecs * HZ,\n\t\t\t\t     bp->current_interval * 10);\n\t\tfw_health->tmr_counter = fw_health->tmr_multiplier;\n\t\tif (!fw_health->enabled)\n\t\t\tfw_health->last_fw_heartbeat =\n\t\t\t\tbnxt_fw_health_readl(bp, BNXT_FW_HEARTBEAT_REG);\n\t\tfw_health->last_fw_reset_cnt =\n\t\t\tbnxt_fw_health_readl(bp, BNXT_FW_RESET_CNT_REG);\n\t\tstatus = bnxt_fw_health_readl(bp, BNXT_FW_HEALTH_REG);\n\t\tif (status != BNXT_FW_STATUS_HEALTHY)\n\t\t\tstatus_desc = \"unhealthy\";\n\t\tnetif_info(bp, drv, bp->dev,\n\t\t\t   \"Driver recovery watchdog, role: %s, firmware status: 0x%x (%s), resets: %u\\n\",\n\t\t\t   fw_health->primary ? \"primary\" : \"backup\", status,\n\t\t\t   status_desc, fw_health->last_fw_reset_cnt);\n\t\tif (!fw_health->enabled) {\n\t\t\t \n\t\t\tsmp_wmb();\n\t\t\tfw_health->enabled = true;\n\t\t}\n\t\tgoto async_event_process_exit;\n\t}\n\tcase ASYNC_EVENT_CMPL_EVENT_ID_DEBUG_NOTIFICATION:\n\t\tnetif_notice(bp, hw, bp->dev,\n\t\t\t     \"Received firmware debug notification, data1: 0x%x, data2: 0x%x\\n\",\n\t\t\t     data1, data2);\n\t\tgoto async_event_process_exit;\n\tcase ASYNC_EVENT_CMPL_EVENT_ID_RING_MONITOR_MSG: {\n\t\tstruct bnxt_rx_ring_info *rxr;\n\t\tu16 grp_idx;\n\n\t\tif (bp->flags & BNXT_FLAG_CHIP_P5)\n\t\t\tgoto async_event_process_exit;\n\n\t\tnetdev_warn(bp->dev, \"Ring monitor event, ring type %lu id 0x%x\\n\",\n\t\t\t    BNXT_EVENT_RING_TYPE(data2), data1);\n\t\tif (!BNXT_EVENT_RING_TYPE_RX(data2))\n\t\t\tgoto async_event_process_exit;\n\n\t\tgrp_idx = bnxt_agg_ring_id_to_grp_idx(bp, data1);\n\t\tif (grp_idx == INVALID_HW_RING_ID) {\n\t\t\tnetdev_warn(bp->dev, \"Unknown RX agg ring id 0x%x\\n\",\n\t\t\t\t    data1);\n\t\t\tgoto async_event_process_exit;\n\t\t}\n\t\trxr = bp->bnapi[grp_idx]->rx_ring;\n\t\tbnxt_sched_reset_rxr(bp, rxr);\n\t\tgoto async_event_process_exit;\n\t}\n\tcase ASYNC_EVENT_CMPL_EVENT_ID_ECHO_REQUEST: {\n\t\tstruct bnxt_fw_health *fw_health = bp->fw_health;\n\n\t\tnetif_notice(bp, hw, bp->dev,\n\t\t\t     \"Received firmware echo request, data1: 0x%x, data2: 0x%x\\n\",\n\t\t\t     data1, data2);\n\t\tif (fw_health) {\n\t\t\tfw_health->echo_req_data1 = data1;\n\t\t\tfw_health->echo_req_data2 = data2;\n\t\t\tset_bit(BNXT_FW_ECHO_REQUEST_SP_EVENT, &bp->sp_event);\n\t\t\tbreak;\n\t\t}\n\t\tgoto async_event_process_exit;\n\t}\n\tcase ASYNC_EVENT_CMPL_EVENT_ID_PPS_TIMESTAMP: {\n\t\tbnxt_ptp_pps_event(bp, data1, data2);\n\t\tgoto async_event_process_exit;\n\t}\n\tcase ASYNC_EVENT_CMPL_EVENT_ID_ERROR_REPORT: {\n\t\tbnxt_event_error_report(bp, data1, data2);\n\t\tgoto async_event_process_exit;\n\t}\n\tcase ASYNC_EVENT_CMPL_EVENT_ID_PHC_UPDATE: {\n\t\tswitch (BNXT_EVENT_PHC_EVENT_TYPE(data1)) {\n\t\tcase ASYNC_EVENT_CMPL_PHC_UPDATE_EVENT_DATA1_FLAGS_PHC_RTC_UPDATE:\n\t\t\tif (BNXT_PTP_USE_RTC(bp)) {\n\t\t\t\tstruct bnxt_ptp_cfg *ptp = bp->ptp_cfg;\n\t\t\t\tu64 ns;\n\n\t\t\t\tif (!ptp)\n\t\t\t\t\tgoto async_event_process_exit;\n\n\t\t\t\tspin_lock_bh(&ptp->ptp_lock);\n\t\t\t\tbnxt_ptp_update_current_time(bp);\n\t\t\t\tns = (((u64)BNXT_EVENT_PHC_RTC_UPDATE(data1) <<\n\t\t\t\t       BNXT_PHC_BITS) | ptp->current_time);\n\t\t\t\tbnxt_ptp_rtc_timecounter_init(ptp, ns);\n\t\t\t\tspin_unlock_bh(&ptp->ptp_lock);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tgoto async_event_process_exit;\n\t}\n\tcase ASYNC_EVENT_CMPL_EVENT_ID_DEFERRED_RESPONSE: {\n\t\tu16 seq_id = le32_to_cpu(cmpl->event_data2) & 0xffff;\n\n\t\thwrm_update_token(bp, seq_id, BNXT_HWRM_DEFERRED);\n\t\tgoto async_event_process_exit;\n\t}\n\tdefault:\n\t\tgoto async_event_process_exit;\n\t}\n\t__bnxt_queue_sp_work(bp);\nasync_event_process_exit:\n\treturn 0;\n}\n\nstatic int bnxt_hwrm_handler(struct bnxt *bp, struct tx_cmp *txcmp)\n{\n\tu16 cmpl_type = TX_CMP_TYPE(txcmp), vf_id, seq_id;\n\tstruct hwrm_cmpl *h_cmpl = (struct hwrm_cmpl *)txcmp;\n\tstruct hwrm_fwd_req_cmpl *fwd_req_cmpl =\n\t\t\t\t(struct hwrm_fwd_req_cmpl *)txcmp;\n\n\tswitch (cmpl_type) {\n\tcase CMPL_BASE_TYPE_HWRM_DONE:\n\t\tseq_id = le16_to_cpu(h_cmpl->sequence_id);\n\t\thwrm_update_token(bp, seq_id, BNXT_HWRM_COMPLETE);\n\t\tbreak;\n\n\tcase CMPL_BASE_TYPE_HWRM_FWD_REQ:\n\t\tvf_id = le16_to_cpu(fwd_req_cmpl->source_id);\n\n\t\tif ((vf_id < bp->pf.first_vf_id) ||\n\t\t    (vf_id >= bp->pf.first_vf_id + bp->pf.active_vfs)) {\n\t\t\tnetdev_err(bp->dev, \"Msg contains invalid VF id %x\\n\",\n\t\t\t\t   vf_id);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tset_bit(vf_id - bp->pf.first_vf_id, bp->pf.vf_event_bmap);\n\t\tbnxt_queue_sp_work(bp, BNXT_HWRM_EXEC_FWD_REQ_SP_EVENT);\n\t\tbreak;\n\n\tcase CMPL_BASE_TYPE_HWRM_ASYNC_EVENT:\n\t\tbnxt_async_event_process(bp,\n\t\t\t\t\t (struct hwrm_async_event_cmpl *)txcmp);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic irqreturn_t bnxt_msix(int irq, void *dev_instance)\n{\n\tstruct bnxt_napi *bnapi = dev_instance;\n\tstruct bnxt *bp = bnapi->bp;\n\tstruct bnxt_cp_ring_info *cpr = &bnapi->cp_ring;\n\tu32 cons = RING_CMP(cpr->cp_raw_cons);\n\n\tcpr->event_ctr++;\n\tprefetch(&cpr->cp_desc_ring[CP_RING(cons)][CP_IDX(cons)]);\n\tnapi_schedule(&bnapi->napi);\n\treturn IRQ_HANDLED;\n}\n\nstatic inline int bnxt_has_work(struct bnxt *bp, struct bnxt_cp_ring_info *cpr)\n{\n\tu32 raw_cons = cpr->cp_raw_cons;\n\tu16 cons = RING_CMP(raw_cons);\n\tstruct tx_cmp *txcmp;\n\n\ttxcmp = &cpr->cp_desc_ring[CP_RING(cons)][CP_IDX(cons)];\n\n\treturn TX_CMP_VALID(txcmp, raw_cons);\n}\n\nstatic irqreturn_t bnxt_inta(int irq, void *dev_instance)\n{\n\tstruct bnxt_napi *bnapi = dev_instance;\n\tstruct bnxt *bp = bnapi->bp;\n\tstruct bnxt_cp_ring_info *cpr = &bnapi->cp_ring;\n\tu32 cons = RING_CMP(cpr->cp_raw_cons);\n\tu32 int_status;\n\n\tprefetch(&cpr->cp_desc_ring[CP_RING(cons)][CP_IDX(cons)]);\n\n\tif (!bnxt_has_work(bp, cpr)) {\n\t\tint_status = readl(bp->bar0 + BNXT_CAG_REG_LEGACY_INT_STATUS);\n\t\t \n\t\tif (!(int_status & (0x10000 << cpr->cp_ring_struct.fw_ring_id)))\n\t\t\treturn IRQ_NONE;\n\t}\n\n\t \n\tBNXT_CP_DB_IRQ_DIS(cpr->cp_db.doorbell);\n\n\t \n\tif (unlikely(atomic_read(&bp->intr_sem) != 0))\n\t\treturn IRQ_HANDLED;\n\n\tnapi_schedule(&bnapi->napi);\n\treturn IRQ_HANDLED;\n}\n\nstatic int __bnxt_poll_work(struct bnxt *bp, struct bnxt_cp_ring_info *cpr,\n\t\t\t    int budget)\n{\n\tstruct bnxt_napi *bnapi = cpr->bnapi;\n\tu32 raw_cons = cpr->cp_raw_cons;\n\tu32 cons;\n\tint tx_pkts = 0;\n\tint rx_pkts = 0;\n\tu8 event = 0;\n\tstruct tx_cmp *txcmp;\n\n\tcpr->has_more_work = 0;\n\tcpr->had_work_done = 1;\n\twhile (1) {\n\t\tint rc;\n\n\t\tcons = RING_CMP(raw_cons);\n\t\ttxcmp = &cpr->cp_desc_ring[CP_RING(cons)][CP_IDX(cons)];\n\n\t\tif (!TX_CMP_VALID(txcmp, raw_cons))\n\t\t\tbreak;\n\n\t\t \n\t\tdma_rmb();\n\t\tif (TX_CMP_TYPE(txcmp) == CMP_TYPE_TX_L2_CMP) {\n\t\t\ttx_pkts++;\n\t\t\t \n\t\t\tif (unlikely(tx_pkts >= bp->tx_wake_thresh)) {\n\t\t\t\trx_pkts = budget;\n\t\t\t\traw_cons = NEXT_RAW_CMP(raw_cons);\n\t\t\t\tif (budget)\n\t\t\t\t\tcpr->has_more_work = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if ((TX_CMP_TYPE(txcmp) & 0x30) == 0x10) {\n\t\t\tif (likely(budget))\n\t\t\t\trc = bnxt_rx_pkt(bp, cpr, &raw_cons, &event);\n\t\t\telse\n\t\t\t\trc = bnxt_force_rx_discard(bp, cpr, &raw_cons,\n\t\t\t\t\t\t\t   &event);\n\t\t\tif (likely(rc >= 0))\n\t\t\t\trx_pkts += rc;\n\t\t\t \n\t\t\telse if (rc == -ENOMEM && budget)\n\t\t\t\trx_pkts++;\n\t\t\telse if (rc == -EBUSY)\t \n\t\t\t\tbreak;\n\t\t} else if (unlikely((TX_CMP_TYPE(txcmp) ==\n\t\t\t\t     CMPL_BASE_TYPE_HWRM_DONE) ||\n\t\t\t\t    (TX_CMP_TYPE(txcmp) ==\n\t\t\t\t     CMPL_BASE_TYPE_HWRM_FWD_REQ) ||\n\t\t\t\t    (TX_CMP_TYPE(txcmp) ==\n\t\t\t\t     CMPL_BASE_TYPE_HWRM_ASYNC_EVENT))) {\n\t\t\tbnxt_hwrm_handler(bp, txcmp);\n\t\t}\n\t\traw_cons = NEXT_RAW_CMP(raw_cons);\n\n\t\tif (rx_pkts && rx_pkts == budget) {\n\t\t\tcpr->has_more_work = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (event & BNXT_REDIRECT_EVENT)\n\t\txdp_do_flush();\n\n\tif (event & BNXT_TX_EVENT) {\n\t\tstruct bnxt_tx_ring_info *txr = bnapi->tx_ring;\n\t\tu16 prod = txr->tx_prod;\n\n\t\t \n\t\twmb();\n\n\t\tbnxt_db_write_relaxed(bp, &txr->tx_db, prod);\n\t}\n\n\tcpr->cp_raw_cons = raw_cons;\n\tbnapi->tx_pkts += tx_pkts;\n\tbnapi->events |= event;\n\treturn rx_pkts;\n}\n\nstatic void __bnxt_poll_work_done(struct bnxt *bp, struct bnxt_napi *bnapi,\n\t\t\t\t  int budget)\n{\n\tif (bnapi->tx_pkts && !bnapi->tx_fault)\n\t\tbnapi->tx_int(bp, bnapi, budget);\n\n\tif ((bnapi->events & BNXT_RX_EVENT) && !(bnapi->in_reset)) {\n\t\tstruct bnxt_rx_ring_info *rxr = bnapi->rx_ring;\n\n\t\tbnxt_db_write(bp, &rxr->rx_db, rxr->rx_prod);\n\t}\n\tif (bnapi->events & BNXT_AGG_EVENT) {\n\t\tstruct bnxt_rx_ring_info *rxr = bnapi->rx_ring;\n\n\t\tbnxt_db_write(bp, &rxr->rx_agg_db, rxr->rx_agg_prod);\n\t}\n\tbnapi->events = 0;\n}\n\nstatic int bnxt_poll_work(struct bnxt *bp, struct bnxt_cp_ring_info *cpr,\n\t\t\t  int budget)\n{\n\tstruct bnxt_napi *bnapi = cpr->bnapi;\n\tint rx_pkts;\n\n\trx_pkts = __bnxt_poll_work(bp, cpr, budget);\n\n\t \n\tbnxt_db_cq(bp, &cpr->cp_db, cpr->cp_raw_cons);\n\n\t__bnxt_poll_work_done(bp, bnapi, budget);\n\treturn rx_pkts;\n}\n\nstatic int bnxt_poll_nitroa0(struct napi_struct *napi, int budget)\n{\n\tstruct bnxt_napi *bnapi = container_of(napi, struct bnxt_napi, napi);\n\tstruct bnxt *bp = bnapi->bp;\n\tstruct bnxt_cp_ring_info *cpr = &bnapi->cp_ring;\n\tstruct bnxt_rx_ring_info *rxr = bnapi->rx_ring;\n\tstruct tx_cmp *txcmp;\n\tstruct rx_cmp_ext *rxcmp1;\n\tu32 cp_cons, tmp_raw_cons;\n\tu32 raw_cons = cpr->cp_raw_cons;\n\tbool flush_xdp = false;\n\tu32 rx_pkts = 0;\n\tu8 event = 0;\n\n\twhile (1) {\n\t\tint rc;\n\n\t\tcp_cons = RING_CMP(raw_cons);\n\t\ttxcmp = &cpr->cp_desc_ring[CP_RING(cp_cons)][CP_IDX(cp_cons)];\n\n\t\tif (!TX_CMP_VALID(txcmp, raw_cons))\n\t\t\tbreak;\n\n\t\t \n\t\tdma_rmb();\n\t\tif ((TX_CMP_TYPE(txcmp) & 0x30) == 0x10) {\n\t\t\ttmp_raw_cons = NEXT_RAW_CMP(raw_cons);\n\t\t\tcp_cons = RING_CMP(tmp_raw_cons);\n\t\t\trxcmp1 = (struct rx_cmp_ext *)\n\t\t\t  &cpr->cp_desc_ring[CP_RING(cp_cons)][CP_IDX(cp_cons)];\n\n\t\t\tif (!RX_CMP_VALID(rxcmp1, tmp_raw_cons))\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\trxcmp1->rx_cmp_cfa_code_errors_v2 |=\n\t\t\t\tcpu_to_le32(RX_CMPL_ERRORS_CRC_ERROR);\n\n\t\t\trc = bnxt_rx_pkt(bp, cpr, &raw_cons, &event);\n\t\t\tif (likely(rc == -EIO) && budget)\n\t\t\t\trx_pkts++;\n\t\t\telse if (rc == -EBUSY)\t \n\t\t\t\tbreak;\n\t\t\tif (event & BNXT_REDIRECT_EVENT)\n\t\t\t\tflush_xdp = true;\n\t\t} else if (unlikely(TX_CMP_TYPE(txcmp) ==\n\t\t\t\t    CMPL_BASE_TYPE_HWRM_DONE)) {\n\t\t\tbnxt_hwrm_handler(bp, txcmp);\n\t\t} else {\n\t\t\tnetdev_err(bp->dev,\n\t\t\t\t   \"Invalid completion received on special ring\\n\");\n\t\t}\n\t\traw_cons = NEXT_RAW_CMP(raw_cons);\n\n\t\tif (rx_pkts == budget)\n\t\t\tbreak;\n\t}\n\n\tcpr->cp_raw_cons = raw_cons;\n\tBNXT_DB_CQ(&cpr->cp_db, cpr->cp_raw_cons);\n\tbnxt_db_write(bp, &rxr->rx_db, rxr->rx_prod);\n\n\tif (event & BNXT_AGG_EVENT)\n\t\tbnxt_db_write(bp, &rxr->rx_agg_db, rxr->rx_agg_prod);\n\tif (flush_xdp)\n\t\txdp_do_flush();\n\n\tif (!bnxt_has_work(bp, cpr) && rx_pkts < budget) {\n\t\tnapi_complete_done(napi, rx_pkts);\n\t\tBNXT_DB_CQ_ARM(&cpr->cp_db, cpr->cp_raw_cons);\n\t}\n\treturn rx_pkts;\n}\n\nstatic int bnxt_poll(struct napi_struct *napi, int budget)\n{\n\tstruct bnxt_napi *bnapi = container_of(napi, struct bnxt_napi, napi);\n\tstruct bnxt *bp = bnapi->bp;\n\tstruct bnxt_cp_ring_info *cpr = &bnapi->cp_ring;\n\tint work_done = 0;\n\n\tif (unlikely(test_bit(BNXT_STATE_FW_FATAL_COND, &bp->state))) {\n\t\tnapi_complete(napi);\n\t\treturn 0;\n\t}\n\twhile (1) {\n\t\twork_done += bnxt_poll_work(bp, cpr, budget - work_done);\n\n\t\tif (work_done >= budget) {\n\t\t\tif (!budget)\n\t\t\t\tBNXT_DB_CQ_ARM(&cpr->cp_db, cpr->cp_raw_cons);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!bnxt_has_work(bp, cpr)) {\n\t\t\tif (napi_complete_done(napi, work_done))\n\t\t\t\tBNXT_DB_CQ_ARM(&cpr->cp_db, cpr->cp_raw_cons);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (bp->flags & BNXT_FLAG_DIM) {\n\t\tstruct dim_sample dim_sample = {};\n\n\t\tdim_update_sample(cpr->event_ctr,\n\t\t\t\t  cpr->rx_packets,\n\t\t\t\t  cpr->rx_bytes,\n\t\t\t\t  &dim_sample);\n\t\tnet_dim(&cpr->dim, dim_sample);\n\t}\n\treturn work_done;\n}\n\nstatic int __bnxt_poll_cqs(struct bnxt *bp, struct bnxt_napi *bnapi, int budget)\n{\n\tstruct bnxt_cp_ring_info *cpr = &bnapi->cp_ring;\n\tint i, work_done = 0;\n\n\tfor (i = 0; i < 2; i++) {\n\t\tstruct bnxt_cp_ring_info *cpr2 = cpr->cp_ring_arr[i];\n\n\t\tif (cpr2) {\n\t\t\twork_done += __bnxt_poll_work(bp, cpr2,\n\t\t\t\t\t\t      budget - work_done);\n\t\t\tcpr->has_more_work |= cpr2->has_more_work;\n\t\t}\n\t}\n\treturn work_done;\n}\n\nstatic void __bnxt_poll_cqs_done(struct bnxt *bp, struct bnxt_napi *bnapi,\n\t\t\t\t u64 dbr_type, int budget)\n{\n\tstruct bnxt_cp_ring_info *cpr = &bnapi->cp_ring;\n\tint i;\n\n\tfor (i = 0; i < 2; i++) {\n\t\tstruct bnxt_cp_ring_info *cpr2 = cpr->cp_ring_arr[i];\n\t\tstruct bnxt_db_info *db;\n\n\t\tif (cpr2 && cpr2->had_work_done) {\n\t\t\tdb = &cpr2->cp_db;\n\t\t\tbnxt_writeq(bp, db->db_key64 | dbr_type |\n\t\t\t\t    RING_CMP(cpr2->cp_raw_cons), db->doorbell);\n\t\t\tcpr2->had_work_done = 0;\n\t\t}\n\t}\n\t__bnxt_poll_work_done(bp, bnapi, budget);\n}\n\nstatic int bnxt_poll_p5(struct napi_struct *napi, int budget)\n{\n\tstruct bnxt_napi *bnapi = container_of(napi, struct bnxt_napi, napi);\n\tstruct bnxt_cp_ring_info *cpr = &bnapi->cp_ring;\n\tstruct bnxt_cp_ring_info *cpr_rx;\n\tu32 raw_cons = cpr->cp_raw_cons;\n\tstruct bnxt *bp = bnapi->bp;\n\tstruct nqe_cn *nqcmp;\n\tint work_done = 0;\n\tu32 cons;\n\n\tif (unlikely(test_bit(BNXT_STATE_FW_FATAL_COND, &bp->state))) {\n\t\tnapi_complete(napi);\n\t\treturn 0;\n\t}\n\tif (cpr->has_more_work) {\n\t\tcpr->has_more_work = 0;\n\t\twork_done = __bnxt_poll_cqs(bp, bnapi, budget);\n\t}\n\twhile (1) {\n\t\tcons = RING_CMP(raw_cons);\n\t\tnqcmp = &cpr->nq_desc_ring[CP_RING(cons)][CP_IDX(cons)];\n\n\t\tif (!NQ_CMP_VALID(nqcmp, raw_cons)) {\n\t\t\tif (cpr->has_more_work)\n\t\t\t\tbreak;\n\n\t\t\t__bnxt_poll_cqs_done(bp, bnapi, DBR_TYPE_CQ_ARMALL,\n\t\t\t\t\t     budget);\n\t\t\tcpr->cp_raw_cons = raw_cons;\n\t\t\tif (napi_complete_done(napi, work_done))\n\t\t\t\tBNXT_DB_NQ_ARM_P5(&cpr->cp_db,\n\t\t\t\t\t\t  cpr->cp_raw_cons);\n\t\t\tgoto poll_done;\n\t\t}\n\n\t\t \n\t\tdma_rmb();\n\n\t\tif (nqcmp->type == cpu_to_le16(NQ_CN_TYPE_CQ_NOTIFICATION)) {\n\t\t\tu32 idx = le32_to_cpu(nqcmp->cq_handle_low);\n\t\t\tstruct bnxt_cp_ring_info *cpr2;\n\n\t\t\t \n\t\t\tif (budget && work_done >= budget && idx == BNXT_RX_HDL)\n\t\t\t\tbreak;\n\n\t\t\tcpr2 = cpr->cp_ring_arr[idx];\n\t\t\twork_done += __bnxt_poll_work(bp, cpr2,\n\t\t\t\t\t\t      budget - work_done);\n\t\t\tcpr->has_more_work |= cpr2->has_more_work;\n\t\t} else {\n\t\t\tbnxt_hwrm_handler(bp, (struct tx_cmp *)nqcmp);\n\t\t}\n\t\traw_cons = NEXT_RAW_CMP(raw_cons);\n\t}\n\t__bnxt_poll_cqs_done(bp, bnapi, DBR_TYPE_CQ, budget);\n\tif (raw_cons != cpr->cp_raw_cons) {\n\t\tcpr->cp_raw_cons = raw_cons;\n\t\tBNXT_DB_NQ_P5(&cpr->cp_db, raw_cons);\n\t}\npoll_done:\n\tcpr_rx = cpr->cp_ring_arr[BNXT_RX_HDL];\n\tif (cpr_rx && (bp->flags & BNXT_FLAG_DIM)) {\n\t\tstruct dim_sample dim_sample = {};\n\n\t\tdim_update_sample(cpr->event_ctr,\n\t\t\t\t  cpr_rx->rx_packets,\n\t\t\t\t  cpr_rx->rx_bytes,\n\t\t\t\t  &dim_sample);\n\t\tnet_dim(&cpr->dim, dim_sample);\n\t}\n\treturn work_done;\n}\n\nstatic void bnxt_free_tx_skbs(struct bnxt *bp)\n{\n\tint i, max_idx;\n\tstruct pci_dev *pdev = bp->pdev;\n\n\tif (!bp->tx_ring)\n\t\treturn;\n\n\tmax_idx = bp->tx_nr_pages * TX_DESC_CNT;\n\tfor (i = 0; i < bp->tx_nr_rings; i++) {\n\t\tstruct bnxt_tx_ring_info *txr = &bp->tx_ring[i];\n\t\tint j;\n\n\t\tif (!txr->tx_buf_ring)\n\t\t\tcontinue;\n\n\t\tfor (j = 0; j < max_idx;) {\n\t\t\tstruct bnxt_sw_tx_bd *tx_buf = &txr->tx_buf_ring[j];\n\t\t\tstruct sk_buff *skb;\n\t\t\tint k, last;\n\n\t\t\tif (i < bp->tx_nr_rings_xdp &&\n\t\t\t    tx_buf->action == XDP_REDIRECT) {\n\t\t\t\tdma_unmap_single(&pdev->dev,\n\t\t\t\t\tdma_unmap_addr(tx_buf, mapping),\n\t\t\t\t\tdma_unmap_len(tx_buf, len),\n\t\t\t\t\tDMA_TO_DEVICE);\n\t\t\t\txdp_return_frame(tx_buf->xdpf);\n\t\t\t\ttx_buf->action = 0;\n\t\t\t\ttx_buf->xdpf = NULL;\n\t\t\t\tj++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tskb = tx_buf->skb;\n\t\t\tif (!skb) {\n\t\t\t\tj++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\ttx_buf->skb = NULL;\n\n\t\t\tif (tx_buf->is_push) {\n\t\t\t\tdev_kfree_skb(skb);\n\t\t\t\tj += 2;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tdma_unmap_single(&pdev->dev,\n\t\t\t\t\t dma_unmap_addr(tx_buf, mapping),\n\t\t\t\t\t skb_headlen(skb),\n\t\t\t\t\t DMA_TO_DEVICE);\n\n\t\t\tlast = tx_buf->nr_frags;\n\t\t\tj += 2;\n\t\t\tfor (k = 0; k < last; k++, j++) {\n\t\t\t\tint ring_idx = j & bp->tx_ring_mask;\n\t\t\t\tskb_frag_t *frag = &skb_shinfo(skb)->frags[k];\n\n\t\t\t\ttx_buf = &txr->tx_buf_ring[ring_idx];\n\t\t\t\tdma_unmap_page(\n\t\t\t\t\t&pdev->dev,\n\t\t\t\t\tdma_unmap_addr(tx_buf, mapping),\n\t\t\t\t\tskb_frag_size(frag), DMA_TO_DEVICE);\n\t\t\t}\n\t\t\tdev_kfree_skb(skb);\n\t\t}\n\t\tnetdev_tx_reset_queue(netdev_get_tx_queue(bp->dev, i));\n\t}\n}\n\nstatic void bnxt_free_one_rx_ring_skbs(struct bnxt *bp, int ring_nr)\n{\n\tstruct bnxt_rx_ring_info *rxr = &bp->rx_ring[ring_nr];\n\tstruct pci_dev *pdev = bp->pdev;\n\tstruct bnxt_tpa_idx_map *map;\n\tint i, max_idx, max_agg_idx;\n\n\tmax_idx = bp->rx_nr_pages * RX_DESC_CNT;\n\tmax_agg_idx = bp->rx_agg_nr_pages * RX_DESC_CNT;\n\tif (!rxr->rx_tpa)\n\t\tgoto skip_rx_tpa_free;\n\n\tfor (i = 0; i < bp->max_tpa; i++) {\n\t\tstruct bnxt_tpa_info *tpa_info = &rxr->rx_tpa[i];\n\t\tu8 *data = tpa_info->data;\n\n\t\tif (!data)\n\t\t\tcontinue;\n\n\t\tdma_unmap_single_attrs(&pdev->dev, tpa_info->mapping,\n\t\t\t\t       bp->rx_buf_use_size, bp->rx_dir,\n\t\t\t\t       DMA_ATTR_WEAK_ORDERING);\n\n\t\ttpa_info->data = NULL;\n\n\t\tskb_free_frag(data);\n\t}\n\nskip_rx_tpa_free:\n\tif (!rxr->rx_buf_ring)\n\t\tgoto skip_rx_buf_free;\n\n\tfor (i = 0; i < max_idx; i++) {\n\t\tstruct bnxt_sw_rx_bd *rx_buf = &rxr->rx_buf_ring[i];\n\t\tdma_addr_t mapping = rx_buf->mapping;\n\t\tvoid *data = rx_buf->data;\n\n\t\tif (!data)\n\t\t\tcontinue;\n\n\t\trx_buf->data = NULL;\n\t\tif (BNXT_RX_PAGE_MODE(bp)) {\n\t\t\tpage_pool_recycle_direct(rxr->page_pool, data);\n\t\t} else {\n\t\t\tdma_unmap_single_attrs(&pdev->dev, mapping,\n\t\t\t\t\t       bp->rx_buf_use_size, bp->rx_dir,\n\t\t\t\t\t       DMA_ATTR_WEAK_ORDERING);\n\t\t\tskb_free_frag(data);\n\t\t}\n\t}\n\nskip_rx_buf_free:\n\tif (!rxr->rx_agg_ring)\n\t\tgoto skip_rx_agg_free;\n\n\tfor (i = 0; i < max_agg_idx; i++) {\n\t\tstruct bnxt_sw_rx_agg_bd *rx_agg_buf = &rxr->rx_agg_ring[i];\n\t\tstruct page *page = rx_agg_buf->page;\n\n\t\tif (!page)\n\t\t\tcontinue;\n\n\t\trx_agg_buf->page = NULL;\n\t\t__clear_bit(i, rxr->rx_agg_bmap);\n\n\t\tpage_pool_recycle_direct(rxr->page_pool, page);\n\t}\n\nskip_rx_agg_free:\n\tmap = rxr->rx_tpa_idx_map;\n\tif (map)\n\t\tmemset(map->agg_idx_bmap, 0, sizeof(map->agg_idx_bmap));\n}\n\nstatic void bnxt_free_rx_skbs(struct bnxt *bp)\n{\n\tint i;\n\n\tif (!bp->rx_ring)\n\t\treturn;\n\n\tfor (i = 0; i < bp->rx_nr_rings; i++)\n\t\tbnxt_free_one_rx_ring_skbs(bp, i);\n}\n\nstatic void bnxt_free_skbs(struct bnxt *bp)\n{\n\tbnxt_free_tx_skbs(bp);\n\tbnxt_free_rx_skbs(bp);\n}\n\nstatic void bnxt_init_ctx_mem(struct bnxt_mem_init *mem_init, void *p, int len)\n{\n\tu8 init_val = mem_init->init_val;\n\tu16 offset = mem_init->offset;\n\tu8 *p2 = p;\n\tint i;\n\n\tif (!init_val)\n\t\treturn;\n\tif (offset == BNXT_MEM_INVALID_OFFSET) {\n\t\tmemset(p, init_val, len);\n\t\treturn;\n\t}\n\tfor (i = 0; i < len; i += mem_init->size)\n\t\t*(p2 + i + offset) = init_val;\n}\n\nstatic void bnxt_free_ring(struct bnxt *bp, struct bnxt_ring_mem_info *rmem)\n{\n\tstruct pci_dev *pdev = bp->pdev;\n\tint i;\n\n\tif (!rmem->pg_arr)\n\t\tgoto skip_pages;\n\n\tfor (i = 0; i < rmem->nr_pages; i++) {\n\t\tif (!rmem->pg_arr[i])\n\t\t\tcontinue;\n\n\t\tdma_free_coherent(&pdev->dev, rmem->page_size,\n\t\t\t\t  rmem->pg_arr[i], rmem->dma_arr[i]);\n\n\t\trmem->pg_arr[i] = NULL;\n\t}\nskip_pages:\n\tif (rmem->pg_tbl) {\n\t\tsize_t pg_tbl_size = rmem->nr_pages * 8;\n\n\t\tif (rmem->flags & BNXT_RMEM_USE_FULL_PAGE_FLAG)\n\t\t\tpg_tbl_size = rmem->page_size;\n\t\tdma_free_coherent(&pdev->dev, pg_tbl_size,\n\t\t\t\t  rmem->pg_tbl, rmem->pg_tbl_map);\n\t\trmem->pg_tbl = NULL;\n\t}\n\tif (rmem->vmem_size && *rmem->vmem) {\n\t\tvfree(*rmem->vmem);\n\t\t*rmem->vmem = NULL;\n\t}\n}\n\nstatic int bnxt_alloc_ring(struct bnxt *bp, struct bnxt_ring_mem_info *rmem)\n{\n\tstruct pci_dev *pdev = bp->pdev;\n\tu64 valid_bit = 0;\n\tint i;\n\n\tif (rmem->flags & (BNXT_RMEM_VALID_PTE_FLAG | BNXT_RMEM_RING_PTE_FLAG))\n\t\tvalid_bit = PTU_PTE_VALID;\n\tif ((rmem->nr_pages > 1 || rmem->depth > 0) && !rmem->pg_tbl) {\n\t\tsize_t pg_tbl_size = rmem->nr_pages * 8;\n\n\t\tif (rmem->flags & BNXT_RMEM_USE_FULL_PAGE_FLAG)\n\t\t\tpg_tbl_size = rmem->page_size;\n\t\trmem->pg_tbl = dma_alloc_coherent(&pdev->dev, pg_tbl_size,\n\t\t\t\t\t\t  &rmem->pg_tbl_map,\n\t\t\t\t\t\t  GFP_KERNEL);\n\t\tif (!rmem->pg_tbl)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tfor (i = 0; i < rmem->nr_pages; i++) {\n\t\tu64 extra_bits = valid_bit;\n\n\t\trmem->pg_arr[i] = dma_alloc_coherent(&pdev->dev,\n\t\t\t\t\t\t     rmem->page_size,\n\t\t\t\t\t\t     &rmem->dma_arr[i],\n\t\t\t\t\t\t     GFP_KERNEL);\n\t\tif (!rmem->pg_arr[i])\n\t\t\treturn -ENOMEM;\n\n\t\tif (rmem->mem_init)\n\t\t\tbnxt_init_ctx_mem(rmem->mem_init, rmem->pg_arr[i],\n\t\t\t\t\t  rmem->page_size);\n\t\tif (rmem->nr_pages > 1 || rmem->depth > 0) {\n\t\t\tif (i == rmem->nr_pages - 2 &&\n\t\t\t    (rmem->flags & BNXT_RMEM_RING_PTE_FLAG))\n\t\t\t\textra_bits |= PTU_PTE_NEXT_TO_LAST;\n\t\t\telse if (i == rmem->nr_pages - 1 &&\n\t\t\t\t (rmem->flags & BNXT_RMEM_RING_PTE_FLAG))\n\t\t\t\textra_bits |= PTU_PTE_LAST;\n\t\t\trmem->pg_tbl[i] =\n\t\t\t\tcpu_to_le64(rmem->dma_arr[i] | extra_bits);\n\t\t}\n\t}\n\n\tif (rmem->vmem_size) {\n\t\t*rmem->vmem = vzalloc(rmem->vmem_size);\n\t\tif (!(*rmem->vmem))\n\t\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}\n\nstatic void bnxt_free_tpa_info(struct bnxt *bp)\n{\n\tint i, j;\n\n\tfor (i = 0; i < bp->rx_nr_rings; i++) {\n\t\tstruct bnxt_rx_ring_info *rxr = &bp->rx_ring[i];\n\n\t\tkfree(rxr->rx_tpa_idx_map);\n\t\trxr->rx_tpa_idx_map = NULL;\n\t\tif (rxr->rx_tpa) {\n\t\t\tfor (j = 0; j < bp->max_tpa; j++) {\n\t\t\t\tkfree(rxr->rx_tpa[j].agg_arr);\n\t\t\t\trxr->rx_tpa[j].agg_arr = NULL;\n\t\t\t}\n\t\t}\n\t\tkfree(rxr->rx_tpa);\n\t\trxr->rx_tpa = NULL;\n\t}\n}\n\nstatic int bnxt_alloc_tpa_info(struct bnxt *bp)\n{\n\tint i, j;\n\n\tbp->max_tpa = MAX_TPA;\n\tif (bp->flags & BNXT_FLAG_CHIP_P5) {\n\t\tif (!bp->max_tpa_v2)\n\t\t\treturn 0;\n\t\tbp->max_tpa = max_t(u16, bp->max_tpa_v2, MAX_TPA_P5);\n\t}\n\n\tfor (i = 0; i < bp->rx_nr_rings; i++) {\n\t\tstruct bnxt_rx_ring_info *rxr = &bp->rx_ring[i];\n\t\tstruct rx_agg_cmp *agg;\n\n\t\trxr->rx_tpa = kcalloc(bp->max_tpa, sizeof(struct bnxt_tpa_info),\n\t\t\t\t      GFP_KERNEL);\n\t\tif (!rxr->rx_tpa)\n\t\t\treturn -ENOMEM;\n\n\t\tif (!(bp->flags & BNXT_FLAG_CHIP_P5))\n\t\t\tcontinue;\n\t\tfor (j = 0; j < bp->max_tpa; j++) {\n\t\t\tagg = kcalloc(MAX_SKB_FRAGS, sizeof(*agg), GFP_KERNEL);\n\t\t\tif (!agg)\n\t\t\t\treturn -ENOMEM;\n\t\t\trxr->rx_tpa[j].agg_arr = agg;\n\t\t}\n\t\trxr->rx_tpa_idx_map = kzalloc(sizeof(*rxr->rx_tpa_idx_map),\n\t\t\t\t\t      GFP_KERNEL);\n\t\tif (!rxr->rx_tpa_idx_map)\n\t\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}\n\nstatic void bnxt_free_rx_rings(struct bnxt *bp)\n{\n\tint i;\n\n\tif (!bp->rx_ring)\n\t\treturn;\n\n\tbnxt_free_tpa_info(bp);\n\tfor (i = 0; i < bp->rx_nr_rings; i++) {\n\t\tstruct bnxt_rx_ring_info *rxr = &bp->rx_ring[i];\n\t\tstruct bnxt_ring_struct *ring;\n\n\t\tif (rxr->xdp_prog)\n\t\t\tbpf_prog_put(rxr->xdp_prog);\n\n\t\tif (xdp_rxq_info_is_reg(&rxr->xdp_rxq))\n\t\t\txdp_rxq_info_unreg(&rxr->xdp_rxq);\n\n\t\tpage_pool_destroy(rxr->page_pool);\n\t\trxr->page_pool = NULL;\n\n\t\tkfree(rxr->rx_agg_bmap);\n\t\trxr->rx_agg_bmap = NULL;\n\n\t\tring = &rxr->rx_ring_struct;\n\t\tbnxt_free_ring(bp, &ring->ring_mem);\n\n\t\tring = &rxr->rx_agg_ring_struct;\n\t\tbnxt_free_ring(bp, &ring->ring_mem);\n\t}\n}\n\nstatic int bnxt_alloc_rx_page_pool(struct bnxt *bp,\n\t\t\t\t   struct bnxt_rx_ring_info *rxr)\n{\n\tstruct page_pool_params pp = { 0 };\n\n\tpp.pool_size = bp->rx_agg_ring_size;\n\tif (BNXT_RX_PAGE_MODE(bp))\n\t\tpp.pool_size += bp->rx_ring_size;\n\tpp.nid = dev_to_node(&bp->pdev->dev);\n\tpp.napi = &rxr->bnapi->napi;\n\tpp.dev = &bp->pdev->dev;\n\tpp.dma_dir = bp->rx_dir;\n\tpp.max_len = PAGE_SIZE;\n\tpp.flags = PP_FLAG_DMA_MAP | PP_FLAG_DMA_SYNC_DEV;\n\tif (PAGE_SIZE > BNXT_RX_PAGE_SIZE)\n\t\tpp.flags |= PP_FLAG_PAGE_FRAG;\n\n\trxr->page_pool = page_pool_create(&pp);\n\tif (IS_ERR(rxr->page_pool)) {\n\t\tint err = PTR_ERR(rxr->page_pool);\n\n\t\trxr->page_pool = NULL;\n\t\treturn err;\n\t}\n\treturn 0;\n}\n\nstatic int bnxt_alloc_rx_rings(struct bnxt *bp)\n{\n\tint i, rc = 0, agg_rings = 0;\n\n\tif (!bp->rx_ring)\n\t\treturn -ENOMEM;\n\n\tif (bp->flags & BNXT_FLAG_AGG_RINGS)\n\t\tagg_rings = 1;\n\n\tfor (i = 0; i < bp->rx_nr_rings; i++) {\n\t\tstruct bnxt_rx_ring_info *rxr = &bp->rx_ring[i];\n\t\tstruct bnxt_ring_struct *ring;\n\n\t\tring = &rxr->rx_ring_struct;\n\n\t\trc = bnxt_alloc_rx_page_pool(bp, rxr);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\trc = xdp_rxq_info_reg(&rxr->xdp_rxq, bp->dev, i, 0);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\trc = xdp_rxq_info_reg_mem_model(&rxr->xdp_rxq,\n\t\t\t\t\t\tMEM_TYPE_PAGE_POOL,\n\t\t\t\t\t\trxr->page_pool);\n\t\tif (rc) {\n\t\t\txdp_rxq_info_unreg(&rxr->xdp_rxq);\n\t\t\treturn rc;\n\t\t}\n\n\t\trc = bnxt_alloc_ring(bp, &ring->ring_mem);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\tring->grp_idx = i;\n\t\tif (agg_rings) {\n\t\t\tu16 mem_size;\n\n\t\t\tring = &rxr->rx_agg_ring_struct;\n\t\t\trc = bnxt_alloc_ring(bp, &ring->ring_mem);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\n\t\t\tring->grp_idx = i;\n\t\t\trxr->rx_agg_bmap_size = bp->rx_agg_ring_mask + 1;\n\t\t\tmem_size = rxr->rx_agg_bmap_size / 8;\n\t\t\trxr->rx_agg_bmap = kzalloc(mem_size, GFP_KERNEL);\n\t\t\tif (!rxr->rx_agg_bmap)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\tif (bp->flags & BNXT_FLAG_TPA)\n\t\trc = bnxt_alloc_tpa_info(bp);\n\treturn rc;\n}\n\nstatic void bnxt_free_tx_rings(struct bnxt *bp)\n{\n\tint i;\n\tstruct pci_dev *pdev = bp->pdev;\n\n\tif (!bp->tx_ring)\n\t\treturn;\n\n\tfor (i = 0; i < bp->tx_nr_rings; i++) {\n\t\tstruct bnxt_tx_ring_info *txr = &bp->tx_ring[i];\n\t\tstruct bnxt_ring_struct *ring;\n\n\t\tif (txr->tx_push) {\n\t\t\tdma_free_coherent(&pdev->dev, bp->tx_push_size,\n\t\t\t\t\t  txr->tx_push, txr->tx_push_mapping);\n\t\t\ttxr->tx_push = NULL;\n\t\t}\n\n\t\tring = &txr->tx_ring_struct;\n\n\t\tbnxt_free_ring(bp, &ring->ring_mem);\n\t}\n}\n\nstatic int bnxt_alloc_tx_rings(struct bnxt *bp)\n{\n\tint i, j, rc;\n\tstruct pci_dev *pdev = bp->pdev;\n\n\tbp->tx_push_size = 0;\n\tif (bp->tx_push_thresh) {\n\t\tint push_size;\n\n\t\tpush_size  = L1_CACHE_ALIGN(sizeof(struct tx_push_bd) +\n\t\t\t\t\tbp->tx_push_thresh);\n\n\t\tif (push_size > 256) {\n\t\t\tpush_size = 0;\n\t\t\tbp->tx_push_thresh = 0;\n\t\t}\n\n\t\tbp->tx_push_size = push_size;\n\t}\n\n\tfor (i = 0, j = 0; i < bp->tx_nr_rings; i++) {\n\t\tstruct bnxt_tx_ring_info *txr = &bp->tx_ring[i];\n\t\tstruct bnxt_ring_struct *ring;\n\t\tu8 qidx;\n\n\t\tring = &txr->tx_ring_struct;\n\n\t\trc = bnxt_alloc_ring(bp, &ring->ring_mem);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\tring->grp_idx = txr->bnapi->index;\n\t\tif (bp->tx_push_size) {\n\t\t\tdma_addr_t mapping;\n\n\t\t\t \n\t\t\ttxr->tx_push = dma_alloc_coherent(&pdev->dev,\n\t\t\t\t\t\tbp->tx_push_size,\n\t\t\t\t\t\t&txr->tx_push_mapping,\n\t\t\t\t\t\tGFP_KERNEL);\n\n\t\t\tif (!txr->tx_push)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tmapping = txr->tx_push_mapping +\n\t\t\t\tsizeof(struct tx_push_bd);\n\t\t\ttxr->data_mapping = cpu_to_le64(mapping);\n\t\t}\n\t\tqidx = bp->tc_to_qidx[j];\n\t\tring->queue_id = bp->q_info[qidx].queue_id;\n\t\tspin_lock_init(&txr->xdp_tx_lock);\n\t\tif (i < bp->tx_nr_rings_xdp)\n\t\t\tcontinue;\n\t\tif (i % bp->tx_nr_rings_per_tc == (bp->tx_nr_rings_per_tc - 1))\n\t\t\tj++;\n\t}\n\treturn 0;\n}\n\nstatic void bnxt_free_cp_arrays(struct bnxt_cp_ring_info *cpr)\n{\n\tstruct bnxt_ring_struct *ring = &cpr->cp_ring_struct;\n\n\tkfree(cpr->cp_desc_ring);\n\tcpr->cp_desc_ring = NULL;\n\tring->ring_mem.pg_arr = NULL;\n\tkfree(cpr->cp_desc_mapping);\n\tcpr->cp_desc_mapping = NULL;\n\tring->ring_mem.dma_arr = NULL;\n}\n\nstatic int bnxt_alloc_cp_arrays(struct bnxt_cp_ring_info *cpr, int n)\n{\n\tcpr->cp_desc_ring = kcalloc(n, sizeof(*cpr->cp_desc_ring), GFP_KERNEL);\n\tif (!cpr->cp_desc_ring)\n\t\treturn -ENOMEM;\n\tcpr->cp_desc_mapping = kcalloc(n, sizeof(*cpr->cp_desc_mapping),\n\t\t\t\t       GFP_KERNEL);\n\tif (!cpr->cp_desc_mapping)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nstatic void bnxt_free_all_cp_arrays(struct bnxt *bp)\n{\n\tint i;\n\n\tif (!bp->bnapi)\n\t\treturn;\n\tfor (i = 0; i < bp->cp_nr_rings; i++) {\n\t\tstruct bnxt_napi *bnapi = bp->bnapi[i];\n\n\t\tif (!bnapi)\n\t\t\tcontinue;\n\t\tbnxt_free_cp_arrays(&bnapi->cp_ring);\n\t}\n}\n\nstatic int bnxt_alloc_all_cp_arrays(struct bnxt *bp)\n{\n\tint i, n = bp->cp_nr_pages;\n\n\tfor (i = 0; i < bp->cp_nr_rings; i++) {\n\t\tstruct bnxt_napi *bnapi = bp->bnapi[i];\n\t\tint rc;\n\n\t\tif (!bnapi)\n\t\t\tcontinue;\n\t\trc = bnxt_alloc_cp_arrays(&bnapi->cp_ring, n);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\treturn 0;\n}\n\nstatic void bnxt_free_cp_rings(struct bnxt *bp)\n{\n\tint i;\n\n\tif (!bp->bnapi)\n\t\treturn;\n\n\tfor (i = 0; i < bp->cp_nr_rings; i++) {\n\t\tstruct bnxt_napi *bnapi = bp->bnapi[i];\n\t\tstruct bnxt_cp_ring_info *cpr;\n\t\tstruct bnxt_ring_struct *ring;\n\t\tint j;\n\n\t\tif (!bnapi)\n\t\t\tcontinue;\n\n\t\tcpr = &bnapi->cp_ring;\n\t\tring = &cpr->cp_ring_struct;\n\n\t\tbnxt_free_ring(bp, &ring->ring_mem);\n\n\t\tfor (j = 0; j < 2; j++) {\n\t\t\tstruct bnxt_cp_ring_info *cpr2 = cpr->cp_ring_arr[j];\n\n\t\t\tif (cpr2) {\n\t\t\t\tring = &cpr2->cp_ring_struct;\n\t\t\t\tbnxt_free_ring(bp, &ring->ring_mem);\n\t\t\t\tbnxt_free_cp_arrays(cpr2);\n\t\t\t\tkfree(cpr2);\n\t\t\t\tcpr->cp_ring_arr[j] = NULL;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic struct bnxt_cp_ring_info *bnxt_alloc_cp_sub_ring(struct bnxt *bp)\n{\n\tstruct bnxt_ring_mem_info *rmem;\n\tstruct bnxt_ring_struct *ring;\n\tstruct bnxt_cp_ring_info *cpr;\n\tint rc;\n\n\tcpr = kzalloc(sizeof(*cpr), GFP_KERNEL);\n\tif (!cpr)\n\t\treturn NULL;\n\n\trc = bnxt_alloc_cp_arrays(cpr, bp->cp_nr_pages);\n\tif (rc) {\n\t\tbnxt_free_cp_arrays(cpr);\n\t\tkfree(cpr);\n\t\treturn NULL;\n\t}\n\tring = &cpr->cp_ring_struct;\n\trmem = &ring->ring_mem;\n\trmem->nr_pages = bp->cp_nr_pages;\n\trmem->page_size = HW_CMPD_RING_SIZE;\n\trmem->pg_arr = (void **)cpr->cp_desc_ring;\n\trmem->dma_arr = cpr->cp_desc_mapping;\n\trmem->flags = BNXT_RMEM_RING_PTE_FLAG;\n\trc = bnxt_alloc_ring(bp, rmem);\n\tif (rc) {\n\t\tbnxt_free_ring(bp, rmem);\n\t\tbnxt_free_cp_arrays(cpr);\n\t\tkfree(cpr);\n\t\tcpr = NULL;\n\t}\n\treturn cpr;\n}\n\nstatic int bnxt_alloc_cp_rings(struct bnxt *bp)\n{\n\tbool sh = !!(bp->flags & BNXT_FLAG_SHARED_RINGS);\n\tint i, rc, ulp_base_vec, ulp_msix;\n\n\tulp_msix = bnxt_get_ulp_msix_num(bp);\n\tulp_base_vec = bnxt_get_ulp_msix_base(bp);\n\tfor (i = 0; i < bp->cp_nr_rings; i++) {\n\t\tstruct bnxt_napi *bnapi = bp->bnapi[i];\n\t\tstruct bnxt_cp_ring_info *cpr;\n\t\tstruct bnxt_ring_struct *ring;\n\n\t\tif (!bnapi)\n\t\t\tcontinue;\n\n\t\tcpr = &bnapi->cp_ring;\n\t\tcpr->bnapi = bnapi;\n\t\tring = &cpr->cp_ring_struct;\n\n\t\trc = bnxt_alloc_ring(bp, &ring->ring_mem);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\tif (ulp_msix && i >= ulp_base_vec)\n\t\t\tring->map_idx = i + ulp_msix;\n\t\telse\n\t\t\tring->map_idx = i;\n\n\t\tif (!(bp->flags & BNXT_FLAG_CHIP_P5))\n\t\t\tcontinue;\n\n\t\tif (i < bp->rx_nr_rings) {\n\t\t\tstruct bnxt_cp_ring_info *cpr2 =\n\t\t\t\tbnxt_alloc_cp_sub_ring(bp);\n\n\t\t\tcpr->cp_ring_arr[BNXT_RX_HDL] = cpr2;\n\t\t\tif (!cpr2)\n\t\t\t\treturn -ENOMEM;\n\t\t\tcpr2->bnapi = bnapi;\n\t\t}\n\t\tif ((sh && i < bp->tx_nr_rings) ||\n\t\t    (!sh && i >= bp->rx_nr_rings)) {\n\t\t\tstruct bnxt_cp_ring_info *cpr2 =\n\t\t\t\tbnxt_alloc_cp_sub_ring(bp);\n\n\t\t\tcpr->cp_ring_arr[BNXT_TX_HDL] = cpr2;\n\t\t\tif (!cpr2)\n\t\t\t\treturn -ENOMEM;\n\t\t\tcpr2->bnapi = bnapi;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void bnxt_init_ring_struct(struct bnxt *bp)\n{\n\tint i;\n\n\tfor (i = 0; i < bp->cp_nr_rings; i++) {\n\t\tstruct bnxt_napi *bnapi = bp->bnapi[i];\n\t\tstruct bnxt_ring_mem_info *rmem;\n\t\tstruct bnxt_cp_ring_info *cpr;\n\t\tstruct bnxt_rx_ring_info *rxr;\n\t\tstruct bnxt_tx_ring_info *txr;\n\t\tstruct bnxt_ring_struct *ring;\n\n\t\tif (!bnapi)\n\t\t\tcontinue;\n\n\t\tcpr = &bnapi->cp_ring;\n\t\tring = &cpr->cp_ring_struct;\n\t\trmem = &ring->ring_mem;\n\t\trmem->nr_pages = bp->cp_nr_pages;\n\t\trmem->page_size = HW_CMPD_RING_SIZE;\n\t\trmem->pg_arr = (void **)cpr->cp_desc_ring;\n\t\trmem->dma_arr = cpr->cp_desc_mapping;\n\t\trmem->vmem_size = 0;\n\n\t\trxr = bnapi->rx_ring;\n\t\tif (!rxr)\n\t\t\tgoto skip_rx;\n\n\t\tring = &rxr->rx_ring_struct;\n\t\trmem = &ring->ring_mem;\n\t\trmem->nr_pages = bp->rx_nr_pages;\n\t\trmem->page_size = HW_RXBD_RING_SIZE;\n\t\trmem->pg_arr = (void **)rxr->rx_desc_ring;\n\t\trmem->dma_arr = rxr->rx_desc_mapping;\n\t\trmem->vmem_size = SW_RXBD_RING_SIZE * bp->rx_nr_pages;\n\t\trmem->vmem = (void **)&rxr->rx_buf_ring;\n\n\t\tring = &rxr->rx_agg_ring_struct;\n\t\trmem = &ring->ring_mem;\n\t\trmem->nr_pages = bp->rx_agg_nr_pages;\n\t\trmem->page_size = HW_RXBD_RING_SIZE;\n\t\trmem->pg_arr = (void **)rxr->rx_agg_desc_ring;\n\t\trmem->dma_arr = rxr->rx_agg_desc_mapping;\n\t\trmem->vmem_size = SW_RXBD_AGG_RING_SIZE * bp->rx_agg_nr_pages;\n\t\trmem->vmem = (void **)&rxr->rx_agg_ring;\n\nskip_rx:\n\t\ttxr = bnapi->tx_ring;\n\t\tif (!txr)\n\t\t\tcontinue;\n\n\t\tring = &txr->tx_ring_struct;\n\t\trmem = &ring->ring_mem;\n\t\trmem->nr_pages = bp->tx_nr_pages;\n\t\trmem->page_size = HW_RXBD_RING_SIZE;\n\t\trmem->pg_arr = (void **)txr->tx_desc_ring;\n\t\trmem->dma_arr = txr->tx_desc_mapping;\n\t\trmem->vmem_size = SW_TXBD_RING_SIZE * bp->tx_nr_pages;\n\t\trmem->vmem = (void **)&txr->tx_buf_ring;\n\t}\n}\n\nstatic void bnxt_init_rxbd_pages(struct bnxt_ring_struct *ring, u32 type)\n{\n\tint i;\n\tu32 prod;\n\tstruct rx_bd **rx_buf_ring;\n\n\trx_buf_ring = (struct rx_bd **)ring->ring_mem.pg_arr;\n\tfor (i = 0, prod = 0; i < ring->ring_mem.nr_pages; i++) {\n\t\tint j;\n\t\tstruct rx_bd *rxbd;\n\n\t\trxbd = rx_buf_ring[i];\n\t\tif (!rxbd)\n\t\t\tcontinue;\n\n\t\tfor (j = 0; j < RX_DESC_CNT; j++, rxbd++, prod++) {\n\t\t\trxbd->rx_bd_len_flags_type = cpu_to_le32(type);\n\t\t\trxbd->rx_bd_opaque = prod;\n\t\t}\n\t}\n}\n\nstatic int bnxt_alloc_one_rx_ring(struct bnxt *bp, int ring_nr)\n{\n\tstruct bnxt_rx_ring_info *rxr = &bp->rx_ring[ring_nr];\n\tstruct net_device *dev = bp->dev;\n\tu32 prod;\n\tint i;\n\n\tprod = rxr->rx_prod;\n\tfor (i = 0; i < bp->rx_ring_size; i++) {\n\t\tif (bnxt_alloc_rx_data(bp, rxr, prod, GFP_KERNEL)) {\n\t\t\tnetdev_warn(dev, \"init'ed rx ring %d with %d/%d skbs only\\n\",\n\t\t\t\t    ring_nr, i, bp->rx_ring_size);\n\t\t\tbreak;\n\t\t}\n\t\tprod = NEXT_RX(prod);\n\t}\n\trxr->rx_prod = prod;\n\n\tif (!(bp->flags & BNXT_FLAG_AGG_RINGS))\n\t\treturn 0;\n\n\tprod = rxr->rx_agg_prod;\n\tfor (i = 0; i < bp->rx_agg_ring_size; i++) {\n\t\tif (bnxt_alloc_rx_page(bp, rxr, prod, GFP_KERNEL)) {\n\t\t\tnetdev_warn(dev, \"init'ed rx ring %d with %d/%d pages only\\n\",\n\t\t\t\t    ring_nr, i, bp->rx_ring_size);\n\t\t\tbreak;\n\t\t}\n\t\tprod = NEXT_RX_AGG(prod);\n\t}\n\trxr->rx_agg_prod = prod;\n\n\tif (rxr->rx_tpa) {\n\t\tdma_addr_t mapping;\n\t\tu8 *data;\n\n\t\tfor (i = 0; i < bp->max_tpa; i++) {\n\t\t\tdata = __bnxt_alloc_rx_frag(bp, &mapping, GFP_KERNEL);\n\t\t\tif (!data)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\trxr->rx_tpa[i].data = data;\n\t\t\trxr->rx_tpa[i].data_ptr = data + bp->rx_offset;\n\t\t\trxr->rx_tpa[i].mapping = mapping;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int bnxt_init_one_rx_ring(struct bnxt *bp, int ring_nr)\n{\n\tstruct bnxt_rx_ring_info *rxr;\n\tstruct bnxt_ring_struct *ring;\n\tu32 type;\n\n\ttype = (bp->rx_buf_use_size << RX_BD_LEN_SHIFT) |\n\t\tRX_BD_TYPE_RX_PACKET_BD | RX_BD_FLAGS_EOP;\n\n\tif (NET_IP_ALIGN == 2)\n\t\ttype |= RX_BD_FLAGS_SOP;\n\n\trxr = &bp->rx_ring[ring_nr];\n\tring = &rxr->rx_ring_struct;\n\tbnxt_init_rxbd_pages(ring, type);\n\n\tif (BNXT_RX_PAGE_MODE(bp) && bp->xdp_prog) {\n\t\tbpf_prog_add(bp->xdp_prog, 1);\n\t\trxr->xdp_prog = bp->xdp_prog;\n\t}\n\tring->fw_ring_id = INVALID_HW_RING_ID;\n\n\tring = &rxr->rx_agg_ring_struct;\n\tring->fw_ring_id = INVALID_HW_RING_ID;\n\n\tif ((bp->flags & BNXT_FLAG_AGG_RINGS)) {\n\t\ttype = ((u32)BNXT_RX_PAGE_SIZE << RX_BD_LEN_SHIFT) |\n\t\t\tRX_BD_TYPE_RX_AGG_BD | RX_BD_FLAGS_SOP;\n\n\t\tbnxt_init_rxbd_pages(ring, type);\n\t}\n\n\treturn bnxt_alloc_one_rx_ring(bp, ring_nr);\n}\n\nstatic void bnxt_init_cp_rings(struct bnxt *bp)\n{\n\tint i, j;\n\n\tfor (i = 0; i < bp->cp_nr_rings; i++) {\n\t\tstruct bnxt_cp_ring_info *cpr = &bp->bnapi[i]->cp_ring;\n\t\tstruct bnxt_ring_struct *ring = &cpr->cp_ring_struct;\n\n\t\tring->fw_ring_id = INVALID_HW_RING_ID;\n\t\tcpr->rx_ring_coal.coal_ticks = bp->rx_coal.coal_ticks;\n\t\tcpr->rx_ring_coal.coal_bufs = bp->rx_coal.coal_bufs;\n\t\tfor (j = 0; j < 2; j++) {\n\t\t\tstruct bnxt_cp_ring_info *cpr2 = cpr->cp_ring_arr[j];\n\n\t\t\tif (!cpr2)\n\t\t\t\tcontinue;\n\n\t\t\tring = &cpr2->cp_ring_struct;\n\t\t\tring->fw_ring_id = INVALID_HW_RING_ID;\n\t\t\tcpr2->rx_ring_coal.coal_ticks = bp->rx_coal.coal_ticks;\n\t\t\tcpr2->rx_ring_coal.coal_bufs = bp->rx_coal.coal_bufs;\n\t\t}\n\t}\n}\n\nstatic int bnxt_init_rx_rings(struct bnxt *bp)\n{\n\tint i, rc = 0;\n\n\tif (BNXT_RX_PAGE_MODE(bp)) {\n\t\tbp->rx_offset = NET_IP_ALIGN + XDP_PACKET_HEADROOM;\n\t\tbp->rx_dma_offset = XDP_PACKET_HEADROOM;\n\t} else {\n\t\tbp->rx_offset = BNXT_RX_OFFSET;\n\t\tbp->rx_dma_offset = BNXT_RX_DMA_OFFSET;\n\t}\n\n\tfor (i = 0; i < bp->rx_nr_rings; i++) {\n\t\trc = bnxt_init_one_rx_ring(bp, i);\n\t\tif (rc)\n\t\t\tbreak;\n\t}\n\n\treturn rc;\n}\n\nstatic int bnxt_init_tx_rings(struct bnxt *bp)\n{\n\tu16 i;\n\n\tbp->tx_wake_thresh = max_t(int, bp->tx_ring_size / 2,\n\t\t\t\t   BNXT_MIN_TX_DESC_CNT);\n\n\tfor (i = 0; i < bp->tx_nr_rings; i++) {\n\t\tstruct bnxt_tx_ring_info *txr = &bp->tx_ring[i];\n\t\tstruct bnxt_ring_struct *ring = &txr->tx_ring_struct;\n\n\t\tring->fw_ring_id = INVALID_HW_RING_ID;\n\t}\n\n\treturn 0;\n}\n\nstatic void bnxt_free_ring_grps(struct bnxt *bp)\n{\n\tkfree(bp->grp_info);\n\tbp->grp_info = NULL;\n}\n\nstatic int bnxt_init_ring_grps(struct bnxt *bp, bool irq_re_init)\n{\n\tint i;\n\n\tif (irq_re_init) {\n\t\tbp->grp_info = kcalloc(bp->cp_nr_rings,\n\t\t\t\t       sizeof(struct bnxt_ring_grp_info),\n\t\t\t\t       GFP_KERNEL);\n\t\tif (!bp->grp_info)\n\t\t\treturn -ENOMEM;\n\t}\n\tfor (i = 0; i < bp->cp_nr_rings; i++) {\n\t\tif (irq_re_init)\n\t\t\tbp->grp_info[i].fw_stats_ctx = INVALID_HW_RING_ID;\n\t\tbp->grp_info[i].fw_grp_id = INVALID_HW_RING_ID;\n\t\tbp->grp_info[i].rx_fw_ring_id = INVALID_HW_RING_ID;\n\t\tbp->grp_info[i].agg_fw_ring_id = INVALID_HW_RING_ID;\n\t\tbp->grp_info[i].cp_fw_ring_id = INVALID_HW_RING_ID;\n\t}\n\treturn 0;\n}\n\nstatic void bnxt_free_vnics(struct bnxt *bp)\n{\n\tkfree(bp->vnic_info);\n\tbp->vnic_info = NULL;\n\tbp->nr_vnics = 0;\n}\n\nstatic int bnxt_alloc_vnics(struct bnxt *bp)\n{\n\tint num_vnics = 1;\n\n#ifdef CONFIG_RFS_ACCEL\n\tif ((bp->flags & (BNXT_FLAG_RFS | BNXT_FLAG_CHIP_P5)) == BNXT_FLAG_RFS)\n\t\tnum_vnics += bp->rx_nr_rings;\n#endif\n\n\tif (BNXT_CHIP_TYPE_NITRO_A0(bp))\n\t\tnum_vnics++;\n\n\tbp->vnic_info = kcalloc(num_vnics, sizeof(struct bnxt_vnic_info),\n\t\t\t\tGFP_KERNEL);\n\tif (!bp->vnic_info)\n\t\treturn -ENOMEM;\n\n\tbp->nr_vnics = num_vnics;\n\treturn 0;\n}\n\nstatic void bnxt_init_vnics(struct bnxt *bp)\n{\n\tint i;\n\n\tfor (i = 0; i < bp->nr_vnics; i++) {\n\t\tstruct bnxt_vnic_info *vnic = &bp->vnic_info[i];\n\t\tint j;\n\n\t\tvnic->fw_vnic_id = INVALID_HW_RING_ID;\n\t\tfor (j = 0; j < BNXT_MAX_CTX_PER_VNIC; j++)\n\t\t\tvnic->fw_rss_cos_lb_ctx[j] = INVALID_HW_RING_ID;\n\n\t\tvnic->fw_l2_ctx_id = INVALID_HW_RING_ID;\n\n\t\tif (bp->vnic_info[i].rss_hash_key) {\n\t\t\tif (i == 0)\n\t\t\t\tget_random_bytes(vnic->rss_hash_key,\n\t\t\t\t\t      HW_HASH_KEY_SIZE);\n\t\t\telse\n\t\t\t\tmemcpy(vnic->rss_hash_key,\n\t\t\t\t       bp->vnic_info[0].rss_hash_key,\n\t\t\t\t       HW_HASH_KEY_SIZE);\n\t\t}\n\t}\n}\n\nstatic int bnxt_calc_nr_ring_pages(u32 ring_size, int desc_per_pg)\n{\n\tint pages;\n\n\tpages = ring_size / desc_per_pg;\n\n\tif (!pages)\n\t\treturn 1;\n\n\tpages++;\n\n\twhile (pages & (pages - 1))\n\t\tpages++;\n\n\treturn pages;\n}\n\nvoid bnxt_set_tpa_flags(struct bnxt *bp)\n{\n\tbp->flags &= ~BNXT_FLAG_TPA;\n\tif (bp->flags & BNXT_FLAG_NO_AGG_RINGS)\n\t\treturn;\n\tif (bp->dev->features & NETIF_F_LRO)\n\t\tbp->flags |= BNXT_FLAG_LRO;\n\telse if (bp->dev->features & NETIF_F_GRO_HW)\n\t\tbp->flags |= BNXT_FLAG_GRO;\n}\n\n \nvoid bnxt_set_ring_params(struct bnxt *bp)\n{\n\tu32 ring_size, rx_size, rx_space, max_rx_cmpl;\n\tu32 agg_factor = 0, agg_ring_size = 0;\n\n\t \n\trx_size = SKB_DATA_ALIGN(bp->dev->mtu + ETH_HLEN + NET_IP_ALIGN + 8);\n\n\trx_space = rx_size + ALIGN(max(NET_SKB_PAD, XDP_PACKET_HEADROOM), 8) +\n\t\tSKB_DATA_ALIGN(sizeof(struct skb_shared_info));\n\n\tbp->rx_copy_thresh = BNXT_RX_COPY_THRESH;\n\tring_size = bp->rx_ring_size;\n\tbp->rx_agg_ring_size = 0;\n\tbp->rx_agg_nr_pages = 0;\n\n\tif (bp->flags & BNXT_FLAG_TPA)\n\t\tagg_factor = min_t(u32, 4, 65536 / BNXT_RX_PAGE_SIZE);\n\n\tbp->flags &= ~BNXT_FLAG_JUMBO;\n\tif (rx_space > PAGE_SIZE && !(bp->flags & BNXT_FLAG_NO_AGG_RINGS)) {\n\t\tu32 jumbo_factor;\n\n\t\tbp->flags |= BNXT_FLAG_JUMBO;\n\t\tjumbo_factor = PAGE_ALIGN(bp->dev->mtu - 40) >> PAGE_SHIFT;\n\t\tif (jumbo_factor > agg_factor)\n\t\t\tagg_factor = jumbo_factor;\n\t}\n\tif (agg_factor) {\n\t\tif (ring_size > BNXT_MAX_RX_DESC_CNT_JUM_ENA) {\n\t\t\tring_size = BNXT_MAX_RX_DESC_CNT_JUM_ENA;\n\t\t\tnetdev_warn(bp->dev, \"RX ring size reduced from %d to %d because the jumbo ring is now enabled\\n\",\n\t\t\t\t    bp->rx_ring_size, ring_size);\n\t\t\tbp->rx_ring_size = ring_size;\n\t\t}\n\t\tagg_ring_size = ring_size * agg_factor;\n\n\t\tbp->rx_agg_nr_pages = bnxt_calc_nr_ring_pages(agg_ring_size,\n\t\t\t\t\t\t\tRX_DESC_CNT);\n\t\tif (bp->rx_agg_nr_pages > MAX_RX_AGG_PAGES) {\n\t\t\tu32 tmp = agg_ring_size;\n\n\t\t\tbp->rx_agg_nr_pages = MAX_RX_AGG_PAGES;\n\t\t\tagg_ring_size = MAX_RX_AGG_PAGES * RX_DESC_CNT - 1;\n\t\t\tnetdev_warn(bp->dev, \"rx agg ring size %d reduced to %d.\\n\",\n\t\t\t\t    tmp, agg_ring_size);\n\t\t}\n\t\tbp->rx_agg_ring_size = agg_ring_size;\n\t\tbp->rx_agg_ring_mask = (bp->rx_agg_nr_pages * RX_DESC_CNT) - 1;\n\n\t\tif (BNXT_RX_PAGE_MODE(bp)) {\n\t\t\trx_space = PAGE_SIZE;\n\t\t\trx_size = PAGE_SIZE -\n\t\t\t\t  ALIGN(max(NET_SKB_PAD, XDP_PACKET_HEADROOM), 8) -\n\t\t\t\t  SKB_DATA_ALIGN(sizeof(struct skb_shared_info));\n\t\t} else {\n\t\t\trx_size = SKB_DATA_ALIGN(BNXT_RX_COPY_THRESH + NET_IP_ALIGN);\n\t\t\trx_space = rx_size + NET_SKB_PAD +\n\t\t\t\tSKB_DATA_ALIGN(sizeof(struct skb_shared_info));\n\t\t}\n\t}\n\n\tbp->rx_buf_use_size = rx_size;\n\tbp->rx_buf_size = rx_space;\n\n\tbp->rx_nr_pages = bnxt_calc_nr_ring_pages(ring_size, RX_DESC_CNT);\n\tbp->rx_ring_mask = (bp->rx_nr_pages * RX_DESC_CNT) - 1;\n\n\tring_size = bp->tx_ring_size;\n\tbp->tx_nr_pages = bnxt_calc_nr_ring_pages(ring_size, TX_DESC_CNT);\n\tbp->tx_ring_mask = (bp->tx_nr_pages * TX_DESC_CNT) - 1;\n\n\tmax_rx_cmpl = bp->rx_ring_size;\n\t \n\tif (bp->flags & BNXT_FLAG_TPA)\n\t\tmax_rx_cmpl += bp->max_tpa;\n\t \n\tring_size = max_rx_cmpl * 2 + agg_ring_size + bp->tx_ring_size;\n\tbp->cp_ring_size = ring_size;\n\n\tbp->cp_nr_pages = bnxt_calc_nr_ring_pages(ring_size, CP_DESC_CNT);\n\tif (bp->cp_nr_pages > MAX_CP_PAGES) {\n\t\tbp->cp_nr_pages = MAX_CP_PAGES;\n\t\tbp->cp_ring_size = MAX_CP_PAGES * CP_DESC_CNT - 1;\n\t\tnetdev_warn(bp->dev, \"completion ring size %d reduced to %d.\\n\",\n\t\t\t    ring_size, bp->cp_ring_size);\n\t}\n\tbp->cp_bit = bp->cp_nr_pages * CP_DESC_CNT;\n\tbp->cp_ring_mask = bp->cp_bit - 1;\n}\n\n \nint bnxt_set_rx_skb_mode(struct bnxt *bp, bool page_mode)\n{\n\tstruct net_device *dev = bp->dev;\n\n\tif (page_mode) {\n\t\tbp->flags &= ~BNXT_FLAG_AGG_RINGS;\n\t\tbp->flags |= BNXT_FLAG_RX_PAGE_MODE;\n\n\t\tif (bp->xdp_prog->aux->xdp_has_frags)\n\t\t\tdev->max_mtu = min_t(u16, bp->max_mtu, BNXT_MAX_MTU);\n\t\telse\n\t\t\tdev->max_mtu =\n\t\t\t\tmin_t(u16, bp->max_mtu, BNXT_MAX_PAGE_MODE_MTU);\n\t\tif (dev->mtu > BNXT_MAX_PAGE_MODE_MTU) {\n\t\t\tbp->flags |= BNXT_FLAG_JUMBO;\n\t\t\tbp->rx_skb_func = bnxt_rx_multi_page_skb;\n\t\t} else {\n\t\t\tbp->flags |= BNXT_FLAG_NO_AGG_RINGS;\n\t\t\tbp->rx_skb_func = bnxt_rx_page_skb;\n\t\t}\n\t\tbp->rx_dir = DMA_BIDIRECTIONAL;\n\t\t \n\t\tnetdev_update_features(dev);\n\t} else {\n\t\tdev->max_mtu = bp->max_mtu;\n\t\tbp->flags &= ~BNXT_FLAG_RX_PAGE_MODE;\n\t\tbp->rx_dir = DMA_FROM_DEVICE;\n\t\tbp->rx_skb_func = bnxt_rx_skb;\n\t}\n\treturn 0;\n}\n\nstatic void bnxt_free_vnic_attributes(struct bnxt *bp)\n{\n\tint i;\n\tstruct bnxt_vnic_info *vnic;\n\tstruct pci_dev *pdev = bp->pdev;\n\n\tif (!bp->vnic_info)\n\t\treturn;\n\n\tfor (i = 0; i < bp->nr_vnics; i++) {\n\t\tvnic = &bp->vnic_info[i];\n\n\t\tkfree(vnic->fw_grp_ids);\n\t\tvnic->fw_grp_ids = NULL;\n\n\t\tkfree(vnic->uc_list);\n\t\tvnic->uc_list = NULL;\n\n\t\tif (vnic->mc_list) {\n\t\t\tdma_free_coherent(&pdev->dev, vnic->mc_list_size,\n\t\t\t\t\t  vnic->mc_list, vnic->mc_list_mapping);\n\t\t\tvnic->mc_list = NULL;\n\t\t}\n\n\t\tif (vnic->rss_table) {\n\t\t\tdma_free_coherent(&pdev->dev, vnic->rss_table_size,\n\t\t\t\t\t  vnic->rss_table,\n\t\t\t\t\t  vnic->rss_table_dma_addr);\n\t\t\tvnic->rss_table = NULL;\n\t\t}\n\n\t\tvnic->rss_hash_key = NULL;\n\t\tvnic->flags = 0;\n\t}\n}\n\nstatic int bnxt_alloc_vnic_attributes(struct bnxt *bp)\n{\n\tint i, rc = 0, size;\n\tstruct bnxt_vnic_info *vnic;\n\tstruct pci_dev *pdev = bp->pdev;\n\tint max_rings;\n\n\tfor (i = 0; i < bp->nr_vnics; i++) {\n\t\tvnic = &bp->vnic_info[i];\n\n\t\tif (vnic->flags & BNXT_VNIC_UCAST_FLAG) {\n\t\t\tint mem_size = (BNXT_MAX_UC_ADDRS - 1) * ETH_ALEN;\n\n\t\t\tif (mem_size > 0) {\n\t\t\t\tvnic->uc_list = kmalloc(mem_size, GFP_KERNEL);\n\t\t\t\tif (!vnic->uc_list) {\n\t\t\t\t\trc = -ENOMEM;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (vnic->flags & BNXT_VNIC_MCAST_FLAG) {\n\t\t\tvnic->mc_list_size = BNXT_MAX_MC_ADDRS * ETH_ALEN;\n\t\t\tvnic->mc_list =\n\t\t\t\tdma_alloc_coherent(&pdev->dev,\n\t\t\t\t\t\t   vnic->mc_list_size,\n\t\t\t\t\t\t   &vnic->mc_list_mapping,\n\t\t\t\t\t\t   GFP_KERNEL);\n\t\t\tif (!vnic->mc_list) {\n\t\t\t\trc = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tif (bp->flags & BNXT_FLAG_CHIP_P5)\n\t\t\tgoto vnic_skip_grps;\n\n\t\tif (vnic->flags & BNXT_VNIC_RSS_FLAG)\n\t\t\tmax_rings = bp->rx_nr_rings;\n\t\telse\n\t\t\tmax_rings = 1;\n\n\t\tvnic->fw_grp_ids = kcalloc(max_rings, sizeof(u16), GFP_KERNEL);\n\t\tif (!vnic->fw_grp_ids) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\nvnic_skip_grps:\n\t\tif ((bp->flags & BNXT_FLAG_NEW_RSS_CAP) &&\n\t\t    !(vnic->flags & BNXT_VNIC_RSS_FLAG))\n\t\t\tcontinue;\n\n\t\t \n\t\tsize = L1_CACHE_ALIGN(HW_HASH_INDEX_SIZE * sizeof(u16));\n\t\tif (bp->flags & BNXT_FLAG_CHIP_P5)\n\t\t\tsize = L1_CACHE_ALIGN(BNXT_MAX_RSS_TABLE_SIZE_P5);\n\n\t\tvnic->rss_table_size = size + HW_HASH_KEY_SIZE;\n\t\tvnic->rss_table = dma_alloc_coherent(&pdev->dev,\n\t\t\t\t\t\t     vnic->rss_table_size,\n\t\t\t\t\t\t     &vnic->rss_table_dma_addr,\n\t\t\t\t\t\t     GFP_KERNEL);\n\t\tif (!vnic->rss_table) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tvnic->rss_hash_key = ((void *)vnic->rss_table) + size;\n\t\tvnic->rss_hash_key_dma_addr = vnic->rss_table_dma_addr + size;\n\t}\n\treturn 0;\n\nout:\n\treturn rc;\n}\n\nstatic void bnxt_free_hwrm_resources(struct bnxt *bp)\n{\n\tstruct bnxt_hwrm_wait_token *token;\n\n\tdma_pool_destroy(bp->hwrm_dma_pool);\n\tbp->hwrm_dma_pool = NULL;\n\n\trcu_read_lock();\n\thlist_for_each_entry_rcu(token, &bp->hwrm_pending_list, node)\n\t\tWRITE_ONCE(token->state, BNXT_HWRM_CANCELLED);\n\trcu_read_unlock();\n}\n\nstatic int bnxt_alloc_hwrm_resources(struct bnxt *bp)\n{\n\tbp->hwrm_dma_pool = dma_pool_create(\"bnxt_hwrm\", &bp->pdev->dev,\n\t\t\t\t\t    BNXT_HWRM_DMA_SIZE,\n\t\t\t\t\t    BNXT_HWRM_DMA_ALIGN, 0);\n\tif (!bp->hwrm_dma_pool)\n\t\treturn -ENOMEM;\n\n\tINIT_HLIST_HEAD(&bp->hwrm_pending_list);\n\n\treturn 0;\n}\n\nstatic void bnxt_free_stats_mem(struct bnxt *bp, struct bnxt_stats_mem *stats)\n{\n\tkfree(stats->hw_masks);\n\tstats->hw_masks = NULL;\n\tkfree(stats->sw_stats);\n\tstats->sw_stats = NULL;\n\tif (stats->hw_stats) {\n\t\tdma_free_coherent(&bp->pdev->dev, stats->len, stats->hw_stats,\n\t\t\t\t  stats->hw_stats_map);\n\t\tstats->hw_stats = NULL;\n\t}\n}\n\nstatic int bnxt_alloc_stats_mem(struct bnxt *bp, struct bnxt_stats_mem *stats,\n\t\t\t\tbool alloc_masks)\n{\n\tstats->hw_stats = dma_alloc_coherent(&bp->pdev->dev, stats->len,\n\t\t\t\t\t     &stats->hw_stats_map, GFP_KERNEL);\n\tif (!stats->hw_stats)\n\t\treturn -ENOMEM;\n\n\tstats->sw_stats = kzalloc(stats->len, GFP_KERNEL);\n\tif (!stats->sw_stats)\n\t\tgoto stats_mem_err;\n\n\tif (alloc_masks) {\n\t\tstats->hw_masks = kzalloc(stats->len, GFP_KERNEL);\n\t\tif (!stats->hw_masks)\n\t\t\tgoto stats_mem_err;\n\t}\n\treturn 0;\n\nstats_mem_err:\n\tbnxt_free_stats_mem(bp, stats);\n\treturn -ENOMEM;\n}\n\nstatic void bnxt_fill_masks(u64 *mask_arr, u64 mask, int count)\n{\n\tint i;\n\n\tfor (i = 0; i < count; i++)\n\t\tmask_arr[i] = mask;\n}\n\nstatic void bnxt_copy_hw_masks(u64 *mask_arr, __le64 *hw_mask_arr, int count)\n{\n\tint i;\n\n\tfor (i = 0; i < count; i++)\n\t\tmask_arr[i] = le64_to_cpu(hw_mask_arr[i]);\n}\n\nstatic int bnxt_hwrm_func_qstat_ext(struct bnxt *bp,\n\t\t\t\t    struct bnxt_stats_mem *stats)\n{\n\tstruct hwrm_func_qstats_ext_output *resp;\n\tstruct hwrm_func_qstats_ext_input *req;\n\t__le64 *hw_masks;\n\tint rc;\n\n\tif (!(bp->fw_cap & BNXT_FW_CAP_EXT_HW_STATS_SUPPORTED) ||\n\t    !(bp->flags & BNXT_FLAG_CHIP_P5))\n\t\treturn -EOPNOTSUPP;\n\n\trc = hwrm_req_init(bp, req, HWRM_FUNC_QSTATS_EXT);\n\tif (rc)\n\t\treturn rc;\n\n\treq->fid = cpu_to_le16(0xffff);\n\treq->flags = FUNC_QSTATS_EXT_REQ_FLAGS_COUNTER_MASK;\n\n\tresp = hwrm_req_hold(bp, req);\n\trc = hwrm_req_send(bp, req);\n\tif (!rc) {\n\t\thw_masks = &resp->rx_ucast_pkts;\n\t\tbnxt_copy_hw_masks(stats->hw_masks, hw_masks, stats->len / 8);\n\t}\n\thwrm_req_drop(bp, req);\n\treturn rc;\n}\n\nstatic int bnxt_hwrm_port_qstats(struct bnxt *bp, u8 flags);\nstatic int bnxt_hwrm_port_qstats_ext(struct bnxt *bp, u8 flags);\n\nstatic void bnxt_init_stats(struct bnxt *bp)\n{\n\tstruct bnxt_napi *bnapi = bp->bnapi[0];\n\tstruct bnxt_cp_ring_info *cpr;\n\tstruct bnxt_stats_mem *stats;\n\t__le64 *rx_stats, *tx_stats;\n\tint rc, rx_count, tx_count;\n\tu64 *rx_masks, *tx_masks;\n\tu64 mask;\n\tu8 flags;\n\n\tcpr = &bnapi->cp_ring;\n\tstats = &cpr->stats;\n\trc = bnxt_hwrm_func_qstat_ext(bp, stats);\n\tif (rc) {\n\t\tif (bp->flags & BNXT_FLAG_CHIP_P5)\n\t\t\tmask = (1ULL << 48) - 1;\n\t\telse\n\t\t\tmask = -1ULL;\n\t\tbnxt_fill_masks(stats->hw_masks, mask, stats->len / 8);\n\t}\n\tif (bp->flags & BNXT_FLAG_PORT_STATS) {\n\t\tstats = &bp->port_stats;\n\t\trx_stats = stats->hw_stats;\n\t\trx_masks = stats->hw_masks;\n\t\trx_count = sizeof(struct rx_port_stats) / 8;\n\t\ttx_stats = rx_stats + BNXT_TX_PORT_STATS_BYTE_OFFSET / 8;\n\t\ttx_masks = rx_masks + BNXT_TX_PORT_STATS_BYTE_OFFSET / 8;\n\t\ttx_count = sizeof(struct tx_port_stats) / 8;\n\n\t\tflags = PORT_QSTATS_REQ_FLAGS_COUNTER_MASK;\n\t\trc = bnxt_hwrm_port_qstats(bp, flags);\n\t\tif (rc) {\n\t\t\tmask = (1ULL << 40) - 1;\n\n\t\t\tbnxt_fill_masks(rx_masks, mask, rx_count);\n\t\t\tbnxt_fill_masks(tx_masks, mask, tx_count);\n\t\t} else {\n\t\t\tbnxt_copy_hw_masks(rx_masks, rx_stats, rx_count);\n\t\t\tbnxt_copy_hw_masks(tx_masks, tx_stats, tx_count);\n\t\t\tbnxt_hwrm_port_qstats(bp, 0);\n\t\t}\n\t}\n\tif (bp->flags & BNXT_FLAG_PORT_STATS_EXT) {\n\t\tstats = &bp->rx_port_stats_ext;\n\t\trx_stats = stats->hw_stats;\n\t\trx_masks = stats->hw_masks;\n\t\trx_count = sizeof(struct rx_port_stats_ext) / 8;\n\t\tstats = &bp->tx_port_stats_ext;\n\t\ttx_stats = stats->hw_stats;\n\t\ttx_masks = stats->hw_masks;\n\t\ttx_count = sizeof(struct tx_port_stats_ext) / 8;\n\n\t\tflags = PORT_QSTATS_EXT_REQ_FLAGS_COUNTER_MASK;\n\t\trc = bnxt_hwrm_port_qstats_ext(bp, flags);\n\t\tif (rc) {\n\t\t\tmask = (1ULL << 40) - 1;\n\n\t\t\tbnxt_fill_masks(rx_masks, mask, rx_count);\n\t\t\tif (tx_stats)\n\t\t\t\tbnxt_fill_masks(tx_masks, mask, tx_count);\n\t\t} else {\n\t\t\tbnxt_copy_hw_masks(rx_masks, rx_stats, rx_count);\n\t\t\tif (tx_stats)\n\t\t\t\tbnxt_copy_hw_masks(tx_masks, tx_stats,\n\t\t\t\t\t\t   tx_count);\n\t\t\tbnxt_hwrm_port_qstats_ext(bp, 0);\n\t\t}\n\t}\n}\n\nstatic void bnxt_free_port_stats(struct bnxt *bp)\n{\n\tbp->flags &= ~BNXT_FLAG_PORT_STATS;\n\tbp->flags &= ~BNXT_FLAG_PORT_STATS_EXT;\n\n\tbnxt_free_stats_mem(bp, &bp->port_stats);\n\tbnxt_free_stats_mem(bp, &bp->rx_port_stats_ext);\n\tbnxt_free_stats_mem(bp, &bp->tx_port_stats_ext);\n}\n\nstatic void bnxt_free_ring_stats(struct bnxt *bp)\n{\n\tint i;\n\n\tif (!bp->bnapi)\n\t\treturn;\n\n\tfor (i = 0; i < bp->cp_nr_rings; i++) {\n\t\tstruct bnxt_napi *bnapi = bp->bnapi[i];\n\t\tstruct bnxt_cp_ring_info *cpr = &bnapi->cp_ring;\n\n\t\tbnxt_free_stats_mem(bp, &cpr->stats);\n\t}\n}\n\nstatic int bnxt_alloc_stats(struct bnxt *bp)\n{\n\tu32 size, i;\n\tint rc;\n\n\tsize = bp->hw_ring_stats_size;\n\n\tfor (i = 0; i < bp->cp_nr_rings; i++) {\n\t\tstruct bnxt_napi *bnapi = bp->bnapi[i];\n\t\tstruct bnxt_cp_ring_info *cpr = &bnapi->cp_ring;\n\n\t\tcpr->stats.len = size;\n\t\trc = bnxt_alloc_stats_mem(bp, &cpr->stats, !i);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\tcpr->hw_stats_ctx_id = INVALID_STATS_CTX_ID;\n\t}\n\n\tif (BNXT_VF(bp) || bp->chip_num == CHIP_NUM_58700)\n\t\treturn 0;\n\n\tif (bp->port_stats.hw_stats)\n\t\tgoto alloc_ext_stats;\n\n\tbp->port_stats.len = BNXT_PORT_STATS_SIZE;\n\trc = bnxt_alloc_stats_mem(bp, &bp->port_stats, true);\n\tif (rc)\n\t\treturn rc;\n\n\tbp->flags |= BNXT_FLAG_PORT_STATS;\n\nalloc_ext_stats:\n\t \n\tif (bp->hwrm_spec_code < 0x10804 || bp->hwrm_spec_code == 0x10900)\n\t\tif (!(bp->fw_cap & BNXT_FW_CAP_EXT_STATS_SUPPORTED))\n\t\t\treturn 0;\n\n\tif (bp->rx_port_stats_ext.hw_stats)\n\t\tgoto alloc_tx_ext_stats;\n\n\tbp->rx_port_stats_ext.len = sizeof(struct rx_port_stats_ext);\n\trc = bnxt_alloc_stats_mem(bp, &bp->rx_port_stats_ext, true);\n\t \n\tif (rc)\n\t\treturn 0;\n\nalloc_tx_ext_stats:\n\tif (bp->tx_port_stats_ext.hw_stats)\n\t\treturn 0;\n\n\tif (bp->hwrm_spec_code >= 0x10902 ||\n\t    (bp->fw_cap & BNXT_FW_CAP_EXT_STATS_SUPPORTED)) {\n\t\tbp->tx_port_stats_ext.len = sizeof(struct tx_port_stats_ext);\n\t\trc = bnxt_alloc_stats_mem(bp, &bp->tx_port_stats_ext, true);\n\t\t \n\t\tif (rc)\n\t\t\treturn 0;\n\t}\n\tbp->flags |= BNXT_FLAG_PORT_STATS_EXT;\n\treturn 0;\n}\n\nstatic void bnxt_clear_ring_indices(struct bnxt *bp)\n{\n\tint i;\n\n\tif (!bp->bnapi)\n\t\treturn;\n\n\tfor (i = 0; i < bp->cp_nr_rings; i++) {\n\t\tstruct bnxt_napi *bnapi = bp->bnapi[i];\n\t\tstruct bnxt_cp_ring_info *cpr;\n\t\tstruct bnxt_rx_ring_info *rxr;\n\t\tstruct bnxt_tx_ring_info *txr;\n\n\t\tif (!bnapi)\n\t\t\tcontinue;\n\n\t\tcpr = &bnapi->cp_ring;\n\t\tcpr->cp_raw_cons = 0;\n\n\t\ttxr = bnapi->tx_ring;\n\t\tif (txr) {\n\t\t\ttxr->tx_prod = 0;\n\t\t\ttxr->tx_cons = 0;\n\t\t}\n\n\t\trxr = bnapi->rx_ring;\n\t\tif (rxr) {\n\t\t\trxr->rx_prod = 0;\n\t\t\trxr->rx_agg_prod = 0;\n\t\t\trxr->rx_sw_agg_prod = 0;\n\t\t\trxr->rx_next_cons = 0;\n\t\t}\n\t}\n}\n\nstatic void bnxt_free_ntp_fltrs(struct bnxt *bp, bool irq_reinit)\n{\n#ifdef CONFIG_RFS_ACCEL\n\tint i;\n\n\t \n\tfor (i = 0; i < BNXT_NTP_FLTR_HASH_SIZE; i++) {\n\t\tstruct hlist_head *head;\n\t\tstruct hlist_node *tmp;\n\t\tstruct bnxt_ntuple_filter *fltr;\n\n\t\thead = &bp->ntp_fltr_hash_tbl[i];\n\t\thlist_for_each_entry_safe(fltr, tmp, head, hash) {\n\t\t\thlist_del(&fltr->hash);\n\t\t\tkfree(fltr);\n\t\t}\n\t}\n\tif (irq_reinit) {\n\t\tbitmap_free(bp->ntp_fltr_bmap);\n\t\tbp->ntp_fltr_bmap = NULL;\n\t}\n\tbp->ntp_fltr_count = 0;\n#endif\n}\n\nstatic int bnxt_alloc_ntp_fltrs(struct bnxt *bp)\n{\n#ifdef CONFIG_RFS_ACCEL\n\tint i, rc = 0;\n\n\tif (!(bp->flags & BNXT_FLAG_RFS))\n\t\treturn 0;\n\n\tfor (i = 0; i < BNXT_NTP_FLTR_HASH_SIZE; i++)\n\t\tINIT_HLIST_HEAD(&bp->ntp_fltr_hash_tbl[i]);\n\n\tbp->ntp_fltr_count = 0;\n\tbp->ntp_fltr_bmap = bitmap_zalloc(BNXT_NTP_FLTR_MAX_FLTR, GFP_KERNEL);\n\n\tif (!bp->ntp_fltr_bmap)\n\t\trc = -ENOMEM;\n\n\treturn rc;\n#else\n\treturn 0;\n#endif\n}\n\nstatic void bnxt_free_mem(struct bnxt *bp, bool irq_re_init)\n{\n\tbnxt_free_vnic_attributes(bp);\n\tbnxt_free_tx_rings(bp);\n\tbnxt_free_rx_rings(bp);\n\tbnxt_free_cp_rings(bp);\n\tbnxt_free_all_cp_arrays(bp);\n\tbnxt_free_ntp_fltrs(bp, irq_re_init);\n\tif (irq_re_init) {\n\t\tbnxt_free_ring_stats(bp);\n\t\tif (!(bp->phy_flags & BNXT_PHY_FL_PORT_STATS_NO_RESET) ||\n\t\t    test_bit(BNXT_STATE_IN_FW_RESET, &bp->state))\n\t\t\tbnxt_free_port_stats(bp);\n\t\tbnxt_free_ring_grps(bp);\n\t\tbnxt_free_vnics(bp);\n\t\tkfree(bp->tx_ring_map);\n\t\tbp->tx_ring_map = NULL;\n\t\tkfree(bp->tx_ring);\n\t\tbp->tx_ring = NULL;\n\t\tkfree(bp->rx_ring);\n\t\tbp->rx_ring = NULL;\n\t\tkfree(bp->bnapi);\n\t\tbp->bnapi = NULL;\n\t} else {\n\t\tbnxt_clear_ring_indices(bp);\n\t}\n}\n\nstatic int bnxt_alloc_mem(struct bnxt *bp, bool irq_re_init)\n{\n\tint i, j, rc, size, arr_size;\n\tvoid *bnapi;\n\n\tif (irq_re_init) {\n\t\t \n\t\tarr_size = L1_CACHE_ALIGN(sizeof(struct bnxt_napi *) *\n\t\t\t\tbp->cp_nr_rings);\n\t\tsize = L1_CACHE_ALIGN(sizeof(struct bnxt_napi));\n\t\tbnapi = kzalloc(arr_size + size * bp->cp_nr_rings, GFP_KERNEL);\n\t\tif (!bnapi)\n\t\t\treturn -ENOMEM;\n\n\t\tbp->bnapi = bnapi;\n\t\tbnapi += arr_size;\n\t\tfor (i = 0; i < bp->cp_nr_rings; i++, bnapi += size) {\n\t\t\tbp->bnapi[i] = bnapi;\n\t\t\tbp->bnapi[i]->index = i;\n\t\t\tbp->bnapi[i]->bp = bp;\n\t\t\tif (bp->flags & BNXT_FLAG_CHIP_P5) {\n\t\t\t\tstruct bnxt_cp_ring_info *cpr =\n\t\t\t\t\t&bp->bnapi[i]->cp_ring;\n\n\t\t\t\tcpr->cp_ring_struct.ring_mem.flags =\n\t\t\t\t\tBNXT_RMEM_RING_PTE_FLAG;\n\t\t\t}\n\t\t}\n\n\t\tbp->rx_ring = kcalloc(bp->rx_nr_rings,\n\t\t\t\t      sizeof(struct bnxt_rx_ring_info),\n\t\t\t\t      GFP_KERNEL);\n\t\tif (!bp->rx_ring)\n\t\t\treturn -ENOMEM;\n\n\t\tfor (i = 0; i < bp->rx_nr_rings; i++) {\n\t\t\tstruct bnxt_rx_ring_info *rxr = &bp->rx_ring[i];\n\n\t\t\tif (bp->flags & BNXT_FLAG_CHIP_P5) {\n\t\t\t\trxr->rx_ring_struct.ring_mem.flags =\n\t\t\t\t\tBNXT_RMEM_RING_PTE_FLAG;\n\t\t\t\trxr->rx_agg_ring_struct.ring_mem.flags =\n\t\t\t\t\tBNXT_RMEM_RING_PTE_FLAG;\n\t\t\t}\n\t\t\trxr->bnapi = bp->bnapi[i];\n\t\t\tbp->bnapi[i]->rx_ring = &bp->rx_ring[i];\n\t\t}\n\n\t\tbp->tx_ring = kcalloc(bp->tx_nr_rings,\n\t\t\t\t      sizeof(struct bnxt_tx_ring_info),\n\t\t\t\t      GFP_KERNEL);\n\t\tif (!bp->tx_ring)\n\t\t\treturn -ENOMEM;\n\n\t\tbp->tx_ring_map = kcalloc(bp->tx_nr_rings, sizeof(u16),\n\t\t\t\t\t  GFP_KERNEL);\n\n\t\tif (!bp->tx_ring_map)\n\t\t\treturn -ENOMEM;\n\n\t\tif (bp->flags & BNXT_FLAG_SHARED_RINGS)\n\t\t\tj = 0;\n\t\telse\n\t\t\tj = bp->rx_nr_rings;\n\n\t\tfor (i = 0; i < bp->tx_nr_rings; i++, j++) {\n\t\t\tstruct bnxt_tx_ring_info *txr = &bp->tx_ring[i];\n\n\t\t\tif (bp->flags & BNXT_FLAG_CHIP_P5)\n\t\t\t\ttxr->tx_ring_struct.ring_mem.flags =\n\t\t\t\t\tBNXT_RMEM_RING_PTE_FLAG;\n\t\t\ttxr->bnapi = bp->bnapi[j];\n\t\t\tbp->bnapi[j]->tx_ring = txr;\n\t\t\tbp->tx_ring_map[i] = bp->tx_nr_rings_xdp + i;\n\t\t\tif (i >= bp->tx_nr_rings_xdp) {\n\t\t\t\ttxr->txq_index = i - bp->tx_nr_rings_xdp;\n\t\t\t\tbp->bnapi[j]->tx_int = bnxt_tx_int;\n\t\t\t} else {\n\t\t\t\tbp->bnapi[j]->flags |= BNXT_NAPI_FLAG_XDP;\n\t\t\t\tbp->bnapi[j]->tx_int = bnxt_tx_int_xdp;\n\t\t\t}\n\t\t}\n\n\t\trc = bnxt_alloc_stats(bp);\n\t\tif (rc)\n\t\t\tgoto alloc_mem_err;\n\t\tbnxt_init_stats(bp);\n\n\t\trc = bnxt_alloc_ntp_fltrs(bp);\n\t\tif (rc)\n\t\t\tgoto alloc_mem_err;\n\n\t\trc = bnxt_alloc_vnics(bp);\n\t\tif (rc)\n\t\t\tgoto alloc_mem_err;\n\t}\n\n\trc = bnxt_alloc_all_cp_arrays(bp);\n\tif (rc)\n\t\tgoto alloc_mem_err;\n\n\tbnxt_init_ring_struct(bp);\n\n\trc = bnxt_alloc_rx_rings(bp);\n\tif (rc)\n\t\tgoto alloc_mem_err;\n\n\trc = bnxt_alloc_tx_rings(bp);\n\tif (rc)\n\t\tgoto alloc_mem_err;\n\n\trc = bnxt_alloc_cp_rings(bp);\n\tif (rc)\n\t\tgoto alloc_mem_err;\n\n\tbp->vnic_info[0].flags |= BNXT_VNIC_RSS_FLAG | BNXT_VNIC_MCAST_FLAG |\n\t\t\t\t  BNXT_VNIC_UCAST_FLAG;\n\trc = bnxt_alloc_vnic_attributes(bp);\n\tif (rc)\n\t\tgoto alloc_mem_err;\n\treturn 0;\n\nalloc_mem_err:\n\tbnxt_free_mem(bp, true);\n\treturn rc;\n}\n\nstatic void bnxt_disable_int(struct bnxt *bp)\n{\n\tint i;\n\n\tif (!bp->bnapi)\n\t\treturn;\n\n\tfor (i = 0; i < bp->cp_nr_rings; i++) {\n\t\tstruct bnxt_napi *bnapi = bp->bnapi[i];\n\t\tstruct bnxt_cp_ring_info *cpr = &bnapi->cp_ring;\n\t\tstruct bnxt_ring_struct *ring = &cpr->cp_ring_struct;\n\n\t\tif (ring->fw_ring_id != INVALID_HW_RING_ID)\n\t\t\tbnxt_db_nq(bp, &cpr->cp_db, cpr->cp_raw_cons);\n\t}\n}\n\nstatic int bnxt_cp_num_to_irq_num(struct bnxt *bp, int n)\n{\n\tstruct bnxt_napi *bnapi = bp->bnapi[n];\n\tstruct bnxt_cp_ring_info *cpr;\n\n\tcpr = &bnapi->cp_ring;\n\treturn cpr->cp_ring_struct.map_idx;\n}\n\nstatic void bnxt_disable_int_sync(struct bnxt *bp)\n{\n\tint i;\n\n\tif (!bp->irq_tbl)\n\t\treturn;\n\n\tatomic_inc(&bp->intr_sem);\n\n\tbnxt_disable_int(bp);\n\tfor (i = 0; i < bp->cp_nr_rings; i++) {\n\t\tint map_idx = bnxt_cp_num_to_irq_num(bp, i);\n\n\t\tsynchronize_irq(bp->irq_tbl[map_idx].vector);\n\t}\n}\n\nstatic void bnxt_enable_int(struct bnxt *bp)\n{\n\tint i;\n\n\tatomic_set(&bp->intr_sem, 0);\n\tfor (i = 0; i < bp->cp_nr_rings; i++) {\n\t\tstruct bnxt_napi *bnapi = bp->bnapi[i];\n\t\tstruct bnxt_cp_ring_info *cpr = &bnapi->cp_ring;\n\n\t\tbnxt_db_nq_arm(bp, &cpr->cp_db, cpr->cp_raw_cons);\n\t}\n}\n\nint bnxt_hwrm_func_drv_rgtr(struct bnxt *bp, unsigned long *bmap, int bmap_size,\n\t\t\t    bool async_only)\n{\n\tDECLARE_BITMAP(async_events_bmap, 256);\n\tu32 *events = (u32 *)async_events_bmap;\n\tstruct hwrm_func_drv_rgtr_output *resp;\n\tstruct hwrm_func_drv_rgtr_input *req;\n\tu32 flags;\n\tint rc, i;\n\n\trc = hwrm_req_init(bp, req, HWRM_FUNC_DRV_RGTR);\n\tif (rc)\n\t\treturn rc;\n\n\treq->enables = cpu_to_le32(FUNC_DRV_RGTR_REQ_ENABLES_OS_TYPE |\n\t\t\t\t   FUNC_DRV_RGTR_REQ_ENABLES_VER |\n\t\t\t\t   FUNC_DRV_RGTR_REQ_ENABLES_ASYNC_EVENT_FWD);\n\n\treq->os_type = cpu_to_le16(FUNC_DRV_RGTR_REQ_OS_TYPE_LINUX);\n\tflags = FUNC_DRV_RGTR_REQ_FLAGS_16BIT_VER_MODE;\n\tif (bp->fw_cap & BNXT_FW_CAP_HOT_RESET)\n\t\tflags |= FUNC_DRV_RGTR_REQ_FLAGS_HOT_RESET_SUPPORT;\n\tif (bp->fw_cap & BNXT_FW_CAP_ERROR_RECOVERY)\n\t\tflags |= FUNC_DRV_RGTR_REQ_FLAGS_ERROR_RECOVERY_SUPPORT |\n\t\t\t FUNC_DRV_RGTR_REQ_FLAGS_MASTER_SUPPORT;\n\treq->flags = cpu_to_le32(flags);\n\treq->ver_maj_8b = DRV_VER_MAJ;\n\treq->ver_min_8b = DRV_VER_MIN;\n\treq->ver_upd_8b = DRV_VER_UPD;\n\treq->ver_maj = cpu_to_le16(DRV_VER_MAJ);\n\treq->ver_min = cpu_to_le16(DRV_VER_MIN);\n\treq->ver_upd = cpu_to_le16(DRV_VER_UPD);\n\n\tif (BNXT_PF(bp)) {\n\t\tu32 data[8];\n\t\tint i;\n\n\t\tmemset(data, 0, sizeof(data));\n\t\tfor (i = 0; i < ARRAY_SIZE(bnxt_vf_req_snif); i++) {\n\t\t\tu16 cmd = bnxt_vf_req_snif[i];\n\t\t\tunsigned int bit, idx;\n\n\t\t\tidx = cmd / 32;\n\t\t\tbit = cmd % 32;\n\t\t\tdata[idx] |= 1 << bit;\n\t\t}\n\n\t\tfor (i = 0; i < 8; i++)\n\t\t\treq->vf_req_fwd[i] = cpu_to_le32(data[i]);\n\n\t\treq->enables |=\n\t\t\tcpu_to_le32(FUNC_DRV_RGTR_REQ_ENABLES_VF_REQ_FWD);\n\t}\n\n\tif (bp->fw_cap & BNXT_FW_CAP_OVS_64BIT_HANDLE)\n\t\treq->flags |= cpu_to_le32(\n\t\t\tFUNC_DRV_RGTR_REQ_FLAGS_FLOW_HANDLE_64BIT_MODE);\n\n\tmemset(async_events_bmap, 0, sizeof(async_events_bmap));\n\tfor (i = 0; i < ARRAY_SIZE(bnxt_async_events_arr); i++) {\n\t\tu16 event_id = bnxt_async_events_arr[i];\n\n\t\tif (event_id == ASYNC_EVENT_CMPL_EVENT_ID_ERROR_RECOVERY &&\n\t\t    !(bp->fw_cap & BNXT_FW_CAP_ERROR_RECOVERY))\n\t\t\tcontinue;\n\t\tif (event_id == ASYNC_EVENT_CMPL_EVENT_ID_PHC_UPDATE &&\n\t\t    !bp->ptp_cfg)\n\t\t\tcontinue;\n\t\t__set_bit(bnxt_async_events_arr[i], async_events_bmap);\n\t}\n\tif (bmap && bmap_size) {\n\t\tfor (i = 0; i < bmap_size; i++) {\n\t\t\tif (test_bit(i, bmap))\n\t\t\t\t__set_bit(i, async_events_bmap);\n\t\t}\n\t}\n\tfor (i = 0; i < 8; i++)\n\t\treq->async_event_fwd[i] |= cpu_to_le32(events[i]);\n\n\tif (async_only)\n\t\treq->enables =\n\t\t\tcpu_to_le32(FUNC_DRV_RGTR_REQ_ENABLES_ASYNC_EVENT_FWD);\n\n\tresp = hwrm_req_hold(bp, req);\n\trc = hwrm_req_send(bp, req);\n\tif (!rc) {\n\t\tset_bit(BNXT_STATE_DRV_REGISTERED, &bp->state);\n\t\tif (resp->flags &\n\t\t    cpu_to_le32(FUNC_DRV_RGTR_RESP_FLAGS_IF_CHANGE_SUPPORTED))\n\t\t\tbp->fw_cap |= BNXT_FW_CAP_IF_CHANGE;\n\t}\n\thwrm_req_drop(bp, req);\n\treturn rc;\n}\n\nint bnxt_hwrm_func_drv_unrgtr(struct bnxt *bp)\n{\n\tstruct hwrm_func_drv_unrgtr_input *req;\n\tint rc;\n\n\tif (!test_and_clear_bit(BNXT_STATE_DRV_REGISTERED, &bp->state))\n\t\treturn 0;\n\n\trc = hwrm_req_init(bp, req, HWRM_FUNC_DRV_UNRGTR);\n\tif (rc)\n\t\treturn rc;\n\treturn hwrm_req_send(bp, req);\n}\n\nstatic int bnxt_hwrm_tunnel_dst_port_free(struct bnxt *bp, u8 tunnel_type)\n{\n\tstruct hwrm_tunnel_dst_port_free_input *req;\n\tint rc;\n\n\tif (tunnel_type == TUNNEL_DST_PORT_FREE_REQ_TUNNEL_TYPE_VXLAN &&\n\t    bp->vxlan_fw_dst_port_id == INVALID_HW_RING_ID)\n\t\treturn 0;\n\tif (tunnel_type == TUNNEL_DST_PORT_FREE_REQ_TUNNEL_TYPE_GENEVE &&\n\t    bp->nge_fw_dst_port_id == INVALID_HW_RING_ID)\n\t\treturn 0;\n\n\trc = hwrm_req_init(bp, req, HWRM_TUNNEL_DST_PORT_FREE);\n\tif (rc)\n\t\treturn rc;\n\n\treq->tunnel_type = tunnel_type;\n\n\tswitch (tunnel_type) {\n\tcase TUNNEL_DST_PORT_FREE_REQ_TUNNEL_TYPE_VXLAN:\n\t\treq->tunnel_dst_port_id = cpu_to_le16(bp->vxlan_fw_dst_port_id);\n\t\tbp->vxlan_port = 0;\n\t\tbp->vxlan_fw_dst_port_id = INVALID_HW_RING_ID;\n\t\tbreak;\n\tcase TUNNEL_DST_PORT_FREE_REQ_TUNNEL_TYPE_GENEVE:\n\t\treq->tunnel_dst_port_id = cpu_to_le16(bp->nge_fw_dst_port_id);\n\t\tbp->nge_port = 0;\n\t\tbp->nge_fw_dst_port_id = INVALID_HW_RING_ID;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\trc = hwrm_req_send(bp, req);\n\tif (rc)\n\t\tnetdev_err(bp->dev, \"hwrm_tunnel_dst_port_free failed. rc:%d\\n\",\n\t\t\t   rc);\n\treturn rc;\n}\n\nstatic int bnxt_hwrm_tunnel_dst_port_alloc(struct bnxt *bp, __be16 port,\n\t\t\t\t\t   u8 tunnel_type)\n{\n\tstruct hwrm_tunnel_dst_port_alloc_output *resp;\n\tstruct hwrm_tunnel_dst_port_alloc_input *req;\n\tint rc;\n\n\trc = hwrm_req_init(bp, req, HWRM_TUNNEL_DST_PORT_ALLOC);\n\tif (rc)\n\t\treturn rc;\n\n\treq->tunnel_type = tunnel_type;\n\treq->tunnel_dst_port_val = port;\n\n\tresp = hwrm_req_hold(bp, req);\n\trc = hwrm_req_send(bp, req);\n\tif (rc) {\n\t\tnetdev_err(bp->dev, \"hwrm_tunnel_dst_port_alloc failed. rc:%d\\n\",\n\t\t\t   rc);\n\t\tgoto err_out;\n\t}\n\n\tswitch (tunnel_type) {\n\tcase TUNNEL_DST_PORT_ALLOC_REQ_TUNNEL_TYPE_VXLAN:\n\t\tbp->vxlan_port = port;\n\t\tbp->vxlan_fw_dst_port_id =\n\t\t\tle16_to_cpu(resp->tunnel_dst_port_id);\n\t\tbreak;\n\tcase TUNNEL_DST_PORT_ALLOC_REQ_TUNNEL_TYPE_GENEVE:\n\t\tbp->nge_port = port;\n\t\tbp->nge_fw_dst_port_id = le16_to_cpu(resp->tunnel_dst_port_id);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\nerr_out:\n\thwrm_req_drop(bp, req);\n\treturn rc;\n}\n\nstatic int bnxt_hwrm_cfa_l2_set_rx_mask(struct bnxt *bp, u16 vnic_id)\n{\n\tstruct hwrm_cfa_l2_set_rx_mask_input *req;\n\tstruct bnxt_vnic_info *vnic = &bp->vnic_info[vnic_id];\n\tint rc;\n\n\trc = hwrm_req_init(bp, req, HWRM_CFA_L2_SET_RX_MASK);\n\tif (rc)\n\t\treturn rc;\n\n\treq->vnic_id = cpu_to_le32(vnic->fw_vnic_id);\n\tif (vnic->rx_mask & CFA_L2_SET_RX_MASK_REQ_MASK_MCAST) {\n\t\treq->num_mc_entries = cpu_to_le32(vnic->mc_list_count);\n\t\treq->mc_tbl_addr = cpu_to_le64(vnic->mc_list_mapping);\n\t}\n\treq->mask = cpu_to_le32(vnic->rx_mask);\n\treturn hwrm_req_send_silent(bp, req);\n}\n\n#ifdef CONFIG_RFS_ACCEL\nstatic int bnxt_hwrm_cfa_ntuple_filter_free(struct bnxt *bp,\n\t\t\t\t\t    struct bnxt_ntuple_filter *fltr)\n{\n\tstruct hwrm_cfa_ntuple_filter_free_input *req;\n\tint rc;\n\n\trc = hwrm_req_init(bp, req, HWRM_CFA_NTUPLE_FILTER_FREE);\n\tif (rc)\n\t\treturn rc;\n\n\treq->ntuple_filter_id = fltr->filter_id;\n\treturn hwrm_req_send(bp, req);\n}\n\n#define BNXT_NTP_FLTR_FLAGS\t\t\t\t\t\\\n\t(CFA_NTUPLE_FILTER_ALLOC_REQ_ENABLES_L2_FILTER_ID |\t\\\n\t CFA_NTUPLE_FILTER_ALLOC_REQ_ENABLES_ETHERTYPE |\t\\\n\t CFA_NTUPLE_FILTER_ALLOC_REQ_ENABLES_SRC_MACADDR |\t\\\n\t CFA_NTUPLE_FILTER_ALLOC_REQ_ENABLES_IPADDR_TYPE |\t\\\n\t CFA_NTUPLE_FILTER_ALLOC_REQ_ENABLES_SRC_IPADDR |\t\\\n\t CFA_NTUPLE_FILTER_ALLOC_REQ_ENABLES_SRC_IPADDR_MASK |\t\\\n\t CFA_NTUPLE_FILTER_ALLOC_REQ_ENABLES_DST_IPADDR |\t\\\n\t CFA_NTUPLE_FILTER_ALLOC_REQ_ENABLES_DST_IPADDR_MASK |\t\\\n\t CFA_NTUPLE_FILTER_ALLOC_REQ_ENABLES_IP_PROTOCOL |\t\\\n\t CFA_NTUPLE_FILTER_ALLOC_REQ_ENABLES_SRC_PORT |\t\t\\\n\t CFA_NTUPLE_FILTER_ALLOC_REQ_ENABLES_SRC_PORT_MASK |\t\\\n\t CFA_NTUPLE_FILTER_ALLOC_REQ_ENABLES_DST_PORT |\t\t\\\n\t CFA_NTUPLE_FILTER_ALLOC_REQ_ENABLES_DST_PORT_MASK |\t\\\n\t CFA_NTUPLE_FILTER_ALLOC_REQ_ENABLES_DST_ID)\n\n#define BNXT_NTP_TUNNEL_FLTR_FLAG\t\t\t\t\\\n\t\tCFA_NTUPLE_FILTER_ALLOC_REQ_ENABLES_TUNNEL_TYPE\n\nstatic int bnxt_hwrm_cfa_ntuple_filter_alloc(struct bnxt *bp,\n\t\t\t\t\t     struct bnxt_ntuple_filter *fltr)\n{\n\tstruct hwrm_cfa_ntuple_filter_alloc_output *resp;\n\tstruct hwrm_cfa_ntuple_filter_alloc_input *req;\n\tstruct flow_keys *keys = &fltr->fkeys;\n\tstruct bnxt_vnic_info *vnic;\n\tu32 flags = 0;\n\tint rc;\n\n\trc = hwrm_req_init(bp, req, HWRM_CFA_NTUPLE_FILTER_ALLOC);\n\tif (rc)\n\t\treturn rc;\n\n\treq->l2_filter_id = bp->vnic_info[0].fw_l2_filter_id[fltr->l2_fltr_idx];\n\n\tif (bp->fw_cap & BNXT_FW_CAP_CFA_RFS_RING_TBL_IDX_V2) {\n\t\tflags = CFA_NTUPLE_FILTER_ALLOC_REQ_FLAGS_DEST_RFS_RING_IDX;\n\t\treq->dst_id = cpu_to_le16(fltr->rxq);\n\t} else {\n\t\tvnic = &bp->vnic_info[fltr->rxq + 1];\n\t\treq->dst_id = cpu_to_le16(vnic->fw_vnic_id);\n\t}\n\treq->flags = cpu_to_le32(flags);\n\treq->enables = cpu_to_le32(BNXT_NTP_FLTR_FLAGS);\n\n\treq->ethertype = htons(ETH_P_IP);\n\tmemcpy(req->src_macaddr, fltr->src_mac_addr, ETH_ALEN);\n\treq->ip_addr_type = CFA_NTUPLE_FILTER_ALLOC_REQ_IP_ADDR_TYPE_IPV4;\n\treq->ip_protocol = keys->basic.ip_proto;\n\n\tif (keys->basic.n_proto == htons(ETH_P_IPV6)) {\n\t\tint i;\n\n\t\treq->ethertype = htons(ETH_P_IPV6);\n\t\treq->ip_addr_type =\n\t\t\tCFA_NTUPLE_FILTER_ALLOC_REQ_IP_ADDR_TYPE_IPV6;\n\t\t*(struct in6_addr *)&req->src_ipaddr[0] =\n\t\t\tkeys->addrs.v6addrs.src;\n\t\t*(struct in6_addr *)&req->dst_ipaddr[0] =\n\t\t\tkeys->addrs.v6addrs.dst;\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\treq->src_ipaddr_mask[i] = cpu_to_be32(0xffffffff);\n\t\t\treq->dst_ipaddr_mask[i] = cpu_to_be32(0xffffffff);\n\t\t}\n\t} else {\n\t\treq->src_ipaddr[0] = keys->addrs.v4addrs.src;\n\t\treq->src_ipaddr_mask[0] = cpu_to_be32(0xffffffff);\n\t\treq->dst_ipaddr[0] = keys->addrs.v4addrs.dst;\n\t\treq->dst_ipaddr_mask[0] = cpu_to_be32(0xffffffff);\n\t}\n\tif (keys->control.flags & FLOW_DIS_ENCAPSULATION) {\n\t\treq->enables |= cpu_to_le32(BNXT_NTP_TUNNEL_FLTR_FLAG);\n\t\treq->tunnel_type =\n\t\t\tCFA_NTUPLE_FILTER_ALLOC_REQ_TUNNEL_TYPE_ANYTUNNEL;\n\t}\n\n\treq->src_port = keys->ports.src;\n\treq->src_port_mask = cpu_to_be16(0xffff);\n\treq->dst_port = keys->ports.dst;\n\treq->dst_port_mask = cpu_to_be16(0xffff);\n\n\tresp = hwrm_req_hold(bp, req);\n\trc = hwrm_req_send(bp, req);\n\tif (!rc)\n\t\tfltr->filter_id = resp->ntuple_filter_id;\n\thwrm_req_drop(bp, req);\n\treturn rc;\n}\n#endif\n\nstatic int bnxt_hwrm_set_vnic_filter(struct bnxt *bp, u16 vnic_id, u16 idx,\n\t\t\t\t     const u8 *mac_addr)\n{\n\tstruct hwrm_cfa_l2_filter_alloc_output *resp;\n\tstruct hwrm_cfa_l2_filter_alloc_input *req;\n\tint rc;\n\n\trc = hwrm_req_init(bp, req, HWRM_CFA_L2_FILTER_ALLOC);\n\tif (rc)\n\t\treturn rc;\n\n\treq->flags = cpu_to_le32(CFA_L2_FILTER_ALLOC_REQ_FLAGS_PATH_RX);\n\tif (!BNXT_CHIP_TYPE_NITRO_A0(bp))\n\t\treq->flags |=\n\t\t\tcpu_to_le32(CFA_L2_FILTER_ALLOC_REQ_FLAGS_OUTERMOST);\n\treq->dst_id = cpu_to_le16(bp->vnic_info[vnic_id].fw_vnic_id);\n\treq->enables =\n\t\tcpu_to_le32(CFA_L2_FILTER_ALLOC_REQ_ENABLES_L2_ADDR |\n\t\t\t    CFA_L2_FILTER_ALLOC_REQ_ENABLES_DST_ID |\n\t\t\t    CFA_L2_FILTER_ALLOC_REQ_ENABLES_L2_ADDR_MASK);\n\tmemcpy(req->l2_addr, mac_addr, ETH_ALEN);\n\treq->l2_addr_mask[0] = 0xff;\n\treq->l2_addr_mask[1] = 0xff;\n\treq->l2_addr_mask[2] = 0xff;\n\treq->l2_addr_mask[3] = 0xff;\n\treq->l2_addr_mask[4] = 0xff;\n\treq->l2_addr_mask[5] = 0xff;\n\n\tresp = hwrm_req_hold(bp, req);\n\trc = hwrm_req_send(bp, req);\n\tif (!rc)\n\t\tbp->vnic_info[vnic_id].fw_l2_filter_id[idx] =\n\t\t\t\t\t\t\tresp->l2_filter_id;\n\thwrm_req_drop(bp, req);\n\treturn rc;\n}\n\nstatic int bnxt_hwrm_clear_vnic_filter(struct bnxt *bp)\n{\n\tstruct hwrm_cfa_l2_filter_free_input *req;\n\tu16 i, j, num_of_vnics = 1;  \n\tint rc;\n\n\t \n\trc = hwrm_req_init(bp, req, HWRM_CFA_L2_FILTER_FREE);\n\tif (rc)\n\t\treturn rc;\n\thwrm_req_hold(bp, req);\n\tfor (i = 0; i < num_of_vnics; i++) {\n\t\tstruct bnxt_vnic_info *vnic = &bp->vnic_info[i];\n\n\t\tfor (j = 0; j < vnic->uc_filter_count; j++) {\n\t\t\treq->l2_filter_id = vnic->fw_l2_filter_id[j];\n\n\t\t\trc = hwrm_req_send(bp, req);\n\t\t}\n\t\tvnic->uc_filter_count = 0;\n\t}\n\thwrm_req_drop(bp, req);\n\treturn rc;\n}\n\nstatic int bnxt_hwrm_vnic_set_tpa(struct bnxt *bp, u16 vnic_id, u32 tpa_flags)\n{\n\tstruct bnxt_vnic_info *vnic = &bp->vnic_info[vnic_id];\n\tu16 max_aggs = VNIC_TPA_CFG_REQ_MAX_AGGS_MAX;\n\tstruct hwrm_vnic_tpa_cfg_input *req;\n\tint rc;\n\n\tif (vnic->fw_vnic_id == INVALID_HW_RING_ID)\n\t\treturn 0;\n\n\trc = hwrm_req_init(bp, req, HWRM_VNIC_TPA_CFG);\n\tif (rc)\n\t\treturn rc;\n\n\tif (tpa_flags) {\n\t\tu16 mss = bp->dev->mtu - 40;\n\t\tu32 nsegs, n, segs = 0, flags;\n\n\t\tflags = VNIC_TPA_CFG_REQ_FLAGS_TPA |\n\t\t\tVNIC_TPA_CFG_REQ_FLAGS_ENCAP_TPA |\n\t\t\tVNIC_TPA_CFG_REQ_FLAGS_RSC_WND_UPDATE |\n\t\t\tVNIC_TPA_CFG_REQ_FLAGS_AGG_WITH_ECN |\n\t\t\tVNIC_TPA_CFG_REQ_FLAGS_AGG_WITH_SAME_GRE_SEQ;\n\t\tif (tpa_flags & BNXT_FLAG_GRO)\n\t\t\tflags |= VNIC_TPA_CFG_REQ_FLAGS_GRO;\n\n\t\treq->flags = cpu_to_le32(flags);\n\n\t\treq->enables =\n\t\t\tcpu_to_le32(VNIC_TPA_CFG_REQ_ENABLES_MAX_AGG_SEGS |\n\t\t\t\t    VNIC_TPA_CFG_REQ_ENABLES_MAX_AGGS |\n\t\t\t\t    VNIC_TPA_CFG_REQ_ENABLES_MIN_AGG_LEN);\n\n\t\t \n\t\tif (mss <= BNXT_RX_PAGE_SIZE) {\n\t\t\tn = BNXT_RX_PAGE_SIZE / mss;\n\t\t\tnsegs = (MAX_SKB_FRAGS - 1) * n;\n\t\t} else {\n\t\t\tn = mss / BNXT_RX_PAGE_SIZE;\n\t\t\tif (mss & (BNXT_RX_PAGE_SIZE - 1))\n\t\t\t\tn++;\n\t\t\tnsegs = (MAX_SKB_FRAGS - n) / n;\n\t\t}\n\n\t\tif (bp->flags & BNXT_FLAG_CHIP_P5) {\n\t\t\tsegs = MAX_TPA_SEGS_P5;\n\t\t\tmax_aggs = bp->max_tpa;\n\t\t} else {\n\t\t\tsegs = ilog2(nsegs);\n\t\t}\n\t\treq->max_agg_segs = cpu_to_le16(segs);\n\t\treq->max_aggs = cpu_to_le16(max_aggs);\n\n\t\treq->min_agg_len = cpu_to_le32(512);\n\t}\n\treq->vnic_id = cpu_to_le16(vnic->fw_vnic_id);\n\n\treturn hwrm_req_send(bp, req);\n}\n\nstatic u16 bnxt_cp_ring_from_grp(struct bnxt *bp, struct bnxt_ring_struct *ring)\n{\n\tstruct bnxt_ring_grp_info *grp_info;\n\n\tgrp_info = &bp->grp_info[ring->grp_idx];\n\treturn grp_info->cp_fw_ring_id;\n}\n\nstatic u16 bnxt_cp_ring_for_rx(struct bnxt *bp, struct bnxt_rx_ring_info *rxr)\n{\n\tif (bp->flags & BNXT_FLAG_CHIP_P5) {\n\t\tstruct bnxt_napi *bnapi = rxr->bnapi;\n\t\tstruct bnxt_cp_ring_info *cpr;\n\n\t\tcpr = bnapi->cp_ring.cp_ring_arr[BNXT_RX_HDL];\n\t\treturn cpr->cp_ring_struct.fw_ring_id;\n\t} else {\n\t\treturn bnxt_cp_ring_from_grp(bp, &rxr->rx_ring_struct);\n\t}\n}\n\nstatic u16 bnxt_cp_ring_for_tx(struct bnxt *bp, struct bnxt_tx_ring_info *txr)\n{\n\tif (bp->flags & BNXT_FLAG_CHIP_P5) {\n\t\tstruct bnxt_napi *bnapi = txr->bnapi;\n\t\tstruct bnxt_cp_ring_info *cpr;\n\n\t\tcpr = bnapi->cp_ring.cp_ring_arr[BNXT_TX_HDL];\n\t\treturn cpr->cp_ring_struct.fw_ring_id;\n\t} else {\n\t\treturn bnxt_cp_ring_from_grp(bp, &txr->tx_ring_struct);\n\t}\n}\n\nstatic int bnxt_alloc_rss_indir_tbl(struct bnxt *bp)\n{\n\tint entries;\n\n\tif (bp->flags & BNXT_FLAG_CHIP_P5)\n\t\tentries = BNXT_MAX_RSS_TABLE_ENTRIES_P5;\n\telse\n\t\tentries = HW_HASH_INDEX_SIZE;\n\n\tbp->rss_indir_tbl_entries = entries;\n\tbp->rss_indir_tbl = kmalloc_array(entries, sizeof(*bp->rss_indir_tbl),\n\t\t\t\t\t  GFP_KERNEL);\n\tif (!bp->rss_indir_tbl)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nstatic void bnxt_set_dflt_rss_indir_tbl(struct bnxt *bp)\n{\n\tu16 max_rings, max_entries, pad, i;\n\n\tif (!bp->rx_nr_rings)\n\t\treturn;\n\n\tif (BNXT_CHIP_TYPE_NITRO_A0(bp))\n\t\tmax_rings = bp->rx_nr_rings - 1;\n\telse\n\t\tmax_rings = bp->rx_nr_rings;\n\n\tmax_entries = bnxt_get_rxfh_indir_size(bp->dev);\n\n\tfor (i = 0; i < max_entries; i++)\n\t\tbp->rss_indir_tbl[i] = ethtool_rxfh_indir_default(i, max_rings);\n\n\tpad = bp->rss_indir_tbl_entries - max_entries;\n\tif (pad)\n\t\tmemset(&bp->rss_indir_tbl[i], 0, pad * sizeof(u16));\n}\n\nstatic u16 bnxt_get_max_rss_ring(struct bnxt *bp)\n{\n\tu16 i, tbl_size, max_ring = 0;\n\n\tif (!bp->rss_indir_tbl)\n\t\treturn 0;\n\n\ttbl_size = bnxt_get_rxfh_indir_size(bp->dev);\n\tfor (i = 0; i < tbl_size; i++)\n\t\tmax_ring = max(max_ring, bp->rss_indir_tbl[i]);\n\treturn max_ring;\n}\n\nint bnxt_get_nr_rss_ctxs(struct bnxt *bp, int rx_rings)\n{\n\tif (bp->flags & BNXT_FLAG_CHIP_P5)\n\t\treturn DIV_ROUND_UP(rx_rings, BNXT_RSS_TABLE_ENTRIES_P5);\n\tif (BNXT_CHIP_TYPE_NITRO_A0(bp))\n\t\treturn 2;\n\treturn 1;\n}\n\nstatic void bnxt_fill_hw_rss_tbl(struct bnxt *bp, struct bnxt_vnic_info *vnic)\n{\n\tbool no_rss = !(vnic->flags & BNXT_VNIC_RSS_FLAG);\n\tu16 i, j;\n\n\t \n\tfor (i = 0, j = 0; i < HW_HASH_INDEX_SIZE; i++) {\n\t\tif (!no_rss)\n\t\t\tj = bp->rss_indir_tbl[i];\n\t\tvnic->rss_table[i] = cpu_to_le16(vnic->fw_grp_ids[j]);\n\t}\n}\n\nstatic void bnxt_fill_hw_rss_tbl_p5(struct bnxt *bp,\n\t\t\t\t    struct bnxt_vnic_info *vnic)\n{\n\t__le16 *ring_tbl = vnic->rss_table;\n\tstruct bnxt_rx_ring_info *rxr;\n\tu16 tbl_size, i;\n\n\ttbl_size = bnxt_get_rxfh_indir_size(bp->dev);\n\n\tfor (i = 0; i < tbl_size; i++) {\n\t\tu16 ring_id, j;\n\n\t\tj = bp->rss_indir_tbl[i];\n\t\trxr = &bp->rx_ring[j];\n\n\t\tring_id = rxr->rx_ring_struct.fw_ring_id;\n\t\t*ring_tbl++ = cpu_to_le16(ring_id);\n\t\tring_id = bnxt_cp_ring_for_rx(bp, rxr);\n\t\t*ring_tbl++ = cpu_to_le16(ring_id);\n\t}\n}\n\nstatic void\n__bnxt_hwrm_vnic_set_rss(struct bnxt *bp, struct hwrm_vnic_rss_cfg_input *req,\n\t\t\t struct bnxt_vnic_info *vnic)\n{\n\tif (bp->flags & BNXT_FLAG_CHIP_P5)\n\t\tbnxt_fill_hw_rss_tbl_p5(bp, vnic);\n\telse\n\t\tbnxt_fill_hw_rss_tbl(bp, vnic);\n\n\tif (bp->rss_hash_delta) {\n\t\treq->hash_type = cpu_to_le32(bp->rss_hash_delta);\n\t\tif (bp->rss_hash_cfg & bp->rss_hash_delta)\n\t\t\treq->flags |= VNIC_RSS_CFG_REQ_FLAGS_HASH_TYPE_INCLUDE;\n\t\telse\n\t\t\treq->flags |= VNIC_RSS_CFG_REQ_FLAGS_HASH_TYPE_EXCLUDE;\n\t} else {\n\t\treq->hash_type = cpu_to_le32(bp->rss_hash_cfg);\n\t}\n\treq->hash_mode_flags = VNIC_RSS_CFG_REQ_HASH_MODE_FLAGS_DEFAULT;\n\treq->ring_grp_tbl_addr = cpu_to_le64(vnic->rss_table_dma_addr);\n\treq->hash_key_tbl_addr = cpu_to_le64(vnic->rss_hash_key_dma_addr);\n}\n\nstatic int bnxt_hwrm_vnic_set_rss(struct bnxt *bp, u16 vnic_id, bool set_rss)\n{\n\tstruct bnxt_vnic_info *vnic = &bp->vnic_info[vnic_id];\n\tstruct hwrm_vnic_rss_cfg_input *req;\n\tint rc;\n\n\tif ((bp->flags & BNXT_FLAG_CHIP_P5) ||\n\t    vnic->fw_rss_cos_lb_ctx[0] == INVALID_HW_RING_ID)\n\t\treturn 0;\n\n\trc = hwrm_req_init(bp, req, HWRM_VNIC_RSS_CFG);\n\tif (rc)\n\t\treturn rc;\n\n\tif (set_rss)\n\t\t__bnxt_hwrm_vnic_set_rss(bp, req, vnic);\n\treq->rss_ctx_idx = cpu_to_le16(vnic->fw_rss_cos_lb_ctx[0]);\n\treturn hwrm_req_send(bp, req);\n}\n\nstatic int bnxt_hwrm_vnic_set_rss_p5(struct bnxt *bp, u16 vnic_id, bool set_rss)\n{\n\tstruct bnxt_vnic_info *vnic = &bp->vnic_info[vnic_id];\n\tstruct hwrm_vnic_rss_cfg_input *req;\n\tdma_addr_t ring_tbl_map;\n\tu32 i, nr_ctxs;\n\tint rc;\n\n\trc = hwrm_req_init(bp, req, HWRM_VNIC_RSS_CFG);\n\tif (rc)\n\t\treturn rc;\n\n\treq->vnic_id = cpu_to_le16(vnic->fw_vnic_id);\n\tif (!set_rss)\n\t\treturn hwrm_req_send(bp, req);\n\n\t__bnxt_hwrm_vnic_set_rss(bp, req, vnic);\n\tring_tbl_map = vnic->rss_table_dma_addr;\n\tnr_ctxs = bnxt_get_nr_rss_ctxs(bp, bp->rx_nr_rings);\n\n\thwrm_req_hold(bp, req);\n\tfor (i = 0; i < nr_ctxs; ring_tbl_map += BNXT_RSS_TABLE_SIZE_P5, i++) {\n\t\treq->ring_grp_tbl_addr = cpu_to_le64(ring_tbl_map);\n\t\treq->ring_table_pair_index = i;\n\t\treq->rss_ctx_idx = cpu_to_le16(vnic->fw_rss_cos_lb_ctx[i]);\n\t\trc = hwrm_req_send(bp, req);\n\t\tif (rc)\n\t\t\tgoto exit;\n\t}\n\nexit:\n\thwrm_req_drop(bp, req);\n\treturn rc;\n}\n\nstatic void bnxt_hwrm_update_rss_hash_cfg(struct bnxt *bp)\n{\n\tstruct bnxt_vnic_info *vnic = &bp->vnic_info[0];\n\tstruct hwrm_vnic_rss_qcfg_output *resp;\n\tstruct hwrm_vnic_rss_qcfg_input *req;\n\n\tif (hwrm_req_init(bp, req, HWRM_VNIC_RSS_QCFG))\n\t\treturn;\n\n\treq->vnic_id = cpu_to_le16(vnic->fw_vnic_id);\n\t \n\treq->rss_ctx_idx = cpu_to_le16(vnic->fw_rss_cos_lb_ctx[0]);\n\tresp = hwrm_req_hold(bp, req);\n\tif (!hwrm_req_send(bp, req)) {\n\t\tbp->rss_hash_cfg = le32_to_cpu(resp->hash_type) ?: bp->rss_hash_cfg;\n\t\tbp->rss_hash_delta = 0;\n\t}\n\thwrm_req_drop(bp, req);\n}\n\nstatic int bnxt_hwrm_vnic_set_hds(struct bnxt *bp, u16 vnic_id)\n{\n\tstruct bnxt_vnic_info *vnic = &bp->vnic_info[vnic_id];\n\tstruct hwrm_vnic_plcmodes_cfg_input *req;\n\tint rc;\n\n\trc = hwrm_req_init(bp, req, HWRM_VNIC_PLCMODES_CFG);\n\tif (rc)\n\t\treturn rc;\n\n\treq->flags = cpu_to_le32(VNIC_PLCMODES_CFG_REQ_FLAGS_JUMBO_PLACEMENT);\n\treq->enables = cpu_to_le32(VNIC_PLCMODES_CFG_REQ_ENABLES_JUMBO_THRESH_VALID);\n\n\tif (BNXT_RX_PAGE_MODE(bp)) {\n\t\treq->jumbo_thresh = cpu_to_le16(bp->rx_buf_use_size);\n\t} else {\n\t\treq->flags |= cpu_to_le32(VNIC_PLCMODES_CFG_REQ_FLAGS_HDS_IPV4 |\n\t\t\t\t\t  VNIC_PLCMODES_CFG_REQ_FLAGS_HDS_IPV6);\n\t\treq->enables |=\n\t\t\tcpu_to_le32(VNIC_PLCMODES_CFG_REQ_ENABLES_HDS_THRESHOLD_VALID);\n\t\treq->jumbo_thresh = cpu_to_le16(bp->rx_copy_thresh);\n\t\treq->hds_threshold = cpu_to_le16(bp->rx_copy_thresh);\n\t}\n\treq->vnic_id = cpu_to_le32(vnic->fw_vnic_id);\n\treturn hwrm_req_send(bp, req);\n}\n\nstatic void bnxt_hwrm_vnic_ctx_free_one(struct bnxt *bp, u16 vnic_id,\n\t\t\t\t\tu16 ctx_idx)\n{\n\tstruct hwrm_vnic_rss_cos_lb_ctx_free_input *req;\n\n\tif (hwrm_req_init(bp, req, HWRM_VNIC_RSS_COS_LB_CTX_FREE))\n\t\treturn;\n\n\treq->rss_cos_lb_ctx_id =\n\t\tcpu_to_le16(bp->vnic_info[vnic_id].fw_rss_cos_lb_ctx[ctx_idx]);\n\n\thwrm_req_send(bp, req);\n\tbp->vnic_info[vnic_id].fw_rss_cos_lb_ctx[ctx_idx] = INVALID_HW_RING_ID;\n}\n\nstatic void bnxt_hwrm_vnic_ctx_free(struct bnxt *bp)\n{\n\tint i, j;\n\n\tfor (i = 0; i < bp->nr_vnics; i++) {\n\t\tstruct bnxt_vnic_info *vnic = &bp->vnic_info[i];\n\n\t\tfor (j = 0; j < BNXT_MAX_CTX_PER_VNIC; j++) {\n\t\t\tif (vnic->fw_rss_cos_lb_ctx[j] != INVALID_HW_RING_ID)\n\t\t\t\tbnxt_hwrm_vnic_ctx_free_one(bp, i, j);\n\t\t}\n\t}\n\tbp->rsscos_nr_ctxs = 0;\n}\n\nstatic int bnxt_hwrm_vnic_ctx_alloc(struct bnxt *bp, u16 vnic_id, u16 ctx_idx)\n{\n\tstruct hwrm_vnic_rss_cos_lb_ctx_alloc_output *resp;\n\tstruct hwrm_vnic_rss_cos_lb_ctx_alloc_input *req;\n\tint rc;\n\n\trc = hwrm_req_init(bp, req, HWRM_VNIC_RSS_COS_LB_CTX_ALLOC);\n\tif (rc)\n\t\treturn rc;\n\n\tresp = hwrm_req_hold(bp, req);\n\trc = hwrm_req_send(bp, req);\n\tif (!rc)\n\t\tbp->vnic_info[vnic_id].fw_rss_cos_lb_ctx[ctx_idx] =\n\t\t\tle16_to_cpu(resp->rss_cos_lb_ctx_id);\n\thwrm_req_drop(bp, req);\n\n\treturn rc;\n}\n\nstatic u32 bnxt_get_roce_vnic_mode(struct bnxt *bp)\n{\n\tif (bp->flags & BNXT_FLAG_ROCE_MIRROR_CAP)\n\t\treturn VNIC_CFG_REQ_FLAGS_ROCE_MIRRORING_CAPABLE_VNIC_MODE;\n\treturn VNIC_CFG_REQ_FLAGS_ROCE_DUAL_VNIC_MODE;\n}\n\nint bnxt_hwrm_vnic_cfg(struct bnxt *bp, u16 vnic_id)\n{\n\tstruct bnxt_vnic_info *vnic = &bp->vnic_info[vnic_id];\n\tstruct hwrm_vnic_cfg_input *req;\n\tunsigned int ring = 0, grp_idx;\n\tu16 def_vlan = 0;\n\tint rc;\n\n\trc = hwrm_req_init(bp, req, HWRM_VNIC_CFG);\n\tif (rc)\n\t\treturn rc;\n\n\tif (bp->flags & BNXT_FLAG_CHIP_P5) {\n\t\tstruct bnxt_rx_ring_info *rxr = &bp->rx_ring[0];\n\n\t\treq->default_rx_ring_id =\n\t\t\tcpu_to_le16(rxr->rx_ring_struct.fw_ring_id);\n\t\treq->default_cmpl_ring_id =\n\t\t\tcpu_to_le16(bnxt_cp_ring_for_rx(bp, rxr));\n\t\treq->enables =\n\t\t\tcpu_to_le32(VNIC_CFG_REQ_ENABLES_DEFAULT_RX_RING_ID |\n\t\t\t\t    VNIC_CFG_REQ_ENABLES_DEFAULT_CMPL_RING_ID);\n\t\tgoto vnic_mru;\n\t}\n\treq->enables = cpu_to_le32(VNIC_CFG_REQ_ENABLES_DFLT_RING_GRP);\n\t \n\tif (vnic->fw_rss_cos_lb_ctx[0] != INVALID_HW_RING_ID) {\n\t\treq->rss_rule = cpu_to_le16(vnic->fw_rss_cos_lb_ctx[0]);\n\t\treq->enables |= cpu_to_le32(VNIC_CFG_REQ_ENABLES_RSS_RULE |\n\t\t\t\t\t   VNIC_CFG_REQ_ENABLES_MRU);\n\t} else if (vnic->flags & BNXT_VNIC_RFS_NEW_RSS_FLAG) {\n\t\treq->rss_rule =\n\t\t\tcpu_to_le16(bp->vnic_info[0].fw_rss_cos_lb_ctx[0]);\n\t\treq->enables |= cpu_to_le32(VNIC_CFG_REQ_ENABLES_RSS_RULE |\n\t\t\t\t\t   VNIC_CFG_REQ_ENABLES_MRU);\n\t\treq->flags |= cpu_to_le32(VNIC_CFG_REQ_FLAGS_RSS_DFLT_CR_MODE);\n\t} else {\n\t\treq->rss_rule = cpu_to_le16(0xffff);\n\t}\n\n\tif (BNXT_CHIP_TYPE_NITRO_A0(bp) &&\n\t    (vnic->fw_rss_cos_lb_ctx[0] != INVALID_HW_RING_ID)) {\n\t\treq->cos_rule = cpu_to_le16(vnic->fw_rss_cos_lb_ctx[1]);\n\t\treq->enables |= cpu_to_le32(VNIC_CFG_REQ_ENABLES_COS_RULE);\n\t} else {\n\t\treq->cos_rule = cpu_to_le16(0xffff);\n\t}\n\n\tif (vnic->flags & BNXT_VNIC_RSS_FLAG)\n\t\tring = 0;\n\telse if (vnic->flags & BNXT_VNIC_RFS_FLAG)\n\t\tring = vnic_id - 1;\n\telse if ((vnic_id == 1) && BNXT_CHIP_TYPE_NITRO_A0(bp))\n\t\tring = bp->rx_nr_rings - 1;\n\n\tgrp_idx = bp->rx_ring[ring].bnapi->index;\n\treq->dflt_ring_grp = cpu_to_le16(bp->grp_info[grp_idx].fw_grp_id);\n\treq->lb_rule = cpu_to_le16(0xffff);\nvnic_mru:\n\treq->mru = cpu_to_le16(bp->dev->mtu + ETH_HLEN + VLAN_HLEN);\n\n\treq->vnic_id = cpu_to_le16(vnic->fw_vnic_id);\n#ifdef CONFIG_BNXT_SRIOV\n\tif (BNXT_VF(bp))\n\t\tdef_vlan = bp->vf.vlan;\n#endif\n\tif ((bp->flags & BNXT_FLAG_STRIP_VLAN) || def_vlan)\n\t\treq->flags |= cpu_to_le32(VNIC_CFG_REQ_FLAGS_VLAN_STRIP_MODE);\n\tif (!vnic_id && bnxt_ulp_registered(bp->edev))\n\t\treq->flags |= cpu_to_le32(bnxt_get_roce_vnic_mode(bp));\n\n\treturn hwrm_req_send(bp, req);\n}\n\nstatic void bnxt_hwrm_vnic_free_one(struct bnxt *bp, u16 vnic_id)\n{\n\tif (bp->vnic_info[vnic_id].fw_vnic_id != INVALID_HW_RING_ID) {\n\t\tstruct hwrm_vnic_free_input *req;\n\n\t\tif (hwrm_req_init(bp, req, HWRM_VNIC_FREE))\n\t\t\treturn;\n\n\t\treq->vnic_id =\n\t\t\tcpu_to_le32(bp->vnic_info[vnic_id].fw_vnic_id);\n\n\t\thwrm_req_send(bp, req);\n\t\tbp->vnic_info[vnic_id].fw_vnic_id = INVALID_HW_RING_ID;\n\t}\n}\n\nstatic void bnxt_hwrm_vnic_free(struct bnxt *bp)\n{\n\tu16 i;\n\n\tfor (i = 0; i < bp->nr_vnics; i++)\n\t\tbnxt_hwrm_vnic_free_one(bp, i);\n}\n\nstatic int bnxt_hwrm_vnic_alloc(struct bnxt *bp, u16 vnic_id,\n\t\t\t\tunsigned int start_rx_ring_idx,\n\t\t\t\tunsigned int nr_rings)\n{\n\tunsigned int i, j, grp_idx, end_idx = start_rx_ring_idx + nr_rings;\n\tstruct bnxt_vnic_info *vnic = &bp->vnic_info[vnic_id];\n\tstruct hwrm_vnic_alloc_output *resp;\n\tstruct hwrm_vnic_alloc_input *req;\n\tint rc;\n\n\trc = hwrm_req_init(bp, req, HWRM_VNIC_ALLOC);\n\tif (rc)\n\t\treturn rc;\n\n\tif (bp->flags & BNXT_FLAG_CHIP_P5)\n\t\tgoto vnic_no_ring_grps;\n\n\t \n\tfor (i = start_rx_ring_idx, j = 0; i < end_idx; i++, j++) {\n\t\tgrp_idx = bp->rx_ring[i].bnapi->index;\n\t\tif (bp->grp_info[grp_idx].fw_grp_id == INVALID_HW_RING_ID) {\n\t\t\tnetdev_err(bp->dev, \"Not enough ring groups avail:%x req:%x\\n\",\n\t\t\t\t   j, nr_rings);\n\t\t\tbreak;\n\t\t}\n\t\tvnic->fw_grp_ids[j] = bp->grp_info[grp_idx].fw_grp_id;\n\t}\n\nvnic_no_ring_grps:\n\tfor (i = 0; i < BNXT_MAX_CTX_PER_VNIC; i++)\n\t\tvnic->fw_rss_cos_lb_ctx[i] = INVALID_HW_RING_ID;\n\tif (vnic_id == 0)\n\t\treq->flags = cpu_to_le32(VNIC_ALLOC_REQ_FLAGS_DEFAULT);\n\n\tresp = hwrm_req_hold(bp, req);\n\trc = hwrm_req_send(bp, req);\n\tif (!rc)\n\t\tvnic->fw_vnic_id = le32_to_cpu(resp->vnic_id);\n\thwrm_req_drop(bp, req);\n\treturn rc;\n}\n\nstatic int bnxt_hwrm_vnic_qcaps(struct bnxt *bp)\n{\n\tstruct hwrm_vnic_qcaps_output *resp;\n\tstruct hwrm_vnic_qcaps_input *req;\n\tint rc;\n\n\tbp->hw_ring_stats_size = sizeof(struct ctx_hw_stats);\n\tbp->flags &= ~(BNXT_FLAG_NEW_RSS_CAP | BNXT_FLAG_ROCE_MIRROR_CAP);\n\tif (bp->hwrm_spec_code < 0x10600)\n\t\treturn 0;\n\n\trc = hwrm_req_init(bp, req, HWRM_VNIC_QCAPS);\n\tif (rc)\n\t\treturn rc;\n\n\tresp = hwrm_req_hold(bp, req);\n\trc = hwrm_req_send(bp, req);\n\tif (!rc) {\n\t\tu32 flags = le32_to_cpu(resp->flags);\n\n\t\tif (!(bp->flags & BNXT_FLAG_CHIP_P5) &&\n\t\t    (flags & VNIC_QCAPS_RESP_FLAGS_RSS_DFLT_CR_CAP))\n\t\t\tbp->flags |= BNXT_FLAG_NEW_RSS_CAP;\n\t\tif (flags &\n\t\t    VNIC_QCAPS_RESP_FLAGS_ROCE_MIRRORING_CAPABLE_VNIC_CAP)\n\t\t\tbp->flags |= BNXT_FLAG_ROCE_MIRROR_CAP;\n\n\t\t \n\t\tif ((flags & VNIC_QCAPS_RESP_FLAGS_VLAN_STRIP_CAP) ||\n\t\t    (BNXT_CHIP_P5_THOR(bp) &&\n\t\t     !(bp->fw_cap & BNXT_FW_CAP_EXT_HW_STATS_SUPPORTED)))\n\t\t\tbp->fw_cap |= BNXT_FW_CAP_VLAN_RX_STRIP;\n\t\tif (flags & VNIC_QCAPS_RESP_FLAGS_RSS_HASH_TYPE_DELTA_CAP)\n\t\t\tbp->fw_cap |= BNXT_FW_CAP_RSS_HASH_TYPE_DELTA;\n\t\tbp->max_tpa_v2 = le16_to_cpu(resp->max_aggs_supported);\n\t\tif (bp->max_tpa_v2) {\n\t\t\tif (BNXT_CHIP_P5_THOR(bp))\n\t\t\t\tbp->hw_ring_stats_size = BNXT_RING_STATS_SIZE_P5;\n\t\t\telse\n\t\t\t\tbp->hw_ring_stats_size = BNXT_RING_STATS_SIZE_P5_SR2;\n\t\t}\n\t}\n\thwrm_req_drop(bp, req);\n\treturn rc;\n}\n\nstatic int bnxt_hwrm_ring_grp_alloc(struct bnxt *bp)\n{\n\tstruct hwrm_ring_grp_alloc_output *resp;\n\tstruct hwrm_ring_grp_alloc_input *req;\n\tint rc;\n\tu16 i;\n\n\tif (bp->flags & BNXT_FLAG_CHIP_P5)\n\t\treturn 0;\n\n\trc = hwrm_req_init(bp, req, HWRM_RING_GRP_ALLOC);\n\tif (rc)\n\t\treturn rc;\n\n\tresp = hwrm_req_hold(bp, req);\n\tfor (i = 0; i < bp->rx_nr_rings; i++) {\n\t\tunsigned int grp_idx = bp->rx_ring[i].bnapi->index;\n\n\t\treq->cr = cpu_to_le16(bp->grp_info[grp_idx].cp_fw_ring_id);\n\t\treq->rr = cpu_to_le16(bp->grp_info[grp_idx].rx_fw_ring_id);\n\t\treq->ar = cpu_to_le16(bp->grp_info[grp_idx].agg_fw_ring_id);\n\t\treq->sc = cpu_to_le16(bp->grp_info[grp_idx].fw_stats_ctx);\n\n\t\trc = hwrm_req_send(bp, req);\n\n\t\tif (rc)\n\t\t\tbreak;\n\n\t\tbp->grp_info[grp_idx].fw_grp_id =\n\t\t\tle32_to_cpu(resp->ring_group_id);\n\t}\n\thwrm_req_drop(bp, req);\n\treturn rc;\n}\n\nstatic void bnxt_hwrm_ring_grp_free(struct bnxt *bp)\n{\n\tstruct hwrm_ring_grp_free_input *req;\n\tu16 i;\n\n\tif (!bp->grp_info || (bp->flags & BNXT_FLAG_CHIP_P5))\n\t\treturn;\n\n\tif (hwrm_req_init(bp, req, HWRM_RING_GRP_FREE))\n\t\treturn;\n\n\thwrm_req_hold(bp, req);\n\tfor (i = 0; i < bp->cp_nr_rings; i++) {\n\t\tif (bp->grp_info[i].fw_grp_id == INVALID_HW_RING_ID)\n\t\t\tcontinue;\n\t\treq->ring_group_id =\n\t\t\tcpu_to_le32(bp->grp_info[i].fw_grp_id);\n\n\t\thwrm_req_send(bp, req);\n\t\tbp->grp_info[i].fw_grp_id = INVALID_HW_RING_ID;\n\t}\n\thwrm_req_drop(bp, req);\n}\n\nstatic int hwrm_ring_alloc_send_msg(struct bnxt *bp,\n\t\t\t\t    struct bnxt_ring_struct *ring,\n\t\t\t\t    u32 ring_type, u32 map_index)\n{\n\tstruct hwrm_ring_alloc_output *resp;\n\tstruct hwrm_ring_alloc_input *req;\n\tstruct bnxt_ring_mem_info *rmem = &ring->ring_mem;\n\tstruct bnxt_ring_grp_info *grp_info;\n\tint rc, err = 0;\n\tu16 ring_id;\n\n\trc = hwrm_req_init(bp, req, HWRM_RING_ALLOC);\n\tif (rc)\n\t\tgoto exit;\n\n\treq->enables = 0;\n\tif (rmem->nr_pages > 1) {\n\t\treq->page_tbl_addr = cpu_to_le64(rmem->pg_tbl_map);\n\t\t \n\t\treq->page_size = BNXT_PAGE_SHIFT;\n\t\treq->page_tbl_depth = 1;\n\t} else {\n\t\treq->page_tbl_addr =  cpu_to_le64(rmem->dma_arr[0]);\n\t}\n\treq->fbo = 0;\n\t \n\treq->logical_id = cpu_to_le16(map_index);\n\n\tswitch (ring_type) {\n\tcase HWRM_RING_ALLOC_TX: {\n\t\tstruct bnxt_tx_ring_info *txr;\n\n\t\ttxr = container_of(ring, struct bnxt_tx_ring_info,\n\t\t\t\t   tx_ring_struct);\n\t\treq->ring_type = RING_ALLOC_REQ_RING_TYPE_TX;\n\t\t \n\t\tgrp_info = &bp->grp_info[ring->grp_idx];\n\t\treq->cmpl_ring_id = cpu_to_le16(bnxt_cp_ring_for_tx(bp, txr));\n\t\treq->length = cpu_to_le32(bp->tx_ring_mask + 1);\n\t\treq->stat_ctx_id = cpu_to_le32(grp_info->fw_stats_ctx);\n\t\treq->queue_id = cpu_to_le16(ring->queue_id);\n\t\tbreak;\n\t}\n\tcase HWRM_RING_ALLOC_RX:\n\t\treq->ring_type = RING_ALLOC_REQ_RING_TYPE_RX;\n\t\treq->length = cpu_to_le32(bp->rx_ring_mask + 1);\n\t\tif (bp->flags & BNXT_FLAG_CHIP_P5) {\n\t\t\tu16 flags = 0;\n\n\t\t\t \n\t\t\tgrp_info = &bp->grp_info[ring->grp_idx];\n\t\t\treq->rx_buf_size = cpu_to_le16(bp->rx_buf_use_size);\n\t\t\treq->stat_ctx_id = cpu_to_le32(grp_info->fw_stats_ctx);\n\t\t\treq->enables |= cpu_to_le32(\n\t\t\t\tRING_ALLOC_REQ_ENABLES_RX_BUF_SIZE_VALID);\n\t\t\tif (NET_IP_ALIGN == 2)\n\t\t\t\tflags = RING_ALLOC_REQ_FLAGS_RX_SOP_PAD;\n\t\t\treq->flags = cpu_to_le16(flags);\n\t\t}\n\t\tbreak;\n\tcase HWRM_RING_ALLOC_AGG:\n\t\tif (bp->flags & BNXT_FLAG_CHIP_P5) {\n\t\t\treq->ring_type = RING_ALLOC_REQ_RING_TYPE_RX_AGG;\n\t\t\t \n\t\t\tgrp_info = &bp->grp_info[ring->grp_idx];\n\t\t\treq->rx_ring_id = cpu_to_le16(grp_info->rx_fw_ring_id);\n\t\t\treq->rx_buf_size = cpu_to_le16(BNXT_RX_PAGE_SIZE);\n\t\t\treq->stat_ctx_id = cpu_to_le32(grp_info->fw_stats_ctx);\n\t\t\treq->enables |= cpu_to_le32(\n\t\t\t\tRING_ALLOC_REQ_ENABLES_RX_RING_ID_VALID |\n\t\t\t\tRING_ALLOC_REQ_ENABLES_RX_BUF_SIZE_VALID);\n\t\t} else {\n\t\t\treq->ring_type = RING_ALLOC_REQ_RING_TYPE_RX;\n\t\t}\n\t\treq->length = cpu_to_le32(bp->rx_agg_ring_mask + 1);\n\t\tbreak;\n\tcase HWRM_RING_ALLOC_CMPL:\n\t\treq->ring_type = RING_ALLOC_REQ_RING_TYPE_L2_CMPL;\n\t\treq->length = cpu_to_le32(bp->cp_ring_mask + 1);\n\t\tif (bp->flags & BNXT_FLAG_CHIP_P5) {\n\t\t\t \n\t\t\tgrp_info = &bp->grp_info[map_index];\n\t\t\treq->nq_ring_id = cpu_to_le16(grp_info->cp_fw_ring_id);\n\t\t\treq->cq_handle = cpu_to_le64(ring->handle);\n\t\t\treq->enables |= cpu_to_le32(\n\t\t\t\tRING_ALLOC_REQ_ENABLES_NQ_RING_ID_VALID);\n\t\t} else if (bp->flags & BNXT_FLAG_USING_MSIX) {\n\t\t\treq->int_mode = RING_ALLOC_REQ_INT_MODE_MSIX;\n\t\t}\n\t\tbreak;\n\tcase HWRM_RING_ALLOC_NQ:\n\t\treq->ring_type = RING_ALLOC_REQ_RING_TYPE_NQ;\n\t\treq->length = cpu_to_le32(bp->cp_ring_mask + 1);\n\t\tif (bp->flags & BNXT_FLAG_USING_MSIX)\n\t\t\treq->int_mode = RING_ALLOC_REQ_INT_MODE_MSIX;\n\t\tbreak;\n\tdefault:\n\t\tnetdev_err(bp->dev, \"hwrm alloc invalid ring type %d\\n\",\n\t\t\t   ring_type);\n\t\treturn -1;\n\t}\n\n\tresp = hwrm_req_hold(bp, req);\n\trc = hwrm_req_send(bp, req);\n\terr = le16_to_cpu(resp->error_code);\n\tring_id = le16_to_cpu(resp->ring_id);\n\thwrm_req_drop(bp, req);\n\nexit:\n\tif (rc || err) {\n\t\tnetdev_err(bp->dev, \"hwrm_ring_alloc type %d failed. rc:%x err:%x\\n\",\n\t\t\t   ring_type, rc, err);\n\t\treturn -EIO;\n\t}\n\tring->fw_ring_id = ring_id;\n\treturn rc;\n}\n\nstatic int bnxt_hwrm_set_async_event_cr(struct bnxt *bp, int idx)\n{\n\tint rc;\n\n\tif (BNXT_PF(bp)) {\n\t\tstruct hwrm_func_cfg_input *req;\n\n\t\trc = hwrm_req_init(bp, req, HWRM_FUNC_CFG);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\treq->fid = cpu_to_le16(0xffff);\n\t\treq->enables = cpu_to_le32(FUNC_CFG_REQ_ENABLES_ASYNC_EVENT_CR);\n\t\treq->async_event_cr = cpu_to_le16(idx);\n\t\treturn hwrm_req_send(bp, req);\n\t} else {\n\t\tstruct hwrm_func_vf_cfg_input *req;\n\n\t\trc = hwrm_req_init(bp, req, HWRM_FUNC_VF_CFG);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\treq->enables =\n\t\t\tcpu_to_le32(FUNC_VF_CFG_REQ_ENABLES_ASYNC_EVENT_CR);\n\t\treq->async_event_cr = cpu_to_le16(idx);\n\t\treturn hwrm_req_send(bp, req);\n\t}\n}\n\nstatic void bnxt_set_db(struct bnxt *bp, struct bnxt_db_info *db, u32 ring_type,\n\t\t\tu32 map_idx, u32 xid)\n{\n\tif (bp->flags & BNXT_FLAG_CHIP_P5) {\n\t\tif (BNXT_PF(bp))\n\t\t\tdb->doorbell = bp->bar1 + DB_PF_OFFSET_P5;\n\t\telse\n\t\t\tdb->doorbell = bp->bar1 + DB_VF_OFFSET_P5;\n\t\tswitch (ring_type) {\n\t\tcase HWRM_RING_ALLOC_TX:\n\t\t\tdb->db_key64 = DBR_PATH_L2 | DBR_TYPE_SQ;\n\t\t\tbreak;\n\t\tcase HWRM_RING_ALLOC_RX:\n\t\tcase HWRM_RING_ALLOC_AGG:\n\t\t\tdb->db_key64 = DBR_PATH_L2 | DBR_TYPE_SRQ;\n\t\t\tbreak;\n\t\tcase HWRM_RING_ALLOC_CMPL:\n\t\t\tdb->db_key64 = DBR_PATH_L2;\n\t\t\tbreak;\n\t\tcase HWRM_RING_ALLOC_NQ:\n\t\t\tdb->db_key64 = DBR_PATH_L2;\n\t\t\tbreak;\n\t\t}\n\t\tdb->db_key64 |= (u64)xid << DBR_XID_SFT;\n\t} else {\n\t\tdb->doorbell = bp->bar1 + map_idx * 0x80;\n\t\tswitch (ring_type) {\n\t\tcase HWRM_RING_ALLOC_TX:\n\t\t\tdb->db_key32 = DB_KEY_TX;\n\t\t\tbreak;\n\t\tcase HWRM_RING_ALLOC_RX:\n\t\tcase HWRM_RING_ALLOC_AGG:\n\t\t\tdb->db_key32 = DB_KEY_RX;\n\t\t\tbreak;\n\t\tcase HWRM_RING_ALLOC_CMPL:\n\t\t\tdb->db_key32 = DB_KEY_CP;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic int bnxt_hwrm_ring_alloc(struct bnxt *bp)\n{\n\tbool agg_rings = !!(bp->flags & BNXT_FLAG_AGG_RINGS);\n\tint i, rc = 0;\n\tu32 type;\n\n\tif (bp->flags & BNXT_FLAG_CHIP_P5)\n\t\ttype = HWRM_RING_ALLOC_NQ;\n\telse\n\t\ttype = HWRM_RING_ALLOC_CMPL;\n\tfor (i = 0; i < bp->cp_nr_rings; i++) {\n\t\tstruct bnxt_napi *bnapi = bp->bnapi[i];\n\t\tstruct bnxt_cp_ring_info *cpr = &bnapi->cp_ring;\n\t\tstruct bnxt_ring_struct *ring = &cpr->cp_ring_struct;\n\t\tu32 map_idx = ring->map_idx;\n\t\tunsigned int vector;\n\n\t\tvector = bp->irq_tbl[map_idx].vector;\n\t\tdisable_irq_nosync(vector);\n\t\trc = hwrm_ring_alloc_send_msg(bp, ring, type, map_idx);\n\t\tif (rc) {\n\t\t\tenable_irq(vector);\n\t\t\tgoto err_out;\n\t\t}\n\t\tbnxt_set_db(bp, &cpr->cp_db, type, map_idx, ring->fw_ring_id);\n\t\tbnxt_db_nq(bp, &cpr->cp_db, cpr->cp_raw_cons);\n\t\tenable_irq(vector);\n\t\tbp->grp_info[i].cp_fw_ring_id = ring->fw_ring_id;\n\n\t\tif (!i) {\n\t\t\trc = bnxt_hwrm_set_async_event_cr(bp, ring->fw_ring_id);\n\t\t\tif (rc)\n\t\t\t\tnetdev_warn(bp->dev, \"Failed to set async event completion ring.\\n\");\n\t\t}\n\t}\n\n\ttype = HWRM_RING_ALLOC_TX;\n\tfor (i = 0; i < bp->tx_nr_rings; i++) {\n\t\tstruct bnxt_tx_ring_info *txr = &bp->tx_ring[i];\n\t\tstruct bnxt_ring_struct *ring;\n\t\tu32 map_idx;\n\n\t\tif (bp->flags & BNXT_FLAG_CHIP_P5) {\n\t\t\tstruct bnxt_napi *bnapi = txr->bnapi;\n\t\t\tstruct bnxt_cp_ring_info *cpr, *cpr2;\n\t\t\tu32 type2 = HWRM_RING_ALLOC_CMPL;\n\n\t\t\tcpr = &bnapi->cp_ring;\n\t\t\tcpr2 = cpr->cp_ring_arr[BNXT_TX_HDL];\n\t\t\tring = &cpr2->cp_ring_struct;\n\t\t\tring->handle = BNXT_TX_HDL;\n\t\t\tmap_idx = bnapi->index;\n\t\t\trc = hwrm_ring_alloc_send_msg(bp, ring, type2, map_idx);\n\t\t\tif (rc)\n\t\t\t\tgoto err_out;\n\t\t\tbnxt_set_db(bp, &cpr2->cp_db, type2, map_idx,\n\t\t\t\t    ring->fw_ring_id);\n\t\t\tbnxt_db_cq(bp, &cpr2->cp_db, cpr2->cp_raw_cons);\n\t\t}\n\t\tring = &txr->tx_ring_struct;\n\t\tmap_idx = i;\n\t\trc = hwrm_ring_alloc_send_msg(bp, ring, type, map_idx);\n\t\tif (rc)\n\t\t\tgoto err_out;\n\t\tbnxt_set_db(bp, &txr->tx_db, type, map_idx, ring->fw_ring_id);\n\t}\n\n\ttype = HWRM_RING_ALLOC_RX;\n\tfor (i = 0; i < bp->rx_nr_rings; i++) {\n\t\tstruct bnxt_rx_ring_info *rxr = &bp->rx_ring[i];\n\t\tstruct bnxt_ring_struct *ring = &rxr->rx_ring_struct;\n\t\tstruct bnxt_napi *bnapi = rxr->bnapi;\n\t\tu32 map_idx = bnapi->index;\n\n\t\trc = hwrm_ring_alloc_send_msg(bp, ring, type, map_idx);\n\t\tif (rc)\n\t\t\tgoto err_out;\n\t\tbnxt_set_db(bp, &rxr->rx_db, type, map_idx, ring->fw_ring_id);\n\t\t \n\t\tif (!agg_rings)\n\t\t\tbnxt_db_write(bp, &rxr->rx_db, rxr->rx_prod);\n\t\tbp->grp_info[map_idx].rx_fw_ring_id = ring->fw_ring_id;\n\t\tif (bp->flags & BNXT_FLAG_CHIP_P5) {\n\t\t\tstruct bnxt_cp_ring_info *cpr = &bnapi->cp_ring;\n\t\t\tu32 type2 = HWRM_RING_ALLOC_CMPL;\n\t\t\tstruct bnxt_cp_ring_info *cpr2;\n\n\t\t\tcpr2 = cpr->cp_ring_arr[BNXT_RX_HDL];\n\t\t\tring = &cpr2->cp_ring_struct;\n\t\t\tring->handle = BNXT_RX_HDL;\n\t\t\trc = hwrm_ring_alloc_send_msg(bp, ring, type2, map_idx);\n\t\t\tif (rc)\n\t\t\t\tgoto err_out;\n\t\t\tbnxt_set_db(bp, &cpr2->cp_db, type2, map_idx,\n\t\t\t\t    ring->fw_ring_id);\n\t\t\tbnxt_db_cq(bp, &cpr2->cp_db, cpr2->cp_raw_cons);\n\t\t}\n\t}\n\n\tif (agg_rings) {\n\t\ttype = HWRM_RING_ALLOC_AGG;\n\t\tfor (i = 0; i < bp->rx_nr_rings; i++) {\n\t\t\tstruct bnxt_rx_ring_info *rxr = &bp->rx_ring[i];\n\t\t\tstruct bnxt_ring_struct *ring =\n\t\t\t\t\t\t&rxr->rx_agg_ring_struct;\n\t\t\tu32 grp_idx = ring->grp_idx;\n\t\t\tu32 map_idx = grp_idx + bp->rx_nr_rings;\n\n\t\t\trc = hwrm_ring_alloc_send_msg(bp, ring, type, map_idx);\n\t\t\tif (rc)\n\t\t\t\tgoto err_out;\n\n\t\t\tbnxt_set_db(bp, &rxr->rx_agg_db, type, map_idx,\n\t\t\t\t    ring->fw_ring_id);\n\t\t\tbnxt_db_write(bp, &rxr->rx_agg_db, rxr->rx_agg_prod);\n\t\t\tbnxt_db_write(bp, &rxr->rx_db, rxr->rx_prod);\n\t\t\tbp->grp_info[grp_idx].agg_fw_ring_id = ring->fw_ring_id;\n\t\t}\n\t}\nerr_out:\n\treturn rc;\n}\n\nstatic int hwrm_ring_free_send_msg(struct bnxt *bp,\n\t\t\t\t   struct bnxt_ring_struct *ring,\n\t\t\t\t   u32 ring_type, int cmpl_ring_id)\n{\n\tstruct hwrm_ring_free_output *resp;\n\tstruct hwrm_ring_free_input *req;\n\tu16 error_code = 0;\n\tint rc;\n\n\tif (BNXT_NO_FW_ACCESS(bp))\n\t\treturn 0;\n\n\trc = hwrm_req_init(bp, req, HWRM_RING_FREE);\n\tif (rc)\n\t\tgoto exit;\n\n\treq->cmpl_ring = cpu_to_le16(cmpl_ring_id);\n\treq->ring_type = ring_type;\n\treq->ring_id = cpu_to_le16(ring->fw_ring_id);\n\n\tresp = hwrm_req_hold(bp, req);\n\trc = hwrm_req_send(bp, req);\n\terror_code = le16_to_cpu(resp->error_code);\n\thwrm_req_drop(bp, req);\nexit:\n\tif (rc || error_code) {\n\t\tnetdev_err(bp->dev, \"hwrm_ring_free type %d failed. rc:%x err:%x\\n\",\n\t\t\t   ring_type, rc, error_code);\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}\n\nstatic void bnxt_hwrm_ring_free(struct bnxt *bp, bool close_path)\n{\n\tu32 type;\n\tint i;\n\n\tif (!bp->bnapi)\n\t\treturn;\n\n\tfor (i = 0; i < bp->tx_nr_rings; i++) {\n\t\tstruct bnxt_tx_ring_info *txr = &bp->tx_ring[i];\n\t\tstruct bnxt_ring_struct *ring = &txr->tx_ring_struct;\n\n\t\tif (ring->fw_ring_id != INVALID_HW_RING_ID) {\n\t\t\tu32 cmpl_ring_id = bnxt_cp_ring_for_tx(bp, txr);\n\n\t\t\thwrm_ring_free_send_msg(bp, ring,\n\t\t\t\t\t\tRING_FREE_REQ_RING_TYPE_TX,\n\t\t\t\t\t\tclose_path ? cmpl_ring_id :\n\t\t\t\t\t\tINVALID_HW_RING_ID);\n\t\t\tring->fw_ring_id = INVALID_HW_RING_ID;\n\t\t}\n\t}\n\n\tfor (i = 0; i < bp->rx_nr_rings; i++) {\n\t\tstruct bnxt_rx_ring_info *rxr = &bp->rx_ring[i];\n\t\tstruct bnxt_ring_struct *ring = &rxr->rx_ring_struct;\n\t\tu32 grp_idx = rxr->bnapi->index;\n\n\t\tif (ring->fw_ring_id != INVALID_HW_RING_ID) {\n\t\t\tu32 cmpl_ring_id = bnxt_cp_ring_for_rx(bp, rxr);\n\n\t\t\thwrm_ring_free_send_msg(bp, ring,\n\t\t\t\t\t\tRING_FREE_REQ_RING_TYPE_RX,\n\t\t\t\t\t\tclose_path ? cmpl_ring_id :\n\t\t\t\t\t\tINVALID_HW_RING_ID);\n\t\t\tring->fw_ring_id = INVALID_HW_RING_ID;\n\t\t\tbp->grp_info[grp_idx].rx_fw_ring_id =\n\t\t\t\tINVALID_HW_RING_ID;\n\t\t}\n\t}\n\n\tif (bp->flags & BNXT_FLAG_CHIP_P5)\n\t\ttype = RING_FREE_REQ_RING_TYPE_RX_AGG;\n\telse\n\t\ttype = RING_FREE_REQ_RING_TYPE_RX;\n\tfor (i = 0; i < bp->rx_nr_rings; i++) {\n\t\tstruct bnxt_rx_ring_info *rxr = &bp->rx_ring[i];\n\t\tstruct bnxt_ring_struct *ring = &rxr->rx_agg_ring_struct;\n\t\tu32 grp_idx = rxr->bnapi->index;\n\n\t\tif (ring->fw_ring_id != INVALID_HW_RING_ID) {\n\t\t\tu32 cmpl_ring_id = bnxt_cp_ring_for_rx(bp, rxr);\n\n\t\t\thwrm_ring_free_send_msg(bp, ring, type,\n\t\t\t\t\t\tclose_path ? cmpl_ring_id :\n\t\t\t\t\t\tINVALID_HW_RING_ID);\n\t\t\tring->fw_ring_id = INVALID_HW_RING_ID;\n\t\t\tbp->grp_info[grp_idx].agg_fw_ring_id =\n\t\t\t\tINVALID_HW_RING_ID;\n\t\t}\n\t}\n\n\t \n\tbnxt_disable_int_sync(bp);\n\n\tif (bp->flags & BNXT_FLAG_CHIP_P5)\n\t\ttype = RING_FREE_REQ_RING_TYPE_NQ;\n\telse\n\t\ttype = RING_FREE_REQ_RING_TYPE_L2_CMPL;\n\tfor (i = 0; i < bp->cp_nr_rings; i++) {\n\t\tstruct bnxt_napi *bnapi = bp->bnapi[i];\n\t\tstruct bnxt_cp_ring_info *cpr = &bnapi->cp_ring;\n\t\tstruct bnxt_ring_struct *ring;\n\t\tint j;\n\n\t\tfor (j = 0; j < 2; j++) {\n\t\t\tstruct bnxt_cp_ring_info *cpr2 = cpr->cp_ring_arr[j];\n\n\t\t\tif (cpr2) {\n\t\t\t\tring = &cpr2->cp_ring_struct;\n\t\t\t\tif (ring->fw_ring_id == INVALID_HW_RING_ID)\n\t\t\t\t\tcontinue;\n\t\t\t\thwrm_ring_free_send_msg(bp, ring,\n\t\t\t\t\tRING_FREE_REQ_RING_TYPE_L2_CMPL,\n\t\t\t\t\tINVALID_HW_RING_ID);\n\t\t\t\tring->fw_ring_id = INVALID_HW_RING_ID;\n\t\t\t}\n\t\t}\n\t\tring = &cpr->cp_ring_struct;\n\t\tif (ring->fw_ring_id != INVALID_HW_RING_ID) {\n\t\t\thwrm_ring_free_send_msg(bp, ring, type,\n\t\t\t\t\t\tINVALID_HW_RING_ID);\n\t\t\tring->fw_ring_id = INVALID_HW_RING_ID;\n\t\t\tbp->grp_info[i].cp_fw_ring_id = INVALID_HW_RING_ID;\n\t\t}\n\t}\n}\n\nstatic int bnxt_trim_rings(struct bnxt *bp, int *rx, int *tx, int max,\n\t\t\t   bool shared);\n\nstatic int bnxt_hwrm_get_rings(struct bnxt *bp)\n{\n\tstruct bnxt_hw_resc *hw_resc = &bp->hw_resc;\n\tstruct hwrm_func_qcfg_output *resp;\n\tstruct hwrm_func_qcfg_input *req;\n\tint rc;\n\n\tif (bp->hwrm_spec_code < 0x10601)\n\t\treturn 0;\n\n\trc = hwrm_req_init(bp, req, HWRM_FUNC_QCFG);\n\tif (rc)\n\t\treturn rc;\n\n\treq->fid = cpu_to_le16(0xffff);\n\tresp = hwrm_req_hold(bp, req);\n\trc = hwrm_req_send(bp, req);\n\tif (rc) {\n\t\thwrm_req_drop(bp, req);\n\t\treturn rc;\n\t}\n\n\thw_resc->resv_tx_rings = le16_to_cpu(resp->alloc_tx_rings);\n\tif (BNXT_NEW_RM(bp)) {\n\t\tu16 cp, stats;\n\n\t\thw_resc->resv_rx_rings = le16_to_cpu(resp->alloc_rx_rings);\n\t\thw_resc->resv_hw_ring_grps =\n\t\t\tle32_to_cpu(resp->alloc_hw_ring_grps);\n\t\thw_resc->resv_vnics = le16_to_cpu(resp->alloc_vnics);\n\t\tcp = le16_to_cpu(resp->alloc_cmpl_rings);\n\t\tstats = le16_to_cpu(resp->alloc_stat_ctx);\n\t\thw_resc->resv_irqs = cp;\n\t\tif (bp->flags & BNXT_FLAG_CHIP_P5) {\n\t\t\tint rx = hw_resc->resv_rx_rings;\n\t\t\tint tx = hw_resc->resv_tx_rings;\n\n\t\t\tif (bp->flags & BNXT_FLAG_AGG_RINGS)\n\t\t\t\trx >>= 1;\n\t\t\tif (cp < (rx + tx)) {\n\t\t\t\tbnxt_trim_rings(bp, &rx, &tx, cp, false);\n\t\t\t\tif (bp->flags & BNXT_FLAG_AGG_RINGS)\n\t\t\t\t\trx <<= 1;\n\t\t\t\thw_resc->resv_rx_rings = rx;\n\t\t\t\thw_resc->resv_tx_rings = tx;\n\t\t\t}\n\t\t\thw_resc->resv_irqs = le16_to_cpu(resp->alloc_msix);\n\t\t\thw_resc->resv_hw_ring_grps = rx;\n\t\t}\n\t\thw_resc->resv_cp_rings = cp;\n\t\thw_resc->resv_stat_ctxs = stats;\n\t}\n\thwrm_req_drop(bp, req);\n\treturn 0;\n}\n\nint __bnxt_hwrm_get_tx_rings(struct bnxt *bp, u16 fid, int *tx_rings)\n{\n\tstruct hwrm_func_qcfg_output *resp;\n\tstruct hwrm_func_qcfg_input *req;\n\tint rc;\n\n\tif (bp->hwrm_spec_code < 0x10601)\n\t\treturn 0;\n\n\trc = hwrm_req_init(bp, req, HWRM_FUNC_QCFG);\n\tif (rc)\n\t\treturn rc;\n\n\treq->fid = cpu_to_le16(fid);\n\tresp = hwrm_req_hold(bp, req);\n\trc = hwrm_req_send(bp, req);\n\tif (!rc)\n\t\t*tx_rings = le16_to_cpu(resp->alloc_tx_rings);\n\n\thwrm_req_drop(bp, req);\n\treturn rc;\n}\n\nstatic bool bnxt_rfs_supported(struct bnxt *bp);\n\nstatic struct hwrm_func_cfg_input *\n__bnxt_hwrm_reserve_pf_rings(struct bnxt *bp, int tx_rings, int rx_rings,\n\t\t\t     int ring_grps, int cp_rings, int stats, int vnics)\n{\n\tstruct hwrm_func_cfg_input *req;\n\tu32 enables = 0;\n\n\tif (hwrm_req_init(bp, req, HWRM_FUNC_CFG))\n\t\treturn NULL;\n\n\treq->fid = cpu_to_le16(0xffff);\n\tenables |= tx_rings ? FUNC_CFG_REQ_ENABLES_NUM_TX_RINGS : 0;\n\treq->num_tx_rings = cpu_to_le16(tx_rings);\n\tif (BNXT_NEW_RM(bp)) {\n\t\tenables |= rx_rings ? FUNC_CFG_REQ_ENABLES_NUM_RX_RINGS : 0;\n\t\tenables |= stats ? FUNC_CFG_REQ_ENABLES_NUM_STAT_CTXS : 0;\n\t\tif (bp->flags & BNXT_FLAG_CHIP_P5) {\n\t\t\tenables |= cp_rings ? FUNC_CFG_REQ_ENABLES_NUM_MSIX : 0;\n\t\t\tenables |= tx_rings + ring_grps ?\n\t\t\t\t   FUNC_CFG_REQ_ENABLES_NUM_CMPL_RINGS : 0;\n\t\t\tenables |= rx_rings ?\n\t\t\t\tFUNC_CFG_REQ_ENABLES_NUM_RSSCOS_CTXS : 0;\n\t\t} else {\n\t\t\tenables |= cp_rings ?\n\t\t\t\t   FUNC_CFG_REQ_ENABLES_NUM_CMPL_RINGS : 0;\n\t\t\tenables |= ring_grps ?\n\t\t\t\t   FUNC_CFG_REQ_ENABLES_NUM_HW_RING_GRPS |\n\t\t\t\t   FUNC_CFG_REQ_ENABLES_NUM_RSSCOS_CTXS : 0;\n\t\t}\n\t\tenables |= vnics ? FUNC_CFG_REQ_ENABLES_NUM_VNICS : 0;\n\n\t\treq->num_rx_rings = cpu_to_le16(rx_rings);\n\t\tif (bp->flags & BNXT_FLAG_CHIP_P5) {\n\t\t\treq->num_cmpl_rings = cpu_to_le16(tx_rings + ring_grps);\n\t\t\treq->num_msix = cpu_to_le16(cp_rings);\n\t\t\treq->num_rsscos_ctxs =\n\t\t\t\tcpu_to_le16(DIV_ROUND_UP(ring_grps, 64));\n\t\t} else {\n\t\t\treq->num_cmpl_rings = cpu_to_le16(cp_rings);\n\t\t\treq->num_hw_ring_grps = cpu_to_le16(ring_grps);\n\t\t\treq->num_rsscos_ctxs = cpu_to_le16(1);\n\t\t\tif (!(bp->flags & BNXT_FLAG_NEW_RSS_CAP) &&\n\t\t\t    bnxt_rfs_supported(bp))\n\t\t\t\treq->num_rsscos_ctxs =\n\t\t\t\t\tcpu_to_le16(ring_grps + 1);\n\t\t}\n\t\treq->num_stat_ctxs = cpu_to_le16(stats);\n\t\treq->num_vnics = cpu_to_le16(vnics);\n\t}\n\treq->enables = cpu_to_le32(enables);\n\treturn req;\n}\n\nstatic struct hwrm_func_vf_cfg_input *\n__bnxt_hwrm_reserve_vf_rings(struct bnxt *bp, int tx_rings, int rx_rings,\n\t\t\t     int ring_grps, int cp_rings, int stats, int vnics)\n{\n\tstruct hwrm_func_vf_cfg_input *req;\n\tu32 enables = 0;\n\n\tif (hwrm_req_init(bp, req, HWRM_FUNC_VF_CFG))\n\t\treturn NULL;\n\n\tenables |= tx_rings ? FUNC_VF_CFG_REQ_ENABLES_NUM_TX_RINGS : 0;\n\tenables |= rx_rings ? FUNC_VF_CFG_REQ_ENABLES_NUM_RX_RINGS |\n\t\t\t      FUNC_VF_CFG_REQ_ENABLES_NUM_RSSCOS_CTXS : 0;\n\tenables |= stats ? FUNC_VF_CFG_REQ_ENABLES_NUM_STAT_CTXS : 0;\n\tif (bp->flags & BNXT_FLAG_CHIP_P5) {\n\t\tenables |= tx_rings + ring_grps ?\n\t\t\t   FUNC_VF_CFG_REQ_ENABLES_NUM_CMPL_RINGS : 0;\n\t} else {\n\t\tenables |= cp_rings ?\n\t\t\t   FUNC_VF_CFG_REQ_ENABLES_NUM_CMPL_RINGS : 0;\n\t\tenables |= ring_grps ?\n\t\t\t   FUNC_VF_CFG_REQ_ENABLES_NUM_HW_RING_GRPS : 0;\n\t}\n\tenables |= vnics ? FUNC_VF_CFG_REQ_ENABLES_NUM_VNICS : 0;\n\tenables |= FUNC_VF_CFG_REQ_ENABLES_NUM_L2_CTXS;\n\n\treq->num_l2_ctxs = cpu_to_le16(BNXT_VF_MAX_L2_CTX);\n\treq->num_tx_rings = cpu_to_le16(tx_rings);\n\treq->num_rx_rings = cpu_to_le16(rx_rings);\n\tif (bp->flags & BNXT_FLAG_CHIP_P5) {\n\t\treq->num_cmpl_rings = cpu_to_le16(tx_rings + ring_grps);\n\t\treq->num_rsscos_ctxs = cpu_to_le16(DIV_ROUND_UP(ring_grps, 64));\n\t} else {\n\t\treq->num_cmpl_rings = cpu_to_le16(cp_rings);\n\t\treq->num_hw_ring_grps = cpu_to_le16(ring_grps);\n\t\treq->num_rsscos_ctxs = cpu_to_le16(BNXT_VF_MAX_RSS_CTX);\n\t}\n\treq->num_stat_ctxs = cpu_to_le16(stats);\n\treq->num_vnics = cpu_to_le16(vnics);\n\n\treq->enables = cpu_to_le32(enables);\n\treturn req;\n}\n\nstatic int\nbnxt_hwrm_reserve_pf_rings(struct bnxt *bp, int tx_rings, int rx_rings,\n\t\t\t   int ring_grps, int cp_rings, int stats, int vnics)\n{\n\tstruct hwrm_func_cfg_input *req;\n\tint rc;\n\n\treq = __bnxt_hwrm_reserve_pf_rings(bp, tx_rings, rx_rings, ring_grps,\n\t\t\t\t\t   cp_rings, stats, vnics);\n\tif (!req)\n\t\treturn -ENOMEM;\n\n\tif (!req->enables) {\n\t\thwrm_req_drop(bp, req);\n\t\treturn 0;\n\t}\n\n\trc = hwrm_req_send(bp, req);\n\tif (rc)\n\t\treturn rc;\n\n\tif (bp->hwrm_spec_code < 0x10601)\n\t\tbp->hw_resc.resv_tx_rings = tx_rings;\n\n\treturn bnxt_hwrm_get_rings(bp);\n}\n\nstatic int\nbnxt_hwrm_reserve_vf_rings(struct bnxt *bp, int tx_rings, int rx_rings,\n\t\t\t   int ring_grps, int cp_rings, int stats, int vnics)\n{\n\tstruct hwrm_func_vf_cfg_input *req;\n\tint rc;\n\n\tif (!BNXT_NEW_RM(bp)) {\n\t\tbp->hw_resc.resv_tx_rings = tx_rings;\n\t\treturn 0;\n\t}\n\n\treq = __bnxt_hwrm_reserve_vf_rings(bp, tx_rings, rx_rings, ring_grps,\n\t\t\t\t\t   cp_rings, stats, vnics);\n\tif (!req)\n\t\treturn -ENOMEM;\n\n\trc = hwrm_req_send(bp, req);\n\tif (rc)\n\t\treturn rc;\n\n\treturn bnxt_hwrm_get_rings(bp);\n}\n\nstatic int bnxt_hwrm_reserve_rings(struct bnxt *bp, int tx, int rx, int grp,\n\t\t\t\t   int cp, int stat, int vnic)\n{\n\tif (BNXT_PF(bp))\n\t\treturn bnxt_hwrm_reserve_pf_rings(bp, tx, rx, grp, cp, stat,\n\t\t\t\t\t\t  vnic);\n\telse\n\t\treturn bnxt_hwrm_reserve_vf_rings(bp, tx, rx, grp, cp, stat,\n\t\t\t\t\t\t  vnic);\n}\n\nint bnxt_nq_rings_in_use(struct bnxt *bp)\n{\n\tint cp = bp->cp_nr_rings;\n\tint ulp_msix, ulp_base;\n\n\tulp_msix = bnxt_get_ulp_msix_num(bp);\n\tif (ulp_msix) {\n\t\tulp_base = bnxt_get_ulp_msix_base(bp);\n\t\tcp += ulp_msix;\n\t\tif ((ulp_base + ulp_msix) > cp)\n\t\t\tcp = ulp_base + ulp_msix;\n\t}\n\treturn cp;\n}\n\nstatic int bnxt_cp_rings_in_use(struct bnxt *bp)\n{\n\tint cp;\n\n\tif (!(bp->flags & BNXT_FLAG_CHIP_P5))\n\t\treturn bnxt_nq_rings_in_use(bp);\n\n\tcp = bp->tx_nr_rings + bp->rx_nr_rings;\n\treturn cp;\n}\n\nstatic int bnxt_get_func_stat_ctxs(struct bnxt *bp)\n{\n\tint ulp_stat = bnxt_get_ulp_stat_ctxs(bp);\n\tint cp = bp->cp_nr_rings;\n\n\tif (!ulp_stat)\n\t\treturn cp;\n\n\tif (bnxt_nq_rings_in_use(bp) > cp + bnxt_get_ulp_msix_num(bp))\n\t\treturn bnxt_get_ulp_msix_base(bp) + ulp_stat;\n\n\treturn cp + ulp_stat;\n}\n\n \nstatic void bnxt_check_rss_tbl_no_rmgr(struct bnxt *bp)\n{\n\tstruct bnxt_hw_resc *hw_resc = &bp->hw_resc;\n\n\t \n\tif (hw_resc->resv_rx_rings != bp->rx_nr_rings) {\n\t\thw_resc->resv_rx_rings = bp->rx_nr_rings;\n\t\tif (!netif_is_rxfh_configured(bp->dev))\n\t\t\tbnxt_set_dflt_rss_indir_tbl(bp);\n\t}\n}\n\nstatic bool bnxt_need_reserve_rings(struct bnxt *bp)\n{\n\tstruct bnxt_hw_resc *hw_resc = &bp->hw_resc;\n\tint cp = bnxt_cp_rings_in_use(bp);\n\tint nq = bnxt_nq_rings_in_use(bp);\n\tint rx = bp->rx_nr_rings, stat;\n\tint vnic = 1, grp = rx;\n\n\tif (hw_resc->resv_tx_rings != bp->tx_nr_rings &&\n\t    bp->hwrm_spec_code >= 0x10601)\n\t\treturn true;\n\n\t \n\tif (!BNXT_NEW_RM(bp)) {\n\t\tbnxt_check_rss_tbl_no_rmgr(bp);\n\t\treturn false;\n\t}\n\tif ((bp->flags & BNXT_FLAG_RFS) && !(bp->flags & BNXT_FLAG_CHIP_P5))\n\t\tvnic = rx + 1;\n\tif (bp->flags & BNXT_FLAG_AGG_RINGS)\n\t\trx <<= 1;\n\tstat = bnxt_get_func_stat_ctxs(bp);\n\tif (hw_resc->resv_rx_rings != rx || hw_resc->resv_cp_rings != cp ||\n\t    hw_resc->resv_vnics != vnic || hw_resc->resv_stat_ctxs != stat ||\n\t    (hw_resc->resv_hw_ring_grps != grp &&\n\t     !(bp->flags & BNXT_FLAG_CHIP_P5)))\n\t\treturn true;\n\tif ((bp->flags & BNXT_FLAG_CHIP_P5) && BNXT_PF(bp) &&\n\t    hw_resc->resv_irqs != nq)\n\t\treturn true;\n\treturn false;\n}\n\nstatic int __bnxt_reserve_rings(struct bnxt *bp)\n{\n\tstruct bnxt_hw_resc *hw_resc = &bp->hw_resc;\n\tint cp = bnxt_nq_rings_in_use(bp);\n\tint tx = bp->tx_nr_rings;\n\tint rx = bp->rx_nr_rings;\n\tint grp, rx_rings, rc;\n\tint vnic = 1, stat;\n\tbool sh = false;\n\n\tif (!bnxt_need_reserve_rings(bp))\n\t\treturn 0;\n\n\tif (bp->flags & BNXT_FLAG_SHARED_RINGS)\n\t\tsh = true;\n\tif ((bp->flags & BNXT_FLAG_RFS) && !(bp->flags & BNXT_FLAG_CHIP_P5))\n\t\tvnic = rx + 1;\n\tif (bp->flags & BNXT_FLAG_AGG_RINGS)\n\t\trx <<= 1;\n\tgrp = bp->rx_nr_rings;\n\tstat = bnxt_get_func_stat_ctxs(bp);\n\n\trc = bnxt_hwrm_reserve_rings(bp, tx, rx, grp, cp, stat, vnic);\n\tif (rc)\n\t\treturn rc;\n\n\ttx = hw_resc->resv_tx_rings;\n\tif (BNXT_NEW_RM(bp)) {\n\t\trx = hw_resc->resv_rx_rings;\n\t\tcp = hw_resc->resv_irqs;\n\t\tgrp = hw_resc->resv_hw_ring_grps;\n\t\tvnic = hw_resc->resv_vnics;\n\t\tstat = hw_resc->resv_stat_ctxs;\n\t}\n\n\trx_rings = rx;\n\tif (bp->flags & BNXT_FLAG_AGG_RINGS) {\n\t\tif (rx >= 2) {\n\t\t\trx_rings = rx >> 1;\n\t\t} else {\n\t\t\tif (netif_running(bp->dev))\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tbp->flags &= ~BNXT_FLAG_AGG_RINGS;\n\t\t\tbp->flags |= BNXT_FLAG_NO_AGG_RINGS;\n\t\t\tbp->dev->hw_features &= ~NETIF_F_LRO;\n\t\t\tbp->dev->features &= ~NETIF_F_LRO;\n\t\t\tbnxt_set_ring_params(bp);\n\t\t}\n\t}\n\trx_rings = min_t(int, rx_rings, grp);\n\tcp = min_t(int, cp, bp->cp_nr_rings);\n\tif (stat > bnxt_get_ulp_stat_ctxs(bp))\n\t\tstat -= bnxt_get_ulp_stat_ctxs(bp);\n\tcp = min_t(int, cp, stat);\n\trc = bnxt_trim_rings(bp, &rx_rings, &tx, cp, sh);\n\tif (bp->flags & BNXT_FLAG_AGG_RINGS)\n\t\trx = rx_rings << 1;\n\tcp = sh ? max_t(int, tx, rx_rings) : tx + rx_rings;\n\tbp->tx_nr_rings = tx;\n\n\t \n\tif (rx_rings != bp->rx_nr_rings) {\n\t\tnetdev_warn(bp->dev, \"Able to reserve only %d out of %d requested RX rings\\n\",\n\t\t\t    rx_rings, bp->rx_nr_rings);\n\t\tif (netif_is_rxfh_configured(bp->dev) &&\n\t\t    (bnxt_get_nr_rss_ctxs(bp, bp->rx_nr_rings) !=\n\t\t     bnxt_get_nr_rss_ctxs(bp, rx_rings) ||\n\t\t     bnxt_get_max_rss_ring(bp) >= rx_rings)) {\n\t\t\tnetdev_warn(bp->dev, \"RSS table entries reverting to default\\n\");\n\t\t\tbp->dev->priv_flags &= ~IFF_RXFH_CONFIGURED;\n\t\t}\n\t}\n\tbp->rx_nr_rings = rx_rings;\n\tbp->cp_nr_rings = cp;\n\n\tif (!tx || !rx || !cp || !grp || !vnic || !stat)\n\t\treturn -ENOMEM;\n\n\tif (!netif_is_rxfh_configured(bp->dev))\n\t\tbnxt_set_dflt_rss_indir_tbl(bp);\n\n\treturn rc;\n}\n\nstatic int bnxt_hwrm_check_vf_rings(struct bnxt *bp, int tx_rings, int rx_rings,\n\t\t\t\t    int ring_grps, int cp_rings, int stats,\n\t\t\t\t    int vnics)\n{\n\tstruct hwrm_func_vf_cfg_input *req;\n\tu32 flags;\n\n\tif (!BNXT_NEW_RM(bp))\n\t\treturn 0;\n\n\treq = __bnxt_hwrm_reserve_vf_rings(bp, tx_rings, rx_rings, ring_grps,\n\t\t\t\t\t   cp_rings, stats, vnics);\n\tflags = FUNC_VF_CFG_REQ_FLAGS_TX_ASSETS_TEST |\n\t\tFUNC_VF_CFG_REQ_FLAGS_RX_ASSETS_TEST |\n\t\tFUNC_VF_CFG_REQ_FLAGS_CMPL_ASSETS_TEST |\n\t\tFUNC_VF_CFG_REQ_FLAGS_STAT_CTX_ASSETS_TEST |\n\t\tFUNC_VF_CFG_REQ_FLAGS_VNIC_ASSETS_TEST |\n\t\tFUNC_VF_CFG_REQ_FLAGS_RSSCOS_CTX_ASSETS_TEST;\n\tif (!(bp->flags & BNXT_FLAG_CHIP_P5))\n\t\tflags |= FUNC_VF_CFG_REQ_FLAGS_RING_GRP_ASSETS_TEST;\n\n\treq->flags = cpu_to_le32(flags);\n\treturn hwrm_req_send_silent(bp, req);\n}\n\nstatic int bnxt_hwrm_check_pf_rings(struct bnxt *bp, int tx_rings, int rx_rings,\n\t\t\t\t    int ring_grps, int cp_rings, int stats,\n\t\t\t\t    int vnics)\n{\n\tstruct hwrm_func_cfg_input *req;\n\tu32 flags;\n\n\treq = __bnxt_hwrm_reserve_pf_rings(bp, tx_rings, rx_rings, ring_grps,\n\t\t\t\t\t   cp_rings, stats, vnics);\n\tflags = FUNC_CFG_REQ_FLAGS_TX_ASSETS_TEST;\n\tif (BNXT_NEW_RM(bp)) {\n\t\tflags |= FUNC_CFG_REQ_FLAGS_RX_ASSETS_TEST |\n\t\t\t FUNC_CFG_REQ_FLAGS_CMPL_ASSETS_TEST |\n\t\t\t FUNC_CFG_REQ_FLAGS_STAT_CTX_ASSETS_TEST |\n\t\t\t FUNC_CFG_REQ_FLAGS_VNIC_ASSETS_TEST;\n\t\tif (bp->flags & BNXT_FLAG_CHIP_P5)\n\t\t\tflags |= FUNC_CFG_REQ_FLAGS_RSSCOS_CTX_ASSETS_TEST |\n\t\t\t\t FUNC_CFG_REQ_FLAGS_NQ_ASSETS_TEST;\n\t\telse\n\t\t\tflags |= FUNC_CFG_REQ_FLAGS_RING_GRP_ASSETS_TEST;\n\t}\n\n\treq->flags = cpu_to_le32(flags);\n\treturn hwrm_req_send_silent(bp, req);\n}\n\nstatic int bnxt_hwrm_check_rings(struct bnxt *bp, int tx_rings, int rx_rings,\n\t\t\t\t int ring_grps, int cp_rings, int stats,\n\t\t\t\t int vnics)\n{\n\tif (bp->hwrm_spec_code < 0x10801)\n\t\treturn 0;\n\n\tif (BNXT_PF(bp))\n\t\treturn bnxt_hwrm_check_pf_rings(bp, tx_rings, rx_rings,\n\t\t\t\t\t\tring_grps, cp_rings, stats,\n\t\t\t\t\t\tvnics);\n\n\treturn bnxt_hwrm_check_vf_rings(bp, tx_rings, rx_rings, ring_grps,\n\t\t\t\t\tcp_rings, stats, vnics);\n}\n\nstatic void bnxt_hwrm_coal_params_qcaps(struct bnxt *bp)\n{\n\tstruct bnxt_coal_cap *coal_cap = &bp->coal_cap;\n\tstruct hwrm_ring_aggint_qcaps_output *resp;\n\tstruct hwrm_ring_aggint_qcaps_input *req;\n\tint rc;\n\n\tcoal_cap->cmpl_params = BNXT_LEGACY_COAL_CMPL_PARAMS;\n\tcoal_cap->num_cmpl_dma_aggr_max = 63;\n\tcoal_cap->num_cmpl_dma_aggr_during_int_max = 63;\n\tcoal_cap->cmpl_aggr_dma_tmr_max = 65535;\n\tcoal_cap->cmpl_aggr_dma_tmr_during_int_max = 65535;\n\tcoal_cap->int_lat_tmr_min_max = 65535;\n\tcoal_cap->int_lat_tmr_max_max = 65535;\n\tcoal_cap->num_cmpl_aggr_int_max = 65535;\n\tcoal_cap->timer_units = 80;\n\n\tif (bp->hwrm_spec_code < 0x10902)\n\t\treturn;\n\n\tif (hwrm_req_init(bp, req, HWRM_RING_AGGINT_QCAPS))\n\t\treturn;\n\n\tresp = hwrm_req_hold(bp, req);\n\trc = hwrm_req_send_silent(bp, req);\n\tif (!rc) {\n\t\tcoal_cap->cmpl_params = le32_to_cpu(resp->cmpl_params);\n\t\tcoal_cap->nq_params = le32_to_cpu(resp->nq_params);\n\t\tcoal_cap->num_cmpl_dma_aggr_max =\n\t\t\tle16_to_cpu(resp->num_cmpl_dma_aggr_max);\n\t\tcoal_cap->num_cmpl_dma_aggr_during_int_max =\n\t\t\tle16_to_cpu(resp->num_cmpl_dma_aggr_during_int_max);\n\t\tcoal_cap->cmpl_aggr_dma_tmr_max =\n\t\t\tle16_to_cpu(resp->cmpl_aggr_dma_tmr_max);\n\t\tcoal_cap->cmpl_aggr_dma_tmr_during_int_max =\n\t\t\tle16_to_cpu(resp->cmpl_aggr_dma_tmr_during_int_max);\n\t\tcoal_cap->int_lat_tmr_min_max =\n\t\t\tle16_to_cpu(resp->int_lat_tmr_min_max);\n\t\tcoal_cap->int_lat_tmr_max_max =\n\t\t\tle16_to_cpu(resp->int_lat_tmr_max_max);\n\t\tcoal_cap->num_cmpl_aggr_int_max =\n\t\t\tle16_to_cpu(resp->num_cmpl_aggr_int_max);\n\t\tcoal_cap->timer_units = le16_to_cpu(resp->timer_units);\n\t}\n\thwrm_req_drop(bp, req);\n}\n\nstatic u16 bnxt_usec_to_coal_tmr(struct bnxt *bp, u16 usec)\n{\n\tstruct bnxt_coal_cap *coal_cap = &bp->coal_cap;\n\n\treturn usec * 1000 / coal_cap->timer_units;\n}\n\nstatic void bnxt_hwrm_set_coal_params(struct bnxt *bp,\n\tstruct bnxt_coal *hw_coal,\n\tstruct hwrm_ring_cmpl_ring_cfg_aggint_params_input *req)\n{\n\tstruct bnxt_coal_cap *coal_cap = &bp->coal_cap;\n\tu16 val, tmr, max, flags = hw_coal->flags;\n\tu32 cmpl_params = coal_cap->cmpl_params;\n\n\tmax = hw_coal->bufs_per_record * 128;\n\tif (hw_coal->budget)\n\t\tmax = hw_coal->bufs_per_record * hw_coal->budget;\n\tmax = min_t(u16, max, coal_cap->num_cmpl_aggr_int_max);\n\n\tval = clamp_t(u16, hw_coal->coal_bufs, 1, max);\n\treq->num_cmpl_aggr_int = cpu_to_le16(val);\n\n\tval = min_t(u16, val, coal_cap->num_cmpl_dma_aggr_max);\n\treq->num_cmpl_dma_aggr = cpu_to_le16(val);\n\n\tval = clamp_t(u16, hw_coal->coal_bufs_irq, 1,\n\t\t      coal_cap->num_cmpl_dma_aggr_during_int_max);\n\treq->num_cmpl_dma_aggr_during_int = cpu_to_le16(val);\n\n\ttmr = bnxt_usec_to_coal_tmr(bp, hw_coal->coal_ticks);\n\ttmr = clamp_t(u16, tmr, 1, coal_cap->int_lat_tmr_max_max);\n\treq->int_lat_tmr_max = cpu_to_le16(tmr);\n\n\t \n\tif (cmpl_params & RING_AGGINT_QCAPS_RESP_CMPL_PARAMS_INT_LAT_TMR_MIN) {\n\t\tval = tmr / 2;\n\t\tval = clamp_t(u16, val, 1, coal_cap->int_lat_tmr_min_max);\n\t\treq->int_lat_tmr_min = cpu_to_le16(val);\n\t\treq->enables |= cpu_to_le16(BNXT_COAL_CMPL_MIN_TMR_ENABLE);\n\t}\n\n\t \n\tval = clamp_t(u16, tmr / 4, 1, coal_cap->cmpl_aggr_dma_tmr_max);\n\treq->cmpl_aggr_dma_tmr = cpu_to_le16(val);\n\n\tif (cmpl_params &\n\t    RING_AGGINT_QCAPS_RESP_CMPL_PARAMS_NUM_CMPL_DMA_AGGR_DURING_INT) {\n\t\ttmr = bnxt_usec_to_coal_tmr(bp, hw_coal->coal_ticks_irq);\n\t\tval = clamp_t(u16, tmr, 1,\n\t\t\t      coal_cap->cmpl_aggr_dma_tmr_during_int_max);\n\t\treq->cmpl_aggr_dma_tmr_during_int = cpu_to_le16(val);\n\t\treq->enables |=\n\t\t\tcpu_to_le16(BNXT_COAL_CMPL_AGGR_TMR_DURING_INT_ENABLE);\n\t}\n\n\tif ((cmpl_params & RING_AGGINT_QCAPS_RESP_CMPL_PARAMS_RING_IDLE) &&\n\t    hw_coal->idle_thresh && hw_coal->coal_ticks < hw_coal->idle_thresh)\n\t\tflags |= RING_CMPL_RING_CFG_AGGINT_PARAMS_REQ_FLAGS_RING_IDLE;\n\treq->flags = cpu_to_le16(flags);\n\treq->enables |= cpu_to_le16(BNXT_COAL_CMPL_ENABLES);\n}\n\nstatic int __bnxt_hwrm_set_coal_nq(struct bnxt *bp, struct bnxt_napi *bnapi,\n\t\t\t\t   struct bnxt_coal *hw_coal)\n{\n\tstruct hwrm_ring_cmpl_ring_cfg_aggint_params_input *req;\n\tstruct bnxt_cp_ring_info *cpr = &bnapi->cp_ring;\n\tstruct bnxt_coal_cap *coal_cap = &bp->coal_cap;\n\tu32 nq_params = coal_cap->nq_params;\n\tu16 tmr;\n\tint rc;\n\n\tif (!(nq_params & RING_AGGINT_QCAPS_RESP_NQ_PARAMS_INT_LAT_TMR_MIN))\n\t\treturn 0;\n\n\trc = hwrm_req_init(bp, req, HWRM_RING_CMPL_RING_CFG_AGGINT_PARAMS);\n\tif (rc)\n\t\treturn rc;\n\n\treq->ring_id = cpu_to_le16(cpr->cp_ring_struct.fw_ring_id);\n\treq->flags =\n\t\tcpu_to_le16(RING_CMPL_RING_CFG_AGGINT_PARAMS_REQ_FLAGS_IS_NQ);\n\n\ttmr = bnxt_usec_to_coal_tmr(bp, hw_coal->coal_ticks) / 2;\n\ttmr = clamp_t(u16, tmr, 1, coal_cap->int_lat_tmr_min_max);\n\treq->int_lat_tmr_min = cpu_to_le16(tmr);\n\treq->enables |= cpu_to_le16(BNXT_COAL_CMPL_MIN_TMR_ENABLE);\n\treturn hwrm_req_send(bp, req);\n}\n\nint bnxt_hwrm_set_ring_coal(struct bnxt *bp, struct bnxt_napi *bnapi)\n{\n\tstruct hwrm_ring_cmpl_ring_cfg_aggint_params_input *req_rx;\n\tstruct bnxt_cp_ring_info *cpr = &bnapi->cp_ring;\n\tstruct bnxt_coal coal;\n\tint rc;\n\n\t \n\tmemcpy(&coal, &bp->rx_coal, sizeof(struct bnxt_coal));\n\n\tcoal.coal_ticks = cpr->rx_ring_coal.coal_ticks;\n\tcoal.coal_bufs = cpr->rx_ring_coal.coal_bufs;\n\n\tif (!bnapi->rx_ring)\n\t\treturn -ENODEV;\n\n\trc = hwrm_req_init(bp, req_rx, HWRM_RING_CMPL_RING_CFG_AGGINT_PARAMS);\n\tif (rc)\n\t\treturn rc;\n\n\tbnxt_hwrm_set_coal_params(bp, &coal, req_rx);\n\n\treq_rx->ring_id = cpu_to_le16(bnxt_cp_ring_for_rx(bp, bnapi->rx_ring));\n\n\treturn hwrm_req_send(bp, req_rx);\n}\n\nint bnxt_hwrm_set_coal(struct bnxt *bp)\n{\n\tstruct hwrm_ring_cmpl_ring_cfg_aggint_params_input *req_rx, *req_tx,\n\t\t\t\t\t\t\t   *req;\n\tint i, rc;\n\n\trc = hwrm_req_init(bp, req_rx, HWRM_RING_CMPL_RING_CFG_AGGINT_PARAMS);\n\tif (rc)\n\t\treturn rc;\n\n\trc = hwrm_req_init(bp, req_tx, HWRM_RING_CMPL_RING_CFG_AGGINT_PARAMS);\n\tif (rc) {\n\t\thwrm_req_drop(bp, req_rx);\n\t\treturn rc;\n\t}\n\n\tbnxt_hwrm_set_coal_params(bp, &bp->rx_coal, req_rx);\n\tbnxt_hwrm_set_coal_params(bp, &bp->tx_coal, req_tx);\n\n\thwrm_req_hold(bp, req_rx);\n\thwrm_req_hold(bp, req_tx);\n\tfor (i = 0; i < bp->cp_nr_rings; i++) {\n\t\tstruct bnxt_napi *bnapi = bp->bnapi[i];\n\t\tstruct bnxt_coal *hw_coal;\n\t\tu16 ring_id;\n\n\t\treq = req_rx;\n\t\tif (!bnapi->rx_ring) {\n\t\t\tring_id = bnxt_cp_ring_for_tx(bp, bnapi->tx_ring);\n\t\t\treq = req_tx;\n\t\t} else {\n\t\t\tring_id = bnxt_cp_ring_for_rx(bp, bnapi->rx_ring);\n\t\t}\n\t\treq->ring_id = cpu_to_le16(ring_id);\n\n\t\trc = hwrm_req_send(bp, req);\n\t\tif (rc)\n\t\t\tbreak;\n\n\t\tif (!(bp->flags & BNXT_FLAG_CHIP_P5))\n\t\t\tcontinue;\n\n\t\tif (bnapi->rx_ring && bnapi->tx_ring) {\n\t\t\treq = req_tx;\n\t\t\tring_id = bnxt_cp_ring_for_tx(bp, bnapi->tx_ring);\n\t\t\treq->ring_id = cpu_to_le16(ring_id);\n\t\t\trc = hwrm_req_send(bp, req);\n\t\t\tif (rc)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (bnapi->rx_ring)\n\t\t\thw_coal = &bp->rx_coal;\n\t\telse\n\t\t\thw_coal = &bp->tx_coal;\n\t\t__bnxt_hwrm_set_coal_nq(bp, bnapi, hw_coal);\n\t}\n\thwrm_req_drop(bp, req_rx);\n\thwrm_req_drop(bp, req_tx);\n\treturn rc;\n}\n\nstatic void bnxt_hwrm_stat_ctx_free(struct bnxt *bp)\n{\n\tstruct hwrm_stat_ctx_clr_stats_input *req0 = NULL;\n\tstruct hwrm_stat_ctx_free_input *req;\n\tint i;\n\n\tif (!bp->bnapi)\n\t\treturn;\n\n\tif (BNXT_CHIP_TYPE_NITRO_A0(bp))\n\t\treturn;\n\n\tif (hwrm_req_init(bp, req, HWRM_STAT_CTX_FREE))\n\t\treturn;\n\tif (BNXT_FW_MAJ(bp) <= 20) {\n\t\tif (hwrm_req_init(bp, req0, HWRM_STAT_CTX_CLR_STATS)) {\n\t\t\thwrm_req_drop(bp, req);\n\t\t\treturn;\n\t\t}\n\t\thwrm_req_hold(bp, req0);\n\t}\n\thwrm_req_hold(bp, req);\n\tfor (i = 0; i < bp->cp_nr_rings; i++) {\n\t\tstruct bnxt_napi *bnapi = bp->bnapi[i];\n\t\tstruct bnxt_cp_ring_info *cpr = &bnapi->cp_ring;\n\n\t\tif (cpr->hw_stats_ctx_id != INVALID_STATS_CTX_ID) {\n\t\t\treq->stat_ctx_id = cpu_to_le32(cpr->hw_stats_ctx_id);\n\t\t\tif (req0) {\n\t\t\t\treq0->stat_ctx_id = req->stat_ctx_id;\n\t\t\t\thwrm_req_send(bp, req0);\n\t\t\t}\n\t\t\thwrm_req_send(bp, req);\n\n\t\t\tcpr->hw_stats_ctx_id = INVALID_STATS_CTX_ID;\n\t\t}\n\t}\n\thwrm_req_drop(bp, req);\n\tif (req0)\n\t\thwrm_req_drop(bp, req0);\n}\n\nstatic int bnxt_hwrm_stat_ctx_alloc(struct bnxt *bp)\n{\n\tstruct hwrm_stat_ctx_alloc_output *resp;\n\tstruct hwrm_stat_ctx_alloc_input *req;\n\tint rc, i;\n\n\tif (BNXT_CHIP_TYPE_NITRO_A0(bp))\n\t\treturn 0;\n\n\trc = hwrm_req_init(bp, req, HWRM_STAT_CTX_ALLOC);\n\tif (rc)\n\t\treturn rc;\n\n\treq->stats_dma_length = cpu_to_le16(bp->hw_ring_stats_size);\n\treq->update_period_ms = cpu_to_le32(bp->stats_coal_ticks / 1000);\n\n\tresp = hwrm_req_hold(bp, req);\n\tfor (i = 0; i < bp->cp_nr_rings; i++) {\n\t\tstruct bnxt_napi *bnapi = bp->bnapi[i];\n\t\tstruct bnxt_cp_ring_info *cpr = &bnapi->cp_ring;\n\n\t\treq->stats_dma_addr = cpu_to_le64(cpr->stats.hw_stats_map);\n\n\t\trc = hwrm_req_send(bp, req);\n\t\tif (rc)\n\t\t\tbreak;\n\n\t\tcpr->hw_stats_ctx_id = le32_to_cpu(resp->stat_ctx_id);\n\n\t\tbp->grp_info[i].fw_stats_ctx = cpr->hw_stats_ctx_id;\n\t}\n\thwrm_req_drop(bp, req);\n\treturn rc;\n}\n\nstatic int bnxt_hwrm_func_qcfg(struct bnxt *bp)\n{\n\tstruct hwrm_func_qcfg_output *resp;\n\tstruct hwrm_func_qcfg_input *req;\n\tu32 min_db_offset = 0;\n\tu16 flags;\n\tint rc;\n\n\trc = hwrm_req_init(bp, req, HWRM_FUNC_QCFG);\n\tif (rc)\n\t\treturn rc;\n\n\treq->fid = cpu_to_le16(0xffff);\n\tresp = hwrm_req_hold(bp, req);\n\trc = hwrm_req_send(bp, req);\n\tif (rc)\n\t\tgoto func_qcfg_exit;\n\n#ifdef CONFIG_BNXT_SRIOV\n\tif (BNXT_VF(bp)) {\n\t\tstruct bnxt_vf_info *vf = &bp->vf;\n\n\t\tvf->vlan = le16_to_cpu(resp->vlan) & VLAN_VID_MASK;\n\t} else {\n\t\tbp->pf.registered_vfs = le16_to_cpu(resp->registered_vfs);\n\t}\n#endif\n\tflags = le16_to_cpu(resp->flags);\n\tif (flags & (FUNC_QCFG_RESP_FLAGS_FW_DCBX_AGENT_ENABLED |\n\t\t     FUNC_QCFG_RESP_FLAGS_FW_LLDP_AGENT_ENABLED)) {\n\t\tbp->fw_cap |= BNXT_FW_CAP_LLDP_AGENT;\n\t\tif (flags & FUNC_QCFG_RESP_FLAGS_FW_DCBX_AGENT_ENABLED)\n\t\t\tbp->fw_cap |= BNXT_FW_CAP_DCBX_AGENT;\n\t}\n\tif (BNXT_PF(bp) && (flags & FUNC_QCFG_RESP_FLAGS_MULTI_HOST))\n\t\tbp->flags |= BNXT_FLAG_MULTI_HOST;\n\n\tif (flags & FUNC_QCFG_RESP_FLAGS_RING_MONITOR_ENABLED)\n\t\tbp->fw_cap |= BNXT_FW_CAP_RING_MONITOR;\n\n\tswitch (resp->port_partition_type) {\n\tcase FUNC_QCFG_RESP_PORT_PARTITION_TYPE_NPAR1_0:\n\tcase FUNC_QCFG_RESP_PORT_PARTITION_TYPE_NPAR1_5:\n\tcase FUNC_QCFG_RESP_PORT_PARTITION_TYPE_NPAR2_0:\n\t\tbp->port_partition_type = resp->port_partition_type;\n\t\tbreak;\n\t}\n\tif (bp->hwrm_spec_code < 0x10707 ||\n\t    resp->evb_mode == FUNC_QCFG_RESP_EVB_MODE_VEB)\n\t\tbp->br_mode = BRIDGE_MODE_VEB;\n\telse if (resp->evb_mode == FUNC_QCFG_RESP_EVB_MODE_VEPA)\n\t\tbp->br_mode = BRIDGE_MODE_VEPA;\n\telse\n\t\tbp->br_mode = BRIDGE_MODE_UNDEF;\n\n\tbp->max_mtu = le16_to_cpu(resp->max_mtu_configured);\n\tif (!bp->max_mtu)\n\t\tbp->max_mtu = BNXT_MAX_MTU;\n\n\tif (bp->db_size)\n\t\tgoto func_qcfg_exit;\n\n\tif (bp->flags & BNXT_FLAG_CHIP_P5) {\n\t\tif (BNXT_PF(bp))\n\t\t\tmin_db_offset = DB_PF_OFFSET_P5;\n\t\telse\n\t\t\tmin_db_offset = DB_VF_OFFSET_P5;\n\t}\n\tbp->db_size = PAGE_ALIGN(le16_to_cpu(resp->l2_doorbell_bar_size_kb) *\n\t\t\t\t 1024);\n\tif (!bp->db_size || bp->db_size > pci_resource_len(bp->pdev, 2) ||\n\t    bp->db_size <= min_db_offset)\n\t\tbp->db_size = pci_resource_len(bp->pdev, 2);\n\nfunc_qcfg_exit:\n\thwrm_req_drop(bp, req);\n\treturn rc;\n}\n\nstatic void bnxt_init_ctx_initializer(struct bnxt_ctx_mem_info *ctx,\n\t\t\tstruct hwrm_func_backing_store_qcaps_output *resp)\n{\n\tstruct bnxt_mem_init *mem_init;\n\tu16 init_mask;\n\tu8 init_val;\n\tu8 *offset;\n\tint i;\n\n\tinit_val = resp->ctx_kind_initializer;\n\tinit_mask = le16_to_cpu(resp->ctx_init_mask);\n\toffset = &resp->qp_init_offset;\n\tmem_init = &ctx->mem_init[BNXT_CTX_MEM_INIT_QP];\n\tfor (i = 0; i < BNXT_CTX_MEM_INIT_MAX; i++, mem_init++, offset++) {\n\t\tmem_init->init_val = init_val;\n\t\tmem_init->offset = BNXT_MEM_INVALID_OFFSET;\n\t\tif (!init_mask)\n\t\t\tcontinue;\n\t\tif (i == BNXT_CTX_MEM_INIT_STAT)\n\t\t\toffset = &resp->stat_init_offset;\n\t\tif (init_mask & (1 << i))\n\t\t\tmem_init->offset = *offset * 4;\n\t\telse\n\t\t\tmem_init->init_val = 0;\n\t}\n\tctx->mem_init[BNXT_CTX_MEM_INIT_QP].size = ctx->qp_entry_size;\n\tctx->mem_init[BNXT_CTX_MEM_INIT_SRQ].size = ctx->srq_entry_size;\n\tctx->mem_init[BNXT_CTX_MEM_INIT_CQ].size = ctx->cq_entry_size;\n\tctx->mem_init[BNXT_CTX_MEM_INIT_VNIC].size = ctx->vnic_entry_size;\n\tctx->mem_init[BNXT_CTX_MEM_INIT_STAT].size = ctx->stat_entry_size;\n\tctx->mem_init[BNXT_CTX_MEM_INIT_MRAV].size = ctx->mrav_entry_size;\n}\n\nstatic int bnxt_hwrm_func_backing_store_qcaps(struct bnxt *bp)\n{\n\tstruct hwrm_func_backing_store_qcaps_output *resp;\n\tstruct hwrm_func_backing_store_qcaps_input *req;\n\tint rc;\n\n\tif (bp->hwrm_spec_code < 0x10902 || BNXT_VF(bp) || bp->ctx)\n\t\treturn 0;\n\n\trc = hwrm_req_init(bp, req, HWRM_FUNC_BACKING_STORE_QCAPS);\n\tif (rc)\n\t\treturn rc;\n\n\tresp = hwrm_req_hold(bp, req);\n\trc = hwrm_req_send_silent(bp, req);\n\tif (!rc) {\n\t\tstruct bnxt_ctx_pg_info *ctx_pg;\n\t\tstruct bnxt_ctx_mem_info *ctx;\n\t\tint i, tqm_rings;\n\n\t\tctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\n\t\tif (!ctx) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto ctx_err;\n\t\t}\n\t\tctx->qp_max_entries = le32_to_cpu(resp->qp_max_entries);\n\t\tctx->qp_min_qp1_entries = le16_to_cpu(resp->qp_min_qp1_entries);\n\t\tctx->qp_max_l2_entries = le16_to_cpu(resp->qp_max_l2_entries);\n\t\tctx->qp_entry_size = le16_to_cpu(resp->qp_entry_size);\n\t\tctx->srq_max_l2_entries = le16_to_cpu(resp->srq_max_l2_entries);\n\t\tctx->srq_max_entries = le32_to_cpu(resp->srq_max_entries);\n\t\tctx->srq_entry_size = le16_to_cpu(resp->srq_entry_size);\n\t\tctx->cq_max_l2_entries = le16_to_cpu(resp->cq_max_l2_entries);\n\t\tctx->cq_max_entries = le32_to_cpu(resp->cq_max_entries);\n\t\tctx->cq_entry_size = le16_to_cpu(resp->cq_entry_size);\n\t\tctx->vnic_max_vnic_entries =\n\t\t\tle16_to_cpu(resp->vnic_max_vnic_entries);\n\t\tctx->vnic_max_ring_table_entries =\n\t\t\tle16_to_cpu(resp->vnic_max_ring_table_entries);\n\t\tctx->vnic_entry_size = le16_to_cpu(resp->vnic_entry_size);\n\t\tctx->stat_max_entries = le32_to_cpu(resp->stat_max_entries);\n\t\tctx->stat_entry_size = le16_to_cpu(resp->stat_entry_size);\n\t\tctx->tqm_entry_size = le16_to_cpu(resp->tqm_entry_size);\n\t\tctx->tqm_min_entries_per_ring =\n\t\t\tle32_to_cpu(resp->tqm_min_entries_per_ring);\n\t\tctx->tqm_max_entries_per_ring =\n\t\t\tle32_to_cpu(resp->tqm_max_entries_per_ring);\n\t\tctx->tqm_entries_multiple = resp->tqm_entries_multiple;\n\t\tif (!ctx->tqm_entries_multiple)\n\t\t\tctx->tqm_entries_multiple = 1;\n\t\tctx->mrav_max_entries = le32_to_cpu(resp->mrav_max_entries);\n\t\tctx->mrav_entry_size = le16_to_cpu(resp->mrav_entry_size);\n\t\tctx->mrav_num_entries_units =\n\t\t\tle16_to_cpu(resp->mrav_num_entries_units);\n\t\tctx->tim_entry_size = le16_to_cpu(resp->tim_entry_size);\n\t\tctx->tim_max_entries = le32_to_cpu(resp->tim_max_entries);\n\n\t\tbnxt_init_ctx_initializer(ctx, resp);\n\n\t\tctx->tqm_fp_rings_count = resp->tqm_fp_rings_count;\n\t\tif (!ctx->tqm_fp_rings_count)\n\t\t\tctx->tqm_fp_rings_count = bp->max_q;\n\t\telse if (ctx->tqm_fp_rings_count > BNXT_MAX_TQM_FP_RINGS)\n\t\t\tctx->tqm_fp_rings_count = BNXT_MAX_TQM_FP_RINGS;\n\n\t\ttqm_rings = ctx->tqm_fp_rings_count + BNXT_MAX_TQM_SP_RINGS;\n\t\tctx_pg = kcalloc(tqm_rings, sizeof(*ctx_pg), GFP_KERNEL);\n\t\tif (!ctx_pg) {\n\t\t\tkfree(ctx);\n\t\t\trc = -ENOMEM;\n\t\t\tgoto ctx_err;\n\t\t}\n\t\tfor (i = 0; i < tqm_rings; i++, ctx_pg++)\n\t\t\tctx->tqm_mem[i] = ctx_pg;\n\t\tbp->ctx = ctx;\n\t} else {\n\t\trc = 0;\n\t}\nctx_err:\n\thwrm_req_drop(bp, req);\n\treturn rc;\n}\n\nstatic void bnxt_hwrm_set_pg_attr(struct bnxt_ring_mem_info *rmem, u8 *pg_attr,\n\t\t\t\t  __le64 *pg_dir)\n{\n\tif (!rmem->nr_pages)\n\t\treturn;\n\n\tBNXT_SET_CTX_PAGE_ATTR(*pg_attr);\n\tif (rmem->depth >= 1) {\n\t\tif (rmem->depth == 2)\n\t\t\t*pg_attr |= 2;\n\t\telse\n\t\t\t*pg_attr |= 1;\n\t\t*pg_dir = cpu_to_le64(rmem->pg_tbl_map);\n\t} else {\n\t\t*pg_dir = cpu_to_le64(rmem->dma_arr[0]);\n\t}\n}\n\n#define FUNC_BACKING_STORE_CFG_REQ_DFLT_ENABLES\t\t\t\\\n\t(FUNC_BACKING_STORE_CFG_REQ_ENABLES_QP |\t\t\\\n\t FUNC_BACKING_STORE_CFG_REQ_ENABLES_SRQ |\t\t\\\n\t FUNC_BACKING_STORE_CFG_REQ_ENABLES_CQ |\t\t\\\n\t FUNC_BACKING_STORE_CFG_REQ_ENABLES_VNIC |\t\t\\\n\t FUNC_BACKING_STORE_CFG_REQ_ENABLES_STAT)\n\nstatic int bnxt_hwrm_func_backing_store_cfg(struct bnxt *bp, u32 enables)\n{\n\tstruct hwrm_func_backing_store_cfg_input *req;\n\tstruct bnxt_ctx_mem_info *ctx = bp->ctx;\n\tstruct bnxt_ctx_pg_info *ctx_pg;\n\tvoid **__req = (void **)&req;\n\tu32 req_len = sizeof(*req);\n\t__le32 *num_entries;\n\t__le64 *pg_dir;\n\tu32 flags = 0;\n\tu8 *pg_attr;\n\tu32 ena;\n\tint rc;\n\tint i;\n\n\tif (!ctx)\n\t\treturn 0;\n\n\tif (req_len > bp->hwrm_max_ext_req_len)\n\t\treq_len = BNXT_BACKING_STORE_CFG_LEGACY_LEN;\n\trc = __hwrm_req_init(bp, __req, HWRM_FUNC_BACKING_STORE_CFG, req_len);\n\tif (rc)\n\t\treturn rc;\n\n\treq->enables = cpu_to_le32(enables);\n\tif (enables & FUNC_BACKING_STORE_CFG_REQ_ENABLES_QP) {\n\t\tctx_pg = &ctx->qp_mem;\n\t\treq->qp_num_entries = cpu_to_le32(ctx_pg->entries);\n\t\treq->qp_num_qp1_entries = cpu_to_le16(ctx->qp_min_qp1_entries);\n\t\treq->qp_num_l2_entries = cpu_to_le16(ctx->qp_max_l2_entries);\n\t\treq->qp_entry_size = cpu_to_le16(ctx->qp_entry_size);\n\t\tbnxt_hwrm_set_pg_attr(&ctx_pg->ring_mem,\n\t\t\t\t      &req->qpc_pg_size_qpc_lvl,\n\t\t\t\t      &req->qpc_page_dir);\n\t}\n\tif (enables & FUNC_BACKING_STORE_CFG_REQ_ENABLES_SRQ) {\n\t\tctx_pg = &ctx->srq_mem;\n\t\treq->srq_num_entries = cpu_to_le32(ctx_pg->entries);\n\t\treq->srq_num_l2_entries = cpu_to_le16(ctx->srq_max_l2_entries);\n\t\treq->srq_entry_size = cpu_to_le16(ctx->srq_entry_size);\n\t\tbnxt_hwrm_set_pg_attr(&ctx_pg->ring_mem,\n\t\t\t\t      &req->srq_pg_size_srq_lvl,\n\t\t\t\t      &req->srq_page_dir);\n\t}\n\tif (enables & FUNC_BACKING_STORE_CFG_REQ_ENABLES_CQ) {\n\t\tctx_pg = &ctx->cq_mem;\n\t\treq->cq_num_entries = cpu_to_le32(ctx_pg->entries);\n\t\treq->cq_num_l2_entries = cpu_to_le16(ctx->cq_max_l2_entries);\n\t\treq->cq_entry_size = cpu_to_le16(ctx->cq_entry_size);\n\t\tbnxt_hwrm_set_pg_attr(&ctx_pg->ring_mem,\n\t\t\t\t      &req->cq_pg_size_cq_lvl,\n\t\t\t\t      &req->cq_page_dir);\n\t}\n\tif (enables & FUNC_BACKING_STORE_CFG_REQ_ENABLES_VNIC) {\n\t\tctx_pg = &ctx->vnic_mem;\n\t\treq->vnic_num_vnic_entries =\n\t\t\tcpu_to_le16(ctx->vnic_max_vnic_entries);\n\t\treq->vnic_num_ring_table_entries =\n\t\t\tcpu_to_le16(ctx->vnic_max_ring_table_entries);\n\t\treq->vnic_entry_size = cpu_to_le16(ctx->vnic_entry_size);\n\t\tbnxt_hwrm_set_pg_attr(&ctx_pg->ring_mem,\n\t\t\t\t      &req->vnic_pg_size_vnic_lvl,\n\t\t\t\t      &req->vnic_page_dir);\n\t}\n\tif (enables & FUNC_BACKING_STORE_CFG_REQ_ENABLES_STAT) {\n\t\tctx_pg = &ctx->stat_mem;\n\t\treq->stat_num_entries = cpu_to_le32(ctx->stat_max_entries);\n\t\treq->stat_entry_size = cpu_to_le16(ctx->stat_entry_size);\n\t\tbnxt_hwrm_set_pg_attr(&ctx_pg->ring_mem,\n\t\t\t\t      &req->stat_pg_size_stat_lvl,\n\t\t\t\t      &req->stat_page_dir);\n\t}\n\tif (enables & FUNC_BACKING_STORE_CFG_REQ_ENABLES_MRAV) {\n\t\tctx_pg = &ctx->mrav_mem;\n\t\treq->mrav_num_entries = cpu_to_le32(ctx_pg->entries);\n\t\tif (ctx->mrav_num_entries_units)\n\t\t\tflags |=\n\t\t\tFUNC_BACKING_STORE_CFG_REQ_FLAGS_MRAV_RESERVATION_SPLIT;\n\t\treq->mrav_entry_size = cpu_to_le16(ctx->mrav_entry_size);\n\t\tbnxt_hwrm_set_pg_attr(&ctx_pg->ring_mem,\n\t\t\t\t      &req->mrav_pg_size_mrav_lvl,\n\t\t\t\t      &req->mrav_page_dir);\n\t}\n\tif (enables & FUNC_BACKING_STORE_CFG_REQ_ENABLES_TIM) {\n\t\tctx_pg = &ctx->tim_mem;\n\t\treq->tim_num_entries = cpu_to_le32(ctx_pg->entries);\n\t\treq->tim_entry_size = cpu_to_le16(ctx->tim_entry_size);\n\t\tbnxt_hwrm_set_pg_attr(&ctx_pg->ring_mem,\n\t\t\t\t      &req->tim_pg_size_tim_lvl,\n\t\t\t\t      &req->tim_page_dir);\n\t}\n\tfor (i = 0, num_entries = &req->tqm_sp_num_entries,\n\t     pg_attr = &req->tqm_sp_pg_size_tqm_sp_lvl,\n\t     pg_dir = &req->tqm_sp_page_dir,\n\t     ena = FUNC_BACKING_STORE_CFG_REQ_ENABLES_TQM_SP;\n\t     i < BNXT_MAX_TQM_RINGS;\n\t     i++, num_entries++, pg_attr++, pg_dir++, ena <<= 1) {\n\t\tif (!(enables & ena))\n\t\t\tcontinue;\n\n\t\treq->tqm_entry_size = cpu_to_le16(ctx->tqm_entry_size);\n\t\tctx_pg = ctx->tqm_mem[i];\n\t\t*num_entries = cpu_to_le32(ctx_pg->entries);\n\t\tbnxt_hwrm_set_pg_attr(&ctx_pg->ring_mem, pg_attr, pg_dir);\n\t}\n\treq->flags = cpu_to_le32(flags);\n\treturn hwrm_req_send(bp, req);\n}\n\nstatic int bnxt_alloc_ctx_mem_blk(struct bnxt *bp,\n\t\t\t\t  struct bnxt_ctx_pg_info *ctx_pg)\n{\n\tstruct bnxt_ring_mem_info *rmem = &ctx_pg->ring_mem;\n\n\trmem->page_size = BNXT_PAGE_SIZE;\n\trmem->pg_arr = ctx_pg->ctx_pg_arr;\n\trmem->dma_arr = ctx_pg->ctx_dma_arr;\n\trmem->flags = BNXT_RMEM_VALID_PTE_FLAG;\n\tif (rmem->depth >= 1)\n\t\trmem->flags |= BNXT_RMEM_USE_FULL_PAGE_FLAG;\n\treturn bnxt_alloc_ring(bp, rmem);\n}\n\nstatic int bnxt_alloc_ctx_pg_tbls(struct bnxt *bp,\n\t\t\t\t  struct bnxt_ctx_pg_info *ctx_pg, u32 mem_size,\n\t\t\t\t  u8 depth, struct bnxt_mem_init *mem_init)\n{\n\tstruct bnxt_ring_mem_info *rmem = &ctx_pg->ring_mem;\n\tint rc;\n\n\tif (!mem_size)\n\t\treturn -EINVAL;\n\n\tctx_pg->nr_pages = DIV_ROUND_UP(mem_size, BNXT_PAGE_SIZE);\n\tif (ctx_pg->nr_pages > MAX_CTX_TOTAL_PAGES) {\n\t\tctx_pg->nr_pages = 0;\n\t\treturn -EINVAL;\n\t}\n\tif (ctx_pg->nr_pages > MAX_CTX_PAGES || depth > 1) {\n\t\tint nr_tbls, i;\n\n\t\trmem->depth = 2;\n\t\tctx_pg->ctx_pg_tbl = kcalloc(MAX_CTX_PAGES, sizeof(ctx_pg),\n\t\t\t\t\t     GFP_KERNEL);\n\t\tif (!ctx_pg->ctx_pg_tbl)\n\t\t\treturn -ENOMEM;\n\t\tnr_tbls = DIV_ROUND_UP(ctx_pg->nr_pages, MAX_CTX_PAGES);\n\t\trmem->nr_pages = nr_tbls;\n\t\trc = bnxt_alloc_ctx_mem_blk(bp, ctx_pg);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tfor (i = 0; i < nr_tbls; i++) {\n\t\t\tstruct bnxt_ctx_pg_info *pg_tbl;\n\n\t\t\tpg_tbl = kzalloc(sizeof(*pg_tbl), GFP_KERNEL);\n\t\t\tif (!pg_tbl)\n\t\t\t\treturn -ENOMEM;\n\t\t\tctx_pg->ctx_pg_tbl[i] = pg_tbl;\n\t\t\trmem = &pg_tbl->ring_mem;\n\t\t\trmem->pg_tbl = ctx_pg->ctx_pg_arr[i];\n\t\t\trmem->pg_tbl_map = ctx_pg->ctx_dma_arr[i];\n\t\t\trmem->depth = 1;\n\t\t\trmem->nr_pages = MAX_CTX_PAGES;\n\t\t\trmem->mem_init = mem_init;\n\t\t\tif (i == (nr_tbls - 1)) {\n\t\t\t\tint rem = ctx_pg->nr_pages % MAX_CTX_PAGES;\n\n\t\t\t\tif (rem)\n\t\t\t\t\trmem->nr_pages = rem;\n\t\t\t}\n\t\t\trc = bnxt_alloc_ctx_mem_blk(bp, pg_tbl);\n\t\t\tif (rc)\n\t\t\t\tbreak;\n\t\t}\n\t} else {\n\t\trmem->nr_pages = DIV_ROUND_UP(mem_size, BNXT_PAGE_SIZE);\n\t\tif (rmem->nr_pages > 1 || depth)\n\t\t\trmem->depth = 1;\n\t\trmem->mem_init = mem_init;\n\t\trc = bnxt_alloc_ctx_mem_blk(bp, ctx_pg);\n\t}\n\treturn rc;\n}\n\nstatic void bnxt_free_ctx_pg_tbls(struct bnxt *bp,\n\t\t\t\t  struct bnxt_ctx_pg_info *ctx_pg)\n{\n\tstruct bnxt_ring_mem_info *rmem = &ctx_pg->ring_mem;\n\n\tif (rmem->depth > 1 || ctx_pg->nr_pages > MAX_CTX_PAGES ||\n\t    ctx_pg->ctx_pg_tbl) {\n\t\tint i, nr_tbls = rmem->nr_pages;\n\n\t\tfor (i = 0; i < nr_tbls; i++) {\n\t\t\tstruct bnxt_ctx_pg_info *pg_tbl;\n\t\t\tstruct bnxt_ring_mem_info *rmem2;\n\n\t\t\tpg_tbl = ctx_pg->ctx_pg_tbl[i];\n\t\t\tif (!pg_tbl)\n\t\t\t\tcontinue;\n\t\t\trmem2 = &pg_tbl->ring_mem;\n\t\t\tbnxt_free_ring(bp, rmem2);\n\t\t\tctx_pg->ctx_pg_arr[i] = NULL;\n\t\t\tkfree(pg_tbl);\n\t\t\tctx_pg->ctx_pg_tbl[i] = NULL;\n\t\t}\n\t\tkfree(ctx_pg->ctx_pg_tbl);\n\t\tctx_pg->ctx_pg_tbl = NULL;\n\t}\n\tbnxt_free_ring(bp, rmem);\n\tctx_pg->nr_pages = 0;\n}\n\nvoid bnxt_free_ctx_mem(struct bnxt *bp)\n{\n\tstruct bnxt_ctx_mem_info *ctx = bp->ctx;\n\tint i;\n\n\tif (!ctx)\n\t\treturn;\n\n\tif (ctx->tqm_mem[0]) {\n\t\tfor (i = 0; i < ctx->tqm_fp_rings_count + 1; i++)\n\t\t\tbnxt_free_ctx_pg_tbls(bp, ctx->tqm_mem[i]);\n\t\tkfree(ctx->tqm_mem[0]);\n\t\tctx->tqm_mem[0] = NULL;\n\t}\n\n\tbnxt_free_ctx_pg_tbls(bp, &ctx->tim_mem);\n\tbnxt_free_ctx_pg_tbls(bp, &ctx->mrav_mem);\n\tbnxt_free_ctx_pg_tbls(bp, &ctx->stat_mem);\n\tbnxt_free_ctx_pg_tbls(bp, &ctx->vnic_mem);\n\tbnxt_free_ctx_pg_tbls(bp, &ctx->cq_mem);\n\tbnxt_free_ctx_pg_tbls(bp, &ctx->srq_mem);\n\tbnxt_free_ctx_pg_tbls(bp, &ctx->qp_mem);\n\tctx->flags &= ~BNXT_CTX_FLAG_INITED;\n}\n\nstatic int bnxt_alloc_ctx_mem(struct bnxt *bp)\n{\n\tstruct bnxt_ctx_pg_info *ctx_pg;\n\tstruct bnxt_ctx_mem_info *ctx;\n\tstruct bnxt_mem_init *init;\n\tu32 mem_size, ena, entries;\n\tu32 entries_sp, min;\n\tu32 num_mr, num_ah;\n\tu32 extra_srqs = 0;\n\tu32 extra_qps = 0;\n\tu8 pg_lvl = 1;\n\tint i, rc;\n\n\trc = bnxt_hwrm_func_backing_store_qcaps(bp);\n\tif (rc) {\n\t\tnetdev_err(bp->dev, \"Failed querying context mem capability, rc = %d.\\n\",\n\t\t\t   rc);\n\t\treturn rc;\n\t}\n\tctx = bp->ctx;\n\tif (!ctx || (ctx->flags & BNXT_CTX_FLAG_INITED))\n\t\treturn 0;\n\n\tif ((bp->flags & BNXT_FLAG_ROCE_CAP) && !is_kdump_kernel()) {\n\t\tpg_lvl = 2;\n\t\textra_qps = 65536;\n\t\textra_srqs = 8192;\n\t}\n\n\tctx_pg = &ctx->qp_mem;\n\tctx_pg->entries = ctx->qp_min_qp1_entries + ctx->qp_max_l2_entries +\n\t\t\t  extra_qps;\n\tif (ctx->qp_entry_size) {\n\t\tmem_size = ctx->qp_entry_size * ctx_pg->entries;\n\t\tinit = &ctx->mem_init[BNXT_CTX_MEM_INIT_QP];\n\t\trc = bnxt_alloc_ctx_pg_tbls(bp, ctx_pg, mem_size, pg_lvl, init);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\tctx_pg = &ctx->srq_mem;\n\tctx_pg->entries = ctx->srq_max_l2_entries + extra_srqs;\n\tif (ctx->srq_entry_size) {\n\t\tmem_size = ctx->srq_entry_size * ctx_pg->entries;\n\t\tinit = &ctx->mem_init[BNXT_CTX_MEM_INIT_SRQ];\n\t\trc = bnxt_alloc_ctx_pg_tbls(bp, ctx_pg, mem_size, pg_lvl, init);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\tctx_pg = &ctx->cq_mem;\n\tctx_pg->entries = ctx->cq_max_l2_entries + extra_qps * 2;\n\tif (ctx->cq_entry_size) {\n\t\tmem_size = ctx->cq_entry_size * ctx_pg->entries;\n\t\tinit = &ctx->mem_init[BNXT_CTX_MEM_INIT_CQ];\n\t\trc = bnxt_alloc_ctx_pg_tbls(bp, ctx_pg, mem_size, pg_lvl, init);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\tctx_pg = &ctx->vnic_mem;\n\tctx_pg->entries = ctx->vnic_max_vnic_entries +\n\t\t\t  ctx->vnic_max_ring_table_entries;\n\tif (ctx->vnic_entry_size) {\n\t\tmem_size = ctx->vnic_entry_size * ctx_pg->entries;\n\t\tinit = &ctx->mem_init[BNXT_CTX_MEM_INIT_VNIC];\n\t\trc = bnxt_alloc_ctx_pg_tbls(bp, ctx_pg, mem_size, 1, init);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\tctx_pg = &ctx->stat_mem;\n\tctx_pg->entries = ctx->stat_max_entries;\n\tif (ctx->stat_entry_size) {\n\t\tmem_size = ctx->stat_entry_size * ctx_pg->entries;\n\t\tinit = &ctx->mem_init[BNXT_CTX_MEM_INIT_STAT];\n\t\trc = bnxt_alloc_ctx_pg_tbls(bp, ctx_pg, mem_size, 1, init);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\tena = 0;\n\tif (!(bp->flags & BNXT_FLAG_ROCE_CAP))\n\t\tgoto skip_rdma;\n\n\tctx_pg = &ctx->mrav_mem;\n\t \n\tnum_mr = 1024 * 256;\n\tnum_ah = 1024 * 128;\n\tctx_pg->entries = num_mr + num_ah;\n\tif (ctx->mrav_entry_size) {\n\t\tmem_size = ctx->mrav_entry_size * ctx_pg->entries;\n\t\tinit = &ctx->mem_init[BNXT_CTX_MEM_INIT_MRAV];\n\t\trc = bnxt_alloc_ctx_pg_tbls(bp, ctx_pg, mem_size, 2, init);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\tena = FUNC_BACKING_STORE_CFG_REQ_ENABLES_MRAV;\n\tif (ctx->mrav_num_entries_units)\n\t\tctx_pg->entries =\n\t\t\t((num_mr / ctx->mrav_num_entries_units) << 16) |\n\t\t\t (num_ah / ctx->mrav_num_entries_units);\n\n\tctx_pg = &ctx->tim_mem;\n\tctx_pg->entries = ctx->qp_mem.entries;\n\tif (ctx->tim_entry_size) {\n\t\tmem_size = ctx->tim_entry_size * ctx_pg->entries;\n\t\trc = bnxt_alloc_ctx_pg_tbls(bp, ctx_pg, mem_size, 1, NULL);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\tena |= FUNC_BACKING_STORE_CFG_REQ_ENABLES_TIM;\n\nskip_rdma:\n\tmin = ctx->tqm_min_entries_per_ring;\n\tentries_sp = ctx->vnic_max_vnic_entries + ctx->qp_max_l2_entries +\n\t\t     2 * (extra_qps + ctx->qp_min_qp1_entries) + min;\n\tentries_sp = roundup(entries_sp, ctx->tqm_entries_multiple);\n\tentries = ctx->qp_max_l2_entries + 2 * (extra_qps + ctx->qp_min_qp1_entries);\n\tentries = roundup(entries, ctx->tqm_entries_multiple);\n\tentries = clamp_t(u32, entries, min, ctx->tqm_max_entries_per_ring);\n\tfor (i = 0; i < ctx->tqm_fp_rings_count + 1; i++) {\n\t\tctx_pg = ctx->tqm_mem[i];\n\t\tctx_pg->entries = i ? entries : entries_sp;\n\t\tif (ctx->tqm_entry_size) {\n\t\t\tmem_size = ctx->tqm_entry_size * ctx_pg->entries;\n\t\t\trc = bnxt_alloc_ctx_pg_tbls(bp, ctx_pg, mem_size, 1,\n\t\t\t\t\t\t    NULL);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t}\n\t\tena |= FUNC_BACKING_STORE_CFG_REQ_ENABLES_TQM_SP << i;\n\t}\n\tena |= FUNC_BACKING_STORE_CFG_REQ_DFLT_ENABLES;\n\trc = bnxt_hwrm_func_backing_store_cfg(bp, ena);\n\tif (rc) {\n\t\tnetdev_err(bp->dev, \"Failed configuring context mem, rc = %d.\\n\",\n\t\t\t   rc);\n\t\treturn rc;\n\t}\n\tctx->flags |= BNXT_CTX_FLAG_INITED;\n\treturn 0;\n}\n\nint bnxt_hwrm_func_resc_qcaps(struct bnxt *bp, bool all)\n{\n\tstruct hwrm_func_resource_qcaps_output *resp;\n\tstruct hwrm_func_resource_qcaps_input *req;\n\tstruct bnxt_hw_resc *hw_resc = &bp->hw_resc;\n\tint rc;\n\n\trc = hwrm_req_init(bp, req, HWRM_FUNC_RESOURCE_QCAPS);\n\tif (rc)\n\t\treturn rc;\n\n\treq->fid = cpu_to_le16(0xffff);\n\tresp = hwrm_req_hold(bp, req);\n\trc = hwrm_req_send_silent(bp, req);\n\tif (rc)\n\t\tgoto hwrm_func_resc_qcaps_exit;\n\n\thw_resc->max_tx_sch_inputs = le16_to_cpu(resp->max_tx_scheduler_inputs);\n\tif (!all)\n\t\tgoto hwrm_func_resc_qcaps_exit;\n\n\thw_resc->min_rsscos_ctxs = le16_to_cpu(resp->min_rsscos_ctx);\n\thw_resc->max_rsscos_ctxs = le16_to_cpu(resp->max_rsscos_ctx);\n\thw_resc->min_cp_rings = le16_to_cpu(resp->min_cmpl_rings);\n\thw_resc->max_cp_rings = le16_to_cpu(resp->max_cmpl_rings);\n\thw_resc->min_tx_rings = le16_to_cpu(resp->min_tx_rings);\n\thw_resc->max_tx_rings = le16_to_cpu(resp->max_tx_rings);\n\thw_resc->min_rx_rings = le16_to_cpu(resp->min_rx_rings);\n\thw_resc->max_rx_rings = le16_to_cpu(resp->max_rx_rings);\n\thw_resc->min_hw_ring_grps = le16_to_cpu(resp->min_hw_ring_grps);\n\thw_resc->max_hw_ring_grps = le16_to_cpu(resp->max_hw_ring_grps);\n\thw_resc->min_l2_ctxs = le16_to_cpu(resp->min_l2_ctxs);\n\thw_resc->max_l2_ctxs = le16_to_cpu(resp->max_l2_ctxs);\n\thw_resc->min_vnics = le16_to_cpu(resp->min_vnics);\n\thw_resc->max_vnics = le16_to_cpu(resp->max_vnics);\n\thw_resc->min_stat_ctxs = le16_to_cpu(resp->min_stat_ctx);\n\thw_resc->max_stat_ctxs = le16_to_cpu(resp->max_stat_ctx);\n\n\tif (bp->flags & BNXT_FLAG_CHIP_P5) {\n\t\tu16 max_msix = le16_to_cpu(resp->max_msix);\n\n\t\thw_resc->max_nqs = max_msix;\n\t\thw_resc->max_hw_ring_grps = hw_resc->max_rx_rings;\n\t}\n\n\tif (BNXT_PF(bp)) {\n\t\tstruct bnxt_pf_info *pf = &bp->pf;\n\n\t\tpf->vf_resv_strategy =\n\t\t\tle16_to_cpu(resp->vf_reservation_strategy);\n\t\tif (pf->vf_resv_strategy > BNXT_VF_RESV_STRATEGY_MINIMAL_STATIC)\n\t\t\tpf->vf_resv_strategy = BNXT_VF_RESV_STRATEGY_MAXIMAL;\n\t}\nhwrm_func_resc_qcaps_exit:\n\thwrm_req_drop(bp, req);\n\treturn rc;\n}\n\nstatic int __bnxt_hwrm_ptp_qcfg(struct bnxt *bp)\n{\n\tstruct hwrm_port_mac_ptp_qcfg_output *resp;\n\tstruct hwrm_port_mac_ptp_qcfg_input *req;\n\tstruct bnxt_ptp_cfg *ptp = bp->ptp_cfg;\n\tbool phc_cfg;\n\tu8 flags;\n\tint rc;\n\n\tif (bp->hwrm_spec_code < 0x10801 || !BNXT_CHIP_P5_THOR(bp)) {\n\t\trc = -ENODEV;\n\t\tgoto no_ptp;\n\t}\n\n\trc = hwrm_req_init(bp, req, HWRM_PORT_MAC_PTP_QCFG);\n\tif (rc)\n\t\tgoto no_ptp;\n\n\treq->port_id = cpu_to_le16(bp->pf.port_id);\n\tresp = hwrm_req_hold(bp, req);\n\trc = hwrm_req_send(bp, req);\n\tif (rc)\n\t\tgoto exit;\n\n\tflags = resp->flags;\n\tif (!(flags & PORT_MAC_PTP_QCFG_RESP_FLAGS_HWRM_ACCESS)) {\n\t\trc = -ENODEV;\n\t\tgoto exit;\n\t}\n\tif (!ptp) {\n\t\tptp = kzalloc(sizeof(*ptp), GFP_KERNEL);\n\t\tif (!ptp) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto exit;\n\t\t}\n\t\tptp->bp = bp;\n\t\tbp->ptp_cfg = ptp;\n\t}\n\tif (flags & PORT_MAC_PTP_QCFG_RESP_FLAGS_PARTIAL_DIRECT_ACCESS_REF_CLOCK) {\n\t\tptp->refclk_regs[0] = le32_to_cpu(resp->ts_ref_clock_reg_lower);\n\t\tptp->refclk_regs[1] = le32_to_cpu(resp->ts_ref_clock_reg_upper);\n\t} else if (bp->flags & BNXT_FLAG_CHIP_P5) {\n\t\tptp->refclk_regs[0] = BNXT_TS_REG_TIMESYNC_TS0_LOWER;\n\t\tptp->refclk_regs[1] = BNXT_TS_REG_TIMESYNC_TS0_UPPER;\n\t} else {\n\t\trc = -ENODEV;\n\t\tgoto exit;\n\t}\n\tphc_cfg = (flags & PORT_MAC_PTP_QCFG_RESP_FLAGS_RTC_CONFIGURED) != 0;\n\trc = bnxt_ptp_init(bp, phc_cfg);\n\tif (rc)\n\t\tnetdev_warn(bp->dev, \"PTP initialization failed.\\n\");\nexit:\n\thwrm_req_drop(bp, req);\n\tif (!rc)\n\t\treturn 0;\n\nno_ptp:\n\tbnxt_ptp_clear(bp);\n\tkfree(ptp);\n\tbp->ptp_cfg = NULL;\n\treturn rc;\n}\n\nstatic int __bnxt_hwrm_func_qcaps(struct bnxt *bp)\n{\n\tstruct hwrm_func_qcaps_output *resp;\n\tstruct hwrm_func_qcaps_input *req;\n\tstruct bnxt_hw_resc *hw_resc = &bp->hw_resc;\n\tu32 flags, flags_ext, flags_ext2;\n\tint rc;\n\n\trc = hwrm_req_init(bp, req, HWRM_FUNC_QCAPS);\n\tif (rc)\n\t\treturn rc;\n\n\treq->fid = cpu_to_le16(0xffff);\n\tresp = hwrm_req_hold(bp, req);\n\trc = hwrm_req_send(bp, req);\n\tif (rc)\n\t\tgoto hwrm_func_qcaps_exit;\n\n\tflags = le32_to_cpu(resp->flags);\n\tif (flags & FUNC_QCAPS_RESP_FLAGS_ROCE_V1_SUPPORTED)\n\t\tbp->flags |= BNXT_FLAG_ROCEV1_CAP;\n\tif (flags & FUNC_QCAPS_RESP_FLAGS_ROCE_V2_SUPPORTED)\n\t\tbp->flags |= BNXT_FLAG_ROCEV2_CAP;\n\tif (flags & FUNC_QCAPS_RESP_FLAGS_PCIE_STATS_SUPPORTED)\n\t\tbp->fw_cap |= BNXT_FW_CAP_PCIE_STATS_SUPPORTED;\n\tif (flags & FUNC_QCAPS_RESP_FLAGS_HOT_RESET_CAPABLE)\n\t\tbp->fw_cap |= BNXT_FW_CAP_HOT_RESET;\n\tif (flags & FUNC_QCAPS_RESP_FLAGS_EXT_STATS_SUPPORTED)\n\t\tbp->fw_cap |= BNXT_FW_CAP_EXT_STATS_SUPPORTED;\n\tif (flags &  FUNC_QCAPS_RESP_FLAGS_ERROR_RECOVERY_CAPABLE)\n\t\tbp->fw_cap |= BNXT_FW_CAP_ERROR_RECOVERY;\n\tif (flags & FUNC_QCAPS_RESP_FLAGS_ERR_RECOVER_RELOAD)\n\t\tbp->fw_cap |= BNXT_FW_CAP_ERR_RECOVER_RELOAD;\n\tif (!(flags & FUNC_QCAPS_RESP_FLAGS_VLAN_ACCELERATION_TX_DISABLED))\n\t\tbp->fw_cap |= BNXT_FW_CAP_VLAN_TX_INSERT;\n\tif (flags & FUNC_QCAPS_RESP_FLAGS_DBG_QCAPS_CMD_SUPPORTED)\n\t\tbp->fw_cap |= BNXT_FW_CAP_DBG_QCAPS;\n\n\tflags_ext = le32_to_cpu(resp->flags_ext);\n\tif (flags_ext & FUNC_QCAPS_RESP_FLAGS_EXT_EXT_HW_STATS_SUPPORTED)\n\t\tbp->fw_cap |= BNXT_FW_CAP_EXT_HW_STATS_SUPPORTED;\n\tif (BNXT_PF(bp) && (flags_ext & FUNC_QCAPS_RESP_FLAGS_EXT_PTP_PPS_SUPPORTED))\n\t\tbp->fw_cap |= BNXT_FW_CAP_PTP_PPS;\n\tif (flags_ext & FUNC_QCAPS_RESP_FLAGS_EXT_PTP_64BIT_RTC_SUPPORTED)\n\t\tbp->fw_cap |= BNXT_FW_CAP_PTP_RTC;\n\tif (BNXT_PF(bp) && (flags_ext & FUNC_QCAPS_RESP_FLAGS_EXT_HOT_RESET_IF_SUPPORT))\n\t\tbp->fw_cap |= BNXT_FW_CAP_HOT_RESET_IF;\n\tif (BNXT_PF(bp) && (flags_ext & FUNC_QCAPS_RESP_FLAGS_EXT_FW_LIVEPATCH_SUPPORTED))\n\t\tbp->fw_cap |= BNXT_FW_CAP_LIVEPATCH;\n\n\tflags_ext2 = le32_to_cpu(resp->flags_ext2);\n\tif (flags_ext2 & FUNC_QCAPS_RESP_FLAGS_EXT2_RX_ALL_PKTS_TIMESTAMPS_SUPPORTED)\n\t\tbp->fw_cap |= BNXT_FW_CAP_RX_ALL_PKT_TS;\n\n\tbp->tx_push_thresh = 0;\n\tif ((flags & FUNC_QCAPS_RESP_FLAGS_PUSH_MODE_SUPPORTED) &&\n\t    BNXT_FW_MAJ(bp) > 217)\n\t\tbp->tx_push_thresh = BNXT_TX_PUSH_THRESH;\n\n\thw_resc->max_rsscos_ctxs = le16_to_cpu(resp->max_rsscos_ctx);\n\thw_resc->max_cp_rings = le16_to_cpu(resp->max_cmpl_rings);\n\thw_resc->max_tx_rings = le16_to_cpu(resp->max_tx_rings);\n\thw_resc->max_rx_rings = le16_to_cpu(resp->max_rx_rings);\n\thw_resc->max_hw_ring_grps = le32_to_cpu(resp->max_hw_ring_grps);\n\tif (!hw_resc->max_hw_ring_grps)\n\t\thw_resc->max_hw_ring_grps = hw_resc->max_tx_rings;\n\thw_resc->max_l2_ctxs = le16_to_cpu(resp->max_l2_ctxs);\n\thw_resc->max_vnics = le16_to_cpu(resp->max_vnics);\n\thw_resc->max_stat_ctxs = le16_to_cpu(resp->max_stat_ctx);\n\n\tif (BNXT_PF(bp)) {\n\t\tstruct bnxt_pf_info *pf = &bp->pf;\n\n\t\tpf->fw_fid = le16_to_cpu(resp->fid);\n\t\tpf->port_id = le16_to_cpu(resp->port_id);\n\t\tmemcpy(pf->mac_addr, resp->mac_address, ETH_ALEN);\n\t\tpf->first_vf_id = le16_to_cpu(resp->first_vf_id);\n\t\tpf->max_vfs = le16_to_cpu(resp->max_vfs);\n\t\tpf->max_encap_records = le32_to_cpu(resp->max_encap_records);\n\t\tpf->max_decap_records = le32_to_cpu(resp->max_decap_records);\n\t\tpf->max_tx_em_flows = le32_to_cpu(resp->max_tx_em_flows);\n\t\tpf->max_tx_wm_flows = le32_to_cpu(resp->max_tx_wm_flows);\n\t\tpf->max_rx_em_flows = le32_to_cpu(resp->max_rx_em_flows);\n\t\tpf->max_rx_wm_flows = le32_to_cpu(resp->max_rx_wm_flows);\n\t\tbp->flags &= ~BNXT_FLAG_WOL_CAP;\n\t\tif (flags & FUNC_QCAPS_RESP_FLAGS_WOL_MAGICPKT_SUPPORTED)\n\t\t\tbp->flags |= BNXT_FLAG_WOL_CAP;\n\t\tif (flags & FUNC_QCAPS_RESP_FLAGS_PTP_SUPPORTED) {\n\t\t\tbp->fw_cap |= BNXT_FW_CAP_PTP;\n\t\t} else {\n\t\t\tbnxt_ptp_clear(bp);\n\t\t\tkfree(bp->ptp_cfg);\n\t\t\tbp->ptp_cfg = NULL;\n\t\t}\n\t} else {\n#ifdef CONFIG_BNXT_SRIOV\n\t\tstruct bnxt_vf_info *vf = &bp->vf;\n\n\t\tvf->fw_fid = le16_to_cpu(resp->fid);\n\t\tmemcpy(vf->mac_addr, resp->mac_address, ETH_ALEN);\n#endif\n\t}\n\nhwrm_func_qcaps_exit:\n\thwrm_req_drop(bp, req);\n\treturn rc;\n}\n\nstatic void bnxt_hwrm_dbg_qcaps(struct bnxt *bp)\n{\n\tstruct hwrm_dbg_qcaps_output *resp;\n\tstruct hwrm_dbg_qcaps_input *req;\n\tint rc;\n\n\tbp->fw_dbg_cap = 0;\n\tif (!(bp->fw_cap & BNXT_FW_CAP_DBG_QCAPS))\n\t\treturn;\n\n\trc = hwrm_req_init(bp, req, HWRM_DBG_QCAPS);\n\tif (rc)\n\t\treturn;\n\n\treq->fid = cpu_to_le16(0xffff);\n\tresp = hwrm_req_hold(bp, req);\n\trc = hwrm_req_send(bp, req);\n\tif (rc)\n\t\tgoto hwrm_dbg_qcaps_exit;\n\n\tbp->fw_dbg_cap = le32_to_cpu(resp->flags);\n\nhwrm_dbg_qcaps_exit:\n\thwrm_req_drop(bp, req);\n}\n\nstatic int bnxt_hwrm_queue_qportcfg(struct bnxt *bp);\n\nint bnxt_hwrm_func_qcaps(struct bnxt *bp)\n{\n\tint rc;\n\n\trc = __bnxt_hwrm_func_qcaps(bp);\n\tif (rc)\n\t\treturn rc;\n\n\tbnxt_hwrm_dbg_qcaps(bp);\n\n\trc = bnxt_hwrm_queue_qportcfg(bp);\n\tif (rc) {\n\t\tnetdev_err(bp->dev, \"hwrm query qportcfg failure rc: %d\\n\", rc);\n\t\treturn rc;\n\t}\n\tif (bp->hwrm_spec_code >= 0x10803) {\n\t\trc = bnxt_alloc_ctx_mem(bp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\trc = bnxt_hwrm_func_resc_qcaps(bp, true);\n\t\tif (!rc)\n\t\t\tbp->fw_cap |= BNXT_FW_CAP_NEW_RM;\n\t}\n\treturn 0;\n}\n\nstatic int bnxt_hwrm_cfa_adv_flow_mgnt_qcaps(struct bnxt *bp)\n{\n\tstruct hwrm_cfa_adv_flow_mgnt_qcaps_output *resp;\n\tstruct hwrm_cfa_adv_flow_mgnt_qcaps_input *req;\n\tu32 flags;\n\tint rc;\n\n\tif (!(bp->fw_cap & BNXT_FW_CAP_CFA_ADV_FLOW))\n\t\treturn 0;\n\n\trc = hwrm_req_init(bp, req, HWRM_CFA_ADV_FLOW_MGNT_QCAPS);\n\tif (rc)\n\t\treturn rc;\n\n\tresp = hwrm_req_hold(bp, req);\n\trc = hwrm_req_send(bp, req);\n\tif (rc)\n\t\tgoto hwrm_cfa_adv_qcaps_exit;\n\n\tflags = le32_to_cpu(resp->flags);\n\tif (flags &\n\t    CFA_ADV_FLOW_MGNT_QCAPS_RESP_FLAGS_RFS_RING_TBL_IDX_V2_SUPPORTED)\n\t\tbp->fw_cap |= BNXT_FW_CAP_CFA_RFS_RING_TBL_IDX_V2;\n\nhwrm_cfa_adv_qcaps_exit:\n\thwrm_req_drop(bp, req);\n\treturn rc;\n}\n\nstatic int __bnxt_alloc_fw_health(struct bnxt *bp)\n{\n\tif (bp->fw_health)\n\t\treturn 0;\n\n\tbp->fw_health = kzalloc(sizeof(*bp->fw_health), GFP_KERNEL);\n\tif (!bp->fw_health)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&bp->fw_health->lock);\n\treturn 0;\n}\n\nstatic int bnxt_alloc_fw_health(struct bnxt *bp)\n{\n\tint rc;\n\n\tif (!(bp->fw_cap & BNXT_FW_CAP_HOT_RESET) &&\n\t    !(bp->fw_cap & BNXT_FW_CAP_ERROR_RECOVERY))\n\t\treturn 0;\n\n\trc = __bnxt_alloc_fw_health(bp);\n\tif (rc) {\n\t\tbp->fw_cap &= ~BNXT_FW_CAP_HOT_RESET;\n\t\tbp->fw_cap &= ~BNXT_FW_CAP_ERROR_RECOVERY;\n\t\treturn rc;\n\t}\n\n\treturn 0;\n}\n\nstatic void __bnxt_map_fw_health_reg(struct bnxt *bp, u32 reg)\n{\n\twritel(reg & BNXT_GRC_BASE_MASK, bp->bar0 +\n\t\t\t\t\t BNXT_GRCPF_REG_WINDOW_BASE_OUT +\n\t\t\t\t\t BNXT_FW_HEALTH_WIN_MAP_OFF);\n}\n\nstatic void bnxt_inv_fw_health_reg(struct bnxt *bp)\n{\n\tstruct bnxt_fw_health *fw_health = bp->fw_health;\n\tu32 reg_type;\n\n\tif (!fw_health)\n\t\treturn;\n\n\treg_type = BNXT_FW_HEALTH_REG_TYPE(fw_health->regs[BNXT_FW_HEALTH_REG]);\n\tif (reg_type == BNXT_FW_HEALTH_REG_TYPE_GRC)\n\t\tfw_health->status_reliable = false;\n\n\treg_type = BNXT_FW_HEALTH_REG_TYPE(fw_health->regs[BNXT_FW_RESET_CNT_REG]);\n\tif (reg_type == BNXT_FW_HEALTH_REG_TYPE_GRC)\n\t\tfw_health->resets_reliable = false;\n}\n\nstatic void bnxt_try_map_fw_health_reg(struct bnxt *bp)\n{\n\tvoid __iomem *hs;\n\tu32 status_loc;\n\tu32 reg_type;\n\tu32 sig;\n\n\tif (bp->fw_health)\n\t\tbp->fw_health->status_reliable = false;\n\n\t__bnxt_map_fw_health_reg(bp, HCOMM_STATUS_STRUCT_LOC);\n\ths = bp->bar0 + BNXT_FW_HEALTH_WIN_OFF(HCOMM_STATUS_STRUCT_LOC);\n\n\tsig = readl(hs + offsetof(struct hcomm_status, sig_ver));\n\tif ((sig & HCOMM_STATUS_SIGNATURE_MASK) != HCOMM_STATUS_SIGNATURE_VAL) {\n\t\tif (!bp->chip_num) {\n\t\t\t__bnxt_map_fw_health_reg(bp, BNXT_GRC_REG_BASE);\n\t\t\tbp->chip_num = readl(bp->bar0 +\n\t\t\t\t\t     BNXT_FW_HEALTH_WIN_BASE +\n\t\t\t\t\t     BNXT_GRC_REG_CHIP_NUM);\n\t\t}\n\t\tif (!BNXT_CHIP_P5(bp))\n\t\t\treturn;\n\n\t\tstatus_loc = BNXT_GRC_REG_STATUS_P5 |\n\t\t\t     BNXT_FW_HEALTH_REG_TYPE_BAR0;\n\t} else {\n\t\tstatus_loc = readl(hs + offsetof(struct hcomm_status,\n\t\t\t\t\t\t fw_status_loc));\n\t}\n\n\tif (__bnxt_alloc_fw_health(bp)) {\n\t\tnetdev_warn(bp->dev, \"no memory for firmware status checks\\n\");\n\t\treturn;\n\t}\n\n\tbp->fw_health->regs[BNXT_FW_HEALTH_REG] = status_loc;\n\treg_type = BNXT_FW_HEALTH_REG_TYPE(status_loc);\n\tif (reg_type == BNXT_FW_HEALTH_REG_TYPE_GRC) {\n\t\t__bnxt_map_fw_health_reg(bp, status_loc);\n\t\tbp->fw_health->mapped_regs[BNXT_FW_HEALTH_REG] =\n\t\t\tBNXT_FW_HEALTH_WIN_OFF(status_loc);\n\t}\n\n\tbp->fw_health->status_reliable = true;\n}\n\nstatic int bnxt_map_fw_health_regs(struct bnxt *bp)\n{\n\tstruct bnxt_fw_health *fw_health = bp->fw_health;\n\tu32 reg_base = 0xffffffff;\n\tint i;\n\n\tbp->fw_health->status_reliable = false;\n\tbp->fw_health->resets_reliable = false;\n\t \n\tfor (i = 0; i < 4; i++) {\n\t\tu32 reg = fw_health->regs[i];\n\n\t\tif (BNXT_FW_HEALTH_REG_TYPE(reg) != BNXT_FW_HEALTH_REG_TYPE_GRC)\n\t\t\tcontinue;\n\t\tif (reg_base == 0xffffffff)\n\t\t\treg_base = reg & BNXT_GRC_BASE_MASK;\n\t\tif ((reg & BNXT_GRC_BASE_MASK) != reg_base)\n\t\t\treturn -ERANGE;\n\t\tfw_health->mapped_regs[i] = BNXT_FW_HEALTH_WIN_OFF(reg);\n\t}\n\tbp->fw_health->status_reliable = true;\n\tbp->fw_health->resets_reliable = true;\n\tif (reg_base == 0xffffffff)\n\t\treturn 0;\n\n\t__bnxt_map_fw_health_reg(bp, reg_base);\n\treturn 0;\n}\n\nstatic void bnxt_remap_fw_health_regs(struct bnxt *bp)\n{\n\tif (!bp->fw_health)\n\t\treturn;\n\n\tif (bp->fw_cap & BNXT_FW_CAP_ERROR_RECOVERY) {\n\t\tbp->fw_health->status_reliable = true;\n\t\tbp->fw_health->resets_reliable = true;\n\t} else {\n\t\tbnxt_try_map_fw_health_reg(bp);\n\t}\n}\n\nstatic int bnxt_hwrm_error_recovery_qcfg(struct bnxt *bp)\n{\n\tstruct bnxt_fw_health *fw_health = bp->fw_health;\n\tstruct hwrm_error_recovery_qcfg_output *resp;\n\tstruct hwrm_error_recovery_qcfg_input *req;\n\tint rc, i;\n\n\tif (!(bp->fw_cap & BNXT_FW_CAP_ERROR_RECOVERY))\n\t\treturn 0;\n\n\trc = hwrm_req_init(bp, req, HWRM_ERROR_RECOVERY_QCFG);\n\tif (rc)\n\t\treturn rc;\n\n\tresp = hwrm_req_hold(bp, req);\n\trc = hwrm_req_send(bp, req);\n\tif (rc)\n\t\tgoto err_recovery_out;\n\tfw_health->flags = le32_to_cpu(resp->flags);\n\tif ((fw_health->flags & ERROR_RECOVERY_QCFG_RESP_FLAGS_CO_CPU) &&\n\t    !(bp->fw_cap & BNXT_FW_CAP_KONG_MB_CHNL)) {\n\t\trc = -EINVAL;\n\t\tgoto err_recovery_out;\n\t}\n\tfw_health->polling_dsecs = le32_to_cpu(resp->driver_polling_freq);\n\tfw_health->master_func_wait_dsecs =\n\t\tle32_to_cpu(resp->master_func_wait_period);\n\tfw_health->normal_func_wait_dsecs =\n\t\tle32_to_cpu(resp->normal_func_wait_period);\n\tfw_health->post_reset_wait_dsecs =\n\t\tle32_to_cpu(resp->master_func_wait_period_after_reset);\n\tfw_health->post_reset_max_wait_dsecs =\n\t\tle32_to_cpu(resp->max_bailout_time_after_reset);\n\tfw_health->regs[BNXT_FW_HEALTH_REG] =\n\t\tle32_to_cpu(resp->fw_health_status_reg);\n\tfw_health->regs[BNXT_FW_HEARTBEAT_REG] =\n\t\tle32_to_cpu(resp->fw_heartbeat_reg);\n\tfw_health->regs[BNXT_FW_RESET_CNT_REG] =\n\t\tle32_to_cpu(resp->fw_reset_cnt_reg);\n\tfw_health->regs[BNXT_FW_RESET_INPROG_REG] =\n\t\tle32_to_cpu(resp->reset_inprogress_reg);\n\tfw_health->fw_reset_inprog_reg_mask =\n\t\tle32_to_cpu(resp->reset_inprogress_reg_mask);\n\tfw_health->fw_reset_seq_cnt = resp->reg_array_cnt;\n\tif (fw_health->fw_reset_seq_cnt >= 16) {\n\t\trc = -EINVAL;\n\t\tgoto err_recovery_out;\n\t}\n\tfor (i = 0; i < fw_health->fw_reset_seq_cnt; i++) {\n\t\tfw_health->fw_reset_seq_regs[i] =\n\t\t\tle32_to_cpu(resp->reset_reg[i]);\n\t\tfw_health->fw_reset_seq_vals[i] =\n\t\t\tle32_to_cpu(resp->reset_reg_val[i]);\n\t\tfw_health->fw_reset_seq_delay_msec[i] =\n\t\t\tresp->delay_after_reset[i];\n\t}\nerr_recovery_out:\n\thwrm_req_drop(bp, req);\n\tif (!rc)\n\t\trc = bnxt_map_fw_health_regs(bp);\n\tif (rc)\n\t\tbp->fw_cap &= ~BNXT_FW_CAP_ERROR_RECOVERY;\n\treturn rc;\n}\n\nstatic int bnxt_hwrm_func_reset(struct bnxt *bp)\n{\n\tstruct hwrm_func_reset_input *req;\n\tint rc;\n\n\trc = hwrm_req_init(bp, req, HWRM_FUNC_RESET);\n\tif (rc)\n\t\treturn rc;\n\n\treq->enables = 0;\n\thwrm_req_timeout(bp, req, HWRM_RESET_TIMEOUT);\n\treturn hwrm_req_send(bp, req);\n}\n\nstatic void bnxt_nvm_cfg_ver_get(struct bnxt *bp)\n{\n\tstruct hwrm_nvm_get_dev_info_output nvm_info;\n\n\tif (!bnxt_hwrm_nvm_get_dev_info(bp, &nvm_info))\n\t\tsnprintf(bp->nvm_cfg_ver, FW_VER_STR_LEN, \"%d.%d.%d\",\n\t\t\t nvm_info.nvm_cfg_ver_maj, nvm_info.nvm_cfg_ver_min,\n\t\t\t nvm_info.nvm_cfg_ver_upd);\n}\n\nstatic int bnxt_hwrm_queue_qportcfg(struct bnxt *bp)\n{\n\tstruct hwrm_queue_qportcfg_output *resp;\n\tstruct hwrm_queue_qportcfg_input *req;\n\tu8 i, j, *qptr;\n\tbool no_rdma;\n\tint rc = 0;\n\n\trc = hwrm_req_init(bp, req, HWRM_QUEUE_QPORTCFG);\n\tif (rc)\n\t\treturn rc;\n\n\tresp = hwrm_req_hold(bp, req);\n\trc = hwrm_req_send(bp, req);\n\tif (rc)\n\t\tgoto qportcfg_exit;\n\n\tif (!resp->max_configurable_queues) {\n\t\trc = -EINVAL;\n\t\tgoto qportcfg_exit;\n\t}\n\tbp->max_tc = resp->max_configurable_queues;\n\tbp->max_lltc = resp->max_configurable_lossless_queues;\n\tif (bp->max_tc > BNXT_MAX_QUEUE)\n\t\tbp->max_tc = BNXT_MAX_QUEUE;\n\n\tno_rdma = !(bp->flags & BNXT_FLAG_ROCE_CAP);\n\tqptr = &resp->queue_id0;\n\tfor (i = 0, j = 0; i < bp->max_tc; i++) {\n\t\tbp->q_info[j].queue_id = *qptr;\n\t\tbp->q_ids[i] = *qptr++;\n\t\tbp->q_info[j].queue_profile = *qptr++;\n\t\tbp->tc_to_qidx[j] = j;\n\t\tif (!BNXT_CNPQ(bp->q_info[j].queue_profile) ||\n\t\t    (no_rdma && BNXT_PF(bp)))\n\t\t\tj++;\n\t}\n\tbp->max_q = bp->max_tc;\n\tbp->max_tc = max_t(u8, j, 1);\n\n\tif (resp->queue_cfg_info & QUEUE_QPORTCFG_RESP_QUEUE_CFG_INFO_ASYM_CFG)\n\t\tbp->max_tc = 1;\n\n\tif (bp->max_lltc > bp->max_tc)\n\t\tbp->max_lltc = bp->max_tc;\n\nqportcfg_exit:\n\thwrm_req_drop(bp, req);\n\treturn rc;\n}\n\nstatic int bnxt_hwrm_poll(struct bnxt *bp)\n{\n\tstruct hwrm_ver_get_input *req;\n\tint rc;\n\n\trc = hwrm_req_init(bp, req, HWRM_VER_GET);\n\tif (rc)\n\t\treturn rc;\n\n\treq->hwrm_intf_maj = HWRM_VERSION_MAJOR;\n\treq->hwrm_intf_min = HWRM_VERSION_MINOR;\n\treq->hwrm_intf_upd = HWRM_VERSION_UPDATE;\n\n\thwrm_req_flags(bp, req, BNXT_HWRM_CTX_SILENT | BNXT_HWRM_FULL_WAIT);\n\trc = hwrm_req_send(bp, req);\n\treturn rc;\n}\n\nstatic int bnxt_hwrm_ver_get(struct bnxt *bp)\n{\n\tstruct hwrm_ver_get_output *resp;\n\tstruct hwrm_ver_get_input *req;\n\tu16 fw_maj, fw_min, fw_bld, fw_rsv;\n\tu32 dev_caps_cfg, hwrm_ver;\n\tint rc, len;\n\n\trc = hwrm_req_init(bp, req, HWRM_VER_GET);\n\tif (rc)\n\t\treturn rc;\n\n\thwrm_req_flags(bp, req, BNXT_HWRM_FULL_WAIT);\n\tbp->hwrm_max_req_len = HWRM_MAX_REQ_LEN;\n\treq->hwrm_intf_maj = HWRM_VERSION_MAJOR;\n\treq->hwrm_intf_min = HWRM_VERSION_MINOR;\n\treq->hwrm_intf_upd = HWRM_VERSION_UPDATE;\n\n\tresp = hwrm_req_hold(bp, req);\n\trc = hwrm_req_send(bp, req);\n\tif (rc)\n\t\tgoto hwrm_ver_get_exit;\n\n\tmemcpy(&bp->ver_resp, resp, sizeof(struct hwrm_ver_get_output));\n\n\tbp->hwrm_spec_code = resp->hwrm_intf_maj_8b << 16 |\n\t\t\t     resp->hwrm_intf_min_8b << 8 |\n\t\t\t     resp->hwrm_intf_upd_8b;\n\tif (resp->hwrm_intf_maj_8b < 1) {\n\t\tnetdev_warn(bp->dev, \"HWRM interface %d.%d.%d is older than 1.0.0.\\n\",\n\t\t\t    resp->hwrm_intf_maj_8b, resp->hwrm_intf_min_8b,\n\t\t\t    resp->hwrm_intf_upd_8b);\n\t\tnetdev_warn(bp->dev, \"Please update firmware with HWRM interface 1.0.0 or newer.\\n\");\n\t}\n\n\thwrm_ver = HWRM_VERSION_MAJOR << 16 | HWRM_VERSION_MINOR << 8 |\n\t\t\tHWRM_VERSION_UPDATE;\n\n\tif (bp->hwrm_spec_code > hwrm_ver)\n\t\tsnprintf(bp->hwrm_ver_supp, FW_VER_STR_LEN, \"%d.%d.%d\",\n\t\t\t HWRM_VERSION_MAJOR, HWRM_VERSION_MINOR,\n\t\t\t HWRM_VERSION_UPDATE);\n\telse\n\t\tsnprintf(bp->hwrm_ver_supp, FW_VER_STR_LEN, \"%d.%d.%d\",\n\t\t\t resp->hwrm_intf_maj_8b, resp->hwrm_intf_min_8b,\n\t\t\t resp->hwrm_intf_upd_8b);\n\n\tfw_maj = le16_to_cpu(resp->hwrm_fw_major);\n\tif (bp->hwrm_spec_code > 0x10803 && fw_maj) {\n\t\tfw_min = le16_to_cpu(resp->hwrm_fw_minor);\n\t\tfw_bld = le16_to_cpu(resp->hwrm_fw_build);\n\t\tfw_rsv = le16_to_cpu(resp->hwrm_fw_patch);\n\t\tlen = FW_VER_STR_LEN;\n\t} else {\n\t\tfw_maj = resp->hwrm_fw_maj_8b;\n\t\tfw_min = resp->hwrm_fw_min_8b;\n\t\tfw_bld = resp->hwrm_fw_bld_8b;\n\t\tfw_rsv = resp->hwrm_fw_rsvd_8b;\n\t\tlen = BC_HWRM_STR_LEN;\n\t}\n\tbp->fw_ver_code = BNXT_FW_VER_CODE(fw_maj, fw_min, fw_bld, fw_rsv);\n\tsnprintf(bp->fw_ver_str, len, \"%d.%d.%d.%d\", fw_maj, fw_min, fw_bld,\n\t\t fw_rsv);\n\n\tif (strlen(resp->active_pkg_name)) {\n\t\tint fw_ver_len = strlen(bp->fw_ver_str);\n\n\t\tsnprintf(bp->fw_ver_str + fw_ver_len,\n\t\t\t FW_VER_STR_LEN - fw_ver_len - 1, \"/pkg %s\",\n\t\t\t resp->active_pkg_name);\n\t\tbp->fw_cap |= BNXT_FW_CAP_PKG_VER;\n\t}\n\n\tbp->hwrm_cmd_timeout = le16_to_cpu(resp->def_req_timeout);\n\tif (!bp->hwrm_cmd_timeout)\n\t\tbp->hwrm_cmd_timeout = DFLT_HWRM_CMD_TIMEOUT;\n\tbp->hwrm_cmd_max_timeout = le16_to_cpu(resp->max_req_timeout) * 1000;\n\tif (!bp->hwrm_cmd_max_timeout)\n\t\tbp->hwrm_cmd_max_timeout = HWRM_CMD_MAX_TIMEOUT;\n\telse if (bp->hwrm_cmd_max_timeout > HWRM_CMD_MAX_TIMEOUT)\n\t\tnetdev_warn(bp->dev, \"Device requests max timeout of %d seconds, may trigger hung task watchdog\\n\",\n\t\t\t    bp->hwrm_cmd_max_timeout / 1000);\n\n\tif (resp->hwrm_intf_maj_8b >= 1) {\n\t\tbp->hwrm_max_req_len = le16_to_cpu(resp->max_req_win_len);\n\t\tbp->hwrm_max_ext_req_len = le16_to_cpu(resp->max_ext_req_len);\n\t}\n\tif (bp->hwrm_max_ext_req_len < HWRM_MAX_REQ_LEN)\n\t\tbp->hwrm_max_ext_req_len = HWRM_MAX_REQ_LEN;\n\n\tbp->chip_num = le16_to_cpu(resp->chip_num);\n\tbp->chip_rev = resp->chip_rev;\n\tif (bp->chip_num == CHIP_NUM_58700 && !resp->chip_rev &&\n\t    !resp->chip_metal)\n\t\tbp->flags |= BNXT_FLAG_CHIP_NITRO_A0;\n\n\tdev_caps_cfg = le32_to_cpu(resp->dev_caps_cfg);\n\tif ((dev_caps_cfg & VER_GET_RESP_DEV_CAPS_CFG_SHORT_CMD_SUPPORTED) &&\n\t    (dev_caps_cfg & VER_GET_RESP_DEV_CAPS_CFG_SHORT_CMD_REQUIRED))\n\t\tbp->fw_cap |= BNXT_FW_CAP_SHORT_CMD;\n\n\tif (dev_caps_cfg & VER_GET_RESP_DEV_CAPS_CFG_KONG_MB_CHNL_SUPPORTED)\n\t\tbp->fw_cap |= BNXT_FW_CAP_KONG_MB_CHNL;\n\n\tif (dev_caps_cfg &\n\t    VER_GET_RESP_DEV_CAPS_CFG_FLOW_HANDLE_64BIT_SUPPORTED)\n\t\tbp->fw_cap |= BNXT_FW_CAP_OVS_64BIT_HANDLE;\n\n\tif (dev_caps_cfg &\n\t    VER_GET_RESP_DEV_CAPS_CFG_TRUSTED_VF_SUPPORTED)\n\t\tbp->fw_cap |= BNXT_FW_CAP_TRUSTED_VF;\n\n\tif (dev_caps_cfg &\n\t    VER_GET_RESP_DEV_CAPS_CFG_CFA_ADV_FLOW_MGNT_SUPPORTED)\n\t\tbp->fw_cap |= BNXT_FW_CAP_CFA_ADV_FLOW;\n\nhwrm_ver_get_exit:\n\thwrm_req_drop(bp, req);\n\treturn rc;\n}\n\nint bnxt_hwrm_fw_set_time(struct bnxt *bp)\n{\n\tstruct hwrm_fw_set_time_input *req;\n\tstruct tm tm;\n\ttime64_t now = ktime_get_real_seconds();\n\tint rc;\n\n\tif ((BNXT_VF(bp) && bp->hwrm_spec_code < 0x10901) ||\n\t    bp->hwrm_spec_code < 0x10400)\n\t\treturn -EOPNOTSUPP;\n\n\ttime64_to_tm(now, 0, &tm);\n\trc = hwrm_req_init(bp, req, HWRM_FW_SET_TIME);\n\tif (rc)\n\t\treturn rc;\n\n\treq->year = cpu_to_le16(1900 + tm.tm_year);\n\treq->month = 1 + tm.tm_mon;\n\treq->day = tm.tm_mday;\n\treq->hour = tm.tm_hour;\n\treq->minute = tm.tm_min;\n\treq->second = tm.tm_sec;\n\treturn hwrm_req_send(bp, req);\n}\n\nstatic void bnxt_add_one_ctr(u64 hw, u64 *sw, u64 mask)\n{\n\tu64 sw_tmp;\n\n\thw &= mask;\n\tsw_tmp = (*sw & ~mask) | hw;\n\tif (hw < (*sw & mask))\n\t\tsw_tmp += mask + 1;\n\tWRITE_ONCE(*sw, sw_tmp);\n}\n\nstatic void __bnxt_accumulate_stats(__le64 *hw_stats, u64 *sw_stats, u64 *masks,\n\t\t\t\t    int count, bool ignore_zero)\n{\n\tint i;\n\n\tfor (i = 0; i < count; i++) {\n\t\tu64 hw = le64_to_cpu(READ_ONCE(hw_stats[i]));\n\n\t\tif (ignore_zero && !hw)\n\t\t\tcontinue;\n\n\t\tif (masks[i] == -1ULL)\n\t\t\tsw_stats[i] = hw;\n\t\telse\n\t\t\tbnxt_add_one_ctr(hw, &sw_stats[i], masks[i]);\n\t}\n}\n\nstatic void bnxt_accumulate_stats(struct bnxt_stats_mem *stats)\n{\n\tif (!stats->hw_stats)\n\t\treturn;\n\n\t__bnxt_accumulate_stats(stats->hw_stats, stats->sw_stats,\n\t\t\t\tstats->hw_masks, stats->len / 8, false);\n}\n\nstatic void bnxt_accumulate_all_stats(struct bnxt *bp)\n{\n\tstruct bnxt_stats_mem *ring0_stats;\n\tbool ignore_zero = false;\n\tint i;\n\n\t \n\tif (bp->flags & BNXT_FLAG_CHIP_P5)\n\t\tignore_zero = true;\n\n\tfor (i = 0; i < bp->cp_nr_rings; i++) {\n\t\tstruct bnxt_napi *bnapi = bp->bnapi[i];\n\t\tstruct bnxt_cp_ring_info *cpr;\n\t\tstruct bnxt_stats_mem *stats;\n\n\t\tcpr = &bnapi->cp_ring;\n\t\tstats = &cpr->stats;\n\t\tif (!i)\n\t\t\tring0_stats = stats;\n\t\t__bnxt_accumulate_stats(stats->hw_stats, stats->sw_stats,\n\t\t\t\t\tring0_stats->hw_masks,\n\t\t\t\t\tring0_stats->len / 8, ignore_zero);\n\t}\n\tif (bp->flags & BNXT_FLAG_PORT_STATS) {\n\t\tstruct bnxt_stats_mem *stats = &bp->port_stats;\n\t\t__le64 *hw_stats = stats->hw_stats;\n\t\tu64 *sw_stats = stats->sw_stats;\n\t\tu64 *masks = stats->hw_masks;\n\t\tint cnt;\n\n\t\tcnt = sizeof(struct rx_port_stats) / 8;\n\t\t__bnxt_accumulate_stats(hw_stats, sw_stats, masks, cnt, false);\n\n\t\thw_stats += BNXT_TX_PORT_STATS_BYTE_OFFSET / 8;\n\t\tsw_stats += BNXT_TX_PORT_STATS_BYTE_OFFSET / 8;\n\t\tmasks += BNXT_TX_PORT_STATS_BYTE_OFFSET / 8;\n\t\tcnt = sizeof(struct tx_port_stats) / 8;\n\t\t__bnxt_accumulate_stats(hw_stats, sw_stats, masks, cnt, false);\n\t}\n\tif (bp->flags & BNXT_FLAG_PORT_STATS_EXT) {\n\t\tbnxt_accumulate_stats(&bp->rx_port_stats_ext);\n\t\tbnxt_accumulate_stats(&bp->tx_port_stats_ext);\n\t}\n}\n\nstatic int bnxt_hwrm_port_qstats(struct bnxt *bp, u8 flags)\n{\n\tstruct hwrm_port_qstats_input *req;\n\tstruct bnxt_pf_info *pf = &bp->pf;\n\tint rc;\n\n\tif (!(bp->flags & BNXT_FLAG_PORT_STATS))\n\t\treturn 0;\n\n\tif (flags && !(bp->fw_cap & BNXT_FW_CAP_EXT_HW_STATS_SUPPORTED))\n\t\treturn -EOPNOTSUPP;\n\n\trc = hwrm_req_init(bp, req, HWRM_PORT_QSTATS);\n\tif (rc)\n\t\treturn rc;\n\n\treq->flags = flags;\n\treq->port_id = cpu_to_le16(pf->port_id);\n\treq->tx_stat_host_addr = cpu_to_le64(bp->port_stats.hw_stats_map +\n\t\t\t\t\t    BNXT_TX_PORT_STATS_BYTE_OFFSET);\n\treq->rx_stat_host_addr = cpu_to_le64(bp->port_stats.hw_stats_map);\n\treturn hwrm_req_send(bp, req);\n}\n\nstatic int bnxt_hwrm_port_qstats_ext(struct bnxt *bp, u8 flags)\n{\n\tstruct hwrm_queue_pri2cos_qcfg_output *resp_qc;\n\tstruct hwrm_queue_pri2cos_qcfg_input *req_qc;\n\tstruct hwrm_port_qstats_ext_output *resp_qs;\n\tstruct hwrm_port_qstats_ext_input *req_qs;\n\tstruct bnxt_pf_info *pf = &bp->pf;\n\tu32 tx_stat_size;\n\tint rc;\n\n\tif (!(bp->flags & BNXT_FLAG_PORT_STATS_EXT))\n\t\treturn 0;\n\n\tif (flags && !(bp->fw_cap & BNXT_FW_CAP_EXT_HW_STATS_SUPPORTED))\n\t\treturn -EOPNOTSUPP;\n\n\trc = hwrm_req_init(bp, req_qs, HWRM_PORT_QSTATS_EXT);\n\tif (rc)\n\t\treturn rc;\n\n\treq_qs->flags = flags;\n\treq_qs->port_id = cpu_to_le16(pf->port_id);\n\treq_qs->rx_stat_size = cpu_to_le16(sizeof(struct rx_port_stats_ext));\n\treq_qs->rx_stat_host_addr = cpu_to_le64(bp->rx_port_stats_ext.hw_stats_map);\n\ttx_stat_size = bp->tx_port_stats_ext.hw_stats ?\n\t\t       sizeof(struct tx_port_stats_ext) : 0;\n\treq_qs->tx_stat_size = cpu_to_le16(tx_stat_size);\n\treq_qs->tx_stat_host_addr = cpu_to_le64(bp->tx_port_stats_ext.hw_stats_map);\n\tresp_qs = hwrm_req_hold(bp, req_qs);\n\trc = hwrm_req_send(bp, req_qs);\n\tif (!rc) {\n\t\tbp->fw_rx_stats_ext_size =\n\t\t\tle16_to_cpu(resp_qs->rx_stat_size) / 8;\n\t\tif (BNXT_FW_MAJ(bp) < 220 &&\n\t\t    bp->fw_rx_stats_ext_size > BNXT_RX_STATS_EXT_NUM_LEGACY)\n\t\t\tbp->fw_rx_stats_ext_size = BNXT_RX_STATS_EXT_NUM_LEGACY;\n\n\t\tbp->fw_tx_stats_ext_size = tx_stat_size ?\n\t\t\tle16_to_cpu(resp_qs->tx_stat_size) / 8 : 0;\n\t} else {\n\t\tbp->fw_rx_stats_ext_size = 0;\n\t\tbp->fw_tx_stats_ext_size = 0;\n\t}\n\thwrm_req_drop(bp, req_qs);\n\n\tif (flags)\n\t\treturn rc;\n\n\tif (bp->fw_tx_stats_ext_size <=\n\t    offsetof(struct tx_port_stats_ext, pfc_pri0_tx_duration_us) / 8) {\n\t\tbp->pri2cos_valid = 0;\n\t\treturn rc;\n\t}\n\n\trc = hwrm_req_init(bp, req_qc, HWRM_QUEUE_PRI2COS_QCFG);\n\tif (rc)\n\t\treturn rc;\n\n\treq_qc->flags = cpu_to_le32(QUEUE_PRI2COS_QCFG_REQ_FLAGS_IVLAN);\n\n\tresp_qc = hwrm_req_hold(bp, req_qc);\n\trc = hwrm_req_send(bp, req_qc);\n\tif (!rc) {\n\t\tu8 *pri2cos;\n\t\tint i, j;\n\n\t\tpri2cos = &resp_qc->pri0_cos_queue_id;\n\t\tfor (i = 0; i < 8; i++) {\n\t\t\tu8 queue_id = pri2cos[i];\n\t\t\tu8 queue_idx;\n\n\t\t\t \n\t\t\tqueue_idx = queue_id % 10;\n\t\t\tif (queue_idx > BNXT_MAX_QUEUE) {\n\t\t\t\tbp->pri2cos_valid = false;\n\t\t\t\thwrm_req_drop(bp, req_qc);\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t\tfor (j = 0; j < bp->max_q; j++) {\n\t\t\t\tif (bp->q_ids[j] == queue_id)\n\t\t\t\t\tbp->pri2cos_idx[i] = queue_idx;\n\t\t\t}\n\t\t}\n\t\tbp->pri2cos_valid = true;\n\t}\n\thwrm_req_drop(bp, req_qc);\n\n\treturn rc;\n}\n\nstatic void bnxt_hwrm_free_tunnel_ports(struct bnxt *bp)\n{\n\tbnxt_hwrm_tunnel_dst_port_free(bp,\n\t\tTUNNEL_DST_PORT_FREE_REQ_TUNNEL_TYPE_VXLAN);\n\tbnxt_hwrm_tunnel_dst_port_free(bp,\n\t\tTUNNEL_DST_PORT_FREE_REQ_TUNNEL_TYPE_GENEVE);\n}\n\nstatic int bnxt_set_tpa(struct bnxt *bp, bool set_tpa)\n{\n\tint rc, i;\n\tu32 tpa_flags = 0;\n\n\tif (set_tpa)\n\t\ttpa_flags = bp->flags & BNXT_FLAG_TPA;\n\telse if (BNXT_NO_FW_ACCESS(bp))\n\t\treturn 0;\n\tfor (i = 0; i < bp->nr_vnics; i++) {\n\t\trc = bnxt_hwrm_vnic_set_tpa(bp, i, tpa_flags);\n\t\tif (rc) {\n\t\t\tnetdev_err(bp->dev, \"hwrm vnic set tpa failure rc for vnic %d: %x\\n\",\n\t\t\t\t   i, rc);\n\t\t\treturn rc;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void bnxt_hwrm_clear_vnic_rss(struct bnxt *bp)\n{\n\tint i;\n\n\tfor (i = 0; i < bp->nr_vnics; i++)\n\t\tbnxt_hwrm_vnic_set_rss(bp, i, false);\n}\n\nstatic void bnxt_clear_vnic(struct bnxt *bp)\n{\n\tif (!bp->vnic_info)\n\t\treturn;\n\n\tbnxt_hwrm_clear_vnic_filter(bp);\n\tif (!(bp->flags & BNXT_FLAG_CHIP_P5)) {\n\t\t \n\t\tbnxt_hwrm_clear_vnic_rss(bp);\n\t\tbnxt_hwrm_vnic_ctx_free(bp);\n\t}\n\t \n\tif (bp->flags & BNXT_FLAG_TPA)\n\t\tbnxt_set_tpa(bp, false);\n\tbnxt_hwrm_vnic_free(bp);\n\tif (bp->flags & BNXT_FLAG_CHIP_P5)\n\t\tbnxt_hwrm_vnic_ctx_free(bp);\n}\n\nstatic void bnxt_hwrm_resource_free(struct bnxt *bp, bool close_path,\n\t\t\t\t    bool irq_re_init)\n{\n\tbnxt_clear_vnic(bp);\n\tbnxt_hwrm_ring_free(bp, close_path);\n\tbnxt_hwrm_ring_grp_free(bp);\n\tif (irq_re_init) {\n\t\tbnxt_hwrm_stat_ctx_free(bp);\n\t\tbnxt_hwrm_free_tunnel_ports(bp);\n\t}\n}\n\nstatic int bnxt_hwrm_set_br_mode(struct bnxt *bp, u16 br_mode)\n{\n\tstruct hwrm_func_cfg_input *req;\n\tu8 evb_mode;\n\tint rc;\n\n\tif (br_mode == BRIDGE_MODE_VEB)\n\t\tevb_mode = FUNC_CFG_REQ_EVB_MODE_VEB;\n\telse if (br_mode == BRIDGE_MODE_VEPA)\n\t\tevb_mode = FUNC_CFG_REQ_EVB_MODE_VEPA;\n\telse\n\t\treturn -EINVAL;\n\n\trc = hwrm_req_init(bp, req, HWRM_FUNC_CFG);\n\tif (rc)\n\t\treturn rc;\n\n\treq->fid = cpu_to_le16(0xffff);\n\treq->enables = cpu_to_le32(FUNC_CFG_REQ_ENABLES_EVB_MODE);\n\treq->evb_mode = evb_mode;\n\treturn hwrm_req_send(bp, req);\n}\n\nstatic int bnxt_hwrm_set_cache_line_size(struct bnxt *bp, int size)\n{\n\tstruct hwrm_func_cfg_input *req;\n\tint rc;\n\n\tif (BNXT_VF(bp) || bp->hwrm_spec_code < 0x10803)\n\t\treturn 0;\n\n\trc = hwrm_req_init(bp, req, HWRM_FUNC_CFG);\n\tif (rc)\n\t\treturn rc;\n\n\treq->fid = cpu_to_le16(0xffff);\n\treq->enables = cpu_to_le32(FUNC_CFG_REQ_ENABLES_CACHE_LINESIZE);\n\treq->options = FUNC_CFG_REQ_OPTIONS_CACHE_LINESIZE_SIZE_64;\n\tif (size == 128)\n\t\treq->options = FUNC_CFG_REQ_OPTIONS_CACHE_LINESIZE_SIZE_128;\n\n\treturn hwrm_req_send(bp, req);\n}\n\nstatic int __bnxt_setup_vnic(struct bnxt *bp, u16 vnic_id)\n{\n\tstruct bnxt_vnic_info *vnic = &bp->vnic_info[vnic_id];\n\tint rc;\n\n\tif (vnic->flags & BNXT_VNIC_RFS_NEW_RSS_FLAG)\n\t\tgoto skip_rss_ctx;\n\n\t \n\trc = bnxt_hwrm_vnic_ctx_alloc(bp, vnic_id, 0);\n\tif (rc) {\n\t\tnetdev_err(bp->dev, \"hwrm vnic %d alloc failure rc: %x\\n\",\n\t\t\t   vnic_id, rc);\n\t\tgoto vnic_setup_err;\n\t}\n\tbp->rsscos_nr_ctxs++;\n\n\tif (BNXT_CHIP_TYPE_NITRO_A0(bp)) {\n\t\trc = bnxt_hwrm_vnic_ctx_alloc(bp, vnic_id, 1);\n\t\tif (rc) {\n\t\t\tnetdev_err(bp->dev, \"hwrm vnic %d cos ctx alloc failure rc: %x\\n\",\n\t\t\t\t   vnic_id, rc);\n\t\t\tgoto vnic_setup_err;\n\t\t}\n\t\tbp->rsscos_nr_ctxs++;\n\t}\n\nskip_rss_ctx:\n\t \n\trc = bnxt_hwrm_vnic_cfg(bp, vnic_id);\n\tif (rc) {\n\t\tnetdev_err(bp->dev, \"hwrm vnic %d cfg failure rc: %x\\n\",\n\t\t\t   vnic_id, rc);\n\t\tgoto vnic_setup_err;\n\t}\n\n\t \n\trc = bnxt_hwrm_vnic_set_rss(bp, vnic_id, true);\n\tif (rc) {\n\t\tnetdev_err(bp->dev, \"hwrm vnic %d set rss failure rc: %x\\n\",\n\t\t\t   vnic_id, rc);\n\t\tgoto vnic_setup_err;\n\t}\n\n\tif (bp->flags & BNXT_FLAG_AGG_RINGS) {\n\t\trc = bnxt_hwrm_vnic_set_hds(bp, vnic_id);\n\t\tif (rc) {\n\t\t\tnetdev_err(bp->dev, \"hwrm vnic %d set hds failure rc: %x\\n\",\n\t\t\t\t   vnic_id, rc);\n\t\t}\n\t}\n\nvnic_setup_err:\n\treturn rc;\n}\n\nstatic int __bnxt_setup_vnic_p5(struct bnxt *bp, u16 vnic_id)\n{\n\tint rc, i, nr_ctxs;\n\n\tnr_ctxs = bnxt_get_nr_rss_ctxs(bp, bp->rx_nr_rings);\n\tfor (i = 0; i < nr_ctxs; i++) {\n\t\trc = bnxt_hwrm_vnic_ctx_alloc(bp, vnic_id, i);\n\t\tif (rc) {\n\t\t\tnetdev_err(bp->dev, \"hwrm vnic %d ctx %d alloc failure rc: %x\\n\",\n\t\t\t\t   vnic_id, i, rc);\n\t\t\tbreak;\n\t\t}\n\t\tbp->rsscos_nr_ctxs++;\n\t}\n\tif (i < nr_ctxs)\n\t\treturn -ENOMEM;\n\n\trc = bnxt_hwrm_vnic_set_rss_p5(bp, vnic_id, true);\n\tif (rc) {\n\t\tnetdev_err(bp->dev, \"hwrm vnic %d set rss failure rc: %d\\n\",\n\t\t\t   vnic_id, rc);\n\t\treturn rc;\n\t}\n\trc = bnxt_hwrm_vnic_cfg(bp, vnic_id);\n\tif (rc) {\n\t\tnetdev_err(bp->dev, \"hwrm vnic %d cfg failure rc: %x\\n\",\n\t\t\t   vnic_id, rc);\n\t\treturn rc;\n\t}\n\tif (bp->flags & BNXT_FLAG_AGG_RINGS) {\n\t\trc = bnxt_hwrm_vnic_set_hds(bp, vnic_id);\n\t\tif (rc) {\n\t\t\tnetdev_err(bp->dev, \"hwrm vnic %d set hds failure rc: %x\\n\",\n\t\t\t\t   vnic_id, rc);\n\t\t}\n\t}\n\treturn rc;\n}\n\nstatic int bnxt_setup_vnic(struct bnxt *bp, u16 vnic_id)\n{\n\tif (bp->flags & BNXT_FLAG_CHIP_P5)\n\t\treturn __bnxt_setup_vnic_p5(bp, vnic_id);\n\telse\n\t\treturn __bnxt_setup_vnic(bp, vnic_id);\n}\n\nstatic int bnxt_alloc_rfs_vnics(struct bnxt *bp)\n{\n#ifdef CONFIG_RFS_ACCEL\n\tint i, rc = 0;\n\n\tif (bp->flags & BNXT_FLAG_CHIP_P5)\n\t\treturn 0;\n\n\tfor (i = 0; i < bp->rx_nr_rings; i++) {\n\t\tstruct bnxt_vnic_info *vnic;\n\t\tu16 vnic_id = i + 1;\n\t\tu16 ring_id = i;\n\n\t\tif (vnic_id >= bp->nr_vnics)\n\t\t\tbreak;\n\n\t\tvnic = &bp->vnic_info[vnic_id];\n\t\tvnic->flags |= BNXT_VNIC_RFS_FLAG;\n\t\tif (bp->flags & BNXT_FLAG_NEW_RSS_CAP)\n\t\t\tvnic->flags |= BNXT_VNIC_RFS_NEW_RSS_FLAG;\n\t\trc = bnxt_hwrm_vnic_alloc(bp, vnic_id, ring_id, 1);\n\t\tif (rc) {\n\t\t\tnetdev_err(bp->dev, \"hwrm vnic %d alloc failure rc: %x\\n\",\n\t\t\t\t   vnic_id, rc);\n\t\t\tbreak;\n\t\t}\n\t\trc = bnxt_setup_vnic(bp, vnic_id);\n\t\tif (rc)\n\t\t\tbreak;\n\t}\n\treturn rc;\n#else\n\treturn 0;\n#endif\n}\n\n \nstatic bool bnxt_promisc_ok(struct bnxt *bp)\n{\n#ifdef CONFIG_BNXT_SRIOV\n\tif (BNXT_VF(bp) && !bp->vf.vlan && !bnxt_is_trusted_vf(bp, &bp->vf))\n\t\treturn false;\n#endif\n\treturn true;\n}\n\nstatic int bnxt_setup_nitroa0_vnic(struct bnxt *bp)\n{\n\tunsigned int rc = 0;\n\n\trc = bnxt_hwrm_vnic_alloc(bp, 1, bp->rx_nr_rings - 1, 1);\n\tif (rc) {\n\t\tnetdev_err(bp->dev, \"Cannot allocate special vnic for NS2 A0: %x\\n\",\n\t\t\t   rc);\n\t\treturn rc;\n\t}\n\n\trc = bnxt_hwrm_vnic_cfg(bp, 1);\n\tif (rc) {\n\t\tnetdev_err(bp->dev, \"Cannot allocate special vnic for NS2 A0: %x\\n\",\n\t\t\t   rc);\n\t\treturn rc;\n\t}\n\treturn rc;\n}\n\nstatic int bnxt_cfg_rx_mode(struct bnxt *);\nstatic bool bnxt_mc_list_updated(struct bnxt *, u32 *);\n\nstatic int bnxt_init_chip(struct bnxt *bp, bool irq_re_init)\n{\n\tstruct bnxt_vnic_info *vnic = &bp->vnic_info[0];\n\tint rc = 0;\n\tunsigned int rx_nr_rings = bp->rx_nr_rings;\n\n\tif (irq_re_init) {\n\t\trc = bnxt_hwrm_stat_ctx_alloc(bp);\n\t\tif (rc) {\n\t\t\tnetdev_err(bp->dev, \"hwrm stat ctx alloc failure rc: %x\\n\",\n\t\t\t\t   rc);\n\t\t\tgoto err_out;\n\t\t}\n\t}\n\n\trc = bnxt_hwrm_ring_alloc(bp);\n\tif (rc) {\n\t\tnetdev_err(bp->dev, \"hwrm ring alloc failure rc: %x\\n\", rc);\n\t\tgoto err_out;\n\t}\n\n\trc = bnxt_hwrm_ring_grp_alloc(bp);\n\tif (rc) {\n\t\tnetdev_err(bp->dev, \"hwrm_ring_grp alloc failure: %x\\n\", rc);\n\t\tgoto err_out;\n\t}\n\n\tif (BNXT_CHIP_TYPE_NITRO_A0(bp))\n\t\trx_nr_rings--;\n\n\t \n\trc = bnxt_hwrm_vnic_alloc(bp, 0, 0, rx_nr_rings);\n\tif (rc) {\n\t\tnetdev_err(bp->dev, \"hwrm vnic alloc failure rc: %x\\n\", rc);\n\t\tgoto err_out;\n\t}\n\n\tif (BNXT_VF(bp))\n\t\tbnxt_hwrm_func_qcfg(bp);\n\n\trc = bnxt_setup_vnic(bp, 0);\n\tif (rc)\n\t\tgoto err_out;\n\tif (bp->fw_cap & BNXT_FW_CAP_RSS_HASH_TYPE_DELTA)\n\t\tbnxt_hwrm_update_rss_hash_cfg(bp);\n\n\tif (bp->flags & BNXT_FLAG_RFS) {\n\t\trc = bnxt_alloc_rfs_vnics(bp);\n\t\tif (rc)\n\t\t\tgoto err_out;\n\t}\n\n\tif (bp->flags & BNXT_FLAG_TPA) {\n\t\trc = bnxt_set_tpa(bp, true);\n\t\tif (rc)\n\t\t\tgoto err_out;\n\t}\n\n\tif (BNXT_VF(bp))\n\t\tbnxt_update_vf_mac(bp);\n\n\t \n\trc = bnxt_hwrm_set_vnic_filter(bp, 0, 0, bp->dev->dev_addr);\n\tif (rc) {\n\t\tif (BNXT_VF(bp) && rc == -ENODEV)\n\t\t\tnetdev_err(bp->dev, \"Cannot configure L2 filter while PF is unavailable\\n\");\n\t\telse\n\t\t\tnetdev_err(bp->dev, \"HWRM vnic filter failure rc: %x\\n\", rc);\n\t\tgoto err_out;\n\t}\n\tvnic->uc_filter_count = 1;\n\n\tvnic->rx_mask = 0;\n\tif (test_bit(BNXT_STATE_HALF_OPEN, &bp->state))\n\t\tgoto skip_rx_mask;\n\n\tif (bp->dev->flags & IFF_BROADCAST)\n\t\tvnic->rx_mask |= CFA_L2_SET_RX_MASK_REQ_MASK_BCAST;\n\n\tif (bp->dev->flags & IFF_PROMISC)\n\t\tvnic->rx_mask |= CFA_L2_SET_RX_MASK_REQ_MASK_PROMISCUOUS;\n\n\tif (bp->dev->flags & IFF_ALLMULTI) {\n\t\tvnic->rx_mask |= CFA_L2_SET_RX_MASK_REQ_MASK_ALL_MCAST;\n\t\tvnic->mc_list_count = 0;\n\t} else if (bp->dev->flags & IFF_MULTICAST) {\n\t\tu32 mask = 0;\n\n\t\tbnxt_mc_list_updated(bp, &mask);\n\t\tvnic->rx_mask |= mask;\n\t}\n\n\trc = bnxt_cfg_rx_mode(bp);\n\tif (rc)\n\t\tgoto err_out;\n\nskip_rx_mask:\n\trc = bnxt_hwrm_set_coal(bp);\n\tif (rc)\n\t\tnetdev_warn(bp->dev, \"HWRM set coalescing failure rc: %x\\n\",\n\t\t\t\trc);\n\n\tif (BNXT_CHIP_TYPE_NITRO_A0(bp)) {\n\t\trc = bnxt_setup_nitroa0_vnic(bp);\n\t\tif (rc)\n\t\t\tnetdev_err(bp->dev, \"Special vnic setup failure for NS2 A0 rc: %x\\n\",\n\t\t\t\t   rc);\n\t}\n\n\tif (BNXT_VF(bp)) {\n\t\tbnxt_hwrm_func_qcfg(bp);\n\t\tnetdev_update_features(bp->dev);\n\t}\n\n\treturn 0;\n\nerr_out:\n\tbnxt_hwrm_resource_free(bp, 0, true);\n\n\treturn rc;\n}\n\nstatic int bnxt_shutdown_nic(struct bnxt *bp, bool irq_re_init)\n{\n\tbnxt_hwrm_resource_free(bp, 1, irq_re_init);\n\treturn 0;\n}\n\nstatic int bnxt_init_nic(struct bnxt *bp, bool irq_re_init)\n{\n\tbnxt_init_cp_rings(bp);\n\tbnxt_init_rx_rings(bp);\n\tbnxt_init_tx_rings(bp);\n\tbnxt_init_ring_grps(bp, irq_re_init);\n\tbnxt_init_vnics(bp);\n\n\treturn bnxt_init_chip(bp, irq_re_init);\n}\n\nstatic int bnxt_set_real_num_queues(struct bnxt *bp)\n{\n\tint rc;\n\tstruct net_device *dev = bp->dev;\n\n\trc = netif_set_real_num_tx_queues(dev, bp->tx_nr_rings -\n\t\t\t\t\t  bp->tx_nr_rings_xdp);\n\tif (rc)\n\t\treturn rc;\n\n\trc = netif_set_real_num_rx_queues(dev, bp->rx_nr_rings);\n\tif (rc)\n\t\treturn rc;\n\n#ifdef CONFIG_RFS_ACCEL\n\tif (bp->flags & BNXT_FLAG_RFS)\n\t\tdev->rx_cpu_rmap = alloc_irq_cpu_rmap(bp->rx_nr_rings);\n#endif\n\n\treturn rc;\n}\n\nstatic int bnxt_trim_rings(struct bnxt *bp, int *rx, int *tx, int max,\n\t\t\t   bool shared)\n{\n\tint _rx = *rx, _tx = *tx;\n\n\tif (shared) {\n\t\t*rx = min_t(int, _rx, max);\n\t\t*tx = min_t(int, _tx, max);\n\t} else {\n\t\tif (max < 2)\n\t\t\treturn -ENOMEM;\n\n\t\twhile (_rx + _tx > max) {\n\t\t\tif (_rx > _tx && _rx > 1)\n\t\t\t\t_rx--;\n\t\t\telse if (_tx > 1)\n\t\t\t\t_tx--;\n\t\t}\n\t\t*rx = _rx;\n\t\t*tx = _tx;\n\t}\n\treturn 0;\n}\n\nstatic void bnxt_setup_msix(struct bnxt *bp)\n{\n\tconst int len = sizeof(bp->irq_tbl[0].name);\n\tstruct net_device *dev = bp->dev;\n\tint tcs, i;\n\n\ttcs = netdev_get_num_tc(dev);\n\tif (tcs) {\n\t\tint i, off, count;\n\n\t\tfor (i = 0; i < tcs; i++) {\n\t\t\tcount = bp->tx_nr_rings_per_tc;\n\t\t\toff = i * count;\n\t\t\tnetdev_set_tc_queue(dev, i, count, off);\n\t\t}\n\t}\n\n\tfor (i = 0; i < bp->cp_nr_rings; i++) {\n\t\tint map_idx = bnxt_cp_num_to_irq_num(bp, i);\n\t\tchar *attr;\n\n\t\tif (bp->flags & BNXT_FLAG_SHARED_RINGS)\n\t\t\tattr = \"TxRx\";\n\t\telse if (i < bp->rx_nr_rings)\n\t\t\tattr = \"rx\";\n\t\telse\n\t\t\tattr = \"tx\";\n\n\t\tsnprintf(bp->irq_tbl[map_idx].name, len, \"%s-%s-%d\", dev->name,\n\t\t\t attr, i);\n\t\tbp->irq_tbl[map_idx].handler = bnxt_msix;\n\t}\n}\n\nstatic void bnxt_setup_inta(struct bnxt *bp)\n{\n\tconst int len = sizeof(bp->irq_tbl[0].name);\n\n\tif (netdev_get_num_tc(bp->dev))\n\t\tnetdev_reset_tc(bp->dev);\n\n\tsnprintf(bp->irq_tbl[0].name, len, \"%s-%s-%d\", bp->dev->name, \"TxRx\",\n\t\t 0);\n\tbp->irq_tbl[0].handler = bnxt_inta;\n}\n\nstatic int bnxt_init_int_mode(struct bnxt *bp);\n\nstatic int bnxt_setup_int_mode(struct bnxt *bp)\n{\n\tint rc;\n\n\tif (!bp->irq_tbl) {\n\t\trc = bnxt_init_int_mode(bp);\n\t\tif (rc || !bp->irq_tbl)\n\t\t\treturn rc ?: -ENODEV;\n\t}\n\n\tif (bp->flags & BNXT_FLAG_USING_MSIX)\n\t\tbnxt_setup_msix(bp);\n\telse\n\t\tbnxt_setup_inta(bp);\n\n\trc = bnxt_set_real_num_queues(bp);\n\treturn rc;\n}\n\n#ifdef CONFIG_RFS_ACCEL\nstatic unsigned int bnxt_get_max_func_rss_ctxs(struct bnxt *bp)\n{\n\treturn bp->hw_resc.max_rsscos_ctxs;\n}\n\nstatic unsigned int bnxt_get_max_func_vnics(struct bnxt *bp)\n{\n\treturn bp->hw_resc.max_vnics;\n}\n#endif\n\nunsigned int bnxt_get_max_func_stat_ctxs(struct bnxt *bp)\n{\n\treturn bp->hw_resc.max_stat_ctxs;\n}\n\nunsigned int bnxt_get_max_func_cp_rings(struct bnxt *bp)\n{\n\treturn bp->hw_resc.max_cp_rings;\n}\n\nstatic unsigned int bnxt_get_max_func_cp_rings_for_en(struct bnxt *bp)\n{\n\tunsigned int cp = bp->hw_resc.max_cp_rings;\n\n\tif (!(bp->flags & BNXT_FLAG_CHIP_P5))\n\t\tcp -= bnxt_get_ulp_msix_num(bp);\n\n\treturn cp;\n}\n\nstatic unsigned int bnxt_get_max_func_irqs(struct bnxt *bp)\n{\n\tstruct bnxt_hw_resc *hw_resc = &bp->hw_resc;\n\n\tif (bp->flags & BNXT_FLAG_CHIP_P5)\n\t\treturn min_t(unsigned int, hw_resc->max_irqs, hw_resc->max_nqs);\n\n\treturn min_t(unsigned int, hw_resc->max_irqs, hw_resc->max_cp_rings);\n}\n\nstatic void bnxt_set_max_func_irqs(struct bnxt *bp, unsigned int max_irqs)\n{\n\tbp->hw_resc.max_irqs = max_irqs;\n}\n\nunsigned int bnxt_get_avail_cp_rings_for_en(struct bnxt *bp)\n{\n\tunsigned int cp;\n\n\tcp = bnxt_get_max_func_cp_rings_for_en(bp);\n\tif (bp->flags & BNXT_FLAG_CHIP_P5)\n\t\treturn cp - bp->rx_nr_rings - bp->tx_nr_rings;\n\telse\n\t\treturn cp - bp->cp_nr_rings;\n}\n\nunsigned int bnxt_get_avail_stat_ctxs_for_en(struct bnxt *bp)\n{\n\treturn bnxt_get_max_func_stat_ctxs(bp) - bnxt_get_func_stat_ctxs(bp);\n}\n\nint bnxt_get_avail_msix(struct bnxt *bp, int num)\n{\n\tint max_cp = bnxt_get_max_func_cp_rings(bp);\n\tint max_irq = bnxt_get_max_func_irqs(bp);\n\tint total_req = bp->cp_nr_rings + num;\n\tint max_idx, avail_msix;\n\n\tmax_idx = bp->total_irqs;\n\tif (!(bp->flags & BNXT_FLAG_CHIP_P5))\n\t\tmax_idx = min_t(int, bp->total_irqs, max_cp);\n\tavail_msix = max_idx - bp->cp_nr_rings;\n\tif (!BNXT_NEW_RM(bp) || avail_msix >= num)\n\t\treturn avail_msix;\n\n\tif (max_irq < total_req) {\n\t\tnum = max_irq - bp->cp_nr_rings;\n\t\tif (num <= 0)\n\t\t\treturn 0;\n\t}\n\treturn num;\n}\n\nstatic int bnxt_get_num_msix(struct bnxt *bp)\n{\n\tif (!BNXT_NEW_RM(bp))\n\t\treturn bnxt_get_max_func_irqs(bp);\n\n\treturn bnxt_nq_rings_in_use(bp);\n}\n\nstatic int bnxt_init_msix(struct bnxt *bp)\n{\n\tint i, total_vecs, max, rc = 0, min = 1, ulp_msix;\n\tstruct msix_entry *msix_ent;\n\n\ttotal_vecs = bnxt_get_num_msix(bp);\n\tmax = bnxt_get_max_func_irqs(bp);\n\tif (total_vecs > max)\n\t\ttotal_vecs = max;\n\n\tif (!total_vecs)\n\t\treturn 0;\n\n\tmsix_ent = kcalloc(total_vecs, sizeof(struct msix_entry), GFP_KERNEL);\n\tif (!msix_ent)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < total_vecs; i++) {\n\t\tmsix_ent[i].entry = i;\n\t\tmsix_ent[i].vector = 0;\n\t}\n\n\tif (!(bp->flags & BNXT_FLAG_SHARED_RINGS))\n\t\tmin = 2;\n\n\ttotal_vecs = pci_enable_msix_range(bp->pdev, msix_ent, min, total_vecs);\n\tulp_msix = bnxt_get_ulp_msix_num(bp);\n\tif (total_vecs < 0 || total_vecs < ulp_msix) {\n\t\trc = -ENODEV;\n\t\tgoto msix_setup_exit;\n\t}\n\n\tbp->irq_tbl = kcalloc(total_vecs, sizeof(struct bnxt_irq), GFP_KERNEL);\n\tif (bp->irq_tbl) {\n\t\tfor (i = 0; i < total_vecs; i++)\n\t\t\tbp->irq_tbl[i].vector = msix_ent[i].vector;\n\n\t\tbp->total_irqs = total_vecs;\n\t\t \n\t\trc = bnxt_trim_rings(bp, &bp->rx_nr_rings, &bp->tx_nr_rings,\n\t\t\t\t     total_vecs - ulp_msix, min == 1);\n\t\tif (rc)\n\t\t\tgoto msix_setup_exit;\n\n\t\tbp->cp_nr_rings = (min == 1) ?\n\t\t\t\t  max_t(int, bp->tx_nr_rings, bp->rx_nr_rings) :\n\t\t\t\t  bp->tx_nr_rings + bp->rx_nr_rings;\n\n\t} else {\n\t\trc = -ENOMEM;\n\t\tgoto msix_setup_exit;\n\t}\n\tbp->flags |= BNXT_FLAG_USING_MSIX;\n\tkfree(msix_ent);\n\treturn 0;\n\nmsix_setup_exit:\n\tnetdev_err(bp->dev, \"bnxt_init_msix err: %x\\n\", rc);\n\tkfree(bp->irq_tbl);\n\tbp->irq_tbl = NULL;\n\tpci_disable_msix(bp->pdev);\n\tkfree(msix_ent);\n\treturn rc;\n}\n\nstatic int bnxt_init_inta(struct bnxt *bp)\n{\n\tbp->irq_tbl = kzalloc(sizeof(struct bnxt_irq), GFP_KERNEL);\n\tif (!bp->irq_tbl)\n\t\treturn -ENOMEM;\n\n\tbp->total_irqs = 1;\n\tbp->rx_nr_rings = 1;\n\tbp->tx_nr_rings = 1;\n\tbp->cp_nr_rings = 1;\n\tbp->flags |= BNXT_FLAG_SHARED_RINGS;\n\tbp->irq_tbl[0].vector = bp->pdev->irq;\n\treturn 0;\n}\n\nstatic int bnxt_init_int_mode(struct bnxt *bp)\n{\n\tint rc = -ENODEV;\n\n\tif (bp->flags & BNXT_FLAG_MSIX_CAP)\n\t\trc = bnxt_init_msix(bp);\n\n\tif (!(bp->flags & BNXT_FLAG_USING_MSIX) && BNXT_PF(bp)) {\n\t\t \n\t\trc = bnxt_init_inta(bp);\n\t}\n\treturn rc;\n}\n\nstatic void bnxt_clear_int_mode(struct bnxt *bp)\n{\n\tif (bp->flags & BNXT_FLAG_USING_MSIX)\n\t\tpci_disable_msix(bp->pdev);\n\n\tkfree(bp->irq_tbl);\n\tbp->irq_tbl = NULL;\n\tbp->flags &= ~BNXT_FLAG_USING_MSIX;\n}\n\nint bnxt_reserve_rings(struct bnxt *bp, bool irq_re_init)\n{\n\tint tcs = netdev_get_num_tc(bp->dev);\n\tbool irq_cleared = false;\n\tint rc;\n\n\tif (!bnxt_need_reserve_rings(bp))\n\t\treturn 0;\n\n\tif (irq_re_init && BNXT_NEW_RM(bp) &&\n\t    bnxt_get_num_msix(bp) != bp->total_irqs) {\n\t\tbnxt_ulp_irq_stop(bp);\n\t\tbnxt_clear_int_mode(bp);\n\t\tirq_cleared = true;\n\t}\n\trc = __bnxt_reserve_rings(bp);\n\tif (irq_cleared) {\n\t\tif (!rc)\n\t\t\trc = bnxt_init_int_mode(bp);\n\t\tbnxt_ulp_irq_restart(bp, rc);\n\t}\n\tif (rc) {\n\t\tnetdev_err(bp->dev, \"ring reservation/IRQ init failure rc: %d\\n\", rc);\n\t\treturn rc;\n\t}\n\tif (tcs && (bp->tx_nr_rings_per_tc * tcs !=\n\t\t    bp->tx_nr_rings - bp->tx_nr_rings_xdp)) {\n\t\tnetdev_err(bp->dev, \"tx ring reservation failure\\n\");\n\t\tnetdev_reset_tc(bp->dev);\n\t\tif (bp->tx_nr_rings_xdp)\n\t\t\tbp->tx_nr_rings_per_tc = bp->tx_nr_rings_xdp;\n\t\telse\n\t\t\tbp->tx_nr_rings_per_tc = bp->tx_nr_rings;\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}\n\nstatic void bnxt_free_irq(struct bnxt *bp)\n{\n\tstruct bnxt_irq *irq;\n\tint i;\n\n#ifdef CONFIG_RFS_ACCEL\n\tfree_irq_cpu_rmap(bp->dev->rx_cpu_rmap);\n\tbp->dev->rx_cpu_rmap = NULL;\n#endif\n\tif (!bp->irq_tbl || !bp->bnapi)\n\t\treturn;\n\n\tfor (i = 0; i < bp->cp_nr_rings; i++) {\n\t\tint map_idx = bnxt_cp_num_to_irq_num(bp, i);\n\n\t\tirq = &bp->irq_tbl[map_idx];\n\t\tif (irq->requested) {\n\t\t\tif (irq->have_cpumask) {\n\t\t\t\tirq_set_affinity_hint(irq->vector, NULL);\n\t\t\t\tfree_cpumask_var(irq->cpu_mask);\n\t\t\t\tirq->have_cpumask = 0;\n\t\t\t}\n\t\t\tfree_irq(irq->vector, bp->bnapi[i]);\n\t\t}\n\n\t\tirq->requested = 0;\n\t}\n}\n\nstatic int bnxt_request_irq(struct bnxt *bp)\n{\n\tint i, j, rc = 0;\n\tunsigned long flags = 0;\n#ifdef CONFIG_RFS_ACCEL\n\tstruct cpu_rmap *rmap;\n#endif\n\n\trc = bnxt_setup_int_mode(bp);\n\tif (rc) {\n\t\tnetdev_err(bp->dev, \"bnxt_setup_int_mode err: %x\\n\",\n\t\t\t   rc);\n\t\treturn rc;\n\t}\n#ifdef CONFIG_RFS_ACCEL\n\trmap = bp->dev->rx_cpu_rmap;\n#endif\n\tif (!(bp->flags & BNXT_FLAG_USING_MSIX))\n\t\tflags = IRQF_SHARED;\n\n\tfor (i = 0, j = 0; i < bp->cp_nr_rings; i++) {\n\t\tint map_idx = bnxt_cp_num_to_irq_num(bp, i);\n\t\tstruct bnxt_irq *irq = &bp->irq_tbl[map_idx];\n\n#ifdef CONFIG_RFS_ACCEL\n\t\tif (rmap && bp->bnapi[i]->rx_ring) {\n\t\t\trc = irq_cpu_rmap_add(rmap, irq->vector);\n\t\t\tif (rc)\n\t\t\t\tnetdev_warn(bp->dev, \"failed adding irq rmap for ring %d\\n\",\n\t\t\t\t\t    j);\n\t\t\tj++;\n\t\t}\n#endif\n\t\trc = request_irq(irq->vector, irq->handler, flags, irq->name,\n\t\t\t\t bp->bnapi[i]);\n\t\tif (rc)\n\t\t\tbreak;\n\n\t\tirq->requested = 1;\n\n\t\tif (zalloc_cpumask_var(&irq->cpu_mask, GFP_KERNEL)) {\n\t\t\tint numa_node = dev_to_node(&bp->pdev->dev);\n\n\t\t\tirq->have_cpumask = 1;\n\t\t\tcpumask_set_cpu(cpumask_local_spread(i, numa_node),\n\t\t\t\t\tirq->cpu_mask);\n\t\t\trc = irq_set_affinity_hint(irq->vector, irq->cpu_mask);\n\t\t\tif (rc) {\n\t\t\t\tnetdev_warn(bp->dev,\n\t\t\t\t\t    \"Set affinity failed, IRQ = %d\\n\",\n\t\t\t\t\t    irq->vector);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn rc;\n}\n\nstatic void bnxt_del_napi(struct bnxt *bp)\n{\n\tint i;\n\n\tif (!bp->bnapi)\n\t\treturn;\n\n\tfor (i = 0; i < bp->cp_nr_rings; i++) {\n\t\tstruct bnxt_napi *bnapi = bp->bnapi[i];\n\n\t\t__netif_napi_del(&bnapi->napi);\n\t}\n\t \n\tsynchronize_net();\n}\n\nstatic void bnxt_init_napi(struct bnxt *bp)\n{\n\tint i;\n\tunsigned int cp_nr_rings = bp->cp_nr_rings;\n\tstruct bnxt_napi *bnapi;\n\n\tif (bp->flags & BNXT_FLAG_USING_MSIX) {\n\t\tint (*poll_fn)(struct napi_struct *, int) = bnxt_poll;\n\n\t\tif (bp->flags & BNXT_FLAG_CHIP_P5)\n\t\t\tpoll_fn = bnxt_poll_p5;\n\t\telse if (BNXT_CHIP_TYPE_NITRO_A0(bp))\n\t\t\tcp_nr_rings--;\n\t\tfor (i = 0; i < cp_nr_rings; i++) {\n\t\t\tbnapi = bp->bnapi[i];\n\t\t\tnetif_napi_add(bp->dev, &bnapi->napi, poll_fn);\n\t\t}\n\t\tif (BNXT_CHIP_TYPE_NITRO_A0(bp)) {\n\t\t\tbnapi = bp->bnapi[cp_nr_rings];\n\t\t\tnetif_napi_add(bp->dev, &bnapi->napi,\n\t\t\t\t       bnxt_poll_nitroa0);\n\t\t}\n\t} else {\n\t\tbnapi = bp->bnapi[0];\n\t\tnetif_napi_add(bp->dev, &bnapi->napi, bnxt_poll);\n\t}\n}\n\nstatic void bnxt_disable_napi(struct bnxt *bp)\n{\n\tint i;\n\n\tif (!bp->bnapi ||\n\t    test_and_set_bit(BNXT_STATE_NAPI_DISABLED, &bp->state))\n\t\treturn;\n\n\tfor (i = 0; i < bp->cp_nr_rings; i++) {\n\t\tstruct bnxt_napi *bnapi = bp->bnapi[i];\n\t\tstruct bnxt_cp_ring_info *cpr;\n\n\t\tcpr = &bnapi->cp_ring;\n\t\tif (bnapi->tx_fault)\n\t\t\tcpr->sw_stats.tx.tx_resets++;\n\t\tif (bnapi->in_reset)\n\t\t\tcpr->sw_stats.rx.rx_resets++;\n\t\tnapi_disable(&bnapi->napi);\n\t\tif (bnapi->rx_ring)\n\t\t\tcancel_work_sync(&cpr->dim.work);\n\t}\n}\n\nstatic void bnxt_enable_napi(struct bnxt *bp)\n{\n\tint i;\n\n\tclear_bit(BNXT_STATE_NAPI_DISABLED, &bp->state);\n\tfor (i = 0; i < bp->cp_nr_rings; i++) {\n\t\tstruct bnxt_napi *bnapi = bp->bnapi[i];\n\t\tstruct bnxt_cp_ring_info *cpr;\n\n\t\tbnapi->tx_fault = 0;\n\n\t\tcpr = &bnapi->cp_ring;\n\t\tbnapi->in_reset = false;\n\n\t\tbnapi->tx_pkts = 0;\n\n\t\tif (bnapi->rx_ring) {\n\t\t\tINIT_WORK(&cpr->dim.work, bnxt_dim_work);\n\t\t\tcpr->dim.mode = DIM_CQ_PERIOD_MODE_START_FROM_EQE;\n\t\t}\n\t\tnapi_enable(&bnapi->napi);\n\t}\n}\n\nvoid bnxt_tx_disable(struct bnxt *bp)\n{\n\tint i;\n\tstruct bnxt_tx_ring_info *txr;\n\n\tif (bp->tx_ring) {\n\t\tfor (i = 0; i < bp->tx_nr_rings; i++) {\n\t\t\ttxr = &bp->tx_ring[i];\n\t\t\tWRITE_ONCE(txr->dev_state, BNXT_DEV_STATE_CLOSING);\n\t\t}\n\t}\n\t \n\tsynchronize_net();\n\t \n\tnetif_carrier_off(bp->dev);\n\t \n\tnetif_tx_disable(bp->dev);\n}\n\nvoid bnxt_tx_enable(struct bnxt *bp)\n{\n\tint i;\n\tstruct bnxt_tx_ring_info *txr;\n\n\tfor (i = 0; i < bp->tx_nr_rings; i++) {\n\t\ttxr = &bp->tx_ring[i];\n\t\tWRITE_ONCE(txr->dev_state, 0);\n\t}\n\t \n\tsynchronize_net();\n\tnetif_tx_wake_all_queues(bp->dev);\n\tif (BNXT_LINK_IS_UP(bp))\n\t\tnetif_carrier_on(bp->dev);\n}\n\nstatic char *bnxt_report_fec(struct bnxt_link_info *link_info)\n{\n\tu8 active_fec = link_info->active_fec_sig_mode &\n\t\t\tPORT_PHY_QCFG_RESP_ACTIVE_FEC_MASK;\n\n\tswitch (active_fec) {\n\tdefault:\n\tcase PORT_PHY_QCFG_RESP_ACTIVE_FEC_FEC_NONE_ACTIVE:\n\t\treturn \"None\";\n\tcase PORT_PHY_QCFG_RESP_ACTIVE_FEC_FEC_CLAUSE74_ACTIVE:\n\t\treturn \"Clause 74 BaseR\";\n\tcase PORT_PHY_QCFG_RESP_ACTIVE_FEC_FEC_CLAUSE91_ACTIVE:\n\t\treturn \"Clause 91 RS(528,514)\";\n\tcase PORT_PHY_QCFG_RESP_ACTIVE_FEC_FEC_RS544_1XN_ACTIVE:\n\t\treturn \"Clause 91 RS544_1XN\";\n\tcase PORT_PHY_QCFG_RESP_ACTIVE_FEC_FEC_RS544_IEEE_ACTIVE:\n\t\treturn \"Clause 91 RS(544,514)\";\n\tcase PORT_PHY_QCFG_RESP_ACTIVE_FEC_FEC_RS272_1XN_ACTIVE:\n\t\treturn \"Clause 91 RS272_1XN\";\n\tcase PORT_PHY_QCFG_RESP_ACTIVE_FEC_FEC_RS272_IEEE_ACTIVE:\n\t\treturn \"Clause 91 RS(272,257)\";\n\t}\n}\n\nvoid bnxt_report_link(struct bnxt *bp)\n{\n\tif (BNXT_LINK_IS_UP(bp)) {\n\t\tconst char *signal = \"\";\n\t\tconst char *flow_ctrl;\n\t\tconst char *duplex;\n\t\tu32 speed;\n\t\tu16 fec;\n\n\t\tnetif_carrier_on(bp->dev);\n\t\tspeed = bnxt_fw_to_ethtool_speed(bp->link_info.link_speed);\n\t\tif (speed == SPEED_UNKNOWN) {\n\t\t\tnetdev_info(bp->dev, \"NIC Link is Up, speed unknown\\n\");\n\t\t\treturn;\n\t\t}\n\t\tif (bp->link_info.duplex == BNXT_LINK_DUPLEX_FULL)\n\t\t\tduplex = \"full\";\n\t\telse\n\t\t\tduplex = \"half\";\n\t\tif (bp->link_info.pause == BNXT_LINK_PAUSE_BOTH)\n\t\t\tflow_ctrl = \"ON - receive & transmit\";\n\t\telse if (bp->link_info.pause == BNXT_LINK_PAUSE_TX)\n\t\t\tflow_ctrl = \"ON - transmit\";\n\t\telse if (bp->link_info.pause == BNXT_LINK_PAUSE_RX)\n\t\t\tflow_ctrl = \"ON - receive\";\n\t\telse\n\t\t\tflow_ctrl = \"none\";\n\t\tif (bp->link_info.phy_qcfg_resp.option_flags &\n\t\t    PORT_PHY_QCFG_RESP_OPTION_FLAGS_SIGNAL_MODE_KNOWN) {\n\t\t\tu8 sig_mode = bp->link_info.active_fec_sig_mode &\n\t\t\t\t      PORT_PHY_QCFG_RESP_SIGNAL_MODE_MASK;\n\t\t\tswitch (sig_mode) {\n\t\t\tcase PORT_PHY_QCFG_RESP_SIGNAL_MODE_NRZ:\n\t\t\t\tsignal = \"(NRZ) \";\n\t\t\t\tbreak;\n\t\t\tcase PORT_PHY_QCFG_RESP_SIGNAL_MODE_PAM4:\n\t\t\t\tsignal = \"(PAM4) \";\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tnetdev_info(bp->dev, \"NIC Link is Up, %u Mbps %s%s duplex, Flow control: %s\\n\",\n\t\t\t    speed, signal, duplex, flow_ctrl);\n\t\tif (bp->phy_flags & BNXT_PHY_FL_EEE_CAP)\n\t\t\tnetdev_info(bp->dev, \"EEE is %s\\n\",\n\t\t\t\t    bp->eee.eee_active ? \"active\" :\n\t\t\t\t\t\t\t \"not active\");\n\t\tfec = bp->link_info.fec_cfg;\n\t\tif (!(fec & PORT_PHY_QCFG_RESP_FEC_CFG_FEC_NONE_SUPPORTED))\n\t\t\tnetdev_info(bp->dev, \"FEC autoneg %s encoding: %s\\n\",\n\t\t\t\t    (fec & BNXT_FEC_AUTONEG) ? \"on\" : \"off\",\n\t\t\t\t    bnxt_report_fec(&bp->link_info));\n\t} else {\n\t\tnetif_carrier_off(bp->dev);\n\t\tnetdev_err(bp->dev, \"NIC Link is Down\\n\");\n\t}\n}\n\nstatic bool bnxt_phy_qcaps_no_speed(struct hwrm_port_phy_qcaps_output *resp)\n{\n\tif (!resp->supported_speeds_auto_mode &&\n\t    !resp->supported_speeds_force_mode &&\n\t    !resp->supported_pam4_speeds_auto_mode &&\n\t    !resp->supported_pam4_speeds_force_mode)\n\t\treturn true;\n\treturn false;\n}\n\nstatic int bnxt_hwrm_phy_qcaps(struct bnxt *bp)\n{\n\tstruct bnxt_link_info *link_info = &bp->link_info;\n\tstruct hwrm_port_phy_qcaps_output *resp;\n\tstruct hwrm_port_phy_qcaps_input *req;\n\tint rc = 0;\n\n\tif (bp->hwrm_spec_code < 0x10201)\n\t\treturn 0;\n\n\trc = hwrm_req_init(bp, req, HWRM_PORT_PHY_QCAPS);\n\tif (rc)\n\t\treturn rc;\n\n\tresp = hwrm_req_hold(bp, req);\n\trc = hwrm_req_send(bp, req);\n\tif (rc)\n\t\tgoto hwrm_phy_qcaps_exit;\n\n\tbp->phy_flags = resp->flags | (le16_to_cpu(resp->flags2) << 8);\n\tif (resp->flags & PORT_PHY_QCAPS_RESP_FLAGS_EEE_SUPPORTED) {\n\t\tstruct ethtool_eee *eee = &bp->eee;\n\t\tu16 fw_speeds = le16_to_cpu(resp->supported_speeds_eee_mode);\n\n\t\teee->supported = _bnxt_fw_to_ethtool_adv_spds(fw_speeds, 0);\n\t\tbp->lpi_tmr_lo = le32_to_cpu(resp->tx_lpi_timer_low) &\n\t\t\t\t PORT_PHY_QCAPS_RESP_TX_LPI_TIMER_LOW_MASK;\n\t\tbp->lpi_tmr_hi = le32_to_cpu(resp->valid_tx_lpi_timer_high) &\n\t\t\t\t PORT_PHY_QCAPS_RESP_TX_LPI_TIMER_HIGH_MASK;\n\t}\n\n\tif (bp->hwrm_spec_code >= 0x10a01) {\n\t\tif (bnxt_phy_qcaps_no_speed(resp)) {\n\t\t\tlink_info->phy_state = BNXT_PHY_STATE_DISABLED;\n\t\t\tnetdev_warn(bp->dev, \"Ethernet link disabled\\n\");\n\t\t} else if (link_info->phy_state == BNXT_PHY_STATE_DISABLED) {\n\t\t\tlink_info->phy_state = BNXT_PHY_STATE_ENABLED;\n\t\t\tnetdev_info(bp->dev, \"Ethernet link enabled\\n\");\n\t\t\t \n\t\t\tlink_info->support_auto_speeds = 0;\n\t\t\tlink_info->support_pam4_auto_speeds = 0;\n\t\t}\n\t}\n\tif (resp->supported_speeds_auto_mode)\n\t\tlink_info->support_auto_speeds =\n\t\t\tle16_to_cpu(resp->supported_speeds_auto_mode);\n\tif (resp->supported_pam4_speeds_auto_mode)\n\t\tlink_info->support_pam4_auto_speeds =\n\t\t\tle16_to_cpu(resp->supported_pam4_speeds_auto_mode);\n\n\tbp->port_count = resp->port_cnt;\n\nhwrm_phy_qcaps_exit:\n\thwrm_req_drop(bp, req);\n\treturn rc;\n}\n\nstatic bool bnxt_support_dropped(u16 advertising, u16 supported)\n{\n\tu16 diff = advertising ^ supported;\n\n\treturn ((supported | diff) != supported);\n}\n\nint bnxt_update_link(struct bnxt *bp, bool chng_link_state)\n{\n\tstruct bnxt_link_info *link_info = &bp->link_info;\n\tstruct hwrm_port_phy_qcfg_output *resp;\n\tstruct hwrm_port_phy_qcfg_input *req;\n\tu8 link_state = link_info->link_state;\n\tbool support_changed = false;\n\tint rc;\n\n\trc = hwrm_req_init(bp, req, HWRM_PORT_PHY_QCFG);\n\tif (rc)\n\t\treturn rc;\n\n\tresp = hwrm_req_hold(bp, req);\n\trc = hwrm_req_send(bp, req);\n\tif (rc) {\n\t\thwrm_req_drop(bp, req);\n\t\tif (BNXT_VF(bp) && rc == -ENODEV) {\n\t\t\tnetdev_warn(bp->dev, \"Cannot obtain link state while PF unavailable.\\n\");\n\t\t\trc = 0;\n\t\t}\n\t\treturn rc;\n\t}\n\n\tmemcpy(&link_info->phy_qcfg_resp, resp, sizeof(*resp));\n\tlink_info->phy_link_status = resp->link;\n\tlink_info->duplex = resp->duplex_cfg;\n\tif (bp->hwrm_spec_code >= 0x10800)\n\t\tlink_info->duplex = resp->duplex_state;\n\tlink_info->pause = resp->pause;\n\tlink_info->auto_mode = resp->auto_mode;\n\tlink_info->auto_pause_setting = resp->auto_pause;\n\tlink_info->lp_pause = resp->link_partner_adv_pause;\n\tlink_info->force_pause_setting = resp->force_pause;\n\tlink_info->duplex_setting = resp->duplex_cfg;\n\tif (link_info->phy_link_status == BNXT_LINK_LINK)\n\t\tlink_info->link_speed = le16_to_cpu(resp->link_speed);\n\telse\n\t\tlink_info->link_speed = 0;\n\tlink_info->force_link_speed = le16_to_cpu(resp->force_link_speed);\n\tlink_info->force_pam4_link_speed =\n\t\tle16_to_cpu(resp->force_pam4_link_speed);\n\tlink_info->support_speeds = le16_to_cpu(resp->support_speeds);\n\tlink_info->support_pam4_speeds = le16_to_cpu(resp->support_pam4_speeds);\n\tlink_info->auto_link_speeds = le16_to_cpu(resp->auto_link_speed_mask);\n\tlink_info->auto_pam4_link_speeds =\n\t\tle16_to_cpu(resp->auto_pam4_link_speed_mask);\n\tlink_info->lp_auto_link_speeds =\n\t\tle16_to_cpu(resp->link_partner_adv_speeds);\n\tlink_info->lp_auto_pam4_link_speeds =\n\t\tresp->link_partner_pam4_adv_speeds;\n\tlink_info->preemphasis = le32_to_cpu(resp->preemphasis);\n\tlink_info->phy_ver[0] = resp->phy_maj;\n\tlink_info->phy_ver[1] = resp->phy_min;\n\tlink_info->phy_ver[2] = resp->phy_bld;\n\tlink_info->media_type = resp->media_type;\n\tlink_info->phy_type = resp->phy_type;\n\tlink_info->transceiver = resp->xcvr_pkg_type;\n\tlink_info->phy_addr = resp->eee_config_phy_addr &\n\t\t\t      PORT_PHY_QCFG_RESP_PHY_ADDR_MASK;\n\tlink_info->module_status = resp->module_status;\n\n\tif (bp->phy_flags & BNXT_PHY_FL_EEE_CAP) {\n\t\tstruct ethtool_eee *eee = &bp->eee;\n\t\tu16 fw_speeds;\n\n\t\teee->eee_active = 0;\n\t\tif (resp->eee_config_phy_addr &\n\t\t    PORT_PHY_QCFG_RESP_EEE_CONFIG_EEE_ACTIVE) {\n\t\t\teee->eee_active = 1;\n\t\t\tfw_speeds = le16_to_cpu(\n\t\t\t\tresp->link_partner_adv_eee_link_speed_mask);\n\t\t\teee->lp_advertised =\n\t\t\t\t_bnxt_fw_to_ethtool_adv_spds(fw_speeds, 0);\n\t\t}\n\n\t\t \n\t\tif (!chng_link_state) {\n\t\t\tif (resp->eee_config_phy_addr &\n\t\t\t    PORT_PHY_QCFG_RESP_EEE_CONFIG_EEE_ENABLED)\n\t\t\t\teee->eee_enabled = 1;\n\n\t\t\tfw_speeds = le16_to_cpu(resp->adv_eee_link_speed_mask);\n\t\t\teee->advertised =\n\t\t\t\t_bnxt_fw_to_ethtool_adv_spds(fw_speeds, 0);\n\n\t\t\tif (resp->eee_config_phy_addr &\n\t\t\t    PORT_PHY_QCFG_RESP_EEE_CONFIG_EEE_TX_LPI) {\n\t\t\t\t__le32 tmr;\n\n\t\t\t\teee->tx_lpi_enabled = 1;\n\t\t\t\ttmr = resp->xcvr_identifier_type_tx_lpi_timer;\n\t\t\t\teee->tx_lpi_timer = le32_to_cpu(tmr) &\n\t\t\t\t\tPORT_PHY_QCFG_RESP_TX_LPI_TIMER_MASK;\n\t\t\t}\n\t\t}\n\t}\n\n\tlink_info->fec_cfg = PORT_PHY_QCFG_RESP_FEC_CFG_FEC_NONE_SUPPORTED;\n\tif (bp->hwrm_spec_code >= 0x10504) {\n\t\tlink_info->fec_cfg = le16_to_cpu(resp->fec_cfg);\n\t\tlink_info->active_fec_sig_mode = resp->active_fec_signal_mode;\n\t}\n\t \n\tif (chng_link_state) {\n\t\tif (link_info->phy_link_status == BNXT_LINK_LINK)\n\t\t\tlink_info->link_state = BNXT_LINK_STATE_UP;\n\t\telse\n\t\t\tlink_info->link_state = BNXT_LINK_STATE_DOWN;\n\t\tif (link_state != link_info->link_state)\n\t\t\tbnxt_report_link(bp);\n\t} else {\n\t\t \n\t\tlink_info->link_state = BNXT_LINK_STATE_DOWN;\n\t}\n\thwrm_req_drop(bp, req);\n\n\tif (!BNXT_PHY_CFG_ABLE(bp))\n\t\treturn 0;\n\n\t \n\tif (bnxt_support_dropped(link_info->advertising,\n\t\t\t\t link_info->support_auto_speeds)) {\n\t\tlink_info->advertising = link_info->support_auto_speeds;\n\t\tsupport_changed = true;\n\t}\n\tif (bnxt_support_dropped(link_info->advertising_pam4,\n\t\t\t\t link_info->support_pam4_auto_speeds)) {\n\t\tlink_info->advertising_pam4 = link_info->support_pam4_auto_speeds;\n\t\tsupport_changed = true;\n\t}\n\tif (support_changed && (link_info->autoneg & BNXT_AUTONEG_SPEED))\n\t\tbnxt_hwrm_set_link_setting(bp, true, false);\n\treturn 0;\n}\n\nstatic void bnxt_get_port_module_status(struct bnxt *bp)\n{\n\tstruct bnxt_link_info *link_info = &bp->link_info;\n\tstruct hwrm_port_phy_qcfg_output *resp = &link_info->phy_qcfg_resp;\n\tu8 module_status;\n\n\tif (bnxt_update_link(bp, true))\n\t\treturn;\n\n\tmodule_status = link_info->module_status;\n\tswitch (module_status) {\n\tcase PORT_PHY_QCFG_RESP_MODULE_STATUS_DISABLETX:\n\tcase PORT_PHY_QCFG_RESP_MODULE_STATUS_PWRDOWN:\n\tcase PORT_PHY_QCFG_RESP_MODULE_STATUS_WARNINGMSG:\n\t\tnetdev_warn(bp->dev, \"Unqualified SFP+ module detected on port %d\\n\",\n\t\t\t    bp->pf.port_id);\n\t\tif (bp->hwrm_spec_code >= 0x10201) {\n\t\t\tnetdev_warn(bp->dev, \"Module part number %s\\n\",\n\t\t\t\t    resp->phy_vendor_partnumber);\n\t\t}\n\t\tif (module_status == PORT_PHY_QCFG_RESP_MODULE_STATUS_DISABLETX)\n\t\t\tnetdev_warn(bp->dev, \"TX is disabled\\n\");\n\t\tif (module_status == PORT_PHY_QCFG_RESP_MODULE_STATUS_PWRDOWN)\n\t\t\tnetdev_warn(bp->dev, \"SFP+ module is shutdown\\n\");\n\t}\n}\n\nstatic void\nbnxt_hwrm_set_pause_common(struct bnxt *bp, struct hwrm_port_phy_cfg_input *req)\n{\n\tif (bp->link_info.autoneg & BNXT_AUTONEG_FLOW_CTRL) {\n\t\tif (bp->hwrm_spec_code >= 0x10201)\n\t\t\treq->auto_pause =\n\t\t\t\tPORT_PHY_CFG_REQ_AUTO_PAUSE_AUTONEG_PAUSE;\n\t\tif (bp->link_info.req_flow_ctrl & BNXT_LINK_PAUSE_RX)\n\t\t\treq->auto_pause |= PORT_PHY_CFG_REQ_AUTO_PAUSE_RX;\n\t\tif (bp->link_info.req_flow_ctrl & BNXT_LINK_PAUSE_TX)\n\t\t\treq->auto_pause |= PORT_PHY_CFG_REQ_AUTO_PAUSE_TX;\n\t\treq->enables |=\n\t\t\tcpu_to_le32(PORT_PHY_CFG_REQ_ENABLES_AUTO_PAUSE);\n\t} else {\n\t\tif (bp->link_info.req_flow_ctrl & BNXT_LINK_PAUSE_RX)\n\t\t\treq->force_pause |= PORT_PHY_CFG_REQ_FORCE_PAUSE_RX;\n\t\tif (bp->link_info.req_flow_ctrl & BNXT_LINK_PAUSE_TX)\n\t\t\treq->force_pause |= PORT_PHY_CFG_REQ_FORCE_PAUSE_TX;\n\t\treq->enables |=\n\t\t\tcpu_to_le32(PORT_PHY_CFG_REQ_ENABLES_FORCE_PAUSE);\n\t\tif (bp->hwrm_spec_code >= 0x10201) {\n\t\t\treq->auto_pause = req->force_pause;\n\t\t\treq->enables |= cpu_to_le32(\n\t\t\t\tPORT_PHY_CFG_REQ_ENABLES_AUTO_PAUSE);\n\t\t}\n\t}\n}\n\nstatic void bnxt_hwrm_set_link_common(struct bnxt *bp, struct hwrm_port_phy_cfg_input *req)\n{\n\tif (bp->link_info.autoneg & BNXT_AUTONEG_SPEED) {\n\t\treq->auto_mode |= PORT_PHY_CFG_REQ_AUTO_MODE_SPEED_MASK;\n\t\tif (bp->link_info.advertising) {\n\t\t\treq->enables |= cpu_to_le32(PORT_PHY_CFG_REQ_ENABLES_AUTO_LINK_SPEED_MASK);\n\t\t\treq->auto_link_speed_mask = cpu_to_le16(bp->link_info.advertising);\n\t\t}\n\t\tif (bp->link_info.advertising_pam4) {\n\t\t\treq->enables |=\n\t\t\t\tcpu_to_le32(PORT_PHY_CFG_REQ_ENABLES_AUTO_PAM4_LINK_SPEED_MASK);\n\t\t\treq->auto_link_pam4_speed_mask =\n\t\t\t\tcpu_to_le16(bp->link_info.advertising_pam4);\n\t\t}\n\t\treq->enables |= cpu_to_le32(PORT_PHY_CFG_REQ_ENABLES_AUTO_MODE);\n\t\treq->flags |= cpu_to_le32(PORT_PHY_CFG_REQ_FLAGS_RESTART_AUTONEG);\n\t} else {\n\t\treq->flags |= cpu_to_le32(PORT_PHY_CFG_REQ_FLAGS_FORCE);\n\t\tif (bp->link_info.req_signal_mode == BNXT_SIG_MODE_PAM4) {\n\t\t\treq->force_pam4_link_speed = cpu_to_le16(bp->link_info.req_link_speed);\n\t\t\treq->enables |= cpu_to_le32(PORT_PHY_CFG_REQ_ENABLES_FORCE_PAM4_LINK_SPEED);\n\t\t} else {\n\t\t\treq->force_link_speed = cpu_to_le16(bp->link_info.req_link_speed);\n\t\t}\n\t}\n\n\t \n\treq->flags |= cpu_to_le32(PORT_PHY_CFG_REQ_FLAGS_RESET_PHY);\n}\n\nint bnxt_hwrm_set_pause(struct bnxt *bp)\n{\n\tstruct hwrm_port_phy_cfg_input *req;\n\tint rc;\n\n\trc = hwrm_req_init(bp, req, HWRM_PORT_PHY_CFG);\n\tif (rc)\n\t\treturn rc;\n\n\tbnxt_hwrm_set_pause_common(bp, req);\n\n\tif ((bp->link_info.autoneg & BNXT_AUTONEG_FLOW_CTRL) ||\n\t    bp->link_info.force_link_chng)\n\t\tbnxt_hwrm_set_link_common(bp, req);\n\n\trc = hwrm_req_send(bp, req);\n\tif (!rc && !(bp->link_info.autoneg & BNXT_AUTONEG_FLOW_CTRL)) {\n\t\t \n\t\tbp->link_info.pause =\n\t\tbp->link_info.force_pause_setting = bp->link_info.req_flow_ctrl;\n\t\tbp->link_info.auto_pause_setting = 0;\n\t\tif (!bp->link_info.force_link_chng)\n\t\t\tbnxt_report_link(bp);\n\t}\n\tbp->link_info.force_link_chng = false;\n\treturn rc;\n}\n\nstatic void bnxt_hwrm_set_eee(struct bnxt *bp,\n\t\t\t      struct hwrm_port_phy_cfg_input *req)\n{\n\tstruct ethtool_eee *eee = &bp->eee;\n\n\tif (eee->eee_enabled) {\n\t\tu16 eee_speeds;\n\t\tu32 flags = PORT_PHY_CFG_REQ_FLAGS_EEE_ENABLE;\n\n\t\tif (eee->tx_lpi_enabled)\n\t\t\tflags |= PORT_PHY_CFG_REQ_FLAGS_EEE_TX_LPI_ENABLE;\n\t\telse\n\t\t\tflags |= PORT_PHY_CFG_REQ_FLAGS_EEE_TX_LPI_DISABLE;\n\n\t\treq->flags |= cpu_to_le32(flags);\n\t\teee_speeds = bnxt_get_fw_auto_link_speeds(eee->advertised);\n\t\treq->eee_link_speed_mask = cpu_to_le16(eee_speeds);\n\t\treq->tx_lpi_timer = cpu_to_le32(eee->tx_lpi_timer);\n\t} else {\n\t\treq->flags |= cpu_to_le32(PORT_PHY_CFG_REQ_FLAGS_EEE_DISABLE);\n\t}\n}\n\nint bnxt_hwrm_set_link_setting(struct bnxt *bp, bool set_pause, bool set_eee)\n{\n\tstruct hwrm_port_phy_cfg_input *req;\n\tint rc;\n\n\trc = hwrm_req_init(bp, req, HWRM_PORT_PHY_CFG);\n\tif (rc)\n\t\treturn rc;\n\n\tif (set_pause)\n\t\tbnxt_hwrm_set_pause_common(bp, req);\n\n\tbnxt_hwrm_set_link_common(bp, req);\n\n\tif (set_eee)\n\t\tbnxt_hwrm_set_eee(bp, req);\n\treturn hwrm_req_send(bp, req);\n}\n\nstatic int bnxt_hwrm_shutdown_link(struct bnxt *bp)\n{\n\tstruct hwrm_port_phy_cfg_input *req;\n\tint rc;\n\n\tif (!BNXT_SINGLE_PF(bp))\n\t\treturn 0;\n\n\tif (pci_num_vf(bp->pdev) &&\n\t    !(bp->phy_flags & BNXT_PHY_FL_FW_MANAGED_LKDN))\n\t\treturn 0;\n\n\trc = hwrm_req_init(bp, req, HWRM_PORT_PHY_CFG);\n\tif (rc)\n\t\treturn rc;\n\n\treq->flags = cpu_to_le32(PORT_PHY_CFG_REQ_FLAGS_FORCE_LINK_DWN);\n\trc = hwrm_req_send(bp, req);\n\tif (!rc) {\n\t\tmutex_lock(&bp->link_lock);\n\t\t \n\t\tbp->link_info.link_state = BNXT_LINK_STATE_UNKNOWN;\n\t\tmutex_unlock(&bp->link_lock);\n\t}\n\treturn rc;\n}\n\nstatic int bnxt_fw_reset_via_optee(struct bnxt *bp)\n{\n#ifdef CONFIG_TEE_BNXT_FW\n\tint rc = tee_bnxt_fw_load();\n\n\tif (rc)\n\t\tnetdev_err(bp->dev, \"Failed FW reset via OP-TEE, rc=%d\\n\", rc);\n\n\treturn rc;\n#else\n\tnetdev_err(bp->dev, \"OP-TEE not supported\\n\");\n\treturn -ENODEV;\n#endif\n}\n\nstatic int bnxt_try_recover_fw(struct bnxt *bp)\n{\n\tif (bp->fw_health && bp->fw_health->status_reliable) {\n\t\tint retry = 0, rc;\n\t\tu32 sts;\n\n\t\tdo {\n\t\t\tsts = bnxt_fw_health_readl(bp, BNXT_FW_HEALTH_REG);\n\t\t\trc = bnxt_hwrm_poll(bp);\n\t\t\tif (!BNXT_FW_IS_BOOTING(sts) &&\n\t\t\t    !BNXT_FW_IS_RECOVERING(sts))\n\t\t\t\tbreak;\n\t\t\tretry++;\n\t\t} while (rc == -EBUSY && retry < BNXT_FW_RETRY);\n\n\t\tif (!BNXT_FW_IS_HEALTHY(sts)) {\n\t\t\tnetdev_err(bp->dev,\n\t\t\t\t   \"Firmware not responding, status: 0x%x\\n\",\n\t\t\t\t   sts);\n\t\t\trc = -ENODEV;\n\t\t}\n\t\tif (sts & FW_STATUS_REG_CRASHED_NO_MASTER) {\n\t\t\tnetdev_warn(bp->dev, \"Firmware recover via OP-TEE requested\\n\");\n\t\t\treturn bnxt_fw_reset_via_optee(bp);\n\t\t}\n\t\treturn rc;\n\t}\n\n\treturn -ENODEV;\n}\n\nstatic void bnxt_clear_reservations(struct bnxt *bp, bool fw_reset)\n{\n\tstruct bnxt_hw_resc *hw_resc = &bp->hw_resc;\n\n\tif (!BNXT_NEW_RM(bp))\n\t\treturn;  \n\n\thw_resc->resv_cp_rings = 0;\n\thw_resc->resv_stat_ctxs = 0;\n\thw_resc->resv_irqs = 0;\n\thw_resc->resv_tx_rings = 0;\n\thw_resc->resv_rx_rings = 0;\n\thw_resc->resv_hw_ring_grps = 0;\n\thw_resc->resv_vnics = 0;\n\tif (!fw_reset) {\n\t\tbp->tx_nr_rings = 0;\n\t\tbp->rx_nr_rings = 0;\n\t}\n}\n\nint bnxt_cancel_reservations(struct bnxt *bp, bool fw_reset)\n{\n\tint rc;\n\n\tif (!BNXT_NEW_RM(bp))\n\t\treturn 0;  \n\n\trc = bnxt_hwrm_func_resc_qcaps(bp, true);\n\tif (rc)\n\t\tnetdev_err(bp->dev, \"resc_qcaps failed\\n\");\n\n\tbnxt_clear_reservations(bp, fw_reset);\n\n\treturn rc;\n}\n\nstatic int bnxt_hwrm_if_change(struct bnxt *bp, bool up)\n{\n\tstruct hwrm_func_drv_if_change_output *resp;\n\tstruct hwrm_func_drv_if_change_input *req;\n\tbool fw_reset = !bp->irq_tbl;\n\tbool resc_reinit = false;\n\tint rc, retry = 0;\n\tu32 flags = 0;\n\n\tif (!(bp->fw_cap & BNXT_FW_CAP_IF_CHANGE))\n\t\treturn 0;\n\n\trc = hwrm_req_init(bp, req, HWRM_FUNC_DRV_IF_CHANGE);\n\tif (rc)\n\t\treturn rc;\n\n\tif (up)\n\t\treq->flags = cpu_to_le32(FUNC_DRV_IF_CHANGE_REQ_FLAGS_UP);\n\tresp = hwrm_req_hold(bp, req);\n\n\thwrm_req_flags(bp, req, BNXT_HWRM_FULL_WAIT);\n\twhile (retry < BNXT_FW_IF_RETRY) {\n\t\trc = hwrm_req_send(bp, req);\n\t\tif (rc != -EAGAIN)\n\t\t\tbreak;\n\n\t\tmsleep(50);\n\t\tretry++;\n\t}\n\n\tif (rc == -EAGAIN) {\n\t\thwrm_req_drop(bp, req);\n\t\treturn rc;\n\t} else if (!rc) {\n\t\tflags = le32_to_cpu(resp->flags);\n\t} else if (up) {\n\t\trc = bnxt_try_recover_fw(bp);\n\t\tfw_reset = true;\n\t}\n\thwrm_req_drop(bp, req);\n\tif (rc)\n\t\treturn rc;\n\n\tif (!up) {\n\t\tbnxt_inv_fw_health_reg(bp);\n\t\treturn 0;\n\t}\n\n\tif (flags & FUNC_DRV_IF_CHANGE_RESP_FLAGS_RESC_CHANGE)\n\t\tresc_reinit = true;\n\tif (flags & FUNC_DRV_IF_CHANGE_RESP_FLAGS_HOT_FW_RESET_DONE ||\n\t    test_bit(BNXT_STATE_FW_RESET_DET, &bp->state))\n\t\tfw_reset = true;\n\telse\n\t\tbnxt_remap_fw_health_regs(bp);\n\n\tif (test_bit(BNXT_STATE_IN_FW_RESET, &bp->state) && !fw_reset) {\n\t\tnetdev_err(bp->dev, \"RESET_DONE not set during FW reset.\\n\");\n\t\tset_bit(BNXT_STATE_ABORT_ERR, &bp->state);\n\t\treturn -ENODEV;\n\t}\n\tif (resc_reinit || fw_reset) {\n\t\tif (fw_reset) {\n\t\t\tset_bit(BNXT_STATE_FW_RESET_DET, &bp->state);\n\t\t\tif (!test_bit(BNXT_STATE_IN_FW_RESET, &bp->state))\n\t\t\t\tbnxt_ulp_stop(bp);\n\t\t\tbnxt_free_ctx_mem(bp);\n\t\t\tkfree(bp->ctx);\n\t\t\tbp->ctx = NULL;\n\t\t\tbnxt_dcb_free(bp);\n\t\t\trc = bnxt_fw_init_one(bp);\n\t\t\tif (rc) {\n\t\t\t\tclear_bit(BNXT_STATE_FW_RESET_DET, &bp->state);\n\t\t\t\tset_bit(BNXT_STATE_ABORT_ERR, &bp->state);\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t\tbnxt_clear_int_mode(bp);\n\t\t\trc = bnxt_init_int_mode(bp);\n\t\t\tif (rc) {\n\t\t\t\tclear_bit(BNXT_STATE_FW_RESET_DET, &bp->state);\n\t\t\t\tnetdev_err(bp->dev, \"init int mode failed\\n\");\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\t\trc = bnxt_cancel_reservations(bp, fw_reset);\n\t}\n\treturn rc;\n}\n\nstatic int bnxt_hwrm_port_led_qcaps(struct bnxt *bp)\n{\n\tstruct hwrm_port_led_qcaps_output *resp;\n\tstruct hwrm_port_led_qcaps_input *req;\n\tstruct bnxt_pf_info *pf = &bp->pf;\n\tint rc;\n\n\tbp->num_leds = 0;\n\tif (BNXT_VF(bp) || bp->hwrm_spec_code < 0x10601)\n\t\treturn 0;\n\n\trc = hwrm_req_init(bp, req, HWRM_PORT_LED_QCAPS);\n\tif (rc)\n\t\treturn rc;\n\n\treq->port_id = cpu_to_le16(pf->port_id);\n\tresp = hwrm_req_hold(bp, req);\n\trc = hwrm_req_send(bp, req);\n\tif (rc) {\n\t\thwrm_req_drop(bp, req);\n\t\treturn rc;\n\t}\n\tif (resp->num_leds > 0 && resp->num_leds < BNXT_MAX_LED) {\n\t\tint i;\n\n\t\tbp->num_leds = resp->num_leds;\n\t\tmemcpy(bp->leds, &resp->led0_id, sizeof(bp->leds[0]) *\n\t\t\t\t\t\t bp->num_leds);\n\t\tfor (i = 0; i < bp->num_leds; i++) {\n\t\t\tstruct bnxt_led_info *led = &bp->leds[i];\n\t\t\t__le16 caps = led->led_state_caps;\n\n\t\t\tif (!led->led_group_id ||\n\t\t\t    !BNXT_LED_ALT_BLINK_CAP(caps)) {\n\t\t\t\tbp->num_leds = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\thwrm_req_drop(bp, req);\n\treturn 0;\n}\n\nint bnxt_hwrm_alloc_wol_fltr(struct bnxt *bp)\n{\n\tstruct hwrm_wol_filter_alloc_output *resp;\n\tstruct hwrm_wol_filter_alloc_input *req;\n\tint rc;\n\n\trc = hwrm_req_init(bp, req, HWRM_WOL_FILTER_ALLOC);\n\tif (rc)\n\t\treturn rc;\n\n\treq->port_id = cpu_to_le16(bp->pf.port_id);\n\treq->wol_type = WOL_FILTER_ALLOC_REQ_WOL_TYPE_MAGICPKT;\n\treq->enables = cpu_to_le32(WOL_FILTER_ALLOC_REQ_ENABLES_MAC_ADDRESS);\n\tmemcpy(req->mac_address, bp->dev->dev_addr, ETH_ALEN);\n\n\tresp = hwrm_req_hold(bp, req);\n\trc = hwrm_req_send(bp, req);\n\tif (!rc)\n\t\tbp->wol_filter_id = resp->wol_filter_id;\n\thwrm_req_drop(bp, req);\n\treturn rc;\n}\n\nint bnxt_hwrm_free_wol_fltr(struct bnxt *bp)\n{\n\tstruct hwrm_wol_filter_free_input *req;\n\tint rc;\n\n\trc = hwrm_req_init(bp, req, HWRM_WOL_FILTER_FREE);\n\tif (rc)\n\t\treturn rc;\n\n\treq->port_id = cpu_to_le16(bp->pf.port_id);\n\treq->enables = cpu_to_le32(WOL_FILTER_FREE_REQ_ENABLES_WOL_FILTER_ID);\n\treq->wol_filter_id = bp->wol_filter_id;\n\n\treturn hwrm_req_send(bp, req);\n}\n\nstatic u16 bnxt_hwrm_get_wol_fltrs(struct bnxt *bp, u16 handle)\n{\n\tstruct hwrm_wol_filter_qcfg_output *resp;\n\tstruct hwrm_wol_filter_qcfg_input *req;\n\tu16 next_handle = 0;\n\tint rc;\n\n\trc = hwrm_req_init(bp, req, HWRM_WOL_FILTER_QCFG);\n\tif (rc)\n\t\treturn rc;\n\n\treq->port_id = cpu_to_le16(bp->pf.port_id);\n\treq->handle = cpu_to_le16(handle);\n\tresp = hwrm_req_hold(bp, req);\n\trc = hwrm_req_send(bp, req);\n\tif (!rc) {\n\t\tnext_handle = le16_to_cpu(resp->next_handle);\n\t\tif (next_handle != 0) {\n\t\t\tif (resp->wol_type ==\n\t\t\t    WOL_FILTER_ALLOC_REQ_WOL_TYPE_MAGICPKT) {\n\t\t\t\tbp->wol = 1;\n\t\t\t\tbp->wol_filter_id = resp->wol_filter_id;\n\t\t\t}\n\t\t}\n\t}\n\thwrm_req_drop(bp, req);\n\treturn next_handle;\n}\n\nstatic void bnxt_get_wol_settings(struct bnxt *bp)\n{\n\tu16 handle = 0;\n\n\tbp->wol = 0;\n\tif (!BNXT_PF(bp) || !(bp->flags & BNXT_FLAG_WOL_CAP))\n\t\treturn;\n\n\tdo {\n\t\thandle = bnxt_hwrm_get_wol_fltrs(bp, handle);\n\t} while (handle && handle != 0xffff);\n}\n\n#ifdef CONFIG_BNXT_HWMON\nstatic ssize_t bnxt_show_temp(struct device *dev,\n\t\t\t      struct device_attribute *devattr, char *buf)\n{\n\tstruct hwrm_temp_monitor_query_output *resp;\n\tstruct hwrm_temp_monitor_query_input *req;\n\tstruct bnxt *bp = dev_get_drvdata(dev);\n\tu32 len = 0;\n\tint rc;\n\n\trc = hwrm_req_init(bp, req, HWRM_TEMP_MONITOR_QUERY);\n\tif (rc)\n\t\treturn rc;\n\tresp = hwrm_req_hold(bp, req);\n\trc = hwrm_req_send(bp, req);\n\tif (!rc)\n\t\tlen = sprintf(buf, \"%u\\n\", resp->temp * 1000);  \n\thwrm_req_drop(bp, req);\n\tif (rc)\n\t\treturn rc;\n\treturn len;\n}\nstatic SENSOR_DEVICE_ATTR(temp1_input, 0444, bnxt_show_temp, NULL, 0);\n\nstatic struct attribute *bnxt_attrs[] = {\n\t&sensor_dev_attr_temp1_input.dev_attr.attr,\n\tNULL\n};\nATTRIBUTE_GROUPS(bnxt);\n\nstatic void bnxt_hwmon_close(struct bnxt *bp)\n{\n\tif (bp->hwmon_dev) {\n\t\thwmon_device_unregister(bp->hwmon_dev);\n\t\tbp->hwmon_dev = NULL;\n\t}\n}\n\nstatic void bnxt_hwmon_open(struct bnxt *bp)\n{\n\tstruct hwrm_temp_monitor_query_input *req;\n\tstruct pci_dev *pdev = bp->pdev;\n\tint rc;\n\n\trc = hwrm_req_init(bp, req, HWRM_TEMP_MONITOR_QUERY);\n\tif (!rc)\n\t\trc = hwrm_req_send_silent(bp, req);\n\tif (rc == -EACCES || rc == -EOPNOTSUPP) {\n\t\tbnxt_hwmon_close(bp);\n\t\treturn;\n\t}\n\n\tif (bp->hwmon_dev)\n\t\treturn;\n\n\tbp->hwmon_dev = hwmon_device_register_with_groups(&pdev->dev,\n\t\t\t\t\t\t\t  DRV_MODULE_NAME, bp,\n\t\t\t\t\t\t\t  bnxt_groups);\n\tif (IS_ERR(bp->hwmon_dev)) {\n\t\tbp->hwmon_dev = NULL;\n\t\tdev_warn(&pdev->dev, \"Cannot register hwmon device\\n\");\n\t}\n}\n#else\nstatic void bnxt_hwmon_close(struct bnxt *bp)\n{\n}\n\nstatic void bnxt_hwmon_open(struct bnxt *bp)\n{\n}\n#endif\n\nstatic bool bnxt_eee_config_ok(struct bnxt *bp)\n{\n\tstruct ethtool_eee *eee = &bp->eee;\n\tstruct bnxt_link_info *link_info = &bp->link_info;\n\n\tif (!(bp->phy_flags & BNXT_PHY_FL_EEE_CAP))\n\t\treturn true;\n\n\tif (eee->eee_enabled) {\n\t\tu32 advertising =\n\t\t\t_bnxt_fw_to_ethtool_adv_spds(link_info->advertising, 0);\n\n\t\tif (!(link_info->autoneg & BNXT_AUTONEG_SPEED)) {\n\t\t\teee->eee_enabled = 0;\n\t\t\treturn false;\n\t\t}\n\t\tif (eee->advertised & ~advertising) {\n\t\t\teee->advertised = advertising & eee->supported;\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nstatic int bnxt_update_phy_setting(struct bnxt *bp)\n{\n\tint rc;\n\tbool update_link = false;\n\tbool update_pause = false;\n\tbool update_eee = false;\n\tstruct bnxt_link_info *link_info = &bp->link_info;\n\n\trc = bnxt_update_link(bp, true);\n\tif (rc) {\n\t\tnetdev_err(bp->dev, \"failed to update link (rc: %x)\\n\",\n\t\t\t   rc);\n\t\treturn rc;\n\t}\n\tif (!BNXT_SINGLE_PF(bp))\n\t\treturn 0;\n\n\tif ((link_info->autoneg & BNXT_AUTONEG_FLOW_CTRL) &&\n\t    (link_info->auto_pause_setting & BNXT_LINK_PAUSE_BOTH) !=\n\t    link_info->req_flow_ctrl)\n\t\tupdate_pause = true;\n\tif (!(link_info->autoneg & BNXT_AUTONEG_FLOW_CTRL) &&\n\t    link_info->force_pause_setting != link_info->req_flow_ctrl)\n\t\tupdate_pause = true;\n\tif (!(link_info->autoneg & BNXT_AUTONEG_SPEED)) {\n\t\tif (BNXT_AUTO_MODE(link_info->auto_mode))\n\t\t\tupdate_link = true;\n\t\tif (link_info->req_signal_mode == BNXT_SIG_MODE_NRZ &&\n\t\t    link_info->req_link_speed != link_info->force_link_speed)\n\t\t\tupdate_link = true;\n\t\telse if (link_info->req_signal_mode == BNXT_SIG_MODE_PAM4 &&\n\t\t\t link_info->req_link_speed != link_info->force_pam4_link_speed)\n\t\t\tupdate_link = true;\n\t\tif (link_info->req_duplex != link_info->duplex_setting)\n\t\t\tupdate_link = true;\n\t} else {\n\t\tif (link_info->auto_mode == BNXT_LINK_AUTO_NONE)\n\t\t\tupdate_link = true;\n\t\tif (link_info->advertising != link_info->auto_link_speeds ||\n\t\t    link_info->advertising_pam4 != link_info->auto_pam4_link_speeds)\n\t\t\tupdate_link = true;\n\t}\n\n\t \n\tif (!BNXT_LINK_IS_UP(bp))\n\t\tupdate_link = true;\n\n\tif (!bnxt_eee_config_ok(bp))\n\t\tupdate_eee = true;\n\n\tif (update_link)\n\t\trc = bnxt_hwrm_set_link_setting(bp, update_pause, update_eee);\n\telse if (update_pause)\n\t\trc = bnxt_hwrm_set_pause(bp);\n\tif (rc) {\n\t\tnetdev_err(bp->dev, \"failed to update phy setting (rc: %x)\\n\",\n\t\t\t   rc);\n\t\treturn rc;\n\t}\n\n\treturn rc;\n}\n\n \nstatic void bnxt_preset_reg_win(struct bnxt *bp)\n{\n\tif (BNXT_PF(bp)) {\n\t\t \n\t\twritel(BNXT_CAG_REG_BASE,\n\t\t       bp->bar0 + BNXT_GRCPF_REG_WINDOW_BASE_OUT + 12);\n\t}\n}\n\nstatic int bnxt_init_dflt_ring_mode(struct bnxt *bp);\n\nstatic int bnxt_reinit_after_abort(struct bnxt *bp)\n{\n\tint rc;\n\n\tif (test_bit(BNXT_STATE_IN_FW_RESET, &bp->state))\n\t\treturn -EBUSY;\n\n\tif (bp->dev->reg_state == NETREG_UNREGISTERED)\n\t\treturn -ENODEV;\n\n\trc = bnxt_fw_init_one(bp);\n\tif (!rc) {\n\t\tbnxt_clear_int_mode(bp);\n\t\trc = bnxt_init_int_mode(bp);\n\t\tif (!rc) {\n\t\t\tclear_bit(BNXT_STATE_ABORT_ERR, &bp->state);\n\t\t\tset_bit(BNXT_STATE_FW_RESET_DET, &bp->state);\n\t\t}\n\t}\n\treturn rc;\n}\n\nstatic int __bnxt_open_nic(struct bnxt *bp, bool irq_re_init, bool link_re_init)\n{\n\tint rc = 0;\n\n\tbnxt_preset_reg_win(bp);\n\tnetif_carrier_off(bp->dev);\n\tif (irq_re_init) {\n\t\t \n\t\trc = bnxt_init_dflt_ring_mode(bp);\n\t\tif (rc) {\n\t\t\tnetdev_err(bp->dev, \"Failed to reserve default rings at open\\n\");\n\t\t\treturn rc;\n\t\t}\n\t}\n\trc = bnxt_reserve_rings(bp, irq_re_init);\n\tif (rc)\n\t\treturn rc;\n\tif ((bp->flags & BNXT_FLAG_RFS) &&\n\t    !(bp->flags & BNXT_FLAG_USING_MSIX)) {\n\t\t \n\t\tbp->dev->hw_features &= ~NETIF_F_NTUPLE;\n\t\tbp->flags &= ~BNXT_FLAG_RFS;\n\t}\n\n\trc = bnxt_alloc_mem(bp, irq_re_init);\n\tif (rc) {\n\t\tnetdev_err(bp->dev, \"bnxt_alloc_mem err: %x\\n\", rc);\n\t\tgoto open_err_free_mem;\n\t}\n\n\tif (irq_re_init) {\n\t\tbnxt_init_napi(bp);\n\t\trc = bnxt_request_irq(bp);\n\t\tif (rc) {\n\t\t\tnetdev_err(bp->dev, \"bnxt_request_irq err: %x\\n\", rc);\n\t\t\tgoto open_err_irq;\n\t\t}\n\t}\n\n\trc = bnxt_init_nic(bp, irq_re_init);\n\tif (rc) {\n\t\tnetdev_err(bp->dev, \"bnxt_init_nic err: %x\\n\", rc);\n\t\tgoto open_err_irq;\n\t}\n\n\tbnxt_enable_napi(bp);\n\tbnxt_debug_dev_init(bp);\n\n\tif (link_re_init) {\n\t\tmutex_lock(&bp->link_lock);\n\t\trc = bnxt_update_phy_setting(bp);\n\t\tmutex_unlock(&bp->link_lock);\n\t\tif (rc) {\n\t\t\tnetdev_warn(bp->dev, \"failed to update phy settings\\n\");\n\t\t\tif (BNXT_SINGLE_PF(bp)) {\n\t\t\t\tbp->link_info.phy_retry = true;\n\t\t\t\tbp->link_info.phy_retry_expires =\n\t\t\t\t\tjiffies + 5 * HZ;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (irq_re_init)\n\t\tudp_tunnel_nic_reset_ntf(bp->dev);\n\n\tif (bp->tx_nr_rings_xdp < num_possible_cpus()) {\n\t\tif (!static_key_enabled(&bnxt_xdp_locking_key))\n\t\t\tstatic_branch_enable(&bnxt_xdp_locking_key);\n\t} else if (static_key_enabled(&bnxt_xdp_locking_key)) {\n\t\tstatic_branch_disable(&bnxt_xdp_locking_key);\n\t}\n\tset_bit(BNXT_STATE_OPEN, &bp->state);\n\tbnxt_enable_int(bp);\n\t \n\tbnxt_tx_enable(bp);\n\tmod_timer(&bp->timer, jiffies + bp->current_interval);\n\t \n\tmutex_lock(&bp->link_lock);\n\tbnxt_get_port_module_status(bp);\n\tmutex_unlock(&bp->link_lock);\n\n\t \n\tif (BNXT_PF(bp))\n\t\tbnxt_vf_reps_open(bp);\n\tbnxt_ptp_init_rtc(bp, true);\n\tbnxt_ptp_cfg_tstamp_filters(bp);\n\treturn 0;\n\nopen_err_irq:\n\tbnxt_del_napi(bp);\n\nopen_err_free_mem:\n\tbnxt_free_skbs(bp);\n\tbnxt_free_irq(bp);\n\tbnxt_free_mem(bp, true);\n\treturn rc;\n}\n\n \nint bnxt_open_nic(struct bnxt *bp, bool irq_re_init, bool link_re_init)\n{\n\tint rc = 0;\n\n\tif (test_bit(BNXT_STATE_ABORT_ERR, &bp->state))\n\t\trc = -EIO;\n\tif (!rc)\n\t\trc = __bnxt_open_nic(bp, irq_re_init, link_re_init);\n\tif (rc) {\n\t\tnetdev_err(bp->dev, \"nic open fail (rc: %x)\\n\", rc);\n\t\tdev_close(bp->dev);\n\t}\n\treturn rc;\n}\n\n \nint bnxt_half_open_nic(struct bnxt *bp)\n{\n\tint rc = 0;\n\n\tif (test_bit(BNXT_STATE_ABORT_ERR, &bp->state)) {\n\t\tnetdev_err(bp->dev, \"A previous firmware reset has not completed, aborting half open\\n\");\n\t\trc = -ENODEV;\n\t\tgoto half_open_err;\n\t}\n\n\trc = bnxt_alloc_mem(bp, true);\n\tif (rc) {\n\t\tnetdev_err(bp->dev, \"bnxt_alloc_mem err: %x\\n\", rc);\n\t\tgoto half_open_err;\n\t}\n\tset_bit(BNXT_STATE_HALF_OPEN, &bp->state);\n\trc = bnxt_init_nic(bp, true);\n\tif (rc) {\n\t\tclear_bit(BNXT_STATE_HALF_OPEN, &bp->state);\n\t\tnetdev_err(bp->dev, \"bnxt_init_nic err: %x\\n\", rc);\n\t\tgoto half_open_err;\n\t}\n\treturn 0;\n\nhalf_open_err:\n\tbnxt_free_skbs(bp);\n\tbnxt_free_mem(bp, true);\n\tdev_close(bp->dev);\n\treturn rc;\n}\n\n \nvoid bnxt_half_close_nic(struct bnxt *bp)\n{\n\tbnxt_hwrm_resource_free(bp, false, true);\n\tbnxt_free_skbs(bp);\n\tbnxt_free_mem(bp, true);\n\tclear_bit(BNXT_STATE_HALF_OPEN, &bp->state);\n}\n\nvoid bnxt_reenable_sriov(struct bnxt *bp)\n{\n\tif (BNXT_PF(bp)) {\n\t\tstruct bnxt_pf_info *pf = &bp->pf;\n\t\tint n = pf->active_vfs;\n\n\t\tif (n)\n\t\t\tbnxt_cfg_hw_sriov(bp, &n, true);\n\t}\n}\n\nstatic int bnxt_open(struct net_device *dev)\n{\n\tstruct bnxt *bp = netdev_priv(dev);\n\tint rc;\n\n\tif (test_bit(BNXT_STATE_ABORT_ERR, &bp->state)) {\n\t\trc = bnxt_reinit_after_abort(bp);\n\t\tif (rc) {\n\t\t\tif (rc == -EBUSY)\n\t\t\t\tnetdev_err(bp->dev, \"A previous firmware reset has not completed, aborting\\n\");\n\t\t\telse\n\t\t\t\tnetdev_err(bp->dev, \"Failed to reinitialize after aborted firmware reset\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\trc = bnxt_hwrm_if_change(bp, true);\n\tif (rc)\n\t\treturn rc;\n\n\trc = __bnxt_open_nic(bp, true, true);\n\tif (rc) {\n\t\tbnxt_hwrm_if_change(bp, false);\n\t} else {\n\t\tif (test_and_clear_bit(BNXT_STATE_FW_RESET_DET, &bp->state)) {\n\t\t\tif (!test_bit(BNXT_STATE_IN_FW_RESET, &bp->state)) {\n\t\t\t\tbnxt_ulp_start(bp, 0);\n\t\t\t\tbnxt_reenable_sriov(bp);\n\t\t\t}\n\t\t}\n\t\tbnxt_hwmon_open(bp);\n\t}\n\n\treturn rc;\n}\n\nstatic bool bnxt_drv_busy(struct bnxt *bp)\n{\n\treturn (test_bit(BNXT_STATE_IN_SP_TASK, &bp->state) ||\n\t\ttest_bit(BNXT_STATE_READ_STATS, &bp->state));\n}\n\nstatic void bnxt_get_ring_stats(struct bnxt *bp,\n\t\t\t\tstruct rtnl_link_stats64 *stats);\n\nstatic void __bnxt_close_nic(struct bnxt *bp, bool irq_re_init,\n\t\t\t     bool link_re_init)\n{\n\t \n\tif (BNXT_PF(bp))\n\t\tbnxt_vf_reps_close(bp);\n\n\t \n\tbnxt_tx_disable(bp);\n\n\tclear_bit(BNXT_STATE_OPEN, &bp->state);\n\tsmp_mb__after_atomic();\n\twhile (bnxt_drv_busy(bp))\n\t\tmsleep(20);\n\n\t \n\tbnxt_shutdown_nic(bp, irq_re_init);\n\n\t \n\n\tbnxt_debug_dev_exit(bp);\n\tbnxt_disable_napi(bp);\n\tdel_timer_sync(&bp->timer);\n\tbnxt_free_skbs(bp);\n\n\t \n\tif (bp->bnapi && irq_re_init) {\n\t\tbnxt_get_ring_stats(bp, &bp->net_stats_prev);\n\t\tbnxt_get_ring_err_stats(bp, &bp->ring_err_stats_prev);\n\t}\n\tif (irq_re_init) {\n\t\tbnxt_free_irq(bp);\n\t\tbnxt_del_napi(bp);\n\t}\n\tbnxt_free_mem(bp, irq_re_init);\n}\n\nvoid bnxt_close_nic(struct bnxt *bp, bool irq_re_init, bool link_re_init)\n{\n\tif (test_bit(BNXT_STATE_IN_FW_RESET, &bp->state)) {\n\t\t \n\t\tnetdev_warn(bp->dev, \"FW reset in progress during close, FW reset will be aborted\\n\");\n\t\tset_bit(BNXT_STATE_ABORT_ERR, &bp->state);\n\t}\n\n#ifdef CONFIG_BNXT_SRIOV\n\tif (bp->sriov_cfg) {\n\t\tint rc;\n\n\t\trc = wait_event_interruptible_timeout(bp->sriov_cfg_wait,\n\t\t\t\t\t\t      !bp->sriov_cfg,\n\t\t\t\t\t\t      BNXT_SRIOV_CFG_WAIT_TMO);\n\t\tif (!rc)\n\t\t\tnetdev_warn(bp->dev, \"timeout waiting for SRIOV config operation to complete, proceeding to close!\\n\");\n\t\telse if (rc < 0)\n\t\t\tnetdev_warn(bp->dev, \"SRIOV config operation interrupted, proceeding to close!\\n\");\n\t}\n#endif\n\t__bnxt_close_nic(bp, irq_re_init, link_re_init);\n}\n\nstatic int bnxt_close(struct net_device *dev)\n{\n\tstruct bnxt *bp = netdev_priv(dev);\n\n\tbnxt_hwmon_close(bp);\n\tbnxt_close_nic(bp, true, true);\n\tbnxt_hwrm_shutdown_link(bp);\n\tbnxt_hwrm_if_change(bp, false);\n\treturn 0;\n}\n\nstatic int bnxt_hwrm_port_phy_read(struct bnxt *bp, u16 phy_addr, u16 reg,\n\t\t\t\t   u16 *val)\n{\n\tstruct hwrm_port_phy_mdio_read_output *resp;\n\tstruct hwrm_port_phy_mdio_read_input *req;\n\tint rc;\n\n\tif (bp->hwrm_spec_code < 0x10a00)\n\t\treturn -EOPNOTSUPP;\n\n\trc = hwrm_req_init(bp, req, HWRM_PORT_PHY_MDIO_READ);\n\tif (rc)\n\t\treturn rc;\n\n\treq->port_id = cpu_to_le16(bp->pf.port_id);\n\treq->phy_addr = phy_addr;\n\treq->reg_addr = cpu_to_le16(reg & 0x1f);\n\tif (mdio_phy_id_is_c45(phy_addr)) {\n\t\treq->cl45_mdio = 1;\n\t\treq->phy_addr = mdio_phy_id_prtad(phy_addr);\n\t\treq->dev_addr = mdio_phy_id_devad(phy_addr);\n\t\treq->reg_addr = cpu_to_le16(reg);\n\t}\n\n\tresp = hwrm_req_hold(bp, req);\n\trc = hwrm_req_send(bp, req);\n\tif (!rc)\n\t\t*val = le16_to_cpu(resp->reg_data);\n\thwrm_req_drop(bp, req);\n\treturn rc;\n}\n\nstatic int bnxt_hwrm_port_phy_write(struct bnxt *bp, u16 phy_addr, u16 reg,\n\t\t\t\t    u16 val)\n{\n\tstruct hwrm_port_phy_mdio_write_input *req;\n\tint rc;\n\n\tif (bp->hwrm_spec_code < 0x10a00)\n\t\treturn -EOPNOTSUPP;\n\n\trc = hwrm_req_init(bp, req, HWRM_PORT_PHY_MDIO_WRITE);\n\tif (rc)\n\t\treturn rc;\n\n\treq->port_id = cpu_to_le16(bp->pf.port_id);\n\treq->phy_addr = phy_addr;\n\treq->reg_addr = cpu_to_le16(reg & 0x1f);\n\tif (mdio_phy_id_is_c45(phy_addr)) {\n\t\treq->cl45_mdio = 1;\n\t\treq->phy_addr = mdio_phy_id_prtad(phy_addr);\n\t\treq->dev_addr = mdio_phy_id_devad(phy_addr);\n\t\treq->reg_addr = cpu_to_le16(reg);\n\t}\n\treq->reg_data = cpu_to_le16(val);\n\n\treturn hwrm_req_send(bp, req);\n}\n\n \nstatic int bnxt_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\n{\n\tstruct mii_ioctl_data *mdio = if_mii(ifr);\n\tstruct bnxt *bp = netdev_priv(dev);\n\tint rc;\n\n\tswitch (cmd) {\n\tcase SIOCGMIIPHY:\n\t\tmdio->phy_id = bp->link_info.phy_addr;\n\n\t\tfallthrough;\n\tcase SIOCGMIIREG: {\n\t\tu16 mii_regval = 0;\n\n\t\tif (!netif_running(dev))\n\t\t\treturn -EAGAIN;\n\n\t\trc = bnxt_hwrm_port_phy_read(bp, mdio->phy_id, mdio->reg_num,\n\t\t\t\t\t     &mii_regval);\n\t\tmdio->val_out = mii_regval;\n\t\treturn rc;\n\t}\n\n\tcase SIOCSMIIREG:\n\t\tif (!netif_running(dev))\n\t\t\treturn -EAGAIN;\n\n\t\treturn bnxt_hwrm_port_phy_write(bp, mdio->phy_id, mdio->reg_num,\n\t\t\t\t\t\tmdio->val_in);\n\n\tcase SIOCSHWTSTAMP:\n\t\treturn bnxt_hwtstamp_set(dev, ifr);\n\n\tcase SIOCGHWTSTAMP:\n\t\treturn bnxt_hwtstamp_get(dev, ifr);\n\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n\treturn -EOPNOTSUPP;\n}\n\nstatic void bnxt_get_ring_stats(struct bnxt *bp,\n\t\t\t\tstruct rtnl_link_stats64 *stats)\n{\n\tint i;\n\n\tfor (i = 0; i < bp->cp_nr_rings; i++) {\n\t\tstruct bnxt_napi *bnapi = bp->bnapi[i];\n\t\tstruct bnxt_cp_ring_info *cpr = &bnapi->cp_ring;\n\t\tu64 *sw = cpr->stats.sw_stats;\n\n\t\tstats->rx_packets += BNXT_GET_RING_STATS64(sw, rx_ucast_pkts);\n\t\tstats->rx_packets += BNXT_GET_RING_STATS64(sw, rx_mcast_pkts);\n\t\tstats->rx_packets += BNXT_GET_RING_STATS64(sw, rx_bcast_pkts);\n\n\t\tstats->tx_packets += BNXT_GET_RING_STATS64(sw, tx_ucast_pkts);\n\t\tstats->tx_packets += BNXT_GET_RING_STATS64(sw, tx_mcast_pkts);\n\t\tstats->tx_packets += BNXT_GET_RING_STATS64(sw, tx_bcast_pkts);\n\n\t\tstats->rx_bytes += BNXT_GET_RING_STATS64(sw, rx_ucast_bytes);\n\t\tstats->rx_bytes += BNXT_GET_RING_STATS64(sw, rx_mcast_bytes);\n\t\tstats->rx_bytes += BNXT_GET_RING_STATS64(sw, rx_bcast_bytes);\n\n\t\tstats->tx_bytes += BNXT_GET_RING_STATS64(sw, tx_ucast_bytes);\n\t\tstats->tx_bytes += BNXT_GET_RING_STATS64(sw, tx_mcast_bytes);\n\t\tstats->tx_bytes += BNXT_GET_RING_STATS64(sw, tx_bcast_bytes);\n\n\t\tstats->rx_missed_errors +=\n\t\t\tBNXT_GET_RING_STATS64(sw, rx_discard_pkts);\n\n\t\tstats->multicast += BNXT_GET_RING_STATS64(sw, rx_mcast_pkts);\n\n\t\tstats->tx_dropped += BNXT_GET_RING_STATS64(sw, tx_error_pkts);\n\n\t\tstats->rx_dropped +=\n\t\t\tcpr->sw_stats.rx.rx_netpoll_discards +\n\t\t\tcpr->sw_stats.rx.rx_oom_discards;\n\t}\n}\n\nstatic void bnxt_add_prev_stats(struct bnxt *bp,\n\t\t\t\tstruct rtnl_link_stats64 *stats)\n{\n\tstruct rtnl_link_stats64 *prev_stats = &bp->net_stats_prev;\n\n\tstats->rx_packets += prev_stats->rx_packets;\n\tstats->tx_packets += prev_stats->tx_packets;\n\tstats->rx_bytes += prev_stats->rx_bytes;\n\tstats->tx_bytes += prev_stats->tx_bytes;\n\tstats->rx_missed_errors += prev_stats->rx_missed_errors;\n\tstats->multicast += prev_stats->multicast;\n\tstats->rx_dropped += prev_stats->rx_dropped;\n\tstats->tx_dropped += prev_stats->tx_dropped;\n}\n\nstatic void\nbnxt_get_stats64(struct net_device *dev, struct rtnl_link_stats64 *stats)\n{\n\tstruct bnxt *bp = netdev_priv(dev);\n\n\tset_bit(BNXT_STATE_READ_STATS, &bp->state);\n\t \n\tsmp_mb__after_atomic();\n\tif (!test_bit(BNXT_STATE_OPEN, &bp->state)) {\n\t\tclear_bit(BNXT_STATE_READ_STATS, &bp->state);\n\t\t*stats = bp->net_stats_prev;\n\t\treturn;\n\t}\n\n\tbnxt_get_ring_stats(bp, stats);\n\tbnxt_add_prev_stats(bp, stats);\n\n\tif (bp->flags & BNXT_FLAG_PORT_STATS) {\n\t\tu64 *rx = bp->port_stats.sw_stats;\n\t\tu64 *tx = bp->port_stats.sw_stats +\n\t\t\t  BNXT_TX_PORT_STATS_BYTE_OFFSET / 8;\n\n\t\tstats->rx_crc_errors =\n\t\t\tBNXT_GET_RX_PORT_STATS64(rx, rx_fcs_err_frames);\n\t\tstats->rx_frame_errors =\n\t\t\tBNXT_GET_RX_PORT_STATS64(rx, rx_align_err_frames);\n\t\tstats->rx_length_errors =\n\t\t\tBNXT_GET_RX_PORT_STATS64(rx, rx_undrsz_frames) +\n\t\t\tBNXT_GET_RX_PORT_STATS64(rx, rx_ovrsz_frames) +\n\t\t\tBNXT_GET_RX_PORT_STATS64(rx, rx_runt_frames);\n\t\tstats->rx_errors =\n\t\t\tBNXT_GET_RX_PORT_STATS64(rx, rx_false_carrier_frames) +\n\t\t\tBNXT_GET_RX_PORT_STATS64(rx, rx_jbr_frames);\n\t\tstats->collisions =\n\t\t\tBNXT_GET_TX_PORT_STATS64(tx, tx_total_collisions);\n\t\tstats->tx_fifo_errors =\n\t\t\tBNXT_GET_TX_PORT_STATS64(tx, tx_fifo_underruns);\n\t\tstats->tx_errors = BNXT_GET_TX_PORT_STATS64(tx, tx_err);\n\t}\n\tclear_bit(BNXT_STATE_READ_STATS, &bp->state);\n}\n\nstatic void bnxt_get_one_ring_err_stats(struct bnxt *bp,\n\t\t\t\t\tstruct bnxt_total_ring_err_stats *stats,\n\t\t\t\t\tstruct bnxt_cp_ring_info *cpr)\n{\n\tstruct bnxt_sw_stats *sw_stats = &cpr->sw_stats;\n\tu64 *hw_stats = cpr->stats.sw_stats;\n\n\tstats->rx_total_l4_csum_errors += sw_stats->rx.rx_l4_csum_errors;\n\tstats->rx_total_resets += sw_stats->rx.rx_resets;\n\tstats->rx_total_buf_errors += sw_stats->rx.rx_buf_errors;\n\tstats->rx_total_oom_discards += sw_stats->rx.rx_oom_discards;\n\tstats->rx_total_netpoll_discards += sw_stats->rx.rx_netpoll_discards;\n\tstats->rx_total_ring_discards +=\n\t\tBNXT_GET_RING_STATS64(hw_stats, rx_discard_pkts);\n\tstats->tx_total_resets += sw_stats->tx.tx_resets;\n\tstats->tx_total_ring_discards +=\n\t\tBNXT_GET_RING_STATS64(hw_stats, tx_discard_pkts);\n\tstats->total_missed_irqs += sw_stats->cmn.missed_irqs;\n}\n\nvoid bnxt_get_ring_err_stats(struct bnxt *bp,\n\t\t\t     struct bnxt_total_ring_err_stats *stats)\n{\n\tint i;\n\n\tfor (i = 0; i < bp->cp_nr_rings; i++)\n\t\tbnxt_get_one_ring_err_stats(bp, stats, &bp->bnapi[i]->cp_ring);\n}\n\nstatic bool bnxt_mc_list_updated(struct bnxt *bp, u32 *rx_mask)\n{\n\tstruct net_device *dev = bp->dev;\n\tstruct bnxt_vnic_info *vnic = &bp->vnic_info[0];\n\tstruct netdev_hw_addr *ha;\n\tu8 *haddr;\n\tint mc_count = 0;\n\tbool update = false;\n\tint off = 0;\n\n\tnetdev_for_each_mc_addr(ha, dev) {\n\t\tif (mc_count >= BNXT_MAX_MC_ADDRS) {\n\t\t\t*rx_mask |= CFA_L2_SET_RX_MASK_REQ_MASK_ALL_MCAST;\n\t\t\tvnic->mc_list_count = 0;\n\t\t\treturn false;\n\t\t}\n\t\thaddr = ha->addr;\n\t\tif (!ether_addr_equal(haddr, vnic->mc_list + off)) {\n\t\t\tmemcpy(vnic->mc_list + off, haddr, ETH_ALEN);\n\t\t\tupdate = true;\n\t\t}\n\t\toff += ETH_ALEN;\n\t\tmc_count++;\n\t}\n\tif (mc_count)\n\t\t*rx_mask |= CFA_L2_SET_RX_MASK_REQ_MASK_MCAST;\n\n\tif (mc_count != vnic->mc_list_count) {\n\t\tvnic->mc_list_count = mc_count;\n\t\tupdate = true;\n\t}\n\treturn update;\n}\n\nstatic bool bnxt_uc_list_updated(struct bnxt *bp)\n{\n\tstruct net_device *dev = bp->dev;\n\tstruct bnxt_vnic_info *vnic = &bp->vnic_info[0];\n\tstruct netdev_hw_addr *ha;\n\tint off = 0;\n\n\tif (netdev_uc_count(dev) != (vnic->uc_filter_count - 1))\n\t\treturn true;\n\n\tnetdev_for_each_uc_addr(ha, dev) {\n\t\tif (!ether_addr_equal(ha->addr, vnic->uc_list + off))\n\t\t\treturn true;\n\n\t\toff += ETH_ALEN;\n\t}\n\treturn false;\n}\n\nstatic void bnxt_set_rx_mode(struct net_device *dev)\n{\n\tstruct bnxt *bp = netdev_priv(dev);\n\tstruct bnxt_vnic_info *vnic;\n\tbool mc_update = false;\n\tbool uc_update;\n\tu32 mask;\n\n\tif (!test_bit(BNXT_STATE_OPEN, &bp->state))\n\t\treturn;\n\n\tvnic = &bp->vnic_info[0];\n\tmask = vnic->rx_mask;\n\tmask &= ~(CFA_L2_SET_RX_MASK_REQ_MASK_PROMISCUOUS |\n\t\t  CFA_L2_SET_RX_MASK_REQ_MASK_MCAST |\n\t\t  CFA_L2_SET_RX_MASK_REQ_MASK_ALL_MCAST |\n\t\t  CFA_L2_SET_RX_MASK_REQ_MASK_BCAST);\n\n\tif (dev->flags & IFF_PROMISC)\n\t\tmask |= CFA_L2_SET_RX_MASK_REQ_MASK_PROMISCUOUS;\n\n\tuc_update = bnxt_uc_list_updated(bp);\n\n\tif (dev->flags & IFF_BROADCAST)\n\t\tmask |= CFA_L2_SET_RX_MASK_REQ_MASK_BCAST;\n\tif (dev->flags & IFF_ALLMULTI) {\n\t\tmask |= CFA_L2_SET_RX_MASK_REQ_MASK_ALL_MCAST;\n\t\tvnic->mc_list_count = 0;\n\t} else if (dev->flags & IFF_MULTICAST) {\n\t\tmc_update = bnxt_mc_list_updated(bp, &mask);\n\t}\n\n\tif (mask != vnic->rx_mask || uc_update || mc_update) {\n\t\tvnic->rx_mask = mask;\n\n\t\tbnxt_queue_sp_work(bp, BNXT_RX_MASK_SP_EVENT);\n\t}\n}\n\nstatic int bnxt_cfg_rx_mode(struct bnxt *bp)\n{\n\tstruct net_device *dev = bp->dev;\n\tstruct bnxt_vnic_info *vnic = &bp->vnic_info[0];\n\tstruct hwrm_cfa_l2_filter_free_input *req;\n\tstruct netdev_hw_addr *ha;\n\tint i, off = 0, rc;\n\tbool uc_update;\n\n\tnetif_addr_lock_bh(dev);\n\tuc_update = bnxt_uc_list_updated(bp);\n\tnetif_addr_unlock_bh(dev);\n\n\tif (!uc_update)\n\t\tgoto skip_uc;\n\n\trc = hwrm_req_init(bp, req, HWRM_CFA_L2_FILTER_FREE);\n\tif (rc)\n\t\treturn rc;\n\thwrm_req_hold(bp, req);\n\tfor (i = 1; i < vnic->uc_filter_count; i++) {\n\t\treq->l2_filter_id = vnic->fw_l2_filter_id[i];\n\n\t\trc = hwrm_req_send(bp, req);\n\t}\n\thwrm_req_drop(bp, req);\n\n\tvnic->uc_filter_count = 1;\n\n\tnetif_addr_lock_bh(dev);\n\tif (netdev_uc_count(dev) > (BNXT_MAX_UC_ADDRS - 1)) {\n\t\tvnic->rx_mask |= CFA_L2_SET_RX_MASK_REQ_MASK_PROMISCUOUS;\n\t} else {\n\t\tnetdev_for_each_uc_addr(ha, dev) {\n\t\t\tmemcpy(vnic->uc_list + off, ha->addr, ETH_ALEN);\n\t\t\toff += ETH_ALEN;\n\t\t\tvnic->uc_filter_count++;\n\t\t}\n\t}\n\tnetif_addr_unlock_bh(dev);\n\n\tfor (i = 1, off = 0; i < vnic->uc_filter_count; i++, off += ETH_ALEN) {\n\t\trc = bnxt_hwrm_set_vnic_filter(bp, 0, i, vnic->uc_list + off);\n\t\tif (rc) {\n\t\t\tif (BNXT_VF(bp) && rc == -ENODEV) {\n\t\t\t\tif (!test_and_set_bit(BNXT_STATE_L2_FILTER_RETRY, &bp->state))\n\t\t\t\t\tnetdev_warn(bp->dev, \"Cannot configure L2 filters while PF is unavailable, will retry\\n\");\n\t\t\t\telse\n\t\t\t\t\tnetdev_dbg(bp->dev, \"PF still unavailable while configuring L2 filters.\\n\");\n\t\t\t\trc = 0;\n\t\t\t} else {\n\t\t\t\tnetdev_err(bp->dev, \"HWRM vnic filter failure rc: %x\\n\", rc);\n\t\t\t}\n\t\t\tvnic->uc_filter_count = i;\n\t\t\treturn rc;\n\t\t}\n\t}\n\tif (test_and_clear_bit(BNXT_STATE_L2_FILTER_RETRY, &bp->state))\n\t\tnetdev_notice(bp->dev, \"Retry of L2 filter configuration successful.\\n\");\n\nskip_uc:\n\tif ((vnic->rx_mask & CFA_L2_SET_RX_MASK_REQ_MASK_PROMISCUOUS) &&\n\t    !bnxt_promisc_ok(bp))\n\t\tvnic->rx_mask &= ~CFA_L2_SET_RX_MASK_REQ_MASK_PROMISCUOUS;\n\trc = bnxt_hwrm_cfa_l2_set_rx_mask(bp, 0);\n\tif (rc && (vnic->rx_mask & CFA_L2_SET_RX_MASK_REQ_MASK_MCAST)) {\n\t\tnetdev_info(bp->dev, \"Failed setting MC filters rc: %d, turning on ALL_MCAST mode\\n\",\n\t\t\t    rc);\n\t\tvnic->rx_mask &= ~CFA_L2_SET_RX_MASK_REQ_MASK_MCAST;\n\t\tvnic->rx_mask |= CFA_L2_SET_RX_MASK_REQ_MASK_ALL_MCAST;\n\t\tvnic->mc_list_count = 0;\n\t\trc = bnxt_hwrm_cfa_l2_set_rx_mask(bp, 0);\n\t}\n\tif (rc)\n\t\tnetdev_err(bp->dev, \"HWRM cfa l2 rx mask failure rc: %d\\n\",\n\t\t\t   rc);\n\n\treturn rc;\n}\n\nstatic bool bnxt_can_reserve_rings(struct bnxt *bp)\n{\n#ifdef CONFIG_BNXT_SRIOV\n\tif (BNXT_NEW_RM(bp) && BNXT_VF(bp)) {\n\t\tstruct bnxt_hw_resc *hw_resc = &bp->hw_resc;\n\n\t\t \n\t\tif (hw_resc->min_tx_rings || hw_resc->resv_tx_rings)\n\t\t\treturn true;\n\n\t\tif (!netif_running(bp->dev))\n\t\t\treturn false;\n\t}\n#endif\n\treturn true;\n}\n\n \nstatic bool bnxt_rfs_supported(struct bnxt *bp)\n{\n\tif (bp->flags & BNXT_FLAG_CHIP_P5) {\n\t\tif (bp->fw_cap & BNXT_FW_CAP_CFA_RFS_RING_TBL_IDX_V2)\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\t \n\tif (BNXT_FW_MAJ(bp) == 212)\n\t\treturn false;\n\tif (BNXT_PF(bp) && !BNXT_CHIP_TYPE_NITRO_A0(bp))\n\t\treturn true;\n\tif (bp->flags & BNXT_FLAG_NEW_RSS_CAP)\n\t\treturn true;\n\treturn false;\n}\n\n \nstatic bool bnxt_rfs_capable(struct bnxt *bp)\n{\n#ifdef CONFIG_RFS_ACCEL\n\tint vnics, max_vnics, max_rss_ctxs;\n\n\tif (bp->flags & BNXT_FLAG_CHIP_P5)\n\t\treturn bnxt_rfs_supported(bp);\n\tif (!(bp->flags & BNXT_FLAG_MSIX_CAP) || !bnxt_can_reserve_rings(bp) || !bp->rx_nr_rings)\n\t\treturn false;\n\n\tvnics = 1 + bp->rx_nr_rings;\n\tmax_vnics = bnxt_get_max_func_vnics(bp);\n\tmax_rss_ctxs = bnxt_get_max_func_rss_ctxs(bp);\n\n\t \n\tif (bp->flags & BNXT_FLAG_NEW_RSS_CAP)\n\t\tmax_rss_ctxs = max_vnics;\n\tif (vnics > max_vnics || vnics > max_rss_ctxs) {\n\t\tif (bp->rx_nr_rings > 1)\n\t\t\tnetdev_warn(bp->dev,\n\t\t\t\t    \"Not enough resources to support NTUPLE filters, enough resources for up to %d rx rings\\n\",\n\t\t\t\t    min(max_rss_ctxs - 1, max_vnics - 1));\n\t\treturn false;\n\t}\n\n\tif (!BNXT_NEW_RM(bp))\n\t\treturn true;\n\n\tif (vnics == bp->hw_resc.resv_vnics)\n\t\treturn true;\n\n\tbnxt_hwrm_reserve_rings(bp, 0, 0, 0, 0, 0, vnics);\n\tif (vnics <= bp->hw_resc.resv_vnics)\n\t\treturn true;\n\n\tnetdev_warn(bp->dev, \"Unable to reserve resources to support NTUPLE filters.\\n\");\n\tbnxt_hwrm_reserve_rings(bp, 0, 0, 0, 0, 0, 1);\n\treturn false;\n#else\n\treturn false;\n#endif\n}\n\nstatic netdev_features_t bnxt_fix_features(struct net_device *dev,\n\t\t\t\t\t   netdev_features_t features)\n{\n\tstruct bnxt *bp = netdev_priv(dev);\n\tnetdev_features_t vlan_features;\n\n\tif ((features & NETIF_F_NTUPLE) && !bnxt_rfs_capable(bp))\n\t\tfeatures &= ~NETIF_F_NTUPLE;\n\n\tif ((bp->flags & BNXT_FLAG_NO_AGG_RINGS) || bp->xdp_prog)\n\t\tfeatures &= ~(NETIF_F_LRO | NETIF_F_GRO_HW);\n\n\tif (!(features & NETIF_F_GRO))\n\t\tfeatures &= ~NETIF_F_GRO_HW;\n\n\tif (features & NETIF_F_GRO_HW)\n\t\tfeatures &= ~NETIF_F_LRO;\n\n\t \n\tvlan_features = features & BNXT_HW_FEATURE_VLAN_ALL_RX;\n\tif (vlan_features != BNXT_HW_FEATURE_VLAN_ALL_RX) {\n\t\tif (dev->features & BNXT_HW_FEATURE_VLAN_ALL_RX)\n\t\t\tfeatures &= ~BNXT_HW_FEATURE_VLAN_ALL_RX;\n\t\telse if (vlan_features)\n\t\t\tfeatures |= BNXT_HW_FEATURE_VLAN_ALL_RX;\n\t}\n#ifdef CONFIG_BNXT_SRIOV\n\tif (BNXT_VF(bp) && bp->vf.vlan)\n\t\tfeatures &= ~BNXT_HW_FEATURE_VLAN_ALL_RX;\n#endif\n\treturn features;\n}\n\nstatic int bnxt_set_features(struct net_device *dev, netdev_features_t features)\n{\n\tstruct bnxt *bp = netdev_priv(dev);\n\tu32 flags = bp->flags;\n\tu32 changes;\n\tint rc = 0;\n\tbool re_init = false;\n\tbool update_tpa = false;\n\n\tflags &= ~BNXT_FLAG_ALL_CONFIG_FEATS;\n\tif (features & NETIF_F_GRO_HW)\n\t\tflags |= BNXT_FLAG_GRO;\n\telse if (features & NETIF_F_LRO)\n\t\tflags |= BNXT_FLAG_LRO;\n\n\tif (bp->flags & BNXT_FLAG_NO_AGG_RINGS)\n\t\tflags &= ~BNXT_FLAG_TPA;\n\n\tif (features & BNXT_HW_FEATURE_VLAN_ALL_RX)\n\t\tflags |= BNXT_FLAG_STRIP_VLAN;\n\n\tif (features & NETIF_F_NTUPLE)\n\t\tflags |= BNXT_FLAG_RFS;\n\n\tchanges = flags ^ bp->flags;\n\tif (changes & BNXT_FLAG_TPA) {\n\t\tupdate_tpa = true;\n\t\tif ((bp->flags & BNXT_FLAG_TPA) == 0 ||\n\t\t    (flags & BNXT_FLAG_TPA) == 0 ||\n\t\t    (bp->flags & BNXT_FLAG_CHIP_P5))\n\t\t\tre_init = true;\n\t}\n\n\tif (changes & ~BNXT_FLAG_TPA)\n\t\tre_init = true;\n\n\tif (flags != bp->flags) {\n\t\tu32 old_flags = bp->flags;\n\n\t\tif (!test_bit(BNXT_STATE_OPEN, &bp->state)) {\n\t\t\tbp->flags = flags;\n\t\t\tif (update_tpa)\n\t\t\t\tbnxt_set_ring_params(bp);\n\t\t\treturn rc;\n\t\t}\n\n\t\tif (re_init) {\n\t\t\tbnxt_close_nic(bp, false, false);\n\t\t\tbp->flags = flags;\n\t\t\tif (update_tpa)\n\t\t\t\tbnxt_set_ring_params(bp);\n\n\t\t\treturn bnxt_open_nic(bp, false, false);\n\t\t}\n\t\tif (update_tpa) {\n\t\t\tbp->flags = flags;\n\t\t\trc = bnxt_set_tpa(bp,\n\t\t\t\t\t  (flags & BNXT_FLAG_TPA) ?\n\t\t\t\t\t  true : false);\n\t\t\tif (rc)\n\t\t\t\tbp->flags = old_flags;\n\t\t}\n\t}\n\treturn rc;\n}\n\nstatic bool bnxt_exthdr_check(struct bnxt *bp, struct sk_buff *skb, int nw_off,\n\t\t\t      u8 **nextp)\n{\n\tstruct ipv6hdr *ip6h = (struct ipv6hdr *)(skb->data + nw_off);\n\tstruct hop_jumbo_hdr *jhdr;\n\tint hdr_count = 0;\n\tu8 *nexthdr;\n\tint start;\n\n\t \n\tstart = nw_off + sizeof(*ip6h);\n\tnexthdr = &ip6h->nexthdr;\n\twhile (ipv6_ext_hdr(*nexthdr)) {\n\t\tstruct ipv6_opt_hdr *hp;\n\t\tint hdrlen;\n\n\t\tif (hdr_count >= 3 || *nexthdr == NEXTHDR_NONE ||\n\t\t    *nexthdr == NEXTHDR_FRAGMENT)\n\t\t\treturn false;\n\t\thp = __skb_header_pointer(NULL, start, sizeof(*hp), skb->data,\n\t\t\t\t\t  skb_headlen(skb), NULL);\n\t\tif (!hp)\n\t\t\treturn false;\n\t\tif (*nexthdr == NEXTHDR_AUTH)\n\t\t\thdrlen = ipv6_authlen(hp);\n\t\telse\n\t\t\thdrlen = ipv6_optlen(hp);\n\n\t\tif (hdrlen > 64)\n\t\t\treturn false;\n\n\t\t \n\t\tif (*nexthdr == NEXTHDR_HOP) {\n\t\t\tif (likely(skb->len <= GRO_LEGACY_MAX_SIZE))\n\t\t\t\tgoto increment_hdr;\n\n\t\t\tjhdr = (struct hop_jumbo_hdr *)hp;\n\t\t\tif (jhdr->tlv_type != IPV6_TLV_JUMBO || jhdr->hdrlen != 0 ||\n\t\t\t    jhdr->nexthdr != IPPROTO_TCP)\n\t\t\t\tgoto increment_hdr;\n\n\t\t\tgoto next_hdr;\n\t\t}\nincrement_hdr:\n\t\thdr_count++;\nnext_hdr:\n\t\tnexthdr = &hp->nexthdr;\n\t\tstart += hdrlen;\n\t}\n\tif (nextp) {\n\t\t \n\t\tif (skb->encapsulation) {\n\t\t\t*nextp = nexthdr;\n\t\t\treturn true;\n\t\t}\n\t\t*nextp = NULL;\n\t}\n\t \n\treturn *nexthdr == IPPROTO_TCP || *nexthdr == IPPROTO_UDP;\n}\n\n \nstatic bool bnxt_udp_tunl_check(struct bnxt *bp, struct sk_buff *skb)\n{\n\tstruct udphdr *uh = udp_hdr(skb);\n\t__be16 udp_port = uh->dest;\n\n\tif (udp_port != bp->vxlan_port && udp_port != bp->nge_port)\n\t\treturn false;\n\tif (skb->inner_protocol_type == ENCAP_TYPE_ETHER) {\n\t\tstruct ethhdr *eh = inner_eth_hdr(skb);\n\n\t\tswitch (eh->h_proto) {\n\t\tcase htons(ETH_P_IP):\n\t\t\treturn true;\n\t\tcase htons(ETH_P_IPV6):\n\t\t\treturn bnxt_exthdr_check(bp, skb,\n\t\t\t\t\t\t skb_inner_network_offset(skb),\n\t\t\t\t\t\t NULL);\n\t\t}\n\t}\n\treturn false;\n}\n\nstatic bool bnxt_tunl_check(struct bnxt *bp, struct sk_buff *skb, u8 l4_proto)\n{\n\tswitch (l4_proto) {\n\tcase IPPROTO_UDP:\n\t\treturn bnxt_udp_tunl_check(bp, skb);\n\tcase IPPROTO_IPIP:\n\t\treturn true;\n\tcase IPPROTO_GRE: {\n\t\tswitch (skb->inner_protocol) {\n\t\tdefault:\n\t\t\treturn false;\n\t\tcase htons(ETH_P_IP):\n\t\t\treturn true;\n\t\tcase htons(ETH_P_IPV6):\n\t\t\tfallthrough;\n\t\t}\n\t}\n\tcase IPPROTO_IPV6:\n\t\t \n\t\treturn bnxt_exthdr_check(bp, skb, skb_inner_network_offset(skb),\n\t\t\t\t\t NULL);\n\t}\n\treturn false;\n}\n\nstatic netdev_features_t bnxt_features_check(struct sk_buff *skb,\n\t\t\t\t\t     struct net_device *dev,\n\t\t\t\t\t     netdev_features_t features)\n{\n\tstruct bnxt *bp = netdev_priv(dev);\n\tu8 *l4_proto;\n\n\tfeatures = vlan_features_check(skb, features);\n\tswitch (vlan_get_protocol(skb)) {\n\tcase htons(ETH_P_IP):\n\t\tif (!skb->encapsulation)\n\t\t\treturn features;\n\t\tl4_proto = &ip_hdr(skb)->protocol;\n\t\tif (bnxt_tunl_check(bp, skb, *l4_proto))\n\t\t\treturn features;\n\t\tbreak;\n\tcase htons(ETH_P_IPV6):\n\t\tif (!bnxt_exthdr_check(bp, skb, skb_network_offset(skb),\n\t\t\t\t       &l4_proto))\n\t\t\tbreak;\n\t\tif (!l4_proto || bnxt_tunl_check(bp, skb, *l4_proto))\n\t\t\treturn features;\n\t\tbreak;\n\t}\n\treturn features & ~(NETIF_F_CSUM_MASK | NETIF_F_GSO_MASK);\n}\n\nint bnxt_dbg_hwrm_rd_reg(struct bnxt *bp, u32 reg_off, u16 num_words,\n\t\t\t u32 *reg_buf)\n{\n\tstruct hwrm_dbg_read_direct_output *resp;\n\tstruct hwrm_dbg_read_direct_input *req;\n\t__le32 *dbg_reg_buf;\n\tdma_addr_t mapping;\n\tint rc, i;\n\n\trc = hwrm_req_init(bp, req, HWRM_DBG_READ_DIRECT);\n\tif (rc)\n\t\treturn rc;\n\n\tdbg_reg_buf = hwrm_req_dma_slice(bp, req, num_words * 4,\n\t\t\t\t\t &mapping);\n\tif (!dbg_reg_buf) {\n\t\trc = -ENOMEM;\n\t\tgoto dbg_rd_reg_exit;\n\t}\n\n\treq->host_dest_addr = cpu_to_le64(mapping);\n\n\tresp = hwrm_req_hold(bp, req);\n\treq->read_addr = cpu_to_le32(reg_off + CHIMP_REG_VIEW_ADDR);\n\treq->read_len32 = cpu_to_le32(num_words);\n\n\trc = hwrm_req_send(bp, req);\n\tif (rc || resp->error_code) {\n\t\trc = -EIO;\n\t\tgoto dbg_rd_reg_exit;\n\t}\n\tfor (i = 0; i < num_words; i++)\n\t\treg_buf[i] = le32_to_cpu(dbg_reg_buf[i]);\n\ndbg_rd_reg_exit:\n\thwrm_req_drop(bp, req);\n\treturn rc;\n}\n\nstatic int bnxt_dbg_hwrm_ring_info_get(struct bnxt *bp, u8 ring_type,\n\t\t\t\t       u32 ring_id, u32 *prod, u32 *cons)\n{\n\tstruct hwrm_dbg_ring_info_get_output *resp;\n\tstruct hwrm_dbg_ring_info_get_input *req;\n\tint rc;\n\n\trc = hwrm_req_init(bp, req, HWRM_DBG_RING_INFO_GET);\n\tif (rc)\n\t\treturn rc;\n\n\treq->ring_type = ring_type;\n\treq->fw_ring_id = cpu_to_le32(ring_id);\n\tresp = hwrm_req_hold(bp, req);\n\trc = hwrm_req_send(bp, req);\n\tif (!rc) {\n\t\t*prod = le32_to_cpu(resp->producer_index);\n\t\t*cons = le32_to_cpu(resp->consumer_index);\n\t}\n\thwrm_req_drop(bp, req);\n\treturn rc;\n}\n\nstatic void bnxt_dump_tx_sw_state(struct bnxt_napi *bnapi)\n{\n\tstruct bnxt_tx_ring_info *txr = bnapi->tx_ring;\n\tint i = bnapi->index;\n\n\tif (!txr)\n\t\treturn;\n\n\tnetdev_info(bnapi->bp->dev, \"[%d]: tx{fw_ring: %d prod: %x cons: %x}\\n\",\n\t\t    i, txr->tx_ring_struct.fw_ring_id, txr->tx_prod,\n\t\t    txr->tx_cons);\n}\n\nstatic void bnxt_dump_rx_sw_state(struct bnxt_napi *bnapi)\n{\n\tstruct bnxt_rx_ring_info *rxr = bnapi->rx_ring;\n\tint i = bnapi->index;\n\n\tif (!rxr)\n\t\treturn;\n\n\tnetdev_info(bnapi->bp->dev, \"[%d]: rx{fw_ring: %d prod: %x} rx_agg{fw_ring: %d agg_prod: %x sw_agg_prod: %x}\\n\",\n\t\t    i, rxr->rx_ring_struct.fw_ring_id, rxr->rx_prod,\n\t\t    rxr->rx_agg_ring_struct.fw_ring_id, rxr->rx_agg_prod,\n\t\t    rxr->rx_sw_agg_prod);\n}\n\nstatic void bnxt_dump_cp_sw_state(struct bnxt_napi *bnapi)\n{\n\tstruct bnxt_cp_ring_info *cpr = &bnapi->cp_ring;\n\tint i = bnapi->index;\n\n\tnetdev_info(bnapi->bp->dev, \"[%d]: cp{fw_ring: %d raw_cons: %x}\\n\",\n\t\t    i, cpr->cp_ring_struct.fw_ring_id, cpr->cp_raw_cons);\n}\n\nstatic void bnxt_dbg_dump_states(struct bnxt *bp)\n{\n\tint i;\n\tstruct bnxt_napi *bnapi;\n\n\tfor (i = 0; i < bp->cp_nr_rings; i++) {\n\t\tbnapi = bp->bnapi[i];\n\t\tif (netif_msg_drv(bp)) {\n\t\t\tbnxt_dump_tx_sw_state(bnapi);\n\t\t\tbnxt_dump_rx_sw_state(bnapi);\n\t\t\tbnxt_dump_cp_sw_state(bnapi);\n\t\t}\n\t}\n}\n\nstatic int bnxt_hwrm_rx_ring_reset(struct bnxt *bp, int ring_nr)\n{\n\tstruct bnxt_rx_ring_info *rxr = &bp->rx_ring[ring_nr];\n\tstruct hwrm_ring_reset_input *req;\n\tstruct bnxt_napi *bnapi = rxr->bnapi;\n\tstruct bnxt_cp_ring_info *cpr;\n\tu16 cp_ring_id;\n\tint rc;\n\n\trc = hwrm_req_init(bp, req, HWRM_RING_RESET);\n\tif (rc)\n\t\treturn rc;\n\n\tcpr = &bnapi->cp_ring;\n\tcp_ring_id = cpr->cp_ring_struct.fw_ring_id;\n\treq->cmpl_ring = cpu_to_le16(cp_ring_id);\n\treq->ring_type = RING_RESET_REQ_RING_TYPE_RX_RING_GRP;\n\treq->ring_id = cpu_to_le16(bp->grp_info[bnapi->index].fw_grp_id);\n\treturn hwrm_req_send_silent(bp, req);\n}\n\nstatic void bnxt_reset_task(struct bnxt *bp, bool silent)\n{\n\tif (!silent)\n\t\tbnxt_dbg_dump_states(bp);\n\tif (netif_running(bp->dev)) {\n\t\tint rc;\n\n\t\tif (silent) {\n\t\t\tbnxt_close_nic(bp, false, false);\n\t\t\tbnxt_open_nic(bp, false, false);\n\t\t} else {\n\t\t\tbnxt_ulp_stop(bp);\n\t\t\tbnxt_close_nic(bp, true, false);\n\t\t\trc = bnxt_open_nic(bp, true, false);\n\t\t\tbnxt_ulp_start(bp, rc);\n\t\t}\n\t}\n}\n\nstatic void bnxt_tx_timeout(struct net_device *dev, unsigned int txqueue)\n{\n\tstruct bnxt *bp = netdev_priv(dev);\n\n\tnetdev_err(bp->dev,  \"TX timeout detected, starting reset task!\\n\");\n\tbnxt_queue_sp_work(bp, BNXT_RESET_TASK_SP_EVENT);\n}\n\nstatic void bnxt_fw_health_check(struct bnxt *bp)\n{\n\tstruct bnxt_fw_health *fw_health = bp->fw_health;\n\tstruct pci_dev *pdev = bp->pdev;\n\tu32 val;\n\n\tif (!fw_health->enabled || test_bit(BNXT_STATE_IN_FW_RESET, &bp->state))\n\t\treturn;\n\n\t \n\tsmp_rmb();\n\tif (fw_health->tmr_counter) {\n\t\tfw_health->tmr_counter--;\n\t\treturn;\n\t}\n\n\tval = bnxt_fw_health_readl(bp, BNXT_FW_HEARTBEAT_REG);\n\tif (val == fw_health->last_fw_heartbeat && pci_device_is_present(pdev)) {\n\t\tfw_health->arrests++;\n\t\tgoto fw_reset;\n\t}\n\n\tfw_health->last_fw_heartbeat = val;\n\n\tval = bnxt_fw_health_readl(bp, BNXT_FW_RESET_CNT_REG);\n\tif (val != fw_health->last_fw_reset_cnt && pci_device_is_present(pdev)) {\n\t\tfw_health->discoveries++;\n\t\tgoto fw_reset;\n\t}\n\n\tfw_health->tmr_counter = fw_health->tmr_multiplier;\n\treturn;\n\nfw_reset:\n\tbnxt_queue_sp_work(bp, BNXT_FW_EXCEPTION_SP_EVENT);\n}\n\nstatic void bnxt_timer(struct timer_list *t)\n{\n\tstruct bnxt *bp = from_timer(bp, t, timer);\n\tstruct net_device *dev = bp->dev;\n\n\tif (!netif_running(dev) || !test_bit(BNXT_STATE_OPEN, &bp->state))\n\t\treturn;\n\n\tif (atomic_read(&bp->intr_sem) != 0)\n\t\tgoto bnxt_restart_timer;\n\n\tif (bp->fw_cap & BNXT_FW_CAP_ERROR_RECOVERY)\n\t\tbnxt_fw_health_check(bp);\n\n\tif (BNXT_LINK_IS_UP(bp) && bp->stats_coal_ticks)\n\t\tbnxt_queue_sp_work(bp, BNXT_PERIODIC_STATS_SP_EVENT);\n\n\tif (bnxt_tc_flower_enabled(bp))\n\t\tbnxt_queue_sp_work(bp, BNXT_FLOW_STATS_SP_EVENT);\n\n#ifdef CONFIG_RFS_ACCEL\n\tif ((bp->flags & BNXT_FLAG_RFS) && bp->ntp_fltr_count)\n\t\tbnxt_queue_sp_work(bp, BNXT_RX_NTP_FLTR_SP_EVENT);\n#endif  \n\n\tif (bp->link_info.phy_retry) {\n\t\tif (time_after(jiffies, bp->link_info.phy_retry_expires)) {\n\t\t\tbp->link_info.phy_retry = false;\n\t\t\tnetdev_warn(bp->dev, \"failed to update phy settings after maximum retries.\\n\");\n\t\t} else {\n\t\t\tbnxt_queue_sp_work(bp, BNXT_UPDATE_PHY_SP_EVENT);\n\t\t}\n\t}\n\n\tif (test_bit(BNXT_STATE_L2_FILTER_RETRY, &bp->state))\n\t\tbnxt_queue_sp_work(bp, BNXT_RX_MASK_SP_EVENT);\n\n\tif ((bp->flags & BNXT_FLAG_CHIP_P5) && !bp->chip_rev &&\n\t    netif_carrier_ok(dev))\n\t\tbnxt_queue_sp_work(bp, BNXT_RING_COAL_NOW_SP_EVENT);\n\nbnxt_restart_timer:\n\tmod_timer(&bp->timer, jiffies + bp->current_interval);\n}\n\nstatic void bnxt_rtnl_lock_sp(struct bnxt *bp)\n{\n\t \n\tclear_bit(BNXT_STATE_IN_SP_TASK, &bp->state);\n\trtnl_lock();\n}\n\nstatic void bnxt_rtnl_unlock_sp(struct bnxt *bp)\n{\n\tset_bit(BNXT_STATE_IN_SP_TASK, &bp->state);\n\trtnl_unlock();\n}\n\n \nstatic void bnxt_reset(struct bnxt *bp, bool silent)\n{\n\tbnxt_rtnl_lock_sp(bp);\n\tif (test_bit(BNXT_STATE_OPEN, &bp->state))\n\t\tbnxt_reset_task(bp, silent);\n\tbnxt_rtnl_unlock_sp(bp);\n}\n\n \nstatic void bnxt_rx_ring_reset(struct bnxt *bp)\n{\n\tint i;\n\n\tbnxt_rtnl_lock_sp(bp);\n\tif (!test_bit(BNXT_STATE_OPEN, &bp->state)) {\n\t\tbnxt_rtnl_unlock_sp(bp);\n\t\treturn;\n\t}\n\t \n\tif (bp->flags & BNXT_FLAG_TPA)\n\t\tbnxt_set_tpa(bp, false);\n\tfor (i = 0; i < bp->rx_nr_rings; i++) {\n\t\tstruct bnxt_rx_ring_info *rxr = &bp->rx_ring[i];\n\t\tstruct bnxt_cp_ring_info *cpr;\n\t\tint rc;\n\n\t\tif (!rxr->bnapi->in_reset)\n\t\t\tcontinue;\n\n\t\trc = bnxt_hwrm_rx_ring_reset(bp, i);\n\t\tif (rc) {\n\t\t\tif (rc == -EINVAL || rc == -EOPNOTSUPP)\n\t\t\t\tnetdev_info_once(bp->dev, \"RX ring reset not supported by firmware, falling back to global reset\\n\");\n\t\t\telse\n\t\t\t\tnetdev_warn(bp->dev, \"RX ring reset failed, rc = %d, falling back to global reset\\n\",\n\t\t\t\t\t    rc);\n\t\t\tbnxt_reset_task(bp, true);\n\t\t\tbreak;\n\t\t}\n\t\tbnxt_free_one_rx_ring_skbs(bp, i);\n\t\trxr->rx_prod = 0;\n\t\trxr->rx_agg_prod = 0;\n\t\trxr->rx_sw_agg_prod = 0;\n\t\trxr->rx_next_cons = 0;\n\t\trxr->bnapi->in_reset = false;\n\t\tbnxt_alloc_one_rx_ring(bp, i);\n\t\tcpr = &rxr->bnapi->cp_ring;\n\t\tcpr->sw_stats.rx.rx_resets++;\n\t\tif (bp->flags & BNXT_FLAG_AGG_RINGS)\n\t\t\tbnxt_db_write(bp, &rxr->rx_agg_db, rxr->rx_agg_prod);\n\t\tbnxt_db_write(bp, &rxr->rx_db, rxr->rx_prod);\n\t}\n\tif (bp->flags & BNXT_FLAG_TPA)\n\t\tbnxt_set_tpa(bp, true);\n\tbnxt_rtnl_unlock_sp(bp);\n}\n\nstatic void bnxt_fw_reset_close(struct bnxt *bp)\n{\n\tbnxt_ulp_stop(bp);\n\t \n\tif (test_bit(BNXT_STATE_FW_FATAL_COND, &bp->state)) {\n\t\tu16 val = 0;\n\n\t\tpci_read_config_word(bp->pdev, PCI_SUBSYSTEM_ID, &val);\n\t\tif (val == 0xffff)\n\t\t\tbp->fw_reset_min_dsecs = 0;\n\t\tbnxt_tx_disable(bp);\n\t\tbnxt_disable_napi(bp);\n\t\tbnxt_disable_int_sync(bp);\n\t\tbnxt_free_irq(bp);\n\t\tbnxt_clear_int_mode(bp);\n\t\tpci_disable_device(bp->pdev);\n\t}\n\t__bnxt_close_nic(bp, true, false);\n\tbnxt_vf_reps_free(bp);\n\tbnxt_clear_int_mode(bp);\n\tbnxt_hwrm_func_drv_unrgtr(bp);\n\tif (pci_is_enabled(bp->pdev))\n\t\tpci_disable_device(bp->pdev);\n\tbnxt_free_ctx_mem(bp);\n\tkfree(bp->ctx);\n\tbp->ctx = NULL;\n}\n\nstatic bool is_bnxt_fw_ok(struct bnxt *bp)\n{\n\tstruct bnxt_fw_health *fw_health = bp->fw_health;\n\tbool no_heartbeat = false, has_reset = false;\n\tu32 val;\n\n\tval = bnxt_fw_health_readl(bp, BNXT_FW_HEARTBEAT_REG);\n\tif (val == fw_health->last_fw_heartbeat)\n\t\tno_heartbeat = true;\n\n\tval = bnxt_fw_health_readl(bp, BNXT_FW_RESET_CNT_REG);\n\tif (val != fw_health->last_fw_reset_cnt)\n\t\thas_reset = true;\n\n\tif (!no_heartbeat && has_reset)\n\t\treturn true;\n\n\treturn false;\n}\n\n \nstatic void bnxt_force_fw_reset(struct bnxt *bp)\n{\n\tstruct bnxt_fw_health *fw_health = bp->fw_health;\n\tstruct bnxt_ptp_cfg *ptp = bp->ptp_cfg;\n\tu32 wait_dsecs;\n\n\tif (!test_bit(BNXT_STATE_OPEN, &bp->state) ||\n\t    test_bit(BNXT_STATE_IN_FW_RESET, &bp->state))\n\t\treturn;\n\n\tif (ptp) {\n\t\tspin_lock_bh(&ptp->ptp_lock);\n\t\tset_bit(BNXT_STATE_IN_FW_RESET, &bp->state);\n\t\tspin_unlock_bh(&ptp->ptp_lock);\n\t} else {\n\t\tset_bit(BNXT_STATE_IN_FW_RESET, &bp->state);\n\t}\n\tbnxt_fw_reset_close(bp);\n\twait_dsecs = fw_health->master_func_wait_dsecs;\n\tif (fw_health->primary) {\n\t\tif (fw_health->flags & ERROR_RECOVERY_QCFG_RESP_FLAGS_CO_CPU)\n\t\t\twait_dsecs = 0;\n\t\tbp->fw_reset_state = BNXT_FW_RESET_STATE_RESET_FW;\n\t} else {\n\t\tbp->fw_reset_timestamp = jiffies + wait_dsecs * HZ / 10;\n\t\twait_dsecs = fw_health->normal_func_wait_dsecs;\n\t\tbp->fw_reset_state = BNXT_FW_RESET_STATE_ENABLE_DEV;\n\t}\n\n\tbp->fw_reset_min_dsecs = fw_health->post_reset_wait_dsecs;\n\tbp->fw_reset_max_dsecs = fw_health->post_reset_max_wait_dsecs;\n\tbnxt_queue_fw_reset_work(bp, wait_dsecs * HZ / 10);\n}\n\nvoid bnxt_fw_exception(struct bnxt *bp)\n{\n\tnetdev_warn(bp->dev, \"Detected firmware fatal condition, initiating reset\\n\");\n\tset_bit(BNXT_STATE_FW_FATAL_COND, &bp->state);\n\tbnxt_rtnl_lock_sp(bp);\n\tbnxt_force_fw_reset(bp);\n\tbnxt_rtnl_unlock_sp(bp);\n}\n\n \nstatic int bnxt_get_registered_vfs(struct bnxt *bp)\n{\n#ifdef CONFIG_BNXT_SRIOV\n\tint rc;\n\n\tif (!BNXT_PF(bp))\n\t\treturn 0;\n\n\trc = bnxt_hwrm_func_qcfg(bp);\n\tif (rc) {\n\t\tnetdev_err(bp->dev, \"func_qcfg cmd failed, rc = %d\\n\", rc);\n\t\treturn rc;\n\t}\n\tif (bp->pf.registered_vfs)\n\t\treturn bp->pf.registered_vfs;\n\tif (bp->sriov_cfg)\n\t\treturn 1;\n#endif\n\treturn 0;\n}\n\nvoid bnxt_fw_reset(struct bnxt *bp)\n{\n\tbnxt_rtnl_lock_sp(bp);\n\tif (test_bit(BNXT_STATE_OPEN, &bp->state) &&\n\t    !test_bit(BNXT_STATE_IN_FW_RESET, &bp->state)) {\n\t\tstruct bnxt_ptp_cfg *ptp = bp->ptp_cfg;\n\t\tint n = 0, tmo;\n\n\t\tif (ptp) {\n\t\t\tspin_lock_bh(&ptp->ptp_lock);\n\t\t\tset_bit(BNXT_STATE_IN_FW_RESET, &bp->state);\n\t\t\tspin_unlock_bh(&ptp->ptp_lock);\n\t\t} else {\n\t\t\tset_bit(BNXT_STATE_IN_FW_RESET, &bp->state);\n\t\t}\n\t\tif (bp->pf.active_vfs &&\n\t\t    !test_bit(BNXT_STATE_FW_FATAL_COND, &bp->state))\n\t\t\tn = bnxt_get_registered_vfs(bp);\n\t\tif (n < 0) {\n\t\t\tnetdev_err(bp->dev, \"Firmware reset aborted, rc = %d\\n\",\n\t\t\t\t   n);\n\t\t\tclear_bit(BNXT_STATE_IN_FW_RESET, &bp->state);\n\t\t\tdev_close(bp->dev);\n\t\t\tgoto fw_reset_exit;\n\t\t} else if (n > 0) {\n\t\t\tu16 vf_tmo_dsecs = n * 10;\n\n\t\t\tif (bp->fw_reset_max_dsecs < vf_tmo_dsecs)\n\t\t\t\tbp->fw_reset_max_dsecs = vf_tmo_dsecs;\n\t\t\tbp->fw_reset_state =\n\t\t\t\tBNXT_FW_RESET_STATE_POLL_VF;\n\t\t\tbnxt_queue_fw_reset_work(bp, HZ / 10);\n\t\t\tgoto fw_reset_exit;\n\t\t}\n\t\tbnxt_fw_reset_close(bp);\n\t\tif (bp->fw_cap & BNXT_FW_CAP_ERR_RECOVER_RELOAD) {\n\t\t\tbp->fw_reset_state = BNXT_FW_RESET_STATE_POLL_FW_DOWN;\n\t\t\ttmo = HZ / 10;\n\t\t} else {\n\t\t\tbp->fw_reset_state = BNXT_FW_RESET_STATE_ENABLE_DEV;\n\t\t\ttmo = bp->fw_reset_min_dsecs * HZ / 10;\n\t\t}\n\t\tbnxt_queue_fw_reset_work(bp, tmo);\n\t}\nfw_reset_exit:\n\tbnxt_rtnl_unlock_sp(bp);\n}\n\nstatic void bnxt_chk_missed_irq(struct bnxt *bp)\n{\n\tint i;\n\n\tif (!(bp->flags & BNXT_FLAG_CHIP_P5))\n\t\treturn;\n\n\tfor (i = 0; i < bp->cp_nr_rings; i++) {\n\t\tstruct bnxt_napi *bnapi = bp->bnapi[i];\n\t\tstruct bnxt_cp_ring_info *cpr;\n\t\tu32 fw_ring_id;\n\t\tint j;\n\n\t\tif (!bnapi)\n\t\t\tcontinue;\n\n\t\tcpr = &bnapi->cp_ring;\n\t\tfor (j = 0; j < 2; j++) {\n\t\t\tstruct bnxt_cp_ring_info *cpr2 = cpr->cp_ring_arr[j];\n\t\t\tu32 val[2];\n\n\t\t\tif (!cpr2 || cpr2->has_more_work ||\n\t\t\t    !bnxt_has_work(bp, cpr2))\n\t\t\t\tcontinue;\n\n\t\t\tif (cpr2->cp_raw_cons != cpr2->last_cp_raw_cons) {\n\t\t\t\tcpr2->last_cp_raw_cons = cpr2->cp_raw_cons;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfw_ring_id = cpr2->cp_ring_struct.fw_ring_id;\n\t\t\tbnxt_dbg_hwrm_ring_info_get(bp,\n\t\t\t\tDBG_RING_INFO_GET_REQ_RING_TYPE_L2_CMPL,\n\t\t\t\tfw_ring_id, &val[0], &val[1]);\n\t\t\tcpr->sw_stats.cmn.missed_irqs++;\n\t\t}\n\t}\n}\n\nstatic void bnxt_cfg_ntp_filters(struct bnxt *);\n\nstatic void bnxt_init_ethtool_link_settings(struct bnxt *bp)\n{\n\tstruct bnxt_link_info *link_info = &bp->link_info;\n\n\tif (BNXT_AUTO_MODE(link_info->auto_mode)) {\n\t\tlink_info->autoneg = BNXT_AUTONEG_SPEED;\n\t\tif (bp->hwrm_spec_code >= 0x10201) {\n\t\t\tif (link_info->auto_pause_setting &\n\t\t\t    PORT_PHY_CFG_REQ_AUTO_PAUSE_AUTONEG_PAUSE)\n\t\t\t\tlink_info->autoneg |= BNXT_AUTONEG_FLOW_CTRL;\n\t\t} else {\n\t\t\tlink_info->autoneg |= BNXT_AUTONEG_FLOW_CTRL;\n\t\t}\n\t\tlink_info->advertising = link_info->auto_link_speeds;\n\t\tlink_info->advertising_pam4 = link_info->auto_pam4_link_speeds;\n\t} else {\n\t\tlink_info->req_link_speed = link_info->force_link_speed;\n\t\tlink_info->req_signal_mode = BNXT_SIG_MODE_NRZ;\n\t\tif (link_info->force_pam4_link_speed) {\n\t\t\tlink_info->req_link_speed =\n\t\t\t\tlink_info->force_pam4_link_speed;\n\t\t\tlink_info->req_signal_mode = BNXT_SIG_MODE_PAM4;\n\t\t}\n\t\tlink_info->req_duplex = link_info->duplex_setting;\n\t}\n\tif (link_info->autoneg & BNXT_AUTONEG_FLOW_CTRL)\n\t\tlink_info->req_flow_ctrl =\n\t\t\tlink_info->auto_pause_setting & BNXT_LINK_PAUSE_BOTH;\n\telse\n\t\tlink_info->req_flow_ctrl = link_info->force_pause_setting;\n}\n\nstatic void bnxt_fw_echo_reply(struct bnxt *bp)\n{\n\tstruct bnxt_fw_health *fw_health = bp->fw_health;\n\tstruct hwrm_func_echo_response_input *req;\n\tint rc;\n\n\trc = hwrm_req_init(bp, req, HWRM_FUNC_ECHO_RESPONSE);\n\tif (rc)\n\t\treturn;\n\treq->event_data1 = cpu_to_le32(fw_health->echo_req_data1);\n\treq->event_data2 = cpu_to_le32(fw_health->echo_req_data2);\n\thwrm_req_send(bp, req);\n}\n\nstatic void bnxt_sp_task(struct work_struct *work)\n{\n\tstruct bnxt *bp = container_of(work, struct bnxt, sp_task);\n\n\tset_bit(BNXT_STATE_IN_SP_TASK, &bp->state);\n\tsmp_mb__after_atomic();\n\tif (!test_bit(BNXT_STATE_OPEN, &bp->state)) {\n\t\tclear_bit(BNXT_STATE_IN_SP_TASK, &bp->state);\n\t\treturn;\n\t}\n\n\tif (test_and_clear_bit(BNXT_RX_MASK_SP_EVENT, &bp->sp_event))\n\t\tbnxt_cfg_rx_mode(bp);\n\n\tif (test_and_clear_bit(BNXT_RX_NTP_FLTR_SP_EVENT, &bp->sp_event))\n\t\tbnxt_cfg_ntp_filters(bp);\n\tif (test_and_clear_bit(BNXT_HWRM_EXEC_FWD_REQ_SP_EVENT, &bp->sp_event))\n\t\tbnxt_hwrm_exec_fwd_req(bp);\n\tif (test_and_clear_bit(BNXT_HWRM_PF_UNLOAD_SP_EVENT, &bp->sp_event))\n\t\tnetdev_info(bp->dev, \"Receive PF driver unload event!\\n\");\n\tif (test_and_clear_bit(BNXT_PERIODIC_STATS_SP_EVENT, &bp->sp_event)) {\n\t\tbnxt_hwrm_port_qstats(bp, 0);\n\t\tbnxt_hwrm_port_qstats_ext(bp, 0);\n\t\tbnxt_accumulate_all_stats(bp);\n\t}\n\n\tif (test_and_clear_bit(BNXT_LINK_CHNG_SP_EVENT, &bp->sp_event)) {\n\t\tint rc;\n\n\t\tmutex_lock(&bp->link_lock);\n\t\tif (test_and_clear_bit(BNXT_LINK_SPEED_CHNG_SP_EVENT,\n\t\t\t\t       &bp->sp_event))\n\t\t\tbnxt_hwrm_phy_qcaps(bp);\n\n\t\trc = bnxt_update_link(bp, true);\n\t\tif (rc)\n\t\t\tnetdev_err(bp->dev, \"SP task can't update link (rc: %x)\\n\",\n\t\t\t\t   rc);\n\n\t\tif (test_and_clear_bit(BNXT_LINK_CFG_CHANGE_SP_EVENT,\n\t\t\t\t       &bp->sp_event))\n\t\t\tbnxt_init_ethtool_link_settings(bp);\n\t\tmutex_unlock(&bp->link_lock);\n\t}\n\tif (test_and_clear_bit(BNXT_UPDATE_PHY_SP_EVENT, &bp->sp_event)) {\n\t\tint rc;\n\n\t\tmutex_lock(&bp->link_lock);\n\t\trc = bnxt_update_phy_setting(bp);\n\t\tmutex_unlock(&bp->link_lock);\n\t\tif (rc) {\n\t\t\tnetdev_warn(bp->dev, \"update phy settings retry failed\\n\");\n\t\t} else {\n\t\t\tbp->link_info.phy_retry = false;\n\t\t\tnetdev_info(bp->dev, \"update phy settings retry succeeded\\n\");\n\t\t}\n\t}\n\tif (test_and_clear_bit(BNXT_HWRM_PORT_MODULE_SP_EVENT, &bp->sp_event)) {\n\t\tmutex_lock(&bp->link_lock);\n\t\tbnxt_get_port_module_status(bp);\n\t\tmutex_unlock(&bp->link_lock);\n\t}\n\n\tif (test_and_clear_bit(BNXT_FLOW_STATS_SP_EVENT, &bp->sp_event))\n\t\tbnxt_tc_flow_stats_work(bp);\n\n\tif (test_and_clear_bit(BNXT_RING_COAL_NOW_SP_EVENT, &bp->sp_event))\n\t\tbnxt_chk_missed_irq(bp);\n\n\tif (test_and_clear_bit(BNXT_FW_ECHO_REQUEST_SP_EVENT, &bp->sp_event))\n\t\tbnxt_fw_echo_reply(bp);\n\n\t \n\tif (test_and_clear_bit(BNXT_RESET_TASK_SP_EVENT, &bp->sp_event))\n\t\tbnxt_reset(bp, false);\n\n\tif (test_and_clear_bit(BNXT_RESET_TASK_SILENT_SP_EVENT, &bp->sp_event))\n\t\tbnxt_reset(bp, true);\n\n\tif (test_and_clear_bit(BNXT_RST_RING_SP_EVENT, &bp->sp_event))\n\t\tbnxt_rx_ring_reset(bp);\n\n\tif (test_and_clear_bit(BNXT_FW_RESET_NOTIFY_SP_EVENT, &bp->sp_event)) {\n\t\tif (test_bit(BNXT_STATE_FW_FATAL_COND, &bp->state) ||\n\t\t    test_bit(BNXT_STATE_FW_NON_FATAL_COND, &bp->state))\n\t\t\tbnxt_devlink_health_fw_report(bp);\n\t\telse\n\t\t\tbnxt_fw_reset(bp);\n\t}\n\n\tif (test_and_clear_bit(BNXT_FW_EXCEPTION_SP_EVENT, &bp->sp_event)) {\n\t\tif (!is_bnxt_fw_ok(bp))\n\t\t\tbnxt_devlink_health_fw_report(bp);\n\t}\n\n\tsmp_mb__before_atomic();\n\tclear_bit(BNXT_STATE_IN_SP_TASK, &bp->state);\n}\n\n \nint bnxt_check_rings(struct bnxt *bp, int tx, int rx, bool sh, int tcs,\n\t\t     int tx_xdp)\n{\n\tint max_rx, max_tx, tx_sets = 1;\n\tint tx_rings_needed, stats;\n\tint rx_rings = rx;\n\tint cp, vnics, rc;\n\n\tif (tcs)\n\t\ttx_sets = tcs;\n\n\trc = bnxt_get_max_rings(bp, &max_rx, &max_tx, sh);\n\tif (rc)\n\t\treturn rc;\n\n\tif (max_rx < rx)\n\t\treturn -ENOMEM;\n\n\ttx_rings_needed = tx * tx_sets + tx_xdp;\n\tif (max_tx < tx_rings_needed)\n\t\treturn -ENOMEM;\n\n\tvnics = 1;\n\tif ((bp->flags & (BNXT_FLAG_RFS | BNXT_FLAG_CHIP_P5)) == BNXT_FLAG_RFS)\n\t\tvnics += rx_rings;\n\n\tif (bp->flags & BNXT_FLAG_AGG_RINGS)\n\t\trx_rings <<= 1;\n\tcp = sh ? max_t(int, tx_rings_needed, rx) : tx_rings_needed + rx;\n\tstats = cp;\n\tif (BNXT_NEW_RM(bp)) {\n\t\tcp += bnxt_get_ulp_msix_num(bp);\n\t\tstats += bnxt_get_ulp_stat_ctxs(bp);\n\t}\n\treturn bnxt_hwrm_check_rings(bp, tx_rings_needed, rx_rings, rx, cp,\n\t\t\t\t     stats, vnics);\n}\n\nstatic void bnxt_unmap_bars(struct bnxt *bp, struct pci_dev *pdev)\n{\n\tif (bp->bar2) {\n\t\tpci_iounmap(pdev, bp->bar2);\n\t\tbp->bar2 = NULL;\n\t}\n\n\tif (bp->bar1) {\n\t\tpci_iounmap(pdev, bp->bar1);\n\t\tbp->bar1 = NULL;\n\t}\n\n\tif (bp->bar0) {\n\t\tpci_iounmap(pdev, bp->bar0);\n\t\tbp->bar0 = NULL;\n\t}\n}\n\nstatic void bnxt_cleanup_pci(struct bnxt *bp)\n{\n\tbnxt_unmap_bars(bp, bp->pdev);\n\tpci_release_regions(bp->pdev);\n\tif (pci_is_enabled(bp->pdev))\n\t\tpci_disable_device(bp->pdev);\n}\n\nstatic void bnxt_init_dflt_coal(struct bnxt *bp)\n{\n\tstruct bnxt_coal_cap *coal_cap = &bp->coal_cap;\n\tstruct bnxt_coal *coal;\n\tu16 flags = 0;\n\n\tif (coal_cap->cmpl_params &\n\t    RING_AGGINT_QCAPS_RESP_CMPL_PARAMS_TIMER_RESET)\n\t\tflags |= RING_CMPL_RING_CFG_AGGINT_PARAMS_REQ_FLAGS_TIMER_RESET;\n\n\t \n\tcoal = &bp->rx_coal;\n\tcoal->coal_ticks = 10;\n\tcoal->coal_bufs = 30;\n\tcoal->coal_ticks_irq = 1;\n\tcoal->coal_bufs_irq = 2;\n\tcoal->idle_thresh = 50;\n\tcoal->bufs_per_record = 2;\n\tcoal->budget = 64;\t\t \n\tcoal->flags = flags;\n\n\tcoal = &bp->tx_coal;\n\tcoal->coal_ticks = 28;\n\tcoal->coal_bufs = 30;\n\tcoal->coal_ticks_irq = 2;\n\tcoal->coal_bufs_irq = 2;\n\tcoal->bufs_per_record = 1;\n\tcoal->flags = flags;\n\n\tbp->stats_coal_ticks = BNXT_DEF_STATS_COAL_TICKS;\n}\n\nstatic int bnxt_fw_init_one_p1(struct bnxt *bp)\n{\n\tint rc;\n\n\tbp->fw_cap = 0;\n\trc = bnxt_hwrm_ver_get(bp);\n\tbnxt_try_map_fw_health_reg(bp);\n\tif (rc) {\n\t\trc = bnxt_try_recover_fw(bp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\trc = bnxt_hwrm_ver_get(bp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\tbnxt_nvm_cfg_ver_get(bp);\n\n\trc = bnxt_hwrm_func_reset(bp);\n\tif (rc)\n\t\treturn -ENODEV;\n\n\tbnxt_hwrm_fw_set_time(bp);\n\treturn 0;\n}\n\nstatic int bnxt_fw_init_one_p2(struct bnxt *bp)\n{\n\tint rc;\n\n\t \n\trc = bnxt_hwrm_func_qcaps(bp);\n\tif (rc) {\n\t\tnetdev_err(bp->dev, \"hwrm query capability failure rc: %x\\n\",\n\t\t\t   rc);\n\t\treturn -ENODEV;\n\t}\n\n\trc = bnxt_hwrm_cfa_adv_flow_mgnt_qcaps(bp);\n\tif (rc)\n\t\tnetdev_warn(bp->dev, \"hwrm query adv flow mgnt failure rc: %d\\n\",\n\t\t\t    rc);\n\n\tif (bnxt_alloc_fw_health(bp)) {\n\t\tnetdev_warn(bp->dev, \"no memory for firmware error recovery\\n\");\n\t} else {\n\t\trc = bnxt_hwrm_error_recovery_qcfg(bp);\n\t\tif (rc)\n\t\t\tnetdev_warn(bp->dev, \"hwrm query error recovery failure rc: %d\\n\",\n\t\t\t\t    rc);\n\t}\n\n\trc = bnxt_hwrm_func_drv_rgtr(bp, NULL, 0, false);\n\tif (rc)\n\t\treturn -ENODEV;\n\n\tbnxt_hwrm_func_qcfg(bp);\n\tbnxt_hwrm_vnic_qcaps(bp);\n\tbnxt_hwrm_port_led_qcaps(bp);\n\tbnxt_ethtool_init(bp);\n\tif (bp->fw_cap & BNXT_FW_CAP_PTP)\n\t\t__bnxt_hwrm_ptp_qcfg(bp);\n\tbnxt_dcb_init(bp);\n\treturn 0;\n}\n\nstatic void bnxt_set_dflt_rss_hash_type(struct bnxt *bp)\n{\n\tbp->flags &= ~BNXT_FLAG_UDP_RSS_CAP;\n\tbp->rss_hash_cfg = VNIC_RSS_CFG_REQ_HASH_TYPE_IPV4 |\n\t\t\t   VNIC_RSS_CFG_REQ_HASH_TYPE_TCP_IPV4 |\n\t\t\t   VNIC_RSS_CFG_REQ_HASH_TYPE_IPV6 |\n\t\t\t   VNIC_RSS_CFG_REQ_HASH_TYPE_TCP_IPV6;\n\tif (bp->fw_cap & BNXT_FW_CAP_RSS_HASH_TYPE_DELTA)\n\t\tbp->rss_hash_delta = bp->rss_hash_cfg;\n\tif (BNXT_CHIP_P4_PLUS(bp) && bp->hwrm_spec_code >= 0x10501) {\n\t\tbp->flags |= BNXT_FLAG_UDP_RSS_CAP;\n\t\tbp->rss_hash_cfg |= VNIC_RSS_CFG_REQ_HASH_TYPE_UDP_IPV4 |\n\t\t\t\t    VNIC_RSS_CFG_REQ_HASH_TYPE_UDP_IPV6;\n\t}\n}\n\nstatic void bnxt_set_dflt_rfs(struct bnxt *bp)\n{\n\tstruct net_device *dev = bp->dev;\n\n\tdev->hw_features &= ~NETIF_F_NTUPLE;\n\tdev->features &= ~NETIF_F_NTUPLE;\n\tbp->flags &= ~BNXT_FLAG_RFS;\n\tif (bnxt_rfs_supported(bp)) {\n\t\tdev->hw_features |= NETIF_F_NTUPLE;\n\t\tif (bnxt_rfs_capable(bp)) {\n\t\t\tbp->flags |= BNXT_FLAG_RFS;\n\t\t\tdev->features |= NETIF_F_NTUPLE;\n\t\t}\n\t}\n}\n\nstatic void bnxt_fw_init_one_p3(struct bnxt *bp)\n{\n\tstruct pci_dev *pdev = bp->pdev;\n\n\tbnxt_set_dflt_rss_hash_type(bp);\n\tbnxt_set_dflt_rfs(bp);\n\n\tbnxt_get_wol_settings(bp);\n\tif (bp->flags & BNXT_FLAG_WOL_CAP)\n\t\tdevice_set_wakeup_enable(&pdev->dev, bp->wol);\n\telse\n\t\tdevice_set_wakeup_capable(&pdev->dev, false);\n\n\tbnxt_hwrm_set_cache_line_size(bp, cache_line_size());\n\tbnxt_hwrm_coal_params_qcaps(bp);\n}\n\nstatic int bnxt_probe_phy(struct bnxt *bp, bool fw_dflt);\n\nint bnxt_fw_init_one(struct bnxt *bp)\n{\n\tint rc;\n\n\trc = bnxt_fw_init_one_p1(bp);\n\tif (rc) {\n\t\tnetdev_err(bp->dev, \"Firmware init phase 1 failed\\n\");\n\t\treturn rc;\n\t}\n\trc = bnxt_fw_init_one_p2(bp);\n\tif (rc) {\n\t\tnetdev_err(bp->dev, \"Firmware init phase 2 failed\\n\");\n\t\treturn rc;\n\t}\n\trc = bnxt_probe_phy(bp, false);\n\tif (rc)\n\t\treturn rc;\n\trc = bnxt_approve_mac(bp, bp->dev->dev_addr, false);\n\tif (rc)\n\t\treturn rc;\n\n\tbnxt_fw_init_one_p3(bp);\n\treturn 0;\n}\n\nstatic void bnxt_fw_reset_writel(struct bnxt *bp, int reg_idx)\n{\n\tstruct bnxt_fw_health *fw_health = bp->fw_health;\n\tu32 reg = fw_health->fw_reset_seq_regs[reg_idx];\n\tu32 val = fw_health->fw_reset_seq_vals[reg_idx];\n\tu32 reg_type, reg_off, delay_msecs;\n\n\tdelay_msecs = fw_health->fw_reset_seq_delay_msec[reg_idx];\n\treg_type = BNXT_FW_HEALTH_REG_TYPE(reg);\n\treg_off = BNXT_FW_HEALTH_REG_OFF(reg);\n\tswitch (reg_type) {\n\tcase BNXT_FW_HEALTH_REG_TYPE_CFG:\n\t\tpci_write_config_dword(bp->pdev, reg_off, val);\n\t\tbreak;\n\tcase BNXT_FW_HEALTH_REG_TYPE_GRC:\n\t\twritel(reg_off & BNXT_GRC_BASE_MASK,\n\t\t       bp->bar0 + BNXT_GRCPF_REG_WINDOW_BASE_OUT + 4);\n\t\treg_off = (reg_off & BNXT_GRC_OFFSET_MASK) + 0x2000;\n\t\tfallthrough;\n\tcase BNXT_FW_HEALTH_REG_TYPE_BAR0:\n\t\twritel(val, bp->bar0 + reg_off);\n\t\tbreak;\n\tcase BNXT_FW_HEALTH_REG_TYPE_BAR1:\n\t\twritel(val, bp->bar1 + reg_off);\n\t\tbreak;\n\t}\n\tif (delay_msecs) {\n\t\tpci_read_config_dword(bp->pdev, 0, &val);\n\t\tmsleep(delay_msecs);\n\t}\n}\n\nbool bnxt_hwrm_reset_permitted(struct bnxt *bp)\n{\n\tstruct hwrm_func_qcfg_output *resp;\n\tstruct hwrm_func_qcfg_input *req;\n\tbool result = true;  \n\n\tif (~bp->fw_cap & BNXT_FW_CAP_HOT_RESET_IF)\n\t\treturn result;\n\n\tif (hwrm_req_init(bp, req, HWRM_FUNC_QCFG))\n\t\treturn result;\n\n\treq->fid = cpu_to_le16(0xffff);\n\tresp = hwrm_req_hold(bp, req);\n\tif (!hwrm_req_send(bp, req))\n\t\tresult = !!(le16_to_cpu(resp->flags) &\n\t\t\t    FUNC_QCFG_RESP_FLAGS_HOT_RESET_ALLOWED);\n\thwrm_req_drop(bp, req);\n\treturn result;\n}\n\nstatic void bnxt_reset_all(struct bnxt *bp)\n{\n\tstruct bnxt_fw_health *fw_health = bp->fw_health;\n\tint i, rc;\n\n\tif (bp->fw_cap & BNXT_FW_CAP_ERR_RECOVER_RELOAD) {\n\t\tbnxt_fw_reset_via_optee(bp);\n\t\tbp->fw_reset_timestamp = jiffies;\n\t\treturn;\n\t}\n\n\tif (fw_health->flags & ERROR_RECOVERY_QCFG_RESP_FLAGS_HOST) {\n\t\tfor (i = 0; i < fw_health->fw_reset_seq_cnt; i++)\n\t\t\tbnxt_fw_reset_writel(bp, i);\n\t} else if (fw_health->flags & ERROR_RECOVERY_QCFG_RESP_FLAGS_CO_CPU) {\n\t\tstruct hwrm_fw_reset_input *req;\n\n\t\trc = hwrm_req_init(bp, req, HWRM_FW_RESET);\n\t\tif (!rc) {\n\t\t\treq->target_id = cpu_to_le16(HWRM_TARGET_ID_KONG);\n\t\t\treq->embedded_proc_type = FW_RESET_REQ_EMBEDDED_PROC_TYPE_CHIP;\n\t\t\treq->selfrst_status = FW_RESET_REQ_SELFRST_STATUS_SELFRSTASAP;\n\t\t\treq->flags = FW_RESET_REQ_FLAGS_RESET_GRACEFUL;\n\t\t\trc = hwrm_req_send(bp, req);\n\t\t}\n\t\tif (rc != -ENODEV)\n\t\t\tnetdev_warn(bp->dev, \"Unable to reset FW rc=%d\\n\", rc);\n\t}\n\tbp->fw_reset_timestamp = jiffies;\n}\n\nstatic bool bnxt_fw_reset_timeout(struct bnxt *bp)\n{\n\treturn time_after(jiffies, bp->fw_reset_timestamp +\n\t\t\t  (bp->fw_reset_max_dsecs * HZ / 10));\n}\n\nstatic void bnxt_fw_reset_abort(struct bnxt *bp, int rc)\n{\n\tclear_bit(BNXT_STATE_IN_FW_RESET, &bp->state);\n\tif (bp->fw_reset_state != BNXT_FW_RESET_STATE_POLL_VF) {\n\t\tbnxt_ulp_start(bp, rc);\n\t\tbnxt_dl_health_fw_status_update(bp, false);\n\t}\n\tbp->fw_reset_state = 0;\n\tdev_close(bp->dev);\n}\n\nstatic void bnxt_fw_reset_task(struct work_struct *work)\n{\n\tstruct bnxt *bp = container_of(work, struct bnxt, fw_reset_task.work);\n\tint rc = 0;\n\n\tif (!test_bit(BNXT_STATE_IN_FW_RESET, &bp->state)) {\n\t\tnetdev_err(bp->dev, \"bnxt_fw_reset_task() called when not in fw reset mode!\\n\");\n\t\treturn;\n\t}\n\n\tswitch (bp->fw_reset_state) {\n\tcase BNXT_FW_RESET_STATE_POLL_VF: {\n\t\tint n = bnxt_get_registered_vfs(bp);\n\t\tint tmo;\n\n\t\tif (n < 0) {\n\t\t\tnetdev_err(bp->dev, \"Firmware reset aborted, subsequent func_qcfg cmd failed, rc = %d, %d msecs since reset timestamp\\n\",\n\t\t\t\t   n, jiffies_to_msecs(jiffies -\n\t\t\t\t   bp->fw_reset_timestamp));\n\t\t\tgoto fw_reset_abort;\n\t\t} else if (n > 0) {\n\t\t\tif (bnxt_fw_reset_timeout(bp)) {\n\t\t\t\tclear_bit(BNXT_STATE_IN_FW_RESET, &bp->state);\n\t\t\t\tbp->fw_reset_state = 0;\n\t\t\t\tnetdev_err(bp->dev, \"Firmware reset aborted, bnxt_get_registered_vfs() returns %d\\n\",\n\t\t\t\t\t   n);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tbnxt_queue_fw_reset_work(bp, HZ / 10);\n\t\t\treturn;\n\t\t}\n\t\tbp->fw_reset_timestamp = jiffies;\n\t\trtnl_lock();\n\t\tif (test_bit(BNXT_STATE_ABORT_ERR, &bp->state)) {\n\t\t\tbnxt_fw_reset_abort(bp, rc);\n\t\t\trtnl_unlock();\n\t\t\treturn;\n\t\t}\n\t\tbnxt_fw_reset_close(bp);\n\t\tif (bp->fw_cap & BNXT_FW_CAP_ERR_RECOVER_RELOAD) {\n\t\t\tbp->fw_reset_state = BNXT_FW_RESET_STATE_POLL_FW_DOWN;\n\t\t\ttmo = HZ / 10;\n\t\t} else {\n\t\t\tbp->fw_reset_state = BNXT_FW_RESET_STATE_ENABLE_DEV;\n\t\t\ttmo = bp->fw_reset_min_dsecs * HZ / 10;\n\t\t}\n\t\trtnl_unlock();\n\t\tbnxt_queue_fw_reset_work(bp, tmo);\n\t\treturn;\n\t}\n\tcase BNXT_FW_RESET_STATE_POLL_FW_DOWN: {\n\t\tu32 val;\n\n\t\tval = bnxt_fw_health_readl(bp, BNXT_FW_HEALTH_REG);\n\t\tif (!(val & BNXT_FW_STATUS_SHUTDOWN) &&\n\t\t    !bnxt_fw_reset_timeout(bp)) {\n\t\t\tbnxt_queue_fw_reset_work(bp, HZ / 5);\n\t\t\treturn;\n\t\t}\n\n\t\tif (!bp->fw_health->primary) {\n\t\t\tu32 wait_dsecs = bp->fw_health->normal_func_wait_dsecs;\n\n\t\t\tbp->fw_reset_state = BNXT_FW_RESET_STATE_ENABLE_DEV;\n\t\t\tbnxt_queue_fw_reset_work(bp, wait_dsecs * HZ / 10);\n\t\t\treturn;\n\t\t}\n\t\tbp->fw_reset_state = BNXT_FW_RESET_STATE_RESET_FW;\n\t}\n\t\tfallthrough;\n\tcase BNXT_FW_RESET_STATE_RESET_FW:\n\t\tbnxt_reset_all(bp);\n\t\tbp->fw_reset_state = BNXT_FW_RESET_STATE_ENABLE_DEV;\n\t\tbnxt_queue_fw_reset_work(bp, bp->fw_reset_min_dsecs * HZ / 10);\n\t\treturn;\n\tcase BNXT_FW_RESET_STATE_ENABLE_DEV:\n\t\tbnxt_inv_fw_health_reg(bp);\n\t\tif (test_bit(BNXT_STATE_FW_FATAL_COND, &bp->state) &&\n\t\t    !bp->fw_reset_min_dsecs) {\n\t\t\tu16 val;\n\n\t\t\tpci_read_config_word(bp->pdev, PCI_SUBSYSTEM_ID, &val);\n\t\t\tif (val == 0xffff) {\n\t\t\t\tif (bnxt_fw_reset_timeout(bp)) {\n\t\t\t\t\tnetdev_err(bp->dev, \"Firmware reset aborted, PCI config space invalid\\n\");\n\t\t\t\t\trc = -ETIMEDOUT;\n\t\t\t\t\tgoto fw_reset_abort;\n\t\t\t\t}\n\t\t\t\tbnxt_queue_fw_reset_work(bp, HZ / 1000);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tclear_bit(BNXT_STATE_FW_FATAL_COND, &bp->state);\n\t\tclear_bit(BNXT_STATE_FW_NON_FATAL_COND, &bp->state);\n\t\tif (test_and_clear_bit(BNXT_STATE_FW_ACTIVATE_RESET, &bp->state) &&\n\t\t    !test_bit(BNXT_STATE_FW_ACTIVATE, &bp->state))\n\t\t\tbnxt_dl_remote_reload(bp);\n\t\tif (pci_enable_device(bp->pdev)) {\n\t\t\tnetdev_err(bp->dev, \"Cannot re-enable PCI device\\n\");\n\t\t\trc = -ENODEV;\n\t\t\tgoto fw_reset_abort;\n\t\t}\n\t\tpci_set_master(bp->pdev);\n\t\tbp->fw_reset_state = BNXT_FW_RESET_STATE_POLL_FW;\n\t\tfallthrough;\n\tcase BNXT_FW_RESET_STATE_POLL_FW:\n\t\tbp->hwrm_cmd_timeout = SHORT_HWRM_CMD_TIMEOUT;\n\t\trc = bnxt_hwrm_poll(bp);\n\t\tif (rc) {\n\t\t\tif (bnxt_fw_reset_timeout(bp)) {\n\t\t\t\tnetdev_err(bp->dev, \"Firmware reset aborted\\n\");\n\t\t\t\tgoto fw_reset_abort_status;\n\t\t\t}\n\t\t\tbnxt_queue_fw_reset_work(bp, HZ / 5);\n\t\t\treturn;\n\t\t}\n\t\tbp->hwrm_cmd_timeout = DFLT_HWRM_CMD_TIMEOUT;\n\t\tbp->fw_reset_state = BNXT_FW_RESET_STATE_OPENING;\n\t\tfallthrough;\n\tcase BNXT_FW_RESET_STATE_OPENING:\n\t\twhile (!rtnl_trylock()) {\n\t\t\tbnxt_queue_fw_reset_work(bp, HZ / 10);\n\t\t\treturn;\n\t\t}\n\t\trc = bnxt_open(bp->dev);\n\t\tif (rc) {\n\t\t\tnetdev_err(bp->dev, \"bnxt_open() failed during FW reset\\n\");\n\t\t\tbnxt_fw_reset_abort(bp, rc);\n\t\t\trtnl_unlock();\n\t\t\treturn;\n\t\t}\n\n\t\tif ((bp->fw_cap & BNXT_FW_CAP_ERROR_RECOVERY) &&\n\t\t    bp->fw_health->enabled) {\n\t\t\tbp->fw_health->last_fw_reset_cnt =\n\t\t\t\tbnxt_fw_health_readl(bp, BNXT_FW_RESET_CNT_REG);\n\t\t}\n\t\tbp->fw_reset_state = 0;\n\t\t \n\t\tsmp_mb__before_atomic();\n\t\tclear_bit(BNXT_STATE_IN_FW_RESET, &bp->state);\n\t\tbnxt_ulp_start(bp, 0);\n\t\tbnxt_reenable_sriov(bp);\n\t\tbnxt_vf_reps_alloc(bp);\n\t\tbnxt_vf_reps_open(bp);\n\t\tbnxt_ptp_reapply_pps(bp);\n\t\tclear_bit(BNXT_STATE_FW_ACTIVATE, &bp->state);\n\t\tif (test_and_clear_bit(BNXT_STATE_RECOVER, &bp->state)) {\n\t\t\tbnxt_dl_health_fw_recovery_done(bp);\n\t\t\tbnxt_dl_health_fw_status_update(bp, true);\n\t\t}\n\t\trtnl_unlock();\n\t\tbreak;\n\t}\n\treturn;\n\nfw_reset_abort_status:\n\tif (bp->fw_health->status_reliable ||\n\t    (bp->fw_cap & BNXT_FW_CAP_ERROR_RECOVERY)) {\n\t\tu32 sts = bnxt_fw_health_readl(bp, BNXT_FW_HEALTH_REG);\n\n\t\tnetdev_err(bp->dev, \"fw_health_status 0x%x\\n\", sts);\n\t}\nfw_reset_abort:\n\trtnl_lock();\n\tbnxt_fw_reset_abort(bp, rc);\n\trtnl_unlock();\n}\n\nstatic int bnxt_init_board(struct pci_dev *pdev, struct net_device *dev)\n{\n\tint rc;\n\tstruct bnxt *bp = netdev_priv(dev);\n\n\tSET_NETDEV_DEV(dev, &pdev->dev);\n\n\t \n\trc = pci_enable_device(pdev);\n\tif (rc) {\n\t\tdev_err(&pdev->dev, \"Cannot enable PCI device, aborting\\n\");\n\t\tgoto init_err;\n\t}\n\n\tif (!(pci_resource_flags(pdev, 0) & IORESOURCE_MEM)) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Cannot find PCI device base address, aborting\\n\");\n\t\trc = -ENODEV;\n\t\tgoto init_err_disable;\n\t}\n\n\trc = pci_request_regions(pdev, DRV_MODULE_NAME);\n\tif (rc) {\n\t\tdev_err(&pdev->dev, \"Cannot obtain PCI resources, aborting\\n\");\n\t\tgoto init_err_disable;\n\t}\n\n\tif (dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(64)) != 0 &&\n\t    dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(32)) != 0) {\n\t\tdev_err(&pdev->dev, \"System does not support DMA, aborting\\n\");\n\t\trc = -EIO;\n\t\tgoto init_err_release;\n\t}\n\n\tpci_set_master(pdev);\n\n\tbp->dev = dev;\n\tbp->pdev = pdev;\n\n\t \n\tbp->bar0 = pci_ioremap_bar(pdev, 0);\n\tif (!bp->bar0) {\n\t\tdev_err(&pdev->dev, \"Cannot map device registers, aborting\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto init_err_release;\n\t}\n\n\tbp->bar2 = pci_ioremap_bar(pdev, 4);\n\tif (!bp->bar2) {\n\t\tdev_err(&pdev->dev, \"Cannot map bar4 registers, aborting\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto init_err_release;\n\t}\n\n\tINIT_WORK(&bp->sp_task, bnxt_sp_task);\n\tINIT_DELAYED_WORK(&bp->fw_reset_task, bnxt_fw_reset_task);\n\n\tspin_lock_init(&bp->ntp_fltr_lock);\n#if BITS_PER_LONG == 32\n\tspin_lock_init(&bp->db_lock);\n#endif\n\n\tbp->rx_ring_size = BNXT_DEFAULT_RX_RING_SIZE;\n\tbp->tx_ring_size = BNXT_DEFAULT_TX_RING_SIZE;\n\n\ttimer_setup(&bp->timer, bnxt_timer, 0);\n\tbp->current_interval = BNXT_TIMER_INTERVAL;\n\n\tbp->vxlan_fw_dst_port_id = INVALID_HW_RING_ID;\n\tbp->nge_fw_dst_port_id = INVALID_HW_RING_ID;\n\n\tclear_bit(BNXT_STATE_OPEN, &bp->state);\n\treturn 0;\n\ninit_err_release:\n\tbnxt_unmap_bars(bp, pdev);\n\tpci_release_regions(pdev);\n\ninit_err_disable:\n\tpci_disable_device(pdev);\n\ninit_err:\n\treturn rc;\n}\n\n \nstatic int bnxt_change_mac_addr(struct net_device *dev, void *p)\n{\n\tstruct sockaddr *addr = p;\n\tstruct bnxt *bp = netdev_priv(dev);\n\tint rc = 0;\n\n\tif (!is_valid_ether_addr(addr->sa_data))\n\t\treturn -EADDRNOTAVAIL;\n\n\tif (ether_addr_equal(addr->sa_data, dev->dev_addr))\n\t\treturn 0;\n\n\trc = bnxt_approve_mac(bp, addr->sa_data, true);\n\tif (rc)\n\t\treturn rc;\n\n\teth_hw_addr_set(dev, addr->sa_data);\n\tif (netif_running(dev)) {\n\t\tbnxt_close_nic(bp, false, false);\n\t\trc = bnxt_open_nic(bp, false, false);\n\t}\n\n\treturn rc;\n}\n\n \nstatic int bnxt_change_mtu(struct net_device *dev, int new_mtu)\n{\n\tstruct bnxt *bp = netdev_priv(dev);\n\n\tif (netif_running(dev))\n\t\tbnxt_close_nic(bp, true, false);\n\n\tdev->mtu = new_mtu;\n\tbnxt_set_ring_params(bp);\n\n\tif (netif_running(dev))\n\t\treturn bnxt_open_nic(bp, true, false);\n\n\treturn 0;\n}\n\nint bnxt_setup_mq_tc(struct net_device *dev, u8 tc)\n{\n\tstruct bnxt *bp = netdev_priv(dev);\n\tbool sh = false;\n\tint rc;\n\n\tif (tc > bp->max_tc) {\n\t\tnetdev_err(dev, \"Too many traffic classes requested: %d. Max supported is %d.\\n\",\n\t\t\t   tc, bp->max_tc);\n\t\treturn -EINVAL;\n\t}\n\n\tif (netdev_get_num_tc(dev) == tc)\n\t\treturn 0;\n\n\tif (bp->flags & BNXT_FLAG_SHARED_RINGS)\n\t\tsh = true;\n\n\trc = bnxt_check_rings(bp, bp->tx_nr_rings_per_tc, bp->rx_nr_rings,\n\t\t\t      sh, tc, bp->tx_nr_rings_xdp);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tif (netif_running(bp->dev))\n\t\tbnxt_close_nic(bp, true, false);\n\n\tif (tc) {\n\t\tbp->tx_nr_rings = bp->tx_nr_rings_per_tc * tc;\n\t\tnetdev_set_num_tc(dev, tc);\n\t} else {\n\t\tbp->tx_nr_rings = bp->tx_nr_rings_per_tc;\n\t\tnetdev_reset_tc(dev);\n\t}\n\tbp->tx_nr_rings += bp->tx_nr_rings_xdp;\n\tbp->cp_nr_rings = sh ? max_t(int, bp->tx_nr_rings, bp->rx_nr_rings) :\n\t\t\t       bp->tx_nr_rings + bp->rx_nr_rings;\n\n\tif (netif_running(bp->dev))\n\t\treturn bnxt_open_nic(bp, true, false);\n\n\treturn 0;\n}\n\nstatic int bnxt_setup_tc_block_cb(enum tc_setup_type type, void *type_data,\n\t\t\t\t  void *cb_priv)\n{\n\tstruct bnxt *bp = cb_priv;\n\n\tif (!bnxt_tc_flower_enabled(bp) ||\n\t    !tc_cls_can_offload_and_chain0(bp->dev, type_data))\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (type) {\n\tcase TC_SETUP_CLSFLOWER:\n\t\treturn bnxt_tc_setup_flower(bp, bp->pf.fw_fid, type_data);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nLIST_HEAD(bnxt_block_cb_list);\n\nstatic int bnxt_setup_tc(struct net_device *dev, enum tc_setup_type type,\n\t\t\t void *type_data)\n{\n\tstruct bnxt *bp = netdev_priv(dev);\n\n\tswitch (type) {\n\tcase TC_SETUP_BLOCK:\n\t\treturn flow_block_cb_setup_simple(type_data,\n\t\t\t\t\t\t  &bnxt_block_cb_list,\n\t\t\t\t\t\t  bnxt_setup_tc_block_cb,\n\t\t\t\t\t\t  bp, bp, true);\n\tcase TC_SETUP_QDISC_MQPRIO: {\n\t\tstruct tc_mqprio_qopt *mqprio = type_data;\n\n\t\tmqprio->hw = TC_MQPRIO_HW_OFFLOAD_TCS;\n\n\t\treturn bnxt_setup_mq_tc(dev, mqprio->num_tc);\n\t}\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\n#ifdef CONFIG_RFS_ACCEL\nstatic bool bnxt_fltr_match(struct bnxt_ntuple_filter *f1,\n\t\t\t    struct bnxt_ntuple_filter *f2)\n{\n\tstruct flow_keys *keys1 = &f1->fkeys;\n\tstruct flow_keys *keys2 = &f2->fkeys;\n\n\tif (keys1->basic.n_proto != keys2->basic.n_proto ||\n\t    keys1->basic.ip_proto != keys2->basic.ip_proto)\n\t\treturn false;\n\n\tif (keys1->basic.n_proto == htons(ETH_P_IP)) {\n\t\tif (keys1->addrs.v4addrs.src != keys2->addrs.v4addrs.src ||\n\t\t    keys1->addrs.v4addrs.dst != keys2->addrs.v4addrs.dst)\n\t\t\treturn false;\n\t} else {\n\t\tif (memcmp(&keys1->addrs.v6addrs.src, &keys2->addrs.v6addrs.src,\n\t\t\t   sizeof(keys1->addrs.v6addrs.src)) ||\n\t\t    memcmp(&keys1->addrs.v6addrs.dst, &keys2->addrs.v6addrs.dst,\n\t\t\t   sizeof(keys1->addrs.v6addrs.dst)))\n\t\t\treturn false;\n\t}\n\n\tif (keys1->ports.ports == keys2->ports.ports &&\n\t    keys1->control.flags == keys2->control.flags &&\n\t    ether_addr_equal(f1->src_mac_addr, f2->src_mac_addr) &&\n\t    ether_addr_equal(f1->dst_mac_addr, f2->dst_mac_addr))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic int bnxt_rx_flow_steer(struct net_device *dev, const struct sk_buff *skb,\n\t\t\t      u16 rxq_index, u32 flow_id)\n{\n\tstruct bnxt *bp = netdev_priv(dev);\n\tstruct bnxt_ntuple_filter *fltr, *new_fltr;\n\tstruct flow_keys *fkeys;\n\tstruct ethhdr *eth = (struct ethhdr *)skb_mac_header(skb);\n\tint rc = 0, idx, bit_id, l2_idx = 0;\n\tstruct hlist_head *head;\n\tu32 flags;\n\n\tif (!ether_addr_equal(dev->dev_addr, eth->h_dest)) {\n\t\tstruct bnxt_vnic_info *vnic = &bp->vnic_info[0];\n\t\tint off = 0, j;\n\n\t\tnetif_addr_lock_bh(dev);\n\t\tfor (j = 0; j < vnic->uc_filter_count; j++, off += ETH_ALEN) {\n\t\t\tif (ether_addr_equal(eth->h_dest,\n\t\t\t\t\t     vnic->uc_list + off)) {\n\t\t\t\tl2_idx = j + 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tnetif_addr_unlock_bh(dev);\n\t\tif (!l2_idx)\n\t\t\treturn -EINVAL;\n\t}\n\tnew_fltr = kzalloc(sizeof(*new_fltr), GFP_ATOMIC);\n\tif (!new_fltr)\n\t\treturn -ENOMEM;\n\n\tfkeys = &new_fltr->fkeys;\n\tif (!skb_flow_dissect_flow_keys(skb, fkeys, 0)) {\n\t\trc = -EPROTONOSUPPORT;\n\t\tgoto err_free;\n\t}\n\n\tif ((fkeys->basic.n_proto != htons(ETH_P_IP) &&\n\t     fkeys->basic.n_proto != htons(ETH_P_IPV6)) ||\n\t    ((fkeys->basic.ip_proto != IPPROTO_TCP) &&\n\t     (fkeys->basic.ip_proto != IPPROTO_UDP))) {\n\t\trc = -EPROTONOSUPPORT;\n\t\tgoto err_free;\n\t}\n\tif (fkeys->basic.n_proto == htons(ETH_P_IPV6) &&\n\t    bp->hwrm_spec_code < 0x10601) {\n\t\trc = -EPROTONOSUPPORT;\n\t\tgoto err_free;\n\t}\n\tflags = fkeys->control.flags;\n\tif (((flags & FLOW_DIS_ENCAPSULATION) &&\n\t     bp->hwrm_spec_code < 0x10601) || (flags & FLOW_DIS_IS_FRAGMENT)) {\n\t\trc = -EPROTONOSUPPORT;\n\t\tgoto err_free;\n\t}\n\n\tmemcpy(new_fltr->dst_mac_addr, eth->h_dest, ETH_ALEN);\n\tmemcpy(new_fltr->src_mac_addr, eth->h_source, ETH_ALEN);\n\n\tidx = skb_get_hash_raw(skb) & BNXT_NTP_FLTR_HASH_MASK;\n\thead = &bp->ntp_fltr_hash_tbl[idx];\n\trcu_read_lock();\n\thlist_for_each_entry_rcu(fltr, head, hash) {\n\t\tif (bnxt_fltr_match(fltr, new_fltr)) {\n\t\t\trc = fltr->sw_id;\n\t\t\trcu_read_unlock();\n\t\t\tgoto err_free;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\tspin_lock_bh(&bp->ntp_fltr_lock);\n\tbit_id = bitmap_find_free_region(bp->ntp_fltr_bmap,\n\t\t\t\t\t BNXT_NTP_FLTR_MAX_FLTR, 0);\n\tif (bit_id < 0) {\n\t\tspin_unlock_bh(&bp->ntp_fltr_lock);\n\t\trc = -ENOMEM;\n\t\tgoto err_free;\n\t}\n\n\tnew_fltr->sw_id = (u16)bit_id;\n\tnew_fltr->flow_id = flow_id;\n\tnew_fltr->l2_fltr_idx = l2_idx;\n\tnew_fltr->rxq = rxq_index;\n\thlist_add_head_rcu(&new_fltr->hash, head);\n\tbp->ntp_fltr_count++;\n\tspin_unlock_bh(&bp->ntp_fltr_lock);\n\n\tbnxt_queue_sp_work(bp, BNXT_RX_NTP_FLTR_SP_EVENT);\n\n\treturn new_fltr->sw_id;\n\nerr_free:\n\tkfree(new_fltr);\n\treturn rc;\n}\n\nstatic void bnxt_cfg_ntp_filters(struct bnxt *bp)\n{\n\tint i;\n\n\tfor (i = 0; i < BNXT_NTP_FLTR_HASH_SIZE; i++) {\n\t\tstruct hlist_head *head;\n\t\tstruct hlist_node *tmp;\n\t\tstruct bnxt_ntuple_filter *fltr;\n\t\tint rc;\n\n\t\thead = &bp->ntp_fltr_hash_tbl[i];\n\t\thlist_for_each_entry_safe(fltr, tmp, head, hash) {\n\t\t\tbool del = false;\n\n\t\t\tif (test_bit(BNXT_FLTR_VALID, &fltr->state)) {\n\t\t\t\tif (rps_may_expire_flow(bp->dev, fltr->rxq,\n\t\t\t\t\t\t\tfltr->flow_id,\n\t\t\t\t\t\t\tfltr->sw_id)) {\n\t\t\t\t\tbnxt_hwrm_cfa_ntuple_filter_free(bp,\n\t\t\t\t\t\t\t\t\t fltr);\n\t\t\t\t\tdel = true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\trc = bnxt_hwrm_cfa_ntuple_filter_alloc(bp,\n\t\t\t\t\t\t\t\t       fltr);\n\t\t\t\tif (rc)\n\t\t\t\t\tdel = true;\n\t\t\t\telse\n\t\t\t\t\tset_bit(BNXT_FLTR_VALID, &fltr->state);\n\t\t\t}\n\n\t\t\tif (del) {\n\t\t\t\tspin_lock_bh(&bp->ntp_fltr_lock);\n\t\t\t\thlist_del_rcu(&fltr->hash);\n\t\t\t\tbp->ntp_fltr_count--;\n\t\t\t\tspin_unlock_bh(&bp->ntp_fltr_lock);\n\t\t\t\tsynchronize_rcu();\n\t\t\t\tclear_bit(fltr->sw_id, bp->ntp_fltr_bmap);\n\t\t\t\tkfree(fltr);\n\t\t\t}\n\t\t}\n\t}\n}\n\n#else\n\nstatic void bnxt_cfg_ntp_filters(struct bnxt *bp)\n{\n}\n\n#endif  \n\nstatic int bnxt_udp_tunnel_set_port(struct net_device *netdev, unsigned int table,\n\t\t\t\t    unsigned int entry, struct udp_tunnel_info *ti)\n{\n\tstruct bnxt *bp = netdev_priv(netdev);\n\tunsigned int cmd;\n\n\tif (ti->type == UDP_TUNNEL_TYPE_VXLAN)\n\t\tcmd = TUNNEL_DST_PORT_FREE_REQ_TUNNEL_TYPE_VXLAN;\n\telse\n\t\tcmd = TUNNEL_DST_PORT_FREE_REQ_TUNNEL_TYPE_GENEVE;\n\n\treturn bnxt_hwrm_tunnel_dst_port_alloc(bp, ti->port, cmd);\n}\n\nstatic int bnxt_udp_tunnel_unset_port(struct net_device *netdev, unsigned int table,\n\t\t\t\t      unsigned int entry, struct udp_tunnel_info *ti)\n{\n\tstruct bnxt *bp = netdev_priv(netdev);\n\tunsigned int cmd;\n\n\tif (ti->type == UDP_TUNNEL_TYPE_VXLAN)\n\t\tcmd = TUNNEL_DST_PORT_FREE_REQ_TUNNEL_TYPE_VXLAN;\n\telse\n\t\tcmd = TUNNEL_DST_PORT_FREE_REQ_TUNNEL_TYPE_GENEVE;\n\n\treturn bnxt_hwrm_tunnel_dst_port_free(bp, cmd);\n}\n\nstatic const struct udp_tunnel_nic_info bnxt_udp_tunnels = {\n\t.set_port\t= bnxt_udp_tunnel_set_port,\n\t.unset_port\t= bnxt_udp_tunnel_unset_port,\n\t.flags\t\t= UDP_TUNNEL_NIC_INFO_MAY_SLEEP |\n\t\t\t  UDP_TUNNEL_NIC_INFO_OPEN_ONLY,\n\t.tables\t\t= {\n\t\t{ .n_entries = 1, .tunnel_types = UDP_TUNNEL_TYPE_VXLAN,  },\n\t\t{ .n_entries = 1, .tunnel_types = UDP_TUNNEL_TYPE_GENEVE, },\n\t},\n};\n\nstatic int bnxt_bridge_getlink(struct sk_buff *skb, u32 pid, u32 seq,\n\t\t\t       struct net_device *dev, u32 filter_mask,\n\t\t\t       int nlflags)\n{\n\tstruct bnxt *bp = netdev_priv(dev);\n\n\treturn ndo_dflt_bridge_getlink(skb, pid, seq, dev, bp->br_mode, 0, 0,\n\t\t\t\t       nlflags, filter_mask, NULL);\n}\n\nstatic int bnxt_bridge_setlink(struct net_device *dev, struct nlmsghdr *nlh,\n\t\t\t       u16 flags, struct netlink_ext_ack *extack)\n{\n\tstruct bnxt *bp = netdev_priv(dev);\n\tstruct nlattr *attr, *br_spec;\n\tint rem, rc = 0;\n\n\tif (bp->hwrm_spec_code < 0x10708 || !BNXT_SINGLE_PF(bp))\n\t\treturn -EOPNOTSUPP;\n\n\tbr_spec = nlmsg_find_attr(nlh, sizeof(struct ifinfomsg), IFLA_AF_SPEC);\n\tif (!br_spec)\n\t\treturn -EINVAL;\n\n\tnla_for_each_nested(attr, br_spec, rem) {\n\t\tu16 mode;\n\n\t\tif (nla_type(attr) != IFLA_BRIDGE_MODE)\n\t\t\tcontinue;\n\n\t\tmode = nla_get_u16(attr);\n\t\tif (mode == bp->br_mode)\n\t\t\tbreak;\n\n\t\trc = bnxt_hwrm_set_br_mode(bp, mode);\n\t\tif (!rc)\n\t\t\tbp->br_mode = mode;\n\t\tbreak;\n\t}\n\treturn rc;\n}\n\nint bnxt_get_port_parent_id(struct net_device *dev,\n\t\t\t    struct netdev_phys_item_id *ppid)\n{\n\tstruct bnxt *bp = netdev_priv(dev);\n\n\tif (bp->eswitch_mode != DEVLINK_ESWITCH_MODE_SWITCHDEV)\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tif (!BNXT_PF(bp) || !(bp->flags & BNXT_FLAG_DSN_VALID))\n\t\treturn -EOPNOTSUPP;\n\n\tppid->id_len = sizeof(bp->dsn);\n\tmemcpy(ppid->id, bp->dsn, ppid->id_len);\n\n\treturn 0;\n}\n\nstatic const struct net_device_ops bnxt_netdev_ops = {\n\t.ndo_open\t\t= bnxt_open,\n\t.ndo_start_xmit\t\t= bnxt_start_xmit,\n\t.ndo_stop\t\t= bnxt_close,\n\t.ndo_get_stats64\t= bnxt_get_stats64,\n\t.ndo_set_rx_mode\t= bnxt_set_rx_mode,\n\t.ndo_eth_ioctl\t\t= bnxt_ioctl,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_set_mac_address\t= bnxt_change_mac_addr,\n\t.ndo_change_mtu\t\t= bnxt_change_mtu,\n\t.ndo_fix_features\t= bnxt_fix_features,\n\t.ndo_set_features\t= bnxt_set_features,\n\t.ndo_features_check\t= bnxt_features_check,\n\t.ndo_tx_timeout\t\t= bnxt_tx_timeout,\n#ifdef CONFIG_BNXT_SRIOV\n\t.ndo_get_vf_config\t= bnxt_get_vf_config,\n\t.ndo_set_vf_mac\t\t= bnxt_set_vf_mac,\n\t.ndo_set_vf_vlan\t= bnxt_set_vf_vlan,\n\t.ndo_set_vf_rate\t= bnxt_set_vf_bw,\n\t.ndo_set_vf_link_state\t= bnxt_set_vf_link_state,\n\t.ndo_set_vf_spoofchk\t= bnxt_set_vf_spoofchk,\n\t.ndo_set_vf_trust\t= bnxt_set_vf_trust,\n#endif\n\t.ndo_setup_tc           = bnxt_setup_tc,\n#ifdef CONFIG_RFS_ACCEL\n\t.ndo_rx_flow_steer\t= bnxt_rx_flow_steer,\n#endif\n\t.ndo_bpf\t\t= bnxt_xdp,\n\t.ndo_xdp_xmit\t\t= bnxt_xdp_xmit,\n\t.ndo_bridge_getlink\t= bnxt_bridge_getlink,\n\t.ndo_bridge_setlink\t= bnxt_bridge_setlink,\n};\n\nstatic void bnxt_remove_one(struct pci_dev *pdev)\n{\n\tstruct net_device *dev = pci_get_drvdata(pdev);\n\tstruct bnxt *bp = netdev_priv(dev);\n\n\tif (BNXT_PF(bp))\n\t\tbnxt_sriov_disable(bp);\n\n\tbnxt_rdma_aux_device_uninit(bp);\n\n\tbnxt_ptp_clear(bp);\n\tunregister_netdev(dev);\n\tclear_bit(BNXT_STATE_IN_FW_RESET, &bp->state);\n\t \n\tcancel_work_sync(&bp->sp_task);\n\tcancel_delayed_work_sync(&bp->fw_reset_task);\n\tbp->sp_event = 0;\n\n\tbnxt_dl_fw_reporters_destroy(bp);\n\tbnxt_dl_unregister(bp);\n\tbnxt_shutdown_tc(bp);\n\n\tbnxt_clear_int_mode(bp);\n\tbnxt_hwrm_func_drv_unrgtr(bp);\n\tbnxt_free_hwrm_resources(bp);\n\tbnxt_ethtool_free(bp);\n\tbnxt_dcb_free(bp);\n\tkfree(bp->ptp_cfg);\n\tbp->ptp_cfg = NULL;\n\tkfree(bp->fw_health);\n\tbp->fw_health = NULL;\n\tbnxt_cleanup_pci(bp);\n\tbnxt_free_ctx_mem(bp);\n\tkfree(bp->ctx);\n\tbp->ctx = NULL;\n\tkfree(bp->rss_indir_tbl);\n\tbp->rss_indir_tbl = NULL;\n\tbnxt_free_port_stats(bp);\n\tfree_netdev(dev);\n}\n\nstatic int bnxt_probe_phy(struct bnxt *bp, bool fw_dflt)\n{\n\tint rc = 0;\n\tstruct bnxt_link_info *link_info = &bp->link_info;\n\n\tbp->phy_flags = 0;\n\trc = bnxt_hwrm_phy_qcaps(bp);\n\tif (rc) {\n\t\tnetdev_err(bp->dev, \"Probe phy can't get phy capabilities (rc: %x)\\n\",\n\t\t\t   rc);\n\t\treturn rc;\n\t}\n\tif (bp->phy_flags & BNXT_PHY_FL_NO_FCS)\n\t\tbp->dev->priv_flags |= IFF_SUPP_NOFCS;\n\telse\n\t\tbp->dev->priv_flags &= ~IFF_SUPP_NOFCS;\n\tif (!fw_dflt)\n\t\treturn 0;\n\n\tmutex_lock(&bp->link_lock);\n\trc = bnxt_update_link(bp, false);\n\tif (rc) {\n\t\tmutex_unlock(&bp->link_lock);\n\t\tnetdev_err(bp->dev, \"Probe phy can't update link (rc: %x)\\n\",\n\t\t\t   rc);\n\t\treturn rc;\n\t}\n\n\t \n\tif (link_info->auto_link_speeds && !link_info->support_auto_speeds)\n\t\tlink_info->support_auto_speeds = link_info->support_speeds;\n\n\tbnxt_init_ethtool_link_settings(bp);\n\tmutex_unlock(&bp->link_lock);\n\treturn 0;\n}\n\nstatic int bnxt_get_max_irq(struct pci_dev *pdev)\n{\n\tu16 ctrl;\n\n\tif (!pdev->msix_cap)\n\t\treturn 1;\n\n\tpci_read_config_word(pdev, pdev->msix_cap + PCI_MSIX_FLAGS, &ctrl);\n\treturn (ctrl & PCI_MSIX_FLAGS_QSIZE) + 1;\n}\n\nstatic void _bnxt_get_max_rings(struct bnxt *bp, int *max_rx, int *max_tx,\n\t\t\t\tint *max_cp)\n{\n\tstruct bnxt_hw_resc *hw_resc = &bp->hw_resc;\n\tint max_ring_grps = 0, max_irq;\n\n\t*max_tx = hw_resc->max_tx_rings;\n\t*max_rx = hw_resc->max_rx_rings;\n\t*max_cp = bnxt_get_max_func_cp_rings_for_en(bp);\n\tmax_irq = min_t(int, bnxt_get_max_func_irqs(bp) -\n\t\t\tbnxt_get_ulp_msix_num(bp),\n\t\t\thw_resc->max_stat_ctxs - bnxt_get_ulp_stat_ctxs(bp));\n\tif (!(bp->flags & BNXT_FLAG_CHIP_P5))\n\t\t*max_cp = min_t(int, *max_cp, max_irq);\n\tmax_ring_grps = hw_resc->max_hw_ring_grps;\n\tif (BNXT_CHIP_TYPE_NITRO_A0(bp) && BNXT_PF(bp)) {\n\t\t*max_cp -= 1;\n\t\t*max_rx -= 2;\n\t}\n\tif (bp->flags & BNXT_FLAG_AGG_RINGS)\n\t\t*max_rx >>= 1;\n\tif (bp->flags & BNXT_FLAG_CHIP_P5) {\n\t\tbnxt_trim_rings(bp, max_rx, max_tx, *max_cp, false);\n\t\t \n\t\t*max_cp = max_irq;\n\t}\n\t*max_rx = min_t(int, *max_rx, max_ring_grps);\n}\n\nint bnxt_get_max_rings(struct bnxt *bp, int *max_rx, int *max_tx, bool shared)\n{\n\tint rx, tx, cp;\n\n\t_bnxt_get_max_rings(bp, &rx, &tx, &cp);\n\t*max_rx = rx;\n\t*max_tx = tx;\n\tif (!rx || !tx || !cp)\n\t\treturn -ENOMEM;\n\n\treturn bnxt_trim_rings(bp, max_rx, max_tx, cp, shared);\n}\n\nstatic int bnxt_get_dflt_rings(struct bnxt *bp, int *max_rx, int *max_tx,\n\t\t\t       bool shared)\n{\n\tint rc;\n\n\trc = bnxt_get_max_rings(bp, max_rx, max_tx, shared);\n\tif (rc && (bp->flags & BNXT_FLAG_AGG_RINGS)) {\n\t\t \n\t\tbp->flags &= ~BNXT_FLAG_AGG_RINGS;\n\t\trc = bnxt_get_max_rings(bp, max_rx, max_tx, shared);\n\t\tif (rc) {\n\t\t\t \n\t\t\tbp->flags |= BNXT_FLAG_AGG_RINGS;\n\t\t\treturn rc;\n\t\t}\n\t\tbp->flags |= BNXT_FLAG_NO_AGG_RINGS;\n\t\tbp->dev->hw_features &= ~(NETIF_F_LRO | NETIF_F_GRO_HW);\n\t\tbp->dev->features &= ~(NETIF_F_LRO | NETIF_F_GRO_HW);\n\t\tbnxt_set_ring_params(bp);\n\t}\n\n\tif (bp->flags & BNXT_FLAG_ROCE_CAP) {\n\t\tint max_cp, max_stat, max_irq;\n\n\t\t \n\t\tmax_cp = bnxt_get_max_func_cp_rings(bp);\n\t\tmax_stat = bnxt_get_max_func_stat_ctxs(bp);\n\t\tmax_irq = bnxt_get_max_func_irqs(bp);\n\t\tif (max_cp <= BNXT_MIN_ROCE_CP_RINGS ||\n\t\t    max_irq <= BNXT_MIN_ROCE_CP_RINGS ||\n\t\t    max_stat <= BNXT_MIN_ROCE_STAT_CTXS)\n\t\t\treturn 0;\n\n\t\tmax_cp -= BNXT_MIN_ROCE_CP_RINGS;\n\t\tmax_irq -= BNXT_MIN_ROCE_CP_RINGS;\n\t\tmax_stat -= BNXT_MIN_ROCE_STAT_CTXS;\n\t\tmax_cp = min_t(int, max_cp, max_irq);\n\t\tmax_cp = min_t(int, max_cp, max_stat);\n\t\trc = bnxt_trim_rings(bp, max_rx, max_tx, max_cp, shared);\n\t\tif (rc)\n\t\t\trc = 0;\n\t}\n\treturn rc;\n}\n\n \nstatic void bnxt_trim_dflt_sh_rings(struct bnxt *bp)\n{\n\tbp->cp_nr_rings = min_t(int, bp->tx_nr_rings_per_tc, bp->rx_nr_rings);\n\tbp->rx_nr_rings = bp->cp_nr_rings;\n\tbp->tx_nr_rings_per_tc = bp->cp_nr_rings;\n\tbp->tx_nr_rings = bp->tx_nr_rings_per_tc;\n}\n\nstatic int bnxt_set_dflt_rings(struct bnxt *bp, bool sh)\n{\n\tint dflt_rings, max_rx_rings, max_tx_rings, rc;\n\n\tif (!bnxt_can_reserve_rings(bp))\n\t\treturn 0;\n\n\tif (sh)\n\t\tbp->flags |= BNXT_FLAG_SHARED_RINGS;\n\tdflt_rings = is_kdump_kernel() ? 1 : netif_get_num_default_rss_queues();\n\t \n\tif (bp->port_count > 1) {\n\t\tint max_rings =\n\t\t\tmax_t(int, num_online_cpus() / bp->port_count, 1);\n\n\t\tdflt_rings = min_t(int, dflt_rings, max_rings);\n\t}\n\trc = bnxt_get_dflt_rings(bp, &max_rx_rings, &max_tx_rings, sh);\n\tif (rc)\n\t\treturn rc;\n\tbp->rx_nr_rings = min_t(int, dflt_rings, max_rx_rings);\n\tbp->tx_nr_rings_per_tc = min_t(int, dflt_rings, max_tx_rings);\n\tif (sh)\n\t\tbnxt_trim_dflt_sh_rings(bp);\n\telse\n\t\tbp->cp_nr_rings = bp->tx_nr_rings_per_tc + bp->rx_nr_rings;\n\tbp->tx_nr_rings = bp->tx_nr_rings_per_tc;\n\n\trc = __bnxt_reserve_rings(bp);\n\tif (rc && rc != -ENODEV)\n\t\tnetdev_warn(bp->dev, \"Unable to reserve tx rings\\n\");\n\tbp->tx_nr_rings_per_tc = bp->tx_nr_rings;\n\tif (sh)\n\t\tbnxt_trim_dflt_sh_rings(bp);\n\n\t \n\tif (bnxt_need_reserve_rings(bp)) {\n\t\trc = __bnxt_reserve_rings(bp);\n\t\tif (rc && rc != -ENODEV)\n\t\t\tnetdev_warn(bp->dev, \"2nd rings reservation failed.\\n\");\n\t\tbp->tx_nr_rings_per_tc = bp->tx_nr_rings;\n\t}\n\tif (BNXT_CHIP_TYPE_NITRO_A0(bp)) {\n\t\tbp->rx_nr_rings++;\n\t\tbp->cp_nr_rings++;\n\t}\n\tif (rc) {\n\t\tbp->tx_nr_rings = 0;\n\t\tbp->rx_nr_rings = 0;\n\t}\n\treturn rc;\n}\n\nstatic int bnxt_init_dflt_ring_mode(struct bnxt *bp)\n{\n\tint rc;\n\n\tif (bp->tx_nr_rings)\n\t\treturn 0;\n\n\tbnxt_ulp_irq_stop(bp);\n\tbnxt_clear_int_mode(bp);\n\trc = bnxt_set_dflt_rings(bp, true);\n\tif (rc) {\n\t\tif (BNXT_VF(bp) && rc == -ENODEV)\n\t\t\tnetdev_err(bp->dev, \"Cannot configure VF rings while PF is unavailable.\\n\");\n\t\telse\n\t\t\tnetdev_err(bp->dev, \"Not enough rings available.\\n\");\n\t\tgoto init_dflt_ring_err;\n\t}\n\trc = bnxt_init_int_mode(bp);\n\tif (rc)\n\t\tgoto init_dflt_ring_err;\n\n\tbp->tx_nr_rings_per_tc = bp->tx_nr_rings;\n\n\tbnxt_set_dflt_rfs(bp);\n\ninit_dflt_ring_err:\n\tbnxt_ulp_irq_restart(bp, rc);\n\treturn rc;\n}\n\nint bnxt_restore_pf_fw_resources(struct bnxt *bp)\n{\n\tint rc;\n\n\tASSERT_RTNL();\n\tbnxt_hwrm_func_qcaps(bp);\n\n\tif (netif_running(bp->dev))\n\t\t__bnxt_close_nic(bp, true, false);\n\n\tbnxt_ulp_irq_stop(bp);\n\tbnxt_clear_int_mode(bp);\n\trc = bnxt_init_int_mode(bp);\n\tbnxt_ulp_irq_restart(bp, rc);\n\n\tif (netif_running(bp->dev)) {\n\t\tif (rc)\n\t\t\tdev_close(bp->dev);\n\t\telse\n\t\t\trc = bnxt_open_nic(bp, true, false);\n\t}\n\n\treturn rc;\n}\n\nstatic int bnxt_init_mac_addr(struct bnxt *bp)\n{\n\tint rc = 0;\n\n\tif (BNXT_PF(bp)) {\n\t\teth_hw_addr_set(bp->dev, bp->pf.mac_addr);\n\t} else {\n#ifdef CONFIG_BNXT_SRIOV\n\t\tstruct bnxt_vf_info *vf = &bp->vf;\n\t\tbool strict_approval = true;\n\n\t\tif (is_valid_ether_addr(vf->mac_addr)) {\n\t\t\t \n\t\t\teth_hw_addr_set(bp->dev, vf->mac_addr);\n\t\t\t \n\t\t\tstrict_approval = false;\n\t\t} else {\n\t\t\teth_hw_addr_random(bp->dev);\n\t\t}\n\t\trc = bnxt_approve_mac(bp, bp->dev->dev_addr, strict_approval);\n#endif\n\t}\n\treturn rc;\n}\n\nstatic void bnxt_vpd_read_info(struct bnxt *bp)\n{\n\tstruct pci_dev *pdev = bp->pdev;\n\tunsigned int vpd_size, kw_len;\n\tint pos, size;\n\tu8 *vpd_data;\n\n\tvpd_data = pci_vpd_alloc(pdev, &vpd_size);\n\tif (IS_ERR(vpd_data)) {\n\t\tpci_warn(pdev, \"Unable to read VPD\\n\");\n\t\treturn;\n\t}\n\n\tpos = pci_vpd_find_ro_info_keyword(vpd_data, vpd_size,\n\t\t\t\t\t   PCI_VPD_RO_KEYWORD_PARTNO, &kw_len);\n\tif (pos < 0)\n\t\tgoto read_sn;\n\n\tsize = min_t(int, kw_len, BNXT_VPD_FLD_LEN - 1);\n\tmemcpy(bp->board_partno, &vpd_data[pos], size);\n\nread_sn:\n\tpos = pci_vpd_find_ro_info_keyword(vpd_data, vpd_size,\n\t\t\t\t\t   PCI_VPD_RO_KEYWORD_SERIALNO,\n\t\t\t\t\t   &kw_len);\n\tif (pos < 0)\n\t\tgoto exit;\n\n\tsize = min_t(int, kw_len, BNXT_VPD_FLD_LEN - 1);\n\tmemcpy(bp->board_serialno, &vpd_data[pos], size);\nexit:\n\tkfree(vpd_data);\n}\n\nstatic int bnxt_pcie_dsn_get(struct bnxt *bp, u8 dsn[])\n{\n\tstruct pci_dev *pdev = bp->pdev;\n\tu64 qword;\n\n\tqword = pci_get_dsn(pdev);\n\tif (!qword) {\n\t\tnetdev_info(bp->dev, \"Unable to read adapter's DSN\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tput_unaligned_le64(qword, dsn);\n\n\tbp->flags |= BNXT_FLAG_DSN_VALID;\n\treturn 0;\n}\n\nstatic int bnxt_map_db_bar(struct bnxt *bp)\n{\n\tif (!bp->db_size)\n\t\treturn -ENODEV;\n\tbp->bar1 = pci_iomap(bp->pdev, 2, bp->db_size);\n\tif (!bp->bar1)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nvoid bnxt_print_device_info(struct bnxt *bp)\n{\n\tnetdev_info(bp->dev, \"%s found at mem %lx, node addr %pM\\n\",\n\t\t    board_info[bp->board_idx].name,\n\t\t    (long)pci_resource_start(bp->pdev, 0), bp->dev->dev_addr);\n\n\tpcie_print_link_status(bp->pdev);\n}\n\nstatic int bnxt_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tstruct net_device *dev;\n\tstruct bnxt *bp;\n\tint rc, max_irqs;\n\n\tif (pci_is_bridge(pdev))\n\t\treturn -ENODEV;\n\n\t \n\tif (is_kdump_kernel()) {\n\t\tpci_clear_master(pdev);\n\t\tpcie_flr(pdev);\n\t}\n\n\tmax_irqs = bnxt_get_max_irq(pdev);\n\tdev = alloc_etherdev_mq(sizeof(*bp), max_irqs);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tbp = netdev_priv(dev);\n\tbp->board_idx = ent->driver_data;\n\tbp->msg_enable = BNXT_DEF_MSG_ENABLE;\n\tbnxt_set_max_func_irqs(bp, max_irqs);\n\n\tif (bnxt_vf_pciid(bp->board_idx))\n\t\tbp->flags |= BNXT_FLAG_VF;\n\n\t \n\tif (BNXT_PF(bp))\n\t\tSET_NETDEV_DEVLINK_PORT(dev, &bp->dl_port);\n\n\tif (pdev->msix_cap)\n\t\tbp->flags |= BNXT_FLAG_MSIX_CAP;\n\n\trc = bnxt_init_board(pdev, dev);\n\tif (rc < 0)\n\t\tgoto init_err_free;\n\n\tdev->netdev_ops = &bnxt_netdev_ops;\n\tdev->watchdog_timeo = BNXT_TX_TIMEOUT;\n\tdev->ethtool_ops = &bnxt_ethtool_ops;\n\tpci_set_drvdata(pdev, dev);\n\n\trc = bnxt_alloc_hwrm_resources(bp);\n\tif (rc)\n\t\tgoto init_err_pci_clean;\n\n\tmutex_init(&bp->hwrm_cmd_lock);\n\tmutex_init(&bp->link_lock);\n\n\trc = bnxt_fw_init_one_p1(bp);\n\tif (rc)\n\t\tgoto init_err_pci_clean;\n\n\tif (BNXT_PF(bp))\n\t\tbnxt_vpd_read_info(bp);\n\n\tif (BNXT_CHIP_P5(bp)) {\n\t\tbp->flags |= BNXT_FLAG_CHIP_P5;\n\t\tif (BNXT_CHIP_SR2(bp))\n\t\t\tbp->flags |= BNXT_FLAG_CHIP_SR2;\n\t}\n\n\trc = bnxt_alloc_rss_indir_tbl(bp);\n\tif (rc)\n\t\tgoto init_err_pci_clean;\n\n\trc = bnxt_fw_init_one_p2(bp);\n\tif (rc)\n\t\tgoto init_err_pci_clean;\n\n\trc = bnxt_map_db_bar(bp);\n\tif (rc) {\n\t\tdev_err(&pdev->dev, \"Cannot map doorbell BAR rc = %d, aborting\\n\",\n\t\t\trc);\n\t\tgoto init_err_pci_clean;\n\t}\n\n\tdev->hw_features = NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM | NETIF_F_SG |\n\t\t\t   NETIF_F_TSO | NETIF_F_TSO6 |\n\t\t\t   NETIF_F_GSO_UDP_TUNNEL | NETIF_F_GSO_GRE |\n\t\t\t   NETIF_F_GSO_IPXIP4 |\n\t\t\t   NETIF_F_GSO_UDP_TUNNEL_CSUM | NETIF_F_GSO_GRE_CSUM |\n\t\t\t   NETIF_F_GSO_PARTIAL | NETIF_F_RXHASH |\n\t\t\t   NETIF_F_RXCSUM | NETIF_F_GRO;\n\n\tif (BNXT_SUPPORTS_TPA(bp))\n\t\tdev->hw_features |= NETIF_F_LRO;\n\n\tdev->hw_enc_features =\n\t\t\tNETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM | NETIF_F_SG |\n\t\t\tNETIF_F_TSO | NETIF_F_TSO6 |\n\t\t\tNETIF_F_GSO_UDP_TUNNEL | NETIF_F_GSO_GRE |\n\t\t\tNETIF_F_GSO_UDP_TUNNEL_CSUM | NETIF_F_GSO_GRE_CSUM |\n\t\t\tNETIF_F_GSO_IPXIP4 | NETIF_F_GSO_PARTIAL;\n\tdev->udp_tunnel_nic_info = &bnxt_udp_tunnels;\n\n\tdev->gso_partial_features = NETIF_F_GSO_UDP_TUNNEL_CSUM |\n\t\t\t\t    NETIF_F_GSO_GRE_CSUM;\n\tdev->vlan_features = dev->hw_features | NETIF_F_HIGHDMA;\n\tif (bp->fw_cap & BNXT_FW_CAP_VLAN_RX_STRIP)\n\t\tdev->hw_features |= BNXT_HW_FEATURE_VLAN_ALL_RX;\n\tif (bp->fw_cap & BNXT_FW_CAP_VLAN_TX_INSERT)\n\t\tdev->hw_features |= BNXT_HW_FEATURE_VLAN_ALL_TX;\n\tif (BNXT_SUPPORTS_TPA(bp))\n\t\tdev->hw_features |= NETIF_F_GRO_HW;\n\tdev->features |= dev->hw_features | NETIF_F_HIGHDMA;\n\tif (dev->features & NETIF_F_GRO_HW)\n\t\tdev->features &= ~NETIF_F_LRO;\n\tdev->priv_flags |= IFF_UNICAST_FLT;\n\n\tnetif_set_tso_max_size(dev, GSO_MAX_SIZE);\n\n\tdev->xdp_features = NETDEV_XDP_ACT_BASIC | NETDEV_XDP_ACT_REDIRECT |\n\t\t\t    NETDEV_XDP_ACT_RX_SG;\n\n#ifdef CONFIG_BNXT_SRIOV\n\tinit_waitqueue_head(&bp->sriov_cfg_wait);\n#endif\n\tif (BNXT_SUPPORTS_TPA(bp)) {\n\t\tbp->gro_func = bnxt_gro_func_5730x;\n\t\tif (BNXT_CHIP_P4(bp))\n\t\t\tbp->gro_func = bnxt_gro_func_5731x;\n\t\telse if (BNXT_CHIP_P5(bp))\n\t\t\tbp->gro_func = bnxt_gro_func_5750x;\n\t}\n\tif (!BNXT_CHIP_P4_PLUS(bp))\n\t\tbp->flags |= BNXT_FLAG_DOUBLE_DB;\n\n\trc = bnxt_init_mac_addr(bp);\n\tif (rc) {\n\t\tdev_err(&pdev->dev, \"Unable to initialize mac address.\\n\");\n\t\trc = -EADDRNOTAVAIL;\n\t\tgoto init_err_pci_clean;\n\t}\n\n\tif (BNXT_PF(bp)) {\n\t\t \n\t\trc = bnxt_pcie_dsn_get(bp, bp->dsn);\n\t}\n\n\t \n\tdev->min_mtu = ETH_ZLEN;\n\tdev->max_mtu = bp->max_mtu;\n\n\trc = bnxt_probe_phy(bp, true);\n\tif (rc)\n\t\tgoto init_err_pci_clean;\n\n\tbnxt_set_rx_skb_mode(bp, false);\n\tbnxt_set_tpa_flags(bp);\n\tbnxt_set_ring_params(bp);\n\trc = bnxt_set_dflt_rings(bp, true);\n\tif (rc) {\n\t\tif (BNXT_VF(bp) && rc == -ENODEV) {\n\t\t\tnetdev_err(bp->dev, \"Cannot configure VF rings while PF is unavailable.\\n\");\n\t\t} else {\n\t\t\tnetdev_err(bp->dev, \"Not enough rings available.\\n\");\n\t\t\trc = -ENOMEM;\n\t\t}\n\t\tgoto init_err_pci_clean;\n\t}\n\n\tbnxt_fw_init_one_p3(bp);\n\n\tbnxt_init_dflt_coal(bp);\n\n\tif (dev->hw_features & BNXT_HW_FEATURE_VLAN_ALL_RX)\n\t\tbp->flags |= BNXT_FLAG_STRIP_VLAN;\n\n\trc = bnxt_init_int_mode(bp);\n\tif (rc)\n\t\tgoto init_err_pci_clean;\n\n\t \n\tbp->tx_nr_rings_per_tc = bp->tx_nr_rings;\n\n\tif (BNXT_PF(bp)) {\n\t\tif (!bnxt_pf_wq) {\n\t\t\tbnxt_pf_wq =\n\t\t\t\tcreate_singlethread_workqueue(\"bnxt_pf_wq\");\n\t\t\tif (!bnxt_pf_wq) {\n\t\t\t\tdev_err(&pdev->dev, \"Unable to create workqueue.\\n\");\n\t\t\t\trc = -ENOMEM;\n\t\t\t\tgoto init_err_pci_clean;\n\t\t\t}\n\t\t}\n\t\trc = bnxt_init_tc(bp);\n\t\tif (rc)\n\t\t\tnetdev_err(dev, \"Failed to initialize TC flower offload, err = %d.\\n\",\n\t\t\t\t   rc);\n\t}\n\n\tbnxt_inv_fw_health_reg(bp);\n\trc = bnxt_dl_register(bp);\n\tif (rc)\n\t\tgoto init_err_dl;\n\n\trc = register_netdev(dev);\n\tif (rc)\n\t\tgoto init_err_cleanup;\n\n\tbnxt_dl_fw_reporters_create(bp);\n\n\tbnxt_rdma_aux_device_init(bp);\n\n\tbnxt_print_device_info(bp);\n\n\tpci_save_state(pdev);\n\n\treturn 0;\ninit_err_cleanup:\n\tbnxt_dl_unregister(bp);\ninit_err_dl:\n\tbnxt_shutdown_tc(bp);\n\tbnxt_clear_int_mode(bp);\n\ninit_err_pci_clean:\n\tbnxt_hwrm_func_drv_unrgtr(bp);\n\tbnxt_free_hwrm_resources(bp);\n\tbnxt_ethtool_free(bp);\n\tbnxt_ptp_clear(bp);\n\tkfree(bp->ptp_cfg);\n\tbp->ptp_cfg = NULL;\n\tkfree(bp->fw_health);\n\tbp->fw_health = NULL;\n\tbnxt_cleanup_pci(bp);\n\tbnxt_free_ctx_mem(bp);\n\tkfree(bp->ctx);\n\tbp->ctx = NULL;\n\tkfree(bp->rss_indir_tbl);\n\tbp->rss_indir_tbl = NULL;\n\ninit_err_free:\n\tfree_netdev(dev);\n\treturn rc;\n}\n\nstatic void bnxt_shutdown(struct pci_dev *pdev)\n{\n\tstruct net_device *dev = pci_get_drvdata(pdev);\n\tstruct bnxt *bp;\n\n\tif (!dev)\n\t\treturn;\n\n\trtnl_lock();\n\tbp = netdev_priv(dev);\n\tif (!bp)\n\t\tgoto shutdown_exit;\n\n\tif (netif_running(dev))\n\t\tdev_close(dev);\n\n\tbnxt_clear_int_mode(bp);\n\tpci_disable_device(pdev);\n\n\tif (system_state == SYSTEM_POWER_OFF) {\n\t\tpci_wake_from_d3(pdev, bp->wol);\n\t\tpci_set_power_state(pdev, PCI_D3hot);\n\t}\n\nshutdown_exit:\n\trtnl_unlock();\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int bnxt_suspend(struct device *device)\n{\n\tstruct net_device *dev = dev_get_drvdata(device);\n\tstruct bnxt *bp = netdev_priv(dev);\n\tint rc = 0;\n\n\trtnl_lock();\n\tbnxt_ulp_stop(bp);\n\tif (netif_running(dev)) {\n\t\tnetif_device_detach(dev);\n\t\trc = bnxt_close(dev);\n\t}\n\tbnxt_hwrm_func_drv_unrgtr(bp);\n\tpci_disable_device(bp->pdev);\n\tbnxt_free_ctx_mem(bp);\n\tkfree(bp->ctx);\n\tbp->ctx = NULL;\n\trtnl_unlock();\n\treturn rc;\n}\n\nstatic int bnxt_resume(struct device *device)\n{\n\tstruct net_device *dev = dev_get_drvdata(device);\n\tstruct bnxt *bp = netdev_priv(dev);\n\tint rc = 0;\n\n\trtnl_lock();\n\trc = pci_enable_device(bp->pdev);\n\tif (rc) {\n\t\tnetdev_err(dev, \"Cannot re-enable PCI device during resume, err = %d\\n\",\n\t\t\t   rc);\n\t\tgoto resume_exit;\n\t}\n\tpci_set_master(bp->pdev);\n\tif (bnxt_hwrm_ver_get(bp)) {\n\t\trc = -ENODEV;\n\t\tgoto resume_exit;\n\t}\n\trc = bnxt_hwrm_func_reset(bp);\n\tif (rc) {\n\t\trc = -EBUSY;\n\t\tgoto resume_exit;\n\t}\n\n\trc = bnxt_hwrm_func_qcaps(bp);\n\tif (rc)\n\t\tgoto resume_exit;\n\n\tbnxt_clear_reservations(bp, true);\n\n\tif (bnxt_hwrm_func_drv_rgtr(bp, NULL, 0, false)) {\n\t\trc = -ENODEV;\n\t\tgoto resume_exit;\n\t}\n\n\tbnxt_get_wol_settings(bp);\n\tif (netif_running(dev)) {\n\t\trc = bnxt_open(dev);\n\t\tif (!rc)\n\t\t\tnetif_device_attach(dev);\n\t}\n\nresume_exit:\n\tbnxt_ulp_start(bp, rc);\n\tif (!rc)\n\t\tbnxt_reenable_sriov(bp);\n\trtnl_unlock();\n\treturn rc;\n}\n\nstatic SIMPLE_DEV_PM_OPS(bnxt_pm_ops, bnxt_suspend, bnxt_resume);\n#define BNXT_PM_OPS (&bnxt_pm_ops)\n\n#else\n\n#define BNXT_PM_OPS NULL\n\n#endif  \n\n \nstatic pci_ers_result_t bnxt_io_error_detected(struct pci_dev *pdev,\n\t\t\t\t\t       pci_channel_state_t state)\n{\n\tstruct net_device *netdev = pci_get_drvdata(pdev);\n\tstruct bnxt *bp = netdev_priv(netdev);\n\n\tnetdev_info(netdev, \"PCI I/O error detected\\n\");\n\n\trtnl_lock();\n\tnetif_device_detach(netdev);\n\n\tbnxt_ulp_stop(bp);\n\n\tif (state == pci_channel_io_perm_failure) {\n\t\trtnl_unlock();\n\t\treturn PCI_ERS_RESULT_DISCONNECT;\n\t}\n\n\tif (state == pci_channel_io_frozen)\n\t\tset_bit(BNXT_STATE_PCI_CHANNEL_IO_FROZEN, &bp->state);\n\n\tif (netif_running(netdev))\n\t\tbnxt_close(netdev);\n\n\tif (pci_is_enabled(pdev))\n\t\tpci_disable_device(pdev);\n\tbnxt_free_ctx_mem(bp);\n\tkfree(bp->ctx);\n\tbp->ctx = NULL;\n\trtnl_unlock();\n\n\t \n\treturn PCI_ERS_RESULT_NEED_RESET;\n}\n\n \nstatic pci_ers_result_t bnxt_io_slot_reset(struct pci_dev *pdev)\n{\n\tpci_ers_result_t result = PCI_ERS_RESULT_DISCONNECT;\n\tstruct net_device *netdev = pci_get_drvdata(pdev);\n\tstruct bnxt *bp = netdev_priv(netdev);\n\tint retry = 0;\n\tint err = 0;\n\tint off;\n\n\tnetdev_info(bp->dev, \"PCI Slot Reset\\n\");\n\n\trtnl_lock();\n\n\tif (pci_enable_device(pdev)) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Cannot re-enable PCI device after reset.\\n\");\n\t} else {\n\t\tpci_set_master(pdev);\n\t\t \n\t\tif (test_and_clear_bit(BNXT_STATE_PCI_CHANNEL_IO_FROZEN,\n\t\t\t\t       &bp->state)) {\n\t\t\tfor (off = PCI_BASE_ADDRESS_0;\n\t\t\t     off <= PCI_BASE_ADDRESS_5; off += 4)\n\t\t\t\tpci_write_config_dword(bp->pdev, off, 0);\n\t\t}\n\t\tpci_restore_state(pdev);\n\t\tpci_save_state(pdev);\n\n\t\tbnxt_inv_fw_health_reg(bp);\n\t\tbnxt_try_map_fw_health_reg(bp);\n\n\t\t \n\t\tdo {\n\t\t\terr = bnxt_try_recover_fw(bp);\n\t\t\tif (!err)\n\t\t\t\tbreak;\n\t\t\tretry++;\n\t\t} while (retry < BNXT_FW_SLOT_RESET_RETRY);\n\n\t\tif (err) {\n\t\t\tdev_err(&pdev->dev, \"Firmware not ready\\n\");\n\t\t\tgoto reset_exit;\n\t\t}\n\n\t\terr = bnxt_hwrm_func_reset(bp);\n\t\tif (!err)\n\t\t\tresult = PCI_ERS_RESULT_RECOVERED;\n\n\t\tbnxt_ulp_irq_stop(bp);\n\t\tbnxt_clear_int_mode(bp);\n\t\terr = bnxt_init_int_mode(bp);\n\t\tbnxt_ulp_irq_restart(bp, err);\n\t}\n\nreset_exit:\n\tbnxt_clear_reservations(bp, true);\n\trtnl_unlock();\n\n\treturn result;\n}\n\n \nstatic void bnxt_io_resume(struct pci_dev *pdev)\n{\n\tstruct net_device *netdev = pci_get_drvdata(pdev);\n\tstruct bnxt *bp = netdev_priv(netdev);\n\tint err;\n\n\tnetdev_info(bp->dev, \"PCI Slot Resume\\n\");\n\trtnl_lock();\n\n\terr = bnxt_hwrm_func_qcaps(bp);\n\tif (!err && netif_running(netdev))\n\t\terr = bnxt_open(netdev);\n\n\tbnxt_ulp_start(bp, err);\n\tif (!err) {\n\t\tbnxt_reenable_sriov(bp);\n\t\tnetif_device_attach(netdev);\n\t}\n\n\trtnl_unlock();\n}\n\nstatic const struct pci_error_handlers bnxt_err_handler = {\n\t.error_detected\t= bnxt_io_error_detected,\n\t.slot_reset\t= bnxt_io_slot_reset,\n\t.resume\t\t= bnxt_io_resume\n};\n\nstatic struct pci_driver bnxt_pci_driver = {\n\t.name\t\t= DRV_MODULE_NAME,\n\t.id_table\t= bnxt_pci_tbl,\n\t.probe\t\t= bnxt_init_one,\n\t.remove\t\t= bnxt_remove_one,\n\t.shutdown\t= bnxt_shutdown,\n\t.driver.pm\t= BNXT_PM_OPS,\n\t.err_handler\t= &bnxt_err_handler,\n#if defined(CONFIG_BNXT_SRIOV)\n\t.sriov_configure = bnxt_sriov_configure,\n#endif\n};\n\nstatic int __init bnxt_init(void)\n{\n\tint err;\n\n\tbnxt_debug_init();\n\terr = pci_register_driver(&bnxt_pci_driver);\n\tif (err) {\n\t\tbnxt_debug_exit();\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic void __exit bnxt_exit(void)\n{\n\tpci_unregister_driver(&bnxt_pci_driver);\n\tif (bnxt_pf_wq)\n\t\tdestroy_workqueue(bnxt_pf_wq);\n\tbnxt_debug_exit();\n}\n\nmodule_init(bnxt_init);\nmodule_exit(bnxt_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}