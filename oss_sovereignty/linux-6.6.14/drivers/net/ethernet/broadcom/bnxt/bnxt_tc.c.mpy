{
  "module_name": "bnxt_tc.c",
  "hash_id": "e70a3051df869808bb201fb25214e25c300f0cdbf5bdd0f2ed40cdcfbb478d28",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/broadcom/bnxt/bnxt_tc.c",
  "human_readable_source": " \n\n#include <linux/netdevice.h>\n#include <linux/inetdevice.h>\n#include <linux/if_vlan.h>\n#include <net/flow_dissector.h>\n#include <net/pkt_cls.h>\n#include <net/tc_act/tc_gact.h>\n#include <net/tc_act/tc_skbedit.h>\n#include <net/tc_act/tc_mirred.h>\n#include <net/tc_act/tc_vlan.h>\n#include <net/tc_act/tc_pedit.h>\n#include <net/tc_act/tc_tunnel_key.h>\n#include <net/vxlan.h>\n\n#include \"bnxt_hsi.h\"\n#include \"bnxt.h\"\n#include \"bnxt_hwrm.h\"\n#include \"bnxt_sriov.h\"\n#include \"bnxt_tc.h\"\n#include \"bnxt_vfr.h\"\n\n#define BNXT_FID_INVALID\t\t\t0xffff\n#define VLAN_TCI(vid, prio)\t((vid) | ((prio) << VLAN_PRIO_SHIFT))\n\n#define is_vlan_pcp_wildcarded(vlan_tci_mask)\t\\\n\t((ntohs(vlan_tci_mask) & VLAN_PRIO_MASK) == 0x0000)\n#define is_vlan_pcp_exactmatch(vlan_tci_mask)\t\\\n\t((ntohs(vlan_tci_mask) & VLAN_PRIO_MASK) == VLAN_PRIO_MASK)\n#define is_vlan_pcp_zero(vlan_tci)\t\\\n\t((ntohs(vlan_tci) & VLAN_PRIO_MASK) == 0x0000)\n#define is_vid_exactmatch(vlan_tci_mask)\t\\\n\t((ntohs(vlan_tci_mask) & VLAN_VID_MASK) == VLAN_VID_MASK)\n\nstatic bool is_wildcard(void *mask, int len);\nstatic bool is_exactmatch(void *mask, int len);\n \nstatic u16 bnxt_flow_get_dst_fid(struct bnxt *pf_bp, struct net_device *dev)\n{\n\tstruct bnxt *bp;\n\n\t \n\tif (!netdev_port_same_parent_id(pf_bp->dev, dev)) {\n\t\tnetdev_info(pf_bp->dev, \"dev(ifindex=%d) not on same switch\\n\",\n\t\t\t    dev->ifindex);\n\t\treturn BNXT_FID_INVALID;\n\t}\n\n\t \n\tif (bnxt_dev_is_vf_rep(dev))\n\t\treturn bnxt_vf_rep_get_fid(dev);\n\n\tbp = netdev_priv(dev);\n\treturn bp->pf.fw_fid;\n}\n\nstatic int bnxt_tc_parse_redir(struct bnxt *bp,\n\t\t\t       struct bnxt_tc_actions *actions,\n\t\t\t       const struct flow_action_entry *act)\n{\n\tstruct net_device *dev = act->dev;\n\n\tif (!dev) {\n\t\tnetdev_info(bp->dev, \"no dev in mirred action\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tactions->flags |= BNXT_TC_ACTION_FLAG_FWD;\n\tactions->dst_dev = dev;\n\treturn 0;\n}\n\nstatic int bnxt_tc_parse_vlan(struct bnxt *bp,\n\t\t\t      struct bnxt_tc_actions *actions,\n\t\t\t      const struct flow_action_entry *act)\n{\n\tswitch (act->id) {\n\tcase FLOW_ACTION_VLAN_POP:\n\t\tactions->flags |= BNXT_TC_ACTION_FLAG_POP_VLAN;\n\t\tbreak;\n\tcase FLOW_ACTION_VLAN_PUSH:\n\t\tactions->flags |= BNXT_TC_ACTION_FLAG_PUSH_VLAN;\n\t\tactions->push_vlan_tci = htons(act->vlan.vid);\n\t\tactions->push_vlan_tpid = act->vlan.proto;\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn 0;\n}\n\nstatic int bnxt_tc_parse_tunnel_set(struct bnxt *bp,\n\t\t\t\t    struct bnxt_tc_actions *actions,\n\t\t\t\t    const struct flow_action_entry *act)\n{\n\tconst struct ip_tunnel_info *tun_info = act->tunnel;\n\tconst struct ip_tunnel_key *tun_key = &tun_info->key;\n\n\tif (ip_tunnel_info_af(tun_info) != AF_INET) {\n\t\tnetdev_info(bp->dev, \"only IPv4 tunnel-encap is supported\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tactions->tun_encap_key = *tun_key;\n\tactions->flags |= BNXT_TC_ACTION_FLAG_TUNNEL_ENCAP;\n\treturn 0;\n}\n\n \nstatic void bnxt_set_l2_key_mask(u32 part_key, u32 part_mask,\n\t\t\t\t u8 *actual_key, u8 *actual_mask)\n{\n\tu32 key = get_unaligned((u32 *)actual_key);\n\tu32 mask = get_unaligned((u32 *)actual_mask);\n\n\tpart_key &= part_mask;\n\tpart_key |= key & ~part_mask;\n\n\tput_unaligned(mask | part_mask, (u32 *)actual_mask);\n\tput_unaligned(part_key, (u32 *)actual_key);\n}\n\nstatic int\nbnxt_fill_l2_rewrite_fields(struct bnxt_tc_actions *actions,\n\t\t\t    u16 *eth_addr, u16 *eth_addr_mask)\n{\n\tu16 *p;\n\tint j;\n\n\tif (unlikely(bnxt_eth_addr_key_mask_invalid(eth_addr, eth_addr_mask)))\n\t\treturn -EINVAL;\n\n\tif (!is_wildcard(&eth_addr_mask[0], ETH_ALEN)) {\n\t\tif (!is_exactmatch(&eth_addr_mask[0], ETH_ALEN))\n\t\t\treturn -EINVAL;\n\t\t \n\t\tp = eth_addr;\n\t\tfor (j = 0; j < 3; j++)\n\t\t\tactions->l2_rewrite_dmac[j] = cpu_to_be16(*(p + j));\n\t}\n\n\tif (!is_wildcard(&eth_addr_mask[ETH_ALEN / 2], ETH_ALEN)) {\n\t\tif (!is_exactmatch(&eth_addr_mask[ETH_ALEN / 2], ETH_ALEN))\n\t\t\treturn -EINVAL;\n\t\t \n\t\tp = &eth_addr[ETH_ALEN / 2];\n\t\tfor (j = 0; j < 3; j++)\n\t\t\tactions->l2_rewrite_smac[j] = cpu_to_be16(*(p + j));\n\t}\n\n\treturn 0;\n}\n\nstatic int\nbnxt_tc_parse_pedit(struct bnxt *bp, struct bnxt_tc_actions *actions,\n\t\t    struct flow_action_entry *act, int act_idx, u8 *eth_addr,\n\t\t    u8 *eth_addr_mask)\n{\n\tsize_t offset_of_ip6_daddr = offsetof(struct ipv6hdr, daddr);\n\tsize_t offset_of_ip6_saddr = offsetof(struct ipv6hdr, saddr);\n\tu32 mask, val, offset, idx;\n\tu8 htype;\n\n\toffset = act->mangle.offset;\n\thtype = act->mangle.htype;\n\tmask = ~act->mangle.mask;\n\tval = act->mangle.val;\n\n\tswitch (htype) {\n\tcase FLOW_ACT_MANGLE_HDR_TYPE_ETH:\n\t\tif (offset > PEDIT_OFFSET_SMAC_LAST_4_BYTES) {\n\t\t\tnetdev_err(bp->dev,\n\t\t\t\t   \"%s: eth_hdr: Invalid pedit field\\n\",\n\t\t\t\t   __func__);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tactions->flags |= BNXT_TC_ACTION_FLAG_L2_REWRITE;\n\n\t\tbnxt_set_l2_key_mask(val, mask, &eth_addr[offset],\n\t\t\t\t     &eth_addr_mask[offset]);\n\t\tbreak;\n\tcase FLOW_ACT_MANGLE_HDR_TYPE_IP4:\n\t\tactions->flags |= BNXT_TC_ACTION_FLAG_NAT_XLATE;\n\t\tactions->nat.l3_is_ipv4 = true;\n\t\tif (offset ==  offsetof(struct iphdr, saddr)) {\n\t\t\tactions->nat.src_xlate = true;\n\t\t\tactions->nat.l3.ipv4.saddr.s_addr = htonl(val);\n\t\t} else if (offset ==  offsetof(struct iphdr, daddr)) {\n\t\t\tactions->nat.src_xlate = false;\n\t\t\tactions->nat.l3.ipv4.daddr.s_addr = htonl(val);\n\t\t} else {\n\t\t\tnetdev_err(bp->dev,\n\t\t\t\t   \"%s: IPv4_hdr: Invalid pedit field\\n\",\n\t\t\t\t   __func__);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tnetdev_dbg(bp->dev, \"nat.src_xlate = %d src IP: %pI4 dst ip : %pI4\\n\",\n\t\t\t   actions->nat.src_xlate, &actions->nat.l3.ipv4.saddr,\n\t\t\t   &actions->nat.l3.ipv4.daddr);\n\t\tbreak;\n\n\tcase FLOW_ACT_MANGLE_HDR_TYPE_IP6:\n\t\tactions->flags |= BNXT_TC_ACTION_FLAG_NAT_XLATE;\n\t\tactions->nat.l3_is_ipv4 = false;\n\t\tif (offset >= offsetof(struct ipv6hdr, saddr) &&\n\t\t    offset < offset_of_ip6_daddr) {\n\t\t\t \n\t\t\tactions->nat.src_xlate = true;\n\t\t\tidx = (offset - offset_of_ip6_saddr) / 4;\n\t\t\t \n\t\t\tactions->nat.l3.ipv6.saddr.s6_addr32[idx] = htonl(val);\n\t\t} else if (offset >= offset_of_ip6_daddr &&\n\t\t\t   offset < offset_of_ip6_daddr + 16) {\n\t\t\tactions->nat.src_xlate = false;\n\t\t\tidx = (offset - offset_of_ip6_daddr) / 4;\n\t\t\tactions->nat.l3.ipv6.saddr.s6_addr32[idx] = htonl(val);\n\t\t} else {\n\t\t\tnetdev_err(bp->dev,\n\t\t\t\t   \"%s: IPv6_hdr: Invalid pedit field\\n\",\n\t\t\t\t   __func__);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase FLOW_ACT_MANGLE_HDR_TYPE_TCP:\n\tcase FLOW_ACT_MANGLE_HDR_TYPE_UDP:\n\t\t \n\t\tif (!(actions->flags & BNXT_TC_ACTION_FLAG_NAT_XLATE)) {\n\t\t\tnetdev_err(bp->dev,\n\t\t\t\t   \"Need to specify L3 rewrite as well\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (actions->nat.src_xlate)\n\t\t\tactions->nat.l4.ports.sport = htons(val);\n\t\telse\n\t\t\tactions->nat.l4.ports.dport = htons(val);\n\t\tnetdev_dbg(bp->dev, \"actions->nat.sport = %d dport = %d\\n\",\n\t\t\t   actions->nat.l4.ports.sport,\n\t\t\t   actions->nat.l4.ports.dport);\n\t\tbreak;\n\tdefault:\n\t\tnetdev_err(bp->dev, \"%s: Unsupported pedit hdr type\\n\",\n\t\t\t   __func__);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int bnxt_tc_parse_actions(struct bnxt *bp,\n\t\t\t\t struct bnxt_tc_actions *actions,\n\t\t\t\t struct flow_action *flow_action,\n\t\t\t\t struct netlink_ext_ack *extack)\n{\n\t \n\tu16 eth_addr_mask[ETH_ALEN] = { 0 };\n\t \n\tu16 eth_addr[ETH_ALEN] = { 0 };\n\tstruct flow_action_entry *act;\n\tint i, rc;\n\n\tif (!flow_action_has_entries(flow_action)) {\n\t\tnetdev_info(bp->dev, \"no actions\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!flow_action_basic_hw_stats_check(flow_action, extack))\n\t\treturn -EOPNOTSUPP;\n\n\tflow_action_for_each(i, act, flow_action) {\n\t\tswitch (act->id) {\n\t\tcase FLOW_ACTION_DROP:\n\t\t\tactions->flags |= BNXT_TC_ACTION_FLAG_DROP;\n\t\t\treturn 0;  \n\t\tcase FLOW_ACTION_REDIRECT:\n\t\t\trc = bnxt_tc_parse_redir(bp, actions, act);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t\tbreak;\n\t\tcase FLOW_ACTION_VLAN_POP:\n\t\tcase FLOW_ACTION_VLAN_PUSH:\n\t\tcase FLOW_ACTION_VLAN_MANGLE:\n\t\t\trc = bnxt_tc_parse_vlan(bp, actions, act);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t\tbreak;\n\t\tcase FLOW_ACTION_TUNNEL_ENCAP:\n\t\t\trc = bnxt_tc_parse_tunnel_set(bp, actions, act);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t\tbreak;\n\t\tcase FLOW_ACTION_TUNNEL_DECAP:\n\t\t\tactions->flags |= BNXT_TC_ACTION_FLAG_TUNNEL_DECAP;\n\t\t\tbreak;\n\t\t \n\t\tcase FLOW_ACTION_MANGLE:\n\t\t\trc = bnxt_tc_parse_pedit(bp, actions, act, i,\n\t\t\t\t\t\t (u8 *)eth_addr,\n\t\t\t\t\t\t (u8 *)eth_addr_mask);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (actions->flags & BNXT_TC_ACTION_FLAG_L2_REWRITE) {\n\t\trc = bnxt_fill_l2_rewrite_fields(actions, eth_addr,\n\t\t\t\t\t\t eth_addr_mask);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\tif (actions->flags & BNXT_TC_ACTION_FLAG_FWD) {\n\t\tif (actions->flags & BNXT_TC_ACTION_FLAG_TUNNEL_ENCAP) {\n\t\t\t \n\t\t\tactions->dst_fid = bp->pf.fw_fid;\n\t\t} else {\n\t\t\t \n\t\t\tactions->dst_fid =\n\t\t\t\tbnxt_flow_get_dst_fid(bp, actions->dst_dev);\n\t\t\tif (actions->dst_fid == BNXT_FID_INVALID)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int bnxt_tc_parse_flow(struct bnxt *bp,\n\t\t\t      struct flow_cls_offload *tc_flow_cmd,\n\t\t\t      struct bnxt_tc_flow *flow)\n{\n\tstruct flow_rule *rule = flow_cls_offload_flow_rule(tc_flow_cmd);\n\tstruct flow_dissector *dissector = rule->match.dissector;\n\n\t \n\tif ((dissector->used_keys & BIT_ULL(FLOW_DISSECTOR_KEY_CONTROL)) == 0 ||\n\t    (dissector->used_keys & BIT_ULL(FLOW_DISSECTOR_KEY_BASIC)) == 0) {\n\t\tnetdev_info(bp->dev, \"cannot form TC key: used_keys = 0x%llx\\n\",\n\t\t\t    dissector->used_keys);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_BASIC)) {\n\t\tstruct flow_match_basic match;\n\n\t\tflow_rule_match_basic(rule, &match);\n\t\tflow->l2_key.ether_type = match.key->n_proto;\n\t\tflow->l2_mask.ether_type = match.mask->n_proto;\n\n\t\tif (match.key->n_proto == htons(ETH_P_IP) ||\n\t\t    match.key->n_proto == htons(ETH_P_IPV6)) {\n\t\t\tflow->l4_key.ip_proto = match.key->ip_proto;\n\t\t\tflow->l4_mask.ip_proto = match.mask->ip_proto;\n\t\t}\n\t}\n\n\tif (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_ETH_ADDRS)) {\n\t\tstruct flow_match_eth_addrs match;\n\n\t\tflow_rule_match_eth_addrs(rule, &match);\n\t\tflow->flags |= BNXT_TC_FLOW_FLAGS_ETH_ADDRS;\n\t\tether_addr_copy(flow->l2_key.dmac, match.key->dst);\n\t\tether_addr_copy(flow->l2_mask.dmac, match.mask->dst);\n\t\tether_addr_copy(flow->l2_key.smac, match.key->src);\n\t\tether_addr_copy(flow->l2_mask.smac, match.mask->src);\n\t}\n\n\tif (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_VLAN)) {\n\t\tstruct flow_match_vlan match;\n\n\t\tflow_rule_match_vlan(rule, &match);\n\t\tflow->l2_key.inner_vlan_tci =\n\t\t\tcpu_to_be16(VLAN_TCI(match.key->vlan_id,\n\t\t\t\t\t     match.key->vlan_priority));\n\t\tflow->l2_mask.inner_vlan_tci =\n\t\t\tcpu_to_be16((VLAN_TCI(match.mask->vlan_id,\n\t\t\t\t\t      match.mask->vlan_priority)));\n\t\tflow->l2_key.inner_vlan_tpid = htons(ETH_P_8021Q);\n\t\tflow->l2_mask.inner_vlan_tpid = htons(0xffff);\n\t\tflow->l2_key.num_vlans = 1;\n\t}\n\n\tif (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_IPV4_ADDRS)) {\n\t\tstruct flow_match_ipv4_addrs match;\n\n\t\tflow_rule_match_ipv4_addrs(rule, &match);\n\t\tflow->flags |= BNXT_TC_FLOW_FLAGS_IPV4_ADDRS;\n\t\tflow->l3_key.ipv4.daddr.s_addr = match.key->dst;\n\t\tflow->l3_mask.ipv4.daddr.s_addr = match.mask->dst;\n\t\tflow->l3_key.ipv4.saddr.s_addr = match.key->src;\n\t\tflow->l3_mask.ipv4.saddr.s_addr = match.mask->src;\n\t} else if (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_IPV6_ADDRS)) {\n\t\tstruct flow_match_ipv6_addrs match;\n\n\t\tflow_rule_match_ipv6_addrs(rule, &match);\n\t\tflow->flags |= BNXT_TC_FLOW_FLAGS_IPV6_ADDRS;\n\t\tflow->l3_key.ipv6.daddr = match.key->dst;\n\t\tflow->l3_mask.ipv6.daddr = match.mask->dst;\n\t\tflow->l3_key.ipv6.saddr = match.key->src;\n\t\tflow->l3_mask.ipv6.saddr = match.mask->src;\n\t}\n\n\tif (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_PORTS)) {\n\t\tstruct flow_match_ports match;\n\n\t\tflow_rule_match_ports(rule, &match);\n\t\tflow->flags |= BNXT_TC_FLOW_FLAGS_PORTS;\n\t\tflow->l4_key.ports.dport = match.key->dst;\n\t\tflow->l4_mask.ports.dport = match.mask->dst;\n\t\tflow->l4_key.ports.sport = match.key->src;\n\t\tflow->l4_mask.ports.sport = match.mask->src;\n\t}\n\n\tif (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_ICMP)) {\n\t\tstruct flow_match_icmp match;\n\n\t\tflow_rule_match_icmp(rule, &match);\n\t\tflow->flags |= BNXT_TC_FLOW_FLAGS_ICMP;\n\t\tflow->l4_key.icmp.type = match.key->type;\n\t\tflow->l4_key.icmp.code = match.key->code;\n\t\tflow->l4_mask.icmp.type = match.mask->type;\n\t\tflow->l4_mask.icmp.code = match.mask->code;\n\t}\n\n\tif (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_ENC_IPV4_ADDRS)) {\n\t\tstruct flow_match_ipv4_addrs match;\n\n\t\tflow_rule_match_enc_ipv4_addrs(rule, &match);\n\t\tflow->flags |= BNXT_TC_FLOW_FLAGS_TUNL_IPV4_ADDRS;\n\t\tflow->tun_key.u.ipv4.dst = match.key->dst;\n\t\tflow->tun_mask.u.ipv4.dst = match.mask->dst;\n\t\tflow->tun_key.u.ipv4.src = match.key->src;\n\t\tflow->tun_mask.u.ipv4.src = match.mask->src;\n\t} else if (flow_rule_match_key(rule,\n\t\t\t\t      FLOW_DISSECTOR_KEY_ENC_IPV6_ADDRS)) {\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_ENC_KEYID)) {\n\t\tstruct flow_match_enc_keyid match;\n\n\t\tflow_rule_match_enc_keyid(rule, &match);\n\t\tflow->flags |= BNXT_TC_FLOW_FLAGS_TUNL_ID;\n\t\tflow->tun_key.tun_id = key32_to_tunnel_id(match.key->keyid);\n\t\tflow->tun_mask.tun_id = key32_to_tunnel_id(match.mask->keyid);\n\t}\n\n\tif (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_ENC_PORTS)) {\n\t\tstruct flow_match_ports match;\n\n\t\tflow_rule_match_enc_ports(rule, &match);\n\t\tflow->flags |= BNXT_TC_FLOW_FLAGS_TUNL_PORTS;\n\t\tflow->tun_key.tp_dst = match.key->dst;\n\t\tflow->tun_mask.tp_dst = match.mask->dst;\n\t\tflow->tun_key.tp_src = match.key->src;\n\t\tflow->tun_mask.tp_src = match.mask->src;\n\t}\n\n\treturn bnxt_tc_parse_actions(bp, &flow->actions, &rule->action,\n\t\t\t\t     tc_flow_cmd->common.extack);\n}\n\nstatic int bnxt_hwrm_cfa_flow_free(struct bnxt *bp,\n\t\t\t\t   struct bnxt_tc_flow_node *flow_node)\n{\n\tstruct hwrm_cfa_flow_free_input *req;\n\tint rc;\n\n\trc = hwrm_req_init(bp, req, HWRM_CFA_FLOW_FREE);\n\tif (!rc) {\n\t\tif (bp->fw_cap & BNXT_FW_CAP_OVS_64BIT_HANDLE)\n\t\t\treq->ext_flow_handle = flow_node->ext_flow_handle;\n\t\telse\n\t\t\treq->flow_handle = flow_node->flow_handle;\n\n\t\trc = hwrm_req_send(bp, req);\n\t}\n\tif (rc)\n\t\tnetdev_info(bp->dev, \"%s: Error rc=%d\\n\", __func__, rc);\n\n\treturn rc;\n}\n\nstatic int ipv6_mask_len(struct in6_addr *mask)\n{\n\tint mask_len = 0, i;\n\n\tfor (i = 0; i < 4; i++)\n\t\tmask_len += inet_mask_len(mask->s6_addr32[i]);\n\n\treturn mask_len;\n}\n\nstatic bool is_wildcard(void *mask, int len)\n{\n\tconst u8 *p = mask;\n\tint i;\n\n\tfor (i = 0; i < len; i++) {\n\t\tif (p[i] != 0)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic bool is_exactmatch(void *mask, int len)\n{\n\tconst u8 *p = mask;\n\tint i;\n\n\tfor (i = 0; i < len; i++)\n\t\tif (p[i] != 0xff)\n\t\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool is_vlan_tci_allowed(__be16  vlan_tci_mask,\n\t\t\t\t__be16  vlan_tci)\n{\n\t \n\tif (is_vid_exactmatch(vlan_tci_mask) &&\n\t    ((is_vlan_pcp_exactmatch(vlan_tci_mask) &&\n\t      is_vlan_pcp_zero(vlan_tci)) ||\n\t     is_vlan_pcp_wildcarded(vlan_tci_mask)))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic bool bits_set(void *key, int len)\n{\n\tconst u8 *p = key;\n\tint i;\n\n\tfor (i = 0; i < len; i++)\n\t\tif (p[i] != 0)\n\t\t\treturn true;\n\n\treturn false;\n}\n\nstatic int bnxt_hwrm_cfa_flow_alloc(struct bnxt *bp, struct bnxt_tc_flow *flow,\n\t\t\t\t    __le16 ref_flow_handle,\n\t\t\t\t    __le32 tunnel_handle,\n\t\t\t\t    struct bnxt_tc_flow_node *flow_node)\n{\n\tstruct bnxt_tc_actions *actions = &flow->actions;\n\tstruct bnxt_tc_l3_key *l3_mask = &flow->l3_mask;\n\tstruct bnxt_tc_l3_key *l3_key = &flow->l3_key;\n\tstruct hwrm_cfa_flow_alloc_output *resp;\n\tstruct hwrm_cfa_flow_alloc_input *req;\n\tu16 flow_flags = 0, action_flags = 0;\n\tint rc;\n\n\trc = hwrm_req_init(bp, req, HWRM_CFA_FLOW_ALLOC);\n\tif (rc)\n\t\treturn rc;\n\n\treq->src_fid = cpu_to_le16(flow->src_fid);\n\treq->ref_flow_handle = ref_flow_handle;\n\n\tif (actions->flags & BNXT_TC_ACTION_FLAG_L2_REWRITE) {\n\t\tmemcpy(req->l2_rewrite_dmac, actions->l2_rewrite_dmac,\n\t\t       ETH_ALEN);\n\t\tmemcpy(req->l2_rewrite_smac, actions->l2_rewrite_smac,\n\t\t       ETH_ALEN);\n\t\taction_flags |=\n\t\t\tCFA_FLOW_ALLOC_REQ_ACTION_FLAGS_L2_HEADER_REWRITE;\n\t}\n\n\tif (actions->flags & BNXT_TC_ACTION_FLAG_NAT_XLATE) {\n\t\tif (actions->nat.l3_is_ipv4) {\n\t\t\taction_flags |=\n\t\t\t\tCFA_FLOW_ALLOC_REQ_ACTION_FLAGS_NAT_IPV4_ADDRESS;\n\n\t\t\tif (actions->nat.src_xlate) {\n\t\t\t\taction_flags |=\n\t\t\t\t\tCFA_FLOW_ALLOC_REQ_ACTION_FLAGS_NAT_SRC;\n\t\t\t\t \n\t\t\t\treq->nat_ip_address[0] =\n\t\t\t\t\tactions->nat.l3.ipv4.saddr.s_addr;\n\t\t\t\t \n\t\t\t\tif (actions->nat.l4.ports.sport)\n\t\t\t\t\treq->nat_port =\n\t\t\t\t\t\tactions->nat.l4.ports.sport;\n\t\t\t} else {\n\t\t\t\taction_flags |=\n\t\t\t\t\tCFA_FLOW_ALLOC_REQ_ACTION_FLAGS_NAT_DEST;\n\t\t\t\t \n\t\t\t\treq->nat_ip_address[0] =\n\t\t\t\t\tactions->nat.l3.ipv4.daddr.s_addr;\n\t\t\t\t \n\t\t\t\tif (actions->nat.l4.ports.dport)\n\t\t\t\t\treq->nat_port =\n\t\t\t\t\t\tactions->nat.l4.ports.dport;\n\t\t\t}\n\t\t\tnetdev_dbg(bp->dev,\n\t\t\t\t   \"req->nat_ip_address: %pI4 src_xlate: %d req->nat_port: %x\\n\",\n\t\t\t\t   req->nat_ip_address, actions->nat.src_xlate,\n\t\t\t\t   req->nat_port);\n\t\t} else {\n\t\t\tif (actions->nat.src_xlate) {\n\t\t\t\taction_flags |=\n\t\t\t\t\tCFA_FLOW_ALLOC_REQ_ACTION_FLAGS_NAT_SRC;\n\t\t\t\t \n\t\t\t\tmemcpy(req->nat_ip_address,\n\t\t\t\t       actions->nat.l3.ipv6.saddr.s6_addr32,\n\t\t\t\t       sizeof(req->nat_ip_address));\n\t\t\t\t \n\t\t\t\tif (actions->nat.l4.ports.sport)\n\t\t\t\t\treq->nat_port =\n\t\t\t\t\t\tactions->nat.l4.ports.sport;\n\t\t\t} else {\n\t\t\t\taction_flags |=\n\t\t\t\t\tCFA_FLOW_ALLOC_REQ_ACTION_FLAGS_NAT_DEST;\n\t\t\t\t \n\t\t\t\tmemcpy(req->nat_ip_address,\n\t\t\t\t       actions->nat.l3.ipv6.daddr.s6_addr32,\n\t\t\t\t       sizeof(req->nat_ip_address));\n\t\t\t\t \n\t\t\t\tif (actions->nat.l4.ports.dport)\n\t\t\t\t\treq->nat_port =\n\t\t\t\t\t\tactions->nat.l4.ports.dport;\n\t\t\t}\n\t\t\tnetdev_dbg(bp->dev,\n\t\t\t\t   \"req->nat_ip_address: %pI6 src_xlate: %d req->nat_port: %x\\n\",\n\t\t\t\t   req->nat_ip_address, actions->nat.src_xlate,\n\t\t\t\t   req->nat_port);\n\t\t}\n\t}\n\n\tif (actions->flags & BNXT_TC_ACTION_FLAG_TUNNEL_DECAP ||\n\t    actions->flags & BNXT_TC_ACTION_FLAG_TUNNEL_ENCAP) {\n\t\treq->tunnel_handle = tunnel_handle;\n\t\tflow_flags |= CFA_FLOW_ALLOC_REQ_FLAGS_TUNNEL;\n\t\taction_flags |= CFA_FLOW_ALLOC_REQ_ACTION_FLAGS_TUNNEL;\n\t}\n\n\treq->ethertype = flow->l2_key.ether_type;\n\treq->ip_proto = flow->l4_key.ip_proto;\n\n\tif (flow->flags & BNXT_TC_FLOW_FLAGS_ETH_ADDRS) {\n\t\tmemcpy(req->dmac, flow->l2_key.dmac, ETH_ALEN);\n\t\tmemcpy(req->smac, flow->l2_key.smac, ETH_ALEN);\n\t}\n\n\tif (flow->l2_key.num_vlans > 0) {\n\t\tflow_flags |= CFA_FLOW_ALLOC_REQ_FLAGS_NUM_VLAN_ONE;\n\t\t \n\t\treq->outer_vlan_tci = flow->l2_key.inner_vlan_tci;\n\t}\n\n\t \n\tif (is_wildcard(l3_mask, sizeof(*l3_mask)) &&\n\t    is_wildcard(&flow->l4_mask, sizeof(flow->l4_mask))) {\n\t\tflow_flags |= CFA_FLOW_ALLOC_REQ_FLAGS_FLOWTYPE_L2;\n\t} else {\n\t\tflow_flags |= flow->l2_key.ether_type == htons(ETH_P_IP) ?\n\t\t\t\tCFA_FLOW_ALLOC_REQ_FLAGS_FLOWTYPE_IPV4 :\n\t\t\t\tCFA_FLOW_ALLOC_REQ_FLAGS_FLOWTYPE_IPV6;\n\n\t\tif (flow->flags & BNXT_TC_FLOW_FLAGS_IPV4_ADDRS) {\n\t\t\treq->ip_dst[0] = l3_key->ipv4.daddr.s_addr;\n\t\t\treq->ip_dst_mask_len =\n\t\t\t\tinet_mask_len(l3_mask->ipv4.daddr.s_addr);\n\t\t\treq->ip_src[0] = l3_key->ipv4.saddr.s_addr;\n\t\t\treq->ip_src_mask_len =\n\t\t\t\tinet_mask_len(l3_mask->ipv4.saddr.s_addr);\n\t\t} else if (flow->flags & BNXT_TC_FLOW_FLAGS_IPV6_ADDRS) {\n\t\t\tmemcpy(req->ip_dst, l3_key->ipv6.daddr.s6_addr32,\n\t\t\t       sizeof(req->ip_dst));\n\t\t\treq->ip_dst_mask_len =\n\t\t\t\t\tipv6_mask_len(&l3_mask->ipv6.daddr);\n\t\t\tmemcpy(req->ip_src, l3_key->ipv6.saddr.s6_addr32,\n\t\t\t       sizeof(req->ip_src));\n\t\t\treq->ip_src_mask_len =\n\t\t\t\t\tipv6_mask_len(&l3_mask->ipv6.saddr);\n\t\t}\n\t}\n\n\tif (flow->flags & BNXT_TC_FLOW_FLAGS_PORTS) {\n\t\treq->l4_src_port = flow->l4_key.ports.sport;\n\t\treq->l4_src_port_mask = flow->l4_mask.ports.sport;\n\t\treq->l4_dst_port = flow->l4_key.ports.dport;\n\t\treq->l4_dst_port_mask = flow->l4_mask.ports.dport;\n\t} else if (flow->flags & BNXT_TC_FLOW_FLAGS_ICMP) {\n\t\t \n\t\treq->l4_src_port = htons(flow->l4_key.icmp.type);\n\t\treq->l4_src_port_mask = htons(flow->l4_mask.icmp.type);\n\t\treq->l4_dst_port = htons(flow->l4_key.icmp.code);\n\t\treq->l4_dst_port_mask = htons(flow->l4_mask.icmp.code);\n\t}\n\treq->flags = cpu_to_le16(flow_flags);\n\n\tif (actions->flags & BNXT_TC_ACTION_FLAG_DROP) {\n\t\taction_flags |= CFA_FLOW_ALLOC_REQ_ACTION_FLAGS_DROP;\n\t} else {\n\t\tif (actions->flags & BNXT_TC_ACTION_FLAG_FWD) {\n\t\t\taction_flags |= CFA_FLOW_ALLOC_REQ_ACTION_FLAGS_FWD;\n\t\t\treq->dst_fid = cpu_to_le16(actions->dst_fid);\n\t\t}\n\t\tif (actions->flags & BNXT_TC_ACTION_FLAG_PUSH_VLAN) {\n\t\t\taction_flags |=\n\t\t\t    CFA_FLOW_ALLOC_REQ_ACTION_FLAGS_L2_HEADER_REWRITE;\n\t\t\treq->l2_rewrite_vlan_tpid = actions->push_vlan_tpid;\n\t\t\treq->l2_rewrite_vlan_tci = actions->push_vlan_tci;\n\t\t\tmemcpy(&req->l2_rewrite_dmac, &req->dmac, ETH_ALEN);\n\t\t\tmemcpy(&req->l2_rewrite_smac, &req->smac, ETH_ALEN);\n\t\t}\n\t\tif (actions->flags & BNXT_TC_ACTION_FLAG_POP_VLAN) {\n\t\t\taction_flags |=\n\t\t\t    CFA_FLOW_ALLOC_REQ_ACTION_FLAGS_L2_HEADER_REWRITE;\n\t\t\t \n\t\t\treq->l2_rewrite_vlan_tpid = 0;\n\t\t\tmemcpy(&req->l2_rewrite_dmac, &req->dmac, ETH_ALEN);\n\t\t\tmemcpy(&req->l2_rewrite_smac, &req->smac, ETH_ALEN);\n\t\t}\n\t}\n\treq->action_flags = cpu_to_le16(action_flags);\n\n\tresp = hwrm_req_hold(bp, req);\n\trc = hwrm_req_send_silent(bp, req);\n\tif (!rc) {\n\t\t \n\t\tflow_node->flow_handle = resp->flow_handle;\n\t\tif (bp->fw_cap & BNXT_FW_CAP_OVS_64BIT_HANDLE) {\n\t\t\tflow_node->ext_flow_handle = resp->ext_flow_handle;\n\t\t\tflow_node->flow_id = resp->flow_id;\n\t\t}\n\t}\n\thwrm_req_drop(bp, req);\n\treturn rc;\n}\n\nstatic int hwrm_cfa_decap_filter_alloc(struct bnxt *bp,\n\t\t\t\t       struct bnxt_tc_flow *flow,\n\t\t\t\t       struct bnxt_tc_l2_key *l2_info,\n\t\t\t\t       __le32 ref_decap_handle,\n\t\t\t\t       __le32 *decap_filter_handle)\n{\n\tstruct hwrm_cfa_decap_filter_alloc_output *resp;\n\tstruct ip_tunnel_key *tun_key = &flow->tun_key;\n\tstruct hwrm_cfa_decap_filter_alloc_input *req;\n\tu32 enables = 0;\n\tint rc;\n\n\trc = hwrm_req_init(bp, req, HWRM_CFA_DECAP_FILTER_ALLOC);\n\tif (rc)\n\t\tgoto exit;\n\n\treq->flags = cpu_to_le32(CFA_DECAP_FILTER_ALLOC_REQ_FLAGS_OVS_TUNNEL);\n\tenables |= CFA_DECAP_FILTER_ALLOC_REQ_ENABLES_TUNNEL_TYPE |\n\t\t   CFA_DECAP_FILTER_ALLOC_REQ_ENABLES_IP_PROTOCOL;\n\treq->tunnel_type = CFA_DECAP_FILTER_ALLOC_REQ_TUNNEL_TYPE_VXLAN;\n\treq->ip_protocol = CFA_DECAP_FILTER_ALLOC_REQ_IP_PROTOCOL_UDP;\n\n\tif (flow->flags & BNXT_TC_FLOW_FLAGS_TUNL_ID) {\n\t\tenables |= CFA_DECAP_FILTER_ALLOC_REQ_ENABLES_TUNNEL_ID;\n\t\t \n\t\treq->tunnel_id = tunnel_id_to_key32(tun_key->tun_id);\n\t}\n\n\tif (flow->flags & BNXT_TC_FLOW_FLAGS_TUNL_ETH_ADDRS) {\n\t\tenables |= CFA_DECAP_FILTER_ALLOC_REQ_ENABLES_DST_MACADDR;\n\t\tether_addr_copy(req->dst_macaddr, l2_info->dmac);\n\t}\n\tif (l2_info->num_vlans) {\n\t\tenables |= CFA_DECAP_FILTER_ALLOC_REQ_ENABLES_T_IVLAN_VID;\n\t\treq->t_ivlan_vid = l2_info->inner_vlan_tci;\n\t}\n\n\tenables |= CFA_DECAP_FILTER_ALLOC_REQ_ENABLES_ETHERTYPE;\n\treq->ethertype = htons(ETH_P_IP);\n\n\tif (flow->flags & BNXT_TC_FLOW_FLAGS_TUNL_IPV4_ADDRS) {\n\t\tenables |= CFA_DECAP_FILTER_ALLOC_REQ_ENABLES_SRC_IPADDR |\n\t\t\t   CFA_DECAP_FILTER_ALLOC_REQ_ENABLES_DST_IPADDR |\n\t\t\t   CFA_DECAP_FILTER_ALLOC_REQ_ENABLES_IPADDR_TYPE;\n\t\treq->ip_addr_type =\n\t\t\tCFA_DECAP_FILTER_ALLOC_REQ_IP_ADDR_TYPE_IPV4;\n\t\treq->dst_ipaddr[0] = tun_key->u.ipv4.dst;\n\t\treq->src_ipaddr[0] = tun_key->u.ipv4.src;\n\t}\n\n\tif (flow->flags & BNXT_TC_FLOW_FLAGS_TUNL_PORTS) {\n\t\tenables |= CFA_DECAP_FILTER_ALLOC_REQ_ENABLES_DST_PORT;\n\t\treq->dst_port = tun_key->tp_dst;\n\t}\n\n\t \n\treq->l2_ctxt_ref_id = (__force __le16)ref_decap_handle;\n\treq->enables = cpu_to_le32(enables);\n\n\tresp = hwrm_req_hold(bp, req);\n\trc = hwrm_req_send_silent(bp, req);\n\tif (!rc)\n\t\t*decap_filter_handle = resp->decap_filter_id;\n\thwrm_req_drop(bp, req);\nexit:\n\tif (rc)\n\t\tnetdev_info(bp->dev, \"%s: Error rc=%d\\n\", __func__, rc);\n\n\treturn rc;\n}\n\nstatic int hwrm_cfa_decap_filter_free(struct bnxt *bp,\n\t\t\t\t      __le32 decap_filter_handle)\n{\n\tstruct hwrm_cfa_decap_filter_free_input *req;\n\tint rc;\n\n\trc = hwrm_req_init(bp, req, HWRM_CFA_DECAP_FILTER_FREE);\n\tif (!rc) {\n\t\treq->decap_filter_id = decap_filter_handle;\n\t\trc = hwrm_req_send(bp, req);\n\t}\n\tif (rc)\n\t\tnetdev_info(bp->dev, \"%s: Error rc=%d\\n\", __func__, rc);\n\n\treturn rc;\n}\n\nstatic int hwrm_cfa_encap_record_alloc(struct bnxt *bp,\n\t\t\t\t       struct ip_tunnel_key *encap_key,\n\t\t\t\t       struct bnxt_tc_l2_key *l2_info,\n\t\t\t\t       __le32 *encap_record_handle)\n{\n\tstruct hwrm_cfa_encap_record_alloc_output *resp;\n\tstruct hwrm_cfa_encap_record_alloc_input *req;\n\tstruct hwrm_cfa_encap_data_vxlan *encap;\n\tstruct hwrm_vxlan_ipv4_hdr *encap_ipv4;\n\tint rc;\n\n\trc = hwrm_req_init(bp, req, HWRM_CFA_ENCAP_RECORD_ALLOC);\n\tif (rc)\n\t\tgoto exit;\n\n\tencap = (struct hwrm_cfa_encap_data_vxlan *)&req->encap_data;\n\treq->encap_type = CFA_ENCAP_RECORD_ALLOC_REQ_ENCAP_TYPE_VXLAN;\n\tether_addr_copy(encap->dst_mac_addr, l2_info->dmac);\n\tether_addr_copy(encap->src_mac_addr, l2_info->smac);\n\tif (l2_info->num_vlans) {\n\t\tencap->num_vlan_tags = l2_info->num_vlans;\n\t\tencap->ovlan_tci = l2_info->inner_vlan_tci;\n\t\tencap->ovlan_tpid = l2_info->inner_vlan_tpid;\n\t}\n\n\tencap_ipv4 = (struct hwrm_vxlan_ipv4_hdr *)encap->l3;\n\tencap_ipv4->ver_hlen = 4 << VXLAN_IPV4_HDR_VER_HLEN_VERSION_SFT;\n\tencap_ipv4->ver_hlen |= 5 << VXLAN_IPV4_HDR_VER_HLEN_HEADER_LENGTH_SFT;\n\tencap_ipv4->ttl = encap_key->ttl;\n\n\tencap_ipv4->dest_ip_addr = encap_key->u.ipv4.dst;\n\tencap_ipv4->src_ip_addr = encap_key->u.ipv4.src;\n\tencap_ipv4->protocol = IPPROTO_UDP;\n\n\tencap->dst_port = encap_key->tp_dst;\n\tencap->vni = tunnel_id_to_key32(encap_key->tun_id);\n\n\tresp = hwrm_req_hold(bp, req);\n\trc = hwrm_req_send_silent(bp, req);\n\tif (!rc)\n\t\t*encap_record_handle = resp->encap_record_id;\n\thwrm_req_drop(bp, req);\nexit:\n\tif (rc)\n\t\tnetdev_info(bp->dev, \"%s: Error rc=%d\\n\", __func__, rc);\n\n\treturn rc;\n}\n\nstatic int hwrm_cfa_encap_record_free(struct bnxt *bp,\n\t\t\t\t      __le32 encap_record_handle)\n{\n\tstruct hwrm_cfa_encap_record_free_input *req;\n\tint rc;\n\n\trc = hwrm_req_init(bp, req, HWRM_CFA_ENCAP_RECORD_FREE);\n\tif (!rc) {\n\t\treq->encap_record_id = encap_record_handle;\n\t\trc = hwrm_req_send(bp, req);\n\t}\n\tif (rc)\n\t\tnetdev_info(bp->dev, \"%s: Error rc=%d\\n\", __func__, rc);\n\n\treturn rc;\n}\n\nstatic int bnxt_tc_put_l2_node(struct bnxt *bp,\n\t\t\t       struct bnxt_tc_flow_node *flow_node)\n{\n\tstruct bnxt_tc_l2_node *l2_node = flow_node->l2_node;\n\tstruct bnxt_tc_info *tc_info = bp->tc_info;\n\tint rc;\n\n\t \n\tlist_del(&flow_node->l2_list_node);\n\tif (--l2_node->refcount == 0) {\n\t\trc =  rhashtable_remove_fast(&tc_info->l2_table, &l2_node->node,\n\t\t\t\t\t     tc_info->l2_ht_params);\n\t\tif (rc)\n\t\t\tnetdev_err(bp->dev,\n\t\t\t\t   \"Error: %s: rhashtable_remove_fast: %d\\n\",\n\t\t\t\t   __func__, rc);\n\t\tkfree_rcu(l2_node, rcu);\n\t}\n\treturn 0;\n}\n\nstatic struct bnxt_tc_l2_node *\nbnxt_tc_get_l2_node(struct bnxt *bp, struct rhashtable *l2_table,\n\t\t    struct rhashtable_params ht_params,\n\t\t    struct bnxt_tc_l2_key *l2_key)\n{\n\tstruct bnxt_tc_l2_node *l2_node;\n\tint rc;\n\n\tl2_node = rhashtable_lookup_fast(l2_table, l2_key, ht_params);\n\tif (!l2_node) {\n\t\tl2_node = kzalloc(sizeof(*l2_node), GFP_KERNEL);\n\t\tif (!l2_node) {\n\t\t\trc = -ENOMEM;\n\t\t\treturn NULL;\n\t\t}\n\n\t\tl2_node->key = *l2_key;\n\t\trc = rhashtable_insert_fast(l2_table, &l2_node->node,\n\t\t\t\t\t    ht_params);\n\t\tif (rc) {\n\t\t\tkfree_rcu(l2_node, rcu);\n\t\t\tnetdev_err(bp->dev,\n\t\t\t\t   \"Error: %s: rhashtable_insert_fast: %d\\n\",\n\t\t\t\t   __func__, rc);\n\t\t\treturn NULL;\n\t\t}\n\t\tINIT_LIST_HEAD(&l2_node->common_l2_flows);\n\t}\n\treturn l2_node;\n}\n\n \nstatic int\nbnxt_tc_get_ref_flow_handle(struct bnxt *bp, struct bnxt_tc_flow *flow,\n\t\t\t    struct bnxt_tc_flow_node *flow_node,\n\t\t\t    __le16 *ref_flow_handle)\n{\n\tstruct bnxt_tc_info *tc_info = bp->tc_info;\n\tstruct bnxt_tc_flow_node *ref_flow_node;\n\tstruct bnxt_tc_l2_node *l2_node;\n\n\tl2_node = bnxt_tc_get_l2_node(bp, &tc_info->l2_table,\n\t\t\t\t      tc_info->l2_ht_params,\n\t\t\t\t      &flow->l2_key);\n\tif (!l2_node)\n\t\treturn -1;\n\n\t \n\tif (l2_node->refcount > 0) {\n\t\tref_flow_node = list_first_entry(&l2_node->common_l2_flows,\n\t\t\t\t\t\t struct bnxt_tc_flow_node,\n\t\t\t\t\t\t l2_list_node);\n\t\t*ref_flow_handle = ref_flow_node->flow_handle;\n\t} else {\n\t\t*ref_flow_handle = cpu_to_le16(0xffff);\n\t}\n\n\t \n\tflow_node->l2_node = l2_node;\n\tlist_add(&flow_node->l2_list_node, &l2_node->common_l2_flows);\n\tl2_node->refcount++;\n\treturn 0;\n}\n\n \nstatic bool bnxt_tc_can_offload(struct bnxt *bp, struct bnxt_tc_flow *flow)\n{\n\t \n\tif ((flow->flags & BNXT_TC_FLOW_FLAGS_PORTS) &&\n\t    (flow->l4_key.ip_proto != IPPROTO_TCP &&\n\t     flow->l4_key.ip_proto != IPPROTO_UDP)) {\n\t\tnetdev_info(bp->dev, \"Cannot offload non-TCP/UDP (%d) ports\\n\",\n\t\t\t    flow->l4_key.ip_proto);\n\t\treturn false;\n\t}\n\n\t \n\tif (bits_set(&flow->l2_key.smac, sizeof(flow->l2_key.smac)) &&\n\t    !is_exactmatch(flow->l2_mask.smac, sizeof(flow->l2_mask.smac))) {\n\t\tnetdev_info(bp->dev, \"Wildcard match unsupported for Source MAC\\n\");\n\t\treturn false;\n\t}\n\tif (bits_set(&flow->l2_key.dmac, sizeof(flow->l2_key.dmac)) &&\n\t    !is_exactmatch(&flow->l2_mask.dmac, sizeof(flow->l2_mask.dmac))) {\n\t\tnetdev_info(bp->dev, \"Wildcard match unsupported for Dest MAC\\n\");\n\t\treturn false;\n\t}\n\n\t \n\tif (bits_set(&flow->l2_key.inner_vlan_tci,\n\t\t     sizeof(flow->l2_key.inner_vlan_tci)) &&\n\t    !is_vlan_tci_allowed(flow->l2_mask.inner_vlan_tci,\n\t\t\t\t flow->l2_key.inner_vlan_tci)) {\n\t\tnetdev_info(bp->dev, \"Unsupported VLAN TCI\\n\");\n\t\treturn false;\n\t}\n\tif (bits_set(&flow->l2_key.inner_vlan_tpid,\n\t\t     sizeof(flow->l2_key.inner_vlan_tpid)) &&\n\t    !is_exactmatch(&flow->l2_mask.inner_vlan_tpid,\n\t\t\t   sizeof(flow->l2_mask.inner_vlan_tpid))) {\n\t\tnetdev_info(bp->dev, \"Wildcard match unsupported for VLAN TPID\\n\");\n\t\treturn false;\n\t}\n\n\t \n\tif (!is_exactmatch(&flow->l2_mask.ether_type,\n\t\t\t   sizeof(flow->l2_mask.ether_type))) {\n\t\tnetdev_info(bp->dev, \"Wildcard match unsupported for Ethertype\\n\");\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n \nstatic int bnxt_tc_put_tunnel_node(struct bnxt *bp,\n\t\t\t\t   struct rhashtable *tunnel_table,\n\t\t\t\t   struct rhashtable_params *ht_params,\n\t\t\t\t   struct bnxt_tc_tunnel_node *tunnel_node)\n{\n\tint rc;\n\n\tif (--tunnel_node->refcount == 0) {\n\t\trc =  rhashtable_remove_fast(tunnel_table, &tunnel_node->node,\n\t\t\t\t\t     *ht_params);\n\t\tif (rc) {\n\t\t\tnetdev_err(bp->dev, \"rhashtable_remove_fast rc=%d\\n\", rc);\n\t\t\trc = -1;\n\t\t}\n\t\tkfree_rcu(tunnel_node, rcu);\n\t\treturn rc;\n\t} else {\n\t\treturn tunnel_node->refcount;\n\t}\n}\n\n \nstatic struct bnxt_tc_tunnel_node *\nbnxt_tc_get_tunnel_node(struct bnxt *bp, struct rhashtable *tunnel_table,\n\t\t\tstruct rhashtable_params *ht_params,\n\t\t\tstruct ip_tunnel_key *tun_key)\n{\n\tstruct bnxt_tc_tunnel_node *tunnel_node;\n\tint rc;\n\n\ttunnel_node = rhashtable_lookup_fast(tunnel_table, tun_key, *ht_params);\n\tif (!tunnel_node) {\n\t\ttunnel_node = kzalloc(sizeof(*tunnel_node), GFP_KERNEL);\n\t\tif (!tunnel_node) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\n\t\ttunnel_node->key = *tun_key;\n\t\ttunnel_node->tunnel_handle = INVALID_TUNNEL_HANDLE;\n\t\trc = rhashtable_insert_fast(tunnel_table, &tunnel_node->node,\n\t\t\t\t\t    *ht_params);\n\t\tif (rc) {\n\t\t\tkfree_rcu(tunnel_node, rcu);\n\t\t\tgoto err;\n\t\t}\n\t}\n\ttunnel_node->refcount++;\n\treturn tunnel_node;\nerr:\n\tnetdev_info(bp->dev, \"error rc=%d\\n\", rc);\n\treturn NULL;\n}\n\nstatic int bnxt_tc_get_ref_decap_handle(struct bnxt *bp,\n\t\t\t\t\tstruct bnxt_tc_flow *flow,\n\t\t\t\t\tstruct bnxt_tc_l2_key *l2_key,\n\t\t\t\t\tstruct bnxt_tc_flow_node *flow_node,\n\t\t\t\t\t__le32 *ref_decap_handle)\n{\n\tstruct bnxt_tc_info *tc_info = bp->tc_info;\n\tstruct bnxt_tc_flow_node *ref_flow_node;\n\tstruct bnxt_tc_l2_node *decap_l2_node;\n\n\tdecap_l2_node = bnxt_tc_get_l2_node(bp, &tc_info->decap_l2_table,\n\t\t\t\t\t    tc_info->decap_l2_ht_params,\n\t\t\t\t\t    l2_key);\n\tif (!decap_l2_node)\n\t\treturn -1;\n\n\t \n\tif (decap_l2_node->refcount > 0) {\n\t\tref_flow_node =\n\t\t\tlist_first_entry(&decap_l2_node->common_l2_flows,\n\t\t\t\t\t struct bnxt_tc_flow_node,\n\t\t\t\t\t decap_l2_list_node);\n\t\t*ref_decap_handle = ref_flow_node->decap_node->tunnel_handle;\n\t} else {\n\t\t*ref_decap_handle = INVALID_TUNNEL_HANDLE;\n\t}\n\n\t \n\tflow_node->decap_l2_node = decap_l2_node;\n\tlist_add(&flow_node->decap_l2_list_node,\n\t\t &decap_l2_node->common_l2_flows);\n\tdecap_l2_node->refcount++;\n\treturn 0;\n}\n\nstatic void bnxt_tc_put_decap_l2_node(struct bnxt *bp,\n\t\t\t\t      struct bnxt_tc_flow_node *flow_node)\n{\n\tstruct bnxt_tc_l2_node *decap_l2_node = flow_node->decap_l2_node;\n\tstruct bnxt_tc_info *tc_info = bp->tc_info;\n\tint rc;\n\n\t \n\tlist_del(&flow_node->decap_l2_list_node);\n\tif (--decap_l2_node->refcount == 0) {\n\t\trc =  rhashtable_remove_fast(&tc_info->decap_l2_table,\n\t\t\t\t\t     &decap_l2_node->node,\n\t\t\t\t\t     tc_info->decap_l2_ht_params);\n\t\tif (rc)\n\t\t\tnetdev_err(bp->dev, \"rhashtable_remove_fast rc=%d\\n\", rc);\n\t\tkfree_rcu(decap_l2_node, rcu);\n\t}\n}\n\nstatic void bnxt_tc_put_decap_handle(struct bnxt *bp,\n\t\t\t\t     struct bnxt_tc_flow_node *flow_node)\n{\n\t__le32 decap_handle = flow_node->decap_node->tunnel_handle;\n\tstruct bnxt_tc_info *tc_info = bp->tc_info;\n\tint rc;\n\n\tif (flow_node->decap_l2_node)\n\t\tbnxt_tc_put_decap_l2_node(bp, flow_node);\n\n\trc = bnxt_tc_put_tunnel_node(bp, &tc_info->decap_table,\n\t\t\t\t     &tc_info->decap_ht_params,\n\t\t\t\t     flow_node->decap_node);\n\tif (!rc && decap_handle != INVALID_TUNNEL_HANDLE)\n\t\thwrm_cfa_decap_filter_free(bp, decap_handle);\n}\n\nstatic int bnxt_tc_resolve_tunnel_hdrs(struct bnxt *bp,\n\t\t\t\t       struct ip_tunnel_key *tun_key,\n\t\t\t\t       struct bnxt_tc_l2_key *l2_info)\n{\n#ifdef CONFIG_INET\n\tstruct net_device *real_dst_dev = bp->dev;\n\tstruct flowi4 flow = { {0} };\n\tstruct net_device *dst_dev;\n\tstruct neighbour *nbr;\n\tstruct rtable *rt;\n\tint rc;\n\n\tflow.flowi4_proto = IPPROTO_UDP;\n\tflow.fl4_dport = tun_key->tp_dst;\n\tflow.daddr = tun_key->u.ipv4.dst;\n\n\trt = ip_route_output_key(dev_net(real_dst_dev), &flow);\n\tif (IS_ERR(rt)) {\n\t\tnetdev_info(bp->dev, \"no route to %pI4b\\n\", &flow.daddr);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t \n\tdst_dev = rt->dst.dev;\n\tif (is_vlan_dev(dst_dev)) {\n#if IS_ENABLED(CONFIG_VLAN_8021Q)\n\t\tstruct vlan_dev_priv *vlan = vlan_dev_priv(dst_dev);\n\n\t\tif (vlan->real_dev != real_dst_dev) {\n\t\t\tnetdev_info(bp->dev,\n\t\t\t\t    \"dst_dev(%s) doesn't use PF-if(%s)\\n\",\n\t\t\t\t    netdev_name(dst_dev),\n\t\t\t\t    netdev_name(real_dst_dev));\n\t\t\trc = -EOPNOTSUPP;\n\t\t\tgoto put_rt;\n\t\t}\n\t\tl2_info->inner_vlan_tci = htons(vlan->vlan_id);\n\t\tl2_info->inner_vlan_tpid = vlan->vlan_proto;\n\t\tl2_info->num_vlans = 1;\n#endif\n\t} else if (dst_dev != real_dst_dev) {\n\t\tnetdev_info(bp->dev,\n\t\t\t    \"dst_dev(%s) for %pI4b is not PF-if(%s)\\n\",\n\t\t\t    netdev_name(dst_dev), &flow.daddr,\n\t\t\t    netdev_name(real_dst_dev));\n\t\trc = -EOPNOTSUPP;\n\t\tgoto put_rt;\n\t}\n\n\tnbr = dst_neigh_lookup(&rt->dst, &flow.daddr);\n\tif (!nbr) {\n\t\tnetdev_info(bp->dev, \"can't lookup neighbor for %pI4b\\n\",\n\t\t\t    &flow.daddr);\n\t\trc = -EOPNOTSUPP;\n\t\tgoto put_rt;\n\t}\n\n\ttun_key->u.ipv4.src = flow.saddr;\n\ttun_key->ttl = ip4_dst_hoplimit(&rt->dst);\n\tneigh_ha_snapshot(l2_info->dmac, nbr, dst_dev);\n\tether_addr_copy(l2_info->smac, dst_dev->dev_addr);\n\tneigh_release(nbr);\n\tip_rt_put(rt);\n\n\treturn 0;\nput_rt:\n\tip_rt_put(rt);\n\treturn rc;\n#else\n\treturn -EOPNOTSUPP;\n#endif\n}\n\nstatic int bnxt_tc_get_decap_handle(struct bnxt *bp, struct bnxt_tc_flow *flow,\n\t\t\t\t    struct bnxt_tc_flow_node *flow_node,\n\t\t\t\t    __le32 *decap_filter_handle)\n{\n\tstruct ip_tunnel_key *decap_key = &flow->tun_key;\n\tstruct bnxt_tc_info *tc_info = bp->tc_info;\n\tstruct bnxt_tc_l2_key l2_info = { {0} };\n\tstruct bnxt_tc_tunnel_node *decap_node;\n\tstruct ip_tunnel_key tun_key = { 0 };\n\tstruct bnxt_tc_l2_key *decap_l2_info;\n\t__le32 ref_decap_handle;\n\tint rc;\n\n\t \n\tdecap_key->tp_src = 0;\n\tdecap_node = bnxt_tc_get_tunnel_node(bp, &tc_info->decap_table,\n\t\t\t\t\t     &tc_info->decap_ht_params,\n\t\t\t\t\t     decap_key);\n\tif (!decap_node)\n\t\treturn -ENOMEM;\n\n\tflow_node->decap_node = decap_node;\n\n\tif (decap_node->tunnel_handle != INVALID_TUNNEL_HANDLE)\n\t\tgoto done;\n\n\t \n\ttun_key.u.ipv4.dst = flow->tun_key.u.ipv4.src;\n\ttun_key.tp_dst = flow->tun_key.tp_dst;\n\trc = bnxt_tc_resolve_tunnel_hdrs(bp, &tun_key, &l2_info);\n\tif (rc)\n\t\tgoto put_decap;\n\n\tdecap_l2_info = &decap_node->l2_info;\n\t \n\tether_addr_copy(decap_l2_info->dmac, l2_info.smac);\n\tif (l2_info.num_vlans) {\n\t\tdecap_l2_info->num_vlans = l2_info.num_vlans;\n\t\tdecap_l2_info->inner_vlan_tpid = l2_info.inner_vlan_tpid;\n\t\tdecap_l2_info->inner_vlan_tci = l2_info.inner_vlan_tci;\n\t}\n\tflow->flags |= BNXT_TC_FLOW_FLAGS_TUNL_ETH_ADDRS;\n\n\t \n\trc = bnxt_tc_get_ref_decap_handle(bp, flow, decap_l2_info, flow_node,\n\t\t\t\t\t  &ref_decap_handle);\n\tif (rc)\n\t\tgoto put_decap;\n\n\t \n\trc = hwrm_cfa_decap_filter_alloc(bp, flow, decap_l2_info,\n\t\t\t\t\t ref_decap_handle,\n\t\t\t\t\t &decap_node->tunnel_handle);\n\tif (rc)\n\t\tgoto put_decap_l2;\n\ndone:\n\t*decap_filter_handle = decap_node->tunnel_handle;\n\treturn 0;\n\nput_decap_l2:\n\tbnxt_tc_put_decap_l2_node(bp, flow_node);\nput_decap:\n\tbnxt_tc_put_tunnel_node(bp, &tc_info->decap_table,\n\t\t\t\t&tc_info->decap_ht_params,\n\t\t\t\tflow_node->decap_node);\n\treturn rc;\n}\n\nstatic void bnxt_tc_put_encap_handle(struct bnxt *bp,\n\t\t\t\t     struct bnxt_tc_tunnel_node *encap_node)\n{\n\t__le32 encap_handle = encap_node->tunnel_handle;\n\tstruct bnxt_tc_info *tc_info = bp->tc_info;\n\tint rc;\n\n\trc = bnxt_tc_put_tunnel_node(bp, &tc_info->encap_table,\n\t\t\t\t     &tc_info->encap_ht_params, encap_node);\n\tif (!rc && encap_handle != INVALID_TUNNEL_HANDLE)\n\t\thwrm_cfa_encap_record_free(bp, encap_handle);\n}\n\n \nstatic int bnxt_tc_get_encap_handle(struct bnxt *bp, struct bnxt_tc_flow *flow,\n\t\t\t\t    struct bnxt_tc_flow_node *flow_node,\n\t\t\t\t    __le32 *encap_handle)\n{\n\tstruct ip_tunnel_key *encap_key = &flow->actions.tun_encap_key;\n\tstruct bnxt_tc_info *tc_info = bp->tc_info;\n\tstruct bnxt_tc_tunnel_node *encap_node;\n\tint rc;\n\n\t \n\tencap_node = bnxt_tc_get_tunnel_node(bp, &tc_info->encap_table,\n\t\t\t\t\t     &tc_info->encap_ht_params,\n\t\t\t\t\t     encap_key);\n\tif (!encap_node)\n\t\treturn -ENOMEM;\n\n\tflow_node->encap_node = encap_node;\n\n\tif (encap_node->tunnel_handle != INVALID_TUNNEL_HANDLE)\n\t\tgoto done;\n\n\trc = bnxt_tc_resolve_tunnel_hdrs(bp, encap_key, &encap_node->l2_info);\n\tif (rc)\n\t\tgoto put_encap;\n\n\t \n\trc = hwrm_cfa_encap_record_alloc(bp, encap_key, &encap_node->l2_info,\n\t\t\t\t\t &encap_node->tunnel_handle);\n\tif (rc)\n\t\tgoto put_encap;\n\ndone:\n\t*encap_handle = encap_node->tunnel_handle;\n\treturn 0;\n\nput_encap:\n\tbnxt_tc_put_tunnel_node(bp, &tc_info->encap_table,\n\t\t\t\t&tc_info->encap_ht_params, encap_node);\n\treturn rc;\n}\n\nstatic void bnxt_tc_put_tunnel_handle(struct bnxt *bp,\n\t\t\t\t      struct bnxt_tc_flow *flow,\n\t\t\t\t      struct bnxt_tc_flow_node *flow_node)\n{\n\tif (flow->actions.flags & BNXT_TC_ACTION_FLAG_TUNNEL_DECAP)\n\t\tbnxt_tc_put_decap_handle(bp, flow_node);\n\telse if (flow->actions.flags & BNXT_TC_ACTION_FLAG_TUNNEL_ENCAP)\n\t\tbnxt_tc_put_encap_handle(bp, flow_node->encap_node);\n}\n\nstatic int bnxt_tc_get_tunnel_handle(struct bnxt *bp,\n\t\t\t\t     struct bnxt_tc_flow *flow,\n\t\t\t\t     struct bnxt_tc_flow_node *flow_node,\n\t\t\t\t     __le32 *tunnel_handle)\n{\n\tif (flow->actions.flags & BNXT_TC_ACTION_FLAG_TUNNEL_DECAP)\n\t\treturn bnxt_tc_get_decap_handle(bp, flow, flow_node,\n\t\t\t\t\t\ttunnel_handle);\n\telse if (flow->actions.flags & BNXT_TC_ACTION_FLAG_TUNNEL_ENCAP)\n\t\treturn bnxt_tc_get_encap_handle(bp, flow, flow_node,\n\t\t\t\t\t\ttunnel_handle);\n\telse\n\t\treturn 0;\n}\nstatic int __bnxt_tc_del_flow(struct bnxt *bp,\n\t\t\t      struct bnxt_tc_flow_node *flow_node)\n{\n\tstruct bnxt_tc_info *tc_info = bp->tc_info;\n\tint rc;\n\n\t \n\tbnxt_hwrm_cfa_flow_free(bp, flow_node);\n\n\tmutex_lock(&tc_info->lock);\n\n\t \n\tbnxt_tc_put_tunnel_handle(bp, &flow_node->flow, flow_node);\n\n\t \n\tbnxt_tc_put_l2_node(bp, flow_node);\n\n\tmutex_unlock(&tc_info->lock);\n\n\trc = rhashtable_remove_fast(&tc_info->flow_table, &flow_node->node,\n\t\t\t\t    tc_info->flow_ht_params);\n\tif (rc)\n\t\tnetdev_err(bp->dev, \"Error: %s: rhashtable_remove_fast rc=%d\\n\",\n\t\t\t   __func__, rc);\n\n\tkfree_rcu(flow_node, rcu);\n\treturn 0;\n}\n\nstatic void bnxt_tc_set_flow_dir(struct bnxt *bp, struct bnxt_tc_flow *flow,\n\t\t\t\t u16 src_fid)\n{\n\tflow->l2_key.dir = (bp->pf.fw_fid == src_fid) ? BNXT_DIR_RX : BNXT_DIR_TX;\n}\n\nstatic void bnxt_tc_set_src_fid(struct bnxt *bp, struct bnxt_tc_flow *flow,\n\t\t\t\tu16 src_fid)\n{\n\tif (flow->actions.flags & BNXT_TC_ACTION_FLAG_TUNNEL_DECAP)\n\t\tflow->src_fid = bp->pf.fw_fid;\n\telse\n\t\tflow->src_fid = src_fid;\n}\n\n \nstatic int bnxt_tc_add_flow(struct bnxt *bp, u16 src_fid,\n\t\t\t    struct flow_cls_offload *tc_flow_cmd)\n{\n\tstruct bnxt_tc_flow_node *new_node, *old_node;\n\tstruct bnxt_tc_info *tc_info = bp->tc_info;\n\tstruct bnxt_tc_flow *flow;\n\t__le32 tunnel_handle = 0;\n\t__le16 ref_flow_handle;\n\tint rc;\n\n\t \n\tnew_node = kzalloc(sizeof(*new_node), GFP_KERNEL);\n\tif (!new_node) {\n\t\trc = -ENOMEM;\n\t\tgoto done;\n\t}\n\tnew_node->cookie = tc_flow_cmd->cookie;\n\tflow = &new_node->flow;\n\n\trc = bnxt_tc_parse_flow(bp, tc_flow_cmd, flow);\n\tif (rc)\n\t\tgoto free_node;\n\n\tbnxt_tc_set_src_fid(bp, flow, src_fid);\n\tbnxt_tc_set_flow_dir(bp, flow, flow->src_fid);\n\n\tif (!bnxt_tc_can_offload(bp, flow)) {\n\t\trc = -EOPNOTSUPP;\n\t\tkfree_rcu(new_node, rcu);\n\t\treturn rc;\n\t}\n\n\t \n\told_node = rhashtable_lookup_fast(&tc_info->flow_table,\n\t\t\t\t\t  &tc_flow_cmd->cookie,\n\t\t\t\t\t  tc_info->flow_ht_params);\n\tif (old_node)\n\t\t__bnxt_tc_del_flow(bp, old_node);\n\n\t \n\tmutex_lock(&tc_info->lock);\n\trc = bnxt_tc_get_ref_flow_handle(bp, flow, new_node, &ref_flow_handle);\n\tif (rc)\n\t\tgoto unlock;\n\n\t \n\trc = bnxt_tc_get_tunnel_handle(bp, flow, new_node, &tunnel_handle);\n\tif (rc)\n\t\tgoto put_l2;\n\n\t \n\trc = bnxt_hwrm_cfa_flow_alloc(bp, flow, ref_flow_handle,\n\t\t\t\t      tunnel_handle, new_node);\n\tif (rc)\n\t\tgoto put_tunnel;\n\n\tflow->lastused = jiffies;\n\tspin_lock_init(&flow->stats_lock);\n\t \n\trc = rhashtable_insert_fast(&tc_info->flow_table, &new_node->node,\n\t\t\t\t    tc_info->flow_ht_params);\n\tif (rc)\n\t\tgoto hwrm_flow_free;\n\n\tmutex_unlock(&tc_info->lock);\n\treturn 0;\n\nhwrm_flow_free:\n\tbnxt_hwrm_cfa_flow_free(bp, new_node);\nput_tunnel:\n\tbnxt_tc_put_tunnel_handle(bp, flow, new_node);\nput_l2:\n\tbnxt_tc_put_l2_node(bp, new_node);\nunlock:\n\tmutex_unlock(&tc_info->lock);\nfree_node:\n\tkfree_rcu(new_node, rcu);\ndone:\n\tnetdev_err(bp->dev, \"Error: %s: cookie=0x%lx error=%d\\n\",\n\t\t   __func__, tc_flow_cmd->cookie, rc);\n\treturn rc;\n}\n\nstatic int bnxt_tc_del_flow(struct bnxt *bp,\n\t\t\t    struct flow_cls_offload *tc_flow_cmd)\n{\n\tstruct bnxt_tc_info *tc_info = bp->tc_info;\n\tstruct bnxt_tc_flow_node *flow_node;\n\n\tflow_node = rhashtable_lookup_fast(&tc_info->flow_table,\n\t\t\t\t\t   &tc_flow_cmd->cookie,\n\t\t\t\t\t   tc_info->flow_ht_params);\n\tif (!flow_node)\n\t\treturn -EINVAL;\n\n\treturn __bnxt_tc_del_flow(bp, flow_node);\n}\n\nstatic int bnxt_tc_get_flow_stats(struct bnxt *bp,\n\t\t\t\t  struct flow_cls_offload *tc_flow_cmd)\n{\n\tstruct bnxt_tc_flow_stats stats, *curr_stats, *prev_stats;\n\tstruct bnxt_tc_info *tc_info = bp->tc_info;\n\tstruct bnxt_tc_flow_node *flow_node;\n\tstruct bnxt_tc_flow *flow;\n\tunsigned long lastused;\n\n\tflow_node = rhashtable_lookup_fast(&tc_info->flow_table,\n\t\t\t\t\t   &tc_flow_cmd->cookie,\n\t\t\t\t\t   tc_info->flow_ht_params);\n\tif (!flow_node)\n\t\treturn -1;\n\n\tflow = &flow_node->flow;\n\tcurr_stats = &flow->stats;\n\tprev_stats = &flow->prev_stats;\n\n\tspin_lock(&flow->stats_lock);\n\tstats.packets = curr_stats->packets - prev_stats->packets;\n\tstats.bytes = curr_stats->bytes - prev_stats->bytes;\n\t*prev_stats = *curr_stats;\n\tlastused = flow->lastused;\n\tspin_unlock(&flow->stats_lock);\n\n\tflow_stats_update(&tc_flow_cmd->stats, stats.bytes, stats.packets, 0,\n\t\t\t  lastused, FLOW_ACTION_HW_STATS_DELAYED);\n\treturn 0;\n}\n\nstatic void bnxt_fill_cfa_stats_req(struct bnxt *bp,\n\t\t\t\t    struct bnxt_tc_flow_node *flow_node,\n\t\t\t\t    __le16 *flow_handle, __le32 *flow_id)\n{\n\tu16 handle;\n\n\tif (bp->fw_cap & BNXT_FW_CAP_OVS_64BIT_HANDLE) {\n\t\t*flow_id = flow_node->flow_id;\n\n\t\t \n\t\tif (flow_node->flow.l2_key.dir == BNXT_DIR_RX)\n\t\t\thandle = CFA_FLOW_INFO_REQ_FLOW_HANDLE_DIR_RX |\n\t\t\t\t CFA_FLOW_INFO_REQ_FLOW_HANDLE_MAX_MASK;\n\t\telse\n\t\t\thandle = CFA_FLOW_INFO_REQ_FLOW_HANDLE_MAX_MASK;\n\n\t\t*flow_handle = cpu_to_le16(handle);\n\t} else {\n\t\t*flow_handle = flow_node->flow_handle;\n\t}\n}\n\nstatic int\nbnxt_hwrm_cfa_flow_stats_get(struct bnxt *bp, int num_flows,\n\t\t\t     struct bnxt_tc_stats_batch stats_batch[])\n{\n\tstruct hwrm_cfa_flow_stats_output *resp;\n\tstruct hwrm_cfa_flow_stats_input *req;\n\t__le16 *req_flow_handles;\n\t__le32 *req_flow_ids;\n\tint rc, i;\n\n\trc = hwrm_req_init(bp, req, HWRM_CFA_FLOW_STATS);\n\tif (rc)\n\t\tgoto exit;\n\n\treq_flow_handles = &req->flow_handle_0;\n\treq_flow_ids = &req->flow_id_0;\n\n\treq->num_flows = cpu_to_le16(num_flows);\n\tfor (i = 0; i < num_flows; i++) {\n\t\tstruct bnxt_tc_flow_node *flow_node = stats_batch[i].flow_node;\n\n\t\tbnxt_fill_cfa_stats_req(bp, flow_node,\n\t\t\t\t\t&req_flow_handles[i], &req_flow_ids[i]);\n\t}\n\n\tresp = hwrm_req_hold(bp, req);\n\trc = hwrm_req_send(bp, req);\n\tif (!rc) {\n\t\t__le64 *resp_packets;\n\t\t__le64 *resp_bytes;\n\n\t\tresp_packets = &resp->packet_0;\n\t\tresp_bytes = &resp->byte_0;\n\n\t\tfor (i = 0; i < num_flows; i++) {\n\t\t\tstats_batch[i].hw_stats.packets =\n\t\t\t\t\t\tle64_to_cpu(resp_packets[i]);\n\t\t\tstats_batch[i].hw_stats.bytes =\n\t\t\t\t\t\tle64_to_cpu(resp_bytes[i]);\n\t\t}\n\t}\n\thwrm_req_drop(bp, req);\nexit:\n\tif (rc)\n\t\tnetdev_info(bp->dev, \"error rc=%d\\n\", rc);\n\n\treturn rc;\n}\n\n \nstatic void accumulate_val(u64 *accum, u64 val, u64 mask)\n{\n#define low_bits(x, mask)\t\t((x) & (mask))\n#define high_bits(x, mask)\t\t((x) & ~(mask))\n\tbool wrapped = val < low_bits(*accum, mask);\n\n\t*accum = high_bits(*accum, mask) + val;\n\tif (wrapped)\n\t\t*accum += (mask + 1);\n}\n\n \nstatic void bnxt_flow_stats_accum(struct bnxt_tc_info *tc_info,\n\t\t\t\t  struct bnxt_tc_flow_stats *acc_stats,\n\t\t\t\t  struct bnxt_tc_flow_stats *hw_stats)\n{\n\taccumulate_val(&acc_stats->bytes, hw_stats->bytes, tc_info->bytes_mask);\n\taccumulate_val(&acc_stats->packets, hw_stats->packets,\n\t\t       tc_info->packets_mask);\n}\n\nstatic int\nbnxt_tc_flow_stats_batch_update(struct bnxt *bp, int num_flows,\n\t\t\t\tstruct bnxt_tc_stats_batch stats_batch[])\n{\n\tstruct bnxt_tc_info *tc_info = bp->tc_info;\n\tint rc, i;\n\n\trc = bnxt_hwrm_cfa_flow_stats_get(bp, num_flows, stats_batch);\n\tif (rc)\n\t\treturn rc;\n\n\tfor (i = 0; i < num_flows; i++) {\n\t\tstruct bnxt_tc_flow_node *flow_node = stats_batch[i].flow_node;\n\t\tstruct bnxt_tc_flow *flow = &flow_node->flow;\n\n\t\tspin_lock(&flow->stats_lock);\n\t\tbnxt_flow_stats_accum(tc_info, &flow->stats,\n\t\t\t\t      &stats_batch[i].hw_stats);\n\t\tif (flow->stats.packets != flow->prev_stats.packets)\n\t\t\tflow->lastused = jiffies;\n\t\tspin_unlock(&flow->stats_lock);\n\t}\n\n\treturn 0;\n}\n\nstatic int\nbnxt_tc_flow_stats_batch_prep(struct bnxt *bp,\n\t\t\t      struct bnxt_tc_stats_batch stats_batch[],\n\t\t\t      int *num_flows)\n{\n\tstruct bnxt_tc_info *tc_info = bp->tc_info;\n\tstruct rhashtable_iter *iter = &tc_info->iter;\n\tvoid *flow_node;\n\tint rc, i;\n\n\trhashtable_walk_start(iter);\n\n\trc = 0;\n\tfor (i = 0; i < BNXT_FLOW_STATS_BATCH_MAX; i++) {\n\t\tflow_node = rhashtable_walk_next(iter);\n\t\tif (IS_ERR(flow_node)) {\n\t\t\ti = 0;\n\t\t\tif (PTR_ERR(flow_node) == -EAGAIN) {\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\trc = PTR_ERR(flow_node);\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (!flow_node)\n\t\t\tgoto done;\n\n\t\tstats_batch[i].flow_node = flow_node;\n\t}\ndone:\n\trhashtable_walk_stop(iter);\n\t*num_flows = i;\n\treturn rc;\n}\n\nvoid bnxt_tc_flow_stats_work(struct bnxt *bp)\n{\n\tstruct bnxt_tc_info *tc_info = bp->tc_info;\n\tint num_flows, rc;\n\n\tnum_flows = atomic_read(&tc_info->flow_table.nelems);\n\tif (!num_flows)\n\t\treturn;\n\n\trhashtable_walk_enter(&tc_info->flow_table, &tc_info->iter);\n\n\tfor (;;) {\n\t\trc = bnxt_tc_flow_stats_batch_prep(bp, tc_info->stats_batch,\n\t\t\t\t\t\t   &num_flows);\n\t\tif (rc) {\n\t\t\tif (rc == -EAGAIN)\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!num_flows)\n\t\t\tbreak;\n\n\t\tbnxt_tc_flow_stats_batch_update(bp, num_flows,\n\t\t\t\t\t\ttc_info->stats_batch);\n\t}\n\n\trhashtable_walk_exit(&tc_info->iter);\n}\n\nint bnxt_tc_setup_flower(struct bnxt *bp, u16 src_fid,\n\t\t\t struct flow_cls_offload *cls_flower)\n{\n\tswitch (cls_flower->command) {\n\tcase FLOW_CLS_REPLACE:\n\t\treturn bnxt_tc_add_flow(bp, src_fid, cls_flower);\n\tcase FLOW_CLS_DESTROY:\n\t\treturn bnxt_tc_del_flow(bp, cls_flower);\n\tcase FLOW_CLS_STATS:\n\t\treturn bnxt_tc_get_flow_stats(bp, cls_flower);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int bnxt_tc_setup_indr_block_cb(enum tc_setup_type type,\n\t\t\t\t       void *type_data, void *cb_priv)\n{\n\tstruct bnxt_flower_indr_block_cb_priv *priv = cb_priv;\n\tstruct flow_cls_offload *flower = type_data;\n\tstruct bnxt *bp = priv->bp;\n\n\tif (!tc_cls_can_offload_and_chain0(bp->dev, type_data))\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (type) {\n\tcase TC_SETUP_CLSFLOWER:\n\t\treturn bnxt_tc_setup_flower(bp, bp->pf.fw_fid, flower);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic struct bnxt_flower_indr_block_cb_priv *\nbnxt_tc_indr_block_cb_lookup(struct bnxt *bp, struct net_device *netdev)\n{\n\tstruct bnxt_flower_indr_block_cb_priv *cb_priv;\n\n\tlist_for_each_entry(cb_priv, &bp->tc_indr_block_list, list)\n\t\tif (cb_priv->tunnel_netdev == netdev)\n\t\t\treturn cb_priv;\n\n\treturn NULL;\n}\n\nstatic void bnxt_tc_setup_indr_rel(void *cb_priv)\n{\n\tstruct bnxt_flower_indr_block_cb_priv *priv = cb_priv;\n\n\tlist_del(&priv->list);\n\tkfree(priv);\n}\n\nstatic int bnxt_tc_setup_indr_block(struct net_device *netdev, struct Qdisc *sch, struct bnxt *bp,\n\t\t\t\t    struct flow_block_offload *f, void *data,\n\t\t\t\t    void (*cleanup)(struct flow_block_cb *block_cb))\n{\n\tstruct bnxt_flower_indr_block_cb_priv *cb_priv;\n\tstruct flow_block_cb *block_cb;\n\n\tif (f->binder_type != FLOW_BLOCK_BINDER_TYPE_CLSACT_INGRESS)\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (f->command) {\n\tcase FLOW_BLOCK_BIND:\n\t\tcb_priv = kmalloc(sizeof(*cb_priv), GFP_KERNEL);\n\t\tif (!cb_priv)\n\t\t\treturn -ENOMEM;\n\n\t\tcb_priv->tunnel_netdev = netdev;\n\t\tcb_priv->bp = bp;\n\t\tlist_add(&cb_priv->list, &bp->tc_indr_block_list);\n\n\t\tblock_cb = flow_indr_block_cb_alloc(bnxt_tc_setup_indr_block_cb,\n\t\t\t\t\t\t    cb_priv, cb_priv,\n\t\t\t\t\t\t    bnxt_tc_setup_indr_rel, f,\n\t\t\t\t\t\t    netdev, sch, data, bp, cleanup);\n\t\tif (IS_ERR(block_cb)) {\n\t\t\tlist_del(&cb_priv->list);\n\t\t\tkfree(cb_priv);\n\t\t\treturn PTR_ERR(block_cb);\n\t\t}\n\n\t\tflow_block_cb_add(block_cb, f);\n\t\tlist_add_tail(&block_cb->driver_list, &bnxt_block_cb_list);\n\t\tbreak;\n\tcase FLOW_BLOCK_UNBIND:\n\t\tcb_priv = bnxt_tc_indr_block_cb_lookup(bp, netdev);\n\t\tif (!cb_priv)\n\t\t\treturn -ENOENT;\n\n\t\tblock_cb = flow_block_cb_lookup(f->block,\n\t\t\t\t\t\tbnxt_tc_setup_indr_block_cb,\n\t\t\t\t\t\tcb_priv);\n\t\tif (!block_cb)\n\t\t\treturn -ENOENT;\n\n\t\tflow_indr_block_cb_remove(block_cb, f);\n\t\tlist_del(&block_cb->driver_list);\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn 0;\n}\n\nstatic bool bnxt_is_netdev_indr_offload(struct net_device *netdev)\n{\n\treturn netif_is_vxlan(netdev);\n}\n\nstatic int bnxt_tc_setup_indr_cb(struct net_device *netdev, struct Qdisc *sch, void *cb_priv,\n\t\t\t\t enum tc_setup_type type, void *type_data,\n\t\t\t\t void *data,\n\t\t\t\t void (*cleanup)(struct flow_block_cb *block_cb))\n{\n\tif (!netdev || !bnxt_is_netdev_indr_offload(netdev))\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (type) {\n\tcase TC_SETUP_BLOCK:\n\t\treturn bnxt_tc_setup_indr_block(netdev, sch, cb_priv, type_data, data, cleanup);\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic const struct rhashtable_params bnxt_tc_flow_ht_params = {\n\t.head_offset = offsetof(struct bnxt_tc_flow_node, node),\n\t.key_offset = offsetof(struct bnxt_tc_flow_node, cookie),\n\t.key_len = sizeof(((struct bnxt_tc_flow_node *)0)->cookie),\n\t.automatic_shrinking = true\n};\n\nstatic const struct rhashtable_params bnxt_tc_l2_ht_params = {\n\t.head_offset = offsetof(struct bnxt_tc_l2_node, node),\n\t.key_offset = offsetof(struct bnxt_tc_l2_node, key),\n\t.key_len = BNXT_TC_L2_KEY_LEN,\n\t.automatic_shrinking = true\n};\n\nstatic const struct rhashtable_params bnxt_tc_decap_l2_ht_params = {\n\t.head_offset = offsetof(struct bnxt_tc_l2_node, node),\n\t.key_offset = offsetof(struct bnxt_tc_l2_node, key),\n\t.key_len = BNXT_TC_L2_KEY_LEN,\n\t.automatic_shrinking = true\n};\n\nstatic const struct rhashtable_params bnxt_tc_tunnel_ht_params = {\n\t.head_offset = offsetof(struct bnxt_tc_tunnel_node, node),\n\t.key_offset = offsetof(struct bnxt_tc_tunnel_node, key),\n\t.key_len = sizeof(struct ip_tunnel_key),\n\t.automatic_shrinking = true\n};\n\n \n#define mask(width)\t\t((u64)~0 >> (64 - (width)))\n\nint bnxt_init_tc(struct bnxt *bp)\n{\n\tstruct bnxt_tc_info *tc_info;\n\tint rc;\n\n\tif (bp->hwrm_spec_code < 0x10803)\n\t\treturn 0;\n\n\ttc_info = kzalloc(sizeof(*tc_info), GFP_KERNEL);\n\tif (!tc_info)\n\t\treturn -ENOMEM;\n\tmutex_init(&tc_info->lock);\n\n\t \n\ttc_info->bytes_mask = mask(36);\n\ttc_info->packets_mask = mask(28);\n\n\ttc_info->flow_ht_params = bnxt_tc_flow_ht_params;\n\trc = rhashtable_init(&tc_info->flow_table, &tc_info->flow_ht_params);\n\tif (rc)\n\t\tgoto free_tc_info;\n\n\ttc_info->l2_ht_params = bnxt_tc_l2_ht_params;\n\trc = rhashtable_init(&tc_info->l2_table, &tc_info->l2_ht_params);\n\tif (rc)\n\t\tgoto destroy_flow_table;\n\n\ttc_info->decap_l2_ht_params = bnxt_tc_decap_l2_ht_params;\n\trc = rhashtable_init(&tc_info->decap_l2_table,\n\t\t\t     &tc_info->decap_l2_ht_params);\n\tif (rc)\n\t\tgoto destroy_l2_table;\n\n\ttc_info->decap_ht_params = bnxt_tc_tunnel_ht_params;\n\trc = rhashtable_init(&tc_info->decap_table,\n\t\t\t     &tc_info->decap_ht_params);\n\tif (rc)\n\t\tgoto destroy_decap_l2_table;\n\n\ttc_info->encap_ht_params = bnxt_tc_tunnel_ht_params;\n\trc = rhashtable_init(&tc_info->encap_table,\n\t\t\t     &tc_info->encap_ht_params);\n\tif (rc)\n\t\tgoto destroy_decap_table;\n\n\ttc_info->enabled = true;\n\tbp->dev->hw_features |= NETIF_F_HW_TC;\n\tbp->dev->features |= NETIF_F_HW_TC;\n\tbp->tc_info = tc_info;\n\n\t \n\tINIT_LIST_HEAD(&bp->tc_indr_block_list);\n\n\trc = flow_indr_dev_register(bnxt_tc_setup_indr_cb, bp);\n\tif (!rc)\n\t\treturn 0;\n\n\trhashtable_destroy(&tc_info->encap_table);\n\ndestroy_decap_table:\n\trhashtable_destroy(&tc_info->decap_table);\ndestroy_decap_l2_table:\n\trhashtable_destroy(&tc_info->decap_l2_table);\ndestroy_l2_table:\n\trhashtable_destroy(&tc_info->l2_table);\ndestroy_flow_table:\n\trhashtable_destroy(&tc_info->flow_table);\nfree_tc_info:\n\tkfree(tc_info);\n\tbp->tc_info = NULL;\n\treturn rc;\n}\n\nvoid bnxt_shutdown_tc(struct bnxt *bp)\n{\n\tstruct bnxt_tc_info *tc_info = bp->tc_info;\n\n\tif (!bnxt_tc_flower_enabled(bp))\n\t\treturn;\n\n\tflow_indr_dev_unregister(bnxt_tc_setup_indr_cb, bp,\n\t\t\t\t bnxt_tc_setup_indr_rel);\n\trhashtable_destroy(&tc_info->flow_table);\n\trhashtable_destroy(&tc_info->l2_table);\n\trhashtable_destroy(&tc_info->decap_l2_table);\n\trhashtable_destroy(&tc_info->decap_table);\n\trhashtable_destroy(&tc_info->encap_table);\n\tkfree(tc_info);\n\tbp->tc_info = NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}