{
  "module_name": "myri10ge.c",
  "hash_id": "6edd5a6362127911ccb9e6c51fac28e3146e681f62b7a5184733d4b7a9b8e1af",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/myricom/myri10ge/myri10ge.c",
  "human_readable_source": " \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/tcp.h>\n#include <linux/netdevice.h>\n#include <linux/skbuff.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/dma-mapping.h>\n#include <linux/etherdevice.h>\n#include <linux/if_ether.h>\n#include <linux/if_vlan.h>\n#include <linux/dca.h>\n#include <linux/ip.h>\n#include <linux/inet.h>\n#include <linux/in.h>\n#include <linux/ethtool.h>\n#include <linux/firmware.h>\n#include <linux/delay.h>\n#include <linux/timer.h>\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/moduleparam.h>\n#include <linux/io.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/prefetch.h>\n#include <net/checksum.h>\n#include <net/gso.h>\n#include <net/ip.h>\n#include <net/tcp.h>\n#include <asm/byteorder.h>\n#include <asm/processor.h>\n\n#include \"myri10ge_mcp.h\"\n#include \"myri10ge_mcp_gen_header.h\"\n\n#define MYRI10GE_VERSION_STR \"1.5.3-1.534\"\n\nMODULE_DESCRIPTION(\"Myricom 10G driver (10GbE)\");\nMODULE_AUTHOR(\"Maintainer: help@myri.com\");\nMODULE_VERSION(MYRI10GE_VERSION_STR);\nMODULE_LICENSE(\"Dual BSD/GPL\");\n\n#define MYRI10GE_MAX_ETHER_MTU 9014\n\n#define MYRI10GE_ETH_STOPPED 0\n#define MYRI10GE_ETH_STOPPING 1\n#define MYRI10GE_ETH_STARTING 2\n#define MYRI10GE_ETH_RUNNING 3\n#define MYRI10GE_ETH_OPEN_FAILED 4\n\n#define MYRI10GE_EEPROM_STRINGS_SIZE 256\n#define MYRI10GE_MAX_SEND_DESC_TSO ((65536 / 2048) * 2)\n\n#define MYRI10GE_NO_CONFIRM_DATA htonl(0xffffffff)\n#define MYRI10GE_NO_RESPONSE_RESULT 0xffffffff\n\n#define MYRI10GE_ALLOC_ORDER 0\n#define MYRI10GE_ALLOC_SIZE ((1 << MYRI10GE_ALLOC_ORDER) * PAGE_SIZE)\n#define MYRI10GE_MAX_FRAGS_PER_FRAME (MYRI10GE_MAX_ETHER_MTU/MYRI10GE_ALLOC_SIZE + 1)\n\n#define MYRI10GE_MAX_SLICES 32\n\nstruct myri10ge_rx_buffer_state {\n\tstruct page *page;\n\tint page_offset;\n\tDEFINE_DMA_UNMAP_ADDR(bus);\n\tDEFINE_DMA_UNMAP_LEN(len);\n};\n\nstruct myri10ge_tx_buffer_state {\n\tstruct sk_buff *skb;\n\tint last;\n\tDEFINE_DMA_UNMAP_ADDR(bus);\n\tDEFINE_DMA_UNMAP_LEN(len);\n};\n\nstruct myri10ge_cmd {\n\tu32 data0;\n\tu32 data1;\n\tu32 data2;\n};\n\nstruct myri10ge_rx_buf {\n\tstruct mcp_kreq_ether_recv __iomem *lanai;\t \n\tstruct mcp_kreq_ether_recv *shadow;\t \n\tstruct myri10ge_rx_buffer_state *info;\n\tstruct page *page;\n\tdma_addr_t bus;\n\tint page_offset;\n\tint cnt;\n\tint fill_cnt;\n\tint alloc_fail;\n\tint mask;\t\t \n\tint watchdog_needed;\n};\n\nstruct myri10ge_tx_buf {\n\tstruct mcp_kreq_ether_send __iomem *lanai;\t \n\t__be32 __iomem *send_go;\t \n\t__be32 __iomem *send_stop;\t \n\tstruct mcp_kreq_ether_send *req_list;\t \n\tchar *req_bytes;\n\tstruct myri10ge_tx_buffer_state *info;\n\tint mask;\t\t \n\tint req ____cacheline_aligned;\t \n\tint pkt_start;\t\t \n\tint stop_queue;\n\tint linearized;\n\tint done ____cacheline_aligned;\t \n\tint pkt_done;\t\t \n\tint wake_queue;\n\tint queue_active;\n};\n\nstruct myri10ge_rx_done {\n\tstruct mcp_slot *entry;\n\tdma_addr_t bus;\n\tint cnt;\n\tint idx;\n};\n\nstruct myri10ge_slice_netstats {\n\tunsigned long rx_packets;\n\tunsigned long tx_packets;\n\tunsigned long rx_bytes;\n\tunsigned long tx_bytes;\n\tunsigned long rx_dropped;\n\tunsigned long tx_dropped;\n};\n\nstruct myri10ge_slice_state {\n\tstruct myri10ge_tx_buf tx;\t \n\tstruct myri10ge_rx_buf rx_small;\n\tstruct myri10ge_rx_buf rx_big;\n\tstruct myri10ge_rx_done rx_done;\n\tstruct net_device *dev;\n\tstruct napi_struct napi;\n\tstruct myri10ge_priv *mgp;\n\tstruct myri10ge_slice_netstats stats;\n\t__be32 __iomem *irq_claim;\n\tstruct mcp_irq_data *fw_stats;\n\tdma_addr_t fw_stats_bus;\n\tint watchdog_tx_done;\n\tint watchdog_tx_req;\n\tint watchdog_rx_done;\n\tint stuck;\n#ifdef CONFIG_MYRI10GE_DCA\n\tint cached_dca_tag;\n\tint cpu;\n\t__be32 __iomem *dca_tag;\n#endif\n\tchar irq_desc[32];\n};\n\nstruct myri10ge_priv {\n\tstruct myri10ge_slice_state *ss;\n\tint tx_boundary;\t \n\tint num_slices;\n\tint running;\t\t \n\tint small_bytes;\n\tint big_bytes;\n\tint max_intr_slots;\n\tstruct net_device *dev;\n\tu8 __iomem *sram;\n\tint sram_size;\n\tunsigned long board_span;\n\tunsigned long iomem_base;\n\t__be32 __iomem *irq_deassert;\n\tchar *mac_addr_string;\n\tstruct mcp_cmd_response *cmd;\n\tdma_addr_t cmd_bus;\n\tstruct pci_dev *pdev;\n\tint msi_enabled;\n\tint msix_enabled;\n\tstruct msix_entry *msix_vectors;\n#ifdef CONFIG_MYRI10GE_DCA\n\tint dca_enabled;\n\tint relaxed_order;\n#endif\n\tu32 link_state;\n\tunsigned int rdma_tags_available;\n\tint intr_coal_delay;\n\t__be32 __iomem *intr_coal_delay_ptr;\n\tint wc_cookie;\n\tint down_cnt;\n\twait_queue_head_t down_wq;\n\tstruct work_struct watchdog_work;\n\tstruct timer_list watchdog_timer;\n\tint watchdog_resets;\n\tint watchdog_pause;\n\tint pause;\n\tbool fw_name_allocated;\n\tchar *fw_name;\n\tchar eeprom_strings[MYRI10GE_EEPROM_STRINGS_SIZE];\n\tchar *product_code_string;\n\tchar fw_version[128];\n\tint fw_ver_major;\n\tint fw_ver_minor;\n\tint fw_ver_tiny;\n\tint adopted_rx_filter_bug;\n\tu8 mac_addr[ETH_ALEN];\t\t \n\tunsigned long serial_number;\n\tint vendor_specific_offset;\n\tint fw_multicast_support;\n\tu32 features;\n\tu32 max_tso6;\n\tu32 read_dma;\n\tu32 write_dma;\n\tu32 read_write_dma;\n\tu32 link_changes;\n\tu32 msg_enable;\n\tunsigned int board_number;\n\tint rebooted;\n};\n\nstatic char *myri10ge_fw_unaligned = \"myri10ge_ethp_z8e.dat\";\nstatic char *myri10ge_fw_aligned = \"myri10ge_eth_z8e.dat\";\nstatic char *myri10ge_fw_rss_unaligned = \"myri10ge_rss_ethp_z8e.dat\";\nstatic char *myri10ge_fw_rss_aligned = \"myri10ge_rss_eth_z8e.dat\";\nMODULE_FIRMWARE(\"myri10ge_ethp_z8e.dat\");\nMODULE_FIRMWARE(\"myri10ge_eth_z8e.dat\");\nMODULE_FIRMWARE(\"myri10ge_rss_ethp_z8e.dat\");\nMODULE_FIRMWARE(\"myri10ge_rss_eth_z8e.dat\");\n\n \nstatic char *myri10ge_fw_name = NULL;\nmodule_param(myri10ge_fw_name, charp, 0644);\nMODULE_PARM_DESC(myri10ge_fw_name, \"Firmware image name\");\n\n#define MYRI10GE_MAX_BOARDS 8\nstatic char *myri10ge_fw_names[MYRI10GE_MAX_BOARDS] =\n    {[0 ... (MYRI10GE_MAX_BOARDS - 1)] = NULL };\nmodule_param_array_named(myri10ge_fw_names, myri10ge_fw_names, charp, NULL,\n\t\t\t 0444);\nMODULE_PARM_DESC(myri10ge_fw_names, \"Firmware image names per board\");\n\nstatic int myri10ge_ecrc_enable = 1;\nmodule_param(myri10ge_ecrc_enable, int, 0444);\nMODULE_PARM_DESC(myri10ge_ecrc_enable, \"Enable Extended CRC on PCI-E\");\n\nstatic int myri10ge_small_bytes = -1;\t \nmodule_param(myri10ge_small_bytes, int, 0644);\nMODULE_PARM_DESC(myri10ge_small_bytes, \"Threshold of small packets\");\n\nstatic int myri10ge_msi = 1;\t \nmodule_param(myri10ge_msi, int, 0644);\nMODULE_PARM_DESC(myri10ge_msi, \"Enable Message Signalled Interrupts\");\n\nstatic int myri10ge_intr_coal_delay = 75;\nmodule_param(myri10ge_intr_coal_delay, int, 0444);\nMODULE_PARM_DESC(myri10ge_intr_coal_delay, \"Interrupt coalescing delay\");\n\nstatic int myri10ge_flow_control = 1;\nmodule_param(myri10ge_flow_control, int, 0444);\nMODULE_PARM_DESC(myri10ge_flow_control, \"Pause parameter\");\n\nstatic int myri10ge_deassert_wait = 1;\nmodule_param(myri10ge_deassert_wait, int, 0644);\nMODULE_PARM_DESC(myri10ge_deassert_wait,\n\t\t \"Wait when deasserting legacy interrupts\");\n\nstatic int myri10ge_force_firmware = 0;\nmodule_param(myri10ge_force_firmware, int, 0444);\nMODULE_PARM_DESC(myri10ge_force_firmware,\n\t\t \"Force firmware to assume aligned completions\");\n\nstatic int myri10ge_initial_mtu = MYRI10GE_MAX_ETHER_MTU - ETH_HLEN;\nmodule_param(myri10ge_initial_mtu, int, 0444);\nMODULE_PARM_DESC(myri10ge_initial_mtu, \"Initial MTU\");\n\nstatic int myri10ge_napi_weight = 64;\nmodule_param(myri10ge_napi_weight, int, 0444);\nMODULE_PARM_DESC(myri10ge_napi_weight, \"Set NAPI weight\");\n\nstatic int myri10ge_watchdog_timeout = 1;\nmodule_param(myri10ge_watchdog_timeout, int, 0444);\nMODULE_PARM_DESC(myri10ge_watchdog_timeout, \"Set watchdog timeout\");\n\nstatic int myri10ge_max_irq_loops = 1048576;\nmodule_param(myri10ge_max_irq_loops, int, 0444);\nMODULE_PARM_DESC(myri10ge_max_irq_loops,\n\t\t \"Set stuck legacy IRQ detection threshold\");\n\n#define MYRI10GE_MSG_DEFAULT NETIF_MSG_LINK\n\nstatic int myri10ge_debug = -1;\t \nmodule_param(myri10ge_debug, int, 0);\nMODULE_PARM_DESC(myri10ge_debug, \"Debug level (0=none,...,16=all)\");\n\nstatic int myri10ge_fill_thresh = 256;\nmodule_param(myri10ge_fill_thresh, int, 0644);\nMODULE_PARM_DESC(myri10ge_fill_thresh, \"Number of empty rx slots allowed\");\n\nstatic int myri10ge_reset_recover = 1;\n\nstatic int myri10ge_max_slices = 1;\nmodule_param(myri10ge_max_slices, int, 0444);\nMODULE_PARM_DESC(myri10ge_max_slices, \"Max tx/rx queues\");\n\nstatic int myri10ge_rss_hash = MXGEFW_RSS_HASH_TYPE_SRC_DST_PORT;\nmodule_param(myri10ge_rss_hash, int, 0444);\nMODULE_PARM_DESC(myri10ge_rss_hash, \"Type of RSS hashing to do\");\n\nstatic int myri10ge_dca = 1;\nmodule_param(myri10ge_dca, int, 0444);\nMODULE_PARM_DESC(myri10ge_dca, \"Enable DCA if possible\");\n\n#define MYRI10GE_FW_OFFSET 1024*1024\n#define MYRI10GE_HIGHPART_TO_U32(X) \\\n(sizeof (X) == 8) ? ((u32)((u64)(X) >> 32)) : (0)\n#define MYRI10GE_LOWPART_TO_U32(X) ((u32)(X))\n\n#define myri10ge_pio_copy(to,from,size) __iowrite64_copy(to,from,size/8)\n\nstatic void myri10ge_set_multicast_list(struct net_device *dev);\nstatic netdev_tx_t myri10ge_sw_tso(struct sk_buff *skb,\n\t\t\t\t\t struct net_device *dev);\n\nstatic inline void put_be32(__be32 val, __be32 __iomem * p)\n{\n\t__raw_writel((__force __u32) val, (__force void __iomem *)p);\n}\n\nstatic void myri10ge_get_stats(struct net_device *dev,\n\t\t\t       struct rtnl_link_stats64 *stats);\n\nstatic void set_fw_name(struct myri10ge_priv *mgp, char *name, bool allocated)\n{\n\tif (mgp->fw_name_allocated)\n\t\tkfree(mgp->fw_name);\n\tmgp->fw_name = name;\n\tmgp->fw_name_allocated = allocated;\n}\n\nstatic int\nmyri10ge_send_cmd(struct myri10ge_priv *mgp, u32 cmd,\n\t\t  struct myri10ge_cmd *data, int atomic)\n{\n\tstruct mcp_cmd *buf;\n\tchar buf_bytes[sizeof(*buf) + 8];\n\tstruct mcp_cmd_response *response = mgp->cmd;\n\tchar __iomem *cmd_addr = mgp->sram + MXGEFW_ETH_CMD;\n\tu32 dma_low, dma_high, result, value;\n\tint sleep_total = 0;\n\n\t \n\tbuf = (struct mcp_cmd *)ALIGN((unsigned long)buf_bytes, 8);\n\n\tbuf->data0 = htonl(data->data0);\n\tbuf->data1 = htonl(data->data1);\n\tbuf->data2 = htonl(data->data2);\n\tbuf->cmd = htonl(cmd);\n\tdma_low = MYRI10GE_LOWPART_TO_U32(mgp->cmd_bus);\n\tdma_high = MYRI10GE_HIGHPART_TO_U32(mgp->cmd_bus);\n\n\tbuf->response_addr.low = htonl(dma_low);\n\tbuf->response_addr.high = htonl(dma_high);\n\tresponse->result = htonl(MYRI10GE_NO_RESPONSE_RESULT);\n\tmb();\n\tmyri10ge_pio_copy(cmd_addr, buf, sizeof(*buf));\n\n\t \n\tif (atomic) {\n\t\t \n\t\tfor (sleep_total = 0;\n\t\t     sleep_total < 1000 &&\n\t\t     response->result == htonl(MYRI10GE_NO_RESPONSE_RESULT);\n\t\t     sleep_total += 10) {\n\t\t\tudelay(10);\n\t\t\tmb();\n\t\t}\n\t} else {\n\t\t \n\t\tfor (sleep_total = 0;\n\t\t     sleep_total < 15 &&\n\t\t     response->result == htonl(MYRI10GE_NO_RESPONSE_RESULT);\n\t\t     sleep_total++)\n\t\t\tmsleep(1);\n\t}\n\n\tresult = ntohl(response->result);\n\tvalue = ntohl(response->data);\n\tif (result != MYRI10GE_NO_RESPONSE_RESULT) {\n\t\tif (result == 0) {\n\t\t\tdata->data0 = value;\n\t\t\treturn 0;\n\t\t} else if (result == MXGEFW_CMD_UNKNOWN) {\n\t\t\treturn -ENOSYS;\n\t\t} else if (result == MXGEFW_CMD_ERROR_UNALIGNED) {\n\t\t\treturn -E2BIG;\n\t\t} else if (result == MXGEFW_CMD_ERROR_RANGE &&\n\t\t\t   cmd == MXGEFW_CMD_ENABLE_RSS_QUEUES &&\n\t\t\t   (data->\n\t\t\t    data1 & MXGEFW_SLICE_ENABLE_MULTIPLE_TX_QUEUES) !=\n\t\t\t   0) {\n\t\t\treturn -ERANGE;\n\t\t} else {\n\t\t\tdev_err(&mgp->pdev->dev,\n\t\t\t\t\"command %d failed, result = %d\\n\",\n\t\t\t\tcmd, result);\n\t\t\treturn -ENXIO;\n\t\t}\n\t}\n\n\tdev_err(&mgp->pdev->dev, \"command %d timed out, result = %d\\n\",\n\t\tcmd, result);\n\treturn -EAGAIN;\n}\n\n \nstatic int myri10ge_read_mac_addr(struct myri10ge_priv *mgp)\n{\n\tchar *ptr, *limit;\n\tint i;\n\n\tptr = mgp->eeprom_strings;\n\tlimit = mgp->eeprom_strings + MYRI10GE_EEPROM_STRINGS_SIZE;\n\n\twhile (*ptr != '\\0' && ptr < limit) {\n\t\tif (memcmp(ptr, \"MAC=\", 4) == 0) {\n\t\t\tptr += 4;\n\t\t\tmgp->mac_addr_string = ptr;\n\t\t\tfor (i = 0; i < 6; i++) {\n\t\t\t\tif ((ptr + 2) > limit)\n\t\t\t\t\tgoto abort;\n\t\t\t\tmgp->mac_addr[i] =\n\t\t\t\t    simple_strtoul(ptr, &ptr, 16);\n\t\t\t\tptr += 1;\n\t\t\t}\n\t\t}\n\t\tif (memcmp(ptr, \"PC=\", 3) == 0) {\n\t\t\tptr += 3;\n\t\t\tmgp->product_code_string = ptr;\n\t\t}\n\t\tif (memcmp((const void *)ptr, \"SN=\", 3) == 0) {\n\t\t\tptr += 3;\n\t\t\tmgp->serial_number = simple_strtoul(ptr, &ptr, 10);\n\t\t}\n\t\twhile (ptr < limit && *ptr++) ;\n\t}\n\n\treturn 0;\n\nabort:\n\tdev_err(&mgp->pdev->dev, \"failed to parse eeprom_strings\\n\");\n\treturn -ENXIO;\n}\n\n \n\nstatic void myri10ge_dummy_rdma(struct myri10ge_priv *mgp, int enable)\n{\n\tchar __iomem *submit;\n\t__be32 buf[16] __attribute__ ((__aligned__(8)));\n\tu32 dma_low, dma_high;\n\tint i;\n\n\t \n\tmgp->cmd->data = 0;\n\tmb();\n\n\t \n\tdma_low = MYRI10GE_LOWPART_TO_U32(mgp->cmd_bus);\n\tdma_high = MYRI10GE_HIGHPART_TO_U32(mgp->cmd_bus);\n\n\tbuf[0] = htonl(dma_high);\t \n\tbuf[1] = htonl(dma_low);\t \n\tbuf[2] = MYRI10GE_NO_CONFIRM_DATA;\t \n\tbuf[3] = htonl(dma_high);\t \n\tbuf[4] = htonl(dma_low);\t \n\tbuf[5] = htonl(enable);\t \n\n\tsubmit = mgp->sram + MXGEFW_BOOT_DUMMY_RDMA;\n\n\tmyri10ge_pio_copy(submit, &buf, sizeof(buf));\n\tfor (i = 0; mgp->cmd->data != MYRI10GE_NO_CONFIRM_DATA && i < 20; i++)\n\t\tmsleep(1);\n\tif (mgp->cmd->data != MYRI10GE_NO_CONFIRM_DATA)\n\t\tdev_err(&mgp->pdev->dev, \"dummy rdma %s failed\\n\",\n\t\t\t(enable ? \"enable\" : \"disable\"));\n}\n\nstatic int\nmyri10ge_validate_firmware(struct myri10ge_priv *mgp,\n\t\t\t   struct mcp_gen_header *hdr)\n{\n\tstruct device *dev = &mgp->pdev->dev;\n\n\t \n\tif (ntohl(hdr->mcp_type) != MCP_TYPE_ETH) {\n\t\tdev_err(dev, \"Bad firmware type: 0x%x\\n\", ntohl(hdr->mcp_type));\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tstrscpy(mgp->fw_version, hdr->version, sizeof(mgp->fw_version));\n\n\tsscanf(mgp->fw_version, \"%d.%d.%d\", &mgp->fw_ver_major,\n\t       &mgp->fw_ver_minor, &mgp->fw_ver_tiny);\n\n\tif (!(mgp->fw_ver_major == MXGEFW_VERSION_MAJOR &&\n\t      mgp->fw_ver_minor == MXGEFW_VERSION_MINOR)) {\n\t\tdev_err(dev, \"Found firmware version %s\\n\", mgp->fw_version);\n\t\tdev_err(dev, \"Driver needs %d.%d\\n\", MXGEFW_VERSION_MAJOR,\n\t\t\tMXGEFW_VERSION_MINOR);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int myri10ge_load_hotplug_firmware(struct myri10ge_priv *mgp, u32 * size)\n{\n\tunsigned crc, reread_crc;\n\tconst struct firmware *fw;\n\tstruct device *dev = &mgp->pdev->dev;\n\tunsigned char *fw_readback;\n\tstruct mcp_gen_header *hdr;\n\tsize_t hdr_offset;\n\tint status;\n\tunsigned i;\n\n\tif (request_firmware(&fw, mgp->fw_name, dev) < 0) {\n\t\tdev_err(dev, \"Unable to load %s firmware image via hotplug\\n\",\n\t\t\tmgp->fw_name);\n\t\tstatus = -EINVAL;\n\t\tgoto abort_with_nothing;\n\t}\n\n\t \n\n\tif (fw->size >= mgp->sram_size - MYRI10GE_FW_OFFSET ||\n\t    fw->size < MCP_HEADER_PTR_OFFSET + 4) {\n\t\tdev_err(dev, \"Firmware size invalid:%d\\n\", (int)fw->size);\n\t\tstatus = -EINVAL;\n\t\tgoto abort_with_fw;\n\t}\n\n\t \n\thdr_offset = ntohl(*(__be32 *) (fw->data + MCP_HEADER_PTR_OFFSET));\n\tif ((hdr_offset & 3) || hdr_offset + sizeof(*hdr) > fw->size) {\n\t\tdev_err(dev, \"Bad firmware file\\n\");\n\t\tstatus = -EINVAL;\n\t\tgoto abort_with_fw;\n\t}\n\thdr = (void *)(fw->data + hdr_offset);\n\n\tstatus = myri10ge_validate_firmware(mgp, hdr);\n\tif (status != 0)\n\t\tgoto abort_with_fw;\n\n\tcrc = crc32(~0, fw->data, fw->size);\n\tfor (i = 0; i < fw->size; i += 256) {\n\t\tmyri10ge_pio_copy(mgp->sram + MYRI10GE_FW_OFFSET + i,\n\t\t\t\t  fw->data + i,\n\t\t\t\t  min(256U, (unsigned)(fw->size - i)));\n\t\tmb();\n\t\treadb(mgp->sram);\n\t}\n\tfw_readback = vmalloc(fw->size);\n\tif (!fw_readback) {\n\t\tstatus = -ENOMEM;\n\t\tgoto abort_with_fw;\n\t}\n\t \n\tmemcpy_fromio(fw_readback, mgp->sram + MYRI10GE_FW_OFFSET, fw->size);\n\treread_crc = crc32(~0, fw_readback, fw->size);\n\tvfree(fw_readback);\n\tif (crc != reread_crc) {\n\t\tdev_err(dev, \"CRC failed(fw-len=%u), got 0x%x (expect 0x%x)\\n\",\n\t\t\t(unsigned)fw->size, reread_crc, crc);\n\t\tstatus = -EIO;\n\t\tgoto abort_with_fw;\n\t}\n\t*size = (u32) fw->size;\n\nabort_with_fw:\n\trelease_firmware(fw);\n\nabort_with_nothing:\n\treturn status;\n}\n\nstatic int myri10ge_adopt_running_firmware(struct myri10ge_priv *mgp)\n{\n\tstruct mcp_gen_header *hdr;\n\tstruct device *dev = &mgp->pdev->dev;\n\tconst size_t bytes = sizeof(struct mcp_gen_header);\n\tsize_t hdr_offset;\n\tint status;\n\n\t \n\thdr_offset = swab32(readl(mgp->sram + MCP_HEADER_PTR_OFFSET));\n\n\tif ((hdr_offset & 3) || hdr_offset + sizeof(*hdr) > mgp->sram_size) {\n\t\tdev_err(dev, \"Running firmware has bad header offset (%d)\\n\",\n\t\t\t(int)hdr_offset);\n\t\treturn -EIO;\n\t}\n\n\t \n\thdr = kmalloc(bytes, GFP_KERNEL);\n\tif (hdr == NULL)\n\t\treturn -ENOMEM;\n\n\tmemcpy_fromio(hdr, mgp->sram + hdr_offset, bytes);\n\tstatus = myri10ge_validate_firmware(mgp, hdr);\n\tkfree(hdr);\n\n\t \n\tif (mgp->fw_ver_major == 1 && mgp->fw_ver_minor == 4 &&\n\t    mgp->fw_ver_tiny >= 4 && mgp->fw_ver_tiny <= 11) {\n\t\tmgp->adopted_rx_filter_bug = 1;\n\t\tdev_warn(dev, \"Adopting fw %d.%d.%d: \"\n\t\t\t \"working around rx filter bug\\n\",\n\t\t\t mgp->fw_ver_major, mgp->fw_ver_minor,\n\t\t\t mgp->fw_ver_tiny);\n\t}\n\treturn status;\n}\n\nstatic int myri10ge_get_firmware_capabilities(struct myri10ge_priv *mgp)\n{\n\tstruct myri10ge_cmd cmd;\n\tint status;\n\n\t \n\tmgp->features = NETIF_F_SG | NETIF_F_HW_CSUM | NETIF_F_TSO;\n\tstatus = myri10ge_send_cmd(mgp, MXGEFW_CMD_GET_MAX_TSO6_HDR_SIZE,\n\t\t\t\t   &cmd, 0);\n\tif (status == 0) {\n\t\tmgp->max_tso6 = cmd.data0;\n\t\tmgp->features |= NETIF_F_TSO6;\n\t}\n\n\tstatus = myri10ge_send_cmd(mgp, MXGEFW_CMD_GET_RX_RING_SIZE, &cmd, 0);\n\tif (status != 0) {\n\t\tdev_err(&mgp->pdev->dev,\n\t\t\t\"failed MXGEFW_CMD_GET_RX_RING_SIZE\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tmgp->max_intr_slots = 2 * (cmd.data0 / sizeof(struct mcp_dma_addr));\n\n\treturn 0;\n}\n\nstatic int myri10ge_load_firmware(struct myri10ge_priv *mgp, int adopt)\n{\n\tchar __iomem *submit;\n\t__be32 buf[16] __attribute__ ((__aligned__(8)));\n\tu32 dma_low, dma_high, size;\n\tint status, i;\n\n\tsize = 0;\n\tstatus = myri10ge_load_hotplug_firmware(mgp, &size);\n\tif (status) {\n\t\tif (!adopt)\n\t\t\treturn status;\n\t\tdev_warn(&mgp->pdev->dev, \"hotplug firmware loading failed\\n\");\n\n\t\t \n\t\tif (status == -EIO)\n\t\t\treturn status;\n\n\t\tstatus = myri10ge_adopt_running_firmware(mgp);\n\t\tif (status != 0) {\n\t\t\tdev_err(&mgp->pdev->dev,\n\t\t\t\t\"failed to adopt running firmware\\n\");\n\t\t\treturn status;\n\t\t}\n\t\tdev_info(&mgp->pdev->dev,\n\t\t\t \"Successfully adopted running firmware\\n\");\n\t\tif (mgp->tx_boundary == 4096) {\n\t\t\tdev_warn(&mgp->pdev->dev,\n\t\t\t\t \"Using firmware currently running on NIC\"\n\t\t\t\t \".  For optimal\\n\");\n\t\t\tdev_warn(&mgp->pdev->dev,\n\t\t\t\t \"performance consider loading optimized \"\n\t\t\t\t \"firmware\\n\");\n\t\t\tdev_warn(&mgp->pdev->dev, \"via hotplug\\n\");\n\t\t}\n\n\t\tset_fw_name(mgp, \"adopted\", false);\n\t\tmgp->tx_boundary = 2048;\n\t\tmyri10ge_dummy_rdma(mgp, 1);\n\t\tstatus = myri10ge_get_firmware_capabilities(mgp);\n\t\treturn status;\n\t}\n\n\t \n\tmgp->cmd->data = 0;\n\tmb();\n\n\t \n\tdma_low = MYRI10GE_LOWPART_TO_U32(mgp->cmd_bus);\n\tdma_high = MYRI10GE_HIGHPART_TO_U32(mgp->cmd_bus);\n\n\tbuf[0] = htonl(dma_high);\t \n\tbuf[1] = htonl(dma_low);\t \n\tbuf[2] = MYRI10GE_NO_CONFIRM_DATA;\t \n\n\t \n\tbuf[3] = htonl(MYRI10GE_FW_OFFSET + 8);\t \n\tbuf[4] = htonl(size - 8);\t \n\tbuf[5] = htonl(8);\t \n\tbuf[6] = htonl(0);\t \n\n\tsubmit = mgp->sram + MXGEFW_BOOT_HANDOFF;\n\n\tmyri10ge_pio_copy(submit, &buf, sizeof(buf));\n\tmb();\n\tmsleep(1);\n\tmb();\n\ti = 0;\n\twhile (mgp->cmd->data != MYRI10GE_NO_CONFIRM_DATA && i < 9) {\n\t\tmsleep(1 << i);\n\t\ti++;\n\t}\n\tif (mgp->cmd->data != MYRI10GE_NO_CONFIRM_DATA) {\n\t\tdev_err(&mgp->pdev->dev, \"handoff failed\\n\");\n\t\treturn -ENXIO;\n\t}\n\tmyri10ge_dummy_rdma(mgp, 1);\n\tstatus = myri10ge_get_firmware_capabilities(mgp);\n\n\treturn status;\n}\n\nstatic int myri10ge_update_mac_address(struct myri10ge_priv *mgp,\n\t\t\t\t       const u8 * addr)\n{\n\tstruct myri10ge_cmd cmd;\n\tint status;\n\n\tcmd.data0 = ((addr[0] << 24) | (addr[1] << 16)\n\t\t     | (addr[2] << 8) | addr[3]);\n\n\tcmd.data1 = ((addr[4] << 8) | (addr[5]));\n\n\tstatus = myri10ge_send_cmd(mgp, MXGEFW_SET_MAC_ADDRESS, &cmd, 0);\n\treturn status;\n}\n\nstatic int myri10ge_change_pause(struct myri10ge_priv *mgp, int pause)\n{\n\tstruct myri10ge_cmd cmd;\n\tint status, ctl;\n\n\tctl = pause ? MXGEFW_ENABLE_FLOW_CONTROL : MXGEFW_DISABLE_FLOW_CONTROL;\n\tstatus = myri10ge_send_cmd(mgp, ctl, &cmd, 0);\n\n\tif (status) {\n\t\tnetdev_err(mgp->dev, \"Failed to set flow control mode\\n\");\n\t\treturn status;\n\t}\n\tmgp->pause = pause;\n\treturn 0;\n}\n\nstatic void\nmyri10ge_change_promisc(struct myri10ge_priv *mgp, int promisc, int atomic)\n{\n\tstruct myri10ge_cmd cmd;\n\tint status, ctl;\n\n\tctl = promisc ? MXGEFW_ENABLE_PROMISC : MXGEFW_DISABLE_PROMISC;\n\tstatus = myri10ge_send_cmd(mgp, ctl, &cmd, atomic);\n\tif (status)\n\t\tnetdev_err(mgp->dev, \"Failed to set promisc mode\\n\");\n}\n\nstatic int myri10ge_dma_test(struct myri10ge_priv *mgp, int test_type)\n{\n\tstruct myri10ge_cmd cmd;\n\tint status;\n\tu32 len;\n\tstruct page *dmatest_page;\n\tdma_addr_t dmatest_bus;\n\tchar *test = \" \";\n\n\tdmatest_page = alloc_page(GFP_KERNEL);\n\tif (!dmatest_page)\n\t\treturn -ENOMEM;\n\tdmatest_bus = dma_map_page(&mgp->pdev->dev, dmatest_page, 0,\n\t\t\t\t   PAGE_SIZE, DMA_BIDIRECTIONAL);\n\tif (unlikely(dma_mapping_error(&mgp->pdev->dev, dmatest_bus))) {\n\t\t__free_page(dmatest_page);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\n\tlen = mgp->tx_boundary;\n\n\tcmd.data0 = MYRI10GE_LOWPART_TO_U32(dmatest_bus);\n\tcmd.data1 = MYRI10GE_HIGHPART_TO_U32(dmatest_bus);\n\tcmd.data2 = len * 0x10000;\n\tstatus = myri10ge_send_cmd(mgp, test_type, &cmd, 0);\n\tif (status != 0) {\n\t\ttest = \"read\";\n\t\tgoto abort;\n\t}\n\tmgp->read_dma = ((cmd.data0 >> 16) * len * 2) / (cmd.data0 & 0xffff);\n\tcmd.data0 = MYRI10GE_LOWPART_TO_U32(dmatest_bus);\n\tcmd.data1 = MYRI10GE_HIGHPART_TO_U32(dmatest_bus);\n\tcmd.data2 = len * 0x1;\n\tstatus = myri10ge_send_cmd(mgp, test_type, &cmd, 0);\n\tif (status != 0) {\n\t\ttest = \"write\";\n\t\tgoto abort;\n\t}\n\tmgp->write_dma = ((cmd.data0 >> 16) * len * 2) / (cmd.data0 & 0xffff);\n\n\tcmd.data0 = MYRI10GE_LOWPART_TO_U32(dmatest_bus);\n\tcmd.data1 = MYRI10GE_HIGHPART_TO_U32(dmatest_bus);\n\tcmd.data2 = len * 0x10001;\n\tstatus = myri10ge_send_cmd(mgp, test_type, &cmd, 0);\n\tif (status != 0) {\n\t\ttest = \"read/write\";\n\t\tgoto abort;\n\t}\n\tmgp->read_write_dma = ((cmd.data0 >> 16) * len * 2 * 2) /\n\t    (cmd.data0 & 0xffff);\n\nabort:\n\tdma_unmap_page(&mgp->pdev->dev, dmatest_bus, PAGE_SIZE,\n\t\t       DMA_BIDIRECTIONAL);\n\tput_page(dmatest_page);\n\n\tif (status != 0 && test_type != MXGEFW_CMD_UNALIGNED_TEST)\n\t\tdev_warn(&mgp->pdev->dev, \"DMA %s benchmark failed: %d\\n\",\n\t\t\t test, status);\n\n\treturn status;\n}\n\nstatic int myri10ge_reset(struct myri10ge_priv *mgp)\n{\n\tstruct myri10ge_cmd cmd;\n\tstruct myri10ge_slice_state *ss;\n\tint i, status;\n\tsize_t bytes;\n#ifdef CONFIG_MYRI10GE_DCA\n\tunsigned long dca_tag_off;\n#endif\n\n\t \n\tmemset(&cmd, 0, sizeof(cmd));\n\tstatus = myri10ge_send_cmd(mgp, MXGEFW_CMD_RESET, &cmd, 0);\n\tif (status != 0) {\n\t\tdev_err(&mgp->pdev->dev, \"failed reset\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\t(void)myri10ge_dma_test(mgp, MXGEFW_DMA_TEST);\n\t \n\tcmd.data0 = MXGEFW_RSS_MCP_SLOT_TYPE_MIN;\n\t(void)myri10ge_send_cmd(mgp, MXGEFW_CMD_SET_RSS_MCP_SLOT_TYPE, &cmd, 0);\n\n\t \n\n\tbytes = mgp->max_intr_slots * sizeof(*mgp->ss[0].rx_done.entry);\n\tcmd.data0 = (u32) bytes;\n\tstatus = myri10ge_send_cmd(mgp, MXGEFW_CMD_SET_INTRQ_SIZE, &cmd, 0);\n\n\t \n\n\tif (mgp->num_slices > 1) {\n\n\t\t \n\t\tstatus = myri10ge_send_cmd(mgp, MXGEFW_CMD_GET_MAX_RSS_QUEUES,\n\t\t\t\t\t   &cmd, 0);\n\t\tif (status != 0) {\n\t\t\tdev_err(&mgp->pdev->dev,\n\t\t\t\t\"failed to get number of slices\\n\");\n\t\t}\n\n\t\t \n\n\t\tcmd.data0 = mgp->num_slices;\n\t\tcmd.data1 = MXGEFW_SLICE_INTR_MODE_ONE_PER_SLICE;\n\t\tif (mgp->dev->real_num_tx_queues > 1)\n\t\t\tcmd.data1 |= MXGEFW_SLICE_ENABLE_MULTIPLE_TX_QUEUES;\n\t\tstatus = myri10ge_send_cmd(mgp, MXGEFW_CMD_ENABLE_RSS_QUEUES,\n\t\t\t\t\t   &cmd, 0);\n\n\t\t \n\t\tif (status != 0 && mgp->dev->real_num_tx_queues > 1) {\n\t\t\tnetif_set_real_num_tx_queues(mgp->dev, 1);\n\t\t\tcmd.data0 = mgp->num_slices;\n\t\t\tcmd.data1 = MXGEFW_SLICE_INTR_MODE_ONE_PER_SLICE;\n\t\t\tstatus = myri10ge_send_cmd(mgp,\n\t\t\t\t\t\t   MXGEFW_CMD_ENABLE_RSS_QUEUES,\n\t\t\t\t\t\t   &cmd, 0);\n\t\t}\n\n\t\tif (status != 0) {\n\t\t\tdev_err(&mgp->pdev->dev,\n\t\t\t\t\"failed to set number of slices\\n\");\n\n\t\t\treturn status;\n\t\t}\n\t}\n\tfor (i = 0; i < mgp->num_slices; i++) {\n\t\tss = &mgp->ss[i];\n\t\tcmd.data0 = MYRI10GE_LOWPART_TO_U32(ss->rx_done.bus);\n\t\tcmd.data1 = MYRI10GE_HIGHPART_TO_U32(ss->rx_done.bus);\n\t\tcmd.data2 = i;\n\t\tstatus |= myri10ge_send_cmd(mgp, MXGEFW_CMD_SET_INTRQ_DMA,\n\t\t\t\t\t    &cmd, 0);\n\t}\n\n\tstatus |=\n\t    myri10ge_send_cmd(mgp, MXGEFW_CMD_GET_IRQ_ACK_OFFSET, &cmd, 0);\n\tfor (i = 0; i < mgp->num_slices; i++) {\n\t\tss = &mgp->ss[i];\n\t\tss->irq_claim =\n\t\t    (__iomem __be32 *) (mgp->sram + cmd.data0 + 8 * i);\n\t}\n\tstatus |= myri10ge_send_cmd(mgp, MXGEFW_CMD_GET_IRQ_DEASSERT_OFFSET,\n\t\t\t\t    &cmd, 0);\n\tmgp->irq_deassert = (__iomem __be32 *) (mgp->sram + cmd.data0);\n\n\tstatus |= myri10ge_send_cmd\n\t    (mgp, MXGEFW_CMD_GET_INTR_COAL_DELAY_OFFSET, &cmd, 0);\n\tmgp->intr_coal_delay_ptr = (__iomem __be32 *) (mgp->sram + cmd.data0);\n\tif (status != 0) {\n\t\tdev_err(&mgp->pdev->dev, \"failed set interrupt parameters\\n\");\n\t\treturn status;\n\t}\n\tput_be32(htonl(mgp->intr_coal_delay), mgp->intr_coal_delay_ptr);\n\n#ifdef CONFIG_MYRI10GE_DCA\n\tstatus = myri10ge_send_cmd(mgp, MXGEFW_CMD_GET_DCA_OFFSET, &cmd, 0);\n\tdca_tag_off = cmd.data0;\n\tfor (i = 0; i < mgp->num_slices; i++) {\n\t\tss = &mgp->ss[i];\n\t\tif (status == 0) {\n\t\t\tss->dca_tag = (__iomem __be32 *)\n\t\t\t    (mgp->sram + dca_tag_off + 4 * i);\n\t\t} else {\n\t\t\tss->dca_tag = NULL;\n\t\t}\n\t}\n#endif\t\t\t\t \n\n\t \n\n\tmgp->link_changes = 0;\n\tfor (i = 0; i < mgp->num_slices; i++) {\n\t\tss = &mgp->ss[i];\n\n\t\tmemset(ss->rx_done.entry, 0, bytes);\n\t\tss->tx.req = 0;\n\t\tss->tx.done = 0;\n\t\tss->tx.pkt_start = 0;\n\t\tss->tx.pkt_done = 0;\n\t\tss->rx_big.cnt = 0;\n\t\tss->rx_small.cnt = 0;\n\t\tss->rx_done.idx = 0;\n\t\tss->rx_done.cnt = 0;\n\t\tss->tx.wake_queue = 0;\n\t\tss->tx.stop_queue = 0;\n\t}\n\n\tstatus = myri10ge_update_mac_address(mgp, mgp->dev->dev_addr);\n\tmyri10ge_change_pause(mgp, mgp->pause);\n\tmyri10ge_set_multicast_list(mgp->dev);\n\treturn status;\n}\n\n#ifdef CONFIG_MYRI10GE_DCA\nstatic int myri10ge_toggle_relaxed(struct pci_dev *pdev, int on)\n{\n\tint ret;\n\tu16 ctl;\n\n\tpcie_capability_read_word(pdev, PCI_EXP_DEVCTL, &ctl);\n\n\tret = (ctl & PCI_EXP_DEVCTL_RELAX_EN) >> 4;\n\tif (ret != on) {\n\t\tctl &= ~PCI_EXP_DEVCTL_RELAX_EN;\n\t\tctl |= (on << 4);\n\t\tpcie_capability_write_word(pdev, PCI_EXP_DEVCTL, ctl);\n\t}\n\treturn ret;\n}\n\nstatic void\nmyri10ge_write_dca(struct myri10ge_slice_state *ss, int cpu, int tag)\n{\n\tss->cached_dca_tag = tag;\n\tput_be32(htonl(tag), ss->dca_tag);\n}\n\nstatic inline void myri10ge_update_dca(struct myri10ge_slice_state *ss)\n{\n\tint cpu = get_cpu();\n\tint tag;\n\n\tif (cpu != ss->cpu) {\n\t\ttag = dca3_get_tag(&ss->mgp->pdev->dev, cpu);\n\t\tif (ss->cached_dca_tag != tag)\n\t\t\tmyri10ge_write_dca(ss, cpu, tag);\n\t\tss->cpu = cpu;\n\t}\n\tput_cpu();\n}\n\nstatic void myri10ge_setup_dca(struct myri10ge_priv *mgp)\n{\n\tint err, i;\n\tstruct pci_dev *pdev = mgp->pdev;\n\n\tif (mgp->ss[0].dca_tag == NULL || mgp->dca_enabled)\n\t\treturn;\n\tif (!myri10ge_dca) {\n\t\tdev_err(&pdev->dev, \"dca disabled by administrator\\n\");\n\t\treturn;\n\t}\n\terr = dca_add_requester(&pdev->dev);\n\tif (err) {\n\t\tif (err != -ENODEV)\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"dca_add_requester() failed, err=%d\\n\", err);\n\t\treturn;\n\t}\n\tmgp->relaxed_order = myri10ge_toggle_relaxed(pdev, 0);\n\tmgp->dca_enabled = 1;\n\tfor (i = 0; i < mgp->num_slices; i++) {\n\t\tmgp->ss[i].cpu = -1;\n\t\tmgp->ss[i].cached_dca_tag = -1;\n\t\tmyri10ge_update_dca(&mgp->ss[i]);\n\t}\n}\n\nstatic void myri10ge_teardown_dca(struct myri10ge_priv *mgp)\n{\n\tstruct pci_dev *pdev = mgp->pdev;\n\n\tif (!mgp->dca_enabled)\n\t\treturn;\n\tmgp->dca_enabled = 0;\n\tif (mgp->relaxed_order)\n\t\tmyri10ge_toggle_relaxed(pdev, 1);\n\tdca_remove_requester(&pdev->dev);\n}\n\nstatic int myri10ge_notify_dca_device(struct device *dev, void *data)\n{\n\tstruct myri10ge_priv *mgp;\n\tunsigned long event;\n\n\tmgp = dev_get_drvdata(dev);\n\tevent = *(unsigned long *)data;\n\n\tif (event == DCA_PROVIDER_ADD)\n\t\tmyri10ge_setup_dca(mgp);\n\telse if (event == DCA_PROVIDER_REMOVE)\n\t\tmyri10ge_teardown_dca(mgp);\n\treturn 0;\n}\n#endif\t\t\t\t \n\nstatic inline void\nmyri10ge_submit_8rx(struct mcp_kreq_ether_recv __iomem * dst,\n\t\t    struct mcp_kreq_ether_recv *src)\n{\n\t__be32 low;\n\n\tlow = src->addr_low;\n\tsrc->addr_low = htonl(DMA_BIT_MASK(32));\n\tmyri10ge_pio_copy(dst, src, 4 * sizeof(*src));\n\tmb();\n\tmyri10ge_pio_copy(dst + 4, src + 4, 4 * sizeof(*src));\n\tmb();\n\tsrc->addr_low = low;\n\tput_be32(low, &dst->addr_low);\n\tmb();\n}\n\nstatic void\nmyri10ge_alloc_rx_pages(struct myri10ge_priv *mgp, struct myri10ge_rx_buf *rx,\n\t\t\tint bytes, int watchdog)\n{\n\tstruct page *page;\n\tdma_addr_t bus;\n\tint idx;\n#if MYRI10GE_ALLOC_SIZE > 4096\n\tint end_offset;\n#endif\n\n\tif (unlikely(rx->watchdog_needed && !watchdog))\n\t\treturn;\n\n\t \n\twhile (rx->fill_cnt != (rx->cnt + rx->mask + 1)) {\n\t\tidx = rx->fill_cnt & rx->mask;\n\t\tif (rx->page_offset + bytes <= MYRI10GE_ALLOC_SIZE) {\n\t\t\t \n\t\t\tget_page(rx->page);\n\t\t} else {\n\t\t\t \n\t\t\tpage =\n\t\t\t    alloc_pages(GFP_ATOMIC | __GFP_COMP,\n\t\t\t\t\tMYRI10GE_ALLOC_ORDER);\n\t\t\tif (unlikely(page == NULL)) {\n\t\t\t\tif (rx->fill_cnt - rx->cnt < 16)\n\t\t\t\t\trx->watchdog_needed = 1;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tbus = dma_map_page(&mgp->pdev->dev, page, 0,\n\t\t\t\t\t   MYRI10GE_ALLOC_SIZE,\n\t\t\t\t\t   DMA_FROM_DEVICE);\n\t\t\tif (unlikely(dma_mapping_error(&mgp->pdev->dev, bus))) {\n\t\t\t\t__free_pages(page, MYRI10GE_ALLOC_ORDER);\n\t\t\t\tif (rx->fill_cnt - rx->cnt < 16)\n\t\t\t\t\trx->watchdog_needed = 1;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\trx->page = page;\n\t\t\trx->page_offset = 0;\n\t\t\trx->bus = bus;\n\n\t\t}\n\t\trx->info[idx].page = rx->page;\n\t\trx->info[idx].page_offset = rx->page_offset;\n\t\t \n\t\tdma_unmap_addr_set(&rx->info[idx], bus, rx->bus);\n\t\trx->shadow[idx].addr_low =\n\t\t    htonl(MYRI10GE_LOWPART_TO_U32(rx->bus) + rx->page_offset);\n\t\trx->shadow[idx].addr_high =\n\t\t    htonl(MYRI10GE_HIGHPART_TO_U32(rx->bus));\n\n\t\t \n\t\trx->page_offset += SKB_DATA_ALIGN(bytes);\n\n#if MYRI10GE_ALLOC_SIZE > 4096\n\t\t \n\t\tend_offset = rx->page_offset + bytes - 1;\n\t\tif ((unsigned)(rx->page_offset ^ end_offset) > 4095)\n\t\t\trx->page_offset = end_offset & ~4095;\n#endif\n\t\trx->fill_cnt++;\n\n\t\t \n\t\tif ((idx & 7) == 7) {\n\t\t\tmyri10ge_submit_8rx(&rx->lanai[idx - 7],\n\t\t\t\t\t    &rx->shadow[idx - 7]);\n\t\t}\n\t}\n}\n\nstatic inline void\nmyri10ge_unmap_rx_page(struct pci_dev *pdev,\n\t\t       struct myri10ge_rx_buffer_state *info, int bytes)\n{\n\t \n\tif (bytes >= MYRI10GE_ALLOC_SIZE / 2 ||\n\t    (info->page_offset + 2 * bytes) > MYRI10GE_ALLOC_SIZE) {\n\t\tdma_unmap_page(&pdev->dev, (dma_unmap_addr(info, bus)\n\t\t\t\t\t    & ~(MYRI10GE_ALLOC_SIZE - 1)),\n\t\t\t       MYRI10GE_ALLOC_SIZE, DMA_FROM_DEVICE);\n\t}\n}\n\n \n\nstatic inline void\nmyri10ge_vlan_rx(struct net_device *dev, void *addr, struct sk_buff *skb)\n{\n\tu8 *va;\n\tstruct vlan_ethhdr *veh;\n\tskb_frag_t *frag;\n\t__wsum vsum;\n\n\tva = addr;\n\tva += MXGEFW_PAD;\n\tveh = (struct vlan_ethhdr *)va;\n\tif ((dev->features & NETIF_F_HW_VLAN_CTAG_RX) ==\n\t    NETIF_F_HW_VLAN_CTAG_RX &&\n\t    veh->h_vlan_proto == htons(ETH_P_8021Q)) {\n\t\t \n\t\tif (skb->ip_summed == CHECKSUM_COMPLETE) {\n\t\t\tvsum = csum_partial(va + ETH_HLEN, VLAN_HLEN, 0);\n\t\t\tskb->csum = csum_sub(skb->csum, vsum);\n\t\t}\n\t\t \n\t\t__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q), ntohs(veh->h_vlan_TCI));\n\t\tmemmove(va + VLAN_HLEN, va, 2 * ETH_ALEN);\n\t\tskb->len -= VLAN_HLEN;\n\t\tskb->data_len -= VLAN_HLEN;\n\t\tfrag = skb_shinfo(skb)->frags;\n\t\tskb_frag_off_add(frag, VLAN_HLEN);\n\t\tskb_frag_size_sub(frag, VLAN_HLEN);\n\t}\n}\n\n#define MYRI10GE_HLEN 64  \n\nstatic inline int\nmyri10ge_rx_done(struct myri10ge_slice_state *ss, int len, __wsum csum)\n{\n\tstruct myri10ge_priv *mgp = ss->mgp;\n\tstruct sk_buff *skb;\n\tskb_frag_t *rx_frags;\n\tstruct myri10ge_rx_buf *rx;\n\tint i, idx, remainder, bytes;\n\tstruct pci_dev *pdev = mgp->pdev;\n\tstruct net_device *dev = mgp->dev;\n\tu8 *va;\n\n\tif (len <= mgp->small_bytes) {\n\t\trx = &ss->rx_small;\n\t\tbytes = mgp->small_bytes;\n\t} else {\n\t\trx = &ss->rx_big;\n\t\tbytes = mgp->big_bytes;\n\t}\n\n\tlen += MXGEFW_PAD;\n\tidx = rx->cnt & rx->mask;\n\tva = page_address(rx->info[idx].page) + rx->info[idx].page_offset;\n\tprefetch(va);\n\n\tskb = napi_get_frags(&ss->napi);\n\tif (unlikely(skb == NULL)) {\n\t\tss->stats.rx_dropped++;\n\t\tfor (i = 0, remainder = len; remainder > 0; i++) {\n\t\t\tmyri10ge_unmap_rx_page(pdev, &rx->info[idx], bytes);\n\t\t\tput_page(rx->info[idx].page);\n\t\t\trx->cnt++;\n\t\t\tidx = rx->cnt & rx->mask;\n\t\t\tremainder -= MYRI10GE_ALLOC_SIZE;\n\t\t}\n\t\treturn 0;\n\t}\n\trx_frags = skb_shinfo(skb)->frags;\n\t \n\tfor (i = 0, remainder = len; remainder > 0; i++) {\n\t\tmyri10ge_unmap_rx_page(pdev, &rx->info[idx], bytes);\n\t\tskb_fill_page_desc(skb, i, rx->info[idx].page,\n\t\t\t\t   rx->info[idx].page_offset,\n\t\t\t\t   remainder < MYRI10GE_ALLOC_SIZE ?\n\t\t\t\t   remainder : MYRI10GE_ALLOC_SIZE);\n\t\trx->cnt++;\n\t\tidx = rx->cnt & rx->mask;\n\t\tremainder -= MYRI10GE_ALLOC_SIZE;\n\t}\n\n\t \n\tskb_frag_off_add(&rx_frags[0], MXGEFW_PAD);\n\tskb_frag_size_sub(&rx_frags[0], MXGEFW_PAD);\n\tlen -= MXGEFW_PAD;\n\n\tskb->len = len;\n\tskb->data_len = len;\n\tskb->truesize += len;\n\tif (dev->features & NETIF_F_RXCSUM) {\n\t\tskb->ip_summed = CHECKSUM_COMPLETE;\n\t\tskb->csum = csum;\n\t}\n\tmyri10ge_vlan_rx(mgp->dev, va, skb);\n\tskb_record_rx_queue(skb, ss - &mgp->ss[0]);\n\n\tnapi_gro_frags(&ss->napi);\n\n\treturn 1;\n}\n\nstatic inline void\nmyri10ge_tx_done(struct myri10ge_slice_state *ss, int mcp_index)\n{\n\tstruct pci_dev *pdev = ss->mgp->pdev;\n\tstruct myri10ge_tx_buf *tx = &ss->tx;\n\tstruct netdev_queue *dev_queue;\n\tstruct sk_buff *skb;\n\tint idx, len;\n\n\twhile (tx->pkt_done != mcp_index) {\n\t\tidx = tx->done & tx->mask;\n\t\tskb = tx->info[idx].skb;\n\n\t\t \n\t\ttx->info[idx].skb = NULL;\n\t\tif (tx->info[idx].last) {\n\t\t\ttx->pkt_done++;\n\t\t\ttx->info[idx].last = 0;\n\t\t}\n\t\ttx->done++;\n\t\tlen = dma_unmap_len(&tx->info[idx], len);\n\t\tdma_unmap_len_set(&tx->info[idx], len, 0);\n\t\tif (skb) {\n\t\t\tss->stats.tx_bytes += skb->len;\n\t\t\tss->stats.tx_packets++;\n\t\t\tdev_consume_skb_irq(skb);\n\t\t\tif (len)\n\t\t\t\tdma_unmap_single(&pdev->dev,\n\t\t\t\t\t\t dma_unmap_addr(&tx->info[idx],\n\t\t\t\t\t\t\t\tbus), len,\n\t\t\t\t\t\t DMA_TO_DEVICE);\n\t\t} else {\n\t\t\tif (len)\n\t\t\t\tdma_unmap_page(&pdev->dev,\n\t\t\t\t\t       dma_unmap_addr(&tx->info[idx],\n\t\t\t\t\t\t\t      bus), len,\n\t\t\t\t\t       DMA_TO_DEVICE);\n\t\t}\n\t}\n\n\tdev_queue = netdev_get_tx_queue(ss->dev, ss - ss->mgp->ss);\n\t \n\n\tif ((ss->mgp->dev->real_num_tx_queues > 1) &&\n\t    __netif_tx_trylock(dev_queue)) {\n\t\tif (tx->req == tx->done) {\n\t\t\ttx->queue_active = 0;\n\t\t\tput_be32(htonl(1), tx->send_stop);\n\t\t\tmb();\n\t\t}\n\t\t__netif_tx_unlock(dev_queue);\n\t}\n\n\t \n\tif (netif_tx_queue_stopped(dev_queue) &&\n\t    tx->req - tx->done < (tx->mask >> 1) &&\n\t    ss->mgp->running == MYRI10GE_ETH_RUNNING) {\n\t\ttx->wake_queue++;\n\t\tnetif_tx_wake_queue(dev_queue);\n\t}\n}\n\nstatic inline int\nmyri10ge_clean_rx_done(struct myri10ge_slice_state *ss, int budget)\n{\n\tstruct myri10ge_rx_done *rx_done = &ss->rx_done;\n\tstruct myri10ge_priv *mgp = ss->mgp;\n\tunsigned long rx_bytes = 0;\n\tunsigned long rx_packets = 0;\n\tunsigned long rx_ok;\n\tint idx = rx_done->idx;\n\tint cnt = rx_done->cnt;\n\tint work_done = 0;\n\tu16 length;\n\t__wsum checksum;\n\n\twhile (rx_done->entry[idx].length != 0 && work_done < budget) {\n\t\tlength = ntohs(rx_done->entry[idx].length);\n\t\trx_done->entry[idx].length = 0;\n\t\tchecksum = csum_unfold(rx_done->entry[idx].checksum);\n\t\trx_ok = myri10ge_rx_done(ss, length, checksum);\n\t\trx_packets += rx_ok;\n\t\trx_bytes += rx_ok * (unsigned long)length;\n\t\tcnt++;\n\t\tidx = cnt & (mgp->max_intr_slots - 1);\n\t\twork_done++;\n\t}\n\trx_done->idx = idx;\n\trx_done->cnt = cnt;\n\tss->stats.rx_packets += rx_packets;\n\tss->stats.rx_bytes += rx_bytes;\n\n\t \n\tif (ss->rx_small.fill_cnt - ss->rx_small.cnt < myri10ge_fill_thresh)\n\t\tmyri10ge_alloc_rx_pages(mgp, &ss->rx_small,\n\t\t\t\t\tmgp->small_bytes + MXGEFW_PAD, 0);\n\tif (ss->rx_big.fill_cnt - ss->rx_big.cnt < myri10ge_fill_thresh)\n\t\tmyri10ge_alloc_rx_pages(mgp, &ss->rx_big, mgp->big_bytes, 0);\n\n\treturn work_done;\n}\n\nstatic inline void myri10ge_check_statblock(struct myri10ge_priv *mgp)\n{\n\tstruct mcp_irq_data *stats = mgp->ss[0].fw_stats;\n\n\tif (unlikely(stats->stats_updated)) {\n\t\tunsigned link_up = ntohl(stats->link_up);\n\t\tif (mgp->link_state != link_up) {\n\t\t\tmgp->link_state = link_up;\n\n\t\t\tif (mgp->link_state == MXGEFW_LINK_UP) {\n\t\t\t\tnetif_info(mgp, link, mgp->dev, \"link up\\n\");\n\t\t\t\tnetif_carrier_on(mgp->dev);\n\t\t\t\tmgp->link_changes++;\n\t\t\t} else {\n\t\t\t\tnetif_info(mgp, link, mgp->dev, \"link %s\\n\",\n\t\t\t\t\t   (link_up == MXGEFW_LINK_MYRINET ?\n\t\t\t\t\t    \"mismatch (Myrinet detected)\" :\n\t\t\t\t\t    \"down\"));\n\t\t\t\tnetif_carrier_off(mgp->dev);\n\t\t\t\tmgp->link_changes++;\n\t\t\t}\n\t\t}\n\t\tif (mgp->rdma_tags_available !=\n\t\t    ntohl(stats->rdma_tags_available)) {\n\t\t\tmgp->rdma_tags_available =\n\t\t\t    ntohl(stats->rdma_tags_available);\n\t\t\tnetdev_warn(mgp->dev, \"RDMA timed out! %d tags left\\n\",\n\t\t\t\t    mgp->rdma_tags_available);\n\t\t}\n\t\tmgp->down_cnt += stats->link_down;\n\t\tif (stats->link_down)\n\t\t\twake_up(&mgp->down_wq);\n\t}\n}\n\nstatic int myri10ge_poll(struct napi_struct *napi, int budget)\n{\n\tstruct myri10ge_slice_state *ss =\n\t    container_of(napi, struct myri10ge_slice_state, napi);\n\tint work_done;\n\n#ifdef CONFIG_MYRI10GE_DCA\n\tif (ss->mgp->dca_enabled)\n\t\tmyri10ge_update_dca(ss);\n#endif\n\t \n\twork_done = myri10ge_clean_rx_done(ss, budget);\n\n\tif (work_done < budget) {\n\t\tnapi_complete_done(napi, work_done);\n\t\tput_be32(htonl(3), ss->irq_claim);\n\t}\n\treturn work_done;\n}\n\nstatic irqreturn_t myri10ge_intr(int irq, void *arg)\n{\n\tstruct myri10ge_slice_state *ss = arg;\n\tstruct myri10ge_priv *mgp = ss->mgp;\n\tstruct mcp_irq_data *stats = ss->fw_stats;\n\tstruct myri10ge_tx_buf *tx = &ss->tx;\n\tu32 send_done_count;\n\tint i;\n\n\t \n\tif ((mgp->dev->real_num_tx_queues == 1) && (ss != mgp->ss)) {\n\t\tnapi_schedule(&ss->napi);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\t \n\tif (unlikely(!stats->valid))\n\t\treturn IRQ_NONE;\n\n\t \n\tif (stats->valid & 1)\n\t\tnapi_schedule(&ss->napi);\n\n\tif (!mgp->msi_enabled && !mgp->msix_enabled) {\n\t\tput_be32(0, mgp->irq_deassert);\n\t\tif (!myri10ge_deassert_wait)\n\t\t\tstats->valid = 0;\n\t\tmb();\n\t} else\n\t\tstats->valid = 0;\n\n\t \n\ti = 0;\n\twhile (1) {\n\t\ti++;\n\t\t \n\t\tsend_done_count = ntohl(stats->send_done_count);\n\t\tif (send_done_count != tx->pkt_done)\n\t\t\tmyri10ge_tx_done(ss, (int)send_done_count);\n\t\tif (unlikely(i > myri10ge_max_irq_loops)) {\n\t\t\tnetdev_warn(mgp->dev, \"irq stuck?\\n\");\n\t\t\tstats->valid = 0;\n\t\t\tschedule_work(&mgp->watchdog_work);\n\t\t}\n\t\tif (likely(stats->valid == 0))\n\t\t\tbreak;\n\t\tcpu_relax();\n\t\tbarrier();\n\t}\n\n\t \n\tif (ss == mgp->ss)\n\t\tmyri10ge_check_statblock(mgp);\n\n\tput_be32(htonl(3), ss->irq_claim + 1);\n\treturn IRQ_HANDLED;\n}\n\nstatic int\nmyri10ge_get_link_ksettings(struct net_device *netdev,\n\t\t\t    struct ethtool_link_ksettings *cmd)\n{\n\tstruct myri10ge_priv *mgp = netdev_priv(netdev);\n\tchar *ptr;\n\tint i;\n\n\tcmd->base.autoneg = AUTONEG_DISABLE;\n\tcmd->base.speed = SPEED_10000;\n\tcmd->base.duplex = DUPLEX_FULL;\n\n\t \n\tptr = mgp->product_code_string;\n\tif (ptr == NULL) {\n\t\tnetdev_err(netdev, \"Missing product code\\n\");\n\t\treturn 0;\n\t}\n\tfor (i = 0; i < 3; i++, ptr++) {\n\t\tptr = strchr(ptr, '-');\n\t\tif (ptr == NULL) {\n\t\t\tnetdev_err(netdev, \"Invalid product code %s\\n\",\n\t\t\t\t   mgp->product_code_string);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (*ptr == '2')\n\t\tptr++;\n\tif (*ptr == 'R' || *ptr == 'Q' || *ptr == 'S') {\n\t\t \n\t\tcmd->base.port = PORT_FIBRE;\n\t\tethtool_link_ksettings_add_link_mode(cmd, supported, FIBRE);\n\t\tethtool_link_ksettings_add_link_mode(cmd, advertising, FIBRE);\n\t} else {\n\t\tcmd->base.port = PORT_OTHER;\n\t}\n\n\treturn 0;\n}\n\nstatic void\nmyri10ge_get_drvinfo(struct net_device *netdev, struct ethtool_drvinfo *info)\n{\n\tstruct myri10ge_priv *mgp = netdev_priv(netdev);\n\n\tstrscpy(info->driver, \"myri10ge\", sizeof(info->driver));\n\tstrscpy(info->version, MYRI10GE_VERSION_STR, sizeof(info->version));\n\tstrscpy(info->fw_version, mgp->fw_version, sizeof(info->fw_version));\n\tstrscpy(info->bus_info, pci_name(mgp->pdev), sizeof(info->bus_info));\n}\n\nstatic int myri10ge_get_coalesce(struct net_device *netdev,\n\t\t\t\t struct ethtool_coalesce *coal,\n\t\t\t\t struct kernel_ethtool_coalesce *kernel_coal,\n\t\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct myri10ge_priv *mgp = netdev_priv(netdev);\n\n\tcoal->rx_coalesce_usecs = mgp->intr_coal_delay;\n\treturn 0;\n}\n\nstatic int myri10ge_set_coalesce(struct net_device *netdev,\n\t\t\t\t struct ethtool_coalesce *coal,\n\t\t\t\t struct kernel_ethtool_coalesce *kernel_coal,\n\t\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct myri10ge_priv *mgp = netdev_priv(netdev);\n\n\tmgp->intr_coal_delay = coal->rx_coalesce_usecs;\n\tput_be32(htonl(mgp->intr_coal_delay), mgp->intr_coal_delay_ptr);\n\treturn 0;\n}\n\nstatic void\nmyri10ge_get_pauseparam(struct net_device *netdev,\n\t\t\tstruct ethtool_pauseparam *pause)\n{\n\tstruct myri10ge_priv *mgp = netdev_priv(netdev);\n\n\tpause->autoneg = 0;\n\tpause->rx_pause = mgp->pause;\n\tpause->tx_pause = mgp->pause;\n}\n\nstatic int\nmyri10ge_set_pauseparam(struct net_device *netdev,\n\t\t\tstruct ethtool_pauseparam *pause)\n{\n\tstruct myri10ge_priv *mgp = netdev_priv(netdev);\n\n\tif (pause->tx_pause != mgp->pause)\n\t\treturn myri10ge_change_pause(mgp, pause->tx_pause);\n\tif (pause->rx_pause != mgp->pause)\n\t\treturn myri10ge_change_pause(mgp, pause->rx_pause);\n\tif (pause->autoneg != 0)\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic void\nmyri10ge_get_ringparam(struct net_device *netdev,\n\t\t       struct ethtool_ringparam *ring,\n\t\t       struct kernel_ethtool_ringparam *kernel_ring,\n\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct myri10ge_priv *mgp = netdev_priv(netdev);\n\n\tring->rx_mini_max_pending = mgp->ss[0].rx_small.mask + 1;\n\tring->rx_max_pending = mgp->ss[0].rx_big.mask + 1;\n\tring->rx_jumbo_max_pending = 0;\n\tring->tx_max_pending = mgp->ss[0].tx.mask + 1;\n\tring->rx_mini_pending = ring->rx_mini_max_pending;\n\tring->rx_pending = ring->rx_max_pending;\n\tring->rx_jumbo_pending = ring->rx_jumbo_max_pending;\n\tring->tx_pending = ring->tx_max_pending;\n}\n\nstatic const char myri10ge_gstrings_main_stats[][ETH_GSTRING_LEN] = {\n\t\"rx_packets\", \"tx_packets\", \"rx_bytes\", \"tx_bytes\", \"rx_errors\",\n\t\"tx_errors\", \"rx_dropped\", \"tx_dropped\", \"multicast\", \"collisions\",\n\t\"rx_length_errors\", \"rx_over_errors\", \"rx_crc_errors\",\n\t\"rx_frame_errors\", \"rx_fifo_errors\", \"rx_missed_errors\",\n\t\"tx_aborted_errors\", \"tx_carrier_errors\", \"tx_fifo_errors\",\n\t\"tx_heartbeat_errors\", \"tx_window_errors\",\n\t \n\t\"tx_boundary\", \"irq\", \"MSI\", \"MSIX\",\n\t\"read_dma_bw_MBs\", \"write_dma_bw_MBs\", \"read_write_dma_bw_MBs\",\n\t\"serial_number\", \"watchdog_resets\",\n#ifdef CONFIG_MYRI10GE_DCA\n\t\"dca_capable_firmware\", \"dca_device_present\",\n#endif\n\t\"link_changes\", \"link_up\", \"dropped_link_overflow\",\n\t\"dropped_link_error_or_filtered\",\n\t\"dropped_pause\", \"dropped_bad_phy\", \"dropped_bad_crc32\",\n\t\"dropped_unicast_filtered\", \"dropped_multicast_filtered\",\n\t\"dropped_runt\", \"dropped_overrun\", \"dropped_no_small_buffer\",\n\t\"dropped_no_big_buffer\"\n};\n\nstatic const char myri10ge_gstrings_slice_stats[][ETH_GSTRING_LEN] = {\n\t\"----------- slice ---------\",\n\t\"tx_pkt_start\", \"tx_pkt_done\", \"tx_req\", \"tx_done\",\n\t\"rx_small_cnt\", \"rx_big_cnt\",\n\t\"wake_queue\", \"stop_queue\", \"tx_linearized\",\n};\n\n#define MYRI10GE_NET_STATS_LEN      21\n#define MYRI10GE_MAIN_STATS_LEN  ARRAY_SIZE(myri10ge_gstrings_main_stats)\n#define MYRI10GE_SLICE_STATS_LEN  ARRAY_SIZE(myri10ge_gstrings_slice_stats)\n\nstatic void\nmyri10ge_get_strings(struct net_device *netdev, u32 stringset, u8 * data)\n{\n\tstruct myri10ge_priv *mgp = netdev_priv(netdev);\n\tint i;\n\n\tswitch (stringset) {\n\tcase ETH_SS_STATS:\n\t\tmemcpy(data, *myri10ge_gstrings_main_stats,\n\t\t       sizeof(myri10ge_gstrings_main_stats));\n\t\tdata += sizeof(myri10ge_gstrings_main_stats);\n\t\tfor (i = 0; i < mgp->num_slices; i++) {\n\t\t\tmemcpy(data, *myri10ge_gstrings_slice_stats,\n\t\t\t       sizeof(myri10ge_gstrings_slice_stats));\n\t\t\tdata += sizeof(myri10ge_gstrings_slice_stats);\n\t\t}\n\t\tbreak;\n\t}\n}\n\nstatic int myri10ge_get_sset_count(struct net_device *netdev, int sset)\n{\n\tstruct myri10ge_priv *mgp = netdev_priv(netdev);\n\n\tswitch (sset) {\n\tcase ETH_SS_STATS:\n\t\treturn MYRI10GE_MAIN_STATS_LEN +\n\t\t    mgp->num_slices * MYRI10GE_SLICE_STATS_LEN;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic void\nmyri10ge_get_ethtool_stats(struct net_device *netdev,\n\t\t\t   struct ethtool_stats *stats, u64 * data)\n{\n\tstruct myri10ge_priv *mgp = netdev_priv(netdev);\n\tstruct myri10ge_slice_state *ss;\n\tstruct rtnl_link_stats64 link_stats;\n\tint slice;\n\tint i;\n\n\t \n\tmemset(&link_stats, 0, sizeof(link_stats));\n\t(void)myri10ge_get_stats(netdev, &link_stats);\n\tfor (i = 0; i < MYRI10GE_NET_STATS_LEN; i++)\n\t\tdata[i] = ((u64 *)&link_stats)[i];\n\n\tdata[i++] = (unsigned int)mgp->tx_boundary;\n\tdata[i++] = (unsigned int)mgp->pdev->irq;\n\tdata[i++] = (unsigned int)mgp->msi_enabled;\n\tdata[i++] = (unsigned int)mgp->msix_enabled;\n\tdata[i++] = (unsigned int)mgp->read_dma;\n\tdata[i++] = (unsigned int)mgp->write_dma;\n\tdata[i++] = (unsigned int)mgp->read_write_dma;\n\tdata[i++] = (unsigned int)mgp->serial_number;\n\tdata[i++] = (unsigned int)mgp->watchdog_resets;\n#ifdef CONFIG_MYRI10GE_DCA\n\tdata[i++] = (unsigned int)(mgp->ss[0].dca_tag != NULL);\n\tdata[i++] = (unsigned int)(mgp->dca_enabled);\n#endif\n\tdata[i++] = (unsigned int)mgp->link_changes;\n\n\t \n\tss = &mgp->ss[0];\n\tdata[i++] = (unsigned int)ntohl(ss->fw_stats->link_up);\n\tdata[i++] = (unsigned int)ntohl(ss->fw_stats->dropped_link_overflow);\n\tdata[i++] =\n\t    (unsigned int)ntohl(ss->fw_stats->dropped_link_error_or_filtered);\n\tdata[i++] = (unsigned int)ntohl(ss->fw_stats->dropped_pause);\n\tdata[i++] = (unsigned int)ntohl(ss->fw_stats->dropped_bad_phy);\n\tdata[i++] = (unsigned int)ntohl(ss->fw_stats->dropped_bad_crc32);\n\tdata[i++] = (unsigned int)ntohl(ss->fw_stats->dropped_unicast_filtered);\n\tdata[i++] =\n\t    (unsigned int)ntohl(ss->fw_stats->dropped_multicast_filtered);\n\tdata[i++] = (unsigned int)ntohl(ss->fw_stats->dropped_runt);\n\tdata[i++] = (unsigned int)ntohl(ss->fw_stats->dropped_overrun);\n\tdata[i++] = (unsigned int)ntohl(ss->fw_stats->dropped_no_small_buffer);\n\tdata[i++] = (unsigned int)ntohl(ss->fw_stats->dropped_no_big_buffer);\n\n\tfor (slice = 0; slice < mgp->num_slices; slice++) {\n\t\tss = &mgp->ss[slice];\n\t\tdata[i++] = slice;\n\t\tdata[i++] = (unsigned int)ss->tx.pkt_start;\n\t\tdata[i++] = (unsigned int)ss->tx.pkt_done;\n\t\tdata[i++] = (unsigned int)ss->tx.req;\n\t\tdata[i++] = (unsigned int)ss->tx.done;\n\t\tdata[i++] = (unsigned int)ss->rx_small.cnt;\n\t\tdata[i++] = (unsigned int)ss->rx_big.cnt;\n\t\tdata[i++] = (unsigned int)ss->tx.wake_queue;\n\t\tdata[i++] = (unsigned int)ss->tx.stop_queue;\n\t\tdata[i++] = (unsigned int)ss->tx.linearized;\n\t}\n}\n\nstatic void myri10ge_set_msglevel(struct net_device *netdev, u32 value)\n{\n\tstruct myri10ge_priv *mgp = netdev_priv(netdev);\n\tmgp->msg_enable = value;\n}\n\nstatic u32 myri10ge_get_msglevel(struct net_device *netdev)\n{\n\tstruct myri10ge_priv *mgp = netdev_priv(netdev);\n\treturn mgp->msg_enable;\n}\n\n \nstatic int myri10ge_led(struct myri10ge_priv *mgp, int on)\n{\n\tstruct mcp_gen_header *hdr;\n\tstruct device *dev = &mgp->pdev->dev;\n\tsize_t hdr_off, pattern_off, hdr_len;\n\tu32 pattern = 0xfffffffe;\n\n\t \n\thdr_off = swab32(readl(mgp->sram + MCP_HEADER_PTR_OFFSET));\n\tif ((hdr_off & 3) || hdr_off + sizeof(*hdr) > mgp->sram_size) {\n\t\tdev_err(dev, \"Running firmware has bad header offset (%d)\\n\",\n\t\t\t(int)hdr_off);\n\t\treturn -EIO;\n\t}\n\thdr_len = swab32(readl(mgp->sram + hdr_off +\n\t\t\t       offsetof(struct mcp_gen_header, header_length)));\n\tpattern_off = hdr_off + offsetof(struct mcp_gen_header, led_pattern);\n\tif (pattern_off >= (hdr_len + hdr_off)) {\n\t\tdev_info(dev, \"Firmware does not support LED identification\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (!on)\n\t\tpattern = swab32(readl(mgp->sram + pattern_off + 4));\n\twritel(swab32(pattern), mgp->sram + pattern_off);\n\treturn 0;\n}\n\nstatic int\nmyri10ge_phys_id(struct net_device *netdev, enum ethtool_phys_id_state state)\n{\n\tstruct myri10ge_priv *mgp = netdev_priv(netdev);\n\tint rc;\n\n\tswitch (state) {\n\tcase ETHTOOL_ID_ACTIVE:\n\t\trc = myri10ge_led(mgp, 1);\n\t\tbreak;\n\n\tcase ETHTOOL_ID_INACTIVE:\n\t\trc =  myri10ge_led(mgp, 0);\n\t\tbreak;\n\n\tdefault:\n\t\trc = -EINVAL;\n\t}\n\n\treturn rc;\n}\n\nstatic const struct ethtool_ops myri10ge_ethtool_ops = {\n\t.supported_coalesce_params = ETHTOOL_COALESCE_RX_USECS,\n\t.get_drvinfo = myri10ge_get_drvinfo,\n\t.get_coalesce = myri10ge_get_coalesce,\n\t.set_coalesce = myri10ge_set_coalesce,\n\t.get_pauseparam = myri10ge_get_pauseparam,\n\t.set_pauseparam = myri10ge_set_pauseparam,\n\t.get_ringparam = myri10ge_get_ringparam,\n\t.get_link = ethtool_op_get_link,\n\t.get_strings = myri10ge_get_strings,\n\t.get_sset_count = myri10ge_get_sset_count,\n\t.get_ethtool_stats = myri10ge_get_ethtool_stats,\n\t.set_msglevel = myri10ge_set_msglevel,\n\t.get_msglevel = myri10ge_get_msglevel,\n\t.set_phys_id = myri10ge_phys_id,\n\t.get_link_ksettings = myri10ge_get_link_ksettings,\n};\n\nstatic int myri10ge_allocate_rings(struct myri10ge_slice_state *ss)\n{\n\tstruct myri10ge_priv *mgp = ss->mgp;\n\tstruct myri10ge_cmd cmd;\n\tstruct net_device *dev = mgp->dev;\n\tint tx_ring_size, rx_ring_size;\n\tint tx_ring_entries, rx_ring_entries;\n\tint i, slice, status;\n\tsize_t bytes;\n\n\t \n\tslice = ss - mgp->ss;\n\tcmd.data0 = slice;\n\tstatus = myri10ge_send_cmd(mgp, MXGEFW_CMD_GET_SEND_RING_SIZE, &cmd, 0);\n\ttx_ring_size = cmd.data0;\n\tcmd.data0 = slice;\n\tstatus |= myri10ge_send_cmd(mgp, MXGEFW_CMD_GET_RX_RING_SIZE, &cmd, 0);\n\tif (status != 0)\n\t\treturn status;\n\trx_ring_size = cmd.data0;\n\n\ttx_ring_entries = tx_ring_size / sizeof(struct mcp_kreq_ether_send);\n\trx_ring_entries = rx_ring_size / sizeof(struct mcp_dma_addr);\n\tss->tx.mask = tx_ring_entries - 1;\n\tss->rx_small.mask = ss->rx_big.mask = rx_ring_entries - 1;\n\n\tstatus = -ENOMEM;\n\n\t \n\n\tbytes = 8 + (MYRI10GE_MAX_SEND_DESC_TSO + 4)\n\t    * sizeof(*ss->tx.req_list);\n\tss->tx.req_bytes = kzalloc(bytes, GFP_KERNEL);\n\tif (ss->tx.req_bytes == NULL)\n\t\tgoto abort_with_nothing;\n\n\t \n\tss->tx.req_list = (struct mcp_kreq_ether_send *)\n\t    ALIGN((unsigned long)ss->tx.req_bytes, 8);\n\tss->tx.queue_active = 0;\n\n\tbytes = rx_ring_entries * sizeof(*ss->rx_small.shadow);\n\tss->rx_small.shadow = kzalloc(bytes, GFP_KERNEL);\n\tif (ss->rx_small.shadow == NULL)\n\t\tgoto abort_with_tx_req_bytes;\n\n\tbytes = rx_ring_entries * sizeof(*ss->rx_big.shadow);\n\tss->rx_big.shadow = kzalloc(bytes, GFP_KERNEL);\n\tif (ss->rx_big.shadow == NULL)\n\t\tgoto abort_with_rx_small_shadow;\n\n\t \n\n\tbytes = tx_ring_entries * sizeof(*ss->tx.info);\n\tss->tx.info = kzalloc(bytes, GFP_KERNEL);\n\tif (ss->tx.info == NULL)\n\t\tgoto abort_with_rx_big_shadow;\n\n\tbytes = rx_ring_entries * sizeof(*ss->rx_small.info);\n\tss->rx_small.info = kzalloc(bytes, GFP_KERNEL);\n\tif (ss->rx_small.info == NULL)\n\t\tgoto abort_with_tx_info;\n\n\tbytes = rx_ring_entries * sizeof(*ss->rx_big.info);\n\tss->rx_big.info = kzalloc(bytes, GFP_KERNEL);\n\tif (ss->rx_big.info == NULL)\n\t\tgoto abort_with_rx_small_info;\n\n\t \n\tss->rx_big.cnt = 0;\n\tss->rx_small.cnt = 0;\n\tss->rx_big.fill_cnt = 0;\n\tss->rx_small.fill_cnt = 0;\n\tss->rx_small.page_offset = MYRI10GE_ALLOC_SIZE;\n\tss->rx_big.page_offset = MYRI10GE_ALLOC_SIZE;\n\tss->rx_small.watchdog_needed = 0;\n\tss->rx_big.watchdog_needed = 0;\n\tif (mgp->small_bytes == 0) {\n\t\tss->rx_small.fill_cnt = ss->rx_small.mask + 1;\n\t} else {\n\t\tmyri10ge_alloc_rx_pages(mgp, &ss->rx_small,\n\t\t\t\t\tmgp->small_bytes + MXGEFW_PAD, 0);\n\t}\n\n\tif (ss->rx_small.fill_cnt < ss->rx_small.mask + 1) {\n\t\tnetdev_err(dev, \"slice-%d: alloced only %d small bufs\\n\",\n\t\t\t   slice, ss->rx_small.fill_cnt);\n\t\tgoto abort_with_rx_small_ring;\n\t}\n\n\tmyri10ge_alloc_rx_pages(mgp, &ss->rx_big, mgp->big_bytes, 0);\n\tif (ss->rx_big.fill_cnt < ss->rx_big.mask + 1) {\n\t\tnetdev_err(dev, \"slice-%d: alloced only %d big bufs\\n\",\n\t\t\t   slice, ss->rx_big.fill_cnt);\n\t\tgoto abort_with_rx_big_ring;\n\t}\n\n\treturn 0;\n\nabort_with_rx_big_ring:\n\tfor (i = ss->rx_big.cnt; i < ss->rx_big.fill_cnt; i++) {\n\t\tint idx = i & ss->rx_big.mask;\n\t\tmyri10ge_unmap_rx_page(mgp->pdev, &ss->rx_big.info[idx],\n\t\t\t\t       mgp->big_bytes);\n\t\tput_page(ss->rx_big.info[idx].page);\n\t}\n\nabort_with_rx_small_ring:\n\tif (mgp->small_bytes == 0)\n\t\tss->rx_small.fill_cnt = ss->rx_small.cnt;\n\tfor (i = ss->rx_small.cnt; i < ss->rx_small.fill_cnt; i++) {\n\t\tint idx = i & ss->rx_small.mask;\n\t\tmyri10ge_unmap_rx_page(mgp->pdev, &ss->rx_small.info[idx],\n\t\t\t\t       mgp->small_bytes + MXGEFW_PAD);\n\t\tput_page(ss->rx_small.info[idx].page);\n\t}\n\n\tkfree(ss->rx_big.info);\n\nabort_with_rx_small_info:\n\tkfree(ss->rx_small.info);\n\nabort_with_tx_info:\n\tkfree(ss->tx.info);\n\nabort_with_rx_big_shadow:\n\tkfree(ss->rx_big.shadow);\n\nabort_with_rx_small_shadow:\n\tkfree(ss->rx_small.shadow);\n\nabort_with_tx_req_bytes:\n\tkfree(ss->tx.req_bytes);\n\tss->tx.req_bytes = NULL;\n\tss->tx.req_list = NULL;\n\nabort_with_nothing:\n\treturn status;\n}\n\nstatic void myri10ge_free_rings(struct myri10ge_slice_state *ss)\n{\n\tstruct myri10ge_priv *mgp = ss->mgp;\n\tstruct sk_buff *skb;\n\tstruct myri10ge_tx_buf *tx;\n\tint i, len, idx;\n\n\t \n\tif (ss->tx.req_list == NULL)\n\t\treturn;\n\n\tfor (i = ss->rx_big.cnt; i < ss->rx_big.fill_cnt; i++) {\n\t\tidx = i & ss->rx_big.mask;\n\t\tif (i == ss->rx_big.fill_cnt - 1)\n\t\t\tss->rx_big.info[idx].page_offset = MYRI10GE_ALLOC_SIZE;\n\t\tmyri10ge_unmap_rx_page(mgp->pdev, &ss->rx_big.info[idx],\n\t\t\t\t       mgp->big_bytes);\n\t\tput_page(ss->rx_big.info[idx].page);\n\t}\n\n\tif (mgp->small_bytes == 0)\n\t\tss->rx_small.fill_cnt = ss->rx_small.cnt;\n\tfor (i = ss->rx_small.cnt; i < ss->rx_small.fill_cnt; i++) {\n\t\tidx = i & ss->rx_small.mask;\n\t\tif (i == ss->rx_small.fill_cnt - 1)\n\t\t\tss->rx_small.info[idx].page_offset =\n\t\t\t    MYRI10GE_ALLOC_SIZE;\n\t\tmyri10ge_unmap_rx_page(mgp->pdev, &ss->rx_small.info[idx],\n\t\t\t\t       mgp->small_bytes + MXGEFW_PAD);\n\t\tput_page(ss->rx_small.info[idx].page);\n\t}\n\ttx = &ss->tx;\n\twhile (tx->done != tx->req) {\n\t\tidx = tx->done & tx->mask;\n\t\tskb = tx->info[idx].skb;\n\n\t\t \n\t\ttx->info[idx].skb = NULL;\n\t\ttx->done++;\n\t\tlen = dma_unmap_len(&tx->info[idx], len);\n\t\tdma_unmap_len_set(&tx->info[idx], len, 0);\n\t\tif (skb) {\n\t\t\tss->stats.tx_dropped++;\n\t\t\tdev_kfree_skb_any(skb);\n\t\t\tif (len)\n\t\t\t\tdma_unmap_single(&mgp->pdev->dev,\n\t\t\t\t\t\t dma_unmap_addr(&tx->info[idx],\n\t\t\t\t\t\t\t\tbus), len,\n\t\t\t\t\t\t DMA_TO_DEVICE);\n\t\t} else {\n\t\t\tif (len)\n\t\t\t\tdma_unmap_page(&mgp->pdev->dev,\n\t\t\t\t\t       dma_unmap_addr(&tx->info[idx],\n\t\t\t\t\t\t\t      bus), len,\n\t\t\t\t\t       DMA_TO_DEVICE);\n\t\t}\n\t}\n\tkfree(ss->rx_big.info);\n\n\tkfree(ss->rx_small.info);\n\n\tkfree(ss->tx.info);\n\n\tkfree(ss->rx_big.shadow);\n\n\tkfree(ss->rx_small.shadow);\n\n\tkfree(ss->tx.req_bytes);\n\tss->tx.req_bytes = NULL;\n\tss->tx.req_list = NULL;\n}\n\nstatic int myri10ge_request_irq(struct myri10ge_priv *mgp)\n{\n\tstruct pci_dev *pdev = mgp->pdev;\n\tstruct myri10ge_slice_state *ss;\n\tstruct net_device *netdev = mgp->dev;\n\tint i;\n\tint status;\n\n\tmgp->msi_enabled = 0;\n\tmgp->msix_enabled = 0;\n\tstatus = 0;\n\tif (myri10ge_msi) {\n\t\tif (mgp->num_slices > 1) {\n\t\t\tstatus = pci_enable_msix_range(pdev, mgp->msix_vectors,\n\t\t\t\t\tmgp->num_slices, mgp->num_slices);\n\t\t\tif (status < 0) {\n\t\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\t\"Error %d setting up MSI-X\\n\", status);\n\t\t\t\treturn status;\n\t\t\t}\n\t\t\tmgp->msix_enabled = 1;\n\t\t}\n\t\tif (mgp->msix_enabled == 0) {\n\t\t\tstatus = pci_enable_msi(pdev);\n\t\t\tif (status != 0) {\n\t\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\t\"Error %d setting up MSI; falling back to xPIC\\n\",\n\t\t\t\t\tstatus);\n\t\t\t} else {\n\t\t\t\tmgp->msi_enabled = 1;\n\t\t\t}\n\t\t}\n\t}\n\tif (mgp->msix_enabled) {\n\t\tfor (i = 0; i < mgp->num_slices; i++) {\n\t\t\tss = &mgp->ss[i];\n\t\t\tsnprintf(ss->irq_desc, sizeof(ss->irq_desc),\n\t\t\t\t \"%s:slice-%d\", netdev->name, i);\n\t\t\tstatus = request_irq(mgp->msix_vectors[i].vector,\n\t\t\t\t\t     myri10ge_intr, 0, ss->irq_desc,\n\t\t\t\t\t     ss);\n\t\t\tif (status != 0) {\n\t\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\t\"slice %d failed to allocate IRQ\\n\", i);\n\t\t\t\ti--;\n\t\t\t\twhile (i >= 0) {\n\t\t\t\t\tfree_irq(mgp->msix_vectors[i].vector,\n\t\t\t\t\t\t &mgp->ss[i]);\n\t\t\t\t\ti--;\n\t\t\t\t}\n\t\t\t\tpci_disable_msix(pdev);\n\t\t\t\treturn status;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tstatus = request_irq(pdev->irq, myri10ge_intr, IRQF_SHARED,\n\t\t\t\t     mgp->dev->name, &mgp->ss[0]);\n\t\tif (status != 0) {\n\t\t\tdev_err(&pdev->dev, \"failed to allocate IRQ\\n\");\n\t\t\tif (mgp->msi_enabled)\n\t\t\t\tpci_disable_msi(pdev);\n\t\t}\n\t}\n\treturn status;\n}\n\nstatic void myri10ge_free_irq(struct myri10ge_priv *mgp)\n{\n\tstruct pci_dev *pdev = mgp->pdev;\n\tint i;\n\n\tif (mgp->msix_enabled) {\n\t\tfor (i = 0; i < mgp->num_slices; i++)\n\t\t\tfree_irq(mgp->msix_vectors[i].vector, &mgp->ss[i]);\n\t} else {\n\t\tfree_irq(pdev->irq, &mgp->ss[0]);\n\t}\n\tif (mgp->msi_enabled)\n\t\tpci_disable_msi(pdev);\n\tif (mgp->msix_enabled)\n\t\tpci_disable_msix(pdev);\n}\n\nstatic int myri10ge_get_txrx(struct myri10ge_priv *mgp, int slice)\n{\n\tstruct myri10ge_cmd cmd;\n\tstruct myri10ge_slice_state *ss;\n\tint status;\n\n\tss = &mgp->ss[slice];\n\tstatus = 0;\n\tif (slice == 0 || (mgp->dev->real_num_tx_queues > 1)) {\n\t\tcmd.data0 = slice;\n\t\tstatus = myri10ge_send_cmd(mgp, MXGEFW_CMD_GET_SEND_OFFSET,\n\t\t\t\t\t   &cmd, 0);\n\t\tss->tx.lanai = (struct mcp_kreq_ether_send __iomem *)\n\t\t    (mgp->sram + cmd.data0);\n\t}\n\tcmd.data0 = slice;\n\tstatus |= myri10ge_send_cmd(mgp, MXGEFW_CMD_GET_SMALL_RX_OFFSET,\n\t\t\t\t    &cmd, 0);\n\tss->rx_small.lanai = (struct mcp_kreq_ether_recv __iomem *)\n\t    (mgp->sram + cmd.data0);\n\n\tcmd.data0 = slice;\n\tstatus |= myri10ge_send_cmd(mgp, MXGEFW_CMD_GET_BIG_RX_OFFSET, &cmd, 0);\n\tss->rx_big.lanai = (struct mcp_kreq_ether_recv __iomem *)\n\t    (mgp->sram + cmd.data0);\n\n\tss->tx.send_go = (__iomem __be32 *)\n\t    (mgp->sram + MXGEFW_ETH_SEND_GO + 64 * slice);\n\tss->tx.send_stop = (__iomem __be32 *)\n\t    (mgp->sram + MXGEFW_ETH_SEND_STOP + 64 * slice);\n\treturn status;\n\n}\n\nstatic int myri10ge_set_stats(struct myri10ge_priv *mgp, int slice)\n{\n\tstruct myri10ge_cmd cmd;\n\tstruct myri10ge_slice_state *ss;\n\tint status;\n\n\tss = &mgp->ss[slice];\n\tcmd.data0 = MYRI10GE_LOWPART_TO_U32(ss->fw_stats_bus);\n\tcmd.data1 = MYRI10GE_HIGHPART_TO_U32(ss->fw_stats_bus);\n\tcmd.data2 = sizeof(struct mcp_irq_data) | (slice << 16);\n\tstatus = myri10ge_send_cmd(mgp, MXGEFW_CMD_SET_STATS_DMA_V2, &cmd, 0);\n\tif (status == -ENOSYS) {\n\t\tdma_addr_t bus = ss->fw_stats_bus;\n\t\tif (slice != 0)\n\t\t\treturn -EINVAL;\n\t\tbus += offsetof(struct mcp_irq_data, send_done_count);\n\t\tcmd.data0 = MYRI10GE_LOWPART_TO_U32(bus);\n\t\tcmd.data1 = MYRI10GE_HIGHPART_TO_U32(bus);\n\t\tstatus = myri10ge_send_cmd(mgp,\n\t\t\t\t\t   MXGEFW_CMD_SET_STATS_DMA_OBSOLETE,\n\t\t\t\t\t   &cmd, 0);\n\t\t \n\t\tmgp->fw_multicast_support = 0;\n\t} else {\n\t\tmgp->fw_multicast_support = 1;\n\t}\n\treturn 0;\n}\n\nstatic int myri10ge_open(struct net_device *dev)\n{\n\tstruct myri10ge_slice_state *ss;\n\tstruct myri10ge_priv *mgp = netdev_priv(dev);\n\tstruct myri10ge_cmd cmd;\n\tint i, status, big_pow2, slice;\n\tu8 __iomem *itable;\n\n\tif (mgp->running != MYRI10GE_ETH_STOPPED)\n\t\treturn -EBUSY;\n\n\tmgp->running = MYRI10GE_ETH_STARTING;\n\tstatus = myri10ge_reset(mgp);\n\tif (status != 0) {\n\t\tnetdev_err(dev, \"failed reset\\n\");\n\t\tgoto abort_with_nothing;\n\t}\n\n\tif (mgp->num_slices > 1) {\n\t\tcmd.data0 = mgp->num_slices;\n\t\tcmd.data1 = MXGEFW_SLICE_INTR_MODE_ONE_PER_SLICE;\n\t\tif (mgp->dev->real_num_tx_queues > 1)\n\t\t\tcmd.data1 |= MXGEFW_SLICE_ENABLE_MULTIPLE_TX_QUEUES;\n\t\tstatus = myri10ge_send_cmd(mgp, MXGEFW_CMD_ENABLE_RSS_QUEUES,\n\t\t\t\t\t   &cmd, 0);\n\t\tif (status != 0) {\n\t\t\tnetdev_err(dev, \"failed to set number of slices\\n\");\n\t\t\tgoto abort_with_nothing;\n\t\t}\n\t\t \n\t\tcmd.data0 = mgp->num_slices;\n\t\tstatus = myri10ge_send_cmd(mgp, MXGEFW_CMD_SET_RSS_TABLE_SIZE,\n\t\t\t\t\t   &cmd, 0);\n\n\t\tstatus |= myri10ge_send_cmd(mgp,\n\t\t\t\t\t    MXGEFW_CMD_GET_RSS_TABLE_OFFSET,\n\t\t\t\t\t    &cmd, 0);\n\t\tif (status != 0) {\n\t\t\tnetdev_err(dev, \"failed to setup rss tables\\n\");\n\t\t\tgoto abort_with_nothing;\n\t\t}\n\n\t\t \n\t\titable = mgp->sram + cmd.data0;\n\t\tfor (i = 0; i < mgp->num_slices; i++)\n\t\t\t__raw_writeb(i, &itable[i]);\n\n\t\tcmd.data0 = 1;\n\t\tcmd.data1 = myri10ge_rss_hash;\n\t\tstatus = myri10ge_send_cmd(mgp, MXGEFW_CMD_SET_RSS_ENABLE,\n\t\t\t\t\t   &cmd, 0);\n\t\tif (status != 0) {\n\t\t\tnetdev_err(dev, \"failed to enable slices\\n\");\n\t\t\tgoto abort_with_nothing;\n\t\t}\n\t}\n\n\tstatus = myri10ge_request_irq(mgp);\n\tif (status != 0)\n\t\tgoto abort_with_nothing;\n\n\t \n\n\tif (dev->mtu <= ETH_DATA_LEN)\n\t\t \n\t\tmgp->small_bytes = (128 > SMP_CACHE_BYTES)\n\t\t    ? (128 - MXGEFW_PAD)\n\t\t    : (SMP_CACHE_BYTES - MXGEFW_PAD);\n\telse\n\t\t \n\t\tmgp->small_bytes = VLAN_ETH_FRAME_LEN;\n\n\t \n\tif (myri10ge_small_bytes >= 0)\n\t\tmgp->small_bytes = myri10ge_small_bytes;\n\n\t \n\tbig_pow2 = dev->mtu + ETH_HLEN + VLAN_HLEN + MXGEFW_PAD;\n\tif (big_pow2 < MYRI10GE_ALLOC_SIZE / 2) {\n\t\twhile (!is_power_of_2(big_pow2))\n\t\t\tbig_pow2++;\n\t\tmgp->big_bytes = dev->mtu + ETH_HLEN + VLAN_HLEN + MXGEFW_PAD;\n\t} else {\n\t\tbig_pow2 = MYRI10GE_ALLOC_SIZE;\n\t\tmgp->big_bytes = big_pow2;\n\t}\n\n\t \n\tfor (slice = 0; slice < mgp->num_slices; slice++) {\n\t\tss = &mgp->ss[slice];\n\n\t\tstatus = myri10ge_get_txrx(mgp, slice);\n\t\tif (status != 0) {\n\t\t\tnetdev_err(dev, \"failed to get ring sizes or locations\\n\");\n\t\t\tgoto abort_with_rings;\n\t\t}\n\t\tstatus = myri10ge_allocate_rings(ss);\n\t\tif (status != 0)\n\t\t\tgoto abort_with_rings;\n\n\t\t \n\t\tif (slice == 0 || mgp->dev->real_num_tx_queues > 1)\n\t\t\tstatus = myri10ge_set_stats(mgp, slice);\n\t\tif (status) {\n\t\t\tnetdev_err(dev, \"Couldn't set stats DMA\\n\");\n\t\t\tgoto abort_with_rings;\n\t\t}\n\n\t\t \n\t\tnapi_enable(&(ss)->napi);\n\t}\n\n\t \n\tcmd.data0 = dev->mtu + ETH_HLEN + VLAN_HLEN;\n\tstatus = myri10ge_send_cmd(mgp, MXGEFW_CMD_SET_MTU, &cmd, 0);\n\tcmd.data0 = mgp->small_bytes;\n\tstatus |=\n\t    myri10ge_send_cmd(mgp, MXGEFW_CMD_SET_SMALL_BUFFER_SIZE, &cmd, 0);\n\tcmd.data0 = big_pow2;\n\tstatus |=\n\t    myri10ge_send_cmd(mgp, MXGEFW_CMD_SET_BIG_BUFFER_SIZE, &cmd, 0);\n\tif (status) {\n\t\tnetdev_err(dev, \"Couldn't set buffer sizes\\n\");\n\t\tgoto abort_with_rings;\n\t}\n\n\t \n\tcmd.data0 = 0;\n\tstatus = myri10ge_send_cmd(mgp, MXGEFW_CMD_SET_TSO_MODE, &cmd, 0);\n\tif (status && status != -ENOSYS) {\n\t\tnetdev_err(dev, \"Couldn't set TSO mode\\n\");\n\t\tgoto abort_with_rings;\n\t}\n\n\tmgp->link_state = ~0U;\n\tmgp->rdma_tags_available = 15;\n\n\tstatus = myri10ge_send_cmd(mgp, MXGEFW_CMD_ETHERNET_UP, &cmd, 0);\n\tif (status) {\n\t\tnetdev_err(dev, \"Couldn't bring up link\\n\");\n\t\tgoto abort_with_rings;\n\t}\n\n\tmgp->running = MYRI10GE_ETH_RUNNING;\n\tmgp->watchdog_timer.expires = jiffies + myri10ge_watchdog_timeout * HZ;\n\tadd_timer(&mgp->watchdog_timer);\n\tnetif_tx_wake_all_queues(dev);\n\n\treturn 0;\n\nabort_with_rings:\n\twhile (slice) {\n\t\tslice--;\n\t\tnapi_disable(&mgp->ss[slice].napi);\n\t}\n\tfor (i = 0; i < mgp->num_slices; i++)\n\t\tmyri10ge_free_rings(&mgp->ss[i]);\n\n\tmyri10ge_free_irq(mgp);\n\nabort_with_nothing:\n\tmgp->running = MYRI10GE_ETH_STOPPED;\n\treturn -ENOMEM;\n}\n\nstatic int myri10ge_close(struct net_device *dev)\n{\n\tstruct myri10ge_priv *mgp = netdev_priv(dev);\n\tstruct myri10ge_cmd cmd;\n\tint status, old_down_cnt;\n\tint i;\n\n\tif (mgp->running != MYRI10GE_ETH_RUNNING)\n\t\treturn 0;\n\n\tif (mgp->ss[0].tx.req_bytes == NULL)\n\t\treturn 0;\n\n\tdel_timer_sync(&mgp->watchdog_timer);\n\tmgp->running = MYRI10GE_ETH_STOPPING;\n\tfor (i = 0; i < mgp->num_slices; i++)\n\t\tnapi_disable(&mgp->ss[i].napi);\n\n\tnetif_carrier_off(dev);\n\n\tnetif_tx_stop_all_queues(dev);\n\tif (mgp->rebooted == 0) {\n\t\told_down_cnt = mgp->down_cnt;\n\t\tmb();\n\t\tstatus =\n\t\t    myri10ge_send_cmd(mgp, MXGEFW_CMD_ETHERNET_DOWN, &cmd, 0);\n\t\tif (status)\n\t\t\tnetdev_err(dev, \"Couldn't bring down link\\n\");\n\n\t\twait_event_timeout(mgp->down_wq, old_down_cnt != mgp->down_cnt,\n\t\t\t\t   HZ);\n\t\tif (old_down_cnt == mgp->down_cnt)\n\t\t\tnetdev_err(dev, \"never got down irq\\n\");\n\t}\n\tnetif_tx_disable(dev);\n\tmyri10ge_free_irq(mgp);\n\tfor (i = 0; i < mgp->num_slices; i++)\n\t\tmyri10ge_free_rings(&mgp->ss[i]);\n\n\tmgp->running = MYRI10GE_ETH_STOPPED;\n\treturn 0;\n}\n\n \n\nstatic inline void\nmyri10ge_submit_req_backwards(struct myri10ge_tx_buf *tx,\n\t\t\t      struct mcp_kreq_ether_send *src, int cnt)\n{\n\tint idx, starting_slot;\n\tstarting_slot = tx->req;\n\twhile (cnt > 1) {\n\t\tcnt--;\n\t\tidx = (starting_slot + cnt) & tx->mask;\n\t\tmyri10ge_pio_copy(&tx->lanai[idx], &src[cnt], sizeof(*src));\n\t\tmb();\n\t}\n}\n\n \n\nstatic inline void\nmyri10ge_submit_req(struct myri10ge_tx_buf *tx, struct mcp_kreq_ether_send *src,\n\t\t    int cnt)\n{\n\tint idx, i;\n\tstruct mcp_kreq_ether_send __iomem *dstp, *dst;\n\tstruct mcp_kreq_ether_send *srcp;\n\tu8 last_flags;\n\n\tidx = tx->req & tx->mask;\n\n\tlast_flags = src->flags;\n\tsrc->flags = 0;\n\tmb();\n\tdst = dstp = &tx->lanai[idx];\n\tsrcp = src;\n\n\tif ((idx + cnt) < tx->mask) {\n\t\tfor (i = 0; i < (cnt - 1); i += 2) {\n\t\t\tmyri10ge_pio_copy(dstp, srcp, 2 * sizeof(*src));\n\t\t\tmb();\t \n\t\t\tsrcp += 2;\n\t\t\tdstp += 2;\n\t\t}\n\t} else {\n\t\t \n\t\tmyri10ge_submit_req_backwards(tx, src, cnt);\n\t\ti = 0;\n\t}\n\tif (i < cnt) {\n\t\t \n\t\tmyri10ge_pio_copy(dstp, srcp, sizeof(*src));\n\t\tmb();\t\t \n\t}\n\n\t \n\tsrc->flags = last_flags;\n\tput_be32(*((__be32 *) src + 3), (__be32 __iomem *) dst + 3);\n\ttx->req += cnt;\n\tmb();\n}\n\nstatic void myri10ge_unmap_tx_dma(struct myri10ge_priv *mgp,\n\t\t\t\t  struct myri10ge_tx_buf *tx, int idx)\n{\n\tunsigned int len;\n\tint last_idx;\n\n\t \n\tlast_idx = (idx + 1) & tx->mask;\n\tidx = tx->req & tx->mask;\n\tdo {\n\t\tlen = dma_unmap_len(&tx->info[idx], len);\n\t\tif (len) {\n\t\t\tif (tx->info[idx].skb != NULL)\n\t\t\t\tdma_unmap_single(&mgp->pdev->dev,\n\t\t\t\t\t\t dma_unmap_addr(&tx->info[idx],\n\t\t\t\t\t\t\t\tbus), len,\n\t\t\t\t\t\t DMA_TO_DEVICE);\n\t\t\telse\n\t\t\t\tdma_unmap_page(&mgp->pdev->dev,\n\t\t\t\t\t       dma_unmap_addr(&tx->info[idx],\n\t\t\t\t\t\t\t      bus), len,\n\t\t\t\t\t       DMA_TO_DEVICE);\n\t\t\tdma_unmap_len_set(&tx->info[idx], len, 0);\n\t\t\ttx->info[idx].skb = NULL;\n\t\t}\n\t\tidx = (idx + 1) & tx->mask;\n\t} while (idx != last_idx);\n}\n\n \n\nstatic netdev_tx_t myri10ge_xmit(struct sk_buff *skb,\n\t\t\t\t       struct net_device *dev)\n{\n\tstruct myri10ge_priv *mgp = netdev_priv(dev);\n\tstruct myri10ge_slice_state *ss;\n\tstruct mcp_kreq_ether_send *req;\n\tstruct myri10ge_tx_buf *tx;\n\tskb_frag_t *frag;\n\tstruct netdev_queue *netdev_queue;\n\tdma_addr_t bus;\n\tu32 low;\n\t__be32 high_swapped;\n\tunsigned int len;\n\tint idx, avail, frag_cnt, frag_idx, count, mss, max_segments;\n\tu16 pseudo_hdr_offset, cksum_offset, queue;\n\tint cum_len, seglen, boundary, rdma_count;\n\tu8 flags, odd_flag;\n\n\tqueue = skb_get_queue_mapping(skb);\n\tss = &mgp->ss[queue];\n\tnetdev_queue = netdev_get_tx_queue(mgp->dev, queue);\n\ttx = &ss->tx;\n\nagain:\n\treq = tx->req_list;\n\tavail = tx->mask - 1 - (tx->req - tx->done);\n\n\tmss = 0;\n\tmax_segments = MXGEFW_MAX_SEND_DESC;\n\n\tif (skb_is_gso(skb)) {\n\t\tmss = skb_shinfo(skb)->gso_size;\n\t\tmax_segments = MYRI10GE_MAX_SEND_DESC_TSO;\n\t}\n\n\tif ((unlikely(avail < max_segments))) {\n\t\t \n\t\ttx->stop_queue++;\n\t\tnetif_tx_stop_queue(netdev_queue);\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\n\t \n\tcksum_offset = 0;\n\tpseudo_hdr_offset = 0;\n\todd_flag = 0;\n\tflags = (MXGEFW_FLAGS_NO_TSO | MXGEFW_FLAGS_FIRST);\n\tif (likely(skb->ip_summed == CHECKSUM_PARTIAL)) {\n\t\tcksum_offset = skb_checksum_start_offset(skb);\n\t\tpseudo_hdr_offset = cksum_offset + skb->csum_offset;\n\t\t \n\t\tif (unlikely(!mss && (cksum_offset > 255 ||\n\t\t\t\t      pseudo_hdr_offset > 127))) {\n\t\t\tif (skb_checksum_help(skb))\n\t\t\t\tgoto drop;\n\t\t\tcksum_offset = 0;\n\t\t\tpseudo_hdr_offset = 0;\n\t\t} else {\n\t\t\todd_flag = MXGEFW_FLAGS_ALIGN_ODD;\n\t\t\tflags |= MXGEFW_FLAGS_CKSUM;\n\t\t}\n\t}\n\n\tcum_len = 0;\n\n\tif (mss) {\t\t \n\t\t \n\t\tflags = (MXGEFW_FLAGS_TSO_HDR | MXGEFW_FLAGS_FIRST);\n\n\t\t \n\t\tcum_len = -skb_tcp_all_headers(skb);\n\n\t\t \n\t\tif (skb_is_gso_v6(skb)) {\n\t\t\tcksum_offset = tcp_hdrlen(skb);\n\t\t\t \n\t\t\tif (unlikely(-cum_len > mgp->max_tso6))\n\t\t\t\treturn myri10ge_sw_tso(skb, dev);\n\t\t}\n\t\t \n\t\tpseudo_hdr_offset = mss;\n\t} else\n\t\t \n\tif (skb->len <= MXGEFW_SEND_SMALL_SIZE) {\n\t\tflags |= MXGEFW_FLAGS_SMALL;\n\n\t\t \n\t\tif (eth_skb_pad(skb)) {\n\t\t\t \n\t\t\tss->stats.tx_dropped += 1;\n\t\t\treturn NETDEV_TX_OK;\n\t\t}\n\t}\n\n\t \n\tlen = skb_headlen(skb);\n\tbus = dma_map_single(&mgp->pdev->dev, skb->data, len, DMA_TO_DEVICE);\n\tif (unlikely(dma_mapping_error(&mgp->pdev->dev, bus)))\n\t\tgoto drop;\n\n\tidx = tx->req & tx->mask;\n\ttx->info[idx].skb = skb;\n\tdma_unmap_addr_set(&tx->info[idx], bus, bus);\n\tdma_unmap_len_set(&tx->info[idx], len, len);\n\n\tfrag_cnt = skb_shinfo(skb)->nr_frags;\n\tfrag_idx = 0;\n\tcount = 0;\n\trdma_count = 0;\n\n\t \n\n\twhile (1) {\n\t\t \n\t\tlow = MYRI10GE_LOWPART_TO_U32(bus);\n\t\thigh_swapped = htonl(MYRI10GE_HIGHPART_TO_U32(bus));\n\t\twhile (len) {\n\t\t\tu8 flags_next;\n\t\t\tint cum_len_next;\n\n\t\t\tif (unlikely(count == max_segments))\n\t\t\t\tgoto abort_linearize;\n\n\t\t\tboundary =\n\t\t\t    (low + mgp->tx_boundary) & ~(mgp->tx_boundary - 1);\n\t\t\tseglen = boundary - low;\n\t\t\tif (seglen > len)\n\t\t\t\tseglen = len;\n\t\t\tflags_next = flags & ~MXGEFW_FLAGS_FIRST;\n\t\t\tcum_len_next = cum_len + seglen;\n\t\t\tif (mss) {\t \n\t\t\t\t(req - rdma_count)->rdma_count = rdma_count + 1;\n\n\t\t\t\tif (likely(cum_len >= 0)) {\t \n\t\t\t\t\tint next_is_first, chop;\n\n\t\t\t\t\tchop = (cum_len_next > mss);\n\t\t\t\t\tcum_len_next = cum_len_next % mss;\n\t\t\t\t\tnext_is_first = (cum_len_next == 0);\n\t\t\t\t\tflags |= chop * MXGEFW_FLAGS_TSO_CHOP;\n\t\t\t\t\tflags_next |= next_is_first *\n\t\t\t\t\t    MXGEFW_FLAGS_FIRST;\n\t\t\t\t\trdma_count |= -(chop | next_is_first);\n\t\t\t\t\trdma_count += chop & ~next_is_first;\n\t\t\t\t} else if (likely(cum_len_next >= 0)) {\t \n\t\t\t\t\tint small;\n\n\t\t\t\t\trdma_count = -1;\n\t\t\t\t\tcum_len_next = 0;\n\t\t\t\t\tseglen = -cum_len;\n\t\t\t\t\tsmall = (mss <= MXGEFW_SEND_SMALL_SIZE);\n\t\t\t\t\tflags_next = MXGEFW_FLAGS_TSO_PLD |\n\t\t\t\t\t    MXGEFW_FLAGS_FIRST |\n\t\t\t\t\t    (small * MXGEFW_FLAGS_SMALL);\n\t\t\t\t}\n\t\t\t}\n\t\t\treq->addr_high = high_swapped;\n\t\t\treq->addr_low = htonl(low);\n\t\t\treq->pseudo_hdr_offset = htons(pseudo_hdr_offset);\n\t\t\treq->pad = 0;\t \n\t\t\treq->rdma_count = 1;\n\t\t\treq->length = htons(seglen);\n\t\t\treq->cksum_offset = cksum_offset;\n\t\t\treq->flags = flags | ((cum_len & 1) * odd_flag);\n\n\t\t\tlow += seglen;\n\t\t\tlen -= seglen;\n\t\t\tcum_len = cum_len_next;\n\t\t\tflags = flags_next;\n\t\t\treq++;\n\t\t\tcount++;\n\t\t\trdma_count++;\n\t\t\tif (cksum_offset != 0 && !(mss && skb_is_gso_v6(skb))) {\n\t\t\t\tif (unlikely(cksum_offset > seglen))\n\t\t\t\t\tcksum_offset -= seglen;\n\t\t\t\telse\n\t\t\t\t\tcksum_offset = 0;\n\t\t\t}\n\t\t}\n\t\tif (frag_idx == frag_cnt)\n\t\t\tbreak;\n\n\t\t \n\t\tfrag = &skb_shinfo(skb)->frags[frag_idx];\n\t\tfrag_idx++;\n\t\tlen = skb_frag_size(frag);\n\t\tbus = skb_frag_dma_map(&mgp->pdev->dev, frag, 0, len,\n\t\t\t\t       DMA_TO_DEVICE);\n\t\tif (unlikely(dma_mapping_error(&mgp->pdev->dev, bus))) {\n\t\t\tmyri10ge_unmap_tx_dma(mgp, tx, idx);\n\t\t\tgoto drop;\n\t\t}\n\t\tidx = (count + tx->req) & tx->mask;\n\t\tdma_unmap_addr_set(&tx->info[idx], bus, bus);\n\t\tdma_unmap_len_set(&tx->info[idx], len, len);\n\t}\n\n\t(req - rdma_count)->rdma_count = rdma_count;\n\tif (mss)\n\t\tdo {\n\t\t\treq--;\n\t\t\treq->flags |= MXGEFW_FLAGS_TSO_LAST;\n\t\t} while (!(req->flags & (MXGEFW_FLAGS_TSO_CHOP |\n\t\t\t\t\t MXGEFW_FLAGS_FIRST)));\n\tidx = ((count - 1) + tx->req) & tx->mask;\n\ttx->info[idx].last = 1;\n\tmyri10ge_submit_req(tx, tx->req_list, count);\n\t \n\tif ((mgp->dev->real_num_tx_queues > 1) && tx->queue_active == 0) {\n\t\ttx->queue_active = 1;\n\t\tput_be32(htonl(1), tx->send_go);\n\t\tmb();\n\t}\n\ttx->pkt_start++;\n\tif ((avail - count) < MXGEFW_MAX_SEND_DESC) {\n\t\ttx->stop_queue++;\n\t\tnetif_tx_stop_queue(netdev_queue);\n\t}\n\treturn NETDEV_TX_OK;\n\nabort_linearize:\n\tmyri10ge_unmap_tx_dma(mgp, tx, idx);\n\n\tif (skb_is_gso(skb)) {\n\t\tnetdev_err(mgp->dev, \"TSO but wanted to linearize?!?!?\\n\");\n\t\tgoto drop;\n\t}\n\n\tif (skb_linearize(skb))\n\t\tgoto drop;\n\n\ttx->linearized++;\n\tgoto again;\n\ndrop:\n\tdev_kfree_skb_any(skb);\n\tss->stats.tx_dropped += 1;\n\treturn NETDEV_TX_OK;\n\n}\n\nstatic netdev_tx_t myri10ge_sw_tso(struct sk_buff *skb,\n\t\t\t\t\t struct net_device *dev)\n{\n\tstruct sk_buff *segs, *curr, *next;\n\tstruct myri10ge_priv *mgp = netdev_priv(dev);\n\tstruct myri10ge_slice_state *ss;\n\tnetdev_tx_t status;\n\n\tsegs = skb_gso_segment(skb, dev->features & ~NETIF_F_TSO6);\n\tif (IS_ERR(segs))\n\t\tgoto drop;\n\n\tskb_list_walk_safe(segs, curr, next) {\n\t\tskb_mark_not_on_list(curr);\n\t\tstatus = myri10ge_xmit(curr, dev);\n\t\tif (status != 0) {\n\t\t\tdev_kfree_skb_any(curr);\n\t\t\tskb_list_walk_safe(next, curr, next) {\n\t\t\t\tcurr->next = NULL;\n\t\t\t\tdev_kfree_skb_any(curr);\n\t\t\t}\n\t\t\tgoto drop;\n\t\t}\n\t}\n\tdev_kfree_skb_any(skb);\n\treturn NETDEV_TX_OK;\n\ndrop:\n\tss = &mgp->ss[skb_get_queue_mapping(skb)];\n\tdev_kfree_skb_any(skb);\n\tss->stats.tx_dropped += 1;\n\treturn NETDEV_TX_OK;\n}\n\nstatic void myri10ge_get_stats(struct net_device *dev,\n\t\t\t       struct rtnl_link_stats64 *stats)\n{\n\tconst struct myri10ge_priv *mgp = netdev_priv(dev);\n\tconst struct myri10ge_slice_netstats *slice_stats;\n\tint i;\n\n\tfor (i = 0; i < mgp->num_slices; i++) {\n\t\tslice_stats = &mgp->ss[i].stats;\n\t\tstats->rx_packets += slice_stats->rx_packets;\n\t\tstats->tx_packets += slice_stats->tx_packets;\n\t\tstats->rx_bytes += slice_stats->rx_bytes;\n\t\tstats->tx_bytes += slice_stats->tx_bytes;\n\t\tstats->rx_dropped += slice_stats->rx_dropped;\n\t\tstats->tx_dropped += slice_stats->tx_dropped;\n\t}\n}\n\nstatic void myri10ge_set_multicast_list(struct net_device *dev)\n{\n\tstruct myri10ge_priv *mgp = netdev_priv(dev);\n\tstruct myri10ge_cmd cmd;\n\tstruct netdev_hw_addr *ha;\n\t__be32 data[2] = { 0, 0 };\n\tint err;\n\n\t \n\tmyri10ge_change_promisc(mgp, dev->flags & IFF_PROMISC, 1);\n\n\t \n\tif (!mgp->fw_multicast_support)\n\t\treturn;\n\n\t \n\n\terr = myri10ge_send_cmd(mgp, MXGEFW_ENABLE_ALLMULTI, &cmd, 1);\n\tif (err != 0) {\n\t\tnetdev_err(dev, \"Failed MXGEFW_ENABLE_ALLMULTI, error status: %d\\n\",\n\t\t\t   err);\n\t\tgoto abort;\n\t}\n\n\tif ((dev->flags & IFF_ALLMULTI) || mgp->adopted_rx_filter_bug) {\n\t\t \n\t\treturn;\n\t}\n\n\t \n\n\terr = myri10ge_send_cmd(mgp, MXGEFW_LEAVE_ALL_MULTICAST_GROUPS,\n\t\t\t\t&cmd, 1);\n\tif (err != 0) {\n\t\tnetdev_err(dev, \"Failed MXGEFW_LEAVE_ALL_MULTICAST_GROUPS, error status: %d\\n\",\n\t\t\t   err);\n\t\tgoto abort;\n\t}\n\n\t \n\tnetdev_for_each_mc_addr(ha, dev) {\n\t\tmemcpy(data, &ha->addr, ETH_ALEN);\n\t\tcmd.data0 = ntohl(data[0]);\n\t\tcmd.data1 = ntohl(data[1]);\n\t\terr = myri10ge_send_cmd(mgp, MXGEFW_JOIN_MULTICAST_GROUP,\n\t\t\t\t\t&cmd, 1);\n\n\t\tif (err != 0) {\n\t\t\tnetdev_err(dev, \"Failed MXGEFW_JOIN_MULTICAST_GROUP, error status:%d %pM\\n\",\n\t\t\t\t   err, ha->addr);\n\t\t\tgoto abort;\n\t\t}\n\t}\n\t \n\terr = myri10ge_send_cmd(mgp, MXGEFW_DISABLE_ALLMULTI, &cmd, 1);\n\tif (err != 0) {\n\t\tnetdev_err(dev, \"Failed MXGEFW_DISABLE_ALLMULTI, error status: %d\\n\",\n\t\t\t   err);\n\t\tgoto abort;\n\t}\n\n\treturn;\n\nabort:\n\treturn;\n}\n\nstatic int myri10ge_set_mac_address(struct net_device *dev, void *addr)\n{\n\tstruct sockaddr *sa = addr;\n\tstruct myri10ge_priv *mgp = netdev_priv(dev);\n\tint status;\n\n\tif (!is_valid_ether_addr(sa->sa_data))\n\t\treturn -EADDRNOTAVAIL;\n\n\tstatus = myri10ge_update_mac_address(mgp, sa->sa_data);\n\tif (status != 0) {\n\t\tnetdev_err(dev, \"changing mac address failed with %d\\n\",\n\t\t\t   status);\n\t\treturn status;\n\t}\n\n\t \n\teth_hw_addr_set(dev, sa->sa_data);\n\treturn 0;\n}\n\nstatic int myri10ge_change_mtu(struct net_device *dev, int new_mtu)\n{\n\tstruct myri10ge_priv *mgp = netdev_priv(dev);\n\n\tnetdev_info(dev, \"changing mtu from %d to %d\\n\", dev->mtu, new_mtu);\n\tif (mgp->running) {\n\t\t \n\t\tmyri10ge_close(dev);\n\t\tdev->mtu = new_mtu;\n\t\tmyri10ge_open(dev);\n\t} else\n\t\tdev->mtu = new_mtu;\n\n\treturn 0;\n}\n\n \n\nstatic void myri10ge_enable_ecrc(struct myri10ge_priv *mgp)\n{\n\tstruct pci_dev *bridge = mgp->pdev->bus->self;\n\tstruct device *dev = &mgp->pdev->dev;\n\tint cap;\n\tunsigned err_cap;\n\tint ret;\n\n\tif (!myri10ge_ecrc_enable || !bridge)\n\t\treturn;\n\n\t \n\tif (pci_pcie_type(bridge) != PCI_EXP_TYPE_ROOT_PORT) {\n\t\tif (myri10ge_ecrc_enable > 1) {\n\t\t\tstruct pci_dev *prev_bridge, *old_bridge = bridge;\n\n\t\t\t \n\t\t\tdo {\n\t\t\t\tprev_bridge = bridge;\n\t\t\t\tbridge = bridge->bus->self;\n\t\t\t\tif (!bridge || prev_bridge == bridge) {\n\t\t\t\t\tdev_err(dev,\n\t\t\t\t\t\t\"Failed to find root port\"\n\t\t\t\t\t\t\" to force ECRC\\n\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (pci_pcie_type(bridge) !=\n\t\t\t\t PCI_EXP_TYPE_ROOT_PORT);\n\n\t\t\tdev_info(dev,\n\t\t\t\t \"Forcing ECRC on non-root port %s\"\n\t\t\t\t \" (enabling on root port %s)\\n\",\n\t\t\t\t pci_name(old_bridge), pci_name(bridge));\n\t\t} else {\n\t\t\tdev_err(dev,\n\t\t\t\t\"Not enabling ECRC on non-root port %s\\n\",\n\t\t\t\tpci_name(bridge));\n\t\t\treturn;\n\t\t}\n\t}\n\n\tcap = pci_find_ext_capability(bridge, PCI_EXT_CAP_ID_ERR);\n\tif (!cap)\n\t\treturn;\n\n\tret = pci_read_config_dword(bridge, cap + PCI_ERR_CAP, &err_cap);\n\tif (ret) {\n\t\tdev_err(dev, \"failed reading ext-conf-space of %s\\n\",\n\t\t\tpci_name(bridge));\n\t\tdev_err(dev, \"\\t pci=nommconf in use? \"\n\t\t\t\"or buggy/incomplete/absent ACPI MCFG attr?\\n\");\n\t\treturn;\n\t}\n\tif (!(err_cap & PCI_ERR_CAP_ECRC_GENC))\n\t\treturn;\n\n\terr_cap |= PCI_ERR_CAP_ECRC_GENE;\n\tpci_write_config_dword(bridge, cap + PCI_ERR_CAP, err_cap);\n\tdev_info(dev, \"Enabled ECRC on upstream bridge %s\\n\", pci_name(bridge));\n}\n\n \n\nstatic void myri10ge_firmware_probe(struct myri10ge_priv *mgp)\n{\n\tstruct pci_dev *pdev = mgp->pdev;\n\tstruct device *dev = &pdev->dev;\n\tint status;\n\n\tmgp->tx_boundary = 4096;\n\t \n\tstatus = pcie_get_readrq(pdev);\n\tif (status < 0) {\n\t\tdev_err(dev, \"Couldn't read max read req size: %d\\n\", status);\n\t\tgoto abort;\n\t}\n\tif (status != 4096) {\n\t\tdev_warn(dev, \"Max Read Request size != 4096 (%d)\\n\", status);\n\t\tmgp->tx_boundary = 2048;\n\t}\n\t \n\tset_fw_name(mgp, myri10ge_fw_aligned, false);\n\tstatus = myri10ge_load_firmware(mgp, 1);\n\tif (status != 0) {\n\t\tgoto abort;\n\t}\n\n\t \n\tmyri10ge_enable_ecrc(mgp);\n\n\t \n\n\tstatus = myri10ge_dma_test(mgp, MXGEFW_CMD_UNALIGNED_TEST);\n\tif (status == 0)\n\t\treturn;\t\t \n\n\tif (status != -E2BIG)\n\t\tdev_warn(dev, \"DMA test failed: %d\\n\", status);\n\tif (status == -ENOSYS)\n\t\tdev_warn(dev, \"Falling back to ethp! \"\n\t\t\t \"Please install up to date fw\\n\");\nabort:\n\t \n\tmgp->tx_boundary = 2048;\n\tset_fw_name(mgp, myri10ge_fw_unaligned, false);\n}\n\nstatic void myri10ge_select_firmware(struct myri10ge_priv *mgp)\n{\n\tint overridden = 0;\n\n\tif (myri10ge_force_firmware == 0) {\n\t\tint link_width;\n\t\tu16 lnk;\n\n\t\tpcie_capability_read_word(mgp->pdev, PCI_EXP_LNKSTA, &lnk);\n\t\tlink_width = (lnk >> 4) & 0x3f;\n\n\t\t \n\t\tif (link_width < 8) {\n\t\t\tdev_info(&mgp->pdev->dev, \"PCIE x%d Link\\n\",\n\t\t\t\t link_width);\n\t\t\tmgp->tx_boundary = 4096;\n\t\t\tset_fw_name(mgp, myri10ge_fw_aligned, false);\n\t\t} else {\n\t\t\tmyri10ge_firmware_probe(mgp);\n\t\t}\n\t} else {\n\t\tif (myri10ge_force_firmware == 1) {\n\t\t\tdev_info(&mgp->pdev->dev,\n\t\t\t\t \"Assuming aligned completions (forced)\\n\");\n\t\t\tmgp->tx_boundary = 4096;\n\t\t\tset_fw_name(mgp, myri10ge_fw_aligned, false);\n\t\t} else {\n\t\t\tdev_info(&mgp->pdev->dev,\n\t\t\t\t \"Assuming unaligned completions (forced)\\n\");\n\t\t\tmgp->tx_boundary = 2048;\n\t\t\tset_fw_name(mgp, myri10ge_fw_unaligned, false);\n\t\t}\n\t}\n\n\tkernel_param_lock(THIS_MODULE);\n\tif (myri10ge_fw_name != NULL) {\n\t\tchar *fw_name = kstrdup(myri10ge_fw_name, GFP_KERNEL);\n\t\tif (fw_name) {\n\t\t\toverridden = 1;\n\t\t\tset_fw_name(mgp, fw_name, true);\n\t\t}\n\t}\n\tkernel_param_unlock(THIS_MODULE);\n\n\tif (mgp->board_number < MYRI10GE_MAX_BOARDS &&\n\t    myri10ge_fw_names[mgp->board_number] != NULL &&\n\t    strlen(myri10ge_fw_names[mgp->board_number])) {\n\t\tset_fw_name(mgp, myri10ge_fw_names[mgp->board_number], false);\n\t\toverridden = 1;\n\t}\n\tif (overridden)\n\t\tdev_info(&mgp->pdev->dev, \"overriding firmware to %s\\n\",\n\t\t\t mgp->fw_name);\n}\n\nstatic void myri10ge_mask_surprise_down(struct pci_dev *pdev)\n{\n\tstruct pci_dev *bridge = pdev->bus->self;\n\tint cap;\n\tu32 mask;\n\n\tif (bridge == NULL)\n\t\treturn;\n\n\tcap = pci_find_ext_capability(bridge, PCI_EXT_CAP_ID_ERR);\n\tif (cap) {\n\t\t \n\t\tpci_read_config_dword(bridge, cap + PCI_ERR_UNCOR_MASK, &mask);\n\t\tmask |= 0x20;\n\t\tpci_write_config_dword(bridge, cap + PCI_ERR_UNCOR_MASK, mask);\n\t}\n}\n\nstatic int __maybe_unused myri10ge_suspend(struct device *dev)\n{\n\tstruct myri10ge_priv *mgp;\n\tstruct net_device *netdev;\n\n\tmgp = dev_get_drvdata(dev);\n\tif (mgp == NULL)\n\t\treturn -EINVAL;\n\tnetdev = mgp->dev;\n\n\tnetif_device_detach(netdev);\n\tif (netif_running(netdev)) {\n\t\tnetdev_info(netdev, \"closing\\n\");\n\t\trtnl_lock();\n\t\tmyri10ge_close(netdev);\n\t\trtnl_unlock();\n\t}\n\tmyri10ge_dummy_rdma(mgp, 0);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused myri10ge_resume(struct device *dev)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tstruct myri10ge_priv *mgp;\n\tstruct net_device *netdev;\n\tint status;\n\tu16 vendor;\n\n\tmgp = pci_get_drvdata(pdev);\n\tif (mgp == NULL)\n\t\treturn -EINVAL;\n\tnetdev = mgp->dev;\n\tmsleep(5);\t\t \n\tpci_read_config_word(mgp->pdev, PCI_VENDOR_ID, &vendor);\n\tif (vendor == 0xffff) {\n\t\tnetdev_err(mgp->dev, \"device disappeared!\\n\");\n\t\treturn -EIO;\n\t}\n\n\tmyri10ge_reset(mgp);\n\tmyri10ge_dummy_rdma(mgp, 1);\n\n\tif (netif_running(netdev)) {\n\t\trtnl_lock();\n\t\tstatus = myri10ge_open(netdev);\n\t\trtnl_unlock();\n\t\tif (status != 0)\n\t\t\tgoto abort_with_enabled;\n\n\t}\n\tnetif_device_attach(netdev);\n\n\treturn 0;\n\nabort_with_enabled:\n\treturn -EIO;\n}\n\nstatic u32 myri10ge_read_reboot(struct myri10ge_priv *mgp)\n{\n\tstruct pci_dev *pdev = mgp->pdev;\n\tint vs = mgp->vendor_specific_offset;\n\tu32 reboot;\n\n\t \n\tpci_write_config_byte(pdev, vs + 0x10, 0x3);\n\n\t \n\tpci_write_config_dword(pdev, vs + 0x18, 0xfffffff0);\n\tpci_read_config_dword(pdev, vs + 0x14, &reboot);\n\treturn reboot;\n}\n\nstatic void\nmyri10ge_check_slice(struct myri10ge_slice_state *ss, int *reset_needed,\n\t\t     int *busy_slice_cnt, u32 rx_pause_cnt)\n{\n\tstruct myri10ge_priv *mgp = ss->mgp;\n\tint slice = ss - mgp->ss;\n\n\tif (ss->tx.req != ss->tx.done &&\n\t    ss->tx.done == ss->watchdog_tx_done &&\n\t    ss->watchdog_tx_req != ss->watchdog_tx_done) {\n\t\t \n\t\tif (rx_pause_cnt != mgp->watchdog_pause) {\n\t\t\tif (net_ratelimit())\n\t\t\t\tnetdev_warn(mgp->dev, \"slice %d: TX paused, \"\n\t\t\t\t\t    \"check link partner\\n\", slice);\n\t\t} else {\n\t\t\tnetdev_warn(mgp->dev,\n\t\t\t\t    \"slice %d: TX stuck %d %d %d %d %d %d\\n\",\n\t\t\t\t    slice, ss->tx.queue_active, ss->tx.req,\n\t\t\t\t    ss->tx.done, ss->tx.pkt_start,\n\t\t\t\t    ss->tx.pkt_done,\n\t\t\t\t    (int)ntohl(mgp->ss[slice].fw_stats->\n\t\t\t\t\t       send_done_count));\n\t\t\t*reset_needed = 1;\n\t\t\tss->stuck = 1;\n\t\t}\n\t}\n\tif (ss->watchdog_tx_done != ss->tx.done ||\n\t    ss->watchdog_rx_done != ss->rx_done.cnt) {\n\t\t*busy_slice_cnt += 1;\n\t}\n\tss->watchdog_tx_done = ss->tx.done;\n\tss->watchdog_tx_req = ss->tx.req;\n\tss->watchdog_rx_done = ss->rx_done.cnt;\n}\n\n \nstatic void myri10ge_watchdog(struct work_struct *work)\n{\n\tstruct myri10ge_priv *mgp =\n\t    container_of(work, struct myri10ge_priv, watchdog_work);\n\tstruct myri10ge_slice_state *ss;\n\tu32 reboot, rx_pause_cnt;\n\tint status, rebooted;\n\tint i;\n\tint reset_needed = 0;\n\tint busy_slice_cnt = 0;\n\tu16 cmd, vendor;\n\n\tmgp->watchdog_resets++;\n\tpci_read_config_word(mgp->pdev, PCI_COMMAND, &cmd);\n\trebooted = 0;\n\tif ((cmd & PCI_COMMAND_MASTER) == 0) {\n\t\t \n\t\treboot = myri10ge_read_reboot(mgp);\n\t\tnetdev_err(mgp->dev, \"NIC rebooted (0x%x),%s resetting\\n\",\n\t\t\t   reboot, myri10ge_reset_recover ? \"\" : \" not\");\n\t\tif (myri10ge_reset_recover == 0)\n\t\t\treturn;\n\t\trtnl_lock();\n\t\tmgp->rebooted = 1;\n\t\trebooted = 1;\n\t\tmyri10ge_close(mgp->dev);\n\t\tmyri10ge_reset_recover--;\n\t\tmgp->rebooted = 0;\n\t\t \n\t\tpci_restore_state(mgp->pdev);\n\n\t\t \n\t\tpci_save_state(mgp->pdev);\n\n\t} else {\n\t\t \n\t\tif (cmd == 0xffff) {\n\t\t\tpci_read_config_word(mgp->pdev, PCI_VENDOR_ID, &vendor);\n\t\t\tif (vendor == 0xffff) {\n\t\t\t\tnetdev_err(mgp->dev, \"device disappeared!\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t \n\t\trx_pause_cnt = ntohl(mgp->ss[0].fw_stats->dropped_pause);\n\t\tfor (i = 0; i < mgp->num_slices; i++) {\n\t\t\tss = mgp->ss;\n\t\t\tif (ss->stuck) {\n\t\t\t\tmyri10ge_check_slice(ss, &reset_needed,\n\t\t\t\t\t\t     &busy_slice_cnt,\n\t\t\t\t\t\t     rx_pause_cnt);\n\t\t\t\tss->stuck = 0;\n\t\t\t}\n\t\t}\n\t\tif (!reset_needed) {\n\t\t\tnetdev_dbg(mgp->dev, \"not resetting\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\tnetdev_err(mgp->dev, \"device timeout, resetting\\n\");\n\t}\n\n\tif (!rebooted) {\n\t\trtnl_lock();\n\t\tmyri10ge_close(mgp->dev);\n\t}\n\tstatus = myri10ge_load_firmware(mgp, 1);\n\tif (status != 0)\n\t\tnetdev_err(mgp->dev, \"failed to load firmware\\n\");\n\telse\n\t\tmyri10ge_open(mgp->dev);\n\trtnl_unlock();\n}\n\n \nstatic void myri10ge_watchdog_timer(struct timer_list *t)\n{\n\tstruct myri10ge_priv *mgp;\n\tstruct myri10ge_slice_state *ss;\n\tint i, reset_needed, busy_slice_cnt;\n\tu32 rx_pause_cnt;\n\tu16 cmd;\n\n\tmgp = from_timer(mgp, t, watchdog_timer);\n\n\trx_pause_cnt = ntohl(mgp->ss[0].fw_stats->dropped_pause);\n\tbusy_slice_cnt = 0;\n\tfor (i = 0, reset_needed = 0;\n\t     i < mgp->num_slices && reset_needed == 0; ++i) {\n\n\t\tss = &mgp->ss[i];\n\t\tif (ss->rx_small.watchdog_needed) {\n\t\t\tmyri10ge_alloc_rx_pages(mgp, &ss->rx_small,\n\t\t\t\t\t\tmgp->small_bytes + MXGEFW_PAD,\n\t\t\t\t\t\t1);\n\t\t\tif (ss->rx_small.fill_cnt - ss->rx_small.cnt >=\n\t\t\t    myri10ge_fill_thresh)\n\t\t\t\tss->rx_small.watchdog_needed = 0;\n\t\t}\n\t\tif (ss->rx_big.watchdog_needed) {\n\t\t\tmyri10ge_alloc_rx_pages(mgp, &ss->rx_big,\n\t\t\t\t\t\tmgp->big_bytes, 1);\n\t\t\tif (ss->rx_big.fill_cnt - ss->rx_big.cnt >=\n\t\t\t    myri10ge_fill_thresh)\n\t\t\t\tss->rx_big.watchdog_needed = 0;\n\t\t}\n\t\tmyri10ge_check_slice(ss, &reset_needed, &busy_slice_cnt,\n\t\t\t\t     rx_pause_cnt);\n\t}\n\t \n\tif (busy_slice_cnt == 0) {\n\t\tpci_read_config_word(mgp->pdev, PCI_COMMAND, &cmd);\n\t\tif ((cmd & PCI_COMMAND_MASTER) == 0) {\n\t\t\treset_needed = 1;\n\t\t}\n\t}\n\tmgp->watchdog_pause = rx_pause_cnt;\n\n\tif (reset_needed) {\n\t\tschedule_work(&mgp->watchdog_work);\n\t} else {\n\t\t \n\t\tmod_timer(&mgp->watchdog_timer,\n\t\t\t  jiffies + myri10ge_watchdog_timeout * HZ);\n\t}\n}\n\nstatic void myri10ge_free_slices(struct myri10ge_priv *mgp)\n{\n\tstruct myri10ge_slice_state *ss;\n\tstruct pci_dev *pdev = mgp->pdev;\n\tsize_t bytes;\n\tint i;\n\n\tif (mgp->ss == NULL)\n\t\treturn;\n\n\tfor (i = 0; i < mgp->num_slices; i++) {\n\t\tss = &mgp->ss[i];\n\t\tif (ss->rx_done.entry != NULL) {\n\t\t\tbytes = mgp->max_intr_slots *\n\t\t\t    sizeof(*ss->rx_done.entry);\n\t\t\tdma_free_coherent(&pdev->dev, bytes,\n\t\t\t\t\t  ss->rx_done.entry, ss->rx_done.bus);\n\t\t\tss->rx_done.entry = NULL;\n\t\t}\n\t\tif (ss->fw_stats != NULL) {\n\t\t\tbytes = sizeof(*ss->fw_stats);\n\t\t\tdma_free_coherent(&pdev->dev, bytes,\n\t\t\t\t\t  ss->fw_stats, ss->fw_stats_bus);\n\t\t\tss->fw_stats = NULL;\n\t\t}\n\t\t__netif_napi_del(&ss->napi);\n\t}\n\t \n\tsynchronize_net();\n\tkfree(mgp->ss);\n\tmgp->ss = NULL;\n}\n\nstatic int myri10ge_alloc_slices(struct myri10ge_priv *mgp)\n{\n\tstruct myri10ge_slice_state *ss;\n\tstruct pci_dev *pdev = mgp->pdev;\n\tsize_t bytes;\n\tint i;\n\n\tbytes = sizeof(*mgp->ss) * mgp->num_slices;\n\tmgp->ss = kzalloc(bytes, GFP_KERNEL);\n\tif (mgp->ss == NULL) {\n\t\treturn -ENOMEM;\n\t}\n\n\tfor (i = 0; i < mgp->num_slices; i++) {\n\t\tss = &mgp->ss[i];\n\t\tbytes = mgp->max_intr_slots * sizeof(*ss->rx_done.entry);\n\t\tss->rx_done.entry = dma_alloc_coherent(&pdev->dev, bytes,\n\t\t\t\t\t\t       &ss->rx_done.bus,\n\t\t\t\t\t\t       GFP_KERNEL);\n\t\tif (ss->rx_done.entry == NULL)\n\t\t\tgoto abort;\n\t\tbytes = sizeof(*ss->fw_stats);\n\t\tss->fw_stats = dma_alloc_coherent(&pdev->dev, bytes,\n\t\t\t\t\t\t  &ss->fw_stats_bus,\n\t\t\t\t\t\t  GFP_KERNEL);\n\t\tif (ss->fw_stats == NULL)\n\t\t\tgoto abort;\n\t\tss->mgp = mgp;\n\t\tss->dev = mgp->dev;\n\t\tnetif_napi_add_weight(ss->dev, &ss->napi, myri10ge_poll,\n\t\t\t\t      myri10ge_napi_weight);\n\t}\n\treturn 0;\nabort:\n\tmyri10ge_free_slices(mgp);\n\treturn -ENOMEM;\n}\n\n \nstatic void myri10ge_probe_slices(struct myri10ge_priv *mgp)\n{\n\tstruct myri10ge_cmd cmd;\n\tstruct pci_dev *pdev = mgp->pdev;\n\tchar *old_fw;\n\tbool old_allocated;\n\tint i, status, ncpus;\n\n\tmgp->num_slices = 1;\n\tncpus = netif_get_num_default_rss_queues();\n\n\tif (myri10ge_max_slices == 1 || !pdev->msix_cap ||\n\t    (myri10ge_max_slices == -1 && ncpus < 2))\n\t\treturn;\n\n\t \n\told_fw = mgp->fw_name;\n\told_allocated = mgp->fw_name_allocated;\n\t \n\tmgp->fw_name_allocated = false;\n\n\tif (myri10ge_fw_name != NULL) {\n\t\tdev_info(&mgp->pdev->dev, \"overriding rss firmware to %s\\n\",\n\t\t\t myri10ge_fw_name);\n\t\tset_fw_name(mgp, myri10ge_fw_name, false);\n\t} else if (old_fw == myri10ge_fw_aligned)\n\t\tset_fw_name(mgp, myri10ge_fw_rss_aligned, false);\n\telse\n\t\tset_fw_name(mgp, myri10ge_fw_rss_unaligned, false);\n\tstatus = myri10ge_load_firmware(mgp, 0);\n\tif (status != 0) {\n\t\tdev_info(&pdev->dev, \"Rss firmware not found\\n\");\n\t\tif (old_allocated)\n\t\t\tkfree(old_fw);\n\t\treturn;\n\t}\n\n\t \n\tmemset(&cmd, 0, sizeof(cmd));\n\tstatus = myri10ge_send_cmd(mgp, MXGEFW_CMD_RESET, &cmd, 0);\n\tif (status != 0) {\n\t\tdev_err(&mgp->pdev->dev, \"failed reset\\n\");\n\t\tgoto abort_with_fw;\n\t}\n\n\tmgp->max_intr_slots = cmd.data0 / sizeof(struct mcp_slot);\n\n\t \n\tcmd.data0 = mgp->max_intr_slots * sizeof(struct mcp_slot);\n\tstatus = myri10ge_send_cmd(mgp, MXGEFW_CMD_SET_INTRQ_SIZE, &cmd, 0);\n\tif (status != 0) {\n\t\tdev_err(&mgp->pdev->dev, \"failed MXGEFW_CMD_SET_INTRQ_SIZE\\n\");\n\t\tgoto abort_with_fw;\n\t}\n\n\t \n\tstatus = myri10ge_send_cmd(mgp, MXGEFW_CMD_GET_MAX_RSS_QUEUES, &cmd, 0);\n\tif (status != 0)\n\t\tgoto abort_with_fw;\n\telse\n\t\tmgp->num_slices = cmd.data0;\n\n\t \n\tif (!myri10ge_msi) {\n\t\tgoto abort_with_fw;\n\t}\n\n\t \n\tif (myri10ge_max_slices == -1)\n\t\tmyri10ge_max_slices = ncpus;\n\n\tif (mgp->num_slices > myri10ge_max_slices)\n\t\tmgp->num_slices = myri10ge_max_slices;\n\n\t \n\n\tmgp->msix_vectors = kcalloc(mgp->num_slices, sizeof(*mgp->msix_vectors),\n\t\t\t\t    GFP_KERNEL);\n\tif (mgp->msix_vectors == NULL)\n\t\tgoto no_msix;\n\tfor (i = 0; i < mgp->num_slices; i++) {\n\t\tmgp->msix_vectors[i].entry = i;\n\t}\n\n\twhile (mgp->num_slices > 1) {\n\t\tmgp->num_slices = rounddown_pow_of_two(mgp->num_slices);\n\t\tif (mgp->num_slices == 1)\n\t\t\tgoto no_msix;\n\t\tstatus = pci_enable_msix_range(pdev,\n\t\t\t\t\t       mgp->msix_vectors,\n\t\t\t\t\t       mgp->num_slices,\n\t\t\t\t\t       mgp->num_slices);\n\t\tif (status < 0)\n\t\t\tgoto no_msix;\n\n\t\tpci_disable_msix(pdev);\n\n\t\tif (status == mgp->num_slices) {\n\t\t\tif (old_allocated)\n\t\t\t\tkfree(old_fw);\n\t\t\treturn;\n\t\t} else {\n\t\t\tmgp->num_slices = status;\n\t\t}\n\t}\n\nno_msix:\n\tif (mgp->msix_vectors != NULL) {\n\t\tkfree(mgp->msix_vectors);\n\t\tmgp->msix_vectors = NULL;\n\t}\n\nabort_with_fw:\n\tmgp->num_slices = 1;\n\tset_fw_name(mgp, old_fw, old_allocated);\n\tmyri10ge_load_firmware(mgp, 0);\n}\n\nstatic const struct net_device_ops myri10ge_netdev_ops = {\n\t.ndo_open\t\t= myri10ge_open,\n\t.ndo_stop\t\t= myri10ge_close,\n\t.ndo_start_xmit\t\t= myri10ge_xmit,\n\t.ndo_get_stats64\t= myri10ge_get_stats,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_change_mtu\t\t= myri10ge_change_mtu,\n\t.ndo_set_rx_mode\t= myri10ge_set_multicast_list,\n\t.ndo_set_mac_address\t= myri10ge_set_mac_address,\n};\n\nstatic int myri10ge_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tstruct net_device *netdev;\n\tstruct myri10ge_priv *mgp;\n\tstruct device *dev = &pdev->dev;\n\tint status = -ENXIO;\n\tunsigned hdr_offset, ss_offset;\n\tstatic int board_number;\n\n\tnetdev = alloc_etherdev_mq(sizeof(*mgp), MYRI10GE_MAX_SLICES);\n\tif (netdev == NULL)\n\t\treturn -ENOMEM;\n\n\tSET_NETDEV_DEV(netdev, &pdev->dev);\n\n\tmgp = netdev_priv(netdev);\n\tmgp->dev = netdev;\n\tmgp->pdev = pdev;\n\tmgp->pause = myri10ge_flow_control;\n\tmgp->intr_coal_delay = myri10ge_intr_coal_delay;\n\tmgp->msg_enable = netif_msg_init(myri10ge_debug, MYRI10GE_MSG_DEFAULT);\n\tmgp->board_number = board_number;\n\tinit_waitqueue_head(&mgp->down_wq);\n\n\tif (pci_enable_device(pdev)) {\n\t\tdev_err(&pdev->dev, \"pci_enable_device call failed\\n\");\n\t\tstatus = -ENODEV;\n\t\tgoto abort_with_netdev;\n\t}\n\n\t \n\tmgp->vendor_specific_offset\n\t    = pci_find_capability(pdev, PCI_CAP_ID_VNDR);\n\n\t \n\tstatus = pcie_set_readrq(pdev, 4096);\n\tif (status != 0) {\n\t\tdev_err(&pdev->dev, \"Error %d writing PCI_EXP_DEVCTL\\n\",\n\t\t\tstatus);\n\t\tgoto abort_with_enabled;\n\t}\n\n\tmyri10ge_mask_surprise_down(pdev);\n\tpci_set_master(pdev);\n\tstatus = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(64));\n\tif (status != 0) {\n\t\tdev_err(&pdev->dev, \"Error %d setting DMA mask\\n\", status);\n\t\tgoto abort_with_enabled;\n\t}\n\tmgp->cmd = dma_alloc_coherent(&pdev->dev, sizeof(*mgp->cmd),\n\t\t\t\t      &mgp->cmd_bus, GFP_KERNEL);\n\tif (!mgp->cmd) {\n\t\tstatus = -ENOMEM;\n\t\tgoto abort_with_enabled;\n\t}\n\n\tmgp->board_span = pci_resource_len(pdev, 0);\n\tmgp->iomem_base = pci_resource_start(pdev, 0);\n\tmgp->wc_cookie = arch_phys_wc_add(mgp->iomem_base, mgp->board_span);\n\tmgp->sram = ioremap_wc(mgp->iomem_base, mgp->board_span);\n\tif (mgp->sram == NULL) {\n\t\tdev_err(&pdev->dev, \"ioremap failed for %ld bytes at 0x%lx\\n\",\n\t\t\tmgp->board_span, mgp->iomem_base);\n\t\tstatus = -ENXIO;\n\t\tgoto abort_with_mtrr;\n\t}\n\thdr_offset =\n\t    swab32(readl(mgp->sram + MCP_HEADER_PTR_OFFSET)) & 0xffffc;\n\tss_offset = hdr_offset + offsetof(struct mcp_gen_header, string_specs);\n\tmgp->sram_size = swab32(readl(mgp->sram + ss_offset));\n\tif (mgp->sram_size > mgp->board_span ||\n\t    mgp->sram_size <= MYRI10GE_FW_OFFSET) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"invalid sram_size %dB or board span %ldB\\n\",\n\t\t\tmgp->sram_size, mgp->board_span);\n\t\tstatus = -EINVAL;\n\t\tgoto abort_with_ioremap;\n\t}\n\tmemcpy_fromio(mgp->eeprom_strings,\n\t\t      mgp->sram + mgp->sram_size, MYRI10GE_EEPROM_STRINGS_SIZE);\n\tmemset(mgp->eeprom_strings + MYRI10GE_EEPROM_STRINGS_SIZE - 2, 0, 2);\n\tstatus = myri10ge_read_mac_addr(mgp);\n\tif (status)\n\t\tgoto abort_with_ioremap;\n\n\teth_hw_addr_set(netdev, mgp->mac_addr);\n\n\tmyri10ge_select_firmware(mgp);\n\n\tstatus = myri10ge_load_firmware(mgp, 1);\n\tif (status != 0) {\n\t\tdev_err(&pdev->dev, \"failed to load firmware\\n\");\n\t\tgoto abort_with_ioremap;\n\t}\n\tmyri10ge_probe_slices(mgp);\n\tstatus = myri10ge_alloc_slices(mgp);\n\tif (status != 0) {\n\t\tdev_err(&pdev->dev, \"failed to alloc slice state\\n\");\n\t\tgoto abort_with_firmware;\n\t}\n\tnetif_set_real_num_tx_queues(netdev, mgp->num_slices);\n\tnetif_set_real_num_rx_queues(netdev, mgp->num_slices);\n\tstatus = myri10ge_reset(mgp);\n\tif (status != 0) {\n\t\tdev_err(&pdev->dev, \"failed reset\\n\");\n\t\tgoto abort_with_slices;\n\t}\n#ifdef CONFIG_MYRI10GE_DCA\n\tmyri10ge_setup_dca(mgp);\n#endif\n\tpci_set_drvdata(pdev, mgp);\n\n\t \n\tnetdev->min_mtu = ETH_MIN_MTU;\n\tnetdev->max_mtu = MYRI10GE_MAX_ETHER_MTU - ETH_HLEN;\n\n\tif (myri10ge_initial_mtu > netdev->max_mtu)\n\t\tmyri10ge_initial_mtu = netdev->max_mtu;\n\tif (myri10ge_initial_mtu < netdev->min_mtu)\n\t\tmyri10ge_initial_mtu = netdev->min_mtu;\n\n\tnetdev->mtu = myri10ge_initial_mtu;\n\n\tnetdev->netdev_ops = &myri10ge_netdev_ops;\n\tnetdev->hw_features = mgp->features | NETIF_F_RXCSUM;\n\n\t \n\tnetdev->hw_features |= NETIF_F_HW_VLAN_CTAG_RX;\n\n\tnetdev->features = netdev->hw_features | NETIF_F_HIGHDMA;\n\n\tnetdev->vlan_features |= mgp->features;\n\tif (mgp->fw_ver_tiny < 37)\n\t\tnetdev->vlan_features &= ~NETIF_F_TSO6;\n\tif (mgp->fw_ver_tiny < 32)\n\t\tnetdev->vlan_features &= ~NETIF_F_TSO;\n\n\t \n\tstatus = myri10ge_request_irq(mgp);\n\tif (status != 0)\n\t\tgoto abort_with_slices;\n\tmyri10ge_free_irq(mgp);\n\n\t \n\tpci_save_state(pdev);\n\n\t \n\ttimer_setup(&mgp->watchdog_timer, myri10ge_watchdog_timer, 0);\n\n\tnetdev->ethtool_ops = &myri10ge_ethtool_ops;\n\tINIT_WORK(&mgp->watchdog_work, myri10ge_watchdog);\n\tstatus = register_netdev(netdev);\n\tif (status != 0) {\n\t\tdev_err(&pdev->dev, \"register_netdev failed: %d\\n\", status);\n\t\tgoto abort_with_state;\n\t}\n\tif (mgp->msix_enabled)\n\t\tdev_info(dev, \"%d MSI-X IRQs, tx bndry %d, fw %s, MTRR %s, WC Enabled\\n\",\n\t\t\t mgp->num_slices, mgp->tx_boundary, mgp->fw_name,\n\t\t\t (mgp->wc_cookie > 0 ? \"Enabled\" : \"Disabled\"));\n\telse\n\t\tdev_info(dev, \"%s IRQ %d, tx bndry %d, fw %s, MTRR %s, WC Enabled\\n\",\n\t\t\t mgp->msi_enabled ? \"MSI\" : \"xPIC\",\n\t\t\t pdev->irq, mgp->tx_boundary, mgp->fw_name,\n\t\t\t (mgp->wc_cookie > 0 ? \"Enabled\" : \"Disabled\"));\n\n\tboard_number++;\n\treturn 0;\n\nabort_with_state:\n\tpci_restore_state(pdev);\n\nabort_with_slices:\n\tmyri10ge_free_slices(mgp);\n\nabort_with_firmware:\n\tkfree(mgp->msix_vectors);\n\tmyri10ge_dummy_rdma(mgp, 0);\n\nabort_with_ioremap:\n\tif (mgp->mac_addr_string != NULL)\n\t\tdev_err(&pdev->dev,\n\t\t\t\"myri10ge_probe() failed: MAC=%s, SN=%ld\\n\",\n\t\t\tmgp->mac_addr_string, mgp->serial_number);\n\tiounmap(mgp->sram);\n\nabort_with_mtrr:\n\tarch_phys_wc_del(mgp->wc_cookie);\n\tdma_free_coherent(&pdev->dev, sizeof(*mgp->cmd),\n\t\t\t  mgp->cmd, mgp->cmd_bus);\n\nabort_with_enabled:\n\tpci_disable_device(pdev);\n\nabort_with_netdev:\n\tset_fw_name(mgp, NULL, false);\n\tfree_netdev(netdev);\n\treturn status;\n}\n\n \nstatic void myri10ge_remove(struct pci_dev *pdev)\n{\n\tstruct myri10ge_priv *mgp;\n\tstruct net_device *netdev;\n\n\tmgp = pci_get_drvdata(pdev);\n\tif (mgp == NULL)\n\t\treturn;\n\n\tcancel_work_sync(&mgp->watchdog_work);\n\tnetdev = mgp->dev;\n\tunregister_netdev(netdev);\n\n#ifdef CONFIG_MYRI10GE_DCA\n\tmyri10ge_teardown_dca(mgp);\n#endif\n\tmyri10ge_dummy_rdma(mgp, 0);\n\n\t \n\tpci_restore_state(pdev);\n\n\tiounmap(mgp->sram);\n\tarch_phys_wc_del(mgp->wc_cookie);\n\tmyri10ge_free_slices(mgp);\n\tkfree(mgp->msix_vectors);\n\tdma_free_coherent(&pdev->dev, sizeof(*mgp->cmd),\n\t\t\t  mgp->cmd, mgp->cmd_bus);\n\n\tset_fw_name(mgp, NULL, false);\n\tfree_netdev(netdev);\n\tpci_disable_device(pdev);\n}\n\n#define PCI_DEVICE_ID_MYRICOM_MYRI10GE_Z8E \t0x0008\n#define PCI_DEVICE_ID_MYRICOM_MYRI10GE_Z8E_9\t0x0009\n\nstatic const struct pci_device_id myri10ge_pci_tbl[] = {\n\t{PCI_DEVICE(PCI_VENDOR_ID_MYRICOM, PCI_DEVICE_ID_MYRICOM_MYRI10GE_Z8E)},\n\t{PCI_DEVICE\n\t (PCI_VENDOR_ID_MYRICOM, PCI_DEVICE_ID_MYRICOM_MYRI10GE_Z8E_9)},\n\t{0},\n};\n\nMODULE_DEVICE_TABLE(pci, myri10ge_pci_tbl);\n\nstatic SIMPLE_DEV_PM_OPS(myri10ge_pm_ops, myri10ge_suspend, myri10ge_resume);\n\nstatic struct pci_driver myri10ge_driver = {\n\t.name = \"myri10ge\",\n\t.probe = myri10ge_probe,\n\t.remove = myri10ge_remove,\n\t.id_table = myri10ge_pci_tbl,\n\t.driver.pm = &myri10ge_pm_ops,\n};\n\n#ifdef CONFIG_MYRI10GE_DCA\nstatic int\nmyri10ge_notify_dca(struct notifier_block *nb, unsigned long event, void *p)\n{\n\tint err = driver_for_each_device(&myri10ge_driver.driver,\n\t\t\t\t\t NULL, &event,\n\t\t\t\t\t myri10ge_notify_dca_device);\n\n\tif (err)\n\t\treturn NOTIFY_BAD;\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block myri10ge_dca_notifier = {\n\t.notifier_call = myri10ge_notify_dca,\n\t.next = NULL,\n\t.priority = 0,\n};\n#endif\t\t\t\t \n\nstatic __init int myri10ge_init_module(void)\n{\n\tpr_info(\"Version %s\\n\", MYRI10GE_VERSION_STR);\n\n\tif (myri10ge_rss_hash > MXGEFW_RSS_HASH_TYPE_MAX) {\n\t\tpr_err(\"Illegal rssh hash type %d, defaulting to source port\\n\",\n\t\t       myri10ge_rss_hash);\n\t\tmyri10ge_rss_hash = MXGEFW_RSS_HASH_TYPE_SRC_PORT;\n\t}\n#ifdef CONFIG_MYRI10GE_DCA\n\tdca_register_notify(&myri10ge_dca_notifier);\n#endif\n\tif (myri10ge_max_slices > MYRI10GE_MAX_SLICES)\n\t\tmyri10ge_max_slices = MYRI10GE_MAX_SLICES;\n\n\treturn pci_register_driver(&myri10ge_driver);\n}\n\nmodule_init(myri10ge_init_module);\n\nstatic __exit void myri10ge_cleanup_module(void)\n{\n#ifdef CONFIG_MYRI10GE_DCA\n\tdca_unregister_notify(&myri10ge_dca_notifier);\n#endif\n\tpci_unregister_driver(&myri10ge_driver);\n}\n\nmodule_exit(myri10ge_cleanup_module);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}