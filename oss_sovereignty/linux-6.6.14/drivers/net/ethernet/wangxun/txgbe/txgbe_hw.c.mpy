{
  "module_name": "txgbe_hw.c",
  "hash_id": "e0eb143a0d7d986a886e0f3c837f92d54ddbfd607ec3237d4f183e7653a8f4bd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/wangxun/txgbe/txgbe_hw.c",
  "human_readable_source": "\n \n\n#include <linux/etherdevice.h>\n#include <linux/if_ether.h>\n#include <linux/string.h>\n#include <linux/iopoll.h>\n#include <linux/types.h>\n#include <linux/pci.h>\n\n#include \"../libwx/wx_type.h\"\n#include \"../libwx/wx_hw.h\"\n#include \"txgbe_type.h\"\n#include \"txgbe_hw.h\"\n\n \nint txgbe_disable_sec_tx_path(struct wx *wx)\n{\n\tint val;\n\n\twr32m(wx, WX_TSC_CTL, WX_TSC_CTL_TX_DIS, WX_TSC_CTL_TX_DIS);\n\treturn read_poll_timeout(rd32, val, val & WX_TSC_ST_SECTX_RDY,\n\t\t\t\t 1000, 20000, false, wx, WX_TSC_ST);\n}\n\n \nvoid txgbe_enable_sec_tx_path(struct wx *wx)\n{\n\twr32m(wx, WX_TSC_CTL, WX_TSC_CTL_TX_DIS, 0);\n\tWX_WRITE_FLUSH(wx);\n}\n\n \nstatic void txgbe_init_thermal_sensor_thresh(struct wx *wx)\n{\n\tstruct wx_thermal_sensor_data *data = &wx->mac.sensor;\n\n\tmemset(data, 0, sizeof(struct wx_thermal_sensor_data));\n\n\t \n\tif (wx->bus.func)\n\t\treturn;\n\n\twr32(wx, TXGBE_TS_CTL, TXGBE_TS_CTL_EVAL_MD);\n\n\twr32(wx, WX_TS_INT_EN,\n\t     WX_TS_INT_EN_ALARM_INT_EN | WX_TS_INT_EN_DALARM_INT_EN);\n\twr32(wx, WX_TS_EN, WX_TS_EN_ENA);\n\n\tdata->alarm_thresh = 100;\n\twr32(wx, WX_TS_ALARM_THRE, 677);\n\tdata->dalarm_thresh = 90;\n\twr32(wx, WX_TS_DALARM_THRE, 614);\n}\n\n \nint txgbe_read_pba_string(struct wx *wx, u8 *pba_num, u32 pba_num_size)\n{\n\tu16 pba_ptr, offset, length, data;\n\tint ret_val;\n\n\tif (!pba_num) {\n\t\twx_err(wx, \"PBA string buffer was null\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret_val = wx_read_ee_hostif(wx,\n\t\t\t\t    wx->eeprom.sw_region_offset + TXGBE_PBANUM0_PTR,\n\t\t\t\t    &data);\n\tif (ret_val != 0) {\n\t\twx_err(wx, \"NVM Read Error\\n\");\n\t\treturn ret_val;\n\t}\n\n\tret_val = wx_read_ee_hostif(wx,\n\t\t\t\t    wx->eeprom.sw_region_offset + TXGBE_PBANUM1_PTR,\n\t\t\t\t    &pba_ptr);\n\tif (ret_val != 0) {\n\t\twx_err(wx, \"NVM Read Error\\n\");\n\t\treturn ret_val;\n\t}\n\n\t \n\tif (data != TXGBE_PBANUM_PTR_GUARD) {\n\t\twx_err(wx, \"NVM PBA number is not stored as string\\n\");\n\n\t\t \n\t\tif (pba_num_size < 11) {\n\t\t\twx_err(wx, \"PBA string buffer too small\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\t \n\t\tpba_num[0] = (data >> 12) & 0xF;\n\t\tpba_num[1] = (data >> 8) & 0xF;\n\t\tpba_num[2] = (data >> 4) & 0xF;\n\t\tpba_num[3] = data & 0xF;\n\t\tpba_num[4] = (pba_ptr >> 12) & 0xF;\n\t\tpba_num[5] = (pba_ptr >> 8) & 0xF;\n\t\tpba_num[6] = '-';\n\t\tpba_num[7] = 0;\n\t\tpba_num[8] = (pba_ptr >> 4) & 0xF;\n\t\tpba_num[9] = pba_ptr & 0xF;\n\n\t\t \n\t\tpba_num[10] = '\\0';\n\n\t\t \n\t\tfor (offset = 0; offset < 10; offset++) {\n\t\t\tif (pba_num[offset] < 0xA)\n\t\t\t\tpba_num[offset] += '0';\n\t\t\telse if (pba_num[offset] < 0x10)\n\t\t\t\tpba_num[offset] += 'A' - 0xA;\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tret_val = wx_read_ee_hostif(wx, pba_ptr, &length);\n\tif (ret_val != 0) {\n\t\twx_err(wx, \"NVM Read Error\\n\");\n\t\treturn ret_val;\n\t}\n\n\tif (length == 0xFFFF || length == 0) {\n\t\twx_err(wx, \"NVM PBA number section invalid length\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (pba_num_size  < (((u32)length * 2) - 1)) {\n\t\twx_err(wx, \"PBA string buffer too small\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tpba_ptr++;\n\tlength--;\n\n\tfor (offset = 0; offset < length; offset++) {\n\t\tret_val = wx_read_ee_hostif(wx, pba_ptr + offset, &data);\n\t\tif (ret_val != 0) {\n\t\t\twx_err(wx, \"NVM Read Error\\n\");\n\t\t\treturn ret_val;\n\t\t}\n\t\tpba_num[offset * 2] = (u8)(data >> 8);\n\t\tpba_num[(offset * 2) + 1] = (u8)(data & 0xFF);\n\t}\n\tpba_num[offset * 2] = '\\0';\n\n\treturn 0;\n}\n\n \nstatic int txgbe_calc_eeprom_checksum(struct wx *wx, u16 *checksum)\n{\n\tu16 *eeprom_ptrs = NULL;\n\tu16 *local_buffer;\n\tint status;\n\tu16 i;\n\n\twx_init_eeprom_params(wx);\n\n\teeprom_ptrs = kvmalloc_array(TXGBE_EEPROM_LAST_WORD, sizeof(u16),\n\t\t\t\t     GFP_KERNEL);\n\tif (!eeprom_ptrs)\n\t\treturn -ENOMEM;\n\t \n\tstatus = wx_read_ee_hostif_buffer(wx, 0, TXGBE_EEPROM_LAST_WORD, eeprom_ptrs);\n\tif (status != 0) {\n\t\twx_err(wx, \"Failed to read EEPROM image\\n\");\n\t\tkvfree(eeprom_ptrs);\n\t\treturn status;\n\t}\n\tlocal_buffer = eeprom_ptrs;\n\n\tfor (i = 0; i < TXGBE_EEPROM_LAST_WORD; i++)\n\t\tif (i != wx->eeprom.sw_region_offset + TXGBE_EEPROM_CHECKSUM)\n\t\t\t*checksum += local_buffer[i];\n\n\tif (eeprom_ptrs)\n\t\tkvfree(eeprom_ptrs);\n\n\t*checksum = TXGBE_EEPROM_SUM - *checksum;\n\n\treturn 0;\n}\n\n \nint txgbe_validate_eeprom_checksum(struct wx *wx, u16 *checksum_val)\n{\n\tu16 read_checksum = 0;\n\tu16 checksum;\n\tint status;\n\n\t \n\tstatus = wx_read_ee_hostif(wx, 0, &checksum);\n\tif (status) {\n\t\twx_err(wx, \"EEPROM read failed\\n\");\n\t\treturn status;\n\t}\n\n\tchecksum = 0;\n\tstatus = txgbe_calc_eeprom_checksum(wx, &checksum);\n\tif (status != 0)\n\t\treturn status;\n\n\tstatus = wx_read_ee_hostif(wx, wx->eeprom.sw_region_offset +\n\t\t\t\t   TXGBE_EEPROM_CHECKSUM, &read_checksum);\n\tif (status != 0)\n\t\treturn status;\n\n\t \n\tif (read_checksum != checksum) {\n\t\tstatus = -EIO;\n\t\twx_err(wx, \"Invalid EEPROM checksum\\n\");\n\t}\n\n\t \n\tif (checksum_val)\n\t\t*checksum_val = checksum;\n\n\treturn status;\n}\n\nstatic void txgbe_reset_misc(struct wx *wx)\n{\n\twx_reset_misc(wx);\n\ttxgbe_init_thermal_sensor_thresh(wx);\n}\n\n \nint txgbe_reset_hw(struct wx *wx)\n{\n\tint status;\n\n\t \n\tstatus = wx_stop_adapter(wx);\n\tif (status != 0)\n\t\treturn status;\n\n\tif (wx->media_type != sp_media_copper) {\n\t\tu32 val;\n\n\t\tval = WX_MIS_RST_LAN_RST(wx->bus.func);\n\t\twr32(wx, WX_MIS_RST, val | rd32(wx, WX_MIS_RST));\n\t\tWX_WRITE_FLUSH(wx);\n\t\tusleep_range(10, 100);\n\t}\n\n\tstatus = wx_check_flash_load(wx, TXGBE_SPI_ILDR_STATUS_LAN_SW_RST(wx->bus.func));\n\tif (status != 0)\n\t\treturn status;\n\n\ttxgbe_reset_misc(wx);\n\n\t \n\twx_get_mac_addr(wx, wx->mac.perm_addr);\n\n\t \n\twx->mac.num_rar_entries = TXGBE_SP_RAR_ENTRIES;\n\twx_init_rx_addrs(wx);\n\n\tpci_set_master(wx->pdev);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}