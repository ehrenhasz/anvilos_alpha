{
  "module_name": "txgbe_phy.c",
  "hash_id": "84ec9431c21ab5792da10a6235d16908395095ba5f3a14dca6b3eb22b6c901a7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/wangxun/txgbe/txgbe_phy.c",
  "human_readable_source": "\n \n\n#include <linux/gpio/machine.h>\n#include <linux/gpio/driver.h>\n#include <linux/gpio/property.h>\n#include <linux/clk-provider.h>\n#include <linux/clkdev.h>\n#include <linux/i2c.h>\n#include <linux/pci.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/pcs/pcs-xpcs.h>\n#include <linux/phylink.h>\n\n#include \"../libwx/wx_type.h\"\n#include \"../libwx/wx_lib.h\"\n#include \"../libwx/wx_hw.h\"\n#include \"txgbe_type.h\"\n#include \"txgbe_phy.h\"\n#include \"txgbe_hw.h\"\n\nstatic int txgbe_swnodes_register(struct txgbe *txgbe)\n{\n\tstruct txgbe_nodes *nodes = &txgbe->nodes;\n\tstruct pci_dev *pdev = txgbe->wx->pdev;\n\tstruct software_node *swnodes;\n\tu32 id;\n\n\tid = pci_dev_id(pdev);\n\n\tsnprintf(nodes->gpio_name, sizeof(nodes->gpio_name), \"txgbe_gpio-%x\", id);\n\tsnprintf(nodes->i2c_name, sizeof(nodes->i2c_name), \"txgbe_i2c-%x\", id);\n\tsnprintf(nodes->sfp_name, sizeof(nodes->sfp_name), \"txgbe_sfp-%x\", id);\n\tsnprintf(nodes->phylink_name, sizeof(nodes->phylink_name), \"txgbe_phylink-%x\", id);\n\n\tswnodes = nodes->swnodes;\n\n\t \n\tnodes->gpio_props[0] = PROPERTY_ENTRY_STRING(\"pinctrl-names\", \"default\");\n\tswnodes[SWNODE_GPIO] = NODE_PROP(nodes->gpio_name, nodes->gpio_props);\n\tnodes->gpio0_ref[0] = SOFTWARE_NODE_REFERENCE(&swnodes[SWNODE_GPIO], 0, GPIO_ACTIVE_HIGH);\n\tnodes->gpio1_ref[0] = SOFTWARE_NODE_REFERENCE(&swnodes[SWNODE_GPIO], 1, GPIO_ACTIVE_HIGH);\n\tnodes->gpio2_ref[0] = SOFTWARE_NODE_REFERENCE(&swnodes[SWNODE_GPIO], 2, GPIO_ACTIVE_LOW);\n\tnodes->gpio3_ref[0] = SOFTWARE_NODE_REFERENCE(&swnodes[SWNODE_GPIO], 3, GPIO_ACTIVE_HIGH);\n\tnodes->gpio4_ref[0] = SOFTWARE_NODE_REFERENCE(&swnodes[SWNODE_GPIO], 4, GPIO_ACTIVE_HIGH);\n\tnodes->gpio5_ref[0] = SOFTWARE_NODE_REFERENCE(&swnodes[SWNODE_GPIO], 5, GPIO_ACTIVE_HIGH);\n\n\tnodes->i2c_props[0] = PROPERTY_ENTRY_STRING(\"compatible\", \"snps,designware-i2c\");\n\tnodes->i2c_props[1] = PROPERTY_ENTRY_BOOL(\"wx,i2c-snps-model\");\n\tnodes->i2c_props[2] = PROPERTY_ENTRY_U32(\"clock-frequency\", I2C_MAX_STANDARD_MODE_FREQ);\n\tswnodes[SWNODE_I2C] = NODE_PROP(nodes->i2c_name, nodes->i2c_props);\n\tnodes->i2c_ref[0] = SOFTWARE_NODE_REFERENCE(&swnodes[SWNODE_I2C]);\n\n\tnodes->sfp_props[0] = PROPERTY_ENTRY_STRING(\"compatible\", \"sff,sfp\");\n\tnodes->sfp_props[1] = PROPERTY_ENTRY_REF_ARRAY(\"i2c-bus\", nodes->i2c_ref);\n\tnodes->sfp_props[2] = PROPERTY_ENTRY_REF_ARRAY(\"tx-fault-gpios\", nodes->gpio0_ref);\n\tnodes->sfp_props[3] = PROPERTY_ENTRY_REF_ARRAY(\"tx-disable-gpios\", nodes->gpio1_ref);\n\tnodes->sfp_props[4] = PROPERTY_ENTRY_REF_ARRAY(\"mod-def0-gpios\", nodes->gpio2_ref);\n\tnodes->sfp_props[5] = PROPERTY_ENTRY_REF_ARRAY(\"los-gpios\", nodes->gpio3_ref);\n\tnodes->sfp_props[6] = PROPERTY_ENTRY_REF_ARRAY(\"rate-select1-gpios\", nodes->gpio4_ref);\n\tnodes->sfp_props[7] = PROPERTY_ENTRY_REF_ARRAY(\"rate-select0-gpios\", nodes->gpio5_ref);\n\tswnodes[SWNODE_SFP] = NODE_PROP(nodes->sfp_name, nodes->sfp_props);\n\tnodes->sfp_ref[0] = SOFTWARE_NODE_REFERENCE(&swnodes[SWNODE_SFP]);\n\n\tnodes->phylink_props[0] = PROPERTY_ENTRY_STRING(\"managed\", \"in-band-status\");\n\tnodes->phylink_props[1] = PROPERTY_ENTRY_REF_ARRAY(\"sfp\", nodes->sfp_ref);\n\tswnodes[SWNODE_PHYLINK] = NODE_PROP(nodes->phylink_name, nodes->phylink_props);\n\n\tnodes->group[SWNODE_GPIO] = &swnodes[SWNODE_GPIO];\n\tnodes->group[SWNODE_I2C] = &swnodes[SWNODE_I2C];\n\tnodes->group[SWNODE_SFP] = &swnodes[SWNODE_SFP];\n\tnodes->group[SWNODE_PHYLINK] = &swnodes[SWNODE_PHYLINK];\n\n\treturn software_node_register_node_group(nodes->group);\n}\n\nstatic int txgbe_pcs_read(struct mii_bus *bus, int addr, int devnum, int regnum)\n{\n\tstruct wx *wx  = bus->priv;\n\tu32 offset, val;\n\n\tif (addr)\n\t\treturn -EOPNOTSUPP;\n\n\toffset = devnum << 16 | regnum;\n\n\t \n\twr32(wx, TXGBE_XPCS_IDA_ADDR, offset);\n\n\t \n\tval = rd32(wx, TXGBE_XPCS_IDA_DATA);\n\n\treturn (u16)val;\n}\n\nstatic int txgbe_pcs_write(struct mii_bus *bus, int addr, int devnum, int regnum, u16 val)\n{\n\tstruct wx *wx = bus->priv;\n\tu32 offset;\n\n\tif (addr)\n\t\treturn -EOPNOTSUPP;\n\n\toffset = devnum << 16 | regnum;\n\n\t \n\twr32(wx, TXGBE_XPCS_IDA_ADDR, offset);\n\n\t \n\twr32(wx, TXGBE_XPCS_IDA_DATA, val);\n\n\treturn 0;\n}\n\nstatic int txgbe_mdio_pcs_init(struct txgbe *txgbe)\n{\n\tstruct mii_bus *mii_bus;\n\tstruct dw_xpcs *xpcs;\n\tstruct pci_dev *pdev;\n\tstruct wx *wx;\n\tint ret = 0;\n\n\twx = txgbe->wx;\n\tpdev = wx->pdev;\n\n\tmii_bus = devm_mdiobus_alloc(&pdev->dev);\n\tif (!mii_bus)\n\t\treturn -ENOMEM;\n\n\tmii_bus->name = \"txgbe_pcs_mdio_bus\";\n\tmii_bus->read_c45 = &txgbe_pcs_read;\n\tmii_bus->write_c45 = &txgbe_pcs_write;\n\tmii_bus->parent = &pdev->dev;\n\tmii_bus->phy_mask = ~0;\n\tmii_bus->priv = wx;\n\tsnprintf(mii_bus->id, MII_BUS_ID_SIZE, \"txgbe_pcs-%x\",\n\t\t pci_dev_id(pdev));\n\n\tret = devm_mdiobus_register(&pdev->dev, mii_bus);\n\tif (ret)\n\t\treturn ret;\n\n\txpcs = xpcs_create_mdiodev(mii_bus, 0, PHY_INTERFACE_MODE_10GBASER);\n\tif (IS_ERR(xpcs))\n\t\treturn PTR_ERR(xpcs);\n\n\ttxgbe->xpcs = xpcs;\n\n\treturn 0;\n}\n\nstatic struct phylink_pcs *txgbe_phylink_mac_select(struct phylink_config *config,\n\t\t\t\t\t\t    phy_interface_t interface)\n{\n\tstruct txgbe *txgbe = netdev_to_txgbe(to_net_dev(config->dev));\n\n\tif (interface == PHY_INTERFACE_MODE_10GBASER)\n\t\treturn &txgbe->xpcs->pcs;\n\n\treturn NULL;\n}\n\nstatic void txgbe_mac_config(struct phylink_config *config, unsigned int mode,\n\t\t\t     const struct phylink_link_state *state)\n{\n}\n\nstatic void txgbe_mac_link_down(struct phylink_config *config,\n\t\t\t\tunsigned int mode, phy_interface_t interface)\n{\n\tstruct wx *wx = netdev_priv(to_net_dev(config->dev));\n\n\twr32m(wx, WX_MAC_TX_CFG, WX_MAC_TX_CFG_TE, 0);\n}\n\nstatic void txgbe_mac_link_up(struct phylink_config *config,\n\t\t\t      struct phy_device *phy,\n\t\t\t      unsigned int mode, phy_interface_t interface,\n\t\t\t      int speed, int duplex,\n\t\t\t      bool tx_pause, bool rx_pause)\n{\n\tstruct wx *wx = netdev_priv(to_net_dev(config->dev));\n\tu32 txcfg, wdg;\n\n\ttxcfg = rd32(wx, WX_MAC_TX_CFG);\n\ttxcfg &= ~WX_MAC_TX_CFG_SPEED_MASK;\n\n\tswitch (speed) {\n\tcase SPEED_10000:\n\t\ttxcfg |= WX_MAC_TX_CFG_SPEED_10G;\n\t\tbreak;\n\tcase SPEED_1000:\n\tcase SPEED_100:\n\tcase SPEED_10:\n\t\ttxcfg |= WX_MAC_TX_CFG_SPEED_1G;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\twr32(wx, WX_MAC_TX_CFG, txcfg | WX_MAC_TX_CFG_TE);\n\n\t \n\twr32m(wx, WX_MAC_RX_CFG, WX_MAC_RX_CFG_RE, WX_MAC_RX_CFG_RE);\n\twr32(wx, WX_MAC_PKT_FLT, WX_MAC_PKT_FLT_PR);\n\twdg = rd32(wx, WX_MAC_WDG_TIMEOUT);\n\twr32(wx, WX_MAC_WDG_TIMEOUT, wdg);\n}\n\nstatic int txgbe_mac_prepare(struct phylink_config *config, unsigned int mode,\n\t\t\t     phy_interface_t interface)\n{\n\tstruct wx *wx = netdev_priv(to_net_dev(config->dev));\n\n\twr32m(wx, WX_MAC_TX_CFG, WX_MAC_TX_CFG_TE, 0);\n\twr32m(wx, WX_MAC_RX_CFG, WX_MAC_RX_CFG_RE, 0);\n\n\treturn txgbe_disable_sec_tx_path(wx);\n}\n\nstatic int txgbe_mac_finish(struct phylink_config *config, unsigned int mode,\n\t\t\t    phy_interface_t interface)\n{\n\tstruct wx *wx = netdev_priv(to_net_dev(config->dev));\n\n\ttxgbe_enable_sec_tx_path(wx);\n\twr32m(wx, WX_MAC_RX_CFG, WX_MAC_RX_CFG_RE, WX_MAC_RX_CFG_RE);\n\n\treturn 0;\n}\n\nstatic const struct phylink_mac_ops txgbe_mac_ops = {\n\t.mac_select_pcs = txgbe_phylink_mac_select,\n\t.mac_prepare = txgbe_mac_prepare,\n\t.mac_finish = txgbe_mac_finish,\n\t.mac_config = txgbe_mac_config,\n\t.mac_link_down = txgbe_mac_link_down,\n\t.mac_link_up = txgbe_mac_link_up,\n};\n\nstatic int txgbe_phylink_init(struct txgbe *txgbe)\n{\n\tstruct fwnode_handle *fwnode = NULL;\n\tstruct phylink_config *config;\n\tstruct wx *wx = txgbe->wx;\n\tphy_interface_t phy_mode;\n\tstruct phylink *phylink;\n\n\tconfig = devm_kzalloc(&wx->pdev->dev, sizeof(*config), GFP_KERNEL);\n\tif (!config)\n\t\treturn -ENOMEM;\n\n\tconfig->dev = &wx->netdev->dev;\n\tconfig->type = PHYLINK_NETDEV;\n\tconfig->mac_capabilities = MAC_10000FD | MAC_1000FD | MAC_100FD |\n\t\t\t\t   MAC_SYM_PAUSE | MAC_ASYM_PAUSE;\n\n\tif (wx->media_type == sp_media_copper) {\n\t\tphy_mode = PHY_INTERFACE_MODE_XAUI;\n\t\t__set_bit(PHY_INTERFACE_MODE_XAUI, config->supported_interfaces);\n\t} else {\n\t\tphy_mode = PHY_INTERFACE_MODE_10GBASER;\n\t\tfwnode = software_node_fwnode(txgbe->nodes.group[SWNODE_PHYLINK]);\n\t\t__set_bit(PHY_INTERFACE_MODE_10GBASER, config->supported_interfaces);\n\t\t__set_bit(PHY_INTERFACE_MODE_1000BASEX, config->supported_interfaces);\n\t\t__set_bit(PHY_INTERFACE_MODE_SGMII, config->supported_interfaces);\n\t}\n\n\tphylink = phylink_create(config, fwnode, phy_mode, &txgbe_mac_ops);\n\tif (IS_ERR(phylink))\n\t\treturn PTR_ERR(phylink);\n\n\tif (wx->phydev) {\n\t\tint ret;\n\n\t\tret = phylink_connect_phy(phylink, wx->phydev);\n\t\tif (ret) {\n\t\t\tphylink_destroy(phylink);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\ttxgbe->phylink = phylink;\n\n\treturn 0;\n}\n\nstatic int txgbe_gpio_get(struct gpio_chip *chip, unsigned int offset)\n{\n\tstruct wx *wx = gpiochip_get_data(chip);\n\tint val;\n\n\tval = rd32m(wx, WX_GPIO_EXT, BIT(offset));\n\n\treturn !!(val & BIT(offset));\n}\n\nstatic int txgbe_gpio_get_direction(struct gpio_chip *chip, unsigned int offset)\n{\n\tstruct wx *wx = gpiochip_get_data(chip);\n\tu32 val;\n\n\tval = rd32(wx, WX_GPIO_DDR);\n\tif (BIT(offset) & val)\n\t\treturn GPIO_LINE_DIRECTION_OUT;\n\n\treturn GPIO_LINE_DIRECTION_IN;\n}\n\nstatic int txgbe_gpio_direction_in(struct gpio_chip *chip, unsigned int offset)\n{\n\tstruct wx *wx = gpiochip_get_data(chip);\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&wx->gpio_lock, flags);\n\twr32m(wx, WX_GPIO_DDR, BIT(offset), 0);\n\traw_spin_unlock_irqrestore(&wx->gpio_lock, flags);\n\n\treturn 0;\n}\n\nstatic int txgbe_gpio_direction_out(struct gpio_chip *chip, unsigned int offset,\n\t\t\t\t    int val)\n{\n\tstruct wx *wx = gpiochip_get_data(chip);\n\tunsigned long flags;\n\tu32 set;\n\n\tset = val ? BIT(offset) : 0;\n\n\traw_spin_lock_irqsave(&wx->gpio_lock, flags);\n\twr32m(wx, WX_GPIO_DR, BIT(offset), set);\n\twr32m(wx, WX_GPIO_DDR, BIT(offset), BIT(offset));\n\traw_spin_unlock_irqrestore(&wx->gpio_lock, flags);\n\n\treturn 0;\n}\n\nstatic void txgbe_gpio_irq_ack(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tirq_hw_number_t hwirq = irqd_to_hwirq(d);\n\tstruct wx *wx = gpiochip_get_data(gc);\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&wx->gpio_lock, flags);\n\twr32(wx, WX_GPIO_EOI, BIT(hwirq));\n\traw_spin_unlock_irqrestore(&wx->gpio_lock, flags);\n}\n\nstatic void txgbe_gpio_irq_mask(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tirq_hw_number_t hwirq = irqd_to_hwirq(d);\n\tstruct wx *wx = gpiochip_get_data(gc);\n\tunsigned long flags;\n\n\tgpiochip_disable_irq(gc, hwirq);\n\n\traw_spin_lock_irqsave(&wx->gpio_lock, flags);\n\twr32m(wx, WX_GPIO_INTMASK, BIT(hwirq), BIT(hwirq));\n\traw_spin_unlock_irqrestore(&wx->gpio_lock, flags);\n}\n\nstatic void txgbe_gpio_irq_unmask(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tirq_hw_number_t hwirq = irqd_to_hwirq(d);\n\tstruct wx *wx = gpiochip_get_data(gc);\n\tunsigned long flags;\n\n\tgpiochip_enable_irq(gc, hwirq);\n\n\traw_spin_lock_irqsave(&wx->gpio_lock, flags);\n\twr32m(wx, WX_GPIO_INTMASK, BIT(hwirq), 0);\n\traw_spin_unlock_irqrestore(&wx->gpio_lock, flags);\n}\n\nstatic void txgbe_toggle_trigger(struct gpio_chip *gc, unsigned int offset)\n{\n\tstruct wx *wx = gpiochip_get_data(gc);\n\tu32 pol, val;\n\n\tpol = rd32(wx, WX_GPIO_POLARITY);\n\tval = rd32(wx, WX_GPIO_EXT);\n\n\tif (val & BIT(offset))\n\t\tpol &= ~BIT(offset);\n\telse\n\t\tpol |= BIT(offset);\n\n\twr32(wx, WX_GPIO_POLARITY, pol);\n}\n\nstatic int txgbe_gpio_set_type(struct irq_data *d, unsigned int type)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tirq_hw_number_t hwirq = irqd_to_hwirq(d);\n\tstruct wx *wx = gpiochip_get_data(gc);\n\tu32 level, polarity, mask;\n\tunsigned long flags;\n\n\tmask = BIT(hwirq);\n\n\tif (type & IRQ_TYPE_LEVEL_MASK) {\n\t\tlevel = 0;\n\t\tirq_set_handler_locked(d, handle_level_irq);\n\t} else {\n\t\tlevel = mask;\n\t\tirq_set_handler_locked(d, handle_edge_irq);\n\t}\n\n\tif (type == IRQ_TYPE_EDGE_RISING || type == IRQ_TYPE_LEVEL_HIGH)\n\t\tpolarity = mask;\n\telse\n\t\tpolarity = 0;\n\n\traw_spin_lock_irqsave(&wx->gpio_lock, flags);\n\n\twr32m(wx, WX_GPIO_INTEN, mask, mask);\n\twr32m(wx, WX_GPIO_INTTYPE_LEVEL, mask, level);\n\tif (type == IRQ_TYPE_EDGE_BOTH)\n\t\ttxgbe_toggle_trigger(gc, hwirq);\n\telse\n\t\twr32m(wx, WX_GPIO_POLARITY, mask, polarity);\n\n\traw_spin_unlock_irqrestore(&wx->gpio_lock, flags);\n\n\treturn 0;\n}\n\nstatic const struct irq_chip txgbe_gpio_irq_chip = {\n\t.name = \"txgbe_gpio_irq\",\n\t.irq_ack = txgbe_gpio_irq_ack,\n\t.irq_mask = txgbe_gpio_irq_mask,\n\t.irq_unmask = txgbe_gpio_irq_unmask,\n\t.irq_set_type = txgbe_gpio_set_type,\n\t.flags = IRQCHIP_IMMUTABLE,\n\tGPIOCHIP_IRQ_RESOURCE_HELPERS,\n};\n\nstatic void txgbe_irq_handler(struct irq_desc *desc)\n{\n\tstruct irq_chip *chip = irq_desc_get_chip(desc);\n\tstruct wx *wx = irq_desc_get_handler_data(desc);\n\tstruct txgbe *txgbe = wx->priv;\n\tirq_hw_number_t hwirq;\n\tunsigned long gpioirq;\n\tstruct gpio_chip *gc;\n\tunsigned long flags;\n\tu32 eicr;\n\n\teicr = wx_misc_isb(wx, WX_ISB_MISC);\n\n\tchained_irq_enter(chip, desc);\n\n\tgpioirq = rd32(wx, WX_GPIO_INTSTATUS);\n\n\tgc = txgbe->gpio;\n\tfor_each_set_bit(hwirq, &gpioirq, gc->ngpio) {\n\t\tint gpio = irq_find_mapping(gc->irq.domain, hwirq);\n\t\tu32 irq_type = irq_get_trigger_type(gpio);\n\n\t\tgeneric_handle_domain_irq(gc->irq.domain, hwirq);\n\n\t\tif ((irq_type & IRQ_TYPE_SENSE_MASK) == IRQ_TYPE_EDGE_BOTH) {\n\t\t\traw_spin_lock_irqsave(&wx->gpio_lock, flags);\n\t\t\ttxgbe_toggle_trigger(gc, hwirq);\n\t\t\traw_spin_unlock_irqrestore(&wx->gpio_lock, flags);\n\t\t}\n\t}\n\n\tchained_irq_exit(chip, desc);\n\n\tif (eicr & (TXGBE_PX_MISC_ETH_LK | TXGBE_PX_MISC_ETH_LKDN |\n\t\t    TXGBE_PX_MISC_ETH_AN)) {\n\t\tu32 reg = rd32(wx, TXGBE_CFG_PORT_ST);\n\n\t\tphylink_mac_change(txgbe->phylink, !!(reg & TXGBE_CFG_PORT_ST_LINK_UP));\n\t}\n\n\t \n\twx_intr_enable(wx, TXGBE_INTR_MISC(wx));\n}\n\nstatic int txgbe_gpio_init(struct txgbe *txgbe)\n{\n\tstruct gpio_irq_chip *girq;\n\tstruct gpio_chip *gc;\n\tstruct device *dev;\n\tstruct wx *wx;\n\tint ret;\n\n\twx = txgbe->wx;\n\tdev = &wx->pdev->dev;\n\n\traw_spin_lock_init(&wx->gpio_lock);\n\n\tgc = devm_kzalloc(dev, sizeof(*gc), GFP_KERNEL);\n\tif (!gc)\n\t\treturn -ENOMEM;\n\n\tgc->label = devm_kasprintf(dev, GFP_KERNEL, \"txgbe_gpio-%x\",\n\t\t\t\t   pci_dev_id(wx->pdev));\n\tif (!gc->label)\n\t\treturn -ENOMEM;\n\n\tgc->base = -1;\n\tgc->ngpio = 6;\n\tgc->owner = THIS_MODULE;\n\tgc->parent = dev;\n\tgc->fwnode = software_node_fwnode(txgbe->nodes.group[SWNODE_GPIO]);\n\tgc->get = txgbe_gpio_get;\n\tgc->get_direction = txgbe_gpio_get_direction;\n\tgc->direction_input = txgbe_gpio_direction_in;\n\tgc->direction_output = txgbe_gpio_direction_out;\n\n\tgirq = &gc->irq;\n\tgpio_irq_chip_set_chip(girq, &txgbe_gpio_irq_chip);\n\tgirq->parent_handler = txgbe_irq_handler;\n\tgirq->parent_handler_data = wx;\n\tgirq->num_parents = 1;\n\tgirq->parents = devm_kcalloc(dev, girq->num_parents,\n\t\t\t\t     sizeof(*girq->parents), GFP_KERNEL);\n\tif (!girq->parents)\n\t\treturn -ENOMEM;\n\tgirq->parents[0] = wx->msix_entries[wx->num_q_vectors].vector;\n\tgirq->default_type = IRQ_TYPE_NONE;\n\tgirq->handler = handle_bad_irq;\n\n\tret = devm_gpiochip_add_data(dev, gc, wx);\n\tif (ret)\n\t\treturn ret;\n\n\ttxgbe->gpio = gc;\n\n\treturn 0;\n}\n\nstatic int txgbe_clock_register(struct txgbe *txgbe)\n{\n\tstruct pci_dev *pdev = txgbe->wx->pdev;\n\tstruct clk_lookup *clock;\n\tchar clk_name[32];\n\tstruct clk *clk;\n\n\tsnprintf(clk_name, sizeof(clk_name), \"i2c_designware.%d\",\n\t\t pci_dev_id(pdev));\n\n\tclk = clk_register_fixed_rate(NULL, clk_name, NULL, 0, 156250000);\n\tif (IS_ERR(clk))\n\t\treturn PTR_ERR(clk);\n\n\tclock = clkdev_create(clk, NULL, clk_name);\n\tif (!clock) {\n\t\tclk_unregister(clk);\n\t\treturn -ENOMEM;\n\t}\n\n\ttxgbe->clk = clk;\n\ttxgbe->clock = clock;\n\n\treturn 0;\n}\n\nstatic int txgbe_i2c_read(void *context, unsigned int reg, unsigned int *val)\n{\n\tstruct wx *wx = context;\n\n\t*val = rd32(wx, reg + TXGBE_I2C_BASE);\n\n\treturn 0;\n}\n\nstatic int txgbe_i2c_write(void *context, unsigned int reg, unsigned int val)\n{\n\tstruct wx *wx = context;\n\n\twr32(wx, reg + TXGBE_I2C_BASE, val);\n\n\treturn 0;\n}\n\nstatic const struct regmap_config i2c_regmap_config = {\n\t.reg_bits = 32,\n\t.val_bits = 32,\n\t.reg_read = txgbe_i2c_read,\n\t.reg_write = txgbe_i2c_write,\n\t.fast_io = true,\n};\n\nstatic int txgbe_i2c_register(struct txgbe *txgbe)\n{\n\tstruct platform_device_info info = {};\n\tstruct platform_device *i2c_dev;\n\tstruct regmap *i2c_regmap;\n\tstruct pci_dev *pdev;\n\tstruct wx *wx;\n\n\twx = txgbe->wx;\n\tpdev = wx->pdev;\n\ti2c_regmap = devm_regmap_init(&pdev->dev, NULL, wx, &i2c_regmap_config);\n\tif (IS_ERR(i2c_regmap)) {\n\t\twx_err(wx, \"failed to init I2C regmap\\n\");\n\t\treturn PTR_ERR(i2c_regmap);\n\t}\n\n\tinfo.parent = &pdev->dev;\n\tinfo.fwnode = software_node_fwnode(txgbe->nodes.group[SWNODE_I2C]);\n\tinfo.name = \"i2c_designware\";\n\tinfo.id = pci_dev_id(pdev);\n\n\tinfo.res = &DEFINE_RES_IRQ(pdev->irq);\n\tinfo.num_res = 1;\n\ti2c_dev = platform_device_register_full(&info);\n\tif (IS_ERR(i2c_dev))\n\t\treturn PTR_ERR(i2c_dev);\n\n\ttxgbe->i2c_dev = i2c_dev;\n\n\treturn 0;\n}\n\nstatic int txgbe_sfp_register(struct txgbe *txgbe)\n{\n\tstruct pci_dev *pdev = txgbe->wx->pdev;\n\tstruct platform_device_info info = {};\n\tstruct platform_device *sfp_dev;\n\n\tinfo.parent = &pdev->dev;\n\tinfo.fwnode = software_node_fwnode(txgbe->nodes.group[SWNODE_SFP]);\n\tinfo.name = \"sfp\";\n\tinfo.id = pci_dev_id(pdev);\n\tsfp_dev = platform_device_register_full(&info);\n\tif (IS_ERR(sfp_dev))\n\t\treturn PTR_ERR(sfp_dev);\n\n\ttxgbe->sfp_dev = sfp_dev;\n\n\treturn 0;\n}\n\nstatic int txgbe_phy_read(struct mii_bus *bus, int phy_addr,\n\t\t\t  int devnum, int regnum)\n{\n\tstruct wx *wx = bus->priv;\n\tu32 val, command;\n\tint ret;\n\n\t \n\tcommand = WX_MSCA_RA(regnum) |\n\t\t  WX_MSCA_PA(phy_addr) |\n\t\t  WX_MSCA_DA(devnum);\n\twr32(wx, WX_MSCA, command);\n\n\tcommand = WX_MSCC_CMD(WX_MSCA_CMD_READ) | WX_MSCC_BUSY;\n\twr32(wx, WX_MSCC, command);\n\n\t \n\tret = read_poll_timeout(rd32, val, !(val & WX_MSCC_BUSY), 1000,\n\t\t\t\t100000, false, wx, WX_MSCC);\n\tif (ret) {\n\t\twx_err(wx, \"Mdio read c45 command did not complete.\\n\");\n\t\treturn ret;\n\t}\n\n\treturn (u16)rd32(wx, WX_MSCC);\n}\n\nstatic int txgbe_phy_write(struct mii_bus *bus, int phy_addr,\n\t\t\t   int devnum, int regnum, u16 value)\n{\n\tstruct wx *wx = bus->priv;\n\tint ret, command;\n\tu16 val;\n\n\t \n\tcommand = WX_MSCA_RA(regnum) |\n\t\t  WX_MSCA_PA(phy_addr) |\n\t\t  WX_MSCA_DA(devnum);\n\twr32(wx, WX_MSCA, command);\n\n\tcommand = value | WX_MSCC_CMD(WX_MSCA_CMD_WRITE) | WX_MSCC_BUSY;\n\twr32(wx, WX_MSCC, command);\n\n\t \n\tret = read_poll_timeout(rd32, val, !(val & WX_MSCC_BUSY), 1000,\n\t\t\t\t100000, false, wx, WX_MSCC);\n\tif (ret)\n\t\twx_err(wx, \"Mdio write c45 command did not complete.\\n\");\n\n\treturn ret;\n}\n\nstatic int txgbe_ext_phy_init(struct txgbe *txgbe)\n{\n\tstruct phy_device *phydev;\n\tstruct mii_bus *mii_bus;\n\tstruct pci_dev *pdev;\n\tstruct wx *wx;\n\tint ret = 0;\n\n\twx = txgbe->wx;\n\tpdev = wx->pdev;\n\n\tmii_bus = devm_mdiobus_alloc(&pdev->dev);\n\tif (!mii_bus)\n\t\treturn -ENOMEM;\n\n\tmii_bus->name = \"txgbe_mii_bus\";\n\tmii_bus->read_c45 = &txgbe_phy_read;\n\tmii_bus->write_c45 = &txgbe_phy_write;\n\tmii_bus->parent = &pdev->dev;\n\tmii_bus->phy_mask = GENMASK(31, 1);\n\tmii_bus->priv = wx;\n\tsnprintf(mii_bus->id, MII_BUS_ID_SIZE, \"txgbe-%x\",\n\t\t (pdev->bus->number << 8) | pdev->devfn);\n\n\tret = devm_mdiobus_register(&pdev->dev, mii_bus);\n\tif (ret) {\n\t\twx_err(wx, \"failed to register MDIO bus: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tphydev = phy_find_first(mii_bus);\n\tif (!phydev) {\n\t\twx_err(wx, \"no PHY found\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tphy_attached_info(phydev);\n\n\twx->link = 0;\n\twx->speed = 0;\n\twx->duplex = 0;\n\twx->phydev = phydev;\n\n\tret = txgbe_phylink_init(txgbe);\n\tif (ret) {\n\t\twx_err(wx, \"failed to init phylink: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nint txgbe_init_phy(struct txgbe *txgbe)\n{\n\tint ret;\n\n\tif (txgbe->wx->media_type == sp_media_copper)\n\t\treturn txgbe_ext_phy_init(txgbe);\n\n\tret = txgbe_swnodes_register(txgbe);\n\tif (ret) {\n\t\twx_err(txgbe->wx, \"failed to register software nodes\\n\");\n\t\treturn ret;\n\t}\n\n\tret = txgbe_mdio_pcs_init(txgbe);\n\tif (ret) {\n\t\twx_err(txgbe->wx, \"failed to init mdio pcs: %d\\n\", ret);\n\t\tgoto err_unregister_swnode;\n\t}\n\n\tret = txgbe_phylink_init(txgbe);\n\tif (ret) {\n\t\twx_err(txgbe->wx, \"failed to init phylink\\n\");\n\t\tgoto err_destroy_xpcs;\n\t}\n\n\tret = txgbe_gpio_init(txgbe);\n\tif (ret) {\n\t\twx_err(txgbe->wx, \"failed to init gpio\\n\");\n\t\tgoto err_destroy_phylink;\n\t}\n\n\tret = txgbe_clock_register(txgbe);\n\tif (ret) {\n\t\twx_err(txgbe->wx, \"failed to register clock: %d\\n\", ret);\n\t\tgoto err_destroy_phylink;\n\t}\n\n\tret = txgbe_i2c_register(txgbe);\n\tif (ret) {\n\t\twx_err(txgbe->wx, \"failed to init i2c interface: %d\\n\", ret);\n\t\tgoto err_unregister_clk;\n\t}\n\n\tret = txgbe_sfp_register(txgbe);\n\tif (ret) {\n\t\twx_err(txgbe->wx, \"failed to register sfp\\n\");\n\t\tgoto err_unregister_i2c;\n\t}\n\n\treturn 0;\n\nerr_unregister_i2c:\n\tplatform_device_unregister(txgbe->i2c_dev);\nerr_unregister_clk:\n\tclkdev_drop(txgbe->clock);\n\tclk_unregister(txgbe->clk);\nerr_destroy_phylink:\n\tphylink_destroy(txgbe->phylink);\nerr_destroy_xpcs:\n\txpcs_destroy(txgbe->xpcs);\nerr_unregister_swnode:\n\tsoftware_node_unregister_node_group(txgbe->nodes.group);\n\n\treturn ret;\n}\n\nvoid txgbe_remove_phy(struct txgbe *txgbe)\n{\n\tif (txgbe->wx->media_type == sp_media_copper) {\n\t\tphylink_disconnect_phy(txgbe->phylink);\n\t\tphylink_destroy(txgbe->phylink);\n\t\treturn;\n\t}\n\n\tplatform_device_unregister(txgbe->sfp_dev);\n\tplatform_device_unregister(txgbe->i2c_dev);\n\tclkdev_drop(txgbe->clock);\n\tclk_unregister(txgbe->clk);\n\tphylink_destroy(txgbe->phylink);\n\txpcs_destroy(txgbe->xpcs);\n\tsoftware_node_unregister_node_group(txgbe->nodes.group);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}