{
  "module_name": "txgbe_main.c",
  "hash_id": "dc66b3a56b844f01e7ac289c948a3b5286580f3d5a72a767aee3140e8fb98455",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/wangxun/txgbe/txgbe_main.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/netdevice.h>\n#include <linux/string.h>\n#include <linux/etherdevice.h>\n#include <linux/phylink.h>\n#include <net/ip.h>\n#include <linux/if_vlan.h>\n\n#include \"../libwx/wx_type.h\"\n#include \"../libwx/wx_lib.h\"\n#include \"../libwx/wx_hw.h\"\n#include \"txgbe_type.h\"\n#include \"txgbe_hw.h\"\n#include \"txgbe_phy.h\"\n#include \"txgbe_ethtool.h\"\n\nchar txgbe_driver_name[] = \"txgbe\";\n\n \nstatic const struct pci_device_id txgbe_pci_tbl[] = {\n\t{ PCI_VDEVICE(WANGXUN, TXGBE_DEV_ID_SP1000), 0},\n\t{ PCI_VDEVICE(WANGXUN, TXGBE_DEV_ID_WX1820), 0},\n\t \n\t{ .device = 0 }\n};\n\n#define DEFAULT_DEBUG_LEVEL_SHIFT 3\n\nstatic void txgbe_check_minimum_link(struct wx *wx)\n{\n\tstruct pci_dev *pdev;\n\n\tpdev = wx->pdev;\n\tpcie_print_link_status(pdev);\n}\n\n \nstatic int txgbe_enumerate_functions(struct wx *wx)\n{\n\tstruct pci_dev *entry, *pdev = wx->pdev;\n\tint physfns = 0;\n\n\tlist_for_each_entry(entry, &pdev->bus->devices, bus_list) {\n\t\t \n\t\tif (entry->vendor != pdev->vendor ||\n\t\t    entry->device != pdev->device)\n\t\t\treturn -EINVAL;\n\n\t\tphysfns++;\n\t}\n\n\treturn physfns;\n}\n\n \nstatic void txgbe_irq_enable(struct wx *wx, bool queues)\n{\n\twr32(wx, WX_PX_MISC_IEN, TXGBE_PX_MISC_IEN_MASK);\n\n\t \n\twx_intr_enable(wx, TXGBE_INTR_MISC(wx));\n\tif (queues)\n\t\twx_intr_enable(wx, TXGBE_INTR_QALL(wx));\n}\n\n \nstatic irqreturn_t txgbe_intr(int __always_unused irq, void *data)\n{\n\tstruct wx_q_vector *q_vector;\n\tstruct wx *wx  = data;\n\tstruct pci_dev *pdev;\n\tu32 eicr;\n\n\tq_vector = wx->q_vector[0];\n\tpdev = wx->pdev;\n\n\teicr = wx_misc_isb(wx, WX_ISB_VEC0);\n\tif (!eicr) {\n\t\t \n\t\tif (netif_running(wx->netdev))\n\t\t\ttxgbe_irq_enable(wx, true);\n\t\treturn IRQ_NONE;         \n\t}\n\twx->isb_mem[WX_ISB_VEC0] = 0;\n\tif (!(pdev->msi_enabled))\n\t\twr32(wx, WX_PX_INTA, 1);\n\n\twx->isb_mem[WX_ISB_MISC] = 0;\n\t \n\tnapi_schedule_irqoff(&q_vector->napi);\n\n\t \n\tif (netif_running(wx->netdev))\n\t\ttxgbe_irq_enable(wx, false);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic int txgbe_request_msix_irqs(struct wx *wx)\n{\n\tstruct net_device *netdev = wx->netdev;\n\tint vector, err;\n\n\tfor (vector = 0; vector < wx->num_q_vectors; vector++) {\n\t\tstruct wx_q_vector *q_vector = wx->q_vector[vector];\n\t\tstruct msix_entry *entry = &wx->msix_entries[vector];\n\n\t\tif (q_vector->tx.ring && q_vector->rx.ring)\n\t\t\tsnprintf(q_vector->name, sizeof(q_vector->name) - 1,\n\t\t\t\t \"%s-TxRx-%d\", netdev->name, entry->entry);\n\t\telse\n\t\t\t \n\t\t\tcontinue;\n\n\t\terr = request_irq(entry->vector, wx_msix_clean_rings, 0,\n\t\t\t\t  q_vector->name, q_vector);\n\t\tif (err) {\n\t\t\twx_err(wx, \"request_irq failed for MSIX interrupt %s Error: %d\\n\",\n\t\t\t       q_vector->name, err);\n\t\t\tgoto free_queue_irqs;\n\t\t}\n\t}\n\n\treturn 0;\n\nfree_queue_irqs:\n\twhile (vector) {\n\t\tvector--;\n\t\tfree_irq(wx->msix_entries[vector].vector,\n\t\t\t wx->q_vector[vector]);\n\t}\n\twx_reset_interrupt_capability(wx);\n\treturn err;\n}\n\n \nstatic int txgbe_request_irq(struct wx *wx)\n{\n\tstruct net_device *netdev = wx->netdev;\n\tstruct pci_dev *pdev = wx->pdev;\n\tint err;\n\n\tif (pdev->msix_enabled)\n\t\terr = txgbe_request_msix_irqs(wx);\n\telse if (pdev->msi_enabled)\n\t\terr = request_irq(wx->pdev->irq, &txgbe_intr, 0,\n\t\t\t\t  netdev->name, wx);\n\telse\n\t\terr = request_irq(wx->pdev->irq, &txgbe_intr, IRQF_SHARED,\n\t\t\t\t  netdev->name, wx);\n\n\tif (err)\n\t\twx_err(wx, \"request_irq failed, Error %d\\n\", err);\n\n\treturn err;\n}\n\nstatic void txgbe_up_complete(struct wx *wx)\n{\n\tstruct net_device *netdev = wx->netdev;\n\tstruct txgbe *txgbe;\n\n\twx_control_hw(wx, true);\n\twx_configure_vectors(wx);\n\n\t \n\tsmp_mb__before_atomic();\n\twx_napi_enable_all(wx);\n\n\ttxgbe = netdev_to_txgbe(netdev);\n\tphylink_start(txgbe->phylink);\n\n\t \n\trd32(wx, WX_PX_IC(0));\n\trd32(wx, WX_PX_IC(1));\n\trd32(wx, WX_PX_MISC_IC);\n\ttxgbe_irq_enable(wx, true);\n\n\t \n\tnetif_tx_start_all_queues(netdev);\n}\n\nstatic void txgbe_reset(struct wx *wx)\n{\n\tstruct net_device *netdev = wx->netdev;\n\tu8 old_addr[ETH_ALEN];\n\tint err;\n\n\terr = txgbe_reset_hw(wx);\n\tif (err != 0)\n\t\twx_err(wx, \"Hardware Error: %d\\n\", err);\n\n\twx_start_hw(wx);\n\t \n\tmemcpy(old_addr, &wx->mac_table[0].addr, netdev->addr_len);\n\twx_flush_sw_mac_table(wx);\n\twx_mac_set_default_filter(wx, old_addr);\n}\n\nstatic void txgbe_disable_device(struct wx *wx)\n{\n\tstruct net_device *netdev = wx->netdev;\n\tu32 i;\n\n\twx_disable_pcie_master(wx);\n\t \n\twx_disable_rx(wx);\n\n\t \n\tfor (i = 0; i < wx->num_rx_queues; i++)\n\t\t \n\t\twx_disable_rx_queue(wx, wx->rx_ring[i]);\n\n\tnetif_tx_stop_all_queues(netdev);\n\tnetif_tx_disable(netdev);\n\n\twx_irq_disable(wx);\n\twx_napi_disable_all(wx);\n\n\tif (wx->bus.func < 2)\n\t\twr32m(wx, TXGBE_MIS_PRB_CTL, TXGBE_MIS_PRB_CTL_LAN_UP(wx->bus.func), 0);\n\telse\n\t\twx_err(wx, \"%s: invalid bus lan id %d\\n\",\n\t\t       __func__, wx->bus.func);\n\n\tif (!(((wx->subsystem_device_id & WX_NCSI_MASK) == WX_NCSI_SUP) ||\n\t      ((wx->subsystem_device_id & WX_WOL_MASK) == WX_WOL_SUP))) {\n\t\t \n\t\twr32m(wx, WX_MAC_TX_CFG, WX_MAC_TX_CFG_TE, 0);\n\t}\n\n\t \n\tfor (i = 0; i < wx->num_tx_queues; i++) {\n\t\tu8 reg_idx = wx->tx_ring[i]->reg_idx;\n\n\t\twr32(wx, WX_PX_TR_CFG(reg_idx), WX_PX_TR_CFG_SWFLSH);\n\t}\n\n\t \n\twr32m(wx, WX_TDM_CTL, WX_TDM_CTL_TE, 0);\n}\n\nstatic void txgbe_down(struct wx *wx)\n{\n\tstruct txgbe *txgbe = netdev_to_txgbe(wx->netdev);\n\n\ttxgbe_disable_device(wx);\n\ttxgbe_reset(wx);\n\tphylink_stop(txgbe->phylink);\n\n\twx_clean_all_tx_rings(wx);\n\twx_clean_all_rx_rings(wx);\n}\n\n \nstatic void txgbe_init_type_code(struct wx *wx)\n{\n\tu8 device_type = wx->subsystem_device_id & 0xF0;\n\n\tswitch (wx->device_id) {\n\tcase TXGBE_DEV_ID_SP1000:\n\tcase TXGBE_DEV_ID_WX1820:\n\t\twx->mac.type = wx_mac_sp;\n\t\tbreak;\n\tdefault:\n\t\twx->mac.type = wx_mac_unknown;\n\t\tbreak;\n\t}\n\n\tswitch (device_type) {\n\tcase TXGBE_ID_SFP:\n\t\twx->media_type = sp_media_fiber;\n\t\tbreak;\n\tcase TXGBE_ID_XAUI:\n\tcase TXGBE_ID_SGMII:\n\t\twx->media_type = sp_media_copper;\n\t\tbreak;\n\tcase TXGBE_ID_KR_KX_KX4:\n\tcase TXGBE_ID_MAC_XAUI:\n\tcase TXGBE_ID_MAC_SGMII:\n\t\twx->media_type = sp_media_backplane;\n\t\tbreak;\n\tcase TXGBE_ID_SFI_XAUI:\n\t\tif (wx->bus.func == 0)\n\t\t\twx->media_type = sp_media_fiber;\n\t\telse\n\t\t\twx->media_type = sp_media_copper;\n\t\tbreak;\n\tdefault:\n\t\twx->media_type = sp_media_unknown;\n\t\tbreak;\n\t}\n}\n\n \nstatic int txgbe_sw_init(struct wx *wx)\n{\n\tu16 msix_count = 0;\n\tint err;\n\n\twx->mac.num_rar_entries = TXGBE_SP_RAR_ENTRIES;\n\twx->mac.max_tx_queues = TXGBE_SP_MAX_TX_QUEUES;\n\twx->mac.max_rx_queues = TXGBE_SP_MAX_RX_QUEUES;\n\twx->mac.mcft_size = TXGBE_SP_MC_TBL_SIZE;\n\twx->mac.vft_size = TXGBE_SP_VFT_TBL_SIZE;\n\twx->mac.rx_pb_size = TXGBE_SP_RX_PB_SIZE;\n\twx->mac.tx_pb_size = TXGBE_SP_TDB_PB_SZ;\n\n\t \n\terr = wx_sw_init(wx);\n\tif (err < 0)\n\t\treturn err;\n\n\ttxgbe_init_type_code(wx);\n\n\t \n\twx->max_q_vectors = TXGBE_MAX_MSIX_VECTORS;\n\terr = wx_get_pcie_msix_counts(wx, &msix_count, TXGBE_MAX_MSIX_VECTORS);\n\tif (err)\n\t\twx_err(wx, \"Do not support MSI-X\\n\");\n\twx->mac.max_msix_vectors = msix_count;\n\n\t \n\twx->rx_itr_setting = 1;\n\twx->tx_itr_setting = 1;\n\n\t \n\twx->tx_ring_count = TXGBE_DEFAULT_TXD;\n\twx->rx_ring_count = TXGBE_DEFAULT_RXD;\n\n\t \n\twx->tx_work_limit = TXGBE_DEFAULT_TX_WORK;\n\twx->rx_work_limit = TXGBE_DEFAULT_RX_WORK;\n\n\treturn 0;\n}\n\n \nstatic int txgbe_open(struct net_device *netdev)\n{\n\tstruct wx *wx = netdev_priv(netdev);\n\tint err;\n\n\terr = wx_setup_resources(wx);\n\tif (err)\n\t\tgoto err_reset;\n\n\twx_configure(wx);\n\n\terr = txgbe_request_irq(wx);\n\tif (err)\n\t\tgoto err_free_isb;\n\n\t \n\terr = netif_set_real_num_tx_queues(netdev, wx->num_tx_queues);\n\tif (err)\n\t\tgoto err_free_irq;\n\n\terr = netif_set_real_num_rx_queues(netdev, wx->num_rx_queues);\n\tif (err)\n\t\tgoto err_free_irq;\n\n\ttxgbe_up_complete(wx);\n\n\treturn 0;\n\nerr_free_irq:\n\twx_free_irq(wx);\nerr_free_isb:\n\twx_free_isb_resources(wx);\nerr_reset:\n\ttxgbe_reset(wx);\n\n\treturn err;\n}\n\n \nstatic void txgbe_close_suspend(struct wx *wx)\n{\n\ttxgbe_disable_device(wx);\n\twx_free_resources(wx);\n}\n\n \nstatic int txgbe_close(struct net_device *netdev)\n{\n\tstruct wx *wx = netdev_priv(netdev);\n\n\ttxgbe_down(wx);\n\twx_free_irq(wx);\n\twx_free_resources(wx);\n\twx_control_hw(wx, false);\n\n\treturn 0;\n}\n\nstatic void txgbe_dev_shutdown(struct pci_dev *pdev)\n{\n\tstruct wx *wx = pci_get_drvdata(pdev);\n\tstruct net_device *netdev;\n\n\tnetdev = wx->netdev;\n\tnetif_device_detach(netdev);\n\n\trtnl_lock();\n\tif (netif_running(netdev))\n\t\ttxgbe_close_suspend(wx);\n\trtnl_unlock();\n\n\twx_control_hw(wx, false);\n\n\tpci_disable_device(pdev);\n}\n\nstatic void txgbe_shutdown(struct pci_dev *pdev)\n{\n\ttxgbe_dev_shutdown(pdev);\n\n\tif (system_state == SYSTEM_POWER_OFF) {\n\t\tpci_wake_from_d3(pdev, false);\n\t\tpci_set_power_state(pdev, PCI_D3hot);\n\t}\n}\n\nstatic const struct net_device_ops txgbe_netdev_ops = {\n\t.ndo_open               = txgbe_open,\n\t.ndo_stop               = txgbe_close,\n\t.ndo_change_mtu         = wx_change_mtu,\n\t.ndo_start_xmit         = wx_xmit_frame,\n\t.ndo_set_rx_mode        = wx_set_rx_mode,\n\t.ndo_set_features       = wx_set_features,\n\t.ndo_validate_addr      = eth_validate_addr,\n\t.ndo_set_mac_address    = wx_set_mac,\n\t.ndo_get_stats64        = wx_get_stats64,\n\t.ndo_vlan_rx_add_vid    = wx_vlan_rx_add_vid,\n\t.ndo_vlan_rx_kill_vid   = wx_vlan_rx_kill_vid,\n};\n\n \nstatic int txgbe_probe(struct pci_dev *pdev,\n\t\t       const struct pci_device_id __always_unused *ent)\n{\n\tstruct net_device *netdev;\n\tint err, expected_gts;\n\tstruct wx *wx = NULL;\n\tstruct txgbe *txgbe;\n\n\tu16 eeprom_verh = 0, eeprom_verl = 0, offset = 0;\n\tu16 eeprom_cfg_blkh = 0, eeprom_cfg_blkl = 0;\n\tu16 build = 0, major = 0, patch = 0;\n\tu8 part_str[TXGBE_PBANUM_LENGTH];\n\tu32 etrack_id = 0;\n\n\terr = pci_enable_device_mem(pdev);\n\tif (err)\n\t\treturn err;\n\n\terr = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(64));\n\tif (err) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"No usable DMA configuration, aborting\\n\");\n\t\tgoto err_pci_disable_dev;\n\t}\n\n\terr = pci_request_selected_regions(pdev,\n\t\t\t\t\t   pci_select_bars(pdev, IORESOURCE_MEM),\n\t\t\t\t\t   txgbe_driver_name);\n\tif (err) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"pci_request_selected_regions failed 0x%x\\n\", err);\n\t\tgoto err_pci_disable_dev;\n\t}\n\n\tpci_set_master(pdev);\n\n\tnetdev = devm_alloc_etherdev_mqs(&pdev->dev,\n\t\t\t\t\t sizeof(struct wx),\n\t\t\t\t\t TXGBE_MAX_TX_QUEUES,\n\t\t\t\t\t TXGBE_MAX_RX_QUEUES);\n\tif (!netdev) {\n\t\terr = -ENOMEM;\n\t\tgoto err_pci_release_regions;\n\t}\n\n\tSET_NETDEV_DEV(netdev, &pdev->dev);\n\n\twx = netdev_priv(netdev);\n\twx->netdev = netdev;\n\twx->pdev = pdev;\n\n\twx->msg_enable = (1 << DEFAULT_DEBUG_LEVEL_SHIFT) - 1;\n\n\twx->hw_addr = devm_ioremap(&pdev->dev,\n\t\t\t\t   pci_resource_start(pdev, 0),\n\t\t\t\t   pci_resource_len(pdev, 0));\n\tif (!wx->hw_addr) {\n\t\terr = -EIO;\n\t\tgoto err_pci_release_regions;\n\t}\n\n\twx->driver_name = txgbe_driver_name;\n\ttxgbe_set_ethtool_ops(netdev);\n\tnetdev->netdev_ops = &txgbe_netdev_ops;\n\n\t \n\terr = txgbe_sw_init(wx);\n\tif (err)\n\t\tgoto err_free_mac_table;\n\n\t \n\terr = wx_check_flash_load(wx, TXGBE_SPI_ILDR_STATUS_PERST);\n\tif (err)\n\t\tgoto err_free_mac_table;\n\terr = wx_check_flash_load(wx, TXGBE_SPI_ILDR_STATUS_PWRRST);\n\tif (err)\n\t\tgoto err_free_mac_table;\n\n\terr = wx_mng_present(wx);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Management capability is not present\\n\");\n\t\tgoto err_free_mac_table;\n\t}\n\n\terr = txgbe_reset_hw(wx);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"HW Init failed: %d\\n\", err);\n\t\tgoto err_free_mac_table;\n\t}\n\n\tnetdev->features = NETIF_F_SG |\n\t\t\t   NETIF_F_TSO |\n\t\t\t   NETIF_F_TSO6 |\n\t\t\t   NETIF_F_RXHASH |\n\t\t\t   NETIF_F_RXCSUM |\n\t\t\t   NETIF_F_HW_CSUM;\n\n\tnetdev->gso_partial_features =  NETIF_F_GSO_ENCAP_ALL;\n\tnetdev->features |= netdev->gso_partial_features;\n\tnetdev->features |= NETIF_F_SCTP_CRC;\n\tnetdev->vlan_features |= netdev->features | NETIF_F_TSO_MANGLEID;\n\tnetdev->hw_enc_features |= netdev->vlan_features;\n\tnetdev->features |= NETIF_F_VLAN_FEATURES;\n\t \n\tnetdev->hw_features |= netdev->features | NETIF_F_RXALL;\n\tnetdev->hw_features |= NETIF_F_NTUPLE | NETIF_F_HW_TC;\n\tnetdev->features |= NETIF_F_HIGHDMA;\n\tnetdev->hw_features |= NETIF_F_GRO;\n\tnetdev->features |= NETIF_F_GRO;\n\n\tnetdev->priv_flags |= IFF_UNICAST_FLT;\n\tnetdev->priv_flags |= IFF_SUPP_NOFCS;\n\n\tnetdev->min_mtu = ETH_MIN_MTU;\n\tnetdev->max_mtu = WX_MAX_JUMBO_FRAME_SIZE -\n\t\t\t  (ETH_HLEN + ETH_FCS_LEN + VLAN_HLEN);\n\n\t \n\terr = txgbe_validate_eeprom_checksum(wx, NULL);\n\tif (err != 0) {\n\t\tdev_err(&pdev->dev, \"The EEPROM Checksum Is Not Valid\\n\");\n\t\twr32(wx, WX_MIS_RST, WX_MIS_RST_SW_RST);\n\t\terr = -EIO;\n\t\tgoto err_free_mac_table;\n\t}\n\n\teth_hw_addr_set(netdev, wx->mac.perm_addr);\n\twx_mac_set_default_filter(wx, wx->mac.perm_addr);\n\n\terr = wx_init_interrupt_scheme(wx);\n\tif (err)\n\t\tgoto err_free_mac_table;\n\n\t \n\twx_read_ee_hostif(wx,\n\t\t\t  wx->eeprom.sw_region_offset + TXGBE_EEPROM_VERSION_H,\n\t\t\t  &eeprom_verh);\n\twx_read_ee_hostif(wx,\n\t\t\t  wx->eeprom.sw_region_offset + TXGBE_EEPROM_VERSION_L,\n\t\t\t  &eeprom_verl);\n\tetrack_id = (eeprom_verh << 16) | eeprom_verl;\n\n\twx_read_ee_hostif(wx,\n\t\t\t  wx->eeprom.sw_region_offset + TXGBE_ISCSI_BOOT_CONFIG,\n\t\t\t  &offset);\n\n\t \n\tif (!(offset == 0x0) && !(offset == 0xffff)) {\n\t\twx_read_ee_hostif(wx, offset + 0x84, &eeprom_cfg_blkh);\n\t\twx_read_ee_hostif(wx, offset + 0x83, &eeprom_cfg_blkl);\n\n\t\t \n\t\tif (eeprom_cfg_blkl && eeprom_cfg_blkh) {\n\t\t\tmajor = eeprom_cfg_blkl >> 8;\n\t\t\tbuild = (eeprom_cfg_blkl << 8) | (eeprom_cfg_blkh >> 8);\n\t\t\tpatch = eeprom_cfg_blkh & 0x00ff;\n\n\t\t\tsnprintf(wx->eeprom_id, sizeof(wx->eeprom_id),\n\t\t\t\t \"0x%08x, %d.%d.%d\", etrack_id, major, build,\n\t\t\t\t patch);\n\t\t} else {\n\t\t\tsnprintf(wx->eeprom_id, sizeof(wx->eeprom_id),\n\t\t\t\t \"0x%08x\", etrack_id);\n\t\t}\n\t} else {\n\t\tsnprintf(wx->eeprom_id, sizeof(wx->eeprom_id),\n\t\t\t \"0x%08x\", etrack_id);\n\t}\n\n\tif (etrack_id < 0x20010)\n\t\tdev_warn(&pdev->dev, \"Please upgrade the firmware to 0x20010 or above.\\n\");\n\n\ttxgbe = devm_kzalloc(&pdev->dev, sizeof(*txgbe), GFP_KERNEL);\n\tif (!txgbe) {\n\t\terr = -ENOMEM;\n\t\tgoto err_release_hw;\n\t}\n\n\ttxgbe->wx = wx;\n\twx->priv = txgbe;\n\n\terr = txgbe_init_phy(txgbe);\n\tif (err)\n\t\tgoto err_release_hw;\n\n\terr = register_netdev(netdev);\n\tif (err)\n\t\tgoto err_remove_phy;\n\n\tpci_set_drvdata(pdev, wx);\n\n\tnetif_tx_stop_all_queues(netdev);\n\n\t \n\texpected_gts = txgbe_enumerate_functions(wx) * 10;\n\n\t \n\tif (expected_gts > 0)\n\t\ttxgbe_check_minimum_link(wx);\n\telse\n\t\tdev_warn(&pdev->dev, \"Failed to enumerate PF devices.\\n\");\n\n\t \n\terr = txgbe_read_pba_string(wx, part_str, TXGBE_PBANUM_LENGTH);\n\tif (err)\n\t\tstrncpy(part_str, \"Unknown\", TXGBE_PBANUM_LENGTH);\n\n\tnetif_info(wx, probe, netdev, \"%pM\\n\", netdev->dev_addr);\n\n\treturn 0;\n\nerr_remove_phy:\n\ttxgbe_remove_phy(txgbe);\nerr_release_hw:\n\twx_clear_interrupt_scheme(wx);\n\twx_control_hw(wx, false);\nerr_free_mac_table:\n\tkfree(wx->mac_table);\nerr_pci_release_regions:\n\tpci_release_selected_regions(pdev,\n\t\t\t\t     pci_select_bars(pdev, IORESOURCE_MEM));\nerr_pci_disable_dev:\n\tpci_disable_device(pdev);\n\treturn err;\n}\n\n \nstatic void txgbe_remove(struct pci_dev *pdev)\n{\n\tstruct wx *wx = pci_get_drvdata(pdev);\n\tstruct txgbe *txgbe = wx->priv;\n\tstruct net_device *netdev;\n\n\tnetdev = wx->netdev;\n\tunregister_netdev(netdev);\n\n\ttxgbe_remove_phy(txgbe);\n\n\tpci_release_selected_regions(pdev,\n\t\t\t\t     pci_select_bars(pdev, IORESOURCE_MEM));\n\n\tkfree(wx->mac_table);\n\twx_clear_interrupt_scheme(wx);\n\n\tpci_disable_device(pdev);\n}\n\nstatic struct pci_driver txgbe_driver = {\n\t.name     = txgbe_driver_name,\n\t.id_table = txgbe_pci_tbl,\n\t.probe    = txgbe_probe,\n\t.remove   = txgbe_remove,\n\t.shutdown = txgbe_shutdown,\n};\n\nmodule_pci_driver(txgbe_driver);\n\nMODULE_DEVICE_TABLE(pci, txgbe_pci_tbl);\nMODULE_AUTHOR(\"Beijing WangXun Technology Co., Ltd, <software@trustnetic.com>\");\nMODULE_DESCRIPTION(\"WangXun(R) 10 Gigabit PCI Express Network Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}