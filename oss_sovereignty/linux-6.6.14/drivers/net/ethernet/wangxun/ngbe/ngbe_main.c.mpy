{
  "module_name": "ngbe_main.c",
  "hash_id": "7a8bac4a902f3a072ef91e732613570cf41b19f0c9cac87425105b6e63f37069",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/wangxun/ngbe/ngbe_main.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/netdevice.h>\n#include <linux/string.h>\n#include <linux/etherdevice.h>\n#include <net/ip.h>\n#include <linux/phy.h>\n#include <linux/if_vlan.h>\n\n#include \"../libwx/wx_type.h\"\n#include \"../libwx/wx_hw.h\"\n#include \"../libwx/wx_lib.h\"\n#include \"ngbe_type.h\"\n#include \"ngbe_mdio.h\"\n#include \"ngbe_hw.h\"\n#include \"ngbe_ethtool.h\"\n\nchar ngbe_driver_name[] = \"ngbe\";\n\n \nstatic const struct pci_device_id ngbe_pci_tbl[] = {\n\t{ PCI_VDEVICE(WANGXUN, NGBE_DEV_ID_EM_WX1860AL_W), 0},\n\t{ PCI_VDEVICE(WANGXUN, NGBE_DEV_ID_EM_WX1860A2), 0},\n\t{ PCI_VDEVICE(WANGXUN, NGBE_DEV_ID_EM_WX1860A2S), 0},\n\t{ PCI_VDEVICE(WANGXUN, NGBE_DEV_ID_EM_WX1860A4), 0},\n\t{ PCI_VDEVICE(WANGXUN, NGBE_DEV_ID_EM_WX1860A4S), 0},\n\t{ PCI_VDEVICE(WANGXUN, NGBE_DEV_ID_EM_WX1860AL2), 0},\n\t{ PCI_VDEVICE(WANGXUN, NGBE_DEV_ID_EM_WX1860AL2S), 0},\n\t{ PCI_VDEVICE(WANGXUN, NGBE_DEV_ID_EM_WX1860AL4), 0},\n\t{ PCI_VDEVICE(WANGXUN, NGBE_DEV_ID_EM_WX1860AL4S), 0},\n\t{ PCI_VDEVICE(WANGXUN, NGBE_DEV_ID_EM_WX1860LC), 0},\n\t{ PCI_VDEVICE(WANGXUN, NGBE_DEV_ID_EM_WX1860A1), 0},\n\t{ PCI_VDEVICE(WANGXUN, NGBE_DEV_ID_EM_WX1860A1L), 0},\n\t \n\t{ .device = 0 }\n};\n\n \nstatic void ngbe_init_type_code(struct wx *wx)\n{\n\tint wol_mask = 0, ncsi_mask = 0;\n\tu16 type_mask = 0, val;\n\n\twx->mac.type = wx_mac_em;\n\ttype_mask = (u16)(wx->subsystem_device_id & NGBE_OEM_MASK);\n\tncsi_mask = wx->subsystem_device_id & NGBE_NCSI_MASK;\n\twol_mask = wx->subsystem_device_id & NGBE_WOL_MASK;\n\n\tval = rd32(wx, WX_CFG_PORT_ST);\n\twx->mac_type = (val & BIT(7)) >> 7 ?\n\t\t       em_mac_type_rgmii :\n\t\t       em_mac_type_mdi;\n\n\twx->wol_hw_supported = (wol_mask == NGBE_WOL_SUP) ? 1 : 0;\n\twx->ncsi_enabled = (ncsi_mask == NGBE_NCSI_MASK ||\n\t\t\t   type_mask == NGBE_SUBID_OCP_CARD) ? 1 : 0;\n\n\tswitch (type_mask) {\n\tcase NGBE_SUBID_LY_YT8521S_SFP:\n\tcase NGBE_SUBID_LY_M88E1512_SFP:\n\tcase NGBE_SUBID_YT8521S_SFP_GPIO:\n\tcase NGBE_SUBID_INTERNAL_YT8521S_SFP_GPIO:\n\t\twx->gpio_ctrl = 1;\n\t\tbreak;\n\tdefault:\n\t\twx->gpio_ctrl = 0;\n\t\tbreak;\n\t}\n}\n\n \nstatic inline int ngbe_init_rss_key(struct wx *wx)\n{\n\tu32 *rss_key;\n\n\tif (!wx->rss_key) {\n\t\trss_key = kzalloc(WX_RSS_KEY_SIZE, GFP_KERNEL);\n\t\tif (unlikely(!rss_key))\n\t\t\treturn -ENOMEM;\n\n\t\tnetdev_rss_key_fill(rss_key, WX_RSS_KEY_SIZE);\n\t\twx->rss_key = rss_key;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int ngbe_sw_init(struct wx *wx)\n{\n\tstruct pci_dev *pdev = wx->pdev;\n\tu16 msix_count = 0;\n\tint err = 0;\n\n\twx->mac.num_rar_entries = NGBE_RAR_ENTRIES;\n\twx->mac.max_rx_queues = NGBE_MAX_RX_QUEUES;\n\twx->mac.max_tx_queues = NGBE_MAX_TX_QUEUES;\n\twx->mac.mcft_size = NGBE_MC_TBL_SIZE;\n\twx->mac.vft_size = NGBE_SP_VFT_TBL_SIZE;\n\twx->mac.rx_pb_size = NGBE_RX_PB_SIZE;\n\twx->mac.tx_pb_size = NGBE_TDB_PB_SZ;\n\n\t \n\terr = wx_sw_init(wx);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tngbe_init_type_code(wx);\n\n\t \n\twx->max_q_vectors = NGBE_MAX_MSIX_VECTORS;\n\terr = wx_get_pcie_msix_counts(wx, &msix_count, NGBE_MAX_MSIX_VECTORS);\n\tif (err)\n\t\tdev_err(&pdev->dev, \"Do not support MSI-X\\n\");\n\twx->mac.max_msix_vectors = msix_count;\n\n\tif (ngbe_init_rss_key(wx))\n\t\treturn -ENOMEM;\n\n\t \n\twx->rx_itr_setting = 1;\n\twx->tx_itr_setting = 1;\n\n\t \n\twx->tx_ring_count = NGBE_DEFAULT_TXD;\n\twx->rx_ring_count = NGBE_DEFAULT_RXD;\n\n\t \n\twx->tx_work_limit = NGBE_DEFAULT_TX_WORK;\n\twx->rx_work_limit = NGBE_DEFAULT_RX_WORK;\n\n\treturn 0;\n}\n\n \nstatic void ngbe_irq_enable(struct wx *wx, bool queues)\n{\n\tu32 mask;\n\n\t \n\tmask = NGBE_PX_MISC_IEN_MASK;\n\n\twr32(wx, WX_GPIO_DDR, WX_GPIO_DDR_0);\n\twr32(wx, WX_GPIO_INTEN, WX_GPIO_INTEN_0 | WX_GPIO_INTEN_1);\n\twr32(wx, WX_GPIO_INTTYPE_LEVEL, 0x0);\n\twr32(wx, WX_GPIO_POLARITY, wx->gpio_ctrl ? 0 : 0x3);\n\n\twr32(wx, WX_PX_MISC_IEN, mask);\n\n\t \n\tif (queues)\n\t\twx_intr_enable(wx, NGBE_INTR_ALL);\n\telse\n\t\twx_intr_enable(wx, NGBE_INTR_MISC(wx));\n}\n\n \nstatic irqreturn_t ngbe_intr(int __always_unused irq, void *data)\n{\n\tstruct wx_q_vector *q_vector;\n\tstruct wx *wx  = data;\n\tstruct pci_dev *pdev;\n\tu32 eicr;\n\n\tq_vector = wx->q_vector[0];\n\tpdev = wx->pdev;\n\n\teicr = wx_misc_isb(wx, WX_ISB_VEC0);\n\tif (!eicr) {\n\t\t \n\t\tif (netif_running(wx->netdev))\n\t\t\tngbe_irq_enable(wx, true);\n\t\treturn IRQ_NONE;         \n\t}\n\twx->isb_mem[WX_ISB_VEC0] = 0;\n\tif (!(pdev->msi_enabled))\n\t\twr32(wx, WX_PX_INTA, 1);\n\n\twx->isb_mem[WX_ISB_MISC] = 0;\n\t \n\tnapi_schedule_irqoff(&q_vector->napi);\n\n\tif (netif_running(wx->netdev))\n\t\tngbe_irq_enable(wx, false);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t ngbe_msix_other(int __always_unused irq, void *data)\n{\n\tstruct wx *wx = data;\n\n\t \n\tif (netif_running(wx->netdev))\n\t\tngbe_irq_enable(wx, false);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic int ngbe_request_msix_irqs(struct wx *wx)\n{\n\tstruct net_device *netdev = wx->netdev;\n\tint vector, err;\n\n\tfor (vector = 0; vector < wx->num_q_vectors; vector++) {\n\t\tstruct wx_q_vector *q_vector = wx->q_vector[vector];\n\t\tstruct msix_entry *entry = &wx->msix_entries[vector];\n\n\t\tif (q_vector->tx.ring && q_vector->rx.ring)\n\t\t\tsnprintf(q_vector->name, sizeof(q_vector->name) - 1,\n\t\t\t\t \"%s-TxRx-%d\", netdev->name, entry->entry);\n\t\telse\n\t\t\t \n\t\t\tcontinue;\n\n\t\terr = request_irq(entry->vector, wx_msix_clean_rings, 0,\n\t\t\t\t  q_vector->name, q_vector);\n\t\tif (err) {\n\t\t\twx_err(wx, \"request_irq failed for MSIX interrupt %s Error: %d\\n\",\n\t\t\t       q_vector->name, err);\n\t\t\tgoto free_queue_irqs;\n\t\t}\n\t}\n\n\terr = request_irq(wx->msix_entries[vector].vector,\n\t\t\t  ngbe_msix_other, 0, netdev->name, wx);\n\n\tif (err) {\n\t\twx_err(wx, \"request_irq for msix_other failed: %d\\n\", err);\n\t\tgoto free_queue_irqs;\n\t}\n\n\treturn 0;\n\nfree_queue_irqs:\n\twhile (vector) {\n\t\tvector--;\n\t\tfree_irq(wx->msix_entries[vector].vector,\n\t\t\t wx->q_vector[vector]);\n\t}\n\twx_reset_interrupt_capability(wx);\n\treturn err;\n}\n\n \nstatic int ngbe_request_irq(struct wx *wx)\n{\n\tstruct net_device *netdev = wx->netdev;\n\tstruct pci_dev *pdev = wx->pdev;\n\tint err;\n\n\tif (pdev->msix_enabled)\n\t\terr = ngbe_request_msix_irqs(wx);\n\telse if (pdev->msi_enabled)\n\t\terr = request_irq(pdev->irq, ngbe_intr, 0,\n\t\t\t\t  netdev->name, wx);\n\telse\n\t\terr = request_irq(pdev->irq, ngbe_intr, IRQF_SHARED,\n\t\t\t\t  netdev->name, wx);\n\n\tif (err)\n\t\twx_err(wx, \"request_irq failed, Error %d\\n\", err);\n\n\treturn err;\n}\n\nstatic void ngbe_disable_device(struct wx *wx)\n{\n\tstruct net_device *netdev = wx->netdev;\n\tu32 i;\n\n\t \n\tfor (i = 0; i < wx->num_rx_queues; i++)\n\t\t \n\t\twx_disable_rx_queue(wx, wx->rx_ring[i]);\n\t \n\twx_disable_rx(wx);\n\twx_napi_disable_all(wx);\n\tnetif_tx_stop_all_queues(netdev);\n\tnetif_tx_disable(netdev);\n\tif (wx->gpio_ctrl)\n\t\tngbe_sfp_modules_txrx_powerctl(wx, false);\n\twx_irq_disable(wx);\n\t \n\tfor (i = 0; i < wx->num_tx_queues; i++) {\n\t\tu8 reg_idx = wx->tx_ring[i]->reg_idx;\n\n\t\twr32(wx, WX_PX_TR_CFG(reg_idx), WX_PX_TR_CFG_SWFLSH);\n\t}\n}\n\nstatic void ngbe_down(struct wx *wx)\n{\n\tphy_stop(wx->phydev);\n\tngbe_disable_device(wx);\n\twx_clean_all_tx_rings(wx);\n\twx_clean_all_rx_rings(wx);\n}\n\nstatic void ngbe_up(struct wx *wx)\n{\n\twx_configure_vectors(wx);\n\n\t \n\tsmp_mb__before_atomic();\n\twx_napi_enable_all(wx);\n\t \n\tnetif_tx_start_all_queues(wx->netdev);\n\n\t \n\trd32(wx, WX_PX_IC(0));\n\trd32(wx, WX_PX_MISC_IC);\n\tngbe_irq_enable(wx, true);\n\tif (wx->gpio_ctrl)\n\t\tngbe_sfp_modules_txrx_powerctl(wx, true);\n\n\tphy_start(wx->phydev);\n}\n\n \nstatic int ngbe_open(struct net_device *netdev)\n{\n\tstruct wx *wx = netdev_priv(netdev);\n\tint err;\n\n\twx_control_hw(wx, true);\n\n\terr = wx_setup_resources(wx);\n\tif (err)\n\t\treturn err;\n\n\twx_configure(wx);\n\n\terr = ngbe_request_irq(wx);\n\tif (err)\n\t\tgoto err_free_resources;\n\n\terr = ngbe_phy_connect(wx);\n\tif (err)\n\t\tgoto err_free_irq;\n\n\terr = netif_set_real_num_tx_queues(netdev, wx->num_tx_queues);\n\tif (err)\n\t\tgoto err_dis_phy;\n\n\terr = netif_set_real_num_rx_queues(netdev, wx->num_rx_queues);\n\tif (err)\n\t\tgoto err_dis_phy;\n\n\tngbe_up(wx);\n\n\treturn 0;\nerr_dis_phy:\n\tphy_disconnect(wx->phydev);\nerr_free_irq:\n\twx_free_irq(wx);\nerr_free_resources:\n\twx_free_resources(wx);\n\treturn err;\n}\n\n \nstatic int ngbe_close(struct net_device *netdev)\n{\n\tstruct wx *wx = netdev_priv(netdev);\n\n\tngbe_down(wx);\n\twx_free_irq(wx);\n\twx_free_resources(wx);\n\tphy_disconnect(wx->phydev);\n\twx_control_hw(wx, false);\n\n\treturn 0;\n}\n\nstatic void ngbe_dev_shutdown(struct pci_dev *pdev, bool *enable_wake)\n{\n\tstruct wx *wx = pci_get_drvdata(pdev);\n\tstruct net_device *netdev;\n\tu32 wufc = wx->wol;\n\n\tnetdev = wx->netdev;\n\trtnl_lock();\n\tnetif_device_detach(netdev);\n\n\tif (netif_running(netdev))\n\t\tngbe_close(netdev);\n\twx_clear_interrupt_scheme(wx);\n\trtnl_unlock();\n\n\tif (wufc) {\n\t\twx_set_rx_mode(netdev);\n\t\twx_configure_rx(wx);\n\t\twr32(wx, NGBE_PSR_WKUP_CTL, wufc);\n\t} else {\n\t\twr32(wx, NGBE_PSR_WKUP_CTL, 0);\n\t}\n\tpci_wake_from_d3(pdev, !!wufc);\n\t*enable_wake = !!wufc;\n\twx_control_hw(wx, false);\n\n\tpci_disable_device(pdev);\n}\n\nstatic void ngbe_shutdown(struct pci_dev *pdev)\n{\n\tstruct wx *wx = pci_get_drvdata(pdev);\n\tbool wake;\n\n\twake = !!wx->wol;\n\n\tngbe_dev_shutdown(pdev, &wake);\n\n\tif (system_state == SYSTEM_POWER_OFF) {\n\t\tpci_wake_from_d3(pdev, wake);\n\t\tpci_set_power_state(pdev, PCI_D3hot);\n\t}\n}\n\nstatic const struct net_device_ops ngbe_netdev_ops = {\n\t.ndo_open               = ngbe_open,\n\t.ndo_stop               = ngbe_close,\n\t.ndo_change_mtu         = wx_change_mtu,\n\t.ndo_start_xmit         = wx_xmit_frame,\n\t.ndo_set_rx_mode        = wx_set_rx_mode,\n\t.ndo_set_features       = wx_set_features,\n\t.ndo_validate_addr      = eth_validate_addr,\n\t.ndo_set_mac_address    = wx_set_mac,\n\t.ndo_get_stats64        = wx_get_stats64,\n\t.ndo_vlan_rx_add_vid    = wx_vlan_rx_add_vid,\n\t.ndo_vlan_rx_kill_vid   = wx_vlan_rx_kill_vid,\n};\n\n \nstatic int ngbe_probe(struct pci_dev *pdev,\n\t\t      const struct pci_device_id __always_unused *ent)\n{\n\tstruct net_device *netdev;\n\tu32 e2rom_cksum_cap = 0;\n\tstruct wx *wx = NULL;\n\tstatic int func_nums;\n\tu16 e2rom_ver = 0;\n\tu32 etrack_id = 0;\n\tu32 saved_ver = 0;\n\tint err;\n\n\terr = pci_enable_device_mem(pdev);\n\tif (err)\n\t\treturn err;\n\n\terr = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(64));\n\tif (err) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"No usable DMA configuration, aborting\\n\");\n\t\tgoto err_pci_disable_dev;\n\t}\n\n\terr = pci_request_selected_regions(pdev,\n\t\t\t\t\t   pci_select_bars(pdev, IORESOURCE_MEM),\n\t\t\t\t\t   ngbe_driver_name);\n\tif (err) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"pci_request_selected_regions failed %d\\n\", err);\n\t\tgoto err_pci_disable_dev;\n\t}\n\n\tpci_set_master(pdev);\n\n\tnetdev = devm_alloc_etherdev_mqs(&pdev->dev,\n\t\t\t\t\t sizeof(struct wx),\n\t\t\t\t\t NGBE_MAX_TX_QUEUES,\n\t\t\t\t\t NGBE_MAX_RX_QUEUES);\n\tif (!netdev) {\n\t\terr = -ENOMEM;\n\t\tgoto err_pci_release_regions;\n\t}\n\n\tSET_NETDEV_DEV(netdev, &pdev->dev);\n\n\twx = netdev_priv(netdev);\n\twx->netdev = netdev;\n\twx->pdev = pdev;\n\twx->msg_enable = BIT(3) - 1;\n\n\twx->hw_addr = devm_ioremap(&pdev->dev,\n\t\t\t\t   pci_resource_start(pdev, 0),\n\t\t\t\t   pci_resource_len(pdev, 0));\n\tif (!wx->hw_addr) {\n\t\terr = -EIO;\n\t\tgoto err_pci_release_regions;\n\t}\n\n\twx->driver_name = ngbe_driver_name;\n\tngbe_set_ethtool_ops(netdev);\n\tnetdev->netdev_ops = &ngbe_netdev_ops;\n\n\tnetdev->features = NETIF_F_SG | NETIF_F_IP_CSUM |\n\t\t\t   NETIF_F_TSO | NETIF_F_TSO6 |\n\t\t\t   NETIF_F_RXHASH | NETIF_F_RXCSUM;\n\tnetdev->features |= NETIF_F_SCTP_CRC | NETIF_F_TSO_MANGLEID;\n\tnetdev->vlan_features |= netdev->features;\n\tnetdev->features |= NETIF_F_IPV6_CSUM | NETIF_F_VLAN_FEATURES;\n\t \n\tnetdev->hw_features |= netdev->features | NETIF_F_RXALL;\n\tnetdev->hw_features |= NETIF_F_NTUPLE | NETIF_F_HW_TC;\n\tnetdev->features |= NETIF_F_HIGHDMA;\n\tnetdev->hw_features |= NETIF_F_GRO;\n\tnetdev->features |= NETIF_F_GRO;\n\n\tnetdev->priv_flags |= IFF_UNICAST_FLT;\n\tnetdev->priv_flags |= IFF_SUPP_NOFCS;\n\n\tnetdev->min_mtu = ETH_MIN_MTU;\n\tnetdev->max_mtu = WX_MAX_JUMBO_FRAME_SIZE -\n\t\t\t  (ETH_HLEN + ETH_FCS_LEN + VLAN_HLEN);\n\n\twx->bd_number = func_nums;\n\t \n\terr = ngbe_sw_init(wx);\n\tif (err)\n\t\tgoto err_free_mac_table;\n\n\t \n\terr = wx_check_flash_load(wx, NGBE_SPI_ILDR_STATUS_PERST);\n\tif (err)\n\t\tgoto err_free_mac_table;\n\terr = wx_check_flash_load(wx, NGBE_SPI_ILDR_STATUS_PWRRST);\n\tif (err)\n\t\tgoto err_free_mac_table;\n\n\terr = wx_mng_present(wx);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Management capability is not present\\n\");\n\t\tgoto err_free_mac_table;\n\t}\n\n\terr = ngbe_reset_hw(wx);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"HW Init failed: %d\\n\", err);\n\t\tgoto err_free_mac_table;\n\t}\n\n\tif (wx->bus.func == 0) {\n\t\twr32(wx, NGBE_CALSUM_CAP_STATUS, 0x0);\n\t\twr32(wx, NGBE_EEPROM_VERSION_STORE_REG, 0x0);\n\t} else {\n\t\te2rom_cksum_cap = rd32(wx, NGBE_CALSUM_CAP_STATUS);\n\t\tsaved_ver = rd32(wx, NGBE_EEPROM_VERSION_STORE_REG);\n\t}\n\n\twx_init_eeprom_params(wx);\n\tif (wx->bus.func == 0 || e2rom_cksum_cap == 0) {\n\t\t \n\t\terr = ngbe_eeprom_chksum_hostif(wx);\n\t\tif (err) {\n\t\t\tdev_err(&pdev->dev, \"The EEPROM Checksum Is Not Valid\\n\");\n\t\t\terr = -EIO;\n\t\t\tgoto err_free_mac_table;\n\t\t}\n\t}\n\n\twx->wol = 0;\n\tif (wx->wol_hw_supported)\n\t\twx->wol = NGBE_PSR_WKUP_CTL_MAG;\n\n\tnetdev->wol_enabled = !!(wx->wol);\n\twr32(wx, NGBE_PSR_WKUP_CTL, wx->wol);\n\tdevice_set_wakeup_enable(&pdev->dev, wx->wol);\n\n\t \n\tif (saved_ver) {\n\t\tetrack_id = saved_ver;\n\t} else {\n\t\twx_read_ee_hostif(wx,\n\t\t\t\t  wx->eeprom.sw_region_offset + NGBE_EEPROM_VERSION_H,\n\t\t\t\t  &e2rom_ver);\n\t\tetrack_id = e2rom_ver << 16;\n\t\twx_read_ee_hostif(wx,\n\t\t\t\t  wx->eeprom.sw_region_offset + NGBE_EEPROM_VERSION_L,\n\t\t\t\t  &e2rom_ver);\n\t\tetrack_id |= e2rom_ver;\n\t\twr32(wx, NGBE_EEPROM_VERSION_STORE_REG, etrack_id);\n\t}\n\tsnprintf(wx->eeprom_id, sizeof(wx->eeprom_id),\n\t\t \"0x%08x\", etrack_id);\n\n\teth_hw_addr_set(netdev, wx->mac.perm_addr);\n\twx_mac_set_default_filter(wx, wx->mac.perm_addr);\n\n\terr = wx_init_interrupt_scheme(wx);\n\tif (err)\n\t\tgoto err_free_mac_table;\n\n\t \n\terr = ngbe_mdio_init(wx);\n\tif (err)\n\t\tgoto err_clear_interrupt_scheme;\n\n\terr = register_netdev(netdev);\n\tif (err)\n\t\tgoto err_register;\n\n\tpci_set_drvdata(pdev, wx);\n\n\tnetif_info(wx, probe, netdev,\n\t\t   \"PHY: %s, PBA No: Wang Xun GbE Family Controller\\n\",\n\t\t   wx->mac_type == em_mac_type_mdi ? \"Internal\" : \"External\");\n\tnetif_info(wx, probe, netdev, \"%pM\\n\", netdev->dev_addr);\n\n\treturn 0;\n\nerr_register:\n\twx_control_hw(wx, false);\nerr_clear_interrupt_scheme:\n\twx_clear_interrupt_scheme(wx);\nerr_free_mac_table:\n\tkfree(wx->mac_table);\nerr_pci_release_regions:\n\tpci_release_selected_regions(pdev,\n\t\t\t\t     pci_select_bars(pdev, IORESOURCE_MEM));\nerr_pci_disable_dev:\n\tpci_disable_device(pdev);\n\treturn err;\n}\n\n \nstatic void ngbe_remove(struct pci_dev *pdev)\n{\n\tstruct wx *wx = pci_get_drvdata(pdev);\n\tstruct net_device *netdev;\n\n\tnetdev = wx->netdev;\n\tunregister_netdev(netdev);\n\tpci_release_selected_regions(pdev,\n\t\t\t\t     pci_select_bars(pdev, IORESOURCE_MEM));\n\n\tkfree(wx->mac_table);\n\twx_clear_interrupt_scheme(wx);\n\n\tpci_disable_device(pdev);\n}\n\nstatic int ngbe_suspend(struct pci_dev *pdev, pm_message_t state)\n{\n\tbool wake;\n\n\tngbe_dev_shutdown(pdev, &wake);\n\tdevice_set_wakeup_enable(&pdev->dev, wake);\n\n\treturn 0;\n}\n\nstatic int ngbe_resume(struct pci_dev *pdev)\n{\n\tstruct net_device *netdev;\n\tstruct wx *wx;\n\tu32 err;\n\n\twx = pci_get_drvdata(pdev);\n\tnetdev = wx->netdev;\n\n\terr = pci_enable_device_mem(pdev);\n\tif (err) {\n\t\twx_err(wx, \"Cannot enable PCI device from suspend\\n\");\n\t\treturn err;\n\t}\n\tpci_set_master(pdev);\n\tdevice_wakeup_disable(&pdev->dev);\n\n\tngbe_reset_hw(wx);\n\trtnl_lock();\n\terr = wx_init_interrupt_scheme(wx);\n\tif (!err && netif_running(netdev))\n\t\terr = ngbe_open(netdev);\n\tif (!err)\n\t\tnetif_device_attach(netdev);\n\trtnl_unlock();\n\n\treturn 0;\n}\n\nstatic struct pci_driver ngbe_driver = {\n\t.name     = ngbe_driver_name,\n\t.id_table = ngbe_pci_tbl,\n\t.probe    = ngbe_probe,\n\t.remove   = ngbe_remove,\n\t.suspend  = ngbe_suspend,\n\t.resume   = ngbe_resume,\n\t.shutdown = ngbe_shutdown,\n};\n\nmodule_pci_driver(ngbe_driver);\n\nMODULE_DEVICE_TABLE(pci, ngbe_pci_tbl);\nMODULE_AUTHOR(\"Beijing WangXun Technology Co., Ltd, <software@net-swift.com>\");\nMODULE_DESCRIPTION(\"WangXun(R) Gigabit PCI Express Network Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}