{
  "module_name": "ngbe_mdio.c",
  "hash_id": "aba8e8c030f2035299780083fc5da28f9a73c4f3c84435c9c4467db6a3442fd6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/wangxun/ngbe/ngbe_mdio.c",
  "human_readable_source": "\n \n\n#include <linux/ethtool.h>\n#include <linux/iopoll.h>\n#include <linux/pci.h>\n#include <linux/phy.h>\n\n#include \"../libwx/wx_type.h\"\n#include \"../libwx/wx_hw.h\"\n#include \"ngbe_type.h\"\n#include \"ngbe_mdio.h\"\n\nstatic int ngbe_phy_read_reg_internal(struct mii_bus *bus, int phy_addr, int regnum)\n{\n\tstruct wx *wx = bus->priv;\n\n\tif (phy_addr != 0)\n\t\treturn 0xffff;\n\treturn (u16)rd32(wx, NGBE_PHY_CONFIG(regnum));\n}\n\nstatic int ngbe_phy_write_reg_internal(struct mii_bus *bus, int phy_addr, int regnum, u16 value)\n{\n\tstruct wx *wx = bus->priv;\n\n\tif (phy_addr == 0)\n\t\twr32(wx, NGBE_PHY_CONFIG(regnum), value);\n\treturn 0;\n}\n\nstatic int ngbe_phy_read_reg_mdi_c22(struct mii_bus *bus, int phy_addr, int regnum)\n{\n\tu32 command, val, device_type = 0;\n\tstruct wx *wx = bus->priv;\n\tint ret;\n\n\twr32(wx, NGBE_MDIO_CLAUSE_SELECT, 0xF);\n\t \n\tcommand = WX_MSCA_RA(regnum) |\n\t\t  WX_MSCA_PA(phy_addr) |\n\t\t  WX_MSCA_DA(device_type);\n\twr32(wx, WX_MSCA, command);\n\tcommand = WX_MSCC_CMD(WX_MSCA_CMD_READ) |\n\t\t  WX_MSCC_BUSY |\n\t\t  WX_MDIO_CLK(6);\n\twr32(wx, WX_MSCC, command);\n\n\t \n\tret = read_poll_timeout(rd32, val, !(val & WX_MSCC_BUSY), 1000,\n\t\t\t\t100000, false, wx, WX_MSCC);\n\tif (ret) {\n\t\twx_err(wx, \"Mdio read c22 command did not complete.\\n\");\n\t\treturn ret;\n\t}\n\n\treturn (u16)rd32(wx, WX_MSCC);\n}\n\nstatic int ngbe_phy_write_reg_mdi_c22(struct mii_bus *bus, int phy_addr, int regnum, u16 value)\n{\n\tu32 command, val, device_type = 0;\n\tstruct wx *wx = bus->priv;\n\tint ret;\n\n\twr32(wx, NGBE_MDIO_CLAUSE_SELECT, 0xF);\n\t \n\tcommand = WX_MSCA_RA(regnum) |\n\t\t  WX_MSCA_PA(phy_addr) |\n\t\t  WX_MSCA_DA(device_type);\n\twr32(wx, WX_MSCA, command);\n\tcommand = value |\n\t\t  WX_MSCC_CMD(WX_MSCA_CMD_WRITE) |\n\t\t  WX_MSCC_BUSY |\n\t\t  WX_MDIO_CLK(6);\n\twr32(wx, WX_MSCC, command);\n\n\t \n\tret = read_poll_timeout(rd32, val, !(val & WX_MSCC_BUSY), 1000,\n\t\t\t\t100000, false, wx, WX_MSCC);\n\tif (ret)\n\t\twx_err(wx, \"Mdio write c22 command did not complete.\\n\");\n\n\treturn ret;\n}\n\nstatic int ngbe_phy_read_reg_mdi_c45(struct mii_bus *bus, int phy_addr, int devnum, int regnum)\n{\n\tstruct wx *wx = bus->priv;\n\tu32 val, command;\n\tint ret;\n\n\twr32(wx, NGBE_MDIO_CLAUSE_SELECT, 0x0);\n\t \n\tcommand = WX_MSCA_RA(regnum) |\n\t\t  WX_MSCA_PA(phy_addr) |\n\t\t  WX_MSCA_DA(devnum);\n\twr32(wx, WX_MSCA, command);\n\tcommand = WX_MSCC_CMD(WX_MSCA_CMD_READ) |\n\t\t  WX_MSCC_BUSY |\n\t\t  WX_MDIO_CLK(6);\n\twr32(wx, WX_MSCC, command);\n\n\t \n\tret = read_poll_timeout(rd32, val, !(val & WX_MSCC_BUSY), 1000,\n\t\t\t\t100000, false, wx, WX_MSCC);\n\tif (ret) {\n\t\twx_err(wx, \"Mdio read c45 command did not complete.\\n\");\n\t\treturn ret;\n\t}\n\n\treturn (u16)rd32(wx, WX_MSCC);\n}\n\nstatic int ngbe_phy_write_reg_mdi_c45(struct mii_bus *bus, int phy_addr,\n\t\t\t\t      int devnum, int regnum, u16 value)\n{\n\tstruct wx *wx = bus->priv;\n\tint ret, command;\n\tu16 val;\n\n\twr32(wx, NGBE_MDIO_CLAUSE_SELECT, 0x0);\n\t \n\tcommand = WX_MSCA_RA(regnum) |\n\t\t  WX_MSCA_PA(phy_addr) |\n\t\t  WX_MSCA_DA(devnum);\n\twr32(wx, WX_MSCA, command);\n\tcommand = value |\n\t\t  WX_MSCC_CMD(WX_MSCA_CMD_WRITE) |\n\t\t  WX_MSCC_BUSY |\n\t\t  WX_MDIO_CLK(6);\n\twr32(wx, WX_MSCC, command);\n\n\t \n\tret = read_poll_timeout(rd32, val, !(val & WX_MSCC_BUSY), 1000,\n\t\t\t\t100000, false, wx, WX_MSCC);\n\tif (ret)\n\t\twx_err(wx, \"Mdio write c45 command did not complete.\\n\");\n\n\treturn ret;\n}\n\nstatic int ngbe_phy_read_reg_c22(struct mii_bus *bus, int phy_addr, int regnum)\n{\n\tstruct wx *wx = bus->priv;\n\tu16 phy_data;\n\n\tif (wx->mac_type == em_mac_type_mdi)\n\t\tphy_data = ngbe_phy_read_reg_internal(bus, phy_addr, regnum);\n\telse\n\t\tphy_data = ngbe_phy_read_reg_mdi_c22(bus, phy_addr, regnum);\n\n\treturn phy_data;\n}\n\nstatic int ngbe_phy_write_reg_c22(struct mii_bus *bus, int phy_addr,\n\t\t\t\t  int regnum, u16 value)\n{\n\tstruct wx *wx = bus->priv;\n\tint ret;\n\n\tif (wx->mac_type == em_mac_type_mdi)\n\t\tret = ngbe_phy_write_reg_internal(bus, phy_addr, regnum, value);\n\telse\n\t\tret = ngbe_phy_write_reg_mdi_c22(bus, phy_addr, regnum, value);\n\n\treturn ret;\n}\n\nstatic void ngbe_handle_link_change(struct net_device *dev)\n{\n\tstruct wx *wx = netdev_priv(dev);\n\tstruct phy_device *phydev;\n\tu32 lan_speed, reg;\n\n\tphydev = wx->phydev;\n\tif (!(wx->link != phydev->link ||\n\t      wx->speed != phydev->speed ||\n\t      wx->duplex != phydev->duplex))\n\t\treturn;\n\n\twx->link = phydev->link;\n\twx->speed = phydev->speed;\n\twx->duplex = phydev->duplex;\n\tswitch (phydev->speed) {\n\tcase SPEED_10:\n\t\tlan_speed = 0;\n\t\tbreak;\n\tcase SPEED_100:\n\t\tlan_speed = 1;\n\t\tbreak;\n\tcase SPEED_1000:\n\tdefault:\n\t\tlan_speed = 2;\n\t\tbreak;\n\t}\n\twr32m(wx, NGBE_CFG_LAN_SPEED, 0x3, lan_speed);\n\n\tif (phydev->link) {\n\t\treg = rd32(wx, WX_MAC_TX_CFG);\n\t\treg &= ~WX_MAC_TX_CFG_SPEED_MASK;\n\t\treg |= WX_MAC_TX_CFG_SPEED_1G | WX_MAC_TX_CFG_TE;\n\t\twr32(wx, WX_MAC_TX_CFG, reg);\n\t\t \n\t\treg = rd32(wx, WX_MAC_RX_CFG);\n\t\twr32(wx, WX_MAC_RX_CFG, reg);\n\t\twr32(wx, WX_MAC_PKT_FLT, WX_MAC_PKT_FLT_PR);\n\t\treg = rd32(wx, WX_MAC_WDG_TIMEOUT);\n\t\twr32(wx, WX_MAC_WDG_TIMEOUT, reg);\n\t}\n\tphy_print_status(phydev);\n}\n\nint ngbe_phy_connect(struct wx *wx)\n{\n\tint ret;\n\n\tret = phy_connect_direct(wx->netdev,\n\t\t\t\t wx->phydev,\n\t\t\t\t ngbe_handle_link_change,\n\t\t\t\t PHY_INTERFACE_MODE_RGMII_ID);\n\tif (ret) {\n\t\twx_err(wx, \"PHY connect failed.\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void ngbe_phy_fixup(struct wx *wx)\n{\n\tstruct phy_device *phydev = wx->phydev;\n\tstruct ethtool_eee eee;\n\n\tphy_remove_link_mode(phydev, ETHTOOL_LINK_MODE_10baseT_Half_BIT);\n\tphy_remove_link_mode(phydev, ETHTOOL_LINK_MODE_100baseT_Half_BIT);\n\tphy_remove_link_mode(phydev, ETHTOOL_LINK_MODE_1000baseT_Half_BIT);\n\n\tphydev->mac_managed_pm = true;\n\tif (wx->mac_type != em_mac_type_mdi)\n\t\treturn;\n\t \n\tmemset(&eee, 0, sizeof(eee));\n\tphy_ethtool_set_eee(phydev, &eee);\n}\n\nint ngbe_mdio_init(struct wx *wx)\n{\n\tstruct pci_dev *pdev = wx->pdev;\n\tstruct mii_bus *mii_bus;\n\tint ret;\n\n\tmii_bus = devm_mdiobus_alloc(&pdev->dev);\n\tif (!mii_bus)\n\t\treturn -ENOMEM;\n\n\tmii_bus->name = \"ngbe_mii_bus\";\n\tmii_bus->read = ngbe_phy_read_reg_c22;\n\tmii_bus->write = ngbe_phy_write_reg_c22;\n\tmii_bus->phy_mask = GENMASK(31, 4);\n\tmii_bus->parent = &pdev->dev;\n\tmii_bus->priv = wx;\n\n\tif (wx->mac_type == em_mac_type_rgmii) {\n\t\tmii_bus->read_c45 = ngbe_phy_read_reg_mdi_c45;\n\t\tmii_bus->write_c45 = ngbe_phy_write_reg_mdi_c45;\n\t}\n\n\tsnprintf(mii_bus->id, MII_BUS_ID_SIZE, \"ngbe-%x\", pci_dev_id(pdev));\n\tret = devm_mdiobus_register(&pdev->dev, mii_bus);\n\tif (ret)\n\t\treturn ret;\n\n\twx->phydev = phy_find_first(mii_bus);\n\tif (!wx->phydev)\n\t\treturn -ENODEV;\n\n\tphy_attached_info(wx->phydev);\n\tngbe_phy_fixup(wx);\n\n\twx->link = 0;\n\twx->speed = 0;\n\twx->duplex = 0;\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}