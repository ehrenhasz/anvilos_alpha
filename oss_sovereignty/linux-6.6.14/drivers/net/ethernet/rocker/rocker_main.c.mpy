{
  "module_name": "rocker_main.c",
  "hash_id": "931053658662ee7358131c9c8d9ec25a6e9926834dd8446e468bd406e013fdbb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/rocker/rocker_main.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/interrupt.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/spinlock.h>\n#include <linux/sort.h>\n#include <linux/random.h>\n#include <linux/netdevice.h>\n#include <linux/skbuff.h>\n#include <linux/socket.h>\n#include <linux/etherdevice.h>\n#include <linux/ethtool.h>\n#include <linux/if_ether.h>\n#include <linux/if_vlan.h>\n#include <linux/if_bridge.h>\n#include <linux/bitops.h>\n#include <linux/ctype.h>\n#include <linux/workqueue.h>\n#include <net/switchdev.h>\n#include <net/rtnetlink.h>\n#include <net/netevent.h>\n#include <net/arp.h>\n#include <net/fib_rules.h>\n#include <net/fib_notifier.h>\n#include <linux/io-64-nonatomic-lo-hi.h>\n#include <generated/utsrelease.h>\n\n#include \"rocker_hw.h\"\n#include \"rocker.h\"\n#include \"rocker_tlv.h\"\n\nstatic const char rocker_driver_name[] = \"rocker\";\n\nstatic const struct pci_device_id rocker_pci_id_table[] = {\n\t{PCI_VDEVICE(REDHAT, PCI_DEVICE_ID_REDHAT_ROCKER), 0},\n\t{0, }\n};\n\nstruct rocker_wait {\n\twait_queue_head_t wait;\n\tbool done;\n\tbool nowait;\n};\n\nstatic void rocker_wait_reset(struct rocker_wait *wait)\n{\n\twait->done = false;\n\twait->nowait = false;\n}\n\nstatic void rocker_wait_init(struct rocker_wait *wait)\n{\n\tinit_waitqueue_head(&wait->wait);\n\trocker_wait_reset(wait);\n}\n\nstatic struct rocker_wait *rocker_wait_create(void)\n{\n\tstruct rocker_wait *wait;\n\n\twait = kzalloc(sizeof(*wait), GFP_KERNEL);\n\tif (!wait)\n\t\treturn NULL;\n\treturn wait;\n}\n\nstatic void rocker_wait_destroy(struct rocker_wait *wait)\n{\n\tkfree(wait);\n}\n\nstatic bool rocker_wait_event_timeout(struct rocker_wait *wait,\n\t\t\t\t      unsigned long timeout)\n{\n\twait_event_timeout(wait->wait, wait->done, HZ / 10);\n\tif (!wait->done)\n\t\treturn false;\n\treturn true;\n}\n\nstatic void rocker_wait_wake_up(struct rocker_wait *wait)\n{\n\twait->done = true;\n\twake_up(&wait->wait);\n}\n\nstatic u32 rocker_msix_vector(const struct rocker *rocker, unsigned int vector)\n{\n\treturn rocker->msix_entries[vector].vector;\n}\n\nstatic u32 rocker_msix_tx_vector(const struct rocker_port *rocker_port)\n{\n\treturn rocker_msix_vector(rocker_port->rocker,\n\t\t\t\t  ROCKER_MSIX_VEC_TX(rocker_port->port_number));\n}\n\nstatic u32 rocker_msix_rx_vector(const struct rocker_port *rocker_port)\n{\n\treturn rocker_msix_vector(rocker_port->rocker,\n\t\t\t\t  ROCKER_MSIX_VEC_RX(rocker_port->port_number));\n}\n\n#define rocker_write32(rocker, reg, val)\t\\\n\twritel((val), (rocker)->hw_addr + (ROCKER_ ## reg))\n#define rocker_read32(rocker, reg)\t\\\n\treadl((rocker)->hw_addr + (ROCKER_ ## reg))\n#define rocker_write64(rocker, reg, val)\t\\\n\twriteq((val), (rocker)->hw_addr + (ROCKER_ ## reg))\n#define rocker_read64(rocker, reg)\t\\\n\treadq((rocker)->hw_addr + (ROCKER_ ## reg))\n\n \n\nstatic int rocker_reg_test(const struct rocker *rocker)\n{\n\tconst struct pci_dev *pdev = rocker->pdev;\n\tu64 test_reg;\n\tu64 rnd;\n\n\trnd = get_random_u32();\n\trnd >>= 1;\n\trocker_write32(rocker, TEST_REG, rnd);\n\ttest_reg = rocker_read32(rocker, TEST_REG);\n\tif (test_reg != rnd * 2) {\n\t\tdev_err(&pdev->dev, \"unexpected 32bit register value %08llx, expected %08llx\\n\",\n\t\t\ttest_reg, rnd * 2);\n\t\treturn -EIO;\n\t}\n\n\trnd = get_random_u32();\n\trnd <<= 31;\n\trnd |= get_random_u32();\n\trocker_write64(rocker, TEST_REG64, rnd);\n\ttest_reg = rocker_read64(rocker, TEST_REG64);\n\tif (test_reg != rnd * 2) {\n\t\tdev_err(&pdev->dev, \"unexpected 64bit register value %16llx, expected %16llx\\n\",\n\t\t\ttest_reg, rnd * 2);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int rocker_dma_test_one(const struct rocker *rocker,\n\t\t\t       struct rocker_wait *wait, u32 test_type,\n\t\t\t       dma_addr_t dma_handle, const unsigned char *buf,\n\t\t\t       const unsigned char *expect, size_t size)\n{\n\tconst struct pci_dev *pdev = rocker->pdev;\n\tint i;\n\n\trocker_wait_reset(wait);\n\trocker_write32(rocker, TEST_DMA_CTRL, test_type);\n\n\tif (!rocker_wait_event_timeout(wait, HZ / 10)) {\n\t\tdev_err(&pdev->dev, \"no interrupt received within a timeout\\n\");\n\t\treturn -EIO;\n\t}\n\n\tfor (i = 0; i < size; i++) {\n\t\tif (buf[i] != expect[i]) {\n\t\t\tdev_err(&pdev->dev, \"unexpected memory content %02x at byte %x\\n, %02x expected\",\n\t\t\t\tbuf[i], i, expect[i]);\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\treturn 0;\n}\n\n#define ROCKER_TEST_DMA_BUF_SIZE (PAGE_SIZE * 4)\n#define ROCKER_TEST_DMA_FILL_PATTERN 0x96\n\nstatic int rocker_dma_test_offset(const struct rocker *rocker,\n\t\t\t\t  struct rocker_wait *wait, int offset)\n{\n\tstruct pci_dev *pdev = rocker->pdev;\n\tunsigned char *alloc;\n\tunsigned char *buf;\n\tunsigned char *expect;\n\tdma_addr_t dma_handle;\n\tint i;\n\tint err;\n\n\talloc = kzalloc(ROCKER_TEST_DMA_BUF_SIZE * 2 + offset,\n\t\t\tGFP_KERNEL | GFP_DMA);\n\tif (!alloc)\n\t\treturn -ENOMEM;\n\tbuf = alloc + offset;\n\texpect = buf + ROCKER_TEST_DMA_BUF_SIZE;\n\n\tdma_handle = dma_map_single(&pdev->dev, buf, ROCKER_TEST_DMA_BUF_SIZE,\n\t\t\t\t    DMA_BIDIRECTIONAL);\n\tif (dma_mapping_error(&pdev->dev, dma_handle)) {\n\t\terr = -EIO;\n\t\tgoto free_alloc;\n\t}\n\n\trocker_write64(rocker, TEST_DMA_ADDR, dma_handle);\n\trocker_write32(rocker, TEST_DMA_SIZE, ROCKER_TEST_DMA_BUF_SIZE);\n\n\tmemset(expect, ROCKER_TEST_DMA_FILL_PATTERN, ROCKER_TEST_DMA_BUF_SIZE);\n\terr = rocker_dma_test_one(rocker, wait, ROCKER_TEST_DMA_CTRL_FILL,\n\t\t\t\t  dma_handle, buf, expect,\n\t\t\t\t  ROCKER_TEST_DMA_BUF_SIZE);\n\tif (err)\n\t\tgoto unmap;\n\n\tmemset(expect, 0, ROCKER_TEST_DMA_BUF_SIZE);\n\terr = rocker_dma_test_one(rocker, wait, ROCKER_TEST_DMA_CTRL_CLEAR,\n\t\t\t\t  dma_handle, buf, expect,\n\t\t\t\t  ROCKER_TEST_DMA_BUF_SIZE);\n\tif (err)\n\t\tgoto unmap;\n\n\tget_random_bytes(buf, ROCKER_TEST_DMA_BUF_SIZE);\n\tfor (i = 0; i < ROCKER_TEST_DMA_BUF_SIZE; i++)\n\t\texpect[i] = ~buf[i];\n\terr = rocker_dma_test_one(rocker, wait, ROCKER_TEST_DMA_CTRL_INVERT,\n\t\t\t\t  dma_handle, buf, expect,\n\t\t\t\t  ROCKER_TEST_DMA_BUF_SIZE);\n\tif (err)\n\t\tgoto unmap;\n\nunmap:\n\tdma_unmap_single(&pdev->dev, dma_handle, ROCKER_TEST_DMA_BUF_SIZE,\n\t\t\t DMA_BIDIRECTIONAL);\nfree_alloc:\n\tkfree(alloc);\n\n\treturn err;\n}\n\nstatic int rocker_dma_test(const struct rocker *rocker,\n\t\t\t   struct rocker_wait *wait)\n{\n\tint i;\n\tint err;\n\n\tfor (i = 0; i < 8; i++) {\n\t\terr = rocker_dma_test_offset(rocker, wait, i);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n\nstatic irqreturn_t rocker_test_irq_handler(int irq, void *dev_id)\n{\n\tstruct rocker_wait *wait = dev_id;\n\n\trocker_wait_wake_up(wait);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int rocker_basic_hw_test(const struct rocker *rocker)\n{\n\tconst struct pci_dev *pdev = rocker->pdev;\n\tstruct rocker_wait wait;\n\tint err;\n\n\terr = rocker_reg_test(rocker);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"reg test failed\\n\");\n\t\treturn err;\n\t}\n\n\terr = request_irq(rocker_msix_vector(rocker, ROCKER_MSIX_VEC_TEST),\n\t\t\t  rocker_test_irq_handler, 0,\n\t\t\t  rocker_driver_name, &wait);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"cannot assign test irq\\n\");\n\t\treturn err;\n\t}\n\n\trocker_wait_init(&wait);\n\trocker_write32(rocker, TEST_IRQ, ROCKER_MSIX_VEC_TEST);\n\n\tif (!rocker_wait_event_timeout(&wait, HZ / 10)) {\n\t\tdev_err(&pdev->dev, \"no interrupt received within a timeout\\n\");\n\t\terr = -EIO;\n\t\tgoto free_irq;\n\t}\n\n\terr = rocker_dma_test(rocker, &wait);\n\tif (err)\n\t\tdev_err(&pdev->dev, \"dma test failed\\n\");\n\nfree_irq:\n\tfree_irq(rocker_msix_vector(rocker, ROCKER_MSIX_VEC_TEST), &wait);\n\treturn err;\n}\n\n \n\nstatic u32 __pos_inc(u32 pos, size_t limit)\n{\n\treturn ++pos == limit ? 0 : pos;\n}\n\nstatic int rocker_desc_err(const struct rocker_desc_info *desc_info)\n{\n\tint err = desc_info->desc->comp_err & ~ROCKER_DMA_DESC_COMP_ERR_GEN;\n\n\tswitch (err) {\n\tcase ROCKER_OK:\n\t\treturn 0;\n\tcase -ROCKER_ENOENT:\n\t\treturn -ENOENT;\n\tcase -ROCKER_ENXIO:\n\t\treturn -ENXIO;\n\tcase -ROCKER_ENOMEM:\n\t\treturn -ENOMEM;\n\tcase -ROCKER_EEXIST:\n\t\treturn -EEXIST;\n\tcase -ROCKER_EINVAL:\n\t\treturn -EINVAL;\n\tcase -ROCKER_EMSGSIZE:\n\t\treturn -EMSGSIZE;\n\tcase -ROCKER_ENOTSUP:\n\t\treturn -EOPNOTSUPP;\n\tcase -ROCKER_ENOBUFS:\n\t\treturn -ENOBUFS;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic void rocker_desc_gen_clear(const struct rocker_desc_info *desc_info)\n{\n\tdesc_info->desc->comp_err &= ~ROCKER_DMA_DESC_COMP_ERR_GEN;\n}\n\nstatic bool rocker_desc_gen(const struct rocker_desc_info *desc_info)\n{\n\tu32 comp_err = desc_info->desc->comp_err;\n\n\treturn comp_err & ROCKER_DMA_DESC_COMP_ERR_GEN ? true : false;\n}\n\nstatic void *\nrocker_desc_cookie_ptr_get(const struct rocker_desc_info *desc_info)\n{\n\treturn (void *)(uintptr_t)desc_info->desc->cookie;\n}\n\nstatic void rocker_desc_cookie_ptr_set(const struct rocker_desc_info *desc_info,\n\t\t\t\t       void *ptr)\n{\n\tdesc_info->desc->cookie = (uintptr_t) ptr;\n}\n\nstatic struct rocker_desc_info *\nrocker_desc_head_get(const struct rocker_dma_ring_info *info)\n{\n\tstruct rocker_desc_info *desc_info;\n\tu32 head = __pos_inc(info->head, info->size);\n\n\tdesc_info = &info->desc_info[info->head];\n\tif (head == info->tail)\n\t\treturn NULL;  \n\tdesc_info->tlv_size = 0;\n\treturn desc_info;\n}\n\nstatic void rocker_desc_commit(const struct rocker_desc_info *desc_info)\n{\n\tdesc_info->desc->buf_size = desc_info->data_size;\n\tdesc_info->desc->tlv_size = desc_info->tlv_size;\n}\n\nstatic void rocker_desc_head_set(const struct rocker *rocker,\n\t\t\t\t struct rocker_dma_ring_info *info,\n\t\t\t\t const struct rocker_desc_info *desc_info)\n{\n\tu32 head = __pos_inc(info->head, info->size);\n\n\tBUG_ON(head == info->tail);\n\trocker_desc_commit(desc_info);\n\tinfo->head = head;\n\trocker_write32(rocker, DMA_DESC_HEAD(info->type), head);\n}\n\nstatic struct rocker_desc_info *\nrocker_desc_tail_get(struct rocker_dma_ring_info *info)\n{\n\tstruct rocker_desc_info *desc_info;\n\n\tif (info->tail == info->head)\n\t\treturn NULL;  \n\tdesc_info = &info->desc_info[info->tail];\n\tif (!rocker_desc_gen(desc_info))\n\t\treturn NULL;  \n\tinfo->tail = __pos_inc(info->tail, info->size);\n\tdesc_info->tlv_size = desc_info->desc->tlv_size;\n\treturn desc_info;\n}\n\nstatic void rocker_dma_ring_credits_set(const struct rocker *rocker,\n\t\t\t\t\tconst struct rocker_dma_ring_info *info,\n\t\t\t\t\tu32 credits)\n{\n\tif (credits)\n\t\trocker_write32(rocker, DMA_DESC_CREDITS(info->type), credits);\n}\n\nstatic unsigned long rocker_dma_ring_size_fix(size_t size)\n{\n\treturn max(ROCKER_DMA_SIZE_MIN,\n\t\t   min(roundup_pow_of_two(size), ROCKER_DMA_SIZE_MAX));\n}\n\nstatic int rocker_dma_ring_create(const struct rocker *rocker,\n\t\t\t\t  unsigned int type,\n\t\t\t\t  size_t size,\n\t\t\t\t  struct rocker_dma_ring_info *info)\n{\n\tint i;\n\n\tBUG_ON(size != rocker_dma_ring_size_fix(size));\n\tinfo->size = size;\n\tinfo->type = type;\n\tinfo->head = 0;\n\tinfo->tail = 0;\n\tinfo->desc_info = kcalloc(info->size, sizeof(*info->desc_info),\n\t\t\t\t  GFP_KERNEL);\n\tif (!info->desc_info)\n\t\treturn -ENOMEM;\n\n\tinfo->desc = dma_alloc_coherent(&rocker->pdev->dev,\n\t\t\t\t\tinfo->size * sizeof(*info->desc),\n\t\t\t\t\t&info->mapaddr, GFP_KERNEL);\n\tif (!info->desc) {\n\t\tkfree(info->desc_info);\n\t\treturn -ENOMEM;\n\t}\n\n\tfor (i = 0; i < info->size; i++)\n\t\tinfo->desc_info[i].desc = &info->desc[i];\n\n\trocker_write32(rocker, DMA_DESC_CTRL(info->type),\n\t\t       ROCKER_DMA_DESC_CTRL_RESET);\n\trocker_write64(rocker, DMA_DESC_ADDR(info->type), info->mapaddr);\n\trocker_write32(rocker, DMA_DESC_SIZE(info->type), info->size);\n\n\treturn 0;\n}\n\nstatic void rocker_dma_ring_destroy(const struct rocker *rocker,\n\t\t\t\t    const struct rocker_dma_ring_info *info)\n{\n\trocker_write64(rocker, DMA_DESC_ADDR(info->type), 0);\n\n\tdma_free_coherent(&rocker->pdev->dev,\n\t\t\t  info->size * sizeof(struct rocker_desc), info->desc,\n\t\t\t  info->mapaddr);\n\tkfree(info->desc_info);\n}\n\nstatic void rocker_dma_ring_pass_to_producer(const struct rocker *rocker,\n\t\t\t\t\t     struct rocker_dma_ring_info *info)\n{\n\tint i;\n\n\tBUG_ON(info->head || info->tail);\n\n\t \n\tfor (i = 0; i < info->size - 1; i++)\n\t\trocker_desc_head_set(rocker, info, &info->desc_info[i]);\n\trocker_desc_commit(&info->desc_info[i]);\n}\n\nstatic int rocker_dma_ring_bufs_alloc(const struct rocker *rocker,\n\t\t\t\t      const struct rocker_dma_ring_info *info,\n\t\t\t\t      int direction, size_t buf_size)\n{\n\tstruct pci_dev *pdev = rocker->pdev;\n\tint i;\n\tint err;\n\n\tfor (i = 0; i < info->size; i++) {\n\t\tstruct rocker_desc_info *desc_info = &info->desc_info[i];\n\t\tstruct rocker_desc *desc = &info->desc[i];\n\t\tdma_addr_t dma_handle;\n\t\tchar *buf;\n\n\t\tbuf = kzalloc(buf_size, GFP_KERNEL | GFP_DMA);\n\t\tif (!buf) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto rollback;\n\t\t}\n\n\t\tdma_handle = dma_map_single(&pdev->dev, buf, buf_size,\n\t\t\t\t\t    direction);\n\t\tif (dma_mapping_error(&pdev->dev, dma_handle)) {\n\t\t\tkfree(buf);\n\t\t\terr = -EIO;\n\t\t\tgoto rollback;\n\t\t}\n\n\t\tdesc_info->data = buf;\n\t\tdesc_info->data_size = buf_size;\n\t\tdma_unmap_addr_set(desc_info, mapaddr, dma_handle);\n\n\t\tdesc->buf_addr = dma_handle;\n\t\tdesc->buf_size = buf_size;\n\t}\n\treturn 0;\n\nrollback:\n\tfor (i--; i >= 0; i--) {\n\t\tconst struct rocker_desc_info *desc_info = &info->desc_info[i];\n\n\t\tdma_unmap_single(&pdev->dev,\n\t\t\t\t dma_unmap_addr(desc_info, mapaddr),\n\t\t\t\t desc_info->data_size, direction);\n\t\tkfree(desc_info->data);\n\t}\n\treturn err;\n}\n\nstatic void rocker_dma_ring_bufs_free(const struct rocker *rocker,\n\t\t\t\t      const struct rocker_dma_ring_info *info,\n\t\t\t\t      int direction)\n{\n\tstruct pci_dev *pdev = rocker->pdev;\n\tint i;\n\n\tfor (i = 0; i < info->size; i++) {\n\t\tconst struct rocker_desc_info *desc_info = &info->desc_info[i];\n\t\tstruct rocker_desc *desc = &info->desc[i];\n\n\t\tdesc->buf_addr = 0;\n\t\tdesc->buf_size = 0;\n\t\tdma_unmap_single(&pdev->dev,\n\t\t\t\t dma_unmap_addr(desc_info, mapaddr),\n\t\t\t\t desc_info->data_size, direction);\n\t\tkfree(desc_info->data);\n\t}\n}\n\nstatic int rocker_dma_cmd_ring_wait_alloc(struct rocker_desc_info *desc_info)\n{\n\tstruct rocker_wait *wait;\n\n\twait = rocker_wait_create();\n\tif (!wait)\n\t\treturn -ENOMEM;\n\trocker_desc_cookie_ptr_set(desc_info, wait);\n\treturn 0;\n}\n\nstatic void\nrocker_dma_cmd_ring_wait_free(const struct rocker_desc_info *desc_info)\n{\n\tstruct rocker_wait *wait = rocker_desc_cookie_ptr_get(desc_info);\n\n\trocker_wait_destroy(wait);\n}\n\nstatic int rocker_dma_cmd_ring_waits_alloc(const struct rocker *rocker)\n{\n\tconst struct rocker_dma_ring_info *cmd_ring = &rocker->cmd_ring;\n\tint i;\n\tint err;\n\n\tfor (i = 0; i < cmd_ring->size; i++) {\n\t\terr = rocker_dma_cmd_ring_wait_alloc(&cmd_ring->desc_info[i]);\n\t\tif (err)\n\t\t\tgoto rollback;\n\t}\n\treturn 0;\n\nrollback:\n\tfor (i--; i >= 0; i--)\n\t\trocker_dma_cmd_ring_wait_free(&cmd_ring->desc_info[i]);\n\treturn err;\n}\n\nstatic void rocker_dma_cmd_ring_waits_free(const struct rocker *rocker)\n{\n\tconst struct rocker_dma_ring_info *cmd_ring = &rocker->cmd_ring;\n\tint i;\n\n\tfor (i = 0; i < cmd_ring->size; i++)\n\t\trocker_dma_cmd_ring_wait_free(&cmd_ring->desc_info[i]);\n}\n\nstatic int rocker_dma_rings_init(struct rocker *rocker)\n{\n\tconst struct pci_dev *pdev = rocker->pdev;\n\tint err;\n\n\terr = rocker_dma_ring_create(rocker, ROCKER_DMA_CMD,\n\t\t\t\t     ROCKER_DMA_CMD_DEFAULT_SIZE,\n\t\t\t\t     &rocker->cmd_ring);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"failed to create command dma ring\\n\");\n\t\treturn err;\n\t}\n\n\tspin_lock_init(&rocker->cmd_ring_lock);\n\n\terr = rocker_dma_ring_bufs_alloc(rocker, &rocker->cmd_ring,\n\t\t\t\t\t DMA_BIDIRECTIONAL, PAGE_SIZE);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"failed to alloc command dma ring buffers\\n\");\n\t\tgoto err_dma_cmd_ring_bufs_alloc;\n\t}\n\n\terr = rocker_dma_cmd_ring_waits_alloc(rocker);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"failed to alloc command dma ring waits\\n\");\n\t\tgoto err_dma_cmd_ring_waits_alloc;\n\t}\n\n\terr = rocker_dma_ring_create(rocker, ROCKER_DMA_EVENT,\n\t\t\t\t     ROCKER_DMA_EVENT_DEFAULT_SIZE,\n\t\t\t\t     &rocker->event_ring);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"failed to create event dma ring\\n\");\n\t\tgoto err_dma_event_ring_create;\n\t}\n\n\terr = rocker_dma_ring_bufs_alloc(rocker, &rocker->event_ring,\n\t\t\t\t\t DMA_FROM_DEVICE, PAGE_SIZE);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"failed to alloc event dma ring buffers\\n\");\n\t\tgoto err_dma_event_ring_bufs_alloc;\n\t}\n\trocker_dma_ring_pass_to_producer(rocker, &rocker->event_ring);\n\treturn 0;\n\nerr_dma_event_ring_bufs_alloc:\n\trocker_dma_ring_destroy(rocker, &rocker->event_ring);\nerr_dma_event_ring_create:\n\trocker_dma_cmd_ring_waits_free(rocker);\nerr_dma_cmd_ring_waits_alloc:\n\trocker_dma_ring_bufs_free(rocker, &rocker->cmd_ring,\n\t\t\t\t  DMA_BIDIRECTIONAL);\nerr_dma_cmd_ring_bufs_alloc:\n\trocker_dma_ring_destroy(rocker, &rocker->cmd_ring);\n\treturn err;\n}\n\nstatic void rocker_dma_rings_fini(struct rocker *rocker)\n{\n\trocker_dma_ring_bufs_free(rocker, &rocker->event_ring,\n\t\t\t\t  DMA_BIDIRECTIONAL);\n\trocker_dma_ring_destroy(rocker, &rocker->event_ring);\n\trocker_dma_cmd_ring_waits_free(rocker);\n\trocker_dma_ring_bufs_free(rocker, &rocker->cmd_ring,\n\t\t\t\t  DMA_BIDIRECTIONAL);\n\trocker_dma_ring_destroy(rocker, &rocker->cmd_ring);\n}\n\nstatic int rocker_dma_rx_ring_skb_map(const struct rocker_port *rocker_port,\n\t\t\t\t      struct rocker_desc_info *desc_info,\n\t\t\t\t      struct sk_buff *skb, size_t buf_len)\n{\n\tconst struct rocker *rocker = rocker_port->rocker;\n\tstruct pci_dev *pdev = rocker->pdev;\n\tdma_addr_t dma_handle;\n\n\tdma_handle = dma_map_single(&pdev->dev, skb->data, buf_len,\n\t\t\t\t    DMA_FROM_DEVICE);\n\tif (dma_mapping_error(&pdev->dev, dma_handle))\n\t\treturn -EIO;\n\tif (rocker_tlv_put_u64(desc_info, ROCKER_TLV_RX_FRAG_ADDR, dma_handle))\n\t\tgoto tlv_put_failure;\n\tif (rocker_tlv_put_u16(desc_info, ROCKER_TLV_RX_FRAG_MAX_LEN, buf_len))\n\t\tgoto tlv_put_failure;\n\treturn 0;\n\ntlv_put_failure:\n\tdma_unmap_single(&pdev->dev, dma_handle, buf_len, DMA_FROM_DEVICE);\n\tdesc_info->tlv_size = 0;\n\treturn -EMSGSIZE;\n}\n\nstatic size_t rocker_port_rx_buf_len(const struct rocker_port *rocker_port)\n{\n\treturn rocker_port->dev->mtu + ETH_HLEN + ETH_FCS_LEN + VLAN_HLEN;\n}\n\nstatic int rocker_dma_rx_ring_skb_alloc(const struct rocker_port *rocker_port,\n\t\t\t\t\tstruct rocker_desc_info *desc_info)\n{\n\tstruct net_device *dev = rocker_port->dev;\n\tstruct sk_buff *skb;\n\tsize_t buf_len = rocker_port_rx_buf_len(rocker_port);\n\tint err;\n\n\t \n\trocker_desc_cookie_ptr_set(desc_info, NULL);\n\tdesc_info->tlv_size = 0;\n\n\tskb = netdev_alloc_skb_ip_align(dev, buf_len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\terr = rocker_dma_rx_ring_skb_map(rocker_port, desc_info, skb, buf_len);\n\tif (err) {\n\t\tdev_kfree_skb_any(skb);\n\t\treturn err;\n\t}\n\trocker_desc_cookie_ptr_set(desc_info, skb);\n\treturn 0;\n}\n\nstatic void rocker_dma_rx_ring_skb_unmap(const struct rocker *rocker,\n\t\t\t\t\t const struct rocker_tlv **attrs)\n{\n\tstruct pci_dev *pdev = rocker->pdev;\n\tdma_addr_t dma_handle;\n\tsize_t len;\n\n\tif (!attrs[ROCKER_TLV_RX_FRAG_ADDR] ||\n\t    !attrs[ROCKER_TLV_RX_FRAG_MAX_LEN])\n\t\treturn;\n\tdma_handle = rocker_tlv_get_u64(attrs[ROCKER_TLV_RX_FRAG_ADDR]);\n\tlen = rocker_tlv_get_u16(attrs[ROCKER_TLV_RX_FRAG_MAX_LEN]);\n\tdma_unmap_single(&pdev->dev, dma_handle, len, DMA_FROM_DEVICE);\n}\n\nstatic void rocker_dma_rx_ring_skb_free(const struct rocker *rocker,\n\t\t\t\t\tconst struct rocker_desc_info *desc_info)\n{\n\tconst struct rocker_tlv *attrs[ROCKER_TLV_RX_MAX + 1];\n\tstruct sk_buff *skb = rocker_desc_cookie_ptr_get(desc_info);\n\n\tif (!skb)\n\t\treturn;\n\trocker_tlv_parse_desc(attrs, ROCKER_TLV_RX_MAX, desc_info);\n\trocker_dma_rx_ring_skb_unmap(rocker, attrs);\n\tdev_kfree_skb_any(skb);\n}\n\nstatic int rocker_dma_rx_ring_skbs_alloc(const struct rocker_port *rocker_port)\n{\n\tconst struct rocker_dma_ring_info *rx_ring = &rocker_port->rx_ring;\n\tconst struct rocker *rocker = rocker_port->rocker;\n\tint i;\n\tint err;\n\n\tfor (i = 0; i < rx_ring->size; i++) {\n\t\terr = rocker_dma_rx_ring_skb_alloc(rocker_port,\n\t\t\t\t\t\t   &rx_ring->desc_info[i]);\n\t\tif (err)\n\t\t\tgoto rollback;\n\t}\n\treturn 0;\n\nrollback:\n\tfor (i--; i >= 0; i--)\n\t\trocker_dma_rx_ring_skb_free(rocker, &rx_ring->desc_info[i]);\n\treturn err;\n}\n\nstatic void rocker_dma_rx_ring_skbs_free(const struct rocker_port *rocker_port)\n{\n\tconst struct rocker_dma_ring_info *rx_ring = &rocker_port->rx_ring;\n\tconst struct rocker *rocker = rocker_port->rocker;\n\tint i;\n\n\tfor (i = 0; i < rx_ring->size; i++)\n\t\trocker_dma_rx_ring_skb_free(rocker, &rx_ring->desc_info[i]);\n}\n\nstatic int rocker_port_dma_rings_init(struct rocker_port *rocker_port)\n{\n\tstruct rocker *rocker = rocker_port->rocker;\n\tint err;\n\n\terr = rocker_dma_ring_create(rocker,\n\t\t\t\t     ROCKER_DMA_TX(rocker_port->port_number),\n\t\t\t\t     ROCKER_DMA_TX_DEFAULT_SIZE,\n\t\t\t\t     &rocker_port->tx_ring);\n\tif (err) {\n\t\tnetdev_err(rocker_port->dev, \"failed to create tx dma ring\\n\");\n\t\treturn err;\n\t}\n\n\terr = rocker_dma_ring_bufs_alloc(rocker, &rocker_port->tx_ring,\n\t\t\t\t\t DMA_TO_DEVICE,\n\t\t\t\t\t ROCKER_DMA_TX_DESC_SIZE);\n\tif (err) {\n\t\tnetdev_err(rocker_port->dev, \"failed to alloc tx dma ring buffers\\n\");\n\t\tgoto err_dma_tx_ring_bufs_alloc;\n\t}\n\n\terr = rocker_dma_ring_create(rocker,\n\t\t\t\t     ROCKER_DMA_RX(rocker_port->port_number),\n\t\t\t\t     ROCKER_DMA_RX_DEFAULT_SIZE,\n\t\t\t\t     &rocker_port->rx_ring);\n\tif (err) {\n\t\tnetdev_err(rocker_port->dev, \"failed to create rx dma ring\\n\");\n\t\tgoto err_dma_rx_ring_create;\n\t}\n\n\terr = rocker_dma_ring_bufs_alloc(rocker, &rocker_port->rx_ring,\n\t\t\t\t\t DMA_BIDIRECTIONAL,\n\t\t\t\t\t ROCKER_DMA_RX_DESC_SIZE);\n\tif (err) {\n\t\tnetdev_err(rocker_port->dev, \"failed to alloc rx dma ring buffers\\n\");\n\t\tgoto err_dma_rx_ring_bufs_alloc;\n\t}\n\n\terr = rocker_dma_rx_ring_skbs_alloc(rocker_port);\n\tif (err) {\n\t\tnetdev_err(rocker_port->dev, \"failed to alloc rx dma ring skbs\\n\");\n\t\tgoto err_dma_rx_ring_skbs_alloc;\n\t}\n\trocker_dma_ring_pass_to_producer(rocker, &rocker_port->rx_ring);\n\n\treturn 0;\n\nerr_dma_rx_ring_skbs_alloc:\n\trocker_dma_ring_bufs_free(rocker, &rocker_port->rx_ring,\n\t\t\t\t  DMA_BIDIRECTIONAL);\nerr_dma_rx_ring_bufs_alloc:\n\trocker_dma_ring_destroy(rocker, &rocker_port->rx_ring);\nerr_dma_rx_ring_create:\n\trocker_dma_ring_bufs_free(rocker, &rocker_port->tx_ring,\n\t\t\t\t  DMA_TO_DEVICE);\nerr_dma_tx_ring_bufs_alloc:\n\trocker_dma_ring_destroy(rocker, &rocker_port->tx_ring);\n\treturn err;\n}\n\nstatic void rocker_port_dma_rings_fini(struct rocker_port *rocker_port)\n{\n\tstruct rocker *rocker = rocker_port->rocker;\n\n\trocker_dma_rx_ring_skbs_free(rocker_port);\n\trocker_dma_ring_bufs_free(rocker, &rocker_port->rx_ring,\n\t\t\t\t  DMA_BIDIRECTIONAL);\n\trocker_dma_ring_destroy(rocker, &rocker_port->rx_ring);\n\trocker_dma_ring_bufs_free(rocker, &rocker_port->tx_ring,\n\t\t\t\t  DMA_TO_DEVICE);\n\trocker_dma_ring_destroy(rocker, &rocker_port->tx_ring);\n}\n\nstatic void rocker_port_set_enable(const struct rocker_port *rocker_port,\n\t\t\t\t   bool enable)\n{\n\tu64 val = rocker_read64(rocker_port->rocker, PORT_PHYS_ENABLE);\n\n\tif (enable)\n\t\tval |= 1ULL << rocker_port->pport;\n\telse\n\t\tval &= ~(1ULL << rocker_port->pport);\n\trocker_write64(rocker_port->rocker, PORT_PHYS_ENABLE, val);\n}\n\n \n\nstatic irqreturn_t rocker_cmd_irq_handler(int irq, void *dev_id)\n{\n\tstruct rocker *rocker = dev_id;\n\tconst struct rocker_desc_info *desc_info;\n\tstruct rocker_wait *wait;\n\tu32 credits = 0;\n\n\tspin_lock(&rocker->cmd_ring_lock);\n\twhile ((desc_info = rocker_desc_tail_get(&rocker->cmd_ring))) {\n\t\twait = rocker_desc_cookie_ptr_get(desc_info);\n\t\tif (wait->nowait) {\n\t\t\trocker_desc_gen_clear(desc_info);\n\t\t} else {\n\t\t\trocker_wait_wake_up(wait);\n\t\t}\n\t\tcredits++;\n\t}\n\tspin_unlock(&rocker->cmd_ring_lock);\n\trocker_dma_ring_credits_set(rocker, &rocker->cmd_ring, credits);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void rocker_port_link_up(const struct rocker_port *rocker_port)\n{\n\tnetif_carrier_on(rocker_port->dev);\n\tnetdev_info(rocker_port->dev, \"Link is up\\n\");\n}\n\nstatic void rocker_port_link_down(const struct rocker_port *rocker_port)\n{\n\tnetif_carrier_off(rocker_port->dev);\n\tnetdev_info(rocker_port->dev, \"Link is down\\n\");\n}\n\nstatic int rocker_event_link_change(const struct rocker *rocker,\n\t\t\t\t    const struct rocker_tlv *info)\n{\n\tconst struct rocker_tlv *attrs[ROCKER_TLV_EVENT_LINK_CHANGED_MAX + 1];\n\tunsigned int port_number;\n\tbool link_up;\n\tstruct rocker_port *rocker_port;\n\n\trocker_tlv_parse_nested(attrs, ROCKER_TLV_EVENT_LINK_CHANGED_MAX, info);\n\tif (!attrs[ROCKER_TLV_EVENT_LINK_CHANGED_PPORT] ||\n\t    !attrs[ROCKER_TLV_EVENT_LINK_CHANGED_LINKUP])\n\t\treturn -EIO;\n\tport_number =\n\t\trocker_tlv_get_u32(attrs[ROCKER_TLV_EVENT_LINK_CHANGED_PPORT]) - 1;\n\tlink_up = rocker_tlv_get_u8(attrs[ROCKER_TLV_EVENT_LINK_CHANGED_LINKUP]);\n\n\tif (port_number >= rocker->port_count)\n\t\treturn -EINVAL;\n\n\trocker_port = rocker->ports[port_number];\n\tif (netif_carrier_ok(rocker_port->dev) != link_up) {\n\t\tif (link_up)\n\t\t\trocker_port_link_up(rocker_port);\n\t\telse\n\t\t\trocker_port_link_down(rocker_port);\n\t}\n\n\treturn 0;\n}\n\nstatic int rocker_world_port_ev_mac_vlan_seen(struct rocker_port *rocker_port,\n\t\t\t\t\t      const unsigned char *addr,\n\t\t\t\t\t      __be16 vlan_id);\n\nstatic int rocker_event_mac_vlan_seen(const struct rocker *rocker,\n\t\t\t\t      const struct rocker_tlv *info)\n{\n\tconst struct rocker_tlv *attrs[ROCKER_TLV_EVENT_MAC_VLAN_MAX + 1];\n\tunsigned int port_number;\n\tstruct rocker_port *rocker_port;\n\tconst unsigned char *addr;\n\t__be16 vlan_id;\n\n\trocker_tlv_parse_nested(attrs, ROCKER_TLV_EVENT_MAC_VLAN_MAX, info);\n\tif (!attrs[ROCKER_TLV_EVENT_MAC_VLAN_PPORT] ||\n\t    !attrs[ROCKER_TLV_EVENT_MAC_VLAN_MAC] ||\n\t    !attrs[ROCKER_TLV_EVENT_MAC_VLAN_VLAN_ID])\n\t\treturn -EIO;\n\tport_number =\n\t\trocker_tlv_get_u32(attrs[ROCKER_TLV_EVENT_MAC_VLAN_PPORT]) - 1;\n\taddr = rocker_tlv_data(attrs[ROCKER_TLV_EVENT_MAC_VLAN_MAC]);\n\tvlan_id = rocker_tlv_get_be16(attrs[ROCKER_TLV_EVENT_MAC_VLAN_VLAN_ID]);\n\n\tif (port_number >= rocker->port_count)\n\t\treturn -EINVAL;\n\n\trocker_port = rocker->ports[port_number];\n\treturn rocker_world_port_ev_mac_vlan_seen(rocker_port, addr, vlan_id);\n}\n\nstatic int rocker_event_process(const struct rocker *rocker,\n\t\t\t\tconst struct rocker_desc_info *desc_info)\n{\n\tconst struct rocker_tlv *attrs[ROCKER_TLV_EVENT_MAX + 1];\n\tconst struct rocker_tlv *info;\n\tu16 type;\n\n\trocker_tlv_parse_desc(attrs, ROCKER_TLV_EVENT_MAX, desc_info);\n\tif (!attrs[ROCKER_TLV_EVENT_TYPE] ||\n\t    !attrs[ROCKER_TLV_EVENT_INFO])\n\t\treturn -EIO;\n\n\ttype = rocker_tlv_get_u16(attrs[ROCKER_TLV_EVENT_TYPE]);\n\tinfo = attrs[ROCKER_TLV_EVENT_INFO];\n\n\tswitch (type) {\n\tcase ROCKER_TLV_EVENT_TYPE_LINK_CHANGED:\n\t\treturn rocker_event_link_change(rocker, info);\n\tcase ROCKER_TLV_EVENT_TYPE_MAC_VLAN_SEEN:\n\t\treturn rocker_event_mac_vlan_seen(rocker, info);\n\t}\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic irqreturn_t rocker_event_irq_handler(int irq, void *dev_id)\n{\n\tstruct rocker *rocker = dev_id;\n\tconst struct pci_dev *pdev = rocker->pdev;\n\tconst struct rocker_desc_info *desc_info;\n\tu32 credits = 0;\n\tint err;\n\n\twhile ((desc_info = rocker_desc_tail_get(&rocker->event_ring))) {\n\t\terr = rocker_desc_err(desc_info);\n\t\tif (err) {\n\t\t\tdev_err(&pdev->dev, \"event desc received with err %d\\n\",\n\t\t\t\terr);\n\t\t} else {\n\t\t\terr = rocker_event_process(rocker, desc_info);\n\t\t\tif (err)\n\t\t\t\tdev_err(&pdev->dev, \"event processing failed with err %d\\n\",\n\t\t\t\t\terr);\n\t\t}\n\t\trocker_desc_gen_clear(desc_info);\n\t\trocker_desc_head_set(rocker, &rocker->event_ring, desc_info);\n\t\tcredits++;\n\t}\n\trocker_dma_ring_credits_set(rocker, &rocker->event_ring, credits);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t rocker_tx_irq_handler(int irq, void *dev_id)\n{\n\tstruct rocker_port *rocker_port = dev_id;\n\n\tnapi_schedule(&rocker_port->napi_tx);\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t rocker_rx_irq_handler(int irq, void *dev_id)\n{\n\tstruct rocker_port *rocker_port = dev_id;\n\n\tnapi_schedule(&rocker_port->napi_rx);\n\treturn IRQ_HANDLED;\n}\n\n \n\nint rocker_cmd_exec(struct rocker_port *rocker_port, bool nowait,\n\t\t    rocker_cmd_prep_cb_t prepare, void *prepare_priv,\n\t\t    rocker_cmd_proc_cb_t process, void *process_priv)\n{\n\tstruct rocker *rocker = rocker_port->rocker;\n\tstruct rocker_desc_info *desc_info;\n\tstruct rocker_wait *wait;\n\tunsigned long lock_flags;\n\tint err;\n\n\tspin_lock_irqsave(&rocker->cmd_ring_lock, lock_flags);\n\n\tdesc_info = rocker_desc_head_get(&rocker->cmd_ring);\n\tif (!desc_info) {\n\t\tspin_unlock_irqrestore(&rocker->cmd_ring_lock, lock_flags);\n\t\treturn -EAGAIN;\n\t}\n\n\twait = rocker_desc_cookie_ptr_get(desc_info);\n\trocker_wait_init(wait);\n\twait->nowait = nowait;\n\n\terr = prepare(rocker_port, desc_info, prepare_priv);\n\tif (err) {\n\t\tspin_unlock_irqrestore(&rocker->cmd_ring_lock, lock_flags);\n\t\treturn err;\n\t}\n\n\trocker_desc_head_set(rocker, &rocker->cmd_ring, desc_info);\n\n\tspin_unlock_irqrestore(&rocker->cmd_ring_lock, lock_flags);\n\n\tif (nowait)\n\t\treturn 0;\n\n\tif (!rocker_wait_event_timeout(wait, HZ / 10))\n\t\treturn -EIO;\n\n\terr = rocker_desc_err(desc_info);\n\tif (err)\n\t\treturn err;\n\n\tif (process)\n\t\terr = process(rocker_port, desc_info, process_priv);\n\n\trocker_desc_gen_clear(desc_info);\n\treturn err;\n}\n\nstatic int\nrocker_cmd_get_port_settings_prep(const struct rocker_port *rocker_port,\n\t\t\t\t  struct rocker_desc_info *desc_info,\n\t\t\t\t  void *priv)\n{\n\tstruct rocker_tlv *cmd_info;\n\n\tif (rocker_tlv_put_u16(desc_info, ROCKER_TLV_CMD_TYPE,\n\t\t\t       ROCKER_TLV_CMD_TYPE_GET_PORT_SETTINGS))\n\t\treturn -EMSGSIZE;\n\tcmd_info = rocker_tlv_nest_start(desc_info, ROCKER_TLV_CMD_INFO);\n\tif (!cmd_info)\n\t\treturn -EMSGSIZE;\n\tif (rocker_tlv_put_u32(desc_info, ROCKER_TLV_CMD_PORT_SETTINGS_PPORT,\n\t\t\t       rocker_port->pport))\n\t\treturn -EMSGSIZE;\n\trocker_tlv_nest_end(desc_info, cmd_info);\n\treturn 0;\n}\n\nstatic int\nrocker_cmd_get_port_settings_ethtool_proc(const struct rocker_port *rocker_port,\n\t\t\t\t\t  const struct rocker_desc_info *desc_info,\n\t\t\t\t\t  void *priv)\n{\n\tstruct ethtool_link_ksettings *ecmd = priv;\n\tconst struct rocker_tlv *attrs[ROCKER_TLV_CMD_MAX + 1];\n\tconst struct rocker_tlv *info_attrs[ROCKER_TLV_CMD_PORT_SETTINGS_MAX + 1];\n\tu32 speed;\n\tu8 duplex;\n\tu8 autoneg;\n\n\trocker_tlv_parse_desc(attrs, ROCKER_TLV_CMD_MAX, desc_info);\n\tif (!attrs[ROCKER_TLV_CMD_INFO])\n\t\treturn -EIO;\n\n\trocker_tlv_parse_nested(info_attrs, ROCKER_TLV_CMD_PORT_SETTINGS_MAX,\n\t\t\t\tattrs[ROCKER_TLV_CMD_INFO]);\n\tif (!info_attrs[ROCKER_TLV_CMD_PORT_SETTINGS_SPEED] ||\n\t    !info_attrs[ROCKER_TLV_CMD_PORT_SETTINGS_DUPLEX] ||\n\t    !info_attrs[ROCKER_TLV_CMD_PORT_SETTINGS_AUTONEG])\n\t\treturn -EIO;\n\n\tspeed = rocker_tlv_get_u32(info_attrs[ROCKER_TLV_CMD_PORT_SETTINGS_SPEED]);\n\tduplex = rocker_tlv_get_u8(info_attrs[ROCKER_TLV_CMD_PORT_SETTINGS_DUPLEX]);\n\tautoneg = rocker_tlv_get_u8(info_attrs[ROCKER_TLV_CMD_PORT_SETTINGS_AUTONEG]);\n\n\tethtool_link_ksettings_zero_link_mode(ecmd, supported);\n\tethtool_link_ksettings_add_link_mode(ecmd, supported, TP);\n\n\tecmd->base.phy_address = 0xff;\n\tecmd->base.port = PORT_TP;\n\tecmd->base.speed = speed;\n\tecmd->base.duplex = duplex ? DUPLEX_FULL : DUPLEX_HALF;\n\tecmd->base.autoneg = autoneg ? AUTONEG_ENABLE : AUTONEG_DISABLE;\n\n\treturn 0;\n}\n\nstatic int\nrocker_cmd_get_port_settings_macaddr_proc(const struct rocker_port *rocker_port,\n\t\t\t\t\t  const struct rocker_desc_info *desc_info,\n\t\t\t\t\t  void *priv)\n{\n\tunsigned char *macaddr = priv;\n\tconst struct rocker_tlv *attrs[ROCKER_TLV_CMD_MAX + 1];\n\tconst struct rocker_tlv *info_attrs[ROCKER_TLV_CMD_PORT_SETTINGS_MAX + 1];\n\tconst struct rocker_tlv *attr;\n\n\trocker_tlv_parse_desc(attrs, ROCKER_TLV_CMD_MAX, desc_info);\n\tif (!attrs[ROCKER_TLV_CMD_INFO])\n\t\treturn -EIO;\n\n\trocker_tlv_parse_nested(info_attrs, ROCKER_TLV_CMD_PORT_SETTINGS_MAX,\n\t\t\t\tattrs[ROCKER_TLV_CMD_INFO]);\n\tattr = info_attrs[ROCKER_TLV_CMD_PORT_SETTINGS_MACADDR];\n\tif (!attr)\n\t\treturn -EIO;\n\n\tif (rocker_tlv_len(attr) != ETH_ALEN)\n\t\treturn -EINVAL;\n\n\tether_addr_copy(macaddr, rocker_tlv_data(attr));\n\treturn 0;\n}\n\nstatic int\nrocker_cmd_get_port_settings_mode_proc(const struct rocker_port *rocker_port,\n\t\t\t\t       const struct rocker_desc_info *desc_info,\n\t\t\t\t       void *priv)\n{\n\tu8 *p_mode = priv;\n\tconst struct rocker_tlv *attrs[ROCKER_TLV_CMD_MAX + 1];\n\tconst struct rocker_tlv *info_attrs[ROCKER_TLV_CMD_PORT_SETTINGS_MAX + 1];\n\tconst struct rocker_tlv *attr;\n\n\trocker_tlv_parse_desc(attrs, ROCKER_TLV_CMD_MAX, desc_info);\n\tif (!attrs[ROCKER_TLV_CMD_INFO])\n\t\treturn -EIO;\n\n\trocker_tlv_parse_nested(info_attrs, ROCKER_TLV_CMD_PORT_SETTINGS_MAX,\n\t\t\t\tattrs[ROCKER_TLV_CMD_INFO]);\n\tattr = info_attrs[ROCKER_TLV_CMD_PORT_SETTINGS_MODE];\n\tif (!attr)\n\t\treturn -EIO;\n\n\t*p_mode = rocker_tlv_get_u8(info_attrs[ROCKER_TLV_CMD_PORT_SETTINGS_MODE]);\n\treturn 0;\n}\n\nstruct port_name {\n\tchar *buf;\n\tsize_t len;\n};\n\nstatic int\nrocker_cmd_get_port_settings_phys_name_proc(const struct rocker_port *rocker_port,\n\t\t\t\t\t    const struct rocker_desc_info *desc_info,\n\t\t\t\t\t    void *priv)\n{\n\tconst struct rocker_tlv *info_attrs[ROCKER_TLV_CMD_PORT_SETTINGS_MAX + 1];\n\tconst struct rocker_tlv *attrs[ROCKER_TLV_CMD_MAX + 1];\n\tstruct port_name *name = priv;\n\tconst struct rocker_tlv *attr;\n\tsize_t i, j, len;\n\tconst char *str;\n\n\trocker_tlv_parse_desc(attrs, ROCKER_TLV_CMD_MAX, desc_info);\n\tif (!attrs[ROCKER_TLV_CMD_INFO])\n\t\treturn -EIO;\n\n\trocker_tlv_parse_nested(info_attrs, ROCKER_TLV_CMD_PORT_SETTINGS_MAX,\n\t\t\t\tattrs[ROCKER_TLV_CMD_INFO]);\n\tattr = info_attrs[ROCKER_TLV_CMD_PORT_SETTINGS_PHYS_NAME];\n\tif (!attr)\n\t\treturn -EIO;\n\n\tlen = min_t(size_t, rocker_tlv_len(attr), name->len);\n\tstr = rocker_tlv_data(attr);\n\n\t \n\tfor (i = j = 0; i < len; ++i) {\n\t\tif (isalnum(str[i])) {\n\t\t\tname->buf[j] = str[i];\n\t\t\tj++;\n\t\t}\n\t}\n\n\tif (j == 0)\n\t\treturn -EIO;\n\n\tname->buf[j] = '\\0';\n\n\treturn 0;\n}\n\nstatic int\nrocker_cmd_set_port_settings_ethtool_prep(const struct rocker_port *rocker_port,\n\t\t\t\t\t  struct rocker_desc_info *desc_info,\n\t\t\t\t\t  void *priv)\n{\n\tstruct ethtool_link_ksettings *ecmd = priv;\n\tstruct rocker_tlv *cmd_info;\n\n\tif (rocker_tlv_put_u16(desc_info, ROCKER_TLV_CMD_TYPE,\n\t\t\t       ROCKER_TLV_CMD_TYPE_SET_PORT_SETTINGS))\n\t\treturn -EMSGSIZE;\n\tcmd_info = rocker_tlv_nest_start(desc_info, ROCKER_TLV_CMD_INFO);\n\tif (!cmd_info)\n\t\treturn -EMSGSIZE;\n\tif (rocker_tlv_put_u32(desc_info, ROCKER_TLV_CMD_PORT_SETTINGS_PPORT,\n\t\t\t       rocker_port->pport))\n\t\treturn -EMSGSIZE;\n\tif (rocker_tlv_put_u32(desc_info, ROCKER_TLV_CMD_PORT_SETTINGS_SPEED,\n\t\t\t       ecmd->base.speed))\n\t\treturn -EMSGSIZE;\n\tif (rocker_tlv_put_u8(desc_info, ROCKER_TLV_CMD_PORT_SETTINGS_DUPLEX,\n\t\t\t      ecmd->base.duplex))\n\t\treturn -EMSGSIZE;\n\tif (rocker_tlv_put_u8(desc_info, ROCKER_TLV_CMD_PORT_SETTINGS_AUTONEG,\n\t\t\t      ecmd->base.autoneg))\n\t\treturn -EMSGSIZE;\n\trocker_tlv_nest_end(desc_info, cmd_info);\n\treturn 0;\n}\n\nstatic int\nrocker_cmd_set_port_settings_macaddr_prep(const struct rocker_port *rocker_port,\n\t\t\t\t\t  struct rocker_desc_info *desc_info,\n\t\t\t\t\t  void *priv)\n{\n\tconst unsigned char *macaddr = priv;\n\tstruct rocker_tlv *cmd_info;\n\n\tif (rocker_tlv_put_u16(desc_info, ROCKER_TLV_CMD_TYPE,\n\t\t\t       ROCKER_TLV_CMD_TYPE_SET_PORT_SETTINGS))\n\t\treturn -EMSGSIZE;\n\tcmd_info = rocker_tlv_nest_start(desc_info, ROCKER_TLV_CMD_INFO);\n\tif (!cmd_info)\n\t\treturn -EMSGSIZE;\n\tif (rocker_tlv_put_u32(desc_info, ROCKER_TLV_CMD_PORT_SETTINGS_PPORT,\n\t\t\t       rocker_port->pport))\n\t\treturn -EMSGSIZE;\n\tif (rocker_tlv_put(desc_info, ROCKER_TLV_CMD_PORT_SETTINGS_MACADDR,\n\t\t\t   ETH_ALEN, macaddr))\n\t\treturn -EMSGSIZE;\n\trocker_tlv_nest_end(desc_info, cmd_info);\n\treturn 0;\n}\n\nstatic int\nrocker_cmd_set_port_settings_mtu_prep(const struct rocker_port *rocker_port,\n\t\t\t\t      struct rocker_desc_info *desc_info,\n\t\t\t\t      void *priv)\n{\n\tint mtu = *(int *)priv;\n\tstruct rocker_tlv *cmd_info;\n\n\tif (rocker_tlv_put_u16(desc_info, ROCKER_TLV_CMD_TYPE,\n\t\t\t       ROCKER_TLV_CMD_TYPE_SET_PORT_SETTINGS))\n\t\treturn -EMSGSIZE;\n\tcmd_info = rocker_tlv_nest_start(desc_info, ROCKER_TLV_CMD_INFO);\n\tif (!cmd_info)\n\t\treturn -EMSGSIZE;\n\tif (rocker_tlv_put_u32(desc_info, ROCKER_TLV_CMD_PORT_SETTINGS_PPORT,\n\t\t\t       rocker_port->pport))\n\t\treturn -EMSGSIZE;\n\tif (rocker_tlv_put_u16(desc_info, ROCKER_TLV_CMD_PORT_SETTINGS_MTU,\n\t\t\t       mtu))\n\t\treturn -EMSGSIZE;\n\trocker_tlv_nest_end(desc_info, cmd_info);\n\treturn 0;\n}\n\nstatic int\nrocker_cmd_set_port_learning_prep(const struct rocker_port *rocker_port,\n\t\t\t\t  struct rocker_desc_info *desc_info,\n\t\t\t\t  void *priv)\n{\n\tbool learning = *(bool *)priv;\n\tstruct rocker_tlv *cmd_info;\n\n\tif (rocker_tlv_put_u16(desc_info, ROCKER_TLV_CMD_TYPE,\n\t\t\t       ROCKER_TLV_CMD_TYPE_SET_PORT_SETTINGS))\n\t\treturn -EMSGSIZE;\n\tcmd_info = rocker_tlv_nest_start(desc_info, ROCKER_TLV_CMD_INFO);\n\tif (!cmd_info)\n\t\treturn -EMSGSIZE;\n\tif (rocker_tlv_put_u32(desc_info, ROCKER_TLV_CMD_PORT_SETTINGS_PPORT,\n\t\t\t       rocker_port->pport))\n\t\treturn -EMSGSIZE;\n\tif (rocker_tlv_put_u8(desc_info, ROCKER_TLV_CMD_PORT_SETTINGS_LEARNING,\n\t\t\t      learning))\n\t\treturn -EMSGSIZE;\n\trocker_tlv_nest_end(desc_info, cmd_info);\n\treturn 0;\n}\n\nstatic int\nrocker_cmd_get_port_settings_ethtool(struct rocker_port *rocker_port,\n\t\t\t\t     struct ethtool_link_ksettings *ecmd)\n{\n\treturn rocker_cmd_exec(rocker_port, false,\n\t\t\t       rocker_cmd_get_port_settings_prep, NULL,\n\t\t\t       rocker_cmd_get_port_settings_ethtool_proc,\n\t\t\t       ecmd);\n}\n\nstatic int rocker_cmd_get_port_settings_macaddr(struct rocker_port *rocker_port,\n\t\t\t\t\t\tunsigned char *macaddr)\n{\n\treturn rocker_cmd_exec(rocker_port, false,\n\t\t\t       rocker_cmd_get_port_settings_prep, NULL,\n\t\t\t       rocker_cmd_get_port_settings_macaddr_proc,\n\t\t\t       macaddr);\n}\n\nstatic int rocker_cmd_get_port_settings_mode(struct rocker_port *rocker_port,\n\t\t\t\t\t     u8 *p_mode)\n{\n\treturn rocker_cmd_exec(rocker_port, false,\n\t\t\t       rocker_cmd_get_port_settings_prep, NULL,\n\t\t\t       rocker_cmd_get_port_settings_mode_proc, p_mode);\n}\n\nstatic int\nrocker_cmd_set_port_settings_ethtool(struct rocker_port *rocker_port,\n\t\t\t\t     const struct ethtool_link_ksettings *ecmd)\n{\n\tstruct ethtool_link_ksettings copy_ecmd;\n\n\tmemcpy(&copy_ecmd, ecmd, sizeof(copy_ecmd));\n\n\treturn rocker_cmd_exec(rocker_port, false,\n\t\t\t       rocker_cmd_set_port_settings_ethtool_prep,\n\t\t\t       &copy_ecmd, NULL, NULL);\n}\n\nstatic int rocker_cmd_set_port_settings_macaddr(struct rocker_port *rocker_port,\n\t\t\t\t\t\tunsigned char *macaddr)\n{\n\treturn rocker_cmd_exec(rocker_port, false,\n\t\t\t       rocker_cmd_set_port_settings_macaddr_prep,\n\t\t\t       macaddr, NULL, NULL);\n}\n\nstatic int rocker_cmd_set_port_settings_mtu(struct rocker_port *rocker_port,\n\t\t\t\t\t    int mtu)\n{\n\treturn rocker_cmd_exec(rocker_port, false,\n\t\t\t       rocker_cmd_set_port_settings_mtu_prep,\n\t\t\t       &mtu, NULL, NULL);\n}\n\nint rocker_port_set_learning(struct rocker_port *rocker_port,\n\t\t\t     bool learning)\n{\n\treturn rocker_cmd_exec(rocker_port, false,\n\t\t\t       rocker_cmd_set_port_learning_prep,\n\t\t\t       &learning, NULL, NULL);\n}\n\n \n\nstatic struct rocker_world_ops *rocker_world_ops[] = {\n\t&rocker_ofdpa_ops,\n};\n\n#define ROCKER_WORLD_OPS_LEN ARRAY_SIZE(rocker_world_ops)\n\nstatic struct rocker_world_ops *rocker_world_ops_find(u8 mode)\n{\n\tint i;\n\n\tfor (i = 0; i < ROCKER_WORLD_OPS_LEN; i++)\n\t\tif (rocker_world_ops[i]->mode == mode)\n\t\t\treturn rocker_world_ops[i];\n\treturn NULL;\n}\n\nstatic int rocker_world_init(struct rocker *rocker, u8 mode)\n{\n\tstruct rocker_world_ops *wops;\n\tint err;\n\n\twops = rocker_world_ops_find(mode);\n\tif (!wops) {\n\t\tdev_err(&rocker->pdev->dev, \"port mode \\\"%d\\\" is not supported\\n\",\n\t\t\tmode);\n\t\treturn -EINVAL;\n\t}\n\trocker->wops = wops;\n\trocker->wpriv = kzalloc(wops->priv_size, GFP_KERNEL);\n\tif (!rocker->wpriv)\n\t\treturn -ENOMEM;\n\tif (!wops->init)\n\t\treturn 0;\n\terr = wops->init(rocker);\n\tif (err)\n\t\tkfree(rocker->wpriv);\n\treturn err;\n}\n\nstatic void rocker_world_fini(struct rocker *rocker)\n{\n\tstruct rocker_world_ops *wops = rocker->wops;\n\n\tif (!wops || !wops->fini)\n\t\treturn;\n\twops->fini(rocker);\n\tkfree(rocker->wpriv);\n}\n\nstatic int rocker_world_check_init(struct rocker_port *rocker_port)\n{\n\tstruct rocker *rocker = rocker_port->rocker;\n\tu8 mode;\n\tint err;\n\n\terr = rocker_cmd_get_port_settings_mode(rocker_port, &mode);\n\tif (err) {\n\t\tdev_err(&rocker->pdev->dev, \"failed to get port mode\\n\");\n\t\treturn err;\n\t}\n\tif (rocker->wops) {\n\t\tif (rocker->wops->mode != mode) {\n\t\t\tdev_err(&rocker->pdev->dev, \"hardware has ports in different worlds, which is not supported\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\treturn 0;\n\t}\n\treturn rocker_world_init(rocker, mode);\n}\n\nstatic int rocker_world_port_pre_init(struct rocker_port *rocker_port)\n{\n\tstruct rocker_world_ops *wops = rocker_port->rocker->wops;\n\tint err;\n\n\trocker_port->wpriv = kzalloc(wops->port_priv_size, GFP_KERNEL);\n\tif (!rocker_port->wpriv)\n\t\treturn -ENOMEM;\n\tif (!wops->port_pre_init)\n\t\treturn 0;\n\terr = wops->port_pre_init(rocker_port);\n\tif (err)\n\t\tkfree(rocker_port->wpriv);\n\treturn 0;\n}\n\nstatic int rocker_world_port_init(struct rocker_port *rocker_port)\n{\n\tstruct rocker_world_ops *wops = rocker_port->rocker->wops;\n\n\tif (!wops->port_init)\n\t\treturn 0;\n\treturn wops->port_init(rocker_port);\n}\n\nstatic void rocker_world_port_fini(struct rocker_port *rocker_port)\n{\n\tstruct rocker_world_ops *wops = rocker_port->rocker->wops;\n\n\tif (!wops->port_fini)\n\t\treturn;\n\twops->port_fini(rocker_port);\n}\n\nstatic void rocker_world_port_post_fini(struct rocker_port *rocker_port)\n{\n\tstruct rocker_world_ops *wops = rocker_port->rocker->wops;\n\n\tif (!wops->port_post_fini)\n\t\treturn;\n\twops->port_post_fini(rocker_port);\n\tkfree(rocker_port->wpriv);\n}\n\nstatic int rocker_world_port_open(struct rocker_port *rocker_port)\n{\n\tstruct rocker_world_ops *wops = rocker_port->rocker->wops;\n\n\tif (!wops->port_open)\n\t\treturn 0;\n\treturn wops->port_open(rocker_port);\n}\n\nstatic void rocker_world_port_stop(struct rocker_port *rocker_port)\n{\n\tstruct rocker_world_ops *wops = rocker_port->rocker->wops;\n\n\tif (!wops->port_stop)\n\t\treturn;\n\twops->port_stop(rocker_port);\n}\n\nstatic int rocker_world_port_attr_stp_state_set(struct rocker_port *rocker_port,\n\t\t\t\t\t\tu8 state)\n{\n\tstruct rocker_world_ops *wops = rocker_port->rocker->wops;\n\n\tif (!wops->port_attr_stp_state_set)\n\t\treturn -EOPNOTSUPP;\n\n\treturn wops->port_attr_stp_state_set(rocker_port, state);\n}\n\nstatic int\nrocker_world_port_attr_bridge_flags_support_get(const struct rocker_port *\n\t\t\t\t\t\trocker_port,\n\t\t\t\t\t\tunsigned long *\n\t\t\t\t\t\tp_brport_flags_support)\n{\n\tstruct rocker_world_ops *wops = rocker_port->rocker->wops;\n\n\tif (!wops->port_attr_bridge_flags_support_get)\n\t\treturn -EOPNOTSUPP;\n\treturn wops->port_attr_bridge_flags_support_get(rocker_port,\n\t\t\t\t\t\t\tp_brport_flags_support);\n}\n\nstatic int\nrocker_world_port_attr_pre_bridge_flags_set(struct rocker_port *rocker_port,\n\t\t\t\t\t    struct switchdev_brport_flags flags)\n{\n\tstruct rocker_world_ops *wops = rocker_port->rocker->wops;\n\tunsigned long brport_flags_s;\n\tint err;\n\n\tif (!wops->port_attr_bridge_flags_set)\n\t\treturn -EOPNOTSUPP;\n\n\terr = rocker_world_port_attr_bridge_flags_support_get(rocker_port,\n\t\t\t\t\t\t\t      &brport_flags_s);\n\tif (err)\n\t\treturn err;\n\n\tif (flags.mask & ~brport_flags_s)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int\nrocker_world_port_attr_bridge_flags_set(struct rocker_port *rocker_port,\n\t\t\t\t\tstruct switchdev_brport_flags flags)\n{\n\tstruct rocker_world_ops *wops = rocker_port->rocker->wops;\n\n\tif (!wops->port_attr_bridge_flags_set)\n\t\treturn -EOPNOTSUPP;\n\n\treturn wops->port_attr_bridge_flags_set(rocker_port, flags.val);\n}\n\nstatic int\nrocker_world_port_attr_bridge_ageing_time_set(struct rocker_port *rocker_port,\n\t\t\t\t\t      u32 ageing_time)\n{\n\tstruct rocker_world_ops *wops = rocker_port->rocker->wops;\n\n\tif (!wops->port_attr_bridge_ageing_time_set)\n\t\treturn -EOPNOTSUPP;\n\n\treturn wops->port_attr_bridge_ageing_time_set(rocker_port, ageing_time);\n}\n\nstatic int\nrocker_world_port_obj_vlan_add(struct rocker_port *rocker_port,\n\t\t\t       const struct switchdev_obj_port_vlan *vlan)\n{\n\tstruct rocker_world_ops *wops = rocker_port->rocker->wops;\n\n\tif (!wops->port_obj_vlan_add)\n\t\treturn -EOPNOTSUPP;\n\n\treturn wops->port_obj_vlan_add(rocker_port, vlan);\n}\n\nstatic int\nrocker_world_port_obj_vlan_del(struct rocker_port *rocker_port,\n\t\t\t       const struct switchdev_obj_port_vlan *vlan)\n{\n\tstruct rocker_world_ops *wops = rocker_port->rocker->wops;\n\n\tif (netif_is_bridge_master(vlan->obj.orig_dev))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!wops->port_obj_vlan_del)\n\t\treturn -EOPNOTSUPP;\n\treturn wops->port_obj_vlan_del(rocker_port, vlan);\n}\n\nstatic int\nrocker_world_port_fdb_add(struct rocker_port *rocker_port,\n\t\t\t  struct switchdev_notifier_fdb_info *info)\n{\n\tstruct rocker_world_ops *wops = rocker_port->rocker->wops;\n\n\tif (!wops->port_obj_fdb_add)\n\t\treturn -EOPNOTSUPP;\n\n\treturn wops->port_obj_fdb_add(rocker_port, info->vid, info->addr);\n}\n\nstatic int\nrocker_world_port_fdb_del(struct rocker_port *rocker_port,\n\t\t\t  struct switchdev_notifier_fdb_info *info)\n{\n\tstruct rocker_world_ops *wops = rocker_port->rocker->wops;\n\n\tif (!wops->port_obj_fdb_del)\n\t\treturn -EOPNOTSUPP;\n\treturn wops->port_obj_fdb_del(rocker_port, info->vid, info->addr);\n}\n\nstatic int rocker_world_port_master_linked(struct rocker_port *rocker_port,\n\t\t\t\t\t   struct net_device *master,\n\t\t\t\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct rocker_world_ops *wops = rocker_port->rocker->wops;\n\n\tif (!wops->port_master_linked)\n\t\treturn -EOPNOTSUPP;\n\treturn wops->port_master_linked(rocker_port, master, extack);\n}\n\nstatic int rocker_world_port_master_unlinked(struct rocker_port *rocker_port,\n\t\t\t\t\t     struct net_device *master)\n{\n\tstruct rocker_world_ops *wops = rocker_port->rocker->wops;\n\n\tif (!wops->port_master_unlinked)\n\t\treturn -EOPNOTSUPP;\n\treturn wops->port_master_unlinked(rocker_port, master);\n}\n\nstatic int rocker_world_port_neigh_update(struct rocker_port *rocker_port,\n\t\t\t\t\t  struct neighbour *n)\n{\n\tstruct rocker_world_ops *wops = rocker_port->rocker->wops;\n\n\tif (!wops->port_neigh_update)\n\t\treturn -EOPNOTSUPP;\n\treturn wops->port_neigh_update(rocker_port, n);\n}\n\nstatic int rocker_world_port_neigh_destroy(struct rocker_port *rocker_port,\n\t\t\t\t\t   struct neighbour *n)\n{\n\tstruct rocker_world_ops *wops = rocker_port->rocker->wops;\n\n\tif (!wops->port_neigh_destroy)\n\t\treturn -EOPNOTSUPP;\n\treturn wops->port_neigh_destroy(rocker_port, n);\n}\n\nstatic int rocker_world_port_ev_mac_vlan_seen(struct rocker_port *rocker_port,\n\t\t\t\t\t      const unsigned char *addr,\n\t\t\t\t\t      __be16 vlan_id)\n{\n\tstruct rocker_world_ops *wops = rocker_port->rocker->wops;\n\n\tif (!wops->port_ev_mac_vlan_seen)\n\t\treturn -EOPNOTSUPP;\n\treturn wops->port_ev_mac_vlan_seen(rocker_port, addr, vlan_id);\n}\n\nstatic int rocker_world_fib4_add(struct rocker *rocker,\n\t\t\t\t const struct fib_entry_notifier_info *fen_info)\n{\n\tstruct rocker_world_ops *wops = rocker->wops;\n\n\tif (!wops->fib4_add)\n\t\treturn 0;\n\treturn wops->fib4_add(rocker, fen_info);\n}\n\nstatic int rocker_world_fib4_del(struct rocker *rocker,\n\t\t\t\t const struct fib_entry_notifier_info *fen_info)\n{\n\tstruct rocker_world_ops *wops = rocker->wops;\n\n\tif (!wops->fib4_del)\n\t\treturn 0;\n\treturn wops->fib4_del(rocker, fen_info);\n}\n\nstatic void rocker_world_fib4_abort(struct rocker *rocker)\n{\n\tstruct rocker_world_ops *wops = rocker->wops;\n\n\tif (wops->fib4_abort)\n\t\twops->fib4_abort(rocker);\n}\n\n \n\nstatic int rocker_port_open(struct net_device *dev)\n{\n\tstruct rocker_port *rocker_port = netdev_priv(dev);\n\tint err;\n\n\terr = rocker_port_dma_rings_init(rocker_port);\n\tif (err)\n\t\treturn err;\n\n\terr = request_irq(rocker_msix_tx_vector(rocker_port),\n\t\t\t  rocker_tx_irq_handler, 0,\n\t\t\t  rocker_driver_name, rocker_port);\n\tif (err) {\n\t\tnetdev_err(rocker_port->dev, \"cannot assign tx irq\\n\");\n\t\tgoto err_request_tx_irq;\n\t}\n\n\terr = request_irq(rocker_msix_rx_vector(rocker_port),\n\t\t\t  rocker_rx_irq_handler, 0,\n\t\t\t  rocker_driver_name, rocker_port);\n\tif (err) {\n\t\tnetdev_err(rocker_port->dev, \"cannot assign rx irq\\n\");\n\t\tgoto err_request_rx_irq;\n\t}\n\n\terr = rocker_world_port_open(rocker_port);\n\tif (err) {\n\t\tnetdev_err(rocker_port->dev, \"cannot open port in world\\n\");\n\t\tgoto err_world_port_open;\n\t}\n\n\tnapi_enable(&rocker_port->napi_tx);\n\tnapi_enable(&rocker_port->napi_rx);\n\tif (!dev->proto_down)\n\t\trocker_port_set_enable(rocker_port, true);\n\tnetif_start_queue(dev);\n\treturn 0;\n\nerr_world_port_open:\n\tfree_irq(rocker_msix_rx_vector(rocker_port), rocker_port);\nerr_request_rx_irq:\n\tfree_irq(rocker_msix_tx_vector(rocker_port), rocker_port);\nerr_request_tx_irq:\n\trocker_port_dma_rings_fini(rocker_port);\n\treturn err;\n}\n\nstatic int rocker_port_stop(struct net_device *dev)\n{\n\tstruct rocker_port *rocker_port = netdev_priv(dev);\n\n\tnetif_stop_queue(dev);\n\trocker_port_set_enable(rocker_port, false);\n\tnapi_disable(&rocker_port->napi_rx);\n\tnapi_disable(&rocker_port->napi_tx);\n\trocker_world_port_stop(rocker_port);\n\tfree_irq(rocker_msix_rx_vector(rocker_port), rocker_port);\n\tfree_irq(rocker_msix_tx_vector(rocker_port), rocker_port);\n\trocker_port_dma_rings_fini(rocker_port);\n\n\treturn 0;\n}\n\nstatic void rocker_tx_desc_frags_unmap(const struct rocker_port *rocker_port,\n\t\t\t\t       const struct rocker_desc_info *desc_info)\n{\n\tconst struct rocker *rocker = rocker_port->rocker;\n\tstruct pci_dev *pdev = rocker->pdev;\n\tconst struct rocker_tlv *attrs[ROCKER_TLV_TX_MAX + 1];\n\tstruct rocker_tlv *attr;\n\tint rem;\n\n\trocker_tlv_parse_desc(attrs, ROCKER_TLV_TX_MAX, desc_info);\n\tif (!attrs[ROCKER_TLV_TX_FRAGS])\n\t\treturn;\n\trocker_tlv_for_each_nested(attr, attrs[ROCKER_TLV_TX_FRAGS], rem) {\n\t\tconst struct rocker_tlv *frag_attrs[ROCKER_TLV_TX_FRAG_ATTR_MAX + 1];\n\t\tdma_addr_t dma_handle;\n\t\tsize_t len;\n\n\t\tif (rocker_tlv_type(attr) != ROCKER_TLV_TX_FRAG)\n\t\t\tcontinue;\n\t\trocker_tlv_parse_nested(frag_attrs, ROCKER_TLV_TX_FRAG_ATTR_MAX,\n\t\t\t\t\tattr);\n\t\tif (!frag_attrs[ROCKER_TLV_TX_FRAG_ATTR_ADDR] ||\n\t\t    !frag_attrs[ROCKER_TLV_TX_FRAG_ATTR_LEN])\n\t\t\tcontinue;\n\t\tdma_handle = rocker_tlv_get_u64(frag_attrs[ROCKER_TLV_TX_FRAG_ATTR_ADDR]);\n\t\tlen = rocker_tlv_get_u16(frag_attrs[ROCKER_TLV_TX_FRAG_ATTR_LEN]);\n\t\tdma_unmap_single(&pdev->dev, dma_handle, len, DMA_TO_DEVICE);\n\t}\n}\n\nstatic int rocker_tx_desc_frag_map_put(const struct rocker_port *rocker_port,\n\t\t\t\t       struct rocker_desc_info *desc_info,\n\t\t\t\t       char *buf, size_t buf_len)\n{\n\tconst struct rocker *rocker = rocker_port->rocker;\n\tstruct pci_dev *pdev = rocker->pdev;\n\tdma_addr_t dma_handle;\n\tstruct rocker_tlv *frag;\n\n\tdma_handle = dma_map_single(&pdev->dev, buf, buf_len, DMA_TO_DEVICE);\n\tif (unlikely(dma_mapping_error(&pdev->dev, dma_handle))) {\n\t\tif (net_ratelimit())\n\t\t\tnetdev_err(rocker_port->dev, \"failed to dma map tx frag\\n\");\n\t\treturn -EIO;\n\t}\n\tfrag = rocker_tlv_nest_start(desc_info, ROCKER_TLV_TX_FRAG);\n\tif (!frag)\n\t\tgoto unmap_frag;\n\tif (rocker_tlv_put_u64(desc_info, ROCKER_TLV_TX_FRAG_ATTR_ADDR,\n\t\t\t       dma_handle))\n\t\tgoto nest_cancel;\n\tif (rocker_tlv_put_u16(desc_info, ROCKER_TLV_TX_FRAG_ATTR_LEN,\n\t\t\t       buf_len))\n\t\tgoto nest_cancel;\n\trocker_tlv_nest_end(desc_info, frag);\n\treturn 0;\n\nnest_cancel:\n\trocker_tlv_nest_cancel(desc_info, frag);\nunmap_frag:\n\tdma_unmap_single(&pdev->dev, dma_handle, buf_len, DMA_TO_DEVICE);\n\treturn -EMSGSIZE;\n}\n\nstatic netdev_tx_t rocker_port_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct rocker_port *rocker_port = netdev_priv(dev);\n\tstruct rocker *rocker = rocker_port->rocker;\n\tstruct rocker_desc_info *desc_info;\n\tstruct rocker_tlv *frags;\n\tint i;\n\tint err;\n\n\tdesc_info = rocker_desc_head_get(&rocker_port->tx_ring);\n\tif (unlikely(!desc_info)) {\n\t\tif (net_ratelimit())\n\t\t\tnetdev_err(dev, \"tx ring full when queue awake\\n\");\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\n\trocker_desc_cookie_ptr_set(desc_info, skb);\n\n\tfrags = rocker_tlv_nest_start(desc_info, ROCKER_TLV_TX_FRAGS);\n\tif (!frags)\n\t\tgoto out;\n\terr = rocker_tx_desc_frag_map_put(rocker_port, desc_info,\n\t\t\t\t\t  skb->data, skb_headlen(skb));\n\tif (err)\n\t\tgoto nest_cancel;\n\tif (skb_shinfo(skb)->nr_frags > ROCKER_TX_FRAGS_MAX) {\n\t\terr = skb_linearize(skb);\n\t\tif (err)\n\t\t\tgoto unmap_frags;\n\t}\n\n\tfor (i = 0; i < skb_shinfo(skb)->nr_frags; i++) {\n\t\tconst skb_frag_t *frag = &skb_shinfo(skb)->frags[i];\n\n\t\terr = rocker_tx_desc_frag_map_put(rocker_port, desc_info,\n\t\t\t\t\t\t  skb_frag_address(frag),\n\t\t\t\t\t\t  skb_frag_size(frag));\n\t\tif (err)\n\t\t\tgoto unmap_frags;\n\t}\n\trocker_tlv_nest_end(desc_info, frags);\n\n\trocker_desc_gen_clear(desc_info);\n\trocker_desc_head_set(rocker, &rocker_port->tx_ring, desc_info);\n\n\tdesc_info = rocker_desc_head_get(&rocker_port->tx_ring);\n\tif (!desc_info)\n\t\tnetif_stop_queue(dev);\n\n\treturn NETDEV_TX_OK;\n\nunmap_frags:\n\trocker_tx_desc_frags_unmap(rocker_port, desc_info);\nnest_cancel:\n\trocker_tlv_nest_cancel(desc_info, frags);\nout:\n\tdev_kfree_skb(skb);\n\tdev->stats.tx_dropped++;\n\n\treturn NETDEV_TX_OK;\n}\n\nstatic int rocker_port_set_mac_address(struct net_device *dev, void *p)\n{\n\tstruct sockaddr *addr = p;\n\tstruct rocker_port *rocker_port = netdev_priv(dev);\n\tint err;\n\n\tif (!is_valid_ether_addr(addr->sa_data))\n\t\treturn -EADDRNOTAVAIL;\n\n\terr = rocker_cmd_set_port_settings_macaddr(rocker_port, addr->sa_data);\n\tif (err)\n\t\treturn err;\n\teth_hw_addr_set(dev, addr->sa_data);\n\treturn 0;\n}\n\nstatic int rocker_port_change_mtu(struct net_device *dev, int new_mtu)\n{\n\tstruct rocker_port *rocker_port = netdev_priv(dev);\n\tint running = netif_running(dev);\n\tint err;\n\n\tif (running)\n\t\trocker_port_stop(dev);\n\n\tnetdev_info(dev, \"MTU change from %d to %d\\n\", dev->mtu, new_mtu);\n\tdev->mtu = new_mtu;\n\n\terr = rocker_cmd_set_port_settings_mtu(rocker_port, new_mtu);\n\tif (err)\n\t\treturn err;\n\n\tif (running)\n\t\terr = rocker_port_open(dev);\n\n\treturn err;\n}\n\nstatic int rocker_port_get_phys_port_name(struct net_device *dev,\n\t\t\t\t\t  char *buf, size_t len)\n{\n\tstruct rocker_port *rocker_port = netdev_priv(dev);\n\tstruct port_name name = { .buf = buf, .len = len };\n\tint err;\n\n\terr = rocker_cmd_exec(rocker_port, false,\n\t\t\t      rocker_cmd_get_port_settings_prep, NULL,\n\t\t\t      rocker_cmd_get_port_settings_phys_name_proc,\n\t\t\t      &name);\n\n\treturn err ? -EOPNOTSUPP : 0;\n}\n\nstatic void rocker_port_neigh_destroy(struct net_device *dev,\n\t\t\t\t      struct neighbour *n)\n{\n\tstruct rocker_port *rocker_port = netdev_priv(n->dev);\n\tint err;\n\n\terr = rocker_world_port_neigh_destroy(rocker_port, n);\n\tif (err)\n\t\tnetdev_warn(rocker_port->dev, \"failed to handle neigh destroy (err %d)\\n\",\n\t\t\t    err);\n}\n\nstatic int rocker_port_get_port_parent_id(struct net_device *dev,\n\t\t\t\t\t  struct netdev_phys_item_id *ppid)\n{\n\tconst struct rocker_port *rocker_port = netdev_priv(dev);\n\tconst struct rocker *rocker = rocker_port->rocker;\n\n\tppid->id_len = sizeof(rocker->hw.id);\n\tmemcpy(&ppid->id, &rocker->hw.id, ppid->id_len);\n\n\treturn 0;\n}\n\nstatic const struct net_device_ops rocker_port_netdev_ops = {\n\t.ndo_open\t\t\t= rocker_port_open,\n\t.ndo_stop\t\t\t= rocker_port_stop,\n\t.ndo_start_xmit\t\t\t= rocker_port_xmit,\n\t.ndo_set_mac_address\t\t= rocker_port_set_mac_address,\n\t.ndo_change_mtu\t\t\t= rocker_port_change_mtu,\n\t.ndo_get_phys_port_name\t\t= rocker_port_get_phys_port_name,\n\t.ndo_neigh_destroy\t\t= rocker_port_neigh_destroy,\n\t.ndo_get_port_parent_id\t\t= rocker_port_get_port_parent_id,\n};\n\n \n\nstatic int rocker_port_attr_set(struct net_device *dev,\n\t\t\t\tconst struct switchdev_attr *attr)\n{\n\tstruct rocker_port *rocker_port = netdev_priv(dev);\n\tint err = 0;\n\n\tswitch (attr->id) {\n\tcase SWITCHDEV_ATTR_ID_PORT_STP_STATE:\n\t\terr = rocker_world_port_attr_stp_state_set(rocker_port,\n\t\t\t\t\t\t\t   attr->u.stp_state);\n\t\tbreak;\n\tcase SWITCHDEV_ATTR_ID_PORT_PRE_BRIDGE_FLAGS:\n\t\terr = rocker_world_port_attr_pre_bridge_flags_set(rocker_port,\n\t\t\t\t\t\t\t\t  attr->u.brport_flags);\n\t\tbreak;\n\tcase SWITCHDEV_ATTR_ID_PORT_BRIDGE_FLAGS:\n\t\terr = rocker_world_port_attr_bridge_flags_set(rocker_port,\n\t\t\t\t\t\t\t      attr->u.brport_flags);\n\t\tbreak;\n\tcase SWITCHDEV_ATTR_ID_BRIDGE_AGEING_TIME:\n\t\terr = rocker_world_port_attr_bridge_ageing_time_set(rocker_port,\n\t\t\t\t\t\t\t\t    attr->u.ageing_time);\n\t\tbreak;\n\tdefault:\n\t\terr = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nstatic int rocker_port_obj_add(struct net_device *dev,\n\t\t\t       const struct switchdev_obj *obj)\n{\n\tstruct rocker_port *rocker_port = netdev_priv(dev);\n\tint err = 0;\n\n\tswitch (obj->id) {\n\tcase SWITCHDEV_OBJ_ID_PORT_VLAN:\n\t\terr = rocker_world_port_obj_vlan_add(rocker_port,\n\t\t\t\t\t\t     SWITCHDEV_OBJ_PORT_VLAN(obj));\n\t\tbreak;\n\tdefault:\n\t\terr = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nstatic int rocker_port_obj_del(struct net_device *dev,\n\t\t\t       const struct switchdev_obj *obj)\n{\n\tstruct rocker_port *rocker_port = netdev_priv(dev);\n\tint err = 0;\n\n\tswitch (obj->id) {\n\tcase SWITCHDEV_OBJ_ID_PORT_VLAN:\n\t\terr = rocker_world_port_obj_vlan_del(rocker_port,\n\t\t\t\t\t\t     SWITCHDEV_OBJ_PORT_VLAN(obj));\n\t\tbreak;\n\tdefault:\n\t\terr = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nstruct rocker_fib_event_work {\n\tstruct work_struct work;\n\tunion {\n\t\tstruct fib_entry_notifier_info fen_info;\n\t\tstruct fib_rule_notifier_info fr_info;\n\t};\n\tstruct rocker *rocker;\n\tunsigned long event;\n};\n\nstatic void rocker_router_fib_event_work(struct work_struct *work)\n{\n\tstruct rocker_fib_event_work *fib_work =\n\t\tcontainer_of(work, struct rocker_fib_event_work, work);\n\tstruct rocker *rocker = fib_work->rocker;\n\tstruct fib_rule *rule;\n\tint err;\n\n\t \n\trtnl_lock();\n\tswitch (fib_work->event) {\n\tcase FIB_EVENT_ENTRY_REPLACE:\n\t\terr = rocker_world_fib4_add(rocker, &fib_work->fen_info);\n\t\tif (err)\n\t\t\trocker_world_fib4_abort(rocker);\n\t\tfib_info_put(fib_work->fen_info.fi);\n\t\tbreak;\n\tcase FIB_EVENT_ENTRY_DEL:\n\t\trocker_world_fib4_del(rocker, &fib_work->fen_info);\n\t\tfib_info_put(fib_work->fen_info.fi);\n\t\tbreak;\n\tcase FIB_EVENT_RULE_ADD:\n\tcase FIB_EVENT_RULE_DEL:\n\t\trule = fib_work->fr_info.rule;\n\t\tif (!fib4_rule_default(rule))\n\t\t\trocker_world_fib4_abort(rocker);\n\t\tfib_rule_put(rule);\n\t\tbreak;\n\t}\n\trtnl_unlock();\n\tkfree(fib_work);\n}\n\n \nstatic int rocker_router_fib_event(struct notifier_block *nb,\n\t\t\t\t   unsigned long event, void *ptr)\n{\n\tstruct rocker *rocker = container_of(nb, struct rocker, fib_nb);\n\tstruct rocker_fib_event_work *fib_work;\n\tstruct fib_notifier_info *info = ptr;\n\n\tif (info->family != AF_INET)\n\t\treturn NOTIFY_DONE;\n\n\tfib_work = kzalloc(sizeof(*fib_work), GFP_ATOMIC);\n\tif (WARN_ON(!fib_work))\n\t\treturn NOTIFY_BAD;\n\n\tINIT_WORK(&fib_work->work, rocker_router_fib_event_work);\n\tfib_work->rocker = rocker;\n\tfib_work->event = event;\n\n\tswitch (event) {\n\tcase FIB_EVENT_ENTRY_REPLACE:\n\tcase FIB_EVENT_ENTRY_DEL:\n\t\tif (info->family == AF_INET) {\n\t\t\tstruct fib_entry_notifier_info *fen_info = ptr;\n\n\t\t\tif (fen_info->fi->fib_nh_is_v6) {\n\t\t\t\tNL_SET_ERR_MSG_MOD(info->extack, \"IPv6 gateway with IPv4 route is not supported\");\n\t\t\t\tkfree(fib_work);\n\t\t\t\treturn notifier_from_errno(-EINVAL);\n\t\t\t}\n\t\t\tif (fen_info->fi->nh) {\n\t\t\t\tNL_SET_ERR_MSG_MOD(info->extack, \"IPv4 route with nexthop objects is not supported\");\n\t\t\t\tkfree(fib_work);\n\t\t\t\treturn notifier_from_errno(-EINVAL);\n\t\t\t}\n\t\t}\n\n\t\tmemcpy(&fib_work->fen_info, ptr, sizeof(fib_work->fen_info));\n\t\t \n\t\tfib_info_hold(fib_work->fen_info.fi);\n\t\tbreak;\n\tcase FIB_EVENT_RULE_ADD:\n\tcase FIB_EVENT_RULE_DEL:\n\t\tmemcpy(&fib_work->fr_info, ptr, sizeof(fib_work->fr_info));\n\t\tfib_rule_get(fib_work->fr_info.rule);\n\t\tbreak;\n\t}\n\n\tqueue_work(rocker->rocker_owq, &fib_work->work);\n\n\treturn NOTIFY_DONE;\n}\n\n \n\nstatic int\nrocker_port_get_link_ksettings(struct net_device *dev,\n\t\t\t       struct ethtool_link_ksettings *ecmd)\n{\n\tstruct rocker_port *rocker_port = netdev_priv(dev);\n\n\treturn rocker_cmd_get_port_settings_ethtool(rocker_port, ecmd);\n}\n\nstatic int\nrocker_port_set_link_ksettings(struct net_device *dev,\n\t\t\t       const struct ethtool_link_ksettings *ecmd)\n{\n\tstruct rocker_port *rocker_port = netdev_priv(dev);\n\n\treturn rocker_cmd_set_port_settings_ethtool(rocker_port, ecmd);\n}\n\nstatic void rocker_port_get_drvinfo(struct net_device *dev,\n\t\t\t\t    struct ethtool_drvinfo *drvinfo)\n{\n\tstrscpy(drvinfo->driver, rocker_driver_name, sizeof(drvinfo->driver));\n\tstrscpy(drvinfo->version, UTS_RELEASE, sizeof(drvinfo->version));\n}\n\nstatic struct rocker_port_stats {\n\tchar str[ETH_GSTRING_LEN];\n\tint type;\n} rocker_port_stats[] = {\n\t{ \"rx_packets\", ROCKER_TLV_CMD_PORT_STATS_RX_PKTS,    },\n\t{ \"rx_bytes\",   ROCKER_TLV_CMD_PORT_STATS_RX_BYTES,   },\n\t{ \"rx_dropped\", ROCKER_TLV_CMD_PORT_STATS_RX_DROPPED, },\n\t{ \"rx_errors\",  ROCKER_TLV_CMD_PORT_STATS_RX_ERRORS,  },\n\n\t{ \"tx_packets\", ROCKER_TLV_CMD_PORT_STATS_TX_PKTS,    },\n\t{ \"tx_bytes\",   ROCKER_TLV_CMD_PORT_STATS_TX_BYTES,   },\n\t{ \"tx_dropped\", ROCKER_TLV_CMD_PORT_STATS_TX_DROPPED, },\n\t{ \"tx_errors\",  ROCKER_TLV_CMD_PORT_STATS_TX_ERRORS,  },\n};\n\n#define ROCKER_PORT_STATS_LEN  ARRAY_SIZE(rocker_port_stats)\n\nstatic void rocker_port_get_strings(struct net_device *netdev, u32 stringset,\n\t\t\t\t    u8 *data)\n{\n\tu8 *p = data;\n\tint i;\n\n\tswitch (stringset) {\n\tcase ETH_SS_STATS:\n\t\tfor (i = 0; i < ARRAY_SIZE(rocker_port_stats); i++) {\n\t\t\tmemcpy(p, rocker_port_stats[i].str, ETH_GSTRING_LEN);\n\t\t\tp += ETH_GSTRING_LEN;\n\t\t}\n\t\tbreak;\n\t}\n}\n\nstatic int\nrocker_cmd_get_port_stats_prep(const struct rocker_port *rocker_port,\n\t\t\t       struct rocker_desc_info *desc_info,\n\t\t\t       void *priv)\n{\n\tstruct rocker_tlv *cmd_stats;\n\n\tif (rocker_tlv_put_u16(desc_info, ROCKER_TLV_CMD_TYPE,\n\t\t\t       ROCKER_TLV_CMD_TYPE_GET_PORT_STATS))\n\t\treturn -EMSGSIZE;\n\n\tcmd_stats = rocker_tlv_nest_start(desc_info, ROCKER_TLV_CMD_INFO);\n\tif (!cmd_stats)\n\t\treturn -EMSGSIZE;\n\n\tif (rocker_tlv_put_u32(desc_info, ROCKER_TLV_CMD_PORT_STATS_PPORT,\n\t\t\t       rocker_port->pport))\n\t\treturn -EMSGSIZE;\n\n\trocker_tlv_nest_end(desc_info, cmd_stats);\n\n\treturn 0;\n}\n\nstatic int\nrocker_cmd_get_port_stats_ethtool_proc(const struct rocker_port *rocker_port,\n\t\t\t\t       const struct rocker_desc_info *desc_info,\n\t\t\t\t       void *priv)\n{\n\tconst struct rocker_tlv *attrs[ROCKER_TLV_CMD_MAX + 1];\n\tconst struct rocker_tlv *stats_attrs[ROCKER_TLV_CMD_PORT_STATS_MAX + 1];\n\tconst struct rocker_tlv *pattr;\n\tu32 pport;\n\tu64 *data = priv;\n\tint i;\n\n\trocker_tlv_parse_desc(attrs, ROCKER_TLV_CMD_MAX, desc_info);\n\n\tif (!attrs[ROCKER_TLV_CMD_INFO])\n\t\treturn -EIO;\n\n\trocker_tlv_parse_nested(stats_attrs, ROCKER_TLV_CMD_PORT_STATS_MAX,\n\t\t\t\tattrs[ROCKER_TLV_CMD_INFO]);\n\n\tif (!stats_attrs[ROCKER_TLV_CMD_PORT_STATS_PPORT])\n\t\treturn -EIO;\n\n\tpport = rocker_tlv_get_u32(stats_attrs[ROCKER_TLV_CMD_PORT_STATS_PPORT]);\n\tif (pport != rocker_port->pport)\n\t\treturn -EIO;\n\n\tfor (i = 0; i < ARRAY_SIZE(rocker_port_stats); i++) {\n\t\tpattr = stats_attrs[rocker_port_stats[i].type];\n\t\tif (!pattr)\n\t\t\tcontinue;\n\n\t\tdata[i] = rocker_tlv_get_u64(pattr);\n\t}\n\n\treturn 0;\n}\n\nstatic int rocker_cmd_get_port_stats_ethtool(struct rocker_port *rocker_port,\n\t\t\t\t\t     void *priv)\n{\n\treturn rocker_cmd_exec(rocker_port, false,\n\t\t\t       rocker_cmd_get_port_stats_prep, NULL,\n\t\t\t       rocker_cmd_get_port_stats_ethtool_proc,\n\t\t\t       priv);\n}\n\nstatic void rocker_port_get_stats(struct net_device *dev,\n\t\t\t\t  struct ethtool_stats *stats, u64 *data)\n{\n\tstruct rocker_port *rocker_port = netdev_priv(dev);\n\n\tif (rocker_cmd_get_port_stats_ethtool(rocker_port, data) != 0) {\n\t\tint i;\n\n\t\tfor (i = 0; i < ARRAY_SIZE(rocker_port_stats); ++i)\n\t\t\tdata[i] = 0;\n\t}\n}\n\nstatic int rocker_port_get_sset_count(struct net_device *netdev, int sset)\n{\n\tswitch (sset) {\n\tcase ETH_SS_STATS:\n\t\treturn ROCKER_PORT_STATS_LEN;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic const struct ethtool_ops rocker_port_ethtool_ops = {\n\t.get_drvinfo\t\t= rocker_port_get_drvinfo,\n\t.get_link\t\t= ethtool_op_get_link,\n\t.get_strings\t\t= rocker_port_get_strings,\n\t.get_ethtool_stats\t= rocker_port_get_stats,\n\t.get_sset_count\t\t= rocker_port_get_sset_count,\n\t.get_link_ksettings\t= rocker_port_get_link_ksettings,\n\t.set_link_ksettings\t= rocker_port_set_link_ksettings,\n};\n\n \n\nstatic struct rocker_port *rocker_port_napi_tx_get(struct napi_struct *napi)\n{\n\treturn container_of(napi, struct rocker_port, napi_tx);\n}\n\nstatic int rocker_port_poll_tx(struct napi_struct *napi, int budget)\n{\n\tstruct rocker_port *rocker_port = rocker_port_napi_tx_get(napi);\n\tconst struct rocker *rocker = rocker_port->rocker;\n\tconst struct rocker_desc_info *desc_info;\n\tu32 credits = 0;\n\tint err;\n\n\t \n\twhile ((desc_info = rocker_desc_tail_get(&rocker_port->tx_ring))) {\n\t\tstruct sk_buff *skb;\n\n\t\terr = rocker_desc_err(desc_info);\n\t\tif (err && net_ratelimit())\n\t\t\tnetdev_err(rocker_port->dev, \"tx desc received with err %d\\n\",\n\t\t\t\t   err);\n\t\trocker_tx_desc_frags_unmap(rocker_port, desc_info);\n\n\t\tskb = rocker_desc_cookie_ptr_get(desc_info);\n\t\tif (err == 0) {\n\t\t\trocker_port->dev->stats.tx_packets++;\n\t\t\trocker_port->dev->stats.tx_bytes += skb->len;\n\t\t} else {\n\t\t\trocker_port->dev->stats.tx_errors++;\n\t\t}\n\n\t\tdev_kfree_skb_any(skb);\n\t\tcredits++;\n\t}\n\n\tif (credits && netif_queue_stopped(rocker_port->dev))\n\t\tnetif_wake_queue(rocker_port->dev);\n\n\tnapi_complete(napi);\n\trocker_dma_ring_credits_set(rocker, &rocker_port->tx_ring, credits);\n\n\treturn 0;\n}\n\nstatic int rocker_port_rx_proc(const struct rocker *rocker,\n\t\t\t       const struct rocker_port *rocker_port,\n\t\t\t       struct rocker_desc_info *desc_info)\n{\n\tconst struct rocker_tlv *attrs[ROCKER_TLV_RX_MAX + 1];\n\tstruct sk_buff *skb = rocker_desc_cookie_ptr_get(desc_info);\n\tsize_t rx_len;\n\tu16 rx_flags = 0;\n\n\tif (!skb)\n\t\treturn -ENOENT;\n\n\trocker_tlv_parse_desc(attrs, ROCKER_TLV_RX_MAX, desc_info);\n\tif (!attrs[ROCKER_TLV_RX_FRAG_LEN])\n\t\treturn -EINVAL;\n\tif (attrs[ROCKER_TLV_RX_FLAGS])\n\t\trx_flags = rocker_tlv_get_u16(attrs[ROCKER_TLV_RX_FLAGS]);\n\n\trocker_dma_rx_ring_skb_unmap(rocker, attrs);\n\n\trx_len = rocker_tlv_get_u16(attrs[ROCKER_TLV_RX_FRAG_LEN]);\n\tskb_put(skb, rx_len);\n\tskb->protocol = eth_type_trans(skb, rocker_port->dev);\n\n\tif (rx_flags & ROCKER_RX_FLAGS_FWD_OFFLOAD)\n\t\tskb->offload_fwd_mark = 1;\n\n\trocker_port->dev->stats.rx_packets++;\n\trocker_port->dev->stats.rx_bytes += skb->len;\n\n\tnetif_receive_skb(skb);\n\n\treturn rocker_dma_rx_ring_skb_alloc(rocker_port, desc_info);\n}\n\nstatic struct rocker_port *rocker_port_napi_rx_get(struct napi_struct *napi)\n{\n\treturn container_of(napi, struct rocker_port, napi_rx);\n}\n\nstatic int rocker_port_poll_rx(struct napi_struct *napi, int budget)\n{\n\tstruct rocker_port *rocker_port = rocker_port_napi_rx_get(napi);\n\tconst struct rocker *rocker = rocker_port->rocker;\n\tstruct rocker_desc_info *desc_info;\n\tu32 credits = 0;\n\tint err;\n\n\t \n\twhile (credits < budget &&\n\t       (desc_info = rocker_desc_tail_get(&rocker_port->rx_ring))) {\n\t\terr = rocker_desc_err(desc_info);\n\t\tif (err) {\n\t\t\tif (net_ratelimit())\n\t\t\t\tnetdev_err(rocker_port->dev, \"rx desc received with err %d\\n\",\n\t\t\t\t\t   err);\n\t\t} else {\n\t\t\terr = rocker_port_rx_proc(rocker, rocker_port,\n\t\t\t\t\t\t  desc_info);\n\t\t\tif (err && net_ratelimit())\n\t\t\t\tnetdev_err(rocker_port->dev, \"rx processing failed with err %d\\n\",\n\t\t\t\t\t   err);\n\t\t}\n\t\tif (err)\n\t\t\trocker_port->dev->stats.rx_errors++;\n\n\t\trocker_desc_gen_clear(desc_info);\n\t\trocker_desc_head_set(rocker, &rocker_port->rx_ring, desc_info);\n\t\tcredits++;\n\t}\n\n\tif (credits < budget)\n\t\tnapi_complete_done(napi, credits);\n\n\trocker_dma_ring_credits_set(rocker, &rocker_port->rx_ring, credits);\n\n\treturn credits;\n}\n\n \n\nstatic void rocker_carrier_init(const struct rocker_port *rocker_port)\n{\n\tconst struct rocker *rocker = rocker_port->rocker;\n\tu64 link_status = rocker_read64(rocker, PORT_PHYS_LINK_STATUS);\n\tbool link_up;\n\n\tlink_up = link_status & (1 << rocker_port->pport);\n\tif (link_up)\n\t\tnetif_carrier_on(rocker_port->dev);\n\telse\n\t\tnetif_carrier_off(rocker_port->dev);\n}\n\nstatic void rocker_remove_ports(struct rocker *rocker)\n{\n\tstruct rocker_port *rocker_port;\n\tint i;\n\n\tfor (i = 0; i < rocker->port_count; i++) {\n\t\trocker_port = rocker->ports[i];\n\t\tif (!rocker_port)\n\t\t\tcontinue;\n\t\trocker_world_port_fini(rocker_port);\n\t\tunregister_netdev(rocker_port->dev);\n\t\trocker_world_port_post_fini(rocker_port);\n\t\tfree_netdev(rocker_port->dev);\n\t}\n\trocker_world_fini(rocker);\n\tkfree(rocker->ports);\n}\n\nstatic void rocker_port_dev_addr_init(struct rocker_port *rocker_port)\n{\n\tconst struct rocker *rocker = rocker_port->rocker;\n\tconst struct pci_dev *pdev = rocker->pdev;\n\tu8 addr[ETH_ALEN];\n\tint err;\n\n\terr = rocker_cmd_get_port_settings_macaddr(rocker_port, addr);\n\tif (!err) {\n\t\teth_hw_addr_set(rocker_port->dev, addr);\n\t} else {\n\t\tdev_warn(&pdev->dev, \"failed to get mac address, using random\\n\");\n\t\teth_hw_addr_random(rocker_port->dev);\n\t}\n}\n\n#define ROCKER_PORT_MIN_MTU\tETH_MIN_MTU\n#define ROCKER_PORT_MAX_MTU\t9000\nstatic int rocker_probe_port(struct rocker *rocker, unsigned int port_number)\n{\n\tstruct pci_dev *pdev = rocker->pdev;\n\tstruct rocker_port *rocker_port;\n\tstruct net_device *dev;\n\tint err;\n\n\tdev = alloc_etherdev(sizeof(struct rocker_port));\n\tif (!dev)\n\t\treturn -ENOMEM;\n\tSET_NETDEV_DEV(dev, &pdev->dev);\n\trocker_port = netdev_priv(dev);\n\trocker_port->dev = dev;\n\trocker_port->rocker = rocker;\n\trocker_port->port_number = port_number;\n\trocker_port->pport = port_number + 1;\n\n\terr = rocker_world_check_init(rocker_port);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"world init failed\\n\");\n\t\tgoto err_world_check_init;\n\t}\n\n\trocker_port_dev_addr_init(rocker_port);\n\tdev->netdev_ops = &rocker_port_netdev_ops;\n\tdev->ethtool_ops = &rocker_port_ethtool_ops;\n\tnetif_napi_add_tx(dev, &rocker_port->napi_tx, rocker_port_poll_tx);\n\tnetif_napi_add(dev, &rocker_port->napi_rx, rocker_port_poll_rx);\n\trocker_carrier_init(rocker_port);\n\n\tdev->features |= NETIF_F_NETNS_LOCAL | NETIF_F_SG;\n\n\t \n\tdev->min_mtu = ROCKER_PORT_MIN_MTU;\n\tdev->max_mtu = ROCKER_PORT_MAX_MTU;\n\n\terr = rocker_world_port_pre_init(rocker_port);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"port world pre-init failed\\n\");\n\t\tgoto err_world_port_pre_init;\n\t}\n\terr = register_netdev(dev);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"register_netdev failed\\n\");\n\t\tgoto err_register_netdev;\n\t}\n\trocker->ports[port_number] = rocker_port;\n\n\terr = rocker_world_port_init(rocker_port);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"port world init failed\\n\");\n\t\tgoto err_world_port_init;\n\t}\n\n\treturn 0;\n\nerr_world_port_init:\n\trocker->ports[port_number] = NULL;\n\tunregister_netdev(dev);\nerr_register_netdev:\n\trocker_world_port_post_fini(rocker_port);\nerr_world_port_pre_init:\nerr_world_check_init:\n\tfree_netdev(dev);\n\treturn err;\n}\n\nstatic int rocker_probe_ports(struct rocker *rocker)\n{\n\tint i;\n\tsize_t alloc_size;\n\tint err;\n\n\talloc_size = sizeof(struct rocker_port *) * rocker->port_count;\n\trocker->ports = kzalloc(alloc_size, GFP_KERNEL);\n\tif (!rocker->ports)\n\t\treturn -ENOMEM;\n\tfor (i = 0; i < rocker->port_count; i++) {\n\t\terr = rocker_probe_port(rocker, i);\n\t\tif (err)\n\t\t\tgoto remove_ports;\n\t}\n\treturn 0;\n\nremove_ports:\n\trocker_remove_ports(rocker);\n\treturn err;\n}\n\nstatic int rocker_msix_init(struct rocker *rocker)\n{\n\tstruct pci_dev *pdev = rocker->pdev;\n\tint msix_entries;\n\tint i;\n\tint err;\n\n\tmsix_entries = pci_msix_vec_count(pdev);\n\tif (msix_entries < 0)\n\t\treturn msix_entries;\n\n\tif (msix_entries != ROCKER_MSIX_VEC_COUNT(rocker->port_count))\n\t\treturn -EINVAL;\n\n\trocker->msix_entries = kmalloc_array(msix_entries,\n\t\t\t\t\t     sizeof(struct msix_entry),\n\t\t\t\t\t     GFP_KERNEL);\n\tif (!rocker->msix_entries)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < msix_entries; i++)\n\t\trocker->msix_entries[i].entry = i;\n\n\terr = pci_enable_msix_exact(pdev, rocker->msix_entries, msix_entries);\n\tif (err < 0)\n\t\tgoto err_enable_msix;\n\n\treturn 0;\n\nerr_enable_msix:\n\tkfree(rocker->msix_entries);\n\treturn err;\n}\n\nstatic void rocker_msix_fini(const struct rocker *rocker)\n{\n\tpci_disable_msix(rocker->pdev);\n\tkfree(rocker->msix_entries);\n}\n\nstatic bool rocker_port_dev_check(const struct net_device *dev)\n{\n\treturn dev->netdev_ops == &rocker_port_netdev_ops;\n}\n\nstatic int\nrocker_switchdev_port_attr_set_event(struct net_device *netdev,\n\t\tstruct switchdev_notifier_port_attr_info *port_attr_info)\n{\n\tint err;\n\n\terr = rocker_port_attr_set(netdev, port_attr_info->attr);\n\n\tport_attr_info->handled = true;\n\treturn notifier_from_errno(err);\n}\n\nstruct rocker_switchdev_event_work {\n\tstruct work_struct work;\n\tstruct switchdev_notifier_fdb_info fdb_info;\n\tstruct rocker_port *rocker_port;\n\tunsigned long event;\n};\n\nstatic void\nrocker_fdb_offload_notify(struct rocker_port *rocker_port,\n\t\t\t  struct switchdev_notifier_fdb_info *recv_info)\n{\n\tstruct switchdev_notifier_fdb_info info = {};\n\n\tinfo.addr = recv_info->addr;\n\tinfo.vid = recv_info->vid;\n\tinfo.offloaded = true;\n\tcall_switchdev_notifiers(SWITCHDEV_FDB_OFFLOADED,\n\t\t\t\t rocker_port->dev, &info.info, NULL);\n}\n\nstatic void rocker_switchdev_event_work(struct work_struct *work)\n{\n\tstruct rocker_switchdev_event_work *switchdev_work =\n\t\tcontainer_of(work, struct rocker_switchdev_event_work, work);\n\tstruct rocker_port *rocker_port = switchdev_work->rocker_port;\n\tstruct switchdev_notifier_fdb_info *fdb_info;\n\tint err;\n\n\trtnl_lock();\n\tswitch (switchdev_work->event) {\n\tcase SWITCHDEV_FDB_ADD_TO_DEVICE:\n\t\tfdb_info = &switchdev_work->fdb_info;\n\t\tif (!fdb_info->added_by_user || fdb_info->is_local)\n\t\t\tbreak;\n\t\terr = rocker_world_port_fdb_add(rocker_port, fdb_info);\n\t\tif (err) {\n\t\t\tnetdev_dbg(rocker_port->dev, \"fdb add failed err=%d\\n\", err);\n\t\t\tbreak;\n\t\t}\n\t\trocker_fdb_offload_notify(rocker_port, fdb_info);\n\t\tbreak;\n\tcase SWITCHDEV_FDB_DEL_TO_DEVICE:\n\t\tfdb_info = &switchdev_work->fdb_info;\n\t\tif (!fdb_info->added_by_user || fdb_info->is_local)\n\t\t\tbreak;\n\t\terr = rocker_world_port_fdb_del(rocker_port, fdb_info);\n\t\tif (err)\n\t\t\tnetdev_dbg(rocker_port->dev, \"fdb add failed err=%d\\n\", err);\n\t\tbreak;\n\t}\n\trtnl_unlock();\n\n\tkfree(switchdev_work->fdb_info.addr);\n\tkfree(switchdev_work);\n\tdev_put(rocker_port->dev);\n}\n\n \nstatic int rocker_switchdev_event(struct notifier_block *unused,\n\t\t\t\t  unsigned long event, void *ptr)\n{\n\tstruct net_device *dev = switchdev_notifier_info_to_dev(ptr);\n\tstruct rocker_switchdev_event_work *switchdev_work;\n\tstruct switchdev_notifier_fdb_info *fdb_info = ptr;\n\tstruct rocker_port *rocker_port;\n\n\tif (!rocker_port_dev_check(dev))\n\t\treturn NOTIFY_DONE;\n\n\tif (event == SWITCHDEV_PORT_ATTR_SET)\n\t\treturn rocker_switchdev_port_attr_set_event(dev, ptr);\n\n\trocker_port = netdev_priv(dev);\n\tswitchdev_work = kzalloc(sizeof(*switchdev_work), GFP_ATOMIC);\n\tif (WARN_ON(!switchdev_work))\n\t\treturn NOTIFY_BAD;\n\n\tINIT_WORK(&switchdev_work->work, rocker_switchdev_event_work);\n\tswitchdev_work->rocker_port = rocker_port;\n\tswitchdev_work->event = event;\n\n\tswitch (event) {\n\tcase SWITCHDEV_FDB_ADD_TO_DEVICE:\n\tcase SWITCHDEV_FDB_DEL_TO_DEVICE:\n\t\tmemcpy(&switchdev_work->fdb_info, ptr,\n\t\t       sizeof(switchdev_work->fdb_info));\n\t\tswitchdev_work->fdb_info.addr = kzalloc(ETH_ALEN, GFP_ATOMIC);\n\t\tif (unlikely(!switchdev_work->fdb_info.addr)) {\n\t\t\tkfree(switchdev_work);\n\t\t\treturn NOTIFY_BAD;\n\t\t}\n\n\t\tether_addr_copy((u8 *)switchdev_work->fdb_info.addr,\n\t\t\t\tfdb_info->addr);\n\t\t \n\t\tdev_hold(dev);\n\t\tbreak;\n\tdefault:\n\t\tkfree(switchdev_work);\n\t\treturn NOTIFY_DONE;\n\t}\n\n\tqueue_work(rocker_port->rocker->rocker_owq,\n\t\t   &switchdev_work->work);\n\treturn NOTIFY_DONE;\n}\n\nstatic int\nrocker_switchdev_port_obj_event(unsigned long event, struct net_device *netdev,\n\t\t\tstruct switchdev_notifier_port_obj_info *port_obj_info)\n{\n\tint err = -EOPNOTSUPP;\n\n\tswitch (event) {\n\tcase SWITCHDEV_PORT_OBJ_ADD:\n\t\terr = rocker_port_obj_add(netdev, port_obj_info->obj);\n\t\tbreak;\n\tcase SWITCHDEV_PORT_OBJ_DEL:\n\t\terr = rocker_port_obj_del(netdev, port_obj_info->obj);\n\t\tbreak;\n\t}\n\n\tport_obj_info->handled = true;\n\treturn notifier_from_errno(err);\n}\n\nstatic int rocker_switchdev_blocking_event(struct notifier_block *unused,\n\t\t\t\t\t   unsigned long event, void *ptr)\n{\n\tstruct net_device *dev = switchdev_notifier_info_to_dev(ptr);\n\n\tif (!rocker_port_dev_check(dev))\n\t\treturn NOTIFY_DONE;\n\n\tswitch (event) {\n\tcase SWITCHDEV_PORT_OBJ_ADD:\n\tcase SWITCHDEV_PORT_OBJ_DEL:\n\t\treturn rocker_switchdev_port_obj_event(event, dev, ptr);\n\tcase SWITCHDEV_PORT_ATTR_SET:\n\t\treturn rocker_switchdev_port_attr_set_event(dev, ptr);\n\t}\n\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block rocker_switchdev_notifier = {\n\t.notifier_call = rocker_switchdev_event,\n};\n\nstatic struct notifier_block rocker_switchdev_blocking_notifier = {\n\t.notifier_call = rocker_switchdev_blocking_event,\n};\n\nstatic int rocker_probe(struct pci_dev *pdev, const struct pci_device_id *id)\n{\n\tstruct notifier_block *nb;\n\tstruct rocker *rocker;\n\tint err;\n\n\trocker = kzalloc(sizeof(*rocker), GFP_KERNEL);\n\tif (!rocker)\n\t\treturn -ENOMEM;\n\n\terr = pci_enable_device(pdev);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"pci_enable_device failed\\n\");\n\t\tgoto err_pci_enable_device;\n\t}\n\n\terr = pci_request_regions(pdev, rocker_driver_name);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"pci_request_regions failed\\n\");\n\t\tgoto err_pci_request_regions;\n\t}\n\n\terr = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(64));\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"dma_set_mask failed\\n\");\n\t\tgoto err_pci_set_dma_mask;\n\t}\n\n\tif (pci_resource_len(pdev, 0) < ROCKER_PCI_BAR0_SIZE) {\n\t\tdev_err(&pdev->dev, \"invalid PCI region size\\n\");\n\t\terr = -EINVAL;\n\t\tgoto err_pci_resource_len_check;\n\t}\n\n\trocker->hw_addr = ioremap(pci_resource_start(pdev, 0),\n\t\t\t\t  pci_resource_len(pdev, 0));\n\tif (!rocker->hw_addr) {\n\t\tdev_err(&pdev->dev, \"ioremap failed\\n\");\n\t\terr = -EIO;\n\t\tgoto err_ioremap;\n\t}\n\tpci_set_master(pdev);\n\n\trocker->pdev = pdev;\n\tpci_set_drvdata(pdev, rocker);\n\n\trocker->port_count = rocker_read32(rocker, PORT_PHYS_COUNT);\n\n\terr = rocker_msix_init(rocker);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"MSI-X init failed\\n\");\n\t\tgoto err_msix_init;\n\t}\n\n\terr = rocker_basic_hw_test(rocker);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"basic hw test failed\\n\");\n\t\tgoto err_basic_hw_test;\n\t}\n\n\trocker_write32(rocker, CONTROL, ROCKER_CONTROL_RESET);\n\n\terr = rocker_dma_rings_init(rocker);\n\tif (err)\n\t\tgoto err_dma_rings_init;\n\n\terr = request_irq(rocker_msix_vector(rocker, ROCKER_MSIX_VEC_CMD),\n\t\t\t  rocker_cmd_irq_handler, 0,\n\t\t\t  rocker_driver_name, rocker);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"cannot assign cmd irq\\n\");\n\t\tgoto err_request_cmd_irq;\n\t}\n\n\terr = request_irq(rocker_msix_vector(rocker, ROCKER_MSIX_VEC_EVENT),\n\t\t\t  rocker_event_irq_handler, 0,\n\t\t\t  rocker_driver_name, rocker);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"cannot assign event irq\\n\");\n\t\tgoto err_request_event_irq;\n\t}\n\n\trocker->rocker_owq = alloc_ordered_workqueue(rocker_driver_name,\n\t\t\t\t\t\t     WQ_MEM_RECLAIM);\n\tif (!rocker->rocker_owq) {\n\t\terr = -ENOMEM;\n\t\tgoto err_alloc_ordered_workqueue;\n\t}\n\n\terr = rocker_probe_ports(rocker);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"failed to probe ports\\n\");\n\t\tgoto err_probe_ports;\n\t}\n\n\t \n\trocker->fib_nb.notifier_call = rocker_router_fib_event;\n\terr = register_fib_notifier(&init_net, &rocker->fib_nb, NULL, NULL);\n\tif (err)\n\t\tgoto err_register_fib_notifier;\n\n\terr = register_switchdev_notifier(&rocker_switchdev_notifier);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Failed to register switchdev notifier\\n\");\n\t\tgoto err_register_switchdev_notifier;\n\t}\n\n\tnb = &rocker_switchdev_blocking_notifier;\n\terr = register_switchdev_blocking_notifier(nb);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Failed to register switchdev blocking notifier\\n\");\n\t\tgoto err_register_switchdev_blocking_notifier;\n\t}\n\n\trocker->hw.id = rocker_read64(rocker, SWITCH_ID);\n\n\tdev_info(&pdev->dev, \"Rocker switch with id %*phN\\n\",\n\t\t (int)sizeof(rocker->hw.id), &rocker->hw.id);\n\n\treturn 0;\n\nerr_register_switchdev_blocking_notifier:\n\tunregister_switchdev_notifier(&rocker_switchdev_notifier);\nerr_register_switchdev_notifier:\n\tunregister_fib_notifier(&init_net, &rocker->fib_nb);\nerr_register_fib_notifier:\n\trocker_remove_ports(rocker);\nerr_probe_ports:\n\tdestroy_workqueue(rocker->rocker_owq);\nerr_alloc_ordered_workqueue:\n\tfree_irq(rocker_msix_vector(rocker, ROCKER_MSIX_VEC_EVENT), rocker);\nerr_request_event_irq:\n\tfree_irq(rocker_msix_vector(rocker, ROCKER_MSIX_VEC_CMD), rocker);\nerr_request_cmd_irq:\n\trocker_dma_rings_fini(rocker);\nerr_dma_rings_init:\nerr_basic_hw_test:\n\trocker_msix_fini(rocker);\nerr_msix_init:\n\tiounmap(rocker->hw_addr);\nerr_ioremap:\nerr_pci_resource_len_check:\nerr_pci_set_dma_mask:\n\tpci_release_regions(pdev);\nerr_pci_request_regions:\n\tpci_disable_device(pdev);\nerr_pci_enable_device:\n\tkfree(rocker);\n\treturn err;\n}\n\nstatic void rocker_remove(struct pci_dev *pdev)\n{\n\tstruct rocker *rocker = pci_get_drvdata(pdev);\n\tstruct notifier_block *nb;\n\n\tnb = &rocker_switchdev_blocking_notifier;\n\tunregister_switchdev_blocking_notifier(nb);\n\n\tunregister_switchdev_notifier(&rocker_switchdev_notifier);\n\tunregister_fib_notifier(&init_net, &rocker->fib_nb);\n\trocker_remove_ports(rocker);\n\trocker_write32(rocker, CONTROL, ROCKER_CONTROL_RESET);\n\tdestroy_workqueue(rocker->rocker_owq);\n\tfree_irq(rocker_msix_vector(rocker, ROCKER_MSIX_VEC_EVENT), rocker);\n\tfree_irq(rocker_msix_vector(rocker, ROCKER_MSIX_VEC_CMD), rocker);\n\trocker_dma_rings_fini(rocker);\n\trocker_msix_fini(rocker);\n\tiounmap(rocker->hw_addr);\n\tpci_release_regions(rocker->pdev);\n\tpci_disable_device(rocker->pdev);\n\tkfree(rocker);\n}\n\nstatic struct pci_driver rocker_pci_driver = {\n\t.name\t\t= rocker_driver_name,\n\t.id_table\t= rocker_pci_id_table,\n\t.probe\t\t= rocker_probe,\n\t.remove\t\t= rocker_remove,\n};\n\n \n\nstatic bool rocker_port_dev_check_under(const struct net_device *dev,\n\t\t\t\t\tstruct rocker *rocker)\n{\n\tstruct rocker_port *rocker_port;\n\n\tif (!rocker_port_dev_check(dev))\n\t\treturn false;\n\n\trocker_port = netdev_priv(dev);\n\tif (rocker_port->rocker != rocker)\n\t\treturn false;\n\n\treturn true;\n}\n\nstruct rocker_walk_data {\n\tstruct rocker *rocker;\n\tstruct rocker_port *port;\n};\n\nstatic int rocker_lower_dev_walk(struct net_device *lower_dev,\n\t\t\t\t struct netdev_nested_priv *priv)\n{\n\tstruct rocker_walk_data *data = (struct rocker_walk_data *)priv->data;\n\tint ret = 0;\n\n\tif (rocker_port_dev_check_under(lower_dev, data->rocker)) {\n\t\tdata->port = netdev_priv(lower_dev);\n\t\tret = 1;\n\t}\n\n\treturn ret;\n}\n\nstruct rocker_port *rocker_port_dev_lower_find(struct net_device *dev,\n\t\t\t\t\t       struct rocker *rocker)\n{\n\tstruct netdev_nested_priv priv;\n\tstruct rocker_walk_data data;\n\n\tif (rocker_port_dev_check_under(dev, rocker))\n\t\treturn netdev_priv(dev);\n\n\tdata.rocker = rocker;\n\tdata.port = NULL;\n\tpriv.data = (void *)&data;\n\tnetdev_walk_all_lower_dev(dev, rocker_lower_dev_walk, &priv);\n\n\treturn data.port;\n}\n\nstatic int rocker_netdevice_event(struct notifier_block *unused,\n\t\t\t\t  unsigned long event, void *ptr)\n{\n\tstruct netlink_ext_ack *extack = netdev_notifier_info_to_extack(ptr);\n\tstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\n\tstruct netdev_notifier_changeupper_info *info;\n\tstruct rocker_port *rocker_port;\n\tint err;\n\n\tif (!rocker_port_dev_check(dev))\n\t\treturn NOTIFY_DONE;\n\n\tswitch (event) {\n\tcase NETDEV_CHANGEUPPER:\n\t\tinfo = ptr;\n\t\tif (!info->master)\n\t\t\tgoto out;\n\t\trocker_port = netdev_priv(dev);\n\t\tif (info->linking) {\n\t\t\terr = rocker_world_port_master_linked(rocker_port,\n\t\t\t\t\t\t\t      info->upper_dev,\n\t\t\t\t\t\t\t      extack);\n\t\t\tif (err)\n\t\t\t\tnetdev_warn(dev, \"failed to reflect master linked (err %d)\\n\",\n\t\t\t\t\t    err);\n\t\t} else {\n\t\t\terr = rocker_world_port_master_unlinked(rocker_port,\n\t\t\t\t\t\t\t\tinfo->upper_dev);\n\t\t\tif (err)\n\t\t\t\tnetdev_warn(dev, \"failed to reflect master unlinked (err %d)\\n\",\n\t\t\t\t\t    err);\n\t\t}\n\t}\nout:\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block rocker_netdevice_nb __read_mostly = {\n\t.notifier_call = rocker_netdevice_event,\n};\n\n \n\nstatic int rocker_netevent_event(struct notifier_block *unused,\n\t\t\t\t unsigned long event, void *ptr)\n{\n\tstruct rocker_port *rocker_port;\n\tstruct net_device *dev;\n\tstruct neighbour *n = ptr;\n\tint err;\n\n\tswitch (event) {\n\tcase NETEVENT_NEIGH_UPDATE:\n\t\tif (n->tbl != &arp_tbl)\n\t\t\treturn NOTIFY_DONE;\n\t\tdev = n->dev;\n\t\tif (!rocker_port_dev_check(dev))\n\t\t\treturn NOTIFY_DONE;\n\t\trocker_port = netdev_priv(dev);\n\t\terr = rocker_world_port_neigh_update(rocker_port, n);\n\t\tif (err)\n\t\t\tnetdev_warn(dev, \"failed to handle neigh update (err %d)\\n\",\n\t\t\t\t    err);\n\t\tbreak;\n\t}\n\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block rocker_netevent_nb __read_mostly = {\n\t.notifier_call = rocker_netevent_event,\n};\n\n \n\nstatic int __init rocker_module_init(void)\n{\n\tint err;\n\n\tregister_netdevice_notifier(&rocker_netdevice_nb);\n\tregister_netevent_notifier(&rocker_netevent_nb);\n\terr = pci_register_driver(&rocker_pci_driver);\n\tif (err)\n\t\tgoto err_pci_register_driver;\n\treturn 0;\n\nerr_pci_register_driver:\n\tunregister_netevent_notifier(&rocker_netevent_nb);\n\tunregister_netdevice_notifier(&rocker_netdevice_nb);\n\treturn err;\n}\n\nstatic void __exit rocker_module_exit(void)\n{\n\tunregister_netevent_notifier(&rocker_netevent_nb);\n\tunregister_netdevice_notifier(&rocker_netdevice_nb);\n\tpci_unregister_driver(&rocker_pci_driver);\n}\n\nmodule_init(rocker_module_init);\nmodule_exit(rocker_module_exit);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Jiri Pirko <jiri@resnulli.us>\");\nMODULE_AUTHOR(\"Scott Feldman <sfeldma@gmail.com>\");\nMODULE_DESCRIPTION(\"Rocker switch device driver\");\nMODULE_DEVICE_TABLE(pci, rocker_pci_id_table);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}