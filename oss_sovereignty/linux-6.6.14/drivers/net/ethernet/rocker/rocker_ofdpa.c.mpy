{
  "module_name": "rocker_ofdpa.c",
  "hash_id": "57e22bf927dbb4b1c4657d114830d4dbacd56a127266f5964d0c6f1055441f53",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/rocker/rocker_ofdpa.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/hashtable.h>\n#include <linux/crc32.h>\n#include <linux/netdevice.h>\n#include <linux/inetdevice.h>\n#include <linux/if_vlan.h>\n#include <linux/if_bridge.h>\n#include <net/neighbour.h>\n#include <net/switchdev.h>\n#include <net/ip_fib.h>\n#include <net/nexthop.h>\n#include <net/arp.h>\n\n#include \"rocker.h\"\n#include \"rocker_tlv.h\"\n\nstruct ofdpa_flow_tbl_key {\n\tu32 priority;\n\tenum rocker_of_dpa_table_id tbl_id;\n\tunion {\n\t\tstruct {\n\t\t\tu32 in_pport;\n\t\t\tu32 in_pport_mask;\n\t\t\tenum rocker_of_dpa_table_id goto_tbl;\n\t\t} ig_port;\n\t\tstruct {\n\t\t\tu32 in_pport;\n\t\t\t__be16 vlan_id;\n\t\t\t__be16 vlan_id_mask;\n\t\t\tenum rocker_of_dpa_table_id goto_tbl;\n\t\t\tbool untagged;\n\t\t\t__be16 new_vlan_id;\n\t\t} vlan;\n\t\tstruct {\n\t\t\tu32 in_pport;\n\t\t\tu32 in_pport_mask;\n\t\t\t__be16 eth_type;\n\t\t\tu8 eth_dst[ETH_ALEN];\n\t\t\tu8 eth_dst_mask[ETH_ALEN];\n\t\t\t__be16 vlan_id;\n\t\t\t__be16 vlan_id_mask;\n\t\t\tenum rocker_of_dpa_table_id goto_tbl;\n\t\t\tbool copy_to_cpu;\n\t\t} term_mac;\n\t\tstruct {\n\t\t\t__be16 eth_type;\n\t\t\t__be32 dst4;\n\t\t\t__be32 dst4_mask;\n\t\t\tenum rocker_of_dpa_table_id goto_tbl;\n\t\t\tu32 group_id;\n\t\t} ucast_routing;\n\t\tstruct {\n\t\t\tu8 eth_dst[ETH_ALEN];\n\t\t\tu8 eth_dst_mask[ETH_ALEN];\n\t\t\tint has_eth_dst;\n\t\t\tint has_eth_dst_mask;\n\t\t\t__be16 vlan_id;\n\t\t\tu32 tunnel_id;\n\t\t\tenum rocker_of_dpa_table_id goto_tbl;\n\t\t\tu32 group_id;\n\t\t\tbool copy_to_cpu;\n\t\t} bridge;\n\t\tstruct {\n\t\t\tu32 in_pport;\n\t\t\tu32 in_pport_mask;\n\t\t\tu8 eth_src[ETH_ALEN];\n\t\t\tu8 eth_src_mask[ETH_ALEN];\n\t\t\tu8 eth_dst[ETH_ALEN];\n\t\t\tu8 eth_dst_mask[ETH_ALEN];\n\t\t\t__be16 eth_type;\n\t\t\t__be16 vlan_id;\n\t\t\t__be16 vlan_id_mask;\n\t\t\tu8 ip_proto;\n\t\t\tu8 ip_proto_mask;\n\t\t\tu8 ip_tos;\n\t\t\tu8 ip_tos_mask;\n\t\t\tu32 group_id;\n\t\t} acl;\n\t};\n};\n\nstruct ofdpa_flow_tbl_entry {\n\tstruct hlist_node entry;\n\tu32 cmd;\n\tu64 cookie;\n\tstruct ofdpa_flow_tbl_key key;\n\tsize_t key_len;\n\tu32 key_crc32;  \n\tstruct fib_info *fi;\n};\n\nstruct ofdpa_group_tbl_entry {\n\tstruct hlist_node entry;\n\tu32 cmd;\n\tu32 group_id;  \n\tu16 group_count;\n\tu32 *group_ids;\n\tunion {\n\t\tstruct {\n\t\t\tu8 pop_vlan;\n\t\t} l2_interface;\n\t\tstruct {\n\t\t\tu8 eth_src[ETH_ALEN];\n\t\t\tu8 eth_dst[ETH_ALEN];\n\t\t\t__be16 vlan_id;\n\t\t\tu32 group_id;\n\t\t} l2_rewrite;\n\t\tstruct {\n\t\t\tu8 eth_src[ETH_ALEN];\n\t\t\tu8 eth_dst[ETH_ALEN];\n\t\t\t__be16 vlan_id;\n\t\t\tbool ttl_check;\n\t\t\tu32 group_id;\n\t\t} l3_unicast;\n\t};\n};\n\nstruct ofdpa_fdb_tbl_entry {\n\tstruct hlist_node entry;\n\tu32 key_crc32;  \n\tbool learned;\n\tunsigned long touched;\n\tstruct ofdpa_fdb_tbl_key {\n\t\tstruct ofdpa_port *ofdpa_port;\n\t\tu8 addr[ETH_ALEN];\n\t\t__be16 vlan_id;\n\t} key;\n};\n\nstruct ofdpa_internal_vlan_tbl_entry {\n\tstruct hlist_node entry;\n\tint ifindex;  \n\tu32 ref_count;\n\t__be16 vlan_id;\n};\n\nstruct ofdpa_neigh_tbl_entry {\n\tstruct hlist_node entry;\n\t__be32 ip_addr;  \n\tstruct net_device *dev;\n\tu32 ref_count;\n\tu32 index;\n\tu8 eth_dst[ETH_ALEN];\n\tbool ttl_check;\n};\n\nenum {\n\tOFDPA_CTRL_LINK_LOCAL_MCAST,\n\tOFDPA_CTRL_LOCAL_ARP,\n\tOFDPA_CTRL_IPV4_MCAST,\n\tOFDPA_CTRL_IPV6_MCAST,\n\tOFDPA_CTRL_DFLT_BRIDGING,\n\tOFDPA_CTRL_DFLT_OVS,\n\tOFDPA_CTRL_MAX,\n};\n\n#define OFDPA_INTERNAL_VLAN_ID_BASE\t0x0f00\n#define OFDPA_N_INTERNAL_VLANS\t\t255\n#define OFDPA_VLAN_BITMAP_LEN\t\tBITS_TO_LONGS(VLAN_N_VID)\n#define OFDPA_INTERNAL_VLAN_BITMAP_LEN\tBITS_TO_LONGS(OFDPA_N_INTERNAL_VLANS)\n#define OFDPA_UNTAGGED_VID 0\n\nstruct ofdpa {\n\tstruct rocker *rocker;\n\tDECLARE_HASHTABLE(flow_tbl, 16);\n\tspinlock_t flow_tbl_lock;\t\t \n\tu64 flow_tbl_next_cookie;\n\tDECLARE_HASHTABLE(group_tbl, 16);\n\tspinlock_t group_tbl_lock;\t\t \n\tstruct timer_list fdb_cleanup_timer;\n\tDECLARE_HASHTABLE(fdb_tbl, 16);\n\tspinlock_t fdb_tbl_lock;\t\t \n\tunsigned long internal_vlan_bitmap[OFDPA_INTERNAL_VLAN_BITMAP_LEN];\n\tDECLARE_HASHTABLE(internal_vlan_tbl, 8);\n\tspinlock_t internal_vlan_tbl_lock;\t \n\tDECLARE_HASHTABLE(neigh_tbl, 16);\n\tspinlock_t neigh_tbl_lock;\t\t \n\tu32 neigh_tbl_next_index;\n\tunsigned long ageing_time;\n\tbool fib_aborted;\n};\n\nstruct ofdpa_port {\n\tstruct ofdpa *ofdpa;\n\tstruct rocker_port *rocker_port;\n\tstruct net_device *dev;\n\tu32 pport;\n\tstruct net_device *bridge_dev;\n\t__be16 internal_vlan_id;\n\tint stp_state;\n\tu32 brport_flags;\n\tunsigned long ageing_time;\n\tbool ctrls[OFDPA_CTRL_MAX];\n\tunsigned long vlan_bitmap[OFDPA_VLAN_BITMAP_LEN];\n};\n\nstatic const u8 zero_mac[ETH_ALEN]   = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nstatic const u8 ff_mac[ETH_ALEN]     = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };\nstatic const u8 ll_mac[ETH_ALEN]     = { 0x01, 0x80, 0xc2, 0x00, 0x00, 0x00 };\nstatic const u8 ll_mask[ETH_ALEN]    = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0 };\nstatic const u8 mcast_mac[ETH_ALEN]  = { 0x01, 0x00, 0x00, 0x00, 0x00, 0x00 };\nstatic const u8 ipv4_mcast[ETH_ALEN] = { 0x01, 0x00, 0x5e, 0x00, 0x00, 0x00 };\nstatic const u8 ipv4_mask[ETH_ALEN]  = { 0xff, 0xff, 0xff, 0x80, 0x00, 0x00 };\nstatic const u8 ipv6_mcast[ETH_ALEN] = { 0x33, 0x33, 0x00, 0x00, 0x00, 0x00 };\nstatic const u8 ipv6_mask[ETH_ALEN]  = { 0xff, 0xff, 0x00, 0x00, 0x00, 0x00 };\n\n \n\nenum {\n\tOFDPA_PRIORITY_UNKNOWN = 0,\n\tOFDPA_PRIORITY_IG_PORT = 1,\n\tOFDPA_PRIORITY_VLAN = 1,\n\tOFDPA_PRIORITY_TERM_MAC_UCAST = 0,\n\tOFDPA_PRIORITY_TERM_MAC_MCAST = 1,\n\tOFDPA_PRIORITY_BRIDGING_VLAN_DFLT_EXACT = 1,\n\tOFDPA_PRIORITY_BRIDGING_VLAN_DFLT_WILD = 2,\n\tOFDPA_PRIORITY_BRIDGING_VLAN = 3,\n\tOFDPA_PRIORITY_BRIDGING_TENANT_DFLT_EXACT = 1,\n\tOFDPA_PRIORITY_BRIDGING_TENANT_DFLT_WILD = 2,\n\tOFDPA_PRIORITY_BRIDGING_TENANT = 3,\n\tOFDPA_PRIORITY_ACL_CTRL = 3,\n\tOFDPA_PRIORITY_ACL_NORMAL = 2,\n\tOFDPA_PRIORITY_ACL_DFLT = 1,\n};\n\nstatic bool ofdpa_vlan_id_is_internal(__be16 vlan_id)\n{\n\tu16 start = OFDPA_INTERNAL_VLAN_ID_BASE;\n\tu16 end = 0xffe;\n\tu16 _vlan_id = ntohs(vlan_id);\n\n\treturn (_vlan_id >= start && _vlan_id <= end);\n}\n\nstatic __be16 ofdpa_port_vid_to_vlan(const struct ofdpa_port *ofdpa_port,\n\t\t\t\t     u16 vid, bool *pop_vlan)\n{\n\t__be16 vlan_id;\n\n\tif (pop_vlan)\n\t\t*pop_vlan = false;\n\tvlan_id = htons(vid);\n\tif (!vlan_id) {\n\t\tvlan_id = ofdpa_port->internal_vlan_id;\n\t\tif (pop_vlan)\n\t\t\t*pop_vlan = true;\n\t}\n\n\treturn vlan_id;\n}\n\nstatic u16 ofdpa_port_vlan_to_vid(const struct ofdpa_port *ofdpa_port,\n\t\t\t\t  __be16 vlan_id)\n{\n\tif (ofdpa_vlan_id_is_internal(vlan_id))\n\t\treturn 0;\n\n\treturn ntohs(vlan_id);\n}\n\nstatic bool ofdpa_port_is_slave(const struct ofdpa_port *ofdpa_port,\n\t\t\t\tconst char *kind)\n{\n\treturn ofdpa_port->bridge_dev &&\n\t\t!strcmp(ofdpa_port->bridge_dev->rtnl_link_ops->kind, kind);\n}\n\nstatic bool ofdpa_port_is_bridged(const struct ofdpa_port *ofdpa_port)\n{\n\treturn ofdpa_port_is_slave(ofdpa_port, \"bridge\");\n}\n\nstatic bool ofdpa_port_is_ovsed(const struct ofdpa_port *ofdpa_port)\n{\n\treturn ofdpa_port_is_slave(ofdpa_port, \"openvswitch\");\n}\n\n#define OFDPA_OP_FLAG_REMOVE\t\tBIT(0)\n#define OFDPA_OP_FLAG_NOWAIT\t\tBIT(1)\n#define OFDPA_OP_FLAG_LEARNED\t\tBIT(2)\n#define OFDPA_OP_FLAG_REFRESH\t\tBIT(3)\n\nstatic bool ofdpa_flags_nowait(int flags)\n{\n\treturn flags & OFDPA_OP_FLAG_NOWAIT;\n}\n\n \n\nstatic int\nofdpa_cmd_flow_tbl_add_ig_port(struct rocker_desc_info *desc_info,\n\t\t\t       const struct ofdpa_flow_tbl_entry *entry)\n{\n\tif (rocker_tlv_put_u32(desc_info, ROCKER_TLV_OF_DPA_IN_PPORT,\n\t\t\t       entry->key.ig_port.in_pport))\n\t\treturn -EMSGSIZE;\n\tif (rocker_tlv_put_u32(desc_info, ROCKER_TLV_OF_DPA_IN_PPORT_MASK,\n\t\t\t       entry->key.ig_port.in_pport_mask))\n\t\treturn -EMSGSIZE;\n\tif (rocker_tlv_put_u16(desc_info, ROCKER_TLV_OF_DPA_GOTO_TABLE_ID,\n\t\t\t       entry->key.ig_port.goto_tbl))\n\t\treturn -EMSGSIZE;\n\n\treturn 0;\n}\n\nstatic int\nofdpa_cmd_flow_tbl_add_vlan(struct rocker_desc_info *desc_info,\n\t\t\t    const struct ofdpa_flow_tbl_entry *entry)\n{\n\tif (rocker_tlv_put_u32(desc_info, ROCKER_TLV_OF_DPA_IN_PPORT,\n\t\t\t       entry->key.vlan.in_pport))\n\t\treturn -EMSGSIZE;\n\tif (rocker_tlv_put_be16(desc_info, ROCKER_TLV_OF_DPA_VLAN_ID,\n\t\t\t\tentry->key.vlan.vlan_id))\n\t\treturn -EMSGSIZE;\n\tif (rocker_tlv_put_be16(desc_info, ROCKER_TLV_OF_DPA_VLAN_ID_MASK,\n\t\t\t\tentry->key.vlan.vlan_id_mask))\n\t\treturn -EMSGSIZE;\n\tif (rocker_tlv_put_u16(desc_info, ROCKER_TLV_OF_DPA_GOTO_TABLE_ID,\n\t\t\t       entry->key.vlan.goto_tbl))\n\t\treturn -EMSGSIZE;\n\tif (entry->key.vlan.untagged &&\n\t    rocker_tlv_put_be16(desc_info, ROCKER_TLV_OF_DPA_NEW_VLAN_ID,\n\t\t\t\tentry->key.vlan.new_vlan_id))\n\t\treturn -EMSGSIZE;\n\n\treturn 0;\n}\n\nstatic int\nofdpa_cmd_flow_tbl_add_term_mac(struct rocker_desc_info *desc_info,\n\t\t\t\tconst struct ofdpa_flow_tbl_entry *entry)\n{\n\tif (rocker_tlv_put_u32(desc_info, ROCKER_TLV_OF_DPA_IN_PPORT,\n\t\t\t       entry->key.term_mac.in_pport))\n\t\treturn -EMSGSIZE;\n\tif (rocker_tlv_put_u32(desc_info, ROCKER_TLV_OF_DPA_IN_PPORT_MASK,\n\t\t\t       entry->key.term_mac.in_pport_mask))\n\t\treturn -EMSGSIZE;\n\tif (rocker_tlv_put_be16(desc_info, ROCKER_TLV_OF_DPA_ETHERTYPE,\n\t\t\t\tentry->key.term_mac.eth_type))\n\t\treturn -EMSGSIZE;\n\tif (rocker_tlv_put(desc_info, ROCKER_TLV_OF_DPA_DST_MAC,\n\t\t\t   ETH_ALEN, entry->key.term_mac.eth_dst))\n\t\treturn -EMSGSIZE;\n\tif (rocker_tlv_put(desc_info, ROCKER_TLV_OF_DPA_DST_MAC_MASK,\n\t\t\t   ETH_ALEN, entry->key.term_mac.eth_dst_mask))\n\t\treturn -EMSGSIZE;\n\tif (rocker_tlv_put_be16(desc_info, ROCKER_TLV_OF_DPA_VLAN_ID,\n\t\t\t\tentry->key.term_mac.vlan_id))\n\t\treturn -EMSGSIZE;\n\tif (rocker_tlv_put_be16(desc_info, ROCKER_TLV_OF_DPA_VLAN_ID_MASK,\n\t\t\t\tentry->key.term_mac.vlan_id_mask))\n\t\treturn -EMSGSIZE;\n\tif (rocker_tlv_put_u16(desc_info, ROCKER_TLV_OF_DPA_GOTO_TABLE_ID,\n\t\t\t       entry->key.term_mac.goto_tbl))\n\t\treturn -EMSGSIZE;\n\tif (entry->key.term_mac.copy_to_cpu &&\n\t    rocker_tlv_put_u8(desc_info, ROCKER_TLV_OF_DPA_COPY_CPU_ACTION,\n\t\t\t      entry->key.term_mac.copy_to_cpu))\n\t\treturn -EMSGSIZE;\n\n\treturn 0;\n}\n\nstatic int\nofdpa_cmd_flow_tbl_add_ucast_routing(struct rocker_desc_info *desc_info,\n\t\t\t\t     const struct ofdpa_flow_tbl_entry *entry)\n{\n\tif (rocker_tlv_put_be16(desc_info, ROCKER_TLV_OF_DPA_ETHERTYPE,\n\t\t\t\tentry->key.ucast_routing.eth_type))\n\t\treturn -EMSGSIZE;\n\tif (rocker_tlv_put_be32(desc_info, ROCKER_TLV_OF_DPA_DST_IP,\n\t\t\t\tentry->key.ucast_routing.dst4))\n\t\treturn -EMSGSIZE;\n\tif (rocker_tlv_put_be32(desc_info, ROCKER_TLV_OF_DPA_DST_IP_MASK,\n\t\t\t\tentry->key.ucast_routing.dst4_mask))\n\t\treturn -EMSGSIZE;\n\tif (rocker_tlv_put_u16(desc_info, ROCKER_TLV_OF_DPA_GOTO_TABLE_ID,\n\t\t\t       entry->key.ucast_routing.goto_tbl))\n\t\treturn -EMSGSIZE;\n\tif (rocker_tlv_put_u32(desc_info, ROCKER_TLV_OF_DPA_GROUP_ID,\n\t\t\t       entry->key.ucast_routing.group_id))\n\t\treturn -EMSGSIZE;\n\n\treturn 0;\n}\n\nstatic int\nofdpa_cmd_flow_tbl_add_bridge(struct rocker_desc_info *desc_info,\n\t\t\t      const struct ofdpa_flow_tbl_entry *entry)\n{\n\tif (entry->key.bridge.has_eth_dst &&\n\t    rocker_tlv_put(desc_info, ROCKER_TLV_OF_DPA_DST_MAC,\n\t\t\t   ETH_ALEN, entry->key.bridge.eth_dst))\n\t\treturn -EMSGSIZE;\n\tif (entry->key.bridge.has_eth_dst_mask &&\n\t    rocker_tlv_put(desc_info, ROCKER_TLV_OF_DPA_DST_MAC_MASK,\n\t\t\t   ETH_ALEN, entry->key.bridge.eth_dst_mask))\n\t\treturn -EMSGSIZE;\n\tif (entry->key.bridge.vlan_id &&\n\t    rocker_tlv_put_be16(desc_info, ROCKER_TLV_OF_DPA_VLAN_ID,\n\t\t\t\tentry->key.bridge.vlan_id))\n\t\treturn -EMSGSIZE;\n\tif (entry->key.bridge.tunnel_id &&\n\t    rocker_tlv_put_u32(desc_info, ROCKER_TLV_OF_DPA_TUNNEL_ID,\n\t\t\t       entry->key.bridge.tunnel_id))\n\t\treturn -EMSGSIZE;\n\tif (rocker_tlv_put_u16(desc_info, ROCKER_TLV_OF_DPA_GOTO_TABLE_ID,\n\t\t\t       entry->key.bridge.goto_tbl))\n\t\treturn -EMSGSIZE;\n\tif (rocker_tlv_put_u32(desc_info, ROCKER_TLV_OF_DPA_GROUP_ID,\n\t\t\t       entry->key.bridge.group_id))\n\t\treturn -EMSGSIZE;\n\tif (entry->key.bridge.copy_to_cpu &&\n\t    rocker_tlv_put_u8(desc_info, ROCKER_TLV_OF_DPA_COPY_CPU_ACTION,\n\t\t\t      entry->key.bridge.copy_to_cpu))\n\t\treturn -EMSGSIZE;\n\n\treturn 0;\n}\n\nstatic int\nofdpa_cmd_flow_tbl_add_acl(struct rocker_desc_info *desc_info,\n\t\t\t   const struct ofdpa_flow_tbl_entry *entry)\n{\n\tif (rocker_tlv_put_u32(desc_info, ROCKER_TLV_OF_DPA_IN_PPORT,\n\t\t\t       entry->key.acl.in_pport))\n\t\treturn -EMSGSIZE;\n\tif (rocker_tlv_put_u32(desc_info, ROCKER_TLV_OF_DPA_IN_PPORT_MASK,\n\t\t\t       entry->key.acl.in_pport_mask))\n\t\treturn -EMSGSIZE;\n\tif (rocker_tlv_put(desc_info, ROCKER_TLV_OF_DPA_SRC_MAC,\n\t\t\t   ETH_ALEN, entry->key.acl.eth_src))\n\t\treturn -EMSGSIZE;\n\tif (rocker_tlv_put(desc_info, ROCKER_TLV_OF_DPA_SRC_MAC_MASK,\n\t\t\t   ETH_ALEN, entry->key.acl.eth_src_mask))\n\t\treturn -EMSGSIZE;\n\tif (rocker_tlv_put(desc_info, ROCKER_TLV_OF_DPA_DST_MAC,\n\t\t\t   ETH_ALEN, entry->key.acl.eth_dst))\n\t\treturn -EMSGSIZE;\n\tif (rocker_tlv_put(desc_info, ROCKER_TLV_OF_DPA_DST_MAC_MASK,\n\t\t\t   ETH_ALEN, entry->key.acl.eth_dst_mask))\n\t\treturn -EMSGSIZE;\n\tif (rocker_tlv_put_be16(desc_info, ROCKER_TLV_OF_DPA_ETHERTYPE,\n\t\t\t\tentry->key.acl.eth_type))\n\t\treturn -EMSGSIZE;\n\tif (rocker_tlv_put_be16(desc_info, ROCKER_TLV_OF_DPA_VLAN_ID,\n\t\t\t\tentry->key.acl.vlan_id))\n\t\treturn -EMSGSIZE;\n\tif (rocker_tlv_put_be16(desc_info, ROCKER_TLV_OF_DPA_VLAN_ID_MASK,\n\t\t\t\tentry->key.acl.vlan_id_mask))\n\t\treturn -EMSGSIZE;\n\n\tswitch (ntohs(entry->key.acl.eth_type)) {\n\tcase ETH_P_IP:\n\tcase ETH_P_IPV6:\n\t\tif (rocker_tlv_put_u8(desc_info, ROCKER_TLV_OF_DPA_IP_PROTO,\n\t\t\t\t      entry->key.acl.ip_proto))\n\t\t\treturn -EMSGSIZE;\n\t\tif (rocker_tlv_put_u8(desc_info,\n\t\t\t\t      ROCKER_TLV_OF_DPA_IP_PROTO_MASK,\n\t\t\t\t      entry->key.acl.ip_proto_mask))\n\t\t\treturn -EMSGSIZE;\n\t\tif (rocker_tlv_put_u8(desc_info, ROCKER_TLV_OF_DPA_IP_DSCP,\n\t\t\t\t      entry->key.acl.ip_tos & 0x3f))\n\t\t\treturn -EMSGSIZE;\n\t\tif (rocker_tlv_put_u8(desc_info,\n\t\t\t\t      ROCKER_TLV_OF_DPA_IP_DSCP_MASK,\n\t\t\t\t      entry->key.acl.ip_tos_mask & 0x3f))\n\t\t\treturn -EMSGSIZE;\n\t\tif (rocker_tlv_put_u8(desc_info, ROCKER_TLV_OF_DPA_IP_ECN,\n\t\t\t\t      (entry->key.acl.ip_tos & 0xc0) >> 6))\n\t\t\treturn -EMSGSIZE;\n\t\tif (rocker_tlv_put_u8(desc_info,\n\t\t\t\t      ROCKER_TLV_OF_DPA_IP_ECN_MASK,\n\t\t\t\t      (entry->key.acl.ip_tos_mask & 0xc0) >> 6))\n\t\t\treturn -EMSGSIZE;\n\t\tbreak;\n\t}\n\n\tif (entry->key.acl.group_id != ROCKER_GROUP_NONE &&\n\t    rocker_tlv_put_u32(desc_info, ROCKER_TLV_OF_DPA_GROUP_ID,\n\t\t\t       entry->key.acl.group_id))\n\t\treturn -EMSGSIZE;\n\n\treturn 0;\n}\n\nstatic int ofdpa_cmd_flow_tbl_add(const struct rocker_port *rocker_port,\n\t\t\t\t  struct rocker_desc_info *desc_info,\n\t\t\t\t  void *priv)\n{\n\tconst struct ofdpa_flow_tbl_entry *entry = priv;\n\tstruct rocker_tlv *cmd_info;\n\tint err = 0;\n\n\tif (rocker_tlv_put_u16(desc_info, ROCKER_TLV_CMD_TYPE, entry->cmd))\n\t\treturn -EMSGSIZE;\n\tcmd_info = rocker_tlv_nest_start(desc_info, ROCKER_TLV_CMD_INFO);\n\tif (!cmd_info)\n\t\treturn -EMSGSIZE;\n\tif (rocker_tlv_put_u16(desc_info, ROCKER_TLV_OF_DPA_TABLE_ID,\n\t\t\t       entry->key.tbl_id))\n\t\treturn -EMSGSIZE;\n\tif (rocker_tlv_put_u32(desc_info, ROCKER_TLV_OF_DPA_PRIORITY,\n\t\t\t       entry->key.priority))\n\t\treturn -EMSGSIZE;\n\tif (rocker_tlv_put_u32(desc_info, ROCKER_TLV_OF_DPA_HARDTIME, 0))\n\t\treturn -EMSGSIZE;\n\tif (rocker_tlv_put_u64(desc_info, ROCKER_TLV_OF_DPA_COOKIE,\n\t\t\t       entry->cookie))\n\t\treturn -EMSGSIZE;\n\n\tswitch (entry->key.tbl_id) {\n\tcase ROCKER_OF_DPA_TABLE_ID_INGRESS_PORT:\n\t\terr = ofdpa_cmd_flow_tbl_add_ig_port(desc_info, entry);\n\t\tbreak;\n\tcase ROCKER_OF_DPA_TABLE_ID_VLAN:\n\t\terr = ofdpa_cmd_flow_tbl_add_vlan(desc_info, entry);\n\t\tbreak;\n\tcase ROCKER_OF_DPA_TABLE_ID_TERMINATION_MAC:\n\t\terr = ofdpa_cmd_flow_tbl_add_term_mac(desc_info, entry);\n\t\tbreak;\n\tcase ROCKER_OF_DPA_TABLE_ID_UNICAST_ROUTING:\n\t\terr = ofdpa_cmd_flow_tbl_add_ucast_routing(desc_info, entry);\n\t\tbreak;\n\tcase ROCKER_OF_DPA_TABLE_ID_BRIDGING:\n\t\terr = ofdpa_cmd_flow_tbl_add_bridge(desc_info, entry);\n\t\tbreak;\n\tcase ROCKER_OF_DPA_TABLE_ID_ACL_POLICY:\n\t\terr = ofdpa_cmd_flow_tbl_add_acl(desc_info, entry);\n\t\tbreak;\n\tdefault:\n\t\terr = -ENOTSUPP;\n\t\tbreak;\n\t}\n\n\tif (err)\n\t\treturn err;\n\n\trocker_tlv_nest_end(desc_info, cmd_info);\n\n\treturn 0;\n}\n\nstatic int ofdpa_cmd_flow_tbl_del(const struct rocker_port *rocker_port,\n\t\t\t\t  struct rocker_desc_info *desc_info,\n\t\t\t\t  void *priv)\n{\n\tconst struct ofdpa_flow_tbl_entry *entry = priv;\n\tstruct rocker_tlv *cmd_info;\n\n\tif (rocker_tlv_put_u16(desc_info, ROCKER_TLV_CMD_TYPE, entry->cmd))\n\t\treturn -EMSGSIZE;\n\tcmd_info = rocker_tlv_nest_start(desc_info, ROCKER_TLV_CMD_INFO);\n\tif (!cmd_info)\n\t\treturn -EMSGSIZE;\n\tif (rocker_tlv_put_u64(desc_info, ROCKER_TLV_OF_DPA_COOKIE,\n\t\t\t       entry->cookie))\n\t\treturn -EMSGSIZE;\n\trocker_tlv_nest_end(desc_info, cmd_info);\n\n\treturn 0;\n}\n\nstatic int\nofdpa_cmd_group_tbl_add_l2_interface(struct rocker_desc_info *desc_info,\n\t\t\t\t     struct ofdpa_group_tbl_entry *entry)\n{\n\tif (rocker_tlv_put_u32(desc_info, ROCKER_TLV_OF_DPA_OUT_PPORT,\n\t\t\t       ROCKER_GROUP_PORT_GET(entry->group_id)))\n\t\treturn -EMSGSIZE;\n\tif (rocker_tlv_put_u8(desc_info, ROCKER_TLV_OF_DPA_POP_VLAN,\n\t\t\t      entry->l2_interface.pop_vlan))\n\t\treturn -EMSGSIZE;\n\n\treturn 0;\n}\n\nstatic int\nofdpa_cmd_group_tbl_add_l2_rewrite(struct rocker_desc_info *desc_info,\n\t\t\t\t   const struct ofdpa_group_tbl_entry *entry)\n{\n\tif (rocker_tlv_put_u32(desc_info, ROCKER_TLV_OF_DPA_GROUP_ID_LOWER,\n\t\t\t       entry->l2_rewrite.group_id))\n\t\treturn -EMSGSIZE;\n\tif (!is_zero_ether_addr(entry->l2_rewrite.eth_src) &&\n\t    rocker_tlv_put(desc_info, ROCKER_TLV_OF_DPA_SRC_MAC,\n\t\t\t   ETH_ALEN, entry->l2_rewrite.eth_src))\n\t\treturn -EMSGSIZE;\n\tif (!is_zero_ether_addr(entry->l2_rewrite.eth_dst) &&\n\t    rocker_tlv_put(desc_info, ROCKER_TLV_OF_DPA_DST_MAC,\n\t\t\t   ETH_ALEN, entry->l2_rewrite.eth_dst))\n\t\treturn -EMSGSIZE;\n\tif (entry->l2_rewrite.vlan_id &&\n\t    rocker_tlv_put_be16(desc_info, ROCKER_TLV_OF_DPA_VLAN_ID,\n\t\t\t\tentry->l2_rewrite.vlan_id))\n\t\treturn -EMSGSIZE;\n\n\treturn 0;\n}\n\nstatic int\nofdpa_cmd_group_tbl_add_group_ids(struct rocker_desc_info *desc_info,\n\t\t\t\t  const struct ofdpa_group_tbl_entry *entry)\n{\n\tint i;\n\tstruct rocker_tlv *group_ids;\n\n\tif (rocker_tlv_put_u16(desc_info, ROCKER_TLV_OF_DPA_GROUP_COUNT,\n\t\t\t       entry->group_count))\n\t\treturn -EMSGSIZE;\n\n\tgroup_ids = rocker_tlv_nest_start(desc_info,\n\t\t\t\t\t  ROCKER_TLV_OF_DPA_GROUP_IDS);\n\tif (!group_ids)\n\t\treturn -EMSGSIZE;\n\n\tfor (i = 0; i < entry->group_count; i++)\n\t\t \n\t\tif (rocker_tlv_put_u32(desc_info, i + 1, entry->group_ids[i]))\n\t\t\treturn -EMSGSIZE;\n\n\trocker_tlv_nest_end(desc_info, group_ids);\n\n\treturn 0;\n}\n\nstatic int\nofdpa_cmd_group_tbl_add_l3_unicast(struct rocker_desc_info *desc_info,\n\t\t\t\t   const struct ofdpa_group_tbl_entry *entry)\n{\n\tif (!is_zero_ether_addr(entry->l3_unicast.eth_src) &&\n\t    rocker_tlv_put(desc_info, ROCKER_TLV_OF_DPA_SRC_MAC,\n\t\t\t   ETH_ALEN, entry->l3_unicast.eth_src))\n\t\treturn -EMSGSIZE;\n\tif (!is_zero_ether_addr(entry->l3_unicast.eth_dst) &&\n\t    rocker_tlv_put(desc_info, ROCKER_TLV_OF_DPA_DST_MAC,\n\t\t\t   ETH_ALEN, entry->l3_unicast.eth_dst))\n\t\treturn -EMSGSIZE;\n\tif (entry->l3_unicast.vlan_id &&\n\t    rocker_tlv_put_be16(desc_info, ROCKER_TLV_OF_DPA_VLAN_ID,\n\t\t\t\tentry->l3_unicast.vlan_id))\n\t\treturn -EMSGSIZE;\n\tif (rocker_tlv_put_u8(desc_info, ROCKER_TLV_OF_DPA_TTL_CHECK,\n\t\t\t      entry->l3_unicast.ttl_check))\n\t\treturn -EMSGSIZE;\n\tif (rocker_tlv_put_u32(desc_info, ROCKER_TLV_OF_DPA_GROUP_ID_LOWER,\n\t\t\t       entry->l3_unicast.group_id))\n\t\treturn -EMSGSIZE;\n\n\treturn 0;\n}\n\nstatic int ofdpa_cmd_group_tbl_add(const struct rocker_port *rocker_port,\n\t\t\t\t   struct rocker_desc_info *desc_info,\n\t\t\t\t   void *priv)\n{\n\tstruct ofdpa_group_tbl_entry *entry = priv;\n\tstruct rocker_tlv *cmd_info;\n\tint err = 0;\n\n\tif (rocker_tlv_put_u16(desc_info, ROCKER_TLV_CMD_TYPE, entry->cmd))\n\t\treturn -EMSGSIZE;\n\tcmd_info = rocker_tlv_nest_start(desc_info, ROCKER_TLV_CMD_INFO);\n\tif (!cmd_info)\n\t\treturn -EMSGSIZE;\n\n\tif (rocker_tlv_put_u32(desc_info, ROCKER_TLV_OF_DPA_GROUP_ID,\n\t\t\t       entry->group_id))\n\t\treturn -EMSGSIZE;\n\n\tswitch (ROCKER_GROUP_TYPE_GET(entry->group_id)) {\n\tcase ROCKER_OF_DPA_GROUP_TYPE_L2_INTERFACE:\n\t\terr = ofdpa_cmd_group_tbl_add_l2_interface(desc_info, entry);\n\t\tbreak;\n\tcase ROCKER_OF_DPA_GROUP_TYPE_L2_REWRITE:\n\t\terr = ofdpa_cmd_group_tbl_add_l2_rewrite(desc_info, entry);\n\t\tbreak;\n\tcase ROCKER_OF_DPA_GROUP_TYPE_L2_FLOOD:\n\tcase ROCKER_OF_DPA_GROUP_TYPE_L2_MCAST:\n\t\terr = ofdpa_cmd_group_tbl_add_group_ids(desc_info, entry);\n\t\tbreak;\n\tcase ROCKER_OF_DPA_GROUP_TYPE_L3_UCAST:\n\t\terr = ofdpa_cmd_group_tbl_add_l3_unicast(desc_info, entry);\n\t\tbreak;\n\tdefault:\n\t\terr = -ENOTSUPP;\n\t\tbreak;\n\t}\n\n\tif (err)\n\t\treturn err;\n\n\trocker_tlv_nest_end(desc_info, cmd_info);\n\n\treturn 0;\n}\n\nstatic int ofdpa_cmd_group_tbl_del(const struct rocker_port *rocker_port,\n\t\t\t\t   struct rocker_desc_info *desc_info,\n\t\t\t\t   void *priv)\n{\n\tconst struct ofdpa_group_tbl_entry *entry = priv;\n\tstruct rocker_tlv *cmd_info;\n\n\tif (rocker_tlv_put_u16(desc_info, ROCKER_TLV_CMD_TYPE, entry->cmd))\n\t\treturn -EMSGSIZE;\n\tcmd_info = rocker_tlv_nest_start(desc_info, ROCKER_TLV_CMD_INFO);\n\tif (!cmd_info)\n\t\treturn -EMSGSIZE;\n\tif (rocker_tlv_put_u32(desc_info, ROCKER_TLV_OF_DPA_GROUP_ID,\n\t\t\t       entry->group_id))\n\t\treturn -EMSGSIZE;\n\trocker_tlv_nest_end(desc_info, cmd_info);\n\n\treturn 0;\n}\n\n \n\nstatic struct ofdpa_flow_tbl_entry *\nofdpa_flow_tbl_find(const struct ofdpa *ofdpa,\n\t\t    const struct ofdpa_flow_tbl_entry *match)\n{\n\tstruct ofdpa_flow_tbl_entry *found;\n\tsize_t key_len = match->key_len ? match->key_len : sizeof(found->key);\n\n\thash_for_each_possible(ofdpa->flow_tbl, found,\n\t\t\t       entry, match->key_crc32) {\n\t\tif (memcmp(&found->key, &match->key, key_len) == 0)\n\t\t\treturn found;\n\t}\n\n\treturn NULL;\n}\n\nstatic int ofdpa_flow_tbl_add(struct ofdpa_port *ofdpa_port,\n\t\t\t      int flags, struct ofdpa_flow_tbl_entry *match)\n{\n\tstruct ofdpa *ofdpa = ofdpa_port->ofdpa;\n\tstruct ofdpa_flow_tbl_entry *found;\n\tsize_t key_len = match->key_len ? match->key_len : sizeof(found->key);\n\tunsigned long lock_flags;\n\n\tmatch->key_crc32 = crc32(~0, &match->key, key_len);\n\n\tspin_lock_irqsave(&ofdpa->flow_tbl_lock, lock_flags);\n\n\tfound = ofdpa_flow_tbl_find(ofdpa, match);\n\n\tif (found) {\n\t\tmatch->cookie = found->cookie;\n\t\thash_del(&found->entry);\n\t\tkfree(found);\n\t\tfound = match;\n\t\tfound->cmd = ROCKER_TLV_CMD_TYPE_OF_DPA_FLOW_MOD;\n\t} else {\n\t\tfound = match;\n\t\tfound->cookie = ofdpa->flow_tbl_next_cookie++;\n\t\tfound->cmd = ROCKER_TLV_CMD_TYPE_OF_DPA_FLOW_ADD;\n\t}\n\n\thash_add(ofdpa->flow_tbl, &found->entry, found->key_crc32);\n\tspin_unlock_irqrestore(&ofdpa->flow_tbl_lock, lock_flags);\n\n\treturn rocker_cmd_exec(ofdpa_port->rocker_port,\n\t\t\t       ofdpa_flags_nowait(flags),\n\t\t\t       ofdpa_cmd_flow_tbl_add,\n\t\t\t       found, NULL, NULL);\n}\n\nstatic int ofdpa_flow_tbl_del(struct ofdpa_port *ofdpa_port,\n\t\t\t      int flags, struct ofdpa_flow_tbl_entry *match)\n{\n\tstruct ofdpa *ofdpa = ofdpa_port->ofdpa;\n\tstruct ofdpa_flow_tbl_entry *found;\n\tsize_t key_len = match->key_len ? match->key_len : sizeof(found->key);\n\tunsigned long lock_flags;\n\tint err = 0;\n\n\tmatch->key_crc32 = crc32(~0, &match->key, key_len);\n\n\tspin_lock_irqsave(&ofdpa->flow_tbl_lock, lock_flags);\n\n\tfound = ofdpa_flow_tbl_find(ofdpa, match);\n\n\tif (found) {\n\t\thash_del(&found->entry);\n\t\tfound->cmd = ROCKER_TLV_CMD_TYPE_OF_DPA_FLOW_DEL;\n\t}\n\n\tspin_unlock_irqrestore(&ofdpa->flow_tbl_lock, lock_flags);\n\n\tkfree(match);\n\n\tif (found) {\n\t\terr = rocker_cmd_exec(ofdpa_port->rocker_port,\n\t\t\t\t      ofdpa_flags_nowait(flags),\n\t\t\t\t      ofdpa_cmd_flow_tbl_del,\n\t\t\t\t      found, NULL, NULL);\n\t\tkfree(found);\n\t}\n\n\treturn err;\n}\n\nstatic int ofdpa_flow_tbl_do(struct ofdpa_port *ofdpa_port, int flags,\n\t\t\t     struct ofdpa_flow_tbl_entry *entry)\n{\n\tif (flags & OFDPA_OP_FLAG_REMOVE)\n\t\treturn ofdpa_flow_tbl_del(ofdpa_port, flags, entry);\n\telse\n\t\treturn ofdpa_flow_tbl_add(ofdpa_port, flags, entry);\n}\n\nstatic int ofdpa_flow_tbl_ig_port(struct ofdpa_port *ofdpa_port, int flags,\n\t\t\t\t  u32 in_pport, u32 in_pport_mask,\n\t\t\t\t  enum rocker_of_dpa_table_id goto_tbl)\n{\n\tstruct ofdpa_flow_tbl_entry *entry;\n\n\tentry = kzalloc(sizeof(*entry), GFP_KERNEL);\n\tif (!entry)\n\t\treturn -ENOMEM;\n\n\tentry->key.priority = OFDPA_PRIORITY_IG_PORT;\n\tentry->key.tbl_id = ROCKER_OF_DPA_TABLE_ID_INGRESS_PORT;\n\tentry->key.ig_port.in_pport = in_pport;\n\tentry->key.ig_port.in_pport_mask = in_pport_mask;\n\tentry->key.ig_port.goto_tbl = goto_tbl;\n\n\treturn ofdpa_flow_tbl_do(ofdpa_port, flags, entry);\n}\n\nstatic int ofdpa_flow_tbl_vlan(struct ofdpa_port *ofdpa_port,\n\t\t\t       int flags,\n\t\t\t       u32 in_pport, __be16 vlan_id,\n\t\t\t       __be16 vlan_id_mask,\n\t\t\t       enum rocker_of_dpa_table_id goto_tbl,\n\t\t\t       bool untagged, __be16 new_vlan_id)\n{\n\tstruct ofdpa_flow_tbl_entry *entry;\n\n\tentry = kzalloc(sizeof(*entry), GFP_KERNEL);\n\tif (!entry)\n\t\treturn -ENOMEM;\n\n\tentry->key.priority = OFDPA_PRIORITY_VLAN;\n\tentry->key.tbl_id = ROCKER_OF_DPA_TABLE_ID_VLAN;\n\tentry->key.vlan.in_pport = in_pport;\n\tentry->key.vlan.vlan_id = vlan_id;\n\tentry->key.vlan.vlan_id_mask = vlan_id_mask;\n\tentry->key.vlan.goto_tbl = goto_tbl;\n\n\tentry->key.vlan.untagged = untagged;\n\tentry->key.vlan.new_vlan_id = new_vlan_id;\n\n\treturn ofdpa_flow_tbl_do(ofdpa_port, flags, entry);\n}\n\nstatic int ofdpa_flow_tbl_term_mac(struct ofdpa_port *ofdpa_port,\n\t\t\t\t   u32 in_pport, u32 in_pport_mask,\n\t\t\t\t   __be16 eth_type, const u8 *eth_dst,\n\t\t\t\t   const u8 *eth_dst_mask, __be16 vlan_id,\n\t\t\t\t   __be16 vlan_id_mask, bool copy_to_cpu,\n\t\t\t\t   int flags)\n{\n\tstruct ofdpa_flow_tbl_entry *entry;\n\n\tentry = kzalloc(sizeof(*entry), GFP_KERNEL);\n\tif (!entry)\n\t\treturn -ENOMEM;\n\n\tif (is_multicast_ether_addr(eth_dst)) {\n\t\tentry->key.priority = OFDPA_PRIORITY_TERM_MAC_MCAST;\n\t\tentry->key.term_mac.goto_tbl =\n\t\t\t ROCKER_OF_DPA_TABLE_ID_MULTICAST_ROUTING;\n\t} else {\n\t\tentry->key.priority = OFDPA_PRIORITY_TERM_MAC_UCAST;\n\t\tentry->key.term_mac.goto_tbl =\n\t\t\t ROCKER_OF_DPA_TABLE_ID_UNICAST_ROUTING;\n\t}\n\n\tentry->key.tbl_id = ROCKER_OF_DPA_TABLE_ID_TERMINATION_MAC;\n\tentry->key.term_mac.in_pport = in_pport;\n\tentry->key.term_mac.in_pport_mask = in_pport_mask;\n\tentry->key.term_mac.eth_type = eth_type;\n\tether_addr_copy(entry->key.term_mac.eth_dst, eth_dst);\n\tether_addr_copy(entry->key.term_mac.eth_dst_mask, eth_dst_mask);\n\tentry->key.term_mac.vlan_id = vlan_id;\n\tentry->key.term_mac.vlan_id_mask = vlan_id_mask;\n\tentry->key.term_mac.copy_to_cpu = copy_to_cpu;\n\n\treturn ofdpa_flow_tbl_do(ofdpa_port, flags, entry);\n}\n\nstatic int ofdpa_flow_tbl_bridge(struct ofdpa_port *ofdpa_port,\n\t\t\t\t int flags, const u8 *eth_dst,\n\t\t\t\t const u8 *eth_dst_mask,  __be16 vlan_id,\n\t\t\t\t u32 tunnel_id,\n\t\t\t\t enum rocker_of_dpa_table_id goto_tbl,\n\t\t\t\t u32 group_id, bool copy_to_cpu)\n{\n\tstruct ofdpa_flow_tbl_entry *entry;\n\tu32 priority;\n\tbool vlan_bridging = !!vlan_id;\n\tbool dflt = !eth_dst || eth_dst_mask;\n\tbool wild = false;\n\n\tentry = kzalloc(sizeof(*entry), GFP_ATOMIC);\n\tif (!entry)\n\t\treturn -ENOMEM;\n\n\tentry->key.tbl_id = ROCKER_OF_DPA_TABLE_ID_BRIDGING;\n\n\tif (eth_dst) {\n\t\tentry->key.bridge.has_eth_dst = 1;\n\t\tether_addr_copy(entry->key.bridge.eth_dst, eth_dst);\n\t}\n\tif (eth_dst_mask) {\n\t\tentry->key.bridge.has_eth_dst_mask = 1;\n\t\tether_addr_copy(entry->key.bridge.eth_dst_mask, eth_dst_mask);\n\t\tif (!ether_addr_equal(eth_dst_mask, ff_mac))\n\t\t\twild = true;\n\t}\n\n\tpriority = OFDPA_PRIORITY_UNKNOWN;\n\tif (vlan_bridging && dflt && wild)\n\t\tpriority = OFDPA_PRIORITY_BRIDGING_VLAN_DFLT_WILD;\n\telse if (vlan_bridging && dflt && !wild)\n\t\tpriority = OFDPA_PRIORITY_BRIDGING_VLAN_DFLT_EXACT;\n\telse if (vlan_bridging && !dflt)\n\t\tpriority = OFDPA_PRIORITY_BRIDGING_VLAN;\n\telse if (!vlan_bridging && dflt && wild)\n\t\tpriority = OFDPA_PRIORITY_BRIDGING_TENANT_DFLT_WILD;\n\telse if (!vlan_bridging && dflt && !wild)\n\t\tpriority = OFDPA_PRIORITY_BRIDGING_TENANT_DFLT_EXACT;\n\telse if (!vlan_bridging && !dflt)\n\t\tpriority = OFDPA_PRIORITY_BRIDGING_TENANT;\n\n\tentry->key.priority = priority;\n\tentry->key.bridge.vlan_id = vlan_id;\n\tentry->key.bridge.tunnel_id = tunnel_id;\n\tentry->key.bridge.goto_tbl = goto_tbl;\n\tentry->key.bridge.group_id = group_id;\n\tentry->key.bridge.copy_to_cpu = copy_to_cpu;\n\n\treturn ofdpa_flow_tbl_do(ofdpa_port, flags, entry);\n}\n\nstatic int ofdpa_flow_tbl_ucast4_routing(struct ofdpa_port *ofdpa_port,\n\t\t\t\t\t __be16 eth_type, __be32 dst,\n\t\t\t\t\t __be32 dst_mask, u32 priority,\n\t\t\t\t\t enum rocker_of_dpa_table_id goto_tbl,\n\t\t\t\t\t u32 group_id, struct fib_info *fi,\n\t\t\t\t\t int flags)\n{\n\tstruct ofdpa_flow_tbl_entry *entry;\n\n\tentry = kzalloc(sizeof(*entry), GFP_KERNEL);\n\tif (!entry)\n\t\treturn -ENOMEM;\n\n\tentry->key.tbl_id = ROCKER_OF_DPA_TABLE_ID_UNICAST_ROUTING;\n\tentry->key.priority = priority;\n\tentry->key.ucast_routing.eth_type = eth_type;\n\tentry->key.ucast_routing.dst4 = dst;\n\tentry->key.ucast_routing.dst4_mask = dst_mask;\n\tentry->key.ucast_routing.goto_tbl = goto_tbl;\n\tentry->key.ucast_routing.group_id = group_id;\n\tentry->key_len = offsetof(struct ofdpa_flow_tbl_key,\n\t\t\t\t  ucast_routing.group_id);\n\tentry->fi = fi;\n\n\treturn ofdpa_flow_tbl_do(ofdpa_port, flags, entry);\n}\n\nstatic int ofdpa_flow_tbl_acl(struct ofdpa_port *ofdpa_port, int flags,\n\t\t\t      u32 in_pport, u32 in_pport_mask,\n\t\t\t      const u8 *eth_src, const u8 *eth_src_mask,\n\t\t\t      const u8 *eth_dst, const u8 *eth_dst_mask,\n\t\t\t      __be16 eth_type, __be16 vlan_id,\n\t\t\t      __be16 vlan_id_mask, u8 ip_proto,\n\t\t\t      u8 ip_proto_mask, u8 ip_tos, u8 ip_tos_mask,\n\t\t\t      u32 group_id)\n{\n\tu32 priority;\n\tstruct ofdpa_flow_tbl_entry *entry;\n\n\tentry = kzalloc(sizeof(*entry), GFP_KERNEL);\n\tif (!entry)\n\t\treturn -ENOMEM;\n\n\tpriority = OFDPA_PRIORITY_ACL_NORMAL;\n\tif (eth_dst && eth_dst_mask) {\n\t\tif (ether_addr_equal(eth_dst_mask, mcast_mac))\n\t\t\tpriority = OFDPA_PRIORITY_ACL_DFLT;\n\t\telse if (is_link_local_ether_addr(eth_dst))\n\t\t\tpriority = OFDPA_PRIORITY_ACL_CTRL;\n\t}\n\n\tentry->key.priority = priority;\n\tentry->key.tbl_id = ROCKER_OF_DPA_TABLE_ID_ACL_POLICY;\n\tentry->key.acl.in_pport = in_pport;\n\tentry->key.acl.in_pport_mask = in_pport_mask;\n\n\tif (eth_src)\n\t\tether_addr_copy(entry->key.acl.eth_src, eth_src);\n\tif (eth_src_mask)\n\t\tether_addr_copy(entry->key.acl.eth_src_mask, eth_src_mask);\n\tif (eth_dst)\n\t\tether_addr_copy(entry->key.acl.eth_dst, eth_dst);\n\tif (eth_dst_mask)\n\t\tether_addr_copy(entry->key.acl.eth_dst_mask, eth_dst_mask);\n\n\tentry->key.acl.eth_type = eth_type;\n\tentry->key.acl.vlan_id = vlan_id;\n\tentry->key.acl.vlan_id_mask = vlan_id_mask;\n\tentry->key.acl.ip_proto = ip_proto;\n\tentry->key.acl.ip_proto_mask = ip_proto_mask;\n\tentry->key.acl.ip_tos = ip_tos;\n\tentry->key.acl.ip_tos_mask = ip_tos_mask;\n\tentry->key.acl.group_id = group_id;\n\n\treturn ofdpa_flow_tbl_do(ofdpa_port, flags, entry);\n}\n\nstatic struct ofdpa_group_tbl_entry *\nofdpa_group_tbl_find(const struct ofdpa *ofdpa,\n\t\t     const struct ofdpa_group_tbl_entry *match)\n{\n\tstruct ofdpa_group_tbl_entry *found;\n\n\thash_for_each_possible(ofdpa->group_tbl, found,\n\t\t\t       entry, match->group_id) {\n\t\tif (found->group_id == match->group_id)\n\t\t\treturn found;\n\t}\n\n\treturn NULL;\n}\n\nstatic void ofdpa_group_tbl_entry_free(struct ofdpa_group_tbl_entry *entry)\n{\n\tswitch (ROCKER_GROUP_TYPE_GET(entry->group_id)) {\n\tcase ROCKER_OF_DPA_GROUP_TYPE_L2_FLOOD:\n\tcase ROCKER_OF_DPA_GROUP_TYPE_L2_MCAST:\n\t\tkfree(entry->group_ids);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tkfree(entry);\n}\n\nstatic int ofdpa_group_tbl_add(struct ofdpa_port *ofdpa_port, int flags,\n\t\t\t       struct ofdpa_group_tbl_entry *match)\n{\n\tstruct ofdpa *ofdpa = ofdpa_port->ofdpa;\n\tstruct ofdpa_group_tbl_entry *found;\n\tunsigned long lock_flags;\n\n\tspin_lock_irqsave(&ofdpa->group_tbl_lock, lock_flags);\n\n\tfound = ofdpa_group_tbl_find(ofdpa, match);\n\n\tif (found) {\n\t\thash_del(&found->entry);\n\t\tofdpa_group_tbl_entry_free(found);\n\t\tfound = match;\n\t\tfound->cmd = ROCKER_TLV_CMD_TYPE_OF_DPA_GROUP_MOD;\n\t} else {\n\t\tfound = match;\n\t\tfound->cmd = ROCKER_TLV_CMD_TYPE_OF_DPA_GROUP_ADD;\n\t}\n\n\thash_add(ofdpa->group_tbl, &found->entry, found->group_id);\n\n\tspin_unlock_irqrestore(&ofdpa->group_tbl_lock, lock_flags);\n\n\treturn rocker_cmd_exec(ofdpa_port->rocker_port,\n\t\t\t       ofdpa_flags_nowait(flags),\n\t\t\t       ofdpa_cmd_group_tbl_add,\n\t\t\t       found, NULL, NULL);\n}\n\nstatic int ofdpa_group_tbl_del(struct ofdpa_port *ofdpa_port, int flags,\n\t\t\t       struct ofdpa_group_tbl_entry *match)\n{\n\tstruct ofdpa *ofdpa = ofdpa_port->ofdpa;\n\tstruct ofdpa_group_tbl_entry *found;\n\tunsigned long lock_flags;\n\tint err = 0;\n\n\tspin_lock_irqsave(&ofdpa->group_tbl_lock, lock_flags);\n\n\tfound = ofdpa_group_tbl_find(ofdpa, match);\n\n\tif (found) {\n\t\thash_del(&found->entry);\n\t\tfound->cmd = ROCKER_TLV_CMD_TYPE_OF_DPA_GROUP_DEL;\n\t}\n\n\tspin_unlock_irqrestore(&ofdpa->group_tbl_lock, lock_flags);\n\n\tofdpa_group_tbl_entry_free(match);\n\n\tif (found) {\n\t\terr = rocker_cmd_exec(ofdpa_port->rocker_port,\n\t\t\t\t      ofdpa_flags_nowait(flags),\n\t\t\t\t      ofdpa_cmd_group_tbl_del,\n\t\t\t\t      found, NULL, NULL);\n\t\tofdpa_group_tbl_entry_free(found);\n\t}\n\n\treturn err;\n}\n\nstatic int ofdpa_group_tbl_do(struct ofdpa_port *ofdpa_port, int flags,\n\t\t\t      struct ofdpa_group_tbl_entry *entry)\n{\n\tif (flags & OFDPA_OP_FLAG_REMOVE)\n\t\treturn ofdpa_group_tbl_del(ofdpa_port, flags, entry);\n\telse\n\t\treturn ofdpa_group_tbl_add(ofdpa_port, flags, entry);\n}\n\nstatic int ofdpa_group_l2_interface(struct ofdpa_port *ofdpa_port,\n\t\t\t\t    int flags, __be16 vlan_id,\n\t\t\t\t    u32 out_pport, int pop_vlan)\n{\n\tstruct ofdpa_group_tbl_entry *entry;\n\n\tentry = kzalloc(sizeof(*entry), GFP_KERNEL);\n\tif (!entry)\n\t\treturn -ENOMEM;\n\n\tentry->group_id = ROCKER_GROUP_L2_INTERFACE(vlan_id, out_pport);\n\tentry->l2_interface.pop_vlan = pop_vlan;\n\n\treturn ofdpa_group_tbl_do(ofdpa_port, flags, entry);\n}\n\nstatic int ofdpa_group_l2_fan_out(struct ofdpa_port *ofdpa_port,\n\t\t\t\t  int flags, u8 group_count,\n\t\t\t\t  const u32 *group_ids, u32 group_id)\n{\n\tstruct ofdpa_group_tbl_entry *entry;\n\n\tentry = kzalloc(sizeof(*entry), GFP_KERNEL);\n\tif (!entry)\n\t\treturn -ENOMEM;\n\n\tentry->group_id = group_id;\n\tentry->group_count = group_count;\n\n\tentry->group_ids = kcalloc(group_count, sizeof(u32), GFP_KERNEL);\n\tif (!entry->group_ids) {\n\t\tkfree(entry);\n\t\treturn -ENOMEM;\n\t}\n\tmemcpy(entry->group_ids, group_ids, group_count * sizeof(u32));\n\n\treturn ofdpa_group_tbl_do(ofdpa_port, flags, entry);\n}\n\nstatic int ofdpa_group_l2_flood(struct ofdpa_port *ofdpa_port,\n\t\t\t\tint flags, __be16 vlan_id,\n\t\t\t\tu8 group_count,\tconst u32 *group_ids,\n\t\t\t\tu32 group_id)\n{\n\treturn ofdpa_group_l2_fan_out(ofdpa_port, flags,\n\t\t\t\t      group_count, group_ids,\n\t\t\t\t      group_id);\n}\n\nstatic int ofdpa_group_l3_unicast(struct ofdpa_port *ofdpa_port, int flags,\n\t\t\t\t  u32 index, const u8 *src_mac, const u8 *dst_mac,\n\t\t\t\t  __be16 vlan_id, bool ttl_check, u32 pport)\n{\n\tstruct ofdpa_group_tbl_entry *entry;\n\n\tentry = kzalloc(sizeof(*entry), GFP_KERNEL);\n\tif (!entry)\n\t\treturn -ENOMEM;\n\n\tentry->group_id = ROCKER_GROUP_L3_UNICAST(index);\n\tif (src_mac)\n\t\tether_addr_copy(entry->l3_unicast.eth_src, src_mac);\n\tif (dst_mac)\n\t\tether_addr_copy(entry->l3_unicast.eth_dst, dst_mac);\n\tentry->l3_unicast.vlan_id = vlan_id;\n\tentry->l3_unicast.ttl_check = ttl_check;\n\tentry->l3_unicast.group_id = ROCKER_GROUP_L2_INTERFACE(vlan_id, pport);\n\n\treturn ofdpa_group_tbl_do(ofdpa_port, flags, entry);\n}\n\nstatic struct ofdpa_neigh_tbl_entry *\nofdpa_neigh_tbl_find(const struct ofdpa *ofdpa, __be32 ip_addr)\n{\n\tstruct ofdpa_neigh_tbl_entry *found;\n\n\thash_for_each_possible(ofdpa->neigh_tbl, found,\n\t\t\t       entry, be32_to_cpu(ip_addr))\n\t\tif (found->ip_addr == ip_addr)\n\t\t\treturn found;\n\n\treturn NULL;\n}\n\nstatic void ofdpa_neigh_add(struct ofdpa *ofdpa,\n\t\t\t    struct ofdpa_neigh_tbl_entry *entry)\n{\n\tentry->index = ofdpa->neigh_tbl_next_index++;\n\tentry->ref_count++;\n\thash_add(ofdpa->neigh_tbl, &entry->entry,\n\t\t be32_to_cpu(entry->ip_addr));\n}\n\nstatic void ofdpa_neigh_del(struct ofdpa_neigh_tbl_entry *entry)\n{\n\tif (--entry->ref_count == 0) {\n\t\thash_del(&entry->entry);\n\t\tkfree(entry);\n\t}\n}\n\nstatic void ofdpa_neigh_update(struct ofdpa_neigh_tbl_entry *entry,\n\t\t\t       const u8 *eth_dst, bool ttl_check)\n{\n\tif (eth_dst) {\n\t\tether_addr_copy(entry->eth_dst, eth_dst);\n\t\tentry->ttl_check = ttl_check;\n\t} else {\n\t\tentry->ref_count++;\n\t}\n}\n\nstatic int ofdpa_port_ipv4_neigh(struct ofdpa_port *ofdpa_port,\n\t\t\t\t int flags, __be32 ip_addr, const u8 *eth_dst)\n{\n\tstruct ofdpa *ofdpa = ofdpa_port->ofdpa;\n\tstruct ofdpa_neigh_tbl_entry *entry;\n\tstruct ofdpa_neigh_tbl_entry *found;\n\tunsigned long lock_flags;\n\t__be16 eth_type = htons(ETH_P_IP);\n\tenum rocker_of_dpa_table_id goto_tbl =\n\t\t\tROCKER_OF_DPA_TABLE_ID_ACL_POLICY;\n\tu32 group_id;\n\tu32 priority = 0;\n\tbool adding = !(flags & OFDPA_OP_FLAG_REMOVE);\n\tbool updating;\n\tbool removing;\n\tint err = 0;\n\n\tentry = kzalloc(sizeof(*entry), GFP_ATOMIC);\n\tif (!entry)\n\t\treturn -ENOMEM;\n\n\tspin_lock_irqsave(&ofdpa->neigh_tbl_lock, lock_flags);\n\n\tfound = ofdpa_neigh_tbl_find(ofdpa, ip_addr);\n\n\tupdating = found && adding;\n\tremoving = found && !adding;\n\tadding = !found && adding;\n\n\tif (adding) {\n\t\tentry->ip_addr = ip_addr;\n\t\tentry->dev = ofdpa_port->dev;\n\t\tether_addr_copy(entry->eth_dst, eth_dst);\n\t\tentry->ttl_check = true;\n\t\tofdpa_neigh_add(ofdpa, entry);\n\t} else if (removing) {\n\t\tmemcpy(entry, found, sizeof(*entry));\n\t\tofdpa_neigh_del(found);\n\t} else if (updating) {\n\t\tofdpa_neigh_update(found, eth_dst, true);\n\t\tmemcpy(entry, found, sizeof(*entry));\n\t} else {\n\t\terr = -ENOENT;\n\t}\n\n\tspin_unlock_irqrestore(&ofdpa->neigh_tbl_lock, lock_flags);\n\n\tif (err)\n\t\tgoto err_out;\n\n\t \n\n\terr = ofdpa_group_l3_unicast(ofdpa_port, flags,\n\t\t\t\t     entry->index,\n\t\t\t\t     ofdpa_port->dev->dev_addr,\n\t\t\t\t     entry->eth_dst,\n\t\t\t\t     ofdpa_port->internal_vlan_id,\n\t\t\t\t     entry->ttl_check,\n\t\t\t\t     ofdpa_port->pport);\n\tif (err) {\n\t\tnetdev_err(ofdpa_port->dev, \"Error (%d) L3 unicast group index %d\\n\",\n\t\t\t   err, entry->index);\n\t\tgoto err_out;\n\t}\n\n\tif (adding || removing) {\n\t\tgroup_id = ROCKER_GROUP_L3_UNICAST(entry->index);\n\t\terr = ofdpa_flow_tbl_ucast4_routing(ofdpa_port,\n\t\t\t\t\t\t    eth_type, ip_addr,\n\t\t\t\t\t\t    inet_make_mask(32),\n\t\t\t\t\t\t    priority, goto_tbl,\n\t\t\t\t\t\t    group_id, NULL, flags);\n\n\t\tif (err)\n\t\t\tnetdev_err(ofdpa_port->dev, \"Error (%d) /32 unicast route %pI4 group 0x%08x\\n\",\n\t\t\t\t   err, &entry->ip_addr, group_id);\n\t}\n\nerr_out:\n\tif (!adding)\n\t\tkfree(entry);\n\n\treturn err;\n}\n\nstatic int ofdpa_port_ipv4_resolve(struct ofdpa_port *ofdpa_port,\n\t\t\t\t   __be32 ip_addr)\n{\n\tstruct net_device *dev = ofdpa_port->dev;\n\tstruct neighbour *n = __ipv4_neigh_lookup(dev, (__force u32)ip_addr);\n\tint err = 0;\n\n\tif (!n) {\n\t\tn = neigh_create(&arp_tbl, &ip_addr, dev);\n\t\tif (IS_ERR(n))\n\t\t\treturn PTR_ERR(n);\n\t}\n\n\t \n\n\tif (n->nud_state & NUD_VALID)\n\t\terr = ofdpa_port_ipv4_neigh(ofdpa_port, 0,\n\t\t\t\t\t    ip_addr, n->ha);\n\telse\n\t\tneigh_event_send(n, NULL);\n\n\tneigh_release(n);\n\treturn err;\n}\n\nstatic int ofdpa_port_ipv4_nh(struct ofdpa_port *ofdpa_port,\n\t\t\t      int flags, __be32 ip_addr, u32 *index)\n{\n\tstruct ofdpa *ofdpa = ofdpa_port->ofdpa;\n\tstruct ofdpa_neigh_tbl_entry *entry;\n\tstruct ofdpa_neigh_tbl_entry *found;\n\tunsigned long lock_flags;\n\tbool adding = !(flags & OFDPA_OP_FLAG_REMOVE);\n\tbool updating;\n\tbool removing;\n\tbool resolved = true;\n\tint err = 0;\n\n\tentry = kzalloc(sizeof(*entry), GFP_KERNEL);\n\tif (!entry)\n\t\treturn -ENOMEM;\n\n\tspin_lock_irqsave(&ofdpa->neigh_tbl_lock, lock_flags);\n\n\tfound = ofdpa_neigh_tbl_find(ofdpa, ip_addr);\n\n\tupdating = found && adding;\n\tremoving = found && !adding;\n\tadding = !found && adding;\n\n\tif (adding) {\n\t\tentry->ip_addr = ip_addr;\n\t\tentry->dev = ofdpa_port->dev;\n\t\tofdpa_neigh_add(ofdpa, entry);\n\t\t*index = entry->index;\n\t\tresolved = false;\n\t} else if (removing) {\n\t\t*index = found->index;\n\t\tofdpa_neigh_del(found);\n\t} else if (updating) {\n\t\tofdpa_neigh_update(found, NULL, false);\n\t\tresolved = !is_zero_ether_addr(found->eth_dst);\n\t\t*index = found->index;\n\t} else {\n\t\terr = -ENOENT;\n\t}\n\n\tspin_unlock_irqrestore(&ofdpa->neigh_tbl_lock, lock_flags);\n\n\tif (!adding)\n\t\tkfree(entry);\n\n\tif (err)\n\t\treturn err;\n\n\t \n\n\tif (!resolved)\n\t\terr = ofdpa_port_ipv4_resolve(ofdpa_port, ip_addr);\n\n\treturn err;\n}\n\nstatic struct ofdpa_port *ofdpa_port_get(const struct ofdpa *ofdpa,\n\t\t\t\t\t int port_index)\n{\n\tstruct rocker_port *rocker_port;\n\n\trocker_port = ofdpa->rocker->ports[port_index];\n\treturn rocker_port ? rocker_port->wpriv : NULL;\n}\n\nstatic int ofdpa_port_vlan_flood_group(struct ofdpa_port *ofdpa_port,\n\t\t\t\t       int flags, __be16 vlan_id)\n{\n\tstruct ofdpa_port *p;\n\tconst struct ofdpa *ofdpa = ofdpa_port->ofdpa;\n\tunsigned int port_count = ofdpa->rocker->port_count;\n\tu32 group_id = ROCKER_GROUP_L2_FLOOD(vlan_id, 0);\n\tu32 *group_ids;\n\tu8 group_count = 0;\n\tint err = 0;\n\tint i;\n\n\tgroup_ids = kcalloc(port_count, sizeof(u32), GFP_KERNEL);\n\tif (!group_ids)\n\t\treturn -ENOMEM;\n\n\t \n\n\tfor (i = 0; i < port_count; i++) {\n\t\tp = ofdpa_port_get(ofdpa, i);\n\t\tif (!p)\n\t\t\tcontinue;\n\t\tif (!ofdpa_port_is_bridged(p))\n\t\t\tcontinue;\n\t\tif (test_bit(ntohs(vlan_id), p->vlan_bitmap)) {\n\t\t\tgroup_ids[group_count++] =\n\t\t\t\tROCKER_GROUP_L2_INTERFACE(vlan_id, p->pport);\n\t\t}\n\t}\n\n\t \n\tif (group_count == 0)\n\t\tgoto no_ports_in_vlan;\n\n\terr = ofdpa_group_l2_flood(ofdpa_port, flags, vlan_id,\n\t\t\t\t   group_count, group_ids, group_id);\n\tif (err)\n\t\tnetdev_err(ofdpa_port->dev, \"Error (%d) port VLAN l2 flood group\\n\", err);\n\nno_ports_in_vlan:\n\tkfree(group_ids);\n\treturn err;\n}\n\nstatic int ofdpa_port_vlan_l2_groups(struct ofdpa_port *ofdpa_port, int flags,\n\t\t\t\t     __be16 vlan_id, bool pop_vlan)\n{\n\tconst struct ofdpa *ofdpa = ofdpa_port->ofdpa;\n\tunsigned int port_count = ofdpa->rocker->port_count;\n\tstruct ofdpa_port *p;\n\tbool adding = !(flags & OFDPA_OP_FLAG_REMOVE);\n\tu32 out_pport;\n\tint ref = 0;\n\tint err;\n\tint i;\n\n\t \n\n\tif (ofdpa_port->stp_state == BR_STATE_LEARNING ||\n\t    ofdpa_port->stp_state == BR_STATE_FORWARDING) {\n\t\tout_pport = ofdpa_port->pport;\n\t\terr = ofdpa_group_l2_interface(ofdpa_port, flags,\n\t\t\t\t\t       vlan_id, out_pport, pop_vlan);\n\t\tif (err) {\n\t\t\tnetdev_err(ofdpa_port->dev, \"Error (%d) port VLAN l2 group for pport %d\\n\",\n\t\t\t\t   err, out_pport);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\t \n\n\tfor (i = 0; i < port_count; i++) {\n\t\tp = ofdpa_port_get(ofdpa, i);\n\t\tif (p && test_bit(ntohs(vlan_id), p->vlan_bitmap))\n\t\t\tref++;\n\t}\n\n\tif ((!adding || ref != 1) && (adding || ref != 0))\n\t\treturn 0;\n\n\tout_pport = 0;\n\terr = ofdpa_group_l2_interface(ofdpa_port, flags,\n\t\t\t\t       vlan_id, out_pport, pop_vlan);\n\tif (err) {\n\t\tnetdev_err(ofdpa_port->dev, \"Error (%d) port VLAN l2 group for CPU port\\n\", err);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic struct ofdpa_ctrl {\n\tconst u8 *eth_dst;\n\tconst u8 *eth_dst_mask;\n\t__be16 eth_type;\n\tbool acl;\n\tbool bridge;\n\tbool term;\n\tbool copy_to_cpu;\n} ofdpa_ctrls[] = {\n\t[OFDPA_CTRL_LINK_LOCAL_MCAST] = {\n\t\t \n\t\t.eth_dst = ll_mac,\n\t\t.eth_dst_mask = ll_mask,\n\t\t.acl = true,\n\t},\n\t[OFDPA_CTRL_LOCAL_ARP] = {\n\t\t \n\t\t.eth_dst = zero_mac,\n\t\t.eth_dst_mask = zero_mac,\n\t\t.eth_type = htons(ETH_P_ARP),\n\t\t.acl = true,\n\t},\n\t[OFDPA_CTRL_IPV4_MCAST] = {\n\t\t \n\t\t.eth_dst = ipv4_mcast,\n\t\t.eth_dst_mask = ipv4_mask,\n\t\t.eth_type = htons(ETH_P_IP),\n\t\t.term  = true,\n\t\t.copy_to_cpu = true,\n\t},\n\t[OFDPA_CTRL_IPV6_MCAST] = {\n\t\t \n\t\t.eth_dst = ipv6_mcast,\n\t\t.eth_dst_mask = ipv6_mask,\n\t\t.eth_type = htons(ETH_P_IPV6),\n\t\t.term  = true,\n\t\t.copy_to_cpu = true,\n\t},\n\t[OFDPA_CTRL_DFLT_BRIDGING] = {\n\t\t \n\t\t.bridge = true,\n\t\t.copy_to_cpu = true,\n\t},\n\t[OFDPA_CTRL_DFLT_OVS] = {\n\t\t \n\t\t.eth_dst = zero_mac,\n\t\t.eth_dst_mask = zero_mac,\n\t\t.acl = true,\n\t},\n};\n\nstatic int ofdpa_port_ctrl_vlan_acl(struct ofdpa_port *ofdpa_port, int flags,\n\t\t\t\t    const struct ofdpa_ctrl *ctrl, __be16 vlan_id)\n{\n\tu32 in_pport = ofdpa_port->pport;\n\tu32 in_pport_mask = 0xffffffff;\n\tu32 out_pport = 0;\n\tconst u8 *eth_src = NULL;\n\tconst u8 *eth_src_mask = NULL;\n\t__be16 vlan_id_mask = htons(0xffff);\n\tu8 ip_proto = 0;\n\tu8 ip_proto_mask = 0;\n\tu8 ip_tos = 0;\n\tu8 ip_tos_mask = 0;\n\tu32 group_id = ROCKER_GROUP_L2_INTERFACE(vlan_id, out_pport);\n\tint err;\n\n\terr = ofdpa_flow_tbl_acl(ofdpa_port, flags,\n\t\t\t\t in_pport, in_pport_mask,\n\t\t\t\t eth_src, eth_src_mask,\n\t\t\t\t ctrl->eth_dst, ctrl->eth_dst_mask,\n\t\t\t\t ctrl->eth_type,\n\t\t\t\t vlan_id, vlan_id_mask,\n\t\t\t\t ip_proto, ip_proto_mask,\n\t\t\t\t ip_tos, ip_tos_mask,\n\t\t\t\t group_id);\n\n\tif (err)\n\t\tnetdev_err(ofdpa_port->dev, \"Error (%d) ctrl ACL\\n\", err);\n\n\treturn err;\n}\n\nstatic int ofdpa_port_ctrl_vlan_bridge(struct ofdpa_port *ofdpa_port,\n\t\t\t\t       int flags, const struct ofdpa_ctrl *ctrl,\n\t\t\t\t       __be16 vlan_id)\n{\n\tenum rocker_of_dpa_table_id goto_tbl =\n\t\t\tROCKER_OF_DPA_TABLE_ID_ACL_POLICY;\n\tu32 group_id = ROCKER_GROUP_L2_FLOOD(vlan_id, 0);\n\tu32 tunnel_id = 0;\n\tint err;\n\n\tif (!ofdpa_port_is_bridged(ofdpa_port))\n\t\treturn 0;\n\n\terr = ofdpa_flow_tbl_bridge(ofdpa_port, flags,\n\t\t\t\t    ctrl->eth_dst, ctrl->eth_dst_mask,\n\t\t\t\t    vlan_id, tunnel_id,\n\t\t\t\t    goto_tbl, group_id, ctrl->copy_to_cpu);\n\n\tif (err)\n\t\tnetdev_err(ofdpa_port->dev, \"Error (%d) ctrl FLOOD\\n\", err);\n\n\treturn err;\n}\n\nstatic int ofdpa_port_ctrl_vlan_term(struct ofdpa_port *ofdpa_port, int flags,\n\t\t\t\t     const struct ofdpa_ctrl *ctrl, __be16 vlan_id)\n{\n\tu32 in_pport_mask = 0xffffffff;\n\t__be16 vlan_id_mask = htons(0xffff);\n\tint err;\n\n\tif (ntohs(vlan_id) == 0)\n\t\tvlan_id = ofdpa_port->internal_vlan_id;\n\n\terr = ofdpa_flow_tbl_term_mac(ofdpa_port, ofdpa_port->pport, in_pport_mask,\n\t\t\t\t      ctrl->eth_type, ctrl->eth_dst,\n\t\t\t\t      ctrl->eth_dst_mask, vlan_id,\n\t\t\t\t      vlan_id_mask, ctrl->copy_to_cpu,\n\t\t\t\t      flags);\n\n\tif (err)\n\t\tnetdev_err(ofdpa_port->dev, \"Error (%d) ctrl term\\n\", err);\n\n\treturn err;\n}\n\nstatic int ofdpa_port_ctrl_vlan(struct ofdpa_port *ofdpa_port, int flags,\n\t\t\t\tconst struct ofdpa_ctrl *ctrl, __be16 vlan_id)\n{\n\tif (ctrl->acl)\n\t\treturn ofdpa_port_ctrl_vlan_acl(ofdpa_port, flags,\n\t\t\t\t\t\tctrl, vlan_id);\n\tif (ctrl->bridge)\n\t\treturn ofdpa_port_ctrl_vlan_bridge(ofdpa_port, flags,\n\t\t\t\t\t\t   ctrl, vlan_id);\n\n\tif (ctrl->term)\n\t\treturn ofdpa_port_ctrl_vlan_term(ofdpa_port, flags,\n\t\t\t\t\t\t ctrl, vlan_id);\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic int ofdpa_port_ctrl_vlan_add(struct ofdpa_port *ofdpa_port, int flags,\n\t\t\t\t    __be16 vlan_id)\n{\n\tint err = 0;\n\tint i;\n\n\tfor (i = 0; i < OFDPA_CTRL_MAX; i++) {\n\t\tif (ofdpa_port->ctrls[i]) {\n\t\t\terr = ofdpa_port_ctrl_vlan(ofdpa_port, flags,\n\t\t\t\t\t\t   &ofdpa_ctrls[i], vlan_id);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn err;\n}\n\nstatic int ofdpa_port_ctrl(struct ofdpa_port *ofdpa_port, int flags,\n\t\t\t   const struct ofdpa_ctrl *ctrl)\n{\n\tu16 vid;\n\tint err = 0;\n\n\tfor (vid = 1; vid < VLAN_N_VID; vid++) {\n\t\tif (!test_bit(vid, ofdpa_port->vlan_bitmap))\n\t\t\tcontinue;\n\t\terr = ofdpa_port_ctrl_vlan(ofdpa_port, flags,\n\t\t\t\t\t   ctrl, htons(vid));\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nstatic int ofdpa_port_vlan(struct ofdpa_port *ofdpa_port, int flags,\n\t\t\t   u16 vid)\n{\n\tenum rocker_of_dpa_table_id goto_tbl =\n\t\t\tROCKER_OF_DPA_TABLE_ID_TERMINATION_MAC;\n\tu32 in_pport = ofdpa_port->pport;\n\t__be16 vlan_id = htons(vid);\n\t__be16 vlan_id_mask = htons(0xffff);\n\t__be16 internal_vlan_id;\n\tbool untagged;\n\tbool adding = !(flags & OFDPA_OP_FLAG_REMOVE);\n\tint err;\n\n\tinternal_vlan_id = ofdpa_port_vid_to_vlan(ofdpa_port, vid, &untagged);\n\n\tif (adding &&\n\t    test_bit(ntohs(internal_vlan_id), ofdpa_port->vlan_bitmap))\n\t\treturn 0;  \n\telse if (!adding &&\n\t\t !test_bit(ntohs(internal_vlan_id), ofdpa_port->vlan_bitmap))\n\t\treturn 0;  \n\n\tchange_bit(ntohs(internal_vlan_id), ofdpa_port->vlan_bitmap);\n\n\tif (adding) {\n\t\terr = ofdpa_port_ctrl_vlan_add(ofdpa_port, flags,\n\t\t\t\t\t       internal_vlan_id);\n\t\tif (err) {\n\t\t\tnetdev_err(ofdpa_port->dev, \"Error (%d) port ctrl vlan add\\n\", err);\n\t\t\tgoto err_vlan_add;\n\t\t}\n\t}\n\n\terr = ofdpa_port_vlan_l2_groups(ofdpa_port, flags,\n\t\t\t\t\tinternal_vlan_id, untagged);\n\tif (err) {\n\t\tnetdev_err(ofdpa_port->dev, \"Error (%d) port VLAN l2 groups\\n\", err);\n\t\tgoto err_vlan_l2_groups;\n\t}\n\n\terr = ofdpa_port_vlan_flood_group(ofdpa_port, flags,\n\t\t\t\t\t  internal_vlan_id);\n\tif (err) {\n\t\tnetdev_err(ofdpa_port->dev, \"Error (%d) port VLAN l2 flood group\\n\", err);\n\t\tgoto err_flood_group;\n\t}\n\n\terr = ofdpa_flow_tbl_vlan(ofdpa_port, flags,\n\t\t\t\t  in_pport, vlan_id, vlan_id_mask,\n\t\t\t\t  goto_tbl, untagged, internal_vlan_id);\n\tif (err)\n\t\tnetdev_err(ofdpa_port->dev, \"Error (%d) port VLAN table\\n\", err);\n\n\treturn 0;\n\nerr_vlan_add:\nerr_vlan_l2_groups:\nerr_flood_group:\n\tchange_bit(ntohs(internal_vlan_id), ofdpa_port->vlan_bitmap);\n\treturn err;\n}\n\nstatic int ofdpa_port_ig_tbl(struct ofdpa_port *ofdpa_port, int flags)\n{\n\tenum rocker_of_dpa_table_id goto_tbl;\n\tu32 in_pport;\n\tu32 in_pport_mask;\n\tint err;\n\n\t \n\n\tin_pport = 0;\n\tin_pport_mask = 0xffff0000;\n\tgoto_tbl = ROCKER_OF_DPA_TABLE_ID_VLAN;\n\n\terr = ofdpa_flow_tbl_ig_port(ofdpa_port, flags,\n\t\t\t\t     in_pport, in_pport_mask,\n\t\t\t\t     goto_tbl);\n\tif (err)\n\t\tnetdev_err(ofdpa_port->dev, \"Error (%d) ingress port table entry\\n\", err);\n\n\treturn err;\n}\n\nstruct ofdpa_fdb_learn_work {\n\tstruct work_struct work;\n\tstruct ofdpa_port *ofdpa_port;\n\tint flags;\n\tu8 addr[ETH_ALEN];\n\tu16 vid;\n};\n\nstatic void ofdpa_port_fdb_learn_work(struct work_struct *work)\n{\n\tconst struct ofdpa_fdb_learn_work *lw =\n\t\tcontainer_of(work, struct ofdpa_fdb_learn_work, work);\n\tbool removing = (lw->flags & OFDPA_OP_FLAG_REMOVE);\n\tstruct switchdev_notifier_fdb_info info = {};\n\tenum switchdev_notifier_type event;\n\n\tinfo.addr = lw->addr;\n\tinfo.vid = lw->vid;\n\tinfo.offloaded = !removing;\n\tevent = removing ? SWITCHDEV_FDB_DEL_TO_BRIDGE :\n\t\t\t   SWITCHDEV_FDB_ADD_TO_BRIDGE;\n\n\trtnl_lock();\n\tcall_switchdev_notifiers(event, lw->ofdpa_port->dev, &info.info, NULL);\n\trtnl_unlock();\n\n\tkfree(work);\n}\n\nstatic int ofdpa_port_fdb_learn(struct ofdpa_port *ofdpa_port,\n\t\t\t\tint flags, const u8 *addr, __be16 vlan_id)\n{\n\tstruct ofdpa_fdb_learn_work *lw;\n\tenum rocker_of_dpa_table_id goto_tbl =\n\t\t\tROCKER_OF_DPA_TABLE_ID_ACL_POLICY;\n\tu32 out_pport = ofdpa_port->pport;\n\tu32 tunnel_id = 0;\n\tu32 group_id = ROCKER_GROUP_NONE;\n\tbool copy_to_cpu = false;\n\tint err;\n\n\tif (ofdpa_port_is_bridged(ofdpa_port))\n\t\tgroup_id = ROCKER_GROUP_L2_INTERFACE(vlan_id, out_pport);\n\n\tif (!(flags & OFDPA_OP_FLAG_REFRESH)) {\n\t\terr = ofdpa_flow_tbl_bridge(ofdpa_port, flags, addr,\n\t\t\t\t\t    NULL, vlan_id, tunnel_id, goto_tbl,\n\t\t\t\t\t    group_id, copy_to_cpu);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (!ofdpa_port_is_bridged(ofdpa_port))\n\t\treturn 0;\n\n\tif (!(flags & OFDPA_OP_FLAG_LEARNED))\n\t\treturn 0;\n\n\tlw = kzalloc(sizeof(*lw), GFP_ATOMIC);\n\tif (!lw)\n\t\treturn -ENOMEM;\n\n\tINIT_WORK(&lw->work, ofdpa_port_fdb_learn_work);\n\n\tlw->ofdpa_port = ofdpa_port;\n\tlw->flags = flags;\n\tether_addr_copy(lw->addr, addr);\n\tlw->vid = ofdpa_port_vlan_to_vid(ofdpa_port, vlan_id);\n\n\tschedule_work(&lw->work);\n\treturn 0;\n}\n\nstatic struct ofdpa_fdb_tbl_entry *\nofdpa_fdb_tbl_find(const struct ofdpa *ofdpa,\n\t\t   const struct ofdpa_fdb_tbl_entry *match)\n{\n\tstruct ofdpa_fdb_tbl_entry *found;\n\n\thash_for_each_possible(ofdpa->fdb_tbl, found, entry, match->key_crc32)\n\t\tif (memcmp(&found->key, &match->key, sizeof(found->key)) == 0)\n\t\t\treturn found;\n\n\treturn NULL;\n}\n\nstatic int ofdpa_port_fdb(struct ofdpa_port *ofdpa_port,\n\t\t\t  const unsigned char *addr,\n\t\t\t  __be16 vlan_id, int flags)\n{\n\tstruct ofdpa *ofdpa = ofdpa_port->ofdpa;\n\tstruct ofdpa_fdb_tbl_entry *fdb;\n\tstruct ofdpa_fdb_tbl_entry *found;\n\tbool removing = (flags & OFDPA_OP_FLAG_REMOVE);\n\tunsigned long lock_flags;\n\n\tfdb = kzalloc(sizeof(*fdb), GFP_KERNEL);\n\tif (!fdb)\n\t\treturn -ENOMEM;\n\n\tfdb->learned = (flags & OFDPA_OP_FLAG_LEARNED);\n\tfdb->touched = jiffies;\n\tfdb->key.ofdpa_port = ofdpa_port;\n\tether_addr_copy(fdb->key.addr, addr);\n\tfdb->key.vlan_id = vlan_id;\n\tfdb->key_crc32 = crc32(~0, &fdb->key, sizeof(fdb->key));\n\n\tspin_lock_irqsave(&ofdpa->fdb_tbl_lock, lock_flags);\n\n\tfound = ofdpa_fdb_tbl_find(ofdpa, fdb);\n\n\tif (found) {\n\t\tfound->touched = jiffies;\n\t\tif (removing) {\n\t\t\tkfree(fdb);\n\t\t\thash_del(&found->entry);\n\t\t}\n\t} else if (!removing) {\n\t\thash_add(ofdpa->fdb_tbl, &fdb->entry,\n\t\t\t fdb->key_crc32);\n\t}\n\n\tspin_unlock_irqrestore(&ofdpa->fdb_tbl_lock, lock_flags);\n\n\t \n\tif (!found != !removing) {\n\t\tkfree(fdb);\n\t\tif (!found && removing)\n\t\t\treturn 0;\n\t\t \n\t\tflags |= OFDPA_OP_FLAG_REFRESH;\n\t}\n\n\treturn ofdpa_port_fdb_learn(ofdpa_port, flags, addr, vlan_id);\n}\n\nstatic int ofdpa_port_fdb_flush(struct ofdpa_port *ofdpa_port, int flags)\n{\n\tstruct ofdpa *ofdpa = ofdpa_port->ofdpa;\n\tstruct ofdpa_fdb_tbl_entry *found;\n\tunsigned long lock_flags;\n\tstruct hlist_node *tmp;\n\tint bkt;\n\tint err = 0;\n\n\tif (ofdpa_port->stp_state == BR_STATE_LEARNING ||\n\t    ofdpa_port->stp_state == BR_STATE_FORWARDING)\n\t\treturn 0;\n\n\tflags |= OFDPA_OP_FLAG_NOWAIT | OFDPA_OP_FLAG_REMOVE;\n\n\tspin_lock_irqsave(&ofdpa->fdb_tbl_lock, lock_flags);\n\n\thash_for_each_safe(ofdpa->fdb_tbl, bkt, tmp, found, entry) {\n\t\tif (found->key.ofdpa_port != ofdpa_port)\n\t\t\tcontinue;\n\t\tif (!found->learned)\n\t\t\tcontinue;\n\t\terr = ofdpa_port_fdb_learn(ofdpa_port, flags,\n\t\t\t\t\t   found->key.addr,\n\t\t\t\t\t   found->key.vlan_id);\n\t\tif (err)\n\t\t\tgoto err_out;\n\t\thash_del(&found->entry);\n\t}\n\nerr_out:\n\tspin_unlock_irqrestore(&ofdpa->fdb_tbl_lock, lock_flags);\n\n\treturn err;\n}\n\nstatic void ofdpa_fdb_cleanup(struct timer_list *t)\n{\n\tstruct ofdpa *ofdpa = from_timer(ofdpa, t, fdb_cleanup_timer);\n\tstruct ofdpa_port *ofdpa_port;\n\tstruct ofdpa_fdb_tbl_entry *entry;\n\tstruct hlist_node *tmp;\n\tunsigned long next_timer = jiffies + ofdpa->ageing_time;\n\tunsigned long expires;\n\tunsigned long lock_flags;\n\tint flags = OFDPA_OP_FLAG_NOWAIT | OFDPA_OP_FLAG_REMOVE |\n\t\t    OFDPA_OP_FLAG_LEARNED;\n\tint bkt;\n\n\tspin_lock_irqsave(&ofdpa->fdb_tbl_lock, lock_flags);\n\n\thash_for_each_safe(ofdpa->fdb_tbl, bkt, tmp, entry, entry) {\n\t\tif (!entry->learned)\n\t\t\tcontinue;\n\t\tofdpa_port = entry->key.ofdpa_port;\n\t\texpires = entry->touched + ofdpa_port->ageing_time;\n\t\tif (time_before_eq(expires, jiffies)) {\n\t\t\tofdpa_port_fdb_learn(ofdpa_port, flags,\n\t\t\t\t\t     entry->key.addr,\n\t\t\t\t\t     entry->key.vlan_id);\n\t\t\thash_del(&entry->entry);\n\t\t} else if (time_before(expires, next_timer)) {\n\t\t\tnext_timer = expires;\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&ofdpa->fdb_tbl_lock, lock_flags);\n\n\tmod_timer(&ofdpa->fdb_cleanup_timer, round_jiffies_up(next_timer));\n}\n\nstatic int ofdpa_port_router_mac(struct ofdpa_port *ofdpa_port,\n\t\t\t\t int flags, __be16 vlan_id)\n{\n\tu32 in_pport_mask = 0xffffffff;\n\t__be16 eth_type;\n\tconst u8 *dst_mac_mask = ff_mac;\n\t__be16 vlan_id_mask = htons(0xffff);\n\tbool copy_to_cpu = false;\n\tint err;\n\n\tif (ntohs(vlan_id) == 0)\n\t\tvlan_id = ofdpa_port->internal_vlan_id;\n\n\teth_type = htons(ETH_P_IP);\n\terr = ofdpa_flow_tbl_term_mac(ofdpa_port, ofdpa_port->pport,\n\t\t\t\t      in_pport_mask, eth_type,\n\t\t\t\t      ofdpa_port->dev->dev_addr,\n\t\t\t\t      dst_mac_mask, vlan_id, vlan_id_mask,\n\t\t\t\t      copy_to_cpu, flags);\n\tif (err)\n\t\treturn err;\n\n\teth_type = htons(ETH_P_IPV6);\n\terr = ofdpa_flow_tbl_term_mac(ofdpa_port, ofdpa_port->pport,\n\t\t\t\t      in_pport_mask, eth_type,\n\t\t\t\t      ofdpa_port->dev->dev_addr,\n\t\t\t\t      dst_mac_mask, vlan_id, vlan_id_mask,\n\t\t\t\t      copy_to_cpu, flags);\n\n\treturn err;\n}\n\nstatic int ofdpa_port_fwding(struct ofdpa_port *ofdpa_port, int flags)\n{\n\tbool pop_vlan;\n\tu32 out_pport;\n\t__be16 vlan_id;\n\tu16 vid;\n\tint err;\n\n\t \n\n\tif (ofdpa_port->stp_state != BR_STATE_LEARNING &&\n\t    ofdpa_port->stp_state != BR_STATE_FORWARDING)\n\t\tflags |= OFDPA_OP_FLAG_REMOVE;\n\n\tout_pport = ofdpa_port->pport;\n\tfor (vid = 1; vid < VLAN_N_VID; vid++) {\n\t\tif (!test_bit(vid, ofdpa_port->vlan_bitmap))\n\t\t\tcontinue;\n\t\tvlan_id = htons(vid);\n\t\tpop_vlan = ofdpa_vlan_id_is_internal(vlan_id);\n\t\terr = ofdpa_group_l2_interface(ofdpa_port, flags,\n\t\t\t\t\t       vlan_id, out_pport, pop_vlan);\n\t\tif (err) {\n\t\t\tnetdev_err(ofdpa_port->dev, \"Error (%d) port VLAN l2 group for pport %d\\n\",\n\t\t\t\t   err, out_pport);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int ofdpa_port_stp_update(struct ofdpa_port *ofdpa_port,\n\t\t\t\t int flags, u8 state)\n{\n\tbool want[OFDPA_CTRL_MAX] = { 0, };\n\tbool prev_ctrls[OFDPA_CTRL_MAX];\n\tu8 prev_state;\n\tint err;\n\tint i;\n\n\tmemcpy(prev_ctrls, ofdpa_port->ctrls, sizeof(prev_ctrls));\n\tprev_state = ofdpa_port->stp_state;\n\n\tif (ofdpa_port->stp_state == state)\n\t\treturn 0;\n\n\tofdpa_port->stp_state = state;\n\n\tswitch (state) {\n\tcase BR_STATE_DISABLED:\n\t\t \n\t\tbreak;\n\tcase BR_STATE_LISTENING:\n\tcase BR_STATE_BLOCKING:\n\t\twant[OFDPA_CTRL_LINK_LOCAL_MCAST] = true;\n\t\tbreak;\n\tcase BR_STATE_LEARNING:\n\tcase BR_STATE_FORWARDING:\n\t\tif (!ofdpa_port_is_ovsed(ofdpa_port))\n\t\t\twant[OFDPA_CTRL_LINK_LOCAL_MCAST] = true;\n\t\twant[OFDPA_CTRL_IPV4_MCAST] = true;\n\t\twant[OFDPA_CTRL_IPV6_MCAST] = true;\n\t\tif (ofdpa_port_is_bridged(ofdpa_port))\n\t\t\twant[OFDPA_CTRL_DFLT_BRIDGING] = true;\n\t\telse if (ofdpa_port_is_ovsed(ofdpa_port))\n\t\t\twant[OFDPA_CTRL_DFLT_OVS] = true;\n\t\telse\n\t\t\twant[OFDPA_CTRL_LOCAL_ARP] = true;\n\t\tbreak;\n\t}\n\n\tfor (i = 0; i < OFDPA_CTRL_MAX; i++) {\n\t\tif (want[i] != ofdpa_port->ctrls[i]) {\n\t\t\tint ctrl_flags = flags |\n\t\t\t\t\t (want[i] ? 0 : OFDPA_OP_FLAG_REMOVE);\n\t\t\terr = ofdpa_port_ctrl(ofdpa_port, ctrl_flags,\n\t\t\t\t\t      &ofdpa_ctrls[i]);\n\t\t\tif (err)\n\t\t\t\tgoto err_port_ctrl;\n\t\t\tofdpa_port->ctrls[i] = want[i];\n\t\t}\n\t}\n\n\terr = ofdpa_port_fdb_flush(ofdpa_port, flags);\n\tif (err)\n\t\tgoto err_fdb_flush;\n\n\terr = ofdpa_port_fwding(ofdpa_port, flags);\n\tif (err)\n\t\tgoto err_port_fwding;\n\n\treturn 0;\n\nerr_port_ctrl:\nerr_fdb_flush:\nerr_port_fwding:\n\tmemcpy(ofdpa_port->ctrls, prev_ctrls, sizeof(prev_ctrls));\n\tofdpa_port->stp_state = prev_state;\n\treturn err;\n}\n\nstatic int ofdpa_port_fwd_enable(struct ofdpa_port *ofdpa_port, int flags)\n{\n\tif (ofdpa_port_is_bridged(ofdpa_port))\n\t\t \n\t\treturn 0;\n\n\t \n\treturn ofdpa_port_stp_update(ofdpa_port, flags,\n\t\t\t\t     BR_STATE_FORWARDING);\n}\n\nstatic int ofdpa_port_fwd_disable(struct ofdpa_port *ofdpa_port, int flags)\n{\n\tif (ofdpa_port_is_bridged(ofdpa_port))\n\t\t \n\t\treturn 0;\n\n\t \n\treturn ofdpa_port_stp_update(ofdpa_port, flags,\n\t\t\t\t     BR_STATE_DISABLED);\n}\n\nstatic int ofdpa_port_vlan_add(struct ofdpa_port *ofdpa_port,\n\t\t\t       u16 vid, u16 flags)\n{\n\tint err;\n\n\t \n\n\terr = ofdpa_port_vlan(ofdpa_port, 0, vid);\n\tif (err)\n\t\treturn err;\n\n\terr = ofdpa_port_router_mac(ofdpa_port, 0, htons(vid));\n\tif (err)\n\t\tofdpa_port_vlan(ofdpa_port,\n\t\t\t\tOFDPA_OP_FLAG_REMOVE, vid);\n\n\treturn err;\n}\n\nstatic int ofdpa_port_vlan_del(struct ofdpa_port *ofdpa_port,\n\t\t\t       u16 vid, u16 flags)\n{\n\tint err;\n\n\terr = ofdpa_port_router_mac(ofdpa_port, OFDPA_OP_FLAG_REMOVE,\n\t\t\t\t    htons(vid));\n\tif (err)\n\t\treturn err;\n\n\treturn ofdpa_port_vlan(ofdpa_port, OFDPA_OP_FLAG_REMOVE,\n\t\t\t       vid);\n}\n\nstatic struct ofdpa_internal_vlan_tbl_entry *\nofdpa_internal_vlan_tbl_find(const struct ofdpa *ofdpa, int ifindex)\n{\n\tstruct ofdpa_internal_vlan_tbl_entry *found;\n\n\thash_for_each_possible(ofdpa->internal_vlan_tbl, found,\n\t\t\t       entry, ifindex) {\n\t\tif (found->ifindex == ifindex)\n\t\t\treturn found;\n\t}\n\n\treturn NULL;\n}\n\nstatic __be16 ofdpa_port_internal_vlan_id_get(struct ofdpa_port *ofdpa_port,\n\t\t\t\t\t      int ifindex)\n{\n\tstruct ofdpa *ofdpa = ofdpa_port->ofdpa;\n\tstruct ofdpa_internal_vlan_tbl_entry *entry;\n\tstruct ofdpa_internal_vlan_tbl_entry *found;\n\tunsigned long lock_flags;\n\tint i;\n\n\tentry = kzalloc(sizeof(*entry), GFP_KERNEL);\n\tif (!entry)\n\t\treturn 0;\n\n\tentry->ifindex = ifindex;\n\n\tspin_lock_irqsave(&ofdpa->internal_vlan_tbl_lock, lock_flags);\n\n\tfound = ofdpa_internal_vlan_tbl_find(ofdpa, ifindex);\n\tif (found) {\n\t\tkfree(entry);\n\t\tgoto found;\n\t}\n\n\tfound = entry;\n\thash_add(ofdpa->internal_vlan_tbl, &found->entry, found->ifindex);\n\n\tfor (i = 0; i < OFDPA_N_INTERNAL_VLANS; i++) {\n\t\tif (test_and_set_bit(i, ofdpa->internal_vlan_bitmap))\n\t\t\tcontinue;\n\t\tfound->vlan_id = htons(OFDPA_INTERNAL_VLAN_ID_BASE + i);\n\t\tgoto found;\n\t}\n\n\tnetdev_err(ofdpa_port->dev, \"Out of internal VLAN IDs\\n\");\n\nfound:\n\tfound->ref_count++;\n\tspin_unlock_irqrestore(&ofdpa->internal_vlan_tbl_lock, lock_flags);\n\n\treturn found->vlan_id;\n}\n\nstatic int ofdpa_port_fib_ipv4(struct ofdpa_port *ofdpa_port,  __be32 dst,\n\t\t\t       int dst_len, struct fib_info *fi, u32 tb_id,\n\t\t\t       int flags)\n{\n\tconst struct fib_nh *nh;\n\t__be16 eth_type = htons(ETH_P_IP);\n\t__be32 dst_mask = inet_make_mask(dst_len);\n\t__be16 internal_vlan_id = ofdpa_port->internal_vlan_id;\n\tu32 priority = fi->fib_priority;\n\tenum rocker_of_dpa_table_id goto_tbl =\n\t\tROCKER_OF_DPA_TABLE_ID_ACL_POLICY;\n\tu32 group_id;\n\tbool nh_on_port;\n\tbool has_gw;\n\tu32 index;\n\tint err;\n\n\t \n\n\tnh = fib_info_nh(fi, 0);\n\tnh_on_port = (nh->fib_nh_dev == ofdpa_port->dev);\n\thas_gw = !!nh->fib_nh_gw4;\n\n\tif (has_gw && nh_on_port) {\n\t\terr = ofdpa_port_ipv4_nh(ofdpa_port, flags,\n\t\t\t\t\t nh->fib_nh_gw4, &index);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tgroup_id = ROCKER_GROUP_L3_UNICAST(index);\n\t} else {\n\t\t \n\t\tgroup_id = ROCKER_GROUP_L2_INTERFACE(internal_vlan_id, 0);\n\t}\n\n\terr = ofdpa_flow_tbl_ucast4_routing(ofdpa_port, eth_type, dst,\n\t\t\t\t\t    dst_mask, priority, goto_tbl,\n\t\t\t\t\t    group_id, fi, flags);\n\tif (err)\n\t\tnetdev_err(ofdpa_port->dev, \"Error (%d) IPv4 route %pI4\\n\",\n\t\t\t   err, &dst);\n\n\treturn err;\n}\n\nstatic void\nofdpa_port_internal_vlan_id_put(const struct ofdpa_port *ofdpa_port,\n\t\t\t\tint ifindex)\n{\n\tstruct ofdpa *ofdpa = ofdpa_port->ofdpa;\n\tstruct ofdpa_internal_vlan_tbl_entry *found;\n\tunsigned long lock_flags;\n\tunsigned long bit;\n\n\tspin_lock_irqsave(&ofdpa->internal_vlan_tbl_lock, lock_flags);\n\n\tfound = ofdpa_internal_vlan_tbl_find(ofdpa, ifindex);\n\tif (!found) {\n\t\tnetdev_err(ofdpa_port->dev,\n\t\t\t   \"ifindex (%d) not found in internal VLAN tbl\\n\",\n\t\t\t   ifindex);\n\t\tgoto not_found;\n\t}\n\n\tif (--found->ref_count <= 0) {\n\t\tbit = ntohs(found->vlan_id) - OFDPA_INTERNAL_VLAN_ID_BASE;\n\t\tclear_bit(bit, ofdpa->internal_vlan_bitmap);\n\t\thash_del(&found->entry);\n\t\tkfree(found);\n\t}\n\nnot_found:\n\tspin_unlock_irqrestore(&ofdpa->internal_vlan_tbl_lock, lock_flags);\n}\n\n \n\nstatic int ofdpa_init(struct rocker *rocker)\n{\n\tstruct ofdpa *ofdpa = rocker->wpriv;\n\n\tofdpa->rocker = rocker;\n\n\thash_init(ofdpa->flow_tbl);\n\tspin_lock_init(&ofdpa->flow_tbl_lock);\n\n\thash_init(ofdpa->group_tbl);\n\tspin_lock_init(&ofdpa->group_tbl_lock);\n\n\thash_init(ofdpa->fdb_tbl);\n\tspin_lock_init(&ofdpa->fdb_tbl_lock);\n\n\thash_init(ofdpa->internal_vlan_tbl);\n\tspin_lock_init(&ofdpa->internal_vlan_tbl_lock);\n\n\thash_init(ofdpa->neigh_tbl);\n\tspin_lock_init(&ofdpa->neigh_tbl_lock);\n\n\ttimer_setup(&ofdpa->fdb_cleanup_timer, ofdpa_fdb_cleanup, 0);\n\tmod_timer(&ofdpa->fdb_cleanup_timer, jiffies);\n\n\tofdpa->ageing_time = BR_DEFAULT_AGEING_TIME;\n\n\treturn 0;\n}\n\nstatic void ofdpa_fini(struct rocker *rocker)\n{\n\tstruct ofdpa *ofdpa = rocker->wpriv;\n\n\tunsigned long flags;\n\tstruct ofdpa_flow_tbl_entry *flow_entry;\n\tstruct ofdpa_group_tbl_entry *group_entry;\n\tstruct ofdpa_fdb_tbl_entry *fdb_entry;\n\tstruct ofdpa_internal_vlan_tbl_entry *internal_vlan_entry;\n\tstruct ofdpa_neigh_tbl_entry *neigh_entry;\n\tstruct hlist_node *tmp;\n\tint bkt;\n\n\tdel_timer_sync(&ofdpa->fdb_cleanup_timer);\n\tflush_workqueue(rocker->rocker_owq);\n\n\tspin_lock_irqsave(&ofdpa->flow_tbl_lock, flags);\n\thash_for_each_safe(ofdpa->flow_tbl, bkt, tmp, flow_entry, entry)\n\t\thash_del(&flow_entry->entry);\n\tspin_unlock_irqrestore(&ofdpa->flow_tbl_lock, flags);\n\n\tspin_lock_irqsave(&ofdpa->group_tbl_lock, flags);\n\thash_for_each_safe(ofdpa->group_tbl, bkt, tmp, group_entry, entry)\n\t\thash_del(&group_entry->entry);\n\tspin_unlock_irqrestore(&ofdpa->group_tbl_lock, flags);\n\n\tspin_lock_irqsave(&ofdpa->fdb_tbl_lock, flags);\n\thash_for_each_safe(ofdpa->fdb_tbl, bkt, tmp, fdb_entry, entry)\n\t\thash_del(&fdb_entry->entry);\n\tspin_unlock_irqrestore(&ofdpa->fdb_tbl_lock, flags);\n\n\tspin_lock_irqsave(&ofdpa->internal_vlan_tbl_lock, flags);\n\thash_for_each_safe(ofdpa->internal_vlan_tbl, bkt,\n\t\t\t   tmp, internal_vlan_entry, entry)\n\t\thash_del(&internal_vlan_entry->entry);\n\tspin_unlock_irqrestore(&ofdpa->internal_vlan_tbl_lock, flags);\n\n\tspin_lock_irqsave(&ofdpa->neigh_tbl_lock, flags);\n\thash_for_each_safe(ofdpa->neigh_tbl, bkt, tmp, neigh_entry, entry)\n\t\thash_del(&neigh_entry->entry);\n\tspin_unlock_irqrestore(&ofdpa->neigh_tbl_lock, flags);\n}\n\nstatic int ofdpa_port_pre_init(struct rocker_port *rocker_port)\n{\n\tstruct ofdpa_port *ofdpa_port = rocker_port->wpriv;\n\n\tofdpa_port->ofdpa = rocker_port->rocker->wpriv;\n\tofdpa_port->rocker_port = rocker_port;\n\tofdpa_port->dev = rocker_port->dev;\n\tofdpa_port->pport = rocker_port->pport;\n\tofdpa_port->brport_flags = BR_LEARNING;\n\tofdpa_port->ageing_time = BR_DEFAULT_AGEING_TIME;\n\treturn 0;\n}\n\nstatic int ofdpa_port_init(struct rocker_port *rocker_port)\n{\n\tstruct ofdpa_port *ofdpa_port = rocker_port->wpriv;\n\tint err;\n\n\trocker_port_set_learning(rocker_port,\n\t\t\t\t !!(ofdpa_port->brport_flags & BR_LEARNING));\n\n\terr = ofdpa_port_ig_tbl(ofdpa_port, 0);\n\tif (err) {\n\t\tnetdev_err(ofdpa_port->dev, \"install ig port table failed\\n\");\n\t\treturn err;\n\t}\n\n\tofdpa_port->internal_vlan_id =\n\t\tofdpa_port_internal_vlan_id_get(ofdpa_port,\n\t\t\t\t\t\tofdpa_port->dev->ifindex);\n\n\terr = ofdpa_port_vlan_add(ofdpa_port, OFDPA_UNTAGGED_VID, 0);\n\tif (err) {\n\t\tnetdev_err(ofdpa_port->dev, \"install untagged VLAN failed\\n\");\n\t\tgoto err_untagged_vlan;\n\t}\n\treturn 0;\n\nerr_untagged_vlan:\n\tofdpa_port_ig_tbl(ofdpa_port, OFDPA_OP_FLAG_REMOVE);\n\treturn err;\n}\n\nstatic void ofdpa_port_fini(struct rocker_port *rocker_port)\n{\n\tstruct ofdpa_port *ofdpa_port = rocker_port->wpriv;\n\n\tofdpa_port_ig_tbl(ofdpa_port, OFDPA_OP_FLAG_REMOVE);\n}\n\nstatic int ofdpa_port_open(struct rocker_port *rocker_port)\n{\n\tstruct ofdpa_port *ofdpa_port = rocker_port->wpriv;\n\n\treturn ofdpa_port_fwd_enable(ofdpa_port, 0);\n}\n\nstatic void ofdpa_port_stop(struct rocker_port *rocker_port)\n{\n\tstruct ofdpa_port *ofdpa_port = rocker_port->wpriv;\n\n\tofdpa_port_fwd_disable(ofdpa_port, OFDPA_OP_FLAG_NOWAIT);\n}\n\nstatic int ofdpa_port_attr_stp_state_set(struct rocker_port *rocker_port,\n\t\t\t\t\t u8 state)\n{\n\tstruct ofdpa_port *ofdpa_port = rocker_port->wpriv;\n\n\treturn ofdpa_port_stp_update(ofdpa_port, 0, state);\n}\n\nstatic int ofdpa_port_attr_bridge_flags_set(struct rocker_port *rocker_port,\n\t\t\t\t\t    unsigned long brport_flags)\n{\n\tstruct ofdpa_port *ofdpa_port = rocker_port->wpriv;\n\tunsigned long orig_flags;\n\tint err = 0;\n\n\torig_flags = ofdpa_port->brport_flags;\n\tofdpa_port->brport_flags = brport_flags;\n\n\tif ((orig_flags ^ ofdpa_port->brport_flags) & BR_LEARNING)\n\t\terr = rocker_port_set_learning(ofdpa_port->rocker_port,\n\t\t\t\t\t       !!(ofdpa_port->brport_flags & BR_LEARNING));\n\n\treturn err;\n}\n\nstatic int\nofdpa_port_attr_bridge_flags_support_get(const struct rocker_port *\n\t\t\t\t\t rocker_port,\n\t\t\t\t\t unsigned long *\n\t\t\t\t\t p_brport_flags_support)\n{\n\t*p_brport_flags_support = BR_LEARNING;\n\treturn 0;\n}\n\nstatic int\nofdpa_port_attr_bridge_ageing_time_set(struct rocker_port *rocker_port,\n\t\t\t\t       u32 ageing_time)\n{\n\tstruct ofdpa_port *ofdpa_port = rocker_port->wpriv;\n\tstruct ofdpa *ofdpa = ofdpa_port->ofdpa;\n\n\tofdpa_port->ageing_time = clock_t_to_jiffies(ageing_time);\n\tif (ofdpa_port->ageing_time < ofdpa->ageing_time)\n\t\tofdpa->ageing_time = ofdpa_port->ageing_time;\n\tmod_timer(&ofdpa_port->ofdpa->fdb_cleanup_timer, jiffies);\n\n\treturn 0;\n}\n\nstatic int ofdpa_port_obj_vlan_add(struct rocker_port *rocker_port,\n\t\t\t\t   const struct switchdev_obj_port_vlan *vlan)\n{\n\tstruct ofdpa_port *ofdpa_port = rocker_port->wpriv;\n\n\treturn ofdpa_port_vlan_add(ofdpa_port, vlan->vid, vlan->flags);\n}\n\nstatic int ofdpa_port_obj_vlan_del(struct rocker_port *rocker_port,\n\t\t\t\t   const struct switchdev_obj_port_vlan *vlan)\n{\n\tstruct ofdpa_port *ofdpa_port = rocker_port->wpriv;\n\n\treturn ofdpa_port_vlan_del(ofdpa_port, vlan->vid, vlan->flags);\n}\n\nstatic int ofdpa_port_obj_fdb_add(struct rocker_port *rocker_port,\n\t\t\t\t  u16 vid, const unsigned char *addr)\n{\n\tstruct ofdpa_port *ofdpa_port = rocker_port->wpriv;\n\t__be16 vlan_id = ofdpa_port_vid_to_vlan(ofdpa_port, vid, NULL);\n\n\tif (!ofdpa_port_is_bridged(ofdpa_port))\n\t\treturn -EINVAL;\n\n\treturn ofdpa_port_fdb(ofdpa_port, addr, vlan_id, 0);\n}\n\nstatic int ofdpa_port_obj_fdb_del(struct rocker_port *rocker_port,\n\t\t\t\t  u16 vid, const unsigned char *addr)\n{\n\tstruct ofdpa_port *ofdpa_port = rocker_port->wpriv;\n\t__be16 vlan_id = ofdpa_port_vid_to_vlan(ofdpa_port, vid, NULL);\n\tint flags = OFDPA_OP_FLAG_REMOVE;\n\n\tif (!ofdpa_port_is_bridged(ofdpa_port))\n\t\treturn -EINVAL;\n\n\treturn ofdpa_port_fdb(ofdpa_port, addr, vlan_id, flags);\n}\n\nstatic int ofdpa_port_bridge_join(struct ofdpa_port *ofdpa_port,\n\t\t\t\t  struct net_device *bridge,\n\t\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct net_device *dev = ofdpa_port->dev;\n\tint err;\n\n\t \n\n\terr = ofdpa_port_vlan_del(ofdpa_port, OFDPA_UNTAGGED_VID, 0);\n\tif (err)\n\t\treturn err;\n\n\tofdpa_port_internal_vlan_id_put(ofdpa_port,\n\t\t\t\t\tofdpa_port->dev->ifindex);\n\tofdpa_port->internal_vlan_id =\n\t\tofdpa_port_internal_vlan_id_get(ofdpa_port, bridge->ifindex);\n\n\tofdpa_port->bridge_dev = bridge;\n\n\terr = ofdpa_port_vlan_add(ofdpa_port, OFDPA_UNTAGGED_VID, 0);\n\tif (err)\n\t\treturn err;\n\n\treturn switchdev_bridge_port_offload(dev, dev, NULL, NULL, NULL,\n\t\t\t\t\t     false, extack);\n}\n\nstatic int ofdpa_port_bridge_leave(struct ofdpa_port *ofdpa_port)\n{\n\tstruct net_device *dev = ofdpa_port->dev;\n\tint err;\n\n\tswitchdev_bridge_port_unoffload(dev, NULL, NULL, NULL);\n\n\terr = ofdpa_port_vlan_del(ofdpa_port, OFDPA_UNTAGGED_VID, 0);\n\tif (err)\n\t\treturn err;\n\n\tofdpa_port_internal_vlan_id_put(ofdpa_port,\n\t\t\t\t\tofdpa_port->bridge_dev->ifindex);\n\tofdpa_port->internal_vlan_id =\n\t\tofdpa_port_internal_vlan_id_get(ofdpa_port,\n\t\t\t\t\t\tofdpa_port->dev->ifindex);\n\n\tofdpa_port->bridge_dev = NULL;\n\n\terr = ofdpa_port_vlan_add(ofdpa_port, OFDPA_UNTAGGED_VID, 0);\n\tif (err)\n\t\treturn err;\n\n\tif (ofdpa_port->dev->flags & IFF_UP)\n\t\terr = ofdpa_port_fwd_enable(ofdpa_port, 0);\n\n\treturn err;\n}\n\nstatic int ofdpa_port_ovs_changed(struct ofdpa_port *ofdpa_port,\n\t\t\t\t  struct net_device *master)\n{\n\tint err;\n\n\tofdpa_port->bridge_dev = master;\n\n\terr = ofdpa_port_fwd_disable(ofdpa_port, 0);\n\tif (err)\n\t\treturn err;\n\terr = ofdpa_port_fwd_enable(ofdpa_port, 0);\n\n\treturn err;\n}\n\nstatic int ofdpa_port_master_linked(struct rocker_port *rocker_port,\n\t\t\t\t    struct net_device *master,\n\t\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct ofdpa_port *ofdpa_port = rocker_port->wpriv;\n\tint err = 0;\n\n\tif (netif_is_bridge_master(master))\n\t\terr = ofdpa_port_bridge_join(ofdpa_port, master, extack);\n\telse if (netif_is_ovs_master(master))\n\t\terr = ofdpa_port_ovs_changed(ofdpa_port, master);\n\treturn err;\n}\n\nstatic int ofdpa_port_master_unlinked(struct rocker_port *rocker_port,\n\t\t\t\t      struct net_device *master)\n{\n\tstruct ofdpa_port *ofdpa_port = rocker_port->wpriv;\n\tint err = 0;\n\n\tif (ofdpa_port_is_bridged(ofdpa_port))\n\t\terr = ofdpa_port_bridge_leave(ofdpa_port);\n\telse if (ofdpa_port_is_ovsed(ofdpa_port))\n\t\terr = ofdpa_port_ovs_changed(ofdpa_port, NULL);\n\treturn err;\n}\n\nstatic int ofdpa_port_neigh_update(struct rocker_port *rocker_port,\n\t\t\t\t   struct neighbour *n)\n{\n\tstruct ofdpa_port *ofdpa_port = rocker_port->wpriv;\n\tint flags = (n->nud_state & NUD_VALID ? 0 : OFDPA_OP_FLAG_REMOVE) |\n\t\t\t\t\t\t    OFDPA_OP_FLAG_NOWAIT;\n\t__be32 ip_addr = *(__be32 *) n->primary_key;\n\n\treturn ofdpa_port_ipv4_neigh(ofdpa_port, flags, ip_addr, n->ha);\n}\n\nstatic int ofdpa_port_neigh_destroy(struct rocker_port *rocker_port,\n\t\t\t\t    struct neighbour *n)\n{\n\tstruct ofdpa_port *ofdpa_port = rocker_port->wpriv;\n\tint flags = OFDPA_OP_FLAG_REMOVE | OFDPA_OP_FLAG_NOWAIT;\n\t__be32 ip_addr = *(__be32 *) n->primary_key;\n\n\treturn ofdpa_port_ipv4_neigh(ofdpa_port, flags, ip_addr, n->ha);\n}\n\nstatic int ofdpa_port_ev_mac_vlan_seen(struct rocker_port *rocker_port,\n\t\t\t\t       const unsigned char *addr,\n\t\t\t\t       __be16 vlan_id)\n{\n\tstruct ofdpa_port *ofdpa_port = rocker_port->wpriv;\n\tint flags = OFDPA_OP_FLAG_NOWAIT | OFDPA_OP_FLAG_LEARNED;\n\n\tif (ofdpa_port->stp_state != BR_STATE_LEARNING &&\n\t    ofdpa_port->stp_state != BR_STATE_FORWARDING)\n\t\treturn 0;\n\n\treturn ofdpa_port_fdb(ofdpa_port, addr, vlan_id, flags);\n}\n\nstatic struct ofdpa_port *ofdpa_port_dev_lower_find(struct net_device *dev,\n\t\t\t\t\t\t    struct rocker *rocker)\n{\n\tstruct rocker_port *rocker_port;\n\n\trocker_port = rocker_port_dev_lower_find(dev, rocker);\n\treturn rocker_port ? rocker_port->wpriv : NULL;\n}\n\nstatic int ofdpa_fib4_add(struct rocker *rocker,\n\t\t\t  const struct fib_entry_notifier_info *fen_info)\n{\n\tstruct ofdpa *ofdpa = rocker->wpriv;\n\tstruct ofdpa_port *ofdpa_port;\n\tstruct fib_nh *nh;\n\tint err;\n\n\tif (ofdpa->fib_aborted)\n\t\treturn 0;\n\tnh = fib_info_nh(fen_info->fi, 0);\n\tofdpa_port = ofdpa_port_dev_lower_find(nh->fib_nh_dev, rocker);\n\tif (!ofdpa_port)\n\t\treturn 0;\n\terr = ofdpa_port_fib_ipv4(ofdpa_port, htonl(fen_info->dst),\n\t\t\t\t  fen_info->dst_len, fen_info->fi,\n\t\t\t\t  fen_info->tb_id, 0);\n\tif (err)\n\t\treturn err;\n\tnh->fib_nh_flags |= RTNH_F_OFFLOAD;\n\treturn 0;\n}\n\nstatic int ofdpa_fib4_del(struct rocker *rocker,\n\t\t\t  const struct fib_entry_notifier_info *fen_info)\n{\n\tstruct ofdpa *ofdpa = rocker->wpriv;\n\tstruct ofdpa_port *ofdpa_port;\n\tstruct fib_nh *nh;\n\n\tif (ofdpa->fib_aborted)\n\t\treturn 0;\n\tnh = fib_info_nh(fen_info->fi, 0);\n\tofdpa_port = ofdpa_port_dev_lower_find(nh->fib_nh_dev, rocker);\n\tif (!ofdpa_port)\n\t\treturn 0;\n\tnh->fib_nh_flags &= ~RTNH_F_OFFLOAD;\n\treturn ofdpa_port_fib_ipv4(ofdpa_port, htonl(fen_info->dst),\n\t\t\t\t   fen_info->dst_len, fen_info->fi,\n\t\t\t\t   fen_info->tb_id, OFDPA_OP_FLAG_REMOVE);\n}\n\nstatic void ofdpa_fib4_abort(struct rocker *rocker)\n{\n\tstruct ofdpa *ofdpa = rocker->wpriv;\n\tstruct ofdpa_port *ofdpa_port;\n\tstruct ofdpa_flow_tbl_entry *flow_entry;\n\tstruct hlist_node *tmp;\n\tunsigned long flags;\n\tint bkt;\n\n\tif (ofdpa->fib_aborted)\n\t\treturn;\n\n\tspin_lock_irqsave(&ofdpa->flow_tbl_lock, flags);\n\thash_for_each_safe(ofdpa->flow_tbl, bkt, tmp, flow_entry, entry) {\n\t\tstruct fib_nh *nh;\n\n\t\tif (flow_entry->key.tbl_id !=\n\t\t    ROCKER_OF_DPA_TABLE_ID_UNICAST_ROUTING)\n\t\t\tcontinue;\n\t\tnh = fib_info_nh(flow_entry->fi, 0);\n\t\tofdpa_port = ofdpa_port_dev_lower_find(nh->fib_nh_dev, rocker);\n\t\tif (!ofdpa_port)\n\t\t\tcontinue;\n\t\tnh->fib_nh_flags &= ~RTNH_F_OFFLOAD;\n\t\tofdpa_flow_tbl_del(ofdpa_port,\n\t\t\t\t   OFDPA_OP_FLAG_REMOVE | OFDPA_OP_FLAG_NOWAIT,\n\t\t\t\t   flow_entry);\n\t}\n\tspin_unlock_irqrestore(&ofdpa->flow_tbl_lock, flags);\n\tofdpa->fib_aborted = true;\n}\n\nstruct rocker_world_ops rocker_ofdpa_ops = {\n\t.kind = \"ofdpa\",\n\t.priv_size = sizeof(struct ofdpa),\n\t.port_priv_size = sizeof(struct ofdpa_port),\n\t.mode = ROCKER_PORT_MODE_OF_DPA,\n\t.init = ofdpa_init,\n\t.fini = ofdpa_fini,\n\t.port_pre_init = ofdpa_port_pre_init,\n\t.port_init = ofdpa_port_init,\n\t.port_fini = ofdpa_port_fini,\n\t.port_open = ofdpa_port_open,\n\t.port_stop = ofdpa_port_stop,\n\t.port_attr_stp_state_set = ofdpa_port_attr_stp_state_set,\n\t.port_attr_bridge_flags_set = ofdpa_port_attr_bridge_flags_set,\n\t.port_attr_bridge_flags_support_get = ofdpa_port_attr_bridge_flags_support_get,\n\t.port_attr_bridge_ageing_time_set = ofdpa_port_attr_bridge_ageing_time_set,\n\t.port_obj_vlan_add = ofdpa_port_obj_vlan_add,\n\t.port_obj_vlan_del = ofdpa_port_obj_vlan_del,\n\t.port_obj_fdb_add = ofdpa_port_obj_fdb_add,\n\t.port_obj_fdb_del = ofdpa_port_obj_fdb_del,\n\t.port_master_linked = ofdpa_port_master_linked,\n\t.port_master_unlinked = ofdpa_port_master_unlinked,\n\t.port_neigh_update = ofdpa_port_neigh_update,\n\t.port_neigh_destroy = ofdpa_port_neigh_destroy,\n\t.port_ev_mac_vlan_seen = ofdpa_port_ev_mac_vlan_seen,\n\t.fib4_add = ofdpa_fib4_add,\n\t.fib4_del = ofdpa_fib4_del,\n\t.fib4_abort = ofdpa_fib4_abort,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}