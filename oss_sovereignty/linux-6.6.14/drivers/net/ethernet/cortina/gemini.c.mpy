{
  "module_name": "gemini.c",
  "hash_id": "9e4d7518a36603c78e4222e546a87ff3863e6ecf401a3b1518eb51383a94253b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/cortina/gemini.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/dma-mapping.h>\n#include <linux/cache.h>\n#include <linux/interrupt.h>\n#include <linux/reset.h>\n#include <linux/clk.h>\n#include <linux/of.h>\n#include <linux/of_mdio.h>\n#include <linux/of_net.h>\n#include <linux/of_platform.h>\n#include <linux/etherdevice.h>\n#include <linux/if_vlan.h>\n#include <linux/skbuff.h>\n#include <linux/phy.h>\n#include <linux/crc32.h>\n#include <linux/ethtool.h>\n#include <linux/tcp.h>\n#include <linux/u64_stats_sync.h>\n\n#include <linux/in.h>\n#include <linux/ip.h>\n#include <linux/ipv6.h>\n\n#include \"gemini.h\"\n\n#define DRV_NAME\t\t\"gmac-gemini\"\n\n#define DEFAULT_MSG_ENABLE (NETIF_MSG_DRV | NETIF_MSG_PROBE | NETIF_MSG_LINK)\nstatic int debug = -1;\nmodule_param(debug, int, 0);\nMODULE_PARM_DESC(debug, \"Debug level (0=none,...,16=all)\");\n\n#define HSIZE_8\t\t\t0x00\n#define HSIZE_16\t\t0x01\n#define HSIZE_32\t\t0x02\n\n#define HBURST_SINGLE\t\t0x00\n#define HBURST_INCR\t\t0x01\n#define HBURST_INCR4\t\t0x02\n#define HBURST_INCR8\t\t0x03\n\n#define HPROT_DATA_CACHE\tBIT(0)\n#define HPROT_PRIVILIGED\tBIT(1)\n#define HPROT_BUFFERABLE\tBIT(2)\n#define HPROT_CACHABLE\t\tBIT(3)\n\n#define DEFAULT_RX_COALESCE_NSECS\t0\n#define DEFAULT_GMAC_RXQ_ORDER\t\t9\n#define DEFAULT_GMAC_TXQ_ORDER\t\t8\n#define DEFAULT_RX_BUF_ORDER\t\t11\n#define TX_MAX_FRAGS\t\t\t16\n#define TX_QUEUE_NUM\t\t\t1\t \n#define RX_MAX_ALLOC_ORDER\t\t2\n\n#define GMAC0_IRQ0_2 (GMAC0_TXDERR_INT_BIT | GMAC0_TXPERR_INT_BIT | \\\n\t\t      GMAC0_RXDERR_INT_BIT | GMAC0_RXPERR_INT_BIT)\n#define GMAC0_IRQ0_TXQ0_INTS (GMAC0_SWTQ00_EOF_INT_BIT | \\\n\t\t\t      GMAC0_SWTQ00_FIN_INT_BIT)\n#define GMAC0_IRQ4_8 (GMAC0_MIB_INT_BIT | GMAC0_RX_OVERRUN_INT_BIT)\n\n#define GMAC_OFFLOAD_FEATURES (NETIF_F_SG | NETIF_F_IP_CSUM | \\\n\t\tNETIF_F_IPV6_CSUM | NETIF_F_RXCSUM | \\\n\t\tNETIF_F_TSO | NETIF_F_TSO_ECN | NETIF_F_TSO6)\n\n \nstruct gmac_queue_page {\n\tstruct page *page;\n\tdma_addr_t mapping;\n};\n\nstruct gmac_txq {\n\tstruct gmac_txdesc *ring;\n\tstruct sk_buff\t**skb;\n\tunsigned int\tcptr;\n\tunsigned int\tnoirq_packets;\n};\n\nstruct gemini_ethernet;\n\nstruct gemini_ethernet_port {\n\tu8 id;  \n\n\tstruct gemini_ethernet *geth;\n\tstruct net_device *netdev;\n\tstruct device *dev;\n\tvoid __iomem *dma_base;\n\tvoid __iomem *gmac_base;\n\tstruct clk *pclk;\n\tstruct reset_control *reset;\n\tint irq;\n\t__le32 mac_addr[3];\n\n\tvoid __iomem\t\t*rxq_rwptr;\n\tstruct gmac_rxdesc\t*rxq_ring;\n\tunsigned int\t\trxq_order;\n\n\tstruct napi_struct\tnapi;\n\tstruct hrtimer\t\trx_coalesce_timer;\n\tunsigned int\t\trx_coalesce_nsecs;\n\tunsigned int\t\tfreeq_refill;\n\tstruct gmac_txq\t\ttxq[TX_QUEUE_NUM];\n\tunsigned int\t\ttxq_order;\n\tunsigned int\t\tirq_every_tx_packets;\n\n\tdma_addr_t\t\trxq_dma_base;\n\tdma_addr_t\t\ttxq_dma_base;\n\n\tunsigned int\t\tmsg_enable;\n\tspinlock_t\t\tconfig_lock;  \n\n\tstruct u64_stats_sync\ttx_stats_syncp;\n\tstruct u64_stats_sync\trx_stats_syncp;\n\tstruct u64_stats_sync\tir_stats_syncp;\n\n\tstruct rtnl_link_stats64 stats;\n\tu64\t\t\thw_stats[RX_STATS_NUM];\n\tu64\t\t\trx_stats[RX_STATUS_NUM];\n\tu64\t\t\trx_csum_stats[RX_CHKSUM_NUM];\n\tu64\t\t\trx_napi_exits;\n\tu64\t\t\ttx_frag_stats[TX_MAX_FRAGS];\n\tu64\t\t\ttx_frags_linearized;\n\tu64\t\t\ttx_hw_csummed;\n};\n\nstruct gemini_ethernet {\n\tstruct device *dev;\n\tvoid __iomem *base;\n\tstruct gemini_ethernet_port *port0;\n\tstruct gemini_ethernet_port *port1;\n\tbool initialized;\n\n\tspinlock_t\tirq_lock;  \n\tunsigned int\tfreeq_order;\n\tunsigned int\tfreeq_frag_order;\n\tstruct gmac_rxdesc *freeq_ring;\n\tdma_addr_t\tfreeq_dma_base;\n\tstruct gmac_queue_page\t*freeq_pages;\n\tunsigned int\tnum_freeq_pages;\n\tspinlock_t\tfreeq_lock;  \n};\n\n#define GMAC_STATS_NUM\t( \\\n\tRX_STATS_NUM + RX_STATUS_NUM + RX_CHKSUM_NUM + 1 + \\\n\tTX_MAX_FRAGS + 2)\n\nstatic const char gmac_stats_strings[GMAC_STATS_NUM][ETH_GSTRING_LEN] = {\n\t\"GMAC_IN_DISCARDS\",\n\t\"GMAC_IN_ERRORS\",\n\t\"GMAC_IN_MCAST\",\n\t\"GMAC_IN_BCAST\",\n\t\"GMAC_IN_MAC1\",\n\t\"GMAC_IN_MAC2\",\n\t\"RX_STATUS_GOOD_FRAME\",\n\t\"RX_STATUS_TOO_LONG_GOOD_CRC\",\n\t\"RX_STATUS_RUNT_FRAME\",\n\t\"RX_STATUS_SFD_NOT_FOUND\",\n\t\"RX_STATUS_CRC_ERROR\",\n\t\"RX_STATUS_TOO_LONG_BAD_CRC\",\n\t\"RX_STATUS_ALIGNMENT_ERROR\",\n\t\"RX_STATUS_TOO_LONG_BAD_ALIGN\",\n\t\"RX_STATUS_RX_ERR\",\n\t\"RX_STATUS_DA_FILTERED\",\n\t\"RX_STATUS_BUFFER_FULL\",\n\t\"RX_STATUS_11\",\n\t\"RX_STATUS_12\",\n\t\"RX_STATUS_13\",\n\t\"RX_STATUS_14\",\n\t\"RX_STATUS_15\",\n\t\"RX_CHKSUM_IP_UDP_TCP_OK\",\n\t\"RX_CHKSUM_IP_OK_ONLY\",\n\t\"RX_CHKSUM_NONE\",\n\t\"RX_CHKSUM_3\",\n\t\"RX_CHKSUM_IP_ERR_UNKNOWN\",\n\t\"RX_CHKSUM_IP_ERR\",\n\t\"RX_CHKSUM_TCP_UDP_ERR\",\n\t\"RX_CHKSUM_7\",\n\t\"RX_NAPI_EXITS\",\n\t\"TX_FRAGS[1]\",\n\t\"TX_FRAGS[2]\",\n\t\"TX_FRAGS[3]\",\n\t\"TX_FRAGS[4]\",\n\t\"TX_FRAGS[5]\",\n\t\"TX_FRAGS[6]\",\n\t\"TX_FRAGS[7]\",\n\t\"TX_FRAGS[8]\",\n\t\"TX_FRAGS[9]\",\n\t\"TX_FRAGS[10]\",\n\t\"TX_FRAGS[11]\",\n\t\"TX_FRAGS[12]\",\n\t\"TX_FRAGS[13]\",\n\t\"TX_FRAGS[14]\",\n\t\"TX_FRAGS[15]\",\n\t\"TX_FRAGS[16+]\",\n\t\"TX_FRAGS_LINEARIZED\",\n\t\"TX_HW_CSUMMED\",\n};\n\nstatic void gmac_dump_dma_state(struct net_device *netdev);\n\nstatic void gmac_update_config0_reg(struct net_device *netdev,\n\t\t\t\t    u32 val, u32 vmask)\n{\n\tstruct gemini_ethernet_port *port = netdev_priv(netdev);\n\tunsigned long flags;\n\tu32 reg;\n\n\tspin_lock_irqsave(&port->config_lock, flags);\n\n\treg = readl(port->gmac_base + GMAC_CONFIG0);\n\treg = (reg & ~vmask) | val;\n\twritel(reg, port->gmac_base + GMAC_CONFIG0);\n\n\tspin_unlock_irqrestore(&port->config_lock, flags);\n}\n\nstatic void gmac_enable_tx_rx(struct net_device *netdev)\n{\n\tstruct gemini_ethernet_port *port = netdev_priv(netdev);\n\tunsigned long flags;\n\tu32 reg;\n\n\tspin_lock_irqsave(&port->config_lock, flags);\n\n\treg = readl(port->gmac_base + GMAC_CONFIG0);\n\treg &= ~CONFIG0_TX_RX_DISABLE;\n\twritel(reg, port->gmac_base + GMAC_CONFIG0);\n\n\tspin_unlock_irqrestore(&port->config_lock, flags);\n}\n\nstatic void gmac_disable_tx_rx(struct net_device *netdev)\n{\n\tstruct gemini_ethernet_port *port = netdev_priv(netdev);\n\tunsigned long flags;\n\tu32 val;\n\n\tspin_lock_irqsave(&port->config_lock, flags);\n\n\tval = readl(port->gmac_base + GMAC_CONFIG0);\n\tval |= CONFIG0_TX_RX_DISABLE;\n\twritel(val, port->gmac_base + GMAC_CONFIG0);\n\n\tspin_unlock_irqrestore(&port->config_lock, flags);\n\n\tmdelay(10);\t \n}\n\nstatic void gmac_set_flow_control(struct net_device *netdev, bool tx, bool rx)\n{\n\tstruct gemini_ethernet_port *port = netdev_priv(netdev);\n\tunsigned long flags;\n\tu32 val;\n\n\tspin_lock_irqsave(&port->config_lock, flags);\n\n\tval = readl(port->gmac_base + GMAC_CONFIG0);\n\tval &= ~CONFIG0_FLOW_CTL;\n\tif (tx)\n\t\tval |= CONFIG0_FLOW_TX;\n\tif (rx)\n\t\tval |= CONFIG0_FLOW_RX;\n\twritel(val, port->gmac_base + GMAC_CONFIG0);\n\n\tspin_unlock_irqrestore(&port->config_lock, flags);\n}\n\nstatic void gmac_speed_set(struct net_device *netdev)\n{\n\tstruct gemini_ethernet_port *port = netdev_priv(netdev);\n\tstruct phy_device *phydev = netdev->phydev;\n\tunion gmac_status status, old_status;\n\tint pause_tx = 0;\n\tint pause_rx = 0;\n\n\tstatus.bits32 = readl(port->gmac_base + GMAC_STATUS);\n\told_status.bits32 = status.bits32;\n\tstatus.bits.link = phydev->link;\n\tstatus.bits.duplex = phydev->duplex;\n\n\tswitch (phydev->speed) {\n\tcase 1000:\n\t\tstatus.bits.speed = GMAC_SPEED_1000;\n\t\tif (phy_interface_mode_is_rgmii(phydev->interface))\n\t\t\tstatus.bits.mii_rmii = GMAC_PHY_RGMII_1000;\n\t\tnetdev_dbg(netdev, \"connect %s to RGMII @ 1Gbit\\n\",\n\t\t\t   phydev_name(phydev));\n\t\tbreak;\n\tcase 100:\n\t\tstatus.bits.speed = GMAC_SPEED_100;\n\t\tif (phy_interface_mode_is_rgmii(phydev->interface))\n\t\t\tstatus.bits.mii_rmii = GMAC_PHY_RGMII_100_10;\n\t\tnetdev_dbg(netdev, \"connect %s to RGMII @ 100 Mbit\\n\",\n\t\t\t   phydev_name(phydev));\n\t\tbreak;\n\tcase 10:\n\t\tstatus.bits.speed = GMAC_SPEED_10;\n\t\tif (phy_interface_mode_is_rgmii(phydev->interface))\n\t\t\tstatus.bits.mii_rmii = GMAC_PHY_RGMII_100_10;\n\t\tnetdev_dbg(netdev, \"connect %s to RGMII @ 10 Mbit\\n\",\n\t\t\t   phydev_name(phydev));\n\t\tbreak;\n\tdefault:\n\t\tnetdev_warn(netdev, \"Unsupported PHY speed (%d) on %s\\n\",\n\t\t\t    phydev->speed, phydev_name(phydev));\n\t}\n\n\tif (phydev->duplex == DUPLEX_FULL) {\n\t\tu16 lcladv = phy_read(phydev, MII_ADVERTISE);\n\t\tu16 rmtadv = phy_read(phydev, MII_LPA);\n\t\tu8 cap = mii_resolve_flowctrl_fdx(lcladv, rmtadv);\n\n\t\tif (cap & FLOW_CTRL_RX)\n\t\t\tpause_rx = 1;\n\t\tif (cap & FLOW_CTRL_TX)\n\t\t\tpause_tx = 1;\n\t}\n\n\tgmac_set_flow_control(netdev, pause_tx, pause_rx);\n\n\tif (old_status.bits32 == status.bits32)\n\t\treturn;\n\n\tif (netif_msg_link(port)) {\n\t\tphy_print_status(phydev);\n\t\tnetdev_info(netdev, \"link flow control: %s\\n\",\n\t\t\t    phydev->pause\n\t\t\t    ? (phydev->asym_pause ? \"tx\" : \"both\")\n\t\t\t    : (phydev->asym_pause ? \"rx\" : \"none\")\n\t\t);\n\t}\n\n\tgmac_disable_tx_rx(netdev);\n\twritel(status.bits32, port->gmac_base + GMAC_STATUS);\n\tgmac_enable_tx_rx(netdev);\n}\n\nstatic int gmac_setup_phy(struct net_device *netdev)\n{\n\tstruct gemini_ethernet_port *port = netdev_priv(netdev);\n\tunion gmac_status status = { .bits32 = 0 };\n\tstruct device *dev = port->dev;\n\tstruct phy_device *phy;\n\n\tphy = of_phy_get_and_connect(netdev,\n\t\t\t\t     dev->of_node,\n\t\t\t\t     gmac_speed_set);\n\tif (!phy)\n\t\treturn -ENODEV;\n\tnetdev->phydev = phy;\n\n\tphy_set_max_speed(phy, SPEED_1000);\n\tphy_support_asym_pause(phy);\n\n\t \n\tswitch (phy->interface) {\n\tcase PHY_INTERFACE_MODE_MII:\n\t\tnetdev_dbg(netdev,\n\t\t\t   \"MII: set GMAC0 to GMII mode, GMAC1 disabled\\n\");\n\t\tstatus.bits.mii_rmii = GMAC_PHY_MII;\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_GMII:\n\t\tnetdev_dbg(netdev,\n\t\t\t   \"GMII: set GMAC0 to GMII mode, GMAC1 disabled\\n\");\n\t\tstatus.bits.mii_rmii = GMAC_PHY_GMII;\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_RGMII:\n\tcase PHY_INTERFACE_MODE_RGMII_ID:\n\tcase PHY_INTERFACE_MODE_RGMII_TXID:\n\tcase PHY_INTERFACE_MODE_RGMII_RXID:\n\t\tnetdev_dbg(netdev,\n\t\t\t   \"RGMII: set GMAC0 and GMAC1 to MII/RGMII mode\\n\");\n\t\tstatus.bits.mii_rmii = GMAC_PHY_RGMII_100_10;\n\t\tbreak;\n\tdefault:\n\t\tnetdev_err(netdev, \"Unsupported MII interface\\n\");\n\t\tphy_disconnect(phy);\n\t\tnetdev->phydev = NULL;\n\t\treturn -EINVAL;\n\t}\n\twritel(status.bits32, port->gmac_base + GMAC_STATUS);\n\n\tif (netif_msg_link(port))\n\t\tphy_attached_info(phy);\n\n\treturn 0;\n}\n\n \nstruct gmac_max_framelen {\n\tunsigned int max_l3_len;\n\tu8 val;\n};\n\nstatic const struct gmac_max_framelen gmac_maxlens[] = {\n\t{\n\t\t.max_l3_len = 1518,\n\t\t.val = CONFIG0_MAXLEN_1518,\n\t},\n\t{\n\t\t.max_l3_len = 1522,\n\t\t.val = CONFIG0_MAXLEN_1522,\n\t},\n\t{\n\t\t.max_l3_len = 1536,\n\t\t.val = CONFIG0_MAXLEN_1536,\n\t},\n\t{\n\t\t.max_l3_len = 1548,\n\t\t.val = CONFIG0_MAXLEN_1548,\n\t},\n\t{\n\t\t.max_l3_len = 9212,\n\t\t.val = CONFIG0_MAXLEN_9k,\n\t},\n\t{\n\t\t.max_l3_len = 10236,\n\t\t.val = CONFIG0_MAXLEN_10k,\n\t},\n};\n\nstatic int gmac_pick_rx_max_len(unsigned int max_l3_len)\n{\n\tconst struct gmac_max_framelen *maxlen;\n\tint maxtot;\n\tint i;\n\n\tmaxtot = max_l3_len + ETH_HLEN + VLAN_HLEN;\n\n\tfor (i = 0; i < ARRAY_SIZE(gmac_maxlens); i++) {\n\t\tmaxlen = &gmac_maxlens[i];\n\t\tif (maxtot <= maxlen->max_l3_len)\n\t\t\treturn maxlen->val;\n\t}\n\n\treturn -1;\n}\n\nstatic int gmac_init(struct net_device *netdev)\n{\n\tstruct gemini_ethernet_port *port = netdev_priv(netdev);\n\tunion gmac_config0 config0 = { .bits = {\n\t\t.dis_tx = 1,\n\t\t.dis_rx = 1,\n\t\t.ipv4_rx_chksum = 1,\n\t\t.ipv6_rx_chksum = 1,\n\t\t.rx_err_detect = 1,\n\t\t.rgmm_edge = 1,\n\t\t.port0_chk_hwq = 1,\n\t\t.port1_chk_hwq = 1,\n\t\t.port0_chk_toeq = 1,\n\t\t.port1_chk_toeq = 1,\n\t\t.port0_chk_classq = 1,\n\t\t.port1_chk_classq = 1,\n\t} };\n\tunion gmac_ahb_weight ahb_weight = { .bits = {\n\t\t.rx_weight = 1,\n\t\t.tx_weight = 1,\n\t\t.hash_weight = 1,\n\t\t.pre_req = 0x1f,\n\t\t.tq_dv_threshold = 0,\n\t} };\n\tunion gmac_tx_wcr0 hw_weigh = { .bits = {\n\t\t.hw_tq3 = 1,\n\t\t.hw_tq2 = 1,\n\t\t.hw_tq1 = 1,\n\t\t.hw_tq0 = 1,\n\t} };\n\tunion gmac_tx_wcr1 sw_weigh = { .bits = {\n\t\t.sw_tq5 = 1,\n\t\t.sw_tq4 = 1,\n\t\t.sw_tq3 = 1,\n\t\t.sw_tq2 = 1,\n\t\t.sw_tq1 = 1,\n\t\t.sw_tq0 = 1,\n\t} };\n\tunion gmac_config1 config1 = { .bits = {\n\t\t.set_threshold = 16,\n\t\t.rel_threshold = 24,\n\t} };\n\tunion gmac_config2 config2 = { .bits = {\n\t\t.set_threshold = 16,\n\t\t.rel_threshold = 32,\n\t} };\n\tunion gmac_config3 config3 = { .bits = {\n\t\t.set_threshold = 0,\n\t\t.rel_threshold = 0,\n\t} };\n\tunion gmac_config0 tmp;\n\n\tconfig0.bits.max_len = gmac_pick_rx_max_len(netdev->mtu);\n\ttmp.bits32 = readl(port->gmac_base + GMAC_CONFIG0);\n\tconfig0.bits.reserved = tmp.bits.reserved;\n\twritel(config0.bits32, port->gmac_base + GMAC_CONFIG0);\n\twritel(config1.bits32, port->gmac_base + GMAC_CONFIG1);\n\twritel(config2.bits32, port->gmac_base + GMAC_CONFIG2);\n\twritel(config3.bits32, port->gmac_base + GMAC_CONFIG3);\n\n\treadl(port->dma_base + GMAC_AHB_WEIGHT_REG);\n\twritel(ahb_weight.bits32, port->dma_base + GMAC_AHB_WEIGHT_REG);\n\n\twritel(hw_weigh.bits32,\n\t       port->dma_base + GMAC_TX_WEIGHTING_CTRL_0_REG);\n\twritel(sw_weigh.bits32,\n\t       port->dma_base + GMAC_TX_WEIGHTING_CTRL_1_REG);\n\n\tport->rxq_order = DEFAULT_GMAC_RXQ_ORDER;\n\tport->txq_order = DEFAULT_GMAC_TXQ_ORDER;\n\tport->rx_coalesce_nsecs = DEFAULT_RX_COALESCE_NSECS;\n\n\t \n\tport->irq_every_tx_packets = 1 << (port->txq_order - 2);\n\n\treturn 0;\n}\n\nstatic int gmac_setup_txqs(struct net_device *netdev)\n{\n\tstruct gemini_ethernet_port *port = netdev_priv(netdev);\n\tunsigned int n_txq = netdev->num_tx_queues;\n\tstruct gemini_ethernet *geth = port->geth;\n\tsize_t entries = 1 << port->txq_order;\n\tstruct gmac_txq *txq = port->txq;\n\tstruct gmac_txdesc *desc_ring;\n\tsize_t len = n_txq * entries;\n\tstruct sk_buff **skb_tab;\n\tvoid __iomem *rwptr_reg;\n\tunsigned int r;\n\tint i;\n\n\trwptr_reg = port->dma_base + GMAC_SW_TX_QUEUE0_PTR_REG;\n\n\tskb_tab = kcalloc(len, sizeof(*skb_tab), GFP_KERNEL);\n\tif (!skb_tab)\n\t\treturn -ENOMEM;\n\n\tdesc_ring = dma_alloc_coherent(geth->dev, len * sizeof(*desc_ring),\n\t\t\t\t       &port->txq_dma_base, GFP_KERNEL);\n\n\tif (!desc_ring) {\n\t\tkfree(skb_tab);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (port->txq_dma_base & ~DMA_Q_BASE_MASK) {\n\t\tdev_warn(geth->dev, \"TX queue base is not aligned\\n\");\n\t\tdma_free_coherent(geth->dev, len * sizeof(*desc_ring),\n\t\t\t\t  desc_ring, port->txq_dma_base);\n\t\tkfree(skb_tab);\n\t\treturn -ENOMEM;\n\t}\n\n\twritel(port->txq_dma_base | port->txq_order,\n\t       port->dma_base + GMAC_SW_TX_QUEUE_BASE_REG);\n\n\tfor (i = 0; i < n_txq; i++) {\n\t\ttxq->ring = desc_ring;\n\t\ttxq->skb = skb_tab;\n\t\ttxq->noirq_packets = 0;\n\n\t\tr = readw(rwptr_reg);\n\t\trwptr_reg += 2;\n\t\twritew(r, rwptr_reg);\n\t\trwptr_reg += 2;\n\t\ttxq->cptr = r;\n\n\t\ttxq++;\n\t\tdesc_ring += entries;\n\t\tskb_tab += entries;\n\t}\n\n\treturn 0;\n}\n\nstatic void gmac_clean_txq(struct net_device *netdev, struct gmac_txq *txq,\n\t\t\t   unsigned int r)\n{\n\tstruct gemini_ethernet_port *port = netdev_priv(netdev);\n\tunsigned int m = (1 << port->txq_order) - 1;\n\tstruct gemini_ethernet *geth = port->geth;\n\tunsigned int c = txq->cptr;\n\tunion gmac_txdesc_0 word0;\n\tunion gmac_txdesc_1 word1;\n\tunsigned int hwchksum = 0;\n\tunsigned long bytes = 0;\n\tstruct gmac_txdesc *txd;\n\tunsigned short nfrags;\n\tunsigned int errs = 0;\n\tunsigned int pkts = 0;\n\tunsigned int word3;\n\tdma_addr_t mapping;\n\n\tif (c == r)\n\t\treturn;\n\n\twhile (c != r) {\n\t\ttxd = txq->ring + c;\n\t\tword0 = txd->word0;\n\t\tword1 = txd->word1;\n\t\tmapping = txd->word2.buf_adr;\n\t\tword3 = txd->word3.bits32;\n\n\t\tdma_unmap_single(geth->dev, mapping,\n\t\t\t\t word0.bits.buffer_size, DMA_TO_DEVICE);\n\n\t\tif (word3 & EOF_BIT)\n\t\t\tdev_kfree_skb(txq->skb[c]);\n\n\t\tc++;\n\t\tc &= m;\n\n\t\tif (!(word3 & SOF_BIT))\n\t\t\tcontinue;\n\n\t\tif (!word0.bits.status_tx_ok) {\n\t\t\terrs++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tpkts++;\n\t\tbytes += txd->word1.bits.byte_count;\n\n\t\tif (word1.bits32 & TSS_CHECKUM_ENABLE)\n\t\t\thwchksum++;\n\n\t\tnfrags = word0.bits.desc_count - 1;\n\t\tif (nfrags) {\n\t\t\tif (nfrags >= TX_MAX_FRAGS)\n\t\t\t\tnfrags = TX_MAX_FRAGS - 1;\n\n\t\t\tu64_stats_update_begin(&port->tx_stats_syncp);\n\t\t\tport->tx_frag_stats[nfrags]++;\n\t\t\tu64_stats_update_end(&port->tx_stats_syncp);\n\t\t}\n\t}\n\n\tu64_stats_update_begin(&port->ir_stats_syncp);\n\tport->stats.tx_errors += errs;\n\tport->stats.tx_packets += pkts;\n\tport->stats.tx_bytes += bytes;\n\tport->tx_hw_csummed += hwchksum;\n\tu64_stats_update_end(&port->ir_stats_syncp);\n\n\ttxq->cptr = c;\n}\n\nstatic void gmac_cleanup_txqs(struct net_device *netdev)\n{\n\tstruct gemini_ethernet_port *port = netdev_priv(netdev);\n\tunsigned int n_txq = netdev->num_tx_queues;\n\tstruct gemini_ethernet *geth = port->geth;\n\tvoid __iomem *rwptr_reg;\n\tunsigned int r, i;\n\n\trwptr_reg = port->dma_base + GMAC_SW_TX_QUEUE0_PTR_REG;\n\n\tfor (i = 0; i < n_txq; i++) {\n\t\tr = readw(rwptr_reg);\n\t\trwptr_reg += 2;\n\t\twritew(r, rwptr_reg);\n\t\trwptr_reg += 2;\n\n\t\tgmac_clean_txq(netdev, port->txq + i, r);\n\t}\n\twritel(0, port->dma_base + GMAC_SW_TX_QUEUE_BASE_REG);\n\n\tkfree(port->txq->skb);\n\tdma_free_coherent(geth->dev,\n\t\t\t  n_txq * sizeof(*port->txq->ring) << port->txq_order,\n\t\t\t  port->txq->ring, port->txq_dma_base);\n}\n\nstatic int gmac_setup_rxq(struct net_device *netdev)\n{\n\tstruct gemini_ethernet_port *port = netdev_priv(netdev);\n\tstruct gemini_ethernet *geth = port->geth;\n\tstruct nontoe_qhdr __iomem *qhdr;\n\n\tqhdr = geth->base + TOE_DEFAULT_Q_HDR_BASE(netdev->dev_id);\n\tport->rxq_rwptr = &qhdr->word1;\n\n\t \n\tport->rxq_ring = dma_alloc_coherent(geth->dev,\n\t\t\t\tsizeof(*port->rxq_ring) << port->rxq_order,\n\t\t\t\t&port->rxq_dma_base, GFP_KERNEL);\n\tif (!port->rxq_ring)\n\t\treturn -ENOMEM;\n\tif (port->rxq_dma_base & ~NONTOE_QHDR0_BASE_MASK) {\n\t\tdev_warn(geth->dev, \"RX queue base is not aligned\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\twritel(port->rxq_dma_base | port->rxq_order, &qhdr->word0);\n\twritel(0, port->rxq_rwptr);\n\treturn 0;\n}\n\nstatic struct gmac_queue_page *\ngmac_get_queue_page(struct gemini_ethernet *geth,\n\t\t    struct gemini_ethernet_port *port,\n\t\t    dma_addr_t addr)\n{\n\tstruct gmac_queue_page *gpage;\n\tdma_addr_t mapping;\n\tint i;\n\n\t \n\tmapping = addr & PAGE_MASK;\n\n\tif (!geth->freeq_pages) {\n\t\tdev_err(geth->dev, \"try to get page with no page list\\n\");\n\t\treturn NULL;\n\t}\n\n\t \n\tfor (i = 0; i < geth->num_freeq_pages; i++) {\n\t\tgpage = &geth->freeq_pages[i];\n\t\tif (gpage->mapping == mapping)\n\t\t\treturn gpage;\n\t}\n\n\treturn NULL;\n}\n\nstatic void gmac_cleanup_rxq(struct net_device *netdev)\n{\n\tstruct gemini_ethernet_port *port = netdev_priv(netdev);\n\tstruct gemini_ethernet *geth = port->geth;\n\tstruct gmac_rxdesc *rxd = port->rxq_ring;\n\tstatic struct gmac_queue_page *gpage;\n\tstruct nontoe_qhdr __iomem *qhdr;\n\tvoid __iomem *dma_reg;\n\tvoid __iomem *ptr_reg;\n\tdma_addr_t mapping;\n\tunion dma_rwptr rw;\n\tunsigned int r, w;\n\n\tqhdr = geth->base +\n\t\tTOE_DEFAULT_Q_HDR_BASE(netdev->dev_id);\n\tdma_reg = &qhdr->word0;\n\tptr_reg = &qhdr->word1;\n\n\trw.bits32 = readl(ptr_reg);\n\tr = rw.bits.rptr;\n\tw = rw.bits.wptr;\n\twritew(r, ptr_reg + 2);\n\n\twritel(0, dma_reg);\n\n\t \n\twhile (r != w) {\n\t\tmapping = rxd[r].word2.buf_adr;\n\t\tr++;\n\t\tr &= ((1 << port->rxq_order) - 1);\n\n\t\tif (!mapping)\n\t\t\tcontinue;\n\n\t\t \n\t\tgpage = gmac_get_queue_page(geth, port, mapping + PAGE_SIZE);\n\t\tif (!gpage) {\n\t\t\tdev_err(geth->dev, \"could not find page\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\t \n\t\tput_page(gpage->page);\n\t}\n\n\tdma_free_coherent(geth->dev, sizeof(*port->rxq_ring) << port->rxq_order,\n\t\t\t  port->rxq_ring, port->rxq_dma_base);\n}\n\nstatic struct page *geth_freeq_alloc_map_page(struct gemini_ethernet *geth,\n\t\t\t\t\t      int pn)\n{\n\tstruct gmac_rxdesc *freeq_entry;\n\tstruct gmac_queue_page *gpage;\n\tunsigned int fpp_order;\n\tunsigned int frag_len;\n\tdma_addr_t mapping;\n\tstruct page *page;\n\tint i;\n\n\t \n\tpage = alloc_page(GFP_ATOMIC);\n\tif (!page)\n\t\treturn NULL;\n\n\tmapping = dma_map_single(geth->dev, page_address(page),\n\t\t\t\t PAGE_SIZE, DMA_FROM_DEVICE);\n\tif (dma_mapping_error(geth->dev, mapping)) {\n\t\tput_page(page);\n\t\treturn NULL;\n\t}\n\n\t \n\tfrag_len = 1 << geth->freeq_frag_order;  \n\tfpp_order = PAGE_SHIFT - geth->freeq_frag_order;\n\tfreeq_entry = geth->freeq_ring + (pn << fpp_order);\n\tdev_dbg(geth->dev, \"allocate page %d fragment length %d fragments per page %d, freeq entry %p\\n\",\n\t\t pn, frag_len, (1 << fpp_order), freeq_entry);\n\tfor (i = (1 << fpp_order); i > 0; i--) {\n\t\tfreeq_entry->word2.buf_adr = mapping;\n\t\tfreeq_entry++;\n\t\tmapping += frag_len;\n\t}\n\n\t \n\tgpage = &geth->freeq_pages[pn];\n\tif (gpage->page) {\n\t\tmapping = geth->freeq_ring[pn << fpp_order].word2.buf_adr;\n\t\tdma_unmap_single(geth->dev, mapping, frag_len, DMA_FROM_DEVICE);\n\t\t \n\t\tput_page(gpage->page);\n\t}\n\n\t \n\tdev_dbg(geth->dev, \"page %d, DMA addr: %08x, page %p\\n\",\n\t\tpn, (unsigned int)mapping, page);\n\tgpage->mapping = mapping;\n\tgpage->page = page;\n\n\treturn page;\n}\n\n \nstatic unsigned int geth_fill_freeq(struct gemini_ethernet *geth, bool refill)\n{\n\tunsigned int fpp_order = PAGE_SHIFT - geth->freeq_frag_order;\n\tunsigned int count = 0;\n\tunsigned int pn, epn;\n\tunsigned long flags;\n\tunion dma_rwptr rw;\n\tunsigned int m_pn;\n\n\t \n\tm_pn = (1 << (geth->freeq_order - fpp_order)) - 1;\n\n\tspin_lock_irqsave(&geth->freeq_lock, flags);\n\n\trw.bits32 = readl(geth->base + GLOBAL_SWFQ_RWPTR_REG);\n\tpn = (refill ? rw.bits.wptr : rw.bits.rptr) >> fpp_order;\n\tepn = (rw.bits.rptr >> fpp_order) - 1;\n\tepn &= m_pn;\n\n\t \n\twhile (pn != epn) {\n\t\tstruct gmac_queue_page *gpage;\n\t\tstruct page *page;\n\n\t\tgpage = &geth->freeq_pages[pn];\n\t\tpage = gpage->page;\n\n\t\tdev_dbg(geth->dev, \"fill entry %d page ref count %d add %d refs\\n\",\n\t\t\tpn, page_ref_count(page), 1 << fpp_order);\n\n\t\tif (page_ref_count(page) > 1) {\n\t\t\tunsigned int fl = (pn - epn) & m_pn;\n\n\t\t\tif (fl > 64 >> fpp_order)\n\t\t\t\tbreak;\n\n\t\t\tpage = geth_freeq_alloc_map_page(geth, pn);\n\t\t\tif (!page)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tpage_ref_add(page, 1 << fpp_order);\n\t\tcount += 1 << fpp_order;\n\t\tpn++;\n\t\tpn &= m_pn;\n\t}\n\n\twritew(pn << fpp_order, geth->base + GLOBAL_SWFQ_RWPTR_REG + 2);\n\n\tspin_unlock_irqrestore(&geth->freeq_lock, flags);\n\n\treturn count;\n}\n\nstatic int geth_setup_freeq(struct gemini_ethernet *geth)\n{\n\tunsigned int fpp_order = PAGE_SHIFT - geth->freeq_frag_order;\n\tunsigned int frag_len = 1 << geth->freeq_frag_order;\n\tunsigned int len = 1 << geth->freeq_order;\n\tunsigned int pages = len >> fpp_order;\n\tunion queue_threshold qt;\n\tunion dma_skb_size skbsz;\n\tunsigned int filled;\n\tunsigned int pn;\n\n\tgeth->freeq_ring = dma_alloc_coherent(geth->dev,\n\t\tsizeof(*geth->freeq_ring) << geth->freeq_order,\n\t\t&geth->freeq_dma_base, GFP_KERNEL);\n\tif (!geth->freeq_ring)\n\t\treturn -ENOMEM;\n\tif (geth->freeq_dma_base & ~DMA_Q_BASE_MASK) {\n\t\tdev_warn(geth->dev, \"queue ring base is not aligned\\n\");\n\t\tgoto err_freeq;\n\t}\n\n\t \n\tgeth->freeq_pages = kcalloc(pages, sizeof(*geth->freeq_pages),\n\t\t\t\t    GFP_KERNEL);\n\tif (!geth->freeq_pages)\n\t\tgoto err_freeq;\n\tgeth->num_freeq_pages = pages;\n\n\tdev_info(geth->dev, \"allocate %d pages for queue\\n\", pages);\n\tfor (pn = 0; pn < pages; pn++)\n\t\tif (!geth_freeq_alloc_map_page(geth, pn))\n\t\t\tgoto err_freeq_alloc;\n\n\tfilled = geth_fill_freeq(geth, false);\n\tif (!filled)\n\t\tgoto err_freeq_alloc;\n\n\tqt.bits32 = readl(geth->base + GLOBAL_QUEUE_THRESHOLD_REG);\n\tqt.bits.swfq_empty = 32;\n\twritel(qt.bits32, geth->base + GLOBAL_QUEUE_THRESHOLD_REG);\n\n\tskbsz.bits.sw_skb_size = 1 << geth->freeq_frag_order;\n\twritel(skbsz.bits32, geth->base + GLOBAL_DMA_SKB_SIZE_REG);\n\twritel(geth->freeq_dma_base | geth->freeq_order,\n\t       geth->base + GLOBAL_SW_FREEQ_BASE_SIZE_REG);\n\n\treturn 0;\n\nerr_freeq_alloc:\n\twhile (pn > 0) {\n\t\tstruct gmac_queue_page *gpage;\n\t\tdma_addr_t mapping;\n\n\t\t--pn;\n\t\tmapping = geth->freeq_ring[pn << fpp_order].word2.buf_adr;\n\t\tdma_unmap_single(geth->dev, mapping, frag_len, DMA_FROM_DEVICE);\n\t\tgpage = &geth->freeq_pages[pn];\n\t\tput_page(gpage->page);\n\t}\n\n\tkfree(geth->freeq_pages);\nerr_freeq:\n\tdma_free_coherent(geth->dev,\n\t\t\t  sizeof(*geth->freeq_ring) << geth->freeq_order,\n\t\t\t  geth->freeq_ring, geth->freeq_dma_base);\n\tgeth->freeq_ring = NULL;\n\treturn -ENOMEM;\n}\n\n \nstatic void geth_cleanup_freeq(struct gemini_ethernet *geth)\n{\n\tunsigned int fpp_order = PAGE_SHIFT - geth->freeq_frag_order;\n\tunsigned int frag_len = 1 << geth->freeq_frag_order;\n\tunsigned int len = 1 << geth->freeq_order;\n\tunsigned int pages = len >> fpp_order;\n\tunsigned int pn;\n\n\twritew(readw(geth->base + GLOBAL_SWFQ_RWPTR_REG),\n\t       geth->base + GLOBAL_SWFQ_RWPTR_REG + 2);\n\twritel(0, geth->base + GLOBAL_SW_FREEQ_BASE_SIZE_REG);\n\n\tfor (pn = 0; pn < pages; pn++) {\n\t\tstruct gmac_queue_page *gpage;\n\t\tdma_addr_t mapping;\n\n\t\tmapping = geth->freeq_ring[pn << fpp_order].word2.buf_adr;\n\t\tdma_unmap_single(geth->dev, mapping, frag_len, DMA_FROM_DEVICE);\n\n\t\tgpage = &geth->freeq_pages[pn];\n\t\twhile (page_ref_count(gpage->page) > 0)\n\t\t\tput_page(gpage->page);\n\t}\n\n\tkfree(geth->freeq_pages);\n\n\tdma_free_coherent(geth->dev,\n\t\t\t  sizeof(*geth->freeq_ring) << geth->freeq_order,\n\t\t\t  geth->freeq_ring, geth->freeq_dma_base);\n}\n\n \nstatic int geth_resize_freeq(struct gemini_ethernet_port *port)\n{\n\tstruct gemini_ethernet *geth = port->geth;\n\tstruct net_device *netdev = port->netdev;\n\tstruct gemini_ethernet_port *other_port;\n\tstruct net_device *other_netdev;\n\tunsigned int new_size = 0;\n\tunsigned int new_order;\n\tunsigned long flags;\n\tu32 en;\n\tint ret;\n\n\tif (netdev->dev_id == 0)\n\t\tother_netdev = geth->port1->netdev;\n\telse\n\t\tother_netdev = geth->port0->netdev;\n\n\tif (other_netdev && netif_running(other_netdev))\n\t\treturn -EBUSY;\n\n\tnew_size = 1 << (port->rxq_order + 1);\n\tnetdev_dbg(netdev, \"port %d size: %d order %d\\n\",\n\t\t   netdev->dev_id,\n\t\t   new_size,\n\t\t   port->rxq_order);\n\tif (other_netdev) {\n\t\tother_port = netdev_priv(other_netdev);\n\t\tnew_size += 1 << (other_port->rxq_order + 1);\n\t\tnetdev_dbg(other_netdev, \"port %d size: %d order %d\\n\",\n\t\t\t   other_netdev->dev_id,\n\t\t\t   (1 << (other_port->rxq_order + 1)),\n\t\t\t   other_port->rxq_order);\n\t}\n\n\tnew_order = min(15, ilog2(new_size - 1) + 1);\n\tdev_dbg(geth->dev, \"set shared queue to size %d order %d\\n\",\n\t\tnew_size, new_order);\n\tif (geth->freeq_order == new_order)\n\t\treturn 0;\n\n\tspin_lock_irqsave(&geth->irq_lock, flags);\n\n\t \n\ten = readl(geth->base + GLOBAL_INTERRUPT_ENABLE_4_REG);\n\ten &= ~SWFQ_EMPTY_INT_BIT;\n\twritel(en, geth->base + GLOBAL_INTERRUPT_ENABLE_4_REG);\n\tspin_unlock_irqrestore(&geth->irq_lock, flags);\n\n\t \n\tif (geth->freeq_ring)\n\t\tgeth_cleanup_freeq(geth);\n\n\t \n\tgeth->freeq_order = new_order;\n\tret = geth_setup_freeq(geth);\n\n\t \n\tspin_lock_irqsave(&geth->irq_lock, flags);\n\ten |= SWFQ_EMPTY_INT_BIT;\n\twritel(en, geth->base + GLOBAL_INTERRUPT_ENABLE_4_REG);\n\tspin_unlock_irqrestore(&geth->irq_lock, flags);\n\n\treturn ret;\n}\n\nstatic void gmac_tx_irq_enable(struct net_device *netdev,\n\t\t\t       unsigned int txq, int en)\n{\n\tstruct gemini_ethernet_port *port = netdev_priv(netdev);\n\tstruct gemini_ethernet *geth = port->geth;\n\tu32 val, mask;\n\n\tnetdev_dbg(netdev, \"%s device %d\\n\", __func__, netdev->dev_id);\n\n\tmask = GMAC0_IRQ0_TXQ0_INTS << (6 * netdev->dev_id + txq);\n\n\tif (en)\n\t\twritel(mask, geth->base + GLOBAL_INTERRUPT_STATUS_0_REG);\n\n\tval = readl(geth->base + GLOBAL_INTERRUPT_ENABLE_0_REG);\n\tval = en ? val | mask : val & ~mask;\n\twritel(val, geth->base + GLOBAL_INTERRUPT_ENABLE_0_REG);\n}\n\nstatic void gmac_tx_irq(struct net_device *netdev, unsigned int txq_num)\n{\n\tstruct netdev_queue *ntxq = netdev_get_tx_queue(netdev, txq_num);\n\n\tgmac_tx_irq_enable(netdev, txq_num, 0);\n\tnetif_tx_wake_queue(ntxq);\n}\n\nstatic int gmac_map_tx_bufs(struct net_device *netdev, struct sk_buff *skb,\n\t\t\t    struct gmac_txq *txq, unsigned short *desc)\n{\n\tstruct gemini_ethernet_port *port = netdev_priv(netdev);\n\tstruct skb_shared_info *skb_si =  skb_shinfo(skb);\n\tunsigned short m = (1 << port->txq_order) - 1;\n\tshort frag, last_frag = skb_si->nr_frags - 1;\n\tstruct gemini_ethernet *geth = port->geth;\n\tunsigned int word1, word3, buflen;\n\tunsigned short w = *desc;\n\tstruct gmac_txdesc *txd;\n\tskb_frag_t *skb_frag;\n\tdma_addr_t mapping;\n\tunsigned short mtu;\n\tvoid *buffer;\n\tint ret;\n\n\tmtu  = ETH_HLEN;\n\tmtu += netdev->mtu;\n\tif (skb->protocol == htons(ETH_P_8021Q))\n\t\tmtu += VLAN_HLEN;\n\n\tword1 = skb->len;\n\tword3 = SOF_BIT;\n\n\tif (word1 > mtu) {\n\t\tword1 |= TSS_MTU_ENABLE_BIT;\n\t\tword3 |= mtu;\n\t}\n\n\tif (skb->len >= ETH_FRAME_LEN) {\n\t\t \n\t\tif (skb->ip_summed == CHECKSUM_PARTIAL) {\n\t\t\tret = skb_checksum_help(skb);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t\tword1 |= TSS_BYPASS_BIT;\n\t} else if (skb->ip_summed == CHECKSUM_PARTIAL) {\n\t\tint tcp = 0;\n\n\t\t \n\t\tif (skb->protocol == htons(ETH_P_IP)) {\n\t\t\tword1 |= TSS_IP_CHKSUM_BIT;\n\t\t\ttcp = ip_hdr(skb)->protocol == IPPROTO_TCP;\n\t\t} else {  \n\t\t\tword1 |= TSS_IPV6_ENABLE_BIT;\n\t\t\ttcp = ipv6_hdr(skb)->nexthdr == IPPROTO_TCP;\n\t\t}\n\n\t\tword1 |= tcp ? TSS_TCP_CHKSUM_BIT : TSS_UDP_CHKSUM_BIT;\n\t}\n\n\tfrag = -1;\n\twhile (frag <= last_frag) {\n\t\tif (frag == -1) {\n\t\t\tbuffer = skb->data;\n\t\t\tbuflen = skb_headlen(skb);\n\t\t} else {\n\t\t\tskb_frag = skb_si->frags + frag;\n\t\t\tbuffer = skb_frag_address(skb_frag);\n\t\t\tbuflen = skb_frag_size(skb_frag);\n\t\t}\n\n\t\tif (frag == last_frag) {\n\t\t\tword3 |= EOF_BIT;\n\t\t\ttxq->skb[w] = skb;\n\t\t}\n\n\t\tmapping = dma_map_single(geth->dev, buffer, buflen,\n\t\t\t\t\t DMA_TO_DEVICE);\n\t\tif (dma_mapping_error(geth->dev, mapping))\n\t\t\tgoto map_error;\n\n\t\ttxd = txq->ring + w;\n\t\ttxd->word0.bits32 = buflen;\n\t\ttxd->word1.bits32 = word1;\n\t\ttxd->word2.buf_adr = mapping;\n\t\ttxd->word3.bits32 = word3;\n\n\t\tword3 &= MTU_SIZE_BIT_MASK;\n\t\tw++;\n\t\tw &= m;\n\t\tfrag++;\n\t}\n\n\t*desc = w;\n\treturn 0;\n\nmap_error:\n\twhile (w != *desc) {\n\t\tw--;\n\t\tw &= m;\n\n\t\tdma_unmap_page(geth->dev, txq->ring[w].word2.buf_adr,\n\t\t\t       txq->ring[w].word0.bits.buffer_size,\n\t\t\t       DMA_TO_DEVICE);\n\t}\n\treturn -ENOMEM;\n}\n\nstatic netdev_tx_t gmac_start_xmit(struct sk_buff *skb,\n\t\t\t\t   struct net_device *netdev)\n{\n\tstruct gemini_ethernet_port *port = netdev_priv(netdev);\n\tunsigned short m = (1 << port->txq_order) - 1;\n\tstruct netdev_queue *ntxq;\n\tunsigned short r, w, d;\n\tvoid __iomem *ptr_reg;\n\tstruct gmac_txq *txq;\n\tint txq_num, nfrags;\n\tunion dma_rwptr rw;\n\n\tif (skb->len >= 0x10000)\n\t\tgoto out_drop_free;\n\n\ttxq_num = skb_get_queue_mapping(skb);\n\tptr_reg = port->dma_base + GMAC_SW_TX_QUEUE_PTR_REG(txq_num);\n\ttxq = &port->txq[txq_num];\n\tntxq = netdev_get_tx_queue(netdev, txq_num);\n\tnfrags = skb_shinfo(skb)->nr_frags;\n\n\trw.bits32 = readl(ptr_reg);\n\tr = rw.bits.rptr;\n\tw = rw.bits.wptr;\n\n\td = txq->cptr - w - 1;\n\td &= m;\n\n\tif (d < nfrags + 2) {\n\t\tgmac_clean_txq(netdev, txq, r);\n\t\td = txq->cptr - w - 1;\n\t\td &= m;\n\n\t\tif (d < nfrags + 2) {\n\t\t\tnetif_tx_stop_queue(ntxq);\n\n\t\t\td = txq->cptr + nfrags + 16;\n\t\t\td &= m;\n\t\t\ttxq->ring[d].word3.bits.eofie = 1;\n\t\t\tgmac_tx_irq_enable(netdev, txq_num, 1);\n\n\t\t\tu64_stats_update_begin(&port->tx_stats_syncp);\n\t\t\tnetdev->stats.tx_fifo_errors++;\n\t\t\tu64_stats_update_end(&port->tx_stats_syncp);\n\t\t\treturn NETDEV_TX_BUSY;\n\t\t}\n\t}\n\n\tif (gmac_map_tx_bufs(netdev, skb, txq, &w)) {\n\t\tif (skb_linearize(skb))\n\t\t\tgoto out_drop;\n\n\t\tu64_stats_update_begin(&port->tx_stats_syncp);\n\t\tport->tx_frags_linearized++;\n\t\tu64_stats_update_end(&port->tx_stats_syncp);\n\n\t\tif (gmac_map_tx_bufs(netdev, skb, txq, &w))\n\t\t\tgoto out_drop_free;\n\t}\n\n\twritew(w, ptr_reg + 2);\n\n\tgmac_clean_txq(netdev, txq, r);\n\treturn NETDEV_TX_OK;\n\nout_drop_free:\n\tdev_kfree_skb(skb);\nout_drop:\n\tu64_stats_update_begin(&port->tx_stats_syncp);\n\tport->stats.tx_dropped++;\n\tu64_stats_update_end(&port->tx_stats_syncp);\n\treturn NETDEV_TX_OK;\n}\n\nstatic void gmac_tx_timeout(struct net_device *netdev, unsigned int txqueue)\n{\n\tnetdev_err(netdev, \"Tx timeout\\n\");\n\tgmac_dump_dma_state(netdev);\n}\n\nstatic void gmac_enable_irq(struct net_device *netdev, int enable)\n{\n\tstruct gemini_ethernet_port *port = netdev_priv(netdev);\n\tstruct gemini_ethernet *geth = port->geth;\n\tunsigned long flags;\n\tu32 val, mask;\n\n\tnetdev_dbg(netdev, \"%s device %d %s\\n\", __func__,\n\t\t   netdev->dev_id, enable ? \"enable\" : \"disable\");\n\tspin_lock_irqsave(&geth->irq_lock, flags);\n\n\tmask = GMAC0_IRQ0_2 << (netdev->dev_id * 2);\n\tval = readl(geth->base + GLOBAL_INTERRUPT_ENABLE_0_REG);\n\tval = enable ? (val | mask) : (val & ~mask);\n\twritel(val, geth->base + GLOBAL_INTERRUPT_ENABLE_0_REG);\n\n\tmask = DEFAULT_Q0_INT_BIT << netdev->dev_id;\n\tval = readl(geth->base + GLOBAL_INTERRUPT_ENABLE_1_REG);\n\tval = enable ? (val | mask) : (val & ~mask);\n\twritel(val, geth->base + GLOBAL_INTERRUPT_ENABLE_1_REG);\n\n\tmask = GMAC0_IRQ4_8 << (netdev->dev_id * 8);\n\tval = readl(geth->base + GLOBAL_INTERRUPT_ENABLE_4_REG);\n\tval = enable ? (val | mask) : (val & ~mask);\n\twritel(val, geth->base + GLOBAL_INTERRUPT_ENABLE_4_REG);\n\n\tspin_unlock_irqrestore(&geth->irq_lock, flags);\n}\n\nstatic void gmac_enable_rx_irq(struct net_device *netdev, int enable)\n{\n\tstruct gemini_ethernet_port *port = netdev_priv(netdev);\n\tstruct gemini_ethernet *geth = port->geth;\n\tunsigned long flags;\n\tu32 val, mask;\n\n\tnetdev_dbg(netdev, \"%s device %d %s\\n\", __func__, netdev->dev_id,\n\t\t   enable ? \"enable\" : \"disable\");\n\tspin_lock_irqsave(&geth->irq_lock, flags);\n\tmask = DEFAULT_Q0_INT_BIT << netdev->dev_id;\n\n\tval = readl(geth->base + GLOBAL_INTERRUPT_ENABLE_1_REG);\n\tval = enable ? (val | mask) : (val & ~mask);\n\twritel(val, geth->base + GLOBAL_INTERRUPT_ENABLE_1_REG);\n\n\tspin_unlock_irqrestore(&geth->irq_lock, flags);\n}\n\nstatic struct sk_buff *gmac_skb_if_good_frame(struct gemini_ethernet_port *port,\n\t\t\t\t\t      union gmac_rxdesc_0 word0,\n\t\t\t\t\t      unsigned int frame_len)\n{\n\tunsigned int rx_csum = word0.bits.chksum_status;\n\tunsigned int rx_status = word0.bits.status;\n\tstruct sk_buff *skb = NULL;\n\n\tport->rx_stats[rx_status]++;\n\tport->rx_csum_stats[rx_csum]++;\n\n\tif (word0.bits.derr || word0.bits.perr ||\n\t    rx_status || frame_len < ETH_ZLEN ||\n\t    rx_csum >= RX_CHKSUM_IP_ERR_UNKNOWN) {\n\t\tport->stats.rx_errors++;\n\n\t\tif (frame_len < ETH_ZLEN || RX_ERROR_LENGTH(rx_status))\n\t\t\tport->stats.rx_length_errors++;\n\t\tif (RX_ERROR_OVER(rx_status))\n\t\t\tport->stats.rx_over_errors++;\n\t\tif (RX_ERROR_CRC(rx_status))\n\t\t\tport->stats.rx_crc_errors++;\n\t\tif (RX_ERROR_FRAME(rx_status))\n\t\t\tport->stats.rx_frame_errors++;\n\t\treturn NULL;\n\t}\n\n\tskb = napi_get_frags(&port->napi);\n\tif (!skb)\n\t\tgoto update_exit;\n\n\tif (rx_csum == RX_CHKSUM_IP_UDP_TCP_OK)\n\t\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\nupdate_exit:\n\tport->stats.rx_bytes += frame_len;\n\tport->stats.rx_packets++;\n\treturn skb;\n}\n\nstatic unsigned int gmac_rx(struct net_device *netdev, unsigned int budget)\n{\n\tstruct gemini_ethernet_port *port = netdev_priv(netdev);\n\tunsigned short m = (1 << port->rxq_order) - 1;\n\tstruct gemini_ethernet *geth = port->geth;\n\tvoid __iomem *ptr_reg = port->rxq_rwptr;\n\tunsigned int frame_len, frag_len;\n\tstruct gmac_rxdesc *rx = NULL;\n\tstruct gmac_queue_page *gpage;\n\tstatic struct sk_buff *skb;\n\tunion gmac_rxdesc_0 word0;\n\tunion gmac_rxdesc_1 word1;\n\tunion gmac_rxdesc_3 word3;\n\tstruct page *page = NULL;\n\tunsigned int page_offs;\n\tunsigned short r, w;\n\tunion dma_rwptr rw;\n\tdma_addr_t mapping;\n\tint frag_nr = 0;\n\n\trw.bits32 = readl(ptr_reg);\n\t \n\twritel(DEFAULT_Q0_INT_BIT << netdev->dev_id,\n\t       geth->base + GLOBAL_INTERRUPT_STATUS_1_REG);\n\tr = rw.bits.rptr;\n\tw = rw.bits.wptr;\n\n\twhile (budget && w != r) {\n\t\trx = port->rxq_ring + r;\n\t\tword0 = rx->word0;\n\t\tword1 = rx->word1;\n\t\tmapping = rx->word2.buf_adr;\n\t\tword3 = rx->word3;\n\n\t\tr++;\n\t\tr &= m;\n\n\t\tfrag_len = word0.bits.buffer_size;\n\t\tframe_len = word1.bits.byte_count;\n\t\tpage_offs = mapping & ~PAGE_MASK;\n\n\t\tif (!mapping) {\n\t\t\tnetdev_err(netdev,\n\t\t\t\t   \"rxq[%u]: HW BUG: zero DMA desc\\n\", r);\n\t\t\tgoto err_drop;\n\t\t}\n\n\t\t \n\t\tgpage = gmac_get_queue_page(geth, port, mapping + PAGE_SIZE);\n\t\tif (!gpage) {\n\t\t\tdev_err(geth->dev, \"could not find mapping\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tpage = gpage->page;\n\n\t\tif (word3.bits32 & SOF_BIT) {\n\t\t\tif (skb) {\n\t\t\t\tnapi_free_frags(&port->napi);\n\t\t\t\tport->stats.rx_dropped++;\n\t\t\t}\n\n\t\t\tskb = gmac_skb_if_good_frame(port, word0, frame_len);\n\t\t\tif (!skb)\n\t\t\t\tgoto err_drop;\n\n\t\t\tpage_offs += NET_IP_ALIGN;\n\t\t\tfrag_len -= NET_IP_ALIGN;\n\t\t\tfrag_nr = 0;\n\n\t\t} else if (!skb) {\n\t\t\tput_page(page);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (word3.bits32 & EOF_BIT)\n\t\t\tfrag_len = frame_len - skb->len;\n\n\t\t \n\t\tif (frag_nr == MAX_SKB_FRAGS)\n\t\t\tgoto err_drop;\n\n\t\tif (frag_len == 0)\n\t\t\tnetdev_err(netdev, \"Received fragment with len = 0\\n\");\n\n\t\tskb_fill_page_desc(skb, frag_nr, page, page_offs, frag_len);\n\t\tskb->len += frag_len;\n\t\tskb->data_len += frag_len;\n\t\tskb->truesize += frag_len;\n\t\tfrag_nr++;\n\n\t\tif (word3.bits32 & EOF_BIT) {\n\t\t\tnapi_gro_frags(&port->napi);\n\t\t\tskb = NULL;\n\t\t\t--budget;\n\t\t}\n\t\tcontinue;\n\nerr_drop:\n\t\tif (skb) {\n\t\t\tnapi_free_frags(&port->napi);\n\t\t\tskb = NULL;\n\t\t}\n\n\t\tif (mapping)\n\t\t\tput_page(page);\n\n\t\tport->stats.rx_dropped++;\n\t}\n\n\twritew(r, ptr_reg);\n\treturn budget;\n}\n\nstatic int gmac_napi_poll(struct napi_struct *napi, int budget)\n{\n\tstruct gemini_ethernet_port *port = netdev_priv(napi->dev);\n\tstruct gemini_ethernet *geth = port->geth;\n\tunsigned int freeq_threshold;\n\tunsigned int received;\n\n\tfreeq_threshold = 1 << (geth->freeq_order - 1);\n\tu64_stats_update_begin(&port->rx_stats_syncp);\n\n\treceived = gmac_rx(napi->dev, budget);\n\tif (received < budget) {\n\t\tnapi_gro_flush(napi, false);\n\t\tnapi_complete_done(napi, received);\n\t\tgmac_enable_rx_irq(napi->dev, 1);\n\t\t++port->rx_napi_exits;\n\t}\n\n\tport->freeq_refill += (budget - received);\n\tif (port->freeq_refill > freeq_threshold) {\n\t\tport->freeq_refill -= freeq_threshold;\n\t\tgeth_fill_freeq(geth, true);\n\t}\n\n\tu64_stats_update_end(&port->rx_stats_syncp);\n\treturn received;\n}\n\nstatic void gmac_dump_dma_state(struct net_device *netdev)\n{\n\tstruct gemini_ethernet_port *port = netdev_priv(netdev);\n\tstruct gemini_ethernet *geth = port->geth;\n\tvoid __iomem *ptr_reg;\n\tu32 reg[5];\n\n\t \n\treg[0] = readl(geth->base + GLOBAL_INTERRUPT_STATUS_0_REG);\n\treg[1] = readl(geth->base + GLOBAL_INTERRUPT_STATUS_1_REG);\n\treg[2] = readl(geth->base + GLOBAL_INTERRUPT_STATUS_2_REG);\n\treg[3] = readl(geth->base + GLOBAL_INTERRUPT_STATUS_3_REG);\n\treg[4] = readl(geth->base + GLOBAL_INTERRUPT_STATUS_4_REG);\n\tnetdev_err(netdev, \"IRQ status: 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x\\n\",\n\t\t   reg[0], reg[1], reg[2], reg[3], reg[4]);\n\n\t \n\treg[0] = readl(geth->base + GLOBAL_INTERRUPT_ENABLE_0_REG);\n\treg[1] = readl(geth->base + GLOBAL_INTERRUPT_ENABLE_1_REG);\n\treg[2] = readl(geth->base + GLOBAL_INTERRUPT_ENABLE_2_REG);\n\treg[3] = readl(geth->base + GLOBAL_INTERRUPT_ENABLE_3_REG);\n\treg[4] = readl(geth->base + GLOBAL_INTERRUPT_ENABLE_4_REG);\n\tnetdev_err(netdev, \"IRQ enable: 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x\\n\",\n\t\t   reg[0], reg[1], reg[2], reg[3], reg[4]);\n\n\t \n\treg[0] = readl(port->dma_base + GMAC_DMA_RX_FIRST_DESC_REG);\n\treg[1] = readl(port->dma_base + GMAC_DMA_RX_CURR_DESC_REG);\n\treg[2] = GET_RPTR(port->rxq_rwptr);\n\treg[3] = GET_WPTR(port->rxq_rwptr);\n\tnetdev_err(netdev, \"RX DMA regs: 0x%08x 0x%08x, ptr: %u %u\\n\",\n\t\t   reg[0], reg[1], reg[2], reg[3]);\n\n\treg[0] = readl(port->dma_base + GMAC_DMA_RX_DESC_WORD0_REG);\n\treg[1] = readl(port->dma_base + GMAC_DMA_RX_DESC_WORD1_REG);\n\treg[2] = readl(port->dma_base + GMAC_DMA_RX_DESC_WORD2_REG);\n\treg[3] = readl(port->dma_base + GMAC_DMA_RX_DESC_WORD3_REG);\n\tnetdev_err(netdev, \"RX DMA descriptor: 0x%08x 0x%08x 0x%08x 0x%08x\\n\",\n\t\t   reg[0], reg[1], reg[2], reg[3]);\n\n\t \n\tptr_reg = port->dma_base + GMAC_SW_TX_QUEUE0_PTR_REG;\n\n\treg[0] = readl(port->dma_base + GMAC_DMA_TX_FIRST_DESC_REG);\n\treg[1] = readl(port->dma_base + GMAC_DMA_TX_CURR_DESC_REG);\n\treg[2] = GET_RPTR(ptr_reg);\n\treg[3] = GET_WPTR(ptr_reg);\n\tnetdev_err(netdev, \"TX DMA regs: 0x%08x 0x%08x, ptr: %u %u\\n\",\n\t\t   reg[0], reg[1], reg[2], reg[3]);\n\n\treg[0] = readl(port->dma_base + GMAC_DMA_TX_DESC_WORD0_REG);\n\treg[1] = readl(port->dma_base + GMAC_DMA_TX_DESC_WORD1_REG);\n\treg[2] = readl(port->dma_base + GMAC_DMA_TX_DESC_WORD2_REG);\n\treg[3] = readl(port->dma_base + GMAC_DMA_TX_DESC_WORD3_REG);\n\tnetdev_err(netdev, \"TX DMA descriptor: 0x%08x 0x%08x 0x%08x 0x%08x\\n\",\n\t\t   reg[0], reg[1], reg[2], reg[3]);\n\n\t \n\tptr_reg = geth->base + GLOBAL_SWFQ_RWPTR_REG;\n\n\treg[0] = GET_RPTR(ptr_reg);\n\treg[1] = GET_WPTR(ptr_reg);\n\n\tptr_reg = geth->base + GLOBAL_HWFQ_RWPTR_REG;\n\n\treg[2] = GET_RPTR(ptr_reg);\n\treg[3] = GET_WPTR(ptr_reg);\n\tnetdev_err(netdev, \"FQ SW ptr: %u %u, HW ptr: %u %u\\n\",\n\t\t   reg[0], reg[1], reg[2], reg[3]);\n}\n\nstatic void gmac_update_hw_stats(struct net_device *netdev)\n{\n\tstruct gemini_ethernet_port *port = netdev_priv(netdev);\n\tunsigned int rx_discards, rx_mcast, rx_bcast;\n\tstruct gemini_ethernet *geth = port->geth;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&geth->irq_lock, flags);\n\tu64_stats_update_begin(&port->ir_stats_syncp);\n\n\trx_discards = readl(port->gmac_base + GMAC_IN_DISCARDS);\n\tport->hw_stats[0] += rx_discards;\n\tport->hw_stats[1] += readl(port->gmac_base + GMAC_IN_ERRORS);\n\trx_mcast = readl(port->gmac_base + GMAC_IN_MCAST);\n\tport->hw_stats[2] += rx_mcast;\n\trx_bcast = readl(port->gmac_base + GMAC_IN_BCAST);\n\tport->hw_stats[3] += rx_bcast;\n\tport->hw_stats[4] += readl(port->gmac_base + GMAC_IN_MAC1);\n\tport->hw_stats[5] += readl(port->gmac_base + GMAC_IN_MAC2);\n\n\tport->stats.rx_missed_errors += rx_discards;\n\tport->stats.multicast += rx_mcast;\n\tport->stats.multicast += rx_bcast;\n\n\twritel(GMAC0_MIB_INT_BIT << (netdev->dev_id * 8),\n\t       geth->base + GLOBAL_INTERRUPT_STATUS_4_REG);\n\n\tu64_stats_update_end(&port->ir_stats_syncp);\n\tspin_unlock_irqrestore(&geth->irq_lock, flags);\n}\n\n \nstatic u32 gmac_get_intr_flags(struct net_device *netdev, int i)\n{\n\tstruct gemini_ethernet_port *port = netdev_priv(netdev);\n\tstruct gemini_ethernet *geth = port->geth;\n\tvoid __iomem *irqif_reg, *irqen_reg;\n\tunsigned int offs, val;\n\n\t \n\toffs = i * (GLOBAL_INTERRUPT_STATUS_1_REG -\n\t\t    GLOBAL_INTERRUPT_STATUS_0_REG);\n\n\tirqif_reg = geth->base + GLOBAL_INTERRUPT_STATUS_0_REG + offs;\n\tirqen_reg = geth->base + GLOBAL_INTERRUPT_ENABLE_0_REG + offs;\n\n\tval = readl(irqif_reg) & readl(irqen_reg);\n\treturn val;\n}\n\nstatic enum hrtimer_restart gmac_coalesce_delay_expired(struct hrtimer *timer)\n{\n\tstruct gemini_ethernet_port *port =\n\t\tcontainer_of(timer, struct gemini_ethernet_port,\n\t\t\t     rx_coalesce_timer);\n\n\tnapi_schedule(&port->napi);\n\treturn HRTIMER_NORESTART;\n}\n\nstatic irqreturn_t gmac_irq(int irq, void *data)\n{\n\tstruct gemini_ethernet_port *port;\n\tstruct net_device *netdev = data;\n\tstruct gemini_ethernet *geth;\n\tu32 val, orr = 0;\n\n\tport = netdev_priv(netdev);\n\tgeth = port->geth;\n\n\tval = gmac_get_intr_flags(netdev, 0);\n\torr |= val;\n\n\tif (val & (GMAC0_IRQ0_2 << (netdev->dev_id * 2))) {\n\t\t \n\t\tnetdev_err(netdev, \"hw failure/sw bug\\n\");\n\t\tgmac_dump_dma_state(netdev);\n\n\t\t \n\t\tgmac_enable_irq(netdev, 0);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tif (val & (GMAC0_IRQ0_TXQ0_INTS << (netdev->dev_id * 6)))\n\t\tgmac_tx_irq(netdev, 0);\n\n\tval = gmac_get_intr_flags(netdev, 1);\n\torr |= val;\n\n\tif (val & (DEFAULT_Q0_INT_BIT << netdev->dev_id)) {\n\t\tgmac_enable_rx_irq(netdev, 0);\n\n\t\tif (!port->rx_coalesce_nsecs) {\n\t\t\tnapi_schedule(&port->napi);\n\t\t} else {\n\t\t\tktime_t ktime;\n\n\t\t\tktime = ktime_set(0, port->rx_coalesce_nsecs);\n\t\t\thrtimer_start(&port->rx_coalesce_timer, ktime,\n\t\t\t\t      HRTIMER_MODE_REL);\n\t\t}\n\t}\n\n\tval = gmac_get_intr_flags(netdev, 4);\n\torr |= val;\n\n\tif (val & (GMAC0_MIB_INT_BIT << (netdev->dev_id * 8)))\n\t\tgmac_update_hw_stats(netdev);\n\n\tif (val & (GMAC0_RX_OVERRUN_INT_BIT << (netdev->dev_id * 8))) {\n\t\twritel(GMAC0_RXDERR_INT_BIT << (netdev->dev_id * 8),\n\t\t       geth->base + GLOBAL_INTERRUPT_STATUS_4_REG);\n\n\t\tspin_lock(&geth->irq_lock);\n\t\tu64_stats_update_begin(&port->ir_stats_syncp);\n\t\t++port->stats.rx_fifo_errors;\n\t\tu64_stats_update_end(&port->ir_stats_syncp);\n\t\tspin_unlock(&geth->irq_lock);\n\t}\n\n\treturn orr ? IRQ_HANDLED : IRQ_NONE;\n}\n\nstatic void gmac_start_dma(struct gemini_ethernet_port *port)\n{\n\tvoid __iomem *dma_ctrl_reg = port->dma_base + GMAC_DMA_CTRL_REG;\n\tunion gmac_dma_ctrl dma_ctrl;\n\n\tdma_ctrl.bits32 = readl(dma_ctrl_reg);\n\tdma_ctrl.bits.rd_enable = 1;\n\tdma_ctrl.bits.td_enable = 1;\n\tdma_ctrl.bits.loopback = 0;\n\tdma_ctrl.bits.drop_small_ack = 0;\n\tdma_ctrl.bits.rd_insert_bytes = NET_IP_ALIGN;\n\tdma_ctrl.bits.rd_prot = HPROT_DATA_CACHE | HPROT_PRIVILIGED;\n\tdma_ctrl.bits.rd_burst_size = HBURST_INCR8;\n\tdma_ctrl.bits.rd_bus = HSIZE_8;\n\tdma_ctrl.bits.td_prot = HPROT_DATA_CACHE;\n\tdma_ctrl.bits.td_burst_size = HBURST_INCR8;\n\tdma_ctrl.bits.td_bus = HSIZE_8;\n\n\twritel(dma_ctrl.bits32, dma_ctrl_reg);\n}\n\nstatic void gmac_stop_dma(struct gemini_ethernet_port *port)\n{\n\tvoid __iomem *dma_ctrl_reg = port->dma_base + GMAC_DMA_CTRL_REG;\n\tunion gmac_dma_ctrl dma_ctrl;\n\n\tdma_ctrl.bits32 = readl(dma_ctrl_reg);\n\tdma_ctrl.bits.rd_enable = 0;\n\tdma_ctrl.bits.td_enable = 0;\n\twritel(dma_ctrl.bits32, dma_ctrl_reg);\n}\n\nstatic int gmac_open(struct net_device *netdev)\n{\n\tstruct gemini_ethernet_port *port = netdev_priv(netdev);\n\tint err;\n\n\terr = request_irq(netdev->irq, gmac_irq,\n\t\t\t  IRQF_SHARED, netdev->name, netdev);\n\tif (err) {\n\t\tnetdev_err(netdev, \"no IRQ\\n\");\n\t\treturn err;\n\t}\n\n\tnetif_carrier_off(netdev);\n\tphy_start(netdev->phydev);\n\n\terr = geth_resize_freeq(port);\n\t \n\tif (err && (err != -EBUSY)) {\n\t\tnetdev_err(netdev, \"could not resize freeq\\n\");\n\t\tgoto err_stop_phy;\n\t}\n\n\terr = gmac_setup_rxq(netdev);\n\tif (err) {\n\t\tnetdev_err(netdev, \"could not setup RXQ\\n\");\n\t\tgoto err_stop_phy;\n\t}\n\n\terr = gmac_setup_txqs(netdev);\n\tif (err) {\n\t\tnetdev_err(netdev, \"could not setup TXQs\\n\");\n\t\tgmac_cleanup_rxq(netdev);\n\t\tgoto err_stop_phy;\n\t}\n\n\tnapi_enable(&port->napi);\n\n\tgmac_start_dma(port);\n\tgmac_enable_irq(netdev, 1);\n\tgmac_enable_tx_rx(netdev);\n\tnetif_tx_start_all_queues(netdev);\n\n\thrtimer_init(&port->rx_coalesce_timer, CLOCK_MONOTONIC,\n\t\t     HRTIMER_MODE_REL);\n\tport->rx_coalesce_timer.function = &gmac_coalesce_delay_expired;\n\n\tnetdev_dbg(netdev, \"opened\\n\");\n\n\treturn 0;\n\nerr_stop_phy:\n\tphy_stop(netdev->phydev);\n\tfree_irq(netdev->irq, netdev);\n\treturn err;\n}\n\nstatic int gmac_stop(struct net_device *netdev)\n{\n\tstruct gemini_ethernet_port *port = netdev_priv(netdev);\n\n\thrtimer_cancel(&port->rx_coalesce_timer);\n\tnetif_tx_stop_all_queues(netdev);\n\tgmac_disable_tx_rx(netdev);\n\tgmac_stop_dma(port);\n\tnapi_disable(&port->napi);\n\n\tgmac_enable_irq(netdev, 0);\n\tgmac_cleanup_rxq(netdev);\n\tgmac_cleanup_txqs(netdev);\n\n\tphy_stop(netdev->phydev);\n\tfree_irq(netdev->irq, netdev);\n\n\tgmac_update_hw_stats(netdev);\n\treturn 0;\n}\n\nstatic void gmac_set_rx_mode(struct net_device *netdev)\n{\n\tstruct gemini_ethernet_port *port = netdev_priv(netdev);\n\tunion gmac_rx_fltr filter = { .bits = {\n\t\t.broadcast = 1,\n\t\t.multicast = 1,\n\t\t.unicast = 1,\n\t} };\n\tstruct netdev_hw_addr *ha;\n\tunsigned int bit_nr;\n\tu32 mc_filter[2];\n\n\tmc_filter[1] = 0;\n\tmc_filter[0] = 0;\n\n\tif (netdev->flags & IFF_PROMISC) {\n\t\tfilter.bits.error = 1;\n\t\tfilter.bits.promiscuous = 1;\n\t\tmc_filter[1] = ~0;\n\t\tmc_filter[0] = ~0;\n\t} else if (netdev->flags & IFF_ALLMULTI) {\n\t\tmc_filter[1] = ~0;\n\t\tmc_filter[0] = ~0;\n\t} else {\n\t\tnetdev_for_each_mc_addr(ha, netdev) {\n\t\t\tbit_nr = ~crc32_le(~0, ha->addr, ETH_ALEN) & 0x3f;\n\t\t\tmc_filter[bit_nr >> 5] |= 1 << (bit_nr & 0x1f);\n\t\t}\n\t}\n\n\twritel(mc_filter[0], port->gmac_base + GMAC_MCAST_FIL0);\n\twritel(mc_filter[1], port->gmac_base + GMAC_MCAST_FIL1);\n\twritel(filter.bits32, port->gmac_base + GMAC_RX_FLTR);\n}\n\nstatic void gmac_write_mac_address(struct net_device *netdev)\n{\n\tstruct gemini_ethernet_port *port = netdev_priv(netdev);\n\t__le32 addr[3];\n\n\tmemset(addr, 0, sizeof(addr));\n\tmemcpy(addr, netdev->dev_addr, ETH_ALEN);\n\n\twritel(le32_to_cpu(addr[0]), port->gmac_base + GMAC_STA_ADD0);\n\twritel(le32_to_cpu(addr[1]), port->gmac_base + GMAC_STA_ADD1);\n\twritel(le32_to_cpu(addr[2]), port->gmac_base + GMAC_STA_ADD2);\n}\n\nstatic int gmac_set_mac_address(struct net_device *netdev, void *addr)\n{\n\tstruct sockaddr *sa = addr;\n\n\teth_hw_addr_set(netdev, sa->sa_data);\n\tgmac_write_mac_address(netdev);\n\n\treturn 0;\n}\n\nstatic void gmac_clear_hw_stats(struct net_device *netdev)\n{\n\tstruct gemini_ethernet_port *port = netdev_priv(netdev);\n\n\treadl(port->gmac_base + GMAC_IN_DISCARDS);\n\treadl(port->gmac_base + GMAC_IN_ERRORS);\n\treadl(port->gmac_base + GMAC_IN_MCAST);\n\treadl(port->gmac_base + GMAC_IN_BCAST);\n\treadl(port->gmac_base + GMAC_IN_MAC1);\n\treadl(port->gmac_base + GMAC_IN_MAC2);\n}\n\nstatic void gmac_get_stats64(struct net_device *netdev,\n\t\t\t     struct rtnl_link_stats64 *stats)\n{\n\tstruct gemini_ethernet_port *port = netdev_priv(netdev);\n\tunsigned int start;\n\n\tgmac_update_hw_stats(netdev);\n\n\t \n\tdo {\n\t\tstart = u64_stats_fetch_begin(&port->rx_stats_syncp);\n\n\t\tstats->rx_packets = port->stats.rx_packets;\n\t\tstats->rx_bytes = port->stats.rx_bytes;\n\t\tstats->rx_errors = port->stats.rx_errors;\n\t\tstats->rx_dropped = port->stats.rx_dropped;\n\n\t\tstats->rx_length_errors = port->stats.rx_length_errors;\n\t\tstats->rx_over_errors = port->stats.rx_over_errors;\n\t\tstats->rx_crc_errors = port->stats.rx_crc_errors;\n\t\tstats->rx_frame_errors = port->stats.rx_frame_errors;\n\n\t} while (u64_stats_fetch_retry(&port->rx_stats_syncp, start));\n\n\t \n\tdo {\n\t\tstart = u64_stats_fetch_begin(&port->ir_stats_syncp);\n\n\t\tstats->tx_errors = port->stats.tx_errors;\n\t\tstats->tx_packets = port->stats.tx_packets;\n\t\tstats->tx_bytes = port->stats.tx_bytes;\n\n\t\tstats->multicast = port->stats.multicast;\n\t\tstats->rx_missed_errors = port->stats.rx_missed_errors;\n\t\tstats->rx_fifo_errors = port->stats.rx_fifo_errors;\n\n\t} while (u64_stats_fetch_retry(&port->ir_stats_syncp, start));\n\n\t \n\tdo {\n\t\tstart = u64_stats_fetch_begin(&port->tx_stats_syncp);\n\n\t\tstats->tx_dropped = port->stats.tx_dropped;\n\n\t} while (u64_stats_fetch_retry(&port->tx_stats_syncp, start));\n\n\tstats->rx_dropped += stats->rx_missed_errors;\n}\n\nstatic int gmac_change_mtu(struct net_device *netdev, int new_mtu)\n{\n\tint max_len = gmac_pick_rx_max_len(new_mtu);\n\n\tif (max_len < 0)\n\t\treturn -EINVAL;\n\n\tgmac_disable_tx_rx(netdev);\n\n\tnetdev->mtu = new_mtu;\n\tgmac_update_config0_reg(netdev, max_len << CONFIG0_MAXLEN_SHIFT,\n\t\t\t\tCONFIG0_MAXLEN_MASK);\n\n\tnetdev_update_features(netdev);\n\n\tgmac_enable_tx_rx(netdev);\n\n\treturn 0;\n}\n\nstatic int gmac_set_features(struct net_device *netdev,\n\t\t\t     netdev_features_t features)\n{\n\tstruct gemini_ethernet_port *port = netdev_priv(netdev);\n\tint enable = features & NETIF_F_RXCSUM;\n\tunsigned long flags;\n\tu32 reg;\n\n\tspin_lock_irqsave(&port->config_lock, flags);\n\n\treg = readl(port->gmac_base + GMAC_CONFIG0);\n\treg = enable ? reg | CONFIG0_RX_CHKSUM : reg & ~CONFIG0_RX_CHKSUM;\n\twritel(reg, port->gmac_base + GMAC_CONFIG0);\n\n\tspin_unlock_irqrestore(&port->config_lock, flags);\n\treturn 0;\n}\n\nstatic int gmac_get_sset_count(struct net_device *netdev, int sset)\n{\n\treturn sset == ETH_SS_STATS ? GMAC_STATS_NUM : 0;\n}\n\nstatic void gmac_get_strings(struct net_device *netdev, u32 stringset, u8 *data)\n{\n\tif (stringset != ETH_SS_STATS)\n\t\treturn;\n\n\tmemcpy(data, gmac_stats_strings, sizeof(gmac_stats_strings));\n}\n\nstatic void gmac_get_ethtool_stats(struct net_device *netdev,\n\t\t\t\t   struct ethtool_stats *estats, u64 *values)\n{\n\tstruct gemini_ethernet_port *port = netdev_priv(netdev);\n\tunsigned int start;\n\tu64 *p;\n\tint i;\n\n\tgmac_update_hw_stats(netdev);\n\n\t \n\tdo {\n\t\tp = values;\n\t\tstart = u64_stats_fetch_begin(&port->ir_stats_syncp);\n\n\t\tfor (i = 0; i < RX_STATS_NUM; i++)\n\t\t\t*p++ = port->hw_stats[i];\n\n\t} while (u64_stats_fetch_retry(&port->ir_stats_syncp, start));\n\tvalues = p;\n\n\t \n\tdo {\n\t\tp = values;\n\t\tstart = u64_stats_fetch_begin(&port->rx_stats_syncp);\n\n\t\tfor (i = 0; i < RX_STATUS_NUM; i++)\n\t\t\t*p++ = port->rx_stats[i];\n\t\tfor (i = 0; i < RX_CHKSUM_NUM; i++)\n\t\t\t*p++ = port->rx_csum_stats[i];\n\t\t*p++ = port->rx_napi_exits;\n\n\t} while (u64_stats_fetch_retry(&port->rx_stats_syncp, start));\n\tvalues = p;\n\n\t \n\tdo {\n\t\tp = values;\n\t\tstart = u64_stats_fetch_begin(&port->tx_stats_syncp);\n\n\t\tfor (i = 0; i < TX_MAX_FRAGS; i++) {\n\t\t\t*values++ = port->tx_frag_stats[i];\n\t\t\tport->tx_frag_stats[i] = 0;\n\t\t}\n\t\t*values++ = port->tx_frags_linearized;\n\t\t*values++ = port->tx_hw_csummed;\n\n\t} while (u64_stats_fetch_retry(&port->tx_stats_syncp, start));\n}\n\nstatic int gmac_get_ksettings(struct net_device *netdev,\n\t\t\t      struct ethtool_link_ksettings *cmd)\n{\n\tif (!netdev->phydev)\n\t\treturn -ENXIO;\n\tphy_ethtool_ksettings_get(netdev->phydev, cmd);\n\n\treturn 0;\n}\n\nstatic int gmac_set_ksettings(struct net_device *netdev,\n\t\t\t      const struct ethtool_link_ksettings *cmd)\n{\n\tif (!netdev->phydev)\n\t\treturn -ENXIO;\n\treturn phy_ethtool_ksettings_set(netdev->phydev, cmd);\n}\n\nstatic int gmac_nway_reset(struct net_device *netdev)\n{\n\tif (!netdev->phydev)\n\t\treturn -ENXIO;\n\treturn phy_start_aneg(netdev->phydev);\n}\n\nstatic void gmac_get_pauseparam(struct net_device *netdev,\n\t\t\t\tstruct ethtool_pauseparam *pparam)\n{\n\tstruct gemini_ethernet_port *port = netdev_priv(netdev);\n\tunion gmac_config0 config0;\n\n\tconfig0.bits32 = readl(port->gmac_base + GMAC_CONFIG0);\n\n\tpparam->rx_pause = config0.bits.rx_fc_en;\n\tpparam->tx_pause = config0.bits.tx_fc_en;\n\tpparam->autoneg = true;\n}\n\nstatic void gmac_get_ringparam(struct net_device *netdev,\n\t\t\t       struct ethtool_ringparam *rp,\n\t\t\t       struct kernel_ethtool_ringparam *kernel_rp,\n\t\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct gemini_ethernet_port *port = netdev_priv(netdev);\n\n\treadl(port->gmac_base + GMAC_CONFIG0);\n\n\trp->rx_max_pending = 1 << 15;\n\trp->rx_mini_max_pending = 0;\n\trp->rx_jumbo_max_pending = 0;\n\trp->tx_max_pending = 1 << 15;\n\n\trp->rx_pending = 1 << port->rxq_order;\n\trp->rx_mini_pending = 0;\n\trp->rx_jumbo_pending = 0;\n\trp->tx_pending = 1 << port->txq_order;\n}\n\nstatic int gmac_set_ringparam(struct net_device *netdev,\n\t\t\t      struct ethtool_ringparam *rp,\n\t\t\t      struct kernel_ethtool_ringparam *kernel_rp,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct gemini_ethernet_port *port = netdev_priv(netdev);\n\tint err = 0;\n\n\tif (netif_running(netdev))\n\t\treturn -EBUSY;\n\n\tif (rp->rx_pending) {\n\t\tport->rxq_order = min(15, ilog2(rp->rx_pending - 1) + 1);\n\t\terr = geth_resize_freeq(port);\n\t}\n\tif (rp->tx_pending) {\n\t\tport->txq_order = min(15, ilog2(rp->tx_pending - 1) + 1);\n\t\tport->irq_every_tx_packets = 1 << (port->txq_order - 2);\n\t}\n\n\treturn err;\n}\n\nstatic int gmac_get_coalesce(struct net_device *netdev,\n\t\t\t     struct ethtool_coalesce *ecmd,\n\t\t\t     struct kernel_ethtool_coalesce *kernel_coal,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct gemini_ethernet_port *port = netdev_priv(netdev);\n\n\tecmd->rx_max_coalesced_frames = 1;\n\tecmd->tx_max_coalesced_frames = port->irq_every_tx_packets;\n\tecmd->rx_coalesce_usecs = port->rx_coalesce_nsecs / 1000;\n\n\treturn 0;\n}\n\nstatic int gmac_set_coalesce(struct net_device *netdev,\n\t\t\t     struct ethtool_coalesce *ecmd,\n\t\t\t     struct kernel_ethtool_coalesce *kernel_coal,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct gemini_ethernet_port *port = netdev_priv(netdev);\n\n\tif (ecmd->tx_max_coalesced_frames < 1)\n\t\treturn -EINVAL;\n\tif (ecmd->tx_max_coalesced_frames >= 1 << port->txq_order)\n\t\treturn -EINVAL;\n\n\tport->irq_every_tx_packets = ecmd->tx_max_coalesced_frames;\n\tport->rx_coalesce_nsecs = ecmd->rx_coalesce_usecs * 1000;\n\n\treturn 0;\n}\n\nstatic u32 gmac_get_msglevel(struct net_device *netdev)\n{\n\tstruct gemini_ethernet_port *port = netdev_priv(netdev);\n\n\treturn port->msg_enable;\n}\n\nstatic void gmac_set_msglevel(struct net_device *netdev, u32 level)\n{\n\tstruct gemini_ethernet_port *port = netdev_priv(netdev);\n\n\tport->msg_enable = level;\n}\n\nstatic void gmac_get_drvinfo(struct net_device *netdev,\n\t\t\t     struct ethtool_drvinfo *info)\n{\n\tstrcpy(info->driver,  DRV_NAME);\n\tstrcpy(info->bus_info, netdev->dev_id ? \"1\" : \"0\");\n}\n\nstatic const struct net_device_ops gmac_351x_ops = {\n\t.ndo_init\t\t= gmac_init,\n\t.ndo_open\t\t= gmac_open,\n\t.ndo_stop\t\t= gmac_stop,\n\t.ndo_start_xmit\t\t= gmac_start_xmit,\n\t.ndo_tx_timeout\t\t= gmac_tx_timeout,\n\t.ndo_set_rx_mode\t= gmac_set_rx_mode,\n\t.ndo_set_mac_address\t= gmac_set_mac_address,\n\t.ndo_get_stats64\t= gmac_get_stats64,\n\t.ndo_change_mtu\t\t= gmac_change_mtu,\n\t.ndo_set_features\t= gmac_set_features,\n};\n\nstatic const struct ethtool_ops gmac_351x_ethtool_ops = {\n\t.supported_coalesce_params = ETHTOOL_COALESCE_RX_USECS |\n\t\t\t\t     ETHTOOL_COALESCE_MAX_FRAMES,\n\t.get_sset_count\t= gmac_get_sset_count,\n\t.get_strings\t= gmac_get_strings,\n\t.get_ethtool_stats = gmac_get_ethtool_stats,\n\t.get_link\t= ethtool_op_get_link,\n\t.get_link_ksettings = gmac_get_ksettings,\n\t.set_link_ksettings = gmac_set_ksettings,\n\t.nway_reset\t= gmac_nway_reset,\n\t.get_pauseparam\t= gmac_get_pauseparam,\n\t.get_ringparam\t= gmac_get_ringparam,\n\t.set_ringparam\t= gmac_set_ringparam,\n\t.get_coalesce\t= gmac_get_coalesce,\n\t.set_coalesce\t= gmac_set_coalesce,\n\t.get_msglevel\t= gmac_get_msglevel,\n\t.set_msglevel\t= gmac_set_msglevel,\n\t.get_drvinfo\t= gmac_get_drvinfo,\n};\n\nstatic irqreturn_t gemini_port_irq_thread(int irq, void *data)\n{\n\tunsigned long irqmask = SWFQ_EMPTY_INT_BIT;\n\tstruct gemini_ethernet_port *port = data;\n\tstruct gemini_ethernet *geth;\n\tunsigned long flags;\n\n\tgeth = port->geth;\n\t \n\tgeth_fill_freeq(geth, true);\n\n\tspin_lock_irqsave(&geth->irq_lock, flags);\n\t \n\twritel(irqmask, geth->base + GLOBAL_INTERRUPT_STATUS_4_REG);\n\t \n\tirqmask |= readl(geth->base + GLOBAL_INTERRUPT_ENABLE_4_REG);\n\twritel(irqmask, geth->base + GLOBAL_INTERRUPT_ENABLE_4_REG);\n\tspin_unlock_irqrestore(&geth->irq_lock, flags);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t gemini_port_irq(int irq, void *data)\n{\n\tstruct gemini_ethernet_port *port = data;\n\tstruct gemini_ethernet *geth;\n\tirqreturn_t ret = IRQ_NONE;\n\tu32 val, en;\n\n\tgeth = port->geth;\n\tspin_lock(&geth->irq_lock);\n\n\tval = readl(geth->base + GLOBAL_INTERRUPT_STATUS_4_REG);\n\ten = readl(geth->base + GLOBAL_INTERRUPT_ENABLE_4_REG);\n\n\tif (val & en & SWFQ_EMPTY_INT_BIT) {\n\t\t \n\t\ten &= ~(SWFQ_EMPTY_INT_BIT | GMAC0_RX_OVERRUN_INT_BIT\n\t\t\t\t\t   | GMAC1_RX_OVERRUN_INT_BIT);\n\t\twritel(en, geth->base + GLOBAL_INTERRUPT_ENABLE_4_REG);\n\t\tret = IRQ_WAKE_THREAD;\n\t}\n\n\tspin_unlock(&geth->irq_lock);\n\n\treturn ret;\n}\n\nstatic void gemini_port_remove(struct gemini_ethernet_port *port)\n{\n\tif (port->netdev) {\n\t\tphy_disconnect(port->netdev->phydev);\n\t\tunregister_netdev(port->netdev);\n\t}\n\tclk_disable_unprepare(port->pclk);\n\tgeth_cleanup_freeq(port->geth);\n}\n\nstatic void gemini_ethernet_init(struct gemini_ethernet *geth)\n{\n\t \n\tif (geth->initialized)\n\t\treturn;\n\tif (geth->port0 && geth->port1)\n\t\tgeth->initialized = true;\n\telse\n\t\treturn;\n\n\twritel(0, geth->base + GLOBAL_INTERRUPT_ENABLE_0_REG);\n\twritel(0, geth->base + GLOBAL_INTERRUPT_ENABLE_1_REG);\n\twritel(0, geth->base + GLOBAL_INTERRUPT_ENABLE_2_REG);\n\twritel(0, geth->base + GLOBAL_INTERRUPT_ENABLE_3_REG);\n\twritel(0, geth->base + GLOBAL_INTERRUPT_ENABLE_4_REG);\n\n\t \n\twritel(0xCCFC0FC0, geth->base + GLOBAL_INTERRUPT_SELECT_0_REG);\n\twritel(0x00F00002, geth->base + GLOBAL_INTERRUPT_SELECT_1_REG);\n\twritel(0xFFFFFFFF, geth->base + GLOBAL_INTERRUPT_SELECT_2_REG);\n\twritel(0xFFFFFFFF, geth->base + GLOBAL_INTERRUPT_SELECT_3_REG);\n\twritel(0xFF000003, geth->base + GLOBAL_INTERRUPT_SELECT_4_REG);\n\n\t \n\twritel(~0, geth->base + GLOBAL_INTERRUPT_STATUS_0_REG);\n\twritel(~0, geth->base + GLOBAL_INTERRUPT_STATUS_1_REG);\n\twritel(~0, geth->base + GLOBAL_INTERRUPT_STATUS_2_REG);\n\twritel(~0, geth->base + GLOBAL_INTERRUPT_STATUS_3_REG);\n\twritel(~0, geth->base + GLOBAL_INTERRUPT_STATUS_4_REG);\n\n\t \n\twritel(0, geth->base + GLOBAL_SW_FREEQ_BASE_SIZE_REG);\n\twritel(0, geth->base + GLOBAL_HW_FREEQ_BASE_SIZE_REG);\n\twritel(0, geth->base + GLOBAL_SWFQ_RWPTR_REG);\n\twritel(0, geth->base + GLOBAL_HWFQ_RWPTR_REG);\n\n\tgeth->freeq_frag_order = DEFAULT_RX_BUF_ORDER;\n\t \n\tgeth->freeq_order = 1;\n}\n\nstatic void gemini_port_save_mac_addr(struct gemini_ethernet_port *port)\n{\n\tport->mac_addr[0] =\n\t\tcpu_to_le32(readl(port->gmac_base + GMAC_STA_ADD0));\n\tport->mac_addr[1] =\n\t\tcpu_to_le32(readl(port->gmac_base + GMAC_STA_ADD1));\n\tport->mac_addr[2] =\n\t\tcpu_to_le32(readl(port->gmac_base + GMAC_STA_ADD2));\n}\n\nstatic int gemini_ethernet_port_probe(struct platform_device *pdev)\n{\n\tchar *port_names[2] = { \"ethernet0\", \"ethernet1\" };\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct gemini_ethernet_port *port;\n\tstruct device *dev = &pdev->dev;\n\tstruct gemini_ethernet *geth;\n\tstruct net_device *netdev;\n\tstruct device *parent;\n\tu8 mac[ETH_ALEN];\n\tunsigned int id;\n\tint irq;\n\tint ret;\n\n\tparent = dev->parent;\n\tgeth = dev_get_drvdata(parent);\n\n\tif (!strcmp(dev_name(dev), \"60008000.ethernet-port\"))\n\t\tid = 0;\n\telse if (!strcmp(dev_name(dev), \"6000c000.ethernet-port\"))\n\t\tid = 1;\n\telse\n\t\treturn -ENODEV;\n\n\tdev_info(dev, \"probe %s ID %d\\n\", dev_name(dev), id);\n\n\tnetdev = devm_alloc_etherdev_mqs(dev, sizeof(*port), TX_QUEUE_NUM, TX_QUEUE_NUM);\n\tif (!netdev) {\n\t\tdev_err(dev, \"Can't allocate ethernet device #%d\\n\", id);\n\t\treturn -ENOMEM;\n\t}\n\n\tport = netdev_priv(netdev);\n\tSET_NETDEV_DEV(netdev, dev);\n\tport->netdev = netdev;\n\tport->id = id;\n\tport->geth = geth;\n\tport->dev = dev;\n\tport->msg_enable = netif_msg_init(debug, DEFAULT_MSG_ENABLE);\n\n\t \n\tport->dma_base = devm_platform_get_and_ioremap_resource(pdev, 0, NULL);\n\tif (IS_ERR(port->dma_base)) {\n\t\tdev_err(dev, \"get DMA address failed\\n\");\n\t\treturn PTR_ERR(port->dma_base);\n\t}\n\n\t \n\tport->gmac_base = devm_platform_get_and_ioremap_resource(pdev, 1, NULL);\n\tif (IS_ERR(port->gmac_base)) {\n\t\tdev_err(dev, \"get GMAC address failed\\n\");\n\t\treturn PTR_ERR(port->gmac_base);\n\t}\n\n\t \n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\tport->irq = irq;\n\n\t \n\tport->pclk = devm_clk_get(dev, \"PCLK\");\n\tif (IS_ERR(port->pclk)) {\n\t\tdev_err(dev, \"no PCLK\\n\");\n\t\treturn PTR_ERR(port->pclk);\n\t}\n\tret = clk_prepare_enable(port->pclk);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tgemini_port_save_mac_addr(port);\n\n\t \n\tport->reset = devm_reset_control_get_exclusive(dev, NULL);\n\tif (IS_ERR(port->reset)) {\n\t\tdev_err(dev, \"no reset\\n\");\n\t\tret = PTR_ERR(port->reset);\n\t\tgoto unprepare;\n\t}\n\treset_control_reset(port->reset);\n\tusleep_range(100, 500);\n\n\t \n\tif (!id)\n\t\tgeth->port0 = port;\n\telse\n\t\tgeth->port1 = port;\n\n\t \n\tgemini_ethernet_init(geth);\n\n\tplatform_set_drvdata(pdev, port);\n\n\t \n\tnetdev->dev_id = port->id;\n\tnetdev->irq = irq;\n\tnetdev->netdev_ops = &gmac_351x_ops;\n\tnetdev->ethtool_ops = &gmac_351x_ethtool_ops;\n\n\tspin_lock_init(&port->config_lock);\n\tgmac_clear_hw_stats(netdev);\n\n\tnetdev->hw_features = GMAC_OFFLOAD_FEATURES;\n\tnetdev->features |= GMAC_OFFLOAD_FEATURES | NETIF_F_GRO;\n\t \n\tnetdev->min_mtu = ETH_MIN_MTU;\n\tnetdev->max_mtu = MTU_SIZE_BIT_MASK - VLAN_ETH_HLEN;\n\n\tport->freeq_refill = 0;\n\tnetif_napi_add(netdev, &port->napi, gmac_napi_poll);\n\n\tret = of_get_mac_address(np, mac);\n\tif (!ret) {\n\t\tdev_info(dev, \"Setting macaddr from DT %pM\\n\", mac);\n\t\tmemcpy(port->mac_addr, mac, ETH_ALEN);\n\t}\n\n\tif (is_valid_ether_addr((void *)port->mac_addr)) {\n\t\teth_hw_addr_set(netdev, (u8 *)port->mac_addr);\n\t} else {\n\t\tdev_dbg(dev, \"ethernet address 0x%08x%08x%08x invalid\\n\",\n\t\t\tport->mac_addr[0], port->mac_addr[1],\n\t\t\tport->mac_addr[2]);\n\t\tdev_info(dev, \"using a random ethernet address\\n\");\n\t\teth_hw_addr_random(netdev);\n\t}\n\tgmac_write_mac_address(netdev);\n\n\tret = devm_request_threaded_irq(port->dev,\n\t\t\t\t\tport->irq,\n\t\t\t\t\tgemini_port_irq,\n\t\t\t\t\tgemini_port_irq_thread,\n\t\t\t\t\tIRQF_SHARED,\n\t\t\t\t\tport_names[port->id],\n\t\t\t\t\tport);\n\tif (ret)\n\t\tgoto unprepare;\n\n\tret = gmac_setup_phy(netdev);\n\tif (ret) {\n\t\tnetdev_err(netdev,\n\t\t\t   \"PHY init failed\\n\");\n\t\tgoto unprepare;\n\t}\n\n\tret = register_netdev(netdev);\n\tif (ret)\n\t\tgoto unprepare;\n\n\treturn 0;\n\nunprepare:\n\tclk_disable_unprepare(port->pclk);\n\treturn ret;\n}\n\nstatic int gemini_ethernet_port_remove(struct platform_device *pdev)\n{\n\tstruct gemini_ethernet_port *port = platform_get_drvdata(pdev);\n\n\tgemini_port_remove(port);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id gemini_ethernet_port_of_match[] = {\n\t{\n\t\t.compatible = \"cortina,gemini-ethernet-port\",\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, gemini_ethernet_port_of_match);\n\nstatic struct platform_driver gemini_ethernet_port_driver = {\n\t.driver = {\n\t\t.name = \"gemini-ethernet-port\",\n\t\t.of_match_table = gemini_ethernet_port_of_match,\n\t},\n\t.probe = gemini_ethernet_port_probe,\n\t.remove = gemini_ethernet_port_remove,\n};\n\nstatic int gemini_ethernet_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct gemini_ethernet *geth;\n\tunsigned int retry = 5;\n\tu32 val;\n\n\t \n\tgeth = devm_kzalloc(dev, sizeof(*geth), GFP_KERNEL);\n\tif (!geth)\n\t\treturn -ENOMEM;\n\tgeth->base = devm_platform_get_and_ioremap_resource(pdev, 0, NULL);\n\tif (IS_ERR(geth->base))\n\t\treturn PTR_ERR(geth->base);\n\tgeth->dev = dev;\n\n\t \n\tdo {\n\t\tudelay(2);\n\t\tval = readl(geth->base + GLOBAL_TOE_VERSION_REG);\n\t\tbarrier();\n\t} while (!val && --retry);\n\tif (!retry) {\n\t\tdev_err(dev, \"failed to reset ethernet\\n\");\n\t\treturn -EIO;\n\t}\n\tdev_info(dev, \"Ethernet device ID: 0x%03x, revision 0x%01x\\n\",\n\t\t (val >> 4) & 0xFFFU, val & 0xFU);\n\n\tspin_lock_init(&geth->irq_lock);\n\tspin_lock_init(&geth->freeq_lock);\n\n\t \n\tplatform_set_drvdata(pdev, geth);\n\n\t \n\treturn devm_of_platform_populate(dev);\n}\n\nstatic int gemini_ethernet_remove(struct platform_device *pdev)\n{\n\tstruct gemini_ethernet *geth = platform_get_drvdata(pdev);\n\n\tgeth_cleanup_freeq(geth);\n\tgeth->initialized = false;\n\n\treturn 0;\n}\n\nstatic const struct of_device_id gemini_ethernet_of_match[] = {\n\t{\n\t\t.compatible = \"cortina,gemini-ethernet\",\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, gemini_ethernet_of_match);\n\nstatic struct platform_driver gemini_ethernet_driver = {\n\t.driver = {\n\t\t.name = DRV_NAME,\n\t\t.of_match_table = gemini_ethernet_of_match,\n\t},\n\t.probe = gemini_ethernet_probe,\n\t.remove = gemini_ethernet_remove,\n};\n\nstatic int __init gemini_ethernet_module_init(void)\n{\n\tint ret;\n\n\tret = platform_driver_register(&gemini_ethernet_port_driver);\n\tif (ret)\n\t\treturn ret;\n\n\tret = platform_driver_register(&gemini_ethernet_driver);\n\tif (ret) {\n\t\tplatform_driver_unregister(&gemini_ethernet_port_driver);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\nmodule_init(gemini_ethernet_module_init);\n\nstatic void __exit gemini_ethernet_module_exit(void)\n{\n\tplatform_driver_unregister(&gemini_ethernet_driver);\n\tplatform_driver_unregister(&gemini_ethernet_port_driver);\n}\nmodule_exit(gemini_ethernet_module_exit);\n\nMODULE_AUTHOR(\"Linus Walleij <linus.walleij@linaro.org>\");\nMODULE_DESCRIPTION(\"StorLink SL351x (Gemini) ethernet driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:\" DRV_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}