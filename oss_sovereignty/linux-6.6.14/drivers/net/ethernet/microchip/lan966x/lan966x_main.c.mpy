{
  "module_name": "lan966x_main.c",
  "hash_id": "1e9d3c6a5c1b7040cc2026cc04fc68c678426fc5989ace760cabd254def96330",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/microchip/lan966x/lan966x_main.c",
  "human_readable_source": "\n\n#include <linux/module.h>\n#include <linux/if_bridge.h>\n#include <linux/if_vlan.h>\n#include <linux/iopoll.h>\n#include <linux/ip.h>\n#include <linux/of.h>\n#include <linux/of_net.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_device.h>\n#include <linux/reset.h>\n#include <net/addrconf.h>\n\n#include \"lan966x_main.h\"\n\n#define XTR_EOF_0\t\t\t0x00000080U\n#define XTR_EOF_1\t\t\t0x01000080U\n#define XTR_EOF_2\t\t\t0x02000080U\n#define XTR_EOF_3\t\t\t0x03000080U\n#define XTR_PRUNED\t\t\t0x04000080U\n#define XTR_ABORT\t\t\t0x05000080U\n#define XTR_ESCAPE\t\t\t0x06000080U\n#define XTR_NOT_READY\t\t\t0x07000080U\n#define XTR_VALID_BYTES(x)\t\t(4 - (((x) >> 24) & 3))\n\n#define IO_RANGES 2\n\nstatic const struct of_device_id lan966x_match[] = {\n\t{ .compatible = \"microchip,lan966x-switch\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, lan966x_match);\n\nstruct lan966x_main_io_resource {\n\tenum lan966x_target id;\n\tphys_addr_t offset;\n\tint range;\n};\n\nstatic const struct lan966x_main_io_resource lan966x_main_iomap[] =  {\n\t{ TARGET_CPU,                   0xc0000, 0 },  \n\t{ TARGET_FDMA,                  0xc0400, 0 },  \n\t{ TARGET_ORG,                         0, 1 },  \n\t{ TARGET_GCB,                    0x4000, 1 },  \n\t{ TARGET_QS,                     0x8000, 1 },  \n\t{ TARGET_PTP,                    0xc000, 1 },  \n\t{ TARGET_CHIP_TOP,              0x10000, 1 },  \n\t{ TARGET_REW,                   0x14000, 1 },  \n\t{ TARGET_VCAP,                  0x18000, 1 },  \n\t{ TARGET_VCAP + 1,              0x20000, 1 },  \n\t{ TARGET_VCAP + 2,              0x24000, 1 },  \n\t{ TARGET_SYS,                   0x28000, 1 },  \n\t{ TARGET_DEV,                   0x34000, 1 },  \n\t{ TARGET_DEV +  1,              0x38000, 1 },  \n\t{ TARGET_DEV +  2,              0x3c000, 1 },  \n\t{ TARGET_DEV +  3,              0x40000, 1 },  \n\t{ TARGET_DEV +  4,              0x44000, 1 },  \n\t{ TARGET_DEV +  5,              0x48000, 1 },  \n\t{ TARGET_DEV +  6,              0x4c000, 1 },  \n\t{ TARGET_DEV +  7,              0x50000, 1 },  \n\t{ TARGET_QSYS,                 0x100000, 1 },  \n\t{ TARGET_AFI,                  0x120000, 1 },  \n\t{ TARGET_ANA,                  0x140000, 1 },  \n};\n\nstatic int lan966x_create_targets(struct platform_device *pdev,\n\t\t\t\t  struct lan966x *lan966x)\n{\n\tstruct resource *iores[IO_RANGES];\n\tvoid __iomem *begin[IO_RANGES];\n\tint idx;\n\n\t \n\tfor (idx = 0; idx < IO_RANGES; idx++) {\n\t\tiores[idx] = platform_get_resource(pdev, IORESOURCE_MEM,\n\t\t\t\t\t\t   idx);\n\t\tif (!iores[idx]) {\n\t\t\tdev_err(&pdev->dev, \"Invalid resource\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tbegin[idx] = devm_ioremap(&pdev->dev,\n\t\t\t\t\t  iores[idx]->start,\n\t\t\t\t\t  resource_size(iores[idx]));\n\t\tif (!begin[idx]) {\n\t\t\tdev_err(&pdev->dev, \"Unable to get registers: %s\\n\",\n\t\t\t\tiores[idx]->name);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tfor (idx = 0; idx < ARRAY_SIZE(lan966x_main_iomap); idx++) {\n\t\tconst struct lan966x_main_io_resource *iomap =\n\t\t\t&lan966x_main_iomap[idx];\n\n\t\tlan966x->regs[iomap->id] = begin[iomap->range] + iomap->offset;\n\t}\n\n\treturn 0;\n}\n\nstatic bool lan966x_port_unique_address(struct net_device *dev)\n{\n\tstruct lan966x_port *port = netdev_priv(dev);\n\tstruct lan966x *lan966x = port->lan966x;\n\tint p;\n\n\tfor (p = 0; p < lan966x->num_phys_ports; ++p) {\n\t\tport = lan966x->ports[p];\n\t\tif (!port || port->dev == dev)\n\t\t\tcontinue;\n\n\t\tif (ether_addr_equal(dev->dev_addr, port->dev->dev_addr))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic int lan966x_port_set_mac_address(struct net_device *dev, void *p)\n{\n\tstruct lan966x_port *port = netdev_priv(dev);\n\tstruct lan966x *lan966x = port->lan966x;\n\tconst struct sockaddr *addr = p;\n\tint ret;\n\n\tif (ether_addr_equal(addr->sa_data, dev->dev_addr))\n\t\treturn 0;\n\n\t \n\tret = lan966x_mac_cpu_learn(lan966x, addr->sa_data, HOST_PVID);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (!lan966x_port_unique_address(dev))\n\t\tgoto out;\n\n\t \n\tret = lan966x_mac_cpu_forget(lan966x, dev->dev_addr, HOST_PVID);\n\tif (ret)\n\t\treturn ret;\n\nout:\n\teth_hw_addr_set(dev, addr->sa_data);\n\treturn ret;\n}\n\nstatic int lan966x_port_get_phys_port_name(struct net_device *dev,\n\t\t\t\t\t   char *buf, size_t len)\n{\n\tstruct lan966x_port *port = netdev_priv(dev);\n\tint ret;\n\n\tret = snprintf(buf, len, \"p%d\", port->chip_port);\n\tif (ret >= len)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int lan966x_port_open(struct net_device *dev)\n{\n\tstruct lan966x_port *port = netdev_priv(dev);\n\tstruct lan966x *lan966x = port->lan966x;\n\tint err;\n\n\t \n\tlan_rmw(ANA_PORT_CFG_LEARNAUTO_SET(1) |\n\t\tANA_PORT_CFG_RECV_ENA_SET(1) |\n\t\tANA_PORT_CFG_PORTID_VAL_SET(port->chip_port),\n\t\tANA_PORT_CFG_LEARNAUTO |\n\t\tANA_PORT_CFG_RECV_ENA |\n\t\tANA_PORT_CFG_PORTID_VAL,\n\t\tlan966x, ANA_PORT_CFG(port->chip_port));\n\n\terr = phylink_fwnode_phy_connect(port->phylink, port->fwnode, 0);\n\tif (err) {\n\t\tnetdev_err(dev, \"Could not attach to PHY\\n\");\n\t\treturn err;\n\t}\n\n\tphylink_start(port->phylink);\n\n\treturn 0;\n}\n\nstatic int lan966x_port_stop(struct net_device *dev)\n{\n\tstruct lan966x_port *port = netdev_priv(dev);\n\n\tlan966x_port_config_down(port);\n\tphylink_stop(port->phylink);\n\tphylink_disconnect_phy(port->phylink);\n\n\treturn 0;\n}\n\nstatic int lan966x_port_inj_status(struct lan966x *lan966x)\n{\n\treturn lan_rd(lan966x, QS_INJ_STATUS);\n}\n\nstatic int lan966x_port_inj_ready(struct lan966x *lan966x, u8 grp)\n{\n\tu32 val;\n\n\tif (lan_rd(lan966x, QS_INJ_STATUS) & QS_INJ_STATUS_FIFO_RDY_SET(BIT(grp)))\n\t\treturn 0;\n\n\treturn readx_poll_timeout_atomic(lan966x_port_inj_status, lan966x, val,\n\t\t\t\t\t QS_INJ_STATUS_FIFO_RDY_GET(val) & BIT(grp),\n\t\t\t\t\t READL_SLEEP_US, READL_TIMEOUT_US);\n}\n\nstatic int lan966x_port_ifh_xmit(struct sk_buff *skb,\n\t\t\t\t __be32 *ifh,\n\t\t\t\t struct net_device *dev)\n{\n\tstruct lan966x_port *port = netdev_priv(dev);\n\tstruct lan966x *lan966x = port->lan966x;\n\tu32 i, count, last;\n\tu8 grp = 0;\n\tu32 val;\n\tint err;\n\n\tval = lan_rd(lan966x, QS_INJ_STATUS);\n\tif (!(QS_INJ_STATUS_FIFO_RDY_GET(val) & BIT(grp)) ||\n\t    (QS_INJ_STATUS_WMARK_REACHED_GET(val) & BIT(grp)))\n\t\tgoto err;\n\n\t \n\tlan_wr(QS_INJ_CTRL_GAP_SIZE_SET(1) |\n\t       QS_INJ_CTRL_SOF_SET(1),\n\t       lan966x, QS_INJ_CTRL(grp));\n\n\t \n\tfor (i = 0; i < IFH_LEN; ++i) {\n\t\t \n\t\terr = lan966x_port_inj_ready(lan966x, grp);\n\t\tif (err)\n\t\t\tgoto err;\n\n\t\tlan_wr((__force u32)ifh[i], lan966x, QS_INJ_WR(grp));\n\t}\n\n\t \n\tcount = DIV_ROUND_UP(skb->len, 4);\n\tlast = skb->len % 4;\n\tfor (i = 0; i < count; ++i) {\n\t\t \n\t\terr = lan966x_port_inj_ready(lan966x, grp);\n\t\tif (err)\n\t\t\tgoto err;\n\n\t\tlan_wr(((u32 *)skb->data)[i], lan966x, QS_INJ_WR(grp));\n\t}\n\n\t \n\twhile (i < (LAN966X_BUFFER_MIN_SZ / 4)) {\n\t\t \n\t\terr = lan966x_port_inj_ready(lan966x, grp);\n\t\tif (err)\n\t\t\tgoto err;\n\n\t\tlan_wr(0, lan966x, QS_INJ_WR(grp));\n\t\t++i;\n\t}\n\n\t \n\tlan_wr(QS_INJ_CTRL_GAP_SIZE_SET(1) |\n\t       QS_INJ_CTRL_VLD_BYTES_SET(skb->len < LAN966X_BUFFER_MIN_SZ ?\n\t\t\t\t     0 : last) |\n\t       QS_INJ_CTRL_EOF_SET(1),\n\t       lan966x, QS_INJ_CTRL(grp));\n\n\t \n\tlan_wr(0, lan966x, QS_INJ_WR(grp));\n\tskb_tx_timestamp(skb);\n\n\tdev->stats.tx_packets++;\n\tdev->stats.tx_bytes += skb->len;\n\n\tif (skb_shinfo(skb)->tx_flags & SKBTX_HW_TSTAMP &&\n\t    LAN966X_SKB_CB(skb)->rew_op == IFH_REW_OP_TWO_STEP_PTP)\n\t\treturn NETDEV_TX_OK;\n\n\tdev_consume_skb_any(skb);\n\treturn NETDEV_TX_OK;\n\nerr:\n\tif (skb_shinfo(skb)->tx_flags & SKBTX_HW_TSTAMP &&\n\t    LAN966X_SKB_CB(skb)->rew_op == IFH_REW_OP_TWO_STEP_PTP)\n\t\tlan966x_ptp_txtstamp_release(port, skb);\n\n\treturn NETDEV_TX_BUSY;\n}\n\nstatic void lan966x_ifh_set(u8 *ifh, size_t val, size_t pos, size_t length)\n{\n\tint i = 0;\n\n\tdo {\n\t\tu8 p = IFH_LEN_BYTES - (pos + i) / 8 - 1;\n\t\tu8 v = val >> i & 0xff;\n\n\t\t \n\t\tifh[p] |= v << ((pos + i) % 8);\n\t\tifh[p - 1] |= v >> (8 - (pos + i) % 8);\n\n\t\ti += 8;\n\t} while (i < length);\n}\n\nvoid lan966x_ifh_set_bypass(void *ifh, u64 bypass)\n{\n\tlan966x_ifh_set(ifh, bypass, IFH_POS_BYPASS, IFH_WID_BYPASS);\n}\n\nvoid lan966x_ifh_set_port(void *ifh, u64 port)\n{\n\tlan966x_ifh_set(ifh, port, IFH_POS_DSTS, IFH_WID_DSTS);\n}\n\nstatic void lan966x_ifh_set_qos_class(void *ifh, u64 qos)\n{\n\tlan966x_ifh_set(ifh, qos, IFH_POS_QOS_CLASS, IFH_WID_QOS_CLASS);\n}\n\nstatic void lan966x_ifh_set_ipv(void *ifh, u64 ipv)\n{\n\tlan966x_ifh_set(ifh, ipv, IFH_POS_IPV, IFH_WID_IPV);\n}\n\nstatic void lan966x_ifh_set_vid(void *ifh, u64 vid)\n{\n\tlan966x_ifh_set(ifh, vid, IFH_POS_TCI, IFH_WID_TCI);\n}\n\nstatic void lan966x_ifh_set_rew_op(void *ifh, u64 rew_op)\n{\n\tlan966x_ifh_set(ifh, rew_op, IFH_POS_REW_CMD, IFH_WID_REW_CMD);\n}\n\nstatic void lan966x_ifh_set_timestamp(void *ifh, u64 timestamp)\n{\n\tlan966x_ifh_set(ifh, timestamp, IFH_POS_TIMESTAMP, IFH_WID_TIMESTAMP);\n}\n\nstatic netdev_tx_t lan966x_port_xmit(struct sk_buff *skb,\n\t\t\t\t     struct net_device *dev)\n{\n\tstruct lan966x_port *port = netdev_priv(dev);\n\tstruct lan966x *lan966x = port->lan966x;\n\t__be32 ifh[IFH_LEN];\n\tint err;\n\n\tmemset(ifh, 0x0, sizeof(__be32) * IFH_LEN);\n\n\tlan966x_ifh_set_bypass(ifh, 1);\n\tlan966x_ifh_set_port(ifh, BIT_ULL(port->chip_port));\n\tlan966x_ifh_set_qos_class(ifh, skb->priority >= 7 ? 0x7 : skb->priority);\n\tlan966x_ifh_set_ipv(ifh, skb->priority >= 7 ? 0x7 : skb->priority);\n\tlan966x_ifh_set_vid(ifh, skb_vlan_tag_get(skb));\n\n\tif (port->lan966x->ptp && skb_shinfo(skb)->tx_flags & SKBTX_HW_TSTAMP) {\n\t\terr = lan966x_ptp_txtstamp_request(port, skb);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tlan966x_ifh_set_rew_op(ifh, LAN966X_SKB_CB(skb)->rew_op);\n\t\tlan966x_ifh_set_timestamp(ifh, LAN966X_SKB_CB(skb)->ts_id);\n\t}\n\n\tspin_lock(&lan966x->tx_lock);\n\tif (port->lan966x->fdma)\n\t\terr = lan966x_fdma_xmit(skb, ifh, dev);\n\telse\n\t\terr = lan966x_port_ifh_xmit(skb, ifh, dev);\n\tspin_unlock(&lan966x->tx_lock);\n\n\treturn err;\n}\n\nstatic int lan966x_port_change_mtu(struct net_device *dev, int new_mtu)\n{\n\tstruct lan966x_port *port = netdev_priv(dev);\n\tstruct lan966x *lan966x = port->lan966x;\n\tint old_mtu = dev->mtu;\n\tint err;\n\n\tlan_wr(DEV_MAC_MAXLEN_CFG_MAX_LEN_SET(LAN966X_HW_MTU(new_mtu)),\n\t       lan966x, DEV_MAC_MAXLEN_CFG(port->chip_port));\n\tdev->mtu = new_mtu;\n\n\tif (!lan966x->fdma)\n\t\treturn 0;\n\n\terr = lan966x_fdma_change_mtu(lan966x);\n\tif (err) {\n\t\tlan_wr(DEV_MAC_MAXLEN_CFG_MAX_LEN_SET(LAN966X_HW_MTU(old_mtu)),\n\t\t       lan966x, DEV_MAC_MAXLEN_CFG(port->chip_port));\n\t\tdev->mtu = old_mtu;\n\t}\n\n\treturn err;\n}\n\nstatic int lan966x_mc_unsync(struct net_device *dev, const unsigned char *addr)\n{\n\tstruct lan966x_port *port = netdev_priv(dev);\n\tstruct lan966x *lan966x = port->lan966x;\n\n\treturn lan966x_mac_forget(lan966x, addr, HOST_PVID, ENTRYTYPE_LOCKED);\n}\n\nstatic int lan966x_mc_sync(struct net_device *dev, const unsigned char *addr)\n{\n\tstruct lan966x_port *port = netdev_priv(dev);\n\tstruct lan966x *lan966x = port->lan966x;\n\n\treturn lan966x_mac_cpu_learn(lan966x, addr, HOST_PVID);\n}\n\nstatic void lan966x_port_set_rx_mode(struct net_device *dev)\n{\n\t__dev_mc_sync(dev, lan966x_mc_sync, lan966x_mc_unsync);\n}\n\nstatic int lan966x_port_get_parent_id(struct net_device *dev,\n\t\t\t\t      struct netdev_phys_item_id *ppid)\n{\n\tstruct lan966x_port *port = netdev_priv(dev);\n\tstruct lan966x *lan966x = port->lan966x;\n\n\tppid->id_len = sizeof(lan966x->base_mac);\n\tmemcpy(&ppid->id, &lan966x->base_mac, ppid->id_len);\n\n\treturn 0;\n}\n\nstatic int lan966x_port_hwtstamp_get(struct net_device *dev,\n\t\t\t\t     struct kernel_hwtstamp_config *cfg)\n{\n\tstruct lan966x_port *port = netdev_priv(dev);\n\n\tif (!port->lan966x->ptp)\n\t\treturn -EOPNOTSUPP;\n\n\tlan966x_ptp_hwtstamp_get(port, cfg);\n\n\treturn 0;\n}\n\nstatic int lan966x_port_hwtstamp_set(struct net_device *dev,\n\t\t\t\t     struct kernel_hwtstamp_config *cfg,\n\t\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct lan966x_port *port = netdev_priv(dev);\n\tint err;\n\n\tif (cfg->source != HWTSTAMP_SOURCE_NETDEV &&\n\t    cfg->source != HWTSTAMP_SOURCE_PHYLIB)\n\t\treturn -EOPNOTSUPP;\n\n\terr = lan966x_ptp_setup_traps(port, cfg);\n\tif (err)\n\t\treturn err;\n\n\tif (cfg->source == HWTSTAMP_SOURCE_NETDEV) {\n\t\tif (!port->lan966x->ptp)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\terr = lan966x_ptp_hwtstamp_set(port, cfg, extack);\n\t\tif (err) {\n\t\t\tlan966x_ptp_del_traps(port);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic const struct net_device_ops lan966x_port_netdev_ops = {\n\t.ndo_open\t\t\t= lan966x_port_open,\n\t.ndo_stop\t\t\t= lan966x_port_stop,\n\t.ndo_start_xmit\t\t\t= lan966x_port_xmit,\n\t.ndo_change_mtu\t\t\t= lan966x_port_change_mtu,\n\t.ndo_set_rx_mode\t\t= lan966x_port_set_rx_mode,\n\t.ndo_get_phys_port_name\t\t= lan966x_port_get_phys_port_name,\n\t.ndo_get_stats64\t\t= lan966x_stats_get,\n\t.ndo_set_mac_address\t\t= lan966x_port_set_mac_address,\n\t.ndo_get_port_parent_id\t\t= lan966x_port_get_parent_id,\n\t.ndo_eth_ioctl\t\t\t= phy_do_ioctl,\n\t.ndo_setup_tc\t\t\t= lan966x_tc_setup,\n\t.ndo_bpf\t\t\t= lan966x_xdp,\n\t.ndo_xdp_xmit\t\t\t= lan966x_xdp_xmit,\n\t.ndo_hwtstamp_get\t\t= lan966x_port_hwtstamp_get,\n\t.ndo_hwtstamp_set\t\t= lan966x_port_hwtstamp_set,\n};\n\nbool lan966x_netdevice_check(const struct net_device *dev)\n{\n\treturn dev->netdev_ops == &lan966x_port_netdev_ops;\n}\n\nbool lan966x_hw_offload(struct lan966x *lan966x, u32 port, struct sk_buff *skb)\n{\n\tu32 val;\n\n\t \n\tval = lan_rd(lan966x, ANA_CPU_FWD_CFG(port));\n\tif (!(val & (ANA_CPU_FWD_CFG_IGMP_REDIR_ENA |\n\t\t     ANA_CPU_FWD_CFG_MLD_REDIR_ENA)))\n\t\treturn true;\n\n\tif (eth_type_vlan(skb->protocol)) {\n\t\tskb = skb_vlan_untag(skb);\n\t\tif (unlikely(!skb))\n\t\t\treturn false;\n\t}\n\n\tif (skb->protocol == htons(ETH_P_IP) &&\n\t    ip_hdr(skb)->protocol == IPPROTO_IGMP)\n\t\treturn false;\n\n\tif (IS_ENABLED(CONFIG_IPV6) &&\n\t    skb->protocol == htons(ETH_P_IPV6) &&\n\t    ipv6_addr_is_multicast(&ipv6_hdr(skb)->daddr) &&\n\t    !ipv6_mc_check_mld(skb))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic int lan966x_port_xtr_status(struct lan966x *lan966x, u8 grp)\n{\n\treturn lan_rd(lan966x, QS_XTR_RD(grp));\n}\n\nstatic int lan966x_port_xtr_ready(struct lan966x *lan966x, u8 grp)\n{\n\tu32 val;\n\n\treturn read_poll_timeout(lan966x_port_xtr_status, val,\n\t\t\t\t val != XTR_NOT_READY,\n\t\t\t\t READL_SLEEP_US, READL_TIMEOUT_US, false,\n\t\t\t\t lan966x, grp);\n}\n\nstatic int lan966x_rx_frame_word(struct lan966x *lan966x, u8 grp, u32 *rval)\n{\n\tu32 bytes_valid;\n\tu32 val;\n\tint err;\n\n\tval = lan_rd(lan966x, QS_XTR_RD(grp));\n\tif (val == XTR_NOT_READY) {\n\t\terr = lan966x_port_xtr_ready(lan966x, grp);\n\t\tif (err)\n\t\t\treturn -EIO;\n\t}\n\n\tswitch (val) {\n\tcase XTR_ABORT:\n\t\treturn -EIO;\n\tcase XTR_EOF_0:\n\tcase XTR_EOF_1:\n\tcase XTR_EOF_2:\n\tcase XTR_EOF_3:\n\tcase XTR_PRUNED:\n\t\tbytes_valid = XTR_VALID_BYTES(val);\n\t\tval = lan_rd(lan966x, QS_XTR_RD(grp));\n\t\tif (val == XTR_ESCAPE)\n\t\t\t*rval = lan_rd(lan966x, QS_XTR_RD(grp));\n\t\telse\n\t\t\t*rval = val;\n\n\t\treturn bytes_valid;\n\tcase XTR_ESCAPE:\n\t\t*rval = lan_rd(lan966x, QS_XTR_RD(grp));\n\n\t\treturn 4;\n\tdefault:\n\t\t*rval = val;\n\n\t\treturn 4;\n\t}\n}\n\nstatic u64 lan966x_ifh_get(u8 *ifh, size_t pos, size_t length)\n{\n\tu64 val = 0;\n\tu8 v;\n\n\tfor (int i = 0; i < length ; i++) {\n\t\tint j = pos + i;\n\t\tint k = j % 8;\n\n\t\tif (i == 0 || k == 0)\n\t\t\tv = ifh[IFH_LEN_BYTES - (j / 8) - 1];\n\n\t\tif (v & (1 << k))\n\t\t\tval |= (1ULL << i);\n\t}\n\n\treturn val;\n}\n\nvoid lan966x_ifh_get_src_port(void *ifh, u64 *src_port)\n{\n\t*src_port = lan966x_ifh_get(ifh, IFH_POS_SRCPORT, IFH_WID_SRCPORT);\n}\n\nstatic void lan966x_ifh_get_len(void *ifh, u64 *len)\n{\n\t*len = lan966x_ifh_get(ifh, IFH_POS_LEN, IFH_WID_LEN);\n}\n\nvoid lan966x_ifh_get_timestamp(void *ifh, u64 *timestamp)\n{\n\t*timestamp = lan966x_ifh_get(ifh, IFH_POS_TIMESTAMP, IFH_WID_TIMESTAMP);\n}\n\nstatic irqreturn_t lan966x_xtr_irq_handler(int irq, void *args)\n{\n\tstruct lan966x *lan966x = args;\n\tint i, grp = 0, err = 0;\n\n\tif (!(lan_rd(lan966x, QS_XTR_DATA_PRESENT) & BIT(grp)))\n\t\treturn IRQ_NONE;\n\n\tdo {\n\t\tu64 src_port, len, timestamp;\n\t\tstruct net_device *dev;\n\t\tstruct sk_buff *skb;\n\t\tint sz = 0, buf_len;\n\t\tu32 ifh[IFH_LEN];\n\t\tu32 *buf;\n\t\tu32 val;\n\n\t\tfor (i = 0; i < IFH_LEN; i++) {\n\t\t\terr = lan966x_rx_frame_word(lan966x, grp, &ifh[i]);\n\t\t\tif (err != 4)\n\t\t\t\tgoto recover;\n\t\t}\n\n\t\terr = 0;\n\n\t\tlan966x_ifh_get_src_port(ifh, &src_port);\n\t\tlan966x_ifh_get_len(ifh, &len);\n\t\tlan966x_ifh_get_timestamp(ifh, &timestamp);\n\n\t\tWARN_ON(src_port >= lan966x->num_phys_ports);\n\n\t\tdev = lan966x->ports[src_port]->dev;\n\t\tskb = netdev_alloc_skb(dev, len);\n\t\tif (unlikely(!skb)) {\n\t\t\tnetdev_err(dev, \"Unable to allocate sk_buff\\n\");\n\t\t\terr = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t\tbuf_len = len - ETH_FCS_LEN;\n\t\tbuf = (u32 *)skb_put(skb, buf_len);\n\n\t\tlen = 0;\n\t\tdo {\n\t\t\tsz = lan966x_rx_frame_word(lan966x, grp, &val);\n\t\t\tif (sz < 0) {\n\t\t\t\tkfree_skb(skb);\n\t\t\t\tgoto recover;\n\t\t\t}\n\n\t\t\t*buf++ = val;\n\t\t\tlen += sz;\n\t\t} while (len < buf_len);\n\n\t\t \n\t\tsz = lan966x_rx_frame_word(lan966x, grp, &val);\n\t\tif (sz < 0) {\n\t\t\tkfree_skb(skb);\n\t\t\tgoto recover;\n\t\t}\n\n\t\t \n\t\tlen -= ETH_FCS_LEN - sz;\n\n\t\tif (unlikely(dev->features & NETIF_F_RXFCS)) {\n\t\t\tbuf = (u32 *)skb_put(skb, ETH_FCS_LEN);\n\t\t\t*buf = val;\n\t\t}\n\n\t\tlan966x_ptp_rxtstamp(lan966x, skb, src_port, timestamp);\n\t\tskb->protocol = eth_type_trans(skb, dev);\n\n\t\tif (lan966x->bridge_mask & BIT(src_port)) {\n\t\t\tskb->offload_fwd_mark = 1;\n\n\t\t\tskb_reset_network_header(skb);\n\t\t\tif (!lan966x_hw_offload(lan966x, src_port, skb))\n\t\t\t\tskb->offload_fwd_mark = 0;\n\t\t}\n\n\t\tif (!skb_defer_rx_timestamp(skb))\n\t\t\tnetif_rx(skb);\n\n\t\tdev->stats.rx_bytes += len;\n\t\tdev->stats.rx_packets++;\n\nrecover:\n\t\tif (sz < 0 || err)\n\t\t\tlan_rd(lan966x, QS_XTR_RD(grp));\n\n\t} while (lan_rd(lan966x, QS_XTR_DATA_PRESENT) & BIT(grp));\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t lan966x_ana_irq_handler(int irq, void *args)\n{\n\tstruct lan966x *lan966x = args;\n\n\treturn lan966x_mac_irq_handler(lan966x);\n}\n\nstatic void lan966x_cleanup_ports(struct lan966x *lan966x)\n{\n\tstruct lan966x_port *port;\n\tint p;\n\n\tfor (p = 0; p < lan966x->num_phys_ports; p++) {\n\t\tport = lan966x->ports[p];\n\t\tif (!port)\n\t\t\tcontinue;\n\n\t\tif (port->dev)\n\t\t\tunregister_netdev(port->dev);\n\n\t\tlan966x_xdp_port_deinit(port);\n\t\tif (lan966x->fdma && lan966x->fdma_ndev == port->dev)\n\t\t\tlan966x_fdma_netdev_deinit(lan966x, port->dev);\n\n\t\tif (port->phylink) {\n\t\t\trtnl_lock();\n\t\t\tlan966x_port_stop(port->dev);\n\t\t\trtnl_unlock();\n\t\t\tphylink_destroy(port->phylink);\n\t\t\tport->phylink = NULL;\n\t\t}\n\n\t\tif (port->fwnode)\n\t\t\tfwnode_handle_put(port->fwnode);\n\t}\n\n\tdisable_irq(lan966x->xtr_irq);\n\tlan966x->xtr_irq = -ENXIO;\n\n\tif (lan966x->ana_irq > 0) {\n\t\tdisable_irq(lan966x->ana_irq);\n\t\tlan966x->ana_irq = -ENXIO;\n\t}\n\n\tif (lan966x->fdma)\n\t\tdevm_free_irq(lan966x->dev, lan966x->fdma_irq, lan966x);\n\n\tif (lan966x->ptp_irq > 0)\n\t\tdevm_free_irq(lan966x->dev, lan966x->ptp_irq, lan966x);\n\n\tif (lan966x->ptp_ext_irq > 0)\n\t\tdevm_free_irq(lan966x->dev, lan966x->ptp_ext_irq, lan966x);\n}\n\nstatic int lan966x_probe_port(struct lan966x *lan966x, u32 p,\n\t\t\t      phy_interface_t phy_mode,\n\t\t\t      struct fwnode_handle *portnp)\n{\n\tstruct lan966x_port *port;\n\tstruct phylink *phylink;\n\tstruct net_device *dev;\n\tint err;\n\n\tif (p >= lan966x->num_phys_ports)\n\t\treturn -EINVAL;\n\n\tdev = devm_alloc_etherdev_mqs(lan966x->dev,\n\t\t\t\t      sizeof(struct lan966x_port),\n\t\t\t\t      NUM_PRIO_QUEUES, 1);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tSET_NETDEV_DEV(dev, lan966x->dev);\n\tport = netdev_priv(dev);\n\tport->dev = dev;\n\tport->lan966x = lan966x;\n\tport->chip_port = p;\n\tlan966x->ports[p] = port;\n\n\tdev->max_mtu = ETH_MAX_MTU;\n\n\tdev->netdev_ops = &lan966x_port_netdev_ops;\n\tdev->ethtool_ops = &lan966x_ethtool_ops;\n\tdev->features |= NETIF_F_HW_VLAN_CTAG_TX |\n\t\t\t NETIF_F_HW_VLAN_STAG_TX |\n\t\t\t NETIF_F_HW_TC;\n\tdev->hw_features |= NETIF_F_HW_TC;\n\tdev->priv_flags |= IFF_SEE_ALL_HWTSTAMP_REQUESTS;\n\tdev->needed_headroom = IFH_LEN_BYTES;\n\n\teth_hw_addr_gen(dev, lan966x->base_mac, p + 1);\n\n\tlan966x_mac_learn(lan966x, PGID_CPU, dev->dev_addr, HOST_PVID,\n\t\t\t  ENTRYTYPE_LOCKED);\n\n\tport->phylink_config.dev = &port->dev->dev;\n\tport->phylink_config.type = PHYLINK_NETDEV;\n\tport->phylink_pcs.poll = true;\n\tport->phylink_pcs.ops = &lan966x_phylink_pcs_ops;\n\tport->phylink_pcs.neg_mode = true;\n\n\tport->phylink_config.mac_capabilities = MAC_ASYM_PAUSE | MAC_SYM_PAUSE |\n\t\tMAC_10 | MAC_100 | MAC_1000FD | MAC_2500FD;\n\n\tphy_interface_set_rgmii(port->phylink_config.supported_interfaces);\n\t__set_bit(PHY_INTERFACE_MODE_MII,\n\t\t  port->phylink_config.supported_interfaces);\n\t__set_bit(PHY_INTERFACE_MODE_GMII,\n\t\t  port->phylink_config.supported_interfaces);\n\t__set_bit(PHY_INTERFACE_MODE_SGMII,\n\t\t  port->phylink_config.supported_interfaces);\n\t__set_bit(PHY_INTERFACE_MODE_QSGMII,\n\t\t  port->phylink_config.supported_interfaces);\n\t__set_bit(PHY_INTERFACE_MODE_QUSGMII,\n\t\t  port->phylink_config.supported_interfaces);\n\t__set_bit(PHY_INTERFACE_MODE_1000BASEX,\n\t\t  port->phylink_config.supported_interfaces);\n\t__set_bit(PHY_INTERFACE_MODE_2500BASEX,\n\t\t  port->phylink_config.supported_interfaces);\n\n\tphylink = phylink_create(&port->phylink_config,\n\t\t\t\t portnp,\n\t\t\t\t phy_mode,\n\t\t\t\t &lan966x_phylink_mac_ops);\n\tif (IS_ERR(phylink)) {\n\t\tport->dev = NULL;\n\t\treturn PTR_ERR(phylink);\n\t}\n\n\tport->phylink = phylink;\n\n\tif (lan966x->fdma)\n\t\tdev->xdp_features = NETDEV_XDP_ACT_BASIC |\n\t\t\t\t    NETDEV_XDP_ACT_REDIRECT |\n\t\t\t\t    NETDEV_XDP_ACT_NDO_XMIT;\n\n\terr = register_netdev(dev);\n\tif (err) {\n\t\tdev_err(lan966x->dev, \"register_netdev failed\\n\");\n\t\treturn err;\n\t}\n\n\tlan966x_vlan_port_set_vlan_aware(port, 0);\n\tlan966x_vlan_port_set_vid(port, HOST_PVID, false, false);\n\tlan966x_vlan_port_apply(port);\n\n\treturn 0;\n}\n\nstatic void lan966x_init(struct lan966x *lan966x)\n{\n\tu32 p, i;\n\n\t \n\tlan966x_mac_init(lan966x);\n\n\tlan966x_vlan_init(lan966x);\n\n\t \n\tlan_wr(lan_rd(lan966x, QS_XTR_FLUSH) |\n\t       GENMASK(1, 0),\n\t       lan966x, QS_XTR_FLUSH);\n\n\t \n\tmdelay(1);\n\n\t \n\tlan_wr(lan_rd(lan966x, QS_XTR_FLUSH) &\n\t       ~(GENMASK(1, 0)),\n\t       lan966x, QS_XTR_FLUSH);\n\n\t \n\tlan_wr(ANA_AUTOAGE_AGE_PERIOD_SET(BR_DEFAULT_AGEING_TIME / 2 / HZ),\n\t       lan966x, ANA_AUTOAGE);\n\n\t \n\tlan_rmw(ANA_ADVLEARN_VLAN_CHK_SET(1),\n\t\tANA_ADVLEARN_VLAN_CHK,\n\t\tlan966x, ANA_ADVLEARN);\n\n\t \n\tlan_wr(SYS_FRM_AGING_AGE_TX_ENA_SET(1) |\n\t       (20000000 / 65),\n\t       lan966x,  SYS_FRM_AGING);\n\n\t \n\tlan_wr(0, lan966x, QSYS_CPU_GROUP_MAP);\n\n\t \n\tlan_wr(QS_XTR_GRP_CFG_MODE_SET(lan966x->fdma ? 2 : 1) |\n\t       QS_XTR_GRP_CFG_BYTE_SWAP_SET(1),\n\t       lan966x, QS_XTR_GRP_CFG(0));\n\n\t \n\tlan_wr(QS_INJ_GRP_CFG_MODE_SET(lan966x->fdma ? 2 : 1) |\n\t       QS_INJ_GRP_CFG_BYTE_SWAP_SET(1),\n\t       lan966x, QS_INJ_GRP_CFG(0));\n\n\tlan_rmw(QS_INJ_CTRL_GAP_SIZE_SET(0),\n\t\tQS_INJ_CTRL_GAP_SIZE,\n\t\tlan966x, QS_INJ_CTRL(0));\n\n\t \n\tlan_wr(SYS_PORT_MODE_INCL_INJ_HDR_SET(1) |\n\t       SYS_PORT_MODE_INCL_XTR_HDR_SET(1),\n\t       lan966x, SYS_PORT_MODE(CPU_PORT));\n\n\t \n\tlan_wr(ANA_FLOODING_IPMC_FLD_MC4_DATA_SET(PGID_MCIPV4) |\n\t       ANA_FLOODING_IPMC_FLD_MC4_CTRL_SET(PGID_MC) |\n\t       ANA_FLOODING_IPMC_FLD_MC6_DATA_SET(PGID_MCIPV6) |\n\t       ANA_FLOODING_IPMC_FLD_MC6_CTRL_SET(PGID_MC),\n\t       lan966x, ANA_FLOODING_IPMC);\n\n\t \n\tfor (i = 0; i < 8; ++i)\n\t\tlan_rmw(ANA_FLOODING_FLD_MULTICAST_SET(PGID_MC) |\n\t\t\tANA_FLOODING_FLD_UNICAST_SET(PGID_UC) |\n\t\t\tANA_FLOODING_FLD_BROADCAST_SET(PGID_BC),\n\t\t\tANA_FLOODING_FLD_MULTICAST |\n\t\t\tANA_FLOODING_FLD_UNICAST |\n\t\t\tANA_FLOODING_FLD_BROADCAST,\n\t\t\tlan966x, ANA_FLOODING(i));\n\n\tfor (i = 0; i < PGID_ENTRIES; ++i)\n\t\t \n\t\tlan_rmw(ANA_PGID_CFG_OBEY_VLAN_SET(1),\n\t\t\tANA_PGID_CFG_OBEY_VLAN,\n\t\t\tlan966x, ANA_PGID_CFG(i));\n\n\tfor (p = 0; p < lan966x->num_phys_ports; p++) {\n\t\t \n\t\tlan_rmw(ANA_PGID_PGID_SET(0x0),\n\t\t\tANA_PGID_PGID,\n\t\t\tlan966x, ANA_PGID(p + PGID_SRC));\n\n\t\t \n\t\tlan_wr(0xffff, lan966x, ANA_CPU_FWD_BPDU_CFG(p));\n\t}\n\n\t \n\tfor (i = 0; i <= QSYS_Q_RSRV; ++i) {\n\t\tlan_wr(1500 / 64, lan966x, QSYS_RES_CFG(i));\n\t\tlan_wr(1500 / 64, lan966x, QSYS_RES_CFG(512 + i));\n\t}\n\n\t \n\tlan_wr(QSYS_SW_PORT_MODE_PORT_ENA_SET(1) |\n\t       QSYS_SW_PORT_MODE_SCH_NEXT_CFG_SET(1) |\n\t       QSYS_SW_PORT_MODE_INGRESS_DROP_MODE_SET(1),\n\t       lan966x,  QSYS_SW_PORT_MODE(CPU_PORT));\n\n\t \n\tlan_rmw(ANA_PGID_PGID_SET(0),\n\t\tANA_PGID_PGID,\n\t\tlan966x, ANA_PGID(CPU_PORT));\n\tlan_rmw(ANA_PGID_PGID_SET(BIT(CPU_PORT)),\n\t\tANA_PGID_PGID,\n\t\tlan966x, ANA_PGID(PGID_CPU));\n\n\t \n\tlan_rmw(GENMASK(lan966x->num_phys_ports - 1, 0),\n\t\tANA_PGID_PGID,\n\t\tlan966x, ANA_PGID(PGID_MC));\n\n\t \n\tlan_rmw(GENMASK(lan966x->num_phys_ports - 1, 0),\n\t\tANA_PGID_PGID,\n\t\tlan966x, ANA_PGID(PGID_MCIPV4));\n\n\tlan_rmw(GENMASK(lan966x->num_phys_ports - 1, 0),\n\t\tANA_PGID_PGID,\n\t\tlan966x, ANA_PGID(PGID_MCIPV6));\n\n\t \n\tlan_rmw(GENMASK(lan966x->num_phys_ports - 1, 0),\n\t\tANA_PGID_PGID,\n\t\tlan966x, ANA_PGID(PGID_UC));\n\n\t \n\tlan_rmw(ANA_PGID_PGID_SET(BIT(CPU_PORT) | GENMASK(lan966x->num_phys_ports - 1, 0)),\n\t\tANA_PGID_PGID,\n\t\tlan966x, ANA_PGID(PGID_BC));\n\n\tlan_wr(REW_PORT_CFG_NO_REWRITE_SET(1),\n\t       lan966x, REW_PORT_CFG(CPU_PORT));\n\n\tlan_rmw(ANA_ANAINTR_INTR_ENA_SET(1),\n\t\tANA_ANAINTR_INTR_ENA,\n\t\tlan966x, ANA_ANAINTR);\n\n\tspin_lock_init(&lan966x->tx_lock);\n\n\tlan966x_taprio_init(lan966x);\n}\n\nstatic int lan966x_ram_init(struct lan966x *lan966x)\n{\n\treturn lan_rd(lan966x, SYS_RAM_INIT);\n}\n\nstatic int lan966x_reset_switch(struct lan966x *lan966x)\n{\n\tstruct reset_control *switch_reset;\n\tint val = 0;\n\tint ret;\n\n\tswitch_reset = devm_reset_control_get_optional_shared(lan966x->dev,\n\t\t\t\t\t\t\t      \"switch\");\n\tif (IS_ERR(switch_reset))\n\t\treturn dev_err_probe(lan966x->dev, PTR_ERR(switch_reset),\n\t\t\t\t     \"Could not obtain switch reset\");\n\n\treset_control_reset(switch_reset);\n\n\t \n\tif (lan_rd(lan966x, SYS_RESET_CFG) & SYS_RESET_CFG_CORE_ENA)\n\t\treturn 0;\n\n\tlan_wr(SYS_RESET_CFG_CORE_ENA_SET(0), lan966x, SYS_RESET_CFG);\n\tlan_wr(SYS_RAM_INIT_RAM_INIT_SET(1), lan966x, SYS_RAM_INIT);\n\tret = readx_poll_timeout(lan966x_ram_init, lan966x,\n\t\t\t\t val, (val & BIT(1)) == 0, READL_SLEEP_US,\n\t\t\t\t READL_TIMEOUT_US);\n\tif (ret)\n\t\treturn ret;\n\n\tlan_wr(SYS_RESET_CFG_CORE_ENA_SET(1), lan966x, SYS_RESET_CFG);\n\n\treturn 0;\n}\n\nstatic int lan966x_probe(struct platform_device *pdev)\n{\n\tstruct fwnode_handle *ports, *portnp;\n\tstruct lan966x *lan966x;\n\tu8 mac_addr[ETH_ALEN];\n\tint err;\n\n\tlan966x = devm_kzalloc(&pdev->dev, sizeof(*lan966x), GFP_KERNEL);\n\tif (!lan966x)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, lan966x);\n\tlan966x->dev = &pdev->dev;\n\n\tlan966x->debugfs_root = debugfs_create_dir(\"lan966x\", NULL);\n\n\tif (!device_get_mac_address(&pdev->dev, mac_addr)) {\n\t\tether_addr_copy(lan966x->base_mac, mac_addr);\n\t} else {\n\t\tpr_info(\"MAC addr was not set, use random MAC\\n\");\n\t\teth_random_addr(lan966x->base_mac);\n\t\tlan966x->base_mac[5] &= 0xf0;\n\t}\n\n\terr = lan966x_create_targets(pdev, lan966x);\n\tif (err)\n\t\treturn dev_err_probe(&pdev->dev, err,\n\t\t\t\t     \"Failed to create targets\");\n\n\terr = lan966x_reset_switch(lan966x);\n\tif (err)\n\t\treturn dev_err_probe(&pdev->dev, err, \"Reset failed\");\n\n\tlan966x->num_phys_ports = NUM_PHYS_PORTS;\n\tlan966x->ports = devm_kcalloc(&pdev->dev, lan966x->num_phys_ports,\n\t\t\t\t      sizeof(struct lan966x_port *),\n\t\t\t\t      GFP_KERNEL);\n\tif (!lan966x->ports)\n\t\treturn -ENOMEM;\n\n\t \n\tlan966x->shared_queue_sz = LAN966X_BUFFER_MEMORY;\n\n\t \n\tlan966x->xtr_irq = platform_get_irq_byname(pdev, \"xtr\");\n\tif (lan966x->xtr_irq < 0)\n\t\treturn lan966x->xtr_irq;\n\n\terr = devm_request_threaded_irq(&pdev->dev, lan966x->xtr_irq, NULL,\n\t\t\t\t\tlan966x_xtr_irq_handler, IRQF_ONESHOT,\n\t\t\t\t\t\"frame extraction\", lan966x);\n\tif (err) {\n\t\tpr_err(\"Unable to use xtr irq\");\n\t\treturn -ENODEV;\n\t}\n\n\tlan966x->ana_irq = platform_get_irq_byname(pdev, \"ana\");\n\tif (lan966x->ana_irq > 0) {\n\t\terr = devm_request_threaded_irq(&pdev->dev, lan966x->ana_irq, NULL,\n\t\t\t\t\t\tlan966x_ana_irq_handler, IRQF_ONESHOT,\n\t\t\t\t\t\t\"ana irq\", lan966x);\n\t\tif (err)\n\t\t\treturn dev_err_probe(&pdev->dev, err, \"Unable to use ana irq\");\n\t}\n\n\tlan966x->ptp_irq = platform_get_irq_byname(pdev, \"ptp\");\n\tif (lan966x->ptp_irq > 0) {\n\t\terr = devm_request_threaded_irq(&pdev->dev, lan966x->ptp_irq, NULL,\n\t\t\t\t\t\tlan966x_ptp_irq_handler, IRQF_ONESHOT,\n\t\t\t\t\t\t\"ptp irq\", lan966x);\n\t\tif (err)\n\t\t\treturn dev_err_probe(&pdev->dev, err, \"Unable to use ptp irq\");\n\n\t\tlan966x->ptp = 1;\n\t}\n\n\tlan966x->fdma_irq = platform_get_irq_byname(pdev, \"fdma\");\n\tif (lan966x->fdma_irq > 0) {\n\t\terr = devm_request_irq(&pdev->dev, lan966x->fdma_irq,\n\t\t\t\t       lan966x_fdma_irq_handler, 0,\n\t\t\t\t       \"fdma irq\", lan966x);\n\t\tif (err)\n\t\t\treturn dev_err_probe(&pdev->dev, err, \"Unable to use fdma irq\");\n\n\t\tlan966x->fdma = true;\n\t}\n\n\tif (lan966x->ptp) {\n\t\tlan966x->ptp_ext_irq = platform_get_irq_byname(pdev, \"ptp-ext\");\n\t\tif (lan966x->ptp_ext_irq > 0) {\n\t\t\terr = devm_request_threaded_irq(&pdev->dev,\n\t\t\t\t\t\t\tlan966x->ptp_ext_irq, NULL,\n\t\t\t\t\t\t\tlan966x_ptp_ext_irq_handler,\n\t\t\t\t\t\t\tIRQF_ONESHOT,\n\t\t\t\t\t\t\t\"ptp-ext irq\", lan966x);\n\t\t\tif (err)\n\t\t\t\treturn dev_err_probe(&pdev->dev, err,\n\t\t\t\t\t\t     \"Unable to use ptp-ext irq\");\n\t\t}\n\t}\n\n\tports = device_get_named_child_node(&pdev->dev, \"ethernet-ports\");\n\tif (!ports)\n\t\treturn dev_err_probe(&pdev->dev, -ENODEV,\n\t\t\t\t     \"no ethernet-ports child found\\n\");\n\n\t \n\tlan966x_init(lan966x);\n\tlan966x_stats_init(lan966x);\n\n\t \n\tfwnode_for_each_available_child_node(ports, portnp) {\n\t\tphy_interface_t phy_mode;\n\t\tstruct phy *serdes;\n\t\tu32 p;\n\n\t\tif (fwnode_property_read_u32(portnp, \"reg\", &p))\n\t\t\tcontinue;\n\n\t\tphy_mode = fwnode_get_phy_mode(portnp);\n\t\terr = lan966x_probe_port(lan966x, p, phy_mode, portnp);\n\t\tif (err)\n\t\t\tgoto cleanup_ports;\n\n\t\t \n\t\tlan966x->ports[p]->config.portmode = phy_mode;\n\t\tlan966x->ports[p]->fwnode = fwnode_handle_get(portnp);\n\n\t\tserdes = devm_of_phy_optional_get(lan966x->dev,\n\t\t\t\t\t\t  to_of_node(portnp), NULL);\n\t\tif (IS_ERR(serdes)) {\n\t\t\terr = PTR_ERR(serdes);\n\t\t\tgoto cleanup_ports;\n\t\t}\n\t\tlan966x->ports[p]->serdes = serdes;\n\n\t\tlan966x_port_init(lan966x->ports[p]);\n\t\terr = lan966x_xdp_port_init(lan966x->ports[p]);\n\t\tif (err)\n\t\t\tgoto cleanup_ports;\n\t}\n\n\tfwnode_handle_put(ports);\n\n\tlan966x_mdb_init(lan966x);\n\terr = lan966x_fdb_init(lan966x);\n\tif (err)\n\t\tgoto cleanup_ports;\n\n\terr = lan966x_ptp_init(lan966x);\n\tif (err)\n\t\tgoto cleanup_fdb;\n\n\terr = lan966x_fdma_init(lan966x);\n\tif (err)\n\t\tgoto cleanup_ptp;\n\n\terr = lan966x_vcap_init(lan966x);\n\tif (err)\n\t\tgoto cleanup_fdma;\n\n\tlan966x_dcb_init(lan966x);\n\n\treturn 0;\n\ncleanup_fdma:\n\tlan966x_fdma_deinit(lan966x);\n\ncleanup_ptp:\n\tlan966x_ptp_deinit(lan966x);\n\ncleanup_fdb:\n\tlan966x_fdb_deinit(lan966x);\n\ncleanup_ports:\n\tfwnode_handle_put(ports);\n\tfwnode_handle_put(portnp);\n\n\tlan966x_cleanup_ports(lan966x);\n\n\tcancel_delayed_work_sync(&lan966x->stats_work);\n\tdestroy_workqueue(lan966x->stats_queue);\n\tmutex_destroy(&lan966x->stats_lock);\n\n\treturn err;\n}\n\nstatic int lan966x_remove(struct platform_device *pdev)\n{\n\tstruct lan966x *lan966x = platform_get_drvdata(pdev);\n\n\tlan966x_taprio_deinit(lan966x);\n\tlan966x_vcap_deinit(lan966x);\n\tlan966x_fdma_deinit(lan966x);\n\tlan966x_cleanup_ports(lan966x);\n\n\tcancel_delayed_work_sync(&lan966x->stats_work);\n\tdestroy_workqueue(lan966x->stats_queue);\n\tmutex_destroy(&lan966x->stats_lock);\n\n\tlan966x_mac_purge_entries(lan966x);\n\tlan966x_mdb_deinit(lan966x);\n\tlan966x_fdb_deinit(lan966x);\n\tlan966x_ptp_deinit(lan966x);\n\n\tdebugfs_remove_recursive(lan966x->debugfs_root);\n\n\treturn 0;\n}\n\nstatic struct platform_driver lan966x_driver = {\n\t.probe = lan966x_probe,\n\t.remove = lan966x_remove,\n\t.driver = {\n\t\t.name = \"lan966x-switch\",\n\t\t.of_match_table = lan966x_match,\n\t},\n};\n\nstatic int __init lan966x_switch_driver_init(void)\n{\n\tint ret;\n\n\tlan966x_register_notifier_blocks();\n\n\tret = platform_driver_register(&lan966x_driver);\n\tif (ret)\n\t\tgoto err;\n\n\treturn 0;\n\nerr:\n\tlan966x_unregister_notifier_blocks();\n\treturn ret;\n}\n\nstatic void __exit lan966x_switch_driver_exit(void)\n{\n\tplatform_driver_unregister(&lan966x_driver);\n\tlan966x_unregister_notifier_blocks();\n}\n\nmodule_init(lan966x_switch_driver_init);\nmodule_exit(lan966x_switch_driver_exit);\n\nMODULE_DESCRIPTION(\"Microchip LAN966X switch driver\");\nMODULE_AUTHOR(\"Horatiu Vultur <horatiu.vultur@microchip.com>\");\nMODULE_LICENSE(\"Dual MIT/GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}