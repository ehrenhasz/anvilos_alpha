{
  "module_name": "lan966x_vcap_impl.c",
  "hash_id": "da6ea2fa942b6493b92239d73fc5405393487ee7609f6357ce130043394b098e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/microchip/lan966x/lan966x_vcap_impl.c",
  "human_readable_source": "\n\n#include \"lan966x_main.h\"\n#include \"lan966x_vcap_ag_api.h\"\n#include \"vcap_api.h\"\n#include \"vcap_api_client.h\"\n#include \"vcap_api_debugfs.h\"\n\n#define STREAMSIZE (64 * 4)\n\n#define LAN966X_IS1_LOOKUPS 3\n#define LAN966X_IS2_LOOKUPS 2\n#define LAN966X_ES0_LOOKUPS 1\n\n#define LAN966X_STAT_ESDX_GRN_BYTES 0x300\n#define LAN966X_STAT_ESDX_GRN_PKTS 0x301\n#define LAN966X_STAT_ESDX_YEL_BYTES 0x302\n#define LAN966X_STAT_ESDX_YEL_PKTS 0x303\n\nstatic struct lan966x_vcap_inst {\n\tenum vcap_type vtype;  \n\tint tgt_inst;  \n\tint lookups;  \n\tint first_cid;  \n\tint last_cid;  \n\tint count;  \n\tbool ingress;  \n} lan966x_vcap_inst_cfg[] = {\n\t{\n\t\t.vtype = VCAP_TYPE_ES0,\n\t\t.tgt_inst = 0,\n\t\t.lookups = LAN966X_ES0_LOOKUPS,\n\t\t.first_cid = LAN966X_VCAP_CID_ES0_L0,\n\t\t.last_cid = LAN966X_VCAP_CID_ES0_MAX,\n\t\t.count = 64,\n\t},\n\t{\n\t\t.vtype = VCAP_TYPE_IS1,  \n\t\t.tgt_inst = 1,\n\t\t.lookups = LAN966X_IS1_LOOKUPS,\n\t\t.first_cid = LAN966X_VCAP_CID_IS1_L0,\n\t\t.last_cid = LAN966X_VCAP_CID_IS1_MAX,\n\t\t.count = 768,\n\t\t.ingress = true,\n\t},\n\t{\n\t\t.vtype = VCAP_TYPE_IS2,  \n\t\t.tgt_inst = 2,\n\t\t.lookups = LAN966X_IS2_LOOKUPS,\n\t\t.first_cid = LAN966X_VCAP_CID_IS2_L0,\n\t\t.last_cid = LAN966X_VCAP_CID_IS2_MAX,\n\t\t.count = 256,\n\t\t.ingress = true,\n\t},\n};\n\nstruct lan966x_vcap_cmd_cb {\n\tstruct lan966x *lan966x;\n\tu32 instance;\n};\n\nstatic u32 lan966x_vcap_read_update_ctrl(const struct lan966x_vcap_cmd_cb *cb)\n{\n\treturn lan_rd(cb->lan966x, VCAP_UPDATE_CTRL(cb->instance));\n}\n\nstatic void lan966x_vcap_wait_update(struct lan966x *lan966x, int instance)\n{\n\tconst struct lan966x_vcap_cmd_cb cb = { .lan966x = lan966x,\n\t\t\t\t\t\t.instance = instance };\n\tu32 val;\n\n\treadx_poll_timeout(lan966x_vcap_read_update_ctrl, &cb, val,\n\t\t\t   (val & VCAP_UPDATE_CTRL_UPDATE_SHOT) == 0, 10,\n\t\t\t   100000);\n}\n\nstatic void __lan966x_vcap_range_init(struct lan966x *lan966x,\n\t\t\t\t      struct vcap_admin *admin,\n\t\t\t\t      u32 addr,\n\t\t\t\t      u32 count)\n{\n\tlan_wr(VCAP_MV_CFG_MV_NUM_POS_SET(0) |\n\t       VCAP_MV_CFG_MV_SIZE_SET(count - 1),\n\t       lan966x, VCAP_MV_CFG(admin->tgt_inst));\n\n\tlan_wr(VCAP_UPDATE_CTRL_UPDATE_CMD_SET(VCAP_CMD_INITIALIZE) |\n\t       VCAP_UPDATE_CTRL_UPDATE_ENTRY_DIS_SET(0) |\n\t       VCAP_UPDATE_CTRL_UPDATE_ACTION_DIS_SET(0) |\n\t       VCAP_UPDATE_CTRL_UPDATE_CNT_DIS_SET(0) |\n\t       VCAP_UPDATE_CTRL_UPDATE_ADDR_SET(addr) |\n\t       VCAP_UPDATE_CTRL_CLEAR_CACHE_SET(true) |\n\t       VCAP_UPDATE_CTRL_UPDATE_SHOT_SET(1),\n\t       lan966x, VCAP_UPDATE_CTRL(admin->tgt_inst));\n\n\tlan966x_vcap_wait_update(lan966x, admin->tgt_inst);\n}\n\nstatic int lan966x_vcap_is1_cid_to_lookup(int cid)\n{\n\tint lookup = 0;\n\n\tif (cid >= LAN966X_VCAP_CID_IS1_L1 &&\n\t    cid < LAN966X_VCAP_CID_IS1_L2)\n\t\tlookup = 1;\n\telse if (cid >= LAN966X_VCAP_CID_IS1_L2 &&\n\t\t cid < LAN966X_VCAP_CID_IS1_MAX)\n\t\tlookup = 2;\n\n\treturn lookup;\n}\n\nstatic int lan966x_vcap_is2_cid_to_lookup(int cid)\n{\n\tif (cid >= LAN966X_VCAP_CID_IS2_L1 &&\n\t    cid < LAN966X_VCAP_CID_IS2_MAX)\n\t\treturn 1;\n\n\treturn 0;\n}\n\n \nstatic int\nlan966x_vcap_is1_get_port_keysets(struct net_device *ndev, int lookup,\n\t\t\t\t  struct vcap_keyset_list *keysetlist,\n\t\t\t\t  u16 l3_proto)\n{\n\tstruct lan966x_port *port = netdev_priv(ndev);\n\tstruct lan966x *lan966x = port->lan966x;\n\tu32 val;\n\n\tval = lan_rd(lan966x, ANA_VCAP_S1_CFG(port->chip_port, lookup));\n\n\t \n\tif (l3_proto == ETH_P_ALL || l3_proto == ETH_P_IP) {\n\t\tswitch (ANA_VCAP_S1_CFG_KEY_IP4_CFG_GET(val)) {\n\t\tcase VCAP_IS1_PS_IPV4_7TUPLE:\n\t\t\tvcap_keyset_list_add(keysetlist, VCAP_KFS_7TUPLE);\n\t\t\tbreak;\n\t\tcase VCAP_IS1_PS_IPV4_5TUPLE_IP4:\n\t\t\tvcap_keyset_list_add(keysetlist, VCAP_KFS_5TUPLE_IP4);\n\t\t\tbreak;\n\t\tcase VCAP_IS1_PS_IPV4_NORMAL:\n\t\t\tvcap_keyset_list_add(keysetlist, VCAP_KFS_NORMAL);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (l3_proto == ETH_P_ALL || l3_proto == ETH_P_IPV6) {\n\t\tswitch (ANA_VCAP_S1_CFG_KEY_IP6_CFG_GET(val)) {\n\t\tcase VCAP_IS1_PS_IPV6_NORMAL:\n\t\tcase VCAP_IS1_PS_IPV6_NORMAL_IP6:\n\t\t\tvcap_keyset_list_add(keysetlist, VCAP_KFS_NORMAL);\n\t\t\tvcap_keyset_list_add(keysetlist, VCAP_KFS_NORMAL_IP6);\n\t\t\tbreak;\n\t\tcase VCAP_IS1_PS_IPV6_5TUPLE_IP6:\n\t\t\tvcap_keyset_list_add(keysetlist, VCAP_KFS_5TUPLE_IP6);\n\t\t\tbreak;\n\t\tcase VCAP_IS1_PS_IPV6_7TUPLE:\n\t\t\tvcap_keyset_list_add(keysetlist, VCAP_KFS_7TUPLE);\n\t\t\tbreak;\n\t\tcase VCAP_IS1_PS_IPV6_5TUPLE_IP4:\n\t\t\tvcap_keyset_list_add(keysetlist, VCAP_KFS_5TUPLE_IP4);\n\t\t\tbreak;\n\t\tcase VCAP_IS1_PS_IPV6_DMAC_VID:\n\t\t\tvcap_keyset_list_add(keysetlist, VCAP_KFS_DMAC_VID);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tswitch (ANA_VCAP_S1_CFG_KEY_OTHER_CFG_GET(val)) {\n\tcase VCAP_IS1_PS_OTHER_7TUPLE:\n\t\tvcap_keyset_list_add(keysetlist, VCAP_KFS_7TUPLE);\n\t\tbreak;\n\tcase VCAP_IS1_PS_OTHER_NORMAL:\n\t\tvcap_keyset_list_add(keysetlist, VCAP_KFS_NORMAL);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nlan966x_vcap_is2_get_port_keysets(struct net_device *dev, int lookup,\n\t\t\t\t  struct vcap_keyset_list *keysetlist,\n\t\t\t\t  u16 l3_proto)\n{\n\tstruct lan966x_port *port = netdev_priv(dev);\n\tstruct lan966x *lan966x = port->lan966x;\n\tbool found = false;\n\tu32 val;\n\n\tval = lan_rd(lan966x, ANA_VCAP_S2_CFG(port->chip_port));\n\n\t \n\tif (l3_proto == ETH_P_ALL)\n\t\tvcap_keyset_list_add(keysetlist, VCAP_KFS_MAC_ETYPE);\n\n\tif (l3_proto == ETH_P_ALL || l3_proto == ETH_P_SNAP) {\n\t\tif (ANA_VCAP_S2_CFG_SNAP_DIS_GET(val) & (BIT(0) << lookup))\n\t\t\tvcap_keyset_list_add(keysetlist, VCAP_KFS_MAC_LLC);\n\t\telse\n\t\t\tvcap_keyset_list_add(keysetlist, VCAP_KFS_MAC_SNAP);\n\n\t\tfound = true;\n\t}\n\n\tif (l3_proto == ETH_P_ALL || l3_proto == ETH_P_CFM) {\n\t\tif (ANA_VCAP_S2_CFG_OAM_DIS_GET(val) & (BIT(0) << lookup))\n\t\t\tvcap_keyset_list_add(keysetlist, VCAP_KFS_MAC_ETYPE);\n\t\telse\n\t\t\tvcap_keyset_list_add(keysetlist, VCAP_KFS_OAM);\n\n\t\tfound = true;\n\t}\n\n\tif (l3_proto == ETH_P_ALL || l3_proto == ETH_P_ARP) {\n\t\tif (ANA_VCAP_S2_CFG_ARP_DIS_GET(val) & (BIT(0) << lookup))\n\t\t\tvcap_keyset_list_add(keysetlist, VCAP_KFS_MAC_ETYPE);\n\t\telse\n\t\t\tvcap_keyset_list_add(keysetlist, VCAP_KFS_ARP);\n\n\t\tfound = true;\n\t}\n\n\tif (l3_proto == ETH_P_ALL || l3_proto == ETH_P_IP) {\n\t\tif (ANA_VCAP_S2_CFG_IP_OTHER_DIS_GET(val) & (BIT(0) << lookup))\n\t\t\tvcap_keyset_list_add(keysetlist, VCAP_KFS_MAC_ETYPE);\n\t\telse\n\t\t\tvcap_keyset_list_add(keysetlist, VCAP_KFS_IP4_OTHER);\n\n\t\tif (ANA_VCAP_S2_CFG_IP_TCPUDP_DIS_GET(val) & (BIT(0) << lookup))\n\t\t\tvcap_keyset_list_add(keysetlist, VCAP_KFS_MAC_ETYPE);\n\t\telse\n\t\t\tvcap_keyset_list_add(keysetlist, VCAP_KFS_IP4_TCP_UDP);\n\n\t\tfound = true;\n\t}\n\n\tif (l3_proto == ETH_P_ALL || l3_proto == ETH_P_IPV6) {\n\t\tswitch (ANA_VCAP_S2_CFG_IP6_CFG_GET(val) & (0x3 << lookup)) {\n\t\tcase VCAP_IS2_PS_IPV6_TCPUDP_OTHER:\n\t\t\tvcap_keyset_list_add(keysetlist, VCAP_KFS_IP6_OTHER);\n\t\t\tvcap_keyset_list_add(keysetlist, VCAP_KFS_IP6_TCP_UDP);\n\t\t\tbreak;\n\t\tcase VCAP_IS2_PS_IPV6_STD:\n\t\t\tvcap_keyset_list_add(keysetlist, VCAP_KFS_IP6_STD);\n\t\t\tbreak;\n\t\tcase VCAP_IS2_PS_IPV6_IP4_TCPUDP_IP4_OTHER:\n\t\t\tvcap_keyset_list_add(keysetlist, VCAP_KFS_IP4_OTHER);\n\t\t\tvcap_keyset_list_add(keysetlist, VCAP_KFS_IP4_TCP_UDP);\n\t\t\tbreak;\n\t\tcase VCAP_IS2_PS_IPV6_MAC_ETYPE:\n\t\t\tvcap_keyset_list_add(keysetlist, VCAP_KFS_MAC_ETYPE);\n\t\t\tbreak;\n\t\t}\n\n\t\tfound = true;\n\t}\n\n\tif (!found)\n\t\tvcap_keyset_list_add(keysetlist, VCAP_KFS_MAC_ETYPE);\n\n\treturn 0;\n}\n\nstatic enum vcap_keyfield_set\nlan966x_vcap_validate_keyset(struct net_device *dev,\n\t\t\t     struct vcap_admin *admin,\n\t\t\t     struct vcap_rule *rule,\n\t\t\t     struct vcap_keyset_list *kslist,\n\t\t\t     u16 l3_proto)\n{\n\tstruct vcap_keyset_list keysetlist = {};\n\tenum vcap_keyfield_set keysets[10] = {};\n\tint lookup;\n\tint err;\n\n\tif (!kslist || kslist->cnt == 0)\n\t\treturn VCAP_KFS_NO_VALUE;\n\n\tkeysetlist.max = ARRAY_SIZE(keysets);\n\tkeysetlist.keysets = keysets;\n\n\tswitch (admin->vtype) {\n\tcase VCAP_TYPE_IS1:\n\t\tlookup = lan966x_vcap_is1_cid_to_lookup(rule->vcap_chain_id);\n\t\terr = lan966x_vcap_is1_get_port_keysets(dev, lookup, &keysetlist,\n\t\t\t\t\t\t\tl3_proto);\n\t\tbreak;\n\tcase VCAP_TYPE_IS2:\n\t\tlookup = lan966x_vcap_is2_cid_to_lookup(rule->vcap_chain_id);\n\t\terr = lan966x_vcap_is2_get_port_keysets(dev, lookup, &keysetlist,\n\t\t\t\t\t\t\tl3_proto);\n\t\tbreak;\n\tcase VCAP_TYPE_ES0:\n\t\treturn kslist->keysets[0];\n\tdefault:\n\t\tpr_err(\"vcap type: %s not supported\\n\",\n\t\t       lan966x_vcaps[admin->vtype].name);\n\t\treturn VCAP_KFS_NO_VALUE;\n\t}\n\n\tif (err)\n\t\treturn VCAP_KFS_NO_VALUE;\n\n\t \n\tfor (int i = 0; i < kslist->cnt; ++i)\n\t\tfor (int j = 0; j < keysetlist.cnt; ++j)\n\t\t\tif (kslist->keysets[i] == keysets[j])\n\t\t\t\treturn kslist->keysets[i];\n\n\treturn VCAP_KFS_NO_VALUE;\n}\n\nstatic bool lan966x_vcap_is2_is_first_chain(struct vcap_rule *rule)\n{\n\treturn (rule->vcap_chain_id >= LAN966X_VCAP_CID_IS2_L0 &&\n\t\trule->vcap_chain_id < LAN966X_VCAP_CID_IS2_L1);\n}\n\nstatic void lan966x_vcap_is1_add_default_fields(struct lan966x_port *port,\n\t\t\t\t\t\tstruct vcap_admin *admin,\n\t\t\t\t\t\tstruct vcap_rule *rule)\n{\n\tu32 value, mask;\n\tu32 lookup;\n\n\tif (vcap_rule_get_key_u32(rule, VCAP_KF_IF_IGR_PORT_MASK,\n\t\t\t\t  &value, &mask))\n\t\tvcap_rule_add_key_u32(rule, VCAP_KF_IF_IGR_PORT_MASK, 0,\n\t\t\t\t      ~BIT(port->chip_port));\n\n\tlookup = lan966x_vcap_is1_cid_to_lookup(rule->vcap_chain_id);\n\tvcap_rule_add_key_u32(rule, VCAP_KF_LOOKUP_INDEX, lookup, 0x3);\n}\n\nstatic void lan966x_vcap_is2_add_default_fields(struct lan966x_port *port,\n\t\t\t\t\t\tstruct vcap_admin *admin,\n\t\t\t\t\t\tstruct vcap_rule *rule)\n{\n\tu32 value, mask;\n\n\tif (vcap_rule_get_key_u32(rule, VCAP_KF_IF_IGR_PORT_MASK,\n\t\t\t\t  &value, &mask))\n\t\tvcap_rule_add_key_u32(rule, VCAP_KF_IF_IGR_PORT_MASK, 0,\n\t\t\t\t      ~BIT(port->chip_port));\n\n\tif (lan966x_vcap_is2_is_first_chain(rule))\n\t\tvcap_rule_add_key_bit(rule, VCAP_KF_LOOKUP_FIRST_IS,\n\t\t\t\t      VCAP_BIT_1);\n\telse\n\t\tvcap_rule_add_key_bit(rule, VCAP_KF_LOOKUP_FIRST_IS,\n\t\t\t\t      VCAP_BIT_0);\n}\n\nstatic void lan966x_vcap_es0_add_default_fields(struct lan966x_port *port,\n\t\t\t\t\t\tstruct vcap_admin *admin,\n\t\t\t\t\t\tstruct vcap_rule *rule)\n{\n\tvcap_rule_add_key_u32(rule, VCAP_KF_IF_EGR_PORT_NO,\n\t\t\t      port->chip_port, GENMASK(4, 0));\n}\n\nstatic void lan966x_vcap_add_default_fields(struct net_device *dev,\n\t\t\t\t\t    struct vcap_admin *admin,\n\t\t\t\t\t    struct vcap_rule *rule)\n{\n\tstruct lan966x_port *port = netdev_priv(dev);\n\n\tswitch (admin->vtype) {\n\tcase VCAP_TYPE_IS1:\n\t\tlan966x_vcap_is1_add_default_fields(port, admin, rule);\n\t\tbreak;\n\tcase VCAP_TYPE_IS2:\n\t\tlan966x_vcap_is2_add_default_fields(port, admin, rule);\n\t\tbreak;\n\tcase VCAP_TYPE_ES0:\n\t\tlan966x_vcap_es0_add_default_fields(port, admin, rule);\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"vcap type: %s not supported\\n\",\n\t\t       lan966x_vcaps[admin->vtype].name);\n\t\tbreak;\n\t}\n}\n\nstatic void lan966x_vcap_cache_erase(struct vcap_admin *admin)\n{\n\tmemset(admin->cache.keystream, 0, STREAMSIZE);\n\tmemset(admin->cache.maskstream, 0, STREAMSIZE);\n\tmemset(admin->cache.actionstream, 0, STREAMSIZE);\n\tmemset(&admin->cache.counter, 0, sizeof(admin->cache.counter));\n}\n\n \nstatic void lan966x_es0_read_esdx_counter(struct lan966x *lan966x,\n\t\t\t\t\t  struct vcap_admin *admin, u32 id)\n{\n\tu32 counter;\n\n\tid = id & 0xff;  \n\tmutex_lock(&lan966x->stats_lock);\n\tlan_wr(SYS_STAT_CFG_STAT_VIEW_SET(id), lan966x, SYS_STAT_CFG);\n\tcounter = lan_rd(lan966x, SYS_CNT(LAN966X_STAT_ESDX_GRN_PKTS)) +\n\t\t  lan_rd(lan966x, SYS_CNT(LAN966X_STAT_ESDX_YEL_PKTS));\n\tmutex_unlock(&lan966x->stats_lock);\n\tif (counter)\n\t\tadmin->cache.counter = counter;\n}\n\nstatic void lan966x_es0_write_esdx_counter(struct lan966x *lan966x,\n\t\t\t\t\t   struct vcap_admin *admin, u32 id)\n{\n\tid = id & 0xff;  \n\n\tmutex_lock(&lan966x->stats_lock);\n\tlan_wr(SYS_STAT_CFG_STAT_VIEW_SET(id), lan966x, SYS_STAT_CFG);\n\tlan_wr(0, lan966x, SYS_CNT(LAN966X_STAT_ESDX_GRN_BYTES));\n\tlan_wr(admin->cache.counter, lan966x,\n\t       SYS_CNT(LAN966X_STAT_ESDX_GRN_PKTS));\n\tlan_wr(0, lan966x, SYS_CNT(LAN966X_STAT_ESDX_YEL_BYTES));\n\tlan_wr(0, lan966x, SYS_CNT(LAN966X_STAT_ESDX_YEL_PKTS));\n\tmutex_unlock(&lan966x->stats_lock);\n}\n\nstatic void lan966x_vcap_cache_write(struct net_device *dev,\n\t\t\t\t     struct vcap_admin *admin,\n\t\t\t\t     enum vcap_selection sel,\n\t\t\t\t     u32 start,\n\t\t\t\t     u32 count)\n{\n\tstruct lan966x_port *port = netdev_priv(dev);\n\tstruct lan966x *lan966x = port->lan966x;\n\tu32 *keystr, *mskstr, *actstr;\n\n\tkeystr = &admin->cache.keystream[start];\n\tmskstr = &admin->cache.maskstream[start];\n\tactstr = &admin->cache.actionstream[start];\n\n\tswitch (sel) {\n\tcase VCAP_SEL_ENTRY:\n\t\tfor (int i = 0; i < count; ++i) {\n\t\t\tlan_wr(keystr[i] & mskstr[i], lan966x,\n\t\t\t       VCAP_ENTRY_DAT(admin->tgt_inst, i));\n\t\t\tlan_wr(~mskstr[i], lan966x,\n\t\t\t       VCAP_MASK_DAT(admin->tgt_inst, i));\n\t\t}\n\t\tbreak;\n\tcase VCAP_SEL_ACTION:\n\t\tfor (int i = 0; i < count; ++i)\n\t\t\tlan_wr(actstr[i], lan966x,\n\t\t\t       VCAP_ACTION_DAT(admin->tgt_inst, i));\n\t\tbreak;\n\tcase VCAP_SEL_COUNTER:\n\t\tadmin->cache.sticky = admin->cache.counter > 0;\n\t\tlan_wr(admin->cache.counter, lan966x,\n\t\t       VCAP_CNT_DAT(admin->tgt_inst, 0));\n\n\t\tif (admin->vtype == VCAP_TYPE_ES0)\n\t\t\tlan966x_es0_write_esdx_counter(lan966x, admin, start);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void lan966x_vcap_cache_read(struct net_device *dev,\n\t\t\t\t    struct vcap_admin *admin,\n\t\t\t\t    enum vcap_selection sel,\n\t\t\t\t    u32 start,\n\t\t\t\t    u32 count)\n{\n\tstruct lan966x_port *port = netdev_priv(dev);\n\tstruct lan966x *lan966x = port->lan966x;\n\tint instance = admin->tgt_inst;\n\tu32 *keystr, *mskstr, *actstr;\n\n\tkeystr = &admin->cache.keystream[start];\n\tmskstr = &admin->cache.maskstream[start];\n\tactstr = &admin->cache.actionstream[start];\n\n\tif (sel & VCAP_SEL_ENTRY) {\n\t\tfor (int i = 0; i < count; ++i) {\n\t\t\tkeystr[i] =\n\t\t\t\tlan_rd(lan966x, VCAP_ENTRY_DAT(instance, i));\n\t\t\tmskstr[i] =\n\t\t\t\t~lan_rd(lan966x, VCAP_MASK_DAT(instance, i));\n\t\t}\n\t}\n\n\tif (sel & VCAP_SEL_ACTION)\n\t\tfor (int i = 0; i < count; ++i)\n\t\t\tactstr[i] =\n\t\t\t\tlan_rd(lan966x, VCAP_ACTION_DAT(instance, i));\n\n\tif (sel & VCAP_SEL_COUNTER) {\n\t\tadmin->cache.counter =\n\t\t\tlan_rd(lan966x, VCAP_CNT_DAT(instance, 0));\n\t\tadmin->cache.sticky = admin->cache.counter > 0;\n\n\t\tif (admin->vtype == VCAP_TYPE_ES0)\n\t\t\tlan966x_es0_read_esdx_counter(lan966x, admin, start);\n\t}\n}\n\nstatic void lan966x_vcap_range_init(struct net_device *dev,\n\t\t\t\t    struct vcap_admin *admin,\n\t\t\t\t    u32 addr,\n\t\t\t\t    u32 count)\n{\n\tstruct lan966x_port *port = netdev_priv(dev);\n\tstruct lan966x *lan966x = port->lan966x;\n\n\t__lan966x_vcap_range_init(lan966x, admin, addr, count);\n}\n\nstatic void lan966x_vcap_update(struct net_device *dev,\n\t\t\t\tstruct vcap_admin *admin,\n\t\t\t\tenum vcap_command cmd,\n\t\t\t\tenum vcap_selection sel,\n\t\t\t\tu32 addr)\n{\n\tstruct lan966x_port *port = netdev_priv(dev);\n\tstruct lan966x *lan966x = port->lan966x;\n\tbool clear;\n\n\tclear = (cmd == VCAP_CMD_INITIALIZE);\n\n\tlan_wr(VCAP_MV_CFG_MV_NUM_POS_SET(0) |\n\t       VCAP_MV_CFG_MV_SIZE_SET(0),\n\t       lan966x, VCAP_MV_CFG(admin->tgt_inst));\n\n\tlan_wr(VCAP_UPDATE_CTRL_UPDATE_CMD_SET(cmd) |\n\t       VCAP_UPDATE_CTRL_UPDATE_ENTRY_DIS_SET((VCAP_SEL_ENTRY & sel) == 0) |\n\t       VCAP_UPDATE_CTRL_UPDATE_ACTION_DIS_SET((VCAP_SEL_ACTION & sel) == 0) |\n\t       VCAP_UPDATE_CTRL_UPDATE_CNT_DIS_SET((VCAP_SEL_COUNTER & sel) == 0) |\n\t       VCAP_UPDATE_CTRL_UPDATE_ADDR_SET(addr) |\n\t       VCAP_UPDATE_CTRL_CLEAR_CACHE_SET(clear) |\n\t       VCAP_UPDATE_CTRL_UPDATE_SHOT,\n\t       lan966x, VCAP_UPDATE_CTRL(admin->tgt_inst));\n\n\tlan966x_vcap_wait_update(lan966x, admin->tgt_inst);\n}\n\nstatic void lan966x_vcap_move(struct net_device *dev,\n\t\t\t      struct vcap_admin *admin,\n\t\t\t      u32 addr, int offset, int count)\n{\n\tstruct lan966x_port *port = netdev_priv(dev);\n\tstruct lan966x *lan966x = port->lan966x;\n\tenum vcap_command cmd;\n\tu16 mv_num_pos;\n\tu16 mv_size;\n\n\tmv_size = count - 1;\n\tif (offset > 0) {\n\t\tmv_num_pos = offset - 1;\n\t\tcmd = VCAP_CMD_MOVE_DOWN;\n\t} else {\n\t\tmv_num_pos = -offset - 1;\n\t\tcmd = VCAP_CMD_MOVE_UP;\n\t}\n\n\tlan_wr(VCAP_MV_CFG_MV_NUM_POS_SET(mv_num_pos) |\n\t       VCAP_MV_CFG_MV_SIZE_SET(mv_size),\n\t       lan966x, VCAP_MV_CFG(admin->tgt_inst));\n\n\tlan_wr(VCAP_UPDATE_CTRL_UPDATE_CMD_SET(cmd) |\n\t       VCAP_UPDATE_CTRL_UPDATE_ENTRY_DIS_SET(0) |\n\t       VCAP_UPDATE_CTRL_UPDATE_ACTION_DIS_SET(0) |\n\t       VCAP_UPDATE_CTRL_UPDATE_CNT_DIS_SET(0) |\n\t       VCAP_UPDATE_CTRL_UPDATE_ADDR_SET(addr) |\n\t       VCAP_UPDATE_CTRL_CLEAR_CACHE_SET(false) |\n\t       VCAP_UPDATE_CTRL_UPDATE_SHOT,\n\t       lan966x, VCAP_UPDATE_CTRL(admin->tgt_inst));\n\n\tlan966x_vcap_wait_update(lan966x, admin->tgt_inst);\n}\n\nstatic struct vcap_operations lan966x_vcap_ops = {\n\t.validate_keyset = lan966x_vcap_validate_keyset,\n\t.add_default_fields = lan966x_vcap_add_default_fields,\n\t.cache_erase = lan966x_vcap_cache_erase,\n\t.cache_write = lan966x_vcap_cache_write,\n\t.cache_read = lan966x_vcap_cache_read,\n\t.init = lan966x_vcap_range_init,\n\t.update = lan966x_vcap_update,\n\t.move = lan966x_vcap_move,\n\t.port_info = lan966x_vcap_port_info,\n};\n\nstatic void lan966x_vcap_admin_free(struct vcap_admin *admin)\n{\n\tif (!admin)\n\t\treturn;\n\n\tkfree(admin->cache.keystream);\n\tkfree(admin->cache.maskstream);\n\tkfree(admin->cache.actionstream);\n\tmutex_destroy(&admin->lock);\n\tkfree(admin);\n}\n\nstatic struct vcap_admin *\nlan966x_vcap_admin_alloc(struct lan966x *lan966x, struct vcap_control *ctrl,\n\t\t\t const struct lan966x_vcap_inst *cfg)\n{\n\tstruct vcap_admin *admin;\n\n\tadmin = kzalloc(sizeof(*admin), GFP_KERNEL);\n\tif (!admin)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmutex_init(&admin->lock);\n\tINIT_LIST_HEAD(&admin->list);\n\tINIT_LIST_HEAD(&admin->rules);\n\tINIT_LIST_HEAD(&admin->enabled);\n\n\tadmin->vtype = cfg->vtype;\n\tadmin->vinst = 0;\n\tadmin->ingress = cfg->ingress;\n\tadmin->w32be = true;\n\tadmin->tgt_inst = cfg->tgt_inst;\n\n\tadmin->lookups = cfg->lookups;\n\tadmin->lookups_per_instance = cfg->lookups;\n\n\tadmin->first_cid = cfg->first_cid;\n\tadmin->last_cid = cfg->last_cid;\n\n\tadmin->cache.keystream = kzalloc(STREAMSIZE, GFP_KERNEL);\n\tadmin->cache.maskstream = kzalloc(STREAMSIZE, GFP_KERNEL);\n\tadmin->cache.actionstream = kzalloc(STREAMSIZE, GFP_KERNEL);\n\tif (!admin->cache.keystream ||\n\t    !admin->cache.maskstream ||\n\t    !admin->cache.actionstream) {\n\t\tlan966x_vcap_admin_free(admin);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\treturn admin;\n}\n\nstatic void lan966x_vcap_block_init(struct lan966x *lan966x,\n\t\t\t\t    struct vcap_admin *admin,\n\t\t\t\t    struct lan966x_vcap_inst *cfg)\n{\n\tadmin->first_valid_addr = 0;\n\tadmin->last_used_addr = cfg->count;\n\tadmin->last_valid_addr = cfg->count - 1;\n\n\tlan_wr(VCAP_CORE_IDX_CORE_IDX_SET(0),\n\t       lan966x, VCAP_CORE_IDX(admin->tgt_inst));\n\tlan_wr(VCAP_CORE_MAP_CORE_MAP_SET(1),\n\t       lan966x, VCAP_CORE_MAP(admin->tgt_inst));\n\n\t__lan966x_vcap_range_init(lan966x, admin, admin->first_valid_addr,\n\t\t\t\t  admin->last_valid_addr -\n\t\t\t\t\tadmin->first_valid_addr);\n}\n\nstatic void lan966x_vcap_port_key_deselection(struct lan966x *lan966x,\n\t\t\t\t\t      struct vcap_admin *admin)\n{\n\tu32 val;\n\n\tswitch (admin->vtype) {\n\tcase VCAP_TYPE_IS1:\n\t\tval = ANA_VCAP_S1_CFG_KEY_IP6_CFG_SET(VCAP_IS1_PS_IPV6_5TUPLE_IP6) |\n\t\t      ANA_VCAP_S1_CFG_KEY_IP4_CFG_SET(VCAP_IS1_PS_IPV4_5TUPLE_IP4) |\n\t\t      ANA_VCAP_S1_CFG_KEY_OTHER_CFG_SET(VCAP_IS1_PS_OTHER_NORMAL);\n\n\t\tfor (int p = 0; p < lan966x->num_phys_ports; ++p) {\n\t\t\tif (!lan966x->ports[p])\n\t\t\t\tcontinue;\n\n\t\t\tfor (int l = 0; l < LAN966X_IS1_LOOKUPS; ++l)\n\t\t\t\tlan_wr(val, lan966x, ANA_VCAP_S1_CFG(p, l));\n\n\t\t\tlan_rmw(ANA_VCAP_CFG_S1_ENA_SET(true),\n\t\t\t\tANA_VCAP_CFG_S1_ENA, lan966x,\n\t\t\t\tANA_VCAP_CFG(p));\n\t\t}\n\n\t\tbreak;\n\tcase VCAP_TYPE_IS2:\n\t\tfor (int p = 0; p < lan966x->num_phys_ports; ++p)\n\t\t\tlan_wr(0, lan966x, ANA_VCAP_S2_CFG(p));\n\n\t\tbreak;\n\tcase VCAP_TYPE_ES0:\n\t\tfor (int p = 0; p < lan966x->num_phys_ports; ++p)\n\t\t\tlan_rmw(REW_PORT_CFG_ES0_EN_SET(false),\n\t\t\t\tREW_PORT_CFG_ES0_EN, lan966x,\n\t\t\t\tREW_PORT_CFG(p));\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"vcap type: %s not supported\\n\",\n\t\t       lan966x_vcaps[admin->vtype].name);\n\t\tbreak;\n\t}\n}\n\nint lan966x_vcap_init(struct lan966x *lan966x)\n{\n\tstruct lan966x_vcap_inst *cfg;\n\tstruct vcap_control *ctrl;\n\tstruct vcap_admin *admin;\n\tstruct dentry *dir;\n\n\tctrl = kzalloc(sizeof(*ctrl), GFP_KERNEL);\n\tif (!ctrl)\n\t\treturn -ENOMEM;\n\n\tctrl->vcaps = lan966x_vcaps;\n\tctrl->stats = &lan966x_vcap_stats;\n\tctrl->ops = &lan966x_vcap_ops;\n\n\tINIT_LIST_HEAD(&ctrl->list);\n\tfor (int i = 0; i < ARRAY_SIZE(lan966x_vcap_inst_cfg); ++i) {\n\t\tcfg = &lan966x_vcap_inst_cfg[i];\n\n\t\tadmin = lan966x_vcap_admin_alloc(lan966x, ctrl, cfg);\n\t\tif (IS_ERR(admin))\n\t\t\treturn PTR_ERR(admin);\n\n\t\tlan966x_vcap_block_init(lan966x, admin, cfg);\n\t\tlan966x_vcap_port_key_deselection(lan966x, admin);\n\n\t\tlist_add_tail(&admin->list, &ctrl->list);\n\t}\n\n\tdir = vcap_debugfs(lan966x->dev, lan966x->debugfs_root, ctrl);\n\tfor (int p = 0; p < lan966x->num_phys_ports; ++p) {\n\t\tif (lan966x->ports[p]) {\n\t\t\tvcap_port_debugfs(lan966x->dev, dir, ctrl,\n\t\t\t\t\t  lan966x->ports[p]->dev);\n\n\t\t\tlan_rmw(ANA_VCAP_S2_CFG_ENA_SET(true),\n\t\t\t\tANA_VCAP_S2_CFG_ENA, lan966x,\n\t\t\t\tANA_VCAP_S2_CFG(lan966x->ports[p]->chip_port));\n\n\t\t\tlan_rmw(ANA_VCAP_CFG_S1_ENA_SET(true),\n\t\t\t\tANA_VCAP_CFG_S1_ENA, lan966x,\n\t\t\t\tANA_VCAP_CFG(lan966x->ports[p]->chip_port));\n\n\t\t\tlan_rmw(REW_PORT_CFG_ES0_EN_SET(true),\n\t\t\t\tREW_PORT_CFG_ES0_EN, lan966x,\n\t\t\t\tREW_PORT_CFG(lan966x->ports[p]->chip_port));\n\t\t}\n\t}\n\n\t \n\tlan_rmw(REW_STAT_CFG_STAT_MODE_SET(1),\n\t\tREW_STAT_CFG_STAT_MODE, lan966x,\n\t\tREW_STAT_CFG);\n\n\tlan966x->vcap_ctrl = ctrl;\n\n\treturn 0;\n}\n\nvoid lan966x_vcap_deinit(struct lan966x *lan966x)\n{\n\tstruct vcap_admin *admin, *admin_next;\n\tstruct vcap_control *ctrl;\n\n\tctrl = lan966x->vcap_ctrl;\n\tif (!ctrl)\n\t\treturn;\n\n\tlist_for_each_entry_safe(admin, admin_next, &ctrl->list, list) {\n\t\tlan966x_vcap_port_key_deselection(lan966x, admin);\n\t\tvcap_del_rules(ctrl, admin);\n\t\tlist_del(&admin->list);\n\t\tlan966x_vcap_admin_free(admin);\n\t}\n\n\tkfree(ctrl);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}