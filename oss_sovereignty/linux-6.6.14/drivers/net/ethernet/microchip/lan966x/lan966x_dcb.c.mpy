{
  "module_name": "lan966x_dcb.c",
  "hash_id": "3fcb91910687558f8a98c62fabd0882348cc8910732935c1dc5bcc91695fe47d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/microchip/lan966x/lan966x_dcb.c",
  "human_readable_source": "\n\n#include \"lan966x_main.h\"\n\nenum lan966x_dcb_apptrust_values {\n\tLAN966X_DCB_APPTRUST_EMPTY,\n\tLAN966X_DCB_APPTRUST_DSCP,\n\tLAN966X_DCB_APPTRUST_PCP,\n\tLAN966X_DCB_APPTRUST_DSCP_PCP,\n\t__LAN966X_DCB_APPTRUST_MAX\n};\n\nstatic const struct lan966x_dcb_apptrust {\n\tu8 selectors[IEEE_8021QAZ_APP_SEL_MAX + 1];\n\tint nselectors;\n} *lan966x_port_apptrust[NUM_PHYS_PORTS];\n\nstatic const char *lan966x_dcb_apptrust_names[__LAN966X_DCB_APPTRUST_MAX] = {\n\t[LAN966X_DCB_APPTRUST_EMPTY]    = \"empty\",\n\t[LAN966X_DCB_APPTRUST_DSCP]     = \"dscp\",\n\t[LAN966X_DCB_APPTRUST_PCP]      = \"pcp\",\n\t[LAN966X_DCB_APPTRUST_DSCP_PCP] = \"dscp pcp\"\n};\n\n \nstatic const struct lan966x_dcb_apptrust\n\tlan966x_dcb_apptrust_policies[__LAN966X_DCB_APPTRUST_MAX] = {\n\t \n\t[LAN966X_DCB_APPTRUST_EMPTY]    = { { 0 }, 0 },\n\t[LAN966X_DCB_APPTRUST_DSCP]     = { { IEEE_8021QAZ_APP_SEL_DSCP }, 1 },\n\t[LAN966X_DCB_APPTRUST_PCP]      = { { DCB_APP_SEL_PCP }, 1 },\n\t[LAN966X_DCB_APPTRUST_DSCP_PCP] = { { IEEE_8021QAZ_APP_SEL_DSCP,\n\t\t\t\t\t      DCB_APP_SEL_PCP }, 2 },\n};\n\nstatic bool lan966x_dcb_apptrust_contains(int portno, u8 selector)\n{\n\tconst struct lan966x_dcb_apptrust *conf = lan966x_port_apptrust[portno];\n\n\tfor (int i = 0; i < conf->nselectors; i++)\n\t\tif (conf->selectors[i] == selector)\n\t\t\treturn true;\n\n\treturn false;\n}\n\nstatic void lan966x_dcb_app_update(struct net_device *dev)\n{\n\tstruct dcb_ieee_app_prio_map dscp_rewr_map = {0};\n\tstruct dcb_rewr_prio_pcp_map pcp_rewr_map = {0};\n\tstruct lan966x_port *port = netdev_priv(dev);\n\tstruct lan966x_port_qos qos = {0};\n\tstruct dcb_app app_itr;\n\tbool dscp_rewr = false;\n\tbool pcp_rewr = false;\n\n\t \n\tfor (int i = 0; i < ARRAY_SIZE(qos.pcp.map); i++) {\n\t\tapp_itr.selector = DCB_APP_SEL_PCP;\n\t\tapp_itr.protocol = i;\n\t\tqos.pcp.map[i] = dcb_getapp(dev, &app_itr);\n\t}\n\n\t \n\tfor (int i = 0; i < ARRAY_SIZE(qos.dscp.map); i++) {\n\t\tapp_itr.selector = IEEE_8021QAZ_APP_SEL_DSCP;\n\t\tapp_itr.protocol = i;\n\t\tqos.dscp.map[i] = dcb_getapp(dev, &app_itr);\n\t}\n\n\t \n\tqos.default_prio = dcb_ieee_getapp_default_prio_mask(dev);\n\tif (qos.default_prio)\n\t\tqos.default_prio = fls(qos.default_prio) - 1;\n\n\t \n\tdcb_getrewr_prio_pcp_mask_map(dev, &pcp_rewr_map);\n\tfor (int i = 0; i < ARRAY_SIZE(pcp_rewr_map.map); i++) {\n\t\tif (!pcp_rewr_map.map[i])\n\t\t\tcontinue;\n\n\t\tpcp_rewr = true;\n\t\tqos.pcp_rewr.map[i] = fls(pcp_rewr_map.map[i]) - 1;\n\t}\n\n\t \n\tdcb_getrewr_prio_dscp_mask_map(dev, &dscp_rewr_map);\n\tfor (int i = 0; i < ARRAY_SIZE(dscp_rewr_map.map); i++) {\n\t\tif (!dscp_rewr_map.map[i])\n\t\t\tcontinue;\n\n\t\tdscp_rewr = true;\n\t\tqos.dscp_rewr.map[i] = fls64(dscp_rewr_map.map[i]) - 1;\n\t}\n\n\t \n\tif (lan966x_dcb_apptrust_contains(port->chip_port, DCB_APP_SEL_PCP)) {\n\t\tqos.pcp.enable = true;\n\n\t\tif (pcp_rewr)\n\t\t\tqos.pcp_rewr.enable = true;\n\t}\n\n\t \n\tif (lan966x_dcb_apptrust_contains(port->chip_port, IEEE_8021QAZ_APP_SEL_DSCP)) {\n\t\tqos.dscp.enable = true;\n\n\t\tif (dscp_rewr)\n\t\t\tqos.dscp_rewr.enable = true;\n\t}\n\n\tlan966x_port_qos_set(port, &qos);\n}\n\n \nstatic int lan966x_dcb_ieee_dscp_setdel(struct net_device *dev,\n\t\t\t\t\tstruct dcb_app *app,\n\t\t\t\t\tint (*setdel)(struct net_device *,\n\t\t\t\t\t\t      struct dcb_app *))\n{\n\tstruct lan966x_port *port = netdev_priv(dev);\n\tstruct lan966x *lan966x = port->lan966x;\n\tint err;\n\n\tfor (int i = 0; i < NUM_PHYS_PORTS; i++) {\n\t\tport = lan966x->ports[i];\n\t\tif (!port)\n\t\t\tcontinue;\n\n\t\terr = setdel(port->dev, app);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int lan966x_dcb_app_validate(struct net_device *dev,\n\t\t\t\t    const struct dcb_app *app)\n{\n\tint err = 0;\n\n\tswitch (app->selector) {\n\t \n\tcase IEEE_8021QAZ_APP_SEL_ETHERTYPE:\n\t\tif (app->protocol)\n\t\t\terr = -EINVAL;\n\t\telse if (app->priority >= NUM_PRIO_QUEUES)\n\t\t\terr = -ERANGE;\n\t\tbreak;\n\t \n\tcase IEEE_8021QAZ_APP_SEL_DSCP:\n\t\tif (app->protocol >= LAN966X_PORT_QOS_DSCP_COUNT)\n\t\t\terr = -EINVAL;\n\t\telse if (app->priority >= NUM_PRIO_QUEUES)\n\t\t\terr = -ERANGE;\n\t\tbreak;\n\t \n\tcase DCB_APP_SEL_PCP:\n\t\tif (app->protocol >= LAN966X_PORT_QOS_PCP_DEI_COUNT)\n\t\t\terr = -EINVAL;\n\t\telse if (app->priority >= NUM_PRIO_QUEUES)\n\t\t\terr = -ERANGE;\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t\tbreak;\n\t}\n\n\tif (err)\n\t\tnetdev_err(dev, \"Invalid entry: %d:%d\\n\", app->protocol,\n\t\t\t   app->priority);\n\n\treturn err;\n}\n\nstatic int lan966x_dcb_ieee_delapp(struct net_device *dev, struct dcb_app *app)\n{\n\tint err;\n\n\tif (app->selector == IEEE_8021QAZ_APP_SEL_DSCP)\n\t\terr = lan966x_dcb_ieee_dscp_setdel(dev, app, dcb_ieee_delapp);\n\telse\n\t\terr = dcb_ieee_delapp(dev, app);\n\n\tif (err)\n\t\treturn err;\n\n\tlan966x_dcb_app_update(dev);\n\n\treturn 0;\n}\n\nstatic int lan966x_dcb_ieee_setapp(struct net_device *dev, struct dcb_app *app)\n{\n\tstruct dcb_app app_itr;\n\tint err;\n\tu8 prio;\n\n\terr = lan966x_dcb_app_validate(dev, app);\n\tif (err)\n\t\treturn err;\n\n\t \n\tprio = dcb_getapp(dev, app);\n\tif (prio) {\n\t\tapp_itr = *app;\n\t\tapp_itr.priority = prio;\n\t\tlan966x_dcb_ieee_delapp(dev, &app_itr);\n\t}\n\n\tif (app->selector == IEEE_8021QAZ_APP_SEL_DSCP)\n\t\terr = lan966x_dcb_ieee_dscp_setdel(dev, app, dcb_ieee_setapp);\n\telse\n\t\terr = dcb_ieee_setapp(dev, app);\n\n\tif (err)\n\t\treturn err;\n\n\tlan966x_dcb_app_update(dev);\n\n\treturn 0;\n}\n\nstatic int lan966x_dcb_apptrust_validate(struct net_device *dev,\n\t\t\t\t\t u8 *selectors,\n\t\t\t\t\t int nselectors)\n{\n\tfor (int i = 0; i < ARRAY_SIZE(lan966x_dcb_apptrust_policies); i++) {\n\t\tbool match;\n\n\t\tif (lan966x_dcb_apptrust_policies[i].nselectors != nselectors)\n\t\t\tcontinue;\n\n\t\tmatch = true;\n\t\tfor (int j = 0; j < nselectors; j++) {\n\t\t\tif (lan966x_dcb_apptrust_policies[i].selectors[j] !=\n\t\t\t    *(selectors + j)) {\n\t\t\t\tmatch = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (match)\n\t\t\treturn i;\n\t}\n\n\tnetdev_err(dev, \"Valid apptrust configurations are:\\n\");\n\tfor (int i = 0; i < ARRAY_SIZE(lan966x_dcb_apptrust_names); i++)\n\t\tpr_info(\"order: %s\\n\", lan966x_dcb_apptrust_names[i]);\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic int lan966x_dcb_setapptrust(struct net_device *dev,\n\t\t\t\t   u8 *selectors,\n\t\t\t\t   int nselectors)\n{\n\tstruct lan966x_port *port = netdev_priv(dev);\n\tint idx;\n\n\tidx = lan966x_dcb_apptrust_validate(dev, selectors, nselectors);\n\tif (idx < 0)\n\t\treturn idx;\n\n\tlan966x_port_apptrust[port->chip_port] = &lan966x_dcb_apptrust_policies[idx];\n\tlan966x_dcb_app_update(dev);\n\n\treturn 0;\n}\n\nstatic int lan966x_dcb_getapptrust(struct net_device *dev, u8 *selectors,\n\t\t\t\t   int *nselectors)\n{\n\tstruct lan966x_port *port = netdev_priv(dev);\n\tconst struct lan966x_dcb_apptrust *trust;\n\n\ttrust = lan966x_port_apptrust[port->chip_port];\n\n\tmemcpy(selectors, trust->selectors, trust->nselectors);\n\t*nselectors = trust->nselectors;\n\n\treturn 0;\n}\n\nstatic int lan966x_dcb_delrewr(struct net_device *dev, struct dcb_app *app)\n{\n\tint err;\n\n\tif (app->selector == IEEE_8021QAZ_APP_SEL_DSCP)\n\t\terr = lan966x_dcb_ieee_dscp_setdel(dev, app, dcb_delrewr);\n\telse\n\t\terr = dcb_delrewr(dev, app);\n\n\tif (err < 0)\n\t\treturn err;\n\n\tlan966x_dcb_app_update(dev);\n\n\treturn 0;\n}\n\nstatic int lan966x_dcb_setrewr(struct net_device *dev, struct dcb_app *app)\n{\n\tstruct dcb_app app_itr;\n\tu16 proto;\n\tint err;\n\n\terr = lan966x_dcb_app_validate(dev, app);\n\tif (err)\n\t\tgoto out;\n\n\t \n\tproto = dcb_getrewr(dev, app);\n\tif (proto) {\n\t\tapp_itr = *app;\n\t\tapp_itr.protocol = proto;\n\t\tlan966x_dcb_delrewr(dev, &app_itr);\n\t}\n\n\tif (app->selector == IEEE_8021QAZ_APP_SEL_DSCP)\n\t\terr = lan966x_dcb_ieee_dscp_setdel(dev, app, dcb_setrewr);\n\telse\n\t\terr = dcb_setrewr(dev, app);\n\n\tif (err)\n\t\tgoto out;\n\n\tlan966x_dcb_app_update(dev);\n\nout:\n\treturn err;\n}\n\nstatic const struct dcbnl_rtnl_ops lan966x_dcbnl_ops = {\n\t.ieee_setapp = lan966x_dcb_ieee_setapp,\n\t.ieee_delapp = lan966x_dcb_ieee_delapp,\n\t.dcbnl_setapptrust = lan966x_dcb_setapptrust,\n\t.dcbnl_getapptrust = lan966x_dcb_getapptrust,\n\t.dcbnl_setrewr = lan966x_dcb_setrewr,\n\t.dcbnl_delrewr = lan966x_dcb_delrewr,\n};\n\nvoid lan966x_dcb_init(struct lan966x *lan966x)\n{\n\tfor (int p = 0; p < lan966x->num_phys_ports; ++p) {\n\t\tstruct lan966x_port *port;\n\n\t\tport = lan966x->ports[p];\n\t\tif (!port)\n\t\t\tcontinue;\n\n\t\tport->dev->dcbnl_ops = &lan966x_dcbnl_ops;\n\n\t\tlan966x_port_apptrust[port->chip_port] =\n\t\t\t&lan966x_dcb_apptrust_policies[LAN966X_DCB_APPTRUST_DSCP_PCP];\n\n\t\t \n\t\tlan966x_port_qos_dscp_rewr_mode_set(port,\n\t\t\t\t\t\t    LAN966X_PORT_QOS_REWR_DSCP_ALL);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}