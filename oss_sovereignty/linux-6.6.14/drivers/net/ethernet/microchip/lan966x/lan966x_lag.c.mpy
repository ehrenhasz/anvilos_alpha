{
  "module_name": "lan966x_lag.c",
  "hash_id": "946266c5d5c794a41ae3f0bf30ad3db93ebd4491c7450f21a03602a6f58d0926",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/microchip/lan966x/lan966x_lag.c",
  "human_readable_source": "\n\n#include <linux/if_bridge.h>\n\n#include \"lan966x_main.h\"\n\nstatic void lan966x_lag_set_aggr_pgids(struct lan966x *lan966x)\n{\n\tu32 visited = GENMASK(lan966x->num_phys_ports - 1, 0);\n\tint p, lag, i;\n\n\t \n\tfor (p = 0; p < lan966x->num_phys_ports; ++p)\n\t\tlan_wr(ANA_PGID_PGID_SET(BIT(p)),\n\t\t       lan966x, ANA_PGID(p));\n\n\tfor (p = PGID_AGGR; p < PGID_SRC; ++p)\n\t\tlan_wr(ANA_PGID_PGID_SET(visited),\n\t\t       lan966x, ANA_PGID(p));\n\n\t \n\tfor (p = 0; p < lan966x->num_phys_ports; ++p) {\n\t\tstruct lan966x_port *port = lan966x->ports[p];\n\n\t\tif (!port || !port->bond)\n\t\t\tcontinue;\n\n\t\tvisited &= ~BIT(p);\n\t}\n\n\t \n\tfor (lag = 0; lag < lan966x->num_phys_ports; ++lag) {\n\t\tstruct net_device *bond = lan966x->ports[lag]->bond;\n\t\tint num_active_ports = 0;\n\t\tunsigned long bond_mask;\n\t\tu8 aggr_idx[16];\n\n\t\tif (!bond || (visited & BIT(lag)))\n\t\t\tcontinue;\n\n\t\tbond_mask = lan966x_lag_get_mask(lan966x, bond);\n\n\t\tfor_each_set_bit(p, &bond_mask, lan966x->num_phys_ports) {\n\t\t\tstruct lan966x_port *port = lan966x->ports[p];\n\n\t\t\tlan_wr(ANA_PGID_PGID_SET(bond_mask),\n\t\t\t       lan966x, ANA_PGID(p));\n\t\t\tif (port->lag_tx_active)\n\t\t\t\taggr_idx[num_active_ports++] = p;\n\t\t}\n\n\t\tfor (i = PGID_AGGR; i < PGID_SRC; ++i) {\n\t\t\tu32 ac;\n\n\t\t\tac = lan_rd(lan966x, ANA_PGID(i));\n\t\t\tac &= ~bond_mask;\n\t\t\t \n\t\t\tif (num_active_ports)\n\t\t\t\tac |= BIT(aggr_idx[i % num_active_ports]);\n\t\t\tlan_wr(ANA_PGID_PGID_SET(ac),\n\t\t\t       lan966x, ANA_PGID(i));\n\t\t}\n\n\t\t \n\t\tfor (p = lag; p < lan966x->num_phys_ports; p++) {\n\t\t\tstruct lan966x_port *port = lan966x->ports[p];\n\n\t\t\tif (!port)\n\t\t\t\tcontinue;\n\n\t\t\tif (port->bond == bond)\n\t\t\t\tvisited |= BIT(p);\n\t\t}\n\t}\n}\n\nstatic void lan966x_lag_set_port_ids(struct lan966x *lan966x)\n{\n\tstruct lan966x_port *port;\n\tu32 bond_mask;\n\tu32 lag_id;\n\tint p;\n\n\tfor (p = 0; p < lan966x->num_phys_ports; ++p) {\n\t\tport = lan966x->ports[p];\n\t\tif (!port)\n\t\t\tcontinue;\n\n\t\tlag_id = port->chip_port;\n\n\t\tbond_mask = lan966x_lag_get_mask(lan966x, port->bond);\n\t\tif (bond_mask)\n\t\t\tlag_id = __ffs(bond_mask);\n\n\t\tlan_rmw(ANA_PORT_CFG_PORTID_VAL_SET(lag_id),\n\t\t\tANA_PORT_CFG_PORTID_VAL,\n\t\t\tlan966x, ANA_PORT_CFG(port->chip_port));\n\t}\n}\n\nstatic void lan966x_lag_update_ids(struct lan966x *lan966x)\n{\n\tlan966x_lag_set_port_ids(lan966x);\n\tlan966x_update_fwd_mask(lan966x);\n\tlan966x_lag_set_aggr_pgids(lan966x);\n}\n\nint lan966x_lag_port_join(struct lan966x_port *port,\n\t\t\t  struct net_device *brport_dev,\n\t\t\t  struct net_device *bond,\n\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct lan966x *lan966x = port->lan966x;\n\tstruct net_device *dev = port->dev;\n\tu32 lag_id = -1;\n\tu32 bond_mask;\n\tint err;\n\n\tbond_mask = lan966x_lag_get_mask(lan966x, bond);\n\tif (bond_mask)\n\t\tlag_id = __ffs(bond_mask);\n\n\tport->bond = bond;\n\tlan966x_lag_update_ids(lan966x);\n\n\terr = switchdev_bridge_port_offload(brport_dev, dev, port,\n\t\t\t\t\t    &lan966x_switchdev_nb,\n\t\t\t\t\t    &lan966x_switchdev_blocking_nb,\n\t\t\t\t\t    false, extack);\n\tif (err)\n\t\tgoto out;\n\n\tlan966x_port_stp_state_set(port, br_port_get_stp_state(brport_dev));\n\n\tif (lan966x_lag_first_port(port->bond, port->dev) &&\n\t    lag_id != -1)\n\t\tlan966x_mac_lag_replace_port_entry(lan966x,\n\t\t\t\t\t\t   lan966x->ports[lag_id],\n\t\t\t\t\t\t   port);\n\n\treturn 0;\n\nout:\n\tport->bond = NULL;\n\tlan966x_lag_update_ids(lan966x);\n\n\treturn err;\n}\n\nvoid lan966x_lag_port_leave(struct lan966x_port *port, struct net_device *bond)\n{\n\tstruct lan966x *lan966x = port->lan966x;\n\tu32 bond_mask;\n\tu32 lag_id;\n\n\tif (lan966x_lag_first_port(port->bond, port->dev)) {\n\t\tbond_mask = lan966x_lag_get_mask(lan966x, port->bond);\n\t\tbond_mask &= ~BIT(port->chip_port);\n\t\tif (bond_mask) {\n\t\t\tlag_id = __ffs(bond_mask);\n\t\t\tlan966x_mac_lag_replace_port_entry(lan966x, port,\n\t\t\t\t\t\t\t   lan966x->ports[lag_id]);\n\t\t} else {\n\t\t\tlan966x_mac_lag_remove_port_entry(lan966x, port);\n\t\t}\n\t}\n\n\tport->bond = NULL;\n\tlan966x_lag_update_ids(lan966x);\n\tlan966x_port_stp_state_set(port, BR_STATE_FORWARDING);\n}\n\nstatic bool lan966x_lag_port_check_hash_types(struct lan966x *lan966x,\n\t\t\t\t\t      enum netdev_lag_hash hash_type)\n{\n\tint p;\n\n\tfor (p = 0; p < lan966x->num_phys_ports; ++p) {\n\t\tstruct lan966x_port *port = lan966x->ports[p];\n\n\t\tif (!port || !port->bond)\n\t\t\tcontinue;\n\n\t\tif (port->hash_type != hash_type)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nint lan966x_lag_port_prechangeupper(struct net_device *dev,\n\t\t\t\t    struct netdev_notifier_changeupper_info *info)\n{\n\tstruct lan966x_port *port = netdev_priv(dev);\n\tstruct lan966x *lan966x = port->lan966x;\n\tstruct netdev_lag_upper_info *lui;\n\tstruct netlink_ext_ack *extack;\n\n\textack = netdev_notifier_info_to_extack(&info->info);\n\tlui = info->upper_info;\n\tif (!lui) {\n\t\tport->hash_type = NETDEV_LAG_HASH_NONE;\n\t\treturn NOTIFY_DONE;\n\t}\n\n\tif (lui->tx_type != NETDEV_LAG_TX_TYPE_HASH) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"LAG device using unsupported Tx type\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!lan966x_lag_port_check_hash_types(lan966x, lui->hash_type)) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"LAG devices can have only the same hash_type\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (lui->hash_type) {\n\tcase NETDEV_LAG_HASH_L2:\n\t\tlan_wr(ANA_AGGR_CFG_AC_DMAC_ENA_SET(1) |\n\t\t       ANA_AGGR_CFG_AC_SMAC_ENA_SET(1),\n\t\t       lan966x, ANA_AGGR_CFG);\n\t\tbreak;\n\tcase NETDEV_LAG_HASH_L34:\n\t\tlan_wr(ANA_AGGR_CFG_AC_IP6_TCPUDP_ENA_SET(1) |\n\t\t       ANA_AGGR_CFG_AC_IP4_TCPUDP_ENA_SET(1) |\n\t\t       ANA_AGGR_CFG_AC_IP4_SIPDIP_ENA_SET(1),\n\t\t       lan966x, ANA_AGGR_CFG);\n\t\tbreak;\n\tcase NETDEV_LAG_HASH_L23:\n\t\tlan_wr(ANA_AGGR_CFG_AC_DMAC_ENA_SET(1) |\n\t\t       ANA_AGGR_CFG_AC_SMAC_ENA_SET(1) |\n\t\t       ANA_AGGR_CFG_AC_IP6_TCPUDP_ENA_SET(1) |\n\t\t       ANA_AGGR_CFG_AC_IP4_TCPUDP_ENA_SET(1),\n\t\t       lan966x, ANA_AGGR_CFG);\n\t\tbreak;\n\tdefault:\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"LAG device using unsupported hash type\");\n\t\treturn -EINVAL;\n\t}\n\n\tport->hash_type = lui->hash_type;\n\n\treturn NOTIFY_OK;\n}\n\nint lan966x_lag_port_changelowerstate(struct net_device *dev,\n\t\t\t\t      struct netdev_notifier_changelowerstate_info *info)\n{\n\tstruct netdev_lag_lower_state_info *lag = info->lower_state_info;\n\tstruct lan966x_port *port = netdev_priv(dev);\n\tstruct lan966x *lan966x = port->lan966x;\n\tbool is_active;\n\n\tif (!port->bond)\n\t\treturn NOTIFY_DONE;\n\n\tis_active = lag->link_up && lag->tx_enabled;\n\tif (port->lag_tx_active == is_active)\n\t\treturn NOTIFY_DONE;\n\n\tport->lag_tx_active = is_active;\n\tlan966x_lag_set_aggr_pgids(lan966x);\n\n\treturn NOTIFY_OK;\n}\n\nint lan966x_lag_netdev_prechangeupper(struct net_device *dev,\n\t\t\t\t      struct netdev_notifier_changeupper_info *info)\n{\n\tstruct lan966x_port *port;\n\tstruct net_device *lower;\n\tstruct list_head *iter;\n\tint err;\n\n\tnetdev_for_each_lower_dev(dev, lower, iter) {\n\t\tif (!lan966x_netdevice_check(lower))\n\t\t\tcontinue;\n\n\t\tport = netdev_priv(lower);\n\t\tif (port->bond != dev)\n\t\t\tcontinue;\n\n\t\terr = lan966x_port_prechangeupper(lower, dev, info);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn NOTIFY_DONE;\n}\n\nint lan966x_lag_netdev_changeupper(struct net_device *dev,\n\t\t\t\t   struct netdev_notifier_changeupper_info *info)\n{\n\tstruct lan966x_port *port;\n\tstruct net_device *lower;\n\tstruct list_head *iter;\n\tint err;\n\n\tnetdev_for_each_lower_dev(dev, lower, iter) {\n\t\tif (!lan966x_netdevice_check(lower))\n\t\t\tcontinue;\n\n\t\tport = netdev_priv(lower);\n\t\tif (port->bond != dev)\n\t\t\tcontinue;\n\n\t\terr = lan966x_port_changeupper(lower, dev, info);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn NOTIFY_DONE;\n}\n\nbool lan966x_lag_first_port(struct net_device *lag, struct net_device *dev)\n{\n\tstruct lan966x_port *port = netdev_priv(dev);\n\tstruct lan966x *lan966x = port->lan966x;\n\tunsigned long bond_mask;\n\n\tif (port->bond != lag)\n\t\treturn false;\n\n\tbond_mask = lan966x_lag_get_mask(lan966x, lag);\n\tif (bond_mask && port->chip_port == __ffs(bond_mask))\n\t\treturn true;\n\n\treturn false;\n}\n\nu32 lan966x_lag_get_mask(struct lan966x *lan966x, struct net_device *bond)\n{\n\tstruct lan966x_port *port;\n\tu32 mask = 0;\n\tint p;\n\n\tif (!bond)\n\t\treturn mask;\n\n\tfor (p = 0; p < lan966x->num_phys_ports; p++) {\n\t\tport = lan966x->ports[p];\n\t\tif (!port)\n\t\t\tcontinue;\n\n\t\tif (port->bond == bond)\n\t\t\tmask |= BIT(p);\n\t}\n\n\treturn mask;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}