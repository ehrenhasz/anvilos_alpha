{
  "module_name": "lan966x_police.c",
  "hash_id": "b754136f54a4cb2c9bb316cf7bd7281d6a386a6a06d09cdeb1712ee5d392bfaa",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/microchip/lan966x/lan966x_police.c",
  "human_readable_source": "\n\n#include \"lan966x_main.h\"\n\n \n#define POL_IDX_PORT\t0\n\n \n#define POL_ORDER\t0x1d3\n\nstruct lan966x_tc_policer {\n\t \n\tu32 rate;\n\t \n\tu32 burst;\n};\n\nstatic int lan966x_police_add(struct lan966x_port *port,\n\t\t\t      struct lan966x_tc_policer *pol,\n\t\t\t      u16 pol_idx)\n{\n\tstruct lan966x *lan966x = port->lan966x;\n\n\t \n\tpol->rate = DIV_ROUND_UP(pol->rate * 3, 100);\n\t \n\tpol->burst = pol->burst ?: 1;\n\t \n\tpol->burst = DIV_ROUND_UP(pol->burst, 4096);\n\n\tif (pol->rate > GENMASK(15, 0) ||\n\t    pol->burst > GENMASK(6, 0))\n\t\treturn -EINVAL;\n\n\tlan_wr(ANA_POL_MODE_DROP_ON_YELLOW_ENA_SET(0) |\n\t       ANA_POL_MODE_MARK_ALL_FRMS_RED_ENA_SET(0) |\n\t       ANA_POL_MODE_IPG_SIZE_SET(20) |\n\t       ANA_POL_MODE_FRM_MODE_SET(1) |\n\t       ANA_POL_MODE_OVERSHOOT_ENA_SET(1),\n\t       lan966x, ANA_POL_MODE(pol_idx));\n\n\tlan_wr(ANA_POL_PIR_STATE_PIR_LVL_SET(0),\n\t       lan966x, ANA_POL_PIR_STATE(pol_idx));\n\n\tlan_wr(ANA_POL_PIR_CFG_PIR_RATE_SET(pol->rate) |\n\t       ANA_POL_PIR_CFG_PIR_BURST_SET(pol->burst),\n\t       lan966x, ANA_POL_PIR_CFG(pol_idx));\n\n\treturn 0;\n}\n\nstatic void lan966x_police_del(struct lan966x_port *port, u16 pol_idx)\n{\n\tstruct lan966x *lan966x = port->lan966x;\n\n\tlan_wr(ANA_POL_MODE_DROP_ON_YELLOW_ENA_SET(0) |\n\t       ANA_POL_MODE_MARK_ALL_FRMS_RED_ENA_SET(0) |\n\t       ANA_POL_MODE_IPG_SIZE_SET(20) |\n\t       ANA_POL_MODE_FRM_MODE_SET(2) |\n\t       ANA_POL_MODE_OVERSHOOT_ENA_SET(1),\n\t       lan966x, ANA_POL_MODE(pol_idx));\n\n\tlan_wr(ANA_POL_PIR_STATE_PIR_LVL_SET(0),\n\t       lan966x, ANA_POL_PIR_STATE(pol_idx));\n\n\tlan_wr(ANA_POL_PIR_CFG_PIR_RATE_SET(GENMASK(14, 0)) |\n\t       ANA_POL_PIR_CFG_PIR_BURST_SET(0),\n\t       lan966x, ANA_POL_PIR_CFG(pol_idx));\n}\n\nstatic int lan966x_police_validate(struct lan966x_port *port,\n\t\t\t\t   const struct flow_action *action,\n\t\t\t\t   const struct flow_action_entry *act,\n\t\t\t\t   unsigned long police_id,\n\t\t\t\t   bool ingress,\n\t\t\t\t   struct netlink_ext_ack *extack)\n{\n\tif (act->police.exceed.act_id != FLOW_ACTION_DROP) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Offload not supported when exceed action is not drop\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (act->police.notexceed.act_id != FLOW_ACTION_PIPE &&\n\t    act->police.notexceed.act_id != FLOW_ACTION_ACCEPT) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Offload not supported when conform action is not pipe or ok\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (act->police.notexceed.act_id == FLOW_ACTION_ACCEPT &&\n\t    !flow_action_is_last_entry(action, act)) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Offload not supported when conform action is ok, but action is not last\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (act->police.peakrate_bytes_ps ||\n\t    act->police.avrate || act->police.overhead) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Offload not supported when peakrate/avrate/overhead is configured\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (act->police.rate_pkt_ps) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"QoS offload not support packets per second\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (!ingress) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Policer is not supported on egress\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (port->tc.ingress_shared_block) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Policer is not supported on shared ingress blocks\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (port->tc.police_id && port->tc.police_id != police_id) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Only one policer per port is supported\");\n\t\treturn -EEXIST;\n\t}\n\n\treturn 0;\n}\n\nint lan966x_police_port_add(struct lan966x_port *port,\n\t\t\t    struct flow_action *action,\n\t\t\t    struct flow_action_entry *act,\n\t\t\t    unsigned long police_id,\n\t\t\t    bool ingress,\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct lan966x *lan966x = port->lan966x;\n\tstruct rtnl_link_stats64 new_stats;\n\tstruct lan966x_tc_policer pol;\n\tstruct flow_stats *old_stats;\n\tint err;\n\n\terr = lan966x_police_validate(port, action, act, police_id, ingress,\n\t\t\t\t      extack);\n\tif (err)\n\t\treturn err;\n\n\tmemset(&pol, 0, sizeof(pol));\n\n\tpol.rate = div_u64(act->police.rate_bytes_ps, 1000) * 8;\n\tpol.burst = act->police.burst;\n\n\terr = lan966x_police_add(port, &pol, POL_IDX_PORT + port->chip_port);\n\tif (err) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Failed to add policer to port\");\n\t\treturn err;\n\t}\n\n\tlan_rmw(ANA_POL_CFG_PORT_POL_ENA_SET(1) |\n\t\tANA_POL_CFG_POL_ORDER_SET(POL_ORDER),\n\t\tANA_POL_CFG_PORT_POL_ENA |\n\t\tANA_POL_CFG_POL_ORDER,\n\t\tlan966x, ANA_POL_CFG(port->chip_port));\n\n\tport->tc.police_id = police_id;\n\n\t \n\told_stats = &port->tc.police_stat;\n\tlan966x_stats_get(port->dev, &new_stats);\n\told_stats->bytes = new_stats.rx_bytes;\n\told_stats->pkts = new_stats.rx_packets;\n\told_stats->drops = new_stats.rx_dropped;\n\told_stats->lastused = jiffies;\n\n\treturn 0;\n}\n\nint lan966x_police_port_del(struct lan966x_port *port,\n\t\t\t    unsigned long police_id,\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct lan966x *lan966x = port->lan966x;\n\n\tif (port->tc.police_id != police_id) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Invalid policer id\");\n\t\treturn -EINVAL;\n\t}\n\n\tlan966x_police_del(port, POL_IDX_PORT + port->chip_port);\n\n\tlan_rmw(ANA_POL_CFG_PORT_POL_ENA_SET(0) |\n\t\tANA_POL_CFG_POL_ORDER_SET(POL_ORDER),\n\t\tANA_POL_CFG_PORT_POL_ENA |\n\t\tANA_POL_CFG_POL_ORDER,\n\t\tlan966x, ANA_POL_CFG(port->chip_port));\n\n\tport->tc.police_id = 0;\n\n\treturn 0;\n}\n\nvoid lan966x_police_port_stats(struct lan966x_port *port,\n\t\t\t       struct flow_stats *stats)\n{\n\tstruct rtnl_link_stats64 new_stats;\n\tstruct flow_stats *old_stats;\n\n\told_stats = &port->tc.police_stat;\n\tlan966x_stats_get(port->dev, &new_stats);\n\n\tflow_stats_update(stats,\n\t\t\t  new_stats.rx_bytes - old_stats->bytes,\n\t\t\t  new_stats.rx_packets - old_stats->pkts,\n\t\t\t  new_stats.rx_dropped - old_stats->drops,\n\t\t\t  old_stats->lastused,\n\t\t\t  FLOW_ACTION_HW_STATS_IMMEDIATE);\n\n\told_stats->bytes = new_stats.rx_bytes;\n\told_stats->pkts = new_stats.rx_packets;\n\told_stats->drops = new_stats.rx_dropped;\n\told_stats->lastused = jiffies;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}