{
  "module_name": "lan966x_tc_matchall.c",
  "hash_id": "29c74e7bd47a15dcf7a0cfc885a3471ea169af4f040939771bb84290d3c58224",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/microchip/lan966x/lan966x_tc_matchall.c",
  "human_readable_source": "\n\n#include \"lan966x_main.h\"\n\nstatic int lan966x_tc_matchall_add(struct lan966x_port *port,\n\t\t\t\t   struct tc_cls_matchall_offload *f,\n\t\t\t\t   bool ingress)\n{\n\tstruct flow_action_entry *act;\n\n\tif (!flow_offload_has_one_action(&f->rule->action)) {\n\t\tNL_SET_ERR_MSG_MOD(f->common.extack,\n\t\t\t\t   \"Only once action per filter is supported\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tact = &f->rule->action.entries[0];\n\tswitch (act->id) {\n\tcase FLOW_ACTION_POLICE:\n\t\treturn lan966x_police_port_add(port, &f->rule->action, act,\n\t\t\t\t\t       f->cookie, ingress,\n\t\t\t\t\t       f->common.extack);\n\tcase FLOW_ACTION_MIRRED:\n\t\treturn lan966x_mirror_port_add(port, act, f->cookie,\n\t\t\t\t\t       ingress, f->common.extack);\n\tcase FLOW_ACTION_GOTO:\n\t\treturn lan966x_goto_port_add(port, f->common.chain_index,\n\t\t\t\t\t     act->chain_index, f->cookie,\n\t\t\t\t\t     f->common.extack);\n\tdefault:\n\t\tNL_SET_ERR_MSG_MOD(f->common.extack,\n\t\t\t\t   \"Unsupported action\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic int lan966x_tc_matchall_del(struct lan966x_port *port,\n\t\t\t\t   struct tc_cls_matchall_offload *f,\n\t\t\t\t   bool ingress)\n{\n\tif (f->cookie == port->tc.police_id) {\n\t\treturn lan966x_police_port_del(port, f->cookie,\n\t\t\t\t\t       f->common.extack);\n\t} else if (f->cookie == port->tc.ingress_mirror_id ||\n\t\t   f->cookie == port->tc.egress_mirror_id) {\n\t\treturn lan966x_mirror_port_del(port, ingress,\n\t\t\t\t\t       f->common.extack);\n\t} else {\n\t\treturn lan966x_goto_port_del(port, f->cookie, f->common.extack);\n\t}\n\n\treturn 0;\n}\n\nstatic int lan966x_tc_matchall_stats(struct lan966x_port *port,\n\t\t\t\t     struct tc_cls_matchall_offload *f,\n\t\t\t\t     bool ingress)\n{\n\tif (f->cookie == port->tc.police_id) {\n\t\tlan966x_police_port_stats(port, &f->stats);\n\t} else if (f->cookie == port->tc.ingress_mirror_id ||\n\t\t   f->cookie == port->tc.egress_mirror_id) {\n\t\tlan966x_mirror_port_stats(port, &f->stats, ingress);\n\t} else {\n\t\tNL_SET_ERR_MSG_MOD(f->common.extack,\n\t\t\t\t   \"Unsupported action\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nint lan966x_tc_matchall(struct lan966x_port *port,\n\t\t\tstruct tc_cls_matchall_offload *f,\n\t\t\tbool ingress)\n{\n\tswitch (f->command) {\n\tcase TC_CLSMATCHALL_REPLACE:\n\t\treturn lan966x_tc_matchall_add(port, f, ingress);\n\tcase TC_CLSMATCHALL_DESTROY:\n\t\treturn lan966x_tc_matchall_del(port, f, ingress);\n\tcase TC_CLSMATCHALL_STATS:\n\t\treturn lan966x_tc_matchall_stats(port, f, ingress);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}