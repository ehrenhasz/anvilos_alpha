{
  "module_name": "lan966x_tc_flower.c",
  "hash_id": "34d3fff6fa065aea1b516f59bfc91a0f4ea584c272f09160465bce804cb3978a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/microchip/lan966x/lan966x_tc_flower.c",
  "human_readable_source": "\n\n#include \"lan966x_main.h\"\n#include \"vcap_api.h\"\n#include \"vcap_api_client.h\"\n#include \"vcap_tc.h\"\n\n#define LAN966X_FORCE_UNTAGED\t3\n\nstatic bool lan966x_tc_is_known_etype(struct vcap_tc_flower_parse_usage *st,\n\t\t\t\t      u16 etype)\n{\n\tswitch (st->admin->vtype) {\n\tcase VCAP_TYPE_IS1:\n\t\tswitch (etype) {\n\t\tcase ETH_P_ALL:\n\t\tcase ETH_P_ARP:\n\t\tcase ETH_P_IP:\n\t\tcase ETH_P_IPV6:\n\t\t\treturn true;\n\t\t}\n\t\tbreak;\n\tcase VCAP_TYPE_IS2:\n\t\tswitch (etype) {\n\t\tcase ETH_P_ALL:\n\t\tcase ETH_P_ARP:\n\t\tcase ETH_P_IP:\n\t\tcase ETH_P_IPV6:\n\t\tcase ETH_P_SNAP:\n\t\tcase ETH_P_802_2:\n\t\t\treturn true;\n\t\t}\n\t\tbreak;\n\tcase VCAP_TYPE_ES0:\n\t\treturn true;\n\tdefault:\n\t\tNL_SET_ERR_MSG_MOD(st->fco->common.extack,\n\t\t\t\t   \"VCAP type not supported\");\n\t\treturn false;\n\t}\n\n\treturn false;\n}\n\nstatic int\nlan966x_tc_flower_handler_control_usage(struct vcap_tc_flower_parse_usage *st)\n{\n\tstruct flow_match_control match;\n\tint err = 0;\n\n\tflow_rule_match_control(st->frule, &match);\n\tif (match.mask->flags & FLOW_DIS_IS_FRAGMENT) {\n\t\tif (match.key->flags & FLOW_DIS_IS_FRAGMENT)\n\t\t\terr = vcap_rule_add_key_bit(st->vrule,\n\t\t\t\t\t\t    VCAP_KF_L3_FRAGMENT,\n\t\t\t\t\t\t    VCAP_BIT_1);\n\t\telse\n\t\t\terr = vcap_rule_add_key_bit(st->vrule,\n\t\t\t\t\t\t    VCAP_KF_L3_FRAGMENT,\n\t\t\t\t\t\t    VCAP_BIT_0);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tif (match.mask->flags & FLOW_DIS_FIRST_FRAG) {\n\t\tif (match.key->flags & FLOW_DIS_FIRST_FRAG)\n\t\t\terr = vcap_rule_add_key_bit(st->vrule,\n\t\t\t\t\t\t    VCAP_KF_L3_FRAG_OFS_GT0,\n\t\t\t\t\t\t    VCAP_BIT_0);\n\t\telse\n\t\t\terr = vcap_rule_add_key_bit(st->vrule,\n\t\t\t\t\t\t    VCAP_KF_L3_FRAG_OFS_GT0,\n\t\t\t\t\t\t    VCAP_BIT_1);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tst->used_keys |= BIT_ULL(FLOW_DISSECTOR_KEY_CONTROL);\n\n\treturn err;\n\nout:\n\tNL_SET_ERR_MSG_MOD(st->fco->common.extack, \"ip_frag parse error\");\n\treturn err;\n}\n\nstatic int\nlan966x_tc_flower_handler_basic_usage(struct vcap_tc_flower_parse_usage *st)\n{\n\tstruct flow_match_basic match;\n\tint err = 0;\n\n\tflow_rule_match_basic(st->frule, &match);\n\tif (match.mask->n_proto) {\n\t\tst->l3_proto = be16_to_cpu(match.key->n_proto);\n\t\tif (!lan966x_tc_is_known_etype(st, st->l3_proto)) {\n\t\t\terr = vcap_rule_add_key_u32(st->vrule, VCAP_KF_ETYPE,\n\t\t\t\t\t\t    st->l3_proto, ~0);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t} else if (st->l3_proto == ETH_P_IP) {\n\t\t\terr = vcap_rule_add_key_bit(st->vrule, VCAP_KF_IP4_IS,\n\t\t\t\t\t\t    VCAP_BIT_1);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t} else if (st->l3_proto == ETH_P_IPV6 &&\n\t\t\t   st->admin->vtype == VCAP_TYPE_IS1) {\n\t\t\t \n\t\t} else if (st->l3_proto == ETH_P_SNAP &&\n\t\t\t   st->admin->vtype == VCAP_TYPE_IS1) {\n\t\t\terr = vcap_rule_add_key_bit(st->vrule,\n\t\t\t\t\t\t    VCAP_KF_ETYPE_LEN_IS,\n\t\t\t\t\t\t    VCAP_BIT_0);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\n\t\t\terr = vcap_rule_add_key_bit(st->vrule,\n\t\t\t\t\t\t    VCAP_KF_IP_SNAP_IS,\n\t\t\t\t\t\t    VCAP_BIT_1);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t} else if (st->admin->vtype == VCAP_TYPE_IS1) {\n\t\t\terr = vcap_rule_add_key_bit(st->vrule,\n\t\t\t\t\t\t    VCAP_KF_ETYPE_LEN_IS,\n\t\t\t\t\t\t    VCAP_BIT_1);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\n\t\t\terr = vcap_rule_add_key_u32(st->vrule, VCAP_KF_ETYPE,\n\t\t\t\t\t\t    st->l3_proto, ~0);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\tif (match.mask->ip_proto) {\n\t\tst->l4_proto = match.key->ip_proto;\n\n\t\tif (st->l4_proto == IPPROTO_TCP) {\n\t\t\tif (st->admin->vtype == VCAP_TYPE_IS1) {\n\t\t\t\terr = vcap_rule_add_key_bit(st->vrule,\n\t\t\t\t\t\t\t    VCAP_KF_TCP_UDP_IS,\n\t\t\t\t\t\t\t    VCAP_BIT_1);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\terr = vcap_rule_add_key_bit(st->vrule,\n\t\t\t\t\t\t    VCAP_KF_TCP_IS,\n\t\t\t\t\t\t    VCAP_BIT_1);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t} else if (st->l4_proto == IPPROTO_UDP) {\n\t\t\tif (st->admin->vtype == VCAP_TYPE_IS1) {\n\t\t\t\terr = vcap_rule_add_key_bit(st->vrule,\n\t\t\t\t\t\t\t    VCAP_KF_TCP_UDP_IS,\n\t\t\t\t\t\t\t    VCAP_BIT_1);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\terr = vcap_rule_add_key_bit(st->vrule,\n\t\t\t\t\t\t    VCAP_KF_TCP_IS,\n\t\t\t\t\t\t    VCAP_BIT_0);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t} else {\n\t\t\terr = vcap_rule_add_key_u32(st->vrule,\n\t\t\t\t\t\t    VCAP_KF_L3_IP_PROTO,\n\t\t\t\t\t\t    st->l4_proto, ~0);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\n\tst->used_keys |= BIT_ULL(FLOW_DISSECTOR_KEY_BASIC);\n\treturn err;\nout:\n\tNL_SET_ERR_MSG_MOD(st->fco->common.extack, \"ip_proto parse error\");\n\treturn err;\n}\n\nstatic int\nlan966x_tc_flower_handler_cvlan_usage(struct vcap_tc_flower_parse_usage *st)\n{\n\tif (st->admin->vtype != VCAP_TYPE_IS1) {\n\t\tNL_SET_ERR_MSG_MOD(st->fco->common.extack,\n\t\t\t\t   \"cvlan not supported in this VCAP\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn vcap_tc_flower_handler_cvlan_usage(st);\n}\n\nstatic int\nlan966x_tc_flower_handler_vlan_usage(struct vcap_tc_flower_parse_usage *st)\n{\n\tenum vcap_key_field vid_key = VCAP_KF_8021Q_VID_CLS;\n\tenum vcap_key_field pcp_key = VCAP_KF_8021Q_PCP_CLS;\n\n\tif (st->admin->vtype == VCAP_TYPE_IS1) {\n\t\tvid_key = VCAP_KF_8021Q_VID0;\n\t\tpcp_key = VCAP_KF_8021Q_PCP0;\n\t}\n\n\treturn vcap_tc_flower_handler_vlan_usage(st, vid_key, pcp_key);\n}\n\nstatic int\n(*lan966x_tc_flower_handlers_usage[])(struct vcap_tc_flower_parse_usage *st) = {\n\t[FLOW_DISSECTOR_KEY_ETH_ADDRS] = vcap_tc_flower_handler_ethaddr_usage,\n\t[FLOW_DISSECTOR_KEY_IPV4_ADDRS] = vcap_tc_flower_handler_ipv4_usage,\n\t[FLOW_DISSECTOR_KEY_IPV6_ADDRS] = vcap_tc_flower_handler_ipv6_usage,\n\t[FLOW_DISSECTOR_KEY_CONTROL] = lan966x_tc_flower_handler_control_usage,\n\t[FLOW_DISSECTOR_KEY_PORTS] = vcap_tc_flower_handler_portnum_usage,\n\t[FLOW_DISSECTOR_KEY_BASIC] = lan966x_tc_flower_handler_basic_usage,\n\t[FLOW_DISSECTOR_KEY_CVLAN] = lan966x_tc_flower_handler_cvlan_usage,\n\t[FLOW_DISSECTOR_KEY_VLAN] = lan966x_tc_flower_handler_vlan_usage,\n\t[FLOW_DISSECTOR_KEY_TCP] = vcap_tc_flower_handler_tcp_usage,\n\t[FLOW_DISSECTOR_KEY_ARP] = vcap_tc_flower_handler_arp_usage,\n\t[FLOW_DISSECTOR_KEY_IP] = vcap_tc_flower_handler_ip_usage,\n};\n\nstatic int lan966x_tc_flower_use_dissectors(struct flow_cls_offload *f,\n\t\t\t\t\t    struct vcap_admin *admin,\n\t\t\t\t\t    struct vcap_rule *vrule,\n\t\t\t\t\t    u16 *l3_proto)\n{\n\tstruct vcap_tc_flower_parse_usage state = {\n\t\t.fco = f,\n\t\t.vrule = vrule,\n\t\t.l3_proto = ETH_P_ALL,\n\t\t.admin = admin,\n\t};\n\tint err = 0;\n\n\tstate.frule = flow_cls_offload_flow_rule(f);\n\tfor (int i = 0; i < ARRAY_SIZE(lan966x_tc_flower_handlers_usage); ++i) {\n\t\tif (!flow_rule_match_key(state.frule, i) ||\n\t\t    !lan966x_tc_flower_handlers_usage[i])\n\t\t\tcontinue;\n\n\t\terr = lan966x_tc_flower_handlers_usage[i](&state);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (l3_proto)\n\t\t*l3_proto = state.l3_proto;\n\n\treturn err;\n}\n\nstatic int lan966x_tc_flower_action_check(struct vcap_control *vctrl,\n\t\t\t\t\t  struct net_device *dev,\n\t\t\t\t\t  struct flow_cls_offload *fco,\n\t\t\t\t\t  bool ingress)\n{\n\tstruct flow_rule *rule = flow_cls_offload_flow_rule(fco);\n\tstruct flow_action_entry *actent, *last_actent = NULL;\n\tstruct flow_action *act = &rule->action;\n\tu64 action_mask = 0;\n\tint idx;\n\n\tif (!flow_action_has_entries(act)) {\n\t\tNL_SET_ERR_MSG_MOD(fco->common.extack, \"No actions\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!flow_action_basic_hw_stats_check(act, fco->common.extack))\n\t\treturn -EOPNOTSUPP;\n\n\tflow_action_for_each(idx, actent, act) {\n\t\tif (action_mask & BIT(actent->id)) {\n\t\t\tNL_SET_ERR_MSG_MOD(fco->common.extack,\n\t\t\t\t\t   \"More actions of the same type\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\taction_mask |= BIT(actent->id);\n\t\tlast_actent = actent;  \n\t}\n\n\t \n\tif (last_actent->id == FLOW_ACTION_GOTO) {\n\t\t \n\t\tif (!vcap_is_next_lookup(vctrl, fco->common.chain_index,\n\t\t\t\t\t last_actent->chain_index)) {\n\t\t\tNL_SET_ERR_MSG_MOD(fco->common.extack,\n\t\t\t\t\t   \"Invalid goto chain\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else if (!vcap_is_last_chain(vctrl, fco->common.chain_index,\n\t\t\t\t       ingress)) {\n\t\tNL_SET_ERR_MSG_MOD(fco->common.extack,\n\t\t\t\t   \"Last action must be 'goto'\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (action_mask & BIT(FLOW_ACTION_TRAP) &&\n\t    action_mask & BIT(FLOW_ACTION_ACCEPT)) {\n\t\tNL_SET_ERR_MSG_MOD(fco->common.extack,\n\t\t\t\t   \"Cannot combine pass and trap action\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int lan966x_tc_set_actionset(struct vcap_admin *admin,\n\t\t\t\t    struct vcap_rule *vrule)\n{\n\tenum vcap_actionfield_set aset;\n\tint err = 0;\n\n\tswitch (admin->vtype) {\n\tcase VCAP_TYPE_IS1:\n\t\taset = VCAP_AFS_S1;\n\t\tbreak;\n\tcase VCAP_TYPE_IS2:\n\t\taset = VCAP_AFS_BASE_TYPE;\n\t\tbreak;\n\tcase VCAP_TYPE_ES0:\n\t\taset = VCAP_AFS_VID;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (vrule->actionset == VCAP_AFS_NO_VALUE)\n\t\terr = vcap_set_rule_set_actionset(vrule, aset);\n\n\treturn err;\n}\n\nstatic int lan966x_tc_add_rule_link_target(struct vcap_admin *admin,\n\t\t\t\t\t   struct vcap_rule *vrule,\n\t\t\t\t\t   int target_cid)\n{\n\tint link_val = target_cid % VCAP_CID_LOOKUP_SIZE;\n\tint err;\n\n\tif (!link_val)\n\t\treturn 0;\n\n\tswitch (admin->vtype) {\n\tcase VCAP_TYPE_IS1:\n\t\t \n\t\terr = vcap_rule_add_key_u32(vrule, VCAP_KF_LOOKUP_GEN_IDX_SEL,\n\t\t\t\t\t    1, ~0);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\treturn vcap_rule_add_key_u32(vrule, VCAP_KF_LOOKUP_GEN_IDX,\n\t\t\t\t\t     link_val, ~0);\n\tcase VCAP_TYPE_IS2:\n\t\t \n\t\treturn vcap_rule_add_key_u32(vrule, VCAP_KF_LOOKUP_PAG,\n\t\t\t\t\t     link_val, ~0);\n\tcase VCAP_TYPE_ES0:\n\t\t \n\t\treturn vcap_rule_add_key_u32(vrule, VCAP_KF_ISDX_CLS,\n\t\t\t\t\t     link_val, ~0);\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int lan966x_tc_add_rule_link(struct vcap_control *vctrl,\n\t\t\t\t    struct vcap_admin *admin,\n\t\t\t\t    struct vcap_rule *vrule,\n\t\t\t\t    struct flow_cls_offload *f,\n\t\t\t\t    int to_cid)\n{\n\tstruct vcap_admin *to_admin = vcap_find_admin(vctrl, to_cid);\n\tint diff, err = 0;\n\n\tif (!to_admin) {\n\t\tNL_SET_ERR_MSG_MOD(f->common.extack,\n\t\t\t\t   \"Unknown destination chain\");\n\t\treturn -EINVAL;\n\t}\n\n\tdiff = vcap_chain_offset(vctrl, f->common.chain_index, to_cid);\n\tif (!diff)\n\t\treturn 0;\n\n\t \n\tif (admin->vtype == VCAP_TYPE_IS1 && to_admin->vtype == VCAP_TYPE_IS2) {\n\t\t \n\t\terr = vcap_rule_add_action_u32(vrule, VCAP_AF_PAG_VAL, diff);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = vcap_rule_add_action_u32(vrule, VCAP_AF_PAG_OVERRIDE_MASK,\n\t\t\t\t\t       0xff);\n\t\tif (err)\n\t\t\treturn err;\n\t} else if (admin->vtype == VCAP_TYPE_IS1 &&\n\t\t   to_admin->vtype == VCAP_TYPE_ES0) {\n\t\t \n\t\terr = vcap_rule_add_action_u32(vrule, VCAP_AF_ISDX_ADD_VAL,\n\t\t\t\t\t       diff);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = vcap_rule_add_action_bit(vrule, VCAP_AF_ISDX_REPLACE_ENA,\n\t\t\t\t\t       VCAP_BIT_1);\n\t\tif (err)\n\t\t\treturn err;\n\t} else {\n\t\tNL_SET_ERR_MSG_MOD(f->common.extack,\n\t\t\t\t   \"Unsupported chain destination\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn err;\n}\n\nstatic int lan966x_tc_add_rule_counter(struct vcap_admin *admin,\n\t\t\t\t       struct vcap_rule *vrule)\n{\n\tint err = 0;\n\n\tswitch (admin->vtype) {\n\tcase VCAP_TYPE_ES0:\n\t\terr = vcap_rule_mod_action_u32(vrule, VCAP_AF_ESDX,\n\t\t\t\t\t       vrule->id);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nstatic int lan966x_tc_flower_add(struct lan966x_port *port,\n\t\t\t\t struct flow_cls_offload *f,\n\t\t\t\t struct vcap_admin *admin,\n\t\t\t\t bool ingress)\n{\n\tstruct flow_action_entry *act;\n\tu16 l3_proto = ETH_P_ALL;\n\tstruct flow_rule *frule;\n\tstruct vcap_rule *vrule;\n\tint err, idx;\n\n\terr = lan966x_tc_flower_action_check(port->lan966x->vcap_ctrl,\n\t\t\t\t\t     port->dev, f, ingress);\n\tif (err)\n\t\treturn err;\n\n\tvrule = vcap_alloc_rule(port->lan966x->vcap_ctrl, port->dev,\n\t\t\t\tf->common.chain_index, VCAP_USER_TC,\n\t\t\t\tf->common.prio, 0);\n\tif (IS_ERR(vrule))\n\t\treturn PTR_ERR(vrule);\n\n\tvrule->cookie = f->cookie;\n\terr = lan966x_tc_flower_use_dissectors(f, admin, vrule, &l3_proto);\n\tif (err)\n\t\tgoto out;\n\n\terr = lan966x_tc_add_rule_link_target(admin, vrule,\n\t\t\t\t\t      f->common.chain_index);\n\tif (err)\n\t\tgoto out;\n\n\tfrule = flow_cls_offload_flow_rule(f);\n\n\tflow_action_for_each(idx, act, &frule->action) {\n\t\tswitch (act->id) {\n\t\tcase FLOW_ACTION_TRAP:\n\t\t\tif (admin->vtype != VCAP_TYPE_IS2) {\n\t\t\t\tNL_SET_ERR_MSG_MOD(f->common.extack,\n\t\t\t\t\t\t   \"Trap action not supported in this VCAP\");\n\t\t\t\terr = -EOPNOTSUPP;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\terr = vcap_rule_add_action_bit(vrule,\n\t\t\t\t\t\t       VCAP_AF_CPU_COPY_ENA,\n\t\t\t\t\t\t       VCAP_BIT_1);\n\t\t\terr |= vcap_rule_add_action_u32(vrule,\n\t\t\t\t\t\t\tVCAP_AF_CPU_QUEUE_NUM,\n\t\t\t\t\t\t\t0);\n\t\t\terr |= vcap_rule_add_action_u32(vrule, VCAP_AF_MASK_MODE,\n\t\t\t\t\t\t\tLAN966X_PMM_REPLACE);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\n\t\t\tbreak;\n\t\tcase FLOW_ACTION_GOTO:\n\t\t\terr = lan966x_tc_set_actionset(admin, vrule);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\n\t\t\terr = lan966x_tc_add_rule_link(port->lan966x->vcap_ctrl,\n\t\t\t\t\t\t       admin, vrule,\n\t\t\t\t\t\t       f, act->chain_index);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\n\t\t\tbreak;\n\t\tcase FLOW_ACTION_VLAN_POP:\n\t\t\tif (admin->vtype != VCAP_TYPE_ES0) {\n\t\t\t\tNL_SET_ERR_MSG_MOD(f->common.extack,\n\t\t\t\t\t\t   \"Cannot use vlan pop on non es0\");\n\t\t\t\terr = -EOPNOTSUPP;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t \n\t\t\terr = vcap_rule_add_action_u32(vrule, VCAP_AF_PUSH_OUTER_TAG,\n\t\t\t\t\t\t       LAN966X_FORCE_UNTAGED);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tNL_SET_ERR_MSG_MOD(f->common.extack,\n\t\t\t\t\t   \"Unsupported TC action\");\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\terr = lan966x_tc_add_rule_counter(admin, vrule);\n\tif (err) {\n\t\tvcap_set_tc_exterr(f, vrule);\n\t\tgoto out;\n\t}\n\n\terr = vcap_val_rule(vrule, l3_proto);\n\tif (err) {\n\t\tvcap_set_tc_exterr(f, vrule);\n\t\tgoto out;\n\t}\n\n\terr = vcap_add_rule(vrule);\n\tif (err)\n\t\tNL_SET_ERR_MSG_MOD(f->common.extack,\n\t\t\t\t   \"Could not add the filter\");\nout:\n\tvcap_free_rule(vrule);\n\treturn err;\n}\n\nstatic int lan966x_tc_flower_del(struct lan966x_port *port,\n\t\t\t\t struct flow_cls_offload *f,\n\t\t\t\t struct vcap_admin *admin)\n{\n\tstruct vcap_control *vctrl;\n\tint err = -ENOENT, rule_id;\n\n\tvctrl = port->lan966x->vcap_ctrl;\n\twhile (true) {\n\t\trule_id = vcap_lookup_rule_by_cookie(vctrl, f->cookie);\n\t\tif (rule_id <= 0)\n\t\t\tbreak;\n\n\t\terr = vcap_del_rule(vctrl, port->dev, rule_id);\n\t\tif (err) {\n\t\t\tNL_SET_ERR_MSG_MOD(f->common.extack,\n\t\t\t\t\t   \"Cannot delete rule\");\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn err;\n}\n\nstatic int lan966x_tc_flower_stats(struct lan966x_port *port,\n\t\t\t\t   struct flow_cls_offload *f,\n\t\t\t\t   struct vcap_admin *admin)\n{\n\tstruct vcap_counter count = {};\n\tint err;\n\n\terr = vcap_get_rule_count_by_cookie(port->lan966x->vcap_ctrl,\n\t\t\t\t\t    &count, f->cookie);\n\tif (err)\n\t\treturn err;\n\n\tflow_stats_update(&f->stats, 0x0, count.value, 0, 0,\n\t\t\t  FLOW_ACTION_HW_STATS_IMMEDIATE);\n\n\treturn err;\n}\n\nint lan966x_tc_flower(struct lan966x_port *port,\n\t\t      struct flow_cls_offload *f,\n\t\t      bool ingress)\n{\n\tstruct vcap_admin *admin;\n\n\tadmin = vcap_find_admin(port->lan966x->vcap_ctrl,\n\t\t\t\tf->common.chain_index);\n\tif (!admin) {\n\t\tNL_SET_ERR_MSG_MOD(f->common.extack, \"Invalid chain\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (f->command) {\n\tcase FLOW_CLS_REPLACE:\n\t\treturn lan966x_tc_flower_add(port, f, admin, ingress);\n\tcase FLOW_CLS_DESTROY:\n\t\treturn lan966x_tc_flower_del(port, f, admin);\n\tcase FLOW_CLS_STATS:\n\t\treturn lan966x_tc_flower_stats(port, f, admin);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}