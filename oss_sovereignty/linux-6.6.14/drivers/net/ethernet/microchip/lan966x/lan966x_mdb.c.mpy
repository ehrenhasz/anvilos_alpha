{
  "module_name": "lan966x_mdb.c",
  "hash_id": "cde01050293ab2c08f1486f226a8f8dce2d0dc8bbefbaec20e0adac0955dda0e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/microchip/lan966x/lan966x_mdb.c",
  "human_readable_source": "\n\n#include <net/switchdev.h>\n\n#include \"lan966x_main.h\"\n\nstruct lan966x_pgid_entry {\n\tstruct list_head list;\n\tint index;\n\trefcount_t refcount;\n\tu16 ports;\n};\n\nstruct lan966x_mdb_entry {\n\tstruct list_head list;\n\tunsigned char mac[ETH_ALEN];\n\tu16 vid;\n\tu16 ports;\n\tstruct lan966x_pgid_entry *pgid;\n\tu8 cpu_copy;\n};\n\nvoid lan966x_mdb_init(struct lan966x *lan966x)\n{\n\tINIT_LIST_HEAD(&lan966x->mdb_entries);\n\tINIT_LIST_HEAD(&lan966x->pgid_entries);\n}\n\nstatic void lan966x_mdb_purge_mdb_entries(struct lan966x *lan966x)\n{\n\tstruct lan966x_mdb_entry *mdb_entry, *tmp;\n\n\tlist_for_each_entry_safe(mdb_entry, tmp, &lan966x->mdb_entries, list) {\n\t\tlist_del(&mdb_entry->list);\n\t\tkfree(mdb_entry);\n\t}\n}\n\nstatic void lan966x_mdb_purge_pgid_entries(struct lan966x *lan966x)\n{\n\tstruct lan966x_pgid_entry *pgid_entry, *tmp;\n\n\tlist_for_each_entry_safe(pgid_entry, tmp, &lan966x->pgid_entries, list) {\n\t\tlist_del(&pgid_entry->list);\n\t\tkfree(pgid_entry);\n\t}\n}\n\nvoid lan966x_mdb_deinit(struct lan966x *lan966x)\n{\n\tlan966x_mdb_purge_mdb_entries(lan966x);\n\tlan966x_mdb_purge_pgid_entries(lan966x);\n}\n\nstatic struct lan966x_mdb_entry *\nlan966x_mdb_entry_get(struct lan966x *lan966x,\n\t\t      const unsigned char *mac,\n\t\t      u16 vid)\n{\n\tstruct lan966x_mdb_entry *mdb_entry;\n\n\tlist_for_each_entry(mdb_entry, &lan966x->mdb_entries, list) {\n\t\tif (ether_addr_equal(mdb_entry->mac, mac) &&\n\t\t    mdb_entry->vid == vid)\n\t\t\treturn mdb_entry;\n\t}\n\n\treturn NULL;\n}\n\nstatic struct lan966x_mdb_entry *\nlan966x_mdb_entry_add(struct lan966x *lan966x,\n\t\t      const struct switchdev_obj_port_mdb *mdb)\n{\n\tstruct lan966x_mdb_entry *mdb_entry;\n\n\tmdb_entry = kzalloc(sizeof(*mdb_entry), GFP_KERNEL);\n\tif (!mdb_entry)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tether_addr_copy(mdb_entry->mac, mdb->addr);\n\tmdb_entry->vid = mdb->vid;\n\n\tlist_add_tail(&mdb_entry->list, &lan966x->mdb_entries);\n\n\treturn mdb_entry;\n}\n\nstatic void lan966x_mdb_encode_mac(unsigned char *mac,\n\t\t\t\t   struct lan966x_mdb_entry *mdb_entry,\n\t\t\t\t   enum macaccess_entry_type type)\n{\n\tether_addr_copy(mac, mdb_entry->mac);\n\n\tif (type == ENTRYTYPE_MACV4) {\n\t\tmac[0] = 0;\n\t\tmac[1] = mdb_entry->ports >> 8;\n\t\tmac[2] = mdb_entry->ports & 0xff;\n\t} else if (type == ENTRYTYPE_MACV6) {\n\t\tmac[0] = mdb_entry->ports >> 8;\n\t\tmac[1] = mdb_entry->ports & 0xff;\n\t}\n}\n\nstatic int lan966x_mdb_ip_add(struct lan966x_port *port,\n\t\t\t      const struct switchdev_obj_port_mdb *mdb,\n\t\t\t      enum macaccess_entry_type type)\n{\n\tbool cpu_port = netif_is_bridge_master(mdb->obj.orig_dev);\n\tstruct lan966x *lan966x = port->lan966x;\n\tstruct lan966x_mdb_entry *mdb_entry;\n\tunsigned char mac[ETH_ALEN];\n\tbool cpu_copy = false;\n\n\tmdb_entry = lan966x_mdb_entry_get(lan966x, mdb->addr, mdb->vid);\n\tif (!mdb_entry) {\n\t\tmdb_entry = lan966x_mdb_entry_add(lan966x, mdb);\n\t\tif (IS_ERR(mdb_entry))\n\t\t\treturn PTR_ERR(mdb_entry);\n\t} else {\n\t\tlan966x_mdb_encode_mac(mac, mdb_entry, type);\n\t\tlan966x_mac_forget(lan966x, mac, mdb_entry->vid, type);\n\t}\n\n\tif (cpu_port)\n\t\tmdb_entry->cpu_copy++;\n\telse\n\t\tmdb_entry->ports |= BIT(port->chip_port);\n\n\t \n\tif (lan966x_vlan_cpu_member_cpu_vlan_mask(lan966x, mdb_entry->vid) &&\n\t    mdb_entry->cpu_copy)\n\t\tcpu_copy = true;\n\n\tlan966x_mdb_encode_mac(mac, mdb_entry, type);\n\treturn lan966x_mac_ip_learn(lan966x, cpu_copy,\n\t\t\t\t    mac, mdb_entry->vid, type);\n}\n\nstatic int lan966x_mdb_ip_del(struct lan966x_port *port,\n\t\t\t      const struct switchdev_obj_port_mdb *mdb,\n\t\t\t      enum macaccess_entry_type type)\n{\n\tbool cpu_port = netif_is_bridge_master(mdb->obj.orig_dev);\n\tstruct lan966x *lan966x = port->lan966x;\n\tstruct lan966x_mdb_entry *mdb_entry;\n\tunsigned char mac[ETH_ALEN];\n\tu16 ports;\n\n\tmdb_entry = lan966x_mdb_entry_get(lan966x, mdb->addr, mdb->vid);\n\tif (!mdb_entry)\n\t\treturn -ENOENT;\n\n\tports = mdb_entry->ports;\n\tif (cpu_port) {\n\t\t \n\t\tmdb_entry->cpu_copy--;\n\t\tif (mdb_entry->cpu_copy)\n\t\t\treturn 0;\n\t} else {\n\t\tports &= ~BIT(port->chip_port);\n\t}\n\n\tlan966x_mdb_encode_mac(mac, mdb_entry, type);\n\tlan966x_mac_forget(lan966x, mac, mdb_entry->vid, type);\n\n\tmdb_entry->ports = ports;\n\n\tif (!mdb_entry->ports && !mdb_entry->cpu_copy) {\n\t\tlist_del(&mdb_entry->list);\n\t\tkfree(mdb_entry);\n\t\treturn 0;\n\t}\n\n\tlan966x_mdb_encode_mac(mac, mdb_entry, type);\n\treturn lan966x_mac_ip_learn(lan966x, mdb_entry->cpu_copy,\n\t\t\t\t    mac, mdb_entry->vid, type);\n}\n\nstatic struct lan966x_pgid_entry *\nlan966x_pgid_entry_add(struct lan966x *lan966x, int index, u16 ports)\n{\n\tstruct lan966x_pgid_entry *pgid_entry;\n\n\tpgid_entry = kzalloc(sizeof(*pgid_entry), GFP_KERNEL);\n\tif (!pgid_entry)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tpgid_entry->ports = ports;\n\tpgid_entry->index = index;\n\trefcount_set(&pgid_entry->refcount, 1);\n\n\tlist_add_tail(&pgid_entry->list, &lan966x->pgid_entries);\n\n\treturn pgid_entry;\n}\n\nstatic struct lan966x_pgid_entry *\nlan966x_pgid_entry_get(struct lan966x *lan966x,\n\t\t       struct lan966x_mdb_entry *mdb_entry)\n{\n\tstruct lan966x_pgid_entry *pgid_entry;\n\tint index;\n\n\t \n\tlist_for_each_entry(pgid_entry, &lan966x->pgid_entries, list) {\n\t\tif (pgid_entry->ports == mdb_entry->ports) {\n\t\t\trefcount_inc(&pgid_entry->refcount);\n\t\t\treturn pgid_entry;\n\t\t}\n\t}\n\n\t \n\tfor (index = PGID_GP_START; index < PGID_GP_END; index++) {\n\t\tbool used = false;\n\n\t\tlist_for_each_entry(pgid_entry, &lan966x->pgid_entries, list) {\n\t\t\tif (pgid_entry->index == index) {\n\t\t\t\tused = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!used)\n\t\t\treturn lan966x_pgid_entry_add(lan966x, index,\n\t\t\t\t\t\t      mdb_entry->ports);\n\t}\n\n\treturn ERR_PTR(-ENOSPC);\n}\n\nstatic void lan966x_pgid_entry_del(struct lan966x *lan966x,\n\t\t\t\t   struct lan966x_pgid_entry *pgid_entry)\n{\n\tif (!refcount_dec_and_test(&pgid_entry->refcount))\n\t\treturn;\n\n\tlist_del(&pgid_entry->list);\n\tkfree(pgid_entry);\n}\n\nstatic int lan966x_mdb_l2_add(struct lan966x_port *port,\n\t\t\t      const struct switchdev_obj_port_mdb *mdb,\n\t\t\t      enum macaccess_entry_type type)\n{\n\tbool cpu_port = netif_is_bridge_master(mdb->obj.orig_dev);\n\tstruct lan966x *lan966x = port->lan966x;\n\tstruct lan966x_pgid_entry *pgid_entry;\n\tstruct lan966x_mdb_entry *mdb_entry;\n\tunsigned char mac[ETH_ALEN];\n\n\tmdb_entry = lan966x_mdb_entry_get(lan966x, mdb->addr, mdb->vid);\n\tif (!mdb_entry) {\n\t\tmdb_entry = lan966x_mdb_entry_add(lan966x, mdb);\n\t\tif (IS_ERR(mdb_entry))\n\t\t\treturn PTR_ERR(mdb_entry);\n\t} else {\n\t\tlan966x_pgid_entry_del(lan966x, mdb_entry->pgid);\n\t\tlan966x_mdb_encode_mac(mac, mdb_entry, type);\n\t\tlan966x_mac_forget(lan966x, mac, mdb_entry->vid, type);\n\t}\n\n\tif (cpu_port) {\n\t\tmdb_entry->ports |= BIT(CPU_PORT);\n\t\tmdb_entry->cpu_copy++;\n\t} else {\n\t\tmdb_entry->ports |= BIT(port->chip_port);\n\t}\n\n\tpgid_entry = lan966x_pgid_entry_get(lan966x, mdb_entry);\n\tif (IS_ERR(pgid_entry)) {\n\t\tlist_del(&mdb_entry->list);\n\t\tkfree(mdb_entry);\n\t\treturn PTR_ERR(pgid_entry);\n\t}\n\tmdb_entry->pgid = pgid_entry;\n\n\t \n\tif (!lan966x_vlan_cpu_member_cpu_vlan_mask(lan966x, mdb_entry->vid) &&\n\t    mdb_entry->cpu_copy)\n\t\tmdb_entry->ports &= BIT(CPU_PORT);\n\n\tlan_rmw(ANA_PGID_PGID_SET(mdb_entry->ports),\n\t\tANA_PGID_PGID,\n\t\tlan966x, ANA_PGID(pgid_entry->index));\n\n\treturn lan966x_mac_learn(lan966x, pgid_entry->index, mdb_entry->mac,\n\t\t\t\t mdb_entry->vid, type);\n}\n\nstatic int lan966x_mdb_l2_del(struct lan966x_port *port,\n\t\t\t      const struct switchdev_obj_port_mdb *mdb,\n\t\t\t      enum macaccess_entry_type type)\n{\n\tbool cpu_port = netif_is_bridge_master(mdb->obj.orig_dev);\n\tstruct lan966x *lan966x = port->lan966x;\n\tstruct lan966x_pgid_entry *pgid_entry;\n\tstruct lan966x_mdb_entry *mdb_entry;\n\tunsigned char mac[ETH_ALEN];\n\tu16 ports;\n\n\tmdb_entry = lan966x_mdb_entry_get(lan966x, mdb->addr, mdb->vid);\n\tif (!mdb_entry)\n\t\treturn -ENOENT;\n\n\tports = mdb_entry->ports;\n\tif (cpu_port) {\n\t\t \n\t\tmdb_entry->cpu_copy--;\n\t\tif (mdb_entry->cpu_copy)\n\t\t\treturn 0;\n\n\t\tports &= ~BIT(CPU_PORT);\n\t} else {\n\t\tports &= ~BIT(port->chip_port);\n\t}\n\n\tlan966x_mdb_encode_mac(mac, mdb_entry, type);\n\tlan966x_mac_forget(lan966x, mac, mdb_entry->vid, type);\n\tlan966x_pgid_entry_del(lan966x, mdb_entry->pgid);\n\n\tmdb_entry->ports = ports;\n\n\tif (!mdb_entry->ports) {\n\t\tlist_del(&mdb_entry->list);\n\t\tkfree(mdb_entry);\n\t\treturn 0;\n\t}\n\n\tpgid_entry = lan966x_pgid_entry_get(lan966x, mdb_entry);\n\tif (IS_ERR(pgid_entry)) {\n\t\tlist_del(&mdb_entry->list);\n\t\tkfree(mdb_entry);\n\t\treturn PTR_ERR(pgid_entry);\n\t}\n\tmdb_entry->pgid = pgid_entry;\n\n\tlan_rmw(ANA_PGID_PGID_SET(mdb_entry->ports),\n\t\tANA_PGID_PGID,\n\t\tlan966x, ANA_PGID(pgid_entry->index));\n\n\treturn lan966x_mac_learn(lan966x, pgid_entry->index, mdb_entry->mac,\n\t\t\t\t mdb_entry->vid, type);\n}\n\nstatic enum macaccess_entry_type\nlan966x_mdb_classify(const unsigned char *mac)\n{\n\tif (mac[0] == 0x01 && mac[1] == 0x00 && mac[2] == 0x5e)\n\t\treturn ENTRYTYPE_MACV4;\n\tif (mac[0] == 0x33 && mac[1] == 0x33)\n\t\treturn ENTRYTYPE_MACV6;\n\treturn ENTRYTYPE_LOCKED;\n}\n\nint lan966x_handle_port_mdb_add(struct lan966x_port *port,\n\t\t\t\tconst struct switchdev_obj *obj)\n{\n\tconst struct switchdev_obj_port_mdb *mdb = SWITCHDEV_OBJ_PORT_MDB(obj);\n\tenum macaccess_entry_type type;\n\n\t \n\ttype = lan966x_mdb_classify(mdb->addr);\n\tif (type == ENTRYTYPE_MACV4 || type == ENTRYTYPE_MACV6)\n\t\treturn lan966x_mdb_ip_add(port, mdb, type);\n\n\treturn lan966x_mdb_l2_add(port, mdb, type);\n}\n\nint lan966x_handle_port_mdb_del(struct lan966x_port *port,\n\t\t\t\tconst struct switchdev_obj *obj)\n{\n\tconst struct switchdev_obj_port_mdb *mdb = SWITCHDEV_OBJ_PORT_MDB(obj);\n\tenum macaccess_entry_type type;\n\n\t \n\ttype = lan966x_mdb_classify(mdb->addr);\n\tif (type == ENTRYTYPE_MACV4 || type == ENTRYTYPE_MACV6)\n\t\treturn lan966x_mdb_ip_del(port, mdb, type);\n\n\treturn lan966x_mdb_l2_del(port, mdb, type);\n}\n\nstatic void lan966x_mdb_ip_cpu_copy(struct lan966x *lan966x,\n\t\t\t\t    struct lan966x_mdb_entry *mdb_entry,\n\t\t\t\t    enum macaccess_entry_type type)\n{\n\tunsigned char mac[ETH_ALEN];\n\n\tlan966x_mdb_encode_mac(mac, mdb_entry, type);\n\tlan966x_mac_forget(lan966x, mac, mdb_entry->vid, type);\n\tlan966x_mac_ip_learn(lan966x, true, mac, mdb_entry->vid, type);\n}\n\nstatic void lan966x_mdb_l2_cpu_copy(struct lan966x *lan966x,\n\t\t\t\t    struct lan966x_mdb_entry *mdb_entry,\n\t\t\t\t    enum macaccess_entry_type type)\n{\n\tstruct lan966x_pgid_entry *pgid_entry;\n\tunsigned char mac[ETH_ALEN];\n\n\tlan966x_pgid_entry_del(lan966x, mdb_entry->pgid);\n\tlan966x_mdb_encode_mac(mac, mdb_entry, type);\n\tlan966x_mac_forget(lan966x, mac, mdb_entry->vid, type);\n\n\tmdb_entry->ports |= BIT(CPU_PORT);\n\n\tpgid_entry = lan966x_pgid_entry_get(lan966x, mdb_entry);\n\tif (IS_ERR(pgid_entry))\n\t\treturn;\n\n\tmdb_entry->pgid = pgid_entry;\n\n\tlan_rmw(ANA_PGID_PGID_SET(mdb_entry->ports),\n\t\tANA_PGID_PGID,\n\t\tlan966x, ANA_PGID(pgid_entry->index));\n\n\tlan966x_mac_learn(lan966x, pgid_entry->index, mdb_entry->mac,\n\t\t\t  mdb_entry->vid, type);\n}\n\nvoid lan966x_mdb_write_entries(struct lan966x *lan966x, u16 vid)\n{\n\tstruct lan966x_mdb_entry *mdb_entry;\n\tenum macaccess_entry_type type;\n\n\tlist_for_each_entry(mdb_entry, &lan966x->mdb_entries, list) {\n\t\tif (mdb_entry->vid != vid || !mdb_entry->cpu_copy)\n\t\t\tcontinue;\n\n\t\ttype = lan966x_mdb_classify(mdb_entry->mac);\n\t\tif (type == ENTRYTYPE_MACV4 || type == ENTRYTYPE_MACV6)\n\t\t\tlan966x_mdb_ip_cpu_copy(lan966x, mdb_entry, type);\n\t\telse\n\t\t\tlan966x_mdb_l2_cpu_copy(lan966x, mdb_entry, type);\n\t}\n}\n\nstatic void lan966x_mdb_ip_cpu_remove(struct lan966x *lan966x,\n\t\t\t\t      struct lan966x_mdb_entry *mdb_entry,\n\t\t\t\t      enum macaccess_entry_type type)\n{\n\tunsigned char mac[ETH_ALEN];\n\n\tlan966x_mdb_encode_mac(mac, mdb_entry, type);\n\tlan966x_mac_forget(lan966x, mac, mdb_entry->vid, type);\n\tlan966x_mac_ip_learn(lan966x, false, mac, mdb_entry->vid, type);\n}\n\nstatic void lan966x_mdb_l2_cpu_remove(struct lan966x *lan966x,\n\t\t\t\t      struct lan966x_mdb_entry *mdb_entry,\n\t\t\t\t      enum macaccess_entry_type type)\n{\n\tstruct lan966x_pgid_entry *pgid_entry;\n\tunsigned char mac[ETH_ALEN];\n\n\tlan966x_pgid_entry_del(lan966x, mdb_entry->pgid);\n\tlan966x_mdb_encode_mac(mac, mdb_entry, type);\n\tlan966x_mac_forget(lan966x, mac, mdb_entry->vid, type);\n\n\tmdb_entry->ports &= ~BIT(CPU_PORT);\n\n\tpgid_entry = lan966x_pgid_entry_get(lan966x, mdb_entry);\n\tif (IS_ERR(pgid_entry))\n\t\treturn;\n\n\tmdb_entry->pgid = pgid_entry;\n\n\tlan_rmw(ANA_PGID_PGID_SET(mdb_entry->ports),\n\t\tANA_PGID_PGID,\n\t\tlan966x, ANA_PGID(pgid_entry->index));\n\n\tlan966x_mac_learn(lan966x, pgid_entry->index, mdb_entry->mac,\n\t\t\t  mdb_entry->vid, type);\n}\n\nvoid lan966x_mdb_erase_entries(struct lan966x *lan966x, u16 vid)\n{\n\tstruct lan966x_mdb_entry *mdb_entry;\n\tenum macaccess_entry_type type;\n\n\tlist_for_each_entry(mdb_entry, &lan966x->mdb_entries, list) {\n\t\tif (mdb_entry->vid != vid || !mdb_entry->cpu_copy)\n\t\t\tcontinue;\n\n\t\ttype = lan966x_mdb_classify(mdb_entry->mac);\n\t\tif (type == ENTRYTYPE_MACV4 || type == ENTRYTYPE_MACV6)\n\t\t\tlan966x_mdb_ip_cpu_remove(lan966x, mdb_entry, type);\n\t\telse\n\t\t\tlan966x_mdb_l2_cpu_remove(lan966x, mdb_entry, type);\n\t}\n}\n\nvoid lan966x_mdb_clear_entries(struct lan966x *lan966x)\n{\n\tstruct lan966x_mdb_entry *mdb_entry;\n\tenum macaccess_entry_type type;\n\tunsigned char mac[ETH_ALEN];\n\n\tlist_for_each_entry(mdb_entry, &lan966x->mdb_entries, list) {\n\t\ttype = lan966x_mdb_classify(mdb_entry->mac);\n\n\t\tlan966x_mdb_encode_mac(mac, mdb_entry, type);\n\t\t \n\t\tlan966x_mac_forget(lan966x, mac, mdb_entry->vid, type);\n\t}\n}\n\nvoid lan966x_mdb_restore_entries(struct lan966x *lan966x)\n{\n\tstruct lan966x_mdb_entry *mdb_entry;\n\tenum macaccess_entry_type type;\n\tunsigned char mac[ETH_ALEN];\n\tbool cpu_copy = false;\n\n\tlist_for_each_entry(mdb_entry, &lan966x->mdb_entries, list) {\n\t\ttype = lan966x_mdb_classify(mdb_entry->mac);\n\n\t\tlan966x_mdb_encode_mac(mac, mdb_entry, type);\n\t\tif (type == ENTRYTYPE_MACV4 || type == ENTRYTYPE_MACV6) {\n\t\t\t \n\t\t\tif (lan966x_vlan_cpu_member_cpu_vlan_mask(lan966x,\n\t\t\t\t\t\t\t\t  mdb_entry->vid) &&\n\t\t\t    mdb_entry->cpu_copy)\n\t\t\t\tcpu_copy = true;\n\n\t\t\tlan966x_mac_ip_learn(lan966x, cpu_copy, mac,\n\t\t\t\t\t     mdb_entry->vid, type);\n\t\t} else {\n\t\t\tlan966x_mac_learn(lan966x, mdb_entry->pgid->index,\n\t\t\t\t\t  mdb_entry->mac,\n\t\t\t\t\t  mdb_entry->vid, type);\n\t\t}\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}