{
  "module_name": "lan966x_mac.c",
  "hash_id": "868e4c07855a54b8af0f26d4f39d2f65a41c4e2f9f7ba3da1e3800576545200f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/microchip/lan966x/lan966x_mac.c",
  "human_readable_source": "\n\n#include <net/switchdev.h>\n#include \"lan966x_main.h\"\n\n#define LAN966X_MAC_COLUMNS\t\t4\n#define MACACCESS_CMD_IDLE\t\t0\n#define MACACCESS_CMD_LEARN\t\t1\n#define MACACCESS_CMD_FORGET\t\t2\n#define MACACCESS_CMD_AGE\t\t3\n#define MACACCESS_CMD_GET_NEXT\t\t4\n#define MACACCESS_CMD_INIT\t\t5\n#define MACACCESS_CMD_READ\t\t6\n#define MACACCESS_CMD_WRITE\t\t7\n#define MACACCESS_CMD_SYNC_GET_NEXT\t8\n\n#define LAN966X_MAC_INVALID_ROW\t\t-1\n\nstruct lan966x_mac_entry {\n\tstruct list_head list;\n\tunsigned char mac[ETH_ALEN] __aligned(2);\n\tu16 vid;\n\tu16 port_index;\n\tint row;\n\tbool lag;\n};\n\nstruct lan966x_mac_raw_entry {\n\tu32 mach;\n\tu32 macl;\n\tu32 maca;\n\tbool processed;\n};\n\nstatic int lan966x_mac_get_status(struct lan966x *lan966x)\n{\n\treturn lan_rd(lan966x, ANA_MACACCESS);\n}\n\nstatic int lan966x_mac_wait_for_completion(struct lan966x *lan966x)\n{\n\tu32 val;\n\n\treturn readx_poll_timeout_atomic(lan966x_mac_get_status,\n\t\t\t\t\t lan966x, val,\n\t\t\t\t\t (ANA_MACACCESS_MAC_TABLE_CMD_GET(val)) ==\n\t\t\t\t\t MACACCESS_CMD_IDLE,\n\t\t\t\t\t TABLE_UPDATE_SLEEP_US,\n\t\t\t\t\t TABLE_UPDATE_TIMEOUT_US);\n}\n\nstatic void lan966x_mac_select(struct lan966x *lan966x,\n\t\t\t       const unsigned char mac[ETH_ALEN],\n\t\t\t       unsigned int vid)\n{\n\tu32 macl = 0, mach = 0;\n\n\t \n\tmach |= vid    << 16;\n\tmach |= mac[0] << 8;\n\tmach |= mac[1] << 0;\n\tmacl |= mac[2] << 24;\n\tmacl |= mac[3] << 16;\n\tmacl |= mac[4] << 8;\n\tmacl |= mac[5] << 0;\n\n\tlan_wr(macl, lan966x, ANA_MACLDATA);\n\tlan_wr(mach, lan966x, ANA_MACHDATA);\n}\n\nstatic int __lan966x_mac_learn_locked(struct lan966x *lan966x, int pgid,\n\t\t\t\t      bool cpu_copy,\n\t\t\t\t      const unsigned char mac[ETH_ALEN],\n\t\t\t\t      unsigned int vid,\n\t\t\t\t      enum macaccess_entry_type type)\n{\n\tlockdep_assert_held(&lan966x->mac_lock);\n\n\tlan966x_mac_select(lan966x, mac, vid);\n\n\t \n\tlan_wr(ANA_MACACCESS_VALID_SET(1) |\n\t       ANA_MACACCESS_CHANGE2SW_SET(0) |\n\t       ANA_MACACCESS_MAC_CPU_COPY_SET(cpu_copy) |\n\t       ANA_MACACCESS_DEST_IDX_SET(pgid) |\n\t       ANA_MACACCESS_ENTRYTYPE_SET(type) |\n\t       ANA_MACACCESS_MAC_TABLE_CMD_SET(MACACCESS_CMD_LEARN),\n\t       lan966x, ANA_MACACCESS);\n\n\treturn lan966x_mac_wait_for_completion(lan966x);\n}\n\nstatic int __lan966x_mac_learn(struct lan966x *lan966x, int pgid,\n\t\t\t       bool cpu_copy,\n\t\t\t       const unsigned char mac[ETH_ALEN],\n\t\t\t       unsigned int vid,\n\t\t\t       enum macaccess_entry_type type)\n{\n\tint ret;\n\n\tspin_lock(&lan966x->mac_lock);\n\tret = __lan966x_mac_learn_locked(lan966x, pgid, cpu_copy, mac, vid, type);\n\tspin_unlock(&lan966x->mac_lock);\n\n\treturn ret;\n}\n\n \nint lan966x_mac_ip_learn(struct lan966x *lan966x,\n\t\t\t bool cpu_copy,\n\t\t\t const unsigned char mac[ETH_ALEN],\n\t\t\t unsigned int vid,\n\t\t\t enum macaccess_entry_type type)\n{\n\tWARN_ON(type != ENTRYTYPE_MACV4 && type != ENTRYTYPE_MACV6);\n\n\treturn __lan966x_mac_learn(lan966x, 0, cpu_copy, mac, vid, type);\n}\n\nint lan966x_mac_learn(struct lan966x *lan966x, int port,\n\t\t      const unsigned char mac[ETH_ALEN],\n\t\t      unsigned int vid,\n\t\t      enum macaccess_entry_type type)\n{\n\tWARN_ON(type != ENTRYTYPE_NORMAL && type != ENTRYTYPE_LOCKED);\n\n\treturn __lan966x_mac_learn(lan966x, port, false, mac, vid, type);\n}\n\nstatic int lan966x_mac_learn_locked(struct lan966x *lan966x, int port,\n\t\t\t\t    const unsigned char mac[ETH_ALEN],\n\t\t\t\t    unsigned int vid,\n\t\t\t\t    enum macaccess_entry_type type)\n{\n\tWARN_ON(type != ENTRYTYPE_NORMAL && type != ENTRYTYPE_LOCKED);\n\n\treturn __lan966x_mac_learn_locked(lan966x, port, false, mac, vid, type);\n}\n\nstatic int lan966x_mac_forget_locked(struct lan966x *lan966x,\n\t\t\t\t     const unsigned char mac[ETH_ALEN],\n\t\t\t\t     unsigned int vid,\n\t\t\t\t     enum macaccess_entry_type type)\n{\n\tlockdep_assert_held(&lan966x->mac_lock);\n\n\tlan966x_mac_select(lan966x, mac, vid);\n\n\t \n\tlan_wr(ANA_MACACCESS_ENTRYTYPE_SET(type) |\n\t       ANA_MACACCESS_MAC_TABLE_CMD_SET(MACACCESS_CMD_FORGET),\n\t       lan966x, ANA_MACACCESS);\n\n\treturn lan966x_mac_wait_for_completion(lan966x);\n}\n\nint lan966x_mac_forget(struct lan966x *lan966x,\n\t\t       const unsigned char mac[ETH_ALEN],\n\t\t       unsigned int vid,\n\t\t       enum macaccess_entry_type type)\n{\n\tint ret;\n\n\tspin_lock(&lan966x->mac_lock);\n\tret = lan966x_mac_forget_locked(lan966x, mac, vid, type);\n\tspin_unlock(&lan966x->mac_lock);\n\n\treturn ret;\n}\n\nint lan966x_mac_cpu_learn(struct lan966x *lan966x, const char *addr, u16 vid)\n{\n\treturn lan966x_mac_learn(lan966x, PGID_CPU, addr, vid, ENTRYTYPE_LOCKED);\n}\n\nint lan966x_mac_cpu_forget(struct lan966x *lan966x, const char *addr, u16 vid)\n{\n\treturn lan966x_mac_forget(lan966x, addr, vid, ENTRYTYPE_LOCKED);\n}\n\nvoid lan966x_mac_set_ageing(struct lan966x *lan966x,\n\t\t\t    u32 ageing)\n{\n\tlan_rmw(ANA_AUTOAGE_AGE_PERIOD_SET(ageing / 2),\n\t\tANA_AUTOAGE_AGE_PERIOD,\n\t\tlan966x, ANA_AUTOAGE);\n}\n\nvoid lan966x_mac_init(struct lan966x *lan966x)\n{\n\t \n\tlan_wr(MACACCESS_CMD_INIT, lan966x, ANA_MACACCESS);\n\tlan966x_mac_wait_for_completion(lan966x);\n\n\tspin_lock_init(&lan966x->mac_lock);\n\tINIT_LIST_HEAD(&lan966x->mac_entries);\n}\n\nstatic struct lan966x_mac_entry *lan966x_mac_alloc_entry(struct lan966x_port *port,\n\t\t\t\t\t\t\t const unsigned char *mac,\n\t\t\t\t\t\t\t u16 vid)\n{\n\tstruct lan966x_mac_entry *mac_entry;\n\n\tmac_entry = kzalloc(sizeof(*mac_entry), GFP_ATOMIC);\n\tif (!mac_entry)\n\t\treturn NULL;\n\n\tmemcpy(mac_entry->mac, mac, ETH_ALEN);\n\tmac_entry->vid = vid;\n\tmac_entry->port_index = port->chip_port;\n\tmac_entry->row = LAN966X_MAC_INVALID_ROW;\n\tmac_entry->lag = port->bond ? true : false;\n\treturn mac_entry;\n}\n\nstatic struct lan966x_mac_entry *lan966x_mac_find_entry(struct lan966x *lan966x,\n\t\t\t\t\t\t\tconst unsigned char *mac,\n\t\t\t\t\t\t\tu16 vid, u16 port_index)\n{\n\tstruct lan966x_mac_entry *res = NULL;\n\tstruct lan966x_mac_entry *mac_entry;\n\n\tlist_for_each_entry(mac_entry, &lan966x->mac_entries, list) {\n\t\tif (mac_entry->vid == vid &&\n\t\t    ether_addr_equal(mac, mac_entry->mac) &&\n\t\t    mac_entry->port_index == port_index) {\n\t\t\tres = mac_entry;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn res;\n}\n\nstatic int lan966x_mac_lookup(struct lan966x *lan966x,\n\t\t\t      const unsigned char mac[ETH_ALEN],\n\t\t\t      unsigned int vid, enum macaccess_entry_type type)\n{\n\tint ret;\n\n\tlan966x_mac_select(lan966x, mac, vid);\n\n\t \n\tlan_wr(ANA_MACACCESS_ENTRYTYPE_SET(type) |\n\t       ANA_MACACCESS_VALID_SET(1) |\n\t       ANA_MACACCESS_MAC_TABLE_CMD_SET(MACACCESS_CMD_READ),\n\t       lan966x, ANA_MACACCESS);\n\n\tret = lan966x_mac_wait_for_completion(lan966x);\n\tif (ret)\n\t\treturn ret;\n\n\treturn ANA_MACACCESS_VALID_GET(lan_rd(lan966x, ANA_MACACCESS));\n}\n\nstatic void lan966x_fdb_call_notifiers(enum switchdev_notifier_type type,\n\t\t\t\t       const char *mac, u16 vid,\n\t\t\t\t       struct net_device *dev)\n{\n\tstruct switchdev_notifier_fdb_info info = { 0 };\n\n\tinfo.addr = mac;\n\tinfo.vid = vid;\n\tinfo.offloaded = true;\n\tcall_switchdev_notifiers(type, dev, &info.info, NULL);\n}\n\nint lan966x_mac_add_entry(struct lan966x *lan966x, struct lan966x_port *port,\n\t\t\t  const unsigned char *addr, u16 vid)\n{\n\tstruct lan966x_mac_entry *mac_entry;\n\n\tspin_lock(&lan966x->mac_lock);\n\tif (lan966x_mac_lookup(lan966x, addr, vid, ENTRYTYPE_NORMAL)) {\n\t\tspin_unlock(&lan966x->mac_lock);\n\t\treturn 0;\n\t}\n\n\t \n\tmac_entry = lan966x_mac_find_entry(lan966x, addr, vid, port->chip_port);\n\tif (mac_entry) {\n\t\tspin_unlock(&lan966x->mac_lock);\n\t\tgoto mac_learn;\n\t}\n\n\tmac_entry = lan966x_mac_alloc_entry(port, addr, vid);\n\tif (!mac_entry) {\n\t\tspin_unlock(&lan966x->mac_lock);\n\t\treturn -ENOMEM;\n\t}\n\n\tlist_add_tail(&mac_entry->list, &lan966x->mac_entries);\n\tspin_unlock(&lan966x->mac_lock);\n\n\tlan966x_fdb_call_notifiers(SWITCHDEV_FDB_OFFLOADED, addr, vid,\n\t\t\t\t   port->bond ?: port->dev);\n\nmac_learn:\n\tlan966x_mac_learn(lan966x, port->chip_port, addr, vid, ENTRYTYPE_LOCKED);\n\n\treturn 0;\n}\n\nint lan966x_mac_del_entry(struct lan966x *lan966x, const unsigned char *addr,\n\t\t\t  u16 vid)\n{\n\tstruct lan966x_mac_entry *mac_entry, *tmp;\n\n\tspin_lock(&lan966x->mac_lock);\n\tlist_for_each_entry_safe(mac_entry, tmp, &lan966x->mac_entries,\n\t\t\t\t list) {\n\t\tif (mac_entry->vid == vid &&\n\t\t    ether_addr_equal(addr, mac_entry->mac)) {\n\t\t\tlan966x_mac_forget_locked(lan966x, mac_entry->mac,\n\t\t\t\t\t\t  mac_entry->vid,\n\t\t\t\t\t\t  ENTRYTYPE_LOCKED);\n\n\t\t\tlist_del(&mac_entry->list);\n\t\t\tkfree(mac_entry);\n\t\t}\n\t}\n\tspin_unlock(&lan966x->mac_lock);\n\n\treturn 0;\n}\n\nvoid lan966x_mac_lag_replace_port_entry(struct lan966x *lan966x,\n\t\t\t\t\tstruct lan966x_port *src,\n\t\t\t\t\tstruct lan966x_port *dst)\n{\n\tstruct lan966x_mac_entry *mac_entry;\n\n\tspin_lock(&lan966x->mac_lock);\n\tlist_for_each_entry(mac_entry, &lan966x->mac_entries, list) {\n\t\tif (mac_entry->port_index == src->chip_port &&\n\t\t    mac_entry->lag) {\n\t\t\tlan966x_mac_forget_locked(lan966x, mac_entry->mac,\n\t\t\t\t\t\t  mac_entry->vid,\n\t\t\t\t\t\t  ENTRYTYPE_LOCKED);\n\n\t\t\tlan966x_mac_learn_locked(lan966x, dst->chip_port,\n\t\t\t\t\t\t mac_entry->mac, mac_entry->vid,\n\t\t\t\t\t\t ENTRYTYPE_LOCKED);\n\t\t\tmac_entry->port_index = dst->chip_port;\n\t\t}\n\t}\n\tspin_unlock(&lan966x->mac_lock);\n}\n\nvoid lan966x_mac_lag_remove_port_entry(struct lan966x *lan966x,\n\t\t\t\t       struct lan966x_port *src)\n{\n\tstruct lan966x_mac_entry *mac_entry, *tmp;\n\n\tspin_lock(&lan966x->mac_lock);\n\tlist_for_each_entry_safe(mac_entry, tmp, &lan966x->mac_entries,\n\t\t\t\t list) {\n\t\tif (mac_entry->port_index == src->chip_port &&\n\t\t    mac_entry->lag) {\n\t\t\tlan966x_mac_forget_locked(lan966x, mac_entry->mac,\n\t\t\t\t\t\t  mac_entry->vid,\n\t\t\t\t\t\t  ENTRYTYPE_LOCKED);\n\n\t\t\tlist_del(&mac_entry->list);\n\t\t\tkfree(mac_entry);\n\t\t}\n\t}\n\tspin_unlock(&lan966x->mac_lock);\n}\n\nvoid lan966x_mac_purge_entries(struct lan966x *lan966x)\n{\n\tstruct lan966x_mac_entry *mac_entry, *tmp;\n\n\tspin_lock(&lan966x->mac_lock);\n\tlist_for_each_entry_safe(mac_entry, tmp, &lan966x->mac_entries,\n\t\t\t\t list) {\n\t\tlan966x_mac_forget_locked(lan966x, mac_entry->mac,\n\t\t\t\t\t  mac_entry->vid, ENTRYTYPE_LOCKED);\n\n\t\tlist_del(&mac_entry->list);\n\t\tkfree(mac_entry);\n\t}\n\tspin_unlock(&lan966x->mac_lock);\n}\n\nstatic void lan966x_mac_notifiers(enum switchdev_notifier_type type,\n\t\t\t\t  unsigned char *mac, u32 vid,\n\t\t\t\t  struct net_device *dev)\n{\n\trtnl_lock();\n\tlan966x_fdb_call_notifiers(type, mac, vid, dev);\n\trtnl_unlock();\n}\n\nstatic void lan966x_mac_process_raw_entry(struct lan966x_mac_raw_entry *raw_entry,\n\t\t\t\t\t  u8 *mac, u16 *vid, u32 *dest_idx)\n{\n\tmac[0] = (raw_entry->mach >> 8)  & 0xff;\n\tmac[1] = (raw_entry->mach >> 0)  & 0xff;\n\tmac[2] = (raw_entry->macl >> 24) & 0xff;\n\tmac[3] = (raw_entry->macl >> 16) & 0xff;\n\tmac[4] = (raw_entry->macl >> 8)  & 0xff;\n\tmac[5] = (raw_entry->macl >> 0)  & 0xff;\n\n\t*vid = (raw_entry->mach >> 16) & 0xfff;\n\t*dest_idx = ANA_MACACCESS_DEST_IDX_GET(raw_entry->maca);\n}\n\nstatic void lan966x_mac_irq_process(struct lan966x *lan966x, u32 row,\n\t\t\t\t    struct lan966x_mac_raw_entry *raw_entries)\n{\n\tstruct lan966x_mac_entry *mac_entry, *tmp;\n\tunsigned char mac[ETH_ALEN] __aligned(2);\n\tstruct list_head mac_deleted_entries;\n\tstruct lan966x_port *port;\n\tu32 dest_idx;\n\tu32 column;\n\tu16 vid;\n\n\tINIT_LIST_HEAD(&mac_deleted_entries);\n\n\tspin_lock(&lan966x->mac_lock);\n\tlist_for_each_entry_safe(mac_entry, tmp, &lan966x->mac_entries, list) {\n\t\tbool found = false;\n\n\t\tif (mac_entry->row != row)\n\t\t\tcontinue;\n\n\t\tfor (column = 0; column < LAN966X_MAC_COLUMNS; ++column) {\n\t\t\t \n\t\t\tif (!ANA_MACACCESS_VALID_GET(raw_entries[column].maca))\n\t\t\t\tbreak;\n\n\t\t\tlan966x_mac_process_raw_entry(&raw_entries[column],\n\t\t\t\t\t\t      mac, &vid, &dest_idx);\n\t\t\tif (WARN_ON(dest_idx >= lan966x->num_phys_ports))\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tif (mac_entry->vid == vid &&\n\t\t\t    ether_addr_equal(mac_entry->mac, mac) &&\n\t\t\t    mac_entry->port_index == dest_idx) {\n\t\t\t\traw_entries[column].processed = true;\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!found) {\n\t\t\tlist_del(&mac_entry->list);\n\t\t\t \n\t\t\tlist_add_tail(&mac_entry->list, &mac_deleted_entries);\n\t\t}\n\t}\n\tspin_unlock(&lan966x->mac_lock);\n\n\tlist_for_each_entry_safe(mac_entry, tmp, &mac_deleted_entries, list) {\n\t\t \n\t\tport = lan966x->ports[mac_entry->port_index];\n\t\tlan966x_mac_notifiers(SWITCHDEV_FDB_DEL_TO_BRIDGE,\n\t\t\t\t      mac_entry->mac, mac_entry->vid,\n\t\t\t\t      port->bond ?: port->dev);\n\t\tlist_del(&mac_entry->list);\n\t\tkfree(mac_entry);\n\t}\n\n\t \n\tfor (column = 0; column < LAN966X_MAC_COLUMNS; ++column) {\n\t\t \n\t\tif (!ANA_MACACCESS_VALID_GET(raw_entries[column].maca))\n\t\t\tbreak;\n\n\t\t \n\t\tif (raw_entries[column].processed)\n\t\t\tcontinue;\n\n\t\tlan966x_mac_process_raw_entry(&raw_entries[column],\n\t\t\t\t\t      mac, &vid, &dest_idx);\n\t\tif (WARN_ON(dest_idx >= lan966x->num_phys_ports))\n\t\t\tcontinue;\n\n\t\tspin_lock(&lan966x->mac_lock);\n\t\tmac_entry = lan966x_mac_find_entry(lan966x, mac, vid, dest_idx);\n\t\tif (mac_entry) {\n\t\t\tspin_unlock(&lan966x->mac_lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\tport = lan966x->ports[dest_idx];\n\t\tmac_entry = lan966x_mac_alloc_entry(port, mac, vid);\n\t\tif (!mac_entry) {\n\t\t\tspin_unlock(&lan966x->mac_lock);\n\t\t\treturn;\n\t\t}\n\n\t\tmac_entry->row = row;\n\t\tlist_add_tail(&mac_entry->list, &lan966x->mac_entries);\n\t\tspin_unlock(&lan966x->mac_lock);\n\n\t\tlan966x_mac_notifiers(SWITCHDEV_FDB_ADD_TO_BRIDGE,\n\t\t\t\t      mac, vid, port->bond ?: port->dev);\n\t}\n}\n\nirqreturn_t lan966x_mac_irq_handler(struct lan966x *lan966x)\n{\n\tstruct lan966x_mac_raw_entry entry[LAN966X_MAC_COLUMNS] = { 0 };\n\tu32 index, column;\n\tbool stop = true;\n\tu32 val;\n\n\t \n\tlan_wr(ANA_MACTINDX_M_INDEX_SET(0) |\n\t       ANA_MACTINDX_BUCKET_SET(0),\n\t       lan966x, ANA_MACTINDX);\n\n\twhile (1) {\n\t\tspin_lock(&lan966x->mac_lock);\n\t\tlan_rmw(ANA_MACACCESS_MAC_TABLE_CMD_SET(MACACCESS_CMD_SYNC_GET_NEXT),\n\t\t\tANA_MACACCESS_MAC_TABLE_CMD,\n\t\t\tlan966x, ANA_MACACCESS);\n\t\tlan966x_mac_wait_for_completion(lan966x);\n\n\t\tval = lan_rd(lan966x, ANA_MACTINDX);\n\t\tindex = ANA_MACTINDX_M_INDEX_GET(val);\n\t\tcolumn = ANA_MACTINDX_BUCKET_GET(val);\n\n\t\t \n\t\tif (index == 0 && column == 0)\n\t\t\tstop = false;\n\n\t\tif (column == LAN966X_MAC_COLUMNS - 1 &&\n\t\t    index == 0 && stop) {\n\t\t\tspin_unlock(&lan966x->mac_lock);\n\t\t\tbreak;\n\t\t}\n\n\t\tentry[column].mach = lan_rd(lan966x, ANA_MACHDATA);\n\t\tentry[column].macl = lan_rd(lan966x, ANA_MACLDATA);\n\t\tentry[column].maca = lan_rd(lan966x, ANA_MACACCESS);\n\t\tspin_unlock(&lan966x->mac_lock);\n\n\t\t \n\t\tif (column == LAN966X_MAC_COLUMNS - 1) {\n\t\t\tlan966x_mac_irq_process(lan966x, index, entry);\n\t\t\t \n\t\t\tstop = true;\n\t\t}\n\t}\n\n\tlan_rmw(ANA_ANAINTR_INTR_SET(0),\n\t\tANA_ANAINTR_INTR,\n\t\tlan966x, ANA_ANAINTR);\n\n\treturn IRQ_HANDLED;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}