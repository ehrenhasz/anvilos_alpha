{
  "module_name": "lan966x_xdp.c",
  "hash_id": "9b0b307e8bcf562662ba17dec06ea97b1a45c40c5519bfa38d433d801d82965f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/microchip/lan966x/lan966x_xdp.c",
  "human_readable_source": "\n\n#include <linux/bpf.h>\n#include <linux/bpf_trace.h>\n#include <linux/filter.h>\n\n#include \"lan966x_main.h\"\n\nstatic int lan966x_xdp_setup(struct net_device *dev, struct netdev_bpf *xdp)\n{\n\tstruct lan966x_port *port = netdev_priv(dev);\n\tstruct lan966x *lan966x = port->lan966x;\n\tstruct bpf_prog *old_prog;\n\tbool old_xdp, new_xdp;\n\tint err;\n\n\tif (!lan966x->fdma) {\n\t\tNL_SET_ERR_MSG_MOD(xdp->extack,\n\t\t\t\t   \"Allow to set xdp only when using fdma\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\told_xdp = lan966x_xdp_present(lan966x);\n\told_prog = xchg(&port->xdp_prog, xdp->prog);\n\tnew_xdp = lan966x_xdp_present(lan966x);\n\n\tif (old_xdp == new_xdp)\n\t\tgoto out;\n\n\terr = lan966x_fdma_reload_page_pool(lan966x);\n\tif (err) {\n\t\txchg(&port->xdp_prog, old_prog);\n\t\treturn err;\n\t}\n\nout:\n\tif (old_prog)\n\t\tbpf_prog_put(old_prog);\n\n\treturn 0;\n}\n\nint lan966x_xdp(struct net_device *dev, struct netdev_bpf *xdp)\n{\n\tswitch (xdp->command) {\n\tcase XDP_SETUP_PROG:\n\t\treturn lan966x_xdp_setup(dev, xdp);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nint lan966x_xdp_xmit(struct net_device *dev,\n\t\t     int n,\n\t\t     struct xdp_frame **frames,\n\t\t     u32 flags)\n{\n\tstruct lan966x_port *port = netdev_priv(dev);\n\tint nxmit = 0;\n\n\tfor (int i = 0; i < n; ++i) {\n\t\tstruct xdp_frame *xdpf = frames[i];\n\t\tint err;\n\n\t\terr = lan966x_fdma_xmit_xdpf(port, xdpf, 0);\n\t\tif (err)\n\t\t\tbreak;\n\n\t\tnxmit++;\n\t}\n\n\treturn nxmit;\n}\n\nint lan966x_xdp_run(struct lan966x_port *port, struct page *page, u32 data_len)\n{\n\tstruct bpf_prog *xdp_prog = port->xdp_prog;\n\tstruct lan966x *lan966x = port->lan966x;\n\tstruct xdp_buff xdp;\n\tu32 act;\n\n\txdp_init_buff(&xdp, PAGE_SIZE << lan966x->rx.page_order,\n\t\t      &port->xdp_rxq);\n\txdp_prepare_buff(&xdp, page_address(page),\n\t\t\t IFH_LEN_BYTES + XDP_PACKET_HEADROOM,\n\t\t\t data_len - IFH_LEN_BYTES, false);\n\tact = bpf_prog_run_xdp(xdp_prog, &xdp);\n\tswitch (act) {\n\tcase XDP_PASS:\n\t\treturn FDMA_PASS;\n\tcase XDP_TX:\n\t\treturn lan966x_fdma_xmit_xdpf(port, page,\n\t\t\t\t\t      data_len - IFH_LEN_BYTES) ?\n\t\t       FDMA_DROP : FDMA_TX;\n\tcase XDP_REDIRECT:\n\t\tif (xdp_do_redirect(port->dev, &xdp, xdp_prog))\n\t\t\treturn FDMA_DROP;\n\n\t\treturn FDMA_REDIRECT;\n\tdefault:\n\t\tbpf_warn_invalid_xdp_action(port->dev, xdp_prog, act);\n\t\tfallthrough;\n\tcase XDP_ABORTED:\n\t\ttrace_xdp_exception(port->dev, xdp_prog, act);\n\t\tfallthrough;\n\tcase XDP_DROP:\n\t\treturn FDMA_DROP;\n\t}\n}\n\nbool lan966x_xdp_present(struct lan966x *lan966x)\n{\n\tfor (int p = 0; p < lan966x->num_phys_ports; ++p) {\n\t\tif (!lan966x->ports[p])\n\t\t\tcontinue;\n\n\t\tif (lan966x_xdp_port_present(lan966x->ports[p]))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nint lan966x_xdp_port_init(struct lan966x_port *port)\n{\n\tstruct lan966x *lan966x = port->lan966x;\n\n\treturn xdp_rxq_info_reg(&port->xdp_rxq, port->dev, 0,\n\t\t\t\tlan966x->napi.napi_id);\n}\n\nvoid lan966x_xdp_port_deinit(struct lan966x_port *port)\n{\n\tif (xdp_rxq_info_is_reg(&port->xdp_rxq))\n\t\txdp_rxq_info_unreg(&port->xdp_rxq);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}