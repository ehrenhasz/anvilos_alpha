{
  "module_name": "lan966x_switchdev.c",
  "hash_id": "5cd6b57ccf05ee00045ba108967e6fba8536d2233de8d8b3db8091943a3d859c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/microchip/lan966x/lan966x_switchdev.c",
  "human_readable_source": "\n\n#include <linux/if_bridge.h>\n#include <net/switchdev.h>\n\n#include \"lan966x_main.h\"\n\nstatic struct notifier_block lan966x_netdevice_nb __read_mostly;\n\nstatic void lan966x_port_set_mcast_ip_flood(struct lan966x_port *port,\n\t\t\t\t\t    u32 pgid_ip)\n{\n\tstruct lan966x *lan966x = port->lan966x;\n\tu32 flood_mask_ip;\n\n\tflood_mask_ip = lan_rd(lan966x, ANA_PGID(pgid_ip));\n\tflood_mask_ip = ANA_PGID_PGID_GET(flood_mask_ip);\n\n\t \n\tif (!port->mcast_ena) {\n\t\tu32 flood_mask;\n\n\t\tflood_mask = lan_rd(lan966x, ANA_PGID(PGID_MC));\n\t\tflood_mask = ANA_PGID_PGID_GET(flood_mask);\n\n\t\tif (flood_mask & BIT(port->chip_port))\n\t\t\tflood_mask_ip |= BIT(port->chip_port);\n\t\telse\n\t\t\tflood_mask_ip &= ~BIT(port->chip_port);\n\t} else {\n\t\tflood_mask_ip &= ~BIT(port->chip_port);\n\t}\n\n\tlan_rmw(ANA_PGID_PGID_SET(flood_mask_ip),\n\t\tANA_PGID_PGID,\n\t\tlan966x, ANA_PGID(pgid_ip));\n}\n\nstatic void lan966x_port_set_mcast_flood(struct lan966x_port *port,\n\t\t\t\t\t bool enabled)\n{\n\tu32 val = lan_rd(port->lan966x, ANA_PGID(PGID_MC));\n\n\tval = ANA_PGID_PGID_GET(val);\n\tif (enabled)\n\t\tval |= BIT(port->chip_port);\n\telse\n\t\tval &= ~BIT(port->chip_port);\n\n\tlan_rmw(ANA_PGID_PGID_SET(val),\n\t\tANA_PGID_PGID,\n\t\tport->lan966x, ANA_PGID(PGID_MC));\n\n\tif (!port->mcast_ena) {\n\t\tlan966x_port_set_mcast_ip_flood(port, PGID_MCIPV4);\n\t\tlan966x_port_set_mcast_ip_flood(port, PGID_MCIPV6);\n\t}\n}\n\nstatic void lan966x_port_set_ucast_flood(struct lan966x_port *port,\n\t\t\t\t\t bool enabled)\n{\n\tu32 val = lan_rd(port->lan966x, ANA_PGID(PGID_UC));\n\n\tval = ANA_PGID_PGID_GET(val);\n\tif (enabled)\n\t\tval |= BIT(port->chip_port);\n\telse\n\t\tval &= ~BIT(port->chip_port);\n\n\tlan_rmw(ANA_PGID_PGID_SET(val),\n\t\tANA_PGID_PGID,\n\t\tport->lan966x, ANA_PGID(PGID_UC));\n}\n\nstatic void lan966x_port_set_bcast_flood(struct lan966x_port *port,\n\t\t\t\t\t bool enabled)\n{\n\tu32 val = lan_rd(port->lan966x, ANA_PGID(PGID_BC));\n\n\tval = ANA_PGID_PGID_GET(val);\n\tif (enabled)\n\t\tval |= BIT(port->chip_port);\n\telse\n\t\tval &= ~BIT(port->chip_port);\n\n\tlan_rmw(ANA_PGID_PGID_SET(val),\n\t\tANA_PGID_PGID,\n\t\tport->lan966x, ANA_PGID(PGID_BC));\n}\n\nstatic void lan966x_port_set_learning(struct lan966x_port *port, bool enabled)\n{\n\tlan_rmw(ANA_PORT_CFG_LEARN_ENA_SET(enabled),\n\t\tANA_PORT_CFG_LEARN_ENA,\n\t\tport->lan966x, ANA_PORT_CFG(port->chip_port));\n\n\tport->learn_ena = enabled;\n}\n\nstatic void lan966x_port_bridge_flags(struct lan966x_port *port,\n\t\t\t\t      struct switchdev_brport_flags flags)\n{\n\tif (flags.mask & BR_MCAST_FLOOD)\n\t\tlan966x_port_set_mcast_flood(port,\n\t\t\t\t\t     !!(flags.val & BR_MCAST_FLOOD));\n\n\tif (flags.mask & BR_FLOOD)\n\t\tlan966x_port_set_ucast_flood(port,\n\t\t\t\t\t     !!(flags.val & BR_FLOOD));\n\n\tif (flags.mask & BR_BCAST_FLOOD)\n\t\tlan966x_port_set_bcast_flood(port,\n\t\t\t\t\t     !!(flags.val & BR_BCAST_FLOOD));\n\n\tif (flags.mask & BR_LEARNING)\n\t\tlan966x_port_set_learning(port,\n\t\t\t\t\t  !!(flags.val & BR_LEARNING));\n}\n\nstatic int lan966x_port_pre_bridge_flags(struct lan966x_port *port,\n\t\t\t\t\t struct switchdev_brport_flags flags)\n{\n\tif (flags.mask & ~(BR_MCAST_FLOOD | BR_FLOOD | BR_BCAST_FLOOD |\n\t\t\t   BR_LEARNING))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nvoid lan966x_update_fwd_mask(struct lan966x *lan966x)\n{\n\tint i;\n\n\tfor (i = 0; i < lan966x->num_phys_ports; i++) {\n\t\tstruct lan966x_port *port = lan966x->ports[i];\n\t\tunsigned long mask = 0;\n\n\t\tif (port && lan966x->bridge_fwd_mask & BIT(i)) {\n\t\t\tmask = lan966x->bridge_fwd_mask & ~BIT(i);\n\n\t\t\tif (port->bond)\n\t\t\t\tmask &= ~lan966x_lag_get_mask(lan966x,\n\t\t\t\t\t\t\t      port->bond);\n\t\t}\n\n\t\tmask |= BIT(CPU_PORT);\n\n\t\tlan_wr(ANA_PGID_PGID_SET(mask),\n\t\t       lan966x, ANA_PGID(PGID_SRC + i));\n\t}\n}\n\nvoid lan966x_port_stp_state_set(struct lan966x_port *port, u8 state)\n{\n\tstruct lan966x *lan966x = port->lan966x;\n\tbool learn_ena = false;\n\n\tif ((state == BR_STATE_FORWARDING || state == BR_STATE_LEARNING) &&\n\t    port->learn_ena)\n\t\tlearn_ena = true;\n\n\tif (state == BR_STATE_FORWARDING)\n\t\tlan966x->bridge_fwd_mask |= BIT(port->chip_port);\n\telse\n\t\tlan966x->bridge_fwd_mask &= ~BIT(port->chip_port);\n\n\tlan_rmw(ANA_PORT_CFG_LEARN_ENA_SET(learn_ena),\n\t\tANA_PORT_CFG_LEARN_ENA,\n\t\tlan966x, ANA_PORT_CFG(port->chip_port));\n\n\tlan966x_update_fwd_mask(lan966x);\n}\n\nvoid lan966x_port_ageing_set(struct lan966x_port *port,\n\t\t\t     unsigned long ageing_clock_t)\n{\n\tunsigned long ageing_jiffies = clock_t_to_jiffies(ageing_clock_t);\n\tu32 ageing_time = jiffies_to_msecs(ageing_jiffies) / 1000;\n\n\tlan966x_mac_set_ageing(port->lan966x, ageing_time);\n}\n\nstatic void lan966x_port_mc_set(struct lan966x_port *port, bool mcast_ena)\n{\n\tstruct lan966x *lan966x = port->lan966x;\n\n\tport->mcast_ena = mcast_ena;\n\tif (mcast_ena)\n\t\tlan966x_mdb_restore_entries(lan966x);\n\telse\n\t\tlan966x_mdb_clear_entries(lan966x);\n\n\tlan_rmw(ANA_CPU_FWD_CFG_IGMP_REDIR_ENA_SET(mcast_ena) |\n\t\tANA_CPU_FWD_CFG_MLD_REDIR_ENA_SET(mcast_ena) |\n\t\tANA_CPU_FWD_CFG_IPMC_CTRL_COPY_ENA_SET(mcast_ena),\n\t\tANA_CPU_FWD_CFG_IGMP_REDIR_ENA |\n\t\tANA_CPU_FWD_CFG_MLD_REDIR_ENA |\n\t\tANA_CPU_FWD_CFG_IPMC_CTRL_COPY_ENA,\n\t\tlan966x, ANA_CPU_FWD_CFG(port->chip_port));\n\n\tlan966x_port_set_mcast_ip_flood(port, PGID_MCIPV4);\n\tlan966x_port_set_mcast_ip_flood(port, PGID_MCIPV6);\n}\n\nstatic int lan966x_port_attr_set(struct net_device *dev, const void *ctx,\n\t\t\t\t const struct switchdev_attr *attr,\n\t\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct lan966x_port *port = netdev_priv(dev);\n\tint err = 0;\n\n\tif (ctx && ctx != port)\n\t\treturn 0;\n\n\tswitch (attr->id) {\n\tcase SWITCHDEV_ATTR_ID_PORT_BRIDGE_FLAGS:\n\t\tlan966x_port_bridge_flags(port, attr->u.brport_flags);\n\t\tbreak;\n\tcase SWITCHDEV_ATTR_ID_PORT_PRE_BRIDGE_FLAGS:\n\t\terr = lan966x_port_pre_bridge_flags(port, attr->u.brport_flags);\n\t\tbreak;\n\tcase SWITCHDEV_ATTR_ID_PORT_STP_STATE:\n\t\tlan966x_port_stp_state_set(port, attr->u.stp_state);\n\t\tbreak;\n\tcase SWITCHDEV_ATTR_ID_BRIDGE_AGEING_TIME:\n\t\tlan966x_port_ageing_set(port, attr->u.ageing_time);\n\t\tbreak;\n\tcase SWITCHDEV_ATTR_ID_BRIDGE_VLAN_FILTERING:\n\t\tlan966x_vlan_port_set_vlan_aware(port, attr->u.vlan_filtering);\n\t\tlan966x_vlan_port_apply(port);\n\t\tbreak;\n\tcase SWITCHDEV_ATTR_ID_BRIDGE_MC_DISABLED:\n\t\tlan966x_port_mc_set(port, !attr->u.mc_disabled);\n\t\tbreak;\n\tdefault:\n\t\terr = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nstatic int lan966x_port_bridge_join(struct lan966x_port *port,\n\t\t\t\t    struct net_device *brport_dev,\n\t\t\t\t    struct net_device *bridge,\n\t\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct switchdev_brport_flags flags = {0};\n\tstruct lan966x *lan966x = port->lan966x;\n\tstruct net_device *dev = port->dev;\n\tint err;\n\n\tif (!lan966x->bridge_mask) {\n\t\tlan966x->bridge = bridge;\n\t} else {\n\t\tif (lan966x->bridge != bridge) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Not allow to add port to different bridge\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\terr = switchdev_bridge_port_offload(brport_dev, dev, port,\n\t\t\t\t\t    &lan966x_switchdev_nb,\n\t\t\t\t\t    &lan966x_switchdev_blocking_nb,\n\t\t\t\t\t    false, extack);\n\tif (err)\n\t\treturn err;\n\n\tlan966x->bridge_mask |= BIT(port->chip_port);\n\n\tflags.mask = BR_LEARNING | BR_FLOOD | BR_MCAST_FLOOD | BR_BCAST_FLOOD;\n\tflags.val = flags.mask;\n\tlan966x_port_bridge_flags(port, flags);\n\n\treturn 0;\n}\n\nstatic void lan966x_port_bridge_leave(struct lan966x_port *port,\n\t\t\t\t      struct net_device *bridge)\n{\n\tstruct switchdev_brport_flags flags = {0};\n\tstruct lan966x *lan966x = port->lan966x;\n\n\tflags.mask = BR_LEARNING | BR_FLOOD | BR_MCAST_FLOOD | BR_BCAST_FLOOD;\n\tflags.val = flags.mask & ~BR_LEARNING;\n\tlan966x_port_bridge_flags(port, flags);\n\n\tlan966x->bridge_mask &= ~BIT(port->chip_port);\n\n\tif (!lan966x->bridge_mask)\n\t\tlan966x->bridge = NULL;\n\n\t \n\tlan966x_vlan_port_set_vlan_aware(port, false);\n\tlan966x_vlan_port_set_vid(port, HOST_PVID, false, false);\n\tlan966x_vlan_port_apply(port);\n}\n\nint lan966x_port_changeupper(struct net_device *dev,\n\t\t\t     struct net_device *brport_dev,\n\t\t\t     struct netdev_notifier_changeupper_info *info)\n{\n\tstruct lan966x_port *port = netdev_priv(dev);\n\tstruct netlink_ext_ack *extack;\n\tint err = 0;\n\n\textack = netdev_notifier_info_to_extack(&info->info);\n\n\tif (netif_is_bridge_master(info->upper_dev)) {\n\t\tif (info->linking)\n\t\t\terr = lan966x_port_bridge_join(port, brport_dev,\n\t\t\t\t\t\t       info->upper_dev,\n\t\t\t\t\t\t       extack);\n\t\telse\n\t\t\tlan966x_port_bridge_leave(port, info->upper_dev);\n\t}\n\n\tif (netif_is_lag_master(info->upper_dev)) {\n\t\tif (info->linking)\n\t\t\terr = lan966x_lag_port_join(port, info->upper_dev,\n\t\t\t\t\t\t    info->upper_dev,\n\t\t\t\t\t\t    extack);\n\t\telse\n\t\t\tlan966x_lag_port_leave(port, info->upper_dev);\n\t}\n\n\treturn err;\n}\n\nint lan966x_port_prechangeupper(struct net_device *dev,\n\t\t\t\tstruct net_device *brport_dev,\n\t\t\t\tstruct netdev_notifier_changeupper_info *info)\n{\n\tstruct lan966x_port *port = netdev_priv(dev);\n\tint err = NOTIFY_DONE;\n\n\tif (netif_is_bridge_master(info->upper_dev) && !info->linking) {\n\t\tswitchdev_bridge_port_unoffload(port->dev, port, NULL, NULL);\n\t\tlan966x_fdb_flush_workqueue(port->lan966x);\n\t}\n\n\tif (netif_is_lag_master(info->upper_dev)) {\n\t\terr = lan966x_lag_port_prechangeupper(dev, info);\n\t\tif (err || info->linking)\n\t\t\treturn err;\n\n\t\tswitchdev_bridge_port_unoffload(brport_dev, port, NULL, NULL);\n\t\tlan966x_fdb_flush_workqueue(port->lan966x);\n\t}\n\n\treturn err;\n}\n\nstatic int lan966x_foreign_bridging_check(struct net_device *upper,\n\t\t\t\t\t  bool *has_foreign,\n\t\t\t\t\t  bool *seen_lan966x,\n\t\t\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct lan966x *lan966x = NULL;\n\tstruct net_device *dev;\n\tstruct list_head *iter;\n\n\tif (!netif_is_bridge_master(upper) &&\n\t    !netif_is_lag_master(upper))\n\t\treturn 0;\n\n\tnetdev_for_each_lower_dev(upper, dev, iter) {\n\t\tif (lan966x_netdevice_check(dev)) {\n\t\t\tstruct lan966x_port *port = netdev_priv(dev);\n\n\t\t\tif (lan966x) {\n\t\t\t\t \n\t\t\t\tif (port->lan966x != lan966x) {\n\t\t\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t\t\t   \"Bridging between multiple lan966x switches disallowed\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tlan966x = port->lan966x;\n\t\t\t\t*seen_lan966x = true;\n\t\t\t}\n\t\t} else if (netif_is_lag_master(dev)) {\n\t\t\t \n\t\t\tif (lan966x_foreign_bridging_check(dev, has_foreign,\n\t\t\t\t\t\t\t   seen_lan966x,\n\t\t\t\t\t\t\t   extack))\n\t\t\t\treturn -EINVAL;\n\t\t} else {\n\t\t\t*has_foreign = true;\n\t\t}\n\n\t\tif (*seen_lan966x && *has_foreign) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t   \"Bridging lan966x ports with foreign interfaces disallowed\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int lan966x_bridge_check(struct net_device *dev,\n\t\t\t\tstruct netdev_notifier_changeupper_info *info)\n{\n\tbool has_foreign = false;\n\tbool seen_lan966x = false;\n\n\treturn lan966x_foreign_bridging_check(info->upper_dev,\n\t\t\t\t\t      &has_foreign,\n\t\t\t\t\t      &seen_lan966x,\n\t\t\t\t\t      info->info.extack);\n}\n\nstatic int lan966x_netdevice_port_event(struct net_device *dev,\n\t\t\t\t\tstruct notifier_block *nb,\n\t\t\t\t\tunsigned long event, void *ptr)\n{\n\tint err = 0;\n\n\tif (!lan966x_netdevice_check(dev)) {\n\t\tswitch (event) {\n\t\tcase NETDEV_CHANGEUPPER:\n\t\tcase NETDEV_PRECHANGEUPPER:\n\t\t\terr = lan966x_bridge_check(dev, ptr);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\tif (netif_is_lag_master(dev)) {\n\t\t\t\tif (event == NETDEV_CHANGEUPPER)\n\t\t\t\t\terr = lan966x_lag_netdev_changeupper(dev,\n\t\t\t\t\t\t\t\t\t     ptr);\n\t\t\t\telse\n\t\t\t\t\terr = lan966x_lag_netdev_prechangeupper(dev,\n\t\t\t\t\t\t\t\t\t\tptr);\n\n\t\t\t\treturn err;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tswitch (event) {\n\tcase NETDEV_PRECHANGEUPPER:\n\t\terr = lan966x_port_prechangeupper(dev, dev, ptr);\n\t\tbreak;\n\tcase NETDEV_CHANGEUPPER:\n\t\terr = lan966x_bridge_check(dev, ptr);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = lan966x_port_changeupper(dev, dev, ptr);\n\t\tbreak;\n\tcase NETDEV_CHANGELOWERSTATE:\n\t\terr = lan966x_lag_port_changelowerstate(dev, ptr);\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nstatic int lan966x_netdevice_event(struct notifier_block *nb,\n\t\t\t\t   unsigned long event, void *ptr)\n{\n\tstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\n\tint ret;\n\n\tret = lan966x_netdevice_port_event(dev, nb, event, ptr);\n\n\treturn notifier_from_errno(ret);\n}\n\nstatic bool lan966x_foreign_dev_check(const struct net_device *dev,\n\t\t\t\t      const struct net_device *foreign_dev)\n{\n\tstruct lan966x_port *port = netdev_priv(dev);\n\tstruct lan966x *lan966x = port->lan966x;\n\tint i;\n\n\tif (netif_is_bridge_master(foreign_dev))\n\t\tif (lan966x->bridge == foreign_dev)\n\t\t\treturn false;\n\n\tif (netif_is_lag_master(foreign_dev))\n\t\tfor (i = 0; i < lan966x->num_phys_ports; ++i)\n\t\t\tif (lan966x->ports[i] &&\n\t\t\t    lan966x->ports[i]->bond == foreign_dev)\n\t\t\t\treturn false;\n\n\treturn true;\n}\n\nstatic int lan966x_switchdev_event(struct notifier_block *nb,\n\t\t\t\t   unsigned long event, void *ptr)\n{\n\tstruct net_device *dev = switchdev_notifier_info_to_dev(ptr);\n\tint err;\n\n\tswitch (event) {\n\tcase SWITCHDEV_PORT_ATTR_SET:\n\t\terr = switchdev_handle_port_attr_set(dev, ptr,\n\t\t\t\t\t\t     lan966x_netdevice_check,\n\t\t\t\t\t\t     lan966x_port_attr_set);\n\t\treturn notifier_from_errno(err);\n\tcase SWITCHDEV_FDB_ADD_TO_DEVICE:\n\tcase SWITCHDEV_FDB_DEL_TO_DEVICE:\n\t\terr = switchdev_handle_fdb_event_to_device(dev, event, ptr,\n\t\t\t\t\t\t\t   lan966x_netdevice_check,\n\t\t\t\t\t\t\t   lan966x_foreign_dev_check,\n\t\t\t\t\t\t\t   lan966x_handle_fdb);\n\t\treturn notifier_from_errno(err);\n\t}\n\n\treturn NOTIFY_DONE;\n}\n\nstatic int lan966x_handle_port_vlan_add(struct lan966x_port *port,\n\t\t\t\t\tconst struct switchdev_obj *obj)\n{\n\tconst struct switchdev_obj_port_vlan *v = SWITCHDEV_OBJ_PORT_VLAN(obj);\n\tstruct lan966x *lan966x = port->lan966x;\n\n\tif (!netif_is_bridge_master(obj->orig_dev))\n\t\tlan966x_vlan_port_add_vlan(port, v->vid,\n\t\t\t\t\t   v->flags & BRIDGE_VLAN_INFO_PVID,\n\t\t\t\t\t   v->flags & BRIDGE_VLAN_INFO_UNTAGGED);\n\telse\n\t\tlan966x_vlan_cpu_add_vlan(lan966x, v->vid);\n\n\treturn 0;\n}\n\nstatic int lan966x_handle_port_obj_add(struct net_device *dev, const void *ctx,\n\t\t\t\t       const struct switchdev_obj *obj,\n\t\t\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct lan966x_port *port = netdev_priv(dev);\n\tint err;\n\n\tif (ctx && ctx != port)\n\t\treturn 0;\n\n\tswitch (obj->id) {\n\tcase SWITCHDEV_OBJ_ID_PORT_VLAN:\n\t\terr = lan966x_handle_port_vlan_add(port, obj);\n\t\tbreak;\n\tcase SWITCHDEV_OBJ_ID_PORT_MDB:\n\tcase SWITCHDEV_OBJ_ID_HOST_MDB:\n\t\terr = lan966x_handle_port_mdb_add(port, obj);\n\t\tbreak;\n\tdefault:\n\t\terr = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nstatic int lan966x_handle_port_vlan_del(struct lan966x_port *port,\n\t\t\t\t\tconst struct switchdev_obj *obj)\n{\n\tconst struct switchdev_obj_port_vlan *v = SWITCHDEV_OBJ_PORT_VLAN(obj);\n\tstruct lan966x *lan966x = port->lan966x;\n\n\tif (!netif_is_bridge_master(obj->orig_dev))\n\t\tlan966x_vlan_port_del_vlan(port, v->vid);\n\telse\n\t\tlan966x_vlan_cpu_del_vlan(lan966x, v->vid);\n\n\treturn 0;\n}\n\nstatic int lan966x_handle_port_obj_del(struct net_device *dev, const void *ctx,\n\t\t\t\t       const struct switchdev_obj *obj)\n{\n\tstruct lan966x_port *port = netdev_priv(dev);\n\tint err;\n\n\tif (ctx && ctx != port)\n\t\treturn 0;\n\n\tswitch (obj->id) {\n\tcase SWITCHDEV_OBJ_ID_PORT_VLAN:\n\t\terr = lan966x_handle_port_vlan_del(port, obj);\n\t\tbreak;\n\tcase SWITCHDEV_OBJ_ID_PORT_MDB:\n\tcase SWITCHDEV_OBJ_ID_HOST_MDB:\n\t\terr = lan966x_handle_port_mdb_del(port, obj);\n\t\tbreak;\n\tdefault:\n\t\terr = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nstatic int lan966x_switchdev_blocking_event(struct notifier_block *nb,\n\t\t\t\t\t    unsigned long event,\n\t\t\t\t\t    void *ptr)\n{\n\tstruct net_device *dev = switchdev_notifier_info_to_dev(ptr);\n\tint err;\n\n\tswitch (event) {\n\tcase SWITCHDEV_PORT_OBJ_ADD:\n\t\terr = switchdev_handle_port_obj_add(dev, ptr,\n\t\t\t\t\t\t    lan966x_netdevice_check,\n\t\t\t\t\t\t    lan966x_handle_port_obj_add);\n\t\treturn notifier_from_errno(err);\n\tcase SWITCHDEV_PORT_OBJ_DEL:\n\t\terr = switchdev_handle_port_obj_del(dev, ptr,\n\t\t\t\t\t\t    lan966x_netdevice_check,\n\t\t\t\t\t\t    lan966x_handle_port_obj_del);\n\t\treturn notifier_from_errno(err);\n\tcase SWITCHDEV_PORT_ATTR_SET:\n\t\terr = switchdev_handle_port_attr_set(dev, ptr,\n\t\t\t\t\t\t     lan966x_netdevice_check,\n\t\t\t\t\t\t     lan966x_port_attr_set);\n\t\treturn notifier_from_errno(err);\n\t}\n\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block lan966x_netdevice_nb __read_mostly = {\n\t.notifier_call = lan966x_netdevice_event,\n};\n\nstruct notifier_block lan966x_switchdev_nb __read_mostly = {\n\t.notifier_call = lan966x_switchdev_event,\n};\n\nstruct notifier_block lan966x_switchdev_blocking_nb __read_mostly = {\n\t.notifier_call = lan966x_switchdev_blocking_event,\n};\n\nvoid lan966x_register_notifier_blocks(void)\n{\n\tregister_netdevice_notifier(&lan966x_netdevice_nb);\n\tregister_switchdev_notifier(&lan966x_switchdev_nb);\n\tregister_switchdev_blocking_notifier(&lan966x_switchdev_blocking_nb);\n}\n\nvoid lan966x_unregister_notifier_blocks(void)\n{\n\tunregister_switchdev_blocking_notifier(&lan966x_switchdev_blocking_nb);\n\tunregister_switchdev_notifier(&lan966x_switchdev_nb);\n\tunregister_netdevice_notifier(&lan966x_netdevice_nb);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}