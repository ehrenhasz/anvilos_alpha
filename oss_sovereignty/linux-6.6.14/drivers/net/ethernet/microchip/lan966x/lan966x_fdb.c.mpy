{
  "module_name": "lan966x_fdb.c",
  "hash_id": "ebfdec559ce1efc0efa71ae911314183ff37ffc2d630376619a8719c19fdc3cf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/microchip/lan966x/lan966x_fdb.c",
  "human_readable_source": "\n\n#include <net/switchdev.h>\n\n#include \"lan966x_main.h\"\n\nstruct lan966x_fdb_event_work {\n\tstruct work_struct work;\n\tstruct switchdev_notifier_fdb_info fdb_info;\n\tstruct net_device *dev;\n\tstruct net_device *orig_dev;\n\tstruct lan966x *lan966x;\n\tunsigned long event;\n};\n\nstruct lan966x_fdb_entry {\n\tstruct list_head list;\n\tunsigned char mac[ETH_ALEN] __aligned(2);\n\tu16 vid;\n\tu32 references;\n};\n\nstatic struct lan966x_fdb_entry *\nlan966x_fdb_find_entry(struct lan966x *lan966x,\n\t\t       struct switchdev_notifier_fdb_info *fdb_info)\n{\n\tstruct lan966x_fdb_entry *fdb_entry;\n\n\tlist_for_each_entry(fdb_entry, &lan966x->fdb_entries, list) {\n\t\tif (fdb_entry->vid == fdb_info->vid &&\n\t\t    ether_addr_equal(fdb_entry->mac, fdb_info->addr))\n\t\t\treturn fdb_entry;\n\t}\n\n\treturn NULL;\n}\n\nstatic void lan966x_fdb_add_entry(struct lan966x *lan966x,\n\t\t\t\t  struct switchdev_notifier_fdb_info *fdb_info)\n{\n\tstruct lan966x_fdb_entry *fdb_entry;\n\n\tfdb_entry = lan966x_fdb_find_entry(lan966x, fdb_info);\n\tif (fdb_entry) {\n\t\tfdb_entry->references++;\n\t\treturn;\n\t}\n\n\tfdb_entry = kzalloc(sizeof(*fdb_entry), GFP_KERNEL);\n\tif (!fdb_entry)\n\t\treturn;\n\n\tether_addr_copy(fdb_entry->mac, fdb_info->addr);\n\tfdb_entry->vid = fdb_info->vid;\n\tfdb_entry->references = 1;\n\tlist_add_tail(&fdb_entry->list, &lan966x->fdb_entries);\n}\n\nstatic bool lan966x_fdb_del_entry(struct lan966x *lan966x,\n\t\t\t\t  struct switchdev_notifier_fdb_info *fdb_info)\n{\n\tstruct lan966x_fdb_entry *fdb_entry, *tmp;\n\n\tlist_for_each_entry_safe(fdb_entry, tmp, &lan966x->fdb_entries,\n\t\t\t\t list) {\n\t\tif (fdb_entry->vid == fdb_info->vid &&\n\t\t    ether_addr_equal(fdb_entry->mac, fdb_info->addr)) {\n\t\t\tfdb_entry->references--;\n\t\t\tif (!fdb_entry->references) {\n\t\t\t\tlist_del(&fdb_entry->list);\n\t\t\t\tkfree(fdb_entry);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nvoid lan966x_fdb_write_entries(struct lan966x *lan966x, u16 vid)\n{\n\tstruct lan966x_fdb_entry *fdb_entry;\n\n\tlist_for_each_entry(fdb_entry, &lan966x->fdb_entries, list) {\n\t\tif (fdb_entry->vid != vid)\n\t\t\tcontinue;\n\n\t\tlan966x_mac_cpu_learn(lan966x, fdb_entry->mac, fdb_entry->vid);\n\t}\n}\n\nvoid lan966x_fdb_erase_entries(struct lan966x *lan966x, u16 vid)\n{\n\tstruct lan966x_fdb_entry *fdb_entry;\n\n\tlist_for_each_entry(fdb_entry, &lan966x->fdb_entries, list) {\n\t\tif (fdb_entry->vid != vid)\n\t\t\tcontinue;\n\n\t\tlan966x_mac_cpu_forget(lan966x, fdb_entry->mac, fdb_entry->vid);\n\t}\n}\n\nstatic void lan966x_fdb_purge_entries(struct lan966x *lan966x)\n{\n\tstruct lan966x_fdb_entry *fdb_entry, *tmp;\n\n\tlist_for_each_entry_safe(fdb_entry, tmp, &lan966x->fdb_entries, list) {\n\t\tlist_del(&fdb_entry->list);\n\t\tkfree(fdb_entry);\n\t}\n}\n\nint lan966x_fdb_init(struct lan966x *lan966x)\n{\n\tINIT_LIST_HEAD(&lan966x->fdb_entries);\n\tlan966x->fdb_work = alloc_ordered_workqueue(\"lan966x_order\", 0);\n\tif (!lan966x->fdb_work)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nvoid lan966x_fdb_deinit(struct lan966x *lan966x)\n{\n\tdestroy_workqueue(lan966x->fdb_work);\n\tlan966x_fdb_purge_entries(lan966x);\n}\n\nvoid lan966x_fdb_flush_workqueue(struct lan966x *lan966x)\n{\n\tflush_workqueue(lan966x->fdb_work);\n}\n\nstatic void lan966x_fdb_port_event_work(struct lan966x_fdb_event_work *fdb_work)\n{\n\tstruct switchdev_notifier_fdb_info *fdb_info;\n\tstruct lan966x_port *port;\n\tstruct lan966x *lan966x;\n\n\tlan966x = fdb_work->lan966x;\n\tport = netdev_priv(fdb_work->orig_dev);\n\tfdb_info = &fdb_work->fdb_info;\n\n\tswitch (fdb_work->event) {\n\tcase SWITCHDEV_FDB_ADD_TO_DEVICE:\n\t\tif (!fdb_info->added_by_user)\n\t\t\tbreak;\n\t\tlan966x_mac_add_entry(lan966x, port, fdb_info->addr,\n\t\t\t\t      fdb_info->vid);\n\t\tbreak;\n\tcase SWITCHDEV_FDB_DEL_TO_DEVICE:\n\t\tif (!fdb_info->added_by_user)\n\t\t\tbreak;\n\t\tlan966x_mac_del_entry(lan966x, fdb_info->addr,\n\t\t\t\t      fdb_info->vid);\n\t\tbreak;\n\t}\n}\n\nstatic void lan966x_fdb_bridge_event_work(struct lan966x_fdb_event_work *fdb_work)\n{\n\tstruct switchdev_notifier_fdb_info *fdb_info;\n\tstruct lan966x *lan966x;\n\tint ret;\n\n\tlan966x = fdb_work->lan966x;\n\tfdb_info = &fdb_work->fdb_info;\n\n\t \n\tswitch (fdb_work->event) {\n\tcase SWITCHDEV_FDB_ADD_TO_DEVICE:\n\t\t \n\t\tlan966x_fdb_add_entry(lan966x, fdb_info);\n\t\tif (!lan966x_vlan_cpu_member_cpu_vlan_mask(lan966x,\n\t\t\t\t\t\t\t   fdb_info->vid))\n\t\t\tbreak;\n\n\t\tlan966x_mac_cpu_learn(lan966x, fdb_info->addr,\n\t\t\t\t      fdb_info->vid);\n\t\tbreak;\n\tcase SWITCHDEV_FDB_DEL_TO_DEVICE:\n\t\tret = lan966x_fdb_del_entry(lan966x, fdb_info);\n\t\tif (!lan966x_vlan_cpu_member_cpu_vlan_mask(lan966x,\n\t\t\t\t\t\t\t   fdb_info->vid))\n\t\t\tbreak;\n\n\t\tif (ret)\n\t\t\tlan966x_mac_cpu_forget(lan966x, fdb_info->addr,\n\t\t\t\t\t       fdb_info->vid);\n\t\tbreak;\n\t}\n}\n\nstatic void lan966x_fdb_lag_event_work(struct lan966x_fdb_event_work *fdb_work)\n{\n\tstruct switchdev_notifier_fdb_info *fdb_info;\n\tstruct lan966x_port *port;\n\tstruct lan966x *lan966x;\n\n\tif (!lan966x_lag_first_port(fdb_work->orig_dev, fdb_work->dev))\n\t\treturn;\n\n\tlan966x = fdb_work->lan966x;\n\tport = netdev_priv(fdb_work->dev);\n\tfdb_info = &fdb_work->fdb_info;\n\n\tswitch (fdb_work->event) {\n\tcase SWITCHDEV_FDB_ADD_TO_DEVICE:\n\t\tif (!fdb_info->added_by_user)\n\t\t\tbreak;\n\t\tlan966x_mac_add_entry(lan966x, port, fdb_info->addr,\n\t\t\t\t      fdb_info->vid);\n\t\tbreak;\n\tcase SWITCHDEV_FDB_DEL_TO_DEVICE:\n\t\tif (!fdb_info->added_by_user)\n\t\t\tbreak;\n\t\tlan966x_mac_del_entry(lan966x, fdb_info->addr, fdb_info->vid);\n\t\tbreak;\n\t}\n}\n\nstatic void lan966x_fdb_event_work(struct work_struct *work)\n{\n\tstruct lan966x_fdb_event_work *fdb_work =\n\t\tcontainer_of(work, struct lan966x_fdb_event_work, work);\n\n\tif (lan966x_netdevice_check(fdb_work->orig_dev))\n\t\tlan966x_fdb_port_event_work(fdb_work);\n\telse if (netif_is_bridge_master(fdb_work->orig_dev))\n\t\tlan966x_fdb_bridge_event_work(fdb_work);\n\telse if (netif_is_lag_master(fdb_work->orig_dev))\n\t\tlan966x_fdb_lag_event_work(fdb_work);\n\n\tkfree(fdb_work->fdb_info.addr);\n\tkfree(fdb_work);\n}\n\nint lan966x_handle_fdb(struct net_device *dev,\n\t\t       struct net_device *orig_dev,\n\t\t       unsigned long event, const void *ctx,\n\t\t       const struct switchdev_notifier_fdb_info *fdb_info)\n{\n\tstruct lan966x_port *port = netdev_priv(dev);\n\tstruct lan966x *lan966x = port->lan966x;\n\tstruct lan966x_fdb_event_work *fdb_work;\n\n\tif (ctx && ctx != port)\n\t\treturn 0;\n\n\tswitch (event) {\n\tcase SWITCHDEV_FDB_ADD_TO_DEVICE:\n\tcase SWITCHDEV_FDB_DEL_TO_DEVICE:\n\t\tif (lan966x_netdevice_check(orig_dev) &&\n\t\t    !fdb_info->added_by_user)\n\t\t\tbreak;\n\n\t\tfdb_work = kzalloc(sizeof(*fdb_work), GFP_ATOMIC);\n\t\tif (!fdb_work)\n\t\t\treturn -ENOMEM;\n\n\t\tfdb_work->dev = dev;\n\t\tfdb_work->orig_dev = orig_dev;\n\t\tfdb_work->lan966x = lan966x;\n\t\tfdb_work->event = event;\n\t\tINIT_WORK(&fdb_work->work, lan966x_fdb_event_work);\n\t\tmemcpy(&fdb_work->fdb_info, fdb_info, sizeof(fdb_work->fdb_info));\n\t\tfdb_work->fdb_info.addr = kzalloc(ETH_ALEN, GFP_ATOMIC);\n\t\tif (!fdb_work->fdb_info.addr)\n\t\t\tgoto err_addr_alloc;\n\n\t\tether_addr_copy((u8 *)fdb_work->fdb_info.addr, fdb_info->addr);\n\n\t\tqueue_work(lan966x->fdb_work, &fdb_work->work);\n\t\tbreak;\n\t}\n\n\treturn 0;\nerr_addr_alloc:\n\tkfree(fdb_work);\n\treturn -ENOMEM;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}