{
  "module_name": "lan966x_ptp.c",
  "hash_id": "aac88547e28f59a3b5c8836d57f772d584a839cb3c9cbe0fded082a245178dcc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/microchip/lan966x/lan966x_ptp.c",
  "human_readable_source": "\n\n#include <linux/ptp_classify.h>\n\n#include \"lan966x_main.h\"\n#include \"vcap_api.h\"\n#include \"vcap_api_client.h\"\n\n#define LAN966X_MAX_PTP_ID\t512\n\n \n#define LAN966X_1PPM_FORMAT\t\t3480517749723LL\n\n \n#define LAN966X_1PPB_FORMAT\t\t3480517749LL\n\n#define TOD_ACC_PIN\t\t0x7\n\n \n#define LAN966X_VCAP_PTP_RULE_ID\t1000000\n#define LAN966X_VCAP_L2_PTP_TRAP\t(LAN966X_VCAP_PTP_RULE_ID + 0)\n#define LAN966X_VCAP_IPV4_EV_PTP_TRAP\t(LAN966X_VCAP_PTP_RULE_ID + 1)\n#define LAN966X_VCAP_IPV4_GEN_PTP_TRAP\t(LAN966X_VCAP_PTP_RULE_ID + 2)\n#define LAN966X_VCAP_IPV6_EV_PTP_TRAP\t(LAN966X_VCAP_PTP_RULE_ID + 3)\n#define LAN966X_VCAP_IPV6_GEN_PTP_TRAP\t(LAN966X_VCAP_PTP_RULE_ID + 4)\n\nenum {\n\tPTP_PIN_ACTION_IDLE = 0,\n\tPTP_PIN_ACTION_LOAD,\n\tPTP_PIN_ACTION_SAVE,\n\tPTP_PIN_ACTION_CLOCK,\n\tPTP_PIN_ACTION_DELTA,\n\tPTP_PIN_ACTION_TOD\n};\n\nstatic u64 lan966x_ptp_get_nominal_value(void)\n{\n\t \n\treturn 0x304d4873ecade305;\n}\n\nstatic int lan966x_ptp_add_trap(struct lan966x_port *port,\n\t\t\t\tint (*add_ptp_key)(struct vcap_rule *vrule,\n\t\t\t\t\t\t   struct lan966x_port*),\n\t\t\t\tu32 rule_id,\n\t\t\t\tu16 proto)\n{\n\tstruct lan966x *lan966x = port->lan966x;\n\tstruct vcap_rule *vrule;\n\tint err;\n\n\tvrule = vcap_get_rule(lan966x->vcap_ctrl, rule_id);\n\tif (!IS_ERR(vrule)) {\n\t\tu32 value, mask;\n\n\t\t \n\t\tvcap_rule_get_key_u32(vrule, VCAP_KF_IF_IGR_PORT_MASK,\n\t\t\t\t      &value, &mask);\n\t\tmask &= ~BIT(port->chip_port);\n\t\tvcap_rule_mod_key_u32(vrule, VCAP_KF_IF_IGR_PORT_MASK,\n\t\t\t\t      value, mask);\n\n\t\terr = vcap_mod_rule(vrule);\n\t\tgoto free_rule;\n\t}\n\n\tvrule = vcap_alloc_rule(lan966x->vcap_ctrl, port->dev,\n\t\t\t\tLAN966X_VCAP_CID_IS2_L0,\n\t\t\t\tVCAP_USER_PTP, 0, rule_id);\n\tif (IS_ERR(vrule))\n\t\treturn PTR_ERR(vrule);\n\n\terr = add_ptp_key(vrule, port);\n\tif (err)\n\t\tgoto free_rule;\n\n\terr = vcap_rule_add_action_bit(vrule, VCAP_AF_CPU_COPY_ENA, VCAP_BIT_1);\n\terr |= vcap_rule_add_action_u32(vrule, VCAP_AF_MASK_MODE, LAN966X_PMM_REPLACE);\n\terr |= vcap_val_rule(vrule, proto);\n\tif (err)\n\t\tgoto free_rule;\n\n\terr = vcap_add_rule(vrule);\n\nfree_rule:\n\t \n\tvcap_free_rule(vrule);\n\treturn err;\n}\n\nstatic int lan966x_ptp_del_trap(struct lan966x_port *port,\n\t\t\t\tu32 rule_id)\n{\n\tstruct lan966x *lan966x = port->lan966x;\n\tstruct vcap_rule *vrule;\n\tu32 value, mask;\n\tint err;\n\n\tvrule = vcap_get_rule(lan966x->vcap_ctrl, rule_id);\n\tif (IS_ERR(vrule))\n\t\treturn -EEXIST;\n\n\tvcap_rule_get_key_u32(vrule, VCAP_KF_IF_IGR_PORT_MASK, &value, &mask);\n\tmask |= BIT(port->chip_port);\n\n\t \n\tif (mask == GENMASK(lan966x->num_phys_ports, 0)) {\n\t\terr = vcap_del_rule(lan966x->vcap_ctrl, port->dev, rule_id);\n\t\tgoto free_rule;\n\t}\n\n\tvcap_rule_mod_key_u32(vrule, VCAP_KF_IF_IGR_PORT_MASK, value, mask);\n\terr = vcap_mod_rule(vrule);\n\nfree_rule:\n\tvcap_free_rule(vrule);\n\treturn err;\n}\n\nstatic int lan966x_ptp_add_l2_key(struct vcap_rule *vrule,\n\t\t\t\t  struct lan966x_port *port)\n{\n\treturn vcap_rule_add_key_u32(vrule, VCAP_KF_ETYPE, ETH_P_1588, ~0);\n}\n\nstatic int lan966x_ptp_add_ip_event_key(struct vcap_rule *vrule,\n\t\t\t\t\tstruct lan966x_port *port)\n{\n\treturn vcap_rule_add_key_u32(vrule, VCAP_KF_L4_DPORT, PTP_EV_PORT, ~0) ||\n\t       vcap_rule_add_key_bit(vrule, VCAP_KF_TCP_IS, VCAP_BIT_0);\n}\n\nstatic int lan966x_ptp_add_ip_general_key(struct vcap_rule *vrule,\n\t\t\t\t\t  struct lan966x_port *port)\n{\n\treturn vcap_rule_add_key_u32(vrule, VCAP_KF_L4_DPORT, PTP_GEN_PORT, ~0) ||\n\t       vcap_rule_add_key_bit(vrule, VCAP_KF_TCP_IS, VCAP_BIT_0);\n}\n\nstatic int lan966x_ptp_add_l2_rule(struct lan966x_port *port)\n{\n\treturn lan966x_ptp_add_trap(port, lan966x_ptp_add_l2_key,\n\t\t\t\t    LAN966X_VCAP_L2_PTP_TRAP, ETH_P_ALL);\n}\n\nstatic int lan966x_ptp_add_ipv4_rules(struct lan966x_port *port)\n{\n\tint err;\n\n\terr = lan966x_ptp_add_trap(port, lan966x_ptp_add_ip_event_key,\n\t\t\t\t   LAN966X_VCAP_IPV4_EV_PTP_TRAP, ETH_P_IP);\n\tif (err)\n\t\treturn err;\n\n\terr = lan966x_ptp_add_trap(port, lan966x_ptp_add_ip_general_key,\n\t\t\t\t   LAN966X_VCAP_IPV4_GEN_PTP_TRAP, ETH_P_IP);\n\tif (err)\n\t\tlan966x_ptp_del_trap(port, LAN966X_VCAP_IPV4_EV_PTP_TRAP);\n\n\treturn err;\n}\n\nstatic int lan966x_ptp_add_ipv6_rules(struct lan966x_port *port)\n{\n\tint err;\n\n\terr = lan966x_ptp_add_trap(port, lan966x_ptp_add_ip_event_key,\n\t\t\t\t   LAN966X_VCAP_IPV6_EV_PTP_TRAP, ETH_P_IPV6);\n\tif (err)\n\t\treturn err;\n\n\terr = lan966x_ptp_add_trap(port, lan966x_ptp_add_ip_general_key,\n\t\t\t\t   LAN966X_VCAP_IPV6_GEN_PTP_TRAP, ETH_P_IPV6);\n\tif (err)\n\t\tlan966x_ptp_del_trap(port, LAN966X_VCAP_IPV6_EV_PTP_TRAP);\n\n\treturn err;\n}\n\nstatic int lan966x_ptp_del_l2_rule(struct lan966x_port *port)\n{\n\treturn lan966x_ptp_del_trap(port, LAN966X_VCAP_L2_PTP_TRAP);\n}\n\nstatic int lan966x_ptp_del_ipv4_rules(struct lan966x_port *port)\n{\n\tint err;\n\n\terr = lan966x_ptp_del_trap(port, LAN966X_VCAP_IPV4_EV_PTP_TRAP);\n\terr |= lan966x_ptp_del_trap(port, LAN966X_VCAP_IPV4_GEN_PTP_TRAP);\n\n\treturn err;\n}\n\nstatic int lan966x_ptp_del_ipv6_rules(struct lan966x_port *port)\n{\n\tint err;\n\n\terr = lan966x_ptp_del_trap(port, LAN966X_VCAP_IPV6_EV_PTP_TRAP);\n\terr |= lan966x_ptp_del_trap(port, LAN966X_VCAP_IPV6_GEN_PTP_TRAP);\n\n\treturn err;\n}\n\nstatic int lan966x_ptp_add_traps(struct lan966x_port *port)\n{\n\tint err;\n\n\terr = lan966x_ptp_add_l2_rule(port);\n\tif (err)\n\t\tgoto err_l2;\n\n\terr = lan966x_ptp_add_ipv4_rules(port);\n\tif (err)\n\t\tgoto err_ipv4;\n\n\terr = lan966x_ptp_add_ipv6_rules(port);\n\tif (err)\n\t\tgoto err_ipv6;\n\n\treturn err;\n\nerr_ipv6:\n\tlan966x_ptp_del_ipv4_rules(port);\nerr_ipv4:\n\tlan966x_ptp_del_l2_rule(port);\nerr_l2:\n\treturn err;\n}\n\nint lan966x_ptp_del_traps(struct lan966x_port *port)\n{\n\tint err;\n\n\terr = lan966x_ptp_del_l2_rule(port);\n\terr |= lan966x_ptp_del_ipv4_rules(port);\n\terr |= lan966x_ptp_del_ipv6_rules(port);\n\n\treturn err;\n}\n\nint lan966x_ptp_setup_traps(struct lan966x_port *port,\n\t\t\t    struct kernel_hwtstamp_config *cfg)\n{\n\tif (cfg->rx_filter == HWTSTAMP_FILTER_NONE)\n\t\treturn lan966x_ptp_del_traps(port);\n\telse\n\t\treturn lan966x_ptp_add_traps(port);\n}\n\nint lan966x_ptp_hwtstamp_set(struct lan966x_port *port,\n\t\t\t     struct kernel_hwtstamp_config *cfg,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct lan966x *lan966x = port->lan966x;\n\tstruct lan966x_phc *phc;\n\n\tswitch (cfg->tx_type) {\n\tcase HWTSTAMP_TX_ON:\n\t\tport->ptp_tx_cmd = IFH_REW_OP_TWO_STEP_PTP;\n\t\tbreak;\n\tcase HWTSTAMP_TX_ONESTEP_SYNC:\n\t\tport->ptp_tx_cmd = IFH_REW_OP_ONE_STEP_PTP;\n\t\tbreak;\n\tcase HWTSTAMP_TX_OFF:\n\t\tport->ptp_tx_cmd = IFH_REW_OP_NOOP;\n\t\tbreak;\n\tdefault:\n\t\treturn -ERANGE;\n\t}\n\n\tswitch (cfg->rx_filter) {\n\tcase HWTSTAMP_FILTER_NONE:\n\t\tport->ptp_rx_cmd = false;\n\t\tbreak;\n\tcase HWTSTAMP_FILTER_ALL:\n\tcase HWTSTAMP_FILTER_PTP_V1_L4_EVENT:\n\tcase HWTSTAMP_FILTER_PTP_V1_L4_SYNC:\n\tcase HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ:\n\tcase HWTSTAMP_FILTER_PTP_V2_L4_EVENT:\n\tcase HWTSTAMP_FILTER_PTP_V2_L4_SYNC:\n\tcase HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ:\n\tcase HWTSTAMP_FILTER_PTP_V2_L2_EVENT:\n\tcase HWTSTAMP_FILTER_PTP_V2_L2_SYNC:\n\tcase HWTSTAMP_FILTER_PTP_V2_L2_DELAY_REQ:\n\tcase HWTSTAMP_FILTER_PTP_V2_EVENT:\n\tcase HWTSTAMP_FILTER_PTP_V2_SYNC:\n\tcase HWTSTAMP_FILTER_PTP_V2_DELAY_REQ:\n\tcase HWTSTAMP_FILTER_NTP_ALL:\n\t\tport->ptp_rx_cmd = true;\n\t\tcfg->rx_filter = HWTSTAMP_FILTER_ALL;\n\t\tbreak;\n\tdefault:\n\t\treturn -ERANGE;\n\t}\n\n\t \n\tmutex_lock(&lan966x->ptp_lock);\n\tphc = &lan966x->phc[LAN966X_PHC_PORT];\n\tphc->hwtstamp_config = *cfg;\n\tmutex_unlock(&lan966x->ptp_lock);\n\n\treturn 0;\n}\n\nvoid lan966x_ptp_hwtstamp_get(struct lan966x_port *port,\n\t\t\t      struct kernel_hwtstamp_config *cfg)\n{\n\tstruct lan966x *lan966x = port->lan966x;\n\tstruct lan966x_phc *phc;\n\n\tphc = &lan966x->phc[LAN966X_PHC_PORT];\n\t*cfg = phc->hwtstamp_config;\n}\n\nstatic int lan966x_ptp_classify(struct lan966x_port *port, struct sk_buff *skb)\n{\n\tstruct ptp_header *header;\n\tu8 msgtype;\n\tint type;\n\n\tif (port->ptp_tx_cmd == IFH_REW_OP_NOOP)\n\t\treturn IFH_REW_OP_NOOP;\n\n\ttype = ptp_classify_raw(skb);\n\tif (type == PTP_CLASS_NONE)\n\t\treturn IFH_REW_OP_NOOP;\n\n\theader = ptp_parse_header(skb, type);\n\tif (!header)\n\t\treturn IFH_REW_OP_NOOP;\n\n\tif (port->ptp_tx_cmd == IFH_REW_OP_TWO_STEP_PTP)\n\t\treturn IFH_REW_OP_TWO_STEP_PTP;\n\n\t \n\tmsgtype = ptp_get_msgtype(header, type);\n\tif ((msgtype & 0xf) == 0)\n\t\treturn IFH_REW_OP_ONE_STEP_PTP;\n\n\treturn IFH_REW_OP_TWO_STEP_PTP;\n}\n\nstatic void lan966x_ptp_txtstamp_old_release(struct lan966x_port *port)\n{\n\tstruct sk_buff *skb, *skb_tmp;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&port->tx_skbs.lock, flags);\n\tskb_queue_walk_safe(&port->tx_skbs, skb, skb_tmp) {\n\t\tif time_after(LAN966X_SKB_CB(skb)->jiffies + LAN966X_PTP_TIMEOUT,\n\t\t\t      jiffies)\n\t\t\tbreak;\n\n\t\t__skb_unlink(skb, &port->tx_skbs);\n\t\tdev_kfree_skb_any(skb);\n\t}\n\tspin_unlock_irqrestore(&port->tx_skbs.lock, flags);\n}\n\nint lan966x_ptp_txtstamp_request(struct lan966x_port *port,\n\t\t\t\t struct sk_buff *skb)\n{\n\tstruct lan966x *lan966x = port->lan966x;\n\tunsigned long flags;\n\tu8 rew_op;\n\n\trew_op = lan966x_ptp_classify(port, skb);\n\tLAN966X_SKB_CB(skb)->rew_op = rew_op;\n\n\tif (rew_op != IFH_REW_OP_TWO_STEP_PTP)\n\t\treturn 0;\n\n\tlan966x_ptp_txtstamp_old_release(port);\n\n\tspin_lock_irqsave(&lan966x->ptp_ts_id_lock, flags);\n\tif (lan966x->ptp_skbs == LAN966X_MAX_PTP_ID) {\n\t\tspin_unlock_irqrestore(&lan966x->ptp_ts_id_lock, flags);\n\t\treturn -EBUSY;\n\t}\n\n\tskb_shinfo(skb)->tx_flags |= SKBTX_IN_PROGRESS;\n\n\tskb_queue_tail(&port->tx_skbs, skb);\n\tLAN966X_SKB_CB(skb)->ts_id = port->ts_id;\n\tLAN966X_SKB_CB(skb)->jiffies = jiffies;\n\n\tlan966x->ptp_skbs++;\n\tport->ts_id++;\n\tif (port->ts_id == LAN966X_MAX_PTP_ID)\n\t\tport->ts_id = 0;\n\n\tspin_unlock_irqrestore(&lan966x->ptp_ts_id_lock, flags);\n\n\treturn 0;\n}\n\nvoid lan966x_ptp_txtstamp_release(struct lan966x_port *port,\n\t\t\t\t  struct sk_buff *skb)\n{\n\tstruct lan966x *lan966x = port->lan966x;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&lan966x->ptp_ts_id_lock, flags);\n\tport->ts_id--;\n\tlan966x->ptp_skbs--;\n\tskb_unlink(skb, &port->tx_skbs);\n\tspin_unlock_irqrestore(&lan966x->ptp_ts_id_lock, flags);\n}\n\nstatic void lan966x_get_hwtimestamp(struct lan966x *lan966x,\n\t\t\t\t    struct timespec64 *ts,\n\t\t\t\t    u32 nsec)\n{\n\t \n\tunsigned long flags;\n\tu32 curr_nsec;\n\n\tspin_lock_irqsave(&lan966x->ptp_clock_lock, flags);\n\n\tlan_rmw(PTP_PIN_CFG_PIN_ACTION_SET(PTP_PIN_ACTION_SAVE) |\n\t\tPTP_PIN_CFG_PIN_DOM_SET(LAN966X_PHC_PORT) |\n\t\tPTP_PIN_CFG_PIN_SYNC_SET(0),\n\t\tPTP_PIN_CFG_PIN_ACTION |\n\t\tPTP_PIN_CFG_PIN_DOM |\n\t\tPTP_PIN_CFG_PIN_SYNC,\n\t\tlan966x, PTP_PIN_CFG(TOD_ACC_PIN));\n\n\tts->tv_sec = lan_rd(lan966x, PTP_TOD_SEC_LSB(TOD_ACC_PIN));\n\tcurr_nsec = lan_rd(lan966x, PTP_TOD_NSEC(TOD_ACC_PIN));\n\n\tts->tv_nsec = nsec;\n\n\t \n\tif (curr_nsec < nsec)\n\t\tts->tv_sec--;\n\n\tspin_unlock_irqrestore(&lan966x->ptp_clock_lock, flags);\n}\n\nirqreturn_t lan966x_ptp_irq_handler(int irq, void *args)\n{\n\tint budget = LAN966X_MAX_PTP_ID;\n\tstruct lan966x *lan966x = args;\n\n\twhile (budget--) {\n\t\tstruct sk_buff *skb, *skb_tmp, *skb_match = NULL;\n\t\tstruct skb_shared_hwtstamps shhwtstamps;\n\t\tstruct lan966x_port *port;\n\t\tstruct timespec64 ts;\n\t\tunsigned long flags;\n\t\tu32 val, id, txport;\n\t\tu32 delay;\n\n\t\tval = lan_rd(lan966x, PTP_TWOSTEP_CTRL);\n\n\t\t \n\t\tif (!(val & PTP_TWOSTEP_CTRL_VLD))\n\t\t\tbreak;\n\n\t\tWARN_ON(val & PTP_TWOSTEP_CTRL_OVFL);\n\n\t\tif (!(val & PTP_TWOSTEP_CTRL_STAMP_TX))\n\t\t\tcontinue;\n\n\t\t \n\t\ttxport = PTP_TWOSTEP_CTRL_STAMP_PORT_GET(val);\n\n\t\t \n\t\tport = lan966x->ports[txport];\n\n\t\t \n\t\tdelay = lan_rd(lan966x, PTP_TWOSTEP_STAMP);\n\t\tdelay = PTP_TWOSTEP_STAMP_STAMP_NSEC_GET(delay);\n\n\t\t \n\t\tlan_rmw(PTP_TWOSTEP_CTRL_NXT_SET(1),\n\t\t\tPTP_TWOSTEP_CTRL_NXT,\n\t\t\tlan966x, PTP_TWOSTEP_CTRL);\n\n\t\tval = lan_rd(lan966x, PTP_TWOSTEP_CTRL);\n\n\t\t \n\t\tif (!(val & PTP_TWOSTEP_CTRL_VLD))\n\t\t\tbreak;\n\n\t\t \n\t\tid = lan_rd(lan966x, PTP_TWOSTEP_STAMP);\n\n\t\tspin_lock_irqsave(&port->tx_skbs.lock, flags);\n\t\tskb_queue_walk_safe(&port->tx_skbs, skb, skb_tmp) {\n\t\t\tif (LAN966X_SKB_CB(skb)->ts_id != id)\n\t\t\t\tcontinue;\n\n\t\t\t__skb_unlink(skb, &port->tx_skbs);\n\t\t\tskb_match = skb;\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock_irqrestore(&port->tx_skbs.lock, flags);\n\n\t\t \n\t\tlan_rmw(PTP_TWOSTEP_CTRL_NXT_SET(1),\n\t\t\tPTP_TWOSTEP_CTRL_NXT,\n\t\t\tlan966x, PTP_TWOSTEP_CTRL);\n\n\t\tif (WARN_ON(!skb_match))\n\t\t\tcontinue;\n\n\t\tspin_lock_irqsave(&lan966x->ptp_ts_id_lock, flags);\n\t\tlan966x->ptp_skbs--;\n\t\tspin_unlock_irqrestore(&lan966x->ptp_ts_id_lock, flags);\n\n\t\t \n\t\tlan966x_get_hwtimestamp(lan966x, &ts, delay);\n\n\t\t \n\t\tshhwtstamps.hwtstamp = ktime_set(ts.tv_sec, ts.tv_nsec);\n\t\tskb_tstamp_tx(skb_match, &shhwtstamps);\n\n\t\tdev_kfree_skb_any(skb_match);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nirqreturn_t lan966x_ptp_ext_irq_handler(int irq, void *args)\n{\n\tstruct lan966x *lan966x = args;\n\tstruct lan966x_phc *phc;\n\tunsigned long flags;\n\tu64 time = 0;\n\ttime64_t s;\n\tint pin, i;\n\ts64 ns;\n\n\tif (!(lan_rd(lan966x, PTP_PIN_INTR)))\n\t\treturn IRQ_NONE;\n\n\t \n\tfor (i = 0; i < LAN966X_PHC_COUNT; ++i) {\n\t\tstruct ptp_clock_event ptp_event = {0};\n\n\t\tphc = &lan966x->phc[i];\n\t\tpin = ptp_find_pin_unlocked(phc->clock, PTP_PF_EXTTS, 0);\n\t\tif (pin == -1)\n\t\t\tcontinue;\n\n\t\tif (!(lan_rd(lan966x, PTP_PIN_INTR) & BIT(pin)))\n\t\t\tcontinue;\n\n\t\tspin_lock_irqsave(&lan966x->ptp_clock_lock, flags);\n\n\t\t \n\t\tlan_wr(BIT(pin), lan966x, PTP_PIN_INTR);\n\n\t\t \n\t\ts = lan_rd(lan966x, PTP_TOD_SEC_MSB(pin));\n\t\ts <<= 32;\n\t\ts |= lan_rd(lan966x, PTP_TOD_SEC_LSB(pin));\n\t\tns = lan_rd(lan966x, PTP_TOD_NSEC(pin));\n\t\tns &= PTP_TOD_NSEC_TOD_NSEC;\n\n\t\tspin_unlock_irqrestore(&lan966x->ptp_clock_lock, flags);\n\n\t\tif ((ns & 0xFFFFFFF0) == 0x3FFFFFF0) {\n\t\t\ts--;\n\t\t\tns &= 0xf;\n\t\t\tns += 999999984;\n\t\t}\n\t\ttime = ktime_set(s, ns);\n\n\t\tptp_event.index = pin;\n\t\tptp_event.timestamp = time;\n\t\tptp_event.type = PTP_CLOCK_EXTTS;\n\t\tptp_clock_event(phc->clock, &ptp_event);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int lan966x_ptp_adjfine(struct ptp_clock_info *ptp, long scaled_ppm)\n{\n\tstruct lan966x_phc *phc = container_of(ptp, struct lan966x_phc, info);\n\tstruct lan966x *lan966x = phc->lan966x;\n\tunsigned long flags;\n\tbool neg_adj = 0;\n\tu64 tod_inc;\n\tu64 ref;\n\n\tif (!scaled_ppm)\n\t\treturn 0;\n\n\tif (scaled_ppm < 0) {\n\t\tneg_adj = 1;\n\t\tscaled_ppm = -scaled_ppm;\n\t}\n\n\ttod_inc = lan966x_ptp_get_nominal_value();\n\n\t \n\tref = LAN966X_1PPM_FORMAT * (scaled_ppm >> 16);\n\tref += (LAN966X_1PPM_FORMAT * (0xffff & scaled_ppm)) >> 16;\n\ttod_inc = neg_adj ? tod_inc - ref : tod_inc + ref;\n\n\tspin_lock_irqsave(&lan966x->ptp_clock_lock, flags);\n\n\tlan_rmw(PTP_DOM_CFG_CLKCFG_DIS_SET(1 << BIT(phc->index)),\n\t\tPTP_DOM_CFG_CLKCFG_DIS,\n\t\tlan966x, PTP_DOM_CFG);\n\n\tlan_wr((u32)tod_inc & 0xFFFFFFFF, lan966x,\n\t       PTP_CLK_PER_CFG(phc->index, 0));\n\tlan_wr((u32)(tod_inc >> 32), lan966x,\n\t       PTP_CLK_PER_CFG(phc->index, 1));\n\n\tlan_rmw(PTP_DOM_CFG_CLKCFG_DIS_SET(0),\n\t\tPTP_DOM_CFG_CLKCFG_DIS,\n\t\tlan966x, PTP_DOM_CFG);\n\n\tspin_unlock_irqrestore(&lan966x->ptp_clock_lock, flags);\n\n\treturn 0;\n}\n\nstatic int lan966x_ptp_settime64(struct ptp_clock_info *ptp,\n\t\t\t\t const struct timespec64 *ts)\n{\n\tstruct lan966x_phc *phc = container_of(ptp, struct lan966x_phc, info);\n\tstruct lan966x *lan966x = phc->lan966x;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&lan966x->ptp_clock_lock, flags);\n\n\t \n\tlan_rmw(PTP_PIN_CFG_PIN_ACTION_SET(PTP_PIN_ACTION_IDLE) |\n\t\tPTP_PIN_CFG_PIN_DOM_SET(phc->index) |\n\t\tPTP_PIN_CFG_PIN_SYNC_SET(0),\n\t\tPTP_PIN_CFG_PIN_ACTION |\n\t\tPTP_PIN_CFG_PIN_DOM |\n\t\tPTP_PIN_CFG_PIN_SYNC,\n\t\tlan966x, PTP_PIN_CFG(TOD_ACC_PIN));\n\n\t \n\tlan_wr(PTP_TOD_SEC_MSB_TOD_SEC_MSB_SET(upper_32_bits(ts->tv_sec)),\n\t       lan966x, PTP_TOD_SEC_MSB(TOD_ACC_PIN));\n\tlan_wr(lower_32_bits(ts->tv_sec),\n\t       lan966x, PTP_TOD_SEC_LSB(TOD_ACC_PIN));\n\tlan_wr(ts->tv_nsec, lan966x, PTP_TOD_NSEC(TOD_ACC_PIN));\n\n\t \n\tlan_rmw(PTP_PIN_CFG_PIN_ACTION_SET(PTP_PIN_ACTION_LOAD) |\n\t\tPTP_PIN_CFG_PIN_DOM_SET(phc->index) |\n\t\tPTP_PIN_CFG_PIN_SYNC_SET(0),\n\t\tPTP_PIN_CFG_PIN_ACTION |\n\t\tPTP_PIN_CFG_PIN_DOM |\n\t\tPTP_PIN_CFG_PIN_SYNC,\n\t\tlan966x, PTP_PIN_CFG(TOD_ACC_PIN));\n\n\tspin_unlock_irqrestore(&lan966x->ptp_clock_lock, flags);\n\n\treturn 0;\n}\n\nint lan966x_ptp_gettime64(struct ptp_clock_info *ptp, struct timespec64 *ts)\n{\n\tstruct lan966x_phc *phc = container_of(ptp, struct lan966x_phc, info);\n\tstruct lan966x *lan966x = phc->lan966x;\n\tunsigned long flags;\n\ttime64_t s;\n\ts64 ns;\n\n\tspin_lock_irqsave(&lan966x->ptp_clock_lock, flags);\n\n\tlan_rmw(PTP_PIN_CFG_PIN_ACTION_SET(PTP_PIN_ACTION_SAVE) |\n\t\tPTP_PIN_CFG_PIN_DOM_SET(phc->index) |\n\t\tPTP_PIN_CFG_PIN_SYNC_SET(0),\n\t\tPTP_PIN_CFG_PIN_ACTION |\n\t\tPTP_PIN_CFG_PIN_DOM |\n\t\tPTP_PIN_CFG_PIN_SYNC,\n\t\tlan966x, PTP_PIN_CFG(TOD_ACC_PIN));\n\n\ts = lan_rd(lan966x, PTP_TOD_SEC_MSB(TOD_ACC_PIN));\n\ts <<= 32;\n\ts |= lan_rd(lan966x, PTP_TOD_SEC_LSB(TOD_ACC_PIN));\n\tns = lan_rd(lan966x, PTP_TOD_NSEC(TOD_ACC_PIN));\n\tns &= PTP_TOD_NSEC_TOD_NSEC;\n\n\tspin_unlock_irqrestore(&lan966x->ptp_clock_lock, flags);\n\n\t \n\tif ((ns & 0xFFFFFFF0) == 0x3FFFFFF0) {\n\t\ts--;\n\t\tns &= 0xf;\n\t\tns += 999999984;\n\t}\n\n\tset_normalized_timespec64(ts, s, ns);\n\treturn 0;\n}\n\nstatic int lan966x_ptp_adjtime(struct ptp_clock_info *ptp, s64 delta)\n{\n\tstruct lan966x_phc *phc = container_of(ptp, struct lan966x_phc, info);\n\tstruct lan966x *lan966x = phc->lan966x;\n\n\tif (delta > -(NSEC_PER_SEC / 2) && delta < (NSEC_PER_SEC / 2)) {\n\t\tunsigned long flags;\n\n\t\tspin_lock_irqsave(&lan966x->ptp_clock_lock, flags);\n\n\t\t \n\t\tlan_rmw(PTP_PIN_CFG_PIN_ACTION_SET(PTP_PIN_ACTION_IDLE) |\n\t\t\tPTP_PIN_CFG_PIN_DOM_SET(phc->index) |\n\t\t\tPTP_PIN_CFG_PIN_SYNC_SET(0),\n\t\t\tPTP_PIN_CFG_PIN_ACTION |\n\t\t\tPTP_PIN_CFG_PIN_DOM |\n\t\t\tPTP_PIN_CFG_PIN_SYNC,\n\t\t\tlan966x, PTP_PIN_CFG(TOD_ACC_PIN));\n\n\t\tlan_wr(PTP_TOD_NSEC_TOD_NSEC_SET(delta),\n\t\t       lan966x, PTP_TOD_NSEC(TOD_ACC_PIN));\n\n\t\t \n\t\tlan_rmw(PTP_PIN_CFG_PIN_ACTION_SET(PTP_PIN_ACTION_DELTA) |\n\t\t\tPTP_PIN_CFG_PIN_DOM_SET(phc->index) |\n\t\t\tPTP_PIN_CFG_PIN_SYNC_SET(0),\n\t\t\tPTP_PIN_CFG_PIN_ACTION |\n\t\t\tPTP_PIN_CFG_PIN_DOM |\n\t\t\tPTP_PIN_CFG_PIN_SYNC,\n\t\t\tlan966x, PTP_PIN_CFG(TOD_ACC_PIN));\n\n\t\tspin_unlock_irqrestore(&lan966x->ptp_clock_lock, flags);\n\t} else {\n\t\t \n\t\tstruct timespec64 ts;\n\t\tu64 now;\n\n\t\tlan966x_ptp_gettime64(ptp, &ts);\n\n\t\tnow = ktime_to_ns(timespec64_to_ktime(ts));\n\t\tts = ns_to_timespec64(now + delta);\n\n\t\tlan966x_ptp_settime64(ptp, &ts);\n\t}\n\n\treturn 0;\n}\n\nstatic int lan966x_ptp_verify(struct ptp_clock_info *ptp, unsigned int pin,\n\t\t\t      enum ptp_pin_function func, unsigned int chan)\n{\n\tstruct lan966x_phc *phc = container_of(ptp, struct lan966x_phc, info);\n\tstruct lan966x *lan966x = phc->lan966x;\n\tstruct ptp_clock_info *info;\n\tint i;\n\n\t \n\tif (chan != 0)\n\t\treturn -1;\n\n\tswitch (func) {\n\tcase PTP_PF_NONE:\n\tcase PTP_PF_PEROUT:\n\tcase PTP_PF_EXTTS:\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\n\t \n\tfor (i = 0; i < LAN966X_PHC_COUNT; ++i) {\n\t\tinfo = &lan966x->phc[i].info;\n\n\t\t \n\t\tif (ptp == info)\n\t\t\tcontinue;\n\n\t\tif (info->pin_config[pin].func == PTP_PF_PEROUT ||\n\t\t    info->pin_config[pin].func == PTP_PF_EXTTS)\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int lan966x_ptp_perout(struct ptp_clock_info *ptp,\n\t\t\t      struct ptp_clock_request *rq, int on)\n{\n\tstruct lan966x_phc *phc = container_of(ptp, struct lan966x_phc, info);\n\tstruct lan966x *lan966x = phc->lan966x;\n\tstruct timespec64 ts_phase, ts_period;\n\tunsigned long flags;\n\ts64 wf_high, wf_low;\n\tbool pps = false;\n\tint pin;\n\n\tif (rq->perout.flags & ~(PTP_PEROUT_DUTY_CYCLE |\n\t\t\t\t PTP_PEROUT_PHASE))\n\t\treturn -EOPNOTSUPP;\n\n\tpin = ptp_find_pin(phc->clock, PTP_PF_PEROUT, rq->perout.index);\n\tif (pin == -1 || pin >= LAN966X_PHC_PINS_NUM)\n\t\treturn -EINVAL;\n\n\tif (!on) {\n\t\tspin_lock_irqsave(&lan966x->ptp_clock_lock, flags);\n\t\tlan_rmw(PTP_PIN_CFG_PIN_ACTION_SET(PTP_PIN_ACTION_IDLE) |\n\t\t\tPTP_PIN_CFG_PIN_DOM_SET(phc->index) |\n\t\t\tPTP_PIN_CFG_PIN_SYNC_SET(0),\n\t\t\tPTP_PIN_CFG_PIN_ACTION |\n\t\t\tPTP_PIN_CFG_PIN_DOM |\n\t\t\tPTP_PIN_CFG_PIN_SYNC,\n\t\t\tlan966x, PTP_PIN_CFG(pin));\n\t\tspin_unlock_irqrestore(&lan966x->ptp_clock_lock, flags);\n\t\treturn 0;\n\t}\n\n\tif (rq->perout.period.sec == 1 &&\n\t    rq->perout.period.nsec == 0)\n\t\tpps = true;\n\n\tif (rq->perout.flags & PTP_PEROUT_PHASE) {\n\t\tts_phase.tv_sec = rq->perout.phase.sec;\n\t\tts_phase.tv_nsec = rq->perout.phase.nsec;\n\t} else {\n\t\tts_phase.tv_sec = rq->perout.start.sec;\n\t\tts_phase.tv_nsec = rq->perout.start.nsec;\n\t}\n\n\tif (ts_phase.tv_sec || (ts_phase.tv_nsec && !pps)) {\n\t\tdev_warn(lan966x->dev,\n\t\t\t \"Absolute time not supported!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (rq->perout.flags & PTP_PEROUT_DUTY_CYCLE) {\n\t\tstruct timespec64 ts_on;\n\n\t\tts_on.tv_sec = rq->perout.on.sec;\n\t\tts_on.tv_nsec = rq->perout.on.nsec;\n\n\t\twf_high = timespec64_to_ns(&ts_on);\n\t} else {\n\t\twf_high = 5000;\n\t}\n\n\tif (pps) {\n\t\tspin_lock_irqsave(&lan966x->ptp_clock_lock, flags);\n\t\tlan_wr(PTP_WF_LOW_PERIOD_PIN_WFL(ts_phase.tv_nsec),\n\t\t       lan966x, PTP_WF_LOW_PERIOD(pin));\n\t\tlan_wr(PTP_WF_HIGH_PERIOD_PIN_WFH(wf_high),\n\t\t       lan966x, PTP_WF_HIGH_PERIOD(pin));\n\t\tlan_rmw(PTP_PIN_CFG_PIN_ACTION_SET(PTP_PIN_ACTION_CLOCK) |\n\t\t\tPTP_PIN_CFG_PIN_DOM_SET(phc->index) |\n\t\t\tPTP_PIN_CFG_PIN_SYNC_SET(3),\n\t\t\tPTP_PIN_CFG_PIN_ACTION |\n\t\t\tPTP_PIN_CFG_PIN_DOM |\n\t\t\tPTP_PIN_CFG_PIN_SYNC,\n\t\t\tlan966x, PTP_PIN_CFG(pin));\n\t\tspin_unlock_irqrestore(&lan966x->ptp_clock_lock, flags);\n\t\treturn 0;\n\t}\n\n\tts_period.tv_sec = rq->perout.period.sec;\n\tts_period.tv_nsec = rq->perout.period.nsec;\n\n\twf_low = timespec64_to_ns(&ts_period);\n\twf_low -= wf_high;\n\n\tspin_lock_irqsave(&lan966x->ptp_clock_lock, flags);\n\tlan_wr(PTP_WF_LOW_PERIOD_PIN_WFL(wf_low),\n\t       lan966x, PTP_WF_LOW_PERIOD(pin));\n\tlan_wr(PTP_WF_HIGH_PERIOD_PIN_WFH(wf_high),\n\t       lan966x, PTP_WF_HIGH_PERIOD(pin));\n\tlan_rmw(PTP_PIN_CFG_PIN_ACTION_SET(PTP_PIN_ACTION_CLOCK) |\n\t\tPTP_PIN_CFG_PIN_DOM_SET(phc->index) |\n\t\tPTP_PIN_CFG_PIN_SYNC_SET(0),\n\t\tPTP_PIN_CFG_PIN_ACTION |\n\t\tPTP_PIN_CFG_PIN_DOM |\n\t\tPTP_PIN_CFG_PIN_SYNC,\n\t\tlan966x, PTP_PIN_CFG(pin));\n\tspin_unlock_irqrestore(&lan966x->ptp_clock_lock, flags);\n\n\treturn 0;\n}\n\nstatic int lan966x_ptp_extts(struct ptp_clock_info *ptp,\n\t\t\t     struct ptp_clock_request *rq, int on)\n{\n\tstruct lan966x_phc *phc = container_of(ptp, struct lan966x_phc, info);\n\tstruct lan966x *lan966x = phc->lan966x;\n\tunsigned long flags;\n\tint pin;\n\tu32 val;\n\n\tif (lan966x->ptp_ext_irq <= 0)\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tif (rq->extts.flags & ~(PTP_ENABLE_FEATURE |\n\t\t\t\tPTP_RISING_EDGE |\n\t\t\t\tPTP_STRICT_FLAGS))\n\t\treturn -EOPNOTSUPP;\n\n\tpin = ptp_find_pin(phc->clock, PTP_PF_EXTTS, rq->extts.index);\n\tif (pin == -1 || pin >= LAN966X_PHC_PINS_NUM)\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&lan966x->ptp_clock_lock, flags);\n\tlan_rmw(PTP_PIN_CFG_PIN_ACTION_SET(PTP_PIN_ACTION_SAVE) |\n\t\tPTP_PIN_CFG_PIN_SYNC_SET(on ? 3 : 0) |\n\t\tPTP_PIN_CFG_PIN_DOM_SET(phc->index) |\n\t\tPTP_PIN_CFG_PIN_SELECT_SET(pin),\n\t\tPTP_PIN_CFG_PIN_ACTION |\n\t\tPTP_PIN_CFG_PIN_SYNC |\n\t\tPTP_PIN_CFG_PIN_DOM |\n\t\tPTP_PIN_CFG_PIN_SELECT,\n\t\tlan966x, PTP_PIN_CFG(pin));\n\n\tval = lan_rd(lan966x, PTP_PIN_INTR_ENA);\n\tif (on)\n\t\tval |= BIT(pin);\n\telse\n\t\tval &= ~BIT(pin);\n\tlan_wr(val, lan966x, PTP_PIN_INTR_ENA);\n\n\tspin_unlock_irqrestore(&lan966x->ptp_clock_lock, flags);\n\n\treturn 0;\n}\n\nstatic int lan966x_ptp_enable(struct ptp_clock_info *ptp,\n\t\t\t      struct ptp_clock_request *rq, int on)\n{\n\tswitch (rq->type) {\n\tcase PTP_CLK_REQ_PEROUT:\n\t\treturn lan966x_ptp_perout(ptp, rq, on);\n\tcase PTP_CLK_REQ_EXTTS:\n\t\treturn lan966x_ptp_extts(ptp, rq, on);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic struct ptp_clock_info lan966x_ptp_clock_info = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"lan966x ptp\",\n\t.max_adj\t= 200000,\n\t.gettime64\t= lan966x_ptp_gettime64,\n\t.settime64\t= lan966x_ptp_settime64,\n\t.adjtime\t= lan966x_ptp_adjtime,\n\t.adjfine\t= lan966x_ptp_adjfine,\n\t.verify\t\t= lan966x_ptp_verify,\n\t.enable\t\t= lan966x_ptp_enable,\n\t.n_per_out\t= LAN966X_PHC_PINS_NUM,\n\t.n_ext_ts\t= LAN966X_PHC_PINS_NUM,\n\t.n_pins\t\t= LAN966X_PHC_PINS_NUM,\n};\n\nstatic int lan966x_ptp_phc_init(struct lan966x *lan966x,\n\t\t\t\tint index,\n\t\t\t\tstruct ptp_clock_info *clock_info)\n{\n\tstruct lan966x_phc *phc = &lan966x->phc[index];\n\tstruct ptp_pin_desc *p;\n\tint i;\n\n\tfor (i = 0; i < LAN966X_PHC_PINS_NUM; i++) {\n\t\tp = &phc->pins[i];\n\n\t\tsnprintf(p->name, sizeof(p->name), \"pin%d\", i);\n\t\tp->index = i;\n\t\tp->func = PTP_PF_NONE;\n\t}\n\n\tphc->info = *clock_info;\n\tphc->info.pin_config = &phc->pins[0];\n\tphc->clock = ptp_clock_register(&phc->info, lan966x->dev);\n\tif (IS_ERR(phc->clock))\n\t\treturn PTR_ERR(phc->clock);\n\n\tphc->index = index;\n\tphc->lan966x = lan966x;\n\n\treturn 0;\n}\n\nint lan966x_ptp_init(struct lan966x *lan966x)\n{\n\tu64 tod_adj = lan966x_ptp_get_nominal_value();\n\tstruct lan966x_port *port;\n\tint err, i;\n\n\tif (!lan966x->ptp)\n\t\treturn 0;\n\n\tfor (i = 0; i < LAN966X_PHC_COUNT; ++i) {\n\t\terr = lan966x_ptp_phc_init(lan966x, i, &lan966x_ptp_clock_info);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tspin_lock_init(&lan966x->ptp_clock_lock);\n\tspin_lock_init(&lan966x->ptp_ts_id_lock);\n\tmutex_init(&lan966x->ptp_lock);\n\n\t \n\tlan_wr(PTP_DOM_CFG_ENA_SET(0), lan966x, PTP_DOM_CFG);\n\n\t \n\tlan_rmw(PTP_DOM_CFG_CLKCFG_DIS_SET(0x7),\n\t\tPTP_DOM_CFG_CLKCFG_DIS,\n\t\tlan966x, PTP_DOM_CFG);\n\n\tfor (i = 0; i < LAN966X_PHC_COUNT; ++i) {\n\t\tlan_wr((u32)tod_adj & 0xFFFFFFFF, lan966x,\n\t\t       PTP_CLK_PER_CFG(i, 0));\n\t\tlan_wr((u32)(tod_adj >> 32), lan966x,\n\t\t       PTP_CLK_PER_CFG(i, 1));\n\t}\n\n\tlan_rmw(PTP_DOM_CFG_CLKCFG_DIS_SET(0),\n\t\tPTP_DOM_CFG_CLKCFG_DIS,\n\t\tlan966x, PTP_DOM_CFG);\n\n\t \n\tlan_wr(PTP_DOM_CFG_ENA_SET(0x7), lan966x, PTP_DOM_CFG);\n\n\tfor (i = 0; i < lan966x->num_phys_ports; i++) {\n\t\tport = lan966x->ports[i];\n\t\tif (!port)\n\t\t\tcontinue;\n\n\t\tskb_queue_head_init(&port->tx_skbs);\n\t}\n\n\treturn 0;\n}\n\nvoid lan966x_ptp_deinit(struct lan966x *lan966x)\n{\n\tstruct lan966x_port *port;\n\tint i;\n\n\tif (!lan966x->ptp)\n\t\treturn;\n\n\tfor (i = 0; i < lan966x->num_phys_ports; i++) {\n\t\tport = lan966x->ports[i];\n\t\tif (!port)\n\t\t\tcontinue;\n\n\t\tskb_queue_purge(&port->tx_skbs);\n\t}\n\n\tfor (i = 0; i < LAN966X_PHC_COUNT; ++i)\n\t\tptp_clock_unregister(lan966x->phc[i].clock);\n}\n\nvoid lan966x_ptp_rxtstamp(struct lan966x *lan966x, struct sk_buff *skb,\n\t\t\t  u64 src_port, u64 timestamp)\n{\n\tstruct skb_shared_hwtstamps *shhwtstamps;\n\tstruct lan966x_phc *phc;\n\tstruct timespec64 ts;\n\tu64 full_ts_in_ns;\n\n\tif (!lan966x->ptp ||\n\t    !lan966x->ports[src_port]->ptp_rx_cmd)\n\t\treturn;\n\n\tphc = &lan966x->phc[LAN966X_PHC_PORT];\n\tlan966x_ptp_gettime64(&phc->info, &ts);\n\n\t \n\ttimestamp = timestamp >> 2;\n\tif (ts.tv_nsec < timestamp)\n\t\tts.tv_sec--;\n\tts.tv_nsec = timestamp;\n\tfull_ts_in_ns = ktime_set(ts.tv_sec, ts.tv_nsec);\n\n\tshhwtstamps = skb_hwtstamps(skb);\n\tshhwtstamps->hwtstamp = full_ts_in_ns;\n}\n\nu32 lan966x_ptp_get_period_ps(void)\n{\n\t \n\treturn 15125;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}