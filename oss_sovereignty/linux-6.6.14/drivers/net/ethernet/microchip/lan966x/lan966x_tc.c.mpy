{
  "module_name": "lan966x_tc.c",
  "hash_id": "6a7a3b885f32678ad7cd9c7e7a5e47e5e77d696bd78687859b82ca577db6f55f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/microchip/lan966x/lan966x_tc.c",
  "human_readable_source": "\n\n#include <net/pkt_cls.h>\n#include <net/pkt_sched.h>\n\n#include \"lan966x_main.h\"\n\nstatic LIST_HEAD(lan966x_tc_block_cb_list);\n\nstatic int lan966x_tc_setup_qdisc_mqprio(struct lan966x_port *port,\n\t\t\t\t\t struct tc_mqprio_qopt_offload *mqprio)\n{\n\tu8 num_tc = mqprio->qopt.num_tc;\n\n\tmqprio->qopt.hw = TC_MQPRIO_HW_OFFLOAD_TCS;\n\n\treturn num_tc ? lan966x_mqprio_add(port, num_tc) :\n\t\t\tlan966x_mqprio_del(port);\n}\n\nstatic int lan966x_tc_setup_qdisc_taprio(struct lan966x_port *port,\n\t\t\t\t\t struct tc_taprio_qopt_offload *taprio)\n{\n\tswitch (taprio->cmd) {\n\tcase TAPRIO_CMD_REPLACE:\n\t\treturn lan966x_taprio_add(port, taprio);\n\tcase TAPRIO_CMD_DESTROY:\n\t\treturn lan966x_taprio_del(port);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int lan966x_tc_setup_qdisc_tbf(struct lan966x_port *port,\n\t\t\t\t      struct tc_tbf_qopt_offload *qopt)\n{\n\tswitch (qopt->command) {\n\tcase TC_TBF_REPLACE:\n\t\treturn lan966x_tbf_add(port, qopt);\n\tcase TC_TBF_DESTROY:\n\t\treturn lan966x_tbf_del(port, qopt);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic int lan966x_tc_setup_qdisc_cbs(struct lan966x_port *port,\n\t\t\t\t      struct tc_cbs_qopt_offload *qopt)\n{\n\treturn qopt->enable ? lan966x_cbs_add(port, qopt) :\n\t\t\t      lan966x_cbs_del(port, qopt);\n}\n\nstatic int lan966x_tc_setup_qdisc_ets(struct lan966x_port *port,\n\t\t\t\t      struct tc_ets_qopt_offload *qopt)\n{\n\tswitch (qopt->command) {\n\tcase TC_ETS_REPLACE:\n\t\treturn lan966x_ets_add(port, qopt);\n\tcase TC_ETS_DESTROY:\n\t\treturn lan966x_ets_del(port, qopt);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t};\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic int lan966x_tc_block_cb(enum tc_setup_type type, void *type_data,\n\t\t\t       void *cb_priv, bool ingress)\n{\n\tstruct lan966x_port *port = cb_priv;\n\n\tswitch (type) {\n\tcase TC_SETUP_CLSMATCHALL:\n\t\treturn lan966x_tc_matchall(port, type_data, ingress);\n\tcase TC_SETUP_CLSFLOWER:\n\t\treturn lan966x_tc_flower(port, type_data, ingress);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int lan966x_tc_block_cb_ingress(enum tc_setup_type type,\n\t\t\t\t       void *type_data, void *cb_priv)\n{\n\treturn lan966x_tc_block_cb(type, type_data, cb_priv, true);\n}\n\nstatic int lan966x_tc_block_cb_egress(enum tc_setup_type type,\n\t\t\t\t      void *type_data, void *cb_priv)\n{\n\treturn lan966x_tc_block_cb(type, type_data, cb_priv, false);\n}\n\nstatic int lan966x_tc_setup_block(struct lan966x_port *port,\n\t\t\t\t  struct flow_block_offload *f)\n{\n\tflow_setup_cb_t *cb;\n\tbool ingress;\n\n\tif (f->binder_type == FLOW_BLOCK_BINDER_TYPE_CLSACT_INGRESS) {\n\t\tcb = lan966x_tc_block_cb_ingress;\n\t\tport->tc.ingress_shared_block = f->block_shared;\n\t\tingress = true;\n\t} else if (f->binder_type == FLOW_BLOCK_BINDER_TYPE_CLSACT_EGRESS) {\n\t\tcb = lan966x_tc_block_cb_egress;\n\t\tingress = false;\n\t} else {\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn flow_block_cb_setup_simple(f, &lan966x_tc_block_cb_list,\n\t\t\t\t\t  cb, port, port, ingress);\n}\n\nint lan966x_tc_setup(struct net_device *dev, enum tc_setup_type type,\n\t\t     void *type_data)\n{\n\tstruct lan966x_port *port = netdev_priv(dev);\n\n\tswitch (type) {\n\tcase TC_SETUP_QDISC_MQPRIO:\n\t\treturn lan966x_tc_setup_qdisc_mqprio(port, type_data);\n\tcase TC_SETUP_QDISC_TAPRIO:\n\t\treturn lan966x_tc_setup_qdisc_taprio(port, type_data);\n\tcase TC_SETUP_QDISC_TBF:\n\t\treturn lan966x_tc_setup_qdisc_tbf(port, type_data);\n\tcase TC_SETUP_QDISC_CBS:\n\t\treturn lan966x_tc_setup_qdisc_cbs(port, type_data);\n\tcase TC_SETUP_QDISC_ETS:\n\t\treturn lan966x_tc_setup_qdisc_ets(port, type_data);\n\tcase TC_SETUP_BLOCK:\n\t\treturn lan966x_tc_setup_block(port, type_data);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}