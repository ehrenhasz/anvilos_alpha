{
  "module_name": "vcap_api.c",
  "hash_id": "81630cd1708094d6e0e3ce1bd71d6cf5733cfff0fb99de779e8882349bb7f69a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/microchip/vcap/vcap_api.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n\n#include \"vcap_api_private.h\"\n\nstatic int keyfield_size_table[] = {\n\t[VCAP_FIELD_BIT]  = sizeof(struct vcap_u1_key),\n\t[VCAP_FIELD_U32]  = sizeof(struct vcap_u32_key),\n\t[VCAP_FIELD_U48]  = sizeof(struct vcap_u48_key),\n\t[VCAP_FIELD_U56]  = sizeof(struct vcap_u56_key),\n\t[VCAP_FIELD_U64]  = sizeof(struct vcap_u64_key),\n\t[VCAP_FIELD_U72]  = sizeof(struct vcap_u72_key),\n\t[VCAP_FIELD_U112] = sizeof(struct vcap_u112_key),\n\t[VCAP_FIELD_U128] = sizeof(struct vcap_u128_key),\n};\n\nstatic int actionfield_size_table[] = {\n\t[VCAP_FIELD_BIT]  = sizeof(struct vcap_u1_action),\n\t[VCAP_FIELD_U32]  = sizeof(struct vcap_u32_action),\n\t[VCAP_FIELD_U48]  = sizeof(struct vcap_u48_action),\n\t[VCAP_FIELD_U56]  = sizeof(struct vcap_u56_action),\n\t[VCAP_FIELD_U64]  = sizeof(struct vcap_u64_action),\n\t[VCAP_FIELD_U72]  = sizeof(struct vcap_u72_action),\n\t[VCAP_FIELD_U112] = sizeof(struct vcap_u112_action),\n\t[VCAP_FIELD_U128] = sizeof(struct vcap_u128_action),\n};\n\n \nstruct vcap_rule_move {\n\tint addr;  \n\tint offset;  \n\tint count;  \n};\n\n \nstruct vcap_enabled_port {\n\tstruct list_head list;  \n\tstruct net_device *ndev;   \n\tunsigned long cookie;  \n\tint src_cid;  \n\tint dst_cid;  \n};\n\nvoid vcap_iter_set(struct vcap_stream_iter *itr, int sw_width,\n\t\t   const struct vcap_typegroup *tg, u32 offset)\n{\n\tmemset(itr, 0, sizeof(*itr));\n\titr->offset = offset;\n\titr->sw_width = sw_width;\n\titr->regs_per_sw = DIV_ROUND_UP(sw_width, 32);\n\titr->tg = tg;\n}\n\nstatic void vcap_iter_skip_tg(struct vcap_stream_iter *itr)\n{\n\t \n\twhile (itr->tg->width && itr->offset >= itr->tg->offset) {\n\t\titr->offset += itr->tg->width;\n\t\titr->tg++;  \n\t}\n}\n\nvoid vcap_iter_update(struct vcap_stream_iter *itr)\n{\n\tint sw_idx, sw_bitpos;\n\n\t \n\tsw_idx = itr->offset / itr->sw_width;\n\tsw_bitpos = itr->offset % itr->sw_width;\n\t \n\titr->reg_idx = (sw_idx * itr->regs_per_sw) + (sw_bitpos / 32);\n\titr->reg_bitpos = sw_bitpos % 32;\n}\n\nvoid vcap_iter_init(struct vcap_stream_iter *itr, int sw_width,\n\t\t    const struct vcap_typegroup *tg, u32 offset)\n{\n\tvcap_iter_set(itr, sw_width, tg, offset);\n\tvcap_iter_skip_tg(itr);\n\tvcap_iter_update(itr);\n}\n\nvoid vcap_iter_next(struct vcap_stream_iter *itr)\n{\n\titr->offset++;\n\tvcap_iter_skip_tg(itr);\n\tvcap_iter_update(itr);\n}\n\nstatic void vcap_set_bit(u32 *stream, struct vcap_stream_iter *itr, bool value)\n{\n\tu32 mask = BIT(itr->reg_bitpos);\n\tu32 *p = &stream[itr->reg_idx];\n\n\tif (value)\n\t\t*p |= mask;\n\telse\n\t\t*p &= ~mask;\n}\n\nstatic void vcap_encode_bit(u32 *stream, struct vcap_stream_iter *itr, bool val)\n{\n\t \n\twhile (itr->tg->width &&\n\t       itr->offset >= itr->tg->offset &&\n\t       itr->offset < itr->tg->offset + itr->tg->width) {\n\t\tint tg_bitpos = itr->tg->offset - itr->offset;\n\n\t\tvcap_set_bit(stream, itr, (itr->tg->value >> tg_bitpos) & 0x1);\n\t\titr->offset++;\n\t\tvcap_iter_update(itr);\n\t}\n\tvcap_set_bit(stream, itr, val);\n}\n\nstatic void vcap_encode_field(u32 *stream, struct vcap_stream_iter *itr,\n\t\t\t      int width, const u8 *value)\n{\n\tint idx;\n\n\t \n\tfor (idx = 0; idx < width; idx++) {\n\t\tu8 bidx = idx & GENMASK(2, 0);\n\n\t\t \n\t\tvcap_encode_bit(stream, itr, (value[idx / 8] >> bidx) & 0x1);\n\t\tvcap_iter_next(itr);\n\t}\n}\n\nstatic void vcap_encode_typegroups(u32 *stream, int sw_width,\n\t\t\t\t   const struct vcap_typegroup *tg,\n\t\t\t\t   bool mask)\n{\n\tstruct vcap_stream_iter iter;\n\tint idx;\n\n\t \n\tvcap_iter_set(&iter, sw_width, tg, 0);\n\twhile (iter.tg->width) {\n\t\t \n\t\titer.offset = iter.tg->offset;\n\t\tvcap_iter_update(&iter);\n\t\tfor (idx = 0; idx < iter.tg->width; idx++) {\n\t\t\t \n\t\t\tif (mask)\n\t\t\t\tvcap_set_bit(stream, &iter, 0x1);\n\t\t\telse\n\t\t\t\tvcap_set_bit(stream, &iter,\n\t\t\t\t\t     (iter.tg->value >> idx) & 0x1);\n\t\t\titer.offset++;\n\t\t\tvcap_iter_update(&iter);\n\t\t}\n\t\titer.tg++;  \n\t}\n}\n\nstatic bool vcap_bitarray_zero(int width, u8 *value)\n{\n\tint bytes = DIV_ROUND_UP(width, BITS_PER_BYTE);\n\tu8 total = 0, bmask = 0xff;\n\tint rwidth = width;\n\tint idx;\n\n\tfor (idx = 0; idx < bytes; ++idx, rwidth -= BITS_PER_BYTE) {\n\t\tif (rwidth && rwidth < BITS_PER_BYTE)\n\t\t\tbmask = (1 << rwidth) - 1;\n\t\ttotal += value[idx] & bmask;\n\t}\n\treturn total == 0;\n}\n\nstatic bool vcap_get_bit(u32 *stream, struct vcap_stream_iter *itr)\n{\n\tu32 mask = BIT(itr->reg_bitpos);\n\tu32 *p = &stream[itr->reg_idx];\n\n\treturn !!(*p & mask);\n}\n\nstatic void vcap_decode_field(u32 *stream, struct vcap_stream_iter *itr,\n\t\t\t      int width, u8 *value)\n{\n\tint idx;\n\n\t \n\tfor (idx = 0; idx < width; idx++) {\n\t\tu8 bidx = idx & 0x7;\n\n\t\t \n\t\tif (vcap_get_bit(stream, itr))\n\t\t\t*value |= 1 << bidx;\n\t\tvcap_iter_next(itr);\n\t\tif (bidx == 7)\n\t\t\tvalue++;\n\t}\n}\n\n \nstatic bool vcap_verify_keystream_keyset(struct vcap_control *vctrl,\n\t\t\t\t\t enum vcap_type vt,\n\t\t\t\t\t u32 *keystream,\n\t\t\t\t\t u32 *mskstream,\n\t\t\t\t\t enum vcap_keyfield_set keyset)\n{\n\tconst struct vcap_info *vcap = &vctrl->vcaps[vt];\n\tconst struct vcap_field *typefld;\n\tconst struct vcap_typegroup *tgt;\n\tconst struct vcap_field *fields;\n\tstruct vcap_stream_iter iter;\n\tconst struct vcap_set *info;\n\tu32 value = 0;\n\tu32 mask = 0;\n\n\tif (vcap_keyfield_count(vctrl, vt, keyset) == 0)\n\t\treturn false;\n\n\tinfo = vcap_keyfieldset(vctrl, vt, keyset);\n\t \n\tif (!info)\n\t\treturn false;\n\n\t \n\tif (info->type_id == (u8)-1)\n\t\treturn true;\n\n\t \n\ttgt = vcap_keyfield_typegroup(vctrl, vt, keyset);\n\tif (!tgt)\n\t\treturn false;\n\n\tfields = vcap_keyfields(vctrl, vt, keyset);\n\tif (!fields)\n\t\treturn false;\n\n\ttypefld = &fields[VCAP_KF_TYPE];\n\tvcap_iter_init(&iter, vcap->sw_width, tgt, typefld->offset);\n\tvcap_decode_field(mskstream, &iter, typefld->width, (u8 *)&mask);\n\t \n\tif (vcap_bitarray_zero(typefld->width, (u8 *)&mask))\n\t\treturn false;\n\n\t \n\tvcap_iter_init(&iter, vcap->sw_width, tgt, typefld->offset);\n\tvcap_decode_field(keystream, &iter, typefld->width, (u8 *)&value);\n\n\treturn (value & mask) == (info->type_id & mask);\n}\n\n \nstatic int vcap_verify_typegroups(u32 *stream, int sw_width,\n\t\t\t\t  const struct vcap_typegroup *tgt, bool mask,\n\t\t\t\t  int sw_max)\n{\n\tstruct vcap_stream_iter iter;\n\tint sw_cnt, idx;\n\n\tvcap_iter_set(&iter, sw_width, tgt, 0);\n\tsw_cnt = 0;\n\twhile (iter.tg->width) {\n\t\tu32 value = 0;\n\t\tu32 tg_value = iter.tg->value;\n\n\t\tif (mask)\n\t\t\ttg_value = (1 << iter.tg->width) - 1;\n\t\t \n\t\titer.offset = iter.tg->offset;\n\t\tvcap_iter_update(&iter);\n\t\tfor (idx = 0; idx < iter.tg->width; idx++) {\n\t\t\t \n\t\t\tif (vcap_get_bit(stream, &iter))\n\t\t\t\tvalue |= 1 << idx;\n\t\t\titer.offset++;\n\t\t\tvcap_iter_update(&iter);\n\t\t}\n\t\tif (value != tg_value)\n\t\t\treturn -EINVAL;\n\t\titer.tg++;  \n\t\tsw_cnt++;\n\t\t \n\t\tif (sw_max && sw_cnt >= sw_max)\n\t\t\tbreak;\n\t}\n\treturn 0;\n}\n\n \nstatic int vcap_find_keystream_typegroup_sw(struct vcap_control *vctrl,\n\t\t\t\t\t    enum vcap_type vt, u32 *stream,\n\t\t\t\t\t    bool mask, int sw_max)\n{\n\tconst struct vcap_typegroup **tgt;\n\tint sw_idx, res;\n\n\ttgt = vctrl->vcaps[vt].keyfield_set_typegroups;\n\t \n\tfor (sw_idx = vctrl->vcaps[vt].sw_count; sw_idx >= 0; sw_idx--) {\n\t\tif (!tgt[sw_idx])\n\t\t\tcontinue;\n\n\t\tres = vcap_verify_typegroups(stream, vctrl->vcaps[vt].sw_width,\n\t\t\t\t\t     tgt[sw_idx], mask, sw_max);\n\t\tif (res == 0)\n\t\t\treturn sw_idx;\n\t}\n\treturn -EINVAL;\n}\n\n \nint\nvcap_find_keystream_keysets(struct vcap_control *vctrl,\n\t\t\t    enum vcap_type vt,\n\t\t\t    u32 *keystream,\n\t\t\t    u32 *mskstream,\n\t\t\t    bool mask, int sw_max,\n\t\t\t    struct vcap_keyset_list *kslist)\n{\n\tconst struct vcap_set *keyfield_set;\n\tint sw_count, idx;\n\n\tsw_count = vcap_find_keystream_typegroup_sw(vctrl, vt, keystream, mask,\n\t\t\t\t\t\t    sw_max);\n\tif (sw_count < 0)\n\t\treturn sw_count;\n\n\tkeyfield_set = vctrl->vcaps[vt].keyfield_set;\n\tfor (idx = 0; idx < vctrl->vcaps[vt].keyfield_set_size; ++idx) {\n\t\tif (keyfield_set[idx].sw_per_item != sw_count)\n\t\t\tcontinue;\n\n\t\tif (vcap_verify_keystream_keyset(vctrl, vt, keystream,\n\t\t\t\t\t\t mskstream, idx))\n\t\t\tvcap_keyset_list_add(kslist, idx);\n\t}\n\tif (kslist->cnt > 0)\n\t\treturn 0;\n\treturn -EINVAL;\n}\nEXPORT_SYMBOL_GPL(vcap_find_keystream_keysets);\n\n \nint vcap_addr_keysets(struct vcap_control *vctrl,\n\t\t      struct net_device *ndev,\n\t\t      struct vcap_admin *admin,\n\t\t      int addr,\n\t\t      struct vcap_keyset_list *kslist)\n{\n\tenum vcap_type vt = admin->vtype;\n\tint keyset_sw_regs, idx;\n\tu32 key = 0, mask = 0;\n\n\t \n\tkeyset_sw_regs = DIV_ROUND_UP(vctrl->vcaps[vt].sw_width, 32);\n\tvctrl->ops->update(ndev, admin, VCAP_CMD_READ, VCAP_SEL_ALL, addr);\n\tvctrl->ops->cache_read(ndev, admin, VCAP_SEL_ENTRY, 0,\n\t\t\t       keyset_sw_regs);\n\t \n\tfor (idx = 0; idx < keyset_sw_regs; ++idx) {\n\t\tkey |= ~admin->cache.keystream[idx];\n\t\tmask |= admin->cache.maskstream[idx];\n\t}\n\tif (key == 0 && mask == 0)\n\t\treturn -EINVAL;\n\t \n\treturn vcap_find_keystream_keysets(vctrl, vt, admin->cache.keystream,\n\t\t\t\t\t   admin->cache.maskstream, false, 0,\n\t\t\t\t\t   kslist);\n}\nEXPORT_SYMBOL_GPL(vcap_addr_keysets);\n\n \nconst struct vcap_field *vcap_keyfields(struct vcap_control *vctrl,\n\t\t\t\t\tenum vcap_type vt,\n\t\t\t\t\tenum vcap_keyfield_set keyset)\n{\n\t \n\tif (keyset >= vctrl->vcaps[vt].keyfield_set_size)\n\t\treturn NULL;\n\treturn vctrl->vcaps[vt].keyfield_set_map[keyset];\n}\n\n \nconst struct vcap_set *vcap_keyfieldset(struct vcap_control *vctrl,\n\t\t\t\t\tenum vcap_type vt,\n\t\t\t\t\tenum vcap_keyfield_set keyset)\n{\n\tconst struct vcap_set *kset;\n\n\t \n\tif (keyset >= vctrl->vcaps[vt].keyfield_set_size)\n\t\treturn NULL;\n\tkset = &vctrl->vcaps[vt].keyfield_set[keyset];\n\tif (kset->sw_per_item == 0 || kset->sw_per_item > vctrl->vcaps[vt].sw_count)\n\t\treturn NULL;\n\treturn kset;\n}\nEXPORT_SYMBOL_GPL(vcap_keyfieldset);\n\n \nconst struct vcap_typegroup *\nvcap_keyfield_typegroup(struct vcap_control *vctrl,\n\t\t\tenum vcap_type vt, enum vcap_keyfield_set keyset)\n{\n\tconst struct vcap_set *kset = vcap_keyfieldset(vctrl, vt, keyset);\n\n\t \n\tif (!kset)\n\t\treturn NULL;\n\treturn vctrl->vcaps[vt].keyfield_set_typegroups[kset->sw_per_item];\n}\n\n \nint vcap_keyfield_count(struct vcap_control *vctrl,\n\t\t\tenum vcap_type vt, enum vcap_keyfield_set keyset)\n{\n\t \n\tif (keyset >= vctrl->vcaps[vt].keyfield_set_size)\n\t\treturn 0;\n\treturn vctrl->vcaps[vt].keyfield_set_map_size[keyset];\n}\n\nstatic void vcap_encode_keyfield(struct vcap_rule_internal *ri,\n\t\t\t\t const struct vcap_client_keyfield *kf,\n\t\t\t\t const struct vcap_field *rf,\n\t\t\t\t const struct vcap_typegroup *tgt)\n{\n\tint sw_width = ri->vctrl->vcaps[ri->admin->vtype].sw_width;\n\tstruct vcap_cache_data *cache = &ri->admin->cache;\n\tstruct vcap_stream_iter iter;\n\tconst u8 *value, *mask;\n\n\t \n\tswitch (kf->ctrl.type) {\n\tcase VCAP_FIELD_BIT:\n\t\tvalue = &kf->data.u1.value;\n\t\tmask = &kf->data.u1.mask;\n\t\tbreak;\n\tcase VCAP_FIELD_U32:\n\t\tvalue = (const u8 *)&kf->data.u32.value;\n\t\tmask = (const u8 *)&kf->data.u32.mask;\n\t\tbreak;\n\tcase VCAP_FIELD_U48:\n\t\tvalue = kf->data.u48.value;\n\t\tmask = kf->data.u48.mask;\n\t\tbreak;\n\tcase VCAP_FIELD_U56:\n\t\tvalue = kf->data.u56.value;\n\t\tmask = kf->data.u56.mask;\n\t\tbreak;\n\tcase VCAP_FIELD_U64:\n\t\tvalue = kf->data.u64.value;\n\t\tmask = kf->data.u64.mask;\n\t\tbreak;\n\tcase VCAP_FIELD_U72:\n\t\tvalue = kf->data.u72.value;\n\t\tmask = kf->data.u72.mask;\n\t\tbreak;\n\tcase VCAP_FIELD_U112:\n\t\tvalue = kf->data.u112.value;\n\t\tmask = kf->data.u112.mask;\n\t\tbreak;\n\tcase VCAP_FIELD_U128:\n\t\tvalue = kf->data.u128.value;\n\t\tmask = kf->data.u128.mask;\n\t\tbreak;\n\t}\n\tvcap_iter_init(&iter, sw_width, tgt, rf->offset);\n\tvcap_encode_field(cache->keystream, &iter, rf->width, value);\n\tvcap_iter_init(&iter, sw_width, tgt, rf->offset);\n\tvcap_encode_field(cache->maskstream, &iter, rf->width, mask);\n}\n\nstatic void vcap_encode_keyfield_typegroups(struct vcap_control *vctrl,\n\t\t\t\t\t    struct vcap_rule_internal *ri,\n\t\t\t\t\t    const struct vcap_typegroup *tgt)\n{\n\tint sw_width = vctrl->vcaps[ri->admin->vtype].sw_width;\n\tstruct vcap_cache_data *cache = &ri->admin->cache;\n\n\t \n\tvcap_encode_typegroups(cache->keystream, sw_width, tgt, false);\n\tvcap_encode_typegroups(cache->maskstream, sw_width, tgt, true);\n}\n\n \nstatic void vcap_copy_to_w32be(u8 *dst, const u8 *src, int size)\n{\n\tfor (int idx = 0; idx < size; ++idx) {\n\t\tint first_byte_index = 0;\n\t\tint nidx;\n\n\t\tfirst_byte_index = size - (((idx >> 2) + 1) << 2);\n\t\tif (first_byte_index < 0)\n\t\t\tfirst_byte_index = 0;\n\t\tnidx = idx + first_byte_index - (idx & ~0x3);\n\t\tdst[nidx] = src[idx];\n\t}\n}\n\nstatic void\nvcap_copy_from_client_keyfield(struct vcap_rule *rule,\n\t\t\t       struct vcap_client_keyfield *dst,\n\t\t\t       const struct vcap_client_keyfield *src)\n{\n\tstruct vcap_rule_internal *ri = to_intrule(rule);\n\tconst struct vcap_client_keyfield_data *sdata;\n\tstruct vcap_client_keyfield_data *ddata;\n\tint size;\n\n\tdst->ctrl.type = src->ctrl.type;\n\tdst->ctrl.key = src->ctrl.key;\n\tINIT_LIST_HEAD(&dst->ctrl.list);\n\tsdata = &src->data;\n\tddata = &dst->data;\n\n\tif (!ri->admin->w32be) {\n\t\tmemcpy(ddata, sdata, sizeof(dst->data));\n\t\treturn;\n\t}\n\n\tsize = keyfield_size_table[dst->ctrl.type] / 2;\n\n\tswitch (dst->ctrl.type) {\n\tcase VCAP_FIELD_BIT:\n\tcase VCAP_FIELD_U32:\n\t\tmemcpy(ddata, sdata, sizeof(dst->data));\n\t\tbreak;\n\tcase VCAP_FIELD_U48:\n\t\tvcap_copy_to_w32be(ddata->u48.value, src->data.u48.value, size);\n\t\tvcap_copy_to_w32be(ddata->u48.mask,  src->data.u48.mask, size);\n\t\tbreak;\n\tcase VCAP_FIELD_U56:\n\t\tvcap_copy_to_w32be(ddata->u56.value, sdata->u56.value, size);\n\t\tvcap_copy_to_w32be(ddata->u56.mask,  sdata->u56.mask, size);\n\t\tbreak;\n\tcase VCAP_FIELD_U64:\n\t\tvcap_copy_to_w32be(ddata->u64.value, sdata->u64.value, size);\n\t\tvcap_copy_to_w32be(ddata->u64.mask,  sdata->u64.mask, size);\n\t\tbreak;\n\tcase VCAP_FIELD_U72:\n\t\tvcap_copy_to_w32be(ddata->u72.value, sdata->u72.value, size);\n\t\tvcap_copy_to_w32be(ddata->u72.mask,  sdata->u72.mask, size);\n\t\tbreak;\n\tcase VCAP_FIELD_U112:\n\t\tvcap_copy_to_w32be(ddata->u112.value, sdata->u112.value, size);\n\t\tvcap_copy_to_w32be(ddata->u112.mask,  sdata->u112.mask, size);\n\t\tbreak;\n\tcase VCAP_FIELD_U128:\n\t\tvcap_copy_to_w32be(ddata->u128.value, sdata->u128.value, size);\n\t\tvcap_copy_to_w32be(ddata->u128.mask,  sdata->u128.mask, size);\n\t\tbreak;\n\t}\n}\n\nstatic void\nvcap_copy_from_client_actionfield(struct vcap_rule *rule,\n\t\t\t\t  struct vcap_client_actionfield *dst,\n\t\t\t\t  const struct vcap_client_actionfield *src)\n{\n\tstruct vcap_rule_internal *ri = to_intrule(rule);\n\tconst struct vcap_client_actionfield_data *sdata;\n\tstruct vcap_client_actionfield_data *ddata;\n\tint size;\n\n\tdst->ctrl.type = src->ctrl.type;\n\tdst->ctrl.action = src->ctrl.action;\n\tINIT_LIST_HEAD(&dst->ctrl.list);\n\tsdata = &src->data;\n\tddata = &dst->data;\n\n\tif (!ri->admin->w32be) {\n\t\tmemcpy(ddata, sdata, sizeof(dst->data));\n\t\treturn;\n\t}\n\n\tsize = actionfield_size_table[dst->ctrl.type];\n\n\tswitch (dst->ctrl.type) {\n\tcase VCAP_FIELD_BIT:\n\tcase VCAP_FIELD_U32:\n\t\tmemcpy(ddata, sdata, sizeof(dst->data));\n\t\tbreak;\n\tcase VCAP_FIELD_U48:\n\t\tvcap_copy_to_w32be(ddata->u48.value, sdata->u48.value, size);\n\t\tbreak;\n\tcase VCAP_FIELD_U56:\n\t\tvcap_copy_to_w32be(ddata->u56.value, sdata->u56.value, size);\n\t\tbreak;\n\tcase VCAP_FIELD_U64:\n\t\tvcap_copy_to_w32be(ddata->u64.value, sdata->u64.value, size);\n\t\tbreak;\n\tcase VCAP_FIELD_U72:\n\t\tvcap_copy_to_w32be(ddata->u72.value, sdata->u72.value, size);\n\t\tbreak;\n\tcase VCAP_FIELD_U112:\n\t\tvcap_copy_to_w32be(ddata->u112.value, sdata->u112.value, size);\n\t\tbreak;\n\tcase VCAP_FIELD_U128:\n\t\tvcap_copy_to_w32be(ddata->u128.value, sdata->u128.value, size);\n\t\tbreak;\n\t}\n}\n\nstatic int vcap_encode_rule_keyset(struct vcap_rule_internal *ri)\n{\n\tconst struct vcap_client_keyfield *ckf;\n\tconst struct vcap_typegroup *tg_table;\n\tstruct vcap_client_keyfield tempkf;\n\tconst struct vcap_field *kf_table;\n\tint keyset_size;\n\n\t \n\tkf_table = vcap_keyfields(ri->vctrl, ri->admin->vtype, ri->data.keyset);\n\tif (!kf_table) {\n\t\tpr_err(\"%s:%d: no fields available for this keyset: %d\\n\",\n\t\t       __func__, __LINE__, ri->data.keyset);\n\t\treturn -EINVAL;\n\t}\n\t \n\ttg_table = vcap_keyfield_typegroup(ri->vctrl, ri->admin->vtype,\n\t\t\t\t\t   ri->data.keyset);\n\tif (!tg_table) {\n\t\tpr_err(\"%s:%d: no typegroups available for this keyset: %d\\n\",\n\t\t       __func__, __LINE__, ri->data.keyset);\n\t\treturn -EINVAL;\n\t}\n\t \n\tkeyset_size = vcap_keyfield_count(ri->vctrl, ri->admin->vtype,\n\t\t\t\t\t  ri->data.keyset);\n\tif (keyset_size == 0) {\n\t\tpr_err(\"%s:%d: zero field count for this keyset: %d\\n\",\n\t\t       __func__, __LINE__, ri->data.keyset);\n\t\treturn -EINVAL;\n\t}\n\t \n\tif (list_empty(&ri->data.keyfields)) {\n\t\tpr_err(\"%s:%d: no keyfields in the rule\\n\", __func__, __LINE__);\n\t\treturn -EINVAL;\n\t}\n\tlist_for_each_entry(ckf, &ri->data.keyfields, ctrl.list) {\n\t\t \n\t\tif (ckf->ctrl.key >= keyset_size) {\n\t\t\tpr_err(\"%s:%d: key %d is not in vcap\\n\",\n\t\t\t       __func__, __LINE__, ckf->ctrl.key);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tvcap_copy_from_client_keyfield(&ri->data, &tempkf, ckf);\n\t\tvcap_encode_keyfield(ri, &tempkf, &kf_table[ckf->ctrl.key],\n\t\t\t\t     tg_table);\n\t}\n\t \n\tvcap_encode_keyfield_typegroups(ri->vctrl, ri, tg_table);\n\treturn 0;\n}\n\n \nconst struct vcap_field *\nvcap_actionfields(struct vcap_control *vctrl,\n\t\t  enum vcap_type vt, enum vcap_actionfield_set actionset)\n{\n\t \n\tif (actionset >= vctrl->vcaps[vt].actionfield_set_size)\n\t\treturn NULL;\n\treturn vctrl->vcaps[vt].actionfield_set_map[actionset];\n}\n\nconst struct vcap_set *\nvcap_actionfieldset(struct vcap_control *vctrl,\n\t\t    enum vcap_type vt, enum vcap_actionfield_set actionset)\n{\n\tconst struct vcap_set *aset;\n\n\t \n\tif (actionset >= vctrl->vcaps[vt].actionfield_set_size)\n\t\treturn NULL;\n\taset = &vctrl->vcaps[vt].actionfield_set[actionset];\n\tif (aset->sw_per_item == 0 || aset->sw_per_item > vctrl->vcaps[vt].sw_count)\n\t\treturn NULL;\n\treturn aset;\n}\n\n \nconst struct vcap_typegroup *\nvcap_actionfield_typegroup(struct vcap_control *vctrl,\n\t\t\t   enum vcap_type vt, enum vcap_actionfield_set actionset)\n{\n\tconst struct vcap_set *aset = vcap_actionfieldset(vctrl, vt, actionset);\n\n\t \n\tif (!aset)\n\t\treturn NULL;\n\treturn vctrl->vcaps[vt].actionfield_set_typegroups[aset->sw_per_item];\n}\n\n \nint vcap_actionfield_count(struct vcap_control *vctrl,\n\t\t\t   enum vcap_type vt,\n\t\t\t   enum vcap_actionfield_set actionset)\n{\n\t \n\tif (actionset >= vctrl->vcaps[vt].actionfield_set_size)\n\t\treturn 0;\n\treturn vctrl->vcaps[vt].actionfield_set_map_size[actionset];\n}\n\nstatic void vcap_encode_actionfield(struct vcap_rule_internal *ri,\n\t\t\t\t    const struct vcap_client_actionfield *af,\n\t\t\t\t    const struct vcap_field *rf,\n\t\t\t\t    const struct vcap_typegroup *tgt)\n{\n\tint act_width = ri->vctrl->vcaps[ri->admin->vtype].act_width;\n\n\tstruct vcap_cache_data *cache = &ri->admin->cache;\n\tstruct vcap_stream_iter iter;\n\tconst u8 *value;\n\n\t \n\tswitch (af->ctrl.type) {\n\tcase VCAP_FIELD_BIT:\n\t\tvalue = &af->data.u1.value;\n\t\tbreak;\n\tcase VCAP_FIELD_U32:\n\t\tvalue = (const u8 *)&af->data.u32.value;\n\t\tbreak;\n\tcase VCAP_FIELD_U48:\n\t\tvalue = af->data.u48.value;\n\t\tbreak;\n\tcase VCAP_FIELD_U56:\n\t\tvalue = af->data.u56.value;\n\t\tbreak;\n\tcase VCAP_FIELD_U64:\n\t\tvalue = af->data.u64.value;\n\t\tbreak;\n\tcase VCAP_FIELD_U72:\n\t\tvalue = af->data.u72.value;\n\t\tbreak;\n\tcase VCAP_FIELD_U112:\n\t\tvalue = af->data.u112.value;\n\t\tbreak;\n\tcase VCAP_FIELD_U128:\n\t\tvalue = af->data.u128.value;\n\t\tbreak;\n\t}\n\tvcap_iter_init(&iter, act_width, tgt, rf->offset);\n\tvcap_encode_field(cache->actionstream, &iter, rf->width, value);\n}\n\nstatic void vcap_encode_actionfield_typegroups(struct vcap_rule_internal *ri,\n\t\t\t\t\t       const struct vcap_typegroup *tgt)\n{\n\tint sw_width = ri->vctrl->vcaps[ri->admin->vtype].act_width;\n\tstruct vcap_cache_data *cache = &ri->admin->cache;\n\n\t \n\tvcap_encode_typegroups(cache->actionstream, sw_width, tgt, false);\n}\n\nstatic int vcap_encode_rule_actionset(struct vcap_rule_internal *ri)\n{\n\tconst struct vcap_client_actionfield *caf;\n\tconst struct vcap_typegroup *tg_table;\n\tstruct vcap_client_actionfield tempaf;\n\tconst struct vcap_field *af_table;\n\tint actionset_size;\n\n\t \n\taf_table = vcap_actionfields(ri->vctrl, ri->admin->vtype,\n\t\t\t\t     ri->data.actionset);\n\tif (!af_table) {\n\t\tpr_err(\"%s:%d: no fields available for this actionset: %d\\n\",\n\t\t       __func__, __LINE__, ri->data.actionset);\n\t\treturn -EINVAL;\n\t}\n\t \n\ttg_table = vcap_actionfield_typegroup(ri->vctrl, ri->admin->vtype,\n\t\t\t\t\t      ri->data.actionset);\n\tif (!tg_table) {\n\t\tpr_err(\"%s:%d: no typegroups available for this actionset: %d\\n\",\n\t\t       __func__, __LINE__, ri->data.actionset);\n\t\treturn -EINVAL;\n\t}\n\t \n\tactionset_size = vcap_actionfield_count(ri->vctrl, ri->admin->vtype,\n\t\t\t\t\t\tri->data.actionset);\n\tif (actionset_size == 0) {\n\t\tpr_err(\"%s:%d: zero field count for this actionset: %d\\n\",\n\t\t       __func__, __LINE__, ri->data.actionset);\n\t\treturn -EINVAL;\n\t}\n\t \n\tif (list_empty(&ri->data.actionfields))\n\t\tpr_warn(\"%s:%d: no actionfields in the rule\\n\",\n\t\t\t__func__, __LINE__);\n\tlist_for_each_entry(caf, &ri->data.actionfields, ctrl.list) {\n\t\t \n\t\tif (caf->ctrl.action >= actionset_size) {\n\t\t\tpr_err(\"%s:%d: action %d is not in vcap\\n\",\n\t\t\t       __func__, __LINE__, caf->ctrl.action);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tvcap_copy_from_client_actionfield(&ri->data, &tempaf, caf);\n\t\tvcap_encode_actionfield(ri, &tempaf,\n\t\t\t\t\t&af_table[caf->ctrl.action], tg_table);\n\t}\n\t \n\tvcap_encode_actionfield_typegroups(ri, tg_table);\n\treturn 0;\n}\n\nstatic int vcap_encode_rule(struct vcap_rule_internal *ri)\n{\n\tint err;\n\n\terr = vcap_encode_rule_keyset(ri);\n\tif (err)\n\t\treturn err;\n\terr = vcap_encode_rule_actionset(ri);\n\tif (err)\n\t\treturn err;\n\treturn 0;\n}\n\nint vcap_api_check(struct vcap_control *ctrl)\n{\n\tif (!ctrl) {\n\t\tpr_err(\"%s:%d: vcap control is missing\\n\", __func__, __LINE__);\n\t\treturn -EINVAL;\n\t}\n\tif (!ctrl->ops || !ctrl->ops->validate_keyset ||\n\t    !ctrl->ops->add_default_fields || !ctrl->ops->cache_erase ||\n\t    !ctrl->ops->cache_write || !ctrl->ops->cache_read ||\n\t    !ctrl->ops->init || !ctrl->ops->update || !ctrl->ops->move ||\n\t    !ctrl->ops->port_info) {\n\t\tpr_err(\"%s:%d: client operations are missing\\n\",\n\t\t       __func__, __LINE__);\n\t\treturn -ENOENT;\n\t}\n\treturn 0;\n}\n\nvoid vcap_erase_cache(struct vcap_rule_internal *ri)\n{\n\tri->vctrl->ops->cache_erase(ri->admin);\n}\n\n \nint vcap_set_rule_set_keyset(struct vcap_rule *rule,\n\t\t\t     enum vcap_keyfield_set keyset)\n{\n\tstruct vcap_rule_internal *ri = to_intrule(rule);\n\tconst struct vcap_set *kset;\n\tint sw_width;\n\n\tkset = vcap_keyfieldset(ri->vctrl, ri->admin->vtype, keyset);\n\t \n\tif (!kset)\n\t\treturn -EINVAL;\n\tri->keyset_sw = kset->sw_per_item;\n\tsw_width = ri->vctrl->vcaps[ri->admin->vtype].sw_width;\n\tri->keyset_sw_regs = DIV_ROUND_UP(sw_width, 32);\n\tri->data.keyset = keyset;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(vcap_set_rule_set_keyset);\n\n \nint vcap_set_rule_set_actionset(struct vcap_rule *rule,\n\t\t\t\tenum vcap_actionfield_set actionset)\n{\n\tstruct vcap_rule_internal *ri = to_intrule(rule);\n\tconst struct vcap_set *aset;\n\tint act_width;\n\n\taset = vcap_actionfieldset(ri->vctrl, ri->admin->vtype, actionset);\n\t \n\tif (!aset)\n\t\treturn -EINVAL;\n\tri->actionset_sw = aset->sw_per_item;\n\tact_width = ri->vctrl->vcaps[ri->admin->vtype].act_width;\n\tri->actionset_sw_regs = DIV_ROUND_UP(act_width, 32);\n\tri->data.actionset = actionset;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(vcap_set_rule_set_actionset);\n\n \nstatic bool vcap_rule_exists(struct vcap_control *vctrl, u32 id)\n{\n\tstruct vcap_rule_internal *ri;\n\tstruct vcap_admin *admin;\n\n\t \n\tlist_for_each_entry(admin, &vctrl->list, list)\n\t\tlist_for_each_entry(ri, &admin->rules, list)\n\t\t\tif (ri->data.id == id)\n\t\t\t\treturn true;\n\treturn false;\n}\n\n \nstatic struct vcap_rule_internal *\nvcap_get_locked_rule(struct vcap_control *vctrl, u32 id)\n{\n\tstruct vcap_rule_internal *ri;\n\tstruct vcap_admin *admin;\n\n\t \n\tlist_for_each_entry(admin, &vctrl->list, list) {\n\t\tmutex_lock(&admin->lock);\n\t\tlist_for_each_entry(ri, &admin->rules, list)\n\t\t\tif (ri->data.id == id)\n\t\t\t\treturn ri;\n\t\tmutex_unlock(&admin->lock);\n\t}\n\treturn NULL;\n}\n\n \nint vcap_lookup_rule_by_cookie(struct vcap_control *vctrl, u64 cookie)\n{\n\tstruct vcap_rule_internal *ri;\n\tstruct vcap_admin *admin;\n\tint id = 0;\n\n\t \n\tlist_for_each_entry(admin, &vctrl->list, list) {\n\t\tmutex_lock(&admin->lock);\n\t\tlist_for_each_entry(ri, &admin->rules, list) {\n\t\t\tif (ri->data.cookie == cookie) {\n\t\t\t\tid = ri->data.id;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmutex_unlock(&admin->lock);\n\t\tif (id)\n\t\t\treturn id;\n\t}\n\treturn -ENOENT;\n}\nEXPORT_SYMBOL_GPL(vcap_lookup_rule_by_cookie);\n\n \nint vcap_admin_rule_count(struct vcap_admin *admin, int cid)\n{\n\tint max_cid = roundup(cid + 1, VCAP_CID_LOOKUP_SIZE);\n\tint min_cid = rounddown(cid, VCAP_CID_LOOKUP_SIZE);\n\tstruct vcap_rule_internal *elem;\n\tint count = 0;\n\n\tlist_for_each_entry(elem, &admin->rules, list) {\n\t\tmutex_lock(&admin->lock);\n\t\tif (elem->data.vcap_chain_id >= min_cid &&\n\t\t    elem->data.vcap_chain_id < max_cid)\n\t\t\t++count;\n\t\tmutex_unlock(&admin->lock);\n\t}\n\treturn count;\n}\nEXPORT_SYMBOL_GPL(vcap_admin_rule_count);\n\n \nstatic struct vcap_rule_internal *vcap_dup_rule(struct vcap_rule_internal *ri,\n\t\t\t\t\t\tbool full)\n{\n\tstruct vcap_client_actionfield *caf, *newcaf;\n\tstruct vcap_client_keyfield *ckf, *newckf;\n\tstruct vcap_rule_internal *duprule;\n\n\t \n\tduprule = kzalloc(sizeof(*duprule), GFP_KERNEL);\n\tif (!duprule)\n\t\treturn ERR_PTR(-ENOMEM);\n\t*duprule = *ri;\n\t \n\tINIT_LIST_HEAD(&duprule->list);\n\t \n\tINIT_LIST_HEAD(&duprule->data.keyfields);\n\tINIT_LIST_HEAD(&duprule->data.actionfields);\n\n\t \n\tif (!full)\n\t\treturn duprule;\n\n\tlist_for_each_entry(ckf, &ri->data.keyfields, ctrl.list) {\n\t\tnewckf = kmemdup(ckf, sizeof(*newckf), GFP_KERNEL);\n\t\tif (!newckf)\n\t\t\tgoto err;\n\t\tlist_add_tail(&newckf->ctrl.list, &duprule->data.keyfields);\n\t}\n\n\tlist_for_each_entry(caf, &ri->data.actionfields, ctrl.list) {\n\t\tnewcaf = kmemdup(caf, sizeof(*newcaf), GFP_KERNEL);\n\t\tif (!newcaf)\n\t\t\tgoto err;\n\t\tlist_add_tail(&newcaf->ctrl.list, &duprule->data.actionfields);\n\t}\n\n\treturn duprule;\n\nerr:\n\tlist_for_each_entry_safe(ckf, newckf, &duprule->data.keyfields, ctrl.list) {\n\t\tlist_del(&ckf->ctrl.list);\n\t\tkfree(ckf);\n\t}\n\n\tlist_for_each_entry_safe(caf, newcaf, &duprule->data.actionfields, ctrl.list) {\n\t\tlist_del(&caf->ctrl.list);\n\t\tkfree(caf);\n\t}\n\n\tkfree(duprule);\n\treturn ERR_PTR(-ENOMEM);\n}\n\nstatic void vcap_apply_width(u8 *dst, int width, int bytes)\n{\n\tu8 bmask;\n\tint idx;\n\n\tfor (idx = 0; idx < bytes; idx++) {\n\t\tif (width > 0)\n\t\t\tif (width < 8)\n\t\t\t\tbmask = (1 << width) - 1;\n\t\t\telse\n\t\t\t\tbmask = ~0;\n\t\telse\n\t\t\tbmask = 0;\n\t\tdst[idx] &= bmask;\n\t\twidth -= 8;\n\t}\n}\n\nstatic void vcap_copy_from_w32be(u8 *dst, u8 *src, int size, int width)\n{\n\tint idx, ridx, wstart, nidx;\n\tint tail_bytes = (((size + 4) >> 2) << 2) - size;\n\n\tfor (idx = 0, ridx = size - 1; idx < size; ++idx, --ridx) {\n\t\twstart = (idx >> 2) << 2;\n\t\tnidx = wstart + 3 - (idx & 0x3);\n\t\tif (nidx >= size)\n\t\t\tnidx -= tail_bytes;\n\t\tdst[nidx] = src[ridx];\n\t}\n\n\tvcap_apply_width(dst, width, size);\n}\n\nstatic void vcap_copy_action_bit_field(struct vcap_u1_action *field, u8 *value)\n{\n\tfield->value = (*value) & 0x1;\n}\n\nstatic void vcap_copy_limited_actionfield(u8 *dstvalue, u8 *srcvalue,\n\t\t\t\t\t  int width, int bytes)\n{\n\tmemcpy(dstvalue, srcvalue, bytes);\n\tvcap_apply_width(dstvalue, width, bytes);\n}\n\nstatic void vcap_copy_to_client_actionfield(struct vcap_rule_internal *ri,\n\t\t\t\t\t    struct vcap_client_actionfield *field,\n\t\t\t\t\t    u8 *value, u16 width)\n{\n\tint field_size = actionfield_size_table[field->ctrl.type];\n\n\tif (ri->admin->w32be) {\n\t\tswitch (field->ctrl.type) {\n\t\tcase VCAP_FIELD_BIT:\n\t\t\tvcap_copy_action_bit_field(&field->data.u1, value);\n\t\t\tbreak;\n\t\tcase VCAP_FIELD_U32:\n\t\t\tvcap_copy_limited_actionfield((u8 *)&field->data.u32.value,\n\t\t\t\t\t\t      value,\n\t\t\t\t\t\t      width, field_size);\n\t\t\tbreak;\n\t\tcase VCAP_FIELD_U48:\n\t\t\tvcap_copy_from_w32be(field->data.u48.value, value,\n\t\t\t\t\t     field_size, width);\n\t\t\tbreak;\n\t\tcase VCAP_FIELD_U56:\n\t\t\tvcap_copy_from_w32be(field->data.u56.value, value,\n\t\t\t\t\t     field_size, width);\n\t\t\tbreak;\n\t\tcase VCAP_FIELD_U64:\n\t\t\tvcap_copy_from_w32be(field->data.u64.value, value,\n\t\t\t\t\t     field_size, width);\n\t\t\tbreak;\n\t\tcase VCAP_FIELD_U72:\n\t\t\tvcap_copy_from_w32be(field->data.u72.value, value,\n\t\t\t\t\t     field_size, width);\n\t\t\tbreak;\n\t\tcase VCAP_FIELD_U112:\n\t\t\tvcap_copy_from_w32be(field->data.u112.value, value,\n\t\t\t\t\t     field_size, width);\n\t\t\tbreak;\n\t\tcase VCAP_FIELD_U128:\n\t\t\tvcap_copy_from_w32be(field->data.u128.value, value,\n\t\t\t\t\t     field_size, width);\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tswitch (field->ctrl.type) {\n\t\tcase VCAP_FIELD_BIT:\n\t\t\tvcap_copy_action_bit_field(&field->data.u1, value);\n\t\t\tbreak;\n\t\tcase VCAP_FIELD_U32:\n\t\t\tvcap_copy_limited_actionfield((u8 *)&field->data.u32.value,\n\t\t\t\t\t\t      value,\n\t\t\t\t\t\t      width, field_size);\n\t\t\tbreak;\n\t\tcase VCAP_FIELD_U48:\n\t\t\tvcap_copy_limited_actionfield(field->data.u48.value,\n\t\t\t\t\t\t      value,\n\t\t\t\t\t\t      width, field_size);\n\t\t\tbreak;\n\t\tcase VCAP_FIELD_U56:\n\t\t\tvcap_copy_limited_actionfield(field->data.u56.value,\n\t\t\t\t\t\t      value,\n\t\t\t\t\t\t      width, field_size);\n\t\t\tbreak;\n\t\tcase VCAP_FIELD_U64:\n\t\t\tvcap_copy_limited_actionfield(field->data.u64.value,\n\t\t\t\t\t\t      value,\n\t\t\t\t\t\t      width, field_size);\n\t\t\tbreak;\n\t\tcase VCAP_FIELD_U72:\n\t\t\tvcap_copy_limited_actionfield(field->data.u72.value,\n\t\t\t\t\t\t      value,\n\t\t\t\t\t\t      width, field_size);\n\t\t\tbreak;\n\t\tcase VCAP_FIELD_U112:\n\t\t\tvcap_copy_limited_actionfield(field->data.u112.value,\n\t\t\t\t\t\t      value,\n\t\t\t\t\t\t      width, field_size);\n\t\t\tbreak;\n\t\tcase VCAP_FIELD_U128:\n\t\t\tvcap_copy_limited_actionfield(field->data.u128.value,\n\t\t\t\t\t\t      value,\n\t\t\t\t\t\t      width, field_size);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void vcap_copy_key_bit_field(struct vcap_u1_key *field,\n\t\t\t\t    u8 *value, u8 *mask)\n{\n\tfield->value = (*value) & 0x1;\n\tfield->mask = (*mask) & 0x1;\n}\n\nstatic void vcap_copy_limited_keyfield(u8 *dstvalue, u8 *dstmask,\n\t\t\t\t       u8 *srcvalue, u8 *srcmask,\n\t\t\t\t       int width, int bytes)\n{\n\tmemcpy(dstvalue, srcvalue, bytes);\n\tvcap_apply_width(dstvalue, width, bytes);\n\tmemcpy(dstmask, srcmask, bytes);\n\tvcap_apply_width(dstmask, width, bytes);\n}\n\nstatic void vcap_copy_to_client_keyfield(struct vcap_rule_internal *ri,\n\t\t\t\t\t struct vcap_client_keyfield *field,\n\t\t\t\t\t u8 *value, u8 *mask, u16 width)\n{\n\tint field_size = keyfield_size_table[field->ctrl.type] / 2;\n\n\tif (ri->admin->w32be) {\n\t\tswitch (field->ctrl.type) {\n\t\tcase VCAP_FIELD_BIT:\n\t\t\tvcap_copy_key_bit_field(&field->data.u1, value, mask);\n\t\t\tbreak;\n\t\tcase VCAP_FIELD_U32:\n\t\t\tvcap_copy_limited_keyfield((u8 *)&field->data.u32.value,\n\t\t\t\t\t\t   (u8 *)&field->data.u32.mask,\n\t\t\t\t\t\t   value, mask,\n\t\t\t\t\t\t   width, field_size);\n\t\t\tbreak;\n\t\tcase VCAP_FIELD_U48:\n\t\t\tvcap_copy_from_w32be(field->data.u48.value, value,\n\t\t\t\t\t     field_size, width);\n\t\t\tvcap_copy_from_w32be(field->data.u48.mask,  mask,\n\t\t\t\t\t     field_size, width);\n\t\t\tbreak;\n\t\tcase VCAP_FIELD_U56:\n\t\t\tvcap_copy_from_w32be(field->data.u56.value, value,\n\t\t\t\t\t     field_size, width);\n\t\t\tvcap_copy_from_w32be(field->data.u56.mask,  mask,\n\t\t\t\t\t     field_size, width);\n\t\t\tbreak;\n\t\tcase VCAP_FIELD_U64:\n\t\t\tvcap_copy_from_w32be(field->data.u64.value, value,\n\t\t\t\t\t     field_size, width);\n\t\t\tvcap_copy_from_w32be(field->data.u64.mask,  mask,\n\t\t\t\t\t     field_size, width);\n\t\t\tbreak;\n\t\tcase VCAP_FIELD_U72:\n\t\t\tvcap_copy_from_w32be(field->data.u72.value, value,\n\t\t\t\t\t     field_size, width);\n\t\t\tvcap_copy_from_w32be(field->data.u72.mask,  mask,\n\t\t\t\t\t     field_size, width);\n\t\t\tbreak;\n\t\tcase VCAP_FIELD_U112:\n\t\t\tvcap_copy_from_w32be(field->data.u112.value, value,\n\t\t\t\t\t     field_size, width);\n\t\t\tvcap_copy_from_w32be(field->data.u112.mask,  mask,\n\t\t\t\t\t     field_size, width);\n\t\t\tbreak;\n\t\tcase VCAP_FIELD_U128:\n\t\t\tvcap_copy_from_w32be(field->data.u128.value, value,\n\t\t\t\t\t     field_size, width);\n\t\t\tvcap_copy_from_w32be(field->data.u128.mask,  mask,\n\t\t\t\t\t     field_size, width);\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tswitch (field->ctrl.type) {\n\t\tcase VCAP_FIELD_BIT:\n\t\t\tvcap_copy_key_bit_field(&field->data.u1, value, mask);\n\t\t\tbreak;\n\t\tcase VCAP_FIELD_U32:\n\t\t\tvcap_copy_limited_keyfield((u8 *)&field->data.u32.value,\n\t\t\t\t\t\t   (u8 *)&field->data.u32.mask,\n\t\t\t\t\t\t   value, mask,\n\t\t\t\t\t\t   width, field_size);\n\t\t\tbreak;\n\t\tcase VCAP_FIELD_U48:\n\t\t\tvcap_copy_limited_keyfield(field->data.u48.value,\n\t\t\t\t\t\t   field->data.u48.mask,\n\t\t\t\t\t\t   value, mask,\n\t\t\t\t\t\t   width, field_size);\n\t\t\tbreak;\n\t\tcase VCAP_FIELD_U56:\n\t\t\tvcap_copy_limited_keyfield(field->data.u56.value,\n\t\t\t\t\t\t   field->data.u56.mask,\n\t\t\t\t\t\t   value, mask,\n\t\t\t\t\t\t   width, field_size);\n\t\t\tbreak;\n\t\tcase VCAP_FIELD_U64:\n\t\t\tvcap_copy_limited_keyfield(field->data.u64.value,\n\t\t\t\t\t\t   field->data.u64.mask,\n\t\t\t\t\t\t   value, mask,\n\t\t\t\t\t\t   width, field_size);\n\t\t\tbreak;\n\t\tcase VCAP_FIELD_U72:\n\t\t\tvcap_copy_limited_keyfield(field->data.u72.value,\n\t\t\t\t\t\t   field->data.u72.mask,\n\t\t\t\t\t\t   value, mask,\n\t\t\t\t\t\t   width, field_size);\n\t\t\tbreak;\n\t\tcase VCAP_FIELD_U112:\n\t\t\tvcap_copy_limited_keyfield(field->data.u112.value,\n\t\t\t\t\t\t   field->data.u112.mask,\n\t\t\t\t\t\t   value, mask,\n\t\t\t\t\t\t   width, field_size);\n\t\t\tbreak;\n\t\tcase VCAP_FIELD_U128:\n\t\t\tvcap_copy_limited_keyfield(field->data.u128.value,\n\t\t\t\t\t\t   field->data.u128.mask,\n\t\t\t\t\t\t   value, mask,\n\t\t\t\t\t\t   width, field_size);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void vcap_rule_alloc_keyfield(struct vcap_rule_internal *ri,\n\t\t\t\t     const struct vcap_field *keyfield,\n\t\t\t\t     enum vcap_key_field key,\n\t\t\t\t     u8 *value, u8 *mask)\n{\n\tstruct vcap_client_keyfield *field;\n\n\tfield = kzalloc(sizeof(*field), GFP_KERNEL);\n\tif (!field)\n\t\treturn;\n\tINIT_LIST_HEAD(&field->ctrl.list);\n\tfield->ctrl.key = key;\n\tfield->ctrl.type = keyfield->type;\n\tvcap_copy_to_client_keyfield(ri, field, value, mask, keyfield->width);\n\tlist_add_tail(&field->ctrl.list, &ri->data.keyfields);\n}\n\n \nstatic bool\nvcap_verify_actionstream_actionset(struct vcap_control *vctrl,\n\t\t\t\t   enum vcap_type vt,\n\t\t\t\t   u32 *actionstream,\n\t\t\t\t   enum vcap_actionfield_set actionset)\n{\n\tconst struct vcap_typegroup *tgt;\n\tconst struct vcap_field *fields;\n\tconst struct vcap_set *info;\n\n\tif (vcap_actionfield_count(vctrl, vt, actionset) == 0)\n\t\treturn false;\n\n\tinfo = vcap_actionfieldset(vctrl, vt, actionset);\n\t \n\tif (!info)\n\t\treturn false;\n\n\t \n\tif (info->type_id == (u8)-1)\n\t\treturn true;\n\n\t \n\ttgt = vcap_actionfield_typegroup(vctrl, vt, actionset);\n\tif (!tgt)\n\t\treturn false;\n\n\tfields = vcap_actionfields(vctrl, vt, actionset);\n\tif (!fields)\n\t\treturn false;\n\n\t \n\treturn true;\n}\n\n \nstatic int vcap_find_actionstream_typegroup_sw(struct vcap_control *vctrl,\n\t\t\t\t\t       enum vcap_type vt, u32 *stream,\n\t\t\t\t\t       int sw_max)\n{\n\tconst struct vcap_typegroup **tgt;\n\tint sw_idx, res;\n\n\ttgt = vctrl->vcaps[vt].actionfield_set_typegroups;\n\t \n\tfor (sw_idx = vctrl->vcaps[vt].sw_count; sw_idx >= 0; sw_idx--) {\n\t\tif (!tgt[sw_idx])\n\t\t\tcontinue;\n\t\tres = vcap_verify_typegroups(stream, vctrl->vcaps[vt].act_width,\n\t\t\t\t\t     tgt[sw_idx], false, sw_max);\n\t\tif (res == 0)\n\t\t\treturn sw_idx;\n\t}\n\treturn -EINVAL;\n}\n\n \nstatic enum vcap_actionfield_set\nvcap_find_actionstream_actionset(struct vcap_control *vctrl,\n\t\t\t\t enum vcap_type vt,\n\t\t\t\t u32 *stream,\n\t\t\t\t int sw_max)\n{\n\tconst struct vcap_set *actionfield_set;\n\tint sw_count, idx;\n\tbool res;\n\n\tsw_count = vcap_find_actionstream_typegroup_sw(vctrl, vt, stream,\n\t\t\t\t\t\t       sw_max);\n\tif (sw_count < 0)\n\t\treturn sw_count;\n\n\tactionfield_set = vctrl->vcaps[vt].actionfield_set;\n\tfor (idx = 0; idx < vctrl->vcaps[vt].actionfield_set_size; ++idx) {\n\t\tif (actionfield_set[idx].sw_per_item != sw_count)\n\t\t\tcontinue;\n\n\t\tres = vcap_verify_actionstream_actionset(vctrl, vt,\n\t\t\t\t\t\t\t stream, idx);\n\t\tif (res)\n\t\t\treturn idx;\n\t}\n\treturn -EINVAL;\n}\n\n \nstatic void vcap_rule_alloc_actionfield(struct vcap_rule_internal *ri,\n\t\t\t\t\tconst struct vcap_field *actionfield,\n\t\t\t\t\tenum vcap_action_field action,\n\t\t\t\t\tu8 *value)\n{\n\tstruct vcap_client_actionfield *field;\n\n\tfield = kzalloc(sizeof(*field), GFP_KERNEL);\n\tif (!field)\n\t\treturn;\n\tINIT_LIST_HEAD(&field->ctrl.list);\n\tfield->ctrl.action = action;\n\tfield->ctrl.type = actionfield->type;\n\tvcap_copy_to_client_actionfield(ri, field, value, actionfield->width);\n\tlist_add_tail(&field->ctrl.list, &ri->data.actionfields);\n}\n\nstatic int vcap_decode_actionset(struct vcap_rule_internal *ri)\n{\n\tstruct vcap_control *vctrl = ri->vctrl;\n\tstruct vcap_admin *admin = ri->admin;\n\tconst struct vcap_field *actionfield;\n\tenum vcap_actionfield_set actionset;\n\tenum vcap_type vt = admin->vtype;\n\tconst struct vcap_typegroup *tgt;\n\tstruct vcap_stream_iter iter;\n\tint idx, res, actfield_count;\n\tu32 *actstream;\n\tu8 value[16];\n\n\tactstream = admin->cache.actionstream;\n\tres = vcap_find_actionstream_actionset(vctrl, vt, actstream, 0);\n\tif (res < 0) {\n\t\tpr_err(\"%s:%d: could not find valid actionset: %d\\n\",\n\t\t       __func__, __LINE__, res);\n\t\treturn -EINVAL;\n\t}\n\tactionset = res;\n\tactfield_count = vcap_actionfield_count(vctrl, vt, actionset);\n\tactionfield = vcap_actionfields(vctrl, vt, actionset);\n\ttgt = vcap_actionfield_typegroup(vctrl, vt, actionset);\n\t \n\tfor (idx = 0; idx < actfield_count; ++idx) {\n\t\tif (actionfield[idx].width <= 0)\n\t\t\tcontinue;\n\t\t \n\t\tmemset(value, 0, DIV_ROUND_UP(actionfield[idx].width, 8));\n\t\tvcap_iter_init(&iter, vctrl->vcaps[vt].act_width, tgt,\n\t\t\t       actionfield[idx].offset);\n\t\tvcap_decode_field(actstream, &iter, actionfield[idx].width,\n\t\t\t\t  value);\n\t\t \n\t\tif (vcap_bitarray_zero(actionfield[idx].width, value))\n\t\t\tcontinue;\n\t\tvcap_rule_alloc_actionfield(ri, &actionfield[idx], idx, value);\n\t\t \n\t}\n\treturn vcap_set_rule_set_actionset((struct vcap_rule *)ri, actionset);\n}\n\nstatic int vcap_decode_keyset(struct vcap_rule_internal *ri)\n{\n\tstruct vcap_control *vctrl = ri->vctrl;\n\tstruct vcap_stream_iter kiter, miter;\n\tstruct vcap_admin *admin = ri->admin;\n\tenum vcap_keyfield_set keysets[10];\n\tconst struct vcap_field *keyfield;\n\tenum vcap_type vt = admin->vtype;\n\tconst struct vcap_typegroup *tgt;\n\tstruct vcap_keyset_list matches;\n\tenum vcap_keyfield_set keyset;\n\tint idx, res, keyfield_count;\n\tu32 *maskstream;\n\tu32 *keystream;\n\tu8 value[16];\n\tu8 mask[16];\n\n\tkeystream = admin->cache.keystream;\n\tmaskstream = admin->cache.maskstream;\n\tmatches.keysets = keysets;\n\tmatches.cnt = 0;\n\tmatches.max = ARRAY_SIZE(keysets);\n\tres = vcap_find_keystream_keysets(vctrl, vt, keystream, maskstream,\n\t\t\t\t\t  false, 0, &matches);\n\tif (res < 0) {\n\t\tpr_err(\"%s:%d: could not find valid keysets: %d\\n\",\n\t\t       __func__, __LINE__, res);\n\t\treturn -EINVAL;\n\t}\n\tkeyset = matches.keysets[0];\n\tkeyfield_count = vcap_keyfield_count(vctrl, vt, keyset);\n\tkeyfield = vcap_keyfields(vctrl, vt, keyset);\n\ttgt = vcap_keyfield_typegroup(vctrl, vt, keyset);\n\t \n\tfor (idx = 0; idx < keyfield_count; ++idx) {\n\t\tif (keyfield[idx].width <= 0)\n\t\t\tcontinue;\n\t\t \n\t\tmemset(mask, 0, DIV_ROUND_UP(keyfield[idx].width, 8));\n\t\tvcap_iter_init(&miter, vctrl->vcaps[vt].sw_width, tgt,\n\t\t\t       keyfield[idx].offset);\n\t\tvcap_decode_field(maskstream, &miter, keyfield[idx].width,\n\t\t\t\t  mask);\n\t\t \n\t\tif (vcap_bitarray_zero(keyfield[idx].width, mask))\n\t\t\tcontinue;\n\t\t \n\t\tmemset(value, 0, DIV_ROUND_UP(keyfield[idx].width, 8));\n\t\tvcap_iter_init(&kiter, vctrl->vcaps[vt].sw_width, tgt,\n\t\t\t       keyfield[idx].offset);\n\t\tvcap_decode_field(keystream, &kiter, keyfield[idx].width,\n\t\t\t\t  value);\n\t\tvcap_rule_alloc_keyfield(ri, &keyfield[idx], idx, value, mask);\n\t}\n\treturn vcap_set_rule_set_keyset((struct vcap_rule *)ri, keyset);\n}\n\n \nstatic int vcap_read_rule(struct vcap_rule_internal *ri)\n{\n\tstruct vcap_admin *admin = ri->admin;\n\tint sw_idx, ent_idx = 0, act_idx = 0;\n\tu32 addr = ri->addr;\n\n\tif (!ri->size || !ri->keyset_sw_regs || !ri->actionset_sw_regs) {\n\t\tpr_err(\"%s:%d: rule is empty\\n\", __func__, __LINE__);\n\t\treturn -EINVAL;\n\t}\n\tvcap_erase_cache(ri);\n\t \n\tfor (sw_idx = 0; sw_idx < ri->size; sw_idx++, addr++) {\n\t\tri->vctrl->ops->update(ri->ndev, admin, VCAP_CMD_READ,\n\t\t\t\t       VCAP_SEL_ALL, addr);\n\t\tri->vctrl->ops->cache_read(ri->ndev, admin,\n\t\t\t\t\t   VCAP_SEL_ENTRY, ent_idx,\n\t\t\t\t\t   ri->keyset_sw_regs);\n\t\tri->vctrl->ops->cache_read(ri->ndev, admin,\n\t\t\t\t\t   VCAP_SEL_ACTION, act_idx,\n\t\t\t\t\t   ri->actionset_sw_regs);\n\t\tif (sw_idx == 0)\n\t\t\tri->vctrl->ops->cache_read(ri->ndev, admin,\n\t\t\t\t\t\t   VCAP_SEL_COUNTER,\n\t\t\t\t\t\t   ri->counter_id, 0);\n\t\tent_idx += ri->keyset_sw_regs;\n\t\tact_idx += ri->actionset_sw_regs;\n\t}\n\treturn 0;\n}\n\n \nstatic int vcap_write_rule(struct vcap_rule_internal *ri)\n{\n\tstruct vcap_admin *admin = ri->admin;\n\tint sw_idx, ent_idx = 0, act_idx = 0;\n\tu32 addr = ri->addr;\n\n\tif (!ri->size || !ri->keyset_sw_regs || !ri->actionset_sw_regs) {\n\t\tpr_err(\"%s:%d: rule is empty\\n\", __func__, __LINE__);\n\t\treturn -EINVAL;\n\t}\n\t \n\tfor (sw_idx = 0; sw_idx < ri->size; sw_idx++, addr++) {\n\t\tri->vctrl->ops->cache_write(ri->ndev, admin,\n\t\t\t\t\t    VCAP_SEL_ENTRY, ent_idx,\n\t\t\t\t\t    ri->keyset_sw_regs);\n\t\tri->vctrl->ops->cache_write(ri->ndev, admin,\n\t\t\t\t\t    VCAP_SEL_ACTION, act_idx,\n\t\t\t\t\t    ri->actionset_sw_regs);\n\t\tri->vctrl->ops->update(ri->ndev, admin, VCAP_CMD_WRITE,\n\t\t\t\t       VCAP_SEL_ALL, addr);\n\t\tent_idx += ri->keyset_sw_regs;\n\t\tact_idx += ri->actionset_sw_regs;\n\t}\n\treturn 0;\n}\n\nstatic int vcap_write_counter(struct vcap_rule_internal *ri,\n\t\t\t      struct vcap_counter *ctr)\n{\n\tstruct vcap_admin *admin = ri->admin;\n\n\tadmin->cache.counter = ctr->value;\n\tadmin->cache.sticky = ctr->sticky;\n\tri->vctrl->ops->cache_write(ri->ndev, admin, VCAP_SEL_COUNTER,\n\t\t\t\t    ri->counter_id, 0);\n\tri->vctrl->ops->update(ri->ndev, admin, VCAP_CMD_WRITE,\n\t\t\t       VCAP_SEL_COUNTER, ri->addr);\n\treturn 0;\n}\n\n \nint vcap_chain_id_to_lookup(struct vcap_admin *admin, int cur_cid)\n{\n\tint lookup_first = admin->vinst * admin->lookups_per_instance;\n\tint lookup_last = lookup_first + admin->lookups_per_instance;\n\tint cid_next = admin->first_cid + VCAP_CID_LOOKUP_SIZE;\n\tint cid = admin->first_cid;\n\tint lookup;\n\n\tfor (lookup = lookup_first; lookup < lookup_last; ++lookup,\n\t     cid += VCAP_CID_LOOKUP_SIZE, cid_next += VCAP_CID_LOOKUP_SIZE)\n\t\tif (cur_cid >= cid && cur_cid < cid_next)\n\t\t\treturn lookup;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(vcap_chain_id_to_lookup);\n\n \nstruct vcap_admin *vcap_find_admin(struct vcap_control *vctrl, int cid)\n{\n\tstruct vcap_admin *admin;\n\n\tif (vcap_api_check(vctrl))\n\t\treturn NULL;\n\n\tlist_for_each_entry(admin, &vctrl->list, list) {\n\t\tif (cid >= admin->first_cid && cid <= admin->last_cid)\n\t\t\treturn admin;\n\t}\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(vcap_find_admin);\n\n \nstatic bool vcap_admin_is_last(struct vcap_control *vctrl,\n\t\t\t       struct vcap_admin *admin,\n\t\t\t       bool ingress)\n{\n\tstruct vcap_admin *iter, *last = NULL;\n\tint max_cid = 0;\n\n\tlist_for_each_entry(iter, &vctrl->list, list) {\n\t\tif (iter->first_cid > max_cid &&\n\t\t    iter->ingress == ingress) {\n\t\t\tlast = iter;\n\t\t\tmax_cid = iter->first_cid;\n\t\t}\n\t}\n\tif (!last)\n\t\treturn false;\n\n\treturn admin == last;\n}\n\n \nint vcap_chain_offset(struct vcap_control *vctrl, int from_cid, int to_cid)\n{\n\tint diff = to_cid - from_cid;\n\n\tif (diff < 0)  \n\t\treturn diff;\n\tto_cid %= VCAP_CID_LOOKUP_SIZE;\n\tif (to_cid == 0)   \n\t\treturn 0;\n\tdiff %= VCAP_CID_LOOKUP_SIZE;   \n\treturn diff;\n}\nEXPORT_SYMBOL_GPL(vcap_chain_offset);\n\n \nbool vcap_is_next_lookup(struct vcap_control *vctrl, int src_cid, int dst_cid)\n{\n\tstruct vcap_admin *admin;\n\tint next_cid;\n\n\tif (vcap_api_check(vctrl))\n\t\treturn false;\n\n\t \n\tnext_cid = roundup(src_cid + 1, VCAP_CID_LOOKUP_SIZE);\n\n\tif (dst_cid < next_cid)\n\t\treturn false;\n\n\tadmin = vcap_find_admin(vctrl, dst_cid);\n\tif (!admin)\n\t\treturn false;\n\n\treturn true;\n}\nEXPORT_SYMBOL_GPL(vcap_is_next_lookup);\n\n \nstatic int vcap_rule_space(struct vcap_admin *admin, int size)\n{\n\tif (admin->last_used_addr - size < admin->first_valid_addr) {\n\t\tpr_err(\"%s:%d: No room for rule size: %u, %u\\n\",\n\t\t       __func__, __LINE__, size, admin->first_valid_addr);\n\t\treturn -ENOSPC;\n\t}\n\treturn 0;\n}\n\n \nstatic int vcap_add_type_keyfield(struct vcap_rule *rule)\n{\n\tstruct vcap_rule_internal *ri = to_intrule(rule);\n\tenum vcap_keyfield_set keyset = rule->keyset;\n\tenum vcap_type vt = ri->admin->vtype;\n\tconst struct vcap_field *fields;\n\tconst struct vcap_set *kset;\n\tint ret = -EINVAL;\n\n\tkset = vcap_keyfieldset(ri->vctrl, vt, keyset);\n\tif (!kset)\n\t\treturn ret;\n\tif (kset->type_id == (u8)-1)   \n\t\treturn 0;\n\n\tfields = vcap_keyfields(ri->vctrl, vt, keyset);\n\tif (!fields)\n\t\treturn -EINVAL;\n\tif (fields[VCAP_KF_TYPE].width > 1) {\n\t\tret = vcap_rule_add_key_u32(rule, VCAP_KF_TYPE,\n\t\t\t\t\t    kset->type_id, 0xff);\n\t} else {\n\t\tif (kset->type_id)\n\t\t\tret = vcap_rule_add_key_bit(rule, VCAP_KF_TYPE,\n\t\t\t\t\t\t    VCAP_BIT_1);\n\t\telse\n\t\t\tret = vcap_rule_add_key_bit(rule, VCAP_KF_TYPE,\n\t\t\t\t\t\t    VCAP_BIT_0);\n\t}\n\treturn 0;\n}\n\n \nstatic int vcap_add_type_actionfield(struct vcap_rule *rule)\n{\n\tenum vcap_actionfield_set actionset = rule->actionset;\n\tstruct vcap_rule_internal *ri = to_intrule(rule);\n\tenum vcap_type vt = ri->admin->vtype;\n\tconst struct vcap_field *fields;\n\tconst struct vcap_set *aset;\n\tint ret = -EINVAL;\n\n\taset = vcap_actionfieldset(ri->vctrl, vt, actionset);\n\tif (!aset)\n\t\treturn ret;\n\tif (aset->type_id == (u8)-1)   \n\t\treturn 0;\n\n\tfields = vcap_actionfields(ri->vctrl, vt, actionset);\n\tif (!fields)\n\t\treturn -EINVAL;\n\tif (fields[VCAP_AF_TYPE].width > 1) {\n\t\tret = vcap_rule_add_action_u32(rule, VCAP_AF_TYPE,\n\t\t\t\t\t       aset->type_id);\n\t} else {\n\t\tif (aset->type_id)\n\t\t\tret = vcap_rule_add_action_bit(rule, VCAP_AF_TYPE,\n\t\t\t\t\t\t       VCAP_BIT_1);\n\t\telse\n\t\t\tret = vcap_rule_add_action_bit(rule, VCAP_AF_TYPE,\n\t\t\t\t\t\t       VCAP_BIT_0);\n\t}\n\treturn ret;\n}\n\n \nbool vcap_keyset_list_add(struct vcap_keyset_list *keysetlist,\n\t\t\t  enum vcap_keyfield_set keyset)\n{\n\tint idx;\n\n\tif (keysetlist->cnt < keysetlist->max) {\n\t\t \n\t\tfor (idx = 0; idx < keysetlist->cnt; ++idx)\n\t\t\tif (keysetlist->keysets[idx] == keyset)\n\t\t\t\treturn keysetlist->cnt < keysetlist->max;\n\t\tkeysetlist->keysets[keysetlist->cnt++] = keyset;\n\t}\n\treturn keysetlist->cnt < keysetlist->max;\n}\nEXPORT_SYMBOL_GPL(vcap_keyset_list_add);\n\n \nstatic bool vcap_actionset_list_add(struct vcap_actionset_list *actionsetlist,\n\t\t\t\t    enum vcap_actionfield_set actionset)\n{\n\tint idx;\n\n\tif (actionsetlist->cnt < actionsetlist->max) {\n\t\t \n\t\tfor (idx = 0; idx < actionsetlist->cnt; ++idx)\n\t\t\tif (actionsetlist->actionsets[idx] == actionset)\n\t\t\t\treturn actionsetlist->cnt < actionsetlist->max;\n\t\tactionsetlist->actionsets[actionsetlist->cnt++] = actionset;\n\t}\n\treturn actionsetlist->cnt < actionsetlist->max;\n}\n\n \nconst char *vcap_keyset_name(struct vcap_control *vctrl,\n\t\t\t     enum vcap_keyfield_set keyset)\n{\n\treturn vctrl->stats->keyfield_set_names[keyset];\n}\nEXPORT_SYMBOL_GPL(vcap_keyset_name);\n\n \nconst char *vcap_keyfield_name(struct vcap_control *vctrl,\n\t\t\t       enum vcap_key_field key)\n{\n\treturn vctrl->stats->keyfield_names[key];\n}\nEXPORT_SYMBOL_GPL(vcap_keyfield_name);\n\n \nconst char *vcap_actionset_name(struct vcap_control *vctrl,\n\t\t\t\tenum vcap_actionfield_set actionset)\n{\n\treturn vctrl->stats->actionfield_set_names[actionset];\n}\n\n \nconst char *vcap_actionfield_name(struct vcap_control *vctrl,\n\t\t\t\t  enum vcap_action_field action)\n{\n\treturn vctrl->stats->actionfield_names[action];\n}\n\n \nstatic const struct vcap_field *\nvcap_find_keyset_keyfield(struct vcap_control *vctrl,\n\t\t\t  enum vcap_type vtype,\n\t\t\t  enum vcap_keyfield_set keyset,\n\t\t\t  enum vcap_key_field key)\n{\n\tconst struct vcap_field *fields;\n\tint idx, count;\n\n\tfields = vcap_keyfields(vctrl, vtype, keyset);\n\tif (!fields)\n\t\treturn NULL;\n\n\t \n\tcount = vcap_keyfield_count(vctrl, vtype, keyset);\n\tfor (idx = 0; idx < count; ++idx) {\n\t\tif (fields[idx].width == 0)\n\t\t\tcontinue;\n\n\t\tif (key == idx)\n\t\t\treturn &fields[idx];\n\t}\n\n\treturn NULL;\n}\n\n \nstatic bool _vcap_rule_find_keysets(struct vcap_rule_internal *ri,\n\t\t\t\t    struct vcap_keyset_list *matches)\n{\n\tconst struct vcap_client_keyfield *ckf;\n\tint keyset, found, keycount, map_size;\n\tconst struct vcap_field **map;\n\tenum vcap_type vtype;\n\n\tvtype = ri->admin->vtype;\n\tmap = ri->vctrl->vcaps[vtype].keyfield_set_map;\n\tmap_size = ri->vctrl->vcaps[vtype].keyfield_set_size;\n\n\t \n\tkeycount = 0;\n\tlist_for_each_entry(ckf, &ri->data.keyfields, ctrl.list)\n\t\t++keycount;\n\n\tmatches->cnt = 0;\n\t \n\tfor (keyset = 0; keyset < map_size; ++keyset) {\n\t\tif (!map[keyset])\n\t\t\tcontinue;\n\n\t\t \n\t\tfound = 0;\n\t\tlist_for_each_entry(ckf, &ri->data.keyfields, ctrl.list)\n\t\t\tif (vcap_find_keyset_keyfield(ri->vctrl, vtype,\n\t\t\t\t\t\t      keyset, ckf->ctrl.key))\n\t\t\t\t++found;\n\n\t\t \n\t\tif (found == keycount)\n\t\t\tif (!vcap_keyset_list_add(matches, keyset))\n\t\t\t\t \n\t\t\t\tbreak;\n\t}\n\n\treturn matches->cnt > 0;\n}\n\n \nbool vcap_rule_find_keysets(struct vcap_rule *rule,\n\t\t\t    struct vcap_keyset_list *matches)\n{\n\tstruct vcap_rule_internal *ri = to_intrule(rule);\n\n\treturn _vcap_rule_find_keysets(ri, matches);\n}\nEXPORT_SYMBOL_GPL(vcap_rule_find_keysets);\n\n \nstatic const struct vcap_field *\nvcap_find_actionset_actionfield(struct vcap_control *vctrl,\n\t\t\t\tenum vcap_type vtype,\n\t\t\t\tenum vcap_actionfield_set actionset,\n\t\t\t\tenum vcap_action_field action)\n{\n\tconst struct vcap_field *fields;\n\tint idx, count;\n\n\tfields = vcap_actionfields(vctrl, vtype, actionset);\n\tif (!fields)\n\t\treturn NULL;\n\n\t \n\tcount = vcap_actionfield_count(vctrl, vtype, actionset);\n\tfor (idx = 0; idx < count; ++idx) {\n\t\tif (fields[idx].width == 0)\n\t\t\tcontinue;\n\n\t\tif (action == idx)\n\t\t\treturn &fields[idx];\n\t}\n\n\treturn NULL;\n}\n\n \nstatic bool vcap_rule_find_actionsets(struct vcap_rule_internal *ri,\n\t\t\t\t      struct vcap_actionset_list *matches)\n{\n\tint actionset, found, actioncount, map_size;\n\tconst struct vcap_client_actionfield *ckf;\n\tconst struct vcap_field **map;\n\tenum vcap_type vtype;\n\n\tvtype = ri->admin->vtype;\n\tmap = ri->vctrl->vcaps[vtype].actionfield_set_map;\n\tmap_size = ri->vctrl->vcaps[vtype].actionfield_set_size;\n\n\t \n\tactioncount = 0;\n\tlist_for_each_entry(ckf, &ri->data.actionfields, ctrl.list)\n\t\t++actioncount;\n\n\tmatches->cnt = 0;\n\t \n\tfor (actionset = 0; actionset < map_size; ++actionset) {\n\t\tif (!map[actionset])\n\t\t\tcontinue;\n\n\t\t \n\t\tfound = 0;\n\t\tlist_for_each_entry(ckf, &ri->data.actionfields, ctrl.list)\n\t\t\tif (vcap_find_actionset_actionfield(ri->vctrl, vtype,\n\t\t\t\t\t\t\t    actionset,\n\t\t\t\t\t\t\t    ckf->ctrl.action))\n\t\t\t\t++found;\n\n\t\t \n\t\tif (found == actioncount)\n\t\t\tif (!vcap_actionset_list_add(matches, actionset))\n\t\t\t\t \n\t\t\t\tbreak;\n\t}\n\n\treturn matches->cnt > 0;\n}\n\n \nint vcap_val_rule(struct vcap_rule *rule, u16 l3_proto)\n{\n\tstruct vcap_rule_internal *ri = to_intrule(rule);\n\tstruct vcap_keyset_list matches = {};\n\tenum vcap_keyfield_set keysets[10];\n\tint ret;\n\n\tret = vcap_api_check(ri->vctrl);\n\tif (ret)\n\t\treturn ret;\n\tif (!ri->admin) {\n\t\tri->data.exterr = VCAP_ERR_NO_ADMIN;\n\t\treturn -EINVAL;\n\t}\n\tif (!ri->ndev) {\n\t\tri->data.exterr = VCAP_ERR_NO_NETDEV;\n\t\treturn -EINVAL;\n\t}\n\n\tmatches.keysets = keysets;\n\tmatches.max = ARRAY_SIZE(keysets);\n\tif (ri->data.keyset == VCAP_KFS_NO_VALUE) {\n\t\t \n\t\tif (!_vcap_rule_find_keysets(ri, &matches)) {\n\t\t\tri->data.exterr = VCAP_ERR_NO_KEYSET_MATCH;\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\t \n\t\tkeysets[0] = ri->data.keyset;\n\t\tmatches.cnt = 1;\n\t}\n\n\t \n\tret = ri->vctrl->ops->validate_keyset(ri->ndev, ri->admin, rule,\n\t\t\t\t\t      &matches, l3_proto);\n\tif (ret < 0) {\n\t\tpr_err(\"%s:%d: keyset validation failed: %d\\n\",\n\t\t       __func__, __LINE__, ret);\n\t\tri->data.exterr = VCAP_ERR_NO_PORT_KEYSET_MATCH;\n\t\treturn ret;\n\t}\n\t \n\tret = vcap_set_rule_set_keyset(rule, ret);\n\tif (ret < 0) {\n\t\tpr_err(\"%s:%d: keyset was not updated: %d\\n\",\n\t\t       __func__, __LINE__, ret);\n\t\treturn ret;\n\t}\n\tif (ri->data.actionset == VCAP_AFS_NO_VALUE) {\n\t\tstruct vcap_actionset_list matches = {};\n\t\tenum vcap_actionfield_set actionsets[10];\n\n\t\tmatches.actionsets = actionsets;\n\t\tmatches.max = ARRAY_SIZE(actionsets);\n\n\t\t \n\t\tif (!vcap_rule_find_actionsets(ri, &matches)) {\n\t\t\tri->data.exterr = VCAP_ERR_NO_ACTIONSET_MATCH;\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tret = vcap_set_rule_set_actionset(rule, actionsets[0]);\n\t\tif (ret < 0) {\n\t\t\tpr_err(\"%s:%d: actionset was not updated: %d\\n\",\n\t\t\t       __func__, __LINE__, ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\tvcap_add_type_keyfield(rule);\n\tvcap_add_type_actionfield(rule);\n\t \n\tri->vctrl->ops->add_default_fields(ri->ndev, ri->admin, rule);\n\n\t \n\tri->size = max(ri->keyset_sw, ri->actionset_sw);\n\n\t \n\treturn vcap_rule_space(ri->admin, ri->size);\n}\nEXPORT_SYMBOL_GPL(vcap_val_rule);\n\n \nstatic u32 vcap_sort_key(u32 max_size, u32 size, u8 user, u16 prio)\n{\n\treturn ((max_size - size) << 24) | (user << 16) | prio;\n}\n\n \nstatic u32 vcap_next_rule_addr(u32 addr, struct vcap_rule_internal *ri)\n{\n\treturn ((addr - ri->size) /  ri->size) * ri->size;\n}\n\n \nstatic u32 vcap_set_rule_id(struct vcap_rule_internal *ri)\n{\n\tif (ri->data.id != 0)\n\t\treturn ri->data.id;\n\n\tfor (u32 next_id = 1; next_id < ~0; ++next_id) {\n\t\tif (!vcap_rule_exists(ri->vctrl, next_id)) {\n\t\t\tri->data.id = next_id;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ri->data.id;\n}\n\nstatic int vcap_insert_rule(struct vcap_rule_internal *ri,\n\t\t\t    struct vcap_rule_move *move)\n{\n\tint sw_count = ri->vctrl->vcaps[ri->admin->vtype].sw_count;\n\tstruct vcap_rule_internal *duprule, *iter, *elem = NULL;\n\tstruct vcap_admin *admin = ri->admin;\n\tu32 addr;\n\n\tri->sort_key = vcap_sort_key(sw_count, ri->size, ri->data.user,\n\t\t\t\t     ri->data.priority);\n\n\t \n\tlist_for_each_entry(iter, &admin->rules, list) {\n\t\tif (ri->sort_key < iter->sort_key) {\n\t\t\telem = iter;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!elem) {\n\t\tri->addr = vcap_next_rule_addr(admin->last_used_addr, ri);\n\t\tadmin->last_used_addr = ri->addr;\n\n\t\t \n\t\tduprule = vcap_dup_rule(ri, ri->state == VCAP_RS_DISABLED);\n\t\tif (IS_ERR(duprule))\n\t\t\treturn PTR_ERR(duprule);\n\n\t\tlist_add_tail(&duprule->list, &admin->rules);\n\t\treturn 0;\n\t}\n\n\t \n\taddr = elem->addr + elem->size;\n\tri->addr = vcap_next_rule_addr(addr, ri);\n\taddr = ri->addr;\n\n\t \n\tduprule = vcap_dup_rule(ri, ri->state == VCAP_RS_DISABLED);\n\tif (IS_ERR(duprule))\n\t\treturn PTR_ERR(duprule);\n\n\t \n\tlist_add_tail(&duprule->list, &elem->list);\n\n\t \n\telem->addr = vcap_next_rule_addr(addr, elem);\n\taddr = elem->addr;\n\n\t \n\tlist_for_each_entry_continue(elem, &admin->rules, list) {\n\t\telem->addr = vcap_next_rule_addr(addr, elem);\n\t\taddr = elem->addr;\n\t}\n\n\t \n\tmove->addr = admin->last_used_addr;\n\tmove->count = ri->addr - addr;\n\tmove->offset = admin->last_used_addr - addr;\n\tadmin->last_used_addr = addr;\n\treturn 0;\n}\n\nstatic void vcap_move_rules(struct vcap_rule_internal *ri,\n\t\t\t    struct vcap_rule_move *move)\n{\n\tri->vctrl->ops->move(ri->ndev, ri->admin, move->addr,\n\t\t\t move->offset, move->count);\n}\n\n \nstatic bool vcap_is_chain_used(struct vcap_control *vctrl,\n\t\t\t       struct net_device *ndev, int src_cid)\n{\n\tstruct vcap_enabled_port *eport;\n\tstruct vcap_admin *admin;\n\n\tlist_for_each_entry(admin, &vctrl->list, list)\n\t\tlist_for_each_entry(eport, &admin->enabled, list)\n\t\t\tif (eport->src_cid == src_cid && eport->ndev == ndev)\n\t\t\t\treturn true;\n\n\treturn false;\n}\n\n \nstatic int vcap_get_next_chain(struct vcap_control *vctrl,\n\t\t\t       struct net_device *ndev,\n\t\t\t       int dst_cid)\n{\n\tstruct vcap_enabled_port *eport;\n\tstruct vcap_admin *admin;\n\n\tlist_for_each_entry(admin, &vctrl->list, list) {\n\t\tlist_for_each_entry(eport, &admin->enabled, list) {\n\t\t\tif (eport->ndev != ndev)\n\t\t\t\tcontinue;\n\t\t\tif (eport->src_cid == dst_cid)\n\t\t\t\treturn eport->dst_cid;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic bool vcap_path_exist(struct vcap_control *vctrl, struct net_device *ndev,\n\t\t\t    int dst_cid)\n{\n\tint cid = rounddown(dst_cid, VCAP_CID_LOOKUP_SIZE);\n\tstruct vcap_enabled_port *eport = NULL;\n\tstruct vcap_enabled_port *elem;\n\tstruct vcap_admin *admin;\n\tint tmp;\n\n\tif (cid == 0)  \n\t\treturn true;\n\n\t \n\tlist_for_each_entry(admin, &vctrl->list, list) {\n\t\tlist_for_each_entry(elem, &admin->enabled, list) {\n\t\t\tif (elem->src_cid == 0 && elem->ndev == ndev) {\n\t\t\t\teport = elem;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (eport)\n\t\t\tbreak;\n\t}\n\n\tif (!eport)\n\t\treturn false;\n\n\ttmp = eport->dst_cid;\n\twhile (tmp != cid && tmp != 0)\n\t\ttmp = vcap_get_next_chain(vctrl, ndev, tmp);\n\n\treturn !!tmp;\n}\n\n \nstatic void vcap_rule_set_state(struct vcap_rule_internal *ri)\n{\n\tif (ri->data.user <= VCAP_USER_QOS)\n\t\tri->state = VCAP_RS_PERMANENT;\n\telse if (vcap_path_exist(ri->vctrl, ri->ndev, ri->data.vcap_chain_id))\n\t\tri->state = VCAP_RS_ENABLED;\n\telse\n\t\tri->state = VCAP_RS_DISABLED;\n}\n\n \nint vcap_add_rule(struct vcap_rule *rule)\n{\n\tstruct vcap_rule_internal *ri = to_intrule(rule);\n\tstruct vcap_rule_move move = {0};\n\tstruct vcap_counter ctr = {0};\n\tint ret;\n\n\tret = vcap_api_check(ri->vctrl);\n\tif (ret)\n\t\treturn ret;\n\t \n\tmutex_lock(&ri->admin->lock);\n\n\tvcap_rule_set_state(ri);\n\tret = vcap_insert_rule(ri, &move);\n\tif (ret < 0) {\n\t\tpr_err(\"%s:%d: could not insert rule in vcap list: %d\\n\",\n\t\t       __func__, __LINE__, ret);\n\t\tgoto out;\n\t}\n\tif (move.count > 0)\n\t\tvcap_move_rules(ri, &move);\n\n\t \n\tret = vcap_write_counter(ri, &ctr);\n\tif (ret)\n\t\tgoto out;\n\n\tif (ri->state == VCAP_RS_DISABLED) {\n\t\t \n\t\tri->vctrl->ops->init(ri->ndev, ri->admin, ri->addr, ri->size);\n\t\tgoto out;\n\t}\n\n\tvcap_erase_cache(ri);\n\tret = vcap_encode_rule(ri);\n\tif (ret) {\n\t\tpr_err(\"%s:%d: rule encoding error: %d\\n\", __func__, __LINE__, ret);\n\t\tgoto out;\n\t}\n\n\tret = vcap_write_rule(ri);\n\tif (ret) {\n\t\tpr_err(\"%s:%d: rule write error: %d\\n\", __func__, __LINE__, ret);\n\t\tgoto out;\n\t}\nout:\n\tmutex_unlock(&ri->admin->lock);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(vcap_add_rule);\n\n \nstruct vcap_rule *vcap_alloc_rule(struct vcap_control *vctrl,\n\t\t\t\t  struct net_device *ndev, int vcap_chain_id,\n\t\t\t\t  enum vcap_user user, u16 priority,\n\t\t\t\t  u32 id)\n{\n\tstruct vcap_rule_internal *ri;\n\tstruct vcap_admin *admin;\n\tint err, maxsize;\n\n\terr = vcap_api_check(vctrl);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\tif (!ndev)\n\t\treturn ERR_PTR(-ENODEV);\n\t \n\tadmin = vcap_find_admin(vctrl, vcap_chain_id);\n\tif (!admin)\n\t\treturn ERR_PTR(-ENOENT);\n\t \n\tif (vctrl->vcaps[admin->vtype].rows == 0)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tmutex_lock(&admin->lock);\n\t \n\tif (vcap_rule_exists(vctrl, id)) {\n\t\terr = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\t \n\tmaxsize = vctrl->vcaps[admin->vtype].sw_count;  \n\tif (vcap_rule_space(admin, maxsize)) {\n\t\terr = -ENOSPC;\n\t\tgoto out_unlock;\n\t}\n\n\t \n\tri = kzalloc(sizeof(*ri), GFP_KERNEL);\n\tif (!ri) {\n\t\terr = -ENOMEM;\n\t\tgoto out_unlock;\n\t}\n\n\tri->data.vcap_chain_id = vcap_chain_id;\n\tri->data.user = user;\n\tri->data.priority = priority;\n\tri->data.id = id;\n\tri->data.keyset = VCAP_KFS_NO_VALUE;\n\tri->data.actionset = VCAP_AFS_NO_VALUE;\n\tINIT_LIST_HEAD(&ri->list);\n\tINIT_LIST_HEAD(&ri->data.keyfields);\n\tINIT_LIST_HEAD(&ri->data.actionfields);\n\tri->ndev = ndev;\n\tri->admin = admin;  \n\tri->vctrl = vctrl;  \n\n\tif (vcap_set_rule_id(ri) == 0) {\n\t\terr = -EINVAL;\n\t\tgoto out_free;\n\t}\n\n\tmutex_unlock(&admin->lock);\n\treturn (struct vcap_rule *)ri;\n\nout_free:\n\tkfree(ri);\nout_unlock:\n\tmutex_unlock(&admin->lock);\n\treturn ERR_PTR(err);\n\n}\nEXPORT_SYMBOL_GPL(vcap_alloc_rule);\n\n \nvoid vcap_free_rule(struct vcap_rule *rule)\n{\n\tstruct vcap_rule_internal *ri = to_intrule(rule);\n\tstruct vcap_client_actionfield *caf, *next_caf;\n\tstruct vcap_client_keyfield *ckf, *next_ckf;\n\n\t \n\tlist_for_each_entry_safe(ckf, next_ckf, &ri->data.keyfields, ctrl.list) {\n\t\tlist_del(&ckf->ctrl.list);\n\t\tkfree(ckf);\n\t}\n\tlist_for_each_entry_safe(caf, next_caf, &ri->data.actionfields, ctrl.list) {\n\t\tlist_del(&caf->ctrl.list);\n\t\tkfree(caf);\n\t}\n\t \n\tkfree(rule);\n}\nEXPORT_SYMBOL_GPL(vcap_free_rule);\n\n \nstruct vcap_rule *vcap_decode_rule(struct vcap_rule_internal *elem)\n{\n\tstruct vcap_rule_internal *ri;\n\tint err;\n\n\tri = vcap_dup_rule(elem, elem->state == VCAP_RS_DISABLED);\n\tif (IS_ERR(ri))\n\t\treturn ERR_CAST(ri);\n\n\tif (ri->state == VCAP_RS_DISABLED)\n\t\tgoto out;\n\n\terr = vcap_read_rule(ri);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\terr = vcap_decode_keyset(ri);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\terr = vcap_decode_actionset(ri);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\nout:\n\treturn &ri->data;\n}\n\nstruct vcap_rule *vcap_get_rule(struct vcap_control *vctrl, u32 id)\n{\n\tstruct vcap_rule_internal *elem;\n\tstruct vcap_rule *rule;\n\tint err;\n\n\terr = vcap_api_check(vctrl);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\telem = vcap_get_locked_rule(vctrl, id);\n\tif (!elem)\n\t\treturn ERR_PTR(-ENOENT);\n\n\trule = vcap_decode_rule(elem);\n\tmutex_unlock(&elem->admin->lock);\n\treturn rule;\n}\nEXPORT_SYMBOL_GPL(vcap_get_rule);\n\n \nint vcap_mod_rule(struct vcap_rule *rule)\n{\n\tstruct vcap_rule_internal *ri = to_intrule(rule);\n\tstruct vcap_counter ctr;\n\tint err;\n\n\terr = vcap_api_check(ri->vctrl);\n\tif (err)\n\t\treturn err;\n\n\tif (!vcap_get_locked_rule(ri->vctrl, ri->data.id))\n\t\treturn -ENOENT;\n\n\tvcap_rule_set_state(ri);\n\tif (ri->state == VCAP_RS_DISABLED)\n\t\tgoto out;\n\n\t \n\tvcap_erase_cache(ri);\n\terr = vcap_encode_rule(ri);\n\tif (err)\n\t\tgoto out;\n\n\terr = vcap_write_rule(ri);\n\tif (err)\n\t\tgoto out;\n\n\tmemset(&ctr, 0, sizeof(ctr));\n\terr =  vcap_write_counter(ri, &ctr);\n\nout:\n\tmutex_unlock(&ri->admin->lock);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(vcap_mod_rule);\n\n \nstatic int vcap_valid_rule_move(struct vcap_rule_internal *el, int offset)\n{\n\treturn (el->addr + offset) % el->size;\n}\n\n \nstatic void vcap_adjust_rule_addr(struct vcap_rule_internal *el, int offset)\n{\n\tel->addr += offset;\n}\n\n \nstatic int vcap_fill_rule_gap(struct vcap_rule_internal *ri)\n{\n\tstruct vcap_admin *admin = ri->admin;\n\tstruct vcap_rule_internal *elem;\n\tstruct vcap_rule_move move;\n\tint gap = 0, offset = 0;\n\n\t \n\tif (list_is_first(&ri->list, &admin->rules))\n\t\toffset = admin->last_valid_addr + 1 - ri->addr - ri->size;\n\n\t \n\telem = ri;\n\tlist_for_each_entry_continue(elem, &admin->rules, list)\n\t\tgap += vcap_valid_rule_move(elem, ri->size);\n\n\t \n\telem = ri;\n\tlist_for_each_entry_continue(elem, &admin->rules, list)\n\t\tvcap_adjust_rule_addr(elem, ri->size + gap + offset);\n\n\t \n\tmove.addr = admin->last_used_addr;\n\tmove.count = ri->addr - admin->last_used_addr - gap;\n\tmove.offset = -(ri->size + gap + offset);\n\n\t \n\tvcap_move_rules(ri, &move);\n\n\treturn gap + offset;\n}\n\n \nint vcap_del_rule(struct vcap_control *vctrl, struct net_device *ndev, u32 id)\n{\n\tstruct vcap_rule_internal *ri, *elem;\n\tstruct vcap_admin *admin;\n\tint gap = 0, err;\n\n\t \n\tif (!ndev)\n\t\treturn -ENODEV;\n\terr = vcap_api_check(vctrl);\n\tif (err)\n\t\treturn err;\n\t \n\tri = vcap_get_locked_rule(vctrl, id);\n\tif (!ri)\n\t\treturn -ENOENT;\n\n\tadmin = ri->admin;\n\n\tif (ri->addr > admin->last_used_addr)\n\t\tgap = vcap_fill_rule_gap(ri);\n\n\t \n\tlist_del(&ri->list);\n\tvctrl->ops->init(ndev, admin, admin->last_used_addr, ri->size + gap);\n\tvcap_free_rule(&ri->data);\n\n\t \n\tif (list_empty(&admin->rules)) {\n\t\tadmin->last_used_addr = admin->last_valid_addr + 1;\n\t} else {\n\t\telem = list_last_entry(&admin->rules, struct vcap_rule_internal,\n\t\t\t\t       list);\n\t\tadmin->last_used_addr = elem->addr;\n\t}\n\n\tmutex_unlock(&admin->lock);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(vcap_del_rule);\n\n \nint vcap_del_rules(struct vcap_control *vctrl, struct vcap_admin *admin)\n{\n\tstruct vcap_enabled_port *eport, *next_eport;\n\tstruct vcap_rule_internal *ri, *next_ri;\n\tint ret = vcap_api_check(vctrl);\n\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&admin->lock);\n\tlist_for_each_entry_safe(ri, next_ri, &admin->rules, list) {\n\t\tvctrl->ops->init(ri->ndev, admin, ri->addr, ri->size);\n\t\tlist_del(&ri->list);\n\t\tvcap_free_rule(&ri->data);\n\t}\n\tadmin->last_used_addr = admin->last_valid_addr;\n\n\t \n\tlist_for_each_entry_safe(eport, next_eport, &admin->enabled, list) {\n\t\tlist_del(&eport->list);\n\t\tkfree(eport);\n\t}\n\tmutex_unlock(&admin->lock);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(vcap_del_rules);\n\n \nstatic struct vcap_client_keyfield *\nvcap_find_keyfield(struct vcap_rule *rule, enum vcap_key_field key)\n{\n\tstruct vcap_rule_internal *ri = to_intrule(rule);\n\tstruct vcap_client_keyfield *ckf;\n\n\tlist_for_each_entry(ckf, &ri->data.keyfields, ctrl.list)\n\t\tif (ckf->ctrl.key == key)\n\t\t\treturn ckf;\n\treturn NULL;\n}\n\n \nconst struct vcap_field *vcap_lookup_keyfield(struct vcap_rule *rule,\n\t\t\t\t\t      enum vcap_key_field key)\n{\n\tstruct vcap_rule_internal *ri = to_intrule(rule);\n\tenum vcap_keyfield_set keyset = rule->keyset;\n\tenum vcap_type vt = ri->admin->vtype;\n\tconst struct vcap_field *fields;\n\n\tif (keyset == VCAP_KFS_NO_VALUE)\n\t\treturn NULL;\n\tfields = vcap_keyfields(ri->vctrl, vt, keyset);\n\tif (!fields)\n\t\treturn NULL;\n\treturn &fields[key];\n}\nEXPORT_SYMBOL_GPL(vcap_lookup_keyfield);\n\n \nstatic bool vcap_keyfield_unique(struct vcap_rule *rule,\n\t\t\t\t enum vcap_key_field key)\n{\n\tstruct vcap_rule_internal *ri = to_intrule(rule);\n\tconst struct vcap_client_keyfield *ckf;\n\n\tlist_for_each_entry(ckf, &ri->data.keyfields, ctrl.list)\n\t\tif (ckf->ctrl.key == key)\n\t\t\treturn false;\n\treturn true;\n}\n\n \nstatic bool vcap_keyfield_match_keyset(struct vcap_rule *rule,\n\t\t\t\t       enum vcap_key_field key)\n{\n\tstruct vcap_rule_internal *ri = to_intrule(rule);\n\tenum vcap_keyfield_set keyset = rule->keyset;\n\tenum vcap_type vt = ri->admin->vtype;\n\tconst struct vcap_field *fields;\n\n\t \n\tif (keyset == VCAP_KFS_NO_VALUE)\n\t\treturn true;\n\tfields = vcap_keyfields(ri->vctrl, vt, keyset);\n\tif (!fields)\n\t\treturn false;\n\t \n\treturn fields[key].width > 0;\n}\n\nstatic int vcap_rule_add_key(struct vcap_rule *rule,\n\t\t\t     enum vcap_key_field key,\n\t\t\t     enum vcap_field_type ftype,\n\t\t\t     struct vcap_client_keyfield_data *data)\n{\n\tstruct vcap_rule_internal *ri = to_intrule(rule);\n\tstruct vcap_client_keyfield *field;\n\n\tif (!vcap_keyfield_unique(rule, key)) {\n\t\tpr_warn(\"%s:%d: keyfield %s is already in the rule\\n\",\n\t\t\t__func__, __LINE__,\n\t\t\tvcap_keyfield_name(ri->vctrl, key));\n\t\treturn -EINVAL;\n\t}\n\n\tif (!vcap_keyfield_match_keyset(rule, key)) {\n\t\tpr_err(\"%s:%d: keyfield %s does not belong in the rule keyset\\n\",\n\t\t       __func__, __LINE__,\n\t\t       vcap_keyfield_name(ri->vctrl, key));\n\t\treturn -EINVAL;\n\t}\n\n\tfield = kzalloc(sizeof(*field), GFP_KERNEL);\n\tif (!field)\n\t\treturn -ENOMEM;\n\tmemcpy(&field->data, data, sizeof(field->data));\n\tfield->ctrl.key = key;\n\tfield->ctrl.type = ftype;\n\tlist_add_tail(&field->ctrl.list, &rule->keyfields);\n\treturn 0;\n}\n\nstatic void vcap_rule_set_key_bitsize(struct vcap_u1_key *u1, enum vcap_bit val)\n{\n\tswitch (val) {\n\tcase VCAP_BIT_0:\n\t\tu1->value = 0;\n\t\tu1->mask = 1;\n\t\tbreak;\n\tcase VCAP_BIT_1:\n\t\tu1->value = 1;\n\t\tu1->mask = 1;\n\t\tbreak;\n\tcase VCAP_BIT_ANY:\n\t\tu1->value = 0;\n\t\tu1->mask = 0;\n\t\tbreak;\n\t}\n}\n\n \nint vcap_rule_add_key_bit(struct vcap_rule *rule, enum vcap_key_field key,\n\t\t\t  enum vcap_bit val)\n{\n\tstruct vcap_client_keyfield_data data;\n\n\tvcap_rule_set_key_bitsize(&data.u1, val);\n\treturn vcap_rule_add_key(rule, key, VCAP_FIELD_BIT, &data);\n}\nEXPORT_SYMBOL_GPL(vcap_rule_add_key_bit);\n\n \nint vcap_rule_add_key_u32(struct vcap_rule *rule, enum vcap_key_field key,\n\t\t\t  u32 value, u32 mask)\n{\n\tstruct vcap_client_keyfield_data data;\n\n\tdata.u32.value = value;\n\tdata.u32.mask = mask;\n\treturn vcap_rule_add_key(rule, key, VCAP_FIELD_U32, &data);\n}\nEXPORT_SYMBOL_GPL(vcap_rule_add_key_u32);\n\n \nint vcap_rule_add_key_u48(struct vcap_rule *rule, enum vcap_key_field key,\n\t\t\t  struct vcap_u48_key *fieldval)\n{\n\tstruct vcap_client_keyfield_data data;\n\n\tmemcpy(&data.u48, fieldval, sizeof(data.u48));\n\treturn vcap_rule_add_key(rule, key, VCAP_FIELD_U48, &data);\n}\nEXPORT_SYMBOL_GPL(vcap_rule_add_key_u48);\n\n \nint vcap_rule_add_key_u72(struct vcap_rule *rule, enum vcap_key_field key,\n\t\t\t  struct vcap_u72_key *fieldval)\n{\n\tstruct vcap_client_keyfield_data data;\n\n\tmemcpy(&data.u72, fieldval, sizeof(data.u72));\n\treturn vcap_rule_add_key(rule, key, VCAP_FIELD_U72, &data);\n}\nEXPORT_SYMBOL_GPL(vcap_rule_add_key_u72);\n\n \nint vcap_rule_add_key_u128(struct vcap_rule *rule, enum vcap_key_field key,\n\t\t\t   struct vcap_u128_key *fieldval)\n{\n\tstruct vcap_client_keyfield_data data;\n\n\tmemcpy(&data.u128, fieldval, sizeof(data.u128));\n\treturn vcap_rule_add_key(rule, key, VCAP_FIELD_U128, &data);\n}\nEXPORT_SYMBOL_GPL(vcap_rule_add_key_u128);\n\nint vcap_rule_get_key_u32(struct vcap_rule *rule, enum vcap_key_field key,\n\t\t\t  u32 *value, u32 *mask)\n{\n\tstruct vcap_client_keyfield *ckf;\n\n\tckf = vcap_find_keyfield(rule, key);\n\tif (!ckf)\n\t\treturn -ENOENT;\n\n\t*value = ckf->data.u32.value;\n\t*mask = ckf->data.u32.mask;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(vcap_rule_get_key_u32);\n\n \nstruct vcap_client_actionfield *\nvcap_find_actionfield(struct vcap_rule *rule, enum vcap_action_field act)\n{\n\tstruct vcap_rule_internal *ri = (struct vcap_rule_internal *)rule;\n\tstruct vcap_client_actionfield *caf;\n\n\tlist_for_each_entry(caf, &ri->data.actionfields, ctrl.list)\n\t\tif (caf->ctrl.action == act)\n\t\t\treturn caf;\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(vcap_find_actionfield);\n\n \nstatic bool vcap_actionfield_unique(struct vcap_rule *rule,\n\t\t\t\t    enum vcap_action_field act)\n{\n\tstruct vcap_rule_internal *ri = to_intrule(rule);\n\tconst struct vcap_client_actionfield *caf;\n\n\tlist_for_each_entry(caf, &ri->data.actionfields, ctrl.list)\n\t\tif (caf->ctrl.action == act)\n\t\t\treturn false;\n\treturn true;\n}\n\n \nstatic bool vcap_actionfield_match_actionset(struct vcap_rule *rule,\n\t\t\t\t\t     enum vcap_action_field action)\n{\n\tenum vcap_actionfield_set actionset = rule->actionset;\n\tstruct vcap_rule_internal *ri = to_intrule(rule);\n\tenum vcap_type vt = ri->admin->vtype;\n\tconst struct vcap_field *fields;\n\n\t \n\tif (actionset == VCAP_AFS_NO_VALUE)\n\t\treturn true;\n\tfields = vcap_actionfields(ri->vctrl, vt, actionset);\n\tif (!fields)\n\t\treturn false;\n\t \n\treturn fields[action].width > 0;\n}\n\nstatic int vcap_rule_add_action(struct vcap_rule *rule,\n\t\t\t\tenum vcap_action_field action,\n\t\t\t\tenum vcap_field_type ftype,\n\t\t\t\tstruct vcap_client_actionfield_data *data)\n{\n\tstruct vcap_rule_internal *ri = to_intrule(rule);\n\tstruct vcap_client_actionfield *field;\n\n\tif (!vcap_actionfield_unique(rule, action)) {\n\t\tpr_warn(\"%s:%d: actionfield %s is already in the rule\\n\",\n\t\t\t__func__, __LINE__,\n\t\t\tvcap_actionfield_name(ri->vctrl, action));\n\t\treturn -EINVAL;\n\t}\n\n\tif (!vcap_actionfield_match_actionset(rule, action)) {\n\t\tpr_err(\"%s:%d: actionfield %s does not belong in the rule actionset\\n\",\n\t\t       __func__, __LINE__,\n\t\t       vcap_actionfield_name(ri->vctrl, action));\n\t\treturn -EINVAL;\n\t}\n\n\tfield = kzalloc(sizeof(*field), GFP_KERNEL);\n\tif (!field)\n\t\treturn -ENOMEM;\n\tmemcpy(&field->data, data, sizeof(field->data));\n\tfield->ctrl.action = action;\n\tfield->ctrl.type = ftype;\n\tlist_add_tail(&field->ctrl.list, &rule->actionfields);\n\treturn 0;\n}\n\nstatic void vcap_rule_set_action_bitsize(struct vcap_u1_action *u1,\n\t\t\t\t\t enum vcap_bit val)\n{\n\tswitch (val) {\n\tcase VCAP_BIT_0:\n\t\tu1->value = 0;\n\t\tbreak;\n\tcase VCAP_BIT_1:\n\t\tu1->value = 1;\n\t\tbreak;\n\tcase VCAP_BIT_ANY:\n\t\tu1->value = 0;\n\t\tbreak;\n\t}\n}\n\n \nint vcap_rule_add_action_bit(struct vcap_rule *rule,\n\t\t\t     enum vcap_action_field action,\n\t\t\t     enum vcap_bit val)\n{\n\tstruct vcap_client_actionfield_data data;\n\n\tvcap_rule_set_action_bitsize(&data.u1, val);\n\treturn vcap_rule_add_action(rule, action, VCAP_FIELD_BIT, &data);\n}\nEXPORT_SYMBOL_GPL(vcap_rule_add_action_bit);\n\n \nint vcap_rule_add_action_u32(struct vcap_rule *rule,\n\t\t\t     enum vcap_action_field action,\n\t\t\t     u32 value)\n{\n\tstruct vcap_client_actionfield_data data;\n\n\tdata.u32.value = value;\n\treturn vcap_rule_add_action(rule, action, VCAP_FIELD_U32, &data);\n}\nEXPORT_SYMBOL_GPL(vcap_rule_add_action_u32);\n\nstatic int vcap_read_counter(struct vcap_rule_internal *ri,\n\t\t\t     struct vcap_counter *ctr)\n{\n\tstruct vcap_admin *admin = ri->admin;\n\n\tri->vctrl->ops->update(ri->ndev, admin, VCAP_CMD_READ, VCAP_SEL_COUNTER,\n\t\t\t       ri->addr);\n\tri->vctrl->ops->cache_read(ri->ndev, admin, VCAP_SEL_COUNTER,\n\t\t\t\t   ri->counter_id, 0);\n\tctr->value = admin->cache.counter;\n\tctr->sticky = admin->cache.sticky;\n\treturn 0;\n}\n\n \nvoid vcap_netbytes_copy(u8 *dst, u8 *src, int count)\n{\n\tint idx;\n\n\tfor (idx = 0; idx < count; ++idx, ++dst)\n\t\t*dst = src[count - idx - 1];\n}\nEXPORT_SYMBOL_GPL(vcap_netbytes_copy);\n\n \nvoid vcap_set_tc_exterr(struct flow_cls_offload *fco, struct vcap_rule *vrule)\n{\n\tswitch (vrule->exterr) {\n\tcase VCAP_ERR_NONE:\n\t\tbreak;\n\tcase VCAP_ERR_NO_ADMIN:\n\t\tNL_SET_ERR_MSG_MOD(fco->common.extack,\n\t\t\t\t   \"Missing VCAP instance\");\n\t\tbreak;\n\tcase VCAP_ERR_NO_NETDEV:\n\t\tNL_SET_ERR_MSG_MOD(fco->common.extack,\n\t\t\t\t   \"Missing network interface\");\n\t\tbreak;\n\tcase VCAP_ERR_NO_KEYSET_MATCH:\n\t\tNL_SET_ERR_MSG_MOD(fco->common.extack,\n\t\t\t\t   \"No keyset matched the filter keys\");\n\t\tbreak;\n\tcase VCAP_ERR_NO_ACTIONSET_MATCH:\n\t\tNL_SET_ERR_MSG_MOD(fco->common.extack,\n\t\t\t\t   \"No actionset matched the filter actions\");\n\t\tbreak;\n\tcase VCAP_ERR_NO_PORT_KEYSET_MATCH:\n\t\tNL_SET_ERR_MSG_MOD(fco->common.extack,\n\t\t\t\t   \"No port keyset matched the filter keys\");\n\t\tbreak;\n\t}\n}\nEXPORT_SYMBOL_GPL(vcap_set_tc_exterr);\n\n \nstatic int vcap_enable_rule(struct vcap_rule_internal *ri)\n{\n\tstruct vcap_client_actionfield *af, *naf;\n\tstruct vcap_client_keyfield *kf, *nkf;\n\tint err;\n\n\tvcap_erase_cache(ri);\n\terr = vcap_encode_rule(ri);\n\tif (err)\n\t\tgoto out;\n\terr = vcap_write_rule(ri);\n\tif (err)\n\t\tgoto out;\n\n\t \n\tlist_for_each_entry_safe(kf, nkf, &ri->data.keyfields, ctrl.list) {\n\t\tlist_del(&kf->ctrl.list);\n\t\tkfree(kf);\n\t}\n\tlist_for_each_entry_safe(af, naf, &ri->data.actionfields, ctrl.list) {\n\t\tlist_del(&af->ctrl.list);\n\t\tkfree(af);\n\t}\n\tri->state = VCAP_RS_ENABLED;\nout:\n\treturn err;\n}\n\n \nstatic int vcap_enable_rules(struct vcap_control *vctrl,\n\t\t\t     struct net_device *ndev, int chain)\n{\n\tint next_chain = chain + VCAP_CID_LOOKUP_SIZE;\n\tstruct vcap_rule_internal *ri;\n\tstruct vcap_admin *admin;\n\tint err = 0;\n\n\tlist_for_each_entry(admin, &vctrl->list, list) {\n\t\tif (!(chain >= admin->first_cid && chain <= admin->last_cid))\n\t\t\tcontinue;\n\n\t\t \n\t\tmutex_lock(&admin->lock);\n\t\tlist_for_each_entry(ri, &admin->rules, list) {\n\t\t\t \n\t\t\tif (!(ri->data.vcap_chain_id >= chain &&\n\t\t\t      ri->data.vcap_chain_id < next_chain)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (ri->ndev != ndev)\n\t\t\t\tcontinue;\n\n\t\t\tif (ri->state != VCAP_RS_DISABLED)\n\t\t\t\tcontinue;\n\n\t\t\terr = vcap_enable_rule(ri);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t}\n\t\tmutex_unlock(&admin->lock);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\treturn err;\n}\n\n \nstatic int vcap_disable_rule(struct vcap_rule_internal *ri)\n{\n\tint err;\n\n\terr = vcap_read_rule(ri);\n\tif (err)\n\t\treturn err;\n\terr = vcap_decode_keyset(ri);\n\tif (err)\n\t\treturn err;\n\terr = vcap_decode_actionset(ri);\n\tif (err)\n\t\treturn err;\n\n\tri->state = VCAP_RS_DISABLED;\n\tri->vctrl->ops->init(ri->ndev, ri->admin, ri->addr, ri->size);\n\treturn 0;\n}\n\n \nstatic int vcap_disable_rules(struct vcap_control *vctrl,\n\t\t\t      struct net_device *ndev, int chain)\n{\n\tstruct vcap_rule_internal *ri;\n\tstruct vcap_admin *admin;\n\tint err = 0;\n\n\tlist_for_each_entry(admin, &vctrl->list, list) {\n\t\tif (!(chain >= admin->first_cid && chain <= admin->last_cid))\n\t\t\tcontinue;\n\n\t\t \n\t\tmutex_lock(&admin->lock);\n\t\tlist_for_each_entry(ri, &admin->rules, list) {\n\t\t\tif (ri->data.vcap_chain_id != chain)\n\t\t\t\tcontinue;\n\n\t\t\tif (ri->ndev != ndev)\n\t\t\t\tcontinue;\n\n\t\t\tif (ri->state != VCAP_RS_ENABLED)\n\t\t\t\tcontinue;\n\n\t\t\terr = vcap_disable_rule(ri);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t}\n\t\tmutex_unlock(&admin->lock);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\treturn err;\n}\n\n \nstatic bool vcap_is_enabled(struct vcap_control *vctrl, struct net_device *ndev,\n\t\t\t    int dst_cid)\n{\n\tstruct vcap_enabled_port *eport;\n\tstruct vcap_admin *admin;\n\n\tlist_for_each_entry(admin, &vctrl->list, list)\n\t\tlist_for_each_entry(eport, &admin->enabled, list)\n\t\t\tif (eport->dst_cid == dst_cid && eport->ndev == ndev)\n\t\t\t\treturn true;\n\n\treturn false;\n}\n\n \nstatic int vcap_enable(struct vcap_control *vctrl, struct net_device *ndev,\n\t\t       unsigned long cookie, int src_cid, int dst_cid)\n{\n\tstruct vcap_enabled_port *eport;\n\tstruct vcap_admin *admin;\n\n\tif (src_cid >= dst_cid)\n\t\treturn -EFAULT;\n\n\tadmin = vcap_find_admin(vctrl, dst_cid);\n\tif (!admin)\n\t\treturn -ENOENT;\n\n\teport = kzalloc(sizeof(*eport), GFP_KERNEL);\n\tif (!eport)\n\t\treturn -ENOMEM;\n\n\teport->ndev = ndev;\n\teport->cookie = cookie;\n\teport->src_cid = src_cid;\n\teport->dst_cid = dst_cid;\n\tmutex_lock(&admin->lock);\n\tlist_add_tail(&eport->list, &admin->enabled);\n\tmutex_unlock(&admin->lock);\n\n\tif (vcap_path_exist(vctrl, ndev, src_cid)) {\n\t\t \n\t\twhile (dst_cid) {\n\t\t\tadmin = vcap_find_admin(vctrl, dst_cid);\n\t\t\tif (!admin)\n\t\t\t\treturn -ENOENT;\n\n\t\t\tvcap_enable_rules(vctrl, ndev, dst_cid);\n\t\t\tdst_cid = vcap_get_next_chain(vctrl, ndev, dst_cid);\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nstatic int vcap_disable(struct vcap_control *vctrl, struct net_device *ndev,\n\t\t\tunsigned long cookie)\n{\n\tstruct vcap_enabled_port *elem, *eport = NULL;\n\tstruct vcap_admin *found = NULL, *admin;\n\tint dst_cid;\n\n\tlist_for_each_entry(admin, &vctrl->list, list) {\n\t\tlist_for_each_entry(elem, &admin->enabled, list) {\n\t\t\tif (elem->cookie == cookie && elem->ndev == ndev) {\n\t\t\t\teport = elem;\n\t\t\t\tfound = admin;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (eport)\n\t\t\tbreak;\n\t}\n\n\tif (!eport)\n\t\treturn -ENOENT;\n\n\t \n\tdst_cid = eport->dst_cid;\n\twhile (dst_cid) {\n\t\tadmin = vcap_find_admin(vctrl, dst_cid);\n\t\tif (!admin)\n\t\t\treturn -ENOENT;\n\n\t\tvcap_disable_rules(vctrl, ndev, dst_cid);\n\t\tdst_cid = vcap_get_next_chain(vctrl, ndev, dst_cid);\n\t}\n\n\tmutex_lock(&found->lock);\n\tlist_del(&eport->list);\n\tmutex_unlock(&found->lock);\n\tkfree(eport);\n\treturn 0;\n}\n\n \nint vcap_enable_lookups(struct vcap_control *vctrl, struct net_device *ndev,\n\t\t\tint src_cid, int dst_cid, unsigned long cookie,\n\t\t\tbool enable)\n{\n\tint err;\n\n\terr = vcap_api_check(vctrl);\n\tif (err)\n\t\treturn err;\n\n\tif (!ndev)\n\t\treturn -ENODEV;\n\n\t \n\tif (src_cid % VCAP_CID_LOOKUP_SIZE)\n\t\treturn -EFAULT;\n\tif (dst_cid % VCAP_CID_LOOKUP_SIZE)\n\t\treturn -EFAULT;\n\n\tif (enable) {\n\t\tif (vcap_is_enabled(vctrl, ndev, dst_cid))\n\t\t\treturn -EADDRINUSE;\n\t\tif (vcap_is_chain_used(vctrl, ndev, src_cid))\n\t\t\treturn -EADDRNOTAVAIL;\n\t\terr = vcap_enable(vctrl, ndev, cookie, src_cid, dst_cid);\n\t} else {\n\t\terr = vcap_disable(vctrl, ndev, cookie);\n\t}\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(vcap_enable_lookups);\n\n \nbool vcap_is_last_chain(struct vcap_control *vctrl, int cid, bool ingress)\n{\n\tstruct vcap_admin *admin;\n\tint lookup;\n\n\tif (vcap_api_check(vctrl))\n\t\treturn false;\n\n\tadmin = vcap_find_admin(vctrl, cid);\n\tif (!admin)\n\t\treturn false;\n\n\tif (!vcap_admin_is_last(vctrl, admin, ingress))\n\t\treturn false;\n\n\t \n\tlookup = vcap_chain_id_to_lookup(admin, cid);\n\treturn lookup == admin->lookups - 1;\n}\nEXPORT_SYMBOL_GPL(vcap_is_last_chain);\n\n \nvoid vcap_rule_set_counter_id(struct vcap_rule *rule, u32 counter_id)\n{\n\tstruct vcap_rule_internal *ri = to_intrule(rule);\n\n\tri->counter_id = counter_id;\n}\nEXPORT_SYMBOL_GPL(vcap_rule_set_counter_id);\n\nint vcap_rule_set_counter(struct vcap_rule *rule, struct vcap_counter *ctr)\n{\n\tstruct vcap_rule_internal *ri = to_intrule(rule);\n\tint err;\n\n\terr = vcap_api_check(ri->vctrl);\n\tif (err)\n\t\treturn err;\n\tif (!ctr) {\n\t\tpr_err(\"%s:%d: counter is missing\\n\", __func__, __LINE__);\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&ri->admin->lock);\n\terr = vcap_write_counter(ri, ctr);\n\tmutex_unlock(&ri->admin->lock);\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(vcap_rule_set_counter);\n\nint vcap_rule_get_counter(struct vcap_rule *rule, struct vcap_counter *ctr)\n{\n\tstruct vcap_rule_internal *ri = to_intrule(rule);\n\tint err;\n\n\terr = vcap_api_check(ri->vctrl);\n\tif (err)\n\t\treturn err;\n\tif (!ctr) {\n\t\tpr_err(\"%s:%d: counter is missing\\n\", __func__, __LINE__);\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&ri->admin->lock);\n\terr = vcap_read_counter(ri, ctr);\n\tmutex_unlock(&ri->admin->lock);\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(vcap_rule_get_counter);\n\n \nstatic int vcap_rule_get_key(struct vcap_rule *rule,\n\t\t\t     enum vcap_key_field key,\n\t\t\t     struct vcap_client_keyfield *ckf)\n{\n\tstruct vcap_client_keyfield *field;\n\n\tfield = vcap_find_keyfield(rule, key);\n\tif (!field)\n\t\treturn -EINVAL;\n\tmemcpy(ckf, field, sizeof(*ckf));\n\tINIT_LIST_HEAD(&ckf->ctrl.list);\n\treturn 0;\n}\n\n \nstatic int vcap_rule_get_untyped_keyset(struct vcap_rule_internal *ri,\n\t\t\t\t\tstruct vcap_keyset_list *matches)\n{\n\tstruct vcap_control *vctrl = ri->vctrl;\n\tenum vcap_type vt = ri->admin->vtype;\n\tconst struct vcap_set *keyfield_set;\n\tint idx;\n\n\tkeyfield_set = vctrl->vcaps[vt].keyfield_set;\n\tfor (idx = 0; idx < vctrl->vcaps[vt].keyfield_set_size; ++idx) {\n\t\tif (keyfield_set[idx].sw_per_item == ri->keyset_sw &&\n\t\t    keyfield_set[idx].type_id == (u8)-1) {\n\t\t\tvcap_keyset_list_add(matches, idx);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -EINVAL;\n}\n\n \nint vcap_rule_get_keysets(struct vcap_rule_internal *ri,\n\t\t\t  struct vcap_keyset_list *matches)\n{\n\tstruct vcap_control *vctrl = ri->vctrl;\n\tenum vcap_type vt = ri->admin->vtype;\n\tconst struct vcap_set *keyfield_set;\n\tstruct vcap_client_keyfield kf = {};\n\tu32 value, mask;\n\tint err, idx;\n\n\terr = vcap_rule_get_key(&ri->data, VCAP_KF_TYPE, &kf);\n\tif (err)\n\t\treturn vcap_rule_get_untyped_keyset(ri, matches);\n\n\tif (kf.ctrl.type == VCAP_FIELD_BIT) {\n\t\tvalue = kf.data.u1.value;\n\t\tmask = kf.data.u1.mask;\n\t} else if (kf.ctrl.type == VCAP_FIELD_U32) {\n\t\tvalue = kf.data.u32.value;\n\t\tmask = kf.data.u32.mask;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\tkeyfield_set = vctrl->vcaps[vt].keyfield_set;\n\tfor (idx = 0; idx < vctrl->vcaps[vt].keyfield_set_size; ++idx) {\n\t\tif (keyfield_set[idx].sw_per_item != ri->keyset_sw)\n\t\t\tcontinue;\n\n\t\tif (keyfield_set[idx].type_id == (u8)-1) {\n\t\t\tvcap_keyset_list_add(matches, idx);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ((keyfield_set[idx].type_id & mask) == value)\n\t\t\tvcap_keyset_list_add(matches, idx);\n\t}\n\tif (matches->cnt > 0)\n\t\treturn 0;\n\n\treturn -EINVAL;\n}\n\n \nint vcap_get_rule_count_by_cookie(struct vcap_control *vctrl,\n\t\t\t\t  struct vcap_counter *ctr, u64 cookie)\n{\n\tstruct vcap_rule_internal *ri;\n\tstruct vcap_counter temp = {};\n\tstruct vcap_admin *admin;\n\tint err;\n\n\terr = vcap_api_check(vctrl);\n\tif (err)\n\t\treturn err;\n\n\t \n\tlist_for_each_entry(admin, &vctrl->list, list) {\n\t\tmutex_lock(&admin->lock);\n\t\tlist_for_each_entry(ri, &admin->rules, list) {\n\t\t\tif (ri->data.cookie != cookie)\n\t\t\t\tcontinue;\n\n\t\t\terr = vcap_read_counter(ri, &temp);\n\t\t\tif (err)\n\t\t\t\tgoto unlock;\n\t\t\tctr->value += temp.value;\n\n\t\t\t \n\t\t\ttemp.value = 0;\n\t\t\ttemp.sticky = 0;\n\t\t\terr = vcap_write_counter(ri, &temp);\n\t\t\tif (err)\n\t\t\t\tgoto unlock;\n\t\t}\n\t\tmutex_unlock(&admin->lock);\n\t}\n\treturn err;\n\nunlock:\n\tmutex_unlock(&admin->lock);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(vcap_get_rule_count_by_cookie);\n\nstatic int vcap_rule_mod_key(struct vcap_rule *rule,\n\t\t\t     enum vcap_key_field key,\n\t\t\t     enum vcap_field_type ftype,\n\t\t\t     struct vcap_client_keyfield_data *data)\n{\n\tstruct vcap_client_keyfield *field;\n\n\tfield = vcap_find_keyfield(rule, key);\n\tif (!field)\n\t\treturn vcap_rule_add_key(rule, key, ftype, data);\n\tmemcpy(&field->data, data, sizeof(field->data));\n\treturn 0;\n}\n\n \nint vcap_rule_mod_key_u32(struct vcap_rule *rule, enum vcap_key_field key,\n\t\t\t  u32 value, u32 mask)\n{\n\tstruct vcap_client_keyfield_data data;\n\n\tdata.u32.value = value;\n\tdata.u32.mask = mask;\n\treturn vcap_rule_mod_key(rule, key, VCAP_FIELD_U32, &data);\n}\nEXPORT_SYMBOL_GPL(vcap_rule_mod_key_u32);\n\n \nint vcap_rule_rem_key(struct vcap_rule *rule, enum vcap_key_field key)\n{\n\tstruct vcap_rule_internal *ri = to_intrule(rule);\n\tstruct vcap_client_keyfield *field;\n\n\tfield = vcap_find_keyfield(rule, key);\n\tif (!field) {\n\t\tpr_err(\"%s:%d: key %s is not in the rule\\n\",\n\t\t       __func__, __LINE__, vcap_keyfield_name(ri->vctrl, key));\n\t\treturn -EINVAL;\n\t}\n\t \n\tlist_del(&field->ctrl.list);\n\tkfree(field);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(vcap_rule_rem_key);\n\nstatic int vcap_rule_mod_action(struct vcap_rule *rule,\n\t\t\t\tenum vcap_action_field action,\n\t\t\t\tenum vcap_field_type ftype,\n\t\t\t\tstruct vcap_client_actionfield_data *data)\n{\n\tstruct vcap_client_actionfield *field;\n\n\tfield = vcap_find_actionfield(rule, action);\n\tif (!field)\n\t\treturn vcap_rule_add_action(rule, action, ftype, data);\n\tmemcpy(&field->data, data, sizeof(field->data));\n\treturn 0;\n}\n\n \nint vcap_rule_mod_action_u32(struct vcap_rule *rule,\n\t\t\t     enum vcap_action_field action,\n\t\t\t     u32 value)\n{\n\tstruct vcap_client_actionfield_data data;\n\n\tdata.u32.value = value;\n\treturn vcap_rule_mod_action(rule, action, VCAP_FIELD_U32, &data);\n}\nEXPORT_SYMBOL_GPL(vcap_rule_mod_action_u32);\n\n \nint vcap_filter_rule_keys(struct vcap_rule *rule,\n\t\t\t  enum vcap_key_field keylist[], int length,\n\t\t\t  bool drop_unsupported)\n{\n\tstruct vcap_rule_internal *ri = to_intrule(rule);\n\tstruct vcap_client_keyfield *ckf, *next_ckf;\n\tconst struct vcap_field *fields;\n\tenum vcap_key_field key;\n\tint err = 0;\n\tint idx;\n\n\tif (length > 0) {\n\t\terr = -EEXIST;\n\t\tlist_for_each_entry_safe(ckf, next_ckf,\n\t\t\t\t\t &ri->data.keyfields, ctrl.list) {\n\t\t\tkey = ckf->ctrl.key;\n\t\t\tfor (idx = 0; idx < length; ++idx)\n\t\t\t\tif (key == keylist[idx]) {\n\t\t\t\t\tlist_del(&ckf->ctrl.list);\n\t\t\t\t\tkfree(ckf);\n\t\t\t\t\tidx++;\n\t\t\t\t\terr = 0;\n\t\t\t\t}\n\t\t}\n\t}\n\tif (drop_unsupported) {\n\t\terr = -EEXIST;\n\t\tfields = vcap_keyfields(ri->vctrl, ri->admin->vtype,\n\t\t\t\t\trule->keyset);\n\t\tif (!fields)\n\t\t\treturn err;\n\t\tlist_for_each_entry_safe(ckf, next_ckf,\n\t\t\t\t\t &ri->data.keyfields, ctrl.list) {\n\t\t\tkey = ckf->ctrl.key;\n\t\t\tif (fields[key].width == 0) {\n\t\t\t\tlist_del(&ckf->ctrl.list);\n\t\t\t\tkfree(ckf);\n\t\t\t\terr = 0;\n\t\t\t}\n\t\t}\n\t}\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(vcap_filter_rule_keys);\n\n \nenum vcap_keyfield_set\nvcap_select_min_rule_keyset(struct vcap_control *vctrl,\n\t\t\t    enum vcap_type vtype,\n\t\t\t    struct vcap_keyset_list *kslist)\n{\n\tenum vcap_keyfield_set ret = VCAP_KFS_NO_VALUE;\n\tconst struct vcap_set *kset;\n\tint max = 100, idx;\n\n\tfor (idx = 0; idx < kslist->cnt; ++idx) {\n\t\tkset = vcap_keyfieldset(vctrl, vtype, kslist->keysets[idx]);\n\t\tif (!kset)\n\t\t\tcontinue;\n\t\tif (kset->sw_per_item >= max)\n\t\t\tcontinue;\n\t\tmax = kset->sw_per_item;\n\t\tret = kslist->keysets[idx];\n\t}\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(vcap_select_min_rule_keyset);\n\n \nstruct vcap_rule *vcap_copy_rule(struct vcap_rule *erule)\n{\n\tstruct vcap_rule_internal *ri = to_intrule(erule);\n\tstruct vcap_client_actionfield *caf;\n\tstruct vcap_client_keyfield *ckf;\n\tstruct vcap_rule *rule;\n\tint err;\n\n\terr = vcap_api_check(ri->vctrl);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\trule = vcap_alloc_rule(ri->vctrl, ri->ndev, ri->data.vcap_chain_id,\n\t\t\t       ri->data.user, ri->data.priority, 0);\n\tif (IS_ERR(rule))\n\t\treturn rule;\n\n\tlist_for_each_entry(ckf, &ri->data.keyfields, ctrl.list) {\n\t\t \n\t\terr = vcap_rule_add_key(rule,\n\t\t\t\t\tckf->ctrl.key,\n\t\t\t\t\tckf->ctrl.type,\n\t\t\t\t\t&ckf->data);\n\t\tif (err)\n\t\t\tgoto err;\n\t}\n\n\tlist_for_each_entry(caf, &ri->data.actionfields, ctrl.list) {\n\t\t \n\t\terr = vcap_rule_add_action(rule,\n\t\t\t\t\t   caf->ctrl.action,\n\t\t\t\t\t   caf->ctrl.type,\n\t\t\t\t\t   &caf->data);\n\t\tif (err)\n\t\t\tgoto err;\n\t}\n\treturn rule;\nerr:\n\tvcap_free_rule(rule);\n\treturn ERR_PTR(err);\n}\nEXPORT_SYMBOL_GPL(vcap_copy_rule);\n\n#ifdef CONFIG_VCAP_KUNIT_TEST\n#include \"vcap_api_kunit.c\"\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}