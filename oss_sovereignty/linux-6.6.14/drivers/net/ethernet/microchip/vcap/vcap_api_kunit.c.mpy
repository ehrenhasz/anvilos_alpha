{
  "module_name": "vcap_api_kunit.c",
  "hash_id": "2eb379e789790814c7ae7643235bb2333f102691c681eb6fc53a21907365d64e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/microchip/vcap/vcap_api_kunit.c",
  "human_readable_source": "\n \n\n#include <kunit/test.h>\n#include \"vcap_api.h\"\n#include \"vcap_api_client.h\"\n#include \"vcap_model_kunit.h\"\n\n \n#define TEST_BUF_CNT 100\n#define TEST_BUF_SZ  350\n#define STREAMWSIZE 64\n\nstatic u32 test_updateaddr[STREAMWSIZE] = {};\nstatic int test_updateaddridx;\nstatic int test_cache_erase_count;\nstatic u32 test_init_start;\nstatic u32 test_init_count;\nstatic u32 test_hw_counter_id;\nstatic struct vcap_cache_data test_hw_cache;\nstatic struct net_device test_netdev = {};\nstatic int test_move_addr;\nstatic int test_move_offset;\nstatic int test_move_count;\n\n \nstatic enum vcap_keyfield_set test_val_keyset(struct net_device *ndev,\n\t\t\t\t\t      struct vcap_admin *admin,\n\t\t\t\t\t      struct vcap_rule *rule,\n\t\t\t\t\t      struct vcap_keyset_list *kslist,\n\t\t\t\t\t      u16 l3_proto)\n{\n\tint idx;\n\n\tif (kslist->cnt > 0) {\n\t\tswitch (admin->vtype) {\n\t\tcase VCAP_TYPE_IS0:\n\t\t\tfor (idx = 0; idx < kslist->cnt; idx++) {\n\t\t\t\tif (kslist->keysets[idx] == VCAP_KFS_ETAG)\n\t\t\t\t\treturn kslist->keysets[idx];\n\t\t\t\tif (kslist->keysets[idx] == VCAP_KFS_PURE_5TUPLE_IP4)\n\t\t\t\t\treturn kslist->keysets[idx];\n\t\t\t\tif (kslist->keysets[idx] == VCAP_KFS_NORMAL_5TUPLE_IP4)\n\t\t\t\t\treturn kslist->keysets[idx];\n\t\t\t\tif (kslist->keysets[idx] == VCAP_KFS_NORMAL_7TUPLE)\n\t\t\t\t\treturn kslist->keysets[idx];\n\t\t\t}\n\t\t\tbreak;\n\t\tcase VCAP_TYPE_IS2:\n\t\t\tfor (idx = 0; idx < kslist->cnt; idx++) {\n\t\t\t\tif (kslist->keysets[idx] == VCAP_KFS_MAC_ETYPE)\n\t\t\t\t\treturn kslist->keysets[idx];\n\t\t\t\tif (kslist->keysets[idx] == VCAP_KFS_ARP)\n\t\t\t\t\treturn kslist->keysets[idx];\n\t\t\t\tif (kslist->keysets[idx] == VCAP_KFS_IP_7TUPLE)\n\t\t\t\t\treturn kslist->keysets[idx];\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_info(\"%s:%d: no validation for VCAP %d\\n\",\n\t\t\t\t__func__, __LINE__, admin->vtype);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn -EINVAL;\n}\n\n \nstatic void test_add_def_fields(struct net_device *ndev,\n\t\t\t\tstruct vcap_admin *admin,\n\t\t\t\tstruct vcap_rule *rule)\n{\n\tif (admin->vinst == 0 || admin->vinst == 2)\n\t\tvcap_rule_add_key_bit(rule, VCAP_KF_LOOKUP_FIRST_IS, VCAP_BIT_1);\n\telse\n\t\tvcap_rule_add_key_bit(rule, VCAP_KF_LOOKUP_FIRST_IS, VCAP_BIT_0);\n}\n\n \nstatic void test_cache_erase(struct vcap_admin *admin)\n{\n\tif (test_cache_erase_count) {\n\t\tmemset(admin->cache.keystream, 0, test_cache_erase_count);\n\t\tmemset(admin->cache.maskstream, 0, test_cache_erase_count);\n\t\tmemset(admin->cache.actionstream, 0, test_cache_erase_count);\n\t\ttest_cache_erase_count = 0;\n\t}\n}\n\n \nstatic void test_cache_init(struct net_device *ndev, struct vcap_admin *admin,\n\t\t\t    u32 start, u32 count)\n{\n\ttest_init_start = start;\n\ttest_init_count = count;\n}\n\n \nstatic void test_cache_read(struct net_device *ndev, struct vcap_admin *admin,\n\t\t\t    enum vcap_selection sel, u32 start, u32 count)\n{\n\tu32 *keystr, *mskstr, *actstr;\n\tint idx;\n\n\tpr_debug(\"%s:%d: %d %d\\n\", __func__, __LINE__, start, count);\n\tswitch (sel) {\n\tcase VCAP_SEL_ENTRY:\n\t\tkeystr = &admin->cache.keystream[start];\n\t\tmskstr = &admin->cache.maskstream[start];\n\t\tfor (idx = 0; idx < count; ++idx) {\n\t\t\tpr_debug(\"%s:%d: keydata[%02d]: 0x%08x\\n\", __func__,\n\t\t\t\t __LINE__, start + idx, keystr[idx]);\n\t\t}\n\t\tfor (idx = 0; idx < count; ++idx) {\n\t\t\t \n\t\t\tmskstr[idx] = ~mskstr[idx];\n\t\t\tpr_debug(\"%s:%d: mskdata[%02d]: 0x%08x\\n\", __func__,\n\t\t\t\t __LINE__, start + idx, mskstr[idx]);\n\t\t}\n\t\tbreak;\n\tcase VCAP_SEL_ACTION:\n\t\tactstr = &admin->cache.actionstream[start];\n\t\tfor (idx = 0; idx < count; ++idx) {\n\t\t\tpr_debug(\"%s:%d: actdata[%02d]: 0x%08x\\n\", __func__,\n\t\t\t\t __LINE__, start + idx, actstr[idx]);\n\t\t}\n\t\tbreak;\n\tcase VCAP_SEL_COUNTER:\n\t\tpr_debug(\"%s:%d\\n\", __func__, __LINE__);\n\t\ttest_hw_counter_id = start;\n\t\tadmin->cache.counter = test_hw_cache.counter;\n\t\tadmin->cache.sticky = test_hw_cache.sticky;\n\t\tbreak;\n\tcase VCAP_SEL_ALL:\n\t\tpr_debug(\"%s:%d\\n\", __func__, __LINE__);\n\t\tbreak;\n\t}\n}\n\n \nstatic void test_cache_write(struct net_device *ndev, struct vcap_admin *admin,\n\t\t\t     enum vcap_selection sel, u32 start, u32 count)\n{\n\tu32 *keystr, *mskstr, *actstr;\n\tint idx;\n\n\tswitch (sel) {\n\tcase VCAP_SEL_ENTRY:\n\t\tkeystr = &admin->cache.keystream[start];\n\t\tmskstr = &admin->cache.maskstream[start];\n\t\tfor (idx = 0; idx < count; ++idx) {\n\t\t\tpr_debug(\"%s:%d: keydata[%02d]: 0x%08x\\n\", __func__,\n\t\t\t\t __LINE__, start + idx, keystr[idx]);\n\t\t}\n\t\tfor (idx = 0; idx < count; ++idx) {\n\t\t\t \n\t\t\tmskstr[idx] = ~mskstr[idx];\n\t\t\tpr_debug(\"%s:%d: mskdata[%02d]: 0x%08x\\n\", __func__,\n\t\t\t\t __LINE__, start + idx, mskstr[idx]);\n\t\t}\n\t\tbreak;\n\tcase VCAP_SEL_ACTION:\n\t\tactstr = &admin->cache.actionstream[start];\n\t\tfor (idx = 0; idx < count; ++idx) {\n\t\t\tpr_debug(\"%s:%d: actdata[%02d]: 0x%08x\\n\", __func__,\n\t\t\t\t __LINE__, start + idx, actstr[idx]);\n\t\t}\n\t\tbreak;\n\tcase VCAP_SEL_COUNTER:\n\t\tpr_debug(\"%s:%d\\n\", __func__, __LINE__);\n\t\ttest_hw_counter_id = start;\n\t\ttest_hw_cache.counter = admin->cache.counter;\n\t\ttest_hw_cache.sticky = admin->cache.sticky;\n\t\tbreak;\n\tcase VCAP_SEL_ALL:\n\t\tpr_err(\"%s:%d: cannot write all streams at once\\n\",\n\t\t       __func__, __LINE__);\n\t\tbreak;\n\t}\n}\n\n \nstatic void test_cache_update(struct net_device *ndev, struct vcap_admin *admin,\n\t\t\t      enum vcap_command cmd,\n\t\t\t      enum vcap_selection sel, u32 addr)\n{\n\tif (test_updateaddridx < ARRAY_SIZE(test_updateaddr))\n\t\ttest_updateaddr[test_updateaddridx] = addr;\n\telse\n\t\tpr_err(\"%s:%d: overflow: %d\\n\", __func__, __LINE__, test_updateaddridx);\n\ttest_updateaddridx++;\n}\n\nstatic void test_cache_move(struct net_device *ndev, struct vcap_admin *admin,\n\t\t\t    u32 addr, int offset, int count)\n{\n\ttest_move_addr = addr;\n\ttest_move_offset = offset;\n\ttest_move_count = count;\n}\n\n \nstatic int vcap_test_port_info(struct net_device *ndev,\n\t\t\t       struct vcap_admin *admin,\n\t\t\t       struct vcap_output_print *out)\n{\n\treturn 0;\n}\n\nstatic struct vcap_operations test_callbacks = {\n\t.validate_keyset = test_val_keyset,\n\t.add_default_fields = test_add_def_fields,\n\t.cache_erase = test_cache_erase,\n\t.cache_write = test_cache_write,\n\t.cache_read = test_cache_read,\n\t.init = test_cache_init,\n\t.update = test_cache_update,\n\t.move = test_cache_move,\n\t.port_info = vcap_test_port_info,\n};\n\nstatic struct vcap_control test_vctrl = {\n\t.vcaps = kunit_test_vcaps,\n\t.stats = &kunit_test_vcap_stats,\n\t.ops = &test_callbacks,\n};\n\nstatic void vcap_test_api_init(struct vcap_admin *admin)\n{\n\t \n\tINIT_LIST_HEAD(&test_vctrl.list);\n\tINIT_LIST_HEAD(&admin->list);\n\tINIT_LIST_HEAD(&admin->rules);\n\tINIT_LIST_HEAD(&admin->enabled);\n\tmutex_init(&admin->lock);\n\tlist_add_tail(&admin->list, &test_vctrl.list);\n\tmemset(test_updateaddr, 0, sizeof(test_updateaddr));\n\ttest_updateaddridx = 0;\n}\n\n \nstatic void test_vcap_xn_rule_creator(struct kunit *test, int cid,\n\t\t\t\t      enum vcap_user user, u16 priority,\n\t\t\t\t      int id, int size, int expected_addr)\n{\n\tstruct vcap_rule *rule;\n\tstruct vcap_rule_internal *ri;\n\tenum vcap_keyfield_set keyset = VCAP_KFS_NO_VALUE;\n\tenum vcap_actionfield_set actionset = VCAP_AFS_NO_VALUE;\n\tint ret;\n\n\t \n\tmemset(test_updateaddr, 0, sizeof(test_updateaddr));\n\ttest_updateaddridx = 0;\n\ttest_move_addr = 0;\n\ttest_move_offset = 0;\n\ttest_move_count = 0;\n\n\tswitch (size) {\n\tcase 2:\n\t\tkeyset = VCAP_KFS_ETAG;\n\t\tactionset = VCAP_AFS_CLASS_REDUCED;\n\t\tbreak;\n\tcase 3:\n\t\tkeyset = VCAP_KFS_PURE_5TUPLE_IP4;\n\t\tactionset = VCAP_AFS_CLASSIFICATION;\n\t\tbreak;\n\tcase 6:\n\t\tkeyset = VCAP_KFS_NORMAL_5TUPLE_IP4;\n\t\tactionset = VCAP_AFS_CLASSIFICATION;\n\t\tbreak;\n\tcase 12:\n\t\tkeyset = VCAP_KFS_NORMAL_7TUPLE;\n\t\tactionset = VCAP_AFS_FULL;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tKUNIT_ASSERT_NE(test, VCAP_KFS_NO_VALUE, keyset);\n\n\t \n\trule = vcap_alloc_rule(&test_vctrl, &test_netdev, cid, user, priority,\n\t\t\t       id);\n\tKUNIT_EXPECT_PTR_NE(test, NULL, rule);\n\n\tri = (struct vcap_rule_internal *)rule;\n\n\t \n\tret = vcap_set_rule_set_keyset(rule, keyset);\n\n\t \n\tret = vcap_rule_add_action_u32(rule, VCAP_AF_ISDX_VAL, 0);\n\n\t \n\tret = vcap_set_rule_set_actionset(rule, actionset);\n\n\tret = vcap_val_rule(rule, ETH_P_ALL);\n\tKUNIT_EXPECT_EQ(test, 0, ret);\n\tKUNIT_EXPECT_EQ(test, keyset, rule->keyset);\n\tKUNIT_EXPECT_EQ(test, actionset, rule->actionset);\n\tKUNIT_EXPECT_EQ(test, size, ri->size);\n\n\t \n\tret = vcap_add_rule(rule);\n\tKUNIT_EXPECT_EQ(test, 0, ret);\n\tKUNIT_EXPECT_EQ(test, expected_addr, ri->addr);\n\tvcap_free_rule(rule);\n}\n\n \nstatic void test_init_rule_deletion(void)\n{\n\ttest_move_addr = 0;\n\ttest_move_offset = 0;\n\ttest_move_count = 0;\n\ttest_init_start = 0;\n\ttest_init_count = 0;\n}\n\n \n\nstatic void vcap_api_set_bit_1_test(struct kunit *test)\n{\n\tstruct vcap_stream_iter iter = {\n\t\t.offset = 35,\n\t\t.sw_width = 52,\n\t\t.reg_idx = 1,\n\t\t.reg_bitpos = 20,\n\t\t.tg = NULL,\n\t};\n\tu32 stream[2] = {0};\n\n\tvcap_set_bit(stream, &iter, 1);\n\n\tKUNIT_EXPECT_EQ(test, (u32)0x0, stream[0]);\n\tKUNIT_EXPECT_EQ(test, (u32)BIT(20), stream[1]);\n}\n\nstatic void vcap_api_set_bit_0_test(struct kunit *test)\n{\n\tstruct vcap_stream_iter iter = {\n\t\t.offset = 35,\n\t\t.sw_width = 52,\n\t\t.reg_idx = 2,\n\t\t.reg_bitpos = 11,\n\t\t.tg = NULL,\n\t};\n\tu32 stream[3] = {~0, ~0, ~0};\n\n\tvcap_set_bit(stream, &iter, 0);\n\n\tKUNIT_EXPECT_EQ(test, (u32)~0, stream[0]);\n\tKUNIT_EXPECT_EQ(test, (u32)~0, stream[1]);\n\tKUNIT_EXPECT_EQ(test, (u32)~BIT(11), stream[2]);\n}\n\nstatic void vcap_api_iterator_init_test(struct kunit *test)\n{\n\tstruct vcap_stream_iter iter;\n\tstruct vcap_typegroup typegroups[] = {\n\t\t{ .offset = 0, .width = 2, .value = 2, },\n\t\t{ .offset = 156, .width = 1, .value = 0, },\n\t\t{ .offset = 0, .width = 0, .value = 0, },\n\t};\n\tstruct vcap_typegroup typegroups2[] = {\n\t\t{ .offset = 0, .width = 3, .value = 4, },\n\t\t{ .offset = 49, .width = 2, .value = 0, },\n\t\t{ .offset = 98, .width = 2, .value = 0, },\n\t};\n\n\tvcap_iter_init(&iter, 52, typegroups, 86);\n\n\tKUNIT_EXPECT_EQ(test, 52, iter.sw_width);\n\tKUNIT_EXPECT_EQ(test, 86 + 2, iter.offset);\n\tKUNIT_EXPECT_EQ(test, 3, iter.reg_idx);\n\tKUNIT_EXPECT_EQ(test, 4, iter.reg_bitpos);\n\n\tvcap_iter_init(&iter, 49, typegroups2, 134);\n\n\tKUNIT_EXPECT_EQ(test, 49, iter.sw_width);\n\tKUNIT_EXPECT_EQ(test, 134 + 7, iter.offset);\n\tKUNIT_EXPECT_EQ(test, 5, iter.reg_idx);\n\tKUNIT_EXPECT_EQ(test, 11, iter.reg_bitpos);\n}\n\nstatic void vcap_api_iterator_next_test(struct kunit *test)\n{\n\tstruct vcap_stream_iter iter;\n\tstruct vcap_typegroup typegroups[] = {\n\t\t{ .offset = 0, .width = 4, .value = 8, },\n\t\t{ .offset = 49, .width = 1, .value = 0, },\n\t\t{ .offset = 98, .width = 2, .value = 0, },\n\t\t{ .offset = 147, .width = 3, .value = 0, },\n\t\t{ .offset = 196, .width = 2, .value = 0, },\n\t\t{ .offset = 245, .width = 1, .value = 0, },\n\t};\n\tint idx;\n\n\tvcap_iter_init(&iter, 49, typegroups, 86);\n\n\tKUNIT_EXPECT_EQ(test, 49, iter.sw_width);\n\tKUNIT_EXPECT_EQ(test, 86 + 5, iter.offset);\n\tKUNIT_EXPECT_EQ(test, 3, iter.reg_idx);\n\tKUNIT_EXPECT_EQ(test, 10, iter.reg_bitpos);\n\n\tvcap_iter_next(&iter);\n\n\tKUNIT_EXPECT_EQ(test, 91 + 1, iter.offset);\n\tKUNIT_EXPECT_EQ(test, 3, iter.reg_idx);\n\tKUNIT_EXPECT_EQ(test, 11, iter.reg_bitpos);\n\n\tfor (idx = 0; idx < 6; idx++)\n\t\tvcap_iter_next(&iter);\n\n\tKUNIT_EXPECT_EQ(test, 92 + 6 + 2, iter.offset);\n\tKUNIT_EXPECT_EQ(test, 4, iter.reg_idx);\n\tKUNIT_EXPECT_EQ(test, 2, iter.reg_bitpos);\n}\n\nstatic void vcap_api_encode_typegroups_test(struct kunit *test)\n{\n\tu32 stream[12] = {0};\n\tstruct vcap_typegroup typegroups[] = {\n\t\t{ .offset = 0, .width = 4, .value = 8, },\n\t\t{ .offset = 49, .width = 1, .value = 1, },\n\t\t{ .offset = 98, .width = 2, .value = 3, },\n\t\t{ .offset = 147, .width = 3, .value = 5, },\n\t\t{ .offset = 196, .width = 2, .value = 2, },\n\t\t{ .offset = 245, .width = 5, .value = 27, },\n\t\t{ .offset = 0, .width = 0, .value = 0, },\n\t};\n\n\tvcap_encode_typegroups(stream, 49, typegroups, false);\n\n\tKUNIT_EXPECT_EQ(test, (u32)0x8, stream[0]);\n\tKUNIT_EXPECT_EQ(test, (u32)0x0, stream[1]);\n\tKUNIT_EXPECT_EQ(test, (u32)0x1, stream[2]);\n\tKUNIT_EXPECT_EQ(test, (u32)0x0, stream[3]);\n\tKUNIT_EXPECT_EQ(test, (u32)0x3, stream[4]);\n\tKUNIT_EXPECT_EQ(test, (u32)0x0, stream[5]);\n\tKUNIT_EXPECT_EQ(test, (u32)0x5, stream[6]);\n\tKUNIT_EXPECT_EQ(test, (u32)0x0, stream[7]);\n\tKUNIT_EXPECT_EQ(test, (u32)0x2, stream[8]);\n\tKUNIT_EXPECT_EQ(test, (u32)0x0, stream[9]);\n\tKUNIT_EXPECT_EQ(test, (u32)27, stream[10]);\n\tKUNIT_EXPECT_EQ(test, (u32)0x0, stream[11]);\n}\n\nstatic void vcap_api_encode_bit_test(struct kunit *test)\n{\n\tstruct vcap_stream_iter iter;\n\tu32 stream[4] = {0};\n\tstruct vcap_typegroup typegroups[] = {\n\t\t{ .offset = 0, .width = 4, .value = 8, },\n\t\t{ .offset = 49, .width = 1, .value = 1, },\n\t\t{ .offset = 98, .width = 2, .value = 3, },\n\t\t{ .offset = 147, .width = 3, .value = 5, },\n\t\t{ .offset = 196, .width = 2, .value = 2, },\n\t\t{ .offset = 245, .width = 1, .value = 0, },\n\t};\n\n\tvcap_iter_init(&iter, 49, typegroups, 44);\n\n\tKUNIT_EXPECT_EQ(test, 48, iter.offset);\n\tKUNIT_EXPECT_EQ(test, 1, iter.reg_idx);\n\tKUNIT_EXPECT_EQ(test, 16, iter.reg_bitpos);\n\n\tvcap_encode_bit(stream, &iter, 1);\n\n\tKUNIT_EXPECT_EQ(test, (u32)0x0, stream[0]);\n\tKUNIT_EXPECT_EQ(test, (u32)BIT(16), stream[1]);\n\tKUNIT_EXPECT_EQ(test, (u32)0x0, stream[2]);\n}\n\nstatic void vcap_api_encode_field_test(struct kunit *test)\n{\n\tstruct vcap_stream_iter iter;\n\tu32 stream[16] = {0};\n\tstruct vcap_typegroup typegroups[] = {\n\t\t{ .offset = 0, .width = 4, .value = 8, },\n\t\t{ .offset = 49, .width = 1, .value = 1, },\n\t\t{ .offset = 98, .width = 2, .value = 3, },\n\t\t{ .offset = 147, .width = 3, .value = 5, },\n\t\t{ .offset = 196, .width = 2, .value = 2, },\n\t\t{ .offset = 245, .width = 5, .value = 27, },\n\t\t{ .offset = 0, .width = 0, .value = 0, },\n\t};\n\tstruct vcap_field rf = {\n\t\t.type = VCAP_FIELD_U32,\n\t\t.offset = 86,\n\t\t.width = 4,\n\t};\n\tu8 value[] = {0x5};\n\n\tvcap_iter_init(&iter, 49, typegroups, rf.offset);\n\n\tKUNIT_EXPECT_EQ(test, 91, iter.offset);\n\tKUNIT_EXPECT_EQ(test, 3, iter.reg_idx);\n\tKUNIT_EXPECT_EQ(test, 10, iter.reg_bitpos);\n\n\tvcap_encode_field(stream, &iter, rf.width, value);\n\n\tKUNIT_EXPECT_EQ(test, (u32)0x0, stream[0]);\n\tKUNIT_EXPECT_EQ(test, (u32)0x0, stream[1]);\n\tKUNIT_EXPECT_EQ(test, (u32)0x0, stream[2]);\n\tKUNIT_EXPECT_EQ(test, (u32)(0x5 << 10), stream[3]);\n\tKUNIT_EXPECT_EQ(test, (u32)0x0, stream[4]);\n\n\tvcap_encode_typegroups(stream, 49, typegroups, false);\n\n\tKUNIT_EXPECT_EQ(test, (u32)0x8, stream[0]);\n\tKUNIT_EXPECT_EQ(test, (u32)0x0, stream[1]);\n\tKUNIT_EXPECT_EQ(test, (u32)0x1, stream[2]);\n\tKUNIT_EXPECT_EQ(test, (u32)(0x5 << 10), stream[3]);\n\tKUNIT_EXPECT_EQ(test, (u32)0x3, stream[4]);\n\tKUNIT_EXPECT_EQ(test, (u32)0x0, stream[5]);\n\tKUNIT_EXPECT_EQ(test, (u32)0x5, stream[6]);\n\tKUNIT_EXPECT_EQ(test, (u32)0x0, stream[7]);\n\tKUNIT_EXPECT_EQ(test, (u32)0x2, stream[8]);\n\tKUNIT_EXPECT_EQ(test, (u32)0x0, stream[9]);\n\tKUNIT_EXPECT_EQ(test, (u32)27, stream[10]);\n\tKUNIT_EXPECT_EQ(test, (u32)0x0, stream[11]);\n}\n\n \nstatic void vcap_api_encode_short_field_test(struct kunit *test)\n{\n\tstruct vcap_stream_iter iter;\n\tint sw_width = 21;\n\tu32 stream[6] = {0};\n\tstruct vcap_typegroup tgt[] = {\n\t\t{ .offset = 0, .width = 3, .value = 7, },\n\t\t{ .offset = 21, .width = 2, .value = 3, },\n\t\t{ .offset = 42, .width = 1, .value = 1, },\n\t\t{ .offset = 0, .width = 0, .value = 0, },\n\t};\n\tstruct vcap_field rf = {\n\t\t.type = VCAP_FIELD_U32,\n\t\t.offset = 25,\n\t\t.width = 4,\n\t};\n\tu8 value[] = {0x5};\n\n\tvcap_iter_init(&iter, sw_width, tgt, rf.offset);\n\n\tKUNIT_EXPECT_EQ(test, 1, iter.regs_per_sw);\n\tKUNIT_EXPECT_EQ(test, 21, iter.sw_width);\n\tKUNIT_EXPECT_EQ(test, 25 + 3 + 2, iter.offset);\n\tKUNIT_EXPECT_EQ(test, 1, iter.reg_idx);\n\tKUNIT_EXPECT_EQ(test, 25 + 3 + 2 - sw_width, iter.reg_bitpos);\n\n\tvcap_encode_field(stream, &iter, rf.width, value);\n\n\tKUNIT_EXPECT_EQ(test, (u32)0x0, stream[0]);\n\tKUNIT_EXPECT_EQ(test, (u32)(0x5 << (25 + 3 + 2 - sw_width)), stream[1]);\n\tKUNIT_EXPECT_EQ(test, (u32)0x0, stream[2]);\n\tKUNIT_EXPECT_EQ(test, (u32)0x0, stream[3]);\n\tKUNIT_EXPECT_EQ(test, (u32)0x0, stream[4]);\n\tKUNIT_EXPECT_EQ(test, (u32)0x0, stream[5]);\n\n\tvcap_encode_typegroups(stream, sw_width, tgt, false);\n\n\tKUNIT_EXPECT_EQ(test, (u32)7, stream[0]);\n\tKUNIT_EXPECT_EQ(test, (u32)((0x5 << (25 + 3 + 2 - sw_width)) + 3), stream[1]);\n\tKUNIT_EXPECT_EQ(test, (u32)1, stream[2]);\n\tKUNIT_EXPECT_EQ(test, (u32)0, stream[3]);\n\tKUNIT_EXPECT_EQ(test, (u32)0, stream[4]);\n\tKUNIT_EXPECT_EQ(test, (u32)0, stream[5]);\n}\n\nstatic void vcap_api_encode_keyfield_test(struct kunit *test)\n{\n\tu32 keywords[16] = {0};\n\tu32 maskwords[16] = {0};\n\tstruct vcap_admin admin = {\n\t\t.vtype = VCAP_TYPE_IS2,\n\t\t.cache = {\n\t\t\t.keystream = keywords,\n\t\t\t.maskstream = maskwords,\n\t\t\t.actionstream = keywords,\n\t\t},\n\t};\n\tstruct vcap_rule_internal rule = {\n\t\t.admin = &admin,\n\t\t.data = {\n\t\t\t.keyset = VCAP_KFS_MAC_ETYPE,\n\t\t},\n\t\t.vctrl = &test_vctrl,\n\t};\n\tstruct vcap_client_keyfield ckf = {\n\t\t.ctrl.list = {},\n\t\t.ctrl.key = VCAP_KF_ISDX_CLS,\n\t\t.ctrl.type = VCAP_FIELD_U32,\n\t\t.data.u32.value = 0xeef014a1,\n\t\t.data.u32.mask = 0xfff,\n\t};\n\tstruct vcap_field rf = {\n\t\t.type = VCAP_FIELD_U32,\n\t\t.offset = 56,\n\t\t.width = 12,\n\t};\n\tstruct vcap_typegroup tgt[] = {\n\t\t{ .offset = 0, .width = 2, .value = 2, },\n\t\t{ .offset = 156, .width = 1, .value = 1, },\n\t\t{ .offset = 0, .width = 0, .value = 0, },\n\t};\n\n\tvcap_test_api_init(&admin);\n\tvcap_encode_keyfield(&rule, &ckf, &rf, tgt);\n\n\t \n\tKUNIT_EXPECT_EQ(test, (u32)0x0, keywords[0]);\n\tKUNIT_EXPECT_EQ(test, (u32)0x0, keywords[1]);\n\tKUNIT_EXPECT_EQ(test, (u32)(0x04a1 << 6), keywords[2]);\n\tKUNIT_EXPECT_EQ(test, (u32)0x0, keywords[3]);\n\tKUNIT_EXPECT_EQ(test, (u32)0x0, keywords[4]);\n\tKUNIT_EXPECT_EQ(test, (u32)0x0, keywords[5]);\n\tKUNIT_EXPECT_EQ(test, (u32)0x0, keywords[6]);\n\n\t \n\tKUNIT_EXPECT_EQ(test, (u32)0x0, maskwords[0]);\n\tKUNIT_EXPECT_EQ(test, (u32)0x0, maskwords[1]);\n\tKUNIT_EXPECT_EQ(test, (u32)(0x0fff << 6), maskwords[2]);\n\tKUNIT_EXPECT_EQ(test, (u32)0x0, maskwords[3]);\n\tKUNIT_EXPECT_EQ(test, (u32)0x0, maskwords[4]);\n\tKUNIT_EXPECT_EQ(test, (u32)0x0, maskwords[5]);\n\tKUNIT_EXPECT_EQ(test, (u32)0x0, maskwords[6]);\n}\n\nstatic void vcap_api_encode_max_keyfield_test(struct kunit *test)\n{\n\tint idx;\n\tu32 keywords[6] = {0};\n\tu32 maskwords[6] = {0};\n\tstruct vcap_admin admin = {\n\t\t.vtype = VCAP_TYPE_IS2,\n\t\t \n\t\t.cache = {\n\t\t\t.keystream = keywords,\n\t\t\t.maskstream = maskwords,\n\t\t\t.actionstream = keywords,\n\t\t},\n\t};\n\tstruct vcap_rule_internal rule = {\n\t\t.admin = &admin,\n\t\t.data = {\n\t\t\t.keyset = VCAP_KFS_IP_7TUPLE,\n\t\t},\n\t\t.vctrl = &test_vctrl,\n\t};\n\tstruct vcap_client_keyfield ckf = {\n\t\t.ctrl.list = {},\n\t\t.ctrl.key = VCAP_KF_L3_IP6_DIP,\n\t\t.ctrl.type = VCAP_FIELD_U128,\n\t\t.data.u128.value = { 0xa1, 0xa2, 0xa3, 0xa4, 0, 0, 0x43, 0,\n\t\t\t0, 0, 0, 0, 0, 0, 0x78, 0x8e, },\n\t\t.data.u128.mask =  { 0xff, 0xff, 0xff, 0xff, 0, 0, 0xff, 0,\n\t\t\t0, 0, 0, 0, 0, 0, 0xff, 0xff },\n\t};\n\tstruct vcap_field rf = {\n\t\t.type = VCAP_FIELD_U128,\n\t\t.offset = 0,\n\t\t.width = 128,\n\t};\n\tstruct vcap_typegroup tgt[] = {\n\t\t{ .offset = 0, .width = 2, .value = 2, },\n\t\t{ .offset = 156, .width = 1, .value = 1, },\n\t\t{ .offset = 0, .width = 0, .value = 0, },\n\t};\n\tu32 keyres[] = {\n\t\t0x928e8a84,\n\t\t0x000c0002,\n\t\t0x00000010,\n\t\t0x00000000,\n\t\t0x0239e000,\n\t\t0x00000000,\n\t};\n\tu32 mskres[] = {\n\t\t0xfffffffc,\n\t\t0x000c0003,\n\t\t0x0000003f,\n\t\t0x00000000,\n\t\t0x03fffc00,\n\t\t0x00000000,\n\t};\n\n\tvcap_encode_keyfield(&rule, &ckf, &rf, tgt);\n\n\t \n\tfor (idx = 0; idx < ARRAY_SIZE(keyres); ++idx)\n\t\tKUNIT_EXPECT_EQ(test, keyres[idx], keywords[idx]);\n\t \n\tfor (idx = 0; idx < ARRAY_SIZE(mskres); ++idx)\n\t\tKUNIT_EXPECT_EQ(test, mskres[idx], maskwords[idx]);\n}\n\nstatic void vcap_api_encode_actionfield_test(struct kunit *test)\n{\n\tu32 actwords[16] = {0};\n\tint sw_width = 21;\n\tstruct vcap_admin admin = {\n\t\t.vtype = VCAP_TYPE_ES2,  \n\t\t.cache = {\n\t\t\t.actionstream = actwords,\n\t\t},\n\t};\n\tstruct vcap_rule_internal rule = {\n\t\t.admin = &admin,\n\t\t.data = {\n\t\t\t.actionset = VCAP_AFS_BASE_TYPE,\n\t\t},\n\t\t.vctrl = &test_vctrl,\n\t};\n\tstruct vcap_client_actionfield caf = {\n\t\t.ctrl.list = {},\n\t\t.ctrl.action = VCAP_AF_POLICE_IDX,\n\t\t.ctrl.type = VCAP_FIELD_U32,\n\t\t.data.u32.value = 0x67908032,\n\t};\n\tstruct vcap_field rf = {\n\t\t.type = VCAP_FIELD_U32,\n\t\t.offset = 35,\n\t\t.width = 6,\n\t};\n\tstruct vcap_typegroup tgt[] = {\n\t\t{ .offset = 0, .width = 2, .value = 2, },\n\t\t{ .offset = 21, .width = 1, .value = 1, },\n\t\t{ .offset = 42, .width = 1, .value = 0, },\n\t\t{ .offset = 0, .width = 0, .value = 0, },\n\t};\n\n\tvcap_encode_actionfield(&rule, &caf, &rf, tgt);\n\n\t \n\tKUNIT_EXPECT_EQ(test, (u32)0x0, actwords[0]);\n\tKUNIT_EXPECT_EQ(test, (u32)((0x32 << (35 + 2 + 1 - sw_width)) & 0x1fffff), actwords[1]);\n\tKUNIT_EXPECT_EQ(test, (u32)((0x32 >> ((2 * sw_width) - 38 - 1))), actwords[2]);\n\tKUNIT_EXPECT_EQ(test, (u32)0x0, actwords[3]);\n\tKUNIT_EXPECT_EQ(test, (u32)0x0, actwords[4]);\n\tKUNIT_EXPECT_EQ(test, (u32)0x0, actwords[5]);\n\tKUNIT_EXPECT_EQ(test, (u32)0x0, actwords[6]);\n}\n\nstatic void vcap_api_keyfield_typegroup_test(struct kunit *test)\n{\n\tconst struct vcap_typegroup *tg;\n\n\ttg = vcap_keyfield_typegroup(&test_vctrl, VCAP_TYPE_IS2, VCAP_KFS_MAC_ETYPE);\n\tKUNIT_EXPECT_PTR_NE(test, NULL, tg);\n\tKUNIT_EXPECT_EQ(test, 0, tg[0].offset);\n\tKUNIT_EXPECT_EQ(test, 2, tg[0].width);\n\tKUNIT_EXPECT_EQ(test, 2, tg[0].value);\n\tKUNIT_EXPECT_EQ(test, 156, tg[1].offset);\n\tKUNIT_EXPECT_EQ(test, 1, tg[1].width);\n\tKUNIT_EXPECT_EQ(test, 0, tg[1].value);\n\tKUNIT_EXPECT_EQ(test, 0, tg[2].offset);\n\tKUNIT_EXPECT_EQ(test, 0, tg[2].width);\n\tKUNIT_EXPECT_EQ(test, 0, tg[2].value);\n\n\ttg = vcap_keyfield_typegroup(&test_vctrl, VCAP_TYPE_ES2, VCAP_KFS_LL_FULL);\n\tKUNIT_EXPECT_PTR_EQ(test, NULL, tg);\n}\n\nstatic void vcap_api_actionfield_typegroup_test(struct kunit *test)\n{\n\tconst struct vcap_typegroup *tg;\n\n\ttg = vcap_actionfield_typegroup(&test_vctrl, VCAP_TYPE_IS0, VCAP_AFS_FULL);\n\tKUNIT_EXPECT_PTR_NE(test, NULL, tg);\n\tKUNIT_EXPECT_EQ(test, 0, tg[0].offset);\n\tKUNIT_EXPECT_EQ(test, 3, tg[0].width);\n\tKUNIT_EXPECT_EQ(test, 4, tg[0].value);\n\tKUNIT_EXPECT_EQ(test, 110, tg[1].offset);\n\tKUNIT_EXPECT_EQ(test, 2, tg[1].width);\n\tKUNIT_EXPECT_EQ(test, 0, tg[1].value);\n\tKUNIT_EXPECT_EQ(test, 220, tg[2].offset);\n\tKUNIT_EXPECT_EQ(test, 2, tg[2].width);\n\tKUNIT_EXPECT_EQ(test, 0, tg[2].value);\n\tKUNIT_EXPECT_EQ(test, 0, tg[3].offset);\n\tKUNIT_EXPECT_EQ(test, 0, tg[3].width);\n\tKUNIT_EXPECT_EQ(test, 0, tg[3].value);\n\n\ttg = vcap_actionfield_typegroup(&test_vctrl, VCAP_TYPE_IS2, VCAP_AFS_CLASSIFICATION);\n\tKUNIT_EXPECT_PTR_EQ(test, NULL, tg);\n}\n\nstatic void vcap_api_vcap_keyfields_test(struct kunit *test)\n{\n\tconst struct vcap_field *ft;\n\n\tft = vcap_keyfields(&test_vctrl, VCAP_TYPE_IS2, VCAP_KFS_MAC_ETYPE);\n\tKUNIT_EXPECT_PTR_NE(test, NULL, ft);\n\n\t \n\tft = vcap_keyfields(&test_vctrl, VCAP_TYPE_ES2, VCAP_KFS_PURE_5TUPLE_IP4);\n\tKUNIT_EXPECT_PTR_EQ(test, NULL, ft);\n\n\t \n\tft = vcap_keyfields(&test_vctrl, VCAP_TYPE_ES2, VCAP_KFS_LL_FULL);\n\tKUNIT_EXPECT_PTR_EQ(test, NULL, ft);\n}\n\nstatic void vcap_api_vcap_actionfields_test(struct kunit *test)\n{\n\tconst struct vcap_field *ft;\n\n\tft = vcap_actionfields(&test_vctrl, VCAP_TYPE_IS0, VCAP_AFS_FULL);\n\tKUNIT_EXPECT_PTR_NE(test, NULL, ft);\n\n\tft = vcap_actionfields(&test_vctrl, VCAP_TYPE_IS2, VCAP_AFS_FULL);\n\tKUNIT_EXPECT_PTR_EQ(test, NULL, ft);\n\n\tft = vcap_actionfields(&test_vctrl, VCAP_TYPE_IS2, VCAP_AFS_CLASSIFICATION);\n\tKUNIT_EXPECT_PTR_EQ(test, NULL, ft);\n}\n\nstatic void vcap_api_encode_rule_keyset_test(struct kunit *test)\n{\n\tu32 keywords[16] = {0};\n\tu32 maskwords[16] = {0};\n\tstruct vcap_admin admin = {\n\t\t.vtype = VCAP_TYPE_IS2,\n\t\t.cache = {\n\t\t\t.keystream = keywords,\n\t\t\t.maskstream = maskwords,\n\t\t},\n\t};\n\tstruct vcap_rule_internal rule = {\n\t\t.admin = &admin,\n\t\t.data = {\n\t\t\t.keyset = VCAP_KFS_MAC_ETYPE,\n\t\t},\n\t\t.vctrl = &test_vctrl,\n\t};\n\tstruct vcap_client_keyfield ckf[] = {\n\t\t{\n\t\t\t.ctrl.key = VCAP_KF_TYPE,\n\t\t\t.ctrl.type = VCAP_FIELD_U32,\n\t\t\t.data.u32.value = 0x00,\n\t\t\t.data.u32.mask = 0x0f,\n\t\t},\n\t\t{\n\t\t\t.ctrl.key = VCAP_KF_LOOKUP_FIRST_IS,\n\t\t\t.ctrl.type = VCAP_FIELD_BIT,\n\t\t\t.data.u1.value = 0x01,\n\t\t\t.data.u1.mask = 0x01,\n\t\t},\n\t\t{\n\t\t\t.ctrl.key = VCAP_KF_IF_IGR_PORT_MASK_L3,\n\t\t\t.ctrl.type = VCAP_FIELD_BIT,\n\t\t\t.data.u1.value = 0x00,\n\t\t\t.data.u1.mask = 0x01,\n\t\t},\n\t\t{\n\t\t\t.ctrl.key = VCAP_KF_IF_IGR_PORT_MASK_RNG,\n\t\t\t.ctrl.type = VCAP_FIELD_U32,\n\t\t\t.data.u32.value = 0x00,\n\t\t\t.data.u32.mask = 0x0f,\n\t\t},\n\t\t{\n\t\t\t.ctrl.key = VCAP_KF_IF_IGR_PORT_MASK,\n\t\t\t.ctrl.type = VCAP_FIELD_U72,\n\t\t\t.data.u72.value = {0x0, 0x00, 0x00, 0x00},\n\t\t\t.data.u72.mask = {0xfd, 0xff, 0xff, 0xff},\n\t\t},\n\t\t{\n\t\t\t.ctrl.key = VCAP_KF_L2_DMAC,\n\t\t\t.ctrl.type = VCAP_FIELD_U48,\n\t\t\t \n\t\t\t.data.u48.value = {0x01, 0x02, 0x03, 0x04, 0x05, 0x06},\n\t\t\t.data.u48.mask = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff},\n\t\t},\n\t\t{\n\t\t\t.ctrl.key = VCAP_KF_ETYPE_LEN_IS,\n\t\t\t.ctrl.type = VCAP_FIELD_BIT,\n\t\t\t.data.u1.value = 0x01,\n\t\t\t.data.u1.mask = 0x01,\n\t\t},\n\t\t{\n\t\t\t.ctrl.key = VCAP_KF_ETYPE,\n\t\t\t.ctrl.type = VCAP_FIELD_U32,\n\t\t\t.data.u32.value = 0xaabb,\n\t\t\t.data.u32.mask = 0xffff,\n\t\t},\n\t};\n\tint idx;\n\tint ret;\n\n\t \n\tINIT_LIST_HEAD(&rule.data.keyfields);\n\tret = vcap_encode_rule_keyset(&rule);\n\tKUNIT_EXPECT_EQ(test, -EINVAL, ret);\n\n\tfor (idx = 0; idx < ARRAY_SIZE(ckf); idx++)\n\t\tlist_add_tail(&ckf[idx].ctrl.list, &rule.data.keyfields);\n\tret = vcap_encode_rule_keyset(&rule);\n\tKUNIT_EXPECT_EQ(test, 0, ret);\n\n\t \n\t \n\tKUNIT_EXPECT_EQ(test, (u32)0x00000042, keywords[0]);\n\tKUNIT_EXPECT_EQ(test, (u32)0x00000000, keywords[1]);\n\tKUNIT_EXPECT_EQ(test, (u32)0x00000000, keywords[2]);\n\tKUNIT_EXPECT_EQ(test, (u32)0x00020100, keywords[3]);\n\tKUNIT_EXPECT_EQ(test, (u32)0x60504030, keywords[4]);\n\tKUNIT_EXPECT_EQ(test, (u32)0x00000000, keywords[5]);\n\tKUNIT_EXPECT_EQ(test, (u32)0x00000000, keywords[6]);\n\tKUNIT_EXPECT_EQ(test, (u32)0x0002aaee, keywords[7]);\n\tKUNIT_EXPECT_EQ(test, (u32)0x00000000, keywords[8]);\n\tKUNIT_EXPECT_EQ(test, (u32)0x00000000, keywords[9]);\n\tKUNIT_EXPECT_EQ(test, (u32)0x00000000, keywords[10]);\n\tKUNIT_EXPECT_EQ(test, (u32)0x00000000, keywords[11]);\n\n\t \n\tKUNIT_EXPECT_EQ(test, (u32)~0x00b07f80, maskwords[0]);\n\tKUNIT_EXPECT_EQ(test, (u32)~0xfff00000, maskwords[1]);\n\tKUNIT_EXPECT_EQ(test, (u32)~0xfffffffc, maskwords[2]);\n\tKUNIT_EXPECT_EQ(test, (u32)~0xfff000ff, maskwords[3]);\n\tKUNIT_EXPECT_EQ(test, (u32)~0x00000000, maskwords[4]);\n\tKUNIT_EXPECT_EQ(test, (u32)~0xfffffff0, maskwords[5]);\n\tKUNIT_EXPECT_EQ(test, (u32)~0xfffffffe, maskwords[6]);\n\tKUNIT_EXPECT_EQ(test, (u32)~0xfffc0001, maskwords[7]);\n\tKUNIT_EXPECT_EQ(test, (u32)~0xffffffff, maskwords[8]);\n\tKUNIT_EXPECT_EQ(test, (u32)~0xffffffff, maskwords[9]);\n\tKUNIT_EXPECT_EQ(test, (u32)~0xffffffff, maskwords[10]);\n\tKUNIT_EXPECT_EQ(test, (u32)~0xffffffff, maskwords[11]);\n}\n\nstatic void vcap_api_encode_rule_actionset_test(struct kunit *test)\n{\n\tu32 actwords[16] = {0};\n\tstruct vcap_admin admin = {\n\t\t.vtype = VCAP_TYPE_IS2,\n\t\t.cache = {\n\t\t\t.actionstream = actwords,\n\t\t},\n\t};\n\tstruct vcap_rule_internal rule = {\n\t\t.admin = &admin,\n\t\t.data = {\n\t\t\t.actionset = VCAP_AFS_BASE_TYPE,\n\t\t},\n\t\t.vctrl = &test_vctrl,\n\t};\n\tstruct vcap_client_actionfield caf[] = {\n\t\t{\n\t\t\t.ctrl.action = VCAP_AF_MATCH_ID,\n\t\t\t.ctrl.type = VCAP_FIELD_U32,\n\t\t\t.data.u32.value = 0x01,\n\t\t},\n\t\t{\n\t\t\t.ctrl.action = VCAP_AF_MATCH_ID_MASK,\n\t\t\t.ctrl.type = VCAP_FIELD_U32,\n\t\t\t.data.u32.value = 0x01,\n\t\t},\n\t\t{\n\t\t\t.ctrl.action = VCAP_AF_CNT_ID,\n\t\t\t.ctrl.type = VCAP_FIELD_U32,\n\t\t\t.data.u32.value = 0x64,\n\t\t},\n\t};\n\tint idx;\n\tint ret;\n\n\t \n\tINIT_LIST_HEAD(&rule.data.actionfields);\n\tret = vcap_encode_rule_actionset(&rule);\n\t \n\tKUNIT_EXPECT_EQ(test, 0, ret);\n\n\tfor (idx = 0; idx < ARRAY_SIZE(caf); idx++)\n\t\tlist_add_tail(&caf[idx].ctrl.list, &rule.data.actionfields);\n\tret = vcap_encode_rule_actionset(&rule);\n\tKUNIT_EXPECT_EQ(test, 0, ret);\n\n\t \n\tKUNIT_EXPECT_EQ(test, (u32)0x00000002, actwords[0]);\n\tKUNIT_EXPECT_EQ(test, (u32)0x00000000, actwords[1]);\n\tKUNIT_EXPECT_EQ(test, (u32)0x00000000, actwords[2]);\n\tKUNIT_EXPECT_EQ(test, (u32)0x00000000, actwords[3]);\n\tKUNIT_EXPECT_EQ(test, (u32)0x00000000, actwords[4]);\n\tKUNIT_EXPECT_EQ(test, (u32)0x00100000, actwords[5]);\n\tKUNIT_EXPECT_EQ(test, (u32)0x06400010, actwords[6]);\n\tKUNIT_EXPECT_EQ(test, (u32)0x00000000, actwords[7]);\n\tKUNIT_EXPECT_EQ(test, (u32)0x00000000, actwords[8]);\n\tKUNIT_EXPECT_EQ(test, (u32)0x00000000, actwords[9]);\n\tKUNIT_EXPECT_EQ(test, (u32)0x00000000, actwords[10]);\n\tKUNIT_EXPECT_EQ(test, (u32)0x00000000, actwords[11]);\n}\n\nstatic void vcap_free_ckf(struct vcap_rule *rule)\n{\n\tstruct vcap_client_keyfield *ckf, *next_ckf;\n\n\tlist_for_each_entry_safe(ckf, next_ckf, &rule->keyfields, ctrl.list) {\n\t\tlist_del(&ckf->ctrl.list);\n\t\tkfree(ckf);\n\t}\n}\n\nstatic void vcap_api_rule_add_keyvalue_test(struct kunit *test)\n{\n\tstruct vcap_admin admin = {\n\t\t.vtype = VCAP_TYPE_IS2,\n\t};\n\tstruct vcap_rule_internal ri = {\n\t\t.admin = &admin,\n\t\t.data = {\n\t\t\t.keyset = VCAP_KFS_NO_VALUE,\n\t\t},\n\t\t.vctrl = &test_vctrl,\n\t};\n\tstruct vcap_rule *rule = (struct vcap_rule *)&ri;\n\tstruct vcap_client_keyfield *kf;\n\tint ret;\n\tstruct vcap_u128_key dip = {\n\t\t.value = {0x17, 0x26, 0x35, 0x44, 0x63, 0x62, 0x71},\n\t\t.mask = {0xf1, 0xf2, 0xf3, 0xf4, 0x4f, 0x3f, 0x2f, 0x1f},\n\t};\n\tint idx;\n\n\tINIT_LIST_HEAD(&rule->keyfields);\n\tret = vcap_rule_add_key_bit(rule, VCAP_KF_LOOKUP_FIRST_IS, VCAP_BIT_0);\n\tKUNIT_EXPECT_EQ(test, 0, ret);\n\tret = list_empty(&rule->keyfields);\n\tKUNIT_EXPECT_EQ(test, false, ret);\n\tkf = list_first_entry(&rule->keyfields, struct vcap_client_keyfield,\n\t\t\t      ctrl.list);\n\tKUNIT_EXPECT_EQ(test, VCAP_KF_LOOKUP_FIRST_IS, kf->ctrl.key);\n\tKUNIT_EXPECT_EQ(test, VCAP_FIELD_BIT, kf->ctrl.type);\n\tKUNIT_EXPECT_EQ(test, 0x0, kf->data.u1.value);\n\tKUNIT_EXPECT_EQ(test, 0x1, kf->data.u1.mask);\n\tvcap_free_ckf(rule);\n\n\tINIT_LIST_HEAD(&rule->keyfields);\n\tret = vcap_rule_add_key_bit(rule, VCAP_KF_LOOKUP_FIRST_IS, VCAP_BIT_1);\n\tKUNIT_EXPECT_EQ(test, 0, ret);\n\tret = list_empty(&rule->keyfields);\n\tKUNIT_EXPECT_EQ(test, false, ret);\n\tkf = list_first_entry(&rule->keyfields, struct vcap_client_keyfield,\n\t\t\t      ctrl.list);\n\tKUNIT_EXPECT_EQ(test, VCAP_KF_LOOKUP_FIRST_IS, kf->ctrl.key);\n\tKUNIT_EXPECT_EQ(test, VCAP_FIELD_BIT, kf->ctrl.type);\n\tKUNIT_EXPECT_EQ(test, 0x1, kf->data.u1.value);\n\tKUNIT_EXPECT_EQ(test, 0x1, kf->data.u1.mask);\n\tvcap_free_ckf(rule);\n\n\tINIT_LIST_HEAD(&rule->keyfields);\n\tret = vcap_rule_add_key_bit(rule, VCAP_KF_LOOKUP_FIRST_IS,\n\t\t\t\t    VCAP_BIT_ANY);\n\tKUNIT_EXPECT_EQ(test, 0, ret);\n\tret = list_empty(&rule->keyfields);\n\tKUNIT_EXPECT_EQ(test, false, ret);\n\tkf = list_first_entry(&rule->keyfields, struct vcap_client_keyfield,\n\t\t\t      ctrl.list);\n\tKUNIT_EXPECT_EQ(test, VCAP_KF_LOOKUP_FIRST_IS, kf->ctrl.key);\n\tKUNIT_EXPECT_EQ(test, VCAP_FIELD_BIT, kf->ctrl.type);\n\tKUNIT_EXPECT_EQ(test, 0x0, kf->data.u1.value);\n\tKUNIT_EXPECT_EQ(test, 0x0, kf->data.u1.mask);\n\tvcap_free_ckf(rule);\n\n\tINIT_LIST_HEAD(&rule->keyfields);\n\tret = vcap_rule_add_key_u32(rule, VCAP_KF_TYPE, 0x98765432, 0xff00ffab);\n\tKUNIT_EXPECT_EQ(test, 0, ret);\n\tret = list_empty(&rule->keyfields);\n\tKUNIT_EXPECT_EQ(test, false, ret);\n\tkf = list_first_entry(&rule->keyfields, struct vcap_client_keyfield,\n\t\t\t      ctrl.list);\n\tKUNIT_EXPECT_EQ(test, VCAP_KF_TYPE, kf->ctrl.key);\n\tKUNIT_EXPECT_EQ(test, VCAP_FIELD_U32, kf->ctrl.type);\n\tKUNIT_EXPECT_EQ(test, 0x98765432, kf->data.u32.value);\n\tKUNIT_EXPECT_EQ(test, 0xff00ffab, kf->data.u32.mask);\n\tvcap_free_ckf(rule);\n\n\tINIT_LIST_HEAD(&rule->keyfields);\n\tret = vcap_rule_add_key_u128(rule, VCAP_KF_L3_IP6_SIP, &dip);\n\tKUNIT_EXPECT_EQ(test, 0, ret);\n\tret = list_empty(&rule->keyfields);\n\tKUNIT_EXPECT_EQ(test, false, ret);\n\tkf = list_first_entry(&rule->keyfields, struct vcap_client_keyfield,\n\t\t\t      ctrl.list);\n\tKUNIT_EXPECT_EQ(test, VCAP_KF_L3_IP6_SIP, kf->ctrl.key);\n\tKUNIT_EXPECT_EQ(test, VCAP_FIELD_U128, kf->ctrl.type);\n\tfor (idx = 0; idx < ARRAY_SIZE(dip.value); ++idx)\n\t\tKUNIT_EXPECT_EQ(test, dip.value[idx], kf->data.u128.value[idx]);\n\tfor (idx = 0; idx < ARRAY_SIZE(dip.mask); ++idx)\n\t\tKUNIT_EXPECT_EQ(test, dip.mask[idx], kf->data.u128.mask[idx]);\n\tvcap_free_ckf(rule);\n}\n\nstatic void vcap_free_caf(struct vcap_rule *rule)\n{\n\tstruct vcap_client_actionfield *caf, *next_caf;\n\n\tlist_for_each_entry_safe(caf, next_caf,\n\t\t\t\t &rule->actionfields, ctrl.list) {\n\t\tlist_del(&caf->ctrl.list);\n\t\tkfree(caf);\n\t}\n}\n\nstatic void vcap_api_rule_add_actionvalue_test(struct kunit *test)\n{\n\tstruct vcap_admin admin = {\n\t\t.vtype = VCAP_TYPE_IS2,\n\t};\n\tstruct vcap_rule_internal ri = {\n\t\t.admin = &admin,\n\t\t.data = {\n\t\t\t.actionset = VCAP_AFS_NO_VALUE,\n\t\t},\n\t};\n\tstruct vcap_rule *rule = (struct vcap_rule *)&ri;\n\tstruct vcap_client_actionfield *af;\n\tint ret;\n\n\tINIT_LIST_HEAD(&rule->actionfields);\n\tret = vcap_rule_add_action_bit(rule, VCAP_AF_POLICE_ENA, VCAP_BIT_0);\n\tKUNIT_EXPECT_EQ(test, 0, ret);\n\tret = list_empty(&rule->actionfields);\n\tKUNIT_EXPECT_EQ(test, false, ret);\n\taf = list_first_entry(&rule->actionfields,\n\t\t\t      struct vcap_client_actionfield, ctrl.list);\n\tKUNIT_EXPECT_EQ(test, VCAP_AF_POLICE_ENA, af->ctrl.action);\n\tKUNIT_EXPECT_EQ(test, VCAP_FIELD_BIT, af->ctrl.type);\n\tKUNIT_EXPECT_EQ(test, 0x0, af->data.u1.value);\n\tvcap_free_caf(rule);\n\n\tINIT_LIST_HEAD(&rule->actionfields);\n\tret = vcap_rule_add_action_bit(rule, VCAP_AF_POLICE_ENA, VCAP_BIT_1);\n\tKUNIT_EXPECT_EQ(test, 0, ret);\n\tret = list_empty(&rule->actionfields);\n\tKUNIT_EXPECT_EQ(test, false, ret);\n\taf = list_first_entry(&rule->actionfields,\n\t\t\t      struct vcap_client_actionfield, ctrl.list);\n\tKUNIT_EXPECT_EQ(test, VCAP_AF_POLICE_ENA, af->ctrl.action);\n\tKUNIT_EXPECT_EQ(test, VCAP_FIELD_BIT, af->ctrl.type);\n\tKUNIT_EXPECT_EQ(test, 0x1, af->data.u1.value);\n\tvcap_free_caf(rule);\n\n\tINIT_LIST_HEAD(&rule->actionfields);\n\tret = vcap_rule_add_action_bit(rule, VCAP_AF_POLICE_ENA, VCAP_BIT_ANY);\n\tKUNIT_EXPECT_EQ(test, 0, ret);\n\tret = list_empty(&rule->actionfields);\n\tKUNIT_EXPECT_EQ(test, false, ret);\n\taf = list_first_entry(&rule->actionfields,\n\t\t\t      struct vcap_client_actionfield, ctrl.list);\n\tKUNIT_EXPECT_EQ(test, VCAP_AF_POLICE_ENA, af->ctrl.action);\n\tKUNIT_EXPECT_EQ(test, VCAP_FIELD_BIT, af->ctrl.type);\n\tKUNIT_EXPECT_EQ(test, 0x0, af->data.u1.value);\n\tvcap_free_caf(rule);\n\n\tINIT_LIST_HEAD(&rule->actionfields);\n\tret = vcap_rule_add_action_u32(rule, VCAP_AF_TYPE, 0x98765432);\n\tKUNIT_EXPECT_EQ(test, 0, ret);\n\tret = list_empty(&rule->actionfields);\n\tKUNIT_EXPECT_EQ(test, false, ret);\n\taf = list_first_entry(&rule->actionfields,\n\t\t\t      struct vcap_client_actionfield, ctrl.list);\n\tKUNIT_EXPECT_EQ(test, VCAP_AF_TYPE, af->ctrl.action);\n\tKUNIT_EXPECT_EQ(test, VCAP_FIELD_U32, af->ctrl.type);\n\tKUNIT_EXPECT_EQ(test, 0x98765432, af->data.u32.value);\n\tvcap_free_caf(rule);\n\n\tINIT_LIST_HEAD(&rule->actionfields);\n\tret = vcap_rule_add_action_u32(rule, VCAP_AF_MASK_MODE, 0xaabbccdd);\n\tKUNIT_EXPECT_EQ(test, 0, ret);\n\tret = list_empty(&rule->actionfields);\n\tKUNIT_EXPECT_EQ(test, false, ret);\n\taf = list_first_entry(&rule->actionfields,\n\t\t\t      struct vcap_client_actionfield, ctrl.list);\n\tKUNIT_EXPECT_EQ(test, VCAP_AF_MASK_MODE, af->ctrl.action);\n\tKUNIT_EXPECT_EQ(test, VCAP_FIELD_U32, af->ctrl.type);\n\tKUNIT_EXPECT_EQ(test, 0xaabbccdd, af->data.u32.value);\n\tvcap_free_caf(rule);\n}\n\nstatic void vcap_api_rule_find_keyset_basic_test(struct kunit *test)\n{\n\tstruct vcap_keyset_list matches = {};\n\tstruct vcap_admin admin = {\n\t\t.vtype = VCAP_TYPE_IS2,\n\t};\n\tstruct vcap_rule_internal ri = {\n\t\t.admin = &admin,\n\t\t.vctrl = &test_vctrl,\n\t};\n\tstruct vcap_client_keyfield ckf[] = {\n\t\t{\n\t\t\t.ctrl.key = VCAP_KF_TYPE,\n\t\t}, {\n\t\t\t.ctrl.key = VCAP_KF_LOOKUP_FIRST_IS,\n\t\t}, {\n\t\t\t.ctrl.key = VCAP_KF_IF_IGR_PORT_MASK_L3,\n\t\t}, {\n\t\t\t.ctrl.key = VCAP_KF_IF_IGR_PORT_MASK_RNG,\n\t\t}, {\n\t\t\t.ctrl.key = VCAP_KF_IF_IGR_PORT_MASK,\n\t\t}, {\n\t\t\t.ctrl.key = VCAP_KF_L2_DMAC,\n\t\t}, {\n\t\t\t.ctrl.key = VCAP_KF_ETYPE_LEN_IS,\n\t\t}, {\n\t\t\t.ctrl.key = VCAP_KF_ETYPE,\n\t\t},\n\t};\n\tint idx;\n\tbool ret;\n\tenum vcap_keyfield_set keysets[10] = {};\n\n\tmatches.keysets = keysets;\n\tmatches.max = ARRAY_SIZE(keysets);\n\n\tINIT_LIST_HEAD(&ri.data.keyfields);\n\tfor (idx = 0; idx < ARRAY_SIZE(ckf); idx++)\n\t\tlist_add_tail(&ckf[idx].ctrl.list, &ri.data.keyfields);\n\n\tret = vcap_rule_find_keysets(&ri.data, &matches);\n\n\tKUNIT_EXPECT_EQ(test, true, ret);\n\tKUNIT_EXPECT_EQ(test, 1, matches.cnt);\n\tKUNIT_EXPECT_EQ(test, VCAP_KFS_MAC_ETYPE, matches.keysets[0]);\n}\n\nstatic void vcap_api_rule_find_keyset_failed_test(struct kunit *test)\n{\n\tstruct vcap_keyset_list matches = {};\n\tstruct vcap_admin admin = {\n\t\t.vtype = VCAP_TYPE_IS2,\n\t};\n\tstruct vcap_rule_internal ri = {\n\t\t.admin = &admin,\n\t\t.vctrl = &test_vctrl,\n\t};\n\tstruct vcap_client_keyfield ckf[] = {\n\t\t{\n\t\t\t.ctrl.key = VCAP_KF_TYPE,\n\t\t}, {\n\t\t\t.ctrl.key = VCAP_KF_LOOKUP_FIRST_IS,\n\t\t}, {\n\t\t\t.ctrl.key = VCAP_KF_ARP_OPCODE,\n\t\t}, {\n\t\t\t.ctrl.key = VCAP_KF_L3_IP4_SIP,\n\t\t}, {\n\t\t\t.ctrl.key = VCAP_KF_L3_IP4_DIP,\n\t\t}, {\n\t\t\t.ctrl.key = VCAP_KF_8021Q_PCP_CLS,\n\t\t}, {\n\t\t\t.ctrl.key = VCAP_KF_ETYPE_LEN_IS,  \n\t\t}, {\n\t\t\t.ctrl.key = VCAP_KF_ETYPE,  \n\t\t},\n\t};\n\tint idx;\n\tbool ret;\n\tenum vcap_keyfield_set keysets[10] = {};\n\n\tmatches.keysets = keysets;\n\tmatches.max = ARRAY_SIZE(keysets);\n\n\tINIT_LIST_HEAD(&ri.data.keyfields);\n\tfor (idx = 0; idx < ARRAY_SIZE(ckf); idx++)\n\t\tlist_add_tail(&ckf[idx].ctrl.list, &ri.data.keyfields);\n\n\tret = vcap_rule_find_keysets(&ri.data, &matches);\n\n\tKUNIT_EXPECT_EQ(test, false, ret);\n\tKUNIT_EXPECT_EQ(test, 0, matches.cnt);\n\tKUNIT_EXPECT_EQ(test, VCAP_KFS_NO_VALUE, matches.keysets[0]);\n}\n\nstatic void vcap_api_rule_find_keyset_many_test(struct kunit *test)\n{\n\tstruct vcap_keyset_list matches = {};\n\tstruct vcap_admin admin = {\n\t\t.vtype = VCAP_TYPE_IS2,\n\t};\n\tstruct vcap_rule_internal ri = {\n\t\t.admin = &admin,\n\t\t.vctrl = &test_vctrl,\n\t};\n\tstruct vcap_client_keyfield ckf[] = {\n\t\t{\n\t\t\t.ctrl.key = VCAP_KF_TYPE,\n\t\t}, {\n\t\t\t.ctrl.key = VCAP_KF_LOOKUP_FIRST_IS,\n\t\t}, {\n\t\t\t.ctrl.key = VCAP_KF_8021Q_DEI_CLS,\n\t\t}, {\n\t\t\t.ctrl.key = VCAP_KF_8021Q_PCP_CLS,\n\t\t}, {\n\t\t\t.ctrl.key = VCAP_KF_8021Q_VID_CLS,\n\t\t}, {\n\t\t\t.ctrl.key = VCAP_KF_ISDX_CLS,\n\t\t}, {\n\t\t\t.ctrl.key = VCAP_KF_L2_MC_IS,\n\t\t}, {\n\t\t\t.ctrl.key = VCAP_KF_L2_BC_IS,\n\t\t},\n\t};\n\tint idx;\n\tbool ret;\n\tenum vcap_keyfield_set keysets[10] = {};\n\n\tmatches.keysets = keysets;\n\tmatches.max = ARRAY_SIZE(keysets);\n\n\tINIT_LIST_HEAD(&ri.data.keyfields);\n\tfor (idx = 0; idx < ARRAY_SIZE(ckf); idx++)\n\t\tlist_add_tail(&ckf[idx].ctrl.list, &ri.data.keyfields);\n\n\tret = vcap_rule_find_keysets(&ri.data, &matches);\n\n\tKUNIT_EXPECT_EQ(test, true, ret);\n\tKUNIT_EXPECT_EQ(test, 6, matches.cnt);\n\tKUNIT_EXPECT_EQ(test, VCAP_KFS_ARP, matches.keysets[0]);\n\tKUNIT_EXPECT_EQ(test, VCAP_KFS_IP4_OTHER, matches.keysets[1]);\n\tKUNIT_EXPECT_EQ(test, VCAP_KFS_IP4_TCP_UDP, matches.keysets[2]);\n\tKUNIT_EXPECT_EQ(test, VCAP_KFS_IP6_STD, matches.keysets[3]);\n\tKUNIT_EXPECT_EQ(test, VCAP_KFS_IP_7TUPLE, matches.keysets[4]);\n\tKUNIT_EXPECT_EQ(test, VCAP_KFS_MAC_ETYPE, matches.keysets[5]);\n}\n\nstatic void vcap_api_encode_rule_test(struct kunit *test)\n{\n\t \n\tstatic u32 keydata[32] = {};\n\tstatic u32 mskdata[32] = {};\n\tstatic u32 actdata[32] = {};\n\n\tstruct vcap_admin is2_admin = {\n\t\t.vtype = VCAP_TYPE_IS2,\n\t\t.first_cid = 8000000,\n\t\t.last_cid = 8099999,\n\t\t.lookups = 4,\n\t\t.last_valid_addr = 3071,\n\t\t.first_valid_addr = 0,\n\t\t.last_used_addr = 800,\n\t\t.cache = {\n\t\t\t.keystream = keydata,\n\t\t\t.maskstream = mskdata,\n\t\t\t.actionstream = actdata,\n\t\t},\n\t};\n\tstruct vcap_rule *rule;\n\tstruct vcap_rule_internal *ri;\n\tint vcap_chain_id = 8000000;\n\tenum vcap_user user = VCAP_USER_VCAP_UTIL;\n\tu16 priority = 10;\n\tint id = 100;\n\tint ret;\n\tstruct vcap_u48_key smac = {\n\t\t.value = { 0x88, 0x75, 0x32, 0x34, 0x9e, 0xb1 },\n\t\t.mask = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff }\n\t};\n\tstruct vcap_u48_key dmac = {\n\t\t.value = { 0x06, 0x05, 0x04, 0x03, 0x02, 0x01 },\n\t\t.mask = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff }\n\t};\n\tu32 port_mask_rng_value = 0x05;\n\tu32 port_mask_rng_mask = 0x0f;\n\tu32 igr_port_mask_value = 0xffabcd01;\n\tu32 igr_port_mask_mask = ~0;\n\t \n\tu32 expwriteaddr[] = {792, 792, 793, 794, 795, 796, 797};\n\tint idx;\n\n\tvcap_test_api_init(&is2_admin);\n\n\t \n\trule = vcap_alloc_rule(&test_vctrl, &test_netdev, vcap_chain_id, user,\n\t\t\t       priority, id);\n\tKUNIT_EXPECT_PTR_NE(test, NULL, rule);\n\tri = (struct vcap_rule_internal *)rule;\n\n\t \n\tret = vcap_rule_add_key_u48(rule, VCAP_KF_L2_DMAC, &dmac);\n\tKUNIT_EXPECT_EQ(test, 0, ret);\n\tret = vcap_rule_add_key_u48(rule, VCAP_KF_L2_SMAC, &smac);\n\tKUNIT_EXPECT_EQ(test, 0, ret);\n\tret = vcap_rule_add_key_bit(rule, VCAP_KF_ETYPE_LEN_IS, VCAP_BIT_1);\n\tKUNIT_EXPECT_EQ(test, 0, ret);\n\t \n\tret = vcap_rule_add_key_bit(rule, VCAP_KF_ETYPE_LEN_IS, VCAP_BIT_1);\n\tKUNIT_EXPECT_EQ(test, -EINVAL, ret);\n\tret = vcap_rule_add_key_bit(rule, VCAP_KF_IF_IGR_PORT_MASK_L3,\n\t\t\t\t    VCAP_BIT_ANY);\n\tKUNIT_EXPECT_EQ(test, 0, ret);\n\tret = vcap_rule_add_key_u32(rule, VCAP_KF_IF_IGR_PORT_MASK_RNG,\n\t\t\t\t    port_mask_rng_value, port_mask_rng_mask);\n\tKUNIT_EXPECT_EQ(test, 0, ret);\n\tret = vcap_rule_add_key_u32(rule, VCAP_KF_IF_IGR_PORT_MASK,\n\t\t\t\t    igr_port_mask_value, igr_port_mask_mask);\n\tKUNIT_EXPECT_EQ(test, 0, ret);\n\n\t \n\tret = vcap_rule_add_action_bit(rule, VCAP_AF_POLICE_ENA, VCAP_BIT_1);\n\tKUNIT_EXPECT_EQ(test, 0, ret);\n\tret = vcap_rule_add_action_u32(rule, VCAP_AF_CNT_ID, id);\n\tKUNIT_EXPECT_EQ(test, 0, ret);\n\tret = vcap_rule_add_action_u32(rule, VCAP_AF_MATCH_ID, 1);\n\tKUNIT_EXPECT_EQ(test, 0, ret);\n\tret = vcap_rule_add_action_u32(rule, VCAP_AF_MATCH_ID_MASK, 1);\n\tKUNIT_EXPECT_EQ(test, 0, ret);\n\n\t \n\tret = vcap_set_rule_set_actionset(rule, VCAP_AFS_BASE_TYPE);\n\tKUNIT_EXPECT_EQ(test, 0, ret);\n\n\t \n\tret = vcap_val_rule(rule, ETH_P_ALL);\n\tKUNIT_EXPECT_EQ(test, 0, ret);\n\tKUNIT_EXPECT_EQ(test, VCAP_KFS_MAC_ETYPE, rule->keyset);\n\tKUNIT_EXPECT_EQ(test, VCAP_AFS_BASE_TYPE, rule->actionset);\n\tKUNIT_EXPECT_EQ(test, 6, ri->size);\n\tKUNIT_EXPECT_EQ(test, 2, ri->keyset_sw_regs);\n\tKUNIT_EXPECT_EQ(test, 4, ri->actionset_sw_regs);\n\n\t \n\tret = vcap_enable_lookups(&test_vctrl, &test_netdev, 0,\n\t\t\t\t  rule->vcap_chain_id, rule->cookie, true);\n\tKUNIT_EXPECT_EQ(test, 0, ret);\n\n\t \n\tret = vcap_add_rule(rule);\n\tKUNIT_EXPECT_EQ(test, 0, ret);\n\tKUNIT_EXPECT_EQ(test, 792, is2_admin.last_used_addr);\n\tfor (idx = 0; idx < ARRAY_SIZE(expwriteaddr); ++idx)\n\t\tKUNIT_EXPECT_EQ(test, expwriteaddr[idx], test_updateaddr[idx]);\n\n\t \n\tret = list_empty(&is2_admin.rules);\n\tKUNIT_EXPECT_EQ(test, false, ret);\n\tKUNIT_EXPECT_EQ(test, 0, ret);\n\n\tvcap_enable_lookups(&test_vctrl, &test_netdev, 0, 0,\n\t\t\t    rule->cookie, false);\n\n\tvcap_free_rule(rule);\n\n\t \n\tKUNIT_EXPECT_PTR_NE(test, NULL, rule);\n\tret = list_empty(&rule->keyfields);\n\tKUNIT_EXPECT_EQ(test, true, ret);\n\tret = list_empty(&rule->actionfields);\n\tKUNIT_EXPECT_EQ(test, true, ret);\n\n\tvcap_del_rule(&test_vctrl, &test_netdev, id);\n}\n\nstatic void vcap_api_set_rule_counter_test(struct kunit *test)\n{\n\tstruct vcap_admin is2_admin = {\n\t\t.cache = {\n\t\t\t.counter = 100,\n\t\t\t.sticky = true,\n\t\t},\n\t};\n\tstruct vcap_rule_internal ri = {\n\t\t.data = {\n\t\t\t.id = 1001,\n\t\t},\n\t\t.addr = 600,\n\t\t.admin = &is2_admin,\n\t\t.counter_id = 1002,\n\t\t.vctrl = &test_vctrl,\n\t};\n\tstruct vcap_rule_internal ri2 = {\n\t\t.data = {\n\t\t\t.id = 2001,\n\t\t},\n\t\t.addr = 700,\n\t\t.admin = &is2_admin,\n\t\t.counter_id = 2002,\n\t\t.vctrl = &test_vctrl,\n\t};\n\tstruct vcap_counter ctr = { .value = 0, .sticky = false};\n\tstruct vcap_counter ctr2 = { .value = 101, .sticky = true};\n\tint ret;\n\n\tvcap_test_api_init(&is2_admin);\n\tlist_add_tail(&ri.list, &is2_admin.rules);\n\tlist_add_tail(&ri2.list, &is2_admin.rules);\n\n\tpr_info(\"%s:%d\\n\", __func__, __LINE__);\n\tret = vcap_rule_set_counter(&ri.data, &ctr);\n\tpr_info(\"%s:%d\\n\", __func__, __LINE__);\n\tKUNIT_EXPECT_EQ(test, 0, ret);\n\n\tKUNIT_EXPECT_EQ(test, 1002, test_hw_counter_id);\n\tKUNIT_EXPECT_EQ(test, 0, test_hw_cache.counter);\n\tKUNIT_EXPECT_EQ(test, false, test_hw_cache.sticky);\n\tKUNIT_EXPECT_EQ(test, 600, test_updateaddr[0]);\n\n\tret = vcap_rule_set_counter(&ri2.data, &ctr2);\n\tKUNIT_EXPECT_EQ(test, 0, ret);\n\n\tKUNIT_EXPECT_EQ(test, 2002, test_hw_counter_id);\n\tKUNIT_EXPECT_EQ(test, 101, test_hw_cache.counter);\n\tKUNIT_EXPECT_EQ(test, true, test_hw_cache.sticky);\n\tKUNIT_EXPECT_EQ(test, 700, test_updateaddr[1]);\n}\n\nstatic void vcap_api_get_rule_counter_test(struct kunit *test)\n{\n\tstruct vcap_admin is2_admin = {\n\t\t.cache = {\n\t\t\t.counter = 100,\n\t\t\t.sticky = true,\n\t\t},\n\t};\n\tstruct vcap_rule_internal ri = {\n\t\t.data = {\n\t\t\t.id = 1010,\n\t\t},\n\t\t.addr = 400,\n\t\t.admin = &is2_admin,\n\t\t.counter_id = 1011,\n\t\t.vctrl = &test_vctrl,\n\t};\n\tstruct vcap_rule_internal ri2 = {\n\t\t.data = {\n\t\t\t.id = 2011,\n\t\t},\n\t\t.addr = 300,\n\t\t.admin = &is2_admin,\n\t\t.counter_id = 2012,\n\t\t.vctrl = &test_vctrl,\n\t};\n\tstruct vcap_counter ctr = {};\n\tstruct vcap_counter ctr2 = {};\n\tint ret;\n\n\tvcap_test_api_init(&is2_admin);\n\ttest_hw_cache.counter = 55;\n\ttest_hw_cache.sticky = true;\n\n\tlist_add_tail(&ri.list, &is2_admin.rules);\n\tlist_add_tail(&ri2.list, &is2_admin.rules);\n\n\tret = vcap_rule_get_counter(&ri.data, &ctr);\n\tKUNIT_EXPECT_EQ(test, 0, ret);\n\n\tKUNIT_EXPECT_EQ(test, 1011, test_hw_counter_id);\n\tKUNIT_EXPECT_EQ(test, 55, ctr.value);\n\tKUNIT_EXPECT_EQ(test, true, ctr.sticky);\n\tKUNIT_EXPECT_EQ(test, 400, test_updateaddr[0]);\n\n\ttest_hw_cache.counter = 22;\n\ttest_hw_cache.sticky = false;\n\n\tret = vcap_rule_get_counter(&ri2.data, &ctr2);\n\tKUNIT_EXPECT_EQ(test, 0, ret);\n\n\tKUNIT_EXPECT_EQ(test, 2012, test_hw_counter_id);\n\tKUNIT_EXPECT_EQ(test, 22, ctr2.value);\n\tKUNIT_EXPECT_EQ(test, false, ctr2.sticky);\n\tKUNIT_EXPECT_EQ(test, 300, test_updateaddr[1]);\n}\n\nstatic void vcap_api_rule_insert_in_order_test(struct kunit *test)\n{\n\t \n\tstatic u32 keydata[32] = {};\n\tstatic u32 mskdata[32] = {};\n\tstatic u32 actdata[32] = {};\n\n\tstruct vcap_admin admin = {\n\t\t.vtype = VCAP_TYPE_IS0,\n\t\t.first_cid = 10000,\n\t\t.last_cid = 19999,\n\t\t.lookups = 4,\n\t\t.last_valid_addr = 3071,\n\t\t.first_valid_addr = 0,\n\t\t.last_used_addr = 800,\n\t\t.cache = {\n\t\t\t.keystream = keydata,\n\t\t\t.maskstream = mskdata,\n\t\t\t.actionstream = actdata,\n\t\t},\n\t};\n\n\tvcap_test_api_init(&admin);\n\n\t \n\ttest_vcap_xn_rule_creator(test, 10000, VCAP_USER_QOS, 10, 500, 12, 780);\n\ttest_vcap_xn_rule_creator(test, 10000, VCAP_USER_QOS, 20, 400, 6, 774);\n\ttest_vcap_xn_rule_creator(test, 10000, VCAP_USER_QOS, 30, 300, 3, 771);\n\ttest_vcap_xn_rule_creator(test, 10000, VCAP_USER_QOS, 40, 200, 2, 768);\n\n\tvcap_del_rule(&test_vctrl, &test_netdev, 200);\n\tvcap_del_rule(&test_vctrl, &test_netdev, 300);\n\tvcap_del_rule(&test_vctrl, &test_netdev, 400);\n\tvcap_del_rule(&test_vctrl, &test_netdev, 500);\n}\n\nstatic void vcap_api_rule_insert_reverse_order_test(struct kunit *test)\n{\n\t \n\tstatic u32 keydata[32] = {};\n\tstatic u32 mskdata[32] = {};\n\tstatic u32 actdata[32] = {};\n\n\tstruct vcap_admin admin = {\n\t\t.vtype = VCAP_TYPE_IS0,\n\t\t.first_cid = 10000,\n\t\t.last_cid = 19999,\n\t\t.lookups = 4,\n\t\t.last_valid_addr = 3071,\n\t\t.first_valid_addr = 0,\n\t\t.last_used_addr = 800,\n\t\t.cache = {\n\t\t\t.keystream = keydata,\n\t\t\t.maskstream = mskdata,\n\t\t\t.actionstream = actdata,\n\t\t},\n\t};\n\tstruct vcap_rule_internal *elem;\n\tu32 exp_addr[] = {780, 774, 771, 768, 767};\n\tint idx;\n\n\tvcap_test_api_init(&admin);\n\n\t \n\ttest_vcap_xn_rule_creator(test, 10000, VCAP_USER_QOS, 20, 200, 2, 798);\n\tKUNIT_EXPECT_EQ(test, 0, test_move_offset);\n\tKUNIT_EXPECT_EQ(test, 0, test_move_count);\n\tKUNIT_EXPECT_EQ(test, 0, test_move_addr);\n\n\ttest_vcap_xn_rule_creator(test, 10000, VCAP_USER_QOS, 30, 300, 3, 795);\n\tKUNIT_EXPECT_EQ(test, 6, test_move_offset);\n\tKUNIT_EXPECT_EQ(test, 3, test_move_count);\n\tKUNIT_EXPECT_EQ(test, 798, test_move_addr);\n\n\ttest_vcap_xn_rule_creator(test, 10000, VCAP_USER_QOS, 40, 400, 6, 792);\n\tKUNIT_EXPECT_EQ(test, 6, test_move_offset);\n\tKUNIT_EXPECT_EQ(test, 6, test_move_count);\n\tKUNIT_EXPECT_EQ(test, 792, test_move_addr);\n\n\ttest_vcap_xn_rule_creator(test, 10000, VCAP_USER_QOS, 50, 500, 12, 780);\n\tKUNIT_EXPECT_EQ(test, 18, test_move_offset);\n\tKUNIT_EXPECT_EQ(test, 12, test_move_count);\n\tKUNIT_EXPECT_EQ(test, 786, test_move_addr);\n\n\tidx = 0;\n\tlist_for_each_entry(elem, &admin.rules, list) {\n\t\tKUNIT_EXPECT_EQ(test, exp_addr[idx], elem->addr);\n\t\t++idx;\n\t}\n\tKUNIT_EXPECT_EQ(test, 768, admin.last_used_addr);\n\n\tvcap_del_rule(&test_vctrl, &test_netdev, 500);\n\tvcap_del_rule(&test_vctrl, &test_netdev, 400);\n\tvcap_del_rule(&test_vctrl, &test_netdev, 300);\n\tvcap_del_rule(&test_vctrl, &test_netdev, 200);\n}\n\nstatic void vcap_api_rule_remove_at_end_test(struct kunit *test)\n{\n\t \n\tstatic u32 keydata[32] = {};\n\tstatic u32 mskdata[32] = {};\n\tstatic u32 actdata[32] = {};\n\n\tstruct vcap_admin admin = {\n\t\t.vtype = VCAP_TYPE_IS0,\n\t\t.first_cid = 10000,\n\t\t.last_cid = 19999,\n\t\t.lookups = 4,\n\t\t.last_valid_addr = 3071,\n\t\t.first_valid_addr = 0,\n\t\t.last_used_addr = 800,\n\t\t.cache = {\n\t\t\t.keystream = keydata,\n\t\t\t.maskstream = mskdata,\n\t\t\t.actionstream = actdata,\n\t\t},\n\t};\n\tint ret;\n\n\tvcap_test_api_init(&admin);\n\ttest_init_rule_deletion();\n\n\t \n\ttest_vcap_xn_rule_creator(test, 10000, VCAP_USER_QOS, 10, 500, 12, 780);\n\ttest_vcap_xn_rule_creator(test, 10000, VCAP_USER_QOS, 20, 400, 6, 774);\n\ttest_vcap_xn_rule_creator(test, 10000, VCAP_USER_QOS, 30, 300, 3, 771);\n\ttest_vcap_xn_rule_creator(test, 10000, VCAP_USER_QOS, 40, 200, 2, 768);\n\n\t \n\tret = vcap_del_rule(&test_vctrl, &test_netdev, 200);\n\tKUNIT_EXPECT_EQ(test, 0, ret);\n\tKUNIT_EXPECT_EQ(test, 0, test_move_addr);\n\tKUNIT_EXPECT_EQ(test, 0, test_move_offset);\n\tKUNIT_EXPECT_EQ(test, 0, test_move_count);\n\tKUNIT_EXPECT_EQ(test, 768, test_init_start);\n\tKUNIT_EXPECT_EQ(test, 2, test_init_count);\n\tKUNIT_EXPECT_EQ(test, 771, admin.last_used_addr);\n\n\tret = vcap_del_rule(&test_vctrl, &test_netdev, 300);\n\tKUNIT_EXPECT_EQ(test, ret, 0);\n\tKUNIT_EXPECT_EQ(test, 0, test_move_addr);\n\tKUNIT_EXPECT_EQ(test, 0, test_move_offset);\n\tKUNIT_EXPECT_EQ(test, 0, test_move_count);\n\tKUNIT_EXPECT_EQ(test, 771, test_init_start);\n\tKUNIT_EXPECT_EQ(test, 3, test_init_count);\n\tKUNIT_EXPECT_EQ(test, 774, admin.last_used_addr);\n\n\tret = vcap_del_rule(&test_vctrl, &test_netdev, 400);\n\tKUNIT_EXPECT_EQ(test, ret, 0);\n\tKUNIT_EXPECT_EQ(test, 0, test_move_addr);\n\tKUNIT_EXPECT_EQ(test, 0, test_move_offset);\n\tKUNIT_EXPECT_EQ(test, 0, test_move_count);\n\tKUNIT_EXPECT_EQ(test, 774, test_init_start);\n\tKUNIT_EXPECT_EQ(test, 6, test_init_count);\n\tKUNIT_EXPECT_EQ(test, 780, admin.last_used_addr);\n\n\tret = vcap_del_rule(&test_vctrl, &test_netdev, 500);\n\tKUNIT_EXPECT_EQ(test, ret, 0);\n\tKUNIT_EXPECT_EQ(test, 0, test_move_addr);\n\tKUNIT_EXPECT_EQ(test, 0, test_move_offset);\n\tKUNIT_EXPECT_EQ(test, 0, test_move_count);\n\tKUNIT_EXPECT_EQ(test, 780, test_init_start);\n\tKUNIT_EXPECT_EQ(test, 12, test_init_count);\n\tKUNIT_EXPECT_EQ(test, 3072, admin.last_used_addr);\n}\n\nstatic void vcap_api_rule_remove_in_middle_test(struct kunit *test)\n{\n\t \n\tstatic u32 keydata[32] = {};\n\tstatic u32 mskdata[32] = {};\n\tstatic u32 actdata[32] = {};\n\n\tstruct vcap_admin admin = {\n\t\t.vtype = VCAP_TYPE_IS0,\n\t\t.first_cid = 10000,\n\t\t.last_cid = 19999,\n\t\t.lookups = 4,\n\t\t.first_valid_addr = 0,\n\t\t.last_used_addr = 800,\n\t\t.last_valid_addr = 800 - 1,\n\t\t.cache = {\n\t\t\t.keystream = keydata,\n\t\t\t.maskstream = mskdata,\n\t\t\t.actionstream = actdata,\n\t\t},\n\t};\n\tint ret;\n\n\tvcap_test_api_init(&admin);\n\n\t \n\ttest_vcap_xn_rule_creator(test, 10000, VCAP_USER_QOS, 10, 500, 12, 780);\n\ttest_vcap_xn_rule_creator(test, 10000, VCAP_USER_QOS, 20, 400, 6, 774);\n\ttest_vcap_xn_rule_creator(test, 10000, VCAP_USER_QOS, 30, 300, 3, 771);\n\ttest_vcap_xn_rule_creator(test, 10000, VCAP_USER_QOS, 40, 200, 2, 768);\n\n\t \n\ttest_init_rule_deletion();\n\tret = vcap_del_rule(&test_vctrl, &test_netdev, 400);\n\tKUNIT_EXPECT_EQ(test, 0, ret);\n\tKUNIT_EXPECT_EQ(test, 768, test_move_addr);\n\tKUNIT_EXPECT_EQ(test, -6, test_move_offset);\n\tKUNIT_EXPECT_EQ(test, 6, test_move_count);\n\tKUNIT_EXPECT_EQ(test, 768, test_init_start);\n\tKUNIT_EXPECT_EQ(test, 6, test_init_count);\n\tKUNIT_EXPECT_EQ(test, 774, admin.last_used_addr);\n\n\ttest_init_rule_deletion();\n\tret = vcap_del_rule(&test_vctrl, &test_netdev, 300);\n\tKUNIT_EXPECT_EQ(test, 0, ret);\n\tKUNIT_EXPECT_EQ(test, 774, test_move_addr);\n\tKUNIT_EXPECT_EQ(test, -4, test_move_offset);\n\tKUNIT_EXPECT_EQ(test, 2, test_move_count);\n\tKUNIT_EXPECT_EQ(test, 774, test_init_start);\n\tKUNIT_EXPECT_EQ(test, 4, test_init_count);\n\tKUNIT_EXPECT_EQ(test, 778, admin.last_used_addr);\n\n\ttest_init_rule_deletion();\n\tret = vcap_del_rule(&test_vctrl, &test_netdev, 500);\n\tKUNIT_EXPECT_EQ(test, 0, ret);\n\tKUNIT_EXPECT_EQ(test, 778, test_move_addr);\n\tKUNIT_EXPECT_EQ(test, -20, test_move_offset);\n\tKUNIT_EXPECT_EQ(test, 2, test_move_count);\n\tKUNIT_EXPECT_EQ(test, 778, test_init_start);\n\tKUNIT_EXPECT_EQ(test, 20, test_init_count);\n\tKUNIT_EXPECT_EQ(test, 798, admin.last_used_addr);\n\n\ttest_init_rule_deletion();\n\tret = vcap_del_rule(&test_vctrl, &test_netdev, 200);\n\tKUNIT_EXPECT_EQ(test, 0, ret);\n\tKUNIT_EXPECT_EQ(test, 0, test_move_addr);\n\tKUNIT_EXPECT_EQ(test, 0, test_move_offset);\n\tKUNIT_EXPECT_EQ(test, 0, test_move_count);\n\tKUNIT_EXPECT_EQ(test, 798, test_init_start);\n\tKUNIT_EXPECT_EQ(test, 2, test_init_count);\n\tKUNIT_EXPECT_EQ(test, 800, admin.last_used_addr);\n}\n\nstatic void vcap_api_rule_remove_in_front_test(struct kunit *test)\n{\n\t \n\tstatic u32 keydata[32] = {};\n\tstatic u32 mskdata[32] = {};\n\tstatic u32 actdata[32] = {};\n\n\tstruct vcap_admin admin = {\n\t\t.vtype = VCAP_TYPE_IS0,\n\t\t.first_cid = 10000,\n\t\t.last_cid = 19999,\n\t\t.lookups = 4,\n\t\t.first_valid_addr = 0,\n\t\t.last_used_addr = 800,\n\t\t.last_valid_addr = 800 - 1,\n\t\t.cache = {\n\t\t\t.keystream = keydata,\n\t\t\t.maskstream = mskdata,\n\t\t\t.actionstream = actdata,\n\t\t},\n\t};\n\tint ret;\n\n\tvcap_test_api_init(&admin);\n\n\ttest_vcap_xn_rule_creator(test, 10000, VCAP_USER_QOS, 10, 500, 12, 780);\n\tKUNIT_EXPECT_EQ(test, 780, admin.last_used_addr);\n\n\ttest_init_rule_deletion();\n\tret = vcap_del_rule(&test_vctrl, &test_netdev, 500);\n\tKUNIT_EXPECT_EQ(test, 0, ret);\n\tKUNIT_EXPECT_EQ(test, 0, test_move_addr);\n\tKUNIT_EXPECT_EQ(test, 0, test_move_offset);\n\tKUNIT_EXPECT_EQ(test, 0, test_move_count);\n\tKUNIT_EXPECT_EQ(test, 780, test_init_start);\n\tKUNIT_EXPECT_EQ(test, 12, test_init_count);\n\tKUNIT_EXPECT_EQ(test, 800, admin.last_used_addr);\n\n\ttest_vcap_xn_rule_creator(test, 10000, VCAP_USER_QOS, 20, 400, 6, 792);\n\ttest_vcap_xn_rule_creator(test, 10000, VCAP_USER_QOS, 30, 300, 3, 789);\n\ttest_vcap_xn_rule_creator(test, 10000, VCAP_USER_QOS, 40, 200, 2, 786);\n\n\ttest_init_rule_deletion();\n\tret = vcap_del_rule(&test_vctrl, &test_netdev, 400);\n\tKUNIT_EXPECT_EQ(test, 0, ret);\n\tKUNIT_EXPECT_EQ(test, 786, test_move_addr);\n\tKUNIT_EXPECT_EQ(test, -8, test_move_offset);\n\tKUNIT_EXPECT_EQ(test, 6, test_move_count);\n\tKUNIT_EXPECT_EQ(test, 786, test_init_start);\n\tKUNIT_EXPECT_EQ(test, 8, test_init_count);\n\tKUNIT_EXPECT_EQ(test, 794, admin.last_used_addr);\n\n\tvcap_del_rule(&test_vctrl, &test_netdev, 200);\n\tvcap_del_rule(&test_vctrl, &test_netdev, 300);\n}\n\nstatic struct kunit_case vcap_api_rule_remove_test_cases[] = {\n\tKUNIT_CASE(vcap_api_rule_remove_at_end_test),\n\tKUNIT_CASE(vcap_api_rule_remove_in_middle_test),\n\tKUNIT_CASE(vcap_api_rule_remove_in_front_test),\n\t{}\n};\n\nstatic void vcap_api_next_lookup_basic_test(struct kunit *test)\n{\n\tstruct vcap_admin admin1 = {\n\t\t.vtype = VCAP_TYPE_IS2,\n\t\t.vinst = 0,\n\t\t.first_cid = 8000000,\n\t\t.last_cid = 8199999,\n\t\t.lookups = 4,\n\t\t.lookups_per_instance = 2,\n\t};\n\tstruct vcap_admin admin2 = {\n\t\t.vtype = VCAP_TYPE_IS2,\n\t\t.vinst = 1,\n\t\t.first_cid = 8200000,\n\t\t.last_cid = 8399999,\n\t\t.lookups = 4,\n\t\t.lookups_per_instance = 2,\n\t};\n\tbool ret;\n\n\tvcap_test_api_init(&admin1);\n\tlist_add_tail(&admin2.list, &test_vctrl.list);\n\n\tret = vcap_is_next_lookup(&test_vctrl, 8000000, 1001000);\n\tKUNIT_EXPECT_EQ(test, false, ret);\n\tret = vcap_is_next_lookup(&test_vctrl, 8000000, 8001000);\n\tKUNIT_EXPECT_EQ(test, false, ret);\n\tret = vcap_is_next_lookup(&test_vctrl, 8000000, 8101000);\n\tKUNIT_EXPECT_EQ(test, true, ret);\n\n\tret = vcap_is_next_lookup(&test_vctrl, 8100000, 8101000);\n\tKUNIT_EXPECT_EQ(test, false, ret);\n\tret = vcap_is_next_lookup(&test_vctrl, 8100000, 8201000);\n\tKUNIT_EXPECT_EQ(test, true, ret);\n\n\tret = vcap_is_next_lookup(&test_vctrl, 8200000, 8201000);\n\tKUNIT_EXPECT_EQ(test, false, ret);\n\tret = vcap_is_next_lookup(&test_vctrl, 8200000, 8301000);\n\tKUNIT_EXPECT_EQ(test, true, ret);\n\n\tret = vcap_is_next_lookup(&test_vctrl, 8300000, 8301000);\n\tKUNIT_EXPECT_EQ(test, false, ret);\n\tret = vcap_is_next_lookup(&test_vctrl, 8300000, 8401000);\n\tKUNIT_EXPECT_EQ(test, false, ret);\n}\n\nstatic void vcap_api_next_lookup_advanced_test(struct kunit *test)\n{\n\tstruct vcap_admin admin[] = {\n\t{\n\t\t.vtype = VCAP_TYPE_IS0,\n\t\t.vinst = 0,\n\t\t.first_cid = 1000000,\n\t\t.last_cid =  1199999,\n\t\t.lookups = 6,\n\t\t.lookups_per_instance = 2,\n\t}, {\n\t\t.vtype = VCAP_TYPE_IS0,\n\t\t.vinst = 1,\n\t\t.first_cid = 1200000,\n\t\t.last_cid =  1399999,\n\t\t.lookups = 6,\n\t\t.lookups_per_instance = 2,\n\t}, {\n\t\t.vtype = VCAP_TYPE_IS0,\n\t\t.vinst = 2,\n\t\t.first_cid = 1400000,\n\t\t.last_cid =  1599999,\n\t\t.lookups = 6,\n\t\t.lookups_per_instance = 2,\n\t}, {\n\t\t.vtype = VCAP_TYPE_IS2,\n\t\t.vinst = 0,\n\t\t.first_cid = 8000000,\n\t\t.last_cid = 8199999,\n\t\t.lookups = 4,\n\t\t.lookups_per_instance = 2,\n\t}, {\n\t\t.vtype = VCAP_TYPE_IS2,\n\t\t.vinst = 1,\n\t\t.first_cid = 8200000,\n\t\t.last_cid = 8399999,\n\t\t.lookups = 4,\n\t\t.lookups_per_instance = 2,\n\t}\n\t};\n\tbool ret;\n\n\tvcap_test_api_init(&admin[0]);\n\tlist_add_tail(&admin[1].list, &test_vctrl.list);\n\tlist_add_tail(&admin[2].list, &test_vctrl.list);\n\tlist_add_tail(&admin[3].list, &test_vctrl.list);\n\tlist_add_tail(&admin[4].list, &test_vctrl.list);\n\n\tret = vcap_is_next_lookup(&test_vctrl, 1000000, 1001000);\n\tKUNIT_EXPECT_EQ(test, false, ret);\n\tret = vcap_is_next_lookup(&test_vctrl, 1000000, 1101000);\n\tKUNIT_EXPECT_EQ(test, true, ret);\n\n\tret = vcap_is_next_lookup(&test_vctrl, 1100000, 1201000);\n\tKUNIT_EXPECT_EQ(test, true, ret);\n\tret = vcap_is_next_lookup(&test_vctrl, 1100000, 1301000);\n\tKUNIT_EXPECT_EQ(test, true, ret);\n\tret = vcap_is_next_lookup(&test_vctrl, 1100000, 8101000);\n\tKUNIT_EXPECT_EQ(test, true, ret);\n\tret = vcap_is_next_lookup(&test_vctrl, 1300000, 1401000);\n\tKUNIT_EXPECT_EQ(test, true, ret);\n\tret = vcap_is_next_lookup(&test_vctrl, 1400000, 1501000);\n\tKUNIT_EXPECT_EQ(test, true, ret);\n\tret = vcap_is_next_lookup(&test_vctrl, 1500000, 8001000);\n\tKUNIT_EXPECT_EQ(test, true, ret);\n\n\tret = vcap_is_next_lookup(&test_vctrl, 8000000, 8001000);\n\tKUNIT_EXPECT_EQ(test, false, ret);\n\tret = vcap_is_next_lookup(&test_vctrl, 8000000, 8101000);\n\tKUNIT_EXPECT_EQ(test, true, ret);\n\n\tret = vcap_is_next_lookup(&test_vctrl, 8300000, 8301000);\n\tKUNIT_EXPECT_EQ(test, false, ret);\n\tret = vcap_is_next_lookup(&test_vctrl, 8300000, 8401000);\n\tKUNIT_EXPECT_EQ(test, false, ret);\n}\n\nstatic void vcap_api_filter_unsupported_keys_test(struct kunit *test)\n{\n\tstruct vcap_admin admin = {\n\t\t.vtype = VCAP_TYPE_IS2,\n\t};\n\tstruct vcap_rule_internal ri = {\n\t\t.admin = &admin,\n\t\t.vctrl = &test_vctrl,\n\t\t.data.keyset = VCAP_KFS_MAC_ETYPE,\n\t};\n\tenum vcap_key_field keylist[] = {\n\t\tVCAP_KF_TYPE,\n\t\tVCAP_KF_LOOKUP_FIRST_IS,\n\t\tVCAP_KF_ARP_ADDR_SPACE_OK_IS,   \n\t\tVCAP_KF_ARP_PROTO_SPACE_OK_IS,\n\t\tVCAP_KF_ARP_LEN_OK_IS,\n\t\tVCAP_KF_ARP_TGT_MATCH_IS,\n\t\tVCAP_KF_ARP_SENDER_MATCH_IS,\n\t\tVCAP_KF_ARP_OPCODE_UNKNOWN_IS,\n\t\tVCAP_KF_ARP_OPCODE,\n\t\tVCAP_KF_8021Q_DEI_CLS,\n\t\tVCAP_KF_8021Q_PCP_CLS,\n\t\tVCAP_KF_8021Q_VID_CLS,\n\t\tVCAP_KF_L2_MC_IS,\n\t\tVCAP_KF_L2_BC_IS,\n\t};\n\tenum vcap_key_field expected[] = {\n\t\tVCAP_KF_TYPE,\n\t\tVCAP_KF_LOOKUP_FIRST_IS,\n\t\tVCAP_KF_8021Q_DEI_CLS,\n\t\tVCAP_KF_8021Q_PCP_CLS,\n\t\tVCAP_KF_8021Q_VID_CLS,\n\t\tVCAP_KF_L2_MC_IS,\n\t\tVCAP_KF_L2_BC_IS,\n\t};\n\tstruct vcap_client_keyfield *ckf, *next;\n\tbool ret;\n\tint idx;\n\n\t \n\tINIT_LIST_HEAD(&ri.data.keyfields);\n\tfor (idx = 0; idx < ARRAY_SIZE(keylist); idx++) {\n\t\tckf = kzalloc(sizeof(*ckf), GFP_KERNEL);\n\t\tif (ckf) {\n\t\t\tckf->ctrl.key = keylist[idx];\n\t\t\tlist_add_tail(&ckf->ctrl.list, &ri.data.keyfields);\n\t\t}\n\t}\n\n\tKUNIT_EXPECT_EQ(test, 14, ARRAY_SIZE(keylist));\n\n\t \n\tret = vcap_filter_rule_keys(&ri.data, NULL, 0, true);\n\n\tKUNIT_EXPECT_EQ(test, 0, ret);\n\n\t \n\tidx = 0;\n\tlist_for_each_entry_safe(ckf, next, &ri.data.keyfields, ctrl.list) {\n\t\tKUNIT_EXPECT_EQ(test, expected[idx], ckf->ctrl.key);\n\t\tlist_del(&ckf->ctrl.list);\n\t\tkfree(ckf);\n\t\t++idx;\n\t}\n\tKUNIT_EXPECT_EQ(test, 7, idx);\n}\n\nstatic void vcap_api_filter_keylist_test(struct kunit *test)\n{\n\tstruct vcap_admin admin = {\n\t\t.vtype = VCAP_TYPE_IS0,\n\t};\n\tstruct vcap_rule_internal ri = {\n\t\t.admin = &admin,\n\t\t.vctrl = &test_vctrl,\n\t\t.data.keyset = VCAP_KFS_NORMAL_7TUPLE,\n\t};\n\tenum vcap_key_field keylist[] = {\n\t\tVCAP_KF_TYPE,\n\t\tVCAP_KF_LOOKUP_FIRST_IS,\n\t\tVCAP_KF_LOOKUP_GEN_IDX_SEL,\n\t\tVCAP_KF_LOOKUP_GEN_IDX,\n\t\tVCAP_KF_IF_IGR_PORT_MASK_SEL,\n\t\tVCAP_KF_IF_IGR_PORT_MASK,\n\t\tVCAP_KF_L2_MC_IS,\n\t\tVCAP_KF_L2_BC_IS,\n\t\tVCAP_KF_8021Q_VLAN_TAGS,\n\t\tVCAP_KF_8021Q_TPID0,\n\t\tVCAP_KF_8021Q_PCP0,\n\t\tVCAP_KF_8021Q_DEI0,\n\t\tVCAP_KF_8021Q_VID0,\n\t\tVCAP_KF_8021Q_TPID1,\n\t\tVCAP_KF_8021Q_PCP1,\n\t\tVCAP_KF_8021Q_DEI1,\n\t\tVCAP_KF_8021Q_VID1,\n\t\tVCAP_KF_8021Q_TPID2,\n\t\tVCAP_KF_8021Q_PCP2,\n\t\tVCAP_KF_8021Q_DEI2,\n\t\tVCAP_KF_8021Q_VID2,\n\t\tVCAP_KF_L2_DMAC,\n\t\tVCAP_KF_L2_SMAC,\n\t\tVCAP_KF_IP_MC_IS,\n\t\tVCAP_KF_ETYPE_LEN_IS,\n\t\tVCAP_KF_ETYPE,\n\t\tVCAP_KF_IP_SNAP_IS,\n\t\tVCAP_KF_IP4_IS,\n\t\tVCAP_KF_L3_FRAGMENT_TYPE,\n\t\tVCAP_KF_L3_FRAG_INVLD_L4_LEN,\n\t\tVCAP_KF_L3_OPTIONS_IS,\n\t\tVCAP_KF_L3_DSCP,\n\t\tVCAP_KF_L3_IP6_DIP,\n\t\tVCAP_KF_L3_IP6_SIP,\n\t\tVCAP_KF_TCP_UDP_IS,\n\t\tVCAP_KF_TCP_IS,\n\t\tVCAP_KF_L4_SPORT,\n\t\tVCAP_KF_L4_RNG,\n\t};\n\tenum vcap_key_field droplist[] = {\n\t\tVCAP_KF_8021Q_TPID1,\n\t\tVCAP_KF_8021Q_PCP1,\n\t\tVCAP_KF_8021Q_DEI1,\n\t\tVCAP_KF_8021Q_VID1,\n\t\tVCAP_KF_8021Q_TPID2,\n\t\tVCAP_KF_8021Q_PCP2,\n\t\tVCAP_KF_8021Q_DEI2,\n\t\tVCAP_KF_8021Q_VID2,\n\t\tVCAP_KF_L3_IP6_DIP,\n\t\tVCAP_KF_L3_IP6_SIP,\n\t\tVCAP_KF_L4_SPORT,\n\t\tVCAP_KF_L4_RNG,\n\t};\n\tenum vcap_key_field expected[] = {\n\t\tVCAP_KF_TYPE,\n\t\tVCAP_KF_LOOKUP_FIRST_IS,\n\t\tVCAP_KF_LOOKUP_GEN_IDX_SEL,\n\t\tVCAP_KF_LOOKUP_GEN_IDX,\n\t\tVCAP_KF_IF_IGR_PORT_MASK_SEL,\n\t\tVCAP_KF_IF_IGR_PORT_MASK,\n\t\tVCAP_KF_L2_MC_IS,\n\t\tVCAP_KF_L2_BC_IS,\n\t\tVCAP_KF_8021Q_VLAN_TAGS,\n\t\tVCAP_KF_8021Q_TPID0,\n\t\tVCAP_KF_8021Q_PCP0,\n\t\tVCAP_KF_8021Q_DEI0,\n\t\tVCAP_KF_8021Q_VID0,\n\t\tVCAP_KF_L2_DMAC,\n\t\tVCAP_KF_L2_SMAC,\n\t\tVCAP_KF_IP_MC_IS,\n\t\tVCAP_KF_ETYPE_LEN_IS,\n\t\tVCAP_KF_ETYPE,\n\t\tVCAP_KF_IP_SNAP_IS,\n\t\tVCAP_KF_IP4_IS,\n\t\tVCAP_KF_L3_FRAGMENT_TYPE,\n\t\tVCAP_KF_L3_FRAG_INVLD_L4_LEN,\n\t\tVCAP_KF_L3_OPTIONS_IS,\n\t\tVCAP_KF_L3_DSCP,\n\t\tVCAP_KF_TCP_UDP_IS,\n\t\tVCAP_KF_TCP_IS,\n\t};\n\tstruct vcap_client_keyfield *ckf, *next;\n\tbool ret;\n\tint idx;\n\n\t \n\tINIT_LIST_HEAD(&ri.data.keyfields);\n\tfor (idx = 0; idx < ARRAY_SIZE(keylist); idx++) {\n\t\tckf = kzalloc(sizeof(*ckf), GFP_KERNEL);\n\t\tif (ckf) {\n\t\t\tckf->ctrl.key = keylist[idx];\n\t\t\tlist_add_tail(&ckf->ctrl.list, &ri.data.keyfields);\n\t\t}\n\t}\n\n\tKUNIT_EXPECT_EQ(test, 38, ARRAY_SIZE(keylist));\n\n\t \n\tret = vcap_filter_rule_keys(&ri.data, droplist, ARRAY_SIZE(droplist),\n\t\t\t\t    false);\n\n\tKUNIT_EXPECT_EQ(test, 0, ret);\n\n\t \n\tidx = 0;\n\tlist_for_each_entry_safe(ckf, next, &ri.data.keyfields, ctrl.list) {\n\t\tKUNIT_EXPECT_EQ(test, expected[idx], ckf->ctrl.key);\n\t\tlist_del(&ckf->ctrl.list);\n\t\tkfree(ckf);\n\t\t++idx;\n\t}\n\tKUNIT_EXPECT_EQ(test, 26, idx);\n}\n\nstatic void vcap_api_rule_chain_path_test(struct kunit *test)\n{\n\tstruct vcap_admin admin1 = {\n\t\t.vtype = VCAP_TYPE_IS0,\n\t\t.vinst = 0,\n\t\t.first_cid = 1000000,\n\t\t.last_cid =  1199999,\n\t\t.lookups = 6,\n\t\t.lookups_per_instance = 2,\n\t};\n\tstruct vcap_enabled_port eport3 = {\n\t\t.ndev = &test_netdev,\n\t\t.cookie = 0x100,\n\t\t.src_cid = 0,\n\t\t.dst_cid = 1000000,\n\t};\n\tstruct vcap_enabled_port eport2 = {\n\t\t.ndev = &test_netdev,\n\t\t.cookie = 0x200,\n\t\t.src_cid = 1000000,\n\t\t.dst_cid = 1100000,\n\t};\n\tstruct vcap_enabled_port eport1 = {\n\t\t.ndev = &test_netdev,\n\t\t.cookie = 0x300,\n\t\t.src_cid = 1100000,\n\t\t.dst_cid = 8000000,\n\t};\n\tbool ret;\n\tint chain;\n\n\tvcap_test_api_init(&admin1);\n\tlist_add_tail(&eport1.list, &admin1.enabled);\n\tlist_add_tail(&eport2.list, &admin1.enabled);\n\tlist_add_tail(&eport3.list, &admin1.enabled);\n\n\tret = vcap_path_exist(&test_vctrl, &test_netdev, 1000000);\n\tKUNIT_EXPECT_EQ(test, true, ret);\n\n\tret = vcap_path_exist(&test_vctrl, &test_netdev, 1100000);\n\tKUNIT_EXPECT_EQ(test, true, ret);\n\n\tret = vcap_path_exist(&test_vctrl, &test_netdev, 1200000);\n\tKUNIT_EXPECT_EQ(test, false, ret);\n\n\tchain = vcap_get_next_chain(&test_vctrl, &test_netdev, 0);\n\tKUNIT_EXPECT_EQ(test, 1000000, chain);\n\n\tchain = vcap_get_next_chain(&test_vctrl, &test_netdev, 1000000);\n\tKUNIT_EXPECT_EQ(test, 1100000, chain);\n\n\tchain = vcap_get_next_chain(&test_vctrl, &test_netdev, 1100000);\n\tKUNIT_EXPECT_EQ(test, 8000000, chain);\n}\n\nstatic struct kunit_case vcap_api_rule_enable_test_cases[] = {\n\tKUNIT_CASE(vcap_api_rule_chain_path_test),\n\t{}\n};\n\nstatic struct kunit_suite vcap_api_rule_enable_test_suite = {\n\t.name = \"VCAP_API_Rule_Enable_Testsuite\",\n\t.test_cases = vcap_api_rule_enable_test_cases,\n};\n\nstatic struct kunit_suite vcap_api_rule_remove_test_suite = {\n\t.name = \"VCAP_API_Rule_Remove_Testsuite\",\n\t.test_cases = vcap_api_rule_remove_test_cases,\n};\n\nstatic struct kunit_case vcap_api_rule_insert_test_cases[] = {\n\tKUNIT_CASE(vcap_api_rule_insert_in_order_test),\n\tKUNIT_CASE(vcap_api_rule_insert_reverse_order_test),\n\t{}\n};\n\nstatic struct kunit_suite vcap_api_rule_insert_test_suite = {\n\t.name = \"VCAP_API_Rule_Insert_Testsuite\",\n\t.test_cases = vcap_api_rule_insert_test_cases,\n};\n\nstatic struct kunit_case vcap_api_rule_counter_test_cases[] = {\n\tKUNIT_CASE(vcap_api_set_rule_counter_test),\n\tKUNIT_CASE(vcap_api_get_rule_counter_test),\n\t{}\n};\n\nstatic struct kunit_suite vcap_api_rule_counter_test_suite = {\n\t.name = \"VCAP_API_Rule_Counter_Testsuite\",\n\t.test_cases = vcap_api_rule_counter_test_cases,\n};\n\nstatic struct kunit_case vcap_api_support_test_cases[] = {\n\tKUNIT_CASE(vcap_api_next_lookup_basic_test),\n\tKUNIT_CASE(vcap_api_next_lookup_advanced_test),\n\tKUNIT_CASE(vcap_api_filter_unsupported_keys_test),\n\tKUNIT_CASE(vcap_api_filter_keylist_test),\n\t{}\n};\n\nstatic struct kunit_suite vcap_api_support_test_suite = {\n\t.name = \"VCAP_API_Support_Testsuite\",\n\t.test_cases = vcap_api_support_test_cases,\n};\n\nstatic struct kunit_case vcap_api_full_rule_test_cases[] = {\n\tKUNIT_CASE(vcap_api_rule_find_keyset_basic_test),\n\tKUNIT_CASE(vcap_api_rule_find_keyset_failed_test),\n\tKUNIT_CASE(vcap_api_rule_find_keyset_many_test),\n\tKUNIT_CASE(vcap_api_encode_rule_test),\n\t{}\n};\n\nstatic struct kunit_suite vcap_api_full_rule_test_suite = {\n\t.name = \"VCAP_API_Full_Rule_Testsuite\",\n\t.test_cases = vcap_api_full_rule_test_cases,\n};\n\nstatic struct kunit_case vcap_api_rule_value_test_cases[] = {\n\tKUNIT_CASE(vcap_api_rule_add_keyvalue_test),\n\tKUNIT_CASE(vcap_api_rule_add_actionvalue_test),\n\t{}\n};\n\nstatic struct kunit_suite vcap_api_rule_value_test_suite = {\n\t.name = \"VCAP_API_Rule_Value_Testsuite\",\n\t.test_cases = vcap_api_rule_value_test_cases,\n};\n\nstatic struct kunit_case vcap_api_encoding_test_cases[] = {\n\tKUNIT_CASE(vcap_api_set_bit_1_test),\n\tKUNIT_CASE(vcap_api_set_bit_0_test),\n\tKUNIT_CASE(vcap_api_iterator_init_test),\n\tKUNIT_CASE(vcap_api_iterator_next_test),\n\tKUNIT_CASE(vcap_api_encode_typegroups_test),\n\tKUNIT_CASE(vcap_api_encode_bit_test),\n\tKUNIT_CASE(vcap_api_encode_field_test),\n\tKUNIT_CASE(vcap_api_encode_short_field_test),\n\tKUNIT_CASE(vcap_api_encode_keyfield_test),\n\tKUNIT_CASE(vcap_api_encode_max_keyfield_test),\n\tKUNIT_CASE(vcap_api_encode_actionfield_test),\n\tKUNIT_CASE(vcap_api_keyfield_typegroup_test),\n\tKUNIT_CASE(vcap_api_actionfield_typegroup_test),\n\tKUNIT_CASE(vcap_api_vcap_keyfields_test),\n\tKUNIT_CASE(vcap_api_vcap_actionfields_test),\n\tKUNIT_CASE(vcap_api_encode_rule_keyset_test),\n\tKUNIT_CASE(vcap_api_encode_rule_actionset_test),\n\t{}\n};\n\nstatic struct kunit_suite vcap_api_encoding_test_suite = {\n\t.name = \"VCAP_API_Encoding_Testsuite\",\n\t.test_cases = vcap_api_encoding_test_cases,\n};\n\nkunit_test_suite(vcap_api_rule_enable_test_suite);\nkunit_test_suite(vcap_api_rule_remove_test_suite);\nkunit_test_suite(vcap_api_rule_insert_test_suite);\nkunit_test_suite(vcap_api_rule_counter_test_suite);\nkunit_test_suite(vcap_api_support_test_suite);\nkunit_test_suite(vcap_api_full_rule_test_suite);\nkunit_test_suite(vcap_api_rule_value_test_suite);\nkunit_test_suite(vcap_api_encoding_test_suite);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}