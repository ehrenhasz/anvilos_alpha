{
  "module_name": "vcap_api.h",
  "hash_id": "68b2cec4b805ea4125239f53982efc7da0c60154c4dd58d9964847f027983625",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/microchip/vcap/vcap_api.h",
  "human_readable_source": " \n \n\n#ifndef __VCAP_API__\n#define __VCAP_API__\n\n#include <linux/types.h>\n#include <linux/list.h>\n#include <linux/netdevice.h>\n\n \n#include \"vcap_ag_api.h\"\n\n#define VCAP_CID_LOOKUP_SIZE          100000  \n#define VCAP_CID_INGRESS_L0          1000000  \n#define VCAP_CID_INGRESS_L1          1100000  \n#define VCAP_CID_INGRESS_L2          1200000  \n#define VCAP_CID_INGRESS_L3          1300000  \n#define VCAP_CID_INGRESS_L4          1400000  \n#define VCAP_CID_INGRESS_L5          1500000  \n\n#define VCAP_CID_PREROUTING_IPV6     3000000  \n#define VCAP_CID_PREROUTING          6000000  \n\n#define VCAP_CID_INGRESS_STAGE2_L0   8000000  \n#define VCAP_CID_INGRESS_STAGE2_L1   8100000  \n#define VCAP_CID_INGRESS_STAGE2_L2   8200000  \n#define VCAP_CID_INGRESS_STAGE2_L3   8300000  \n\n#define VCAP_CID_EGRESS_L0           10000000  \n#define VCAP_CID_EGRESS_L1           10100000  \n\n#define VCAP_CID_EGRESS_STAGE2_L0    20000000  \n#define VCAP_CID_EGRESS_STAGE2_L1    20100000  \n\n \nenum vcap_user {\n\tVCAP_USER_PTP,\n\tVCAP_USER_MRP,\n\tVCAP_USER_CFM,\n\tVCAP_USER_VLAN,\n\tVCAP_USER_QOS,\n\tVCAP_USER_VCAP_UTIL,\n\tVCAP_USER_TC,\n\tVCAP_USER_TC_EXTRA,\n\n\t \n\n\t \n\t__VCAP_USER_AFTER_LAST,\n\tVCAP_USER_MAX = __VCAP_USER_AFTER_LAST - 1,\n};\n\n \nstruct vcap_statistics {\n\tchar *name;\n\tint count;\n\tconst char * const *keyfield_set_names;\n\tconst char * const *actionfield_set_names;\n\tconst char * const *keyfield_names;\n\tconst char * const *actionfield_names;\n};\n\n \nstruct vcap_field {\n\tu16 type;\n\tu16 width;\n\tu16 offset;\n};\n\n \nstruct vcap_set {\n\tu8 type_id;\n\tu8 sw_per_item;\n\tu8 sw_cnt;\n};\n\n \nstruct vcap_typegroup {\n\tu16 offset;\n\tu16 width;\n\tu16 value;\n};\n\n \nstruct vcap_info {\n\tchar *name;  \n\tu16 rows;  \n\tu16 sw_count;  \n\tu16 sw_width;  \n\tu16 sticky_width;  \n\tu16 act_width;   \n\tu16 default_cnt;  \n\tu16 require_cnt_dis;  \n\tu16 version;  \n\tconst struct vcap_set *keyfield_set;  \n\tint keyfield_set_size;  \n\tconst struct vcap_set *actionfield_set;  \n\tint actionfield_set_size;  \n\t \n\tconst struct vcap_field **keyfield_set_map;\n\t \n\tint *keyfield_set_map_size;\n\t \n\tconst struct vcap_field **actionfield_set_map;\n\t \n\tint *actionfield_set_map_size;\n\t \n\tconst struct vcap_typegroup **keyfield_set_typegroups;\n\t \n\tconst struct vcap_typegroup **actionfield_set_typegroups;\n};\n\nenum vcap_field_type {\n\tVCAP_FIELD_BIT,\n\tVCAP_FIELD_U32,\n\tVCAP_FIELD_U48,\n\tVCAP_FIELD_U56,\n\tVCAP_FIELD_U64,\n\tVCAP_FIELD_U72,\n\tVCAP_FIELD_U112,\n\tVCAP_FIELD_U128,\n};\n\n \nstruct vcap_cache_data {\n\tu32 *keystream;\n\tu32 *maskstream;\n\tu32 *actionstream;\n\tu32 counter;\n\tbool sticky;\n};\n\n \nenum vcap_selection {\n\tVCAP_SEL_ENTRY = 0x01,\n\tVCAP_SEL_ACTION = 0x02,\n\tVCAP_SEL_COUNTER = 0x04,\n\tVCAP_SEL_ALL = 0xff,\n};\n\n \nenum vcap_command {\n\tVCAP_CMD_WRITE = 0,\n\tVCAP_CMD_READ = 1,\n\tVCAP_CMD_MOVE_DOWN = 2,\n\tVCAP_CMD_MOVE_UP = 3,\n\tVCAP_CMD_INITIALIZE = 4,\n};\n\nenum vcap_rule_error {\n\tVCAP_ERR_NONE = 0,   \n\tVCAP_ERR_NO_ADMIN,   \n\tVCAP_ERR_NO_NETDEV,   \n\tVCAP_ERR_NO_KEYSET_MATCH,  \n\tVCAP_ERR_NO_ACTIONSET_MATCH,  \n\tVCAP_ERR_NO_PORT_KEYSET_MATCH,  \n};\n\n \nstruct vcap_admin {\n\tstruct list_head list;  \n\tstruct list_head rules;  \n\tstruct list_head enabled;  \n\tstruct mutex lock;  \n\tenum vcap_type vtype;   \n\tint vinst;  \n\tint first_cid;  \n\tint last_cid;  \n\tint tgt_inst;  \n\tint lookups;  \n\tint lookups_per_instance;  \n\tint last_valid_addr;  \n\tint first_valid_addr;  \n\tint last_used_addr;   \n\tbool w32be;  \n\tbool ingress;  \n\tstruct vcap_cache_data cache;  \n};\n\n \nstruct vcap_rule {\n\tint vcap_chain_id;  \n\tenum vcap_user user;  \n\tu16 priority;\n\tu32 id;   \n\tu64 cookie;   \n\tstruct list_head keyfields;   \n\tstruct list_head actionfields;   \n\tenum vcap_keyfield_set keyset;  \n\tenum vcap_actionfield_set actionset;  \n\tenum vcap_rule_error exterr;  \n\tu64 client;  \n};\n\n \nstruct vcap_keyset_list {\n\tint max;  \n\tint cnt;  \n\tenum vcap_keyfield_set *keysets;  \n};\n\n \nstruct vcap_actionset_list {\n\tint max;  \n\tint cnt;  \n\tenum vcap_actionfield_set *actionsets;  \n};\n\n \nstruct vcap_output_print {\n\t__printf(2, 3)\n\tvoid (*prf)(void *out, const char *fmt, ...);\n\tvoid *dst;\n};\n\n \nstruct vcap_operations {\n\t \n\tenum vcap_keyfield_set (*validate_keyset)\n\t\t(struct net_device *ndev,\n\t\t struct vcap_admin *admin,\n\t\t struct vcap_rule *rule,\n\t\t struct vcap_keyset_list *kslist,\n\t\t u16 l3_proto);\n\t \n\tvoid (*add_default_fields)\n\t\t(struct net_device *ndev,\n\t\t struct vcap_admin *admin,\n\t\t struct vcap_rule *rule);\n\t \n\tvoid (*cache_erase)\n\t\t(struct vcap_admin *admin);\n\tvoid (*cache_write)\n\t\t(struct net_device *ndev,\n\t\t struct vcap_admin *admin,\n\t\t enum vcap_selection sel,\n\t\t u32 idx, u32 count);\n\tvoid (*cache_read)\n\t\t(struct net_device *ndev,\n\t\t struct vcap_admin *admin,\n\t\t enum vcap_selection sel,\n\t\t u32 idx,\n\t\t u32 count);\n\t \n\tvoid (*init)\n\t\t(struct net_device *ndev,\n\t\t struct vcap_admin *admin,\n\t\t u32 addr,\n\t\t u32 count);\n\tvoid (*update)\n\t\t(struct net_device *ndev,\n\t\t struct vcap_admin *admin,\n\t\t enum vcap_command cmd,\n\t\t enum vcap_selection sel,\n\t\t u32 addr);\n\tvoid (*move)\n\t\t(struct net_device *ndev,\n\t\t struct vcap_admin *admin,\n\t\t u32 addr,\n\t\t int offset,\n\t\t int count);\n\t \n\tint (*port_info)\n\t\t(struct net_device *ndev,\n\t\t struct vcap_admin *admin,\n\t\t struct vcap_output_print *out);\n};\n\n \nstruct vcap_control {\n\tstruct vcap_operations *ops;   \n\tconst struct vcap_info *vcaps;  \n\tconst struct vcap_statistics *stats;  \n\tstruct list_head list;  \n};\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}