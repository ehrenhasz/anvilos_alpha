{
  "module_name": "vcap_api_debugfs_kunit.c",
  "hash_id": "25df111c65e0343f9c2f48ad245b5e0876e244d75a0129b99772dfdebac7da7e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/microchip/vcap/vcap_api_debugfs_kunit.c",
  "human_readable_source": "\n \n\n#include <kunit/test.h>\n#include \"vcap_api.h\"\n#include \"vcap_api_client.h\"\n#include \"vcap_api_debugfs.h\"\n#include \"vcap_model_kunit.h\"\n\n \n#define TEST_BUF_CNT 100\n#define TEST_BUF_SZ  350\n#define STREAMWSIZE 64\n\nstatic u32 test_updateaddr[STREAMWSIZE] = {};\nstatic int test_updateaddridx;\nstatic int test_cache_erase_count;\nstatic u32 test_init_start;\nstatic u32 test_init_count;\nstatic u32 test_hw_counter_id;\nstatic struct vcap_cache_data test_hw_cache;\nstatic struct net_device test_netdev = {};\nstatic int test_move_addr;\nstatic int test_move_offset;\nstatic int test_move_count;\nstatic char test_pr_buffer[TEST_BUF_CNT][TEST_BUF_SZ];\nstatic int test_pr_bufferidx;\nstatic int test_pr_idx;\n\n \nstatic enum vcap_keyfield_set test_val_keyset(struct net_device *ndev,\n\t\t\t\t\t      struct vcap_admin *admin,\n\t\t\t\t\t      struct vcap_rule *rule,\n\t\t\t\t\t      struct vcap_keyset_list *kslist,\n\t\t\t\t\t      u16 l3_proto)\n{\n\tint idx;\n\n\tif (kslist->cnt > 0) {\n\t\tswitch (admin->vtype) {\n\t\tcase VCAP_TYPE_IS0:\n\t\t\tfor (idx = 0; idx < kslist->cnt; idx++) {\n\t\t\t\tif (kslist->keysets[idx] == VCAP_KFS_ETAG)\n\t\t\t\t\treturn kslist->keysets[idx];\n\t\t\t\tif (kslist->keysets[idx] ==\n\t\t\t\t    VCAP_KFS_PURE_5TUPLE_IP4)\n\t\t\t\t\treturn kslist->keysets[idx];\n\t\t\t\tif (kslist->keysets[idx] ==\n\t\t\t\t    VCAP_KFS_NORMAL_5TUPLE_IP4)\n\t\t\t\t\treturn kslist->keysets[idx];\n\t\t\t\tif (kslist->keysets[idx] ==\n\t\t\t\t    VCAP_KFS_NORMAL_7TUPLE)\n\t\t\t\t\treturn kslist->keysets[idx];\n\t\t\t}\n\t\t\tbreak;\n\t\tcase VCAP_TYPE_IS2:\n\t\t\tfor (idx = 0; idx < kslist->cnt; idx++) {\n\t\t\t\tif (kslist->keysets[idx] == VCAP_KFS_MAC_ETYPE)\n\t\t\t\t\treturn kslist->keysets[idx];\n\t\t\t\tif (kslist->keysets[idx] == VCAP_KFS_ARP)\n\t\t\t\t\treturn kslist->keysets[idx];\n\t\t\t\tif (kslist->keysets[idx] == VCAP_KFS_IP_7TUPLE)\n\t\t\t\t\treturn kslist->keysets[idx];\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_info(\"%s:%d: no validation for VCAP %d\\n\",\n\t\t\t\t__func__, __LINE__, admin->vtype);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn -EINVAL;\n}\n\n \nstatic void test_add_def_fields(struct net_device *ndev,\n\t\t\t\tstruct vcap_admin *admin,\n\t\t\t\tstruct vcap_rule *rule)\n{\n\tif (admin->vinst == 0 || admin->vinst == 2)\n\t\tvcap_rule_add_key_bit(rule, VCAP_KF_LOOKUP_FIRST_IS,\n\t\t\t\t      VCAP_BIT_1);\n\telse\n\t\tvcap_rule_add_key_bit(rule, VCAP_KF_LOOKUP_FIRST_IS,\n\t\t\t\t      VCAP_BIT_0);\n}\n\n \nstatic void test_cache_erase(struct vcap_admin *admin)\n{\n\tif (test_cache_erase_count) {\n\t\tmemset(admin->cache.keystream, 0, test_cache_erase_count);\n\t\tmemset(admin->cache.maskstream, 0, test_cache_erase_count);\n\t\tmemset(admin->cache.actionstream, 0, test_cache_erase_count);\n\t\ttest_cache_erase_count = 0;\n\t}\n}\n\n \nstatic void test_cache_init(struct net_device *ndev, struct vcap_admin *admin,\n\t\t\t    u32 start, u32 count)\n{\n\ttest_init_start = start;\n\ttest_init_count = count;\n}\n\n \nstatic void test_cache_read(struct net_device *ndev, struct vcap_admin *admin,\n\t\t\t    enum vcap_selection sel, u32 start, u32 count)\n{\n\tu32 *keystr, *mskstr, *actstr;\n\tint idx;\n\n\tpr_debug(\"%s:%d: %d %d\\n\", __func__, __LINE__, start, count);\n\tswitch (sel) {\n\tcase VCAP_SEL_ENTRY:\n\t\tkeystr = &admin->cache.keystream[start];\n\t\tmskstr = &admin->cache.maskstream[start];\n\t\tfor (idx = 0; idx < count; ++idx) {\n\t\t\tpr_debug(\"%s:%d: keydata[%02d]: 0x%08x\\n\", __func__,\n\t\t\t\t __LINE__, start + idx, keystr[idx]);\n\t\t}\n\t\tfor (idx = 0; idx < count; ++idx) {\n\t\t\t \n\t\t\tmskstr[idx] = ~mskstr[idx];\n\t\t\tpr_debug(\"%s:%d: mskdata[%02d]: 0x%08x\\n\", __func__,\n\t\t\t\t __LINE__, start + idx, mskstr[idx]);\n\t\t}\n\t\tbreak;\n\tcase VCAP_SEL_ACTION:\n\t\tactstr = &admin->cache.actionstream[start];\n\t\tfor (idx = 0; idx < count; ++idx) {\n\t\t\tpr_debug(\"%s:%d: actdata[%02d]: 0x%08x\\n\", __func__,\n\t\t\t\t __LINE__, start + idx, actstr[idx]);\n\t\t}\n\t\tbreak;\n\tcase VCAP_SEL_COUNTER:\n\t\tpr_debug(\"%s:%d\\n\", __func__, __LINE__);\n\t\ttest_hw_counter_id = start;\n\t\tadmin->cache.counter = test_hw_cache.counter;\n\t\tadmin->cache.sticky = test_hw_cache.sticky;\n\t\tbreak;\n\tcase VCAP_SEL_ALL:\n\t\tpr_debug(\"%s:%d\\n\", __func__, __LINE__);\n\t\tbreak;\n\t}\n}\n\n \nstatic void test_cache_write(struct net_device *ndev, struct vcap_admin *admin,\n\t\t\t     enum vcap_selection sel, u32 start, u32 count)\n{\n\tu32 *keystr, *mskstr, *actstr;\n\tint idx;\n\n\tswitch (sel) {\n\tcase VCAP_SEL_ENTRY:\n\t\tkeystr = &admin->cache.keystream[start];\n\t\tmskstr = &admin->cache.maskstream[start];\n\t\tfor (idx = 0; idx < count; ++idx) {\n\t\t\tpr_debug(\"%s:%d: keydata[%02d]: 0x%08x\\n\", __func__,\n\t\t\t\t __LINE__, start + idx, keystr[idx]);\n\t\t}\n\t\tfor (idx = 0; idx < count; ++idx) {\n\t\t\t \n\t\t\tmskstr[idx] = ~mskstr[idx];\n\t\t\tpr_debug(\"%s:%d: mskdata[%02d]: 0x%08x\\n\", __func__,\n\t\t\t\t __LINE__, start + idx, mskstr[idx]);\n\t\t}\n\t\tbreak;\n\tcase VCAP_SEL_ACTION:\n\t\tactstr = &admin->cache.actionstream[start];\n\t\tfor (idx = 0; idx < count; ++idx) {\n\t\t\tpr_debug(\"%s:%d: actdata[%02d]: 0x%08x\\n\", __func__,\n\t\t\t\t __LINE__, start + idx, actstr[idx]);\n\t\t}\n\t\tbreak;\n\tcase VCAP_SEL_COUNTER:\n\t\tpr_debug(\"%s:%d\\n\", __func__, __LINE__);\n\t\ttest_hw_counter_id = start;\n\t\ttest_hw_cache.counter = admin->cache.counter;\n\t\ttest_hw_cache.sticky = admin->cache.sticky;\n\t\tbreak;\n\tcase VCAP_SEL_ALL:\n\t\tpr_err(\"%s:%d: cannot write all streams at once\\n\",\n\t\t       __func__, __LINE__);\n\t\tbreak;\n\t}\n}\n\n \nstatic void test_cache_update(struct net_device *ndev, struct vcap_admin *admin,\n\t\t\t      enum vcap_command cmd,\n\t\t\t      enum vcap_selection sel, u32 addr)\n{\n\tif (test_updateaddridx < ARRAY_SIZE(test_updateaddr))\n\t\ttest_updateaddr[test_updateaddridx] = addr;\n\telse\n\t\tpr_err(\"%s:%d: overflow: %d\\n\", __func__, __LINE__,\n\t\t       test_updateaddridx);\n\ttest_updateaddridx++;\n}\n\nstatic void test_cache_move(struct net_device *ndev, struct vcap_admin *admin,\n\t\t\t    u32 addr, int offset, int count)\n{\n\ttest_move_addr = addr;\n\ttest_move_offset = offset;\n\ttest_move_count = count;\n}\n\n \nstatic int vcap_test_port_info(struct net_device *ndev,\n\t\t\t       struct vcap_admin *admin,\n\t\t\t       struct vcap_output_print *out)\n{\n\treturn 0;\n}\n\nstatic struct vcap_operations test_callbacks = {\n\t.validate_keyset = test_val_keyset,\n\t.add_default_fields = test_add_def_fields,\n\t.cache_erase = test_cache_erase,\n\t.cache_write = test_cache_write,\n\t.cache_read = test_cache_read,\n\t.init = test_cache_init,\n\t.update = test_cache_update,\n\t.move = test_cache_move,\n\t.port_info = vcap_test_port_info,\n};\n\nstatic struct vcap_control test_vctrl = {\n\t.vcaps = kunit_test_vcaps,\n\t.stats = &kunit_test_vcap_stats,\n\t.ops = &test_callbacks,\n};\n\nstatic void vcap_test_api_init(struct vcap_admin *admin)\n{\n\t \n\tINIT_LIST_HEAD(&test_vctrl.list);\n\tINIT_LIST_HEAD(&admin->list);\n\tINIT_LIST_HEAD(&admin->rules);\n\tINIT_LIST_HEAD(&admin->enabled);\n\tmutex_init(&admin->lock);\n\tlist_add_tail(&admin->list, &test_vctrl.list);\n\tmemset(test_updateaddr, 0, sizeof(test_updateaddr));\n\ttest_updateaddridx = 0;\n\ttest_pr_bufferidx = 0;\n\ttest_pr_idx = 0;\n}\n\n \nstatic __printf(2, 3)\nint test_prf(void *out, const char *fmt, ...)\n{\n\tstatic char test_buffer[TEST_BUF_SZ];\n\tva_list args;\n\tint idx, cnt;\n\n\tif (test_pr_bufferidx >= TEST_BUF_CNT) {\n\t\tpr_err(\"%s:%d: overflow: %d\\n\", __func__, __LINE__,\n\t\t       test_pr_bufferidx);\n\t\treturn 0;\n\t}\n\n\tva_start(args, fmt);\n\tcnt = vscnprintf(test_buffer, TEST_BUF_SZ, fmt, args);\n\tva_end(args);\n\n\tfor (idx = 0; idx < cnt; ++idx) {\n\t\ttest_pr_buffer[test_pr_bufferidx][test_pr_idx] =\n\t\t\ttest_buffer[idx];\n\t\tif (test_buffer[idx] == '\\n') {\n\t\t\ttest_pr_buffer[test_pr_bufferidx][++test_pr_idx] = 0;\n\t\t\ttest_pr_idx = 0;\n\t\t\ttest_pr_bufferidx++;\n\t\t} else {\n\t\t\t++test_pr_idx;\n\t\t}\n\t}\n\n\treturn cnt;\n}\n\n \n\nstatic void vcap_api_addr_keyset_test(struct kunit *test)\n{\n\tu32 keydata[12] = {\n\t\t0x40450042, 0x000feaf3, 0x00000003, 0x00050600,\n\t\t0x10203040, 0x00075880, 0x633c6864, 0x00040003,\n\t\t0x00000020, 0x00000008, 0x00000240, 0x00000000,\n\t};\n\tu32 mskdata[12] = {\n\t\t0x0030ff80, 0xfff00000, 0xfffffffc, 0xfff000ff,\n\t\t0x00000000, 0xfff00000, 0x00000000, 0xfff3fffc,\n\t\t0xffffffc0, 0xffffffff, 0xfffffc03, 0xffffffff,\n\t};\n\tu32 actdata[12] = {};\n\tstruct vcap_admin admin = {\n\t\t.vtype = VCAP_TYPE_IS2,\n\t\t.cache = {\n\t\t\t.keystream = keydata,\n\t\t\t.maskstream = mskdata,\n\t\t\t.actionstream = actdata,\n\t\t},\n\t};\n\tenum vcap_keyfield_set keysets[10];\n\tstruct vcap_keyset_list matches;\n\tint ret, idx, addr;\n\n\tvcap_test_api_init(&admin);\n\n\t \n\tmatches.keysets = keysets;\n\tmatches.cnt = 0;\n\tmatches.max = ARRAY_SIZE(keysets);\n\tfor (idx = ARRAY_SIZE(keydata) - 1, addr = 799; idx > 0;\n\t     --idx, --addr) {\n\t\tadmin.cache.keystream = &keydata[idx];\n\t\tadmin.cache.maskstream = &mskdata[idx];\n\t\tret = vcap_addr_keysets(&test_vctrl, &test_netdev, &admin,\n\t\t\t\t\taddr, &matches);\n\t\tKUNIT_EXPECT_EQ(test, -EINVAL, ret);\n\t}\n\n\t \n\tadmin.cache.keystream = &keydata[idx];\n\tadmin.cache.maskstream = &mskdata[idx];\n\tmatches.cnt = 0;\n\tret = vcap_addr_keysets(&test_vctrl, &test_netdev, &admin,\n\t\t\t\taddr, &matches);\n\tKUNIT_EXPECT_EQ(test, 0, ret);\n\tKUNIT_EXPECT_EQ(test, matches.cnt, 1);\n\tKUNIT_EXPECT_EQ(test, matches.keysets[0], VCAP_KFS_MAC_ETYPE);\n}\n\nstatic void vcap_api_show_admin_raw_test(struct kunit *test)\n{\n\tu32 keydata[4] = {\n\t\t0x40450042, 0x000feaf3, 0x00000003, 0x00050600,\n\t};\n\tu32 mskdata[4] = {\n\t\t0x0030ff80, 0xfff00000, 0xfffffffc, 0xfff000ff,\n\t};\n\tu32 actdata[12] = {};\n\tstruct vcap_admin admin = {\n\t\t.vtype = VCAP_TYPE_IS2,\n\t\t.cache = {\n\t\t\t.keystream = keydata,\n\t\t\t.maskstream = mskdata,\n\t\t\t.actionstream = actdata,\n\t\t},\n\t\t.first_valid_addr = 786,\n\t\t.last_valid_addr = 788,\n\t};\n\tstruct vcap_rule_internal ri = {\n\t\t.ndev = &test_netdev,\n\t};\n\tstruct vcap_output_print out = {\n\t\t.prf = (void *)test_prf,\n\t};\n\tconst char *test_expected =\n\t\t\"  addr: 786, X6 rule, keysets: VCAP_KFS_MAC_ETYPE\\n\";\n\tint ret;\n\n\tvcap_test_api_init(&admin);\n\tlist_add_tail(&ri.list, &admin.rules);\n\n\tret = vcap_show_admin_raw(&test_vctrl, &admin, &out);\n\tKUNIT_EXPECT_EQ(test, 0, ret);\n\tKUNIT_EXPECT_STREQ(test, test_expected, test_pr_buffer[0]);\n}\n\nstatic const char * const test_admin_info_expect[] = {\n\t\"name: is2\\n\",\n\t\"rows: 256\\n\",\n\t\"sw_count: 12\\n\",\n\t\"sw_width: 52\\n\",\n\t\"sticky_width: 1\\n\",\n\t\"act_width: 110\\n\",\n\t\"default_cnt: 73\\n\",\n\t\"require_cnt_dis: 0\\n\",\n\t\"version: 1\\n\",\n\t\"vtype: 4\\n\",\n\t\"vinst: 0\\n\",\n\t\"ingress: 1\\n\",\n\t\"first_cid: 10000\\n\",\n\t\"last_cid: 19999\\n\",\n\t\"lookups: 4\\n\",\n\t\"first_valid_addr: 0\\n\",\n\t\"last_valid_addr: 3071\\n\",\n\t\"last_used_addr: 794\\n\",\n};\n\nstatic void vcap_api_show_admin_test(struct kunit *test)\n{\n\tstruct vcap_admin admin = {\n\t\t.vtype = VCAP_TYPE_IS2,\n\t\t.first_cid = 10000,\n\t\t.last_cid = 19999,\n\t\t.lookups = 4,\n\t\t.last_valid_addr = 3071,\n\t\t.first_valid_addr = 0,\n\t\t.last_used_addr = 794,\n\t\t.ingress = true,\n\t};\n\tstruct vcap_output_print out = {\n\t\t.prf = (void *)test_prf,\n\t};\n\tint idx;\n\n\tvcap_test_api_init(&admin);\n\n\tvcap_show_admin_info(&test_vctrl, &admin, &out);\n\tfor (idx = 0; idx < test_pr_bufferidx; ++idx) {\n\t\t \n\t\tKUNIT_EXPECT_STREQ(test, test_admin_info_expect[idx],\n\t\t\t\t   test_pr_buffer[idx]);\n\t}\n}\n\nstatic const char * const test_admin_expect[] = {\n\t\"name: is2\\n\",\n\t\"rows: 256\\n\",\n\t\"sw_count: 12\\n\",\n\t\"sw_width: 52\\n\",\n\t\"sticky_width: 1\\n\",\n\t\"act_width: 110\\n\",\n\t\"default_cnt: 73\\n\",\n\t\"require_cnt_dis: 0\\n\",\n\t\"version: 1\\n\",\n\t\"vtype: 4\\n\",\n\t\"vinst: 0\\n\",\n\t\"ingress: 1\\n\",\n\t\"first_cid: 8000000\\n\",\n\t\"last_cid: 8199999\\n\",\n\t\"lookups: 4\\n\",\n\t\"first_valid_addr: 0\\n\",\n\t\"last_valid_addr: 3071\\n\",\n\t\"last_used_addr: 794\\n\",\n\t\"\\n\",\n\t\"rule: 100, addr: [794,799], X6, ctr[0]: 0, hit: 0\\n\",\n\t\"  chain_id: 0\\n\",\n\t\"  user: 0\\n\",\n\t\"  priority: 0\\n\",\n\t\"  state: permanent\\n\",\n\t\"  keysets: VCAP_KFS_MAC_ETYPE\\n\",\n\t\"  keyset_sw: 6\\n\",\n\t\"  keyset_sw_regs: 2\\n\",\n\t\"    ETYPE_LEN_IS: W1: 1/1\\n\",\n\t\"    IF_IGR_PORT_MASK: W32: 0xffabcd01/0xffffffff\\n\",\n\t\"    IF_IGR_PORT_MASK_RNG: W4: 5/15\\n\",\n\t\"    L2_DMAC: W48: 01:02:03:04:05:06/ff:ff:ff:ff:ff:ff\\n\",\n\t\"    L2_PAYLOAD_ETYPE: W64: 0x9000002000000081/0xff000000000000ff\\n\",\n\t\"    L2_SMAC: W48: b1:9e:34:32:75:88/ff:ff:ff:ff:ff:ff\\n\",\n\t\"    LOOKUP_FIRST_IS: W1: 1/1\\n\",\n\t\"    TYPE: W4: 0/15\\n\",\n\t\"  actionset: VCAP_AFS_BASE_TYPE\\n\",\n\t\"  actionset_sw: 3\\n\",\n\t\"  actionset_sw_regs: 4\\n\",\n\t\"    CNT_ID: W12: 100\\n\",\n\t\"    MATCH_ID: W16: 1\\n\",\n\t\"    MATCH_ID_MASK: W16: 1\\n\",\n\t\"    POLICE_ENA: W1: 1\\n\",\n\t\"    PORT_MASK: W68: 0x0514670115f3324589\\n\",\n};\n\nstatic void vcap_api_show_admin_rule_test(struct kunit *test)\n{\n\tu32 keydata[] = {\n\t\t0x40450042, 0x000feaf3, 0x00000003, 0x00050600,\n\t\t0x10203040, 0x00075880, 0x633c6864, 0x00040003,\n\t\t0x00000020, 0x00000008, 0x00000240, 0x00000000,\n\t};\n\tu32 mskdata[] = {\n\t\t0x0030ff80, 0xfff00000, 0xfffffffc, 0xfff000ff,\n\t\t0x00000000, 0xfff00000, 0x00000000, 0xfff3fffc,\n\t\t0xffffffc0, 0xffffffff, 0xfffffc03, 0xffffffff,\n\t};\n\tu32 actdata[] = {\n\t\t0x00040002, 0xf3324589, 0x14670115, 0x00000005,\n\t\t0x00000000, 0x00100000, 0x06400010, 0x00000000,\n\t\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t};\n\tstruct vcap_admin admin = {\n\t\t.vtype = VCAP_TYPE_IS2,\n\t\t.first_cid = 8000000,\n\t\t.last_cid = 8199999,\n\t\t.lookups = 4,\n\t\t.last_valid_addr = 3071,\n\t\t.first_valid_addr = 0,\n\t\t.last_used_addr = 794,\n\t\t.ingress = true,\n\t\t.cache = {\n\t\t\t.keystream = keydata,\n\t\t\t.maskstream = mskdata,\n\t\t\t.actionstream = actdata,\n\t\t},\n\t};\n\tstruct vcap_rule_internal ri = {\n\t\t.admin = &admin,\n\t\t.data = {\n\t\t\t.id = 100,\n\t\t\t.keyset = VCAP_KFS_MAC_ETYPE,\n\t\t\t.actionset = VCAP_AFS_BASE_TYPE,\n\t\t},\n\t\t.size = 6,\n\t\t.keyset_sw = 6,\n\t\t.keyset_sw_regs = 2,\n\t\t.actionset_sw = 3,\n\t\t.actionset_sw_regs = 4,\n\t\t.addr = 794,\n\t\t.vctrl = &test_vctrl,\n\t};\n\tstruct vcap_output_print out = {\n\t\t.prf = (void *)test_prf,\n\t};\n\tint ret, idx;\n\n\tvcap_test_api_init(&admin);\n\tlist_add_tail(&ri.list, &admin.rules);\n\n\tret = vcap_show_admin(&test_vctrl, &admin, &out);\n\tKUNIT_EXPECT_EQ(test, 0, ret);\n\tfor (idx = 0; idx < test_pr_bufferidx; ++idx) {\n\t\t \n\t\tKUNIT_EXPECT_STREQ(test, test_admin_expect[idx],\n\t\t\t\t   test_pr_buffer[idx]);\n\t}\n}\n\nstatic struct kunit_case vcap_api_debugfs_test_cases[] = {\n\tKUNIT_CASE(vcap_api_addr_keyset_test),\n\tKUNIT_CASE(vcap_api_show_admin_raw_test),\n\tKUNIT_CASE(vcap_api_show_admin_test),\n\tKUNIT_CASE(vcap_api_show_admin_rule_test),\n\t{}\n};\n\nstatic struct kunit_suite vcap_api_debugfs_test_suite = {\n\t.name = \"VCAP_API_DebugFS_Testsuite\",\n\t.test_cases = vcap_api_debugfs_test_cases,\n};\n\nkunit_test_suite(vcap_api_debugfs_test_suite);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}