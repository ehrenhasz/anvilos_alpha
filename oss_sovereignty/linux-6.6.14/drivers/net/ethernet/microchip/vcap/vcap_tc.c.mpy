{
  "module_name": "vcap_tc.c",
  "hash_id": "d369afb03b7a2236b8728786169884665cbbc92437e4b0dcf1e1afd185c32052",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/microchip/vcap/vcap_tc.c",
  "human_readable_source": "\n \n\n#include <net/flow_offload.h>\n#include <net/ipv6.h>\n#include <net/tcp.h>\n\n#include \"vcap_api_client.h\"\n#include \"vcap_tc.h\"\n\nenum vcap_is2_arp_opcode {\n\tVCAP_IS2_ARP_REQUEST,\n\tVCAP_IS2_ARP_REPLY,\n\tVCAP_IS2_RARP_REQUEST,\n\tVCAP_IS2_RARP_REPLY,\n};\n\nenum vcap_arp_opcode {\n\tVCAP_ARP_OP_RESERVED,\n\tVCAP_ARP_OP_REQUEST,\n\tVCAP_ARP_OP_REPLY,\n};\n\nint vcap_tc_flower_handler_ethaddr_usage(struct vcap_tc_flower_parse_usage *st)\n{\n\tenum vcap_key_field smac_key = VCAP_KF_L2_SMAC;\n\tenum vcap_key_field dmac_key = VCAP_KF_L2_DMAC;\n\tstruct flow_match_eth_addrs match;\n\tstruct vcap_u48_key smac, dmac;\n\tint err = 0;\n\n\tflow_rule_match_eth_addrs(st->frule, &match);\n\n\tif (!is_zero_ether_addr(match.mask->src)) {\n\t\tvcap_netbytes_copy(smac.value, match.key->src, ETH_ALEN);\n\t\tvcap_netbytes_copy(smac.mask, match.mask->src, ETH_ALEN);\n\t\terr = vcap_rule_add_key_u48(st->vrule, smac_key, &smac);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tif (!is_zero_ether_addr(match.mask->dst)) {\n\t\tvcap_netbytes_copy(dmac.value, match.key->dst, ETH_ALEN);\n\t\tvcap_netbytes_copy(dmac.mask, match.mask->dst, ETH_ALEN);\n\t\terr = vcap_rule_add_key_u48(st->vrule, dmac_key, &dmac);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tst->used_keys |= BIT_ULL(FLOW_DISSECTOR_KEY_ETH_ADDRS);\n\n\treturn err;\n\nout:\n\tNL_SET_ERR_MSG_MOD(st->fco->common.extack, \"eth_addr parse error\");\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(vcap_tc_flower_handler_ethaddr_usage);\n\nint vcap_tc_flower_handler_ipv4_usage(struct vcap_tc_flower_parse_usage *st)\n{\n\tint err = 0;\n\n\tif (st->l3_proto == ETH_P_IP) {\n\t\tstruct flow_match_ipv4_addrs mt;\n\n\t\tflow_rule_match_ipv4_addrs(st->frule, &mt);\n\t\tif (mt.mask->src) {\n\t\t\terr = vcap_rule_add_key_u32(st->vrule,\n\t\t\t\t\t\t    VCAP_KF_L3_IP4_SIP,\n\t\t\t\t\t\t    be32_to_cpu(mt.key->src),\n\t\t\t\t\t\t    be32_to_cpu(mt.mask->src));\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n\t\tif (mt.mask->dst) {\n\t\t\terr = vcap_rule_add_key_u32(st->vrule,\n\t\t\t\t\t\t    VCAP_KF_L3_IP4_DIP,\n\t\t\t\t\t\t    be32_to_cpu(mt.key->dst),\n\t\t\t\t\t\t    be32_to_cpu(mt.mask->dst));\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\n\tst->used_keys |= BIT_ULL(FLOW_DISSECTOR_KEY_IPV4_ADDRS);\n\n\treturn err;\n\nout:\n\tNL_SET_ERR_MSG_MOD(st->fco->common.extack, \"ipv4_addr parse error\");\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(vcap_tc_flower_handler_ipv4_usage);\n\nint vcap_tc_flower_handler_ipv6_usage(struct vcap_tc_flower_parse_usage *st)\n{\n\tint err = 0;\n\n\tif (st->l3_proto == ETH_P_IPV6) {\n\t\tstruct flow_match_ipv6_addrs mt;\n\t\tstruct vcap_u128_key sip;\n\t\tstruct vcap_u128_key dip;\n\n\t\tflow_rule_match_ipv6_addrs(st->frule, &mt);\n\t\t \n\t\tif (!ipv6_addr_any(&mt.mask->src)) {\n\t\t\tvcap_netbytes_copy(sip.value, mt.key->src.s6_addr, 16);\n\t\t\tvcap_netbytes_copy(sip.mask, mt.mask->src.s6_addr, 16);\n\t\t\terr = vcap_rule_add_key_u128(st->vrule,\n\t\t\t\t\t\t     VCAP_KF_L3_IP6_SIP, &sip);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n\t\tif (!ipv6_addr_any(&mt.mask->dst)) {\n\t\t\tvcap_netbytes_copy(dip.value, mt.key->dst.s6_addr, 16);\n\t\t\tvcap_netbytes_copy(dip.mask, mt.mask->dst.s6_addr, 16);\n\t\t\terr = vcap_rule_add_key_u128(st->vrule,\n\t\t\t\t\t\t     VCAP_KF_L3_IP6_DIP, &dip);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\tst->used_keys |= BIT_ULL(FLOW_DISSECTOR_KEY_IPV6_ADDRS);\n\treturn err;\nout:\n\tNL_SET_ERR_MSG_MOD(st->fco->common.extack, \"ipv6_addr parse error\");\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(vcap_tc_flower_handler_ipv6_usage);\n\nint vcap_tc_flower_handler_portnum_usage(struct vcap_tc_flower_parse_usage *st)\n{\n\tstruct flow_match_ports mt;\n\tu16 value, mask;\n\tint err = 0;\n\n\tflow_rule_match_ports(st->frule, &mt);\n\n\tif (mt.mask->src) {\n\t\tvalue = be16_to_cpu(mt.key->src);\n\t\tmask = be16_to_cpu(mt.mask->src);\n\t\terr = vcap_rule_add_key_u32(st->vrule, VCAP_KF_L4_SPORT, value,\n\t\t\t\t\t    mask);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tif (mt.mask->dst) {\n\t\tvalue = be16_to_cpu(mt.key->dst);\n\t\tmask = be16_to_cpu(mt.mask->dst);\n\t\terr = vcap_rule_add_key_u32(st->vrule, VCAP_KF_L4_DPORT, value,\n\t\t\t\t\t    mask);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tst->used_keys |= BIT_ULL(FLOW_DISSECTOR_KEY_PORTS);\n\n\treturn err;\n\nout:\n\tNL_SET_ERR_MSG_MOD(st->fco->common.extack, \"port parse error\");\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(vcap_tc_flower_handler_portnum_usage);\n\nint vcap_tc_flower_handler_cvlan_usage(struct vcap_tc_flower_parse_usage *st)\n{\n\tenum vcap_key_field vid_key = VCAP_KF_8021Q_VID0;\n\tenum vcap_key_field pcp_key = VCAP_KF_8021Q_PCP0;\n\tstruct flow_match_vlan mt;\n\tu16 tpid;\n\tint err;\n\n\tflow_rule_match_cvlan(st->frule, &mt);\n\n\ttpid = be16_to_cpu(mt.key->vlan_tpid);\n\n\tif (tpid == ETH_P_8021Q) {\n\t\tvid_key = VCAP_KF_8021Q_VID1;\n\t\tpcp_key = VCAP_KF_8021Q_PCP1;\n\t}\n\n\tif (mt.mask->vlan_id) {\n\t\terr = vcap_rule_add_key_u32(st->vrule, vid_key,\n\t\t\t\t\t    mt.key->vlan_id,\n\t\t\t\t\t    mt.mask->vlan_id);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tif (mt.mask->vlan_priority) {\n\t\terr = vcap_rule_add_key_u32(st->vrule, pcp_key,\n\t\t\t\t\t    mt.key->vlan_priority,\n\t\t\t\t\t    mt.mask->vlan_priority);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tst->used_keys |= BIT_ULL(FLOW_DISSECTOR_KEY_CVLAN);\n\n\treturn 0;\nout:\n\tNL_SET_ERR_MSG_MOD(st->fco->common.extack, \"cvlan parse error\");\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(vcap_tc_flower_handler_cvlan_usage);\n\nint vcap_tc_flower_handler_vlan_usage(struct vcap_tc_flower_parse_usage *st,\n\t\t\t\t      enum vcap_key_field vid_key,\n\t\t\t\t      enum vcap_key_field pcp_key)\n{\n\tstruct flow_match_vlan mt;\n\tint err;\n\n\tflow_rule_match_vlan(st->frule, &mt);\n\n\tif (mt.mask->vlan_id) {\n\t\terr = vcap_rule_add_key_u32(st->vrule, vid_key,\n\t\t\t\t\t    mt.key->vlan_id,\n\t\t\t\t\t    mt.mask->vlan_id);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tif (mt.mask->vlan_priority) {\n\t\terr = vcap_rule_add_key_u32(st->vrule, pcp_key,\n\t\t\t\t\t    mt.key->vlan_priority,\n\t\t\t\t\t    mt.mask->vlan_priority);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tif (mt.mask->vlan_tpid)\n\t\tst->tpid = be16_to_cpu(mt.key->vlan_tpid);\n\n\tst->used_keys |= BIT_ULL(FLOW_DISSECTOR_KEY_VLAN);\n\n\treturn 0;\nout:\n\tNL_SET_ERR_MSG_MOD(st->fco->common.extack, \"vlan parse error\");\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(vcap_tc_flower_handler_vlan_usage);\n\nint vcap_tc_flower_handler_tcp_usage(struct vcap_tc_flower_parse_usage *st)\n{\n\tstruct flow_match_tcp mt;\n\tu16 tcp_flags_mask;\n\tu16 tcp_flags_key;\n\tenum vcap_bit val;\n\tint err = 0;\n\n\tflow_rule_match_tcp(st->frule, &mt);\n\ttcp_flags_key = be16_to_cpu(mt.key->flags);\n\ttcp_flags_mask = be16_to_cpu(mt.mask->flags);\n\n\tif (tcp_flags_mask & TCPHDR_FIN) {\n\t\tval = VCAP_BIT_0;\n\t\tif (tcp_flags_key & TCPHDR_FIN)\n\t\t\tval = VCAP_BIT_1;\n\t\terr = vcap_rule_add_key_bit(st->vrule, VCAP_KF_L4_FIN, val);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tif (tcp_flags_mask & TCPHDR_SYN) {\n\t\tval = VCAP_BIT_0;\n\t\tif (tcp_flags_key & TCPHDR_SYN)\n\t\t\tval = VCAP_BIT_1;\n\t\terr = vcap_rule_add_key_bit(st->vrule, VCAP_KF_L4_SYN, val);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tif (tcp_flags_mask & TCPHDR_RST) {\n\t\tval = VCAP_BIT_0;\n\t\tif (tcp_flags_key & TCPHDR_RST)\n\t\t\tval = VCAP_BIT_1;\n\t\terr = vcap_rule_add_key_bit(st->vrule, VCAP_KF_L4_RST, val);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tif (tcp_flags_mask & TCPHDR_PSH) {\n\t\tval = VCAP_BIT_0;\n\t\tif (tcp_flags_key & TCPHDR_PSH)\n\t\t\tval = VCAP_BIT_1;\n\t\terr = vcap_rule_add_key_bit(st->vrule, VCAP_KF_L4_PSH, val);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tif (tcp_flags_mask & TCPHDR_ACK) {\n\t\tval = VCAP_BIT_0;\n\t\tif (tcp_flags_key & TCPHDR_ACK)\n\t\t\tval = VCAP_BIT_1;\n\t\terr = vcap_rule_add_key_bit(st->vrule, VCAP_KF_L4_ACK, val);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tif (tcp_flags_mask & TCPHDR_URG) {\n\t\tval = VCAP_BIT_0;\n\t\tif (tcp_flags_key & TCPHDR_URG)\n\t\t\tval = VCAP_BIT_1;\n\t\terr = vcap_rule_add_key_bit(st->vrule, VCAP_KF_L4_URG, val);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tst->used_keys |= BIT_ULL(FLOW_DISSECTOR_KEY_TCP);\n\n\treturn err;\n\nout:\n\tNL_SET_ERR_MSG_MOD(st->fco->common.extack, \"tcp_flags parse error\");\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(vcap_tc_flower_handler_tcp_usage);\n\nint vcap_tc_flower_handler_arp_usage(struct vcap_tc_flower_parse_usage *st)\n{\n\tstruct flow_match_arp mt;\n\tu16 value, mask;\n\tu32 ipval, ipmsk;\n\tint err;\n\n\tflow_rule_match_arp(st->frule, &mt);\n\n\tif (mt.mask->op) {\n\t\tmask = 0x3;\n\t\tif (st->l3_proto == ETH_P_ARP) {\n\t\t\tvalue = mt.key->op == VCAP_ARP_OP_REQUEST ?\n\t\t\t\t\tVCAP_IS2_ARP_REQUEST :\n\t\t\t\t\tVCAP_IS2_ARP_REPLY;\n\t\t} else {  \n\t\t\tvalue = mt.key->op == VCAP_ARP_OP_REQUEST ?\n\t\t\t\t\tVCAP_IS2_RARP_REQUEST :\n\t\t\t\t\tVCAP_IS2_RARP_REPLY;\n\t\t}\n\t\terr = vcap_rule_add_key_u32(st->vrule, VCAP_KF_ARP_OPCODE,\n\t\t\t\t\t    value, mask);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\t \n\tif (!is_zero_ether_addr(mt.mask->sha) ||\n\t    !is_zero_ether_addr(mt.mask->tha)) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (mt.mask->sip) {\n\t\tipval = be32_to_cpu((__force __be32)mt.key->sip);\n\t\tipmsk = be32_to_cpu((__force __be32)mt.mask->sip);\n\n\t\terr = vcap_rule_add_key_u32(st->vrule, VCAP_KF_L3_IP4_SIP,\n\t\t\t\t\t    ipval, ipmsk);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tif (mt.mask->tip) {\n\t\tipval = be32_to_cpu((__force __be32)mt.key->tip);\n\t\tipmsk = be32_to_cpu((__force __be32)mt.mask->tip);\n\n\t\terr = vcap_rule_add_key_u32(st->vrule, VCAP_KF_L3_IP4_DIP,\n\t\t\t\t\t    ipval, ipmsk);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tst->used_keys |= BIT_ULL(FLOW_DISSECTOR_KEY_ARP);\n\n\treturn 0;\n\nout:\n\tNL_SET_ERR_MSG_MOD(st->fco->common.extack, \"arp parse error\");\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(vcap_tc_flower_handler_arp_usage);\n\nint vcap_tc_flower_handler_ip_usage(struct vcap_tc_flower_parse_usage *st)\n{\n\tstruct flow_match_ip mt;\n\tint err = 0;\n\n\tflow_rule_match_ip(st->frule, &mt);\n\n\tif (mt.mask->tos) {\n\t\terr = vcap_rule_add_key_u32(st->vrule, VCAP_KF_L3_TOS,\n\t\t\t\t\t    mt.key->tos,\n\t\t\t\t\t    mt.mask->tos);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tst->used_keys |= BIT_ULL(FLOW_DISSECTOR_KEY_IP);\n\n\treturn err;\n\nout:\n\tNL_SET_ERR_MSG_MOD(st->fco->common.extack, \"ip_tos parse error\");\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(vcap_tc_flower_handler_ip_usage);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}