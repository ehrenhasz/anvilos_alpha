{
  "module_name": "vcap_api_debugfs.c",
  "hash_id": "2636087ce3332699c774adea8687adf239015c5542ba31dd2feeb4c544a4b808",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/microchip/vcap/vcap_api_debugfs.c",
  "human_readable_source": "\n \n\n#include \"vcap_api_private.h\"\n#include \"vcap_api_debugfs.h\"\n\nstruct vcap_admin_debugfs_info {\n\tstruct vcap_control *vctrl;\n\tstruct vcap_admin *admin;\n};\n\nstruct vcap_port_debugfs_info {\n\tstruct vcap_control *vctrl;\n\tstruct net_device *ndev;\n};\n\n \nstatic void vcap_debugfs_show_rule_keyfield(struct vcap_control *vctrl,\n\t\t\t\t\t    struct vcap_output_print *out,\n\t\t\t\t\t    enum vcap_key_field key,\n\t\t\t\t\t    const struct vcap_field *keyfield,\n\t\t\t\t\t    struct vcap_client_keyfield_data *data)\n{\n\tbool hex = false;\n\tu8 *value, *mask;\n\tint idx, bytes;\n\n\tout->prf(out->dst, \"    %s: W%d: \", vcap_keyfield_name(vctrl, key),\n\t\t keyfield[key].width);\n\n\tswitch (keyfield[key].type) {\n\tcase VCAP_FIELD_BIT:\n\t\tout->prf(out->dst, \"%d/%d\", data->u1.value, data->u1.mask);\n\t\tbreak;\n\tcase VCAP_FIELD_U32:\n\t\tvalue = (u8 *)(&data->u32.value);\n\t\tmask = (u8 *)(&data->u32.mask);\n\n\t\tif (key == VCAP_KF_L3_IP4_SIP || key == VCAP_KF_L3_IP4_DIP) {\n\t\t\tout->prf(out->dst, \"%pI4h/%pI4h\", &data->u32.value,\n\t\t\t\t &data->u32.mask);\n\t\t} else if (key == VCAP_KF_ETYPE ||\n\t\t\t   key == VCAP_KF_IF_IGR_PORT_MASK ||\n\t\t\t   key == VCAP_KF_IF_EGR_PORT_MASK) {\n\t\t\thex = true;\n\t\t} else {\n\t\t\tu32 fmsk = (1 << keyfield[key].width) - 1;\n\n\t\t\tif (keyfield[key].width == 32)\n\t\t\t\tfmsk = ~0;\n\t\t\tout->prf(out->dst, \"%u/%u\", data->u32.value & fmsk,\n\t\t\t\t data->u32.mask & fmsk);\n\t\t}\n\t\tbreak;\n\tcase VCAP_FIELD_U48:\n\t\tvalue = data->u48.value;\n\t\tmask = data->u48.mask;\n\t\tif (key == VCAP_KF_L2_SMAC || key == VCAP_KF_L2_DMAC)\n\t\t\tout->prf(out->dst, \"%pMR/%pMR\", data->u48.value,\n\t\t\t\t data->u48.mask);\n\t\telse\n\t\t\thex = true;\n\t\tbreak;\n\tcase VCAP_FIELD_U56:\n\t\tvalue = data->u56.value;\n\t\tmask = data->u56.mask;\n\t\thex = true;\n\t\tbreak;\n\tcase VCAP_FIELD_U64:\n\t\tvalue = data->u64.value;\n\t\tmask = data->u64.mask;\n\t\thex = true;\n\t\tbreak;\n\tcase VCAP_FIELD_U72:\n\t\tvalue = data->u72.value;\n\t\tmask = data->u72.mask;\n\t\thex = true;\n\t\tbreak;\n\tcase VCAP_FIELD_U112:\n\t\tvalue = data->u112.value;\n\t\tmask = data->u112.mask;\n\t\thex = true;\n\t\tbreak;\n\tcase VCAP_FIELD_U128:\n\t\tvalue = data->u128.value;\n\t\tmask = data->u128.mask;\n\t\tif (key == VCAP_KF_L3_IP6_SIP || key == VCAP_KF_L3_IP6_DIP) {\n\t\t\tu8 nvalue[16], nmask[16];\n\n\t\t\tvcap_netbytes_copy(nvalue, data->u128.value,\n\t\t\t\t\t   sizeof(nvalue));\n\t\t\tvcap_netbytes_copy(nmask, data->u128.mask,\n\t\t\t\t\t   sizeof(nmask));\n\t\t\tout->prf(out->dst, \"%pI6/%pI6\", nvalue, nmask);\n\t\t} else {\n\t\t\thex = true;\n\t\t}\n\t\tbreak;\n\t}\n\tif (hex) {\n\t\tbytes = DIV_ROUND_UP(keyfield[key].width, BITS_PER_BYTE);\n\t\tout->prf(out->dst, \"0x\");\n\t\tfor (idx = 0; idx < bytes; ++idx)\n\t\t\tout->prf(out->dst, \"%02x\", value[bytes - idx - 1]);\n\t\tout->prf(out->dst, \"/0x\");\n\t\tfor (idx = 0; idx < bytes; ++idx)\n\t\t\tout->prf(out->dst, \"%02x\", mask[bytes - idx - 1]);\n\t}\n\tout->prf(out->dst, \"\\n\");\n}\n\nstatic void\nvcap_debugfs_show_rule_actionfield(struct vcap_control *vctrl,\n\t\t\t\t   struct vcap_output_print *out,\n\t\t\t\t   enum vcap_action_field action,\n\t\t\t\t   const struct vcap_field *actionfield,\n\t\t\t\t   u8 *value)\n{\n\tbool hex = false;\n\tint idx, bytes;\n\tu32 fmsk, val;\n\n\tout->prf(out->dst, \"    %s: W%d: \",\n\t\t vcap_actionfield_name(vctrl, action),\n\t\t actionfield[action].width);\n\n\tswitch (actionfield[action].type) {\n\tcase VCAP_FIELD_BIT:\n\t\tout->prf(out->dst, \"%d\", value[0]);\n\t\tbreak;\n\tcase VCAP_FIELD_U32:\n\t\tfmsk = (1 << actionfield[action].width) - 1;\n\t\tval = *(u32 *)value;\n\t\tout->prf(out->dst, \"%u\", val & fmsk);\n\t\tbreak;\n\tcase VCAP_FIELD_U48:\n\tcase VCAP_FIELD_U56:\n\tcase VCAP_FIELD_U64:\n\tcase VCAP_FIELD_U72:\n\tcase VCAP_FIELD_U112:\n\tcase VCAP_FIELD_U128:\n\t\thex = true;\n\t\tbreak;\n\t}\n\tif (hex) {\n\t\tbytes = DIV_ROUND_UP(actionfield[action].width, BITS_PER_BYTE);\n\t\tout->prf(out->dst, \"0x\");\n\t\tfor (idx = 0; idx < bytes; ++idx)\n\t\t\tout->prf(out->dst, \"%02x\", value[bytes - idx - 1]);\n\t}\n\tout->prf(out->dst, \"\\n\");\n}\n\nstatic int vcap_debugfs_show_keysets(struct vcap_rule_internal *ri,\n\t\t\t\t     struct vcap_output_print *out)\n{\n\tstruct vcap_admin *admin = ri->admin;\n\tenum vcap_keyfield_set keysets[10];\n\tstruct vcap_keyset_list matches;\n\tint err;\n\n\tmatches.keysets = keysets;\n\tmatches.cnt = 0;\n\tmatches.max = ARRAY_SIZE(keysets);\n\n\tif (ri->state == VCAP_RS_DISABLED)\n\t\terr = vcap_rule_get_keysets(ri, &matches);\n\telse\n\t\terr = vcap_find_keystream_keysets(ri->vctrl, admin->vtype,\n\t\t\t\t\t\t  admin->cache.keystream,\n\t\t\t\t\t\t  admin->cache.maskstream,\n\t\t\t\t\t\t  false, 0, &matches);\n\tif (err) {\n\t\tpr_err(\"%s:%d: could not find valid keysets: %d\\n\",\n\t\t       __func__, __LINE__, err);\n\t\treturn err;\n\t}\n\n\tout->prf(out->dst, \"  keysets:\");\n\tfor (int idx = 0; idx < matches.cnt; ++idx)\n\t\tout->prf(out->dst, \" %s\",\n\t\t\t vcap_keyset_name(ri->vctrl, matches.keysets[idx]));\n\tout->prf(out->dst, \"\\n\");\n\treturn 0;\n}\n\nstatic int vcap_debugfs_show_rule_keyset(struct vcap_rule_internal *ri,\n\t\t\t\t\t struct vcap_output_print *out)\n{\n\tstruct vcap_control *vctrl = ri->vctrl;\n\tstruct vcap_admin *admin = ri->admin;\n\tconst struct vcap_field *keyfield;\n\tstruct vcap_client_keyfield *ckf;\n\n\tvcap_debugfs_show_keysets(ri, out);\n\tout->prf(out->dst, \"  keyset_sw: %d\\n\", ri->keyset_sw);\n\tout->prf(out->dst, \"  keyset_sw_regs: %d\\n\", ri->keyset_sw_regs);\n\n\tlist_for_each_entry(ckf, &ri->data.keyfields, ctrl.list) {\n\t\tkeyfield = vcap_keyfields(vctrl, admin->vtype, ri->data.keyset);\n\t\tvcap_debugfs_show_rule_keyfield(vctrl, out, ckf->ctrl.key,\n\t\t\t\t\t\tkeyfield, &ckf->data);\n\t}\n\n\treturn 0;\n}\n\nstatic int vcap_debugfs_show_rule_actionset(struct vcap_rule_internal *ri,\n\t\t\t\t\t    struct vcap_output_print *out)\n{\n\tstruct vcap_control *vctrl = ri->vctrl;\n\tstruct vcap_admin *admin = ri->admin;\n\tconst struct vcap_field *actionfield;\n\tstruct vcap_client_actionfield *caf;\n\n\tout->prf(out->dst, \"  actionset: %s\\n\",\n\t\t vcap_actionset_name(vctrl, ri->data.actionset));\n\tout->prf(out->dst, \"  actionset_sw: %d\\n\", ri->actionset_sw);\n\tout->prf(out->dst, \"  actionset_sw_regs: %d\\n\", ri->actionset_sw_regs);\n\n\tlist_for_each_entry(caf, &ri->data.actionfields, ctrl.list) {\n\t\tactionfield = vcap_actionfields(vctrl, admin->vtype,\n\t\t\t\t\t\tri->data.actionset);\n\t\tvcap_debugfs_show_rule_actionfield(vctrl, out, caf->ctrl.action,\n\t\t\t\t\t\t   actionfield,\n\t\t\t\t\t\t   &caf->data.u1.value);\n\t}\n\n\treturn 0;\n}\n\nstatic void vcap_show_admin_rule(struct vcap_control *vctrl,\n\t\t\t\t struct vcap_admin *admin,\n\t\t\t\t struct vcap_output_print *out,\n\t\t\t\t struct vcap_rule_internal *ri)\n{\n\tri->counter.value = admin->cache.counter;\n\tri->counter.sticky = admin->cache.sticky;\n\tout->prf(out->dst,\n\t\t \"rule: %u, addr: [%d,%d], X%d, ctr[%d]: %d, hit: %d\\n\",\n\t\t ri->data.id, ri->addr, ri->addr + ri->size - 1, ri->size,\n\t\t ri->counter_id, ri->counter.value, ri->counter.sticky);\n\tout->prf(out->dst, \"  chain_id: %d\\n\", ri->data.vcap_chain_id);\n\tout->prf(out->dst, \"  user: %d\\n\", ri->data.user);\n\tout->prf(out->dst, \"  priority: %d\\n\", ri->data.priority);\n\tout->prf(out->dst, \"  state: \");\n\tswitch (ri->state) {\n\tcase VCAP_RS_PERMANENT:\n\t\tout->prf(out->dst, \"permanent\\n\");\n\t\tbreak;\n\tcase VCAP_RS_DISABLED:\n\t\tout->prf(out->dst, \"disabled\\n\");\n\t\tbreak;\n\tcase VCAP_RS_ENABLED:\n\t\tout->prf(out->dst, \"enabled\\n\");\n\t\tbreak;\n\t}\n\tvcap_debugfs_show_rule_keyset(ri, out);\n\tvcap_debugfs_show_rule_actionset(ri, out);\n}\n\nstatic void vcap_show_admin_info(struct vcap_control *vctrl,\n\t\t\t\t struct vcap_admin *admin,\n\t\t\t\t struct vcap_output_print *out)\n{\n\tconst struct vcap_info *vcap = &vctrl->vcaps[admin->vtype];\n\n\tout->prf(out->dst, \"name: %s\\n\", vcap->name);\n\tout->prf(out->dst, \"rows: %d\\n\", vcap->rows);\n\tout->prf(out->dst, \"sw_count: %d\\n\", vcap->sw_count);\n\tout->prf(out->dst, \"sw_width: %d\\n\", vcap->sw_width);\n\tout->prf(out->dst, \"sticky_width: %d\\n\", vcap->sticky_width);\n\tout->prf(out->dst, \"act_width: %d\\n\", vcap->act_width);\n\tout->prf(out->dst, \"default_cnt: %d\\n\", vcap->default_cnt);\n\tout->prf(out->dst, \"require_cnt_dis: %d\\n\", vcap->require_cnt_dis);\n\tout->prf(out->dst, \"version: %d\\n\", vcap->version);\n\tout->prf(out->dst, \"vtype: %d\\n\", admin->vtype);\n\tout->prf(out->dst, \"vinst: %d\\n\", admin->vinst);\n\tout->prf(out->dst, \"ingress: %d\\n\", admin->ingress);\n\tout->prf(out->dst, \"first_cid: %d\\n\", admin->first_cid);\n\tout->prf(out->dst, \"last_cid: %d\\n\", admin->last_cid);\n\tout->prf(out->dst, \"lookups: %d\\n\", admin->lookups);\n\tout->prf(out->dst, \"first_valid_addr: %d\\n\", admin->first_valid_addr);\n\tout->prf(out->dst, \"last_valid_addr: %d\\n\", admin->last_valid_addr);\n\tout->prf(out->dst, \"last_used_addr: %d\\n\", admin->last_used_addr);\n}\n\nstatic int vcap_show_admin(struct vcap_control *vctrl,\n\t\t\t   struct vcap_admin *admin,\n\t\t\t   struct vcap_output_print *out)\n{\n\tstruct vcap_rule_internal *elem;\n\tstruct vcap_rule *vrule;\n\tint ret = 0;\n\n\tvcap_show_admin_info(vctrl, admin, out);\n\tlist_for_each_entry(elem, &admin->rules, list) {\n\t\tvrule = vcap_decode_rule(elem);\n\t\tif (IS_ERR_OR_NULL(vrule)) {\n\t\t\tret = PTR_ERR(vrule);\n\t\t\tbreak;\n\t\t}\n\n\t\tout->prf(out->dst, \"\\n\");\n\t\tvcap_show_admin_rule(vctrl, admin, out, to_intrule(vrule));\n\t\tvcap_free_rule(vrule);\n\t}\n\treturn ret;\n}\n\nstatic int vcap_show_admin_raw(struct vcap_control *vctrl,\n\t\t\t       struct vcap_admin *admin,\n\t\t\t       struct vcap_output_print *out)\n{\n\tenum vcap_keyfield_set keysets[10];\n\tenum vcap_type vt = admin->vtype;\n\tstruct vcap_keyset_list kslist;\n\tstruct vcap_rule_internal *ri;\n\tconst struct vcap_set *info;\n\tint addr, idx;\n\tint ret;\n\n\tif (list_empty(&admin->rules))\n\t\treturn 0;\n\n\tret = vcap_api_check(vctrl);\n\tif (ret)\n\t\treturn ret;\n\n\tri = list_first_entry(&admin->rules, struct vcap_rule_internal, list);\n\n\t \n\tkslist.keysets = keysets;\n\tkslist.max = ARRAY_SIZE(keysets);\n\tfor (addr = admin->last_valid_addr; addr >= admin->first_valid_addr;\n\t     --addr) {\n\t\tkslist.cnt = 0;\n\t\tret = vcap_addr_keysets(vctrl, ri->ndev, admin, addr, &kslist);\n\t\tif (ret < 0)\n\t\t\tcontinue;\n\t\tinfo = vcap_keyfieldset(vctrl, vt, kslist.keysets[0]);\n\t\tif (!info)\n\t\t\tcontinue;\n\t\tif (addr % info->sw_per_item) {\n\t\t\tpr_info(\"addr: %d X%d error rule, keyset: %s\\n\",\n\t\t\t\taddr,\n\t\t\t\tinfo->sw_per_item,\n\t\t\t\tvcap_keyset_name(vctrl, kslist.keysets[0]));\n\t\t} else {\n\t\t\tout->prf(out->dst, \"  addr: %d, X%d rule, keysets:\",\n\t\t\t\t addr,\n\t\t\t\t info->sw_per_item);\n\t\t\tfor (idx = 0; idx < kslist.cnt; ++idx)\n\t\t\t\tout->prf(out->dst, \" %s\",\n\t\t\t\t\t vcap_keyset_name(vctrl,\n\t\t\t\t\t\t\t  kslist.keysets[idx]));\n\t\t\tout->prf(out->dst, \"\\n\");\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nstatic int vcap_port_debugfs_show(struct seq_file *m, void *unused)\n{\n\tstruct vcap_port_debugfs_info *info = m->private;\n\tstruct vcap_admin *admin;\n\tstruct vcap_output_print out = {\n\t\t.prf = (void *)seq_printf,\n\t\t.dst = m,\n\t};\n\n\tlist_for_each_entry(admin, &info->vctrl->list, list) {\n\t\tif (admin->vinst)\n\t\t\tcontinue;\n\t\tinfo->vctrl->ops->port_info(info->ndev, admin, &out);\n\t}\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(vcap_port_debugfs);\n\nvoid vcap_port_debugfs(struct device *dev, struct dentry *parent,\n\t\t       struct vcap_control *vctrl,\n\t\t       struct net_device *ndev)\n{\n\tstruct vcap_port_debugfs_info *info;\n\n\tinfo = devm_kzalloc(dev, sizeof(*info), GFP_KERNEL);\n\tif (!info)\n\t\treturn;\n\n\tinfo->vctrl = vctrl;\n\tinfo->ndev = ndev;\n\tdebugfs_create_file(netdev_name(ndev), 0444, parent, info,\n\t\t\t    &vcap_port_debugfs_fops);\n}\nEXPORT_SYMBOL_GPL(vcap_port_debugfs);\n\n \nstatic int vcap_debugfs_show(struct seq_file *m, void *unused)\n{\n\tstruct vcap_admin_debugfs_info *info = m->private;\n\tstruct vcap_output_print out = {\n\t\t.prf = (void *)seq_printf,\n\t\t.dst = m,\n\t};\n\tint ret;\n\n\tmutex_lock(&info->admin->lock);\n\tret = vcap_show_admin(info->vctrl, info->admin, &out);\n\tmutex_unlock(&info->admin->lock);\n\treturn ret;\n}\nDEFINE_SHOW_ATTRIBUTE(vcap_debugfs);\n\n \nstatic int vcap_raw_debugfs_show(struct seq_file *m, void *unused)\n{\n\tstruct vcap_admin_debugfs_info *info = m->private;\n\tstruct vcap_output_print out = {\n\t\t.prf = (void *)seq_printf,\n\t\t.dst = m,\n\t};\n\tint ret;\n\n\tmutex_lock(&info->admin->lock);\n\tret = vcap_show_admin_raw(info->vctrl, info->admin, &out);\n\tmutex_unlock(&info->admin->lock);\n\treturn ret;\n}\nDEFINE_SHOW_ATTRIBUTE(vcap_raw_debugfs);\n\nstruct dentry *vcap_debugfs(struct device *dev, struct dentry *parent,\n\t\t\t    struct vcap_control *vctrl)\n{\n\tstruct vcap_admin_debugfs_info *info;\n\tstruct vcap_admin *admin;\n\tstruct dentry *dir;\n\tchar name[50];\n\n\tdir = debugfs_create_dir(\"vcaps\", parent);\n\tif (PTR_ERR_OR_ZERO(dir))\n\t\treturn NULL;\n\tlist_for_each_entry(admin, &vctrl->list, list) {\n\t\tsprintf(name, \"raw_%s_%d\", vctrl->vcaps[admin->vtype].name,\n\t\t\tadmin->vinst);\n\t\tinfo = devm_kzalloc(dev, sizeof(*info), GFP_KERNEL);\n\t\tif (!info)\n\t\t\treturn NULL;\n\t\tinfo->vctrl = vctrl;\n\t\tinfo->admin = admin;\n\t\tdebugfs_create_file(name, 0444, dir, info,\n\t\t\t\t    &vcap_raw_debugfs_fops);\n\t\tsprintf(name, \"%s_%d\", vctrl->vcaps[admin->vtype].name,\n\t\t\tadmin->vinst);\n\t\tdebugfs_create_file(name, 0444, dir, info, &vcap_debugfs_fops);\n\t}\n\treturn dir;\n}\nEXPORT_SYMBOL_GPL(vcap_debugfs);\n\n#ifdef CONFIG_VCAP_KUNIT_TEST\n#include \"vcap_api_debugfs_kunit.c\"\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}