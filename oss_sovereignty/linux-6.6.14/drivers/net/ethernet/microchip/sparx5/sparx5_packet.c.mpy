{
  "module_name": "sparx5_packet.c",
  "hash_id": "5133413b15d9db51f71cacec51252cbd81ea28afb171133d0dddf9976f177475",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/microchip/sparx5/sparx5_packet.c",
  "human_readable_source": "\n \n\n#include \"sparx5_main_regs.h\"\n#include \"sparx5_main.h\"\n\n#define XTR_EOF_0     ntohl((__force __be32)0x80000000u)\n#define XTR_EOF_1     ntohl((__force __be32)0x80000001u)\n#define XTR_EOF_2     ntohl((__force __be32)0x80000002u)\n#define XTR_EOF_3     ntohl((__force __be32)0x80000003u)\n#define XTR_PRUNED    ntohl((__force __be32)0x80000004u)\n#define XTR_ABORT     ntohl((__force __be32)0x80000005u)\n#define XTR_ESCAPE    ntohl((__force __be32)0x80000006u)\n#define XTR_NOT_READY ntohl((__force __be32)0x80000007u)\n\n#define XTR_VALID_BYTES(x)      (4 - ((x) & 3))\n\n#define INJ_TIMEOUT_NS 50000\n\nvoid sparx5_xtr_flush(struct sparx5 *sparx5, u8 grp)\n{\n\t \n\tspx5_wr(QS_XTR_FLUSH_FLUSH_SET(BIT(grp)), sparx5, QS_XTR_FLUSH);\n\n\t \n\tmdelay(1);\n\n\t \n\tspx5_wr(0, sparx5, QS_XTR_FLUSH);\n}\n\nvoid sparx5_ifh_parse(u32 *ifh, struct frame_info *info)\n{\n\tu8 *xtr_hdr = (u8 *)ifh;\n\n\t \n\tu32 fwd =\n\t\t((u32)xtr_hdr[27] << 24) |\n\t\t((u32)xtr_hdr[28] << 16) |\n\t\t((u32)xtr_hdr[29] <<  8) |\n\t\t((u32)xtr_hdr[30] <<  0);\n\tfwd = (fwd >> 5);\n\tinfo->src_port = FIELD_GET(GENMASK(7, 1), fwd);\n\n\tinfo->timestamp =\n\t\t((u64)xtr_hdr[2] << 24) |\n\t\t((u64)xtr_hdr[3] << 16) |\n\t\t((u64)xtr_hdr[4] <<  8) |\n\t\t((u64)xtr_hdr[5] <<  0);\n}\n\nstatic void sparx5_xtr_grp(struct sparx5 *sparx5, u8 grp, bool byte_swap)\n{\n\tbool eof_flag = false, pruned_flag = false, abort_flag = false;\n\tstruct net_device *netdev;\n\tstruct sparx5_port *port;\n\tstruct frame_info fi;\n\tint i, byte_cnt = 0;\n\tstruct sk_buff *skb;\n\tu32 ifh[IFH_LEN];\n\tu32 *rxbuf;\n\n\t \n\tfor (i = 0; i < IFH_LEN; i++)\n\t\tifh[i] = spx5_rd(sparx5, QS_XTR_RD(grp));\n\n\t \n\tsparx5_ifh_parse(ifh, &fi);\n\n\t \n\tport = fi.src_port < SPX5_PORTS ?\n\t\tsparx5->ports[fi.src_port] : NULL;\n\tif (!port || !port->ndev) {\n\t\tdev_err(sparx5->dev, \"Data on inactive port %d\\n\", fi.src_port);\n\t\tsparx5_xtr_flush(sparx5, grp);\n\t\treturn;\n\t}\n\n\t \n\tnetdev = port->ndev;\n\tskb = netdev_alloc_skb(netdev, netdev->mtu + ETH_HLEN);\n\tif (!skb) {\n\t\tsparx5_xtr_flush(sparx5, grp);\n\t\tdev_err(sparx5->dev, \"No skb allocated\\n\");\n\t\tnetdev->stats.rx_dropped++;\n\t\treturn;\n\t}\n\trxbuf = (u32 *)skb->data;\n\n\t \n\twhile (!eof_flag) {\n\t\tu32 val = spx5_rd(sparx5, QS_XTR_RD(grp));\n\t\tu32 cmp = val;\n\n\t\tif (byte_swap)\n\t\t\tcmp = ntohl((__force __be32)val);\n\n\t\tswitch (cmp) {\n\t\tcase XTR_NOT_READY:\n\t\t\tbreak;\n\t\tcase XTR_ABORT:\n\t\t\t \n\t\t\tabort_flag = true;\n\t\t\teof_flag = true;\n\t\t\tbreak;\n\t\tcase XTR_EOF_0:\n\t\tcase XTR_EOF_1:\n\t\tcase XTR_EOF_2:\n\t\tcase XTR_EOF_3:\n\t\t\t \n\t\t\tif (!byte_swap)\n\t\t\t\tval = ntohl((__force __be32)val);\n\t\t\tbyte_cnt -= (4 - XTR_VALID_BYTES(val));\n\t\t\teof_flag = true;\n\t\t\tbreak;\n\t\tcase XTR_PRUNED:\n\t\t\t \n\t\t\teof_flag = true;\n\t\t\tpruned_flag = true;\n\t\t\tfallthrough;\n\t\tcase XTR_ESCAPE:\n\t\t\t*rxbuf = spx5_rd(sparx5, QS_XTR_RD(grp));\n\t\t\tbyte_cnt += 4;\n\t\t\trxbuf++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t*rxbuf = val;\n\t\t\tbyte_cnt += 4;\n\t\t\trxbuf++;\n\t\t}\n\t}\n\n\tif (abort_flag || pruned_flag || !eof_flag) {\n\t\tnetdev_err(netdev, \"Discarded frame: abort:%d pruned:%d eof:%d\\n\",\n\t\t\t   abort_flag, pruned_flag, eof_flag);\n\t\tkfree_skb(skb);\n\t\tnetdev->stats.rx_dropped++;\n\t\treturn;\n\t}\n\n\t \n\tif (test_bit(port->portno, sparx5->bridge_mask))\n\t\tskb->offload_fwd_mark = 1;\n\n\t \n\tskb_put(skb, byte_cnt - ETH_FCS_LEN);\n\teth_skb_pad(skb);\n\tsparx5_ptp_rxtstamp(sparx5, skb, fi.timestamp);\n\tskb->protocol = eth_type_trans(skb, netdev);\n\tnetdev->stats.rx_bytes += skb->len;\n\tnetdev->stats.rx_packets++;\n\tnetif_rx(skb);\n}\n\nstatic int sparx5_inject(struct sparx5 *sparx5,\n\t\t\t u32 *ifh,\n\t\t\t struct sk_buff *skb,\n\t\t\t struct net_device *ndev)\n{\n\tint grp = INJ_QUEUE;\n\tu32 val, w, count;\n\tu8 *buf;\n\n\tval = spx5_rd(sparx5, QS_INJ_STATUS);\n\tif (!(QS_INJ_STATUS_FIFO_RDY_GET(val) & BIT(grp))) {\n\t\tpr_err_ratelimited(\"Injection: Queue not ready: 0x%lx\\n\",\n\t\t\t\t   QS_INJ_STATUS_FIFO_RDY_GET(val));\n\t\treturn -EBUSY;\n\t}\n\n\t \n\tspx5_wr(QS_INJ_CTRL_SOF_SET(1) |\n\t\tQS_INJ_CTRL_GAP_SIZE_SET(1),\n\t\tsparx5, QS_INJ_CTRL(grp));\n\n\t \n\tfor (w = 0; w < IFH_LEN; w++)\n\t\tspx5_wr(ifh[w], sparx5, QS_INJ_WR(grp));\n\n\t \n\tcount = DIV_ROUND_UP(skb->len, 4);\n\tbuf = skb->data;\n\tfor (w = 0; w < count; w++, buf += 4) {\n\t\tval = get_unaligned((const u32 *)buf);\n\t\tspx5_wr(val, sparx5, QS_INJ_WR(grp));\n\t}\n\n\t \n\twhile (w < (60 / 4)) {\n\t\tspx5_wr(0, sparx5, QS_INJ_WR(grp));\n\t\tw++;\n\t}\n\n\t \n\tspx5_wr(QS_INJ_CTRL_GAP_SIZE_SET(1) |\n\t\tQS_INJ_CTRL_VLD_BYTES_SET(skb->len < 60 ? 0 : skb->len % 4) |\n\t\tQS_INJ_CTRL_EOF_SET(1),\n\t\tsparx5, QS_INJ_CTRL(grp));\n\n\t \n\tspx5_wr(0, sparx5, QS_INJ_WR(grp));\n\tw++;\n\n\tval = spx5_rd(sparx5, QS_INJ_STATUS);\n\tif (QS_INJ_STATUS_WMARK_REACHED_GET(val) & BIT(grp)) {\n\t\tstruct sparx5_port *port = netdev_priv(ndev);\n\n\t\tpr_err_ratelimited(\"Injection: Watermark reached: 0x%lx\\n\",\n\t\t\t\t   QS_INJ_STATUS_WMARK_REACHED_GET(val));\n\t\tnetif_stop_queue(ndev);\n\t\thrtimer_start(&port->inj_timer, INJ_TIMEOUT_NS,\n\t\t\t      HRTIMER_MODE_REL);\n\t}\n\n\treturn NETDEV_TX_OK;\n}\n\nnetdev_tx_t sparx5_port_xmit_impl(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct net_device_stats *stats = &dev->stats;\n\tstruct sparx5_port *port = netdev_priv(dev);\n\tstruct sparx5 *sparx5 = port->sparx5;\n\tu32 ifh[IFH_LEN];\n\tnetdev_tx_t ret;\n\n\tmemset(ifh, 0, IFH_LEN * 4);\n\tsparx5_set_port_ifh(ifh, port->portno);\n\n\tif (sparx5->ptp && skb_shinfo(skb)->tx_flags & SKBTX_HW_TSTAMP) {\n\t\tif (sparx5_ptp_txtstamp_request(port, skb) < 0)\n\t\t\treturn NETDEV_TX_BUSY;\n\n\t\tsparx5_set_port_ifh_rew_op(ifh, SPARX5_SKB_CB(skb)->rew_op);\n\t\tsparx5_set_port_ifh_pdu_type(ifh, SPARX5_SKB_CB(skb)->pdu_type);\n\t\tsparx5_set_port_ifh_pdu_w16_offset(ifh, SPARX5_SKB_CB(skb)->pdu_w16_offset);\n\t\tsparx5_set_port_ifh_timestamp(ifh, SPARX5_SKB_CB(skb)->ts_id);\n\t}\n\n\tskb_tx_timestamp(skb);\n\tif (sparx5->fdma_irq > 0)\n\t\tret = sparx5_fdma_xmit(sparx5, ifh, skb);\n\telse\n\t\tret = sparx5_inject(sparx5, ifh, skb, dev);\n\n\tif (ret == -EBUSY)\n\t\tgoto busy;\n\tif (ret < 0)\n\t\tgoto drop;\n\n\tstats->tx_bytes += skb->len;\n\tstats->tx_packets++;\n\tsparx5->tx.packets++;\n\n\tif (skb_shinfo(skb)->tx_flags & SKBTX_HW_TSTAMP &&\n\t    SPARX5_SKB_CB(skb)->rew_op == IFH_REW_OP_TWO_STEP_PTP)\n\t\treturn NETDEV_TX_OK;\n\n\tdev_consume_skb_any(skb);\n\treturn NETDEV_TX_OK;\ndrop:\n\tstats->tx_dropped++;\n\tsparx5->tx.dropped++;\n\tdev_kfree_skb_any(skb);\n\treturn NETDEV_TX_OK;\nbusy:\n\tif (skb_shinfo(skb)->tx_flags & SKBTX_HW_TSTAMP &&\n\t    SPARX5_SKB_CB(skb)->rew_op == IFH_REW_OP_TWO_STEP_PTP)\n\t\tsparx5_ptp_txtstamp_release(port, skb);\n\treturn NETDEV_TX_BUSY;\n}\n\nstatic enum hrtimer_restart sparx5_injection_timeout(struct hrtimer *tmr)\n{\n\tstruct sparx5_port *port = container_of(tmr, struct sparx5_port,\n\t\t\t\t\t\tinj_timer);\n\tint grp = INJ_QUEUE;\n\tu32 val;\n\n\tval = spx5_rd(port->sparx5, QS_INJ_STATUS);\n\tif (QS_INJ_STATUS_WMARK_REACHED_GET(val) & BIT(grp)) {\n\t\tpr_err_ratelimited(\"Injection: Reset watermark count\\n\");\n\t\t \n\t\tspx5_rmw(DSM_DEV_TX_STOP_WM_CFG_DEV_TX_CNT_CLR_SET(1),\n\t\t\t DSM_DEV_TX_STOP_WM_CFG_DEV_TX_CNT_CLR,\n\t\t\t port->sparx5,\n\t\t\t DSM_DEV_TX_STOP_WM_CFG(port->portno));\n\t}\n\tnetif_wake_queue(port->ndev);\n\treturn HRTIMER_NORESTART;\n}\n\nint sparx5_manual_injection_mode(struct sparx5 *sparx5)\n{\n\tconst int byte_swap = 1;\n\tint portno;\n\n\t \n\tspx5_wr(QS_XTR_GRP_CFG_MODE_SET(1) |\n\t\tQS_XTR_GRP_CFG_STATUS_WORD_POS_SET(1) |\n\t\tQS_XTR_GRP_CFG_BYTE_SWAP_SET(byte_swap),\n\t\tsparx5, QS_XTR_GRP_CFG(XTR_QUEUE));\n\tspx5_wr(QS_INJ_GRP_CFG_MODE_SET(1) |\n\t\tQS_INJ_GRP_CFG_BYTE_SWAP_SET(byte_swap),\n\t\tsparx5, QS_INJ_GRP_CFG(INJ_QUEUE));\n\n\t \n\tfor (portno = SPX5_PORT_CPU_0; portno <= SPX5_PORT_CPU_1; portno++) {\n\t\t \n\t\tspx5_wr(ASM_PORT_CFG_PAD_ENA_SET(1) |\n\t\t\tASM_PORT_CFG_NO_PREAMBLE_ENA_SET(1) |\n\t\t\tASM_PORT_CFG_INJ_FORMAT_CFG_SET(1),  \n\t\t\tsparx5, ASM_PORT_CFG(portno));\n\n\t\t \n\t\tspx5_rmw(DSM_DEV_TX_STOP_WM_CFG_DEV_TX_CNT_CLR_SET(1),\n\t\t\t DSM_DEV_TX_STOP_WM_CFG_DEV_TX_CNT_CLR,\n\t\t\t sparx5,\n\t\t\t DSM_DEV_TX_STOP_WM_CFG(portno));\n\n\t\t \n\t\tspx5_rmw(DSM_DEV_TX_STOP_WM_CFG_DEV_TX_STOP_WM_SET(0),\n\t\t\t DSM_DEV_TX_STOP_WM_CFG_DEV_TX_STOP_WM,\n\t\t\t sparx5,\n\t\t\t DSM_DEV_TX_STOP_WM_CFG(portno));\n\n\t\t \n\t\tspx5_rmw(DSM_BUF_CFG_UNDERFLOW_WATCHDOG_DIS_SET(0),\n\t\t\t DSM_BUF_CFG_UNDERFLOW_WATCHDOG_DIS,\n\t\t\t sparx5,\n\t\t\t DSM_BUF_CFG(portno));\n\t}\n\treturn 0;\n}\n\nirqreturn_t sparx5_xtr_handler(int irq, void *_sparx5)\n{\n\tstruct sparx5 *s5 = _sparx5;\n\tint poll = 64;\n\n\t \n\twhile (spx5_rd(s5, QS_XTR_DATA_PRESENT) & BIT(XTR_QUEUE) && poll-- > 0)\n\t\tsparx5_xtr_grp(s5, XTR_QUEUE, false);\n\n\treturn IRQ_HANDLED;\n}\n\nvoid sparx5_port_inj_timer_setup(struct sparx5_port *port)\n{\n\thrtimer_init(&port->inj_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);\n\tport->inj_timer.function = sparx5_injection_timeout;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}