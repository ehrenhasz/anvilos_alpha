{
  "module_name": "sparx5_ptp.c",
  "hash_id": "3a16eaa8d5b035f36531ea033af1088d69a1b231a7a629d8477c83cdcb4648af",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/microchip/sparx5/sparx5_ptp.c",
  "human_readable_source": "\n \n#include <linux/ptp_classify.h>\n\n#include \"sparx5_main_regs.h\"\n#include \"sparx5_main.h\"\n\n#define SPARX5_MAX_PTP_ID\t512\n\n#define TOD_ACC_PIN\t\t0x4\n\nenum {\n\tPTP_PIN_ACTION_IDLE = 0,\n\tPTP_PIN_ACTION_LOAD,\n\tPTP_PIN_ACTION_SAVE,\n\tPTP_PIN_ACTION_CLOCK,\n\tPTP_PIN_ACTION_DELTA,\n\tPTP_PIN_ACTION_TOD\n};\n\nstatic u64 sparx5_ptp_get_1ppm(struct sparx5 *sparx5)\n{\n\t \n\n\tu64 res = 0;\n\n\tswitch (sparx5->coreclock) {\n\tcase SPX5_CORE_CLOCK_250MHZ:\n\t\tres = 2301339409586;\n\t\tbreak;\n\tcase SPX5_CORE_CLOCK_500MHZ:\n\t\tres = 1150669704793;\n\t\tbreak;\n\tcase SPX5_CORE_CLOCK_625MHZ:\n\t\tres =  920535763834;\n\t\tbreak;\n\tdefault:\n\t\tWARN(1, \"Invalid core clock\");\n\t\tbreak;\n\t}\n\n\treturn res;\n}\n\nstatic u64 sparx5_ptp_get_nominal_value(struct sparx5 *sparx5)\n{\n\tu64 res = 0;\n\n\tswitch (sparx5->coreclock) {\n\tcase SPX5_CORE_CLOCK_250MHZ:\n\t\tres = 0x1FF0000000000000;\n\t\tbreak;\n\tcase SPX5_CORE_CLOCK_500MHZ:\n\t\tres = 0x0FF8000000000000;\n\t\tbreak;\n\tcase SPX5_CORE_CLOCK_625MHZ:\n\t\tres = 0x0CC6666666666666;\n\t\tbreak;\n\tdefault:\n\t\tWARN(1, \"Invalid core clock\");\n\t\tbreak;\n\t}\n\n\treturn res;\n}\n\nint sparx5_ptp_hwtstamp_set(struct sparx5_port *port,\n\t\t\t    struct kernel_hwtstamp_config *cfg,\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct sparx5 *sparx5 = port->sparx5;\n\tstruct sparx5_phc *phc;\n\n\t \n\n\tif (test_bit(port->portno, sparx5->bridge_mask))\n\t\treturn -EINVAL;\n\n\tswitch (cfg->tx_type) {\n\tcase HWTSTAMP_TX_ON:\n\t\tport->ptp_cmd = IFH_REW_OP_TWO_STEP_PTP;\n\t\tbreak;\n\tcase HWTSTAMP_TX_ONESTEP_SYNC:\n\t\tport->ptp_cmd = IFH_REW_OP_ONE_STEP_PTP;\n\t\tbreak;\n\tcase HWTSTAMP_TX_OFF:\n\t\tport->ptp_cmd = IFH_REW_OP_NOOP;\n\t\tbreak;\n\tdefault:\n\t\treturn -ERANGE;\n\t}\n\n\tswitch (cfg->rx_filter) {\n\tcase HWTSTAMP_FILTER_NONE:\n\t\tbreak;\n\tcase HWTSTAMP_FILTER_ALL:\n\tcase HWTSTAMP_FILTER_PTP_V1_L4_EVENT:\n\tcase HWTSTAMP_FILTER_PTP_V1_L4_SYNC:\n\tcase HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ:\n\tcase HWTSTAMP_FILTER_PTP_V2_L4_EVENT:\n\tcase HWTSTAMP_FILTER_PTP_V2_L4_SYNC:\n\tcase HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ:\n\tcase HWTSTAMP_FILTER_PTP_V2_L2_EVENT:\n\tcase HWTSTAMP_FILTER_PTP_V2_L2_SYNC:\n\tcase HWTSTAMP_FILTER_PTP_V2_L2_DELAY_REQ:\n\tcase HWTSTAMP_FILTER_PTP_V2_EVENT:\n\tcase HWTSTAMP_FILTER_PTP_V2_SYNC:\n\tcase HWTSTAMP_FILTER_PTP_V2_DELAY_REQ:\n\tcase HWTSTAMP_FILTER_NTP_ALL:\n\t\tcfg->rx_filter = HWTSTAMP_FILTER_ALL;\n\t\tbreak;\n\tdefault:\n\t\treturn -ERANGE;\n\t}\n\n\t \n\tmutex_lock(&sparx5->ptp_lock);\n\tphc = &sparx5->phc[SPARX5_PHC_PORT];\n\tphc->hwtstamp_config = *cfg;\n\tmutex_unlock(&sparx5->ptp_lock);\n\n\treturn 0;\n}\n\nvoid sparx5_ptp_hwtstamp_get(struct sparx5_port *port,\n\t\t\t     struct kernel_hwtstamp_config *cfg)\n{\n\tstruct sparx5 *sparx5 = port->sparx5;\n\tstruct sparx5_phc *phc;\n\n\tphc = &sparx5->phc[SPARX5_PHC_PORT];\n\t*cfg = phc->hwtstamp_config;\n}\n\nstatic void sparx5_ptp_classify(struct sparx5_port *port, struct sk_buff *skb,\n\t\t\t\tu8 *rew_op, u8 *pdu_type, u8 *pdu_w16_offset)\n{\n\tstruct ptp_header *header;\n\tu8 msgtype;\n\tint type;\n\n\tif (port->ptp_cmd == IFH_REW_OP_NOOP) {\n\t\t*rew_op = IFH_REW_OP_NOOP;\n\t\t*pdu_type = IFH_PDU_TYPE_NONE;\n\t\t*pdu_w16_offset = 0;\n\t\treturn;\n\t}\n\n\ttype = ptp_classify_raw(skb);\n\tif (type == PTP_CLASS_NONE) {\n\t\t*rew_op = IFH_REW_OP_NOOP;\n\t\t*pdu_type = IFH_PDU_TYPE_NONE;\n\t\t*pdu_w16_offset = 0;\n\t\treturn;\n\t}\n\n\theader = ptp_parse_header(skb, type);\n\tif (!header) {\n\t\t*rew_op = IFH_REW_OP_NOOP;\n\t\t*pdu_type = IFH_PDU_TYPE_NONE;\n\t\t*pdu_w16_offset = 0;\n\t\treturn;\n\t}\n\n\t*pdu_w16_offset = 7;\n\tif (type & PTP_CLASS_L2)\n\t\t*pdu_type = IFH_PDU_TYPE_PTP;\n\tif (type & PTP_CLASS_IPV4)\n\t\t*pdu_type = IFH_PDU_TYPE_IPV4_UDP_PTP;\n\tif (type & PTP_CLASS_IPV6)\n\t\t*pdu_type = IFH_PDU_TYPE_IPV6_UDP_PTP;\n\n\tif (port->ptp_cmd == IFH_REW_OP_TWO_STEP_PTP) {\n\t\t*rew_op = IFH_REW_OP_TWO_STEP_PTP;\n\t\treturn;\n\t}\n\n\t \n\tmsgtype = ptp_get_msgtype(header, type);\n\tif ((msgtype & 0xf) == 0) {\n\t\t*rew_op = IFH_REW_OP_ONE_STEP_PTP;\n\t\treturn;\n\t}\n\n\t*rew_op = IFH_REW_OP_TWO_STEP_PTP;\n}\n\nstatic void sparx5_ptp_txtstamp_old_release(struct sparx5_port *port)\n{\n\tstruct sk_buff *skb, *skb_tmp;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&port->tx_skbs.lock, flags);\n\tskb_queue_walk_safe(&port->tx_skbs, skb, skb_tmp) {\n\t\tif time_after(SPARX5_SKB_CB(skb)->jiffies + SPARX5_PTP_TIMEOUT,\n\t\t\t      jiffies)\n\t\t\tbreak;\n\n\t\t__skb_unlink(skb, &port->tx_skbs);\n\t\tdev_kfree_skb_any(skb);\n\t}\n\tspin_unlock_irqrestore(&port->tx_skbs.lock, flags);\n}\n\nint sparx5_ptp_txtstamp_request(struct sparx5_port *port,\n\t\t\t\tstruct sk_buff *skb)\n{\n\tstruct sparx5 *sparx5 = port->sparx5;\n\tu8 rew_op, pdu_type, pdu_w16_offset;\n\tunsigned long flags;\n\n\tsparx5_ptp_classify(port, skb, &rew_op, &pdu_type, &pdu_w16_offset);\n\tSPARX5_SKB_CB(skb)->rew_op = rew_op;\n\tSPARX5_SKB_CB(skb)->pdu_type = pdu_type;\n\tSPARX5_SKB_CB(skb)->pdu_w16_offset = pdu_w16_offset;\n\n\tif (rew_op != IFH_REW_OP_TWO_STEP_PTP)\n\t\treturn 0;\n\n\tsparx5_ptp_txtstamp_old_release(port);\n\n\tspin_lock_irqsave(&sparx5->ptp_ts_id_lock, flags);\n\tif (sparx5->ptp_skbs == SPARX5_MAX_PTP_ID) {\n\t\tspin_unlock_irqrestore(&sparx5->ptp_ts_id_lock, flags);\n\t\treturn -EBUSY;\n\t}\n\n\tskb_shinfo(skb)->tx_flags |= SKBTX_IN_PROGRESS;\n\n\tskb_queue_tail(&port->tx_skbs, skb);\n\tSPARX5_SKB_CB(skb)->ts_id = port->ts_id;\n\tSPARX5_SKB_CB(skb)->jiffies = jiffies;\n\n\tsparx5->ptp_skbs++;\n\tport->ts_id++;\n\tif (port->ts_id == SPARX5_MAX_PTP_ID)\n\t\tport->ts_id = 0;\n\n\tspin_unlock_irqrestore(&sparx5->ptp_ts_id_lock, flags);\n\n\treturn 0;\n}\n\nvoid sparx5_ptp_txtstamp_release(struct sparx5_port *port,\n\t\t\t\t struct sk_buff *skb)\n{\n\tstruct sparx5 *sparx5 = port->sparx5;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&sparx5->ptp_ts_id_lock, flags);\n\tport->ts_id--;\n\tsparx5->ptp_skbs--;\n\tskb_unlink(skb, &port->tx_skbs);\n\tspin_unlock_irqrestore(&sparx5->ptp_ts_id_lock, flags);\n}\n\nstatic void sparx5_get_hwtimestamp(struct sparx5 *sparx5,\n\t\t\t\t   struct timespec64 *ts,\n\t\t\t\t   u32 nsec)\n{\n\t \n\tunsigned long flags;\n\tu32 curr_nsec;\n\n\tspin_lock_irqsave(&sparx5->ptp_clock_lock, flags);\n\n\tspx5_rmw(PTP_PTP_PIN_CFG_PTP_PIN_ACTION_SET(PTP_PIN_ACTION_SAVE) |\n\t\t PTP_PTP_PIN_CFG_PTP_PIN_DOM_SET(SPARX5_PHC_PORT) |\n\t\t PTP_PTP_PIN_CFG_PTP_PIN_SYNC_SET(0),\n\t\t PTP_PTP_PIN_CFG_PTP_PIN_ACTION |\n\t\t PTP_PTP_PIN_CFG_PTP_PIN_DOM |\n\t\t PTP_PTP_PIN_CFG_PTP_PIN_SYNC,\n\t\t sparx5, PTP_PTP_PIN_CFG(TOD_ACC_PIN));\n\n\tts->tv_sec = spx5_rd(sparx5, PTP_PTP_TOD_SEC_LSB(TOD_ACC_PIN));\n\tcurr_nsec = spx5_rd(sparx5, PTP_PTP_TOD_NSEC(TOD_ACC_PIN));\n\n\tts->tv_nsec = nsec;\n\n\t \n\tif (curr_nsec < nsec)\n\t\tts->tv_sec--;\n\n\tspin_unlock_irqrestore(&sparx5->ptp_clock_lock, flags);\n}\n\nirqreturn_t sparx5_ptp_irq_handler(int irq, void *args)\n{\n\tint budget = SPARX5_MAX_PTP_ID;\n\tstruct sparx5 *sparx5 = args;\n\n\twhile (budget--) {\n\t\tstruct sk_buff *skb, *skb_tmp, *skb_match = NULL;\n\t\tstruct skb_shared_hwtstamps shhwtstamps;\n\t\tstruct sparx5_port *port;\n\t\tstruct timespec64 ts;\n\t\tunsigned long flags;\n\t\tu32 val, id, txport;\n\t\tu32 delay;\n\n\t\tval = spx5_rd(sparx5, REW_PTP_TWOSTEP_CTRL);\n\n\t\t \n\t\tif (!(val & REW_PTP_TWOSTEP_CTRL_PTP_VLD))\n\t\t\tbreak;\n\n\t\tWARN_ON(val & REW_PTP_TWOSTEP_CTRL_PTP_OVFL);\n\n\t\tif (!(val & REW_PTP_TWOSTEP_CTRL_STAMP_TX))\n\t\t\tcontinue;\n\n\t\t \n\t\ttxport = REW_PTP_TWOSTEP_CTRL_STAMP_PORT_GET(val);\n\n\t\t \n\t\tport = sparx5->ports[txport];\n\n\t\t \n\t\tdelay = spx5_rd(sparx5, REW_PTP_TWOSTEP_STAMP);\n\t\tdelay = REW_PTP_TWOSTEP_STAMP_STAMP_NSEC_GET(delay);\n\n\t\t \n\t\tspx5_rmw(REW_PTP_TWOSTEP_CTRL_PTP_NXT_SET(1),\n\t\t\t REW_PTP_TWOSTEP_CTRL_PTP_NXT,\n\t\t\t sparx5, REW_PTP_TWOSTEP_CTRL);\n\n\t\tval = spx5_rd(sparx5, REW_PTP_TWOSTEP_CTRL);\n\n\t\t \n\t\tif (!(val & REW_PTP_TWOSTEP_CTRL_PTP_VLD))\n\t\t\tbreak;\n\n\t\t \n\t\tid = spx5_rd(sparx5, REW_PTP_TWOSTEP_STAMP);\n\t\tid <<= 8;\n\t\tid |= spx5_rd(sparx5, REW_PTP_TWOSTEP_STAMP_SUBNS);\n\n\t\tspin_lock_irqsave(&port->tx_skbs.lock, flags);\n\t\tskb_queue_walk_safe(&port->tx_skbs, skb, skb_tmp) {\n\t\t\tif (SPARX5_SKB_CB(skb)->ts_id != id)\n\t\t\t\tcontinue;\n\n\t\t\t__skb_unlink(skb, &port->tx_skbs);\n\t\t\tskb_match = skb;\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock_irqrestore(&port->tx_skbs.lock, flags);\n\n\t\t \n\t\tspx5_rmw(REW_PTP_TWOSTEP_CTRL_PTP_NXT_SET(1),\n\t\t\t REW_PTP_TWOSTEP_CTRL_PTP_NXT,\n\t\t\t sparx5, REW_PTP_TWOSTEP_CTRL);\n\n\t\tif (WARN_ON(!skb_match))\n\t\t\tcontinue;\n\n\t\tspin_lock(&sparx5->ptp_ts_id_lock);\n\t\tsparx5->ptp_skbs--;\n\t\tspin_unlock(&sparx5->ptp_ts_id_lock);\n\n\t\t \n\t\tsparx5_get_hwtimestamp(sparx5, &ts, delay);\n\n\t\t \n\t\tshhwtstamps.hwtstamp = ktime_set(ts.tv_sec, ts.tv_nsec);\n\t\tskb_tstamp_tx(skb_match, &shhwtstamps);\n\n\t\tdev_kfree_skb_any(skb_match);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int sparx5_ptp_adjfine(struct ptp_clock_info *ptp, long scaled_ppm)\n{\n\tstruct sparx5_phc *phc = container_of(ptp, struct sparx5_phc, info);\n\tstruct sparx5 *sparx5 = phc->sparx5;\n\tunsigned long flags;\n\tbool neg_adj = 0;\n\tu64 tod_inc;\n\tu64 ref;\n\n\tif (!scaled_ppm)\n\t\treturn 0;\n\n\tif (scaled_ppm < 0) {\n\t\tneg_adj = 1;\n\t\tscaled_ppm = -scaled_ppm;\n\t}\n\n\ttod_inc = sparx5_ptp_get_nominal_value(sparx5);\n\n\t \n\tref = sparx5_ptp_get_1ppm(sparx5) * (scaled_ppm >> 16);\n\tref += (sparx5_ptp_get_1ppm(sparx5) * (0xffff & scaled_ppm)) >> 16;\n\ttod_inc = neg_adj ? tod_inc - ref : tod_inc + ref;\n\n\tspin_lock_irqsave(&sparx5->ptp_clock_lock, flags);\n\n\tspx5_rmw(PTP_PTP_DOM_CFG_PTP_CLKCFG_DIS_SET(1 << BIT(phc->index)),\n\t\t PTP_PTP_DOM_CFG_PTP_CLKCFG_DIS,\n\t\t sparx5, PTP_PTP_DOM_CFG);\n\n\tspx5_wr((u32)tod_inc & 0xFFFFFFFF, sparx5,\n\t\tPTP_CLK_PER_CFG(phc->index, 0));\n\tspx5_wr((u32)(tod_inc >> 32), sparx5,\n\t\tPTP_CLK_PER_CFG(phc->index, 1));\n\n\tspx5_rmw(PTP_PTP_DOM_CFG_PTP_CLKCFG_DIS_SET(0),\n\t\t PTP_PTP_DOM_CFG_PTP_CLKCFG_DIS, sparx5,\n\t\t PTP_PTP_DOM_CFG);\n\n\tspin_unlock_irqrestore(&sparx5->ptp_clock_lock, flags);\n\n\treturn 0;\n}\n\nstatic int sparx5_ptp_settime64(struct ptp_clock_info *ptp,\n\t\t\t\tconst struct timespec64 *ts)\n{\n\tstruct sparx5_phc *phc = container_of(ptp, struct sparx5_phc, info);\n\tstruct sparx5 *sparx5 = phc->sparx5;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&sparx5->ptp_clock_lock, flags);\n\n\t \n\tspx5_rmw(PTP_PTP_PIN_CFG_PTP_PIN_ACTION_SET(PTP_PIN_ACTION_IDLE) |\n\t\t PTP_PTP_PIN_CFG_PTP_PIN_DOM_SET(phc->index) |\n\t\t PTP_PTP_PIN_CFG_PTP_PIN_SYNC_SET(0),\n\t\t PTP_PTP_PIN_CFG_PTP_PIN_ACTION |\n\t\t PTP_PTP_PIN_CFG_PTP_PIN_DOM |\n\t\t PTP_PTP_PIN_CFG_PTP_PIN_SYNC,\n\t\t sparx5, PTP_PTP_PIN_CFG(TOD_ACC_PIN));\n\n\t \n\tspx5_wr(PTP_PTP_TOD_SEC_MSB_PTP_TOD_SEC_MSB_SET(upper_32_bits(ts->tv_sec)),\n\t\tsparx5, PTP_PTP_TOD_SEC_MSB(TOD_ACC_PIN));\n\tspx5_wr(lower_32_bits(ts->tv_sec),\n\t\tsparx5, PTP_PTP_TOD_SEC_LSB(TOD_ACC_PIN));\n\tspx5_wr(ts->tv_nsec, sparx5, PTP_PTP_TOD_NSEC(TOD_ACC_PIN));\n\n\t \n\tspx5_rmw(PTP_PTP_PIN_CFG_PTP_PIN_ACTION_SET(PTP_PIN_ACTION_LOAD) |\n\t\t PTP_PTP_PIN_CFG_PTP_PIN_DOM_SET(phc->index) |\n\t\t PTP_PTP_PIN_CFG_PTP_PIN_SYNC_SET(0),\n\t\t PTP_PTP_PIN_CFG_PTP_PIN_ACTION |\n\t\t PTP_PTP_PIN_CFG_PTP_PIN_DOM |\n\t\t PTP_PTP_PIN_CFG_PTP_PIN_SYNC,\n\t\t sparx5, PTP_PTP_PIN_CFG(TOD_ACC_PIN));\n\n\tspin_unlock_irqrestore(&sparx5->ptp_clock_lock, flags);\n\n\treturn 0;\n}\n\nint sparx5_ptp_gettime64(struct ptp_clock_info *ptp, struct timespec64 *ts)\n{\n\tstruct sparx5_phc *phc = container_of(ptp, struct sparx5_phc, info);\n\tstruct sparx5 *sparx5 = phc->sparx5;\n\tunsigned long flags;\n\ttime64_t s;\n\ts64 ns;\n\n\tspin_lock_irqsave(&sparx5->ptp_clock_lock, flags);\n\n\tspx5_rmw(PTP_PTP_PIN_CFG_PTP_PIN_ACTION_SET(PTP_PIN_ACTION_SAVE) |\n\t\t PTP_PTP_PIN_CFG_PTP_PIN_DOM_SET(phc->index) |\n\t\t PTP_PTP_PIN_CFG_PTP_PIN_SYNC_SET(0),\n\t\t PTP_PTP_PIN_CFG_PTP_PIN_ACTION |\n\t\t PTP_PTP_PIN_CFG_PTP_PIN_DOM |\n\t\t PTP_PTP_PIN_CFG_PTP_PIN_SYNC,\n\t\t sparx5, PTP_PTP_PIN_CFG(TOD_ACC_PIN));\n\n\ts = spx5_rd(sparx5, PTP_PTP_TOD_SEC_MSB(TOD_ACC_PIN));\n\ts <<= 32;\n\ts |= spx5_rd(sparx5, PTP_PTP_TOD_SEC_LSB(TOD_ACC_PIN));\n\tns = spx5_rd(sparx5, PTP_PTP_TOD_NSEC(TOD_ACC_PIN));\n\tns &= PTP_PTP_TOD_NSEC_PTP_TOD_NSEC;\n\n\tspin_unlock_irqrestore(&sparx5->ptp_clock_lock, flags);\n\n\t \n\tif ((ns & 0xFFFFFFF0) == 0x3FFFFFF0) {\n\t\ts--;\n\t\tns &= 0xf;\n\t\tns += 999999984;\n\t}\n\n\tset_normalized_timespec64(ts, s, ns);\n\treturn 0;\n}\n\nstatic int sparx5_ptp_adjtime(struct ptp_clock_info *ptp, s64 delta)\n{\n\tstruct sparx5_phc *phc = container_of(ptp, struct sparx5_phc, info);\n\tstruct sparx5 *sparx5 = phc->sparx5;\n\n\tif (delta > -(NSEC_PER_SEC / 2) && delta < (NSEC_PER_SEC / 2)) {\n\t\tunsigned long flags;\n\n\t\tspin_lock_irqsave(&sparx5->ptp_clock_lock, flags);\n\n\t\t \n\t\tspx5_rmw(PTP_PTP_PIN_CFG_PTP_PIN_ACTION_SET(PTP_PIN_ACTION_IDLE) |\n\t\t\t PTP_PTP_PIN_CFG_PTP_PIN_DOM_SET(phc->index) |\n\t\t\t PTP_PTP_PIN_CFG_PTP_PIN_SYNC_SET(0),\n\t\t\t PTP_PTP_PIN_CFG_PTP_PIN_ACTION |\n\t\t\t PTP_PTP_PIN_CFG_PTP_PIN_DOM |\n\t\t\t PTP_PTP_PIN_CFG_PTP_PIN_SYNC,\n\t\t\t sparx5, PTP_PTP_PIN_CFG(TOD_ACC_PIN));\n\n\t\tspx5_wr(PTP_PTP_TOD_NSEC_PTP_TOD_NSEC_SET(delta),\n\t\t\tsparx5, PTP_PTP_TOD_NSEC(TOD_ACC_PIN));\n\n\t\t \n\t\tspx5_rmw(PTP_PTP_PIN_CFG_PTP_PIN_ACTION_SET(PTP_PIN_ACTION_DELTA) |\n\t\t\t PTP_PTP_PIN_CFG_PTP_PIN_DOM_SET(phc->index) |\n\t\t\t PTP_PTP_PIN_CFG_PTP_PIN_SYNC_SET(0),\n\t\t\t PTP_PTP_PIN_CFG_PTP_PIN_ACTION |\n\t\t\t PTP_PTP_PIN_CFG_PTP_PIN_DOM |\n\t\t\t PTP_PTP_PIN_CFG_PTP_PIN_SYNC,\n\t\t\t sparx5, PTP_PTP_PIN_CFG(TOD_ACC_PIN));\n\n\t\tspin_unlock_irqrestore(&sparx5->ptp_clock_lock, flags);\n\t} else {\n\t\t \n\t\tstruct timespec64 ts;\n\t\tu64 now;\n\n\t\tsparx5_ptp_gettime64(ptp, &ts);\n\n\t\tnow = ktime_to_ns(timespec64_to_ktime(ts));\n\t\tts = ns_to_timespec64(now + delta);\n\n\t\tsparx5_ptp_settime64(ptp, &ts);\n\t}\n\n\treturn 0;\n}\n\nstatic struct ptp_clock_info sparx5_ptp_clock_info = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"sparx5 ptp\",\n\t.max_adj\t= 200000,\n\t.gettime64\t= sparx5_ptp_gettime64,\n\t.settime64\t= sparx5_ptp_settime64,\n\t.adjtime\t= sparx5_ptp_adjtime,\n\t.adjfine\t= sparx5_ptp_adjfine,\n};\n\nstatic int sparx5_ptp_phc_init(struct sparx5 *sparx5,\n\t\t\t       int index,\n\t\t\t       struct ptp_clock_info *clock_info)\n{\n\tstruct sparx5_phc *phc = &sparx5->phc[index];\n\n\tphc->info = *clock_info;\n\tphc->clock = ptp_clock_register(&phc->info, sparx5->dev);\n\tif (IS_ERR(phc->clock))\n\t\treturn PTR_ERR(phc->clock);\n\n\tphc->index = index;\n\tphc->sparx5 = sparx5;\n\n\t \n\tphc->hwtstamp_config.rx_filter = HWTSTAMP_FILTER_PTP_V2_EVENT;\n\n\treturn 0;\n}\n\nint sparx5_ptp_init(struct sparx5 *sparx5)\n{\n\tu64 tod_adj = sparx5_ptp_get_nominal_value(sparx5);\n\tstruct sparx5_port *port;\n\tint err, i;\n\n\tif (!sparx5->ptp)\n\t\treturn 0;\n\n\tfor (i = 0; i < SPARX5_PHC_COUNT; ++i) {\n\t\terr = sparx5_ptp_phc_init(sparx5, i, &sparx5_ptp_clock_info);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tspin_lock_init(&sparx5->ptp_clock_lock);\n\tspin_lock_init(&sparx5->ptp_ts_id_lock);\n\tmutex_init(&sparx5->ptp_lock);\n\n\t \n\tspx5_wr(PTP_PTP_DOM_CFG_PTP_ENA_SET(0), sparx5, PTP_PTP_DOM_CFG);\n\n\t \n\tspx5_rmw(PTP_PTP_DOM_CFG_PTP_CLKCFG_DIS_SET(0x7),\n\t\t PTP_PTP_DOM_CFG_PTP_CLKCFG_DIS,\n\t\t sparx5, PTP_PTP_DOM_CFG);\n\n\tfor (i = 0; i < SPARX5_PHC_COUNT; ++i) {\n\t\tspx5_wr((u32)tod_adj & 0xFFFFFFFF, sparx5,\n\t\t\tPTP_CLK_PER_CFG(i, 0));\n\t\tspx5_wr((u32)(tod_adj >> 32), sparx5,\n\t\t\tPTP_CLK_PER_CFG(i, 1));\n\t}\n\n\tspx5_rmw(PTP_PTP_DOM_CFG_PTP_CLKCFG_DIS_SET(0),\n\t\t PTP_PTP_DOM_CFG_PTP_CLKCFG_DIS,\n\t\t sparx5, PTP_PTP_DOM_CFG);\n\n\t \n\tspx5_wr(PTP_PTP_DOM_CFG_PTP_ENA_SET(0x7), sparx5, PTP_PTP_DOM_CFG);\n\n\tfor (i = 0; i < SPX5_PORTS; i++) {\n\t\tport = sparx5->ports[i];\n\t\tif (!port)\n\t\t\tcontinue;\n\n\t\tskb_queue_head_init(&port->tx_skbs);\n\t}\n\n\treturn 0;\n}\n\nvoid sparx5_ptp_deinit(struct sparx5 *sparx5)\n{\n\tstruct sparx5_port *port;\n\tint i;\n\n\tfor (i = 0; i < SPX5_PORTS; i++) {\n\t\tport = sparx5->ports[i];\n\t\tif (!port)\n\t\t\tcontinue;\n\n\t\tskb_queue_purge(&port->tx_skbs);\n\t}\n\n\tfor (i = 0; i < SPARX5_PHC_COUNT; ++i)\n\t\tptp_clock_unregister(sparx5->phc[i].clock);\n}\n\nvoid sparx5_ptp_rxtstamp(struct sparx5 *sparx5, struct sk_buff *skb,\n\t\t\t u64 timestamp)\n{\n\tstruct skb_shared_hwtstamps *shhwtstamps;\n\tstruct sparx5_phc *phc;\n\tstruct timespec64 ts;\n\tu64 full_ts_in_ns;\n\n\tif (!sparx5->ptp)\n\t\treturn;\n\n\tphc = &sparx5->phc[SPARX5_PHC_PORT];\n\tsparx5_ptp_gettime64(&phc->info, &ts);\n\n\tif (ts.tv_nsec < timestamp)\n\t\tts.tv_sec--;\n\tts.tv_nsec = timestamp;\n\tfull_ts_in_ns = ktime_set(ts.tv_sec, ts.tv_nsec);\n\n\tshhwtstamps = skb_hwtstamps(skb);\n\tshhwtstamps->hwtstamp = full_ts_in_ns;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}