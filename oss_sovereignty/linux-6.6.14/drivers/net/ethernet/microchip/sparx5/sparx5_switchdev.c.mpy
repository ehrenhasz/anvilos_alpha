{
  "module_name": "sparx5_switchdev.c",
  "hash_id": "d041d9c0985cdc30f2b339ea891b81f86f02dd448650d30c8332f5caa29b3c91",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/microchip/sparx5/sparx5_switchdev.c",
  "human_readable_source": "\n \n\n#include <linux/if_bridge.h>\n#include <net/switchdev.h>\n\n#include \"sparx5_main_regs.h\"\n#include \"sparx5_main.h\"\n\nstatic struct workqueue_struct *sparx5_owq;\n\nstruct sparx5_switchdev_event_work {\n\tstruct work_struct work;\n\tstruct switchdev_notifier_fdb_info fdb_info;\n\tstruct net_device *dev;\n\tstruct sparx5 *sparx5;\n\tunsigned long event;\n};\n\nstatic int sparx5_port_attr_pre_bridge_flags(struct sparx5_port *port,\n\t\t\t\t\t     struct switchdev_brport_flags flags)\n{\n\tif (flags.mask & ~(BR_FLOOD | BR_MCAST_FLOOD | BR_BCAST_FLOOD))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic void sparx5_port_update_mcast_ip_flood(struct sparx5_port *port, bool flood_flag)\n{\n\tbool should_flood = flood_flag || port->is_mrouter;\n\tint pgid;\n\n\tfor (pgid = PGID_IPV4_MC_DATA; pgid <= PGID_IPV6_MC_CTRL; pgid++)\n\t\tsparx5_pgid_update_mask(port, pgid, should_flood);\n}\n\nstatic void sparx5_port_attr_bridge_flags(struct sparx5_port *port,\n\t\t\t\t\t  struct switchdev_brport_flags flags)\n{\n\tif (flags.mask & BR_MCAST_FLOOD) {\n\t\tsparx5_pgid_update_mask(port, PGID_MC_FLOOD, !!(flags.val & BR_MCAST_FLOOD));\n\t\tsparx5_port_update_mcast_ip_flood(port, !!(flags.val & BR_MCAST_FLOOD));\n\t}\n\n\tif (flags.mask & BR_FLOOD)\n\t\tsparx5_pgid_update_mask(port, PGID_UC_FLOOD, !!(flags.val & BR_FLOOD));\n\tif (flags.mask & BR_BCAST_FLOOD)\n\t\tsparx5_pgid_update_mask(port, PGID_BCAST, !!(flags.val & BR_BCAST_FLOOD));\n}\n\nstatic void sparx5_attr_stp_state_set(struct sparx5_port *port,\n\t\t\t\t      u8 state)\n{\n\tstruct sparx5 *sparx5 = port->sparx5;\n\n\tif (!test_bit(port->portno, sparx5->bridge_mask)) {\n\t\tnetdev_err(port->ndev,\n\t\t\t   \"Controlling non-bridged port %d?\\n\", port->portno);\n\t\treturn;\n\t}\n\n\tswitch (state) {\n\tcase BR_STATE_FORWARDING:\n\t\tset_bit(port->portno, sparx5->bridge_fwd_mask);\n\t\tfallthrough;\n\tcase BR_STATE_LEARNING:\n\t\tset_bit(port->portno, sparx5->bridge_lrn_mask);\n\t\tbreak;\n\n\tdefault:\n\t\t \n\t\tclear_bit(port->portno, sparx5->bridge_fwd_mask);\n\t\tclear_bit(port->portno, sparx5->bridge_lrn_mask);\n\t\tbreak;\n\t}\n\n\t \n\tsparx5_update_fwd(sparx5);\n}\n\nstatic void sparx5_port_attr_ageing_set(struct sparx5_port *port,\n\t\t\t\t\tunsigned long ageing_clock_t)\n{\n\tunsigned long ageing_jiffies = clock_t_to_jiffies(ageing_clock_t);\n\tu32 ageing_time = jiffies_to_msecs(ageing_jiffies);\n\n\tsparx5_set_ageing(port->sparx5, ageing_time);\n}\n\nstatic void sparx5_port_attr_mrouter_set(struct sparx5_port *port,\n\t\t\t\t\t struct net_device *orig_dev,\n\t\t\t\t\t bool enable)\n{\n\tstruct sparx5 *sparx5 = port->sparx5;\n\tstruct sparx5_mdb_entry *e;\n\tbool flood_flag;\n\n\tif ((enable && port->is_mrouter) || (!enable && !port->is_mrouter))\n\t\treturn;\n\n\t \n\tmutex_lock(&sparx5->mdb_lock);\n\tlist_for_each_entry(e, &sparx5->mdb_entries, list) {\n\t\tif (!test_bit(port->portno, e->port_mask) &&\n\t\t    ether_addr_is_ip_mcast(e->addr))\n\t\t\tsparx5_pgid_update_mask(port, e->pgid_idx, enable);\n\t}\n\tmutex_unlock(&sparx5->mdb_lock);\n\n\t \n\tport->is_mrouter = enable;\n\tflood_flag = br_port_flag_is_set(port->ndev, BR_MCAST_FLOOD);\n\tsparx5_port_update_mcast_ip_flood(port, flood_flag);\n}\n\nstatic int sparx5_port_attr_set(struct net_device *dev, const void *ctx,\n\t\t\t\tconst struct switchdev_attr *attr,\n\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct sparx5_port *port = netdev_priv(dev);\n\n\tswitch (attr->id) {\n\tcase SWITCHDEV_ATTR_ID_PORT_PRE_BRIDGE_FLAGS:\n\t\treturn sparx5_port_attr_pre_bridge_flags(port,\n\t\t\t\t\t\t\t attr->u.brport_flags);\n\tcase SWITCHDEV_ATTR_ID_PORT_BRIDGE_FLAGS:\n\t\tsparx5_port_attr_bridge_flags(port, attr->u.brport_flags);\n\t\tbreak;\n\tcase SWITCHDEV_ATTR_ID_PORT_STP_STATE:\n\t\tsparx5_attr_stp_state_set(port, attr->u.stp_state);\n\t\tbreak;\n\tcase SWITCHDEV_ATTR_ID_BRIDGE_AGEING_TIME:\n\t\tsparx5_port_attr_ageing_set(port, attr->u.ageing_time);\n\t\tbreak;\n\tcase SWITCHDEV_ATTR_ID_BRIDGE_VLAN_FILTERING:\n\t\t \n\t\tif (port->pvid == 0)\n\t\t\tport->pvid = 1;\n\t\tport->vlan_aware = attr->u.vlan_filtering;\n\t\tsparx5_vlan_port_apply(port->sparx5, port);\n\t\tbreak;\n\tcase SWITCHDEV_ATTR_ID_PORT_MROUTER:\n\t\tsparx5_port_attr_mrouter_set(port,\n\t\t\t\t\t     attr->orig_dev,\n\t\t\t\t\t     attr->u.mrouter);\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic int sparx5_port_bridge_join(struct sparx5_port *port,\n\t\t\t\t   struct net_device *bridge,\n\t\t\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct sparx5 *sparx5 = port->sparx5;\n\tstruct net_device *ndev = port->ndev;\n\tint err;\n\n\tif (bitmap_empty(sparx5->bridge_mask, SPX5_PORTS))\n\t\t \n\t\tsparx5->hw_bridge_dev = bridge;\n\telse\n\t\tif (sparx5->hw_bridge_dev != bridge)\n\t\t\t \n\t\t\treturn -ENODEV;\n\n\tset_bit(port->portno, sparx5->bridge_mask);\n\n\terr = switchdev_bridge_port_offload(ndev, ndev, NULL, NULL, NULL,\n\t\t\t\t\t    false, extack);\n\tif (err)\n\t\tgoto err_switchdev_offload;\n\n\t \n\tsparx5_mact_forget(sparx5, ndev->dev_addr, 0);\n\n\t \n\t__dev_mc_unsync(ndev, sparx5_mc_unsync);\n\n\treturn 0;\n\nerr_switchdev_offload:\n\tclear_bit(port->portno, sparx5->bridge_mask);\n\treturn err;\n}\n\nstatic void sparx5_port_bridge_leave(struct sparx5_port *port,\n\t\t\t\t     struct net_device *bridge)\n{\n\tstruct sparx5 *sparx5 = port->sparx5;\n\n\tswitchdev_bridge_port_unoffload(port->ndev, NULL, NULL, NULL);\n\n\tclear_bit(port->portno, sparx5->bridge_mask);\n\tif (bitmap_empty(sparx5->bridge_mask, SPX5_PORTS))\n\t\tsparx5->hw_bridge_dev = NULL;\n\n\t \n\tport->vlan_aware = 0;\n\tport->pvid = NULL_VID;\n\tport->vid = NULL_VID;\n\n\t \n\tsparx5_mact_learn(sparx5, PGID_CPU, port->ndev->dev_addr, 0);\n\n\t \n\t__dev_mc_sync(port->ndev, sparx5_mc_sync, sparx5_mc_unsync);\n}\n\nstatic int sparx5_port_changeupper(struct net_device *dev,\n\t\t\t\t   struct netdev_notifier_changeupper_info *info)\n{\n\tstruct sparx5_port *port = netdev_priv(dev);\n\tstruct netlink_ext_ack *extack;\n\tint err = 0;\n\n\textack = netdev_notifier_info_to_extack(&info->info);\n\n\tif (netif_is_bridge_master(info->upper_dev)) {\n\t\tif (info->linking)\n\t\t\terr = sparx5_port_bridge_join(port, info->upper_dev,\n\t\t\t\t\t\t      extack);\n\t\telse\n\t\t\tsparx5_port_bridge_leave(port, info->upper_dev);\n\n\t\tsparx5_vlan_port_apply(port->sparx5, port);\n\t}\n\n\treturn err;\n}\n\nstatic int sparx5_port_add_addr(struct net_device *dev, bool up)\n{\n\tstruct sparx5_port *port = netdev_priv(dev);\n\tstruct sparx5 *sparx5 = port->sparx5;\n\tu16 vid = port->pvid;\n\n\tif (up)\n\t\tsparx5_mact_learn(sparx5, PGID_CPU, port->ndev->dev_addr, vid);\n\telse\n\t\tsparx5_mact_forget(sparx5, port->ndev->dev_addr, vid);\n\n\treturn 0;\n}\n\nstatic int sparx5_netdevice_port_event(struct net_device *dev,\n\t\t\t\t       struct notifier_block *nb,\n\t\t\t\t       unsigned long event, void *ptr)\n{\n\tint err = 0;\n\n\tif (!sparx5_netdevice_check(dev))\n\t\treturn 0;\n\n\tswitch (event) {\n\tcase NETDEV_CHANGEUPPER:\n\t\terr = sparx5_port_changeupper(dev, ptr);\n\t\tbreak;\n\tcase NETDEV_PRE_UP:\n\t\terr = sparx5_port_add_addr(dev, true);\n\t\tbreak;\n\tcase NETDEV_DOWN:\n\t\terr = sparx5_port_add_addr(dev, false);\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nstatic int sparx5_netdevice_event(struct notifier_block *nb,\n\t\t\t\t  unsigned long event, void *ptr)\n{\n\tstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\n\tint ret = 0;\n\n\tret = sparx5_netdevice_port_event(dev, nb, event, ptr);\n\n\treturn notifier_from_errno(ret);\n}\n\nstatic void sparx5_switchdev_bridge_fdb_event_work(struct work_struct *work)\n{\n\tstruct sparx5_switchdev_event_work *switchdev_work =\n\t\tcontainer_of(work, struct sparx5_switchdev_event_work, work);\n\tstruct net_device *dev = switchdev_work->dev;\n\tstruct switchdev_notifier_fdb_info *fdb_info;\n\tstruct sparx5_port *port;\n\tstruct sparx5 *sparx5;\n\tbool host_addr;\n\tu16 vid;\n\n\trtnl_lock();\n\tif (!sparx5_netdevice_check(dev)) {\n\t\thost_addr = true;\n\t\tsparx5 = switchdev_work->sparx5;\n\t} else {\n\t\thost_addr = false;\n\t\tsparx5 = switchdev_work->sparx5;\n\t\tport = netdev_priv(dev);\n\t}\n\n\tfdb_info = &switchdev_work->fdb_info;\n\n\t \n\tif (fdb_info->vid == 0)\n\t\tvid = 1;\n\telse\n\t\tvid = fdb_info->vid;\n\n\tswitch (switchdev_work->event) {\n\tcase SWITCHDEV_FDB_ADD_TO_DEVICE:\n\t\tif (host_addr)\n\t\t\tsparx5_add_mact_entry(sparx5, dev, PGID_CPU,\n\t\t\t\t\t      fdb_info->addr, vid);\n\t\telse\n\t\t\tsparx5_add_mact_entry(sparx5, port->ndev, port->portno,\n\t\t\t\t\t      fdb_info->addr, vid);\n\t\tbreak;\n\tcase SWITCHDEV_FDB_DEL_TO_DEVICE:\n\t\tsparx5_del_mact_entry(sparx5, fdb_info->addr, vid);\n\t\tbreak;\n\t}\n\n\trtnl_unlock();\n\tkfree(switchdev_work->fdb_info.addr);\n\tkfree(switchdev_work);\n\tdev_put(dev);\n}\n\nstatic void sparx5_schedule_work(struct work_struct *work)\n{\n\tqueue_work(sparx5_owq, work);\n}\n\nstatic int sparx5_switchdev_event(struct notifier_block *nb,\n\t\t\t\t  unsigned long event, void *ptr)\n{\n\tstruct net_device *dev = switchdev_notifier_info_to_dev(ptr);\n\tstruct sparx5_switchdev_event_work *switchdev_work;\n\tstruct switchdev_notifier_fdb_info *fdb_info;\n\tstruct switchdev_notifier_info *info = ptr;\n\tstruct sparx5 *spx5;\n\tint err;\n\n\tspx5 = container_of(nb, struct sparx5, switchdev_nb);\n\n\tswitch (event) {\n\tcase SWITCHDEV_PORT_ATTR_SET:\n\t\terr = switchdev_handle_port_attr_set(dev, ptr,\n\t\t\t\t\t\t     sparx5_netdevice_check,\n\t\t\t\t\t\t     sparx5_port_attr_set);\n\t\treturn notifier_from_errno(err);\n\tcase SWITCHDEV_FDB_ADD_TO_DEVICE:\n\t\tfallthrough;\n\tcase SWITCHDEV_FDB_DEL_TO_DEVICE:\n\t\tswitchdev_work = kzalloc(sizeof(*switchdev_work), GFP_ATOMIC);\n\t\tif (!switchdev_work)\n\t\t\treturn NOTIFY_BAD;\n\n\t\tswitchdev_work->dev = dev;\n\t\tswitchdev_work->event = event;\n\t\tswitchdev_work->sparx5 = spx5;\n\n\t\tfdb_info = container_of(info,\n\t\t\t\t\tstruct switchdev_notifier_fdb_info,\n\t\t\t\t\tinfo);\n\t\tINIT_WORK(&switchdev_work->work,\n\t\t\t  sparx5_switchdev_bridge_fdb_event_work);\n\t\tmemcpy(&switchdev_work->fdb_info, ptr,\n\t\t       sizeof(switchdev_work->fdb_info));\n\t\tswitchdev_work->fdb_info.addr = kzalloc(ETH_ALEN, GFP_ATOMIC);\n\t\tif (!switchdev_work->fdb_info.addr)\n\t\t\tgoto err_addr_alloc;\n\n\t\tether_addr_copy((u8 *)switchdev_work->fdb_info.addr,\n\t\t\t\tfdb_info->addr);\n\t\tdev_hold(dev);\n\n\t\tsparx5_schedule_work(&switchdev_work->work);\n\t\tbreak;\n\t}\n\n\treturn NOTIFY_DONE;\nerr_addr_alloc:\n\tkfree(switchdev_work);\n\treturn NOTIFY_BAD;\n}\n\nstatic int sparx5_handle_port_vlan_add(struct net_device *dev,\n\t\t\t\t       struct notifier_block *nb,\n\t\t\t\t       const struct switchdev_obj_port_vlan *v)\n{\n\tstruct sparx5_port *port = netdev_priv(dev);\n\n\tif (netif_is_bridge_master(dev)) {\n\t\tstruct sparx5 *sparx5 =\n\t\t\tcontainer_of(nb, struct sparx5,\n\t\t\t\t     switchdev_blocking_nb);\n\n\t\t \n\t\tsparx5_mact_learn(sparx5, PGID_BCAST, dev->broadcast,\n\t\t\t\t  v->vid);\n\t\treturn 0;\n\t}\n\n\tif (!sparx5_netdevice_check(dev))\n\t\treturn -EOPNOTSUPP;\n\n\treturn sparx5_vlan_vid_add(port, v->vid,\n\t\t\t\t  v->flags & BRIDGE_VLAN_INFO_PVID,\n\t\t\t\t  v->flags & BRIDGE_VLAN_INFO_UNTAGGED);\n}\n\nstatic int sparx5_alloc_mdb_entry(struct sparx5 *sparx5,\n\t\t\t\t  const unsigned char *addr,\n\t\t\t\t  u16 vid,\n\t\t\t\t  struct sparx5_mdb_entry **entry_out)\n{\n\tstruct sparx5_mdb_entry *entry;\n\tu16 pgid_idx;\n\tint err;\n\n\tentry = kzalloc(sizeof(*entry), GFP_KERNEL);\n\tif (!entry)\n\t\treturn -ENOMEM;\n\n\terr = sparx5_pgid_alloc_mcast(sparx5, &pgid_idx);\n\tif (err) {\n\t\tkfree(entry);\n\t\treturn err;\n\t}\n\n\tmemcpy(entry->addr, addr, ETH_ALEN);\n\tentry->vid = vid;\n\tentry->pgid_idx = pgid_idx;\n\n\tmutex_lock(&sparx5->mdb_lock);\n\tlist_add_tail(&entry->list, &sparx5->mdb_entries);\n\tmutex_unlock(&sparx5->mdb_lock);\n\n\t*entry_out = entry;\n\treturn 0;\n}\n\nstatic void sparx5_free_mdb_entry(struct sparx5 *sparx5,\n\t\t\t\t  const unsigned char *addr,\n\t\t\t\t  u16 vid)\n{\n\tstruct sparx5_mdb_entry *entry, *tmp;\n\n\tmutex_lock(&sparx5->mdb_lock);\n\tlist_for_each_entry_safe(entry, tmp, &sparx5->mdb_entries, list) {\n\t\tif ((vid == 0 || entry->vid == vid) &&\n\t\t    ether_addr_equal(addr, entry->addr)) {\n\t\t\tlist_del(&entry->list);\n\n\t\t\tsparx5_pgid_free(sparx5, entry->pgid_idx);\n\t\t\tkfree(entry);\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tmutex_unlock(&sparx5->mdb_lock);\n}\n\nstatic struct sparx5_mdb_entry *sparx5_mdb_get_entry(struct sparx5 *sparx5,\n\t\t\t\t\t\t     const unsigned char *addr,\n\t\t\t\t\t\t     u16 vid)\n{\n\tstruct sparx5_mdb_entry *e, *found = NULL;\n\n\tmutex_lock(&sparx5->mdb_lock);\n\tlist_for_each_entry(e, &sparx5->mdb_entries, list) {\n\t\tif (ether_addr_equal(e->addr, addr) && e->vid == vid) {\n\t\t\tfound = e;\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tmutex_unlock(&sparx5->mdb_lock);\n\treturn found;\n}\n\nstatic void sparx5_cpu_copy_ena(struct sparx5 *spx5, u16 pgid, bool enable)\n{\n\tspx5_rmw(ANA_AC_PGID_MISC_CFG_PGID_CPU_COPY_ENA_SET(enable),\n\t\t ANA_AC_PGID_MISC_CFG_PGID_CPU_COPY_ENA, spx5,\n\t\t ANA_AC_PGID_MISC_CFG(pgid));\n}\n\nstatic int sparx5_handle_port_mdb_add(struct net_device *dev,\n\t\t\t\t      struct notifier_block *nb,\n\t\t\t\t      const struct switchdev_obj_port_mdb *v)\n{\n\tstruct sparx5_port *port = netdev_priv(dev);\n\tstruct sparx5 *spx5 = port->sparx5;\n\tstruct sparx5_mdb_entry *entry;\n\tbool is_host, is_new;\n\tint err, i;\n\tu16 vid;\n\n\tif (!sparx5_netdevice_check(dev))\n\t\treturn -EOPNOTSUPP;\n\n\tis_host = netif_is_bridge_master(v->obj.orig_dev);\n\n\t \n\tif (!br_vlan_enabled(spx5->hw_bridge_dev))\n\t\tvid = 1;\n\telse\n\t\tvid = v->vid;\n\n\tis_new = false;\n\tentry = sparx5_mdb_get_entry(spx5, v->addr, vid);\n\tif (!entry) {\n\t\terr = sparx5_alloc_mdb_entry(spx5, v->addr, vid, &entry);\n\t\tis_new = true;\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tmutex_lock(&spx5->mdb_lock);\n\n\t \n\tif (is_new && ether_addr_is_ip_mcast(v->addr))\n\t\tfor (i = 0; i < SPX5_PORTS; i++)\n\t\t\tif (spx5->ports[i] && spx5->ports[i]->is_mrouter)\n\t\t\t\tsparx5_pgid_update_mask(spx5->ports[i],\n\t\t\t\t\t\t\tentry->pgid_idx,\n\t\t\t\t\t\t\ttrue);\n\n\tif (is_host && !entry->cpu_copy) {\n\t\tsparx5_cpu_copy_ena(spx5, entry->pgid_idx, true);\n\t\tentry->cpu_copy = true;\n\t} else if (!is_host) {\n\t\tsparx5_pgid_update_mask(port, entry->pgid_idx, true);\n\t\tset_bit(port->portno, entry->port_mask);\n\t}\n\tmutex_unlock(&spx5->mdb_lock);\n\n\tsparx5_mact_learn(spx5, entry->pgid_idx, entry->addr, entry->vid);\n\n\treturn 0;\n}\n\nstatic int sparx5_handle_port_mdb_del(struct net_device *dev,\n\t\t\t\t      struct notifier_block *nb,\n\t\t\t\t      const struct switchdev_obj_port_mdb *v)\n{\n\tstruct sparx5_port *port = netdev_priv(dev);\n\tstruct sparx5 *spx5 = port->sparx5;\n\tstruct sparx5_mdb_entry *entry;\n\tbool is_host;\n\tu16 vid;\n\n\tif (!sparx5_netdevice_check(dev))\n\t\treturn -EOPNOTSUPP;\n\n\tis_host = netif_is_bridge_master(v->obj.orig_dev);\n\n\tif (!br_vlan_enabled(spx5->hw_bridge_dev))\n\t\tvid = 1;\n\telse\n\t\tvid = v->vid;\n\n\tentry = sparx5_mdb_get_entry(spx5, v->addr, vid);\n\tif (!entry)\n\t\treturn 0;\n\n\tmutex_lock(&spx5->mdb_lock);\n\tif (is_host && entry->cpu_copy) {\n\t\tsparx5_cpu_copy_ena(spx5, entry->pgid_idx, false);\n\t\tentry->cpu_copy = false;\n\t} else if (!is_host) {\n\t\tclear_bit(port->portno, entry->port_mask);\n\n\t\t \n\t\tif (!port->is_mrouter || !ether_addr_is_ip_mcast(v->addr))\n\t\t\tsparx5_pgid_update_mask(port, entry->pgid_idx, false);\n\t}\n\tmutex_unlock(&spx5->mdb_lock);\n\n\tif (bitmap_empty(entry->port_mask, SPX5_PORTS) && !entry->cpu_copy) {\n\t\t  \n\t\tsparx5_pgid_clear(spx5, entry->pgid_idx);\n\t\tsparx5_mact_forget(spx5, entry->addr, entry->vid);\n\t\tsparx5_free_mdb_entry(spx5, entry->addr, entry->vid);\n\t}\n\treturn 0;\n}\n\nstatic int sparx5_handle_port_obj_add(struct net_device *dev,\n\t\t\t\t      struct notifier_block *nb,\n\t\t\t\t      struct switchdev_notifier_port_obj_info *info)\n{\n\tconst struct switchdev_obj *obj = info->obj;\n\tint err;\n\n\tswitch (obj->id) {\n\tcase SWITCHDEV_OBJ_ID_PORT_VLAN:\n\t\terr = sparx5_handle_port_vlan_add(dev, nb,\n\t\t\t\t\t\t  SWITCHDEV_OBJ_PORT_VLAN(obj));\n\t\tbreak;\n\tcase SWITCHDEV_OBJ_ID_PORT_MDB:\n\tcase SWITCHDEV_OBJ_ID_HOST_MDB:\n\t\terr = sparx5_handle_port_mdb_add(dev, nb,\n\t\t\t\t\t\t SWITCHDEV_OBJ_PORT_MDB(obj));\n\t\tbreak;\n\tdefault:\n\t\terr = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\n\tinfo->handled = true;\n\treturn err;\n}\n\nstatic int sparx5_handle_port_vlan_del(struct net_device *dev,\n\t\t\t\t       struct notifier_block *nb,\n\t\t\t\t       u16 vid)\n{\n\tstruct sparx5_port *port = netdev_priv(dev);\n\tint ret;\n\n\t \n\tif (netif_is_bridge_master(dev)) {\n\t\tstruct sparx5 *sparx5 =\n\t\t\tcontainer_of(nb, struct sparx5,\n\t\t\t\t     switchdev_blocking_nb);\n\n\t\tsparx5_mact_forget(sparx5, dev->broadcast, vid);\n\t\treturn 0;\n\t}\n\n\tif (!sparx5_netdevice_check(dev))\n\t\treturn -EOPNOTSUPP;\n\n\tret = sparx5_vlan_vid_del(port, vid);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int sparx5_handle_port_obj_del(struct net_device *dev,\n\t\t\t\t      struct notifier_block *nb,\n\t\t\t\t      struct switchdev_notifier_port_obj_info *info)\n{\n\tconst struct switchdev_obj *obj = info->obj;\n\tint err;\n\n\tswitch (obj->id) {\n\tcase SWITCHDEV_OBJ_ID_PORT_VLAN:\n\t\terr = sparx5_handle_port_vlan_del(dev, nb,\n\t\t\t\t\t\t  SWITCHDEV_OBJ_PORT_VLAN(obj)->vid);\n\t\tbreak;\n\tcase SWITCHDEV_OBJ_ID_PORT_MDB:\n\tcase SWITCHDEV_OBJ_ID_HOST_MDB:\n\t\terr = sparx5_handle_port_mdb_del(dev, nb,\n\t\t\t\t\t\t SWITCHDEV_OBJ_PORT_MDB(obj));\n\t\tbreak;\n\tdefault:\n\t\terr = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\n\tinfo->handled = true;\n\treturn err;\n}\n\nstatic int sparx5_switchdev_blocking_event(struct notifier_block *nb,\n\t\t\t\t\t   unsigned long event,\n\t\t\t\t\t   void *ptr)\n{\n\tstruct net_device *dev = switchdev_notifier_info_to_dev(ptr);\n\tint err;\n\n\tswitch (event) {\n\tcase SWITCHDEV_PORT_OBJ_ADD:\n\t\terr = sparx5_handle_port_obj_add(dev, nb, ptr);\n\t\treturn notifier_from_errno(err);\n\tcase SWITCHDEV_PORT_OBJ_DEL:\n\t\terr = sparx5_handle_port_obj_del(dev, nb, ptr);\n\t\treturn notifier_from_errno(err);\n\tcase SWITCHDEV_PORT_ATTR_SET:\n\t\terr = switchdev_handle_port_attr_set(dev, ptr,\n\t\t\t\t\t\t     sparx5_netdevice_check,\n\t\t\t\t\t\t     sparx5_port_attr_set);\n\t\treturn notifier_from_errno(err);\n\t}\n\n\treturn NOTIFY_DONE;\n}\n\nint sparx5_register_notifier_blocks(struct sparx5 *s5)\n{\n\tint err;\n\n\ts5->netdevice_nb.notifier_call = sparx5_netdevice_event;\n\terr = register_netdevice_notifier(&s5->netdevice_nb);\n\tif (err)\n\t\treturn err;\n\n\ts5->switchdev_nb.notifier_call = sparx5_switchdev_event;\n\terr = register_switchdev_notifier(&s5->switchdev_nb);\n\tif (err)\n\t\tgoto err_switchdev_nb;\n\n\ts5->switchdev_blocking_nb.notifier_call = sparx5_switchdev_blocking_event;\n\terr = register_switchdev_blocking_notifier(&s5->switchdev_blocking_nb);\n\tif (err)\n\t\tgoto err_switchdev_blocking_nb;\n\n\tsparx5_owq = alloc_ordered_workqueue(\"sparx5_order\", 0);\n\tif (!sparx5_owq) {\n\t\terr = -ENOMEM;\n\t\tgoto err_switchdev_blocking_nb;\n\t}\n\n\treturn 0;\n\nerr_switchdev_blocking_nb:\n\tunregister_switchdev_notifier(&s5->switchdev_nb);\nerr_switchdev_nb:\n\tunregister_netdevice_notifier(&s5->netdevice_nb);\n\n\treturn err;\n}\n\nvoid sparx5_unregister_notifier_blocks(struct sparx5 *s5)\n{\n\tdestroy_workqueue(sparx5_owq);\n\n\tunregister_switchdev_blocking_notifier(&s5->switchdev_blocking_nb);\n\tunregister_switchdev_notifier(&s5->switchdev_nb);\n\tunregister_netdevice_notifier(&s5->netdevice_nb);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}