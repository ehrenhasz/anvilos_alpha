{
  "module_name": "sparx5_main.h",
  "hash_id": "25ebbc691d3f5d4faebcb912515bbd7926a48cefb344da44998eb51f0acc4474",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/microchip/sparx5/sparx5_main.h",
  "human_readable_source": " \n \n\n#ifndef __SPARX5_MAIN_H__\n#define __SPARX5_MAIN_H__\n\n#include <linux/types.h>\n#include <linux/phy/phy.h>\n#include <linux/netdevice.h>\n#include <linux/phy.h>\n#include <linux/if_vlan.h>\n#include <linux/bitmap.h>\n#include <linux/phylink.h>\n#include <linux/net_tstamp.h>\n#include <linux/ptp_clock_kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/debugfs.h>\n\n#include \"sparx5_main_regs.h\"\n\n \nenum spx5_target_chiptype {\n\tSPX5_TARGET_CT_7546    = 0x7546,   \n\tSPX5_TARGET_CT_7549    = 0x7549,   \n\tSPX5_TARGET_CT_7552    = 0x7552,   \n\tSPX5_TARGET_CT_7556    = 0x7556,   \n\tSPX5_TARGET_CT_7558    = 0x7558,   \n\tSPX5_TARGET_CT_7546TSN = 0x47546,  \n\tSPX5_TARGET_CT_7549TSN = 0x47549,  \n\tSPX5_TARGET_CT_7552TSN = 0x47552,  \n\tSPX5_TARGET_CT_7556TSN = 0x47556,  \n\tSPX5_TARGET_CT_7558TSN = 0x47558,  \n};\n\nenum sparx5_port_max_tags {\n\tSPX5_PORT_MAX_TAGS_NONE,   \n\tSPX5_PORT_MAX_TAGS_ONE,    \n\tSPX5_PORT_MAX_TAGS_TWO     \n};\n\nenum sparx5_vlan_port_type {\n\tSPX5_VLAN_PORT_TYPE_UNAWARE,  \n\tSPX5_VLAN_PORT_TYPE_C,        \n\tSPX5_VLAN_PORT_TYPE_S,        \n\tSPX5_VLAN_PORT_TYPE_S_CUSTOM  \n};\n\n#define SPX5_PORTS             65\n#define SPX5_PORT_CPU          (SPX5_PORTS)   \n#define SPX5_PORT_CPU_0        (SPX5_PORT_CPU + 0)  \n#define SPX5_PORT_CPU_1        (SPX5_PORT_CPU + 1)  \n#define SPX5_PORT_VD0          (SPX5_PORT_CPU + 2)  \n#define SPX5_PORT_VD1          (SPX5_PORT_CPU + 3)  \n#define SPX5_PORT_VD2          (SPX5_PORT_CPU + 4)  \n#define SPX5_PORTS_ALL         (SPX5_PORT_CPU + 5)  \n\n#define PGID_BASE              SPX5_PORTS  \n#define PGID_UC_FLOOD          (PGID_BASE + 0)\n#define PGID_MC_FLOOD          (PGID_BASE + 1)\n#define PGID_IPV4_MC_DATA      (PGID_BASE + 2)\n#define PGID_IPV4_MC_CTRL      (PGID_BASE + 3)\n#define PGID_IPV6_MC_DATA      (PGID_BASE + 4)\n#define PGID_IPV6_MC_CTRL      (PGID_BASE + 5)\n#define PGID_BCAST\t       (PGID_BASE + 6)\n#define PGID_CPU\t       (PGID_BASE + 7)\n#define PGID_MCAST_START       (PGID_BASE + 8)\n\n#define PGID_TABLE_SIZE\t       3290\n\n#define IFH_LEN                9  \n#define NULL_VID               0\n#define SPX5_MACT_PULL_DELAY   (2 * HZ)\n#define SPX5_STATS_CHECK_DELAY (1 * HZ)\n#define SPX5_PRIOS             8      \n#define SPX5_BUFFER_CELL_SZ    184    \n#define SPX5_BUFFER_MEMORY     4194280  \n\n#define XTR_QUEUE     0\n#define INJ_QUEUE     0\n\n#define FDMA_DCB_MAX\t\t\t64\n#define FDMA_RX_DCB_MAX_DBS\t\t15\n#define FDMA_TX_DCB_MAX_DBS\t\t1\n\n#define SPARX5_PHC_COUNT\t\t3\n#define SPARX5_PHC_PORT\t\t\t0\n\n#define IFH_REW_OP_NOOP\t\t\t0x0\n#define IFH_REW_OP_ONE_STEP_PTP\t\t0x3\n#define IFH_REW_OP_TWO_STEP_PTP\t\t0x4\n\n#define IFH_PDU_TYPE_NONE\t\t0x0\n#define IFH_PDU_TYPE_PTP\t\t0x5\n#define IFH_PDU_TYPE_IPV4_UDP_PTP\t0x6\n#define IFH_PDU_TYPE_IPV6_UDP_PTP\t0x7\n\nstruct sparx5;\n\nstruct sparx5_db_hw {\n\tu64 dataptr;\n\tu64 status;\n};\n\nstruct sparx5_rx_dcb_hw {\n\tu64 nextptr;\n\tu64 info;\n\tstruct sparx5_db_hw db[FDMA_RX_DCB_MAX_DBS];\n};\n\nstruct sparx5_tx_dcb_hw {\n\tu64 nextptr;\n\tu64 info;\n\tstruct sparx5_db_hw db[FDMA_TX_DCB_MAX_DBS];\n};\n\n \nstruct sparx5_rx {\n\tstruct sparx5_rx_dcb_hw *dcb_entries;\n\tstruct sparx5_rx_dcb_hw *last_entry;\n\tstruct sk_buff *skb[FDMA_DCB_MAX][FDMA_RX_DCB_MAX_DBS];\n\tint db_index;\n\tint dcb_index;\n\tdma_addr_t dma;\n\tstruct napi_struct napi;\n\tu32 channel_id;\n\tstruct net_device *ndev;\n\tu64 packets;\n};\n\n \nstruct sparx5_tx {\n\tstruct sparx5_tx_dcb_hw *curr_entry;\n\tstruct sparx5_tx_dcb_hw *first_entry;\n\tstruct list_head db_list;\n\tdma_addr_t dma;\n\tu32 channel_id;\n\tu64 packets;\n\tu64 dropped;\n};\n\nstruct sparx5_port_config {\n\tphy_interface_t portmode;\n\tu32 bandwidth;\n\tint speed;\n\tint duplex;\n\tenum phy_media media;\n\tbool inband;\n\tbool power_down;\n\tbool autoneg;\n\tbool serdes_reset;\n\tu32 pause;\n\tu32 pause_adv;\n\tphy_interface_t phy_mode;\n\tu32 sd_sgpio;\n};\n\nstruct sparx5_port {\n\tstruct net_device *ndev;\n\tstruct sparx5 *sparx5;\n\tstruct device_node *of_node;\n\tstruct phy *serdes;\n\tstruct sparx5_port_config conf;\n\tstruct phylink_config phylink_config;\n\tstruct phylink *phylink;\n\tstruct phylink_pcs phylink_pcs;\n\tu16 portno;\n\t \n\tu16 pvid;\n\t \n\tu16 vid;\n\tbool signd_internal;\n\tbool signd_active_high;\n\tbool signd_enable;\n\tbool flow_control;\n\tenum sparx5_port_max_tags max_vlan_tags;\n\tenum sparx5_vlan_port_type vlan_type;\n\tu32 custom_etype;\n\tbool vlan_aware;\n\tstruct hrtimer inj_timer;\n\t \n\tu8 ptp_cmd;\n\tu16 ts_id;\n\tstruct sk_buff_head tx_skbs;\n\tbool is_mrouter;\n\tstruct list_head tc_templates;  \n};\n\nenum sparx5_core_clockfreq {\n\tSPX5_CORE_CLOCK_DEFAULT,   \n\tSPX5_CORE_CLOCK_250MHZ,    \n\tSPX5_CORE_CLOCK_500MHZ,    \n\tSPX5_CORE_CLOCK_625MHZ,    \n};\n\nstruct sparx5_phc {\n\tstruct ptp_clock *clock;\n\tstruct ptp_clock_info info;\n\tstruct kernel_hwtstamp_config hwtstamp_config;\n\tstruct sparx5 *sparx5;\n\tu8 index;\n};\n\nstruct sparx5_skb_cb {\n\tu8 rew_op;\n\tu8 pdu_type;\n\tu8 pdu_w16_offset;\n\tu16 ts_id;\n\tunsigned long jiffies;\n};\n\nstruct sparx5_mdb_entry {\n\tstruct list_head list;\n\tDECLARE_BITMAP(port_mask, SPX5_PORTS);\n\tunsigned char addr[ETH_ALEN];\n\tbool cpu_copy;\n\tu16 vid;\n\tu16 pgid_idx;\n};\n\n#define SPARX5_PTP_TIMEOUT\t\tmsecs_to_jiffies(10)\n#define SPARX5_SKB_CB(skb) \\\n\t((struct sparx5_skb_cb *)((skb)->cb))\n\nstruct sparx5 {\n\tstruct platform_device *pdev;\n\tstruct device *dev;\n\tu32 chip_id;\n\tenum spx5_target_chiptype target_ct;\n\tvoid __iomem *regs[NUM_TARGETS];\n\tint port_count;\n\tstruct mutex lock;  \n\t \n\tstruct sparx5_port *ports[SPX5_PORTS];\n\tenum sparx5_core_clockfreq coreclock;\n\t \n\tu32 num_stats;\n\tu32 num_ethtool_stats;\n\tconst char * const *stats_layout;\n\tu64 *stats;\n\t \n\tstruct mutex queue_stats_lock;\n\tstruct delayed_work stats_work;\n\tstruct workqueue_struct *stats_queue;\n\t \n\tstruct notifier_block netdevice_nb;\n\tstruct notifier_block switchdev_nb;\n\tstruct notifier_block switchdev_blocking_nb;\n\t \n\tu8 base_mac[ETH_ALEN];\n\t \n\tstruct net_device *hw_bridge_dev;\n\t \n\tDECLARE_BITMAP(bridge_mask, SPX5_PORTS);\n\tDECLARE_BITMAP(bridge_fwd_mask, SPX5_PORTS);\n\tDECLARE_BITMAP(bridge_lrn_mask, SPX5_PORTS);\n\tDECLARE_BITMAP(vlan_mask[VLAN_N_VID], SPX5_PORTS);\n\t \n\tstruct list_head mact_entries;\n\t \n\tstruct mutex mact_lock;\n\t \n\tstruct list_head mdb_entries;\n\t \n\tstruct mutex mdb_lock;\n\tstruct delayed_work mact_work;\n\tstruct workqueue_struct *mact_queue;\n\t \n\tbool sd_sgpio_remapping;\n\t \n\tint xtr_irq;\n\t \n\tint fdma_irq;\n\tstruct sparx5_rx rx;\n\tstruct sparx5_tx tx;\n\t \n\tbool ptp;\n\tstruct sparx5_phc phc[SPARX5_PHC_COUNT];\n\tspinlock_t ptp_clock_lock;  \n\tspinlock_t ptp_ts_id_lock;  \n\tstruct mutex ptp_lock;  \n\tu16 ptp_skbs;\n\tint ptp_irq;\n\t \n\tstruct vcap_control *vcap_ctrl;\n\t \n\tu8 pgid_map[PGID_TABLE_SIZE];\n\t \n\tstruct dentry *debugfs_root;\n};\n\n \nint sparx5_register_notifier_blocks(struct sparx5 *sparx5);\nvoid sparx5_unregister_notifier_blocks(struct sparx5 *sparx5);\n\n \nstruct frame_info {\n\tint src_port;\n\tu32 timestamp;\n};\n\nvoid sparx5_xtr_flush(struct sparx5 *sparx5, u8 grp);\nvoid sparx5_ifh_parse(u32 *ifh, struct frame_info *info);\nirqreturn_t sparx5_xtr_handler(int irq, void *_priv);\nnetdev_tx_t sparx5_port_xmit_impl(struct sk_buff *skb, struct net_device *dev);\nint sparx5_manual_injection_mode(struct sparx5 *sparx5);\nvoid sparx5_port_inj_timer_setup(struct sparx5_port *port);\n\n \nint sparx5_fdma_start(struct sparx5 *sparx5);\nint sparx5_fdma_stop(struct sparx5 *sparx5);\nint sparx5_fdma_xmit(struct sparx5 *sparx5, u32 *ifh, struct sk_buff *skb);\nirqreturn_t sparx5_fdma_handler(int irq, void *args);\n\n \nvoid sparx5_mact_pull_work(struct work_struct *work);\nint sparx5_mact_learn(struct sparx5 *sparx5, int port,\n\t\t      const unsigned char mac[ETH_ALEN], u16 vid);\nbool sparx5_mact_getnext(struct sparx5 *sparx5,\n\t\t\t unsigned char mac[ETH_ALEN], u16 *vid, u32 *pcfg2);\nint sparx5_mact_find(struct sparx5 *sparx5,\n\t\t     const unsigned char mac[ETH_ALEN], u16 vid, u32 *pcfg2);\nint sparx5_mact_forget(struct sparx5 *sparx5,\n\t\t       const unsigned char mac[ETH_ALEN], u16 vid);\nint sparx5_add_mact_entry(struct sparx5 *sparx5,\n\t\t\t  struct net_device *dev,\n\t\t\t  u16 portno,\n\t\t\t  const unsigned char *addr, u16 vid);\nint sparx5_del_mact_entry(struct sparx5 *sparx5,\n\t\t\t  const unsigned char *addr,\n\t\t\t  u16 vid);\nint sparx5_mc_sync(struct net_device *dev, const unsigned char *addr);\nint sparx5_mc_unsync(struct net_device *dev, const unsigned char *addr);\nvoid sparx5_set_ageing(struct sparx5 *sparx5, int msecs);\nvoid sparx5_mact_init(struct sparx5 *sparx5);\n\n \nvoid sparx5_pgid_update_mask(struct sparx5_port *port, int pgid, bool enable);\nvoid sparx5_pgid_clear(struct sparx5 *spx5, int pgid);\nvoid sparx5_pgid_read_mask(struct sparx5 *sparx5, int pgid, u32 portmask[3]);\nvoid sparx5_update_fwd(struct sparx5 *sparx5);\nvoid sparx5_vlan_init(struct sparx5 *sparx5);\nvoid sparx5_vlan_port_setup(struct sparx5 *sparx5, int portno);\nint sparx5_vlan_vid_add(struct sparx5_port *port, u16 vid, bool pvid,\n\t\t\tbool untagged);\nint sparx5_vlan_vid_del(struct sparx5_port *port, u16 vid);\nvoid sparx5_vlan_port_apply(struct sparx5 *sparx5, struct sparx5_port *port);\n\n \nint sparx5_config_auto_calendar(struct sparx5 *sparx5);\nint sparx5_config_dsm_calendar(struct sparx5 *sparx5);\n\n \nvoid sparx5_get_stats64(struct net_device *ndev, struct rtnl_link_stats64 *stats);\nint sparx_stats_init(struct sparx5 *sparx5);\n\n \n#ifdef CONFIG_SPARX5_DCB\nint sparx5_dcb_init(struct sparx5 *sparx5);\n#else\nstatic inline int sparx5_dcb_init(struct sparx5 *sparx5)\n{\n\treturn 0;\n}\n#endif\n\n \nvoid sparx5_set_port_ifh_timestamp(void *ifh_hdr, u64 timestamp);\nvoid sparx5_set_port_ifh_rew_op(void *ifh_hdr, u32 rew_op);\nvoid sparx5_set_port_ifh_pdu_type(void *ifh_hdr, u32 pdu_type);\nvoid sparx5_set_port_ifh_pdu_w16_offset(void *ifh_hdr, u32 pdu_w16_offset);\nvoid sparx5_set_port_ifh(void *ifh_hdr, u16 portno);\nbool sparx5_netdevice_check(const struct net_device *dev);\nstruct net_device *sparx5_create_netdev(struct sparx5 *sparx5, u32 portno);\nint sparx5_register_netdevs(struct sparx5 *sparx5);\nvoid sparx5_destroy_netdevs(struct sparx5 *sparx5);\nvoid sparx5_unregister_netdevs(struct sparx5 *sparx5);\n\n \nint sparx5_ptp_init(struct sparx5 *sparx5);\nvoid sparx5_ptp_deinit(struct sparx5 *sparx5);\nint sparx5_ptp_hwtstamp_set(struct sparx5_port *port,\n\t\t\t    struct kernel_hwtstamp_config *cfg,\n\t\t\t    struct netlink_ext_ack *extack);\nvoid sparx5_ptp_hwtstamp_get(struct sparx5_port *port,\n\t\t\t     struct kernel_hwtstamp_config *cfg);\nvoid sparx5_ptp_rxtstamp(struct sparx5 *sparx5, struct sk_buff *skb,\n\t\t\t u64 timestamp);\nint sparx5_ptp_txtstamp_request(struct sparx5_port *port,\n\t\t\t\tstruct sk_buff *skb);\nvoid sparx5_ptp_txtstamp_release(struct sparx5_port *port,\n\t\t\t\t struct sk_buff *skb);\nirqreturn_t sparx5_ptp_irq_handler(int irq, void *args);\nint sparx5_ptp_gettime64(struct ptp_clock_info *ptp, struct timespec64 *ts);\n\n \nint sparx5_vcap_init(struct sparx5 *sparx5);\nvoid sparx5_vcap_destroy(struct sparx5 *sparx5);\n\n \nenum sparx5_pgid_type {\n\tSPX5_PGID_FREE,\n\tSPX5_PGID_RESERVED,\n\tSPX5_PGID_MULTICAST,\n};\n\nvoid sparx5_pgid_init(struct sparx5 *spx5);\nint sparx5_pgid_alloc_mcast(struct sparx5 *spx5, u16 *idx);\nint sparx5_pgid_free(struct sparx5 *spx5, u16 idx);\n\n \nstruct sparx5_pool_entry {\n\tu16 ref_cnt;\n\tu32 idx;  \n};\n\nu32 sparx5_pool_idx_to_id(u32 idx);\nint sparx5_pool_put(struct sparx5_pool_entry *pool, int size, u32 id);\nint sparx5_pool_get(struct sparx5_pool_entry *pool, int size, u32 *id);\nint sparx5_pool_get_with_idx(struct sparx5_pool_entry *pool, int size, u32 idx,\n\t\t\t     u32 *id);\n\n \n#define SPX5_SDLB_PUP_TOKEN_DISABLE 0x1FFF\n#define SPX5_SDLB_PUP_TOKEN_MAX (SPX5_SDLB_PUP_TOKEN_DISABLE - 1)\n#define SPX5_SDLB_GROUP_RATE_MAX 25000000000ULL\n#define SPX5_SDLB_2CYCLES_TYPE2_THRES_OFFSET 13\n#define SPX5_SDLB_CNT 4096\n#define SPX5_SDLB_GROUP_CNT 10\n#define SPX5_CLK_PER_100PS_DEFAULT 16\n\nstruct sparx5_sdlb_group {\n\tu64 max_rate;\n\tu32 min_burst;\n\tu32 frame_size;\n\tu32 pup_interval;\n\tu32 nsets;\n};\n\nextern struct sparx5_sdlb_group sdlb_groups[SPX5_SDLB_GROUP_CNT];\nint sparx5_sdlb_pup_token_get(struct sparx5 *sparx5, u32 pup_interval,\n\t\t\t      u64 rate);\n\nint sparx5_sdlb_clk_hz_get(struct sparx5 *sparx5);\nint sparx5_sdlb_group_get_by_rate(struct sparx5 *sparx5, u32 rate, u32 burst);\nint sparx5_sdlb_group_get_by_index(struct sparx5 *sparx5, u32 idx, u32 *group);\n\nint sparx5_sdlb_group_add(struct sparx5 *sparx5, u32 group, u32 idx);\nint sparx5_sdlb_group_del(struct sparx5 *sparx5, u32 group, u32 idx);\n\nvoid sparx5_sdlb_group_init(struct sparx5 *sparx5, u64 max_rate, u32 min_burst,\n\t\t\t    u32 frame_size, u32 idx);\n\n \nenum {\n\t \n\tSPX5_POL_SERVICE\n};\n\nstruct sparx5_policer {\n\tu32 type;\n\tu32 idx;\n\tu64 rate;\n\tu32 burst;\n\tu32 group;\n\tu8 event_mask;\n};\n\nint sparx5_policer_conf_set(struct sparx5 *sparx5, struct sparx5_policer *pol);\n\n \n#define SPX5_PSFP_GCE_CNT 4\n#define SPX5_PSFP_SG_CNT 1024\n#define SPX5_PSFP_SG_MIN_CYCLE_TIME_NS (1 * NSEC_PER_USEC)\n#define SPX5_PSFP_SG_MAX_CYCLE_TIME_NS ((1 * NSEC_PER_SEC) - 1)\n#define SPX5_PSFP_SG_MAX_IPV (SPX5_PRIOS - 1)\n#define SPX5_PSFP_SG_OPEN (SPX5_PSFP_SG_CNT - 1)\n#define SPX5_PSFP_SG_CYCLE_TIME_DEFAULT 1000000\n#define SPX5_PSFP_SF_MAX_SDU 16383\n\nstruct sparx5_psfp_fm {\n\tstruct sparx5_policer pol;\n};\n\nstruct sparx5_psfp_gce {\n\tbool gate_state;             \n\tu32 interval;                \n\tu32 ipv;                     \n\tu32 maxoctets;               \n};\n\nstruct sparx5_psfp_sg {\n\tbool gate_state;             \n\tbool gate_enabled;           \n\tu32 ipv;                     \n\tstruct timespec64 basetime;  \n\tu32 cycletime;               \n\tu32 cycletimeext;            \n\tu32 num_entries;             \n\tstruct sparx5_psfp_gce gce[SPX5_PSFP_GCE_CNT];\n};\n\nstruct sparx5_psfp_sf {\n\tbool sblock_osize_ena;\n\tbool sblock_osize;\n\tu32 max_sdu;\n\tu32 sgid;  \n\tu32 fmid;  \n};\n\nint sparx5_psfp_fm_add(struct sparx5 *sparx5, u32 uidx,\n\t\t       struct sparx5_psfp_fm *fm, u32 *id);\nint sparx5_psfp_fm_del(struct sparx5 *sparx5, u32 id);\n\nint sparx5_psfp_sg_add(struct sparx5 *sparx5, u32 uidx,\n\t\t       struct sparx5_psfp_sg *sg, u32 *id);\nint sparx5_psfp_sg_del(struct sparx5 *sparx5, u32 id);\n\nint sparx5_psfp_sf_add(struct sparx5 *sparx5, const struct sparx5_psfp_sf *sf,\n\t\t       u32 *id);\nint sparx5_psfp_sf_del(struct sparx5 *sparx5, u32 id);\n\nu32 sparx5_psfp_isdx_get_sf(struct sparx5 *sparx5, u32 isdx);\nu32 sparx5_psfp_isdx_get_fm(struct sparx5 *sparx5, u32 isdx);\nu32 sparx5_psfp_sf_get_sg(struct sparx5 *sparx5, u32 sfid);\nvoid sparx5_isdx_conf_set(struct sparx5 *sparx5, u32 isdx, u32 sfid, u32 fmid);\n\nvoid sparx5_psfp_init(struct sparx5 *sparx5);\n\n \nvoid sparx5_new_base_time(struct sparx5 *sparx5, const u32 cycle_time,\n\t\t\t  const ktime_t org_base_time, ktime_t *new_base_time);\n\n \nstatic inline u32 sparx5_clk_period(enum sparx5_core_clockfreq cclock)\n{\n\tswitch (cclock) {\n\tcase SPX5_CORE_CLOCK_250MHZ:\n\t\treturn 4000;\n\tcase SPX5_CORE_CLOCK_500MHZ:\n\t\treturn 2000;\n\tcase SPX5_CORE_CLOCK_625MHZ:\n\tdefault:\n\t\treturn 1600;\n\t}\n}\n\nstatic inline bool sparx5_is_baser(phy_interface_t interface)\n{\n\treturn interface == PHY_INTERFACE_MODE_5GBASER ||\n\t\t   interface == PHY_INTERFACE_MODE_10GBASER ||\n\t\t   interface == PHY_INTERFACE_MODE_25GBASER;\n}\n\nextern const struct phylink_mac_ops sparx5_phylink_mac_ops;\nextern const struct phylink_pcs_ops sparx5_phylink_pcs_ops;\nextern const struct ethtool_ops sparx5_ethtool_ops;\nextern const struct dcbnl_rtnl_ops sparx5_dcbnl_ops;\n\n \nstatic inline __pure int spx5_offset(int id, int tinst, int tcnt,\n\t\t\t\t     int gbase, int ginst,\n\t\t\t\t     int gcnt, int gwidth,\n\t\t\t\t     int raddr, int rinst,\n\t\t\t\t     int rcnt, int rwidth)\n{\n\tWARN_ON((tinst) >= tcnt);\n\tWARN_ON((ginst) >= gcnt);\n\tWARN_ON((rinst) >= rcnt);\n\treturn gbase + ((ginst) * gwidth) +\n\t\traddr + ((rinst) * rwidth);\n}\n\n \nstatic inline void __iomem *spx5_addr(void __iomem *base[],\n\t\t\t\t      int id, int tinst, int tcnt,\n\t\t\t\t      int gbase, int ginst,\n\t\t\t\t      int gcnt, int gwidth,\n\t\t\t\t      int raddr, int rinst,\n\t\t\t\t      int rcnt, int rwidth)\n{\n\tWARN_ON((tinst) >= tcnt);\n\tWARN_ON((ginst) >= gcnt);\n\tWARN_ON((rinst) >= rcnt);\n\treturn base[id + (tinst)] +\n\t\tgbase + ((ginst) * gwidth) +\n\t\traddr + ((rinst) * rwidth);\n}\n\nstatic inline void __iomem *spx5_inst_addr(void __iomem *base,\n\t\t\t\t\t   int gbase, int ginst,\n\t\t\t\t\t   int gcnt, int gwidth,\n\t\t\t\t\t   int raddr, int rinst,\n\t\t\t\t\t   int rcnt, int rwidth)\n{\n\tWARN_ON((ginst) >= gcnt);\n\tWARN_ON((rinst) >= rcnt);\n\treturn base +\n\t\tgbase + ((ginst) * gwidth) +\n\t\traddr + ((rinst) * rwidth);\n}\n\nstatic inline u32 spx5_rd(struct sparx5 *sparx5, int id, int tinst, int tcnt,\n\t\t\t  int gbase, int ginst, int gcnt, int gwidth,\n\t\t\t  int raddr, int rinst, int rcnt, int rwidth)\n{\n\treturn readl(spx5_addr(sparx5->regs, id, tinst, tcnt, gbase, ginst,\n\t\t\t       gcnt, gwidth, raddr, rinst, rcnt, rwidth));\n}\n\nstatic inline u32 spx5_inst_rd(void __iomem *iomem, int id, int tinst, int tcnt,\n\t\t\t       int gbase, int ginst, int gcnt, int gwidth,\n\t\t\t       int raddr, int rinst, int rcnt, int rwidth)\n{\n\treturn readl(spx5_inst_addr(iomem, gbase, ginst,\n\t\t\t\t     gcnt, gwidth, raddr, rinst, rcnt, rwidth));\n}\n\nstatic inline void spx5_wr(u32 val, struct sparx5 *sparx5,\n\t\t\t   int id, int tinst, int tcnt,\n\t\t\t   int gbase, int ginst, int gcnt, int gwidth,\n\t\t\t   int raddr, int rinst, int rcnt, int rwidth)\n{\n\twritel(val, spx5_addr(sparx5->regs, id, tinst, tcnt,\n\t\t\t      gbase, ginst, gcnt, gwidth,\n\t\t\t      raddr, rinst, rcnt, rwidth));\n}\n\nstatic inline void spx5_inst_wr(u32 val, void __iomem *iomem,\n\t\t\t\tint id, int tinst, int tcnt,\n\t\t\t\tint gbase, int ginst, int gcnt, int gwidth,\n\t\t\t\tint raddr, int rinst, int rcnt, int rwidth)\n{\n\twritel(val, spx5_inst_addr(iomem,\n\t\t\t\t   gbase, ginst, gcnt, gwidth,\n\t\t\t\t   raddr, rinst, rcnt, rwidth));\n}\n\nstatic inline void spx5_rmw(u32 val, u32 mask, struct sparx5 *sparx5,\n\t\t\t    int id, int tinst, int tcnt,\n\t\t\t    int gbase, int ginst, int gcnt, int gwidth,\n\t\t\t    int raddr, int rinst, int rcnt, int rwidth)\n{\n\tu32 nval;\n\n\tnval = readl(spx5_addr(sparx5->regs, id, tinst, tcnt, gbase, ginst,\n\t\t\t       gcnt, gwidth, raddr, rinst, rcnt, rwidth));\n\tnval = (nval & ~mask) | (val & mask);\n\twritel(nval, spx5_addr(sparx5->regs, id, tinst, tcnt, gbase, ginst,\n\t\t\t       gcnt, gwidth, raddr, rinst, rcnt, rwidth));\n}\n\nstatic inline void spx5_inst_rmw(u32 val, u32 mask, void __iomem *iomem,\n\t\t\t\t int id, int tinst, int tcnt,\n\t\t\t\t int gbase, int ginst, int gcnt, int gwidth,\n\t\t\t\t int raddr, int rinst, int rcnt, int rwidth)\n{\n\tu32 nval;\n\n\tnval = readl(spx5_inst_addr(iomem, gbase, ginst, gcnt, gwidth, raddr,\n\t\t\t\t    rinst, rcnt, rwidth));\n\tnval = (nval & ~mask) | (val & mask);\n\twritel(nval, spx5_inst_addr(iomem, gbase, ginst, gcnt, gwidth, raddr,\n\t\t\t\t    rinst, rcnt, rwidth));\n}\n\nstatic inline void __iomem *spx5_inst_get(struct sparx5 *sparx5, int id, int tinst)\n{\n\treturn sparx5->regs[id + tinst];\n}\n\nstatic inline void __iomem *spx5_reg_get(struct sparx5 *sparx5,\n\t\t\t\t\t int id, int tinst, int tcnt,\n\t\t\t\t\t int gbase, int ginst, int gcnt, int gwidth,\n\t\t\t\t\t int raddr, int rinst, int rcnt, int rwidth)\n{\n\treturn spx5_addr(sparx5->regs, id, tinst, tcnt,\n\t\t\t gbase, ginst, gcnt, gwidth,\n\t\t\t raddr, rinst, rcnt, rwidth);\n}\n\n#endif\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}