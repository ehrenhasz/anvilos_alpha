{
  "module_name": "sparx5_calendar.c",
  "hash_id": "9c5ccc39e3759de476a4d5c9da58bef5ffcb34acc1df111e43c49a3a082d5f5a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/microchip/sparx5/sparx5_calendar.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/device.h>\n\n#include \"sparx5_main_regs.h\"\n#include \"sparx5_main.h\"\n\n \n#define SPX5_PORTS_PER_CALREG          10   \n#define SPX5_CALBITS_PER_PORT          3    \n\n \n#define SPX5_DSM_CAL_LEN               64\n#define SPX5_DSM_CAL_EMPTY             0xFFFF\n#define SPX5_DSM_CAL_MAX_DEVS_PER_TAXI 13\n#define SPX5_DSM_CAL_TAXIS             8\n#define SPX5_DSM_CAL_BW_LOSS           553\n\n#define SPX5_TAXI_PORT_MAX             70\n\n#define SPEED_12500                    12500\n\n \nstatic u32 sparx5_taxi_ports[SPX5_DSM_CAL_TAXIS][SPX5_DSM_CAL_MAX_DEVS_PER_TAXI] = {\n\t{57, 12, 0, 1, 2, 16, 17, 18, 19, 20, 21, 22, 23},\n\t{58, 13, 3, 4, 5, 24, 25, 26, 27, 28, 29, 30, 31},\n\t{59, 14, 6, 7, 8, 32, 33, 34, 35, 36, 37, 38, 39},\n\t{60, 15, 9, 10, 11, 40, 41, 42, 43, 44, 45, 46, 47},\n\t{61, 48, 49, 50, 99, 99, 99, 99, 99, 99, 99, 99, 99},\n\t{62, 51, 52, 53, 99, 99, 99, 99, 99, 99, 99, 99, 99},\n\t{56, 63, 54, 55, 99, 99, 99, 99, 99, 99, 99, 99, 99},\n\t{64, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99},\n};\n\nstruct sparx5_calendar_data {\n\tu32 schedule[SPX5_DSM_CAL_LEN];\n\tu32 avg_dist[SPX5_DSM_CAL_MAX_DEVS_PER_TAXI];\n\tu32 taxi_ports[SPX5_DSM_CAL_MAX_DEVS_PER_TAXI];\n\tu32 taxi_speeds[SPX5_DSM_CAL_MAX_DEVS_PER_TAXI];\n\tu32 dev_slots[SPX5_DSM_CAL_MAX_DEVS_PER_TAXI];\n\tu32 new_slots[SPX5_DSM_CAL_LEN];\n\tu32 temp_sched[SPX5_DSM_CAL_LEN];\n\tu32 indices[SPX5_DSM_CAL_LEN];\n\tu32 short_list[SPX5_DSM_CAL_LEN];\n\tu32 long_list[SPX5_DSM_CAL_LEN];\n};\n\nstatic u32 sparx5_target_bandwidth(struct sparx5 *sparx5)\n{\n\tswitch (sparx5->target_ct) {\n\tcase SPX5_TARGET_CT_7546:\n\tcase SPX5_TARGET_CT_7546TSN:\n\t\treturn 65000;\n\tcase SPX5_TARGET_CT_7549:\n\tcase SPX5_TARGET_CT_7549TSN:\n\t\treturn 91000;\n\tcase SPX5_TARGET_CT_7552:\n\tcase SPX5_TARGET_CT_7552TSN:\n\t\treturn 129000;\n\tcase SPX5_TARGET_CT_7556:\n\tcase SPX5_TARGET_CT_7556TSN:\n\t\treturn 161000;\n\tcase SPX5_TARGET_CT_7558:\n\tcase SPX5_TARGET_CT_7558TSN:\n\t\treturn 201000;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\n \nenum sparx5_cal_bw {\n\tSPX5_CAL_SPEED_NONE = 0,\n\tSPX5_CAL_SPEED_1G   = 1,\n\tSPX5_CAL_SPEED_2G5  = 2,\n\tSPX5_CAL_SPEED_5G   = 3,\n\tSPX5_CAL_SPEED_10G  = 4,\n\tSPX5_CAL_SPEED_25G  = 5,\n\tSPX5_CAL_SPEED_0G5  = 6,\n\tSPX5_CAL_SPEED_12G5 = 7\n};\n\nstatic u32 sparx5_clk_to_bandwidth(enum sparx5_core_clockfreq cclock)\n{\n\tswitch (cclock) {\n\tcase SPX5_CORE_CLOCK_250MHZ: return 83000;  \n\tcase SPX5_CORE_CLOCK_500MHZ: return 166000;  \n\tcase SPX5_CORE_CLOCK_625MHZ: return  208000;  \n\tdefault: return 0;\n\t}\n\treturn 0;\n}\n\nstatic u32 sparx5_cal_speed_to_value(enum sparx5_cal_bw speed)\n{\n\tswitch (speed) {\n\tcase SPX5_CAL_SPEED_1G:   return 1000;\n\tcase SPX5_CAL_SPEED_2G5:  return 2500;\n\tcase SPX5_CAL_SPEED_5G:   return 5000;\n\tcase SPX5_CAL_SPEED_10G:  return 10000;\n\tcase SPX5_CAL_SPEED_25G:  return 25000;\n\tcase SPX5_CAL_SPEED_0G5:  return 500;\n\tcase SPX5_CAL_SPEED_12G5: return 12500;\n\tdefault: return 0;\n\t}\n}\n\nstatic u32 sparx5_bandwidth_to_calendar(u32 bw)\n{\n\tswitch (bw) {\n\tcase SPEED_10:      return SPX5_CAL_SPEED_0G5;\n\tcase SPEED_100:     return SPX5_CAL_SPEED_0G5;\n\tcase SPEED_1000:    return SPX5_CAL_SPEED_1G;\n\tcase SPEED_2500:    return SPX5_CAL_SPEED_2G5;\n\tcase SPEED_5000:    return SPX5_CAL_SPEED_5G;\n\tcase SPEED_10000:   return SPX5_CAL_SPEED_10G;\n\tcase SPEED_12500:   return SPX5_CAL_SPEED_12G5;\n\tcase SPEED_25000:   return SPX5_CAL_SPEED_25G;\n\tcase SPEED_UNKNOWN: return SPX5_CAL_SPEED_1G;\n\tdefault:            return SPX5_CAL_SPEED_NONE;\n\t}\n}\n\nstatic enum sparx5_cal_bw sparx5_get_port_cal_speed(struct sparx5 *sparx5,\n\t\t\t\t\t\t    u32 portno)\n{\n\tstruct sparx5_port *port;\n\n\tif (portno >= SPX5_PORTS) {\n\t\t \n\t\tif (portno == SPX5_PORT_CPU_0 || portno == SPX5_PORT_CPU_1) {\n\t\t\t \n\t\t\treturn SPX5_CAL_SPEED_2G5;\n\t\t} else if (portno == SPX5_PORT_VD0) {\n\t\t\t \n\t\t\treturn SPX5_CAL_SPEED_NONE;\n\t\t} else if (portno == SPX5_PORT_VD1) {\n\t\t\t \n\t\t\treturn SPX5_CAL_SPEED_NONE;\n\t\t} else if (portno == SPX5_PORT_VD2) {\n\t\t\t \n\t\t\treturn SPX5_CAL_SPEED_NONE;\n\t\t}\n\t\t \n\t\treturn SPX5_CAL_SPEED_NONE;\n\t}\n\t \n\tport = sparx5->ports[portno];\n\tif (!port)\n\t\treturn SPX5_CAL_SPEED_NONE;\n\treturn sparx5_bandwidth_to_calendar(port->conf.bandwidth);\n}\n\n \nint sparx5_config_auto_calendar(struct sparx5 *sparx5)\n{\n\tu32 cal[7], value, idx, portno;\n\tu32 max_core_bw;\n\tu32 total_bw = 0, used_port_bw = 0;\n\tint err = 0;\n\tenum sparx5_cal_bw spd;\n\n\tmemset(cal, 0, sizeof(cal));\n\n\tmax_core_bw = sparx5_clk_to_bandwidth(sparx5->coreclock);\n\tif (max_core_bw == 0) {\n\t\tdev_err(sparx5->dev, \"Core clock not supported\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tfor (portno = 0; portno < SPX5_PORTS_ALL; portno++) {\n\t\tu64 reg, offset, this_bw;\n\n\t\tspd = sparx5_get_port_cal_speed(sparx5, portno);\n\t\tif (spd == SPX5_CAL_SPEED_NONE)\n\t\t\tcontinue;\n\n\t\tthis_bw = sparx5_cal_speed_to_value(spd);\n\t\tif (portno < SPX5_PORTS)\n\t\t\tused_port_bw += this_bw;\n\t\telse\n\t\t\t \n\t\t\tthis_bw = this_bw / 2;\n\t\ttotal_bw += this_bw;\n\t\treg = portno;\n\t\toffset = do_div(reg, SPX5_PORTS_PER_CALREG);\n\t\tcal[reg] |= spd << (offset * SPX5_CALBITS_PER_PORT);\n\t}\n\n\tif (used_port_bw > sparx5_target_bandwidth(sparx5)) {\n\t\tdev_err(sparx5->dev,\n\t\t\t\"Port BW %u above target BW %u\\n\",\n\t\t\tused_port_bw, sparx5_target_bandwidth(sparx5));\n\t\treturn -EINVAL;\n\t}\n\n\tif (total_bw > max_core_bw) {\n\t\tdev_err(sparx5->dev,\n\t\t\t\"Total BW %u above switch core BW %u\\n\",\n\t\t\ttotal_bw, max_core_bw);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tspx5_rmw(QSYS_CAL_CTRL_CAL_MODE_SET(10),\n\t\t QSYS_CAL_CTRL_CAL_MODE,\n\t\t sparx5, QSYS_CAL_CTRL);\n\n\t \n\tfor (idx = 0; idx < ARRAY_SIZE(cal); idx++)\n\t\tspx5_wr(cal[idx], sparx5, QSYS_CAL_AUTO(idx));\n\n\t \n\tspx5_rmw(QSYS_CAL_CTRL_CAL_AUTO_GRANT_RATE_SET(671),  \n\t\t QSYS_CAL_CTRL_CAL_AUTO_GRANT_RATE,\n\t\t sparx5,\n\t\t QSYS_CAL_CTRL);\n\n\t \n\tfor (idx = 2; idx < 5; idx++)\n\t\tspx5_wr(HSCH_OUTB_SHARE_ENA_OUTB_SHARE_ENA_SET(12),\n\t\t\tsparx5,\n\t\t\tHSCH_OUTB_SHARE_ENA(idx));\n\n\t \n\tspx5_rmw(QSYS_CAL_CTRL_CAL_MODE_SET(8),\n\t\t QSYS_CAL_CTRL_CAL_MODE,\n\t\t sparx5, QSYS_CAL_CTRL);\n\n\t \n\tvalue = spx5_rd(sparx5, QSYS_CAL_CTRL);\n\tif (QSYS_CAL_CTRL_CAL_AUTO_ERROR_GET(value)) {\n\t\tdev_err(sparx5->dev, \"QSYS calendar error\\n\");\n\t\terr = -EINVAL;\n\t}\n\treturn err;\n}\n\nstatic u32 sparx5_dsm_exb_gcd(u32 a, u32 b)\n{\n\tif (b == 0)\n\t\treturn a;\n\treturn sparx5_dsm_exb_gcd(b, a % b);\n}\n\nstatic u32 sparx5_dsm_cal_len(u32 *cal)\n{\n\tu32 idx = 0, len = 0;\n\n\twhile (idx < SPX5_DSM_CAL_LEN) {\n\t\tif (cal[idx] != SPX5_DSM_CAL_EMPTY)\n\t\t\tlen++;\n\t\tidx++;\n\t}\n\treturn len;\n}\n\nstatic u32 sparx5_dsm_cp_cal(u32 *sched)\n{\n\tu32 idx = 0, tmp;\n\n\twhile (idx < SPX5_DSM_CAL_LEN) {\n\t\tif (sched[idx] != SPX5_DSM_CAL_EMPTY) {\n\t\t\ttmp = sched[idx];\n\t\t\tsched[idx] = SPX5_DSM_CAL_EMPTY;\n\t\t\treturn tmp;\n\t\t}\n\t\tidx++;\n\t}\n\treturn SPX5_DSM_CAL_EMPTY;\n}\n\nstatic int sparx5_dsm_calendar_calc(struct sparx5 *sparx5, u32 taxi,\n\t\t\t\t    struct sparx5_calendar_data *data)\n{\n\tbool slow_mode;\n\tu32 gcd, idx, sum, min, factor;\n\tu32 num_of_slots, slot_spd, empty_slots;\n\tu32 taxi_bw, clk_period_ps;\n\n\tclk_period_ps = sparx5_clk_period(sparx5->coreclock);\n\ttaxi_bw = 128 * 1000000 / clk_period_ps;\n\tslow_mode = !!(clk_period_ps > 2000);\n\tmemcpy(data->taxi_ports, &sparx5_taxi_ports[taxi],\n\t       sizeof(data->taxi_ports));\n\n\tfor (idx = 0; idx < SPX5_DSM_CAL_LEN; idx++) {\n\t\tdata->new_slots[idx] = SPX5_DSM_CAL_EMPTY;\n\t\tdata->schedule[idx] = SPX5_DSM_CAL_EMPTY;\n\t\tdata->temp_sched[idx] = SPX5_DSM_CAL_EMPTY;\n\t}\n\t \n\tdata->schedule[0] = SPX5_DSM_CAL_MAX_DEVS_PER_TAXI;\n\n\t \n\tfor (idx = 0; idx < SPX5_DSM_CAL_MAX_DEVS_PER_TAXI; idx++) {\n\t\tu32 portno = data->taxi_ports[idx];\n\n\t\tif (portno < SPX5_TAXI_PORT_MAX) {\n\t\t\tdata->taxi_speeds[idx] = sparx5_cal_speed_to_value\n\t\t\t\t(sparx5_get_port_cal_speed(sparx5, portno));\n\t\t} else {\n\t\t\tdata->taxi_speeds[idx] = 0;\n\t\t}\n\t}\n\n\tsum = 0;\n\tmin = 25000;\n\tfor (idx = 0; idx < ARRAY_SIZE(data->taxi_speeds); idx++) {\n\t\tu32 jdx;\n\n\t\tsum += data->taxi_speeds[idx];\n\t\tif (data->taxi_speeds[idx] && data->taxi_speeds[idx] < min)\n\t\t\tmin = data->taxi_speeds[idx];\n\t\tgcd = min;\n\t\tfor (jdx = 0; jdx < ARRAY_SIZE(data->taxi_speeds); jdx++)\n\t\t\tgcd = sparx5_dsm_exb_gcd(gcd, data->taxi_speeds[jdx]);\n\t}\n\tif (sum == 0)  \n\t\treturn 0;\n\t \n\tfactor = 100 * 100 * 1000 / (100 * 100 - SPX5_DSM_CAL_BW_LOSS);\n\n\tif (sum * factor > (taxi_bw * 1000)) {\n\t\tdev_err(sparx5->dev,\n\t\t\t\"Taxi %u, Requested BW %u above available BW %u\\n\",\n\t\t\ttaxi, sum, taxi_bw);\n\t\treturn -EINVAL;\n\t}\n\tfor (idx = 0; idx < 4; idx++) {\n\t\tu32 raw_spd;\n\n\t\tif (idx == 0)\n\t\t\traw_spd = gcd / 5;\n\t\telse if (idx == 1)\n\t\t\traw_spd = gcd / 2;\n\t\telse if (idx == 2)\n\t\t\traw_spd = gcd;\n\t\telse\n\t\t\traw_spd = min;\n\t\tslot_spd = raw_spd * factor / 1000;\n\t\tnum_of_slots = taxi_bw / slot_spd;\n\t\tif (num_of_slots <= 64)\n\t\t\tbreak;\n\t}\n\n\tnum_of_slots = num_of_slots > 64 ? 64 : num_of_slots;\n\tslot_spd = taxi_bw / num_of_slots;\n\n\tsum = 0;\n\tfor (idx = 0; idx < ARRAY_SIZE(data->taxi_speeds); idx++) {\n\t\tu32 spd = data->taxi_speeds[idx];\n\t\tu32 adjusted_speed = data->taxi_speeds[idx] * factor / 1000;\n\n\t\tif (adjusted_speed > 0) {\n\t\t\tdata->avg_dist[idx] = (128 * 1000000 * 10) /\n\t\t\t\t(adjusted_speed * clk_period_ps);\n\t\t} else {\n\t\t\tdata->avg_dist[idx] = -1;\n\t\t}\n\t\tdata->dev_slots[idx] = ((spd * factor / slot_spd) + 999) / 1000;\n\t\tif (spd != 25000 && (spd != 10000 || !slow_mode)) {\n\t\t\tif (num_of_slots < (5 * data->dev_slots[idx])) {\n\t\t\t\tdev_err(sparx5->dev,\n\t\t\t\t\t\"Taxi %u, speed %u, Low slot sep.\\n\",\n\t\t\t\t\ttaxi, spd);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t\tsum += data->dev_slots[idx];\n\t\tif (sum > num_of_slots) {\n\t\t\tdev_err(sparx5->dev,\n\t\t\t\t\"Taxi %u with overhead factor %u\\n\",\n\t\t\t\ttaxi, factor);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tempty_slots = num_of_slots - sum;\n\n\tfor (idx = 0; idx < empty_slots; idx++)\n\t\tdata->schedule[idx] = SPX5_DSM_CAL_MAX_DEVS_PER_TAXI;\n\n\tfor (idx = 1; idx < num_of_slots; idx++) {\n\t\tu32 indices_len = 0;\n\t\tu32 slot, jdx, kdx, ts;\n\t\ts32 cnt;\n\t\tu32 num_of_old_slots, num_of_new_slots, tgt_score;\n\n\t\tfor (slot = 0; slot < ARRAY_SIZE(data->dev_slots); slot++) {\n\t\t\tif (data->dev_slots[slot] == idx) {\n\t\t\t\tdata->indices[indices_len] = slot;\n\t\t\t\tindices_len++;\n\t\t\t}\n\t\t}\n\t\tif (indices_len == 0)\n\t\t\tcontinue;\n\t\tkdx = 0;\n\t\tfor (slot = 0; slot < idx; slot++) {\n\t\t\tfor (jdx = 0; jdx < indices_len; jdx++, kdx++)\n\t\t\t\tdata->new_slots[kdx] = data->indices[jdx];\n\t\t}\n\n\t\tfor (slot = 0; slot < SPX5_DSM_CAL_LEN; slot++) {\n\t\t\tif (data->schedule[slot] == SPX5_DSM_CAL_EMPTY)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tnum_of_old_slots =  slot;\n\t\tnum_of_new_slots =  kdx;\n\t\tcnt = 0;\n\t\tts = 0;\n\n\t\tif (num_of_new_slots > num_of_old_slots) {\n\t\t\tmemcpy(data->short_list, data->schedule,\n\t\t\t       sizeof(data->short_list));\n\t\t\tmemcpy(data->long_list, data->new_slots,\n\t\t\t       sizeof(data->long_list));\n\t\t\ttgt_score = 100000 * num_of_old_slots /\n\t\t\t\tnum_of_new_slots;\n\t\t} else {\n\t\t\tmemcpy(data->short_list, data->new_slots,\n\t\t\t       sizeof(data->short_list));\n\t\t\tmemcpy(data->long_list, data->schedule,\n\t\t\t       sizeof(data->long_list));\n\t\t\ttgt_score = 100000 * num_of_new_slots /\n\t\t\t\tnum_of_old_slots;\n\t\t}\n\n\t\twhile (sparx5_dsm_cal_len(data->short_list) > 0 ||\n\t\t       sparx5_dsm_cal_len(data->long_list) > 0) {\n\t\t\tu32 act = 0;\n\n\t\t\tif (sparx5_dsm_cal_len(data->short_list) > 0) {\n\t\t\t\tdata->temp_sched[ts] =\n\t\t\t\t\tsparx5_dsm_cp_cal(data->short_list);\n\t\t\t\tts++;\n\t\t\t\tcnt += 100000;\n\t\t\t\tact = 1;\n\t\t\t}\n\t\t\twhile (sparx5_dsm_cal_len(data->long_list) > 0 &&\n\t\t\t       cnt > 0) {\n\t\t\t\tdata->temp_sched[ts] =\n\t\t\t\t\tsparx5_dsm_cp_cal(data->long_list);\n\t\t\t\tts++;\n\t\t\t\tcnt -= tgt_score;\n\t\t\t\tact = 1;\n\t\t\t}\n\t\t\tif (act == 0) {\n\t\t\t\tdev_err(sparx5->dev,\n\t\t\t\t\t\"Error in DSM calendar calculation\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\tfor (slot = 0; slot < SPX5_DSM_CAL_LEN; slot++) {\n\t\t\tif (data->temp_sched[slot] == SPX5_DSM_CAL_EMPTY)\n\t\t\t\tbreak;\n\t\t}\n\t\tfor (slot = 0; slot < SPX5_DSM_CAL_LEN; slot++) {\n\t\t\tdata->schedule[slot] = data->temp_sched[slot];\n\t\t\tdata->temp_sched[slot] = SPX5_DSM_CAL_EMPTY;\n\t\t\tdata->new_slots[slot] = SPX5_DSM_CAL_EMPTY;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int sparx5_dsm_calendar_check(struct sparx5 *sparx5,\n\t\t\t\t     struct sparx5_calendar_data *data)\n{\n\tu32 num_of_slots, idx, port;\n\tint cnt, max_dist;\n\tu32 slot_indices[SPX5_DSM_CAL_LEN], distances[SPX5_DSM_CAL_LEN];\n\tu32 cal_length = sparx5_dsm_cal_len(data->schedule);\n\n\tfor (port = 0; port < SPX5_DSM_CAL_MAX_DEVS_PER_TAXI; port++) {\n\t\tnum_of_slots = 0;\n\t\tmax_dist = data->avg_dist[port];\n\t\tfor (idx = 0; idx < SPX5_DSM_CAL_LEN; idx++) {\n\t\t\tslot_indices[idx] = SPX5_DSM_CAL_EMPTY;\n\t\t\tdistances[idx] = SPX5_DSM_CAL_EMPTY;\n\t\t}\n\n\t\tfor (idx = 0; idx < cal_length; idx++) {\n\t\t\tif (data->schedule[idx] == port) {\n\t\t\t\tslot_indices[num_of_slots] = idx;\n\t\t\t\tnum_of_slots++;\n\t\t\t}\n\t\t}\n\n\t\tslot_indices[num_of_slots] = slot_indices[0] + cal_length;\n\n\t\tfor (idx = 0; idx < num_of_slots; idx++) {\n\t\t\tdistances[idx] = (slot_indices[idx + 1] -\n\t\t\t\t\t  slot_indices[idx]) * 10;\n\t\t}\n\n\t\tfor (idx = 0; idx < num_of_slots; idx++) {\n\t\t\tu32 jdx, kdx;\n\n\t\t\tcnt = distances[idx] - max_dist;\n\t\t\tif (cnt < 0)\n\t\t\t\tcnt = -cnt;\n\t\t\tkdx = 0;\n\t\t\tfor (jdx = (idx + 1) % num_of_slots;\n\t\t\t     jdx != idx;\n\t\t\t     jdx = (jdx + 1) % num_of_slots, kdx++) {\n\t\t\t\tcnt =  cnt + distances[jdx] - max_dist;\n\t\t\t\tif (cnt < 0)\n\t\t\t\t\tcnt = -cnt;\n\t\t\t\tif (cnt > max_dist)\n\t\t\t\t\tgoto check_err;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\ncheck_err:\n\tdev_err(sparx5->dev,\n\t\t\"Port %u: distance %u above limit %d\\n\",\n\t\tport, cnt, max_dist);\n\treturn -EINVAL;\n}\n\nstatic int sparx5_dsm_calendar_update(struct sparx5 *sparx5, u32 taxi,\n\t\t\t\t      struct sparx5_calendar_data *data)\n{\n\tu32 idx;\n\tu32 cal_len = sparx5_dsm_cal_len(data->schedule), len;\n\n\tspx5_wr(DSM_TAXI_CAL_CFG_CAL_PGM_ENA_SET(1),\n\t\tsparx5,\n\t\tDSM_TAXI_CAL_CFG(taxi));\n\tfor (idx = 0; idx < cal_len; idx++) {\n\t\tspx5_rmw(DSM_TAXI_CAL_CFG_CAL_IDX_SET(idx),\n\t\t\t DSM_TAXI_CAL_CFG_CAL_IDX,\n\t\t\t sparx5,\n\t\t\t DSM_TAXI_CAL_CFG(taxi));\n\t\tspx5_rmw(DSM_TAXI_CAL_CFG_CAL_PGM_VAL_SET(data->schedule[idx]),\n\t\t\t DSM_TAXI_CAL_CFG_CAL_PGM_VAL,\n\t\t\t sparx5,\n\t\t\t DSM_TAXI_CAL_CFG(taxi));\n\t}\n\tspx5_wr(DSM_TAXI_CAL_CFG_CAL_PGM_ENA_SET(0),\n\t\tsparx5,\n\t\tDSM_TAXI_CAL_CFG(taxi));\n\tlen = DSM_TAXI_CAL_CFG_CAL_CUR_LEN_GET(spx5_rd(sparx5,\n\t\t\t\t\t\t       DSM_TAXI_CAL_CFG(taxi)));\n\tif (len != cal_len - 1)\n\t\tgoto update_err;\n\treturn 0;\nupdate_err:\n\tdev_err(sparx5->dev, \"Incorrect calendar length: %u\\n\", len);\n\treturn -EINVAL;\n}\n\n \nint sparx5_config_dsm_calendar(struct sparx5 *sparx5)\n{\n\tint taxi;\n\tstruct sparx5_calendar_data *data;\n\tint err = 0;\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tfor (taxi = 0; taxi < SPX5_DSM_CAL_TAXIS; ++taxi) {\n\t\terr = sparx5_dsm_calendar_calc(sparx5, taxi, data);\n\t\tif (err) {\n\t\t\tdev_err(sparx5->dev, \"DSM calendar calculation failed\\n\");\n\t\t\tgoto cal_out;\n\t\t}\n\t\terr = sparx5_dsm_calendar_check(sparx5, data);\n\t\tif (err) {\n\t\t\tdev_err(sparx5->dev, \"DSM calendar check failed\\n\");\n\t\t\tgoto cal_out;\n\t\t}\n\t\terr = sparx5_dsm_calendar_update(sparx5, taxi, data);\n\t\tif (err) {\n\t\t\tdev_err(sparx5->dev, \"DSM calendar update failed\\n\");\n\t\t\tgoto cal_out;\n\t\t}\n\t}\ncal_out:\n\tkfree(data);\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}