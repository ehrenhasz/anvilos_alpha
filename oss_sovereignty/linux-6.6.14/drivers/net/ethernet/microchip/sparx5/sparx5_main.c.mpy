{
  "module_name": "sparx5_main.c",
  "hash_id": "9e3b5a1cd6d66e42871f08f49c959c5d0ac8b5d36ea60a517f2ac570c5b5e170",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/microchip/sparx5/sparx5_main.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/netdevice.h>\n#include <linux/platform_device.h>\n#include <linux/interrupt.h>\n#include <linux/of.h>\n#include <linux/of_net.h>\n#include <linux/of_mdio.h>\n#include <net/switchdev.h>\n#include <linux/etherdevice.h>\n#include <linux/io.h>\n#include <linux/printk.h>\n#include <linux/iopoll.h>\n#include <linux/mfd/syscon.h>\n#include <linux/regmap.h>\n#include <linux/types.h>\n#include <linux/reset.h>\n\n#include \"sparx5_main_regs.h\"\n#include \"sparx5_main.h\"\n#include \"sparx5_port.h\"\n#include \"sparx5_qos.h\"\n\n#define QLIM_WM(fraction) \\\n\t((SPX5_BUFFER_MEMORY / SPX5_BUFFER_CELL_SZ - 100) * (fraction) / 100)\n#define IO_RANGES 3\n\nstruct initial_port_config {\n\tu32 portno;\n\tstruct device_node *node;\n\tstruct sparx5_port_config conf;\n\tstruct phy *serdes;\n};\n\nstruct sparx5_ram_config {\n\tvoid __iomem *init_reg;\n\tu32 init_val;\n};\n\nstruct sparx5_main_io_resource {\n\tenum sparx5_target id;\n\tphys_addr_t offset;\n\tint range;\n};\n\nstatic const struct sparx5_main_io_resource sparx5_main_iomap[] =  {\n\t{ TARGET_CPU,                         0, 0 },  \n\t{ TARGET_FDMA,                  0x80000, 0 },  \n\t{ TARGET_PCEP,                 0x400000, 0 },  \n\t{ TARGET_DEV2G5,             0x10004000, 1 },  \n\t{ TARGET_DEV5G,              0x10008000, 1 },  \n\t{ TARGET_PCS5G_BR,           0x1000c000, 1 },  \n\t{ TARGET_DEV2G5 +  1,        0x10010000, 1 },  \n\t{ TARGET_DEV5G +  1,         0x10014000, 1 },  \n\t{ TARGET_PCS5G_BR +  1,      0x10018000, 1 },  \n\t{ TARGET_DEV2G5 +  2,        0x1001c000, 1 },  \n\t{ TARGET_DEV5G +  2,         0x10020000, 1 },  \n\t{ TARGET_PCS5G_BR +  2,      0x10024000, 1 },  \n\t{ TARGET_DEV2G5 +  6,        0x10028000, 1 },  \n\t{ TARGET_DEV5G +  6,         0x1002c000, 1 },  \n\t{ TARGET_PCS5G_BR +  6,      0x10030000, 1 },  \n\t{ TARGET_DEV2G5 +  7,        0x10034000, 1 },  \n\t{ TARGET_DEV5G +  7,         0x10038000, 1 },  \n\t{ TARGET_PCS5G_BR +  7,      0x1003c000, 1 },  \n\t{ TARGET_DEV2G5 +  8,        0x10040000, 1 },  \n\t{ TARGET_DEV5G +  8,         0x10044000, 1 },  \n\t{ TARGET_PCS5G_BR +  8,      0x10048000, 1 },  \n\t{ TARGET_DEV2G5 +  9,        0x1004c000, 1 },  \n\t{ TARGET_DEV5G +  9,         0x10050000, 1 },  \n\t{ TARGET_PCS5G_BR +  9,      0x10054000, 1 },  \n\t{ TARGET_DEV2G5 + 10,        0x10058000, 1 },  \n\t{ TARGET_DEV5G + 10,         0x1005c000, 1 },  \n\t{ TARGET_PCS5G_BR + 10,      0x10060000, 1 },  \n\t{ TARGET_DEV2G5 + 11,        0x10064000, 1 },  \n\t{ TARGET_DEV5G + 11,         0x10068000, 1 },  \n\t{ TARGET_PCS5G_BR + 11,      0x1006c000, 1 },  \n\t{ TARGET_DEV2G5 + 12,        0x10070000, 1 },  \n\t{ TARGET_DEV10G,             0x10074000, 1 },  \n\t{ TARGET_PCS10G_BR,          0x10078000, 1 },  \n\t{ TARGET_DEV2G5 + 14,        0x1007c000, 1 },  \n\t{ TARGET_DEV10G +  2,        0x10080000, 1 },  \n\t{ TARGET_PCS10G_BR +  2,     0x10084000, 1 },  \n\t{ TARGET_DEV2G5 + 15,        0x10088000, 1 },  \n\t{ TARGET_DEV10G +  3,        0x1008c000, 1 },  \n\t{ TARGET_PCS10G_BR +  3,     0x10090000, 1 },  \n\t{ TARGET_DEV2G5 + 16,        0x10094000, 1 },  \n\t{ TARGET_DEV2G5 + 17,        0x10098000, 1 },  \n\t{ TARGET_DEV2G5 + 18,        0x1009c000, 1 },  \n\t{ TARGET_DEV2G5 + 19,        0x100a0000, 1 },  \n\t{ TARGET_DEV2G5 + 20,        0x100a4000, 1 },  \n\t{ TARGET_DEV2G5 + 21,        0x100a8000, 1 },  \n\t{ TARGET_DEV2G5 + 22,        0x100ac000, 1 },  \n\t{ TARGET_DEV2G5 + 23,        0x100b0000, 1 },  \n\t{ TARGET_DEV2G5 + 32,        0x100b4000, 1 },  \n\t{ TARGET_DEV2G5 + 33,        0x100b8000, 1 },  \n\t{ TARGET_DEV2G5 + 34,        0x100bc000, 1 },  \n\t{ TARGET_DEV2G5 + 35,        0x100c0000, 1 },  \n\t{ TARGET_DEV2G5 + 36,        0x100c4000, 1 },  \n\t{ TARGET_DEV2G5 + 37,        0x100c8000, 1 },  \n\t{ TARGET_DEV2G5 + 38,        0x100cc000, 1 },  \n\t{ TARGET_DEV2G5 + 39,        0x100d0000, 1 },  \n\t{ TARGET_DEV2G5 + 40,        0x100d4000, 1 },  \n\t{ TARGET_DEV2G5 + 41,        0x100d8000, 1 },  \n\t{ TARGET_DEV2G5 + 42,        0x100dc000, 1 },  \n\t{ TARGET_DEV2G5 + 43,        0x100e0000, 1 },  \n\t{ TARGET_DEV2G5 + 44,        0x100e4000, 1 },  \n\t{ TARGET_DEV2G5 + 45,        0x100e8000, 1 },  \n\t{ TARGET_DEV2G5 + 46,        0x100ec000, 1 },  \n\t{ TARGET_DEV2G5 + 47,        0x100f0000, 1 },  \n\t{ TARGET_DEV2G5 + 57,        0x100f4000, 1 },  \n\t{ TARGET_DEV25G +  1,        0x100f8000, 1 },  \n\t{ TARGET_PCS25G_BR +  1,     0x100fc000, 1 },  \n\t{ TARGET_DEV2G5 + 59,        0x10104000, 1 },  \n\t{ TARGET_DEV25G +  3,        0x10108000, 1 },  \n\t{ TARGET_PCS25G_BR +  3,     0x1010c000, 1 },  \n\t{ TARGET_DEV2G5 + 60,        0x10114000, 1 },  \n\t{ TARGET_DEV25G +  4,        0x10118000, 1 },  \n\t{ TARGET_PCS25G_BR +  4,     0x1011c000, 1 },  \n\t{ TARGET_DEV2G5 + 64,        0x10124000, 1 },  \n\t{ TARGET_DEV5G + 12,         0x10128000, 1 },  \n\t{ TARGET_PCS5G_BR + 12,      0x1012c000, 1 },  \n\t{ TARGET_PORT_CONF,          0x10130000, 1 },  \n\t{ TARGET_DEV2G5 +  3,        0x10404000, 1 },  \n\t{ TARGET_DEV5G +  3,         0x10408000, 1 },  \n\t{ TARGET_PCS5G_BR +  3,      0x1040c000, 1 },  \n\t{ TARGET_DEV2G5 +  4,        0x10410000, 1 },  \n\t{ TARGET_DEV5G +  4,         0x10414000, 1 },  \n\t{ TARGET_PCS5G_BR +  4,      0x10418000, 1 },  \n\t{ TARGET_DEV2G5 +  5,        0x1041c000, 1 },  \n\t{ TARGET_DEV5G +  5,         0x10420000, 1 },  \n\t{ TARGET_PCS5G_BR +  5,      0x10424000, 1 },  \n\t{ TARGET_DEV2G5 + 13,        0x10428000, 1 },  \n\t{ TARGET_DEV10G +  1,        0x1042c000, 1 },  \n\t{ TARGET_PCS10G_BR +  1,     0x10430000, 1 },  \n\t{ TARGET_DEV2G5 + 24,        0x10434000, 1 },  \n\t{ TARGET_DEV2G5 + 25,        0x10438000, 1 },  \n\t{ TARGET_DEV2G5 + 26,        0x1043c000, 1 },  \n\t{ TARGET_DEV2G5 + 27,        0x10440000, 1 },  \n\t{ TARGET_DEV2G5 + 28,        0x10444000, 1 },  \n\t{ TARGET_DEV2G5 + 29,        0x10448000, 1 },  \n\t{ TARGET_DEV2G5 + 30,        0x1044c000, 1 },  \n\t{ TARGET_DEV2G5 + 31,        0x10450000, 1 },  \n\t{ TARGET_DEV2G5 + 48,        0x10454000, 1 },  \n\t{ TARGET_DEV10G +  4,        0x10458000, 1 },  \n\t{ TARGET_PCS10G_BR +  4,     0x1045c000, 1 },  \n\t{ TARGET_DEV2G5 + 49,        0x10460000, 1 },  \n\t{ TARGET_DEV10G +  5,        0x10464000, 1 },  \n\t{ TARGET_PCS10G_BR +  5,     0x10468000, 1 },  \n\t{ TARGET_DEV2G5 + 50,        0x1046c000, 1 },  \n\t{ TARGET_DEV10G +  6,        0x10470000, 1 },  \n\t{ TARGET_PCS10G_BR +  6,     0x10474000, 1 },  \n\t{ TARGET_DEV2G5 + 51,        0x10478000, 1 },  \n\t{ TARGET_DEV10G +  7,        0x1047c000, 1 },  \n\t{ TARGET_PCS10G_BR +  7,     0x10480000, 1 },  \n\t{ TARGET_DEV2G5 + 52,        0x10484000, 1 },  \n\t{ TARGET_DEV10G +  8,        0x10488000, 1 },  \n\t{ TARGET_PCS10G_BR +  8,     0x1048c000, 1 },  \n\t{ TARGET_DEV2G5 + 53,        0x10490000, 1 },  \n\t{ TARGET_DEV10G +  9,        0x10494000, 1 },  \n\t{ TARGET_PCS10G_BR +  9,     0x10498000, 1 },  \n\t{ TARGET_DEV2G5 + 54,        0x1049c000, 1 },  \n\t{ TARGET_DEV10G + 10,        0x104a0000, 1 },  \n\t{ TARGET_PCS10G_BR + 10,     0x104a4000, 1 },  \n\t{ TARGET_DEV2G5 + 55,        0x104a8000, 1 },  \n\t{ TARGET_DEV10G + 11,        0x104ac000, 1 },  \n\t{ TARGET_PCS10G_BR + 11,     0x104b0000, 1 },  \n\t{ TARGET_DEV2G5 + 56,        0x104b4000, 1 },  \n\t{ TARGET_DEV25G,             0x104b8000, 1 },  \n\t{ TARGET_PCS25G_BR,          0x104bc000, 1 },  \n\t{ TARGET_DEV2G5 + 58,        0x104c4000, 1 },  \n\t{ TARGET_DEV25G +  2,        0x104c8000, 1 },  \n\t{ TARGET_PCS25G_BR +  2,     0x104cc000, 1 },  \n\t{ TARGET_DEV2G5 + 61,        0x104d4000, 1 },  \n\t{ TARGET_DEV25G +  5,        0x104d8000, 1 },  \n\t{ TARGET_PCS25G_BR +  5,     0x104dc000, 1 },  \n\t{ TARGET_DEV2G5 + 62,        0x104e4000, 1 },  \n\t{ TARGET_DEV25G +  6,        0x104e8000, 1 },  \n\t{ TARGET_PCS25G_BR +  6,     0x104ec000, 1 },  \n\t{ TARGET_DEV2G5 + 63,        0x104f4000, 1 },  \n\t{ TARGET_DEV25G +  7,        0x104f8000, 1 },  \n\t{ TARGET_PCS25G_BR +  7,     0x104fc000, 1 },  \n\t{ TARGET_DSM,                0x10504000, 1 },  \n\t{ TARGET_ASM,                0x10600000, 1 },  \n\t{ TARGET_GCB,                0x11010000, 2 },  \n\t{ TARGET_QS,                 0x11030000, 2 },  \n\t{ TARGET_PTP,                0x11040000, 2 },  \n\t{ TARGET_ANA_ACL,            0x11050000, 2 },  \n\t{ TARGET_LRN,                0x11060000, 2 },  \n\t{ TARGET_VCAP_SUPER,         0x11080000, 2 },  \n\t{ TARGET_QSYS,               0x110a0000, 2 },  \n\t{ TARGET_QFWD,               0x110b0000, 2 },  \n\t{ TARGET_XQS,                0x110c0000, 2 },  \n\t{ TARGET_VCAP_ES2,           0x110d0000, 2 },  \n\t{ TARGET_VCAP_ES0,           0x110e0000, 2 },  \n\t{ TARGET_CLKGEN,             0x11100000, 2 },  \n\t{ TARGET_ANA_AC_POL,         0x11200000, 2 },  \n\t{ TARGET_QRES,               0x11280000, 2 },  \n\t{ TARGET_EACL,               0x112c0000, 2 },  \n\t{ TARGET_ANA_CL,             0x11400000, 2 },  \n\t{ TARGET_ANA_L3,             0x11480000, 2 },  \n\t{ TARGET_ANA_AC_SDLB,        0x11500000, 2 },  \n\t{ TARGET_HSCH,               0x11580000, 2 },  \n\t{ TARGET_REW,                0x11600000, 2 },  \n\t{ TARGET_ANA_L2,             0x11800000, 2 },  \n\t{ TARGET_ANA_AC,             0x11900000, 2 },  \n\t{ TARGET_VOP,                0x11a00000, 2 },  \n};\n\nstatic int sparx5_create_targets(struct sparx5 *sparx5)\n{\n\tstruct resource *iores[IO_RANGES];\n\tvoid __iomem *iomem[IO_RANGES];\n\tvoid __iomem *begin[IO_RANGES];\n\tint range_id[IO_RANGES];\n\tint idx, jdx;\n\n\tfor (idx = 0, jdx = 0; jdx < ARRAY_SIZE(sparx5_main_iomap); jdx++) {\n\t\tconst struct sparx5_main_io_resource *iomap = &sparx5_main_iomap[jdx];\n\n\t\tif (idx == iomap->range) {\n\t\t\trange_id[idx] = jdx;\n\t\t\tidx++;\n\t\t}\n\t}\n\tfor (idx = 0; idx < IO_RANGES; idx++) {\n\t\tiores[idx] = platform_get_resource(sparx5->pdev, IORESOURCE_MEM,\n\t\t\t\t\t\t   idx);\n\t\tif (!iores[idx]) {\n\t\t\tdev_err(sparx5->dev, \"Invalid resource\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tiomem[idx] = devm_ioremap(sparx5->dev,\n\t\t\t\t\t  iores[idx]->start,\n\t\t\t\t\t  resource_size(iores[idx]));\n\t\tif (!iomem[idx]) {\n\t\t\tdev_err(sparx5->dev, \"Unable to get switch registers: %s\\n\",\n\t\t\t\tiores[idx]->name);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tbegin[idx] = iomem[idx] - sparx5_main_iomap[range_id[idx]].offset;\n\t}\n\tfor (jdx = 0; jdx < ARRAY_SIZE(sparx5_main_iomap); jdx++) {\n\t\tconst struct sparx5_main_io_resource *iomap = &sparx5_main_iomap[jdx];\n\n\t\tsparx5->regs[iomap->id] = begin[iomap->range] + iomap->offset;\n\t}\n\treturn 0;\n}\n\nstatic int sparx5_create_port(struct sparx5 *sparx5,\n\t\t\t      struct initial_port_config *config)\n{\n\tstruct sparx5_port *spx5_port;\n\tstruct net_device *ndev;\n\tstruct phylink *phylink;\n\tint err;\n\n\tndev = sparx5_create_netdev(sparx5, config->portno);\n\tif (IS_ERR(ndev)) {\n\t\tdev_err(sparx5->dev, \"Could not create net device: %02u\\n\",\n\t\t\tconfig->portno);\n\t\treturn PTR_ERR(ndev);\n\t}\n\tspx5_port = netdev_priv(ndev);\n\tspx5_port->of_node = config->node;\n\tspx5_port->serdes = config->serdes;\n\tspx5_port->pvid = NULL_VID;\n\tspx5_port->signd_internal = true;\n\tspx5_port->signd_active_high = true;\n\tspx5_port->signd_enable = true;\n\tspx5_port->max_vlan_tags = SPX5_PORT_MAX_TAGS_NONE;\n\tspx5_port->vlan_type = SPX5_VLAN_PORT_TYPE_UNAWARE;\n\tspx5_port->custom_etype = 0x8880;  \n\tspx5_port->phylink_pcs.poll = true;\n\tspx5_port->phylink_pcs.ops = &sparx5_phylink_pcs_ops;\n\tspx5_port->phylink_pcs.neg_mode = true;\n\tspx5_port->is_mrouter = false;\n\tINIT_LIST_HEAD(&spx5_port->tc_templates);\n\tsparx5->ports[config->portno] = spx5_port;\n\n\terr = sparx5_port_init(sparx5, spx5_port, &config->conf);\n\tif (err) {\n\t\tdev_err(sparx5->dev, \"port init failed\\n\");\n\t\treturn err;\n\t}\n\tspx5_port->conf = config->conf;\n\n\t \n\tsparx5_vlan_port_setup(sparx5, spx5_port->portno);\n\n\t \n\tspx5_port->phylink_config.dev = &spx5_port->ndev->dev;\n\tspx5_port->phylink_config.type = PHYLINK_NETDEV;\n\tspx5_port->phylink_config.mac_capabilities = MAC_ASYM_PAUSE |\n\t\tMAC_SYM_PAUSE | MAC_10 | MAC_100 | MAC_1000FD |\n\t\tMAC_2500FD | MAC_5000FD | MAC_10000FD | MAC_25000FD;\n\n\t__set_bit(PHY_INTERFACE_MODE_SGMII,\n\t\t  spx5_port->phylink_config.supported_interfaces);\n\t__set_bit(PHY_INTERFACE_MODE_QSGMII,\n\t\t  spx5_port->phylink_config.supported_interfaces);\n\t__set_bit(PHY_INTERFACE_MODE_1000BASEX,\n\t\t  spx5_port->phylink_config.supported_interfaces);\n\t__set_bit(PHY_INTERFACE_MODE_2500BASEX,\n\t\t  spx5_port->phylink_config.supported_interfaces);\n\n\tif (spx5_port->conf.bandwidth == SPEED_5000 ||\n\t    spx5_port->conf.bandwidth == SPEED_10000 ||\n\t    spx5_port->conf.bandwidth == SPEED_25000)\n\t\t__set_bit(PHY_INTERFACE_MODE_5GBASER,\n\t\t\t  spx5_port->phylink_config.supported_interfaces);\n\n\tif (spx5_port->conf.bandwidth == SPEED_10000 ||\n\t    spx5_port->conf.bandwidth == SPEED_25000)\n\t\t__set_bit(PHY_INTERFACE_MODE_10GBASER,\n\t\t\t  spx5_port->phylink_config.supported_interfaces);\n\n\tif (spx5_port->conf.bandwidth == SPEED_25000)\n\t\t__set_bit(PHY_INTERFACE_MODE_25GBASER,\n\t\t\t  spx5_port->phylink_config.supported_interfaces);\n\n\tphylink = phylink_create(&spx5_port->phylink_config,\n\t\t\t\t of_fwnode_handle(config->node),\n\t\t\t\t config->conf.phy_mode,\n\t\t\t\t &sparx5_phylink_mac_ops);\n\tif (IS_ERR(phylink))\n\t\treturn PTR_ERR(phylink);\n\n\tspx5_port->phylink = phylink;\n\n\treturn 0;\n}\n\nstatic int sparx5_init_ram(struct sparx5 *s5)\n{\n\tconst struct sparx5_ram_config spx5_ram_cfg[] = {\n\t\t{spx5_reg_get(s5, ANA_AC_STAT_RESET), ANA_AC_STAT_RESET_RESET},\n\t\t{spx5_reg_get(s5, ASM_STAT_CFG), ASM_STAT_CFG_STAT_CNT_CLR_SHOT},\n\t\t{spx5_reg_get(s5, QSYS_RAM_INIT), QSYS_RAM_INIT_RAM_INIT},\n\t\t{spx5_reg_get(s5, REW_RAM_INIT), QSYS_RAM_INIT_RAM_INIT},\n\t\t{spx5_reg_get(s5, VOP_RAM_INIT), QSYS_RAM_INIT_RAM_INIT},\n\t\t{spx5_reg_get(s5, ANA_AC_RAM_INIT), QSYS_RAM_INIT_RAM_INIT},\n\t\t{spx5_reg_get(s5, ASM_RAM_INIT), QSYS_RAM_INIT_RAM_INIT},\n\t\t{spx5_reg_get(s5, EACL_RAM_INIT), QSYS_RAM_INIT_RAM_INIT},\n\t\t{spx5_reg_get(s5, VCAP_SUPER_RAM_INIT), QSYS_RAM_INIT_RAM_INIT},\n\t\t{spx5_reg_get(s5, DSM_RAM_INIT), QSYS_RAM_INIT_RAM_INIT}\n\t};\n\tconst struct sparx5_ram_config *cfg;\n\tu32 value, pending, jdx, idx;\n\n\tfor (jdx = 0; jdx < 10; jdx++) {\n\t\tpending = ARRAY_SIZE(spx5_ram_cfg);\n\t\tfor (idx = 0; idx < ARRAY_SIZE(spx5_ram_cfg); idx++) {\n\t\t\tcfg = &spx5_ram_cfg[idx];\n\t\t\tif (jdx == 0) {\n\t\t\t\twritel(cfg->init_val, cfg->init_reg);\n\t\t\t} else {\n\t\t\t\tvalue = readl(cfg->init_reg);\n\t\t\t\tif ((value & cfg->init_val) != cfg->init_val)\n\t\t\t\t\tpending--;\n\t\t\t}\n\t\t}\n\t\tif (!pending)\n\t\t\tbreak;\n\t\tusleep_range(USEC_PER_MSEC, 2 * USEC_PER_MSEC);\n\t}\n\n\tif (pending > 0) {\n\t\t \n\t\tdev_err(s5->dev, \"Memory initialization error\\n\");\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int sparx5_init_switchcore(struct sparx5 *sparx5)\n{\n\tu32 value;\n\tint err = 0;\n\n\tspx5_rmw(EACL_POL_EACL_CFG_EACL_FORCE_INIT_SET(1),\n\t\t EACL_POL_EACL_CFG_EACL_FORCE_INIT,\n\t\t sparx5,\n\t\t EACL_POL_EACL_CFG);\n\n\tspx5_rmw(EACL_POL_EACL_CFG_EACL_FORCE_INIT_SET(0),\n\t\t EACL_POL_EACL_CFG_EACL_FORCE_INIT,\n\t\t sparx5,\n\t\t EACL_POL_EACL_CFG);\n\n\t \n\tvalue = spx5_rd(sparx5, HSCH_RESET_CFG);\n\tif (!(value & HSCH_RESET_CFG_CORE_ENA)) {\n\t\terr = sparx5_init_ram(sparx5);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t \n\tspx5_wr(ANA_AC_STAT_RESET_RESET_SET(1), sparx5, ANA_AC_STAT_RESET);\n\tspx5_wr(ASM_STAT_CFG_STAT_CNT_CLR_SHOT_SET(1), sparx5, ASM_STAT_CFG);\n\n\t \n\tspx5_wr(HSCH_RESET_CFG_CORE_ENA_SET(1), sparx5, HSCH_RESET_CFG);\n\n\treturn 0;\n}\n\nstatic int sparx5_init_coreclock(struct sparx5 *sparx5)\n{\n\tenum sparx5_core_clockfreq freq = sparx5->coreclock;\n\tu32 clk_div, clk_period, pol_upd_int, idx;\n\n\t \n\tswitch (sparx5->target_ct) {\n\tcase SPX5_TARGET_CT_7546:\n\t\tif (sparx5->coreclock == SPX5_CORE_CLOCK_DEFAULT)\n\t\t\tfreq = SPX5_CORE_CLOCK_250MHZ;\n\t\telse if (sparx5->coreclock != SPX5_CORE_CLOCK_250MHZ)\n\t\t\tfreq = 0;  \n\t\tbreak;\n\tcase SPX5_TARGET_CT_7549:\n\tcase SPX5_TARGET_CT_7552:\n\tcase SPX5_TARGET_CT_7556:\n\t\tif (sparx5->coreclock == SPX5_CORE_CLOCK_DEFAULT)\n\t\t\tfreq = SPX5_CORE_CLOCK_500MHZ;\n\t\telse if (sparx5->coreclock != SPX5_CORE_CLOCK_500MHZ)\n\t\t\tfreq = 0;  \n\t\tbreak;\n\tcase SPX5_TARGET_CT_7558:\n\tcase SPX5_TARGET_CT_7558TSN:\n\t\tif (sparx5->coreclock == SPX5_CORE_CLOCK_DEFAULT)\n\t\t\tfreq = SPX5_CORE_CLOCK_625MHZ;\n\t\telse if (sparx5->coreclock != SPX5_CORE_CLOCK_625MHZ)\n\t\t\tfreq = 0;  \n\t\tbreak;\n\tcase SPX5_TARGET_CT_7546TSN:\n\t\tif (sparx5->coreclock == SPX5_CORE_CLOCK_DEFAULT)\n\t\t\tfreq = SPX5_CORE_CLOCK_625MHZ;\n\t\tbreak;\n\tcase SPX5_TARGET_CT_7549TSN:\n\tcase SPX5_TARGET_CT_7552TSN:\n\tcase SPX5_TARGET_CT_7556TSN:\n\t\tif (sparx5->coreclock == SPX5_CORE_CLOCK_DEFAULT)\n\t\t\tfreq = SPX5_CORE_CLOCK_625MHZ;\n\t\telse if (sparx5->coreclock == SPX5_CORE_CLOCK_250MHZ)\n\t\t\tfreq = 0;  \n\t\tbreak;\n\tdefault:\n\t\tdev_err(sparx5->dev, \"Target (%#04x) not supported\\n\",\n\t\t\tsparx5->target_ct);\n\t\treturn -ENODEV;\n\t}\n\n\tswitch (freq) {\n\tcase SPX5_CORE_CLOCK_250MHZ:\n\t\tclk_div = 10;\n\t\tpol_upd_int = 312;\n\t\tbreak;\n\tcase SPX5_CORE_CLOCK_500MHZ:\n\t\tclk_div = 5;\n\t\tpol_upd_int = 624;\n\t\tbreak;\n\tcase SPX5_CORE_CLOCK_625MHZ:\n\t\tclk_div = 4;\n\t\tpol_upd_int = 780;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(sparx5->dev, \"%d coreclock not supported on (%#04x)\\n\",\n\t\t\tsparx5->coreclock, sparx5->target_ct);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tsparx5->coreclock = freq;\n\n\t \n\tspx5_rmw(CLKGEN_LCPLL1_CORE_CLK_CFG_CORE_CLK_DIV_SET(clk_div) |\n\t\t CLKGEN_LCPLL1_CORE_CLK_CFG_CORE_PRE_DIV_SET(0) |\n\t\t CLKGEN_LCPLL1_CORE_CLK_CFG_CORE_ROT_DIR_SET(0) |\n\t\t CLKGEN_LCPLL1_CORE_CLK_CFG_CORE_ROT_SEL_SET(0) |\n\t\t CLKGEN_LCPLL1_CORE_CLK_CFG_CORE_ROT_ENA_SET(0) |\n\t\t CLKGEN_LCPLL1_CORE_CLK_CFG_CORE_CLK_ENA_SET(1),\n\t\t CLKGEN_LCPLL1_CORE_CLK_CFG_CORE_CLK_DIV |\n\t\t CLKGEN_LCPLL1_CORE_CLK_CFG_CORE_PRE_DIV |\n\t\t CLKGEN_LCPLL1_CORE_CLK_CFG_CORE_ROT_DIR |\n\t\t CLKGEN_LCPLL1_CORE_CLK_CFG_CORE_ROT_SEL |\n\t\t CLKGEN_LCPLL1_CORE_CLK_CFG_CORE_ROT_ENA |\n\t\t CLKGEN_LCPLL1_CORE_CLK_CFG_CORE_CLK_ENA,\n\t\t sparx5,\n\t\t CLKGEN_LCPLL1_CORE_CLK_CFG);\n\n\tclk_period = sparx5_clk_period(freq);\n\n\tspx5_rmw(HSCH_SYS_CLK_PER_100PS_SET(clk_period / 100),\n\t\t HSCH_SYS_CLK_PER_100PS,\n\t\t sparx5,\n\t\t HSCH_SYS_CLK_PER);\n\n\tspx5_rmw(ANA_AC_POL_BDLB_DLB_CTRL_CLK_PERIOD_01NS_SET(clk_period / 100),\n\t\t ANA_AC_POL_BDLB_DLB_CTRL_CLK_PERIOD_01NS,\n\t\t sparx5,\n\t\t ANA_AC_POL_BDLB_DLB_CTRL);\n\n\tspx5_rmw(ANA_AC_POL_SLB_DLB_CTRL_CLK_PERIOD_01NS_SET(clk_period / 100),\n\t\t ANA_AC_POL_SLB_DLB_CTRL_CLK_PERIOD_01NS,\n\t\t sparx5,\n\t\t ANA_AC_POL_SLB_DLB_CTRL);\n\n\tspx5_rmw(LRN_AUTOAGE_CFG_1_CLK_PERIOD_01NS_SET(clk_period / 100),\n\t\t LRN_AUTOAGE_CFG_1_CLK_PERIOD_01NS,\n\t\t sparx5,\n\t\t LRN_AUTOAGE_CFG_1);\n\n\tfor (idx = 0; idx < 3; idx++)\n\t\tspx5_rmw(GCB_SIO_CLOCK_SYS_CLK_PERIOD_SET(clk_period / 100),\n\t\t\t GCB_SIO_CLOCK_SYS_CLK_PERIOD,\n\t\t\t sparx5,\n\t\t\t GCB_SIO_CLOCK(idx));\n\n\tspx5_rmw(HSCH_TAS_STATEMACHINE_CFG_REVISIT_DLY_SET\n\t\t ((256 * 1000) / clk_period),\n\t\t HSCH_TAS_STATEMACHINE_CFG_REVISIT_DLY,\n\t\t sparx5,\n\t\t HSCH_TAS_STATEMACHINE_CFG);\n\n\tspx5_rmw(ANA_AC_POL_POL_UPD_INT_CFG_POL_UPD_INT_SET(pol_upd_int),\n\t\t ANA_AC_POL_POL_UPD_INT_CFG_POL_UPD_INT,\n\t\t sparx5,\n\t\t ANA_AC_POL_POL_UPD_INT_CFG);\n\n\treturn 0;\n}\n\nstatic int sparx5_qlim_set(struct sparx5 *sparx5)\n{\n\tu32 res, dp, prio;\n\n\tfor (res = 0; res < 2; res++) {\n\t\tfor (prio = 0; prio < 8; prio++)\n\t\t\tspx5_wr(0xFFF, sparx5,\n\t\t\t\tQRES_RES_CFG(prio + 630 + res * 1024));\n\n\t\tfor (dp = 0; dp < 4; dp++)\n\t\t\tspx5_wr(0xFFF, sparx5,\n\t\t\t\tQRES_RES_CFG(dp + 638 + res * 1024));\n\t}\n\n\t \n\tspx5_wr(QLIM_WM(80), sparx5, XQS_QLIMIT_SHR_QLIM_CFG(0));\n\tspx5_wr(QLIM_WM(90), sparx5, XQS_QLIMIT_SHR_CTOP_CFG(0));\n\tspx5_wr(QLIM_WM(95), sparx5, XQS_QLIMIT_SHR_ATOP_CFG(0));\n\tspx5_wr(QLIM_WM(100), sparx5, XQS_QLIMIT_SHR_TOP_CFG(0));\n\n\treturn 0;\n}\n\n \nstatic void sparx5_board_init(struct sparx5 *sparx5)\n{\n\tint idx;\n\n\tif (!sparx5->sd_sgpio_remapping)\n\t\treturn;\n\n\t \n\tspx5_rmw(GCB_HW_SGPIO_SD_CFG_SD_MAP_SEL,\n\t\t GCB_HW_SGPIO_SD_CFG_SD_MAP_SEL,\n\t\t sparx5,\n\t\t GCB_HW_SGPIO_SD_CFG);\n\n\t \n\tfor (idx = 0; idx < SPX5_PORTS; idx++)\n\t\tif (sparx5->ports[idx])\n\t\t\tif (sparx5->ports[idx]->conf.sd_sgpio != ~0)\n\t\t\t\tspx5_wr(sparx5->ports[idx]->conf.sd_sgpio,\n\t\t\t\t\tsparx5,\n\t\t\t\t\tGCB_HW_SGPIO_TO_SD_MAP_CFG(idx));\n}\n\nstatic int sparx5_start(struct sparx5 *sparx5)\n{\n\tu8 broadcast[ETH_ALEN] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};\n\tchar queue_name[32];\n\tu32 idx;\n\tint err;\n\n\t \n\tfor (idx = 0; idx < 3; idx++) {\n\t\tspx5_wr(idx, sparx5, ANA_AC_OWN_UPSID(idx));\n\t\tspx5_wr(idx, sparx5, ANA_CL_OWN_UPSID(idx));\n\t\tspx5_wr(idx, sparx5, ANA_L2_OWN_UPSID(idx));\n\t\tspx5_wr(idx, sparx5, REW_OWN_UPSID(idx));\n\t}\n\n\t \n\tfor (idx = SPX5_PORTS; idx < SPX5_PORTS_ALL; idx++)\n\t\tspx5_rmw(QFWD_SWITCH_PORT_MODE_PORT_ENA_SET(1),\n\t\t\t QFWD_SWITCH_PORT_MODE_PORT_ENA,\n\t\t\t sparx5,\n\t\t\t QFWD_SWITCH_PORT_MODE(idx));\n\n\t \n\tsparx5_update_fwd(sparx5);\n\n\t \n\tspx5_wr(ANA_AC_PGID_MISC_CFG_PGID_CPU_COPY_ENA_SET(1),\n\t\tsparx5, ANA_AC_PGID_MISC_CFG(PGID_CPU));\n\tspx5_wr(ANA_AC_PGID_MISC_CFG_PGID_CPU_COPY_ENA_SET(1),\n\t\tsparx5, ANA_AC_PGID_MISC_CFG(PGID_BCAST));\n\n\t \n\tfor (idx = SPX5_PORT_CPU_0; idx <= SPX5_PORT_CPU_1; idx++)\n\t\tspx5_rmw(ANA_CL_FILTER_CTRL_FORCE_FCS_UPDATE_ENA_SET(1),\n\t\t\t ANA_CL_FILTER_CTRL_FORCE_FCS_UPDATE_ENA,\n\t\t\t sparx5, ANA_CL_FILTER_CTRL(idx));\n\n\t \n\tsparx5_mact_init(sparx5);\n\n\t \n\tsparx5_pgid_init(sparx5);\n\n\t \n\tsparx5_vlan_init(sparx5);\n\n\t \n\tsparx5_mact_learn(sparx5, PGID_CPU, broadcast, NULL_VID);\n\n\t \n\tsparx5_qlim_set(sparx5);\n\n\terr = sparx5_config_auto_calendar(sparx5);\n\tif (err)\n\t\treturn err;\n\n\terr = sparx5_config_dsm_calendar(sparx5);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = sparx_stats_init(sparx5);\n\tif (err)\n\t\treturn err;\n\n\t \n\tmutex_init(&sparx5->mact_lock);\n\tINIT_LIST_HEAD(&sparx5->mact_entries);\n\tsnprintf(queue_name, sizeof(queue_name), \"%s-mact\",\n\t\t dev_name(sparx5->dev));\n\tsparx5->mact_queue = create_singlethread_workqueue(queue_name);\n\tif (!sparx5->mact_queue)\n\t\treturn -ENOMEM;\n\n\tINIT_DELAYED_WORK(&sparx5->mact_work, sparx5_mact_pull_work);\n\tqueue_delayed_work(sparx5->mact_queue, &sparx5->mact_work,\n\t\t\t   SPX5_MACT_PULL_DELAY);\n\n\tmutex_init(&sparx5->mdb_lock);\n\tINIT_LIST_HEAD(&sparx5->mdb_entries);\n\n\terr = sparx5_register_netdevs(sparx5);\n\tif (err)\n\t\treturn err;\n\n\tsparx5_board_init(sparx5);\n\terr = sparx5_register_notifier_blocks(sparx5);\n\tif (err)\n\t\treturn err;\n\n\terr = sparx5_vcap_init(sparx5);\n\tif (err) {\n\t\tsparx5_unregister_notifier_blocks(sparx5);\n\t\treturn err;\n\t}\n\n\t \n\terr = -ENXIO;\n\tif (sparx5->fdma_irq >= 0) {\n\t\tif (GCB_CHIP_ID_REV_ID_GET(sparx5->chip_id) > 0)\n\t\t\terr = devm_request_threaded_irq(sparx5->dev,\n\t\t\t\t\t\t\tsparx5->fdma_irq,\n\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\tsparx5_fdma_handler,\n\t\t\t\t\t\t\tIRQF_ONESHOT,\n\t\t\t\t\t\t\t\"sparx5-fdma\", sparx5);\n\t\tif (!err)\n\t\t\terr = sparx5_fdma_start(sparx5);\n\t\tif (err)\n\t\t\tsparx5->fdma_irq = -ENXIO;\n\t} else {\n\t\tsparx5->fdma_irq = -ENXIO;\n\t}\n\tif (err && sparx5->xtr_irq >= 0) {\n\t\terr = devm_request_irq(sparx5->dev, sparx5->xtr_irq,\n\t\t\t\t       sparx5_xtr_handler, IRQF_SHARED,\n\t\t\t\t       \"sparx5-xtr\", sparx5);\n\t\tif (!err)\n\t\t\terr = sparx5_manual_injection_mode(sparx5);\n\t\tif (err)\n\t\t\tsparx5->xtr_irq = -ENXIO;\n\t} else {\n\t\tsparx5->xtr_irq = -ENXIO;\n\t}\n\n\tif (sparx5->ptp_irq >= 0) {\n\t\terr = devm_request_threaded_irq(sparx5->dev, sparx5->ptp_irq,\n\t\t\t\t\t\tNULL, sparx5_ptp_irq_handler,\n\t\t\t\t\t\tIRQF_ONESHOT, \"sparx5-ptp\",\n\t\t\t\t\t\tsparx5);\n\t\tif (err)\n\t\t\tsparx5->ptp_irq = -ENXIO;\n\n\t\tsparx5->ptp = 1;\n\t}\n\n\treturn err;\n}\n\nstatic void sparx5_cleanup_ports(struct sparx5 *sparx5)\n{\n\tsparx5_unregister_netdevs(sparx5);\n\tsparx5_destroy_netdevs(sparx5);\n}\n\nstatic int mchp_sparx5_probe(struct platform_device *pdev)\n{\n\tstruct initial_port_config *configs, *config;\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct device_node *ports, *portnp;\n\tstruct reset_control *reset;\n\tstruct sparx5 *sparx5;\n\tint idx = 0, err = 0;\n\n\tif (!np && !pdev->dev.platform_data)\n\t\treturn -ENODEV;\n\n\tsparx5 = devm_kzalloc(&pdev->dev, sizeof(*sparx5), GFP_KERNEL);\n\tif (!sparx5)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, sparx5);\n\tsparx5->pdev = pdev;\n\tsparx5->dev = &pdev->dev;\n\n\t \n\treset = devm_reset_control_get_optional_shared(&pdev->dev, \"switch\");\n\tif (IS_ERR(reset))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(reset),\n\t\t\t\t     \"Failed to get switch reset controller.\\n\");\n\treset_control_reset(reset);\n\n\t \n\tsparx5->coreclock = SPX5_CORE_CLOCK_DEFAULT;\n\n\tsparx5->debugfs_root = debugfs_create_dir(\"sparx5\", NULL);\n\n\tports = of_get_child_by_name(np, \"ethernet-ports\");\n\tif (!ports) {\n\t\tdev_err(sparx5->dev, \"no ethernet-ports child node found\\n\");\n\t\treturn -ENODEV;\n\t}\n\tsparx5->port_count = of_get_child_count(ports);\n\n\tconfigs = kcalloc(sparx5->port_count,\n\t\t\t  sizeof(struct initial_port_config), GFP_KERNEL);\n\tif (!configs) {\n\t\terr = -ENOMEM;\n\t\tgoto cleanup_pnode;\n\t}\n\n\tfor_each_available_child_of_node(ports, portnp) {\n\t\tstruct sparx5_port_config *conf;\n\t\tstruct phy *serdes;\n\t\tu32 portno;\n\n\t\terr = of_property_read_u32(portnp, \"reg\", &portno);\n\t\tif (err) {\n\t\t\tdev_err(sparx5->dev, \"port reg property error\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tconfig = &configs[idx];\n\t\tconf = &config->conf;\n\t\tconf->speed = SPEED_UNKNOWN;\n\t\tconf->bandwidth = SPEED_UNKNOWN;\n\t\terr = of_get_phy_mode(portnp, &conf->phy_mode);\n\t\tif (err) {\n\t\t\tdev_err(sparx5->dev, \"port %u: missing phy-mode\\n\",\n\t\t\t\tportno);\n\t\t\tcontinue;\n\t\t}\n\t\terr = of_property_read_u32(portnp, \"microchip,bandwidth\",\n\t\t\t\t\t   &conf->bandwidth);\n\t\tif (err) {\n\t\t\tdev_err(sparx5->dev, \"port %u: missing bandwidth\\n\",\n\t\t\t\tportno);\n\t\t\tcontinue;\n\t\t}\n\t\terr = of_property_read_u32(portnp, \"microchip,sd-sgpio\", &conf->sd_sgpio);\n\t\tif (err)\n\t\t\tconf->sd_sgpio = ~0;\n\t\telse\n\t\t\tsparx5->sd_sgpio_remapping = true;\n\t\tserdes = devm_of_phy_get(sparx5->dev, portnp, NULL);\n\t\tif (IS_ERR(serdes)) {\n\t\t\terr = dev_err_probe(sparx5->dev, PTR_ERR(serdes),\n\t\t\t\t\t    \"port %u: missing serdes\\n\",\n\t\t\t\t\t    portno);\n\t\t\tof_node_put(portnp);\n\t\t\tgoto cleanup_config;\n\t\t}\n\t\tconfig->portno = portno;\n\t\tconfig->node = portnp;\n\t\tconfig->serdes = serdes;\n\n\t\tconf->media = PHY_MEDIA_DAC;\n\t\tconf->serdes_reset = true;\n\t\tconf->portmode = conf->phy_mode;\n\t\tconf->power_down = true;\n\t\tidx++;\n\t}\n\n\terr = sparx5_create_targets(sparx5);\n\tif (err)\n\t\tgoto cleanup_config;\n\n\tif (of_get_mac_address(np, sparx5->base_mac)) {\n\t\tdev_info(sparx5->dev, \"MAC addr was not set, use random MAC\\n\");\n\t\teth_random_addr(sparx5->base_mac);\n\t\tsparx5->base_mac[5] = 0;\n\t}\n\n\tsparx5->fdma_irq = platform_get_irq_byname(sparx5->pdev, \"fdma\");\n\tsparx5->xtr_irq = platform_get_irq_byname(sparx5->pdev, \"xtr\");\n\tsparx5->ptp_irq = platform_get_irq_byname(sparx5->pdev, \"ptp\");\n\n\t \n\tsparx5->chip_id = spx5_rd(sparx5, GCB_CHIP_ID);\n\n\tsparx5->target_ct = (enum spx5_target_chiptype)\n\t\tGCB_CHIP_ID_PART_ID_GET(sparx5->chip_id);\n\n\t \n\terr = sparx5_init_switchcore(sparx5);\n\tif (err) {\n\t\tdev_err(sparx5->dev, \"Switchcore initialization error\\n\");\n\t\tgoto cleanup_config;\n\t}\n\n\t \n\terr = sparx5_init_coreclock(sparx5);\n\tif (err) {\n\t\tdev_err(sparx5->dev, \"LC-PLL initialization error\\n\");\n\t\tgoto cleanup_config;\n\t}\n\n\tfor (idx = 0; idx < sparx5->port_count; ++idx) {\n\t\tconfig = &configs[idx];\n\t\tif (!config->node)\n\t\t\tcontinue;\n\n\t\terr = sparx5_create_port(sparx5, config);\n\t\tif (err) {\n\t\t\tdev_err(sparx5->dev, \"port create error\\n\");\n\t\t\tgoto cleanup_ports;\n\t\t}\n\t}\n\n\terr = sparx5_start(sparx5);\n\tif (err) {\n\t\tdev_err(sparx5->dev, \"Start failed\\n\");\n\t\tgoto cleanup_ports;\n\t}\n\n\terr = sparx5_qos_init(sparx5);\n\tif (err) {\n\t\tdev_err(sparx5->dev, \"Failed to initialize QoS\\n\");\n\t\tgoto cleanup_ports;\n\t}\n\n\terr = sparx5_ptp_init(sparx5);\n\tif (err) {\n\t\tdev_err(sparx5->dev, \"PTP failed\\n\");\n\t\tgoto cleanup_ports;\n\t}\n\tgoto cleanup_config;\n\ncleanup_ports:\n\tsparx5_cleanup_ports(sparx5);\n\tif (sparx5->mact_queue)\n\t\tdestroy_workqueue(sparx5->mact_queue);\ncleanup_config:\n\tkfree(configs);\ncleanup_pnode:\n\tof_node_put(ports);\n\treturn err;\n}\n\nstatic int mchp_sparx5_remove(struct platform_device *pdev)\n{\n\tstruct sparx5 *sparx5 = platform_get_drvdata(pdev);\n\n\tdebugfs_remove_recursive(sparx5->debugfs_root);\n\tif (sparx5->xtr_irq) {\n\t\tdisable_irq(sparx5->xtr_irq);\n\t\tsparx5->xtr_irq = -ENXIO;\n\t}\n\tif (sparx5->fdma_irq) {\n\t\tdisable_irq(sparx5->fdma_irq);\n\t\tsparx5->fdma_irq = -ENXIO;\n\t}\n\tsparx5_ptp_deinit(sparx5);\n\tsparx5_fdma_stop(sparx5);\n\tsparx5_cleanup_ports(sparx5);\n\tsparx5_vcap_destroy(sparx5);\n\t \n\tsparx5_unregister_notifier_blocks(sparx5);\n\tdestroy_workqueue(sparx5->mact_queue);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id mchp_sparx5_match[] = {\n\t{ .compatible = \"microchip,sparx5-switch\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, mchp_sparx5_match);\n\nstatic struct platform_driver mchp_sparx5_driver = {\n\t.probe = mchp_sparx5_probe,\n\t.remove = mchp_sparx5_remove,\n\t.driver = {\n\t\t.name = \"sparx5-switch\",\n\t\t.of_match_table = mchp_sparx5_match,\n\t},\n};\n\nmodule_platform_driver(mchp_sparx5_driver);\n\nMODULE_DESCRIPTION(\"Microchip Sparx5 switch driver\");\nMODULE_AUTHOR(\"Steen Hegelund <steen.hegelund@microchip.com>\");\nMODULE_LICENSE(\"Dual MIT/GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}