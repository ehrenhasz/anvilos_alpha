{
  "module_name": "sparx5_mactable.c",
  "hash_id": "415ba86324ef3edaf39c74eb84c99feb39db0a836ea0fd5bc4464103fb5a1632",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/microchip/sparx5/sparx5_mactable.c",
  "human_readable_source": "\n \n\n#include <net/switchdev.h>\n#include <linux/if_bridge.h>\n#include <linux/iopoll.h>\n\n#include \"sparx5_main_regs.h\"\n#include \"sparx5_main.h\"\n\n \n#define MAC_CMD_LEARN         0  \n#define MAC_CMD_UNLEARN       1  \n#define MAC_CMD_LOOKUP        2  \n#define MAC_CMD_READ          3  \n#define MAC_CMD_WRITE         4  \n#define MAC_CMD_SCAN          5  \n#define MAC_CMD_FIND_SMALLEST 6  \n#define MAC_CMD_CLEAR_ALL     7  \n\n \n#define  MAC_ENTRY_ADDR_TYPE_UPSID_PN         0\n#define  MAC_ENTRY_ADDR_TYPE_UPSID_CPU_OR_INT 1\n#define  MAC_ENTRY_ADDR_TYPE_GLAG             2\n#define  MAC_ENTRY_ADDR_TYPE_MC_IDX           3\n\n#define TABLE_UPDATE_SLEEP_US 10\n#define TABLE_UPDATE_TIMEOUT_US 100000\n\nstruct sparx5_mact_entry {\n\tstruct list_head list;\n\tunsigned char mac[ETH_ALEN];\n\tu32 flags;\n#define MAC_ENT_ALIVE\tBIT(0)\n#define MAC_ENT_MOVED\tBIT(1)\n#define MAC_ENT_LOCK\tBIT(2)\n\tu16 vid;\n\tu16 port;\n};\n\nstatic int sparx5_mact_get_status(struct sparx5 *sparx5)\n{\n\treturn spx5_rd(sparx5, LRN_COMMON_ACCESS_CTRL);\n}\n\nstatic int sparx5_mact_wait_for_completion(struct sparx5 *sparx5)\n{\n\tu32 val;\n\n\treturn readx_poll_timeout(sparx5_mact_get_status,\n\t\tsparx5, val,\n\t\tLRN_COMMON_ACCESS_CTRL_MAC_TABLE_ACCESS_SHOT_GET(val) == 0,\n\t\tTABLE_UPDATE_SLEEP_US, TABLE_UPDATE_TIMEOUT_US);\n}\n\nstatic void sparx5_mact_select(struct sparx5 *sparx5,\n\t\t\t       const unsigned char mac[ETH_ALEN],\n\t\t\t       u16 vid)\n{\n\tu32 macl = 0, mach = 0;\n\n\t \n\tmach |= vid    << 16;\n\tmach |= mac[0] << 8;\n\tmach |= mac[1] << 0;\n\tmacl |= mac[2] << 24;\n\tmacl |= mac[3] << 16;\n\tmacl |= mac[4] << 8;\n\tmacl |= mac[5] << 0;\n\n\tspx5_wr(mach, sparx5, LRN_MAC_ACCESS_CFG_0);\n\tspx5_wr(macl, sparx5, LRN_MAC_ACCESS_CFG_1);\n}\n\nint sparx5_mact_learn(struct sparx5 *sparx5, int pgid,\n\t\t      const unsigned char mac[ETH_ALEN], u16 vid)\n{\n\tint addr, type, ret;\n\n\tif (pgid < SPX5_PORTS) {\n\t\ttype = MAC_ENTRY_ADDR_TYPE_UPSID_PN;\n\t\taddr = pgid % 32;\n\t\taddr += (pgid / 32) << 5;  \n\t} else {\n\t\ttype = MAC_ENTRY_ADDR_TYPE_MC_IDX;\n\t\taddr = pgid - SPX5_PORTS;\n\t}\n\n\tmutex_lock(&sparx5->lock);\n\n\tsparx5_mact_select(sparx5, mac, vid);\n\n\t \n\tspx5_wr(LRN_MAC_ACCESS_CFG_2_MAC_ENTRY_ADDR_SET(addr) |\n\t\tLRN_MAC_ACCESS_CFG_2_MAC_ENTRY_ADDR_TYPE_SET(type) |\n\t\tLRN_MAC_ACCESS_CFG_2_MAC_ENTRY_VLD_SET(1) |\n\t\tLRN_MAC_ACCESS_CFG_2_MAC_ENTRY_LOCKED_SET(1),\n\t\tsparx5, LRN_MAC_ACCESS_CFG_2);\n\tspx5_wr(0, sparx5, LRN_MAC_ACCESS_CFG_3);\n\n\t \n\tspx5_wr(LRN_COMMON_ACCESS_CTRL_CPU_ACCESS_CMD_SET(MAC_CMD_LEARN) |\n\t\tLRN_COMMON_ACCESS_CTRL_MAC_TABLE_ACCESS_SHOT_SET(1),\n\t\tsparx5, LRN_COMMON_ACCESS_CTRL);\n\n\tret = sparx5_mact_wait_for_completion(sparx5);\n\n\tmutex_unlock(&sparx5->lock);\n\n\treturn ret;\n}\n\nint sparx5_mc_unsync(struct net_device *dev, const unsigned char *addr)\n{\n\tstruct sparx5_port *port = netdev_priv(dev);\n\tstruct sparx5 *sparx5 = port->sparx5;\n\n\treturn sparx5_mact_forget(sparx5, addr, port->pvid);\n}\n\nint sparx5_mc_sync(struct net_device *dev, const unsigned char *addr)\n{\n\tstruct sparx5_port *port = netdev_priv(dev);\n\tstruct sparx5 *sparx5 = port->sparx5;\n\n\treturn sparx5_mact_learn(sparx5, PGID_CPU, addr, port->pvid);\n}\n\nstatic int sparx5_mact_get(struct sparx5 *sparx5,\n\t\t\t   unsigned char mac[ETH_ALEN],\n\t\t\t   u16 *vid, u32 *pcfg2)\n{\n\tu32 mach, macl, cfg2;\n\tint ret = -ENOENT;\n\n\tcfg2 = spx5_rd(sparx5, LRN_MAC_ACCESS_CFG_2);\n\tif (LRN_MAC_ACCESS_CFG_2_MAC_ENTRY_VLD_GET(cfg2)) {\n\t\tmach = spx5_rd(sparx5, LRN_MAC_ACCESS_CFG_0);\n\t\tmacl = spx5_rd(sparx5, LRN_MAC_ACCESS_CFG_1);\n\t\tmac[0] = ((mach >> 8)  & 0xff);\n\t\tmac[1] = ((mach >> 0)  & 0xff);\n\t\tmac[2] = ((macl >> 24) & 0xff);\n\t\tmac[3] = ((macl >> 16) & 0xff);\n\t\tmac[4] = ((macl >> 8)  & 0xff);\n\t\tmac[5] = ((macl >> 0)  & 0xff);\n\t\t*vid = mach >> 16;\n\t\t*pcfg2 = cfg2;\n\t\tret = 0;\n\t}\n\n\treturn ret;\n}\n\nbool sparx5_mact_getnext(struct sparx5 *sparx5,\n\t\t\t unsigned char mac[ETH_ALEN], u16 *vid, u32 *pcfg2)\n{\n\tu32 cfg2;\n\tint ret;\n\n\tmutex_lock(&sparx5->lock);\n\n\tsparx5_mact_select(sparx5, mac, *vid);\n\n\tspx5_wr(LRN_SCAN_NEXT_CFG_SCAN_NEXT_IGNORE_LOCKED_ENA_SET(1) |\n\t\tLRN_SCAN_NEXT_CFG_SCAN_NEXT_UNTIL_FOUND_ENA_SET(1),\n\t\tsparx5, LRN_SCAN_NEXT_CFG);\n\tspx5_wr(LRN_COMMON_ACCESS_CTRL_CPU_ACCESS_CMD_SET\n\t\t(MAC_CMD_FIND_SMALLEST) |\n\t\tLRN_COMMON_ACCESS_CTRL_MAC_TABLE_ACCESS_SHOT_SET(1),\n\t\tsparx5, LRN_COMMON_ACCESS_CTRL);\n\n\tret = sparx5_mact_wait_for_completion(sparx5);\n\tif (ret == 0) {\n\t\tret = sparx5_mact_get(sparx5, mac, vid, &cfg2);\n\t\tif (ret == 0)\n\t\t\t*pcfg2 = cfg2;\n\t}\n\n\tmutex_unlock(&sparx5->lock);\n\n\treturn ret == 0;\n}\n\nint sparx5_mact_find(struct sparx5 *sparx5,\n\t\t     const unsigned char mac[ETH_ALEN], u16 vid, u32 *pcfg2)\n{\n\tint ret;\n\tu32 cfg2;\n\n\tmutex_lock(&sparx5->lock);\n\n\tsparx5_mact_select(sparx5, mac, vid);\n\n\t \n\tspx5_wr(LRN_COMMON_ACCESS_CTRL_CPU_ACCESS_CMD_SET(MAC_CMD_LOOKUP) |\n\t\tLRN_COMMON_ACCESS_CTRL_MAC_TABLE_ACCESS_SHOT_SET(1),\n\t\tsparx5, LRN_COMMON_ACCESS_CTRL);\n\n\tret = sparx5_mact_wait_for_completion(sparx5);\n\tif (ret == 0) {\n\t\tcfg2 = spx5_rd(sparx5, LRN_MAC_ACCESS_CFG_2);\n\t\tif (LRN_MAC_ACCESS_CFG_2_MAC_ENTRY_VLD_GET(cfg2))\n\t\t\t*pcfg2 = cfg2;\n\t\telse\n\t\t\tret = -ENOENT;\n\t}\n\n\tmutex_unlock(&sparx5->lock);\n\n\treturn ret;\n}\n\nint sparx5_mact_forget(struct sparx5 *sparx5,\n\t\t       const unsigned char mac[ETH_ALEN], u16 vid)\n{\n\tint ret;\n\n\tmutex_lock(&sparx5->lock);\n\n\tsparx5_mact_select(sparx5, mac, vid);\n\n\t \n\tspx5_wr(LRN_COMMON_ACCESS_CTRL_CPU_ACCESS_CMD_SET(MAC_CMD_UNLEARN) |\n\t\tLRN_COMMON_ACCESS_CTRL_MAC_TABLE_ACCESS_SHOT_SET(1),\n\t\tsparx5, LRN_COMMON_ACCESS_CTRL);\n\n\tret = sparx5_mact_wait_for_completion(sparx5);\n\n\tmutex_unlock(&sparx5->lock);\n\n\treturn ret;\n}\n\nstatic struct sparx5_mact_entry *alloc_mact_entry(struct sparx5 *sparx5,\n\t\t\t\t\t\t  const unsigned char *mac,\n\t\t\t\t\t\t  u16 vid, u16 port_index)\n{\n\tstruct sparx5_mact_entry *mact_entry;\n\n\tmact_entry = devm_kzalloc(sparx5->dev,\n\t\t\t\t  sizeof(*mact_entry), GFP_ATOMIC);\n\tif (!mact_entry)\n\t\treturn NULL;\n\n\tmemcpy(mact_entry->mac, mac, ETH_ALEN);\n\tmact_entry->vid = vid;\n\tmact_entry->port = port_index;\n\treturn mact_entry;\n}\n\nstatic struct sparx5_mact_entry *find_mact_entry(struct sparx5 *sparx5,\n\t\t\t\t\t\t const unsigned char *mac,\n\t\t\t\t\t\t u16 vid, u16 port_index)\n{\n\tstruct sparx5_mact_entry *mact_entry;\n\tstruct sparx5_mact_entry *res = NULL;\n\n\tmutex_lock(&sparx5->mact_lock);\n\tlist_for_each_entry(mact_entry, &sparx5->mact_entries, list) {\n\t\tif (mact_entry->vid == vid &&\n\t\t    ether_addr_equal(mac, mact_entry->mac) &&\n\t\t    mact_entry->port == port_index) {\n\t\t\tres = mact_entry;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&sparx5->mact_lock);\n\n\treturn res;\n}\n\nstatic void sparx5_fdb_call_notifiers(enum switchdev_notifier_type type,\n\t\t\t\t      const char *mac, u16 vid,\n\t\t\t\t      struct net_device *dev, bool offloaded)\n{\n\tstruct switchdev_notifier_fdb_info info = {};\n\n\tinfo.addr = mac;\n\tinfo.vid = vid;\n\tinfo.offloaded = offloaded;\n\tcall_switchdev_notifiers(type, dev, &info.info, NULL);\n}\n\nint sparx5_add_mact_entry(struct sparx5 *sparx5,\n\t\t\t  struct net_device *dev,\n\t\t\t  u16 portno,\n\t\t\t  const unsigned char *addr, u16 vid)\n{\n\tstruct sparx5_mact_entry *mact_entry;\n\tint ret;\n\tu32 cfg2;\n\n\tret = sparx5_mact_find(sparx5, addr, vid, &cfg2);\n\tif (!ret)\n\t\treturn 0;\n\n\t \n\tmact_entry = find_mact_entry(sparx5, addr, vid, portno);\n\tif (mact_entry)\n\t\tgoto update_hw;\n\n\t \n\tmact_entry = alloc_mact_entry(sparx5, addr, vid, portno);\n\tif (!mact_entry)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&sparx5->mact_lock);\n\tlist_add_tail(&mact_entry->list, &sparx5->mact_entries);\n\tmutex_unlock(&sparx5->mact_lock);\n\nupdate_hw:\n\tret = sparx5_mact_learn(sparx5, portno, addr, vid);\n\n\t \n\tif (mact_entry->flags == 0) {\n\t\tmact_entry->flags |= MAC_ENT_LOCK;  \n\t\tsparx5_fdb_call_notifiers(SWITCHDEV_FDB_ADD_TO_BRIDGE, addr, vid,\n\t\t\t\t\t  dev, true);\n\t}\n\n\treturn ret;\n}\n\nint sparx5_del_mact_entry(struct sparx5 *sparx5,\n\t\t\t  const unsigned char *addr,\n\t\t\t  u16 vid)\n{\n\tstruct sparx5_mact_entry *mact_entry, *tmp;\n\n\t \n\tmutex_lock(&sparx5->mact_lock);\n\tlist_for_each_entry_safe(mact_entry, tmp, &sparx5->mact_entries,\n\t\t\t\t list) {\n\t\tif ((vid == 0 || mact_entry->vid == vid) &&\n\t\t    ether_addr_equal(addr, mact_entry->mac)) {\n\t\t\tlist_del(&mact_entry->list);\n\t\t\tdevm_kfree(sparx5->dev, mact_entry);\n\n\t\t\tsparx5_mact_forget(sparx5, addr, mact_entry->vid);\n\t\t}\n\t}\n\tmutex_unlock(&sparx5->mact_lock);\n\n\treturn 0;\n}\n\nstatic void sparx5_mact_handle_entry(struct sparx5 *sparx5,\n\t\t\t\t     unsigned char mac[ETH_ALEN],\n\t\t\t\t     u16 vid, u32 cfg2)\n{\n\tstruct sparx5_mact_entry *mact_entry;\n\tbool found = false;\n\tu16 port;\n\n\tif (LRN_MAC_ACCESS_CFG_2_MAC_ENTRY_ADDR_TYPE_GET(cfg2) !=\n\t    MAC_ENTRY_ADDR_TYPE_UPSID_PN)\n\t\treturn;\n\n\tport = LRN_MAC_ACCESS_CFG_2_MAC_ENTRY_ADDR_GET(cfg2);\n\tif (port >= SPX5_PORTS)\n\t\treturn;\n\n\tif (!test_bit(port, sparx5->bridge_mask))\n\t\treturn;\n\n\tmutex_lock(&sparx5->mact_lock);\n\tlist_for_each_entry(mact_entry, &sparx5->mact_entries, list) {\n\t\tif (mact_entry->vid == vid &&\n\t\t    ether_addr_equal(mac, mact_entry->mac)) {\n\t\t\tfound = true;\n\t\t\tmact_entry->flags |= MAC_ENT_ALIVE;\n\t\t\tif (mact_entry->port != port) {\n\t\t\t\tdev_warn(sparx5->dev, \"Entry move: %d -> %d\\n\",\n\t\t\t\t\t mact_entry->port, port);\n\t\t\t\tmact_entry->port = port;\n\t\t\t\tmact_entry->flags |= MAC_ENT_MOVED;\n\t\t\t}\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&sparx5->mact_lock);\n\n\tif (found && !(mact_entry->flags & MAC_ENT_MOVED))\n\t\t \n\t\treturn;\n\n\tif (!found) {\n\t\t \n\t\tmact_entry = alloc_mact_entry(sparx5, mac, vid, port);\n\t\tif (!mact_entry)\n\t\t\treturn;\n\n\t\tmact_entry->flags |= MAC_ENT_ALIVE;\n\t\tmutex_lock(&sparx5->mact_lock);\n\t\tlist_add_tail(&mact_entry->list, &sparx5->mact_entries);\n\t\tmutex_unlock(&sparx5->mact_lock);\n\t}\n\n\t \n\tsparx5_fdb_call_notifiers(SWITCHDEV_FDB_ADD_TO_BRIDGE,\n\t\t\t\t  mac, vid, sparx5->ports[port]->ndev,\n\t\t\t\t  true);\n}\n\nvoid sparx5_mact_pull_work(struct work_struct *work)\n{\n\tstruct delayed_work *del_work = to_delayed_work(work);\n\tstruct sparx5 *sparx5 = container_of(del_work, struct sparx5,\n\t\t\t\t\t     mact_work);\n\tstruct sparx5_mact_entry *mact_entry, *tmp;\n\tunsigned char mac[ETH_ALEN];\n\tu32 cfg2;\n\tu16 vid;\n\tint ret;\n\n\t \n\tmutex_lock(&sparx5->mact_lock);\n\tlist_for_each_entry(mact_entry, &sparx5->mact_entries, list)\n\t\tmact_entry->flags &= MAC_ENT_LOCK;\n\tmutex_unlock(&sparx5->mact_lock);\n\n\t \n\tvid = 0;\n\tmemset(mac, 0, sizeof(mac));\n\tdo {\n\t\tmutex_lock(&sparx5->lock);\n\t\tsparx5_mact_select(sparx5, mac, vid);\n\t\tspx5_wr(LRN_SCAN_NEXT_CFG_SCAN_NEXT_UNTIL_FOUND_ENA_SET(1),\n\t\t\tsparx5, LRN_SCAN_NEXT_CFG);\n\t\tspx5_wr(LRN_COMMON_ACCESS_CTRL_CPU_ACCESS_CMD_SET\n\t\t\t(MAC_CMD_FIND_SMALLEST) |\n\t\t\tLRN_COMMON_ACCESS_CTRL_MAC_TABLE_ACCESS_SHOT_SET(1),\n\t\t\tsparx5, LRN_COMMON_ACCESS_CTRL);\n\t\tret = sparx5_mact_wait_for_completion(sparx5);\n\t\tif (ret == 0)\n\t\t\tret = sparx5_mact_get(sparx5, mac, &vid, &cfg2);\n\t\tmutex_unlock(&sparx5->lock);\n\t\tif (ret == 0)\n\t\t\tsparx5_mact_handle_entry(sparx5, mac, vid, cfg2);\n\t} while (ret == 0);\n\n\tmutex_lock(&sparx5->mact_lock);\n\tlist_for_each_entry_safe(mact_entry, tmp, &sparx5->mact_entries,\n\t\t\t\t list) {\n\t\t \n\t\tif (mact_entry->flags & (MAC_ENT_ALIVE | MAC_ENT_LOCK))\n\t\t\tcontinue;\n\n\t\tsparx5_fdb_call_notifiers(SWITCHDEV_FDB_DEL_TO_BRIDGE,\n\t\t\t\t\t  mact_entry->mac, mact_entry->vid,\n\t\t\t\t\t  sparx5->ports[mact_entry->port]->ndev,\n\t\t\t\t\t  true);\n\n\t\tlist_del(&mact_entry->list);\n\t\tdevm_kfree(sparx5->dev, mact_entry);\n\t}\n\tmutex_unlock(&sparx5->mact_lock);\n\n\tqueue_delayed_work(sparx5->mact_queue, &sparx5->mact_work,\n\t\t\t   SPX5_MACT_PULL_DELAY);\n}\n\nvoid sparx5_set_ageing(struct sparx5 *sparx5, int msecs)\n{\n\tint value = max(1, msecs / 10);  \n\n\tspx5_rmw(LRN_AUTOAGE_CFG_UNIT_SIZE_SET(2) |  \n\t\t LRN_AUTOAGE_CFG_PERIOD_VAL_SET(value / 2),  \n\t\t LRN_AUTOAGE_CFG_UNIT_SIZE |\n\t\t LRN_AUTOAGE_CFG_PERIOD_VAL,\n\t\t sparx5,\n\t\t LRN_AUTOAGE_CFG(0));\n}\n\nvoid sparx5_mact_init(struct sparx5 *sparx5)\n{\n\tmutex_init(&sparx5->lock);\n\n\t \n\tspx5_wr(LRN_COMMON_ACCESS_CTRL_CPU_ACCESS_CMD_SET(MAC_CMD_CLEAR_ALL) |\n\t\tLRN_COMMON_ACCESS_CTRL_MAC_TABLE_ACCESS_SHOT_SET(1),\n\t\tsparx5, LRN_COMMON_ACCESS_CTRL);\n\n\tif (sparx5_mact_wait_for_completion(sparx5) != 0)\n\t\tdev_warn(sparx5->dev, \"MAC flush error\\n\");\n\n\tsparx5_set_ageing(sparx5, BR_DEFAULT_AGEING_TIME / HZ * 1000);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}