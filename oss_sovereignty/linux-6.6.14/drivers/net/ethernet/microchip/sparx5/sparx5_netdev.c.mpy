{
  "module_name": "sparx5_netdev.c",
  "hash_id": "b86374888aea2d6f2f6067dca3fbcdb0984deb76ff41e95ff0bf539a63b86574",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/microchip/sparx5/sparx5_netdev.c",
  "human_readable_source": "\n \n\n#include \"sparx5_main_regs.h\"\n#include \"sparx5_main.h\"\n#include \"sparx5_port.h\"\n#include \"sparx5_tc.h\"\n\n \n#define VSTAX 73\n\n#define ifh_encode_bitfield(ifh, value, pos, _width)\t\t\t\\\n\t({\t\t\t\t\t\t\t\t\\\n\t\tu32 width = (_width);\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\t \t\t\t\t\t\t\t\\\n\t\tcompiletime_assert(width <= 40,\t\t\t\t\\\n\t\t\t\t   \"Unsupported width, must be <= 40\");\t\\\n\t\t__ifh_encode_bitfield((ifh), (value), (pos), width);\t\\\n\t})\n\nstatic void __ifh_encode_bitfield(void *ifh, u64 value, u32 pos, u32 width)\n{\n\tu8 *ifh_hdr = ifh;\n\t \n\tu32 byte = (35 - (pos / 8));\n\t \n\tu32 bit  = (pos % 8);\n\tu64 encode = GENMASK_ULL(bit + width - 1, bit) & (value << bit);\n\n\t \n\tif (encode & 0xFF)\n\t\tifh_hdr[byte] |= (u8)((encode & 0xFF));\n\t \n\tif (encode & 0xFF00)\n\t\tifh_hdr[byte - 1] |= (u8)((encode & 0xFF00) >> 8);\n\t \n\tif (encode & 0xFF0000)\n\t\tifh_hdr[byte - 2] |= (u8)((encode & 0xFF0000) >> 16);\n\t \n\tif (encode & 0xFF000000)\n\t\tifh_hdr[byte - 3] |= (u8)((encode & 0xFF000000) >> 24);\n\t \n\tif (encode & 0xFF00000000)\n\t\tifh_hdr[byte - 4] |= (u8)((encode & 0xFF00000000) >> 32);\n\t \n\tif (encode & 0xFF0000000000)\n\t\tifh_hdr[byte - 5] |= (u8)((encode & 0xFF0000000000) >> 40);\n}\n\nvoid sparx5_set_port_ifh(void *ifh_hdr, u16 portno)\n{\n\t \n\tifh_encode_bitfield(ifh_hdr, 1, VSTAX + 79,  1);\n\t \n\tifh_encode_bitfield(ifh_hdr, 1, VSTAX + 55,  1);\n\t \n\tifh_encode_bitfield(ifh_hdr, portno,   29, 8);\n\t \n\tifh_encode_bitfield(ifh_hdr, 16,       37, 5);\n\t \n\tifh_encode_bitfield(ifh_hdr, 1,        42, 3);\n\t \n\tifh_encode_bitfield(ifh_hdr, SPX5_PORT_CPU, 46, 7);\n\t \n\tifh_encode_bitfield(ifh_hdr, 124,      57, 7);\n\t \n\tifh_encode_bitfield(ifh_hdr, 1,        67, 1);\n}\n\nvoid sparx5_set_port_ifh_rew_op(void *ifh_hdr, u32 rew_op)\n{\n\tifh_encode_bitfield(ifh_hdr, rew_op, VSTAX + 32,  10);\n}\n\nvoid sparx5_set_port_ifh_pdu_type(void *ifh_hdr, u32 pdu_type)\n{\n\tifh_encode_bitfield(ifh_hdr, pdu_type, 191, 4);\n}\n\nvoid sparx5_set_port_ifh_pdu_w16_offset(void *ifh_hdr, u32 pdu_w16_offset)\n{\n\tifh_encode_bitfield(ifh_hdr, pdu_w16_offset, 195, 6);\n}\n\nvoid sparx5_set_port_ifh_timestamp(void *ifh_hdr, u64 timestamp)\n{\n\tifh_encode_bitfield(ifh_hdr, timestamp, 232,  40);\n}\n\nstatic int sparx5_port_open(struct net_device *ndev)\n{\n\tstruct sparx5_port *port = netdev_priv(ndev);\n\tint err = 0;\n\n\tsparx5_port_enable(port, true);\n\terr = phylink_of_phy_connect(port->phylink, port->of_node, 0);\n\tif (err) {\n\t\tnetdev_err(ndev, \"Could not attach to PHY\\n\");\n\t\tgoto err_connect;\n\t}\n\n\tphylink_start(port->phylink);\n\n\tif (!ndev->phydev) {\n\t\t \n\t\tport->conf.power_down = false;\n\t\tif (port->conf.serdes_reset)\n\t\t\terr = sparx5_serdes_set(port->sparx5, port, &port->conf);\n\t\telse\n\t\t\terr = phy_power_on(port->serdes);\n\t\tif (err) {\n\t\t\tnetdev_err(ndev, \"%s failed\\n\", __func__);\n\t\t\tgoto out_power;\n\t\t}\n\t}\n\n\treturn 0;\n\nout_power:\n\tphylink_stop(port->phylink);\n\tphylink_disconnect_phy(port->phylink);\nerr_connect:\n\tsparx5_port_enable(port, false);\n\n\treturn err;\n}\n\nstatic int sparx5_port_stop(struct net_device *ndev)\n{\n\tstruct sparx5_port *port = netdev_priv(ndev);\n\tint err = 0;\n\n\tsparx5_port_enable(port, false);\n\tphylink_stop(port->phylink);\n\tphylink_disconnect_phy(port->phylink);\n\n\tif (!ndev->phydev) {\n\t\t \n\t\tport->conf.power_down = true;\n\t\tif (port->conf.serdes_reset)\n\t\t\terr = sparx5_serdes_set(port->sparx5, port, &port->conf);\n\t\telse\n\t\t\terr = phy_power_off(port->serdes);\n\t\tif (err)\n\t\t\tnetdev_err(ndev, \"%s failed\\n\", __func__);\n\t}\n\treturn 0;\n}\n\nstatic void sparx5_set_rx_mode(struct net_device *dev)\n{\n\tstruct sparx5_port *port = netdev_priv(dev);\n\tstruct sparx5 *sparx5 = port->sparx5;\n\n\tif (!test_bit(port->portno, sparx5->bridge_mask))\n\t\t__dev_mc_sync(dev, sparx5_mc_sync, sparx5_mc_unsync);\n}\n\nstatic int sparx5_port_get_phys_port_name(struct net_device *dev,\n\t\t\t\t\t  char *buf, size_t len)\n{\n\tstruct sparx5_port *port = netdev_priv(dev);\n\tint ret;\n\n\tret = snprintf(buf, len, \"p%d\", port->portno);\n\tif (ret >= len)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int sparx5_set_mac_address(struct net_device *dev, void *p)\n{\n\tstruct sparx5_port *port = netdev_priv(dev);\n\tstruct sparx5 *sparx5 = port->sparx5;\n\tconst struct sockaddr *addr = p;\n\n\tif (!is_valid_ether_addr(addr->sa_data))\n\t\treturn -EADDRNOTAVAIL;\n\n\t \n\tsparx5_mact_forget(sparx5, dev->dev_addr,  port->pvid);\n\n\t \n\tsparx5_mact_learn(sparx5, PGID_CPU, addr->sa_data, port->pvid);\n\n\t \n\teth_hw_addr_set(dev, addr->sa_data);\n\n\treturn 0;\n}\n\nstatic int sparx5_get_port_parent_id(struct net_device *dev,\n\t\t\t\t     struct netdev_phys_item_id *ppid)\n{\n\tstruct sparx5_port *sparx5_port = netdev_priv(dev);\n\tstruct sparx5 *sparx5 = sparx5_port->sparx5;\n\n\tppid->id_len = sizeof(sparx5->base_mac);\n\tmemcpy(&ppid->id, &sparx5->base_mac, ppid->id_len);\n\n\treturn 0;\n}\n\nstatic int sparx5_port_hwtstamp_get(struct net_device *dev,\n\t\t\t\t    struct kernel_hwtstamp_config *cfg)\n{\n\tstruct sparx5_port *sparx5_port = netdev_priv(dev);\n\tstruct sparx5 *sparx5 = sparx5_port->sparx5;\n\n\tif (!sparx5->ptp)\n\t\treturn -EOPNOTSUPP;\n\n\tsparx5_ptp_hwtstamp_get(sparx5_port, cfg);\n\n\treturn 0;\n}\n\nstatic int sparx5_port_hwtstamp_set(struct net_device *dev,\n\t\t\t\t    struct kernel_hwtstamp_config *cfg,\n\t\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct sparx5_port *sparx5_port = netdev_priv(dev);\n\tstruct sparx5 *sparx5 = sparx5_port->sparx5;\n\n\tif (!sparx5->ptp)\n\t\treturn -EOPNOTSUPP;\n\n\treturn sparx5_ptp_hwtstamp_set(sparx5_port, cfg, extack);\n}\n\nstatic const struct net_device_ops sparx5_port_netdev_ops = {\n\t.ndo_open               = sparx5_port_open,\n\t.ndo_stop               = sparx5_port_stop,\n\t.ndo_start_xmit         = sparx5_port_xmit_impl,\n\t.ndo_set_rx_mode        = sparx5_set_rx_mode,\n\t.ndo_get_phys_port_name = sparx5_port_get_phys_port_name,\n\t.ndo_set_mac_address    = sparx5_set_mac_address,\n\t.ndo_validate_addr      = eth_validate_addr,\n\t.ndo_get_stats64        = sparx5_get_stats64,\n\t.ndo_get_port_parent_id = sparx5_get_port_parent_id,\n\t.ndo_eth_ioctl          = phy_do_ioctl,\n\t.ndo_setup_tc           = sparx5_port_setup_tc,\n\t.ndo_hwtstamp_get       = sparx5_port_hwtstamp_get,\n\t.ndo_hwtstamp_set       = sparx5_port_hwtstamp_set,\n};\n\nbool sparx5_netdevice_check(const struct net_device *dev)\n{\n\treturn dev && (dev->netdev_ops == &sparx5_port_netdev_ops);\n}\n\nstruct net_device *sparx5_create_netdev(struct sparx5 *sparx5, u32 portno)\n{\n\tstruct sparx5_port *spx5_port;\n\tstruct net_device *ndev;\n\n\tndev = devm_alloc_etherdev_mqs(sparx5->dev, sizeof(struct sparx5_port),\n\t\t\t\t       SPX5_PRIOS, 1);\n\tif (!ndev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tndev->hw_features |= NETIF_F_HW_TC;\n\tndev->features |= NETIF_F_HW_TC;\n\n\tSET_NETDEV_DEV(ndev, sparx5->dev);\n\tspx5_port = netdev_priv(ndev);\n\tspx5_port->ndev = ndev;\n\tspx5_port->sparx5 = sparx5;\n\tspx5_port->portno = portno;\n\n\tndev->netdev_ops = &sparx5_port_netdev_ops;\n\tndev->ethtool_ops = &sparx5_ethtool_ops;\n\n\teth_hw_addr_gen(ndev, sparx5->base_mac, portno + 1);\n\n\treturn ndev;\n}\n\nint sparx5_register_netdevs(struct sparx5 *sparx5)\n{\n\tint portno;\n\tint err;\n\n\tfor (portno = 0; portno < SPX5_PORTS; portno++)\n\t\tif (sparx5->ports[portno]) {\n\t\t\terr = register_netdev(sparx5->ports[portno]->ndev);\n\t\t\tif (err) {\n\t\t\t\tdev_err(sparx5->dev,\n\t\t\t\t\t\"port: %02u: netdev registration failed\\n\",\n\t\t\t\t\tportno);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t\tsparx5_port_inj_timer_setup(sparx5->ports[portno]);\n\t\t}\n\treturn 0;\n}\n\nvoid sparx5_destroy_netdevs(struct sparx5 *sparx5)\n{\n\tstruct sparx5_port *port;\n\tint portno;\n\n\tfor (portno = 0; portno < SPX5_PORTS; portno++) {\n\t\tport = sparx5->ports[portno];\n\t\tif (port && port->phylink) {\n\t\t\t \n\t\t\trtnl_lock();\n\t\t\tsparx5_port_stop(port->ndev);\n\t\t\tphylink_disconnect_phy(port->phylink);\n\t\t\trtnl_unlock();\n\t\t\tphylink_destroy(port->phylink);\n\t\t\tport->phylink = NULL;\n\t\t}\n\t}\n}\n\nvoid sparx5_unregister_netdevs(struct sparx5 *sparx5)\n{\n\tint portno;\n\n\tfor (portno = 0; portno < SPX5_PORTS; portno++)\n\t\tif (sparx5->ports[portno])\n\t\t\tunregister_netdev(sparx5->ports[portno]->ndev);\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}