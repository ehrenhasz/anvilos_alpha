{
  "module_name": "sparx5_vcap_impl.c",
  "hash_id": "2852ccbca0fc78d1c9f40f84412510dc92142e9d77945f13b664b508aee6463a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/microchip/sparx5/sparx5_vcap_impl.c",
  "human_readable_source": "\n \n\n#include \"vcap_api_debugfs.h\"\n#include \"sparx5_main_regs.h\"\n#include \"sparx5_main.h\"\n#include \"sparx5_vcap_impl.h\"\n#include \"sparx5_vcap_ag_api.h\"\n#include \"sparx5_vcap_debugfs.h\"\n\n#define SUPER_VCAP_BLK_SIZE 3072  \n#define STREAMSIZE (64 * 4)   \n\n#define SPARX5_IS2_LOOKUPS 4\n#define VCAP_IS2_KEYSEL(_ena, _noneth, _v4_mc, _v4_uc, _v6_mc, _v6_uc, _arp) \\\n\t(ANA_ACL_VCAP_S2_KEY_SEL_KEY_SEL_ENA_SET(_ena) | \\\n\t ANA_ACL_VCAP_S2_KEY_SEL_NON_ETH_KEY_SEL_SET(_noneth) | \\\n\t ANA_ACL_VCAP_S2_KEY_SEL_IP4_MC_KEY_SEL_SET(_v4_mc) | \\\n\t ANA_ACL_VCAP_S2_KEY_SEL_IP4_UC_KEY_SEL_SET(_v4_uc) | \\\n\t ANA_ACL_VCAP_S2_KEY_SEL_IP6_MC_KEY_SEL_SET(_v6_mc) | \\\n\t ANA_ACL_VCAP_S2_KEY_SEL_IP6_UC_KEY_SEL_SET(_v6_uc) | \\\n\t ANA_ACL_VCAP_S2_KEY_SEL_ARP_KEY_SEL_SET(_arp))\n\n#define SPARX5_IS0_LOOKUPS 6\n#define VCAP_IS0_KEYSEL(_ena, _etype, _ipv4, _ipv6, _mpls_uc, _mpls_mc, _mlbs) \\\n\t(ANA_CL_ADV_CL_CFG_LOOKUP_ENA_SET(_ena) | \\\n\tANA_CL_ADV_CL_CFG_ETYPE_CLM_KEY_SEL_SET(_etype) | \\\n\tANA_CL_ADV_CL_CFG_IP4_CLM_KEY_SEL_SET(_ipv4) | \\\n\tANA_CL_ADV_CL_CFG_IP6_CLM_KEY_SEL_SET(_ipv6) | \\\n\tANA_CL_ADV_CL_CFG_MPLS_UC_CLM_KEY_SEL_SET(_mpls_uc) | \\\n\tANA_CL_ADV_CL_CFG_MPLS_MC_CLM_KEY_SEL_SET(_mpls_mc) | \\\n\tANA_CL_ADV_CL_CFG_MLBS_CLM_KEY_SEL_SET(_mlbs))\n\n#define SPARX5_ES0_LOOKUPS 1\n#define VCAP_ES0_KEYSEL(_key) (REW_RTAG_ETAG_CTRL_ES0_ISDX_KEY_ENA_SET(_key))\n#define SPARX5_STAT_ESDX_GRN_PKTS  0x300\n#define SPARX5_STAT_ESDX_YEL_PKTS  0x301\n\n#define SPARX5_ES2_LOOKUPS 2\n#define VCAP_ES2_KEYSEL(_ena, _arp, _ipv4, _ipv6) \\\n\t(EACL_VCAP_ES2_KEY_SEL_KEY_ENA_SET(_ena) | \\\n\tEACL_VCAP_ES2_KEY_SEL_ARP_KEY_SEL_SET(_arp) | \\\n\tEACL_VCAP_ES2_KEY_SEL_IP4_KEY_SEL_SET(_ipv4) | \\\n\tEACL_VCAP_ES2_KEY_SEL_IP6_KEY_SEL_SET(_ipv6))\n\nstatic struct sparx5_vcap_inst {\n\tenum vcap_type vtype;  \n\tint vinst;  \n\tint lookups;  \n\tint lookups_per_instance;  \n\tint first_cid;  \n\tint last_cid;  \n\tint count;  \n\tint map_id;  \n\tint blockno;  \n\tint blocks;  \n\tbool ingress;  \n} sparx5_vcap_inst_cfg[] = {\n\t{\n\t\t.vtype = VCAP_TYPE_IS0,  \n\t\t.vinst = 0,\n\t\t.map_id = 1,\n\t\t.lookups = SPARX5_IS0_LOOKUPS,\n\t\t.lookups_per_instance = SPARX5_IS0_LOOKUPS / 3,\n\t\t.first_cid = SPARX5_VCAP_CID_IS0_L0,\n\t\t.last_cid = SPARX5_VCAP_CID_IS0_L2 - 1,\n\t\t.blockno = 8,  \n\t\t.blocks = 2,\n\t\t.ingress = true,\n\t},\n\t{\n\t\t.vtype = VCAP_TYPE_IS0,  \n\t\t.vinst = 1,\n\t\t.map_id = 2,\n\t\t.lookups = SPARX5_IS0_LOOKUPS,\n\t\t.lookups_per_instance = SPARX5_IS0_LOOKUPS / 3,\n\t\t.first_cid = SPARX5_VCAP_CID_IS0_L2,\n\t\t.last_cid = SPARX5_VCAP_CID_IS0_L4 - 1,\n\t\t.blockno = 6,  \n\t\t.blocks = 2,\n\t\t.ingress = true,\n\t},\n\t{\n\t\t.vtype = VCAP_TYPE_IS0,  \n\t\t.vinst = 2,\n\t\t.map_id = 3,\n\t\t.lookups = SPARX5_IS0_LOOKUPS,\n\t\t.lookups_per_instance = SPARX5_IS0_LOOKUPS / 3,\n\t\t.first_cid = SPARX5_VCAP_CID_IS0_L4,\n\t\t.last_cid = SPARX5_VCAP_CID_IS0_MAX,\n\t\t.blockno = 4,  \n\t\t.blocks = 2,\n\t\t.ingress = true,\n\t},\n\t{\n\t\t.vtype = VCAP_TYPE_IS2,  \n\t\t.vinst = 0,\n\t\t.map_id = 4,\n\t\t.lookups = SPARX5_IS2_LOOKUPS,\n\t\t.lookups_per_instance = SPARX5_IS2_LOOKUPS / 2,\n\t\t.first_cid = SPARX5_VCAP_CID_IS2_L0,\n\t\t.last_cid = SPARX5_VCAP_CID_IS2_L2 - 1,\n\t\t.blockno = 0,  \n\t\t.blocks = 2,\n\t\t.ingress = true,\n\t},\n\t{\n\t\t.vtype = VCAP_TYPE_IS2,  \n\t\t.vinst = 1,\n\t\t.map_id = 5,\n\t\t.lookups = SPARX5_IS2_LOOKUPS,\n\t\t.lookups_per_instance = SPARX5_IS2_LOOKUPS / 2,\n\t\t.first_cid = SPARX5_VCAP_CID_IS2_L2,\n\t\t.last_cid = SPARX5_VCAP_CID_IS2_MAX,\n\t\t.blockno = 2,  \n\t\t.blocks = 2,\n\t\t.ingress = true,\n\t},\n\t{\n\t\t.vtype = VCAP_TYPE_ES0,\n\t\t.lookups = SPARX5_ES0_LOOKUPS,\n\t\t.lookups_per_instance = SPARX5_ES0_LOOKUPS,\n\t\t.first_cid = SPARX5_VCAP_CID_ES0_L0,\n\t\t.last_cid = SPARX5_VCAP_CID_ES0_MAX,\n\t\t.count = 4096,  \n\t\t.ingress = false,\n\t},\n\t{\n\t\t.vtype = VCAP_TYPE_ES2,\n\t\t.lookups = SPARX5_ES2_LOOKUPS,\n\t\t.lookups_per_instance = SPARX5_ES2_LOOKUPS,\n\t\t.first_cid = SPARX5_VCAP_CID_ES2_L0,\n\t\t.last_cid = SPARX5_VCAP_CID_ES2_MAX,\n\t\t.count = 12288,  \n\t\t.ingress = false,\n\t},\n};\n\n \nstatic u16 sparx5_vcap_is0_known_etypes[] = {\n\tETH_P_ALL,\n\tETH_P_IP,\n\tETH_P_IPV6,\n};\n\n \nstatic u16 sparx5_vcap_is2_known_etypes[] = {\n\tETH_P_ALL,\n\tETH_P_ARP,\n\tETH_P_IP,\n\tETH_P_IPV6,\n};\n\n \nstatic u16 sparx5_vcap_es2_known_etypes[] = {\n\tETH_P_ALL,\n\tETH_P_ARP,\n\tETH_P_IP,\n\tETH_P_IPV6,\n};\n\nstatic void sparx5_vcap_type_err(struct sparx5 *sparx5,\n\t\t\t\t struct vcap_admin *admin,\n\t\t\t\t const char *fname)\n{\n\tpr_err(\"%s: vcap type: %s not supported\\n\",\n\t       fname, sparx5_vcaps[admin->vtype].name);\n}\n\n \nstatic void sparx5_vcap_wait_super_update(struct sparx5 *sparx5)\n{\n\tu32 value;\n\n\tread_poll_timeout(spx5_rd, value,\n\t\t\t  !VCAP_SUPER_CTRL_UPDATE_SHOT_GET(value), 500, 10000,\n\t\t\t  false, sparx5, VCAP_SUPER_CTRL);\n}\n\n \nstatic void sparx5_vcap_wait_es0_update(struct sparx5 *sparx5)\n{\n\tu32 value;\n\n\tread_poll_timeout(spx5_rd, value,\n\t\t\t  !VCAP_ES0_CTRL_UPDATE_SHOT_GET(value), 500, 10000,\n\t\t\t  false, sparx5, VCAP_ES0_CTRL);\n}\n\n \nstatic void sparx5_vcap_wait_es2_update(struct sparx5 *sparx5)\n{\n\tu32 value;\n\n\tread_poll_timeout(spx5_rd, value,\n\t\t\t  !VCAP_ES2_CTRL_UPDATE_SHOT_GET(value), 500, 10000,\n\t\t\t  false, sparx5, VCAP_ES2_CTRL);\n}\n\n \nstatic void _sparx5_vcap_range_init(struct sparx5 *sparx5,\n\t\t\t\t    struct vcap_admin *admin,\n\t\t\t\t    u32 addr, u32 count)\n{\n\tu32 size = count - 1;\n\n\tswitch (admin->vtype) {\n\tcase VCAP_TYPE_IS0:\n\tcase VCAP_TYPE_IS2:\n\t\tspx5_wr(VCAP_SUPER_CFG_MV_NUM_POS_SET(0) |\n\t\t\tVCAP_SUPER_CFG_MV_SIZE_SET(size),\n\t\t\tsparx5, VCAP_SUPER_CFG);\n\t\tspx5_wr(VCAP_SUPER_CTRL_UPDATE_CMD_SET(VCAP_CMD_INITIALIZE) |\n\t\t\tVCAP_SUPER_CTRL_UPDATE_ENTRY_DIS_SET(0) |\n\t\t\tVCAP_SUPER_CTRL_UPDATE_ACTION_DIS_SET(0) |\n\t\t\tVCAP_SUPER_CTRL_UPDATE_CNT_DIS_SET(0) |\n\t\t\tVCAP_SUPER_CTRL_UPDATE_ADDR_SET(addr) |\n\t\t\tVCAP_SUPER_CTRL_CLEAR_CACHE_SET(true) |\n\t\t\tVCAP_SUPER_CTRL_UPDATE_SHOT_SET(true),\n\t\t\tsparx5, VCAP_SUPER_CTRL);\n\t\tsparx5_vcap_wait_super_update(sparx5);\n\t\tbreak;\n\tcase VCAP_TYPE_ES0:\n\t\tspx5_wr(VCAP_ES0_CFG_MV_NUM_POS_SET(0) |\n\t\t\t\tVCAP_ES0_CFG_MV_SIZE_SET(size),\n\t\t\tsparx5, VCAP_ES0_CFG);\n\t\tspx5_wr(VCAP_ES0_CTRL_UPDATE_CMD_SET(VCAP_CMD_INITIALIZE) |\n\t\t\t\tVCAP_ES0_CTRL_UPDATE_ENTRY_DIS_SET(0) |\n\t\t\t\tVCAP_ES0_CTRL_UPDATE_ACTION_DIS_SET(0) |\n\t\t\t\tVCAP_ES0_CTRL_UPDATE_CNT_DIS_SET(0) |\n\t\t\t\tVCAP_ES0_CTRL_UPDATE_ADDR_SET(addr) |\n\t\t\t\tVCAP_ES0_CTRL_CLEAR_CACHE_SET(true) |\n\t\t\t\tVCAP_ES0_CTRL_UPDATE_SHOT_SET(true),\n\t\t\tsparx5, VCAP_ES0_CTRL);\n\t\tsparx5_vcap_wait_es0_update(sparx5);\n\t\tbreak;\n\tcase VCAP_TYPE_ES2:\n\t\tspx5_wr(VCAP_ES2_CFG_MV_NUM_POS_SET(0) |\n\t\t\tVCAP_ES2_CFG_MV_SIZE_SET(size),\n\t\t\tsparx5, VCAP_ES2_CFG);\n\t\tspx5_wr(VCAP_ES2_CTRL_UPDATE_CMD_SET(VCAP_CMD_INITIALIZE) |\n\t\t\tVCAP_ES2_CTRL_UPDATE_ENTRY_DIS_SET(0) |\n\t\t\tVCAP_ES2_CTRL_UPDATE_ACTION_DIS_SET(0) |\n\t\t\tVCAP_ES2_CTRL_UPDATE_CNT_DIS_SET(0) |\n\t\t\tVCAP_ES2_CTRL_UPDATE_ADDR_SET(addr) |\n\t\t\tVCAP_ES2_CTRL_CLEAR_CACHE_SET(true) |\n\t\t\tVCAP_ES2_CTRL_UPDATE_SHOT_SET(true),\n\t\t\tsparx5, VCAP_ES2_CTRL);\n\t\tsparx5_vcap_wait_es2_update(sparx5);\n\t\tbreak;\n\tdefault:\n\t\tsparx5_vcap_type_err(sparx5, admin, __func__);\n\t\tbreak;\n\t}\n}\n\n \nstatic void sparx5_vcap_block_init(struct sparx5 *sparx5,\n\t\t\t\t   struct vcap_admin *admin)\n{\n\t_sparx5_vcap_range_init(sparx5, admin, admin->first_valid_addr,\n\t\t\t\tadmin->last_valid_addr -\n\t\t\t\t\tadmin->first_valid_addr);\n}\n\n \nstatic const char *sparx5_vcap_keyset_name(struct net_device *ndev,\n\t\t\t\t\t   enum vcap_keyfield_set keyset)\n{\n\tstruct sparx5_port *port = netdev_priv(ndev);\n\n\treturn vcap_keyset_name(port->sparx5->vcap_ctrl, keyset);\n}\n\n \nstatic bool sparx5_vcap_is0_is_first_chain(struct vcap_rule *rule)\n{\n\treturn (rule->vcap_chain_id >= SPARX5_VCAP_CID_IS0_L0 &&\n\t\trule->vcap_chain_id < SPARX5_VCAP_CID_IS0_L1) ||\n\t\t((rule->vcap_chain_id >= SPARX5_VCAP_CID_IS0_L2 &&\n\t\t  rule->vcap_chain_id < SPARX5_VCAP_CID_IS0_L3)) ||\n\t\t((rule->vcap_chain_id >= SPARX5_VCAP_CID_IS0_L4 &&\n\t\t  rule->vcap_chain_id < SPARX5_VCAP_CID_IS0_L5));\n}\n\n \nstatic bool sparx5_vcap_is2_is_first_chain(struct vcap_rule *rule)\n{\n\treturn (rule->vcap_chain_id >= SPARX5_VCAP_CID_IS2_L0 &&\n\t\trule->vcap_chain_id < SPARX5_VCAP_CID_IS2_L1) ||\n\t\t((rule->vcap_chain_id >= SPARX5_VCAP_CID_IS2_L2 &&\n\t\t  rule->vcap_chain_id < SPARX5_VCAP_CID_IS2_L3));\n}\n\nstatic bool sparx5_vcap_es2_is_first_chain(struct vcap_rule *rule)\n{\n\treturn (rule->vcap_chain_id >= SPARX5_VCAP_CID_ES2_L0 &&\n\t\trule->vcap_chain_id < SPARX5_VCAP_CID_ES2_L1);\n}\n\n \nstatic void sparx5_vcap_add_ingress_range_port_mask(struct vcap_rule *rule,\n\t\t\t\t\t\t    struct net_device *ndev)\n{\n\tstruct sparx5_port *port = netdev_priv(ndev);\n\tu32 port_mask;\n\tu32 range;\n\n\trange = port->portno / BITS_PER_TYPE(u32);\n\t \n\tport_mask = ~BIT(port->portno % BITS_PER_TYPE(u32));\n\tvcap_rule_add_key_u32(rule, VCAP_KF_IF_IGR_PORT_MASK_SEL, 0, 0xf);\n\tvcap_rule_add_key_u32(rule, VCAP_KF_IF_IGR_PORT_MASK_RNG, range, 0xf);\n\tvcap_rule_add_key_u32(rule, VCAP_KF_IF_IGR_PORT_MASK, 0, port_mask);\n}\n\n \nstatic void sparx5_vcap_add_wide_port_mask(struct vcap_rule *rule,\n\t\t\t\t\t   struct net_device *ndev)\n{\n\tstruct sparx5_port *port = netdev_priv(ndev);\n\tstruct vcap_u72_key port_mask;\n\tu32 range;\n\n\t \n\tmemset(port_mask.value, 0, sizeof(port_mask.value));\n\tmemset(port_mask.mask, 0xff, sizeof(port_mask.mask));\n\trange = port->portno / BITS_PER_BYTE;\n\tport_mask.mask[range] = ~BIT(port->portno % BITS_PER_BYTE);\n\tvcap_rule_add_key_u72(rule, VCAP_KF_IF_IGR_PORT_MASK, &port_mask);\n}\n\nstatic void sparx5_vcap_add_egress_range_port_mask(struct vcap_rule *rule,\n\t\t\t\t\t\t   struct net_device *ndev)\n{\n\tstruct sparx5_port *port = netdev_priv(ndev);\n\tu32 port_mask;\n\tu32 range;\n\n\t \n\trange = port->portno / BITS_PER_TYPE(u32);\n\t \n\tport_mask = ~BIT(port->portno % BITS_PER_TYPE(u32));\n\tvcap_rule_add_key_u32(rule, VCAP_KF_IF_EGR_PORT_MASK_RNG, range, 0xf);\n\tvcap_rule_add_key_u32(rule, VCAP_KF_IF_EGR_PORT_MASK, 0, port_mask);\n}\n\n \nstatic int sparx5_vcap_is0_cid_to_lookup(int cid)\n{\n\tint lookup = 0;\n\n\tif (cid >= SPARX5_VCAP_CID_IS0_L1 && cid < SPARX5_VCAP_CID_IS0_L2)\n\t\tlookup = 1;\n\telse if (cid >= SPARX5_VCAP_CID_IS0_L2 && cid < SPARX5_VCAP_CID_IS0_L3)\n\t\tlookup = 2;\n\telse if (cid >= SPARX5_VCAP_CID_IS0_L3 && cid < SPARX5_VCAP_CID_IS0_L4)\n\t\tlookup = 3;\n\telse if (cid >= SPARX5_VCAP_CID_IS0_L4 && cid < SPARX5_VCAP_CID_IS0_L5)\n\t\tlookup = 4;\n\telse if (cid >= SPARX5_VCAP_CID_IS0_L5 && cid < SPARX5_VCAP_CID_IS0_MAX)\n\t\tlookup = 5;\n\n\treturn lookup;\n}\n\n \nstatic int sparx5_vcap_is2_cid_to_lookup(int cid)\n{\n\tint lookup = 0;\n\n\tif (cid >= SPARX5_VCAP_CID_IS2_L1 && cid < SPARX5_VCAP_CID_IS2_L2)\n\t\tlookup = 1;\n\telse if (cid >= SPARX5_VCAP_CID_IS2_L2 && cid < SPARX5_VCAP_CID_IS2_L3)\n\t\tlookup = 2;\n\telse if (cid >= SPARX5_VCAP_CID_IS2_L3 && cid < SPARX5_VCAP_CID_IS2_MAX)\n\t\tlookup = 3;\n\n\treturn lookup;\n}\n\n \nstatic int sparx5_vcap_es2_cid_to_lookup(int cid)\n{\n\tint lookup = 0;\n\n\tif (cid >= SPARX5_VCAP_CID_ES2_L1)\n\t\tlookup = 1;\n\n\treturn lookup;\n}\n\n \nstatic void\nsparx5_vcap_is0_get_port_etype_keysets(struct vcap_keyset_list *keysetlist,\n\t\t\t\t       u32 value)\n{\n\tswitch (ANA_CL_ADV_CL_CFG_ETYPE_CLM_KEY_SEL_GET(value)) {\n\tcase VCAP_IS0_PS_ETYPE_NORMAL_7TUPLE:\n\t\tvcap_keyset_list_add(keysetlist, VCAP_KFS_NORMAL_7TUPLE);\n\t\tbreak;\n\tcase VCAP_IS0_PS_ETYPE_NORMAL_5TUPLE_IP4:\n\t\tvcap_keyset_list_add(keysetlist, VCAP_KFS_NORMAL_5TUPLE_IP4);\n\t\tbreak;\n\t}\n}\n\n \nstatic int sparx5_vcap_is0_get_port_keysets(struct net_device *ndev,\n\t\t\t\t\t    int lookup,\n\t\t\t\t\t    struct vcap_keyset_list *keysetlist,\n\t\t\t\t\t    u16 l3_proto)\n{\n\tstruct sparx5_port *port = netdev_priv(ndev);\n\tstruct sparx5 *sparx5 = port->sparx5;\n\tint portno = port->portno;\n\tu32 value;\n\n\tvalue = spx5_rd(sparx5, ANA_CL_ADV_CL_CFG(portno, lookup));\n\n\t \n\tif (l3_proto == ETH_P_ALL)\n\t\tsparx5_vcap_is0_get_port_etype_keysets(keysetlist, value);\n\n\tif (l3_proto == ETH_P_ALL || l3_proto == ETH_P_IP)\n\t\tswitch (ANA_CL_ADV_CL_CFG_IP4_CLM_KEY_SEL_GET(value)) {\n\t\tcase VCAP_IS0_PS_ETYPE_DEFAULT:\n\t\t\tsparx5_vcap_is0_get_port_etype_keysets(keysetlist,\n\t\t\t\t\t\t\t       value);\n\t\t\tbreak;\n\t\tcase VCAP_IS0_PS_ETYPE_NORMAL_7TUPLE:\n\t\t\tvcap_keyset_list_add(keysetlist,\n\t\t\t\t\t     VCAP_KFS_NORMAL_7TUPLE);\n\t\t\tbreak;\n\t\tcase VCAP_IS0_PS_ETYPE_NORMAL_5TUPLE_IP4:\n\t\t\tvcap_keyset_list_add(keysetlist,\n\t\t\t\t\t     VCAP_KFS_NORMAL_5TUPLE_IP4);\n\t\t\tbreak;\n\t\t}\n\n\tif (l3_proto == ETH_P_ALL || l3_proto == ETH_P_IPV6)\n\t\tswitch (ANA_CL_ADV_CL_CFG_IP6_CLM_KEY_SEL_GET(value)) {\n\t\tcase VCAP_IS0_PS_ETYPE_DEFAULT:\n\t\t\tsparx5_vcap_is0_get_port_etype_keysets(keysetlist,\n\t\t\t\t\t\t\t       value);\n\t\t\tbreak;\n\t\tcase VCAP_IS0_PS_ETYPE_NORMAL_7TUPLE:\n\t\t\tvcap_keyset_list_add(keysetlist,\n\t\t\t\t\t     VCAP_KFS_NORMAL_7TUPLE);\n\t\t\tbreak;\n\t\tcase VCAP_IS0_PS_ETYPE_NORMAL_5TUPLE_IP4:\n\t\t\tvcap_keyset_list_add(keysetlist,\n\t\t\t\t\t     VCAP_KFS_NORMAL_5TUPLE_IP4);\n\t\t\tbreak;\n\t\t}\n\n\tif (l3_proto != ETH_P_IP && l3_proto != ETH_P_IPV6)\n\t\tsparx5_vcap_is0_get_port_etype_keysets(keysetlist, value);\n\treturn 0;\n}\n\n \nstatic int sparx5_vcap_is2_get_port_keysets(struct net_device *ndev,\n\t\t\t\t\t    int lookup,\n\t\t\t\t\t    struct vcap_keyset_list *keysetlist,\n\t\t\t\t\t    u16 l3_proto)\n{\n\tstruct sparx5_port *port = netdev_priv(ndev);\n\tstruct sparx5 *sparx5 = port->sparx5;\n\tint portno = port->portno;\n\tu32 value;\n\n\tvalue = spx5_rd(sparx5, ANA_ACL_VCAP_S2_KEY_SEL(portno, lookup));\n\n\t \n\tif (l3_proto == ETH_P_ALL || l3_proto == ETH_P_ARP) {\n\t\tswitch (ANA_ACL_VCAP_S2_KEY_SEL_ARP_KEY_SEL_GET(value)) {\n\t\tcase VCAP_IS2_PS_ARP_MAC_ETYPE:\n\t\t\tvcap_keyset_list_add(keysetlist, VCAP_KFS_MAC_ETYPE);\n\t\t\tbreak;\n\t\tcase VCAP_IS2_PS_ARP_ARP:\n\t\t\tvcap_keyset_list_add(keysetlist, VCAP_KFS_ARP);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (l3_proto == ETH_P_ALL || l3_proto == ETH_P_IP) {\n\t\tswitch (ANA_ACL_VCAP_S2_KEY_SEL_IP4_UC_KEY_SEL_GET(value)) {\n\t\tcase VCAP_IS2_PS_IPV4_UC_MAC_ETYPE:\n\t\t\tvcap_keyset_list_add(keysetlist, VCAP_KFS_MAC_ETYPE);\n\t\t\tbreak;\n\t\tcase VCAP_IS2_PS_IPV4_UC_IP4_TCP_UDP_OTHER:\n\t\t\tvcap_keyset_list_add(keysetlist, VCAP_KFS_IP4_TCP_UDP);\n\t\t\tvcap_keyset_list_add(keysetlist, VCAP_KFS_IP4_OTHER);\n\t\t\tbreak;\n\t\tcase VCAP_IS2_PS_IPV4_UC_IP_7TUPLE:\n\t\t\tvcap_keyset_list_add(keysetlist, VCAP_KFS_IP_7TUPLE);\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (ANA_ACL_VCAP_S2_KEY_SEL_IP4_MC_KEY_SEL_GET(value)) {\n\t\tcase VCAP_IS2_PS_IPV4_MC_MAC_ETYPE:\n\t\t\tvcap_keyset_list_add(keysetlist, VCAP_KFS_MAC_ETYPE);\n\t\t\tbreak;\n\t\tcase VCAP_IS2_PS_IPV4_MC_IP4_TCP_UDP_OTHER:\n\t\t\tvcap_keyset_list_add(keysetlist, VCAP_KFS_IP4_TCP_UDP);\n\t\t\tvcap_keyset_list_add(keysetlist, VCAP_KFS_IP4_OTHER);\n\t\t\tbreak;\n\t\tcase VCAP_IS2_PS_IPV4_MC_IP_7TUPLE:\n\t\t\tvcap_keyset_list_add(keysetlist, VCAP_KFS_IP_7TUPLE);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (l3_proto == ETH_P_ALL || l3_proto == ETH_P_IPV6) {\n\t\tswitch (ANA_ACL_VCAP_S2_KEY_SEL_IP6_UC_KEY_SEL_GET(value)) {\n\t\tcase VCAP_IS2_PS_IPV6_UC_MAC_ETYPE:\n\t\t\tvcap_keyset_list_add(keysetlist, VCAP_KFS_MAC_ETYPE);\n\t\t\tbreak;\n\t\tcase VCAP_IS2_PS_IPV6_UC_IP_7TUPLE:\n\t\t\tvcap_keyset_list_add(keysetlist, VCAP_KFS_IP_7TUPLE);\n\t\t\tbreak;\n\t\tcase VCAP_IS2_PS_IPV6_UC_IP6_STD:\n\t\t\tvcap_keyset_list_add(keysetlist, VCAP_KFS_IP6_STD);\n\t\t\tbreak;\n\t\tcase VCAP_IS2_PS_IPV6_UC_IP4_TCP_UDP_OTHER:\n\t\t\tvcap_keyset_list_add(keysetlist, VCAP_KFS_IP4_TCP_UDP);\n\t\t\tvcap_keyset_list_add(keysetlist, VCAP_KFS_IP4_OTHER);\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (ANA_ACL_VCAP_S2_KEY_SEL_IP6_MC_KEY_SEL_GET(value)) {\n\t\tcase VCAP_IS2_PS_IPV6_MC_MAC_ETYPE:\n\t\t\tvcap_keyset_list_add(keysetlist, VCAP_KFS_MAC_ETYPE);\n\t\t\tbreak;\n\t\tcase VCAP_IS2_PS_IPV6_MC_IP_7TUPLE:\n\t\t\tvcap_keyset_list_add(keysetlist, VCAP_KFS_IP_7TUPLE);\n\t\t\tbreak;\n\t\tcase VCAP_IS2_PS_IPV6_MC_IP6_STD:\n\t\t\tvcap_keyset_list_add(keysetlist, VCAP_KFS_IP6_STD);\n\t\t\tbreak;\n\t\tcase VCAP_IS2_PS_IPV6_MC_IP4_TCP_UDP_OTHER:\n\t\t\tvcap_keyset_list_add(keysetlist, VCAP_KFS_IP4_TCP_UDP);\n\t\t\tvcap_keyset_list_add(keysetlist, VCAP_KFS_IP4_OTHER);\n\t\t\tbreak;\n\t\tcase VCAP_IS2_PS_IPV6_MC_IP6_VID:\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (l3_proto != ETH_P_ARP && l3_proto != ETH_P_IP &&\n\t    l3_proto != ETH_P_IPV6) {\n\t\tswitch (ANA_ACL_VCAP_S2_KEY_SEL_NON_ETH_KEY_SEL_GET(value)) {\n\t\tcase VCAP_IS2_PS_NONETH_MAC_ETYPE:\n\t\t\t \n\t\t\tvcap_keyset_list_add(keysetlist, VCAP_KFS_MAC_ETYPE);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nstatic void\nsparx5_vcap_es2_get_port_ipv4_keysets(struct vcap_keyset_list *keysetlist,\n\t\t\t\t      u32 value)\n{\n\tswitch (EACL_VCAP_ES2_KEY_SEL_IP4_KEY_SEL_GET(value)) {\n\tcase VCAP_ES2_PS_IPV4_MAC_ETYPE:\n\t\tvcap_keyset_list_add(keysetlist, VCAP_KFS_MAC_ETYPE);\n\t\tbreak;\n\tcase VCAP_ES2_PS_IPV4_IP_7TUPLE:\n\t\tvcap_keyset_list_add(keysetlist, VCAP_KFS_IP_7TUPLE);\n\t\tbreak;\n\tcase VCAP_ES2_PS_IPV4_IP4_TCP_UDP_VID:\n\t\tvcap_keyset_list_add(keysetlist, VCAP_KFS_IP4_TCP_UDP);\n\t\tbreak;\n\tcase VCAP_ES2_PS_IPV4_IP4_TCP_UDP_OTHER:\n\t\tvcap_keyset_list_add(keysetlist, VCAP_KFS_IP4_TCP_UDP);\n\t\tvcap_keyset_list_add(keysetlist, VCAP_KFS_IP4_OTHER);\n\t\tbreak;\n\tcase VCAP_ES2_PS_IPV4_IP4_VID:\n\t\t \n\t\tbreak;\n\tcase VCAP_ES2_PS_IPV4_IP4_OTHER:\n\t\tvcap_keyset_list_add(keysetlist, VCAP_KFS_IP4_OTHER);\n\t\tbreak;\n\t}\n}\n\n \nstatic int sparx5_vcap_es0_get_port_keysets(struct net_device *ndev,\n\t\t\t\t\t    struct vcap_keyset_list *keysetlist,\n\t\t\t\t\t    u16 l3_proto)\n{\n\tstruct sparx5_port *port = netdev_priv(ndev);\n\tstruct sparx5 *sparx5 = port->sparx5;\n\tint portno = port->portno;\n\tu32 value;\n\n\tvalue = spx5_rd(sparx5, REW_RTAG_ETAG_CTRL(portno));\n\n\t \n\tswitch (REW_RTAG_ETAG_CTRL_ES0_ISDX_KEY_ENA_GET(value)) {\n\tcase VCAP_ES0_PS_NORMAL_SELECTION:\n\tcase VCAP_ES0_PS_FORCE_ISDX_LOOKUPS:\n\t\tvcap_keyset_list_add(keysetlist, VCAP_KFS_ISDX);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\n \nstatic int sparx5_vcap_es2_get_port_keysets(struct net_device *ndev,\n\t\t\t\t\t    int lookup,\n\t\t\t\t\t    struct vcap_keyset_list *keysetlist,\n\t\t\t\t\t    u16 l3_proto)\n{\n\tstruct sparx5_port *port = netdev_priv(ndev);\n\tstruct sparx5 *sparx5 = port->sparx5;\n\tint portno = port->portno;\n\tu32 value;\n\n\tvalue = spx5_rd(sparx5, EACL_VCAP_ES2_KEY_SEL(portno, lookup));\n\n\t \n\tif (l3_proto == ETH_P_ALL || l3_proto == ETH_P_ARP) {\n\t\tswitch (EACL_VCAP_ES2_KEY_SEL_ARP_KEY_SEL_GET(value)) {\n\t\tcase VCAP_ES2_PS_ARP_MAC_ETYPE:\n\t\t\tvcap_keyset_list_add(keysetlist, VCAP_KFS_MAC_ETYPE);\n\t\t\tbreak;\n\t\tcase VCAP_ES2_PS_ARP_ARP:\n\t\t\tvcap_keyset_list_add(keysetlist, VCAP_KFS_ARP);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (l3_proto == ETH_P_ALL || l3_proto == ETH_P_IP)\n\t\tsparx5_vcap_es2_get_port_ipv4_keysets(keysetlist, value);\n\n\tif (l3_proto == ETH_P_ALL || l3_proto == ETH_P_IPV6) {\n\t\tswitch (EACL_VCAP_ES2_KEY_SEL_IP6_KEY_SEL_GET(value)) {\n\t\tcase VCAP_ES2_PS_IPV6_MAC_ETYPE:\n\t\t\tvcap_keyset_list_add(keysetlist, VCAP_KFS_MAC_ETYPE);\n\t\t\tbreak;\n\t\tcase VCAP_ES2_PS_IPV6_IP_7TUPLE:\n\t\t\tvcap_keyset_list_add(keysetlist, VCAP_KFS_IP_7TUPLE);\n\t\t\tbreak;\n\t\tcase VCAP_ES2_PS_IPV6_IP_7TUPLE_VID:\n\t\t\tvcap_keyset_list_add(keysetlist, VCAP_KFS_IP_7TUPLE);\n\t\t\tbreak;\n\t\tcase VCAP_ES2_PS_IPV6_IP_7TUPLE_STD:\n\t\t\tvcap_keyset_list_add(keysetlist, VCAP_KFS_IP_7TUPLE);\n\t\t\tvcap_keyset_list_add(keysetlist, VCAP_KFS_IP6_STD);\n\t\t\tbreak;\n\t\tcase VCAP_ES2_PS_IPV6_IP6_VID:\n\t\t\t \n\t\t\tbreak;\n\t\tcase VCAP_ES2_PS_IPV6_IP6_STD:\n\t\t\tvcap_keyset_list_add(keysetlist, VCAP_KFS_IP6_STD);\n\t\t\tbreak;\n\t\tcase VCAP_ES2_PS_IPV6_IP4_DOWNGRADE:\n\t\t\tsparx5_vcap_es2_get_port_ipv4_keysets(keysetlist,\n\t\t\t\t\t\t\t      value);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (l3_proto != ETH_P_ARP && l3_proto != ETH_P_IP &&\n\t    l3_proto != ETH_P_IPV6) {\n\t\tvcap_keyset_list_add(keysetlist, VCAP_KFS_MAC_ETYPE);\n\t}\n\treturn 0;\n}\n\n \nint sparx5_vcap_get_port_keyset(struct net_device *ndev,\n\t\t\t\tstruct vcap_admin *admin,\n\t\t\t\tint cid,\n\t\t\t\tu16 l3_proto,\n\t\t\t\tstruct vcap_keyset_list *kslist)\n{\n\tint lookup, err = -EINVAL;\n\tstruct sparx5_port *port;\n\n\tswitch (admin->vtype) {\n\tcase VCAP_TYPE_IS0:\n\t\tlookup = sparx5_vcap_is0_cid_to_lookup(cid);\n\t\terr = sparx5_vcap_is0_get_port_keysets(ndev, lookup, kslist,\n\t\t\t\t\t\t       l3_proto);\n\t\tbreak;\n\tcase VCAP_TYPE_IS2:\n\t\tlookup = sparx5_vcap_is2_cid_to_lookup(cid);\n\t\terr = sparx5_vcap_is2_get_port_keysets(ndev, lookup, kslist,\n\t\t\t\t\t\t       l3_proto);\n\t\tbreak;\n\tcase VCAP_TYPE_ES0:\n\t\terr = sparx5_vcap_es0_get_port_keysets(ndev, kslist, l3_proto);\n\t\tbreak;\n\tcase VCAP_TYPE_ES2:\n\t\tlookup = sparx5_vcap_es2_cid_to_lookup(cid);\n\t\terr = sparx5_vcap_es2_get_port_keysets(ndev, lookup, kslist,\n\t\t\t\t\t\t       l3_proto);\n\t\tbreak;\n\tdefault:\n\t\tport = netdev_priv(ndev);\n\t\tsparx5_vcap_type_err(port->sparx5, admin, __func__);\n\t\tbreak;\n\t}\n\treturn err;\n}\n\n \nbool sparx5_vcap_is_known_etype(struct vcap_admin *admin, u16 etype)\n{\n\tconst u16 *known_etypes;\n\tint size, idx;\n\n\tswitch (admin->vtype) {\n\tcase VCAP_TYPE_IS0:\n\t\tknown_etypes = sparx5_vcap_is0_known_etypes;\n\t\tsize = ARRAY_SIZE(sparx5_vcap_is0_known_etypes);\n\t\tbreak;\n\tcase VCAP_TYPE_IS2:\n\t\tknown_etypes = sparx5_vcap_is2_known_etypes;\n\t\tsize = ARRAY_SIZE(sparx5_vcap_is2_known_etypes);\n\t\tbreak;\n\tcase VCAP_TYPE_ES0:\n\t\treturn true;\n\tcase VCAP_TYPE_ES2:\n\t\tknown_etypes = sparx5_vcap_es2_known_etypes;\n\t\tsize = ARRAY_SIZE(sparx5_vcap_es2_known_etypes);\n\t\tbreak;\n\tdefault:\n\t\treturn false;\n\t}\n\tfor (idx = 0; idx < size; ++idx)\n\t\tif (known_etypes[idx] == etype)\n\t\t\treturn true;\n\treturn false;\n}\n\n \nstatic enum vcap_keyfield_set\nsparx5_vcap_validate_keyset(struct net_device *ndev,\n\t\t\t    struct vcap_admin *admin,\n\t\t\t    struct vcap_rule *rule,\n\t\t\t    struct vcap_keyset_list *kslist,\n\t\t\t    u16 l3_proto)\n{\n\tstruct vcap_keyset_list keysetlist = {};\n\tenum vcap_keyfield_set keysets[10] = {};\n\tstruct sparx5_port *port;\n\tint idx, jdx, lookup;\n\n\tif (!kslist || kslist->cnt == 0)\n\t\treturn VCAP_KFS_NO_VALUE;\n\n\tkeysetlist.max = ARRAY_SIZE(keysets);\n\tkeysetlist.keysets = keysets;\n\n\t \n\tswitch (admin->vtype) {\n\tcase VCAP_TYPE_IS0:\n\t\tlookup = sparx5_vcap_is0_cid_to_lookup(rule->vcap_chain_id);\n\t\tsparx5_vcap_is0_get_port_keysets(ndev, lookup, &keysetlist,\n\t\t\t\t\t\t l3_proto);\n\t\tbreak;\n\tcase VCAP_TYPE_IS2:\n\t\tlookup = sparx5_vcap_is2_cid_to_lookup(rule->vcap_chain_id);\n\t\tsparx5_vcap_is2_get_port_keysets(ndev, lookup, &keysetlist,\n\t\t\t\t\t\t l3_proto);\n\t\tbreak;\n\tcase VCAP_TYPE_ES0:\n\t\tsparx5_vcap_es0_get_port_keysets(ndev, &keysetlist, l3_proto);\n\t\tbreak;\n\tcase VCAP_TYPE_ES2:\n\t\tlookup = sparx5_vcap_es2_cid_to_lookup(rule->vcap_chain_id);\n\t\tsparx5_vcap_es2_get_port_keysets(ndev, lookup, &keysetlist,\n\t\t\t\t\t\t l3_proto);\n\t\tbreak;\n\tdefault:\n\t\tport = netdev_priv(ndev);\n\t\tsparx5_vcap_type_err(port->sparx5, admin, __func__);\n\t\tbreak;\n\t}\n\n\t \n\tfor (idx = 0; idx < kslist->cnt; ++idx)\n\t\tfor (jdx = 0; jdx < keysetlist.cnt; ++jdx)\n\t\t\tif (kslist->keysets[idx] == keysets[jdx])\n\t\t\t\treturn kslist->keysets[idx];\n\n\tpr_err(\"%s:%d: %s not supported in port key selection\\n\",\n\t       __func__, __LINE__,\n\t       sparx5_vcap_keyset_name(ndev, kslist->keysets[0]));\n\n\treturn -ENOENT;\n}\n\nstatic void sparx5_vcap_ingress_add_default_fields(struct net_device *ndev,\n\t\t\t\t\t\t   struct vcap_admin *admin,\n\t\t\t\t\t\t   struct vcap_rule *rule)\n{\n\tconst struct vcap_field *field;\n\tbool is_first;\n\n\t \n\tfield = vcap_lookup_keyfield(rule, VCAP_KF_IF_IGR_PORT_MASK);\n\tif (field && field->width == SPX5_PORTS)\n\t\tsparx5_vcap_add_wide_port_mask(rule, ndev);\n\telse if (field && field->width == BITS_PER_TYPE(u32))\n\t\tsparx5_vcap_add_ingress_range_port_mask(rule, ndev);\n\telse\n\t\tpr_err(\"%s:%d: %s: could not add an ingress port mask for: %s\\n\",\n\t\t       __func__, __LINE__, netdev_name(ndev),\n\t\t       sparx5_vcap_keyset_name(ndev, rule->keyset));\n\n\tif (admin->vtype == VCAP_TYPE_IS0)\n\t\tis_first = sparx5_vcap_is0_is_first_chain(rule);\n\telse\n\t\tis_first = sparx5_vcap_is2_is_first_chain(rule);\n\n\t \n\tif (is_first)\n\t\tvcap_rule_add_key_bit(rule, VCAP_KF_LOOKUP_FIRST_IS,\n\t\t\t\t      VCAP_BIT_1);\n\telse\n\t\tvcap_rule_add_key_bit(rule, VCAP_KF_LOOKUP_FIRST_IS,\n\t\t\t\t      VCAP_BIT_0);\n}\n\nstatic void sparx5_vcap_es0_add_default_fields(struct net_device *ndev,\n\t\t\t\t\t       struct vcap_admin *admin,\n\t\t\t\t\t       struct vcap_rule *rule)\n{\n\tstruct sparx5_port *port = netdev_priv(ndev);\n\n\tvcap_rule_add_key_u32(rule, VCAP_KF_IF_EGR_PORT_NO, port->portno, ~0);\n\t \n\tvcap_rule_add_key_u32(rule, VCAP_KF_8021Q_TPID, SPX5_TPID_SEL_UNTAGGED,\n\t\t\t      ~0);\n}\n\nstatic void sparx5_vcap_es2_add_default_fields(struct net_device *ndev,\n\t\t\t\t\t       struct vcap_admin *admin,\n\t\t\t\t\t       struct vcap_rule *rule)\n{\n\tconst struct vcap_field *field;\n\tbool is_first;\n\n\t \n\tfield = vcap_lookup_keyfield(rule, VCAP_KF_IF_EGR_PORT_MASK);\n\tif (field)\n\t\tsparx5_vcap_add_egress_range_port_mask(rule, ndev);\n\n\t \n\tis_first = sparx5_vcap_es2_is_first_chain(rule);\n\n\tif (is_first)\n\t\tvcap_rule_add_key_bit(rule, VCAP_KF_LOOKUP_FIRST_IS,\n\t\t\t\t      VCAP_BIT_1);\n\telse\n\t\tvcap_rule_add_key_bit(rule, VCAP_KF_LOOKUP_FIRST_IS,\n\t\t\t\t      VCAP_BIT_0);\n}\n\n \nstatic void sparx5_vcap_add_default_fields(struct net_device *ndev,\n\t\t\t\t\t   struct vcap_admin *admin,\n\t\t\t\t\t   struct vcap_rule *rule)\n{\n\tstruct sparx5_port *port;\n\n\t \n\tswitch (admin->vtype) {\n\tcase VCAP_TYPE_IS0:\n\tcase VCAP_TYPE_IS2:\n\t\tsparx5_vcap_ingress_add_default_fields(ndev, admin, rule);\n\t\tbreak;\n\tcase VCAP_TYPE_ES0:\n\t\tsparx5_vcap_es0_add_default_fields(ndev, admin, rule);\n\t\tbreak;\n\tcase VCAP_TYPE_ES2:\n\t\tsparx5_vcap_es2_add_default_fields(ndev, admin, rule);\n\t\tbreak;\n\tdefault:\n\t\tport = netdev_priv(ndev);\n\t\tsparx5_vcap_type_err(port->sparx5, admin, __func__);\n\t\tbreak;\n\t}\n}\n\n \nstatic void sparx5_vcap_cache_erase(struct vcap_admin *admin)\n{\n\tmemset(admin->cache.keystream, 0, STREAMSIZE);\n\tmemset(admin->cache.maskstream, 0, STREAMSIZE);\n\tmemset(admin->cache.actionstream, 0, STREAMSIZE);\n\tmemset(&admin->cache.counter, 0, sizeof(admin->cache.counter));\n}\n\nstatic void sparx5_vcap_is0_cache_write(struct sparx5 *sparx5,\n\t\t\t\t\tstruct vcap_admin *admin,\n\t\t\t\t\tenum vcap_selection sel,\n\t\t\t\t\tu32 start,\n\t\t\t\t\tu32 count)\n{\n\tu32 *keystr, *mskstr, *actstr;\n\tint idx;\n\n\tkeystr = &admin->cache.keystream[start];\n\tmskstr = &admin->cache.maskstream[start];\n\tactstr = &admin->cache.actionstream[start];\n\n\tswitch (sel) {\n\tcase VCAP_SEL_ENTRY:\n\t\tfor (idx = 0; idx < count; ++idx) {\n\t\t\t \n\t\t\tspx5_wr(keystr[idx] & mskstr[idx], sparx5,\n\t\t\t\tVCAP_SUPER_VCAP_ENTRY_DAT(idx));\n\t\t\tspx5_wr(~mskstr[idx], sparx5,\n\t\t\t\tVCAP_SUPER_VCAP_MASK_DAT(idx));\n\t\t}\n\t\tbreak;\n\tcase VCAP_SEL_ACTION:\n\t\tfor (idx = 0; idx < count; ++idx)\n\t\t\tspx5_wr(actstr[idx], sparx5,\n\t\t\t\tVCAP_SUPER_VCAP_ACTION_DAT(idx));\n\t\tbreak;\n\tcase VCAP_SEL_ALL:\n\t\tpr_err(\"%s:%d: cannot write all streams at once\\n\",\n\t\t       __func__, __LINE__);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (sel & VCAP_SEL_COUNTER)\n\t\tspx5_wr(admin->cache.counter, sparx5,\n\t\t\tVCAP_SUPER_VCAP_CNT_DAT(0));\n}\n\nstatic void sparx5_vcap_is2_cache_write(struct sparx5 *sparx5,\n\t\t\t\t\tstruct vcap_admin *admin,\n\t\t\t\t\tenum vcap_selection sel,\n\t\t\t\t\tu32 start,\n\t\t\t\t\tu32 count)\n{\n\tu32 *keystr, *mskstr, *actstr;\n\tint idx;\n\n\tkeystr = &admin->cache.keystream[start];\n\tmskstr = &admin->cache.maskstream[start];\n\tactstr = &admin->cache.actionstream[start];\n\n\tswitch (sel) {\n\tcase VCAP_SEL_ENTRY:\n\t\tfor (idx = 0; idx < count; ++idx) {\n\t\t\t \n\t\t\tspx5_wr(keystr[idx] & mskstr[idx], sparx5,\n\t\t\t\tVCAP_SUPER_VCAP_ENTRY_DAT(idx));\n\t\t\tspx5_wr(~mskstr[idx], sparx5,\n\t\t\t\tVCAP_SUPER_VCAP_MASK_DAT(idx));\n\t\t}\n\t\tbreak;\n\tcase VCAP_SEL_ACTION:\n\t\tfor (idx = 0; idx < count; ++idx)\n\t\t\tspx5_wr(actstr[idx], sparx5,\n\t\t\t\tVCAP_SUPER_VCAP_ACTION_DAT(idx));\n\t\tbreak;\n\tcase VCAP_SEL_ALL:\n\t\tpr_err(\"%s:%d: cannot write all streams at once\\n\",\n\t\t       __func__, __LINE__);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sel & VCAP_SEL_COUNTER) {\n\t\tstart = start & 0xfff;  \n\t\tif (admin->vinst == 0)\n\t\t\tspx5_wr(admin->cache.counter, sparx5,\n\t\t\t\tANA_ACL_CNT_A(start));\n\t\telse\n\t\t\tspx5_wr(admin->cache.counter, sparx5,\n\t\t\t\tANA_ACL_CNT_B(start));\n\t\tspx5_wr(admin->cache.sticky, sparx5,\n\t\t\tVCAP_SUPER_VCAP_CNT_DAT(0));\n\t}\n}\n\n \nstatic void sparx5_es0_write_esdx_counter(struct sparx5 *sparx5,\n\t\t\t\t\t  struct vcap_admin *admin, u32 id)\n{\n\tmutex_lock(&sparx5->queue_stats_lock);\n\tspx5_wr(XQS_STAT_CFG_STAT_VIEW_SET(id), sparx5, XQS_STAT_CFG);\n\tspx5_wr(admin->cache.counter, sparx5,\n\t\tXQS_CNT(SPARX5_STAT_ESDX_GRN_PKTS));\n\tspx5_wr(0, sparx5, XQS_CNT(SPARX5_STAT_ESDX_YEL_PKTS));\n\tmutex_unlock(&sparx5->queue_stats_lock);\n}\n\nstatic void sparx5_vcap_es0_cache_write(struct sparx5 *sparx5,\n\t\t\t\t\tstruct vcap_admin *admin,\n\t\t\t\t\tenum vcap_selection sel,\n\t\t\t\t\tu32 start,\n\t\t\t\t\tu32 count)\n{\n\tu32 *keystr, *mskstr, *actstr;\n\tint idx;\n\n\tkeystr = &admin->cache.keystream[start];\n\tmskstr = &admin->cache.maskstream[start];\n\tactstr = &admin->cache.actionstream[start];\n\n\tswitch (sel) {\n\tcase VCAP_SEL_ENTRY:\n\t\tfor (idx = 0; idx < count; ++idx) {\n\t\t\t \n\t\t\tspx5_wr(keystr[idx] & mskstr[idx], sparx5,\n\t\t\t\tVCAP_ES0_VCAP_ENTRY_DAT(idx));\n\t\t\tspx5_wr(~mskstr[idx], sparx5,\n\t\t\t\tVCAP_ES0_VCAP_MASK_DAT(idx));\n\t\t}\n\t\tbreak;\n\tcase VCAP_SEL_ACTION:\n\t\tfor (idx = 0; idx < count; ++idx)\n\t\t\tspx5_wr(actstr[idx], sparx5,\n\t\t\t\tVCAP_ES0_VCAP_ACTION_DAT(idx));\n\t\tbreak;\n\tcase VCAP_SEL_ALL:\n\t\tpr_err(\"%s:%d: cannot write all streams at once\\n\",\n\t\t       __func__, __LINE__);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sel & VCAP_SEL_COUNTER) {\n\t\tspx5_wr(admin->cache.counter, sparx5, VCAP_ES0_VCAP_CNT_DAT(0));\n\t\tsparx5_es0_write_esdx_counter(sparx5, admin, start);\n\t}\n}\n\nstatic void sparx5_vcap_es2_cache_write(struct sparx5 *sparx5,\n\t\t\t\t\tstruct vcap_admin *admin,\n\t\t\t\t\tenum vcap_selection sel,\n\t\t\t\t\tu32 start,\n\t\t\t\t\tu32 count)\n{\n\tu32 *keystr, *mskstr, *actstr;\n\tint idx;\n\n\tkeystr = &admin->cache.keystream[start];\n\tmskstr = &admin->cache.maskstream[start];\n\tactstr = &admin->cache.actionstream[start];\n\n\tswitch (sel) {\n\tcase VCAP_SEL_ENTRY:\n\t\tfor (idx = 0; idx < count; ++idx) {\n\t\t\t \n\t\t\tspx5_wr(keystr[idx] & mskstr[idx], sparx5,\n\t\t\t\tVCAP_ES2_VCAP_ENTRY_DAT(idx));\n\t\t\tspx5_wr(~mskstr[idx], sparx5,\n\t\t\t\tVCAP_ES2_VCAP_MASK_DAT(idx));\n\t\t}\n\t\tbreak;\n\tcase VCAP_SEL_ACTION:\n\t\tfor (idx = 0; idx < count; ++idx)\n\t\t\tspx5_wr(actstr[idx], sparx5,\n\t\t\t\tVCAP_ES2_VCAP_ACTION_DAT(idx));\n\t\tbreak;\n\tcase VCAP_SEL_ALL:\n\t\tpr_err(\"%s:%d: cannot write all streams at once\\n\",\n\t\t       __func__, __LINE__);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sel & VCAP_SEL_COUNTER) {\n\t\tstart = start & 0x7ff;  \n\t\tspx5_wr(admin->cache.counter, sparx5, EACL_ES2_CNT(start));\n\t\tspx5_wr(admin->cache.sticky, sparx5, VCAP_ES2_VCAP_CNT_DAT(0));\n\t}\n}\n\n \nstatic void sparx5_vcap_cache_write(struct net_device *ndev,\n\t\t\t\t    struct vcap_admin *admin,\n\t\t\t\t    enum vcap_selection sel,\n\t\t\t\t    u32 start,\n\t\t\t\t    u32 count)\n{\n\tstruct sparx5_port *port = netdev_priv(ndev);\n\tstruct sparx5 *sparx5 = port->sparx5;\n\n\tswitch (admin->vtype) {\n\tcase VCAP_TYPE_IS0:\n\t\tsparx5_vcap_is0_cache_write(sparx5, admin, sel, start, count);\n\t\tbreak;\n\tcase VCAP_TYPE_IS2:\n\t\tsparx5_vcap_is2_cache_write(sparx5, admin, sel, start, count);\n\t\tbreak;\n\tcase VCAP_TYPE_ES0:\n\t\tsparx5_vcap_es0_cache_write(sparx5, admin, sel, start, count);\n\t\tbreak;\n\tcase VCAP_TYPE_ES2:\n\t\tsparx5_vcap_es2_cache_write(sparx5, admin, sel, start, count);\n\t\tbreak;\n\tdefault:\n\t\tsparx5_vcap_type_err(sparx5, admin, __func__);\n\t\tbreak;\n\t}\n}\n\nstatic void sparx5_vcap_is0_cache_read(struct sparx5 *sparx5,\n\t\t\t\t       struct vcap_admin *admin,\n\t\t\t\t       enum vcap_selection sel,\n\t\t\t\t       u32 start,\n\t\t\t\t       u32 count)\n{\n\tu32 *keystr, *mskstr, *actstr;\n\tint idx;\n\n\tkeystr = &admin->cache.keystream[start];\n\tmskstr = &admin->cache.maskstream[start];\n\tactstr = &admin->cache.actionstream[start];\n\n\tif (sel & VCAP_SEL_ENTRY) {\n\t\tfor (idx = 0; idx < count; ++idx) {\n\t\t\tkeystr[idx] = spx5_rd(sparx5,\n\t\t\t\t\t      VCAP_SUPER_VCAP_ENTRY_DAT(idx));\n\t\t\tmskstr[idx] = ~spx5_rd(sparx5,\n\t\t\t\t\t       VCAP_SUPER_VCAP_MASK_DAT(idx));\n\t\t}\n\t}\n\n\tif (sel & VCAP_SEL_ACTION)\n\t\tfor (idx = 0; idx < count; ++idx)\n\t\t\tactstr[idx] = spx5_rd(sparx5,\n\t\t\t\t\t      VCAP_SUPER_VCAP_ACTION_DAT(idx));\n\n\tif (sel & VCAP_SEL_COUNTER) {\n\t\tadmin->cache.counter =\n\t\t\tspx5_rd(sparx5, VCAP_SUPER_VCAP_CNT_DAT(0));\n\t\tadmin->cache.sticky =\n\t\t\tspx5_rd(sparx5, VCAP_SUPER_VCAP_CNT_DAT(0));\n\t}\n}\n\nstatic void sparx5_vcap_is2_cache_read(struct sparx5 *sparx5,\n\t\t\t\t       struct vcap_admin *admin,\n\t\t\t\t       enum vcap_selection sel,\n\t\t\t\t       u32 start,\n\t\t\t\t       u32 count)\n{\n\tu32 *keystr, *mskstr, *actstr;\n\tint idx;\n\n\tkeystr = &admin->cache.keystream[start];\n\tmskstr = &admin->cache.maskstream[start];\n\tactstr = &admin->cache.actionstream[start];\n\n\tif (sel & VCAP_SEL_ENTRY) {\n\t\tfor (idx = 0; idx < count; ++idx) {\n\t\t\tkeystr[idx] = spx5_rd(sparx5,\n\t\t\t\t\t      VCAP_SUPER_VCAP_ENTRY_DAT(idx));\n\t\t\tmskstr[idx] = ~spx5_rd(sparx5,\n\t\t\t\t\t       VCAP_SUPER_VCAP_MASK_DAT(idx));\n\t\t}\n\t}\n\n\tif (sel & VCAP_SEL_ACTION)\n\t\tfor (idx = 0; idx < count; ++idx)\n\t\t\tactstr[idx] = spx5_rd(sparx5,\n\t\t\t\t\t      VCAP_SUPER_VCAP_ACTION_DAT(idx));\n\n\tif (sel & VCAP_SEL_COUNTER) {\n\t\tstart = start & 0xfff;  \n\t\tif (admin->vinst == 0)\n\t\t\tadmin->cache.counter =\n\t\t\t\tspx5_rd(sparx5, ANA_ACL_CNT_A(start));\n\t\telse\n\t\t\tadmin->cache.counter =\n\t\t\t\tspx5_rd(sparx5, ANA_ACL_CNT_B(start));\n\t\tadmin->cache.sticky =\n\t\t\tspx5_rd(sparx5, VCAP_SUPER_VCAP_CNT_DAT(0));\n\t}\n}\n\n \nstatic void sparx5_es0_read_esdx_counter(struct sparx5 *sparx5,\n\t\t\t\t\t struct vcap_admin *admin, u32 id)\n{\n\tu32 counter;\n\n\tmutex_lock(&sparx5->queue_stats_lock);\n\tspx5_wr(XQS_STAT_CFG_STAT_VIEW_SET(id), sparx5, XQS_STAT_CFG);\n\tcounter = spx5_rd(sparx5, XQS_CNT(SPARX5_STAT_ESDX_GRN_PKTS)) +\n\t\tspx5_rd(sparx5, XQS_CNT(SPARX5_STAT_ESDX_YEL_PKTS));\n\tmutex_unlock(&sparx5->queue_stats_lock);\n\tif (counter)\n\t\tadmin->cache.counter = counter;\n}\n\nstatic void sparx5_vcap_es0_cache_read(struct sparx5 *sparx5,\n\t\t\t\t       struct vcap_admin *admin,\n\t\t\t\t       enum vcap_selection sel,\n\t\t\t\t       u32 start,\n\t\t\t\t       u32 count)\n{\n\tu32 *keystr, *mskstr, *actstr;\n\tint idx;\n\n\tkeystr = &admin->cache.keystream[start];\n\tmskstr = &admin->cache.maskstream[start];\n\tactstr = &admin->cache.actionstream[start];\n\n\tif (sel & VCAP_SEL_ENTRY) {\n\t\tfor (idx = 0; idx < count; ++idx) {\n\t\t\tkeystr[idx] =\n\t\t\t\tspx5_rd(sparx5, VCAP_ES0_VCAP_ENTRY_DAT(idx));\n\t\t\tmskstr[idx] =\n\t\t\t\t~spx5_rd(sparx5, VCAP_ES0_VCAP_MASK_DAT(idx));\n\t\t}\n\t}\n\n\tif (sel & VCAP_SEL_ACTION)\n\t\tfor (idx = 0; idx < count; ++idx)\n\t\t\tactstr[idx] =\n\t\t\t\tspx5_rd(sparx5, VCAP_ES0_VCAP_ACTION_DAT(idx));\n\n\tif (sel & VCAP_SEL_COUNTER) {\n\t\tadmin->cache.counter =\n\t\t\tspx5_rd(sparx5, VCAP_ES0_VCAP_CNT_DAT(0));\n\t\tadmin->cache.sticky = admin->cache.counter;\n\t\tsparx5_es0_read_esdx_counter(sparx5, admin, start);\n\t}\n}\n\nstatic void sparx5_vcap_es2_cache_read(struct sparx5 *sparx5,\n\t\t\t\t       struct vcap_admin *admin,\n\t\t\t\t       enum vcap_selection sel,\n\t\t\t\t       u32 start,\n\t\t\t\t       u32 count)\n{\n\tu32 *keystr, *mskstr, *actstr;\n\tint idx;\n\n\tkeystr = &admin->cache.keystream[start];\n\tmskstr = &admin->cache.maskstream[start];\n\tactstr = &admin->cache.actionstream[start];\n\n\tif (sel & VCAP_SEL_ENTRY) {\n\t\tfor (idx = 0; idx < count; ++idx) {\n\t\t\tkeystr[idx] =\n\t\t\t\tspx5_rd(sparx5, VCAP_ES2_VCAP_ENTRY_DAT(idx));\n\t\t\tmskstr[idx] =\n\t\t\t\t~spx5_rd(sparx5, VCAP_ES2_VCAP_MASK_DAT(idx));\n\t\t}\n\t}\n\n\tif (sel & VCAP_SEL_ACTION)\n\t\tfor (idx = 0; idx < count; ++idx)\n\t\t\tactstr[idx] =\n\t\t\t\tspx5_rd(sparx5, VCAP_ES2_VCAP_ACTION_DAT(idx));\n\n\tif (sel & VCAP_SEL_COUNTER) {\n\t\tstart = start & 0x7ff;  \n\t\tadmin->cache.counter =\n\t\t\tspx5_rd(sparx5, EACL_ES2_CNT(start));\n\t\tadmin->cache.sticky =\n\t\t\tspx5_rd(sparx5, VCAP_ES2_VCAP_CNT_DAT(0));\n\t}\n}\n\n \nstatic void sparx5_vcap_cache_read(struct net_device *ndev,\n\t\t\t\t   struct vcap_admin *admin,\n\t\t\t\t   enum vcap_selection sel,\n\t\t\t\t   u32 start,\n\t\t\t\t   u32 count)\n{\n\tstruct sparx5_port *port = netdev_priv(ndev);\n\tstruct sparx5 *sparx5 = port->sparx5;\n\n\tswitch (admin->vtype) {\n\tcase VCAP_TYPE_IS0:\n\t\tsparx5_vcap_is0_cache_read(sparx5, admin, sel, start, count);\n\t\tbreak;\n\tcase VCAP_TYPE_IS2:\n\t\tsparx5_vcap_is2_cache_read(sparx5, admin, sel, start, count);\n\t\tbreak;\n\tcase VCAP_TYPE_ES0:\n\t\tsparx5_vcap_es0_cache_read(sparx5, admin, sel, start, count);\n\t\tbreak;\n\tcase VCAP_TYPE_ES2:\n\t\tsparx5_vcap_es2_cache_read(sparx5, admin, sel, start, count);\n\t\tbreak;\n\tdefault:\n\t\tsparx5_vcap_type_err(sparx5, admin, __func__);\n\t\tbreak;\n\t}\n}\n\n \nstatic void sparx5_vcap_range_init(struct net_device *ndev,\n\t\t\t\t   struct vcap_admin *admin, u32 addr,\n\t\t\t\t   u32 count)\n{\n\tstruct sparx5_port *port = netdev_priv(ndev);\n\tstruct sparx5 *sparx5 = port->sparx5;\n\n\t_sparx5_vcap_range_init(sparx5, admin, addr, count);\n}\n\nstatic void sparx5_vcap_super_update(struct sparx5 *sparx5,\n\t\t\t\t     enum vcap_command cmd,\n\t\t\t\t     enum vcap_selection sel, u32 addr)\n{\n\tbool clear = (cmd == VCAP_CMD_INITIALIZE);\n\n\tspx5_wr(VCAP_SUPER_CFG_MV_NUM_POS_SET(0) |\n\t\tVCAP_SUPER_CFG_MV_SIZE_SET(0), sparx5, VCAP_SUPER_CFG);\n\tspx5_wr(VCAP_SUPER_CTRL_UPDATE_CMD_SET(cmd) |\n\t\tVCAP_SUPER_CTRL_UPDATE_ENTRY_DIS_SET((VCAP_SEL_ENTRY & sel) == 0) |\n\t\tVCAP_SUPER_CTRL_UPDATE_ACTION_DIS_SET((VCAP_SEL_ACTION & sel) == 0) |\n\t\tVCAP_SUPER_CTRL_UPDATE_CNT_DIS_SET((VCAP_SEL_COUNTER & sel) == 0) |\n\t\tVCAP_SUPER_CTRL_UPDATE_ADDR_SET(addr) |\n\t\tVCAP_SUPER_CTRL_CLEAR_CACHE_SET(clear) |\n\t\tVCAP_SUPER_CTRL_UPDATE_SHOT_SET(true),\n\t\tsparx5, VCAP_SUPER_CTRL);\n\tsparx5_vcap_wait_super_update(sparx5);\n}\n\nstatic void sparx5_vcap_es0_update(struct sparx5 *sparx5,\n\t\t\t\t   enum vcap_command cmd,\n\t\t\t\t   enum vcap_selection sel, u32 addr)\n{\n\tbool clear = (cmd == VCAP_CMD_INITIALIZE);\n\n\tspx5_wr(VCAP_ES0_CFG_MV_NUM_POS_SET(0) |\n\t\tVCAP_ES0_CFG_MV_SIZE_SET(0), sparx5, VCAP_ES0_CFG);\n\tspx5_wr(VCAP_ES0_CTRL_UPDATE_CMD_SET(cmd) |\n\t\tVCAP_ES0_CTRL_UPDATE_ENTRY_DIS_SET((VCAP_SEL_ENTRY & sel) == 0) |\n\t\tVCAP_ES0_CTRL_UPDATE_ACTION_DIS_SET((VCAP_SEL_ACTION & sel) == 0) |\n\t\tVCAP_ES0_CTRL_UPDATE_CNT_DIS_SET((VCAP_SEL_COUNTER & sel) == 0) |\n\t\tVCAP_ES0_CTRL_UPDATE_ADDR_SET(addr) |\n\t\tVCAP_ES0_CTRL_CLEAR_CACHE_SET(clear) |\n\t\tVCAP_ES0_CTRL_UPDATE_SHOT_SET(true),\n\t\tsparx5, VCAP_ES0_CTRL);\n\tsparx5_vcap_wait_es0_update(sparx5);\n}\n\nstatic void sparx5_vcap_es2_update(struct sparx5 *sparx5,\n\t\t\t\t   enum vcap_command cmd,\n\t\t\t\t   enum vcap_selection sel, u32 addr)\n{\n\tbool clear = (cmd == VCAP_CMD_INITIALIZE);\n\n\tspx5_wr(VCAP_ES2_CFG_MV_NUM_POS_SET(0) |\n\t\tVCAP_ES2_CFG_MV_SIZE_SET(0), sparx5, VCAP_ES2_CFG);\n\tspx5_wr(VCAP_ES2_CTRL_UPDATE_CMD_SET(cmd) |\n\t\tVCAP_ES2_CTRL_UPDATE_ENTRY_DIS_SET((VCAP_SEL_ENTRY & sel) == 0) |\n\t\tVCAP_ES2_CTRL_UPDATE_ACTION_DIS_SET((VCAP_SEL_ACTION & sel) == 0) |\n\t\tVCAP_ES2_CTRL_UPDATE_CNT_DIS_SET((VCAP_SEL_COUNTER & sel) == 0) |\n\t\tVCAP_ES2_CTRL_UPDATE_ADDR_SET(addr) |\n\t\tVCAP_ES2_CTRL_CLEAR_CACHE_SET(clear) |\n\t\tVCAP_ES2_CTRL_UPDATE_SHOT_SET(true),\n\t\tsparx5, VCAP_ES2_CTRL);\n\tsparx5_vcap_wait_es2_update(sparx5);\n}\n\n \nstatic void sparx5_vcap_update(struct net_device *ndev,\n\t\t\t       struct vcap_admin *admin, enum vcap_command cmd,\n\t\t\t       enum vcap_selection sel, u32 addr)\n{\n\tstruct sparx5_port *port = netdev_priv(ndev);\n\tstruct sparx5 *sparx5 = port->sparx5;\n\n\tswitch (admin->vtype) {\n\tcase VCAP_TYPE_IS0:\n\tcase VCAP_TYPE_IS2:\n\t\tsparx5_vcap_super_update(sparx5, cmd, sel, addr);\n\t\tbreak;\n\tcase VCAP_TYPE_ES0:\n\t\tsparx5_vcap_es0_update(sparx5, cmd, sel, addr);\n\t\tbreak;\n\tcase VCAP_TYPE_ES2:\n\t\tsparx5_vcap_es2_update(sparx5, cmd, sel, addr);\n\t\tbreak;\n\tdefault:\n\t\tsparx5_vcap_type_err(sparx5, admin, __func__);\n\t\tbreak;\n\t}\n}\n\nstatic void sparx5_vcap_super_move(struct sparx5 *sparx5,\n\t\t\t\t   u32 addr,\n\t\t\t\t   enum vcap_command cmd,\n\t\t\t\t   u16 mv_num_pos,\n\t\t\t\t   u16 mv_size)\n{\n\tspx5_wr(VCAP_SUPER_CFG_MV_NUM_POS_SET(mv_num_pos) |\n\t\tVCAP_SUPER_CFG_MV_SIZE_SET(mv_size),\n\t\tsparx5, VCAP_SUPER_CFG);\n\tspx5_wr(VCAP_SUPER_CTRL_UPDATE_CMD_SET(cmd) |\n\t\tVCAP_SUPER_CTRL_UPDATE_ENTRY_DIS_SET(0) |\n\t\tVCAP_SUPER_CTRL_UPDATE_ACTION_DIS_SET(0) |\n\t\tVCAP_SUPER_CTRL_UPDATE_CNT_DIS_SET(0) |\n\t\tVCAP_SUPER_CTRL_UPDATE_ADDR_SET(addr) |\n\t\tVCAP_SUPER_CTRL_CLEAR_CACHE_SET(false) |\n\t\tVCAP_SUPER_CTRL_UPDATE_SHOT_SET(true),\n\t\tsparx5, VCAP_SUPER_CTRL);\n\tsparx5_vcap_wait_super_update(sparx5);\n}\n\nstatic void sparx5_vcap_es0_move(struct sparx5 *sparx5,\n\t\t\t\t u32 addr,\n\t\t\t\t enum vcap_command cmd,\n\t\t\t\t u16 mv_num_pos,\n\t\t\t\t u16 mv_size)\n{\n\tspx5_wr(VCAP_ES0_CFG_MV_NUM_POS_SET(mv_num_pos) |\n\t\tVCAP_ES0_CFG_MV_SIZE_SET(mv_size),\n\t\tsparx5, VCAP_ES0_CFG);\n\tspx5_wr(VCAP_ES0_CTRL_UPDATE_CMD_SET(cmd) |\n\t\tVCAP_ES0_CTRL_UPDATE_ENTRY_DIS_SET(0) |\n\t\tVCAP_ES0_CTRL_UPDATE_ACTION_DIS_SET(0) |\n\t\tVCAP_ES0_CTRL_UPDATE_CNT_DIS_SET(0) |\n\t\tVCAP_ES0_CTRL_UPDATE_ADDR_SET(addr) |\n\t\tVCAP_ES0_CTRL_CLEAR_CACHE_SET(false) |\n\t\tVCAP_ES0_CTRL_UPDATE_SHOT_SET(true),\n\t\tsparx5, VCAP_ES0_CTRL);\n\tsparx5_vcap_wait_es0_update(sparx5);\n}\n\nstatic void sparx5_vcap_es2_move(struct sparx5 *sparx5,\n\t\t\t\t u32 addr,\n\t\t\t\t enum vcap_command cmd,\n\t\t\t\t u16 mv_num_pos,\n\t\t\t\t u16 mv_size)\n{\n\tspx5_wr(VCAP_ES2_CFG_MV_NUM_POS_SET(mv_num_pos) |\n\t\tVCAP_ES2_CFG_MV_SIZE_SET(mv_size),\n\t\tsparx5, VCAP_ES2_CFG);\n\tspx5_wr(VCAP_ES2_CTRL_UPDATE_CMD_SET(cmd) |\n\t\tVCAP_ES2_CTRL_UPDATE_ENTRY_DIS_SET(0) |\n\t\tVCAP_ES2_CTRL_UPDATE_ACTION_DIS_SET(0) |\n\t\tVCAP_ES2_CTRL_UPDATE_CNT_DIS_SET(0) |\n\t\tVCAP_ES2_CTRL_UPDATE_ADDR_SET(addr) |\n\t\tVCAP_ES2_CTRL_CLEAR_CACHE_SET(false) |\n\t\tVCAP_ES2_CTRL_UPDATE_SHOT_SET(true),\n\t\tsparx5, VCAP_ES2_CTRL);\n\tsparx5_vcap_wait_es2_update(sparx5);\n}\n\n \nstatic void sparx5_vcap_move(struct net_device *ndev, struct vcap_admin *admin,\n\t\t\t     u32 addr, int offset, int count)\n{\n\tstruct sparx5_port *port = netdev_priv(ndev);\n\tstruct sparx5 *sparx5 = port->sparx5;\n\tenum vcap_command cmd;\n\tu16 mv_num_pos;\n\tu16 mv_size;\n\n\tmv_size = count - 1;\n\tif (offset > 0) {\n\t\tmv_num_pos = offset - 1;\n\t\tcmd = VCAP_CMD_MOVE_DOWN;\n\t} else {\n\t\tmv_num_pos = -offset - 1;\n\t\tcmd = VCAP_CMD_MOVE_UP;\n\t}\n\n\tswitch (admin->vtype) {\n\tcase VCAP_TYPE_IS0:\n\tcase VCAP_TYPE_IS2:\n\t\tsparx5_vcap_super_move(sparx5, addr, cmd, mv_num_pos, mv_size);\n\t\tbreak;\n\tcase VCAP_TYPE_ES0:\n\t\tsparx5_vcap_es0_move(sparx5, addr, cmd, mv_num_pos, mv_size);\n\t\tbreak;\n\tcase VCAP_TYPE_ES2:\n\t\tsparx5_vcap_es2_move(sparx5, addr, cmd, mv_num_pos, mv_size);\n\t\tbreak;\n\tdefault:\n\t\tsparx5_vcap_type_err(sparx5, admin, __func__);\n\t\tbreak;\n\t}\n}\n\nstatic struct vcap_operations sparx5_vcap_ops = {\n\t.validate_keyset = sparx5_vcap_validate_keyset,\n\t.add_default_fields = sparx5_vcap_add_default_fields,\n\t.cache_erase = sparx5_vcap_cache_erase,\n\t.cache_write = sparx5_vcap_cache_write,\n\t.cache_read = sparx5_vcap_cache_read,\n\t.init = sparx5_vcap_range_init,\n\t.update = sparx5_vcap_update,\n\t.move = sparx5_vcap_move,\n\t.port_info = sparx5_port_info,\n};\n\nstatic u32 sparx5_vcap_is0_keyset_to_etype_ps(enum vcap_keyfield_set keyset)\n{\n\tswitch (keyset) {\n\tcase VCAP_KFS_NORMAL_7TUPLE:\n\t\treturn VCAP_IS0_PS_ETYPE_NORMAL_7TUPLE;\n\tcase VCAP_KFS_NORMAL_5TUPLE_IP4:\n\t\treturn VCAP_IS0_PS_ETYPE_NORMAL_5TUPLE_IP4;\n\tdefault:\n\t\treturn VCAP_IS0_PS_ETYPE_NORMAL_7TUPLE;\n\t}\n}\n\nstatic void sparx5_vcap_is0_set_port_keyset(struct net_device *ndev, int lookup,\n\t\t\t\t\t    enum vcap_keyfield_set keyset,\n\t\t\t\t\t    int l3_proto)\n{\n\tstruct sparx5_port *port = netdev_priv(ndev);\n\tstruct sparx5 *sparx5 = port->sparx5;\n\tint portno = port->portno;\n\tu32 value;\n\n\tswitch (l3_proto) {\n\tcase ETH_P_IP:\n\t\tvalue = sparx5_vcap_is0_keyset_to_etype_ps(keyset);\n\t\tspx5_rmw(ANA_CL_ADV_CL_CFG_IP4_CLM_KEY_SEL_SET(value),\n\t\t\t ANA_CL_ADV_CL_CFG_IP4_CLM_KEY_SEL,\n\t\t\t sparx5,\n\t\t\t ANA_CL_ADV_CL_CFG(portno, lookup));\n\t\tbreak;\n\tcase ETH_P_IPV6:\n\t\tvalue = sparx5_vcap_is0_keyset_to_etype_ps(keyset);\n\t\tspx5_rmw(ANA_CL_ADV_CL_CFG_IP6_CLM_KEY_SEL_SET(value),\n\t\t\t ANA_CL_ADV_CL_CFG_IP6_CLM_KEY_SEL,\n\t\t\t sparx5,\n\t\t\t ANA_CL_ADV_CL_CFG(portno, lookup));\n\t\tbreak;\n\tdefault:\n\t\tvalue = sparx5_vcap_is0_keyset_to_etype_ps(keyset);\n\t\tspx5_rmw(ANA_CL_ADV_CL_CFG_ETYPE_CLM_KEY_SEL_SET(value),\n\t\t\t ANA_CL_ADV_CL_CFG_ETYPE_CLM_KEY_SEL,\n\t\t\t sparx5,\n\t\t\t ANA_CL_ADV_CL_CFG(portno, lookup));\n\t\tbreak;\n\t}\n}\n\nstatic u32 sparx5_vcap_is2_keyset_to_arp_ps(enum vcap_keyfield_set keyset)\n{\n\tswitch (keyset) {\n\tcase VCAP_KFS_ARP:\n\t\treturn VCAP_IS2_PS_ARP_ARP;\n\tdefault:\n\t\treturn VCAP_IS2_PS_ARP_MAC_ETYPE;\n\t}\n}\n\nstatic u32 sparx5_vcap_is2_keyset_to_ipv4_ps(enum vcap_keyfield_set keyset)\n{\n\tswitch (keyset) {\n\tcase VCAP_KFS_MAC_ETYPE:\n\t\treturn VCAP_IS2_PS_IPV4_UC_MAC_ETYPE;\n\tcase VCAP_KFS_IP4_OTHER:\n\tcase VCAP_KFS_IP4_TCP_UDP:\n\t\treturn VCAP_IS2_PS_IPV4_UC_IP4_TCP_UDP_OTHER;\n\tcase VCAP_KFS_IP_7TUPLE:\n\t\treturn VCAP_IS2_PS_IPV4_UC_IP_7TUPLE;\n\tdefault:\n\t\treturn VCAP_KFS_NO_VALUE;\n\t}\n}\n\nstatic u32 sparx5_vcap_is2_keyset_to_ipv6_uc_ps(enum vcap_keyfield_set keyset)\n{\n\tswitch (keyset) {\n\tcase VCAP_KFS_MAC_ETYPE:\n\t\treturn VCAP_IS2_PS_IPV6_UC_MAC_ETYPE;\n\tcase VCAP_KFS_IP4_OTHER:\n\tcase VCAP_KFS_IP4_TCP_UDP:\n\t\treturn VCAP_IS2_PS_IPV6_UC_IP4_TCP_UDP_OTHER;\n\tcase VCAP_KFS_IP_7TUPLE:\n\t\treturn VCAP_IS2_PS_IPV6_UC_IP_7TUPLE;\n\tdefault:\n\t\treturn VCAP_KFS_NO_VALUE;\n\t}\n}\n\nstatic u32 sparx5_vcap_is2_keyset_to_ipv6_mc_ps(enum vcap_keyfield_set keyset)\n{\n\tswitch (keyset) {\n\tcase VCAP_KFS_MAC_ETYPE:\n\t\treturn VCAP_IS2_PS_IPV6_MC_MAC_ETYPE;\n\tcase VCAP_KFS_IP4_OTHER:\n\tcase VCAP_KFS_IP4_TCP_UDP:\n\t\treturn VCAP_IS2_PS_IPV6_MC_IP4_TCP_UDP_OTHER;\n\tcase VCAP_KFS_IP_7TUPLE:\n\t\treturn VCAP_IS2_PS_IPV6_MC_IP_7TUPLE;\n\tdefault:\n\t\treturn VCAP_KFS_NO_VALUE;\n\t}\n}\n\nstatic void sparx5_vcap_is2_set_port_keyset(struct net_device *ndev, int lookup,\n\t\t\t\t\t    enum vcap_keyfield_set keyset,\n\t\t\t\t\t    int l3_proto)\n{\n\tstruct sparx5_port *port = netdev_priv(ndev);\n\tstruct sparx5 *sparx5 = port->sparx5;\n\tint portno = port->portno;\n\tu32 value;\n\n\tswitch (l3_proto) {\n\tcase ETH_P_ARP:\n\t\tvalue = sparx5_vcap_is2_keyset_to_arp_ps(keyset);\n\t\tspx5_rmw(ANA_ACL_VCAP_S2_KEY_SEL_ARP_KEY_SEL_SET(value),\n\t\t\t ANA_ACL_VCAP_S2_KEY_SEL_ARP_KEY_SEL,\n\t\t\t sparx5,\n\t\t\t ANA_ACL_VCAP_S2_KEY_SEL(portno, lookup));\n\t\tbreak;\n\tcase ETH_P_IP:\n\t\tvalue = sparx5_vcap_is2_keyset_to_ipv4_ps(keyset);\n\t\tspx5_rmw(ANA_ACL_VCAP_S2_KEY_SEL_IP4_UC_KEY_SEL_SET(value),\n\t\t\t ANA_ACL_VCAP_S2_KEY_SEL_IP4_UC_KEY_SEL,\n\t\t\t sparx5,\n\t\t\t ANA_ACL_VCAP_S2_KEY_SEL(portno, lookup));\n\t\tspx5_rmw(ANA_ACL_VCAP_S2_KEY_SEL_IP4_MC_KEY_SEL_SET(value),\n\t\t\t ANA_ACL_VCAP_S2_KEY_SEL_IP4_MC_KEY_SEL,\n\t\t\t sparx5,\n\t\t\t ANA_ACL_VCAP_S2_KEY_SEL(portno, lookup));\n\t\tbreak;\n\tcase ETH_P_IPV6:\n\t\tvalue = sparx5_vcap_is2_keyset_to_ipv6_uc_ps(keyset);\n\t\tspx5_rmw(ANA_ACL_VCAP_S2_KEY_SEL_IP6_UC_KEY_SEL_SET(value),\n\t\t\t ANA_ACL_VCAP_S2_KEY_SEL_IP6_UC_KEY_SEL,\n\t\t\t sparx5,\n\t\t\t ANA_ACL_VCAP_S2_KEY_SEL(portno, lookup));\n\t\tvalue = sparx5_vcap_is2_keyset_to_ipv6_mc_ps(keyset);\n\t\tspx5_rmw(ANA_ACL_VCAP_S2_KEY_SEL_IP6_MC_KEY_SEL_SET(value),\n\t\t\t ANA_ACL_VCAP_S2_KEY_SEL_IP6_MC_KEY_SEL,\n\t\t\t sparx5,\n\t\t\t ANA_ACL_VCAP_S2_KEY_SEL(portno, lookup));\n\t\tbreak;\n\tdefault:\n\t\tvalue = VCAP_IS2_PS_NONETH_MAC_ETYPE;\n\t\tspx5_rmw(ANA_ACL_VCAP_S2_KEY_SEL_NON_ETH_KEY_SEL_SET(value),\n\t\t\t ANA_ACL_VCAP_S2_KEY_SEL_NON_ETH_KEY_SEL,\n\t\t\t sparx5,\n\t\t\t ANA_ACL_VCAP_S2_KEY_SEL(portno, lookup));\n\t\tbreak;\n\t}\n}\n\nstatic u32 sparx5_vcap_es2_keyset_to_arp_ps(enum vcap_keyfield_set keyset)\n{\n\tswitch (keyset) {\n\tcase VCAP_KFS_ARP:\n\t\treturn VCAP_ES2_PS_ARP_ARP;\n\tdefault:\n\t\treturn VCAP_ES2_PS_ARP_MAC_ETYPE;\n\t}\n}\n\nstatic u32 sparx5_vcap_es2_keyset_to_ipv4_ps(enum vcap_keyfield_set keyset)\n{\n\tswitch (keyset) {\n\tcase VCAP_KFS_MAC_ETYPE:\n\t\treturn VCAP_ES2_PS_IPV4_MAC_ETYPE;\n\tcase VCAP_KFS_IP_7TUPLE:\n\t\treturn VCAP_ES2_PS_IPV4_IP_7TUPLE;\n\tcase VCAP_KFS_IP4_TCP_UDP:\n\t\treturn VCAP_ES2_PS_IPV4_IP4_TCP_UDP_OTHER;\n\tcase VCAP_KFS_IP4_OTHER:\n\t\treturn VCAP_ES2_PS_IPV4_IP4_OTHER;\n\tdefault:\n\t\treturn VCAP_ES2_PS_IPV4_MAC_ETYPE;\n\t}\n}\n\nstatic u32 sparx5_vcap_es2_keyset_to_ipv6_ps(enum vcap_keyfield_set keyset)\n{\n\tswitch (keyset) {\n\tcase VCAP_KFS_MAC_ETYPE:\n\t\treturn VCAP_ES2_PS_IPV6_MAC_ETYPE;\n\tcase VCAP_KFS_IP4_TCP_UDP:\n\tcase VCAP_KFS_IP4_OTHER:\n\t\treturn VCAP_ES2_PS_IPV6_IP4_DOWNGRADE;\n\tcase VCAP_KFS_IP_7TUPLE:\n\t\treturn VCAP_ES2_PS_IPV6_IP_7TUPLE;\n\tcase VCAP_KFS_IP6_STD:\n\t\treturn VCAP_ES2_PS_IPV6_IP6_STD;\n\tdefault:\n\t\treturn VCAP_ES2_PS_IPV6_MAC_ETYPE;\n\t}\n}\n\nstatic void sparx5_vcap_es2_set_port_keyset(struct net_device *ndev, int lookup,\n\t\t\t\t\t    enum vcap_keyfield_set keyset,\n\t\t\t\t\t    int l3_proto)\n{\n\tstruct sparx5_port *port = netdev_priv(ndev);\n\tstruct sparx5 *sparx5 = port->sparx5;\n\tint portno = port->portno;\n\tu32 value;\n\n\tswitch (l3_proto) {\n\tcase ETH_P_IP:\n\t\tvalue = sparx5_vcap_es2_keyset_to_ipv4_ps(keyset);\n\t\tspx5_rmw(EACL_VCAP_ES2_KEY_SEL_IP4_KEY_SEL_SET(value),\n\t\t\t EACL_VCAP_ES2_KEY_SEL_IP4_KEY_SEL,\n\t\t\t sparx5,\n\t\t\t EACL_VCAP_ES2_KEY_SEL(portno, lookup));\n\t\tbreak;\n\tcase ETH_P_IPV6:\n\t\tvalue = sparx5_vcap_es2_keyset_to_ipv6_ps(keyset);\n\t\tspx5_rmw(EACL_VCAP_ES2_KEY_SEL_IP6_KEY_SEL_SET(value),\n\t\t\t EACL_VCAP_ES2_KEY_SEL_IP6_KEY_SEL,\n\t\t\t sparx5,\n\t\t\t EACL_VCAP_ES2_KEY_SEL(portno, lookup));\n\t\tbreak;\n\tcase ETH_P_ARP:\n\t\tvalue = sparx5_vcap_es2_keyset_to_arp_ps(keyset);\n\t\tspx5_rmw(EACL_VCAP_ES2_KEY_SEL_ARP_KEY_SEL_SET(value),\n\t\t\t EACL_VCAP_ES2_KEY_SEL_ARP_KEY_SEL,\n\t\t\t sparx5,\n\t\t\t EACL_VCAP_ES2_KEY_SEL(portno, lookup));\n\t\tbreak;\n\t}\n}\n\n \nvoid sparx5_vcap_set_port_keyset(struct net_device *ndev,\n\t\t\t\t struct vcap_admin *admin,\n\t\t\t\t int cid,\n\t\t\t\t u16 l3_proto,\n\t\t\t\t enum vcap_keyfield_set keyset,\n\t\t\t\t struct vcap_keyset_list *orig)\n{\n\tstruct sparx5_port *port;\n\tint lookup;\n\n\tswitch (admin->vtype) {\n\tcase VCAP_TYPE_IS0:\n\t\tlookup = sparx5_vcap_is0_cid_to_lookup(cid);\n\t\tif (orig)\n\t\t\tsparx5_vcap_is0_get_port_keysets(ndev, lookup, orig,\n\t\t\t\t\t\t\t l3_proto);\n\t\tsparx5_vcap_is0_set_port_keyset(ndev, lookup, keyset, l3_proto);\n\t\tbreak;\n\tcase VCAP_TYPE_IS2:\n\t\tlookup = sparx5_vcap_is2_cid_to_lookup(cid);\n\t\tif (orig)\n\t\t\tsparx5_vcap_is2_get_port_keysets(ndev, lookup, orig,\n\t\t\t\t\t\t\t l3_proto);\n\t\tsparx5_vcap_is2_set_port_keyset(ndev, lookup, keyset, l3_proto);\n\t\tbreak;\n\tcase VCAP_TYPE_ES0:\n\t\tbreak;\n\tcase VCAP_TYPE_ES2:\n\t\tlookup = sparx5_vcap_es2_cid_to_lookup(cid);\n\t\tif (orig)\n\t\t\tsparx5_vcap_es2_get_port_keysets(ndev, lookup, orig,\n\t\t\t\t\t\t\t l3_proto);\n\t\tsparx5_vcap_es2_set_port_keyset(ndev, lookup, keyset, l3_proto);\n\t\tbreak;\n\tdefault:\n\t\tport = netdev_priv(ndev);\n\t\tsparx5_vcap_type_err(port->sparx5, admin, __func__);\n\t\tbreak;\n\t}\n}\n\n \nstatic void sparx5_vcap_is0_port_key_selection(struct sparx5 *sparx5,\n\t\t\t\t\t       struct vcap_admin *admin)\n{\n\tint portno, lookup;\n\tu32 keysel;\n\n\tkeysel = VCAP_IS0_KEYSEL(false,\n\t\t\t\t VCAP_IS0_PS_ETYPE_NORMAL_7TUPLE,\n\t\t\t\t VCAP_IS0_PS_ETYPE_NORMAL_5TUPLE_IP4,\n\t\t\t\t VCAP_IS0_PS_ETYPE_NORMAL_7TUPLE,\n\t\t\t\t VCAP_IS0_PS_MPLS_FOLLOW_ETYPE,\n\t\t\t\t VCAP_IS0_PS_MPLS_FOLLOW_ETYPE,\n\t\t\t\t VCAP_IS0_PS_MLBS_FOLLOW_ETYPE);\n\tfor (lookup = 0; lookup < admin->lookups; ++lookup) {\n\t\tfor (portno = 0; portno < SPX5_PORTS; ++portno) {\n\t\t\tspx5_wr(keysel, sparx5,\n\t\t\t\tANA_CL_ADV_CL_CFG(portno, lookup));\n\t\t\tspx5_rmw(ANA_CL_ADV_CL_CFG_LOOKUP_ENA,\n\t\t\t\t ANA_CL_ADV_CL_CFG_LOOKUP_ENA,\n\t\t\t\t sparx5,\n\t\t\t\t ANA_CL_ADV_CL_CFG(portno, lookup));\n\t\t}\n\t}\n}\n\n \nstatic void sparx5_vcap_is2_port_key_selection(struct sparx5 *sparx5,\n\t\t\t\t\t       struct vcap_admin *admin)\n{\n\tint portno, lookup;\n\tu32 keysel;\n\n\tkeysel = VCAP_IS2_KEYSEL(true, VCAP_IS2_PS_NONETH_MAC_ETYPE,\n\t\t\t\t VCAP_IS2_PS_IPV4_MC_IP4_TCP_UDP_OTHER,\n\t\t\t\t VCAP_IS2_PS_IPV4_UC_IP4_TCP_UDP_OTHER,\n\t\t\t\t VCAP_IS2_PS_IPV6_MC_IP_7TUPLE,\n\t\t\t\t VCAP_IS2_PS_IPV6_UC_IP_7TUPLE,\n\t\t\t\t VCAP_IS2_PS_ARP_ARP);\n\tfor (lookup = 0; lookup < admin->lookups; ++lookup) {\n\t\tfor (portno = 0; portno < SPX5_PORTS; ++portno) {\n\t\t\tspx5_wr(keysel, sparx5,\n\t\t\t\tANA_ACL_VCAP_S2_KEY_SEL(portno, lookup));\n\t\t}\n\t}\n\t \n\tfor (portno = 0; portno < SPX5_PORTS; ++portno)\n\t\tspx5_rmw(ANA_ACL_VCAP_S2_CFG_SEC_ENA_SET(0xf),\n\t\t\t ANA_ACL_VCAP_S2_CFG_SEC_ENA,\n\t\t\t sparx5,\n\t\t\t ANA_ACL_VCAP_S2_CFG(portno));\n}\n\n \nstatic void sparx5_vcap_es0_port_key_selection(struct sparx5 *sparx5,\n\t\t\t\t\t       struct vcap_admin *admin)\n{\n\tint portno;\n\tu32 keysel;\n\n\tkeysel = VCAP_ES0_KEYSEL(VCAP_ES0_PS_FORCE_ISDX_LOOKUPS);\n\tfor (portno = 0; portno < SPX5_PORTS; ++portno)\n\t\tspx5_rmw(keysel, REW_RTAG_ETAG_CTRL_ES0_ISDX_KEY_ENA,\n\t\t\t sparx5, REW_RTAG_ETAG_CTRL(portno));\n\n\tspx5_rmw(REW_ES0_CTRL_ES0_LU_ENA_SET(1), REW_ES0_CTRL_ES0_LU_ENA,\n\t\t sparx5, REW_ES0_CTRL);\n}\n\n \nstatic void sparx5_vcap_es2_port_key_selection(struct sparx5 *sparx5,\n\t\t\t\t\t       struct vcap_admin *admin)\n{\n\tint portno, lookup;\n\tu32 keysel;\n\n\tkeysel = VCAP_ES2_KEYSEL(true, VCAP_ES2_PS_ARP_MAC_ETYPE,\n\t\t\t\t VCAP_ES2_PS_IPV4_IP4_TCP_UDP_OTHER,\n\t\t\t\t VCAP_ES2_PS_IPV6_IP_7TUPLE);\n\tfor (lookup = 0; lookup < admin->lookups; ++lookup)\n\t\tfor (portno = 0; portno < SPX5_PORTS; ++portno)\n\t\t\tspx5_wr(keysel, sparx5,\n\t\t\t\tEACL_VCAP_ES2_KEY_SEL(portno, lookup));\n}\n\n \nstatic void sparx5_vcap_port_key_selection(struct sparx5 *sparx5,\n\t\t\t\t\t   struct vcap_admin *admin)\n{\n\tswitch (admin->vtype) {\n\tcase VCAP_TYPE_IS0:\n\t\tsparx5_vcap_is0_port_key_selection(sparx5, admin);\n\t\tbreak;\n\tcase VCAP_TYPE_IS2:\n\t\tsparx5_vcap_is2_port_key_selection(sparx5, admin);\n\t\tbreak;\n\tcase VCAP_TYPE_ES0:\n\t\tsparx5_vcap_es0_port_key_selection(sparx5, admin);\n\t\tbreak;\n\tcase VCAP_TYPE_ES2:\n\t\tsparx5_vcap_es2_port_key_selection(sparx5, admin);\n\t\tbreak;\n\tdefault:\n\t\tsparx5_vcap_type_err(sparx5, admin, __func__);\n\t\tbreak;\n\t}\n}\n\n \nstatic void sparx5_vcap_port_key_deselection(struct sparx5 *sparx5,\n\t\t\t\t\t     struct vcap_admin *admin)\n{\n\tint portno, lookup;\n\n\tswitch (admin->vtype) {\n\tcase VCAP_TYPE_IS0:\n\t\tfor (lookup = 0; lookup < admin->lookups; ++lookup)\n\t\t\tfor (portno = 0; portno < SPX5_PORTS; ++portno)\n\t\t\t\tspx5_rmw(ANA_CL_ADV_CL_CFG_LOOKUP_ENA_SET(0),\n\t\t\t\t\t ANA_CL_ADV_CL_CFG_LOOKUP_ENA,\n\t\t\t\t\t sparx5,\n\t\t\t\t\t ANA_CL_ADV_CL_CFG(portno, lookup));\n\t\tbreak;\n\tcase VCAP_TYPE_IS2:\n\t\tfor (portno = 0; portno < SPX5_PORTS; ++portno)\n\t\t\tspx5_rmw(ANA_ACL_VCAP_S2_CFG_SEC_ENA_SET(0),\n\t\t\t\t ANA_ACL_VCAP_S2_CFG_SEC_ENA,\n\t\t\t\t sparx5,\n\t\t\t\t ANA_ACL_VCAP_S2_CFG(portno));\n\t\tbreak;\n\tcase VCAP_TYPE_ES0:\n\t\tspx5_rmw(REW_ES0_CTRL_ES0_LU_ENA_SET(0),\n\t\t\t REW_ES0_CTRL_ES0_LU_ENA, sparx5, REW_ES0_CTRL);\n\t\tbreak;\n\tcase VCAP_TYPE_ES2:\n\t\tfor (lookup = 0; lookup < admin->lookups; ++lookup)\n\t\t\tfor (portno = 0; portno < SPX5_PORTS; ++portno)\n\t\t\t\tspx5_rmw(EACL_VCAP_ES2_KEY_SEL_KEY_ENA_SET(0),\n\t\t\t\t\t EACL_VCAP_ES2_KEY_SEL_KEY_ENA,\n\t\t\t\t\t sparx5,\n\t\t\t\t\t EACL_VCAP_ES2_KEY_SEL(portno, lookup));\n\t\tbreak;\n\tdefault:\n\t\tsparx5_vcap_type_err(sparx5, admin, __func__);\n\t\tbreak;\n\t}\n}\n\nstatic void sparx5_vcap_admin_free(struct vcap_admin *admin)\n{\n\tif (!admin)\n\t\treturn;\n\tmutex_destroy(&admin->lock);\n\tkfree(admin->cache.keystream);\n\tkfree(admin->cache.maskstream);\n\tkfree(admin->cache.actionstream);\n\tkfree(admin);\n}\n\n \nstatic struct vcap_admin *\nsparx5_vcap_admin_alloc(struct sparx5 *sparx5, struct vcap_control *ctrl,\n\t\t\tconst struct sparx5_vcap_inst *cfg)\n{\n\tstruct vcap_admin *admin;\n\n\tadmin = kzalloc(sizeof(*admin), GFP_KERNEL);\n\tif (!admin)\n\t\treturn ERR_PTR(-ENOMEM);\n\tINIT_LIST_HEAD(&admin->list);\n\tINIT_LIST_HEAD(&admin->rules);\n\tINIT_LIST_HEAD(&admin->enabled);\n\tmutex_init(&admin->lock);\n\tadmin->vtype = cfg->vtype;\n\tadmin->vinst = cfg->vinst;\n\tadmin->ingress = cfg->ingress;\n\tadmin->lookups = cfg->lookups;\n\tadmin->lookups_per_instance = cfg->lookups_per_instance;\n\tadmin->first_cid = cfg->first_cid;\n\tadmin->last_cid = cfg->last_cid;\n\tadmin->cache.keystream =\n\t\tkzalloc(STREAMSIZE, GFP_KERNEL);\n\tadmin->cache.maskstream =\n\t\tkzalloc(STREAMSIZE, GFP_KERNEL);\n\tadmin->cache.actionstream =\n\t\tkzalloc(STREAMSIZE, GFP_KERNEL);\n\tif (!admin->cache.keystream || !admin->cache.maskstream ||\n\t    !admin->cache.actionstream) {\n\t\tsparx5_vcap_admin_free(admin);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\treturn admin;\n}\n\n \nstatic void sparx5_vcap_block_alloc(struct sparx5 *sparx5,\n\t\t\t\t    struct vcap_admin *admin,\n\t\t\t\t    const struct sparx5_vcap_inst *cfg)\n{\n\tint idx, cores;\n\n\tswitch (admin->vtype) {\n\tcase VCAP_TYPE_IS0:\n\tcase VCAP_TYPE_IS2:\n\t\t \n\t\tfor (idx = cfg->blockno; idx < cfg->blockno + cfg->blocks;\n\t\t     ++idx) {\n\t\t\tspx5_wr(VCAP_SUPER_IDX_CORE_IDX_SET(idx), sparx5,\n\t\t\t\tVCAP_SUPER_IDX);\n\t\t\tspx5_wr(VCAP_SUPER_MAP_CORE_MAP_SET(cfg->map_id),\n\t\t\t\tsparx5, VCAP_SUPER_MAP);\n\t\t}\n\t\tadmin->first_valid_addr = cfg->blockno * SUPER_VCAP_BLK_SIZE;\n\t\tadmin->last_used_addr = admin->first_valid_addr +\n\t\t\tcfg->blocks * SUPER_VCAP_BLK_SIZE;\n\t\tadmin->last_valid_addr = admin->last_used_addr - 1;\n\t\tbreak;\n\tcase VCAP_TYPE_ES0:\n\t\tadmin->first_valid_addr = 0;\n\t\tadmin->last_used_addr = cfg->count;\n\t\tadmin->last_valid_addr = cfg->count - 1;\n\t\tcores = spx5_rd(sparx5, VCAP_ES0_CORE_CNT);\n\t\tfor (idx = 0; idx < cores; ++idx) {\n\t\t\tspx5_wr(VCAP_ES0_IDX_CORE_IDX_SET(idx), sparx5,\n\t\t\t\tVCAP_ES0_IDX);\n\t\t\tspx5_wr(VCAP_ES0_MAP_CORE_MAP_SET(1), sparx5,\n\t\t\t\tVCAP_ES0_MAP);\n\t\t}\n\t\tbreak;\n\tcase VCAP_TYPE_ES2:\n\t\tadmin->first_valid_addr = 0;\n\t\tadmin->last_used_addr = cfg->count;\n\t\tadmin->last_valid_addr = cfg->count - 1;\n\t\tcores = spx5_rd(sparx5, VCAP_ES2_CORE_CNT);\n\t\tfor (idx = 0; idx < cores; ++idx) {\n\t\t\tspx5_wr(VCAP_ES2_IDX_CORE_IDX_SET(idx), sparx5,\n\t\t\t\tVCAP_ES2_IDX);\n\t\t\tspx5_wr(VCAP_ES2_MAP_CORE_MAP_SET(1), sparx5,\n\t\t\t\tVCAP_ES2_MAP);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tsparx5_vcap_type_err(sparx5, admin, __func__);\n\t\tbreak;\n\t}\n}\n\n \nint sparx5_vcap_init(struct sparx5 *sparx5)\n{\n\tconst struct sparx5_vcap_inst *cfg;\n\tstruct vcap_control *ctrl;\n\tstruct vcap_admin *admin;\n\tstruct dentry *dir;\n\tint err = 0, idx;\n\n\t \n\tctrl = kzalloc(sizeof(*ctrl), GFP_KERNEL);\n\tif (!ctrl)\n\t\treturn -ENOMEM;\n\n\tsparx5->vcap_ctrl = ctrl;\n\t \n\tctrl->vcaps = sparx5_vcaps;\n\tctrl->stats = &sparx5_vcap_stats;\n\t \n\tctrl->ops = &sparx5_vcap_ops;\n\n\tINIT_LIST_HEAD(&ctrl->list);\n\tfor (idx = 0; idx < ARRAY_SIZE(sparx5_vcap_inst_cfg); ++idx) {\n\t\tcfg = &sparx5_vcap_inst_cfg[idx];\n\t\tadmin = sparx5_vcap_admin_alloc(sparx5, ctrl, cfg);\n\t\tif (IS_ERR(admin)) {\n\t\t\terr = PTR_ERR(admin);\n\t\t\tpr_err(\"%s:%d: vcap allocation failed: %d\\n\",\n\t\t\t       __func__, __LINE__, err);\n\t\t\treturn err;\n\t\t}\n\t\tsparx5_vcap_block_alloc(sparx5, admin, cfg);\n\t\tsparx5_vcap_block_init(sparx5, admin);\n\t\tif (cfg->vinst == 0)\n\t\t\tsparx5_vcap_port_key_selection(sparx5, admin);\n\t\tlist_add_tail(&admin->list, &ctrl->list);\n\t}\n\tdir = vcap_debugfs(sparx5->dev, sparx5->debugfs_root, ctrl);\n\tfor (idx = 0; idx < SPX5_PORTS; ++idx)\n\t\tif (sparx5->ports[idx])\n\t\t\tvcap_port_debugfs(sparx5->dev, dir, ctrl,\n\t\t\t\t\t  sparx5->ports[idx]->ndev);\n\n\treturn err;\n}\n\nvoid sparx5_vcap_destroy(struct sparx5 *sparx5)\n{\n\tstruct vcap_control *ctrl = sparx5->vcap_ctrl;\n\tstruct vcap_admin *admin, *admin_next;\n\n\tif (!ctrl)\n\t\treturn;\n\n\tlist_for_each_entry_safe(admin, admin_next, &ctrl->list, list) {\n\t\tsparx5_vcap_port_key_deselection(sparx5, admin);\n\t\tvcap_del_rules(ctrl, admin);\n\t\tlist_del(&admin->list);\n\t\tsparx5_vcap_admin_free(admin);\n\t}\n\tkfree(ctrl);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}