{
  "module_name": "sparx5_sdlb.c",
  "hash_id": "8d1e440be6ad6c2eebad6a3f462099e24cc4fd1b6a1fd4a89536d22a74648761",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/microchip/sparx5/sparx5_sdlb.c",
  "human_readable_source": "\n \n\n#include \"sparx5_main_regs.h\"\n#include \"sparx5_main.h\"\n\nstruct sparx5_sdlb_group sdlb_groups[SPX5_SDLB_GROUP_CNT] = {\n\t{ SPX5_SDLB_GROUP_RATE_MAX,    8192 / 1, 64 },  \n\t{ 15000000000ULL,              8192 / 1, 64 },  \n\t{ 10000000000ULL,              8192 / 1, 64 },  \n\t{  5000000000ULL,              8192 / 1, 64 },  \n\t{  2500000000ULL,              8192 / 1, 64 },  \n\t{  1000000000ULL,              8192 / 2, 64 },  \n\t{   500000000ULL,              8192 / 2, 64 },  \n\t{   100000000ULL,              8192 / 4, 64 },  \n\t{    50000000ULL,              8192 / 4, 64 },  \n\t{     5000000ULL,              8192 / 8, 64 }   \n};\n\nint sparx5_sdlb_clk_hz_get(struct sparx5 *sparx5)\n{\n\tu32 clk_per_100ps;\n\tu64 clk_hz;\n\n\tclk_per_100ps = HSCH_SYS_CLK_PER_100PS_GET(spx5_rd(sparx5,\n\t\t\t\t\t\t\t   HSCH_SYS_CLK_PER));\n\tif (!clk_per_100ps)\n\t\tclk_per_100ps = SPX5_CLK_PER_100PS_DEFAULT;\n\n\tclk_hz = (10 * 1000 * 1000) / clk_per_100ps;\n\treturn clk_hz *= 1000;\n}\n\nstatic int sparx5_sdlb_pup_interval_get(struct sparx5 *sparx5, u32 max_token,\n\t\t\t\t\tu64 max_rate)\n{\n\tu64 clk_hz;\n\n\tclk_hz = sparx5_sdlb_clk_hz_get(sparx5);\n\n\treturn div64_u64((8 * clk_hz * max_token), max_rate);\n}\n\nint sparx5_sdlb_pup_token_get(struct sparx5 *sparx5, u32 pup_interval, u64 rate)\n{\n\tu64 clk_hz;\n\n\tif (!rate)\n\t\treturn SPX5_SDLB_PUP_TOKEN_DISABLE;\n\n\tclk_hz = sparx5_sdlb_clk_hz_get(sparx5);\n\n\treturn DIV64_U64_ROUND_UP((rate * pup_interval), (clk_hz * 8));\n}\n\nstatic void sparx5_sdlb_group_disable(struct sparx5 *sparx5, u32 group)\n{\n\tspx5_rmw(ANA_AC_SDLB_PUP_CTRL_PUP_ENA_SET(0),\n\t\t ANA_AC_SDLB_PUP_CTRL_PUP_ENA, sparx5,\n\t\t ANA_AC_SDLB_PUP_CTRL(group));\n}\n\nstatic void sparx5_sdlb_group_enable(struct sparx5 *sparx5, u32 group)\n{\n\tspx5_rmw(ANA_AC_SDLB_PUP_CTRL_PUP_ENA_SET(1),\n\t\t ANA_AC_SDLB_PUP_CTRL_PUP_ENA, sparx5,\n\t\t ANA_AC_SDLB_PUP_CTRL(group));\n}\n\nstatic u32 sparx5_sdlb_group_get_first(struct sparx5 *sparx5, u32 group)\n{\n\tu32 val;\n\n\tval = spx5_rd(sparx5, ANA_AC_SDLB_XLB_START(group));\n\n\treturn ANA_AC_SDLB_XLB_START_LBSET_START_GET(val);\n}\n\nstatic u32 sparx5_sdlb_group_get_next(struct sparx5 *sparx5, u32 group,\n\t\t\t\t      u32 lb)\n{\n\tu32 val;\n\n\tval = spx5_rd(sparx5, ANA_AC_SDLB_XLB_NEXT(lb));\n\n\treturn ANA_AC_SDLB_XLB_NEXT_LBSET_NEXT_GET(val);\n}\n\nstatic bool sparx5_sdlb_group_is_first(struct sparx5 *sparx5, u32 group,\n\t\t\t\t       u32 lb)\n{\n\treturn lb == sparx5_sdlb_group_get_first(sparx5, group);\n}\n\nstatic bool sparx5_sdlb_group_is_last(struct sparx5 *sparx5, u32 group,\n\t\t\t\t      u32 lb)\n{\n\treturn lb == sparx5_sdlb_group_get_next(sparx5, group, lb);\n}\n\nstatic bool sparx5_sdlb_group_is_empty(struct sparx5 *sparx5, u32 group)\n{\n\tu32 val;\n\n\tval = spx5_rd(sparx5, ANA_AC_SDLB_PUP_CTRL(group));\n\n\treturn ANA_AC_SDLB_PUP_CTRL_PUP_ENA_GET(val) == 0;\n}\n\nstatic u32 sparx5_sdlb_group_get_last(struct sparx5 *sparx5, u32 group)\n{\n\tu32 itr, next;\n\n\titr = sparx5_sdlb_group_get_first(sparx5, group);\n\n\tfor (;;) {\n\t\tnext = sparx5_sdlb_group_get_next(sparx5, group, itr);\n\t\tif (itr == next)\n\t\t\treturn itr;\n\n\t\titr = next;\n\t}\n}\n\nstatic bool sparx5_sdlb_group_is_singular(struct sparx5 *sparx5, u32 group)\n{\n\tif (sparx5_sdlb_group_is_empty(sparx5, group))\n\t\treturn false;\n\n\treturn sparx5_sdlb_group_get_first(sparx5, group) ==\n\t       sparx5_sdlb_group_get_last(sparx5, group);\n}\n\nstatic int sparx5_sdlb_group_get_adjacent(struct sparx5 *sparx5, u32 group,\n\t\t\t\t\t  u32 idx, u32 *prev, u32 *next,\n\t\t\t\t\t  u32 *first)\n{\n\tu32 itr;\n\n\t*first = sparx5_sdlb_group_get_first(sparx5, group);\n\t*prev = *first;\n\t*next = *first;\n\titr = *first;\n\n\tfor (;;) {\n\t\t*next = sparx5_sdlb_group_get_next(sparx5, group, itr);\n\n\t\tif (itr == idx)\n\t\t\treturn 0;  \n\n\t\tif (itr == *next)\n\t\t\treturn -EINVAL;  \n\n\t\t*prev = itr;\n\t\titr = *next;\n\t}\n}\n\nstatic int sparx5_sdlb_group_get_count(struct sparx5 *sparx5, u32 group)\n{\n\tu32 itr, next;\n\tint count = 0;\n\n\titr = sparx5_sdlb_group_get_first(sparx5, group);\n\n\tfor (;;) {\n\t\tnext = sparx5_sdlb_group_get_next(sparx5, group, itr);\n\t\tif (itr == next)\n\t\t\treturn count;\n\n\t\titr = next;\n\t\tcount++;\n\t}\n}\n\nint sparx5_sdlb_group_get_by_rate(struct sparx5 *sparx5, u32 rate, u32 burst)\n{\n\tconst struct sparx5_sdlb_group *group;\n\tu64 rate_bps;\n\tint i, count;\n\n\trate_bps = rate * 1000;\n\n\tfor (i = SPX5_SDLB_GROUP_CNT - 1; i >= 0; i--) {\n\t\tgroup = &sdlb_groups[i];\n\n\t\tcount = sparx5_sdlb_group_get_count(sparx5, i);\n\n\t\t \n\t\tif (count > ((group->pup_interval / 4) - 1))\n\t\t\tcontinue;\n\n\t\tif (rate_bps < group->max_rate)\n\t\t\treturn i;\n\t}\n\n\treturn -ENOSPC;\n}\n\nint sparx5_sdlb_group_get_by_index(struct sparx5 *sparx5, u32 idx, u32 *group)\n{\n\tu32 itr, next;\n\tint i;\n\n\tfor (i = 0; i < SPX5_SDLB_GROUP_CNT; i++) {\n\t\tif (sparx5_sdlb_group_is_empty(sparx5, i))\n\t\t\tcontinue;\n\n\t\titr = sparx5_sdlb_group_get_first(sparx5, i);\n\n\t\tfor (;;) {\n\t\t\tnext = sparx5_sdlb_group_get_next(sparx5, i, itr);\n\n\t\t\tif (itr == idx) {\n\t\t\t\t*group = i;\n\t\t\t\treturn 0;  \n\t\t\t}\n\t\t\tif (itr == next)\n\t\t\t\tbreak;  \n\n\t\t\titr = next;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int sparx5_sdlb_group_link(struct sparx5 *sparx5, u32 group, u32 idx,\n\t\t\t\t  u32 first, u32 next, bool empty)\n{\n\t \n\tsparx5_sdlb_group_disable(sparx5, group);\n\n\tif (empty)\n\t\treturn 0;\n\n\t \n\tspx5_wr(ANA_AC_SDLB_XLB_NEXT_LBSET_NEXT_SET(next) |\n\t\t\tANA_AC_SDLB_XLB_NEXT_LBGRP_SET(group),\n\t\tsparx5, ANA_AC_SDLB_XLB_NEXT(idx));\n\n\t \n\tspx5_wr(ANA_AC_SDLB_XLB_START_LBSET_START_SET(first), sparx5,\n\t\tANA_AC_SDLB_XLB_START(group));\n\n\t \n\tsparx5_sdlb_group_enable(sparx5, group);\n\n\treturn 0;\n};\n\nint sparx5_sdlb_group_add(struct sparx5 *sparx5, u32 group, u32 idx)\n{\n\tu32 first, next;\n\n\t \n\tfirst = idx;\n\n\tif (sparx5_sdlb_group_is_empty(sparx5, group))\n\t\tnext = idx;\n\telse\n\t\tnext = sparx5_sdlb_group_get_first(sparx5, group);\n\n\treturn sparx5_sdlb_group_link(sparx5, group, idx, first, next, false);\n}\n\nint sparx5_sdlb_group_del(struct sparx5 *sparx5, u32 group, u32 idx)\n{\n\tu32 first, next, prev;\n\tbool empty = false;\n\n\tif (sparx5_sdlb_group_get_adjacent(sparx5, group, idx, &prev, &next,\n\t\t\t\t\t   &first) < 0) {\n\t\tpr_err(\"%s:%d Could not find idx: %d in group: %d\", __func__,\n\t\t       __LINE__, idx, group);\n\t\treturn -EINVAL;\n\t}\n\n\tif (sparx5_sdlb_group_is_singular(sparx5, group)) {\n\t\tempty = true;\n\t} else if (sparx5_sdlb_group_is_last(sparx5, group, idx)) {\n\t\t \n\t\tidx = prev;\n\t\tnext = prev;\n\t} else if (sparx5_sdlb_group_is_first(sparx5, group, idx)) {\n\t\t \n\t\tfirst = next;\n\t\tnext = idx;\n\t} else {\n\t\t \n\t\tidx = prev;\n\t}\n\n\treturn sparx5_sdlb_group_link(sparx5, group, idx, first, next, empty);\n}\n\nvoid sparx5_sdlb_group_init(struct sparx5 *sparx5, u64 max_rate, u32 min_burst,\n\t\t\t    u32 frame_size, u32 idx)\n{\n\tu32 thres_shift, mask = 0x01, power = 0;\n\tstruct sparx5_sdlb_group *group;\n\tu64 max_token;\n\n\tgroup = &sdlb_groups[idx];\n\n\t \n\twhile ((min_burst & mask) == 0) {\n\t\tpower++;\n\t\tmask <<= 1;\n\t}\n\tthres_shift = SPX5_SDLB_2CYCLES_TYPE2_THRES_OFFSET - power;\n\n\tmax_token = (min_burst > SPX5_SDLB_PUP_TOKEN_MAX) ?\n\t\t\t    SPX5_SDLB_PUP_TOKEN_MAX :\n\t\t\t    min_burst;\n\tgroup->pup_interval =\n\t\tsparx5_sdlb_pup_interval_get(sparx5, max_token, max_rate);\n\n\tgroup->frame_size = frame_size;\n\n\tspx5_wr(ANA_AC_SDLB_PUP_INTERVAL_PUP_INTERVAL_SET(group->pup_interval),\n\t\tsparx5, ANA_AC_SDLB_PUP_INTERVAL(idx));\n\n\tspx5_wr(ANA_AC_SDLB_FRM_RATE_TOKENS_FRM_RATE_TOKENS_SET(frame_size),\n\t\tsparx5, ANA_AC_SDLB_FRM_RATE_TOKENS(idx));\n\n\tspx5_wr(ANA_AC_SDLB_LBGRP_MISC_THRES_SHIFT_SET(thres_shift), sparx5,\n\t\tANA_AC_SDLB_LBGRP_MISC(idx));\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}