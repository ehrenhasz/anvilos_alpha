{
  "module_name": "sparx5_vlan.c",
  "hash_id": "4cb93180c9fef12ac291f876201b40ea88160de39f96cab31008461d8a6b49f0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/microchip/sparx5/sparx5_vlan.c",
  "human_readable_source": "\n \n\n#include \"sparx5_main_regs.h\"\n#include \"sparx5_main.h\"\n\nstatic int sparx5_vlant_set_mask(struct sparx5 *sparx5, u16 vid)\n{\n\tu32 mask[3];\n\n\t \n\tbitmap_to_arr32(mask, sparx5->vlan_mask[vid], SPX5_PORTS);\n\n\t \n\tspx5_wr(mask[0], sparx5, ANA_L3_VLAN_MASK_CFG(vid));\n\tspx5_wr(mask[1], sparx5, ANA_L3_VLAN_MASK_CFG1(vid));\n\tspx5_wr(mask[2], sparx5, ANA_L3_VLAN_MASK_CFG2(vid));\n\n\treturn 0;\n}\n\nvoid sparx5_vlan_init(struct sparx5 *sparx5)\n{\n\tu16 vid;\n\n\tspx5_rmw(ANA_L3_VLAN_CTRL_VLAN_ENA_SET(1),\n\t\t ANA_L3_VLAN_CTRL_VLAN_ENA,\n\t\t sparx5,\n\t\t ANA_L3_VLAN_CTRL);\n\n\t \n\tfor (vid = NULL_VID; vid < VLAN_N_VID; vid++)\n\t\tspx5_rmw(ANA_L3_VLAN_CFG_VLAN_FID_SET(vid),\n\t\t\t ANA_L3_VLAN_CFG_VLAN_FID,\n\t\t\t sparx5,\n\t\t\t ANA_L3_VLAN_CFG(vid));\n}\n\nvoid sparx5_vlan_port_setup(struct sparx5 *sparx5, int portno)\n{\n\tstruct sparx5_port *port = sparx5->ports[portno];\n\n\t \n\tspx5_rmw(ANA_CL_VLAN_CTRL_VLAN_AWARE_ENA_SET(0) |\n\t\t ANA_CL_VLAN_CTRL_PORT_VID_SET(port->pvid),\n\t\t ANA_CL_VLAN_CTRL_VLAN_AWARE_ENA |\n\t\t ANA_CL_VLAN_CTRL_PORT_VID,\n\t\t sparx5,\n\t\t ANA_CL_VLAN_CTRL(port->portno));\n}\n\nint sparx5_vlan_vid_add(struct sparx5_port *port, u16 vid, bool pvid,\n\t\t\tbool untagged)\n{\n\tstruct sparx5 *sparx5 = port->sparx5;\n\tint ret;\n\n\t \n\tif (untagged && port->vid != vid) {\n\t\tif (port->vid) {\n\t\t\tnetdev_err(port->ndev,\n\t\t\t\t   \"Port already has a native VLAN: %d\\n\",\n\t\t\t\t   port->vid);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tport->vid = vid;\n\t}\n\n\t \n\tset_bit(port->portno, sparx5->vlan_mask[vid]);\n\tret = sparx5_vlant_set_mask(sparx5, vid);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (pvid)\n\t\tport->pvid = vid;\n\n\tsparx5_vlan_port_apply(sparx5, port);\n\n\treturn 0;\n}\n\nint sparx5_vlan_vid_del(struct sparx5_port *port, u16 vid)\n{\n\tstruct sparx5 *sparx5 = port->sparx5;\n\tint ret;\n\n\t \n\tif (vid == 0)\n\t\treturn 0;\n\n\t \n\tclear_bit(port->portno, sparx5->vlan_mask[vid]);\n\tret = sparx5_vlant_set_mask(sparx5, vid);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (port->pvid == vid)\n\t\tport->pvid = 0;\n\n\t \n\tif (port->vid == vid)\n\t\tport->vid = 0;\n\n\tsparx5_vlan_port_apply(sparx5, port);\n\n\treturn 0;\n}\n\nvoid sparx5_pgid_update_mask(struct sparx5_port *port, int pgid, bool enable)\n{\n\tstruct sparx5 *sparx5 = port->sparx5;\n\tu32 val, mask;\n\n\t \n\tif (port->portno < 32) {\n\t\tmask = BIT(port->portno);\n\t\tval = enable ? mask : 0;\n\t\tspx5_rmw(val, mask, sparx5, ANA_AC_PGID_CFG(pgid));\n\t} else if (port->portno < 64) {\n\t\tmask = BIT(port->portno - 32);\n\t\tval = enable ? mask : 0;\n\t\tspx5_rmw(val, mask, sparx5, ANA_AC_PGID_CFG1(pgid));\n\t} else if (port->portno < SPX5_PORTS) {\n\t\tmask = BIT(port->portno - 64);\n\t\tval = enable ? mask : 0;\n\t\tspx5_rmw(val, mask, sparx5, ANA_AC_PGID_CFG2(pgid));\n\t} else {\n\t\tnetdev_err(port->ndev, \"Invalid port no: %d\\n\", port->portno);\n\t}\n}\n\nvoid sparx5_pgid_clear(struct sparx5 *spx5, int pgid)\n{\n\tspx5_wr(0, spx5, ANA_AC_PGID_CFG(pgid));\n\tspx5_wr(0, spx5, ANA_AC_PGID_CFG1(pgid));\n\tspx5_wr(0, spx5, ANA_AC_PGID_CFG2(pgid));\n}\n\nvoid sparx5_pgid_read_mask(struct sparx5 *spx5, int pgid, u32 portmask[3])\n{\n\tportmask[0] = spx5_rd(spx5, ANA_AC_PGID_CFG(pgid));\n\tportmask[1] = spx5_rd(spx5, ANA_AC_PGID_CFG1(pgid));\n\tportmask[2] = spx5_rd(spx5, ANA_AC_PGID_CFG2(pgid));\n}\n\nvoid sparx5_update_fwd(struct sparx5 *sparx5)\n{\n\tDECLARE_BITMAP(workmask, SPX5_PORTS);\n\tu32 mask[3];\n\tint port;\n\n\t \n\tbitmap_to_arr32(mask, sparx5->bridge_fwd_mask, SPX5_PORTS);\n\n\t \n\tfor (port = PGID_UC_FLOOD; port <= PGID_BCAST; port++) {\n\t\tspx5_wr(mask[0], sparx5, ANA_AC_PGID_CFG(port));\n\t\tspx5_wr(mask[1], sparx5, ANA_AC_PGID_CFG1(port));\n\t\tspx5_wr(mask[2], sparx5, ANA_AC_PGID_CFG2(port));\n\t}\n\n\t \n\tfor (port = 0; port < SPX5_PORTS; port++) {\n\t\tif (test_bit(port, sparx5->bridge_fwd_mask)) {\n\t\t\t \n\t\t\tbitmap_copy(workmask, sparx5->bridge_fwd_mask, SPX5_PORTS);\n\t\t\tclear_bit(port, workmask);\n\t\t\tbitmap_to_arr32(mask, workmask, SPX5_PORTS);\n\t\t\tspx5_wr(mask[0], sparx5, ANA_AC_SRC_CFG(port));\n\t\t\tspx5_wr(mask[1], sparx5, ANA_AC_SRC_CFG1(port));\n\t\t\tspx5_wr(mask[2], sparx5, ANA_AC_SRC_CFG2(port));\n\t\t} else {\n\t\t\tspx5_wr(0, sparx5, ANA_AC_SRC_CFG(port));\n\t\t\tspx5_wr(0, sparx5, ANA_AC_SRC_CFG1(port));\n\t\t\tspx5_wr(0, sparx5, ANA_AC_SRC_CFG2(port));\n\t\t}\n\t}\n\n\t \n\tbitmap_and(workmask, sparx5->bridge_fwd_mask,\n\t\t   sparx5->bridge_lrn_mask, SPX5_PORTS);\n\tbitmap_to_arr32(mask, workmask, SPX5_PORTS);\n\n\t \n\tspx5_wr(mask[0], sparx5, ANA_L2_AUTO_LRN_CFG);\n\tspx5_wr(mask[1], sparx5, ANA_L2_AUTO_LRN_CFG1);\n\tspx5_wr(mask[2], sparx5, ANA_L2_AUTO_LRN_CFG2);\n}\n\nvoid sparx5_vlan_port_apply(struct sparx5 *sparx5,\n\t\t\t    struct sparx5_port *port)\n\n{\n\tu32 val;\n\n\t \n\tval = ANA_CL_VLAN_CTRL_VLAN_AWARE_ENA_SET(port->vlan_aware) |\n\t\tANA_CL_VLAN_CTRL_VLAN_POP_CNT_SET(port->vlan_aware) |\n\t\tANA_CL_VLAN_CTRL_PORT_VID_SET(port->pvid);\n\tspx5_wr(val, sparx5, ANA_CL_VLAN_CTRL(port->portno));\n\n\tval = 0;\n\tif (port->vlan_aware && !port->pvid)\n\t\t \n\t\tval = ANA_CL_VLAN_FILTER_CTRL_TAG_REQUIRED_ENA_SET(1) |\n\t\t\tANA_CL_VLAN_FILTER_CTRL_PRIO_CTAG_DIS_SET(1) |\n\t\t\tANA_CL_VLAN_FILTER_CTRL_PRIO_STAG_DIS_SET(1);\n\tspx5_wr(val, sparx5,\n\t\tANA_CL_VLAN_FILTER_CTRL(port->portno, 0));\n\n\t \n\tval = REW_TAG_CTRL_TAG_TPID_CFG_SET(5);\n\tif (port->vlan_aware) {\n\t\tif (port->vid)\n\t\t\t \n\t\t\tval |= REW_TAG_CTRL_TAG_CFG_SET(1);\n\t\telse\n\t\t\tval |= REW_TAG_CTRL_TAG_CFG_SET(3);\n\t}\n\tspx5_wr(val, sparx5, REW_TAG_CTRL(port->portno));\n\n\t \n\tspx5_rmw(REW_PORT_VLAN_CFG_PORT_VID_SET(port->vid),\n\t\t REW_PORT_VLAN_CFG_PORT_VID,\n\t\t sparx5,\n\t\t REW_PORT_VLAN_CFG(port->portno));\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}