{
  "module_name": "sparx5_dcb.c",
  "hash_id": "937acc4968e89fb2cd2bb1f2b5676b5b39dc0a94ff6dfbbd99639cb713e73e75",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/microchip/sparx5/sparx5_dcb.c",
  "human_readable_source": "\n \n\n#include <net/dcbnl.h>\n\n#include \"sparx5_port.h\"\n\nenum sparx5_dcb_apptrust_values {\n\tSPARX5_DCB_APPTRUST_EMPTY,\n\tSPARX5_DCB_APPTRUST_DSCP,\n\tSPARX5_DCB_APPTRUST_PCP,\n\tSPARX5_DCB_APPTRUST_DSCP_PCP,\n\t__SPARX5_DCB_APPTRUST_MAX\n};\n\nstatic const struct sparx5_dcb_apptrust {\n\tu8 selectors[IEEE_8021QAZ_APP_SEL_MAX + 1];\n\tint nselectors;\n} *sparx5_port_apptrust[SPX5_PORTS];\n\nstatic const char *sparx5_dcb_apptrust_names[__SPARX5_DCB_APPTRUST_MAX] = {\n\t[SPARX5_DCB_APPTRUST_EMPTY]    = \"empty\",\n\t[SPARX5_DCB_APPTRUST_DSCP]     = \"dscp\",\n\t[SPARX5_DCB_APPTRUST_PCP]      = \"pcp\",\n\t[SPARX5_DCB_APPTRUST_DSCP_PCP] = \"dscp pcp\"\n};\n\n \nstatic const struct sparx5_dcb_apptrust\n\tsparx5_dcb_apptrust_policies[__SPARX5_DCB_APPTRUST_MAX] = {\n\t \n\t[SPARX5_DCB_APPTRUST_EMPTY]    = { { 0 }, 0 },\n\t[SPARX5_DCB_APPTRUST_DSCP]     = { { IEEE_8021QAZ_APP_SEL_DSCP }, 1 },\n\t[SPARX5_DCB_APPTRUST_PCP]      = { { DCB_APP_SEL_PCP }, 1 },\n\t[SPARX5_DCB_APPTRUST_DSCP_PCP] = { { IEEE_8021QAZ_APP_SEL_DSCP,\n\t\t\t\t\t     DCB_APP_SEL_PCP }, 2 },\n};\n\n \nstatic int sparx5_dcb_app_validate(struct net_device *dev,\n\t\t\t\t   const struct dcb_app *app)\n{\n\tint err = 0;\n\n\tswitch (app->selector) {\n\t \n\tcase IEEE_8021QAZ_APP_SEL_ETHERTYPE:\n\t\tif (app->protocol != 0)\n\t\t\terr = -EINVAL;\n\t\telse if (app->priority >= SPX5_PRIOS)\n\t\t\terr = -ERANGE;\n\t\tbreak;\n\t \n\tcase IEEE_8021QAZ_APP_SEL_DSCP:\n\t\tif (app->protocol >= SPARX5_PORT_QOS_DSCP_COUNT)\n\t\t\terr = -EINVAL;\n\t\telse if (app->priority >= SPX5_PRIOS)\n\t\t\terr = -ERANGE;\n\t\tbreak;\n\t \n\tcase DCB_APP_SEL_PCP:\n\t\tif (app->protocol >= SPARX5_PORT_QOS_PCP_DEI_COUNT)\n\t\t\terr = -EINVAL;\n\t\telse if (app->priority >= SPX5_PRIOS)\n\t\t\terr = -ERANGE;\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t\tbreak;\n\t}\n\n\tif (err)\n\t\tnetdev_err(dev, \"Invalid entry: %d:%d\\n\", app->protocol,\n\t\t\t   app->priority);\n\n\treturn err;\n}\n\n \nstatic int sparx5_dcb_apptrust_validate(struct net_device *dev, u8 *selectors,\n\t\t\t\t\tint nselectors, int *err)\n{\n\tbool match = false;\n\tint i, ii;\n\n\tfor (i = 0; i < ARRAY_SIZE(sparx5_dcb_apptrust_policies); i++) {\n\t\tif (sparx5_dcb_apptrust_policies[i].nselectors != nselectors)\n\t\t\tcontinue;\n\t\tmatch = true;\n\t\tfor (ii = 0; ii < nselectors; ii++) {\n\t\t\tif (sparx5_dcb_apptrust_policies[i].selectors[ii] !=\n\t\t\t    *(selectors + ii)) {\n\t\t\t\tmatch = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (match)\n\t\t\tbreak;\n\t}\n\n\t \n\tif (!match) {\n\t\tnetdev_err(dev, \"Valid apptrust configurations are:\\n\");\n\t\tfor (i = 0; i < ARRAY_SIZE(sparx5_dcb_apptrust_names); i++)\n\t\t\tpr_info(\"order: %s\\n\", sparx5_dcb_apptrust_names[i]);\n\t\t*err = -EOPNOTSUPP;\n\t}\n\n\treturn i;\n}\n\nstatic bool sparx5_dcb_apptrust_contains(int portno, u8 selector)\n{\n\tconst struct sparx5_dcb_apptrust *conf = sparx5_port_apptrust[portno];\n\tint i;\n\n\tfor (i = 0; i < conf->nselectors; i++)\n\t\tif (conf->selectors[i] == selector)\n\t\t\treturn true;\n\n\treturn false;\n}\n\nstatic int sparx5_dcb_app_update(struct net_device *dev)\n{\n\tstruct dcb_ieee_app_prio_map dscp_rewr_map = {0};\n\tstruct dcb_rewr_prio_pcp_map pcp_rewr_map = {0};\n\tstruct sparx5_port *port = netdev_priv(dev);\n\tstruct sparx5_port_qos_dscp_map *dscp_map;\n\tstruct sparx5_port_qos_pcp_map *pcp_map;\n\tstruct sparx5_port_qos qos = {0};\n\tstruct dcb_app app_itr = {0};\n\tint portno = port->portno;\n\tbool dscp_rewr = false;\n\tbool pcp_rewr = false;\n\tu16 dscp;\n\tint i;\n\n\tdscp_map = &qos.dscp.map;\n\tpcp_map = &qos.pcp.map;\n\n\t \n\tqos.default_prio = dcb_ieee_getapp_default_prio_mask(dev);\n\tif (qos.default_prio)\n\t\tqos.default_prio = fls(qos.default_prio) - 1;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(dscp_map->map); i++) {\n\t\tapp_itr.selector = IEEE_8021QAZ_APP_SEL_DSCP;\n\t\tapp_itr.protocol = i;\n\t\tdscp_map->map[i] = dcb_getapp(dev, &app_itr);\n\t}\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(pcp_map->map); i++) {\n\t\tapp_itr.selector = DCB_APP_SEL_PCP;\n\t\tapp_itr.protocol = i;\n\t\tpcp_map->map[i] = dcb_getapp(dev, &app_itr);\n\t}\n\n\t \n\tdcb_getrewr_prio_pcp_mask_map(dev, &pcp_rewr_map);\n\tfor (i = 0; i < ARRAY_SIZE(pcp_rewr_map.map); i++) {\n\t\tif (!pcp_rewr_map.map[i])\n\t\t\tcontinue;\n\t\tpcp_rewr = true;\n\t\tqos.pcp_rewr.map.map[i] = fls(pcp_rewr_map.map[i]) - 1;\n\t}\n\n\t \n\tdcb_getrewr_prio_dscp_mask_map(dev, &dscp_rewr_map);\n\tfor (i = 0; i < ARRAY_SIZE(dscp_rewr_map.map); i++) {\n\t\tif (!dscp_rewr_map.map[i])\n\t\t\tcontinue;\n\n\t\t \n\t\tdscp_rewr = true;\n\t\tdscp = fls64(dscp_rewr_map.map[i]) - 1;\n\t\tqos.dscp_rewr.map.map[i] = dscp;       \n\t\tqos.dscp_rewr.map.map[i + 8] = dscp;   \n\t\tqos.dscp_rewr.map.map[i + 16] = dscp;  \n\t\tqos.dscp_rewr.map.map[i + 24] = dscp;  \n\t}\n\n\t \n\tif (sparx5_dcb_apptrust_contains(portno, DCB_APP_SEL_PCP)) {\n\t\tqos.pcp.qos_enable = true;\n\t\tqos.pcp.dp_enable = qos.pcp.qos_enable;\n\t\t \n\t\tif (pcp_rewr)\n\t\t\tqos.pcp_rewr.enable = true;\n\t}\n\n\t \n\tif (sparx5_dcb_apptrust_contains(portno, IEEE_8021QAZ_APP_SEL_DSCP)) {\n\t\tqos.dscp.qos_enable = true;\n\t\tqos.dscp.dp_enable = qos.dscp.qos_enable;\n\t\tif (dscp_rewr)\n\t\t\t \n\t\t\tqos.dscp_rewr.enable = true;\n\t}\n\n\treturn sparx5_port_qos_set(port, &qos);\n}\n\n \nstatic int sparx5_dcb_ieee_dscp_setdel(struct net_device *dev,\n\t\t\t\t       struct dcb_app *app,\n\t\t\t\t       int (*setdel)(struct net_device *,\n\t\t\t\t\t\t     struct dcb_app *))\n{\n\tstruct sparx5_port *port = netdev_priv(dev);\n\tstruct sparx5_port *port_itr;\n\tint err, i;\n\n\tfor (i = 0; i < SPX5_PORTS; i++) {\n\t\tport_itr = port->sparx5->ports[i];\n\t\tif (!port_itr)\n\t\t\tcontinue;\n\t\terr = setdel(port_itr->ndev, app);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int sparx5_dcb_ieee_delapp(struct net_device *dev, struct dcb_app *app)\n{\n\tint err;\n\n\tif (app->selector == IEEE_8021QAZ_APP_SEL_DSCP)\n\t\terr = sparx5_dcb_ieee_dscp_setdel(dev, app, dcb_ieee_delapp);\n\telse\n\t\terr = dcb_ieee_delapp(dev, app);\n\n\tif (err < 0)\n\t\treturn err;\n\n\treturn sparx5_dcb_app_update(dev);\n}\n\nstatic int sparx5_dcb_ieee_setapp(struct net_device *dev, struct dcb_app *app)\n{\n\tstruct dcb_app app_itr;\n\tint err = 0;\n\tu8 prio;\n\n\terr = sparx5_dcb_app_validate(dev, app);\n\tif (err)\n\t\tgoto out;\n\n\t \n\tprio = dcb_getapp(dev, app);\n\tif (prio) {\n\t\tapp_itr = *app;\n\t\tapp_itr.priority = prio;\n\t\tsparx5_dcb_ieee_delapp(dev, &app_itr);\n\t}\n\n\tif (app->selector == IEEE_8021QAZ_APP_SEL_DSCP)\n\t\terr = sparx5_dcb_ieee_dscp_setdel(dev, app, dcb_ieee_setapp);\n\telse\n\t\terr = dcb_ieee_setapp(dev, app);\n\n\tif (err)\n\t\tgoto out;\n\n\tsparx5_dcb_app_update(dev);\n\nout:\n\treturn err;\n}\n\nstatic int sparx5_dcb_setapptrust(struct net_device *dev, u8 *selectors,\n\t\t\t\t  int nselectors)\n{\n\tstruct sparx5_port *port = netdev_priv(dev);\n\tint err = 0, idx;\n\n\tidx = sparx5_dcb_apptrust_validate(dev, selectors, nselectors, &err);\n\tif (err < 0)\n\t\treturn err;\n\n\tsparx5_port_apptrust[port->portno] = &sparx5_dcb_apptrust_policies[idx];\n\n\treturn sparx5_dcb_app_update(dev);\n}\n\nstatic int sparx5_dcb_getapptrust(struct net_device *dev, u8 *selectors,\n\t\t\t\t  int *nselectors)\n{\n\tstruct sparx5_port *port = netdev_priv(dev);\n\tconst struct sparx5_dcb_apptrust *trust;\n\n\ttrust = sparx5_port_apptrust[port->portno];\n\n\tmemcpy(selectors, trust->selectors, trust->nselectors);\n\t*nselectors = trust->nselectors;\n\n\treturn 0;\n}\n\nstatic int sparx5_dcb_delrewr(struct net_device *dev, struct dcb_app *app)\n{\n\tint err;\n\n\tif (app->selector == IEEE_8021QAZ_APP_SEL_DSCP)\n\t\terr = sparx5_dcb_ieee_dscp_setdel(dev, app, dcb_delrewr);\n\telse\n\t\terr = dcb_delrewr(dev, app);\n\n\tif (err < 0)\n\t\treturn err;\n\n\treturn sparx5_dcb_app_update(dev);\n}\n\nstatic int sparx5_dcb_setrewr(struct net_device *dev, struct dcb_app *app)\n{\n\tstruct dcb_app app_itr;\n\tint err = 0;\n\tu16 proto;\n\n\terr = sparx5_dcb_app_validate(dev, app);\n\tif (err)\n\t\tgoto out;\n\n\t \n\tproto = dcb_getrewr(dev, app);\n\tif (proto) {\n\t\tapp_itr = *app;\n\t\tapp_itr.protocol = proto;\n\t\tsparx5_dcb_delrewr(dev, &app_itr);\n\t}\n\n\tif (app->selector == IEEE_8021QAZ_APP_SEL_DSCP)\n\t\terr = sparx5_dcb_ieee_dscp_setdel(dev, app, dcb_setrewr);\n\telse\n\t\terr = dcb_setrewr(dev, app);\n\n\tif (err)\n\t\tgoto out;\n\n\tsparx5_dcb_app_update(dev);\n\nout:\n\treturn err;\n}\n\nconst struct dcbnl_rtnl_ops sparx5_dcbnl_ops = {\n\t.ieee_setapp = sparx5_dcb_ieee_setapp,\n\t.ieee_delapp = sparx5_dcb_ieee_delapp,\n\t.dcbnl_setapptrust = sparx5_dcb_setapptrust,\n\t.dcbnl_getapptrust = sparx5_dcb_getapptrust,\n\t.dcbnl_setrewr = sparx5_dcb_setrewr,\n\t.dcbnl_delrewr = sparx5_dcb_delrewr,\n};\n\nint sparx5_dcb_init(struct sparx5 *sparx5)\n{\n\tstruct sparx5_port *port;\n\tint i;\n\n\tfor (i = 0; i < SPX5_PORTS; i++) {\n\t\tport = sparx5->ports[i];\n\t\tif (!port)\n\t\t\tcontinue;\n\t\tport->ndev->dcbnl_ops = &sparx5_dcbnl_ops;\n\t\t \n\t\tsparx5_port_apptrust[port->portno] =\n\t\t\t&sparx5_dcb_apptrust_policies\n\t\t\t\t[SPARX5_DCB_APPTRUST_DSCP_PCP];\n\n\t\t \n\t\tsparx5_port_qos_dscp_rewr_mode_set(port,\n\t\t\t\t\t\t   SPARX5_PORT_REW_DSCP_ALL);\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}