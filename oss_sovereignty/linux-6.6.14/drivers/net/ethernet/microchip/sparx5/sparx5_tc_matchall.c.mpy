{
  "module_name": "sparx5_tc_matchall.c",
  "hash_id": "a960ff0d0b5c0b9223370351cc2c3c23b1b02677031c717bb3d494a3e9a66852",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/microchip/sparx5/sparx5_tc_matchall.c",
  "human_readable_source": "\n \n\n#include \"sparx5_tc.h\"\n#include \"vcap_api.h\"\n#include \"vcap_api_client.h\"\n#include \"sparx5_main_regs.h\"\n#include \"sparx5_main.h\"\n#include \"sparx5_vcap_impl.h\"\n\nstatic int sparx5_tc_matchall_replace(struct net_device *ndev,\n\t\t\t\t      struct tc_cls_matchall_offload *tmo,\n\t\t\t\t      bool ingress)\n{\n\tstruct sparx5_port *port = netdev_priv(ndev);\n\tstruct flow_action_entry *action;\n\tstruct sparx5 *sparx5;\n\tint err;\n\n\tif (!flow_offload_has_one_action(&tmo->rule->action)) {\n\t\tNL_SET_ERR_MSG_MOD(tmo->common.extack,\n\t\t\t\t   \"Only one action per filter is supported\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\taction = &tmo->rule->action.entries[0];\n\n\tsparx5 = port->sparx5;\n\tswitch (action->id) {\n\tcase FLOW_ACTION_GOTO:\n\t\terr = vcap_enable_lookups(sparx5->vcap_ctrl, ndev,\n\t\t\t\t\t  tmo->common.chain_index,\n\t\t\t\t\t  action->chain_index, tmo->cookie,\n\t\t\t\t\t  true);\n\t\tif (err == -EFAULT) {\n\t\t\tNL_SET_ERR_MSG_MOD(tmo->common.extack,\n\t\t\t\t\t   \"Unsupported goto chain\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tif (err == -EADDRINUSE) {\n\t\t\tNL_SET_ERR_MSG_MOD(tmo->common.extack,\n\t\t\t\t\t   \"VCAP already enabled\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tif (err == -EADDRNOTAVAIL) {\n\t\t\tNL_SET_ERR_MSG_MOD(tmo->common.extack,\n\t\t\t\t\t   \"Already matching this chain\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tif (err) {\n\t\t\tNL_SET_ERR_MSG_MOD(tmo->common.extack,\n\t\t\t\t\t   \"Could not enable VCAP lookups\");\n\t\t\treturn err;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tNL_SET_ERR_MSG_MOD(tmo->common.extack, \"Unsupported action\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn 0;\n}\n\nstatic int sparx5_tc_matchall_destroy(struct net_device *ndev,\n\t\t\t\t      struct tc_cls_matchall_offload *tmo,\n\t\t\t\t      bool ingress)\n{\n\tstruct sparx5_port *port = netdev_priv(ndev);\n\tstruct sparx5 *sparx5;\n\tint err;\n\n\tsparx5 = port->sparx5;\n\tif (!tmo->rule && tmo->cookie) {\n\t\terr = vcap_enable_lookups(sparx5->vcap_ctrl, ndev,\n\t\t\t\t\t  0, 0, tmo->cookie, false);\n\t\tif (err)\n\t\t\treturn err;\n\t\treturn 0;\n\t}\n\tNL_SET_ERR_MSG_MOD(tmo->common.extack, \"Unsupported action\");\n\treturn -EOPNOTSUPP;\n}\n\nint sparx5_tc_matchall(struct net_device *ndev,\n\t\t       struct tc_cls_matchall_offload *tmo,\n\t\t       bool ingress)\n{\n\tswitch (tmo->command) {\n\tcase TC_CLSMATCHALL_REPLACE:\n\t\treturn sparx5_tc_matchall_replace(ndev, tmo, ingress);\n\tcase TC_CLSMATCHALL_DESTROY:\n\t\treturn sparx5_tc_matchall_destroy(ndev, tmo, ingress);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}