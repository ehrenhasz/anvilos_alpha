{
  "module_name": "sparx5_tc_flower.c",
  "hash_id": "0b79325124dfa895e17fd44498274f41da11563b6ff70e80ea39706da2d47200",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/microchip/sparx5/sparx5_tc_flower.c",
  "human_readable_source": "\n \n\n#include <net/tc_act/tc_gate.h>\n#include <net/tcp.h>\n\n#include \"sparx5_tc.h\"\n#include \"vcap_api.h\"\n#include \"vcap_api_client.h\"\n#include \"vcap_tc.h\"\n#include \"sparx5_main.h\"\n#include \"sparx5_vcap_impl.h\"\n\n#define SPX5_MAX_RULE_SIZE 13  \n\n \nstruct sparx5_wildcard_rule {\n\tbool selected;\n\tu8 value;\n\tu8 mask;\n\tenum vcap_keyfield_set keyset;\n};\n\nstruct sparx5_multiple_rules {\n\tstruct sparx5_wildcard_rule rule[SPX5_MAX_RULE_SIZE];\n};\n\nstruct sparx5_tc_flower_template {\n\tstruct list_head list;  \n\tint cid;  \n\tenum vcap_keyfield_set orig;  \n\tenum vcap_keyfield_set keyset;  \n\tu16 l3_proto;  \n};\n\nstatic int\nsparx5_tc_flower_es0_tpid(struct vcap_tc_flower_parse_usage *st)\n{\n\tint err = 0;\n\n\tswitch (st->tpid) {\n\tcase ETH_P_8021Q:\n\t\terr = vcap_rule_add_key_u32(st->vrule,\n\t\t\t\t\t    VCAP_KF_8021Q_TPID,\n\t\t\t\t\t    SPX5_TPID_SEL_8100, ~0);\n\t\tbreak;\n\tcase ETH_P_8021AD:\n\t\terr = vcap_rule_add_key_u32(st->vrule,\n\t\t\t\t\t    VCAP_KF_8021Q_TPID,\n\t\t\t\t\t    SPX5_TPID_SEL_88A8, ~0);\n\t\tbreak;\n\tdefault:\n\t\tNL_SET_ERR_MSG_MOD(st->fco->common.extack,\n\t\t\t\t   \"Invalid vlan proto\");\n\t\terr = -EINVAL;\n\t\tbreak;\n\t}\n\treturn err;\n}\n\nstatic int\nsparx5_tc_flower_handler_basic_usage(struct vcap_tc_flower_parse_usage *st)\n{\n\tstruct flow_match_basic mt;\n\tint err = 0;\n\n\tflow_rule_match_basic(st->frule, &mt);\n\n\tif (mt.mask->n_proto) {\n\t\tst->l3_proto = be16_to_cpu(mt.key->n_proto);\n\t\tif (!sparx5_vcap_is_known_etype(st->admin, st->l3_proto)) {\n\t\t\terr = vcap_rule_add_key_u32(st->vrule, VCAP_KF_ETYPE,\n\t\t\t\t\t\t    st->l3_proto, ~0);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t} else if (st->l3_proto == ETH_P_IP) {\n\t\t\terr = vcap_rule_add_key_bit(st->vrule, VCAP_KF_IP4_IS,\n\t\t\t\t\t\t    VCAP_BIT_1);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t} else if (st->l3_proto == ETH_P_IPV6) {\n\t\t\terr = vcap_rule_add_key_bit(st->vrule, VCAP_KF_IP4_IS,\n\t\t\t\t\t\t    VCAP_BIT_0);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t\tif (st->admin->vtype == VCAP_TYPE_IS0) {\n\t\t\t\terr = vcap_rule_add_key_bit(st->vrule,\n\t\t\t\t\t\t\t    VCAP_KF_IP_SNAP_IS,\n\t\t\t\t\t\t\t    VCAP_BIT_1);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (mt.mask->ip_proto) {\n\t\tst->l4_proto = mt.key->ip_proto;\n\t\tif (st->l4_proto == IPPROTO_TCP) {\n\t\t\terr = vcap_rule_add_key_bit(st->vrule,\n\t\t\t\t\t\t    VCAP_KF_TCP_IS,\n\t\t\t\t\t\t    VCAP_BIT_1);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t} else if (st->l4_proto == IPPROTO_UDP) {\n\t\t\terr = vcap_rule_add_key_bit(st->vrule,\n\t\t\t\t\t\t    VCAP_KF_TCP_IS,\n\t\t\t\t\t\t    VCAP_BIT_0);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t\tif (st->admin->vtype == VCAP_TYPE_IS0) {\n\t\t\t\terr = vcap_rule_add_key_bit(st->vrule,\n\t\t\t\t\t\t\t    VCAP_KF_TCP_UDP_IS,\n\t\t\t\t\t\t\t    VCAP_BIT_1);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else {\n\t\t\terr = vcap_rule_add_key_u32(st->vrule,\n\t\t\t\t\t\t    VCAP_KF_L3_IP_PROTO,\n\t\t\t\t\t\t    st->l4_proto, ~0);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\n\tst->used_keys |= BIT_ULL(FLOW_DISSECTOR_KEY_BASIC);\n\n\treturn err;\n\nout:\n\tNL_SET_ERR_MSG_MOD(st->fco->common.extack, \"ip_proto parse error\");\n\treturn err;\n}\n\nstatic int\nsparx5_tc_flower_handler_control_usage(struct vcap_tc_flower_parse_usage *st)\n{\n\tstruct flow_match_control mt;\n\tu32 value, mask;\n\tint err = 0;\n\n\tflow_rule_match_control(st->frule, &mt);\n\n\tif (mt.mask->flags) {\n\t\tif (mt.mask->flags & FLOW_DIS_FIRST_FRAG) {\n\t\t\tif (mt.key->flags & FLOW_DIS_FIRST_FRAG) {\n\t\t\t\tvalue = 1;  \n\t\t\t\tmask = 0x3;\n\t\t\t} else {\n\t\t\t\tif (mt.mask->flags & FLOW_DIS_IS_FRAGMENT) {\n\t\t\t\t\tvalue = 3;  \n\t\t\t\t\tmask = 0x3;\n\t\t\t\t} else {\n\t\t\t\t\tvalue = 0;  \n\t\t\t\t\tmask = 0x3;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (mt.mask->flags & FLOW_DIS_IS_FRAGMENT) {\n\t\t\t\tvalue = 3;  \n\t\t\t\tmask = 0x3;\n\t\t\t} else {\n\t\t\t\tvalue = 0;  \n\t\t\t\tmask = 0x3;\n\t\t\t}\n\t\t}\n\n\t\terr = vcap_rule_add_key_u32(st->vrule,\n\t\t\t\t\t    VCAP_KF_L3_FRAGMENT_TYPE,\n\t\t\t\t\t    value, mask);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tst->used_keys |= BIT_ULL(FLOW_DISSECTOR_KEY_CONTROL);\n\n\treturn err;\n\nout:\n\tNL_SET_ERR_MSG_MOD(st->fco->common.extack, \"ip_frag parse error\");\n\treturn err;\n}\n\nstatic int\nsparx5_tc_flower_handler_cvlan_usage(struct vcap_tc_flower_parse_usage *st)\n{\n\tif (st->admin->vtype != VCAP_TYPE_IS0) {\n\t\tNL_SET_ERR_MSG_MOD(st->fco->common.extack,\n\t\t\t\t   \"cvlan not supported in this VCAP\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn vcap_tc_flower_handler_cvlan_usage(st);\n}\n\nstatic int\nsparx5_tc_flower_handler_vlan_usage(struct vcap_tc_flower_parse_usage *st)\n{\n\tenum vcap_key_field vid_key = VCAP_KF_8021Q_VID_CLS;\n\tenum vcap_key_field pcp_key = VCAP_KF_8021Q_PCP_CLS;\n\tint err;\n\n\tif (st->admin->vtype == VCAP_TYPE_IS0) {\n\t\tvid_key = VCAP_KF_8021Q_VID0;\n\t\tpcp_key = VCAP_KF_8021Q_PCP0;\n\t}\n\n\terr = vcap_tc_flower_handler_vlan_usage(st, vid_key, pcp_key);\n\tif (err)\n\t\treturn err;\n\n\tif (st->admin->vtype == VCAP_TYPE_ES0 && st->tpid)\n\t\terr = sparx5_tc_flower_es0_tpid(st);\n\n\treturn err;\n}\n\nstatic int (*sparx5_tc_flower_usage_handlers[])(struct vcap_tc_flower_parse_usage *st) = {\n\t[FLOW_DISSECTOR_KEY_ETH_ADDRS] = vcap_tc_flower_handler_ethaddr_usage,\n\t[FLOW_DISSECTOR_KEY_IPV4_ADDRS] = vcap_tc_flower_handler_ipv4_usage,\n\t[FLOW_DISSECTOR_KEY_IPV6_ADDRS] = vcap_tc_flower_handler_ipv6_usage,\n\t[FLOW_DISSECTOR_KEY_CONTROL] = sparx5_tc_flower_handler_control_usage,\n\t[FLOW_DISSECTOR_KEY_PORTS] = vcap_tc_flower_handler_portnum_usage,\n\t[FLOW_DISSECTOR_KEY_BASIC] = sparx5_tc_flower_handler_basic_usage,\n\t[FLOW_DISSECTOR_KEY_CVLAN] = sparx5_tc_flower_handler_cvlan_usage,\n\t[FLOW_DISSECTOR_KEY_VLAN] = sparx5_tc_flower_handler_vlan_usage,\n\t[FLOW_DISSECTOR_KEY_TCP] = vcap_tc_flower_handler_tcp_usage,\n\t[FLOW_DISSECTOR_KEY_ARP] = vcap_tc_flower_handler_arp_usage,\n\t[FLOW_DISSECTOR_KEY_IP] = vcap_tc_flower_handler_ip_usage,\n};\n\nstatic int sparx5_tc_use_dissectors(struct vcap_tc_flower_parse_usage *st,\n\t\t\t\t    struct vcap_admin *admin,\n\t\t\t\t    struct vcap_rule *vrule)\n{\n\tint idx, err = 0;\n\n\tfor (idx = 0; idx < ARRAY_SIZE(sparx5_tc_flower_usage_handlers); ++idx) {\n\t\tif (!flow_rule_match_key(st->frule, idx))\n\t\t\tcontinue;\n\t\tif (!sparx5_tc_flower_usage_handlers[idx])\n\t\t\tcontinue;\n\t\terr = sparx5_tc_flower_usage_handlers[idx](st);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (st->frule->match.dissector->used_keys ^ st->used_keys) {\n\t\tNL_SET_ERR_MSG_MOD(st->fco->common.extack,\n\t\t\t\t   \"Unsupported match item\");\n\t\treturn -ENOENT;\n\t}\n\n\treturn err;\n}\n\nstatic int sparx5_tc_flower_action_check(struct vcap_control *vctrl,\n\t\t\t\t\t struct net_device *ndev,\n\t\t\t\t\t struct flow_cls_offload *fco,\n\t\t\t\t\t bool ingress)\n{\n\tstruct flow_rule *rule = flow_cls_offload_flow_rule(fco);\n\tstruct flow_action_entry *actent, *last_actent = NULL;\n\tstruct flow_action *act = &rule->action;\n\tu64 action_mask = 0;\n\tint idx;\n\n\tif (!flow_action_has_entries(act)) {\n\t\tNL_SET_ERR_MSG_MOD(fco->common.extack, \"No actions\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!flow_action_basic_hw_stats_check(act, fco->common.extack))\n\t\treturn -EOPNOTSUPP;\n\n\tflow_action_for_each(idx, actent, act) {\n\t\tif (action_mask & BIT(actent->id)) {\n\t\t\tNL_SET_ERR_MSG_MOD(fco->common.extack,\n\t\t\t\t\t   \"More actions of the same type\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\taction_mask |= BIT(actent->id);\n\t\tlast_actent = actent;  \n\t}\n\n\t \n\tif (last_actent->id == FLOW_ACTION_GOTO) {\n\t\t \n\t\tif (!vcap_is_next_lookup(vctrl, fco->common.chain_index,\n\t\t\t\t\t last_actent->chain_index)) {\n\t\t\tNL_SET_ERR_MSG_MOD(fco->common.extack,\n\t\t\t\t\t   \"Invalid goto chain\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else if (!vcap_is_last_chain(vctrl, fco->common.chain_index,\n\t\t\t\t       ingress)) {\n\t\tNL_SET_ERR_MSG_MOD(fco->common.extack,\n\t\t\t\t   \"Last action must be 'goto'\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (action_mask & BIT(FLOW_ACTION_TRAP) &&\n\t    action_mask & BIT(FLOW_ACTION_ACCEPT)) {\n\t\tNL_SET_ERR_MSG_MOD(fco->common.extack,\n\t\t\t\t   \"Cannot combine pass and trap action\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (action_mask & BIT(FLOW_ACTION_VLAN_PUSH) &&\n\t    action_mask & BIT(FLOW_ACTION_VLAN_POP)) {\n\t\tNL_SET_ERR_MSG_MOD(fco->common.extack,\n\t\t\t\t   \"Cannot combine vlan push and pop action\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (action_mask & BIT(FLOW_ACTION_VLAN_PUSH) &&\n\t    action_mask & BIT(FLOW_ACTION_VLAN_MANGLE)) {\n\t\tNL_SET_ERR_MSG_MOD(fco->common.extack,\n\t\t\t\t   \"Cannot combine vlan push and modify action\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (action_mask & BIT(FLOW_ACTION_VLAN_POP) &&\n\t    action_mask & BIT(FLOW_ACTION_VLAN_MANGLE)) {\n\t\tNL_SET_ERR_MSG_MOD(fco->common.extack,\n\t\t\t\t   \"Cannot combine vlan pop and modify action\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int sparx5_tc_add_rule_counter(struct vcap_admin *admin,\n\t\t\t\t      struct vcap_rule *vrule)\n{\n\tint err;\n\n\tswitch (admin->vtype) {\n\tcase VCAP_TYPE_IS0:\n\t\tbreak;\n\tcase VCAP_TYPE_ES0:\n\t\terr = vcap_rule_mod_action_u32(vrule, VCAP_AF_ESDX,\n\t\t\t\t\t       vrule->id);\n\t\tif (err)\n\t\t\treturn err;\n\t\tvcap_rule_set_counter_id(vrule, vrule->id);\n\t\tbreak;\n\tcase VCAP_TYPE_IS2:\n\tcase VCAP_TYPE_ES2:\n\t\terr = vcap_rule_mod_action_u32(vrule, VCAP_AF_CNT_ID,\n\t\t\t\t\t       vrule->id);\n\t\tif (err)\n\t\t\treturn err;\n\t\tvcap_rule_set_counter_id(vrule, vrule->id);\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"%s:%d: vcap type: %d not supported\\n\",\n\t\t       __func__, __LINE__, admin->vtype);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\n \nstatic int sparx5_tc_select_protocol_keyset(struct net_device *ndev,\n\t\t\t\t\t    struct vcap_rule *vrule,\n\t\t\t\t\t    struct vcap_admin *admin,\n\t\t\t\t\t    u16 l3_proto,\n\t\t\t\t\t    struct sparx5_multiple_rules *multi)\n{\n\tstruct sparx5_port *port = netdev_priv(ndev);\n\tstruct vcap_keyset_list portkeysetlist = {};\n\tenum vcap_keyfield_set portkeysets[10] = {};\n\tstruct vcap_keyset_list matches = {};\n\tenum vcap_keyfield_set keysets[10];\n\tint idx, jdx, err = 0, count = 0;\n\tstruct sparx5_wildcard_rule *mru;\n\tconst struct vcap_set *kinfo;\n\tstruct vcap_control *vctrl;\n\n\tvctrl = port->sparx5->vcap_ctrl;\n\n\t \n\tmatches.keysets = keysets;\n\tmatches.max = ARRAY_SIZE(keysets);\n\tif (!vcap_rule_find_keysets(vrule, &matches))\n\t\treturn -EINVAL;\n\n\t \n\tportkeysetlist.max = ARRAY_SIZE(portkeysets);\n\tportkeysetlist.keysets = portkeysets;\n\terr = sparx5_vcap_get_port_keyset(ndev,\n\t\t\t\t\t  admin, vrule->vcap_chain_id,\n\t\t\t\t\t  l3_proto,\n\t\t\t\t\t  &portkeysetlist);\n\tif (err)\n\t\treturn err;\n\n\t \n\tfor (idx = 0; idx < portkeysetlist.cnt; ++idx) {\n\t\tkinfo = vcap_keyfieldset(vctrl, admin->vtype,\n\t\t\t\t\t portkeysetlist.keysets[idx]);\n\t\tif (!kinfo)\n\t\t\tcontinue;\n\n\t\t \n\t\tfor (jdx = 0; jdx < matches.cnt; ++jdx) {\n\t\t\tif (portkeysetlist.keysets[idx] != matches.keysets[jdx])\n\t\t\t\tcontinue;\n\n\t\t\tmru = &multi->rule[kinfo->sw_per_item];\n\t\t\tif (!mru->selected) {\n\t\t\t\tmru->selected = true;\n\t\t\t\tmru->keyset = portkeysetlist.keysets[idx];\n\t\t\t\tmru->value = kinfo->type_id;\n\t\t\t}\n\t\t\tmru->value &= kinfo->type_id;\n\t\t\tmru->mask |= kinfo->type_id;\n\t\t\t++count;\n\t\t}\n\t}\n\tif (count == 0)\n\t\treturn -EPROTO;\n\n\tif (l3_proto == ETH_P_ALL && count < portkeysetlist.cnt)\n\t\treturn -ENOENT;\n\n\tfor (idx = 0; idx < SPX5_MAX_RULE_SIZE; ++idx) {\n\t\tmru = &multi->rule[idx];\n\t\tif (!mru->selected)\n\t\t\tcontinue;\n\n\t\t \n\t\tmru->mask ^= mru->value;\n\t}\n\n\t \n\tfor (idx = 0; idx < SPX5_MAX_RULE_SIZE; ++idx) {\n\t\tmru = &multi->rule[idx];\n\t\tif (!mru->selected)\n\t\t\tcontinue;\n\n\t\tvcap_set_rule_set_keyset(vrule, mru->keyset);\n\t\tif (count > 1)\n\t\t\t \n\t\t\tvcap_rule_mod_key_u32(vrule, VCAP_KF_TYPE,\n\t\t\t\t\t      mru->value,\n\t\t\t\t\t      ~mru->mask);\n\t\tmru->selected = false;  \n\t\tbreak;  \n\t}\n\treturn err;\n}\n\nstatic int sparx5_tc_add_rule_copy(struct vcap_control *vctrl,\n\t\t\t\t   struct flow_cls_offload *fco,\n\t\t\t\t   struct vcap_rule *erule,\n\t\t\t\t   struct vcap_admin *admin,\n\t\t\t\t   struct sparx5_wildcard_rule *rule)\n{\n\tenum vcap_key_field keylist[] = {\n\t\tVCAP_KF_IF_IGR_PORT_MASK,\n\t\tVCAP_KF_IF_IGR_PORT_MASK_SEL,\n\t\tVCAP_KF_IF_IGR_PORT_MASK_RNG,\n\t\tVCAP_KF_LOOKUP_FIRST_IS,\n\t\tVCAP_KF_TYPE,\n\t};\n\tstruct vcap_rule *vrule;\n\tint err;\n\n\t \n\terule->user = VCAP_USER_TC_EXTRA;\n\tvrule = vcap_copy_rule(erule);\n\tif (IS_ERR(vrule))\n\t\treturn PTR_ERR(vrule);\n\n\t \n\tvrule->cookie = erule->cookie;\n\tvcap_filter_rule_keys(vrule, keylist, ARRAY_SIZE(keylist), true);\n\terr = vcap_set_rule_set_keyset(vrule, rule->keyset);\n\tif (err) {\n\t\tpr_err(\"%s:%d: could not set keyset %s in rule: %u\\n\",\n\t\t       __func__, __LINE__,\n\t\t       vcap_keyset_name(vctrl, rule->keyset),\n\t\t       vrule->id);\n\t\tgoto out;\n\t}\n\n\t \n\tvcap_rule_mod_key_u32(vrule, VCAP_KF_TYPE, rule->value, ~rule->mask);\n\n\terr = vcap_set_rule_set_actionset(vrule, erule->actionset);\n\tif (err)\n\t\tgoto out;\n\n\terr = sparx5_tc_add_rule_counter(admin, vrule);\n\tif (err)\n\t\tgoto out;\n\n\terr = vcap_val_rule(vrule, ETH_P_ALL);\n\tif (err) {\n\t\tpr_err(\"%s:%d: could not validate rule: %u\\n\",\n\t\t       __func__, __LINE__, vrule->id);\n\t\tvcap_set_tc_exterr(fco, vrule);\n\t\tgoto out;\n\t}\n\terr = vcap_add_rule(vrule);\n\tif (err) {\n\t\tpr_err(\"%s:%d: could not add rule: %u\\n\",\n\t\t       __func__, __LINE__, vrule->id);\n\t\tgoto out;\n\t}\nout:\n\tvcap_free_rule(vrule);\n\treturn err;\n}\n\nstatic int sparx5_tc_add_remaining_rules(struct vcap_control *vctrl,\n\t\t\t\t\t struct flow_cls_offload *fco,\n\t\t\t\t\t struct vcap_rule *erule,\n\t\t\t\t\t struct vcap_admin *admin,\n\t\t\t\t\t struct sparx5_multiple_rules *multi)\n{\n\tint idx, err = 0;\n\n\tfor (idx = 0; idx < SPX5_MAX_RULE_SIZE; ++idx) {\n\t\tif (!multi->rule[idx].selected)\n\t\t\tcontinue;\n\n\t\terr = sparx5_tc_add_rule_copy(vctrl, fco, erule, admin,\n\t\t\t\t\t      &multi->rule[idx]);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\treturn err;\n}\n\n \nstatic int sparx5_tc_set_actionset(struct vcap_admin *admin,\n\t\t\t\t   struct vcap_rule *vrule)\n{\n\tenum vcap_actionfield_set aset;\n\tint err = 0;\n\n\tswitch (admin->vtype) {\n\tcase VCAP_TYPE_IS0:\n\t\taset = VCAP_AFS_CLASSIFICATION;\n\t\tbreak;\n\tcase VCAP_TYPE_IS2:\n\t\taset = VCAP_AFS_BASE_TYPE;\n\t\tbreak;\n\tcase VCAP_TYPE_ES0:\n\t\taset = VCAP_AFS_ES0;\n\t\tbreak;\n\tcase VCAP_TYPE_ES2:\n\t\taset = VCAP_AFS_BASE_TYPE;\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"%s:%d: %s\\n\", __func__, __LINE__, \"Invalid VCAP type\");\n\t\treturn -EINVAL;\n\t}\n\t \n\tif (vrule->actionset == VCAP_AFS_NO_VALUE)\n\t\terr = vcap_set_rule_set_actionset(vrule, aset);\n\treturn err;\n}\n\n \nstatic int sparx5_tc_add_rule_link_target(struct vcap_admin *admin,\n\t\t\t\t\t  struct vcap_rule *vrule,\n\t\t\t\t\t  int target_cid)\n{\n\tint link_val = target_cid % VCAP_CID_LOOKUP_SIZE;\n\tint err;\n\n\tif (!link_val)\n\t\treturn 0;\n\n\tswitch (admin->vtype) {\n\tcase VCAP_TYPE_IS0:\n\t\t \n\t\terr = vcap_rule_add_key_u32(vrule, VCAP_KF_LOOKUP_GEN_IDX_SEL,\n\t\t\t\t\t    1,  \n\t\t\t\t\t    ~0);\n\t\tif (err)\n\t\t\treturn err;\n\t\treturn vcap_rule_add_key_u32(vrule, VCAP_KF_LOOKUP_GEN_IDX,\n\t\t\t\t\t     link_val,  \n\t\t\t\t\t     ~0);\n\tcase VCAP_TYPE_IS2:\n\t\t \n\t\treturn vcap_rule_add_key_u32(vrule, VCAP_KF_LOOKUP_PAG,\n\t\t\t\t\t     link_val,  \n\t\t\t\t\t     ~0);\n\tcase VCAP_TYPE_ES0:\n\tcase VCAP_TYPE_ES2:\n\t\t \n\t\treturn vcap_rule_add_key_u32(vrule, VCAP_KF_ISDX_CLS, link_val,\n\t\t\t\t\t     ~0);\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\n \nstatic int sparx5_tc_add_rule_link(struct vcap_control *vctrl,\n\t\t\t\t   struct vcap_admin *admin,\n\t\t\t\t   struct vcap_rule *vrule,\n\t\t\t\t   int from_cid, int to_cid)\n{\n\tstruct vcap_admin *to_admin = vcap_find_admin(vctrl, to_cid);\n\tint diff, err = 0;\n\n\tif (!to_admin) {\n\t\tpr_err(\"%s:%d: unsupported chain direction: %d\\n\",\n\t\t       __func__, __LINE__, to_cid);\n\t\treturn -EINVAL;\n\t}\n\n\tdiff = vcap_chain_offset(vctrl, from_cid, to_cid);\n\tif (!diff)\n\t\treturn 0;\n\n\tif (admin->vtype == VCAP_TYPE_IS0 &&\n\t    to_admin->vtype == VCAP_TYPE_IS0) {\n\t\t \n\t\terr = vcap_rule_add_action_u32(vrule, VCAP_AF_NXT_IDX, diff);\n\t\tif (err)\n\t\t\tgoto out;\n\t\terr = vcap_rule_add_action_u32(vrule, VCAP_AF_NXT_IDX_CTRL,\n\t\t\t\t\t       1);  \n\t\tif (err)\n\t\t\tgoto out;\n\t} else if (admin->vtype == VCAP_TYPE_IS0 &&\n\t\t   to_admin->vtype == VCAP_TYPE_IS2) {\n\t\t \n\t\terr = vcap_rule_add_action_u32(vrule, VCAP_AF_PAG_VAL, diff);\n\t\tif (err)\n\t\t\tgoto out;\n\t\terr = vcap_rule_add_action_u32(vrule,\n\t\t\t\t\t       VCAP_AF_PAG_OVERRIDE_MASK,\n\t\t\t\t\t       0xff);\n\t\tif (err)\n\t\t\tgoto out;\n\t} else if (admin->vtype == VCAP_TYPE_IS0 &&\n\t\t   (to_admin->vtype == VCAP_TYPE_ES0 ||\n\t\t    to_admin->vtype == VCAP_TYPE_ES2)) {\n\t\t \n\t\terr = vcap_rule_add_action_u32(vrule, VCAP_AF_ISDX_VAL,\n\t\t\t\t\t       diff);\n\t\tif (err)\n\t\t\tgoto out;\n\t\terr = vcap_rule_add_action_bit(vrule,\n\t\t\t\t\t       VCAP_AF_ISDX_ADD_REPLACE_SEL,\n\t\t\t\t\t       VCAP_BIT_1);\n\t\tif (err)\n\t\t\tgoto out;\n\t} else {\n\t\tpr_err(\"%s:%d: unsupported chain destination: %d\\n\",\n\t\t       __func__, __LINE__, to_cid);\n\t\terr = -EOPNOTSUPP;\n\t}\nout:\n\treturn err;\n}\n\nstatic int sparx5_tc_flower_parse_act_gate(struct sparx5_psfp_sg *sg,\n\t\t\t\t\t   struct flow_action_entry *act,\n\t\t\t\t\t   struct netlink_ext_ack *extack)\n{\n\tint i;\n\n\tif (act->gate.prio < -1 || act->gate.prio > SPX5_PSFP_SG_MAX_IPV) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Invalid gate priority\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (act->gate.cycletime < SPX5_PSFP_SG_MIN_CYCLE_TIME_NS ||\n\t    act->gate.cycletime > SPX5_PSFP_SG_MAX_CYCLE_TIME_NS) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Invalid gate cycletime\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (act->gate.cycletimeext > SPX5_PSFP_SG_MAX_CYCLE_TIME_NS) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Invalid gate cycletimeext\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (act->gate.num_entries >= SPX5_PSFP_GCE_CNT) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Invalid number of gate entries\");\n\t\treturn -EINVAL;\n\t}\n\n\tsg->gate_state = true;\n\tsg->ipv = act->gate.prio;\n\tsg->num_entries = act->gate.num_entries;\n\tsg->cycletime = act->gate.cycletime;\n\tsg->cycletimeext = act->gate.cycletimeext;\n\n\tfor (i = 0; i < sg->num_entries; i++) {\n\t\tsg->gce[i].gate_state = !!act->gate.entries[i].gate_state;\n\t\tsg->gce[i].interval = act->gate.entries[i].interval;\n\t\tsg->gce[i].ipv = act->gate.entries[i].ipv;\n\t\tsg->gce[i].maxoctets = act->gate.entries[i].maxoctets;\n\t}\n\n\treturn 0;\n}\n\nstatic int sparx5_tc_flower_parse_act_police(struct sparx5_policer *pol,\n\t\t\t\t\t     struct flow_action_entry *act,\n\t\t\t\t\t     struct netlink_ext_ack *extack)\n{\n\tpol->type = SPX5_POL_SERVICE;\n\tpol->rate = div_u64(act->police.rate_bytes_ps, 1000) * 8;\n\tpol->burst = act->police.burst;\n\tpol->idx = act->hw_index;\n\n\t \n\tif (pol->rate > DIV_ROUND_UP(SPX5_SDLB_GROUP_RATE_MAX, 1000)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Maximum rate exceeded\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (act->police.exceed.act_id != FLOW_ACTION_DROP) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Offload not supported when exceed action is not drop\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (act->police.notexceed.act_id != FLOW_ACTION_PIPE &&\n\t    act->police.notexceed.act_id != FLOW_ACTION_ACCEPT) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Offload not supported when conform action is not pipe or ok\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic int sparx5_tc_flower_psfp_setup(struct sparx5 *sparx5,\n\t\t\t\t       struct vcap_rule *vrule, int sg_idx,\n\t\t\t\t       int pol_idx, struct sparx5_psfp_sg *sg,\n\t\t\t\t       struct sparx5_psfp_fm *fm,\n\t\t\t\t       struct sparx5_psfp_sf *sf)\n{\n\tu32 psfp_sfid = 0, psfp_fmid = 0, psfp_sgid = 0;\n\tint ret;\n\n\t \n\tif (sg_idx < 0) {\n\t\tsg_idx = sparx5_pool_idx_to_id(SPX5_PSFP_SG_OPEN);\n\t\tsg->ipv = 0;  \n\t\tsg->cycletime = SPX5_PSFP_SG_CYCLE_TIME_DEFAULT;\n\t\tsg->num_entries = 1;\n\t\tsg->gate_state = 1;  \n\t\tsg->gate_enabled = 1;\n\t\tsg->gce[0].gate_state = 1;\n\t\tsg->gce[0].interval = SPX5_PSFP_SG_CYCLE_TIME_DEFAULT;\n\t\tsg->gce[0].ipv = 0;\n\t\tsg->gce[0].maxoctets = 0;  \n\t}\n\n\tret = sparx5_psfp_sg_add(sparx5, sg_idx, sg, &psfp_sgid);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (pol_idx >= 0) {\n\t\t \n\t\tret = sparx5_psfp_fm_add(sparx5, pol_idx, fm, &psfp_fmid);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\t \n\tsf->sgid = psfp_sgid;\n\n\t \n\tret = sparx5_psfp_sf_add(sparx5, sf, &psfp_sfid);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tsparx5_isdx_conf_set(sparx5, psfp_sfid, psfp_sfid, psfp_fmid);\n\n\tret = vcap_rule_add_action_bit(vrule, VCAP_AF_ISDX_ADD_REPLACE_SEL,\n\t\t\t\t       VCAP_BIT_1);\n\tif (ret)\n\t\treturn ret;\n\n\tret = vcap_rule_add_action_u32(vrule, VCAP_AF_ISDX_VAL, psfp_sfid);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\n \nstatic int sparx5_tc_action_trap(struct vcap_admin *admin,\n\t\t\t\t struct vcap_rule *vrule,\n\t\t\t\t struct flow_cls_offload *fco)\n{\n\tint err = 0;\n\n\tswitch (admin->vtype) {\n\tcase VCAP_TYPE_IS2:\n\t\terr = vcap_rule_add_action_bit(vrule,\n\t\t\t\t\t       VCAP_AF_CPU_COPY_ENA,\n\t\t\t\t\t       VCAP_BIT_1);\n\t\tif (err)\n\t\t\tbreak;\n\t\terr = vcap_rule_add_action_u32(vrule,\n\t\t\t\t\t       VCAP_AF_CPU_QUEUE_NUM, 0);\n\t\tif (err)\n\t\t\tbreak;\n\t\terr = vcap_rule_add_action_u32(vrule,\n\t\t\t\t\t       VCAP_AF_MASK_MODE,\n\t\t\t\t\t       SPX5_PMM_REPLACE_ALL);\n\t\tbreak;\n\tcase VCAP_TYPE_ES0:\n\t\terr = vcap_rule_add_action_u32(vrule,\n\t\t\t\t\t       VCAP_AF_FWD_SEL,\n\t\t\t\t\t       SPX5_FWSEL_REDIRECT_TO_LOOPBACK);\n\t\tbreak;\n\tcase VCAP_TYPE_ES2:\n\t\terr = vcap_rule_add_action_bit(vrule,\n\t\t\t\t\t       VCAP_AF_CPU_COPY_ENA,\n\t\t\t\t\t       VCAP_BIT_1);\n\t\tif (err)\n\t\t\tbreak;\n\t\terr = vcap_rule_add_action_u32(vrule,\n\t\t\t\t\t       VCAP_AF_CPU_QUEUE_NUM, 0);\n\t\tbreak;\n\tdefault:\n\t\tNL_SET_ERR_MSG_MOD(fco->common.extack,\n\t\t\t\t   \"Trap action not supported in this VCAP\");\n\t\terr = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\treturn err;\n}\n\nstatic int sparx5_tc_action_vlan_pop(struct vcap_admin *admin,\n\t\t\t\t     struct vcap_rule *vrule,\n\t\t\t\t     struct flow_cls_offload *fco,\n\t\t\t\t     u16 tpid)\n{\n\tint err = 0;\n\n\tswitch (admin->vtype) {\n\tcase VCAP_TYPE_ES0:\n\t\tbreak;\n\tdefault:\n\t\tNL_SET_ERR_MSG_MOD(fco->common.extack,\n\t\t\t\t   \"VLAN pop action not supported in this VCAP\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tswitch (tpid) {\n\tcase ETH_P_8021Q:\n\tcase ETH_P_8021AD:\n\t\terr = vcap_rule_add_action_u32(vrule,\n\t\t\t\t\t       VCAP_AF_PUSH_OUTER_TAG,\n\t\t\t\t\t       SPX5_OTAG_UNTAG);\n\t\tbreak;\n\tdefault:\n\t\tNL_SET_ERR_MSG_MOD(fco->common.extack,\n\t\t\t\t   \"Invalid vlan proto\");\n\t\terr = -EINVAL;\n\t}\n\treturn err;\n}\n\nstatic int sparx5_tc_action_vlan_modify(struct vcap_admin *admin,\n\t\t\t\t\tstruct vcap_rule *vrule,\n\t\t\t\t\tstruct flow_cls_offload *fco,\n\t\t\t\t\tstruct flow_action_entry *act,\n\t\t\t\t\tu16 tpid)\n{\n\tint err = 0;\n\n\tswitch (admin->vtype) {\n\tcase VCAP_TYPE_ES0:\n\t\terr = vcap_rule_add_action_u32(vrule,\n\t\t\t\t\t       VCAP_AF_PUSH_OUTER_TAG,\n\t\t\t\t\t       SPX5_OTAG_TAG_A);\n\t\tif (err)\n\t\t\treturn err;\n\t\tbreak;\n\tdefault:\n\t\tNL_SET_ERR_MSG_MOD(fco->common.extack,\n\t\t\t\t   \"VLAN modify action not supported in this VCAP\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tswitch (tpid) {\n\tcase ETH_P_8021Q:\n\t\terr = vcap_rule_add_action_u32(vrule,\n\t\t\t\t\t       VCAP_AF_TAG_A_TPID_SEL,\n\t\t\t\t\t       SPX5_TPID_A_8100);\n\t\tbreak;\n\tcase ETH_P_8021AD:\n\t\terr = vcap_rule_add_action_u32(vrule,\n\t\t\t\t\t       VCAP_AF_TAG_A_TPID_SEL,\n\t\t\t\t\t       SPX5_TPID_A_88A8);\n\t\tbreak;\n\tdefault:\n\t\tNL_SET_ERR_MSG_MOD(fco->common.extack,\n\t\t\t\t   \"Invalid vlan proto\");\n\t\terr = -EINVAL;\n\t}\n\tif (err)\n\t\treturn err;\n\n\terr = vcap_rule_add_action_u32(vrule,\n\t\t\t\t       VCAP_AF_TAG_A_VID_SEL,\n\t\t\t\t       SPX5_VID_A_VAL);\n\tif (err)\n\t\treturn err;\n\n\terr = vcap_rule_add_action_u32(vrule,\n\t\t\t\t       VCAP_AF_VID_A_VAL,\n\t\t\t\t       act->vlan.vid);\n\tif (err)\n\t\treturn err;\n\n\terr = vcap_rule_add_action_u32(vrule,\n\t\t\t\t       VCAP_AF_TAG_A_PCP_SEL,\n\t\t\t\t       SPX5_PCP_A_VAL);\n\tif (err)\n\t\treturn err;\n\n\terr = vcap_rule_add_action_u32(vrule,\n\t\t\t\t       VCAP_AF_PCP_A_VAL,\n\t\t\t\t       act->vlan.prio);\n\tif (err)\n\t\treturn err;\n\n\treturn vcap_rule_add_action_u32(vrule,\n\t\t\t\t\tVCAP_AF_TAG_A_DEI_SEL,\n\t\t\t\t\tSPX5_DEI_A_CLASSIFIED);\n}\n\nstatic int sparx5_tc_action_vlan_push(struct vcap_admin *admin,\n\t\t\t\t      struct vcap_rule *vrule,\n\t\t\t\t      struct flow_cls_offload *fco,\n\t\t\t\t      struct flow_action_entry *act,\n\t\t\t\t      u16 tpid)\n{\n\tu16 act_tpid = be16_to_cpu(act->vlan.proto);\n\tint err = 0;\n\n\tswitch (admin->vtype) {\n\tcase VCAP_TYPE_ES0:\n\t\tbreak;\n\tdefault:\n\t\tNL_SET_ERR_MSG_MOD(fco->common.extack,\n\t\t\t\t   \"VLAN push action not supported in this VCAP\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (tpid == ETH_P_8021AD) {\n\t\tNL_SET_ERR_MSG_MOD(fco->common.extack,\n\t\t\t\t   \"Cannot push on double tagged frames\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\terr = sparx5_tc_action_vlan_modify(admin, vrule, fco, act, act_tpid);\n\tif (err)\n\t\treturn err;\n\n\tswitch (act_tpid) {\n\tcase ETH_P_8021Q:\n\t\tbreak;\n\tcase ETH_P_8021AD:\n\t\t \n\t\terr = vcap_rule_add_action_u32(vrule,\n\t\t\t\t\t       VCAP_AF_PUSH_INNER_TAG,\n\t\t\t\t\t       SPX5_ITAG_PUSH_B_TAG);\n\t\tif (err)\n\t\t\tbreak;\n\t\terr = vcap_rule_add_action_u32(vrule,\n\t\t\t\t\t       VCAP_AF_TAG_B_TPID_SEL,\n\t\t\t\t\t       SPX5_TPID_B_CLASSIFIED);\n\t\tbreak;\n\tdefault:\n\t\tNL_SET_ERR_MSG_MOD(fco->common.extack,\n\t\t\t\t   \"Invalid vlan proto\");\n\t\terr = -EINVAL;\n\t}\n\treturn err;\n}\n\n \nstatic void sparx5_tc_flower_simplify_rule(struct vcap_admin *admin,\n\t\t\t\t\t   struct vcap_rule *vrule,\n\t\t\t\t\t   u16 l3_proto)\n{\n\tswitch (admin->vtype) {\n\tcase VCAP_TYPE_IS0:\n\t\tvcap_rule_rem_key(vrule, VCAP_KF_ETYPE);\n\t\tswitch (l3_proto) {\n\t\tcase ETH_P_IP:\n\t\t\tbreak;\n\t\tcase ETH_P_IPV6:\n\t\t\tvcap_rule_rem_key(vrule, VCAP_KF_IP_SNAP_IS);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase VCAP_TYPE_ES2:\n\t\tswitch (l3_proto) {\n\t\tcase ETH_P_IP:\n\t\t\tif (vrule->keyset == VCAP_KFS_IP4_OTHER)\n\t\t\t\tvcap_rule_rem_key(vrule, VCAP_KF_TCP_IS);\n\t\t\tbreak;\n\t\tcase ETH_P_IPV6:\n\t\t\tif (vrule->keyset == VCAP_KFS_IP6_STD)\n\t\t\t\tvcap_rule_rem_key(vrule, VCAP_KF_TCP_IS);\n\t\t\tvcap_rule_rem_key(vrule, VCAP_KF_IP4_IS);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase VCAP_TYPE_IS2:\n\t\tswitch (l3_proto) {\n\t\tcase ETH_P_IP:\n\t\tcase ETH_P_IPV6:\n\t\t\tvcap_rule_rem_key(vrule, VCAP_KF_IP4_IS);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic bool sparx5_tc_flower_use_template(struct net_device *ndev,\n\t\t\t\t\t  struct flow_cls_offload *fco,\n\t\t\t\t\t  struct vcap_admin *admin,\n\t\t\t\t\t  struct vcap_rule *vrule)\n{\n\tstruct sparx5_port *port = netdev_priv(ndev);\n\tstruct sparx5_tc_flower_template *ftp;\n\n\tlist_for_each_entry(ftp, &port->tc_templates, list) {\n\t\tif (ftp->cid != fco->common.chain_index)\n\t\t\tcontinue;\n\n\t\tvcap_set_rule_set_keyset(vrule, ftp->keyset);\n\t\tsparx5_tc_flower_simplify_rule(admin, vrule, ftp->l3_proto);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic int sparx5_tc_flower_replace(struct net_device *ndev,\n\t\t\t\t    struct flow_cls_offload *fco,\n\t\t\t\t    struct vcap_admin *admin,\n\t\t\t\t    bool ingress)\n{\n\tstruct sparx5_psfp_sf sf = { .max_sdu = SPX5_PSFP_SF_MAX_SDU };\n\tstruct netlink_ext_ack *extack = fco->common.extack;\n\tint err, idx, tc_sg_idx = -1, tc_pol_idx = -1;\n\tstruct vcap_tc_flower_parse_usage state = {\n\t\t.fco = fco,\n\t\t.l3_proto = ETH_P_ALL,\n\t\t.admin = admin,\n\t};\n\tstruct sparx5_port *port = netdev_priv(ndev);\n\tstruct sparx5_multiple_rules multi = {};\n\tstruct sparx5 *sparx5 = port->sparx5;\n\tstruct sparx5_psfp_sg sg = { 0 };\n\tstruct sparx5_psfp_fm fm = { 0 };\n\tstruct flow_action_entry *act;\n\tstruct vcap_control *vctrl;\n\tstruct flow_rule *frule;\n\tstruct vcap_rule *vrule;\n\n\tvctrl = port->sparx5->vcap_ctrl;\n\n\terr = sparx5_tc_flower_action_check(vctrl, ndev, fco, ingress);\n\tif (err)\n\t\treturn err;\n\n\tvrule = vcap_alloc_rule(vctrl, ndev, fco->common.chain_index, VCAP_USER_TC,\n\t\t\t\tfco->common.prio, 0);\n\tif (IS_ERR(vrule))\n\t\treturn PTR_ERR(vrule);\n\n\tvrule->cookie = fco->cookie;\n\n\tstate.vrule = vrule;\n\tstate.frule = flow_cls_offload_flow_rule(fco);\n\terr = sparx5_tc_use_dissectors(&state, admin, vrule);\n\tif (err)\n\t\tgoto out;\n\n\terr = sparx5_tc_add_rule_counter(admin, vrule);\n\tif (err)\n\t\tgoto out;\n\n\terr = sparx5_tc_add_rule_link_target(admin, vrule,\n\t\t\t\t\t     fco->common.chain_index);\n\tif (err)\n\t\tgoto out;\n\n\tfrule = flow_cls_offload_flow_rule(fco);\n\tflow_action_for_each(idx, act, &frule->action) {\n\t\tswitch (act->id) {\n\t\tcase FLOW_ACTION_GATE: {\n\t\t\terr = sparx5_tc_flower_parse_act_gate(&sg, act, extack);\n\t\t\tif (err < 0)\n\t\t\t\tgoto out;\n\n\t\t\ttc_sg_idx = act->hw_index;\n\n\t\t\tbreak;\n\t\t}\n\t\tcase FLOW_ACTION_POLICE: {\n\t\t\terr = sparx5_tc_flower_parse_act_police(&fm.pol, act,\n\t\t\t\t\t\t\t\textack);\n\t\t\tif (err < 0)\n\t\t\t\tgoto out;\n\n\t\t\ttc_pol_idx = fm.pol.idx;\n\t\t\tsf.max_sdu = act->police.mtu;\n\n\t\t\tbreak;\n\t\t}\n\t\tcase FLOW_ACTION_TRAP:\n\t\t\terr = sparx5_tc_action_trap(admin, vrule, fco);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase FLOW_ACTION_ACCEPT:\n\t\t\terr = sparx5_tc_set_actionset(admin, vrule);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase FLOW_ACTION_GOTO:\n\t\t\terr = sparx5_tc_set_actionset(admin, vrule);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t\tsparx5_tc_add_rule_link(vctrl, admin, vrule,\n\t\t\t\t\t\tfco->common.chain_index,\n\t\t\t\t\t\tact->chain_index);\n\t\t\tbreak;\n\t\tcase FLOW_ACTION_VLAN_POP:\n\t\t\terr = sparx5_tc_action_vlan_pop(admin, vrule, fco,\n\t\t\t\t\t\t\tstate.tpid);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase FLOW_ACTION_VLAN_PUSH:\n\t\t\terr = sparx5_tc_action_vlan_push(admin, vrule, fco,\n\t\t\t\t\t\t\t act, state.tpid);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase FLOW_ACTION_VLAN_MANGLE:\n\t\t\terr = sparx5_tc_action_vlan_modify(admin, vrule, fco,\n\t\t\t\t\t\t\t   act, state.tpid);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tNL_SET_ERR_MSG_MOD(fco->common.extack,\n\t\t\t\t\t   \"Unsupported TC action\");\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tif (tc_sg_idx >= 0 || tc_pol_idx >= 0) {\n\t\terr = sparx5_tc_flower_psfp_setup(sparx5, vrule, tc_sg_idx,\n\t\t\t\t\t\t  tc_pol_idx, &sg, &fm, &sf);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tif (!sparx5_tc_flower_use_template(ndev, fco, admin, vrule)) {\n\t\terr = sparx5_tc_select_protocol_keyset(ndev, vrule, admin,\n\t\t\t\t\t\t       state.l3_proto, &multi);\n\t\tif (err) {\n\t\t\tNL_SET_ERR_MSG_MOD(fco->common.extack,\n\t\t\t\t\t   \"No matching port keyset for filter protocol and keys\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\terr = vcap_val_rule(vrule, state.l3_proto);\n\tif (err) {\n\t\tvcap_set_tc_exterr(fco, vrule);\n\t\tgoto out;\n\t}\n\terr = vcap_add_rule(vrule);\n\tif (err)\n\t\tNL_SET_ERR_MSG_MOD(fco->common.extack,\n\t\t\t\t   \"Could not add the filter\");\n\n\tif (state.l3_proto == ETH_P_ALL)\n\t\terr = sparx5_tc_add_remaining_rules(vctrl, fco, vrule, admin,\n\t\t\t\t\t\t    &multi);\n\nout:\n\tvcap_free_rule(vrule);\n\treturn err;\n}\n\nstatic void sparx5_tc_free_psfp_resources(struct sparx5 *sparx5,\n\t\t\t\t\t  struct vcap_rule *vrule)\n{\n\tstruct vcap_client_actionfield *afield;\n\tu32 isdx, sfid, sgid, fmid;\n\n\t \n\tafield = vcap_find_actionfield(vrule, VCAP_AF_ISDX_VAL);\n\tif (!afield)\n\t\treturn;\n\n\tisdx = afield->data.u32.value;\n\tsfid = sparx5_psfp_isdx_get_sf(sparx5, isdx);\n\n\tif (!sfid)\n\t\treturn;\n\n\tfmid = sparx5_psfp_isdx_get_fm(sparx5, isdx);\n\tsgid = sparx5_psfp_sf_get_sg(sparx5, sfid);\n\n\tif (fmid && sparx5_psfp_fm_del(sparx5, fmid) < 0)\n\t\tpr_err(\"%s:%d Could not delete invalid fmid: %d\", __func__,\n\t\t       __LINE__, fmid);\n\n\tif (sgid && sparx5_psfp_sg_del(sparx5, sgid) < 0)\n\t\tpr_err(\"%s:%d Could not delete invalid sgid: %d\", __func__,\n\t\t       __LINE__, sgid);\n\n\tif (sparx5_psfp_sf_del(sparx5, sfid) < 0)\n\t\tpr_err(\"%s:%d Could not delete invalid sfid: %d\", __func__,\n\t\t       __LINE__, sfid);\n\n\tsparx5_isdx_conf_set(sparx5, isdx, 0, 0);\n}\n\nstatic int sparx5_tc_free_rule_resources(struct net_device *ndev,\n\t\t\t\t\t struct vcap_control *vctrl,\n\t\t\t\t\t int rule_id)\n{\n\tstruct sparx5_port *port = netdev_priv(ndev);\n\tstruct sparx5 *sparx5 = port->sparx5;\n\tstruct vcap_rule *vrule;\n\tint ret = 0;\n\n\tvrule = vcap_get_rule(vctrl, rule_id);\n\tif (IS_ERR(vrule))\n\t\treturn -EINVAL;\n\n\tsparx5_tc_free_psfp_resources(sparx5, vrule);\n\n\tvcap_free_rule(vrule);\n\treturn ret;\n}\n\nstatic int sparx5_tc_flower_destroy(struct net_device *ndev,\n\t\t\t\t    struct flow_cls_offload *fco,\n\t\t\t\t    struct vcap_admin *admin)\n{\n\tstruct sparx5_port *port = netdev_priv(ndev);\n\tint err = -ENOENT, count = 0, rule_id;\n\tstruct vcap_control *vctrl;\n\n\tvctrl = port->sparx5->vcap_ctrl;\n\twhile (true) {\n\t\trule_id = vcap_lookup_rule_by_cookie(vctrl, fco->cookie);\n\t\tif (rule_id <= 0)\n\t\t\tbreak;\n\t\tif (count == 0) {\n\t\t\t \n\t\t\terr = sparx5_tc_free_rule_resources(ndev, vctrl,\n\t\t\t\t\t\t\t    rule_id);\n\t\t\tif (err)\n\t\t\t\tpr_err(\"%s:%d: could not free resources %d\\n\",\n\t\t\t\t       __func__, __LINE__, rule_id);\n\t\t}\n\t\terr = vcap_del_rule(vctrl, ndev, rule_id);\n\t\tif (err) {\n\t\t\tpr_err(\"%s:%d: could not delete rule %d\\n\",\n\t\t\t       __func__, __LINE__, rule_id);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn err;\n}\n\nstatic int sparx5_tc_flower_stats(struct net_device *ndev,\n\t\t\t\t  struct flow_cls_offload *fco,\n\t\t\t\t  struct vcap_admin *admin)\n{\n\tstruct sparx5_port *port = netdev_priv(ndev);\n\tstruct vcap_counter ctr = {};\n\tstruct vcap_control *vctrl;\n\tulong lastused = 0;\n\tint err;\n\n\tvctrl = port->sparx5->vcap_ctrl;\n\terr = vcap_get_rule_count_by_cookie(vctrl, &ctr, fco->cookie);\n\tif (err)\n\t\treturn err;\n\tflow_stats_update(&fco->stats, 0x0, ctr.value, 0, lastused,\n\t\t\t  FLOW_ACTION_HW_STATS_IMMEDIATE);\n\treturn err;\n}\n\nstatic int sparx5_tc_flower_template_create(struct net_device *ndev,\n\t\t\t\t\t    struct flow_cls_offload *fco,\n\t\t\t\t\t    struct vcap_admin *admin)\n{\n\tstruct sparx5_port *port = netdev_priv(ndev);\n\tstruct vcap_tc_flower_parse_usage state = {\n\t\t.fco = fco,\n\t\t.l3_proto = ETH_P_ALL,\n\t\t.admin = admin,\n\t};\n\tstruct sparx5_tc_flower_template *ftp;\n\tstruct vcap_keyset_list kslist = {};\n\tenum vcap_keyfield_set keysets[10];\n\tstruct vcap_control *vctrl;\n\tstruct vcap_rule *vrule;\n\tint count, err;\n\n\tif (admin->vtype == VCAP_TYPE_ES0) {\n\t\tpr_err(\"%s:%d: %s\\n\", __func__, __LINE__,\n\t\t       \"VCAP does not support templates\");\n\t\treturn -EINVAL;\n\t}\n\n\tcount = vcap_admin_rule_count(admin, fco->common.chain_index);\n\tif (count > 0) {\n\t\tpr_err(\"%s:%d: %s\\n\", __func__, __LINE__,\n\t\t       \"Filters are already present\");\n\t\treturn -EBUSY;\n\t}\n\n\tftp = kzalloc(sizeof(*ftp), GFP_KERNEL);\n\tif (!ftp)\n\t\treturn -ENOMEM;\n\n\tftp->cid = fco->common.chain_index;\n\tftp->orig = VCAP_KFS_NO_VALUE;\n\tftp->keyset = VCAP_KFS_NO_VALUE;\n\n\tvctrl = port->sparx5->vcap_ctrl;\n\tvrule = vcap_alloc_rule(vctrl, ndev, fco->common.chain_index,\n\t\t\t\tVCAP_USER_TC, fco->common.prio, 0);\n\tif (IS_ERR(vrule)) {\n\t\terr = PTR_ERR(vrule);\n\t\tgoto err_rule;\n\t}\n\n\tstate.vrule = vrule;\n\tstate.frule = flow_cls_offload_flow_rule(fco);\n\terr = sparx5_tc_use_dissectors(&state, admin, vrule);\n\tif (err) {\n\t\tpr_err(\"%s:%d: key error: %d\\n\", __func__, __LINE__, err);\n\t\tgoto out;\n\t}\n\n\tftp->l3_proto = state.l3_proto;\n\n\tsparx5_tc_flower_simplify_rule(admin, vrule, state.l3_proto);\n\n\t \n\tkslist.keysets = keysets;\n\tkslist.max = ARRAY_SIZE(keysets);\n\tif (!vcap_rule_find_keysets(vrule, &kslist)) {\n\t\tpr_err(\"%s:%d: %s\\n\", __func__, __LINE__,\n\t\t       \"Could not find a suitable keyset\");\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tftp->keyset = vcap_select_min_rule_keyset(vctrl, admin->vtype, &kslist);\n\tkslist.cnt = 0;\n\tsparx5_vcap_set_port_keyset(ndev, admin, fco->common.chain_index,\n\t\t\t\t    state.l3_proto,\n\t\t\t\t    ftp->keyset,\n\t\t\t\t    &kslist);\n\n\tif (kslist.cnt > 0)\n\t\tftp->orig = kslist.keysets[0];\n\n\t \n\tlist_add_tail(&ftp->list, &port->tc_templates);\n\tvcap_free_rule(vrule);\n\treturn 0;\n\nout:\n\tvcap_free_rule(vrule);\nerr_rule:\n\tkfree(ftp);\n\treturn err;\n}\n\nstatic int sparx5_tc_flower_template_destroy(struct net_device *ndev,\n\t\t\t\t\t     struct flow_cls_offload *fco,\n\t\t\t\t\t     struct vcap_admin *admin)\n{\n\tstruct sparx5_port *port = netdev_priv(ndev);\n\tstruct sparx5_tc_flower_template *ftp, *tmp;\n\tint err = -ENOENT;\n\n\t \n\tlist_for_each_entry_safe(ftp, tmp, &port->tc_templates, list) {\n\t\tif (ftp->cid != fco->common.chain_index)\n\t\t\tcontinue;\n\n\t\tsparx5_vcap_set_port_keyset(ndev, admin,\n\t\t\t\t\t    fco->common.chain_index,\n\t\t\t\t\t    ftp->l3_proto, ftp->orig,\n\t\t\t\t\t    NULL);\n\t\tlist_del(&ftp->list);\n\t\tkfree(ftp);\n\t\tbreak;\n\t}\n\treturn err;\n}\n\nint sparx5_tc_flower(struct net_device *ndev, struct flow_cls_offload *fco,\n\t\t     bool ingress)\n{\n\tstruct sparx5_port *port = netdev_priv(ndev);\n\tstruct vcap_control *vctrl;\n\tstruct vcap_admin *admin;\n\tint err = -EINVAL;\n\n\t \n\tvctrl = port->sparx5->vcap_ctrl;\n\tadmin = vcap_find_admin(vctrl, fco->common.chain_index);\n\tif (!admin) {\n\t\tNL_SET_ERR_MSG_MOD(fco->common.extack, \"Invalid chain\");\n\t\treturn err;\n\t}\n\n\tswitch (fco->command) {\n\tcase FLOW_CLS_REPLACE:\n\t\treturn sparx5_tc_flower_replace(ndev, fco, admin, ingress);\n\tcase FLOW_CLS_DESTROY:\n\t\treturn sparx5_tc_flower_destroy(ndev, fco, admin);\n\tcase FLOW_CLS_STATS:\n\t\treturn sparx5_tc_flower_stats(ndev, fco, admin);\n\tcase FLOW_CLS_TMPLT_CREATE:\n\t\treturn sparx5_tc_flower_template_create(ndev, fco, admin);\n\tcase FLOW_CLS_TMPLT_DESTROY:\n\t\treturn sparx5_tc_flower_template_destroy(ndev, fco, admin);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}