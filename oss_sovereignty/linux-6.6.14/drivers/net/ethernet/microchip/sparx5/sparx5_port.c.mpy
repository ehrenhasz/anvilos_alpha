{
  "module_name": "sparx5_port.c",
  "hash_id": "1d70eeb65996bf9a186051026574d3ec065a94e7c1f3e03e1ebb94a54b8d38ea",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/microchip/sparx5/sparx5_port.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/phy/phy.h>\n#include <net/dcbnl.h>\n\n#include \"sparx5_main_regs.h\"\n#include \"sparx5_main.h\"\n#include \"sparx5_port.h\"\n\n#define SPX5_ETYPE_TAG_C     0x8100\n#define SPX5_ETYPE_TAG_S     0x88a8\n\n#define SPX5_WAIT_US         1000\n#define SPX5_WAIT_MAX_US     2000\n\nenum port_error {\n\tSPX5_PERR_SPEED,\n\tSPX5_PERR_IFTYPE,\n};\n\n#define PAUSE_DISCARD        0xC\n#define ETH_MAXLEN           (ETH_DATA_LEN + ETH_HLEN + ETH_FCS_LEN)\n\nstatic void decode_sgmii_word(u16 lp_abil, struct sparx5_port_status *status)\n{\n\tstatus->an_complete = true;\n\tif (!(lp_abil & LPA_SGMII_LINK)) {\n\t\tstatus->link = false;\n\t\treturn;\n\t}\n\n\tswitch (lp_abil & LPA_SGMII_SPD_MASK) {\n\tcase LPA_SGMII_10:\n\t\tstatus->speed = SPEED_10;\n\t\tbreak;\n\tcase LPA_SGMII_100:\n\t\tstatus->speed = SPEED_100;\n\t\tbreak;\n\tcase LPA_SGMII_1000:\n\t\tstatus->speed = SPEED_1000;\n\t\tbreak;\n\tdefault:\n\t\tstatus->link = false;\n\t\treturn;\n\t}\n\tif (lp_abil & LPA_SGMII_FULL_DUPLEX)\n\t\tstatus->duplex = DUPLEX_FULL;\n\telse\n\t\tstatus->duplex = DUPLEX_HALF;\n}\n\nstatic void decode_cl37_word(u16 lp_abil, uint16_t ld_abil, struct sparx5_port_status *status)\n{\n\tstatus->link = !(lp_abil & ADVERTISE_RFAULT) && status->link;\n\tstatus->an_complete = true;\n\tstatus->duplex = (ADVERTISE_1000XFULL & lp_abil) ?\n\t\tDUPLEX_FULL : DUPLEX_UNKNOWN; \n\n\tif ((ld_abil & ADVERTISE_1000XPAUSE) &&\n\t    (lp_abil & ADVERTISE_1000XPAUSE)) {\n\t\tstatus->pause = MLO_PAUSE_RX | MLO_PAUSE_TX;\n\t} else if ((ld_abil & ADVERTISE_1000XPSE_ASYM) &&\n\t\t   (lp_abil & ADVERTISE_1000XPSE_ASYM)) {\n\t\tstatus->pause |= (lp_abil & ADVERTISE_1000XPAUSE) ?\n\t\t\tMLO_PAUSE_TX : 0;\n\t\tstatus->pause |= (ld_abil & ADVERTISE_1000XPAUSE) ?\n\t\t\tMLO_PAUSE_RX : 0;\n\t} else {\n\t\tstatus->pause = MLO_PAUSE_NONE;\n\t}\n}\n\nstatic int sparx5_get_dev2g5_status(struct sparx5 *sparx5,\n\t\t\t\t    struct sparx5_port *port,\n\t\t\t\t    struct sparx5_port_status *status)\n{\n\tu32 portno = port->portno;\n\tu16 lp_adv, ld_adv;\n\tu32 value;\n\n\t \n\tvalue = spx5_rd(sparx5, DEV2G5_PCS1G_STICKY(portno));\n\tstatus->link_down = DEV2G5_PCS1G_STICKY_LINK_DOWN_STICKY_GET(value);\n\tif (status->link_down)\t \n\t\tspx5_wr(value, sparx5, DEV2G5_PCS1G_STICKY(portno));\n\n\t \n\tvalue = spx5_rd(sparx5, DEV2G5_PCS1G_LINK_STATUS(portno));\n\tstatus->link = DEV2G5_PCS1G_LINK_STATUS_LINK_STATUS_GET(value) &&\n\t\t       DEV2G5_PCS1G_LINK_STATUS_SYNC_STATUS_GET(value);\n\n\tif (port->conf.portmode == PHY_INTERFACE_MODE_1000BASEX)\n\t\tstatus->speed = SPEED_1000;\n\telse if (port->conf.portmode == PHY_INTERFACE_MODE_2500BASEX)\n\t\tstatus->speed = SPEED_2500;\n\n\tstatus->duplex = DUPLEX_FULL;\n\n\t \n\tvalue = spx5_rd(sparx5, DEV2G5_PCS1G_ANEG_STATUS(portno));\n\n\t \n\tif (DEV2G5_PCS1G_ANEG_STATUS_ANEG_COMPLETE_GET(value)) {\n\t\tlp_adv = DEV2G5_PCS1G_ANEG_STATUS_LP_ADV_ABILITY_GET(value);\n\t\tif (port->conf.portmode == PHY_INTERFACE_MODE_SGMII) {\n\t\t\tdecode_sgmii_word(lp_adv, status);\n\t\t} else {\n\t\t\tvalue = spx5_rd(sparx5, DEV2G5_PCS1G_ANEG_CFG(portno));\n\t\t\tld_adv = DEV2G5_PCS1G_ANEG_CFG_ADV_ABILITY_GET(value);\n\t\t\tdecode_cl37_word(lp_adv, ld_adv, status);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int sparx5_get_sfi_status(struct sparx5 *sparx5,\n\t\t\t\t struct sparx5_port *port,\n\t\t\t\t struct sparx5_port_status *status)\n{\n\tbool high_speed_dev = sparx5_is_baser(port->conf.portmode);\n\tu32 portno = port->portno;\n\tu32 value, dev, tinst;\n\tvoid __iomem *inst;\n\n\tif (!high_speed_dev) {\n\t\tnetdev_err(port->ndev, \"error: low speed and SFI mode\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdev = sparx5_to_high_dev(portno);\n\ttinst = sparx5_port_dev_index(portno);\n\tinst = spx5_inst_get(sparx5, dev, tinst);\n\n\tvalue = spx5_inst_rd(inst, DEV10G_MAC_TX_MONITOR_STICKY(0));\n\tif (value != DEV10G_MAC_TX_MONITOR_STICKY_IDLE_STATE_STICKY) {\n\t\t \n\t\tstatus->link_down = 1;\n\t\tspx5_inst_wr(0xffffffff, inst, DEV10G_MAC_TX_MONITOR_STICKY(0));\n\t\tvalue = spx5_inst_rd(inst, DEV10G_MAC_TX_MONITOR_STICKY(0));\n\t}\n\tstatus->link = (value == DEV10G_MAC_TX_MONITOR_STICKY_IDLE_STATE_STICKY);\n\tstatus->duplex = DUPLEX_FULL;\n\tif (port->conf.portmode == PHY_INTERFACE_MODE_5GBASER)\n\t\tstatus->speed = SPEED_5000;\n\telse if (port->conf.portmode == PHY_INTERFACE_MODE_10GBASER)\n\t\tstatus->speed = SPEED_10000;\n\telse\n\t\tstatus->speed = SPEED_25000;\n\n\treturn 0;\n}\n\n \nint sparx5_get_port_status(struct sparx5 *sparx5,\n\t\t\t   struct sparx5_port *port,\n\t\t\t   struct sparx5_port_status *status)\n{\n\tmemset(status, 0, sizeof(*status));\n\tstatus->speed = port->conf.speed;\n\tif (port->conf.power_down) {\n\t\tstatus->link = false;\n\t\treturn 0;\n\t}\n\tswitch (port->conf.portmode) {\n\tcase PHY_INTERFACE_MODE_SGMII:\n\tcase PHY_INTERFACE_MODE_QSGMII:\n\tcase PHY_INTERFACE_MODE_1000BASEX:\n\tcase PHY_INTERFACE_MODE_2500BASEX:\n\t\treturn sparx5_get_dev2g5_status(sparx5, port, status);\n\tcase PHY_INTERFACE_MODE_5GBASER:\n\tcase PHY_INTERFACE_MODE_10GBASER:\n\tcase PHY_INTERFACE_MODE_25GBASER:\n\t\treturn sparx5_get_sfi_status(sparx5, port, status);\n\tcase PHY_INTERFACE_MODE_NA:\n\t\treturn 0;\n\tdefault:\n\t\tnetdev_err(port->ndev, \"Status not supported\");\n\t\treturn -ENODEV;\n\t}\n\treturn 0;\n}\n\nstatic int sparx5_port_error(struct sparx5_port *port,\n\t\t\t     struct sparx5_port_config *conf,\n\t\t\t     enum port_error errtype)\n{\n\tswitch (errtype) {\n\tcase SPX5_PERR_SPEED:\n\t\tnetdev_err(port->ndev,\n\t\t\t   \"Interface does not support speed: %u: for %s\\n\",\n\t\t\t   conf->speed, phy_modes(conf->portmode));\n\t\tbreak;\n\tcase SPX5_PERR_IFTYPE:\n\t\tnetdev_err(port->ndev,\n\t\t\t   \"Switch port does not support interface type: %s\\n\",\n\t\t\t   phy_modes(conf->portmode));\n\t\tbreak;\n\tdefault:\n\t\tnetdev_err(port->ndev,\n\t\t\t   \"Interface configuration error\\n\");\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int sparx5_port_verify_speed(struct sparx5 *sparx5,\n\t\t\t\t    struct sparx5_port *port,\n\t\t\t\t    struct sparx5_port_config *conf)\n{\n\tif ((sparx5_port_is_2g5(port->portno) &&\n\t     conf->speed > SPEED_2500) ||\n\t    (sparx5_port_is_5g(port->portno)  &&\n\t     conf->speed > SPEED_5000) ||\n\t    (sparx5_port_is_10g(port->portno) &&\n\t     conf->speed > SPEED_10000))\n\t\treturn sparx5_port_error(port, conf, SPX5_PERR_SPEED);\n\n\tswitch (conf->portmode) {\n\tcase PHY_INTERFACE_MODE_NA:\n\t\treturn -EINVAL;\n\tcase PHY_INTERFACE_MODE_1000BASEX:\n\t\tif (conf->speed != SPEED_1000 ||\n\t\t    sparx5_port_is_2g5(port->portno))\n\t\t\treturn sparx5_port_error(port, conf, SPX5_PERR_SPEED);\n\t\tif (sparx5_port_is_2g5(port->portno))\n\t\t\treturn sparx5_port_error(port, conf, SPX5_PERR_IFTYPE);\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_2500BASEX:\n\t\tif (conf->speed != SPEED_2500 ||\n\t\t    sparx5_port_is_2g5(port->portno))\n\t\t\treturn sparx5_port_error(port, conf, SPX5_PERR_SPEED);\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_QSGMII:\n\t\tif (port->portno > 47)\n\t\t\treturn sparx5_port_error(port, conf, SPX5_PERR_IFTYPE);\n\t\tfallthrough;\n\tcase PHY_INTERFACE_MODE_SGMII:\n\t\tif (conf->speed != SPEED_1000 &&\n\t\t    conf->speed != SPEED_100 &&\n\t\t    conf->speed != SPEED_10 &&\n\t\t    conf->speed != SPEED_2500)\n\t\t\treturn sparx5_port_error(port, conf, SPX5_PERR_SPEED);\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_5GBASER:\n\tcase PHY_INTERFACE_MODE_10GBASER:\n\tcase PHY_INTERFACE_MODE_25GBASER:\n\t\tif ((conf->speed != SPEED_5000 &&\n\t\t     conf->speed != SPEED_10000 &&\n\t\t     conf->speed != SPEED_25000))\n\t\t\treturn sparx5_port_error(port, conf, SPX5_PERR_SPEED);\n\t\tbreak;\n\tdefault:\n\t\treturn sparx5_port_error(port, conf, SPX5_PERR_IFTYPE);\n\t}\n\treturn 0;\n}\n\nstatic bool sparx5_dev_change(struct sparx5 *sparx5,\n\t\t\t      struct sparx5_port *port,\n\t\t\t      struct sparx5_port_config *conf)\n{\n\treturn sparx5_is_baser(port->conf.portmode) ^\n\t\tsparx5_is_baser(conf->portmode);\n}\n\nstatic int sparx5_port_flush_poll(struct sparx5 *sparx5, u32 portno)\n{\n\tu32  value, resource, prio, delay_cnt = 0;\n\tbool poll_src = true;\n\tchar *mem = \"\";\n\n\t \n\twhile (1) {\n\t\tbool empty = true;\n\n\t\tfor (resource = 0; resource < (poll_src ? 2 : 1); resource++) {\n\t\t\tu32 base;\n\n\t\t\tbase = (resource == 0 ? 2048 : 0) + SPX5_PRIOS * portno;\n\t\t\tfor (prio = 0; prio < SPX5_PRIOS; prio++) {\n\t\t\t\tvalue = spx5_rd(sparx5,\n\t\t\t\t\t\tQRES_RES_STAT(base + prio));\n\t\t\t\tif (value) {\n\t\t\t\t\tmem = resource == 0 ?\n\t\t\t\t\t\t\"DST-MEM\" : \"SRC-MEM\";\n\t\t\t\t\tempty = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (empty)\n\t\t\tbreak;\n\n\t\tif (delay_cnt++ == 2000) {\n\t\t\tdev_err(sparx5->dev,\n\t\t\t\t\"Flush timeout port %u. %s queue not empty\\n\",\n\t\t\t\tportno, mem);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tusleep_range(SPX5_WAIT_US, SPX5_WAIT_MAX_US);\n\t}\n\treturn 0;\n}\n\nstatic int sparx5_port_disable(struct sparx5 *sparx5, struct sparx5_port *port, bool high_spd_dev)\n{\n\tu32 tinst = high_spd_dev ?\n\t\t    sparx5_port_dev_index(port->portno) : port->portno;\n\tu32 dev = high_spd_dev ?\n\t\t  sparx5_to_high_dev(port->portno) : TARGET_DEV2G5;\n\tvoid __iomem *devinst = spx5_inst_get(sparx5, dev, tinst);\n\tu32 spd = port->conf.speed;\n\tu32 spd_prm;\n\tint err;\n\n\tif (high_spd_dev) {\n\t\t \n\t\tspx5_inst_rmw(DEV10G_DEV_RST_CTRL_PCS_RX_RST,\n\t\t\t      DEV10G_DEV_RST_CTRL_PCS_RX_RST,\n\t\t\t      devinst,\n\t\t\t      DEV10G_DEV_RST_CTRL(0));\n\n\t\t \n\t\tspx5_inst_rmw(0,\n\t\t\t      DEV10G_MAC_ENA_CFG_RX_ENA,\n\t\t\t      devinst,\n\t\t\t      DEV10G_MAC_ENA_CFG(0));\n\t} else {\n\t\t \n\t\tspx5_inst_rmw(DEV2G5_DEV_RST_CTRL_PCS_RX_RST,\n\t\t\t      DEV2G5_DEV_RST_CTRL_PCS_RX_RST,\n\t\t\t      devinst,\n\t\t\t      DEV2G5_DEV_RST_CTRL(0));\n\t\t \n\t\tspx5_inst_rmw(0,\n\t\t\t      DEV2G5_MAC_ENA_CFG_RX_ENA,\n\t\t\t      devinst,\n\t\t\t      DEV2G5_MAC_ENA_CFG(0));\n\t}\n\t \n\tspx5_rmw(0,\n\t\t QFWD_SWITCH_PORT_MODE_PORT_ENA,\n\t\t sparx5,\n\t\t QFWD_SWITCH_PORT_MODE(port->portno));\n\n\t \n\tspx5_rmw(HSCH_PORT_MODE_DEQUEUE_DIS,\n\t\t HSCH_PORT_MODE_DEQUEUE_DIS,\n\t\t sparx5,\n\t\t HSCH_PORT_MODE(port->portno));\n\n\t \n\tspx5_rmw(QSYS_PAUSE_CFG_PAUSE_STOP_SET(0xFFF - 1),\n\t\t QSYS_PAUSE_CFG_PAUSE_STOP,\n\t\t sparx5,\n\t\t QSYS_PAUSE_CFG(port->portno));\n\n\tspd_prm = spd == SPEED_10 ? 1000 : spd == SPEED_100 ? 100 : 10;\n\t \n\tusleep_range(8 * spd_prm, 10 * spd_prm);\n\n\t \n\tspx5_rmw(HSCH_FLUSH_CTRL_FLUSH_PORT_SET(port->portno) |\n\t\t HSCH_FLUSH_CTRL_FLUSH_DST_SET(1) |\n\t\t HSCH_FLUSH_CTRL_FLUSH_SRC_SET(1) |\n\t\t HSCH_FLUSH_CTRL_FLUSH_ENA_SET(1),\n\t\t HSCH_FLUSH_CTRL_FLUSH_PORT |\n\t\t HSCH_FLUSH_CTRL_FLUSH_DST |\n\t\t HSCH_FLUSH_CTRL_FLUSH_SRC |\n\t\t HSCH_FLUSH_CTRL_FLUSH_ENA,\n\t\t sparx5,\n\t\t HSCH_FLUSH_CTRL);\n\n\t \n\tspx5_rmw(0,\n\t\t HSCH_PORT_MODE_DEQUEUE_DIS,\n\t\t sparx5,\n\t\t HSCH_PORT_MODE(port->portno));\n\n\t \n\terr = sparx5_port_flush_poll(sparx5, port->portno);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (high_spd_dev) {\n\t\tspx5_inst_rmw(DEV10G_DEV_RST_CTRL_PCS_TX_RST_SET(1) |\n\t\t\t      DEV10G_DEV_RST_CTRL_MAC_RX_RST_SET(1) |\n\t\t\t      DEV10G_DEV_RST_CTRL_MAC_TX_RST_SET(1),\n\t\t\t      DEV10G_DEV_RST_CTRL_PCS_TX_RST |\n\t\t\t      DEV10G_DEV_RST_CTRL_MAC_RX_RST |\n\t\t\t      DEV10G_DEV_RST_CTRL_MAC_TX_RST,\n\t\t\t      devinst,\n\t\t\t      DEV10G_DEV_RST_CTRL(0));\n\n\t} else {\n\t\tspx5_inst_rmw(DEV2G5_DEV_RST_CTRL_SPEED_SEL_SET(3) |\n\t\t\t      DEV2G5_DEV_RST_CTRL_PCS_TX_RST_SET(1) |\n\t\t\t      DEV2G5_DEV_RST_CTRL_PCS_RX_RST_SET(1) |\n\t\t\t      DEV2G5_DEV_RST_CTRL_MAC_TX_RST_SET(1) |\n\t\t\t      DEV2G5_DEV_RST_CTRL_MAC_RX_RST_SET(1),\n\t\t\t      DEV2G5_DEV_RST_CTRL_SPEED_SEL |\n\t\t\t      DEV2G5_DEV_RST_CTRL_PCS_TX_RST |\n\t\t\t      DEV2G5_DEV_RST_CTRL_PCS_RX_RST |\n\t\t\t      DEV2G5_DEV_RST_CTRL_MAC_TX_RST |\n\t\t\t      DEV2G5_DEV_RST_CTRL_MAC_RX_RST,\n\t\t\t      devinst,\n\t\t\t      DEV2G5_DEV_RST_CTRL(0));\n\t}\n\t \n\tspx5_rmw(HSCH_FLUSH_CTRL_FLUSH_PORT_SET(port->portno) |\n\t\t HSCH_FLUSH_CTRL_FLUSH_ENA_SET(0),\n\t\t HSCH_FLUSH_CTRL_FLUSH_PORT |\n\t\t HSCH_FLUSH_CTRL_FLUSH_ENA,\n\t\t sparx5,\n\t\t HSCH_FLUSH_CTRL);\n\n\tif (high_spd_dev) {\n\t\tu32 pcs = sparx5_to_pcs_dev(port->portno);\n\t\tvoid __iomem *pcsinst = spx5_inst_get(sparx5, pcs, tinst);\n\n\t\t \n\t\tspx5_inst_rmw(PCS10G_BR_PCS_CFG_PCS_ENA_SET(0),\n\t\t\t      PCS10G_BR_PCS_CFG_PCS_ENA,\n\t\t\t      pcsinst,\n\t\t\t      PCS10G_BR_PCS_CFG(0));\n\n\t\tif (sparx5_port_is_25g(port->portno))\n\t\t\t \n\t\t\tspx5_rmw(DEV25G_PCS25G_CFG_PCS25G_ENA_SET(0),\n\t\t\t\t DEV25G_PCS25G_CFG_PCS25G_ENA,\n\t\t\t\t sparx5,\n\t\t\t\t DEV25G_PCS25G_CFG(tinst));\n\t} else {\n\t\t \n\t\tspx5_rmw(DEV2G5_PCS1G_CFG_PCS_ENA_SET(0),\n\t\t\t DEV2G5_PCS1G_CFG_PCS_ENA,\n\t\t\t sparx5,\n\t\t\t DEV2G5_PCS1G_CFG(port->portno));\n\t}\n\n\t \n\treturn 0;\n}\n\nstatic int sparx5_port_fifo_sz(struct sparx5 *sparx5,\n\t\t\t       u32 portno, u32 speed)\n{\n\tu32 sys_clk = sparx5_clk_period(sparx5->coreclock);\n\tconst u32 taxi_dist[SPX5_PORTS_ALL] = {\n\t\t6, 8, 10, 6, 8, 10, 6, 8, 10, 6, 8, 10,\n\t\t4, 4, 4, 4,\n\t\t11, 12, 13, 14, 15, 16, 17, 18,\n\t\t11, 12, 13, 14, 15, 16, 17, 18,\n\t\t11, 12, 13, 14, 15, 16, 17, 18,\n\t\t11, 12, 13, 14, 15, 16, 17, 18,\n\t\t4, 6, 8, 4, 6, 8, 6, 8,\n\t\t2, 2, 2, 2, 2, 2, 2, 4, 2\n\t};\n\tu32 mac_per    = 6400, tmp1, tmp2, tmp3;\n\tu32 fifo_width = 16;\n\tu32 mac_width  = 8;\n\tu32 addition   = 0;\n\n\tswitch (speed) {\n\tcase SPEED_25000:\n\t\treturn 0;\n\tcase SPEED_10000:\n\t\tmac_per = 6400;\n\t\tmac_width = 8;\n\t\taddition = 1;\n\t\tbreak;\n\tcase SPEED_5000:\n\t\tmac_per = 12800;\n\t\tmac_width = 8;\n\t\taddition = 0;\n\t\tbreak;\n\tcase SPEED_2500:\n\t\tmac_per = 3200;\n\t\tmac_width = 1;\n\t\taddition = 0;\n\t\tbreak;\n\tcase SPEED_1000:\n\t\tmac_per =  8000;\n\t\tmac_width = 1;\n\t\taddition = 0;\n\t\tbreak;\n\tcase SPEED_100:\n\tcase SPEED_10:\n\t\treturn 1;\n\tdefault:\n\t\tbreak;\n\t}\n\n\ttmp1 = 1000 * mac_width / fifo_width;\n\ttmp2 = 3000 + ((12000 + 2 * taxi_dist[portno] * 1000)\n\t\t       * sys_clk / mac_per);\n\ttmp3 = tmp1 * tmp2 / 1000;\n\treturn  (tmp3 + 2000 + 999) / 1000 + addition;\n}\n\n \nstatic int sparx5_port_mux_set(struct sparx5 *sparx5,\n\t\t\t       struct sparx5_port *port,\n\t\t\t       struct sparx5_port_config *conf)\n{\n\tu32 portno = port->portno;\n\tu32 inst;\n\n\tif (port->conf.portmode == conf->portmode)\n\t\treturn 0;  \n\n\tswitch (conf->portmode) {\n\tcase PHY_INTERFACE_MODE_QSGMII:  \n\t\tinst = (portno - portno % 4) / 4;\n\t\tspx5_rmw(BIT(inst),\n\t\t\t BIT(inst),\n\t\t\t sparx5,\n\t\t\t PORT_CONF_QSGMII_ENA);\n\n\t\tif ((portno / 4 % 2) == 0) {\n\t\t\t \n\t\t\tspx5_rmw(PORT_CONF_USGMII_CFG_BYPASS_SCRAM_SET(1) |\n\t\t\t\t PORT_CONF_USGMII_CFG_BYPASS_DESCRAM_SET(1) |\n\t\t\t\t PORT_CONF_USGMII_CFG_QUAD_MODE_SET(1),\n\t\t\t\t PORT_CONF_USGMII_CFG_BYPASS_SCRAM |\n\t\t\t\t PORT_CONF_USGMII_CFG_BYPASS_DESCRAM |\n\t\t\t\t PORT_CONF_USGMII_CFG_QUAD_MODE,\n\t\t\t\t sparx5,\n\t\t\t\t PORT_CONF_USGMII_CFG((portno / 8)));\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int sparx5_port_max_tags_set(struct sparx5 *sparx5,\n\t\t\t\t    struct sparx5_port *port)\n{\n\tenum sparx5_port_max_tags max_tags    = port->max_vlan_tags;\n\tint tag_ct          = max_tags == SPX5_PORT_MAX_TAGS_ONE ? 1 :\n\t\t\t      max_tags == SPX5_PORT_MAX_TAGS_TWO ? 2 : 0;\n\tbool dtag           = max_tags == SPX5_PORT_MAX_TAGS_TWO;\n\tenum sparx5_vlan_port_type vlan_type  = port->vlan_type;\n\tbool dotag          = max_tags != SPX5_PORT_MAX_TAGS_NONE;\n\tu32 dev             = sparx5_to_high_dev(port->portno);\n\tu32 tinst           = sparx5_port_dev_index(port->portno);\n\tvoid __iomem *inst  = spx5_inst_get(sparx5, dev, tinst);\n\tu32 etype;\n\n\tetype = (vlan_type == SPX5_VLAN_PORT_TYPE_S_CUSTOM ?\n\t\t port->custom_etype :\n\t\t vlan_type == SPX5_VLAN_PORT_TYPE_C ?\n\t\t SPX5_ETYPE_TAG_C : SPX5_ETYPE_TAG_S);\n\n\tspx5_wr(DEV2G5_MAC_TAGS_CFG_TAG_ID_SET(etype) |\n\t\tDEV2G5_MAC_TAGS_CFG_PB_ENA_SET(dtag) |\n\t\tDEV2G5_MAC_TAGS_CFG_VLAN_AWR_ENA_SET(dotag) |\n\t\tDEV2G5_MAC_TAGS_CFG_VLAN_LEN_AWR_ENA_SET(dotag),\n\t\tsparx5,\n\t\tDEV2G5_MAC_TAGS_CFG(port->portno));\n\n\tif (sparx5_port_is_2g5(port->portno))\n\t\treturn 0;\n\n\tspx5_inst_rmw(DEV10G_MAC_TAGS_CFG_TAG_ID_SET(etype) |\n\t\t      DEV10G_MAC_TAGS_CFG_TAG_ENA_SET(dotag),\n\t\t      DEV10G_MAC_TAGS_CFG_TAG_ID |\n\t\t      DEV10G_MAC_TAGS_CFG_TAG_ENA,\n\t\t      inst,\n\t\t      DEV10G_MAC_TAGS_CFG(0, 0));\n\n\tspx5_inst_rmw(DEV10G_MAC_NUM_TAGS_CFG_NUM_TAGS_SET(tag_ct),\n\t\t      DEV10G_MAC_NUM_TAGS_CFG_NUM_TAGS,\n\t\t      inst,\n\t\t      DEV10G_MAC_NUM_TAGS_CFG(0));\n\n\tspx5_inst_rmw(DEV10G_MAC_MAXLEN_CFG_MAX_LEN_TAG_CHK_SET(dotag),\n\t\t      DEV10G_MAC_MAXLEN_CFG_MAX_LEN_TAG_CHK,\n\t\t      inst,\n\t\t      DEV10G_MAC_MAXLEN_CFG(0));\n\treturn 0;\n}\n\nint sparx5_port_fwd_urg(struct sparx5 *sparx5, u32 speed)\n{\n\tu32 clk_period_ps = 1600;  \n\tu32 urg = 672000;\n\n\tswitch (speed) {\n\tcase SPEED_10:\n\tcase SPEED_100:\n\tcase SPEED_1000:\n\t\turg = 672000;\n\t\tbreak;\n\tcase SPEED_2500:\n\t\turg = 270000;\n\t\tbreak;\n\tcase SPEED_5000:\n\t\turg = 135000;\n\t\tbreak;\n\tcase SPEED_10000:\n\t\turg = 67200;\n\t\tbreak;\n\tcase SPEED_25000:\n\t\turg = 27000;\n\t\tbreak;\n\t}\n\treturn urg / clk_period_ps - 1;\n}\n\nstatic u16 sparx5_wm_enc(u16 value)\n{\n\tif (value >= 2048)\n\t\treturn 2048 + value / 16;\n\n\treturn value;\n}\n\nstatic int sparx5_port_fc_setup(struct sparx5 *sparx5,\n\t\t\t\tstruct sparx5_port *port,\n\t\t\t\tstruct sparx5_port_config *conf)\n{\n\tbool fc_obey = conf->pause & MLO_PAUSE_RX ? 1 : 0;\n\tu32 pause_stop = 0xFFF - 1;  \n\n\tif (conf->pause & MLO_PAUSE_TX)\n\t\tpause_stop = sparx5_wm_enc(4  * (ETH_MAXLEN /\n\t\t\t\t\t\t SPX5_BUFFER_CELL_SZ));\n\n\t \n\tspx5_rmw(DSM_MAC_CFG_HDX_BACKPREASSURE_SET(conf->duplex == DUPLEX_HALF),\n\t\t DSM_MAC_CFG_HDX_BACKPREASSURE,\n\t\t sparx5,\n\t\t DSM_MAC_CFG(port->portno));\n\n\t \n\tspx5_rmw(DSM_RX_PAUSE_CFG_RX_PAUSE_EN_SET(fc_obey),\n\t\t DSM_RX_PAUSE_CFG_RX_PAUSE_EN,\n\t\t sparx5,\n\t\t DSM_RX_PAUSE_CFG(port->portno));\n\n\t \n\tspx5_rmw(QSYS_FWD_PRESSURE_FWD_PRESSURE_DIS_SET(fc_obey),\n\t\t QSYS_FWD_PRESSURE_FWD_PRESSURE_DIS,\n\t\t sparx5,\n\t\t QSYS_FWD_PRESSURE(port->portno));\n\n\t \n\tspx5_rmw(QSYS_PAUSE_CFG_PAUSE_STOP_SET(pause_stop),\n\t\t QSYS_PAUSE_CFG_PAUSE_STOP,\n\t\t sparx5,\n\t\t QSYS_PAUSE_CFG(port->portno));\n\n\treturn 0;\n}\n\nstatic u16 sparx5_get_aneg_word(struct sparx5_port_config *conf)\n{\n\tif (conf->portmode == PHY_INTERFACE_MODE_1000BASEX)  \n\t\treturn (conf->pause_adv | ADVERTISE_LPACK | ADVERTISE_1000XFULL);\n\telse\n\t\treturn 1;  \n}\n\nint sparx5_serdes_set(struct sparx5 *sparx5,\n\t\t      struct sparx5_port *port,\n\t\t      struct sparx5_port_config *conf)\n{\n\tint portmode, err, speed = conf->speed;\n\n\tif (conf->portmode == PHY_INTERFACE_MODE_QSGMII &&\n\t    ((port->portno % 4) != 0)) {\n\t\treturn 0;\n\t}\n\tif (sparx5_is_baser(conf->portmode)) {\n\t\tif (conf->portmode == PHY_INTERFACE_MODE_25GBASER)\n\t\t\tspeed = SPEED_25000;\n\t\telse if (conf->portmode == PHY_INTERFACE_MODE_10GBASER)\n\t\t\tspeed = SPEED_10000;\n\t\telse\n\t\t\tspeed = SPEED_5000;\n\t}\n\n\terr = phy_set_media(port->serdes, conf->media);\n\tif (err)\n\t\treturn err;\n\tif (speed > 0) {\n\t\terr = phy_set_speed(port->serdes, speed);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tif (conf->serdes_reset) {\n\t\terr = phy_reset(port->serdes);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t \n\tportmode = conf->portmode;\n\tif (sparx5_is_baser(conf->portmode))\n\t\tportmode = PHY_INTERFACE_MODE_10GBASER;\n\terr = phy_set_mode_ext(port->serdes, PHY_MODE_ETHERNET, portmode);\n\tif (err)\n\t\treturn err;\n\tconf->serdes_reset = false;\n\treturn err;\n}\n\nstatic int sparx5_port_pcs_low_set(struct sparx5 *sparx5,\n\t\t\t\t   struct sparx5_port *port,\n\t\t\t\t   struct sparx5_port_config *conf)\n{\n\tbool sgmii = false, inband_aneg = false;\n\tint err;\n\n\tif (port->conf.inband) {\n\t\tif (conf->portmode == PHY_INTERFACE_MODE_SGMII ||\n\t\t    conf->portmode == PHY_INTERFACE_MODE_QSGMII)\n\t\t\tinband_aneg = true;  \n\t\telse if (conf->portmode == PHY_INTERFACE_MODE_1000BASEX &&\n\t\t\t conf->autoneg)\n\t\t\tinband_aneg = true;  \n\n\t\terr = sparx5_serdes_set(sparx5, port, conf);\n\t\tif (err)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tsgmii = true;  \n\t}\n\n\t \n\tspx5_rmw(DEV2G5_PCS1G_MODE_CFG_SGMII_MODE_ENA_SET(sgmii),\n\t\t DEV2G5_PCS1G_MODE_CFG_SGMII_MODE_ENA,\n\t\t sparx5,\n\t\t DEV2G5_PCS1G_MODE_CFG(port->portno));\n\n\t \n\tspx5_wr(DEV2G5_PCS1G_CFG_PCS_ENA_SET(1),\n\t\tsparx5,\n\t\tDEV2G5_PCS1G_CFG(port->portno));\n\n\tif (inband_aneg) {\n\t\tu16 abil = sparx5_get_aneg_word(conf);\n\n\t\t \n\t\tspx5_wr(DEV2G5_PCS1G_ANEG_CFG_ADV_ABILITY_SET(abil) |\n\t\t\tDEV2G5_PCS1G_ANEG_CFG_SW_RESOLVE_ENA_SET(1) |\n\t\t\tDEV2G5_PCS1G_ANEG_CFG_ANEG_ENA_SET(1) |\n\t\t\tDEV2G5_PCS1G_ANEG_CFG_ANEG_RESTART_ONE_SHOT_SET(1),\n\t\t\tsparx5,\n\t\t\tDEV2G5_PCS1G_ANEG_CFG(port->portno));\n\t} else {\n\t\tspx5_wr(0, sparx5, DEV2G5_PCS1G_ANEG_CFG(port->portno));\n\t}\n\n\t \n\tspx5_rmw(DEV2G5_DEV_RST_CTRL_SPEED_SEL_SET(2) |\n\t\t DEV2G5_DEV_RST_CTRL_PCS_TX_RST_SET(0) |\n\t\t DEV2G5_DEV_RST_CTRL_PCS_RX_RST_SET(0),\n\t\t DEV2G5_DEV_RST_CTRL_SPEED_SEL |\n\t\t DEV2G5_DEV_RST_CTRL_PCS_TX_RST |\n\t\t DEV2G5_DEV_RST_CTRL_PCS_RX_RST,\n\t\t sparx5,\n\t\t DEV2G5_DEV_RST_CTRL(port->portno));\n\n\treturn 0;\n}\n\nstatic int sparx5_port_pcs_high_set(struct sparx5 *sparx5,\n\t\t\t\t    struct sparx5_port *port,\n\t\t\t\t    struct sparx5_port_config *conf)\n{\n\tu32 clk_spd = conf->portmode == PHY_INTERFACE_MODE_5GBASER ? 1 : 0;\n\tu32 pix = sparx5_port_dev_index(port->portno);\n\tu32 dev = sparx5_to_high_dev(port->portno);\n\tu32 pcs = sparx5_to_pcs_dev(port->portno);\n\tvoid __iomem *devinst;\n\tvoid __iomem *pcsinst;\n\tint err;\n\n\tdevinst = spx5_inst_get(sparx5, dev, pix);\n\tpcsinst = spx5_inst_get(sparx5, pcs, pix);\n\n\t \n\terr = sparx5_serdes_set(sparx5, port, conf);\n\tif (err)\n\t\treturn -EINVAL;\n\tif (conf->portmode == PHY_INTERFACE_MODE_25GBASER) {\n\t\t \n\t\tspx5_rmw(DEV25G_PCS25G_CFG_PCS25G_ENA_SET(1),\n\t\t\t DEV25G_PCS25G_CFG_PCS25G_ENA,\n\t\t\t sparx5,\n\t\t\t DEV25G_PCS25G_CFG(pix));\n\t} else {\n\t\t \n\t\tspx5_inst_rmw(PCS10G_BR_PCS_CFG_PCS_ENA_SET(1),\n\t\t\t      PCS10G_BR_PCS_CFG_PCS_ENA,\n\t\t\t      pcsinst,\n\t\t\t      PCS10G_BR_PCS_CFG(0));\n\t}\n\n\t \n\tspx5_inst_wr(DEV10G_MAC_ENA_CFG_RX_ENA_SET(1) |\n\t\t     DEV10G_MAC_ENA_CFG_TX_ENA_SET(1),\n\t\t     devinst,\n\t\t     DEV10G_MAC_ENA_CFG(0));\n\n\t \n\tspx5_inst_rmw(DEV10G_DEV_RST_CTRL_PCS_RX_RST_SET(0) |\n\t\t      DEV10G_DEV_RST_CTRL_PCS_TX_RST_SET(0) |\n\t\t      DEV10G_DEV_RST_CTRL_MAC_RX_RST_SET(0) |\n\t\t      DEV10G_DEV_RST_CTRL_MAC_TX_RST_SET(0) |\n\t\t      DEV10G_DEV_RST_CTRL_SPEED_SEL_SET(clk_spd),\n\t\t      DEV10G_DEV_RST_CTRL_PCS_RX_RST |\n\t\t      DEV10G_DEV_RST_CTRL_PCS_TX_RST |\n\t\t      DEV10G_DEV_RST_CTRL_MAC_RX_RST |\n\t\t      DEV10G_DEV_RST_CTRL_MAC_TX_RST |\n\t\t      DEV10G_DEV_RST_CTRL_SPEED_SEL,\n\t\t      devinst,\n\t\t      DEV10G_DEV_RST_CTRL(0));\n\n\treturn 0;\n}\n\n \nstatic void sparx5_dev_switch(struct sparx5 *sparx5, int port, bool hsd)\n{\n\tint bt_indx = BIT(sparx5_port_dev_index(port));\n\n\tif (sparx5_port_is_5g(port)) {\n\t\tspx5_rmw(hsd ? 0 : bt_indx,\n\t\t\t bt_indx,\n\t\t\t sparx5,\n\t\t\t PORT_CONF_DEV5G_MODES);\n\t} else if (sparx5_port_is_10g(port)) {\n\t\tspx5_rmw(hsd ? 0 : bt_indx,\n\t\t\t bt_indx,\n\t\t\t sparx5,\n\t\t\t PORT_CONF_DEV10G_MODES);\n\t} else if (sparx5_port_is_25g(port)) {\n\t\tspx5_rmw(hsd ? 0 : bt_indx,\n\t\t\t bt_indx,\n\t\t\t sparx5,\n\t\t\t PORT_CONF_DEV25G_MODES);\n\t}\n}\n\n \nstatic int sparx5_port_config_low_set(struct sparx5 *sparx5,\n\t\t\t\t      struct sparx5_port *port,\n\t\t\t\t      struct sparx5_port_config *conf)\n{\n\tu32 clk_spd, gig_mode, tx_gap, hdx_gap_1, hdx_gap_2;\n\tbool fdx = conf->duplex == DUPLEX_FULL;\n\tint spd = conf->speed;\n\n\tclk_spd = spd == SPEED_10 ? 0 : spd == SPEED_100 ? 1 : 2;\n\tgig_mode = spd == SPEED_1000 || spd == SPEED_2500;\n\ttx_gap = spd == SPEED_1000 ? 4 : fdx ? 6 : 5;\n\thdx_gap_1 = spd == SPEED_1000 ? 0 : spd == SPEED_100 ? 1 : 2;\n\thdx_gap_2 = spd == SPEED_1000 ? 0 : spd == SPEED_100 ? 4 : 1;\n\n\t \n\tspx5_rmw(DEV2G5_MAC_MODE_CFG_GIGA_MODE_ENA_SET(gig_mode) |\n\t\t DEV2G5_MAC_MODE_CFG_FDX_ENA_SET(fdx),\n\t\t DEV2G5_MAC_MODE_CFG_GIGA_MODE_ENA |\n\t\t DEV2G5_MAC_MODE_CFG_FDX_ENA,\n\t\t sparx5,\n\t\t DEV2G5_MAC_MODE_CFG(port->portno));\n\n\t \n\tspx5_wr(DEV2G5_MAC_IFG_CFG_TX_IFG_SET(tx_gap) |\n\t\tDEV2G5_MAC_IFG_CFG_RX_IFG1_SET(hdx_gap_1) |\n\t\tDEV2G5_MAC_IFG_CFG_RX_IFG2_SET(hdx_gap_2),\n\t\tsparx5,\n\t\tDEV2G5_MAC_IFG_CFG(port->portno));\n\n\t \n\tspx5_rmw(HSCH_PORT_MODE_AGE_DIS_SET(fdx == 0),\n\t\t HSCH_PORT_MODE_AGE_DIS,\n\t\t sparx5,\n\t\t HSCH_PORT_MODE(port->portno));\n\n\t \n\tspx5_wr(DEV2G5_MAC_ENA_CFG_RX_ENA |\n\t\tDEV2G5_MAC_ENA_CFG_TX_ENA,\n\t\tsparx5,\n\t\tDEV2G5_MAC_ENA_CFG(port->portno));\n\n\t \n\tspx5_rmw(DEV2G5_DEV_RST_CTRL_SPEED_SEL_SET(clk_spd) |\n\t\t DEV2G5_DEV_RST_CTRL_MAC_TX_RST_SET(0) |\n\t\t DEV2G5_DEV_RST_CTRL_MAC_RX_RST_SET(0),\n\t\t DEV2G5_DEV_RST_CTRL_SPEED_SEL |\n\t\t DEV2G5_DEV_RST_CTRL_MAC_TX_RST |\n\t\t DEV2G5_DEV_RST_CTRL_MAC_RX_RST,\n\t\t sparx5,\n\t\t DEV2G5_DEV_RST_CTRL(port->portno));\n\n\treturn 0;\n}\n\nint sparx5_port_pcs_set(struct sparx5 *sparx5,\n\t\t\tstruct sparx5_port *port,\n\t\t\tstruct sparx5_port_config *conf)\n\n{\n\tbool high_speed_dev = sparx5_is_baser(conf->portmode);\n\tint err;\n\n\tif (sparx5_dev_change(sparx5, port, conf)) {\n\t\t \n\t\tsparx5_dev_switch(sparx5, port->portno, high_speed_dev);\n\n\t\t \n\t\terr = sparx5_port_disable(sparx5, port, !high_speed_dev);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\t \n\terr = sparx5_port_disable(sparx5, port, high_speed_dev);\n\tif (err)\n\t\treturn -EINVAL;\n\n\tif (high_speed_dev)\n\t\terr = sparx5_port_pcs_high_set(sparx5, port, conf);\n\telse\n\t\terr = sparx5_port_pcs_low_set(sparx5, port, conf);\n\n\tif (err)\n\t\treturn -EINVAL;\n\n\tif (port->conf.inband) {\n\t\t \n\t\tspx5_rmw(ASM_PORT_CFG_CSC_STAT_DIS_SET(high_speed_dev),\n\t\t\t ASM_PORT_CFG_CSC_STAT_DIS,\n\t\t\t sparx5,\n\t\t\t ASM_PORT_CFG(port->portno));\n\n\t\t \n\t\tspx5_rmw(DSM_BUF_CFG_CSC_STAT_DIS_SET(high_speed_dev),\n\t\t\t DSM_BUF_CFG_CSC_STAT_DIS,\n\t\t\t sparx5,\n\t\t\t DSM_BUF_CFG(port->portno));\n\t}\n\n\tport->conf = *conf;\n\n\treturn 0;\n}\n\nint sparx5_port_config(struct sparx5 *sparx5,\n\t\t       struct sparx5_port *port,\n\t\t       struct sparx5_port_config *conf)\n{\n\tbool high_speed_dev = sparx5_is_baser(conf->portmode);\n\tint err, urgency, stop_wm;\n\n\terr = sparx5_port_verify_speed(sparx5, port, conf);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (!high_speed_dev)\n\t\tsparx5_port_config_low_set(sparx5, port, conf);\n\n\t \n\terr = sparx5_port_fc_setup(sparx5, port, conf);\n\tif (err)\n\t\treturn err;\n\n\t \n\tstop_wm = sparx5_port_fifo_sz(sparx5, port->portno, conf->speed);\n\tspx5_rmw(DSM_DEV_TX_STOP_WM_CFG_DEV_TX_STOP_WM_SET(stop_wm),\n\t\t DSM_DEV_TX_STOP_WM_CFG_DEV_TX_STOP_WM,\n\t\t sparx5,\n\t\t DSM_DEV_TX_STOP_WM_CFG(port->portno));\n\n\t \n\turgency = sparx5_port_fwd_urg(sparx5, conf->speed);\n\tspx5_rmw(QFWD_SWITCH_PORT_MODE_PORT_ENA_SET(1) |\n\t\t QFWD_SWITCH_PORT_MODE_FWD_URGENCY_SET(urgency),\n\t\t QFWD_SWITCH_PORT_MODE_PORT_ENA |\n\t\t QFWD_SWITCH_PORT_MODE_FWD_URGENCY,\n\t\t sparx5,\n\t\t QFWD_SWITCH_PORT_MODE(port->portno));\n\n\t \n\tport->conf = *conf;\n\n\treturn 0;\n}\n\n \nint sparx5_port_init(struct sparx5 *sparx5,\n\t\t     struct sparx5_port *port,\n\t\t     struct sparx5_port_config *conf)\n{\n\tu32 pause_start = sparx5_wm_enc(6  * (ETH_MAXLEN / SPX5_BUFFER_CELL_SZ));\n\tu32 atop = sparx5_wm_enc(20 * (ETH_MAXLEN / SPX5_BUFFER_CELL_SZ));\n\tu32 devhigh = sparx5_to_high_dev(port->portno);\n\tu32 pix = sparx5_port_dev_index(port->portno);\n\tu32 pcs = sparx5_to_pcs_dev(port->portno);\n\tbool sd_pol = port->signd_active_high;\n\tbool sd_sel = !port->signd_internal;\n\tbool sd_ena = port->signd_enable;\n\tu32 pause_stop = 0xFFF - 1;  \n\tvoid __iomem *devinst;\n\tvoid __iomem *pcsinst;\n\tint err;\n\n\tdevinst = spx5_inst_get(sparx5, devhigh, pix);\n\tpcsinst = spx5_inst_get(sparx5, pcs, pix);\n\n\t \n\terr = sparx5_port_mux_set(sparx5, port, conf);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = sparx5_port_max_tags_set(sparx5, port);\n\tif (err)\n\t\treturn err;\n\n\t \n\tspx5_rmw(DEV2G5_MAC_MAXLEN_CFG_MAX_LEN_SET(ETH_MAXLEN),\n\t\t DEV2G5_MAC_MAXLEN_CFG_MAX_LEN,\n\t\t sparx5,\n\t\t DEV2G5_MAC_MAXLEN_CFG(port->portno));\n\n\t \n\tspx5_wr(DEV2G5_PCS1G_SD_CFG_SD_POL_SET(sd_pol) |\n\t\tDEV2G5_PCS1G_SD_CFG_SD_SEL_SET(sd_sel) |\n\t\tDEV2G5_PCS1G_SD_CFG_SD_ENA_SET(sd_ena),\n\t\tsparx5,\n\t\tDEV2G5_PCS1G_SD_CFG(port->portno));\n\n\t \n\tspx5_rmw(QSYS_PAUSE_CFG_PAUSE_START_SET(pause_start) |\n\t\t QSYS_PAUSE_CFG_PAUSE_STOP_SET(pause_stop) |\n\t\t QSYS_PAUSE_CFG_PAUSE_ENA_SET(1),\n\t\t QSYS_PAUSE_CFG_PAUSE_START |\n\t\t QSYS_PAUSE_CFG_PAUSE_STOP |\n\t\t QSYS_PAUSE_CFG_PAUSE_ENA,\n\t\t sparx5,\n\t\t QSYS_PAUSE_CFG(port->portno));\n\n\t \n\tspx5_wr(QSYS_ATOP_ATOP_SET(atop),\n\t\tsparx5,\n\t\tQSYS_ATOP(port->portno));\n\n\t \n\tspx5_wr(PAUSE_DISCARD, sparx5, ANA_CL_CAPTURE_BPDU_CFG(port->portno));\n\n\t \n\tspx5_rmw(ANA_CL_FILTER_CTRL_FILTER_SMAC_MC_DIS_SET(0),\n\t\t ANA_CL_FILTER_CTRL_FILTER_SMAC_MC_DIS,\n\t\t sparx5, ANA_CL_FILTER_CTRL(port->portno));\n\n\tif (conf->portmode == PHY_INTERFACE_MODE_QSGMII ||\n\t    conf->portmode == PHY_INTERFACE_MODE_SGMII) {\n\t\terr = sparx5_serdes_set(sparx5, port, conf);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (!sparx5_port_is_2g5(port->portno))\n\t\t\t \n\t\t\tspx5_rmw(DSM_DEV_TX_STOP_WM_CFG_DEV10G_SHADOW_ENA_SET(1),\n\t\t\t\t DSM_DEV_TX_STOP_WM_CFG_DEV10G_SHADOW_ENA,\n\t\t\t\t sparx5,\n\t\t\t\t DSM_DEV_TX_STOP_WM_CFG(port->portno));\n\n\t\tsparx5_dev_switch(sparx5, port->portno, false);\n\t}\n\tif (conf->portmode == PHY_INTERFACE_MODE_QSGMII) {\n\t\t \n\t\tspx5_rmw(DEV2G5_DEV_RST_CTRL_PCS_TX_RST_SET(0),\n\t\t\t DEV2G5_DEV_RST_CTRL_PCS_TX_RST,\n\t\t\t sparx5,\n\t\t\t DEV2G5_DEV_RST_CTRL(port->portno));\n\t}\n\t \n\tspx5_wr(DEV2G5_MAC_IFG_CFG_TX_IFG_SET(6) |\n\t\tDEV2G5_MAC_IFG_CFG_RX_IFG1_SET(0) |\n\t\tDEV2G5_MAC_IFG_CFG_RX_IFG2_SET(0),\n\t\tsparx5,\n\t\tDEV2G5_MAC_IFG_CFG(port->portno));\n\n\tif (sparx5_port_is_2g5(port->portno))\n\t\treturn 0;  \n\n\t \n\tif (conf->portmode == PHY_INTERFACE_MODE_NA)\n\t\tconf->portmode = PHY_INTERFACE_MODE_10GBASER;\n\n\tif (sparx5_is_baser(conf->portmode))\n\t\tsparx5_dev_switch(sparx5, port->portno, true);\n\n\t \n\tspx5_inst_rmw(DEV10G_MAC_MAXLEN_CFG_MAX_LEN_SET(ETH_MAXLEN),\n\t\t      DEV10G_MAC_MAXLEN_CFG_MAX_LEN,\n\t\t      devinst,\n\t\t      DEV10G_MAC_ENA_CFG(0));\n\n\t \n\tspx5_inst_wr(PCS10G_BR_PCS_SD_CFG_SD_POL_SET(sd_pol) |\n\t\t     PCS10G_BR_PCS_SD_CFG_SD_SEL_SET(sd_sel) |\n\t\t     PCS10G_BR_PCS_SD_CFG_SD_ENA_SET(sd_ena),\n\t\t     pcsinst,\n\t\t     PCS10G_BR_PCS_SD_CFG(0));\n\n\tif (sparx5_port_is_25g(port->portno)) {\n\t\t \n\t\tspx5_wr(DEV25G_PCS25G_SD_CFG_SD_POL_SET(sd_pol) |\n\t\t\tDEV25G_PCS25G_SD_CFG_SD_SEL_SET(sd_sel) |\n\t\t\tDEV25G_PCS25G_SD_CFG_SD_ENA_SET(sd_ena),\n\t\t\tsparx5,\n\t\t\tDEV25G_PCS25G_SD_CFG(pix));\n\t}\n\n\treturn 0;\n}\n\nvoid sparx5_port_enable(struct sparx5_port *port, bool enable)\n{\n\tstruct sparx5 *sparx5 = port->sparx5;\n\n\t \n\tspx5_rmw(QFWD_SWITCH_PORT_MODE_PORT_ENA_SET(enable),\n\t\t QFWD_SWITCH_PORT_MODE_PORT_ENA,\n\t\t sparx5,\n\t\t QFWD_SWITCH_PORT_MODE(port->portno));\n}\n\nint sparx5_port_qos_set(struct sparx5_port *port,\n\t\t\tstruct sparx5_port_qos *qos)\n{\n\tsparx5_port_qos_dscp_set(port, &qos->dscp);\n\tsparx5_port_qos_pcp_set(port, &qos->pcp);\n\tsparx5_port_qos_pcp_rewr_set(port, &qos->pcp_rewr);\n\tsparx5_port_qos_dscp_rewr_set(port, &qos->dscp_rewr);\n\tsparx5_port_qos_default_set(port, qos);\n\n\treturn 0;\n}\n\nint sparx5_port_qos_pcp_rewr_set(const struct sparx5_port *port,\n\t\t\t\t struct sparx5_port_qos_pcp_rewr *qos)\n{\n\tint i, mode = SPARX5_PORT_REW_TAG_CTRL_CLASSIFIED;\n\tstruct sparx5 *sparx5 = port->sparx5;\n\tu8 pcp, dei;\n\n\t \n\tif (qos->enable)\n\t\tmode = SPARX5_PORT_REW_TAG_CTRL_MAPPED;\n\n\tspx5_rmw(REW_TAG_CTRL_TAG_PCP_CFG_SET(mode) |\n\t\t REW_TAG_CTRL_TAG_DEI_CFG_SET(mode),\n\t\t REW_TAG_CTRL_TAG_PCP_CFG | REW_TAG_CTRL_TAG_DEI_CFG,\n\t\t port->sparx5, REW_TAG_CTRL(port->portno));\n\n\tfor (i = 0; i < ARRAY_SIZE(qos->map.map); i++) {\n\t\t \n\t\tpcp = qos->map.map[i];\n\t\tif (pcp > SPARX5_PORT_QOS_PCP_COUNT)\n\t\t\tdei = 1;\n\t\telse\n\t\t\tdei = 0;\n\n\t\t \n\t\tif (dei) {\n\t\t\tspx5_rmw(REW_PCP_MAP_DE1_PCP_DE1_SET(pcp),\n\t\t\t\t REW_PCP_MAP_DE1_PCP_DE1, sparx5,\n\t\t\t\t REW_PCP_MAP_DE1(port->portno, i));\n\n\t\t\tspx5_rmw(REW_DEI_MAP_DE1_DEI_DE1_SET(dei),\n\t\t\t\t REW_DEI_MAP_DE1_DEI_DE1, port->sparx5,\n\t\t\t\t REW_DEI_MAP_DE1(port->portno, i));\n\t\t} else {\n\t\t\tspx5_rmw(REW_PCP_MAP_DE0_PCP_DE0_SET(pcp),\n\t\t\t\t REW_PCP_MAP_DE0_PCP_DE0, sparx5,\n\t\t\t\t REW_PCP_MAP_DE0(port->portno, i));\n\n\t\t\tspx5_rmw(REW_DEI_MAP_DE0_DEI_DE0_SET(dei),\n\t\t\t\t REW_DEI_MAP_DE0_DEI_DE0, port->sparx5,\n\t\t\t\t REW_DEI_MAP_DE0(port->portno, i));\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint sparx5_port_qos_pcp_set(const struct sparx5_port *port,\n\t\t\t    struct sparx5_port_qos_pcp *qos)\n{\n\tstruct sparx5 *sparx5 = port->sparx5;\n\tu8 *pcp_itr = qos->map.map;\n\tu8 pcp, dp;\n\tint i;\n\n\t \n\tspx5_rmw(ANA_CL_QOS_CFG_PCP_DEI_QOS_ENA_SET(qos->qos_enable) |\n\t\t ANA_CL_QOS_CFG_PCP_DEI_DP_ENA_SET(qos->dp_enable),\n\t\t ANA_CL_QOS_CFG_PCP_DEI_QOS_ENA | ANA_CL_QOS_CFG_PCP_DEI_DP_ENA,\n\t\t sparx5, ANA_CL_QOS_CFG(port->portno));\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(qos->map.map); i++) {\n\t\tpcp = *(pcp_itr + i);\n\t\tdp = (i < SPARX5_PORT_QOS_PCP_COUNT) ? 0 : 1;\n\t\tspx5_rmw(ANA_CL_PCP_DEI_MAP_CFG_PCP_DEI_QOS_VAL_SET(pcp) |\n\t\t\t ANA_CL_PCP_DEI_MAP_CFG_PCP_DEI_DP_VAL_SET(dp),\n\t\t\t ANA_CL_PCP_DEI_MAP_CFG_PCP_DEI_QOS_VAL |\n\t\t\t ANA_CL_PCP_DEI_MAP_CFG_PCP_DEI_DP_VAL, sparx5,\n\t\t\t ANA_CL_PCP_DEI_MAP_CFG(port->portno, i));\n\t}\n\n\treturn 0;\n}\n\nvoid sparx5_port_qos_dscp_rewr_mode_set(const struct sparx5_port *port,\n\t\t\t\t\tint mode)\n{\n\tspx5_rmw(ANA_CL_QOS_CFG_DSCP_REWR_MODE_SEL_SET(mode),\n\t\t ANA_CL_QOS_CFG_DSCP_REWR_MODE_SEL, port->sparx5,\n\t\t ANA_CL_QOS_CFG(port->portno));\n}\n\nint sparx5_port_qos_dscp_rewr_set(const struct sparx5_port *port,\n\t\t\t\t  struct sparx5_port_qos_dscp_rewr *qos)\n{\n\tstruct sparx5 *sparx5 = port->sparx5;\n\tbool rewr = false;\n\tu16 dscp;\n\tint i;\n\n\t \n\tif (qos->enable)\n\t\trewr = true;\n\n\tspx5_rmw(REW_DSCP_MAP_DSCP_UPDATE_ENA_SET(rewr),\n\t\t REW_DSCP_MAP_DSCP_UPDATE_ENA, sparx5,\n\t\t REW_DSCP_MAP(port->portno));\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(qos->map.map); i++) {\n\t\tdscp = qos->map.map[i];\n\t\tspx5_rmw(ANA_CL_QOS_MAP_CFG_DSCP_REWR_VAL_SET(dscp),\n\t\t\t ANA_CL_QOS_MAP_CFG_DSCP_REWR_VAL, sparx5,\n\t\t\t ANA_CL_QOS_MAP_CFG(i));\n\t}\n\n\treturn 0;\n}\n\nint sparx5_port_qos_dscp_set(const struct sparx5_port *port,\n\t\t\t     struct sparx5_port_qos_dscp *qos)\n{\n\tstruct sparx5 *sparx5 = port->sparx5;\n\tu8 *dscp = qos->map.map;\n\tint i;\n\n\t \n\tspx5_rmw(ANA_CL_QOS_CFG_DSCP_QOS_ENA_SET(qos->qos_enable) |\n\t\t ANA_CL_QOS_CFG_DSCP_DP_ENA_SET(qos->dp_enable) |\n\t\t ANA_CL_QOS_CFG_DSCP_KEEP_ENA_SET(1),\n\t\t ANA_CL_QOS_CFG_DSCP_QOS_ENA | ANA_CL_QOS_CFG_DSCP_DP_ENA |\n\t\t ANA_CL_QOS_CFG_DSCP_KEEP_ENA, sparx5,\n\t\t ANA_CL_QOS_CFG(port->portno));\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(qos->map.map); i++) {\n\t\tspx5_rmw(ANA_CL_DSCP_CFG_DSCP_QOS_VAL_SET(*(dscp + i)) |\n\t\t\t ANA_CL_DSCP_CFG_DSCP_DP_VAL_SET(0),\n\t\t\t ANA_CL_DSCP_CFG_DSCP_QOS_VAL |\n\t\t\t ANA_CL_DSCP_CFG_DSCP_DP_VAL, sparx5,\n\t\t\t ANA_CL_DSCP_CFG(i));\n\t}\n\n\t \n\tfor (i = 0; i <  ARRAY_SIZE(qos->map.map); i++) {\n\t\tif (qos->qos_enable) {\n\t\t\tspx5_rmw(ANA_CL_DSCP_CFG_DSCP_TRUST_ENA_SET(1),\n\t\t\t\t ANA_CL_DSCP_CFG_DSCP_TRUST_ENA, sparx5,\n\t\t\t\t ANA_CL_DSCP_CFG(i));\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint sparx5_port_qos_default_set(const struct sparx5_port *port,\n\t\t\t\tconst struct sparx5_port_qos *qos)\n{\n\tstruct sparx5 *sparx5 = port->sparx5;\n\n\t \n\tspx5_rmw(ANA_CL_QOS_CFG_DEFAULT_QOS_VAL_SET(qos->default_prio) |\n\t\t ANA_CL_QOS_CFG_DEFAULT_DP_VAL_SET(0),\n\t\t ANA_CL_QOS_CFG_DEFAULT_QOS_VAL |\n\t\t ANA_CL_QOS_CFG_DEFAULT_DP_VAL,\n\t\t sparx5, ANA_CL_QOS_CFG(port->portno));\n\n\t \n\tspx5_rmw(ANA_CL_VLAN_CTRL_PORT_PCP_SET(0) |\n\t\t ANA_CL_VLAN_CTRL_PORT_DEI_SET(0),\n\t\t ANA_CL_VLAN_CTRL_PORT_PCP |\n\t\t ANA_CL_VLAN_CTRL_PORT_DEI,\n\t\t sparx5, ANA_CL_VLAN_CTRL(port->portno));\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}