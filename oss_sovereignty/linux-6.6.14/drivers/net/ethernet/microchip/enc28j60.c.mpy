{
  "module_name": "enc28j60.c",
  "hash_id": "6beeda49a0cd7f2522b920786d86b5f6aa7b7bbfe7d4615ccafc8f9c7f34031f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/microchip/enc28j60.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/fcntl.h>\n#include <linux/interrupt.h>\n#include <linux/property.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/ethtool.h>\n#include <linux/tcp.h>\n#include <linux/skbuff.h>\n#include <linux/delay.h>\n#include <linux/spi/spi.h>\n\n#include \"enc28j60_hw.h\"\n\n#define DRV_NAME\t\"enc28j60\"\n#define DRV_VERSION\t\"1.02\"\n\n#define SPI_OPLEN\t1\n\n#define ENC28J60_MSG_DEFAULT\t\\\n\t(NETIF_MSG_PROBE | NETIF_MSG_IFUP | NETIF_MSG_IFDOWN | NETIF_MSG_LINK)\n\n \n#define SPI_TRANSFER_BUF_LEN\t(4 + MAX_FRAMELEN)\n\n#define TX_TIMEOUT\t\t(4 * HZ)\n\n \n#define MAX_TX_RETRYCOUNT\t16\n\nenum {\n\tRXFILTER_NORMAL,\n\tRXFILTER_MULTI,\n\tRXFILTER_PROMISC\n};\n\n \nstruct enc28j60_net {\n\tstruct net_device *netdev;\n\tstruct spi_device *spi;\n\tstruct mutex lock;\n\tstruct sk_buff *tx_skb;\n\tstruct work_struct tx_work;\n\tstruct work_struct setrx_work;\n\tstruct work_struct restart_work;\n\tu8 bank;\t\t \n\tu16 next_pk_ptr;\t \n\tu16 max_pk_counter;\t \n\tu16 tx_retry_count;\n\tbool hw_enable;\n\tbool full_duplex;\n\tint rxfilter;\n\tu32 msg_enable;\n\tu8 spi_transfer_buf[SPI_TRANSFER_BUF_LEN];\n};\n\n \nstatic struct {\n\tu32 msg_enable;\n} debug = { -1 };\n\n \nstatic int\nspi_read_buf(struct enc28j60_net *priv, int len, u8 *data)\n{\n\tstruct device *dev = &priv->spi->dev;\n\tu8 *rx_buf = priv->spi_transfer_buf + 4;\n\tu8 *tx_buf = priv->spi_transfer_buf;\n\tstruct spi_transfer tx = {\n\t\t.tx_buf = tx_buf,\n\t\t.len = SPI_OPLEN,\n\t};\n\tstruct spi_transfer rx = {\n\t\t.rx_buf = rx_buf,\n\t\t.len = len,\n\t};\n\tstruct spi_message msg;\n\tint ret;\n\n\ttx_buf[0] = ENC28J60_READ_BUF_MEM;\n\n\tspi_message_init(&msg);\n\tspi_message_add_tail(&tx, &msg);\n\tspi_message_add_tail(&rx, &msg);\n\n\tret = spi_sync(priv->spi, &msg);\n\tif (ret == 0) {\n\t\tmemcpy(data, rx_buf, len);\n\t\tret = msg.status;\n\t}\n\tif (ret && netif_msg_drv(priv))\n\t\tdev_printk(KERN_DEBUG, dev, \"%s() failed: ret = %d\\n\",\n\t\t\t   __func__, ret);\n\n\treturn ret;\n}\n\n \nstatic int spi_write_buf(struct enc28j60_net *priv, int len, const u8 *data)\n{\n\tstruct device *dev = &priv->spi->dev;\n\tint ret;\n\n\tif (len > SPI_TRANSFER_BUF_LEN - 1 || len <= 0)\n\t\tret = -EINVAL;\n\telse {\n\t\tpriv->spi_transfer_buf[0] = ENC28J60_WRITE_BUF_MEM;\n\t\tmemcpy(&priv->spi_transfer_buf[1], data, len);\n\t\tret = spi_write(priv->spi, priv->spi_transfer_buf, len + 1);\n\t\tif (ret && netif_msg_drv(priv))\n\t\t\tdev_printk(KERN_DEBUG, dev, \"%s() failed: ret = %d\\n\",\n\t\t\t\t   __func__, ret);\n\t}\n\treturn ret;\n}\n\n \nstatic u8 spi_read_op(struct enc28j60_net *priv, u8 op, u8 addr)\n{\n\tstruct device *dev = &priv->spi->dev;\n\tu8 tx_buf[2];\n\tu8 rx_buf[4];\n\tu8 val = 0;\n\tint ret;\n\tint slen = SPI_OPLEN;\n\n\t \n\tif (addr & SPRD_MASK)\n\t\tslen++;\n\n\ttx_buf[0] = op | (addr & ADDR_MASK);\n\tret = spi_write_then_read(priv->spi, tx_buf, 1, rx_buf, slen);\n\tif (ret)\n\t\tdev_printk(KERN_DEBUG, dev, \"%s() failed: ret = %d\\n\",\n\t\t\t   __func__, ret);\n\telse\n\t\tval = rx_buf[slen - 1];\n\n\treturn val;\n}\n\n \nstatic int spi_write_op(struct enc28j60_net *priv, u8 op, u8 addr, u8 val)\n{\n\tstruct device *dev = &priv->spi->dev;\n\tint ret;\n\n\tpriv->spi_transfer_buf[0] = op | (addr & ADDR_MASK);\n\tpriv->spi_transfer_buf[1] = val;\n\tret = spi_write(priv->spi, priv->spi_transfer_buf, 2);\n\tif (ret && netif_msg_drv(priv))\n\t\tdev_printk(KERN_DEBUG, dev, \"%s() failed: ret = %d\\n\",\n\t\t\t   __func__, ret);\n\treturn ret;\n}\n\nstatic void enc28j60_soft_reset(struct enc28j60_net *priv)\n{\n\tspi_write_op(priv, ENC28J60_SOFT_RESET, 0, ENC28J60_SOFT_RESET);\n\t \n\tudelay(2000);\n}\n\n \nstatic void enc28j60_set_bank(struct enc28j60_net *priv, u8 addr)\n{\n\tu8 b = (addr & BANK_MASK) >> 5;\n\n\t \n\tif (addr >= EIE && addr <= ECON1)\n\t\treturn;\n\n\t \n\tif ((b & ECON1_BSEL0) != (priv->bank & ECON1_BSEL0)) {\n\t\tif (b & ECON1_BSEL0)\n\t\t\tspi_write_op(priv, ENC28J60_BIT_FIELD_SET, ECON1,\n\t\t\t\t\tECON1_BSEL0);\n\t\telse\n\t\t\tspi_write_op(priv, ENC28J60_BIT_FIELD_CLR, ECON1,\n\t\t\t\t\tECON1_BSEL0);\n\t}\n\tif ((b & ECON1_BSEL1) != (priv->bank & ECON1_BSEL1)) {\n\t\tif (b & ECON1_BSEL1)\n\t\t\tspi_write_op(priv, ENC28J60_BIT_FIELD_SET, ECON1,\n\t\t\t\t\tECON1_BSEL1);\n\t\telse\n\t\t\tspi_write_op(priv, ENC28J60_BIT_FIELD_CLR, ECON1,\n\t\t\t\t\tECON1_BSEL1);\n\t}\n\tpriv->bank = b;\n}\n\n \n\n \nstatic void nolock_reg_bfset(struct enc28j60_net *priv, u8 addr, u8 mask)\n{\n\tenc28j60_set_bank(priv, addr);\n\tspi_write_op(priv, ENC28J60_BIT_FIELD_SET, addr, mask);\n}\n\nstatic void locked_reg_bfset(struct enc28j60_net *priv, u8 addr, u8 mask)\n{\n\tmutex_lock(&priv->lock);\n\tnolock_reg_bfset(priv, addr, mask);\n\tmutex_unlock(&priv->lock);\n}\n\n \nstatic void nolock_reg_bfclr(struct enc28j60_net *priv, u8 addr, u8 mask)\n{\n\tenc28j60_set_bank(priv, addr);\n\tspi_write_op(priv, ENC28J60_BIT_FIELD_CLR, addr, mask);\n}\n\nstatic void locked_reg_bfclr(struct enc28j60_net *priv, u8 addr, u8 mask)\n{\n\tmutex_lock(&priv->lock);\n\tnolock_reg_bfclr(priv, addr, mask);\n\tmutex_unlock(&priv->lock);\n}\n\n \nstatic int nolock_regb_read(struct enc28j60_net *priv, u8 address)\n{\n\tenc28j60_set_bank(priv, address);\n\treturn spi_read_op(priv, ENC28J60_READ_CTRL_REG, address);\n}\n\nstatic int locked_regb_read(struct enc28j60_net *priv, u8 address)\n{\n\tint ret;\n\n\tmutex_lock(&priv->lock);\n\tret = nolock_regb_read(priv, address);\n\tmutex_unlock(&priv->lock);\n\n\treturn ret;\n}\n\n \nstatic int nolock_regw_read(struct enc28j60_net *priv, u8 address)\n{\n\tint rl, rh;\n\n\tenc28j60_set_bank(priv, address);\n\trl = spi_read_op(priv, ENC28J60_READ_CTRL_REG, address);\n\trh = spi_read_op(priv, ENC28J60_READ_CTRL_REG, address + 1);\n\n\treturn (rh << 8) | rl;\n}\n\nstatic int locked_regw_read(struct enc28j60_net *priv, u8 address)\n{\n\tint ret;\n\n\tmutex_lock(&priv->lock);\n\tret = nolock_regw_read(priv, address);\n\tmutex_unlock(&priv->lock);\n\n\treturn ret;\n}\n\n \nstatic void nolock_regb_write(struct enc28j60_net *priv, u8 address, u8 data)\n{\n\tenc28j60_set_bank(priv, address);\n\tspi_write_op(priv, ENC28J60_WRITE_CTRL_REG, address, data);\n}\n\nstatic void locked_regb_write(struct enc28j60_net *priv, u8 address, u8 data)\n{\n\tmutex_lock(&priv->lock);\n\tnolock_regb_write(priv, address, data);\n\tmutex_unlock(&priv->lock);\n}\n\n \nstatic void nolock_regw_write(struct enc28j60_net *priv, u8 address, u16 data)\n{\n\tenc28j60_set_bank(priv, address);\n\tspi_write_op(priv, ENC28J60_WRITE_CTRL_REG, address, (u8) data);\n\tspi_write_op(priv, ENC28J60_WRITE_CTRL_REG, address + 1,\n\t\t     (u8) (data >> 8));\n}\n\nstatic void locked_regw_write(struct enc28j60_net *priv, u8 address, u16 data)\n{\n\tmutex_lock(&priv->lock);\n\tnolock_regw_write(priv, address, data);\n\tmutex_unlock(&priv->lock);\n}\n\n \nstatic void enc28j60_mem_read(struct enc28j60_net *priv, u16 addr, int len,\n\t\t\t      u8 *data)\n{\n\tmutex_lock(&priv->lock);\n\tnolock_regw_write(priv, ERDPTL, addr);\n#ifdef CONFIG_ENC28J60_WRITEVERIFY\n\tif (netif_msg_drv(priv)) {\n\t\tstruct device *dev = &priv->spi->dev;\n\t\tu16 reg;\n\n\t\treg = nolock_regw_read(priv, ERDPTL);\n\t\tif (reg != addr)\n\t\t\tdev_printk(KERN_DEBUG, dev,\n\t\t\t\t   \"%s() error writing ERDPT (0x%04x - 0x%04x)\\n\",\n\t\t\t\t   __func__, reg, addr);\n\t}\n#endif\n\tspi_read_buf(priv, len, data);\n\tmutex_unlock(&priv->lock);\n}\n\n \nstatic void\nenc28j60_packet_write(struct enc28j60_net *priv, int len, const u8 *data)\n{\n\tstruct device *dev = &priv->spi->dev;\n\n\tmutex_lock(&priv->lock);\n\t \n\tnolock_regw_write(priv, EWRPTL, TXSTART_INIT);\n#ifdef CONFIG_ENC28J60_WRITEVERIFY\n\tif (netif_msg_drv(priv)) {\n\t\tu16 reg;\n\t\treg = nolock_regw_read(priv, EWRPTL);\n\t\tif (reg != TXSTART_INIT)\n\t\t\tdev_printk(KERN_DEBUG, dev,\n\t\t\t\t   \"%s() ERWPT:0x%04x != 0x%04x\\n\",\n\t\t\t\t   __func__, reg, TXSTART_INIT);\n\t}\n#endif\n\t \n\tnolock_regw_write(priv, ETXNDL, TXSTART_INIT + len);\n\t \n\tspi_write_op(priv, ENC28J60_WRITE_BUF_MEM, 0, 0x00);\n\tif (netif_msg_hw(priv))\n\t\tdev_printk(KERN_DEBUG, dev,\n\t\t\t   \"%s() after control byte ERWPT:0x%04x\\n\",\n\t\t\t   __func__, nolock_regw_read(priv, EWRPTL));\n\t \n\tspi_write_buf(priv, len, data);\n\tif (netif_msg_hw(priv))\n\t\tdev_printk(KERN_DEBUG, dev,\n\t\t\t   \"%s() after write packet ERWPT:0x%04x, len=%d\\n\",\n\t\t\t   __func__, nolock_regw_read(priv, EWRPTL), len);\n\tmutex_unlock(&priv->lock);\n}\n\nstatic int poll_ready(struct enc28j60_net *priv, u8 reg, u8 mask, u8 val)\n{\n\tstruct device *dev = &priv->spi->dev;\n\tunsigned long timeout = jiffies + msecs_to_jiffies(20);\n\n\t \n\twhile ((nolock_regb_read(priv, reg) & mask) != val) {\n\t\tif (time_after(jiffies, timeout)) {\n\t\t\tif (netif_msg_drv(priv))\n\t\t\t\tdev_dbg(dev, \"reg %02x ready timeout!\\n\", reg);\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t\tcpu_relax();\n\t}\n\treturn 0;\n}\n\n \nstatic int wait_phy_ready(struct enc28j60_net *priv)\n{\n\treturn poll_ready(priv, MISTAT, MISTAT_BUSY, 0) ? 0 : 1;\n}\n\n \nstatic u16 enc28j60_phy_read(struct enc28j60_net *priv, u8 address)\n{\n\tu16 ret;\n\n\tmutex_lock(&priv->lock);\n\t \n\tnolock_regb_write(priv, MIREGADR, address);\n\t \n\tnolock_regb_write(priv, MICMD, MICMD_MIIRD);\n\t \n\twait_phy_ready(priv);\n\t \n\tnolock_regb_write(priv, MICMD, 0x00);\n\t \n\tret = nolock_regw_read(priv, MIRDL);\n\tmutex_unlock(&priv->lock);\n\n\treturn ret;\n}\n\nstatic int enc28j60_phy_write(struct enc28j60_net *priv, u8 address, u16 data)\n{\n\tint ret;\n\n\tmutex_lock(&priv->lock);\n\t \n\tnolock_regb_write(priv, MIREGADR, address);\n\t \n\tnolock_regw_write(priv, MIWRL, data);\n\t \n\tret = wait_phy_ready(priv);\n\tmutex_unlock(&priv->lock);\n\n\treturn ret;\n}\n\n \nstatic int enc28j60_set_hw_macaddr(struct net_device *ndev)\n{\n\tint ret;\n\tstruct enc28j60_net *priv = netdev_priv(ndev);\n\tstruct device *dev = &priv->spi->dev;\n\n\tmutex_lock(&priv->lock);\n\tif (!priv->hw_enable) {\n\t\tif (netif_msg_drv(priv))\n\t\t\tdev_info(dev, \"%s: Setting MAC address to %pM\\n\",\n\t\t\t\t ndev->name, ndev->dev_addr);\n\t\t \n\t\tnolock_regb_write(priv, MAADR5, ndev->dev_addr[0]);\n\t\tnolock_regb_write(priv, MAADR4, ndev->dev_addr[1]);\n\t\tnolock_regb_write(priv, MAADR3, ndev->dev_addr[2]);\n\t\tnolock_regb_write(priv, MAADR2, ndev->dev_addr[3]);\n\t\tnolock_regb_write(priv, MAADR1, ndev->dev_addr[4]);\n\t\tnolock_regb_write(priv, MAADR0, ndev->dev_addr[5]);\n\t\tret = 0;\n\t} else {\n\t\tif (netif_msg_drv(priv))\n\t\t\tdev_printk(KERN_DEBUG, dev,\n\t\t\t\t   \"%s() Hardware must be disabled to set Mac address\\n\",\n\t\t\t\t   __func__);\n\t\tret = -EBUSY;\n\t}\n\tmutex_unlock(&priv->lock);\n\treturn ret;\n}\n\n \nstatic int enc28j60_set_mac_address(struct net_device *dev, void *addr)\n{\n\tstruct sockaddr *address = addr;\n\n\tif (netif_running(dev))\n\t\treturn -EBUSY;\n\tif (!is_valid_ether_addr(address->sa_data))\n\t\treturn -EADDRNOTAVAIL;\n\n\teth_hw_addr_set(dev, address->sa_data);\n\treturn enc28j60_set_hw_macaddr(dev);\n}\n\n \nstatic void enc28j60_dump_regs(struct enc28j60_net *priv, const char *msg)\n{\n\tstruct device *dev = &priv->spi->dev;\n\n\tmutex_lock(&priv->lock);\n\tdev_printk(KERN_DEBUG, dev,\n\t\t   \" %s\\n\"\n\t\t   \"HwRevID: 0x%02x\\n\"\n\t\t   \"Cntrl: ECON1 ECON2 ESTAT  EIR  EIE\\n\"\n\t\t   \"       0x%02x  0x%02x  0x%02x  0x%02x  0x%02x\\n\"\n\t\t   \"MAC  : MACON1 MACON3 MACON4\\n\"\n\t\t   \"       0x%02x   0x%02x   0x%02x\\n\"\n\t\t   \"Rx   : ERXST  ERXND  ERXWRPT ERXRDPT ERXFCON EPKTCNT MAMXFL\\n\"\n\t\t   \"       0x%04x 0x%04x 0x%04x  0x%04x  \"\n\t\t   \"0x%02x    0x%02x    0x%04x\\n\"\n\t\t   \"Tx   : ETXST  ETXND  MACLCON1 MACLCON2 MAPHSUP\\n\"\n\t\t   \"       0x%04x 0x%04x 0x%02x     0x%02x     0x%02x\\n\",\n\t\t   msg, nolock_regb_read(priv, EREVID),\n\t\t   nolock_regb_read(priv, ECON1), nolock_regb_read(priv, ECON2),\n\t\t   nolock_regb_read(priv, ESTAT), nolock_regb_read(priv, EIR),\n\t\t   nolock_regb_read(priv, EIE), nolock_regb_read(priv, MACON1),\n\t\t   nolock_regb_read(priv, MACON3), nolock_regb_read(priv, MACON4),\n\t\t   nolock_regw_read(priv, ERXSTL), nolock_regw_read(priv, ERXNDL),\n\t\t   nolock_regw_read(priv, ERXWRPTL),\n\t\t   nolock_regw_read(priv, ERXRDPTL),\n\t\t   nolock_regb_read(priv, ERXFCON),\n\t\t   nolock_regb_read(priv, EPKTCNT),\n\t\t   nolock_regw_read(priv, MAMXFLL), nolock_regw_read(priv, ETXSTL),\n\t\t   nolock_regw_read(priv, ETXNDL),\n\t\t   nolock_regb_read(priv, MACLCON1),\n\t\t   nolock_regb_read(priv, MACLCON2),\n\t\t   nolock_regb_read(priv, MAPHSUP));\n\tmutex_unlock(&priv->lock);\n}\n\n \nstatic u16 erxrdpt_workaround(u16 next_packet_ptr, u16 start, u16 end)\n{\n\tu16 erxrdpt;\n\n\tif ((next_packet_ptr - 1 < start) || (next_packet_ptr - 1 > end))\n\t\terxrdpt = end;\n\telse\n\t\terxrdpt = next_packet_ptr - 1;\n\n\treturn erxrdpt;\n}\n\n \nstatic u16 rx_packet_start(u16 ptr)\n{\n\tif (ptr + RSV_SIZE > RXEND_INIT)\n\t\treturn (ptr + RSV_SIZE) - (RXEND_INIT - RXSTART_INIT + 1);\n\telse\n\t\treturn ptr + RSV_SIZE;\n}\n\nstatic void nolock_rxfifo_init(struct enc28j60_net *priv, u16 start, u16 end)\n{\n\tstruct device *dev = &priv->spi->dev;\n\tu16 erxrdpt;\n\n\tif (start > 0x1FFF || end > 0x1FFF || start > end) {\n\t\tif (netif_msg_drv(priv))\n\t\t\tdev_err(dev, \"%s(%d, %d) RXFIFO bad parameters!\\n\",\n\t\t\t\t__func__, start, end);\n\t\treturn;\n\t}\n\t \n\tpriv->next_pk_ptr = start;\n\tnolock_regw_write(priv, ERXSTL, start);\n\terxrdpt = erxrdpt_workaround(priv->next_pk_ptr, start, end);\n\tnolock_regw_write(priv, ERXRDPTL, erxrdpt);\n\tnolock_regw_write(priv, ERXNDL, end);\n}\n\nstatic void nolock_txfifo_init(struct enc28j60_net *priv, u16 start, u16 end)\n{\n\tstruct device *dev = &priv->spi->dev;\n\n\tif (start > 0x1FFF || end > 0x1FFF || start > end) {\n\t\tif (netif_msg_drv(priv))\n\t\t\tdev_err(dev, \"%s(%d, %d) TXFIFO bad parameters!\\n\",\n\t\t\t\t__func__, start, end);\n\t\treturn;\n\t}\n\t \n\tnolock_regw_write(priv, ETXSTL, start);\n\tnolock_regw_write(priv, ETXNDL, end);\n}\n\n \nstatic void enc28j60_lowpower(struct enc28j60_net *priv, bool is_low)\n{\n\tstruct device *dev = &priv->spi->dev;\n\n\tif (netif_msg_drv(priv))\n\t\tdev_dbg(dev, \"%s power...\\n\", is_low ? \"low\" : \"high\");\n\n\tmutex_lock(&priv->lock);\n\tif (is_low) {\n\t\tnolock_reg_bfclr(priv, ECON1, ECON1_RXEN);\n\t\tpoll_ready(priv, ESTAT, ESTAT_RXBUSY, 0);\n\t\tpoll_ready(priv, ECON1, ECON1_TXRTS, 0);\n\t\t \n\t\tnolock_reg_bfset(priv, ECON2, ECON2_PWRSV);\n\t} else {\n\t\tnolock_reg_bfclr(priv, ECON2, ECON2_PWRSV);\n\t\tpoll_ready(priv, ESTAT, ESTAT_CLKRDY, ESTAT_CLKRDY);\n\t\t \n\t}\n\tmutex_unlock(&priv->lock);\n}\n\nstatic int enc28j60_hw_init(struct enc28j60_net *priv)\n{\n\tstruct device *dev = &priv->spi->dev;\n\tu8 reg;\n\n\tif (netif_msg_drv(priv))\n\t\tdev_printk(KERN_DEBUG, dev, \"%s() - %s\\n\", __func__,\n\t\t\t   priv->full_duplex ? \"FullDuplex\" : \"HalfDuplex\");\n\n\tmutex_lock(&priv->lock);\n\t \n\tenc28j60_soft_reset(priv);\n\t \n\tspi_write_op(priv, ENC28J60_WRITE_CTRL_REG, ECON1, 0x00);\n\tpriv->bank = 0;\n\tpriv->hw_enable = false;\n\tpriv->tx_retry_count = 0;\n\tpriv->max_pk_counter = 0;\n\tpriv->rxfilter = RXFILTER_NORMAL;\n\t \n\tnolock_regb_write(priv, ECON2, ECON2_AUTOINC | ECON2_VRPS);\n\n\tnolock_rxfifo_init(priv, RXSTART_INIT, RXEND_INIT);\n\tnolock_txfifo_init(priv, TXSTART_INIT, TXEND_INIT);\n\tmutex_unlock(&priv->lock);\n\n\t \n\treg = locked_regb_read(priv, EREVID);\n\tif (netif_msg_drv(priv))\n\t\tdev_info(dev, \"chip RevID: 0x%02x\\n\", reg);\n\tif (reg == 0x00 || reg == 0xff) {\n\t\tif (netif_msg_drv(priv))\n\t\t\tdev_printk(KERN_DEBUG, dev, \"%s() Invalid RevId %d\\n\",\n\t\t\t\t   __func__, reg);\n\t\treturn 0;\n\t}\n\n\t \n\tlocked_regb_write(priv, ERXFCON,\n\t\t\t    ERXFCON_UCEN | ERXFCON_CRCEN | ERXFCON_BCEN);\n\n\t \n\tlocked_regb_write(priv, MACON1,\n\t\t\t    MACON1_MARXEN | MACON1_TXPAUS | MACON1_RXPAUS);\n\t \n\tif (priv->full_duplex) {\n\t\tlocked_regb_write(priv, MACON3,\n\t\t\t\t    MACON3_PADCFG0 | MACON3_TXCRCEN |\n\t\t\t\t    MACON3_FRMLNEN | MACON3_FULDPX);\n\t\t \n\t\tlocked_regb_write(priv, MAIPGL, 0x12);\n\t\t \n\t\tlocked_regb_write(priv, MABBIPG, 0x15);\n\t} else {\n\t\tlocked_regb_write(priv, MACON3,\n\t\t\t\t    MACON3_PADCFG0 | MACON3_TXCRCEN |\n\t\t\t\t    MACON3_FRMLNEN);\n\t\tlocked_regb_write(priv, MACON4, 1 << 6);\t \n\t\t \n\t\tlocked_regw_write(priv, MAIPGL, 0x0C12);\n\t\t \n\t\tlocked_regb_write(priv, MABBIPG, 0x12);\n\t}\n\t \n\tlocked_regw_write(priv, MAMXFLL, MAX_FRAMELEN);\n\n\t \n\tif (!enc28j60_phy_write(priv, PHLCON, ENC28J60_LAMPS_MODE))\n\t\treturn 0;\n\n\tif (priv->full_duplex) {\n\t\tif (!enc28j60_phy_write(priv, PHCON1, PHCON1_PDPXMD))\n\t\t\treturn 0;\n\t\tif (!enc28j60_phy_write(priv, PHCON2, 0x00))\n\t\t\treturn 0;\n\t} else {\n\t\tif (!enc28j60_phy_write(priv, PHCON1, 0x00))\n\t\t\treturn 0;\n\t\tif (!enc28j60_phy_write(priv, PHCON2, PHCON2_HDLDIS))\n\t\t\treturn 0;\n\t}\n\tif (netif_msg_hw(priv))\n\t\tenc28j60_dump_regs(priv, \"Hw initialized.\");\n\n\treturn 1;\n}\n\nstatic void enc28j60_hw_enable(struct enc28j60_net *priv)\n{\n\tstruct device *dev = &priv->spi->dev;\n\n\t \n\tif (netif_msg_hw(priv))\n\t\tdev_printk(KERN_DEBUG, dev, \"%s() enabling interrupts.\\n\",\n\t\t\t   __func__);\n\n\tenc28j60_phy_write(priv, PHIE, PHIE_PGEIE | PHIE_PLNKIE);\n\n\tmutex_lock(&priv->lock);\n\tnolock_reg_bfclr(priv, EIR, EIR_DMAIF | EIR_LINKIF |\n\t\t\t EIR_TXIF | EIR_TXERIF | EIR_RXERIF | EIR_PKTIF);\n\tnolock_regb_write(priv, EIE, EIE_INTIE | EIE_PKTIE | EIE_LINKIE |\n\t\t\t  EIE_TXIE | EIE_TXERIE | EIE_RXERIE);\n\n\t \n\tnolock_reg_bfset(priv, ECON1, ECON1_RXEN);\n\tpriv->hw_enable = true;\n\tmutex_unlock(&priv->lock);\n}\n\nstatic void enc28j60_hw_disable(struct enc28j60_net *priv)\n{\n\tmutex_lock(&priv->lock);\n\t \n\tnolock_regb_write(priv, EIE, 0x00);\n\tnolock_reg_bfclr(priv, ECON1, ECON1_RXEN);\n\tpriv->hw_enable = false;\n\tmutex_unlock(&priv->lock);\n}\n\nstatic int\nenc28j60_setlink(struct net_device *ndev, u8 autoneg, u16 speed, u8 duplex)\n{\n\tstruct enc28j60_net *priv = netdev_priv(ndev);\n\tint ret = 0;\n\n\tif (!priv->hw_enable) {\n\t\t \n\t\tif (autoneg == AUTONEG_DISABLE && speed == SPEED_10)\n\t\t\tpriv->full_duplex = (duplex == DUPLEX_FULL);\n\t\telse {\n\t\t\tif (netif_msg_link(priv))\n\t\t\t\tnetdev_warn(ndev, \"unsupported link setting\\n\");\n\t\t\tret = -EOPNOTSUPP;\n\t\t}\n\t} else {\n\t\tif (netif_msg_link(priv))\n\t\t\tnetdev_warn(ndev, \"Warning: hw must be disabled to set link mode\\n\");\n\t\tret = -EBUSY;\n\t}\n\treturn ret;\n}\n\n \nstatic void enc28j60_read_tsv(struct enc28j60_net *priv, u8 tsv[TSV_SIZE])\n{\n\tstruct device *dev = &priv->spi->dev;\n\tint endptr;\n\n\tendptr = locked_regw_read(priv, ETXNDL);\n\tif (netif_msg_hw(priv))\n\t\tdev_printk(KERN_DEBUG, dev, \"reading TSV at addr:0x%04x\\n\",\n\t\t\t   endptr + 1);\n\tenc28j60_mem_read(priv, endptr + 1, TSV_SIZE, tsv);\n}\n\nstatic void enc28j60_dump_tsv(struct enc28j60_net *priv, const char *msg,\n\t\t\t      u8 tsv[TSV_SIZE])\n{\n\tstruct device *dev = &priv->spi->dev;\n\tu16 tmp1, tmp2;\n\n\tdev_printk(KERN_DEBUG, dev, \"%s - TSV:\\n\", msg);\n\ttmp1 = tsv[1];\n\ttmp1 <<= 8;\n\ttmp1 |= tsv[0];\n\n\ttmp2 = tsv[5];\n\ttmp2 <<= 8;\n\ttmp2 |= tsv[4];\n\n\tdev_printk(KERN_DEBUG, dev,\n\t\t   \"ByteCount: %d, CollisionCount: %d, TotByteOnWire: %d\\n\",\n\t\t   tmp1, tsv[2] & 0x0f, tmp2);\n\tdev_printk(KERN_DEBUG, dev,\n\t\t   \"TxDone: %d, CRCErr:%d, LenChkErr: %d, LenOutOfRange: %d\\n\",\n\t\t   TSV_GETBIT(tsv, TSV_TXDONE),\n\t\t   TSV_GETBIT(tsv, TSV_TXCRCERROR),\n\t\t   TSV_GETBIT(tsv, TSV_TXLENCHKERROR),\n\t\t   TSV_GETBIT(tsv, TSV_TXLENOUTOFRANGE));\n\tdev_printk(KERN_DEBUG, dev,\n\t\t   \"Multicast: %d, Broadcast: %d, PacketDefer: %d, ExDefer: %d\\n\",\n\t\t   TSV_GETBIT(tsv, TSV_TXMULTICAST),\n\t\t   TSV_GETBIT(tsv, TSV_TXBROADCAST),\n\t\t   TSV_GETBIT(tsv, TSV_TXPACKETDEFER),\n\t\t   TSV_GETBIT(tsv, TSV_TXEXDEFER));\n\tdev_printk(KERN_DEBUG, dev,\n\t\t   \"ExCollision: %d, LateCollision: %d, Giant: %d, Underrun: %d\\n\",\n\t\t   TSV_GETBIT(tsv, TSV_TXEXCOLLISION),\n\t\t   TSV_GETBIT(tsv, TSV_TXLATECOLLISION),\n\t\t   TSV_GETBIT(tsv, TSV_TXGIANT), TSV_GETBIT(tsv, TSV_TXUNDERRUN));\n\tdev_printk(KERN_DEBUG, dev,\n\t\t   \"ControlFrame: %d, PauseFrame: %d, BackPressApp: %d, VLanTagFrame: %d\\n\",\n\t\t   TSV_GETBIT(tsv, TSV_TXCONTROLFRAME),\n\t\t   TSV_GETBIT(tsv, TSV_TXPAUSEFRAME),\n\t\t   TSV_GETBIT(tsv, TSV_BACKPRESSUREAPP),\n\t\t   TSV_GETBIT(tsv, TSV_TXVLANTAGFRAME));\n}\n\n \nstatic void enc28j60_dump_rsv(struct enc28j60_net *priv, const char *msg,\n\t\t\t      u16 pk_ptr, int len, u16 sts)\n{\n\tstruct device *dev = &priv->spi->dev;\n\n\tdev_printk(KERN_DEBUG, dev, \"%s - NextPk: 0x%04x - RSV:\\n\", msg, pk_ptr);\n\tdev_printk(KERN_DEBUG, dev, \"ByteCount: %d, DribbleNibble: %d\\n\",\n\t\t   len, RSV_GETBIT(sts, RSV_DRIBBLENIBBLE));\n\tdev_printk(KERN_DEBUG, dev,\n\t\t   \"RxOK: %d, CRCErr:%d, LenChkErr: %d, LenOutOfRange: %d\\n\",\n\t\t   RSV_GETBIT(sts, RSV_RXOK),\n\t\t   RSV_GETBIT(sts, RSV_CRCERROR),\n\t\t   RSV_GETBIT(sts, RSV_LENCHECKERR),\n\t\t   RSV_GETBIT(sts, RSV_LENOUTOFRANGE));\n\tdev_printk(KERN_DEBUG, dev,\n\t\t   \"Multicast: %d, Broadcast: %d, LongDropEvent: %d, CarrierEvent: %d\\n\",\n\t\t   RSV_GETBIT(sts, RSV_RXMULTICAST),\n\t\t   RSV_GETBIT(sts, RSV_RXBROADCAST),\n\t\t   RSV_GETBIT(sts, RSV_RXLONGEVDROPEV),\n\t\t   RSV_GETBIT(sts, RSV_CARRIEREV));\n\tdev_printk(KERN_DEBUG, dev,\n\t\t   \"ControlFrame: %d, PauseFrame: %d, UnknownOp: %d, VLanTagFrame: %d\\n\",\n\t\t   RSV_GETBIT(sts, RSV_RXCONTROLFRAME),\n\t\t   RSV_GETBIT(sts, RSV_RXPAUSEFRAME),\n\t\t   RSV_GETBIT(sts, RSV_RXUNKNOWNOPCODE),\n\t\t   RSV_GETBIT(sts, RSV_RXTYPEVLAN));\n}\n\nstatic void dump_packet(const char *msg, int len, const char *data)\n{\n\tprintk(KERN_DEBUG DRV_NAME \": %s - packet len:%d\\n\", msg, len);\n\tprint_hex_dump(KERN_DEBUG, \"pk data: \", DUMP_PREFIX_OFFSET, 16, 1,\n\t\t\tdata, len, true);\n}\n\n \nstatic void enc28j60_hw_rx(struct net_device *ndev)\n{\n\tstruct enc28j60_net *priv = netdev_priv(ndev);\n\tstruct device *dev = &priv->spi->dev;\n\tstruct sk_buff *skb = NULL;\n\tu16 erxrdpt, next_packet, rxstat;\n\tu8 rsv[RSV_SIZE];\n\tint len;\n\n\tif (netif_msg_rx_status(priv))\n\t\tnetdev_printk(KERN_DEBUG, ndev, \"RX pk_addr:0x%04x\\n\",\n\t\t\t      priv->next_pk_ptr);\n\n\tif (unlikely(priv->next_pk_ptr > RXEND_INIT)) {\n\t\tif (netif_msg_rx_err(priv))\n\t\t\tnetdev_err(ndev, \"%s() Invalid packet address!! 0x%04x\\n\",\n\t\t\t\t   __func__, priv->next_pk_ptr);\n\t\t \n\t\tmutex_lock(&priv->lock);\n\t\tnolock_reg_bfclr(priv, ECON1, ECON1_RXEN);\n\t\tnolock_reg_bfset(priv, ECON1, ECON1_RXRST);\n\t\tnolock_reg_bfclr(priv, ECON1, ECON1_RXRST);\n\t\tnolock_rxfifo_init(priv, RXSTART_INIT, RXEND_INIT);\n\t\tnolock_reg_bfclr(priv, EIR, EIR_RXERIF);\n\t\tnolock_reg_bfset(priv, ECON1, ECON1_RXEN);\n\t\tmutex_unlock(&priv->lock);\n\t\tndev->stats.rx_errors++;\n\t\treturn;\n\t}\n\t \n\tenc28j60_mem_read(priv, priv->next_pk_ptr, sizeof(rsv), rsv);\n\n\tnext_packet = rsv[1];\n\tnext_packet <<= 8;\n\tnext_packet |= rsv[0];\n\n\tlen = rsv[3];\n\tlen <<= 8;\n\tlen |= rsv[2];\n\n\trxstat = rsv[5];\n\trxstat <<= 8;\n\trxstat |= rsv[4];\n\n\tif (netif_msg_rx_status(priv))\n\t\tenc28j60_dump_rsv(priv, __func__, next_packet, len, rxstat);\n\n\tif (!RSV_GETBIT(rxstat, RSV_RXOK) || len > MAX_FRAMELEN) {\n\t\tif (netif_msg_rx_err(priv))\n\t\t\tnetdev_err(ndev, \"Rx Error (%04x)\\n\", rxstat);\n\t\tndev->stats.rx_errors++;\n\t\tif (RSV_GETBIT(rxstat, RSV_CRCERROR))\n\t\t\tndev->stats.rx_crc_errors++;\n\t\tif (RSV_GETBIT(rxstat, RSV_LENCHECKERR))\n\t\t\tndev->stats.rx_frame_errors++;\n\t\tif (len > MAX_FRAMELEN)\n\t\t\tndev->stats.rx_over_errors++;\n\t} else {\n\t\tskb = netdev_alloc_skb(ndev, len + NET_IP_ALIGN);\n\t\tif (!skb) {\n\t\t\tif (netif_msg_rx_err(priv))\n\t\t\t\tnetdev_err(ndev, \"out of memory for Rx'd frame\\n\");\n\t\t\tndev->stats.rx_dropped++;\n\t\t} else {\n\t\t\tskb_reserve(skb, NET_IP_ALIGN);\n\t\t\t \n\t\t\tenc28j60_mem_read(priv,\n\t\t\t\trx_packet_start(priv->next_pk_ptr),\n\t\t\t\tlen, skb_put(skb, len));\n\t\t\tif (netif_msg_pktdata(priv))\n\t\t\t\tdump_packet(__func__, skb->len, skb->data);\n\t\t\tskb->protocol = eth_type_trans(skb, ndev);\n\t\t\t \n\t\t\tndev->stats.rx_packets++;\n\t\t\tndev->stats.rx_bytes += len;\n\t\t\tnetif_rx(skb);\n\t\t}\n\t}\n\t \n\terxrdpt = erxrdpt_workaround(next_packet, RXSTART_INIT, RXEND_INIT);\n\tif (netif_msg_hw(priv))\n\t\tdev_printk(KERN_DEBUG, dev, \"%s() ERXRDPT:0x%04x\\n\",\n\t\t\t   __func__, erxrdpt);\n\n\tmutex_lock(&priv->lock);\n\tnolock_regw_write(priv, ERXRDPTL, erxrdpt);\n#ifdef CONFIG_ENC28J60_WRITEVERIFY\n\tif (netif_msg_drv(priv)) {\n\t\tu16 reg;\n\t\treg = nolock_regw_read(priv, ERXRDPTL);\n\t\tif (reg != erxrdpt)\n\t\t\tdev_printk(KERN_DEBUG, dev,\n\t\t\t\t   \"%s() ERXRDPT verify error (0x%04x - 0x%04x)\\n\",\n\t\t\t\t   __func__, reg, erxrdpt);\n\t}\n#endif\n\tpriv->next_pk_ptr = next_packet;\n\t \n\tnolock_reg_bfset(priv, ECON2, ECON2_PKTDEC);\n\tmutex_unlock(&priv->lock);\n}\n\n \nstatic int enc28j60_get_free_rxfifo(struct enc28j60_net *priv)\n{\n\tstruct net_device *ndev = priv->netdev;\n\tint epkcnt, erxst, erxnd, erxwr, erxrd;\n\tint free_space;\n\n\tmutex_lock(&priv->lock);\n\tepkcnt = nolock_regb_read(priv, EPKTCNT);\n\tif (epkcnt >= 255)\n\t\tfree_space = -1;\n\telse {\n\t\terxst = nolock_regw_read(priv, ERXSTL);\n\t\terxnd = nolock_regw_read(priv, ERXNDL);\n\t\terxwr = nolock_regw_read(priv, ERXWRPTL);\n\t\terxrd = nolock_regw_read(priv, ERXRDPTL);\n\n\t\tif (erxwr > erxrd)\n\t\t\tfree_space = (erxnd - erxst) - (erxwr - erxrd);\n\t\telse if (erxwr == erxrd)\n\t\t\tfree_space = (erxnd - erxst);\n\t\telse\n\t\t\tfree_space = erxrd - erxwr - 1;\n\t}\n\tmutex_unlock(&priv->lock);\n\tif (netif_msg_rx_status(priv))\n\t\tnetdev_printk(KERN_DEBUG, ndev, \"%s() free_space = %d\\n\",\n\t\t\t      __func__, free_space);\n\treturn free_space;\n}\n\n \nstatic void enc28j60_check_link_status(struct net_device *ndev)\n{\n\tstruct enc28j60_net *priv = netdev_priv(ndev);\n\tstruct device *dev = &priv->spi->dev;\n\tu16 reg;\n\tint duplex;\n\n\treg = enc28j60_phy_read(priv, PHSTAT2);\n\tif (netif_msg_hw(priv))\n\t\tdev_printk(KERN_DEBUG, dev,\n\t\t\t   \"%s() PHSTAT1: %04x, PHSTAT2: %04x\\n\", __func__,\n\t\t\t   enc28j60_phy_read(priv, PHSTAT1), reg);\n\tduplex = reg & PHSTAT2_DPXSTAT;\n\n\tif (reg & PHSTAT2_LSTAT) {\n\t\tnetif_carrier_on(ndev);\n\t\tif (netif_msg_ifup(priv))\n\t\t\tnetdev_info(ndev, \"link up - %s\\n\",\n\t\t\t\t    duplex ? \"Full duplex\" : \"Half duplex\");\n\t} else {\n\t\tif (netif_msg_ifdown(priv))\n\t\t\tnetdev_info(ndev, \"link down\\n\");\n\t\tnetif_carrier_off(ndev);\n\t}\n}\n\nstatic void enc28j60_tx_clear(struct net_device *ndev, bool err)\n{\n\tstruct enc28j60_net *priv = netdev_priv(ndev);\n\n\tif (err)\n\t\tndev->stats.tx_errors++;\n\telse\n\t\tndev->stats.tx_packets++;\n\n\tif (priv->tx_skb) {\n\t\tif (!err)\n\t\t\tndev->stats.tx_bytes += priv->tx_skb->len;\n\t\tdev_kfree_skb(priv->tx_skb);\n\t\tpriv->tx_skb = NULL;\n\t}\n\tlocked_reg_bfclr(priv, ECON1, ECON1_TXRTS);\n\tnetif_wake_queue(ndev);\n}\n\n \nstatic int enc28j60_rx_interrupt(struct net_device *ndev)\n{\n\tstruct enc28j60_net *priv = netdev_priv(ndev);\n\tint pk_counter, ret;\n\n\tpk_counter = locked_regb_read(priv, EPKTCNT);\n\tif (pk_counter && netif_msg_intr(priv))\n\t\tnetdev_printk(KERN_DEBUG, ndev, \"intRX, pk_cnt: %d\\n\",\n\t\t\t      pk_counter);\n\tif (pk_counter > priv->max_pk_counter) {\n\t\t \n\t\tpriv->max_pk_counter = pk_counter;\n\t\tif (netif_msg_rx_status(priv) && priv->max_pk_counter > 1)\n\t\t\tnetdev_printk(KERN_DEBUG, ndev, \"RX max_pk_cnt: %d\\n\",\n\t\t\t\t      priv->max_pk_counter);\n\t}\n\tret = pk_counter;\n\twhile (pk_counter-- > 0)\n\t\tenc28j60_hw_rx(ndev);\n\n\treturn ret;\n}\n\nstatic irqreturn_t enc28j60_irq(int irq, void *dev_id)\n{\n\tstruct enc28j60_net *priv = dev_id;\n\tstruct net_device *ndev = priv->netdev;\n\tint intflags, loop;\n\n\t \n\tlocked_reg_bfclr(priv, EIE, EIE_INTIE);\n\n\tdo {\n\t\tloop = 0;\n\t\tintflags = locked_regb_read(priv, EIR);\n\t\t \n\t\tif ((intflags & EIR_DMAIF) != 0) {\n\t\t\tloop++;\n\t\t\tif (netif_msg_intr(priv))\n\t\t\t\tnetdev_printk(KERN_DEBUG, ndev, \"intDMA(%d)\\n\",\n\t\t\t\t\t      loop);\n\t\t\tlocked_reg_bfclr(priv, EIR, EIR_DMAIF);\n\t\t}\n\t\t \n\t\tif ((intflags & EIR_LINKIF) != 0) {\n\t\t\tloop++;\n\t\t\tif (netif_msg_intr(priv))\n\t\t\t\tnetdev_printk(KERN_DEBUG, ndev, \"intLINK(%d)\\n\",\n\t\t\t\t\t      loop);\n\t\t\tenc28j60_check_link_status(ndev);\n\t\t\t \n\t\t\tenc28j60_phy_read(priv, PHIR);\n\t\t}\n\t\t \n\t\tif (((intflags & EIR_TXIF) != 0) &&\n\t\t    ((intflags & EIR_TXERIF) == 0)) {\n\t\t\tbool err = false;\n\t\t\tloop++;\n\t\t\tif (netif_msg_intr(priv))\n\t\t\t\tnetdev_printk(KERN_DEBUG, ndev, \"intTX(%d)\\n\",\n\t\t\t\t\t      loop);\n\t\t\tpriv->tx_retry_count = 0;\n\t\t\tif (locked_regb_read(priv, ESTAT) & ESTAT_TXABRT) {\n\t\t\t\tif (netif_msg_tx_err(priv))\n\t\t\t\t\tnetdev_err(ndev, \"Tx Error (aborted)\\n\");\n\t\t\t\terr = true;\n\t\t\t}\n\t\t\tif (netif_msg_tx_done(priv)) {\n\t\t\t\tu8 tsv[TSV_SIZE];\n\t\t\t\tenc28j60_read_tsv(priv, tsv);\n\t\t\t\tenc28j60_dump_tsv(priv, \"Tx Done\", tsv);\n\t\t\t}\n\t\t\tenc28j60_tx_clear(ndev, err);\n\t\t\tlocked_reg_bfclr(priv, EIR, EIR_TXIF);\n\t\t}\n\t\t \n\t\tif ((intflags & EIR_TXERIF) != 0) {\n\t\t\tu8 tsv[TSV_SIZE];\n\n\t\t\tloop++;\n\t\t\tif (netif_msg_intr(priv))\n\t\t\t\tnetdev_printk(KERN_DEBUG, ndev, \"intTXErr(%d)\\n\",\n\t\t\t\t\t      loop);\n\t\t\tlocked_reg_bfclr(priv, ECON1, ECON1_TXRTS);\n\t\t\tenc28j60_read_tsv(priv, tsv);\n\t\t\tif (netif_msg_tx_err(priv))\n\t\t\t\tenc28j60_dump_tsv(priv, \"Tx Error\", tsv);\n\t\t\t \n\t\t\tmutex_lock(&priv->lock);\n\t\t\tnolock_reg_bfset(priv, ECON1, ECON1_TXRST);\n\t\t\tnolock_reg_bfclr(priv, ECON1, ECON1_TXRST);\n\t\t\tnolock_txfifo_init(priv, TXSTART_INIT, TXEND_INIT);\n\t\t\tmutex_unlock(&priv->lock);\n\t\t\t \n\t\t\tif (TSV_GETBIT(tsv, TSV_TXLATECOLLISION)) {\n\t\t\t\tif (netif_msg_tx_err(priv))\n\t\t\t\t\tnetdev_printk(KERN_DEBUG, ndev,\n\t\t\t\t\t\t      \"LateCollision TXErr (%d)\\n\",\n\t\t\t\t\t\t      priv->tx_retry_count);\n\t\t\t\tif (priv->tx_retry_count++ < MAX_TX_RETRYCOUNT)\n\t\t\t\t\tlocked_reg_bfset(priv, ECON1,\n\t\t\t\t\t\t\t   ECON1_TXRTS);\n\t\t\t\telse\n\t\t\t\t\tenc28j60_tx_clear(ndev, true);\n\t\t\t} else\n\t\t\t\tenc28j60_tx_clear(ndev, true);\n\t\t\tlocked_reg_bfclr(priv, EIR, EIR_TXERIF | EIR_TXIF);\n\t\t}\n\t\t \n\t\tif ((intflags & EIR_RXERIF) != 0) {\n\t\t\tloop++;\n\t\t\tif (netif_msg_intr(priv))\n\t\t\t\tnetdev_printk(KERN_DEBUG, ndev, \"intRXErr(%d)\\n\",\n\t\t\t\t\t      loop);\n\t\t\t \n\t\t\tif (enc28j60_get_free_rxfifo(priv) <= 0) {\n\t\t\t\tif (netif_msg_rx_err(priv))\n\t\t\t\t\tnetdev_printk(KERN_DEBUG, ndev, \"RX Overrun\\n\");\n\t\t\t\tndev->stats.rx_dropped++;\n\t\t\t}\n\t\t\tlocked_reg_bfclr(priv, EIR, EIR_RXERIF);\n\t\t}\n\t\t \n\t\tif (enc28j60_rx_interrupt(ndev))\n\t\t\tloop++;\n\t} while (loop);\n\n\t \n\tlocked_reg_bfset(priv, EIE, EIE_INTIE);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic void enc28j60_hw_tx(struct enc28j60_net *priv)\n{\n\tstruct net_device *ndev = priv->netdev;\n\n\tBUG_ON(!priv->tx_skb);\n\n\tif (netif_msg_tx_queued(priv))\n\t\tnetdev_printk(KERN_DEBUG, ndev, \"Tx Packet Len:%d\\n\",\n\t\t\t      priv->tx_skb->len);\n\n\tif (netif_msg_pktdata(priv))\n\t\tdump_packet(__func__,\n\t\t\t    priv->tx_skb->len, priv->tx_skb->data);\n\tenc28j60_packet_write(priv, priv->tx_skb->len, priv->tx_skb->data);\n\n#ifdef CONFIG_ENC28J60_WRITEVERIFY\n\t \n\tif (netif_msg_drv(priv)) {\n\t\tstruct device *dev = &priv->spi->dev;\n\t\tint test_len, k;\n\t\tu8 test_buf[64];  \n\t\tint okflag;\n\n\t\ttest_len = priv->tx_skb->len;\n\t\tif (test_len > sizeof(test_buf))\n\t\t\ttest_len = sizeof(test_buf);\n\n\t\t \n\t\tenc28j60_mem_read(priv, TXSTART_INIT + 1, test_len, test_buf);\n\t\tokflag = 1;\n\t\tfor (k = 0; k < test_len; k++) {\n\t\t\tif (priv->tx_skb->data[k] != test_buf[k]) {\n\t\t\t\tdev_printk(KERN_DEBUG, dev,\n\t\t\t\t\t   \"Error, %d location differ: 0x%02x-0x%02x\\n\",\n\t\t\t\t\t   k, priv->tx_skb->data[k], test_buf[k]);\n\t\t\t\tokflag = 0;\n\t\t\t}\n\t\t}\n\t\tif (!okflag)\n\t\t\tdev_printk(KERN_DEBUG, dev, \"Tx write buffer, verify ERROR!\\n\");\n\t}\n#endif\n\t \n\tlocked_reg_bfset(priv, ECON1, ECON1_TXRTS);\n}\n\nstatic netdev_tx_t enc28j60_send_packet(struct sk_buff *skb,\n\t\t\t\t\tstruct net_device *dev)\n{\n\tstruct enc28j60_net *priv = netdev_priv(dev);\n\n\t \n\tnetif_stop_queue(dev);\n\n\t \n\tpriv->tx_skb = skb;\n\tschedule_work(&priv->tx_work);\n\n\treturn NETDEV_TX_OK;\n}\n\nstatic void enc28j60_tx_work_handler(struct work_struct *work)\n{\n\tstruct enc28j60_net *priv =\n\t\tcontainer_of(work, struct enc28j60_net, tx_work);\n\n\t \n\tenc28j60_hw_tx(priv);\n}\n\nstatic void enc28j60_tx_timeout(struct net_device *ndev, unsigned int txqueue)\n{\n\tstruct enc28j60_net *priv = netdev_priv(ndev);\n\n\tif (netif_msg_timer(priv))\n\t\tnetdev_err(ndev, \"tx timeout\\n\");\n\n\tndev->stats.tx_errors++;\n\t \n\tschedule_work(&priv->restart_work);\n}\n\n \nstatic int enc28j60_net_open(struct net_device *dev)\n{\n\tstruct enc28j60_net *priv = netdev_priv(dev);\n\n\tif (!is_valid_ether_addr(dev->dev_addr)) {\n\t\tif (netif_msg_ifup(priv))\n\t\t\tnetdev_err(dev, \"invalid MAC address %pM\\n\", dev->dev_addr);\n\t\treturn -EADDRNOTAVAIL;\n\t}\n\t \n\tenc28j60_lowpower(priv, false);\n\tenc28j60_hw_disable(priv);\n\tif (!enc28j60_hw_init(priv)) {\n\t\tif (netif_msg_ifup(priv))\n\t\t\tnetdev_err(dev, \"hw_reset() failed\\n\");\n\t\treturn -EINVAL;\n\t}\n\t \n\tenc28j60_set_hw_macaddr(dev);\n\t \n\tenc28j60_hw_enable(priv);\n\t \n\tenc28j60_check_link_status(dev);\n\t \n\tnetif_start_queue(dev);\n\n\treturn 0;\n}\n\n \nstatic int enc28j60_net_close(struct net_device *dev)\n{\n\tstruct enc28j60_net *priv = netdev_priv(dev);\n\n\tenc28j60_hw_disable(priv);\n\tenc28j60_lowpower(priv, true);\n\tnetif_stop_queue(dev);\n\n\treturn 0;\n}\n\n \nstatic void enc28j60_set_multicast_list(struct net_device *dev)\n{\n\tstruct enc28j60_net *priv = netdev_priv(dev);\n\tint oldfilter = priv->rxfilter;\n\n\tif (dev->flags & IFF_PROMISC) {\n\t\tif (netif_msg_link(priv))\n\t\t\tnetdev_info(dev, \"promiscuous mode\\n\");\n\t\tpriv->rxfilter = RXFILTER_PROMISC;\n\t} else if ((dev->flags & IFF_ALLMULTI) || !netdev_mc_empty(dev)) {\n\t\tif (netif_msg_link(priv))\n\t\t\tnetdev_info(dev, \"%smulticast mode\\n\",\n\t\t\t\t    (dev->flags & IFF_ALLMULTI) ? \"all-\" : \"\");\n\t\tpriv->rxfilter = RXFILTER_MULTI;\n\t} else {\n\t\tif (netif_msg_link(priv))\n\t\t\tnetdev_info(dev, \"normal mode\\n\");\n\t\tpriv->rxfilter = RXFILTER_NORMAL;\n\t}\n\n\tif (oldfilter != priv->rxfilter)\n\t\tschedule_work(&priv->setrx_work);\n}\n\nstatic void enc28j60_setrx_work_handler(struct work_struct *work)\n{\n\tstruct enc28j60_net *priv =\n\t\tcontainer_of(work, struct enc28j60_net, setrx_work);\n\tstruct device *dev = &priv->spi->dev;\n\n\tif (priv->rxfilter == RXFILTER_PROMISC) {\n\t\tif (netif_msg_drv(priv))\n\t\t\tdev_printk(KERN_DEBUG, dev, \"promiscuous mode\\n\");\n\t\tlocked_regb_write(priv, ERXFCON, 0x00);\n\t} else if (priv->rxfilter == RXFILTER_MULTI) {\n\t\tif (netif_msg_drv(priv))\n\t\t\tdev_printk(KERN_DEBUG, dev, \"multicast mode\\n\");\n\t\tlocked_regb_write(priv, ERXFCON,\n\t\t\t\t\tERXFCON_UCEN | ERXFCON_CRCEN |\n\t\t\t\t\tERXFCON_BCEN | ERXFCON_MCEN);\n\t} else {\n\t\tif (netif_msg_drv(priv))\n\t\t\tdev_printk(KERN_DEBUG, dev, \"normal mode\\n\");\n\t\tlocked_regb_write(priv, ERXFCON,\n\t\t\t\t\tERXFCON_UCEN | ERXFCON_CRCEN |\n\t\t\t\t\tERXFCON_BCEN);\n\t}\n}\n\nstatic void enc28j60_restart_work_handler(struct work_struct *work)\n{\n\tstruct enc28j60_net *priv =\n\t\t\tcontainer_of(work, struct enc28j60_net, restart_work);\n\tstruct net_device *ndev = priv->netdev;\n\tint ret;\n\n\trtnl_lock();\n\tif (netif_running(ndev)) {\n\t\tenc28j60_net_close(ndev);\n\t\tret = enc28j60_net_open(ndev);\n\t\tif (unlikely(ret)) {\n\t\t\tnetdev_info(ndev, \"could not restart %d\\n\", ret);\n\t\t\tdev_close(ndev);\n\t\t}\n\t}\n\trtnl_unlock();\n}\n\n \n\nstatic void\nenc28j60_get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *info)\n{\n\tstrscpy(info->driver, DRV_NAME, sizeof(info->driver));\n\tstrscpy(info->version, DRV_VERSION, sizeof(info->version));\n\tstrscpy(info->bus_info,\n\t\tdev_name(dev->dev.parent), sizeof(info->bus_info));\n}\n\nstatic int\nenc28j60_get_link_ksettings(struct net_device *dev,\n\t\t\t    struct ethtool_link_ksettings *cmd)\n{\n\tstruct enc28j60_net *priv = netdev_priv(dev);\n\n\tethtool_link_ksettings_zero_link_mode(cmd, supported);\n\tethtool_link_ksettings_add_link_mode(cmd, supported, 10baseT_Half);\n\tethtool_link_ksettings_add_link_mode(cmd, supported, 10baseT_Full);\n\tethtool_link_ksettings_add_link_mode(cmd, supported, TP);\n\n\tcmd->base.speed = SPEED_10;\n\tcmd->base.duplex = priv->full_duplex ? DUPLEX_FULL : DUPLEX_HALF;\n\tcmd->base.port\t= PORT_TP;\n\tcmd->base.autoneg = AUTONEG_DISABLE;\n\n\treturn 0;\n}\n\nstatic int\nenc28j60_set_link_ksettings(struct net_device *dev,\n\t\t\t    const struct ethtool_link_ksettings *cmd)\n{\n\treturn enc28j60_setlink(dev, cmd->base.autoneg,\n\t\t\t\tcmd->base.speed, cmd->base.duplex);\n}\n\nstatic u32 enc28j60_get_msglevel(struct net_device *dev)\n{\n\tstruct enc28j60_net *priv = netdev_priv(dev);\n\treturn priv->msg_enable;\n}\n\nstatic void enc28j60_set_msglevel(struct net_device *dev, u32 val)\n{\n\tstruct enc28j60_net *priv = netdev_priv(dev);\n\tpriv->msg_enable = val;\n}\n\nstatic const struct ethtool_ops enc28j60_ethtool_ops = {\n\t.get_drvinfo\t= enc28j60_get_drvinfo,\n\t.get_msglevel\t= enc28j60_get_msglevel,\n\t.set_msglevel\t= enc28j60_set_msglevel,\n\t.get_link_ksettings = enc28j60_get_link_ksettings,\n\t.set_link_ksettings = enc28j60_set_link_ksettings,\n};\n\nstatic int enc28j60_chipset_init(struct net_device *dev)\n{\n\tstruct enc28j60_net *priv = netdev_priv(dev);\n\n\treturn enc28j60_hw_init(priv);\n}\n\nstatic const struct net_device_ops enc28j60_netdev_ops = {\n\t.ndo_open\t\t= enc28j60_net_open,\n\t.ndo_stop\t\t= enc28j60_net_close,\n\t.ndo_start_xmit\t\t= enc28j60_send_packet,\n\t.ndo_set_rx_mode\t= enc28j60_set_multicast_list,\n\t.ndo_set_mac_address\t= enc28j60_set_mac_address,\n\t.ndo_tx_timeout\t\t= enc28j60_tx_timeout,\n\t.ndo_validate_addr\t= eth_validate_addr,\n};\n\nstatic int enc28j60_probe(struct spi_device *spi)\n{\n\tstruct net_device *dev;\n\tstruct enc28j60_net *priv;\n\tint ret = 0;\n\n\tif (netif_msg_drv(&debug))\n\t\tdev_info(&spi->dev, \"Ethernet driver %s loaded\\n\", DRV_VERSION);\n\n\tdev = alloc_etherdev(sizeof(struct enc28j60_net));\n\tif (!dev) {\n\t\tret = -ENOMEM;\n\t\tgoto error_alloc;\n\t}\n\tpriv = netdev_priv(dev);\n\n\tpriv->netdev = dev;\t \n\tpriv->spi = spi;\t \n\tpriv->msg_enable = netif_msg_init(debug.msg_enable, ENC28J60_MSG_DEFAULT);\n\tmutex_init(&priv->lock);\n\tINIT_WORK(&priv->tx_work, enc28j60_tx_work_handler);\n\tINIT_WORK(&priv->setrx_work, enc28j60_setrx_work_handler);\n\tINIT_WORK(&priv->restart_work, enc28j60_restart_work_handler);\n\tspi_set_drvdata(spi, priv);\t \n\tSET_NETDEV_DEV(dev, &spi->dev);\n\n\tif (!enc28j60_chipset_init(dev)) {\n\t\tif (netif_msg_probe(priv))\n\t\t\tdev_info(&spi->dev, \"chip not found\\n\");\n\t\tret = -EIO;\n\t\tgoto error_irq;\n\t}\n\n\tif (device_get_ethdev_address(&spi->dev, dev))\n\t\teth_hw_addr_random(dev);\n\tenc28j60_set_hw_macaddr(dev);\n\n\t \n\tret = request_threaded_irq(spi->irq, NULL, enc28j60_irq, IRQF_ONESHOT,\n\t\t\t\t   DRV_NAME, priv);\n\tif (ret < 0) {\n\t\tif (netif_msg_probe(priv))\n\t\t\tdev_err(&spi->dev, \"request irq %d failed (ret = %d)\\n\",\n\t\t\t\tspi->irq, ret);\n\t\tgoto error_irq;\n\t}\n\n\tdev->if_port = IF_PORT_10BASET;\n\tdev->irq = spi->irq;\n\tdev->netdev_ops = &enc28j60_netdev_ops;\n\tdev->watchdog_timeo = TX_TIMEOUT;\n\tdev->ethtool_ops = &enc28j60_ethtool_ops;\n\n\tenc28j60_lowpower(priv, true);\n\n\tret = register_netdev(dev);\n\tif (ret) {\n\t\tif (netif_msg_probe(priv))\n\t\t\tdev_err(&spi->dev, \"register netdev failed (ret = %d)\\n\",\n\t\t\t\tret);\n\t\tgoto error_register;\n\t}\n\n\treturn 0;\n\nerror_register:\n\tfree_irq(spi->irq, priv);\nerror_irq:\n\tfree_netdev(dev);\nerror_alloc:\n\treturn ret;\n}\n\nstatic void enc28j60_remove(struct spi_device *spi)\n{\n\tstruct enc28j60_net *priv = spi_get_drvdata(spi);\n\n\tunregister_netdev(priv->netdev);\n\tfree_irq(spi->irq, priv);\n\tfree_netdev(priv->netdev);\n}\n\nstatic const struct of_device_id enc28j60_dt_ids[] = {\n\t{ .compatible = \"microchip,enc28j60\" },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, enc28j60_dt_ids);\n\nstatic struct spi_driver enc28j60_driver = {\n\t.driver = {\n\t\t.name = DRV_NAME,\n\t\t.of_match_table = enc28j60_dt_ids,\n\t },\n\t.probe = enc28j60_probe,\n\t.remove = enc28j60_remove,\n};\nmodule_spi_driver(enc28j60_driver);\n\nMODULE_DESCRIPTION(DRV_NAME \" ethernet driver\");\nMODULE_AUTHOR(\"Claudio Lanconelli <lanconelli.claudio@eptar.com>\");\nMODULE_LICENSE(\"GPL\");\nmodule_param_named(debug, debug.msg_enable, int, 0);\nMODULE_PARM_DESC(debug, \"Debug verbosity level in amount of bits set (0=none, ..., 31=all)\");\nMODULE_ALIAS(\"spi:\" DRV_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}