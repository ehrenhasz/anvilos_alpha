{
  "module_name": "encx24j600.c",
  "hash_id": "e002f2b65986804dc112dbedef7303a3e0a8501a8bcb3ff62810f77408459baf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/microchip/encx24j600.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/errno.h>\n#include <linux/etherdevice.h>\n#include <linux/ethtool.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/regmap.h>\n#include <linux/skbuff.h>\n#include <linux/spi/spi.h>\n\n#include \"encx24j600_hw.h\"\n\n#define DRV_NAME\t\"encx24j600\"\n#define DRV_VERSION\t\"1.0\"\n\n#define DEFAULT_MSG_ENABLE (NETIF_MSG_DRV | NETIF_MSG_PROBE | NETIF_MSG_LINK)\nstatic int debug = -1;\nmodule_param(debug, int, 0000);\nMODULE_PARM_DESC(debug, \"Debug level (0=none,...,16=all)\");\n\n \n#define ENC_TX_BUF_START 0x0000U\n#define ENC_RX_BUF_START 0x0600U\n#define ENC_RX_BUF_END   0x5fffU\n#define ENC_SRAM_SIZE    0x6000U\n\nenum {\n\tRXFILTER_NORMAL,\n\tRXFILTER_MULTI,\n\tRXFILTER_PROMISC\n};\n\nstruct encx24j600_priv {\n\tstruct net_device        *ndev;\n\tstruct mutex              lock;  \n\tstruct encx24j600_context ctx;\n\tstruct sk_buff           *tx_skb;\n\tstruct task_struct       *kworker_task;\n\tstruct kthread_worker     kworker;\n\tstruct kthread_work       tx_work;\n\tstruct kthread_work       setrx_work;\n\tu16                       next_packet;\n\tbool                      hw_enabled;\n\tbool                      full_duplex;\n\tbool                      autoneg;\n\tu16                       speed;\n\tint                       rxfilter;\n\tu32                       msg_enable;\n};\n\nstatic void dump_packet(const char *msg, int len, const char *data)\n{\n\tpr_debug(DRV_NAME \": %s - packet len:%d\\n\", msg, len);\n\tprint_hex_dump_bytes(\"pk data: \", DUMP_PREFIX_OFFSET, data, len);\n}\n\nstatic void encx24j600_dump_rsv(struct encx24j600_priv *priv, const char *msg,\n\t\t\t\tstruct rsv *rsv)\n{\n\tstruct net_device *dev = priv->ndev;\n\n\tnetdev_info(dev, \"RX packet Len:%d\\n\", rsv->len);\n\tnetdev_dbg(dev, \"%s - NextPk: 0x%04x\\n\", msg,\n\t\t   rsv->next_packet);\n\tnetdev_dbg(dev, \"RxOK: %d, DribbleNibble: %d\\n\",\n\t\t   RSV_GETBIT(rsv->rxstat, RSV_RXOK),\n\t\t   RSV_GETBIT(rsv->rxstat, RSV_DRIBBLENIBBLE));\n\tnetdev_dbg(dev, \"CRCErr:%d, LenChkErr: %d, LenOutOfRange: %d\\n\",\n\t\t   RSV_GETBIT(rsv->rxstat, RSV_CRCERROR),\n\t\t   RSV_GETBIT(rsv->rxstat, RSV_LENCHECKERR),\n\t\t   RSV_GETBIT(rsv->rxstat, RSV_LENOUTOFRANGE));\n\tnetdev_dbg(dev, \"Multicast: %d, Broadcast: %d, LongDropEvent: %d, CarrierEvent: %d\\n\",\n\t\t   RSV_GETBIT(rsv->rxstat, RSV_RXMULTICAST),\n\t\t   RSV_GETBIT(rsv->rxstat, RSV_RXBROADCAST),\n\t\t   RSV_GETBIT(rsv->rxstat, RSV_RXLONGEVDROPEV),\n\t\t   RSV_GETBIT(rsv->rxstat, RSV_CARRIEREV));\n\tnetdev_dbg(dev, \"ControlFrame: %d, PauseFrame: %d, UnknownOp: %d, VLanTagFrame: %d\\n\",\n\t\t   RSV_GETBIT(rsv->rxstat, RSV_RXCONTROLFRAME),\n\t\t   RSV_GETBIT(rsv->rxstat, RSV_RXPAUSEFRAME),\n\t\t   RSV_GETBIT(rsv->rxstat, RSV_RXUNKNOWNOPCODE),\n\t\t   RSV_GETBIT(rsv->rxstat, RSV_RXTYPEVLAN));\n}\n\nstatic u16 encx24j600_read_reg(struct encx24j600_priv *priv, u8 reg)\n{\n\tstruct net_device *dev = priv->ndev;\n\tunsigned int val = 0;\n\tint ret = regmap_read(priv->ctx.regmap, reg, &val);\n\n\tif (unlikely(ret))\n\t\tnetif_err(priv, drv, dev, \"%s: error %d reading reg %02x\\n\",\n\t\t\t  __func__, ret, reg);\n\treturn val;\n}\n\nstatic void encx24j600_write_reg(struct encx24j600_priv *priv, u8 reg, u16 val)\n{\n\tstruct net_device *dev = priv->ndev;\n\tint ret = regmap_write(priv->ctx.regmap, reg, val);\n\n\tif (unlikely(ret))\n\t\tnetif_err(priv, drv, dev, \"%s: error %d writing reg %02x=%04x\\n\",\n\t\t\t  __func__, ret, reg, val);\n}\n\nstatic void encx24j600_update_reg(struct encx24j600_priv *priv, u8 reg,\n\t\t\t\t  u16 mask, u16 val)\n{\n\tstruct net_device *dev = priv->ndev;\n\tint ret = regmap_update_bits(priv->ctx.regmap, reg, mask, val);\n\n\tif (unlikely(ret))\n\t\tnetif_err(priv, drv, dev, \"%s: error %d updating reg %02x=%04x~%04x\\n\",\n\t\t\t  __func__, ret, reg, val, mask);\n}\n\nstatic u16 encx24j600_read_phy(struct encx24j600_priv *priv, u8 reg)\n{\n\tstruct net_device *dev = priv->ndev;\n\tunsigned int val = 0;\n\tint ret = regmap_read(priv->ctx.phymap, reg, &val);\n\n\tif (unlikely(ret))\n\t\tnetif_err(priv, drv, dev, \"%s: error %d reading %02x\\n\",\n\t\t\t  __func__, ret, reg);\n\treturn val;\n}\n\nstatic void encx24j600_write_phy(struct encx24j600_priv *priv, u8 reg, u16 val)\n{\n\tstruct net_device *dev = priv->ndev;\n\tint ret = regmap_write(priv->ctx.phymap, reg, val);\n\n\tif (unlikely(ret))\n\t\tnetif_err(priv, drv, dev, \"%s: error %d writing reg %02x=%04x\\n\",\n\t\t\t  __func__, ret, reg, val);\n}\n\nstatic void encx24j600_clr_bits(struct encx24j600_priv *priv, u8 reg, u16 mask)\n{\n\tencx24j600_update_reg(priv, reg, mask, 0);\n}\n\nstatic void encx24j600_set_bits(struct encx24j600_priv *priv, u8 reg, u16 mask)\n{\n\tencx24j600_update_reg(priv, reg, mask, mask);\n}\n\nstatic void encx24j600_cmd(struct encx24j600_priv *priv, u8 cmd)\n{\n\tstruct net_device *dev = priv->ndev;\n\tint ret = regmap_write(priv->ctx.regmap, cmd, 0);\n\n\tif (unlikely(ret))\n\t\tnetif_err(priv, drv, dev, \"%s: error %d with cmd %02x\\n\",\n\t\t\t  __func__, ret, cmd);\n}\n\nstatic int encx24j600_raw_read(struct encx24j600_priv *priv, u8 reg, u8 *data,\n\t\t\t       size_t count)\n{\n\tint ret;\n\n\tmutex_lock(&priv->ctx.mutex);\n\tret = regmap_encx24j600_spi_read(&priv->ctx, reg, data, count);\n\tmutex_unlock(&priv->ctx.mutex);\n\n\treturn ret;\n}\n\nstatic int encx24j600_raw_write(struct encx24j600_priv *priv, u8 reg,\n\t\t\t\tconst u8 *data, size_t count)\n{\n\tint ret;\n\n\tmutex_lock(&priv->ctx.mutex);\n\tret = regmap_encx24j600_spi_write(&priv->ctx, reg, data, count);\n\tmutex_unlock(&priv->ctx.mutex);\n\n\treturn ret;\n}\n\nstatic void encx24j600_update_phcon1(struct encx24j600_priv *priv)\n{\n\tu16 phcon1 = encx24j600_read_phy(priv, PHCON1);\n\n\tif (priv->autoneg == AUTONEG_ENABLE) {\n\t\tphcon1 |= ANEN | RENEG;\n\t} else {\n\t\tphcon1 &= ~ANEN;\n\t\tif (priv->speed == SPEED_100)\n\t\t\tphcon1 |= SPD100;\n\t\telse\n\t\t\tphcon1 &= ~SPD100;\n\n\t\tif (priv->full_duplex)\n\t\t\tphcon1 |= PFULDPX;\n\t\telse\n\t\t\tphcon1 &= ~PFULDPX;\n\t}\n\tencx24j600_write_phy(priv, PHCON1, phcon1);\n}\n\n \nstatic int encx24j600_wait_for_autoneg(struct encx24j600_priv *priv)\n{\n\tstruct net_device *dev = priv->ndev;\n\tunsigned long timeout = jiffies + msecs_to_jiffies(2000);\n\tu16 phstat1;\n\tu16 estat;\n\n\tphstat1 = encx24j600_read_phy(priv, PHSTAT1);\n\twhile ((phstat1 & ANDONE) == 0) {\n\t\tif (time_after(jiffies, timeout)) {\n\t\t\tu16 phstat3;\n\n\t\t\tnetif_notice(priv, drv, dev, \"timeout waiting for autoneg done\\n\");\n\n\t\t\tpriv->autoneg = AUTONEG_DISABLE;\n\t\t\tphstat3 = encx24j600_read_phy(priv, PHSTAT3);\n\t\t\tpriv->speed = (phstat3 & PHY3SPD100)\n\t\t\t\t      ? SPEED_100 : SPEED_10;\n\t\t\tpriv->full_duplex = (phstat3 & PHY3DPX) ? 1 : 0;\n\t\t\tencx24j600_update_phcon1(priv);\n\t\t\tnetif_notice(priv, drv, dev, \"Using parallel detection: %s/%s\",\n\t\t\t\t     priv->speed == SPEED_100 ? \"100\" : \"10\",\n\t\t\t\t     priv->full_duplex ? \"Full\" : \"Half\");\n\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t\tcpu_relax();\n\t\tphstat1 = encx24j600_read_phy(priv, PHSTAT1);\n\t}\n\n\testat = encx24j600_read_reg(priv, ESTAT);\n\tif (estat & PHYDPX) {\n\t\tencx24j600_set_bits(priv, MACON2, FULDPX);\n\t\tencx24j600_write_reg(priv, MABBIPG, 0x15);\n\t} else {\n\t\tencx24j600_clr_bits(priv, MACON2, FULDPX);\n\t\tencx24j600_write_reg(priv, MABBIPG, 0x12);\n\t\t \n\t\tencx24j600_write_reg(priv, MACLCON, 0x370f);\n\t}\n\n\treturn 0;\n}\n\n \nstatic void encx24j600_check_link_status(struct encx24j600_priv *priv)\n{\n\tstruct net_device *dev = priv->ndev;\n\tu16 estat;\n\n\testat = encx24j600_read_reg(priv, ESTAT);\n\n\tif (estat & PHYLNK) {\n\t\tif (priv->autoneg == AUTONEG_ENABLE)\n\t\t\tencx24j600_wait_for_autoneg(priv);\n\n\t\tnetif_carrier_on(dev);\n\t\tnetif_info(priv, ifup, dev, \"link up\\n\");\n\t} else {\n\t\tnetif_info(priv, ifdown, dev, \"link down\\n\");\n\n\t\t \n\t\tpriv->autoneg  = AUTONEG_ENABLE;\n\t\tpriv->full_duplex = true;\n\t\tpriv->speed = SPEED_100;\n\t\tnetif_carrier_off(dev);\n\t}\n}\n\nstatic void encx24j600_int_link_handler(struct encx24j600_priv *priv)\n{\n\tstruct net_device *dev = priv->ndev;\n\n\tnetif_dbg(priv, intr, dev, \"%s\", __func__);\n\tencx24j600_check_link_status(priv);\n\tencx24j600_clr_bits(priv, EIR, LINKIF);\n}\n\nstatic void encx24j600_tx_complete(struct encx24j600_priv *priv, bool err)\n{\n\tstruct net_device *dev = priv->ndev;\n\n\tif (!priv->tx_skb) {\n\t\tBUG();\n\t\treturn;\n\t}\n\n\tmutex_lock(&priv->lock);\n\n\tif (err)\n\t\tdev->stats.tx_errors++;\n\telse\n\t\tdev->stats.tx_packets++;\n\n\tdev->stats.tx_bytes += priv->tx_skb->len;\n\n\tencx24j600_clr_bits(priv, EIR, TXIF | TXABTIF);\n\n\tnetif_dbg(priv, tx_done, dev, \"TX Done%s\\n\", err ? \": Err\" : \"\");\n\n\tdev_kfree_skb(priv->tx_skb);\n\tpriv->tx_skb = NULL;\n\n\tnetif_wake_queue(dev);\n\n\tmutex_unlock(&priv->lock);\n}\n\nstatic int encx24j600_receive_packet(struct encx24j600_priv *priv,\n\t\t\t\t     struct rsv *rsv)\n{\n\tstruct net_device *dev = priv->ndev;\n\tstruct sk_buff *skb = netdev_alloc_skb(dev, rsv->len + NET_IP_ALIGN);\n\n\tif (!skb) {\n\t\tpr_err_ratelimited(\"RX: OOM: packet dropped\\n\");\n\t\tdev->stats.rx_dropped++;\n\t\treturn -ENOMEM;\n\t}\n\tskb_reserve(skb, NET_IP_ALIGN);\n\tencx24j600_raw_read(priv, RRXDATA, skb_put(skb, rsv->len), rsv->len);\n\n\tif (netif_msg_pktdata(priv))\n\t\tdump_packet(\"RX\", skb->len, skb->data);\n\n\tskb->dev = dev;\n\tskb->protocol = eth_type_trans(skb, dev);\n\tskb->ip_summed = CHECKSUM_COMPLETE;\n\n\t \n\tdev->stats.rx_packets++;\n\tdev->stats.rx_bytes += rsv->len;\n\n\tnetif_rx(skb);\n\n\treturn 0;\n}\n\nstatic void encx24j600_rx_packets(struct encx24j600_priv *priv, u8 packet_count)\n{\n\tstruct net_device *dev = priv->ndev;\n\n\twhile (packet_count--) {\n\t\tstruct rsv rsv;\n\t\tu16 newrxtail;\n\n\t\tencx24j600_write_reg(priv, ERXRDPT, priv->next_packet);\n\t\tencx24j600_raw_read(priv, RRXDATA, (u8 *)&rsv, sizeof(rsv));\n\n\t\tif (netif_msg_rx_status(priv))\n\t\t\tencx24j600_dump_rsv(priv, __func__, &rsv);\n\n\t\tif (!RSV_GETBIT(rsv.rxstat, RSV_RXOK) ||\n\t\t    (rsv.len > MAX_FRAMELEN)) {\n\t\t\tnetif_err(priv, rx_err, dev, \"RX Error %04x\\n\",\n\t\t\t\t  rsv.rxstat);\n\t\t\tdev->stats.rx_errors++;\n\n\t\t\tif (RSV_GETBIT(rsv.rxstat, RSV_CRCERROR))\n\t\t\t\tdev->stats.rx_crc_errors++;\n\t\t\tif (RSV_GETBIT(rsv.rxstat, RSV_LENCHECKERR))\n\t\t\t\tdev->stats.rx_frame_errors++;\n\t\t\tif (rsv.len > MAX_FRAMELEN)\n\t\t\t\tdev->stats.rx_over_errors++;\n\t\t} else {\n\t\t\tencx24j600_receive_packet(priv, &rsv);\n\t\t}\n\n\t\tpriv->next_packet = rsv.next_packet;\n\n\t\tnewrxtail = priv->next_packet - 2;\n\t\tif (newrxtail == ENC_RX_BUF_START)\n\t\t\tnewrxtail = SRAM_SIZE - 2;\n\n\t\tencx24j600_cmd(priv, SETPKTDEC);\n\t\tencx24j600_write_reg(priv, ERXTAIL, newrxtail);\n\t}\n}\n\nstatic irqreturn_t encx24j600_isr(int irq, void *dev_id)\n{\n\tstruct encx24j600_priv *priv = dev_id;\n\tstruct net_device *dev = priv->ndev;\n\tint eir;\n\n\t \n\tencx24j600_cmd(priv, CLREIE);\n\n\teir = encx24j600_read_reg(priv, EIR);\n\n\tif (eir & LINKIF)\n\t\tencx24j600_int_link_handler(priv);\n\n\tif (eir & TXIF)\n\t\tencx24j600_tx_complete(priv, false);\n\n\tif (eir & TXABTIF)\n\t\tencx24j600_tx_complete(priv, true);\n\n\tif (eir & RXABTIF) {\n\t\tif (eir & PCFULIF) {\n\t\t\t \n\t\t\tnetif_err(priv, rx_err, dev, \"Packet counter full\\n\");\n\t\t}\n\t\tdev->stats.rx_dropped++;\n\t\tencx24j600_clr_bits(priv, EIR, RXABTIF);\n\t}\n\n\tif (eir & PKTIF) {\n\t\tu8 packet_count;\n\n\t\tmutex_lock(&priv->lock);\n\n\t\tpacket_count = encx24j600_read_reg(priv, ESTAT) & 0xff;\n\t\twhile (packet_count) {\n\t\t\tencx24j600_rx_packets(priv, packet_count);\n\t\t\tpacket_count = encx24j600_read_reg(priv, ESTAT) & 0xff;\n\t\t}\n\n\t\tmutex_unlock(&priv->lock);\n\t}\n\n\t \n\tencx24j600_cmd(priv, SETEIE);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int encx24j600_soft_reset(struct encx24j600_priv *priv)\n{\n\tint ret = 0;\n\tint timeout;\n\tu16 eudast;\n\n\t \n\tregcache_cache_bypass(priv->ctx.regmap, true);\n\ttimeout = 10;\n\tdo {\n\t\tencx24j600_write_reg(priv, EUDAST, EUDAST_TEST_VAL);\n\t\teudast = encx24j600_read_reg(priv, EUDAST);\n\t\tusleep_range(25, 100);\n\t} while ((eudast != EUDAST_TEST_VAL) && --timeout);\n\tregcache_cache_bypass(priv->ctx.regmap, false);\n\n\tif (timeout == 0) {\n\t\tret = -ETIMEDOUT;\n\t\tgoto err_out;\n\t}\n\n\t \n\ttimeout = 10;\n\twhile (!(encx24j600_read_reg(priv, ESTAT) & CLKRDY) && --timeout)\n\t\tusleep_range(25, 100);\n\n\tif (timeout == 0) {\n\t\tret = -ETIMEDOUT;\n\t\tgoto err_out;\n\t}\n\n\t \n\tencx24j600_cmd(priv, SETETHRST);\n\tusleep_range(25, 100);\n\n\t \n\tif (encx24j600_read_reg(priv, EUDAST) != 0) {\n\t\tret = -EINVAL;\n\t\tgoto err_out;\n\t}\n\n\t \n\tusleep_range(256, 1000);\n\nerr_out:\n\treturn ret;\n}\n\nstatic int encx24j600_hw_reset(struct encx24j600_priv *priv)\n{\n\tint ret;\n\n\tmutex_lock(&priv->lock);\n\tret = encx24j600_soft_reset(priv);\n\tmutex_unlock(&priv->lock);\n\n\treturn ret;\n}\n\nstatic void encx24j600_reset_hw_tx(struct encx24j600_priv *priv)\n{\n\tencx24j600_set_bits(priv, ECON2, TXRST);\n\tencx24j600_clr_bits(priv, ECON2, TXRST);\n}\n\nstatic void encx24j600_hw_init_tx(struct encx24j600_priv *priv)\n{\n\t \n\tencx24j600_reset_hw_tx(priv);\n\n\t \n\tencx24j600_clr_bits(priv, EIR, TXIF | TXABTIF);\n\n\t \n\tencx24j600_write_reg(priv, EGPWRPT, ENC_TX_BUF_START);\n}\n\nstatic void encx24j600_hw_init_rx(struct encx24j600_priv *priv)\n{\n\tencx24j600_cmd(priv, DISABLERX);\n\n\t \n\tencx24j600_write_reg(priv, ERXST, ENC_RX_BUF_START);\n\n\t \n\tencx24j600_write_reg(priv, ERXRDPT, ENC_RX_BUF_START);\n\n\tpriv->next_packet = ENC_RX_BUF_START;\n\n\t \n\tencx24j600_write_reg(priv, ERXTAIL, ENC_SRAM_SIZE - 2);\n\n\t \n\tencx24j600_write_reg(priv, EUDAST, ENC_SRAM_SIZE);\n\tencx24j600_write_reg(priv, EUDAND, ENC_SRAM_SIZE + 1);\n\n\t \n\tencx24j600_write_reg(priv, MAMXFL, MAX_FRAMELEN);\n}\n\nstatic void encx24j600_dump_config(struct encx24j600_priv *priv,\n\t\t\t\t   const char *msg)\n{\n\tpr_info(DRV_NAME \": %s\\n\", msg);\n\n\t \n\tpr_info(DRV_NAME \" ECON1:   %04X\\n\", encx24j600_read_reg(priv, ECON1));\n\tpr_info(DRV_NAME \" ECON2:   %04X\\n\", encx24j600_read_reg(priv, ECON2));\n\tpr_info(DRV_NAME \" ERXFCON: %04X\\n\", encx24j600_read_reg(priv,\n\t\t\t\t\t\t\t\t ERXFCON));\n\tpr_info(DRV_NAME \" ESTAT:   %04X\\n\", encx24j600_read_reg(priv, ESTAT));\n\tpr_info(DRV_NAME \" EIR:     %04X\\n\", encx24j600_read_reg(priv, EIR));\n\tpr_info(DRV_NAME \" EIDLED:  %04X\\n\", encx24j600_read_reg(priv, EIDLED));\n\n\t \n\tpr_info(DRV_NAME \" MACON1:  %04X\\n\", encx24j600_read_reg(priv, MACON1));\n\tpr_info(DRV_NAME \" MACON2:  %04X\\n\", encx24j600_read_reg(priv, MACON2));\n\tpr_info(DRV_NAME \" MAIPG:   %04X\\n\", encx24j600_read_reg(priv, MAIPG));\n\tpr_info(DRV_NAME \" MACLCON: %04X\\n\", encx24j600_read_reg(priv,\n\t\t\t\t\t\t\t\t MACLCON));\n\tpr_info(DRV_NAME \" MABBIPG: %04X\\n\", encx24j600_read_reg(priv,\n\t\t\t\t\t\t\t\t MABBIPG));\n\n\t \n\tpr_info(DRV_NAME \" PHCON1:  %04X\\n\", encx24j600_read_phy(priv, PHCON1));\n\tpr_info(DRV_NAME \" PHCON2:  %04X\\n\", encx24j600_read_phy(priv, PHCON2));\n\tpr_info(DRV_NAME \" PHANA:   %04X\\n\", encx24j600_read_phy(priv, PHANA));\n\tpr_info(DRV_NAME \" PHANLPA: %04X\\n\", encx24j600_read_phy(priv,\n\t\t\t\t\t\t\t\t PHANLPA));\n\tpr_info(DRV_NAME \" PHANE:   %04X\\n\", encx24j600_read_phy(priv, PHANE));\n\tpr_info(DRV_NAME \" PHSTAT1: %04X\\n\", encx24j600_read_phy(priv,\n\t\t\t\t\t\t\t\t PHSTAT1));\n\tpr_info(DRV_NAME \" PHSTAT2: %04X\\n\", encx24j600_read_phy(priv,\n\t\t\t\t\t\t\t\t PHSTAT2));\n\tpr_info(DRV_NAME \" PHSTAT3: %04X\\n\", encx24j600_read_phy(priv,\n\t\t\t\t\t\t\t\t PHSTAT3));\n}\n\nstatic void encx24j600_set_rxfilter_mode(struct encx24j600_priv *priv)\n{\n\tswitch (priv->rxfilter) {\n\tcase RXFILTER_PROMISC:\n\t\tencx24j600_set_bits(priv, MACON1, PASSALL);\n\t\tencx24j600_write_reg(priv, ERXFCON, UCEN | MCEN | NOTMEEN);\n\t\tbreak;\n\tcase RXFILTER_MULTI:\n\t\tencx24j600_clr_bits(priv, MACON1, PASSALL);\n\t\tencx24j600_write_reg(priv, ERXFCON, UCEN | CRCEN | BCEN | MCEN);\n\t\tbreak;\n\tcase RXFILTER_NORMAL:\n\tdefault:\n\t\tencx24j600_clr_bits(priv, MACON1, PASSALL);\n\t\tencx24j600_write_reg(priv, ERXFCON, UCEN | CRCEN | BCEN);\n\t\tbreak;\n\t}\n}\n\nstatic void encx24j600_hw_init(struct encx24j600_priv *priv)\n{\n\tu16 macon2;\n\n\tpriv->hw_enabled = false;\n\n\t \n\tencx24j600_update_reg(priv, EIDLED, 0xff00, 0xcb00);\n\n\t \n\tencx24j600_write_reg(priv, MACON1, 0x9);\n\n\t \n\tencx24j600_write_reg(priv, MAIPG, 0x0c12);\n\n\t \n\tencx24j600_write_phy(priv, PHANA, PHANA_DEFAULT);\n\n\tencx24j600_update_phcon1(priv);\n\tencx24j600_check_link_status(priv);\n\n\tmacon2 = MACON2_RSV1 | TXCRCEN | PADCFG0 | PADCFG2 | MACON2_DEFER;\n\tif ((priv->autoneg == AUTONEG_DISABLE) && priv->full_duplex)\n\t\tmacon2 |= FULDPX;\n\n\tencx24j600_set_bits(priv, MACON2, macon2);\n\n\tpriv->rxfilter = RXFILTER_NORMAL;\n\tencx24j600_set_rxfilter_mode(priv);\n\n\t \n\tencx24j600_write_reg(priv, MAMXFL, MAX_FRAMELEN);\n\n\t \n\tencx24j600_hw_init_tx(priv);\n\n\t \n\tencx24j600_hw_init_rx(priv);\n\n\tif (netif_msg_hw(priv))\n\t\tencx24j600_dump_config(priv, \"Hw is initialized\");\n}\n\nstatic void encx24j600_hw_enable(struct encx24j600_priv *priv)\n{\n\t \n\tencx24j600_clr_bits(priv, EIR, (PCFULIF | RXABTIF | TXABTIF | TXIF |\n\t\t\t\t\tPKTIF | LINKIF));\n\n\t \n\tencx24j600_write_reg(priv, EIE, (PCFULIE | RXABTIE | TXABTIE | TXIE |\n\t\t\t\t\t PKTIE | LINKIE | INTIE));\n\n\t \n\tencx24j600_cmd(priv, ENABLERX);\n\n\tpriv->hw_enabled = true;\n}\n\nstatic void encx24j600_hw_disable(struct encx24j600_priv *priv)\n{\n\t \n\tencx24j600_write_reg(priv, EIE, 0);\n\n\t \n\tencx24j600_cmd(priv, DISABLERX);\n\n\tpriv->hw_enabled = false;\n}\n\nstatic int encx24j600_setlink(struct net_device *dev, u8 autoneg, u16 speed,\n\t\t\t      u8 duplex)\n{\n\tstruct encx24j600_priv *priv = netdev_priv(dev);\n\tint ret = 0;\n\n\tif (!priv->hw_enabled) {\n\t\t \n\t\tif (speed == SPEED_10 || speed == SPEED_100) {\n\t\t\tpriv->autoneg = (autoneg == AUTONEG_ENABLE);\n\t\t\tpriv->full_duplex = (duplex == DUPLEX_FULL);\n\t\t\tpriv->speed = (speed == SPEED_100);\n\t\t} else {\n\t\t\tnetif_warn(priv, link, dev, \"unsupported link speed setting\\n\");\n\t\t\t \n\t\t\t \n\t\t\tret = -EOPNOTSUPP;\n\t\t}\n\t} else {\n\t\tnetif_warn(priv, link, dev, \"Warning: hw must be disabled to set link mode\\n\");\n\t\tret = -EBUSY;\n\t}\n\treturn ret;\n}\n\nstatic void encx24j600_hw_get_macaddr(struct encx24j600_priv *priv,\n\t\t\t\t      unsigned char *ethaddr)\n{\n\tunsigned short val;\n\n\tval = encx24j600_read_reg(priv, MAADR1);\n\n\tethaddr[0] = val & 0x00ff;\n\tethaddr[1] = (val & 0xff00) >> 8;\n\n\tval = encx24j600_read_reg(priv, MAADR2);\n\n\tethaddr[2] = val & 0x00ffU;\n\tethaddr[3] = (val & 0xff00U) >> 8;\n\n\tval = encx24j600_read_reg(priv, MAADR3);\n\n\tethaddr[4] = val & 0x00ffU;\n\tethaddr[5] = (val & 0xff00U) >> 8;\n}\n\n \nstatic int encx24j600_set_hw_macaddr(struct net_device *dev)\n{\n\tstruct encx24j600_priv *priv = netdev_priv(dev);\n\n\tif (priv->hw_enabled) {\n\t\tnetif_info(priv, drv, dev, \"Hardware must be disabled to set Mac address\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tmutex_lock(&priv->lock);\n\n\tnetif_info(priv, drv, dev, \"%s: Setting MAC address to %pM\\n\",\n\t\t   dev->name, dev->dev_addr);\n\n\tencx24j600_write_reg(priv, MAADR3, (dev->dev_addr[4] |\n\t\t\t     dev->dev_addr[5] << 8));\n\tencx24j600_write_reg(priv, MAADR2, (dev->dev_addr[2] |\n\t\t\t     dev->dev_addr[3] << 8));\n\tencx24j600_write_reg(priv, MAADR1, (dev->dev_addr[0] |\n\t\t\t     dev->dev_addr[1] << 8));\n\n\tmutex_unlock(&priv->lock);\n\n\treturn 0;\n}\n\n \nstatic int encx24j600_set_mac_address(struct net_device *dev, void *addr)\n{\n\tstruct sockaddr *address = addr;\n\n\tif (netif_running(dev))\n\t\treturn -EBUSY;\n\tif (!is_valid_ether_addr(address->sa_data))\n\t\treturn -EADDRNOTAVAIL;\n\n\teth_hw_addr_set(dev, address->sa_data);\n\treturn encx24j600_set_hw_macaddr(dev);\n}\n\nstatic int encx24j600_open(struct net_device *dev)\n{\n\tstruct encx24j600_priv *priv = netdev_priv(dev);\n\n\tint ret = request_threaded_irq(priv->ctx.spi->irq, NULL, encx24j600_isr,\n\t\t\t\t       IRQF_TRIGGER_FALLING | IRQF_ONESHOT,\n\t\t\t\t       DRV_NAME, priv);\n\tif (unlikely(ret < 0)) {\n\t\tnetdev_err(dev, \"request irq %d failed (ret = %d)\\n\",\n\t\t\t   priv->ctx.spi->irq, ret);\n\t\treturn ret;\n\t}\n\n\tencx24j600_hw_disable(priv);\n\tencx24j600_hw_init(priv);\n\tencx24j600_hw_enable(priv);\n\tnetif_start_queue(dev);\n\n\treturn 0;\n}\n\nstatic int encx24j600_stop(struct net_device *dev)\n{\n\tstruct encx24j600_priv *priv = netdev_priv(dev);\n\n\tnetif_stop_queue(dev);\n\tfree_irq(priv->ctx.spi->irq, priv);\n\treturn 0;\n}\n\nstatic void encx24j600_setrx_proc(struct kthread_work *ws)\n{\n\tstruct encx24j600_priv *priv =\n\t\t\tcontainer_of(ws, struct encx24j600_priv, setrx_work);\n\n\tmutex_lock(&priv->lock);\n\tencx24j600_set_rxfilter_mode(priv);\n\tmutex_unlock(&priv->lock);\n}\n\nstatic void encx24j600_set_multicast_list(struct net_device *dev)\n{\n\tstruct encx24j600_priv *priv = netdev_priv(dev);\n\tint oldfilter = priv->rxfilter;\n\n\tif (dev->flags & IFF_PROMISC) {\n\t\tnetif_dbg(priv, link, dev, \"promiscuous mode\\n\");\n\t\tpriv->rxfilter = RXFILTER_PROMISC;\n\t} else if ((dev->flags & IFF_ALLMULTI) || !netdev_mc_empty(dev)) {\n\t\tnetif_dbg(priv, link, dev, \"%smulticast mode\\n\",\n\t\t\t  (dev->flags & IFF_ALLMULTI) ? \"all-\" : \"\");\n\t\tpriv->rxfilter = RXFILTER_MULTI;\n\t} else {\n\t\tnetif_dbg(priv, link, dev, \"normal mode\\n\");\n\t\tpriv->rxfilter = RXFILTER_NORMAL;\n\t}\n\n\tif (oldfilter != priv->rxfilter)\n\t\tkthread_queue_work(&priv->kworker, &priv->setrx_work);\n}\n\nstatic void encx24j600_hw_tx(struct encx24j600_priv *priv)\n{\n\tstruct net_device *dev = priv->ndev;\n\n\tnetif_info(priv, tx_queued, dev, \"TX Packet Len:%d\\n\",\n\t\t   priv->tx_skb->len);\n\n\tif (netif_msg_pktdata(priv))\n\t\tdump_packet(\"TX\", priv->tx_skb->len, priv->tx_skb->data);\n\n\tif (encx24j600_read_reg(priv, EIR) & TXABTIF)\n\t\t \n\t\tencx24j600_reset_hw_tx(priv);\n\n\t \n\tencx24j600_clr_bits(priv, EIR, TXIF);\n\n\t \n\tencx24j600_write_reg(priv, EGPWRPT, ENC_TX_BUF_START);\n\n\t \n\tencx24j600_raw_write(priv, WGPDATA, (u8 *)priv->tx_skb->data,\n\t\t\t     priv->tx_skb->len);\n\n\t \n\tencx24j600_write_reg(priv, ETXST, ENC_TX_BUF_START);\n\n\t \n\tencx24j600_write_reg(priv, ETXLEN, priv->tx_skb->len);\n\n\t \n\tencx24j600_cmd(priv, SETTXRTS);\n}\n\nstatic void encx24j600_tx_proc(struct kthread_work *ws)\n{\n\tstruct encx24j600_priv *priv =\n\t\t\tcontainer_of(ws, struct encx24j600_priv, tx_work);\n\n\tmutex_lock(&priv->lock);\n\tencx24j600_hw_tx(priv);\n\tmutex_unlock(&priv->lock);\n}\n\nstatic netdev_tx_t encx24j600_tx(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct encx24j600_priv *priv = netdev_priv(dev);\n\n\tnetif_stop_queue(dev);\n\n\t \n\tnetif_trans_update(dev);\n\n\t \n\tpriv->tx_skb = skb;\n\n\tkthread_queue_work(&priv->kworker, &priv->tx_work);\n\n\treturn NETDEV_TX_OK;\n}\n\n \nstatic void encx24j600_tx_timeout(struct net_device *dev, unsigned int txqueue)\n{\n\tstruct encx24j600_priv *priv = netdev_priv(dev);\n\n\tnetif_err(priv, tx_err, dev, \"TX timeout at %ld, latency %ld\\n\",\n\t\t  jiffies, jiffies - dev_trans_start(dev));\n\n\tdev->stats.tx_errors++;\n\tnetif_wake_queue(dev);\n}\n\nstatic int encx24j600_get_regs_len(struct net_device *dev)\n{\n\treturn SFR_REG_COUNT;\n}\n\nstatic void encx24j600_get_regs(struct net_device *dev,\n\t\t\t\tstruct ethtool_regs *regs, void *p)\n{\n\tstruct encx24j600_priv *priv = netdev_priv(dev);\n\tu16 *buff = p;\n\tu8 reg;\n\n\tregs->version = 1;\n\tmutex_lock(&priv->lock);\n\tfor (reg = 0; reg < SFR_REG_COUNT; reg += 2) {\n\t\tunsigned int val = 0;\n\t\t \n\t\tregmap_read(priv->ctx.regmap, reg, &val);\n\t\tbuff[reg] = val & 0xffff;\n\t}\n\tmutex_unlock(&priv->lock);\n}\n\nstatic void encx24j600_get_drvinfo(struct net_device *dev,\n\t\t\t\t   struct ethtool_drvinfo *info)\n{\n\tstrscpy(info->driver, DRV_NAME, sizeof(info->driver));\n\tstrscpy(info->version, DRV_VERSION, sizeof(info->version));\n\tstrscpy(info->bus_info, dev_name(dev->dev.parent),\n\t\tsizeof(info->bus_info));\n}\n\nstatic int encx24j600_get_link_ksettings(struct net_device *dev,\n\t\t\t\t\t struct ethtool_link_ksettings *cmd)\n{\n\tstruct encx24j600_priv *priv = netdev_priv(dev);\n\tu32 supported;\n\n\tsupported = SUPPORTED_10baseT_Half | SUPPORTED_10baseT_Full |\n\t\t\t SUPPORTED_100baseT_Half | SUPPORTED_100baseT_Full |\n\t\t\t SUPPORTED_Autoneg | SUPPORTED_TP;\n\n\tethtool_convert_legacy_u32_to_link_mode(cmd->link_modes.supported,\n\t\t\t\t\t\tsupported);\n\n\tcmd->base.speed = priv->speed;\n\tcmd->base.duplex = priv->full_duplex ? DUPLEX_FULL : DUPLEX_HALF;\n\tcmd->base.port = PORT_TP;\n\tcmd->base.autoneg = priv->autoneg ? AUTONEG_ENABLE : AUTONEG_DISABLE;\n\n\treturn 0;\n}\n\nstatic int\nencx24j600_set_link_ksettings(struct net_device *dev,\n\t\t\t      const struct ethtool_link_ksettings *cmd)\n{\n\treturn encx24j600_setlink(dev, cmd->base.autoneg,\n\t\t\t\t  cmd->base.speed, cmd->base.duplex);\n}\n\nstatic u32 encx24j600_get_msglevel(struct net_device *dev)\n{\n\tstruct encx24j600_priv *priv = netdev_priv(dev);\n\n\treturn priv->msg_enable;\n}\n\nstatic void encx24j600_set_msglevel(struct net_device *dev, u32 val)\n{\n\tstruct encx24j600_priv *priv = netdev_priv(dev);\n\n\tpriv->msg_enable = val;\n}\n\nstatic const struct ethtool_ops encx24j600_ethtool_ops = {\n\t.get_drvinfo = encx24j600_get_drvinfo,\n\t.get_msglevel = encx24j600_get_msglevel,\n\t.set_msglevel = encx24j600_set_msglevel,\n\t.get_regs_len = encx24j600_get_regs_len,\n\t.get_regs = encx24j600_get_regs,\n\t.get_link_ksettings = encx24j600_get_link_ksettings,\n\t.set_link_ksettings = encx24j600_set_link_ksettings,\n};\n\nstatic const struct net_device_ops encx24j600_netdev_ops = {\n\t.ndo_open = encx24j600_open,\n\t.ndo_stop = encx24j600_stop,\n\t.ndo_start_xmit = encx24j600_tx,\n\t.ndo_set_rx_mode = encx24j600_set_multicast_list,\n\t.ndo_set_mac_address = encx24j600_set_mac_address,\n\t.ndo_tx_timeout = encx24j600_tx_timeout,\n\t.ndo_validate_addr = eth_validate_addr,\n};\n\nstatic int encx24j600_spi_probe(struct spi_device *spi)\n{\n\tint ret;\n\n\tstruct net_device *ndev;\n\tstruct encx24j600_priv *priv;\n\tu16 eidled;\n\tu8 addr[ETH_ALEN];\n\n\tndev = alloc_etherdev(sizeof(struct encx24j600_priv));\n\n\tif (!ndev) {\n\t\tret = -ENOMEM;\n\t\tgoto error_out;\n\t}\n\n\tpriv = netdev_priv(ndev);\n\tspi_set_drvdata(spi, priv);\n\tdev_set_drvdata(&spi->dev, priv);\n\tSET_NETDEV_DEV(ndev, &spi->dev);\n\n\tpriv->msg_enable = netif_msg_init(debug, DEFAULT_MSG_ENABLE);\n\tpriv->ndev = ndev;\n\n\t \n\tpriv->full_duplex = true;\n\tpriv->autoneg = AUTONEG_ENABLE;\n\tpriv->speed = SPEED_100;\n\n\tpriv->ctx.spi = spi;\n\tndev->irq = spi->irq;\n\tndev->netdev_ops = &encx24j600_netdev_ops;\n\n\tret = devm_regmap_init_encx24j600(&spi->dev, &priv->ctx);\n\tif (ret)\n\t\tgoto out_free;\n\n\tmutex_init(&priv->lock);\n\n\t \n\tif (encx24j600_hw_reset(priv)) {\n\t\tnetif_err(priv, probe, ndev,\n\t\t\t  DRV_NAME \": Chip is not detected\\n\");\n\t\tret = -EIO;\n\t\tgoto out_free;\n\t}\n\n\t \n\tencx24j600_hw_init(priv);\n\n\tkthread_init_worker(&priv->kworker);\n\tkthread_init_work(&priv->tx_work, encx24j600_tx_proc);\n\tkthread_init_work(&priv->setrx_work, encx24j600_setrx_proc);\n\n\tpriv->kworker_task = kthread_run(kthread_worker_fn, &priv->kworker,\n\t\t\t\t\t \"encx24j600\");\n\n\tif (IS_ERR(priv->kworker_task)) {\n\t\tret = PTR_ERR(priv->kworker_task);\n\t\tgoto out_free;\n\t}\n\n\t \n\tencx24j600_hw_get_macaddr(priv, addr);\n\teth_hw_addr_set(ndev, addr);\n\n\tndev->ethtool_ops = &encx24j600_ethtool_ops;\n\n\tret = register_netdev(ndev);\n\tif (unlikely(ret)) {\n\t\tnetif_err(priv, probe, ndev, \"Error %d initializing card encx24j600 card\\n\",\n\t\t\t  ret);\n\t\tgoto out_stop;\n\t}\n\n\teidled = encx24j600_read_reg(priv, EIDLED);\n\tif (((eidled & DEVID_MASK) >> DEVID_SHIFT) != ENCX24J600_DEV_ID) {\n\t\tret = -EINVAL;\n\t\tgoto out_unregister;\n\t}\n\n\tnetif_info(priv, probe, ndev, \"Silicon rev ID: 0x%02x\\n\",\n\t\t   (eidled & REVID_MASK) >> REVID_SHIFT);\n\n\tnetif_info(priv, drv, priv->ndev, \"MAC address %pM\\n\", ndev->dev_addr);\n\n\treturn ret;\n\nout_unregister:\n\tunregister_netdev(priv->ndev);\nout_stop:\n\tkthread_stop(priv->kworker_task);\nout_free:\n\tfree_netdev(ndev);\n\nerror_out:\n\treturn ret;\n}\n\nstatic void encx24j600_spi_remove(struct spi_device *spi)\n{\n\tstruct encx24j600_priv *priv = dev_get_drvdata(&spi->dev);\n\n\tunregister_netdev(priv->ndev);\n\tkthread_stop(priv->kworker_task);\n\n\tfree_netdev(priv->ndev);\n}\n\nstatic const struct spi_device_id encx24j600_spi_id_table[] = {\n\t{ .name = \"encx24j600\" },\n\t{   }\n};\nMODULE_DEVICE_TABLE(spi, encx24j600_spi_id_table);\n\nstatic struct spi_driver encx24j600_spi_net_driver = {\n\t.driver = {\n\t\t.name\t= DRV_NAME,\n\t\t.owner\t= THIS_MODULE,\n\t\t.bus\t= &spi_bus_type,\n\t},\n\t.probe\t\t= encx24j600_spi_probe,\n\t.remove\t\t= encx24j600_spi_remove,\n\t.id_table\t= encx24j600_spi_id_table,\n};\n\nmodule_spi_driver(encx24j600_spi_net_driver);\n\nMODULE_DESCRIPTION(DRV_NAME \" ethernet driver\");\nMODULE_AUTHOR(\"Jon Ringle <jringle@gridpoint.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}