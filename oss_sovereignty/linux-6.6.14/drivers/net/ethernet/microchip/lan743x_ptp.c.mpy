{
  "module_name": "lan743x_ptp.c",
  "hash_id": "0bb8e5be57b5185cd798dae1ec8c2e8b1a67f3cb609eb158b5406ad8f0afd848",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/microchip/lan743x_ptp.c",
  "human_readable_source": " \n \n\n#include <linux/netdevice.h>\n\n#include <linux/ptp_clock_kernel.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/net_tstamp.h>\n#include \"lan743x_main.h\"\n\n#include \"lan743x_ptp.h\"\n\n#define LAN743X_LED0_ENABLE\t\t20\t \n#define LAN743X_LED_ENABLE(pin)\t\tBIT(LAN743X_LED0_ENABLE + (pin))\n\n#define LAN743X_PTP_MAX_FREQ_ADJ_IN_PPB\t\t(31249999)\n#define LAN743X_PTP_MAX_FINE_ADJ_IN_SCALED_PPM\t(2047999934)\n\nstatic bool lan743x_ptp_is_enabled(struct lan743x_adapter *adapter);\nstatic void lan743x_ptp_enable(struct lan743x_adapter *adapter);\nstatic void lan743x_ptp_disable(struct lan743x_adapter *adapter);\nstatic void lan743x_ptp_reset(struct lan743x_adapter *adapter);\nstatic void lan743x_ptp_clock_set(struct lan743x_adapter *adapter,\n\t\t\t\t  u32 seconds, u32 nano_seconds,\n\t\t\t\t  u32 sub_nano_seconds);\n\nstatic int lan743x_get_channel(u32 ch_map)\n{\n\tint idx;\n\n\tfor (idx = 0; idx < 32; idx++) {\n\t\tif (ch_map & (0x1 << idx))\n\t\t\treturn idx;\n\t}\n\n\treturn -EINVAL;\n}\n\nint lan743x_gpio_init(struct lan743x_adapter *adapter)\n{\n\tstruct lan743x_gpio *gpio = &adapter->gpio;\n\n\tspin_lock_init(&gpio->gpio_lock);\n\n\tgpio->gpio_cfg0 = 0;  \n\tgpio->gpio_cfg1 = 0x0FFF0000; \n\tgpio->gpio_cfg2 = 0; \n\tgpio->gpio_cfg3 = 0; \n\tlan743x_csr_write(adapter, GPIO_CFG0, gpio->gpio_cfg0);\n\tlan743x_csr_write(adapter, GPIO_CFG1, gpio->gpio_cfg1);\n\tlan743x_csr_write(adapter, GPIO_CFG2, gpio->gpio_cfg2);\n\tlan743x_csr_write(adapter, GPIO_CFG3, gpio->gpio_cfg3);\n\n\treturn 0;\n}\n\nstatic void lan743x_ptp_wait_till_cmd_done(struct lan743x_adapter *adapter,\n\t\t\t\t\t   u32 bit_mask)\n{\n\tint timeout = 1000;\n\tu32 data = 0;\n\n\twhile (timeout &&\n\t       (data = (lan743x_csr_read(adapter, PTP_CMD_CTL) &\n\t       bit_mask))) {\n\t\tusleep_range(1000, 20000);\n\t\ttimeout--;\n\t}\n\tif (data) {\n\t\tnetif_err(adapter, drv, adapter->netdev,\n\t\t\t  \"timeout waiting for cmd to be done, cmd = 0x%08X\\n\",\n\t\t\t  bit_mask);\n\t}\n}\n\nstatic void lan743x_ptp_tx_ts_enqueue_ts(struct lan743x_adapter *adapter,\n\t\t\t\t\t u32 seconds, u32 nano_seconds,\n\t\t\t\t\t u32 header)\n{\n\tstruct lan743x_ptp *ptp = &adapter->ptp;\n\n\tspin_lock_bh(&ptp->tx_ts_lock);\n\tif (ptp->tx_ts_queue_size < LAN743X_PTP_NUMBER_OF_TX_TIMESTAMPS) {\n\t\tptp->tx_ts_seconds_queue[ptp->tx_ts_queue_size] = seconds;\n\t\tptp->tx_ts_nseconds_queue[ptp->tx_ts_queue_size] = nano_seconds;\n\t\tptp->tx_ts_header_queue[ptp->tx_ts_queue_size] = header;\n\t\tptp->tx_ts_queue_size++;\n\t} else {\n\t\tnetif_err(adapter, drv, adapter->netdev,\n\t\t\t  \"tx ts queue overflow\\n\");\n\t}\n\tspin_unlock_bh(&ptp->tx_ts_lock);\n}\n\nstatic void lan743x_ptp_tx_ts_complete(struct lan743x_adapter *adapter)\n{\n\tstruct lan743x_ptp *ptp = &adapter->ptp;\n\tstruct skb_shared_hwtstamps tstamps;\n\tu32 header, nseconds, seconds;\n\tbool ignore_sync = false;\n\tstruct sk_buff *skb;\n\tint c, i;\n\n\tspin_lock_bh(&ptp->tx_ts_lock);\n\tc = ptp->tx_ts_skb_queue_size;\n\n\tif (c > ptp->tx_ts_queue_size)\n\t\tc = ptp->tx_ts_queue_size;\n\tif (c <= 0)\n\t\tgoto done;\n\n\tfor (i = 0; i < c; i++) {\n\t\tignore_sync = ((ptp->tx_ts_ignore_sync_queue &\n\t\t\t\tBIT(i)) != 0);\n\t\tskb = ptp->tx_ts_skb_queue[i];\n\t\tnseconds = ptp->tx_ts_nseconds_queue[i];\n\t\tseconds = ptp->tx_ts_seconds_queue[i];\n\t\theader = ptp->tx_ts_header_queue[i];\n\n\t\tmemset(&tstamps, 0, sizeof(tstamps));\n\t\ttstamps.hwtstamp = ktime_set(seconds, nseconds);\n\t\tif (!ignore_sync ||\n\t\t    ((header & PTP_TX_MSG_HEADER_MSG_TYPE_) !=\n\t\t    PTP_TX_MSG_HEADER_MSG_TYPE_SYNC_))\n\t\t\tskb_tstamp_tx(skb, &tstamps);\n\n\t\tdev_kfree_skb(skb);\n\n\t\tptp->tx_ts_skb_queue[i] = NULL;\n\t\tptp->tx_ts_seconds_queue[i] = 0;\n\t\tptp->tx_ts_nseconds_queue[i] = 0;\n\t\tptp->tx_ts_header_queue[i] = 0;\n\t}\n\n\t \n\tptp->tx_ts_ignore_sync_queue >>= c;\n\tfor (i = c; i < LAN743X_PTP_NUMBER_OF_TX_TIMESTAMPS; i++) {\n\t\tptp->tx_ts_skb_queue[i - c] = ptp->tx_ts_skb_queue[i];\n\t\tptp->tx_ts_seconds_queue[i - c] = ptp->tx_ts_seconds_queue[i];\n\t\tptp->tx_ts_nseconds_queue[i - c] = ptp->tx_ts_nseconds_queue[i];\n\t\tptp->tx_ts_header_queue[i - c] = ptp->tx_ts_header_queue[i];\n\n\t\tptp->tx_ts_skb_queue[i] = NULL;\n\t\tptp->tx_ts_seconds_queue[i] = 0;\n\t\tptp->tx_ts_nseconds_queue[i] = 0;\n\t\tptp->tx_ts_header_queue[i] = 0;\n\t}\n\tptp->tx_ts_skb_queue_size -= c;\n\tptp->tx_ts_queue_size -= c;\ndone:\n\tptp->pending_tx_timestamps -= c;\n\tspin_unlock_bh(&ptp->tx_ts_lock);\n}\n\nstatic int lan743x_ptp_reserve_event_ch(struct lan743x_adapter *adapter,\n\t\t\t\t\tint event_channel)\n{\n\tstruct lan743x_ptp *ptp = &adapter->ptp;\n\tint result = -ENODEV;\n\n\tmutex_lock(&ptp->command_lock);\n\tif (!(test_bit(event_channel, &ptp->used_event_ch))) {\n\t\tptp->used_event_ch |= BIT(event_channel);\n\t\tresult = event_channel;\n\t} else {\n\t\tnetif_warn(adapter, drv, adapter->netdev,\n\t\t\t   \"attempted to reserved a used event_channel = %d\\n\",\n\t\t\t   event_channel);\n\t}\n\tmutex_unlock(&ptp->command_lock);\n\treturn result;\n}\n\nstatic void lan743x_ptp_release_event_ch(struct lan743x_adapter *adapter,\n\t\t\t\t\t int event_channel)\n{\n\tstruct lan743x_ptp *ptp = &adapter->ptp;\n\n\tmutex_lock(&ptp->command_lock);\n\tif (test_bit(event_channel, &ptp->used_event_ch)) {\n\t\tptp->used_event_ch &= ~BIT(event_channel);\n\t} else {\n\t\tnetif_warn(adapter, drv, adapter->netdev,\n\t\t\t   \"attempted release on a not used event_channel = %d\\n\",\n\t\t\t   event_channel);\n\t}\n\tmutex_unlock(&ptp->command_lock);\n}\n\nstatic void lan743x_ptp_clock_get(struct lan743x_adapter *adapter,\n\t\t\t\t  u32 *seconds, u32 *nano_seconds,\n\t\t\t\t  u32 *sub_nano_seconds);\nstatic void lan743x_ptp_io_clock_get(struct lan743x_adapter *adapter,\n\t\t\t\t     u32 *sec, u32 *nsec, u32 *sub_nsec);\nstatic void lan743x_ptp_clock_step(struct lan743x_adapter *adapter,\n\t\t\t\t   s64 time_step_ns);\n\nstatic void lan743x_led_mux_enable(struct lan743x_adapter *adapter,\n\t\t\t\t   int pin, bool enable)\n{\n\tstruct lan743x_ptp *ptp = &adapter->ptp;\n\n\tif (ptp->leds_multiplexed &&\n\t    ptp->led_enabled[pin]) {\n\t\tu32 val = lan743x_csr_read(adapter, HW_CFG);\n\n\t\tif (enable)\n\t\t\tval |= LAN743X_LED_ENABLE(pin);\n\t\telse\n\t\t\tval &= ~LAN743X_LED_ENABLE(pin);\n\n\t\tlan743x_csr_write(adapter, HW_CFG, val);\n\t}\n}\n\nstatic void lan743x_led_mux_save(struct lan743x_adapter *adapter)\n{\n\tstruct lan743x_ptp *ptp = &adapter->ptp;\n\tu32 id_rev = adapter->csr.id_rev & ID_REV_ID_MASK_;\n\n\tif (id_rev == ID_REV_ID_LAN7430_) {\n\t\tint i;\n\t\tu32 val = lan743x_csr_read(adapter, HW_CFG);\n\n\t\tfor (i = 0; i < LAN7430_N_LED; i++) {\n\t\t\tbool led_enabled = (val & LAN743X_LED_ENABLE(i)) != 0;\n\n\t\t\tptp->led_enabled[i] = led_enabled;\n\t\t}\n\t\tptp->leds_multiplexed = true;\n\t} else {\n\t\tptp->leds_multiplexed = false;\n\t}\n}\n\nstatic void lan743x_led_mux_restore(struct lan743x_adapter *adapter)\n{\n\tu32 id_rev = adapter->csr.id_rev & ID_REV_ID_MASK_;\n\n\tif (id_rev == ID_REV_ID_LAN7430_) {\n\t\tint i;\n\n\t\tfor (i = 0; i < LAN7430_N_LED; i++)\n\t\t\tlan743x_led_mux_enable(adapter, i, true);\n\t}\n}\n\nstatic int lan743x_gpio_rsrv_ptp_out(struct lan743x_adapter *adapter,\n\t\t\t\t     int pin, int event_channel)\n{\n\tstruct lan743x_gpio *gpio = &adapter->gpio;\n\tunsigned long irq_flags = 0;\n\tint bit_mask = BIT(pin);\n\tint ret = -EBUSY;\n\n\tspin_lock_irqsave(&gpio->gpio_lock, irq_flags);\n\n\tif (!(gpio->used_bits & bit_mask)) {\n\t\tgpio->used_bits |= bit_mask;\n\t\tgpio->output_bits |= bit_mask;\n\t\tgpio->ptp_bits |= bit_mask;\n\n\t\t \n\t\tlan743x_led_mux_enable(adapter, pin, false);\n\n\t\t \n\t\tgpio->gpio_cfg0 |= GPIO_CFG0_GPIO_DIR_BIT_(pin);\n\t\tgpio->gpio_cfg0 &= ~GPIO_CFG0_GPIO_DATA_BIT_(pin);\n\t\tlan743x_csr_write(adapter, GPIO_CFG0, gpio->gpio_cfg0);\n\n\t\t \n\t\tgpio->gpio_cfg1 &= ~GPIO_CFG1_GPIOEN_BIT_(pin);\n\t\tgpio->gpio_cfg1 |= GPIO_CFG1_GPIOBUF_BIT_(pin);\n\t\tlan743x_csr_write(adapter, GPIO_CFG1, gpio->gpio_cfg1);\n\n\t\t \n\t\tgpio->gpio_cfg2 |= GPIO_CFG2_1588_POL_BIT_(pin);\n\t\tlan743x_csr_write(adapter, GPIO_CFG2, gpio->gpio_cfg2);\n\n\t\tif (event_channel == 0) {\n\t\t\t \n\t\t\tgpio->gpio_cfg3 &= ~GPIO_CFG3_1588_CH_SEL_BIT_(pin);\n\t\t} else {\n\t\t\t \n\t\t\tgpio->gpio_cfg3 |= GPIO_CFG3_1588_CH_SEL_BIT_(pin);\n\t\t}\n\t\tgpio->gpio_cfg3 |= GPIO_CFG3_1588_OE_BIT_(pin);\n\t\tlan743x_csr_write(adapter, GPIO_CFG3, gpio->gpio_cfg3);\n\n\t\tret = pin;\n\t}\n\tspin_unlock_irqrestore(&gpio->gpio_lock, irq_flags);\n\treturn ret;\n}\n\nstatic void lan743x_gpio_release(struct lan743x_adapter *adapter, int pin)\n{\n\tstruct lan743x_gpio *gpio = &adapter->gpio;\n\tunsigned long irq_flags = 0;\n\tint bit_mask = BIT(pin);\n\n\tspin_lock_irqsave(&gpio->gpio_lock, irq_flags);\n\tif (gpio->used_bits & bit_mask) {\n\t\tgpio->used_bits &= ~bit_mask;\n\t\tif (gpio->output_bits & bit_mask) {\n\t\t\tgpio->output_bits &= ~bit_mask;\n\n\t\t\tif (gpio->ptp_bits & bit_mask) {\n\t\t\t\tgpio->ptp_bits &= ~bit_mask;\n\t\t\t\t \n\t\t\t\tgpio->gpio_cfg3 &= ~GPIO_CFG3_1588_OE_BIT_(pin);\n\t\t\t\tlan743x_csr_write(adapter, GPIO_CFG3,\n\t\t\t\t\t\t  gpio->gpio_cfg3);\n\t\t\t}\n\t\t\t \n\n\t\t\t \n\t\t\tgpio->gpio_cfg1 |= GPIO_CFG1_GPIOEN_BIT_(pin);\n\t\t\tgpio->gpio_cfg1 &= ~GPIO_CFG1_GPIOBUF_BIT_(pin);\n\t\t\tlan743x_csr_write(adapter, GPIO_CFG1, gpio->gpio_cfg1);\n\n\t\t\t \n\t\t\tgpio->gpio_cfg0 &= ~GPIO_CFG0_GPIO_DIR_BIT_(pin);\n\t\t\tgpio->gpio_cfg0 &= ~GPIO_CFG0_GPIO_DATA_BIT_(pin);\n\t\t\tlan743x_csr_write(adapter, GPIO_CFG0, gpio->gpio_cfg0);\n\n\t\t\t \n\t\t\tlan743x_led_mux_enable(adapter, pin, true);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&gpio->gpio_lock, irq_flags);\n}\n\nstatic int lan743x_ptpci_adjfine(struct ptp_clock_info *ptpci, long scaled_ppm)\n{\n\tstruct lan743x_ptp *ptp =\n\t\tcontainer_of(ptpci, struct lan743x_ptp, ptp_clock_info);\n\tstruct lan743x_adapter *adapter =\n\t\tcontainer_of(ptp, struct lan743x_adapter, ptp);\n\tu32 lan743x_rate_adj = 0;\n\tu64 u64_delta;\n\n\tif ((scaled_ppm < (-LAN743X_PTP_MAX_FINE_ADJ_IN_SCALED_PPM)) ||\n\t    scaled_ppm > LAN743X_PTP_MAX_FINE_ADJ_IN_SCALED_PPM) {\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (diff_by_scaled_ppm(1ULL << 35, scaled_ppm, &u64_delta))\n\t\tlan743x_rate_adj = (u32)u64_delta;\n\telse\n\t\tlan743x_rate_adj = (u32)u64_delta | PTP_CLOCK_RATE_ADJ_DIR_;\n\n\tlan743x_csr_write(adapter, PTP_CLOCK_RATE_ADJ,\n\t\t\t  lan743x_rate_adj);\n\n\treturn 0;\n}\n\nstatic int lan743x_ptpci_adjtime(struct ptp_clock_info *ptpci, s64 delta)\n{\n\tstruct lan743x_ptp *ptp =\n\t\tcontainer_of(ptpci, struct lan743x_ptp, ptp_clock_info);\n\tstruct lan743x_adapter *adapter =\n\t\tcontainer_of(ptp, struct lan743x_adapter, ptp);\n\n\tlan743x_ptp_clock_step(adapter, delta);\n\n\treturn 0;\n}\n\nstatic int lan743x_ptpci_gettime64(struct ptp_clock_info *ptpci,\n\t\t\t\t   struct timespec64 *ts)\n{\n\tstruct lan743x_ptp *ptp =\n\t\tcontainer_of(ptpci, struct lan743x_ptp, ptp_clock_info);\n\tstruct lan743x_adapter *adapter =\n\t\tcontainer_of(ptp, struct lan743x_adapter, ptp);\n\tu32 nano_seconds = 0;\n\tu32 seconds = 0;\n\n\tif (adapter->is_pci11x1x)\n\t\tlan743x_ptp_io_clock_get(adapter, &seconds, &nano_seconds,\n\t\t\t\t\t NULL);\n\telse\n\t\tlan743x_ptp_clock_get(adapter, &seconds, &nano_seconds, NULL);\n\tts->tv_sec = seconds;\n\tts->tv_nsec = nano_seconds;\n\n\treturn 0;\n}\n\nstatic int lan743x_ptpci_settime64(struct ptp_clock_info *ptpci,\n\t\t\t\t   const struct timespec64 *ts)\n{\n\tstruct lan743x_ptp *ptp =\n\t\tcontainer_of(ptpci, struct lan743x_ptp, ptp_clock_info);\n\tstruct lan743x_adapter *adapter =\n\t\tcontainer_of(ptp, struct lan743x_adapter, ptp);\n\tu32 nano_seconds = 0;\n\tu32 seconds = 0;\n\n\tif (ts) {\n\t\tif (ts->tv_sec > 0xFFFFFFFFLL ||\n\t\t    ts->tv_sec < 0) {\n\t\t\tnetif_warn(adapter, drv, adapter->netdev,\n\t\t\t\t   \"ts->tv_sec out of range, %lld\\n\",\n\t\t\t\t   ts->tv_sec);\n\t\t\treturn -ERANGE;\n\t\t}\n\t\tif (ts->tv_nsec >= 1000000000L ||\n\t\t    ts->tv_nsec < 0) {\n\t\t\tnetif_warn(adapter, drv, adapter->netdev,\n\t\t\t\t   \"ts->tv_nsec out of range, %ld\\n\",\n\t\t\t\t   ts->tv_nsec);\n\t\t\treturn -ERANGE;\n\t\t}\n\t\tseconds = ts->tv_sec;\n\t\tnano_seconds = ts->tv_nsec;\n\t\tlan743x_ptp_clock_set(adapter, seconds, nano_seconds, 0);\n\t} else {\n\t\tnetif_warn(adapter, drv, adapter->netdev, \"ts == NULL\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void lan743x_ptp_perout_off(struct lan743x_adapter *adapter,\n\t\t\t\t   unsigned int index)\n{\n\tstruct lan743x_ptp *ptp = &adapter->ptp;\n\tu32 general_config = 0;\n\tstruct lan743x_ptp_perout *perout = &ptp->perout[index];\n\n\tif (perout->gpio_pin >= 0) {\n\t\tlan743x_gpio_release(adapter, perout->gpio_pin);\n\t\tperout->gpio_pin = -1;\n\t}\n\n\tif (perout->event_ch >= 0) {\n\t\t \n\t\tlan743x_csr_write(adapter,\n\t\t\t\t  PTP_CLOCK_TARGET_SEC_X(perout->event_ch),\n\t\t\t\t  0xFFFF0000);\n\t\tlan743x_csr_write(adapter,\n\t\t\t\t  PTP_CLOCK_TARGET_NS_X(perout->event_ch),\n\t\t\t\t  0);\n\n\t\tgeneral_config = lan743x_csr_read(adapter, PTP_GENERAL_CONFIG);\n\t\tgeneral_config |= PTP_GENERAL_CONFIG_RELOAD_ADD_X_\n\t\t\t\t  (perout->event_ch);\n\t\tlan743x_csr_write(adapter, PTP_GENERAL_CONFIG, general_config);\n\t\tlan743x_ptp_release_event_ch(adapter, perout->event_ch);\n\t\tperout->event_ch = -1;\n\t}\n}\n\nstatic int lan743x_ptp_perout(struct lan743x_adapter *adapter, int on,\n\t\t\t      struct ptp_perout_request *perout_request)\n{\n\tstruct lan743x_ptp *ptp = &adapter->ptp;\n\tu32 period_sec = 0, period_nsec = 0;\n\tu32 start_sec = 0, start_nsec = 0;\n\tu32 general_config = 0;\n\tint pulse_width = 0;\n\tint perout_pin = 0;\n\tunsigned int index = perout_request->index;\n\tstruct lan743x_ptp_perout *perout = &ptp->perout[index];\n\tint ret = 0;\n\n\t \n\tif (perout_request->flags & ~PTP_PEROUT_DUTY_CYCLE)\n\t\treturn -EOPNOTSUPP;\n\n\tif (on) {\n\t\tperout_pin = ptp_find_pin(ptp->ptp_clock, PTP_PF_PEROUT,\n\t\t\t\t\t  perout_request->index);\n\t\tif (perout_pin < 0)\n\t\t\treturn -EBUSY;\n\t} else {\n\t\tlan743x_ptp_perout_off(adapter, index);\n\t\treturn 0;\n\t}\n\n\tif (perout->event_ch >= 0 ||\n\t    perout->gpio_pin >= 0) {\n\t\t \n\t\tlan743x_ptp_perout_off(adapter, index);\n\t}\n\n\tperout->event_ch = lan743x_ptp_reserve_event_ch(adapter, index);\n\n\tif (perout->event_ch < 0) {\n\t\tnetif_warn(adapter, drv, adapter->netdev,\n\t\t\t   \"Failed to reserve event channel %d for PEROUT\\n\",\n\t\t\t   index);\n\t\tret = -EBUSY;\n\t\tgoto failed;\n\t}\n\n\tperout->gpio_pin = lan743x_gpio_rsrv_ptp_out(adapter,\n\t\t\t\t\t\t     perout_pin,\n\t\t\t\t\t\t     perout->event_ch);\n\n\tif (perout->gpio_pin < 0) {\n\t\tnetif_warn(adapter, drv, adapter->netdev,\n\t\t\t   \"Failed to reserve gpio %d for PEROUT\\n\",\n\t\t\t   perout_pin);\n\t\tret = -EBUSY;\n\t\tgoto failed;\n\t}\n\n\tstart_sec = perout_request->start.sec;\n\tstart_sec += perout_request->start.nsec / 1000000000;\n\tstart_nsec = perout_request->start.nsec % 1000000000;\n\n\tperiod_sec = perout_request->period.sec;\n\tperiod_sec += perout_request->period.nsec / 1000000000;\n\tperiod_nsec = perout_request->period.nsec % 1000000000;\n\n\tif (perout_request->flags & PTP_PEROUT_DUTY_CYCLE) {\n\t\tstruct timespec64 ts_on, ts_period;\n\t\ts64 wf_high, period64, half;\n\t\ts32 reminder;\n\n\t\tts_on.tv_sec = perout_request->on.sec;\n\t\tts_on.tv_nsec = perout_request->on.nsec;\n\t\twf_high = timespec64_to_ns(&ts_on);\n\t\tts_period.tv_sec = perout_request->period.sec;\n\t\tts_period.tv_nsec = perout_request->period.nsec;\n\t\tperiod64 = timespec64_to_ns(&ts_period);\n\n\t\tif (period64 < 200) {\n\t\t\tnetif_warn(adapter, drv, adapter->netdev,\n\t\t\t\t   \"perout period too small, minimum is 200nS\\n\");\n\t\t\tret = -EOPNOTSUPP;\n\t\t\tgoto failed;\n\t\t}\n\t\tif (wf_high >= period64) {\n\t\t\tnetif_warn(adapter, drv, adapter->netdev,\n\t\t\t\t   \"pulse width must be smaller than period\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto failed;\n\t\t}\n\n\t\t \n\t\thalf = div_s64_rem(period64, 2, &reminder);\n\t\tif (!reminder) {\n\t\t\tif (half == wf_high) {\n\t\t\t\t \n\t\t\t\tpulse_width = PTP_GENERAL_CONFIG_CLOCK_EVENT_TOGGLE_;\n\t\t\t\t \n\t\t\t\tts_period = ns_to_timespec64(div_s64(period64, 2));\n\t\t\t\tperiod_sec = ts_period.tv_sec;\n\t\t\t\tperiod_nsec = ts_period.tv_nsec;\n\n\t\t\t\tgoto program;\n\t\t\t}\n\t\t}\n\t\t \n\t\tif (wf_high == 200000000) {\n\t\t\tpulse_width = PTP_GENERAL_CONFIG_CLOCK_EVENT_200MS_;\n\t\t} else if (wf_high == 10000000) {\n\t\t\tpulse_width = PTP_GENERAL_CONFIG_CLOCK_EVENT_10MS_;\n\t\t} else if (wf_high == 1000000) {\n\t\t\tpulse_width = PTP_GENERAL_CONFIG_CLOCK_EVENT_1MS_;\n\t\t} else if (wf_high == 100000) {\n\t\t\tpulse_width = PTP_GENERAL_CONFIG_CLOCK_EVENT_100US_;\n\t\t} else if (wf_high == 10000) {\n\t\t\tpulse_width = PTP_GENERAL_CONFIG_CLOCK_EVENT_10US_;\n\t\t} else if (wf_high == 100) {\n\t\t\tpulse_width = PTP_GENERAL_CONFIG_CLOCK_EVENT_100NS_;\n\t\t} else {\n\t\t\tnetif_warn(adapter, drv, adapter->netdev,\n\t\t\t\t   \"duty cycle specified is not supported\\n\");\n\t\t\tret = -EOPNOTSUPP;\n\t\t\tgoto failed;\n\t\t}\n\t} else {\n\t\tif (period_sec == 0) {\n\t\t\tif (period_nsec >= 400000000) {\n\t\t\t\tpulse_width = PTP_GENERAL_CONFIG_CLOCK_EVENT_200MS_;\n\t\t\t} else if (period_nsec >= 20000000) {\n\t\t\t\tpulse_width = PTP_GENERAL_CONFIG_CLOCK_EVENT_10MS_;\n\t\t\t} else if (period_nsec >= 2000000) {\n\t\t\t\tpulse_width = PTP_GENERAL_CONFIG_CLOCK_EVENT_1MS_;\n\t\t\t} else if (period_nsec >= 200000) {\n\t\t\t\tpulse_width = PTP_GENERAL_CONFIG_CLOCK_EVENT_100US_;\n\t\t\t} else if (period_nsec >= 20000) {\n\t\t\t\tpulse_width = PTP_GENERAL_CONFIG_CLOCK_EVENT_10US_;\n\t\t\t} else if (period_nsec >= 200) {\n\t\t\t\tpulse_width = PTP_GENERAL_CONFIG_CLOCK_EVENT_100NS_;\n\t\t\t} else {\n\t\t\t\tnetif_warn(adapter, drv, adapter->netdev,\n\t\t\t\t\t   \"perout period too small, minimum is 200nS\\n\");\n\t\t\t\tret = -EOPNOTSUPP;\n\t\t\t\tgoto failed;\n\t\t\t}\n\t\t} else {\n\t\t\tpulse_width = PTP_GENERAL_CONFIG_CLOCK_EVENT_200MS_;\n\t\t}\n\t}\nprogram:\n\n\t \n\tlan743x_csr_write(adapter,\n\t\t\t  PTP_CLOCK_TARGET_SEC_X(perout->event_ch),\n\t\t\t  0xFFFF0000);\n\tlan743x_csr_write(adapter,\n\t\t\t  PTP_CLOCK_TARGET_NS_X(perout->event_ch), 0);\n\n\t \n\tgeneral_config = lan743x_csr_read(adapter, PTP_GENERAL_CONFIG);\n\tgeneral_config &= ~(PTP_GENERAL_CONFIG_CLOCK_EVENT_X_MASK_\n\t\t\t  (perout->event_ch));\n\tgeneral_config |= PTP_GENERAL_CONFIG_CLOCK_EVENT_X_SET_\n\t\t\t  (perout->event_ch, pulse_width);\n\tgeneral_config &= ~PTP_GENERAL_CONFIG_RELOAD_ADD_X_\n\t\t\t  (perout->event_ch);\n\tlan743x_csr_write(adapter, PTP_GENERAL_CONFIG, general_config);\n\n\t \n\tlan743x_csr_write(adapter,\n\t\t\t  PTP_CLOCK_TARGET_RELOAD_SEC_X(perout->event_ch),\n\t\t\t  period_sec);\n\tlan743x_csr_write(adapter,\n\t\t\t  PTP_CLOCK_TARGET_RELOAD_NS_X(perout->event_ch),\n\t\t\t  period_nsec);\n\n\t \n\tlan743x_csr_write(adapter,\n\t\t\t  PTP_CLOCK_TARGET_SEC_X(perout->event_ch),\n\t\t\t  start_sec);\n\tlan743x_csr_write(adapter,\n\t\t\t  PTP_CLOCK_TARGET_NS_X(perout->event_ch),\n\t\t\t  start_nsec);\n\n\treturn 0;\n\nfailed:\n\tlan743x_ptp_perout_off(adapter, index);\n\treturn ret;\n}\n\nstatic void lan743x_ptp_io_perout_off(struct lan743x_adapter *adapter,\n\t\t\t\t      u32 index)\n{\n\tstruct lan743x_ptp *ptp = &adapter->ptp;\n\tint perout_pin;\n\tint event_ch;\n\tu32 gen_cfg;\n\tint val;\n\n\tevent_ch = ptp->ptp_io_perout[index];\n\tif (event_ch >= 0) {\n\t\t \n\t\tlan743x_csr_write(adapter,\n\t\t\t\t  PTP_CLOCK_TARGET_SEC_X(event_ch),\n\t\t\t\t  0xFFFF0000);\n\t\tlan743x_csr_write(adapter,\n\t\t\t\t  PTP_CLOCK_TARGET_NS_X(event_ch),\n\t\t\t\t  0);\n\n\t\tgen_cfg = lan743x_csr_read(adapter, HS_PTP_GENERAL_CONFIG);\n\t\tgen_cfg &= ~(HS_PTP_GENERAL_CONFIG_CLOCK_EVENT_X_MASK_\n\t\t\t\t    (event_ch));\n\t\tgen_cfg &= ~(HS_PTP_GENERAL_CONFIG_EVENT_POL_X_(event_ch));\n\t\tgen_cfg |= HS_PTP_GENERAL_CONFIG_RELOAD_ADD_X_(event_ch);\n\t\tlan743x_csr_write(adapter, HS_PTP_GENERAL_CONFIG, gen_cfg);\n\t\tif (event_ch)\n\t\t\tlan743x_csr_write(adapter, PTP_INT_STS,\n\t\t\t\t\t  PTP_INT_TIMER_INT_B_);\n\t\telse\n\t\t\tlan743x_csr_write(adapter, PTP_INT_STS,\n\t\t\t\t\t  PTP_INT_TIMER_INT_A_);\n\t\tlan743x_ptp_release_event_ch(adapter, event_ch);\n\t\tptp->ptp_io_perout[index] = -1;\n\t}\n\n\tperout_pin = ptp_find_pin(ptp->ptp_clock, PTP_PF_PEROUT, index);\n\n\t \n\tval = lan743x_csr_read(adapter, PTP_IO_EVENT_OUTPUT_CFG);\n\n\t \n\tval &= ~PTP_IO_EVENT_OUTPUT_CFG_EN_(perout_pin);\n\tlan743x_csr_write(adapter, PTP_IO_EVENT_OUTPUT_CFG, val);\n\n\t \n\tval = lan743x_csr_read(adapter, PTP_IO_PIN_CFG);\n\tval &= ~PTP_IO_PIN_CFG_OBUF_TYPE_(perout_pin);\n\tlan743x_csr_write(adapter, PTP_IO_PIN_CFG, val);\n\t \n\tval = lan743x_csr_read(adapter, PTP_IO_PIN_CFG);\n}\n\nstatic int lan743x_ptp_io_perout(struct lan743x_adapter *adapter, int on,\n\t\t\t\t struct ptp_perout_request *perout_request)\n{\n\tstruct lan743x_ptp *ptp = &adapter->ptp;\n\tu32 period_sec, period_nsec;\n\tu32 start_sec, start_nsec;\n\tu32 pulse_sec, pulse_nsec;\n\tint pulse_width;\n\tint perout_pin;\n\tint event_ch;\n\tu32 gen_cfg;\n\tu32 index;\n\tint val;\n\n\tindex = perout_request->index;\n\tevent_ch = ptp->ptp_io_perout[index];\n\n\tif (on) {\n\t\tperout_pin = ptp_find_pin(ptp->ptp_clock, PTP_PF_PEROUT, index);\n\t\tif (perout_pin < 0)\n\t\t\treturn -EBUSY;\n\t} else {\n\t\tlan743x_ptp_io_perout_off(adapter, index);\n\t\treturn 0;\n\t}\n\n\tif (event_ch >= LAN743X_PTP_N_EVENT_CHAN) {\n\t\t \n\t\tlan743x_ptp_io_perout_off(adapter, index);\n\t}\n\n\tevent_ch = lan743x_ptp_reserve_event_ch(adapter, index);\n\tif (event_ch < 0) {\n\t\tnetif_warn(adapter, drv, adapter->netdev,\n\t\t\t   \"Failed to reserve event channel %d for PEROUT\\n\",\n\t\t\t   index);\n\t\tgoto failed;\n\t}\n\tptp->ptp_io_perout[index] = event_ch;\n\n\tif (perout_request->flags & PTP_PEROUT_DUTY_CYCLE) {\n\t\tpulse_sec = perout_request->on.sec;\n\t\tpulse_sec += perout_request->on.nsec / 1000000000;\n\t\tpulse_nsec = perout_request->on.nsec % 1000000000;\n\t} else {\n\t\tpulse_sec = perout_request->period.sec;\n\t\tpulse_sec += perout_request->period.nsec / 1000000000;\n\t\tpulse_nsec = perout_request->period.nsec % 1000000000;\n\t}\n\n\tif (pulse_sec == 0) {\n\t\tif (pulse_nsec >= 400000000) {\n\t\t\tpulse_width = PTP_GENERAL_CONFIG_CLOCK_EVENT_200MS_;\n\t\t} else if (pulse_nsec >= 200000000) {\n\t\t\tpulse_width = HS_PTP_GENERAL_CONFIG_CLOCK_EVENT_100MS_;\n\t\t} else if (pulse_nsec >= 100000000) {\n\t\t\tpulse_width = HS_PTP_GENERAL_CONFIG_CLOCK_EVENT_50MS_;\n\t\t} else if (pulse_nsec >= 20000000) {\n\t\t\tpulse_width = HS_PTP_GENERAL_CONFIG_CLOCK_EVENT_10MS_;\n\t\t} else if (pulse_nsec >= 10000000) {\n\t\t\tpulse_width = HS_PTP_GENERAL_CONFIG_CLOCK_EVENT_5MS_;\n\t\t} else if (pulse_nsec >= 2000000) {\n\t\t\tpulse_width = HS_PTP_GENERAL_CONFIG_CLOCK_EVENT_1MS_;\n\t\t} else if (pulse_nsec >= 1000000) {\n\t\t\tpulse_width = HS_PTP_GENERAL_CONFIG_CLOCK_EVENT_500US_;\n\t\t} else if (pulse_nsec >= 200000) {\n\t\t\tpulse_width = HS_PTP_GENERAL_CONFIG_CLOCK_EVENT_100US_;\n\t\t} else if (pulse_nsec >= 100000) {\n\t\t\tpulse_width = HS_PTP_GENERAL_CONFIG_CLOCK_EVENT_50US_;\n\t\t} else if (pulse_nsec >= 20000) {\n\t\t\tpulse_width = HS_PTP_GENERAL_CONFIG_CLOCK_EVENT_10US_;\n\t\t} else if (pulse_nsec >= 10000) {\n\t\t\tpulse_width = HS_PTP_GENERAL_CONFIG_CLOCK_EVENT_5US_;\n\t\t} else if (pulse_nsec >= 2000) {\n\t\t\tpulse_width = HS_PTP_GENERAL_CONFIG_CLOCK_EVENT_1US_;\n\t\t} else if (pulse_nsec >= 1000) {\n\t\t\tpulse_width = HS_PTP_GENERAL_CONFIG_CLOCK_EVENT_500NS_;\n\t\t} else if (pulse_nsec >= 200) {\n\t\t\tpulse_width = HS_PTP_GENERAL_CONFIG_CLOCK_EVENT_100NS_;\n\t\t} else {\n\t\t\tnetif_warn(adapter, drv, adapter->netdev,\n\t\t\t\t   \"perout period too small, min is 200nS\\n\");\n\t\t\tgoto failed;\n\t\t}\n\t} else {\n\t\tpulse_width = HS_PTP_GENERAL_CONFIG_CLOCK_EVENT_200MS_;\n\t}\n\n\t \n\tlan743x_csr_write(adapter,\n\t\t\t  PTP_CLOCK_TARGET_SEC_X(event_ch),\n\t\t\t  0xFFFF0000);\n\tlan743x_csr_write(adapter,\n\t\t\t  PTP_CLOCK_TARGET_NS_X(event_ch), 0);\n\n\t \n\tgen_cfg = lan743x_csr_read(adapter, HS_PTP_GENERAL_CONFIG);\n\tgen_cfg &= ~(HS_PTP_GENERAL_CONFIG_CLOCK_EVENT_X_MASK_(event_ch));\n\tgen_cfg |= HS_PTP_GENERAL_CONFIG_CLOCK_EVENT_X_SET_\n\t\t\t  (event_ch, pulse_width);\n\tgen_cfg |= HS_PTP_GENERAL_CONFIG_EVENT_POL_X_(event_ch);\n\tgen_cfg &= ~(HS_PTP_GENERAL_CONFIG_RELOAD_ADD_X_(event_ch));\n\tlan743x_csr_write(adapter, HS_PTP_GENERAL_CONFIG, gen_cfg);\n\n\t \n\tperiod_sec = perout_request->period.sec;\n\tperiod_sec += perout_request->period.nsec / 1000000000;\n\tperiod_nsec = perout_request->period.nsec % 1000000000;\n\tlan743x_csr_write(adapter,\n\t\t\t  PTP_CLOCK_TARGET_RELOAD_SEC_X(event_ch),\n\t\t\t  period_sec);\n\tlan743x_csr_write(adapter,\n\t\t\t  PTP_CLOCK_TARGET_RELOAD_NS_X(event_ch),\n\t\t\t  period_nsec);\n\n\tstart_sec = perout_request->start.sec;\n\tstart_sec += perout_request->start.nsec / 1000000000;\n\tstart_nsec = perout_request->start.nsec % 1000000000;\n\n\t \n\tlan743x_csr_write(adapter,\n\t\t\t  PTP_CLOCK_TARGET_SEC_X(event_ch),\n\t\t\t  start_sec);\n\tlan743x_csr_write(adapter,\n\t\t\t  PTP_CLOCK_TARGET_NS_X(event_ch),\n\t\t\t  start_nsec);\n\n\t \n\tval = lan743x_csr_read(adapter, PTP_CMD_CTL);\n\tval |= PTP_CMD_CTL_PTP_LTC_TARGET_READ_;\n\tlan743x_csr_write(adapter, PTP_CMD_CTL, val);\n\n\t \n\tval = lan743x_csr_read(adapter, PTP_IO_PIN_CFG);\n\tval |= PTP_IO_PIN_CFG_OBUF_TYPE_(perout_pin);\n\tlan743x_csr_write(adapter, PTP_IO_PIN_CFG, val);\n\n\t \n\tval = lan743x_csr_read(adapter, PTP_IO_EVENT_OUTPUT_CFG);\n\tif (event_ch)\n\t\t \n\t\tval |= PTP_IO_EVENT_OUTPUT_CFG_SEL_(perout_pin);\n\telse\n\t\t \n\t\tval &= ~PTP_IO_EVENT_OUTPUT_CFG_SEL_(perout_pin);\n\n\t \n\tval |= PTP_IO_EVENT_OUTPUT_CFG_EN_(perout_pin);\n\tlan743x_csr_write(adapter, PTP_IO_EVENT_OUTPUT_CFG, val);\n\n\treturn 0;\n\nfailed:\n\tlan743x_ptp_io_perout_off(adapter, index);\n\treturn -ENODEV;\n}\n\nstatic void lan743x_ptp_io_extts_off(struct lan743x_adapter *adapter,\n\t\t\t\t     u32 index)\n{\n\tstruct lan743x_ptp *ptp = &adapter->ptp;\n\tstruct lan743x_extts *extts;\n\tint val;\n\n\textts = &ptp->extts[index];\n\t \n\tif (extts->flags & PTP_FALLING_EDGE)\n\t\tval = PTP_INT_EN_FE_EN_CLR_(index);\n\telse\n\t\tval = PTP_INT_EN_RE_EN_CLR_(index);\n\tlan743x_csr_write(adapter, PTP_INT_EN_CLR, val);\n\n\t \n\tval = lan743x_csr_read(adapter, PTP_IO_CAP_CONFIG);\n\tif (extts->flags & PTP_FALLING_EDGE) {\n\t\tval &= ~PTP_IO_CAP_CONFIG_LOCK_FE_(index);\n\t\tval &= ~PTP_IO_CAP_CONFIG_FE_CAP_EN_(index);\n\t} else {\n\t\tval &= ~PTP_IO_CAP_CONFIG_LOCK_RE_(index);\n\t\tval &= ~PTP_IO_CAP_CONFIG_RE_CAP_EN_(index);\n\t}\n\tlan743x_csr_write(adapter, PTP_IO_CAP_CONFIG, val);\n\n\t \n\tval = lan743x_csr_read(adapter, PTP_IO_SEL);\n\tval &= ~PTP_IO_SEL_MASK_;\n\tlan743x_csr_write(adapter, PTP_IO_SEL, val);\n\n\t \n\tmemset(&extts->ts, 0, sizeof(struct timespec64));\n\textts->flags = 0;\n}\n\nstatic int lan743x_ptp_io_event_cap_en(struct lan743x_adapter *adapter,\n\t\t\t\t       u32 flags, u32 channel)\n{\n\tstruct lan743x_ptp *ptp = &adapter->ptp;\n\tint val;\n\n\tif ((flags & PTP_EXTTS_EDGES) ==  PTP_EXTTS_EDGES)\n\t\treturn -EOPNOTSUPP;\n\n\tmutex_lock(&ptp->command_lock);\n\t \n\tval = lan743x_csr_read(adapter, PTP_IO_CAP_CONFIG);\n\tif (flags & PTP_FALLING_EDGE) {\n\t\tval &= ~PTP_IO_CAP_CONFIG_LOCK_RE_(channel);\n\t\tval &= ~PTP_IO_CAP_CONFIG_RE_CAP_EN_(channel);\n\t\tval |= PTP_IO_CAP_CONFIG_LOCK_FE_(channel);\n\t\tval |= PTP_IO_CAP_CONFIG_FE_CAP_EN_(channel);\n\t} else {\n\t\t \n\t\tval &= ~PTP_IO_CAP_CONFIG_LOCK_FE_(channel);\n\t\tval &= ~PTP_IO_CAP_CONFIG_FE_CAP_EN_(channel);\n\t\tval |= PTP_IO_CAP_CONFIG_LOCK_RE_(channel);\n\t\tval |= PTP_IO_CAP_CONFIG_RE_CAP_EN_(channel);\n\t}\n\tlan743x_csr_write(adapter, PTP_IO_CAP_CONFIG, val);\n\n\t \n\tval = lan743x_csr_read(adapter, PTP_IO_SEL);\n\tval &= ~PTP_IO_SEL_MASK_;\n\tval |= channel << PTP_IO_SEL_SHIFT_;\n\tlan743x_csr_write(adapter, PTP_IO_SEL, val);\n\n\t \n\tif (flags & PTP_FALLING_EDGE)\n\t\tval = PTP_INT_EN_FE_EN_SET_(channel);\n\telse\n\t\tval = PTP_INT_EN_RE_EN_SET_(channel);\n\tlan743x_csr_write(adapter, PTP_INT_EN_SET, val);\n\n\tmutex_unlock(&ptp->command_lock);\n\n\treturn 0;\n}\n\nstatic int lan743x_ptp_io_extts(struct lan743x_adapter *adapter, int on,\n\t\t\t\tstruct ptp_extts_request *extts_request)\n{\n\tstruct lan743x_ptp *ptp = &adapter->ptp;\n\tu32 flags = extts_request->flags;\n\tu32 index = extts_request->index;\n\tstruct lan743x_extts *extts;\n\tint extts_pin;\n\tint ret = 0;\n\n\textts = &ptp->extts[index];\n\n\tif (on) {\n\t\textts_pin = ptp_find_pin(ptp->ptp_clock, PTP_PF_EXTTS, index);\n\t\tif (extts_pin < 0)\n\t\t\treturn -EBUSY;\n\n\t\tret = lan743x_ptp_io_event_cap_en(adapter, flags, index);\n\t\tif (!ret)\n\t\t\textts->flags = flags;\n\t} else {\n\t\tlan743x_ptp_io_extts_off(adapter, index);\n\t}\n\n\treturn ret;\n}\n\nstatic int lan743x_ptpci_enable(struct ptp_clock_info *ptpci,\n\t\t\t\tstruct ptp_clock_request *request, int on)\n{\n\tstruct lan743x_ptp *ptp =\n\t\tcontainer_of(ptpci, struct lan743x_ptp, ptp_clock_info);\n\tstruct lan743x_adapter *adapter =\n\t\tcontainer_of(ptp, struct lan743x_adapter, ptp);\n\n\tif (request) {\n\t\tswitch (request->type) {\n\t\tcase PTP_CLK_REQ_EXTTS:\n\t\t\tif (request->extts.index < ptpci->n_ext_ts)\n\t\t\t\treturn lan743x_ptp_io_extts(adapter, on,\n\t\t\t\t\t\t\t &request->extts);\n\t\t\treturn -EINVAL;\n\t\tcase PTP_CLK_REQ_PEROUT:\n\t\t\tif (request->perout.index < ptpci->n_per_out) {\n\t\t\t\tif (adapter->is_pci11x1x)\n\t\t\t\t\treturn lan743x_ptp_io_perout(adapter, on,\n\t\t\t\t\t\t\t     &request->perout);\n\t\t\t\telse\n\t\t\t\t\treturn lan743x_ptp_perout(adapter, on,\n\t\t\t\t\t\t\t  &request->perout);\n\t\t\t}\n\t\t\treturn -EINVAL;\n\t\tcase PTP_CLK_REQ_PPS:\n\t\t\treturn -EINVAL;\n\t\tdefault:\n\t\t\tnetif_err(adapter, drv, adapter->netdev,\n\t\t\t\t  \"request->type == %d, Unknown\\n\",\n\t\t\t\t  request->type);\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tnetif_err(adapter, drv, adapter->netdev, \"request == NULL\\n\");\n\t}\n\treturn 0;\n}\n\nstatic int lan743x_ptpci_verify_pin_config(struct ptp_clock_info *ptp,\n\t\t\t\t\t   unsigned int pin,\n\t\t\t\t\t   enum ptp_pin_function func,\n\t\t\t\t\t   unsigned int chan)\n{\n\tstruct lan743x_ptp *lan_ptp =\n\t\tcontainer_of(ptp, struct lan743x_ptp, ptp_clock_info);\n\tstruct lan743x_adapter *adapter =\n\t\tcontainer_of(lan_ptp, struct lan743x_adapter, ptp);\n\tint result = 0;\n\n\t \n\tswitch (func) {\n\tcase PTP_PF_NONE:\n\tcase PTP_PF_PEROUT:\n\t\tbreak;\n\tcase PTP_PF_EXTTS:\n\t\tif (!adapter->is_pci11x1x)\n\t\t\tresult = -1;\n\t\tbreak;\n\tcase PTP_PF_PHYSYNC:\n\tdefault:\n\t\tresult = -1;\n\t\tbreak;\n\t}\n\treturn result;\n}\n\nstatic void lan743x_ptp_io_event_clock_get(struct lan743x_adapter *adapter,\n\t\t\t\t\t   bool fe, u8 channel,\n\t\t\t\t\t   struct timespec64 *ts)\n{\n\tstruct lan743x_ptp *ptp = &adapter->ptp;\n\tstruct lan743x_extts *extts;\n\tu32 sec, nsec;\n\n\tmutex_lock(&ptp->command_lock);\n\tif (fe) {\n\t\tsec = lan743x_csr_read(adapter, PTP_IO_FE_LTC_SEC_CAP_X);\n\t\tnsec = lan743x_csr_read(adapter, PTP_IO_FE_LTC_NS_CAP_X);\n\t} else {\n\t\tsec = lan743x_csr_read(adapter, PTP_IO_RE_LTC_SEC_CAP_X);\n\t\tnsec = lan743x_csr_read(adapter, PTP_IO_RE_LTC_NS_CAP_X);\n\t}\n\n\tmutex_unlock(&ptp->command_lock);\n\n\t \n\textts = &ptp->extts[channel];\n\textts->ts.tv_sec = sec;\n\textts->ts.tv_nsec = nsec;\n\tts->tv_sec = sec;\n\tts->tv_nsec = nsec;\n}\n\nstatic long lan743x_ptpci_do_aux_work(struct ptp_clock_info *ptpci)\n{\n\tstruct lan743x_ptp *ptp =\n\t\tcontainer_of(ptpci, struct lan743x_ptp, ptp_clock_info);\n\tstruct lan743x_adapter *adapter =\n\t\tcontainer_of(ptp, struct lan743x_adapter, ptp);\n\tu32 cap_info, cause, header, nsec, seconds;\n\tbool new_timestamp_available = false;\n\tstruct ptp_clock_event ptp_event;\n\tstruct timespec64 ts;\n\tint ptp_int_sts;\n\tint count = 0;\n\tint channel;\n\ts64 ns;\n\n\tptp_int_sts = lan743x_csr_read(adapter, PTP_INT_STS);\n\twhile ((count < 100) && ptp_int_sts) {\n\t\tcount++;\n\n\t\tif (ptp_int_sts & PTP_INT_BIT_TX_TS_) {\n\t\t\tcap_info = lan743x_csr_read(adapter, PTP_CAP_INFO);\n\n\t\t\tif (PTP_CAP_INFO_TX_TS_CNT_GET_(cap_info) > 0) {\n\t\t\t\tseconds = lan743x_csr_read(adapter,\n\t\t\t\t\t\t\t   PTP_TX_EGRESS_SEC);\n\t\t\t\tnsec = lan743x_csr_read(adapter,\n\t\t\t\t\t\t\tPTP_TX_EGRESS_NS);\n\t\t\t\tcause = (nsec &\n\t\t\t\t\t PTP_TX_EGRESS_NS_CAPTURE_CAUSE_MASK_);\n\t\t\t\theader = lan743x_csr_read(adapter,\n\t\t\t\t\t\t\t  PTP_TX_MSG_HEADER);\n\n\t\t\t\tif (cause ==\n\t\t\t\t    PTP_TX_EGRESS_NS_CAPTURE_CAUSE_SW_) {\n\t\t\t\t\tnsec &= PTP_TX_EGRESS_NS_TS_NS_MASK_;\n\t\t\t\t\tlan743x_ptp_tx_ts_enqueue_ts(adapter,\n\t\t\t\t\t\t\t\t     seconds,\n\t\t\t\t\t\t\t\t     nsec,\n\t\t\t\t\t\t\t\t     header);\n\t\t\t\t\tnew_timestamp_available = true;\n\t\t\t\t} else if (cause ==\n\t\t\t\t\t   PTP_TX_EGRESS_NS_CAPTURE_CAUSE_AUTO_) {\n\t\t\t\t\tnetif_err(adapter, drv, adapter->netdev,\n\t\t\t\t\t\t  \"Auto capture cause not supported\\n\");\n\t\t\t\t} else {\n\t\t\t\t\tnetif_warn(adapter, drv, adapter->netdev,\n\t\t\t\t\t\t   \"unknown tx timestamp capture cause\\n\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnetif_warn(adapter, drv, adapter->netdev,\n\t\t\t\t\t   \"TX TS INT but no TX TS CNT\\n\");\n\t\t\t}\n\t\t\tlan743x_csr_write(adapter, PTP_INT_STS,\n\t\t\t\t\t  PTP_INT_BIT_TX_TS_);\n\t\t}\n\n\t\tif (ptp_int_sts & PTP_INT_IO_FE_MASK_) {\n\t\t\tdo {\n\t\t\t\tchannel = lan743x_get_channel((ptp_int_sts &\n\t\t\t\t\t\t\tPTP_INT_IO_FE_MASK_) >>\n\t\t\t\t\t\t\tPTP_INT_IO_FE_SHIFT_);\n\t\t\t\tif (channel >= 0 &&\n\t\t\t\t    channel < PCI11X1X_PTP_IO_MAX_CHANNELS) {\n\t\t\t\t\tlan743x_ptp_io_event_clock_get(adapter,\n\t\t\t\t\t\t\t\t       true,\n\t\t\t\t\t\t\t\t       channel,\n\t\t\t\t\t\t\t\t       &ts);\n\t\t\t\t\t \n\t\t\t\t\tns = timespec64_to_ns(&ts);\n\t\t\t\t\tptp_event.timestamp = ns;\n\t\t\t\t\tptp_event.index = channel;\n\t\t\t\t\tptp_event.type = PTP_CLOCK_EXTTS;\n\t\t\t\t\tptp_clock_event(ptp->ptp_clock,\n\t\t\t\t\t\t\t&ptp_event);\n\t\t\t\t\tlan743x_csr_write(adapter, PTP_INT_STS,\n\t\t\t\t\t\t\t  PTP_INT_IO_FE_SET_\n\t\t\t\t\t\t\t  (channel));\n\t\t\t\t\tptp_int_sts &= ~(1 <<\n\t\t\t\t\t\t\t (PTP_INT_IO_FE_SHIFT_ +\n\t\t\t\t\t\t\t  channel));\n\t\t\t\t} else {\n\t\t\t\t\t \n\t\t\t\t\tlan743x_csr_write(adapter, PTP_INT_STS,\n\t\t\t\t\t\t\t  PTP_INT_IO_FE_MASK_);\n\t\t\t\t\tptp_int_sts &= ~PTP_INT_IO_FE_MASK_;\n\t\t\t\t}\n\t\t\t} while (ptp_int_sts & PTP_INT_IO_FE_MASK_);\n\t\t}\n\n\t\tif (ptp_int_sts & PTP_INT_IO_RE_MASK_) {\n\t\t\tdo {\n\t\t\t\tchannel = lan743x_get_channel((ptp_int_sts &\n\t\t\t\t\t\t       PTP_INT_IO_RE_MASK_) >>\n\t\t\t\t\t\t       PTP_INT_IO_RE_SHIFT_);\n\t\t\t\tif (channel >= 0 &&\n\t\t\t\t    channel < PCI11X1X_PTP_IO_MAX_CHANNELS) {\n\t\t\t\t\tlan743x_ptp_io_event_clock_get(adapter,\n\t\t\t\t\t\t\t\t       false,\n\t\t\t\t\t\t\t\t       channel,\n\t\t\t\t\t\t\t\t       &ts);\n\t\t\t\t\t \n\t\t\t\t\tns = timespec64_to_ns(&ts);\n\t\t\t\t\tptp_event.timestamp = ns;\n\t\t\t\t\tptp_event.index = channel;\n\t\t\t\t\tptp_event.type = PTP_CLOCK_EXTTS;\n\t\t\t\t\tptp_clock_event(ptp->ptp_clock,\n\t\t\t\t\t\t\t&ptp_event);\n\t\t\t\t\tlan743x_csr_write(adapter, PTP_INT_STS,\n\t\t\t\t\t\t\t  PTP_INT_IO_RE_SET_\n\t\t\t\t\t\t\t  (channel));\n\t\t\t\t\tptp_int_sts &= ~(1 <<\n\t\t\t\t\t\t\t (PTP_INT_IO_RE_SHIFT_ +\n\t\t\t\t\t\t\t  channel));\n\t\t\t\t} else {\n\t\t\t\t\t \n\t\t\t\t\tlan743x_csr_write(adapter, PTP_INT_STS,\n\t\t\t\t\t\t\t  PTP_INT_IO_RE_MASK_);\n\t\t\t\t\tptp_int_sts &= ~PTP_INT_IO_RE_MASK_;\n\t\t\t\t}\n\t\t\t} while (ptp_int_sts & PTP_INT_IO_RE_MASK_);\n\t\t}\n\n\t\tptp_int_sts = lan743x_csr_read(adapter, PTP_INT_STS);\n\t}\n\n\tif (new_timestamp_available)\n\t\tlan743x_ptp_tx_ts_complete(adapter);\n\n\tlan743x_csr_write(adapter, INT_EN_SET, INT_BIT_1588_);\n\n\treturn -1;\n}\n\nstatic void lan743x_ptp_clock_get(struct lan743x_adapter *adapter,\n\t\t\t\t  u32 *seconds, u32 *nano_seconds,\n\t\t\t\t  u32 *sub_nano_seconds)\n{\n\tstruct lan743x_ptp *ptp = &adapter->ptp;\n\n\tmutex_lock(&ptp->command_lock);\n\n\tlan743x_csr_write(adapter, PTP_CMD_CTL, PTP_CMD_CTL_PTP_CLOCK_READ_);\n\tlan743x_ptp_wait_till_cmd_done(adapter, PTP_CMD_CTL_PTP_CLOCK_READ_);\n\n\tif (seconds)\n\t\t(*seconds) = lan743x_csr_read(adapter, PTP_CLOCK_SEC);\n\n\tif (nano_seconds)\n\t\t(*nano_seconds) = lan743x_csr_read(adapter, PTP_CLOCK_NS);\n\n\tif (sub_nano_seconds)\n\t\t(*sub_nano_seconds) =\n\t\tlan743x_csr_read(adapter, PTP_CLOCK_SUBNS);\n\n\tmutex_unlock(&ptp->command_lock);\n}\n\nstatic void lan743x_ptp_io_clock_get(struct lan743x_adapter *adapter,\n\t\t\t\t     u32 *sec, u32 *nsec, u32 *sub_nsec)\n{\n\tstruct lan743x_ptp *ptp = &adapter->ptp;\n\n\tmutex_lock(&ptp->command_lock);\n\tlan743x_csr_write(adapter, PTP_CMD_CTL, PTP_CMD_CTL_PTP_CLOCK_READ_);\n\tlan743x_ptp_wait_till_cmd_done(adapter, PTP_CMD_CTL_PTP_CLOCK_READ_);\n\n\tif (sec)\n\t\t(*sec) = lan743x_csr_read(adapter, PTP_LTC_RD_SEC_LO);\n\n\tif (nsec)\n\t\t(*nsec) = lan743x_csr_read(adapter, PTP_LTC_RD_NS);\n\n\tif (sub_nsec)\n\t\t(*sub_nsec) =\n\t\tlan743x_csr_read(adapter, PTP_LTC_RD_SUBNS);\n\n\tmutex_unlock(&ptp->command_lock);\n}\n\nstatic void lan743x_ptp_clock_step(struct lan743x_adapter *adapter,\n\t\t\t\t   s64 time_step_ns)\n{\n\tstruct lan743x_ptp *ptp = &adapter->ptp;\n\tu32 nano_seconds_step = 0;\n\tu64 abs_time_step_ns = 0;\n\tu32 unsigned_seconds = 0;\n\tu32 nano_seconds = 0;\n\tu32 remainder = 0;\n\ts32 seconds = 0;\n\n\tif (time_step_ns >  15000000000LL) {\n\t\t \n\t\tif (adapter->is_pci11x1x)\n\t\t\tlan743x_ptp_io_clock_get(adapter, &unsigned_seconds,\n\t\t\t\t\t\t &nano_seconds, NULL);\n\t\telse\n\t\t\tlan743x_ptp_clock_get(adapter, &unsigned_seconds,\n\t\t\t\t\t      &nano_seconds, NULL);\n\t\tunsigned_seconds += div_u64_rem(time_step_ns, 1000000000LL,\n\t\t\t\t\t\t&remainder);\n\t\tnano_seconds += remainder;\n\t\tif (nano_seconds >= 1000000000) {\n\t\t\tunsigned_seconds++;\n\t\t\tnano_seconds -= 1000000000;\n\t\t}\n\t\tlan743x_ptp_clock_set(adapter, unsigned_seconds,\n\t\t\t\t      nano_seconds, 0);\n\t\treturn;\n\t} else if (time_step_ns < -15000000000LL) {\n\t\t \n\t\ttime_step_ns = -time_step_ns;\n\n\t\tif (adapter->is_pci11x1x) {\n\t\t\tlan743x_ptp_io_clock_get(adapter, &unsigned_seconds,\n\t\t\t\t\t\t &nano_seconds, NULL);\n\t\t} else {\n\t\t\tlan743x_ptp_clock_get(adapter, &unsigned_seconds,\n\t\t\t\t\t      &nano_seconds, NULL);\n\t\t}\n\t\tunsigned_seconds -= div_u64_rem(time_step_ns, 1000000000LL,\n\t\t\t\t\t\t&remainder);\n\t\tnano_seconds_step = remainder;\n\t\tif (nano_seconds < nano_seconds_step) {\n\t\t\tunsigned_seconds--;\n\t\t\tnano_seconds += 1000000000;\n\t\t}\n\t\tnano_seconds -= nano_seconds_step;\n\t\tlan743x_ptp_clock_set(adapter, unsigned_seconds,\n\t\t\t\t      nano_seconds, 0);\n\t\treturn;\n\t}\n\n\t \n\tif (time_step_ns >= 0) {\n\t\tabs_time_step_ns = (u64)(time_step_ns);\n\t\tseconds = (s32)div_u64_rem(abs_time_step_ns, 1000000000,\n\t\t\t\t\t   &remainder);\n\t\tnano_seconds = (u32)remainder;\n\t} else {\n\t\tabs_time_step_ns = (u64)(-time_step_ns);\n\t\tseconds = -((s32)div_u64_rem(abs_time_step_ns, 1000000000,\n\t\t\t\t\t     &remainder));\n\t\tnano_seconds = (u32)remainder;\n\t\tif (nano_seconds > 0) {\n\t\t\t \n\t\t\tseconds--;\n\t\t\tnano_seconds = (1000000000 - nano_seconds);\n\t\t}\n\t}\n\n\tif (nano_seconds > 0) {\n\t\t \n\t\tnano_seconds += 8;\n\t}\n\n\tif (nano_seconds >= 1000000000) {\n\t\t \n\t\tseconds++;\n\t\tnano_seconds -= 1000000000;\n\t}\n\n\twhile (seconds) {\n\t\tmutex_lock(&ptp->command_lock);\n\t\tif (seconds > 0) {\n\t\t\tu32 adjustment_value = (u32)seconds;\n\n\t\t\tif (adjustment_value > 0xF)\n\t\t\t\tadjustment_value = 0xF;\n\t\t\tlan743x_csr_write(adapter, PTP_CLOCK_STEP_ADJ,\n\t\t\t\t\t  PTP_CLOCK_STEP_ADJ_DIR_ |\n\t\t\t\t\t  adjustment_value);\n\t\t\tseconds -= ((s32)adjustment_value);\n\t\t} else {\n\t\t\tu32 adjustment_value = (u32)(-seconds);\n\n\t\t\tif (adjustment_value > 0xF)\n\t\t\t\tadjustment_value = 0xF;\n\t\t\tlan743x_csr_write(adapter, PTP_CLOCK_STEP_ADJ,\n\t\t\t\t\t  adjustment_value);\n\t\t\tseconds += ((s32)adjustment_value);\n\t\t}\n\t\tlan743x_csr_write(adapter, PTP_CMD_CTL,\n\t\t\t\t  PTP_CMD_CTL_PTP_CLOCK_STEP_SEC_);\n\t\tlan743x_ptp_wait_till_cmd_done(adapter,\n\t\t\t\t\t       PTP_CMD_CTL_PTP_CLOCK_STEP_SEC_);\n\t\tmutex_unlock(&ptp->command_lock);\n\t}\n\tif (nano_seconds) {\n\t\tmutex_lock(&ptp->command_lock);\n\t\tlan743x_csr_write(adapter, PTP_CLOCK_STEP_ADJ,\n\t\t\t\t  PTP_CLOCK_STEP_ADJ_DIR_ |\n\t\t\t\t  (nano_seconds &\n\t\t\t\t  PTP_CLOCK_STEP_ADJ_VALUE_MASK_));\n\t\tlan743x_csr_write(adapter, PTP_CMD_CTL,\n\t\t\t\t  PTP_CMD_CTL_PTP_CLK_STP_NSEC_);\n\t\tlan743x_ptp_wait_till_cmd_done(adapter,\n\t\t\t\t\t       PTP_CMD_CTL_PTP_CLK_STP_NSEC_);\n\t\tmutex_unlock(&ptp->command_lock);\n\t}\n}\n\nvoid lan743x_ptp_isr(void *context)\n{\n\tstruct lan743x_adapter *adapter = (struct lan743x_adapter *)context;\n\tstruct lan743x_ptp *ptp = NULL;\n\tint enable_flag = 1;\n\tu32 ptp_int_sts = 0;\n\n\tptp = &adapter->ptp;\n\n\tlan743x_csr_write(adapter, INT_EN_CLR, INT_BIT_1588_);\n\n\tptp_int_sts = lan743x_csr_read(adapter, PTP_INT_STS);\n\tptp_int_sts &= lan743x_csr_read(adapter, PTP_INT_EN_SET);\n\n\tif (ptp_int_sts & PTP_INT_BIT_TX_TS_) {\n\t\tptp_schedule_worker(ptp->ptp_clock, 0);\n\t\tenable_flag = 0; \n\t}\n\tif (ptp_int_sts & PTP_INT_BIT_TX_SWTS_ERR_) {\n\t\tnetif_err(adapter, drv, adapter->netdev,\n\t\t\t  \"PTP TX Software Timestamp Error\\n\");\n\t\t \n\t\tlan743x_csr_write(adapter, PTP_INT_STS,\n\t\t\t\t  PTP_INT_BIT_TX_SWTS_ERR_);\n\t}\n\tif (ptp_int_sts & PTP_INT_BIT_TIMER_B_) {\n\t\t \n\t\tlan743x_csr_write(adapter, PTP_INT_STS,\n\t\t\t\t  PTP_INT_BIT_TIMER_B_);\n\t}\n\tif (ptp_int_sts & PTP_INT_BIT_TIMER_A_) {\n\t\t \n\t\tlan743x_csr_write(adapter, PTP_INT_STS,\n\t\t\t\t  PTP_INT_BIT_TIMER_A_);\n\t}\n\n\tif (enable_flag) {\n\t\t \n\t\tlan743x_csr_write(adapter, INT_EN_SET, INT_BIT_1588_);\n\t}\n}\n\nstatic void lan743x_ptp_tx_ts_enqueue_skb(struct lan743x_adapter *adapter,\n\t\t\t\t\t  struct sk_buff *skb, bool ignore_sync)\n{\n\tstruct lan743x_ptp *ptp = &adapter->ptp;\n\n\tspin_lock_bh(&ptp->tx_ts_lock);\n\tif (ptp->tx_ts_skb_queue_size < LAN743X_PTP_NUMBER_OF_TX_TIMESTAMPS) {\n\t\tptp->tx_ts_skb_queue[ptp->tx_ts_skb_queue_size] = skb;\n\t\tif (ignore_sync)\n\t\t\tptp->tx_ts_ignore_sync_queue |=\n\t\t\t\tBIT(ptp->tx_ts_skb_queue_size);\n\t\tptp->tx_ts_skb_queue_size++;\n\t} else {\n\t\t \n\t\tnetif_err(adapter, drv, adapter->netdev,\n\t\t\t  \"tx ts skb queue overflow\\n\");\n\t\tdev_kfree_skb(skb);\n\t}\n\tspin_unlock_bh(&ptp->tx_ts_lock);\n}\n\nstatic void lan743x_ptp_sync_to_system_clock(struct lan743x_adapter *adapter)\n{\n\tstruct timespec64 ts;\n\n\tktime_get_clocktai_ts64(&ts);\n\n\tlan743x_ptp_clock_set(adapter, ts.tv_sec, ts.tv_nsec, 0);\n}\n\nvoid lan743x_ptp_update_latency(struct lan743x_adapter *adapter,\n\t\t\t\tu32 link_speed)\n{\n\tswitch (link_speed) {\n\tcase 10:\n\t\tlan743x_csr_write(adapter, PTP_LATENCY,\n\t\t\t\t  PTP_LATENCY_TX_SET_(0) |\n\t\t\t\t  PTP_LATENCY_RX_SET_(0));\n\t\tbreak;\n\tcase 100:\n\t\tlan743x_csr_write(adapter, PTP_LATENCY,\n\t\t\t\t  PTP_LATENCY_TX_SET_(181) |\n\t\t\t\t  PTP_LATENCY_RX_SET_(594));\n\t\tbreak;\n\tcase 1000:\n\t\tlan743x_csr_write(adapter, PTP_LATENCY,\n\t\t\t\t  PTP_LATENCY_TX_SET_(30) |\n\t\t\t\t  PTP_LATENCY_RX_SET_(525));\n\t\tbreak;\n\t}\n}\n\nint lan743x_ptp_init(struct lan743x_adapter *adapter)\n{\n\tstruct lan743x_ptp *ptp = &adapter->ptp;\n\tint i;\n\n\tmutex_init(&ptp->command_lock);\n\tspin_lock_init(&ptp->tx_ts_lock);\n\tptp->used_event_ch = 0;\n\n\tfor (i = 0; i < LAN743X_PTP_N_EVENT_CHAN; i++) {\n\t\tptp->perout[i].event_ch = -1;\n\t\tptp->perout[i].gpio_pin = -1;\n\t}\n\n\tlan743x_led_mux_save(adapter);\n\n\treturn 0;\n}\n\nint lan743x_ptp_open(struct lan743x_adapter *adapter)\n{\n\tstruct lan743x_ptp *ptp = &adapter->ptp;\n\tint ret = -ENODEV;\n\tu32 temp;\n\tint i;\n\tint n_pins;\n\n\tlan743x_ptp_reset(adapter);\n\tlan743x_ptp_sync_to_system_clock(adapter);\n\ttemp = lan743x_csr_read(adapter, PTP_TX_MOD2);\n\ttemp |= PTP_TX_MOD2_TX_PTP_CLR_UDPV4_CHKSUM_;\n\tlan743x_csr_write(adapter, PTP_TX_MOD2, temp);\n\tlan743x_ptp_enable(adapter);\n\tlan743x_csr_write(adapter, INT_EN_SET, INT_BIT_1588_);\n\tlan743x_csr_write(adapter, PTP_INT_EN_SET,\n\t\t\t  PTP_INT_BIT_TX_SWTS_ERR_ | PTP_INT_BIT_TX_TS_);\n\tptp->flags |= PTP_FLAG_ISR_ENABLED;\n\n\tif (!IS_ENABLED(CONFIG_PTP_1588_CLOCK))\n\t\treturn 0;\n\n\tswitch (adapter->csr.id_rev & ID_REV_ID_MASK_) {\n\tcase ID_REV_ID_LAN7430_:\n\t\tn_pins = LAN7430_N_GPIO;\n\t\tbreak;\n\tcase ID_REV_ID_LAN7431_:\n\tcase ID_REV_ID_A011_:\n\tcase ID_REV_ID_A041_:\n\t\tn_pins = LAN7431_N_GPIO;\n\t\tbreak;\n\tdefault:\n\t\tnetif_warn(adapter, drv, adapter->netdev,\n\t\t\t   \"Unknown LAN743x (%08x). Assuming no GPIO\\n\",\n\t\t\t   adapter->csr.id_rev);\n\t\tn_pins = 0;\n\t\tbreak;\n\t}\n\n\tif (n_pins > LAN743X_PTP_N_GPIO)\n\t\tn_pins = LAN743X_PTP_N_GPIO;\n\n\tfor (i = 0; i < n_pins; i++) {\n\t\tstruct ptp_pin_desc *ptp_pin = &ptp->pin_config[i];\n\n\t\tsnprintf(ptp_pin->name,\n\t\t\t sizeof(ptp_pin->name), \"lan743x_ptp_pin_%02d\", i);\n\t\tptp_pin->index = i;\n\t\tptp_pin->func = PTP_PF_NONE;\n\t}\n\n\tptp->ptp_clock_info.owner = THIS_MODULE;\n\tsnprintf(ptp->ptp_clock_info.name, 16, \"%pm\",\n\t\t adapter->netdev->dev_addr);\n\tptp->ptp_clock_info.max_adj = LAN743X_PTP_MAX_FREQ_ADJ_IN_PPB;\n\tptp->ptp_clock_info.n_alarm = 0;\n\tptp->ptp_clock_info.n_ext_ts = LAN743X_PTP_N_EXTTS;\n\tptp->ptp_clock_info.n_per_out = LAN743X_PTP_N_EVENT_CHAN;\n\tptp->ptp_clock_info.n_pins = n_pins;\n\tptp->ptp_clock_info.pps = LAN743X_PTP_N_PPS;\n\tptp->ptp_clock_info.pin_config = ptp->pin_config;\n\tptp->ptp_clock_info.adjfine = lan743x_ptpci_adjfine;\n\tptp->ptp_clock_info.adjtime = lan743x_ptpci_adjtime;\n\tptp->ptp_clock_info.gettime64 = lan743x_ptpci_gettime64;\n\tptp->ptp_clock_info.getcrosststamp = NULL;\n\tptp->ptp_clock_info.settime64 = lan743x_ptpci_settime64;\n\tptp->ptp_clock_info.enable = lan743x_ptpci_enable;\n\tptp->ptp_clock_info.do_aux_work = lan743x_ptpci_do_aux_work;\n\tptp->ptp_clock_info.verify = lan743x_ptpci_verify_pin_config;\n\n\tptp->ptp_clock = ptp_clock_register(&ptp->ptp_clock_info,\n\t\t\t\t\t    &adapter->pdev->dev);\n\n\tif (IS_ERR(ptp->ptp_clock)) {\n\t\tnetif_err(adapter, ifup, adapter->netdev,\n\t\t\t  \"ptp_clock_register failed\\n\");\n\t\tgoto done;\n\t}\n\tptp->flags |= PTP_FLAG_PTP_CLOCK_REGISTERED;\n\tnetif_info(adapter, ifup, adapter->netdev,\n\t\t   \"successfully registered ptp clock\\n\");\n\n\treturn 0;\ndone:\n\tlan743x_ptp_close(adapter);\n\treturn ret;\n}\n\nvoid lan743x_ptp_close(struct lan743x_adapter *adapter)\n{\n\tstruct lan743x_ptp *ptp = &adapter->ptp;\n\tint index;\n\n\tif (IS_ENABLED(CONFIG_PTP_1588_CLOCK) &&\n\t    (ptp->flags & PTP_FLAG_PTP_CLOCK_REGISTERED)) {\n\t\tptp_clock_unregister(ptp->ptp_clock);\n\t\tptp->ptp_clock = NULL;\n\t\tptp->flags &= ~PTP_FLAG_PTP_CLOCK_REGISTERED;\n\t\tnetif_info(adapter, drv, adapter->netdev,\n\t\t\t   \"ptp clock unregister\\n\");\n\t}\n\n\tif (ptp->flags & PTP_FLAG_ISR_ENABLED) {\n\t\tlan743x_csr_write(adapter, PTP_INT_EN_CLR,\n\t\t\t\t  PTP_INT_BIT_TX_SWTS_ERR_ |\n\t\t\t\t  PTP_INT_BIT_TX_TS_);\n\t\tlan743x_csr_write(adapter, INT_EN_CLR, INT_BIT_1588_);\n\t\tptp->flags &= ~PTP_FLAG_ISR_ENABLED;\n\t}\n\n\t \n\tlan743x_ptp_tx_ts_complete(adapter);\n\tspin_lock_bh(&ptp->tx_ts_lock);\n\tfor (index = 0;\n\t\tindex < LAN743X_PTP_NUMBER_OF_TX_TIMESTAMPS;\n\t\tindex++) {\n\t\tstruct sk_buff *skb = ptp->tx_ts_skb_queue[index];\n\n\t\tdev_kfree_skb(skb);\n\t\tptp->tx_ts_skb_queue[index] = NULL;\n\t\tptp->tx_ts_seconds_queue[index] = 0;\n\t\tptp->tx_ts_nseconds_queue[index] = 0;\n\t}\n\tptp->tx_ts_skb_queue_size = 0;\n\tptp->tx_ts_queue_size = 0;\n\tptp->pending_tx_timestamps = 0;\n\tspin_unlock_bh(&ptp->tx_ts_lock);\n\n\tlan743x_led_mux_restore(adapter);\n\n\tlan743x_ptp_disable(adapter);\n}\n\nstatic void lan743x_ptp_set_sync_ts_insert(struct lan743x_adapter *adapter,\n\t\t\t\t\t   bool ts_insert_enable)\n{\n\tu32 ptp_tx_mod = lan743x_csr_read(adapter, PTP_TX_MOD);\n\n\tif (ts_insert_enable)\n\t\tptp_tx_mod |= PTP_TX_MOD_TX_PTP_SYNC_TS_INSERT_;\n\telse\n\t\tptp_tx_mod &= ~PTP_TX_MOD_TX_PTP_SYNC_TS_INSERT_;\n\n\tlan743x_csr_write(adapter, PTP_TX_MOD, ptp_tx_mod);\n}\n\nstatic bool lan743x_ptp_is_enabled(struct lan743x_adapter *adapter)\n{\n\tif (lan743x_csr_read(adapter, PTP_CMD_CTL) & PTP_CMD_CTL_PTP_ENABLE_)\n\t\treturn true;\n\treturn false;\n}\n\nstatic void lan743x_ptp_enable(struct lan743x_adapter *adapter)\n{\n\tstruct lan743x_ptp *ptp = &adapter->ptp;\n\n\tmutex_lock(&ptp->command_lock);\n\n\tif (lan743x_ptp_is_enabled(adapter)) {\n\t\tnetif_warn(adapter, drv, adapter->netdev,\n\t\t\t   \"PTP already enabled\\n\");\n\t\tgoto done;\n\t}\n\tlan743x_csr_write(adapter, PTP_CMD_CTL, PTP_CMD_CTL_PTP_ENABLE_);\ndone:\n\tmutex_unlock(&ptp->command_lock);\n}\n\nstatic void lan743x_ptp_disable(struct lan743x_adapter *adapter)\n{\n\tstruct lan743x_ptp *ptp = &adapter->ptp;\n\n\tmutex_lock(&ptp->command_lock);\n\tif (!lan743x_ptp_is_enabled(adapter)) {\n\t\tnetif_warn(adapter, drv, adapter->netdev,\n\t\t\t   \"PTP already disabled\\n\");\n\t\tgoto done;\n\t}\n\tlan743x_csr_write(adapter, PTP_CMD_CTL, PTP_CMD_CTL_PTP_DISABLE_);\n\tlan743x_ptp_wait_till_cmd_done(adapter, PTP_CMD_CTL_PTP_ENABLE_);\ndone:\n\tmutex_unlock(&ptp->command_lock);\n}\n\nstatic void lan743x_ptp_reset(struct lan743x_adapter *adapter)\n{\n\tstruct lan743x_ptp *ptp = &adapter->ptp;\n\n\tmutex_lock(&ptp->command_lock);\n\n\tif (lan743x_ptp_is_enabled(adapter)) {\n\t\tnetif_err(adapter, drv, adapter->netdev,\n\t\t\t  \"Attempting reset while enabled\\n\");\n\t\tgoto done;\n\t}\n\n\tlan743x_csr_write(adapter, PTP_CMD_CTL, PTP_CMD_CTL_PTP_RESET_);\n\tlan743x_ptp_wait_till_cmd_done(adapter, PTP_CMD_CTL_PTP_RESET_);\ndone:\n\tmutex_unlock(&ptp->command_lock);\n}\n\nstatic void lan743x_ptp_clock_set(struct lan743x_adapter *adapter,\n\t\t\t\t  u32 seconds, u32 nano_seconds,\n\t\t\t\t  u32 sub_nano_seconds)\n{\n\tstruct lan743x_ptp *ptp = &adapter->ptp;\n\n\tmutex_lock(&ptp->command_lock);\n\n\tlan743x_csr_write(adapter, PTP_CLOCK_SEC, seconds);\n\tlan743x_csr_write(adapter, PTP_CLOCK_NS, nano_seconds);\n\tlan743x_csr_write(adapter, PTP_CLOCK_SUBNS, sub_nano_seconds);\n\n\tlan743x_csr_write(adapter, PTP_CMD_CTL, PTP_CMD_CTL_PTP_CLOCK_LOAD_);\n\tlan743x_ptp_wait_till_cmd_done(adapter, PTP_CMD_CTL_PTP_CLOCK_LOAD_);\n\tmutex_unlock(&ptp->command_lock);\n}\n\nbool lan743x_ptp_request_tx_timestamp(struct lan743x_adapter *adapter)\n{\n\tstruct lan743x_ptp *ptp = &adapter->ptp;\n\tbool result = false;\n\n\tspin_lock_bh(&ptp->tx_ts_lock);\n\tif (ptp->pending_tx_timestamps < LAN743X_PTP_NUMBER_OF_TX_TIMESTAMPS) {\n\t\t \n\t\tptp->pending_tx_timestamps++;\n\t\tresult = true;\n\t}\n\tspin_unlock_bh(&ptp->tx_ts_lock);\n\treturn result;\n}\n\nvoid lan743x_ptp_unrequest_tx_timestamp(struct lan743x_adapter *adapter)\n{\n\tstruct lan743x_ptp *ptp = &adapter->ptp;\n\n\tspin_lock_bh(&ptp->tx_ts_lock);\n\tif (ptp->pending_tx_timestamps > 0)\n\t\tptp->pending_tx_timestamps--;\n\telse\n\t\tnetif_err(adapter, drv, adapter->netdev,\n\t\t\t  \"unrequest failed, pending_tx_timestamps==0\\n\");\n\tspin_unlock_bh(&ptp->tx_ts_lock);\n}\n\nvoid lan743x_ptp_tx_timestamp_skb(struct lan743x_adapter *adapter,\n\t\t\t\t  struct sk_buff *skb, bool ignore_sync)\n{\n\tlan743x_ptp_tx_ts_enqueue_skb(adapter, skb, ignore_sync);\n\n\tlan743x_ptp_tx_ts_complete(adapter);\n}\n\nint lan743x_ptp_ioctl(struct net_device *netdev, struct ifreq *ifr, int cmd)\n{\n\tstruct lan743x_adapter *adapter = netdev_priv(netdev);\n\tstruct hwtstamp_config config;\n\tint ret = 0;\n\tint index;\n\n\tif (!ifr) {\n\t\tnetif_err(adapter, drv, adapter->netdev,\n\t\t\t  \"SIOCSHWTSTAMP, ifr == NULL\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (copy_from_user(&config, ifr->ifr_data, sizeof(config)))\n\t\treturn -EFAULT;\n\n\tswitch (config.tx_type) {\n\tcase HWTSTAMP_TX_OFF:\n\t\tfor (index = 0; index < adapter->used_tx_channels;\n\t\t     index++)\n\t\t\tlan743x_tx_set_timestamping_mode(&adapter->tx[index],\n\t\t\t\t\t\t\t false, false);\n\t\tlan743x_ptp_set_sync_ts_insert(adapter, false);\n\t\tbreak;\n\tcase HWTSTAMP_TX_ON:\n\t\tfor (index = 0; index < adapter->used_tx_channels;\n\t\t\tindex++)\n\t\t\tlan743x_tx_set_timestamping_mode(&adapter->tx[index],\n\t\t\t\t\t\t\t true, false);\n\t\tlan743x_ptp_set_sync_ts_insert(adapter, false);\n\t\tbreak;\n\tcase HWTSTAMP_TX_ONESTEP_SYNC:\n\t\tfor (index = 0; index < adapter->used_tx_channels;\n\t\t\tindex++)\n\t\t\tlan743x_tx_set_timestamping_mode(&adapter->tx[index],\n\t\t\t\t\t\t\t true, true);\n\n\t\tlan743x_ptp_set_sync_ts_insert(adapter, true);\n\t\tbreak;\n\tcase HWTSTAMP_TX_ONESTEP_P2P:\n\t\tret = -ERANGE;\n\t\tbreak;\n\tdefault:\n\t\tnetif_warn(adapter, drv, adapter->netdev,\n\t\t\t   \"  tx_type = %d, UNKNOWN\\n\", config.tx_type);\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\tif (!ret)\n\t\treturn copy_to_user(ifr->ifr_data, &config,\n\t\t\tsizeof(config)) ? -EFAULT : 0;\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}