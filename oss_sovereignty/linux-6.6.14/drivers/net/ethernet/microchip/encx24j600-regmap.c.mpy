{
  "module_name": "encx24j600-regmap.c",
  "hash_id": "ac0e88b69c980f7e08f0625cc5b88503246de3464b38b9496356758cad28bd02",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/microchip/encx24j600-regmap.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/regmap.h>\n#include <linux/spi/spi.h>\n\n#include \"encx24j600_hw.h\"\n\nstatic int encx24j600_switch_bank(struct encx24j600_context *ctx,\n\t\t\t\t  int bank)\n{\n\tint ret = 0;\n\tint bank_opcode = BANK_SELECT(bank);\n\n\tret = spi_write(ctx->spi, &bank_opcode, 1);\n\tif (ret == 0)\n\t\tctx->bank = bank;\n\n\treturn ret;\n}\n\nstatic int encx24j600_cmdn(struct encx24j600_context *ctx, u8 opcode,\n\t\t\t   const void *buf, size_t len)\n{\n\tstruct spi_message m;\n\tstruct spi_transfer t[2] = { { .tx_buf = &opcode, .len = 1, },\n\t\t\t\t     { .tx_buf = buf, .len = len }, };\n\tspi_message_init(&m);\n\tspi_message_add_tail(&t[0], &m);\n\tspi_message_add_tail(&t[1], &m);\n\n\treturn spi_sync(ctx->spi, &m);\n}\n\nstatic void regmap_lock_mutex(void *context)\n{\n\tstruct encx24j600_context *ctx = context;\n\n\tmutex_lock(&ctx->mutex);\n}\n\nstatic void regmap_unlock_mutex(void *context)\n{\n\tstruct encx24j600_context *ctx = context;\n\n\tmutex_unlock(&ctx->mutex);\n}\n\nstatic int regmap_encx24j600_sfr_read(void *context, u8 reg, u8 *val,\n\t\t\t\t      size_t len)\n{\n\tstruct encx24j600_context *ctx = context;\n\tu8 banked_reg = reg & ADDR_MASK;\n\tu8 bank = ((reg & BANK_MASK) >> BANK_SHIFT);\n\tu8 cmd = RCRU;\n\tint ret = 0;\n\tint i = 0;\n\tu8 tx_buf[2];\n\n\tif (reg < 0x80) {\n\t\tcmd = RCRCODE | banked_reg;\n\t\tif ((banked_reg < 0x16) && (ctx->bank != bank))\n\t\t\tret = encx24j600_switch_bank(ctx, bank);\n\t\tif (unlikely(ret))\n\t\t\treturn ret;\n\t} else {\n\t\t \n\t\tswitch (reg) {\n\t\tcase EGPRDPT:\n\t\t\tcmd = RGPRDPT; break;\n\t\tcase EGPWRPT:\n\t\t\tcmd = RGPWRPT; break;\n\t\tcase ERXRDPT:\n\t\t\tcmd = RRXRDPT; break;\n\t\tcase ERXWRPT:\n\t\t\tcmd = RRXWRPT; break;\n\t\tcase EUDARDPT:\n\t\t\tcmd = RUDARDPT; break;\n\t\tcase EUDAWRPT:\n\t\t\tcmd = RUDAWRPT; break;\n\t\tcase EGPDATA:\n\t\tcase ERXDATA:\n\t\tcase EUDADATA:\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\ttx_buf[i++] = cmd;\n\tif (cmd == RCRU)\n\t\ttx_buf[i++] = reg;\n\n\tret = spi_write_then_read(ctx->spi, tx_buf, i, val, len);\n\n\treturn ret;\n}\n\nstatic int regmap_encx24j600_sfr_update(struct encx24j600_context *ctx,\n\t\t\t\t\tu8 reg, u8 *val, size_t len,\n\t\t\t\t\tu8 unbanked_cmd, u8 banked_code)\n{\n\tu8 banked_reg = reg & ADDR_MASK;\n\tu8 bank = ((reg & BANK_MASK) >> BANK_SHIFT);\n\tu8 cmd = unbanked_cmd;\n\tstruct spi_message m;\n\tstruct spi_transfer t[3] = { { .tx_buf = &cmd, .len = sizeof(cmd), },\n\t\t\t\t     { .tx_buf = &reg, .len = sizeof(reg), },\n\t\t\t\t     { .tx_buf = val, .len = len }, };\n\n\tif (reg < 0x80) {\n\t\tint ret = 0;\n\n\t\tcmd = banked_code | banked_reg;\n\t\tif ((banked_reg < 0x16) && (ctx->bank != bank))\n\t\t\tret = encx24j600_switch_bank(ctx, bank);\n\t\tif (unlikely(ret))\n\t\t\treturn ret;\n\t} else {\n\t\t \n\t\tswitch (reg) {\n\t\tcase EGPRDPT:\n\t\t\tcmd = WGPRDPT; break;\n\t\tcase EGPWRPT:\n\t\t\tcmd = WGPWRPT; break;\n\t\tcase ERXRDPT:\n\t\t\tcmd = WRXRDPT; break;\n\t\tcase ERXWRPT:\n\t\t\tcmd = WRXWRPT; break;\n\t\tcase EUDARDPT:\n\t\t\tcmd = WUDARDPT; break;\n\t\tcase EUDAWRPT:\n\t\t\tcmd = WUDAWRPT; break;\n\t\tcase EGPDATA:\n\t\tcase ERXDATA:\n\t\tcase EUDADATA:\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tspi_message_init(&m);\n\tspi_message_add_tail(&t[0], &m);\n\n\tif (cmd == unbanked_cmd) {\n\t\tt[1].tx_buf = &reg;\n\t\tspi_message_add_tail(&t[1], &m);\n\t}\n\n\tspi_message_add_tail(&t[2], &m);\n\treturn spi_sync(ctx->spi, &m);\n}\n\nstatic int regmap_encx24j600_sfr_write(void *context, u8 reg, u8 *val,\n\t\t\t\t       size_t len)\n{\n\tstruct encx24j600_context *ctx = context;\n\n\treturn regmap_encx24j600_sfr_update(ctx, reg, val, len, WCRU, WCRCODE);\n}\n\nstatic int regmap_encx24j600_sfr_set_bits(struct encx24j600_context *ctx,\n\t\t\t\t\t  u8 reg, u8 val)\n{\n\treturn regmap_encx24j600_sfr_update(ctx, reg, &val, 1, BFSU, BFSCODE);\n}\n\nstatic int regmap_encx24j600_sfr_clr_bits(struct encx24j600_context *ctx,\n\t\t\t\t\t  u8 reg, u8 val)\n{\n\treturn regmap_encx24j600_sfr_update(ctx, reg, &val, 1, BFCU, BFCCODE);\n}\n\nstatic int regmap_encx24j600_reg_update_bits(void *context, unsigned int reg,\n\t\t\t\t\t     unsigned int mask,\n\t\t\t\t\t     unsigned int val)\n{\n\tstruct encx24j600_context *ctx = context;\n\n\tint ret = 0;\n\tunsigned int set_mask = mask & val;\n\tunsigned int clr_mask = mask & ~val;\n\n\tif ((reg >= 0x40 && reg < 0x6c) || reg >= 0x80)\n\t\treturn -EINVAL;\n\n\tif (set_mask & 0xff)\n\t\tret = regmap_encx24j600_sfr_set_bits(ctx, reg, set_mask);\n\n\tset_mask = (set_mask & 0xff00) >> 8;\n\n\tif ((set_mask & 0xff) && (ret == 0))\n\t\tret = regmap_encx24j600_sfr_set_bits(ctx, reg + 1, set_mask);\n\n\tif ((clr_mask & 0xff) && (ret == 0))\n\t\tret = regmap_encx24j600_sfr_clr_bits(ctx, reg, clr_mask);\n\n\tclr_mask = (clr_mask & 0xff00) >> 8;\n\n\tif ((clr_mask & 0xff) && (ret == 0))\n\t\tret = regmap_encx24j600_sfr_clr_bits(ctx, reg + 1, clr_mask);\n\n\treturn ret;\n}\n\nint regmap_encx24j600_spi_write(void *context, u8 reg, const u8 *data,\n\t\t\t\tsize_t count)\n{\n\tstruct encx24j600_context *ctx = context;\n\n\tif (reg < 0xc0)\n\t\treturn encx24j600_cmdn(ctx, reg, data, count);\n\n\t \n\treturn spi_write(ctx->spi, &reg, 1);\n}\nEXPORT_SYMBOL_GPL(regmap_encx24j600_spi_write);\n\nint regmap_encx24j600_spi_read(void *context, u8 reg, u8 *data, size_t count)\n{\n\tstruct encx24j600_context *ctx = context;\n\n\tif (reg == RBSEL && count > 1)\n\t\tcount = 1;\n\n\treturn spi_write_then_read(ctx->spi, &reg, sizeof(reg), data, count);\n}\nEXPORT_SYMBOL_GPL(regmap_encx24j600_spi_read);\n\nstatic int regmap_encx24j600_write(void *context, const void *data,\n\t\t\t\t   size_t len)\n{\n\tu8 *dout = (u8 *)data;\n\tu8 reg = dout[0];\n\t++dout;\n\t--len;\n\n\tif (reg > 0xa0)\n\t\treturn regmap_encx24j600_spi_write(context, reg, dout, len);\n\n\tif (len > 2)\n\t\treturn -EINVAL;\n\n\treturn regmap_encx24j600_sfr_write(context, reg, dout, len);\n}\n\nstatic int regmap_encx24j600_read(void *context,\n\t\t\t\t  const void *reg_buf, size_t reg_size,\n\t\t\t\t  void *val, size_t val_size)\n{\n\tu8 reg = *(const u8 *)reg_buf;\n\n\tif (reg_size != 1) {\n\t\tpr_err(\"%s: reg=%02x reg_size=%zu\\n\", __func__, reg, reg_size);\n\t\treturn -EINVAL;\n\t}\n\n\tif (reg > 0xa0)\n\t\treturn regmap_encx24j600_spi_read(context, reg, val, val_size);\n\n\tif (val_size > 2) {\n\t\tpr_err(\"%s: reg=%02x val_size=%zu\\n\", __func__, reg, val_size);\n\t\treturn -EINVAL;\n\t}\n\n\treturn regmap_encx24j600_sfr_read(context, reg, val, val_size);\n}\n\nstatic bool encx24j600_regmap_readable(struct device *dev, unsigned int reg)\n{\n\tif ((reg < 0x36) ||\n\t    ((reg >= 0x40) && (reg < 0x4c)) ||\n\t    ((reg >= 0x52) && (reg < 0x56)) ||\n\t    ((reg >= 0x60) && (reg < 0x66)) ||\n\t    ((reg >= 0x68) && (reg < 0x80)) ||\n\t    ((reg >= 0x86) && (reg < 0x92)) ||\n\t    (reg == 0xc8))\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\nstatic bool encx24j600_regmap_writeable(struct device *dev, unsigned int reg)\n{\n\tif ((reg < 0x12) ||\n\t    ((reg >= 0x14) && (reg < 0x1a)) ||\n\t    ((reg >= 0x1c) && (reg < 0x36)) ||\n\t    ((reg >= 0x40) && (reg < 0x4c)) ||\n\t    ((reg >= 0x52) && (reg < 0x56)) ||\n\t    ((reg >= 0x60) && (reg < 0x68)) ||\n\t    ((reg >= 0x6c) && (reg < 0x80)) ||\n\t    ((reg >= 0x86) && (reg < 0x92)) ||\n\t    ((reg >= 0xc0) && (reg < 0xc8)) ||\n\t    ((reg >= 0xca) && (reg < 0xf0)))\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\nstatic bool encx24j600_regmap_volatile(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase ERXHEAD:\n\tcase EDMACS:\n\tcase ETXSTAT:\n\tcase ETXWIRE:\n\tcase ECON1:\t \n\tcase ECON2:\t \n\tcase ESTAT:\n\tcase EIR:\t \n\tcase MIRD:\n\tcase MISTAT:\n\t\treturn true;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn false;\n}\n\nstatic bool encx24j600_regmap_precious(struct device *dev, unsigned int reg)\n{\n\t \n\tif (((reg >= 0xc0) && (reg < 0xc8)) ||\n\t    ((reg >= 0xca) && (reg < 0xf0)))\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\nstatic int regmap_encx24j600_phy_reg_read(void *context, unsigned int reg,\n\t\t\t\t\t  unsigned int *val)\n{\n\tstruct encx24j600_context *ctx = context;\n\tint ret;\n\tunsigned int mistat;\n\n\treg = MIREGADR_VAL | (reg & PHREG_MASK);\n\tret = regmap_write(ctx->regmap, MIREGADR, reg);\n\tif (unlikely(ret))\n\t\tgoto err_out;\n\n\tret = regmap_write(ctx->regmap, MICMD, MIIRD);\n\tif (unlikely(ret))\n\t\tgoto err_out;\n\n\tusleep_range(26, 100);\n\twhile (((ret = regmap_read(ctx->regmap, MISTAT, &mistat)) == 0) &&\n\t       (mistat & BUSY))\n\t\tcpu_relax();\n\n\tif (unlikely(ret))\n\t\tgoto err_out;\n\n\tret = regmap_write(ctx->regmap, MICMD, 0);\n\tif (unlikely(ret))\n\t\tgoto err_out;\n\n\tret = regmap_read(ctx->regmap, MIRD, val);\n\nerr_out:\n\tif (ret)\n\t\tpr_err(\"%s: error %d reading reg %02x\\n\", __func__, ret,\n\t\t       reg & PHREG_MASK);\n\n\treturn ret;\n}\n\nstatic int regmap_encx24j600_phy_reg_write(void *context, unsigned int reg,\n\t\t\t\t\t   unsigned int val)\n{\n\tstruct encx24j600_context *ctx = context;\n\tint ret;\n\tunsigned int mistat;\n\n\treg = MIREGADR_VAL | (reg & PHREG_MASK);\n\tret = regmap_write(ctx->regmap, MIREGADR, reg);\n\tif (unlikely(ret))\n\t\tgoto err_out;\n\n\tret = regmap_write(ctx->regmap, MIWR, val);\n\tif (unlikely(ret))\n\t\tgoto err_out;\n\n\tusleep_range(26, 100);\n\twhile (((ret = regmap_read(ctx->regmap, MISTAT, &mistat)) == 0) &&\n\t       (mistat & BUSY))\n\t\tcpu_relax();\n\nerr_out:\n\tif (ret)\n\t\tpr_err(\"%s: error %d writing reg %02x=%04x\\n\", __func__, ret,\n\t\t       reg & PHREG_MASK, val);\n\n\treturn ret;\n}\n\nstatic bool encx24j600_phymap_readable(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase PHCON1:\n\tcase PHSTAT1:\n\tcase PHANA:\n\tcase PHANLPA:\n\tcase PHANE:\n\tcase PHCON2:\n\tcase PHSTAT2:\n\tcase PHSTAT3:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool encx24j600_phymap_writeable(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase PHCON1:\n\tcase PHCON2:\n\tcase PHANA:\n\t\treturn true;\n\tcase PHSTAT1:\n\tcase PHSTAT2:\n\tcase PHSTAT3:\n\tcase PHANLPA:\n\tcase PHANE:\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool encx24j600_phymap_volatile(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase PHSTAT1:\n\tcase PHSTAT2:\n\tcase PHSTAT3:\n\tcase PHANLPA:\n\tcase PHANE:\n\tcase PHCON2:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic struct regmap_config regcfg = {\n\t.name = \"reg\",\n\t.reg_bits = 8,\n\t.val_bits = 16,\n\t.max_register = 0xee,\n\t.reg_stride = 2,\n\t.cache_type = REGCACHE_RBTREE,\n\t.val_format_endian = REGMAP_ENDIAN_LITTLE,\n\t.readable_reg = encx24j600_regmap_readable,\n\t.writeable_reg = encx24j600_regmap_writeable,\n\t.volatile_reg = encx24j600_regmap_volatile,\n\t.precious_reg = encx24j600_regmap_precious,\n\t.lock = regmap_lock_mutex,\n\t.unlock = regmap_unlock_mutex,\n};\n\nstatic struct regmap_bus regmap_encx24j600 = {\n\t.write = regmap_encx24j600_write,\n\t.read = regmap_encx24j600_read,\n\t.reg_update_bits = regmap_encx24j600_reg_update_bits,\n};\n\nstatic struct regmap_config phycfg = {\n\t.name = \"phy\",\n\t.reg_bits = 8,\n\t.val_bits = 16,\n\t.max_register = 0x1f,\n\t.cache_type = REGCACHE_RBTREE,\n\t.val_format_endian = REGMAP_ENDIAN_LITTLE,\n\t.readable_reg = encx24j600_phymap_readable,\n\t.writeable_reg = encx24j600_phymap_writeable,\n\t.volatile_reg = encx24j600_phymap_volatile,\n};\n\nstatic struct regmap_bus phymap_encx24j600 = {\n\t.reg_write = regmap_encx24j600_phy_reg_write,\n\t.reg_read = regmap_encx24j600_phy_reg_read,\n};\n\nint devm_regmap_init_encx24j600(struct device *dev,\n\t\t\t\tstruct encx24j600_context *ctx)\n{\n\tmutex_init(&ctx->mutex);\n\tregcfg.lock_arg = ctx;\n\tctx->regmap = devm_regmap_init(dev, &regmap_encx24j600, ctx, &regcfg);\n\tif (IS_ERR(ctx->regmap))\n\t\treturn PTR_ERR(ctx->regmap);\n\tctx->phymap = devm_regmap_init(dev, &phymap_encx24j600, ctx, &phycfg);\n\tif (IS_ERR(ctx->phymap))\n\t\treturn PTR_ERR(ctx->phymap);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(devm_regmap_init_encx24j600);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}