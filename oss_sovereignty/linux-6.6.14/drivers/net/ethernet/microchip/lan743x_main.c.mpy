{
  "module_name": "lan743x_main.c",
  "hash_id": "bf84761071a719dd15a481bf201fe2145c69e0ad9c233062933e1a3a22855dbd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/microchip/lan743x_main.c",
  "human_readable_source": " \n \n\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/crc32.h>\n#include <linux/microchipphy.h>\n#include <linux/net_tstamp.h>\n#include <linux/of_mdio.h>\n#include <linux/of_net.h>\n#include <linux/phy.h>\n#include <linux/phy_fixed.h>\n#include <linux/rtnetlink.h>\n#include <linux/iopoll.h>\n#include <linux/crc16.h>\n#include \"lan743x_main.h\"\n#include \"lan743x_ethtool.h\"\n\n#define MMD_ACCESS_ADDRESS\t0\n#define MMD_ACCESS_WRITE\t1\n#define MMD_ACCESS_READ\t\t2\n#define MMD_ACCESS_READ_INC\t3\n#define PCS_POWER_STATE_DOWN\t0x6\n#define PCS_POWER_STATE_UP\t0x4\n\nstatic void pci11x1x_strap_get_status(struct lan743x_adapter *adapter)\n{\n\tu32 chip_rev;\n\tu32 cfg_load;\n\tu32 hw_cfg;\n\tu32 strap;\n\tint ret;\n\n\t \n\tret = lan743x_hs_syslock_acquire(adapter, 100);\n\tif (ret < 0) {\n\t\tnetif_err(adapter, drv, adapter->netdev,\n\t\t\t  \"Sys Lock acquire failed ret:%d\\n\", ret);\n\t\treturn;\n\t}\n\n\tcfg_load = lan743x_csr_read(adapter, ETH_SYS_CONFIG_LOAD_STARTED_REG);\n\tlan743x_hs_syslock_release(adapter);\n\thw_cfg = lan743x_csr_read(adapter, HW_CFG);\n\n\tif (cfg_load & GEN_SYS_LOAD_STARTED_REG_ETH_ ||\n\t    hw_cfg & HW_CFG_RST_PROTECT_) {\n\t\tstrap = lan743x_csr_read(adapter, STRAP_READ);\n\t\tif (strap & STRAP_READ_SGMII_EN_)\n\t\t\tadapter->is_sgmii_en = true;\n\t\telse\n\t\t\tadapter->is_sgmii_en = false;\n\t} else {\n\t\tchip_rev = lan743x_csr_read(adapter, FPGA_REV);\n\t\tif (chip_rev) {\n\t\t\tif (chip_rev & FPGA_SGMII_OP)\n\t\t\t\tadapter->is_sgmii_en = true;\n\t\t\telse\n\t\t\t\tadapter->is_sgmii_en = false;\n\t\t} else {\n\t\t\tadapter->is_sgmii_en = false;\n\t\t}\n\t}\n\tnetif_dbg(adapter, drv, adapter->netdev,\n\t\t  \"SGMII I/F %sable\\n\", adapter->is_sgmii_en ? \"En\" : \"Dis\");\n}\n\nstatic bool is_pci11x1x_chip(struct lan743x_adapter *adapter)\n{\n\tstruct lan743x_csr *csr = &adapter->csr;\n\tu32 id_rev = csr->id_rev;\n\n\tif (((id_rev & 0xFFFF0000) == ID_REV_ID_A011_) ||\n\t    ((id_rev & 0xFFFF0000) == ID_REV_ID_A041_)) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic void lan743x_pci_cleanup(struct lan743x_adapter *adapter)\n{\n\tpci_release_selected_regions(adapter->pdev,\n\t\t\t\t     pci_select_bars(adapter->pdev,\n\t\t\t\t\t\t     IORESOURCE_MEM));\n\tpci_disable_device(adapter->pdev);\n}\n\nstatic int lan743x_pci_init(struct lan743x_adapter *adapter,\n\t\t\t    struct pci_dev *pdev)\n{\n\tunsigned long bars = 0;\n\tint ret;\n\n\tadapter->pdev = pdev;\n\tret = pci_enable_device_mem(pdev);\n\tif (ret)\n\t\tgoto return_error;\n\n\tnetif_info(adapter, probe, adapter->netdev,\n\t\t   \"PCI: Vendor ID = 0x%04X, Device ID = 0x%04X\\n\",\n\t\t   pdev->vendor, pdev->device);\n\tbars = pci_select_bars(pdev, IORESOURCE_MEM);\n\tif (!test_bit(0, &bars))\n\t\tgoto disable_device;\n\n\tret = pci_request_selected_regions(pdev, bars, DRIVER_NAME);\n\tif (ret)\n\t\tgoto disable_device;\n\n\tpci_set_master(pdev);\n\treturn 0;\n\ndisable_device:\n\tpci_disable_device(adapter->pdev);\n\nreturn_error:\n\treturn ret;\n}\n\nu32 lan743x_csr_read(struct lan743x_adapter *adapter, int offset)\n{\n\treturn ioread32(&adapter->csr.csr_address[offset]);\n}\n\nvoid lan743x_csr_write(struct lan743x_adapter *adapter, int offset,\n\t\t       u32 data)\n{\n\tiowrite32(data, &adapter->csr.csr_address[offset]);\n}\n\n#define LAN743X_CSR_READ_OP(offset)\tlan743x_csr_read(adapter, offset)\n\nstatic int lan743x_csr_light_reset(struct lan743x_adapter *adapter)\n{\n\tu32 data;\n\n\tdata = lan743x_csr_read(adapter, HW_CFG);\n\tdata |= HW_CFG_LRST_;\n\tlan743x_csr_write(adapter, HW_CFG, data);\n\n\treturn readx_poll_timeout(LAN743X_CSR_READ_OP, HW_CFG, data,\n\t\t\t\t  !(data & HW_CFG_LRST_), 100000, 10000000);\n}\n\nstatic int lan743x_csr_wait_for_bit_atomic(struct lan743x_adapter *adapter,\n\t\t\t\t\t   int offset, u32 bit_mask,\n\t\t\t\t\t   int target_value, int udelay_min,\n\t\t\t\t\t   int udelay_max, int count)\n{\n\tu32 data;\n\n\treturn readx_poll_timeout_atomic(LAN743X_CSR_READ_OP, offset, data,\n\t\t\t\t\t target_value == !!(data & bit_mask),\n\t\t\t\t\t udelay_max, udelay_min * count);\n}\n\nstatic int lan743x_csr_wait_for_bit(struct lan743x_adapter *adapter,\n\t\t\t\t    int offset, u32 bit_mask,\n\t\t\t\t    int target_value, int usleep_min,\n\t\t\t\t    int usleep_max, int count)\n{\n\tu32 data;\n\n\treturn readx_poll_timeout(LAN743X_CSR_READ_OP, offset, data,\n\t\t\t\t  target_value == !!(data & bit_mask),\n\t\t\t\t  usleep_max, usleep_min * count);\n}\n\nstatic int lan743x_csr_init(struct lan743x_adapter *adapter)\n{\n\tstruct lan743x_csr *csr = &adapter->csr;\n\tresource_size_t bar_start, bar_length;\n\n\tbar_start = pci_resource_start(adapter->pdev, 0);\n\tbar_length = pci_resource_len(adapter->pdev, 0);\n\tcsr->csr_address = devm_ioremap(&adapter->pdev->dev,\n\t\t\t\t\tbar_start, bar_length);\n\tif (!csr->csr_address)\n\t\treturn -ENOMEM;\n\n\tcsr->id_rev = lan743x_csr_read(adapter, ID_REV);\n\tcsr->fpga_rev = lan743x_csr_read(adapter, FPGA_REV);\n\tnetif_info(adapter, probe, adapter->netdev,\n\t\t   \"ID_REV = 0x%08X, FPGA_REV = %d.%d\\n\",\n\t\t   csr->id_rev,\tFPGA_REV_GET_MAJOR_(csr->fpga_rev),\n\t\t   FPGA_REV_GET_MINOR_(csr->fpga_rev));\n\tif (!ID_REV_IS_VALID_CHIP_ID_(csr->id_rev))\n\t\treturn -ENODEV;\n\n\tcsr->flags = LAN743X_CSR_FLAG_SUPPORTS_INTR_AUTO_SET_CLR;\n\tswitch (csr->id_rev & ID_REV_CHIP_REV_MASK_) {\n\tcase ID_REV_CHIP_REV_A0_:\n\t\tcsr->flags |= LAN743X_CSR_FLAG_IS_A0;\n\t\tcsr->flags &= ~LAN743X_CSR_FLAG_SUPPORTS_INTR_AUTO_SET_CLR;\n\t\tbreak;\n\tcase ID_REV_CHIP_REV_B0_:\n\t\tcsr->flags |= LAN743X_CSR_FLAG_IS_B0;\n\t\tbreak;\n\t}\n\n\treturn lan743x_csr_light_reset(adapter);\n}\n\nstatic void lan743x_intr_software_isr(struct lan743x_adapter *adapter)\n{\n\tstruct lan743x_intr *intr = &adapter->intr;\n\n\t \n\tlan743x_csr_write(adapter, INT_EN_CLR, INT_BIT_SW_GP_);\n\tintr->software_isr_flag = true;\n\twake_up(&intr->software_isr_wq);\n}\n\nstatic void lan743x_tx_isr(void *context, u32 int_sts, u32 flags)\n{\n\tstruct lan743x_tx *tx = context;\n\tstruct lan743x_adapter *adapter = tx->adapter;\n\tbool enable_flag = true;\n\n\tlan743x_csr_read(adapter, INT_EN_SET);\n\tif (flags & LAN743X_VECTOR_FLAG_SOURCE_ENABLE_CLEAR) {\n\t\tlan743x_csr_write(adapter, INT_EN_CLR,\n\t\t\t\t  INT_BIT_DMA_TX_(tx->channel_number));\n\t}\n\n\tif (int_sts & INT_BIT_DMA_TX_(tx->channel_number)) {\n\t\tu32 ioc_bit = DMAC_INT_BIT_TX_IOC_(tx->channel_number);\n\t\tu32 dmac_int_sts;\n\t\tu32 dmac_int_en;\n\n\t\tif (flags & LAN743X_VECTOR_FLAG_SOURCE_STATUS_READ)\n\t\t\tdmac_int_sts = lan743x_csr_read(adapter, DMAC_INT_STS);\n\t\telse\n\t\t\tdmac_int_sts = ioc_bit;\n\t\tif (flags & LAN743X_VECTOR_FLAG_SOURCE_ENABLE_CHECK)\n\t\t\tdmac_int_en = lan743x_csr_read(adapter,\n\t\t\t\t\t\t       DMAC_INT_EN_SET);\n\t\telse\n\t\t\tdmac_int_en = ioc_bit;\n\n\t\tdmac_int_en &= ioc_bit;\n\t\tdmac_int_sts &= dmac_int_en;\n\t\tif (dmac_int_sts & ioc_bit) {\n\t\t\tnapi_schedule(&tx->napi);\n\t\t\tenable_flag = false; \n\t\t}\n\t}\n\n\tif (enable_flag)\n\t\t \n\t\tlan743x_csr_write(adapter, INT_EN_SET,\n\t\t\t\t  INT_BIT_DMA_TX_(tx->channel_number));\n}\n\nstatic void lan743x_rx_isr(void *context, u32 int_sts, u32 flags)\n{\n\tstruct lan743x_rx *rx = context;\n\tstruct lan743x_adapter *adapter = rx->adapter;\n\tbool enable_flag = true;\n\n\tif (flags & LAN743X_VECTOR_FLAG_SOURCE_ENABLE_CLEAR) {\n\t\tlan743x_csr_write(adapter, INT_EN_CLR,\n\t\t\t\t  INT_BIT_DMA_RX_(rx->channel_number));\n\t}\n\n\tif (int_sts & INT_BIT_DMA_RX_(rx->channel_number)) {\n\t\tu32 rx_frame_bit = DMAC_INT_BIT_RXFRM_(rx->channel_number);\n\t\tu32 dmac_int_sts;\n\t\tu32 dmac_int_en;\n\n\t\tif (flags & LAN743X_VECTOR_FLAG_SOURCE_STATUS_READ)\n\t\t\tdmac_int_sts = lan743x_csr_read(adapter, DMAC_INT_STS);\n\t\telse\n\t\t\tdmac_int_sts = rx_frame_bit;\n\t\tif (flags & LAN743X_VECTOR_FLAG_SOURCE_ENABLE_CHECK)\n\t\t\tdmac_int_en = lan743x_csr_read(adapter,\n\t\t\t\t\t\t       DMAC_INT_EN_SET);\n\t\telse\n\t\t\tdmac_int_en = rx_frame_bit;\n\n\t\tdmac_int_en &= rx_frame_bit;\n\t\tdmac_int_sts &= dmac_int_en;\n\t\tif (dmac_int_sts & rx_frame_bit) {\n\t\t\tnapi_schedule(&rx->napi);\n\t\t\tenable_flag = false; \n\t\t}\n\t}\n\n\tif (enable_flag) {\n\t\t \n\t\tlan743x_csr_write(adapter, INT_EN_SET,\n\t\t\t\t  INT_BIT_DMA_RX_(rx->channel_number));\n\t}\n}\n\nstatic void lan743x_intr_shared_isr(void *context, u32 int_sts, u32 flags)\n{\n\tstruct lan743x_adapter *adapter = context;\n\tunsigned int channel;\n\n\tif (int_sts & INT_BIT_ALL_RX_) {\n\t\tfor (channel = 0; channel < LAN743X_USED_RX_CHANNELS;\n\t\t\tchannel++) {\n\t\t\tu32 int_bit = INT_BIT_DMA_RX_(channel);\n\n\t\t\tif (int_sts & int_bit) {\n\t\t\t\tlan743x_rx_isr(&adapter->rx[channel],\n\t\t\t\t\t       int_bit, flags);\n\t\t\t\tint_sts &= ~int_bit;\n\t\t\t}\n\t\t}\n\t}\n\tif (int_sts & INT_BIT_ALL_TX_) {\n\t\tfor (channel = 0; channel < adapter->used_tx_channels;\n\t\t\tchannel++) {\n\t\t\tu32 int_bit = INT_BIT_DMA_TX_(channel);\n\n\t\t\tif (int_sts & int_bit) {\n\t\t\t\tlan743x_tx_isr(&adapter->tx[channel],\n\t\t\t\t\t       int_bit, flags);\n\t\t\t\tint_sts &= ~int_bit;\n\t\t\t}\n\t\t}\n\t}\n\tif (int_sts & INT_BIT_ALL_OTHER_) {\n\t\tif (int_sts & INT_BIT_SW_GP_) {\n\t\t\tlan743x_intr_software_isr(adapter);\n\t\t\tint_sts &= ~INT_BIT_SW_GP_;\n\t\t}\n\t\tif (int_sts & INT_BIT_1588_) {\n\t\t\tlan743x_ptp_isr(adapter);\n\t\t\tint_sts &= ~INT_BIT_1588_;\n\t\t}\n\t}\n\tif (int_sts)\n\t\tlan743x_csr_write(adapter, INT_EN_CLR, int_sts);\n}\n\nstatic irqreturn_t lan743x_intr_entry_isr(int irq, void *ptr)\n{\n\tstruct lan743x_vector *vector = ptr;\n\tstruct lan743x_adapter *adapter = vector->adapter;\n\tirqreturn_t result = IRQ_NONE;\n\tu32 int_enables;\n\tu32 int_sts;\n\n\tif (vector->flags & LAN743X_VECTOR_FLAG_SOURCE_STATUS_READ) {\n\t\tint_sts = lan743x_csr_read(adapter, INT_STS);\n\t} else if (vector->flags &\n\t\t   (LAN743X_VECTOR_FLAG_SOURCE_STATUS_R2C |\n\t\t   LAN743X_VECTOR_FLAG_SOURCE_ENABLE_R2C)) {\n\t\tint_sts = lan743x_csr_read(adapter, INT_STS_R2C);\n\t} else {\n\t\t \n\t\tint_sts = vector->int_mask | INT_BIT_MAS_;\n\t}\n\n\tif (!(int_sts & INT_BIT_MAS_))\n\t\tgoto irq_done;\n\n\tif (vector->flags & LAN743X_VECTOR_FLAG_VECTOR_ENABLE_ISR_CLEAR)\n\t\t \n\t\tlan743x_csr_write(adapter,\n\t\t\t\t  INT_VEC_EN_CLR,\n\t\t\t\t  INT_VEC_EN_(vector->vector_index));\n\n\tif (vector->flags & LAN743X_VECTOR_FLAG_MASTER_ENABLE_CLEAR)\n\t\t \n\t\tlan743x_csr_write(adapter, INT_EN_CLR, INT_BIT_MAS_);\n\n\tif (vector->flags & LAN743X_VECTOR_FLAG_SOURCE_ENABLE_CHECK) {\n\t\tint_enables = lan743x_csr_read(adapter, INT_EN_SET);\n\t} else {\n\t\t \n\t\tint_enables = vector->int_mask;\n\t}\n\n\tint_sts &= int_enables;\n\tint_sts &= vector->int_mask;\n\tif (int_sts) {\n\t\tif (vector->handler) {\n\t\t\tvector->handler(vector->context,\n\t\t\t\t\tint_sts, vector->flags);\n\t\t} else {\n\t\t\t \n\t\t\tlan743x_csr_write(adapter, INT_EN_CLR,\n\t\t\t\t\t  vector->int_mask);\n\t\t}\n\t\tresult = IRQ_HANDLED;\n\t}\n\n\tif (vector->flags & LAN743X_VECTOR_FLAG_MASTER_ENABLE_SET)\n\t\t \n\t\tlan743x_csr_write(adapter, INT_EN_SET, INT_BIT_MAS_);\n\n\tif (vector->flags & LAN743X_VECTOR_FLAG_VECTOR_ENABLE_ISR_SET)\n\t\t \n\t\tlan743x_csr_write(adapter,\n\t\t\t\t  INT_VEC_EN_SET,\n\t\t\t\t  INT_VEC_EN_(vector->vector_index));\nirq_done:\n\treturn result;\n}\n\nstatic int lan743x_intr_test_isr(struct lan743x_adapter *adapter)\n{\n\tstruct lan743x_intr *intr = &adapter->intr;\n\tint ret;\n\n\tintr->software_isr_flag = false;\n\n\t \n\tlan743x_csr_write(adapter, INT_EN_SET, INT_BIT_SW_GP_);\n\tlan743x_csr_write(adapter, INT_SET, INT_BIT_SW_GP_);\n\n\tret = wait_event_timeout(intr->software_isr_wq,\n\t\t\t\t intr->software_isr_flag,\n\t\t\t\t msecs_to_jiffies(200));\n\n\t \n\tlan743x_csr_write(adapter, INT_EN_CLR, INT_BIT_SW_GP_);\n\n\treturn ret > 0 ? 0 : -ENODEV;\n}\n\nstatic int lan743x_intr_register_isr(struct lan743x_adapter *adapter,\n\t\t\t\t     int vector_index, u32 flags,\n\t\t\t\t     u32 int_mask,\n\t\t\t\t     lan743x_vector_handler handler,\n\t\t\t\t     void *context)\n{\n\tstruct lan743x_vector *vector = &adapter->intr.vector_list\n\t\t\t\t\t[vector_index];\n\tint ret;\n\n\tvector->adapter = adapter;\n\tvector->flags = flags;\n\tvector->vector_index = vector_index;\n\tvector->int_mask = int_mask;\n\tvector->handler = handler;\n\tvector->context = context;\n\n\tret = request_irq(vector->irq,\n\t\t\t  lan743x_intr_entry_isr,\n\t\t\t  (flags & LAN743X_VECTOR_FLAG_IRQ_SHARED) ?\n\t\t\t  IRQF_SHARED : 0, DRIVER_NAME, vector);\n\tif (ret) {\n\t\tvector->handler = NULL;\n\t\tvector->context = NULL;\n\t\tvector->int_mask = 0;\n\t\tvector->flags = 0;\n\t}\n\treturn ret;\n}\n\nstatic void lan743x_intr_unregister_isr(struct lan743x_adapter *adapter,\n\t\t\t\t\tint vector_index)\n{\n\tstruct lan743x_vector *vector = &adapter->intr.vector_list\n\t\t\t\t\t[vector_index];\n\n\tfree_irq(vector->irq, vector);\n\tvector->handler = NULL;\n\tvector->context = NULL;\n\tvector->int_mask = 0;\n\tvector->flags = 0;\n}\n\nstatic u32 lan743x_intr_get_vector_flags(struct lan743x_adapter *adapter,\n\t\t\t\t\t u32 int_mask)\n{\n\tint index;\n\n\tfor (index = 0; index < adapter->max_vector_count; index++) {\n\t\tif (adapter->intr.vector_list[index].int_mask & int_mask)\n\t\t\treturn adapter->intr.vector_list[index].flags;\n\t}\n\treturn 0;\n}\n\nstatic void lan743x_intr_close(struct lan743x_adapter *adapter)\n{\n\tstruct lan743x_intr *intr = &adapter->intr;\n\tint index = 0;\n\n\tlan743x_csr_write(adapter, INT_EN_CLR, INT_BIT_MAS_);\n\tif (adapter->is_pci11x1x)\n\t\tlan743x_csr_write(adapter, INT_VEC_EN_CLR, 0x0000FFFF);\n\telse\n\t\tlan743x_csr_write(adapter, INT_VEC_EN_CLR, 0x000000FF);\n\n\tfor (index = 0; index < intr->number_of_vectors; index++) {\n\t\tif (intr->flags & INTR_FLAG_IRQ_REQUESTED(index)) {\n\t\t\tlan743x_intr_unregister_isr(adapter, index);\n\t\t\tintr->flags &= ~INTR_FLAG_IRQ_REQUESTED(index);\n\t\t}\n\t}\n\n\tif (intr->flags & INTR_FLAG_MSI_ENABLED) {\n\t\tpci_disable_msi(adapter->pdev);\n\t\tintr->flags &= ~INTR_FLAG_MSI_ENABLED;\n\t}\n\n\tif (intr->flags & INTR_FLAG_MSIX_ENABLED) {\n\t\tpci_disable_msix(adapter->pdev);\n\t\tintr->flags &= ~INTR_FLAG_MSIX_ENABLED;\n\t}\n}\n\nstatic int lan743x_intr_open(struct lan743x_adapter *adapter)\n{\n\tstruct msix_entry msix_entries[PCI11X1X_MAX_VECTOR_COUNT];\n\tstruct lan743x_intr *intr = &adapter->intr;\n\tunsigned int used_tx_channels;\n\tu32 int_vec_en_auto_clr = 0;\n\tu8 max_vector_count;\n\tu32 int_vec_map0 = 0;\n\tu32 int_vec_map1 = 0;\n\tint ret = -ENODEV;\n\tint index = 0;\n\tu32 flags = 0;\n\n\tintr->number_of_vectors = 0;\n\n\t \n\tmax_vector_count = adapter->max_vector_count;\n\tmemset(&msix_entries[0], 0,\n\t       sizeof(struct msix_entry) * max_vector_count);\n\tfor (index = 0; index < max_vector_count; index++)\n\t\tmsix_entries[index].entry = index;\n\tused_tx_channels = adapter->used_tx_channels;\n\tret = pci_enable_msix_range(adapter->pdev,\n\t\t\t\t    msix_entries, 1,\n\t\t\t\t    1 + used_tx_channels +\n\t\t\t\t    LAN743X_USED_RX_CHANNELS);\n\n\tif (ret > 0) {\n\t\tintr->flags |= INTR_FLAG_MSIX_ENABLED;\n\t\tintr->number_of_vectors = ret;\n\t\tintr->using_vectors = true;\n\t\tfor (index = 0; index < intr->number_of_vectors; index++)\n\t\t\tintr->vector_list[index].irq = msix_entries\n\t\t\t\t\t\t       [index].vector;\n\t\tnetif_info(adapter, ifup, adapter->netdev,\n\t\t\t   \"using MSIX interrupts, number of vectors = %d\\n\",\n\t\t\t   intr->number_of_vectors);\n\t}\n\n\t \n\tif (!intr->number_of_vectors) {\n\t\tif (!(adapter->csr.flags & LAN743X_CSR_FLAG_IS_A0)) {\n\t\t\tif (!pci_enable_msi(adapter->pdev)) {\n\t\t\t\tintr->flags |= INTR_FLAG_MSI_ENABLED;\n\t\t\t\tintr->number_of_vectors = 1;\n\t\t\t\tintr->using_vectors = true;\n\t\t\t\tintr->vector_list[0].irq =\n\t\t\t\t\tadapter->pdev->irq;\n\t\t\t\tnetif_info(adapter, ifup, adapter->netdev,\n\t\t\t\t\t   \"using MSI interrupts, number of vectors = %d\\n\",\n\t\t\t\t\t   intr->number_of_vectors);\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (!intr->number_of_vectors) {\n\t\tintr->number_of_vectors = 1;\n\t\tintr->using_vectors = false;\n\t\tintr->vector_list[0].irq = intr->irq;\n\t\tnetif_info(adapter, ifup, adapter->netdev,\n\t\t\t   \"using legacy interrupts\\n\");\n\t}\n\n\t \n\tlan743x_csr_write(adapter, INT_VEC_EN_CLR, 0xFFFFFFFF);\n\n\t \n\tlan743x_csr_write(adapter, INT_VEC_MAP0, 0x00000000);\n\tlan743x_csr_write(adapter, INT_VEC_MAP1, 0x00000000);\n\tlan743x_csr_write(adapter, INT_VEC_MAP2, 0x00000000);\n\tflags = LAN743X_VECTOR_FLAG_SOURCE_STATUS_READ |\n\t\tLAN743X_VECTOR_FLAG_SOURCE_STATUS_W2C |\n\t\tLAN743X_VECTOR_FLAG_SOURCE_ENABLE_CHECK |\n\t\tLAN743X_VECTOR_FLAG_SOURCE_ENABLE_CLEAR;\n\n\tif (intr->using_vectors) {\n\t\tflags |= LAN743X_VECTOR_FLAG_VECTOR_ENABLE_ISR_CLEAR |\n\t\t\t LAN743X_VECTOR_FLAG_VECTOR_ENABLE_ISR_SET;\n\t} else {\n\t\tflags |= LAN743X_VECTOR_FLAG_MASTER_ENABLE_CLEAR |\n\t\t\t LAN743X_VECTOR_FLAG_MASTER_ENABLE_SET |\n\t\t\t LAN743X_VECTOR_FLAG_IRQ_SHARED;\n\t}\n\n\tif (adapter->csr.flags & LAN743X_CSR_FLAG_SUPPORTS_INTR_AUTO_SET_CLR) {\n\t\tflags &= ~LAN743X_VECTOR_FLAG_SOURCE_STATUS_READ;\n\t\tflags &= ~LAN743X_VECTOR_FLAG_SOURCE_STATUS_W2C;\n\t\tflags &= ~LAN743X_VECTOR_FLAG_SOURCE_ENABLE_CLEAR;\n\t\tflags &= ~LAN743X_VECTOR_FLAG_SOURCE_ENABLE_CHECK;\n\t\tflags |= LAN743X_VECTOR_FLAG_SOURCE_STATUS_R2C;\n\t\tflags |= LAN743X_VECTOR_FLAG_SOURCE_ENABLE_R2C;\n\t}\n\n\tinit_waitqueue_head(&intr->software_isr_wq);\n\n\tret = lan743x_intr_register_isr(adapter, 0, flags,\n\t\t\t\t\tINT_BIT_ALL_RX_ | INT_BIT_ALL_TX_ |\n\t\t\t\t\tINT_BIT_ALL_OTHER_,\n\t\t\t\t\tlan743x_intr_shared_isr, adapter);\n\tif (ret)\n\t\tgoto clean_up;\n\tintr->flags |= INTR_FLAG_IRQ_REQUESTED(0);\n\n\tif (intr->using_vectors)\n\t\tlan743x_csr_write(adapter, INT_VEC_EN_SET,\n\t\t\t\t  INT_VEC_EN_(0));\n\n\tif (!(adapter->csr.flags & LAN743X_CSR_FLAG_IS_A0)) {\n\t\tlan743x_csr_write(adapter, INT_MOD_CFG0, LAN743X_INT_MOD);\n\t\tlan743x_csr_write(adapter, INT_MOD_CFG1, LAN743X_INT_MOD);\n\t\tlan743x_csr_write(adapter, INT_MOD_CFG2, LAN743X_INT_MOD);\n\t\tlan743x_csr_write(adapter, INT_MOD_CFG3, LAN743X_INT_MOD);\n\t\tlan743x_csr_write(adapter, INT_MOD_CFG4, LAN743X_INT_MOD);\n\t\tlan743x_csr_write(adapter, INT_MOD_CFG5, LAN743X_INT_MOD);\n\t\tlan743x_csr_write(adapter, INT_MOD_CFG6, LAN743X_INT_MOD);\n\t\tlan743x_csr_write(adapter, INT_MOD_CFG7, LAN743X_INT_MOD);\n\t\tif (adapter->is_pci11x1x) {\n\t\t\tlan743x_csr_write(adapter, INT_MOD_CFG8, LAN743X_INT_MOD);\n\t\t\tlan743x_csr_write(adapter, INT_MOD_CFG9, LAN743X_INT_MOD);\n\t\t\tlan743x_csr_write(adapter, INT_MOD_MAP0, 0x00007654);\n\t\t\tlan743x_csr_write(adapter, INT_MOD_MAP1, 0x00003210);\n\t\t} else {\n\t\t\tlan743x_csr_write(adapter, INT_MOD_MAP0, 0x00005432);\n\t\t\tlan743x_csr_write(adapter, INT_MOD_MAP1, 0x00000001);\n\t\t}\n\t\tlan743x_csr_write(adapter, INT_MOD_MAP2, 0x00FFFFFF);\n\t}\n\n\t \n\tlan743x_csr_write(adapter, INT_EN_SET, INT_BIT_MAS_);\n\tret = lan743x_intr_test_isr(adapter);\n\tif (ret)\n\t\tgoto clean_up;\n\n\tif (intr->number_of_vectors > 1) {\n\t\tint number_of_tx_vectors = intr->number_of_vectors - 1;\n\n\t\tif (number_of_tx_vectors > used_tx_channels)\n\t\t\tnumber_of_tx_vectors = used_tx_channels;\n\t\tflags = LAN743X_VECTOR_FLAG_SOURCE_STATUS_READ |\n\t\t\tLAN743X_VECTOR_FLAG_SOURCE_STATUS_W2C |\n\t\t\tLAN743X_VECTOR_FLAG_SOURCE_ENABLE_CHECK |\n\t\t\tLAN743X_VECTOR_FLAG_SOURCE_ENABLE_CLEAR |\n\t\t\tLAN743X_VECTOR_FLAG_VECTOR_ENABLE_ISR_CLEAR |\n\t\t\tLAN743X_VECTOR_FLAG_VECTOR_ENABLE_ISR_SET;\n\n\t\tif (adapter->csr.flags &\n\t\t   LAN743X_CSR_FLAG_SUPPORTS_INTR_AUTO_SET_CLR) {\n\t\t\tflags = LAN743X_VECTOR_FLAG_VECTOR_ENABLE_AUTO_SET |\n\t\t\t\tLAN743X_VECTOR_FLAG_SOURCE_ENABLE_AUTO_SET |\n\t\t\t\tLAN743X_VECTOR_FLAG_SOURCE_ENABLE_AUTO_CLEAR |\n\t\t\t\tLAN743X_VECTOR_FLAG_SOURCE_STATUS_AUTO_CLEAR;\n\t\t}\n\n\t\tfor (index = 0; index < number_of_tx_vectors; index++) {\n\t\t\tu32 int_bit = INT_BIT_DMA_TX_(index);\n\t\t\tint vector = index + 1;\n\n\t\t\t \n\t\t\tint_vec_map1 |= INT_VEC_MAP1_TX_VEC_(index, vector);\n\t\t\tlan743x_csr_write(adapter, INT_VEC_MAP1, int_vec_map1);\n\n\t\t\t \n\t\t\tintr->vector_list[0].int_mask &= ~int_bit;\n\t\t\tret = lan743x_intr_register_isr(adapter, vector, flags,\n\t\t\t\t\t\t\tint_bit, lan743x_tx_isr,\n\t\t\t\t\t\t\t&adapter->tx[index]);\n\t\t\tif (ret)\n\t\t\t\tgoto clean_up;\n\t\t\tintr->flags |= INTR_FLAG_IRQ_REQUESTED(vector);\n\t\t\tif (!(flags &\n\t\t\t    LAN743X_VECTOR_FLAG_VECTOR_ENABLE_AUTO_SET))\n\t\t\t\tlan743x_csr_write(adapter, INT_VEC_EN_SET,\n\t\t\t\t\t\t  INT_VEC_EN_(vector));\n\t\t}\n\t}\n\tif ((intr->number_of_vectors - used_tx_channels) > 1) {\n\t\tint number_of_rx_vectors = intr->number_of_vectors -\n\t\t\t\t\t\tused_tx_channels - 1;\n\n\t\tif (number_of_rx_vectors > LAN743X_USED_RX_CHANNELS)\n\t\t\tnumber_of_rx_vectors = LAN743X_USED_RX_CHANNELS;\n\n\t\tflags = LAN743X_VECTOR_FLAG_SOURCE_STATUS_READ |\n\t\t\tLAN743X_VECTOR_FLAG_SOURCE_STATUS_W2C |\n\t\t\tLAN743X_VECTOR_FLAG_SOURCE_ENABLE_CHECK |\n\t\t\tLAN743X_VECTOR_FLAG_SOURCE_ENABLE_CLEAR |\n\t\t\tLAN743X_VECTOR_FLAG_VECTOR_ENABLE_ISR_CLEAR |\n\t\t\tLAN743X_VECTOR_FLAG_VECTOR_ENABLE_ISR_SET;\n\n\t\tif (adapter->csr.flags &\n\t\t    LAN743X_CSR_FLAG_SUPPORTS_INTR_AUTO_SET_CLR) {\n\t\t\tflags = LAN743X_VECTOR_FLAG_VECTOR_ENABLE_AUTO_CLEAR |\n\t\t\t\tLAN743X_VECTOR_FLAG_VECTOR_ENABLE_AUTO_SET |\n\t\t\t\tLAN743X_VECTOR_FLAG_SOURCE_ENABLE_AUTO_SET |\n\t\t\t\tLAN743X_VECTOR_FLAG_SOURCE_ENABLE_AUTO_CLEAR |\n\t\t\t\tLAN743X_VECTOR_FLAG_SOURCE_STATUS_AUTO_CLEAR;\n\t\t}\n\t\tfor (index = 0; index < number_of_rx_vectors; index++) {\n\t\t\tint vector = index + 1 + used_tx_channels;\n\t\t\tu32 int_bit = INT_BIT_DMA_RX_(index);\n\n\t\t\t \n\t\t\tint_vec_map0 |= INT_VEC_MAP0_RX_VEC_(index, vector);\n\t\t\tlan743x_csr_write(adapter, INT_VEC_MAP0, int_vec_map0);\n\t\t\tif (flags &\n\t\t\t    LAN743X_VECTOR_FLAG_VECTOR_ENABLE_AUTO_CLEAR) {\n\t\t\t\tint_vec_en_auto_clr |= INT_VEC_EN_(vector);\n\t\t\t\tlan743x_csr_write(adapter, INT_VEC_EN_AUTO_CLR,\n\t\t\t\t\t\t  int_vec_en_auto_clr);\n\t\t\t}\n\n\t\t\t \n\t\t\tintr->vector_list[0].int_mask &= ~int_bit;\n\t\t\tret = lan743x_intr_register_isr(adapter, vector, flags,\n\t\t\t\t\t\t\tint_bit, lan743x_rx_isr,\n\t\t\t\t\t\t\t&adapter->rx[index]);\n\t\t\tif (ret)\n\t\t\t\tgoto clean_up;\n\t\t\tintr->flags |= INTR_FLAG_IRQ_REQUESTED(vector);\n\n\t\t\tlan743x_csr_write(adapter, INT_VEC_EN_SET,\n\t\t\t\t\t  INT_VEC_EN_(vector));\n\t\t}\n\t}\n\treturn 0;\n\nclean_up:\n\tlan743x_intr_close(adapter);\n\treturn ret;\n}\n\nstatic int lan743x_dp_write(struct lan743x_adapter *adapter,\n\t\t\t    u32 select, u32 addr, u32 length, u32 *buf)\n{\n\tu32 dp_sel;\n\tint i;\n\n\tif (lan743x_csr_wait_for_bit_atomic(adapter, DP_SEL, DP_SEL_DPRDY_,\n\t\t\t\t\t    1, 40, 100, 100))\n\t\treturn -EIO;\n\tdp_sel = lan743x_csr_read(adapter, DP_SEL);\n\tdp_sel &= ~DP_SEL_MASK_;\n\tdp_sel |= select;\n\tlan743x_csr_write(adapter, DP_SEL, dp_sel);\n\n\tfor (i = 0; i < length; i++) {\n\t\tlan743x_csr_write(adapter, DP_ADDR, addr + i);\n\t\tlan743x_csr_write(adapter, DP_DATA_0, buf[i]);\n\t\tlan743x_csr_write(adapter, DP_CMD, DP_CMD_WRITE_);\n\t\tif (lan743x_csr_wait_for_bit_atomic(adapter, DP_SEL,\n\t\t\t\t\t\t    DP_SEL_DPRDY_,\n\t\t\t\t\t\t    1, 40, 100, 100))\n\t\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic u32 lan743x_mac_mii_access(u16 id, u16 index, int read)\n{\n\tu32 ret;\n\n\tret = (id << MAC_MII_ACC_PHY_ADDR_SHIFT_) &\n\t\tMAC_MII_ACC_PHY_ADDR_MASK_;\n\tret |= (index << MAC_MII_ACC_MIIRINDA_SHIFT_) &\n\t\tMAC_MII_ACC_MIIRINDA_MASK_;\n\n\tif (read)\n\t\tret |= MAC_MII_ACC_MII_READ_;\n\telse\n\t\tret |= MAC_MII_ACC_MII_WRITE_;\n\tret |= MAC_MII_ACC_MII_BUSY_;\n\n\treturn ret;\n}\n\nstatic int lan743x_mac_mii_wait_till_not_busy(struct lan743x_adapter *adapter)\n{\n\tu32 data;\n\n\treturn readx_poll_timeout(LAN743X_CSR_READ_OP, MAC_MII_ACC, data,\n\t\t\t\t  !(data & MAC_MII_ACC_MII_BUSY_), 0, 1000000);\n}\n\nstatic int lan743x_mdiobus_read_c22(struct mii_bus *bus, int phy_id, int index)\n{\n\tstruct lan743x_adapter *adapter = bus->priv;\n\tu32 val, mii_access;\n\tint ret;\n\n\t \n\tret = lan743x_mac_mii_wait_till_not_busy(adapter);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tmii_access = lan743x_mac_mii_access(phy_id, index, MAC_MII_READ);\n\tlan743x_csr_write(adapter, MAC_MII_ACC, mii_access);\n\tret = lan743x_mac_mii_wait_till_not_busy(adapter);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tval = lan743x_csr_read(adapter, MAC_MII_DATA);\n\treturn (int)(val & 0xFFFF);\n}\n\nstatic int lan743x_mdiobus_write_c22(struct mii_bus *bus,\n\t\t\t\t     int phy_id, int index, u16 regval)\n{\n\tstruct lan743x_adapter *adapter = bus->priv;\n\tu32 val, mii_access;\n\tint ret;\n\n\t \n\tret = lan743x_mac_mii_wait_till_not_busy(adapter);\n\tif (ret < 0)\n\t\treturn ret;\n\tval = (u32)regval;\n\tlan743x_csr_write(adapter, MAC_MII_DATA, val);\n\n\t \n\tmii_access = lan743x_mac_mii_access(phy_id, index, MAC_MII_WRITE);\n\tlan743x_csr_write(adapter, MAC_MII_ACC, mii_access);\n\tret = lan743x_mac_mii_wait_till_not_busy(adapter);\n\treturn ret;\n}\n\nstatic u32 lan743x_mac_mmd_access(int id, int dev_addr, int op)\n{\n\tu32 ret;\n\n\tret = (id << MAC_MII_ACC_PHY_ADDR_SHIFT_) &\n\t\tMAC_MII_ACC_PHY_ADDR_MASK_;\n\tret |= (dev_addr << MAC_MII_ACC_MIIMMD_SHIFT_) &\n\t\tMAC_MII_ACC_MIIMMD_MASK_;\n\tif (op == MMD_ACCESS_WRITE)\n\t\tret |= MAC_MII_ACC_MIICMD_WRITE_;\n\telse if (op == MMD_ACCESS_READ)\n\t\tret |= MAC_MII_ACC_MIICMD_READ_;\n\telse if (op == MMD_ACCESS_READ_INC)\n\t\tret |= MAC_MII_ACC_MIICMD_READ_INC_;\n\telse\n\t\tret |= MAC_MII_ACC_MIICMD_ADDR_;\n\tret |= (MAC_MII_ACC_MII_BUSY_ | MAC_MII_ACC_MIICL45_);\n\n\treturn ret;\n}\n\nstatic int lan743x_mdiobus_read_c45(struct mii_bus *bus, int phy_id,\n\t\t\t\t    int dev_addr, int index)\n{\n\tstruct lan743x_adapter *adapter = bus->priv;\n\tu32 mmd_access;\n\tint ret;\n\n\t \n\tret = lan743x_mac_mii_wait_till_not_busy(adapter);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tlan743x_csr_write(adapter, MAC_MII_DATA, index);\n\tmmd_access = lan743x_mac_mmd_access(phy_id, dev_addr,\n\t\t\t\t\t    MMD_ACCESS_ADDRESS);\n\tlan743x_csr_write(adapter, MAC_MII_ACC, mmd_access);\n\tret = lan743x_mac_mii_wait_till_not_busy(adapter);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tmmd_access = lan743x_mac_mmd_access(phy_id, dev_addr,\n\t\t\t\t\t    MMD_ACCESS_READ);\n\tlan743x_csr_write(adapter, MAC_MII_ACC, mmd_access);\n\tret = lan743x_mac_mii_wait_till_not_busy(adapter);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = lan743x_csr_read(adapter, MAC_MII_DATA);\n\treturn (int)(ret & 0xFFFF);\n}\n\nstatic int lan743x_mdiobus_write_c45(struct mii_bus *bus, int phy_id,\n\t\t\t\t     int dev_addr, int index, u16 regval)\n{\n\tstruct lan743x_adapter *adapter = bus->priv;\n\tu32 mmd_access;\n\tint ret;\n\n\t \n\tret = lan743x_mac_mii_wait_till_not_busy(adapter);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tlan743x_csr_write(adapter, MAC_MII_DATA, (u32)index);\n\tmmd_access = lan743x_mac_mmd_access(phy_id, dev_addr,\n\t\t\t\t\t    MMD_ACCESS_ADDRESS);\n\tlan743x_csr_write(adapter, MAC_MII_ACC, mmd_access);\n\tret = lan743x_mac_mii_wait_till_not_busy(adapter);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tlan743x_csr_write(adapter, MAC_MII_DATA, (u32)regval);\n\tmmd_access = lan743x_mac_mmd_access(phy_id, dev_addr,\n\t\t\t\t\t    MMD_ACCESS_WRITE);\n\tlan743x_csr_write(adapter, MAC_MII_ACC, mmd_access);\n\n\treturn lan743x_mac_mii_wait_till_not_busy(adapter);\n}\n\nstatic int lan743x_sgmii_wait_till_not_busy(struct lan743x_adapter *adapter)\n{\n\tu32 data;\n\tint ret;\n\n\tret = readx_poll_timeout(LAN743X_CSR_READ_OP, SGMII_ACC, data,\n\t\t\t\t !(data & SGMII_ACC_SGMII_BZY_), 100, 1000000);\n\tif (ret < 0)\n\t\tnetif_err(adapter, drv, adapter->netdev,\n\t\t\t  \"%s: error %d sgmii wait timeout\\n\", __func__, ret);\n\n\treturn ret;\n}\n\nint lan743x_sgmii_read(struct lan743x_adapter *adapter, u8 mmd, u16 addr)\n{\n\tu32 mmd_access;\n\tint ret;\n\tu32 val;\n\n\tif (mmd > 31) {\n\t\tnetif_err(adapter, probe, adapter->netdev,\n\t\t\t  \"%s mmd should <= 31\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&adapter->sgmii_rw_lock);\n\t \n\tmmd_access = mmd << SGMII_ACC_SGMII_MMD_SHIFT_;\n\tmmd_access |= (addr | SGMII_ACC_SGMII_BZY_);\n\tlan743x_csr_write(adapter, SGMII_ACC, mmd_access);\n\tret = lan743x_sgmii_wait_till_not_busy(adapter);\n\tif (ret < 0)\n\t\tgoto sgmii_unlock;\n\n\tval = lan743x_csr_read(adapter, SGMII_DATA);\n\tret = (int)(val & SGMII_DATA_MASK_);\n\nsgmii_unlock:\n\tmutex_unlock(&adapter->sgmii_rw_lock);\n\n\treturn ret;\n}\n\nstatic int lan743x_sgmii_write(struct lan743x_adapter *adapter,\n\t\t\t       u8 mmd, u16 addr, u16 val)\n{\n\tu32 mmd_access;\n\tint ret;\n\n\tif (mmd > 31) {\n\t\tnetif_err(adapter, probe, adapter->netdev,\n\t\t\t  \"%s mmd should <= 31\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\tmutex_lock(&adapter->sgmii_rw_lock);\n\t \n\tlan743x_csr_write(adapter, SGMII_DATA, (u32)(val & SGMII_DATA_MASK_));\n\t \n\tmmd_access = mmd << SGMII_ACC_SGMII_MMD_SHIFT_;\n\tmmd_access |= (addr | SGMII_ACC_SGMII_BZY_ | SGMII_ACC_SGMII_WR_);\n\tlan743x_csr_write(adapter, SGMII_ACC, mmd_access);\n\tret = lan743x_sgmii_wait_till_not_busy(adapter);\n\tmutex_unlock(&adapter->sgmii_rw_lock);\n\n\treturn ret;\n}\n\nstatic int lan743x_sgmii_mpll_set(struct lan743x_adapter *adapter,\n\t\t\t\t  u16 baud)\n{\n\tint mpllctrl0;\n\tint mpllctrl1;\n\tint miscctrl1;\n\tint ret;\n\n\tmpllctrl0 = lan743x_sgmii_read(adapter, MDIO_MMD_VEND2,\n\t\t\t\t       VR_MII_GEN2_4_MPLL_CTRL0);\n\tif (mpllctrl0 < 0)\n\t\treturn mpllctrl0;\n\n\tmpllctrl0 &= ~VR_MII_MPLL_CTRL0_USE_REFCLK_PAD_;\n\tif (baud == VR_MII_BAUD_RATE_1P25GBPS) {\n\t\tmpllctrl1 = VR_MII_MPLL_MULTIPLIER_100;\n\t\t \n\t\tmiscctrl1 = 0xA;\n\t} else {\n\t\tmpllctrl1 = VR_MII_MPLL_MULTIPLIER_125;\n\t\t \n\t\tmiscctrl1 = 0x5;\n\t}\n\n\tret = lan743x_sgmii_write(adapter, MDIO_MMD_VEND2,\n\t\t\t\t  VR_MII_GEN2_4_MPLL_CTRL0, mpllctrl0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = lan743x_sgmii_write(adapter, MDIO_MMD_VEND2,\n\t\t\t\t  VR_MII_GEN2_4_MPLL_CTRL1, mpllctrl1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn lan743x_sgmii_write(adapter, MDIO_MMD_VEND2,\n\t\t\t\t  VR_MII_GEN2_4_MISC_CTRL1, miscctrl1);\n}\n\nstatic int lan743x_sgmii_2_5G_mode_set(struct lan743x_adapter *adapter,\n\t\t\t\t       bool enable)\n{\n\tif (enable)\n\t\treturn lan743x_sgmii_mpll_set(adapter,\n\t\t\t\t\t      VR_MII_BAUD_RATE_3P125GBPS);\n\telse\n\t\treturn lan743x_sgmii_mpll_set(adapter,\n\t\t\t\t\t      VR_MII_BAUD_RATE_1P25GBPS);\n}\n\nstatic int lan743x_is_sgmii_2_5G_mode(struct lan743x_adapter *adapter,\n\t\t\t\t      bool *status)\n{\n\tint ret;\n\n\tret = lan743x_sgmii_read(adapter, MDIO_MMD_VEND2,\n\t\t\t\t VR_MII_GEN2_4_MPLL_CTRL1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ret == VR_MII_MPLL_MULTIPLIER_125 ||\n\t    ret == VR_MII_MPLL_MULTIPLIER_50)\n\t\t*status = true;\n\telse\n\t\t*status = false;\n\n\treturn 0;\n}\n\nstatic int lan743x_sgmii_aneg_update(struct lan743x_adapter *adapter)\n{\n\tenum lan743x_sgmii_lsd lsd = adapter->sgmii_lsd;\n\tint mii_ctrl;\n\tint dgt_ctrl;\n\tint an_ctrl;\n\tint ret;\n\n\tif (lsd == LINK_2500_MASTER || lsd == LINK_2500_SLAVE)\n\t\t \n\t\tret = lan743x_sgmii_2_5G_mode_set(adapter, true);\n\telse\n\t\t \n\t\tret = lan743x_sgmii_2_5G_mode_set(adapter, false);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tmii_ctrl = lan743x_sgmii_read(adapter, MDIO_MMD_VEND2, MII_BMCR);\n\tif (mii_ctrl < 0)\n\t\treturn mii_ctrl;\n\n\tan_ctrl = lan743x_sgmii_read(adapter, MDIO_MMD_VEND2, VR_MII_AN_CTRL);\n\tif (an_ctrl < 0)\n\t\treturn an_ctrl;\n\n\tdgt_ctrl = lan743x_sgmii_read(adapter, MDIO_MMD_VEND2,\n\t\t\t\t      VR_MII_DIG_CTRL1);\n\tif (dgt_ctrl < 0)\n\t\treturn dgt_ctrl;\n\n\tif (lsd == LINK_2500_MASTER || lsd == LINK_2500_SLAVE) {\n\t\tmii_ctrl &= ~(BMCR_ANENABLE | BMCR_ANRESTART | BMCR_SPEED100);\n\t\tmii_ctrl |= BMCR_SPEED1000;\n\t\tdgt_ctrl |= VR_MII_DIG_CTRL1_CL37_TMR_OVR_RIDE_;\n\t\tdgt_ctrl &= ~VR_MII_DIG_CTRL1_MAC_AUTO_SW_;\n\t\t \n\t\tret = lan743x_sgmii_write(adapter, MDIO_MMD_VEND2,\n\t\t\t\t\t  VR_MII_LINK_TIMER_CTRL, 0x7A1);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t} else {\n\t\tmii_ctrl |= (BMCR_ANENABLE | BMCR_ANRESTART);\n\t\tan_ctrl &= ~VR_MII_AN_CTRL_SGMII_LINK_STS_;\n\t\tdgt_ctrl &= ~VR_MII_DIG_CTRL1_CL37_TMR_OVR_RIDE_;\n\t\tdgt_ctrl |= VR_MII_DIG_CTRL1_MAC_AUTO_SW_;\n\t}\n\n\tret = lan743x_sgmii_write(adapter, MDIO_MMD_VEND2, MII_BMCR,\n\t\t\t\t  mii_ctrl);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = lan743x_sgmii_write(adapter, MDIO_MMD_VEND2,\n\t\t\t\t  VR_MII_DIG_CTRL1, dgt_ctrl);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn lan743x_sgmii_write(adapter, MDIO_MMD_VEND2,\n\t\t\t\t  VR_MII_AN_CTRL, an_ctrl);\n}\n\nstatic int lan743x_pcs_seq_state(struct lan743x_adapter *adapter, u8 state)\n{\n\tu8 wait_cnt = 0;\n\tu32 dig_sts;\n\n\tdo {\n\t\tdig_sts = lan743x_sgmii_read(adapter, MDIO_MMD_VEND2,\n\t\t\t\t\t     VR_MII_DIG_STS);\n\t\tif (((dig_sts & VR_MII_DIG_STS_PSEQ_STATE_MASK_) >>\n\t\t      VR_MII_DIG_STS_PSEQ_STATE_POS_) == state)\n\t\t\tbreak;\n\t\tusleep_range(1000, 2000);\n\t} while (wait_cnt++ < 10);\n\n\tif (wait_cnt >= 10)\n\t\treturn -ETIMEDOUT;\n\n\treturn 0;\n}\n\nstatic int lan743x_sgmii_config(struct lan743x_adapter *adapter)\n{\n\tstruct net_device *netdev = adapter->netdev;\n\tstruct phy_device *phydev = netdev->phydev;\n\tenum lan743x_sgmii_lsd lsd = POWER_DOWN;\n\tint mii_ctl;\n\tbool status;\n\tint ret;\n\n\tswitch (phydev->speed) {\n\tcase SPEED_2500:\n\t\tif (phydev->master_slave_state == MASTER_SLAVE_STATE_MASTER)\n\t\t\tlsd = LINK_2500_MASTER;\n\t\telse\n\t\t\tlsd = LINK_2500_SLAVE;\n\t\tbreak;\n\tcase SPEED_1000:\n\t\tif (phydev->master_slave_state == MASTER_SLAVE_STATE_MASTER)\n\t\t\tlsd = LINK_1000_MASTER;\n\t\telse\n\t\t\tlsd = LINK_1000_SLAVE;\n\t\tbreak;\n\tcase SPEED_100:\n\t\tif (phydev->duplex)\n\t\t\tlsd = LINK_100FD;\n\t\telse\n\t\t\tlsd = LINK_100HD;\n\t\tbreak;\n\tcase SPEED_10:\n\t\tif (phydev->duplex)\n\t\t\tlsd = LINK_10FD;\n\t\telse\n\t\t\tlsd = LINK_10HD;\n\t\tbreak;\n\tdefault:\n\t\tnetif_err(adapter, drv, adapter->netdev,\n\t\t\t  \"Invalid speed %d\\n\", phydev->speed);\n\t\treturn -EINVAL;\n\t}\n\n\tadapter->sgmii_lsd = lsd;\n\tret = lan743x_sgmii_aneg_update(adapter);\n\tif (ret < 0) {\n\t\tnetif_err(adapter, drv, adapter->netdev,\n\t\t\t  \"error %d SGMII cfg failed\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = lan743x_is_sgmii_2_5G_mode(adapter, &status);\n\tif (ret < 0) {\n\t\tnetif_err(adapter, drv, adapter->netdev,\n\t\t\t  \"erro %d SGMII get mode failed\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (status)\n\t\tnetif_dbg(adapter, drv, adapter->netdev,\n\t\t\t  \"SGMII 2.5G mode enable\\n\");\n\telse\n\t\tnetif_dbg(adapter, drv, adapter->netdev,\n\t\t\t  \"SGMII 1G mode enable\\n\");\n\n\t \n\tmii_ctl = lan743x_sgmii_read(adapter, MDIO_MMD_VEND2, MII_BMCR);\n\tif (mii_ctl < 0)\n\t\treturn mii_ctl;\n\n\tmii_ctl |= BMCR_PDOWN;\n\tret = lan743x_sgmii_write(adapter, MDIO_MMD_VEND2, MII_BMCR, mii_ctl);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = lan743x_pcs_seq_state(adapter, PCS_POWER_STATE_DOWN);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tmii_ctl &= ~BMCR_PDOWN;\n\tret = lan743x_sgmii_write(adapter, MDIO_MMD_VEND2, MII_BMCR, mii_ctl);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = lan743x_pcs_seq_state(adapter, PCS_POWER_STATE_UP);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic void lan743x_mac_set_address(struct lan743x_adapter *adapter,\n\t\t\t\t    u8 *addr)\n{\n\tu32 addr_lo, addr_hi;\n\n\taddr_lo = addr[0] |\n\t\taddr[1] << 8 |\n\t\taddr[2] << 16 |\n\t\taddr[3] << 24;\n\taddr_hi = addr[4] |\n\t\taddr[5] << 8;\n\tlan743x_csr_write(adapter, MAC_RX_ADDRL, addr_lo);\n\tlan743x_csr_write(adapter, MAC_RX_ADDRH, addr_hi);\n\n\tether_addr_copy(adapter->mac_address, addr);\n\tnetif_info(adapter, drv, adapter->netdev,\n\t\t   \"MAC address set to %pM\\n\", addr);\n}\n\nstatic int lan743x_mac_init(struct lan743x_adapter *adapter)\n{\n\tbool mac_address_valid = true;\n\tstruct net_device *netdev;\n\tu32 mac_addr_hi = 0;\n\tu32 mac_addr_lo = 0;\n\tu32 data;\n\n\tnetdev = adapter->netdev;\n\n\t \n\tdata = lan743x_csr_read(adapter, MAC_CR);\n\tdata &= ~(MAC_CR_ADD_ | MAC_CR_ASD_);\n\tdata |= MAC_CR_CNTR_RST_;\n\tlan743x_csr_write(adapter, MAC_CR, data);\n\n\tif (!is_valid_ether_addr(adapter->mac_address)) {\n\t\tmac_addr_hi = lan743x_csr_read(adapter, MAC_RX_ADDRH);\n\t\tmac_addr_lo = lan743x_csr_read(adapter, MAC_RX_ADDRL);\n\t\tadapter->mac_address[0] = mac_addr_lo & 0xFF;\n\t\tadapter->mac_address[1] = (mac_addr_lo >> 8) & 0xFF;\n\t\tadapter->mac_address[2] = (mac_addr_lo >> 16) & 0xFF;\n\t\tadapter->mac_address[3] = (mac_addr_lo >> 24) & 0xFF;\n\t\tadapter->mac_address[4] = mac_addr_hi & 0xFF;\n\t\tadapter->mac_address[5] = (mac_addr_hi >> 8) & 0xFF;\n\n\t\tif (((mac_addr_hi & 0x0000FFFF) == 0x0000FFFF) &&\n\t\t    mac_addr_lo == 0xFFFFFFFF) {\n\t\t\tmac_address_valid = false;\n\t\t} else if (!is_valid_ether_addr(adapter->mac_address)) {\n\t\t\tmac_address_valid = false;\n\t\t}\n\n\t\tif (!mac_address_valid)\n\t\t\teth_random_addr(adapter->mac_address);\n\t}\n\tlan743x_mac_set_address(adapter, adapter->mac_address);\n\teth_hw_addr_set(netdev, adapter->mac_address);\n\n\treturn 0;\n}\n\nstatic int lan743x_mac_open(struct lan743x_adapter *adapter)\n{\n\tu32 temp;\n\n\ttemp = lan743x_csr_read(adapter, MAC_RX);\n\tlan743x_csr_write(adapter, MAC_RX, temp | MAC_RX_RXEN_);\n\ttemp = lan743x_csr_read(adapter, MAC_TX);\n\tlan743x_csr_write(adapter, MAC_TX, temp | MAC_TX_TXEN_);\n\treturn 0;\n}\n\nstatic void lan743x_mac_close(struct lan743x_adapter *adapter)\n{\n\tu32 temp;\n\n\ttemp = lan743x_csr_read(adapter, MAC_TX);\n\ttemp &= ~MAC_TX_TXEN_;\n\tlan743x_csr_write(adapter, MAC_TX, temp);\n\tlan743x_csr_wait_for_bit(adapter, MAC_TX, MAC_TX_TXD_,\n\t\t\t\t 1, 1000, 20000, 100);\n\n\ttemp = lan743x_csr_read(adapter, MAC_RX);\n\ttemp &= ~MAC_RX_RXEN_;\n\tlan743x_csr_write(adapter, MAC_RX, temp);\n\tlan743x_csr_wait_for_bit(adapter, MAC_RX, MAC_RX_RXD_,\n\t\t\t\t 1, 1000, 20000, 100);\n}\n\nvoid lan743x_mac_flow_ctrl_set_enables(struct lan743x_adapter *adapter,\n\t\t\t\t       bool tx_enable, bool rx_enable)\n{\n\tu32 flow_setting = 0;\n\n\t \n\tflow_setting = MAC_FLOW_CR_FCPT_MASK_;\n\tif (tx_enable)\n\t\tflow_setting |= MAC_FLOW_CR_TX_FCEN_;\n\tif (rx_enable)\n\t\tflow_setting |= MAC_FLOW_CR_RX_FCEN_;\n\tlan743x_csr_write(adapter, MAC_FLOW, flow_setting);\n}\n\nstatic int lan743x_mac_set_mtu(struct lan743x_adapter *adapter, int new_mtu)\n{\n\tint enabled = 0;\n\tu32 mac_rx = 0;\n\n\tmac_rx = lan743x_csr_read(adapter, MAC_RX);\n\tif (mac_rx & MAC_RX_RXEN_) {\n\t\tenabled = 1;\n\t\tif (mac_rx & MAC_RX_RXD_) {\n\t\t\tlan743x_csr_write(adapter, MAC_RX, mac_rx);\n\t\t\tmac_rx &= ~MAC_RX_RXD_;\n\t\t}\n\t\tmac_rx &= ~MAC_RX_RXEN_;\n\t\tlan743x_csr_write(adapter, MAC_RX, mac_rx);\n\t\tlan743x_csr_wait_for_bit(adapter, MAC_RX, MAC_RX_RXD_,\n\t\t\t\t\t 1, 1000, 20000, 100);\n\t\tlan743x_csr_write(adapter, MAC_RX, mac_rx | MAC_RX_RXD_);\n\t}\n\n\tmac_rx &= ~(MAC_RX_MAX_SIZE_MASK_);\n\tmac_rx |= (((new_mtu + ETH_HLEN + ETH_FCS_LEN)\n\t\t  << MAC_RX_MAX_SIZE_SHIFT_) & MAC_RX_MAX_SIZE_MASK_);\n\tlan743x_csr_write(adapter, MAC_RX, mac_rx);\n\n\tif (enabled) {\n\t\tmac_rx |= MAC_RX_RXEN_;\n\t\tlan743x_csr_write(adapter, MAC_RX, mac_rx);\n\t}\n\treturn 0;\n}\n\n \nstatic int lan743x_phy_reset(struct lan743x_adapter *adapter)\n{\n\tu32 data;\n\n\t \n\n\tdata = lan743x_csr_read(adapter, PMT_CTL);\n\tdata |= PMT_CTL_ETH_PHY_RST_;\n\tlan743x_csr_write(adapter, PMT_CTL, data);\n\n\treturn readx_poll_timeout(LAN743X_CSR_READ_OP, PMT_CTL, data,\n\t\t\t\t  (!(data & PMT_CTL_ETH_PHY_RST_) &&\n\t\t\t\t  (data & PMT_CTL_READY_)),\n\t\t\t\t  50000, 1000000);\n}\n\nstatic void lan743x_phy_update_flowcontrol(struct lan743x_adapter *adapter,\n\t\t\t\t\t   u16 local_adv, u16 remote_adv)\n{\n\tstruct lan743x_phy *phy = &adapter->phy;\n\tu8 cap;\n\n\tif (phy->fc_autoneg)\n\t\tcap = mii_resolve_flowctrl_fdx(local_adv, remote_adv);\n\telse\n\t\tcap = phy->fc_request_control;\n\n\tlan743x_mac_flow_ctrl_set_enables(adapter,\n\t\t\t\t\t  cap & FLOW_CTRL_TX,\n\t\t\t\t\t  cap & FLOW_CTRL_RX);\n}\n\nstatic int lan743x_phy_init(struct lan743x_adapter *adapter)\n{\n\treturn lan743x_phy_reset(adapter);\n}\n\nstatic void lan743x_phy_link_status_change(struct net_device *netdev)\n{\n\tstruct lan743x_adapter *adapter = netdev_priv(netdev);\n\tstruct phy_device *phydev = netdev->phydev;\n\tu32 data;\n\n\tphy_print_status(phydev);\n\tif (phydev->state == PHY_RUNNING) {\n\t\tint remote_advertisement = 0;\n\t\tint local_advertisement = 0;\n\n\t\tdata = lan743x_csr_read(adapter, MAC_CR);\n\n\t\t \n\t\tif (phydev->duplex)\n\t\t\tdata |= MAC_CR_DPX_;\n\t\telse\n\t\t\tdata &= ~MAC_CR_DPX_;\n\n\t\t \n\t\tswitch (phydev->speed) {\n\t\tcase SPEED_10:\n\t\t\tdata &= ~MAC_CR_CFG_H_;\n\t\t\tdata &= ~MAC_CR_CFG_L_;\n\t\tbreak;\n\t\tcase SPEED_100:\n\t\t\tdata &= ~MAC_CR_CFG_H_;\n\t\t\tdata |= MAC_CR_CFG_L_;\n\t\tbreak;\n\t\tcase SPEED_1000:\n\t\t\tdata |= MAC_CR_CFG_H_;\n\t\t\tdata &= ~MAC_CR_CFG_L_;\n\t\tbreak;\n\t\tcase SPEED_2500:\n\t\t\tdata |= MAC_CR_CFG_H_;\n\t\t\tdata |= MAC_CR_CFG_L_;\n\t\tbreak;\n\t\t}\n\t\tlan743x_csr_write(adapter, MAC_CR, data);\n\n\t\tlocal_advertisement =\n\t\t\tlinkmode_adv_to_mii_adv_t(phydev->advertising);\n\t\tremote_advertisement =\n\t\t\tlinkmode_adv_to_mii_adv_t(phydev->lp_advertising);\n\n\t\tlan743x_phy_update_flowcontrol(adapter, local_advertisement,\n\t\t\t\t\t       remote_advertisement);\n\t\tlan743x_ptp_update_latency(adapter, phydev->speed);\n\t\tif (phydev->interface == PHY_INTERFACE_MODE_SGMII ||\n\t\t    phydev->interface == PHY_INTERFACE_MODE_1000BASEX ||\n\t\t    phydev->interface == PHY_INTERFACE_MODE_2500BASEX)\n\t\t\tlan743x_sgmii_config(adapter);\n\t}\n}\n\nstatic void lan743x_phy_close(struct lan743x_adapter *adapter)\n{\n\tstruct net_device *netdev = adapter->netdev;\n\n\tphy_stop(netdev->phydev);\n\tphy_disconnect(netdev->phydev);\n}\n\nstatic void lan743x_phy_interface_select(struct lan743x_adapter *adapter)\n{\n\tu32 id_rev;\n\tu32 data;\n\n\tdata = lan743x_csr_read(adapter, MAC_CR);\n\tid_rev = adapter->csr.id_rev & ID_REV_ID_MASK_;\n\n\tif (adapter->is_pci11x1x && adapter->is_sgmii_en)\n\t\tadapter->phy_interface = PHY_INTERFACE_MODE_SGMII;\n\telse if (id_rev == ID_REV_ID_LAN7430_)\n\t\tadapter->phy_interface = PHY_INTERFACE_MODE_GMII;\n\telse if ((id_rev == ID_REV_ID_LAN7431_) && (data & MAC_CR_MII_EN_))\n\t\tadapter->phy_interface = PHY_INTERFACE_MODE_MII;\n\telse\n\t\tadapter->phy_interface = PHY_INTERFACE_MODE_RGMII;\n}\n\nstatic int lan743x_phy_open(struct lan743x_adapter *adapter)\n{\n\tstruct net_device *netdev = adapter->netdev;\n\tstruct lan743x_phy *phy = &adapter->phy;\n\tstruct fixed_phy_status fphy_status = {\n\t\t.link = 1,\n\t\t.speed = SPEED_1000,\n\t\t.duplex = DUPLEX_FULL,\n\t};\n\tstruct phy_device *phydev;\n\tint ret = -EIO;\n\n\t \n\tphydev = of_phy_get_and_connect(netdev, adapter->pdev->dev.of_node,\n\t\t\t\t\tlan743x_phy_link_status_change);\n\n\tif (!phydev) {\n\t\t \n\t\tphydev = phy_find_first(adapter->mdiobus);\n\t\tif (!phydev)\t{\n\t\t\tif ((adapter->csr.id_rev & ID_REV_ID_MASK_) ==\n\t\t\t\t\tID_REV_ID_LAN7431_) {\n\t\t\t\tphydev = fixed_phy_register(PHY_POLL,\n\t\t\t\t\t\t\t    &fphy_status, NULL);\n\t\t\t\tif (IS_ERR(phydev)) {\n\t\t\t\t\tnetdev_err(netdev, \"No PHY/fixed_PHY found\\n\");\n\t\t\t\t\treturn PTR_ERR(phydev);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tgoto return_error;\n\t\t\t\t}\n\t\t}\n\n\t\tlan743x_phy_interface_select(adapter);\n\n\t\tret = phy_connect_direct(netdev, phydev,\n\t\t\t\t\t lan743x_phy_link_status_change,\n\t\t\t\t\t adapter->phy_interface);\n\t\tif (ret)\n\t\t\tgoto return_error;\n\t}\n\n\t \n\tphy_remove_link_mode(phydev, ETHTOOL_LINK_MODE_1000baseT_Half_BIT);\n\n\t \n\tphy_support_asym_pause(phydev);\n\tphy->fc_request_control = (FLOW_CTRL_RX | FLOW_CTRL_TX);\n\tphy->fc_autoneg = phydev->autoneg;\n\n\tphy_start(phydev);\n\tphy_start_aneg(phydev);\n\tphy_attached_info(phydev);\n\treturn 0;\n\nreturn_error:\n\treturn ret;\n}\n\nstatic void lan743x_rfe_open(struct lan743x_adapter *adapter)\n{\n\tlan743x_csr_write(adapter, RFE_RSS_CFG,\n\t\tRFE_RSS_CFG_UDP_IPV6_EX_ |\n\t\tRFE_RSS_CFG_TCP_IPV6_EX_ |\n\t\tRFE_RSS_CFG_IPV6_EX_ |\n\t\tRFE_RSS_CFG_UDP_IPV6_ |\n\t\tRFE_RSS_CFG_TCP_IPV6_ |\n\t\tRFE_RSS_CFG_IPV6_ |\n\t\tRFE_RSS_CFG_UDP_IPV4_ |\n\t\tRFE_RSS_CFG_TCP_IPV4_ |\n\t\tRFE_RSS_CFG_IPV4_ |\n\t\tRFE_RSS_CFG_VALID_HASH_BITS_ |\n\t\tRFE_RSS_CFG_RSS_QUEUE_ENABLE_ |\n\t\tRFE_RSS_CFG_RSS_HASH_STORE_ |\n\t\tRFE_RSS_CFG_RSS_ENABLE_);\n}\n\nstatic void lan743x_rfe_update_mac_address(struct lan743x_adapter *adapter)\n{\n\tu8 *mac_addr;\n\tu32 mac_addr_hi = 0;\n\tu32 mac_addr_lo = 0;\n\n\t \n\tmac_addr = adapter->mac_address;\n\tmac_addr_lo = ((((u32)(mac_addr[0])) << 0) |\n\t\t      (((u32)(mac_addr[1])) << 8) |\n\t\t      (((u32)(mac_addr[2])) << 16) |\n\t\t      (((u32)(mac_addr[3])) << 24));\n\tmac_addr_hi = ((((u32)(mac_addr[4])) << 0) |\n\t\t      (((u32)(mac_addr[5])) << 8));\n\n\tlan743x_csr_write(adapter, RFE_ADDR_FILT_LO(0), mac_addr_lo);\n\tlan743x_csr_write(adapter, RFE_ADDR_FILT_HI(0),\n\t\t\t  mac_addr_hi | RFE_ADDR_FILT_HI_VALID_);\n}\n\nstatic void lan743x_rfe_set_multicast(struct lan743x_adapter *adapter)\n{\n\tstruct net_device *netdev = adapter->netdev;\n\tu32 hash_table[DP_SEL_VHF_HASH_LEN];\n\tu32 rfctl;\n\tu32 data;\n\n\trfctl = lan743x_csr_read(adapter, RFE_CTL);\n\trfctl &= ~(RFE_CTL_AU_ | RFE_CTL_AM_ |\n\t\t RFE_CTL_DA_PERFECT_ | RFE_CTL_MCAST_HASH_);\n\trfctl |= RFE_CTL_AB_;\n\tif (netdev->flags & IFF_PROMISC) {\n\t\trfctl |= RFE_CTL_AM_ | RFE_CTL_AU_;\n\t} else {\n\t\tif (netdev->flags & IFF_ALLMULTI)\n\t\t\trfctl |= RFE_CTL_AM_;\n\t}\n\n\tif (netdev->features & NETIF_F_RXCSUM)\n\t\trfctl |= RFE_CTL_IP_COE_ | RFE_CTL_TCP_UDP_COE_;\n\n\tmemset(hash_table, 0, DP_SEL_VHF_HASH_LEN * sizeof(u32));\n\tif (netdev_mc_count(netdev)) {\n\t\tstruct netdev_hw_addr *ha;\n\t\tint i;\n\n\t\trfctl |= RFE_CTL_DA_PERFECT_;\n\t\ti = 1;\n\t\tnetdev_for_each_mc_addr(ha, netdev) {\n\t\t\t \n\t\t\tif (i < 33) {\n\t\t\t\tlan743x_csr_write(adapter,\n\t\t\t\t\t\t  RFE_ADDR_FILT_HI(i), 0);\n\t\t\t\tdata = ha->addr[3];\n\t\t\t\tdata = ha->addr[2] | (data << 8);\n\t\t\t\tdata = ha->addr[1] | (data << 8);\n\t\t\t\tdata = ha->addr[0] | (data << 8);\n\t\t\t\tlan743x_csr_write(adapter,\n\t\t\t\t\t\t  RFE_ADDR_FILT_LO(i), data);\n\t\t\t\tdata = ha->addr[5];\n\t\t\t\tdata = ha->addr[4] | (data << 8);\n\t\t\t\tdata |= RFE_ADDR_FILT_HI_VALID_;\n\t\t\t\tlan743x_csr_write(adapter,\n\t\t\t\t\t\t  RFE_ADDR_FILT_HI(i), data);\n\t\t\t} else {\n\t\t\t\tu32 bitnum = (ether_crc(ETH_ALEN, ha->addr) >>\n\t\t\t\t\t     23) & 0x1FF;\n\t\t\t\thash_table[bitnum / 32] |= (1 << (bitnum % 32));\n\t\t\t\trfctl |= RFE_CTL_MCAST_HASH_;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t}\n\n\tlan743x_dp_write(adapter, DP_SEL_RFE_RAM,\n\t\t\t DP_SEL_VHF_VLAN_LEN,\n\t\t\t DP_SEL_VHF_HASH_LEN, hash_table);\n\tlan743x_csr_write(adapter, RFE_CTL, rfctl);\n}\n\nstatic int lan743x_dmac_init(struct lan743x_adapter *adapter)\n{\n\tu32 data = 0;\n\n\tlan743x_csr_write(adapter, DMAC_CMD, DMAC_CMD_SWR_);\n\tlan743x_csr_wait_for_bit(adapter, DMAC_CMD, DMAC_CMD_SWR_,\n\t\t\t\t 0, 1000, 20000, 100);\n\tswitch (DEFAULT_DMA_DESCRIPTOR_SPACING) {\n\tcase DMA_DESCRIPTOR_SPACING_16:\n\t\tdata = DMAC_CFG_MAX_DSPACE_16_;\n\t\tbreak;\n\tcase DMA_DESCRIPTOR_SPACING_32:\n\t\tdata = DMAC_CFG_MAX_DSPACE_32_;\n\t\tbreak;\n\tcase DMA_DESCRIPTOR_SPACING_64:\n\t\tdata = DMAC_CFG_MAX_DSPACE_64_;\n\t\tbreak;\n\tcase DMA_DESCRIPTOR_SPACING_128:\n\t\tdata = DMAC_CFG_MAX_DSPACE_128_;\n\t\tbreak;\n\tdefault:\n\t\treturn -EPERM;\n\t}\n\tif (!(adapter->csr.flags & LAN743X_CSR_FLAG_IS_A0))\n\t\tdata |= DMAC_CFG_COAL_EN_;\n\tdata |= DMAC_CFG_CH_ARB_SEL_RX_HIGH_;\n\tdata |= DMAC_CFG_MAX_READ_REQ_SET_(6);\n\tlan743x_csr_write(adapter, DMAC_CFG, data);\n\tdata = DMAC_COAL_CFG_TIMER_LIMIT_SET_(1);\n\tdata |= DMAC_COAL_CFG_TIMER_TX_START_;\n\tdata |= DMAC_COAL_CFG_FLUSH_INTS_;\n\tdata |= DMAC_COAL_CFG_INT_EXIT_COAL_;\n\tdata |= DMAC_COAL_CFG_CSR_EXIT_COAL_;\n\tdata |= DMAC_COAL_CFG_TX_THRES_SET_(0x0A);\n\tdata |= DMAC_COAL_CFG_RX_THRES_SET_(0x0C);\n\tlan743x_csr_write(adapter, DMAC_COAL_CFG, data);\n\tdata = DMAC_OBFF_TX_THRES_SET_(0x08);\n\tdata |= DMAC_OBFF_RX_THRES_SET_(0x0A);\n\tlan743x_csr_write(adapter, DMAC_OBFF_CFG, data);\n\treturn 0;\n}\n\nstatic int lan743x_dmac_tx_get_state(struct lan743x_adapter *adapter,\n\t\t\t\t     int tx_channel)\n{\n\tu32 dmac_cmd = 0;\n\n\tdmac_cmd = lan743x_csr_read(adapter, DMAC_CMD);\n\treturn DMAC_CHANNEL_STATE_SET((dmac_cmd &\n\t\t\t\t      DMAC_CMD_START_T_(tx_channel)),\n\t\t\t\t      (dmac_cmd &\n\t\t\t\t      DMAC_CMD_STOP_T_(tx_channel)));\n}\n\nstatic int lan743x_dmac_tx_wait_till_stopped(struct lan743x_adapter *adapter,\n\t\t\t\t\t     int tx_channel)\n{\n\tint timeout = 100;\n\tint result = 0;\n\n\twhile (timeout &&\n\t       ((result = lan743x_dmac_tx_get_state(adapter, tx_channel)) ==\n\t       DMAC_CHANNEL_STATE_STOP_PENDING)) {\n\t\tusleep_range(1000, 20000);\n\t\ttimeout--;\n\t}\n\tif (result == DMAC_CHANNEL_STATE_STOP_PENDING)\n\t\tresult = -ENODEV;\n\treturn result;\n}\n\nstatic int lan743x_dmac_rx_get_state(struct lan743x_adapter *adapter,\n\t\t\t\t     int rx_channel)\n{\n\tu32 dmac_cmd = 0;\n\n\tdmac_cmd = lan743x_csr_read(adapter, DMAC_CMD);\n\treturn DMAC_CHANNEL_STATE_SET((dmac_cmd &\n\t\t\t\t      DMAC_CMD_START_R_(rx_channel)),\n\t\t\t\t      (dmac_cmd &\n\t\t\t\t      DMAC_CMD_STOP_R_(rx_channel)));\n}\n\nstatic int lan743x_dmac_rx_wait_till_stopped(struct lan743x_adapter *adapter,\n\t\t\t\t\t     int rx_channel)\n{\n\tint timeout = 100;\n\tint result = 0;\n\n\twhile (timeout &&\n\t       ((result = lan743x_dmac_rx_get_state(adapter, rx_channel)) ==\n\t       DMAC_CHANNEL_STATE_STOP_PENDING)) {\n\t\tusleep_range(1000, 20000);\n\t\ttimeout--;\n\t}\n\tif (result == DMAC_CHANNEL_STATE_STOP_PENDING)\n\t\tresult = -ENODEV;\n\treturn result;\n}\n\nstatic void lan743x_tx_release_desc(struct lan743x_tx *tx,\n\t\t\t\t    int descriptor_index, bool cleanup)\n{\n\tstruct lan743x_tx_buffer_info *buffer_info = NULL;\n\tstruct lan743x_tx_descriptor *descriptor = NULL;\n\tu32 descriptor_type = 0;\n\tbool ignore_sync;\n\n\tdescriptor = &tx->ring_cpu_ptr[descriptor_index];\n\tbuffer_info = &tx->buffer_info[descriptor_index];\n\tif (!(buffer_info->flags & TX_BUFFER_INFO_FLAG_ACTIVE))\n\t\tgoto done;\n\n\tdescriptor_type = le32_to_cpu(descriptor->data0) &\n\t\t\t  TX_DESC_DATA0_DTYPE_MASK_;\n\tif (descriptor_type == TX_DESC_DATA0_DTYPE_DATA_)\n\t\tgoto clean_up_data_descriptor;\n\telse\n\t\tgoto clear_active;\n\nclean_up_data_descriptor:\n\tif (buffer_info->dma_ptr) {\n\t\tif (buffer_info->flags &\n\t\t    TX_BUFFER_INFO_FLAG_SKB_FRAGMENT) {\n\t\t\tdma_unmap_page(&tx->adapter->pdev->dev,\n\t\t\t\t       buffer_info->dma_ptr,\n\t\t\t\t       buffer_info->buffer_length,\n\t\t\t\t       DMA_TO_DEVICE);\n\t\t} else {\n\t\t\tdma_unmap_single(&tx->adapter->pdev->dev,\n\t\t\t\t\t buffer_info->dma_ptr,\n\t\t\t\t\t buffer_info->buffer_length,\n\t\t\t\t\t DMA_TO_DEVICE);\n\t\t}\n\t\tbuffer_info->dma_ptr = 0;\n\t\tbuffer_info->buffer_length = 0;\n\t}\n\tif (!buffer_info->skb)\n\t\tgoto clear_active;\n\n\tif (!(buffer_info->flags & TX_BUFFER_INFO_FLAG_TIMESTAMP_REQUESTED)) {\n\t\tdev_kfree_skb_any(buffer_info->skb);\n\t\tgoto clear_skb;\n\t}\n\n\tif (cleanup) {\n\t\tlan743x_ptp_unrequest_tx_timestamp(tx->adapter);\n\t\tdev_kfree_skb_any(buffer_info->skb);\n\t} else {\n\t\tignore_sync = (buffer_info->flags &\n\t\t\t       TX_BUFFER_INFO_FLAG_IGNORE_SYNC) != 0;\n\t\tlan743x_ptp_tx_timestamp_skb(tx->adapter,\n\t\t\t\t\t     buffer_info->skb, ignore_sync);\n\t}\n\nclear_skb:\n\tbuffer_info->skb = NULL;\n\nclear_active:\n\tbuffer_info->flags &= ~TX_BUFFER_INFO_FLAG_ACTIVE;\n\ndone:\n\tmemset(buffer_info, 0, sizeof(*buffer_info));\n\tmemset(descriptor, 0, sizeof(*descriptor));\n}\n\nstatic int lan743x_tx_next_index(struct lan743x_tx *tx, int index)\n{\n\treturn ((++index) % tx->ring_size);\n}\n\nstatic void lan743x_tx_release_completed_descriptors(struct lan743x_tx *tx)\n{\n\twhile (le32_to_cpu(*tx->head_cpu_ptr) != (tx->last_head)) {\n\t\tlan743x_tx_release_desc(tx, tx->last_head, false);\n\t\ttx->last_head = lan743x_tx_next_index(tx, tx->last_head);\n\t}\n}\n\nstatic void lan743x_tx_release_all_descriptors(struct lan743x_tx *tx)\n{\n\tu32 original_head = 0;\n\n\toriginal_head = tx->last_head;\n\tdo {\n\t\tlan743x_tx_release_desc(tx, tx->last_head, true);\n\t\ttx->last_head = lan743x_tx_next_index(tx, tx->last_head);\n\t} while (tx->last_head != original_head);\n\tmemset(tx->ring_cpu_ptr, 0,\n\t       sizeof(*tx->ring_cpu_ptr) * (tx->ring_size));\n\tmemset(tx->buffer_info, 0,\n\t       sizeof(*tx->buffer_info) * (tx->ring_size));\n}\n\nstatic int lan743x_tx_get_desc_cnt(struct lan743x_tx *tx,\n\t\t\t\t   struct sk_buff *skb)\n{\n\tint result = 1;  \n\tint nr_frags = 0;\n\n\tif (skb_is_gso(skb))\n\t\tresult++;  \n\tnr_frags = skb_shinfo(skb)->nr_frags;\n\tresult += nr_frags;  \n\treturn result;\n}\n\nstatic int lan743x_tx_get_avail_desc(struct lan743x_tx *tx)\n{\n\tint last_head = tx->last_head;\n\tint last_tail = tx->last_tail;\n\n\tif (last_tail >= last_head)\n\t\treturn tx->ring_size - last_tail + last_head - 1;\n\telse\n\t\treturn last_head - last_tail - 1;\n}\n\nvoid lan743x_tx_set_timestamping_mode(struct lan743x_tx *tx,\n\t\t\t\t      bool enable_timestamping,\n\t\t\t\t      bool enable_onestep_sync)\n{\n\tif (enable_timestamping)\n\t\ttx->ts_flags |= TX_TS_FLAG_TIMESTAMPING_ENABLED;\n\telse\n\t\ttx->ts_flags &= ~TX_TS_FLAG_TIMESTAMPING_ENABLED;\n\tif (enable_onestep_sync)\n\t\ttx->ts_flags |= TX_TS_FLAG_ONE_STEP_SYNC;\n\telse\n\t\ttx->ts_flags &= ~TX_TS_FLAG_ONE_STEP_SYNC;\n}\n\nstatic int lan743x_tx_frame_start(struct lan743x_tx *tx,\n\t\t\t\t  unsigned char *first_buffer,\n\t\t\t\t  unsigned int first_buffer_length,\n\t\t\t\t  unsigned int frame_length,\n\t\t\t\t  bool time_stamp,\n\t\t\t\t  bool check_sum)\n{\n\t \n\tstruct lan743x_tx_descriptor *tx_descriptor = NULL;\n\tstruct lan743x_tx_buffer_info *buffer_info = NULL;\n\tstruct lan743x_adapter *adapter = tx->adapter;\n\tstruct device *dev = &adapter->pdev->dev;\n\tdma_addr_t dma_ptr;\n\n\ttx->frame_flags |= TX_FRAME_FLAG_IN_PROGRESS;\n\ttx->frame_first = tx->last_tail;\n\ttx->frame_tail = tx->frame_first;\n\n\ttx_descriptor = &tx->ring_cpu_ptr[tx->frame_tail];\n\tbuffer_info = &tx->buffer_info[tx->frame_tail];\n\tdma_ptr = dma_map_single(dev, first_buffer, first_buffer_length,\n\t\t\t\t DMA_TO_DEVICE);\n\tif (dma_mapping_error(dev, dma_ptr))\n\t\treturn -ENOMEM;\n\n\ttx_descriptor->data1 = cpu_to_le32(DMA_ADDR_LOW32(dma_ptr));\n\ttx_descriptor->data2 = cpu_to_le32(DMA_ADDR_HIGH32(dma_ptr));\n\ttx_descriptor->data3 = cpu_to_le32((frame_length << 16) &\n\t\tTX_DESC_DATA3_FRAME_LENGTH_MSS_MASK_);\n\n\tbuffer_info->skb = NULL;\n\tbuffer_info->dma_ptr = dma_ptr;\n\tbuffer_info->buffer_length = first_buffer_length;\n\tbuffer_info->flags |= TX_BUFFER_INFO_FLAG_ACTIVE;\n\n\ttx->frame_data0 = (first_buffer_length &\n\t\tTX_DESC_DATA0_BUF_LENGTH_MASK_) |\n\t\tTX_DESC_DATA0_DTYPE_DATA_ |\n\t\tTX_DESC_DATA0_FS_ |\n\t\tTX_DESC_DATA0_FCS_;\n\tif (time_stamp)\n\t\ttx->frame_data0 |= TX_DESC_DATA0_TSE_;\n\n\tif (check_sum)\n\t\ttx->frame_data0 |= TX_DESC_DATA0_ICE_ |\n\t\t\t\t   TX_DESC_DATA0_IPE_ |\n\t\t\t\t   TX_DESC_DATA0_TPE_;\n\n\t \n\treturn 0;\n}\n\nstatic void lan743x_tx_frame_add_lso(struct lan743x_tx *tx,\n\t\t\t\t     unsigned int frame_length,\n\t\t\t\t     int nr_frags)\n{\n\t \n\tstruct lan743x_tx_descriptor *tx_descriptor = NULL;\n\tstruct lan743x_tx_buffer_info *buffer_info = NULL;\n\n\t \n\ttx->frame_data0 |= TX_DESC_DATA0_EXT_;\n\tif (nr_frags <= 0) {\n\t\ttx->frame_data0 |= TX_DESC_DATA0_LS_;\n\t\ttx->frame_data0 |= TX_DESC_DATA0_IOC_;\n\t}\n\ttx_descriptor = &tx->ring_cpu_ptr[tx->frame_tail];\n\ttx_descriptor->data0 = cpu_to_le32(tx->frame_data0);\n\n\t \n\ttx->frame_tail = lan743x_tx_next_index(tx, tx->frame_tail);\n\ttx_descriptor = &tx->ring_cpu_ptr[tx->frame_tail];\n\tbuffer_info = &tx->buffer_info[tx->frame_tail];\n\n\t \n\ttx_descriptor->data1 = 0;\n\ttx_descriptor->data2 = 0;\n\ttx_descriptor->data3 = 0;\n\n\tbuffer_info->skb = NULL;\n\tbuffer_info->dma_ptr = 0;\n\tbuffer_info->buffer_length = 0;\n\tbuffer_info->flags |= TX_BUFFER_INFO_FLAG_ACTIVE;\n\n\ttx->frame_data0 = (frame_length & TX_DESC_DATA0_EXT_PAY_LENGTH_MASK_) |\n\t\t\t  TX_DESC_DATA0_DTYPE_EXT_ |\n\t\t\t  TX_DESC_DATA0_EXT_LSO_;\n\n\t \n}\n\nstatic int lan743x_tx_frame_add_fragment(struct lan743x_tx *tx,\n\t\t\t\t\t const skb_frag_t *fragment,\n\t\t\t\t\t unsigned int frame_length)\n{\n\t \n\tstruct lan743x_tx_descriptor *tx_descriptor = NULL;\n\tstruct lan743x_tx_buffer_info *buffer_info = NULL;\n\tstruct lan743x_adapter *adapter = tx->adapter;\n\tstruct device *dev = &adapter->pdev->dev;\n\tunsigned int fragment_length = 0;\n\tdma_addr_t dma_ptr;\n\n\tfragment_length = skb_frag_size(fragment);\n\tif (!fragment_length)\n\t\treturn 0;\n\n\t \n\ttx_descriptor = &tx->ring_cpu_ptr[tx->frame_tail];\n\ttx_descriptor->data0 = cpu_to_le32(tx->frame_data0);\n\n\t \n\ttx->frame_tail = lan743x_tx_next_index(tx, tx->frame_tail);\n\ttx_descriptor = &tx->ring_cpu_ptr[tx->frame_tail];\n\tbuffer_info = &tx->buffer_info[tx->frame_tail];\n\tdma_ptr = skb_frag_dma_map(dev, fragment,\n\t\t\t\t   0, fragment_length,\n\t\t\t\t   DMA_TO_DEVICE);\n\tif (dma_mapping_error(dev, dma_ptr)) {\n\t\tint desc_index;\n\n\t\t \n\t\tdesc_index = tx->frame_first;\n\t\twhile (desc_index != tx->frame_tail) {\n\t\t\tlan743x_tx_release_desc(tx, desc_index, true);\n\t\t\tdesc_index = lan743x_tx_next_index(tx, desc_index);\n\t\t}\n\t\tdma_wmb();\n\t\ttx->frame_flags &= ~TX_FRAME_FLAG_IN_PROGRESS;\n\t\ttx->frame_first = 0;\n\t\ttx->frame_data0 = 0;\n\t\ttx->frame_tail = 0;\n\t\treturn -ENOMEM;\n\t}\n\n\ttx_descriptor->data1 = cpu_to_le32(DMA_ADDR_LOW32(dma_ptr));\n\ttx_descriptor->data2 = cpu_to_le32(DMA_ADDR_HIGH32(dma_ptr));\n\ttx_descriptor->data3 = cpu_to_le32((frame_length << 16) &\n\t\t\t       TX_DESC_DATA3_FRAME_LENGTH_MSS_MASK_);\n\n\tbuffer_info->skb = NULL;\n\tbuffer_info->dma_ptr = dma_ptr;\n\tbuffer_info->buffer_length = fragment_length;\n\tbuffer_info->flags |= TX_BUFFER_INFO_FLAG_ACTIVE;\n\tbuffer_info->flags |= TX_BUFFER_INFO_FLAG_SKB_FRAGMENT;\n\n\ttx->frame_data0 = (fragment_length & TX_DESC_DATA0_BUF_LENGTH_MASK_) |\n\t\t\t  TX_DESC_DATA0_DTYPE_DATA_ |\n\t\t\t  TX_DESC_DATA0_FCS_;\n\n\t \n\treturn 0;\n}\n\nstatic void lan743x_tx_frame_end(struct lan743x_tx *tx,\n\t\t\t\t struct sk_buff *skb,\n\t\t\t\t bool time_stamp,\n\t\t\t\t bool ignore_sync)\n{\n\t \n\tstruct lan743x_tx_descriptor *tx_descriptor = NULL;\n\tstruct lan743x_tx_buffer_info *buffer_info = NULL;\n\tstruct lan743x_adapter *adapter = tx->adapter;\n\tu32 tx_tail_flags = 0;\n\n\t \n\tif ((tx->frame_data0 & TX_DESC_DATA0_DTYPE_MASK_) ==\n\t    TX_DESC_DATA0_DTYPE_DATA_) {\n\t\ttx->frame_data0 |= TX_DESC_DATA0_LS_;\n\t\ttx->frame_data0 |= TX_DESC_DATA0_IOC_;\n\t}\n\n\ttx_descriptor = &tx->ring_cpu_ptr[tx->frame_tail];\n\tbuffer_info = &tx->buffer_info[tx->frame_tail];\n\tbuffer_info->skb = skb;\n\tif (time_stamp)\n\t\tbuffer_info->flags |= TX_BUFFER_INFO_FLAG_TIMESTAMP_REQUESTED;\n\tif (ignore_sync)\n\t\tbuffer_info->flags |= TX_BUFFER_INFO_FLAG_IGNORE_SYNC;\n\n\ttx_descriptor->data0 = cpu_to_le32(tx->frame_data0);\n\ttx->frame_tail = lan743x_tx_next_index(tx, tx->frame_tail);\n\ttx->last_tail = tx->frame_tail;\n\n\tdma_wmb();\n\n\tif (tx->vector_flags & LAN743X_VECTOR_FLAG_VECTOR_ENABLE_AUTO_SET)\n\t\ttx_tail_flags |= TX_TAIL_SET_TOP_INT_VEC_EN_;\n\tif (tx->vector_flags & LAN743X_VECTOR_FLAG_SOURCE_ENABLE_AUTO_SET)\n\t\ttx_tail_flags |= TX_TAIL_SET_DMAC_INT_EN_ |\n\t\tTX_TAIL_SET_TOP_INT_EN_;\n\n\tlan743x_csr_write(adapter, TX_TAIL(tx->channel_number),\n\t\t\t  tx_tail_flags | tx->frame_tail);\n\ttx->frame_flags &= ~TX_FRAME_FLAG_IN_PROGRESS;\n}\n\nstatic netdev_tx_t lan743x_tx_xmit_frame(struct lan743x_tx *tx,\n\t\t\t\t\t struct sk_buff *skb)\n{\n\tint required_number_of_descriptors = 0;\n\tunsigned int start_frame_length = 0;\n\tnetdev_tx_t retval = NETDEV_TX_OK;\n\tunsigned int frame_length = 0;\n\tunsigned int head_length = 0;\n\tunsigned long irq_flags = 0;\n\tbool do_timestamp = false;\n\tbool ignore_sync = false;\n\tstruct netdev_queue *txq;\n\tint nr_frags = 0;\n\tbool gso = false;\n\tint j;\n\n\trequired_number_of_descriptors = lan743x_tx_get_desc_cnt(tx, skb);\n\n\tspin_lock_irqsave(&tx->ring_lock, irq_flags);\n\tif (required_number_of_descriptors >\n\t\tlan743x_tx_get_avail_desc(tx)) {\n\t\tif (required_number_of_descriptors > (tx->ring_size - 1)) {\n\t\t\tdev_kfree_skb_irq(skb);\n\t\t} else {\n\t\t\t \n\t\t\ttx->rqd_descriptors = required_number_of_descriptors;\n\t\t\tretval = NETDEV_TX_BUSY;\n\t\t\ttxq = netdev_get_tx_queue(tx->adapter->netdev,\n\t\t\t\t\t\t  tx->channel_number);\n\t\t\tnetif_tx_stop_queue(txq);\n\t\t}\n\t\tgoto unlock;\n\t}\n\n\t \n\tif ((skb_shinfo(skb)->tx_flags & SKBTX_HW_TSTAMP) &&\n\t    (tx->ts_flags & TX_TS_FLAG_TIMESTAMPING_ENABLED) &&\n\t    (lan743x_ptp_request_tx_timestamp(tx->adapter))) {\n\t\tskb_shinfo(skb)->tx_flags |= SKBTX_IN_PROGRESS;\n\t\tdo_timestamp = true;\n\t\tif (tx->ts_flags & TX_TS_FLAG_ONE_STEP_SYNC)\n\t\t\tignore_sync = true;\n\t}\n\thead_length = skb_headlen(skb);\n\tframe_length = skb_pagelen(skb);\n\tnr_frags = skb_shinfo(skb)->nr_frags;\n\tstart_frame_length = frame_length;\n\tgso = skb_is_gso(skb);\n\tif (gso) {\n\t\tstart_frame_length = max(skb_shinfo(skb)->gso_size,\n\t\t\t\t\t (unsigned short)8);\n\t}\n\n\tif (lan743x_tx_frame_start(tx,\n\t\t\t\t   skb->data, head_length,\n\t\t\t\t   start_frame_length,\n\t\t\t\t   do_timestamp,\n\t\t\t\t   skb->ip_summed == CHECKSUM_PARTIAL)) {\n\t\tdev_kfree_skb_irq(skb);\n\t\tgoto unlock;\n\t}\n\ttx->frame_count++;\n\n\tif (gso)\n\t\tlan743x_tx_frame_add_lso(tx, frame_length, nr_frags);\n\n\tif (nr_frags <= 0)\n\t\tgoto finish;\n\n\tfor (j = 0; j < nr_frags; j++) {\n\t\tconst skb_frag_t *frag = &(skb_shinfo(skb)->frags[j]);\n\n\t\tif (lan743x_tx_frame_add_fragment(tx, frag, frame_length)) {\n\t\t\t \n\t\t\tdev_kfree_skb_irq(skb);\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\nfinish:\n\tlan743x_tx_frame_end(tx, skb, do_timestamp, ignore_sync);\n\nunlock:\n\tspin_unlock_irqrestore(&tx->ring_lock, irq_flags);\n\treturn retval;\n}\n\nstatic int lan743x_tx_napi_poll(struct napi_struct *napi, int weight)\n{\n\tstruct lan743x_tx *tx = container_of(napi, struct lan743x_tx, napi);\n\tstruct lan743x_adapter *adapter = tx->adapter;\n\tunsigned long irq_flags = 0;\n\tstruct netdev_queue *txq;\n\tu32 ioc_bit = 0;\n\n\tioc_bit = DMAC_INT_BIT_TX_IOC_(tx->channel_number);\n\tlan743x_csr_read(adapter, DMAC_INT_STS);\n\tif (tx->vector_flags & LAN743X_VECTOR_FLAG_SOURCE_STATUS_W2C)\n\t\tlan743x_csr_write(adapter, DMAC_INT_STS, ioc_bit);\n\tspin_lock_irqsave(&tx->ring_lock, irq_flags);\n\n\t \n\tlan743x_tx_release_completed_descriptors(tx);\n\ttxq = netdev_get_tx_queue(adapter->netdev, tx->channel_number);\n\tif (netif_tx_queue_stopped(txq)) {\n\t\tif (tx->rqd_descriptors) {\n\t\t\tif (tx->rqd_descriptors <=\n\t\t\t    lan743x_tx_get_avail_desc(tx)) {\n\t\t\t\ttx->rqd_descriptors = 0;\n\t\t\t\tnetif_tx_wake_queue(txq);\n\t\t\t}\n\t\t} else {\n\t\t\tnetif_tx_wake_queue(txq);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&tx->ring_lock, irq_flags);\n\n\tif (!napi_complete(napi))\n\t\tgoto done;\n\n\t \n\tlan743x_csr_write(adapter, INT_EN_SET,\n\t\t\t  INT_BIT_DMA_TX_(tx->channel_number));\n\tlan743x_csr_read(adapter, INT_STS);\n\ndone:\n\treturn 0;\n}\n\nstatic void lan743x_tx_ring_cleanup(struct lan743x_tx *tx)\n{\n\tif (tx->head_cpu_ptr) {\n\t\tdma_free_coherent(&tx->adapter->pdev->dev,\n\t\t\t\t  sizeof(*tx->head_cpu_ptr), tx->head_cpu_ptr,\n\t\t\t\t  tx->head_dma_ptr);\n\t\ttx->head_cpu_ptr = NULL;\n\t\ttx->head_dma_ptr = 0;\n\t}\n\tkfree(tx->buffer_info);\n\ttx->buffer_info = NULL;\n\n\tif (tx->ring_cpu_ptr) {\n\t\tdma_free_coherent(&tx->adapter->pdev->dev,\n\t\t\t\t  tx->ring_allocation_size, tx->ring_cpu_ptr,\n\t\t\t\t  tx->ring_dma_ptr);\n\t\ttx->ring_allocation_size = 0;\n\t\ttx->ring_cpu_ptr = NULL;\n\t\ttx->ring_dma_ptr = 0;\n\t}\n\ttx->ring_size = 0;\n}\n\nstatic int lan743x_tx_ring_init(struct lan743x_tx *tx)\n{\n\tsize_t ring_allocation_size = 0;\n\tvoid *cpu_ptr = NULL;\n\tdma_addr_t dma_ptr;\n\tint ret = -ENOMEM;\n\n\ttx->ring_size = LAN743X_TX_RING_SIZE;\n\tif (tx->ring_size & ~TX_CFG_B_TX_RING_LEN_MASK_) {\n\t\tret = -EINVAL;\n\t\tgoto cleanup;\n\t}\n\tif (dma_set_mask_and_coherent(&tx->adapter->pdev->dev,\n\t\t\t\t      DMA_BIT_MASK(64))) {\n\t\tdev_warn(&tx->adapter->pdev->dev,\n\t\t\t \"lan743x_: No suitable DMA available\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto cleanup;\n\t}\n\tring_allocation_size = ALIGN(tx->ring_size *\n\t\t\t\t     sizeof(struct lan743x_tx_descriptor),\n\t\t\t\t     PAGE_SIZE);\n\tdma_ptr = 0;\n\tcpu_ptr = dma_alloc_coherent(&tx->adapter->pdev->dev,\n\t\t\t\t     ring_allocation_size, &dma_ptr, GFP_KERNEL);\n\tif (!cpu_ptr) {\n\t\tret = -ENOMEM;\n\t\tgoto cleanup;\n\t}\n\n\ttx->ring_allocation_size = ring_allocation_size;\n\ttx->ring_cpu_ptr = (struct lan743x_tx_descriptor *)cpu_ptr;\n\ttx->ring_dma_ptr = dma_ptr;\n\n\tcpu_ptr = kcalloc(tx->ring_size, sizeof(*tx->buffer_info), GFP_KERNEL);\n\tif (!cpu_ptr) {\n\t\tret = -ENOMEM;\n\t\tgoto cleanup;\n\t}\n\ttx->buffer_info = (struct lan743x_tx_buffer_info *)cpu_ptr;\n\tdma_ptr = 0;\n\tcpu_ptr = dma_alloc_coherent(&tx->adapter->pdev->dev,\n\t\t\t\t     sizeof(*tx->head_cpu_ptr), &dma_ptr,\n\t\t\t\t     GFP_KERNEL);\n\tif (!cpu_ptr) {\n\t\tret = -ENOMEM;\n\t\tgoto cleanup;\n\t}\n\n\ttx->head_cpu_ptr = cpu_ptr;\n\ttx->head_dma_ptr = dma_ptr;\n\tif (tx->head_dma_ptr & 0x3) {\n\t\tret = -ENOMEM;\n\t\tgoto cleanup;\n\t}\n\n\treturn 0;\n\ncleanup:\n\tlan743x_tx_ring_cleanup(tx);\n\treturn ret;\n}\n\nstatic void lan743x_tx_close(struct lan743x_tx *tx)\n{\n\tstruct lan743x_adapter *adapter = tx->adapter;\n\n\tlan743x_csr_write(adapter,\n\t\t\t  DMAC_CMD,\n\t\t\t  DMAC_CMD_STOP_T_(tx->channel_number));\n\tlan743x_dmac_tx_wait_till_stopped(adapter, tx->channel_number);\n\n\tlan743x_csr_write(adapter,\n\t\t\t  DMAC_INT_EN_CLR,\n\t\t\t  DMAC_INT_BIT_TX_IOC_(tx->channel_number));\n\tlan743x_csr_write(adapter, INT_EN_CLR,\n\t\t\t  INT_BIT_DMA_TX_(tx->channel_number));\n\tnapi_disable(&tx->napi);\n\tnetif_napi_del(&tx->napi);\n\n\tlan743x_csr_write(adapter, FCT_TX_CTL,\n\t\t\t  FCT_TX_CTL_DIS_(tx->channel_number));\n\tlan743x_csr_wait_for_bit(adapter, FCT_TX_CTL,\n\t\t\t\t FCT_TX_CTL_EN_(tx->channel_number),\n\t\t\t\t 0, 1000, 20000, 100);\n\n\tlan743x_tx_release_all_descriptors(tx);\n\n\ttx->rqd_descriptors = 0;\n\n\tlan743x_tx_ring_cleanup(tx);\n}\n\nstatic int lan743x_tx_open(struct lan743x_tx *tx)\n{\n\tstruct lan743x_adapter *adapter = NULL;\n\tu32 data = 0;\n\tint ret;\n\n\tadapter = tx->adapter;\n\tret = lan743x_tx_ring_init(tx);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tlan743x_csr_write(adapter, FCT_TX_CTL,\n\t\t\t  FCT_TX_CTL_RESET_(tx->channel_number));\n\tlan743x_csr_wait_for_bit(adapter, FCT_TX_CTL,\n\t\t\t\t FCT_TX_CTL_RESET_(tx->channel_number),\n\t\t\t\t 0, 1000, 20000, 100);\n\n\t \n\tlan743x_csr_write(adapter, FCT_TX_CTL,\n\t\t\t  FCT_TX_CTL_EN_(tx->channel_number));\n\n\t \n\tlan743x_csr_write(adapter, DMAC_CMD,\n\t\t\t  DMAC_CMD_TX_SWR_(tx->channel_number));\n\tlan743x_csr_wait_for_bit(adapter, DMAC_CMD,\n\t\t\t\t DMAC_CMD_TX_SWR_(tx->channel_number),\n\t\t\t\t 0, 1000, 20000, 100);\n\n\t \n\tlan743x_csr_write(adapter,\n\t\t\t  TX_BASE_ADDRH(tx->channel_number),\n\t\t\t  DMA_ADDR_HIGH32(tx->ring_dma_ptr));\n\tlan743x_csr_write(adapter,\n\t\t\t  TX_BASE_ADDRL(tx->channel_number),\n\t\t\t  DMA_ADDR_LOW32(tx->ring_dma_ptr));\n\n\t \n\tdata = lan743x_csr_read(adapter, TX_CFG_B(tx->channel_number));\n\tdata &= ~TX_CFG_B_TX_RING_LEN_MASK_;\n\tdata |= ((tx->ring_size) & TX_CFG_B_TX_RING_LEN_MASK_);\n\tif (!(adapter->csr.flags & LAN743X_CSR_FLAG_IS_A0))\n\t\tdata |= TX_CFG_B_TDMABL_512_;\n\tlan743x_csr_write(adapter, TX_CFG_B(tx->channel_number), data);\n\n\t \n\tdata = TX_CFG_A_TX_TMR_HPWB_SEL_IOC_ | TX_CFG_A_TX_HP_WB_EN_;\n\tif (!(adapter->csr.flags & LAN743X_CSR_FLAG_IS_A0)) {\n\t\tdata |= TX_CFG_A_TX_HP_WB_ON_INT_TMR_;\n\t\tdata |= TX_CFG_A_TX_PF_THRES_SET_(0x10);\n\t\tdata |= TX_CFG_A_TX_PF_PRI_THRES_SET_(0x04);\n\t\tdata |= TX_CFG_A_TX_HP_WB_THRES_SET_(0x07);\n\t}\n\tlan743x_csr_write(adapter, TX_CFG_A(tx->channel_number), data);\n\n\t \n\tlan743x_csr_write(adapter,\n\t\t\t  TX_HEAD_WRITEBACK_ADDRH(tx->channel_number),\n\t\t\t  DMA_ADDR_HIGH32(tx->head_dma_ptr));\n\tlan743x_csr_write(adapter,\n\t\t\t  TX_HEAD_WRITEBACK_ADDRL(tx->channel_number),\n\t\t\t  DMA_ADDR_LOW32(tx->head_dma_ptr));\n\n\t \n\ttx->last_head = lan743x_csr_read(adapter, TX_HEAD(tx->channel_number));\n\n\t \n\ttx->last_tail = 0;\n\tlan743x_csr_write(adapter, TX_TAIL(tx->channel_number),\n\t\t\t  (u32)(tx->last_tail));\n\ttx->vector_flags = lan743x_intr_get_vector_flags(adapter,\n\t\t\t\t\t\t\t INT_BIT_DMA_TX_\n\t\t\t\t\t\t\t (tx->channel_number));\n\tnetif_napi_add_tx_weight(adapter->netdev,\n\t\t\t\t &tx->napi, lan743x_tx_napi_poll,\n\t\t\t\t NAPI_POLL_WEIGHT);\n\tnapi_enable(&tx->napi);\n\n\tdata = 0;\n\tif (tx->vector_flags & LAN743X_VECTOR_FLAG_SOURCE_ENABLE_AUTO_CLEAR)\n\t\tdata |= TX_CFG_C_TX_TOP_INT_EN_AUTO_CLR_;\n\tif (tx->vector_flags & LAN743X_VECTOR_FLAG_SOURCE_STATUS_AUTO_CLEAR)\n\t\tdata |= TX_CFG_C_TX_DMA_INT_STS_AUTO_CLR_;\n\tif (tx->vector_flags & LAN743X_VECTOR_FLAG_SOURCE_STATUS_R2C)\n\t\tdata |= TX_CFG_C_TX_INT_STS_R2C_MODE_MASK_;\n\tif (tx->vector_flags & LAN743X_VECTOR_FLAG_SOURCE_ENABLE_R2C)\n\t\tdata |= TX_CFG_C_TX_INT_EN_R2C_;\n\tlan743x_csr_write(adapter, TX_CFG_C(tx->channel_number), data);\n\n\tif (!(tx->vector_flags & LAN743X_VECTOR_FLAG_SOURCE_ENABLE_AUTO_SET))\n\t\tlan743x_csr_write(adapter, INT_EN_SET,\n\t\t\t\t  INT_BIT_DMA_TX_(tx->channel_number));\n\tlan743x_csr_write(adapter, DMAC_INT_EN_SET,\n\t\t\t  DMAC_INT_BIT_TX_IOC_(tx->channel_number));\n\n\t \n\tlan743x_csr_write(adapter, DMAC_CMD,\n\t\t\t  DMAC_CMD_START_T_(tx->channel_number));\n\treturn 0;\n}\n\nstatic int lan743x_rx_next_index(struct lan743x_rx *rx, int index)\n{\n\treturn ((++index) % rx->ring_size);\n}\n\nstatic void lan743x_rx_update_tail(struct lan743x_rx *rx, int index)\n{\n\t \n\tif ((index & 7) == 7)\n\t\tlan743x_csr_write(rx->adapter, RX_TAIL(rx->channel_number),\n\t\t\t\t  index);\n}\n\nstatic int lan743x_rx_init_ring_element(struct lan743x_rx *rx, int index,\n\t\t\t\t\tgfp_t gfp)\n{\n\tstruct net_device *netdev = rx->adapter->netdev;\n\tstruct device *dev = &rx->adapter->pdev->dev;\n\tstruct lan743x_rx_buffer_info *buffer_info;\n\tunsigned int buffer_length, used_length;\n\tstruct lan743x_rx_descriptor *descriptor;\n\tstruct sk_buff *skb;\n\tdma_addr_t dma_ptr;\n\n\tbuffer_length = netdev->mtu + ETH_HLEN + ETH_FCS_LEN + RX_HEAD_PADDING;\n\n\tdescriptor = &rx->ring_cpu_ptr[index];\n\tbuffer_info = &rx->buffer_info[index];\n\tskb = __netdev_alloc_skb(netdev, buffer_length, gfp);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\tdma_ptr = dma_map_single(dev, skb->data, buffer_length, DMA_FROM_DEVICE);\n\tif (dma_mapping_error(dev, dma_ptr)) {\n\t\tdev_kfree_skb_any(skb);\n\t\treturn -ENOMEM;\n\t}\n\tif (buffer_info->dma_ptr) {\n\t\t \n\t\tif (le32_to_cpu(descriptor->data0) & RX_DESC_DATA0_LS_)\n\t\t\t \n\t\t\tused_length = min(RX_DESC_DATA0_FRAME_LENGTH_GET_\n\t\t\t\t\t  (le32_to_cpu(descriptor->data0)),\n\t\t\t\t\t  buffer_info->buffer_length);\n\t\telse\n\t\t\tused_length = buffer_info->buffer_length;\n\t\tdma_sync_single_for_cpu(dev, buffer_info->dma_ptr,\n\t\t\t\t\tused_length,\n\t\t\t\t\tDMA_FROM_DEVICE);\n\t\tdma_unmap_single_attrs(dev, buffer_info->dma_ptr,\n\t\t\t\t       buffer_info->buffer_length,\n\t\t\t\t       DMA_FROM_DEVICE,\n\t\t\t\t       DMA_ATTR_SKIP_CPU_SYNC);\n\t}\n\n\tbuffer_info->skb = skb;\n\tbuffer_info->dma_ptr = dma_ptr;\n\tbuffer_info->buffer_length = buffer_length;\n\tdescriptor->data1 = cpu_to_le32(DMA_ADDR_LOW32(buffer_info->dma_ptr));\n\tdescriptor->data2 = cpu_to_le32(DMA_ADDR_HIGH32(buffer_info->dma_ptr));\n\tdescriptor->data3 = 0;\n\tdescriptor->data0 = cpu_to_le32((RX_DESC_DATA0_OWN_ |\n\t\t\t    (buffer_length & RX_DESC_DATA0_BUF_LENGTH_MASK_)));\n\tlan743x_rx_update_tail(rx, index);\n\n\treturn 0;\n}\n\nstatic void lan743x_rx_reuse_ring_element(struct lan743x_rx *rx, int index)\n{\n\tstruct lan743x_rx_buffer_info *buffer_info;\n\tstruct lan743x_rx_descriptor *descriptor;\n\n\tdescriptor = &rx->ring_cpu_ptr[index];\n\tbuffer_info = &rx->buffer_info[index];\n\n\tdescriptor->data1 = cpu_to_le32(DMA_ADDR_LOW32(buffer_info->dma_ptr));\n\tdescriptor->data2 = cpu_to_le32(DMA_ADDR_HIGH32(buffer_info->dma_ptr));\n\tdescriptor->data3 = 0;\n\tdescriptor->data0 = cpu_to_le32((RX_DESC_DATA0_OWN_ |\n\t\t\t    ((buffer_info->buffer_length) &\n\t\t\t    RX_DESC_DATA0_BUF_LENGTH_MASK_)));\n\tlan743x_rx_update_tail(rx, index);\n}\n\nstatic void lan743x_rx_release_ring_element(struct lan743x_rx *rx, int index)\n{\n\tstruct lan743x_rx_buffer_info *buffer_info;\n\tstruct lan743x_rx_descriptor *descriptor;\n\n\tdescriptor = &rx->ring_cpu_ptr[index];\n\tbuffer_info = &rx->buffer_info[index];\n\n\tmemset(descriptor, 0, sizeof(*descriptor));\n\n\tif (buffer_info->dma_ptr) {\n\t\tdma_unmap_single(&rx->adapter->pdev->dev,\n\t\t\t\t buffer_info->dma_ptr,\n\t\t\t\t buffer_info->buffer_length,\n\t\t\t\t DMA_FROM_DEVICE);\n\t\tbuffer_info->dma_ptr = 0;\n\t}\n\n\tif (buffer_info->skb) {\n\t\tdev_kfree_skb(buffer_info->skb);\n\t\tbuffer_info->skb = NULL;\n\t}\n\n\tmemset(buffer_info, 0, sizeof(*buffer_info));\n}\n\nstatic struct sk_buff *\nlan743x_rx_trim_skb(struct sk_buff *skb, int frame_length)\n{\n\tif (skb_linearize(skb)) {\n\t\tdev_kfree_skb_irq(skb);\n\t\treturn NULL;\n\t}\n\tframe_length = max_t(int, 0, frame_length - ETH_FCS_LEN);\n\tif (skb->len > frame_length) {\n\t\tskb->tail -= skb->len - frame_length;\n\t\tskb->len = frame_length;\n\t}\n\treturn skb;\n}\n\nstatic int lan743x_rx_process_buffer(struct lan743x_rx *rx)\n{\n\tint current_head_index = le32_to_cpu(*rx->head_cpu_ptr);\n\tstruct lan743x_rx_descriptor *descriptor, *desc_ext;\n\tstruct net_device *netdev = rx->adapter->netdev;\n\tint result = RX_PROCESS_RESULT_NOTHING_TO_DO;\n\tstruct lan743x_rx_buffer_info *buffer_info;\n\tint frame_length, buffer_length;\n\tbool is_ice, is_tce, is_icsm;\n\tint extension_index = -1;\n\tbool is_last, is_first;\n\tstruct sk_buff *skb;\n\n\tif (current_head_index < 0 || current_head_index >= rx->ring_size)\n\t\tgoto done;\n\n\tif (rx->last_head < 0 || rx->last_head >= rx->ring_size)\n\t\tgoto done;\n\n\tif (rx->last_head == current_head_index)\n\t\tgoto done;\n\n\tdescriptor = &rx->ring_cpu_ptr[rx->last_head];\n\tif (le32_to_cpu(descriptor->data0) & RX_DESC_DATA0_OWN_)\n\t\tgoto done;\n\tbuffer_info = &rx->buffer_info[rx->last_head];\n\n\tis_last = le32_to_cpu(descriptor->data0) & RX_DESC_DATA0_LS_;\n\tis_first = le32_to_cpu(descriptor->data0) & RX_DESC_DATA0_FS_;\n\n\tif (is_last && le32_to_cpu(descriptor->data0) & RX_DESC_DATA0_EXT_) {\n\t\t \n\t\tint index = lan743x_rx_next_index(rx, rx->last_head);\n\n\t\tif (index == current_head_index)\n\t\t\t \n\t\t\tgoto done;\n\t\tdesc_ext = &rx->ring_cpu_ptr[index];\n\t\tif (le32_to_cpu(desc_ext->data0) & RX_DESC_DATA0_OWN_)\n\t\t\t \n\t\t\tgoto done;\n\t\tif (!(le32_to_cpu(desc_ext->data0) & RX_DESC_DATA0_EXT_))\n\t\t\tgoto move_forward;\n\t\textension_index = index;\n\t}\n\n\t \n\tframe_length =\n\t\tRX_DESC_DATA0_FRAME_LENGTH_GET_(le32_to_cpu(descriptor->data0));\n\tbuffer_length = buffer_info->buffer_length;\n\tis_ice = le32_to_cpu(descriptor->data1) & RX_DESC_DATA1_STATUS_ICE_;\n\tis_tce = le32_to_cpu(descriptor->data1) & RX_DESC_DATA1_STATUS_TCE_;\n\tis_icsm = le32_to_cpu(descriptor->data1) & RX_DESC_DATA1_STATUS_ICSM_;\n\n\tnetdev_dbg(netdev, \"%s%schunk: %d/%d\",\n\t\t   is_first ? \"first \" : \"      \",\n\t\t   is_last  ? \"last  \" : \"      \",\n\t\t   frame_length, buffer_length);\n\n\t \n\tskb = buffer_info->skb;\n\tif (lan743x_rx_init_ring_element(rx, rx->last_head,\n\t\t\t\t\t GFP_ATOMIC | GFP_DMA)) {\n\t\t \n\t\tlan743x_rx_reuse_ring_element(rx, rx->last_head);\n\t\t \n\t\tdev_kfree_skb_irq(rx->skb_head);\n\t\trx->skb_head = NULL;\n\t\tgoto process_extension;\n\t}\n\n\t \n\tif (is_first) {\n\t\tskb_reserve(skb, RX_HEAD_PADDING);\n\t\tskb_put(skb, buffer_length - RX_HEAD_PADDING);\n\t\tif (rx->skb_head)\n\t\t\tdev_kfree_skb_irq(rx->skb_head);\n\t\trx->skb_head = skb;\n\t} else if (rx->skb_head) {\n\t\tskb_put(skb, buffer_length);\n\t\tif (skb_shinfo(rx->skb_head)->frag_list)\n\t\t\trx->skb_tail->next = skb;\n\t\telse\n\t\t\tskb_shinfo(rx->skb_head)->frag_list = skb;\n\t\trx->skb_tail = skb;\n\t\trx->skb_head->len += skb->len;\n\t\trx->skb_head->data_len += skb->len;\n\t\trx->skb_head->truesize += skb->truesize;\n\t} else {\n\t\t \n\t\tnetdev_dbg(netdev, \"drop buffer intended for dropped packet\");\n\t\tdev_kfree_skb_irq(skb);\n\t}\n\nprocess_extension:\n\tif (extension_index >= 0) {\n\t\tu32 ts_sec;\n\t\tu32 ts_nsec;\n\n\t\tts_sec = le32_to_cpu(desc_ext->data1);\n\t\tts_nsec = (le32_to_cpu(desc_ext->data2) &\n\t\t\t  RX_DESC_DATA2_TS_NS_MASK_);\n\t\tif (rx->skb_head)\n\t\t\tskb_hwtstamps(rx->skb_head)->hwtstamp =\n\t\t\t\tktime_set(ts_sec, ts_nsec);\n\t\tlan743x_rx_reuse_ring_element(rx, extension_index);\n\t\trx->last_head = extension_index;\n\t\tnetdev_dbg(netdev, \"process extension\");\n\t}\n\n\tif (is_last && rx->skb_head)\n\t\trx->skb_head = lan743x_rx_trim_skb(rx->skb_head, frame_length);\n\n\tif (is_last && rx->skb_head) {\n\t\trx->skb_head->protocol = eth_type_trans(rx->skb_head,\n\t\t\t\t\t\t\trx->adapter->netdev);\n\t\tif (rx->adapter->netdev->features & NETIF_F_RXCSUM) {\n\t\t\tif (!is_ice && !is_tce && !is_icsm)\n\t\t\t\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\t\t}\n\t\tnetdev_dbg(netdev, \"sending %d byte frame to OS\",\n\t\t\t   rx->skb_head->len);\n\t\tnapi_gro_receive(&rx->napi, rx->skb_head);\n\t\trx->skb_head = NULL;\n\t}\n\nmove_forward:\n\t \n\trx->last_tail = rx->last_head;\n\trx->last_head = lan743x_rx_next_index(rx, rx->last_head);\n\tresult = RX_PROCESS_RESULT_BUFFER_RECEIVED;\ndone:\n\treturn result;\n}\n\nstatic int lan743x_rx_napi_poll(struct napi_struct *napi, int weight)\n{\n\tstruct lan743x_rx *rx = container_of(napi, struct lan743x_rx, napi);\n\tstruct lan743x_adapter *adapter = rx->adapter;\n\tint result = RX_PROCESS_RESULT_NOTHING_TO_DO;\n\tu32 rx_tail_flags = 0;\n\tint count;\n\n\tif (rx->vector_flags & LAN743X_VECTOR_FLAG_SOURCE_STATUS_W2C) {\n\t\t \n\t\tlan743x_csr_write(adapter, DMAC_INT_STS,\n\t\t\t\t  DMAC_INT_BIT_RXFRM_(rx->channel_number));\n\t}\n\tfor (count = 0; count < weight; count++) {\n\t\tresult = lan743x_rx_process_buffer(rx);\n\t\tif (result == RX_PROCESS_RESULT_NOTHING_TO_DO)\n\t\t\tbreak;\n\t}\n\trx->frame_count += count;\n\tif (count == weight || result == RX_PROCESS_RESULT_BUFFER_RECEIVED)\n\t\treturn weight;\n\n\tif (!napi_complete_done(napi, count))\n\t\treturn count;\n\n\t \n\tif (rx->vector_flags & LAN743X_VECTOR_FLAG_VECTOR_ENABLE_AUTO_SET)\n\t\trx_tail_flags |= RX_TAIL_SET_TOP_INT_VEC_EN_;\n\tif (rx->vector_flags & LAN743X_VECTOR_FLAG_SOURCE_ENABLE_AUTO_SET) {\n\t\trx_tail_flags |= RX_TAIL_SET_TOP_INT_EN_;\n\t} else {\n\t\tlan743x_csr_write(adapter, INT_EN_SET,\n\t\t\t\t  INT_BIT_DMA_RX_(rx->channel_number));\n\t}\n\n\tif (rx_tail_flags)\n\t\tlan743x_csr_write(adapter, RX_TAIL(rx->channel_number),\n\t\t\t\t  rx_tail_flags | rx->last_tail);\n\n\treturn count;\n}\n\nstatic void lan743x_rx_ring_cleanup(struct lan743x_rx *rx)\n{\n\tif (rx->buffer_info && rx->ring_cpu_ptr) {\n\t\tint index;\n\n\t\tfor (index = 0; index < rx->ring_size; index++)\n\t\t\tlan743x_rx_release_ring_element(rx, index);\n\t}\n\n\tif (rx->head_cpu_ptr) {\n\t\tdma_free_coherent(&rx->adapter->pdev->dev,\n\t\t\t\t  sizeof(*rx->head_cpu_ptr), rx->head_cpu_ptr,\n\t\t\t\t  rx->head_dma_ptr);\n\t\trx->head_cpu_ptr = NULL;\n\t\trx->head_dma_ptr = 0;\n\t}\n\n\tkfree(rx->buffer_info);\n\trx->buffer_info = NULL;\n\n\tif (rx->ring_cpu_ptr) {\n\t\tdma_free_coherent(&rx->adapter->pdev->dev,\n\t\t\t\t  rx->ring_allocation_size, rx->ring_cpu_ptr,\n\t\t\t\t  rx->ring_dma_ptr);\n\t\trx->ring_allocation_size = 0;\n\t\trx->ring_cpu_ptr = NULL;\n\t\trx->ring_dma_ptr = 0;\n\t}\n\n\trx->ring_size = 0;\n\trx->last_head = 0;\n}\n\nstatic int lan743x_rx_ring_init(struct lan743x_rx *rx)\n{\n\tsize_t ring_allocation_size = 0;\n\tdma_addr_t dma_ptr = 0;\n\tvoid *cpu_ptr = NULL;\n\tint ret = -ENOMEM;\n\tint index = 0;\n\n\trx->ring_size = LAN743X_RX_RING_SIZE;\n\tif (rx->ring_size <= 1) {\n\t\tret = -EINVAL;\n\t\tgoto cleanup;\n\t}\n\tif (rx->ring_size & ~RX_CFG_B_RX_RING_LEN_MASK_) {\n\t\tret = -EINVAL;\n\t\tgoto cleanup;\n\t}\n\tif (dma_set_mask_and_coherent(&rx->adapter->pdev->dev,\n\t\t\t\t      DMA_BIT_MASK(64))) {\n\t\tdev_warn(&rx->adapter->pdev->dev,\n\t\t\t \"lan743x_: No suitable DMA available\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto cleanup;\n\t}\n\tring_allocation_size = ALIGN(rx->ring_size *\n\t\t\t\t     sizeof(struct lan743x_rx_descriptor),\n\t\t\t\t     PAGE_SIZE);\n\tdma_ptr = 0;\n\tcpu_ptr = dma_alloc_coherent(&rx->adapter->pdev->dev,\n\t\t\t\t     ring_allocation_size, &dma_ptr, GFP_KERNEL);\n\tif (!cpu_ptr) {\n\t\tret = -ENOMEM;\n\t\tgoto cleanup;\n\t}\n\trx->ring_allocation_size = ring_allocation_size;\n\trx->ring_cpu_ptr = (struct lan743x_rx_descriptor *)cpu_ptr;\n\trx->ring_dma_ptr = dma_ptr;\n\n\tcpu_ptr = kcalloc(rx->ring_size, sizeof(*rx->buffer_info),\n\t\t\t  GFP_KERNEL);\n\tif (!cpu_ptr) {\n\t\tret = -ENOMEM;\n\t\tgoto cleanup;\n\t}\n\trx->buffer_info = (struct lan743x_rx_buffer_info *)cpu_ptr;\n\tdma_ptr = 0;\n\tcpu_ptr = dma_alloc_coherent(&rx->adapter->pdev->dev,\n\t\t\t\t     sizeof(*rx->head_cpu_ptr), &dma_ptr,\n\t\t\t\t     GFP_KERNEL);\n\tif (!cpu_ptr) {\n\t\tret = -ENOMEM;\n\t\tgoto cleanup;\n\t}\n\n\trx->head_cpu_ptr = cpu_ptr;\n\trx->head_dma_ptr = dma_ptr;\n\tif (rx->head_dma_ptr & 0x3) {\n\t\tret = -ENOMEM;\n\t\tgoto cleanup;\n\t}\n\n\trx->last_head = 0;\n\tfor (index = 0; index < rx->ring_size; index++) {\n\t\tret = lan743x_rx_init_ring_element(rx, index, GFP_KERNEL);\n\t\tif (ret)\n\t\t\tgoto cleanup;\n\t}\n\treturn 0;\n\ncleanup:\n\tnetif_warn(rx->adapter, ifup, rx->adapter->netdev,\n\t\t   \"Error allocating memory for LAN743x\\n\");\n\n\tlan743x_rx_ring_cleanup(rx);\n\treturn ret;\n}\n\nstatic void lan743x_rx_close(struct lan743x_rx *rx)\n{\n\tstruct lan743x_adapter *adapter = rx->adapter;\n\n\tlan743x_csr_write(adapter, FCT_RX_CTL,\n\t\t\t  FCT_RX_CTL_DIS_(rx->channel_number));\n\tlan743x_csr_wait_for_bit(adapter, FCT_RX_CTL,\n\t\t\t\t FCT_RX_CTL_EN_(rx->channel_number),\n\t\t\t\t 0, 1000, 20000, 100);\n\n\tlan743x_csr_write(adapter, DMAC_CMD,\n\t\t\t  DMAC_CMD_STOP_R_(rx->channel_number));\n\tlan743x_dmac_rx_wait_till_stopped(adapter, rx->channel_number);\n\n\tlan743x_csr_write(adapter, DMAC_INT_EN_CLR,\n\t\t\t  DMAC_INT_BIT_RXFRM_(rx->channel_number));\n\tlan743x_csr_write(adapter, INT_EN_CLR,\n\t\t\t  INT_BIT_DMA_RX_(rx->channel_number));\n\tnapi_disable(&rx->napi);\n\n\tnetif_napi_del(&rx->napi);\n\n\tlan743x_rx_ring_cleanup(rx);\n}\n\nstatic int lan743x_rx_open(struct lan743x_rx *rx)\n{\n\tstruct lan743x_adapter *adapter = rx->adapter;\n\tu32 data = 0;\n\tint ret;\n\n\trx->frame_count = 0;\n\tret = lan743x_rx_ring_init(rx);\n\tif (ret)\n\t\tgoto return_error;\n\n\tnetif_napi_add(adapter->netdev, &rx->napi, lan743x_rx_napi_poll);\n\n\tlan743x_csr_write(adapter, DMAC_CMD,\n\t\t\t  DMAC_CMD_RX_SWR_(rx->channel_number));\n\tlan743x_csr_wait_for_bit(adapter, DMAC_CMD,\n\t\t\t\t DMAC_CMD_RX_SWR_(rx->channel_number),\n\t\t\t\t 0, 1000, 20000, 100);\n\n\t \n\tlan743x_csr_write(adapter,\n\t\t\t  RX_BASE_ADDRH(rx->channel_number),\n\t\t\t  DMA_ADDR_HIGH32(rx->ring_dma_ptr));\n\tlan743x_csr_write(adapter,\n\t\t\t  RX_BASE_ADDRL(rx->channel_number),\n\t\t\t  DMA_ADDR_LOW32(rx->ring_dma_ptr));\n\n\t \n\tlan743x_csr_write(adapter,\n\t\t\t  RX_HEAD_WRITEBACK_ADDRH(rx->channel_number),\n\t\t\t  DMA_ADDR_HIGH32(rx->head_dma_ptr));\n\tlan743x_csr_write(adapter,\n\t\t\t  RX_HEAD_WRITEBACK_ADDRL(rx->channel_number),\n\t\t\t  DMA_ADDR_LOW32(rx->head_dma_ptr));\n\tdata = RX_CFG_A_RX_HP_WB_EN_;\n\tif (!(adapter->csr.flags & LAN743X_CSR_FLAG_IS_A0)) {\n\t\tdata |= (RX_CFG_A_RX_WB_ON_INT_TMR_ |\n\t\t\tRX_CFG_A_RX_WB_THRES_SET_(0x7) |\n\t\t\tRX_CFG_A_RX_PF_THRES_SET_(16) |\n\t\t\tRX_CFG_A_RX_PF_PRI_THRES_SET_(4));\n\t}\n\n\t \n\tlan743x_csr_write(adapter,\n\t\t\t  RX_CFG_A(rx->channel_number), data);\n\n\t \n\tdata = lan743x_csr_read(adapter, RX_CFG_B(rx->channel_number));\n\tdata &= ~RX_CFG_B_RX_PAD_MASK_;\n\tif (!RX_HEAD_PADDING)\n\t\tdata |= RX_CFG_B_RX_PAD_0_;\n\telse\n\t\tdata |= RX_CFG_B_RX_PAD_2_;\n\tdata &= ~RX_CFG_B_RX_RING_LEN_MASK_;\n\tdata |= ((rx->ring_size) & RX_CFG_B_RX_RING_LEN_MASK_);\n\tdata |= RX_CFG_B_TS_ALL_RX_;\n\tif (!(adapter->csr.flags & LAN743X_CSR_FLAG_IS_A0))\n\t\tdata |= RX_CFG_B_RDMABL_512_;\n\n\tlan743x_csr_write(adapter, RX_CFG_B(rx->channel_number), data);\n\trx->vector_flags = lan743x_intr_get_vector_flags(adapter,\n\t\t\t\t\t\t\t INT_BIT_DMA_RX_\n\t\t\t\t\t\t\t (rx->channel_number));\n\n\t \n\tdata = 0;\n\tif (rx->vector_flags & LAN743X_VECTOR_FLAG_SOURCE_ENABLE_AUTO_CLEAR)\n\t\tdata |= RX_CFG_C_RX_TOP_INT_EN_AUTO_CLR_;\n\tif (rx->vector_flags & LAN743X_VECTOR_FLAG_SOURCE_STATUS_AUTO_CLEAR)\n\t\tdata |= RX_CFG_C_RX_DMA_INT_STS_AUTO_CLR_;\n\tif (rx->vector_flags & LAN743X_VECTOR_FLAG_SOURCE_STATUS_R2C)\n\t\tdata |= RX_CFG_C_RX_INT_STS_R2C_MODE_MASK_;\n\tif (rx->vector_flags & LAN743X_VECTOR_FLAG_SOURCE_ENABLE_R2C)\n\t\tdata |= RX_CFG_C_RX_INT_EN_R2C_;\n\tlan743x_csr_write(adapter, RX_CFG_C(rx->channel_number), data);\n\n\trx->last_tail = ((u32)(rx->ring_size - 1));\n\tlan743x_csr_write(adapter, RX_TAIL(rx->channel_number),\n\t\t\t  rx->last_tail);\n\trx->last_head = lan743x_csr_read(adapter, RX_HEAD(rx->channel_number));\n\tif (rx->last_head) {\n\t\tret = -EIO;\n\t\tgoto napi_delete;\n\t}\n\n\tnapi_enable(&rx->napi);\n\n\tlan743x_csr_write(adapter, INT_EN_SET,\n\t\t\t  INT_BIT_DMA_RX_(rx->channel_number));\n\tlan743x_csr_write(adapter, DMAC_INT_STS,\n\t\t\t  DMAC_INT_BIT_RXFRM_(rx->channel_number));\n\tlan743x_csr_write(adapter, DMAC_INT_EN_SET,\n\t\t\t  DMAC_INT_BIT_RXFRM_(rx->channel_number));\n\tlan743x_csr_write(adapter, DMAC_CMD,\n\t\t\t  DMAC_CMD_START_R_(rx->channel_number));\n\n\t \n\tlan743x_csr_write(adapter, FCT_RX_CTL,\n\t\t\t  FCT_RX_CTL_RESET_(rx->channel_number));\n\tlan743x_csr_wait_for_bit(adapter, FCT_RX_CTL,\n\t\t\t\t FCT_RX_CTL_RESET_(rx->channel_number),\n\t\t\t\t 0, 1000, 20000, 100);\n\tlan743x_csr_write(adapter, FCT_FLOW(rx->channel_number),\n\t\t\t  FCT_FLOW_CTL_REQ_EN_ |\n\t\t\t  FCT_FLOW_CTL_ON_THRESHOLD_SET_(0x2A) |\n\t\t\t  FCT_FLOW_CTL_OFF_THRESHOLD_SET_(0xA));\n\n\t \n\tlan743x_csr_write(adapter, FCT_RX_CTL,\n\t\t\t  FCT_RX_CTL_EN_(rx->channel_number));\n\treturn 0;\n\nnapi_delete:\n\tnetif_napi_del(&rx->napi);\n\tlan743x_rx_ring_cleanup(rx);\n\nreturn_error:\n\treturn ret;\n}\n\nstatic int lan743x_netdev_close(struct net_device *netdev)\n{\n\tstruct lan743x_adapter *adapter = netdev_priv(netdev);\n\tint index;\n\n\tfor (index = 0; index < adapter->used_tx_channels; index++)\n\t\tlan743x_tx_close(&adapter->tx[index]);\n\n\tfor (index = 0; index < LAN743X_USED_RX_CHANNELS; index++)\n\t\tlan743x_rx_close(&adapter->rx[index]);\n\n\tlan743x_ptp_close(adapter);\n\n\tlan743x_phy_close(adapter);\n\n\tlan743x_mac_close(adapter);\n\n\tlan743x_intr_close(adapter);\n\n\treturn 0;\n}\n\nstatic int lan743x_netdev_open(struct net_device *netdev)\n{\n\tstruct lan743x_adapter *adapter = netdev_priv(netdev);\n\tint index;\n\tint ret;\n\n\tret = lan743x_intr_open(adapter);\n\tif (ret)\n\t\tgoto return_error;\n\n\tret = lan743x_mac_open(adapter);\n\tif (ret)\n\t\tgoto close_intr;\n\n\tret = lan743x_phy_open(adapter);\n\tif (ret)\n\t\tgoto close_mac;\n\n\tret = lan743x_ptp_open(adapter);\n\tif (ret)\n\t\tgoto close_phy;\n\n\tlan743x_rfe_open(adapter);\n\n\tfor (index = 0; index < LAN743X_USED_RX_CHANNELS; index++) {\n\t\tret = lan743x_rx_open(&adapter->rx[index]);\n\t\tif (ret)\n\t\t\tgoto close_rx;\n\t}\n\n\tfor (index = 0; index < adapter->used_tx_channels; index++) {\n\t\tret = lan743x_tx_open(&adapter->tx[index]);\n\t\tif (ret)\n\t\t\tgoto close_tx;\n\t}\n\treturn 0;\n\nclose_tx:\n\tfor (index = 0; index < adapter->used_tx_channels; index++) {\n\t\tif (adapter->tx[index].ring_cpu_ptr)\n\t\t\tlan743x_tx_close(&adapter->tx[index]);\n\t}\n\nclose_rx:\n\tfor (index = 0; index < LAN743X_USED_RX_CHANNELS; index++) {\n\t\tif (adapter->rx[index].ring_cpu_ptr)\n\t\t\tlan743x_rx_close(&adapter->rx[index]);\n\t}\n\tlan743x_ptp_close(adapter);\n\nclose_phy:\n\tlan743x_phy_close(adapter);\n\nclose_mac:\n\tlan743x_mac_close(adapter);\n\nclose_intr:\n\tlan743x_intr_close(adapter);\n\nreturn_error:\n\tnetif_warn(adapter, ifup, adapter->netdev,\n\t\t   \"Error opening LAN743x\\n\");\n\treturn ret;\n}\n\nstatic netdev_tx_t lan743x_netdev_xmit_frame(struct sk_buff *skb,\n\t\t\t\t\t     struct net_device *netdev)\n{\n\tstruct lan743x_adapter *adapter = netdev_priv(netdev);\n\tu8 ch = 0;\n\n\tif (adapter->is_pci11x1x)\n\t\tch = skb->queue_mapping % PCI11X1X_USED_TX_CHANNELS;\n\n\treturn lan743x_tx_xmit_frame(&adapter->tx[ch], skb);\n}\n\nstatic int lan743x_netdev_ioctl(struct net_device *netdev,\n\t\t\t\tstruct ifreq *ifr, int cmd)\n{\n\tif (!netif_running(netdev))\n\t\treturn -EINVAL;\n\tif (cmd == SIOCSHWTSTAMP)\n\t\treturn lan743x_ptp_ioctl(netdev, ifr, cmd);\n\treturn phy_mii_ioctl(netdev->phydev, ifr, cmd);\n}\n\nstatic void lan743x_netdev_set_multicast(struct net_device *netdev)\n{\n\tstruct lan743x_adapter *adapter = netdev_priv(netdev);\n\n\tlan743x_rfe_set_multicast(adapter);\n}\n\nstatic int lan743x_netdev_change_mtu(struct net_device *netdev, int new_mtu)\n{\n\tstruct lan743x_adapter *adapter = netdev_priv(netdev);\n\tint ret = 0;\n\n\tret = lan743x_mac_set_mtu(adapter, new_mtu);\n\tif (!ret)\n\t\tnetdev->mtu = new_mtu;\n\treturn ret;\n}\n\nstatic void lan743x_netdev_get_stats64(struct net_device *netdev,\n\t\t\t\t       struct rtnl_link_stats64 *stats)\n{\n\tstruct lan743x_adapter *adapter = netdev_priv(netdev);\n\n\tstats->rx_packets = lan743x_csr_read(adapter, STAT_RX_TOTAL_FRAMES);\n\tstats->tx_packets = lan743x_csr_read(adapter, STAT_TX_TOTAL_FRAMES);\n\tstats->rx_bytes = lan743x_csr_read(adapter,\n\t\t\t\t\t   STAT_RX_UNICAST_BYTE_COUNT) +\n\t\t\t  lan743x_csr_read(adapter,\n\t\t\t\t\t   STAT_RX_BROADCAST_BYTE_COUNT) +\n\t\t\t  lan743x_csr_read(adapter,\n\t\t\t\t\t   STAT_RX_MULTICAST_BYTE_COUNT);\n\tstats->tx_bytes = lan743x_csr_read(adapter,\n\t\t\t\t\t   STAT_TX_UNICAST_BYTE_COUNT) +\n\t\t\t  lan743x_csr_read(adapter,\n\t\t\t\t\t   STAT_TX_BROADCAST_BYTE_COUNT) +\n\t\t\t  lan743x_csr_read(adapter,\n\t\t\t\t\t   STAT_TX_MULTICAST_BYTE_COUNT);\n\tstats->rx_errors = lan743x_csr_read(adapter, STAT_RX_FCS_ERRORS) +\n\t\t\t   lan743x_csr_read(adapter,\n\t\t\t\t\t    STAT_RX_ALIGNMENT_ERRORS) +\n\t\t\t   lan743x_csr_read(adapter, STAT_RX_JABBER_ERRORS) +\n\t\t\t   lan743x_csr_read(adapter,\n\t\t\t\t\t    STAT_RX_UNDERSIZE_FRAME_ERRORS) +\n\t\t\t   lan743x_csr_read(adapter,\n\t\t\t\t\t    STAT_RX_OVERSIZE_FRAME_ERRORS);\n\tstats->tx_errors = lan743x_csr_read(adapter, STAT_TX_FCS_ERRORS) +\n\t\t\t   lan743x_csr_read(adapter,\n\t\t\t\t\t    STAT_TX_EXCESS_DEFERRAL_ERRORS) +\n\t\t\t   lan743x_csr_read(adapter, STAT_TX_CARRIER_ERRORS);\n\tstats->rx_dropped = lan743x_csr_read(adapter,\n\t\t\t\t\t     STAT_RX_DROPPED_FRAMES);\n\tstats->tx_dropped = lan743x_csr_read(adapter,\n\t\t\t\t\t     STAT_TX_EXCESSIVE_COLLISION);\n\tstats->multicast = lan743x_csr_read(adapter,\n\t\t\t\t\t    STAT_RX_MULTICAST_FRAMES) +\n\t\t\t   lan743x_csr_read(adapter,\n\t\t\t\t\t    STAT_TX_MULTICAST_FRAMES);\n\tstats->collisions = lan743x_csr_read(adapter,\n\t\t\t\t\t     STAT_TX_SINGLE_COLLISIONS) +\n\t\t\t    lan743x_csr_read(adapter,\n\t\t\t\t\t     STAT_TX_MULTIPLE_COLLISIONS) +\n\t\t\t    lan743x_csr_read(adapter,\n\t\t\t\t\t     STAT_TX_LATE_COLLISIONS);\n}\n\nstatic int lan743x_netdev_set_mac_address(struct net_device *netdev,\n\t\t\t\t\t  void *addr)\n{\n\tstruct lan743x_adapter *adapter = netdev_priv(netdev);\n\tstruct sockaddr *sock_addr = addr;\n\tint ret;\n\n\tret = eth_prepare_mac_addr_change(netdev, sock_addr);\n\tif (ret)\n\t\treturn ret;\n\teth_hw_addr_set(netdev, sock_addr->sa_data);\n\tlan743x_mac_set_address(adapter, sock_addr->sa_data);\n\tlan743x_rfe_update_mac_address(adapter);\n\treturn 0;\n}\n\nstatic const struct net_device_ops lan743x_netdev_ops = {\n\t.ndo_open\t\t= lan743x_netdev_open,\n\t.ndo_stop\t\t= lan743x_netdev_close,\n\t.ndo_start_xmit\t\t= lan743x_netdev_xmit_frame,\n\t.ndo_eth_ioctl\t\t= lan743x_netdev_ioctl,\n\t.ndo_set_rx_mode\t= lan743x_netdev_set_multicast,\n\t.ndo_change_mtu\t\t= lan743x_netdev_change_mtu,\n\t.ndo_get_stats64\t= lan743x_netdev_get_stats64,\n\t.ndo_set_mac_address\t= lan743x_netdev_set_mac_address,\n};\n\nstatic void lan743x_hardware_cleanup(struct lan743x_adapter *adapter)\n{\n\tlan743x_csr_write(adapter, INT_EN_CLR, 0xFFFFFFFF);\n}\n\nstatic void lan743x_mdiobus_cleanup(struct lan743x_adapter *adapter)\n{\n\tmdiobus_unregister(adapter->mdiobus);\n}\n\nstatic void lan743x_full_cleanup(struct lan743x_adapter *adapter)\n{\n\tunregister_netdev(adapter->netdev);\n\n\tlan743x_mdiobus_cleanup(adapter);\n\tlan743x_hardware_cleanup(adapter);\n\tlan743x_pci_cleanup(adapter);\n}\n\nstatic int lan743x_hardware_init(struct lan743x_adapter *adapter,\n\t\t\t\t struct pci_dev *pdev)\n{\n\tstruct lan743x_tx *tx;\n\tint index;\n\tint ret;\n\n\tadapter->is_pci11x1x = is_pci11x1x_chip(adapter);\n\tif (adapter->is_pci11x1x) {\n\t\tadapter->max_tx_channels = PCI11X1X_MAX_TX_CHANNELS;\n\t\tadapter->used_tx_channels = PCI11X1X_USED_TX_CHANNELS;\n\t\tadapter->max_vector_count = PCI11X1X_MAX_VECTOR_COUNT;\n\t\tpci11x1x_strap_get_status(adapter);\n\t\tspin_lock_init(&adapter->eth_syslock_spinlock);\n\t\tmutex_init(&adapter->sgmii_rw_lock);\n\t} else {\n\t\tadapter->max_tx_channels = LAN743X_MAX_TX_CHANNELS;\n\t\tadapter->used_tx_channels = LAN743X_USED_TX_CHANNELS;\n\t\tadapter->max_vector_count = LAN743X_MAX_VECTOR_COUNT;\n\t}\n\n\tadapter->intr.irq = adapter->pdev->irq;\n\tlan743x_csr_write(adapter, INT_EN_CLR, 0xFFFFFFFF);\n\n\tret = lan743x_gpio_init(adapter);\n\tif (ret)\n\t\treturn ret;\n\n\tret = lan743x_mac_init(adapter);\n\tif (ret)\n\t\treturn ret;\n\n\tret = lan743x_phy_init(adapter);\n\tif (ret)\n\t\treturn ret;\n\n\tret = lan743x_ptp_init(adapter);\n\tif (ret)\n\t\treturn ret;\n\n\tlan743x_rfe_update_mac_address(adapter);\n\n\tret = lan743x_dmac_init(adapter);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (index = 0; index < LAN743X_USED_RX_CHANNELS; index++) {\n\t\tadapter->rx[index].adapter = adapter;\n\t\tadapter->rx[index].channel_number = index;\n\t}\n\n\tfor (index = 0; index < adapter->used_tx_channels; index++) {\n\t\ttx = &adapter->tx[index];\n\t\ttx->adapter = adapter;\n\t\ttx->channel_number = index;\n\t\tspin_lock_init(&tx->ring_lock);\n\t}\n\n\treturn 0;\n}\n\nstatic int lan743x_mdiobus_init(struct lan743x_adapter *adapter)\n{\n\tu32 sgmii_ctl;\n\tint ret;\n\n\tadapter->mdiobus = devm_mdiobus_alloc(&adapter->pdev->dev);\n\tif (!(adapter->mdiobus)) {\n\t\tret = -ENOMEM;\n\t\tgoto return_error;\n\t}\n\n\tadapter->mdiobus->priv = (void *)adapter;\n\tif (adapter->is_pci11x1x) {\n\t\tif (adapter->is_sgmii_en) {\n\t\t\tsgmii_ctl = lan743x_csr_read(adapter, SGMII_CTL);\n\t\t\tsgmii_ctl |= SGMII_CTL_SGMII_ENABLE_;\n\t\t\tsgmii_ctl &= ~SGMII_CTL_SGMII_POWER_DN_;\n\t\t\tlan743x_csr_write(adapter, SGMII_CTL, sgmii_ctl);\n\t\t\tnetif_dbg(adapter, drv, adapter->netdev,\n\t\t\t\t  \"SGMII operation\\n\");\n\t\t\tadapter->mdiobus->read = lan743x_mdiobus_read_c22;\n\t\t\tadapter->mdiobus->write = lan743x_mdiobus_write_c22;\n\t\t\tadapter->mdiobus->read_c45 = lan743x_mdiobus_read_c45;\n\t\t\tadapter->mdiobus->write_c45 = lan743x_mdiobus_write_c45;\n\t\t\tadapter->mdiobus->name = \"lan743x-mdiobus-c45\";\n\t\t\tnetif_dbg(adapter, drv, adapter->netdev,\n\t\t\t\t  \"lan743x-mdiobus-c45\\n\");\n\t\t} else {\n\t\t\tsgmii_ctl = lan743x_csr_read(adapter, SGMII_CTL);\n\t\t\tsgmii_ctl &= ~SGMII_CTL_SGMII_ENABLE_;\n\t\t\tsgmii_ctl |= SGMII_CTL_SGMII_POWER_DN_;\n\t\t\tlan743x_csr_write(adapter, SGMII_CTL, sgmii_ctl);\n\t\t\tnetif_dbg(adapter, drv, adapter->netdev,\n\t\t\t\t  \"RGMII operation\\n\");\n\t\t\t\n\t\t\tadapter->mdiobus->read = lan743x_mdiobus_read_c22;\n\t\t\tadapter->mdiobus->write = lan743x_mdiobus_write_c22;\n\t\t\tadapter->mdiobus->name = \"lan743x-mdiobus\";\n\t\t\tnetif_dbg(adapter, drv, adapter->netdev,\n\t\t\t\t  \"lan743x-mdiobus\\n\");\n\t\t}\n\t} else {\n\t\tadapter->mdiobus->read = lan743x_mdiobus_read_c22;\n\t\tadapter->mdiobus->write = lan743x_mdiobus_write_c22;\n\t\tadapter->mdiobus->name = \"lan743x-mdiobus\";\n\t\tnetif_dbg(adapter, drv, adapter->netdev, \"lan743x-mdiobus\\n\");\n\t}\n\n\tsnprintf(adapter->mdiobus->id, MII_BUS_ID_SIZE,\n\t\t \"pci-%s\", pci_name(adapter->pdev));\n\n\tif ((adapter->csr.id_rev & ID_REV_ID_MASK_) == ID_REV_ID_LAN7430_)\n\t\t \n\t\tadapter->mdiobus->phy_mask = ~(u32)BIT(1);\n\n\t \n\tret = mdiobus_register(adapter->mdiobus);\n\tif (ret < 0)\n\t\tgoto return_error;\n\treturn 0;\n\nreturn_error:\n\treturn ret;\n}\n\n \nstatic int lan743x_pcidev_probe(struct pci_dev *pdev,\n\t\t\t\tconst struct pci_device_id *id)\n{\n\tstruct lan743x_adapter *adapter = NULL;\n\tstruct net_device *netdev = NULL;\n\tint ret = -ENODEV;\n\n\tif (id->device == PCI_DEVICE_ID_SMSC_A011 ||\n\t    id->device == PCI_DEVICE_ID_SMSC_A041) {\n\t\tnetdev = devm_alloc_etherdev_mqs(&pdev->dev,\n\t\t\t\t\t\t sizeof(struct lan743x_adapter),\n\t\t\t\t\t\t PCI11X1X_USED_TX_CHANNELS,\n\t\t\t\t\t\t LAN743X_USED_RX_CHANNELS);\n\t} else {\n\t\tnetdev = devm_alloc_etherdev_mqs(&pdev->dev,\n\t\t\t\t\t\t sizeof(struct lan743x_adapter),\n\t\t\t\t\t\t LAN743X_USED_TX_CHANNELS,\n\t\t\t\t\t\t LAN743X_USED_RX_CHANNELS);\n\t}\n\n\tif (!netdev)\n\t\tgoto return_error;\n\n\tSET_NETDEV_DEV(netdev, &pdev->dev);\n\tpci_set_drvdata(pdev, netdev);\n\tadapter = netdev_priv(netdev);\n\tadapter->netdev = netdev;\n\tadapter->msg_enable = NETIF_MSG_DRV | NETIF_MSG_PROBE |\n\t\t\t      NETIF_MSG_LINK | NETIF_MSG_IFUP |\n\t\t\t      NETIF_MSG_IFDOWN | NETIF_MSG_TX_QUEUED;\n\tnetdev->max_mtu = LAN743X_MAX_FRAME_SIZE;\n\n\tof_get_mac_address(pdev->dev.of_node, adapter->mac_address);\n\n\tret = lan743x_pci_init(adapter, pdev);\n\tif (ret)\n\t\tgoto return_error;\n\n\tret = lan743x_csr_init(adapter);\n\tif (ret)\n\t\tgoto cleanup_pci;\n\n\tret = lan743x_hardware_init(adapter, pdev);\n\tif (ret)\n\t\tgoto cleanup_pci;\n\n\tret = lan743x_mdiobus_init(adapter);\n\tif (ret)\n\t\tgoto cleanup_hardware;\n\n\tadapter->netdev->netdev_ops = &lan743x_netdev_ops;\n\tadapter->netdev->ethtool_ops = &lan743x_ethtool_ops;\n\tadapter->netdev->features = NETIF_F_SG | NETIF_F_TSO |\n\t\t\t\t    NETIF_F_HW_CSUM | NETIF_F_RXCSUM;\n\tadapter->netdev->hw_features = adapter->netdev->features;\n\n\t \n\tnetif_carrier_off(netdev);\n\n\tret = register_netdev(adapter->netdev);\n\tif (ret < 0)\n\t\tgoto cleanup_mdiobus;\n\treturn 0;\n\ncleanup_mdiobus:\n\tlan743x_mdiobus_cleanup(adapter);\n\ncleanup_hardware:\n\tlan743x_hardware_cleanup(adapter);\n\ncleanup_pci:\n\tlan743x_pci_cleanup(adapter);\n\nreturn_error:\n\tpr_warn(\"Initialization failed\\n\");\n\treturn ret;\n}\n\n \nstatic void lan743x_pcidev_remove(struct pci_dev *pdev)\n{\n\tstruct net_device *netdev = pci_get_drvdata(pdev);\n\tstruct lan743x_adapter *adapter = netdev_priv(netdev);\n\n\tlan743x_full_cleanup(adapter);\n}\n\nstatic void lan743x_pcidev_shutdown(struct pci_dev *pdev)\n{\n\tstruct net_device *netdev = pci_get_drvdata(pdev);\n\tstruct lan743x_adapter *adapter = netdev_priv(netdev);\n\n\trtnl_lock();\n\tnetif_device_detach(netdev);\n\n\t \n\tif (netif_running(netdev))\n\t\tlan743x_netdev_close(netdev);\n\trtnl_unlock();\n\n#ifdef CONFIG_PM\n\tpci_save_state(pdev);\n#endif\n\n\t \n\tlan743x_hardware_cleanup(adapter);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic u16 lan743x_pm_wakeframe_crc16(const u8 *buf, int len)\n{\n\treturn bitrev16(crc16(0xFFFF, buf, len));\n}\n\nstatic void lan743x_pm_set_wol(struct lan743x_adapter *adapter)\n{\n\tconst u8 ipv4_multicast[3] = { 0x01, 0x00, 0x5E };\n\tconst u8 ipv6_multicast[3] = { 0x33, 0x33 };\n\tconst u8 arp_type[2] = { 0x08, 0x06 };\n\tint mask_index;\n\tu32 sopass;\n\tu32 pmtctl;\n\tu32 wucsr;\n\tu32 macrx;\n\tu16 crc;\n\n\tfor (mask_index = 0; mask_index < MAC_NUM_OF_WUF_CFG; mask_index++)\n\t\tlan743x_csr_write(adapter, MAC_WUF_CFG(mask_index), 0);\n\n\t \n\tpmtctl = lan743x_csr_read(adapter, PMT_CTL);\n\tpmtctl |= PMT_CTL_WUPS_MASK_;\n\tpmtctl &= ~(PMT_CTL_GPIO_WAKEUP_EN_ | PMT_CTL_EEE_WAKEUP_EN_ |\n\t\tPMT_CTL_WOL_EN_ | PMT_CTL_MAC_D3_RX_CLK_OVR_ |\n\t\tPMT_CTL_RX_FCT_RFE_D3_CLK_OVR_ | PMT_CTL_ETH_PHY_WAKE_EN_);\n\n\tmacrx = lan743x_csr_read(adapter, MAC_RX);\n\n\twucsr = 0;\n\tmask_index = 0;\n\n\tpmtctl |= PMT_CTL_ETH_PHY_D3_COLD_OVR_ | PMT_CTL_ETH_PHY_D3_OVR_;\n\n\tif (adapter->wolopts & WAKE_PHY) {\n\t\tpmtctl |= PMT_CTL_ETH_PHY_EDPD_PLL_CTL_;\n\t\tpmtctl |= PMT_CTL_ETH_PHY_WAKE_EN_;\n\t}\n\tif (adapter->wolopts & WAKE_MAGIC) {\n\t\twucsr |= MAC_WUCSR_MPEN_;\n\t\tmacrx |= MAC_RX_RXEN_;\n\t\tpmtctl |= PMT_CTL_WOL_EN_ | PMT_CTL_MAC_D3_RX_CLK_OVR_;\n\t}\n\tif (adapter->wolopts & WAKE_UCAST) {\n\t\twucsr |= MAC_WUCSR_RFE_WAKE_EN_ | MAC_WUCSR_PFDA_EN_;\n\t\tmacrx |= MAC_RX_RXEN_;\n\t\tpmtctl |= PMT_CTL_WOL_EN_ | PMT_CTL_MAC_D3_RX_CLK_OVR_;\n\t\tpmtctl |= PMT_CTL_RX_FCT_RFE_D3_CLK_OVR_;\n\t}\n\tif (adapter->wolopts & WAKE_BCAST) {\n\t\twucsr |= MAC_WUCSR_RFE_WAKE_EN_ | MAC_WUCSR_BCST_EN_;\n\t\tmacrx |= MAC_RX_RXEN_;\n\t\tpmtctl |= PMT_CTL_WOL_EN_ | PMT_CTL_MAC_D3_RX_CLK_OVR_;\n\t\tpmtctl |= PMT_CTL_RX_FCT_RFE_D3_CLK_OVR_;\n\t}\n\tif (adapter->wolopts & WAKE_MCAST) {\n\t\t \n\t\tcrc = lan743x_pm_wakeframe_crc16(ipv4_multicast, 3);\n\t\tlan743x_csr_write(adapter, MAC_WUF_CFG(mask_index),\n\t\t\t\t  MAC_WUF_CFG_EN_ | MAC_WUF_CFG_TYPE_MCAST_ |\n\t\t\t\t  (0 << MAC_WUF_CFG_OFFSET_SHIFT_) |\n\t\t\t\t  (crc & MAC_WUF_CFG_CRC16_MASK_));\n\t\tlan743x_csr_write(adapter, MAC_WUF_MASK0(mask_index), 7);\n\t\tlan743x_csr_write(adapter, MAC_WUF_MASK1(mask_index), 0);\n\t\tlan743x_csr_write(adapter, MAC_WUF_MASK2(mask_index), 0);\n\t\tlan743x_csr_write(adapter, MAC_WUF_MASK3(mask_index), 0);\n\t\tmask_index++;\n\n\t\t \n\t\tcrc = lan743x_pm_wakeframe_crc16(ipv6_multicast, 2);\n\t\tlan743x_csr_write(adapter, MAC_WUF_CFG(mask_index),\n\t\t\t\t  MAC_WUF_CFG_EN_ | MAC_WUF_CFG_TYPE_MCAST_ |\n\t\t\t\t  (0 << MAC_WUF_CFG_OFFSET_SHIFT_) |\n\t\t\t\t  (crc & MAC_WUF_CFG_CRC16_MASK_));\n\t\tlan743x_csr_write(adapter, MAC_WUF_MASK0(mask_index), 3);\n\t\tlan743x_csr_write(adapter, MAC_WUF_MASK1(mask_index), 0);\n\t\tlan743x_csr_write(adapter, MAC_WUF_MASK2(mask_index), 0);\n\t\tlan743x_csr_write(adapter, MAC_WUF_MASK3(mask_index), 0);\n\t\tmask_index++;\n\n\t\twucsr |= MAC_WUCSR_RFE_WAKE_EN_ | MAC_WUCSR_WAKE_EN_;\n\t\tmacrx |= MAC_RX_RXEN_;\n\t\tpmtctl |= PMT_CTL_WOL_EN_ | PMT_CTL_MAC_D3_RX_CLK_OVR_;\n\t\tpmtctl |= PMT_CTL_RX_FCT_RFE_D3_CLK_OVR_;\n\t}\n\tif (adapter->wolopts & WAKE_ARP) {\n\t\t \n\t\tcrc = lan743x_pm_wakeframe_crc16(arp_type, 2);\n\t\tlan743x_csr_write(adapter, MAC_WUF_CFG(mask_index),\n\t\t\t\t  MAC_WUF_CFG_EN_ | MAC_WUF_CFG_TYPE_ALL_ |\n\t\t\t\t  (0 << MAC_WUF_CFG_OFFSET_SHIFT_) |\n\t\t\t\t  (crc & MAC_WUF_CFG_CRC16_MASK_));\n\t\tlan743x_csr_write(adapter, MAC_WUF_MASK0(mask_index), 0x3000);\n\t\tlan743x_csr_write(adapter, MAC_WUF_MASK1(mask_index), 0);\n\t\tlan743x_csr_write(adapter, MAC_WUF_MASK2(mask_index), 0);\n\t\tlan743x_csr_write(adapter, MAC_WUF_MASK3(mask_index), 0);\n\t\tmask_index++;\n\n\t\twucsr |= MAC_WUCSR_RFE_WAKE_EN_ | MAC_WUCSR_WAKE_EN_;\n\t\tmacrx |= MAC_RX_RXEN_;\n\t\tpmtctl |= PMT_CTL_WOL_EN_ | PMT_CTL_MAC_D3_RX_CLK_OVR_;\n\t\tpmtctl |= PMT_CTL_RX_FCT_RFE_D3_CLK_OVR_;\n\t}\n\n\tif (adapter->wolopts & WAKE_MAGICSECURE) {\n\t\tsopass = *(u32 *)adapter->sopass;\n\t\tlan743x_csr_write(adapter, MAC_MP_SO_LO, sopass);\n\t\tsopass = *(u16 *)&adapter->sopass[4];\n\t\tlan743x_csr_write(adapter, MAC_MP_SO_HI, sopass);\n\t\twucsr |= MAC_MP_SO_EN_;\n\t}\n\n\tlan743x_csr_write(adapter, MAC_WUCSR, wucsr);\n\tlan743x_csr_write(adapter, PMT_CTL, pmtctl);\n\tlan743x_csr_write(adapter, MAC_RX, macrx);\n}\n\nstatic int lan743x_pm_suspend(struct device *dev)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tstruct net_device *netdev = pci_get_drvdata(pdev);\n\tstruct lan743x_adapter *adapter = netdev_priv(netdev);\n\tu32 data;\n\n\tlan743x_pcidev_shutdown(pdev);\n\n\t \n\tlan743x_csr_write(adapter, MAC_WUCSR, 0);\n\tlan743x_csr_write(adapter, MAC_WUCSR2, 0);\n\tlan743x_csr_write(adapter, MAC_WK_SRC, 0xFFFFFFFF);\n\n\tif (adapter->wolopts)\n\t\tlan743x_pm_set_wol(adapter);\n\n\tif (adapter->is_pci11x1x) {\n\t\t \n\t\tdata = lan743x_csr_read(adapter, HW_CFG);\n\t\tadapter->hw_cfg = data;\n\t\tdata |= (HW_CFG_RST_PROTECT_PCIE_ |\n\t\t\t HW_CFG_D3_RESET_DIS_ |\n\t\t\t HW_CFG_D3_VAUX_OVR_ |\n\t\t\t HW_CFG_HOT_RESET_DIS_ |\n\t\t\t HW_CFG_RST_PROTECT_);\n\t\tlan743x_csr_write(adapter, HW_CFG, data);\n\t}\n\n\t \n\treturn pci_prepare_to_sleep(pdev);\n}\n\nstatic int lan743x_pm_resume(struct device *dev)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tstruct net_device *netdev = pci_get_drvdata(pdev);\n\tstruct lan743x_adapter *adapter = netdev_priv(netdev);\n\tint ret;\n\n\tpci_set_power_state(pdev, PCI_D0);\n\tpci_restore_state(pdev);\n\tpci_save_state(pdev);\n\n\t \n\tif (adapter->is_pci11x1x)\n\t\tlan743x_csr_write(adapter, HW_CFG, adapter->hw_cfg);\n\n\tret = lan743x_hardware_init(adapter, pdev);\n\tif (ret) {\n\t\tnetif_err(adapter, probe, adapter->netdev,\n\t\t\t  \"lan743x_hardware_init returned %d\\n\", ret);\n\t\tlan743x_pci_cleanup(adapter);\n\t\treturn ret;\n\t}\n\n\t \n\tif (netif_running(netdev))\n\t\tlan743x_netdev_open(netdev);\n\n\tnetif_device_attach(netdev);\n\tret = lan743x_csr_read(adapter, MAC_WK_SRC);\n\tnetif_info(adapter, drv, adapter->netdev,\n\t\t   \"Wakeup source : 0x%08X\\n\", ret);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops lan743x_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(lan743x_pm_suspend, lan743x_pm_resume)\n};\n#endif  \n\nstatic const struct pci_device_id lan743x_pcidev_tbl[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_SMSC, PCI_DEVICE_ID_SMSC_LAN7430) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_SMSC, PCI_DEVICE_ID_SMSC_LAN7431) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_SMSC, PCI_DEVICE_ID_SMSC_A011) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_SMSC, PCI_DEVICE_ID_SMSC_A041) },\n\t{ 0, }\n};\n\nMODULE_DEVICE_TABLE(pci, lan743x_pcidev_tbl);\n\nstatic struct pci_driver lan743x_pcidev_driver = {\n\t.name     = DRIVER_NAME,\n\t.id_table = lan743x_pcidev_tbl,\n\t.probe    = lan743x_pcidev_probe,\n\t.remove   = lan743x_pcidev_remove,\n#ifdef CONFIG_PM_SLEEP\n\t.driver.pm = &lan743x_pm_ops,\n#endif\n\t.shutdown = lan743x_pcidev_shutdown,\n};\n\nmodule_pci_driver(lan743x_pcidev_driver);\n\nMODULE_AUTHOR(DRIVER_AUTHOR);\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}