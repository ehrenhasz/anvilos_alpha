{
  "module_name": "ll_temac_mdio.c",
  "hash_id": "380dd6434811ec091daefbe1fc4d35964604f741437f895b3c5fe06336b62118",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/xilinx/ll_temac_mdio.c",
  "human_readable_source": "\n \n\n#include <linux/io.h>\n#include <linux/netdevice.h>\n#include <linux/mutex.h>\n#include <linux/phy.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/of_mdio.h>\n#include <linux/platform_data/xilinx-ll-temac.h>\n\n#include \"ll_temac.h\"\n\n \nstatic int temac_mdio_read(struct mii_bus *bus, int phy_id, int reg)\n{\n\tstruct temac_local *lp = bus->priv;\n\tu32 rc;\n\tunsigned long flags;\n\n\t \n\tspin_lock_irqsave(lp->indirect_lock, flags);\n\ttemac_iow(lp, XTE_LSW0_OFFSET, (phy_id << 5) | reg);\n\trc = temac_indirect_in32_locked(lp, XTE_MIIMAI_OFFSET);\n\tspin_unlock_irqrestore(lp->indirect_lock, flags);\n\n\tdev_dbg(lp->dev, \"temac_mdio_read(phy_id=%i, reg=%x) == %x\\n\",\n\t\tphy_id, reg, rc);\n\n\treturn rc;\n}\n\nstatic int temac_mdio_write(struct mii_bus *bus, int phy_id, int reg, u16 val)\n{\n\tstruct temac_local *lp = bus->priv;\n\tunsigned long flags;\n\n\tdev_dbg(lp->dev, \"temac_mdio_write(phy_id=%i, reg=%x, val=%x)\\n\",\n\t\tphy_id, reg, val);\n\n\t \n\tspin_lock_irqsave(lp->indirect_lock, flags);\n\ttemac_indirect_out32_locked(lp, XTE_MGTDR_OFFSET, val);\n\ttemac_indirect_out32_locked(lp, XTE_MIIMAI_OFFSET, (phy_id << 5) | reg);\n\tspin_unlock_irqrestore(lp->indirect_lock, flags);\n\n\treturn 0;\n}\n\nint temac_mdio_setup(struct temac_local *lp, struct platform_device *pdev)\n{\n\tstruct ll_temac_platform_data *pdata = dev_get_platdata(&pdev->dev);\n\tstruct device_node *np = dev_of_node(&pdev->dev);\n\tstruct mii_bus *bus;\n\tu32 bus_hz;\n\tint clk_div;\n\tint rc;\n\tstruct resource res;\n\n\t \n\tbus_hz = 0;\n\tif (np)\n\t\tof_property_read_u32(np, \"clock-frequency\", &bus_hz);\n\telse if (pdata)\n\t\tbus_hz = pdata->mdio_clk_freq;\n\n\t \n\tclk_div = 0x3f;  \n\tif (bus_hz != 0) {\n\t\tclk_div = bus_hz / (2500 * 1000 * 2) - 1;\n\t\tif (clk_div < 1)\n\t\t\tclk_div = 1;\n\t\tif (clk_div > 0x3f)\n\t\t\tclk_div = 0x3f;\n\t}\n\n\t \n\ttemac_indirect_out32(lp, XTE_MC_OFFSET, 1 << 6 | clk_div);\n\n\tbus = devm_mdiobus_alloc(&pdev->dev);\n\tif (!bus)\n\t\treturn -ENOMEM;\n\n\tif (np) {\n\t\tof_address_to_resource(np, 0, &res);\n\t\tsnprintf(bus->id, MII_BUS_ID_SIZE, \"%.8llx\",\n\t\t\t (unsigned long long)res.start);\n\t} else if (pdata) {\n\t\tsnprintf(bus->id, MII_BUS_ID_SIZE, \"%.8llx\",\n\t\t\t pdata->mdio_bus_id);\n\t}\n\n\tbus->priv = lp;\n\tbus->name = \"Xilinx TEMAC MDIO\";\n\tbus->read = temac_mdio_read;\n\tbus->write = temac_mdio_write;\n\tbus->parent = lp->dev;\n\n\tlp->mii_bus = bus;\n\n\trc = of_mdiobus_register(bus, np);\n\tif (rc)\n\t\treturn rc;\n\n\tdev_dbg(lp->dev, \"MDIO bus registered;  MC:%x\\n\",\n\t\ttemac_indirect_in32(lp, XTE_MC_OFFSET));\n\treturn 0;\n}\n\nvoid temac_mdio_teardown(struct temac_local *lp)\n{\n\tmdiobus_unregister(lp->mii_bus);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}