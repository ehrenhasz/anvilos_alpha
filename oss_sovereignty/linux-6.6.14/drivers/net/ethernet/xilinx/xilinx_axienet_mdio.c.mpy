{
  "module_name": "xilinx_axienet_mdio.c",
  "hash_id": "e2a2480864b425e396de2c88dd004bcc56bcb768a28fc9a115a737f6f2d117a2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/xilinx/xilinx_axienet_mdio.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/of_address.h>\n#include <linux/of_mdio.h>\n#include <linux/jiffies.h>\n#include <linux/iopoll.h>\n\n#include \"xilinx_axienet.h\"\n\n#define DEFAULT_MDIO_FREQ\t2500000  \n#define DEFAULT_HOST_CLOCK\t150000000  \n\n \nstatic int axienet_mdio_wait_until_ready(struct axienet_local *lp)\n{\n\tu32 val;\n\n\treturn readx_poll_timeout(axinet_ior_read_mcr, lp,\n\t\t\t\t  val, val & XAE_MDIO_MCR_READY_MASK,\n\t\t\t\t  1, 20000);\n}\n\n \nstatic void axienet_mdio_mdc_enable(struct axienet_local *lp)\n{\n\taxienet_iow(lp, XAE_MDIO_MC_OFFSET,\n\t\t    ((u32)lp->mii_clk_div | XAE_MDIO_MC_MDIOEN_MASK));\n}\n\n \nstatic void axienet_mdio_mdc_disable(struct axienet_local *lp)\n{\n\tu32 mc_reg;\n\n\tmc_reg = axienet_ior(lp, XAE_MDIO_MC_OFFSET);\n\taxienet_iow(lp, XAE_MDIO_MC_OFFSET,\n\t\t    (mc_reg & ~XAE_MDIO_MC_MDIOEN_MASK));\n}\n\n \nstatic int axienet_mdio_read(struct mii_bus *bus, int phy_id, int reg)\n{\n\tu32 rc;\n\tint ret;\n\tstruct axienet_local *lp = bus->priv;\n\n\taxienet_mdio_mdc_enable(lp);\n\n\tret = axienet_mdio_wait_until_ready(lp);\n\tif (ret < 0) {\n\t\taxienet_mdio_mdc_disable(lp);\n\t\treturn ret;\n\t}\n\n\taxienet_iow(lp, XAE_MDIO_MCR_OFFSET,\n\t\t    (((phy_id << XAE_MDIO_MCR_PHYAD_SHIFT) &\n\t\t      XAE_MDIO_MCR_PHYAD_MASK) |\n\t\t     ((reg << XAE_MDIO_MCR_REGAD_SHIFT) &\n\t\t      XAE_MDIO_MCR_REGAD_MASK) |\n\t\t     XAE_MDIO_MCR_INITIATE_MASK |\n\t\t     XAE_MDIO_MCR_OP_READ_MASK));\n\n\tret = axienet_mdio_wait_until_ready(lp);\n\tif (ret < 0) {\n\t\taxienet_mdio_mdc_disable(lp);\n\t\treturn ret;\n\t}\n\n\trc = axienet_ior(lp, XAE_MDIO_MRD_OFFSET) & 0x0000FFFF;\n\n\tdev_dbg(lp->dev, \"axienet_mdio_read(phy_id=%i, reg=%x) == %x\\n\",\n\t\tphy_id, reg, rc);\n\n\taxienet_mdio_mdc_disable(lp);\n\treturn rc;\n}\n\n \nstatic int axienet_mdio_write(struct mii_bus *bus, int phy_id, int reg,\n\t\t\t      u16 val)\n{\n\tint ret;\n\tstruct axienet_local *lp = bus->priv;\n\n\tdev_dbg(lp->dev, \"axienet_mdio_write(phy_id=%i, reg=%x, val=%x)\\n\",\n\t\tphy_id, reg, val);\n\n\taxienet_mdio_mdc_enable(lp);\n\n\tret = axienet_mdio_wait_until_ready(lp);\n\tif (ret < 0) {\n\t\taxienet_mdio_mdc_disable(lp);\n\t\treturn ret;\n\t}\n\n\taxienet_iow(lp, XAE_MDIO_MWD_OFFSET, (u32)val);\n\taxienet_iow(lp, XAE_MDIO_MCR_OFFSET,\n\t\t    (((phy_id << XAE_MDIO_MCR_PHYAD_SHIFT) &\n\t\t      XAE_MDIO_MCR_PHYAD_MASK) |\n\t\t     ((reg << XAE_MDIO_MCR_REGAD_SHIFT) &\n\t\t      XAE_MDIO_MCR_REGAD_MASK) |\n\t\t     XAE_MDIO_MCR_INITIATE_MASK |\n\t\t     XAE_MDIO_MCR_OP_WRITE_MASK));\n\n\tret = axienet_mdio_wait_until_ready(lp);\n\tif (ret < 0) {\n\t\taxienet_mdio_mdc_disable(lp);\n\t\treturn ret;\n\t}\n\taxienet_mdio_mdc_disable(lp);\n\treturn 0;\n}\n\n \nstatic int axienet_mdio_enable(struct axienet_local *lp, struct device_node *np)\n{\n\tu32 mdio_freq = DEFAULT_MDIO_FREQ;\n\tu32 host_clock;\n\tu32 clk_div;\n\tint ret;\n\n\tlp->mii_clk_div = 0;\n\n\tif (lp->axi_clk) {\n\t\thost_clock = clk_get_rate(lp->axi_clk);\n\t} else {\n\t\tstruct device_node *np1;\n\n\t\t \n\t\tnp1 = of_find_node_by_name(NULL, \"cpu\");\n\t\tif (!np1) {\n\t\t\tnetdev_warn(lp->ndev, \"Could not find CPU device node.\\n\");\n\t\t\thost_clock = DEFAULT_HOST_CLOCK;\n\t\t} else {\n\t\t\tint ret = of_property_read_u32(np1, \"clock-frequency\",\n\t\t\t\t\t\t       &host_clock);\n\t\t\tif (ret) {\n\t\t\t\tnetdev_warn(lp->ndev, \"CPU clock-frequency property not found.\\n\");\n\t\t\t\thost_clock = DEFAULT_HOST_CLOCK;\n\t\t\t}\n\t\t\tof_node_put(np1);\n\t\t}\n\t\tnetdev_info(lp->ndev, \"Setting assumed host clock to %u\\n\",\n\t\t\t    host_clock);\n\t}\n\n\tif (np)\n\t\tof_property_read_u32(np, \"clock-frequency\", &mdio_freq);\n\tif (mdio_freq != DEFAULT_MDIO_FREQ)\n\t\tnetdev_info(lp->ndev, \"Setting non-standard mdio bus frequency to %u Hz\\n\",\n\t\t\t    mdio_freq);\n\n\t \n\n\tclk_div = (host_clock / (mdio_freq * 2)) - 1;\n\t \n\tif (host_clock % (mdio_freq * 2))\n\t\tclk_div++;\n\n\t \n\tif (clk_div & ~XAE_MDIO_MC_CLOCK_DIVIDE_MAX) {\n\t\tnetdev_warn(lp->ndev, \"MDIO clock divisor overflow\\n\");\n\t\treturn -EOVERFLOW;\n\t}\n\tlp->mii_clk_div = (u8)clk_div;\n\n\tnetdev_dbg(lp->ndev,\n\t\t   \"Setting MDIO clock divisor to %u/%u Hz host clock.\\n\",\n\t\t   lp->mii_clk_div, host_clock);\n\n\taxienet_mdio_mdc_enable(lp);\n\n\tret = axienet_mdio_wait_until_ready(lp);\n\tif (ret)\n\t\taxienet_mdio_mdc_disable(lp);\n\n\treturn ret;\n}\n\n \nint axienet_mdio_setup(struct axienet_local *lp)\n{\n\tstruct device_node *mdio_node;\n\tstruct mii_bus *bus;\n\tint ret;\n\n\tbus = mdiobus_alloc();\n\tif (!bus)\n\t\treturn -ENOMEM;\n\n\tsnprintf(bus->id, MII_BUS_ID_SIZE, \"axienet-%.8llx\",\n\t\t (unsigned long long)lp->regs_start);\n\n\tbus->priv = lp;\n\tbus->name = \"Xilinx Axi Ethernet MDIO\";\n\tbus->read = axienet_mdio_read;\n\tbus->write = axienet_mdio_write;\n\tbus->parent = lp->dev;\n\tlp->mii_bus = bus;\n\n\tmdio_node = of_get_child_by_name(lp->dev->of_node, \"mdio\");\n\tret = axienet_mdio_enable(lp, mdio_node);\n\tif (ret < 0)\n\t\tgoto unregister;\n\tret = of_mdiobus_register(bus, mdio_node);\n\tif (ret)\n\t\tgoto unregister_mdio_enabled;\n\tof_node_put(mdio_node);\n\taxienet_mdio_mdc_disable(lp);\n\treturn 0;\n\nunregister_mdio_enabled:\n\taxienet_mdio_mdc_disable(lp);\nunregister:\n\tof_node_put(mdio_node);\n\tmdiobus_free(bus);\n\tlp->mii_bus = NULL;\n\treturn ret;\n}\n\n \nvoid axienet_mdio_teardown(struct axienet_local *lp)\n{\n\tmdiobus_unregister(lp->mii_bus);\n\tmdiobus_free(lp->mii_bus);\n\tlp->mii_bus = NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}