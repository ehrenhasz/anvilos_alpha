{
  "module_name": "xilinx_emaclite.c",
  "hash_id": "87e81381ce689769adaed90b379c940741e363c08f98e3df7a34c254768a157d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/xilinx/xilinx_emaclite.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/uaccess.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/skbuff.h>\n#include <linux/ethtool.h>\n#include <linux/io.h>\n#include <linux/slab.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_mdio.h>\n#include <linux/of_net.h>\n#include <linux/phy.h>\n#include <linux/interrupt.h>\n#include <linux/iopoll.h>\n\n#define DRIVER_NAME \"xilinx_emaclite\"\n\n \n#define XEL_TXBUFF_OFFSET\t0x0\t\t \n#define XEL_MDIOADDR_OFFSET\t0x07E4\t\t \n#define XEL_MDIOWR_OFFSET\t0x07E8\t\t \n#define XEL_MDIORD_OFFSET\t0x07EC\t\t \n#define XEL_MDIOCTRL_OFFSET\t0x07F0\t\t \n#define XEL_GIER_OFFSET\t\t0x07F8\t\t \n#define XEL_TSR_OFFSET\t\t0x07FC\t\t \n#define XEL_TPLR_OFFSET\t\t0x07F4\t\t \n\n#define XEL_RXBUFF_OFFSET\t0x1000\t\t \n#define XEL_RPLR_OFFSET\t\t0x100C\t\t \n#define XEL_RSR_OFFSET\t\t0x17FC\t\t \n\n#define XEL_BUFFER_OFFSET\t0x0800\t\t \n\n \n#define XEL_MDIOADDR_REGADR_MASK  0x0000001F\t \n#define XEL_MDIOADDR_PHYADR_MASK  0x000003E0\t \n#define XEL_MDIOADDR_PHYADR_SHIFT 5\n#define XEL_MDIOADDR_OP_MASK\t  0x00000400\t \n\n \n#define XEL_MDIOWR_WRDATA_MASK\t  0x0000FFFF\t \n\n \n#define XEL_MDIORD_RDDATA_MASK\t  0x0000FFFF\t \n\n \n#define XEL_MDIOCTRL_MDIOSTS_MASK 0x00000001\t \n#define XEL_MDIOCTRL_MDIOEN_MASK  0x00000008\t \n\n \n#define XEL_GIER_GIE_MASK\t0x80000000\t \n\n \n#define XEL_TSR_XMIT_BUSY_MASK\t 0x00000001\t \n#define XEL_TSR_PROGRAM_MASK\t 0x00000002\t \n#define XEL_TSR_XMIT_IE_MASK\t 0x00000008\t \n#define XEL_TSR_XMIT_ACTIVE_MASK 0x80000000\t \n\n \n#define XEL_TSR_PROG_MAC_ADDR\t(XEL_TSR_XMIT_BUSY_MASK | XEL_TSR_PROGRAM_MASK)\n\n \n#define XEL_RSR_RECV_DONE_MASK\t0x00000001\t \n#define XEL_RSR_RECV_IE_MASK\t0x00000008\t \n\n \n#define XEL_TPLR_LENGTH_MASK\t0x0000FFFF\t \n\n \n#define XEL_RPLR_LENGTH_MASK\t0x0000FFFF\t \n\n#define XEL_HEADER_OFFSET\t12\t\t \n#define XEL_HEADER_SHIFT\t16\t\t \n\n \n#define XEL_ARP_PACKET_SIZE\t\t28\t \n#define XEL_HEADER_IP_LENGTH_OFFSET\t16\t \n\n#define TX_TIMEOUT\t\t(60 * HZ)\t \n\n#ifdef __BIG_ENDIAN\n#define xemaclite_readl\t\tioread32be\n#define xemaclite_writel\tiowrite32be\n#else\n#define xemaclite_readl\t\tioread32\n#define xemaclite_writel\tiowrite32\n#endif\n\n \nstruct net_local {\n\tstruct net_device *ndev;\n\n\tbool tx_ping_pong;\n\tbool rx_ping_pong;\n\tu32 next_tx_buf_to_use;\n\tu32 next_rx_buf_to_use;\n\tvoid __iomem *base_addr;\n\n\tspinlock_t reset_lock;  \n\tstruct sk_buff *deferred_skb;\n\n\tstruct phy_device *phy_dev;\n\tstruct device_node *phy_node;\n\n\tstruct mii_bus *mii_bus;\n\n\tint last_link;\n};\n\n \n \n \n\n \nstatic void xemaclite_enable_interrupts(struct net_local *drvdata)\n{\n\tu32 reg_data;\n\n\t \n\treg_data = xemaclite_readl(drvdata->base_addr + XEL_TSR_OFFSET);\n\txemaclite_writel(reg_data | XEL_TSR_XMIT_IE_MASK,\n\t\t\t drvdata->base_addr + XEL_TSR_OFFSET);\n\n\t \n\txemaclite_writel(XEL_RSR_RECV_IE_MASK, drvdata->base_addr + XEL_RSR_OFFSET);\n\n\t \n\txemaclite_writel(XEL_GIER_GIE_MASK, drvdata->base_addr + XEL_GIER_OFFSET);\n}\n\n \nstatic void xemaclite_disable_interrupts(struct net_local *drvdata)\n{\n\tu32 reg_data;\n\n\t \n\txemaclite_writel(XEL_GIER_GIE_MASK, drvdata->base_addr + XEL_GIER_OFFSET);\n\n\t \n\treg_data = xemaclite_readl(drvdata->base_addr + XEL_TSR_OFFSET);\n\txemaclite_writel(reg_data & (~XEL_TSR_XMIT_IE_MASK),\n\t\t\t drvdata->base_addr + XEL_TSR_OFFSET);\n\n\t \n\treg_data = xemaclite_readl(drvdata->base_addr + XEL_RSR_OFFSET);\n\txemaclite_writel(reg_data & (~XEL_RSR_RECV_IE_MASK),\n\t\t\t drvdata->base_addr + XEL_RSR_OFFSET);\n}\n\n \nstatic void xemaclite_aligned_write(const void *src_ptr, u32 *dest_ptr,\n\t\t\t\t    unsigned int length)\n{\n\tconst u16 *from_u16_ptr;\n\tu32 align_buffer;\n\tu32 *to_u32_ptr;\n\tu16 *to_u16_ptr;\n\n\tto_u32_ptr = dest_ptr;\n\tfrom_u16_ptr = src_ptr;\n\talign_buffer = 0;\n\n\tfor (; length > 3; length -= 4) {\n\t\tto_u16_ptr = (u16 *)&align_buffer;\n\t\t*to_u16_ptr++ = *from_u16_ptr++;\n\t\t*to_u16_ptr++ = *from_u16_ptr++;\n\n\t\t \n\t\twmb();\n\n\t\t \n\t\t*to_u32_ptr++ = align_buffer;\n\t}\n\tif (length) {\n\t\tu8 *from_u8_ptr, *to_u8_ptr;\n\n\t\t \n\t\talign_buffer = 0;\n\t\tto_u8_ptr = (u8 *)&align_buffer;\n\t\tfrom_u8_ptr = (u8 *)from_u16_ptr;\n\n\t\t \n\t\tfor (; length > 0; length--)\n\t\t\t*to_u8_ptr++ = *from_u8_ptr++;\n\n\t\t \n\t\twmb();\n\t\t*to_u32_ptr = align_buffer;\n\t}\n}\n\n \nstatic void xemaclite_aligned_read(u32 *src_ptr, u8 *dest_ptr,\n\t\t\t\t   unsigned int length)\n{\n\tu16 *to_u16_ptr, *from_u16_ptr;\n\tu32 *from_u32_ptr;\n\tu32 align_buffer;\n\n\tfrom_u32_ptr = src_ptr;\n\tto_u16_ptr = (u16 *)dest_ptr;\n\n\tfor (; length > 3; length -= 4) {\n\t\t \n\t\talign_buffer = *from_u32_ptr++;\n\t\tfrom_u16_ptr = (u16 *)&align_buffer;\n\n\t\t \n\t\t*to_u16_ptr++ = *from_u16_ptr++;\n\t\t*to_u16_ptr++ = *from_u16_ptr++;\n\t}\n\n\tif (length) {\n\t\tu8 *to_u8_ptr, *from_u8_ptr;\n\n\t\t \n\t\tto_u8_ptr = (u8 *)to_u16_ptr;\n\t\talign_buffer = *from_u32_ptr++;\n\t\tfrom_u8_ptr = (u8 *)&align_buffer;\n\n\t\t \n\t\tfor (; length > 0; length--)\n\t\t\t*to_u8_ptr = *from_u8_ptr;\n\t}\n}\n\n \nstatic int xemaclite_send_data(struct net_local *drvdata, u8 *data,\n\t\t\t       unsigned int byte_count)\n{\n\tu32 reg_data;\n\tvoid __iomem *addr;\n\n\t \n\taddr = drvdata->base_addr + drvdata->next_tx_buf_to_use;\n\n\t \n\tif (byte_count > ETH_FRAME_LEN)\n\t\tbyte_count = ETH_FRAME_LEN;\n\n\t \n\treg_data = xemaclite_readl(addr + XEL_TSR_OFFSET);\n\tif ((reg_data & (XEL_TSR_XMIT_BUSY_MASK |\n\t     XEL_TSR_XMIT_ACTIVE_MASK)) == 0) {\n\t\t \n\t\tif (drvdata->tx_ping_pong != 0)\n\t\t\tdrvdata->next_tx_buf_to_use ^= XEL_BUFFER_OFFSET;\n\t} else if (drvdata->tx_ping_pong != 0) {\n\t\t \n\n\t\taddr = (void __iomem __force *)((uintptr_t __force)addr ^\n\t\t\t\t\t\t XEL_BUFFER_OFFSET);\n\t\treg_data = xemaclite_readl(addr + XEL_TSR_OFFSET);\n\n\t\tif ((reg_data & (XEL_TSR_XMIT_BUSY_MASK |\n\t\t     XEL_TSR_XMIT_ACTIVE_MASK)) != 0)\n\t\t\treturn -1;  \n\t} else {\n\t\treturn -1;  \n\t}\n\n\t \n\txemaclite_aligned_write(data, (u32 __force *)addr, byte_count);\n\n\txemaclite_writel((byte_count & XEL_TPLR_LENGTH_MASK),\n\t\t\t addr + XEL_TPLR_OFFSET);\n\n\t \n\treg_data = xemaclite_readl(addr + XEL_TSR_OFFSET);\n\treg_data |= (XEL_TSR_XMIT_BUSY_MASK | XEL_TSR_XMIT_ACTIVE_MASK);\n\txemaclite_writel(reg_data, addr + XEL_TSR_OFFSET);\n\n\treturn 0;\n}\n\n \nstatic u16 xemaclite_recv_data(struct net_local *drvdata, u8 *data, int maxlen)\n{\n\tvoid __iomem *addr;\n\tu16 length, proto_type;\n\tu32 reg_data;\n\n\t \n\taddr = (drvdata->base_addr + drvdata->next_rx_buf_to_use);\n\n\t \n\treg_data = xemaclite_readl(addr + XEL_RSR_OFFSET);\n\n\tif ((reg_data & XEL_RSR_RECV_DONE_MASK) == XEL_RSR_RECV_DONE_MASK) {\n\t\tif (drvdata->rx_ping_pong != 0)\n\t\t\tdrvdata->next_rx_buf_to_use ^= XEL_BUFFER_OFFSET;\n\t} else {\n\t\t \n\t\tif (drvdata->rx_ping_pong != 0)\n\t\t\taddr = (void __iomem __force *)\n\t\t\t\t((uintptr_t __force)addr ^\n\t\t\t\t XEL_BUFFER_OFFSET);\n\t\telse\n\t\t\treturn 0;\t \n\n\t\t \n\t\treg_data = xemaclite_readl(addr + XEL_RSR_OFFSET);\n\t\tif ((reg_data & XEL_RSR_RECV_DONE_MASK) !=\n\t\t     XEL_RSR_RECV_DONE_MASK)\n\t\t\treturn 0;\t \n\t}\n\n\t \n\tproto_type = ((ntohl(xemaclite_readl(addr + XEL_HEADER_OFFSET +\n\t\t\tXEL_RXBUFF_OFFSET)) >> XEL_HEADER_SHIFT) &\n\t\t\tXEL_RPLR_LENGTH_MASK);\n\n\t \n\tif (proto_type > ETH_DATA_LEN) {\n\t\tif (proto_type == ETH_P_IP) {\n\t\t\tlength = ((ntohl(xemaclite_readl(addr +\n\t\t\t\t\tXEL_HEADER_IP_LENGTH_OFFSET +\n\t\t\t\t\tXEL_RXBUFF_OFFSET)) >>\n\t\t\t\t\tXEL_HEADER_SHIFT) &\n\t\t\t\t\tXEL_RPLR_LENGTH_MASK);\n\t\t\tlength = min_t(u16, length, ETH_DATA_LEN);\n\t\t\tlength += ETH_HLEN + ETH_FCS_LEN;\n\n\t\t} else if (proto_type == ETH_P_ARP) {\n\t\t\tlength = XEL_ARP_PACKET_SIZE + ETH_HLEN + ETH_FCS_LEN;\n\t\t} else {\n\t\t\t \n\t\t\tlength = ETH_FRAME_LEN + ETH_FCS_LEN;\n\t\t}\n\t} else {\n\t\t \n\t\tlength = proto_type + ETH_HLEN + ETH_FCS_LEN;\n\t}\n\n\tif (WARN_ON(length > maxlen))\n\t\tlength = maxlen;\n\n\t \n\txemaclite_aligned_read((u32 __force *)(addr + XEL_RXBUFF_OFFSET),\n\t\t\t       data, length);\n\n\t \n\treg_data = xemaclite_readl(addr + XEL_RSR_OFFSET);\n\treg_data &= ~XEL_RSR_RECV_DONE_MASK;\n\txemaclite_writel(reg_data, addr + XEL_RSR_OFFSET);\n\n\treturn length;\n}\n\n \nstatic void xemaclite_update_address(struct net_local *drvdata,\n\t\t\t\t     const u8 *address_ptr)\n{\n\tvoid __iomem *addr;\n\tu32 reg_data;\n\n\t \n\taddr = drvdata->base_addr + drvdata->next_tx_buf_to_use;\n\n\txemaclite_aligned_write(address_ptr, (u32 __force *)addr, ETH_ALEN);\n\n\txemaclite_writel(ETH_ALEN, addr + XEL_TPLR_OFFSET);\n\n\t \n\treg_data = xemaclite_readl(addr + XEL_TSR_OFFSET);\n\txemaclite_writel(reg_data | XEL_TSR_PROG_MAC_ADDR, addr + XEL_TSR_OFFSET);\n\n\t \n\twhile ((xemaclite_readl(addr + XEL_TSR_OFFSET) &\n\t\tXEL_TSR_PROG_MAC_ADDR) != 0)\n\t\t;\n}\n\n \nstatic int xemaclite_set_mac_address(struct net_device *dev, void *address)\n{\n\tstruct net_local *lp = netdev_priv(dev);\n\tstruct sockaddr *addr = address;\n\n\tif (netif_running(dev))\n\t\treturn -EBUSY;\n\n\teth_hw_addr_set(dev, addr->sa_data);\n\txemaclite_update_address(lp, dev->dev_addr);\n\treturn 0;\n}\n\n \nstatic void xemaclite_tx_timeout(struct net_device *dev, unsigned int txqueue)\n{\n\tstruct net_local *lp = netdev_priv(dev);\n\tunsigned long flags;\n\n\tdev_err(&lp->ndev->dev, \"Exceeded transmit timeout of %lu ms\\n\",\n\t\tTX_TIMEOUT * 1000UL / HZ);\n\n\tdev->stats.tx_errors++;\n\n\t \n\tspin_lock_irqsave(&lp->reset_lock, flags);\n\n\t \n\tnetif_stop_queue(dev);\n\n\txemaclite_disable_interrupts(lp);\n\txemaclite_enable_interrupts(lp);\n\n\tif (lp->deferred_skb) {\n\t\tdev_kfree_skb_irq(lp->deferred_skb);\n\t\tlp->deferred_skb = NULL;\n\t\tdev->stats.tx_errors++;\n\t}\n\n\t \n\tnetif_trans_update(dev);  \n\n\t \n\tnetif_wake_queue(dev);\n\tspin_unlock_irqrestore(&lp->reset_lock, flags);\n}\n\n \n \n \n\n \nstatic void xemaclite_tx_handler(struct net_device *dev)\n{\n\tstruct net_local *lp = netdev_priv(dev);\n\n\tdev->stats.tx_packets++;\n\n\tif (!lp->deferred_skb)\n\t\treturn;\n\n\tif (xemaclite_send_data(lp, (u8 *)lp->deferred_skb->data,\n\t\t\t\tlp->deferred_skb->len))\n\t\treturn;\n\n\tdev->stats.tx_bytes += lp->deferred_skb->len;\n\tdev_consume_skb_irq(lp->deferred_skb);\n\tlp->deferred_skb = NULL;\n\tnetif_trans_update(dev);  \n\tnetif_wake_queue(dev);\n}\n\n \nstatic void xemaclite_rx_handler(struct net_device *dev)\n{\n\tstruct net_local *lp = netdev_priv(dev);\n\tstruct sk_buff *skb;\n\tu32 len;\n\n\tlen = ETH_FRAME_LEN + ETH_FCS_LEN;\n\tskb = netdev_alloc_skb(dev, len + NET_IP_ALIGN);\n\tif (!skb) {\n\t\t \n\t\tdev->stats.rx_dropped++;\n\t\tdev_err(&lp->ndev->dev, \"Could not allocate receive buffer\\n\");\n\t\treturn;\n\t}\n\n\tskb_reserve(skb, NET_IP_ALIGN);\n\n\tlen = xemaclite_recv_data(lp, (u8 *)skb->data, len);\n\n\tif (!len) {\n\t\tdev->stats.rx_errors++;\n\t\tdev_kfree_skb_irq(skb);\n\t\treturn;\n\t}\n\n\tskb_put(skb, len);\t \n\n\tskb->protocol = eth_type_trans(skb, dev);\n\tskb_checksum_none_assert(skb);\n\n\tdev->stats.rx_packets++;\n\tdev->stats.rx_bytes += len;\n\n\tif (!skb_defer_rx_timestamp(skb))\n\t\tnetif_rx(skb);\t \n}\n\n \nstatic irqreturn_t xemaclite_interrupt(int irq, void *dev_id)\n{\n\tbool tx_complete = false;\n\tstruct net_device *dev = dev_id;\n\tstruct net_local *lp = netdev_priv(dev);\n\tvoid __iomem *base_addr = lp->base_addr;\n\tu32 tx_status;\n\n\t \n\tif ((xemaclite_readl(base_addr + XEL_RSR_OFFSET) &\n\t\t\t XEL_RSR_RECV_DONE_MASK) ||\n\t    (xemaclite_readl(base_addr + XEL_BUFFER_OFFSET + XEL_RSR_OFFSET)\n\t\t\t & XEL_RSR_RECV_DONE_MASK))\n\n\t\txemaclite_rx_handler(dev);\n\n\t \n\ttx_status = xemaclite_readl(base_addr + XEL_TSR_OFFSET);\n\tif (((tx_status & XEL_TSR_XMIT_BUSY_MASK) == 0) &&\n\t    (tx_status & XEL_TSR_XMIT_ACTIVE_MASK) != 0) {\n\t\ttx_status &= ~XEL_TSR_XMIT_ACTIVE_MASK;\n\t\txemaclite_writel(tx_status, base_addr + XEL_TSR_OFFSET);\n\n\t\ttx_complete = true;\n\t}\n\n\t \n\ttx_status = xemaclite_readl(base_addr + XEL_BUFFER_OFFSET + XEL_TSR_OFFSET);\n\tif (((tx_status & XEL_TSR_XMIT_BUSY_MASK) == 0) &&\n\t    (tx_status & XEL_TSR_XMIT_ACTIVE_MASK) != 0) {\n\t\ttx_status &= ~XEL_TSR_XMIT_ACTIVE_MASK;\n\t\txemaclite_writel(tx_status, base_addr + XEL_BUFFER_OFFSET +\n\t\t\t\t XEL_TSR_OFFSET);\n\n\t\ttx_complete = true;\n\t}\n\n\t \n\tif (tx_complete != 0)\n\t\txemaclite_tx_handler(dev);\n\n\treturn IRQ_HANDLED;\n}\n\n \n \n \n\n \n\nstatic int xemaclite_mdio_wait(struct net_local *lp)\n{\n\tu32 val;\n\n\t \n\treturn readx_poll_timeout(xemaclite_readl,\n\t\t\t\t  lp->base_addr + XEL_MDIOCTRL_OFFSET,\n\t\t\t\t  val, !(val & XEL_MDIOCTRL_MDIOSTS_MASK),\n\t\t\t\t  1000, 20000);\n}\n\n \nstatic int xemaclite_mdio_read(struct mii_bus *bus, int phy_id, int reg)\n{\n\tstruct net_local *lp = bus->priv;\n\tu32 ctrl_reg;\n\tu32 rc;\n\n\tif (xemaclite_mdio_wait(lp))\n\t\treturn -ETIMEDOUT;\n\n\t \n\tctrl_reg = xemaclite_readl(lp->base_addr + XEL_MDIOCTRL_OFFSET);\n\txemaclite_writel(XEL_MDIOADDR_OP_MASK |\n\t\t\t ((phy_id << XEL_MDIOADDR_PHYADR_SHIFT) | reg),\n\t\t\t lp->base_addr + XEL_MDIOADDR_OFFSET);\n\txemaclite_writel(ctrl_reg | XEL_MDIOCTRL_MDIOSTS_MASK,\n\t\t\t lp->base_addr + XEL_MDIOCTRL_OFFSET);\n\n\tif (xemaclite_mdio_wait(lp))\n\t\treturn -ETIMEDOUT;\n\n\trc = xemaclite_readl(lp->base_addr + XEL_MDIORD_OFFSET);\n\n\tdev_dbg(&lp->ndev->dev,\n\t\t\"%s(phy_id=%i, reg=%x) == %x\\n\", __func__,\n\t\tphy_id, reg, rc);\n\n\treturn rc;\n}\n\n \nstatic int xemaclite_mdio_write(struct mii_bus *bus, int phy_id, int reg,\n\t\t\t\tu16 val)\n{\n\tstruct net_local *lp = bus->priv;\n\tu32 ctrl_reg;\n\n\tdev_dbg(&lp->ndev->dev,\n\t\t\"%s(phy_id=%i, reg=%x, val=%x)\\n\", __func__,\n\t\tphy_id, reg, val);\n\n\tif (xemaclite_mdio_wait(lp))\n\t\treturn -ETIMEDOUT;\n\n\t \n\tctrl_reg = xemaclite_readl(lp->base_addr + XEL_MDIOCTRL_OFFSET);\n\txemaclite_writel(~XEL_MDIOADDR_OP_MASK &\n\t\t\t ((phy_id << XEL_MDIOADDR_PHYADR_SHIFT) | reg),\n\t\t\t lp->base_addr + XEL_MDIOADDR_OFFSET);\n\txemaclite_writel(val, lp->base_addr + XEL_MDIOWR_OFFSET);\n\txemaclite_writel(ctrl_reg | XEL_MDIOCTRL_MDIOSTS_MASK,\n\t\t\t lp->base_addr + XEL_MDIOCTRL_OFFSET);\n\n\treturn 0;\n}\n\n \nstatic int xemaclite_mdio_setup(struct net_local *lp, struct device *dev)\n{\n\tstruct mii_bus *bus;\n\tstruct resource res;\n\tstruct device_node *np = of_get_parent(lp->phy_node);\n\tstruct device_node *npp;\n\tint rc, ret;\n\n\t \n\tif (!np) {\n\t\tdev_err(dev, \"Failed to register mdio bus.\\n\");\n\t\treturn -ENODEV;\n\t}\n\tnpp = of_get_parent(np);\n\tret = of_address_to_resource(npp, 0, &res);\n\tof_node_put(npp);\n\tif (ret) {\n\t\tdev_err(dev, \"%s resource error!\\n\",\n\t\t\tdev->of_node->full_name);\n\t\tof_node_put(np);\n\t\treturn ret;\n\t}\n\tif (lp->ndev->mem_start != res.start) {\n\t\tstruct phy_device *phydev;\n\n\t\tphydev = of_phy_find_device(lp->phy_node);\n\t\tif (!phydev)\n\t\t\tdev_info(dev,\n\t\t\t\t \"MDIO of the phy is not registered yet\\n\");\n\t\telse\n\t\t\tput_device(&phydev->mdio.dev);\n\t\tof_node_put(np);\n\t\treturn 0;\n\t}\n\n\t \n\txemaclite_writel(XEL_MDIOCTRL_MDIOEN_MASK,\n\t\t\t lp->base_addr + XEL_MDIOCTRL_OFFSET);\n\n\tbus = mdiobus_alloc();\n\tif (!bus) {\n\t\tdev_err(dev, \"Failed to allocate mdiobus\\n\");\n\t\tof_node_put(np);\n\t\treturn -ENOMEM;\n\t}\n\n\tsnprintf(bus->id, MII_BUS_ID_SIZE, \"%.8llx\",\n\t\t (unsigned long long)res.start);\n\tbus->priv = lp;\n\tbus->name = \"Xilinx Emaclite MDIO\";\n\tbus->read = xemaclite_mdio_read;\n\tbus->write = xemaclite_mdio_write;\n\tbus->parent = dev;\n\n\trc = of_mdiobus_register(bus, np);\n\tof_node_put(np);\n\tif (rc) {\n\t\tdev_err(dev, \"Failed to register mdio bus.\\n\");\n\t\tgoto err_register;\n\t}\n\n\tlp->mii_bus = bus;\n\n\treturn 0;\n\nerr_register:\n\tmdiobus_free(bus);\n\treturn rc;\n}\n\n \nstatic void xemaclite_adjust_link(struct net_device *ndev)\n{\n\tstruct net_local *lp = netdev_priv(ndev);\n\tstruct phy_device *phy = lp->phy_dev;\n\tint link_state;\n\n\t \n\tlink_state = phy->speed | (phy->duplex << 1) | phy->link;\n\n\tif (lp->last_link != link_state) {\n\t\tlp->last_link = link_state;\n\t\tphy_print_status(phy);\n\t}\n}\n\n \nstatic int xemaclite_open(struct net_device *dev)\n{\n\tstruct net_local *lp = netdev_priv(dev);\n\tint retval;\n\n\t \n\txemaclite_disable_interrupts(lp);\n\n\tif (lp->phy_node) {\n\t\tlp->phy_dev = of_phy_connect(lp->ndev, lp->phy_node,\n\t\t\t\t\t     xemaclite_adjust_link, 0,\n\t\t\t\t\t     PHY_INTERFACE_MODE_MII);\n\t\tif (!lp->phy_dev) {\n\t\t\tdev_err(&lp->ndev->dev, \"of_phy_connect() failed\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\t \n\t\tphy_set_max_speed(lp->phy_dev, SPEED_100);\n\t\tphy_start(lp->phy_dev);\n\t}\n\n\t \n\txemaclite_update_address(lp, dev->dev_addr);\n\n\t \n\tretval = request_irq(dev->irq, xemaclite_interrupt, 0, dev->name, dev);\n\tif (retval) {\n\t\tdev_err(&lp->ndev->dev, \"Could not allocate interrupt %d\\n\",\n\t\t\tdev->irq);\n\t\tif (lp->phy_dev)\n\t\t\tphy_disconnect(lp->phy_dev);\n\t\tlp->phy_dev = NULL;\n\n\t\treturn retval;\n\t}\n\n\t \n\txemaclite_enable_interrupts(lp);\n\n\t \n\tnetif_start_queue(dev);\n\n\treturn 0;\n}\n\n \nstatic int xemaclite_close(struct net_device *dev)\n{\n\tstruct net_local *lp = netdev_priv(dev);\n\n\tnetif_stop_queue(dev);\n\txemaclite_disable_interrupts(lp);\n\tfree_irq(dev->irq, dev);\n\n\tif (lp->phy_dev)\n\t\tphy_disconnect(lp->phy_dev);\n\tlp->phy_dev = NULL;\n\n\treturn 0;\n}\n\n \nstatic netdev_tx_t\nxemaclite_send(struct sk_buff *orig_skb, struct net_device *dev)\n{\n\tstruct net_local *lp = netdev_priv(dev);\n\tstruct sk_buff *new_skb;\n\tunsigned int len;\n\tunsigned long flags;\n\n\tlen = orig_skb->len;\n\n\tnew_skb = orig_skb;\n\n\tspin_lock_irqsave(&lp->reset_lock, flags);\n\tif (xemaclite_send_data(lp, (u8 *)new_skb->data, len) != 0) {\n\t\t \n\t\tnetif_stop_queue(dev);\n\t\tlp->deferred_skb = new_skb;\n\t\t \n\t\tskb_tx_timestamp(new_skb);\n\t\tspin_unlock_irqrestore(&lp->reset_lock, flags);\n\t\treturn NETDEV_TX_OK;\n\t}\n\tspin_unlock_irqrestore(&lp->reset_lock, flags);\n\n\tskb_tx_timestamp(new_skb);\n\n\tdev->stats.tx_bytes += len;\n\tdev_consume_skb_any(new_skb);\n\n\treturn NETDEV_TX_OK;\n}\n\n \nstatic bool get_bool(struct platform_device *ofdev, const char *s)\n{\n\tu32 *p = (u32 *)of_get_property(ofdev->dev.of_node, s, NULL);\n\n\tif (!p) {\n\t\tdev_warn(&ofdev->dev, \"Parameter %s not found, defaulting to false\\n\", s);\n\t\treturn false;\n\t}\n\n\treturn (bool)*p;\n}\n\n \nstatic void xemaclite_ethtools_get_drvinfo(struct net_device *ndev,\n\t\t\t\t\t   struct ethtool_drvinfo *ed)\n{\n\tstrscpy(ed->driver, DRIVER_NAME, sizeof(ed->driver));\n}\n\nstatic const struct ethtool_ops xemaclite_ethtool_ops = {\n\t.get_drvinfo    = xemaclite_ethtools_get_drvinfo,\n\t.get_link       = ethtool_op_get_link,\n\t.get_link_ksettings = phy_ethtool_get_link_ksettings,\n\t.set_link_ksettings = phy_ethtool_set_link_ksettings,\n};\n\nstatic const struct net_device_ops xemaclite_netdev_ops;\n\n \nstatic int xemaclite_of_probe(struct platform_device *ofdev)\n{\n\tstruct resource *res;\n\tstruct net_device *ndev = NULL;\n\tstruct net_local *lp = NULL;\n\tstruct device *dev = &ofdev->dev;\n\n\tint rc = 0;\n\n\tdev_info(dev, \"Device Tree Probing\\n\");\n\n\t \n\tndev = alloc_etherdev(sizeof(struct net_local));\n\tif (!ndev)\n\t\treturn -ENOMEM;\n\n\tdev_set_drvdata(dev, ndev);\n\tSET_NETDEV_DEV(ndev, &ofdev->dev);\n\n\tlp = netdev_priv(ndev);\n\tlp->ndev = ndev;\n\n\t \n\trc = platform_get_irq(ofdev, 0);\n\tif (rc < 0)\n\t\tgoto error;\n\n\tndev->irq = rc;\n\n\tres = platform_get_resource(ofdev, IORESOURCE_MEM, 0);\n\tlp->base_addr = devm_ioremap_resource(&ofdev->dev, res);\n\tif (IS_ERR(lp->base_addr)) {\n\t\trc = PTR_ERR(lp->base_addr);\n\t\tgoto error;\n\t}\n\n\tndev->mem_start = res->start;\n\tndev->mem_end = res->end;\n\n\tspin_lock_init(&lp->reset_lock);\n\tlp->next_tx_buf_to_use = 0x0;\n\tlp->next_rx_buf_to_use = 0x0;\n\tlp->tx_ping_pong = get_bool(ofdev, \"xlnx,tx-ping-pong\");\n\tlp->rx_ping_pong = get_bool(ofdev, \"xlnx,rx-ping-pong\");\n\n\trc = of_get_ethdev_address(ofdev->dev.of_node, ndev);\n\tif (rc) {\n\t\tdev_warn(dev, \"No MAC address found, using random\\n\");\n\t\teth_hw_addr_random(ndev);\n\t}\n\n\t \n\txemaclite_writel(0, lp->base_addr + XEL_TSR_OFFSET);\n\txemaclite_writel(0, lp->base_addr + XEL_BUFFER_OFFSET + XEL_TSR_OFFSET);\n\n\t \n\txemaclite_update_address(lp, ndev->dev_addr);\n\n\tlp->phy_node = of_parse_phandle(ofdev->dev.of_node, \"phy-handle\", 0);\n\txemaclite_mdio_setup(lp, &ofdev->dev);\n\n\tdev_info(dev, \"MAC address is now %pM\\n\", ndev->dev_addr);\n\n\tndev->netdev_ops = &xemaclite_netdev_ops;\n\tndev->ethtool_ops = &xemaclite_ethtool_ops;\n\tndev->flags &= ~IFF_MULTICAST;\n\tndev->watchdog_timeo = TX_TIMEOUT;\n\n\t \n\trc = register_netdev(ndev);\n\tif (rc) {\n\t\tdev_err(dev,\n\t\t\t\"Cannot register network device, aborting\\n\");\n\t\tgoto put_node;\n\t}\n\n\tdev_info(dev,\n\t\t \"Xilinx EmacLite at 0x%08lX mapped to 0x%p, irq=%d\\n\",\n\t\t (unsigned long __force)ndev->mem_start, lp->base_addr, ndev->irq);\n\treturn 0;\n\nput_node:\n\tof_node_put(lp->phy_node);\nerror:\n\tfree_netdev(ndev);\n\treturn rc;\n}\n\n \nstatic int xemaclite_of_remove(struct platform_device *of_dev)\n{\n\tstruct net_device *ndev = platform_get_drvdata(of_dev);\n\n\tstruct net_local *lp = netdev_priv(ndev);\n\n\t \n\tif (lp->mii_bus) {\n\t\tmdiobus_unregister(lp->mii_bus);\n\t\tmdiobus_free(lp->mii_bus);\n\t\tlp->mii_bus = NULL;\n\t}\n\n\tunregister_netdev(ndev);\n\n\tof_node_put(lp->phy_node);\n\tlp->phy_node = NULL;\n\n\tfree_netdev(ndev);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_NET_POLL_CONTROLLER\nstatic void\nxemaclite_poll_controller(struct net_device *ndev)\n{\n\tdisable_irq(ndev->irq);\n\txemaclite_interrupt(ndev->irq, ndev);\n\tenable_irq(ndev->irq);\n}\n#endif\n\n \nstatic int xemaclite_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)\n{\n\tif (!dev->phydev || !netif_running(dev))\n\t\treturn -EINVAL;\n\n\tswitch (cmd) {\n\tcase SIOCGMIIPHY:\n\tcase SIOCGMIIREG:\n\tcase SIOCSMIIREG:\n\t\treturn phy_mii_ioctl(dev->phydev, rq, cmd);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic const struct net_device_ops xemaclite_netdev_ops = {\n\t.ndo_open\t\t= xemaclite_open,\n\t.ndo_stop\t\t= xemaclite_close,\n\t.ndo_start_xmit\t\t= xemaclite_send,\n\t.ndo_set_mac_address\t= xemaclite_set_mac_address,\n\t.ndo_tx_timeout\t\t= xemaclite_tx_timeout,\n\t.ndo_eth_ioctl\t\t= xemaclite_ioctl,\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\t.ndo_poll_controller = xemaclite_poll_controller,\n#endif\n};\n\n \nstatic const struct of_device_id xemaclite_of_match[] = {\n\t{ .compatible = \"xlnx,opb-ethernetlite-1.01.a\", },\n\t{ .compatible = \"xlnx,opb-ethernetlite-1.01.b\", },\n\t{ .compatible = \"xlnx,xps-ethernetlite-1.00.a\", },\n\t{ .compatible = \"xlnx,xps-ethernetlite-2.00.a\", },\n\t{ .compatible = \"xlnx,xps-ethernetlite-2.01.a\", },\n\t{ .compatible = \"xlnx,xps-ethernetlite-3.00.a\", },\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, xemaclite_of_match);\n\nstatic struct platform_driver xemaclite_of_driver = {\n\t.driver = {\n\t\t.name = DRIVER_NAME,\n\t\t.of_match_table = xemaclite_of_match,\n\t},\n\t.probe\t\t= xemaclite_of_probe,\n\t.remove\t\t= xemaclite_of_remove,\n};\n\nmodule_platform_driver(xemaclite_of_driver);\n\nMODULE_AUTHOR(\"Xilinx, Inc.\");\nMODULE_DESCRIPTION(\"Xilinx Ethernet MAC Lite driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}