{
  "module_name": "ionic_dev.c",
  "hash_id": "54cc8ee581fecc4e7cc8bd3438ff500375ae4bcceae1eac968bb5285744dd531",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/pensando/ionic/ionic_dev.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/errno.h>\n#include <linux/io.h>\n#include <linux/slab.h>\n#include <linux/etherdevice.h>\n#include \"ionic.h\"\n#include \"ionic_dev.h\"\n#include \"ionic_lif.h\"\n\nstatic void ionic_watchdog_cb(struct timer_list *t)\n{\n\tstruct ionic *ionic = from_timer(ionic, t, watchdog_timer);\n\tstruct ionic_lif *lif = ionic->lif;\n\tstruct ionic_deferred_work *work;\n\tint hb;\n\n\tmod_timer(&ionic->watchdog_timer,\n\t\t  round_jiffies(jiffies + ionic->watchdog_period));\n\n\tif (!lif)\n\t\treturn;\n\n\thb = ionic_heartbeat_check(ionic);\n\tdev_dbg(ionic->dev, \"%s: hb %d running %d UP %d\\n\",\n\t\t__func__, hb, netif_running(lif->netdev),\n\t\ttest_bit(IONIC_LIF_F_UP, lif->state));\n\n\tif (hb >= 0 &&\n\t    !test_bit(IONIC_LIF_F_FW_RESET, lif->state))\n\t\tionic_link_status_check_request(lif, CAN_NOT_SLEEP);\n\n\tif (test_bit(IONIC_LIF_F_FILTER_SYNC_NEEDED, lif->state) &&\n\t    !test_bit(IONIC_LIF_F_FW_RESET, lif->state)) {\n\t\twork = kzalloc(sizeof(*work), GFP_ATOMIC);\n\t\tif (!work) {\n\t\t\tnetdev_err(lif->netdev, \"rxmode change dropped\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\twork->type = IONIC_DW_TYPE_RX_MODE;\n\t\tnetdev_dbg(lif->netdev, \"deferred: rx_mode\\n\");\n\t\tionic_lif_deferred_enqueue(&lif->deferred, work);\n\t}\n}\n\nstatic void ionic_watchdog_init(struct ionic *ionic)\n{\n\tstruct ionic_dev *idev = &ionic->idev;\n\n\ttimer_setup(&ionic->watchdog_timer, ionic_watchdog_cb, 0);\n\tionic->watchdog_period = IONIC_WATCHDOG_SECS * HZ;\n\n\t \n\tatomic_long_set(&idev->last_check_time, jiffies - 2 * HZ);\n\tidev->last_hb_time = jiffies - 2 * ionic->watchdog_period;\n\t \n\tidev->last_fw_hb = 0;\n\tidev->fw_hb_ready = true;\n\tidev->fw_status_ready = true;\n\tidev->fw_generation = IONIC_FW_STS_F_GENERATION &\n\t\t\t      ioread8(&idev->dev_info_regs->fw_status);\n}\n\nvoid ionic_init_devinfo(struct ionic *ionic)\n{\n\tstruct ionic_dev *idev = &ionic->idev;\n\n\tidev->dev_info.asic_type = ioread8(&idev->dev_info_regs->asic_type);\n\tidev->dev_info.asic_rev = ioread8(&idev->dev_info_regs->asic_rev);\n\n\tmemcpy_fromio(idev->dev_info.fw_version,\n\t\t      idev->dev_info_regs->fw_version,\n\t\t      IONIC_DEVINFO_FWVERS_BUFLEN);\n\n\tmemcpy_fromio(idev->dev_info.serial_num,\n\t\t      idev->dev_info_regs->serial_num,\n\t\t      IONIC_DEVINFO_SERIAL_BUFLEN);\n\n\tidev->dev_info.fw_version[IONIC_DEVINFO_FWVERS_BUFLEN] = 0;\n\tidev->dev_info.serial_num[IONIC_DEVINFO_SERIAL_BUFLEN] = 0;\n\n\tdev_dbg(ionic->dev, \"fw_version %s\\n\", idev->dev_info.fw_version);\n}\n\nint ionic_dev_setup(struct ionic *ionic)\n{\n\tstruct ionic_dev_bar *bar = ionic->bars;\n\tunsigned int num_bars = ionic->num_bars;\n\tstruct ionic_dev *idev = &ionic->idev;\n\tstruct device *dev = ionic->dev;\n\tint size;\n\tu32 sig;\n\n\t \n\tif (num_bars < 1) {\n\t\tdev_err(dev, \"No bars found, aborting\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\tif (bar->len < IONIC_BAR0_SIZE) {\n\t\tdev_err(dev, \"Resource bar size %lu too small, aborting\\n\",\n\t\t\tbar->len);\n\t\treturn -EFAULT;\n\t}\n\n\tidev->dev_info_regs = bar->vaddr + IONIC_BAR0_DEV_INFO_REGS_OFFSET;\n\tidev->dev_cmd_regs = bar->vaddr + IONIC_BAR0_DEV_CMD_REGS_OFFSET;\n\tidev->intr_status = bar->vaddr + IONIC_BAR0_INTR_STATUS_OFFSET;\n\tidev->intr_ctrl = bar->vaddr + IONIC_BAR0_INTR_CTRL_OFFSET;\n\n\tidev->hwstamp_regs = &idev->dev_info_regs->hwstamp;\n\n\tsig = ioread32(&idev->dev_info_regs->signature);\n\tif (sig != IONIC_DEV_INFO_SIGNATURE) {\n\t\tdev_err(dev, \"Incompatible firmware signature %x\", sig);\n\t\treturn -EFAULT;\n\t}\n\n\tionic_init_devinfo(ionic);\n\n\t \n\tbar++;\n\tif (num_bars < 2) {\n\t\tdev_err(dev, \"Doorbell bar missing, aborting\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\tionic_watchdog_init(ionic);\n\n\tidev->db_pages = bar->vaddr;\n\tidev->phy_db_pages = bar->bus_addr;\n\n\t \n\tbar++;\n\tmutex_init(&idev->cmb_inuse_lock);\n\tif (num_bars < 3 || !ionic->bars[IONIC_PCI_BAR_CMB].len) {\n\t\tidev->cmb_inuse = NULL;\n\t\treturn 0;\n\t}\n\n\tidev->phy_cmb_pages = bar->bus_addr;\n\tidev->cmb_npages = bar->len / PAGE_SIZE;\n\tsize = BITS_TO_LONGS(idev->cmb_npages) * sizeof(long);\n\tidev->cmb_inuse = kzalloc(size, GFP_KERNEL);\n\tif (!idev->cmb_inuse)\n\t\tdev_warn(dev, \"No memory for CMB, disabling\\n\");\n\n\treturn 0;\n}\n\nvoid ionic_dev_teardown(struct ionic *ionic)\n{\n\tstruct ionic_dev *idev = &ionic->idev;\n\n\tkfree(idev->cmb_inuse);\n\tidev->cmb_inuse = NULL;\n\tidev->phy_cmb_pages = 0;\n\tidev->cmb_npages = 0;\n\n\tmutex_destroy(&idev->cmb_inuse_lock);\n}\n\n \nbool ionic_is_fw_running(struct ionic_dev *idev)\n{\n\tu8 fw_status = ioread8(&idev->dev_info_regs->fw_status);\n\n\t \n\treturn (fw_status != 0xff) && (fw_status & IONIC_FW_STS_F_RUNNING);\n}\n\nint ionic_heartbeat_check(struct ionic *ionic)\n{\n\tunsigned long check_time, last_check_time;\n\tstruct ionic_dev *idev = &ionic->idev;\n\tstruct ionic_lif *lif = ionic->lif;\n\tbool fw_status_ready = true;\n\tbool fw_hb_ready;\n\tu8 fw_generation;\n\tu8 fw_status;\n\tu32 fw_hb;\n\n\t \n\tcheck_time = jiffies;\n\tlast_check_time = atomic_long_read(&idev->last_check_time);\ndo_check_time:\n\tif (time_before(check_time, last_check_time + HZ))\n\t\treturn 0;\n\tif (!atomic_long_try_cmpxchg_relaxed(&idev->last_check_time,\n\t\t\t\t\t     &last_check_time, check_time)) {\n\t\t \n\t\tdev_dbg(ionic->dev, \"%s: do_check_time again\\n\", __func__);\n\t\tgoto do_check_time;\n\t}\n\n\tfw_status = ioread8(&idev->dev_info_regs->fw_status);\n\n\t \n\tif (!ionic_is_fw_running(idev)) {\n\t\tfw_status_ready = false;\n\t} else {\n\t\tfw_generation = fw_status & IONIC_FW_STS_F_GENERATION;\n\t\tif (idev->fw_generation != fw_generation) {\n\t\t\tdev_info(ionic->dev, \"FW generation 0x%02x -> 0x%02x\\n\",\n\t\t\t\t idev->fw_generation, fw_generation);\n\n\t\t\tidev->fw_generation = fw_generation;\n\n\t\t\t \n\t\t\tif (test_bit(IONIC_LIF_F_FW_RESET, lif->state))\n\t\t\t\tidev->fw_status_ready = false;\t \n\t\t\telse\n\t\t\t\tfw_status_ready = false;\t \n\t\t}\n\t}\n\n\tdev_dbg(ionic->dev, \"fw_status 0x%02x ready %d idev->ready %d last_hb 0x%x state 0x%02lx\\n\",\n\t\tfw_status, fw_status_ready, idev->fw_status_ready,\n\t\tidev->last_fw_hb, lif->state[0]);\n\n\t \n\tif (fw_status_ready != idev->fw_status_ready &&\n\t    !test_bit(IONIC_LIF_F_FW_STOPPING, lif->state)) {\n\t\tbool trigger = false;\n\n\t\tidev->fw_status_ready = fw_status_ready;\n\n\t\tif (!fw_status_ready &&\n\t\t    !test_bit(IONIC_LIF_F_FW_RESET, lif->state) &&\n\t\t    !test_and_set_bit(IONIC_LIF_F_FW_STOPPING, lif->state)) {\n\t\t\tdev_info(ionic->dev, \"FW stopped 0x%02x\\n\", fw_status);\n\t\t\ttrigger = true;\n\n\t\t} else if (fw_status_ready &&\n\t\t\t   test_bit(IONIC_LIF_F_FW_RESET, lif->state)) {\n\t\t\tdev_info(ionic->dev, \"FW running 0x%02x\\n\", fw_status);\n\t\t\ttrigger = true;\n\t\t}\n\n\t\tif (trigger) {\n\t\t\tstruct ionic_deferred_work *work;\n\n\t\t\twork = kzalloc(sizeof(*work), GFP_ATOMIC);\n\t\t\tif (work) {\n\t\t\t\twork->type = IONIC_DW_TYPE_LIF_RESET;\n\t\t\t\twork->fw_status = fw_status_ready;\n\t\t\t\tionic_lif_deferred_enqueue(&lif->deferred, work);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!idev->fw_status_ready)\n\t\treturn -ENXIO;\n\n\t \n\tlast_check_time = idev->last_hb_time;\n\tif (time_before(check_time, last_check_time + DEVCMD_TIMEOUT * 2 * HZ))\n\t\treturn 0;\n\n\tfw_hb = ioread32(&idev->dev_info_regs->fw_heartbeat);\n\tfw_hb_ready = fw_hb != idev->last_fw_hb;\n\n\t \n\tif (!fw_hb_ready && !fw_hb)\n\t\tfw_hb_ready = true;\n\n\tdev_dbg(ionic->dev, \"%s: fw_hb %u last_fw_hb %u ready %u\\n\",\n\t\t__func__, fw_hb, idev->last_fw_hb, fw_hb_ready);\n\n\tidev->last_fw_hb = fw_hb;\n\n\t \n\tif (fw_hb_ready != idev->fw_hb_ready) {\n\t\tidev->fw_hb_ready = fw_hb_ready;\n\t\tif (!fw_hb_ready)\n\t\t\tdev_info(ionic->dev, \"FW heartbeat stalled at %d\\n\", fw_hb);\n\t\telse\n\t\t\tdev_info(ionic->dev, \"FW heartbeat restored at %d\\n\", fw_hb);\n\t}\n\n\tif (!fw_hb_ready)\n\t\treturn -ENXIO;\n\n\tidev->last_hb_time = check_time;\n\n\treturn 0;\n}\n\nu8 ionic_dev_cmd_status(struct ionic_dev *idev)\n{\n\treturn ioread8(&idev->dev_cmd_regs->comp.comp.status);\n}\n\nbool ionic_dev_cmd_done(struct ionic_dev *idev)\n{\n\treturn ioread32(&idev->dev_cmd_regs->done) & IONIC_DEV_CMD_DONE;\n}\n\nvoid ionic_dev_cmd_comp(struct ionic_dev *idev, union ionic_dev_cmd_comp *comp)\n{\n\tmemcpy_fromio(comp, &idev->dev_cmd_regs->comp, sizeof(*comp));\n}\n\nvoid ionic_dev_cmd_go(struct ionic_dev *idev, union ionic_dev_cmd *cmd)\n{\n\tmemcpy_toio(&idev->dev_cmd_regs->cmd, cmd, sizeof(*cmd));\n\tiowrite32(0, &idev->dev_cmd_regs->done);\n\tiowrite32(1, &idev->dev_cmd_regs->doorbell);\n}\n\n \nvoid ionic_dev_cmd_identify(struct ionic_dev *idev, u8 ver)\n{\n\tunion ionic_dev_cmd cmd = {\n\t\t.identify.opcode = IONIC_CMD_IDENTIFY,\n\t\t.identify.ver = ver,\n\t};\n\n\tionic_dev_cmd_go(idev, &cmd);\n}\n\nvoid ionic_dev_cmd_init(struct ionic_dev *idev)\n{\n\tunion ionic_dev_cmd cmd = {\n\t\t.init.opcode = IONIC_CMD_INIT,\n\t\t.init.type = 0,\n\t};\n\n\tionic_dev_cmd_go(idev, &cmd);\n}\n\nvoid ionic_dev_cmd_reset(struct ionic_dev *idev)\n{\n\tunion ionic_dev_cmd cmd = {\n\t\t.reset.opcode = IONIC_CMD_RESET,\n\t};\n\n\tionic_dev_cmd_go(idev, &cmd);\n}\n\n \nvoid ionic_dev_cmd_port_identify(struct ionic_dev *idev)\n{\n\tunion ionic_dev_cmd cmd = {\n\t\t.port_init.opcode = IONIC_CMD_PORT_IDENTIFY,\n\t\t.port_init.index = 0,\n\t};\n\n\tionic_dev_cmd_go(idev, &cmd);\n}\n\nvoid ionic_dev_cmd_port_init(struct ionic_dev *idev)\n{\n\tunion ionic_dev_cmd cmd = {\n\t\t.port_init.opcode = IONIC_CMD_PORT_INIT,\n\t\t.port_init.index = 0,\n\t\t.port_init.info_pa = cpu_to_le64(idev->port_info_pa),\n\t};\n\n\tionic_dev_cmd_go(idev, &cmd);\n}\n\nvoid ionic_dev_cmd_port_reset(struct ionic_dev *idev)\n{\n\tunion ionic_dev_cmd cmd = {\n\t\t.port_reset.opcode = IONIC_CMD_PORT_RESET,\n\t\t.port_reset.index = 0,\n\t};\n\n\tionic_dev_cmd_go(idev, &cmd);\n}\n\nvoid ionic_dev_cmd_port_state(struct ionic_dev *idev, u8 state)\n{\n\tunion ionic_dev_cmd cmd = {\n\t\t.port_setattr.opcode = IONIC_CMD_PORT_SETATTR,\n\t\t.port_setattr.index = 0,\n\t\t.port_setattr.attr = IONIC_PORT_ATTR_STATE,\n\t\t.port_setattr.state = state,\n\t};\n\n\tionic_dev_cmd_go(idev, &cmd);\n}\n\nvoid ionic_dev_cmd_port_speed(struct ionic_dev *idev, u32 speed)\n{\n\tunion ionic_dev_cmd cmd = {\n\t\t.port_setattr.opcode = IONIC_CMD_PORT_SETATTR,\n\t\t.port_setattr.index = 0,\n\t\t.port_setattr.attr = IONIC_PORT_ATTR_SPEED,\n\t\t.port_setattr.speed = cpu_to_le32(speed),\n\t};\n\n\tionic_dev_cmd_go(idev, &cmd);\n}\n\nvoid ionic_dev_cmd_port_autoneg(struct ionic_dev *idev, u8 an_enable)\n{\n\tunion ionic_dev_cmd cmd = {\n\t\t.port_setattr.opcode = IONIC_CMD_PORT_SETATTR,\n\t\t.port_setattr.index = 0,\n\t\t.port_setattr.attr = IONIC_PORT_ATTR_AUTONEG,\n\t\t.port_setattr.an_enable = an_enable,\n\t};\n\n\tionic_dev_cmd_go(idev, &cmd);\n}\n\nvoid ionic_dev_cmd_port_fec(struct ionic_dev *idev, u8 fec_type)\n{\n\tunion ionic_dev_cmd cmd = {\n\t\t.port_setattr.opcode = IONIC_CMD_PORT_SETATTR,\n\t\t.port_setattr.index = 0,\n\t\t.port_setattr.attr = IONIC_PORT_ATTR_FEC,\n\t\t.port_setattr.fec_type = fec_type,\n\t};\n\n\tionic_dev_cmd_go(idev, &cmd);\n}\n\nvoid ionic_dev_cmd_port_pause(struct ionic_dev *idev, u8 pause_type)\n{\n\tunion ionic_dev_cmd cmd = {\n\t\t.port_setattr.opcode = IONIC_CMD_PORT_SETATTR,\n\t\t.port_setattr.index = 0,\n\t\t.port_setattr.attr = IONIC_PORT_ATTR_PAUSE,\n\t\t.port_setattr.pause_type = pause_type,\n\t};\n\n\tionic_dev_cmd_go(idev, &cmd);\n}\n\n \nint ionic_set_vf_config(struct ionic *ionic, int vf,\n\t\t\tstruct ionic_vf_setattr_cmd *vfc)\n{\n\tunion ionic_dev_cmd cmd = {\n\t\t.vf_setattr.opcode = IONIC_CMD_VF_SETATTR,\n\t\t.vf_setattr.attr = vfc->attr,\n\t\t.vf_setattr.vf_index = cpu_to_le16(vf),\n\t};\n\tint err;\n\n\tmemcpy(cmd.vf_setattr.pad, vfc->pad, sizeof(vfc->pad));\n\n\tmutex_lock(&ionic->dev_cmd_lock);\n\tionic_dev_cmd_go(&ionic->idev, &cmd);\n\terr = ionic_dev_cmd_wait(ionic, DEVCMD_TIMEOUT);\n\tmutex_unlock(&ionic->dev_cmd_lock);\n\n\treturn err;\n}\n\nint ionic_dev_cmd_vf_getattr(struct ionic *ionic, int vf, u8 attr,\n\t\t\t     struct ionic_vf_getattr_comp *comp)\n{\n\tunion ionic_dev_cmd cmd = {\n\t\t.vf_getattr.opcode = IONIC_CMD_VF_GETATTR,\n\t\t.vf_getattr.attr = attr,\n\t\t.vf_getattr.vf_index = cpu_to_le16(vf),\n\t};\n\tint err;\n\n\tif (vf >= ionic->num_vfs)\n\t\treturn -EINVAL;\n\n\tswitch (attr) {\n\tcase IONIC_VF_ATTR_SPOOFCHK:\n\tcase IONIC_VF_ATTR_TRUST:\n\tcase IONIC_VF_ATTR_LINKSTATE:\n\tcase IONIC_VF_ATTR_MAC:\n\tcase IONIC_VF_ATTR_VLAN:\n\tcase IONIC_VF_ATTR_RATE:\n\t\tbreak;\n\tcase IONIC_VF_ATTR_STATSADDR:\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&ionic->dev_cmd_lock);\n\tionic_dev_cmd_go(&ionic->idev, &cmd);\n\terr = ionic_dev_cmd_wait_nomsg(ionic, DEVCMD_TIMEOUT);\n\tmemcpy_fromio(comp, &ionic->idev.dev_cmd_regs->comp.vf_getattr,\n\t\t      sizeof(*comp));\n\tmutex_unlock(&ionic->dev_cmd_lock);\n\n\tif (err && comp->status != IONIC_RC_ENOSUPP)\n\t\tionic_dev_cmd_dev_err_print(ionic, cmd.vf_getattr.opcode,\n\t\t\t\t\t    comp->status, err);\n\n\treturn err;\n}\n\nvoid ionic_vf_start(struct ionic *ionic)\n{\n\tunion ionic_dev_cmd cmd = {\n\t\t.vf_ctrl.opcode = IONIC_CMD_VF_CTRL,\n\t\t.vf_ctrl.ctrl_opcode = IONIC_VF_CTRL_START_ALL,\n\t};\n\n\tif (!(ionic->ident.dev.capabilities & cpu_to_le64(IONIC_DEV_CAP_VF_CTRL)))\n\t\treturn;\n\n\tionic_dev_cmd_go(&ionic->idev, &cmd);\n\tionic_dev_cmd_wait(ionic, DEVCMD_TIMEOUT);\n}\n\n \nvoid ionic_dev_cmd_queue_identify(struct ionic_dev *idev,\n\t\t\t\t  u16 lif_type, u8 qtype, u8 qver)\n{\n\tunion ionic_dev_cmd cmd = {\n\t\t.q_identify.opcode = IONIC_CMD_Q_IDENTIFY,\n\t\t.q_identify.lif_type = cpu_to_le16(lif_type),\n\t\t.q_identify.type = qtype,\n\t\t.q_identify.ver = qver,\n\t};\n\n\tionic_dev_cmd_go(idev, &cmd);\n}\n\nvoid ionic_dev_cmd_lif_identify(struct ionic_dev *idev, u8 type, u8 ver)\n{\n\tunion ionic_dev_cmd cmd = {\n\t\t.lif_identify.opcode = IONIC_CMD_LIF_IDENTIFY,\n\t\t.lif_identify.type = type,\n\t\t.lif_identify.ver = ver,\n\t};\n\n\tionic_dev_cmd_go(idev, &cmd);\n}\n\nvoid ionic_dev_cmd_lif_init(struct ionic_dev *idev, u16 lif_index,\n\t\t\t    dma_addr_t info_pa)\n{\n\tunion ionic_dev_cmd cmd = {\n\t\t.lif_init.opcode = IONIC_CMD_LIF_INIT,\n\t\t.lif_init.index = cpu_to_le16(lif_index),\n\t\t.lif_init.info_pa = cpu_to_le64(info_pa),\n\t};\n\n\tionic_dev_cmd_go(idev, &cmd);\n}\n\nvoid ionic_dev_cmd_lif_reset(struct ionic_dev *idev, u16 lif_index)\n{\n\tunion ionic_dev_cmd cmd = {\n\t\t.lif_init.opcode = IONIC_CMD_LIF_RESET,\n\t\t.lif_init.index = cpu_to_le16(lif_index),\n\t};\n\n\tionic_dev_cmd_go(idev, &cmd);\n}\n\nvoid ionic_dev_cmd_adminq_init(struct ionic_dev *idev, struct ionic_qcq *qcq,\n\t\t\t       u16 lif_index, u16 intr_index)\n{\n\tstruct ionic_queue *q = &qcq->q;\n\tstruct ionic_cq *cq = &qcq->cq;\n\n\tunion ionic_dev_cmd cmd = {\n\t\t.q_init.opcode = IONIC_CMD_Q_INIT,\n\t\t.q_init.lif_index = cpu_to_le16(lif_index),\n\t\t.q_init.type = q->type,\n\t\t.q_init.ver = qcq->q.lif->qtype_info[q->type].version,\n\t\t.q_init.index = cpu_to_le32(q->index),\n\t\t.q_init.flags = cpu_to_le16(IONIC_QINIT_F_IRQ |\n\t\t\t\t\t    IONIC_QINIT_F_ENA),\n\t\t.q_init.pid = cpu_to_le16(q->pid),\n\t\t.q_init.intr_index = cpu_to_le16(intr_index),\n\t\t.q_init.ring_size = ilog2(q->num_descs),\n\t\t.q_init.ring_base = cpu_to_le64(q->base_pa),\n\t\t.q_init.cq_ring_base = cpu_to_le64(cq->base_pa),\n\t};\n\n\tionic_dev_cmd_go(idev, &cmd);\n}\n\nint ionic_db_page_num(struct ionic_lif *lif, int pid)\n{\n\treturn (lif->hw_index * lif->dbid_count) + pid;\n}\n\nint ionic_get_cmb(struct ionic_lif *lif, u32 *pgid, phys_addr_t *pgaddr, int order)\n{\n\tstruct ionic_dev *idev = &lif->ionic->idev;\n\tint ret;\n\n\tmutex_lock(&idev->cmb_inuse_lock);\n\tret = bitmap_find_free_region(idev->cmb_inuse, idev->cmb_npages, order);\n\tmutex_unlock(&idev->cmb_inuse_lock);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*pgid = ret;\n\t*pgaddr = idev->phy_cmb_pages + ret * PAGE_SIZE;\n\n\treturn 0;\n}\n\nvoid ionic_put_cmb(struct ionic_lif *lif, u32 pgid, int order)\n{\n\tstruct ionic_dev *idev = &lif->ionic->idev;\n\n\tmutex_lock(&idev->cmb_inuse_lock);\n\tbitmap_release_region(idev->cmb_inuse, pgid, order);\n\tmutex_unlock(&idev->cmb_inuse_lock);\n}\n\nint ionic_cq_init(struct ionic_lif *lif, struct ionic_cq *cq,\n\t\t  struct ionic_intr_info *intr,\n\t\t  unsigned int num_descs, size_t desc_size)\n{\n\tunsigned int ring_size;\n\n\tif (desc_size == 0 || !is_power_of_2(num_descs))\n\t\treturn -EINVAL;\n\n\tring_size = ilog2(num_descs);\n\tif (ring_size < 2 || ring_size > 16)\n\t\treturn -EINVAL;\n\n\tcq->lif = lif;\n\tcq->bound_intr = intr;\n\tcq->num_descs = num_descs;\n\tcq->desc_size = desc_size;\n\tcq->tail_idx = 0;\n\tcq->done_color = 1;\n\n\treturn 0;\n}\n\nvoid ionic_cq_map(struct ionic_cq *cq, void *base, dma_addr_t base_pa)\n{\n\tstruct ionic_cq_info *cur;\n\tunsigned int i;\n\n\tcq->base = base;\n\tcq->base_pa = base_pa;\n\n\tfor (i = 0, cur = cq->info; i < cq->num_descs; i++, cur++)\n\t\tcur->cq_desc = base + (i * cq->desc_size);\n}\n\nvoid ionic_cq_bind(struct ionic_cq *cq, struct ionic_queue *q)\n{\n\tcq->bound_q = q;\n}\n\nunsigned int ionic_cq_service(struct ionic_cq *cq, unsigned int work_to_do,\n\t\t\t      ionic_cq_cb cb, ionic_cq_done_cb done_cb,\n\t\t\t      void *done_arg)\n{\n\tstruct ionic_cq_info *cq_info;\n\tunsigned int work_done = 0;\n\n\tif (work_to_do == 0)\n\t\treturn 0;\n\n\tcq_info = &cq->info[cq->tail_idx];\n\twhile (cb(cq, cq_info)) {\n\t\tif (cq->tail_idx == cq->num_descs - 1)\n\t\t\tcq->done_color = !cq->done_color;\n\t\tcq->tail_idx = (cq->tail_idx + 1) & (cq->num_descs - 1);\n\t\tcq_info = &cq->info[cq->tail_idx];\n\n\t\tif (++work_done >= work_to_do)\n\t\t\tbreak;\n\t}\n\n\tif (work_done && done_cb)\n\t\tdone_cb(done_arg);\n\n\treturn work_done;\n}\n\nint ionic_q_init(struct ionic_lif *lif, struct ionic_dev *idev,\n\t\t struct ionic_queue *q, unsigned int index, const char *name,\n\t\t unsigned int num_descs, size_t desc_size,\n\t\t size_t sg_desc_size, unsigned int pid)\n{\n\tunsigned int ring_size;\n\n\tif (desc_size == 0 || !is_power_of_2(num_descs))\n\t\treturn -EINVAL;\n\n\tring_size = ilog2(num_descs);\n\tif (ring_size < 2 || ring_size > 16)\n\t\treturn -EINVAL;\n\n\tq->lif = lif;\n\tq->idev = idev;\n\tq->index = index;\n\tq->num_descs = num_descs;\n\tq->desc_size = desc_size;\n\tq->sg_desc_size = sg_desc_size;\n\tq->tail_idx = 0;\n\tq->head_idx = 0;\n\tq->pid = pid;\n\n\tsnprintf(q->name, sizeof(q->name), \"L%d-%s%u\", lif->index, name, index);\n\n\treturn 0;\n}\n\nvoid ionic_q_map(struct ionic_queue *q, void *base, dma_addr_t base_pa)\n{\n\tstruct ionic_desc_info *cur;\n\tunsigned int i;\n\n\tq->base = base;\n\tq->base_pa = base_pa;\n\n\tfor (i = 0, cur = q->info; i < q->num_descs; i++, cur++)\n\t\tcur->desc = base + (i * q->desc_size);\n}\n\nvoid ionic_q_cmb_map(struct ionic_queue *q, void __iomem *base, dma_addr_t base_pa)\n{\n\tstruct ionic_desc_info *cur;\n\tunsigned int i;\n\n\tq->cmb_base = base;\n\tq->cmb_base_pa = base_pa;\n\n\tfor (i = 0, cur = q->info; i < q->num_descs; i++, cur++)\n\t\tcur->cmb_desc = base + (i * q->desc_size);\n}\n\nvoid ionic_q_sg_map(struct ionic_queue *q, void *base, dma_addr_t base_pa)\n{\n\tstruct ionic_desc_info *cur;\n\tunsigned int i;\n\n\tq->sg_base = base;\n\tq->sg_base_pa = base_pa;\n\n\tfor (i = 0, cur = q->info; i < q->num_descs; i++, cur++)\n\t\tcur->sg_desc = base + (i * q->sg_desc_size);\n}\n\nvoid ionic_q_post(struct ionic_queue *q, bool ring_doorbell, ionic_desc_cb cb,\n\t\t  void *cb_arg)\n{\n\tstruct ionic_desc_info *desc_info;\n\tstruct ionic_lif *lif = q->lif;\n\tstruct device *dev = q->dev;\n\n\tdesc_info = &q->info[q->head_idx];\n\tdesc_info->cb = cb;\n\tdesc_info->cb_arg = cb_arg;\n\n\tq->head_idx = (q->head_idx + 1) & (q->num_descs - 1);\n\n\tdev_dbg(dev, \"lif=%d qname=%s qid=%d qtype=%d p_index=%d ringdb=%d\\n\",\n\t\tq->lif->index, q->name, q->hw_type, q->hw_index,\n\t\tq->head_idx, ring_doorbell);\n\n\tif (ring_doorbell) {\n\t\tionic_dbell_ring(lif->kern_dbpage, q->hw_type,\n\t\t\t\t q->dbval | q->head_idx);\n\n\t\tq->dbell_jiffies = jiffies;\n\n\t\tif (q_to_qcq(q)->napi_qcq)\n\t\t\tmod_timer(&q_to_qcq(q)->napi_qcq->napi_deadline,\n\t\t\t\t  jiffies + IONIC_NAPI_DEADLINE);\n\t}\n}\n\nstatic bool ionic_q_is_posted(struct ionic_queue *q, unsigned int pos)\n{\n\tunsigned int mask, tail, head;\n\n\tmask = q->num_descs - 1;\n\ttail = q->tail_idx;\n\thead = q->head_idx;\n\n\treturn ((pos - tail) & mask) < ((head - tail) & mask);\n}\n\nvoid ionic_q_service(struct ionic_queue *q, struct ionic_cq_info *cq_info,\n\t\t     unsigned int stop_index)\n{\n\tstruct ionic_desc_info *desc_info;\n\tionic_desc_cb cb;\n\tvoid *cb_arg;\n\tu16 index;\n\n\t \n\tif (q->tail_idx == q->head_idx)\n\t\treturn;\n\n\t \n\tif (unlikely(!ionic_q_is_posted(q, stop_index)))\n\t\tdev_err(q->dev,\n\t\t\t\"ionic stop is not posted %s stop %u tail %u head %u\\n\",\n\t\t\tq->name, stop_index, q->tail_idx, q->head_idx);\n\n\tdo {\n\t\tdesc_info = &q->info[q->tail_idx];\n\t\tindex = q->tail_idx;\n\t\tq->tail_idx = (q->tail_idx + 1) & (q->num_descs - 1);\n\n\t\tcb = desc_info->cb;\n\t\tcb_arg = desc_info->cb_arg;\n\n\t\tdesc_info->cb = NULL;\n\t\tdesc_info->cb_arg = NULL;\n\n\t\tif (cb)\n\t\t\tcb(q, desc_info, cq_info, cb_arg);\n\t} while (index != stop_index);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}