{
  "module_name": "ionic_phc.c",
  "hash_id": "4c4d2aae60df7fd8c2a6c1c9b2340292fcff7017febcbf34e5941d54131e20c6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/pensando/ionic/ionic_phc.c",
  "human_readable_source": "\n \n\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n\n#include \"ionic.h\"\n#include \"ionic_bus.h\"\n#include \"ionic_lif.h\"\n#include \"ionic_ethtool.h\"\n\nstatic int ionic_hwstamp_tx_mode(int config_tx_type)\n{\n\tswitch (config_tx_type) {\n\tcase HWTSTAMP_TX_OFF:\n\t\treturn IONIC_TXSTAMP_OFF;\n\tcase HWTSTAMP_TX_ON:\n\t\treturn IONIC_TXSTAMP_ON;\n\tcase HWTSTAMP_TX_ONESTEP_SYNC:\n\t\treturn IONIC_TXSTAMP_ONESTEP_SYNC;\n\tcase HWTSTAMP_TX_ONESTEP_P2P:\n\t\treturn IONIC_TXSTAMP_ONESTEP_P2P;\n\tdefault:\n\t\treturn -ERANGE;\n\t}\n}\n\nstatic u64 ionic_hwstamp_rx_filt(int config_rx_filter)\n{\n\tswitch (config_rx_filter) {\n\tcase HWTSTAMP_FILTER_PTP_V1_L4_EVENT:\n\t\treturn IONIC_PKT_CLS_PTP1_ALL;\n\tcase HWTSTAMP_FILTER_PTP_V1_L4_SYNC:\n\t\treturn IONIC_PKT_CLS_PTP1_SYNC;\n\tcase HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ:\n\t\treturn IONIC_PKT_CLS_PTP1_SYNC | IONIC_PKT_CLS_PTP1_DREQ;\n\n\tcase HWTSTAMP_FILTER_PTP_V2_L4_EVENT:\n\t\treturn IONIC_PKT_CLS_PTP2_L4_ALL;\n\tcase HWTSTAMP_FILTER_PTP_V2_L4_SYNC:\n\t\treturn IONIC_PKT_CLS_PTP2_L4_SYNC;\n\tcase HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ:\n\t\treturn IONIC_PKT_CLS_PTP2_L4_SYNC | IONIC_PKT_CLS_PTP2_L4_DREQ;\n\n\tcase HWTSTAMP_FILTER_PTP_V2_L2_EVENT:\n\t\treturn IONIC_PKT_CLS_PTP2_L2_ALL;\n\tcase HWTSTAMP_FILTER_PTP_V2_L2_SYNC:\n\t\treturn IONIC_PKT_CLS_PTP2_L2_SYNC;\n\tcase HWTSTAMP_FILTER_PTP_V2_L2_DELAY_REQ:\n\t\treturn IONIC_PKT_CLS_PTP2_L2_SYNC | IONIC_PKT_CLS_PTP2_L2_DREQ;\n\n\tcase HWTSTAMP_FILTER_PTP_V2_EVENT:\n\t\treturn IONIC_PKT_CLS_PTP2_ALL;\n\tcase HWTSTAMP_FILTER_PTP_V2_SYNC:\n\t\treturn IONIC_PKT_CLS_PTP2_SYNC;\n\tcase HWTSTAMP_FILTER_PTP_V2_DELAY_REQ:\n\t\treturn IONIC_PKT_CLS_PTP2_SYNC | IONIC_PKT_CLS_PTP2_DREQ;\n\n\tcase HWTSTAMP_FILTER_NTP_ALL:\n\t\treturn IONIC_PKT_CLS_NTP_ALL;\n\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic int ionic_lif_hwstamp_set_ts_config(struct ionic_lif *lif,\n\t\t\t\t\t   struct hwtstamp_config *new_ts)\n{\n\tstruct ionic *ionic = lif->ionic;\n\tstruct hwtstamp_config *config;\n\tstruct hwtstamp_config ts;\n\tint tx_mode = 0;\n\tu64 rx_filt = 0;\n\tint err, err2;\n\tbool rx_all;\n\t__le64 mask;\n\n\tif (!lif->phc || !lif->phc->ptp)\n\t\treturn -EOPNOTSUPP;\n\n\tmutex_lock(&lif->phc->config_lock);\n\n\tif (new_ts) {\n\t\tconfig = new_ts;\n\t} else {\n\t\t \n\t\tconfig = &ts;\n\t\tmemcpy(config, &lif->phc->ts_config, sizeof(*config));\n\t\tmemset(&lif->phc->ts_config, 0, sizeof(lif->phc->ts_config));\n\t\tlif->phc->ts_config_tx_mode = 0;\n\t\tlif->phc->ts_config_rx_filt = 0;\n\t}\n\n\ttx_mode = ionic_hwstamp_tx_mode(config->tx_type);\n\tif (tx_mode < 0) {\n\t\terr = tx_mode;\n\t\tgoto err_queues;\n\t}\n\n\tmask = cpu_to_le64(BIT_ULL(tx_mode));\n\tif ((ionic->ident.lif.eth.hwstamp_tx_modes & mask) != mask) {\n\t\terr = -ERANGE;\n\t\tgoto err_queues;\n\t}\n\n\trx_filt = ionic_hwstamp_rx_filt(config->rx_filter);\n\trx_all = config->rx_filter != HWTSTAMP_FILTER_NONE && !rx_filt;\n\n\tmask = cpu_to_le64(rx_filt);\n\tif ((ionic->ident.lif.eth.hwstamp_rx_filters & mask) != mask) {\n\t\trx_filt = 0;\n\t\trx_all = true;\n\t\tconfig->rx_filter = HWTSTAMP_FILTER_ALL;\n\t}\n\n\tdev_dbg(ionic->dev, \"%s: config_rx_filter %d rx_filt %#llx rx_all %d\\n\",\n\t\t__func__, config->rx_filter, rx_filt, rx_all);\n\n\tif (tx_mode) {\n\t\terr = ionic_lif_create_hwstamp_txq(lif);\n\t\tif (err)\n\t\t\tgoto err_queues;\n\t}\n\n\tif (rx_filt) {\n\t\terr = ionic_lif_create_hwstamp_rxq(lif);\n\t\tif (err)\n\t\t\tgoto err_queues;\n\t}\n\n\tif (tx_mode != lif->phc->ts_config_tx_mode) {\n\t\terr = ionic_lif_set_hwstamp_txmode(lif, tx_mode);\n\t\tif (err)\n\t\t\tgoto err_txmode;\n\t}\n\n\tif (rx_filt != lif->phc->ts_config_rx_filt) {\n\t\terr = ionic_lif_set_hwstamp_rxfilt(lif, rx_filt);\n\t\tif (err)\n\t\t\tgoto err_rxfilt;\n\t}\n\n\tif (rx_all != (lif->phc->ts_config.rx_filter == HWTSTAMP_FILTER_ALL)) {\n\t\terr = ionic_lif_config_hwstamp_rxq_all(lif, rx_all);\n\t\tif (err)\n\t\t\tgoto err_rxall;\n\t}\n\n\tmemcpy(&lif->phc->ts_config, config, sizeof(*config));\n\tlif->phc->ts_config_rx_filt = rx_filt;\n\tlif->phc->ts_config_tx_mode = tx_mode;\n\n\tmutex_unlock(&lif->phc->config_lock);\n\n\treturn 0;\n\nerr_rxall:\n\tif (rx_filt != lif->phc->ts_config_rx_filt) {\n\t\trx_filt = lif->phc->ts_config_rx_filt;\n\t\terr2 = ionic_lif_set_hwstamp_rxfilt(lif, rx_filt);\n\t\tif (err2)\n\t\t\tdev_err(ionic->dev,\n\t\t\t\t\"Failed to revert rx timestamp filter: %d\\n\", err2);\n\t}\nerr_rxfilt:\n\tif (tx_mode != lif->phc->ts_config_tx_mode) {\n\t\ttx_mode = lif->phc->ts_config_tx_mode;\n\t\terr2 = ionic_lif_set_hwstamp_txmode(lif, tx_mode);\n\t\tif (err2)\n\t\t\tdev_err(ionic->dev,\n\t\t\t\t\"Failed to revert tx timestamp mode: %d\\n\", err2);\n\t}\nerr_txmode:\n\t \nerr_queues:\n\tmutex_unlock(&lif->phc->config_lock);\n\treturn err;\n}\n\nint ionic_lif_hwstamp_set(struct ionic_lif *lif, struct ifreq *ifr)\n{\n\tstruct hwtstamp_config config;\n\tint err;\n\n\tif (!lif->phc || !lif->phc->ptp)\n\t\treturn -EOPNOTSUPP;\n\n\tif (copy_from_user(&config, ifr->ifr_data, sizeof(config)))\n\t\treturn -EFAULT;\n\n\tmutex_lock(&lif->queue_lock);\n\terr = ionic_lif_hwstamp_set_ts_config(lif, &config);\n\tmutex_unlock(&lif->queue_lock);\n\tif (err) {\n\t\tnetdev_info(lif->netdev, \"hwstamp set failed: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tif (copy_to_user(ifr->ifr_data, &config, sizeof(config)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nvoid ionic_lif_hwstamp_replay(struct ionic_lif *lif)\n{\n\tint err;\n\n\tif (!lif->phc || !lif->phc->ptp)\n\t\treturn;\n\n\tmutex_lock(&lif->queue_lock);\n\terr = ionic_lif_hwstamp_set_ts_config(lif, NULL);\n\tmutex_unlock(&lif->queue_lock);\n\tif (err)\n\t\tnetdev_info(lif->netdev, \"hwstamp replay failed: %d\\n\", err);\n}\n\nvoid ionic_lif_hwstamp_recreate_queues(struct ionic_lif *lif)\n{\n\tint err;\n\n\tif (!lif->phc || !lif->phc->ptp)\n\t\treturn;\n\n\tmutex_lock(&lif->phc->config_lock);\n\n\tif (lif->phc->ts_config_tx_mode) {\n\t\terr = ionic_lif_create_hwstamp_txq(lif);\n\t\tif (err)\n\t\t\tnetdev_info(lif->netdev, \"hwstamp recreate txq failed: %d\\n\", err);\n\t}\n\n\tif (lif->phc->ts_config_rx_filt) {\n\t\terr = ionic_lif_create_hwstamp_rxq(lif);\n\t\tif (err)\n\t\t\tnetdev_info(lif->netdev, \"hwstamp recreate rxq failed: %d\\n\", err);\n\t}\n\n\tmutex_unlock(&lif->phc->config_lock);\n}\n\nint ionic_lif_hwstamp_get(struct ionic_lif *lif, struct ifreq *ifr)\n{\n\tstruct hwtstamp_config config;\n\n\tif (!lif->phc || !lif->phc->ptp)\n\t\treturn -EOPNOTSUPP;\n\n\tmutex_lock(&lif->phc->config_lock);\n\tmemcpy(&config, &lif->phc->ts_config, sizeof(config));\n\tmutex_unlock(&lif->phc->config_lock);\n\n\tif (copy_to_user(ifr->ifr_data, &config, sizeof(config)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic u64 ionic_hwstamp_read(struct ionic *ionic,\n\t\t\t      struct ptp_system_timestamp *sts)\n{\n\tu32 tick_high_before, tick_high, tick_low;\n\n\t \n\tioread32(&ionic->idev.hwstamp_regs->tick_low);\n\n\ttick_high_before = ioread32(&ionic->idev.hwstamp_regs->tick_high);\n\n\tptp_read_system_prets(sts);\n\ttick_low = ioread32(&ionic->idev.hwstamp_regs->tick_low);\n\tptp_read_system_postts(sts);\n\n\ttick_high = ioread32(&ionic->idev.hwstamp_regs->tick_high);\n\n\t \n\tif (tick_high != tick_high_before) {\n\t\tptp_read_system_prets(sts);\n\t\ttick_low = ioread32(&ionic->idev.hwstamp_regs->tick_low);\n\t\tptp_read_system_postts(sts);\n\t}\n\n\treturn (u64)tick_low | ((u64)tick_high << 32);\n}\n\nstatic u64 ionic_cc_read(const struct cyclecounter *cc)\n{\n\tstruct ionic_phc *phc = container_of(cc, struct ionic_phc, cc);\n\tstruct ionic *ionic = phc->lif->ionic;\n\n\treturn ionic_hwstamp_read(ionic, NULL);\n}\n\nstatic int ionic_setphc_cmd(struct ionic_phc *phc, struct ionic_admin_ctx *ctx)\n{\n\tctx->work = COMPLETION_INITIALIZER_ONSTACK(ctx->work);\n\n\tctx->cmd.lif_setphc.opcode = IONIC_CMD_LIF_SETPHC;\n\tctx->cmd.lif_setphc.lif_index = cpu_to_le16(phc->lif->index);\n\n\tctx->cmd.lif_setphc.tick = cpu_to_le64(phc->tc.cycle_last);\n\tctx->cmd.lif_setphc.nsec = cpu_to_le64(phc->tc.nsec);\n\tctx->cmd.lif_setphc.frac = cpu_to_le64(phc->tc.frac);\n\tctx->cmd.lif_setphc.mult = cpu_to_le32(phc->cc.mult);\n\tctx->cmd.lif_setphc.shift = cpu_to_le32(phc->cc.shift);\n\n\treturn ionic_adminq_post(phc->lif, ctx);\n}\n\nstatic int ionic_phc_adjfine(struct ptp_clock_info *info, long scaled_ppm)\n{\n\tstruct ionic_phc *phc = container_of(info, struct ionic_phc, ptp_info);\n\tstruct ionic_admin_ctx ctx = {};\n\tunsigned long irqflags;\n\ts64 adj;\n\tint err;\n\n\t \n\tif (test_bit(IONIC_LIF_F_FW_RESET, phc->lif->state))\n\t\treturn -EBUSY;\n\n\t \n\tadj = (s64)scaled_ppm * phc->init_cc_mult;\n\n\t \n\tadj /= (s64)SCALED_PPM;\n\n\t \n\tadj += phc->init_cc_mult;\n\n\tspin_lock_irqsave(&phc->lock, irqflags);\n\n\t \n\ttimecounter_read(&phc->tc);\n\tphc->cc.mult = adj;\n\n\t \n\terr = ionic_setphc_cmd(phc, &ctx);\n\n\tspin_unlock_irqrestore(&phc->lock, irqflags);\n\n\treturn ionic_adminq_wait(phc->lif, &ctx, err, true);\n}\n\nstatic int ionic_phc_adjtime(struct ptp_clock_info *info, s64 delta)\n{\n\tstruct ionic_phc *phc = container_of(info, struct ionic_phc, ptp_info);\n\tstruct ionic_admin_ctx ctx = {};\n\tunsigned long irqflags;\n\tint err;\n\n\t \n\tif (test_bit(IONIC_LIF_F_FW_RESET, phc->lif->state))\n\t\treturn -EBUSY;\n\n\tspin_lock_irqsave(&phc->lock, irqflags);\n\n\ttimecounter_adjtime(&phc->tc, delta);\n\n\t \n\terr = ionic_setphc_cmd(phc, &ctx);\n\n\tspin_unlock_irqrestore(&phc->lock, irqflags);\n\n\treturn ionic_adminq_wait(phc->lif, &ctx, err, true);\n}\n\nstatic int ionic_phc_settime64(struct ptp_clock_info *info,\n\t\t\t       const struct timespec64 *ts)\n{\n\tstruct ionic_phc *phc = container_of(info, struct ionic_phc, ptp_info);\n\tstruct ionic_admin_ctx ctx = {};\n\tunsigned long irqflags;\n\tint err;\n\tu64 ns;\n\n\t \n\tif (test_bit(IONIC_LIF_F_FW_RESET, phc->lif->state))\n\t\treturn -EBUSY;\n\n\tns = timespec64_to_ns(ts);\n\n\tspin_lock_irqsave(&phc->lock, irqflags);\n\n\ttimecounter_init(&phc->tc, &phc->cc, ns);\n\n\t \n\terr = ionic_setphc_cmd(phc, &ctx);\n\n\tspin_unlock_irqrestore(&phc->lock, irqflags);\n\n\treturn ionic_adminq_wait(phc->lif, &ctx, err, true);\n}\n\nstatic int ionic_phc_gettimex64(struct ptp_clock_info *info,\n\t\t\t\tstruct timespec64 *ts,\n\t\t\t\tstruct ptp_system_timestamp *sts)\n{\n\tstruct ionic_phc *phc = container_of(info, struct ionic_phc, ptp_info);\n\tstruct ionic *ionic = phc->lif->ionic;\n\tunsigned long irqflags;\n\tu64 tick, ns;\n\n\t \n\tif (test_bit(IONIC_LIF_F_FW_RESET, phc->lif->state))\n\t\treturn -EBUSY;\n\n\tspin_lock_irqsave(&phc->lock, irqflags);\n\n\ttick = ionic_hwstamp_read(ionic, sts);\n\n\tns = timecounter_cyc2time(&phc->tc, tick);\n\n\tspin_unlock_irqrestore(&phc->lock, irqflags);\n\n\t*ts = ns_to_timespec64(ns);\n\n\treturn 0;\n}\n\nstatic long ionic_phc_aux_work(struct ptp_clock_info *info)\n{\n\tstruct ionic_phc *phc = container_of(info, struct ionic_phc, ptp_info);\n\tstruct ionic_admin_ctx ctx = {};\n\tunsigned long irqflags;\n\tint err;\n\n\t \n\tif (test_bit(IONIC_LIF_F_FW_RESET, phc->lif->state))\n\t\treturn phc->aux_work_delay;\n\n\tspin_lock_irqsave(&phc->lock, irqflags);\n\n\t \n\ttimecounter_read(&phc->tc);\n\n\t \n\terr = ionic_setphc_cmd(phc, &ctx);\n\n\tspin_unlock_irqrestore(&phc->lock, irqflags);\n\n\tionic_adminq_wait(phc->lif, &ctx, err, true);\n\n\treturn phc->aux_work_delay;\n}\n\nktime_t ionic_lif_phc_ktime(struct ionic_lif *lif, u64 tick)\n{\n\tunsigned long irqflags;\n\tu64 ns;\n\n\tif (!lif->phc)\n\t\treturn 0;\n\n\tspin_lock_irqsave(&lif->phc->lock, irqflags);\n\tns = timecounter_cyc2time(&lif->phc->tc, tick);\n\tspin_unlock_irqrestore(&lif->phc->lock, irqflags);\n\n\treturn ns_to_ktime(ns);\n}\n\nstatic const struct ptp_clock_info ionic_ptp_info = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"ionic_ptp\",\n\t.adjfine\t= ionic_phc_adjfine,\n\t.adjtime\t= ionic_phc_adjtime,\n\t.gettimex64\t= ionic_phc_gettimex64,\n\t.settime64\t= ionic_phc_settime64,\n\t.do_aux_work\t= ionic_phc_aux_work,\n};\n\nvoid ionic_lif_register_phc(struct ionic_lif *lif)\n{\n\tif (!lif->phc || !(lif->hw_features & IONIC_ETH_HW_TIMESTAMP))\n\t\treturn;\n\n\tlif->phc->ptp = ptp_clock_register(&lif->phc->ptp_info, lif->ionic->dev);\n\n\tif (IS_ERR(lif->phc->ptp)) {\n\t\tdev_warn(lif->ionic->dev, \"Cannot register phc device: %ld\\n\",\n\t\t\t PTR_ERR(lif->phc->ptp));\n\n\t\tlif->phc->ptp = NULL;\n\t}\n\n\tif (lif->phc->ptp)\n\t\tptp_schedule_worker(lif->phc->ptp, lif->phc->aux_work_delay);\n}\n\nvoid ionic_lif_unregister_phc(struct ionic_lif *lif)\n{\n\tif (!lif->phc || !lif->phc->ptp)\n\t\treturn;\n\n\tptp_clock_unregister(lif->phc->ptp);\n\n\tlif->phc->ptp = NULL;\n}\n\nvoid ionic_lif_alloc_phc(struct ionic_lif *lif)\n{\n\tstruct ionic *ionic = lif->ionic;\n\tstruct ionic_phc *phc;\n\tu64 delay, diff, mult;\n\tu64 frac = 0;\n\tu64 features;\n\tu32 shift;\n\n\tif (!ionic->idev.hwstamp_regs)\n\t\treturn;\n\n\tfeatures = le64_to_cpu(ionic->ident.lif.eth.config.features);\n\tif (!(features & IONIC_ETH_HW_TIMESTAMP))\n\t\treturn;\n\n\tphc = devm_kzalloc(ionic->dev, sizeof(*phc), GFP_KERNEL);\n\tif (!phc)\n\t\treturn;\n\n\tphc->lif = lif;\n\n\tphc->cc.read = ionic_cc_read;\n\tphc->cc.mask = le64_to_cpu(ionic->ident.dev.hwstamp_mask);\n\tphc->cc.mult = le32_to_cpu(ionic->ident.dev.hwstamp_mult);\n\tphc->cc.shift = le32_to_cpu(ionic->ident.dev.hwstamp_shift);\n\n\tif (!phc->cc.mult) {\n\t\tdev_err(lif->ionic->dev,\n\t\t\t\"Invalid device PHC mask multiplier %u, disabling HW timestamp support\\n\",\n\t\t\tphc->cc.mult);\n\t\tdevm_kfree(lif->ionic->dev, phc);\n\t\tlif->phc = NULL;\n\t\treturn;\n\t}\n\n\tdev_dbg(lif->ionic->dev, \"Device PHC mask %#llx mult %u shift %u\\n\",\n\t\tphc->cc.mask, phc->cc.mult, phc->cc.shift);\n\n\tspin_lock_init(&phc->lock);\n\tmutex_init(&phc->config_lock);\n\n\t \n\tif (phc->cc.shift + 2 + ilog2(IONIC_PHC_UPDATE_NS) >= 64) {\n\t\t \n\t\tdiff = U64_MAX / phc->cc.mult / 2;\n\t} else {\n\t\t \n\t\tdiff = (u64)IONIC_PHC_UPDATE_NS << (phc->cc.shift + 2);\n\t\tdiff = DIV_ROUND_UP(diff, phc->cc.mult);\n\t}\n\n\t \n\tdiff |= diff >> 1;\n\tdiff |= diff >> 2;\n\tdiff |= diff >> 4;\n\tdiff |= diff >> 8;\n\tdiff |= diff >> 16;\n\tdiff |= diff >> 32;\n\n\t \n\tdiff &= phc->cc.mask;\n\n\t \n\tmult = U64_MAX / 2 / max(diff / 2, SCALED_PPM);\n\tshift = mult / phc->cc.mult;\n\tif (shift >= 2) {\n\t\t \n\t\tshift = fls(shift);\n\t\t \n\t\tphc->cc.mult <<= shift;\n\t\tphc->cc.shift += shift;\n\t}\n\n\tdev_dbg(lif->ionic->dev, \"Initial PHC mask %#llx mult %u shift %u\\n\",\n\t\tphc->cc.mask, phc->cc.mult, phc->cc.shift);\n\n\t \n\tphc->init_cc_mult = phc->cc.mult;\n\n\ttimecounter_init(&phc->tc, &phc->cc, ktime_get_real_ns());\n\n\t \n\tdelay = min_t(u64, IONIC_PHC_UPDATE_NS,\n\t\t      cyclecounter_cyc2ns(&phc->cc, diff / 4, 0, &frac));\n\tdev_dbg(lif->ionic->dev, \"Work delay %llu ms\\n\", delay / NSEC_PER_MSEC);\n\n\tphc->aux_work_delay = nsecs_to_jiffies(delay);\n\n\tphc->ptp_info = ionic_ptp_info;\n\n\t \n\tphc->ptp_info.max_adj = NORMAL_PPB;\n\n\tlif->phc = phc;\n}\n\nvoid ionic_lif_free_phc(struct ionic_lif *lif)\n{\n\tif (!lif->phc)\n\t\treturn;\n\n\tmutex_destroy(&lif->phc->config_lock);\n\n\tdevm_kfree(lif->ionic->dev, lif->phc);\n\tlif->phc = NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}