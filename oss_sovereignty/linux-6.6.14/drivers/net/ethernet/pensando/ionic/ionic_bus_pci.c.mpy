{
  "module_name": "ionic_bus_pci.c",
  "hash_id": "5d78f2d35414b0ee26beb7869d5f063a7d370bc6c918bc166bae6f10f88eb1e2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/pensando/ionic/ionic_bus_pci.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/pci.h>\n\n#include \"ionic.h\"\n#include \"ionic_bus.h\"\n#include \"ionic_lif.h\"\n#include \"ionic_debugfs.h\"\n\n \nstatic const struct pci_device_id ionic_id_table[] = {\n\t{ PCI_VDEVICE(PENSANDO, PCI_DEVICE_ID_PENSANDO_IONIC_ETH_PF) },\n\t{ PCI_VDEVICE(PENSANDO, PCI_DEVICE_ID_PENSANDO_IONIC_ETH_VF) },\n\t{ 0, }\t \n};\nMODULE_DEVICE_TABLE(pci, ionic_id_table);\n\nint ionic_bus_get_irq(struct ionic *ionic, unsigned int num)\n{\n\treturn pci_irq_vector(ionic->pdev, num);\n}\n\nconst char *ionic_bus_info(struct ionic *ionic)\n{\n\treturn pci_name(ionic->pdev);\n}\n\nint ionic_bus_alloc_irq_vectors(struct ionic *ionic, unsigned int nintrs)\n{\n\treturn pci_alloc_irq_vectors(ionic->pdev, nintrs, nintrs,\n\t\t\t\t     PCI_IRQ_MSIX);\n}\n\nvoid ionic_bus_free_irq_vectors(struct ionic *ionic)\n{\n\tif (!ionic->nintrs)\n\t\treturn;\n\n\tpci_free_irq_vectors(ionic->pdev);\n}\n\nstatic int ionic_map_bars(struct ionic *ionic)\n{\n\tstruct pci_dev *pdev = ionic->pdev;\n\tstruct device *dev = ionic->dev;\n\tstruct ionic_dev_bar *bars;\n\tunsigned int i, j;\n\n\tbars = ionic->bars;\n\tionic->num_bars = 0;\n\n\tfor (i = 0, j = 0; i < IONIC_BARS_MAX; i++) {\n\t\tif (!(pci_resource_flags(pdev, i) & IORESOURCE_MEM))\n\t\t\tcontinue;\n\t\tbars[j].len = pci_resource_len(pdev, i);\n\n\t\t \n\t\tif (j > 0) {\n\t\t\tbars[j].vaddr = NULL;\n\t\t} else {\n\t\t\tbars[j].vaddr = pci_iomap(pdev, i, bars[j].len);\n\t\t\tif (!bars[j].vaddr) {\n\t\t\t\tdev_err(dev,\n\t\t\t\t\t\"Cannot memory-map BAR %d, aborting\\n\",\n\t\t\t\t\ti);\n\t\t\t\treturn -ENODEV;\n\t\t\t}\n\t\t}\n\n\t\tbars[j].bus_addr = pci_resource_start(pdev, i);\n\t\tbars[j].res_index = i;\n\t\tionic->num_bars++;\n\t\tj++;\n\t}\n\n\treturn 0;\n}\n\nstatic void ionic_unmap_bars(struct ionic *ionic)\n{\n\tstruct ionic_dev_bar *bars = ionic->bars;\n\tunsigned int i;\n\n\tfor (i = 0; i < IONIC_BARS_MAX; i++) {\n\t\tif (bars[i].vaddr) {\n\t\t\tiounmap(bars[i].vaddr);\n\t\t\tbars[i].bus_addr = 0;\n\t\t\tbars[i].vaddr = NULL;\n\t\t\tbars[i].len = 0;\n\t\t}\n\t}\n}\n\nvoid __iomem *ionic_bus_map_dbpage(struct ionic *ionic, int page_num)\n{\n\treturn pci_iomap_range(ionic->pdev,\n\t\t\t       ionic->bars[IONIC_PCI_BAR_DBELL].res_index,\n\t\t\t       (u64)page_num << PAGE_SHIFT, PAGE_SIZE);\n}\n\nvoid ionic_bus_unmap_dbpage(struct ionic *ionic, void __iomem *page)\n{\n\tiounmap(page);\n}\n\nstatic void ionic_vf_dealloc_locked(struct ionic *ionic)\n{\n\tstruct ionic_vf_setattr_cmd vfc = { .attr = IONIC_VF_ATTR_STATSADDR };\n\tstruct ionic_vf *v;\n\tint i;\n\n\tif (!ionic->vfs)\n\t\treturn;\n\n\tfor (i = ionic->num_vfs - 1; i >= 0; i--) {\n\t\tv = &ionic->vfs[i];\n\n\t\tif (v->stats_pa) {\n\t\t\tvfc.stats_pa = 0;\n\t\t\tionic_set_vf_config(ionic, i, &vfc);\n\t\t\tdma_unmap_single(ionic->dev, v->stats_pa,\n\t\t\t\t\t sizeof(v->stats), DMA_FROM_DEVICE);\n\t\t\tv->stats_pa = 0;\n\t\t}\n\t}\n\n\tkfree(ionic->vfs);\n\tionic->vfs = NULL;\n\tionic->num_vfs = 0;\n}\n\nstatic void ionic_vf_dealloc(struct ionic *ionic)\n{\n\tdown_write(&ionic->vf_op_lock);\n\tionic_vf_dealloc_locked(ionic);\n\tup_write(&ionic->vf_op_lock);\n}\n\nstatic int ionic_vf_alloc(struct ionic *ionic, int num_vfs)\n{\n\tstruct ionic_vf_setattr_cmd vfc = { .attr = IONIC_VF_ATTR_STATSADDR };\n\tstruct ionic_vf *v;\n\tint err = 0;\n\tint i;\n\n\tdown_write(&ionic->vf_op_lock);\n\n\tionic->vfs = kcalloc(num_vfs, sizeof(struct ionic_vf), GFP_KERNEL);\n\tif (!ionic->vfs) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < num_vfs; i++) {\n\t\tv = &ionic->vfs[i];\n\t\tv->stats_pa = dma_map_single(ionic->dev, &v->stats,\n\t\t\t\t\t     sizeof(v->stats), DMA_FROM_DEVICE);\n\t\tif (dma_mapping_error(ionic->dev, v->stats_pa)) {\n\t\t\tv->stats_pa = 0;\n\t\t\terr = -ENODEV;\n\t\t\tgoto out;\n\t\t}\n\n\t\tionic->num_vfs++;\n\n\t\t \n\t\tvfc.stats_pa = cpu_to_le64(v->stats_pa);\n\t\tionic_set_vf_config(ionic, i, &vfc);\n\t}\n\nout:\n\tif (err)\n\t\tionic_vf_dealloc_locked(ionic);\n\tup_write(&ionic->vf_op_lock);\n\treturn err;\n}\n\nstatic int ionic_sriov_configure(struct pci_dev *pdev, int num_vfs)\n{\n\tstruct ionic *ionic = pci_get_drvdata(pdev);\n\tstruct device *dev = ionic->dev;\n\tint ret = 0;\n\n\tif (ionic->lif &&\n\t    test_bit(IONIC_LIF_F_FW_RESET, ionic->lif->state))\n\t\treturn -EBUSY;\n\n\tif (num_vfs > 0) {\n\t\tret = pci_enable_sriov(pdev, num_vfs);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Cannot enable SRIOV: %d\\n\", ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ionic_vf_alloc(ionic, num_vfs);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Cannot alloc VFs: %d\\n\", ret);\n\t\t\tpci_disable_sriov(pdev);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = num_vfs;\n\t} else {\n\t\tpci_disable_sriov(pdev);\n\t\tionic_vf_dealloc(ionic);\n\t}\n\nout:\n\treturn ret;\n}\n\nstatic void ionic_clear_pci(struct ionic *ionic)\n{\n\tionic_unmap_bars(ionic);\n\tpci_release_regions(ionic->pdev);\n\tpci_disable_device(ionic->pdev);\n}\n\nstatic int ionic_setup_one(struct ionic *ionic)\n{\n\tstruct pci_dev *pdev = ionic->pdev;\n\tstruct device *dev = ionic->dev;\n\tint err;\n\n\tionic_debugfs_add_dev(ionic);\n\n\t \n\terr = pci_enable_device_mem(pdev);\n\tif (err) {\n\t\tdev_err(dev, \"Cannot enable PCI device: %d, aborting\\n\", err);\n\t\tgoto err_out_debugfs_del_dev;\n\t}\n\n\terr = pci_request_regions(pdev, IONIC_DRV_NAME);\n\tif (err) {\n\t\tdev_err(dev, \"Cannot request PCI regions: %d, aborting\\n\", err);\n\t\tgoto err_out_clear_pci;\n\t}\n\tpcie_print_link_status(pdev);\n\n\terr = ionic_map_bars(ionic);\n\tif (err)\n\t\tgoto err_out_clear_pci;\n\n\t \n\terr = ionic_setup(ionic);\n\tif (err) {\n\t\tdev_err(dev, \"Cannot setup device: %d, aborting\\n\", err);\n\t\tgoto err_out_clear_pci;\n\t}\n\tpci_set_master(pdev);\n\n\terr = ionic_identify(ionic);\n\tif (err) {\n\t\tdev_err(dev, \"Cannot identify device: %d, aborting\\n\", err);\n\t\tgoto err_out_teardown;\n\t}\n\tionic_debugfs_add_ident(ionic);\n\n\terr = ionic_init(ionic);\n\tif (err) {\n\t\tdev_err(dev, \"Cannot init device: %d, aborting\\n\", err);\n\t\tgoto err_out_teardown;\n\t}\n\n\t \n\terr = ionic_port_identify(ionic);\n\tif (err) {\n\t\tdev_err(dev, \"Cannot identify port: %d, aborting\\n\", err);\n\t\tgoto err_out_teardown;\n\t}\n\n\terr = ionic_port_init(ionic);\n\tif (err) {\n\t\tdev_err(dev, \"Cannot init port: %d, aborting\\n\", err);\n\t\tgoto err_out_teardown;\n\t}\n\n\treturn 0;\n\nerr_out_teardown:\n\tionic_dev_teardown(ionic);\nerr_out_clear_pci:\n\tionic_clear_pci(ionic);\nerr_out_debugfs_del_dev:\n\tionic_debugfs_del_dev(ionic);\n\n\treturn err;\n}\n\nstatic int ionic_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct ionic *ionic;\n\tint num_vfs;\n\tint err;\n\n\tionic = ionic_devlink_alloc(dev);\n\tif (!ionic)\n\t\treturn -ENOMEM;\n\n\tionic->pdev = pdev;\n\tionic->dev = dev;\n\tpci_set_drvdata(pdev, ionic);\n\tmutex_init(&ionic->dev_cmd_lock);\n\n\t \n\terr = dma_set_mask_and_coherent(dev, DMA_BIT_MASK(IONIC_ADDR_LEN));\n\tif (err) {\n\t\tdev_err(dev, \"Unable to obtain 64-bit DMA for consistent allocations, aborting.  err=%d\\n\",\n\t\t\terr);\n\t\tgoto err_out;\n\t}\n\n\terr = ionic_setup_one(ionic);\n\tif (err)\n\t\tgoto err_out;\n\n\t \n\terr = ionic_lif_size(ionic);\n\tif (err) {\n\t\tdev_err(dev, \"Cannot size LIF: %d, aborting\\n\", err);\n\t\tgoto err_out_pci;\n\t}\n\n\terr = ionic_lif_alloc(ionic);\n\tif (err) {\n\t\tdev_err(dev, \"Cannot allocate LIF: %d, aborting\\n\", err);\n\t\tgoto err_out_free_irqs;\n\t}\n\n\terr = ionic_lif_init(ionic->lif);\n\tif (err) {\n\t\tdev_err(dev, \"Cannot init LIF: %d, aborting\\n\", err);\n\t\tgoto err_out_free_lifs;\n\t}\n\n\tinit_rwsem(&ionic->vf_op_lock);\n\tnum_vfs = pci_num_vf(pdev);\n\tif (num_vfs) {\n\t\tdev_info(dev, \"%d VFs found already enabled\\n\", num_vfs);\n\t\terr = ionic_vf_alloc(ionic, num_vfs);\n\t\tif (err)\n\t\t\tdev_err(dev, \"Cannot enable existing VFs: %d\\n\", err);\n\t}\n\n\terr = ionic_devlink_register(ionic);\n\tif (err) {\n\t\tdev_err(dev, \"Cannot register devlink: %d\\n\", err);\n\t\tgoto err_out_deinit_lifs;\n\t}\n\n\terr = ionic_lif_register(ionic->lif);\n\tif (err) {\n\t\tdev_err(dev, \"Cannot register LIF: %d, aborting\\n\", err);\n\t\tgoto err_out_deregister_devlink;\n\t}\n\n\tmod_timer(&ionic->watchdog_timer,\n\t\t  round_jiffies(jiffies + ionic->watchdog_period));\n\n\treturn 0;\n\nerr_out_deregister_devlink:\n\tionic_devlink_unregister(ionic);\nerr_out_deinit_lifs:\n\tionic_vf_dealloc(ionic);\n\tionic_lif_deinit(ionic->lif);\nerr_out_free_lifs:\n\tionic_lif_free(ionic->lif);\n\tionic->lif = NULL;\nerr_out_free_irqs:\n\tionic_bus_free_irq_vectors(ionic);\nerr_out_pci:\n\tionic_dev_teardown(ionic);\n\tionic_clear_pci(ionic);\nerr_out:\n\tmutex_destroy(&ionic->dev_cmd_lock);\n\tionic_devlink_free(ionic);\n\n\treturn err;\n}\n\nstatic void ionic_remove(struct pci_dev *pdev)\n{\n\tstruct ionic *ionic = pci_get_drvdata(pdev);\n\n\tdel_timer_sync(&ionic->watchdog_timer);\n\n\tif (ionic->lif) {\n\t\tionic_lif_unregister(ionic->lif);\n\t\tionic_devlink_unregister(ionic);\n\t\tionic_lif_deinit(ionic->lif);\n\t\tionic_lif_free(ionic->lif);\n\t\tionic->lif = NULL;\n\t\tionic_bus_free_irq_vectors(ionic);\n\t}\n\n\tionic_port_reset(ionic);\n\tionic_reset(ionic);\n\tionic_dev_teardown(ionic);\n\tionic_clear_pci(ionic);\n\tionic_debugfs_del_dev(ionic);\n\tmutex_destroy(&ionic->dev_cmd_lock);\n\tionic_devlink_free(ionic);\n}\n\nstatic void ionic_reset_prepare(struct pci_dev *pdev)\n{\n\tstruct ionic *ionic = pci_get_drvdata(pdev);\n\tstruct ionic_lif *lif = ionic->lif;\n\n\tdev_dbg(ionic->dev, \"%s: device stopping\\n\", __func__);\n\n\tdel_timer_sync(&ionic->watchdog_timer);\n\tcancel_work_sync(&lif->deferred.work);\n\n\tmutex_lock(&lif->queue_lock);\n\tionic_stop_queues_reconfig(lif);\n\tionic_txrx_free(lif);\n\tionic_lif_deinit(lif);\n\tionic_qcqs_free(lif);\n\tmutex_unlock(&lif->queue_lock);\n\n\tionic_dev_teardown(ionic);\n\tionic_clear_pci(ionic);\n\tionic_debugfs_del_dev(ionic);\n}\n\nstatic void ionic_reset_done(struct pci_dev *pdev)\n{\n\tstruct ionic *ionic = pci_get_drvdata(pdev);\n\tstruct ionic_lif *lif = ionic->lif;\n\tint err;\n\n\terr = ionic_setup_one(ionic);\n\tif (err)\n\t\tgoto err_out;\n\n\tionic_debugfs_add_sizes(ionic);\n\tionic_debugfs_add_lif(ionic->lif);\n\n\terr = ionic_restart_lif(lif);\n\tif (err)\n\t\tgoto err_out;\n\n\tmod_timer(&ionic->watchdog_timer, jiffies + 1);\n\nerr_out:\n\tdev_dbg(ionic->dev, \"%s: device recovery %s\\n\",\n\t\t__func__, err ? \"failed\" : \"done\");\n}\n\nstatic const struct pci_error_handlers ionic_err_handler = {\n\t \n\t.reset_prepare      = ionic_reset_prepare,\n\t.reset_done         = ionic_reset_done,\n};\n\nstatic struct pci_driver ionic_driver = {\n\t.name = IONIC_DRV_NAME,\n\t.id_table = ionic_id_table,\n\t.probe = ionic_probe,\n\t.remove = ionic_remove,\n\t.sriov_configure = ionic_sriov_configure,\n\t.err_handler = &ionic_err_handler\n};\n\nint ionic_bus_register_driver(void)\n{\n\treturn pci_register_driver(&ionic_driver);\n}\n\nvoid ionic_bus_unregister_driver(void)\n{\n\tpci_unregister_driver(&ionic_driver);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}