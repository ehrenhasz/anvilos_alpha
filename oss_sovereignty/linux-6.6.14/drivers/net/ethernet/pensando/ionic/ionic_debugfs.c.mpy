{
  "module_name": "ionic_debugfs.c",
  "hash_id": "68330358a80ee8350433a0e2b5a4fa560755fda9b2baf88b320b97105f6f6bf6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/pensando/ionic/ionic_debugfs.c",
  "human_readable_source": "\n \n\n#include <linux/pci.h>\n#include <linux/netdevice.h>\n\n#include \"ionic.h\"\n#include \"ionic_bus.h\"\n#include \"ionic_lif.h\"\n#include \"ionic_debugfs.h\"\n\n#ifdef CONFIG_DEBUG_FS\n\nstatic struct dentry *ionic_dir;\n\nvoid ionic_debugfs_create(void)\n{\n\tionic_dir = debugfs_create_dir(IONIC_DRV_NAME, NULL);\n}\n\nvoid ionic_debugfs_destroy(void)\n{\n\tdebugfs_remove_recursive(ionic_dir);\n}\n\nvoid ionic_debugfs_add_dev(struct ionic *ionic)\n{\n\tionic->dentry = debugfs_create_dir(ionic_bus_info(ionic), ionic_dir);\n}\n\nvoid ionic_debugfs_del_dev(struct ionic *ionic)\n{\n\tdebugfs_remove_recursive(ionic->dentry);\n\tionic->dentry = NULL;\n}\n\nstatic int identity_show(struct seq_file *seq, void *v)\n{\n\tstruct ionic *ionic = seq->private;\n\tstruct ionic_identity *ident;\n\n\tident = &ionic->ident;\n\n\tseq_printf(seq, \"nlifs:            %d\\n\", ident->dev.nlifs);\n\tseq_printf(seq, \"nintrs:           %d\\n\", ident->dev.nintrs);\n\tseq_printf(seq, \"ndbpgs_per_lif:   %d\\n\", ident->dev.ndbpgs_per_lif);\n\tseq_printf(seq, \"intr_coal_mult:   %d\\n\", ident->dev.intr_coal_mult);\n\tseq_printf(seq, \"intr_coal_div:    %d\\n\", ident->dev.intr_coal_div);\n\n\tseq_printf(seq, \"max_ucast_filters:  %d\\n\", ident->lif.eth.max_ucast_filters);\n\tseq_printf(seq, \"max_mcast_filters:  %d\\n\", ident->lif.eth.max_mcast_filters);\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(identity);\n\nvoid ionic_debugfs_add_ident(struct ionic *ionic)\n{\n\tdebugfs_create_file(\"identity\", 0400, ionic->dentry,\n\t\t\t    ionic, &identity_fops);\n}\n\nvoid ionic_debugfs_add_sizes(struct ionic *ionic)\n{\n\tdebugfs_create_u32(\"nlifs\", 0400, ionic->dentry,\n\t\t\t   (u32 *)&ionic->ident.dev.nlifs);\n\tdebugfs_create_u32(\"nintrs\", 0400, ionic->dentry, &ionic->nintrs);\n\n\tdebugfs_create_u32(\"ntxqs_per_lif\", 0400, ionic->dentry,\n\t\t\t   (u32 *)&ionic->ident.lif.eth.config.queue_count[IONIC_QTYPE_TXQ]);\n\tdebugfs_create_u32(\"nrxqs_per_lif\", 0400, ionic->dentry,\n\t\t\t   (u32 *)&ionic->ident.lif.eth.config.queue_count[IONIC_QTYPE_RXQ]);\n}\n\nstatic int q_tail_show(struct seq_file *seq, void *v)\n{\n\tstruct ionic_queue *q = seq->private;\n\n\tseq_printf(seq, \"%d\\n\", q->tail_idx);\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(q_tail);\n\nstatic int q_head_show(struct seq_file *seq, void *v)\n{\n\tstruct ionic_queue *q = seq->private;\n\n\tseq_printf(seq, \"%d\\n\", q->head_idx);\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(q_head);\n\nstatic int cq_tail_show(struct seq_file *seq, void *v)\n{\n\tstruct ionic_cq *cq = seq->private;\n\n\tseq_printf(seq, \"%d\\n\", cq->tail_idx);\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(cq_tail);\n\nstatic const struct debugfs_reg32 intr_ctrl_regs[] = {\n\t{ .name = \"coal_init\", .offset = 0, },\n\t{ .name = \"mask\", .offset = 4, },\n\t{ .name = \"credits\", .offset = 8, },\n\t{ .name = \"mask_on_assert\", .offset = 12, },\n\t{ .name = \"coal_timer\", .offset = 16, },\n};\n\nvoid ionic_debugfs_add_qcq(struct ionic_lif *lif, struct ionic_qcq *qcq)\n{\n\tstruct dentry *qcq_dentry, *q_dentry, *cq_dentry;\n\tstruct dentry *intr_dentry, *stats_dentry;\n\tstruct ionic_dev *idev = &lif->ionic->idev;\n\tstruct debugfs_regset32 *intr_ctrl_regset;\n\tstruct ionic_intr_info *intr = &qcq->intr;\n\tstruct debugfs_blob_wrapper *desc_blob;\n\tstruct device *dev = lif->ionic->dev;\n\tstruct ionic_queue *q = &qcq->q;\n\tstruct ionic_cq *cq = &qcq->cq;\n\n\tqcq_dentry = debugfs_create_dir(q->name, lif->dentry);\n\tif (IS_ERR_OR_NULL(qcq_dentry))\n\t\treturn;\n\tqcq->dentry = qcq_dentry;\n\n\tdebugfs_create_x64(\"q_base_pa\", 0400, qcq_dentry, &qcq->q_base_pa);\n\tdebugfs_create_x32(\"q_size\", 0400, qcq_dentry, &qcq->q_size);\n\tdebugfs_create_x64(\"cq_base_pa\", 0400, qcq_dentry, &qcq->cq_base_pa);\n\tdebugfs_create_x32(\"cq_size\", 0400, qcq_dentry, &qcq->cq_size);\n\tdebugfs_create_x64(\"sg_base_pa\", 0400, qcq_dentry, &qcq->sg_base_pa);\n\tdebugfs_create_x32(\"sg_size\", 0400, qcq_dentry, &qcq->sg_size);\n\n\tq_dentry = debugfs_create_dir(\"q\", qcq->dentry);\n\n\tdebugfs_create_u32(\"index\", 0400, q_dentry, &q->index);\n\tdebugfs_create_u32(\"num_descs\", 0400, q_dentry, &q->num_descs);\n\tdebugfs_create_u32(\"desc_size\", 0400, q_dentry, &q->desc_size);\n\tdebugfs_create_u32(\"pid\", 0400, q_dentry, &q->pid);\n\tdebugfs_create_u32(\"qid\", 0400, q_dentry, &q->hw_index);\n\tdebugfs_create_u32(\"qtype\", 0400, q_dentry, &q->hw_type);\n\tdebugfs_create_u64(\"drop\", 0400, q_dentry, &q->drop);\n\n\tdebugfs_create_file(\"tail\", 0400, q_dentry, q, &q_tail_fops);\n\tdebugfs_create_file(\"head\", 0400, q_dentry, q, &q_head_fops);\n\n\tdesc_blob = devm_kzalloc(dev, sizeof(*desc_blob), GFP_KERNEL);\n\tif (!desc_blob)\n\t\treturn;\n\tdesc_blob->data = q->base;\n\tdesc_blob->size = (unsigned long)q->num_descs * q->desc_size;\n\tdebugfs_create_blob(\"desc_blob\", 0400, q_dentry, desc_blob);\n\n\tif (qcq->flags & IONIC_QCQ_F_SG) {\n\t\tdesc_blob = devm_kzalloc(dev, sizeof(*desc_blob), GFP_KERNEL);\n\t\tif (!desc_blob)\n\t\t\treturn;\n\t\tdesc_blob->data = q->sg_base;\n\t\tdesc_blob->size = (unsigned long)q->num_descs * q->sg_desc_size;\n\t\tdebugfs_create_blob(\"sg_desc_blob\", 0400, q_dentry,\n\t\t\t\t    desc_blob);\n\t}\n\n\tcq_dentry = debugfs_create_dir(\"cq\", qcq->dentry);\n\n\tdebugfs_create_x64(\"base_pa\", 0400, cq_dentry, &cq->base_pa);\n\tdebugfs_create_u32(\"num_descs\", 0400, cq_dentry, &cq->num_descs);\n\tdebugfs_create_u32(\"desc_size\", 0400, cq_dentry, &cq->desc_size);\n\tdebugfs_create_bool(\"done_color\", 0400, cq_dentry, &cq->done_color);\n\n\tdebugfs_create_file(\"tail\", 0400, cq_dentry, cq, &cq_tail_fops);\n\n\tdesc_blob = devm_kzalloc(dev, sizeof(*desc_blob), GFP_KERNEL);\n\tif (!desc_blob)\n\t\treturn;\n\tdesc_blob->data = cq->base;\n\tdesc_blob->size = (unsigned long)cq->num_descs * cq->desc_size;\n\tdebugfs_create_blob(\"desc_blob\", 0400, cq_dentry, desc_blob);\n\n\tif (qcq->flags & IONIC_QCQ_F_INTR) {\n\t\tintr_dentry = debugfs_create_dir(\"intr\", qcq->dentry);\n\n\t\tdebugfs_create_u32(\"index\", 0400, intr_dentry,\n\t\t\t\t   &intr->index);\n\t\tdebugfs_create_u32(\"vector\", 0400, intr_dentry,\n\t\t\t\t   &intr->vector);\n\t\tdebugfs_create_u32(\"dim_coal_hw\", 0400, intr_dentry,\n\t\t\t\t   &intr->dim_coal_hw);\n\n\t\tintr_ctrl_regset = devm_kzalloc(dev, sizeof(*intr_ctrl_regset),\n\t\t\t\t\t\tGFP_KERNEL);\n\t\tif (!intr_ctrl_regset)\n\t\t\treturn;\n\t\tintr_ctrl_regset->regs = intr_ctrl_regs;\n\t\tintr_ctrl_regset->nregs = ARRAY_SIZE(intr_ctrl_regs);\n\t\tintr_ctrl_regset->base = &idev->intr_ctrl[intr->index];\n\n\t\tdebugfs_create_regset32(\"intr_ctrl\", 0400, intr_dentry,\n\t\t\t\t\tintr_ctrl_regset);\n\t}\n\n\tif (qcq->flags & IONIC_QCQ_F_NOTIFYQ) {\n\t\tstats_dentry = debugfs_create_dir(\"notifyblock\", qcq->dentry);\n\n\t\tdebugfs_create_u64(\"eid\", 0400, stats_dentry,\n\t\t\t\t   (u64 *)&lif->info->status.eid);\n\t\tdebugfs_create_u16(\"link_status\", 0400, stats_dentry,\n\t\t\t\t   (u16 *)&lif->info->status.link_status);\n\t\tdebugfs_create_u32(\"link_speed\", 0400, stats_dentry,\n\t\t\t\t   (u32 *)&lif->info->status.link_speed);\n\t\tdebugfs_create_u16(\"link_down_count\", 0400, stats_dentry,\n\t\t\t\t   (u16 *)&lif->info->status.link_down_count);\n\t}\n}\n\nstatic int netdev_show(struct seq_file *seq, void *v)\n{\n\tstruct net_device *netdev = seq->private;\n\n\tseq_printf(seq, \"%s\\n\", netdev->name);\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(netdev);\n\nstatic int lif_filters_show(struct seq_file *seq, void *v)\n{\n\tstruct ionic_lif *lif = seq->private;\n\tstruct ionic_rx_filter *f;\n\tstruct hlist_head *head;\n\tstruct hlist_node *tmp;\n\tunsigned int i;\n\n\tseq_puts(seq, \"id      flow        state type  filter\\n\");\n\tspin_lock_bh(&lif->rx_filters.lock);\n\tfor (i = 0; i < IONIC_RX_FILTER_HLISTS; i++) {\n\t\thead = &lif->rx_filters.by_id[i];\n\t\thlist_for_each_entry_safe(f, tmp, head, by_id) {\n\t\t\tswitch (le16_to_cpu(f->cmd.match)) {\n\t\t\tcase IONIC_RX_FILTER_MATCH_VLAN:\n\t\t\t\tseq_printf(seq, \"0x%04x  0x%08x  0x%02x  vlan  0x%04x\\n\",\n\t\t\t\t\t   f->filter_id, f->flow_id, f->state,\n\t\t\t\t\t   le16_to_cpu(f->cmd.vlan.vlan));\n\t\t\t\tbreak;\n\t\t\tcase IONIC_RX_FILTER_MATCH_MAC:\n\t\t\t\tseq_printf(seq, \"0x%04x  0x%08x  0x%02x  mac   %pM\\n\",\n\t\t\t\t\t   f->filter_id, f->flow_id, f->state,\n\t\t\t\t\t   f->cmd.mac.addr);\n\t\t\t\tbreak;\n\t\t\tcase IONIC_RX_FILTER_MATCH_MAC_VLAN:\n\t\t\t\tseq_printf(seq, \"0x%04x  0x%08x  0x%02x  macvl 0x%04x %pM\\n\",\n\t\t\t\t\t   f->filter_id, f->flow_id, f->state,\n\t\t\t\t\t   le16_to_cpu(f->cmd.vlan.vlan),\n\t\t\t\t\t   f->cmd.mac.addr);\n\t\t\t\tbreak;\n\t\t\tcase IONIC_RX_FILTER_STEER_PKTCLASS:\n\t\t\t\tseq_printf(seq, \"0x%04x  0x%08x  0x%02x  rxstr 0x%llx\\n\",\n\t\t\t\t\t   f->filter_id, f->flow_id, f->state,\n\t\t\t\t\t   le64_to_cpu(f->cmd.pkt_class));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tspin_unlock_bh(&lif->rx_filters.lock);\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(lif_filters);\n\nvoid ionic_debugfs_add_lif(struct ionic_lif *lif)\n{\n\tstruct dentry *lif_dentry;\n\n\tlif_dentry = debugfs_create_dir(lif->name, lif->ionic->dentry);\n\tif (IS_ERR_OR_NULL(lif_dentry))\n\t\treturn;\n\tlif->dentry = lif_dentry;\n\n\tdebugfs_create_file(\"netdev\", 0400, lif->dentry,\n\t\t\t    lif->netdev, &netdev_fops);\n\tdebugfs_create_file(\"filters\", 0400, lif->dentry,\n\t\t\t    lif, &lif_filters_fops);\n}\n\nvoid ionic_debugfs_del_lif(struct ionic_lif *lif)\n{\n\tdebugfs_remove_recursive(lif->dentry);\n\tlif->dentry = NULL;\n}\n\nvoid ionic_debugfs_del_qcq(struct ionic_qcq *qcq)\n{\n\tdebugfs_remove_recursive(qcq->dentry);\n\tqcq->dentry = NULL;\n}\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}