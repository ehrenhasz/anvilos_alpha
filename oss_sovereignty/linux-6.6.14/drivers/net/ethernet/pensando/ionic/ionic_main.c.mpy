{
  "module_name": "ionic_main.c",
  "hash_id": "ac790c5e56505e6ff44e5cbca5e786ad8cbd602659370d3676b066013ce3de99",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/pensando/ionic/ionic_main.c",
  "human_readable_source": "\n \n\n#include <linux/printk.h>\n#include <linux/dynamic_debug.h>\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/utsname.h>\n#include <generated/utsrelease.h>\n#include <linux/ctype.h>\n\n#include \"ionic.h\"\n#include \"ionic_bus.h\"\n#include \"ionic_lif.h\"\n#include \"ionic_debugfs.h\"\n\nMODULE_DESCRIPTION(IONIC_DRV_DESCRIPTION);\nMODULE_AUTHOR(\"Pensando Systems, Inc\");\nMODULE_LICENSE(\"GPL\");\n\nstatic const char *ionic_error_to_str(enum ionic_status_code code)\n{\n\tswitch (code) {\n\tcase IONIC_RC_SUCCESS:\n\t\treturn \"IONIC_RC_SUCCESS\";\n\tcase IONIC_RC_EVERSION:\n\t\treturn \"IONIC_RC_EVERSION\";\n\tcase IONIC_RC_EOPCODE:\n\t\treturn \"IONIC_RC_EOPCODE\";\n\tcase IONIC_RC_EIO:\n\t\treturn \"IONIC_RC_EIO\";\n\tcase IONIC_RC_EPERM:\n\t\treturn \"IONIC_RC_EPERM\";\n\tcase IONIC_RC_EQID:\n\t\treturn \"IONIC_RC_EQID\";\n\tcase IONIC_RC_EQTYPE:\n\t\treturn \"IONIC_RC_EQTYPE\";\n\tcase IONIC_RC_ENOENT:\n\t\treturn \"IONIC_RC_ENOENT\";\n\tcase IONIC_RC_EINTR:\n\t\treturn \"IONIC_RC_EINTR\";\n\tcase IONIC_RC_EAGAIN:\n\t\treturn \"IONIC_RC_EAGAIN\";\n\tcase IONIC_RC_ENOMEM:\n\t\treturn \"IONIC_RC_ENOMEM\";\n\tcase IONIC_RC_EFAULT:\n\t\treturn \"IONIC_RC_EFAULT\";\n\tcase IONIC_RC_EBUSY:\n\t\treturn \"IONIC_RC_EBUSY\";\n\tcase IONIC_RC_EEXIST:\n\t\treturn \"IONIC_RC_EEXIST\";\n\tcase IONIC_RC_EINVAL:\n\t\treturn \"IONIC_RC_EINVAL\";\n\tcase IONIC_RC_ENOSPC:\n\t\treturn \"IONIC_RC_ENOSPC\";\n\tcase IONIC_RC_ERANGE:\n\t\treturn \"IONIC_RC_ERANGE\";\n\tcase IONIC_RC_BAD_ADDR:\n\t\treturn \"IONIC_RC_BAD_ADDR\";\n\tcase IONIC_RC_DEV_CMD:\n\t\treturn \"IONIC_RC_DEV_CMD\";\n\tcase IONIC_RC_ENOSUPP:\n\t\treturn \"IONIC_RC_ENOSUPP\";\n\tcase IONIC_RC_ERROR:\n\t\treturn \"IONIC_RC_ERROR\";\n\tcase IONIC_RC_ERDMA:\n\t\treturn \"IONIC_RC_ERDMA\";\n\tcase IONIC_RC_EBAD_FW:\n\t\treturn \"IONIC_RC_EBAD_FW\";\n\tdefault:\n\t\treturn \"IONIC_RC_UNKNOWN\";\n\t}\n}\n\nstatic int ionic_error_to_errno(enum ionic_status_code code)\n{\n\tswitch (code) {\n\tcase IONIC_RC_SUCCESS:\n\t\treturn 0;\n\tcase IONIC_RC_EVERSION:\n\tcase IONIC_RC_EQTYPE:\n\tcase IONIC_RC_EQID:\n\tcase IONIC_RC_EINVAL:\n\tcase IONIC_RC_ENOSUPP:\n\t\treturn -EINVAL;\n\tcase IONIC_RC_EPERM:\n\t\treturn -EPERM;\n\tcase IONIC_RC_ENOENT:\n\t\treturn -ENOENT;\n\tcase IONIC_RC_EAGAIN:\n\t\treturn -EAGAIN;\n\tcase IONIC_RC_ENOMEM:\n\t\treturn -ENOMEM;\n\tcase IONIC_RC_EFAULT:\n\t\treturn -EFAULT;\n\tcase IONIC_RC_EBUSY:\n\t\treturn -EBUSY;\n\tcase IONIC_RC_EEXIST:\n\t\treturn -EEXIST;\n\tcase IONIC_RC_ENOSPC:\n\t\treturn -ENOSPC;\n\tcase IONIC_RC_ERANGE:\n\t\treturn -ERANGE;\n\tcase IONIC_RC_BAD_ADDR:\n\t\treturn -EFAULT;\n\tcase IONIC_RC_EOPCODE:\n\tcase IONIC_RC_EINTR:\n\tcase IONIC_RC_DEV_CMD:\n\tcase IONIC_RC_ERROR:\n\tcase IONIC_RC_ERDMA:\n\tcase IONIC_RC_EIO:\n\tdefault:\n\t\treturn -EIO;\n\t}\n}\n\nstatic const char *ionic_opcode_to_str(enum ionic_cmd_opcode opcode)\n{\n\tswitch (opcode) {\n\tcase IONIC_CMD_NOP:\n\t\treturn \"IONIC_CMD_NOP\";\n\tcase IONIC_CMD_INIT:\n\t\treturn \"IONIC_CMD_INIT\";\n\tcase IONIC_CMD_RESET:\n\t\treturn \"IONIC_CMD_RESET\";\n\tcase IONIC_CMD_IDENTIFY:\n\t\treturn \"IONIC_CMD_IDENTIFY\";\n\tcase IONIC_CMD_GETATTR:\n\t\treturn \"IONIC_CMD_GETATTR\";\n\tcase IONIC_CMD_SETATTR:\n\t\treturn \"IONIC_CMD_SETATTR\";\n\tcase IONIC_CMD_PORT_IDENTIFY:\n\t\treturn \"IONIC_CMD_PORT_IDENTIFY\";\n\tcase IONIC_CMD_PORT_INIT:\n\t\treturn \"IONIC_CMD_PORT_INIT\";\n\tcase IONIC_CMD_PORT_RESET:\n\t\treturn \"IONIC_CMD_PORT_RESET\";\n\tcase IONIC_CMD_PORT_GETATTR:\n\t\treturn \"IONIC_CMD_PORT_GETATTR\";\n\tcase IONIC_CMD_PORT_SETATTR:\n\t\treturn \"IONIC_CMD_PORT_SETATTR\";\n\tcase IONIC_CMD_LIF_INIT:\n\t\treturn \"IONIC_CMD_LIF_INIT\";\n\tcase IONIC_CMD_LIF_RESET:\n\t\treturn \"IONIC_CMD_LIF_RESET\";\n\tcase IONIC_CMD_LIF_IDENTIFY:\n\t\treturn \"IONIC_CMD_LIF_IDENTIFY\";\n\tcase IONIC_CMD_LIF_SETATTR:\n\t\treturn \"IONIC_CMD_LIF_SETATTR\";\n\tcase IONIC_CMD_LIF_GETATTR:\n\t\treturn \"IONIC_CMD_LIF_GETATTR\";\n\tcase IONIC_CMD_LIF_SETPHC:\n\t\treturn \"IONIC_CMD_LIF_SETPHC\";\n\tcase IONIC_CMD_RX_MODE_SET:\n\t\treturn \"IONIC_CMD_RX_MODE_SET\";\n\tcase IONIC_CMD_RX_FILTER_ADD:\n\t\treturn \"IONIC_CMD_RX_FILTER_ADD\";\n\tcase IONIC_CMD_RX_FILTER_DEL:\n\t\treturn \"IONIC_CMD_RX_FILTER_DEL\";\n\tcase IONIC_CMD_Q_IDENTIFY:\n\t\treturn \"IONIC_CMD_Q_IDENTIFY\";\n\tcase IONIC_CMD_Q_INIT:\n\t\treturn \"IONIC_CMD_Q_INIT\";\n\tcase IONIC_CMD_Q_CONTROL:\n\t\treturn \"IONIC_CMD_Q_CONTROL\";\n\tcase IONIC_CMD_RDMA_RESET_LIF:\n\t\treturn \"IONIC_CMD_RDMA_RESET_LIF\";\n\tcase IONIC_CMD_RDMA_CREATE_EQ:\n\t\treturn \"IONIC_CMD_RDMA_CREATE_EQ\";\n\tcase IONIC_CMD_RDMA_CREATE_CQ:\n\t\treturn \"IONIC_CMD_RDMA_CREATE_CQ\";\n\tcase IONIC_CMD_RDMA_CREATE_ADMINQ:\n\t\treturn \"IONIC_CMD_RDMA_CREATE_ADMINQ\";\n\tcase IONIC_CMD_FW_DOWNLOAD:\n\t\treturn \"IONIC_CMD_FW_DOWNLOAD\";\n\tcase IONIC_CMD_FW_CONTROL:\n\t\treturn \"IONIC_CMD_FW_CONTROL\";\n\tcase IONIC_CMD_FW_DOWNLOAD_V1:\n\t\treturn \"IONIC_CMD_FW_DOWNLOAD_V1\";\n\tcase IONIC_CMD_FW_CONTROL_V1:\n\t\treturn \"IONIC_CMD_FW_CONTROL_V1\";\n\tcase IONIC_CMD_VF_GETATTR:\n\t\treturn \"IONIC_CMD_VF_GETATTR\";\n\tcase IONIC_CMD_VF_SETATTR:\n\t\treturn \"IONIC_CMD_VF_SETATTR\";\n\tdefault:\n\t\treturn \"DEVCMD_UNKNOWN\";\n\t}\n}\n\nconst char *ionic_vf_attr_to_str(enum ionic_vf_attr attr)\n{\n\tswitch (attr) {\n\tcase IONIC_VF_ATTR_SPOOFCHK:\n\t\treturn \"IONIC_VF_ATTR_SPOOFCHK\";\n\tcase IONIC_VF_ATTR_TRUST:\n\t\treturn \"IONIC_VF_ATTR_TRUST\";\n\tcase IONIC_VF_ATTR_LINKSTATE:\n\t\treturn \"IONIC_VF_ATTR_LINKSTATE\";\n\tcase IONIC_VF_ATTR_MAC:\n\t\treturn \"IONIC_VF_ATTR_MAC\";\n\tcase IONIC_VF_ATTR_VLAN:\n\t\treturn \"IONIC_VF_ATTR_VLAN\";\n\tcase IONIC_VF_ATTR_RATE:\n\t\treturn \"IONIC_VF_ATTR_RATE\";\n\tcase IONIC_VF_ATTR_STATSADDR:\n\t\treturn \"IONIC_VF_ATTR_STATSADDR\";\n\tdefault:\n\t\treturn \"IONIC_VF_ATTR_UNKNOWN\";\n\t}\n}\n\nstatic void ionic_adminq_flush(struct ionic_lif *lif)\n{\n\tstruct ionic_desc_info *desc_info;\n\tunsigned long irqflags;\n\tstruct ionic_queue *q;\n\n\tspin_lock_irqsave(&lif->adminq_lock, irqflags);\n\tif (!lif->adminqcq) {\n\t\tspin_unlock_irqrestore(&lif->adminq_lock, irqflags);\n\t\treturn;\n\t}\n\n\tq = &lif->adminqcq->q;\n\n\twhile (q->tail_idx != q->head_idx) {\n\t\tdesc_info = &q->info[q->tail_idx];\n\t\tmemset(desc_info->desc, 0, sizeof(union ionic_adminq_cmd));\n\t\tdesc_info->cb = NULL;\n\t\tdesc_info->cb_arg = NULL;\n\t\tq->tail_idx = (q->tail_idx + 1) & (q->num_descs - 1);\n\t}\n\tspin_unlock_irqrestore(&lif->adminq_lock, irqflags);\n}\n\nvoid ionic_adminq_netdev_err_print(struct ionic_lif *lif, u8 opcode,\n\t\t\t\t   u8 status, int err)\n{\n\tconst char *stat_str;\n\n\tstat_str = (err == -ETIMEDOUT) ? \"TIMEOUT\" :\n\t\t\t\t\t ionic_error_to_str(status);\n\n\tnetdev_err(lif->netdev, \"%s (%d) failed: %s (%d)\\n\",\n\t\t   ionic_opcode_to_str(opcode), opcode, stat_str, err);\n}\n\nstatic int ionic_adminq_check_err(struct ionic_lif *lif,\n\t\t\t\t  struct ionic_admin_ctx *ctx,\n\t\t\t\t  const bool timeout,\n\t\t\t\t  const bool do_msg)\n{\n\tint err = 0;\n\n\tif (ctx->comp.comp.status || timeout) {\n\t\terr = timeout ? -ETIMEDOUT :\n\t\t\t\tionic_error_to_errno(ctx->comp.comp.status);\n\n\t\tif (do_msg)\n\t\t\tionic_adminq_netdev_err_print(lif, ctx->cmd.cmd.opcode,\n\t\t\t\t\t\t      ctx->comp.comp.status, err);\n\n\t\tif (timeout)\n\t\t\tionic_adminq_flush(lif);\n\t}\n\n\treturn err;\n}\n\nstatic void ionic_adminq_cb(struct ionic_queue *q,\n\t\t\t    struct ionic_desc_info *desc_info,\n\t\t\t    struct ionic_cq_info *cq_info, void *cb_arg)\n{\n\tstruct ionic_admin_ctx *ctx = cb_arg;\n\tstruct ionic_admin_comp *comp;\n\n\tif (!ctx)\n\t\treturn;\n\n\tcomp = cq_info->cq_desc;\n\n\tmemcpy(&ctx->comp, comp, sizeof(*comp));\n\n\tdev_dbg(q->dev, \"comp admin queue command:\\n\");\n\tdynamic_hex_dump(\"comp \", DUMP_PREFIX_OFFSET, 16, 1,\n\t\t\t &ctx->comp, sizeof(ctx->comp), true);\n\n\tcomplete_all(&ctx->work);\n}\n\nbool ionic_adminq_poke_doorbell(struct ionic_queue *q)\n{\n\tstruct ionic_lif *lif = q->lif;\n\tunsigned long now, then, dif;\n\tunsigned long irqflags;\n\n\tspin_lock_irqsave(&lif->adminq_lock, irqflags);\n\n\tif (q->tail_idx == q->head_idx) {\n\t\tspin_unlock_irqrestore(&lif->adminq_lock, irqflags);\n\t\treturn false;\n\t}\n\n\tnow = READ_ONCE(jiffies);\n\tthen = q->dbell_jiffies;\n\tdif = now - then;\n\n\tif (dif > q->dbell_deadline) {\n\t\tionic_dbell_ring(q->lif->kern_dbpage, q->hw_type,\n\t\t\t\t q->dbval | q->head_idx);\n\n\t\tq->dbell_jiffies = now;\n\t}\n\n\tspin_unlock_irqrestore(&lif->adminq_lock, irqflags);\n\n\treturn true;\n}\n\nint ionic_adminq_post(struct ionic_lif *lif, struct ionic_admin_ctx *ctx)\n{\n\tstruct ionic_desc_info *desc_info;\n\tunsigned long irqflags;\n\tstruct ionic_queue *q;\n\tint err = 0;\n\n\tspin_lock_irqsave(&lif->adminq_lock, irqflags);\n\tif (!lif->adminqcq) {\n\t\tspin_unlock_irqrestore(&lif->adminq_lock, irqflags);\n\t\treturn -EIO;\n\t}\n\n\tq = &lif->adminqcq->q;\n\n\tif (!ionic_q_has_space(q, 1)) {\n\t\terr = -ENOSPC;\n\t\tgoto err_out;\n\t}\n\n\terr = ionic_heartbeat_check(lif->ionic);\n\tif (err)\n\t\tgoto err_out;\n\n\tdesc_info = &q->info[q->head_idx];\n\tmemcpy(desc_info->desc, &ctx->cmd, sizeof(ctx->cmd));\n\n\tdev_dbg(&lif->netdev->dev, \"post admin queue command:\\n\");\n\tdynamic_hex_dump(\"cmd \", DUMP_PREFIX_OFFSET, 16, 1,\n\t\t\t &ctx->cmd, sizeof(ctx->cmd), true);\n\n\tionic_q_post(q, true, ionic_adminq_cb, ctx);\n\nerr_out:\n\tspin_unlock_irqrestore(&lif->adminq_lock, irqflags);\n\n\treturn err;\n}\n\nint ionic_adminq_wait(struct ionic_lif *lif, struct ionic_admin_ctx *ctx,\n\t\t      const int err, const bool do_msg)\n{\n\tstruct net_device *netdev = lif->netdev;\n\tunsigned long time_limit;\n\tunsigned long time_start;\n\tunsigned long time_done;\n\tunsigned long remaining;\n\tconst char *name;\n\n\tname = ionic_opcode_to_str(ctx->cmd.cmd.opcode);\n\n\tif (err) {\n\t\tif (do_msg && !test_bit(IONIC_LIF_F_FW_RESET, lif->state))\n\t\t\tnetdev_err(netdev, \"Posting of %s (%d) failed: %d\\n\",\n\t\t\t\t   name, ctx->cmd.cmd.opcode, err);\n\t\tctx->comp.comp.status = IONIC_RC_ERROR;\n\t\treturn err;\n\t}\n\n\ttime_start = jiffies;\n\ttime_limit = time_start + HZ * (ulong)DEVCMD_TIMEOUT;\n\tdo {\n\t\tremaining = wait_for_completion_timeout(&ctx->work,\n\t\t\t\t\t\t\tIONIC_ADMINQ_TIME_SLICE);\n\n\t\t \n\t\tif (remaining)\n\t\t\tbreak;\n\n\t\t \n\t\tionic_heartbeat_check(lif->ionic);\n\t\tif ((test_bit(IONIC_LIF_F_FW_RESET, lif->state) &&\n\t\t     !lif->ionic->idev.fw_status_ready) ||\n\t\t    test_bit(IONIC_LIF_F_FW_STOPPING, lif->state)) {\n\t\t\tif (do_msg)\n\t\t\t\tnetdev_warn(netdev, \"%s (%d) interrupted, FW in reset\\n\",\n\t\t\t\t\t    name, ctx->cmd.cmd.opcode);\n\t\t\tctx->comp.comp.status = IONIC_RC_ERROR;\n\t\t\treturn -ENXIO;\n\t\t}\n\n\t} while (time_before(jiffies, time_limit));\n\ttime_done = jiffies;\n\n\tdev_dbg(lif->ionic->dev, \"%s: elapsed %d msecs\\n\",\n\t\t__func__, jiffies_to_msecs(time_done - time_start));\n\n\treturn ionic_adminq_check_err(lif, ctx,\n\t\t\t\t      time_after_eq(time_done, time_limit),\n\t\t\t\t      do_msg);\n}\n\nint ionic_adminq_post_wait(struct ionic_lif *lif, struct ionic_admin_ctx *ctx)\n{\n\tint err;\n\n\terr = ionic_adminq_post(lif, ctx);\n\n\treturn ionic_adminq_wait(lif, ctx, err, true);\n}\n\nint ionic_adminq_post_wait_nomsg(struct ionic_lif *lif, struct ionic_admin_ctx *ctx)\n{\n\tint err;\n\n\terr = ionic_adminq_post(lif, ctx);\n\n\treturn ionic_adminq_wait(lif, ctx, err, false);\n}\n\nstatic void ionic_dev_cmd_clean(struct ionic *ionic)\n{\n\tstruct ionic_dev *idev = &ionic->idev;\n\n\tiowrite32(0, &idev->dev_cmd_regs->doorbell);\n\tmemset_io(&idev->dev_cmd_regs->cmd, 0, sizeof(idev->dev_cmd_regs->cmd));\n}\n\nvoid ionic_dev_cmd_dev_err_print(struct ionic *ionic, u8 opcode, u8 status,\n\t\t\t\t int err)\n{\n\tconst char *stat_str;\n\n\tstat_str = (err == -ETIMEDOUT) ? \"TIMEOUT\" :\n\t\t\t\t\t ionic_error_to_str(status);\n\n\tdev_err(ionic->dev, \"DEV_CMD %s (%d) error, %s (%d) failed\\n\",\n\t\tionic_opcode_to_str(opcode), opcode, stat_str, err);\n}\n\nstatic int __ionic_dev_cmd_wait(struct ionic *ionic, unsigned long max_seconds,\n\t\t\t\tconst bool do_msg)\n{\n\tstruct ionic_dev *idev = &ionic->idev;\n\tunsigned long start_time;\n\tunsigned long max_wait;\n\tunsigned long duration;\n\tint done = 0;\n\tbool fw_up;\n\tint opcode;\n\tint err;\n\n\t \n\tmax_wait = jiffies + (max_seconds * HZ);\ntry_again:\n\topcode = readb(&idev->dev_cmd_regs->cmd.cmd.opcode);\n\tstart_time = jiffies;\n\tfor (fw_up = ionic_is_fw_running(idev);\n\t     !done && fw_up && time_before(jiffies, max_wait);\n\t     fw_up = ionic_is_fw_running(idev)) {\n\t\tdone = ionic_dev_cmd_done(idev);\n\t\tif (done)\n\t\t\tbreak;\n\t\tusleep_range(100, 200);\n\t}\n\tduration = jiffies - start_time;\n\n\tdev_dbg(ionic->dev, \"DEVCMD %s (%d) done=%d took %ld secs (%ld jiffies)\\n\",\n\t\tionic_opcode_to_str(opcode), opcode,\n\t\tdone, duration / HZ, duration);\n\n\tif (!done && !fw_up) {\n\t\tionic_dev_cmd_clean(ionic);\n\t\tdev_warn(ionic->dev, \"DEVCMD %s (%d) interrupted - FW is down\\n\",\n\t\t\t ionic_opcode_to_str(opcode), opcode);\n\t\treturn -ENXIO;\n\t}\n\n\tif (!done && !time_before(jiffies, max_wait)) {\n\t\tionic_dev_cmd_clean(ionic);\n\t\tdev_warn(ionic->dev, \"DEVCMD %s (%d) timeout after %ld secs\\n\",\n\t\t\t ionic_opcode_to_str(opcode), opcode, max_seconds);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\terr = ionic_dev_cmd_status(&ionic->idev);\n\tif (err) {\n\t\tif (err == IONIC_RC_EAGAIN &&\n\t\t    time_before(jiffies, (max_wait - HZ))) {\n\t\t\tdev_dbg(ionic->dev, \"DEV_CMD %s (%d), %s (%d) retrying...\\n\",\n\t\t\t\tionic_opcode_to_str(opcode), opcode,\n\t\t\t\tionic_error_to_str(err), err);\n\n\t\t\tiowrite32(0, &idev->dev_cmd_regs->done);\n\t\t\tmsleep(1000);\n\t\t\tiowrite32(1, &idev->dev_cmd_regs->doorbell);\n\t\t\tgoto try_again;\n\t\t}\n\n\t\tif (!(opcode == IONIC_CMD_FW_CONTROL && err == IONIC_RC_EAGAIN))\n\t\t\tif (do_msg)\n\t\t\t\tionic_dev_cmd_dev_err_print(ionic, opcode, err,\n\t\t\t\t\t\t\t    ionic_error_to_errno(err));\n\n\t\treturn ionic_error_to_errno(err);\n\t}\n\n\tionic_dev_cmd_clean(ionic);\n\n\treturn 0;\n}\n\nint ionic_dev_cmd_wait(struct ionic *ionic, unsigned long max_seconds)\n{\n\treturn __ionic_dev_cmd_wait(ionic, max_seconds, true);\n}\n\nint ionic_dev_cmd_wait_nomsg(struct ionic *ionic, unsigned long max_seconds)\n{\n\treturn __ionic_dev_cmd_wait(ionic, max_seconds, false);\n}\n\nint ionic_setup(struct ionic *ionic)\n{\n\tint err;\n\n\terr = ionic_dev_setup(ionic);\n\tif (err)\n\t\treturn err;\n\tionic_reset(ionic);\n\n\treturn 0;\n}\n\nint ionic_identify(struct ionic *ionic)\n{\n\tstruct ionic_identity *ident = &ionic->ident;\n\tstruct ionic_dev *idev = &ionic->idev;\n\tsize_t sz;\n\tint err;\n\n\tmemset(ident, 0, sizeof(*ident));\n\n\tident->drv.os_type = cpu_to_le32(IONIC_OS_TYPE_LINUX);\n\tstrncpy(ident->drv.driver_ver_str, UTS_RELEASE,\n\t\tsizeof(ident->drv.driver_ver_str) - 1);\n\n\tmutex_lock(&ionic->dev_cmd_lock);\n\n\tsz = min(sizeof(ident->drv), sizeof(idev->dev_cmd_regs->data));\n\tmemcpy_toio(&idev->dev_cmd_regs->data, &ident->drv, sz);\n\n\tionic_dev_cmd_identify(idev, IONIC_DEV_IDENTITY_VERSION_2);\n\terr = ionic_dev_cmd_wait(ionic, DEVCMD_TIMEOUT);\n\tif (!err) {\n\t\tsz = min(sizeof(ident->dev), sizeof(idev->dev_cmd_regs->data));\n\t\tmemcpy_fromio(&ident->dev, &idev->dev_cmd_regs->data, sz);\n\t}\n\tmutex_unlock(&ionic->dev_cmd_lock);\n\n\tif (err) {\n\t\tdev_err(ionic->dev, \"Cannot identify ionic: %d\\n\", err);\n\t\tgoto err_out;\n\t}\n\n\tif (isprint(idev->dev_info.fw_version[0]) &&\n\t    isascii(idev->dev_info.fw_version[0]))\n\t\tdev_info(ionic->dev, \"FW: %.*s\\n\",\n\t\t\t (int)(sizeof(idev->dev_info.fw_version) - 1),\n\t\t\t idev->dev_info.fw_version);\n\telse\n\t\tdev_info(ionic->dev, \"FW: (invalid string) 0x%02x 0x%02x 0x%02x 0x%02x ...\\n\",\n\t\t\t (u8)idev->dev_info.fw_version[0],\n\t\t\t (u8)idev->dev_info.fw_version[1],\n\t\t\t (u8)idev->dev_info.fw_version[2],\n\t\t\t (u8)idev->dev_info.fw_version[3]);\n\n\terr = ionic_lif_identify(ionic, IONIC_LIF_TYPE_CLASSIC,\n\t\t\t\t &ionic->ident.lif);\n\tif (err) {\n\t\tdev_err(ionic->dev, \"Cannot identify LIFs: %d\\n\", err);\n\t\tgoto err_out;\n\t}\n\n\treturn 0;\n\nerr_out:\n\treturn err;\n}\n\nint ionic_init(struct ionic *ionic)\n{\n\tstruct ionic_dev *idev = &ionic->idev;\n\tint err;\n\n\tmutex_lock(&ionic->dev_cmd_lock);\n\tionic_dev_cmd_init(idev);\n\terr = ionic_dev_cmd_wait(ionic, DEVCMD_TIMEOUT);\n\tmutex_unlock(&ionic->dev_cmd_lock);\n\n\treturn err;\n}\n\nint ionic_reset(struct ionic *ionic)\n{\n\tstruct ionic_dev *idev = &ionic->idev;\n\tint err;\n\n\tif (!ionic_is_fw_running(idev))\n\t\treturn 0;\n\n\tmutex_lock(&ionic->dev_cmd_lock);\n\tionic_dev_cmd_reset(idev);\n\terr = ionic_dev_cmd_wait(ionic, DEVCMD_TIMEOUT);\n\tmutex_unlock(&ionic->dev_cmd_lock);\n\n\treturn err;\n}\n\nint ionic_port_identify(struct ionic *ionic)\n{\n\tstruct ionic_identity *ident = &ionic->ident;\n\tstruct ionic_dev *idev = &ionic->idev;\n\tsize_t sz;\n\tint err;\n\n\tmutex_lock(&ionic->dev_cmd_lock);\n\n\tionic_dev_cmd_port_identify(idev);\n\terr = ionic_dev_cmd_wait(ionic, DEVCMD_TIMEOUT);\n\tif (!err) {\n\t\tsz = min(sizeof(ident->port), sizeof(idev->dev_cmd_regs->data));\n\t\tmemcpy_fromio(&ident->port, &idev->dev_cmd_regs->data, sz);\n\t}\n\n\tmutex_unlock(&ionic->dev_cmd_lock);\n\n\treturn err;\n}\n\nint ionic_port_init(struct ionic *ionic)\n{\n\tstruct ionic_identity *ident = &ionic->ident;\n\tstruct ionic_dev *idev = &ionic->idev;\n\tsize_t sz;\n\tint err;\n\n\tif (!idev->port_info) {\n\t\tidev->port_info_sz = ALIGN(sizeof(*idev->port_info), PAGE_SIZE);\n\t\tidev->port_info = dma_alloc_coherent(ionic->dev,\n\t\t\t\t\t\t     idev->port_info_sz,\n\t\t\t\t\t\t     &idev->port_info_pa,\n\t\t\t\t\t\t     GFP_KERNEL);\n\t\tif (!idev->port_info)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tsz = min(sizeof(ident->port.config), sizeof(idev->dev_cmd_regs->data));\n\n\tmutex_lock(&ionic->dev_cmd_lock);\n\n\tmemcpy_toio(&idev->dev_cmd_regs->data, &ident->port.config, sz);\n\tionic_dev_cmd_port_init(idev);\n\terr = ionic_dev_cmd_wait(ionic, DEVCMD_TIMEOUT);\n\n\tionic_dev_cmd_port_state(&ionic->idev, IONIC_PORT_ADMIN_STATE_UP);\n\tionic_dev_cmd_wait(ionic, DEVCMD_TIMEOUT);\n\n\tmutex_unlock(&ionic->dev_cmd_lock);\n\tif (err) {\n\t\tdev_err(ionic->dev, \"Failed to init port\\n\");\n\t\tdma_free_coherent(ionic->dev, idev->port_info_sz,\n\t\t\t\t  idev->port_info, idev->port_info_pa);\n\t\tidev->port_info = NULL;\n\t\tidev->port_info_pa = 0;\n\t}\n\n\treturn err;\n}\n\nint ionic_port_reset(struct ionic *ionic)\n{\n\tstruct ionic_dev *idev = &ionic->idev;\n\tint err = 0;\n\n\tif (!idev->port_info)\n\t\treturn 0;\n\n\tif (ionic_is_fw_running(idev)) {\n\t\tmutex_lock(&ionic->dev_cmd_lock);\n\t\tionic_dev_cmd_port_reset(idev);\n\t\terr = ionic_dev_cmd_wait(ionic, DEVCMD_TIMEOUT);\n\t\tmutex_unlock(&ionic->dev_cmd_lock);\n\t}\n\n\tdma_free_coherent(ionic->dev, idev->port_info_sz,\n\t\t\t  idev->port_info, idev->port_info_pa);\n\n\tidev->port_info = NULL;\n\tidev->port_info_pa = 0;\n\n\treturn err;\n}\n\nstatic int __init ionic_init_module(void)\n{\n\tint ret;\n\n\tionic_debugfs_create();\n\tret = ionic_bus_register_driver();\n\tif (ret)\n\t\tionic_debugfs_destroy();\n\n\treturn ret;\n}\n\nstatic void __exit ionic_cleanup_module(void)\n{\n\tionic_bus_unregister_driver();\n\tionic_debugfs_destroy();\n\n\tpr_info(\"%s removed\\n\", IONIC_DRV_NAME);\n}\n\nmodule_init(ionic_init_module);\nmodule_exit(ionic_cleanup_module);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}