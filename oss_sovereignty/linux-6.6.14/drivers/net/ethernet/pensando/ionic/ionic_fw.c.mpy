{
  "module_name": "ionic_fw.c",
  "hash_id": "c596145b3137337ea048ec1ae2133651b3d68818d83dba96f18d8a2aee81c8e6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/pensando/ionic/ionic_fw.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/errno.h>\n#include <linux/firmware.h>\n\n#include \"ionic.h\"\n#include \"ionic_dev.h\"\n#include \"ionic_lif.h\"\n#include \"ionic_devlink.h\"\n\n \n#define IONIC_FW_INSTALL_TIMEOUT\t(25 * 60)\n#define IONIC_FW_SELECT_TIMEOUT\t\t30\n\n \n#define IONIC_FW_INTERVAL_FRACTION\t32\n\nstatic void ionic_dev_cmd_firmware_download(struct ionic_dev *idev, u64 addr,\n\t\t\t\t\t    u32 offset, u32 length)\n{\n\tunion ionic_dev_cmd cmd = {\n\t\t.fw_download.opcode = IONIC_CMD_FW_DOWNLOAD,\n\t\t.fw_download.offset = cpu_to_le32(offset),\n\t\t.fw_download.addr = cpu_to_le64(addr),\n\t\t.fw_download.length = cpu_to_le32(length),\n\t};\n\n\tionic_dev_cmd_go(idev, &cmd);\n}\n\nstatic void ionic_dev_cmd_firmware_install(struct ionic_dev *idev)\n{\n\tunion ionic_dev_cmd cmd = {\n\t\t.fw_control.opcode = IONIC_CMD_FW_CONTROL,\n\t\t.fw_control.oper = IONIC_FW_INSTALL_ASYNC\n\t};\n\n\tionic_dev_cmd_go(idev, &cmd);\n}\n\nstatic void ionic_dev_cmd_firmware_activate(struct ionic_dev *idev, u8 slot)\n{\n\tunion ionic_dev_cmd cmd = {\n\t\t.fw_control.opcode = IONIC_CMD_FW_CONTROL,\n\t\t.fw_control.oper = IONIC_FW_ACTIVATE_ASYNC,\n\t\t.fw_control.slot = slot\n\t};\n\n\tionic_dev_cmd_go(idev, &cmd);\n}\n\nstatic int ionic_fw_status_long_wait(struct ionic *ionic,\n\t\t\t\t     const char *label,\n\t\t\t\t     unsigned long timeout,\n\t\t\t\t     u8 fw_cmd,\n\t\t\t\t     struct netlink_ext_ack *extack)\n{\n\tunion ionic_dev_cmd cmd = {\n\t\t.fw_control.opcode = IONIC_CMD_FW_CONTROL,\n\t\t.fw_control.oper = fw_cmd,\n\t};\n\tunsigned long start_time;\n\tunsigned long end_time;\n\tint err;\n\n\tstart_time = jiffies;\n\tend_time = start_time + (timeout * HZ);\n\tdo {\n\t\tmutex_lock(&ionic->dev_cmd_lock);\n\t\tionic_dev_cmd_go(&ionic->idev, &cmd);\n\t\terr = ionic_dev_cmd_wait(ionic, DEVCMD_TIMEOUT);\n\t\tmutex_unlock(&ionic->dev_cmd_lock);\n\n\t\tmsleep(20);\n\t} while (time_before(jiffies, end_time) && (err == -EAGAIN || err == -ETIMEDOUT));\n\n\tif (err == -EAGAIN || err == -ETIMEDOUT) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Firmware wait timed out\");\n\t\tdev_err(ionic->dev, \"DEV_CMD firmware wait %s timed out\\n\", label);\n\t} else if (err) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Firmware wait failed\");\n\t}\n\n\treturn err;\n}\n\nint ionic_firmware_update(struct ionic_lif *lif, const struct firmware *fw,\n\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct ionic_dev *idev = &lif->ionic->idev;\n\tstruct net_device *netdev = lif->netdev;\n\tstruct ionic *ionic = lif->ionic;\n\tunion ionic_dev_cmd_comp comp;\n\tu32 buf_sz, copy_sz, offset;\n\tstruct devlink *dl;\n\tint next_interval;\n\tint err = 0;\n\tu8 fw_slot;\n\n\tnetdev_info(netdev, \"Installing firmware\\n\");\n\n\tdl = priv_to_devlink(ionic);\n\tdevlink_flash_update_status_notify(dl, \"Preparing to flash\", NULL, 0, 0);\n\n\tbuf_sz = sizeof(idev->dev_cmd_regs->data);\n\n\tnetdev_dbg(netdev,\n\t\t   \"downloading firmware - size %d part_sz %d nparts %lu\\n\",\n\t\t   (int)fw->size, buf_sz, DIV_ROUND_UP(fw->size, buf_sz));\n\n\toffset = 0;\n\tnext_interval = 0;\n\twhile (offset < fw->size) {\n\t\tif (offset >= next_interval) {\n\t\t\tdevlink_flash_update_status_notify(dl, \"Downloading\", NULL,\n\t\t\t\t\t\t\t   offset, fw->size);\n\t\t\tnext_interval = offset + (fw->size / IONIC_FW_INTERVAL_FRACTION);\n\t\t}\n\n\t\tcopy_sz = min_t(unsigned int, buf_sz, fw->size - offset);\n\t\tmutex_lock(&ionic->dev_cmd_lock);\n\t\tmemcpy_toio(&idev->dev_cmd_regs->data, fw->data + offset, copy_sz);\n\t\tionic_dev_cmd_firmware_download(idev,\n\t\t\t\t\t\toffsetof(union ionic_dev_cmd_regs, data),\n\t\t\t\t\t\toffset, copy_sz);\n\t\terr = ionic_dev_cmd_wait(ionic, DEVCMD_TIMEOUT);\n\t\tmutex_unlock(&ionic->dev_cmd_lock);\n\t\tif (err) {\n\t\t\tnetdev_err(netdev,\n\t\t\t\t   \"download failed offset 0x%x addr 0x%lx len 0x%x\\n\",\n\t\t\t\t   offset, offsetof(union ionic_dev_cmd_regs, data),\n\t\t\t\t   copy_sz);\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Segment download failed\");\n\t\t\tgoto err_out;\n\t\t}\n\t\toffset += copy_sz;\n\t}\n\tdevlink_flash_update_status_notify(dl, \"Downloading\", NULL,\n\t\t\t\t\t   fw->size, fw->size);\n\n\tdevlink_flash_update_timeout_notify(dl, \"Installing\", NULL,\n\t\t\t\t\t    IONIC_FW_INSTALL_TIMEOUT);\n\n\tmutex_lock(&ionic->dev_cmd_lock);\n\tionic_dev_cmd_firmware_install(idev);\n\terr = ionic_dev_cmd_wait(ionic, DEVCMD_TIMEOUT);\n\tionic_dev_cmd_comp(idev, (union ionic_dev_cmd_comp *)&comp);\n\tfw_slot = comp.fw_control.slot;\n\tmutex_unlock(&ionic->dev_cmd_lock);\n\tif (err) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Failed to start firmware install\");\n\t\tgoto err_out;\n\t}\n\n\terr = ionic_fw_status_long_wait(ionic, \"Installing\",\n\t\t\t\t\tIONIC_FW_INSTALL_TIMEOUT,\n\t\t\t\t\tIONIC_FW_INSTALL_STATUS,\n\t\t\t\t\textack);\n\tif (err)\n\t\tgoto err_out;\n\n\tdevlink_flash_update_timeout_notify(dl, \"Selecting\", NULL,\n\t\t\t\t\t    IONIC_FW_SELECT_TIMEOUT);\n\n\tmutex_lock(&ionic->dev_cmd_lock);\n\tionic_dev_cmd_firmware_activate(idev, fw_slot);\n\terr = ionic_dev_cmd_wait(ionic, DEVCMD_TIMEOUT);\n\tmutex_unlock(&ionic->dev_cmd_lock);\n\tif (err) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Failed to start firmware select\");\n\t\tgoto err_out;\n\t}\n\n\terr = ionic_fw_status_long_wait(ionic, \"Selecting\",\n\t\t\t\t\tIONIC_FW_SELECT_TIMEOUT,\n\t\t\t\t\tIONIC_FW_ACTIVATE_STATUS,\n\t\t\t\t\textack);\n\tif (err)\n\t\tgoto err_out;\n\n\tnetdev_info(netdev, \"Firmware update completed\\n\");\n\nerr_out:\n\tif (err)\n\t\tdevlink_flash_update_status_notify(dl, \"Flash failed\", NULL, 0, 0);\n\telse\n\t\tdevlink_flash_update_status_notify(dl, \"Flash done\", NULL, 0, 0);\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}