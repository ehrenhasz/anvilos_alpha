{
  "module_name": "ionic_lif.h",
  "hash_id": "f119182859e88be28d3657a4832d0a527f0b20043c31654887d5dbdd497cbbb3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/pensando/ionic/ionic_lif.h",
  "human_readable_source": " \n \n\n#ifndef _IONIC_LIF_H_\n#define _IONIC_LIF_H_\n\n#include <linux/ptp_clock_kernel.h>\n#include <linux/timecounter.h>\n#include <uapi/linux/net_tstamp.h>\n#include <linux/dim.h>\n#include <linux/pci.h>\n#include \"ionic_rx_filter.h\"\n\n#define IONIC_ADMINQ_LENGTH\t16\t \n#define IONIC_NOTIFYQ_LENGTH\t64\t \n\n#define ADD_ADDR\ttrue\n#define DEL_ADDR\tfalse\n#define CAN_SLEEP\ttrue\n#define CAN_NOT_SLEEP\tfalse\n\n#define IONIC_RX_COPYBREAK_DEFAULT\t256\n#define IONIC_TX_BUDGET_DEFAULT\t\t256\n\nstruct ionic_tx_stats {\n\tu64 pkts;\n\tu64 bytes;\n\tu64 csum_none;\n\tu64 csum;\n\tu64 tso;\n\tu64 tso_bytes;\n\tu64 frags;\n\tu64 vlan_inserted;\n\tu64 clean;\n\tu64 linearize;\n\tu64 crc32_csum;\n\tu64 dma_map_err;\n\tu64 hwstamp_valid;\n\tu64 hwstamp_invalid;\n};\n\nstruct ionic_rx_stats {\n\tu64 pkts;\n\tu64 bytes;\n\tu64 csum_none;\n\tu64 csum_complete;\n\tu64 dropped;\n\tu64 vlan_stripped;\n\tu64 csum_error;\n\tu64 dma_map_err;\n\tu64 alloc_err;\n\tu64 hwstamp_valid;\n\tu64 hwstamp_invalid;\n};\n\n#define IONIC_QCQ_F_INITED\t\tBIT(0)\n#define IONIC_QCQ_F_SG\t\t\tBIT(1)\n#define IONIC_QCQ_F_INTR\t\tBIT(2)\n#define IONIC_QCQ_F_TX_STATS\t\tBIT(3)\n#define IONIC_QCQ_F_RX_STATS\t\tBIT(4)\n#define IONIC_QCQ_F_NOTIFYQ\t\tBIT(5)\n#define IONIC_QCQ_F_CMB_RINGS\t\tBIT(6)\n\nstruct ionic_qcq {\n\tvoid *q_base;\n\tdma_addr_t q_base_pa;\n\tu32 q_size;\n\tvoid *cq_base;\n\tdma_addr_t cq_base_pa;\n\tu32 cq_size;\n\tvoid *sg_base;\n\tdma_addr_t sg_base_pa;\n\tu32 sg_size;\n\tvoid __iomem *cmb_q_base;\n\tphys_addr_t cmb_q_base_pa;\n\tu32 cmb_q_size;\n\tu32 cmb_pgid;\n\tu32 cmb_order;\n\tstruct dim dim;\n\tstruct ionic_queue q;\n\tstruct ionic_cq cq;\n\tstruct ionic_intr_info intr;\n\tstruct timer_list napi_deadline;\n\tstruct napi_struct napi;\n\tunsigned int flags;\n\tstruct ionic_qcq *napi_qcq;\n\tstruct dentry *dentry;\n};\n\n#define q_to_qcq(q)\t\tcontainer_of(q, struct ionic_qcq, q)\n#define q_to_tx_stats(q)\t(&(q)->lif->txqstats[(q)->index])\n#define q_to_rx_stats(q)\t(&(q)->lif->rxqstats[(q)->index])\n#define napi_to_qcq(napi)\tcontainer_of(napi, struct ionic_qcq, napi)\n#define napi_to_cq(napi)\t(&napi_to_qcq(napi)->cq)\n\nenum ionic_deferred_work_type {\n\tIONIC_DW_TYPE_RX_MODE,\n\tIONIC_DW_TYPE_LINK_STATUS,\n\tIONIC_DW_TYPE_LIF_RESET,\n};\n\nstruct ionic_deferred_work {\n\tstruct list_head list;\n\tenum ionic_deferred_work_type type;\n\tunion {\n\t\tu8 addr[ETH_ALEN];\n\t\tu8 fw_status;\n\t};\n};\n\nstruct ionic_deferred {\n\tspinlock_t lock;\t\t \n\tstruct list_head list;\n\tstruct work_struct work;\n};\n\nstruct ionic_lif_sw_stats {\n\tu64 tx_packets;\n\tu64 tx_bytes;\n\tu64 rx_packets;\n\tu64 rx_bytes;\n\tu64 tx_tso;\n\tu64 tx_tso_bytes;\n\tu64 tx_csum_none;\n\tu64 tx_csum;\n\tu64 rx_csum_none;\n\tu64 rx_csum_complete;\n\tu64 rx_csum_error;\n\tu64 tx_hwstamp_valid;\n\tu64 tx_hwstamp_invalid;\n\tu64 rx_hwstamp_valid;\n\tu64 rx_hwstamp_invalid;\n\tu64 hw_tx_dropped;\n\tu64 hw_rx_dropped;\n\tu64 hw_rx_over_errors;\n\tu64 hw_rx_missed_errors;\n\tu64 hw_tx_aborted_errors;\n};\n\nenum ionic_lif_state_flags {\n\tIONIC_LIF_F_INITED,\n\tIONIC_LIF_F_UP,\n\tIONIC_LIF_F_LINK_CHECK_REQUESTED,\n\tIONIC_LIF_F_FILTER_SYNC_NEEDED,\n\tIONIC_LIF_F_FW_RESET,\n\tIONIC_LIF_F_FW_STOPPING,\n\tIONIC_LIF_F_SPLIT_INTR,\n\tIONIC_LIF_F_BROKEN,\n\tIONIC_LIF_F_TX_DIM_INTR,\n\tIONIC_LIF_F_RX_DIM_INTR,\n\tIONIC_LIF_F_CMB_TX_RINGS,\n\tIONIC_LIF_F_CMB_RX_RINGS,\n\n\t \n\tIONIC_LIF_F_STATE_SIZE\n};\n\nstruct ionic_qtype_info {\n\tu8  version;\n\tu8  supported;\n\tu64 features;\n\tu16 desc_sz;\n\tu16 comp_sz;\n\tu16 sg_desc_sz;\n\tu16 max_sg_elems;\n\tu16 sg_desc_stride;\n};\n\nstruct ionic_phc;\n\n#define IONIC_LIF_NAME_MAX_SZ\t\t32\nstruct ionic_lif {\n\tstruct net_device *netdev;\n\tDECLARE_BITMAP(state, IONIC_LIF_F_STATE_SIZE);\n\tstruct ionic *ionic;\n\tunsigned int index;\n\tunsigned int hw_index;\n\tstruct mutex queue_lock;\t \n\tstruct mutex config_lock;\t \n\tspinlock_t adminq_lock;\t\t \n\tstruct ionic_qcq *adminqcq;\n\tstruct ionic_qcq *notifyqcq;\n\tstruct ionic_qcq **txqcqs;\n\tstruct ionic_qcq *hwstamp_txq;\n\tstruct ionic_tx_stats *txqstats;\n\tstruct ionic_qcq **rxqcqs;\n\tstruct ionic_qcq *hwstamp_rxq;\n\tstruct ionic_rx_stats *rxqstats;\n\tstruct ionic_deferred deferred;\n\tstruct work_struct tx_timeout_work;\n\tu64 last_eid;\n\tunsigned int kern_pid;\n\tu64 __iomem *kern_dbpage;\n\tunsigned int neqs;\n\tunsigned int nxqs;\n\tunsigned int ntxq_descs;\n\tunsigned int nrxq_descs;\n\tu32 rx_copybreak;\n\tu64 rxq_features;\n\tu16 rx_mode;\n\tu64 hw_features;\n\tbool registered;\n\tu16 lif_type;\n\tunsigned int link_down_count;\n\tunsigned int nmcast;\n\tunsigned int nucast;\n\tunsigned int nvlans;\n\tunsigned int max_vlans;\n\tchar name[IONIC_LIF_NAME_MAX_SZ];\n\n\tunion ionic_lif_identity *identity;\n\tstruct ionic_lif_info *info;\n\tdma_addr_t info_pa;\n\tu32 info_sz;\n\tstruct ionic_qtype_info qtype_info[IONIC_QTYPE_MAX];\n\n\tu16 rss_types;\n\tu8 rss_hash_key[IONIC_RSS_HASH_KEY_SIZE];\n\tu8 *rss_ind_tbl;\n\tdma_addr_t rss_ind_tbl_pa;\n\tu32 rss_ind_tbl_sz;\n\n\tstruct ionic_rx_filters rx_filters;\n\tu32 rx_coalesce_usecs;\t\t \n\tu32 rx_coalesce_hw;\t\t \n\tu32 tx_coalesce_usecs;\t\t \n\tu32 tx_coalesce_hw;\t\t \n\tunsigned int dbid_count;\n\n\tstruct ionic_phc *phc;\n\n\tstruct dentry *dentry;\n};\n\nstruct ionic_phc {\n\tspinlock_t lock;  \n\tstruct cyclecounter cc;\n\tstruct timecounter tc;\n\n\tstruct mutex config_lock;  \n\tstruct hwtstamp_config ts_config;\n\tu64 ts_config_rx_filt;\n\tu32 ts_config_tx_mode;\n\n\tu32 init_cc_mult;\n\tlong aux_work_delay;\n\n\tstruct ptp_clock_info ptp_info;\n\tstruct ptp_clock *ptp;\n\tstruct ionic_lif *lif;\n};\n\nstruct ionic_queue_params {\n\tunsigned int nxqs;\n\tunsigned int ntxq_descs;\n\tunsigned int nrxq_descs;\n\tu64 rxq_features;\n\tbool intr_split;\n\tbool cmb_tx;\n\tbool cmb_rx;\n};\n\nstatic inline void ionic_init_queue_params(struct ionic_lif *lif,\n\t\t\t\t\t   struct ionic_queue_params *qparam)\n{\n\tqparam->nxqs = lif->nxqs;\n\tqparam->ntxq_descs = lif->ntxq_descs;\n\tqparam->nrxq_descs = lif->nrxq_descs;\n\tqparam->rxq_features = lif->rxq_features;\n\tqparam->intr_split = test_bit(IONIC_LIF_F_SPLIT_INTR, lif->state);\n\tqparam->cmb_tx = test_bit(IONIC_LIF_F_CMB_TX_RINGS, lif->state);\n\tqparam->cmb_rx = test_bit(IONIC_LIF_F_CMB_RX_RINGS, lif->state);\n}\n\nstatic inline void ionic_set_queue_params(struct ionic_lif *lif,\n\t\t\t\t\t  struct ionic_queue_params *qparam)\n{\n\tlif->nxqs = qparam->nxqs;\n\tlif->ntxq_descs = qparam->ntxq_descs;\n\tlif->nrxq_descs = qparam->nrxq_descs;\n\tlif->rxq_features = qparam->rxq_features;\n\n\tif (qparam->intr_split)\n\t\tset_bit(IONIC_LIF_F_SPLIT_INTR, lif->state);\n\telse\n\t\tclear_bit(IONIC_LIF_F_SPLIT_INTR, lif->state);\n\n\tif (qparam->cmb_tx)\n\t\tset_bit(IONIC_LIF_F_CMB_TX_RINGS, lif->state);\n\telse\n\t\tclear_bit(IONIC_LIF_F_CMB_TX_RINGS, lif->state);\n\n\tif (qparam->cmb_rx)\n\t\tset_bit(IONIC_LIF_F_CMB_RX_RINGS, lif->state);\n\telse\n\t\tclear_bit(IONIC_LIF_F_CMB_RX_RINGS, lif->state);\n}\n\nstatic inline u32 ionic_coal_usec_to_hw(struct ionic *ionic, u32 usecs)\n{\n\tu32 mult = le32_to_cpu(ionic->ident.dev.intr_coal_mult);\n\tu32 div = le32_to_cpu(ionic->ident.dev.intr_coal_div);\n\n\t \n\tif (!div || !mult)\n\t\treturn 0;\n\n\t \n\tusecs += (div / mult) >> 1;\n\n\t \n\treturn (usecs * mult) / div;\n}\n\nvoid ionic_link_status_check_request(struct ionic_lif *lif, bool can_sleep);\nvoid ionic_get_stats64(struct net_device *netdev,\n\t\t       struct rtnl_link_stats64 *ns);\nvoid ionic_lif_deferred_enqueue(struct ionic_deferred *def,\n\t\t\t\tstruct ionic_deferred_work *work);\nint ionic_lif_alloc(struct ionic *ionic);\nint ionic_lif_init(struct ionic_lif *lif);\nvoid ionic_lif_free(struct ionic_lif *lif);\nvoid ionic_lif_deinit(struct ionic_lif *lif);\n\nint ionic_lif_addr_add(struct ionic_lif *lif, const u8 *addr);\nint ionic_lif_addr_del(struct ionic_lif *lif, const u8 *addr);\n\nvoid ionic_stop_queues_reconfig(struct ionic_lif *lif);\nvoid ionic_txrx_free(struct ionic_lif *lif);\nvoid ionic_qcqs_free(struct ionic_lif *lif);\nint ionic_restart_lif(struct ionic_lif *lif);\n\nint ionic_lif_register(struct ionic_lif *lif);\nvoid ionic_lif_unregister(struct ionic_lif *lif);\nint ionic_lif_identify(struct ionic *ionic, u8 lif_type,\n\t\t       union ionic_lif_identity *lif_ident);\nint ionic_lif_size(struct ionic *ionic);\n\n#if IS_ENABLED(CONFIG_PTP_1588_CLOCK)\nvoid ionic_lif_hwstamp_replay(struct ionic_lif *lif);\nvoid ionic_lif_hwstamp_recreate_queues(struct ionic_lif *lif);\nint ionic_lif_hwstamp_set(struct ionic_lif *lif, struct ifreq *ifr);\nint ionic_lif_hwstamp_get(struct ionic_lif *lif, struct ifreq *ifr);\nktime_t ionic_lif_phc_ktime(struct ionic_lif *lif, u64 counter);\nvoid ionic_lif_register_phc(struct ionic_lif *lif);\nvoid ionic_lif_unregister_phc(struct ionic_lif *lif);\nvoid ionic_lif_alloc_phc(struct ionic_lif *lif);\nvoid ionic_lif_free_phc(struct ionic_lif *lif);\n#else\nstatic inline void ionic_lif_hwstamp_replay(struct ionic_lif *lif) {}\nstatic inline void ionic_lif_hwstamp_recreate_queues(struct ionic_lif *lif) {}\n\nstatic inline int ionic_lif_hwstamp_set(struct ionic_lif *lif, struct ifreq *ifr)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic inline int ionic_lif_hwstamp_get(struct ionic_lif *lif, struct ifreq *ifr)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic inline ktime_t ionic_lif_phc_ktime(struct ionic_lif *lif, u64 counter)\n{\n\treturn ns_to_ktime(0);\n}\n\nstatic inline void ionic_lif_register_phc(struct ionic_lif *lif) {}\nstatic inline void ionic_lif_unregister_phc(struct ionic_lif *lif) {}\nstatic inline void ionic_lif_alloc_phc(struct ionic_lif *lif) {}\nstatic inline void ionic_lif_free_phc(struct ionic_lif *lif) {}\n#endif\n\nint ionic_lif_create_hwstamp_txq(struct ionic_lif *lif);\nint ionic_lif_create_hwstamp_rxq(struct ionic_lif *lif);\nint ionic_lif_config_hwstamp_rxq_all(struct ionic_lif *lif, bool rx_all);\nint ionic_lif_set_hwstamp_txmode(struct ionic_lif *lif, u16 txstamp_mode);\nint ionic_lif_set_hwstamp_rxfilt(struct ionic_lif *lif, u64 pkt_class);\n\nint ionic_lif_rss_config(struct ionic_lif *lif, u16 types,\n\t\t\t const u8 *key, const u32 *indir);\nvoid ionic_lif_rx_mode(struct ionic_lif *lif);\nint ionic_reconfigure_queues(struct ionic_lif *lif,\n\t\t\t     struct ionic_queue_params *qparam);\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}