{
  "module_name": "ionic_ethtool.c",
  "hash_id": "6244d4f10de3767c83a7cbff816319453bc89904b2e0194310ddce9f0e19c8fd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/pensando/ionic/ionic_ethtool.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/sfp.h>\n\n#include \"ionic.h\"\n#include \"ionic_bus.h\"\n#include \"ionic_lif.h\"\n#include \"ionic_ethtool.h\"\n#include \"ionic_stats.h\"\n\nstatic void ionic_get_stats_strings(struct ionic_lif *lif, u8 *buf)\n{\n\tu32 i;\n\n\tfor (i = 0; i < ionic_num_stats_grps; i++)\n\t\tionic_stats_groups[i].get_strings(lif, &buf);\n}\n\nstatic void ionic_get_stats(struct net_device *netdev,\n\t\t\t    struct ethtool_stats *stats, u64 *buf)\n{\n\tstruct ionic_lif *lif = netdev_priv(netdev);\n\tu32 i;\n\n\tif (test_bit(IONIC_LIF_F_FW_RESET, lif->state))\n\t\treturn;\n\n\tmemset(buf, 0, stats->n_stats * sizeof(*buf));\n\tfor (i = 0; i < ionic_num_stats_grps; i++)\n\t\tionic_stats_groups[i].get_values(lif, &buf);\n}\n\nstatic int ionic_get_stats_count(struct ionic_lif *lif)\n{\n\tint i, num_stats = 0;\n\n\tfor (i = 0; i < ionic_num_stats_grps; i++)\n\t\tnum_stats += ionic_stats_groups[i].get_count(lif);\n\n\treturn num_stats;\n}\n\nstatic int ionic_get_sset_count(struct net_device *netdev, int sset)\n{\n\tstruct ionic_lif *lif = netdev_priv(netdev);\n\tint count = 0;\n\n\tswitch (sset) {\n\tcase ETH_SS_STATS:\n\t\tcount = ionic_get_stats_count(lif);\n\t\tbreak;\n\t}\n\treturn count;\n}\n\nstatic void ionic_get_strings(struct net_device *netdev,\n\t\t\t      u32 sset, u8 *buf)\n{\n\tstruct ionic_lif *lif = netdev_priv(netdev);\n\n\tswitch (sset) {\n\tcase ETH_SS_STATS:\n\t\tionic_get_stats_strings(lif, buf);\n\t\tbreak;\n\t}\n}\n\nstatic void ionic_get_drvinfo(struct net_device *netdev,\n\t\t\t      struct ethtool_drvinfo *drvinfo)\n{\n\tstruct ionic_lif *lif = netdev_priv(netdev);\n\tstruct ionic *ionic = lif->ionic;\n\n\tstrscpy(drvinfo->driver, IONIC_DRV_NAME, sizeof(drvinfo->driver));\n\tstrscpy(drvinfo->fw_version, ionic->idev.dev_info.fw_version,\n\t\tsizeof(drvinfo->fw_version));\n\tstrscpy(drvinfo->bus_info, ionic_bus_info(ionic),\n\t\tsizeof(drvinfo->bus_info));\n}\n\nstatic int ionic_get_regs_len(struct net_device *netdev)\n{\n\treturn (IONIC_DEV_INFO_REG_COUNT + IONIC_DEV_CMD_REG_COUNT) * sizeof(u32);\n}\n\nstatic void ionic_get_regs(struct net_device *netdev, struct ethtool_regs *regs,\n\t\t\t   void *p)\n{\n\tstruct ionic_lif *lif = netdev_priv(netdev);\n\tunsigned int offset;\n\tunsigned int size;\n\n\tregs->version = IONIC_DEV_CMD_REG_VERSION;\n\n\toffset = 0;\n\tsize = IONIC_DEV_INFO_REG_COUNT * sizeof(u32);\n\tmemcpy_fromio(p + offset, lif->ionic->idev.dev_info_regs->words, size);\n\n\toffset += size;\n\tsize = IONIC_DEV_CMD_REG_COUNT * sizeof(u32);\n\tmemcpy_fromio(p + offset, lif->ionic->idev.dev_cmd_regs->words, size);\n}\n\nstatic void ionic_get_link_ext_stats(struct net_device *netdev,\n\t\t\t\t     struct ethtool_link_ext_stats *stats)\n{\n\tstruct ionic_lif *lif = netdev_priv(netdev);\n\n\tif (lif->ionic->pdev->is_physfn)\n\t\tstats->link_down_events = lif->link_down_count;\n}\n\nstatic int ionic_get_link_ksettings(struct net_device *netdev,\n\t\t\t\t    struct ethtool_link_ksettings *ks)\n{\n\tstruct ionic_lif *lif = netdev_priv(netdev);\n\tstruct ionic_dev *idev = &lif->ionic->idev;\n\tint copper_seen = 0;\n\n\tethtool_link_ksettings_zero_link_mode(ks, supported);\n\n\tif (!idev->port_info) {\n\t\tnetdev_err(netdev, \"port_info not initialized\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t \n\n\tswitch (le16_to_cpu(idev->port_info->status.xcvr.pid)) {\n\t\t \n\tcase IONIC_XCVR_PID_QSFP_100G_CR4:\n\t\tethtool_link_ksettings_add_link_mode(ks, supported,\n\t\t\t\t\t\t     100000baseCR4_Full);\n\t\tcopper_seen++;\n\t\tbreak;\n\tcase IONIC_XCVR_PID_QSFP_40GBASE_CR4:\n\t\tethtool_link_ksettings_add_link_mode(ks, supported,\n\t\t\t\t\t\t     40000baseCR4_Full);\n\t\tcopper_seen++;\n\t\tbreak;\n\tcase IONIC_XCVR_PID_SFP_25GBASE_CR_S:\n\tcase IONIC_XCVR_PID_SFP_25GBASE_CR_L:\n\tcase IONIC_XCVR_PID_SFP_25GBASE_CR_N:\n\t\tethtool_link_ksettings_add_link_mode(ks, supported,\n\t\t\t\t\t\t     25000baseCR_Full);\n\t\tcopper_seen++;\n\t\tbreak;\n\tcase IONIC_XCVR_PID_SFP_10GBASE_AOC:\n\tcase IONIC_XCVR_PID_SFP_10GBASE_CU:\n\t\tethtool_link_ksettings_add_link_mode(ks, supported,\n\t\t\t\t\t\t     10000baseCR_Full);\n\t\tcopper_seen++;\n\t\tbreak;\n\n\t\t \n\tcase IONIC_XCVR_PID_QSFP_100G_SR4:\n\tcase IONIC_XCVR_PID_QSFP_100G_AOC:\n\t\tethtool_link_ksettings_add_link_mode(ks, supported,\n\t\t\t\t\t\t     100000baseSR4_Full);\n\t\tbreak;\n\tcase IONIC_XCVR_PID_QSFP_100G_CWDM4:\n\tcase IONIC_XCVR_PID_QSFP_100G_PSM4:\n\tcase IONIC_XCVR_PID_QSFP_100G_LR4:\n\t\tethtool_link_ksettings_add_link_mode(ks, supported,\n\t\t\t\t\t\t     100000baseLR4_ER4_Full);\n\t\tbreak;\n\tcase IONIC_XCVR_PID_QSFP_100G_ER4:\n\t\tethtool_link_ksettings_add_link_mode(ks, supported,\n\t\t\t\t\t\t     100000baseLR4_ER4_Full);\n\t\tbreak;\n\tcase IONIC_XCVR_PID_QSFP_40GBASE_SR4:\n\tcase IONIC_XCVR_PID_QSFP_40GBASE_AOC:\n\t\tethtool_link_ksettings_add_link_mode(ks, supported,\n\t\t\t\t\t\t     40000baseSR4_Full);\n\t\tbreak;\n\tcase IONIC_XCVR_PID_QSFP_40GBASE_LR4:\n\t\tethtool_link_ksettings_add_link_mode(ks, supported,\n\t\t\t\t\t\t     40000baseLR4_Full);\n\t\tbreak;\n\tcase IONIC_XCVR_PID_SFP_25GBASE_SR:\n\tcase IONIC_XCVR_PID_SFP_25GBASE_AOC:\n\tcase IONIC_XCVR_PID_SFP_25GBASE_ACC:\n\t\tethtool_link_ksettings_add_link_mode(ks, supported,\n\t\t\t\t\t\t     25000baseSR_Full);\n\t\tbreak;\n\tcase IONIC_XCVR_PID_SFP_10GBASE_SR:\n\t\tethtool_link_ksettings_add_link_mode(ks, supported,\n\t\t\t\t\t\t     10000baseSR_Full);\n\t\tbreak;\n\tcase IONIC_XCVR_PID_SFP_10GBASE_LR:\n\t\tethtool_link_ksettings_add_link_mode(ks, supported,\n\t\t\t\t\t\t     10000baseLR_Full);\n\t\tbreak;\n\tcase IONIC_XCVR_PID_SFP_10GBASE_LRM:\n\t\tethtool_link_ksettings_add_link_mode(ks, supported,\n\t\t\t\t\t\t     10000baseLRM_Full);\n\t\tbreak;\n\tcase IONIC_XCVR_PID_SFP_10GBASE_ER:\n\t\tethtool_link_ksettings_add_link_mode(ks, supported,\n\t\t\t\t\t\t     10000baseER_Full);\n\t\tbreak;\n\tcase IONIC_XCVR_PID_SFP_10GBASE_T:\n\t\tethtool_link_ksettings_add_link_mode(ks, supported,\n\t\t\t\t\t\t     10000baseT_Full);\n\t\tbreak;\n\tcase IONIC_XCVR_PID_SFP_1000BASE_T:\n\t\tethtool_link_ksettings_add_link_mode(ks, supported,\n\t\t\t\t\t\t     1000baseT_Full);\n\t\tbreak;\n\tcase IONIC_XCVR_PID_UNKNOWN:\n\t\t \n\t\tbreak;\n\tdefault:\n\t\tdev_info(lif->ionic->dev, \"unknown xcvr type pid=%d / 0x%x\\n\",\n\t\t\t idev->port_info->status.xcvr.pid,\n\t\t\t idev->port_info->status.xcvr.pid);\n\t\tbreak;\n\t}\n\n\tlinkmode_copy(ks->link_modes.advertising, ks->link_modes.supported);\n\n\tethtool_link_ksettings_add_link_mode(ks, supported, FEC_BASER);\n\tethtool_link_ksettings_add_link_mode(ks, supported, FEC_RS);\n\tif (idev->port_info->config.fec_type == IONIC_PORT_FEC_TYPE_FC)\n\t\tethtool_link_ksettings_add_link_mode(ks, advertising, FEC_BASER);\n\telse if (idev->port_info->config.fec_type == IONIC_PORT_FEC_TYPE_RS)\n\t\tethtool_link_ksettings_add_link_mode(ks, advertising, FEC_RS);\n\n\tethtool_link_ksettings_add_link_mode(ks, supported, FIBRE);\n\tethtool_link_ksettings_add_link_mode(ks, supported, Pause);\n\n\tif (idev->port_info->status.xcvr.phy == IONIC_PHY_TYPE_COPPER ||\n\t    copper_seen)\n\t\tks->base.port = PORT_DA;\n\telse if (idev->port_info->status.xcvr.phy == IONIC_PHY_TYPE_FIBER)\n\t\tks->base.port = PORT_FIBRE;\n\telse\n\t\tks->base.port = PORT_NONE;\n\n\tif (ks->base.port != PORT_NONE) {\n\t\tks->base.speed = le32_to_cpu(lif->info->status.link_speed);\n\n\t\tif (le16_to_cpu(lif->info->status.link_status))\n\t\t\tks->base.duplex = DUPLEX_FULL;\n\t\telse\n\t\t\tks->base.duplex = DUPLEX_UNKNOWN;\n\n\t\tethtool_link_ksettings_add_link_mode(ks, supported, Autoneg);\n\n\t\tif (idev->port_info->config.an_enable) {\n\t\t\tethtool_link_ksettings_add_link_mode(ks, advertising,\n\t\t\t\t\t\t\t     Autoneg);\n\t\t\tks->base.autoneg = AUTONEG_ENABLE;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int ionic_set_link_ksettings(struct net_device *netdev,\n\t\t\t\t    const struct ethtool_link_ksettings *ks)\n{\n\tstruct ionic_lif *lif = netdev_priv(netdev);\n\tstruct ionic_dev *idev = &lif->ionic->idev;\n\tstruct ionic *ionic = lif->ionic;\n\tint err = 0;\n\n\tif (test_bit(IONIC_LIF_F_FW_RESET, lif->state))\n\t\treturn -EBUSY;\n\n\t \n\tif (ks->base.autoneg != idev->port_info->config.an_enable) {\n\t\tmutex_lock(&ionic->dev_cmd_lock);\n\t\tionic_dev_cmd_port_autoneg(idev, ks->base.autoneg);\n\t\terr = ionic_dev_cmd_wait(ionic, DEVCMD_TIMEOUT);\n\t\tmutex_unlock(&ionic->dev_cmd_lock);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t \n\tif (ks->base.speed != le32_to_cpu(idev->port_info->config.speed)) {\n\t\tmutex_lock(&ionic->dev_cmd_lock);\n\t\tionic_dev_cmd_port_speed(idev, ks->base.speed);\n\t\terr = ionic_dev_cmd_wait(ionic, DEVCMD_TIMEOUT);\n\t\tmutex_unlock(&ionic->dev_cmd_lock);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic void ionic_get_pauseparam(struct net_device *netdev,\n\t\t\t\t struct ethtool_pauseparam *pause)\n{\n\tstruct ionic_lif *lif = netdev_priv(netdev);\n\tu8 pause_type;\n\n\tpause->autoneg = 0;\n\n\tpause_type = lif->ionic->idev.port_info->config.pause_type;\n\tif (pause_type) {\n\t\tpause->rx_pause = (pause_type & IONIC_PAUSE_F_RX) ? 1 : 0;\n\t\tpause->tx_pause = (pause_type & IONIC_PAUSE_F_TX) ? 1 : 0;\n\t}\n}\n\nstatic int ionic_set_pauseparam(struct net_device *netdev,\n\t\t\t\tstruct ethtool_pauseparam *pause)\n{\n\tstruct ionic_lif *lif = netdev_priv(netdev);\n\tstruct ionic *ionic = lif->ionic;\n\tu32 requested_pause;\n\tint err;\n\n\tif (test_bit(IONIC_LIF_F_FW_RESET, lif->state))\n\t\treturn -EBUSY;\n\n\tif (pause->autoneg)\n\t\treturn -EOPNOTSUPP;\n\n\t \n\trequested_pause = IONIC_PORT_PAUSE_TYPE_LINK;\n\tif (pause->rx_pause)\n\t\trequested_pause |= IONIC_PAUSE_F_RX;\n\tif (pause->tx_pause)\n\t\trequested_pause |= IONIC_PAUSE_F_TX;\n\n\tif (requested_pause == lif->ionic->idev.port_info->config.pause_type)\n\t\treturn 0;\n\n\tmutex_lock(&ionic->dev_cmd_lock);\n\tionic_dev_cmd_port_pause(&lif->ionic->idev, requested_pause);\n\terr = ionic_dev_cmd_wait(ionic, DEVCMD_TIMEOUT);\n\tmutex_unlock(&ionic->dev_cmd_lock);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic int ionic_get_fecparam(struct net_device *netdev,\n\t\t\t      struct ethtool_fecparam *fec)\n{\n\tstruct ionic_lif *lif = netdev_priv(netdev);\n\n\tswitch (lif->ionic->idev.port_info->config.fec_type) {\n\tcase IONIC_PORT_FEC_TYPE_NONE:\n\t\tfec->active_fec = ETHTOOL_FEC_OFF;\n\t\tbreak;\n\tcase IONIC_PORT_FEC_TYPE_RS:\n\t\tfec->active_fec = ETHTOOL_FEC_RS;\n\t\tbreak;\n\tcase IONIC_PORT_FEC_TYPE_FC:\n\t\tfec->active_fec = ETHTOOL_FEC_BASER;\n\t\tbreak;\n\t}\n\n\tfec->fec = ETHTOOL_FEC_OFF | ETHTOOL_FEC_RS | ETHTOOL_FEC_BASER;\n\n\treturn 0;\n}\n\nstatic int ionic_set_fecparam(struct net_device *netdev,\n\t\t\t      struct ethtool_fecparam *fec)\n{\n\tstruct ionic_lif *lif = netdev_priv(netdev);\n\tu8 fec_type;\n\tint ret = 0;\n\n\tif (test_bit(IONIC_LIF_F_FW_RESET, lif->state))\n\t\treturn -EBUSY;\n\n\tif (lif->ionic->idev.port_info->config.an_enable) {\n\t\tnetdev_err(netdev, \"FEC request not allowed while autoneg is enabled\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (fec->fec) {\n\tcase ETHTOOL_FEC_NONE:\n\t\tfec_type = IONIC_PORT_FEC_TYPE_NONE;\n\t\tbreak;\n\tcase ETHTOOL_FEC_OFF:\n\t\tfec_type = IONIC_PORT_FEC_TYPE_NONE;\n\t\tbreak;\n\tcase ETHTOOL_FEC_RS:\n\t\tfec_type = IONIC_PORT_FEC_TYPE_RS;\n\t\tbreak;\n\tcase ETHTOOL_FEC_BASER:\n\t\tfec_type = IONIC_PORT_FEC_TYPE_FC;\n\t\tbreak;\n\tcase ETHTOOL_FEC_AUTO:\n\tdefault:\n\t\tnetdev_err(netdev, \"FEC request 0x%04x not supported\\n\",\n\t\t\t   fec->fec);\n\t\treturn -EINVAL;\n\t}\n\n\tif (fec_type != lif->ionic->idev.port_info->config.fec_type) {\n\t\tmutex_lock(&lif->ionic->dev_cmd_lock);\n\t\tionic_dev_cmd_port_fec(&lif->ionic->idev, fec_type);\n\t\tret = ionic_dev_cmd_wait(lif->ionic, DEVCMD_TIMEOUT);\n\t\tmutex_unlock(&lif->ionic->dev_cmd_lock);\n\t}\n\n\treturn ret;\n}\n\nstatic int ionic_get_coalesce(struct net_device *netdev,\n\t\t\t      struct ethtool_coalesce *coalesce,\n\t\t\t      struct kernel_ethtool_coalesce *kernel_coal,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct ionic_lif *lif = netdev_priv(netdev);\n\n\tcoalesce->tx_coalesce_usecs = lif->tx_coalesce_usecs;\n\tcoalesce->rx_coalesce_usecs = lif->rx_coalesce_usecs;\n\n\tif (test_bit(IONIC_LIF_F_SPLIT_INTR, lif->state))\n\t\tcoalesce->use_adaptive_tx_coalesce = test_bit(IONIC_LIF_F_TX_DIM_INTR, lif->state);\n\telse\n\t\tcoalesce->use_adaptive_tx_coalesce = 0;\n\n\tcoalesce->use_adaptive_rx_coalesce = test_bit(IONIC_LIF_F_RX_DIM_INTR, lif->state);\n\n\treturn 0;\n}\n\nstatic int ionic_set_coalesce(struct net_device *netdev,\n\t\t\t      struct ethtool_coalesce *coalesce,\n\t\t\t      struct kernel_ethtool_coalesce *kernel_coal,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct ionic_lif *lif = netdev_priv(netdev);\n\tstruct ionic_identity *ident;\n\tu32 rx_coal, rx_dim;\n\tu32 tx_coal, tx_dim;\n\tunsigned int i;\n\n\tident = &lif->ionic->ident;\n\tif (ident->dev.intr_coal_div == 0) {\n\t\tnetdev_warn(netdev, \"bad HW value in dev.intr_coal_div = %d\\n\",\n\t\t\t    ident->dev.intr_coal_div);\n\t\treturn -EIO;\n\t}\n\n\t \n\tif (!test_bit(IONIC_LIF_F_SPLIT_INTR, lif->state) &&\n\t    (coalesce->tx_coalesce_usecs != lif->rx_coalesce_usecs ||\n\t     coalesce->use_adaptive_tx_coalesce)) {\n\t\tnetdev_warn(netdev, \"only rx parameters can be changed\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\trx_coal = ionic_coal_usec_to_hw(lif->ionic, coalesce->rx_coalesce_usecs);\n\tif (!rx_coal && coalesce->rx_coalesce_usecs)\n\t\trx_coal = 1;\n\ttx_coal = ionic_coal_usec_to_hw(lif->ionic, coalesce->tx_coalesce_usecs);\n\tif (!tx_coal && coalesce->tx_coalesce_usecs)\n\t\ttx_coal = 1;\n\n\tif (rx_coal > IONIC_INTR_CTRL_COAL_MAX ||\n\t    tx_coal > IONIC_INTR_CTRL_COAL_MAX)\n\t\treturn -ERANGE;\n\n\t \n\tlif->rx_coalesce_usecs = coalesce->rx_coalesce_usecs;\n\tlif->rx_coalesce_hw = rx_coal;\n\n\tif (test_bit(IONIC_LIF_F_SPLIT_INTR, lif->state))\n\t\tlif->tx_coalesce_usecs = coalesce->tx_coalesce_usecs;\n\telse\n\t\tlif->tx_coalesce_usecs = coalesce->rx_coalesce_usecs;\n\tlif->tx_coalesce_hw = tx_coal;\n\n\tif (coalesce->use_adaptive_rx_coalesce) {\n\t\tset_bit(IONIC_LIF_F_RX_DIM_INTR, lif->state);\n\t\trx_dim = rx_coal;\n\t} else {\n\t\tclear_bit(IONIC_LIF_F_RX_DIM_INTR, lif->state);\n\t\trx_dim = 0;\n\t}\n\n\tif (coalesce->use_adaptive_tx_coalesce) {\n\t\tset_bit(IONIC_LIF_F_TX_DIM_INTR, lif->state);\n\t\ttx_dim = tx_coal;\n\t} else {\n\t\tclear_bit(IONIC_LIF_F_TX_DIM_INTR, lif->state);\n\t\ttx_dim = 0;\n\t}\n\n\tif (test_bit(IONIC_LIF_F_UP, lif->state)) {\n\t\tfor (i = 0; i < lif->nxqs; i++) {\n\t\t\tif (lif->rxqcqs[i]->flags & IONIC_QCQ_F_INTR) {\n\t\t\t\tionic_intr_coal_init(lif->ionic->idev.intr_ctrl,\n\t\t\t\t\t\t     lif->rxqcqs[i]->intr.index,\n\t\t\t\t\t\t     lif->rx_coalesce_hw);\n\t\t\t\tlif->rxqcqs[i]->intr.dim_coal_hw = rx_dim;\n\t\t\t}\n\n\t\t\tif (lif->txqcqs[i]->flags & IONIC_QCQ_F_INTR) {\n\t\t\t\tionic_intr_coal_init(lif->ionic->idev.intr_ctrl,\n\t\t\t\t\t\t     lif->txqcqs[i]->intr.index,\n\t\t\t\t\t\t     lif->tx_coalesce_hw);\n\t\t\t\tlif->txqcqs[i]->intr.dim_coal_hw = tx_dim;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int ionic_validate_cmb_config(struct ionic_lif *lif,\n\t\t\t\t     struct ionic_queue_params *qparam)\n{\n\tint pages_have, pages_required = 0;\n\tunsigned long sz;\n\n\tif (!lif->ionic->idev.cmb_inuse &&\n\t    (qparam->cmb_tx || qparam->cmb_rx)) {\n\t\tnetdev_info(lif->netdev, \"CMB rings are not supported on this device\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (qparam->cmb_tx) {\n\t\tif (!(lif->qtype_info[IONIC_QTYPE_TXQ].features & IONIC_QIDENT_F_CMB)) {\n\t\t\tnetdev_info(lif->netdev,\n\t\t\t\t    \"CMB rings for tx-push are not supported on this device\\n\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\n\t\tsz = sizeof(struct ionic_txq_desc) * qparam->ntxq_descs * qparam->nxqs;\n\t\tpages_required += ALIGN(sz, PAGE_SIZE) / PAGE_SIZE;\n\t}\n\n\tif (qparam->cmb_rx) {\n\t\tif (!(lif->qtype_info[IONIC_QTYPE_RXQ].features & IONIC_QIDENT_F_CMB)) {\n\t\t\tnetdev_info(lif->netdev,\n\t\t\t\t    \"CMB rings for rx-push are not supported on this device\\n\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\n\t\tsz = sizeof(struct ionic_rxq_desc) * qparam->nrxq_descs * qparam->nxqs;\n\t\tpages_required += ALIGN(sz, PAGE_SIZE) / PAGE_SIZE;\n\t}\n\n\tpages_have = lif->ionic->bars[IONIC_PCI_BAR_CMB].len / PAGE_SIZE;\n\tif (pages_required > pages_have) {\n\t\tnetdev_info(lif->netdev,\n\t\t\t    \"Not enough CMB pages for number of queues and size of descriptor rings, need %d have %d\",\n\t\t\t    pages_required, pages_have);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn pages_required;\n}\n\nstatic int ionic_cmb_rings_toggle(struct ionic_lif *lif, bool cmb_tx, bool cmb_rx)\n{\n\tstruct ionic_queue_params qparam;\n\tint pages_used;\n\n\tif (netif_running(lif->netdev)) {\n\t\tnetdev_info(lif->netdev, \"Please stop device to toggle CMB for tx/rx-push\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tionic_init_queue_params(lif, &qparam);\n\tqparam.cmb_tx = cmb_tx;\n\tqparam.cmb_rx = cmb_rx;\n\tpages_used = ionic_validate_cmb_config(lif, &qparam);\n\tif (pages_used < 0)\n\t\treturn pages_used;\n\n\tif (cmb_tx)\n\t\tset_bit(IONIC_LIF_F_CMB_TX_RINGS, lif->state);\n\telse\n\t\tclear_bit(IONIC_LIF_F_CMB_TX_RINGS, lif->state);\n\n\tif (cmb_rx)\n\t\tset_bit(IONIC_LIF_F_CMB_RX_RINGS, lif->state);\n\telse\n\t\tclear_bit(IONIC_LIF_F_CMB_RX_RINGS, lif->state);\n\n\tif (cmb_tx || cmb_rx)\n\t\tnetdev_info(lif->netdev, \"Enabling CMB %s %s rings - %d pages\\n\",\n\t\t\t    cmb_tx ? \"TX\" : \"\", cmb_rx ? \"RX\" : \"\", pages_used);\n\telse\n\t\tnetdev_info(lif->netdev, \"Disabling CMB rings\\n\");\n\n\treturn 0;\n}\n\nstatic void ionic_get_ringparam(struct net_device *netdev,\n\t\t\t\tstruct ethtool_ringparam *ring,\n\t\t\t\tstruct kernel_ethtool_ringparam *kernel_ring,\n\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct ionic_lif *lif = netdev_priv(netdev);\n\n\tring->tx_max_pending = IONIC_MAX_TX_DESC;\n\tring->tx_pending = lif->ntxq_descs;\n\tring->rx_max_pending = IONIC_MAX_RX_DESC;\n\tring->rx_pending = lif->nrxq_descs;\n\tkernel_ring->tx_push = test_bit(IONIC_LIF_F_CMB_TX_RINGS, lif->state);\n\tkernel_ring->rx_push = test_bit(IONIC_LIF_F_CMB_RX_RINGS, lif->state);\n}\n\nstatic int ionic_set_ringparam(struct net_device *netdev,\n\t\t\t       struct ethtool_ringparam *ring,\n\t\t\t       struct kernel_ethtool_ringparam *kernel_ring,\n\t\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct ionic_lif *lif = netdev_priv(netdev);\n\tstruct ionic_queue_params qparam;\n\tint err;\n\n\tif (test_bit(IONIC_LIF_F_FW_RESET, lif->state))\n\t\treturn -EBUSY;\n\n\tionic_init_queue_params(lif, &qparam);\n\n\tif (ring->rx_mini_pending || ring->rx_jumbo_pending) {\n\t\tnetdev_info(netdev, \"Changing jumbo or mini descriptors not supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!is_power_of_2(ring->tx_pending) ||\n\t    !is_power_of_2(ring->rx_pending)) {\n\t\tnetdev_info(netdev, \"Descriptor count must be a power of 2\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (ring->tx_pending == lif->ntxq_descs &&\n\t    ring->rx_pending == lif->nrxq_descs &&\n\t    kernel_ring->tx_push == test_bit(IONIC_LIF_F_CMB_TX_RINGS, lif->state) &&\n\t    kernel_ring->rx_push == test_bit(IONIC_LIF_F_CMB_RX_RINGS, lif->state))\n\t\treturn 0;\n\n\tqparam.ntxq_descs = ring->tx_pending;\n\tqparam.nrxq_descs = ring->rx_pending;\n\tqparam.cmb_tx = kernel_ring->tx_push;\n\tqparam.cmb_rx = kernel_ring->rx_push;\n\n\terr = ionic_validate_cmb_config(lif, &qparam);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (kernel_ring->tx_push != test_bit(IONIC_LIF_F_CMB_TX_RINGS, lif->state) ||\n\t    kernel_ring->rx_push != test_bit(IONIC_LIF_F_CMB_RX_RINGS, lif->state)) {\n\t\terr = ionic_cmb_rings_toggle(lif, kernel_ring->tx_push,\n\t\t\t\t\t     kernel_ring->rx_push);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tif (ring->tx_pending != lif->ntxq_descs)\n\t\tnetdev_info(netdev, \"Changing Tx ring size from %d to %d\\n\",\n\t\t\t    lif->ntxq_descs, ring->tx_pending);\n\n\tif (ring->rx_pending != lif->nrxq_descs)\n\t\tnetdev_info(netdev, \"Changing Rx ring size from %d to %d\\n\",\n\t\t\t    lif->nrxq_descs, ring->rx_pending);\n\n\t \n\tif (!netif_running(lif->netdev)) {\n\t\tlif->ntxq_descs = ring->tx_pending;\n\t\tlif->nrxq_descs = ring->rx_pending;\n\t\treturn 0;\n\t}\n\n\tmutex_lock(&lif->queue_lock);\n\terr = ionic_reconfigure_queues(lif, &qparam);\n\tmutex_unlock(&lif->queue_lock);\n\tif (err)\n\t\tnetdev_info(netdev, \"Ring reconfiguration failed, changes canceled: %d\\n\", err);\n\n\treturn err;\n}\n\nstatic void ionic_get_channels(struct net_device *netdev,\n\t\t\t       struct ethtool_channels *ch)\n{\n\tstruct ionic_lif *lif = netdev_priv(netdev);\n\n\t \n\tch->max_combined = lif->ionic->ntxqs_per_lif;\n\tch->max_rx = lif->ionic->ntxqs_per_lif / 2;\n\tch->max_tx = lif->ionic->ntxqs_per_lif / 2;\n\n\t \n\tif (test_bit(IONIC_LIF_F_SPLIT_INTR, lif->state)) {\n\t\tch->rx_count = lif->nxqs;\n\t\tch->tx_count = lif->nxqs;\n\t} else {\n\t\tch->combined_count = lif->nxqs;\n\t}\n}\n\nstatic int ionic_set_channels(struct net_device *netdev,\n\t\t\t      struct ethtool_channels *ch)\n{\n\tstruct ionic_lif *lif = netdev_priv(netdev);\n\tstruct ionic_queue_params qparam;\n\tint max_cnt;\n\tint err;\n\n\tif (test_bit(IONIC_LIF_F_FW_RESET, lif->state))\n\t\treturn -EBUSY;\n\n\tionic_init_queue_params(lif, &qparam);\n\n\tif (ch->rx_count != ch->tx_count) {\n\t\tnetdev_info(netdev, \"The rx and tx count must be equal\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (ch->combined_count && ch->rx_count) {\n\t\tnetdev_info(netdev, \"Use either combined or rx and tx, not both\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmax_cnt = lif->ionic->ntxqs_per_lif;\n\tif (ch->combined_count) {\n\t\tif (ch->combined_count > max_cnt)\n\t\t\treturn -EINVAL;\n\n\t\tif (test_bit(IONIC_LIF_F_SPLIT_INTR, lif->state))\n\t\t\tnetdev_info(lif->netdev, \"Sharing queue interrupts\\n\");\n\t\telse if (ch->combined_count == lif->nxqs)\n\t\t\treturn 0;\n\n\t\tif (lif->nxqs != ch->combined_count)\n\t\t\tnetdev_info(netdev, \"Changing queue count from %d to %d\\n\",\n\t\t\t\t    lif->nxqs, ch->combined_count);\n\n\t\tqparam.nxqs = ch->combined_count;\n\t\tqparam.intr_split = false;\n\t} else {\n\t\tmax_cnt /= 2;\n\t\tif (ch->rx_count > max_cnt)\n\t\t\treturn -EINVAL;\n\n\t\tif (!test_bit(IONIC_LIF_F_SPLIT_INTR, lif->state))\n\t\t\tnetdev_info(lif->netdev, \"Splitting queue interrupts\\n\");\n\t\telse if (ch->rx_count == lif->nxqs)\n\t\t\treturn 0;\n\n\t\tif (lif->nxqs != ch->rx_count)\n\t\t\tnetdev_info(netdev, \"Changing queue count from %d to %d\\n\",\n\t\t\t\t    lif->nxqs, ch->rx_count);\n\n\t\tqparam.nxqs = ch->rx_count;\n\t\tqparam.intr_split = true;\n\t}\n\n\terr = ionic_validate_cmb_config(lif, &qparam);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tif (!netif_running(lif->netdev)) {\n\t\tlif->nxqs = qparam.nxqs;\n\n\t\tif (qparam.intr_split) {\n\t\t\tset_bit(IONIC_LIF_F_SPLIT_INTR, lif->state);\n\t\t} else {\n\t\t\tclear_bit(IONIC_LIF_F_SPLIT_INTR, lif->state);\n\t\t\tlif->tx_coalesce_usecs = lif->rx_coalesce_usecs;\n\t\t\tlif->tx_coalesce_hw = lif->rx_coalesce_hw;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tmutex_lock(&lif->queue_lock);\n\terr = ionic_reconfigure_queues(lif, &qparam);\n\tmutex_unlock(&lif->queue_lock);\n\tif (err)\n\t\tnetdev_info(netdev, \"Queue reconfiguration failed, changes canceled: %d\\n\", err);\n\n\treturn err;\n}\n\nstatic int ionic_get_rxnfc(struct net_device *netdev,\n\t\t\t   struct ethtool_rxnfc *info, u32 *rules)\n{\n\tstruct ionic_lif *lif = netdev_priv(netdev);\n\tint err = 0;\n\n\tswitch (info->cmd) {\n\tcase ETHTOOL_GRXRINGS:\n\t\tinfo->data = lif->nxqs;\n\t\tbreak;\n\tdefault:\n\t\tnetdev_dbg(netdev, \"Command parameter %d is not supported\\n\",\n\t\t\t   info->cmd);\n\t\terr = -EOPNOTSUPP;\n\t}\n\n\treturn err;\n}\n\nstatic u32 ionic_get_rxfh_indir_size(struct net_device *netdev)\n{\n\tstruct ionic_lif *lif = netdev_priv(netdev);\n\n\treturn le16_to_cpu(lif->ionic->ident.lif.eth.rss_ind_tbl_sz);\n}\n\nstatic u32 ionic_get_rxfh_key_size(struct net_device *netdev)\n{\n\treturn IONIC_RSS_HASH_KEY_SIZE;\n}\n\nstatic int ionic_get_rxfh(struct net_device *netdev, u32 *indir, u8 *key,\n\t\t\t  u8 *hfunc)\n{\n\tstruct ionic_lif *lif = netdev_priv(netdev);\n\tunsigned int i, tbl_sz;\n\n\tif (indir) {\n\t\ttbl_sz = le16_to_cpu(lif->ionic->ident.lif.eth.rss_ind_tbl_sz);\n\t\tfor (i = 0; i < tbl_sz; i++)\n\t\t\tindir[i] = lif->rss_ind_tbl[i];\n\t}\n\n\tif (key)\n\t\tmemcpy(key, lif->rss_hash_key, IONIC_RSS_HASH_KEY_SIZE);\n\n\tif (hfunc)\n\t\t*hfunc = ETH_RSS_HASH_TOP;\n\n\treturn 0;\n}\n\nstatic int ionic_set_rxfh(struct net_device *netdev, const u32 *indir,\n\t\t\t  const u8 *key, const u8 hfunc)\n{\n\tstruct ionic_lif *lif = netdev_priv(netdev);\n\n\tif (hfunc != ETH_RSS_HASH_NO_CHANGE && hfunc != ETH_RSS_HASH_TOP)\n\t\treturn -EOPNOTSUPP;\n\n\treturn ionic_lif_rss_config(lif, lif->rss_types, key, indir);\n}\n\nstatic int ionic_set_tunable(struct net_device *dev,\n\t\t\t     const struct ethtool_tunable *tuna,\n\t\t\t     const void *data)\n{\n\tstruct ionic_lif *lif = netdev_priv(dev);\n\n\tswitch (tuna->id) {\n\tcase ETHTOOL_RX_COPYBREAK:\n\t\tlif->rx_copybreak = *(u32 *)data;\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic int ionic_get_tunable(struct net_device *netdev,\n\t\t\t     const struct ethtool_tunable *tuna, void *data)\n{\n\tstruct ionic_lif *lif = netdev_priv(netdev);\n\n\tswitch (tuna->id) {\n\tcase ETHTOOL_RX_COPYBREAK:\n\t\t*(u32 *)data = lif->rx_copybreak;\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic int ionic_get_module_info(struct net_device *netdev,\n\t\t\t\t struct ethtool_modinfo *modinfo)\n\n{\n\tstruct ionic_lif *lif = netdev_priv(netdev);\n\tstruct ionic_dev *idev = &lif->ionic->idev;\n\tstruct ionic_xcvr_status *xcvr;\n\tstruct sfp_eeprom_base *sfp;\n\n\txcvr = &idev->port_info->status.xcvr;\n\tsfp = (struct sfp_eeprom_base *) xcvr->sprom;\n\n\t \n\tswitch (sfp->phys_id) {\n\tcase SFF8024_ID_SFP:\n\t\tmodinfo->type = ETH_MODULE_SFF_8079;\n\t\tmodinfo->eeprom_len = ETH_MODULE_SFF_8079_LEN;\n\t\tbreak;\n\tcase SFF8024_ID_QSFP_8436_8636:\n\tcase SFF8024_ID_QSFP28_8636:\n\t\tmodinfo->type = ETH_MODULE_SFF_8436;\n\t\tmodinfo->eeprom_len = ETH_MODULE_SFF_8436_LEN;\n\t\tbreak;\n\tdefault:\n\t\tnetdev_info(netdev, \"unknown xcvr type 0x%02x\\n\",\n\t\t\t    xcvr->sprom[0]);\n\t\tmodinfo->type = 0;\n\t\tmodinfo->eeprom_len = ETH_MODULE_SFF_8079_LEN;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int ionic_get_module_eeprom(struct net_device *netdev,\n\t\t\t\t   struct ethtool_eeprom *ee,\n\t\t\t\t   u8 *data)\n{\n\tstruct ionic_lif *lif = netdev_priv(netdev);\n\tstruct ionic_dev *idev = &lif->ionic->idev;\n\tstruct ionic_xcvr_status *xcvr;\n\tchar tbuf[sizeof(xcvr->sprom)];\n\tint count = 10;\n\tu32 len;\n\n\t \n\txcvr = &idev->port_info->status.xcvr;\n\tlen = min_t(u32, sizeof(xcvr->sprom), ee->len);\n\n\tdo {\n\t\tmemcpy(data, xcvr->sprom, len);\n\t\tmemcpy(tbuf, xcvr->sprom, len);\n\n\t\t \n\t\tif (!memcmp(data, tbuf, len))\n\t\t\tbreak;\n\n\t} while (--count);\n\n\tif (!count)\n\t\treturn -ETIMEDOUT;\n\n\treturn 0;\n}\n\nstatic int ionic_get_ts_info(struct net_device *netdev,\n\t\t\t     struct ethtool_ts_info *info)\n{\n\tstruct ionic_lif *lif = netdev_priv(netdev);\n\tstruct ionic *ionic = lif->ionic;\n\t__le64 mask;\n\n\tif (!lif->phc || !lif->phc->ptp)\n\t\treturn ethtool_op_get_ts_info(netdev, info);\n\n\tinfo->phc_index = ptp_clock_index(lif->phc->ptp);\n\n\tinfo->so_timestamping = SOF_TIMESTAMPING_TX_SOFTWARE |\n\t\t\t\tSOF_TIMESTAMPING_RX_SOFTWARE |\n\t\t\t\tSOF_TIMESTAMPING_SOFTWARE |\n\t\t\t\tSOF_TIMESTAMPING_TX_HARDWARE |\n\t\t\t\tSOF_TIMESTAMPING_RX_HARDWARE |\n\t\t\t\tSOF_TIMESTAMPING_RAW_HARDWARE;\n\n\t \n\n\tinfo->tx_types = BIT(HWTSTAMP_TX_OFF) |\n\t\t\t BIT(HWTSTAMP_TX_ON);\n\n\tmask = cpu_to_le64(BIT_ULL(IONIC_TXSTAMP_ONESTEP_SYNC));\n\tif (ionic->ident.lif.eth.hwstamp_tx_modes & mask)\n\t\tinfo->tx_types |= BIT(HWTSTAMP_TX_ONESTEP_SYNC);\n\n\tmask = cpu_to_le64(BIT_ULL(IONIC_TXSTAMP_ONESTEP_P2P));\n\tif (ionic->ident.lif.eth.hwstamp_tx_modes & mask)\n\t\tinfo->tx_types |= BIT(HWTSTAMP_TX_ONESTEP_P2P);\n\n\t \n\n\tinfo->rx_filters = BIT(HWTSTAMP_FILTER_NONE) |\n\t\t\t   BIT(HWTSTAMP_FILTER_ALL);\n\n\tmask = cpu_to_le64(IONIC_PKT_CLS_NTP_ALL);\n\tif ((ionic->ident.lif.eth.hwstamp_rx_filters & mask) == mask)\n\t\tinfo->rx_filters |= BIT(HWTSTAMP_FILTER_NTP_ALL);\n\n\tmask = cpu_to_le64(IONIC_PKT_CLS_PTP1_SYNC);\n\tif ((ionic->ident.lif.eth.hwstamp_rx_filters & mask) == mask)\n\t\tinfo->rx_filters |= BIT(HWTSTAMP_FILTER_PTP_V1_L4_SYNC);\n\n\tmask = cpu_to_le64(IONIC_PKT_CLS_PTP1_DREQ);\n\tif ((ionic->ident.lif.eth.hwstamp_rx_filters & mask) == mask)\n\t\tinfo->rx_filters |= BIT(HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ);\n\n\tmask = cpu_to_le64(IONIC_PKT_CLS_PTP1_ALL);\n\tif ((ionic->ident.lif.eth.hwstamp_rx_filters & mask) == mask)\n\t\tinfo->rx_filters |= BIT(HWTSTAMP_FILTER_PTP_V1_L4_EVENT);\n\n\tmask = cpu_to_le64(IONIC_PKT_CLS_PTP2_L4_SYNC);\n\tif ((ionic->ident.lif.eth.hwstamp_rx_filters & mask) == mask)\n\t\tinfo->rx_filters |= BIT(HWTSTAMP_FILTER_PTP_V2_L4_SYNC);\n\n\tmask = cpu_to_le64(IONIC_PKT_CLS_PTP2_L4_DREQ);\n\tif ((ionic->ident.lif.eth.hwstamp_rx_filters & mask) == mask)\n\t\tinfo->rx_filters |= BIT(HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ);\n\n\tmask = cpu_to_le64(IONIC_PKT_CLS_PTP2_L4_ALL);\n\tif ((ionic->ident.lif.eth.hwstamp_rx_filters & mask) == mask)\n\t\tinfo->rx_filters |= BIT(HWTSTAMP_FILTER_PTP_V2_L4_EVENT);\n\n\tmask = cpu_to_le64(IONIC_PKT_CLS_PTP2_L2_SYNC);\n\tif ((ionic->ident.lif.eth.hwstamp_rx_filters & mask) == mask)\n\t\tinfo->rx_filters |= BIT(HWTSTAMP_FILTER_PTP_V2_L2_SYNC);\n\n\tmask = cpu_to_le64(IONIC_PKT_CLS_PTP2_L2_DREQ);\n\tif ((ionic->ident.lif.eth.hwstamp_rx_filters & mask) == mask)\n\t\tinfo->rx_filters |= BIT(HWTSTAMP_FILTER_PTP_V2_L2_DELAY_REQ);\n\n\tmask = cpu_to_le64(IONIC_PKT_CLS_PTP2_L2_ALL);\n\tif ((ionic->ident.lif.eth.hwstamp_rx_filters & mask) == mask)\n\t\tinfo->rx_filters |= BIT(HWTSTAMP_FILTER_PTP_V2_L2_EVENT);\n\n\tmask = cpu_to_le64(IONIC_PKT_CLS_PTP2_SYNC);\n\tif ((ionic->ident.lif.eth.hwstamp_rx_filters & mask) == mask)\n\t\tinfo->rx_filters |= BIT(HWTSTAMP_FILTER_PTP_V2_SYNC);\n\n\tmask = cpu_to_le64(IONIC_PKT_CLS_PTP2_DREQ);\n\tif ((ionic->ident.lif.eth.hwstamp_rx_filters & mask) == mask)\n\t\tinfo->rx_filters |= BIT(HWTSTAMP_FILTER_PTP_V2_DELAY_REQ);\n\n\tmask = cpu_to_le64(IONIC_PKT_CLS_PTP2_ALL);\n\tif ((ionic->ident.lif.eth.hwstamp_rx_filters & mask) == mask)\n\t\tinfo->rx_filters |= BIT(HWTSTAMP_FILTER_PTP_V2_EVENT);\n\n\treturn 0;\n}\n\nstatic int ionic_nway_reset(struct net_device *netdev)\n{\n\tstruct ionic_lif *lif = netdev_priv(netdev);\n\tstruct ionic *ionic = lif->ionic;\n\tint err = 0;\n\n\tif (test_bit(IONIC_LIF_F_FW_RESET, lif->state))\n\t\treturn -EBUSY;\n\n\t \n\n\tmutex_lock(&ionic->dev_cmd_lock);\n\n\tionic_dev_cmd_port_state(&ionic->idev, IONIC_PORT_ADMIN_STATE_DOWN);\n\terr = ionic_dev_cmd_wait(ionic, DEVCMD_TIMEOUT);\n\n\tif (!err) {\n\t\tionic_dev_cmd_port_state(&ionic->idev, IONIC_PORT_ADMIN_STATE_UP);\n\t\terr = ionic_dev_cmd_wait(ionic, DEVCMD_TIMEOUT);\n\t}\n\n\tmutex_unlock(&ionic->dev_cmd_lock);\n\n\treturn err;\n}\n\nstatic const struct ethtool_ops ionic_ethtool_ops = {\n\t.supported_coalesce_params = ETHTOOL_COALESCE_USECS |\n\t\t\t\t     ETHTOOL_COALESCE_USE_ADAPTIVE_RX |\n\t\t\t\t     ETHTOOL_COALESCE_USE_ADAPTIVE_TX,\n\t.supported_ring_params = ETHTOOL_RING_USE_TX_PUSH |\n\t\t\t\t ETHTOOL_RING_USE_RX_PUSH,\n\t.get_drvinfo\t\t= ionic_get_drvinfo,\n\t.get_regs_len\t\t= ionic_get_regs_len,\n\t.get_regs\t\t= ionic_get_regs,\n\t.get_link\t\t= ethtool_op_get_link,\n\t.get_link_ext_stats\t= ionic_get_link_ext_stats,\n\t.get_link_ksettings\t= ionic_get_link_ksettings,\n\t.set_link_ksettings\t= ionic_set_link_ksettings,\n\t.get_coalesce\t\t= ionic_get_coalesce,\n\t.set_coalesce\t\t= ionic_set_coalesce,\n\t.get_ringparam\t\t= ionic_get_ringparam,\n\t.set_ringparam\t\t= ionic_set_ringparam,\n\t.get_channels\t\t= ionic_get_channels,\n\t.set_channels\t\t= ionic_set_channels,\n\t.get_strings\t\t= ionic_get_strings,\n\t.get_ethtool_stats\t= ionic_get_stats,\n\t.get_sset_count\t\t= ionic_get_sset_count,\n\t.get_rxnfc\t\t= ionic_get_rxnfc,\n\t.get_rxfh_indir_size\t= ionic_get_rxfh_indir_size,\n\t.get_rxfh_key_size\t= ionic_get_rxfh_key_size,\n\t.get_rxfh\t\t= ionic_get_rxfh,\n\t.set_rxfh\t\t= ionic_set_rxfh,\n\t.get_tunable\t\t= ionic_get_tunable,\n\t.set_tunable\t\t= ionic_set_tunable,\n\t.get_module_info\t= ionic_get_module_info,\n\t.get_module_eeprom\t= ionic_get_module_eeprom,\n\t.get_pauseparam\t\t= ionic_get_pauseparam,\n\t.set_pauseparam\t\t= ionic_set_pauseparam,\n\t.get_fecparam\t\t= ionic_get_fecparam,\n\t.set_fecparam\t\t= ionic_set_fecparam,\n\t.get_ts_info\t\t= ionic_get_ts_info,\n\t.nway_reset\t\t= ionic_nway_reset,\n};\n\nvoid ionic_ethtool_set_ops(struct net_device *netdev)\n{\n\tnetdev->ethtool_ops = &ionic_ethtool_ops;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}