{
  "module_name": "ionic_rx_filter.c",
  "hash_id": "8269270da1aa5e336351ff25d070ff9b34569c245748a4b27860d3aead3a82f6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/pensando/ionic/ionic_rx_filter.c",
  "human_readable_source": "\n \n\n#include <linux/netdevice.h>\n#include <linux/dynamic_debug.h>\n#include <linux/etherdevice.h>\n#include <linux/list.h>\n\n#include \"ionic.h\"\n#include \"ionic_lif.h\"\n#include \"ionic_rx_filter.h\"\n\nvoid ionic_rx_filter_free(struct ionic_lif *lif, struct ionic_rx_filter *f)\n{\n\tstruct device *dev = lif->ionic->dev;\n\n\thlist_del(&f->by_id);\n\thlist_del(&f->by_hash);\n\tdevm_kfree(dev, f);\n}\n\nvoid ionic_rx_filter_replay(struct ionic_lif *lif)\n{\n\tstruct ionic_rx_filter_add_cmd *ac;\n\tstruct hlist_head new_id_list;\n\tstruct ionic_admin_ctx ctx;\n\tstruct ionic_rx_filter *f;\n\tstruct hlist_head *head;\n\tstruct hlist_node *tmp;\n\tunsigned int key;\n\tunsigned int i;\n\tint err;\n\n\tINIT_HLIST_HEAD(&new_id_list);\n\tac = &ctx.cmd.rx_filter_add;\n\n\tfor (i = 0; i < IONIC_RX_FILTER_HLISTS; i++) {\n\t\thead = &lif->rx_filters.by_id[i];\n\t\thlist_for_each_entry_safe(f, tmp, head, by_id) {\n\t\t\tctx.work = COMPLETION_INITIALIZER_ONSTACK(ctx.work);\n\t\t\tmemcpy(ac, &f->cmd, sizeof(f->cmd));\n\t\t\tdev_dbg(&lif->netdev->dev, \"replay filter command:\\n\");\n\t\t\tdynamic_hex_dump(\"cmd \", DUMP_PREFIX_OFFSET, 16, 1,\n\t\t\t\t\t &ctx.cmd, sizeof(ctx.cmd), true);\n\n\t\t\terr = ionic_adminq_post_wait(lif, &ctx);\n\t\t\tif (err) {\n\t\t\t\tswitch (le16_to_cpu(ac->match)) {\n\t\t\t\tcase IONIC_RX_FILTER_MATCH_VLAN:\n\t\t\t\t\tnetdev_info(lif->netdev, \"Replay failed - %d: vlan %d\\n\",\n\t\t\t\t\t\t    err,\n\t\t\t\t\t\t    le16_to_cpu(ac->vlan.vlan));\n\t\t\t\t\tbreak;\n\t\t\t\tcase IONIC_RX_FILTER_MATCH_MAC:\n\t\t\t\t\tnetdev_info(lif->netdev, \"Replay failed - %d: mac %pM\\n\",\n\t\t\t\t\t\t    err, ac->mac.addr);\n\t\t\t\t\tbreak;\n\t\t\t\tcase IONIC_RX_FILTER_MATCH_MAC_VLAN:\n\t\t\t\t\tnetdev_info(lif->netdev, \"Replay failed - %d: vlan %d mac %pM\\n\",\n\t\t\t\t\t\t    err,\n\t\t\t\t\t\t    le16_to_cpu(ac->vlan.vlan),\n\t\t\t\t\t\t    ac->mac.addr);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tspin_lock_bh(&lif->rx_filters.lock);\n\t\t\t\tionic_rx_filter_free(lif, f);\n\t\t\t\tspin_unlock_bh(&lif->rx_filters.lock);\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t \n\t\t\tspin_lock_bh(&lif->rx_filters.lock);\n\t\t\thlist_del(&f->by_id);\n\t\t\tspin_unlock_bh(&lif->rx_filters.lock);\n\t\t\tf->filter_id = le32_to_cpu(ctx.comp.rx_filter_add.filter_id);\n\t\t\thlist_add_head(&f->by_id, &new_id_list);\n\t\t}\n\t}\n\n\t \n\tspin_lock_bh(&lif->rx_filters.lock);\n\thlist_for_each_entry_safe(f, tmp, &new_id_list, by_id) {\n\t\tkey = f->filter_id & IONIC_RX_FILTER_HLISTS_MASK;\n\t\thead = &lif->rx_filters.by_id[key];\n\t\thlist_add_head(&f->by_id, head);\n\t}\n\tspin_unlock_bh(&lif->rx_filters.lock);\n}\n\nint ionic_rx_filters_init(struct ionic_lif *lif)\n{\n\tunsigned int i;\n\n\tspin_lock_init(&lif->rx_filters.lock);\n\n\tspin_lock_bh(&lif->rx_filters.lock);\n\tfor (i = 0; i < IONIC_RX_FILTER_HLISTS; i++) {\n\t\tINIT_HLIST_HEAD(&lif->rx_filters.by_hash[i]);\n\t\tINIT_HLIST_HEAD(&lif->rx_filters.by_id[i]);\n\t}\n\tspin_unlock_bh(&lif->rx_filters.lock);\n\n\treturn 0;\n}\n\nvoid ionic_rx_filters_deinit(struct ionic_lif *lif)\n{\n\tstruct ionic_rx_filter *f;\n\tstruct hlist_head *head;\n\tstruct hlist_node *tmp;\n\tunsigned int i;\n\n\tspin_lock_bh(&lif->rx_filters.lock);\n\tfor (i = 0; i < IONIC_RX_FILTER_HLISTS; i++) {\n\t\thead = &lif->rx_filters.by_id[i];\n\t\thlist_for_each_entry_safe(f, tmp, head, by_id)\n\t\t\tionic_rx_filter_free(lif, f);\n\t}\n\tspin_unlock_bh(&lif->rx_filters.lock);\n}\n\nint ionic_rx_filter_save(struct ionic_lif *lif, u32 flow_id, u16 rxq_index,\n\t\t\t u32 hash, struct ionic_admin_ctx *ctx,\n\t\t\t enum ionic_filter_state state)\n{\n\tstruct device *dev = lif->ionic->dev;\n\tstruct ionic_rx_filter_add_cmd *ac;\n\tstruct ionic_rx_filter *f = NULL;\n\tstruct hlist_head *head;\n\tunsigned int key;\n\n\tac = &ctx->cmd.rx_filter_add;\n\n\tswitch (le16_to_cpu(ac->match)) {\n\tcase IONIC_RX_FILTER_MATCH_VLAN:\n\t\tkey = le16_to_cpu(ac->vlan.vlan);\n\t\tf = ionic_rx_filter_by_vlan(lif, le16_to_cpu(ac->vlan.vlan));\n\t\tbreak;\n\tcase IONIC_RX_FILTER_MATCH_MAC:\n\t\tkey = *(u32 *)ac->mac.addr;\n\t\tf = ionic_rx_filter_by_addr(lif, ac->mac.addr);\n\t\tbreak;\n\tcase IONIC_RX_FILTER_MATCH_MAC_VLAN:\n\t\tkey = le16_to_cpu(ac->mac_vlan.vlan);\n\t\tbreak;\n\tcase IONIC_RX_FILTER_STEER_PKTCLASS:\n\t\tkey = 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (f) {\n\t\t \n\t\thlist_del(&f->by_id);\n\t\thlist_del(&f->by_hash);\n\t} else {\n\t\tf = devm_kzalloc(dev, sizeof(*f), GFP_ATOMIC);\n\t\tif (!f)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tf->flow_id = flow_id;\n\tf->filter_id = le32_to_cpu(ctx->comp.rx_filter_add.filter_id);\n\tf->state = state;\n\tf->rxq_index = rxq_index;\n\tmemcpy(&f->cmd, ac, sizeof(f->cmd));\n\tnetdev_dbg(lif->netdev, \"rx_filter add filter_id %d\\n\", f->filter_id);\n\n\tINIT_HLIST_NODE(&f->by_hash);\n\tINIT_HLIST_NODE(&f->by_id);\n\n\tkey = hash_32(key, IONIC_RX_FILTER_HASH_BITS);\n\thead = &lif->rx_filters.by_hash[key];\n\thlist_add_head(&f->by_hash, head);\n\n\tkey = f->filter_id & IONIC_RX_FILTER_HLISTS_MASK;\n\thead = &lif->rx_filters.by_id[key];\n\thlist_add_head(&f->by_id, head);\n\n\treturn 0;\n}\n\nstruct ionic_rx_filter *ionic_rx_filter_by_vlan(struct ionic_lif *lif, u16 vid)\n{\n\tstruct ionic_rx_filter *f;\n\tstruct hlist_head *head;\n\tunsigned int key;\n\n\tkey = hash_32(vid, IONIC_RX_FILTER_HASH_BITS);\n\thead = &lif->rx_filters.by_hash[key];\n\n\thlist_for_each_entry(f, head, by_hash) {\n\t\tif (le16_to_cpu(f->cmd.match) != IONIC_RX_FILTER_MATCH_VLAN)\n\t\t\tcontinue;\n\t\tif (le16_to_cpu(f->cmd.vlan.vlan) == vid)\n\t\t\treturn f;\n\t}\n\n\treturn NULL;\n}\n\nstruct ionic_rx_filter *ionic_rx_filter_by_addr(struct ionic_lif *lif,\n\t\t\t\t\t\tconst u8 *addr)\n{\n\tstruct ionic_rx_filter *f;\n\tstruct hlist_head *head;\n\tunsigned int key;\n\n\tkey = hash_32(*(u32 *)addr, IONIC_RX_FILTER_HASH_BITS);\n\thead = &lif->rx_filters.by_hash[key];\n\n\thlist_for_each_entry(f, head, by_hash) {\n\t\tif (le16_to_cpu(f->cmd.match) != IONIC_RX_FILTER_MATCH_MAC)\n\t\t\tcontinue;\n\t\tif (memcmp(addr, f->cmd.mac.addr, ETH_ALEN) == 0)\n\t\t\treturn f;\n\t}\n\n\treturn NULL;\n}\n\nstruct ionic_rx_filter *ionic_rx_filter_rxsteer(struct ionic_lif *lif)\n{\n\tstruct ionic_rx_filter *f;\n\tstruct hlist_head *head;\n\tunsigned int key;\n\n\tkey = hash_32(0, IONIC_RX_FILTER_HASH_BITS);\n\thead = &lif->rx_filters.by_hash[key];\n\n\thlist_for_each_entry(f, head, by_hash) {\n\t\tif (le16_to_cpu(f->cmd.match) != IONIC_RX_FILTER_STEER_PKTCLASS)\n\t\t\tcontinue;\n\t\treturn f;\n\t}\n\n\treturn NULL;\n}\n\nstatic struct ionic_rx_filter *ionic_rx_filter_find(struct ionic_lif *lif,\n\t\t\t\t\t\t    struct ionic_rx_filter_add_cmd *ac)\n{\n\tswitch (le16_to_cpu(ac->match)) {\n\tcase IONIC_RX_FILTER_MATCH_VLAN:\n\t\treturn ionic_rx_filter_by_vlan(lif, le16_to_cpu(ac->vlan.vlan));\n\tcase IONIC_RX_FILTER_MATCH_MAC:\n\t\treturn ionic_rx_filter_by_addr(lif, ac->mac.addr);\n\tdefault:\n\t\tnetdev_err(lif->netdev, \"unsupported filter match %d\",\n\t\t\t   le16_to_cpu(ac->match));\n\t\treturn NULL;\n\t}\n}\n\nint ionic_lif_list_addr(struct ionic_lif *lif, const u8 *addr, bool mode)\n{\n\tstruct ionic_rx_filter *f;\n\tint err;\n\n\tspin_lock_bh(&lif->rx_filters.lock);\n\n\tf = ionic_rx_filter_by_addr(lif, addr);\n\tif (mode == ADD_ADDR && !f) {\n\t\tstruct ionic_admin_ctx ctx = {\n\t\t\t.work = COMPLETION_INITIALIZER_ONSTACK(ctx.work),\n\t\t\t.cmd.rx_filter_add = {\n\t\t\t\t.opcode = IONIC_CMD_RX_FILTER_ADD,\n\t\t\t\t.lif_index = cpu_to_le16(lif->index),\n\t\t\t\t.match = cpu_to_le16(IONIC_RX_FILTER_MATCH_MAC),\n\t\t\t},\n\t\t};\n\n\t\tmemcpy(ctx.cmd.rx_filter_add.mac.addr, addr, ETH_ALEN);\n\t\terr = ionic_rx_filter_save(lif, 0, IONIC_RXQ_INDEX_ANY, 0, &ctx,\n\t\t\t\t\t   IONIC_FILTER_STATE_NEW);\n\t\tif (err) {\n\t\t\tspin_unlock_bh(&lif->rx_filters.lock);\n\t\t\treturn err;\n\t\t}\n\n\t} else if (mode == ADD_ADDR && f) {\n\t\tif (f->state == IONIC_FILTER_STATE_OLD)\n\t\t\tf->state = IONIC_FILTER_STATE_SYNCED;\n\n\t} else if (mode == DEL_ADDR && f) {\n\t\tif (f->state == IONIC_FILTER_STATE_NEW)\n\t\t\tionic_rx_filter_free(lif, f);\n\t\telse if (f->state == IONIC_FILTER_STATE_SYNCED)\n\t\t\tf->state = IONIC_FILTER_STATE_OLD;\n\t} else if (mode == DEL_ADDR && !f) {\n\t\tspin_unlock_bh(&lif->rx_filters.lock);\n\t\treturn -ENOENT;\n\t}\n\n\tspin_unlock_bh(&lif->rx_filters.lock);\n\n\tset_bit(IONIC_LIF_F_FILTER_SYNC_NEEDED, lif->state);\n\n\treturn 0;\n}\n\nstatic int ionic_lif_filter_add(struct ionic_lif *lif,\n\t\t\t\tstruct ionic_rx_filter_add_cmd *ac)\n{\n\tstruct ionic_admin_ctx ctx = {\n\t\t.work = COMPLETION_INITIALIZER_ONSTACK(ctx.work),\n\t};\n\tstruct ionic_rx_filter *f;\n\tint nfilters;\n\tint err = 0;\n\n\tctx.cmd.rx_filter_add = *ac;\n\tctx.cmd.rx_filter_add.opcode = IONIC_CMD_RX_FILTER_ADD,\n\tctx.cmd.rx_filter_add.lif_index = cpu_to_le16(lif->index),\n\n\tspin_lock_bh(&lif->rx_filters.lock);\n\tf = ionic_rx_filter_find(lif, &ctx.cmd.rx_filter_add);\n\tif (f) {\n\t\t \n\t\tif (f->state == IONIC_FILTER_STATE_SYNCED) {\n\t\t\tspin_unlock_bh(&lif->rx_filters.lock);\n\t\t\treturn 0;\n\t\t}\n\n\t\t \n\t\tf->state = IONIC_FILTER_STATE_SYNCED;\n\t} else {\n\t\t \n\t\terr = ionic_rx_filter_save(lif, 0, IONIC_RXQ_INDEX_ANY, 0, &ctx,\n\t\t\t\t\t   IONIC_FILTER_STATE_SYNCED);\n\t}\n\tspin_unlock_bh(&lif->rx_filters.lock);\n\tif (err)\n\t\treturn err;\n\n\t \n\tswitch (le16_to_cpu(ctx.cmd.rx_filter_add.match)) {\n\tcase IONIC_RX_FILTER_MATCH_VLAN:\n\t\tnetdev_dbg(lif->netdev, \"%s: rx_filter add VLAN %d\\n\",\n\t\t\t   __func__, ctx.cmd.rx_filter_add.vlan.vlan);\n\t\tif (lif->max_vlans && lif->nvlans >= lif->max_vlans)\n\t\t\terr = -ENOSPC;\n\t\tbreak;\n\tcase IONIC_RX_FILTER_MATCH_MAC:\n\t\tnetdev_dbg(lif->netdev, \"%s: rx_filter add ADDR %pM\\n\",\n\t\t\t   __func__, ctx.cmd.rx_filter_add.mac.addr);\n\t\tnfilters = le32_to_cpu(lif->identity->eth.max_ucast_filters);\n\t\tif ((lif->nucast + lif->nmcast) >= nfilters)\n\t\t\terr = -ENOSPC;\n\t\tbreak;\n\t}\n\n\tif (err != -ENOSPC)\n\t\terr = ionic_adminq_post_wait_nomsg(lif, &ctx);\n\n\tspin_lock_bh(&lif->rx_filters.lock);\n\n\tif (err && err != -EEXIST) {\n\t\t \n\t\tf = ionic_rx_filter_find(lif, &ctx.cmd.rx_filter_add);\n\t\tif (f && f->state == IONIC_FILTER_STATE_SYNCED) {\n\t\t\tf->state = IONIC_FILTER_STATE_NEW;\n\n\t\t\t \n\t\t\tif (err != -ENOSPC)\n\t\t\t\tset_bit(IONIC_LIF_F_FILTER_SYNC_NEEDED, lif->state);\n\t\t}\n\n\t\tspin_unlock_bh(&lif->rx_filters.lock);\n\n\t\t \n\t\tif (err == -ENOSPC &&\n\t\t    le16_to_cpu(ctx.cmd.rx_filter_add.match) == IONIC_RX_FILTER_MATCH_VLAN)\n\t\t\tlif->max_vlans = lif->nvlans;\n\n\t\t \n\t\tswitch (err) {\n\t\tcase -ENOSPC:\n\t\tcase -ENXIO:\n\t\tcase -ETIMEDOUT:\n\t\tcase -EAGAIN:\n\t\tcase -EBUSY:\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tionic_adminq_netdev_err_print(lif, ctx.cmd.cmd.opcode,\n\t\t\t\t\t      ctx.comp.comp.status, err);\n\t\tswitch (le16_to_cpu(ctx.cmd.rx_filter_add.match)) {\n\t\tcase IONIC_RX_FILTER_MATCH_VLAN:\n\t\t\tnetdev_info(lif->netdev, \"rx_filter add failed: VLAN %d\\n\",\n\t\t\t\t    ctx.cmd.rx_filter_add.vlan.vlan);\n\t\t\tbreak;\n\t\tcase IONIC_RX_FILTER_MATCH_MAC:\n\t\t\tnetdev_info(lif->netdev, \"rx_filter add failed: ADDR %pM\\n\",\n\t\t\t\t    ctx.cmd.rx_filter_add.mac.addr);\n\t\t\tbreak;\n\t\t}\n\n\t\treturn err;\n\t}\n\n\tswitch (le16_to_cpu(ctx.cmd.rx_filter_add.match)) {\n\tcase IONIC_RX_FILTER_MATCH_VLAN:\n\t\tlif->nvlans++;\n\t\tbreak;\n\tcase IONIC_RX_FILTER_MATCH_MAC:\n\t\tif (is_multicast_ether_addr(ctx.cmd.rx_filter_add.mac.addr))\n\t\t\tlif->nmcast++;\n\t\telse\n\t\t\tlif->nucast++;\n\t\tbreak;\n\t}\n\n\tf = ionic_rx_filter_find(lif, &ctx.cmd.rx_filter_add);\n\tif (f && f->state == IONIC_FILTER_STATE_OLD) {\n\t\t \n\t\terr = ionic_rx_filter_save(lif, 0, IONIC_RXQ_INDEX_ANY, 0, &ctx,\n\t\t\t\t\t   IONIC_FILTER_STATE_OLD);\n\t} else {\n\t\terr = ionic_rx_filter_save(lif, 0, IONIC_RXQ_INDEX_ANY, 0, &ctx,\n\t\t\t\t\t   IONIC_FILTER_STATE_SYNCED);\n\t}\n\n\tspin_unlock_bh(&lif->rx_filters.lock);\n\n\treturn err;\n}\n\nint ionic_lif_addr_add(struct ionic_lif *lif, const u8 *addr)\n{\n\tstruct ionic_rx_filter_add_cmd ac = {\n\t\t.match = cpu_to_le16(IONIC_RX_FILTER_MATCH_MAC),\n\t};\n\n\tmemcpy(&ac.mac.addr, addr, ETH_ALEN);\n\n\treturn ionic_lif_filter_add(lif, &ac);\n}\n\nint ionic_lif_vlan_add(struct ionic_lif *lif, const u16 vid)\n{\n\tstruct ionic_rx_filter_add_cmd ac = {\n\t\t.match = cpu_to_le16(IONIC_RX_FILTER_MATCH_VLAN),\n\t\t.vlan.vlan = cpu_to_le16(vid),\n\t};\n\n\treturn ionic_lif_filter_add(lif, &ac);\n}\n\nstatic int ionic_lif_filter_del(struct ionic_lif *lif,\n\t\t\t\tstruct ionic_rx_filter_add_cmd *ac)\n{\n\tstruct ionic_admin_ctx ctx = {\n\t\t.work = COMPLETION_INITIALIZER_ONSTACK(ctx.work),\n\t\t.cmd.rx_filter_del = {\n\t\t\t.opcode = IONIC_CMD_RX_FILTER_DEL,\n\t\t\t.lif_index = cpu_to_le16(lif->index),\n\t\t},\n\t};\n\tstruct ionic_rx_filter *f;\n\tint state;\n\tint err;\n\n\tspin_lock_bh(&lif->rx_filters.lock);\n\tf = ionic_rx_filter_find(lif, ac);\n\tif (!f) {\n\t\tspin_unlock_bh(&lif->rx_filters.lock);\n\t\treturn -ENOENT;\n\t}\n\n\tswitch (le16_to_cpu(ac->match)) {\n\tcase IONIC_RX_FILTER_MATCH_VLAN:\n\t\tnetdev_dbg(lif->netdev, \"%s: rx_filter del VLAN %d id %d\\n\",\n\t\t\t   __func__, ac->vlan.vlan, f->filter_id);\n\t\tlif->nvlans--;\n\t\tbreak;\n\tcase IONIC_RX_FILTER_MATCH_MAC:\n\t\tnetdev_dbg(lif->netdev, \"%s: rx_filter del ADDR %pM id %d\\n\",\n\t\t\t   __func__, ac->mac.addr, f->filter_id);\n\t\tif (is_multicast_ether_addr(ac->mac.addr) && lif->nmcast)\n\t\t\tlif->nmcast--;\n\t\telse if (!is_multicast_ether_addr(ac->mac.addr) && lif->nucast)\n\t\t\tlif->nucast--;\n\t\tbreak;\n\t}\n\n\tstate = f->state;\n\tctx.cmd.rx_filter_del.filter_id = cpu_to_le32(f->filter_id);\n\tionic_rx_filter_free(lif, f);\n\n\tspin_unlock_bh(&lif->rx_filters.lock);\n\n\tif (state != IONIC_FILTER_STATE_NEW) {\n\t\terr = ionic_adminq_post_wait_nomsg(lif, &ctx);\n\n\t\tswitch (err) {\n\t\t\t \n\t\tcase -EEXIST:\n\t\tcase -ENXIO:\n\t\tcase -ETIMEDOUT:\n\t\tcase -EAGAIN:\n\t\tcase -EBUSY:\n\t\tcase 0:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tionic_adminq_netdev_err_print(lif, ctx.cmd.cmd.opcode,\n\t\t\t\t\t\t      ctx.comp.comp.status, err);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint ionic_lif_addr_del(struct ionic_lif *lif, const u8 *addr)\n{\n\tstruct ionic_rx_filter_add_cmd ac = {\n\t\t.match = cpu_to_le16(IONIC_RX_FILTER_MATCH_MAC),\n\t};\n\n\tmemcpy(&ac.mac.addr, addr, ETH_ALEN);\n\n\treturn ionic_lif_filter_del(lif, &ac);\n}\n\nint ionic_lif_vlan_del(struct ionic_lif *lif, const u16 vid)\n{\n\tstruct ionic_rx_filter_add_cmd ac = {\n\t\t.match = cpu_to_le16(IONIC_RX_FILTER_MATCH_VLAN),\n\t\t.vlan.vlan = cpu_to_le16(vid),\n\t};\n\n\treturn ionic_lif_filter_del(lif, &ac);\n}\n\nstruct sync_item {\n\tstruct list_head list;\n\tstruct ionic_rx_filter f;\n};\n\nvoid ionic_rx_filter_sync(struct ionic_lif *lif)\n{\n\tstruct device *dev = lif->ionic->dev;\n\tstruct list_head sync_add_list;\n\tstruct list_head sync_del_list;\n\tstruct sync_item *sync_item;\n\tstruct ionic_rx_filter *f;\n\tstruct hlist_head *head;\n\tstruct hlist_node *tmp;\n\tstruct sync_item *spos;\n\tunsigned int i;\n\n\tINIT_LIST_HEAD(&sync_add_list);\n\tINIT_LIST_HEAD(&sync_del_list);\n\n\tclear_bit(IONIC_LIF_F_FILTER_SYNC_NEEDED, lif->state);\n\n\t \n\tspin_lock_bh(&lif->rx_filters.lock);\n\tfor (i = 0; i < IONIC_RX_FILTER_HLISTS; i++) {\n\t\thead = &lif->rx_filters.by_id[i];\n\t\thlist_for_each_entry_safe(f, tmp, head, by_id) {\n\t\t\tif (f->state == IONIC_FILTER_STATE_NEW ||\n\t\t\t    f->state == IONIC_FILTER_STATE_OLD) {\n\t\t\t\tsync_item = devm_kzalloc(dev, sizeof(*sync_item),\n\t\t\t\t\t\t\t GFP_ATOMIC);\n\t\t\t\tif (!sync_item)\n\t\t\t\t\tgoto loop_out;\n\n\t\t\t\tsync_item->f = *f;\n\n\t\t\t\tif (f->state == IONIC_FILTER_STATE_NEW)\n\t\t\t\t\tlist_add(&sync_item->list, &sync_add_list);\n\t\t\t\telse\n\t\t\t\t\tlist_add(&sync_item->list, &sync_del_list);\n\t\t\t}\n\t\t}\n\t}\nloop_out:\n\tspin_unlock_bh(&lif->rx_filters.lock);\n\n\t \n\tlist_for_each_entry_safe(sync_item, spos, &sync_del_list, list) {\n\t\tionic_lif_filter_del(lif, &sync_item->f.cmd);\n\n\t\tlist_del(&sync_item->list);\n\t\tdevm_kfree(dev, sync_item);\n\t}\n\n\tlist_for_each_entry_safe(sync_item, spos, &sync_add_list, list) {\n\t\tionic_lif_filter_add(lif, &sync_item->f.cmd);\n\n\t\tlist_del(&sync_item->list);\n\t\tdevm_kfree(dev, sync_item);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}