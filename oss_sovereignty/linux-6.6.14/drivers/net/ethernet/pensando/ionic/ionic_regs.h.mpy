{
  "module_name": "ionic_regs.h",
  "hash_id": "5f3a14c44df6632ef2afdb184c47c9247db6a043b89c6af5a6c70d53c41026df",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/pensando/ionic/ionic_regs.h",
  "human_readable_source": " \n \n\n#ifndef IONIC_REGS_H\n#define IONIC_REGS_H\n\n#include <linux/io.h>\n\n \nstruct ionic_intr {\n\tu32 coal_init;\n\tu32 mask;\n\tu32 credits;\n\tu32 mask_assert;\n\tu32 coal;\n\tu32 rsvd[3];\n};\n\n#define IONIC_INTR_CTRL_REGS_MAX\t2048\n#define IONIC_INTR_CTRL_COAL_MAX\t0x3F\n\n \nenum ionic_intr_mask_vals {\n\tIONIC_INTR_MASK_CLEAR\t\t= 0,\n\tIONIC_INTR_MASK_SET\t\t= 1,\n};\n\n \nenum ionic_intr_credits_bits {\n\tIONIC_INTR_CRED_COUNT\t\t= 0x7fffu,\n\tIONIC_INTR_CRED_COUNT_SIGNED\t= 0xffffu,\n\tIONIC_INTR_CRED_UNMASK\t\t= 0x10000u,\n\tIONIC_INTR_CRED_RESET_COALESCE\t= 0x20000u,\n\tIONIC_INTR_CRED_REARM\t\t= (IONIC_INTR_CRED_UNMASK |\n\t\t\t\t\t   IONIC_INTR_CRED_RESET_COALESCE),\n};\n\nstatic inline void ionic_intr_coal_init(struct ionic_intr __iomem *intr_ctrl,\n\t\t\t\t\tint intr_idx, u32 coal)\n{\n\tiowrite32(coal, &intr_ctrl[intr_idx].coal_init);\n}\n\nstatic inline void ionic_intr_mask(struct ionic_intr __iomem *intr_ctrl,\n\t\t\t\t   int intr_idx, u32 mask)\n{\n\tiowrite32(mask, &intr_ctrl[intr_idx].mask);\n}\n\nstatic inline void ionic_intr_credits(struct ionic_intr __iomem *intr_ctrl,\n\t\t\t\t      int intr_idx, u32 cred, u32 flags)\n{\n\tif (WARN_ON_ONCE(cred > IONIC_INTR_CRED_COUNT)) {\n\t\tcred = ioread32(&intr_ctrl[intr_idx].credits);\n\t\tcred &= IONIC_INTR_CRED_COUNT_SIGNED;\n\t}\n\n\tiowrite32(cred | flags, &intr_ctrl[intr_idx].credits);\n}\n\nstatic inline void ionic_intr_clean(struct ionic_intr __iomem *intr_ctrl,\n\t\t\t\t    int intr_idx)\n{\n\tu32 cred;\n\n\tcred = ioread32(&intr_ctrl[intr_idx].credits);\n\tcred &= IONIC_INTR_CRED_COUNT_SIGNED;\n\tcred |= IONIC_INTR_CRED_RESET_COALESCE;\n\tiowrite32(cred, &intr_ctrl[intr_idx].credits);\n}\n\nstatic inline void ionic_intr_mask_assert(struct ionic_intr __iomem *intr_ctrl,\n\t\t\t\t\t  int intr_idx, u32 mask)\n{\n\tiowrite32(mask, &intr_ctrl[intr_idx].mask_assert);\n}\n\n \nenum ionic_dbell_bits {\n\tIONIC_DBELL_QID_MASK\t\t= 0xffffff,\n\tIONIC_DBELL_QID_SHIFT\t\t= 24,\n\n#define IONIC_DBELL_QID(n) \\\n\t(((u64)(n) & IONIC_DBELL_QID_MASK) << IONIC_DBELL_QID_SHIFT)\n\n\tIONIC_DBELL_RING_MASK\t\t= 0x7,\n\tIONIC_DBELL_RING_SHIFT\t\t= 16,\n\n#define IONIC_DBELL_RING(n) \\\n\t(((u64)(n) & IONIC_DBELL_RING_MASK) << IONIC_DBELL_RING_SHIFT)\n\n\tIONIC_DBELL_RING_0\t\t= 0,\n\tIONIC_DBELL_RING_1\t\t= IONIC_DBELL_RING(1),\n\tIONIC_DBELL_RING_2\t\t= IONIC_DBELL_RING(2),\n\tIONIC_DBELL_RING_3\t\t= IONIC_DBELL_RING(3),\n\n\tIONIC_DBELL_INDEX_MASK\t\t= 0xffff,\n};\n\nstatic inline void ionic_dbell_ring(u64 __iomem *db_page, int qtype, u64 val)\n{\n\twriteq(val, &db_page[qtype]);\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}