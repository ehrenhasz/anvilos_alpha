{
  "module_name": "dcb.c",
  "hash_id": "6aa3f86bbad22e1689c7d39bd501e1c4c0044093876847eafa4fceae82d48486",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/netronome/nfp/nic/dcb.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/netdevice.h>\n#include <net/dcbnl.h>\n\n#include \"../nfp_app.h\"\n#include \"../nfp_net.h\"\n#include \"../nfp_main.h\"\n#include \"../nfpcore/nfp_cpp.h\"\n#include \"../nfpcore/nfp_nffw.h\"\n#include \"../nfp_net_sriov.h\"\n\n#include \"main.h\"\n\n#define NFP_DCB_TRUST_PCP\t1\n#define NFP_DCB_TRUST_DSCP\t2\n#define NFP_DCB_TRUST_INVALID\t0xff\n\n#define NFP_DCB_TSA_VENDOR\t1\n#define NFP_DCB_TSA_STRICT\t2\n#define NFP_DCB_TSA_ETS\t\t3\n\n#define NFP_DCB_GBL_ENABLE\tBIT(0)\n#define NFP_DCB_QOS_ENABLE\tBIT(1)\n#define NFP_DCB_DISABLE\t\t0\n#define NFP_DCB_ALL_QOS_ENABLE\t(NFP_DCB_GBL_ENABLE | NFP_DCB_QOS_ENABLE)\n\n#define NFP_DCB_UPDATE_MSK_SZ\t4\n#define NFP_DCB_TC_RATE_MAX\t0xffff\n\n#define NFP_DCB_DATA_OFF_DSCP2IDX\t0\n#define NFP_DCB_DATA_OFF_PCP2IDX\t64\n#define NFP_DCB_DATA_OFF_TSA\t\t80\n#define NFP_DCB_DATA_OFF_IDX_BW_PCT\t88\n#define NFP_DCB_DATA_OFF_RATE\t\t96\n#define NFP_DCB_DATA_OFF_CAP\t\t112\n#define NFP_DCB_DATA_OFF_ENABLE\t\t116\n#define NFP_DCB_DATA_OFF_TRUST\t\t120\n\n#define NFP_DCB_MSG_MSK_ENABLE\tBIT(31)\n#define NFP_DCB_MSG_MSK_TRUST\tBIT(30)\n#define NFP_DCB_MSG_MSK_TSA\tBIT(29)\n#define NFP_DCB_MSG_MSK_DSCP\tBIT(28)\n#define NFP_DCB_MSG_MSK_PCP\tBIT(27)\n#define NFP_DCB_MSG_MSK_RATE\tBIT(26)\n#define NFP_DCB_MSG_MSK_PCT\tBIT(25)\n\nstatic struct nfp_dcb *get_dcb_priv(struct nfp_net *nn)\n{\n\tstruct nfp_dcb *dcb = &((struct nfp_app_nic_private *)nn->app_priv)->dcb;\n\n\treturn dcb;\n}\n\nstatic u8 nfp_tsa_ieee2nfp(u8 tsa)\n{\n\tswitch (tsa) {\n\tcase IEEE_8021QAZ_TSA_STRICT:\n\t\treturn NFP_DCB_TSA_STRICT;\n\tcase IEEE_8021QAZ_TSA_ETS:\n\t\treturn NFP_DCB_TSA_ETS;\n\tdefault:\n\t\treturn NFP_DCB_TSA_VENDOR;\n\t}\n}\n\nstatic int nfp_nic_dcbnl_ieee_getets(struct net_device *dev,\n\t\t\t\t     struct ieee_ets *ets)\n{\n\tstruct nfp_net *nn = netdev_priv(dev);\n\tstruct nfp_dcb *dcb;\n\n\tdcb = get_dcb_priv(nn);\n\n\tfor (unsigned int i = 0; i < IEEE_8021QAZ_MAX_TCS; i++) {\n\t\tets->prio_tc[i] = dcb->prio2tc[i];\n\t\tets->tc_tx_bw[i] = dcb->tc_tx_pct[i];\n\t\tets->tc_tsa[i] = dcb->tc_tsa[i];\n\t}\n\n\treturn 0;\n}\n\nstatic bool nfp_refresh_tc2idx(struct nfp_net *nn)\n{\n\tu8 tc2idx[IEEE_8021QAZ_MAX_TCS];\n\tbool change = false;\n\tstruct nfp_dcb *dcb;\n\tint maxstrict = 0;\n\n\tdcb = get_dcb_priv(nn);\n\n\tfor (unsigned int i = 0; i < IEEE_8021QAZ_MAX_TCS; i++) {\n\t\ttc2idx[i] = i;\n\t\tif (dcb->tc_tsa[i] == IEEE_8021QAZ_TSA_STRICT)\n\t\t\tmaxstrict = i;\n\t}\n\n\tif (maxstrict > 0 && dcb->tc_tsa[0] != IEEE_8021QAZ_TSA_STRICT) {\n\t\ttc2idx[0] = maxstrict;\n\t\ttc2idx[maxstrict] = 0;\n\t}\n\n\tfor (unsigned int j = 0; j < IEEE_8021QAZ_MAX_TCS; j++) {\n\t\tif (dcb->tc2idx[j] != tc2idx[j]) {\n\t\t\tchange = true;\n\t\t\tdcb->tc2idx[j] = tc2idx[j];\n\t\t}\n\t}\n\n\treturn change;\n}\n\nstatic int nfp_fill_maxrate(struct nfp_net *nn, u64 *max_rate_array)\n{\n\tstruct nfp_app *app  = nn->app;\n\tstruct nfp_dcb *dcb;\n\tu32 ratembps;\n\n\tdcb = get_dcb_priv(nn);\n\n\tfor (unsigned int i = 0; i < IEEE_8021QAZ_MAX_TCS; i++) {\n\t\t \n\t\tratembps = max_rate_array[i] / 1024;\n\n\t\t \n\t\tif (ratembps >= NFP_DCB_TC_RATE_MAX) {\n\t\t\tnfp_warn(app->cpp, \"ratembps(%d) must less than %d.\",\n\t\t\t\t ratembps, NFP_DCB_TC_RATE_MAX);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t \n\t\tif (ratembps == 0)\n\t\t\tratembps = NFP_DCB_TC_RATE_MAX;\n\n\t\twritew((u16)ratembps, dcb->dcbcfg_tbl +\n\t\t       dcb->cfg_offset + NFP_DCB_DATA_OFF_RATE + dcb->tc2idx[i] * 2);\n\t\t \n\t\tif (dcb->tc_maxrate != max_rate_array)\n\t\t\tdcb->tc_maxrate[i] = max_rate_array[i];\n\t}\n\n\treturn 0;\n}\n\nstatic int update_dscp_maxrate(struct net_device *dev, u32 *update)\n{\n\tstruct nfp_net *nn = netdev_priv(dev);\n\tstruct nfp_dcb *dcb;\n\tint err;\n\n\tdcb = get_dcb_priv(nn);\n\n\terr = nfp_fill_maxrate(nn, dcb->tc_maxrate);\n\tif (err)\n\t\treturn err;\n\n\t*update |= NFP_DCB_MSG_MSK_RATE;\n\n\t \n\tif (dcb->dscp_cnt > 0) {\n\t\tfor (unsigned int i = 0; i < NFP_NET_MAX_DSCP; i++) {\n\t\t\twriteb(dcb->tc2idx[dcb->prio2tc[dcb->dscp2prio[i]]],\n\t\t\t       dcb->dcbcfg_tbl + dcb->cfg_offset +\n\t\t\t       NFP_DCB_DATA_OFF_DSCP2IDX + i);\n\t\t}\n\t\t*update |= NFP_DCB_MSG_MSK_DSCP;\n\t}\n\n\treturn 0;\n}\n\nstatic void nfp_nic_set_trust(struct nfp_net *nn, u32 *update)\n{\n\tstruct nfp_dcb *dcb;\n\tu8 trust;\n\n\tdcb = get_dcb_priv(nn);\n\n\tif (dcb->trust_status != NFP_DCB_TRUST_INVALID)\n\t\treturn;\n\n\ttrust = dcb->dscp_cnt > 0 ? NFP_DCB_TRUST_DSCP : NFP_DCB_TRUST_PCP;\n\twriteb(trust, dcb->dcbcfg_tbl + dcb->cfg_offset +\n\t       NFP_DCB_DATA_OFF_TRUST);\n\n\tdcb->trust_status = trust;\n\t*update |= NFP_DCB_MSG_MSK_TRUST;\n}\n\nstatic void nfp_nic_set_enable(struct nfp_net *nn, u32 enable, u32 *update)\n{\n\tstruct nfp_dcb *dcb;\n\tu32 value = 0;\n\n\tdcb = get_dcb_priv(nn);\n\n\tvalue = readl(dcb->dcbcfg_tbl + dcb->cfg_offset +\n\t\t      NFP_DCB_DATA_OFF_ENABLE);\n\tif (value != enable) {\n\t\twritel(enable, dcb->dcbcfg_tbl + dcb->cfg_offset +\n\t\t       NFP_DCB_DATA_OFF_ENABLE);\n\t\t*update |= NFP_DCB_MSG_MSK_ENABLE;\n\t}\n}\n\nstatic int dcb_ets_check(struct net_device *dev, struct ieee_ets *ets)\n{\n\tstruct nfp_net *nn = netdev_priv(dev);\n\tstruct nfp_app *app = nn->app;\n\tbool ets_exists = false;\n\tint sum = 0;\n\n\tfor (unsigned int i = 0; i < IEEE_8021QAZ_MAX_TCS; i++) {\n\t\t \n\t\tif (ets->tc_tsa[i] == IEEE_8021QAZ_TSA_ETS) {\n\t\t\tets_exists = true;\n\t\t\tsum += ets->tc_tx_bw[i];\n\t\t} else if (ets->tc_tx_bw[i]) {\n\t\t\tnfp_warn(app->cpp, \"ETS BW for strict/vendor TC must be 0.\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (ets_exists && sum != 100) {\n\t\tnfp_warn(app->cpp, \"Failed to validate ETS BW: sum must be 100.\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void nfp_nic_fill_ets(struct nfp_net *nn)\n{\n\tstruct nfp_dcb *dcb;\n\n\tdcb = get_dcb_priv(nn);\n\n\tfor (unsigned int i = 0; i < IEEE_8021QAZ_MAX_TCS; i++) {\n\t\twriteb(dcb->tc2idx[dcb->prio2tc[i]],\n\t\t       dcb->dcbcfg_tbl + dcb->cfg_offset + NFP_DCB_DATA_OFF_PCP2IDX + i);\n\t\twriteb(dcb->tc_tx_pct[i], dcb->dcbcfg_tbl +\n\t\t       dcb->cfg_offset + NFP_DCB_DATA_OFF_IDX_BW_PCT + dcb->tc2idx[i]);\n\t\twriteb(nfp_tsa_ieee2nfp(dcb->tc_tsa[i]), dcb->dcbcfg_tbl +\n\t\t       dcb->cfg_offset + NFP_DCB_DATA_OFF_TSA + dcb->tc2idx[i]);\n\t}\n}\n\nstatic void nfp_nic_ets_init(struct nfp_net *nn, u32 *update)\n{\n\tstruct nfp_dcb *dcb = get_dcb_priv(nn);\n\n\tif (dcb->ets_init)\n\t\treturn;\n\n\tnfp_nic_fill_ets(nn);\n\tdcb->ets_init = true;\n\t*update |= NFP_DCB_MSG_MSK_TSA | NFP_DCB_MSG_MSK_PCT | NFP_DCB_MSG_MSK_PCP;\n}\n\nstatic int nfp_nic_dcbnl_ieee_setets(struct net_device *dev,\n\t\t\t\t     struct ieee_ets *ets)\n{\n\tconst u32 cmd = NFP_NET_CFG_MBOX_CMD_DCB_UPDATE;\n\tstruct nfp_net *nn = netdev_priv(dev);\n\tstruct nfp_app *app = nn->app;\n\tstruct nfp_dcb *dcb;\n\tu32 update = 0;\n\tbool change;\n\tint err;\n\n\terr = dcb_ets_check(dev, ets);\n\tif (err)\n\t\treturn err;\n\n\tdcb = get_dcb_priv(nn);\n\n\tfor (unsigned int i = 0; i < IEEE_8021QAZ_MAX_TCS; i++) {\n\t\tdcb->prio2tc[i] = ets->prio_tc[i];\n\t\tdcb->tc_tx_pct[i] = ets->tc_tx_bw[i];\n\t\tdcb->tc_tsa[i] = ets->tc_tsa[i];\n\t}\n\n\tchange = nfp_refresh_tc2idx(nn);\n\tnfp_nic_fill_ets(nn);\n\tdcb->ets_init = true;\n\tif (change || !dcb->rate_init) {\n\t\terr = update_dscp_maxrate(dev, &update);\n\t\tif (err) {\n\t\t\tnfp_warn(app->cpp,\n\t\t\t\t \"nfp dcbnl ieee setets ERROR:%d.\",\n\t\t\t\t err);\n\t\t\treturn err;\n\t\t}\n\n\t\tdcb->rate_init = true;\n\t}\n\tnfp_nic_set_enable(nn, NFP_DCB_ALL_QOS_ENABLE, &update);\n\tnfp_nic_set_trust(nn, &update);\n\terr = nfp_net_mbox_lock(nn, NFP_DCB_UPDATE_MSK_SZ);\n\tif (err)\n\t\treturn err;\n\n\tnn_writel(nn, nn->tlv_caps.mbox_off + NFP_NET_CFG_MBOX_SIMPLE_VAL,\n\t\t  update | NFP_DCB_MSG_MSK_TSA | NFP_DCB_MSG_MSK_PCT |\n\t\t  NFP_DCB_MSG_MSK_PCP);\n\n\treturn nfp_net_mbox_reconfig_and_unlock(nn, cmd);\n}\n\nstatic int nfp_nic_dcbnl_ieee_getmaxrate(struct net_device *dev,\n\t\t\t\t\t struct ieee_maxrate *maxrate)\n{\n\tstruct nfp_net *nn = netdev_priv(dev);\n\tstruct nfp_dcb *dcb;\n\n\tdcb = get_dcb_priv(nn);\n\n\tfor (unsigned int i = 0; i < IEEE_8021QAZ_MAX_TCS; i++)\n\t\tmaxrate->tc_maxrate[i] = dcb->tc_maxrate[i];\n\n\treturn 0;\n}\n\nstatic int nfp_nic_dcbnl_ieee_setmaxrate(struct net_device *dev,\n\t\t\t\t\t struct ieee_maxrate *maxrate)\n{\n\tconst u32 cmd = NFP_NET_CFG_MBOX_CMD_DCB_UPDATE;\n\tstruct nfp_net *nn = netdev_priv(dev);\n\tstruct nfp_app *app = nn->app;\n\tstruct nfp_dcb *dcb;\n\tu32 update = 0;\n\tint err;\n\n\terr = nfp_fill_maxrate(nn, maxrate->tc_maxrate);\n\tif (err) {\n\t\tnfp_warn(app->cpp,\n\t\t\t \"nfp dcbnl ieee setmaxrate ERROR:%d.\",\n\t\t\t err);\n\t\treturn err;\n\t}\n\n\tdcb = get_dcb_priv(nn);\n\n\tdcb->rate_init = true;\n\tnfp_nic_set_enable(nn, NFP_DCB_ALL_QOS_ENABLE, &update);\n\tnfp_nic_set_trust(nn, &update);\n\tnfp_nic_ets_init(nn, &update);\n\n\terr = nfp_net_mbox_lock(nn, NFP_DCB_UPDATE_MSK_SZ);\n\tif (err)\n\t\treturn err;\n\n\tnn_writel(nn, nn->tlv_caps.mbox_off + NFP_NET_CFG_MBOX_SIMPLE_VAL,\n\t\t  update | NFP_DCB_MSG_MSK_RATE);\n\n\treturn nfp_net_mbox_reconfig_and_unlock(nn, cmd);\n}\n\nstatic int nfp_nic_set_trust_status(struct nfp_net *nn, u8 status)\n{\n\tconst u32 cmd = NFP_NET_CFG_MBOX_CMD_DCB_UPDATE;\n\tstruct nfp_dcb *dcb;\n\tu32 update = 0;\n\tint err;\n\n\tdcb = get_dcb_priv(nn);\n\tif (!dcb->rate_init) {\n\t\terr = nfp_fill_maxrate(nn, dcb->tc_maxrate);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tupdate |= NFP_DCB_MSG_MSK_RATE;\n\t\tdcb->rate_init = true;\n\t}\n\n\terr = nfp_net_mbox_lock(nn, NFP_DCB_UPDATE_MSK_SZ);\n\tif (err)\n\t\treturn err;\n\n\tnfp_nic_ets_init(nn, &update);\n\twriteb(status, dcb->dcbcfg_tbl + dcb->cfg_offset +\n\t       NFP_DCB_DATA_OFF_TRUST);\n\tnfp_nic_set_enable(nn, NFP_DCB_ALL_QOS_ENABLE, &update);\n\tnn_writel(nn, nn->tlv_caps.mbox_off + NFP_NET_CFG_MBOX_SIMPLE_VAL,\n\t\t  update | NFP_DCB_MSG_MSK_TRUST);\n\n\terr = nfp_net_mbox_reconfig_and_unlock(nn, cmd);\n\tif (err)\n\t\treturn err;\n\n\tdcb->trust_status = status;\n\n\treturn 0;\n}\n\nstatic int nfp_nic_set_dscp2prio(struct nfp_net *nn, u8 dscp, u8 prio)\n{\n\tconst u32 cmd = NFP_NET_CFG_MBOX_CMD_DCB_UPDATE;\n\tstruct nfp_dcb *dcb;\n\tu8 idx, tc;\n\tint err;\n\n\terr = nfp_net_mbox_lock(nn, NFP_DCB_UPDATE_MSK_SZ);\n\tif (err)\n\t\treturn err;\n\n\tdcb = get_dcb_priv(nn);\n\n\ttc = dcb->prio2tc[prio];\n\tidx = dcb->tc2idx[tc];\n\n\twriteb(idx, dcb->dcbcfg_tbl + dcb->cfg_offset +\n\t       NFP_DCB_DATA_OFF_DSCP2IDX + dscp);\n\n\tnn_writel(nn, nn->tlv_caps.mbox_off +\n\t\t  NFP_NET_CFG_MBOX_SIMPLE_VAL, NFP_DCB_MSG_MSK_DSCP);\n\n\terr = nfp_net_mbox_reconfig_and_unlock(nn, cmd);\n\tif (err)\n\t\treturn err;\n\n\tdcb->dscp2prio[dscp] = prio;\n\n\treturn 0;\n}\n\nstatic int nfp_nic_dcbnl_ieee_setapp(struct net_device *dev,\n\t\t\t\t     struct dcb_app *app)\n{\n\tstruct nfp_net *nn = netdev_priv(dev);\n\tstruct dcb_app old_app;\n\tstruct nfp_dcb *dcb;\n\tbool is_new;\n\tint err;\n\n\tif (app->selector != IEEE_8021QAZ_APP_SEL_DSCP)\n\t\treturn -EINVAL;\n\n\tdcb = get_dcb_priv(nn);\n\n\t \n\told_app.selector = IEEE_8021QAZ_APP_SEL_DSCP;\n\told_app.protocol = app->protocol;\n\told_app.priority = dcb->dscp2prio[app->protocol];\n\n\t \n\tif (!dcb->dscp_cnt) {\n\t\terr = nfp_nic_set_trust_status(nn, NFP_DCB_TRUST_DSCP);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t \n\tif (app->priority != old_app.priority || app->priority == 0) {\n\t\terr = nfp_nic_set_dscp2prio(nn, app->protocol, app->priority);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t \n\tis_new = !!dcb_ieee_delapp(dev, &old_app);\n\n\t \n\terr = dcb_ieee_setapp(dev, app);\n\tif (err)\n\t\treturn err;\n\n\tif (is_new)\n\t\tdcb->dscp_cnt++;\n\n\treturn 0;\n}\n\nstatic int nfp_nic_dcbnl_ieee_delapp(struct net_device *dev,\n\t\t\t\t     struct dcb_app *app)\n{\n\tstruct nfp_net *nn = netdev_priv(dev);\n\tstruct nfp_dcb *dcb;\n\tint err;\n\n\tif (app->selector != IEEE_8021QAZ_APP_SEL_DSCP)\n\t\treturn -EINVAL;\n\n\tdcb = get_dcb_priv(nn);\n\n\t \n\tif (app->priority != dcb->dscp2prio[app->protocol])\n\t\treturn -ENOENT;\n\n\t \n\terr = nfp_nic_set_dscp2prio(nn, app->protocol, 0);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = dcb_ieee_delapp(dev, app);\n\tif (err)\n\t\treturn err;\n\n\t \n\tdcb->dscp_cnt--;\n\n\t \n\tif (dcb->dscp_cnt == 0)\n\t\treturn nfp_nic_set_trust_status(nn, NFP_DCB_TRUST_PCP);\n\n\treturn 0;\n}\n\nstatic const struct dcbnl_rtnl_ops nfp_nic_dcbnl_ops = {\n\t \n\t.ieee_getets\t= nfp_nic_dcbnl_ieee_getets,\n\t.ieee_setets\t= nfp_nic_dcbnl_ieee_setets,\n\t.ieee_getmaxrate = nfp_nic_dcbnl_ieee_getmaxrate,\n\t.ieee_setmaxrate = nfp_nic_dcbnl_ieee_setmaxrate,\n\t.ieee_setapp\t= nfp_nic_dcbnl_ieee_setapp,\n\t.ieee_delapp\t= nfp_nic_dcbnl_ieee_delapp,\n};\n\nint nfp_nic_dcb_init(struct nfp_net *nn)\n{\n\tstruct nfp_app *app = nn->app;\n\tstruct nfp_dcb *dcb;\n\tint err;\n\n\tdcb = get_dcb_priv(nn);\n\tdcb->cfg_offset = NFP_DCB_CFG_STRIDE * nn->id;\n\tdcb->dcbcfg_tbl = nfp_pf_map_rtsym(app->pf, \"net.dcbcfg_tbl\",\n\t\t\t\t\t   \"_abi_dcb_cfg\",\n\t\t\t\t\t   dcb->cfg_offset, &dcb->dcbcfg_tbl_area);\n\tif (IS_ERR(dcb->dcbcfg_tbl)) {\n\t\tif (PTR_ERR(dcb->dcbcfg_tbl) != -ENOENT) {\n\t\t\terr = PTR_ERR(dcb->dcbcfg_tbl);\n\t\t\tdcb->dcbcfg_tbl = NULL;\n\t\t\tnfp_err(app->cpp,\n\t\t\t\t\"Failed to map dcbcfg_tbl area, min_size %u.\\n\",\n\t\t\t\tdcb->cfg_offset);\n\t\t\treturn err;\n\t\t}\n\t\tdcb->dcbcfg_tbl = NULL;\n\t}\n\n\tif (dcb->dcbcfg_tbl) {\n\t\tfor (unsigned int i = 0; i < IEEE_8021QAZ_MAX_TCS; i++) {\n\t\t\tdcb->prio2tc[i] = i;\n\t\t\tdcb->tc2idx[i] = i;\n\t\t\tdcb->tc_tx_pct[i] = 0;\n\t\t\tdcb->tc_maxrate[i] = 0;\n\t\t\tdcb->tc_tsa[i] = IEEE_8021QAZ_TSA_VENDOR;\n\t\t}\n\t\tdcb->trust_status = NFP_DCB_TRUST_INVALID;\n\t\tdcb->rate_init = false;\n\t\tdcb->ets_init = false;\n\n\t\tnn->dp.netdev->dcbnl_ops = &nfp_nic_dcbnl_ops;\n\t}\n\n\treturn 0;\n}\n\nvoid nfp_nic_dcb_clean(struct nfp_net *nn)\n{\n\tstruct nfp_dcb *dcb;\n\n\tdcb = get_dcb_priv(nn);\n\tif (dcb->dcbcfg_tbl_area)\n\t\tnfp_cpp_area_release_free(dcb->dcbcfg_tbl_area);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}