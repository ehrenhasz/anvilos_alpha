{
  "module_name": "nfp_app.c",
  "hash_id": "97279062e5365d5ac2c27ea87acdd2a7221385c65003c8b9b313cb174bb4bcf7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/netronome/nfp/nfp_app.c",
  "human_readable_source": "\n \n\n#include <linux/bug.h>\n#include <linux/lockdep.h>\n#include <linux/rcupdate.h>\n#include <linux/skbuff.h>\n#include <linux/slab.h>\n\n#include \"nfpcore/nfp_cpp.h\"\n#include \"nfpcore/nfp_nffw.h\"\n#include \"nfp_app.h\"\n#include \"nfp_main.h\"\n#include \"nfp_net.h\"\n#include \"nfp_net_repr.h\"\n#include \"nfp_port.h\"\n\nstatic const struct nfp_app_type *apps[] = {\n\t[NFP_APP_CORE_NIC]\t= &app_nic,\n#ifdef CONFIG_BPF_SYSCALL\n\t[NFP_APP_BPF_NIC]\t= &app_bpf,\n#else\n\t[NFP_APP_BPF_NIC]\t= &app_nic,\n#endif\n#ifdef CONFIG_NFP_APP_FLOWER\n\t[NFP_APP_FLOWER_NIC]\t= &app_flower,\n#endif\n#ifdef CONFIG_NFP_APP_ABM_NIC\n\t[NFP_APP_ACTIVE_BUFFER_MGMT_NIC] = &app_abm,\n#endif\n};\n\nvoid nfp_check_rhashtable_empty(void *ptr, void *arg)\n{\n\tWARN_ON_ONCE(1);\n}\n\nstruct nfp_app *nfp_app_from_netdev(struct net_device *netdev)\n{\n\tif (nfp_netdev_is_nfp_net(netdev)) {\n\t\tstruct nfp_net *nn = netdev_priv(netdev);\n\n\t\treturn nn->app;\n\t}\n\n\tif (nfp_netdev_is_nfp_repr(netdev)) {\n\t\tstruct nfp_repr *repr = netdev_priv(netdev);\n\n\t\treturn repr->app;\n\t}\n\n\tWARN(1, \"Unknown netdev type for nfp_app\\n\");\n\n\treturn NULL;\n}\n\nconst char *nfp_app_mip_name(struct nfp_app *app)\n{\n\tif (!app || !app->pf->mip)\n\t\treturn \"\";\n\treturn nfp_mip_name(app->pf->mip);\n}\n\nint nfp_app_ndo_init(struct net_device *netdev)\n{\n\tstruct nfp_app *app = nfp_app_from_netdev(netdev);\n\n\tif (!app || !app->type->ndo_init)\n\t\treturn 0;\n\treturn app->type->ndo_init(app, netdev);\n}\n\nvoid nfp_app_ndo_uninit(struct net_device *netdev)\n{\n\tstruct nfp_app *app = nfp_app_from_netdev(netdev);\n\n\tif (app && app->type->ndo_uninit)\n\t\tapp->type->ndo_uninit(app, netdev);\n}\n\nu64 *nfp_app_port_get_stats(struct nfp_port *port, u64 *data)\n{\n\tif (!port || !port->app || !port->app->type->port_get_stats)\n\t\treturn data;\n\treturn port->app->type->port_get_stats(port->app, port, data);\n}\n\nint nfp_app_port_get_stats_count(struct nfp_port *port)\n{\n\tif (!port || !port->app || !port->app->type->port_get_stats_count)\n\t\treturn 0;\n\treturn port->app->type->port_get_stats_count(port->app, port);\n}\n\nu8 *nfp_app_port_get_stats_strings(struct nfp_port *port, u8 *data)\n{\n\tif (!port || !port->app || !port->app->type->port_get_stats_strings)\n\t\treturn data;\n\treturn port->app->type->port_get_stats_strings(port->app, port, data);\n}\n\nstruct sk_buff *\nnfp_app_ctrl_msg_alloc(struct nfp_app *app, unsigned int size, gfp_t priority)\n{\n\tstruct sk_buff *skb;\n\n\tif (nfp_app_ctrl_has_meta(app))\n\t\tsize += 8;\n\n\tskb = alloc_skb(size, priority);\n\tif (!skb)\n\t\treturn NULL;\n\n\tif (nfp_app_ctrl_has_meta(app))\n\t\tskb_reserve(skb, 8);\n\n\treturn skb;\n}\n\nstruct nfp_reprs *\nnfp_reprs_get_locked(struct nfp_app *app, enum nfp_repr_type type)\n{\n\treturn rcu_dereference_protected(app->reprs[type],\n\t\t\t\t\t nfp_app_is_locked(app));\n}\n\nstruct nfp_reprs *\nnfp_app_reprs_set(struct nfp_app *app, enum nfp_repr_type type,\n\t\t  struct nfp_reprs *reprs)\n{\n\tstruct nfp_reprs *old;\n\n\told = nfp_reprs_get_locked(app, type);\n\trtnl_lock();\n\trcu_assign_pointer(app->reprs[type], reprs);\n\trtnl_unlock();\n\n\treturn old;\n}\n\nstatic void\nnfp_app_netdev_feat_change(struct nfp_app *app, struct net_device *netdev)\n{\n\tstruct nfp_net *nn;\n\tunsigned int type;\n\n\tif (!nfp_netdev_is_nfp_net(netdev))\n\t\treturn;\n\tnn = netdev_priv(netdev);\n\tif (nn->app != app)\n\t\treturn;\n\n\tfor (type = 0; type < __NFP_REPR_TYPE_MAX; type++) {\n\t\tstruct nfp_reprs *reprs;\n\t\tunsigned int i;\n\n\t\treprs = rtnl_dereference(app->reprs[type]);\n\t\tif (!reprs)\n\t\t\tcontinue;\n\n\t\tfor (i = 0; i < reprs->num_reprs; i++) {\n\t\t\tstruct net_device *repr;\n\n\t\t\trepr = rtnl_dereference(reprs->reprs[i]);\n\t\t\tif (!repr)\n\t\t\t\tcontinue;\n\n\t\t\tnfp_repr_transfer_features(repr, netdev);\n\t\t}\n\t}\n}\n\nstatic int\nnfp_app_netdev_event(struct notifier_block *nb, unsigned long event, void *ptr)\n{\n\tstruct net_device *netdev;\n\tstruct nfp_app *app;\n\n\tnetdev = netdev_notifier_info_to_dev(ptr);\n\tapp = container_of(nb, struct nfp_app, netdev_nb);\n\n\t \n\tswitch (event) {\n\tcase NETDEV_FEAT_CHANGE:\n\t\tnfp_app_netdev_feat_change(app, netdev);\n\t\tbreak;\n\t}\n\n\t \n\tif (app->type->netdev_event)\n\t\treturn app->type->netdev_event(app, netdev, event, ptr);\n\treturn NOTIFY_DONE;\n}\n\nint nfp_app_start(struct nfp_app *app, struct nfp_net *ctrl)\n{\n\tint err;\n\n\tapp->ctrl = ctrl;\n\n\tif (app->type->start) {\n\t\terr = app->type->start(app);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tapp->netdev_nb.notifier_call = nfp_app_netdev_event;\n\terr = register_netdevice_notifier(&app->netdev_nb);\n\tif (err)\n\t\tgoto err_app_stop;\n\n\treturn 0;\n\nerr_app_stop:\n\tif (app->type->stop)\n\t\tapp->type->stop(app);\n\treturn err;\n}\n\nvoid nfp_app_stop(struct nfp_app *app)\n{\n\tunregister_netdevice_notifier(&app->netdev_nb);\n\n\tif (app->type->stop)\n\t\tapp->type->stop(app);\n}\n\nstruct nfp_app *nfp_app_alloc(struct nfp_pf *pf, enum nfp_app_id id)\n{\n\tstruct nfp_app *app;\n\n\tif (id >= ARRAY_SIZE(apps) || !apps[id]) {\n\t\tnfp_err(pf->cpp, \"unknown FW app ID 0x%02x, driver too old or support for FW not built in\\n\", id);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tif (WARN_ON(!apps[id]->name || !apps[id]->vnic_alloc))\n\t\treturn ERR_PTR(-EINVAL);\n\tif (WARN_ON(!apps[id]->ctrl_msg_rx && apps[id]->ctrl_msg_rx_raw))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tapp = kzalloc(sizeof(*app), GFP_KERNEL);\n\tif (!app)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tapp->pf = pf;\n\tapp->cpp = pf->cpp;\n\tapp->pdev = pf->pdev;\n\tapp->type = apps[id];\n\n\treturn app;\n}\n\nvoid nfp_app_free(struct nfp_app *app)\n{\n\tkfree(app);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}