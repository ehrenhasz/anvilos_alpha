{
  "module_name": "nfp_devlink.c",
  "hash_id": "f5436c89c2b3380a0daab486430723c15dc8afdbf6a894d06bebfc749c28378c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/netronome/nfp/nfp_devlink.c",
  "human_readable_source": "\n \n\n#include <linux/rtnetlink.h>\n#include <net/devlink.h>\n\n#include \"nfpcore/nfp.h\"\n#include \"nfpcore/nfp_nsp.h\"\n#include \"nfp_app.h\"\n#include \"nfp_main.h\"\n#include \"nfp_port.h\"\n\nstatic int\nnfp_devlink_fill_eth_port(struct nfp_port *port,\n\t\t\t  struct nfp_eth_table_port *copy)\n{\n\tstruct nfp_eth_table_port *eth_port;\n\n\teth_port = __nfp_port_get_eth_port(port);\n\tif (!eth_port)\n\t\treturn -EINVAL;\n\n\tmemcpy(copy, eth_port, sizeof(*eth_port));\n\n\treturn 0;\n}\n\nstatic int\nnfp_devlink_fill_eth_port_from_id(struct nfp_pf *pf,\n\t\t\t\t  struct devlink_port *dl_port,\n\t\t\t\t  struct nfp_eth_table_port *copy)\n{\n\tstruct nfp_port *port = container_of(dl_port, struct nfp_port, dl_port);\n\n\treturn nfp_devlink_fill_eth_port(port, copy);\n}\n\nstatic int\nnfp_devlink_set_lanes(struct nfp_pf *pf, unsigned int idx, unsigned int lanes)\n{\n\tstruct nfp_nsp *nsp;\n\tint ret;\n\n\tnsp = nfp_eth_config_start(pf->cpp, idx);\n\tif (IS_ERR(nsp))\n\t\treturn PTR_ERR(nsp);\n\n\tret = __nfp_eth_set_split(nsp, lanes);\n\tif (ret) {\n\t\tnfp_eth_config_cleanup_end(nsp);\n\t\treturn ret;\n\t}\n\n\tret = nfp_eth_config_commit_end(nsp);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret)  \n\t\treturn 0;\n\n\treturn nfp_net_refresh_port_table_sync(pf);\n}\n\nstatic int\nnfp_devlink_port_split(struct devlink *devlink, struct devlink_port *port,\n\t\t       unsigned int count, struct netlink_ext_ack *extack)\n{\n\tstruct nfp_pf *pf = devlink_priv(devlink);\n\tstruct nfp_eth_table_port eth_port;\n\tunsigned int lanes;\n\tint ret;\n\n\trtnl_lock();\n\tret = nfp_devlink_fill_eth_port_from_id(pf, port, &eth_port);\n\trtnl_unlock();\n\tif (ret)\n\t\treturn ret;\n\n\tif (eth_port.port_lanes % count)\n\t\treturn -EINVAL;\n\n\t \n\tlanes = eth_port.port_lanes / count;\n\tif (eth_port.lanes == 10 && count == 2)\n\t\tlanes = 8 / count;\n\n\treturn nfp_devlink_set_lanes(pf, eth_port.index, lanes);\n}\n\nstatic int\nnfp_devlink_port_unsplit(struct devlink *devlink, struct devlink_port *port,\n\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct nfp_pf *pf = devlink_priv(devlink);\n\tstruct nfp_eth_table_port eth_port;\n\tunsigned int lanes;\n\tint ret;\n\n\trtnl_lock();\n\tret = nfp_devlink_fill_eth_port_from_id(pf, port, &eth_port);\n\trtnl_unlock();\n\tif (ret)\n\t\treturn ret;\n\n\tif (!eth_port.is_split)\n\t\treturn -EINVAL;\n\n\t \n\tlanes = eth_port.port_lanes;\n\tif (eth_port.port_lanes == 8)\n\t\tlanes = 10;\n\n\treturn nfp_devlink_set_lanes(pf, eth_port.index, lanes);\n}\n\nstatic int\nnfp_devlink_sb_pool_get(struct devlink *devlink, unsigned int sb_index,\n\t\t\tu16 pool_index, struct devlink_sb_pool_info *pool_info)\n{\n\tstruct nfp_pf *pf = devlink_priv(devlink);\n\n\treturn nfp_shared_buf_pool_get(pf, sb_index, pool_index, pool_info);\n}\n\nstatic int\nnfp_devlink_sb_pool_set(struct devlink *devlink, unsigned int sb_index,\n\t\t\tu16 pool_index,\n\t\t\tu32 size, enum devlink_sb_threshold_type threshold_type,\n\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct nfp_pf *pf = devlink_priv(devlink);\n\n\treturn nfp_shared_buf_pool_set(pf, sb_index, pool_index,\n\t\t\t\t       size, threshold_type);\n}\n\nstatic int nfp_devlink_eswitch_mode_get(struct devlink *devlink, u16 *mode)\n{\n\tstruct nfp_pf *pf = devlink_priv(devlink);\n\n\treturn nfp_app_eswitch_mode_get(pf->app, mode);\n}\n\nstatic int nfp_devlink_eswitch_mode_set(struct devlink *devlink, u16 mode,\n\t\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct nfp_pf *pf = devlink_priv(devlink);\n\n\treturn nfp_app_eswitch_mode_set(pf->app, mode);\n}\n\nstatic const struct nfp_devlink_versions_simple {\n\tconst char *key;\n\tconst char *hwinfo;\n} nfp_devlink_versions_hwinfo[] = {\n\t{ DEVLINK_INFO_VERSION_GENERIC_BOARD_ID,\t\"assembly.partno\", },\n\t{ DEVLINK_INFO_VERSION_GENERIC_BOARD_REV,\t\"assembly.revision\", },\n\t{ DEVLINK_INFO_VERSION_GENERIC_BOARD_MANUFACTURE, \"assembly.vendor\", },\n\t{ \"board.model\",  \t\t\"assembly.model\", },\n};\n\nstatic int\nnfp_devlink_versions_get_hwinfo(struct nfp_pf *pf, struct devlink_info_req *req)\n{\n\tunsigned int i;\n\tint err;\n\n\tfor (i = 0; i < ARRAY_SIZE(nfp_devlink_versions_hwinfo); i++) {\n\t\tconst struct nfp_devlink_versions_simple *info;\n\t\tconst char *val;\n\n\t\tinfo = &nfp_devlink_versions_hwinfo[i];\n\n\t\tval = nfp_hwinfo_lookup(pf->hwinfo, info->hwinfo);\n\t\tif (!val)\n\t\t\tcontinue;\n\n\t\terr = devlink_info_version_fixed_put(req, info->key, val);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct nfp_devlink_versions {\n\tenum nfp_nsp_versions id;\n\tconst char *key;\n} nfp_devlink_versions_nsp[] = {\n\t{ NFP_VERSIONS_BUNDLE,\tDEVLINK_INFO_VERSION_GENERIC_FW_BUNDLE_ID, },\n\t{ NFP_VERSIONS_BSP,\tDEVLINK_INFO_VERSION_GENERIC_FW_MGMT, },\n\t{ NFP_VERSIONS_CPLD,\t\"fw.cpld\", },\n\t{ NFP_VERSIONS_APP,\tDEVLINK_INFO_VERSION_GENERIC_FW_APP, },\n\t{ NFP_VERSIONS_UNDI,\tDEVLINK_INFO_VERSION_GENERIC_FW_UNDI, },\n\t{ NFP_VERSIONS_NCSI,\tDEVLINK_INFO_VERSION_GENERIC_FW_NCSI, },\n\t{ NFP_VERSIONS_CFGR,\t\"chip.init\", },\n};\n\nstatic int\nnfp_devlink_versions_get_nsp(struct devlink_info_req *req, bool flash,\n\t\t\t     const u8 *buf, unsigned int size)\n{\n\tunsigned int i;\n\tint err;\n\n\tfor (i = 0; i < ARRAY_SIZE(nfp_devlink_versions_nsp); i++) {\n\t\tconst struct nfp_devlink_versions *info;\n\t\tconst char *version;\n\n\t\tinfo = &nfp_devlink_versions_nsp[i];\n\n\t\tversion = nfp_nsp_versions_get(info->id, flash, buf, size);\n\t\tif (IS_ERR(version)) {\n\t\t\tif (PTR_ERR(version) == -ENOENT)\n\t\t\t\tcontinue;\n\t\t\telse\n\t\t\t\treturn PTR_ERR(version);\n\t\t}\n\n\t\tif (flash)\n\t\t\terr = devlink_info_version_stored_put(req, info->key,\n\t\t\t\t\t\t\t      version);\n\t\telse\n\t\t\terr = devlink_info_version_running_put(req, info->key,\n\t\t\t\t\t\t\t       version);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nnfp_devlink_info_get(struct devlink *devlink, struct devlink_info_req *req,\n\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct nfp_pf *pf = devlink_priv(devlink);\n\tconst char *sn, *vendor, *part;\n\tstruct nfp_nsp *nsp;\n\tchar *buf = NULL;\n\tint err;\n\n\tvendor = nfp_hwinfo_lookup(pf->hwinfo, \"assembly.vendor\");\n\tpart = nfp_hwinfo_lookup(pf->hwinfo, \"assembly.partno\");\n\tsn = nfp_hwinfo_lookup(pf->hwinfo, \"assembly.serial\");\n\tif (vendor && part && sn) {\n\t\tchar *buf;\n\n\t\tbuf = kmalloc(strlen(vendor) + strlen(part) + strlen(sn) + 1,\n\t\t\t      GFP_KERNEL);\n\t\tif (!buf)\n\t\t\treturn -ENOMEM;\n\n\t\tbuf[0] = '\\0';\n\t\tstrcat(buf, vendor);\n\t\tstrcat(buf, part);\n\t\tstrcat(buf, sn);\n\n\t\terr = devlink_info_serial_number_put(req, buf);\n\t\tkfree(buf);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tnsp = nfp_nsp_open(pf->cpp);\n\tif (IS_ERR(nsp)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"can't access NSP\");\n\t\treturn PTR_ERR(nsp);\n\t}\n\n\tif (nfp_nsp_has_versions(nsp)) {\n\t\tbuf = kzalloc(NFP_NSP_VERSION_BUFSZ, GFP_KERNEL);\n\t\tif (!buf) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_close_nsp;\n\t\t}\n\n\t\terr = nfp_nsp_versions(nsp, buf, NFP_NSP_VERSION_BUFSZ);\n\t\tif (err)\n\t\t\tgoto err_free_buf;\n\n\t\terr = nfp_devlink_versions_get_nsp(req, false,\n\t\t\t\t\t\t   buf, NFP_NSP_VERSION_BUFSZ);\n\t\tif (err)\n\t\t\tgoto err_free_buf;\n\n\t\terr = nfp_devlink_versions_get_nsp(req, true,\n\t\t\t\t\t\t   buf, NFP_NSP_VERSION_BUFSZ);\n\t\tif (err)\n\t\t\tgoto err_free_buf;\n\n\t\tkfree(buf);\n\t}\n\n\tnfp_nsp_close(nsp);\n\n\treturn nfp_devlink_versions_get_hwinfo(pf, req);\n\nerr_free_buf:\n\tkfree(buf);\nerr_close_nsp:\n\tnfp_nsp_close(nsp);\n\treturn err;\n}\n\nstatic int\nnfp_devlink_flash_update(struct devlink *devlink,\n\t\t\t struct devlink_flash_update_params *params,\n\t\t\t struct netlink_ext_ack *extack)\n{\n\treturn nfp_flash_update_common(devlink_priv(devlink), params->fw, extack);\n}\n\nconst struct devlink_ops nfp_devlink_ops = {\n\t.sb_pool_get\t\t= nfp_devlink_sb_pool_get,\n\t.sb_pool_set\t\t= nfp_devlink_sb_pool_set,\n\t.eswitch_mode_get\t= nfp_devlink_eswitch_mode_get,\n\t.eswitch_mode_set\t= nfp_devlink_eswitch_mode_set,\n\t.info_get\t\t= nfp_devlink_info_get,\n\t.flash_update\t\t= nfp_devlink_flash_update,\n};\n\nstatic const struct devlink_port_ops nfp_devlink_port_ops = {\n\t.port_split\t\t= nfp_devlink_port_split,\n\t.port_unsplit\t\t= nfp_devlink_port_unsplit,\n};\n\nint nfp_devlink_port_register(struct nfp_app *app, struct nfp_port *port)\n{\n\tstruct devlink_port_attrs attrs = {};\n\tstruct nfp_eth_table_port eth_port;\n\tstruct devlink *devlink;\n\tconst u8 *serial;\n\tint serial_len;\n\tint ret;\n\n\tSET_NETDEV_DEVLINK_PORT(port->netdev, &port->dl_port);\n\n\trtnl_lock();\n\tret = nfp_devlink_fill_eth_port(port, &eth_port);\n\trtnl_unlock();\n\tif (ret)\n\t\treturn ret;\n\n\tattrs.split = eth_port.is_split;\n\tattrs.splittable = eth_port.port_lanes > 1 && !attrs.split;\n\tattrs.lanes = eth_port.port_lanes;\n\tattrs.flavour = DEVLINK_PORT_FLAVOUR_PHYSICAL;\n\tattrs.phys.port_number = eth_port.label_port;\n\tattrs.phys.split_subport_number = eth_port.label_subport;\n\tserial_len = nfp_cpp_serial(port->app->cpp, &serial);\n\tmemcpy(attrs.switch_id.id, serial, serial_len);\n\tattrs.switch_id.id_len = serial_len;\n\tdevlink_port_attrs_set(&port->dl_port, &attrs);\n\n\tdevlink = priv_to_devlink(app->pf);\n\n\treturn devl_port_register_with_ops(devlink, &port->dl_port,\n\t\t\t\t\t   port->eth_id, &nfp_devlink_port_ops);\n}\n\nvoid nfp_devlink_port_unregister(struct nfp_port *port)\n{\n\tdevl_port_unregister(&port->dl_port);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}