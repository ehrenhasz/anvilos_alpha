{
  "module_name": "nfp_net_main.c",
  "hash_id": "16c3ddb384eabf680726a3e749977d7602a170cccb034e4382f640e6f510d6b7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/netronome/nfp/nfp_net_main.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/etherdevice.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/lockdep.h>\n#include <linux/pci.h>\n#include <linux/pci_regs.h>\n#include <linux/random.h>\n#include <linux/rtnetlink.h>\n\n#include \"nfpcore/nfp.h\"\n#include \"nfpcore/nfp_cpp.h\"\n#include \"nfpcore/nfp_dev.h\"\n#include \"nfpcore/nfp_nffw.h\"\n#include \"nfpcore/nfp_nsp.h\"\n#include \"nfpcore/nfp6000_pcie.h\"\n#include \"nfp_app.h\"\n#include \"nfp_net_ctrl.h\"\n#include \"nfp_net_sriov.h\"\n#include \"nfp_net.h\"\n#include \"nfp_main.h\"\n#include \"nfp_port.h\"\n\n#define NFP_PF_CSR_SLICE_SIZE\t(32 * 1024)\n\n \nvoid\nnfp_net_get_mac_addr(struct nfp_pf *pf, struct net_device *netdev,\n\t\t     struct nfp_port *port)\n{\n\tstruct nfp_eth_table_port *eth_port;\n\n\teth_port = __nfp_port_get_eth_port(port);\n\tif (!eth_port) {\n\t\teth_hw_addr_random(netdev);\n\t\treturn;\n\t}\n\n\teth_hw_addr_set(netdev, eth_port->mac_addr);\n\tether_addr_copy(netdev->perm_addr, eth_port->mac_addr);\n}\n\nstatic struct nfp_eth_table_port *\nnfp_net_find_port(struct nfp_eth_table *eth_tbl, unsigned int index)\n{\n\tint i;\n\n\tfor (i = 0; eth_tbl && i < eth_tbl->count; i++)\n\t\tif (eth_tbl->ports[i].index == index)\n\t\t\treturn &eth_tbl->ports[i];\n\n\treturn NULL;\n}\n\nstatic int nfp_net_pf_get_num_ports(struct nfp_pf *pf)\n{\n\treturn nfp_pf_rtsym_read_optional(pf, \"nfd_cfg_pf%u_num_ports\", 1);\n}\n\nstatic void nfp_net_pf_free_vnic(struct nfp_pf *pf, struct nfp_net *nn)\n{\n\tif (nfp_net_is_data_vnic(nn))\n\t\tnfp_app_vnic_free(pf->app, nn);\n\tnfp_port_free(nn->port);\n\tlist_del(&nn->vnic_list);\n\tpf->num_vnics--;\n\tnfp_net_free(nn);\n}\n\nstatic void nfp_net_pf_free_vnics(struct nfp_pf *pf)\n{\n\tstruct nfp_net *nn, *next;\n\n\tlist_for_each_entry_safe(nn, next, &pf->vnics, vnic_list)\n\t\tif (nfp_net_is_data_vnic(nn))\n\t\t\tnfp_net_pf_free_vnic(pf, nn);\n}\n\nstatic struct nfp_net *\nnfp_net_pf_alloc_vnic(struct nfp_pf *pf, bool needs_netdev,\n\t\t      void __iomem *ctrl_bar, void __iomem *qc_bar,\n\t\t      int stride, unsigned int id)\n{\n\tu32 tx_base, rx_base, n_tx_rings, n_rx_rings;\n\tstruct nfp_net *nn;\n\tint err;\n\n\ttx_base = readl(ctrl_bar + NFP_NET_CFG_START_TXQ);\n\trx_base = readl(ctrl_bar + NFP_NET_CFG_START_RXQ);\n\tn_tx_rings = readl(ctrl_bar + NFP_NET_CFG_MAX_TXRINGS);\n\tn_rx_rings = readl(ctrl_bar + NFP_NET_CFG_MAX_RXRINGS);\n\n\t \n\tnn = nfp_net_alloc(pf->pdev, pf->dev_info, ctrl_bar, needs_netdev,\n\t\t\t   n_tx_rings, n_rx_rings);\n\tif (IS_ERR(nn))\n\t\treturn nn;\n\n\tnn->app = pf->app;\n\tnn->tx_bar = qc_bar + tx_base * NFP_QCP_QUEUE_ADDR_SZ;\n\tnn->rx_bar = qc_bar + rx_base * NFP_QCP_QUEUE_ADDR_SZ;\n\tnn->dp.is_vf = 0;\n\tnn->stride_rx = stride;\n\tnn->stride_tx = stride;\n\n\tif (needs_netdev) {\n\t\terr = nfp_app_vnic_alloc(pf->app, nn, id);\n\t\tif (err) {\n\t\t\tnfp_net_free(nn);\n\t\t\treturn ERR_PTR(err);\n\t\t}\n\t}\n\n\tpf->num_vnics++;\n\tlist_add_tail(&nn->vnic_list, &pf->vnics);\n\n\treturn nn;\n}\n\nstatic int\nnfp_net_pf_init_vnic(struct nfp_pf *pf, struct nfp_net *nn, unsigned int id)\n{\n\tint err;\n\n\tnn->id = id;\n\n\tif (nn->port) {\n\t\terr = nfp_devlink_port_register(pf->app, nn->port);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\terr = nfp_net_init(nn);\n\tif (err)\n\t\tgoto err_devlink_port_clean;\n\n\tnfp_net_debugfs_vnic_add(nn, pf->ddir);\n\n\tnfp_net_info(nn);\n\n\tif (nfp_net_is_data_vnic(nn)) {\n\t\terr = nfp_app_vnic_init(pf->app, nn);\n\t\tif (err)\n\t\t\tgoto err_debugfs_vnic_clean;\n\t}\n\n\treturn 0;\n\nerr_debugfs_vnic_clean:\n\tnfp_net_debugfs_dir_clean(&nn->debugfs_dir);\n\tnfp_net_clean(nn);\nerr_devlink_port_clean:\n\tif (nn->port)\n\t\tnfp_devlink_port_unregister(nn->port);\n\treturn err;\n}\n\nstatic int\nnfp_net_pf_alloc_vnics(struct nfp_pf *pf, void __iomem *ctrl_bar,\n\t\t       void __iomem *qc_bar, int stride)\n{\n\tstruct nfp_net *nn;\n\tunsigned int i;\n\tint err;\n\n\tfor (i = 0; i < pf->max_data_vnics; i++) {\n\t\tnn = nfp_net_pf_alloc_vnic(pf, true, ctrl_bar, qc_bar,\n\t\t\t\t\t   stride, i);\n\t\tif (IS_ERR(nn)) {\n\t\t\terr = PTR_ERR(nn);\n\t\t\tgoto err_free_prev;\n\t\t}\n\n\t\tif (nn->port)\n\t\t\tnn->port->link_cb = nfp_net_refresh_port_table;\n\n\t\tctrl_bar += NFP_PF_CSR_SLICE_SIZE;\n\n\t\t \n\t\tif (nn->port && nn->port->type == NFP_PORT_INVALID)\n\t\t\tnfp_net_pf_free_vnic(pf, nn);\n\t}\n\n\tif (list_empty(&pf->vnics))\n\t\treturn -ENODEV;\n\n\treturn 0;\n\nerr_free_prev:\n\tnfp_net_pf_free_vnics(pf);\n\treturn err;\n}\n\nstatic void nfp_net_pf_clean_vnic(struct nfp_pf *pf, struct nfp_net *nn)\n{\n\tif (nfp_net_is_data_vnic(nn))\n\t\tnfp_app_vnic_clean(pf->app, nn);\n\tnfp_net_debugfs_dir_clean(&nn->debugfs_dir);\n\tnfp_net_clean(nn);\n\tif (nn->port)\n\t\tnfp_devlink_port_unregister(nn->port);\n}\n\nstatic int nfp_net_pf_alloc_irqs(struct nfp_pf *pf)\n{\n\tunsigned int wanted_irqs, num_irqs, vnics_left, irqs_left;\n\tstruct nfp_net *nn;\n\n\t \n\twanted_irqs = 0;\n\tlist_for_each_entry(nn, &pf->vnics, vnic_list)\n\t\twanted_irqs += NFP_NET_NON_Q_VECTORS + nn->dp.num_r_vecs;\n\tpf->irq_entries = kcalloc(wanted_irqs, sizeof(*pf->irq_entries),\n\t\t\t\t  GFP_KERNEL);\n\tif (!pf->irq_entries)\n\t\treturn -ENOMEM;\n\n\tnum_irqs = nfp_net_irqs_alloc(pf->pdev, pf->irq_entries,\n\t\t\t\t      NFP_NET_MIN_VNIC_IRQS * pf->num_vnics,\n\t\t\t\t      wanted_irqs);\n\tif (!num_irqs) {\n\t\tnfp_warn(pf->cpp, \"Unable to allocate MSI-X vectors\\n\");\n\t\tkfree(pf->irq_entries);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tirqs_left = num_irqs;\n\tvnics_left = pf->num_vnics;\n\tlist_for_each_entry(nn, &pf->vnics, vnic_list) {\n\t\tunsigned int n;\n\n\t\tn = min(NFP_NET_NON_Q_VECTORS + nn->dp.num_r_vecs,\n\t\t\tDIV_ROUND_UP(irqs_left, vnics_left));\n\t\tnfp_net_irqs_assign(nn, &pf->irq_entries[num_irqs - irqs_left],\n\t\t\t\t    n);\n\t\tirqs_left -= n;\n\t\tvnics_left--;\n\t}\n\n\treturn 0;\n}\n\nstatic void nfp_net_pf_free_irqs(struct nfp_pf *pf)\n{\n\tnfp_net_irqs_disable(pf->pdev);\n\tkfree(pf->irq_entries);\n}\n\nstatic int nfp_net_pf_init_vnics(struct nfp_pf *pf)\n{\n\tstruct nfp_net *nn;\n\tunsigned int id;\n\tint err;\n\n\t \n\tid = 0;\n\tlist_for_each_entry(nn, &pf->vnics, vnic_list) {\n\t\tif (!nfp_net_is_data_vnic(nn))\n\t\t\tcontinue;\n\t\terr = nfp_net_pf_init_vnic(pf, nn, id);\n\t\tif (err)\n\t\t\tgoto err_prev_deinit;\n\n\t\tid++;\n\t}\n\n\treturn 0;\n\nerr_prev_deinit:\n\tlist_for_each_entry_continue_reverse(nn, &pf->vnics, vnic_list)\n\t\tif (nfp_net_is_data_vnic(nn))\n\t\t\tnfp_net_pf_clean_vnic(pf, nn);\n\treturn err;\n}\n\nstatic int\nnfp_net_pf_app_init(struct nfp_pf *pf, u8 __iomem *qc_bar, unsigned int stride)\n{\n\tstruct devlink *devlink = priv_to_devlink(pf);\n\tu8 __iomem *ctrl_bar;\n\tint err;\n\n\tpf->app = nfp_app_alloc(pf, nfp_net_pf_get_app_id(pf));\n\tif (IS_ERR(pf->app))\n\t\treturn PTR_ERR(pf->app);\n\n\tdevl_lock(devlink);\n\terr = nfp_app_init(pf->app);\n\tdevl_unlock(devlink);\n\tif (err)\n\t\tgoto err_free;\n\n\tif (!nfp_app_needs_ctrl_vnic(pf->app))\n\t\treturn 0;\n\n\tctrl_bar = nfp_pf_map_rtsym(pf, \"net.ctrl\", \"_pf%u_net_ctrl_bar\",\n\t\t\t\t    NFP_PF_CSR_SLICE_SIZE, &pf->ctrl_vnic_bar);\n\tif (IS_ERR(ctrl_bar)) {\n\t\tnfp_err(pf->cpp, \"Failed to find ctrl vNIC memory symbol\\n\");\n\t\terr = PTR_ERR(ctrl_bar);\n\t\tgoto err_app_clean;\n\t}\n\n\tpf->ctrl_vnic =\tnfp_net_pf_alloc_vnic(pf, false, ctrl_bar, qc_bar,\n\t\t\t\t\t      stride, 0);\n\tif (IS_ERR(pf->ctrl_vnic)) {\n\t\terr = PTR_ERR(pf->ctrl_vnic);\n\t\tgoto err_unmap;\n\t}\n\n\treturn 0;\n\nerr_unmap:\n\tnfp_cpp_area_release_free(pf->ctrl_vnic_bar);\nerr_app_clean:\n\tdevl_lock(devlink);\n\tnfp_app_clean(pf->app);\n\tdevl_unlock(devlink);\nerr_free:\n\tnfp_app_free(pf->app);\n\tpf->app = NULL;\n\treturn err;\n}\n\nstatic void nfp_net_pf_app_clean(struct nfp_pf *pf)\n{\n\tstruct devlink *devlink = priv_to_devlink(pf);\n\n\tif (pf->ctrl_vnic) {\n\t\tnfp_net_pf_free_vnic(pf, pf->ctrl_vnic);\n\t\tnfp_cpp_area_release_free(pf->ctrl_vnic_bar);\n\t}\n\n\tdevl_lock(devlink);\n\tnfp_app_clean(pf->app);\n\tdevl_unlock(devlink);\n\n\tnfp_app_free(pf->app);\n\tpf->app = NULL;\n}\n\nstatic int nfp_net_pf_app_start_ctrl(struct nfp_pf *pf)\n{\n\tint err;\n\n\tif (!pf->ctrl_vnic)\n\t\treturn 0;\n\terr = nfp_net_pf_init_vnic(pf, pf->ctrl_vnic, 0);\n\tif (err)\n\t\treturn err;\n\n\terr = nfp_ctrl_open(pf->ctrl_vnic);\n\tif (err)\n\t\tgoto err_clean_ctrl;\n\n\treturn 0;\n\nerr_clean_ctrl:\n\tnfp_net_pf_clean_vnic(pf, pf->ctrl_vnic);\n\treturn err;\n}\n\nstatic void nfp_net_pf_app_stop_ctrl(struct nfp_pf *pf)\n{\n\tif (!pf->ctrl_vnic)\n\t\treturn;\n\tnfp_ctrl_close(pf->ctrl_vnic);\n\tnfp_net_pf_clean_vnic(pf, pf->ctrl_vnic);\n}\n\nstatic int nfp_net_pf_app_start(struct nfp_pf *pf)\n{\n\tint err;\n\n\terr = nfp_net_pf_app_start_ctrl(pf);\n\tif (err)\n\t\treturn err;\n\n\terr = nfp_app_start(pf->app, pf->ctrl_vnic);\n\tif (err)\n\t\tgoto err_ctrl_stop;\n\n\tif (pf->num_vfs) {\n\t\terr = nfp_app_sriov_enable(pf->app, pf->num_vfs);\n\t\tif (err)\n\t\t\tgoto err_app_stop;\n\t}\n\n\treturn 0;\n\nerr_app_stop:\n\tnfp_app_stop(pf->app);\nerr_ctrl_stop:\n\tnfp_net_pf_app_stop_ctrl(pf);\n\treturn err;\n}\n\nstatic void nfp_net_pf_app_stop(struct nfp_pf *pf)\n{\n\tif (pf->num_vfs)\n\t\tnfp_app_sriov_disable(pf->app);\n\tnfp_app_stop(pf->app);\n\tnfp_net_pf_app_stop_ctrl(pf);\n}\n\nstatic void nfp_net_pci_unmap_mem(struct nfp_pf *pf)\n{\n\tif (pf->vfcfg_tbl2_area)\n\t\tnfp_cpp_area_release_free(pf->vfcfg_tbl2_area);\n\tif (pf->vf_cfg_bar)\n\t\tnfp_cpp_area_release_free(pf->vf_cfg_bar);\n\tif (pf->mac_stats_bar)\n\t\tnfp_cpp_area_release_free(pf->mac_stats_bar);\n\tnfp_cpp_area_release_free(pf->qc_area);\n\tnfp_cpp_area_release_free(pf->data_vnic_bar);\n}\n\nstatic int nfp_net_pci_map_mem(struct nfp_pf *pf)\n{\n\tu32 min_size, cpp_id;\n\tu8 __iomem *mem;\n\tint err;\n\n\tmin_size = pf->max_data_vnics * NFP_PF_CSR_SLICE_SIZE;\n\tmem = nfp_pf_map_rtsym(pf, \"net.bar0\", \"_pf%d_net_bar0\",\n\t\t\t       min_size, &pf->data_vnic_bar);\n\tif (IS_ERR(mem)) {\n\t\tnfp_err(pf->cpp, \"Failed to find data vNIC memory symbol\\n\");\n\t\treturn PTR_ERR(mem);\n\t}\n\n\tif (pf->eth_tbl) {\n\t\tmin_size =  NFP_MAC_STATS_SIZE * (pf->eth_tbl->max_index + 1);\n\t\tpf->mac_stats_mem = nfp_rtsym_map(pf->rtbl, \"_mac_stats\",\n\t\t\t\t\t\t  \"net.macstats\", min_size,\n\t\t\t\t\t\t  &pf->mac_stats_bar);\n\t\tif (IS_ERR(pf->mac_stats_mem)) {\n\t\t\tif (PTR_ERR(pf->mac_stats_mem) != -ENOENT) {\n\t\t\t\terr = PTR_ERR(pf->mac_stats_mem);\n\t\t\t\tgoto err_unmap_ctrl;\n\t\t\t}\n\t\t\tpf->mac_stats_mem = NULL;\n\t\t}\n\t}\n\n\tpf->vf_cfg_mem = nfp_pf_map_rtsym(pf, \"net.vfcfg\", \"_pf%d_net_vf_bar\",\n\t\t\t\t\t  NFP_NET_CFG_BAR_SZ * pf->limit_vfs,\n\t\t\t\t\t  &pf->vf_cfg_bar);\n\tif (IS_ERR(pf->vf_cfg_mem)) {\n\t\tif (PTR_ERR(pf->vf_cfg_mem) != -ENOENT) {\n\t\t\terr = PTR_ERR(pf->vf_cfg_mem);\n\t\t\tgoto err_unmap_mac_stats;\n\t\t}\n\t\tpf->vf_cfg_mem = NULL;\n\t}\n\n\tmin_size = NFP_NET_VF_CFG_SZ * pf->limit_vfs + NFP_NET_VF_CFG_MB_SZ;\n\tpf->vfcfg_tbl2 = nfp_pf_map_rtsym(pf, \"net.vfcfg_tbl2\",\n\t\t\t\t\t  \"_pf%d_net_vf_cfg2\",\n\t\t\t\t\t  min_size, &pf->vfcfg_tbl2_area);\n\tif (IS_ERR(pf->vfcfg_tbl2)) {\n\t\tif (PTR_ERR(pf->vfcfg_tbl2) != -ENOENT) {\n\t\t\terr = PTR_ERR(pf->vfcfg_tbl2);\n\t\t\tgoto err_unmap_vf_cfg;\n\t\t}\n\t\tpf->vfcfg_tbl2 = NULL;\n\t}\n\n\tcpp_id = NFP_CPP_ISLAND_ID(0, NFP_CPP_ACTION_RW, 0, 0);\n\tmem = nfp_cpp_map_area(pf->cpp, \"net.qc\", cpp_id,\n\t\t\t       nfp_qcp_queue_offset(pf->dev_info, 0),\n\t\t\t       pf->dev_info->qc_area_sz, &pf->qc_area);\n\tif (IS_ERR(mem)) {\n\t\tnfp_err(pf->cpp, \"Failed to map Queue Controller area.\\n\");\n\t\terr = PTR_ERR(mem);\n\t\tgoto err_unmap_vfcfg_tbl2;\n\t}\n\n\treturn 0;\n\nerr_unmap_vfcfg_tbl2:\n\tif (pf->vfcfg_tbl2_area)\n\t\tnfp_cpp_area_release_free(pf->vfcfg_tbl2_area);\nerr_unmap_vf_cfg:\n\tif (pf->vf_cfg_bar)\n\t\tnfp_cpp_area_release_free(pf->vf_cfg_bar);\nerr_unmap_mac_stats:\n\tif (pf->mac_stats_bar)\n\t\tnfp_cpp_area_release_free(pf->mac_stats_bar);\nerr_unmap_ctrl:\n\tnfp_cpp_area_release_free(pf->data_vnic_bar);\n\treturn err;\n}\n\nstatic const unsigned int lr_to_speed[] = {\n\t[NFP_NET_CFG_STS_LINK_RATE_UNSUPPORTED]\t= 0,\n\t[NFP_NET_CFG_STS_LINK_RATE_UNKNOWN]\t= SPEED_UNKNOWN,\n\t[NFP_NET_CFG_STS_LINK_RATE_1G]\t\t= SPEED_1000,\n\t[NFP_NET_CFG_STS_LINK_RATE_10G]\t\t= SPEED_10000,\n\t[NFP_NET_CFG_STS_LINK_RATE_25G]\t\t= SPEED_25000,\n\t[NFP_NET_CFG_STS_LINK_RATE_40G]\t\t= SPEED_40000,\n\t[NFP_NET_CFG_STS_LINK_RATE_50G]\t\t= SPEED_50000,\n\t[NFP_NET_CFG_STS_LINK_RATE_100G]\t= SPEED_100000,\n};\n\nunsigned int nfp_net_lr2speed(unsigned int linkrate)\n{\n\tif (linkrate < ARRAY_SIZE(lr_to_speed))\n\t\treturn lr_to_speed[linkrate];\n\n\treturn SPEED_UNKNOWN;\n}\n\nunsigned int nfp_net_speed2lr(unsigned int speed)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(lr_to_speed); i++) {\n\t\tif (speed == lr_to_speed[i])\n\t\t\treturn i;\n\t}\n\n\treturn NFP_NET_CFG_STS_LINK_RATE_UNKNOWN;\n}\n\nstatic void nfp_net_notify_port_speed(struct nfp_port *port)\n{\n\tstruct net_device *netdev = port->netdev;\n\tstruct nfp_net *nn;\n\tu16 sts;\n\n\tif (!nfp_netdev_is_nfp_net(netdev))\n\t\treturn;\n\n\tnn = netdev_priv(netdev);\n\tsts = nn_readw(nn, NFP_NET_CFG_STS);\n\n\tif (!(sts & NFP_NET_CFG_STS_LINK)) {\n\t\tnn_writew(nn, NFP_NET_CFG_STS_NSP_LINK_RATE, NFP_NET_CFG_STS_LINK_RATE_UNKNOWN);\n\t\treturn;\n\t}\n\n\tnn_writew(nn, NFP_NET_CFG_STS_NSP_LINK_RATE, nfp_net_speed2lr(port->eth_port->speed));\n}\n\nstatic int\nnfp_net_eth_port_update(struct nfp_cpp *cpp, struct nfp_port *port,\n\t\t\tstruct nfp_eth_table *eth_table)\n{\n\tstruct nfp_eth_table_port *eth_port;\n\n\tASSERT_RTNL();\n\n\teth_port = nfp_net_find_port(eth_table, port->eth_id);\n\tif (!eth_port) {\n\t\tset_bit(NFP_PORT_CHANGED, &port->flags);\n\t\tnfp_warn(cpp, \"Warning: port #%d not present after reconfig\\n\",\n\t\t\t port->eth_id);\n\t\treturn -EIO;\n\t}\n\tif (eth_port->override_changed) {\n\t\tnfp_warn(cpp, \"Port #%d config changed, unregistering. Driver reload required before port will be operational again.\\n\", port->eth_id);\n\t\tport->type = NFP_PORT_INVALID;\n\t}\n\n\tmemcpy(port->eth_port, eth_port, sizeof(*eth_port));\n\tnfp_net_notify_port_speed(port);\n\n\treturn 0;\n}\n\nint nfp_net_refresh_port_table_sync(struct nfp_pf *pf)\n{\n\tstruct devlink *devlink = priv_to_devlink(pf);\n\tstruct nfp_eth_table *eth_table;\n\tstruct nfp_net *nn, *next;\n\tstruct nfp_port *port;\n\tint err;\n\n\tdevl_assert_locked(devlink);\n\n\t \n\tif (list_empty(&pf->vnics))\n\t\treturn 0;\n\n\t \n\trtnl_lock();\n\tlist_for_each_entry(port, &pf->ports, port_list)\n\t\tclear_bit(NFP_PORT_CHANGED, &port->flags);\n\n\teth_table = nfp_eth_read_ports(pf->cpp);\n\tif (!eth_table) {\n\t\tlist_for_each_entry(port, &pf->ports, port_list)\n\t\t\tif (__nfp_port_get_eth_port(port))\n\t\t\t\tset_bit(NFP_PORT_CHANGED, &port->flags);\n\t\trtnl_unlock();\n\t\tnfp_err(pf->cpp, \"Error refreshing port config!\\n\");\n\t\treturn -EIO;\n\t}\n\n\tlist_for_each_entry(port, &pf->ports, port_list)\n\t\tif (__nfp_port_get_eth_port(port))\n\t\t\tnfp_net_eth_port_update(pf->cpp, port, eth_table);\n\trtnl_unlock();\n\n\tkfree(eth_table);\n\n\t \n\terr = nfp_reprs_resync_phys_ports(pf->app);\n\tif (err)\n\t\treturn err;\n\n\t \n\tlist_for_each_entry_safe(nn, next, &pf->vnics, vnic_list) {\n\t\tif (!nn->port || nn->port->type != NFP_PORT_INVALID)\n\t\t\tcontinue;\n\n\t\tnfp_net_pf_clean_vnic(pf, nn);\n\t\tnfp_net_pf_free_vnic(pf, nn);\n\t}\n\n\treturn 0;\n}\n\nstatic void nfp_net_refresh_vnics(struct work_struct *work)\n{\n\tstruct nfp_pf *pf = container_of(work, struct nfp_pf,\n\t\t\t\t\t port_refresh_work);\n\tstruct devlink *devlink = priv_to_devlink(pf);\n\n\tdevl_lock(devlink);\n\tnfp_net_refresh_port_table_sync(pf);\n\tdevl_unlock(devlink);\n}\n\nvoid nfp_net_refresh_port_table(struct nfp_port *port)\n{\n\tstruct nfp_pf *pf = port->app->pf;\n\n\tset_bit(NFP_PORT_CHANGED, &port->flags);\n\n\tqueue_work(pf->wq, &pf->port_refresh_work);\n}\n\nint nfp_net_refresh_eth_port(struct nfp_port *port)\n{\n\tstruct nfp_cpp *cpp = port->app->cpp;\n\tstruct nfp_eth_table *eth_table;\n\tint ret;\n\n\tclear_bit(NFP_PORT_CHANGED, &port->flags);\n\n\teth_table = nfp_eth_read_ports(cpp);\n\tif (!eth_table) {\n\t\tset_bit(NFP_PORT_CHANGED, &port->flags);\n\t\tnfp_err(cpp, \"Error refreshing port state table!\\n\");\n\t\treturn -EIO;\n\t}\n\n\tret = nfp_net_eth_port_update(cpp, port, eth_table);\n\n\tkfree(eth_table);\n\n\treturn ret;\n}\n\n \nint nfp_net_pci_probe(struct nfp_pf *pf)\n{\n\tstruct devlink *devlink = priv_to_devlink(pf);\n\tstruct nfp_net_fw_version fw_ver;\n\tu8 __iomem *ctrl_bar, *qc_bar;\n\tint stride;\n\tint err;\n\n\tINIT_WORK(&pf->port_refresh_work, nfp_net_refresh_vnics);\n\n\tif (!pf->rtbl) {\n\t\tnfp_err(pf->cpp, \"No %s, giving up.\\n\",\n\t\t\tpf->fw_loaded ? \"symbol table\" : \"firmware found\");\n\t\treturn -EINVAL;\n\t}\n\n\tpf->max_data_vnics = nfp_net_pf_get_num_ports(pf);\n\tif ((int)pf->max_data_vnics < 0)\n\t\treturn pf->max_data_vnics;\n\n\terr = nfp_net_pci_map_mem(pf);\n\tif (err)\n\t\treturn err;\n\n\tctrl_bar = nfp_cpp_area_iomem(pf->data_vnic_bar);\n\tqc_bar = nfp_cpp_area_iomem(pf->qc_area);\n\tif (!ctrl_bar || !qc_bar) {\n\t\terr = -EIO;\n\t\tgoto err_unmap;\n\t}\n\n\tnfp_net_get_fw_version(&fw_ver, ctrl_bar);\n\tif (fw_ver.extend & NFP_NET_CFG_VERSION_RESERVED_MASK ||\n\t    fw_ver.class != NFP_NET_CFG_VERSION_CLASS_GENERIC) {\n\t\tnfp_err(pf->cpp, \"Unknown Firmware ABI %d.%d.%d.%d\\n\",\n\t\t\tfw_ver.extend, fw_ver.class,\n\t\t\tfw_ver.major, fw_ver.minor);\n\t\terr = -EINVAL;\n\t\tgoto err_unmap;\n\t}\n\n\t \n\tif (nfp_net_fw_ver_eq(&fw_ver, 0, 0, 0, 1)) {\n\t\tstride = 2;\n\t\tnfp_warn(pf->cpp, \"OBSOLETE Firmware detected - VF isolation not available\\n\");\n\t} else {\n\t\tswitch (fw_ver.major) {\n\t\tcase 1 ... 5:\n\t\t\tstride = 4;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tnfp_err(pf->cpp, \"Unsupported Firmware ABI %d.%d.%d.%d\\n\",\n\t\t\t\tfw_ver.extend, fw_ver.class,\n\t\t\t\tfw_ver.major, fw_ver.minor);\n\t\t\terr = -EINVAL;\n\t\t\tgoto err_unmap;\n\t\t}\n\t}\n\n\terr = nfp_net_pf_app_init(pf, qc_bar, stride);\n\tif (err)\n\t\tgoto err_unmap;\n\n\terr = nfp_shared_buf_register(pf);\n\tif (err)\n\t\tgoto err_devlink_unreg;\n\n\tdevl_lock(devlink);\n\terr = nfp_devlink_params_register(pf);\n\tif (err)\n\t\tgoto err_shared_buf_unreg;\n\n\tpf->ddir = nfp_net_debugfs_device_add(pf->pdev);\n\n\t \n\terr = nfp_net_pf_alloc_vnics(pf, ctrl_bar, qc_bar, stride);\n\tif (err)\n\t\tgoto err_clean_ddir;\n\n\terr = nfp_net_pf_alloc_irqs(pf);\n\tif (err)\n\t\tgoto err_free_vnics;\n\n\terr = nfp_net_pf_app_start(pf);\n\tif (err)\n\t\tgoto err_free_irqs;\n\n\terr = nfp_net_pf_init_vnics(pf);\n\tif (err)\n\t\tgoto err_stop_app;\n\n\tdevl_unlock(devlink);\n\tdevlink_register(devlink);\n\n\treturn 0;\n\nerr_stop_app:\n\tnfp_net_pf_app_stop(pf);\nerr_free_irqs:\n\tnfp_net_pf_free_irqs(pf);\nerr_free_vnics:\n\tnfp_net_pf_free_vnics(pf);\nerr_clean_ddir:\n\tnfp_net_debugfs_dir_clean(&pf->ddir);\n\tnfp_devlink_params_unregister(pf);\nerr_shared_buf_unreg:\n\tdevl_unlock(devlink);\n\tnfp_shared_buf_unregister(pf);\nerr_devlink_unreg:\n\tcancel_work_sync(&pf->port_refresh_work);\n\tnfp_net_pf_app_clean(pf);\nerr_unmap:\n\tnfp_net_pci_unmap_mem(pf);\n\treturn err;\n}\n\nvoid nfp_net_pci_remove(struct nfp_pf *pf)\n{\n\tstruct devlink *devlink = priv_to_devlink(pf);\n\tstruct nfp_net *nn, *next;\n\n\tdevlink_unregister(priv_to_devlink(pf));\n\tdevl_lock(devlink);\n\tlist_for_each_entry_safe(nn, next, &pf->vnics, vnic_list) {\n\t\tif (!nfp_net_is_data_vnic(nn))\n\t\t\tcontinue;\n\t\tnfp_net_pf_clean_vnic(pf, nn);\n\t\tnfp_net_pf_free_vnic(pf, nn);\n\t}\n\n\tnfp_net_pf_app_stop(pf);\n\t \n\tnfp_net_debugfs_dir_clean(&pf->ddir);\n\n\tnfp_devlink_params_unregister(pf);\n\n\tdevl_unlock(devlink);\n\n\tnfp_shared_buf_unregister(pf);\n\n\tnfp_net_pf_free_irqs(pf);\n\tnfp_net_pf_app_clean(pf);\n\tnfp_net_pci_unmap_mem(pf);\n\n\tcancel_work_sync(&pf->port_refresh_work);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}