{
  "module_name": "ccm.h",
  "hash_id": "c66c544f0b1c756381670a57719ec9e36b587e807e9a720a4f0861690ef9c588",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/netronome/nfp/ccm.h",
  "human_readable_source": " \n \n\n#ifndef NFP_CCM_H\n#define NFP_CCM_H 1\n\n#include <linux/bitmap.h>\n#include <linux/skbuff.h>\n#include <linux/wait.h>\n\nstruct nfp_app;\nstruct nfp_net;\n\n \n\nenum nfp_ccm_type {\n\tNFP_CCM_TYPE_BPF_MAP_ALLOC\t= 1,\n\tNFP_CCM_TYPE_BPF_MAP_FREE\t= 2,\n\tNFP_CCM_TYPE_BPF_MAP_LOOKUP\t= 3,\n\tNFP_CCM_TYPE_BPF_MAP_UPDATE\t= 4,\n\tNFP_CCM_TYPE_BPF_MAP_DELETE\t= 5,\n\tNFP_CCM_TYPE_BPF_MAP_GETNEXT\t= 6,\n\tNFP_CCM_TYPE_BPF_MAP_GETFIRST\t= 7,\n\tNFP_CCM_TYPE_BPF_BPF_EVENT\t= 8,\n\tNFP_CCM_TYPE_CRYPTO_RESET\t= 9,\n\tNFP_CCM_TYPE_CRYPTO_ADD\t\t= 10,\n\tNFP_CCM_TYPE_CRYPTO_DEL\t\t= 11,\n\tNFP_CCM_TYPE_CRYPTO_UPDATE\t= 12,\n\tNFP_CCM_TYPE_CRYPTO_RESYNC\t= 13,\n\t__NFP_CCM_TYPE_MAX,\n};\n\n#define NFP_CCM_ABI_VERSION\t\t1\n\n#define NFP_CCM_TYPE_REPLY_BIT\t\t7\n#define __NFP_CCM_REPLY(req)\t\t(BIT(NFP_CCM_TYPE_REPLY_BIT) | (req))\n\nstruct nfp_ccm_hdr {\n\tunion {\n\t\tstruct {\n\t\t\tu8 type;\n\t\t\tu8 ver;\n\t\t\t__be16 tag;\n\t\t};\n\t\t__be32 raw;\n\t};\n};\n\nstatic inline u8 nfp_ccm_get_type(struct sk_buff *skb)\n{\n\tstruct nfp_ccm_hdr *hdr;\n\n\thdr = (struct nfp_ccm_hdr *)skb->data;\n\n\treturn hdr->type;\n}\n\nstatic inline __be16 __nfp_ccm_get_tag(struct sk_buff *skb)\n{\n\tstruct nfp_ccm_hdr *hdr;\n\n\thdr = (struct nfp_ccm_hdr *)skb->data;\n\n\treturn hdr->tag;\n}\n\nstatic inline unsigned int nfp_ccm_get_tag(struct sk_buff *skb)\n{\n\treturn be16_to_cpu(__nfp_ccm_get_tag(skb));\n}\n\n#define NFP_NET_MBOX_TLV_TYPE\t\tGENMASK(31, 16)\n#define NFP_NET_MBOX_TLV_LEN\t\tGENMASK(15, 0)\n\nenum nfp_ccm_mbox_tlv_type {\n\tNFP_NET_MBOX_TLV_TYPE_UNKNOWN\t= 0,\n\tNFP_NET_MBOX_TLV_TYPE_END\t= 1,\n\tNFP_NET_MBOX_TLV_TYPE_MSG\t= 2,\n\tNFP_NET_MBOX_TLV_TYPE_MSG_NOSUP\t= 3,\n\tNFP_NET_MBOX_TLV_TYPE_RESV\t= 4,\n};\n\n \n\n \nstruct nfp_ccm {\n\tstruct nfp_app *app;\n\n\tDECLARE_BITMAP(tag_allocator, U16_MAX + 1);\n\tu16 tag_alloc_next;\n\tu16 tag_alloc_last;\n\n\tstruct sk_buff_head replies;\n\twait_queue_head_t wq;\n};\n\nint nfp_ccm_init(struct nfp_ccm *ccm, struct nfp_app *app);\nvoid nfp_ccm_clean(struct nfp_ccm *ccm);\nvoid nfp_ccm_rx(struct nfp_ccm *ccm, struct sk_buff *skb);\nstruct sk_buff *\nnfp_ccm_communicate(struct nfp_ccm *ccm, struct sk_buff *skb,\n\t\t    enum nfp_ccm_type type, unsigned int reply_size);\n\nint nfp_ccm_mbox_alloc(struct nfp_net *nn);\nvoid nfp_ccm_mbox_free(struct nfp_net *nn);\nint nfp_ccm_mbox_init(struct nfp_net *nn);\nvoid nfp_ccm_mbox_clean(struct nfp_net *nn);\nbool nfp_ccm_mbox_fits(struct nfp_net *nn, unsigned int size);\nstruct sk_buff *\nnfp_ccm_mbox_msg_alloc(struct nfp_net *nn, unsigned int req_size,\n\t\t       unsigned int reply_size, gfp_t flags);\nint __nfp_ccm_mbox_communicate(struct nfp_net *nn, struct sk_buff *skb,\n\t\t\t       enum nfp_ccm_type type,\n\t\t\t       unsigned int reply_size,\n\t\t\t       unsigned int max_reply_size, bool critical);\nint nfp_ccm_mbox_communicate(struct nfp_net *nn, struct sk_buff *skb,\n\t\t\t     enum nfp_ccm_type type,\n\t\t\t     unsigned int reply_size,\n\t\t\t     unsigned int max_reply_size);\nint nfp_ccm_mbox_post(struct nfp_net *nn, struct sk_buff *skb,\n\t\t      enum nfp_ccm_type type, unsigned int max_reply_size);\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}