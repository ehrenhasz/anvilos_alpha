{
  "module_name": "nfp_asm.c",
  "hash_id": "a0bdbd43c47dfbfcbc53521f37aded03f201bfcbf17e3d1dcfe5696e82912323",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/netronome/nfp/nfp_asm.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n\n#include \"nfp_asm.h\"\n\nconst struct cmd_tgt_act cmd_tgt_act[__CMD_TGT_MAP_SIZE] = {\n\t[CMD_TGT_WRITE8_SWAP] =\t\t{ 0x02, 0x42 },\n\t[CMD_TGT_WRITE32_SWAP] =\t{ 0x02, 0x5f },\n\t[CMD_TGT_READ8] =\t\t{ 0x01, 0x43 },\n\t[CMD_TGT_READ32] =\t\t{ 0x00, 0x5c },\n\t[CMD_TGT_READ32_LE] =\t\t{ 0x01, 0x5c },\n\t[CMD_TGT_READ32_SWAP] =\t\t{ 0x02, 0x5c },\n\t[CMD_TGT_READ_LE] =\t\t{ 0x01, 0x40 },\n\t[CMD_TGT_READ_SWAP_LE] =\t{ 0x03, 0x40 },\n\t[CMD_TGT_ADD] =\t\t\t{ 0x00, 0x47 },\n\t[CMD_TGT_ADD_IMM] =\t\t{ 0x02, 0x47 },\n};\n\nstatic bool unreg_is_imm(u16 reg)\n{\n\treturn (reg & UR_REG_IMM) == UR_REG_IMM;\n}\n\nu16 br_get_offset(u64 instr)\n{\n\tu16 addr_lo, addr_hi;\n\n\taddr_lo = FIELD_GET(OP_BR_ADDR_LO, instr);\n\taddr_hi = FIELD_GET(OP_BR_ADDR_HI, instr);\n\n\treturn (addr_hi * ((OP_BR_ADDR_LO >> __bf_shf(OP_BR_ADDR_LO)) + 1)) |\n\t\taddr_lo;\n}\n\nvoid br_set_offset(u64 *instr, u16 offset)\n{\n\tu16 addr_lo, addr_hi;\n\n\taddr_lo = offset & (OP_BR_ADDR_LO >> __bf_shf(OP_BR_ADDR_LO));\n\taddr_hi = offset != addr_lo;\n\t*instr &= ~(OP_BR_ADDR_HI | OP_BR_ADDR_LO);\n\t*instr |= FIELD_PREP(OP_BR_ADDR_HI, addr_hi);\n\t*instr |= FIELD_PREP(OP_BR_ADDR_LO, addr_lo);\n}\n\nvoid br_add_offset(u64 *instr, u16 offset)\n{\n\tu16 addr;\n\n\taddr = br_get_offset(*instr);\n\tbr_set_offset(instr, addr + offset);\n}\n\nstatic bool immed_can_modify(u64 instr)\n{\n\tif (FIELD_GET(OP_IMMED_INV, instr) ||\n\t    FIELD_GET(OP_IMMED_SHIFT, instr) ||\n\t    FIELD_GET(OP_IMMED_WIDTH, instr) != IMMED_WIDTH_ALL) {\n\t\tpr_err(\"Can't decode/encode immed!\\n\");\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nu16 immed_get_value(u64 instr)\n{\n\tu16 reg;\n\n\tif (!immed_can_modify(instr))\n\t\treturn 0;\n\n\treg = FIELD_GET(OP_IMMED_A_SRC, instr);\n\tif (!unreg_is_imm(reg))\n\t\treg = FIELD_GET(OP_IMMED_B_SRC, instr);\n\n\treturn (reg & 0xff) | FIELD_GET(OP_IMMED_IMM, instr) << 8;\n}\n\nvoid immed_set_value(u64 *instr, u16 immed)\n{\n\tif (!immed_can_modify(*instr))\n\t\treturn;\n\n\tif (unreg_is_imm(FIELD_GET(OP_IMMED_A_SRC, *instr))) {\n\t\t*instr &= ~FIELD_PREP(OP_IMMED_A_SRC, 0xff);\n\t\t*instr |= FIELD_PREP(OP_IMMED_A_SRC, immed & 0xff);\n\t} else {\n\t\t*instr &= ~FIELD_PREP(OP_IMMED_B_SRC, 0xff);\n\t\t*instr |= FIELD_PREP(OP_IMMED_B_SRC, immed & 0xff);\n\t}\n\n\t*instr &= ~OP_IMMED_IMM;\n\t*instr |= FIELD_PREP(OP_IMMED_IMM, immed >> 8);\n}\n\nvoid immed_add_value(u64 *instr, u16 offset)\n{\n\tu16 val;\n\n\tif (!immed_can_modify(*instr))\n\t\treturn;\n\n\tval = immed_get_value(*instr);\n\timmed_set_value(instr, val + offset);\n}\n\nstatic u16 nfp_swreg_to_unreg(swreg reg, bool is_dst)\n{\n\tbool lm_id, lm_dec = false;\n\tu16 val = swreg_value(reg);\n\n\tswitch (swreg_type(reg)) {\n\tcase NN_REG_GPR_A:\n\tcase NN_REG_GPR_B:\n\tcase NN_REG_GPR_BOTH:\n\t\treturn val;\n\tcase NN_REG_NNR:\n\t\treturn UR_REG_NN | val;\n\tcase NN_REG_XFER:\n\t\treturn UR_REG_XFR | val;\n\tcase NN_REG_LMEM:\n\t\tlm_id = swreg_lm_idx(reg);\n\n\t\tswitch (swreg_lm_mode(reg)) {\n\t\tcase NN_LM_MOD_NONE:\n\t\t\tif (val & ~UR_REG_LM_IDX_MAX) {\n\t\t\t\tpr_err(\"LM offset too large\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\treturn UR_REG_LM | FIELD_PREP(UR_REG_LM_IDX, lm_id) |\n\t\t\t\tval;\n\t\tcase NN_LM_MOD_DEC:\n\t\t\tlm_dec = true;\n\t\t\tfallthrough;\n\t\tcase NN_LM_MOD_INC:\n\t\t\tif (val) {\n\t\t\t\tpr_err(\"LM offset in inc/dev mode\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\treturn UR_REG_LM | UR_REG_LM_POST_MOD |\n\t\t\t\tFIELD_PREP(UR_REG_LM_IDX, lm_id) |\n\t\t\t\tFIELD_PREP(UR_REG_LM_POST_MOD_DEC, lm_dec);\n\t\tdefault:\n\t\t\tpr_err(\"bad LM mode for unrestricted operands %d\\n\",\n\t\t\t       swreg_lm_mode(reg));\n\t\t\treturn 0;\n\t\t}\n\tcase NN_REG_IMM:\n\t\tif (val & ~0xff) {\n\t\t\tpr_err(\"immediate too large\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\treturn UR_REG_IMM_encode(val);\n\tcase NN_REG_NONE:\n\t\treturn is_dst ? UR_REG_NO_DST : REG_NONE;\n\t}\n\n\tpr_err(\"unrecognized reg encoding %08x\\n\", reg);\n\treturn 0;\n}\n\nint swreg_to_unrestricted(swreg dst, swreg lreg, swreg rreg,\n\t\t\t  struct nfp_insn_ur_regs *reg)\n{\n\tmemset(reg, 0, sizeof(*reg));\n\n\t \n\tif (swreg_type(dst) == NN_REG_IMM)\n\t\treturn -EFAULT;\n\n\tif (swreg_type(dst) == NN_REG_GPR_B)\n\t\treg->dst_ab = ALU_DST_B;\n\tif (swreg_type(dst) == NN_REG_GPR_BOTH)\n\t\treg->wr_both = true;\n\treg->dst = nfp_swreg_to_unreg(dst, true);\n\n\t \n\tif (swreg_type(lreg) == swreg_type(rreg) &&\n\t    swreg_type(lreg) != NN_REG_NONE)\n\t\treturn -EFAULT;\n\n\tif (swreg_type(lreg) == NN_REG_GPR_B ||\n\t    swreg_type(rreg) == NN_REG_GPR_A) {\n\t\treg->areg = nfp_swreg_to_unreg(rreg, false);\n\t\treg->breg = nfp_swreg_to_unreg(lreg, false);\n\t\treg->swap = true;\n\t} else {\n\t\treg->areg = nfp_swreg_to_unreg(lreg, false);\n\t\treg->breg = nfp_swreg_to_unreg(rreg, false);\n\t}\n\n\treg->dst_lmextn = swreg_lmextn(dst);\n\treg->src_lmextn = swreg_lmextn(lreg) || swreg_lmextn(rreg);\n\n\treturn 0;\n}\n\nstatic u16 nfp_swreg_to_rereg(swreg reg, bool is_dst, bool has_imm8, bool *i8)\n{\n\tu16 val = swreg_value(reg);\n\tbool lm_id;\n\n\tswitch (swreg_type(reg)) {\n\tcase NN_REG_GPR_A:\n\tcase NN_REG_GPR_B:\n\tcase NN_REG_GPR_BOTH:\n\t\treturn val;\n\tcase NN_REG_XFER:\n\t\treturn RE_REG_XFR | val;\n\tcase NN_REG_LMEM:\n\t\tlm_id = swreg_lm_idx(reg);\n\n\t\tif (swreg_lm_mode(reg) != NN_LM_MOD_NONE) {\n\t\t\tpr_err(\"bad LM mode for restricted operands %d\\n\",\n\t\t\t       swreg_lm_mode(reg));\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (val & ~RE_REG_LM_IDX_MAX) {\n\t\t\tpr_err(\"LM offset too large\\n\");\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn RE_REG_LM | FIELD_PREP(RE_REG_LM_IDX, lm_id) | val;\n\tcase NN_REG_IMM:\n\t\tif (val & ~(0x7f | has_imm8 << 7)) {\n\t\t\tpr_err(\"immediate too large\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\t*i8 = val & 0x80;\n\t\treturn RE_REG_IMM_encode(val & 0x7f);\n\tcase NN_REG_NONE:\n\t\treturn is_dst ? RE_REG_NO_DST : REG_NONE;\n\tcase NN_REG_NNR:\n\t\tpr_err(\"NNRs used with restricted encoding\\n\");\n\t\treturn 0;\n\t}\n\n\tpr_err(\"unrecognized reg encoding\\n\");\n\treturn 0;\n}\n\nint swreg_to_restricted(swreg dst, swreg lreg, swreg rreg,\n\t\t\tstruct nfp_insn_re_regs *reg, bool has_imm8)\n{\n\tmemset(reg, 0, sizeof(*reg));\n\n\t \n\tif (swreg_type(dst) == NN_REG_IMM)\n\t\treturn -EFAULT;\n\n\tif (swreg_type(dst) == NN_REG_GPR_B)\n\t\treg->dst_ab = ALU_DST_B;\n\tif (swreg_type(dst) == NN_REG_GPR_BOTH)\n\t\treg->wr_both = true;\n\treg->dst = nfp_swreg_to_rereg(dst, true, false, NULL);\n\n\t \n\tif (swreg_type(lreg) == swreg_type(rreg) &&\n\t    swreg_type(lreg) != NN_REG_NONE)\n\t\treturn -EFAULT;\n\n\tif (swreg_type(lreg) == NN_REG_GPR_B ||\n\t    swreg_type(rreg) == NN_REG_GPR_A) {\n\t\treg->areg = nfp_swreg_to_rereg(rreg, false, has_imm8, &reg->i8);\n\t\treg->breg = nfp_swreg_to_rereg(lreg, false, has_imm8, &reg->i8);\n\t\treg->swap = true;\n\t} else {\n\t\treg->areg = nfp_swreg_to_rereg(lreg, false, has_imm8, &reg->i8);\n\t\treg->breg = nfp_swreg_to_rereg(rreg, false, has_imm8, &reg->i8);\n\t}\n\n\treg->dst_lmextn = swreg_lmextn(dst);\n\treg->src_lmextn = swreg_lmextn(lreg) || swreg_lmextn(rreg);\n\n\treturn 0;\n}\n\n#define NFP_USTORE_ECC_POLY_WORDS\t\t7\n#define NFP_USTORE_OP_BITS\t\t\t45\n\nstatic const u64 nfp_ustore_ecc_polynomials[NFP_USTORE_ECC_POLY_WORDS] = {\n\t0x0ff800007fffULL,\n\t0x11f801ff801fULL,\n\t0x1e387e0781e1ULL,\n\t0x17cb8e388e22ULL,\n\t0x1af5b2c93244ULL,\n\t0x1f56d5525488ULL,\n\t0x0daf69a46910ULL,\n};\n\nstatic bool parity(u64 value)\n{\n\treturn hweight64(value) & 1;\n}\n\nint nfp_ustore_check_valid_no_ecc(u64 insn)\n{\n\tif (insn & ~GENMASK_ULL(NFP_USTORE_OP_BITS, 0))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nu64 nfp_ustore_calc_ecc_insn(u64 insn)\n{\n\tu8 ecc = 0;\n\tint i;\n\n\tfor (i = 0; i < NFP_USTORE_ECC_POLY_WORDS; i++)\n\t\tecc |= parity(nfp_ustore_ecc_polynomials[i] & insn) << i;\n\n\treturn insn | (u64)ecc << NFP_USTORE_OP_BITS;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}