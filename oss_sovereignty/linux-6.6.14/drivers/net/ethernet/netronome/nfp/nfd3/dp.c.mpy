{
  "module_name": "dp.c",
  "hash_id": "b8b3380fbfadf3e0ff6aac9ab6b88755ac814b6a8c01eb7f91e56dda4ac00f06",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/netronome/nfp/nfd3/dp.c",
  "human_readable_source": "\n \n\n#include <linux/bpf_trace.h>\n#include <linux/netdevice.h>\n#include <linux/bitfield.h>\n#include <net/xfrm.h>\n\n#include \"../nfp_app.h\"\n#include \"../nfp_net.h\"\n#include \"../nfp_net_dp.h\"\n#include \"../nfp_net_xsk.h\"\n#include \"../crypto/crypto.h\"\n#include \"../crypto/fw.h\"\n#include \"nfd3.h\"\n\n \n\n \nstatic int nfp_nfd3_tx_ring_should_wake(struct nfp_net_tx_ring *tx_ring)\n{\n\treturn !nfp_net_tx_full(tx_ring, MAX_SKB_FRAGS * 4);\n}\n\nstatic int nfp_nfd3_tx_ring_should_stop(struct nfp_net_tx_ring *tx_ring)\n{\n\treturn nfp_net_tx_full(tx_ring, MAX_SKB_FRAGS + 1);\n}\n\n \nstatic void\nnfp_nfd3_tx_ring_stop(struct netdev_queue *nd_q,\n\t\t      struct nfp_net_tx_ring *tx_ring)\n{\n\tnetif_tx_stop_queue(nd_q);\n\n\t \n\tsmp_mb();\n\tif (unlikely(nfp_nfd3_tx_ring_should_wake(tx_ring)))\n\t\tnetif_tx_start_queue(nd_q);\n}\n\n \nstatic void\nnfp_nfd3_tx_tso(struct nfp_net_r_vector *r_vec, struct nfp_nfd3_tx_buf *txbuf,\n\t\tstruct nfp_nfd3_tx_desc *txd, struct sk_buff *skb, u32 md_bytes)\n{\n\tu32 l3_offset, l4_offset, hdrlen;\n\tu16 mss;\n\n\tif (!skb_is_gso(skb))\n\t\treturn;\n\n\tif (!skb->encapsulation) {\n\t\tl3_offset = skb_network_offset(skb);\n\t\tl4_offset = skb_transport_offset(skb);\n\t\thdrlen = skb_tcp_all_headers(skb);\n\t} else {\n\t\tl3_offset = skb_inner_network_offset(skb);\n\t\tl4_offset = skb_inner_transport_offset(skb);\n\t\thdrlen = skb_inner_tcp_all_headers(skb);\n\t}\n\n\ttxbuf->pkt_cnt = skb_shinfo(skb)->gso_segs;\n\ttxbuf->real_len += hdrlen * (txbuf->pkt_cnt - 1);\n\n\tmss = skb_shinfo(skb)->gso_size & NFD3_DESC_TX_MSS_MASK;\n\ttxd->l3_offset = l3_offset - md_bytes;\n\ttxd->l4_offset = l4_offset - md_bytes;\n\ttxd->lso_hdrlen = hdrlen - md_bytes;\n\ttxd->mss = cpu_to_le16(mss);\n\ttxd->flags |= NFD3_DESC_TX_LSO;\n\n\tu64_stats_update_begin(&r_vec->tx_sync);\n\tr_vec->tx_lso++;\n\tu64_stats_update_end(&r_vec->tx_sync);\n}\n\n \nstatic void\nnfp_nfd3_tx_csum(struct nfp_net_dp *dp, struct nfp_net_r_vector *r_vec,\n\t\t struct nfp_nfd3_tx_buf *txbuf, struct nfp_nfd3_tx_desc *txd,\n\t\t struct sk_buff *skb)\n{\n\tstruct ipv6hdr *ipv6h;\n\tstruct iphdr *iph;\n\tu8 l4_hdr;\n\n\tif (!(dp->ctrl & NFP_NET_CFG_CTRL_TXCSUM))\n\t\treturn;\n\n\tif (skb->ip_summed != CHECKSUM_PARTIAL)\n\t\treturn;\n\n\ttxd->flags |= NFD3_DESC_TX_CSUM;\n\tif (skb->encapsulation)\n\t\ttxd->flags |= NFD3_DESC_TX_ENCAP;\n\n\tiph = skb->encapsulation ? inner_ip_hdr(skb) : ip_hdr(skb);\n\tipv6h = skb->encapsulation ? inner_ipv6_hdr(skb) : ipv6_hdr(skb);\n\n\tif (iph->version == 4) {\n\t\ttxd->flags |= NFD3_DESC_TX_IP4_CSUM;\n\t\tl4_hdr = iph->protocol;\n\t} else if (ipv6h->version == 6) {\n\t\tl4_hdr = ipv6h->nexthdr;\n\t} else {\n\t\tnn_dp_warn(dp, \"partial checksum but ipv=%x!\\n\", iph->version);\n\t\treturn;\n\t}\n\n\tswitch (l4_hdr) {\n\tcase IPPROTO_TCP:\n\t\ttxd->flags |= NFD3_DESC_TX_TCP_CSUM;\n\t\tbreak;\n\tcase IPPROTO_UDP:\n\t\ttxd->flags |= NFD3_DESC_TX_UDP_CSUM;\n\t\tbreak;\n\tdefault:\n\t\tnn_dp_warn(dp, \"partial checksum but l4 proto=%x!\\n\", l4_hdr);\n\t\treturn;\n\t}\n\n\tu64_stats_update_begin(&r_vec->tx_sync);\n\tif (skb->encapsulation)\n\t\tr_vec->hw_csum_tx_inner += txbuf->pkt_cnt;\n\telse\n\t\tr_vec->hw_csum_tx += txbuf->pkt_cnt;\n\tu64_stats_update_end(&r_vec->tx_sync);\n}\n\nstatic int nfp_nfd3_prep_tx_meta(struct nfp_net_dp *dp, struct sk_buff *skb,\n\t\t\t\t u64 tls_handle, bool *ipsec)\n{\n\tstruct metadata_dst *md_dst = skb_metadata_dst(skb);\n\tstruct nfp_ipsec_offload offload_info;\n\tunsigned char *data;\n\tbool vlan_insert;\n\tu32 meta_id = 0;\n\tint md_bytes;\n\n#ifdef CONFIG_NFP_NET_IPSEC\n\tif (xfrm_offload(skb))\n\t\t*ipsec = nfp_net_ipsec_tx_prep(dp, skb, &offload_info);\n#endif\n\n\tif (unlikely(md_dst && md_dst->type != METADATA_HW_PORT_MUX))\n\t\tmd_dst = NULL;\n\n\tvlan_insert = skb_vlan_tag_present(skb) && (dp->ctrl & NFP_NET_CFG_CTRL_TXVLAN_V2);\n\n\tif (!(md_dst || tls_handle || vlan_insert || *ipsec))\n\t\treturn 0;\n\n\tmd_bytes = sizeof(meta_id) +\n\t\t   (!!md_dst ? NFP_NET_META_PORTID_SIZE : 0) +\n\t\t   (!!tls_handle ? NFP_NET_META_CONN_HANDLE_SIZE : 0) +\n\t\t   (vlan_insert ? NFP_NET_META_VLAN_SIZE : 0) +\n\t\t   (*ipsec ? NFP_NET_META_IPSEC_FIELD_SIZE : 0);\n\n\tif (unlikely(skb_cow_head(skb, md_bytes)))\n\t\treturn -ENOMEM;\n\n\tdata = skb_push(skb, md_bytes) + md_bytes;\n\tif (md_dst) {\n\t\tdata -= NFP_NET_META_PORTID_SIZE;\n\t\tput_unaligned_be32(md_dst->u.port_info.port_id, data);\n\t\tmeta_id = NFP_NET_META_PORTID;\n\t}\n\tif (tls_handle) {\n\t\t \n\t\tdata -= NFP_NET_META_CONN_HANDLE_SIZE;\n\t\tmemcpy(data, &tls_handle, sizeof(tls_handle));\n\t\tmeta_id <<= NFP_NET_META_FIELD_SIZE;\n\t\tmeta_id |= NFP_NET_META_CONN_HANDLE;\n\t}\n\tif (vlan_insert) {\n\t\tdata -= NFP_NET_META_VLAN_SIZE;\n\t\t \n\t\tmemcpy(data, &skb->vlan_proto, sizeof(skb->vlan_proto));\n\t\tput_unaligned_be16(skb_vlan_tag_get(skb), data + sizeof(skb->vlan_proto));\n\t\tmeta_id <<= NFP_NET_META_FIELD_SIZE;\n\t\tmeta_id |= NFP_NET_META_VLAN;\n\t}\n\tif (*ipsec) {\n\t\tdata -= NFP_NET_META_IPSEC_SIZE;\n\t\tput_unaligned_be32(offload_info.seq_hi, data);\n\t\tdata -= NFP_NET_META_IPSEC_SIZE;\n\t\tput_unaligned_be32(offload_info.seq_low, data);\n\t\tdata -= NFP_NET_META_IPSEC_SIZE;\n\t\tput_unaligned_be32(offload_info.handle - 1, data);\n\t\tmeta_id <<= NFP_NET_META_IPSEC_FIELD_SIZE;\n\t\tmeta_id |= NFP_NET_META_IPSEC << 8 | NFP_NET_META_IPSEC << 4 | NFP_NET_META_IPSEC;\n\t}\n\n\tdata -= sizeof(meta_id);\n\tput_unaligned_be32(meta_id, data);\n\n\treturn md_bytes;\n}\n\n \nnetdev_tx_t nfp_nfd3_tx(struct sk_buff *skb, struct net_device *netdev)\n{\n\tstruct nfp_net *nn = netdev_priv(netdev);\n\tint f, nr_frags, wr_idx, md_bytes;\n\tstruct nfp_net_tx_ring *tx_ring;\n\tstruct nfp_net_r_vector *r_vec;\n\tstruct nfp_nfd3_tx_buf *txbuf;\n\tstruct nfp_nfd3_tx_desc *txd;\n\tstruct netdev_queue *nd_q;\n\tconst skb_frag_t *frag;\n\tstruct nfp_net_dp *dp;\n\tdma_addr_t dma_addr;\n\tunsigned int fsize;\n\tu64 tls_handle = 0;\n\tbool ipsec = false;\n\tu16 qidx;\n\n\tdp = &nn->dp;\n\tqidx = skb_get_queue_mapping(skb);\n\ttx_ring = &dp->tx_rings[qidx];\n\tr_vec = tx_ring->r_vec;\n\n\tnr_frags = skb_shinfo(skb)->nr_frags;\n\n\tif (unlikely(nfp_net_tx_full(tx_ring, nr_frags + 1))) {\n\t\tnn_dp_warn(dp, \"TX ring %d busy. wrp=%u rdp=%u\\n\",\n\t\t\t   qidx, tx_ring->wr_p, tx_ring->rd_p);\n\t\tnd_q = netdev_get_tx_queue(dp->netdev, qidx);\n\t\tnetif_tx_stop_queue(nd_q);\n\t\tnfp_net_tx_xmit_more_flush(tx_ring);\n\t\tu64_stats_update_begin(&r_vec->tx_sync);\n\t\tr_vec->tx_busy++;\n\t\tu64_stats_update_end(&r_vec->tx_sync);\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\n\tskb = nfp_net_tls_tx(dp, r_vec, skb, &tls_handle, &nr_frags);\n\tif (unlikely(!skb)) {\n\t\tnfp_net_tx_xmit_more_flush(tx_ring);\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\tmd_bytes = nfp_nfd3_prep_tx_meta(dp, skb, tls_handle, &ipsec);\n\tif (unlikely(md_bytes < 0))\n\t\tgoto err_flush;\n\n\t \n\tdma_addr = dma_map_single(dp->dev, skb->data, skb_headlen(skb),\n\t\t\t\t  DMA_TO_DEVICE);\n\tif (dma_mapping_error(dp->dev, dma_addr))\n\t\tgoto err_dma_err;\n\n\twr_idx = D_IDX(tx_ring, tx_ring->wr_p);\n\n\t \n\ttxbuf = &tx_ring->txbufs[wr_idx];\n\ttxbuf->skb = skb;\n\ttxbuf->dma_addr = dma_addr;\n\ttxbuf->fidx = -1;\n\ttxbuf->pkt_cnt = 1;\n\ttxbuf->real_len = skb->len;\n\n\t \n\ttxd = &tx_ring->txds[wr_idx];\n\ttxd->offset_eop = (nr_frags ? 0 : NFD3_DESC_TX_EOP) | md_bytes;\n\ttxd->dma_len = cpu_to_le16(skb_headlen(skb));\n\tnfp_desc_set_dma_addr_40b(txd, dma_addr);\n\ttxd->data_len = cpu_to_le16(skb->len);\n\n\ttxd->flags = 0;\n\ttxd->mss = 0;\n\ttxd->lso_hdrlen = 0;\n\n\t \n\tnfp_nfd3_tx_tso(r_vec, txbuf, txd, skb, md_bytes);\n\tif (ipsec)\n\t\tnfp_nfd3_ipsec_tx(txd, skb);\n\telse\n\t\tnfp_nfd3_tx_csum(dp, r_vec, txbuf, txd, skb);\n\tif (skb_vlan_tag_present(skb) && dp->ctrl & NFP_NET_CFG_CTRL_TXVLAN) {\n\t\ttxd->flags |= NFD3_DESC_TX_VLAN;\n\t\ttxd->vlan = cpu_to_le16(skb_vlan_tag_get(skb));\n\t}\n\n\t \n\tif (nr_frags > 0) {\n\t\t__le64 second_half;\n\n\t\t \n\t\tsecond_half = txd->vals8[1];\n\n\t\tfor (f = 0; f < nr_frags; f++) {\n\t\t\tfrag = &skb_shinfo(skb)->frags[f];\n\t\t\tfsize = skb_frag_size(frag);\n\n\t\t\tdma_addr = skb_frag_dma_map(dp->dev, frag, 0,\n\t\t\t\t\t\t    fsize, DMA_TO_DEVICE);\n\t\t\tif (dma_mapping_error(dp->dev, dma_addr))\n\t\t\t\tgoto err_unmap;\n\n\t\t\twr_idx = D_IDX(tx_ring, wr_idx + 1);\n\t\t\ttx_ring->txbufs[wr_idx].skb = skb;\n\t\t\ttx_ring->txbufs[wr_idx].dma_addr = dma_addr;\n\t\t\ttx_ring->txbufs[wr_idx].fidx = f;\n\n\t\t\ttxd = &tx_ring->txds[wr_idx];\n\t\t\ttxd->dma_len = cpu_to_le16(fsize);\n\t\t\tnfp_desc_set_dma_addr_40b(txd, dma_addr);\n\t\t\ttxd->offset_eop = md_bytes |\n\t\t\t\t((f == nr_frags - 1) ? NFD3_DESC_TX_EOP : 0);\n\t\t\ttxd->vals8[1] = second_half;\n\t\t}\n\n\t\tu64_stats_update_begin(&r_vec->tx_sync);\n\t\tr_vec->tx_gather++;\n\t\tu64_stats_update_end(&r_vec->tx_sync);\n\t}\n\n\tskb_tx_timestamp(skb);\n\n\tnd_q = netdev_get_tx_queue(dp->netdev, tx_ring->idx);\n\n\ttx_ring->wr_p += nr_frags + 1;\n\tif (nfp_nfd3_tx_ring_should_stop(tx_ring))\n\t\tnfp_nfd3_tx_ring_stop(nd_q, tx_ring);\n\n\ttx_ring->wr_ptr_add += nr_frags + 1;\n\tif (__netdev_tx_sent_queue(nd_q, txbuf->real_len, netdev_xmit_more()))\n\t\tnfp_net_tx_xmit_more_flush(tx_ring);\n\n\treturn NETDEV_TX_OK;\n\nerr_unmap:\n\twhile (--f >= 0) {\n\t\tfrag = &skb_shinfo(skb)->frags[f];\n\t\tdma_unmap_page(dp->dev, tx_ring->txbufs[wr_idx].dma_addr,\n\t\t\t       skb_frag_size(frag), DMA_TO_DEVICE);\n\t\ttx_ring->txbufs[wr_idx].skb = NULL;\n\t\ttx_ring->txbufs[wr_idx].dma_addr = 0;\n\t\ttx_ring->txbufs[wr_idx].fidx = -2;\n\t\twr_idx = wr_idx - 1;\n\t\tif (wr_idx < 0)\n\t\t\twr_idx += tx_ring->cnt;\n\t}\n\tdma_unmap_single(dp->dev, tx_ring->txbufs[wr_idx].dma_addr,\n\t\t\t skb_headlen(skb), DMA_TO_DEVICE);\n\ttx_ring->txbufs[wr_idx].skb = NULL;\n\ttx_ring->txbufs[wr_idx].dma_addr = 0;\n\ttx_ring->txbufs[wr_idx].fidx = -2;\nerr_dma_err:\n\tnn_dp_warn(dp, \"Failed to map DMA TX buffer\\n\");\nerr_flush:\n\tnfp_net_tx_xmit_more_flush(tx_ring);\n\tu64_stats_update_begin(&r_vec->tx_sync);\n\tr_vec->tx_errors++;\n\tu64_stats_update_end(&r_vec->tx_sync);\n\tnfp_net_tls_tx_undo(skb, tls_handle);\n\tdev_kfree_skb_any(skb);\n\treturn NETDEV_TX_OK;\n}\n\n \nvoid nfp_nfd3_tx_complete(struct nfp_net_tx_ring *tx_ring, int budget)\n{\n\tstruct nfp_net_r_vector *r_vec = tx_ring->r_vec;\n\tstruct nfp_net_dp *dp = &r_vec->nfp_net->dp;\n\tu32 done_pkts = 0, done_bytes = 0;\n\tstruct netdev_queue *nd_q;\n\tu32 qcp_rd_p;\n\tint todo;\n\n\tif (tx_ring->wr_p == tx_ring->rd_p)\n\t\treturn;\n\n\t \n\tqcp_rd_p = nfp_net_read_tx_cmpl(tx_ring, dp);\n\n\tif (qcp_rd_p == tx_ring->qcp_rd_p)\n\t\treturn;\n\n\ttodo = D_IDX(tx_ring, qcp_rd_p - tx_ring->qcp_rd_p);\n\n\twhile (todo--) {\n\t\tconst skb_frag_t *frag;\n\t\tstruct nfp_nfd3_tx_buf *tx_buf;\n\t\tstruct sk_buff *skb;\n\t\tint fidx, nr_frags;\n\t\tint idx;\n\n\t\tidx = D_IDX(tx_ring, tx_ring->rd_p++);\n\t\ttx_buf = &tx_ring->txbufs[idx];\n\n\t\tskb = tx_buf->skb;\n\t\tif (!skb)\n\t\t\tcontinue;\n\n\t\tnr_frags = skb_shinfo(skb)->nr_frags;\n\t\tfidx = tx_buf->fidx;\n\n\t\tif (fidx == -1) {\n\t\t\t \n\t\t\tdma_unmap_single(dp->dev, tx_buf->dma_addr,\n\t\t\t\t\t skb_headlen(skb), DMA_TO_DEVICE);\n\n\t\t\tdone_pkts += tx_buf->pkt_cnt;\n\t\t\tdone_bytes += tx_buf->real_len;\n\t\t} else {\n\t\t\t \n\t\t\tfrag = &skb_shinfo(skb)->frags[fidx];\n\t\t\tdma_unmap_page(dp->dev, tx_buf->dma_addr,\n\t\t\t\t       skb_frag_size(frag), DMA_TO_DEVICE);\n\t\t}\n\n\t\t \n\t\tif (fidx == nr_frags - 1)\n\t\t\tnapi_consume_skb(skb, budget);\n\n\t\ttx_buf->dma_addr = 0;\n\t\ttx_buf->skb = NULL;\n\t\ttx_buf->fidx = -2;\n\t}\n\n\ttx_ring->qcp_rd_p = qcp_rd_p;\n\n\tu64_stats_update_begin(&r_vec->tx_sync);\n\tr_vec->tx_bytes += done_bytes;\n\tr_vec->tx_pkts += done_pkts;\n\tu64_stats_update_end(&r_vec->tx_sync);\n\n\tif (!dp->netdev)\n\t\treturn;\n\n\tnd_q = netdev_get_tx_queue(dp->netdev, tx_ring->idx);\n\tnetdev_tx_completed_queue(nd_q, done_pkts, done_bytes);\n\tif (nfp_nfd3_tx_ring_should_wake(tx_ring)) {\n\t\t \n\t\tsmp_mb();\n\n\t\tif (unlikely(netif_tx_queue_stopped(nd_q)))\n\t\t\tnetif_tx_wake_queue(nd_q);\n\t}\n\n\tWARN_ONCE(tx_ring->wr_p - tx_ring->rd_p > tx_ring->cnt,\n\t\t  \"TX ring corruption rd_p=%u wr_p=%u cnt=%u\\n\",\n\t\t  tx_ring->rd_p, tx_ring->wr_p, tx_ring->cnt);\n}\n\nstatic bool nfp_nfd3_xdp_complete(struct nfp_net_tx_ring *tx_ring)\n{\n\tstruct nfp_net_r_vector *r_vec = tx_ring->r_vec;\n\tstruct nfp_net_dp *dp = &r_vec->nfp_net->dp;\n\tu32 done_pkts = 0, done_bytes = 0;\n\tbool done_all;\n\tint idx, todo;\n\tu32 qcp_rd_p;\n\n\t \n\tqcp_rd_p = nfp_net_read_tx_cmpl(tx_ring, dp);\n\n\tif (qcp_rd_p == tx_ring->qcp_rd_p)\n\t\treturn true;\n\n\ttodo = D_IDX(tx_ring, qcp_rd_p - tx_ring->qcp_rd_p);\n\n\tdone_all = todo <= NFP_NET_XDP_MAX_COMPLETE;\n\ttodo = min(todo, NFP_NET_XDP_MAX_COMPLETE);\n\n\ttx_ring->qcp_rd_p = D_IDX(tx_ring, tx_ring->qcp_rd_p + todo);\n\n\tdone_pkts = todo;\n\twhile (todo--) {\n\t\tidx = D_IDX(tx_ring, tx_ring->rd_p);\n\t\ttx_ring->rd_p++;\n\n\t\tdone_bytes += tx_ring->txbufs[idx].real_len;\n\t}\n\n\tu64_stats_update_begin(&r_vec->tx_sync);\n\tr_vec->tx_bytes += done_bytes;\n\tr_vec->tx_pkts += done_pkts;\n\tu64_stats_update_end(&r_vec->tx_sync);\n\n\tWARN_ONCE(tx_ring->wr_p - tx_ring->rd_p > tx_ring->cnt,\n\t\t  \"XDP TX ring corruption rd_p=%u wr_p=%u cnt=%u\\n\",\n\t\t  tx_ring->rd_p, tx_ring->wr_p, tx_ring->cnt);\n\n\treturn done_all;\n}\n\n \n\nstatic void *\nnfp_nfd3_napi_alloc_one(struct nfp_net_dp *dp, dma_addr_t *dma_addr)\n{\n\tvoid *frag;\n\n\tif (!dp->xdp_prog) {\n\t\tfrag = napi_alloc_frag(dp->fl_bufsz);\n\t\tif (unlikely(!frag))\n\t\t\treturn NULL;\n\t} else {\n\t\tstruct page *page;\n\n\t\tpage = dev_alloc_page();\n\t\tif (unlikely(!page))\n\t\t\treturn NULL;\n\t\tfrag = page_address(page);\n\t}\n\n\t*dma_addr = nfp_net_dma_map_rx(dp, frag);\n\tif (dma_mapping_error(dp->dev, *dma_addr)) {\n\t\tnfp_net_free_frag(frag, dp->xdp_prog);\n\t\tnn_dp_warn(dp, \"Failed to map DMA RX buffer\\n\");\n\t\treturn NULL;\n\t}\n\n\treturn frag;\n}\n\n \nstatic void\nnfp_nfd3_rx_give_one(const struct nfp_net_dp *dp,\n\t\t     struct nfp_net_rx_ring *rx_ring,\n\t\t     void *frag, dma_addr_t dma_addr)\n{\n\tunsigned int wr_idx;\n\n\twr_idx = D_IDX(rx_ring, rx_ring->wr_p);\n\n\tnfp_net_dma_sync_dev_rx(dp, dma_addr);\n\n\t \n\trx_ring->rxbufs[wr_idx].frag = frag;\n\trx_ring->rxbufs[wr_idx].dma_addr = dma_addr;\n\n\t \n\trx_ring->rxds[wr_idx].fld.reserved = 0;\n\trx_ring->rxds[wr_idx].fld.meta_len_dd = 0;\n\t \n\tnfp_desc_set_dma_addr_48b(&rx_ring->rxds[wr_idx].fld,\n\t\t\t\t  dma_addr + dp->rx_dma_off);\n\n\trx_ring->wr_p++;\n\tif (!(rx_ring->wr_p % NFP_NET_FL_BATCH)) {\n\t\t \n\t\twmb();\n\t\tnfp_qcp_wr_ptr_add(rx_ring->qcp_fl, NFP_NET_FL_BATCH);\n\t}\n}\n\n \nvoid nfp_nfd3_rx_ring_fill_freelist(struct nfp_net_dp *dp,\n\t\t\t\t    struct nfp_net_rx_ring *rx_ring)\n{\n\tunsigned int i;\n\n\tif (nfp_net_has_xsk_pool_slow(dp, rx_ring->idx))\n\t\treturn nfp_net_xsk_rx_ring_fill_freelist(rx_ring);\n\n\tfor (i = 0; i < rx_ring->cnt - 1; i++)\n\t\tnfp_nfd3_rx_give_one(dp, rx_ring, rx_ring->rxbufs[i].frag,\n\t\t\t\t     rx_ring->rxbufs[i].dma_addr);\n}\n\n \nstatic int nfp_nfd3_rx_csum_has_errors(u16 flags)\n{\n\tu16 csum_all_checked, csum_all_ok;\n\n\tcsum_all_checked = flags & __PCIE_DESC_RX_CSUM_ALL;\n\tcsum_all_ok = flags & __PCIE_DESC_RX_CSUM_ALL_OK;\n\n\treturn csum_all_checked != (csum_all_ok << PCIE_DESC_RX_CSUM_OK_SHIFT);\n}\n\n \nvoid\nnfp_nfd3_rx_csum(const struct nfp_net_dp *dp, struct nfp_net_r_vector *r_vec,\n\t\t const struct nfp_net_rx_desc *rxd,\n\t\t const struct nfp_meta_parsed *meta, struct sk_buff *skb)\n{\n\tskb_checksum_none_assert(skb);\n\n\tif (!(dp->netdev->features & NETIF_F_RXCSUM))\n\t\treturn;\n\n\tif (meta->csum_type) {\n\t\tskb->ip_summed = meta->csum_type;\n\t\tskb->csum = meta->csum;\n\t\tu64_stats_update_begin(&r_vec->rx_sync);\n\t\tr_vec->hw_csum_rx_complete++;\n\t\tu64_stats_update_end(&r_vec->rx_sync);\n\t\treturn;\n\t}\n\n\tif (nfp_nfd3_rx_csum_has_errors(le16_to_cpu(rxd->rxd.flags))) {\n\t\tu64_stats_update_begin(&r_vec->rx_sync);\n\t\tr_vec->hw_csum_rx_error++;\n\t\tu64_stats_update_end(&r_vec->rx_sync);\n\t\treturn;\n\t}\n\n\t \n\tif (rxd->rxd.flags & PCIE_DESC_RX_TCP_CSUM_OK ||\n\t    rxd->rxd.flags & PCIE_DESC_RX_UDP_CSUM_OK) {\n\t\t__skb_incr_checksum_unnecessary(skb);\n\t\tu64_stats_update_begin(&r_vec->rx_sync);\n\t\tr_vec->hw_csum_rx_ok++;\n\t\tu64_stats_update_end(&r_vec->rx_sync);\n\t}\n\n\tif (rxd->rxd.flags & PCIE_DESC_RX_I_TCP_CSUM_OK ||\n\t    rxd->rxd.flags & PCIE_DESC_RX_I_UDP_CSUM_OK) {\n\t\t__skb_incr_checksum_unnecessary(skb);\n\t\tu64_stats_update_begin(&r_vec->rx_sync);\n\t\tr_vec->hw_csum_rx_inner_ok++;\n\t\tu64_stats_update_end(&r_vec->rx_sync);\n\t}\n}\n\nstatic void\nnfp_nfd3_set_hash(struct net_device *netdev, struct nfp_meta_parsed *meta,\n\t\t  unsigned int type, __be32 *hash)\n{\n\tif (!(netdev->features & NETIF_F_RXHASH))\n\t\treturn;\n\n\tswitch (type) {\n\tcase NFP_NET_RSS_IPV4:\n\tcase NFP_NET_RSS_IPV6:\n\tcase NFP_NET_RSS_IPV6_EX:\n\t\tmeta->hash_type = PKT_HASH_TYPE_L3;\n\t\tbreak;\n\tdefault:\n\t\tmeta->hash_type = PKT_HASH_TYPE_L4;\n\t\tbreak;\n\t}\n\n\tmeta->hash = get_unaligned_be32(hash);\n}\n\nstatic void\nnfp_nfd3_set_hash_desc(struct net_device *netdev, struct nfp_meta_parsed *meta,\n\t\t       void *data, struct nfp_net_rx_desc *rxd)\n{\n\tstruct nfp_net_rx_hash *rx_hash = data;\n\n\tif (!(rxd->rxd.flags & PCIE_DESC_RX_RSS))\n\t\treturn;\n\n\tnfp_nfd3_set_hash(netdev, meta, get_unaligned_be32(&rx_hash->hash_type),\n\t\t\t  &rx_hash->hash);\n}\n\nbool\nnfp_nfd3_parse_meta(struct net_device *netdev, struct nfp_meta_parsed *meta,\n\t\t    void *data, void *pkt, unsigned int pkt_len, int meta_len)\n{\n\tu32 meta_info, vlan_info;\n\n\tmeta_info = get_unaligned_be32(data);\n\tdata += 4;\n\n\twhile (meta_info) {\n\t\tswitch (meta_info & NFP_NET_META_FIELD_MASK) {\n\t\tcase NFP_NET_META_HASH:\n\t\t\tmeta_info >>= NFP_NET_META_FIELD_SIZE;\n\t\t\tnfp_nfd3_set_hash(netdev, meta,\n\t\t\t\t\t  meta_info & NFP_NET_META_FIELD_MASK,\n\t\t\t\t\t  (__be32 *)data);\n\t\t\tdata += 4;\n\t\t\tbreak;\n\t\tcase NFP_NET_META_MARK:\n\t\t\tmeta->mark = get_unaligned_be32(data);\n\t\t\tdata += 4;\n\t\t\tbreak;\n\t\tcase NFP_NET_META_VLAN:\n\t\t\tvlan_info = get_unaligned_be32(data);\n\t\t\tif (FIELD_GET(NFP_NET_META_VLAN_STRIP, vlan_info)) {\n\t\t\t\tmeta->vlan.stripped = true;\n\t\t\t\tmeta->vlan.tpid = FIELD_GET(NFP_NET_META_VLAN_TPID_MASK,\n\t\t\t\t\t\t\t    vlan_info);\n\t\t\t\tmeta->vlan.tci = FIELD_GET(NFP_NET_META_VLAN_TCI_MASK,\n\t\t\t\t\t\t\t   vlan_info);\n\t\t\t}\n\t\t\tdata += 4;\n\t\t\tbreak;\n\t\tcase NFP_NET_META_PORTID:\n\t\t\tmeta->portid = get_unaligned_be32(data);\n\t\t\tdata += 4;\n\t\t\tbreak;\n\t\tcase NFP_NET_META_CSUM:\n\t\t\tmeta->csum_type = CHECKSUM_COMPLETE;\n\t\t\tmeta->csum =\n\t\t\t\t(__force __wsum)__get_unaligned_cpu32(data);\n\t\t\tdata += 4;\n\t\t\tbreak;\n\t\tcase NFP_NET_META_RESYNC_INFO:\n\t\t\tif (nfp_net_tls_rx_resync_req(netdev, data, pkt,\n\t\t\t\t\t\t      pkt_len))\n\t\t\t\treturn false;\n\t\t\tdata += sizeof(struct nfp_net_tls_resync_req);\n\t\t\tbreak;\n#ifdef CONFIG_NFP_NET_IPSEC\n\t\tcase NFP_NET_META_IPSEC:\n\t\t\t \n\t\t\tmeta->ipsec_saidx = get_unaligned_be32(data) + 1;\n\t\t\tdata += 4;\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\treturn true;\n\t\t}\n\n\t\tmeta_info >>= NFP_NET_META_FIELD_SIZE;\n\t}\n\n\treturn data != pkt;\n}\n\nstatic void\nnfp_nfd3_rx_drop(const struct nfp_net_dp *dp, struct nfp_net_r_vector *r_vec,\n\t\t struct nfp_net_rx_ring *rx_ring, struct nfp_net_rx_buf *rxbuf,\n\t\t struct sk_buff *skb)\n{\n\tu64_stats_update_begin(&r_vec->rx_sync);\n\tr_vec->rx_drops++;\n\t \n\tif (skb && rxbuf)\n\t\tr_vec->rx_replace_buf_alloc_fail++;\n\tu64_stats_update_end(&r_vec->rx_sync);\n\n\t \n\tif (skb && rxbuf && skb->head == rxbuf->frag)\n\t\tpage_ref_inc(virt_to_head_page(rxbuf->frag));\n\tif (rxbuf)\n\t\tnfp_nfd3_rx_give_one(dp, rx_ring, rxbuf->frag, rxbuf->dma_addr);\n\tif (skb)\n\t\tdev_kfree_skb_any(skb);\n}\n\nstatic bool\nnfp_nfd3_tx_xdp_buf(struct nfp_net_dp *dp, struct nfp_net_rx_ring *rx_ring,\n\t\t    struct nfp_net_tx_ring *tx_ring,\n\t\t    struct nfp_net_rx_buf *rxbuf, unsigned int dma_off,\n\t\t    unsigned int pkt_len, bool *completed)\n{\n\tunsigned int dma_map_sz = dp->fl_bufsz - NFP_NET_RX_BUF_NON_DATA;\n\tstruct nfp_nfd3_tx_buf *txbuf;\n\tstruct nfp_nfd3_tx_desc *txd;\n\tint wr_idx;\n\n\t \n\tif (pkt_len + dma_off > dma_map_sz)\n\t\treturn false;\n\n\tif (unlikely(nfp_net_tx_full(tx_ring, 1))) {\n\t\tif (!*completed) {\n\t\t\tnfp_nfd3_xdp_complete(tx_ring);\n\t\t\t*completed = true;\n\t\t}\n\n\t\tif (unlikely(nfp_net_tx_full(tx_ring, 1))) {\n\t\t\tnfp_nfd3_rx_drop(dp, rx_ring->r_vec, rx_ring, rxbuf,\n\t\t\t\t\t NULL);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\twr_idx = D_IDX(tx_ring, tx_ring->wr_p);\n\n\t \n\ttxbuf = &tx_ring->txbufs[wr_idx];\n\n\tnfp_nfd3_rx_give_one(dp, rx_ring, txbuf->frag, txbuf->dma_addr);\n\n\ttxbuf->frag = rxbuf->frag;\n\ttxbuf->dma_addr = rxbuf->dma_addr;\n\ttxbuf->fidx = -1;\n\ttxbuf->pkt_cnt = 1;\n\ttxbuf->real_len = pkt_len;\n\n\tdma_sync_single_for_device(dp->dev, rxbuf->dma_addr + dma_off,\n\t\t\t\t   pkt_len, DMA_BIDIRECTIONAL);\n\n\t \n\ttxd = &tx_ring->txds[wr_idx];\n\ttxd->offset_eop = NFD3_DESC_TX_EOP;\n\ttxd->dma_len = cpu_to_le16(pkt_len);\n\tnfp_desc_set_dma_addr_40b(txd, rxbuf->dma_addr + dma_off);\n\ttxd->data_len = cpu_to_le16(pkt_len);\n\n\ttxd->flags = 0;\n\ttxd->mss = 0;\n\ttxd->lso_hdrlen = 0;\n\n\ttx_ring->wr_p++;\n\ttx_ring->wr_ptr_add++;\n\treturn true;\n}\n\n \nstatic int nfp_nfd3_rx(struct nfp_net_rx_ring *rx_ring, int budget)\n{\n\tstruct nfp_net_r_vector *r_vec = rx_ring->r_vec;\n\tstruct nfp_net_dp *dp = &r_vec->nfp_net->dp;\n\tstruct nfp_net_tx_ring *tx_ring;\n\tstruct bpf_prog *xdp_prog;\n\tint idx, pkts_polled = 0;\n\tbool xdp_tx_cmpl = false;\n\tunsigned int true_bufsz;\n\tstruct sk_buff *skb;\n\tstruct xdp_buff xdp;\n\n\txdp_prog = READ_ONCE(dp->xdp_prog);\n\ttrue_bufsz = xdp_prog ? PAGE_SIZE : dp->fl_bufsz;\n\txdp_init_buff(&xdp, PAGE_SIZE - NFP_NET_RX_BUF_HEADROOM,\n\t\t      &rx_ring->xdp_rxq);\n\ttx_ring = r_vec->xdp_ring;\n\n\twhile (pkts_polled < budget) {\n\t\tunsigned int meta_len, data_len, meta_off, pkt_len, pkt_off;\n\t\tstruct nfp_net_rx_buf *rxbuf;\n\t\tstruct nfp_net_rx_desc *rxd;\n\t\tstruct nfp_meta_parsed meta;\n\t\tbool redir_egress = false;\n\t\tstruct net_device *netdev;\n\t\tdma_addr_t new_dma_addr;\n\t\tu32 meta_len_xdp = 0;\n\t\tvoid *new_frag;\n\n\t\tidx = D_IDX(rx_ring, rx_ring->rd_p);\n\n\t\trxd = &rx_ring->rxds[idx];\n\t\tif (!(rxd->rxd.meta_len_dd & PCIE_DESC_RX_DD))\n\t\t\tbreak;\n\n\t\t \n\t\tdma_rmb();\n\n\t\tmemset(&meta, 0, sizeof(meta));\n\n\t\trx_ring->rd_p++;\n\t\tpkts_polled++;\n\n\t\trxbuf =\t&rx_ring->rxbufs[idx];\n\t\t \n\t\tmeta_len = rxd->rxd.meta_len_dd & PCIE_DESC_RX_META_LEN_MASK;\n\t\tdata_len = le16_to_cpu(rxd->rxd.data_len);\n\t\tpkt_len = data_len - meta_len;\n\n\t\tpkt_off = NFP_NET_RX_BUF_HEADROOM + dp->rx_dma_off;\n\t\tif (dp->rx_offset == NFP_NET_CFG_RX_OFFSET_DYNAMIC)\n\t\t\tpkt_off += meta_len;\n\t\telse\n\t\t\tpkt_off += dp->rx_offset;\n\t\tmeta_off = pkt_off - meta_len;\n\n\t\t \n\t\tu64_stats_update_begin(&r_vec->rx_sync);\n\t\tr_vec->rx_pkts++;\n\t\tr_vec->rx_bytes += pkt_len;\n\t\tu64_stats_update_end(&r_vec->rx_sync);\n\n\t\tif (unlikely(meta_len > NFP_NET_MAX_PREPEND ||\n\t\t\t     (dp->rx_offset && meta_len > dp->rx_offset))) {\n\t\t\tnn_dp_warn(dp, \"oversized RX packet metadata %u\\n\",\n\t\t\t\t   meta_len);\n\t\t\tnfp_nfd3_rx_drop(dp, r_vec, rx_ring, rxbuf, NULL);\n\t\t\tcontinue;\n\t\t}\n\n\t\tnfp_net_dma_sync_cpu_rx(dp, rxbuf->dma_addr + meta_off,\n\t\t\t\t\tdata_len);\n\n\t\tif (!dp->chained_metadata_format) {\n\t\t\tnfp_nfd3_set_hash_desc(dp->netdev, &meta,\n\t\t\t\t\t       rxbuf->frag + meta_off, rxd);\n\t\t} else if (meta_len) {\n\t\t\tif (unlikely(nfp_nfd3_parse_meta(dp->netdev, &meta,\n\t\t\t\t\t\t\t rxbuf->frag + meta_off,\n\t\t\t\t\t\t\t rxbuf->frag + pkt_off,\n\t\t\t\t\t\t\t pkt_len, meta_len))) {\n\t\t\t\tnn_dp_warn(dp, \"invalid RX packet metadata\\n\");\n\t\t\t\tnfp_nfd3_rx_drop(dp, r_vec, rx_ring, rxbuf,\n\t\t\t\t\t\t NULL);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (xdp_prog && !meta.portid) {\n\t\t\tvoid *orig_data = rxbuf->frag + pkt_off;\n\t\t\tunsigned int dma_off;\n\t\t\tint act;\n\n\t\t\txdp_prepare_buff(&xdp,\n\t\t\t\t\t rxbuf->frag + NFP_NET_RX_BUF_HEADROOM,\n\t\t\t\t\t pkt_off - NFP_NET_RX_BUF_HEADROOM,\n\t\t\t\t\t pkt_len, true);\n\n\t\t\tact = bpf_prog_run_xdp(xdp_prog, &xdp);\n\n\t\t\tpkt_len = xdp.data_end - xdp.data;\n\t\t\tpkt_off += xdp.data - orig_data;\n\n\t\t\tswitch (act) {\n\t\t\tcase XDP_PASS:\n\t\t\t\tmeta_len_xdp = xdp.data - xdp.data_meta;\n\t\t\t\tbreak;\n\t\t\tcase XDP_TX:\n\t\t\t\tdma_off = pkt_off - NFP_NET_RX_BUF_HEADROOM;\n\t\t\t\tif (unlikely(!nfp_nfd3_tx_xdp_buf(dp, rx_ring,\n\t\t\t\t\t\t\t\t  tx_ring,\n\t\t\t\t\t\t\t\t  rxbuf,\n\t\t\t\t\t\t\t\t  dma_off,\n\t\t\t\t\t\t\t\t  pkt_len,\n\t\t\t\t\t\t\t\t  &xdp_tx_cmpl)))\n\t\t\t\t\ttrace_xdp_exception(dp->netdev,\n\t\t\t\t\t\t\t    xdp_prog, act);\n\t\t\t\tcontinue;\n\t\t\tdefault:\n\t\t\t\tbpf_warn_invalid_xdp_action(dp->netdev, xdp_prog, act);\n\t\t\t\tfallthrough;\n\t\t\tcase XDP_ABORTED:\n\t\t\t\ttrace_xdp_exception(dp->netdev, xdp_prog, act);\n\t\t\t\tfallthrough;\n\t\t\tcase XDP_DROP:\n\t\t\t\tnfp_nfd3_rx_give_one(dp, rx_ring, rxbuf->frag,\n\t\t\t\t\t\t     rxbuf->dma_addr);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (likely(!meta.portid)) {\n\t\t\tnetdev = dp->netdev;\n\t\t} else if (meta.portid == NFP_META_PORT_ID_CTRL) {\n\t\t\tstruct nfp_net *nn = netdev_priv(dp->netdev);\n\n\t\t\tnfp_app_ctrl_rx_raw(nn->app, rxbuf->frag + pkt_off,\n\t\t\t\t\t    pkt_len);\n\t\t\tnfp_nfd3_rx_give_one(dp, rx_ring, rxbuf->frag,\n\t\t\t\t\t     rxbuf->dma_addr);\n\t\t\tcontinue;\n\t\t} else {\n\t\t\tstruct nfp_net *nn;\n\n\t\t\tnn = netdev_priv(dp->netdev);\n\t\t\tnetdev = nfp_app_dev_get(nn->app, meta.portid,\n\t\t\t\t\t\t &redir_egress);\n\t\t\tif (unlikely(!netdev)) {\n\t\t\t\tnfp_nfd3_rx_drop(dp, r_vec, rx_ring, rxbuf,\n\t\t\t\t\t\t NULL);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (nfp_netdev_is_nfp_repr(netdev))\n\t\t\t\tnfp_repr_inc_rx_stats(netdev, pkt_len);\n\t\t}\n\n\t\tskb = build_skb(rxbuf->frag, true_bufsz);\n\t\tif (unlikely(!skb)) {\n\t\t\tnfp_nfd3_rx_drop(dp, r_vec, rx_ring, rxbuf, NULL);\n\t\t\tcontinue;\n\t\t}\n\t\tnew_frag = nfp_nfd3_napi_alloc_one(dp, &new_dma_addr);\n\t\tif (unlikely(!new_frag)) {\n\t\t\tnfp_nfd3_rx_drop(dp, r_vec, rx_ring, rxbuf, skb);\n\t\t\tcontinue;\n\t\t}\n\n\t\tnfp_net_dma_unmap_rx(dp, rxbuf->dma_addr);\n\n\t\tnfp_nfd3_rx_give_one(dp, rx_ring, new_frag, new_dma_addr);\n\n\t\tskb_reserve(skb, pkt_off);\n\t\tskb_put(skb, pkt_len);\n\n\t\tskb->mark = meta.mark;\n\t\tskb_set_hash(skb, meta.hash, meta.hash_type);\n\n\t\tskb_record_rx_queue(skb, rx_ring->idx);\n\t\tskb->protocol = eth_type_trans(skb, netdev);\n\n\t\tnfp_nfd3_rx_csum(dp, r_vec, rxd, &meta, skb);\n\n#ifdef CONFIG_TLS_DEVICE\n\t\tif (rxd->rxd.flags & PCIE_DESC_RX_DECRYPTED) {\n\t\t\tskb->decrypted = true;\n\t\t\tu64_stats_update_begin(&r_vec->rx_sync);\n\t\t\tr_vec->hw_tls_rx++;\n\t\t\tu64_stats_update_end(&r_vec->rx_sync);\n\t\t}\n#endif\n\n\t\tif (unlikely(!nfp_net_vlan_strip(skb, rxd, &meta))) {\n\t\t\tnfp_nfd3_rx_drop(dp, r_vec, rx_ring, NULL, skb);\n\t\t\tcontinue;\n\t\t}\n\n#ifdef CONFIG_NFP_NET_IPSEC\n\t\tif (meta.ipsec_saidx != 0 && unlikely(nfp_net_ipsec_rx(&meta, skb))) {\n\t\t\tnfp_nfd3_rx_drop(dp, r_vec, rx_ring, NULL, skb);\n\t\t\tcontinue;\n\t\t}\n#endif\n\n\t\tif (meta_len_xdp)\n\t\t\tskb_metadata_set(skb, meta_len_xdp);\n\n\t\tif (likely(!redir_egress)) {\n\t\t\tnapi_gro_receive(&rx_ring->r_vec->napi, skb);\n\t\t} else {\n\t\t\tskb->dev = netdev;\n\t\t\tskb_reset_network_header(skb);\n\t\t\t__skb_push(skb, ETH_HLEN);\n\t\t\tdev_queue_xmit(skb);\n\t\t}\n\t}\n\n\tif (xdp_prog) {\n\t\tif (tx_ring->wr_ptr_add)\n\t\t\tnfp_net_tx_xmit_more_flush(tx_ring);\n\t\telse if (unlikely(tx_ring->wr_p != tx_ring->rd_p) &&\n\t\t\t !xdp_tx_cmpl)\n\t\t\tif (!nfp_nfd3_xdp_complete(tx_ring))\n\t\t\t\tpkts_polled = budget;\n\t}\n\n\treturn pkts_polled;\n}\n\n \nint nfp_nfd3_poll(struct napi_struct *napi, int budget)\n{\n\tstruct nfp_net_r_vector *r_vec =\n\t\tcontainer_of(napi, struct nfp_net_r_vector, napi);\n\tunsigned int pkts_polled = 0;\n\n\tif (r_vec->tx_ring)\n\t\tnfp_nfd3_tx_complete(r_vec->tx_ring, budget);\n\tif (r_vec->rx_ring)\n\t\tpkts_polled = nfp_nfd3_rx(r_vec->rx_ring, budget);\n\n\tif (pkts_polled < budget)\n\t\tif (napi_complete_done(napi, pkts_polled))\n\t\t\tnfp_net_irq_unmask(r_vec->nfp_net, r_vec->irq_entry);\n\n\tif (r_vec->nfp_net->rx_coalesce_adapt_on && r_vec->rx_ring) {\n\t\tstruct dim_sample dim_sample = {};\n\t\tunsigned int start;\n\t\tu64 pkts, bytes;\n\n\t\tdo {\n\t\t\tstart = u64_stats_fetch_begin(&r_vec->rx_sync);\n\t\t\tpkts = r_vec->rx_pkts;\n\t\t\tbytes = r_vec->rx_bytes;\n\t\t} while (u64_stats_fetch_retry(&r_vec->rx_sync, start));\n\n\t\tdim_update_sample(r_vec->event_ctr, pkts, bytes, &dim_sample);\n\t\tnet_dim(&r_vec->rx_dim, dim_sample);\n\t}\n\n\tif (r_vec->nfp_net->tx_coalesce_adapt_on && r_vec->tx_ring) {\n\t\tstruct dim_sample dim_sample = {};\n\t\tunsigned int start;\n\t\tu64 pkts, bytes;\n\n\t\tdo {\n\t\t\tstart = u64_stats_fetch_begin(&r_vec->tx_sync);\n\t\t\tpkts = r_vec->tx_pkts;\n\t\t\tbytes = r_vec->tx_bytes;\n\t\t} while (u64_stats_fetch_retry(&r_vec->tx_sync, start));\n\n\t\tdim_update_sample(r_vec->event_ctr, pkts, bytes, &dim_sample);\n\t\tnet_dim(&r_vec->tx_dim, dim_sample);\n\t}\n\n\treturn pkts_polled;\n}\n\n \n\nbool\nnfp_nfd3_ctrl_tx_one(struct nfp_net *nn, struct nfp_net_r_vector *r_vec,\n\t\t     struct sk_buff *skb, bool old)\n{\n\tunsigned int real_len = skb->len, meta_len = 0;\n\tstruct nfp_net_tx_ring *tx_ring;\n\tstruct nfp_nfd3_tx_buf *txbuf;\n\tstruct nfp_nfd3_tx_desc *txd;\n\tstruct nfp_net_dp *dp;\n\tdma_addr_t dma_addr;\n\tint wr_idx;\n\n\tdp = &r_vec->nfp_net->dp;\n\ttx_ring = r_vec->tx_ring;\n\n\tif (WARN_ON_ONCE(skb_shinfo(skb)->nr_frags)) {\n\t\tnn_dp_warn(dp, \"Driver's CTRL TX does not implement gather\\n\");\n\t\tgoto err_free;\n\t}\n\n\tif (unlikely(nfp_net_tx_full(tx_ring, 1))) {\n\t\tu64_stats_update_begin(&r_vec->tx_sync);\n\t\tr_vec->tx_busy++;\n\t\tu64_stats_update_end(&r_vec->tx_sync);\n\t\tif (!old)\n\t\t\t__skb_queue_tail(&r_vec->queue, skb);\n\t\telse\n\t\t\t__skb_queue_head(&r_vec->queue, skb);\n\t\treturn true;\n\t}\n\n\tif (nfp_app_ctrl_has_meta(nn->app)) {\n\t\tif (unlikely(skb_headroom(skb) < 8)) {\n\t\t\tnn_dp_warn(dp, \"CTRL TX on skb without headroom\\n\");\n\t\t\tgoto err_free;\n\t\t}\n\t\tmeta_len = 8;\n\t\tput_unaligned_be32(NFP_META_PORT_ID_CTRL, skb_push(skb, 4));\n\t\tput_unaligned_be32(NFP_NET_META_PORTID, skb_push(skb, 4));\n\t}\n\n\t \n\tdma_addr = dma_map_single(dp->dev, skb->data, skb_headlen(skb),\n\t\t\t\t  DMA_TO_DEVICE);\n\tif (dma_mapping_error(dp->dev, dma_addr))\n\t\tgoto err_dma_warn;\n\n\twr_idx = D_IDX(tx_ring, tx_ring->wr_p);\n\n\t \n\ttxbuf = &tx_ring->txbufs[wr_idx];\n\ttxbuf->skb = skb;\n\ttxbuf->dma_addr = dma_addr;\n\ttxbuf->fidx = -1;\n\ttxbuf->pkt_cnt = 1;\n\ttxbuf->real_len = real_len;\n\n\t \n\ttxd = &tx_ring->txds[wr_idx];\n\ttxd->offset_eop = meta_len | NFD3_DESC_TX_EOP;\n\ttxd->dma_len = cpu_to_le16(skb_headlen(skb));\n\tnfp_desc_set_dma_addr_40b(txd, dma_addr);\n\ttxd->data_len = cpu_to_le16(skb->len);\n\n\ttxd->flags = 0;\n\ttxd->mss = 0;\n\ttxd->lso_hdrlen = 0;\n\n\ttx_ring->wr_p++;\n\ttx_ring->wr_ptr_add++;\n\tnfp_net_tx_xmit_more_flush(tx_ring);\n\n\treturn false;\n\nerr_dma_warn:\n\tnn_dp_warn(dp, \"Failed to DMA map TX CTRL buffer\\n\");\nerr_free:\n\tu64_stats_update_begin(&r_vec->tx_sync);\n\tr_vec->tx_errors++;\n\tu64_stats_update_end(&r_vec->tx_sync);\n\tdev_kfree_skb_any(skb);\n\treturn false;\n}\n\nstatic void __nfp_ctrl_tx_queued(struct nfp_net_r_vector *r_vec)\n{\n\tstruct sk_buff *skb;\n\n\twhile ((skb = __skb_dequeue(&r_vec->queue)))\n\t\tif (nfp_nfd3_ctrl_tx_one(r_vec->nfp_net, r_vec, skb, true))\n\t\t\treturn;\n}\n\nstatic bool\nnfp_ctrl_meta_ok(struct nfp_net *nn, void *data, unsigned int meta_len)\n{\n\tu32 meta_type, meta_tag;\n\n\tif (!nfp_app_ctrl_has_meta(nn->app))\n\t\treturn !meta_len;\n\n\tif (meta_len != 8)\n\t\treturn false;\n\n\tmeta_type = get_unaligned_be32(data);\n\tmeta_tag = get_unaligned_be32(data + 4);\n\n\treturn (meta_type == NFP_NET_META_PORTID &&\n\t\tmeta_tag == NFP_META_PORT_ID_CTRL);\n}\n\nstatic bool\nnfp_ctrl_rx_one(struct nfp_net *nn, struct nfp_net_dp *dp,\n\t\tstruct nfp_net_r_vector *r_vec, struct nfp_net_rx_ring *rx_ring)\n{\n\tunsigned int meta_len, data_len, meta_off, pkt_len, pkt_off;\n\tstruct nfp_net_rx_buf *rxbuf;\n\tstruct nfp_net_rx_desc *rxd;\n\tdma_addr_t new_dma_addr;\n\tstruct sk_buff *skb;\n\tvoid *new_frag;\n\tint idx;\n\n\tidx = D_IDX(rx_ring, rx_ring->rd_p);\n\n\trxd = &rx_ring->rxds[idx];\n\tif (!(rxd->rxd.meta_len_dd & PCIE_DESC_RX_DD))\n\t\treturn false;\n\n\t \n\tdma_rmb();\n\n\trx_ring->rd_p++;\n\n\trxbuf =\t&rx_ring->rxbufs[idx];\n\tmeta_len = rxd->rxd.meta_len_dd & PCIE_DESC_RX_META_LEN_MASK;\n\tdata_len = le16_to_cpu(rxd->rxd.data_len);\n\tpkt_len = data_len - meta_len;\n\n\tpkt_off = NFP_NET_RX_BUF_HEADROOM + dp->rx_dma_off;\n\tif (dp->rx_offset == NFP_NET_CFG_RX_OFFSET_DYNAMIC)\n\t\tpkt_off += meta_len;\n\telse\n\t\tpkt_off += dp->rx_offset;\n\tmeta_off = pkt_off - meta_len;\n\n\t \n\tu64_stats_update_begin(&r_vec->rx_sync);\n\tr_vec->rx_pkts++;\n\tr_vec->rx_bytes += pkt_len;\n\tu64_stats_update_end(&r_vec->rx_sync);\n\n\tnfp_net_dma_sync_cpu_rx(dp, rxbuf->dma_addr + meta_off,\tdata_len);\n\n\tif (unlikely(!nfp_ctrl_meta_ok(nn, rxbuf->frag + meta_off, meta_len))) {\n\t\tnn_dp_warn(dp, \"incorrect metadata for ctrl packet (%d)\\n\",\n\t\t\t   meta_len);\n\t\tnfp_nfd3_rx_drop(dp, r_vec, rx_ring, rxbuf, NULL);\n\t\treturn true;\n\t}\n\n\tskb = build_skb(rxbuf->frag, dp->fl_bufsz);\n\tif (unlikely(!skb)) {\n\t\tnfp_nfd3_rx_drop(dp, r_vec, rx_ring, rxbuf, NULL);\n\t\treturn true;\n\t}\n\tnew_frag = nfp_nfd3_napi_alloc_one(dp, &new_dma_addr);\n\tif (unlikely(!new_frag)) {\n\t\tnfp_nfd3_rx_drop(dp, r_vec, rx_ring, rxbuf, skb);\n\t\treturn true;\n\t}\n\n\tnfp_net_dma_unmap_rx(dp, rxbuf->dma_addr);\n\n\tnfp_nfd3_rx_give_one(dp, rx_ring, new_frag, new_dma_addr);\n\n\tskb_reserve(skb, pkt_off);\n\tskb_put(skb, pkt_len);\n\n\tnfp_app_ctrl_rx(nn->app, skb);\n\n\treturn true;\n}\n\nstatic bool nfp_ctrl_rx(struct nfp_net_r_vector *r_vec)\n{\n\tstruct nfp_net_rx_ring *rx_ring = r_vec->rx_ring;\n\tstruct nfp_net *nn = r_vec->nfp_net;\n\tstruct nfp_net_dp *dp = &nn->dp;\n\tunsigned int budget = 512;\n\n\twhile (nfp_ctrl_rx_one(nn, dp, r_vec, rx_ring) && budget--)\n\t\tcontinue;\n\n\treturn budget;\n}\n\nvoid nfp_nfd3_ctrl_poll(struct tasklet_struct *t)\n{\n\tstruct nfp_net_r_vector *r_vec = from_tasklet(r_vec, t, tasklet);\n\n\tspin_lock(&r_vec->lock);\n\tnfp_nfd3_tx_complete(r_vec->tx_ring, 0);\n\t__nfp_ctrl_tx_queued(r_vec);\n\tspin_unlock(&r_vec->lock);\n\n\tif (nfp_ctrl_rx(r_vec)) {\n\t\tnfp_net_irq_unmask(r_vec->nfp_net, r_vec->irq_entry);\n\t} else {\n\t\ttasklet_schedule(&r_vec->tasklet);\n\t\tnn_dp_warn(&r_vec->nfp_net->dp,\n\t\t\t   \"control message budget exceeded!\\n\");\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}