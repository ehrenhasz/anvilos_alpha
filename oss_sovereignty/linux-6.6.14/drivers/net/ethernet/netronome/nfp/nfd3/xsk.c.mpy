{
  "module_name": "xsk.c",
  "hash_id": "b6efeb247c66e0013620f2ea03d952e9376eb1b6a055d79d5c046b366c9b2661",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/netronome/nfp/nfd3/xsk.c",
  "human_readable_source": "\n \n \n\n#include <linux/bpf_trace.h>\n#include <linux/netdevice.h>\n\n#include \"../nfp_app.h\"\n#include \"../nfp_net.h\"\n#include \"../nfp_net_dp.h\"\n#include \"../nfp_net_xsk.h\"\n#include \"nfd3.h\"\n\nstatic bool\nnfp_nfd3_xsk_tx_xdp(const struct nfp_net_dp *dp, struct nfp_net_r_vector *r_vec,\n\t\t    struct nfp_net_rx_ring *rx_ring,\n\t\t    struct nfp_net_tx_ring *tx_ring,\n\t\t    struct nfp_net_xsk_rx_buf *xrxbuf, unsigned int pkt_len,\n\t\t    int pkt_off)\n{\n\tstruct xsk_buff_pool *pool = r_vec->xsk_pool;\n\tstruct nfp_nfd3_tx_buf *txbuf;\n\tstruct nfp_nfd3_tx_desc *txd;\n\tunsigned int wr_idx;\n\n\tif (nfp_net_tx_space(tx_ring) < 1)\n\t\treturn false;\n\n\txsk_buff_raw_dma_sync_for_device(pool, xrxbuf->dma_addr + pkt_off,\n\t\t\t\t\t pkt_len);\n\n\twr_idx = D_IDX(tx_ring, tx_ring->wr_p);\n\n\ttxbuf = &tx_ring->txbufs[wr_idx];\n\ttxbuf->xdp = xrxbuf->xdp;\n\ttxbuf->real_len = pkt_len;\n\ttxbuf->is_xsk_tx = true;\n\n\t \n\ttxd = &tx_ring->txds[wr_idx];\n\ttxd->offset_eop = NFD3_DESC_TX_EOP;\n\ttxd->dma_len = cpu_to_le16(pkt_len);\n\tnfp_desc_set_dma_addr_40b(txd, xrxbuf->dma_addr + pkt_off);\n\ttxd->data_len = cpu_to_le16(pkt_len);\n\n\ttxd->flags = 0;\n\ttxd->mss = 0;\n\ttxd->lso_hdrlen = 0;\n\n\ttx_ring->wr_ptr_add++;\n\ttx_ring->wr_p++;\n\n\treturn true;\n}\n\nstatic void nfp_nfd3_xsk_rx_skb(struct nfp_net_rx_ring *rx_ring,\n\t\t\t\tconst struct nfp_net_rx_desc *rxd,\n\t\t\t\tstruct nfp_net_xsk_rx_buf *xrxbuf,\n\t\t\t\tconst struct nfp_meta_parsed *meta,\n\t\t\t\tunsigned int pkt_len,\n\t\t\t\tbool meta_xdp,\n\t\t\t\tunsigned int *skbs_polled)\n{\n\tstruct nfp_net_r_vector *r_vec = rx_ring->r_vec;\n\tstruct nfp_net_dp *dp = &r_vec->nfp_net->dp;\n\tstruct net_device *netdev;\n\tstruct sk_buff *skb;\n\n\tif (likely(!meta->portid)) {\n\t\tnetdev = dp->netdev;\n\t} else {\n\t\tstruct nfp_net *nn = netdev_priv(dp->netdev);\n\n\t\tnetdev = nfp_app_dev_get(nn->app, meta->portid, NULL);\n\t\tif (unlikely(!netdev)) {\n\t\t\tnfp_net_xsk_rx_drop(r_vec, xrxbuf);\n\t\t\treturn;\n\t\t}\n\t\tnfp_repr_inc_rx_stats(netdev, pkt_len);\n\t}\n\n\tskb = napi_alloc_skb(&r_vec->napi, pkt_len);\n\tif (!skb) {\n\t\tnfp_net_xsk_rx_drop(r_vec, xrxbuf);\n\t\treturn;\n\t}\n\tskb_put_data(skb, xrxbuf->xdp->data, pkt_len);\n\n\tskb->mark = meta->mark;\n\tskb_set_hash(skb, meta->hash, meta->hash_type);\n\n\tskb_record_rx_queue(skb, rx_ring->idx);\n\tskb->protocol = eth_type_trans(skb, netdev);\n\n\tnfp_nfd3_rx_csum(dp, r_vec, rxd, meta, skb);\n\n\tif (unlikely(!nfp_net_vlan_strip(skb, rxd, meta))) {\n\t\tdev_kfree_skb_any(skb);\n\t\tnfp_net_xsk_rx_drop(r_vec, xrxbuf);\n\t\treturn;\n\t}\n\n\tif (meta_xdp)\n\t\tskb_metadata_set(skb,\n\t\t\t\t xrxbuf->xdp->data - xrxbuf->xdp->data_meta);\n\n\tnapi_gro_receive(&rx_ring->r_vec->napi, skb);\n\n\tnfp_net_xsk_rx_free(xrxbuf);\n\n\t(*skbs_polled)++;\n}\n\nstatic unsigned int\nnfp_nfd3_xsk_rx(struct nfp_net_rx_ring *rx_ring, int budget,\n\t\tunsigned int *skbs_polled)\n{\n\tstruct nfp_net_r_vector *r_vec = rx_ring->r_vec;\n\tstruct nfp_net_dp *dp = &r_vec->nfp_net->dp;\n\tstruct nfp_net_tx_ring *tx_ring;\n\tstruct bpf_prog *xdp_prog;\n\tbool xdp_redir = false;\n\tint pkts_polled = 0;\n\n\txdp_prog = READ_ONCE(dp->xdp_prog);\n\ttx_ring = r_vec->xdp_ring;\n\n\twhile (pkts_polled < budget) {\n\t\tunsigned int meta_len, data_len, pkt_len, pkt_off;\n\t\tstruct nfp_net_xsk_rx_buf *xrxbuf;\n\t\tstruct nfp_net_rx_desc *rxd;\n\t\tstruct nfp_meta_parsed meta;\n\t\tint idx, act;\n\n\t\tidx = D_IDX(rx_ring, rx_ring->rd_p);\n\n\t\trxd = &rx_ring->rxds[idx];\n\t\tif (!(rxd->rxd.meta_len_dd & PCIE_DESC_RX_DD))\n\t\t\tbreak;\n\n\t\trx_ring->rd_p++;\n\t\tpkts_polled++;\n\n\t\txrxbuf = &rx_ring->xsk_rxbufs[idx];\n\n\t\t \n\t\tif (rx_ring->rd_p >= rx_ring->wr_p) {\n\t\t\tnn_dp_warn(dp, \"Starved of RX buffers\\n\");\n\t\t\tnfp_net_xsk_rx_drop(r_vec, xrxbuf);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tdma_rmb();\n\n\t\tmemset(&meta, 0, sizeof(meta));\n\n\t\t \n\t\tmeta_len = rxd->rxd.meta_len_dd & PCIE_DESC_RX_META_LEN_MASK;\n\t\tdata_len = le16_to_cpu(rxd->rxd.data_len);\n\t\tpkt_len = data_len - meta_len;\n\n\t\tif (unlikely(meta_len > NFP_NET_MAX_PREPEND)) {\n\t\t\tnn_dp_warn(dp, \"Oversized RX packet metadata %u\\n\",\n\t\t\t\t   meta_len);\n\t\t\tnfp_net_xsk_rx_drop(r_vec, xrxbuf);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tu64_stats_update_begin(&r_vec->rx_sync);\n\t\tr_vec->rx_pkts++;\n\t\tr_vec->rx_bytes += pkt_len;\n\t\tu64_stats_update_end(&r_vec->rx_sync);\n\n\t\txrxbuf->xdp->data += meta_len;\n\t\txrxbuf->xdp->data_end = xrxbuf->xdp->data + pkt_len;\n\t\txdp_set_data_meta_invalid(xrxbuf->xdp);\n\t\txsk_buff_dma_sync_for_cpu(xrxbuf->xdp, r_vec->xsk_pool);\n\t\tnet_prefetch(xrxbuf->xdp->data);\n\n\t\tif (meta_len) {\n\t\t\tif (unlikely(nfp_nfd3_parse_meta(dp->netdev, &meta,\n\t\t\t\t\t\t\t xrxbuf->xdp->data -\n\t\t\t\t\t\t\t meta_len,\n\t\t\t\t\t\t\t xrxbuf->xdp->data,\n\t\t\t\t\t\t\t pkt_len, meta_len))) {\n\t\t\t\tnn_dp_warn(dp, \"Invalid RX packet metadata\\n\");\n\t\t\t\tnfp_net_xsk_rx_drop(r_vec, xrxbuf);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (unlikely(meta.portid)) {\n\t\t\t\tstruct nfp_net *nn = netdev_priv(dp->netdev);\n\n\t\t\t\tif (meta.portid != NFP_META_PORT_ID_CTRL) {\n\t\t\t\t\tnfp_nfd3_xsk_rx_skb(rx_ring, rxd,\n\t\t\t\t\t\t\t    xrxbuf, &meta,\n\t\t\t\t\t\t\t    pkt_len, false,\n\t\t\t\t\t\t\t    skbs_polled);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tnfp_app_ctrl_rx_raw(nn->app, xrxbuf->xdp->data,\n\t\t\t\t\t\t    pkt_len);\n\t\t\t\tnfp_net_xsk_rx_free(xrxbuf);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tact = bpf_prog_run_xdp(xdp_prog, xrxbuf->xdp);\n\n\t\tpkt_len = xrxbuf->xdp->data_end - xrxbuf->xdp->data;\n\t\tpkt_off = xrxbuf->xdp->data - xrxbuf->xdp->data_hard_start;\n\n\t\tswitch (act) {\n\t\tcase XDP_PASS:\n\t\t\tnfp_nfd3_xsk_rx_skb(rx_ring, rxd, xrxbuf, &meta, pkt_len,\n\t\t\t\t\t    true, skbs_polled);\n\t\t\tbreak;\n\t\tcase XDP_TX:\n\t\t\tif (!nfp_nfd3_xsk_tx_xdp(dp, r_vec, rx_ring, tx_ring,\n\t\t\t\t\t\t xrxbuf, pkt_len, pkt_off))\n\t\t\t\tnfp_net_xsk_rx_drop(r_vec, xrxbuf);\n\t\t\telse\n\t\t\t\tnfp_net_xsk_rx_unstash(xrxbuf);\n\t\t\tbreak;\n\t\tcase XDP_REDIRECT:\n\t\t\tif (xdp_do_redirect(dp->netdev, xrxbuf->xdp, xdp_prog)) {\n\t\t\t\tnfp_net_xsk_rx_drop(r_vec, xrxbuf);\n\t\t\t} else {\n\t\t\t\tnfp_net_xsk_rx_unstash(xrxbuf);\n\t\t\t\txdp_redir = true;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbpf_warn_invalid_xdp_action(dp->netdev, xdp_prog, act);\n\t\t\tfallthrough;\n\t\tcase XDP_ABORTED:\n\t\t\ttrace_xdp_exception(dp->netdev, xdp_prog, act);\n\t\t\tfallthrough;\n\t\tcase XDP_DROP:\n\t\t\tnfp_net_xsk_rx_drop(r_vec, xrxbuf);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tnfp_net_xsk_rx_ring_fill_freelist(r_vec->rx_ring);\n\n\tif (xdp_redir)\n\t\txdp_do_flush_map();\n\n\tif (tx_ring->wr_ptr_add)\n\t\tnfp_net_tx_xmit_more_flush(tx_ring);\n\n\treturn pkts_polled;\n}\n\nvoid nfp_nfd3_xsk_tx_free(struct nfp_nfd3_tx_buf *txbuf)\n{\n\txsk_buff_free(txbuf->xdp);\n\n\ttxbuf->dma_addr = 0;\n\ttxbuf->xdp = NULL;\n}\n\nstatic bool nfp_nfd3_xsk_complete(struct nfp_net_tx_ring *tx_ring)\n{\n\tstruct nfp_net_r_vector *r_vec = tx_ring->r_vec;\n\tu32 done_pkts = 0, done_bytes = 0, reused = 0;\n\tbool done_all;\n\tint idx, todo;\n\tu32 qcp_rd_p;\n\n\tif (tx_ring->wr_p == tx_ring->rd_p)\n\t\treturn true;\n\n\t \n\tqcp_rd_p = nfp_qcp_rd_ptr_read(tx_ring->qcp_q);\n\n\tif (qcp_rd_p == tx_ring->qcp_rd_p)\n\t\treturn true;\n\n\ttodo = D_IDX(tx_ring, qcp_rd_p - tx_ring->qcp_rd_p);\n\n\tdone_all = todo <= NFP_NET_XDP_MAX_COMPLETE;\n\ttodo = min(todo, NFP_NET_XDP_MAX_COMPLETE);\n\n\ttx_ring->qcp_rd_p = D_IDX(tx_ring, tx_ring->qcp_rd_p + todo);\n\n\tdone_pkts = todo;\n\twhile (todo--) {\n\t\tstruct nfp_nfd3_tx_buf *txbuf;\n\n\t\tidx = D_IDX(tx_ring, tx_ring->rd_p);\n\t\ttx_ring->rd_p++;\n\n\t\ttxbuf = &tx_ring->txbufs[idx];\n\t\tif (unlikely(!txbuf->real_len))\n\t\t\tcontinue;\n\n\t\tdone_bytes += txbuf->real_len;\n\t\ttxbuf->real_len = 0;\n\n\t\tif (txbuf->is_xsk_tx) {\n\t\t\tnfp_nfd3_xsk_tx_free(txbuf);\n\t\t\treused++;\n\t\t}\n\t}\n\n\tu64_stats_update_begin(&r_vec->tx_sync);\n\tr_vec->tx_bytes += done_bytes;\n\tr_vec->tx_pkts += done_pkts;\n\tu64_stats_update_end(&r_vec->tx_sync);\n\n\txsk_tx_completed(r_vec->xsk_pool, done_pkts - reused);\n\n\tWARN_ONCE(tx_ring->wr_p - tx_ring->rd_p > tx_ring->cnt,\n\t\t  \"XDP TX ring corruption rd_p=%u wr_p=%u cnt=%u\\n\",\n\t\t  tx_ring->rd_p, tx_ring->wr_p, tx_ring->cnt);\n\n\treturn done_all;\n}\n\nstatic void nfp_nfd3_xsk_tx(struct nfp_net_tx_ring *tx_ring)\n{\n\tstruct nfp_net_r_vector *r_vec = tx_ring->r_vec;\n\tstruct xdp_desc desc[NFP_NET_XSK_TX_BATCH];\n\tstruct xsk_buff_pool *xsk_pool;\n\tstruct nfp_nfd3_tx_desc *txd;\n\tu32 pkts = 0, wr_idx;\n\tu32 i, got;\n\n\txsk_pool = r_vec->xsk_pool;\n\n\twhile (nfp_net_tx_space(tx_ring) >= NFP_NET_XSK_TX_BATCH) {\n\t\tfor (i = 0; i < NFP_NET_XSK_TX_BATCH; i++)\n\t\t\tif (!xsk_tx_peek_desc(xsk_pool, &desc[i]))\n\t\t\t\tbreak;\n\t\tgot = i;\n\t\tif (!got)\n\t\t\tbreak;\n\n\t\twr_idx = D_IDX(tx_ring, tx_ring->wr_p + i);\n\t\tprefetchw(&tx_ring->txds[wr_idx]);\n\n\t\tfor (i = 0; i < got; i++)\n\t\t\txsk_buff_raw_dma_sync_for_device(xsk_pool, desc[i].addr,\n\t\t\t\t\t\t\t desc[i].len);\n\n\t\tfor (i = 0; i < got; i++) {\n\t\t\twr_idx = D_IDX(tx_ring, tx_ring->wr_p + i);\n\n\t\t\ttx_ring->txbufs[wr_idx].real_len = desc[i].len;\n\t\t\ttx_ring->txbufs[wr_idx].is_xsk_tx = false;\n\n\t\t\t \n\t\t\ttxd = &tx_ring->txds[wr_idx];\n\t\t\tnfp_desc_set_dma_addr_40b(txd,\n\t\t\t\t\t\t  xsk_buff_raw_get_dma(xsk_pool, desc[i].addr));\n\t\t\ttxd->offset_eop = NFD3_DESC_TX_EOP;\n\t\t\ttxd->dma_len = cpu_to_le16(desc[i].len);\n\t\t\ttxd->data_len = cpu_to_le16(desc[i].len);\n\t\t}\n\n\t\ttx_ring->wr_p += got;\n\t\tpkts += got;\n\t}\n\n\tif (!pkts)\n\t\treturn;\n\n\txsk_tx_release(xsk_pool);\n\t \n\twmb();\n\tnfp_qcp_wr_ptr_add(tx_ring->qcp_q, pkts);\n}\n\nint nfp_nfd3_xsk_poll(struct napi_struct *napi, int budget)\n{\n\tstruct nfp_net_r_vector *r_vec =\n\t\tcontainer_of(napi, struct nfp_net_r_vector, napi);\n\tunsigned int pkts_polled, skbs = 0;\n\n\tpkts_polled = nfp_nfd3_xsk_rx(r_vec->rx_ring, budget, &skbs);\n\n\tif (pkts_polled < budget) {\n\t\tif (r_vec->tx_ring)\n\t\t\tnfp_nfd3_tx_complete(r_vec->tx_ring, budget);\n\n\t\tif (!nfp_nfd3_xsk_complete(r_vec->xdp_ring))\n\t\t\tpkts_polled = budget;\n\n\t\tnfp_nfd3_xsk_tx(r_vec->xdp_ring);\n\n\t\tif (pkts_polled < budget && napi_complete_done(napi, skbs))\n\t\t\tnfp_net_irq_unmask(r_vec->nfp_net, r_vec->irq_entry);\n\t}\n\n\treturn pkts_polled;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}