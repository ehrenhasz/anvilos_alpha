{
  "module_name": "nfp_netvf_main.c",
  "hash_id": "ca430ec75fd859e8adb5012af077d73bf24d3c0e56cef5e8826eb6d8c3266737",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/netronome/nfp/nfp_netvf_main.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/etherdevice.h>\n\n#include \"nfpcore/nfp_dev.h\"\n#include \"nfp_net_ctrl.h\"\n#include \"nfp_net.h\"\n#include \"nfp_main.h\"\n\n \nstruct nfp_net_vf {\n\tstruct nfp_net *nn;\n\n\tstruct msix_entry irq_entries[NFP_NET_NON_Q_VECTORS +\n\t\t\t\t      NFP_NET_MAX_TX_RINGS];\n\tu8 __iomem *q_bar;\n\n\tstruct dentry *ddir;\n};\n\nstatic const char nfp_net_driver_name[] = \"nfp_netvf\";\n\nstatic const struct pci_device_id nfp_netvf_pci_device_ids[] = {\n\t{ PCI_VENDOR_ID_NETRONOME, PCI_DEVICE_ID_NFP3800_VF,\n\t  PCI_VENDOR_ID_NETRONOME, PCI_ANY_ID,\n\t  PCI_ANY_ID, 0, NFP_DEV_NFP3800_VF,\n\t},\n\t{ PCI_VENDOR_ID_NETRONOME, PCI_DEVICE_ID_NFP6000_VF,\n\t  PCI_VENDOR_ID_NETRONOME, PCI_ANY_ID,\n\t  PCI_ANY_ID, 0, NFP_DEV_NFP6000_VF,\n\t},\n\t{ PCI_VENDOR_ID_CORIGINE, PCI_DEVICE_ID_NFP3800_VF,\n\t  PCI_VENDOR_ID_CORIGINE, PCI_ANY_ID,\n\t  PCI_ANY_ID, 0, NFP_DEV_NFP3800_VF,\n\t},\n\t{ PCI_VENDOR_ID_CORIGINE, PCI_DEVICE_ID_NFP6000_VF,\n\t  PCI_VENDOR_ID_CORIGINE, PCI_ANY_ID,\n\t  PCI_ANY_ID, 0, NFP_DEV_NFP6000_VF,\n\t},\n\t{ 0, }  \n};\nMODULE_DEVICE_TABLE(pci, nfp_netvf_pci_device_ids);\n\nstatic void nfp_netvf_get_mac_addr(struct nfp_net *nn)\n{\n\tu8 mac_addr[ETH_ALEN];\n\n\tput_unaligned_be32(nn_readl(nn, NFP_NET_CFG_MACADDR + 0), &mac_addr[0]);\n\tput_unaligned_be16(nn_readw(nn, NFP_NET_CFG_MACADDR + 6), &mac_addr[4]);\n\n\tif (!is_valid_ether_addr(mac_addr)) {\n\t\teth_hw_addr_random(nn->dp.netdev);\n\t\treturn;\n\t}\n\n\teth_hw_addr_set(nn->dp.netdev, mac_addr);\n\tether_addr_copy(nn->dp.netdev->perm_addr, mac_addr);\n}\n\nstatic int nfp_netvf_pci_probe(struct pci_dev *pdev,\n\t\t\t       const struct pci_device_id *pci_id)\n{\n\tconst struct nfp_dev_info *dev_info;\n\tstruct nfp_net_fw_version fw_ver;\n\tint max_tx_rings, max_rx_rings;\n\tu32 tx_bar_off, rx_bar_off;\n\tu32 tx_bar_sz, rx_bar_sz;\n\tint tx_bar_no, rx_bar_no;\n\tstruct nfp_net_vf *vf;\n\tunsigned int num_irqs;\n\tu8 __iomem *ctrl_bar;\n\tstruct nfp_net *nn;\n\tu32 startq;\n\tint stride;\n\tint err;\n\n\tdev_info = &nfp_dev_info[pci_id->driver_data];\n\n\tvf = kzalloc(sizeof(*vf), GFP_KERNEL);\n\tif (!vf)\n\t\treturn -ENOMEM;\n\tpci_set_drvdata(pdev, vf);\n\n\terr = pci_enable_device_mem(pdev);\n\tif (err)\n\t\tgoto err_free_vf;\n\n\terr = pci_request_regions(pdev, nfp_net_driver_name);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Unable to allocate device memory.\\n\");\n\t\tgoto err_pci_disable;\n\t}\n\n\tpci_set_master(pdev);\n\n\terr = dma_set_mask_and_coherent(&pdev->dev, dev_info->dma_mask);\n\tif (err)\n\t\tgoto err_pci_regions;\n\n\t \n\tctrl_bar = ioremap(pci_resource_start(pdev, NFP_NET_CTRL_BAR),\n\t\t\t\t   NFP_NET_CFG_BAR_SZ);\n\tif (!ctrl_bar) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Failed to map resource %d\\n\", NFP_NET_CTRL_BAR);\n\t\terr = -EIO;\n\t\tgoto err_pci_regions;\n\t}\n\n\tnfp_net_get_fw_version(&fw_ver, ctrl_bar);\n\tif (fw_ver.extend & NFP_NET_CFG_VERSION_RESERVED_MASK ||\n\t    fw_ver.class != NFP_NET_CFG_VERSION_CLASS_GENERIC) {\n\t\tdev_err(&pdev->dev, \"Unknown Firmware ABI %d.%d.%d.%d\\n\",\n\t\t\tfw_ver.extend, fw_ver.class,\n\t\t\tfw_ver.major, fw_ver.minor);\n\t\terr = -EINVAL;\n\t\tgoto err_ctrl_unmap;\n\t}\n\n\t \n\tif (nfp_net_fw_ver_eq(&fw_ver, 0, 0, 0, 1)) {\n\t\tstride = 2;\n\t\ttx_bar_no = NFP_NET_Q0_BAR;\n\t\trx_bar_no = NFP_NET_Q1_BAR;\n\t\tdev_warn(&pdev->dev, \"OBSOLETE Firmware detected - VF isolation not available\\n\");\n\t} else {\n\t\tswitch (fw_ver.major) {\n\t\tcase 1 ... 5:\n\t\t\tstride = 4;\n\t\t\ttx_bar_no = NFP_NET_Q0_BAR;\n\t\t\trx_bar_no = tx_bar_no;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(&pdev->dev, \"Unsupported Firmware ABI %d.%d.%d.%d\\n\",\n\t\t\t\tfw_ver.extend, fw_ver.class,\n\t\t\t\tfw_ver.major, fw_ver.minor);\n\t\t\terr = -EINVAL;\n\t\t\tgoto err_ctrl_unmap;\n\t\t}\n\t}\n\n\t \n\tmax_tx_rings = readl(ctrl_bar + NFP_NET_CFG_MAX_TXRINGS);\n\tmax_rx_rings = readl(ctrl_bar + NFP_NET_CFG_MAX_RXRINGS);\n\n\ttx_bar_sz = NFP_QCP_QUEUE_ADDR_SZ * max_tx_rings * stride;\n\trx_bar_sz = NFP_QCP_QUEUE_ADDR_SZ * max_rx_rings * stride;\n\n\t \n\tif (tx_bar_sz > pci_resource_len(pdev, tx_bar_no)) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"TX BAR too small for number of TX rings. Adjusting\\n\");\n\t\ttx_bar_sz = pci_resource_len(pdev, tx_bar_no);\n\t\tmax_tx_rings = (tx_bar_sz / NFP_QCP_QUEUE_ADDR_SZ) / 2;\n\t}\n\tif (rx_bar_sz > pci_resource_len(pdev, rx_bar_no)) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"RX BAR too small for number of RX rings. Adjusting\\n\");\n\t\trx_bar_sz = pci_resource_len(pdev, rx_bar_no);\n\t\tmax_rx_rings = (rx_bar_sz / NFP_QCP_QUEUE_ADDR_SZ) / 2;\n\t}\n\n\tstartq = readl(ctrl_bar + NFP_NET_CFG_START_TXQ);\n\ttx_bar_off = nfp_qcp_queue_offset(dev_info, startq);\n\tstartq = readl(ctrl_bar + NFP_NET_CFG_START_RXQ);\n\trx_bar_off = nfp_qcp_queue_offset(dev_info, startq);\n\n\t \n\tnn = nfp_net_alloc(pdev, dev_info, ctrl_bar, true,\n\t\t\t   max_tx_rings, max_rx_rings);\n\tif (IS_ERR(nn)) {\n\t\terr = PTR_ERR(nn);\n\t\tgoto err_ctrl_unmap;\n\t}\n\tvf->nn = nn;\n\n\tnn->dp.is_vf = 1;\n\tnn->stride_tx = stride;\n\tnn->stride_rx = stride;\n\n\tif (rx_bar_no == tx_bar_no) {\n\t\tu32 bar_off, bar_sz;\n\t\tresource_size_t map_addr;\n\n\t\t \n\t\tif (tx_bar_off < rx_bar_off)\n\t\t\tbar_off = tx_bar_off;\n\t\telse\n\t\t\tbar_off = rx_bar_off;\n\n\t\tif ((tx_bar_off + tx_bar_sz) > (rx_bar_off + rx_bar_sz))\n\t\t\tbar_sz = (tx_bar_off + tx_bar_sz) - bar_off;\n\t\telse\n\t\t\tbar_sz = (rx_bar_off + rx_bar_sz) - bar_off;\n\n\t\tmap_addr = pci_resource_start(pdev, tx_bar_no) + bar_off;\n\t\tvf->q_bar = ioremap(map_addr, bar_sz);\n\t\tif (!vf->q_bar) {\n\t\t\tnn_err(nn, \"Failed to map resource %d\\n\", tx_bar_no);\n\t\t\terr = -EIO;\n\t\t\tgoto err_netdev_free;\n\t\t}\n\n\t\t \n\t\tnn->tx_bar = vf->q_bar + (tx_bar_off - bar_off);\n\t\t \n\t\tnn->rx_bar = vf->q_bar + (rx_bar_off - bar_off);\n\t} else {\n\t\tresource_size_t map_addr;\n\n\t\t \n\t\tmap_addr = pci_resource_start(pdev, tx_bar_no) + tx_bar_off;\n\t\tnn->tx_bar = ioremap(map_addr, tx_bar_sz);\n\t\tif (!nn->tx_bar) {\n\t\t\tnn_err(nn, \"Failed to map resource %d\\n\", tx_bar_no);\n\t\t\terr = -EIO;\n\t\t\tgoto err_netdev_free;\n\t\t}\n\n\t\t \n\t\tmap_addr = pci_resource_start(pdev, rx_bar_no) + rx_bar_off;\n\t\tnn->rx_bar = ioremap(map_addr, rx_bar_sz);\n\t\tif (!nn->rx_bar) {\n\t\t\tnn_err(nn, \"Failed to map resource %d\\n\", rx_bar_no);\n\t\t\terr = -EIO;\n\t\t\tgoto err_unmap_tx;\n\t\t}\n\t}\n\n\tnfp_netvf_get_mac_addr(nn);\n\n\tnum_irqs = nfp_net_irqs_alloc(pdev, vf->irq_entries,\n\t\t\t\t      NFP_NET_MIN_VNIC_IRQS,\n\t\t\t\t      NFP_NET_NON_Q_VECTORS +\n\t\t\t\t      nn->dp.num_r_vecs);\n\tif (!num_irqs) {\n\t\tnn_warn(nn, \"Unable to allocate MSI-X Vectors. Exiting\\n\");\n\t\terr = -EIO;\n\t\tgoto err_unmap_rx;\n\t}\n\tnfp_net_irqs_assign(nn, vf->irq_entries, num_irqs);\n\n\terr = nfp_net_init(nn);\n\tif (err)\n\t\tgoto err_irqs_disable;\n\n\tnfp_net_info(nn);\n\tvf->ddir = nfp_net_debugfs_device_add(pdev);\n\tnfp_net_debugfs_vnic_add(nn, vf->ddir);\n\n\treturn 0;\n\nerr_irqs_disable:\n\tnfp_net_irqs_disable(pdev);\nerr_unmap_rx:\n\tif (!vf->q_bar)\n\t\tiounmap(nn->rx_bar);\nerr_unmap_tx:\n\tif (!vf->q_bar)\n\t\tiounmap(nn->tx_bar);\n\telse\n\t\tiounmap(vf->q_bar);\nerr_netdev_free:\n\tnfp_net_free(nn);\nerr_ctrl_unmap:\n\tiounmap(ctrl_bar);\nerr_pci_regions:\n\tpci_release_regions(pdev);\nerr_pci_disable:\n\tpci_disable_device(pdev);\nerr_free_vf:\n\tpci_set_drvdata(pdev, NULL);\n\tkfree(vf);\n\treturn err;\n}\n\nstatic void nfp_netvf_pci_remove(struct pci_dev *pdev)\n{\n\tstruct nfp_net_vf *vf;\n\tstruct nfp_net *nn;\n\n\tvf = pci_get_drvdata(pdev);\n\tif (!vf)\n\t\treturn;\n\n\tnn = vf->nn;\n\n\t \n\tnfp_net_debugfs_dir_clean(&nn->debugfs_dir);\n\tnfp_net_debugfs_dir_clean(&vf->ddir);\n\n\tnfp_net_clean(nn);\n\n\tnfp_net_irqs_disable(pdev);\n\n\tif (!vf->q_bar) {\n\t\tiounmap(nn->rx_bar);\n\t\tiounmap(nn->tx_bar);\n\t} else {\n\t\tiounmap(vf->q_bar);\n\t}\n\tiounmap(nn->dp.ctrl_bar);\n\n\tnfp_net_free(nn);\n\n\tpci_release_regions(pdev);\n\tpci_disable_device(pdev);\n\n\tpci_set_drvdata(pdev, NULL);\n\tkfree(vf);\n}\n\nstruct pci_driver nfp_netvf_pci_driver = {\n\t.name        = nfp_net_driver_name,\n\t.id_table    = nfp_netvf_pci_device_ids,\n\t.probe       = nfp_netvf_pci_probe,\n\t.remove      = nfp_netvf_pci_remove,\n\t.shutdown    = nfp_netvf_pci_remove,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}