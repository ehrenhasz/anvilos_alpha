{
  "module_name": "nfp_net_ethtool.c",
  "hash_id": "04aa040fd7a24b1cb6def5eab849e047a98405577e1eca6fa4c71b8f4826589e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/netronome/nfp/nfp_net_ethtool.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/bitfield.h>\n#include <linux/kernel.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/ethtool.h>\n#include <linux/firmware.h>\n#include <linux/sfp.h>\n\n#include \"nfpcore/nfp.h\"\n#include \"nfpcore/nfp_dev.h\"\n#include \"nfpcore/nfp_nsp.h\"\n#include \"nfp_app.h\"\n#include \"nfp_main.h\"\n#include \"nfp_net_ctrl.h\"\n#include \"nfp_net_dp.h\"\n#include \"nfp_net.h\"\n#include \"nfp_port.h\"\n#include \"nfpcore/nfp_cpp.h\"\n\nstruct nfp_et_stat {\n\tchar name[ETH_GSTRING_LEN];\n\tint off;\n};\n\nstatic const struct nfp_et_stat nfp_net_et_stats[] = {\n\t \n\t{ \"dev_rx_discards\",\tNFP_NET_CFG_STATS_RX_DISCARDS },\n\t{ \"dev_rx_errors\",\tNFP_NET_CFG_STATS_RX_ERRORS },\n\t{ \"dev_rx_bytes\",\tNFP_NET_CFG_STATS_RX_OCTETS },\n\t{ \"dev_rx_uc_bytes\",\tNFP_NET_CFG_STATS_RX_UC_OCTETS },\n\t{ \"dev_rx_mc_bytes\",\tNFP_NET_CFG_STATS_RX_MC_OCTETS },\n\t{ \"dev_rx_bc_bytes\",\tNFP_NET_CFG_STATS_RX_BC_OCTETS },\n\t{ \"dev_rx_pkts\",\tNFP_NET_CFG_STATS_RX_FRAMES },\n\t{ \"dev_rx_mc_pkts\",\tNFP_NET_CFG_STATS_RX_MC_FRAMES },\n\t{ \"dev_rx_bc_pkts\",\tNFP_NET_CFG_STATS_RX_BC_FRAMES },\n\n\t{ \"dev_tx_discards\",\tNFP_NET_CFG_STATS_TX_DISCARDS },\n\t{ \"dev_tx_errors\",\tNFP_NET_CFG_STATS_TX_ERRORS },\n\t{ \"dev_tx_bytes\",\tNFP_NET_CFG_STATS_TX_OCTETS },\n\t{ \"dev_tx_uc_bytes\",\tNFP_NET_CFG_STATS_TX_UC_OCTETS },\n\t{ \"dev_tx_mc_bytes\",\tNFP_NET_CFG_STATS_TX_MC_OCTETS },\n\t{ \"dev_tx_bc_bytes\",\tNFP_NET_CFG_STATS_TX_BC_OCTETS },\n\t{ \"dev_tx_pkts\",\tNFP_NET_CFG_STATS_TX_FRAMES },\n\t{ \"dev_tx_mc_pkts\",\tNFP_NET_CFG_STATS_TX_MC_FRAMES },\n\t{ \"dev_tx_bc_pkts\",\tNFP_NET_CFG_STATS_TX_BC_FRAMES },\n\n\t{ \"bpf_pass_pkts\",\tNFP_NET_CFG_STATS_APP0_FRAMES },\n\t{ \"bpf_pass_bytes\",\tNFP_NET_CFG_STATS_APP0_BYTES },\n\t \n\t{ \"bpf_app1_pkts\",\tNFP_NET_CFG_STATS_APP1_FRAMES },\n\t{ \"bpf_app1_bytes\",\tNFP_NET_CFG_STATS_APP1_BYTES },\n\t{ \"bpf_app2_pkts\",\tNFP_NET_CFG_STATS_APP2_FRAMES },\n\t{ \"bpf_app2_bytes\",\tNFP_NET_CFG_STATS_APP2_BYTES },\n\t{ \"bpf_app3_pkts\",\tNFP_NET_CFG_STATS_APP3_FRAMES },\n\t{ \"bpf_app3_bytes\",\tNFP_NET_CFG_STATS_APP3_BYTES },\n};\n\nstatic const struct nfp_et_stat nfp_mac_et_stats[] = {\n\t{ \"rx_octets\",\t\t\tNFP_MAC_STATS_RX_IN_OCTETS, },\n\t{ \"rx_frame_too_long_errors\",\n\t\t\tNFP_MAC_STATS_RX_FRAME_TOO_LONG_ERRORS, },\n\t{ \"rx_range_length_errors\",\tNFP_MAC_STATS_RX_RANGE_LENGTH_ERRORS, },\n\t{ \"rx_vlan_received_ok\",\tNFP_MAC_STATS_RX_VLAN_RECEIVED_OK, },\n\t{ \"rx_errors\",\t\t\tNFP_MAC_STATS_RX_IN_ERRORS, },\n\t{ \"rx_broadcast_pkts\",\t\tNFP_MAC_STATS_RX_IN_BROADCAST_PKTS, },\n\t{ \"rx_drop_events\",\t\tNFP_MAC_STATS_RX_DROP_EVENTS, },\n\t{ \"rx_alignment_errors\",\tNFP_MAC_STATS_RX_ALIGNMENT_ERRORS, },\n\t{ \"rx_pause_mac_ctrl_frames\",\n\t\t\tNFP_MAC_STATS_RX_PAUSE_MAC_CTRL_FRAMES, },\n\t{ \"rx_frames_received_ok\",\tNFP_MAC_STATS_RX_FRAMES_RECEIVED_OK, },\n\t{ \"rx_frame_check_sequence_errors\",\n\t\t\tNFP_MAC_STATS_RX_FRAME_CHECK_SEQUENCE_ERRORS, },\n\t{ \"rx_unicast_pkts\",\t\tNFP_MAC_STATS_RX_UNICAST_PKTS, },\n\t{ \"rx_multicast_pkts\",\t\tNFP_MAC_STATS_RX_MULTICAST_PKTS, },\n\t{ \"rx_pkts\",\t\t\tNFP_MAC_STATS_RX_PKTS, },\n\t{ \"rx_undersize_pkts\",\t\tNFP_MAC_STATS_RX_UNDERSIZE_PKTS, },\n\t{ \"rx_pkts_64_octets\",\t\tNFP_MAC_STATS_RX_PKTS_64_OCTETS, },\n\t{ \"rx_pkts_65_to_127_octets\",\n\t\t\tNFP_MAC_STATS_RX_PKTS_65_TO_127_OCTETS, },\n\t{ \"rx_pkts_128_to_255_octets\",\n\t\t\tNFP_MAC_STATS_RX_PKTS_128_TO_255_OCTETS, },\n\t{ \"rx_pkts_256_to_511_octets\",\n\t\t\tNFP_MAC_STATS_RX_PKTS_256_TO_511_OCTETS, },\n\t{ \"rx_pkts_512_to_1023_octets\",\n\t\t\tNFP_MAC_STATS_RX_PKTS_512_TO_1023_OCTETS, },\n\t{ \"rx_pkts_1024_to_1518_octets\",\n\t\t\tNFP_MAC_STATS_RX_PKTS_1024_TO_1518_OCTETS, },\n\t{ \"rx_pkts_1519_to_max_octets\",\n\t\t\tNFP_MAC_STATS_RX_PKTS_1519_TO_MAX_OCTETS, },\n\t{ \"rx_jabbers\",\t\t\tNFP_MAC_STATS_RX_JABBERS, },\n\t{ \"rx_fragments\",\t\tNFP_MAC_STATS_RX_FRAGMENTS, },\n\t{ \"rx_oversize_pkts\",\t\tNFP_MAC_STATS_RX_OVERSIZE_PKTS, },\n\t{ \"rx_pause_frames_class0\",\tNFP_MAC_STATS_RX_PAUSE_FRAMES_CLASS0, },\n\t{ \"rx_pause_frames_class1\",\tNFP_MAC_STATS_RX_PAUSE_FRAMES_CLASS1, },\n\t{ \"rx_pause_frames_class2\",\tNFP_MAC_STATS_RX_PAUSE_FRAMES_CLASS2, },\n\t{ \"rx_pause_frames_class3\",\tNFP_MAC_STATS_RX_PAUSE_FRAMES_CLASS3, },\n\t{ \"rx_pause_frames_class4\",\tNFP_MAC_STATS_RX_PAUSE_FRAMES_CLASS4, },\n\t{ \"rx_pause_frames_class5\",\tNFP_MAC_STATS_RX_PAUSE_FRAMES_CLASS5, },\n\t{ \"rx_pause_frames_class6\",\tNFP_MAC_STATS_RX_PAUSE_FRAMES_CLASS6, },\n\t{ \"rx_pause_frames_class7\",\tNFP_MAC_STATS_RX_PAUSE_FRAMES_CLASS7, },\n\t{ \"rx_mac_ctrl_frames_received\",\n\t\t\tNFP_MAC_STATS_RX_MAC_CTRL_FRAMES_RECEIVED, },\n\t{ \"rx_mac_head_drop\",\t\tNFP_MAC_STATS_RX_MAC_HEAD_DROP, },\n\t{ \"tx_queue_drop\",\t\tNFP_MAC_STATS_TX_QUEUE_DROP, },\n\t{ \"tx_octets\",\t\t\tNFP_MAC_STATS_TX_OUT_OCTETS, },\n\t{ \"tx_vlan_transmitted_ok\",\tNFP_MAC_STATS_TX_VLAN_TRANSMITTED_OK, },\n\t{ \"tx_errors\",\t\t\tNFP_MAC_STATS_TX_OUT_ERRORS, },\n\t{ \"tx_broadcast_pkts\",\t\tNFP_MAC_STATS_TX_BROADCAST_PKTS, },\n\t{ \"tx_pause_mac_ctrl_frames\",\n\t\t\tNFP_MAC_STATS_TX_PAUSE_MAC_CTRL_FRAMES, },\n\t{ \"tx_frames_transmitted_ok\",\n\t\t\tNFP_MAC_STATS_TX_FRAMES_TRANSMITTED_OK, },\n\t{ \"tx_unicast_pkts\",\t\tNFP_MAC_STATS_TX_UNICAST_PKTS, },\n\t{ \"tx_multicast_pkts\",\t\tNFP_MAC_STATS_TX_MULTICAST_PKTS, },\n\t{ \"tx_pkts_64_octets\",\t\tNFP_MAC_STATS_TX_PKTS_64_OCTETS, },\n\t{ \"tx_pkts_65_to_127_octets\",\n\t\t\tNFP_MAC_STATS_TX_PKTS_65_TO_127_OCTETS, },\n\t{ \"tx_pkts_128_to_255_octets\",\n\t\t\tNFP_MAC_STATS_TX_PKTS_128_TO_255_OCTETS, },\n\t{ \"tx_pkts_256_to_511_octets\",\n\t\t\tNFP_MAC_STATS_TX_PKTS_256_TO_511_OCTETS, },\n\t{ \"tx_pkts_512_to_1023_octets\",\n\t\t\tNFP_MAC_STATS_TX_PKTS_512_TO_1023_OCTETS, },\n\t{ \"tx_pkts_1024_to_1518_octets\",\n\t\t\tNFP_MAC_STATS_TX_PKTS_1024_TO_1518_OCTETS, },\n\t{ \"tx_pkts_1519_to_max_octets\",\n\t\t\tNFP_MAC_STATS_TX_PKTS_1519_TO_MAX_OCTETS, },\n\t{ \"tx_pause_frames_class0\",\tNFP_MAC_STATS_TX_PAUSE_FRAMES_CLASS0, },\n\t{ \"tx_pause_frames_class1\",\tNFP_MAC_STATS_TX_PAUSE_FRAMES_CLASS1, },\n\t{ \"tx_pause_frames_class2\",\tNFP_MAC_STATS_TX_PAUSE_FRAMES_CLASS2, },\n\t{ \"tx_pause_frames_class3\",\tNFP_MAC_STATS_TX_PAUSE_FRAMES_CLASS3, },\n\t{ \"tx_pause_frames_class4\",\tNFP_MAC_STATS_TX_PAUSE_FRAMES_CLASS4, },\n\t{ \"tx_pause_frames_class5\",\tNFP_MAC_STATS_TX_PAUSE_FRAMES_CLASS5, },\n\t{ \"tx_pause_frames_class6\",\tNFP_MAC_STATS_TX_PAUSE_FRAMES_CLASS6, },\n\t{ \"tx_pause_frames_class7\",\tNFP_MAC_STATS_TX_PAUSE_FRAMES_CLASS7, },\n};\n\nstatic const char nfp_tlv_stat_names[][ETH_GSTRING_LEN] = {\n\t[1]\t= \"dev_rx_discards\",\n\t[2]\t= \"dev_rx_errors\",\n\t[3]\t= \"dev_rx_bytes\",\n\t[4]\t= \"dev_rx_uc_bytes\",\n\t[5]\t= \"dev_rx_mc_bytes\",\n\t[6]\t= \"dev_rx_bc_bytes\",\n\t[7]\t= \"dev_rx_pkts\",\n\t[8]\t= \"dev_rx_mc_pkts\",\n\t[9]\t= \"dev_rx_bc_pkts\",\n\n\t[10]\t= \"dev_tx_discards\",\n\t[11]\t= \"dev_tx_errors\",\n\t[12]\t= \"dev_tx_bytes\",\n\t[13]\t= \"dev_tx_uc_bytes\",\n\t[14]\t= \"dev_tx_mc_bytes\",\n\t[15]\t= \"dev_tx_bc_bytes\",\n\t[16]\t= \"dev_tx_pkts\",\n\t[17]\t= \"dev_tx_mc_pkts\",\n\t[18]\t= \"dev_tx_bc_pkts\",\n};\n\n#define NN_ET_GLOBAL_STATS_LEN ARRAY_SIZE(nfp_net_et_stats)\n#define NN_ET_SWITCH_STATS_LEN 9\n#define NN_RVEC_GATHER_STATS\t13\n#define NN_RVEC_PER_Q_STATS\t3\n#define NN_CTRL_PATH_STATS\t4\n\n#define SFP_SFF_REV_COMPLIANCE\t1\n\nstatic void nfp_net_get_nspinfo(struct nfp_app *app, char *version)\n{\n\tstruct nfp_nsp *nsp;\n\n\tif (!app)\n\t\treturn;\n\n\tnsp = nfp_nsp_open(app->cpp);\n\tif (IS_ERR(nsp))\n\t\treturn;\n\n\tsnprintf(version, ETHTOOL_FWVERS_LEN, \"%hu.%hu\",\n\t\t nfp_nsp_get_abi_ver_major(nsp),\n\t\t nfp_nsp_get_abi_ver_minor(nsp));\n\n\tnfp_nsp_close(nsp);\n}\n\nstatic void\nnfp_get_drvinfo(struct nfp_app *app, struct pci_dev *pdev,\n\t\tconst char *vnic_version, struct ethtool_drvinfo *drvinfo)\n{\n\tchar nsp_version[ETHTOOL_FWVERS_LEN] = {};\n\n\tstrscpy(drvinfo->driver, dev_driver_string(&pdev->dev),\n\t\tsizeof(drvinfo->driver));\n\tnfp_net_get_nspinfo(app, nsp_version);\n\tsnprintf(drvinfo->fw_version, sizeof(drvinfo->fw_version),\n\t\t \"%s %s %s %s\", vnic_version, nsp_version,\n\t\t nfp_app_mip_name(app), nfp_app_name(app));\n}\n\nstatic void\nnfp_net_get_drvinfo(struct net_device *netdev, struct ethtool_drvinfo *drvinfo)\n{\n\tchar vnic_version[ETHTOOL_FWVERS_LEN] = {};\n\tstruct nfp_net *nn = netdev_priv(netdev);\n\n\tsnprintf(vnic_version, sizeof(vnic_version), \"%d.%d.%d.%d\",\n\t\t nn->fw_ver.extend, nn->fw_ver.class,\n\t\t nn->fw_ver.major, nn->fw_ver.minor);\n\tstrscpy(drvinfo->bus_info, pci_name(nn->pdev),\n\t\tsizeof(drvinfo->bus_info));\n\n\tnfp_get_drvinfo(nn->app, nn->pdev, vnic_version, drvinfo);\n}\n\nstatic int\nnfp_net_nway_reset(struct net_device *netdev)\n{\n\tstruct nfp_eth_table_port *eth_port;\n\tstruct nfp_port *port;\n\tint err;\n\n\tport = nfp_port_from_netdev(netdev);\n\teth_port = nfp_port_get_eth_port(port);\n\tif (!eth_port)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!netif_running(netdev))\n\t\treturn 0;\n\n\terr = nfp_eth_set_configured(port->app->cpp, eth_port->index, false);\n\tif (err) {\n\t\tnetdev_info(netdev, \"Link down failed: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\terr = nfp_eth_set_configured(port->app->cpp, eth_port->index, true);\n\tif (err) {\n\t\tnetdev_info(netdev, \"Link up failed: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tnetdev_info(netdev, \"Link reset succeeded\\n\");\n\treturn 0;\n}\n\nstatic void\nnfp_app_get_drvinfo(struct net_device *netdev, struct ethtool_drvinfo *drvinfo)\n{\n\tstruct nfp_app *app = nfp_app_from_netdev(netdev);\n\n\tstrscpy(drvinfo->bus_info, pci_name(app->pdev),\n\t\tsizeof(drvinfo->bus_info));\n\tnfp_get_drvinfo(app, app->pdev, \"*\", drvinfo);\n}\n\nstatic void\nnfp_net_set_fec_link_mode(struct nfp_eth_table_port *eth_port,\n\t\t\t  struct ethtool_link_ksettings *c)\n{\n\tunsigned int modes;\n\n\tethtool_link_ksettings_add_link_mode(c, supported, FEC_NONE);\n\tif (!nfp_eth_can_support_fec(eth_port)) {\n\t\tethtool_link_ksettings_add_link_mode(c, advertising, FEC_NONE);\n\t\treturn;\n\t}\n\n\tmodes = nfp_eth_supported_fec_modes(eth_port);\n\tif (modes & NFP_FEC_BASER) {\n\t\tethtool_link_ksettings_add_link_mode(c, supported, FEC_BASER);\n\t\tethtool_link_ksettings_add_link_mode(c, advertising, FEC_BASER);\n\t}\n\n\tif (modes & NFP_FEC_REED_SOLOMON) {\n\t\tethtool_link_ksettings_add_link_mode(c, supported, FEC_RS);\n\t\tethtool_link_ksettings_add_link_mode(c, advertising, FEC_RS);\n\t}\n}\n\nstatic const struct nfp_eth_media_link_mode {\n\tu16 ethtool_link_mode;\n\tu16 speed;\n} nfp_eth_media_table[NFP_MEDIA_LINK_MODES_NUMBER] = {\n\t[NFP_MEDIA_1000BASE_CX] = {\n\t\t.ethtool_link_mode\t= ETHTOOL_LINK_MODE_1000baseKX_Full_BIT,\n\t\t.speed\t\t\t= NFP_SPEED_1G,\n\t},\n\t[NFP_MEDIA_1000BASE_KX] = {\n\t\t.ethtool_link_mode\t= ETHTOOL_LINK_MODE_1000baseKX_Full_BIT,\n\t\t.speed\t\t\t= NFP_SPEED_1G,\n\t},\n\t[NFP_MEDIA_10GBASE_KX4] = {\n\t\t.ethtool_link_mode\t= ETHTOOL_LINK_MODE_10000baseKX4_Full_BIT,\n\t\t.speed\t\t\t= NFP_SPEED_10G,\n\t},\n\t[NFP_MEDIA_10GBASE_KR] = {\n\t\t.ethtool_link_mode\t= ETHTOOL_LINK_MODE_10000baseKR_Full_BIT,\n\t\t.speed\t\t\t= NFP_SPEED_10G,\n\t},\n\t[NFP_MEDIA_10GBASE_LR] = {\n\t\t.ethtool_link_mode\t= ETHTOOL_LINK_MODE_10000baseLR_Full_BIT,\n\t\t.speed\t\t\t= NFP_SPEED_10G,\n\t},\n\t[NFP_MEDIA_10GBASE_CX4] = {\n\t\t.ethtool_link_mode\t= ETHTOOL_LINK_MODE_10000baseKX4_Full_BIT,\n\t\t.speed\t\t\t= NFP_SPEED_10G,\n\t},\n\t[NFP_MEDIA_10GBASE_CR] = {\n\t\t.ethtool_link_mode\t= ETHTOOL_LINK_MODE_10000baseCR_Full_BIT,\n\t\t.speed\t\t\t= NFP_SPEED_10G,\n\t},\n\t[NFP_MEDIA_10GBASE_SR] = {\n\t\t.ethtool_link_mode\t= ETHTOOL_LINK_MODE_10000baseSR_Full_BIT,\n\t\t.speed\t\t\t= NFP_SPEED_10G,\n\t},\n\t[NFP_MEDIA_10GBASE_ER] = {\n\t\t.ethtool_link_mode\t= ETHTOOL_LINK_MODE_10000baseER_Full_BIT,\n\t\t.speed\t\t\t= NFP_SPEED_10G,\n\t},\n\t[NFP_MEDIA_25GBASE_KR] = {\n\t\t.ethtool_link_mode\t= ETHTOOL_LINK_MODE_25000baseKR_Full_BIT,\n\t\t.speed\t\t\t= NFP_SPEED_25G,\n\t},\n\t[NFP_MEDIA_25GBASE_KR_S] = {\n\t\t.ethtool_link_mode\t= ETHTOOL_LINK_MODE_25000baseKR_Full_BIT,\n\t\t.speed\t\t\t= NFP_SPEED_25G,\n\t},\n\t[NFP_MEDIA_25GBASE_CR] = {\n\t\t.ethtool_link_mode\t= ETHTOOL_LINK_MODE_25000baseCR_Full_BIT,\n\t\t.speed\t\t\t= NFP_SPEED_25G,\n\t},\n\t[NFP_MEDIA_25GBASE_CR_S] = {\n\t\t.ethtool_link_mode\t= ETHTOOL_LINK_MODE_25000baseCR_Full_BIT,\n\t\t.speed\t\t\t= NFP_SPEED_25G,\n\t},\n\t[NFP_MEDIA_25GBASE_SR] = {\n\t\t.ethtool_link_mode\t= ETHTOOL_LINK_MODE_25000baseSR_Full_BIT,\n\t\t.speed\t\t\t= NFP_SPEED_25G,\n\t},\n\t[NFP_MEDIA_25GBASE_LR] = {\n\t\t.ethtool_link_mode\t= ETHTOOL_LINK_MODE_25000baseSR_Full_BIT,\n\t\t.speed\t\t\t= NFP_SPEED_25G,\n\t},\n\t[NFP_MEDIA_25GBASE_ER] = {\n\t\t.ethtool_link_mode\t= ETHTOOL_LINK_MODE_25000baseSR_Full_BIT,\n\t\t.speed\t\t\t= NFP_SPEED_25G,\n\t},\n\t[NFP_MEDIA_40GBASE_CR4] = {\n\t\t.ethtool_link_mode\t= ETHTOOL_LINK_MODE_40000baseCR4_Full_BIT,\n\t\t.speed\t\t\t= NFP_SPEED_40G,\n\t},\n\t[NFP_MEDIA_40GBASE_KR4] = {\n\t\t.ethtool_link_mode\t= ETHTOOL_LINK_MODE_40000baseKR4_Full_BIT,\n\t\t.speed\t\t\t= NFP_SPEED_40G,\n\t},\n\t[NFP_MEDIA_40GBASE_SR4] = {\n\t\t.ethtool_link_mode\t= ETHTOOL_LINK_MODE_40000baseSR4_Full_BIT,\n\t\t.speed\t\t\t= NFP_SPEED_40G,\n\t},\n\t[NFP_MEDIA_40GBASE_LR4] = {\n\t\t.ethtool_link_mode\t= ETHTOOL_LINK_MODE_40000baseLR4_Full_BIT,\n\t\t.speed\t\t\t= NFP_SPEED_40G,\n\t},\n\t[NFP_MEDIA_50GBASE_KR] = {\n\t\t.ethtool_link_mode\t= ETHTOOL_LINK_MODE_50000baseKR_Full_BIT,\n\t\t.speed\t\t\t= NFP_SPEED_50G,\n\t},\n\t[NFP_MEDIA_50GBASE_SR] = {\n\t\t.ethtool_link_mode\t= ETHTOOL_LINK_MODE_50000baseSR_Full_BIT,\n\t\t.speed\t\t\t= NFP_SPEED_50G,\n\t},\n\t[NFP_MEDIA_50GBASE_CR] = {\n\t\t.ethtool_link_mode\t= ETHTOOL_LINK_MODE_50000baseCR_Full_BIT,\n\t\t.speed\t\t\t= NFP_SPEED_50G,\n\t},\n\t[NFP_MEDIA_50GBASE_LR] = {\n\t\t.ethtool_link_mode\t= ETHTOOL_LINK_MODE_50000baseLR_ER_FR_Full_BIT,\n\t\t.speed\t\t\t= NFP_SPEED_50G,\n\t},\n\t[NFP_MEDIA_50GBASE_ER] = {\n\t\t.ethtool_link_mode\t= ETHTOOL_LINK_MODE_50000baseLR_ER_FR_Full_BIT,\n\t\t.speed\t\t\t= NFP_SPEED_50G,\n\t},\n\t[NFP_MEDIA_50GBASE_FR] = {\n\t\t.ethtool_link_mode\t= ETHTOOL_LINK_MODE_50000baseLR_ER_FR_Full_BIT,\n\t\t.speed\t\t\t= NFP_SPEED_50G,\n\t},\n\t[NFP_MEDIA_100GBASE_KR4] = {\n\t\t.ethtool_link_mode\t= ETHTOOL_LINK_MODE_100000baseKR4_Full_BIT,\n\t\t.speed\t\t\t= NFP_SPEED_100G,\n\t},\n\t[NFP_MEDIA_100GBASE_SR4] = {\n\t\t.ethtool_link_mode\t= ETHTOOL_LINK_MODE_100000baseSR4_Full_BIT,\n\t\t.speed\t\t\t= NFP_SPEED_100G,\n\t},\n\t[NFP_MEDIA_100GBASE_CR4] = {\n\t\t.ethtool_link_mode\t= ETHTOOL_LINK_MODE_100000baseCR4_Full_BIT,\n\t\t.speed\t\t\t= NFP_SPEED_100G,\n\t},\n\t[NFP_MEDIA_100GBASE_KP4] = {\n\t\t.ethtool_link_mode\t= ETHTOOL_LINK_MODE_100000baseKR4_Full_BIT,\n\t\t.speed\t\t\t= NFP_SPEED_100G,\n\t},\n\t[NFP_MEDIA_100GBASE_CR10] = {\n\t\t.ethtool_link_mode\t= ETHTOOL_LINK_MODE_100000baseCR4_Full_BIT,\n\t\t.speed\t\t\t= NFP_SPEED_100G,\n\t},\n};\n\nstatic const unsigned int nfp_eth_speed_map[NFP_SUP_SPEED_NUMBER] = {\n\t[NFP_SPEED_1G]\t\t= SPEED_1000,\n\t[NFP_SPEED_10G]\t\t= SPEED_10000,\n\t[NFP_SPEED_25G]\t\t= SPEED_25000,\n\t[NFP_SPEED_40G]\t\t= SPEED_40000,\n\t[NFP_SPEED_50G]\t\t= SPEED_50000,\n\t[NFP_SPEED_100G]\t= SPEED_100000,\n};\n\nstatic void nfp_add_media_link_mode(struct nfp_port *port,\n\t\t\t\t    struct nfp_eth_table_port *eth_port,\n\t\t\t\t    struct ethtool_link_ksettings *cmd)\n{\n\tbitmap_zero(port->speed_bitmap, NFP_SUP_SPEED_NUMBER);\n\n\tfor (u32 i = 0; i < NFP_MEDIA_LINK_MODES_NUMBER; i++) {\n\t\tif (i < 64) {\n\t\t\tif (eth_port->link_modes_supp[0] & BIT_ULL(i)) {\n\t\t\t\t__set_bit(nfp_eth_media_table[i].ethtool_link_mode,\n\t\t\t\t\t  cmd->link_modes.supported);\n\t\t\t\t__set_bit(nfp_eth_media_table[i].speed,\n\t\t\t\t\t  port->speed_bitmap);\n\t\t\t}\n\n\t\t\tif (eth_port->link_modes_ad[0] & BIT_ULL(i))\n\t\t\t\t__set_bit(nfp_eth_media_table[i].ethtool_link_mode,\n\t\t\t\t\t  cmd->link_modes.advertising);\n\t\t} else {\n\t\t\tif (eth_port->link_modes_supp[1] & BIT_ULL(i - 64)) {\n\t\t\t\t__set_bit(nfp_eth_media_table[i].ethtool_link_mode,\n\t\t\t\t\t  cmd->link_modes.supported);\n\t\t\t\t__set_bit(nfp_eth_media_table[i].speed,\n\t\t\t\t\t  port->speed_bitmap);\n\t\t\t}\n\n\t\t\tif (eth_port->link_modes_ad[1] & BIT_ULL(i - 64))\n\t\t\t\t__set_bit(nfp_eth_media_table[i].ethtool_link_mode,\n\t\t\t\t\t  cmd->link_modes.advertising);\n\t\t}\n\t}\n\n\t \n\tif (bitmap_empty(port->speed_bitmap, NFP_SUP_SPEED_NUMBER))\n\t\tbitmap_fill(port->speed_bitmap, NFP_SUP_SPEED_NUMBER);\n}\n\n \nstatic int\nnfp_net_get_link_ksettings(struct net_device *netdev,\n\t\t\t   struct ethtool_link_ksettings *cmd)\n{\n\tstruct nfp_eth_table_port *eth_port;\n\tstruct nfp_port *port;\n\tstruct nfp_net *nn;\n\tunsigned int speed;\n\tu16 sts;\n\n\t \n\tethtool_link_ksettings_zero_link_mode(cmd, supported);\n\tethtool_link_ksettings_zero_link_mode(cmd, advertising);\n\tethtool_link_ksettings_add_link_mode(cmd, supported, FIBRE);\n\tcmd->base.port = PORT_OTHER;\n\tcmd->base.speed = SPEED_UNKNOWN;\n\tcmd->base.duplex = DUPLEX_UNKNOWN;\n\n\tport = nfp_port_from_netdev(netdev);\n\teth_port = nfp_port_get_eth_port(port);\n\tif (eth_port) {\n\t\tethtool_link_ksettings_add_link_mode(cmd, supported, Pause);\n\t\tethtool_link_ksettings_add_link_mode(cmd, advertising, Pause);\n\t\tnfp_add_media_link_mode(port, eth_port, cmd);\n\t\tif (eth_port->supp_aneg) {\n\t\t\tethtool_link_ksettings_add_link_mode(cmd, supported, Autoneg);\n\t\t\tif (eth_port->aneg == NFP_ANEG_AUTO) {\n\t\t\t\tethtool_link_ksettings_add_link_mode(cmd, advertising, Autoneg);\n\t\t\t\tcmd->base.autoneg = AUTONEG_ENABLE;\n\t\t\t}\n\t\t}\n\t\tnfp_net_set_fec_link_mode(eth_port, cmd);\n\t}\n\n\tif (!netif_carrier_ok(netdev))\n\t\treturn 0;\n\n\t \n\tif (eth_port) {\n\t\tcmd->base.port = eth_port->port_type;\n\t\tcmd->base.speed = eth_port->speed;\n\t\tcmd->base.duplex = DUPLEX_FULL;\n\t\treturn 0;\n\t}\n\n\tif (!nfp_netdev_is_nfp_net(netdev))\n\t\treturn -EOPNOTSUPP;\n\tnn = netdev_priv(netdev);\n\n\tsts = nn_readw(nn, NFP_NET_CFG_STS);\n\tspeed = nfp_net_lr2speed(FIELD_GET(NFP_NET_CFG_STS_LINK_RATE, sts));\n\tif (!speed)\n\t\treturn -EOPNOTSUPP;\n\n\tif (speed != SPEED_UNKNOWN) {\n\t\tcmd->base.speed = speed;\n\t\tcmd->base.duplex = DUPLEX_FULL;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nnfp_net_set_link_ksettings(struct net_device *netdev,\n\t\t\t   const struct ethtool_link_ksettings *cmd)\n{\n\tbool req_aneg = (cmd->base.autoneg == AUTONEG_ENABLE);\n\tstruct nfp_eth_table_port *eth_port;\n\tstruct nfp_port *port;\n\tstruct nfp_nsp *nsp;\n\tint err;\n\n\tport = nfp_port_from_netdev(netdev);\n\teth_port = __nfp_port_get_eth_port(port);\n\tif (!eth_port)\n\t\treturn -EOPNOTSUPP;\n\n\tif (netif_running(netdev)) {\n\t\tnetdev_warn(netdev, \"Changing settings not allowed on an active interface. It may cause the port to be disabled until driver reload.\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tnsp = nfp_eth_config_start(port->app->cpp, eth_port->index);\n\tif (IS_ERR(nsp))\n\t\treturn PTR_ERR(nsp);\n\n\tif (req_aneg && !eth_port->supp_aneg) {\n\t\tnetdev_warn(netdev, \"Autoneg is not supported.\\n\");\n\t\terr = -EOPNOTSUPP;\n\t\tgoto err_bad_set;\n\t}\n\n\terr = __nfp_eth_set_aneg(nsp, req_aneg ? NFP_ANEG_AUTO : NFP_ANEG_DISABLED);\n\tif (err)\n\t\tgoto err_bad_set;\n\n\tif (cmd->base.speed != SPEED_UNKNOWN) {\n\t\tu32 speed = cmd->base.speed / eth_port->lanes;\n\t\tbool is_supported = false;\n\n\t\tfor (u32 i = 0; i < NFP_SUP_SPEED_NUMBER; i++) {\n\t\t\tif (cmd->base.speed == nfp_eth_speed_map[i] &&\n\t\t\t    test_bit(i, port->speed_bitmap)) {\n\t\t\t\tis_supported = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!is_supported) {\n\t\t\tnetdev_err(netdev, \"Speed %u is not supported.\\n\",\n\t\t\t\t   cmd->base.speed);\n\t\t\terr = -EINVAL;\n\t\t\tgoto err_bad_set;\n\t\t}\n\n\t\tif (req_aneg) {\n\t\t\tnetdev_err(netdev, \"Speed changing is not allowed when working on autoneg mode.\\n\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto err_bad_set;\n\t\t}\n\n\t\terr = __nfp_eth_set_speed(nsp, speed);\n\t\tif (err)\n\t\t\tgoto err_bad_set;\n\t}\n\n\terr = nfp_eth_config_commit_end(nsp);\n\tif (err > 0)\n\t\treturn 0;  \n\n\tnfp_net_refresh_port_table(port);\n\n\treturn err;\n\nerr_bad_set:\n\tnfp_eth_config_cleanup_end(nsp);\n\treturn err;\n}\n\nstatic void nfp_net_get_ringparam(struct net_device *netdev,\n\t\t\t\t  struct ethtool_ringparam *ring,\n\t\t\t\t  struct kernel_ethtool_ringparam *kernel_ring,\n\t\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct nfp_net *nn = netdev_priv(netdev);\n\tu32 qc_max = nn->dev_info->max_qc_size;\n\n\tring->rx_max_pending = qc_max;\n\tring->tx_max_pending = qc_max / nn->dp.ops->tx_min_desc_per_pkt;\n\tring->rx_pending = nn->dp.rxd_cnt;\n\tring->tx_pending = nn->dp.txd_cnt;\n}\n\nstatic int nfp_net_set_ring_size(struct nfp_net *nn, u32 rxd_cnt, u32 txd_cnt)\n{\n\tstruct nfp_net_dp *dp;\n\n\tdp = nfp_net_clone_dp(nn);\n\tif (!dp)\n\t\treturn -ENOMEM;\n\n\tdp->rxd_cnt = rxd_cnt;\n\tdp->txd_cnt = txd_cnt;\n\n\treturn nfp_net_ring_reconfig(nn, dp, NULL);\n}\n\nstatic int nfp_net_set_ringparam(struct net_device *netdev,\n\t\t\t\t struct ethtool_ringparam *ring,\n\t\t\t\t struct kernel_ethtool_ringparam *kernel_ring,\n\t\t\t\t struct netlink_ext_ack *extack)\n{\n\tu32 tx_dpp, qc_min, qc_max, rxd_cnt, txd_cnt;\n\tstruct nfp_net *nn = netdev_priv(netdev);\n\n\t \n\tif (ring->rx_mini_pending || ring->rx_jumbo_pending)\n\t\treturn -EINVAL;\n\n\tqc_min = nn->dev_info->min_qc_size;\n\tqc_max = nn->dev_info->max_qc_size;\n\ttx_dpp = nn->dp.ops->tx_min_desc_per_pkt;\n\t \n\trxd_cnt = roundup_pow_of_two(ring->rx_pending);\n\ttxd_cnt = roundup_pow_of_two(ring->tx_pending);\n\n\tif (rxd_cnt < qc_min || rxd_cnt > qc_max ||\n\t    txd_cnt < qc_min / tx_dpp || txd_cnt > qc_max / tx_dpp)\n\t\treturn -EINVAL;\n\n\tif (nn->dp.rxd_cnt == rxd_cnt && nn->dp.txd_cnt == txd_cnt)\n\t\treturn 0;\n\n\tnn_dbg(nn, \"Change ring size: RxQ %u->%u, TxQ %u->%u\\n\",\n\t       nn->dp.rxd_cnt, rxd_cnt, nn->dp.txd_cnt, txd_cnt);\n\n\treturn nfp_net_set_ring_size(nn, rxd_cnt, txd_cnt);\n}\n\nstatic int nfp_test_link(struct net_device *netdev)\n{\n\tif (!netif_carrier_ok(netdev) || !(netdev->flags & IFF_UP))\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic int nfp_test_nsp(struct net_device *netdev)\n{\n\tstruct nfp_app *app = nfp_app_from_netdev(netdev);\n\tstruct nfp_nsp_identify *nspi;\n\tstruct nfp_nsp *nsp;\n\tint err;\n\n\tnsp = nfp_nsp_open(app->cpp);\n\tif (IS_ERR(nsp)) {\n\t\terr = PTR_ERR(nsp);\n\t\tnetdev_info(netdev, \"NSP Test: failed to access the NSP: %d\\n\", err);\n\t\tgoto exit;\n\t}\n\n\tif (nfp_nsp_get_abi_ver_minor(nsp) < 15) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto exit_close_nsp;\n\t}\n\n\tnspi = kzalloc(sizeof(*nspi), GFP_KERNEL);\n\tif (!nspi) {\n\t\terr = -ENOMEM;\n\t\tgoto exit_close_nsp;\n\t}\n\n\terr = nfp_nsp_read_identify(nsp, nspi, sizeof(*nspi));\n\tif (err < 0)\n\t\tnetdev_info(netdev, \"NSP Test: reading bsp version failed %d\\n\", err);\n\n\tkfree(nspi);\nexit_close_nsp:\n\tnfp_nsp_close(nsp);\nexit:\n\treturn err;\n}\n\nstatic int nfp_test_fw(struct net_device *netdev)\n{\n\tstruct nfp_net *nn = netdev_priv(netdev);\n\tint err;\n\n\terr = nfp_net_reconfig(nn, NFP_NET_CFG_UPDATE_GEN);\n\tif (err)\n\t\tnetdev_info(netdev, \"FW Test: update failed %d\\n\", err);\n\n\treturn err;\n}\n\nstatic int nfp_test_reg(struct net_device *netdev)\n{\n\tstruct nfp_app *app = nfp_app_from_netdev(netdev);\n\tstruct nfp_cpp *cpp = app->cpp;\n\tu32 model = nfp_cpp_model(cpp);\n\tu32 value;\n\tint err;\n\n\terr = nfp_cpp_model_autodetect(cpp, &value);\n\tif (err < 0) {\n\t\tnetdev_info(netdev, \"REG Test: NFP model detection failed %d\\n\", err);\n\t\treturn err;\n\t}\n\n\treturn (value == model) ? 0 : 1;\n}\n\nstatic bool link_test_supported(struct net_device *netdev)\n{\n\treturn true;\n}\n\nstatic bool nsp_test_supported(struct net_device *netdev)\n{\n\tif (nfp_app_from_netdev(netdev))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic bool fw_test_supported(struct net_device *netdev)\n{\n\tif (nfp_netdev_is_nfp_net(netdev))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic bool reg_test_supported(struct net_device *netdev)\n{\n\tif (nfp_app_from_netdev(netdev))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic struct nfp_self_test_item {\n\tchar name[ETH_GSTRING_LEN];\n\tbool (*is_supported)(struct net_device *dev);\n\tint (*func)(struct net_device *dev);\n} nfp_self_test[] = {\n\t{\"Link Test\", link_test_supported, nfp_test_link},\n\t{\"NSP Test\", nsp_test_supported, nfp_test_nsp},\n\t{\"Firmware Test\", fw_test_supported, nfp_test_fw},\n\t{\"Register Test\", reg_test_supported, nfp_test_reg}\n};\n\n#define NFP_TEST_TOTAL_NUM ARRAY_SIZE(nfp_self_test)\n\nstatic void nfp_get_self_test_strings(struct net_device *netdev, u8 *data)\n{\n\tint i;\n\n\tfor (i = 0; i < NFP_TEST_TOTAL_NUM; i++)\n\t\tif (nfp_self_test[i].is_supported(netdev))\n\t\t\tethtool_sprintf(&data, nfp_self_test[i].name);\n}\n\nstatic int nfp_get_self_test_count(struct net_device *netdev)\n{\n\tint i, count = 0;\n\n\tfor (i = 0; i < NFP_TEST_TOTAL_NUM; i++)\n\t\tif (nfp_self_test[i].is_supported(netdev))\n\t\t\tcount++;\n\n\treturn count;\n}\n\nstatic void nfp_net_self_test(struct net_device *netdev, struct ethtool_test *eth_test,\n\t\t\t      u64 *data)\n{\n\tint i, ret, count = 0;\n\n\tnetdev_info(netdev, \"Start self test\\n\");\n\n\tfor (i = 0; i < NFP_TEST_TOTAL_NUM; i++) {\n\t\tif (nfp_self_test[i].is_supported(netdev)) {\n\t\t\tret = nfp_self_test[i].func(netdev);\n\t\t\tif (ret)\n\t\t\t\teth_test->flags |= ETH_TEST_FL_FAILED;\n\t\t\tdata[count++] = ret;\n\t\t}\n\t}\n\n\tnetdev_info(netdev, \"Test end\\n\");\n}\n\nstatic unsigned int nfp_vnic_get_sw_stats_count(struct net_device *netdev)\n{\n\tstruct nfp_net *nn = netdev_priv(netdev);\n\n\treturn NN_RVEC_GATHER_STATS + nn->max_r_vecs * NN_RVEC_PER_Q_STATS +\n\t\tNN_CTRL_PATH_STATS;\n}\n\nstatic u8 *nfp_vnic_get_sw_stats_strings(struct net_device *netdev, u8 *data)\n{\n\tstruct nfp_net *nn = netdev_priv(netdev);\n\tint i;\n\n\tfor (i = 0; i < nn->max_r_vecs; i++) {\n\t\tethtool_sprintf(&data, \"rvec_%u_rx_pkts\", i);\n\t\tethtool_sprintf(&data, \"rvec_%u_tx_pkts\", i);\n\t\tethtool_sprintf(&data, \"rvec_%u_tx_busy\", i);\n\t}\n\n\tethtool_sprintf(&data, \"hw_rx_csum_ok\");\n\tethtool_sprintf(&data, \"hw_rx_csum_inner_ok\");\n\tethtool_sprintf(&data, \"hw_rx_csum_complete\");\n\tethtool_sprintf(&data, \"hw_rx_csum_err\");\n\tethtool_sprintf(&data, \"rx_replace_buf_alloc_fail\");\n\tethtool_sprintf(&data, \"rx_tls_decrypted_packets\");\n\tethtool_sprintf(&data, \"hw_tx_csum\");\n\tethtool_sprintf(&data, \"hw_tx_inner_csum\");\n\tethtool_sprintf(&data, \"tx_gather\");\n\tethtool_sprintf(&data, \"tx_lso\");\n\tethtool_sprintf(&data, \"tx_tls_encrypted_packets\");\n\tethtool_sprintf(&data, \"tx_tls_ooo\");\n\tethtool_sprintf(&data, \"tx_tls_drop_no_sync_data\");\n\n\tethtool_sprintf(&data, \"hw_tls_no_space\");\n\tethtool_sprintf(&data, \"rx_tls_resync_req_ok\");\n\tethtool_sprintf(&data, \"rx_tls_resync_req_ign\");\n\tethtool_sprintf(&data, \"rx_tls_resync_sent\");\n\n\treturn data;\n}\n\nstatic u64 *nfp_vnic_get_sw_stats(struct net_device *netdev, u64 *data)\n{\n\tu64 gathered_stats[NN_RVEC_GATHER_STATS] = {};\n\tstruct nfp_net *nn = netdev_priv(netdev);\n\tu64 tmp[NN_RVEC_GATHER_STATS];\n\tunsigned int i, j;\n\n\tfor (i = 0; i < nn->max_r_vecs; i++) {\n\t\tunsigned int start;\n\n\t\tdo {\n\t\t\tstart = u64_stats_fetch_begin(&nn->r_vecs[i].rx_sync);\n\t\t\tdata[0] = nn->r_vecs[i].rx_pkts;\n\t\t\ttmp[0] = nn->r_vecs[i].hw_csum_rx_ok;\n\t\t\ttmp[1] = nn->r_vecs[i].hw_csum_rx_inner_ok;\n\t\t\ttmp[2] = nn->r_vecs[i].hw_csum_rx_complete;\n\t\t\ttmp[3] = nn->r_vecs[i].hw_csum_rx_error;\n\t\t\ttmp[4] = nn->r_vecs[i].rx_replace_buf_alloc_fail;\n\t\t\ttmp[5] = nn->r_vecs[i].hw_tls_rx;\n\t\t} while (u64_stats_fetch_retry(&nn->r_vecs[i].rx_sync, start));\n\n\t\tdo {\n\t\t\tstart = u64_stats_fetch_begin(&nn->r_vecs[i].tx_sync);\n\t\t\tdata[1] = nn->r_vecs[i].tx_pkts;\n\t\t\tdata[2] = nn->r_vecs[i].tx_busy;\n\t\t\ttmp[6] = nn->r_vecs[i].hw_csum_tx;\n\t\t\ttmp[7] = nn->r_vecs[i].hw_csum_tx_inner;\n\t\t\ttmp[8] = nn->r_vecs[i].tx_gather;\n\t\t\ttmp[9] = nn->r_vecs[i].tx_lso;\n\t\t\ttmp[10] = nn->r_vecs[i].hw_tls_tx;\n\t\t\ttmp[11] = nn->r_vecs[i].tls_tx_fallback;\n\t\t\ttmp[12] = nn->r_vecs[i].tls_tx_no_fallback;\n\t\t} while (u64_stats_fetch_retry(&nn->r_vecs[i].tx_sync, start));\n\n\t\tdata += NN_RVEC_PER_Q_STATS;\n\n\t\tfor (j = 0; j < NN_RVEC_GATHER_STATS; j++)\n\t\t\tgathered_stats[j] += tmp[j];\n\t}\n\n\tfor (j = 0; j < NN_RVEC_GATHER_STATS; j++)\n\t\t*data++ = gathered_stats[j];\n\n\t*data++ = atomic_read(&nn->ktls_no_space);\n\t*data++ = atomic_read(&nn->ktls_rx_resync_req);\n\t*data++ = atomic_read(&nn->ktls_rx_resync_ign);\n\t*data++ = atomic_read(&nn->ktls_rx_resync_sent);\n\n\treturn data;\n}\n\nstatic unsigned int nfp_vnic_get_hw_stats_count(unsigned int num_vecs)\n{\n\treturn NN_ET_GLOBAL_STATS_LEN + num_vecs * 4;\n}\n\nstatic u8 *\nnfp_vnic_get_hw_stats_strings(u8 *data, unsigned int num_vecs, bool repr)\n{\n\tint swap_off, i;\n\n\tBUILD_BUG_ON(NN_ET_GLOBAL_STATS_LEN < NN_ET_SWITCH_STATS_LEN * 2);\n\t \n\tswap_off = repr * NN_ET_SWITCH_STATS_LEN;\n\n\tfor (i = 0; i < NN_ET_SWITCH_STATS_LEN; i++)\n\t\tethtool_sprintf(&data, nfp_net_et_stats[i + swap_off].name);\n\n\tfor (i = NN_ET_SWITCH_STATS_LEN; i < NN_ET_SWITCH_STATS_LEN * 2; i++)\n\t\tethtool_sprintf(&data, nfp_net_et_stats[i - swap_off].name);\n\n\tfor (i = NN_ET_SWITCH_STATS_LEN * 2; i < NN_ET_GLOBAL_STATS_LEN; i++)\n\t\tethtool_sprintf(&data, nfp_net_et_stats[i].name);\n\n\tfor (i = 0; i < num_vecs; i++) {\n\t\tethtool_sprintf(&data, \"rxq_%u_pkts\", i);\n\t\tethtool_sprintf(&data, \"rxq_%u_bytes\", i);\n\t\tethtool_sprintf(&data, \"txq_%u_pkts\", i);\n\t\tethtool_sprintf(&data, \"txq_%u_bytes\", i);\n\t}\n\n\treturn data;\n}\n\nstatic u64 *\nnfp_vnic_get_hw_stats(u64 *data, u8 __iomem *mem, unsigned int num_vecs)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < NN_ET_GLOBAL_STATS_LEN; i++)\n\t\t*data++ = readq(mem + nfp_net_et_stats[i].off);\n\n\tfor (i = 0; i < num_vecs; i++) {\n\t\t*data++ = readq(mem + NFP_NET_CFG_RXR_STATS(i));\n\t\t*data++ = readq(mem + NFP_NET_CFG_RXR_STATS(i) + 8);\n\t\t*data++ = readq(mem + NFP_NET_CFG_TXR_STATS(i));\n\t\t*data++ = readq(mem + NFP_NET_CFG_TXR_STATS(i) + 8);\n\t}\n\n\treturn data;\n}\n\nstatic unsigned int nfp_vnic_get_tlv_stats_count(struct nfp_net *nn)\n{\n\treturn nn->tlv_caps.vnic_stats_cnt + nn->max_r_vecs * 4;\n}\n\nstatic u8 *nfp_vnic_get_tlv_stats_strings(struct nfp_net *nn, u8 *data)\n{\n\tunsigned int i, id;\n\tu8 __iomem *mem;\n\tu64 id_word = 0;\n\n\tmem = nn->dp.ctrl_bar + nn->tlv_caps.vnic_stats_off;\n\tfor (i = 0; i < nn->tlv_caps.vnic_stats_cnt; i++) {\n\t\tif (!(i % 4))\n\t\t\tid_word = readq(mem + i * 2);\n\n\t\tid = (u16)id_word;\n\t\tid_word >>= 16;\n\n\t\tif (id < ARRAY_SIZE(nfp_tlv_stat_names) &&\n\t\t    nfp_tlv_stat_names[id][0]) {\n\t\t\tmemcpy(data, nfp_tlv_stat_names[id], ETH_GSTRING_LEN);\n\t\t\tdata += ETH_GSTRING_LEN;\n\t\t} else {\n\t\t\tethtool_sprintf(&data, \"dev_unknown_stat%u\", id);\n\t\t}\n\t}\n\n\tfor (i = 0; i < nn->max_r_vecs; i++) {\n\t\tethtool_sprintf(&data, \"rxq_%u_pkts\", i);\n\t\tethtool_sprintf(&data, \"rxq_%u_bytes\", i);\n\t\tethtool_sprintf(&data, \"txq_%u_pkts\", i);\n\t\tethtool_sprintf(&data, \"txq_%u_bytes\", i);\n\t}\n\n\treturn data;\n}\n\nstatic u64 *nfp_vnic_get_tlv_stats(struct nfp_net *nn, u64 *data)\n{\n\tu8 __iomem *mem;\n\tunsigned int i;\n\n\tmem = nn->dp.ctrl_bar + nn->tlv_caps.vnic_stats_off;\n\tmem += roundup(2 * nn->tlv_caps.vnic_stats_cnt, 8);\n\tfor (i = 0; i < nn->tlv_caps.vnic_stats_cnt; i++)\n\t\t*data++ = readq(mem + i * 8);\n\n\tmem = nn->dp.ctrl_bar;\n\tfor (i = 0; i < nn->max_r_vecs; i++) {\n\t\t*data++ = readq(mem + NFP_NET_CFG_RXR_STATS(i));\n\t\t*data++ = readq(mem + NFP_NET_CFG_RXR_STATS(i) + 8);\n\t\t*data++ = readq(mem + NFP_NET_CFG_TXR_STATS(i));\n\t\t*data++ = readq(mem + NFP_NET_CFG_TXR_STATS(i) + 8);\n\t}\n\n\treturn data;\n}\n\nstatic unsigned int nfp_mac_get_stats_count(struct net_device *netdev)\n{\n\tstruct nfp_port *port;\n\n\tport = nfp_port_from_netdev(netdev);\n\tif (!__nfp_port_get_eth_port(port) || !port->eth_stats)\n\t\treturn 0;\n\n\treturn ARRAY_SIZE(nfp_mac_et_stats);\n}\n\nstatic u8 *nfp_mac_get_stats_strings(struct net_device *netdev, u8 *data)\n{\n\tstruct nfp_port *port;\n\tunsigned int i;\n\n\tport = nfp_port_from_netdev(netdev);\n\tif (!__nfp_port_get_eth_port(port) || !port->eth_stats)\n\t\treturn data;\n\n\tfor (i = 0; i < ARRAY_SIZE(nfp_mac_et_stats); i++)\n\t\tethtool_sprintf(&data, \"mac.%s\", nfp_mac_et_stats[i].name);\n\n\treturn data;\n}\n\nstatic u64 *nfp_mac_get_stats(struct net_device *netdev, u64 *data)\n{\n\tstruct nfp_port *port;\n\tunsigned int i;\n\n\tport = nfp_port_from_netdev(netdev);\n\tif (!__nfp_port_get_eth_port(port) || !port->eth_stats)\n\t\treturn data;\n\n\tfor (i = 0; i < ARRAY_SIZE(nfp_mac_et_stats); i++)\n\t\t*data++ = readq(port->eth_stats + nfp_mac_et_stats[i].off);\n\n\treturn data;\n}\n\nstatic void nfp_net_get_strings(struct net_device *netdev,\n\t\t\t\tu32 stringset, u8 *data)\n{\n\tstruct nfp_net *nn = netdev_priv(netdev);\n\n\tswitch (stringset) {\n\tcase ETH_SS_STATS:\n\t\tdata = nfp_vnic_get_sw_stats_strings(netdev, data);\n\t\tif (!nn->tlv_caps.vnic_stats_off)\n\t\t\tdata = nfp_vnic_get_hw_stats_strings(data,\n\t\t\t\t\t\t\t     nn->max_r_vecs,\n\t\t\t\t\t\t\t     false);\n\t\telse\n\t\t\tdata = nfp_vnic_get_tlv_stats_strings(nn, data);\n\t\tdata = nfp_mac_get_stats_strings(netdev, data);\n\t\tdata = nfp_app_port_get_stats_strings(nn->port, data);\n\t\tbreak;\n\tcase ETH_SS_TEST:\n\t\tnfp_get_self_test_strings(netdev, data);\n\t\tbreak;\n\t}\n}\n\nstatic void\nnfp_net_get_stats(struct net_device *netdev, struct ethtool_stats *stats,\n\t\t  u64 *data)\n{\n\tstruct nfp_net *nn = netdev_priv(netdev);\n\n\tdata = nfp_vnic_get_sw_stats(netdev, data);\n\tif (!nn->tlv_caps.vnic_stats_off)\n\t\tdata = nfp_vnic_get_hw_stats(data, nn->dp.ctrl_bar,\n\t\t\t\t\t     nn->max_r_vecs);\n\telse\n\t\tdata = nfp_vnic_get_tlv_stats(nn, data);\n\tdata = nfp_mac_get_stats(netdev, data);\n\tdata = nfp_app_port_get_stats(nn->port, data);\n}\n\nstatic int nfp_net_get_sset_count(struct net_device *netdev, int sset)\n{\n\tstruct nfp_net *nn = netdev_priv(netdev);\n\tunsigned int cnt;\n\n\tswitch (sset) {\n\tcase ETH_SS_STATS:\n\t\tcnt = nfp_vnic_get_sw_stats_count(netdev);\n\t\tif (!nn->tlv_caps.vnic_stats_off)\n\t\t\tcnt += nfp_vnic_get_hw_stats_count(nn->max_r_vecs);\n\t\telse\n\t\t\tcnt += nfp_vnic_get_tlv_stats_count(nn);\n\t\tcnt += nfp_mac_get_stats_count(netdev);\n\t\tcnt += nfp_app_port_get_stats_count(nn->port);\n\t\treturn cnt;\n\tcase ETH_SS_TEST:\n\t\treturn nfp_get_self_test_count(netdev);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic void nfp_port_get_strings(struct net_device *netdev,\n\t\t\t\t u32 stringset, u8 *data)\n{\n\tstruct nfp_port *port = nfp_port_from_netdev(netdev);\n\n\tswitch (stringset) {\n\tcase ETH_SS_STATS:\n\t\tif (nfp_port_is_vnic(port))\n\t\t\tdata = nfp_vnic_get_hw_stats_strings(data, 0, true);\n\t\telse\n\t\t\tdata = nfp_mac_get_stats_strings(netdev, data);\n\t\tdata = nfp_app_port_get_stats_strings(port, data);\n\t\tbreak;\n\tcase ETH_SS_TEST:\n\t\tnfp_get_self_test_strings(netdev, data);\n\t\tbreak;\n\t}\n}\n\nstatic void\nnfp_port_get_stats(struct net_device *netdev, struct ethtool_stats *stats,\n\t\t   u64 *data)\n{\n\tstruct nfp_port *port = nfp_port_from_netdev(netdev);\n\n\tif (nfp_port_is_vnic(port))\n\t\tdata = nfp_vnic_get_hw_stats(data, port->vnic, 0);\n\telse\n\t\tdata = nfp_mac_get_stats(netdev, data);\n\tdata = nfp_app_port_get_stats(port, data);\n}\n\nstatic int nfp_port_get_sset_count(struct net_device *netdev, int sset)\n{\n\tstruct nfp_port *port = nfp_port_from_netdev(netdev);\n\tunsigned int count;\n\n\tswitch (sset) {\n\tcase ETH_SS_STATS:\n\t\tif (nfp_port_is_vnic(port))\n\t\t\tcount = nfp_vnic_get_hw_stats_count(0);\n\t\telse\n\t\t\tcount = nfp_mac_get_stats_count(netdev);\n\t\tcount += nfp_app_port_get_stats_count(port);\n\t\treturn count;\n\tcase ETH_SS_TEST:\n\t\treturn nfp_get_self_test_count(netdev);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int nfp_port_fec_ethtool_to_nsp(u32 fec)\n{\n\tswitch (fec) {\n\tcase ETHTOOL_FEC_AUTO:\n\t\treturn NFP_FEC_AUTO_BIT;\n\tcase ETHTOOL_FEC_OFF:\n\t\treturn NFP_FEC_DISABLED_BIT;\n\tcase ETHTOOL_FEC_RS:\n\t\treturn NFP_FEC_REED_SOLOMON_BIT;\n\tcase ETHTOOL_FEC_BASER:\n\t\treturn NFP_FEC_BASER_BIT;\n\tdefault:\n\t\t \n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic u32 nfp_port_fec_nsp_to_ethtool(u32 fec)\n{\n\tu32 result = 0;\n\n\tif (fec & NFP_FEC_AUTO)\n\t\tresult |= ETHTOOL_FEC_AUTO;\n\tif (fec & NFP_FEC_BASER)\n\t\tresult |= ETHTOOL_FEC_BASER;\n\tif (fec & NFP_FEC_REED_SOLOMON)\n\t\tresult |= ETHTOOL_FEC_RS;\n\tif (fec & NFP_FEC_DISABLED)\n\t\tresult |= ETHTOOL_FEC_OFF;\n\n\treturn result ?: ETHTOOL_FEC_NONE;\n}\n\nstatic int\nnfp_port_get_fecparam(struct net_device *netdev,\n\t\t      struct ethtool_fecparam *param)\n{\n\tstruct nfp_eth_table_port *eth_port;\n\tstruct nfp_port *port;\n\n\tparam->active_fec = ETHTOOL_FEC_NONE;\n\tparam->fec = ETHTOOL_FEC_NONE;\n\n\tport = nfp_port_from_netdev(netdev);\n\teth_port = nfp_port_get_eth_port(port);\n\tif (!eth_port)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!nfp_eth_can_support_fec(eth_port))\n\t\treturn 0;\n\n\tparam->fec = nfp_port_fec_nsp_to_ethtool(eth_port->fec_modes_supported);\n\tparam->active_fec = nfp_port_fec_nsp_to_ethtool(BIT(eth_port->act_fec));\n\n\treturn 0;\n}\n\nstatic int\nnfp_port_set_fecparam(struct net_device *netdev,\n\t\t      struct ethtool_fecparam *param)\n{\n\tstruct nfp_eth_table_port *eth_port;\n\tstruct nfp_port *port;\n\tint err, fec;\n\n\tport = nfp_port_from_netdev(netdev);\n\teth_port = nfp_port_get_eth_port(port);\n\tif (!eth_port)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!nfp_eth_can_support_fec(eth_port))\n\t\treturn -EOPNOTSUPP;\n\n\tfec = nfp_port_fec_ethtool_to_nsp(param->fec);\n\tif (fec < 0)\n\t\treturn fec;\n\n\terr = nfp_eth_set_fec(port->app->cpp, eth_port->index, fec);\n\tif (!err)\n\t\t \n\t\tnfp_net_refresh_port_table(port);\n\n\treturn err < 0 ? err : 0;\n}\n\n \nstatic u32 ethtool_flow_to_nfp_flag(u32 flow_type)\n{\n\tstatic const u32 xlate_ethtool_to_nfp[IPV6_FLOW + 1] = {\n\t\t[TCP_V4_FLOW]\t= NFP_NET_CFG_RSS_IPV4_TCP,\n\t\t[TCP_V6_FLOW]\t= NFP_NET_CFG_RSS_IPV6_TCP,\n\t\t[UDP_V4_FLOW]\t= NFP_NET_CFG_RSS_IPV4_UDP,\n\t\t[UDP_V6_FLOW]\t= NFP_NET_CFG_RSS_IPV6_UDP,\n\t\t[IPV4_FLOW]\t= NFP_NET_CFG_RSS_IPV4,\n\t\t[IPV6_FLOW]\t= NFP_NET_CFG_RSS_IPV6,\n\t};\n\n\tif (flow_type >= ARRAY_SIZE(xlate_ethtool_to_nfp))\n\t\treturn 0;\n\n\treturn xlate_ethtool_to_nfp[flow_type];\n}\n\nstatic int nfp_net_get_rss_hash_opts(struct nfp_net *nn,\n\t\t\t\t     struct ethtool_rxnfc *cmd)\n{\n\tu32 nfp_rss_flag;\n\n\tcmd->data = 0;\n\n\tif (!(nn->cap & NFP_NET_CFG_CTRL_RSS_ANY))\n\t\treturn -EOPNOTSUPP;\n\n\tnfp_rss_flag = ethtool_flow_to_nfp_flag(cmd->flow_type);\n\tif (!nfp_rss_flag)\n\t\treturn -EINVAL;\n\n\tcmd->data |= RXH_IP_SRC | RXH_IP_DST;\n\tif (nn->rss_cfg & nfp_rss_flag)\n\t\tcmd->data |= RXH_L4_B_0_1 | RXH_L4_B_2_3;\n\n\treturn 0;\n}\n\nstatic int nfp_net_get_rxnfc(struct net_device *netdev,\n\t\t\t     struct ethtool_rxnfc *cmd, u32 *rule_locs)\n{\n\tstruct nfp_net *nn = netdev_priv(netdev);\n\n\tswitch (cmd->cmd) {\n\tcase ETHTOOL_GRXRINGS:\n\t\tcmd->data = nn->dp.num_rx_rings;\n\t\treturn 0;\n\tcase ETHTOOL_GRXFH:\n\t\treturn nfp_net_get_rss_hash_opts(nn, cmd);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int nfp_net_set_rss_hash_opt(struct nfp_net *nn,\n\t\t\t\t    struct ethtool_rxnfc *nfc)\n{\n\tu32 new_rss_cfg = nn->rss_cfg;\n\tu32 nfp_rss_flag;\n\tint err;\n\n\tif (!(nn->cap & NFP_NET_CFG_CTRL_RSS_ANY))\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tif (nfc->data & ~(RXH_IP_SRC | RXH_IP_DST |\n\t\t\t  RXH_L4_B_0_1 | RXH_L4_B_2_3))\n\t\treturn -EINVAL;\n\n\t \n\tif (!(nfc->data & RXH_IP_SRC) ||\n\t    !(nfc->data & RXH_IP_DST))\n\t\treturn -EINVAL;\n\n\tnfp_rss_flag = ethtool_flow_to_nfp_flag(nfc->flow_type);\n\tif (!nfp_rss_flag)\n\t\treturn -EINVAL;\n\n\tswitch (nfc->data & (RXH_L4_B_0_1 | RXH_L4_B_2_3)) {\n\tcase 0:\n\t\tnew_rss_cfg &= ~nfp_rss_flag;\n\t\tbreak;\n\tcase (RXH_L4_B_0_1 | RXH_L4_B_2_3):\n\t\tnew_rss_cfg |= nfp_rss_flag;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tnew_rss_cfg |= FIELD_PREP(NFP_NET_CFG_RSS_HFUNC, nn->rss_hfunc);\n\tnew_rss_cfg |= NFP_NET_CFG_RSS_MASK;\n\n\tif (new_rss_cfg == nn->rss_cfg)\n\t\treturn 0;\n\n\twritel(new_rss_cfg, nn->dp.ctrl_bar + NFP_NET_CFG_RSS_CTRL);\n\terr = nfp_net_reconfig(nn, NFP_NET_CFG_UPDATE_RSS);\n\tif (err)\n\t\treturn err;\n\n\tnn->rss_cfg = new_rss_cfg;\n\n\tnn_dbg(nn, \"Changed RSS config to 0x%x\\n\", nn->rss_cfg);\n\treturn 0;\n}\n\nstatic int nfp_net_set_rxnfc(struct net_device *netdev,\n\t\t\t     struct ethtool_rxnfc *cmd)\n{\n\tstruct nfp_net *nn = netdev_priv(netdev);\n\n\tswitch (cmd->cmd) {\n\tcase ETHTOOL_SRXFH:\n\t\treturn nfp_net_set_rss_hash_opt(nn, cmd);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic u32 nfp_net_get_rxfh_indir_size(struct net_device *netdev)\n{\n\tstruct nfp_net *nn = netdev_priv(netdev);\n\n\tif (!(nn->cap & NFP_NET_CFG_CTRL_RSS_ANY))\n\t\treturn 0;\n\n\treturn ARRAY_SIZE(nn->rss_itbl);\n}\n\nstatic u32 nfp_net_get_rxfh_key_size(struct net_device *netdev)\n{\n\tstruct nfp_net *nn = netdev_priv(netdev);\n\n\tif (!(nn->cap & NFP_NET_CFG_CTRL_RSS_ANY))\n\t\treturn -EOPNOTSUPP;\n\n\treturn nfp_net_rss_key_sz(nn);\n}\n\nstatic int nfp_net_get_rxfh(struct net_device *netdev, u32 *indir, u8 *key,\n\t\t\t    u8 *hfunc)\n{\n\tstruct nfp_net *nn = netdev_priv(netdev);\n\tint i;\n\n\tif (!(nn->cap & NFP_NET_CFG_CTRL_RSS_ANY))\n\t\treturn -EOPNOTSUPP;\n\n\tif (indir)\n\t\tfor (i = 0; i < ARRAY_SIZE(nn->rss_itbl); i++)\n\t\t\tindir[i] = nn->rss_itbl[i];\n\tif (key)\n\t\tmemcpy(key, nn->rss_key, nfp_net_rss_key_sz(nn));\n\tif (hfunc) {\n\t\t*hfunc = nn->rss_hfunc;\n\t\tif (*hfunc >= 1 << ETH_RSS_HASH_FUNCS_COUNT)\n\t\t\t*hfunc = ETH_RSS_HASH_UNKNOWN;\n\t}\n\n\treturn 0;\n}\n\nstatic int nfp_net_set_rxfh(struct net_device *netdev,\n\t\t\t    const u32 *indir, const u8 *key,\n\t\t\t    const u8 hfunc)\n{\n\tstruct nfp_net *nn = netdev_priv(netdev);\n\tint i;\n\n\tif (!(nn->cap & NFP_NET_CFG_CTRL_RSS_ANY) ||\n\t    !(hfunc == ETH_RSS_HASH_NO_CHANGE || hfunc == nn->rss_hfunc))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!key && !indir)\n\t\treturn 0;\n\n\tif (key) {\n\t\tmemcpy(nn->rss_key, key, nfp_net_rss_key_sz(nn));\n\t\tnfp_net_rss_write_key(nn);\n\t}\n\tif (indir) {\n\t\tfor (i = 0; i < ARRAY_SIZE(nn->rss_itbl); i++)\n\t\t\tnn->rss_itbl[i] = indir[i];\n\n\t\tnfp_net_rss_write_itbl(nn);\n\t}\n\n\treturn nfp_net_reconfig(nn, NFP_NET_CFG_UPDATE_RSS);\n}\n\n \nstatic int nfp_net_get_regs_len(struct net_device *netdev)\n{\n\treturn NFP_NET_CFG_BAR_SZ;\n}\n\nstatic void nfp_net_get_regs(struct net_device *netdev,\n\t\t\t     struct ethtool_regs *regs, void *p)\n{\n\tstruct nfp_net *nn = netdev_priv(netdev);\n\tu32 *regs_buf = p;\n\tint i;\n\n\tregs->version = nn_readl(nn, NFP_NET_CFG_VERSION);\n\n\tfor (i = 0; i < NFP_NET_CFG_BAR_SZ / sizeof(u32); i++)\n\t\tregs_buf[i] = readl(nn->dp.ctrl_bar + (i * sizeof(u32)));\n}\n\nstatic int nfp_net_get_coalesce(struct net_device *netdev,\n\t\t\t\tstruct ethtool_coalesce *ec,\n\t\t\t\tstruct kernel_ethtool_coalesce *kernel_coal,\n\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct nfp_net *nn = netdev_priv(netdev);\n\n\tif (!(nn->cap & NFP_NET_CFG_CTRL_IRQMOD))\n\t\treturn -EINVAL;\n\n\tec->use_adaptive_rx_coalesce = nn->rx_coalesce_adapt_on;\n\tec->use_adaptive_tx_coalesce = nn->tx_coalesce_adapt_on;\n\n\tec->rx_coalesce_usecs       = nn->rx_coalesce_usecs;\n\tec->rx_max_coalesced_frames = nn->rx_coalesce_max_frames;\n\tec->tx_coalesce_usecs       = nn->tx_coalesce_usecs;\n\tec->tx_max_coalesced_frames = nn->tx_coalesce_max_frames;\n\n\treturn 0;\n}\n\n \nstatic int\nnfp_dump_nsp_diag(struct nfp_app *app, struct ethtool_dump *dump, void *buffer)\n{\n\tstruct nfp_resource *res;\n\tint ret;\n\n\tif (!app)\n\t\treturn -EOPNOTSUPP;\n\n\tdump->version = 1;\n\tdump->flag = NFP_DUMP_NSP_DIAG;\n\n\tres = nfp_resource_acquire(app->cpp, NFP_RESOURCE_NSP_DIAG);\n\tif (IS_ERR(res))\n\t\treturn PTR_ERR(res);\n\n\tif (buffer) {\n\t\tif (dump->len != nfp_resource_size(res)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto exit_release;\n\t\t}\n\n\t\tret = nfp_cpp_read(app->cpp, nfp_resource_cpp_id(res),\n\t\t\t\t   nfp_resource_address(res),\n\t\t\t\t   buffer, dump->len);\n\t\tif (ret != dump->len)\n\t\t\tret = ret < 0 ? ret : -EIO;\n\t\telse\n\t\t\tret = 0;\n\t} else {\n\t\tdump->len = nfp_resource_size(res);\n\t\tret = 0;\n\t}\nexit_release:\n\tnfp_resource_release(res);\n\n\treturn ret;\n}\n\n \nstatic int nfp_app_set_dump(struct net_device *netdev, struct ethtool_dump *val)\n{\n\tstruct nfp_app *app = nfp_app_from_netdev(netdev);\n\ts64 len;\n\n\tif (!app)\n\t\treturn -EOPNOTSUPP;\n\n\tif (val->flag == NFP_DUMP_NSP_DIAG) {\n\t\tapp->pf->dump_flag = val->flag;\n\t\treturn 0;\n\t}\n\n\tif (!app->pf->dumpspec)\n\t\treturn -EOPNOTSUPP;\n\n\tlen = nfp_net_dump_calculate_size(app->pf, app->pf->dumpspec,\n\t\t\t\t\t  val->flag);\n\tif (len < 0)\n\t\treturn len;\n\n\tapp->pf->dump_flag = val->flag;\n\tapp->pf->dump_len = len;\n\n\treturn 0;\n}\n\nstatic int\nnfp_app_get_dump_flag(struct net_device *netdev, struct ethtool_dump *dump)\n{\n\tstruct nfp_app *app = nfp_app_from_netdev(netdev);\n\n\tif (!app)\n\t\treturn -EOPNOTSUPP;\n\n\tif (app->pf->dump_flag == NFP_DUMP_NSP_DIAG)\n\t\treturn nfp_dump_nsp_diag(app, dump, NULL);\n\n\tdump->flag = app->pf->dump_flag;\n\tdump->len = app->pf->dump_len;\n\n\treturn 0;\n}\n\nstatic int\nnfp_app_get_dump_data(struct net_device *netdev, struct ethtool_dump *dump,\n\t\t      void *buffer)\n{\n\tstruct nfp_app *app = nfp_app_from_netdev(netdev);\n\n\tif (!app)\n\t\treturn -EOPNOTSUPP;\n\n\tif (app->pf->dump_flag == NFP_DUMP_NSP_DIAG)\n\t\treturn nfp_dump_nsp_diag(app, dump, buffer);\n\n\tdump->flag = app->pf->dump_flag;\n\tdump->len = app->pf->dump_len;\n\n\treturn nfp_net_dump_populate_buffer(app->pf, app->pf->dumpspec, dump,\n\t\t\t\t\t    buffer);\n}\n\nstatic int\nnfp_port_get_module_info(struct net_device *netdev,\n\t\t\t struct ethtool_modinfo *modinfo)\n{\n\tstruct nfp_eth_table_port *eth_port;\n\tstruct nfp_port *port;\n\tunsigned int read_len;\n\tstruct nfp_nsp *nsp;\n\tint err = 0;\n\tu8 data;\n\n\tport = nfp_port_from_netdev(netdev);\n\tif (!port)\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tset_bit(NFP_PORT_CHANGED, &port->flags);\n\teth_port = nfp_port_get_eth_port(port);\n\tif (!eth_port)\n\t\treturn -EOPNOTSUPP;\n\n\tnsp = nfp_nsp_open(port->app->cpp);\n\tif (IS_ERR(nsp)) {\n\t\terr = PTR_ERR(nsp);\n\t\tnetdev_err(netdev, \"Failed to access the NSP: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tif (!nfp_nsp_has_read_module_eeprom(nsp)) {\n\t\tnetdev_info(netdev, \"reading module EEPROM not supported. Please update flash\\n\");\n\t\terr = -EOPNOTSUPP;\n\t\tgoto exit_close_nsp;\n\t}\n\n\tswitch (eth_port->interface) {\n\tcase NFP_INTERFACE_SFP:\n\tcase NFP_INTERFACE_SFP28:\n\t\terr = nfp_nsp_read_module_eeprom(nsp, eth_port->eth_index,\n\t\t\t\t\t\t SFP_SFF8472_COMPLIANCE, &data,\n\t\t\t\t\t\t 1, &read_len);\n\t\tif (err < 0)\n\t\t\tgoto exit_close_nsp;\n\n\t\tif (!data) {\n\t\t\tmodinfo->type = ETH_MODULE_SFF_8079;\n\t\t\tmodinfo->eeprom_len = ETH_MODULE_SFF_8079_LEN;\n\t\t} else {\n\t\t\tmodinfo->type = ETH_MODULE_SFF_8472;\n\t\t\tmodinfo->eeprom_len = ETH_MODULE_SFF_8472_LEN;\n\t\t}\n\t\tbreak;\n\tcase NFP_INTERFACE_QSFP:\n\t\terr = nfp_nsp_read_module_eeprom(nsp, eth_port->eth_index,\n\t\t\t\t\t\t SFP_SFF_REV_COMPLIANCE, &data,\n\t\t\t\t\t\t 1, &read_len);\n\t\tif (err < 0)\n\t\t\tgoto exit_close_nsp;\n\n\t\tif (data < 0x3) {\n\t\t\tmodinfo->type = ETH_MODULE_SFF_8436;\n\t\t\tmodinfo->eeprom_len = ETH_MODULE_SFF_8436_MAX_LEN;\n\t\t} else {\n\t\t\tmodinfo->type = ETH_MODULE_SFF_8636;\n\t\t\tmodinfo->eeprom_len = ETH_MODULE_SFF_8636_MAX_LEN;\n\t\t}\n\t\tbreak;\n\tcase NFP_INTERFACE_QSFP28:\n\t\tmodinfo->type = ETH_MODULE_SFF_8636;\n\t\tmodinfo->eeprom_len = ETH_MODULE_SFF_8636_MAX_LEN;\n\t\tbreak;\n\tdefault:\n\t\tnetdev_err(netdev, \"Unsupported module 0x%x detected\\n\",\n\t\t\t   eth_port->interface);\n\t\terr = -EINVAL;\n\t}\n\nexit_close_nsp:\n\tnfp_nsp_close(nsp);\n\treturn err;\n}\n\nstatic int\nnfp_port_get_module_eeprom(struct net_device *netdev,\n\t\t\t   struct ethtool_eeprom *eeprom, u8 *data)\n{\n\tstruct nfp_eth_table_port *eth_port;\n\tstruct nfp_port *port;\n\tstruct nfp_nsp *nsp;\n\tint err;\n\n\tport = nfp_port_from_netdev(netdev);\n\teth_port = __nfp_port_get_eth_port(port);\n\tif (!eth_port)\n\t\treturn -EOPNOTSUPP;\n\n\tnsp = nfp_nsp_open(port->app->cpp);\n\tif (IS_ERR(nsp)) {\n\t\terr = PTR_ERR(nsp);\n\t\tnetdev_err(netdev, \"Failed to access the NSP: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tif (!nfp_nsp_has_read_module_eeprom(nsp)) {\n\t\tnetdev_info(netdev, \"reading module EEPROM not supported. Please update flash\\n\");\n\t\terr = -EOPNOTSUPP;\n\t\tgoto exit_close_nsp;\n\t}\n\n\terr = nfp_nsp_read_module_eeprom(nsp, eth_port->eth_index,\n\t\t\t\t\t eeprom->offset, data, eeprom->len,\n\t\t\t\t\t &eeprom->len);\n\tif (err < 0) {\n\t\tif (eeprom->len) {\n\t\t\tnetdev_warn(netdev,\n\t\t\t\t    \"Incomplete read from module EEPROM: %d\\n\",\n\t\t\t\t     err);\n\t\t\terr = 0;\n\t\t} else {\n\t\t\tnetdev_err(netdev,\n\t\t\t\t   \"Reading from module EEPROM failed: %d\\n\",\n\t\t\t\t   err);\n\t\t}\n\t}\n\nexit_close_nsp:\n\tnfp_nsp_close(nsp);\n\treturn err;\n}\n\nstatic int nfp_net_set_coalesce(struct net_device *netdev,\n\t\t\t\tstruct ethtool_coalesce *ec,\n\t\t\t\tstruct kernel_ethtool_coalesce *kernel_coal,\n\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct nfp_net *nn = netdev_priv(netdev);\n\tunsigned int factor;\n\n\t \n\tfactor = nn->tlv_caps.me_freq_mhz / 16;\n\n\t \n\n\tif (!(nn->cap & NFP_NET_CFG_CTRL_IRQMOD))\n\t\treturn -EINVAL;\n\n\t \n\tif (!ec->rx_coalesce_usecs && !ec->rx_max_coalesced_frames)\n\t\treturn -EINVAL;\n\n\tif (!ec->tx_coalesce_usecs && !ec->tx_max_coalesced_frames)\n\t\treturn -EINVAL;\n\n\tif (nfp_net_coalesce_para_check(ec->rx_coalesce_usecs * factor,\n\t\t\t\t\tec->rx_max_coalesced_frames))\n\t\treturn -EINVAL;\n\n\tif (nfp_net_coalesce_para_check(ec->tx_coalesce_usecs * factor,\n\t\t\t\t\tec->tx_max_coalesced_frames))\n\t\treturn -EINVAL;\n\n\t \n\tnn->rx_coalesce_adapt_on = !!ec->use_adaptive_rx_coalesce;\n\tnn->tx_coalesce_adapt_on = !!ec->use_adaptive_tx_coalesce;\n\n\tnn->rx_coalesce_usecs      = ec->rx_coalesce_usecs;\n\tnn->rx_coalesce_max_frames = ec->rx_max_coalesced_frames;\n\tnn->tx_coalesce_usecs      = ec->tx_coalesce_usecs;\n\tnn->tx_coalesce_max_frames = ec->tx_max_coalesced_frames;\n\n\t \n\tnfp_net_coalesce_write_cfg(nn);\n\treturn nfp_net_reconfig(nn, NFP_NET_CFG_UPDATE_IRQMOD);\n}\n\nstatic void nfp_net_get_channels(struct net_device *netdev,\n\t\t\t\t struct ethtool_channels *channel)\n{\n\tstruct nfp_net *nn = netdev_priv(netdev);\n\tunsigned int num_tx_rings;\n\n\tnum_tx_rings = nn->dp.num_tx_rings;\n\tif (nn->dp.xdp_prog)\n\t\tnum_tx_rings -= nn->dp.num_rx_rings;\n\n\tchannel->max_rx = min(nn->max_rx_rings, nn->max_r_vecs);\n\tchannel->max_tx = min(nn->max_tx_rings, nn->max_r_vecs);\n\tchannel->max_combined = min(channel->max_rx, channel->max_tx);\n\tchannel->max_other = NFP_NET_NON_Q_VECTORS;\n\tchannel->combined_count = min(nn->dp.num_rx_rings, num_tx_rings);\n\tchannel->rx_count = nn->dp.num_rx_rings - channel->combined_count;\n\tchannel->tx_count = num_tx_rings - channel->combined_count;\n\tchannel->other_count = NFP_NET_NON_Q_VECTORS;\n}\n\nstatic int nfp_net_set_num_rings(struct nfp_net *nn, unsigned int total_rx,\n\t\t\t\t unsigned int total_tx)\n{\n\tstruct nfp_net_dp *dp;\n\n\tdp = nfp_net_clone_dp(nn);\n\tif (!dp)\n\t\treturn -ENOMEM;\n\n\tdp->num_rx_rings = total_rx;\n\tdp->num_tx_rings = total_tx;\n\t \n\tif (dp->xdp_prog)\n\t\tdp->num_tx_rings += total_rx;\n\n\treturn nfp_net_ring_reconfig(nn, dp, NULL);\n}\n\nstatic int nfp_net_set_channels(struct net_device *netdev,\n\t\t\t\tstruct ethtool_channels *channel)\n{\n\tstruct nfp_net *nn = netdev_priv(netdev);\n\tunsigned int total_rx, total_tx;\n\n\t \n\tif (channel->other_count != NFP_NET_NON_Q_VECTORS ||\n\t    (channel->rx_count && channel->tx_count))\n\t\treturn -EINVAL;\n\n\ttotal_rx = channel->combined_count + channel->rx_count;\n\ttotal_tx = channel->combined_count + channel->tx_count;\n\n\tif (total_rx > min(nn->max_rx_rings, nn->max_r_vecs) ||\n\t    total_tx > min(nn->max_tx_rings, nn->max_r_vecs))\n\t\treturn -EINVAL;\n\n\treturn nfp_net_set_num_rings(nn, total_rx, total_tx);\n}\n\nstatic void nfp_port_get_pauseparam(struct net_device *netdev,\n\t\t\t\t    struct ethtool_pauseparam *pause)\n{\n\tstruct nfp_eth_table_port *eth_port;\n\tstruct nfp_port *port;\n\n\tport = nfp_port_from_netdev(netdev);\n\teth_port = nfp_port_get_eth_port(port);\n\tif (!eth_port)\n\t\treturn;\n\n\t \n\tpause->autoneg = AUTONEG_DISABLE;\n\tpause->rx_pause = 1;\n\tpause->tx_pause = 1;\n}\n\nstatic int nfp_net_set_phys_id(struct net_device *netdev,\n\t\t\t       enum ethtool_phys_id_state state)\n{\n\tstruct nfp_eth_table_port *eth_port;\n\tstruct nfp_port *port;\n\tint err;\n\n\tport = nfp_port_from_netdev(netdev);\n\teth_port = __nfp_port_get_eth_port(port);\n\tif (!eth_port)\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (state) {\n\tcase ETHTOOL_ID_ACTIVE:\n\t\t \n\t\terr = nfp_eth_set_idmode(port->app->cpp, eth_port->index, 1);\n\t\tbreak;\n\n\tcase ETHTOOL_ID_INACTIVE:\n\t\t \n\t\terr = nfp_eth_set_idmode(port->app->cpp, eth_port->index, 0);\n\t\tbreak;\n\n\tcase ETHTOOL_ID_ON:\n\tcase ETHTOOL_ID_OFF:\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn err;\n}\n\n#define NFP_EEPROM_LEN ETH_ALEN\n\nstatic int\nnfp_net_get_eeprom_len(struct net_device *netdev)\n{\n\tstruct nfp_eth_table_port *eth_port;\n\tstruct nfp_port *port;\n\n\tport = nfp_port_from_netdev(netdev);\n\teth_port = __nfp_port_get_eth_port(port);\n\tif (!eth_port)\n\t\treturn 0;\n\n\treturn NFP_EEPROM_LEN;\n}\n\nstatic int\nnfp_net_get_nsp_hwindex(struct net_device *netdev,\n\t\t\tstruct nfp_nsp **nspptr,\n\t\t\tu32 *index)\n{\n\tstruct nfp_eth_table_port *eth_port;\n\tstruct nfp_port *port;\n\tstruct nfp_nsp *nsp;\n\tint err;\n\n\tport = nfp_port_from_netdev(netdev);\n\teth_port = __nfp_port_get_eth_port(port);\n\tif (!eth_port)\n\t\treturn -EOPNOTSUPP;\n\n\tnsp = nfp_nsp_open(port->app->cpp);\n\tif (IS_ERR(nsp)) {\n\t\terr = PTR_ERR(nsp);\n\t\tnetdev_err(netdev, \"Failed to access the NSP: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tif (!nfp_nsp_has_hwinfo_lookup(nsp)) {\n\t\tnetdev_err(netdev, \"NSP doesn't support PF MAC generation\\n\");\n\t\tnfp_nsp_close(nsp);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t*nspptr = nsp;\n\t*index = eth_port->eth_index;\n\n\treturn 0;\n}\n\nstatic int\nnfp_net_get_port_mac_by_hwinfo(struct net_device *netdev,\n\t\t\t       u8 *mac_addr)\n{\n\tchar hwinfo[32] = {};\n\tstruct nfp_nsp *nsp;\n\tu32 index;\n\tint err;\n\n\terr = nfp_net_get_nsp_hwindex(netdev, &nsp, &index);\n\tif (err)\n\t\treturn err;\n\n\tsnprintf(hwinfo, sizeof(hwinfo), \"eth%u.mac\", index);\n\terr = nfp_nsp_hwinfo_lookup(nsp, hwinfo, sizeof(hwinfo));\n\tnfp_nsp_close(nsp);\n\tif (err) {\n\t\tnetdev_err(netdev, \"Reading persistent MAC address failed: %d\\n\",\n\t\t\t   err);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (sscanf(hwinfo, \"%02hhx:%02hhx:%02hhx:%02hhx:%02hhx:%02hhx\",\n\t\t   &mac_addr[0], &mac_addr[1], &mac_addr[2],\n\t\t   &mac_addr[3], &mac_addr[4], &mac_addr[5]) != 6) {\n\t\tnetdev_err(netdev, \"Can't parse persistent MAC address (%s)\\n\",\n\t\t\t   hwinfo);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nnfp_net_set_port_mac_by_hwinfo(struct net_device *netdev,\n\t\t\t       u8 *mac_addr)\n{\n\tchar hwinfo[32] = {};\n\tstruct nfp_nsp *nsp;\n\tu32 index;\n\tint err;\n\n\terr = nfp_net_get_nsp_hwindex(netdev, &nsp, &index);\n\tif (err)\n\t\treturn err;\n\n\tsnprintf(hwinfo, sizeof(hwinfo),\n\t\t \"eth%u.mac=%02hhx:%02hhx:%02hhx:%02hhx:%02hhx:%02hhx\",\n\t\t index, mac_addr[0], mac_addr[1], mac_addr[2], mac_addr[3],\n\t\t mac_addr[4], mac_addr[5]);\n\n\terr = nfp_nsp_hwinfo_set(nsp, hwinfo, sizeof(hwinfo));\n\tnfp_nsp_close(nsp);\n\tif (err) {\n\t\tnetdev_err(netdev, \"HWinfo set failed: %d, hwinfo: %s\\n\",\n\t\t\t   err, hwinfo);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nnfp_net_get_eeprom(struct net_device *netdev,\n\t\t   struct ethtool_eeprom *eeprom, u8 *bytes)\n{\n\tstruct nfp_app *app = nfp_app_from_netdev(netdev);\n\tu8 buf[NFP_EEPROM_LEN] = {};\n\n\tif (nfp_net_get_port_mac_by_hwinfo(netdev, buf))\n\t\treturn -EOPNOTSUPP;\n\n\tif (eeprom->len == 0)\n\t\treturn -EINVAL;\n\n\teeprom->magic = app->pdev->vendor | (app->pdev->device << 16);\n\tmemcpy(bytes, buf + eeprom->offset, eeprom->len);\n\n\treturn 0;\n}\n\nstatic int\nnfp_net_set_eeprom(struct net_device *netdev,\n\t\t   struct ethtool_eeprom *eeprom, u8 *bytes)\n{\n\tstruct nfp_app *app = nfp_app_from_netdev(netdev);\n\tu8 buf[NFP_EEPROM_LEN] = {};\n\n\tif (nfp_net_get_port_mac_by_hwinfo(netdev, buf))\n\t\treturn -EOPNOTSUPP;\n\n\tif (eeprom->len == 0)\n\t\treturn -EINVAL;\n\n\tif (eeprom->magic != (app->pdev->vendor | app->pdev->device << 16))\n\t\treturn -EINVAL;\n\n\tmemcpy(buf + eeprom->offset, bytes, eeprom->len);\n\tif (nfp_net_set_port_mac_by_hwinfo(netdev, buf))\n\t\treturn -EOPNOTSUPP;\n\n\treturn 0;\n}\n\nstatic const struct ethtool_ops nfp_net_ethtool_ops = {\n\t.supported_coalesce_params = ETHTOOL_COALESCE_USECS |\n\t\t\t\t     ETHTOOL_COALESCE_MAX_FRAMES |\n\t\t\t\t     ETHTOOL_COALESCE_USE_ADAPTIVE,\n\t.get_drvinfo\t\t= nfp_net_get_drvinfo,\n\t.nway_reset             = nfp_net_nway_reset,\n\t.get_link\t\t= ethtool_op_get_link,\n\t.get_ringparam\t\t= nfp_net_get_ringparam,\n\t.set_ringparam\t\t= nfp_net_set_ringparam,\n\t.self_test\t\t= nfp_net_self_test,\n\t.get_strings\t\t= nfp_net_get_strings,\n\t.get_ethtool_stats\t= nfp_net_get_stats,\n\t.get_sset_count\t\t= nfp_net_get_sset_count,\n\t.get_rxnfc\t\t= nfp_net_get_rxnfc,\n\t.set_rxnfc\t\t= nfp_net_set_rxnfc,\n\t.get_rxfh_indir_size\t= nfp_net_get_rxfh_indir_size,\n\t.get_rxfh_key_size\t= nfp_net_get_rxfh_key_size,\n\t.get_rxfh\t\t= nfp_net_get_rxfh,\n\t.set_rxfh\t\t= nfp_net_set_rxfh,\n\t.get_regs_len\t\t= nfp_net_get_regs_len,\n\t.get_regs\t\t= nfp_net_get_regs,\n\t.set_dump\t\t= nfp_app_set_dump,\n\t.get_dump_flag\t\t= nfp_app_get_dump_flag,\n\t.get_dump_data\t\t= nfp_app_get_dump_data,\n\t.get_eeprom_len         = nfp_net_get_eeprom_len,\n\t.get_eeprom             = nfp_net_get_eeprom,\n\t.set_eeprom             = nfp_net_set_eeprom,\n\t.get_module_info\t= nfp_port_get_module_info,\n\t.get_module_eeprom\t= nfp_port_get_module_eeprom,\n\t.get_coalesce           = nfp_net_get_coalesce,\n\t.set_coalesce           = nfp_net_set_coalesce,\n\t.get_channels\t\t= nfp_net_get_channels,\n\t.set_channels\t\t= nfp_net_set_channels,\n\t.get_link_ksettings\t= nfp_net_get_link_ksettings,\n\t.set_link_ksettings\t= nfp_net_set_link_ksettings,\n\t.get_fecparam\t\t= nfp_port_get_fecparam,\n\t.set_fecparam\t\t= nfp_port_set_fecparam,\n\t.get_pauseparam\t\t= nfp_port_get_pauseparam,\n\t.set_phys_id\t\t= nfp_net_set_phys_id,\n};\n\nconst struct ethtool_ops nfp_port_ethtool_ops = {\n\t.get_drvinfo\t\t= nfp_app_get_drvinfo,\n\t.nway_reset             = nfp_net_nway_reset,\n\t.get_link\t\t= ethtool_op_get_link,\n\t.get_strings\t\t= nfp_port_get_strings,\n\t.get_ethtool_stats\t= nfp_port_get_stats,\n\t.self_test\t\t= nfp_net_self_test,\n\t.get_sset_count\t\t= nfp_port_get_sset_count,\n\t.set_dump\t\t= nfp_app_set_dump,\n\t.get_dump_flag\t\t= nfp_app_get_dump_flag,\n\t.get_dump_data\t\t= nfp_app_get_dump_data,\n\t.get_eeprom_len         = nfp_net_get_eeprom_len,\n\t.get_eeprom             = nfp_net_get_eeprom,\n\t.set_eeprom             = nfp_net_set_eeprom,\n\t.get_module_info\t= nfp_port_get_module_info,\n\t.get_module_eeprom\t= nfp_port_get_module_eeprom,\n\t.get_link_ksettings\t= nfp_net_get_link_ksettings,\n\t.set_link_ksettings\t= nfp_net_set_link_ksettings,\n\t.get_fecparam\t\t= nfp_port_get_fecparam,\n\t.set_fecparam\t\t= nfp_port_set_fecparam,\n\t.get_pauseparam\t\t= nfp_port_get_pauseparam,\n\t.set_phys_id\t\t= nfp_net_set_phys_id,\n};\n\nvoid nfp_net_set_ethtool_ops(struct net_device *netdev)\n{\n\tnetdev->ethtool_ops = &nfp_net_ethtool_ops;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}