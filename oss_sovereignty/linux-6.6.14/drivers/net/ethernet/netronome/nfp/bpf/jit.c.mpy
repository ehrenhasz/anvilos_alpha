{
  "module_name": "jit.c",
  "hash_id": "31783d16122948880bbf8b921ca2385ef10155183b7ac20f1e9a4864e2e2da7d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/netronome/nfp/bpf/jit.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt)\t\"NFP net bpf: \" fmt\n\n#include <linux/bug.h>\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/kernel.h>\n#include <linux/pkt_cls.h>\n#include <linux/reciprocal_div.h>\n#include <linux/unistd.h>\n\n#include \"main.h\"\n#include \"../nfp_asm.h\"\n#include \"../nfp_net_ctrl.h\"\n\n \n \n#define nfp_for_each_insn_walk2(nfp_prog, pos, next)\t\t\t\\\n\tfor (pos = list_first_entry(&(nfp_prog)->insns, typeof(*pos), l), \\\n\t     next = list_next_entry(pos, l);\t\t\t\\\n\t     &(nfp_prog)->insns != &pos->l &&\t\t\t\\\n\t     &(nfp_prog)->insns != &next->l;\t\t\t\\\n\t     pos = nfp_meta_next(pos),\t\t\t\t\\\n\t     next = nfp_meta_next(pos))\n\n#define nfp_for_each_insn_walk3(nfp_prog, pos, next, next2)\t\t\\\n\tfor (pos = list_first_entry(&(nfp_prog)->insns, typeof(*pos), l), \\\n\t     next = list_next_entry(pos, l),\t\t\t\\\n\t     next2 = list_next_entry(next, l);\t\t\t\\\n\t     &(nfp_prog)->insns != &pos->l &&\t\t\t\\\n\t     &(nfp_prog)->insns != &next->l &&\t\t\t\\\n\t     &(nfp_prog)->insns != &next2->l;\t\t\t\\\n\t     pos = nfp_meta_next(pos),\t\t\t\t\\\n\t     next = nfp_meta_next(pos),\t\t\t\t\\\n\t     next2 = nfp_meta_next(next))\n\nstatic bool\nnfp_meta_has_prev(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\n{\n\treturn meta->l.prev != &nfp_prog->insns;\n}\n\nstatic void nfp_prog_push(struct nfp_prog *nfp_prog, u64 insn)\n{\n\tif (nfp_prog->__prog_alloc_len / sizeof(u64) == nfp_prog->prog_len) {\n\t\tpr_warn(\"instruction limit reached (%u NFP instructions)\\n\",\n\t\t\tnfp_prog->prog_len);\n\t\tnfp_prog->error = -ENOSPC;\n\t\treturn;\n\t}\n\n\tnfp_prog->prog[nfp_prog->prog_len] = insn;\n\tnfp_prog->prog_len++;\n}\n\nstatic unsigned int nfp_prog_current_offset(struct nfp_prog *nfp_prog)\n{\n\treturn nfp_prog->prog_len;\n}\n\nstatic bool\nnfp_prog_confirm_current_offset(struct nfp_prog *nfp_prog, unsigned int off)\n{\n\t \n\tif (nfp_prog->error)\n\t\treturn true;\n\treturn !WARN_ON_ONCE(nfp_prog_current_offset(nfp_prog) != off);\n}\n\n \nstatic void\n__emit_cmd(struct nfp_prog *nfp_prog, enum cmd_tgt_map op,\n\t   u8 mode, u8 xfer, u8 areg, u8 breg, u8 size, enum cmd_ctx_swap ctx,\n\t   bool indir)\n{\n\tu64 insn;\n\n\tinsn =\tFIELD_PREP(OP_CMD_A_SRC, areg) |\n\t\tFIELD_PREP(OP_CMD_CTX, ctx) |\n\t\tFIELD_PREP(OP_CMD_B_SRC, breg) |\n\t\tFIELD_PREP(OP_CMD_TOKEN, cmd_tgt_act[op].token) |\n\t\tFIELD_PREP(OP_CMD_XFER, xfer) |\n\t\tFIELD_PREP(OP_CMD_CNT, size) |\n\t\tFIELD_PREP(OP_CMD_SIG, ctx != CMD_CTX_NO_SWAP) |\n\t\tFIELD_PREP(OP_CMD_TGT_CMD, cmd_tgt_act[op].tgt_cmd) |\n\t\tFIELD_PREP(OP_CMD_INDIR, indir) |\n\t\tFIELD_PREP(OP_CMD_MODE, mode);\n\n\tnfp_prog_push(nfp_prog, insn);\n}\n\nstatic void\nemit_cmd_any(struct nfp_prog *nfp_prog, enum cmd_tgt_map op, u8 mode, u8 xfer,\n\t     swreg lreg, swreg rreg, u8 size, enum cmd_ctx_swap ctx, bool indir)\n{\n\tstruct nfp_insn_re_regs reg;\n\tint err;\n\n\terr = swreg_to_restricted(reg_none(), lreg, rreg, &reg, false);\n\tif (err) {\n\t\tnfp_prog->error = err;\n\t\treturn;\n\t}\n\tif (reg.swap) {\n\t\tpr_err(\"cmd can't swap arguments\\n\");\n\t\tnfp_prog->error = -EFAULT;\n\t\treturn;\n\t}\n\tif (reg.dst_lmextn || reg.src_lmextn) {\n\t\tpr_err(\"cmd can't use LMextn\\n\");\n\t\tnfp_prog->error = -EFAULT;\n\t\treturn;\n\t}\n\n\t__emit_cmd(nfp_prog, op, mode, xfer, reg.areg, reg.breg, size, ctx,\n\t\t   indir);\n}\n\nstatic void\nemit_cmd(struct nfp_prog *nfp_prog, enum cmd_tgt_map op, u8 mode, u8 xfer,\n\t swreg lreg, swreg rreg, u8 size, enum cmd_ctx_swap ctx)\n{\n\temit_cmd_any(nfp_prog, op, mode, xfer, lreg, rreg, size, ctx, false);\n}\n\nstatic void\nemit_cmd_indir(struct nfp_prog *nfp_prog, enum cmd_tgt_map op, u8 mode, u8 xfer,\n\t       swreg lreg, swreg rreg, u8 size, enum cmd_ctx_swap ctx)\n{\n\temit_cmd_any(nfp_prog, op, mode, xfer, lreg, rreg, size, ctx, true);\n}\n\nstatic void\n__emit_br(struct nfp_prog *nfp_prog, enum br_mask mask, enum br_ev_pip ev_pip,\n\t  enum br_ctx_signal_state css, u16 addr, u8 defer)\n{\n\tu16 addr_lo, addr_hi;\n\tu64 insn;\n\n\taddr_lo = addr & (OP_BR_ADDR_LO >> __bf_shf(OP_BR_ADDR_LO));\n\taddr_hi = addr != addr_lo;\n\n\tinsn = OP_BR_BASE |\n\t\tFIELD_PREP(OP_BR_MASK, mask) |\n\t\tFIELD_PREP(OP_BR_EV_PIP, ev_pip) |\n\t\tFIELD_PREP(OP_BR_CSS, css) |\n\t\tFIELD_PREP(OP_BR_DEFBR, defer) |\n\t\tFIELD_PREP(OP_BR_ADDR_LO, addr_lo) |\n\t\tFIELD_PREP(OP_BR_ADDR_HI, addr_hi);\n\n\tnfp_prog_push(nfp_prog, insn);\n}\n\nstatic void\nemit_br_relo(struct nfp_prog *nfp_prog, enum br_mask mask, u16 addr, u8 defer,\n\t     enum nfp_relo_type relo)\n{\n\tif (mask == BR_UNC && defer > 2) {\n\t\tpr_err(\"BUG: branch defer out of bounds %d\\n\", defer);\n\t\tnfp_prog->error = -EFAULT;\n\t\treturn;\n\t}\n\n\t__emit_br(nfp_prog, mask,\n\t\t  mask != BR_UNC ? BR_EV_PIP_COND : BR_EV_PIP_UNCOND,\n\t\t  BR_CSS_NONE, addr, defer);\n\n\tnfp_prog->prog[nfp_prog->prog_len - 1] |=\n\t\tFIELD_PREP(OP_RELO_TYPE, relo);\n}\n\nstatic void\nemit_br(struct nfp_prog *nfp_prog, enum br_mask mask, u16 addr, u8 defer)\n{\n\temit_br_relo(nfp_prog, mask, addr, defer, RELO_BR_REL);\n}\n\nstatic void\n__emit_br_bit(struct nfp_prog *nfp_prog, u16 areg, u16 breg, u16 addr, u8 defer,\n\t      bool set, bool src_lmextn)\n{\n\tu16 addr_lo, addr_hi;\n\tu64 insn;\n\n\taddr_lo = addr & (OP_BR_BIT_ADDR_LO >> __bf_shf(OP_BR_BIT_ADDR_LO));\n\taddr_hi = addr != addr_lo;\n\n\tinsn = OP_BR_BIT_BASE |\n\t\tFIELD_PREP(OP_BR_BIT_A_SRC, areg) |\n\t\tFIELD_PREP(OP_BR_BIT_B_SRC, breg) |\n\t\tFIELD_PREP(OP_BR_BIT_BV, set) |\n\t\tFIELD_PREP(OP_BR_BIT_DEFBR, defer) |\n\t\tFIELD_PREP(OP_BR_BIT_ADDR_LO, addr_lo) |\n\t\tFIELD_PREP(OP_BR_BIT_ADDR_HI, addr_hi) |\n\t\tFIELD_PREP(OP_BR_BIT_SRC_LMEXTN, src_lmextn);\n\n\tnfp_prog_push(nfp_prog, insn);\n}\n\nstatic void\nemit_br_bit_relo(struct nfp_prog *nfp_prog, swreg src, u8 bit, u16 addr,\n\t\t u8 defer, bool set, enum nfp_relo_type relo)\n{\n\tstruct nfp_insn_re_regs reg;\n\tint err;\n\n\t \n\tbit += 1;\n\n\terr = swreg_to_restricted(reg_none(), src, reg_imm(bit), &reg, false);\n\tif (err) {\n\t\tnfp_prog->error = err;\n\t\treturn;\n\t}\n\n\t__emit_br_bit(nfp_prog, reg.areg, reg.breg, addr, defer, set,\n\t\t      reg.src_lmextn);\n\n\tnfp_prog->prog[nfp_prog->prog_len - 1] |=\n\t\tFIELD_PREP(OP_RELO_TYPE, relo);\n}\n\nstatic void\nemit_br_bset(struct nfp_prog *nfp_prog, swreg src, u8 bit, u16 addr, u8 defer)\n{\n\temit_br_bit_relo(nfp_prog, src, bit, addr, defer, true, RELO_BR_REL);\n}\n\nstatic void\n__emit_br_alu(struct nfp_prog *nfp_prog, u16 areg, u16 breg, u16 imm_hi,\n\t      u8 defer, bool dst_lmextn, bool src_lmextn)\n{\n\tu64 insn;\n\n\tinsn = OP_BR_ALU_BASE |\n\t\tFIELD_PREP(OP_BR_ALU_A_SRC, areg) |\n\t\tFIELD_PREP(OP_BR_ALU_B_SRC, breg) |\n\t\tFIELD_PREP(OP_BR_ALU_DEFBR, defer) |\n\t\tFIELD_PREP(OP_BR_ALU_IMM_HI, imm_hi) |\n\t\tFIELD_PREP(OP_BR_ALU_SRC_LMEXTN, src_lmextn) |\n\t\tFIELD_PREP(OP_BR_ALU_DST_LMEXTN, dst_lmextn);\n\n\tnfp_prog_push(nfp_prog, insn);\n}\n\nstatic void emit_rtn(struct nfp_prog *nfp_prog, swreg base, u8 defer)\n{\n\tstruct nfp_insn_ur_regs reg;\n\tint err;\n\n\terr = swreg_to_unrestricted(reg_none(), base, reg_imm(0), &reg);\n\tif (err) {\n\t\tnfp_prog->error = err;\n\t\treturn;\n\t}\n\n\t__emit_br_alu(nfp_prog, reg.areg, reg.breg, 0, defer, reg.dst_lmextn,\n\t\t      reg.src_lmextn);\n}\n\nstatic void\n__emit_immed(struct nfp_prog *nfp_prog, u16 areg, u16 breg, u16 imm_hi,\n\t     enum immed_width width, bool invert,\n\t     enum immed_shift shift, bool wr_both,\n\t     bool dst_lmextn, bool src_lmextn)\n{\n\tu64 insn;\n\n\tinsn = OP_IMMED_BASE |\n\t\tFIELD_PREP(OP_IMMED_A_SRC, areg) |\n\t\tFIELD_PREP(OP_IMMED_B_SRC, breg) |\n\t\tFIELD_PREP(OP_IMMED_IMM, imm_hi) |\n\t\tFIELD_PREP(OP_IMMED_WIDTH, width) |\n\t\tFIELD_PREP(OP_IMMED_INV, invert) |\n\t\tFIELD_PREP(OP_IMMED_SHIFT, shift) |\n\t\tFIELD_PREP(OP_IMMED_WR_AB, wr_both) |\n\t\tFIELD_PREP(OP_IMMED_SRC_LMEXTN, src_lmextn) |\n\t\tFIELD_PREP(OP_IMMED_DST_LMEXTN, dst_lmextn);\n\n\tnfp_prog_push(nfp_prog, insn);\n}\n\nstatic void\nemit_immed(struct nfp_prog *nfp_prog, swreg dst, u16 imm,\n\t   enum immed_width width, bool invert, enum immed_shift shift)\n{\n\tstruct nfp_insn_ur_regs reg;\n\tint err;\n\n\tif (swreg_type(dst) == NN_REG_IMM) {\n\t\tnfp_prog->error = -EFAULT;\n\t\treturn;\n\t}\n\n\terr = swreg_to_unrestricted(dst, dst, reg_imm(imm & 0xff), &reg);\n\tif (err) {\n\t\tnfp_prog->error = err;\n\t\treturn;\n\t}\n\n\t \n\t__emit_immed(nfp_prog,\n\t\t     swreg_type(dst) == NN_REG_NONE ? reg.dst : reg.areg,\n\t\t     reg.breg, imm >> 8, width, invert, shift,\n\t\t     reg.wr_both, reg.dst_lmextn, reg.src_lmextn);\n}\n\nstatic void\n__emit_shf(struct nfp_prog *nfp_prog, u16 dst, enum alu_dst_ab dst_ab,\n\t   enum shf_sc sc, u8 shift,\n\t   u16 areg, enum shf_op op, u16 breg, bool i8, bool sw, bool wr_both,\n\t   bool dst_lmextn, bool src_lmextn)\n{\n\tu64 insn;\n\n\tif (!FIELD_FIT(OP_SHF_SHIFT, shift)) {\n\t\tnfp_prog->error = -EFAULT;\n\t\treturn;\n\t}\n\n\t \n\tif (sc == SHF_SC_L_SHF && shift)\n\t\tshift = 32 - shift;\n\n\tinsn = OP_SHF_BASE |\n\t\tFIELD_PREP(OP_SHF_A_SRC, areg) |\n\t\tFIELD_PREP(OP_SHF_SC, sc) |\n\t\tFIELD_PREP(OP_SHF_B_SRC, breg) |\n\t\tFIELD_PREP(OP_SHF_I8, i8) |\n\t\tFIELD_PREP(OP_SHF_SW, sw) |\n\t\tFIELD_PREP(OP_SHF_DST, dst) |\n\t\tFIELD_PREP(OP_SHF_SHIFT, shift) |\n\t\tFIELD_PREP(OP_SHF_OP, op) |\n\t\tFIELD_PREP(OP_SHF_DST_AB, dst_ab) |\n\t\tFIELD_PREP(OP_SHF_WR_AB, wr_both) |\n\t\tFIELD_PREP(OP_SHF_SRC_LMEXTN, src_lmextn) |\n\t\tFIELD_PREP(OP_SHF_DST_LMEXTN, dst_lmextn);\n\n\tnfp_prog_push(nfp_prog, insn);\n}\n\nstatic void\nemit_shf(struct nfp_prog *nfp_prog, swreg dst,\n\t swreg lreg, enum shf_op op, swreg rreg, enum shf_sc sc, u8 shift)\n{\n\tstruct nfp_insn_re_regs reg;\n\tint err;\n\n\terr = swreg_to_restricted(dst, lreg, rreg, &reg, true);\n\tif (err) {\n\t\tnfp_prog->error = err;\n\t\treturn;\n\t}\n\n\t__emit_shf(nfp_prog, reg.dst, reg.dst_ab, sc, shift,\n\t\t   reg.areg, op, reg.breg, reg.i8, reg.swap, reg.wr_both,\n\t\t   reg.dst_lmextn, reg.src_lmextn);\n}\n\nstatic void\nemit_shf_indir(struct nfp_prog *nfp_prog, swreg dst,\n\t       swreg lreg, enum shf_op op, swreg rreg, enum shf_sc sc)\n{\n\tif (sc == SHF_SC_R_ROT) {\n\t\tpr_err(\"indirect shift is not allowed on rotation\\n\");\n\t\tnfp_prog->error = -EFAULT;\n\t\treturn;\n\t}\n\n\temit_shf(nfp_prog, dst, lreg, op, rreg, sc, 0);\n}\n\nstatic void\n__emit_alu(struct nfp_prog *nfp_prog, u16 dst, enum alu_dst_ab dst_ab,\n\t   u16 areg, enum alu_op op, u16 breg, bool swap, bool wr_both,\n\t   bool dst_lmextn, bool src_lmextn)\n{\n\tu64 insn;\n\n\tinsn = OP_ALU_BASE |\n\t\tFIELD_PREP(OP_ALU_A_SRC, areg) |\n\t\tFIELD_PREP(OP_ALU_B_SRC, breg) |\n\t\tFIELD_PREP(OP_ALU_DST, dst) |\n\t\tFIELD_PREP(OP_ALU_SW, swap) |\n\t\tFIELD_PREP(OP_ALU_OP, op) |\n\t\tFIELD_PREP(OP_ALU_DST_AB, dst_ab) |\n\t\tFIELD_PREP(OP_ALU_WR_AB, wr_both) |\n\t\tFIELD_PREP(OP_ALU_SRC_LMEXTN, src_lmextn) |\n\t\tFIELD_PREP(OP_ALU_DST_LMEXTN, dst_lmextn);\n\n\tnfp_prog_push(nfp_prog, insn);\n}\n\nstatic void\nemit_alu(struct nfp_prog *nfp_prog, swreg dst,\n\t swreg lreg, enum alu_op op, swreg rreg)\n{\n\tstruct nfp_insn_ur_regs reg;\n\tint err;\n\n\terr = swreg_to_unrestricted(dst, lreg, rreg, &reg);\n\tif (err) {\n\t\tnfp_prog->error = err;\n\t\treturn;\n\t}\n\n\t__emit_alu(nfp_prog, reg.dst, reg.dst_ab,\n\t\t   reg.areg, op, reg.breg, reg.swap, reg.wr_both,\n\t\t   reg.dst_lmextn, reg.src_lmextn);\n}\n\nstatic void\n__emit_mul(struct nfp_prog *nfp_prog, enum alu_dst_ab dst_ab, u16 areg,\n\t   enum mul_type type, enum mul_step step, u16 breg, bool swap,\n\t   bool wr_both, bool dst_lmextn, bool src_lmextn)\n{\n\tu64 insn;\n\n\tinsn = OP_MUL_BASE |\n\t\tFIELD_PREP(OP_MUL_A_SRC, areg) |\n\t\tFIELD_PREP(OP_MUL_B_SRC, breg) |\n\t\tFIELD_PREP(OP_MUL_STEP, step) |\n\t\tFIELD_PREP(OP_MUL_DST_AB, dst_ab) |\n\t\tFIELD_PREP(OP_MUL_SW, swap) |\n\t\tFIELD_PREP(OP_MUL_TYPE, type) |\n\t\tFIELD_PREP(OP_MUL_WR_AB, wr_both) |\n\t\tFIELD_PREP(OP_MUL_SRC_LMEXTN, src_lmextn) |\n\t\tFIELD_PREP(OP_MUL_DST_LMEXTN, dst_lmextn);\n\n\tnfp_prog_push(nfp_prog, insn);\n}\n\nstatic void\nemit_mul(struct nfp_prog *nfp_prog, swreg lreg, enum mul_type type,\n\t enum mul_step step, swreg rreg)\n{\n\tstruct nfp_insn_ur_regs reg;\n\tu16 areg;\n\tint err;\n\n\tif (type == MUL_TYPE_START && step != MUL_STEP_NONE) {\n\t\tnfp_prog->error = -EINVAL;\n\t\treturn;\n\t}\n\n\tif (step == MUL_LAST || step == MUL_LAST_2) {\n\t\t \n\t\terr = swreg_to_unrestricted(lreg, reg_none(), rreg, &reg);\n\t\tareg = reg.dst;\n\t} else {\n\t\terr = swreg_to_unrestricted(reg_none(), lreg, rreg, &reg);\n\t\tareg = reg.areg;\n\t}\n\n\tif (err) {\n\t\tnfp_prog->error = err;\n\t\treturn;\n\t}\n\n\t__emit_mul(nfp_prog, reg.dst_ab, areg, type, step, reg.breg, reg.swap,\n\t\t   reg.wr_both, reg.dst_lmextn, reg.src_lmextn);\n}\n\nstatic void\n__emit_ld_field(struct nfp_prog *nfp_prog, enum shf_sc sc,\n\t\tu8 areg, u8 bmask, u8 breg, u8 shift, bool imm8,\n\t\tbool zero, bool swap, bool wr_both,\n\t\tbool dst_lmextn, bool src_lmextn)\n{\n\tu64 insn;\n\n\tinsn = OP_LDF_BASE |\n\t\tFIELD_PREP(OP_LDF_A_SRC, areg) |\n\t\tFIELD_PREP(OP_LDF_SC, sc) |\n\t\tFIELD_PREP(OP_LDF_B_SRC, breg) |\n\t\tFIELD_PREP(OP_LDF_I8, imm8) |\n\t\tFIELD_PREP(OP_LDF_SW, swap) |\n\t\tFIELD_PREP(OP_LDF_ZF, zero) |\n\t\tFIELD_PREP(OP_LDF_BMASK, bmask) |\n\t\tFIELD_PREP(OP_LDF_SHF, shift) |\n\t\tFIELD_PREP(OP_LDF_WR_AB, wr_both) |\n\t\tFIELD_PREP(OP_LDF_SRC_LMEXTN, src_lmextn) |\n\t\tFIELD_PREP(OP_LDF_DST_LMEXTN, dst_lmextn);\n\n\tnfp_prog_push(nfp_prog, insn);\n}\n\nstatic void\nemit_ld_field_any(struct nfp_prog *nfp_prog, swreg dst, u8 bmask, swreg src,\n\t\t  enum shf_sc sc, u8 shift, bool zero)\n{\n\tstruct nfp_insn_re_regs reg;\n\tint err;\n\n\t \n\terr = swreg_to_restricted(dst, dst, src, &reg, true);\n\tif (err) {\n\t\tnfp_prog->error = err;\n\t\treturn;\n\t}\n\n\t__emit_ld_field(nfp_prog, sc, reg.areg, bmask, reg.breg, shift,\n\t\t\treg.i8, zero, reg.swap, reg.wr_both,\n\t\t\treg.dst_lmextn, reg.src_lmextn);\n}\n\nstatic void\nemit_ld_field(struct nfp_prog *nfp_prog, swreg dst, u8 bmask, swreg src,\n\t      enum shf_sc sc, u8 shift)\n{\n\temit_ld_field_any(nfp_prog, dst, bmask, src, sc, shift, false);\n}\n\nstatic void\n__emit_lcsr(struct nfp_prog *nfp_prog, u16 areg, u16 breg, bool wr, u16 addr,\n\t    bool dst_lmextn, bool src_lmextn)\n{\n\tu64 insn;\n\n\tinsn = OP_LCSR_BASE |\n\t\tFIELD_PREP(OP_LCSR_A_SRC, areg) |\n\t\tFIELD_PREP(OP_LCSR_B_SRC, breg) |\n\t\tFIELD_PREP(OP_LCSR_WRITE, wr) |\n\t\tFIELD_PREP(OP_LCSR_ADDR, addr / 4) |\n\t\tFIELD_PREP(OP_LCSR_SRC_LMEXTN, src_lmextn) |\n\t\tFIELD_PREP(OP_LCSR_DST_LMEXTN, dst_lmextn);\n\n\tnfp_prog_push(nfp_prog, insn);\n}\n\nstatic void emit_csr_wr(struct nfp_prog *nfp_prog, swreg src, u16 addr)\n{\n\tstruct nfp_insn_ur_regs reg;\n\tint err;\n\n\t \n\tif (swreg_type(src) == NN_REG_IMM) {\n\t\terr = swreg_to_unrestricted(reg_none(), src, reg_none(), &reg);\n\t\treg.breg = reg.areg;\n\t} else {\n\t\terr = swreg_to_unrestricted(reg_none(), src, reg_imm(0), &reg);\n\t}\n\tif (err) {\n\t\tnfp_prog->error = err;\n\t\treturn;\n\t}\n\n\t__emit_lcsr(nfp_prog, reg.areg, reg.breg, true, addr,\n\t\t    false, reg.src_lmextn);\n}\n\n \nstatic void __emit_csr_rd(struct nfp_prog *nfp_prog, u16 addr)\n{\n\t__emit_lcsr(nfp_prog, 0, 0, false, addr, false, false);\n}\n\nstatic void emit_nop(struct nfp_prog *nfp_prog)\n{\n\t__emit_immed(nfp_prog, UR_REG_IMM, UR_REG_IMM, 0, 0, 0, 0, 0, 0, 0);\n}\n\n \nstatic bool pack_immed(u32 imm, u16 *val, enum immed_shift *shift)\n{\n\tif (!(imm & 0xffff0000)) {\n\t\t*val = imm;\n\t\t*shift = IMMED_SHIFT_0B;\n\t} else if (!(imm & 0xff0000ff)) {\n\t\t*val = imm >> 8;\n\t\t*shift = IMMED_SHIFT_1B;\n\t} else if (!(imm & 0x0000ffff)) {\n\t\t*val = imm >> 16;\n\t\t*shift = IMMED_SHIFT_2B;\n\t} else {\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic void wrp_immed(struct nfp_prog *nfp_prog, swreg dst, u32 imm)\n{\n\tenum immed_shift shift;\n\tu16 val;\n\n\tif (pack_immed(imm, &val, &shift)) {\n\t\temit_immed(nfp_prog, dst, val, IMMED_WIDTH_ALL, false, shift);\n\t} else if (pack_immed(~imm, &val, &shift)) {\n\t\temit_immed(nfp_prog, dst, val, IMMED_WIDTH_ALL, true, shift);\n\t} else {\n\t\temit_immed(nfp_prog, dst, imm & 0xffff, IMMED_WIDTH_ALL,\n\t\t\t   false, IMMED_SHIFT_0B);\n\t\temit_immed(nfp_prog, dst, imm >> 16, IMMED_WIDTH_WORD,\n\t\t\t   false, IMMED_SHIFT_2B);\n\t}\n}\n\nstatic void\nwrp_zext(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta, u8 dst)\n{\n\tif (meta->flags & FLAG_INSN_DO_ZEXT)\n\t\twrp_immed(nfp_prog, reg_both(dst + 1), 0);\n}\n\nstatic void\nwrp_immed_relo(struct nfp_prog *nfp_prog, swreg dst, u32 imm,\n\t       enum nfp_relo_type relo)\n{\n\tif (imm > 0xffff) {\n\t\tpr_err(\"relocation of a large immediate!\\n\");\n\t\tnfp_prog->error = -EFAULT;\n\t\treturn;\n\t}\n\temit_immed(nfp_prog, dst, imm, IMMED_WIDTH_ALL, false, IMMED_SHIFT_0B);\n\n\tnfp_prog->prog[nfp_prog->prog_len - 1] |=\n\t\tFIELD_PREP(OP_RELO_TYPE, relo);\n}\n\n \nstatic swreg ur_load_imm_any(struct nfp_prog *nfp_prog, u32 imm, swreg tmp_reg)\n{\n\tif (FIELD_FIT(UR_REG_IMM_MAX, imm))\n\t\treturn reg_imm(imm);\n\n\twrp_immed(nfp_prog, tmp_reg, imm);\n\treturn tmp_reg;\n}\n\n \nstatic swreg re_load_imm_any(struct nfp_prog *nfp_prog, u32 imm, swreg tmp_reg)\n{\n\tif (FIELD_FIT(RE_REG_IMM_MAX, imm))\n\t\treturn reg_imm(imm);\n\n\twrp_immed(nfp_prog, tmp_reg, imm);\n\treturn tmp_reg;\n}\n\nstatic void wrp_nops(struct nfp_prog *nfp_prog, unsigned int count)\n{\n\twhile (count--)\n\t\temit_nop(nfp_prog);\n}\n\nstatic void wrp_mov(struct nfp_prog *nfp_prog, swreg dst, swreg src)\n{\n\temit_alu(nfp_prog, dst, reg_none(), ALU_OP_NONE, src);\n}\n\nstatic void wrp_reg_mov(struct nfp_prog *nfp_prog, u16 dst, u16 src)\n{\n\twrp_mov(nfp_prog, reg_both(dst), reg_b(src));\n}\n\n \nstatic void\nwrp_reg_subpart(struct nfp_prog *nfp_prog, swreg dst, swreg src, u8 field_len,\n\t\tu8 offset)\n{\n\tenum shf_sc sc = offset ? SHF_SC_R_SHF : SHF_SC_NONE;\n\tu8 mask = (1 << field_len) - 1;\n\n\temit_ld_field_any(nfp_prog, dst, mask, src, sc, offset * 8, true);\n}\n\n \nstatic void\nwrp_reg_or_subpart(struct nfp_prog *nfp_prog, swreg dst, swreg src,\n\t\t   u8 field_len, u8 offset)\n{\n\tenum shf_sc sc = offset ? SHF_SC_L_SHF : SHF_SC_NONE;\n\tu8 mask = ((1 << field_len) - 1) << offset;\n\n\temit_ld_field(nfp_prog, dst, mask, src, sc, 32 - offset * 8);\n}\n\nstatic void\naddr40_offset(struct nfp_prog *nfp_prog, u8 src_gpr, swreg offset,\n\t      swreg *rega, swreg *regb)\n{\n\tif (offset == reg_imm(0)) {\n\t\t*rega = reg_a(src_gpr);\n\t\t*regb = reg_b(src_gpr + 1);\n\t\treturn;\n\t}\n\n\temit_alu(nfp_prog, imm_a(nfp_prog), reg_a(src_gpr), ALU_OP_ADD, offset);\n\temit_alu(nfp_prog, imm_b(nfp_prog), reg_b(src_gpr + 1), ALU_OP_ADD_C,\n\t\t reg_imm(0));\n\t*rega = imm_a(nfp_prog);\n\t*regb = imm_b(nfp_prog);\n}\n\n \nstatic int nfp_cpp_memcpy(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\n{\n\tbool descending_seq = meta->ldst_gather_len < 0;\n\ts16 len = abs(meta->ldst_gather_len);\n\tswreg src_base, off;\n\tbool src_40bit_addr;\n\tunsigned int i;\n\tu8 xfer_num;\n\n\toff = re_load_imm_any(nfp_prog, meta->insn.off, imm_b(nfp_prog));\n\tsrc_40bit_addr = meta->ptr.type == PTR_TO_MAP_VALUE;\n\tsrc_base = reg_a(meta->insn.src_reg * 2);\n\txfer_num = round_up(len, 4) / 4;\n\n\tif (src_40bit_addr)\n\t\taddr40_offset(nfp_prog, meta->insn.src_reg * 2, off, &src_base,\n\t\t\t      &off);\n\n\t \n\tif (len > 32)\n\t\twrp_immed(nfp_prog, reg_none(),\n\t\t\t  CMD_OVE_LEN | FIELD_PREP(CMD_OV_LEN, xfer_num - 1));\n\n\t \n\temit_cmd_any(nfp_prog, CMD_TGT_READ32_SWAP,\n\t\t     src_40bit_addr ? CMD_MODE_40b_BA : CMD_MODE_32b, 0,\n\t\t     src_base, off, xfer_num - 1, CMD_CTX_SWAP, len > 32);\n\n\t \n\tfor (i = 0; i < xfer_num; i++)\n\t\twrp_mov(nfp_prog, reg_xfer(i), reg_xfer(i));\n\n\toff = re_load_imm_any(nfp_prog, meta->paired_st->off, imm_b(nfp_prog));\n\n\tif (len <= 8) {\n\t\t \n\t\temit_cmd(nfp_prog, CMD_TGT_WRITE8_SWAP, CMD_MODE_32b, 0,\n\t\t\t reg_a(meta->paired_st->dst_reg * 2), off, len - 1,\n\t\t\t CMD_CTX_SWAP);\n\t} else if (len <= 32 && IS_ALIGNED(len, 4)) {\n\t\t \n\t\temit_cmd(nfp_prog, CMD_TGT_WRITE32_SWAP, CMD_MODE_32b, 0,\n\t\t\t reg_a(meta->paired_st->dst_reg * 2), off, xfer_num - 1,\n\t\t\t CMD_CTX_SWAP);\n\t} else if (len <= 32) {\n\t\t \n\t\twrp_immed(nfp_prog, reg_none(),\n\t\t\t  CMD_OVE_LEN | FIELD_PREP(CMD_OV_LEN, len - 1));\n\t\temit_cmd_indir(nfp_prog, CMD_TGT_WRITE8_SWAP, CMD_MODE_32b, 0,\n\t\t\t       reg_a(meta->paired_st->dst_reg * 2), off,\n\t\t\t       len - 1, CMD_CTX_SWAP);\n\t} else if (IS_ALIGNED(len, 4)) {\n\t\t \n\t\twrp_immed(nfp_prog, reg_none(),\n\t\t\t  CMD_OVE_LEN | FIELD_PREP(CMD_OV_LEN, xfer_num - 1));\n\t\temit_cmd_indir(nfp_prog, CMD_TGT_WRITE32_SWAP, CMD_MODE_32b, 0,\n\t\t\t       reg_a(meta->paired_st->dst_reg * 2), off,\n\t\t\t       xfer_num - 1, CMD_CTX_SWAP);\n\t} else if (len <= 40) {\n\t\t \n\t\temit_cmd(nfp_prog, CMD_TGT_WRITE32_SWAP, CMD_MODE_32b, 0,\n\t\t\t reg_a(meta->paired_st->dst_reg * 2), off, 7,\n\t\t\t CMD_CTX_SWAP);\n\n\t\toff = re_load_imm_any(nfp_prog, meta->paired_st->off + 32,\n\t\t\t\t      imm_b(nfp_prog));\n\t\temit_cmd(nfp_prog, CMD_TGT_WRITE8_SWAP, CMD_MODE_32b, 8,\n\t\t\t reg_a(meta->paired_st->dst_reg * 2), off, len - 33,\n\t\t\t CMD_CTX_SWAP);\n\t} else {\n\t\t \n\t\tu8 new_off;\n\n\t\twrp_immed(nfp_prog, reg_none(),\n\t\t\t  CMD_OVE_LEN | FIELD_PREP(CMD_OV_LEN, xfer_num - 2));\n\t\temit_cmd_indir(nfp_prog, CMD_TGT_WRITE32_SWAP, CMD_MODE_32b, 0,\n\t\t\t       reg_a(meta->paired_st->dst_reg * 2), off,\n\t\t\t       xfer_num - 2, CMD_CTX_SWAP);\n\t\tnew_off = meta->paired_st->off + (xfer_num - 1) * 4;\n\t\toff = re_load_imm_any(nfp_prog, new_off, imm_b(nfp_prog));\n\t\temit_cmd(nfp_prog, CMD_TGT_WRITE8_SWAP, CMD_MODE_32b,\n\t\t\t xfer_num - 1, reg_a(meta->paired_st->dst_reg * 2), off,\n\t\t\t (len & 0x3) - 1, CMD_CTX_SWAP);\n\t}\n\n\t \n\tif (descending_seq)\n\t\txfer_num = 0;\n\telse if (BPF_SIZE(meta->insn.code) != BPF_DW)\n\t\txfer_num = xfer_num - 1;\n\telse\n\t\txfer_num = xfer_num - 2;\n\n\tswitch (BPF_SIZE(meta->insn.code)) {\n\tcase BPF_B:\n\t\twrp_reg_subpart(nfp_prog, reg_both(meta->insn.dst_reg * 2),\n\t\t\t\treg_xfer(xfer_num), 1,\n\t\t\t\tIS_ALIGNED(len, 4) ? 3 : (len & 3) - 1);\n\t\tbreak;\n\tcase BPF_H:\n\t\twrp_reg_subpart(nfp_prog, reg_both(meta->insn.dst_reg * 2),\n\t\t\t\treg_xfer(xfer_num), 2, (len & 3) ^ 2);\n\t\tbreak;\n\tcase BPF_W:\n\t\twrp_mov(nfp_prog, reg_both(meta->insn.dst_reg * 2),\n\t\t\treg_xfer(0));\n\t\tbreak;\n\tcase BPF_DW:\n\t\twrp_mov(nfp_prog, reg_both(meta->insn.dst_reg * 2),\n\t\t\treg_xfer(xfer_num));\n\t\twrp_mov(nfp_prog, reg_both(meta->insn.dst_reg * 2 + 1),\n\t\t\treg_xfer(xfer_num + 1));\n\t\tbreak;\n\t}\n\n\tif (BPF_SIZE(meta->insn.code) != BPF_DW)\n\t\twrp_immed(nfp_prog, reg_both(meta->insn.dst_reg * 2 + 1), 0);\n\n\treturn 0;\n}\n\nstatic int\ndata_ld(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta, swreg offset,\n\tu8 dst_gpr, int size)\n{\n\tunsigned int i;\n\tu16 shift, sz;\n\n\t \n\tsz = max(size, 4);\n\tshift = size < 4 ? 4 - size : 0;\n\n\temit_cmd(nfp_prog, CMD_TGT_READ8, CMD_MODE_32b, 0,\n\t\t pptr_reg(nfp_prog), offset, sz - 1, CMD_CTX_SWAP);\n\n\ti = 0;\n\tif (shift)\n\t\temit_shf(nfp_prog, reg_both(dst_gpr), reg_none(), SHF_OP_NONE,\n\t\t\t reg_xfer(0), SHF_SC_R_SHF, shift * 8);\n\telse\n\t\tfor (; i * 4 < size; i++)\n\t\t\twrp_mov(nfp_prog, reg_both(dst_gpr + i), reg_xfer(i));\n\n\tif (i < 2)\n\t\twrp_zext(nfp_prog, meta, dst_gpr);\n\n\treturn 0;\n}\n\nstatic int\ndata_ld_host_order(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta,\n\t\t   u8 dst_gpr, swreg lreg, swreg rreg, int size,\n\t\t   enum cmd_mode mode)\n{\n\tunsigned int i;\n\tu8 mask, sz;\n\n\t \n\tsz = max(size, 4);\n\tmask = size < 4 ? GENMASK(size - 1, 0) : 0;\n\n\temit_cmd(nfp_prog, CMD_TGT_READ32_SWAP, mode, 0,\n\t\t lreg, rreg, sz / 4 - 1, CMD_CTX_SWAP);\n\n\ti = 0;\n\tif (mask)\n\t\temit_ld_field_any(nfp_prog, reg_both(dst_gpr), mask,\n\t\t\t\t  reg_xfer(0), SHF_SC_NONE, 0, true);\n\telse\n\t\tfor (; i * 4 < size; i++)\n\t\t\twrp_mov(nfp_prog, reg_both(dst_gpr + i), reg_xfer(i));\n\n\tif (i < 2)\n\t\twrp_zext(nfp_prog, meta, dst_gpr);\n\n\treturn 0;\n}\n\nstatic int\ndata_ld_host_order_addr32(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta,\n\t\t\t  u8 src_gpr, swreg offset, u8 dst_gpr, u8 size)\n{\n\treturn data_ld_host_order(nfp_prog, meta, dst_gpr, reg_a(src_gpr),\n\t\t\t\t  offset, size, CMD_MODE_32b);\n}\n\nstatic int\ndata_ld_host_order_addr40(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta,\n\t\t\t  u8 src_gpr, swreg offset, u8 dst_gpr, u8 size)\n{\n\tswreg rega, regb;\n\n\taddr40_offset(nfp_prog, src_gpr, offset, &rega, &regb);\n\n\treturn data_ld_host_order(nfp_prog, meta, dst_gpr, rega, regb,\n\t\t\t\t  size, CMD_MODE_40b_BA);\n}\n\nstatic int\nconstruct_data_ind_ld(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta,\n\t\t      u16 offset, u16 src, u8 size)\n{\n\tswreg tmp_reg;\n\n\t \n\ttmp_reg = ur_load_imm_any(nfp_prog, offset, imm_b(nfp_prog));\n\temit_alu(nfp_prog, imm_both(nfp_prog), reg_a(src), ALU_OP_ADD, tmp_reg);\n\n\t \n\temit_alu(nfp_prog, imm_a(nfp_prog),\n\t\t imm_a(nfp_prog), ALU_OP_ADD, reg_imm(size));\n\temit_alu(nfp_prog, reg_none(),\n\t\t plen_reg(nfp_prog), ALU_OP_SUB, imm_a(nfp_prog));\n\temit_br_relo(nfp_prog, BR_BLO, BR_OFF_RELO, 0, RELO_BR_GO_ABORT);\n\n\t \n\treturn data_ld(nfp_prog, meta, imm_b(nfp_prog), 0, size);\n}\n\nstatic int\nconstruct_data_ld(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta,\n\t\t  u16 offset, u8 size)\n{\n\tswreg tmp_reg;\n\n\t \n\ttmp_reg = ur_load_imm_any(nfp_prog, offset + size, imm_a(nfp_prog));\n\temit_alu(nfp_prog, reg_none(), plen_reg(nfp_prog), ALU_OP_SUB, tmp_reg);\n\temit_br_relo(nfp_prog, BR_BLO, BR_OFF_RELO, 0, RELO_BR_GO_ABORT);\n\n\t \n\ttmp_reg = re_load_imm_any(nfp_prog, offset, imm_b(nfp_prog));\n\treturn data_ld(nfp_prog, meta, tmp_reg, 0, size);\n}\n\nstatic int\ndata_stx_host_order(struct nfp_prog *nfp_prog, u8 dst_gpr, swreg offset,\n\t\t    u8 src_gpr, u8 size)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i * 4 < size; i++)\n\t\twrp_mov(nfp_prog, reg_xfer(i), reg_a(src_gpr + i));\n\n\temit_cmd(nfp_prog, CMD_TGT_WRITE8_SWAP, CMD_MODE_32b, 0,\n\t\t reg_a(dst_gpr), offset, size - 1, CMD_CTX_SWAP);\n\n\treturn 0;\n}\n\nstatic int\ndata_st_host_order(struct nfp_prog *nfp_prog, u8 dst_gpr, swreg offset,\n\t\t   u64 imm, u8 size)\n{\n\twrp_immed(nfp_prog, reg_xfer(0), imm);\n\tif (size == 8)\n\t\twrp_immed(nfp_prog, reg_xfer(1), imm >> 32);\n\n\temit_cmd(nfp_prog, CMD_TGT_WRITE8_SWAP, CMD_MODE_32b, 0,\n\t\t reg_a(dst_gpr), offset, size - 1, CMD_CTX_SWAP);\n\n\treturn 0;\n}\n\ntypedef int\n(*lmem_step)(struct nfp_prog *nfp_prog, u8 gpr, u8 gpr_byte, s32 off,\n\t     unsigned int size, bool first, bool new_gpr, bool last, bool lm3,\n\t     bool needs_inc);\n\nstatic int\nwrp_lmem_load(struct nfp_prog *nfp_prog, u8 dst, u8 dst_byte, s32 off,\n\t      unsigned int size, bool first, bool new_gpr, bool last, bool lm3,\n\t      bool needs_inc)\n{\n\tbool should_inc = needs_inc && new_gpr && !last;\n\tu32 idx, src_byte;\n\tenum shf_sc sc;\n\tswreg reg;\n\tint shf;\n\tu8 mask;\n\n\tif (WARN_ON_ONCE(dst_byte + size > 4 || off % 4 + size > 4))\n\t\treturn -EOPNOTSUPP;\n\n\tidx = off / 4;\n\n\t \n\tif (size == 4) {\n\t\twrp_mov(nfp_prog, reg_both(dst),\n\t\t\tshould_inc ? reg_lm_inc(3) : reg_lm(lm3 ? 3 : 0, idx));\n\t\treturn 0;\n\t}\n\n\tif (WARN_ON_ONCE(lm3 && idx > RE_REG_LM_IDX_MAX))\n\t\treturn -EOPNOTSUPP;\n\n\tsrc_byte = off % 4;\n\n\tmask = (1 << size) - 1;\n\tmask <<= dst_byte;\n\n\tif (WARN_ON_ONCE(mask > 0xf))\n\t\treturn -EOPNOTSUPP;\n\n\tshf = abs(src_byte - dst_byte) * 8;\n\tif (src_byte == dst_byte) {\n\t\tsc = SHF_SC_NONE;\n\t} else if (src_byte < dst_byte) {\n\t\tshf = 32 - shf;\n\t\tsc = SHF_SC_L_SHF;\n\t} else {\n\t\tsc = SHF_SC_R_SHF;\n\t}\n\n\t \n\tif (idx <= RE_REG_LM_IDX_MAX) {\n\t\treg = reg_lm(lm3 ? 3 : 0, idx);\n\t} else {\n\t\treg = imm_a(nfp_prog);\n\t\t \n\t\tif (first || !new_gpr)\n\t\t\twrp_mov(nfp_prog, reg, reg_lm(0, idx));\n\t}\n\n\temit_ld_field_any(nfp_prog, reg_both(dst), mask, reg, sc, shf, new_gpr);\n\n\tif (should_inc)\n\t\twrp_mov(nfp_prog, reg_none(), reg_lm_inc(3));\n\n\treturn 0;\n}\n\nstatic int\nwrp_lmem_store(struct nfp_prog *nfp_prog, u8 src, u8 src_byte, s32 off,\n\t       unsigned int size, bool first, bool new_gpr, bool last, bool lm3,\n\t       bool needs_inc)\n{\n\tbool should_inc = needs_inc && new_gpr && !last;\n\tu32 idx, dst_byte;\n\tenum shf_sc sc;\n\tswreg reg;\n\tint shf;\n\tu8 mask;\n\n\tif (WARN_ON_ONCE(src_byte + size > 4 || off % 4 + size > 4))\n\t\treturn -EOPNOTSUPP;\n\n\tidx = off / 4;\n\n\t \n\tif (size == 4) {\n\t\twrp_mov(nfp_prog,\n\t\t\tshould_inc ? reg_lm_inc(3) : reg_lm(lm3 ? 3 : 0, idx),\n\t\t\treg_b(src));\n\t\treturn 0;\n\t}\n\n\tif (WARN_ON_ONCE(lm3 && idx > RE_REG_LM_IDX_MAX))\n\t\treturn -EOPNOTSUPP;\n\n\tdst_byte = off % 4;\n\n\tmask = (1 << size) - 1;\n\tmask <<= dst_byte;\n\n\tif (WARN_ON_ONCE(mask > 0xf))\n\t\treturn -EOPNOTSUPP;\n\n\tshf = abs(src_byte - dst_byte) * 8;\n\tif (src_byte == dst_byte) {\n\t\tsc = SHF_SC_NONE;\n\t} else if (src_byte < dst_byte) {\n\t\tshf = 32 - shf;\n\t\tsc = SHF_SC_L_SHF;\n\t} else {\n\t\tsc = SHF_SC_R_SHF;\n\t}\n\n\t \n\tif (idx <= RE_REG_LM_IDX_MAX) {\n\t\treg = reg_lm(lm3 ? 3 : 0, idx);\n\t} else {\n\t\treg = imm_a(nfp_prog);\n\t\t \n\t\tif (first || last)\n\t\t\twrp_mov(nfp_prog, reg, reg_lm(0, idx));\n\t}\n\n\temit_ld_field(nfp_prog, reg, mask, reg_b(src), sc, shf);\n\n\tif (new_gpr || last) {\n\t\tif (idx > RE_REG_LM_IDX_MAX)\n\t\t\twrp_mov(nfp_prog, reg_lm(0, idx), reg);\n\t\tif (should_inc)\n\t\t\twrp_mov(nfp_prog, reg_none(), reg_lm_inc(3));\n\t}\n\n\treturn 0;\n}\n\nstatic int\nmem_op_stack(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta,\n\t     unsigned int size, unsigned int ptr_off, u8 gpr, u8 ptr_gpr,\n\t     bool clr_gpr, lmem_step step)\n{\n\ts32 off = nfp_prog->stack_frame_depth + meta->insn.off + ptr_off;\n\tbool first = true, narrow_ld, last;\n\tbool needs_inc = false;\n\tswreg stack_off_reg;\n\tu8 prev_gpr = 255;\n\tu32 gpr_byte = 0;\n\tbool lm3 = true;\n\tint ret;\n\n\tif (meta->ptr_not_const ||\n\t    meta->flags & FLAG_INSN_PTR_CALLER_STACK_FRAME) {\n\t\t \n\t\tstack_off_reg = ur_load_imm_any(nfp_prog, meta->insn.off,\n\t\t\t\t\t\tstack_imm(nfp_prog));\n\n\t\temit_alu(nfp_prog, imm_b(nfp_prog),\n\t\t\t reg_a(ptr_gpr), ALU_OP_ADD, stack_off_reg);\n\n\t\tneeds_inc = true;\n\t} else if (off + size <= 64) {\n\t\t \n\t\tlm3 = false;\n\t} else if (round_down(off, 32) == round_down(off + size - 1, 32)) {\n\t\t \n\t\tstack_off_reg = ur_load_imm_any(nfp_prog, round_down(off, 32),\n\t\t\t\t\t\tstack_imm(nfp_prog));\n\t\temit_alu(nfp_prog, imm_b(nfp_prog),\n\t\t\t stack_reg(nfp_prog), ALU_OP_ADD, stack_off_reg);\n\n\t\toff %= 32;\n\t} else {\n\t\tstack_off_reg = ur_load_imm_any(nfp_prog, round_down(off, 4),\n\t\t\t\t\t\tstack_imm(nfp_prog));\n\n\t\temit_alu(nfp_prog, imm_b(nfp_prog),\n\t\t\t stack_reg(nfp_prog), ALU_OP_ADD, stack_off_reg);\n\n\t\tneeds_inc = true;\n\t}\n\n\tnarrow_ld = clr_gpr && size < 8;\n\n\tif (lm3) {\n\t\tunsigned int nop_cnt;\n\n\t\temit_csr_wr(nfp_prog, imm_b(nfp_prog), NFP_CSR_ACT_LM_ADDR3);\n\t\t \n\t\tnop_cnt = narrow_ld && meta->flags & FLAG_INSN_DO_ZEXT ? 2 : 3;\n\t\twrp_nops(nfp_prog, nop_cnt);\n\t}\n\n\tif (narrow_ld)\n\t\twrp_zext(nfp_prog, meta, gpr);\n\n\twhile (size) {\n\t\tu32 slice_end;\n\t\tu8 slice_size;\n\n\t\tslice_size = min(size, 4 - gpr_byte);\n\t\tslice_end = min(off + slice_size, round_up(off + 1, 4));\n\t\tslice_size = slice_end - off;\n\n\t\tlast = slice_size == size;\n\n\t\tif (needs_inc)\n\t\t\toff %= 4;\n\n\t\tret = step(nfp_prog, gpr, gpr_byte, off, slice_size,\n\t\t\t   first, gpr != prev_gpr, last, lm3, needs_inc);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tprev_gpr = gpr;\n\t\tfirst = false;\n\n\t\tgpr_byte += slice_size;\n\t\tif (gpr_byte >= 4) {\n\t\t\tgpr_byte -= 4;\n\t\t\tgpr++;\n\t\t}\n\n\t\tsize -= slice_size;\n\t\toff += slice_size;\n\t}\n\n\treturn 0;\n}\n\nstatic void\nwrp_alu_imm(struct nfp_prog *nfp_prog, u8 dst, enum alu_op alu_op, u32 imm)\n{\n\tswreg tmp_reg;\n\n\tif (alu_op == ALU_OP_AND) {\n\t\tif (!imm)\n\t\t\twrp_immed(nfp_prog, reg_both(dst), 0);\n\t\tif (!imm || !~imm)\n\t\t\treturn;\n\t}\n\tif (alu_op == ALU_OP_OR) {\n\t\tif (!~imm)\n\t\t\twrp_immed(nfp_prog, reg_both(dst), ~0U);\n\t\tif (!imm || !~imm)\n\t\t\treturn;\n\t}\n\tif (alu_op == ALU_OP_XOR) {\n\t\tif (!~imm)\n\t\t\temit_alu(nfp_prog, reg_both(dst), reg_none(),\n\t\t\t\t ALU_OP_NOT, reg_b(dst));\n\t\tif (!imm || !~imm)\n\t\t\treturn;\n\t}\n\n\ttmp_reg = ur_load_imm_any(nfp_prog, imm, imm_b(nfp_prog));\n\temit_alu(nfp_prog, reg_both(dst), reg_a(dst), alu_op, tmp_reg);\n}\n\nstatic int\nwrp_alu64_imm(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta,\n\t      enum alu_op alu_op, bool skip)\n{\n\tconst struct bpf_insn *insn = &meta->insn;\n\tu64 imm = insn->imm;  \n\n\tif (skip) {\n\t\tmeta->flags |= FLAG_INSN_SKIP_NOOP;\n\t\treturn 0;\n\t}\n\n\twrp_alu_imm(nfp_prog, insn->dst_reg * 2, alu_op, imm & ~0U);\n\twrp_alu_imm(nfp_prog, insn->dst_reg * 2 + 1, alu_op, imm >> 32);\n\n\treturn 0;\n}\n\nstatic int\nwrp_alu64_reg(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta,\n\t      enum alu_op alu_op)\n{\n\tu8 dst = meta->insn.dst_reg * 2, src = meta->insn.src_reg * 2;\n\n\temit_alu(nfp_prog, reg_both(dst), reg_a(dst), alu_op, reg_b(src));\n\temit_alu(nfp_prog, reg_both(dst + 1),\n\t\t reg_a(dst + 1), alu_op, reg_b(src + 1));\n\n\treturn 0;\n}\n\nstatic int\nwrp_alu32_imm(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta,\n\t      enum alu_op alu_op)\n{\n\tconst struct bpf_insn *insn = &meta->insn;\n\tu8 dst = insn->dst_reg * 2;\n\n\twrp_alu_imm(nfp_prog, dst, alu_op, insn->imm);\n\twrp_zext(nfp_prog, meta, dst);\n\n\treturn 0;\n}\n\nstatic int\nwrp_alu32_reg(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta,\n\t      enum alu_op alu_op)\n{\n\tu8 dst = meta->insn.dst_reg * 2, src = meta->insn.src_reg * 2;\n\n\temit_alu(nfp_prog, reg_both(dst), reg_a(dst), alu_op, reg_b(src));\n\twrp_zext(nfp_prog, meta, dst);\n\n\treturn 0;\n}\n\nstatic void\nwrp_test_reg_one(struct nfp_prog *nfp_prog, u8 dst, enum alu_op alu_op, u8 src,\n\t\t enum br_mask br_mask, u16 off)\n{\n\temit_alu(nfp_prog, reg_none(), reg_a(dst), alu_op, reg_b(src));\n\temit_br(nfp_prog, br_mask, off, 0);\n}\n\nstatic int\nwrp_test_reg(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta,\n\t     enum alu_op alu_op, enum br_mask br_mask)\n{\n\tconst struct bpf_insn *insn = &meta->insn;\n\n\twrp_test_reg_one(nfp_prog, insn->dst_reg * 2, alu_op,\n\t\t\t insn->src_reg * 2, br_mask, insn->off);\n\tif (is_mbpf_jmp64(meta))\n\t\twrp_test_reg_one(nfp_prog, insn->dst_reg * 2 + 1, alu_op,\n\t\t\t\t insn->src_reg * 2 + 1, br_mask, insn->off);\n\n\treturn 0;\n}\n\nstatic const struct jmp_code_map {\n\tenum br_mask br_mask;\n\tbool swap;\n} jmp_code_map[] = {\n\t[BPF_JGT >> 4]\t= { BR_BLO, true },\n\t[BPF_JGE >> 4]\t= { BR_BHS, false },\n\t[BPF_JLT >> 4]\t= { BR_BLO, false },\n\t[BPF_JLE >> 4]\t= { BR_BHS, true },\n\t[BPF_JSGT >> 4]\t= { BR_BLT, true },\n\t[BPF_JSGE >> 4]\t= { BR_BGE, false },\n\t[BPF_JSLT >> 4]\t= { BR_BLT, false },\n\t[BPF_JSLE >> 4]\t= { BR_BGE, true },\n};\n\nstatic const struct jmp_code_map *nfp_jmp_code_get(struct nfp_insn_meta *meta)\n{\n\tunsigned int op;\n\n\top = BPF_OP(meta->insn.code) >> 4;\n\t \n\tif (WARN_ONCE(op >= ARRAY_SIZE(jmp_code_map) ||\n\t\t      !jmp_code_map[op].br_mask,\n\t\t      \"no code found for jump instruction\"))\n\t\treturn NULL;\n\n\treturn &jmp_code_map[op];\n}\n\nstatic int cmp_imm(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\n{\n\tconst struct bpf_insn *insn = &meta->insn;\n\tu64 imm = insn->imm;  \n\tconst struct jmp_code_map *code;\n\tenum alu_op alu_op, carry_op;\n\tu8 reg = insn->dst_reg * 2;\n\tswreg tmp_reg;\n\n\tcode = nfp_jmp_code_get(meta);\n\tif (!code)\n\t\treturn -EINVAL;\n\n\talu_op = meta->jump_neg_op ? ALU_OP_ADD : ALU_OP_SUB;\n\tcarry_op = meta->jump_neg_op ? ALU_OP_ADD_C : ALU_OP_SUB_C;\n\n\ttmp_reg = ur_load_imm_any(nfp_prog, imm & ~0U, imm_b(nfp_prog));\n\tif (!code->swap)\n\t\temit_alu(nfp_prog, reg_none(), reg_a(reg), alu_op, tmp_reg);\n\telse\n\t\temit_alu(nfp_prog, reg_none(), tmp_reg, alu_op, reg_a(reg));\n\n\tif (is_mbpf_jmp64(meta)) {\n\t\ttmp_reg = ur_load_imm_any(nfp_prog, imm >> 32, imm_b(nfp_prog));\n\t\tif (!code->swap)\n\t\t\temit_alu(nfp_prog, reg_none(),\n\t\t\t\t reg_a(reg + 1), carry_op, tmp_reg);\n\t\telse\n\t\t\temit_alu(nfp_prog, reg_none(),\n\t\t\t\t tmp_reg, carry_op, reg_a(reg + 1));\n\t}\n\n\temit_br(nfp_prog, code->br_mask, insn->off, 0);\n\n\treturn 0;\n}\n\nstatic int cmp_reg(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\n{\n\tconst struct bpf_insn *insn = &meta->insn;\n\tconst struct jmp_code_map *code;\n\tu8 areg, breg;\n\n\tcode = nfp_jmp_code_get(meta);\n\tif (!code)\n\t\treturn -EINVAL;\n\n\tareg = insn->dst_reg * 2;\n\tbreg = insn->src_reg * 2;\n\n\tif (code->swap) {\n\t\tareg ^= breg;\n\t\tbreg ^= areg;\n\t\tareg ^= breg;\n\t}\n\n\temit_alu(nfp_prog, reg_none(), reg_a(areg), ALU_OP_SUB, reg_b(breg));\n\tif (is_mbpf_jmp64(meta))\n\t\temit_alu(nfp_prog, reg_none(),\n\t\t\t reg_a(areg + 1), ALU_OP_SUB_C, reg_b(breg + 1));\n\temit_br(nfp_prog, code->br_mask, insn->off, 0);\n\n\treturn 0;\n}\n\nstatic void wrp_end32(struct nfp_prog *nfp_prog, swreg reg_in, u8 gpr_out)\n{\n\temit_ld_field(nfp_prog, reg_both(gpr_out), 0xf, reg_in,\n\t\t      SHF_SC_R_ROT, 8);\n\temit_ld_field(nfp_prog, reg_both(gpr_out), 0x5, reg_a(gpr_out),\n\t\t      SHF_SC_R_ROT, 16);\n}\n\nstatic void\nwrp_mul_u32(struct nfp_prog *nfp_prog, swreg dst_hi, swreg dst_lo, swreg lreg,\n\t    swreg rreg, bool gen_high_half)\n{\n\temit_mul(nfp_prog, lreg, MUL_TYPE_START, MUL_STEP_NONE, rreg);\n\temit_mul(nfp_prog, lreg, MUL_TYPE_STEP_32x32, MUL_STEP_1, rreg);\n\temit_mul(nfp_prog, lreg, MUL_TYPE_STEP_32x32, MUL_STEP_2, rreg);\n\temit_mul(nfp_prog, lreg, MUL_TYPE_STEP_32x32, MUL_STEP_3, rreg);\n\temit_mul(nfp_prog, lreg, MUL_TYPE_STEP_32x32, MUL_STEP_4, rreg);\n\temit_mul(nfp_prog, dst_lo, MUL_TYPE_STEP_32x32, MUL_LAST, reg_none());\n\tif (gen_high_half)\n\t\temit_mul(nfp_prog, dst_hi, MUL_TYPE_STEP_32x32, MUL_LAST_2,\n\t\t\t reg_none());\n\telse\n\t\twrp_immed(nfp_prog, dst_hi, 0);\n}\n\nstatic void\nwrp_mul_u16(struct nfp_prog *nfp_prog, swreg dst_hi, swreg dst_lo, swreg lreg,\n\t    swreg rreg)\n{\n\temit_mul(nfp_prog, lreg, MUL_TYPE_START, MUL_STEP_NONE, rreg);\n\temit_mul(nfp_prog, lreg, MUL_TYPE_STEP_16x16, MUL_STEP_1, rreg);\n\temit_mul(nfp_prog, lreg, MUL_TYPE_STEP_16x16, MUL_STEP_2, rreg);\n\temit_mul(nfp_prog, dst_lo, MUL_TYPE_STEP_16x16, MUL_LAST, reg_none());\n}\n\nstatic int\nwrp_mul(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta,\n\tbool gen_high_half, bool ropnd_from_reg)\n{\n\tswreg multiplier, multiplicand, dst_hi, dst_lo;\n\tconst struct bpf_insn *insn = &meta->insn;\n\tu32 lopnd_max, ropnd_max;\n\tu8 dst_reg;\n\n\tdst_reg = insn->dst_reg;\n\tmultiplicand = reg_a(dst_reg * 2);\n\tdst_hi = reg_both(dst_reg * 2 + 1);\n\tdst_lo = reg_both(dst_reg * 2);\n\tlopnd_max = meta->umax_dst;\n\tif (ropnd_from_reg) {\n\t\tmultiplier = reg_b(insn->src_reg * 2);\n\t\tropnd_max = meta->umax_src;\n\t} else {\n\t\tu32 imm = insn->imm;\n\n\t\tmultiplier = ur_load_imm_any(nfp_prog, imm, imm_b(nfp_prog));\n\t\tropnd_max = imm;\n\t}\n\tif (lopnd_max > U16_MAX || ropnd_max > U16_MAX)\n\t\twrp_mul_u32(nfp_prog, dst_hi, dst_lo, multiplicand, multiplier,\n\t\t\t    gen_high_half);\n\telse\n\t\twrp_mul_u16(nfp_prog, dst_hi, dst_lo, multiplicand, multiplier);\n\n\treturn 0;\n}\n\nstatic int wrp_div_imm(struct nfp_prog *nfp_prog, u8 dst, u64 imm)\n{\n\tswreg dst_both = reg_both(dst), dst_a = reg_a(dst), dst_b = reg_a(dst);\n\tstruct reciprocal_value_adv rvalue;\n\tu8 pre_shift, exp;\n\tswreg magic;\n\n\tif (imm > U32_MAX) {\n\t\twrp_immed(nfp_prog, dst_both, 0);\n\t\treturn 0;\n\t}\n\n\t \n\tif (imm > 1U << 31) {\n\t\tswreg tmp_b = ur_load_imm_any(nfp_prog, imm, imm_b(nfp_prog));\n\n\t\temit_alu(nfp_prog, reg_none(), dst_a, ALU_OP_SUB, tmp_b);\n\t\twrp_immed(nfp_prog, imm_a(nfp_prog), 0);\n\t\temit_alu(nfp_prog, dst_both, imm_a(nfp_prog), ALU_OP_ADD_C,\n\t\t\t reg_imm(0));\n\t\treturn 0;\n\t}\n\n\trvalue = reciprocal_value_adv(imm, 32);\n\texp = rvalue.exp;\n\tif (rvalue.is_wide_m && !(imm & 1)) {\n\t\tpre_shift = fls(imm & -imm) - 1;\n\t\trvalue = reciprocal_value_adv(imm >> pre_shift, 32 - pre_shift);\n\t} else {\n\t\tpre_shift = 0;\n\t}\n\tmagic = ur_load_imm_any(nfp_prog, rvalue.m, imm_b(nfp_prog));\n\tif (imm == 1U << exp) {\n\t\temit_shf(nfp_prog, dst_both, reg_none(), SHF_OP_NONE, dst_b,\n\t\t\t SHF_SC_R_SHF, exp);\n\t} else if (rvalue.is_wide_m) {\n\t\twrp_mul_u32(nfp_prog, imm_both(nfp_prog), reg_none(), dst_a,\n\t\t\t    magic, true);\n\t\temit_alu(nfp_prog, dst_both, dst_a, ALU_OP_SUB,\n\t\t\t imm_b(nfp_prog));\n\t\temit_shf(nfp_prog, dst_both, reg_none(), SHF_OP_NONE, dst_b,\n\t\t\t SHF_SC_R_SHF, 1);\n\t\temit_alu(nfp_prog, dst_both, dst_a, ALU_OP_ADD,\n\t\t\t imm_b(nfp_prog));\n\t\temit_shf(nfp_prog, dst_both, reg_none(), SHF_OP_NONE, dst_b,\n\t\t\t SHF_SC_R_SHF, rvalue.sh - 1);\n\t} else {\n\t\tif (pre_shift)\n\t\t\temit_shf(nfp_prog, dst_both, reg_none(), SHF_OP_NONE,\n\t\t\t\t dst_b, SHF_SC_R_SHF, pre_shift);\n\t\twrp_mul_u32(nfp_prog, dst_both, reg_none(), dst_a, magic, true);\n\t\temit_shf(nfp_prog, dst_both, reg_none(), SHF_OP_NONE,\n\t\t\t dst_b, SHF_SC_R_SHF, rvalue.sh);\n\t}\n\n\treturn 0;\n}\n\nstatic int adjust_head(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\n{\n\tswreg tmp = imm_a(nfp_prog), tmp_len = imm_b(nfp_prog);\n\tstruct nfp_bpf_cap_adjust_head *adjust_head;\n\tu32 ret_einval, end;\n\n\tadjust_head = &nfp_prog->bpf->adjust_head;\n\n\t \n\tif (nfp_prog->adjust_head_location != UINT_MAX) {\n\t\tif (WARN_ON_ONCE(nfp_prog->adjust_head_location != meta->n))\n\t\t\treturn -EINVAL;\n\n\t\temit_alu(nfp_prog, pptr_reg(nfp_prog),\n\t\t\t reg_a(2 * 2), ALU_OP_ADD, pptr_reg(nfp_prog));\n\t\temit_alu(nfp_prog, plen_reg(nfp_prog),\n\t\t\t plen_reg(nfp_prog), ALU_OP_SUB, reg_a(2 * 2));\n\t\temit_alu(nfp_prog, pv_len(nfp_prog),\n\t\t\t pv_len(nfp_prog), ALU_OP_SUB, reg_a(2 * 2));\n\n\t\twrp_immed(nfp_prog, reg_both(0), 0);\n\t\twrp_immed(nfp_prog, reg_both(1), 0);\n\n\t\t \n\n\t\treturn 0;\n\t}\n\n\tret_einval = nfp_prog_current_offset(nfp_prog) + 14;\n\tend = ret_einval + 2;\n\n\t \n\temit_alu(nfp_prog, tmp,\n\t\t reg_a(2 * 2), ALU_OP_ADD_2B, pptr_reg(nfp_prog));\n\n\t \n\temit_alu(nfp_prog, reg_none(),\n\t\t tmp, ALU_OP_SUB, reg_imm(adjust_head->off_min));\n\temit_br(nfp_prog, BR_BLO, ret_einval, 0);\n\temit_alu(nfp_prog, reg_none(),\n\t\t reg_imm(adjust_head->off_max), ALU_OP_SUB, tmp);\n\temit_br(nfp_prog, BR_BLO, ret_einval, 0);\n\n\t \n\temit_alu(nfp_prog, tmp_len,\n\t\t plen_reg(nfp_prog), ALU_OP_SUB, reg_a(2 * 2));\n\temit_alu(nfp_prog, reg_none(),\n\t\t tmp_len, ALU_OP_SUB, reg_imm(ETH_HLEN));\n\temit_br(nfp_prog, BR_BMI, ret_einval, 0);\n\n\t \n\twrp_immed(nfp_prog, reg_both(0), 0);\n\twrp_immed(nfp_prog, reg_both(1), 0);\n\n\t \n\temit_ld_field(nfp_prog, pptr_reg(nfp_prog), 0x3, tmp, SHF_SC_NONE, 0);\n\n\t \n\temit_br(nfp_prog, BR_UNC, end, 2);\n\n\temit_alu(nfp_prog, plen_reg(nfp_prog),\n\t\t plen_reg(nfp_prog), ALU_OP_SUB, reg_a(2 * 2));\n\temit_alu(nfp_prog, pv_len(nfp_prog),\n\t\t pv_len(nfp_prog), ALU_OP_SUB, reg_a(2 * 2));\n\n\t \n\tif (!nfp_prog_confirm_current_offset(nfp_prog, ret_einval))\n\t\treturn -EINVAL;\n\n\twrp_immed(nfp_prog, reg_both(0), -22);\n\twrp_immed(nfp_prog, reg_both(1), ~0);\n\n\tif (!nfp_prog_confirm_current_offset(nfp_prog, end))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int adjust_tail(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\n{\n\tu32 ret_einval, end;\n\tswreg plen, delta;\n\n\tBUILD_BUG_ON(plen_reg(nfp_prog) != reg_b(STATIC_REG_PKT_LEN));\n\n\tplen = imm_a(nfp_prog);\n\tdelta = reg_a(2 * 2);\n\n\tret_einval = nfp_prog_current_offset(nfp_prog) + 9;\n\tend = nfp_prog_current_offset(nfp_prog) + 11;\n\n\t \n\temit_alu(nfp_prog, plen, plen_reg(nfp_prog), ALU_OP_ADD, delta);\n\t \n\temit_br(nfp_prog, BR_BCC, ret_einval, 0);\n\n\t \n\temit_alu(nfp_prog, reg_none(), plen, ALU_OP_SUB, reg_imm(ETH_HLEN));\n\temit_br(nfp_prog, BR_BMI, ret_einval, 0);\n\n\temit_alu(nfp_prog, plen_reg(nfp_prog),\n\t\t plen_reg(nfp_prog), ALU_OP_ADD, delta);\n\temit_alu(nfp_prog, pv_len(nfp_prog),\n\t\t pv_len(nfp_prog), ALU_OP_ADD, delta);\n\n\temit_br(nfp_prog, BR_UNC, end, 2);\n\twrp_immed(nfp_prog, reg_both(0), 0);\n\twrp_immed(nfp_prog, reg_both(1), 0);\n\n\tif (!nfp_prog_confirm_current_offset(nfp_prog, ret_einval))\n\t\treturn -EINVAL;\n\n\twrp_immed(nfp_prog, reg_both(0), -22);\n\twrp_immed(nfp_prog, reg_both(1), ~0);\n\n\tif (!nfp_prog_confirm_current_offset(nfp_prog, end))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int\nmap_call_stack_common(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\n{\n\tbool load_lm_ptr;\n\tu32 ret_tgt;\n\ts64 lm_off;\n\n\t \n\tlm_off = nfp_prog->stack_frame_depth;\n\tlm_off += meta->arg2.reg.var_off.value + meta->arg2.reg.off;\n\tload_lm_ptr = meta->arg2.var_off || lm_off;\n\n\t \n\tif (load_lm_ptr)\n\t\temit_csr_wr(nfp_prog, reg_b(2 * 2), NFP_CSR_ACT_LM_ADDR0);\n\tif (meta->func_id == BPF_FUNC_map_update_elem)\n\t\temit_csr_wr(nfp_prog, reg_b(3 * 2), NFP_CSR_ACT_LM_ADDR2);\n\n\temit_br_relo(nfp_prog, BR_UNC, BR_OFF_RELO + meta->func_id,\n\t\t     2, RELO_BR_HELPER);\n\tret_tgt = nfp_prog_current_offset(nfp_prog) + 2;\n\n\t \n\twrp_mov(nfp_prog, reg_a(0), reg_a(2));\n\n\t \n\twrp_immed_relo(nfp_prog, reg_b(0), ret_tgt, RELO_IMMED_REL);\n\n\tif (!nfp_prog_confirm_current_offset(nfp_prog, ret_tgt))\n\t\treturn -EINVAL;\n\n\t \n\tif (!load_lm_ptr)\n\t\treturn 0;\n\n\temit_csr_wr(nfp_prog, stack_reg(nfp_prog), NFP_CSR_ACT_LM_ADDR0);\n\twrp_nops(nfp_prog, 3);\n\n\treturn 0;\n}\n\nstatic int\nnfp_get_prandom_u32(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\n{\n\t__emit_csr_rd(nfp_prog, NFP_CSR_PSEUDO_RND_NUM);\n\t \n\temit_immed(nfp_prog, reg_both(0), 0,\n\t\t   IMMED_WIDTH_ALL, false, IMMED_SHIFT_0B);\n\temit_immed(nfp_prog, reg_both(1), 0,\n\t\t   IMMED_WIDTH_ALL, false, IMMED_SHIFT_0B);\n\treturn 0;\n}\n\nstatic int\nnfp_perf_event_output(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\n{\n\tswreg ptr_type;\n\tu32 ret_tgt;\n\n\tptr_type = ur_load_imm_any(nfp_prog, meta->arg1.type, imm_a(nfp_prog));\n\n\tret_tgt = nfp_prog_current_offset(nfp_prog) + 3;\n\n\temit_br_relo(nfp_prog, BR_UNC, BR_OFF_RELO + meta->func_id,\n\t\t     2, RELO_BR_HELPER);\n\n\t \n\twrp_mov(nfp_prog, reg_a(1), ptr_type);\n\n\t \n\twrp_immed_relo(nfp_prog, reg_b(0), ret_tgt, RELO_IMMED_REL);\n\n\tif (!nfp_prog_confirm_current_offset(nfp_prog, ret_tgt))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int\nnfp_queue_select(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\n{\n\tu32 jmp_tgt;\n\n\tjmp_tgt = nfp_prog_current_offset(nfp_prog) + 5;\n\n\t \n\temit_alu(nfp_prog, reg_none(), reg_a(meta->insn.src_reg * 2),\n\t\t ALU_OP_AND_NOT_B, reg_imm(0xff));\n\temit_br(nfp_prog, BR_BEQ, jmp_tgt, 2);\n\n\t \n\temit_shf(nfp_prog, pv_qsel_set(nfp_prog),\n\t\t pv_qsel_set(nfp_prog), SHF_OP_OR, reg_imm(1),\n\t\t SHF_SC_L_SHF, PKT_VEL_QSEL_SET_BIT);\n\temit_ld_field(nfp_prog,\n\t\t      pv_qsel_val(nfp_prog), 0x1, reg_b(meta->insn.src_reg * 2),\n\t\t      SHF_SC_NONE, 0);\n\t \n\temit_ld_field(nfp_prog,\n\t\t      pv_qsel_val(nfp_prog), 0x1, reg_imm(NFP_NET_RXR_MAX),\n\t\t      SHF_SC_NONE, 0);\n\n\tif (!nfp_prog_confirm_current_offset(nfp_prog, jmp_tgt))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n \nstatic int mov_reg64(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\n{\n\tconst struct bpf_insn *insn = &meta->insn;\n\tu8 dst = insn->dst_reg * 2;\n\tu8 src = insn->src_reg * 2;\n\n\tif (insn->src_reg == BPF_REG_10) {\n\t\tswreg stack_depth_reg;\n\n\t\tstack_depth_reg = ur_load_imm_any(nfp_prog,\n\t\t\t\t\t\t  nfp_prog->stack_frame_depth,\n\t\t\t\t\t\t  stack_imm(nfp_prog));\n\t\temit_alu(nfp_prog, reg_both(dst), stack_reg(nfp_prog),\n\t\t\t ALU_OP_ADD, stack_depth_reg);\n\t\twrp_immed(nfp_prog, reg_both(dst + 1), 0);\n\t} else {\n\t\twrp_reg_mov(nfp_prog, dst, src);\n\t\twrp_reg_mov(nfp_prog, dst + 1, src + 1);\n\t}\n\n\treturn 0;\n}\n\nstatic int mov_imm64(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\n{\n\tu64 imm = meta->insn.imm;  \n\n\twrp_immed(nfp_prog, reg_both(meta->insn.dst_reg * 2), imm & ~0U);\n\twrp_immed(nfp_prog, reg_both(meta->insn.dst_reg * 2 + 1), imm >> 32);\n\n\treturn 0;\n}\n\nstatic int xor_reg64(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\n{\n\treturn wrp_alu64_reg(nfp_prog, meta, ALU_OP_XOR);\n}\n\nstatic int xor_imm64(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\n{\n\treturn wrp_alu64_imm(nfp_prog, meta, ALU_OP_XOR, !meta->insn.imm);\n}\n\nstatic int and_reg64(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\n{\n\treturn wrp_alu64_reg(nfp_prog, meta, ALU_OP_AND);\n}\n\nstatic int and_imm64(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\n{\n\treturn wrp_alu64_imm(nfp_prog, meta, ALU_OP_AND, !~meta->insn.imm);\n}\n\nstatic int or_reg64(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\n{\n\treturn wrp_alu64_reg(nfp_prog, meta, ALU_OP_OR);\n}\n\nstatic int or_imm64(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\n{\n\treturn wrp_alu64_imm(nfp_prog, meta, ALU_OP_OR, !meta->insn.imm);\n}\n\nstatic int add_reg64(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\n{\n\tconst struct bpf_insn *insn = &meta->insn;\n\n\temit_alu(nfp_prog, reg_both(insn->dst_reg * 2),\n\t\t reg_a(insn->dst_reg * 2), ALU_OP_ADD,\n\t\t reg_b(insn->src_reg * 2));\n\temit_alu(nfp_prog, reg_both(insn->dst_reg * 2 + 1),\n\t\t reg_a(insn->dst_reg * 2 + 1), ALU_OP_ADD_C,\n\t\t reg_b(insn->src_reg * 2 + 1));\n\n\treturn 0;\n}\n\nstatic int add_imm64(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\n{\n\tconst struct bpf_insn *insn = &meta->insn;\n\tu64 imm = insn->imm;  \n\n\twrp_alu_imm(nfp_prog, insn->dst_reg * 2, ALU_OP_ADD, imm & ~0U);\n\twrp_alu_imm(nfp_prog, insn->dst_reg * 2 + 1, ALU_OP_ADD_C, imm >> 32);\n\n\treturn 0;\n}\n\nstatic int sub_reg64(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\n{\n\tconst struct bpf_insn *insn = &meta->insn;\n\n\temit_alu(nfp_prog, reg_both(insn->dst_reg * 2),\n\t\t reg_a(insn->dst_reg * 2), ALU_OP_SUB,\n\t\t reg_b(insn->src_reg * 2));\n\temit_alu(nfp_prog, reg_both(insn->dst_reg * 2 + 1),\n\t\t reg_a(insn->dst_reg * 2 + 1), ALU_OP_SUB_C,\n\t\t reg_b(insn->src_reg * 2 + 1));\n\n\treturn 0;\n}\n\nstatic int sub_imm64(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\n{\n\tconst struct bpf_insn *insn = &meta->insn;\n\tu64 imm = insn->imm;  \n\n\twrp_alu_imm(nfp_prog, insn->dst_reg * 2, ALU_OP_SUB, imm & ~0U);\n\twrp_alu_imm(nfp_prog, insn->dst_reg * 2 + 1, ALU_OP_SUB_C, imm >> 32);\n\n\treturn 0;\n}\n\nstatic int mul_reg64(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\n{\n\treturn wrp_mul(nfp_prog, meta, true, true);\n}\n\nstatic int mul_imm64(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\n{\n\treturn wrp_mul(nfp_prog, meta, true, false);\n}\n\nstatic int div_imm64(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\n{\n\tconst struct bpf_insn *insn = &meta->insn;\n\n\treturn wrp_div_imm(nfp_prog, insn->dst_reg * 2, insn->imm);\n}\n\nstatic int div_reg64(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\n{\n\t \n\treturn wrp_div_imm(nfp_prog, meta->insn.dst_reg * 2, meta->umin_src);\n}\n\nstatic int neg_reg64(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\n{\n\tconst struct bpf_insn *insn = &meta->insn;\n\n\temit_alu(nfp_prog, reg_both(insn->dst_reg * 2), reg_imm(0),\n\t\t ALU_OP_SUB, reg_b(insn->dst_reg * 2));\n\temit_alu(nfp_prog, reg_both(insn->dst_reg * 2 + 1), reg_imm(0),\n\t\t ALU_OP_SUB_C, reg_b(insn->dst_reg * 2 + 1));\n\n\treturn 0;\n}\n\n \nstatic int __shl_imm64(struct nfp_prog *nfp_prog, u8 dst, u8 shift_amt)\n{\n\tif (!shift_amt)\n\t\treturn 0;\n\n\tif (shift_amt < 32) {\n\t\temit_shf(nfp_prog, reg_both(dst + 1), reg_a(dst + 1),\n\t\t\t SHF_OP_NONE, reg_b(dst), SHF_SC_R_DSHF,\n\t\t\t 32 - shift_amt);\n\t\temit_shf(nfp_prog, reg_both(dst), reg_none(), SHF_OP_NONE,\n\t\t\t reg_b(dst), SHF_SC_L_SHF, shift_amt);\n\t} else if (shift_amt == 32) {\n\t\twrp_reg_mov(nfp_prog, dst + 1, dst);\n\t\twrp_immed(nfp_prog, reg_both(dst), 0);\n\t} else if (shift_amt > 32) {\n\t\temit_shf(nfp_prog, reg_both(dst + 1), reg_none(), SHF_OP_NONE,\n\t\t\t reg_b(dst), SHF_SC_L_SHF, shift_amt - 32);\n\t\twrp_immed(nfp_prog, reg_both(dst), 0);\n\t}\n\n\treturn 0;\n}\n\nstatic int shl_imm64(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\n{\n\tconst struct bpf_insn *insn = &meta->insn;\n\tu8 dst = insn->dst_reg * 2;\n\n\treturn __shl_imm64(nfp_prog, dst, insn->imm);\n}\n\nstatic void shl_reg64_lt32_high(struct nfp_prog *nfp_prog, u8 dst, u8 src)\n{\n\temit_alu(nfp_prog, imm_both(nfp_prog), reg_imm(32), ALU_OP_SUB,\n\t\t reg_b(src));\n\temit_alu(nfp_prog, reg_none(), imm_a(nfp_prog), ALU_OP_OR, reg_imm(0));\n\temit_shf_indir(nfp_prog, reg_both(dst + 1), reg_a(dst + 1), SHF_OP_NONE,\n\t\t       reg_b(dst), SHF_SC_R_DSHF);\n}\n\n \nstatic void shl_reg64_lt32_low(struct nfp_prog *nfp_prog, u8 dst, u8 src)\n{\n\temit_alu(nfp_prog, reg_none(), reg_a(src), ALU_OP_OR, reg_imm(0));\n\temit_shf_indir(nfp_prog, reg_both(dst), reg_none(), SHF_OP_NONE,\n\t\t       reg_b(dst), SHF_SC_L_SHF);\n}\n\nstatic void shl_reg64_lt32(struct nfp_prog *nfp_prog, u8 dst, u8 src)\n{\n\tshl_reg64_lt32_high(nfp_prog, dst, src);\n\tshl_reg64_lt32_low(nfp_prog, dst, src);\n}\n\nstatic void shl_reg64_ge32(struct nfp_prog *nfp_prog, u8 dst, u8 src)\n{\n\temit_alu(nfp_prog, reg_none(), reg_a(src), ALU_OP_OR, reg_imm(0));\n\temit_shf_indir(nfp_prog, reg_both(dst + 1), reg_none(), SHF_OP_NONE,\n\t\t       reg_b(dst), SHF_SC_L_SHF);\n\twrp_immed(nfp_prog, reg_both(dst), 0);\n}\n\nstatic int shl_reg64(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\n{\n\tconst struct bpf_insn *insn = &meta->insn;\n\tu64 umin, umax;\n\tu8 dst, src;\n\n\tdst = insn->dst_reg * 2;\n\tumin = meta->umin_src;\n\tumax = meta->umax_src;\n\tif (umin == umax)\n\t\treturn __shl_imm64(nfp_prog, dst, umin);\n\n\tsrc = insn->src_reg * 2;\n\tif (umax < 32) {\n\t\tshl_reg64_lt32(nfp_prog, dst, src);\n\t} else if (umin >= 32) {\n\t\tshl_reg64_ge32(nfp_prog, dst, src);\n\t} else {\n\t\t \n\t\tu16 label_ge32, label_end;\n\n\t\tlabel_ge32 = nfp_prog_current_offset(nfp_prog) + 7;\n\t\temit_br_bset(nfp_prog, reg_a(src), 5, label_ge32, 0);\n\n\t\tshl_reg64_lt32_high(nfp_prog, dst, src);\n\t\tlabel_end = nfp_prog_current_offset(nfp_prog) + 6;\n\t\temit_br(nfp_prog, BR_UNC, label_end, 2);\n\t\t \n\t\tshl_reg64_lt32_low(nfp_prog, dst, src);\n\n\t\tif (!nfp_prog_confirm_current_offset(nfp_prog, label_ge32))\n\t\t\treturn -EINVAL;\n\t\tshl_reg64_ge32(nfp_prog, dst, src);\n\n\t\tif (!nfp_prog_confirm_current_offset(nfp_prog, label_end))\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int __shr_imm64(struct nfp_prog *nfp_prog, u8 dst, u8 shift_amt)\n{\n\tif (!shift_amt)\n\t\treturn 0;\n\n\tif (shift_amt < 32) {\n\t\temit_shf(nfp_prog, reg_both(dst), reg_a(dst + 1), SHF_OP_NONE,\n\t\t\t reg_b(dst), SHF_SC_R_DSHF, shift_amt);\n\t\temit_shf(nfp_prog, reg_both(dst + 1), reg_none(), SHF_OP_NONE,\n\t\t\t reg_b(dst + 1), SHF_SC_R_SHF, shift_amt);\n\t} else if (shift_amt == 32) {\n\t\twrp_reg_mov(nfp_prog, dst, dst + 1);\n\t\twrp_immed(nfp_prog, reg_both(dst + 1), 0);\n\t} else if (shift_amt > 32) {\n\t\temit_shf(nfp_prog, reg_both(dst), reg_none(), SHF_OP_NONE,\n\t\t\t reg_b(dst + 1), SHF_SC_R_SHF, shift_amt - 32);\n\t\twrp_immed(nfp_prog, reg_both(dst + 1), 0);\n\t}\n\n\treturn 0;\n}\n\nstatic int shr_imm64(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\n{\n\tconst struct bpf_insn *insn = &meta->insn;\n\tu8 dst = insn->dst_reg * 2;\n\n\treturn __shr_imm64(nfp_prog, dst, insn->imm);\n}\n\n \nstatic void shr_reg64_lt32_high(struct nfp_prog *nfp_prog, u8 dst, u8 src)\n{\n\temit_alu(nfp_prog, reg_none(), reg_a(src), ALU_OP_OR, reg_imm(0));\n\temit_shf_indir(nfp_prog, reg_both(dst + 1), reg_none(), SHF_OP_NONE,\n\t\t       reg_b(dst + 1), SHF_SC_R_SHF);\n}\n\nstatic void shr_reg64_lt32_low(struct nfp_prog *nfp_prog, u8 dst, u8 src)\n{\n\temit_alu(nfp_prog, reg_none(), reg_a(src), ALU_OP_OR, reg_imm(0));\n\temit_shf_indir(nfp_prog, reg_both(dst), reg_a(dst + 1), SHF_OP_NONE,\n\t\t       reg_b(dst), SHF_SC_R_DSHF);\n}\n\nstatic void shr_reg64_lt32(struct nfp_prog *nfp_prog, u8 dst, u8 src)\n{\n\tshr_reg64_lt32_low(nfp_prog, dst, src);\n\tshr_reg64_lt32_high(nfp_prog, dst, src);\n}\n\nstatic void shr_reg64_ge32(struct nfp_prog *nfp_prog, u8 dst, u8 src)\n{\n\temit_alu(nfp_prog, reg_none(), reg_a(src), ALU_OP_OR, reg_imm(0));\n\temit_shf_indir(nfp_prog, reg_both(dst), reg_none(), SHF_OP_NONE,\n\t\t       reg_b(dst + 1), SHF_SC_R_SHF);\n\twrp_immed(nfp_prog, reg_both(dst + 1), 0);\n}\n\nstatic int shr_reg64(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\n{\n\tconst struct bpf_insn *insn = &meta->insn;\n\tu64 umin, umax;\n\tu8 dst, src;\n\n\tdst = insn->dst_reg * 2;\n\tumin = meta->umin_src;\n\tumax = meta->umax_src;\n\tif (umin == umax)\n\t\treturn __shr_imm64(nfp_prog, dst, umin);\n\n\tsrc = insn->src_reg * 2;\n\tif (umax < 32) {\n\t\tshr_reg64_lt32(nfp_prog, dst, src);\n\t} else if (umin >= 32) {\n\t\tshr_reg64_ge32(nfp_prog, dst, src);\n\t} else {\n\t\t \n\t\tu16 label_ge32, label_end;\n\n\t\tlabel_ge32 = nfp_prog_current_offset(nfp_prog) + 6;\n\t\temit_br_bset(nfp_prog, reg_a(src), 5, label_ge32, 0);\n\t\tshr_reg64_lt32_low(nfp_prog, dst, src);\n\t\tlabel_end = nfp_prog_current_offset(nfp_prog) + 6;\n\t\temit_br(nfp_prog, BR_UNC, label_end, 2);\n\t\t \n\t\tshr_reg64_lt32_high(nfp_prog, dst, src);\n\n\t\tif (!nfp_prog_confirm_current_offset(nfp_prog, label_ge32))\n\t\t\treturn -EINVAL;\n\t\tshr_reg64_ge32(nfp_prog, dst, src);\n\n\t\tif (!nfp_prog_confirm_current_offset(nfp_prog, label_end))\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int __ashr_imm64(struct nfp_prog *nfp_prog, u8 dst, u8 shift_amt)\n{\n\tif (!shift_amt)\n\t\treturn 0;\n\n\tif (shift_amt < 32) {\n\t\temit_shf(nfp_prog, reg_both(dst), reg_a(dst + 1), SHF_OP_NONE,\n\t\t\t reg_b(dst), SHF_SC_R_DSHF, shift_amt);\n\t\t \n\t\temit_alu(nfp_prog, reg_none(), reg_a(dst + 1), ALU_OP_OR,\n\t\t\t reg_imm(0));\n\t\temit_shf(nfp_prog, reg_both(dst + 1), reg_none(), SHF_OP_ASHR,\n\t\t\t reg_b(dst + 1), SHF_SC_R_SHF, shift_amt);\n\t} else if (shift_amt == 32) {\n\t\t \n\t\twrp_reg_mov(nfp_prog, dst, dst + 1);\n\t\temit_shf(nfp_prog, reg_both(dst + 1), reg_none(), SHF_OP_ASHR,\n\t\t\t reg_b(dst + 1), SHF_SC_R_SHF, 31);\n\t} else if (shift_amt > 32) {\n\t\temit_alu(nfp_prog, reg_none(), reg_a(dst + 1), ALU_OP_OR,\n\t\t\t reg_imm(0));\n\t\temit_shf(nfp_prog, reg_both(dst), reg_none(), SHF_OP_ASHR,\n\t\t\t reg_b(dst + 1), SHF_SC_R_SHF, shift_amt - 32);\n\t\temit_shf(nfp_prog, reg_both(dst + 1), reg_none(), SHF_OP_ASHR,\n\t\t\t reg_b(dst + 1), SHF_SC_R_SHF, 31);\n\t}\n\n\treturn 0;\n}\n\nstatic int ashr_imm64(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\n{\n\tconst struct bpf_insn *insn = &meta->insn;\n\tu8 dst = insn->dst_reg * 2;\n\n\treturn __ashr_imm64(nfp_prog, dst, insn->imm);\n}\n\nstatic void ashr_reg64_lt32_high(struct nfp_prog *nfp_prog, u8 dst, u8 src)\n{\n\t \n\temit_alu(nfp_prog, reg_none(), reg_a(src), ALU_OP_OR, reg_b(dst + 1));\n\temit_shf_indir(nfp_prog, reg_both(dst + 1), reg_none(), SHF_OP_ASHR,\n\t\t       reg_b(dst + 1), SHF_SC_R_SHF);\n}\n\nstatic void ashr_reg64_lt32_low(struct nfp_prog *nfp_prog, u8 dst, u8 src)\n{\n\t \n\treturn shr_reg64_lt32_low(nfp_prog, dst, src);\n}\n\nstatic void ashr_reg64_lt32(struct nfp_prog *nfp_prog, u8 dst, u8 src)\n{\n\tashr_reg64_lt32_low(nfp_prog, dst, src);\n\tashr_reg64_lt32_high(nfp_prog, dst, src);\n}\n\nstatic void ashr_reg64_ge32(struct nfp_prog *nfp_prog, u8 dst, u8 src)\n{\n\temit_alu(nfp_prog, reg_none(), reg_a(src), ALU_OP_OR, reg_b(dst + 1));\n\temit_shf_indir(nfp_prog, reg_both(dst), reg_none(), SHF_OP_ASHR,\n\t\t       reg_b(dst + 1), SHF_SC_R_SHF);\n\temit_shf(nfp_prog, reg_both(dst + 1), reg_none(), SHF_OP_ASHR,\n\t\t reg_b(dst + 1), SHF_SC_R_SHF, 31);\n}\n\n \nstatic int ashr_reg64(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\n{\n\tconst struct bpf_insn *insn = &meta->insn;\n\tu64 umin, umax;\n\tu8 dst, src;\n\n\tdst = insn->dst_reg * 2;\n\tumin = meta->umin_src;\n\tumax = meta->umax_src;\n\tif (umin == umax)\n\t\treturn __ashr_imm64(nfp_prog, dst, umin);\n\n\tsrc = insn->src_reg * 2;\n\tif (umax < 32) {\n\t\tashr_reg64_lt32(nfp_prog, dst, src);\n\t} else if (umin >= 32) {\n\t\tashr_reg64_ge32(nfp_prog, dst, src);\n\t} else {\n\t\tu16 label_ge32, label_end;\n\n\t\tlabel_ge32 = nfp_prog_current_offset(nfp_prog) + 6;\n\t\temit_br_bset(nfp_prog, reg_a(src), 5, label_ge32, 0);\n\t\tashr_reg64_lt32_low(nfp_prog, dst, src);\n\t\tlabel_end = nfp_prog_current_offset(nfp_prog) + 6;\n\t\temit_br(nfp_prog, BR_UNC, label_end, 2);\n\t\t \n\t\tashr_reg64_lt32_high(nfp_prog, dst, src);\n\n\t\tif (!nfp_prog_confirm_current_offset(nfp_prog, label_ge32))\n\t\t\treturn -EINVAL;\n\t\tashr_reg64_ge32(nfp_prog, dst, src);\n\n\t\tif (!nfp_prog_confirm_current_offset(nfp_prog, label_end))\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int mov_reg(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\n{\n\tconst struct bpf_insn *insn = &meta->insn;\n\n\twrp_reg_mov(nfp_prog, insn->dst_reg * 2,  insn->src_reg * 2);\n\twrp_immed(nfp_prog, reg_both(insn->dst_reg * 2 + 1), 0);\n\n\treturn 0;\n}\n\nstatic int mov_imm(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\n{\n\tconst struct bpf_insn *insn = &meta->insn;\n\n\twrp_immed(nfp_prog, reg_both(insn->dst_reg * 2), insn->imm);\n\twrp_immed(nfp_prog, reg_both(insn->dst_reg * 2 + 1), 0);\n\n\treturn 0;\n}\n\nstatic int xor_reg(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\n{\n\treturn wrp_alu32_reg(nfp_prog, meta, ALU_OP_XOR);\n}\n\nstatic int xor_imm(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\n{\n\treturn wrp_alu32_imm(nfp_prog, meta, ALU_OP_XOR);\n}\n\nstatic int and_reg(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\n{\n\treturn wrp_alu32_reg(nfp_prog, meta, ALU_OP_AND);\n}\n\nstatic int and_imm(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\n{\n\treturn wrp_alu32_imm(nfp_prog, meta, ALU_OP_AND);\n}\n\nstatic int or_reg(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\n{\n\treturn wrp_alu32_reg(nfp_prog, meta, ALU_OP_OR);\n}\n\nstatic int or_imm(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\n{\n\treturn wrp_alu32_imm(nfp_prog, meta, ALU_OP_OR);\n}\n\nstatic int add_reg(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\n{\n\treturn wrp_alu32_reg(nfp_prog, meta, ALU_OP_ADD);\n}\n\nstatic int add_imm(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\n{\n\treturn wrp_alu32_imm(nfp_prog, meta, ALU_OP_ADD);\n}\n\nstatic int sub_reg(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\n{\n\treturn wrp_alu32_reg(nfp_prog, meta, ALU_OP_SUB);\n}\n\nstatic int sub_imm(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\n{\n\treturn wrp_alu32_imm(nfp_prog, meta, ALU_OP_SUB);\n}\n\nstatic int mul_reg(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\n{\n\treturn wrp_mul(nfp_prog, meta, false, true);\n}\n\nstatic int mul_imm(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\n{\n\treturn wrp_mul(nfp_prog, meta, false, false);\n}\n\nstatic int div_reg(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\n{\n\treturn div_reg64(nfp_prog, meta);\n}\n\nstatic int div_imm(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\n{\n\treturn div_imm64(nfp_prog, meta);\n}\n\nstatic int neg_reg(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\n{\n\tu8 dst = meta->insn.dst_reg * 2;\n\n\temit_alu(nfp_prog, reg_both(dst), reg_imm(0), ALU_OP_SUB, reg_b(dst));\n\twrp_zext(nfp_prog, meta, dst);\n\n\treturn 0;\n}\n\nstatic int\n__ashr_imm(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta, u8 dst,\n\t   u8 shift_amt)\n{\n\tif (shift_amt) {\n\t\t \n\t\temit_alu(nfp_prog, reg_none(), reg_a(dst), ALU_OP_OR,\n\t\t\t reg_imm(0));\n\t\temit_shf(nfp_prog, reg_both(dst), reg_none(), SHF_OP_ASHR,\n\t\t\t reg_b(dst), SHF_SC_R_SHF, shift_amt);\n\t}\n\twrp_zext(nfp_prog, meta, dst);\n\n\treturn 0;\n}\n\nstatic int ashr_reg(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\n{\n\tconst struct bpf_insn *insn = &meta->insn;\n\tu64 umin, umax;\n\tu8 dst, src;\n\n\tdst = insn->dst_reg * 2;\n\tumin = meta->umin_src;\n\tumax = meta->umax_src;\n\tif (umin == umax)\n\t\treturn __ashr_imm(nfp_prog, meta, dst, umin);\n\n\tsrc = insn->src_reg * 2;\n\t \n\temit_alu(nfp_prog, reg_none(), reg_a(src), ALU_OP_OR, reg_b(dst));\n\temit_shf_indir(nfp_prog, reg_both(dst), reg_none(), SHF_OP_ASHR,\n\t\t       reg_b(dst), SHF_SC_R_SHF);\n\twrp_zext(nfp_prog, meta, dst);\n\n\treturn 0;\n}\n\nstatic int ashr_imm(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\n{\n\tconst struct bpf_insn *insn = &meta->insn;\n\tu8 dst = insn->dst_reg * 2;\n\n\treturn __ashr_imm(nfp_prog, meta, dst, insn->imm);\n}\n\nstatic int\n__shr_imm(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta, u8 dst,\n\t  u8 shift_amt)\n{\n\tif (shift_amt)\n\t\temit_shf(nfp_prog, reg_both(dst), reg_none(), SHF_OP_NONE,\n\t\t\t reg_b(dst), SHF_SC_R_SHF, shift_amt);\n\twrp_zext(nfp_prog, meta, dst);\n\treturn 0;\n}\n\nstatic int shr_imm(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\n{\n\tconst struct bpf_insn *insn = &meta->insn;\n\tu8 dst = insn->dst_reg * 2;\n\n\treturn __shr_imm(nfp_prog, meta, dst, insn->imm);\n}\n\nstatic int shr_reg(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\n{\n\tconst struct bpf_insn *insn = &meta->insn;\n\tu64 umin, umax;\n\tu8 dst, src;\n\n\tdst = insn->dst_reg * 2;\n\tumin = meta->umin_src;\n\tumax = meta->umax_src;\n\tif (umin == umax)\n\t\treturn __shr_imm(nfp_prog, meta, dst, umin);\n\n\tsrc = insn->src_reg * 2;\n\temit_alu(nfp_prog, reg_none(), reg_a(src), ALU_OP_OR, reg_imm(0));\n\temit_shf_indir(nfp_prog, reg_both(dst), reg_none(), SHF_OP_NONE,\n\t\t       reg_b(dst), SHF_SC_R_SHF);\n\twrp_zext(nfp_prog, meta, dst);\n\treturn 0;\n}\n\nstatic int\n__shl_imm(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta, u8 dst,\n\t  u8 shift_amt)\n{\n\tif (shift_amt)\n\t\temit_shf(nfp_prog, reg_both(dst), reg_none(), SHF_OP_NONE,\n\t\t\t reg_b(dst), SHF_SC_L_SHF, shift_amt);\n\twrp_zext(nfp_prog, meta, dst);\n\treturn 0;\n}\n\nstatic int shl_imm(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\n{\n\tconst struct bpf_insn *insn = &meta->insn;\n\tu8 dst = insn->dst_reg * 2;\n\n\treturn __shl_imm(nfp_prog, meta, dst, insn->imm);\n}\n\nstatic int shl_reg(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\n{\n\tconst struct bpf_insn *insn = &meta->insn;\n\tu64 umin, umax;\n\tu8 dst, src;\n\n\tdst = insn->dst_reg * 2;\n\tumin = meta->umin_src;\n\tumax = meta->umax_src;\n\tif (umin == umax)\n\t\treturn __shl_imm(nfp_prog, meta, dst, umin);\n\n\tsrc = insn->src_reg * 2;\n\tshl_reg64_lt32_low(nfp_prog, dst, src);\n\twrp_zext(nfp_prog, meta, dst);\n\treturn 0;\n}\n\nstatic int end_reg32(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\n{\n\tconst struct bpf_insn *insn = &meta->insn;\n\tu8 gpr = insn->dst_reg * 2;\n\n\tswitch (insn->imm) {\n\tcase 16:\n\t\temit_ld_field(nfp_prog, reg_both(gpr), 0x9, reg_b(gpr),\n\t\t\t      SHF_SC_R_ROT, 8);\n\t\temit_ld_field(nfp_prog, reg_both(gpr), 0xe, reg_a(gpr),\n\t\t\t      SHF_SC_R_SHF, 16);\n\n\t\twrp_immed(nfp_prog, reg_both(gpr + 1), 0);\n\t\tbreak;\n\tcase 32:\n\t\twrp_end32(nfp_prog, reg_a(gpr), gpr);\n\t\twrp_immed(nfp_prog, reg_both(gpr + 1), 0);\n\t\tbreak;\n\tcase 64:\n\t\twrp_mov(nfp_prog, imm_a(nfp_prog), reg_b(gpr + 1));\n\n\t\twrp_end32(nfp_prog, reg_a(gpr), gpr + 1);\n\t\twrp_end32(nfp_prog, imm_a(nfp_prog), gpr);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int imm_ld8_part2(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\n{\n\tstruct nfp_insn_meta *prev = nfp_meta_prev(meta);\n\tu32 imm_lo, imm_hi;\n\tu8 dst;\n\n\tdst = prev->insn.dst_reg * 2;\n\timm_lo = prev->insn.imm;\n\timm_hi = meta->insn.imm;\n\n\twrp_immed(nfp_prog, reg_both(dst), imm_lo);\n\n\t \n\tif (imm_hi == imm_lo)\n\t\twrp_mov(nfp_prog, reg_both(dst + 1), reg_a(dst));\n\telse\n\t\twrp_immed(nfp_prog, reg_both(dst + 1), imm_hi);\n\n\treturn 0;\n}\n\nstatic int imm_ld8(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\n{\n\tmeta->double_cb = imm_ld8_part2;\n\treturn 0;\n}\n\nstatic int data_ld1(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\n{\n\treturn construct_data_ld(nfp_prog, meta, meta->insn.imm, 1);\n}\n\nstatic int data_ld2(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\n{\n\treturn construct_data_ld(nfp_prog, meta, meta->insn.imm, 2);\n}\n\nstatic int data_ld4(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\n{\n\treturn construct_data_ld(nfp_prog, meta, meta->insn.imm, 4);\n}\n\nstatic int data_ind_ld1(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\n{\n\treturn construct_data_ind_ld(nfp_prog, meta, meta->insn.imm,\n\t\t\t\t     meta->insn.src_reg * 2, 1);\n}\n\nstatic int data_ind_ld2(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\n{\n\treturn construct_data_ind_ld(nfp_prog, meta, meta->insn.imm,\n\t\t\t\t     meta->insn.src_reg * 2, 2);\n}\n\nstatic int data_ind_ld4(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\n{\n\treturn construct_data_ind_ld(nfp_prog, meta, meta->insn.imm,\n\t\t\t\t     meta->insn.src_reg * 2, 4);\n}\n\nstatic int\nmem_ldx_stack(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta,\n\t      unsigned int size, unsigned int ptr_off)\n{\n\treturn mem_op_stack(nfp_prog, meta, size, ptr_off,\n\t\t\t    meta->insn.dst_reg * 2, meta->insn.src_reg * 2,\n\t\t\t    true, wrp_lmem_load);\n}\n\nstatic int mem_ldx_skb(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta,\n\t\t       u8 size)\n{\n\tswreg dst = reg_both(meta->insn.dst_reg * 2);\n\n\tswitch (meta->insn.off) {\n\tcase offsetof(struct __sk_buff, len):\n\t\tif (size != sizeof_field(struct __sk_buff, len))\n\t\t\treturn -EOPNOTSUPP;\n\t\twrp_mov(nfp_prog, dst, plen_reg(nfp_prog));\n\t\tbreak;\n\tcase offsetof(struct __sk_buff, data):\n\t\tif (size != sizeof_field(struct __sk_buff, data))\n\t\t\treturn -EOPNOTSUPP;\n\t\twrp_mov(nfp_prog, dst, pptr_reg(nfp_prog));\n\t\tbreak;\n\tcase offsetof(struct __sk_buff, data_end):\n\t\tif (size != sizeof_field(struct __sk_buff, data_end))\n\t\t\treturn -EOPNOTSUPP;\n\t\temit_alu(nfp_prog, dst,\n\t\t\t plen_reg(nfp_prog), ALU_OP_ADD, pptr_reg(nfp_prog));\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\twrp_immed(nfp_prog, reg_both(meta->insn.dst_reg * 2 + 1), 0);\n\n\treturn 0;\n}\n\nstatic int mem_ldx_xdp(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta,\n\t\t       u8 size)\n{\n\tswreg dst = reg_both(meta->insn.dst_reg * 2);\n\n\tswitch (meta->insn.off) {\n\tcase offsetof(struct xdp_md, data):\n\t\tif (size != sizeof_field(struct xdp_md, data))\n\t\t\treturn -EOPNOTSUPP;\n\t\twrp_mov(nfp_prog, dst, pptr_reg(nfp_prog));\n\t\tbreak;\n\tcase offsetof(struct xdp_md, data_end):\n\t\tif (size != sizeof_field(struct xdp_md, data_end))\n\t\t\treturn -EOPNOTSUPP;\n\t\temit_alu(nfp_prog, dst,\n\t\t\t plen_reg(nfp_prog), ALU_OP_ADD, pptr_reg(nfp_prog));\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\twrp_immed(nfp_prog, reg_both(meta->insn.dst_reg * 2 + 1), 0);\n\n\treturn 0;\n}\n\nstatic int\nmem_ldx_data(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta,\n\t     unsigned int size)\n{\n\tswreg tmp_reg;\n\n\ttmp_reg = re_load_imm_any(nfp_prog, meta->insn.off, imm_b(nfp_prog));\n\n\treturn data_ld_host_order_addr32(nfp_prog, meta, meta->insn.src_reg * 2,\n\t\t\t\t\t tmp_reg, meta->insn.dst_reg * 2, size);\n}\n\nstatic int\nmem_ldx_emem(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta,\n\t     unsigned int size)\n{\n\tswreg tmp_reg;\n\n\ttmp_reg = re_load_imm_any(nfp_prog, meta->insn.off, imm_b(nfp_prog));\n\n\treturn data_ld_host_order_addr40(nfp_prog, meta, meta->insn.src_reg * 2,\n\t\t\t\t\t tmp_reg, meta->insn.dst_reg * 2, size);\n}\n\nstatic void\nmem_ldx_data_init_pktcache(struct nfp_prog *nfp_prog,\n\t\t\t   struct nfp_insn_meta *meta)\n{\n\ts16 range_start = meta->pkt_cache.range_start;\n\ts16 range_end = meta->pkt_cache.range_end;\n\tswreg src_base, off;\n\tu8 xfer_num, len;\n\tbool indir;\n\n\toff = re_load_imm_any(nfp_prog, range_start, imm_b(nfp_prog));\n\tsrc_base = reg_a(meta->insn.src_reg * 2);\n\tlen = range_end - range_start;\n\txfer_num = round_up(len, REG_WIDTH) / REG_WIDTH;\n\n\tindir = len > 8 * REG_WIDTH;\n\t \n\tif (indir)\n\t\twrp_immed(nfp_prog, reg_none(),\n\t\t\t  CMD_OVE_LEN | FIELD_PREP(CMD_OV_LEN, xfer_num - 1));\n\n\t \n\temit_cmd_any(nfp_prog, CMD_TGT_READ32_SWAP, CMD_MODE_32b, 0, src_base,\n\t\t     off, xfer_num - 1, CMD_CTX_SWAP, indir);\n}\n\nstatic int\nmem_ldx_data_from_pktcache_unaligned(struct nfp_prog *nfp_prog,\n\t\t\t\t     struct nfp_insn_meta *meta,\n\t\t\t\t     unsigned int size)\n{\n\ts16 range_start = meta->pkt_cache.range_start;\n\ts16 insn_off = meta->insn.off - range_start;\n\tswreg dst_lo, dst_hi, src_lo, src_mid;\n\tu8 dst_gpr = meta->insn.dst_reg * 2;\n\tu8 len_lo = size, len_mid = 0;\n\tu8 idx = insn_off / REG_WIDTH;\n\tu8 off = insn_off % REG_WIDTH;\n\n\tdst_hi = reg_both(dst_gpr + 1);\n\tdst_lo = reg_both(dst_gpr);\n\tsrc_lo = reg_xfer(idx);\n\n\t \n\tif (size > REG_WIDTH - off) {\n\t\t \n\t\tlen_lo = REG_WIDTH - off;\n\t\tlen_mid = size - len_lo;\n\n\t\t \n\t\tif (size > 2 * REG_WIDTH - off)\n\t\t\tlen_mid = REG_WIDTH;\n\t}\n\n\twrp_reg_subpart(nfp_prog, dst_lo, src_lo, len_lo, off);\n\n\tif (!len_mid) {\n\t\twrp_zext(nfp_prog, meta, dst_gpr);\n\t\treturn 0;\n\t}\n\n\tsrc_mid = reg_xfer(idx + 1);\n\n\tif (size <= REG_WIDTH) {\n\t\twrp_reg_or_subpart(nfp_prog, dst_lo, src_mid, len_mid, len_lo);\n\t\twrp_zext(nfp_prog, meta, dst_gpr);\n\t} else {\n\t\tswreg src_hi = reg_xfer(idx + 2);\n\n\t\twrp_reg_or_subpart(nfp_prog, dst_lo, src_mid,\n\t\t\t\t   REG_WIDTH - len_lo, len_lo);\n\t\twrp_reg_subpart(nfp_prog, dst_hi, src_mid, len_lo,\n\t\t\t\tREG_WIDTH - len_lo);\n\t\twrp_reg_or_subpart(nfp_prog, dst_hi, src_hi, REG_WIDTH - len_lo,\n\t\t\t\t   len_lo);\n\t}\n\n\treturn 0;\n}\n\nstatic int\nmem_ldx_data_from_pktcache_aligned(struct nfp_prog *nfp_prog,\n\t\t\t\t   struct nfp_insn_meta *meta,\n\t\t\t\t   unsigned int size)\n{\n\tswreg dst_lo, dst_hi, src_lo;\n\tu8 dst_gpr, idx;\n\n\tidx = (meta->insn.off - meta->pkt_cache.range_start) / REG_WIDTH;\n\tdst_gpr = meta->insn.dst_reg * 2;\n\tdst_hi = reg_both(dst_gpr + 1);\n\tdst_lo = reg_both(dst_gpr);\n\tsrc_lo = reg_xfer(idx);\n\n\tif (size < REG_WIDTH) {\n\t\twrp_reg_subpart(nfp_prog, dst_lo, src_lo, size, 0);\n\t\twrp_zext(nfp_prog, meta, dst_gpr);\n\t} else if (size == REG_WIDTH) {\n\t\twrp_mov(nfp_prog, dst_lo, src_lo);\n\t\twrp_zext(nfp_prog, meta, dst_gpr);\n\t} else {\n\t\tswreg src_hi = reg_xfer(idx + 1);\n\n\t\twrp_mov(nfp_prog, dst_lo, src_lo);\n\t\twrp_mov(nfp_prog, dst_hi, src_hi);\n\t}\n\n\treturn 0;\n}\n\nstatic int\nmem_ldx_data_from_pktcache(struct nfp_prog *nfp_prog,\n\t\t\t   struct nfp_insn_meta *meta, unsigned int size)\n{\n\tu8 off = meta->insn.off - meta->pkt_cache.range_start;\n\n\tif (IS_ALIGNED(off, REG_WIDTH))\n\t\treturn mem_ldx_data_from_pktcache_aligned(nfp_prog, meta, size);\n\n\treturn mem_ldx_data_from_pktcache_unaligned(nfp_prog, meta, size);\n}\n\nstatic int\nmem_ldx(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta,\n\tunsigned int size)\n{\n\tif (meta->ldst_gather_len)\n\t\treturn nfp_cpp_memcpy(nfp_prog, meta);\n\n\tif (meta->ptr.type == PTR_TO_CTX) {\n\t\tif (nfp_prog->type == BPF_PROG_TYPE_XDP)\n\t\t\treturn mem_ldx_xdp(nfp_prog, meta, size);\n\t\telse\n\t\t\treturn mem_ldx_skb(nfp_prog, meta, size);\n\t}\n\n\tif (meta->ptr.type == PTR_TO_PACKET) {\n\t\tif (meta->pkt_cache.range_end) {\n\t\t\tif (meta->pkt_cache.do_init)\n\t\t\t\tmem_ldx_data_init_pktcache(nfp_prog, meta);\n\n\t\t\treturn mem_ldx_data_from_pktcache(nfp_prog, meta, size);\n\t\t} else {\n\t\t\treturn mem_ldx_data(nfp_prog, meta, size);\n\t\t}\n\t}\n\n\tif (meta->ptr.type == PTR_TO_STACK)\n\t\treturn mem_ldx_stack(nfp_prog, meta, size,\n\t\t\t\t     meta->ptr.off + meta->ptr.var_off.value);\n\n\tif (meta->ptr.type == PTR_TO_MAP_VALUE)\n\t\treturn mem_ldx_emem(nfp_prog, meta, size);\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic int mem_ldx1(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\n{\n\treturn mem_ldx(nfp_prog, meta, 1);\n}\n\nstatic int mem_ldx2(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\n{\n\treturn mem_ldx(nfp_prog, meta, 2);\n}\n\nstatic int mem_ldx4(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\n{\n\treturn mem_ldx(nfp_prog, meta, 4);\n}\n\nstatic int mem_ldx8(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\n{\n\treturn mem_ldx(nfp_prog, meta, 8);\n}\n\nstatic int\nmem_st_data(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta,\n\t    unsigned int size)\n{\n\tu64 imm = meta->insn.imm;  \n\tswreg off_reg;\n\n\toff_reg = re_load_imm_any(nfp_prog, meta->insn.off, imm_b(nfp_prog));\n\n\treturn data_st_host_order(nfp_prog, meta->insn.dst_reg * 2, off_reg,\n\t\t\t\t  imm, size);\n}\n\nstatic int mem_st(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta,\n\t\t  unsigned int size)\n{\n\tif (meta->ptr.type == PTR_TO_PACKET)\n\t\treturn mem_st_data(nfp_prog, meta, size);\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic int mem_st1(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\n{\n\treturn mem_st(nfp_prog, meta, 1);\n}\n\nstatic int mem_st2(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\n{\n\treturn mem_st(nfp_prog, meta, 2);\n}\n\nstatic int mem_st4(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\n{\n\treturn mem_st(nfp_prog, meta, 4);\n}\n\nstatic int mem_st8(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\n{\n\treturn mem_st(nfp_prog, meta, 8);\n}\n\nstatic int\nmem_stx_data(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta,\n\t     unsigned int size)\n{\n\tswreg off_reg;\n\n\toff_reg = re_load_imm_any(nfp_prog, meta->insn.off, imm_b(nfp_prog));\n\n\treturn data_stx_host_order(nfp_prog, meta->insn.dst_reg * 2, off_reg,\n\t\t\t\t   meta->insn.src_reg * 2, size);\n}\n\nstatic int\nmem_stx_stack(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta,\n\t      unsigned int size, unsigned int ptr_off)\n{\n\treturn mem_op_stack(nfp_prog, meta, size, ptr_off,\n\t\t\t    meta->insn.src_reg * 2, meta->insn.dst_reg * 2,\n\t\t\t    false, wrp_lmem_store);\n}\n\nstatic int mem_stx_xdp(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\n{\n\tswitch (meta->insn.off) {\n\tcase offsetof(struct xdp_md, rx_queue_index):\n\t\treturn nfp_queue_select(nfp_prog, meta);\n\t}\n\n\tWARN_ON_ONCE(1);  \n\treturn -EOPNOTSUPP;\n}\n\nstatic int\nmem_stx(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta,\n\tunsigned int size)\n{\n\tif (meta->ptr.type == PTR_TO_PACKET)\n\t\treturn mem_stx_data(nfp_prog, meta, size);\n\n\tif (meta->ptr.type == PTR_TO_STACK)\n\t\treturn mem_stx_stack(nfp_prog, meta, size,\n\t\t\t\t     meta->ptr.off + meta->ptr.var_off.value);\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic int mem_stx1(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\n{\n\treturn mem_stx(nfp_prog, meta, 1);\n}\n\nstatic int mem_stx2(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\n{\n\treturn mem_stx(nfp_prog, meta, 2);\n}\n\nstatic int mem_stx4(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\n{\n\tif (meta->ptr.type == PTR_TO_CTX)\n\t\tif (nfp_prog->type == BPF_PROG_TYPE_XDP)\n\t\t\treturn mem_stx_xdp(nfp_prog, meta);\n\treturn mem_stx(nfp_prog, meta, 4);\n}\n\nstatic int mem_stx8(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\n{\n\treturn mem_stx(nfp_prog, meta, 8);\n}\n\nstatic int\nmem_xadd(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta, bool is64)\n{\n\tu8 dst_gpr = meta->insn.dst_reg * 2;\n\tu8 src_gpr = meta->insn.src_reg * 2;\n\tunsigned int full_add, out;\n\tswreg addra, addrb, off;\n\n\toff = ur_load_imm_any(nfp_prog, meta->insn.off, imm_b(nfp_prog));\n\n\t \n\tout = nfp_prog_current_offset(nfp_prog);\n\tfull_add = nfp_prog_current_offset(nfp_prog);\n\n\tif (meta->insn.off) {\n\t\tout += 2;\n\t\tfull_add += 2;\n\t}\n\tif (meta->xadd_maybe_16bit) {\n\t\tout += 3;\n\t\tfull_add += 3;\n\t}\n\tif (meta->xadd_over_16bit)\n\t\tout += 2 + is64;\n\tif (meta->xadd_maybe_16bit && meta->xadd_over_16bit) {\n\t\tout += 5;\n\t\tfull_add += 5;\n\t}\n\n\t \n\tif (meta->xadd_maybe_16bit && meta->xadd_over_16bit) {\n\t\tswreg max_imm = imm_a(nfp_prog);\n\n\t\twrp_immed(nfp_prog, max_imm, 0xffff);\n\t\temit_alu(nfp_prog, reg_none(),\n\t\t\t max_imm, ALU_OP_SUB, reg_b(src_gpr));\n\t\temit_alu(nfp_prog, reg_none(),\n\t\t\t reg_imm(0), ALU_OP_SUB_C, reg_b(src_gpr + 1));\n\t\temit_br(nfp_prog, BR_BLO, full_add, meta->insn.off ? 2 : 0);\n\t\t \n\t}\n\n\t \n\tif (!meta->insn.off) {\n\t\taddra = reg_a(dst_gpr);\n\t\taddrb = reg_b(dst_gpr + 1);\n\t} else {\n\t\temit_alu(nfp_prog, imma_a(nfp_prog),\n\t\t\t reg_a(dst_gpr), ALU_OP_ADD, off);\n\t\temit_alu(nfp_prog, imma_b(nfp_prog),\n\t\t\t reg_a(dst_gpr + 1), ALU_OP_ADD_C, reg_imm(0));\n\t\taddra = imma_a(nfp_prog);\n\t\taddrb = imma_b(nfp_prog);\n\t}\n\n\t \n\tif (meta->xadd_maybe_16bit) {\n\t\tswreg prev_alu = imm_a(nfp_prog);\n\n\t\twrp_immed(nfp_prog, prev_alu,\n\t\t\t  FIELD_PREP(CMD_OVE_DATA, 2) |\n\t\t\t  CMD_OVE_LEN |\n\t\t\t  FIELD_PREP(CMD_OV_LEN, 0x8 | is64 << 2));\n\t\twrp_reg_or_subpart(nfp_prog, prev_alu, reg_b(src_gpr), 2, 2);\n\t\temit_cmd_indir(nfp_prog, CMD_TGT_ADD_IMM, CMD_MODE_40b_BA, 0,\n\t\t\t       addra, addrb, 0, CMD_CTX_NO_SWAP);\n\n\t\tif (meta->xadd_over_16bit)\n\t\t\temit_br(nfp_prog, BR_UNC, out, 0);\n\t}\n\n\tif (!nfp_prog_confirm_current_offset(nfp_prog, full_add))\n\t\treturn -EINVAL;\n\n\t \n\tif (meta->xadd_over_16bit) {\n\t\temit_cmd(nfp_prog, CMD_TGT_ADD, CMD_MODE_40b_BA, 0,\n\t\t\t addra, addrb, is64 << 2,\n\t\t\t is64 ? CMD_CTX_SWAP_DEFER2 : CMD_CTX_SWAP_DEFER1);\n\n\t\twrp_mov(nfp_prog, reg_xfer(0), reg_a(src_gpr));\n\t\tif (is64)\n\t\t\twrp_mov(nfp_prog, reg_xfer(1), reg_a(src_gpr + 1));\n\t}\n\n\tif (!nfp_prog_confirm_current_offset(nfp_prog, out))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int mem_atomic4(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\n{\n\tif (meta->insn.imm != BPF_ADD)\n\t\treturn -EOPNOTSUPP;\n\n\treturn mem_xadd(nfp_prog, meta, false);\n}\n\nstatic int mem_atomic8(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\n{\n\tif (meta->insn.imm != BPF_ADD)\n\t\treturn -EOPNOTSUPP;\n\n\treturn mem_xadd(nfp_prog, meta, true);\n}\n\nstatic int jump(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\n{\n\temit_br(nfp_prog, BR_UNC, meta->insn.off, 0);\n\n\treturn 0;\n}\n\nstatic int jeq_imm(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\n{\n\tconst struct bpf_insn *insn = &meta->insn;\n\tu64 imm = insn->imm;  \n\tswreg or1, or2, tmp_reg;\n\n\tor1 = reg_a(insn->dst_reg * 2);\n\tor2 = reg_b(insn->dst_reg * 2 + 1);\n\n\tif (imm & ~0U) {\n\t\ttmp_reg = ur_load_imm_any(nfp_prog, imm & ~0U, imm_b(nfp_prog));\n\t\temit_alu(nfp_prog, imm_a(nfp_prog),\n\t\t\t reg_a(insn->dst_reg * 2), ALU_OP_XOR, tmp_reg);\n\t\tor1 = imm_a(nfp_prog);\n\t}\n\n\tif (imm >> 32) {\n\t\ttmp_reg = ur_load_imm_any(nfp_prog, imm >> 32, imm_b(nfp_prog));\n\t\temit_alu(nfp_prog, imm_b(nfp_prog),\n\t\t\t reg_a(insn->dst_reg * 2 + 1), ALU_OP_XOR, tmp_reg);\n\t\tor2 = imm_b(nfp_prog);\n\t}\n\n\temit_alu(nfp_prog, reg_none(), or1, ALU_OP_OR, or2);\n\temit_br(nfp_prog, BR_BEQ, insn->off, 0);\n\n\treturn 0;\n}\n\nstatic int jeq32_imm(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\n{\n\tconst struct bpf_insn *insn = &meta->insn;\n\tswreg tmp_reg;\n\n\ttmp_reg = ur_load_imm_any(nfp_prog, insn->imm, imm_b(nfp_prog));\n\temit_alu(nfp_prog, reg_none(),\n\t\t reg_a(insn->dst_reg * 2), ALU_OP_XOR, tmp_reg);\n\temit_br(nfp_prog, BR_BEQ, insn->off, 0);\n\n\treturn 0;\n}\n\nstatic int jset_imm(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\n{\n\tconst struct bpf_insn *insn = &meta->insn;\n\tu64 imm = insn->imm;  \n\tu8 dst_gpr = insn->dst_reg * 2;\n\tswreg tmp_reg;\n\n\ttmp_reg = ur_load_imm_any(nfp_prog, imm & ~0U, imm_b(nfp_prog));\n\temit_alu(nfp_prog, imm_b(nfp_prog),\n\t\t reg_a(dst_gpr), ALU_OP_AND, tmp_reg);\n\t \n\tif (is_mbpf_jmp64(meta) && imm >> 32) {\n\t\temit_alu(nfp_prog, reg_none(),\n\t\t\t reg_a(dst_gpr + 1), ALU_OP_OR, imm_b(nfp_prog));\n\t}\n\temit_br(nfp_prog, BR_BNE, insn->off, 0);\n\n\treturn 0;\n}\n\nstatic int jne_imm(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\n{\n\tconst struct bpf_insn *insn = &meta->insn;\n\tu64 imm = insn->imm;  \n\tbool is_jmp32 = is_mbpf_jmp32(meta);\n\tswreg tmp_reg;\n\n\tif (!imm) {\n\t\tif (is_jmp32)\n\t\t\temit_alu(nfp_prog, reg_none(), reg_none(), ALU_OP_NONE,\n\t\t\t\t reg_b(insn->dst_reg * 2));\n\t\telse\n\t\t\temit_alu(nfp_prog, reg_none(), reg_a(insn->dst_reg * 2),\n\t\t\t\t ALU_OP_OR, reg_b(insn->dst_reg * 2 + 1));\n\t\temit_br(nfp_prog, BR_BNE, insn->off, 0);\n\t\treturn 0;\n\t}\n\n\ttmp_reg = ur_load_imm_any(nfp_prog, imm & ~0U, imm_b(nfp_prog));\n\temit_alu(nfp_prog, reg_none(),\n\t\t reg_a(insn->dst_reg * 2), ALU_OP_XOR, tmp_reg);\n\temit_br(nfp_prog, BR_BNE, insn->off, 0);\n\n\tif (is_jmp32)\n\t\treturn 0;\n\n\ttmp_reg = ur_load_imm_any(nfp_prog, imm >> 32, imm_b(nfp_prog));\n\temit_alu(nfp_prog, reg_none(),\n\t\t reg_a(insn->dst_reg * 2 + 1), ALU_OP_XOR, tmp_reg);\n\temit_br(nfp_prog, BR_BNE, insn->off, 0);\n\n\treturn 0;\n}\n\nstatic int jeq_reg(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\n{\n\tconst struct bpf_insn *insn = &meta->insn;\n\n\temit_alu(nfp_prog, imm_a(nfp_prog), reg_a(insn->dst_reg * 2),\n\t\t ALU_OP_XOR, reg_b(insn->src_reg * 2));\n\tif (is_mbpf_jmp64(meta)) {\n\t\temit_alu(nfp_prog, imm_b(nfp_prog),\n\t\t\t reg_a(insn->dst_reg * 2 + 1), ALU_OP_XOR,\n\t\t\t reg_b(insn->src_reg * 2 + 1));\n\t\temit_alu(nfp_prog, reg_none(), imm_a(nfp_prog), ALU_OP_OR,\n\t\t\t imm_b(nfp_prog));\n\t}\n\temit_br(nfp_prog, BR_BEQ, insn->off, 0);\n\n\treturn 0;\n}\n\nstatic int jset_reg(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\n{\n\treturn wrp_test_reg(nfp_prog, meta, ALU_OP_AND, BR_BNE);\n}\n\nstatic int jne_reg(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\n{\n\treturn wrp_test_reg(nfp_prog, meta, ALU_OP_XOR, BR_BNE);\n}\n\nstatic int\nbpf_to_bpf_call(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\n{\n\tu32 ret_tgt, stack_depth, offset_br;\n\tswreg tmp_reg;\n\n\tstack_depth = round_up(nfp_prog->stack_frame_depth, STACK_FRAME_ALIGN);\n\t \n\tif (stack_depth) {\n\t\ttmp_reg = ur_load_imm_any(nfp_prog, stack_depth,\n\t\t\t\t\t  stack_imm(nfp_prog));\n\t\temit_alu(nfp_prog, stack_reg(nfp_prog),\n\t\t\t stack_reg(nfp_prog), ALU_OP_ADD, tmp_reg);\n\t\temit_csr_wr(nfp_prog, stack_reg(nfp_prog),\n\t\t\t    NFP_CSR_ACT_LM_ADDR0);\n\t}\n\n\t \n\tif (!meta->jmp_dst) {\n\t\tpr_err(\"BUG: BPF-to-BPF call has no destination recorded\\n\");\n\t\treturn -ELOOP;\n\t}\n\tif (nfp_prog->subprog[meta->jmp_dst->subprog_idx].needs_reg_push) {\n\t\tret_tgt = nfp_prog_current_offset(nfp_prog) + 3;\n\t\temit_br_relo(nfp_prog, BR_UNC, BR_OFF_RELO, 2,\n\t\t\t     RELO_BR_GO_CALL_PUSH_REGS);\n\t\toffset_br = nfp_prog_current_offset(nfp_prog);\n\t\twrp_immed_relo(nfp_prog, imm_b(nfp_prog), 0, RELO_IMMED_REL);\n\t} else {\n\t\tret_tgt = nfp_prog_current_offset(nfp_prog) + 2;\n\t\temit_br(nfp_prog, BR_UNC, meta->insn.imm, 1);\n\t\toffset_br = nfp_prog_current_offset(nfp_prog);\n\t}\n\twrp_immed_relo(nfp_prog, ret_reg(nfp_prog), ret_tgt, RELO_IMMED_REL);\n\n\tif (!nfp_prog_confirm_current_offset(nfp_prog, ret_tgt))\n\t\treturn -EINVAL;\n\n\tif (stack_depth) {\n\t\ttmp_reg = ur_load_imm_any(nfp_prog, stack_depth,\n\t\t\t\t\t  stack_imm(nfp_prog));\n\t\temit_alu(nfp_prog, stack_reg(nfp_prog),\n\t\t\t stack_reg(nfp_prog), ALU_OP_SUB, tmp_reg);\n\t\temit_csr_wr(nfp_prog, stack_reg(nfp_prog),\n\t\t\t    NFP_CSR_ACT_LM_ADDR0);\n\t\twrp_nops(nfp_prog, 3);\n\t}\n\n\tmeta->num_insns_after_br = nfp_prog_current_offset(nfp_prog);\n\tmeta->num_insns_after_br -= offset_br;\n\n\treturn 0;\n}\n\nstatic int helper_call(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\n{\n\tswitch (meta->insn.imm) {\n\tcase BPF_FUNC_xdp_adjust_head:\n\t\treturn adjust_head(nfp_prog, meta);\n\tcase BPF_FUNC_xdp_adjust_tail:\n\t\treturn adjust_tail(nfp_prog, meta);\n\tcase BPF_FUNC_map_lookup_elem:\n\tcase BPF_FUNC_map_update_elem:\n\tcase BPF_FUNC_map_delete_elem:\n\t\treturn map_call_stack_common(nfp_prog, meta);\n\tcase BPF_FUNC_get_prandom_u32:\n\t\treturn nfp_get_prandom_u32(nfp_prog, meta);\n\tcase BPF_FUNC_perf_event_output:\n\t\treturn nfp_perf_event_output(nfp_prog, meta);\n\tdefault:\n\t\tWARN_ONCE(1, \"verifier allowed unsupported function\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int call(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\n{\n\tif (is_mbpf_pseudo_call(meta))\n\t\treturn bpf_to_bpf_call(nfp_prog, meta);\n\telse\n\t\treturn helper_call(nfp_prog, meta);\n}\n\nstatic bool nfp_is_main_function(struct nfp_insn_meta *meta)\n{\n\treturn meta->subprog_idx == 0;\n}\n\nstatic int goto_out(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\n{\n\temit_br_relo(nfp_prog, BR_UNC, BR_OFF_RELO, 0, RELO_BR_GO_OUT);\n\n\treturn 0;\n}\n\nstatic int\nnfp_subprog_epilogue(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\n{\n\tif (nfp_prog->subprog[meta->subprog_idx].needs_reg_push) {\n\t\t \n\t\temit_br_relo(nfp_prog, BR_UNC, BR_OFF_RELO, 1,\n\t\t\t     RELO_BR_GO_CALL_POP_REGS);\n\t\t \n\t\twrp_mov(nfp_prog, ret_reg(nfp_prog), reg_lm(0, 0));\n\t} else {\n\t\t \n\t\twrp_mov(nfp_prog, ret_reg(nfp_prog), reg_lm(0, 0));\n\t\t \n\t\temit_rtn(nfp_prog, ret_reg(nfp_prog), 0);\n\t}\n\n\treturn 0;\n}\n\nstatic int jmp_exit(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\n{\n\tif (nfp_is_main_function(meta))\n\t\treturn goto_out(nfp_prog, meta);\n\telse\n\t\treturn nfp_subprog_epilogue(nfp_prog, meta);\n}\n\nstatic const instr_cb_t instr_cb[256] = {\n\t[BPF_ALU64 | BPF_MOV | BPF_X] =\tmov_reg64,\n\t[BPF_ALU64 | BPF_MOV | BPF_K] =\tmov_imm64,\n\t[BPF_ALU64 | BPF_XOR | BPF_X] =\txor_reg64,\n\t[BPF_ALU64 | BPF_XOR | BPF_K] =\txor_imm64,\n\t[BPF_ALU64 | BPF_AND | BPF_X] =\tand_reg64,\n\t[BPF_ALU64 | BPF_AND | BPF_K] =\tand_imm64,\n\t[BPF_ALU64 | BPF_OR | BPF_X] =\tor_reg64,\n\t[BPF_ALU64 | BPF_OR | BPF_K] =\tor_imm64,\n\t[BPF_ALU64 | BPF_ADD | BPF_X] =\tadd_reg64,\n\t[BPF_ALU64 | BPF_ADD | BPF_K] =\tadd_imm64,\n\t[BPF_ALU64 | BPF_SUB | BPF_X] =\tsub_reg64,\n\t[BPF_ALU64 | BPF_SUB | BPF_K] =\tsub_imm64,\n\t[BPF_ALU64 | BPF_MUL | BPF_X] =\tmul_reg64,\n\t[BPF_ALU64 | BPF_MUL | BPF_K] =\tmul_imm64,\n\t[BPF_ALU64 | BPF_DIV | BPF_X] =\tdiv_reg64,\n\t[BPF_ALU64 | BPF_DIV | BPF_K] =\tdiv_imm64,\n\t[BPF_ALU64 | BPF_NEG] =\t\tneg_reg64,\n\t[BPF_ALU64 | BPF_LSH | BPF_X] =\tshl_reg64,\n\t[BPF_ALU64 | BPF_LSH | BPF_K] =\tshl_imm64,\n\t[BPF_ALU64 | BPF_RSH | BPF_X] =\tshr_reg64,\n\t[BPF_ALU64 | BPF_RSH | BPF_K] =\tshr_imm64,\n\t[BPF_ALU64 | BPF_ARSH | BPF_X] = ashr_reg64,\n\t[BPF_ALU64 | BPF_ARSH | BPF_K] = ashr_imm64,\n\t[BPF_ALU | BPF_MOV | BPF_X] =\tmov_reg,\n\t[BPF_ALU | BPF_MOV | BPF_K] =\tmov_imm,\n\t[BPF_ALU | BPF_XOR | BPF_X] =\txor_reg,\n\t[BPF_ALU | BPF_XOR | BPF_K] =\txor_imm,\n\t[BPF_ALU | BPF_AND | BPF_X] =\tand_reg,\n\t[BPF_ALU | BPF_AND | BPF_K] =\tand_imm,\n\t[BPF_ALU | BPF_OR | BPF_X] =\tor_reg,\n\t[BPF_ALU | BPF_OR | BPF_K] =\tor_imm,\n\t[BPF_ALU | BPF_ADD | BPF_X] =\tadd_reg,\n\t[BPF_ALU | BPF_ADD | BPF_K] =\tadd_imm,\n\t[BPF_ALU | BPF_SUB | BPF_X] =\tsub_reg,\n\t[BPF_ALU | BPF_SUB | BPF_K] =\tsub_imm,\n\t[BPF_ALU | BPF_MUL | BPF_X] =\tmul_reg,\n\t[BPF_ALU | BPF_MUL | BPF_K] =\tmul_imm,\n\t[BPF_ALU | BPF_DIV | BPF_X] =\tdiv_reg,\n\t[BPF_ALU | BPF_DIV | BPF_K] =\tdiv_imm,\n\t[BPF_ALU | BPF_NEG] =\t\tneg_reg,\n\t[BPF_ALU | BPF_LSH | BPF_X] =\tshl_reg,\n\t[BPF_ALU | BPF_LSH | BPF_K] =\tshl_imm,\n\t[BPF_ALU | BPF_RSH | BPF_X] =\tshr_reg,\n\t[BPF_ALU | BPF_RSH | BPF_K] =\tshr_imm,\n\t[BPF_ALU | BPF_ARSH | BPF_X] =\tashr_reg,\n\t[BPF_ALU | BPF_ARSH | BPF_K] =\tashr_imm,\n\t[BPF_ALU | BPF_END | BPF_X] =\tend_reg32,\n\t[BPF_LD | BPF_IMM | BPF_DW] =\timm_ld8,\n\t[BPF_LD | BPF_ABS | BPF_B] =\tdata_ld1,\n\t[BPF_LD | BPF_ABS | BPF_H] =\tdata_ld2,\n\t[BPF_LD | BPF_ABS | BPF_W] =\tdata_ld4,\n\t[BPF_LD | BPF_IND | BPF_B] =\tdata_ind_ld1,\n\t[BPF_LD | BPF_IND | BPF_H] =\tdata_ind_ld2,\n\t[BPF_LD | BPF_IND | BPF_W] =\tdata_ind_ld4,\n\t[BPF_LDX | BPF_MEM | BPF_B] =\tmem_ldx1,\n\t[BPF_LDX | BPF_MEM | BPF_H] =\tmem_ldx2,\n\t[BPF_LDX | BPF_MEM | BPF_W] =\tmem_ldx4,\n\t[BPF_LDX | BPF_MEM | BPF_DW] =\tmem_ldx8,\n\t[BPF_STX | BPF_MEM | BPF_B] =\tmem_stx1,\n\t[BPF_STX | BPF_MEM | BPF_H] =\tmem_stx2,\n\t[BPF_STX | BPF_MEM | BPF_W] =\tmem_stx4,\n\t[BPF_STX | BPF_MEM | BPF_DW] =\tmem_stx8,\n\t[BPF_STX | BPF_ATOMIC | BPF_W] =\tmem_atomic4,\n\t[BPF_STX | BPF_ATOMIC | BPF_DW] =\tmem_atomic8,\n\t[BPF_ST | BPF_MEM | BPF_B] =\tmem_st1,\n\t[BPF_ST | BPF_MEM | BPF_H] =\tmem_st2,\n\t[BPF_ST | BPF_MEM | BPF_W] =\tmem_st4,\n\t[BPF_ST | BPF_MEM | BPF_DW] =\tmem_st8,\n\t[BPF_JMP | BPF_JA | BPF_K] =\tjump,\n\t[BPF_JMP | BPF_JEQ | BPF_K] =\tjeq_imm,\n\t[BPF_JMP | BPF_JGT | BPF_K] =\tcmp_imm,\n\t[BPF_JMP | BPF_JGE | BPF_K] =\tcmp_imm,\n\t[BPF_JMP | BPF_JLT | BPF_K] =\tcmp_imm,\n\t[BPF_JMP | BPF_JLE | BPF_K] =\tcmp_imm,\n\t[BPF_JMP | BPF_JSGT | BPF_K] =  cmp_imm,\n\t[BPF_JMP | BPF_JSGE | BPF_K] =  cmp_imm,\n\t[BPF_JMP | BPF_JSLT | BPF_K] =  cmp_imm,\n\t[BPF_JMP | BPF_JSLE | BPF_K] =  cmp_imm,\n\t[BPF_JMP | BPF_JSET | BPF_K] =\tjset_imm,\n\t[BPF_JMP | BPF_JNE | BPF_K] =\tjne_imm,\n\t[BPF_JMP | BPF_JEQ | BPF_X] =\tjeq_reg,\n\t[BPF_JMP | BPF_JGT | BPF_X] =\tcmp_reg,\n\t[BPF_JMP | BPF_JGE | BPF_X] =\tcmp_reg,\n\t[BPF_JMP | BPF_JLT | BPF_X] =\tcmp_reg,\n\t[BPF_JMP | BPF_JLE | BPF_X] =\tcmp_reg,\n\t[BPF_JMP | BPF_JSGT | BPF_X] =  cmp_reg,\n\t[BPF_JMP | BPF_JSGE | BPF_X] =  cmp_reg,\n\t[BPF_JMP | BPF_JSLT | BPF_X] =  cmp_reg,\n\t[BPF_JMP | BPF_JSLE | BPF_X] =  cmp_reg,\n\t[BPF_JMP | BPF_JSET | BPF_X] =\tjset_reg,\n\t[BPF_JMP | BPF_JNE | BPF_X] =\tjne_reg,\n\t[BPF_JMP32 | BPF_JEQ | BPF_K] =\tjeq32_imm,\n\t[BPF_JMP32 | BPF_JGT | BPF_K] =\tcmp_imm,\n\t[BPF_JMP32 | BPF_JGE | BPF_K] =\tcmp_imm,\n\t[BPF_JMP32 | BPF_JLT | BPF_K] =\tcmp_imm,\n\t[BPF_JMP32 | BPF_JLE | BPF_K] =\tcmp_imm,\n\t[BPF_JMP32 | BPF_JSGT | BPF_K] =cmp_imm,\n\t[BPF_JMP32 | BPF_JSGE | BPF_K] =cmp_imm,\n\t[BPF_JMP32 | BPF_JSLT | BPF_K] =cmp_imm,\n\t[BPF_JMP32 | BPF_JSLE | BPF_K] =cmp_imm,\n\t[BPF_JMP32 | BPF_JSET | BPF_K] =jset_imm,\n\t[BPF_JMP32 | BPF_JNE | BPF_K] =\tjne_imm,\n\t[BPF_JMP32 | BPF_JEQ | BPF_X] =\tjeq_reg,\n\t[BPF_JMP32 | BPF_JGT | BPF_X] =\tcmp_reg,\n\t[BPF_JMP32 | BPF_JGE | BPF_X] =\tcmp_reg,\n\t[BPF_JMP32 | BPF_JLT | BPF_X] =\tcmp_reg,\n\t[BPF_JMP32 | BPF_JLE | BPF_X] =\tcmp_reg,\n\t[BPF_JMP32 | BPF_JSGT | BPF_X] =cmp_reg,\n\t[BPF_JMP32 | BPF_JSGE | BPF_X] =cmp_reg,\n\t[BPF_JMP32 | BPF_JSLT | BPF_X] =cmp_reg,\n\t[BPF_JMP32 | BPF_JSLE | BPF_X] =cmp_reg,\n\t[BPF_JMP32 | BPF_JSET | BPF_X] =jset_reg,\n\t[BPF_JMP32 | BPF_JNE | BPF_X] =\tjne_reg,\n\t[BPF_JMP | BPF_CALL] =\t\tcall,\n\t[BPF_JMP | BPF_EXIT] =\t\tjmp_exit,\n};\n\n \nstatic int\nnfp_fixup_immed_relo(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta,\n\t\t     struct nfp_insn_meta *jmp_dst, u32 br_idx)\n{\n\tif (immed_get_value(nfp_prog->prog[br_idx + 1])) {\n\t\tpr_err(\"BUG: failed to fix up callee register saving\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\timmed_set_value(&nfp_prog->prog[br_idx + 1], jmp_dst->off);\n\n\treturn 0;\n}\n\nstatic int nfp_fixup_branches(struct nfp_prog *nfp_prog)\n{\n\tstruct nfp_insn_meta *meta, *jmp_dst;\n\tu32 idx, br_idx;\n\tint err;\n\n\tlist_for_each_entry(meta, &nfp_prog->insns, l) {\n\t\tif (meta->flags & FLAG_INSN_SKIP_MASK)\n\t\t\tcontinue;\n\t\tif (!is_mbpf_jmp(meta))\n\t\t\tcontinue;\n\t\tif (meta->insn.code == (BPF_JMP | BPF_EXIT) &&\n\t\t    !nfp_is_main_function(meta))\n\t\t\tcontinue;\n\t\tif (is_mbpf_helper_call(meta))\n\t\t\tcontinue;\n\n\t\tif (list_is_last(&meta->l, &nfp_prog->insns))\n\t\t\tbr_idx = nfp_prog->last_bpf_off;\n\t\telse\n\t\t\tbr_idx = list_next_entry(meta, l)->off - 1;\n\n\t\t \n\t\tif (is_mbpf_pseudo_call(meta))\n\t\t\tbr_idx -= meta->num_insns_after_br;\n\n\t\tif (!nfp_is_br(nfp_prog->prog[br_idx])) {\n\t\t\tpr_err(\"Fixup found block not ending in branch %d %02x %016llx!!\\n\",\n\t\t\t       br_idx, meta->insn.code, nfp_prog->prog[br_idx]);\n\t\t\treturn -ELOOP;\n\t\t}\n\n\t\tif (meta->insn.code == (BPF_JMP | BPF_EXIT))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (FIELD_GET(OP_RELO_TYPE, nfp_prog->prog[br_idx]) !=\n\t\t    RELO_BR_REL && !is_mbpf_pseudo_call(meta))\n\t\t\tcontinue;\n\n\t\tif (!meta->jmp_dst) {\n\t\t\tpr_err(\"Non-exit jump doesn't have destination info recorded!!\\n\");\n\t\t\treturn -ELOOP;\n\t\t}\n\n\t\tjmp_dst = meta->jmp_dst;\n\n\t\tif (jmp_dst->flags & FLAG_INSN_SKIP_PREC_DEPENDENT) {\n\t\t\tpr_err(\"Branch landing on removed instruction!!\\n\");\n\t\t\treturn -ELOOP;\n\t\t}\n\n\t\tif (is_mbpf_pseudo_call(meta) &&\n\t\t    nfp_prog->subprog[jmp_dst->subprog_idx].needs_reg_push) {\n\t\t\terr = nfp_fixup_immed_relo(nfp_prog, meta,\n\t\t\t\t\t\t   jmp_dst, br_idx);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\n\t\tif (FIELD_GET(OP_RELO_TYPE, nfp_prog->prog[br_idx]) !=\n\t\t    RELO_BR_REL)\n\t\t\tcontinue;\n\n\t\tfor (idx = meta->off; idx <= br_idx; idx++) {\n\t\t\tif (!nfp_is_br(nfp_prog->prog[idx]))\n\t\t\t\tcontinue;\n\t\t\tbr_set_offset(&nfp_prog->prog[idx], jmp_dst->off);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void nfp_intro(struct nfp_prog *nfp_prog)\n{\n\twrp_immed(nfp_prog, plen_reg(nfp_prog), GENMASK(13, 0));\n\temit_alu(nfp_prog, plen_reg(nfp_prog),\n\t\t plen_reg(nfp_prog), ALU_OP_AND, pv_len(nfp_prog));\n}\n\nstatic void\nnfp_subprog_prologue(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\n{\n\t \n\twrp_mov(nfp_prog, reg_lm(0, 0), ret_reg(nfp_prog));\n}\n\nstatic void\nnfp_start_subprog(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\n{\n\tunsigned int depth = nfp_prog->subprog[meta->subprog_idx].stack_depth;\n\n\tnfp_prog->stack_frame_depth = round_up(depth, 4);\n\tnfp_subprog_prologue(nfp_prog, meta);\n}\n\nbool nfp_is_subprog_start(struct nfp_insn_meta *meta)\n{\n\treturn meta->flags & FLAG_INSN_IS_SUBPROG_START;\n}\n\nstatic void nfp_outro_tc_da(struct nfp_prog *nfp_prog)\n{\n\t \n\t \n\tnfp_prog->tgt_abort = nfp_prog_current_offset(nfp_prog);\n\n\temit_br_relo(nfp_prog, BR_UNC, BR_OFF_RELO, 2, RELO_BR_NEXT_PKT);\n\n\twrp_mov(nfp_prog, reg_a(0), NFP_BPF_ABI_FLAGS);\n\temit_ld_field(nfp_prog, reg_a(0), 0xc, reg_imm(0x11), SHF_SC_L_SHF, 16);\n\n\t \n\tnfp_prog->tgt_out = nfp_prog_current_offset(nfp_prog);\n\n\t \n\temit_alu(nfp_prog, reg_none(), reg_imm(7), ALU_OP_SUB, reg_b(0));\n\temit_br(nfp_prog, BR_BLO, nfp_prog->tgt_abort, 0);\n\twrp_mov(nfp_prog, reg_a(0), NFP_BPF_ABI_FLAGS);\n\n\twrp_immed(nfp_prog, reg_b(2), 0x41221211);\n\twrp_immed(nfp_prog, reg_b(3), 0x41001211);\n\n\temit_shf(nfp_prog, reg_a(1),\n\t\t reg_none(), SHF_OP_NONE, reg_b(0), SHF_SC_L_SHF, 2);\n\n\temit_alu(nfp_prog, reg_none(), reg_a(1), ALU_OP_OR, reg_imm(0));\n\temit_shf(nfp_prog, reg_a(2),\n\t\t reg_imm(0xf), SHF_OP_AND, reg_b(2), SHF_SC_R_SHF, 0);\n\n\temit_alu(nfp_prog, reg_none(), reg_a(1), ALU_OP_OR, reg_imm(0));\n\temit_shf(nfp_prog, reg_b(2),\n\t\t reg_imm(0xf), SHF_OP_AND, reg_b(3), SHF_SC_R_SHF, 0);\n\n\temit_br_relo(nfp_prog, BR_UNC, BR_OFF_RELO, 2, RELO_BR_NEXT_PKT);\n\n\temit_shf(nfp_prog, reg_b(2),\n\t\t reg_a(2), SHF_OP_OR, reg_b(2), SHF_SC_L_SHF, 4);\n\temit_ld_field(nfp_prog, reg_a(0), 0xc, reg_b(2), SHF_SC_L_SHF, 16);\n}\n\nstatic void nfp_outro_xdp(struct nfp_prog *nfp_prog)\n{\n\t \n\t \n\tnfp_prog->tgt_abort = nfp_prog_current_offset(nfp_prog);\n\n\temit_br_relo(nfp_prog, BR_UNC, BR_OFF_RELO, 2, RELO_BR_NEXT_PKT);\n\n\twrp_mov(nfp_prog, reg_a(0), NFP_BPF_ABI_FLAGS);\n\temit_ld_field(nfp_prog, reg_a(0), 0xc, reg_imm(0x82), SHF_SC_L_SHF, 16);\n\n\t \n\tnfp_prog->tgt_out = nfp_prog_current_offset(nfp_prog);\n\n\t \n\temit_alu(nfp_prog, reg_none(), reg_imm(3), ALU_OP_SUB, reg_b(0));\n\temit_br(nfp_prog, BR_BLO, nfp_prog->tgt_abort, 0);\n\n\twrp_immed(nfp_prog, reg_b(2), 0x44112282);\n\n\temit_shf(nfp_prog, reg_a(1),\n\t\t reg_none(), SHF_OP_NONE, reg_b(0), SHF_SC_L_SHF, 3);\n\n\temit_alu(nfp_prog, reg_none(), reg_a(1), ALU_OP_OR, reg_imm(0));\n\temit_shf(nfp_prog, reg_b(2),\n\t\t reg_imm(0xff), SHF_OP_AND, reg_b(2), SHF_SC_R_SHF, 0);\n\n\temit_br_relo(nfp_prog, BR_UNC, BR_OFF_RELO, 2, RELO_BR_NEXT_PKT);\n\n\twrp_mov(nfp_prog, reg_a(0), NFP_BPF_ABI_FLAGS);\n\temit_ld_field(nfp_prog, reg_a(0), 0xc, reg_b(2), SHF_SC_L_SHF, 16);\n}\n\nstatic bool nfp_prog_needs_callee_reg_save(struct nfp_prog *nfp_prog)\n{\n\tunsigned int idx;\n\n\tfor (idx = 1; idx < nfp_prog->subprog_cnt; idx++)\n\t\tif (nfp_prog->subprog[idx].needs_reg_push)\n\t\t\treturn true;\n\n\treturn false;\n}\n\nstatic void nfp_push_callee_registers(struct nfp_prog *nfp_prog)\n{\n\tu8 reg;\n\n\t \n\tnfp_prog->tgt_call_push_regs = nfp_prog_current_offset(nfp_prog);\n\tfor (reg = BPF_REG_6; reg <= BPF_REG_9; reg++) {\n\t\tu8 adj = (reg - BPF_REG_0) * 2;\n\t\tu8 idx = (reg - BPF_REG_6) * 2;\n\n\t\t \n\t\twrp_mov(nfp_prog, reg_lm(0, 1 + idx), reg_b(adj));\n\n\t\tif (reg == BPF_REG_8)\n\t\t\t \n\t\t\temit_rtn(nfp_prog, imm_b(nfp_prog), 3);\n\n\t\twrp_mov(nfp_prog, reg_lm(0, 1 + idx + 1), reg_b(adj + 1));\n\t}\n}\n\nstatic void nfp_pop_callee_registers(struct nfp_prog *nfp_prog)\n{\n\tu8 reg;\n\n\t \n\tnfp_prog->tgt_call_pop_regs = nfp_prog_current_offset(nfp_prog);\n\tfor (reg = BPF_REG_6; reg <= BPF_REG_9; reg++) {\n\t\tu8 adj = (reg - BPF_REG_0) * 2;\n\t\tu8 idx = (reg - BPF_REG_6) * 2;\n\n\t\t \n\t\twrp_mov(nfp_prog, reg_both(adj), reg_lm(0, 1 + idx));\n\n\t\tif (reg == BPF_REG_8)\n\t\t\t \n\t\t\temit_rtn(nfp_prog, ret_reg(nfp_prog), 3);\n\n\t\twrp_mov(nfp_prog, reg_both(adj + 1), reg_lm(0, 1 + idx + 1));\n\t}\n}\n\nstatic void nfp_outro(struct nfp_prog *nfp_prog)\n{\n\tswitch (nfp_prog->type) {\n\tcase BPF_PROG_TYPE_SCHED_CLS:\n\t\tnfp_outro_tc_da(nfp_prog);\n\t\tbreak;\n\tcase BPF_PROG_TYPE_XDP:\n\t\tnfp_outro_xdp(nfp_prog);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t}\n\n\tif (!nfp_prog_needs_callee_reg_save(nfp_prog))\n\t\treturn;\n\n\tnfp_push_callee_registers(nfp_prog);\n\tnfp_pop_callee_registers(nfp_prog);\n}\n\nstatic int nfp_translate(struct nfp_prog *nfp_prog)\n{\n\tstruct nfp_insn_meta *meta;\n\tunsigned int depth;\n\tint err;\n\n\tdepth = nfp_prog->subprog[0].stack_depth;\n\tnfp_prog->stack_frame_depth = round_up(depth, 4);\n\n\tnfp_intro(nfp_prog);\n\tif (nfp_prog->error)\n\t\treturn nfp_prog->error;\n\n\tlist_for_each_entry(meta, &nfp_prog->insns, l) {\n\t\tinstr_cb_t cb = instr_cb[meta->insn.code];\n\n\t\tmeta->off = nfp_prog_current_offset(nfp_prog);\n\n\t\tif (nfp_is_subprog_start(meta)) {\n\t\t\tnfp_start_subprog(nfp_prog, meta);\n\t\t\tif (nfp_prog->error)\n\t\t\t\treturn nfp_prog->error;\n\t\t}\n\n\t\tif (meta->flags & FLAG_INSN_SKIP_MASK) {\n\t\t\tnfp_prog->n_translated++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (nfp_meta_has_prev(nfp_prog, meta) &&\n\t\t    nfp_meta_prev(meta)->double_cb)\n\t\t\tcb = nfp_meta_prev(meta)->double_cb;\n\t\tif (!cb)\n\t\t\treturn -ENOENT;\n\t\terr = cb(nfp_prog, meta);\n\t\tif (err)\n\t\t\treturn err;\n\t\tif (nfp_prog->error)\n\t\t\treturn nfp_prog->error;\n\n\t\tnfp_prog->n_translated++;\n\t}\n\n\tnfp_prog->last_bpf_off = nfp_prog_current_offset(nfp_prog) - 1;\n\n\tnfp_outro(nfp_prog);\n\tif (nfp_prog->error)\n\t\treturn nfp_prog->error;\n\n\twrp_nops(nfp_prog, NFP_USTORE_PREFETCH_WINDOW);\n\tif (nfp_prog->error)\n\t\treturn nfp_prog->error;\n\n\treturn nfp_fixup_branches(nfp_prog);\n}\n\n \nstatic void nfp_bpf_opt_reg_init(struct nfp_prog *nfp_prog)\n{\n\tstruct nfp_insn_meta *meta;\n\n\tlist_for_each_entry(meta, &nfp_prog->insns, l) {\n\t\tstruct bpf_insn insn = meta->insn;\n\n\t\t \n\t\tif (insn.code == (BPF_ALU64 | BPF_XOR | BPF_X) &&\n\t\t    insn.src_reg == insn.dst_reg)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (insn.code == (BPF_ALU64 | BPF_MOV | BPF_X) &&\n\t\t    insn.src_reg == 1 && insn.dst_reg == 6)\n\t\t\tmeta->flags |= FLAG_INSN_SKIP_PREC_DEPENDENT;\n\n\t\t \n\t\tif (!(meta->flags & FLAG_INSN_SKIP_MASK))\n\t\t\treturn;\n\t}\n}\n\n \nstatic void nfp_bpf_opt_neg_add_sub(struct nfp_prog *nfp_prog)\n{\n\tstruct nfp_insn_meta *meta;\n\n\tlist_for_each_entry(meta, &nfp_prog->insns, l) {\n\t\tstruct bpf_insn insn = meta->insn;\n\n\t\tif (meta->flags & FLAG_INSN_SKIP_MASK)\n\t\t\tcontinue;\n\n\t\tif (!is_mbpf_alu(meta) && !is_mbpf_jmp(meta))\n\t\t\tcontinue;\n\t\tif (BPF_SRC(insn.code) != BPF_K)\n\t\t\tcontinue;\n\t\tif (insn.imm >= 0)\n\t\t\tcontinue;\n\n\t\tif (is_mbpf_jmp(meta)) {\n\t\t\tswitch (BPF_OP(insn.code)) {\n\t\t\tcase BPF_JGE:\n\t\t\tcase BPF_JSGE:\n\t\t\tcase BPF_JLT:\n\t\t\tcase BPF_JSLT:\n\t\t\t\tmeta->jump_neg_op = true;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tif (BPF_OP(insn.code) == BPF_ADD)\n\t\t\t\tinsn.code = BPF_CLASS(insn.code) | BPF_SUB;\n\t\t\telse if (BPF_OP(insn.code) == BPF_SUB)\n\t\t\t\tinsn.code = BPF_CLASS(insn.code) | BPF_ADD;\n\t\t\telse\n\t\t\t\tcontinue;\n\n\t\t\tmeta->insn.code = insn.code | BPF_K;\n\t\t}\n\n\t\tmeta->insn.imm = -insn.imm;\n\t}\n}\n\n \nstatic void nfp_bpf_opt_ld_mask(struct nfp_prog *nfp_prog)\n{\n\tstruct nfp_insn_meta *meta1, *meta2;\n\tstatic const s32 exp_mask[] = {\n\t\t[BPF_B] = 0x000000ffU,\n\t\t[BPF_H] = 0x0000ffffU,\n\t\t[BPF_W] = 0xffffffffU,\n\t};\n\n\tnfp_for_each_insn_walk2(nfp_prog, meta1, meta2) {\n\t\tstruct bpf_insn insn, next;\n\n\t\tinsn = meta1->insn;\n\t\tnext = meta2->insn;\n\n\t\tif (BPF_CLASS(insn.code) != BPF_LD)\n\t\t\tcontinue;\n\t\tif (BPF_MODE(insn.code) != BPF_ABS &&\n\t\t    BPF_MODE(insn.code) != BPF_IND)\n\t\t\tcontinue;\n\n\t\tif (next.code != (BPF_ALU64 | BPF_AND | BPF_K))\n\t\t\tcontinue;\n\n\t\tif (!exp_mask[BPF_SIZE(insn.code)])\n\t\t\tcontinue;\n\t\tif (exp_mask[BPF_SIZE(insn.code)] != next.imm)\n\t\t\tcontinue;\n\n\t\tif (next.src_reg || next.dst_reg)\n\t\t\tcontinue;\n\n\t\tif (meta2->flags & FLAG_INSN_IS_JUMP_DST)\n\t\t\tcontinue;\n\n\t\tmeta2->flags |= FLAG_INSN_SKIP_PREC_DEPENDENT;\n\t}\n}\n\nstatic void nfp_bpf_opt_ld_shift(struct nfp_prog *nfp_prog)\n{\n\tstruct nfp_insn_meta *meta1, *meta2, *meta3;\n\n\tnfp_for_each_insn_walk3(nfp_prog, meta1, meta2, meta3) {\n\t\tstruct bpf_insn insn, next1, next2;\n\n\t\tinsn = meta1->insn;\n\t\tnext1 = meta2->insn;\n\t\tnext2 = meta3->insn;\n\n\t\tif (BPF_CLASS(insn.code) != BPF_LD)\n\t\t\tcontinue;\n\t\tif (BPF_MODE(insn.code) != BPF_ABS &&\n\t\t    BPF_MODE(insn.code) != BPF_IND)\n\t\t\tcontinue;\n\t\tif (BPF_SIZE(insn.code) != BPF_W)\n\t\t\tcontinue;\n\n\t\tif (!(next1.code == (BPF_LSH | BPF_K | BPF_ALU64) &&\n\t\t      next2.code == (BPF_RSH | BPF_K | BPF_ALU64)) &&\n\t\t    !(next1.code == (BPF_RSH | BPF_K | BPF_ALU64) &&\n\t\t      next2.code == (BPF_LSH | BPF_K | BPF_ALU64)))\n\t\t\tcontinue;\n\n\t\tif (next1.src_reg || next1.dst_reg ||\n\t\t    next2.src_reg || next2.dst_reg)\n\t\t\tcontinue;\n\n\t\tif (next1.imm != 0x20 || next2.imm != 0x20)\n\t\t\tcontinue;\n\n\t\tif (meta2->flags & FLAG_INSN_IS_JUMP_DST ||\n\t\t    meta3->flags & FLAG_INSN_IS_JUMP_DST)\n\t\t\tcontinue;\n\n\t\tmeta2->flags |= FLAG_INSN_SKIP_PREC_DEPENDENT;\n\t\tmeta3->flags |= FLAG_INSN_SKIP_PREC_DEPENDENT;\n\t}\n}\n\n \nstatic bool\ncurr_pair_is_memcpy(struct nfp_insn_meta *ld_meta,\n\t\t    struct nfp_insn_meta *st_meta)\n{\n\tstruct bpf_insn *ld = &ld_meta->insn;\n\tstruct bpf_insn *st = &st_meta->insn;\n\n\tif (!is_mbpf_load(ld_meta) || !is_mbpf_store(st_meta))\n\t\treturn false;\n\n\tif (ld_meta->ptr.type != PTR_TO_PACKET &&\n\t    ld_meta->ptr.type != PTR_TO_MAP_VALUE)\n\t\treturn false;\n\n\tif (st_meta->ptr.type != PTR_TO_PACKET)\n\t\treturn false;\n\n\tif (BPF_SIZE(ld->code) != BPF_SIZE(st->code))\n\t\treturn false;\n\n\tif (ld->dst_reg != st->src_reg)\n\t\treturn false;\n\n\t \n\tif (st_meta->flags & FLAG_INSN_IS_JUMP_DST)\n\t\treturn false;\n\n\treturn true;\n}\n\n \nstatic bool\ncurr_pair_chain_with_previous(struct nfp_insn_meta *ld_meta,\n\t\t\t      struct nfp_insn_meta *st_meta,\n\t\t\t      struct bpf_insn *prev_ld,\n\t\t\t      struct bpf_insn *prev_st)\n{\n\tu8 prev_size, curr_size, prev_ld_base, prev_st_base, prev_ld_dst;\n\tstruct bpf_insn *ld = &ld_meta->insn;\n\tstruct bpf_insn *st = &st_meta->insn;\n\ts16 prev_ld_off, prev_st_off;\n\n\t \n\tif (!prev_ld)\n\t\treturn true;\n\n\tprev_size = BPF_LDST_BYTES(prev_ld);\n\tcurr_size = BPF_LDST_BYTES(ld);\n\tprev_ld_base = prev_ld->src_reg;\n\tprev_st_base = prev_st->dst_reg;\n\tprev_ld_dst = prev_ld->dst_reg;\n\tprev_ld_off = prev_ld->off;\n\tprev_st_off = prev_st->off;\n\n\tif (ld->dst_reg != prev_ld_dst)\n\t\treturn false;\n\n\tif (ld->src_reg != prev_ld_base || st->dst_reg != prev_st_base)\n\t\treturn false;\n\n\tif (curr_size != prev_size)\n\t\treturn false;\n\n\t \n\tif (ld_meta->flags & FLAG_INSN_IS_JUMP_DST)\n\t\treturn false;\n\n\t \n\tif (prev_ld_off + prev_size == ld->off &&\n\t    prev_st_off + prev_size == st->off)\n\t\treturn true;\n\n\t \n\tif (ld->off + curr_size == prev_ld_off &&\n\t    st->off + curr_size == prev_st_off)\n\t\treturn true;\n\n\treturn false;\n}\n\n \nstatic bool\ncross_mem_access(struct bpf_insn *ld, struct nfp_insn_meta *head_ld_meta,\n\t\t struct nfp_insn_meta *head_st_meta)\n{\n\ts16 head_ld_off, head_st_off, ld_off;\n\n\t \n\tif (head_ld_meta->ptr.type != head_st_meta->ptr.type)\n\t\treturn false;\n\n\t \n\tif (head_ld_meta->ptr.id != head_st_meta->ptr.id)\n\t\treturn true;\n\n\t \n\thead_ld_off = head_ld_meta->insn.off + head_ld_meta->ptr.off;\n\thead_st_off = head_st_meta->insn.off + head_st_meta->ptr.off;\n\tld_off = ld->off + head_ld_meta->ptr.off;\n\n\t \n\tif (ld_off > head_ld_off &&\n\t    head_ld_off < head_st_off && ld_off >= head_st_off)\n\t\treturn true;\n\n\t \n\tif (ld_off < head_ld_off &&\n\t    head_ld_off > head_st_off && ld_off <= head_st_off)\n\t\treturn true;\n\n\treturn false;\n}\n\n \nstatic void nfp_bpf_opt_ldst_gather(struct nfp_prog *nfp_prog)\n{\n\tstruct nfp_insn_meta *head_ld_meta = NULL;\n\tstruct nfp_insn_meta *head_st_meta = NULL;\n\tstruct nfp_insn_meta *meta1, *meta2;\n\tstruct bpf_insn *prev_ld = NULL;\n\tstruct bpf_insn *prev_st = NULL;\n\tu8 count = 0;\n\n\tnfp_for_each_insn_walk2(nfp_prog, meta1, meta2) {\n\t\tstruct bpf_insn *ld = &meta1->insn;\n\t\tstruct bpf_insn *st = &meta2->insn;\n\n\t\t \n\t\tif (!curr_pair_is_memcpy(meta1, meta2) ||\n\t\t    !curr_pair_chain_with_previous(meta1, meta2, prev_ld,\n\t\t\t\t\t\t   prev_st) ||\n\t\t    (head_ld_meta && (cross_mem_access(ld, head_ld_meta,\n\t\t\t\t\t\t       head_st_meta) ||\n\t\t\t\t      head_ld_meta->ldst_gather_len >= 128))) {\n\t\t\tif (!count)\n\t\t\t\tcontinue;\n\n\t\t\tif (count > 1) {\n\t\t\t\ts16 prev_ld_off = prev_ld->off;\n\t\t\t\ts16 prev_st_off = prev_st->off;\n\t\t\t\ts16 head_ld_off = head_ld_meta->insn.off;\n\n\t\t\t\tif (prev_ld_off < head_ld_off) {\n\t\t\t\t\thead_ld_meta->insn.off = prev_ld_off;\n\t\t\t\t\thead_st_meta->insn.off = prev_st_off;\n\t\t\t\t\thead_ld_meta->ldst_gather_len =\n\t\t\t\t\t\t-head_ld_meta->ldst_gather_len;\n\t\t\t\t}\n\n\t\t\t\thead_ld_meta->paired_st = &head_st_meta->insn;\n\t\t\t\thead_st_meta->flags |=\n\t\t\t\t\tFLAG_INSN_SKIP_PREC_DEPENDENT;\n\t\t\t} else {\n\t\t\t\thead_ld_meta->ldst_gather_len = 0;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (curr_pair_is_memcpy(meta1, meta2)) {\n\t\t\t\thead_ld_meta = meta1;\n\t\t\t\thead_st_meta = meta2;\n\t\t\t\thead_ld_meta->ldst_gather_len =\n\t\t\t\t\tBPF_LDST_BYTES(ld);\n\t\t\t\tmeta1 = nfp_meta_next(meta1);\n\t\t\t\tmeta2 = nfp_meta_next(meta2);\n\t\t\t\tprev_ld = ld;\n\t\t\t\tprev_st = st;\n\t\t\t\tcount = 1;\n\t\t\t} else {\n\t\t\t\thead_ld_meta = NULL;\n\t\t\t\thead_st_meta = NULL;\n\t\t\t\tprev_ld = NULL;\n\t\t\t\tprev_st = NULL;\n\t\t\t\tcount = 0;\n\t\t\t}\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!head_ld_meta) {\n\t\t\thead_ld_meta = meta1;\n\t\t\thead_st_meta = meta2;\n\t\t} else {\n\t\t\tmeta1->flags |= FLAG_INSN_SKIP_PREC_DEPENDENT;\n\t\t\tmeta2->flags |= FLAG_INSN_SKIP_PREC_DEPENDENT;\n\t\t}\n\n\t\thead_ld_meta->ldst_gather_len += BPF_LDST_BYTES(ld);\n\t\tmeta1 = nfp_meta_next(meta1);\n\t\tmeta2 = nfp_meta_next(meta2);\n\t\tprev_ld = ld;\n\t\tprev_st = st;\n\t\tcount++;\n\t}\n}\n\nstatic void nfp_bpf_opt_pkt_cache(struct nfp_prog *nfp_prog)\n{\n\tstruct nfp_insn_meta *meta, *range_node = NULL;\n\ts16 range_start = 0, range_end = 0;\n\tbool cache_avail = false;\n\tstruct bpf_insn *insn;\n\ts32 range_ptr_off = 0;\n\tu32 range_ptr_id = 0;\n\n\tlist_for_each_entry(meta, &nfp_prog->insns, l) {\n\t\tif (meta->flags & FLAG_INSN_IS_JUMP_DST)\n\t\t\tcache_avail = false;\n\n\t\tif (meta->flags & FLAG_INSN_SKIP_MASK)\n\t\t\tcontinue;\n\n\t\tinsn = &meta->insn;\n\n\t\tif (is_mbpf_store_pkt(meta) ||\n\t\t    insn->code == (BPF_JMP | BPF_CALL) ||\n\t\t    is_mbpf_classic_store_pkt(meta) ||\n\t\t    is_mbpf_classic_load(meta)) {\n\t\t\tcache_avail = false;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!is_mbpf_load(meta))\n\t\t\tcontinue;\n\n\t\tif (meta->ptr.type != PTR_TO_PACKET || meta->ldst_gather_len) {\n\t\t\tcache_avail = false;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!cache_avail) {\n\t\t\tcache_avail = true;\n\t\t\tif (range_node)\n\t\t\t\tgoto end_current_then_start_new;\n\t\t\tgoto start_new;\n\t\t}\n\n\t\t \n\t\tif (meta->ptr.id == range_ptr_id &&\n\t\t    meta->ptr.off == range_ptr_off) {\n\t\t\ts16 new_start = range_start;\n\t\t\ts16 end, off = insn->off;\n\t\t\ts16 new_end = range_end;\n\t\t\tbool changed = false;\n\n\t\t\tif (off < range_start) {\n\t\t\t\tnew_start = off;\n\t\t\t\tchanged = true;\n\t\t\t}\n\n\t\t\tend = off + BPF_LDST_BYTES(insn);\n\t\t\tif (end > range_end) {\n\t\t\t\tnew_end = end;\n\t\t\t\tchanged = true;\n\t\t\t}\n\n\t\t\tif (!changed)\n\t\t\t\tcontinue;\n\n\t\t\tif (new_end - new_start <= 64) {\n\t\t\t\t \n\t\t\t\trange_start = new_start;\n\t\t\t\trange_end = new_end;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\nend_current_then_start_new:\n\t\trange_node->pkt_cache.range_start = range_start;\n\t\trange_node->pkt_cache.range_end = range_end;\nstart_new:\n\t\trange_node = meta;\n\t\trange_node->pkt_cache.do_init = true;\n\t\trange_ptr_id = range_node->ptr.id;\n\t\trange_ptr_off = range_node->ptr.off;\n\t\trange_start = insn->off;\n\t\trange_end = insn->off + BPF_LDST_BYTES(insn);\n\t}\n\n\tif (range_node) {\n\t\trange_node->pkt_cache.range_start = range_start;\n\t\trange_node->pkt_cache.range_end = range_end;\n\t}\n\n\tlist_for_each_entry(meta, &nfp_prog->insns, l) {\n\t\tif (meta->flags & FLAG_INSN_SKIP_MASK)\n\t\t\tcontinue;\n\n\t\tif (is_mbpf_load_pkt(meta) && !meta->ldst_gather_len) {\n\t\t\tif (meta->pkt_cache.do_init) {\n\t\t\t\trange_start = meta->pkt_cache.range_start;\n\t\t\t\trange_end = meta->pkt_cache.range_end;\n\t\t\t} else {\n\t\t\t\tmeta->pkt_cache.range_start = range_start;\n\t\t\t\tmeta->pkt_cache.range_end = range_end;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic int nfp_bpf_optimize(struct nfp_prog *nfp_prog)\n{\n\tnfp_bpf_opt_reg_init(nfp_prog);\n\n\tnfp_bpf_opt_neg_add_sub(nfp_prog);\n\tnfp_bpf_opt_ld_mask(nfp_prog);\n\tnfp_bpf_opt_ld_shift(nfp_prog);\n\tnfp_bpf_opt_ldst_gather(nfp_prog);\n\tnfp_bpf_opt_pkt_cache(nfp_prog);\n\n\treturn 0;\n}\n\nstatic int nfp_bpf_replace_map_ptrs(struct nfp_prog *nfp_prog)\n{\n\tstruct nfp_insn_meta *meta1, *meta2;\n\tstruct nfp_bpf_map *nfp_map;\n\tstruct bpf_map *map;\n\tu32 id;\n\n\tnfp_for_each_insn_walk2(nfp_prog, meta1, meta2) {\n\t\tif (meta1->flags & FLAG_INSN_SKIP_MASK ||\n\t\t    meta2->flags & FLAG_INSN_SKIP_MASK)\n\t\t\tcontinue;\n\n\t\tif (meta1->insn.code != (BPF_LD | BPF_IMM | BPF_DW) ||\n\t\t    meta1->insn.src_reg != BPF_PSEUDO_MAP_FD)\n\t\t\tcontinue;\n\n\t\tmap = (void *)(unsigned long)((u32)meta1->insn.imm |\n\t\t\t\t\t      (u64)meta2->insn.imm << 32);\n\t\tif (bpf_map_offload_neutral(map)) {\n\t\t\tid = map->id;\n\t\t} else {\n\t\t\tnfp_map = map_to_offmap(map)->dev_priv;\n\t\t\tid = nfp_map->tid;\n\t\t}\n\n\t\tmeta1->insn.imm = id;\n\t\tmeta2->insn.imm = 0;\n\t}\n\n\treturn 0;\n}\n\nstatic int nfp_bpf_ustore_calc(u64 *prog, unsigned int len)\n{\n\t__le64 *ustore = (__force __le64 *)prog;\n\tint i;\n\n\tfor (i = 0; i < len; i++) {\n\t\tint err;\n\n\t\terr = nfp_ustore_check_valid_no_ecc(prog[i]);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tustore[i] = cpu_to_le64(nfp_ustore_calc_ecc_insn(prog[i]));\n\t}\n\n\treturn 0;\n}\n\nstatic void nfp_bpf_prog_trim(struct nfp_prog *nfp_prog)\n{\n\tvoid *prog;\n\n\tprog = kvmalloc_array(nfp_prog->prog_len, sizeof(u64), GFP_KERNEL);\n\tif (!prog)\n\t\treturn;\n\n\tnfp_prog->__prog_alloc_len = nfp_prog->prog_len * sizeof(u64);\n\tmemcpy(prog, nfp_prog->prog, nfp_prog->__prog_alloc_len);\n\tkvfree(nfp_prog->prog);\n\tnfp_prog->prog = prog;\n}\n\nint nfp_bpf_jit(struct nfp_prog *nfp_prog)\n{\n\tint ret;\n\n\tret = nfp_bpf_replace_map_ptrs(nfp_prog);\n\tif (ret)\n\t\treturn ret;\n\n\tret = nfp_bpf_optimize(nfp_prog);\n\tif (ret)\n\t\treturn ret;\n\n\tret = nfp_translate(nfp_prog);\n\tif (ret) {\n\t\tpr_err(\"Translation failed with error %d (translated: %u)\\n\",\n\t\t       ret, nfp_prog->n_translated);\n\t\treturn -EINVAL;\n\t}\n\n\tnfp_bpf_prog_trim(nfp_prog);\n\n\treturn ret;\n}\n\nvoid nfp_bpf_jit_prepare(struct nfp_prog *nfp_prog)\n{\n\tstruct nfp_insn_meta *meta;\n\n\t \n\tlist_for_each_entry(meta, &nfp_prog->insns, l) {\n\t\tstruct nfp_insn_meta *dst_meta;\n\t\tu64 code = meta->insn.code;\n\t\tunsigned int dst_idx;\n\t\tbool pseudo_call;\n\n\t\tif (!is_mbpf_jmp(meta))\n\t\t\tcontinue;\n\t\tif (BPF_OP(code) == BPF_EXIT)\n\t\t\tcontinue;\n\t\tif (is_mbpf_helper_call(meta))\n\t\t\tcontinue;\n\n\t\t \n\t\tpseudo_call = BPF_OP(code) == BPF_CALL;\n\n\t\tif (pseudo_call)\n\t\t\tdst_idx = meta->n + 1 + meta->insn.imm;\n\t\telse\n\t\t\tdst_idx = meta->n + 1 + meta->insn.off;\n\n\t\tdst_meta = nfp_bpf_goto_meta(nfp_prog, meta, dst_idx);\n\n\t\tif (pseudo_call)\n\t\t\tdst_meta->flags |= FLAG_INSN_IS_SUBPROG_START;\n\n\t\tdst_meta->flags |= FLAG_INSN_IS_JUMP_DST;\n\t\tmeta->jmp_dst = dst_meta;\n\t}\n}\n\nbool nfp_bpf_supported_opcode(u8 code)\n{\n\treturn !!instr_cb[code];\n}\n\nvoid *nfp_bpf_relo_for_vnic(struct nfp_prog *nfp_prog, struct nfp_bpf_vnic *bv)\n{\n\tunsigned int i;\n\tu64 *prog;\n\tint err;\n\n\tprog = kmemdup(nfp_prog->prog, nfp_prog->prog_len * sizeof(u64),\n\t\t       GFP_KERNEL);\n\tif (!prog)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfor (i = 0; i < nfp_prog->prog_len; i++) {\n\t\tenum nfp_relo_type special;\n\t\tu32 val;\n\t\tu16 off;\n\n\t\tspecial = FIELD_GET(OP_RELO_TYPE, prog[i]);\n\t\tswitch (special) {\n\t\tcase RELO_NONE:\n\t\t\tcontinue;\n\t\tcase RELO_BR_REL:\n\t\t\tbr_add_offset(&prog[i], bv->start_off);\n\t\t\tbreak;\n\t\tcase RELO_BR_GO_OUT:\n\t\t\tbr_set_offset(&prog[i],\n\t\t\t\t      nfp_prog->tgt_out + bv->start_off);\n\t\t\tbreak;\n\t\tcase RELO_BR_GO_ABORT:\n\t\t\tbr_set_offset(&prog[i],\n\t\t\t\t      nfp_prog->tgt_abort + bv->start_off);\n\t\t\tbreak;\n\t\tcase RELO_BR_GO_CALL_PUSH_REGS:\n\t\t\tif (!nfp_prog->tgt_call_push_regs) {\n\t\t\t\tpr_err(\"BUG: failed to detect subprogram registers needs\\n\");\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto err_free_prog;\n\t\t\t}\n\t\t\toff = nfp_prog->tgt_call_push_regs + bv->start_off;\n\t\t\tbr_set_offset(&prog[i], off);\n\t\t\tbreak;\n\t\tcase RELO_BR_GO_CALL_POP_REGS:\n\t\t\tif (!nfp_prog->tgt_call_pop_regs) {\n\t\t\t\tpr_err(\"BUG: failed to detect subprogram registers needs\\n\");\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto err_free_prog;\n\t\t\t}\n\t\t\toff = nfp_prog->tgt_call_pop_regs + bv->start_off;\n\t\t\tbr_set_offset(&prog[i], off);\n\t\t\tbreak;\n\t\tcase RELO_BR_NEXT_PKT:\n\t\t\tbr_set_offset(&prog[i], bv->tgt_done);\n\t\t\tbreak;\n\t\tcase RELO_BR_HELPER:\n\t\t\tval = br_get_offset(prog[i]);\n\t\t\tval -= BR_OFF_RELO;\n\t\t\tswitch (val) {\n\t\t\tcase BPF_FUNC_map_lookup_elem:\n\t\t\t\tval = nfp_prog->bpf->helpers.map_lookup;\n\t\t\t\tbreak;\n\t\t\tcase BPF_FUNC_map_update_elem:\n\t\t\t\tval = nfp_prog->bpf->helpers.map_update;\n\t\t\t\tbreak;\n\t\t\tcase BPF_FUNC_map_delete_elem:\n\t\t\t\tval = nfp_prog->bpf->helpers.map_delete;\n\t\t\t\tbreak;\n\t\t\tcase BPF_FUNC_perf_event_output:\n\t\t\t\tval = nfp_prog->bpf->helpers.perf_event_output;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tpr_err(\"relocation of unknown helper %d\\n\",\n\t\t\t\t       val);\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto err_free_prog;\n\t\t\t}\n\t\t\tbr_set_offset(&prog[i], val);\n\t\t\tbreak;\n\t\tcase RELO_IMMED_REL:\n\t\t\timmed_add_value(&prog[i], bv->start_off);\n\t\t\tbreak;\n\t\t}\n\n\t\tprog[i] &= ~OP_RELO_TYPE;\n\t}\n\n\terr = nfp_bpf_ustore_calc(prog, nfp_prog->prog_len);\n\tif (err)\n\t\tgoto err_free_prog;\n\n\treturn prog;\n\nerr_free_prog:\n\tkfree(prog);\n\treturn ERR_PTR(err);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}