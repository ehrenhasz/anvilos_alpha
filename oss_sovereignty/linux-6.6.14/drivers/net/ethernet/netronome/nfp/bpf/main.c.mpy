{
  "module_name": "main.c",
  "hash_id": "d3e81581f834527f962c3f907bfc4f2d8f548c98b429c88ced3999af73bad5c7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/netronome/nfp/bpf/main.c",
  "human_readable_source": "\n \n\n#include <net/pkt_cls.h>\n\n#include \"../nfpcore/nfp_cpp.h\"\n#include \"../nfpcore/nfp_nffw.h\"\n#include \"../nfpcore/nfp_nsp.h\"\n#include \"../nfp_app.h\"\n#include \"../nfp_main.h\"\n#include \"../nfp_net.h\"\n#include \"../nfp_port.h\"\n#include \"fw.h\"\n#include \"main.h\"\n\nconst struct rhashtable_params nfp_bpf_maps_neutral_params = {\n\t.nelem_hint\t\t= 4,\n\t.key_len\t\t= sizeof_field(struct bpf_map, id),\n\t.key_offset\t\t= offsetof(struct nfp_bpf_neutral_map, map_id),\n\t.head_offset\t\t= offsetof(struct nfp_bpf_neutral_map, l),\n\t.automatic_shrinking\t= true,\n};\n\nstatic bool nfp_net_ebpf_capable(struct nfp_net *nn)\n{\n#ifdef __LITTLE_ENDIAN\n\tstruct nfp_app_bpf *bpf = nn->app->priv;\n\n\treturn nn->cap & NFP_NET_CFG_CTRL_BPF &&\n\t       bpf->abi_version &&\n\t       nn_readb(nn, NFP_NET_CFG_BPF_ABI) == bpf->abi_version;\n#else\n\treturn false;\n#endif\n}\n\nstatic int\nnfp_bpf_xdp_offload(struct nfp_app *app, struct nfp_net *nn,\n\t\t    struct bpf_prog *prog, struct netlink_ext_ack *extack)\n{\n\tbool running, xdp_running;\n\n\tif (!nfp_net_ebpf_capable(nn))\n\t\treturn -EINVAL;\n\n\trunning = nn->dp.ctrl & NFP_NET_CFG_CTRL_BPF;\n\txdp_running = running && nn->xdp_hw.prog;\n\n\tif (!prog && !xdp_running)\n\t\treturn 0;\n\tif (prog && running && !xdp_running)\n\t\treturn -EBUSY;\n\n\treturn nfp_net_bpf_offload(nn, prog, running, extack);\n}\n\nstatic const char *nfp_bpf_extra_cap(struct nfp_app *app, struct nfp_net *nn)\n{\n\treturn nfp_net_ebpf_capable(nn) ? \"BPF\" : \"\";\n}\n\nstatic int\nnfp_bpf_vnic_alloc(struct nfp_app *app, struct nfp_net *nn, unsigned int id)\n{\n\tstruct nfp_pf *pf = app->pf;\n\tstruct nfp_bpf_vnic *bv;\n\tint err;\n\n\tif (!pf->eth_tbl) {\n\t\tnfp_err(pf->cpp, \"No ETH table\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (pf->max_data_vnics != pf->eth_tbl->count) {\n\t\tnfp_err(pf->cpp, \"ETH entries don't match vNICs (%d vs %d)\\n\",\n\t\t\tpf->max_data_vnics, pf->eth_tbl->count);\n\t\treturn -EINVAL;\n\t}\n\n\tbv = kzalloc(sizeof(*bv), GFP_KERNEL);\n\tif (!bv)\n\t\treturn -ENOMEM;\n\tnn->app_priv = bv;\n\n\terr = nfp_app_nic_vnic_alloc(app, nn, id);\n\tif (err)\n\t\tgoto err_free_priv;\n\n\tbv->start_off = nn_readw(nn, NFP_NET_CFG_BPF_START);\n\tbv->tgt_done = nn_readw(nn, NFP_NET_CFG_BPF_DONE);\n\n\treturn 0;\nerr_free_priv:\n\tkfree(nn->app_priv);\n\treturn err;\n}\n\nstatic void nfp_bpf_vnic_free(struct nfp_app *app, struct nfp_net *nn)\n{\n\tstruct nfp_bpf_vnic *bv = nn->app_priv;\n\n\tWARN_ON(bv->tc_prog);\n\tkfree(bv);\n}\n\nstatic int nfp_bpf_setup_tc_block_cb(enum tc_setup_type type,\n\t\t\t\t     void *type_data, void *cb_priv)\n{\n\tstruct tc_cls_bpf_offload *cls_bpf = type_data;\n\tstruct nfp_net *nn = cb_priv;\n\tstruct bpf_prog *oldprog;\n\tstruct nfp_bpf_vnic *bv;\n\tint err;\n\n\tif (type != TC_SETUP_CLSBPF) {\n\t\tNL_SET_ERR_MSG_MOD(cls_bpf->common.extack,\n\t\t\t\t   \"only offload of BPF classifiers supported\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\tif (!tc_cls_can_offload_and_chain0(nn->dp.netdev, &cls_bpf->common))\n\t\treturn -EOPNOTSUPP;\n\tif (!nfp_net_ebpf_capable(nn)) {\n\t\tNL_SET_ERR_MSG_MOD(cls_bpf->common.extack,\n\t\t\t\t   \"NFP firmware does not support eBPF offload\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\tif (cls_bpf->common.protocol != htons(ETH_P_ALL)) {\n\t\tNL_SET_ERR_MSG_MOD(cls_bpf->common.extack,\n\t\t\t\t   \"only ETH_P_ALL supported as filter protocol\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t \n\tif (!cls_bpf->exts_integrated ||\n\t    tcf_exts_has_actions(cls_bpf->exts)) {\n\t\tNL_SET_ERR_MSG_MOD(cls_bpf->common.extack,\n\t\t\t\t   \"only direct action with no legacy actions supported\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (cls_bpf->command != TC_CLSBPF_OFFLOAD)\n\t\treturn -EOPNOTSUPP;\n\n\tbv = nn->app_priv;\n\toldprog = cls_bpf->oldprog;\n\n\t \n\tif (bv->tc_prog != oldprog) {\n\t\toldprog = NULL;\n\t\tif (!cls_bpf->prog)\n\t\t\treturn 0;\n\t}\n\n\terr = nfp_net_bpf_offload(nn, cls_bpf->prog, oldprog,\n\t\t\t\t  cls_bpf->common.extack);\n\tif (err)\n\t\treturn err;\n\n\tbv->tc_prog = cls_bpf->prog;\n\tnn->port->tc_offload_cnt = !!bv->tc_prog;\n\treturn 0;\n}\n\nstatic LIST_HEAD(nfp_bpf_block_cb_list);\n\nstatic int nfp_bpf_setup_tc(struct nfp_app *app, struct net_device *netdev,\n\t\t\t    enum tc_setup_type type, void *type_data)\n{\n\tstruct nfp_net *nn = netdev_priv(netdev);\n\n\tswitch (type) {\n\tcase TC_SETUP_BLOCK:\n\t\treturn flow_block_cb_setup_simple(type_data,\n\t\t\t\t\t\t  &nfp_bpf_block_cb_list,\n\t\t\t\t\t\t  nfp_bpf_setup_tc_block_cb,\n\t\t\t\t\t\t  nn, nn, true);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int\nnfp_bpf_check_mtu(struct nfp_app *app, struct net_device *netdev, int new_mtu)\n{\n\tstruct nfp_net *nn = netdev_priv(netdev);\n\tstruct nfp_bpf_vnic *bv;\n\tstruct bpf_prog *prog;\n\n\tif (~nn->dp.ctrl & NFP_NET_CFG_CTRL_BPF)\n\t\treturn 0;\n\n\tif (nn->xdp_hw.prog) {\n\t\tprog = nn->xdp_hw.prog;\n\t} else {\n\t\tbv = nn->app_priv;\n\t\tprog = bv->tc_prog;\n\t}\n\n\tif (nfp_bpf_offload_check_mtu(nn, prog, new_mtu)) {\n\t\tnn_info(nn, \"BPF offload active, potential packet access beyond hardware packet boundary\");\n\t\treturn -EBUSY;\n\t}\n\treturn 0;\n}\n\nstatic int\nnfp_bpf_parse_cap_adjust_head(struct nfp_app_bpf *bpf, void __iomem *value,\n\t\t\t      u32 length)\n{\n\tstruct nfp_bpf_cap_tlv_adjust_head __iomem *cap = value;\n\tstruct nfp_cpp *cpp = bpf->app->pf->cpp;\n\n\tif (length < sizeof(*cap)) {\n\t\tnfp_err(cpp, \"truncated adjust_head TLV: %d\\n\", length);\n\t\treturn -EINVAL;\n\t}\n\n\tbpf->adjust_head.flags = readl(&cap->flags);\n\tbpf->adjust_head.off_min = readl(&cap->off_min);\n\tbpf->adjust_head.off_max = readl(&cap->off_max);\n\tbpf->adjust_head.guaranteed_sub = readl(&cap->guaranteed_sub);\n\tbpf->adjust_head.guaranteed_add = readl(&cap->guaranteed_add);\n\n\tif (bpf->adjust_head.off_min > bpf->adjust_head.off_max) {\n\t\tnfp_err(cpp, \"invalid adjust_head TLV: min > max\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (!FIELD_FIT(UR_REG_IMM_MAX, bpf->adjust_head.off_min) ||\n\t    !FIELD_FIT(UR_REG_IMM_MAX, bpf->adjust_head.off_max)) {\n\t\tnfp_warn(cpp, \"disabling adjust_head - driver expects min/max to fit in as immediates\\n\");\n\t\tmemset(&bpf->adjust_head, 0, sizeof(bpf->adjust_head));\n\t\treturn 0;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nnfp_bpf_parse_cap_func(struct nfp_app_bpf *bpf, void __iomem *value, u32 length)\n{\n\tstruct nfp_bpf_cap_tlv_func __iomem *cap = value;\n\n\tif (length < sizeof(*cap)) {\n\t\tnfp_err(bpf->app->cpp, \"truncated function TLV: %d\\n\", length);\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (readl(&cap->func_id)) {\n\tcase BPF_FUNC_map_lookup_elem:\n\t\tbpf->helpers.map_lookup = readl(&cap->func_addr);\n\t\tbreak;\n\tcase BPF_FUNC_map_update_elem:\n\t\tbpf->helpers.map_update = readl(&cap->func_addr);\n\t\tbreak;\n\tcase BPF_FUNC_map_delete_elem:\n\t\tbpf->helpers.map_delete = readl(&cap->func_addr);\n\t\tbreak;\n\tcase BPF_FUNC_perf_event_output:\n\t\tbpf->helpers.perf_event_output = readl(&cap->func_addr);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nnfp_bpf_parse_cap_maps(struct nfp_app_bpf *bpf, void __iomem *value, u32 length)\n{\n\tstruct nfp_bpf_cap_tlv_maps __iomem *cap = value;\n\n\tif (length < sizeof(*cap)) {\n\t\tnfp_err(bpf->app->cpp, \"truncated maps TLV: %d\\n\", length);\n\t\treturn -EINVAL;\n\t}\n\n\tbpf->maps.types = readl(&cap->types);\n\tbpf->maps.max_maps = readl(&cap->max_maps);\n\tbpf->maps.max_elems = readl(&cap->max_elems);\n\tbpf->maps.max_key_sz = readl(&cap->max_key_sz);\n\tbpf->maps.max_val_sz = readl(&cap->max_val_sz);\n\tbpf->maps.max_elem_sz = readl(&cap->max_elem_sz);\n\n\treturn 0;\n}\n\nstatic int\nnfp_bpf_parse_cap_random(struct nfp_app_bpf *bpf, void __iomem *value,\n\t\t\t u32 length)\n{\n\tbpf->pseudo_random = true;\n\treturn 0;\n}\n\nstatic int\nnfp_bpf_parse_cap_qsel(struct nfp_app_bpf *bpf, void __iomem *value, u32 length)\n{\n\tbpf->queue_select = true;\n\treturn 0;\n}\n\nstatic int\nnfp_bpf_parse_cap_adjust_tail(struct nfp_app_bpf *bpf, void __iomem *value,\n\t\t\t      u32 length)\n{\n\tbpf->adjust_tail = true;\n\treturn 0;\n}\n\nstatic int\nnfp_bpf_parse_cap_cmsg_multi_ent(struct nfp_app_bpf *bpf, void __iomem *value,\n\t\t\t\t u32 length)\n{\n\tbpf->cmsg_multi_ent = true;\n\treturn 0;\n}\n\nstatic int\nnfp_bpf_parse_cap_abi_version(struct nfp_app_bpf *bpf, void __iomem *value,\n\t\t\t      u32 length)\n{\n\tif (length < 4) {\n\t\tnfp_err(bpf->app->cpp, \"truncated ABI version TLV: %d\\n\",\n\t\t\tlength);\n\t\treturn -EINVAL;\n\t}\n\n\tbpf->abi_version = readl(value);\n\tif (bpf->abi_version < 2 || bpf->abi_version > 3) {\n\t\tnfp_warn(bpf->app->cpp, \"unsupported BPF ABI version: %d\\n\",\n\t\t\t bpf->abi_version);\n\t\tbpf->abi_version = 0;\n\t}\n\n\treturn 0;\n}\n\nstatic int nfp_bpf_parse_capabilities(struct nfp_app *app)\n{\n\tstruct nfp_cpp *cpp = app->pf->cpp;\n\tstruct nfp_cpp_area *area;\n\tu8 __iomem *mem, *start;\n\n\tmem = nfp_rtsym_map(app->pf->rtbl, \"_abi_bpf_capabilities\", \"bpf.cap\",\n\t\t\t    8, &area);\n\tif (IS_ERR(mem))\n\t\treturn PTR_ERR(mem) == -ENOENT ? 0 : PTR_ERR(mem);\n\n\tstart = mem;\n\twhile (mem - start + 8 <= nfp_cpp_area_size(area)) {\n\t\tu8 __iomem *value;\n\t\tu32 type, length;\n\n\t\ttype = readl(mem);\n\t\tlength = readl(mem + 4);\n\t\tvalue = mem + 8;\n\n\t\tmem += 8 + length;\n\t\tif (mem - start > nfp_cpp_area_size(area))\n\t\t\tgoto err_release_free;\n\n\t\tswitch (type) {\n\t\tcase NFP_BPF_CAP_TYPE_FUNC:\n\t\t\tif (nfp_bpf_parse_cap_func(app->priv, value, length))\n\t\t\t\tgoto err_release_free;\n\t\t\tbreak;\n\t\tcase NFP_BPF_CAP_TYPE_ADJUST_HEAD:\n\t\t\tif (nfp_bpf_parse_cap_adjust_head(app->priv, value,\n\t\t\t\t\t\t\t  length))\n\t\t\t\tgoto err_release_free;\n\t\t\tbreak;\n\t\tcase NFP_BPF_CAP_TYPE_MAPS:\n\t\t\tif (nfp_bpf_parse_cap_maps(app->priv, value, length))\n\t\t\t\tgoto err_release_free;\n\t\t\tbreak;\n\t\tcase NFP_BPF_CAP_TYPE_RANDOM:\n\t\t\tif (nfp_bpf_parse_cap_random(app->priv, value, length))\n\t\t\t\tgoto err_release_free;\n\t\t\tbreak;\n\t\tcase NFP_BPF_CAP_TYPE_QUEUE_SELECT:\n\t\t\tif (nfp_bpf_parse_cap_qsel(app->priv, value, length))\n\t\t\t\tgoto err_release_free;\n\t\t\tbreak;\n\t\tcase NFP_BPF_CAP_TYPE_ADJUST_TAIL:\n\t\t\tif (nfp_bpf_parse_cap_adjust_tail(app->priv, value,\n\t\t\t\t\t\t\t  length))\n\t\t\t\tgoto err_release_free;\n\t\t\tbreak;\n\t\tcase NFP_BPF_CAP_TYPE_ABI_VERSION:\n\t\t\tif (nfp_bpf_parse_cap_abi_version(app->priv, value,\n\t\t\t\t\t\t\t  length))\n\t\t\t\tgoto err_release_free;\n\t\t\tbreak;\n\t\tcase NFP_BPF_CAP_TYPE_CMSG_MULTI_ENT:\n\t\t\tif (nfp_bpf_parse_cap_cmsg_multi_ent(app->priv, value,\n\t\t\t\t\t\t\t     length))\n\t\t\t\tgoto err_release_free;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tnfp_dbg(cpp, \"unknown BPF capability: %d\\n\", type);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (mem - start != nfp_cpp_area_size(area)) {\n\t\tnfp_err(cpp, \"BPF capabilities left after parsing, parsed:%zd total length:%zu\\n\",\n\t\t\tmem - start, nfp_cpp_area_size(area));\n\t\tgoto err_release_free;\n\t}\n\n\tnfp_cpp_area_release_free(area);\n\n\treturn 0;\n\nerr_release_free:\n\tnfp_err(cpp, \"invalid BPF capabilities at offset:%zd\\n\", mem - start);\n\tnfp_cpp_area_release_free(area);\n\treturn -EINVAL;\n}\n\nstatic void nfp_bpf_init_capabilities(struct nfp_app_bpf *bpf)\n{\n\tbpf->abi_version = 2;  \n}\n\nstatic int nfp_bpf_ndo_init(struct nfp_app *app, struct net_device *netdev)\n{\n\tstruct nfp_app_bpf *bpf = app->priv;\n\n\treturn bpf_offload_dev_netdev_register(bpf->bpf_dev, netdev);\n}\n\nstatic void nfp_bpf_ndo_uninit(struct nfp_app *app, struct net_device *netdev)\n{\n\tstruct nfp_app_bpf *bpf = app->priv;\n\n\tbpf_offload_dev_netdev_unregister(bpf->bpf_dev, netdev);\n}\n\nstatic int nfp_bpf_start(struct nfp_app *app)\n{\n\tstruct nfp_app_bpf *bpf = app->priv;\n\n\tif (app->ctrl->dp.mtu < nfp_bpf_ctrl_cmsg_min_mtu(bpf)) {\n\t\tnfp_err(bpf->app->cpp,\n\t\t\t\"ctrl channel MTU below min required %u < %u\\n\",\n\t\t\tapp->ctrl->dp.mtu, nfp_bpf_ctrl_cmsg_min_mtu(bpf));\n\t\treturn -EINVAL;\n\t}\n\n\tif (bpf->cmsg_multi_ent)\n\t\tbpf->cmsg_cache_cnt = nfp_bpf_ctrl_cmsg_cache_cnt(bpf);\n\telse\n\t\tbpf->cmsg_cache_cnt = 1;\n\n\treturn 0;\n}\n\nstatic int nfp_bpf_init(struct nfp_app *app)\n{\n\tstruct nfp_app_bpf *bpf;\n\tint err;\n\n\tbpf = kzalloc(sizeof(*bpf), GFP_KERNEL);\n\tif (!bpf)\n\t\treturn -ENOMEM;\n\tbpf->app = app;\n\tapp->priv = bpf;\n\n\tINIT_LIST_HEAD(&bpf->map_list);\n\n\terr = nfp_ccm_init(&bpf->ccm, app);\n\tif (err)\n\t\tgoto err_free_bpf;\n\n\terr = rhashtable_init(&bpf->maps_neutral, &nfp_bpf_maps_neutral_params);\n\tif (err)\n\t\tgoto err_clean_ccm;\n\n\tnfp_bpf_init_capabilities(bpf);\n\n\terr = nfp_bpf_parse_capabilities(app);\n\tif (err)\n\t\tgoto err_free_neutral_maps;\n\n\tif (bpf->abi_version < 3) {\n\t\tbpf->cmsg_key_sz = CMSG_MAP_KEY_LW * 4;\n\t\tbpf->cmsg_val_sz = CMSG_MAP_VALUE_LW * 4;\n\t} else {\n\t\tbpf->cmsg_key_sz = bpf->maps.max_key_sz;\n\t\tbpf->cmsg_val_sz = bpf->maps.max_val_sz;\n\t\tapp->ctrl_mtu = nfp_bpf_ctrl_cmsg_mtu(bpf);\n\t}\n\n\tbpf->bpf_dev = bpf_offload_dev_create(&nfp_bpf_dev_ops, bpf);\n\terr = PTR_ERR_OR_ZERO(bpf->bpf_dev);\n\tif (err)\n\t\tgoto err_free_neutral_maps;\n\n\treturn 0;\n\nerr_free_neutral_maps:\n\trhashtable_destroy(&bpf->maps_neutral);\nerr_clean_ccm:\n\tnfp_ccm_clean(&bpf->ccm);\nerr_free_bpf:\n\tkfree(bpf);\n\treturn err;\n}\n\nstatic void nfp_bpf_clean(struct nfp_app *app)\n{\n\tstruct nfp_app_bpf *bpf = app->priv;\n\n\tbpf_offload_dev_destroy(bpf->bpf_dev);\n\tnfp_ccm_clean(&bpf->ccm);\n\tWARN_ON(!list_empty(&bpf->map_list));\n\tWARN_ON(bpf->maps_in_use || bpf->map_elems_in_use);\n\trhashtable_free_and_destroy(&bpf->maps_neutral,\n\t\t\t\t    nfp_check_rhashtable_empty, NULL);\n\tkfree(bpf);\n}\n\nconst struct nfp_app_type app_bpf = {\n\t.id\t\t= NFP_APP_BPF_NIC,\n\t.name\t\t= \"ebpf\",\n\n\t.ctrl_cap_mask\t= 0,\n\n\t.init\t\t= nfp_bpf_init,\n\t.clean\t\t= nfp_bpf_clean,\n\t.start\t\t= nfp_bpf_start,\n\n\t.check_mtu\t= nfp_bpf_check_mtu,\n\n\t.extra_cap\t= nfp_bpf_extra_cap,\n\n\t.ndo_init\t= nfp_bpf_ndo_init,\n\t.ndo_uninit\t= nfp_bpf_ndo_uninit,\n\n\t.vnic_alloc\t= nfp_bpf_vnic_alloc,\n\t.vnic_free\t= nfp_bpf_vnic_free,\n\n\t.ctrl_msg_rx\t= nfp_bpf_ctrl_msg_rx,\n\t.ctrl_msg_rx_raw\t= nfp_bpf_ctrl_msg_rx_raw,\n\n\t.setup_tc\t= nfp_bpf_setup_tc,\n\t.bpf\t\t= nfp_ndo_bpf,\n\t.xdp_offload\t= nfp_bpf_xdp_offload,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}