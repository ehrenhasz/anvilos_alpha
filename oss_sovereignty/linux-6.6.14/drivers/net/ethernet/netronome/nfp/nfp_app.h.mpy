{
  "module_name": "nfp_app.h",
  "hash_id": "69895f2ac7a757d2833c7e8ca838ee8c3628b53ecbe8722d8ed432d23e60a230",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/netronome/nfp/nfp_app.h",
  "human_readable_source": " \n \n\n#ifndef _NFP_APP_H\n#define _NFP_APP_H 1\n\n#include <net/devlink.h>\n\n#include <trace/events/devlink.h>\n\n#include \"nfp_net_repr.h\"\n\n#define NFP_APP_CTRL_MTU_MAX\tU32_MAX\n\nstruct bpf_prog;\nstruct net_device;\nstruct netdev_bpf;\nstruct netlink_ext_ack;\nstruct pci_dev;\nstruct sk_buff;\nstruct nfp_app;\nstruct nfp_cpp;\nstruct nfp_pf;\nstruct nfp_repr;\nstruct nfp_net;\n\nenum nfp_app_id {\n\tNFP_APP_CORE_NIC\t= 0x1,\n\tNFP_APP_BPF_NIC\t\t= 0x2,\n\tNFP_APP_FLOWER_NIC\t= 0x3,\n\tNFP_APP_ACTIVE_BUFFER_MGMT_NIC = 0x4,\n};\n\nextern const struct nfp_app_type app_nic;\nextern const struct nfp_app_type app_bpf;\nextern const struct nfp_app_type app_flower;\nextern const struct nfp_app_type app_abm;\n\n \nstruct nfp_app_type {\n\tenum nfp_app_id id;\n\tconst char *name;\n\n\tu32 ctrl_cap_mask;\n\tbool ctrl_has_meta;\n\n\tint (*init)(struct nfp_app *app);\n\tvoid (*clean)(struct nfp_app *app);\n\n\tconst char *(*extra_cap)(struct nfp_app *app, struct nfp_net *nn);\n\n\tint (*ndo_init)(struct nfp_app *app, struct net_device *netdev);\n\tvoid (*ndo_uninit)(struct nfp_app *app, struct net_device *netdev);\n\n\tint (*vnic_alloc)(struct nfp_app *app, struct nfp_net *nn,\n\t\t\t  unsigned int id);\n\tvoid (*vnic_free)(struct nfp_app *app, struct nfp_net *nn);\n\tint (*vnic_init)(struct nfp_app *app, struct nfp_net *nn);\n\tvoid (*vnic_clean)(struct nfp_app *app, struct nfp_net *nn);\n\n\tint (*repr_init)(struct nfp_app *app, struct net_device *netdev);\n\tvoid (*repr_preclean)(struct nfp_app *app, struct net_device *netdev);\n\tvoid (*repr_clean)(struct nfp_app *app, struct net_device *netdev);\n\n\tint (*repr_open)(struct nfp_app *app, struct nfp_repr *repr);\n\tint (*repr_stop)(struct nfp_app *app, struct nfp_repr *repr);\n\n\tint (*check_mtu)(struct nfp_app *app, struct net_device *netdev,\n\t\t\t int new_mtu);\n\tint (*repr_change_mtu)(struct nfp_app *app, struct net_device *netdev,\n\t\t\t       int new_mtu);\n\n\tu64 *(*port_get_stats)(struct nfp_app *app,\n\t\t\t       struct nfp_port *port, u64 *data);\n\tint (*port_get_stats_count)(struct nfp_app *app, struct nfp_port *port);\n\tu8 *(*port_get_stats_strings)(struct nfp_app *app,\n\t\t\t\t      struct nfp_port *port, u8 *data);\n\n\tint (*start)(struct nfp_app *app);\n\tvoid (*stop)(struct nfp_app *app);\n\n\tint (*netdev_event)(struct nfp_app *app, struct net_device *netdev,\n\t\t\t    unsigned long event, void *ptr);\n\n\tvoid (*ctrl_msg_rx)(struct nfp_app *app, struct sk_buff *skb);\n\tvoid (*ctrl_msg_rx_raw)(struct nfp_app *app, const void *data,\n\t\t\t\tunsigned int len);\n\n\tint (*setup_tc)(struct nfp_app *app, struct net_device *netdev,\n\t\t\tenum tc_setup_type type, void *type_data);\n\tint (*bpf)(struct nfp_app *app, struct nfp_net *nn,\n\t\t   struct netdev_bpf *xdp);\n\tint (*xdp_offload)(struct nfp_app *app, struct nfp_net *nn,\n\t\t\t   struct bpf_prog *prog,\n\t\t\t   struct netlink_ext_ack *extack);\n\n\tint (*sriov_enable)(struct nfp_app *app, int num_vfs);\n\tvoid (*sriov_disable)(struct nfp_app *app);\n\n\tenum devlink_eswitch_mode (*eswitch_mode_get)(struct nfp_app *app);\n\tint (*eswitch_mode_set)(struct nfp_app *app, u16 mode);\n\tstruct net_device *(*dev_get)(struct nfp_app *app, u32 id,\n\t\t\t\t      bool *redir_egress);\n};\n\n \nstruct nfp_app {\n\tstruct pci_dev *pdev;\n\tstruct nfp_pf *pf;\n\tstruct nfp_cpp *cpp;\n\n\tstruct nfp_net *ctrl;\n\tstruct nfp_reprs __rcu *reprs[NFP_REPR_TYPE_MAX + 1];\n\n\tconst struct nfp_app_type *type;\n\tunsigned int ctrl_mtu;\n\n\tstruct notifier_block netdev_nb;\n\n\tvoid *priv;\n};\n\nstatic inline void assert_nfp_app_locked(struct nfp_app *app)\n{\n\tdevl_assert_locked(priv_to_devlink(app->pf));\n}\n\nstatic inline bool nfp_app_is_locked(struct nfp_app *app)\n{\n\treturn devl_lock_is_held(priv_to_devlink(app->pf));\n}\n\nvoid nfp_check_rhashtable_empty(void *ptr, void *arg);\nbool __nfp_ctrl_tx(struct nfp_net *nn, struct sk_buff *skb);\nbool nfp_ctrl_tx(struct nfp_net *nn, struct sk_buff *skb);\n\nstatic inline int nfp_app_init(struct nfp_app *app)\n{\n\tif (!app->type->init)\n\t\treturn 0;\n\treturn app->type->init(app);\n}\n\nstatic inline void nfp_app_clean(struct nfp_app *app)\n{\n\tif (app->type->clean)\n\t\tapp->type->clean(app);\n}\n\nint nfp_app_ndo_init(struct net_device *netdev);\nvoid nfp_app_ndo_uninit(struct net_device *netdev);\n\nstatic inline int nfp_app_vnic_alloc(struct nfp_app *app, struct nfp_net *nn,\n\t\t\t\t     unsigned int id)\n{\n\treturn app->type->vnic_alloc(app, nn, id);\n}\n\nstatic inline void nfp_app_vnic_free(struct nfp_app *app, struct nfp_net *nn)\n{\n\tif (app->type->vnic_free)\n\t\tapp->type->vnic_free(app, nn);\n}\n\nstatic inline int nfp_app_vnic_init(struct nfp_app *app, struct nfp_net *nn)\n{\n\tif (!app->type->vnic_init)\n\t\treturn 0;\n\treturn app->type->vnic_init(app, nn);\n}\n\nstatic inline void nfp_app_vnic_clean(struct nfp_app *app, struct nfp_net *nn)\n{\n\tif (app->type->vnic_clean)\n\t\tapp->type->vnic_clean(app, nn);\n}\n\nstatic inline int nfp_app_repr_open(struct nfp_app *app, struct nfp_repr *repr)\n{\n\tif (!app->type->repr_open)\n\t\treturn -EINVAL;\n\treturn app->type->repr_open(app, repr);\n}\n\nstatic inline int nfp_app_repr_stop(struct nfp_app *app, struct nfp_repr *repr)\n{\n\tif (!app->type->repr_stop)\n\t\treturn -EINVAL;\n\treturn app->type->repr_stop(app, repr);\n}\n\nstatic inline int\nnfp_app_repr_init(struct nfp_app *app, struct net_device *netdev)\n{\n\tif (!app->type->repr_init)\n\t\treturn 0;\n\treturn app->type->repr_init(app, netdev);\n}\n\nstatic inline void\nnfp_app_repr_preclean(struct nfp_app *app, struct net_device *netdev)\n{\n\tif (app->type->repr_preclean)\n\t\tapp->type->repr_preclean(app, netdev);\n}\n\nstatic inline void\nnfp_app_repr_clean(struct nfp_app *app, struct net_device *netdev)\n{\n\tif (app->type->repr_clean)\n\t\tapp->type->repr_clean(app, netdev);\n}\n\nstatic inline int\nnfp_app_check_mtu(struct nfp_app *app, struct net_device *netdev, int new_mtu)\n{\n\tif (!app || !app->type->check_mtu)\n\t\treturn 0;\n\treturn app->type->check_mtu(app, netdev, new_mtu);\n}\n\nstatic inline int\nnfp_app_repr_change_mtu(struct nfp_app *app, struct net_device *netdev,\n\t\t\tint new_mtu)\n{\n\tif (!app || !app->type->repr_change_mtu)\n\t\treturn 0;\n\treturn app->type->repr_change_mtu(app, netdev, new_mtu);\n}\n\nstatic inline const char *nfp_app_name(struct nfp_app *app)\n{\n\tif (!app)\n\t\treturn \"\";\n\treturn app->type->name;\n}\n\nstatic inline bool nfp_app_needs_ctrl_vnic(struct nfp_app *app)\n{\n\treturn app && app->type->ctrl_msg_rx;\n}\n\nstatic inline bool nfp_app_ctrl_has_meta(struct nfp_app *app)\n{\n\treturn app->type->ctrl_has_meta;\n}\n\nstatic inline bool nfp_app_ctrl_uses_data_vnics(struct nfp_app *app)\n{\n\treturn app && app->type->ctrl_msg_rx_raw;\n}\n\nstatic inline const char *nfp_app_extra_cap(struct nfp_app *app,\n\t\t\t\t\t    struct nfp_net *nn)\n{\n\tif (!app || !app->type->extra_cap)\n\t\treturn \"\";\n\treturn app->type->extra_cap(app, nn);\n}\n\nstatic inline bool nfp_app_has_tc(struct nfp_app *app)\n{\n\treturn app && app->type->setup_tc;\n}\n\nstatic inline int nfp_app_setup_tc(struct nfp_app *app,\n\t\t\t\t   struct net_device *netdev,\n\t\t\t\t   enum tc_setup_type type, void *type_data)\n{\n\tif (!app || !app->type->setup_tc)\n\t\treturn -EOPNOTSUPP;\n\treturn app->type->setup_tc(app, netdev, type, type_data);\n}\n\nstatic inline int nfp_app_bpf(struct nfp_app *app, struct nfp_net *nn,\n\t\t\t      struct netdev_bpf *bpf)\n{\n\tif (!app || !app->type->bpf)\n\t\treturn -EINVAL;\n\treturn app->type->bpf(app, nn, bpf);\n}\n\nstatic inline int nfp_app_xdp_offload(struct nfp_app *app, struct nfp_net *nn,\n\t\t\t\t      struct bpf_prog *prog,\n\t\t\t\t      struct netlink_ext_ack *extack)\n{\n\tif (!app || !app->type->xdp_offload)\n\t\treturn -EOPNOTSUPP;\n\treturn app->type->xdp_offload(app, nn, prog, extack);\n}\n\nstatic inline bool __nfp_app_ctrl_tx(struct nfp_app *app, struct sk_buff *skb)\n{\n\ttrace_devlink_hwmsg(priv_to_devlink(app->pf), false, 0,\n\t\t\t    skb->data, skb->len);\n\n\treturn __nfp_ctrl_tx(app->ctrl, skb);\n}\n\nstatic inline bool nfp_app_ctrl_tx(struct nfp_app *app, struct sk_buff *skb)\n{\n\ttrace_devlink_hwmsg(priv_to_devlink(app->pf), false, 0,\n\t\t\t    skb->data, skb->len);\n\n\treturn nfp_ctrl_tx(app->ctrl, skb);\n}\n\nstatic inline void nfp_app_ctrl_rx(struct nfp_app *app, struct sk_buff *skb)\n{\n\ttrace_devlink_hwmsg(priv_to_devlink(app->pf), true, 0,\n\t\t\t    skb->data, skb->len);\n\n\tapp->type->ctrl_msg_rx(app, skb);\n}\n\nstatic inline void\nnfp_app_ctrl_rx_raw(struct nfp_app *app, const void *data, unsigned int len)\n{\n\tif (!app || !app->type->ctrl_msg_rx_raw)\n\t\treturn;\n\n\ttrace_devlink_hwmsg(priv_to_devlink(app->pf), true, 0, data, len);\n\tapp->type->ctrl_msg_rx_raw(app, data, len);\n}\n\nstatic inline int nfp_app_eswitch_mode_get(struct nfp_app *app, u16 *mode)\n{\n\tif (!app->type->eswitch_mode_get)\n\t\treturn -EOPNOTSUPP;\n\n\t*mode = app->type->eswitch_mode_get(app);\n\n\treturn 0;\n}\n\nstatic inline int nfp_app_eswitch_mode_set(struct nfp_app *app, u16 mode)\n{\n\tif (!app->type->eswitch_mode_set)\n\t\treturn -EOPNOTSUPP;\n\treturn app->type->eswitch_mode_set(app, mode);\n}\n\nstatic inline int nfp_app_sriov_enable(struct nfp_app *app, int num_vfs)\n{\n\tif (!app || !app->type->sriov_enable)\n\t\treturn -EOPNOTSUPP;\n\treturn app->type->sriov_enable(app, num_vfs);\n}\n\nstatic inline void nfp_app_sriov_disable(struct nfp_app *app)\n{\n\tif (app && app->type->sriov_disable)\n\t\tapp->type->sriov_disable(app);\n}\n\nstatic inline\nstruct net_device *nfp_app_dev_get(struct nfp_app *app, u32 id,\n\t\t\t\t   bool *redir_egress)\n{\n\tif (unlikely(!app || !app->type->dev_get))\n\t\treturn NULL;\n\n\treturn app->type->dev_get(app, id, redir_egress);\n}\n\nstruct nfp_app *nfp_app_from_netdev(struct net_device *netdev);\n\nu64 *nfp_app_port_get_stats(struct nfp_port *port, u64 *data);\nint nfp_app_port_get_stats_count(struct nfp_port *port);\nu8 *nfp_app_port_get_stats_strings(struct nfp_port *port, u8 *data);\n\nstruct nfp_reprs *\nnfp_reprs_get_locked(struct nfp_app *app, enum nfp_repr_type type);\nstruct nfp_reprs *\nnfp_app_reprs_set(struct nfp_app *app, enum nfp_repr_type type,\n\t\t  struct nfp_reprs *reprs);\n\nconst char *nfp_app_mip_name(struct nfp_app *app);\nstruct sk_buff *\nnfp_app_ctrl_msg_alloc(struct nfp_app *app, unsigned int size, gfp_t priority);\n\nstruct nfp_app *nfp_app_alloc(struct nfp_pf *pf, enum nfp_app_id id);\nvoid nfp_app_free(struct nfp_app *app);\nint nfp_app_start(struct nfp_app *app, struct nfp_net *ctrl);\nvoid nfp_app_stop(struct nfp_app *app);\n\n \n\nint nfp_app_nic_vnic_alloc(struct nfp_app *app, struct nfp_net *nn,\n\t\t\t   unsigned int id);\nint nfp_app_nic_vnic_init_phy_port(struct nfp_pf *pf, struct nfp_app *app,\n\t\t\t\t   struct nfp_net *nn, unsigned int id);\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}