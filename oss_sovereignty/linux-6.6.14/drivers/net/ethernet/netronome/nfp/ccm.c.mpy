{
  "module_name": "ccm.c",
  "hash_id": "1ed754ba5824e23f96335ef79e8317ee3d5801666e1e227b6e624f6dd0219663",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/netronome/nfp/ccm.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n\n#include \"ccm.h\"\n#include \"nfp_app.h\"\n#include \"nfp_net.h\"\n\n#define ccm_warn(app, msg...)\tnn_dp_warn(&(app)->ctrl->dp, msg)\n\n#define NFP_CCM_TAG_ALLOC_SPAN\t(U16_MAX / 4)\n\nstatic bool nfp_ccm_all_tags_busy(struct nfp_ccm *ccm)\n{\n\tu16 used_tags;\n\n\tused_tags = ccm->tag_alloc_next - ccm->tag_alloc_last;\n\n\treturn used_tags > NFP_CCM_TAG_ALLOC_SPAN;\n}\n\nstatic int nfp_ccm_alloc_tag(struct nfp_ccm *ccm)\n{\n\t \n\tif (unlikely(nfp_ccm_all_tags_busy(ccm))) {\n\t\tccm_warn(ccm->app, \"all FW request contexts busy!\\n\");\n\t\treturn -EAGAIN;\n\t}\n\n\tWARN_ON(__test_and_set_bit(ccm->tag_alloc_next, ccm->tag_allocator));\n\treturn ccm->tag_alloc_next++;\n}\n\nstatic void nfp_ccm_free_tag(struct nfp_ccm *ccm, u16 tag)\n{\n\tWARN_ON(!__test_and_clear_bit(tag, ccm->tag_allocator));\n\n\twhile (!test_bit(ccm->tag_alloc_last, ccm->tag_allocator) &&\n\t       ccm->tag_alloc_last != ccm->tag_alloc_next)\n\t\tccm->tag_alloc_last++;\n}\n\nstatic struct sk_buff *__nfp_ccm_reply(struct nfp_ccm *ccm, u16 tag)\n{\n\tunsigned int msg_tag;\n\tstruct sk_buff *skb;\n\n\tskb_queue_walk(&ccm->replies, skb) {\n\t\tmsg_tag = nfp_ccm_get_tag(skb);\n\t\tif (msg_tag == tag) {\n\t\t\tnfp_ccm_free_tag(ccm, tag);\n\t\t\t__skb_unlink(skb, &ccm->replies);\n\t\t\treturn skb;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstatic struct sk_buff *\nnfp_ccm_reply(struct nfp_ccm *ccm, struct nfp_app *app, u16 tag)\n{\n\tstruct sk_buff *skb;\n\n\tnfp_ctrl_lock(app->ctrl);\n\tskb = __nfp_ccm_reply(ccm, tag);\n\tnfp_ctrl_unlock(app->ctrl);\n\n\treturn skb;\n}\n\nstatic struct sk_buff *\nnfp_ccm_reply_drop_tag(struct nfp_ccm *ccm, struct nfp_app *app, u16 tag)\n{\n\tstruct sk_buff *skb;\n\n\tnfp_ctrl_lock(app->ctrl);\n\tskb = __nfp_ccm_reply(ccm, tag);\n\tif (!skb)\n\t\tnfp_ccm_free_tag(ccm, tag);\n\tnfp_ctrl_unlock(app->ctrl);\n\n\treturn skb;\n}\n\nstatic struct sk_buff *\nnfp_ccm_wait_reply(struct nfp_ccm *ccm, struct nfp_app *app,\n\t\t   enum nfp_ccm_type type, int tag)\n{\n\tstruct sk_buff *skb;\n\tint i, err;\n\n\tfor (i = 0; i < 50; i++) {\n\t\tudelay(4);\n\t\tskb = nfp_ccm_reply(ccm, app, tag);\n\t\tif (skb)\n\t\t\treturn skb;\n\t}\n\n\terr = wait_event_interruptible_timeout(ccm->wq,\n\t\t\t\t\t       skb = nfp_ccm_reply(ccm, app,\n\t\t\t\t\t\t\t\t   tag),\n\t\t\t\t\t       msecs_to_jiffies(5000));\n\t \n\tif (!skb)\n\t\tskb = nfp_ccm_reply_drop_tag(ccm, app, tag);\n\tif (err < 0) {\n\t\tccm_warn(app, \"%s waiting for response to 0x%02x: %d\\n\",\n\t\t\t err == ERESTARTSYS ? \"interrupted\" : \"error\",\n\t\t\t type, err);\n\t\treturn ERR_PTR(err);\n\t}\n\tif (!skb) {\n\t\tccm_warn(app, \"timeout waiting for response to 0x%02x\\n\", type);\n\t\treturn ERR_PTR(-ETIMEDOUT);\n\t}\n\n\treturn skb;\n}\n\nstruct sk_buff *\nnfp_ccm_communicate(struct nfp_ccm *ccm, struct sk_buff *skb,\n\t\t    enum nfp_ccm_type type, unsigned int reply_size)\n{\n\tstruct nfp_app *app = ccm->app;\n\tstruct nfp_ccm_hdr *hdr;\n\tint reply_type, tag;\n\n\tnfp_ctrl_lock(app->ctrl);\n\ttag = nfp_ccm_alloc_tag(ccm);\n\tif (tag < 0) {\n\t\tnfp_ctrl_unlock(app->ctrl);\n\t\tdev_kfree_skb_any(skb);\n\t\treturn ERR_PTR(tag);\n\t}\n\n\thdr = (void *)skb->data;\n\thdr->ver = NFP_CCM_ABI_VERSION;\n\thdr->type = type;\n\thdr->tag = cpu_to_be16(tag);\n\n\t__nfp_app_ctrl_tx(app, skb);\n\n\tnfp_ctrl_unlock(app->ctrl);\n\n\tskb = nfp_ccm_wait_reply(ccm, app, type, tag);\n\tif (IS_ERR(skb))\n\t\treturn skb;\n\n\treply_type = nfp_ccm_get_type(skb);\n\tif (reply_type != __NFP_CCM_REPLY(type)) {\n\t\tccm_warn(app, \"cmsg drop - wrong type 0x%02x != 0x%02lx!\\n\",\n\t\t\t reply_type, __NFP_CCM_REPLY(type));\n\t\tgoto err_free;\n\t}\n\t \n\tif (reply_size && skb->len != reply_size) {\n\t\tccm_warn(app, \"cmsg drop - type 0x%02x wrong size %d != %d!\\n\",\n\t\t\t type, skb->len, reply_size);\n\t\tgoto err_free;\n\t}\n\n\treturn skb;\nerr_free:\n\tdev_kfree_skb_any(skb);\n\treturn ERR_PTR(-EIO);\n}\n\nvoid nfp_ccm_rx(struct nfp_ccm *ccm, struct sk_buff *skb)\n{\n\tstruct nfp_app *app = ccm->app;\n\tunsigned int tag;\n\n\tif (unlikely(skb->len < sizeof(struct nfp_ccm_hdr))) {\n\t\tccm_warn(app, \"cmsg drop - too short %d!\\n\", skb->len);\n\t\tgoto err_free;\n\t}\n\n\tnfp_ctrl_lock(app->ctrl);\n\n\ttag = nfp_ccm_get_tag(skb);\n\tif (unlikely(!test_bit(tag, ccm->tag_allocator))) {\n\t\tccm_warn(app, \"cmsg drop - no one is waiting for tag %u!\\n\",\n\t\t\t tag);\n\t\tgoto err_unlock;\n\t}\n\n\t__skb_queue_tail(&ccm->replies, skb);\n\twake_up_interruptible_all(&ccm->wq);\n\n\tnfp_ctrl_unlock(app->ctrl);\n\treturn;\n\nerr_unlock:\n\tnfp_ctrl_unlock(app->ctrl);\nerr_free:\n\tdev_kfree_skb_any(skb);\n}\n\nint nfp_ccm_init(struct nfp_ccm *ccm, struct nfp_app *app)\n{\n\tccm->app = app;\n\tskb_queue_head_init(&ccm->replies);\n\tinit_waitqueue_head(&ccm->wq);\n\treturn 0;\n}\n\nvoid nfp_ccm_clean(struct nfp_ccm *ccm)\n{\n\tWARN_ON(!skb_queue_empty(&ccm->replies));\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}