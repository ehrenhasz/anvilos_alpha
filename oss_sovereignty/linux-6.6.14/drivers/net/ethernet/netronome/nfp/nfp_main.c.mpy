{
  "module_name": "nfp_main.c",
  "hash_id": "5bf298d79cf130b455dbeaa7edf614ed734d207c78a8d4b1069129726dcba5a9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/netronome/nfp/nfp_main.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/pci.h>\n#include <linux/firmware.h>\n#include <linux/vmalloc.h>\n#include <net/devlink.h>\n\n#include \"nfpcore/nfp.h\"\n#include \"nfpcore/nfp_cpp.h\"\n#include \"nfpcore/nfp_dev.h\"\n#include \"nfpcore/nfp_nffw.h\"\n#include \"nfpcore/nfp_nsp.h\"\n\n#include \"nfpcore/nfp6000_pcie.h\"\n\n#include \"nfp_abi.h\"\n#include \"nfp_app.h\"\n#include \"nfp_main.h\"\n#include \"nfp_net.h\"\n\nstatic const char nfp_driver_name[] = \"nfp\";\n\nstatic const struct pci_device_id nfp_pci_device_ids[] = {\n\t{ PCI_VENDOR_ID_NETRONOME, PCI_DEVICE_ID_NFP3800,\n\t  PCI_VENDOR_ID_NETRONOME, PCI_ANY_ID,\n\t  PCI_ANY_ID, 0, NFP_DEV_NFP3800,\n\t},\n\t{ PCI_VENDOR_ID_NETRONOME, PCI_DEVICE_ID_NFP4000,\n\t  PCI_VENDOR_ID_NETRONOME, PCI_ANY_ID,\n\t  PCI_ANY_ID, 0, NFP_DEV_NFP6000,\n\t},\n\t{ PCI_VENDOR_ID_NETRONOME, PCI_DEVICE_ID_NFP5000,\n\t  PCI_VENDOR_ID_NETRONOME, PCI_ANY_ID,\n\t  PCI_ANY_ID, 0, NFP_DEV_NFP6000,\n\t},\n\t{ PCI_VENDOR_ID_NETRONOME, PCI_DEVICE_ID_NFP6000,\n\t  PCI_VENDOR_ID_NETRONOME, PCI_ANY_ID,\n\t  PCI_ANY_ID, 0, NFP_DEV_NFP6000,\n\t},\n\t{ PCI_VENDOR_ID_CORIGINE, PCI_DEVICE_ID_NFP3800,\n\t  PCI_VENDOR_ID_CORIGINE, PCI_ANY_ID,\n\t  PCI_ANY_ID, 0, NFP_DEV_NFP3800,\n\t},\n\t{ PCI_VENDOR_ID_CORIGINE, PCI_DEVICE_ID_NFP4000,\n\t  PCI_VENDOR_ID_CORIGINE, PCI_ANY_ID,\n\t  PCI_ANY_ID, 0, NFP_DEV_NFP6000,\n\t},\n\t{ PCI_VENDOR_ID_CORIGINE, PCI_DEVICE_ID_NFP5000,\n\t  PCI_VENDOR_ID_CORIGINE, PCI_ANY_ID,\n\t  PCI_ANY_ID, 0, NFP_DEV_NFP6000,\n\t},\n\t{ PCI_VENDOR_ID_CORIGINE, PCI_DEVICE_ID_NFP6000,\n\t  PCI_VENDOR_ID_CORIGINE, PCI_ANY_ID,\n\t  PCI_ANY_ID, 0, NFP_DEV_NFP6000,\n\t},\n\t{ 0, }  \n};\nMODULE_DEVICE_TABLE(pci, nfp_pci_device_ids);\n\nint nfp_pf_rtsym_read_optional(struct nfp_pf *pf, const char *format,\n\t\t\t       unsigned int default_val)\n{\n\tchar name[256];\n\tint err = 0;\n\tu64 val;\n\n\tsnprintf(name, sizeof(name), format, nfp_cppcore_pcie_unit(pf->cpp));\n\n\tval = nfp_rtsym_read_le(pf->rtbl, name, &err);\n\tif (err) {\n\t\tif (err == -ENOENT)\n\t\t\treturn default_val;\n\t\tnfp_err(pf->cpp, \"Unable to read symbol %s\\n\", name);\n\t\treturn err;\n\t}\n\n\treturn val;\n}\n\nu8 __iomem *\nnfp_pf_map_rtsym(struct nfp_pf *pf, const char *name, const char *sym_fmt,\n\t\t unsigned int min_size, struct nfp_cpp_area **area)\n{\n\tchar pf_symbol[256];\n\n\tsnprintf(pf_symbol, sizeof(pf_symbol), sym_fmt,\n\t\t nfp_cppcore_pcie_unit(pf->cpp));\n\n\treturn nfp_rtsym_map(pf->rtbl, pf_symbol, name, min_size, area);\n}\n\n \nint nfp_mbox_cmd(struct nfp_pf *pf, u32 cmd, void *in_data, u64 in_length,\n\t\t void *out_data, u64 out_length)\n{\n\tunsigned long err_at;\n\tu64 max_data_sz;\n\tu32 val = 0;\n\tint n, err;\n\n\tif (!pf->mbox)\n\t\treturn -EOPNOTSUPP;\n\n\tmax_data_sz = nfp_rtsym_size(pf->mbox) - NFP_MBOX_SYM_MIN_SIZE;\n\n\t \n\terr = nfp_rtsym_readl(pf->cpp, pf->mbox, NFP_MBOX_CMD, &val);\n\tif (err || val) {\n\t\tnfp_warn(pf->cpp, \"failed to issue command (%u): %u, err: %d\\n\",\n\t\t\t cmd, val, err);\n\t\treturn err ?: -EBUSY;\n\t}\n\n\tin_length = min(in_length, max_data_sz);\n\tn = nfp_rtsym_write(pf->cpp, pf->mbox, NFP_MBOX_DATA, in_data,\n\t\t\t    in_length);\n\tif (n != in_length)\n\t\treturn -EIO;\n\t \n\terr = nfp_rtsym_writeq(pf->cpp, pf->mbox, NFP_MBOX_DATA_LEN, in_length);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = nfp_rtsym_readl(pf->cpp, pf->mbox, NFP_MBOX_DATA_LEN, &val);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = nfp_rtsym_writeq(pf->cpp, pf->mbox, NFP_MBOX_CMD, cmd);\n\tif (err)\n\t\treturn err;\n\n\terr_at = jiffies + 5 * HZ;\n\twhile (true) {\n\t\t \n\t\terr = nfp_rtsym_readl(pf->cpp, pf->mbox, NFP_MBOX_CMD, &val);\n\t\tif (err)\n\t\t\treturn err;\n\t\tif (!val)\n\t\t\tbreak;\n\n\t\tif (time_is_before_eq_jiffies(err_at))\n\t\t\treturn -ETIMEDOUT;\n\n\t\tmsleep(5);\n\t}\n\n\t \n\terr = nfp_rtsym_readl(pf->cpp, pf->mbox, NFP_MBOX_DATA_LEN, &val);\n\tif (err)\n\t\treturn err;\n\n\tout_length = min_t(u32, val, min(out_length, max_data_sz));\n\tn = nfp_rtsym_read(pf->cpp, pf->mbox, NFP_MBOX_DATA,\n\t\t\t   out_data, out_length);\n\tif (n != out_length)\n\t\treturn -EIO;\n\n\t \n\terr = nfp_rtsym_readl(pf->cpp, pf->mbox, NFP_MBOX_RET, &val);\n\tif (err)\n\t\treturn err;\n\tif (val)\n\t\treturn -val;\n\n\treturn out_length;\n}\n\nstatic bool nfp_board_ready(struct nfp_pf *pf)\n{\n\tconst char *cp;\n\tlong state;\n\tint err;\n\n\tcp = nfp_hwinfo_lookup(pf->hwinfo, \"board.state\");\n\tif (!cp)\n\t\treturn false;\n\n\terr = kstrtol(cp, 0, &state);\n\tif (err < 0)\n\t\treturn false;\n\n\treturn state == 15;\n}\n\nstatic int nfp_pf_board_state_wait(struct nfp_pf *pf)\n{\n\tconst unsigned long wait_until = jiffies + 10 * HZ;\n\n\twhile (!nfp_board_ready(pf)) {\n\t\tif (time_is_before_eq_jiffies(wait_until)) {\n\t\t\tnfp_err(pf->cpp, \"NFP board initialization timeout\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tnfp_info(pf->cpp, \"waiting for board initialization\\n\");\n\t\tif (msleep_interruptible(500))\n\t\t\treturn -ERESTARTSYS;\n\n\t\t \n\t\tkfree(pf->hwinfo);\n\t\tpf->hwinfo = nfp_hwinfo_read(pf->cpp);\n\t}\n\n\treturn 0;\n}\n\nstatic int nfp_pcie_sriov_read_nfd_limit(struct nfp_pf *pf)\n{\n\tint err;\n\n\tpf->limit_vfs = nfp_rtsym_read_le(pf->rtbl, \"nfd_vf_cfg_max_vfs\", &err);\n\tif (err) {\n\t\t \n\t\tpf->limit_vfs = ~0;\n\t\tif (err == -ENOENT)\n\t\t\treturn 0;\n\n\t\tnfp_warn(pf->cpp, \"Warning: VF limit read failed: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\terr = pci_sriov_set_totalvfs(pf->pdev, pf->limit_vfs);\n\tif (err)\n\t\tnfp_warn(pf->cpp, \"Failed to set VF count in sysfs: %d\\n\", err);\n\treturn 0;\n}\n\nstatic int nfp_pcie_sriov_enable(struct pci_dev *pdev, int num_vfs)\n{\n#ifdef CONFIG_PCI_IOV\n\tstruct nfp_pf *pf = pci_get_drvdata(pdev);\n\tstruct devlink *devlink;\n\tint err;\n\n\tif (num_vfs > pf->limit_vfs) {\n\t\tnfp_info(pf->cpp, \"Firmware limits number of VFs to %u\\n\",\n\t\t\t pf->limit_vfs);\n\t\treturn -EINVAL;\n\t}\n\n\terr = pci_enable_sriov(pdev, num_vfs);\n\tif (err) {\n\t\tdev_warn(&pdev->dev, \"Failed to enable PCI SR-IOV: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tdevlink = priv_to_devlink(pf);\n\tdevl_lock(devlink);\n\n\terr = nfp_app_sriov_enable(pf->app, num_vfs);\n\tif (err) {\n\t\tdev_warn(&pdev->dev,\n\t\t\t \"App specific PCI SR-IOV configuration failed: %d\\n\",\n\t\t\t err);\n\t\tgoto err_sriov_disable;\n\t}\n\n\tpf->num_vfs = num_vfs;\n\n\tdev_dbg(&pdev->dev, \"Created %d VFs.\\n\", pf->num_vfs);\n\n\tdevl_unlock(devlink);\n\treturn num_vfs;\n\nerr_sriov_disable:\n\tdevl_unlock(devlink);\n\tpci_disable_sriov(pdev);\n\treturn err;\n#endif\n\treturn 0;\n}\n\nstatic int nfp_pcie_sriov_disable(struct pci_dev *pdev)\n{\n#ifdef CONFIG_PCI_IOV\n\tstruct nfp_pf *pf = pci_get_drvdata(pdev);\n\tstruct devlink *devlink;\n\n\tdevlink = priv_to_devlink(pf);\n\tdevl_lock(devlink);\n\n\t \n\tif (pci_vfs_assigned(pdev)) {\n\t\tdev_warn(&pdev->dev, \"Disabling while VFs assigned - VFs will not be deallocated\\n\");\n\t\tdevl_unlock(devlink);\n\t\treturn -EPERM;\n\t}\n\n\tnfp_app_sriov_disable(pf->app);\n\n\tpf->num_vfs = 0;\n\n\tdevl_unlock(devlink);\n\n\tpci_disable_sriov(pdev);\n\tdev_dbg(&pdev->dev, \"Removed VFs.\\n\");\n#endif\n\treturn 0;\n}\n\nstatic int nfp_pcie_sriov_configure(struct pci_dev *pdev, int num_vfs)\n{\n\tif (!pci_get_drvdata(pdev))\n\t\treturn -ENOENT;\n\n\tif (num_vfs == 0)\n\t\treturn nfp_pcie_sriov_disable(pdev);\n\telse\n\t\treturn nfp_pcie_sriov_enable(pdev, num_vfs);\n}\n\nint nfp_flash_update_common(struct nfp_pf *pf, const struct firmware *fw,\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct device *dev = &pf->pdev->dev;\n\tstruct nfp_nsp *nsp;\n\tint err;\n\n\tnsp = nfp_nsp_open(pf->cpp);\n\tif (IS_ERR(nsp)) {\n\t\terr = PTR_ERR(nsp);\n\t\tif (extack)\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"can't access NSP\");\n\t\telse\n\t\t\tdev_err(dev, \"Failed to access the NSP: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\terr = nfp_nsp_write_flash(nsp, fw);\n\tif (err < 0)\n\t\tgoto exit_close_nsp;\n\tdev_info(dev, \"Finished writing flash image\\n\");\n\terr = 0;\n\nexit_close_nsp:\n\tnfp_nsp_close(nsp);\n\treturn err;\n}\n\nstatic const struct firmware *\nnfp_net_fw_request(struct pci_dev *pdev, struct nfp_pf *pf, const char *name)\n{\n\tconst struct firmware *fw = NULL;\n\tint err;\n\n\terr = request_firmware_direct(&fw, name, &pdev->dev);\n\tnfp_info(pf->cpp, \"  %s: %s\\n\",\n\t\t name, err ? \"not found\" : \"found\");\n\tif (err)\n\t\treturn NULL;\n\n\treturn fw;\n}\n\n \nstatic const struct firmware *\nnfp_net_fw_find(struct pci_dev *pdev, struct nfp_pf *pf)\n{\n\tstruct nfp_eth_table_port *port;\n\tconst struct firmware *fw;\n\tconst char *fw_model;\n\tchar fw_name[256];\n\tconst u8 *serial;\n\tu16 interface;\n\tint spc, i, j;\n\n\tnfp_info(pf->cpp, \"Looking for firmware file in order of priority:\\n\");\n\n\t \n\tinterface = nfp_cpp_interface(pf->cpp);\n\tnfp_cpp_serial(pf->cpp, &serial);\n\tsprintf(fw_name, \"netronome/serial-%pMF-%02x-%02x.nffw\",\n\t\tserial, interface >> 8, interface & 0xff);\n\tfw = nfp_net_fw_request(pdev, pf, fw_name);\n\tif (fw)\n\t\treturn fw;\n\n\t \n\tsprintf(fw_name, \"netronome/pci-%s.nffw\", pci_name(pdev));\n\tfw = nfp_net_fw_request(pdev, pf, fw_name);\n\tif (fw)\n\t\treturn fw;\n\n\t \n\tif (!pf->eth_tbl) {\n\t\tdev_err(&pdev->dev, \"Error: can't identify media config\\n\");\n\t\treturn NULL;\n\t}\n\n\tfw_model = nfp_hwinfo_lookup(pf->hwinfo, \"nffw.partno\");\n\tif (!fw_model)\n\t\tfw_model = nfp_hwinfo_lookup(pf->hwinfo, \"assembly.partno\");\n\tif (!fw_model) {\n\t\tdev_err(&pdev->dev, \"Error: can't read part number\\n\");\n\t\treturn NULL;\n\t}\n\n\tspc = ARRAY_SIZE(fw_name);\n\tspc -= snprintf(fw_name, spc, \"netronome/nic_%s\", fw_model);\n\n\tfor (i = 0; spc > 0 && i < pf->eth_tbl->count; i += j) {\n\t\tport = &pf->eth_tbl->ports[i];\n\t\tj = 1;\n\t\twhile (i + j < pf->eth_tbl->count &&\n\t\t       port->speed == port[j].speed)\n\t\t\tj++;\n\n\t\tspc -= snprintf(&fw_name[ARRAY_SIZE(fw_name) - spc], spc,\n\t\t\t\t\"_%dx%d\", j, port->speed / 1000);\n\t}\n\n\tif (spc <= 0)\n\t\treturn NULL;\n\n\tspc -= snprintf(&fw_name[ARRAY_SIZE(fw_name) - spc], spc, \".nffw\");\n\tif (spc <= 0)\n\t\treturn NULL;\n\n\treturn nfp_net_fw_request(pdev, pf, fw_name);\n}\n\nstatic int\nnfp_get_fw_policy_value(struct pci_dev *pdev, struct nfp_nsp *nsp,\n\t\t\tconst char *key, const char *default_val, int max_val,\n\t\t\tint *value)\n{\n\tchar hwinfo[64];\n\tlong hi_val;\n\tint err;\n\n\tsnprintf(hwinfo, sizeof(hwinfo), key);\n\terr = nfp_nsp_hwinfo_lookup_optional(nsp, hwinfo, sizeof(hwinfo),\n\t\t\t\t\t     default_val);\n\tif (err)\n\t\treturn err;\n\n\terr = kstrtol(hwinfo, 0, &hi_val);\n\tif (err || hi_val < 0 || hi_val > max_val) {\n\t\tdev_warn(&pdev->dev,\n\t\t\t \"Invalid value '%s' from '%s', ignoring\\n\",\n\t\t\t hwinfo, key);\n\t\terr = kstrtol(default_val, 0, &hi_val);\n\t}\n\n\t*value = hi_val;\n\treturn err;\n}\n\n \nstatic int\nnfp_fw_load(struct pci_dev *pdev, struct nfp_pf *pf, struct nfp_nsp *nsp)\n{\n\tbool do_reset, fw_loaded = false;\n\tconst struct firmware *fw = NULL;\n\tint err, reset, policy, ifcs = 0;\n\tchar *token, *ptr;\n\tchar hwinfo[64];\n\tu16 interface;\n\n\tsnprintf(hwinfo, sizeof(hwinfo), \"abi_drv_load_ifc\");\n\terr = nfp_nsp_hwinfo_lookup_optional(nsp, hwinfo, sizeof(hwinfo),\n\t\t\t\t\t     NFP_NSP_DRV_LOAD_IFC_DEFAULT);\n\tif (err)\n\t\treturn err;\n\n\tinterface = nfp_cpp_interface(pf->cpp);\n\tptr = hwinfo;\n\twhile ((token = strsep(&ptr, \",\"))) {\n\t\tunsigned long interface_hi;\n\n\t\terr = kstrtoul(token, 0, &interface_hi);\n\t\tif (err) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"Failed to parse interface '%s': %d\\n\",\n\t\t\t\ttoken, err);\n\t\t\treturn err;\n\t\t}\n\n\t\tifcs++;\n\t\tif (interface == interface_hi)\n\t\t\tbreak;\n\t}\n\n\tif (!token) {\n\t\tdev_info(&pdev->dev, \"Firmware will be loaded by partner\\n\");\n\t\treturn 0;\n\t}\n\n\terr = nfp_get_fw_policy_value(pdev, nsp, \"abi_drv_reset\",\n\t\t\t\t      NFP_NSP_DRV_RESET_DEFAULT,\n\t\t\t\t      NFP_NSP_DRV_RESET_NEVER, &reset);\n\tif (err)\n\t\treturn err;\n\n\terr = nfp_get_fw_policy_value(pdev, nsp, \"app_fw_from_flash\",\n\t\t\t\t      NFP_NSP_APP_FW_LOAD_DEFAULT,\n\t\t\t\t      NFP_NSP_APP_FW_LOAD_PREF, &policy);\n\tif (err)\n\t\treturn err;\n\n\tfw = nfp_net_fw_find(pdev, pf);\n\tdo_reset = reset == NFP_NSP_DRV_RESET_ALWAYS ||\n\t\t   (fw && reset == NFP_NSP_DRV_RESET_DISK);\n\n\tif (do_reset) {\n\t\tdev_info(&pdev->dev, \"Soft-resetting the NFP\\n\");\n\t\terr = nfp_nsp_device_soft_reset(nsp);\n\t\tif (err < 0) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"Failed to soft reset the NFP: %d\\n\", err);\n\t\t\tgoto exit_release_fw;\n\t\t}\n\t}\n\n\tif (fw && policy != NFP_NSP_APP_FW_LOAD_FLASH) {\n\t\tif (nfp_nsp_has_fw_loaded(nsp) && nfp_nsp_fw_loaded(nsp))\n\t\t\tgoto exit_release_fw;\n\n\t\terr = nfp_nsp_load_fw(nsp, fw);\n\t\tif (err < 0) {\n\t\t\tdev_err(&pdev->dev, \"FW loading failed: %d\\n\",\n\t\t\t\terr);\n\t\t\tgoto exit_release_fw;\n\t\t}\n\t\tdev_info(&pdev->dev, \"Finished loading FW image\\n\");\n\t\tfw_loaded = true;\n\t} else if (policy != NFP_NSP_APP_FW_LOAD_DISK &&\n\t\t   nfp_nsp_has_stored_fw_load(nsp)) {\n\n\t\t \n\t\tif (!nfp_nsp_load_stored_fw(nsp))\n\t\t\tdev_info(&pdev->dev, \"Finished loading stored FW image\\n\");\n\n\t\t \n\t} else {\n\t\tdev_warn(&pdev->dev, \"Didn't load firmware, please update flash or reconfigure card\\n\");\n\t}\n\nexit_release_fw:\n\trelease_firmware(fw);\n\n\t \n\tif (fw_loaded && ifcs == 1)\n\t\tpf->unload_fw_on_remove = true;\n\n\treturn err < 0 ? err : fw_loaded;\n}\n\nstatic void\nnfp_nsp_init_ports(struct pci_dev *pdev, struct nfp_pf *pf,\n\t\t   struct nfp_nsp *nsp)\n{\n\tbool needs_reinit = false;\n\tint i;\n\n\tpf->eth_tbl = __nfp_eth_read_ports(pf->cpp, nsp);\n\tif (!pf->eth_tbl)\n\t\treturn;\n\n\tif (!nfp_nsp_has_mac_reinit(nsp))\n\t\treturn;\n\n\tfor (i = 0; i < pf->eth_tbl->count; i++)\n\t\tneeds_reinit |= pf->eth_tbl->ports[i].override_changed;\n\tif (!needs_reinit)\n\t\treturn;\n\n\tkfree(pf->eth_tbl);\n\tif (nfp_nsp_mac_reinit(nsp))\n\t\tdev_warn(&pdev->dev, \"MAC reinit failed\\n\");\n\n\tpf->eth_tbl = __nfp_eth_read_ports(pf->cpp, nsp);\n}\n\nstatic int nfp_nsp_init(struct pci_dev *pdev, struct nfp_pf *pf)\n{\n\tstruct nfp_nsp *nsp;\n\tint err;\n\n\terr = nfp_resource_wait(pf->cpp, NFP_RESOURCE_NSP, 30);\n\tif (err)\n\t\treturn err;\n\n\tnsp = nfp_nsp_open(pf->cpp);\n\tif (IS_ERR(nsp)) {\n\t\terr = PTR_ERR(nsp);\n\t\tdev_err(&pdev->dev, \"Failed to access the NSP: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\terr = nfp_nsp_wait(nsp);\n\tif (err < 0)\n\t\tgoto exit_close_nsp;\n\n\tnfp_nsp_init_ports(pdev, pf, nsp);\n\n\tpf->nspi = __nfp_nsp_identify(nsp);\n\tif (pf->nspi)\n\t\tdev_info(&pdev->dev, \"BSP: %s\\n\", pf->nspi->version);\n\n\terr = nfp_fw_load(pdev, pf, nsp);\n\tif (err < 0) {\n\t\tkfree(pf->nspi);\n\t\tkfree(pf->eth_tbl);\n\t\tdev_err(&pdev->dev, \"Failed to load FW\\n\");\n\t\tgoto exit_close_nsp;\n\t}\n\n\tpf->fw_loaded = !!err;\n\terr = 0;\n\nexit_close_nsp:\n\tnfp_nsp_close(nsp);\n\n\treturn err;\n}\n\nstatic void nfp_fw_unload(struct nfp_pf *pf)\n{\n\tstruct nfp_nsp *nsp;\n\tint err;\n\n\tnsp = nfp_nsp_open(pf->cpp);\n\tif (IS_ERR(nsp)) {\n\t\tnfp_err(pf->cpp, \"Reset failed, can't open NSP\\n\");\n\t\treturn;\n\t}\n\n\terr = nfp_nsp_device_soft_reset(nsp);\n\tif (err < 0)\n\t\tdev_warn(&pf->pdev->dev, \"Couldn't unload firmware: %d\\n\", err);\n\telse\n\t\tdev_info(&pf->pdev->dev, \"Firmware safely unloaded\\n\");\n\n\tnfp_nsp_close(nsp);\n}\n\nstatic int nfp_pf_find_rtsyms(struct nfp_pf *pf)\n{\n\tchar pf_symbol[256];\n\tunsigned int pf_id;\n\n\tpf_id = nfp_cppcore_pcie_unit(pf->cpp);\n\n\t \n\tsnprintf(pf_symbol, sizeof(pf_symbol), NFP_MBOX_SYM_NAME, pf_id);\n\tpf->mbox = nfp_rtsym_lookup(pf->rtbl, pf_symbol);\n\tif (pf->mbox && nfp_rtsym_size(pf->mbox) < NFP_MBOX_SYM_MIN_SIZE) {\n\t\tnfp_err(pf->cpp, \"PF mailbox symbol too small: %llu < %d\\n\",\n\t\t\tnfp_rtsym_size(pf->mbox), NFP_MBOX_SYM_MIN_SIZE);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nint nfp_net_pf_get_app_id(struct nfp_pf *pf)\n{\n\treturn nfp_pf_rtsym_read_optional(pf, \"_pf%u_net_app_id\",\n\t\t\t\t\t  NFP_APP_CORE_NIC);\n}\n\nstatic u64 nfp_net_pf_get_app_cap(struct nfp_pf *pf)\n{\n\tchar name[32];\n\tint err = 0;\n\tu64 val;\n\n\tsnprintf(name, sizeof(name), \"_pf%u_net_app_cap\", nfp_cppcore_pcie_unit(pf->cpp));\n\n\tval = nfp_rtsym_read_le(pf->rtbl, name, &err);\n\tif (err) {\n\t\tif (err != -ENOENT)\n\t\t\tnfp_err(pf->cpp, \"Unable to read symbol %s\\n\", name);\n\n\t\treturn 0;\n\t}\n\n\treturn val;\n}\n\nstatic void nfp_pf_cfg_hwinfo(struct nfp_pf *pf)\n{\n\tstruct nfp_nsp *nsp;\n\tchar hwinfo[32];\n\tbool sp_indiff;\n\tint err;\n\n\tnsp = nfp_nsp_open(pf->cpp);\n\tif (IS_ERR(nsp))\n\t\treturn;\n\n\tif (!nfp_nsp_has_hwinfo_set(nsp))\n\t\tgoto end;\n\n\tsp_indiff = (nfp_net_pf_get_app_id(pf) == NFP_APP_FLOWER_NIC) ||\n\t\t    (nfp_net_pf_get_app_cap(pf) & NFP_NET_APP_CAP_SP_INDIFF);\n\n\t \n\tsnprintf(hwinfo, sizeof(hwinfo), \"sp_indiff=%d\", sp_indiff);\n\terr = nfp_nsp_hwinfo_set(nsp, hwinfo, sizeof(hwinfo));\n\t \n\tif (err) {\n\t\tnfp_warn(pf->cpp, \"HWinfo(sp_indiff=%d) set failed: %d\\n\", sp_indiff, err);\n\t} else {\n\t\t \n\t\tkfree(pf->eth_tbl);\n\t\tpf->eth_tbl = __nfp_eth_read_ports(pf->cpp, nsp);\n\t}\n\nend:\n\tnfp_nsp_close(nsp);\n}\n\nstatic int nfp_pci_probe(struct pci_dev *pdev,\n\t\t\t const struct pci_device_id *pci_id)\n{\n\tconst struct nfp_dev_info *dev_info;\n\tstruct devlink *devlink;\n\tstruct nfp_pf *pf;\n\tint err;\n\n\tif ((pdev->vendor == PCI_VENDOR_ID_NETRONOME ||\n\t     pdev->vendor == PCI_VENDOR_ID_CORIGINE) &&\n\t    (pdev->device == PCI_DEVICE_ID_NFP3800_VF ||\n\t     pdev->device == PCI_DEVICE_ID_NFP6000_VF))\n\t\tdev_warn(&pdev->dev, \"Binding NFP VF device to the NFP PF driver, the VF driver is called 'nfp_netvf'\\n\");\n\n\tdev_info = &nfp_dev_info[pci_id->driver_data];\n\n\terr = pci_enable_device(pdev);\n\tif (err < 0)\n\t\treturn err;\n\n\tpci_set_master(pdev);\n\n\terr = dma_set_mask_and_coherent(&pdev->dev, dev_info->dma_mask);\n\tif (err)\n\t\tgoto err_pci_disable;\n\n\terr = pci_request_regions(pdev, nfp_driver_name);\n\tif (err < 0) {\n\t\tdev_err(&pdev->dev, \"Unable to reserve pci resources.\\n\");\n\t\tgoto err_pci_disable;\n\t}\n\n\tdevlink = devlink_alloc(&nfp_devlink_ops, sizeof(*pf), &pdev->dev);\n\tif (!devlink) {\n\t\terr = -ENOMEM;\n\t\tgoto err_rel_regions;\n\t}\n\tpf = devlink_priv(devlink);\n\tINIT_LIST_HEAD(&pf->vnics);\n\tINIT_LIST_HEAD(&pf->ports);\n\tpci_set_drvdata(pdev, pf);\n\tpf->pdev = pdev;\n\tpf->dev_info = dev_info;\n\n\tpf->wq = alloc_workqueue(\"nfp-%s\", 0, 2, pci_name(pdev));\n\tif (!pf->wq) {\n\t\terr = -ENOMEM;\n\t\tgoto err_pci_priv_unset;\n\t}\n\n\tpf->cpp = nfp_cpp_from_nfp6000_pcie(pdev, dev_info);\n\tif (IS_ERR(pf->cpp)) {\n\t\terr = PTR_ERR(pf->cpp);\n\t\tgoto err_disable_msix;\n\t}\n\n\terr = nfp_resource_table_init(pf->cpp);\n\tif (err)\n\t\tgoto err_cpp_free;\n\n\tpf->hwinfo = nfp_hwinfo_read(pf->cpp);\n\n\tdev_info(&pdev->dev, \"Assembly: %s%s%s-%s CPLD: %s\\n\",\n\t\t nfp_hwinfo_lookup(pf->hwinfo, \"assembly.vendor\"),\n\t\t nfp_hwinfo_lookup(pf->hwinfo, \"assembly.partno\"),\n\t\t nfp_hwinfo_lookup(pf->hwinfo, \"assembly.serial\"),\n\t\t nfp_hwinfo_lookup(pf->hwinfo, \"assembly.revision\"),\n\t\t nfp_hwinfo_lookup(pf->hwinfo, \"cpld.version\"));\n\n\terr = nfp_pf_board_state_wait(pf);\n\tif (err)\n\t\tgoto err_hwinfo_free;\n\n\terr = nfp_nsp_init(pdev, pf);\n\tif (err)\n\t\tgoto err_hwinfo_free;\n\n\tpf->mip = nfp_mip_open(pf->cpp);\n\tpf->rtbl = __nfp_rtsym_table_read(pf->cpp, pf->mip);\n\n\terr = nfp_pf_find_rtsyms(pf);\n\tif (err)\n\t\tgoto err_fw_unload;\n\n\tpf->dump_flag = NFP_DUMP_NSP_DIAG;\n\tpf->dumpspec = nfp_net_dump_load_dumpspec(pf->cpp, pf->rtbl);\n\n\terr = nfp_pcie_sriov_read_nfd_limit(pf);\n\tif (err)\n\t\tgoto err_fw_unload;\n\n\tpf->num_vfs = pci_num_vf(pdev);\n\tif (pf->num_vfs > pf->limit_vfs) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Error: %d VFs already enabled, but loaded FW can only support %d\\n\",\n\t\t\tpf->num_vfs, pf->limit_vfs);\n\t\terr = -EINVAL;\n\t\tgoto err_fw_unload;\n\t}\n\n\tnfp_pf_cfg_hwinfo(pf);\n\n\terr = nfp_net_pci_probe(pf);\n\tif (err)\n\t\tgoto err_fw_unload;\n\n\terr = nfp_hwmon_register(pf);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Failed to register hwmon info\\n\");\n\t\tgoto err_net_remove;\n\t}\n\n\treturn 0;\n\nerr_net_remove:\n\tnfp_net_pci_remove(pf);\nerr_fw_unload:\n\tkfree(pf->rtbl);\n\tnfp_mip_close(pf->mip);\n\tif (pf->unload_fw_on_remove)\n\t\tnfp_fw_unload(pf);\n\tkfree(pf->eth_tbl);\n\tkfree(pf->nspi);\n\tvfree(pf->dumpspec);\nerr_hwinfo_free:\n\tkfree(pf->hwinfo);\nerr_cpp_free:\n\tnfp_cpp_free(pf->cpp);\nerr_disable_msix:\n\tdestroy_workqueue(pf->wq);\nerr_pci_priv_unset:\n\tpci_set_drvdata(pdev, NULL);\n\tdevlink_free(devlink);\nerr_rel_regions:\n\tpci_release_regions(pdev);\nerr_pci_disable:\n\tpci_disable_device(pdev);\n\n\treturn err;\n}\n\nstatic void __nfp_pci_shutdown(struct pci_dev *pdev, bool unload_fw)\n{\n\tstruct nfp_pf *pf;\n\n\tpf = pci_get_drvdata(pdev);\n\tif (!pf)\n\t\treturn;\n\n\tnfp_hwmon_unregister(pf);\n\n\tnfp_pcie_sriov_disable(pdev);\n\n\tnfp_net_pci_remove(pf);\n\n\tvfree(pf->dumpspec);\n\tkfree(pf->rtbl);\n\tnfp_mip_close(pf->mip);\n\tif (unload_fw && pf->unload_fw_on_remove)\n\t\tnfp_fw_unload(pf);\n\n\tdestroy_workqueue(pf->wq);\n\tpci_set_drvdata(pdev, NULL);\n\tkfree(pf->hwinfo);\n\tnfp_cpp_free(pf->cpp);\n\n\tkfree(pf->eth_tbl);\n\tkfree(pf->nspi);\n\tdevlink_free(priv_to_devlink(pf));\n\tpci_release_regions(pdev);\n\tpci_disable_device(pdev);\n}\n\nstatic void nfp_pci_remove(struct pci_dev *pdev)\n{\n\t__nfp_pci_shutdown(pdev, true);\n}\n\nstatic void nfp_pci_shutdown(struct pci_dev *pdev)\n{\n\t__nfp_pci_shutdown(pdev, false);\n}\n\nstatic struct pci_driver nfp_pci_driver = {\n\t.name\t\t\t= nfp_driver_name,\n\t.id_table\t\t= nfp_pci_device_ids,\n\t.probe\t\t\t= nfp_pci_probe,\n\t.remove\t\t\t= nfp_pci_remove,\n\t.shutdown\t\t= nfp_pci_shutdown,\n\t.sriov_configure\t= nfp_pcie_sriov_configure,\n};\n\nstatic int __init nfp_main_init(void)\n{\n\tint err;\n\n\tpr_info(\"%s: NFP PCIe Driver, Copyright (C) 2014-2020 Netronome Systems\\n\",\n\t\tnfp_driver_name);\n\tpr_info(\"%s: NFP PCIe Driver, Copyright (C) 2021-2022 Corigine Inc.\\n\",\n\t\tnfp_driver_name);\n\n\tnfp_net_debugfs_create();\n\n\terr = pci_register_driver(&nfp_pci_driver);\n\tif (err < 0)\n\t\tgoto err_destroy_debugfs;\n\n\terr = pci_register_driver(&nfp_netvf_pci_driver);\n\tif (err)\n\t\tgoto err_unreg_pf;\n\n\treturn err;\n\nerr_unreg_pf:\n\tpci_unregister_driver(&nfp_pci_driver);\nerr_destroy_debugfs:\n\tnfp_net_debugfs_destroy();\n\treturn err;\n}\n\nstatic void __exit nfp_main_exit(void)\n{\n\tpci_unregister_driver(&nfp_netvf_pci_driver);\n\tpci_unregister_driver(&nfp_pci_driver);\n\tnfp_net_debugfs_destroy();\n}\n\nmodule_init(nfp_main_init);\nmodule_exit(nfp_main_exit);\n\nMODULE_FIRMWARE(\"netronome/nic_AMDA0058-0011_2x40.nffw\");\nMODULE_FIRMWARE(\"netronome/nic_AMDA0058-0012_2x40.nffw\");\nMODULE_FIRMWARE(\"netronome/nic_AMDA0081-0001_1x40.nffw\");\nMODULE_FIRMWARE(\"netronome/nic_AMDA0081-0001_4x10.nffw\");\nMODULE_FIRMWARE(\"netronome/nic_AMDA0096-0001_2x10.nffw\");\nMODULE_FIRMWARE(\"netronome/nic_AMDA0097-0001_2x40.nffw\");\nMODULE_FIRMWARE(\"netronome/nic_AMDA0097-0001_4x10_1x40.nffw\");\nMODULE_FIRMWARE(\"netronome/nic_AMDA0097-0001_8x10.nffw\");\nMODULE_FIRMWARE(\"netronome/nic_AMDA0099-0001_2x10.nffw\");\nMODULE_FIRMWARE(\"netronome/nic_AMDA0099-0001_2x25.nffw\");\nMODULE_FIRMWARE(\"netronome/nic_AMDA0099-0001_1x10_1x25.nffw\");\n\nMODULE_AUTHOR(\"Corigine, Inc. <oss-drivers@corigine.com>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"The Network Flow Processor (NFP) driver.\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}