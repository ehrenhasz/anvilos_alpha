{
  "module_name": "ccm_mbox.c",
  "hash_id": "c4697eaf63cac0b2974aac712406cdea5cb1dc44210cb60875582fc0361bebec",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/netronome/nfp/ccm_mbox.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/io.h>\n#include <linux/skbuff.h>\n\n#include \"ccm.h\"\n#include \"nfp_net.h\"\n\n \n\n#define NFP_CCM_MBOX_BATCH_LIMIT\t64\n#define NFP_CCM_TIMEOUT\t\t\t(NFP_NET_POLL_TIMEOUT * 1000)\n#define NFP_CCM_MAX_QLEN\t\t1024\n\nenum nfp_net_mbox_cmsg_state {\n\tNFP_NET_MBOX_CMSG_STATE_QUEUED,\n\tNFP_NET_MBOX_CMSG_STATE_NEXT,\n\tNFP_NET_MBOX_CMSG_STATE_BUSY,\n\tNFP_NET_MBOX_CMSG_STATE_REPLY_FOUND,\n\tNFP_NET_MBOX_CMSG_STATE_DONE,\n};\n\n \nstruct nfp_ccm_mbox_cmsg_cb {\n\tenum nfp_net_mbox_cmsg_state state;\n\tint err;\n\tunsigned int max_len;\n\tunsigned int exp_reply;\n\tbool posted;\n};\n\nstatic u32 nfp_ccm_mbox_max_msg(struct nfp_net *nn)\n{\n\treturn round_down(nn->tlv_caps.mbox_len, 4) -\n\t\tNFP_NET_CFG_MBOX_SIMPLE_VAL -  \n\t\t4 * 2;  \n}\n\nstatic void\nnfp_ccm_mbox_msg_init(struct sk_buff *skb, unsigned int exp_reply, int max_len)\n{\n\tstruct nfp_ccm_mbox_cmsg_cb *cb = (void *)skb->cb;\n\n\tcb->state = NFP_NET_MBOX_CMSG_STATE_QUEUED;\n\tcb->err = 0;\n\tcb->max_len = max_len;\n\tcb->exp_reply = exp_reply;\n\tcb->posted = false;\n}\n\nstatic int nfp_ccm_mbox_maxlen(const struct sk_buff *skb)\n{\n\tstruct nfp_ccm_mbox_cmsg_cb *cb = (void *)skb->cb;\n\n\treturn cb->max_len;\n}\n\nstatic bool nfp_ccm_mbox_done(struct sk_buff *skb)\n{\n\tstruct nfp_ccm_mbox_cmsg_cb *cb = (void *)skb->cb;\n\n\treturn cb->state == NFP_NET_MBOX_CMSG_STATE_DONE;\n}\n\nstatic bool nfp_ccm_mbox_in_progress(struct sk_buff *skb)\n{\n\tstruct nfp_ccm_mbox_cmsg_cb *cb = (void *)skb->cb;\n\n\treturn cb->state != NFP_NET_MBOX_CMSG_STATE_QUEUED &&\n\t       cb->state != NFP_NET_MBOX_CMSG_STATE_NEXT;\n}\n\nstatic void nfp_ccm_mbox_set_busy(struct sk_buff *skb)\n{\n\tstruct nfp_ccm_mbox_cmsg_cb *cb = (void *)skb->cb;\n\n\tcb->state = NFP_NET_MBOX_CMSG_STATE_BUSY;\n}\n\nstatic bool nfp_ccm_mbox_is_posted(struct sk_buff *skb)\n{\n\tstruct nfp_ccm_mbox_cmsg_cb *cb = (void *)skb->cb;\n\n\treturn cb->posted;\n}\n\nstatic void nfp_ccm_mbox_mark_posted(struct sk_buff *skb)\n{\n\tstruct nfp_ccm_mbox_cmsg_cb *cb = (void *)skb->cb;\n\n\tcb->posted = true;\n}\n\nstatic bool nfp_ccm_mbox_is_first(struct nfp_net *nn, struct sk_buff *skb)\n{\n\treturn skb_queue_is_first(&nn->mbox_cmsg.queue, skb);\n}\n\nstatic bool nfp_ccm_mbox_should_run(struct nfp_net *nn, struct sk_buff *skb)\n{\n\tstruct nfp_ccm_mbox_cmsg_cb *cb = (void *)skb->cb;\n\n\treturn cb->state == NFP_NET_MBOX_CMSG_STATE_NEXT;\n}\n\nstatic void nfp_ccm_mbox_mark_next_runner(struct nfp_net *nn)\n{\n\tstruct nfp_ccm_mbox_cmsg_cb *cb;\n\tstruct sk_buff *skb;\n\n\tskb = skb_peek(&nn->mbox_cmsg.queue);\n\tif (!skb)\n\t\treturn;\n\n\tcb = (void *)skb->cb;\n\tcb->state = NFP_NET_MBOX_CMSG_STATE_NEXT;\n\tif (cb->posted)\n\t\tqueue_work(nn->mbox_cmsg.workq, &nn->mbox_cmsg.runq_work);\n}\n\nstatic void\nnfp_ccm_mbox_write_tlv(struct nfp_net *nn, u32 off, u32 type, u32 len)\n{\n\tnn_writel(nn, off,\n\t\t  FIELD_PREP(NFP_NET_MBOX_TLV_TYPE, type) |\n\t\t  FIELD_PREP(NFP_NET_MBOX_TLV_LEN, len));\n}\n\nstatic void nfp_ccm_mbox_copy_in(struct nfp_net *nn, struct sk_buff *last)\n{\n\tstruct sk_buff *skb;\n\tint reserve, i, cnt;\n\t__be32 *data;\n\tu32 off, len;\n\n\toff = nn->tlv_caps.mbox_off + NFP_NET_CFG_MBOX_SIMPLE_VAL;\n\tskb = __skb_peek(&nn->mbox_cmsg.queue);\n\twhile (true) {\n\t\tnfp_ccm_mbox_write_tlv(nn, off, NFP_NET_MBOX_TLV_TYPE_MSG,\n\t\t\t\t       skb->len);\n\t\toff += 4;\n\n\t\t \n\t\tdata = (__be32 *)skb->data;\n\t\tcnt = skb->len / 4;\n\t\tfor (i = 0 ; i < cnt; i++) {\n\t\t\tnn_writel(nn, off, be32_to_cpu(data[i]));\n\t\t\toff += 4;\n\t\t}\n\t\tif (skb->len & 3) {\n\t\t\t__be32 tmp = 0;\n\n\t\t\tmemcpy(&tmp, &data[i], skb->len & 3);\n\t\t\tnn_writel(nn, off, be32_to_cpu(tmp));\n\t\t\toff += 4;\n\t\t}\n\n\t\t \n\t\tlen = round_up(skb->len, 4);\n\t\treserve = nfp_ccm_mbox_maxlen(skb) - len;\n\t\tif (reserve > 0) {\n\t\t\tnfp_ccm_mbox_write_tlv(nn, off,\n\t\t\t\t\t       NFP_NET_MBOX_TLV_TYPE_RESV,\n\t\t\t\t\t       reserve);\n\t\t\toff += 4 + reserve;\n\t\t}\n\n\t\tif (skb == last)\n\t\t\tbreak;\n\t\tskb = skb_queue_next(&nn->mbox_cmsg.queue, skb);\n\t}\n\n\tnfp_ccm_mbox_write_tlv(nn, off, NFP_NET_MBOX_TLV_TYPE_END, 0);\n}\n\nstatic struct sk_buff *\nnfp_ccm_mbox_find_req(struct nfp_net *nn, __be16 tag, struct sk_buff *last)\n{\n\tstruct sk_buff *skb;\n\n\tskb = __skb_peek(&nn->mbox_cmsg.queue);\n\twhile (true) {\n\t\tif (__nfp_ccm_get_tag(skb) == tag)\n\t\t\treturn skb;\n\n\t\tif (skb == last)\n\t\t\treturn NULL;\n\t\tskb = skb_queue_next(&nn->mbox_cmsg.queue, skb);\n\t}\n}\n\nstatic void nfp_ccm_mbox_copy_out(struct nfp_net *nn, struct sk_buff *last)\n{\n\tstruct nfp_ccm_mbox_cmsg_cb *cb;\n\tu8 __iomem *data, *end;\n\tstruct sk_buff *skb;\n\n\tdata = nn->dp.ctrl_bar + nn->tlv_caps.mbox_off +\n\t\tNFP_NET_CFG_MBOX_SIMPLE_VAL;\n\tend = data + nn->tlv_caps.mbox_len;\n\n\twhile (true) {\n\t\tunsigned int length, offset, type;\n\t\tstruct nfp_ccm_hdr hdr;\n\t\tu32 tlv_hdr;\n\n\t\ttlv_hdr = readl(data);\n\t\ttype = FIELD_GET(NFP_NET_MBOX_TLV_TYPE, tlv_hdr);\n\t\tlength = FIELD_GET(NFP_NET_MBOX_TLV_LEN, tlv_hdr);\n\t\toffset = data - nn->dp.ctrl_bar;\n\n\t\t \n\t\tdata += 4;\n\n\t\tif (data + length > end) {\n\t\t\tnn_dp_warn(&nn->dp, \"mailbox oversized TLV type:%d offset:%u len:%u\\n\",\n\t\t\t\t   type, offset, length);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (type == NFP_NET_MBOX_TLV_TYPE_END)\n\t\t\tbreak;\n\t\tif (type == NFP_NET_MBOX_TLV_TYPE_RESV)\n\t\t\tgoto next_tlv;\n\t\tif (type != NFP_NET_MBOX_TLV_TYPE_MSG &&\n\t\t    type != NFP_NET_MBOX_TLV_TYPE_MSG_NOSUP) {\n\t\t\tnn_dp_warn(&nn->dp, \"mailbox unknown TLV type:%d offset:%u len:%u\\n\",\n\t\t\t\t   type, offset, length);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (length < 4) {\n\t\t\tnn_dp_warn(&nn->dp, \"mailbox msg too short to contain header TLV type:%d offset:%u len:%u\\n\",\n\t\t\t\t   type, offset, length);\n\t\t\tbreak;\n\t\t}\n\n\t\thdr.raw = cpu_to_be32(readl(data));\n\n\t\tskb = nfp_ccm_mbox_find_req(nn, hdr.tag, last);\n\t\tif (!skb) {\n\t\t\tnn_dp_warn(&nn->dp, \"mailbox request not found:%u\\n\",\n\t\t\t\t   be16_to_cpu(hdr.tag));\n\t\t\tbreak;\n\t\t}\n\t\tcb = (void *)skb->cb;\n\n\t\tif (type == NFP_NET_MBOX_TLV_TYPE_MSG_NOSUP) {\n\t\t\tnn_dp_warn(&nn->dp,\n\t\t\t\t   \"mailbox msg not supported type:%d\\n\",\n\t\t\t\t   nfp_ccm_get_type(skb));\n\t\t\tcb->err = -EIO;\n\t\t\tgoto next_tlv;\n\t\t}\n\n\t\tif (hdr.type != __NFP_CCM_REPLY(nfp_ccm_get_type(skb))) {\n\t\t\tnn_dp_warn(&nn->dp, \"mailbox msg reply wrong type:%u expected:%lu\\n\",\n\t\t\t\t   hdr.type,\n\t\t\t\t   __NFP_CCM_REPLY(nfp_ccm_get_type(skb)));\n\t\t\tcb->err = -EIO;\n\t\t\tgoto next_tlv;\n\t\t}\n\t\tif (cb->exp_reply && length != cb->exp_reply) {\n\t\t\tnn_dp_warn(&nn->dp, \"mailbox msg reply wrong size type:%u expected:%u have:%u\\n\",\n\t\t\t\t   hdr.type, length, cb->exp_reply);\n\t\t\tcb->err = -EIO;\n\t\t\tgoto next_tlv;\n\t\t}\n\t\tif (length > cb->max_len) {\n\t\t\tnn_dp_warn(&nn->dp, \"mailbox msg oversized reply type:%u max:%u have:%u\\n\",\n\t\t\t\t   hdr.type, cb->max_len, length);\n\t\t\tcb->err = -EIO;\n\t\t\tgoto next_tlv;\n\t\t}\n\n\t\tif (!cb->posted) {\n\t\t\t__be32 *skb_data;\n\t\t\tint i, cnt;\n\n\t\t\tif (length <= skb->len)\n\t\t\t\t__skb_trim(skb, length);\n\t\t\telse\n\t\t\t\tskb_put(skb, length - skb->len);\n\n\t\t\t \n\t\t\tskb_data = (__be32 *)skb->data;\n\t\t\tmemcpy(skb_data, &hdr, 4);\n\n\t\t\tcnt = DIV_ROUND_UP(length, 4);\n\t\t\tfor (i = 1 ; i < cnt; i++)\n\t\t\t\tskb_data[i] = cpu_to_be32(readl(data + i * 4));\n\t\t}\n\n\t\tcb->state = NFP_NET_MBOX_CMSG_STATE_REPLY_FOUND;\nnext_tlv:\n\t\tdata += round_up(length, 4);\n\t\tif (data + 4 > end) {\n\t\t\tnn_dp_warn(&nn->dp,\n\t\t\t\t   \"reached end of MBOX without END TLV\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tsmp_wmb();  \n\tspin_lock_bh(&nn->mbox_cmsg.queue.lock);\n\tdo {\n\t\tskb = __skb_dequeue(&nn->mbox_cmsg.queue);\n\t\tcb = (void *)skb->cb;\n\n\t\tif (cb->state != NFP_NET_MBOX_CMSG_STATE_REPLY_FOUND) {\n\t\t\tcb->err = -ENOENT;\n\t\t\tsmp_wmb();  \n\t\t}\n\t\tcb->state = NFP_NET_MBOX_CMSG_STATE_DONE;\n\n\t\tif (cb->posted) {\n\t\t\tif (cb->err)\n\t\t\t\tnn_dp_warn(&nn->dp,\n\t\t\t\t\t   \"mailbox posted msg failed type:%u err:%d\\n\",\n\t\t\t\t\t   nfp_ccm_get_type(skb), cb->err);\n\t\t\tdev_consume_skb_any(skb);\n\t\t}\n\t} while (skb != last);\n\n\tnfp_ccm_mbox_mark_next_runner(nn);\n\tspin_unlock_bh(&nn->mbox_cmsg.queue.lock);\n}\n\nstatic void\nnfp_ccm_mbox_mark_all_err(struct nfp_net *nn, struct sk_buff *last, int err)\n{\n\tstruct nfp_ccm_mbox_cmsg_cb *cb;\n\tstruct sk_buff *skb;\n\n\tspin_lock_bh(&nn->mbox_cmsg.queue.lock);\n\tdo {\n\t\tskb = __skb_dequeue(&nn->mbox_cmsg.queue);\n\t\tcb = (void *)skb->cb;\n\n\t\tcb->err = err;\n\t\tsmp_wmb();  \n\t\tcb->state = NFP_NET_MBOX_CMSG_STATE_DONE;\n\t} while (skb != last);\n\n\tnfp_ccm_mbox_mark_next_runner(nn);\n\tspin_unlock_bh(&nn->mbox_cmsg.queue.lock);\n}\n\nstatic void nfp_ccm_mbox_run_queue_unlock(struct nfp_net *nn)\n\t__releases(&nn->mbox_cmsg.queue.lock)\n{\n\tint space = nn->tlv_caps.mbox_len - NFP_NET_CFG_MBOX_SIMPLE_VAL;\n\tstruct sk_buff *skb, *last;\n\tint cnt, err;\n\n\tspace -= 4;  \n\n\t \n\tcnt = 1;\n\tlast = skb = __skb_peek(&nn->mbox_cmsg.queue);\n\tspace -= 4 + nfp_ccm_mbox_maxlen(skb);\n\n\twhile (!skb_queue_is_last(&nn->mbox_cmsg.queue, last)) {\n\t\tskb = skb_queue_next(&nn->mbox_cmsg.queue, last);\n\t\tspace -= 4 + nfp_ccm_mbox_maxlen(skb);\n\t\tif (space < 0)\n\t\t\tbreak;\n\t\tlast = skb;\n\t\tnfp_ccm_mbox_set_busy(skb);\n\t\tcnt++;\n\t\tif (cnt == NFP_CCM_MBOX_BATCH_LIMIT)\n\t\t\tbreak;\n\t}\n\tspin_unlock_bh(&nn->mbox_cmsg.queue.lock);\n\n\t \n\n\tnn_ctrl_bar_lock(nn);\n\n\tnfp_ccm_mbox_copy_in(nn, last);\n\n\terr = nfp_net_mbox_reconfig(nn, NFP_NET_CFG_MBOX_CMD_TLV_CMSG);\n\tif (!err)\n\t\tnfp_ccm_mbox_copy_out(nn, last);\n\telse\n\t\tnfp_ccm_mbox_mark_all_err(nn, last, -EIO);\n\n\tnn_ctrl_bar_unlock(nn);\n\n\twake_up_all(&nn->mbox_cmsg.wq);\n}\n\nstatic int nfp_ccm_mbox_skb_return(struct sk_buff *skb)\n{\n\tstruct nfp_ccm_mbox_cmsg_cb *cb = (void *)skb->cb;\n\n\tif (cb->err)\n\t\tdev_kfree_skb_any(skb);\n\treturn cb->err;\n}\n\n \nstatic int\nnfp_ccm_mbox_unlink_unlock(struct nfp_net *nn, struct sk_buff *skb,\n\t\t\t   enum nfp_ccm_type type)\n\t__releases(&nn->mbox_cmsg.queue.lock)\n{\n\tbool was_first;\n\n\tif (nfp_ccm_mbox_in_progress(skb)) {\n\t\tspin_unlock_bh(&nn->mbox_cmsg.queue.lock);\n\n\t\twait_event(nn->mbox_cmsg.wq, nfp_ccm_mbox_done(skb));\n\t\tsmp_rmb();  \n\t\treturn nfp_ccm_mbox_skb_return(skb);\n\t}\n\n\twas_first = nfp_ccm_mbox_should_run(nn, skb);\n\t__skb_unlink(skb, &nn->mbox_cmsg.queue);\n\tif (was_first)\n\t\tnfp_ccm_mbox_mark_next_runner(nn);\n\n\tspin_unlock_bh(&nn->mbox_cmsg.queue.lock);\n\n\tif (was_first)\n\t\twake_up_all(&nn->mbox_cmsg.wq);\n\n\tnn_dp_warn(&nn->dp, \"time out waiting for mbox response to 0x%02x\\n\",\n\t\t   type);\n\treturn -ETIMEDOUT;\n}\n\nstatic int\nnfp_ccm_mbox_msg_prepare(struct nfp_net *nn, struct sk_buff *skb,\n\t\t\t enum nfp_ccm_type type,\n\t\t\t unsigned int reply_size, unsigned int max_reply_size,\n\t\t\t gfp_t flags)\n{\n\tconst unsigned int mbox_max = nfp_ccm_mbox_max_msg(nn);\n\tunsigned int max_len;\n\tssize_t undersize;\n\tint err;\n\n\tif (unlikely(!(nn->tlv_caps.mbox_cmsg_types & BIT(type)))) {\n\t\tnn_dp_warn(&nn->dp,\n\t\t\t   \"message type %d not supported by mailbox\\n\", type);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (!max_reply_size)\n\t\tmax_reply_size = mbox_max;\n\tmax_reply_size = round_up(max_reply_size, 4);\n\n\t \n\tundersize = max_reply_size - (skb_end_pointer(skb) - skb->data);\n\tif (undersize > 0) {\n\t\terr = pskb_expand_head(skb, 0, undersize, flags);\n\t\tif (err) {\n\t\t\tnn_dp_warn(&nn->dp,\n\t\t\t\t   \"can't allocate reply buffer for mailbox\\n\");\n\t\t\treturn err;\n\t\t}\n\t}\n\n\t \n\tmax_len = max(max_reply_size, round_up(skb->len, 4));\n\tif (max_len > mbox_max) {\n\t\tnn_dp_warn(&nn->dp,\n\t\t\t   \"message too big for the mailbox: %u/%u vs %u\\n\",\n\t\t\t   skb->len, max_reply_size, mbox_max);\n\t\treturn -EMSGSIZE;\n\t}\n\n\tnfp_ccm_mbox_msg_init(skb, reply_size, max_len);\n\n\treturn 0;\n}\n\nstatic int\nnfp_ccm_mbox_msg_enqueue(struct nfp_net *nn, struct sk_buff *skb,\n\t\t\t enum nfp_ccm_type type, bool critical)\n{\n\tstruct nfp_ccm_hdr *hdr;\n\n\tassert_spin_locked(&nn->mbox_cmsg.queue.lock);\n\n\tif (!critical && nn->mbox_cmsg.queue.qlen >= NFP_CCM_MAX_QLEN) {\n\t\tnn_dp_warn(&nn->dp, \"mailbox request queue too long\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\thdr = (void *)skb->data;\n\thdr->ver = NFP_CCM_ABI_VERSION;\n\thdr->type = type;\n\thdr->tag = cpu_to_be16(nn->mbox_cmsg.tag++);\n\n\t__skb_queue_tail(&nn->mbox_cmsg.queue, skb);\n\n\treturn 0;\n}\n\nint __nfp_ccm_mbox_communicate(struct nfp_net *nn, struct sk_buff *skb,\n\t\t\t       enum nfp_ccm_type type,\n\t\t\t       unsigned int reply_size,\n\t\t\t       unsigned int max_reply_size, bool critical)\n{\n\tint err;\n\n\terr = nfp_ccm_mbox_msg_prepare(nn, skb, type, reply_size,\n\t\t\t\t       max_reply_size, GFP_KERNEL);\n\tif (err)\n\t\tgoto err_free_skb;\n\n\tspin_lock_bh(&nn->mbox_cmsg.queue.lock);\n\n\terr = nfp_ccm_mbox_msg_enqueue(nn, skb, type, critical);\n\tif (err)\n\t\tgoto err_unlock;\n\n\t \n\tif (!nfp_ccm_mbox_is_first(nn, skb)) {\n\t\tbool to;\n\n\t\tspin_unlock_bh(&nn->mbox_cmsg.queue.lock);\n\n\t\tto = !wait_event_timeout(nn->mbox_cmsg.wq,\n\t\t\t\t\t nfp_ccm_mbox_done(skb) ||\n\t\t\t\t\t nfp_ccm_mbox_should_run(nn, skb),\n\t\t\t\t\t msecs_to_jiffies(NFP_CCM_TIMEOUT));\n\n\t\t \n\t\tif (nfp_ccm_mbox_done(skb)) {\n\t\t\tsmp_rmb();  \n\t\t\treturn nfp_ccm_mbox_skb_return(skb);\n\t\t}\n\n\t\tspin_lock_bh(&nn->mbox_cmsg.queue.lock);\n\n\t\tif (!nfp_ccm_mbox_is_first(nn, skb)) {\n\t\t\tWARN_ON(!to);\n\n\t\t\terr = nfp_ccm_mbox_unlink_unlock(nn, skb, type);\n\t\t\tif (err)\n\t\t\t\tgoto err_free_skb;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t \n\tnfp_ccm_mbox_run_queue_unlock(nn);\n\treturn nfp_ccm_mbox_skb_return(skb);\n\nerr_unlock:\n\tspin_unlock_bh(&nn->mbox_cmsg.queue.lock);\nerr_free_skb:\n\tdev_kfree_skb_any(skb);\n\treturn err;\n}\n\nint nfp_ccm_mbox_communicate(struct nfp_net *nn, struct sk_buff *skb,\n\t\t\t     enum nfp_ccm_type type,\n\t\t\t     unsigned int reply_size,\n\t\t\t     unsigned int max_reply_size)\n{\n\treturn __nfp_ccm_mbox_communicate(nn, skb, type, reply_size,\n\t\t\t\t\t  max_reply_size, false);\n}\n\nstatic void nfp_ccm_mbox_post_runq_work(struct work_struct *work)\n{\n\tstruct sk_buff *skb;\n\tstruct nfp_net *nn;\n\n\tnn = container_of(work, struct nfp_net, mbox_cmsg.runq_work);\n\n\tspin_lock_bh(&nn->mbox_cmsg.queue.lock);\n\n\tskb = __skb_peek(&nn->mbox_cmsg.queue);\n\tif (WARN_ON(!skb || !nfp_ccm_mbox_is_posted(skb) ||\n\t\t    !nfp_ccm_mbox_should_run(nn, skb))) {\n\t\tspin_unlock_bh(&nn->mbox_cmsg.queue.lock);\n\t\treturn;\n\t}\n\n\tnfp_ccm_mbox_run_queue_unlock(nn);\n}\n\nstatic void nfp_ccm_mbox_post_wait_work(struct work_struct *work)\n{\n\tstruct sk_buff *skb;\n\tstruct nfp_net *nn;\n\tint err;\n\n\tnn = container_of(work, struct nfp_net, mbox_cmsg.wait_work);\n\n\tskb = skb_peek(&nn->mbox_cmsg.queue);\n\tif (WARN_ON(!skb || !nfp_ccm_mbox_is_posted(skb)))\n\t\t \n\t\tgoto exit_unlock_wake;\n\n\terr = nfp_net_mbox_reconfig_wait_posted(nn);\n\tif (!err)\n\t\tnfp_ccm_mbox_copy_out(nn, skb);\n\telse\n\t\tnfp_ccm_mbox_mark_all_err(nn, skb, -EIO);\nexit_unlock_wake:\n\tnn_ctrl_bar_unlock(nn);\n\twake_up_all(&nn->mbox_cmsg.wq);\n}\n\nint nfp_ccm_mbox_post(struct nfp_net *nn, struct sk_buff *skb,\n\t\t      enum nfp_ccm_type type, unsigned int max_reply_size)\n{\n\tint err;\n\n\terr = nfp_ccm_mbox_msg_prepare(nn, skb, type, 0, max_reply_size,\n\t\t\t\t       GFP_ATOMIC);\n\tif (err)\n\t\tgoto err_free_skb;\n\n\tnfp_ccm_mbox_mark_posted(skb);\n\n\tspin_lock_bh(&nn->mbox_cmsg.queue.lock);\n\n\terr = nfp_ccm_mbox_msg_enqueue(nn, skb, type, false);\n\tif (err)\n\t\tgoto err_unlock;\n\n\tif (nfp_ccm_mbox_is_first(nn, skb)) {\n\t\tif (nn_ctrl_bar_trylock(nn)) {\n\t\t\tnfp_ccm_mbox_copy_in(nn, skb);\n\t\t\tnfp_net_mbox_reconfig_post(nn,\n\t\t\t\t\t\t   NFP_NET_CFG_MBOX_CMD_TLV_CMSG);\n\t\t\tqueue_work(nn->mbox_cmsg.workq,\n\t\t\t\t   &nn->mbox_cmsg.wait_work);\n\t\t} else {\n\t\t\tnfp_ccm_mbox_mark_next_runner(nn);\n\t\t}\n\t}\n\n\tspin_unlock_bh(&nn->mbox_cmsg.queue.lock);\n\n\treturn 0;\n\nerr_unlock:\n\tspin_unlock_bh(&nn->mbox_cmsg.queue.lock);\nerr_free_skb:\n\tdev_kfree_skb_any(skb);\n\treturn err;\n}\n\nstruct sk_buff *\nnfp_ccm_mbox_msg_alloc(struct nfp_net *nn, unsigned int req_size,\n\t\t       unsigned int reply_size, gfp_t flags)\n{\n\tunsigned int max_size;\n\tstruct sk_buff *skb;\n\n\tif (!reply_size)\n\t\tmax_size = nfp_ccm_mbox_max_msg(nn);\n\telse\n\t\tmax_size = max(req_size, reply_size);\n\tmax_size = round_up(max_size, 4);\n\n\tskb = alloc_skb(max_size, flags);\n\tif (!skb)\n\t\treturn NULL;\n\n\tskb_put(skb, req_size);\n\n\treturn skb;\n}\n\nbool nfp_ccm_mbox_fits(struct nfp_net *nn, unsigned int size)\n{\n\treturn nfp_ccm_mbox_max_msg(nn) >= size;\n}\n\nint nfp_ccm_mbox_init(struct nfp_net *nn)\n{\n\treturn 0;\n}\n\nvoid nfp_ccm_mbox_clean(struct nfp_net *nn)\n{\n\tdrain_workqueue(nn->mbox_cmsg.workq);\n}\n\nint nfp_ccm_mbox_alloc(struct nfp_net *nn)\n{\n\tskb_queue_head_init(&nn->mbox_cmsg.queue);\n\tinit_waitqueue_head(&nn->mbox_cmsg.wq);\n\tINIT_WORK(&nn->mbox_cmsg.wait_work, nfp_ccm_mbox_post_wait_work);\n\tINIT_WORK(&nn->mbox_cmsg.runq_work, nfp_ccm_mbox_post_runq_work);\n\n\tnn->mbox_cmsg.workq = alloc_workqueue(\"nfp-ccm-mbox\", WQ_UNBOUND, 0);\n\tif (!nn->mbox_cmsg.workq)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nvoid nfp_ccm_mbox_free(struct nfp_net *nn)\n{\n\tdestroy_workqueue(nn->mbox_cmsg.workq);\n\tWARN_ON(!skb_queue_empty(&nn->mbox_cmsg.queue));\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}