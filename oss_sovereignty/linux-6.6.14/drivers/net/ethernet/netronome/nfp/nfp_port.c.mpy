{
  "module_name": "nfp_port.c",
  "hash_id": "54fd3e3f52baf9efd8f306a61e83e9f5589c3d9091199a31e4c445d4ed81759f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/netronome/nfp/nfp_port.c",
  "human_readable_source": "\n \n\n#include <linux/lockdep.h>\n#include <linux/netdevice.h>\n\n#include \"nfpcore/nfp_cpp.h\"\n#include \"nfpcore/nfp_nsp.h\"\n#include \"nfp_app.h\"\n#include \"nfp_main.h\"\n#include \"nfp_net.h\"\n#include \"nfp_port.h\"\n\nstruct nfp_port *nfp_port_from_netdev(struct net_device *netdev)\n{\n\tif (nfp_netdev_is_nfp_net(netdev)) {\n\t\tstruct nfp_net *nn = netdev_priv(netdev);\n\n\t\treturn nn->port;\n\t}\n\n\tif (nfp_netdev_is_nfp_repr(netdev)) {\n\t\tstruct nfp_repr *repr = netdev_priv(netdev);\n\n\t\treturn repr->port;\n\t}\n\n\tWARN(1, \"Unknown netdev type for nfp_port\\n\");\n\n\treturn NULL;\n}\n\nint nfp_port_get_port_parent_id(struct net_device *netdev,\n\t\t\t\tstruct netdev_phys_item_id *ppid)\n{\n\tstruct nfp_port *port;\n\tconst u8 *serial;\n\n\tport = nfp_port_from_netdev(netdev);\n\tif (!port)\n\t\treturn -EOPNOTSUPP;\n\n\tppid->id_len = nfp_cpp_serial(port->app->cpp, &serial);\n\tmemcpy(&ppid->id, serial, ppid->id_len);\n\n\treturn 0;\n}\n\nint nfp_port_setup_tc(struct net_device *netdev, enum tc_setup_type type,\n\t\t      void *type_data)\n{\n\tstruct nfp_port *port;\n\n\tport = nfp_port_from_netdev(netdev);\n\tif (!port)\n\t\treturn -EOPNOTSUPP;\n\n\treturn nfp_app_setup_tc(port->app, netdev, type, type_data);\n}\n\nint nfp_port_set_features(struct net_device *netdev, netdev_features_t features)\n{\n\tstruct nfp_port *port;\n\n\tport = nfp_port_from_netdev(netdev);\n\tif (!port)\n\t\treturn 0;\n\n\tif ((netdev->features & NETIF_F_HW_TC) > (features & NETIF_F_HW_TC) &&\n\t    port->tc_offload_cnt) {\n\t\tnetdev_err(netdev, \"Cannot disable HW TC offload while offloads active\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\treturn 0;\n}\n\nstruct nfp_eth_table_port *__nfp_port_get_eth_port(struct nfp_port *port)\n{\n\tif (!port)\n\t\treturn NULL;\n\tif (port->type != NFP_PORT_PHYS_PORT)\n\t\treturn NULL;\n\n\treturn port->eth_port;\n}\n\nstruct nfp_eth_table_port *nfp_port_get_eth_port(struct nfp_port *port)\n{\n\tif (!__nfp_port_get_eth_port(port))\n\t\treturn NULL;\n\n\tif (test_bit(NFP_PORT_CHANGED, &port->flags))\n\t\tif (nfp_net_refresh_eth_port(port))\n\t\t\treturn NULL;\n\n\treturn __nfp_port_get_eth_port(port);\n}\n\nint\nnfp_port_get_phys_port_name(struct net_device *netdev, char *name, size_t len)\n{\n\tstruct nfp_eth_table_port *eth_port;\n\tstruct nfp_port *port;\n\tint n;\n\n\tport = nfp_port_from_netdev(netdev);\n\tif (!port)\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (port->type) {\n\tcase NFP_PORT_PHYS_PORT:\n\t\teth_port = __nfp_port_get_eth_port(port);\n\t\tif (!eth_port)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tif (!eth_port->is_split)\n\t\t\tn = snprintf(name, len, \"p%d\", eth_port->label_port);\n\t\telse\n\t\t\tn = snprintf(name, len, \"p%ds%d\", eth_port->label_port,\n\t\t\t\t     eth_port->label_subport);\n\t\tbreak;\n\tcase NFP_PORT_PF_PORT:\n\t\tif (!port->pf_split)\n\t\t\tn = snprintf(name, len, \"pf%d\", port->pf_id);\n\t\telse\n\t\t\tn = snprintf(name, len, \"pf%ds%d\", port->pf_id,\n\t\t\t\t     port->pf_split_id);\n\t\tbreak;\n\tcase NFP_PORT_VF_PORT:\n\t\tn = snprintf(name, len, \"pf%dvf%d\", port->pf_id, port->vf_id);\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (n >= len)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n \nint nfp_port_configure(struct net_device *netdev, bool configed)\n{\n\tstruct nfp_eth_table_port *eth_port;\n\tstruct nfp_port *port;\n\tint err;\n\n\tport = nfp_port_from_netdev(netdev);\n\teth_port = __nfp_port_get_eth_port(port);\n\tif (!eth_port)\n\t\treturn 0;\n\tif (port->eth_forced)\n\t\treturn 0;\n\n\terr = nfp_eth_set_configured(port->app->cpp, eth_port->index, configed);\n\treturn err < 0 && err != -EOPNOTSUPP ? err : 0;\n}\n\nint nfp_port_init_phy_port(struct nfp_pf *pf, struct nfp_app *app,\n\t\t\t   struct nfp_port *port, unsigned int id)\n{\n\t \n\tif (!pf->eth_tbl || id >= pf->eth_tbl->count) {\n\t\tnfp_err(app->cpp,\n\t\t\t\"NSP port entries don't match vNICs (no entry %d)\\n\",\n\t\t\tid);\n\t\treturn -EINVAL;\n\t}\n\tif (pf->eth_tbl->ports[id].override_changed) {\n\t\tnfp_warn(app->cpp,\n\t\t\t \"Config changed for port #%d, reboot required before port will be operational\\n\",\n\t\t\t pf->eth_tbl->ports[id].index);\n\t\tport->type = NFP_PORT_INVALID;\n\t\treturn 0;\n\t}\n\n\tport->eth_port = &pf->eth_tbl->ports[id];\n\tport->eth_id = pf->eth_tbl->ports[id].index;\n\tport->netdev->dev_port = id;\n\tif (pf->mac_stats_mem)\n\t\tport->eth_stats =\n\t\t\tpf->mac_stats_mem + port->eth_id * NFP_MAC_STATS_SIZE;\n\n\treturn 0;\n}\n\nstruct nfp_port *\nnfp_port_alloc(struct nfp_app *app, enum nfp_port_type type,\n\t       struct net_device *netdev)\n{\n\tstruct nfp_port *port;\n\n\tport = kzalloc(sizeof(*port), GFP_KERNEL);\n\tif (!port)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tport->netdev = netdev;\n\tport->type = type;\n\tport->app = app;\n\n\tlist_add_tail(&port->port_list, &app->pf->ports);\n\n\treturn port;\n}\n\nvoid nfp_port_free(struct nfp_port *port)\n{\n\tif (!port)\n\t\treturn;\n\tlist_del(&port->port_list);\n\tkfree(port);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}