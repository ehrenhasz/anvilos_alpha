{
  "module_name": "rings.c",
  "hash_id": "e6f8cbfde3308a8ac81328081a94c2b0b992afc06c2e69e76b4388e2ff5ae5fb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/netronome/nfp/nfdk/rings.c",
  "human_readable_source": "\n \n\n#include <linux/seq_file.h>\n\n#include \"../nfp_net.h\"\n#include \"../nfp_net_dp.h\"\n#include \"nfdk.h\"\n\nstatic void\nnfp_nfdk_tx_ring_reset(struct nfp_net_dp *dp, struct nfp_net_tx_ring *tx_ring)\n{\n\tstruct device *dev = dp->dev;\n\tstruct netdev_queue *nd_q;\n\n\twhile (!tx_ring->is_xdp && tx_ring->rd_p != tx_ring->wr_p) {\n\t\tconst skb_frag_t *frag, *fend;\n\t\tunsigned int size, n_descs = 1;\n\t\tstruct nfp_nfdk_tx_buf *txbuf;\n\t\tint nr_frags, rd_idx;\n\t\tstruct sk_buff *skb;\n\n\t\trd_idx = D_IDX(tx_ring, tx_ring->rd_p);\n\t\ttxbuf = &tx_ring->ktxbufs[rd_idx];\n\n\t\tskb = txbuf->skb;\n\t\tif (!skb) {\n\t\t\tn_descs = D_BLOCK_CPL(tx_ring->rd_p);\n\t\t\tgoto next;\n\t\t}\n\n\t\tnr_frags = skb_shinfo(skb)->nr_frags;\n\t\ttxbuf++;\n\n\t\t \n\t\tsize = skb_headlen(skb);\n\t\tdma_unmap_single(dev, txbuf->dma_addr, size, DMA_TO_DEVICE);\n\t\tn_descs += nfp_nfdk_headlen_to_segs(size);\n\t\ttxbuf++;\n\n\t\tfrag = skb_shinfo(skb)->frags;\n\t\tfend = frag + nr_frags;\n\t\tfor (; frag < fend; frag++) {\n\t\t\tsize = skb_frag_size(frag);\n\t\t\tdma_unmap_page(dev, txbuf->dma_addr,\n\t\t\t\t       skb_frag_size(frag), DMA_TO_DEVICE);\n\t\t\tn_descs += DIV_ROUND_UP(size,\n\t\t\t\t\t\tNFDK_TX_MAX_DATA_PER_DESC);\n\t\t\ttxbuf++;\n\t\t}\n\n\t\tif (skb_is_gso(skb))\n\t\t\tn_descs++;\n\n\t\tdev_kfree_skb_any(skb);\nnext:\n\t\ttx_ring->rd_p += n_descs;\n\t}\n\n\tmemset(tx_ring->txds, 0, tx_ring->size);\n\ttx_ring->data_pending = 0;\n\ttx_ring->wr_p = 0;\n\ttx_ring->rd_p = 0;\n\ttx_ring->qcp_rd_p = 0;\n\ttx_ring->wr_ptr_add = 0;\n\n\tif (tx_ring->is_xdp || !dp->netdev)\n\t\treturn;\n\n\tnd_q = netdev_get_tx_queue(dp->netdev, tx_ring->idx);\n\tnetdev_tx_reset_queue(nd_q);\n}\n\nstatic void nfp_nfdk_tx_ring_free(struct nfp_net_tx_ring *tx_ring)\n{\n\tstruct nfp_net_r_vector *r_vec = tx_ring->r_vec;\n\tstruct nfp_net_dp *dp = &r_vec->nfp_net->dp;\n\n\tkvfree(tx_ring->ktxbufs);\n\n\tif (tx_ring->ktxds)\n\t\tdma_free_coherent(dp->dev, tx_ring->size,\n\t\t\t\t  tx_ring->ktxds, tx_ring->dma);\n\n\ttx_ring->cnt = 0;\n\ttx_ring->txbufs = NULL;\n\ttx_ring->txds = NULL;\n\ttx_ring->dma = 0;\n\ttx_ring->size = 0;\n}\n\nstatic int\nnfp_nfdk_tx_ring_alloc(struct nfp_net_dp *dp, struct nfp_net_tx_ring *tx_ring)\n{\n\tstruct nfp_net_r_vector *r_vec = tx_ring->r_vec;\n\n\ttx_ring->cnt = dp->txd_cnt * NFDK_TX_DESC_PER_SIMPLE_PKT;\n\ttx_ring->size = array_size(tx_ring->cnt, sizeof(*tx_ring->ktxds));\n\ttx_ring->ktxds = dma_alloc_coherent(dp->dev, tx_ring->size,\n\t\t\t\t\t    &tx_ring->dma,\n\t\t\t\t\t    GFP_KERNEL | __GFP_NOWARN);\n\tif (!tx_ring->ktxds) {\n\t\tnetdev_warn(dp->netdev, \"failed to allocate TX descriptor ring memory, requested descriptor count: %d, consider lowering descriptor count\\n\",\n\t\t\t    tx_ring->cnt);\n\t\tgoto err_alloc;\n\t}\n\n\ttx_ring->ktxbufs = kvcalloc(tx_ring->cnt, sizeof(*tx_ring->ktxbufs),\n\t\t\t\t    GFP_KERNEL);\n\tif (!tx_ring->ktxbufs)\n\t\tgoto err_alloc;\n\n\tif (!tx_ring->is_xdp && dp->netdev)\n\t\tnetif_set_xps_queue(dp->netdev, &r_vec->affinity_mask,\n\t\t\t\t    tx_ring->idx);\n\n\treturn 0;\n\nerr_alloc:\n\tnfp_nfdk_tx_ring_free(tx_ring);\n\treturn -ENOMEM;\n}\n\nstatic void\nnfp_nfdk_tx_ring_bufs_free(struct nfp_net_dp *dp,\n\t\t\t   struct nfp_net_tx_ring *tx_ring)\n{\n}\n\nstatic int\nnfp_nfdk_tx_ring_bufs_alloc(struct nfp_net_dp *dp,\n\t\t\t    struct nfp_net_tx_ring *tx_ring)\n{\n\treturn 0;\n}\n\nstatic void\nnfp_nfdk_print_tx_descs(struct seq_file *file,\n\t\t\tstruct nfp_net_r_vector *r_vec,\n\t\t\tstruct nfp_net_tx_ring *tx_ring,\n\t\t\tu32 d_rd_p, u32 d_wr_p)\n{\n\tstruct nfp_nfdk_tx_desc *txd;\n\tu32 txd_cnt = tx_ring->cnt;\n\tint i;\n\n\tfor (i = 0; i < txd_cnt; i++) {\n\t\ttxd = &tx_ring->ktxds[i];\n\n\t\tseq_printf(file, \"%04d: 0x%08x 0x%08x 0x%016llx\", i,\n\t\t\t   txd->vals[0], txd->vals[1], tx_ring->ktxbufs[i].raw);\n\n\t\tif (i == tx_ring->rd_p % txd_cnt)\n\t\t\tseq_puts(file, \" H_RD\");\n\t\tif (i == tx_ring->wr_p % txd_cnt)\n\t\t\tseq_puts(file, \" H_WR\");\n\t\tif (i == d_rd_p % txd_cnt)\n\t\t\tseq_puts(file, \" D_RD\");\n\t\tif (i == d_wr_p % txd_cnt)\n\t\t\tseq_puts(file, \" D_WR\");\n\n\t\tseq_putc(file, '\\n');\n\t}\n}\n\n#define NFP_NFDK_CFG_CTRL_SUPPORTED\t\t\t\t\t\\\n\t(NFP_NET_CFG_CTRL_ENABLE | NFP_NET_CFG_CTRL_PROMISC |\t\t\\\n\t NFP_NET_CFG_CTRL_L2BC | NFP_NET_CFG_CTRL_L2MC |\t\t\\\n\t NFP_NET_CFG_CTRL_RXCSUM | NFP_NET_CFG_CTRL_TXCSUM |\t\t\\\n\t NFP_NET_CFG_CTRL_RXVLAN |\t\t\t\t\t\\\n\t NFP_NET_CFG_CTRL_RXVLAN_V2 | NFP_NET_CFG_CTRL_RXQINQ |\t\t\\\n\t NFP_NET_CFG_CTRL_TXVLAN_V2 |\t\t\t\t\t\\\n\t NFP_NET_CFG_CTRL_GATHER | NFP_NET_CFG_CTRL_LSO |\t\t\\\n\t NFP_NET_CFG_CTRL_CTAG_FILTER | NFP_NET_CFG_CTRL_CMSG_DATA |\t\\\n\t NFP_NET_CFG_CTRL_RINGCFG | NFP_NET_CFG_CTRL_IRQMOD |\t\t\\\n\t NFP_NET_CFG_CTRL_TXRWB | NFP_NET_CFG_CTRL_VEPA |\t\t\\\n\t NFP_NET_CFG_CTRL_VXLAN | NFP_NET_CFG_CTRL_NVGRE |\t\t\\\n\t NFP_NET_CFG_CTRL_BPF | NFP_NET_CFG_CTRL_LSO2 |\t\t\t\\\n\t NFP_NET_CFG_CTRL_RSS2 | NFP_NET_CFG_CTRL_CSUM_COMPLETE |\t\\\n\t NFP_NET_CFG_CTRL_LIVE_ADDR)\n\nconst struct nfp_dp_ops nfp_nfdk_ops = {\n\t.version\t\t= NFP_NFD_VER_NFDK,\n\t.tx_min_desc_per_pkt\t= NFDK_TX_DESC_PER_SIMPLE_PKT,\n\t.cap_mask\t\t= NFP_NFDK_CFG_CTRL_SUPPORTED,\n\t.dma_mask\t\t= DMA_BIT_MASK(48),\n\t.poll\t\t\t= nfp_nfdk_poll,\n\t.ctrl_poll\t\t= nfp_nfdk_ctrl_poll,\n\t.xmit\t\t\t= nfp_nfdk_tx,\n\t.ctrl_tx_one\t\t= nfp_nfdk_ctrl_tx_one,\n\t.rx_ring_fill_freelist\t= nfp_nfdk_rx_ring_fill_freelist,\n\t.tx_ring_alloc\t\t= nfp_nfdk_tx_ring_alloc,\n\t.tx_ring_reset\t\t= nfp_nfdk_tx_ring_reset,\n\t.tx_ring_free\t\t= nfp_nfdk_tx_ring_free,\n\t.tx_ring_bufs_alloc\t= nfp_nfdk_tx_ring_bufs_alloc,\n\t.tx_ring_bufs_free\t= nfp_nfdk_tx_ring_bufs_free,\n\t.print_tx_descs\t\t= nfp_nfdk_print_tx_descs\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}