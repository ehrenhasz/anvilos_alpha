{
  "module_name": "dp.c",
  "hash_id": "1692cb1ce8dffeeda55f35eba423bf7580c76c20b6cfe79fe1979aaedbe09137",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/netronome/nfp/nfdk/dp.c",
  "human_readable_source": "\n \n\n#include <linux/bpf_trace.h>\n#include <linux/netdevice.h>\n#include <linux/overflow.h>\n#include <linux/sizes.h>\n#include <linux/bitfield.h>\n#include <net/xfrm.h>\n\n#include \"../nfp_app.h\"\n#include \"../nfp_net.h\"\n#include \"../nfp_net_dp.h\"\n#include \"../crypto/crypto.h\"\n#include \"../crypto/fw.h\"\n#include \"nfdk.h\"\n\nstatic int nfp_nfdk_tx_ring_should_wake(struct nfp_net_tx_ring *tx_ring)\n{\n\treturn !nfp_net_tx_full(tx_ring, NFDK_TX_DESC_STOP_CNT * 2);\n}\n\nstatic int nfp_nfdk_tx_ring_should_stop(struct nfp_net_tx_ring *tx_ring)\n{\n\treturn nfp_net_tx_full(tx_ring, NFDK_TX_DESC_STOP_CNT);\n}\n\nstatic void nfp_nfdk_tx_ring_stop(struct netdev_queue *nd_q,\n\t\t\t\t  struct nfp_net_tx_ring *tx_ring)\n{\n\tnetif_tx_stop_queue(nd_q);\n\n\t \n\tsmp_mb();\n\tif (unlikely(nfp_nfdk_tx_ring_should_wake(tx_ring)))\n\t\tnetif_tx_start_queue(nd_q);\n}\n\nstatic __le64\nnfp_nfdk_tx_tso(struct nfp_net_r_vector *r_vec, struct nfp_nfdk_tx_buf *txbuf,\n\t\tstruct sk_buff *skb)\n{\n\tu32 segs, hdrlen, l3_offset, l4_offset;\n\tstruct nfp_nfdk_tx_desc txd;\n\tu16 mss;\n\n\tif (!skb->encapsulation) {\n\t\tl3_offset = skb_network_offset(skb);\n\t\tl4_offset = skb_transport_offset(skb);\n\t\thdrlen = skb_tcp_all_headers(skb);\n\t} else {\n\t\tl3_offset = skb_inner_network_offset(skb);\n\t\tl4_offset = skb_inner_transport_offset(skb);\n\t\thdrlen = skb_inner_tcp_all_headers(skb);\n\t}\n\n\tsegs = skb_shinfo(skb)->gso_segs;\n\tmss = skb_shinfo(skb)->gso_size & NFDK_DESC_TX_MSS_MASK;\n\n\ttxd.l3_offset = l3_offset;\n\ttxd.l4_offset = l4_offset;\n\ttxd.lso_meta_res = 0;\n\ttxd.mss = cpu_to_le16(mss);\n\ttxd.lso_hdrlen = hdrlen;\n\ttxd.lso_totsegs = segs;\n\n\ttxbuf->pkt_cnt = segs;\n\ttxbuf->real_len = skb->len + hdrlen * (txbuf->pkt_cnt - 1);\n\n\tu64_stats_update_begin(&r_vec->tx_sync);\n\tr_vec->tx_lso++;\n\tu64_stats_update_end(&r_vec->tx_sync);\n\n\treturn txd.raw;\n}\n\nstatic u8\nnfp_nfdk_tx_csum(struct nfp_net_dp *dp, struct nfp_net_r_vector *r_vec,\n\t\t unsigned int pkt_cnt, struct sk_buff *skb, u64 flags)\n{\n\tstruct ipv6hdr *ipv6h;\n\tstruct iphdr *iph;\n\n\tif (!(dp->ctrl & NFP_NET_CFG_CTRL_TXCSUM))\n\t\treturn flags;\n\n\tif (skb->ip_summed != CHECKSUM_PARTIAL)\n\t\treturn flags;\n\n\tflags |= NFDK_DESC_TX_L4_CSUM;\n\n\tiph = skb->encapsulation ? inner_ip_hdr(skb) : ip_hdr(skb);\n\tipv6h = skb->encapsulation ? inner_ipv6_hdr(skb) : ipv6_hdr(skb);\n\n\t \n\tif (iph->version == 4) {\n\t\tflags |= NFDK_DESC_TX_L3_CSUM;\n\t} else if (ipv6h->version != 6) {\n\t\tnn_dp_warn(dp, \"partial checksum but ipv=%x!\\n\", iph->version);\n\t\treturn flags;\n\t}\n\n\tu64_stats_update_begin(&r_vec->tx_sync);\n\tif (!skb->encapsulation) {\n\t\tr_vec->hw_csum_tx += pkt_cnt;\n\t} else {\n\t\tflags |= NFDK_DESC_TX_ENCAP;\n\t\tr_vec->hw_csum_tx_inner += pkt_cnt;\n\t}\n\tu64_stats_update_end(&r_vec->tx_sync);\n\n\treturn flags;\n}\n\nstatic int\nnfp_nfdk_tx_maybe_close_block(struct nfp_net_tx_ring *tx_ring,\n\t\t\t      struct sk_buff *skb)\n{\n\tunsigned int n_descs, wr_p, nop_slots;\n\tconst skb_frag_t *frag, *fend;\n\tstruct nfp_nfdk_tx_desc *txd;\n\tunsigned int nr_frags;\n\tunsigned int wr_idx;\n\tint err;\n\nrecount_descs:\n\tn_descs = nfp_nfdk_headlen_to_segs(skb_headlen(skb));\n\tnr_frags = skb_shinfo(skb)->nr_frags;\n\tfrag = skb_shinfo(skb)->frags;\n\tfend = frag + nr_frags;\n\tfor (; frag < fend; frag++)\n\t\tn_descs += DIV_ROUND_UP(skb_frag_size(frag),\n\t\t\t\t\tNFDK_TX_MAX_DATA_PER_DESC);\n\n\tif (unlikely(n_descs > NFDK_TX_DESC_GATHER_MAX)) {\n\t\tif (skb_is_nonlinear(skb)) {\n\t\t\terr = skb_linearize(skb);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tgoto recount_descs;\n\t\t}\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tn_descs += !!skb_is_gso(skb);\n\n\tif (round_down(tx_ring->wr_p, NFDK_TX_DESC_BLOCK_CNT) !=\n\t    round_down(tx_ring->wr_p + n_descs, NFDK_TX_DESC_BLOCK_CNT))\n\t\tgoto close_block;\n\n\tif ((u32)tx_ring->data_pending + skb->len > NFDK_TX_MAX_DATA_PER_BLOCK)\n\t\tgoto close_block;\n\n\treturn 0;\n\nclose_block:\n\twr_p = tx_ring->wr_p;\n\tnop_slots = D_BLOCK_CPL(wr_p);\n\n\twr_idx = D_IDX(tx_ring, wr_p);\n\ttx_ring->ktxbufs[wr_idx].skb = NULL;\n\ttxd = &tx_ring->ktxds[wr_idx];\n\n\tmemset(txd, 0, array_size(nop_slots, sizeof(struct nfp_nfdk_tx_desc)));\n\n\ttx_ring->data_pending = 0;\n\ttx_ring->wr_p += nop_slots;\n\ttx_ring->wr_ptr_add += nop_slots;\n\n\treturn 0;\n}\n\nstatic int\nnfp_nfdk_prep_tx_meta(struct nfp_net_dp *dp, struct nfp_app *app,\n\t\t      struct sk_buff *skb, bool *ipsec)\n{\n\tstruct metadata_dst *md_dst = skb_metadata_dst(skb);\n\tstruct nfp_ipsec_offload offload_info;\n\tunsigned char *data;\n\tbool vlan_insert;\n\tu32 meta_id = 0;\n\tint md_bytes;\n\n#ifdef CONFIG_NFP_NET_IPSEC\n\tif (xfrm_offload(skb))\n\t\t*ipsec = nfp_net_ipsec_tx_prep(dp, skb, &offload_info);\n#endif\n\n\tif (unlikely(md_dst && md_dst->type != METADATA_HW_PORT_MUX))\n\t\tmd_dst = NULL;\n\n\tvlan_insert = skb_vlan_tag_present(skb) && (dp->ctrl & NFP_NET_CFG_CTRL_TXVLAN_V2);\n\n\tif (!(md_dst || vlan_insert || *ipsec))\n\t\treturn 0;\n\n\tmd_bytes = sizeof(meta_id) +\n\t\t   (!!md_dst ? NFP_NET_META_PORTID_SIZE : 0) +\n\t\t   (vlan_insert ? NFP_NET_META_VLAN_SIZE : 0) +\n\t\t   (*ipsec ? NFP_NET_META_IPSEC_FIELD_SIZE : 0);\n\n\tif (unlikely(skb_cow_head(skb, md_bytes)))\n\t\treturn -ENOMEM;\n\n\tdata = skb_push(skb, md_bytes) + md_bytes;\n\tif (md_dst) {\n\t\tdata -= NFP_NET_META_PORTID_SIZE;\n\t\tput_unaligned_be32(md_dst->u.port_info.port_id, data);\n\t\tmeta_id = NFP_NET_META_PORTID;\n\t}\n\tif (vlan_insert) {\n\t\tdata -= NFP_NET_META_VLAN_SIZE;\n\t\t \n\t\tmemcpy(data, &skb->vlan_proto, sizeof(skb->vlan_proto));\n\t\tput_unaligned_be16(skb_vlan_tag_get(skb), data + sizeof(skb->vlan_proto));\n\t\tmeta_id <<= NFP_NET_META_FIELD_SIZE;\n\t\tmeta_id |= NFP_NET_META_VLAN;\n\t}\n\n\tif (*ipsec) {\n\t\tdata -= NFP_NET_META_IPSEC_SIZE;\n\t\tput_unaligned_be32(offload_info.seq_hi, data);\n\t\tdata -= NFP_NET_META_IPSEC_SIZE;\n\t\tput_unaligned_be32(offload_info.seq_low, data);\n\t\tdata -= NFP_NET_META_IPSEC_SIZE;\n\t\tput_unaligned_be32(offload_info.handle - 1, data);\n\t\tmeta_id <<= NFP_NET_META_IPSEC_FIELD_SIZE;\n\t\tmeta_id |= NFP_NET_META_IPSEC << 8 | NFP_NET_META_IPSEC << 4 | NFP_NET_META_IPSEC;\n\t}\n\n\tmeta_id = FIELD_PREP(NFDK_META_LEN, md_bytes) |\n\t\t  FIELD_PREP(NFDK_META_FIELDS, meta_id);\n\n\tdata -= sizeof(meta_id);\n\tput_unaligned_be32(meta_id, data);\n\n\treturn NFDK_DESC_TX_CHAIN_META;\n}\n\n \nnetdev_tx_t nfp_nfdk_tx(struct sk_buff *skb, struct net_device *netdev)\n{\n\tstruct nfp_net *nn = netdev_priv(netdev);\n\tstruct nfp_nfdk_tx_buf *txbuf, *etxbuf;\n\tu32 cnt, tmp_dlen, dlen_type = 0;\n\tstruct nfp_net_tx_ring *tx_ring;\n\tstruct nfp_net_r_vector *r_vec;\n\tconst skb_frag_t *frag, *fend;\n\tstruct nfp_nfdk_tx_desc *txd;\n\tunsigned int real_len, qidx;\n\tunsigned int dma_len, type;\n\tstruct netdev_queue *nd_q;\n\tstruct nfp_net_dp *dp;\n\tint nr_frags, wr_idx;\n\tdma_addr_t dma_addr;\n\tbool ipsec = false;\n\tu64 metadata;\n\n\tdp = &nn->dp;\n\tqidx = skb_get_queue_mapping(skb);\n\ttx_ring = &dp->tx_rings[qidx];\n\tr_vec = tx_ring->r_vec;\n\tnd_q = netdev_get_tx_queue(dp->netdev, qidx);\n\n\t \n\tif (unlikely(nfp_net_tx_full(tx_ring, NFDK_TX_DESC_STOP_CNT))) {\n\t\tnn_dp_warn(dp, \"TX ring %d busy. wrp=%u rdp=%u\\n\",\n\t\t\t   qidx, tx_ring->wr_p, tx_ring->rd_p);\n\t\tnetif_tx_stop_queue(nd_q);\n\t\tnfp_net_tx_xmit_more_flush(tx_ring);\n\t\tu64_stats_update_begin(&r_vec->tx_sync);\n\t\tr_vec->tx_busy++;\n\t\tu64_stats_update_end(&r_vec->tx_sync);\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\n\tmetadata = nfp_nfdk_prep_tx_meta(dp, nn->app, skb, &ipsec);\n\tif (unlikely((int)metadata < 0))\n\t\tgoto err_flush;\n\n\tif (nfp_nfdk_tx_maybe_close_block(tx_ring, skb))\n\t\tgoto err_flush;\n\n\t \n\tnr_frags = skb_shinfo(skb)->nr_frags;\n\t \n\twr_idx = D_IDX(tx_ring, tx_ring->wr_p);\n\ttxd = &tx_ring->ktxds[wr_idx];\n\ttxbuf = &tx_ring->ktxbufs[wr_idx];\n\n\tdma_len = skb_headlen(skb);\n\tif (skb_is_gso(skb))\n\t\ttype = NFDK_DESC_TX_TYPE_TSO;\n\telse if (!nr_frags && dma_len <= NFDK_TX_MAX_DATA_PER_HEAD)\n\t\ttype = NFDK_DESC_TX_TYPE_SIMPLE;\n\telse\n\t\ttype = NFDK_DESC_TX_TYPE_GATHER;\n\n\tdma_addr = dma_map_single(dp->dev, skb->data, dma_len, DMA_TO_DEVICE);\n\tif (dma_mapping_error(dp->dev, dma_addr))\n\t\tgoto err_warn_dma;\n\n\ttxbuf->skb = skb;\n\ttxbuf++;\n\n\ttxbuf->dma_addr = dma_addr;\n\ttxbuf++;\n\n\t \n\tdma_len -= 1;\n\n\t \n\tdlen_type = FIELD_PREP(NFDK_DESC_TX_DMA_LEN_HEAD,\n\t\t\t       dma_len > NFDK_DESC_TX_DMA_LEN_HEAD ?\n\t\t\t       NFDK_DESC_TX_DMA_LEN_HEAD : dma_len) |\n\t\t    FIELD_PREP(NFDK_DESC_TX_TYPE_HEAD, type);\n\n\ttxd->dma_len_type = cpu_to_le16(dlen_type);\n\tnfp_desc_set_dma_addr_48b(txd, dma_addr);\n\n\t \n\tBUILD_BUG_ON(!(NFDK_DESC_TX_DMA_LEN_HEAD & 1));\n\n\t \n\ttmp_dlen = dlen_type & NFDK_DESC_TX_DMA_LEN_HEAD;\n\tdma_len -= tmp_dlen;\n\tdma_addr += tmp_dlen + 1;\n\ttxd++;\n\n\t \n\tfrag = skb_shinfo(skb)->frags;\n\tfend = frag + nr_frags;\n\n\twhile (true) {\n\t\twhile (dma_len > 0) {\n\t\t\tdma_len -= 1;\n\t\t\tdlen_type = FIELD_PREP(NFDK_DESC_TX_DMA_LEN, dma_len);\n\n\t\t\ttxd->dma_len_type = cpu_to_le16(dlen_type);\n\t\t\tnfp_desc_set_dma_addr_48b(txd, dma_addr);\n\n\t\t\tdma_len -= dlen_type;\n\t\t\tdma_addr += dlen_type + 1;\n\t\t\ttxd++;\n\t\t}\n\n\t\tif (frag >= fend)\n\t\t\tbreak;\n\n\t\tdma_len = skb_frag_size(frag);\n\t\tdma_addr = skb_frag_dma_map(dp->dev, frag, 0, dma_len,\n\t\t\t\t\t    DMA_TO_DEVICE);\n\t\tif (dma_mapping_error(dp->dev, dma_addr))\n\t\t\tgoto err_unmap;\n\n\t\ttxbuf->dma_addr = dma_addr;\n\t\ttxbuf++;\n\n\t\tfrag++;\n\t}\n\n\t(txd - 1)->dma_len_type = cpu_to_le16(dlen_type | NFDK_DESC_TX_EOP);\n\n\tif (ipsec)\n\t\tmetadata = nfp_nfdk_ipsec_tx(metadata, skb);\n\n\tif (!skb_is_gso(skb)) {\n\t\treal_len = skb->len;\n\t\t \n\t\tif (!ipsec)\n\t\t\tmetadata = nfp_nfdk_tx_csum(dp, r_vec, 1, skb, metadata);\n\t\ttxd->raw = cpu_to_le64(metadata);\n\t\ttxd++;\n\t} else {\n\t\t \n\t\t(txd + 1)->raw = nfp_nfdk_tx_tso(r_vec, txbuf, skb);\n\t\treal_len = txbuf->real_len;\n\t\t \n\t\tif (!ipsec)\n\t\t\tmetadata = nfp_nfdk_tx_csum(dp, r_vec, txbuf->pkt_cnt, skb, metadata);\n\t\ttxd->raw = cpu_to_le64(metadata);\n\t\ttxd += 2;\n\t\ttxbuf++;\n\t}\n\n\tcnt = txd - tx_ring->ktxds - wr_idx;\n\tif (unlikely(round_down(wr_idx, NFDK_TX_DESC_BLOCK_CNT) !=\n\t\t     round_down(wr_idx + cnt - 1, NFDK_TX_DESC_BLOCK_CNT)))\n\t\tgoto err_warn_overflow;\n\n\tskb_tx_timestamp(skb);\n\n\ttx_ring->wr_p += cnt;\n\tif (tx_ring->wr_p % NFDK_TX_DESC_BLOCK_CNT)\n\t\ttx_ring->data_pending += skb->len;\n\telse\n\t\ttx_ring->data_pending = 0;\n\n\tif (nfp_nfdk_tx_ring_should_stop(tx_ring))\n\t\tnfp_nfdk_tx_ring_stop(nd_q, tx_ring);\n\n\ttx_ring->wr_ptr_add += cnt;\n\tif (__netdev_tx_sent_queue(nd_q, real_len, netdev_xmit_more()))\n\t\tnfp_net_tx_xmit_more_flush(tx_ring);\n\n\treturn NETDEV_TX_OK;\n\nerr_warn_overflow:\n\tWARN_ONCE(1, \"unable to fit packet into a descriptor wr_idx:%d head:%d frags:%d cnt:%d\",\n\t\t  wr_idx, skb_headlen(skb), nr_frags, cnt);\n\tif (skb_is_gso(skb))\n\t\ttxbuf--;\nerr_unmap:\n\t \n\tetxbuf = txbuf;\n\t \n\ttxbuf = &tx_ring->ktxbufs[wr_idx + 1];\n\tif (txbuf < etxbuf) {\n\t\tdma_unmap_single(dp->dev, txbuf->dma_addr,\n\t\t\t\t skb_headlen(skb), DMA_TO_DEVICE);\n\t\ttxbuf->raw = 0;\n\t\ttxbuf++;\n\t}\n\tfrag = skb_shinfo(skb)->frags;\n\twhile (etxbuf < txbuf) {\n\t\tdma_unmap_page(dp->dev, txbuf->dma_addr,\n\t\t\t       skb_frag_size(frag), DMA_TO_DEVICE);\n\t\ttxbuf->raw = 0;\n\t\tfrag++;\n\t\ttxbuf++;\n\t}\nerr_warn_dma:\n\tnn_dp_warn(dp, \"Failed to map DMA TX buffer\\n\");\nerr_flush:\n\tnfp_net_tx_xmit_more_flush(tx_ring);\n\tu64_stats_update_begin(&r_vec->tx_sync);\n\tr_vec->tx_errors++;\n\tu64_stats_update_end(&r_vec->tx_sync);\n\tdev_kfree_skb_any(skb);\n\treturn NETDEV_TX_OK;\n}\n\n \nstatic void nfp_nfdk_tx_complete(struct nfp_net_tx_ring *tx_ring, int budget)\n{\n\tstruct nfp_net_r_vector *r_vec = tx_ring->r_vec;\n\tstruct nfp_net_dp *dp = &r_vec->nfp_net->dp;\n\tu32 done_pkts = 0, done_bytes = 0;\n\tstruct nfp_nfdk_tx_buf *ktxbufs;\n\tstruct device *dev = dp->dev;\n\tstruct netdev_queue *nd_q;\n\tu32 rd_p, qcp_rd_p;\n\tint todo;\n\n\trd_p = tx_ring->rd_p;\n\tif (tx_ring->wr_p == rd_p)\n\t\treturn;\n\n\t \n\tqcp_rd_p = nfp_net_read_tx_cmpl(tx_ring, dp);\n\n\tif (qcp_rd_p == tx_ring->qcp_rd_p)\n\t\treturn;\n\n\ttodo = D_IDX(tx_ring, qcp_rd_p - tx_ring->qcp_rd_p);\n\tktxbufs = tx_ring->ktxbufs;\n\n\twhile (todo > 0) {\n\t\tconst skb_frag_t *frag, *fend;\n\t\tunsigned int size, n_descs = 1;\n\t\tstruct nfp_nfdk_tx_buf *txbuf;\n\t\tstruct sk_buff *skb;\n\n\t\ttxbuf = &ktxbufs[D_IDX(tx_ring, rd_p)];\n\t\tskb = txbuf->skb;\n\t\ttxbuf++;\n\n\t\t \n\t\tif (!skb) {\n\t\t\tn_descs = D_BLOCK_CPL(rd_p);\n\t\t\tgoto next;\n\t\t}\n\n\t\t \n\t\tsize = skb_headlen(skb);\n\t\tn_descs += nfp_nfdk_headlen_to_segs(size);\n\t\tdma_unmap_single(dev, txbuf->dma_addr, size, DMA_TO_DEVICE);\n\t\ttxbuf++;\n\n\t\t \n\t\tfrag = skb_shinfo(skb)->frags;\n\t\tfend = frag + skb_shinfo(skb)->nr_frags;\n\t\tfor (; frag < fend; frag++) {\n\t\t\tsize = skb_frag_size(frag);\n\t\t\tn_descs += DIV_ROUND_UP(size,\n\t\t\t\t\t\tNFDK_TX_MAX_DATA_PER_DESC);\n\t\t\tdma_unmap_page(dev, txbuf->dma_addr,\n\t\t\t\t       skb_frag_size(frag), DMA_TO_DEVICE);\n\t\t\ttxbuf++;\n\t\t}\n\n\t\tif (!skb_is_gso(skb)) {\n\t\t\tdone_bytes += skb->len;\n\t\t\tdone_pkts++;\n\t\t} else {\n\t\t\tdone_bytes += txbuf->real_len;\n\t\t\tdone_pkts += txbuf->pkt_cnt;\n\t\t\tn_descs++;\n\t\t}\n\n\t\tnapi_consume_skb(skb, budget);\nnext:\n\t\trd_p += n_descs;\n\t\ttodo -= n_descs;\n\t}\n\n\ttx_ring->rd_p = rd_p;\n\ttx_ring->qcp_rd_p = qcp_rd_p;\n\n\tu64_stats_update_begin(&r_vec->tx_sync);\n\tr_vec->tx_bytes += done_bytes;\n\tr_vec->tx_pkts += done_pkts;\n\tu64_stats_update_end(&r_vec->tx_sync);\n\n\tif (!dp->netdev)\n\t\treturn;\n\n\tnd_q = netdev_get_tx_queue(dp->netdev, tx_ring->idx);\n\tnetdev_tx_completed_queue(nd_q, done_pkts, done_bytes);\n\tif (nfp_nfdk_tx_ring_should_wake(tx_ring)) {\n\t\t \n\t\tsmp_mb();\n\n\t\tif (unlikely(netif_tx_queue_stopped(nd_q)))\n\t\t\tnetif_tx_wake_queue(nd_q);\n\t}\n\n\tWARN_ONCE(tx_ring->wr_p - tx_ring->rd_p > tx_ring->cnt,\n\t\t  \"TX ring corruption rd_p=%u wr_p=%u cnt=%u\\n\",\n\t\t  tx_ring->rd_p, tx_ring->wr_p, tx_ring->cnt);\n}\n\n \nstatic void *\nnfp_nfdk_napi_alloc_one(struct nfp_net_dp *dp, dma_addr_t *dma_addr)\n{\n\tvoid *frag;\n\n\tif (!dp->xdp_prog) {\n\t\tfrag = napi_alloc_frag(dp->fl_bufsz);\n\t\tif (unlikely(!frag))\n\t\t\treturn NULL;\n\t} else {\n\t\tstruct page *page;\n\n\t\tpage = dev_alloc_page();\n\t\tif (unlikely(!page))\n\t\t\treturn NULL;\n\t\tfrag = page_address(page);\n\t}\n\n\t*dma_addr = nfp_net_dma_map_rx(dp, frag);\n\tif (dma_mapping_error(dp->dev, *dma_addr)) {\n\t\tnfp_net_free_frag(frag, dp->xdp_prog);\n\t\tnn_dp_warn(dp, \"Failed to map DMA RX buffer\\n\");\n\t\treturn NULL;\n\t}\n\n\treturn frag;\n}\n\n \nstatic void\nnfp_nfdk_rx_give_one(const struct nfp_net_dp *dp,\n\t\t     struct nfp_net_rx_ring *rx_ring,\n\t\t     void *frag, dma_addr_t dma_addr)\n{\n\tunsigned int wr_idx;\n\n\twr_idx = D_IDX(rx_ring, rx_ring->wr_p);\n\n\tnfp_net_dma_sync_dev_rx(dp, dma_addr);\n\n\t \n\trx_ring->rxbufs[wr_idx].frag = frag;\n\trx_ring->rxbufs[wr_idx].dma_addr = dma_addr;\n\n\t \n\trx_ring->rxds[wr_idx].fld.reserved = 0;\n\trx_ring->rxds[wr_idx].fld.meta_len_dd = 0;\n\tnfp_desc_set_dma_addr_48b(&rx_ring->rxds[wr_idx].fld,\n\t\t\t\t  dma_addr + dp->rx_dma_off);\n\n\trx_ring->wr_p++;\n\tif (!(rx_ring->wr_p % NFP_NET_FL_BATCH)) {\n\t\t \n\t\twmb();\n\t\tnfp_qcp_wr_ptr_add(rx_ring->qcp_fl, NFP_NET_FL_BATCH);\n\t}\n}\n\n \nvoid nfp_nfdk_rx_ring_fill_freelist(struct nfp_net_dp *dp,\n\t\t\t\t    struct nfp_net_rx_ring *rx_ring)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < rx_ring->cnt - 1; i++)\n\t\tnfp_nfdk_rx_give_one(dp, rx_ring, rx_ring->rxbufs[i].frag,\n\t\t\t\t     rx_ring->rxbufs[i].dma_addr);\n}\n\n \nstatic int nfp_nfdk_rx_csum_has_errors(u16 flags)\n{\n\tu16 csum_all_checked, csum_all_ok;\n\n\tcsum_all_checked = flags & __PCIE_DESC_RX_CSUM_ALL;\n\tcsum_all_ok = flags & __PCIE_DESC_RX_CSUM_ALL_OK;\n\n\treturn csum_all_checked != (csum_all_ok << PCIE_DESC_RX_CSUM_OK_SHIFT);\n}\n\n \nstatic void\nnfp_nfdk_rx_csum(struct nfp_net_dp *dp, struct nfp_net_r_vector *r_vec,\n\t\t struct nfp_net_rx_desc *rxd, struct nfp_meta_parsed *meta,\n\t\t struct sk_buff *skb)\n{\n\tskb_checksum_none_assert(skb);\n\n\tif (!(dp->netdev->features & NETIF_F_RXCSUM))\n\t\treturn;\n\n\tif (meta->csum_type) {\n\t\tskb->ip_summed = meta->csum_type;\n\t\tskb->csum = meta->csum;\n\t\tu64_stats_update_begin(&r_vec->rx_sync);\n\t\tr_vec->hw_csum_rx_complete++;\n\t\tu64_stats_update_end(&r_vec->rx_sync);\n\t\treturn;\n\t}\n\n\tif (nfp_nfdk_rx_csum_has_errors(le16_to_cpu(rxd->rxd.flags))) {\n\t\tu64_stats_update_begin(&r_vec->rx_sync);\n\t\tr_vec->hw_csum_rx_error++;\n\t\tu64_stats_update_end(&r_vec->rx_sync);\n\t\treturn;\n\t}\n\n\t \n\tif (rxd->rxd.flags & PCIE_DESC_RX_TCP_CSUM_OK ||\n\t    rxd->rxd.flags & PCIE_DESC_RX_UDP_CSUM_OK) {\n\t\t__skb_incr_checksum_unnecessary(skb);\n\t\tu64_stats_update_begin(&r_vec->rx_sync);\n\t\tr_vec->hw_csum_rx_ok++;\n\t\tu64_stats_update_end(&r_vec->rx_sync);\n\t}\n\n\tif (rxd->rxd.flags & PCIE_DESC_RX_I_TCP_CSUM_OK ||\n\t    rxd->rxd.flags & PCIE_DESC_RX_I_UDP_CSUM_OK) {\n\t\t__skb_incr_checksum_unnecessary(skb);\n\t\tu64_stats_update_begin(&r_vec->rx_sync);\n\t\tr_vec->hw_csum_rx_inner_ok++;\n\t\tu64_stats_update_end(&r_vec->rx_sync);\n\t}\n}\n\nstatic void\nnfp_nfdk_set_hash(struct net_device *netdev, struct nfp_meta_parsed *meta,\n\t\t  unsigned int type, __be32 *hash)\n{\n\tif (!(netdev->features & NETIF_F_RXHASH))\n\t\treturn;\n\n\tswitch (type) {\n\tcase NFP_NET_RSS_IPV4:\n\tcase NFP_NET_RSS_IPV6:\n\tcase NFP_NET_RSS_IPV6_EX:\n\t\tmeta->hash_type = PKT_HASH_TYPE_L3;\n\t\tbreak;\n\tdefault:\n\t\tmeta->hash_type = PKT_HASH_TYPE_L4;\n\t\tbreak;\n\t}\n\n\tmeta->hash = get_unaligned_be32(hash);\n}\n\nstatic bool\nnfp_nfdk_parse_meta(struct net_device *netdev, struct nfp_meta_parsed *meta,\n\t\t    void *data, void *pkt, unsigned int pkt_len, int meta_len)\n{\n\tu32 meta_info, vlan_info;\n\n\tmeta_info = get_unaligned_be32(data);\n\tdata += 4;\n\n\twhile (meta_info) {\n\t\tswitch (meta_info & NFP_NET_META_FIELD_MASK) {\n\t\tcase NFP_NET_META_HASH:\n\t\t\tmeta_info >>= NFP_NET_META_FIELD_SIZE;\n\t\t\tnfp_nfdk_set_hash(netdev, meta,\n\t\t\t\t\t  meta_info & NFP_NET_META_FIELD_MASK,\n\t\t\t\t\t  (__be32 *)data);\n\t\t\tdata += 4;\n\t\t\tbreak;\n\t\tcase NFP_NET_META_MARK:\n\t\t\tmeta->mark = get_unaligned_be32(data);\n\t\t\tdata += 4;\n\t\t\tbreak;\n\t\tcase NFP_NET_META_VLAN:\n\t\t\tvlan_info = get_unaligned_be32(data);\n\t\t\tif (FIELD_GET(NFP_NET_META_VLAN_STRIP, vlan_info)) {\n\t\t\t\tmeta->vlan.stripped = true;\n\t\t\t\tmeta->vlan.tpid = FIELD_GET(NFP_NET_META_VLAN_TPID_MASK,\n\t\t\t\t\t\t\t    vlan_info);\n\t\t\t\tmeta->vlan.tci = FIELD_GET(NFP_NET_META_VLAN_TCI_MASK,\n\t\t\t\t\t\t\t   vlan_info);\n\t\t\t}\n\t\t\tdata += 4;\n\t\t\tbreak;\n\t\tcase NFP_NET_META_PORTID:\n\t\t\tmeta->portid = get_unaligned_be32(data);\n\t\t\tdata += 4;\n\t\t\tbreak;\n\t\tcase NFP_NET_META_CSUM:\n\t\t\tmeta->csum_type = CHECKSUM_COMPLETE;\n\t\t\tmeta->csum =\n\t\t\t\t(__force __wsum)__get_unaligned_cpu32(data);\n\t\t\tdata += 4;\n\t\t\tbreak;\n\t\tcase NFP_NET_META_RESYNC_INFO:\n\t\t\tif (nfp_net_tls_rx_resync_req(netdev, data, pkt,\n\t\t\t\t\t\t      pkt_len))\n\t\t\t\treturn false;\n\t\t\tdata += sizeof(struct nfp_net_tls_resync_req);\n\t\t\tbreak;\n#ifdef CONFIG_NFP_NET_IPSEC\n\t\tcase NFP_NET_META_IPSEC:\n\t\t\t \n\t\t\tmeta->ipsec_saidx = get_unaligned_be32(data) + 1;\n\t\t\tdata += 4;\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\treturn true;\n\t\t}\n\n\t\tmeta_info >>= NFP_NET_META_FIELD_SIZE;\n\t}\n\n\treturn data != pkt;\n}\n\nstatic void\nnfp_nfdk_rx_drop(const struct nfp_net_dp *dp, struct nfp_net_r_vector *r_vec,\n\t\t struct nfp_net_rx_ring *rx_ring, struct nfp_net_rx_buf *rxbuf,\n\t\t struct sk_buff *skb)\n{\n\tu64_stats_update_begin(&r_vec->rx_sync);\n\tr_vec->rx_drops++;\n\t \n\tif (skb && rxbuf)\n\t\tr_vec->rx_replace_buf_alloc_fail++;\n\tu64_stats_update_end(&r_vec->rx_sync);\n\n\t \n\tif (skb && rxbuf && skb->head == rxbuf->frag)\n\t\tpage_ref_inc(virt_to_head_page(rxbuf->frag));\n\tif (rxbuf)\n\t\tnfp_nfdk_rx_give_one(dp, rx_ring, rxbuf->frag, rxbuf->dma_addr);\n\tif (skb)\n\t\tdev_kfree_skb_any(skb);\n}\n\nstatic bool nfp_nfdk_xdp_complete(struct nfp_net_tx_ring *tx_ring)\n{\n\tstruct nfp_net_r_vector *r_vec = tx_ring->r_vec;\n\tstruct nfp_net_dp *dp = &r_vec->nfp_net->dp;\n\tstruct nfp_net_rx_ring *rx_ring;\n\tu32 qcp_rd_p, done = 0;\n\tbool done_all;\n\tint todo;\n\n\t \n\tqcp_rd_p = nfp_net_read_tx_cmpl(tx_ring, dp);\n\tif (qcp_rd_p == tx_ring->qcp_rd_p)\n\t\treturn true;\n\n\ttodo = D_IDX(tx_ring, qcp_rd_p - tx_ring->qcp_rd_p);\n\n\tdone_all = todo <= NFP_NET_XDP_MAX_COMPLETE;\n\ttodo = min(todo, NFP_NET_XDP_MAX_COMPLETE);\n\n\trx_ring = r_vec->rx_ring;\n\twhile (todo > 0) {\n\t\tint idx = D_IDX(tx_ring, tx_ring->rd_p + done);\n\t\tstruct nfp_nfdk_tx_buf *txbuf;\n\t\tunsigned int step = 1;\n\n\t\ttxbuf = &tx_ring->ktxbufs[idx];\n\t\tif (!txbuf->raw)\n\t\t\tgoto next;\n\n\t\tif (NFDK_TX_BUF_INFO(txbuf->val) != NFDK_TX_BUF_INFO_SOP) {\n\t\t\tWARN_ONCE(1, \"Unexpected TX buffer in XDP TX ring\\n\");\n\t\t\tgoto next;\n\t\t}\n\n\t\t \n\t\tnfp_nfdk_rx_give_one(dp, rx_ring,\n\t\t\t\t     (void *)NFDK_TX_BUF_PTR(txbuf[0].val),\n\t\t\t\t     txbuf[1].dma_addr);\n\t\ttxbuf[0].raw = 0;\n\t\ttxbuf[1].raw = 0;\n\t\tstep = 2;\n\n\t\tu64_stats_update_begin(&r_vec->tx_sync);\n\t\t \n\t\tr_vec->tx_pkts++;\n\t\tu64_stats_update_end(&r_vec->tx_sync);\nnext:\n\t\ttodo -= step;\n\t\tdone += step;\n\t}\n\n\ttx_ring->qcp_rd_p = D_IDX(tx_ring, tx_ring->qcp_rd_p + done);\n\ttx_ring->rd_p += done;\n\n\tWARN_ONCE(tx_ring->wr_p - tx_ring->rd_p > tx_ring->cnt,\n\t\t  \"XDP TX ring corruption rd_p=%u wr_p=%u cnt=%u\\n\",\n\t\t  tx_ring->rd_p, tx_ring->wr_p, tx_ring->cnt);\n\n\treturn done_all;\n}\n\nstatic bool\nnfp_nfdk_tx_xdp_buf(struct nfp_net_dp *dp, struct nfp_net_rx_ring *rx_ring,\n\t\t    struct nfp_net_tx_ring *tx_ring,\n\t\t    struct nfp_net_rx_buf *rxbuf, unsigned int dma_off,\n\t\t    unsigned int pkt_len, bool *completed)\n{\n\tunsigned int dma_map_sz = dp->fl_bufsz - NFP_NET_RX_BUF_NON_DATA;\n\tunsigned int dma_len, type, cnt, dlen_type, tmp_dlen;\n\tstruct nfp_nfdk_tx_buf *txbuf;\n\tstruct nfp_nfdk_tx_desc *txd;\n\tunsigned int n_descs;\n\tdma_addr_t dma_addr;\n\tint wr_idx;\n\n\t \n\tif (pkt_len + dma_off > dma_map_sz)\n\t\treturn false;\n\n\t \n\tif (unlikely(nfp_net_tx_full(tx_ring, NFDK_TX_DESC_STOP_CNT))) {\n\t\tif (!*completed) {\n\t\t\tnfp_nfdk_xdp_complete(tx_ring);\n\t\t\t*completed = true;\n\t\t}\n\n\t\tif (unlikely(nfp_net_tx_full(tx_ring, NFDK_TX_DESC_STOP_CNT))) {\n\t\t\tnfp_nfdk_rx_drop(dp, rx_ring->r_vec, rx_ring, rxbuf,\n\t\t\t\t\t NULL);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t \n\tn_descs = nfp_nfdk_headlen_to_segs(pkt_len);\n\tif ((round_down(tx_ring->wr_p, NFDK_TX_DESC_BLOCK_CNT) !=\n\t     round_down(tx_ring->wr_p + n_descs, NFDK_TX_DESC_BLOCK_CNT)) ||\n\t    ((u32)tx_ring->data_pending + pkt_len >\n\t     NFDK_TX_MAX_DATA_PER_BLOCK)) {\n\t\tunsigned int nop_slots = D_BLOCK_CPL(tx_ring->wr_p);\n\n\t\twr_idx = D_IDX(tx_ring, tx_ring->wr_p);\n\t\ttxd = &tx_ring->ktxds[wr_idx];\n\t\tmemset(txd, 0,\n\t\t       array_size(nop_slots, sizeof(struct nfp_nfdk_tx_desc)));\n\n\t\ttx_ring->data_pending = 0;\n\t\ttx_ring->wr_p += nop_slots;\n\t\ttx_ring->wr_ptr_add += nop_slots;\n\t}\n\n\twr_idx = D_IDX(tx_ring, tx_ring->wr_p);\n\n\ttxbuf = &tx_ring->ktxbufs[wr_idx];\n\n\ttxbuf[0].val = (unsigned long)rxbuf->frag | NFDK_TX_BUF_INFO_SOP;\n\ttxbuf[1].dma_addr = rxbuf->dma_addr;\n\t \n\n\tdma_sync_single_for_device(dp->dev, rxbuf->dma_addr + dma_off,\n\t\t\t\t   pkt_len, DMA_BIDIRECTIONAL);\n\n\t \n\ttxd = &tx_ring->ktxds[wr_idx];\n\tdma_len = pkt_len;\n\tdma_addr = rxbuf->dma_addr + dma_off;\n\n\tif (dma_len <= NFDK_TX_MAX_DATA_PER_HEAD)\n\t\ttype = NFDK_DESC_TX_TYPE_SIMPLE;\n\telse\n\t\ttype = NFDK_DESC_TX_TYPE_GATHER;\n\n\t \n\tdma_len -= 1;\n\tdlen_type = FIELD_PREP(NFDK_DESC_TX_DMA_LEN_HEAD,\n\t\t\t       dma_len > NFDK_DESC_TX_DMA_LEN_HEAD ?\n\t\t\t       NFDK_DESC_TX_DMA_LEN_HEAD : dma_len) |\n\t\t    FIELD_PREP(NFDK_DESC_TX_TYPE_HEAD, type);\n\n\ttxd->dma_len_type = cpu_to_le16(dlen_type);\n\tnfp_desc_set_dma_addr_48b(txd, dma_addr);\n\n\ttmp_dlen = dlen_type & NFDK_DESC_TX_DMA_LEN_HEAD;\n\tdma_len -= tmp_dlen;\n\tdma_addr += tmp_dlen + 1;\n\ttxd++;\n\n\twhile (dma_len > 0) {\n\t\tdma_len -= 1;\n\t\tdlen_type = FIELD_PREP(NFDK_DESC_TX_DMA_LEN, dma_len);\n\t\ttxd->dma_len_type = cpu_to_le16(dlen_type);\n\t\tnfp_desc_set_dma_addr_48b(txd, dma_addr);\n\n\t\tdlen_type &= NFDK_DESC_TX_DMA_LEN;\n\t\tdma_len -= dlen_type;\n\t\tdma_addr += dlen_type + 1;\n\t\ttxd++;\n\t}\n\n\t(txd - 1)->dma_len_type = cpu_to_le16(dlen_type | NFDK_DESC_TX_EOP);\n\n\t \n\ttxd->raw = 0;\n\ttxd++;\n\n\tcnt = txd - tx_ring->ktxds - wr_idx;\n\ttx_ring->wr_p += cnt;\n\tif (tx_ring->wr_p % NFDK_TX_DESC_BLOCK_CNT)\n\t\ttx_ring->data_pending += pkt_len;\n\telse\n\t\ttx_ring->data_pending = 0;\n\n\ttx_ring->wr_ptr_add += cnt;\n\treturn true;\n}\n\n \nstatic int nfp_nfdk_rx(struct nfp_net_rx_ring *rx_ring, int budget)\n{\n\tstruct nfp_net_r_vector *r_vec = rx_ring->r_vec;\n\tstruct nfp_net_dp *dp = &r_vec->nfp_net->dp;\n\tstruct nfp_net_tx_ring *tx_ring;\n\tstruct bpf_prog *xdp_prog;\n\tbool xdp_tx_cmpl = false;\n\tunsigned int true_bufsz;\n\tstruct sk_buff *skb;\n\tint pkts_polled = 0;\n\tstruct xdp_buff xdp;\n\tint idx;\n\n\txdp_prog = READ_ONCE(dp->xdp_prog);\n\ttrue_bufsz = xdp_prog ? PAGE_SIZE : dp->fl_bufsz;\n\txdp_init_buff(&xdp, PAGE_SIZE - NFP_NET_RX_BUF_HEADROOM,\n\t\t      &rx_ring->xdp_rxq);\n\ttx_ring = r_vec->xdp_ring;\n\n\twhile (pkts_polled < budget) {\n\t\tunsigned int meta_len, data_len, meta_off, pkt_len, pkt_off;\n\t\tstruct nfp_net_rx_buf *rxbuf;\n\t\tstruct nfp_net_rx_desc *rxd;\n\t\tstruct nfp_meta_parsed meta;\n\t\tbool redir_egress = false;\n\t\tstruct net_device *netdev;\n\t\tdma_addr_t new_dma_addr;\n\t\tu32 meta_len_xdp = 0;\n\t\tvoid *new_frag;\n\n\t\tidx = D_IDX(rx_ring, rx_ring->rd_p);\n\n\t\trxd = &rx_ring->rxds[idx];\n\t\tif (!(rxd->rxd.meta_len_dd & PCIE_DESC_RX_DD))\n\t\t\tbreak;\n\n\t\t \n\t\tdma_rmb();\n\n\t\tmemset(&meta, 0, sizeof(meta));\n\n\t\trx_ring->rd_p++;\n\t\tpkts_polled++;\n\n\t\trxbuf =\t&rx_ring->rxbufs[idx];\n\t\t \n\t\tmeta_len = rxd->rxd.meta_len_dd & PCIE_DESC_RX_META_LEN_MASK;\n\t\tdata_len = le16_to_cpu(rxd->rxd.data_len);\n\t\tpkt_len = data_len - meta_len;\n\n\t\tpkt_off = NFP_NET_RX_BUF_HEADROOM + dp->rx_dma_off;\n\t\tif (dp->rx_offset == NFP_NET_CFG_RX_OFFSET_DYNAMIC)\n\t\t\tpkt_off += meta_len;\n\t\telse\n\t\t\tpkt_off += dp->rx_offset;\n\t\tmeta_off = pkt_off - meta_len;\n\n\t\t \n\t\tu64_stats_update_begin(&r_vec->rx_sync);\n\t\tr_vec->rx_pkts++;\n\t\tr_vec->rx_bytes += pkt_len;\n\t\tu64_stats_update_end(&r_vec->rx_sync);\n\n\t\tif (unlikely(meta_len > NFP_NET_MAX_PREPEND ||\n\t\t\t     (dp->rx_offset && meta_len > dp->rx_offset))) {\n\t\t\tnn_dp_warn(dp, \"oversized RX packet metadata %u\\n\",\n\t\t\t\t   meta_len);\n\t\t\tnfp_nfdk_rx_drop(dp, r_vec, rx_ring, rxbuf, NULL);\n\t\t\tcontinue;\n\t\t}\n\n\t\tnfp_net_dma_sync_cpu_rx(dp, rxbuf->dma_addr + meta_off,\n\t\t\t\t\tdata_len);\n\n\t\tif (meta_len) {\n\t\t\tif (unlikely(nfp_nfdk_parse_meta(dp->netdev, &meta,\n\t\t\t\t\t\t\t rxbuf->frag + meta_off,\n\t\t\t\t\t\t\t rxbuf->frag + pkt_off,\n\t\t\t\t\t\t\t pkt_len, meta_len))) {\n\t\t\t\tnn_dp_warn(dp, \"invalid RX packet metadata\\n\");\n\t\t\t\tnfp_nfdk_rx_drop(dp, r_vec, rx_ring, rxbuf,\n\t\t\t\t\t\t NULL);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (xdp_prog && !meta.portid) {\n\t\t\tvoid *orig_data = rxbuf->frag + pkt_off;\n\t\t\tunsigned int dma_off;\n\t\t\tint act;\n\n\t\t\txdp_prepare_buff(&xdp,\n\t\t\t\t\t rxbuf->frag + NFP_NET_RX_BUF_HEADROOM,\n\t\t\t\t\t pkt_off - NFP_NET_RX_BUF_HEADROOM,\n\t\t\t\t\t pkt_len, true);\n\n\t\t\tact = bpf_prog_run_xdp(xdp_prog, &xdp);\n\n\t\t\tpkt_len = xdp.data_end - xdp.data;\n\t\t\tpkt_off += xdp.data - orig_data;\n\n\t\t\tswitch (act) {\n\t\t\tcase XDP_PASS:\n\t\t\t\tmeta_len_xdp = xdp.data - xdp.data_meta;\n\t\t\t\tbreak;\n\t\t\tcase XDP_TX:\n\t\t\t\tdma_off = pkt_off - NFP_NET_RX_BUF_HEADROOM;\n\t\t\t\tif (unlikely(!nfp_nfdk_tx_xdp_buf(dp, rx_ring,\n\t\t\t\t\t\t\t\t  tx_ring,\n\t\t\t\t\t\t\t\t  rxbuf,\n\t\t\t\t\t\t\t\t  dma_off,\n\t\t\t\t\t\t\t\t  pkt_len,\n\t\t\t\t\t\t\t\t  &xdp_tx_cmpl)))\n\t\t\t\t\ttrace_xdp_exception(dp->netdev,\n\t\t\t\t\t\t\t    xdp_prog, act);\n\t\t\t\tcontinue;\n\t\t\tdefault:\n\t\t\t\tbpf_warn_invalid_xdp_action(dp->netdev, xdp_prog, act);\n\t\t\t\tfallthrough;\n\t\t\tcase XDP_ABORTED:\n\t\t\t\ttrace_xdp_exception(dp->netdev, xdp_prog, act);\n\t\t\t\tfallthrough;\n\t\t\tcase XDP_DROP:\n\t\t\t\tnfp_nfdk_rx_give_one(dp, rx_ring, rxbuf->frag,\n\t\t\t\t\t\t     rxbuf->dma_addr);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (likely(!meta.portid)) {\n\t\t\tnetdev = dp->netdev;\n\t\t} else if (meta.portid == NFP_META_PORT_ID_CTRL) {\n\t\t\tstruct nfp_net *nn = netdev_priv(dp->netdev);\n\n\t\t\tnfp_app_ctrl_rx_raw(nn->app, rxbuf->frag + pkt_off,\n\t\t\t\t\t    pkt_len);\n\t\t\tnfp_nfdk_rx_give_one(dp, rx_ring, rxbuf->frag,\n\t\t\t\t\t     rxbuf->dma_addr);\n\t\t\tcontinue;\n\t\t} else {\n\t\t\tstruct nfp_net *nn;\n\n\t\t\tnn = netdev_priv(dp->netdev);\n\t\t\tnetdev = nfp_app_dev_get(nn->app, meta.portid,\n\t\t\t\t\t\t &redir_egress);\n\t\t\tif (unlikely(!netdev)) {\n\t\t\t\tnfp_nfdk_rx_drop(dp, r_vec, rx_ring, rxbuf,\n\t\t\t\t\t\t NULL);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (nfp_netdev_is_nfp_repr(netdev))\n\t\t\t\tnfp_repr_inc_rx_stats(netdev, pkt_len);\n\t\t}\n\n\t\tskb = build_skb(rxbuf->frag, true_bufsz);\n\t\tif (unlikely(!skb)) {\n\t\t\tnfp_nfdk_rx_drop(dp, r_vec, rx_ring, rxbuf, NULL);\n\t\t\tcontinue;\n\t\t}\n\t\tnew_frag = nfp_nfdk_napi_alloc_one(dp, &new_dma_addr);\n\t\tif (unlikely(!new_frag)) {\n\t\t\tnfp_nfdk_rx_drop(dp, r_vec, rx_ring, rxbuf, skb);\n\t\t\tcontinue;\n\t\t}\n\n\t\tnfp_net_dma_unmap_rx(dp, rxbuf->dma_addr);\n\n\t\tnfp_nfdk_rx_give_one(dp, rx_ring, new_frag, new_dma_addr);\n\n\t\tskb_reserve(skb, pkt_off);\n\t\tskb_put(skb, pkt_len);\n\n\t\tskb->mark = meta.mark;\n\t\tskb_set_hash(skb, meta.hash, meta.hash_type);\n\n\t\tskb_record_rx_queue(skb, rx_ring->idx);\n\t\tskb->protocol = eth_type_trans(skb, netdev);\n\n\t\tnfp_nfdk_rx_csum(dp, r_vec, rxd, &meta, skb);\n\n\t\tif (unlikely(!nfp_net_vlan_strip(skb, rxd, &meta))) {\n\t\t\tnfp_nfdk_rx_drop(dp, r_vec, rx_ring, NULL, skb);\n\t\t\tcontinue;\n\t\t}\n\n#ifdef CONFIG_NFP_NET_IPSEC\n\t\tif (meta.ipsec_saidx != 0 && unlikely(nfp_net_ipsec_rx(&meta, skb))) {\n\t\t\tnfp_nfdk_rx_drop(dp, r_vec, rx_ring, NULL, skb);\n\t\t\tcontinue;\n\t\t}\n#endif\n\n\t\tif (meta_len_xdp)\n\t\t\tskb_metadata_set(skb, meta_len_xdp);\n\n\t\tif (likely(!redir_egress)) {\n\t\t\tnapi_gro_receive(&rx_ring->r_vec->napi, skb);\n\t\t} else {\n\t\t\tskb->dev = netdev;\n\t\t\tskb_reset_network_header(skb);\n\t\t\t__skb_push(skb, ETH_HLEN);\n\t\t\tdev_queue_xmit(skb);\n\t\t}\n\t}\n\n\tif (xdp_prog) {\n\t\tif (tx_ring->wr_ptr_add)\n\t\t\tnfp_net_tx_xmit_more_flush(tx_ring);\n\t\telse if (unlikely(tx_ring->wr_p != tx_ring->rd_p) &&\n\t\t\t !xdp_tx_cmpl)\n\t\t\tif (!nfp_nfdk_xdp_complete(tx_ring))\n\t\t\t\tpkts_polled = budget;\n\t}\n\n\treturn pkts_polled;\n}\n\n \nint nfp_nfdk_poll(struct napi_struct *napi, int budget)\n{\n\tstruct nfp_net_r_vector *r_vec =\n\t\tcontainer_of(napi, struct nfp_net_r_vector, napi);\n\tunsigned int pkts_polled = 0;\n\n\tif (r_vec->tx_ring)\n\t\tnfp_nfdk_tx_complete(r_vec->tx_ring, budget);\n\tif (r_vec->rx_ring)\n\t\tpkts_polled = nfp_nfdk_rx(r_vec->rx_ring, budget);\n\n\tif (pkts_polled < budget)\n\t\tif (napi_complete_done(napi, pkts_polled))\n\t\t\tnfp_net_irq_unmask(r_vec->nfp_net, r_vec->irq_entry);\n\n\tif (r_vec->nfp_net->rx_coalesce_adapt_on && r_vec->rx_ring) {\n\t\tstruct dim_sample dim_sample = {};\n\t\tunsigned int start;\n\t\tu64 pkts, bytes;\n\n\t\tdo {\n\t\t\tstart = u64_stats_fetch_begin(&r_vec->rx_sync);\n\t\t\tpkts = r_vec->rx_pkts;\n\t\t\tbytes = r_vec->rx_bytes;\n\t\t} while (u64_stats_fetch_retry(&r_vec->rx_sync, start));\n\n\t\tdim_update_sample(r_vec->event_ctr, pkts, bytes, &dim_sample);\n\t\tnet_dim(&r_vec->rx_dim, dim_sample);\n\t}\n\n\tif (r_vec->nfp_net->tx_coalesce_adapt_on && r_vec->tx_ring) {\n\t\tstruct dim_sample dim_sample = {};\n\t\tunsigned int start;\n\t\tu64 pkts, bytes;\n\n\t\tdo {\n\t\t\tstart = u64_stats_fetch_begin(&r_vec->tx_sync);\n\t\t\tpkts = r_vec->tx_pkts;\n\t\t\tbytes = r_vec->tx_bytes;\n\t\t} while (u64_stats_fetch_retry(&r_vec->tx_sync, start));\n\n\t\tdim_update_sample(r_vec->event_ctr, pkts, bytes, &dim_sample);\n\t\tnet_dim(&r_vec->tx_dim, dim_sample);\n\t}\n\n\treturn pkts_polled;\n}\n\n \n\nbool\nnfp_nfdk_ctrl_tx_one(struct nfp_net *nn, struct nfp_net_r_vector *r_vec,\n\t\t     struct sk_buff *skb, bool old)\n{\n\tu32 cnt, tmp_dlen, dlen_type = 0;\n\tstruct nfp_net_tx_ring *tx_ring;\n\tstruct nfp_nfdk_tx_buf *txbuf;\n\tstruct nfp_nfdk_tx_desc *txd;\n\tunsigned int dma_len, type;\n\tstruct nfp_net_dp *dp;\n\tdma_addr_t dma_addr;\n\tu64 metadata = 0;\n\tint wr_idx;\n\n\tdp = &r_vec->nfp_net->dp;\n\ttx_ring = r_vec->tx_ring;\n\n\tif (WARN_ON_ONCE(skb_shinfo(skb)->nr_frags)) {\n\t\tnn_dp_warn(dp, \"Driver's CTRL TX does not implement gather\\n\");\n\t\tgoto err_free;\n\t}\n\n\t \n\tif (unlikely(nfp_net_tx_full(tx_ring, NFDK_TX_DESC_STOP_CNT))) {\n\t\tu64_stats_update_begin(&r_vec->tx_sync);\n\t\tr_vec->tx_busy++;\n\t\tu64_stats_update_end(&r_vec->tx_sync);\n\t\tif (!old)\n\t\t\t__skb_queue_tail(&r_vec->queue, skb);\n\t\telse\n\t\t\t__skb_queue_head(&r_vec->queue, skb);\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\n\tif (nfp_app_ctrl_has_meta(nn->app)) {\n\t\tif (unlikely(skb_headroom(skb) < 8)) {\n\t\t\tnn_dp_warn(dp, \"CTRL TX on skb without headroom\\n\");\n\t\t\tgoto err_free;\n\t\t}\n\t\tmetadata = NFDK_DESC_TX_CHAIN_META;\n\t\tput_unaligned_be32(NFP_META_PORT_ID_CTRL, skb_push(skb, 4));\n\t\tput_unaligned_be32(FIELD_PREP(NFDK_META_LEN, 8) |\n\t\t\t\t   FIELD_PREP(NFDK_META_FIELDS,\n\t\t\t\t\t      NFP_NET_META_PORTID),\n\t\t\t\t   skb_push(skb, 4));\n\t}\n\n\tif (nfp_nfdk_tx_maybe_close_block(tx_ring, skb))\n\t\tgoto err_free;\n\n\t \n\twr_idx = D_IDX(tx_ring, tx_ring->wr_p);\n\ttxd = &tx_ring->ktxds[wr_idx];\n\ttxbuf = &tx_ring->ktxbufs[wr_idx];\n\n\tdma_len = skb_headlen(skb);\n\tif (dma_len <= NFDK_TX_MAX_DATA_PER_HEAD)\n\t\ttype = NFDK_DESC_TX_TYPE_SIMPLE;\n\telse\n\t\ttype = NFDK_DESC_TX_TYPE_GATHER;\n\n\tdma_addr = dma_map_single(dp->dev, skb->data, dma_len, DMA_TO_DEVICE);\n\tif (dma_mapping_error(dp->dev, dma_addr))\n\t\tgoto err_warn_dma;\n\n\ttxbuf->skb = skb;\n\ttxbuf++;\n\n\ttxbuf->dma_addr = dma_addr;\n\ttxbuf++;\n\n\tdma_len -= 1;\n\tdlen_type = FIELD_PREP(NFDK_DESC_TX_DMA_LEN_HEAD,\n\t\t\t       dma_len > NFDK_DESC_TX_DMA_LEN_HEAD ?\n\t\t\t       NFDK_DESC_TX_DMA_LEN_HEAD : dma_len) |\n\t\t    FIELD_PREP(NFDK_DESC_TX_TYPE_HEAD, type);\n\n\ttxd->dma_len_type = cpu_to_le16(dlen_type);\n\tnfp_desc_set_dma_addr_48b(txd, dma_addr);\n\n\ttmp_dlen = dlen_type & NFDK_DESC_TX_DMA_LEN_HEAD;\n\tdma_len -= tmp_dlen;\n\tdma_addr += tmp_dlen + 1;\n\ttxd++;\n\n\twhile (dma_len > 0) {\n\t\tdma_len -= 1;\n\t\tdlen_type = FIELD_PREP(NFDK_DESC_TX_DMA_LEN, dma_len);\n\t\ttxd->dma_len_type = cpu_to_le16(dlen_type);\n\t\tnfp_desc_set_dma_addr_48b(txd, dma_addr);\n\n\t\tdlen_type &= NFDK_DESC_TX_DMA_LEN;\n\t\tdma_len -= dlen_type;\n\t\tdma_addr += dlen_type + 1;\n\t\ttxd++;\n\t}\n\n\t(txd - 1)->dma_len_type = cpu_to_le16(dlen_type | NFDK_DESC_TX_EOP);\n\n\t \n\ttxd->raw = cpu_to_le64(metadata);\n\ttxd++;\n\n\tcnt = txd - tx_ring->ktxds - wr_idx;\n\tif (unlikely(round_down(wr_idx, NFDK_TX_DESC_BLOCK_CNT) !=\n\t\t     round_down(wr_idx + cnt - 1, NFDK_TX_DESC_BLOCK_CNT)))\n\t\tgoto err_warn_overflow;\n\n\ttx_ring->wr_p += cnt;\n\tif (tx_ring->wr_p % NFDK_TX_DESC_BLOCK_CNT)\n\t\ttx_ring->data_pending += skb->len;\n\telse\n\t\ttx_ring->data_pending = 0;\n\n\ttx_ring->wr_ptr_add += cnt;\n\tnfp_net_tx_xmit_more_flush(tx_ring);\n\n\treturn NETDEV_TX_OK;\n\nerr_warn_overflow:\n\tWARN_ONCE(1, \"unable to fit packet into a descriptor wr_idx:%d head:%d frags:%d cnt:%d\",\n\t\t  wr_idx, skb_headlen(skb), 0, cnt);\n\ttxbuf--;\n\tdma_unmap_single(dp->dev, txbuf->dma_addr,\n\t\t\t skb_headlen(skb), DMA_TO_DEVICE);\n\ttxbuf->raw = 0;\nerr_warn_dma:\n\tnn_dp_warn(dp, \"Failed to map DMA TX buffer\\n\");\nerr_free:\n\tu64_stats_update_begin(&r_vec->tx_sync);\n\tr_vec->tx_errors++;\n\tu64_stats_update_end(&r_vec->tx_sync);\n\tdev_kfree_skb_any(skb);\n\treturn NETDEV_TX_OK;\n}\n\nstatic void __nfp_ctrl_tx_queued(struct nfp_net_r_vector *r_vec)\n{\n\tstruct sk_buff *skb;\n\n\twhile ((skb = __skb_dequeue(&r_vec->queue)))\n\t\tif (nfp_nfdk_ctrl_tx_one(r_vec->nfp_net, r_vec, skb, true))\n\t\t\treturn;\n}\n\nstatic bool\nnfp_ctrl_meta_ok(struct nfp_net *nn, void *data, unsigned int meta_len)\n{\n\tu32 meta_type, meta_tag;\n\n\tif (!nfp_app_ctrl_has_meta(nn->app))\n\t\treturn !meta_len;\n\n\tif (meta_len != 8)\n\t\treturn false;\n\n\tmeta_type = get_unaligned_be32(data);\n\tmeta_tag = get_unaligned_be32(data + 4);\n\n\treturn (meta_type == NFP_NET_META_PORTID &&\n\t\tmeta_tag == NFP_META_PORT_ID_CTRL);\n}\n\nstatic bool\nnfp_ctrl_rx_one(struct nfp_net *nn, struct nfp_net_dp *dp,\n\t\tstruct nfp_net_r_vector *r_vec, struct nfp_net_rx_ring *rx_ring)\n{\n\tunsigned int meta_len, data_len, meta_off, pkt_len, pkt_off;\n\tstruct nfp_net_rx_buf *rxbuf;\n\tstruct nfp_net_rx_desc *rxd;\n\tdma_addr_t new_dma_addr;\n\tstruct sk_buff *skb;\n\tvoid *new_frag;\n\tint idx;\n\n\tidx = D_IDX(rx_ring, rx_ring->rd_p);\n\n\trxd = &rx_ring->rxds[idx];\n\tif (!(rxd->rxd.meta_len_dd & PCIE_DESC_RX_DD))\n\t\treturn false;\n\n\t \n\tdma_rmb();\n\n\trx_ring->rd_p++;\n\n\trxbuf =\t&rx_ring->rxbufs[idx];\n\tmeta_len = rxd->rxd.meta_len_dd & PCIE_DESC_RX_META_LEN_MASK;\n\tdata_len = le16_to_cpu(rxd->rxd.data_len);\n\tpkt_len = data_len - meta_len;\n\n\tpkt_off = NFP_NET_RX_BUF_HEADROOM + dp->rx_dma_off;\n\tif (dp->rx_offset == NFP_NET_CFG_RX_OFFSET_DYNAMIC)\n\t\tpkt_off += meta_len;\n\telse\n\t\tpkt_off += dp->rx_offset;\n\tmeta_off = pkt_off - meta_len;\n\n\t \n\tu64_stats_update_begin(&r_vec->rx_sync);\n\tr_vec->rx_pkts++;\n\tr_vec->rx_bytes += pkt_len;\n\tu64_stats_update_end(&r_vec->rx_sync);\n\n\tnfp_net_dma_sync_cpu_rx(dp, rxbuf->dma_addr + meta_off,\tdata_len);\n\n\tif (unlikely(!nfp_ctrl_meta_ok(nn, rxbuf->frag + meta_off, meta_len))) {\n\t\tnn_dp_warn(dp, \"incorrect metadata for ctrl packet (%d)\\n\",\n\t\t\t   meta_len);\n\t\tnfp_nfdk_rx_drop(dp, r_vec, rx_ring, rxbuf, NULL);\n\t\treturn true;\n\t}\n\n\tskb = build_skb(rxbuf->frag, dp->fl_bufsz);\n\tif (unlikely(!skb)) {\n\t\tnfp_nfdk_rx_drop(dp, r_vec, rx_ring, rxbuf, NULL);\n\t\treturn true;\n\t}\n\tnew_frag = nfp_nfdk_napi_alloc_one(dp, &new_dma_addr);\n\tif (unlikely(!new_frag)) {\n\t\tnfp_nfdk_rx_drop(dp, r_vec, rx_ring, rxbuf, skb);\n\t\treturn true;\n\t}\n\n\tnfp_net_dma_unmap_rx(dp, rxbuf->dma_addr);\n\n\tnfp_nfdk_rx_give_one(dp, rx_ring, new_frag, new_dma_addr);\n\n\tskb_reserve(skb, pkt_off);\n\tskb_put(skb, pkt_len);\n\n\tnfp_app_ctrl_rx(nn->app, skb);\n\n\treturn true;\n}\n\nstatic bool nfp_ctrl_rx(struct nfp_net_r_vector *r_vec)\n{\n\tstruct nfp_net_rx_ring *rx_ring = r_vec->rx_ring;\n\tstruct nfp_net *nn = r_vec->nfp_net;\n\tstruct nfp_net_dp *dp = &nn->dp;\n\tunsigned int budget = 512;\n\n\twhile (nfp_ctrl_rx_one(nn, dp, r_vec, rx_ring) && budget--)\n\t\tcontinue;\n\n\treturn budget;\n}\n\nvoid nfp_nfdk_ctrl_poll(struct tasklet_struct *t)\n{\n\tstruct nfp_net_r_vector *r_vec = from_tasklet(r_vec, t, tasklet);\n\n\tspin_lock(&r_vec->lock);\n\tnfp_nfdk_tx_complete(r_vec->tx_ring, 0);\n\t__nfp_ctrl_tx_queued(r_vec);\n\tspin_unlock(&r_vec->lock);\n\n\tif (nfp_ctrl_rx(r_vec)) {\n\t\tnfp_net_irq_unmask(r_vec->nfp_net, r_vec->irq_entry);\n\t} else {\n\t\ttasklet_schedule(&r_vec->tasklet);\n\t\tnn_dp_warn(&r_vec->nfp_net->dp,\n\t\t\t   \"control message budget exceeded!\\n\");\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}