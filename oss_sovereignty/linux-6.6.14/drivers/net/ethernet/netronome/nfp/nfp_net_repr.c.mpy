{
  "module_name": "nfp_net_repr.c",
  "hash_id": "d9c8c1d5e5b4a3cd19ca93c715f0c3b026bc6cf56d06f31b2428044152542ade",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/netronome/nfp/nfp_net_repr.c",
  "human_readable_source": "\n \n\n#include <linux/etherdevice.h>\n#include <linux/io-64-nonatomic-hi-lo.h>\n#include <linux/lockdep.h>\n#include <net/dst_metadata.h>\n\n#include \"nfpcore/nfp_cpp.h\"\n#include \"nfpcore/nfp_nsp.h\"\n#include \"nfp_app.h\"\n#include \"nfp_main.h\"\n#include \"nfp_net.h\"\n#include \"nfp_net_ctrl.h\"\n#include \"nfp_net_repr.h\"\n#include \"nfp_net_sriov.h\"\n#include \"nfp_port.h\"\n\nstruct net_device *\nnfp_repr_get_locked(struct nfp_app *app, struct nfp_reprs *set, unsigned int id)\n{\n\treturn rcu_dereference_protected(set->reprs[id],\n\t\t\t\t\t nfp_app_is_locked(app));\n}\n\nstatic void\nnfp_repr_inc_tx_stats(struct net_device *netdev, unsigned int len,\n\t\t      int tx_status)\n{\n\tstruct nfp_repr *repr = netdev_priv(netdev);\n\tstruct nfp_repr_pcpu_stats *stats;\n\n\tif (unlikely(tx_status != NET_XMIT_SUCCESS &&\n\t\t     tx_status != NET_XMIT_CN)) {\n\t\tthis_cpu_inc(repr->stats->tx_drops);\n\t\treturn;\n\t}\n\n\tstats = this_cpu_ptr(repr->stats);\n\tu64_stats_update_begin(&stats->syncp);\n\tstats->tx_packets++;\n\tstats->tx_bytes += len;\n\tu64_stats_update_end(&stats->syncp);\n}\n\nvoid nfp_repr_inc_rx_stats(struct net_device *netdev, unsigned int len)\n{\n\tstruct nfp_repr *repr = netdev_priv(netdev);\n\tstruct nfp_repr_pcpu_stats *stats;\n\n\tstats = this_cpu_ptr(repr->stats);\n\tu64_stats_update_begin(&stats->syncp);\n\tstats->rx_packets++;\n\tstats->rx_bytes += len;\n\tu64_stats_update_end(&stats->syncp);\n}\n\nstatic void\nnfp_repr_phy_port_get_stats64(struct nfp_port *port,\n\t\t\t      struct rtnl_link_stats64 *stats)\n{\n\tu8 __iomem *mem = port->eth_stats;\n\n\tstats->tx_packets = readq(mem + NFP_MAC_STATS_TX_FRAMES_TRANSMITTED_OK);\n\tstats->tx_bytes = readq(mem + NFP_MAC_STATS_TX_OUT_OCTETS);\n\tstats->tx_dropped = readq(mem + NFP_MAC_STATS_TX_OUT_ERRORS);\n\n\tstats->rx_packets = readq(mem + NFP_MAC_STATS_RX_FRAMES_RECEIVED_OK);\n\tstats->rx_bytes = readq(mem + NFP_MAC_STATS_RX_IN_OCTETS);\n\tstats->rx_dropped = readq(mem + NFP_MAC_STATS_RX_IN_ERRORS);\n}\n\nstatic void\nnfp_repr_vnic_get_stats64(struct nfp_port *port,\n\t\t\t  struct rtnl_link_stats64 *stats)\n{\n\t \n\tstats->tx_packets = readq(port->vnic + NFP_NET_CFG_STATS_RX_FRAMES);\n\tstats->tx_bytes = readq(port->vnic + NFP_NET_CFG_STATS_RX_OCTETS);\n\tstats->tx_dropped = readq(port->vnic + NFP_NET_CFG_STATS_RX_DISCARDS);\n\n\tstats->rx_packets = readq(port->vnic + NFP_NET_CFG_STATS_TX_FRAMES);\n\tstats->rx_bytes = readq(port->vnic + NFP_NET_CFG_STATS_TX_OCTETS);\n\tstats->rx_dropped = readq(port->vnic + NFP_NET_CFG_STATS_TX_DISCARDS);\n}\n\nstatic void\nnfp_repr_get_stats64(struct net_device *netdev, struct rtnl_link_stats64 *stats)\n{\n\tstruct nfp_repr *repr = netdev_priv(netdev);\n\n\tif (WARN_ON(!repr->port))\n\t\treturn;\n\n\tswitch (repr->port->type) {\n\tcase NFP_PORT_PHYS_PORT:\n\t\tif (!__nfp_port_get_eth_port(repr->port))\n\t\t\tbreak;\n\t\tnfp_repr_phy_port_get_stats64(repr->port, stats);\n\t\tbreak;\n\tcase NFP_PORT_PF_PORT:\n\tcase NFP_PORT_VF_PORT:\n\t\tnfp_repr_vnic_get_stats64(repr->port, stats);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic bool\nnfp_repr_has_offload_stats(const struct net_device *dev, int attr_id)\n{\n\tswitch (attr_id) {\n\tcase IFLA_OFFLOAD_XSTATS_CPU_HIT:\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic int\nnfp_repr_get_host_stats64(const struct net_device *netdev,\n\t\t\t  struct rtnl_link_stats64 *stats)\n{\n\tstruct nfp_repr *repr = netdev_priv(netdev);\n\tint i;\n\n\tfor_each_possible_cpu(i) {\n\t\tu64 tbytes, tpkts, tdrops, rbytes, rpkts;\n\t\tstruct nfp_repr_pcpu_stats *repr_stats;\n\t\tunsigned int start;\n\n\t\trepr_stats = per_cpu_ptr(repr->stats, i);\n\t\tdo {\n\t\t\tstart = u64_stats_fetch_begin(&repr_stats->syncp);\n\t\t\ttbytes = repr_stats->tx_bytes;\n\t\t\ttpkts = repr_stats->tx_packets;\n\t\t\ttdrops = repr_stats->tx_drops;\n\t\t\trbytes = repr_stats->rx_bytes;\n\t\t\trpkts = repr_stats->rx_packets;\n\t\t} while (u64_stats_fetch_retry(&repr_stats->syncp, start));\n\n\t\tstats->tx_bytes += tbytes;\n\t\tstats->tx_packets += tpkts;\n\t\tstats->tx_dropped += tdrops;\n\t\tstats->rx_bytes += rbytes;\n\t\tstats->rx_packets += rpkts;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nnfp_repr_get_offload_stats(int attr_id, const struct net_device *dev,\n\t\t\t   void *stats)\n{\n\tswitch (attr_id) {\n\tcase IFLA_OFFLOAD_XSTATS_CPU_HIT:\n\t\treturn nfp_repr_get_host_stats64(dev, stats);\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int nfp_repr_change_mtu(struct net_device *netdev, int new_mtu)\n{\n\tstruct nfp_repr *repr = netdev_priv(netdev);\n\tint err;\n\n\terr = nfp_app_check_mtu(repr->app, netdev, new_mtu);\n\tif (err)\n\t\treturn err;\n\n\terr = nfp_app_repr_change_mtu(repr->app, netdev, new_mtu);\n\tif (err)\n\t\treturn err;\n\n\tnetdev->mtu = new_mtu;\n\n\treturn 0;\n}\n\nstatic netdev_tx_t nfp_repr_xmit(struct sk_buff *skb, struct net_device *netdev)\n{\n\tstruct nfp_repr *repr = netdev_priv(netdev);\n\tunsigned int len = skb->len;\n\tint ret;\n\n\tskb_dst_drop(skb);\n\tdst_hold((struct dst_entry *)repr->dst);\n\tskb_dst_set(skb, (struct dst_entry *)repr->dst);\n\tskb->dev = repr->dst->u.port_info.lower_dev;\n\n\tret = dev_queue_xmit(skb);\n\tnfp_repr_inc_tx_stats(netdev, len, ret);\n\n\treturn NETDEV_TX_OK;\n}\n\nstatic int nfp_repr_stop(struct net_device *netdev)\n{\n\tstruct nfp_repr *repr = netdev_priv(netdev);\n\tint err;\n\n\terr = nfp_app_repr_stop(repr->app, repr);\n\tif (err)\n\t\treturn err;\n\n\tnfp_port_configure(netdev, false);\n\treturn 0;\n}\n\nstatic int nfp_repr_open(struct net_device *netdev)\n{\n\tstruct nfp_repr *repr = netdev_priv(netdev);\n\tint err;\n\n\terr = nfp_port_configure(netdev, true);\n\tif (err)\n\t\treturn err;\n\n\terr = nfp_app_repr_open(repr->app, repr);\n\tif (err)\n\t\tgoto err_port_disable;\n\n\treturn 0;\n\nerr_port_disable:\n\tnfp_port_configure(netdev, false);\n\treturn err;\n}\n\nstatic netdev_features_t\nnfp_repr_fix_features(struct net_device *netdev, netdev_features_t features)\n{\n\tstruct nfp_repr *repr = netdev_priv(netdev);\n\tnetdev_features_t old_features = features;\n\tnetdev_features_t lower_features;\n\tstruct net_device *lower_dev;\n\n\tlower_dev = repr->dst->u.port_info.lower_dev;\n\n\tlower_features = lower_dev->features;\n\tif (lower_features & (NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM))\n\t\tlower_features |= NETIF_F_HW_CSUM;\n\n\tfeatures = netdev_intersect_features(features, lower_features);\n\tfeatures |= old_features & (NETIF_F_SOFT_FEATURES | NETIF_F_HW_TC);\n\tfeatures |= NETIF_F_LLTX;\n\n\treturn features;\n}\n\nconst struct net_device_ops nfp_repr_netdev_ops = {\n\t.ndo_init\t\t= nfp_app_ndo_init,\n\t.ndo_uninit\t\t= nfp_app_ndo_uninit,\n\t.ndo_open\t\t= nfp_repr_open,\n\t.ndo_stop\t\t= nfp_repr_stop,\n\t.ndo_start_xmit\t\t= nfp_repr_xmit,\n\t.ndo_change_mtu\t\t= nfp_repr_change_mtu,\n\t.ndo_get_stats64\t= nfp_repr_get_stats64,\n\t.ndo_has_offload_stats\t= nfp_repr_has_offload_stats,\n\t.ndo_get_offload_stats\t= nfp_repr_get_offload_stats,\n\t.ndo_get_phys_port_name\t= nfp_port_get_phys_port_name,\n\t.ndo_setup_tc\t\t= nfp_port_setup_tc,\n\t.ndo_set_vf_mac\t\t= nfp_app_set_vf_mac,\n\t.ndo_set_vf_vlan\t= nfp_app_set_vf_vlan,\n\t.ndo_set_vf_spoofchk\t= nfp_app_set_vf_spoofchk,\n\t.ndo_set_vf_trust\t= nfp_app_set_vf_trust,\n\t.ndo_get_vf_config\t= nfp_app_get_vf_config,\n\t.ndo_set_vf_link_state\t= nfp_app_set_vf_link_state,\n\t.ndo_fix_features\t= nfp_repr_fix_features,\n\t.ndo_set_features\t= nfp_port_set_features,\n\t.ndo_set_mac_address    = eth_mac_addr,\n\t.ndo_get_port_parent_id\t= nfp_port_get_port_parent_id,\n};\n\nvoid\nnfp_repr_transfer_features(struct net_device *netdev, struct net_device *lower)\n{\n\tstruct nfp_repr *repr = netdev_priv(netdev);\n\n\tif (repr->dst->u.port_info.lower_dev != lower)\n\t\treturn;\n\n\tnetif_inherit_tso_max(netdev, lower);\n\n\tnetdev_update_features(netdev);\n}\n\nstatic void nfp_repr_clean(struct nfp_repr *repr)\n{\n\tunregister_netdev(repr->netdev);\n\tnfp_app_repr_clean(repr->app, repr->netdev);\n\tdst_release((struct dst_entry *)repr->dst);\n\tnfp_port_free(repr->port);\n}\n\nstatic struct lock_class_key nfp_repr_netdev_xmit_lock_key;\n\nstatic void nfp_repr_set_lockdep_class_one(struct net_device *dev,\n\t\t\t\t\t   struct netdev_queue *txq,\n\t\t\t\t\t   void *_unused)\n{\n\tlockdep_set_class(&txq->_xmit_lock, &nfp_repr_netdev_xmit_lock_key);\n}\n\nstatic void nfp_repr_set_lockdep_class(struct net_device *dev)\n{\n\tnetdev_for_each_tx_queue(dev, nfp_repr_set_lockdep_class_one, NULL);\n}\n\nint nfp_repr_init(struct nfp_app *app, struct net_device *netdev,\n\t\t  u32 cmsg_port_id, struct nfp_port *port,\n\t\t  struct net_device *pf_netdev)\n{\n\tstruct nfp_repr *repr = netdev_priv(netdev);\n\tstruct nfp_net *nn = netdev_priv(pf_netdev);\n\tu32 repr_cap = nn->tlv_caps.repr_cap;\n\tint err;\n\n\tnfp_repr_set_lockdep_class(netdev);\n\n\trepr->port = port;\n\trepr->dst = metadata_dst_alloc(0, METADATA_HW_PORT_MUX, GFP_KERNEL);\n\tif (!repr->dst)\n\t\treturn -ENOMEM;\n\trepr->dst->u.port_info.port_id = cmsg_port_id;\n\trepr->dst->u.port_info.lower_dev = pf_netdev;\n\n\tnetdev->netdev_ops = &nfp_repr_netdev_ops;\n\tnetdev->ethtool_ops = &nfp_port_ethtool_ops;\n\n\tnetdev->max_mtu = pf_netdev->max_mtu;\n\n\t \n\tif (repr_cap & NFP_NET_CFG_CTRL_LIVE_ADDR)\n\t\tnetdev->priv_flags |= IFF_LIVE_ADDR_CHANGE;\n\n\tnetdev->hw_features = NETIF_F_HIGHDMA;\n\tif (repr_cap & NFP_NET_CFG_CTRL_RXCSUM_ANY)\n\t\tnetdev->hw_features |= NETIF_F_RXCSUM;\n\tif (repr_cap & NFP_NET_CFG_CTRL_TXCSUM)\n\t\tnetdev->hw_features |= NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM;\n\tif (repr_cap & NFP_NET_CFG_CTRL_GATHER)\n\t\tnetdev->hw_features |= NETIF_F_SG;\n\tif ((repr_cap & NFP_NET_CFG_CTRL_LSO && nn->fw_ver.major > 2) ||\n\t    repr_cap & NFP_NET_CFG_CTRL_LSO2)\n\t\tnetdev->hw_features |= NETIF_F_TSO | NETIF_F_TSO6;\n\tif (repr_cap & NFP_NET_CFG_CTRL_RSS_ANY)\n\t\tnetdev->hw_features |= NETIF_F_RXHASH;\n\tif (repr_cap & NFP_NET_CFG_CTRL_VXLAN) {\n\t\tif (repr_cap & NFP_NET_CFG_CTRL_LSO)\n\t\t\tnetdev->hw_features |= NETIF_F_GSO_UDP_TUNNEL;\n\t}\n\tif (repr_cap & NFP_NET_CFG_CTRL_NVGRE) {\n\t\tif (repr_cap & NFP_NET_CFG_CTRL_LSO)\n\t\t\tnetdev->hw_features |= NETIF_F_GSO_GRE;\n\t}\n\tif (repr_cap & (NFP_NET_CFG_CTRL_VXLAN | NFP_NET_CFG_CTRL_NVGRE))\n\t\tnetdev->hw_enc_features = netdev->hw_features;\n\n\tnetdev->vlan_features = netdev->hw_features;\n\n\tif (repr_cap & NFP_NET_CFG_CTRL_RXVLAN_ANY)\n\t\tnetdev->hw_features |= NETIF_F_HW_VLAN_CTAG_RX;\n\tif (repr_cap & NFP_NET_CFG_CTRL_TXVLAN_ANY) {\n\t\tif (repr_cap & NFP_NET_CFG_CTRL_LSO2)\n\t\t\tnetdev_warn(netdev, \"Device advertises both TSO2 and TXVLAN. Refusing to enable TXVLAN.\\n\");\n\t\telse\n\t\t\tnetdev->hw_features |= NETIF_F_HW_VLAN_CTAG_TX;\n\t}\n\tif (repr_cap & NFP_NET_CFG_CTRL_CTAG_FILTER)\n\t\tnetdev->hw_features |= NETIF_F_HW_VLAN_CTAG_FILTER;\n\tif (repr_cap & NFP_NET_CFG_CTRL_RXQINQ)\n\t\tnetdev->hw_features |= NETIF_F_HW_VLAN_STAG_RX;\n\n\tnetdev->features = netdev->hw_features;\n\n\t \n\tnetdev->features &= ~NETIF_F_HW_VLAN_STAG_RX;\n\tnetif_set_tso_max_segs(netdev, NFP_NET_LSO_MAX_SEGS);\n\n\tnetdev->priv_flags |= IFF_NO_QUEUE | IFF_DISABLE_NETPOLL;\n\tnetdev->features |= NETIF_F_LLTX;\n\n\tif (nfp_app_has_tc(app)) {\n\t\tnetdev->features |= NETIF_F_HW_TC;\n\t\tnetdev->hw_features |= NETIF_F_HW_TC;\n\t}\n\n\terr = nfp_app_repr_init(app, netdev);\n\tif (err)\n\t\tgoto err_clean;\n\n\terr = register_netdev(netdev);\n\tif (err)\n\t\tgoto err_repr_clean;\n\n\treturn 0;\n\nerr_repr_clean:\n\tnfp_app_repr_clean(app, netdev);\nerr_clean:\n\tdst_release((struct dst_entry *)repr->dst);\n\treturn err;\n}\n\nstatic void __nfp_repr_free(struct nfp_repr *repr)\n{\n\tfree_percpu(repr->stats);\n\tfree_netdev(repr->netdev);\n}\n\nvoid nfp_repr_free(struct net_device *netdev)\n{\n\t__nfp_repr_free(netdev_priv(netdev));\n}\n\nstruct net_device *\nnfp_repr_alloc_mqs(struct nfp_app *app, unsigned int txqs, unsigned int rxqs)\n{\n\tstruct net_device *netdev;\n\tstruct nfp_repr *repr;\n\n\tnetdev = alloc_etherdev_mqs(sizeof(*repr), txqs, rxqs);\n\tif (!netdev)\n\t\treturn NULL;\n\n\tnetif_carrier_off(netdev);\n\n\trepr = netdev_priv(netdev);\n\trepr->netdev = netdev;\n\trepr->app = app;\n\n\trepr->stats = netdev_alloc_pcpu_stats(struct nfp_repr_pcpu_stats);\n\tif (!repr->stats)\n\t\tgoto err_free_netdev;\n\n\treturn netdev;\n\nerr_free_netdev:\n\tfree_netdev(netdev);\n\treturn NULL;\n}\n\nvoid nfp_repr_clean_and_free(struct nfp_repr *repr)\n{\n\tnfp_info(repr->app->cpp, \"Destroying Representor(%s)\\n\",\n\t\t repr->netdev->name);\n\tnfp_repr_clean(repr);\n\t__nfp_repr_free(repr);\n}\n\nvoid nfp_reprs_clean_and_free(struct nfp_app *app, struct nfp_reprs *reprs)\n{\n\tstruct net_device *netdev;\n\tunsigned int i;\n\n\tfor (i = 0; i < reprs->num_reprs; i++) {\n\t\tnetdev = nfp_repr_get_locked(app, reprs, i);\n\t\tif (netdev)\n\t\t\tnfp_repr_clean_and_free(netdev_priv(netdev));\n\t}\n\n\tkfree(reprs);\n}\n\nvoid\nnfp_reprs_clean_and_free_by_type(struct nfp_app *app, enum nfp_repr_type type)\n{\n\tstruct net_device *netdev;\n\tstruct nfp_reprs *reprs;\n\tint i;\n\n\treprs = rcu_dereference_protected(app->reprs[type],\n\t\t\t\t\t  nfp_app_is_locked(app));\n\tif (!reprs)\n\t\treturn;\n\n\t \n\tfor (i = 0; i < reprs->num_reprs; i++) {\n\t\tnetdev = nfp_repr_get_locked(app, reprs, i);\n\t\tif (netdev)\n\t\t\tnfp_app_repr_preclean(app, netdev);\n\t}\n\n\treprs = nfp_app_reprs_set(app, type, NULL);\n\n\tsynchronize_rcu();\n\tnfp_reprs_clean_and_free(app, reprs);\n}\n\nstruct nfp_reprs *nfp_reprs_alloc(unsigned int num_reprs)\n{\n\tstruct nfp_reprs *reprs;\n\n\treprs = kzalloc(struct_size(reprs, reprs, num_reprs), GFP_KERNEL);\n\tif (!reprs)\n\t\treturn NULL;\n\treprs->num_reprs = num_reprs;\n\n\treturn reprs;\n}\n\nint nfp_reprs_resync_phys_ports(struct nfp_app *app)\n{\n\tstruct net_device *netdev;\n\tstruct nfp_reprs *reprs;\n\tstruct nfp_repr *repr;\n\tint i;\n\n\treprs = nfp_reprs_get_locked(app, NFP_REPR_TYPE_PHYS_PORT);\n\tif (!reprs)\n\t\treturn 0;\n\n\tfor (i = 0; i < reprs->num_reprs; i++) {\n\t\tnetdev = nfp_repr_get_locked(app, reprs, i);\n\t\tif (!netdev)\n\t\t\tcontinue;\n\n\t\trepr = netdev_priv(netdev);\n\t\tif (repr->port->type != NFP_PORT_INVALID)\n\t\t\tcontinue;\n\n\t\tnfp_app_repr_preclean(app, netdev);\n\t\trtnl_lock();\n\t\trcu_assign_pointer(reprs->reprs[i], NULL);\n\t\trtnl_unlock();\n\t\tsynchronize_rcu();\n\t\tnfp_repr_clean(repr);\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}