{
  "module_name": "nfp_hwmon.c",
  "hash_id": "84bef0a3f538a3ed5fc21f96fb58a0be60f54096b1cd7badf932ca795e1f9320",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/netronome/nfp/nfp_hwmon.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/bitops.h>\n#include <linux/hwmon.h>\n\n#include \"nfpcore/nfp_cpp.h\"\n#include \"nfpcore/nfp_nsp.h\"\n#include \"nfp_main.h\"\n\n#define NFP_TEMP_MAX\t\t(95 * 1000)\n#define NFP_TEMP_CRIT\t\t(105 * 1000)\n\n#define NFP_POWER_MAX\t\t(25 * 1000 * 1000)\n\nstatic int nfp_hwmon_sensor_id(enum hwmon_sensor_types type, int channel)\n{\n\tif (type == hwmon_temp)\n\t\treturn NFP_SENSOR_CHIP_TEMPERATURE;\n\tif (type == hwmon_power)\n\t\treturn NFP_SENSOR_ASSEMBLY_POWER + channel;\n\treturn -EINVAL;\n}\n\nstatic int\nnfp_hwmon_read(struct device *dev, enum hwmon_sensor_types type, u32 attr,\n\t       int channel, long *val)\n{\n\tstatic const struct {\n\t\tenum hwmon_sensor_types type;\n\t\tu32 attr;\n\t\tlong val;\n\t} const_vals[] = {\n\t\t{ hwmon_temp,\thwmon_temp_max,\t\tNFP_TEMP_MAX },\n\t\t{ hwmon_temp,\thwmon_temp_crit,\tNFP_TEMP_CRIT },\n\t\t{ hwmon_power,\thwmon_power_max,\tNFP_POWER_MAX },\n\t};\n\tstruct nfp_pf *pf = dev_get_drvdata(dev);\n\tenum nfp_nsp_sensor_id id;\n\tint err, i;\n\n\tfor (i = 0; i < ARRAY_SIZE(const_vals); i++)\n\t\tif (const_vals[i].type == type && const_vals[i].attr == attr) {\n\t\t\t*val = const_vals[i].val;\n\t\t\treturn 0;\n\t\t}\n\n\terr = nfp_hwmon_sensor_id(type, channel);\n\tif (err < 0)\n\t\treturn err;\n\tid = err;\n\n\tif (!(pf->nspi->sensor_mask & BIT(id)))\n\t\treturn -EOPNOTSUPP;\n\n\tif (type == hwmon_temp && attr == hwmon_temp_input)\n\t\treturn nfp_hwmon_read_sensor(pf->cpp, id, val);\n\tif (type == hwmon_power && attr == hwmon_power_input)\n\t\treturn nfp_hwmon_read_sensor(pf->cpp, id, val);\n\n\treturn -EINVAL;\n}\n\nstatic umode_t\nnfp_hwmon_is_visible(const void *data, enum hwmon_sensor_types type, u32 attr,\n\t\t     int channel)\n{\n\tif (type == hwmon_temp) {\n\t\tswitch (attr) {\n\t\tcase hwmon_temp_input:\n\t\tcase hwmon_temp_crit:\n\t\tcase hwmon_temp_max:\n\t\t\treturn 0444;\n\t\t}\n\t} else if (type == hwmon_power) {\n\t\tswitch (attr) {\n\t\tcase hwmon_power_input:\n\t\tcase hwmon_power_max:\n\t\t\treturn 0444;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic u32 nfp_chip_config[] = {\n\tHWMON_C_REGISTER_TZ,\n\t0\n};\n\nstatic const struct hwmon_channel_info nfp_chip = {\n\t.type = hwmon_chip,\n\t.config = nfp_chip_config,\n};\n\nstatic u32 nfp_temp_config[] = {\n\tHWMON_T_INPUT | HWMON_T_MAX | HWMON_T_CRIT,\n\t0\n};\n\nstatic const struct hwmon_channel_info nfp_temp = {\n\t.type = hwmon_temp,\n\t.config = nfp_temp_config,\n};\n\nstatic u32 nfp_power_config[] = {\n\tHWMON_P_INPUT | HWMON_P_MAX,\n\tHWMON_P_INPUT,\n\tHWMON_P_INPUT,\n\t0\n};\n\nstatic const struct hwmon_channel_info nfp_power = {\n\t.type = hwmon_power,\n\t.config = nfp_power_config,\n};\n\nstatic const struct hwmon_channel_info * const nfp_hwmon_info[] = {\n\t&nfp_chip,\n\t&nfp_temp,\n\t&nfp_power,\n\tNULL\n};\n\nstatic const struct hwmon_ops nfp_hwmon_ops = {\n\t.is_visible = nfp_hwmon_is_visible,\n\t.read = nfp_hwmon_read,\n};\n\nstatic const struct hwmon_chip_info nfp_chip_info = {\n\t.ops = &nfp_hwmon_ops,\n\t.info = nfp_hwmon_info,\n};\n\nint nfp_hwmon_register(struct nfp_pf *pf)\n{\n\tif (!IS_REACHABLE(CONFIG_HWMON))\n\t\treturn 0;\n\n\tif (!pf->nspi) {\n\t\tnfp_warn(pf->cpp, \"not registering HWMON (no NSP info)\\n\");\n\t\treturn 0;\n\t}\n\tif (!pf->nspi->sensor_mask) {\n\t\tnfp_info(pf->cpp,\n\t\t\t \"not registering HWMON (NSP doesn't report sensors)\\n\");\n\t\treturn 0;\n\t}\n\n\tpf->hwmon_dev = hwmon_device_register_with_info(&pf->pdev->dev, \"nfp\",\n\t\t\t\t\t\t\tpf, &nfp_chip_info,\n\t\t\t\t\t\t\tNULL);\n\treturn PTR_ERR_OR_ZERO(pf->hwmon_dev);\n}\n\nvoid nfp_hwmon_unregister(struct nfp_pf *pf)\n{\n\tif (!IS_REACHABLE(CONFIG_HWMON) || !pf->hwmon_dev)\n\t\treturn;\n\n\thwmon_device_unregister(pf->hwmon_dev);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}