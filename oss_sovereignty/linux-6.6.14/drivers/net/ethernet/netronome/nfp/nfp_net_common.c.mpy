{
  "module_name": "nfp_net_common.c",
  "hash_id": "bd69b2ec2bf939c9e6411faadf2a6e33d61b07a93a502e6dace271b4d799a68b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/netronome/nfp/nfp_net_common.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/bitfield.h>\n#include <linux/bpf.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/interrupt.h>\n#include <linux/ip.h>\n#include <linux/ipv6.h>\n#include <linux/mm.h>\n#include <linux/overflow.h>\n#include <linux/page_ref.h>\n#include <linux/pci.h>\n#include <linux/pci_regs.h>\n#include <linux/ethtool.h>\n#include <linux/log2.h>\n#include <linux/if_vlan.h>\n#include <linux/if_bridge.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/ktime.h>\n\n#include <net/tls.h>\n#include <net/vxlan.h>\n#include <net/xdp_sock_drv.h>\n#include <net/xfrm.h>\n\n#include \"nfpcore/nfp_dev.h\"\n#include \"nfpcore/nfp_nsp.h\"\n#include \"ccm.h\"\n#include \"nfp_app.h\"\n#include \"nfp_net_ctrl.h\"\n#include \"nfp_net.h\"\n#include \"nfp_net_dp.h\"\n#include \"nfp_net_sriov.h\"\n#include \"nfp_net_xsk.h\"\n#include \"nfp_port.h\"\n#include \"crypto/crypto.h\"\n#include \"crypto/fw.h\"\n\nstatic int nfp_net_mc_unsync(struct net_device *netdev, const unsigned char *addr);\n\n \nvoid nfp_net_get_fw_version(struct nfp_net_fw_version *fw_ver,\n\t\t\t    void __iomem *ctrl_bar)\n{\n\tu32 reg;\n\n\treg = readl(ctrl_bar + NFP_NET_CFG_VERSION);\n\tput_unaligned_le32(reg, fw_ver);\n}\n\nu32 nfp_qcp_queue_offset(const struct nfp_dev_info *dev_info, u16 queue)\n{\n\tqueue &= dev_info->qc_idx_mask;\n\treturn dev_info->qc_addr_offset + NFP_QCP_QUEUE_ADDR_SZ * queue;\n}\n\n \nstatic void nfp_net_reconfig_start(struct nfp_net *nn, u32 update)\n{\n\tnn_writel(nn, NFP_NET_CFG_UPDATE, update);\n\t \n\tnn_pci_flush(nn);\n\tnfp_qcp_wr_ptr_add(nn->qcp_cfg, 1);\n\tnn->reconfig_in_progress_update = update;\n}\n\n \nstatic void nfp_net_reconfig_start_async(struct nfp_net *nn, u32 update)\n{\n\tupdate |= nn->reconfig_posted;\n\tnn->reconfig_posted = 0;\n\n\tnfp_net_reconfig_start(nn, update);\n\n\tnn->reconfig_timer_active = true;\n\tmod_timer(&nn->reconfig_timer, jiffies + NFP_NET_POLL_TIMEOUT * HZ);\n}\n\nstatic bool nfp_net_reconfig_check_done(struct nfp_net *nn, bool last_check)\n{\n\tu32 reg;\n\n\treg = nn_readl(nn, NFP_NET_CFG_UPDATE);\n\tif (reg == 0)\n\t\treturn true;\n\tif (reg & NFP_NET_CFG_UPDATE_ERR) {\n\t\tnn_err(nn, \"Reconfig error (status: 0x%08x update: 0x%08x ctrl: 0x%08x)\\n\",\n\t\t       reg, nn->reconfig_in_progress_update,\n\t\t       nn_readl(nn, NFP_NET_CFG_CTRL));\n\t\treturn true;\n\t} else if (last_check) {\n\t\tnn_err(nn, \"Reconfig timeout (status: 0x%08x update: 0x%08x ctrl: 0x%08x)\\n\",\n\t\t       reg, nn->reconfig_in_progress_update,\n\t\t       nn_readl(nn, NFP_NET_CFG_CTRL));\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic bool __nfp_net_reconfig_wait(struct nfp_net *nn, unsigned long deadline)\n{\n\tbool timed_out = false;\n\tint i;\n\n\t \n\tfor (i = 0; i < 50; i++) {\n\t\tif (nfp_net_reconfig_check_done(nn, false))\n\t\t\treturn false;\n\t\tudelay(4);\n\t}\n\n\twhile (!nfp_net_reconfig_check_done(nn, timed_out)) {\n\t\tusleep_range(250, 500);\n\t\ttimed_out = time_is_before_eq_jiffies(deadline);\n\t}\n\n\treturn timed_out;\n}\n\nstatic int nfp_net_reconfig_wait(struct nfp_net *nn, unsigned long deadline)\n{\n\tif (__nfp_net_reconfig_wait(nn, deadline))\n\t\treturn -EIO;\n\n\tif (nn_readl(nn, NFP_NET_CFG_UPDATE) & NFP_NET_CFG_UPDATE_ERR)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic void nfp_net_reconfig_timer(struct timer_list *t)\n{\n\tstruct nfp_net *nn = from_timer(nn, t, reconfig_timer);\n\n\tspin_lock_bh(&nn->reconfig_lock);\n\n\tnn->reconfig_timer_active = false;\n\n\t \n\tif (nn->reconfig_sync_present)\n\t\tgoto done;\n\n\t \n\tnfp_net_reconfig_check_done(nn, true);\n\n\tif (nn->reconfig_posted)\n\t\tnfp_net_reconfig_start_async(nn, 0);\ndone:\n\tspin_unlock_bh(&nn->reconfig_lock);\n}\n\n \nstatic void nfp_net_reconfig_post(struct nfp_net *nn, u32 update)\n{\n\tspin_lock_bh(&nn->reconfig_lock);\n\n\t \n\tif (nn->reconfig_sync_present) {\n\t\tnn->reconfig_posted |= update;\n\t\tgoto done;\n\t}\n\n\t \n\tif (!nn->reconfig_timer_active ||\n\t    nfp_net_reconfig_check_done(nn, false))\n\t\tnfp_net_reconfig_start_async(nn, update);\n\telse\n\t\tnn->reconfig_posted |= update;\ndone:\n\tspin_unlock_bh(&nn->reconfig_lock);\n}\n\nstatic void nfp_net_reconfig_sync_enter(struct nfp_net *nn)\n{\n\tbool cancelled_timer = false;\n\tu32 pre_posted_requests;\n\n\tspin_lock_bh(&nn->reconfig_lock);\n\n\tWARN_ON(nn->reconfig_sync_present);\n\tnn->reconfig_sync_present = true;\n\n\tif (nn->reconfig_timer_active) {\n\t\tnn->reconfig_timer_active = false;\n\t\tcancelled_timer = true;\n\t}\n\tpre_posted_requests = nn->reconfig_posted;\n\tnn->reconfig_posted = 0;\n\n\tspin_unlock_bh(&nn->reconfig_lock);\n\n\tif (cancelled_timer) {\n\t\tdel_timer_sync(&nn->reconfig_timer);\n\t\tnfp_net_reconfig_wait(nn, nn->reconfig_timer.expires);\n\t}\n\n\t \n\tif (pre_posted_requests) {\n\t\tnfp_net_reconfig_start(nn, pre_posted_requests);\n\t\tnfp_net_reconfig_wait(nn, jiffies + HZ * NFP_NET_POLL_TIMEOUT);\n\t}\n}\n\nstatic void nfp_net_reconfig_wait_posted(struct nfp_net *nn)\n{\n\tnfp_net_reconfig_sync_enter(nn);\n\n\tspin_lock_bh(&nn->reconfig_lock);\n\tnn->reconfig_sync_present = false;\n\tspin_unlock_bh(&nn->reconfig_lock);\n}\n\n \nint __nfp_net_reconfig(struct nfp_net *nn, u32 update)\n{\n\tint ret;\n\n\tnfp_net_reconfig_sync_enter(nn);\n\n\tnfp_net_reconfig_start(nn, update);\n\tret = nfp_net_reconfig_wait(nn, jiffies + HZ * NFP_NET_POLL_TIMEOUT);\n\n\tspin_lock_bh(&nn->reconfig_lock);\n\n\tif (nn->reconfig_posted)\n\t\tnfp_net_reconfig_start_async(nn, 0);\n\n\tnn->reconfig_sync_present = false;\n\n\tspin_unlock_bh(&nn->reconfig_lock);\n\n\treturn ret;\n}\n\nint nfp_net_reconfig(struct nfp_net *nn, u32 update)\n{\n\tint ret;\n\n\tnn_ctrl_bar_lock(nn);\n\tret = __nfp_net_reconfig(nn, update);\n\tnn_ctrl_bar_unlock(nn);\n\n\treturn ret;\n}\n\nint nfp_net_mbox_lock(struct nfp_net *nn, unsigned int data_size)\n{\n\tif (nn->tlv_caps.mbox_len < NFP_NET_CFG_MBOX_SIMPLE_VAL + data_size) {\n\t\tnn_err(nn, \"mailbox too small for %u of data (%u)\\n\",\n\t\t       data_size, nn->tlv_caps.mbox_len);\n\t\treturn -EIO;\n\t}\n\n\tnn_ctrl_bar_lock(nn);\n\treturn 0;\n}\n\n \nint nfp_net_mbox_reconfig(struct nfp_net *nn, u32 mbox_cmd)\n{\n\tu32 mbox = nn->tlv_caps.mbox_off;\n\tint ret;\n\n\tnn_writeq(nn, mbox + NFP_NET_CFG_MBOX_SIMPLE_CMD, mbox_cmd);\n\n\tret = __nfp_net_reconfig(nn, NFP_NET_CFG_UPDATE_MBOX);\n\tif (ret) {\n\t\tnn_err(nn, \"Mailbox update error\\n\");\n\t\treturn ret;\n\t}\n\n\treturn -nn_readl(nn, mbox + NFP_NET_CFG_MBOX_SIMPLE_RET);\n}\n\nvoid nfp_net_mbox_reconfig_post(struct nfp_net *nn, u32 mbox_cmd)\n{\n\tu32 mbox = nn->tlv_caps.mbox_off;\n\n\tnn_writeq(nn, mbox + NFP_NET_CFG_MBOX_SIMPLE_CMD, mbox_cmd);\n\n\tnfp_net_reconfig_post(nn, NFP_NET_CFG_UPDATE_MBOX);\n}\n\nint nfp_net_mbox_reconfig_wait_posted(struct nfp_net *nn)\n{\n\tu32 mbox = nn->tlv_caps.mbox_off;\n\n\tnfp_net_reconfig_wait_posted(nn);\n\n\treturn -nn_readl(nn, mbox + NFP_NET_CFG_MBOX_SIMPLE_RET);\n}\n\nint nfp_net_mbox_reconfig_and_unlock(struct nfp_net *nn, u32 mbox_cmd)\n{\n\tint ret;\n\n\tret = nfp_net_mbox_reconfig(nn, mbox_cmd);\n\tnn_ctrl_bar_unlock(nn);\n\treturn ret;\n}\n\n \n\n \nunsigned int\nnfp_net_irqs_alloc(struct pci_dev *pdev, struct msix_entry *irq_entries,\n\t\t   unsigned int min_irqs, unsigned int wanted_irqs)\n{\n\tunsigned int i;\n\tint got_irqs;\n\n\tfor (i = 0; i < wanted_irqs; i++)\n\t\tirq_entries[i].entry = i;\n\n\tgot_irqs = pci_enable_msix_range(pdev, irq_entries,\n\t\t\t\t\t min_irqs, wanted_irqs);\n\tif (got_irqs < 0) {\n\t\tdev_err(&pdev->dev, \"Failed to enable %d-%d MSI-X (err=%d)\\n\",\n\t\t\tmin_irqs, wanted_irqs, got_irqs);\n\t\treturn 0;\n\t}\n\n\tif (got_irqs < wanted_irqs)\n\t\tdev_warn(&pdev->dev, \"Unable to allocate %d IRQs got only %d\\n\",\n\t\t\t wanted_irqs, got_irqs);\n\n\treturn got_irqs;\n}\n\n \nvoid\nnfp_net_irqs_assign(struct nfp_net *nn, struct msix_entry *irq_entries,\n\t\t    unsigned int n)\n{\n\tstruct nfp_net_dp *dp = &nn->dp;\n\n\tnn->max_r_vecs = n - NFP_NET_NON_Q_VECTORS;\n\tdp->num_r_vecs = nn->max_r_vecs;\n\n\tmemcpy(nn->irq_entries, irq_entries, sizeof(*irq_entries) * n);\n\n\tif (dp->num_rx_rings > dp->num_r_vecs ||\n\t    dp->num_tx_rings > dp->num_r_vecs)\n\t\tdev_warn(nn->dp.dev, \"More rings (%d,%d) than vectors (%d).\\n\",\n\t\t\t dp->num_rx_rings, dp->num_tx_rings,\n\t\t\t dp->num_r_vecs);\n\n\tdp->num_rx_rings = min(dp->num_r_vecs, dp->num_rx_rings);\n\tdp->num_tx_rings = min(dp->num_r_vecs, dp->num_tx_rings);\n\tdp->num_stack_tx_rings = dp->num_tx_rings;\n}\n\n \nvoid nfp_net_irqs_disable(struct pci_dev *pdev)\n{\n\tpci_disable_msix(pdev);\n}\n\n \nstatic irqreturn_t nfp_net_irq_rxtx(int irq, void *data)\n{\n\tstruct nfp_net_r_vector *r_vec = data;\n\n\t \n\tr_vec->event_ctr++;\n\n\tnapi_schedule_irqoff(&r_vec->napi);\n\n\t \n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t nfp_ctrl_irq_rxtx(int irq, void *data)\n{\n\tstruct nfp_net_r_vector *r_vec = data;\n\n\ttasklet_schedule(&r_vec->tasklet);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic void nfp_net_read_link_status(struct nfp_net *nn)\n{\n\tunsigned long flags;\n\tbool link_up;\n\tu16 sts;\n\n\tspin_lock_irqsave(&nn->link_status_lock, flags);\n\n\tsts = nn_readw(nn, NFP_NET_CFG_STS);\n\tlink_up = !!(sts & NFP_NET_CFG_STS_LINK);\n\n\tif (nn->link_up == link_up)\n\t\tgoto out;\n\n\tnn->link_up = link_up;\n\tif (nn->port) {\n\t\tset_bit(NFP_PORT_CHANGED, &nn->port->flags);\n\t\tif (nn->port->link_cb)\n\t\t\tnn->port->link_cb(nn->port);\n\t}\n\n\tif (nn->link_up) {\n\t\tnetif_carrier_on(nn->dp.netdev);\n\t\tnetdev_info(nn->dp.netdev, \"NIC Link is Up\\n\");\n\t} else {\n\t\tnetif_carrier_off(nn->dp.netdev);\n\t\tnetdev_info(nn->dp.netdev, \"NIC Link is Down\\n\");\n\t}\nout:\n\tspin_unlock_irqrestore(&nn->link_status_lock, flags);\n}\n\n \nstatic irqreturn_t nfp_net_irq_lsc(int irq, void *data)\n{\n\tstruct nfp_net *nn = data;\n\tstruct msix_entry *entry;\n\n\tentry = &nn->irq_entries[NFP_NET_IRQ_LSC_IDX];\n\n\tnfp_net_read_link_status(nn);\n\n\tnfp_net_irq_unmask(nn, entry->entry);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic irqreturn_t nfp_net_irq_exn(int irq, void *data)\n{\n\tstruct nfp_net *nn = data;\n\n\tnn_err(nn, \"%s: UNIMPLEMENTED.\\n\", __func__);\n\t \n\treturn IRQ_HANDLED;\n}\n\n \nstatic int\nnfp_net_aux_irq_request(struct nfp_net *nn, u32 ctrl_offset,\n\t\t\tconst char *format, char *name, size_t name_sz,\n\t\t\tunsigned int vector_idx, irq_handler_t handler)\n{\n\tstruct msix_entry *entry;\n\tint err;\n\n\tentry = &nn->irq_entries[vector_idx];\n\n\tsnprintf(name, name_sz, format, nfp_net_name(nn));\n\terr = request_irq(entry->vector, handler, 0, name, nn);\n\tif (err) {\n\t\tnn_err(nn, \"Failed to request IRQ %d (err=%d).\\n\",\n\t\t       entry->vector, err);\n\t\treturn err;\n\t}\n\tnn_writeb(nn, ctrl_offset, entry->entry);\n\tnfp_net_irq_unmask(nn, entry->entry);\n\n\treturn 0;\n}\n\n \nstatic void nfp_net_aux_irq_free(struct nfp_net *nn, u32 ctrl_offset,\n\t\t\t\t unsigned int vector_idx)\n{\n\tnn_writeb(nn, ctrl_offset, 0xff);\n\tnn_pci_flush(nn);\n\tfree_irq(nn->irq_entries[vector_idx].vector, nn);\n}\n\nstruct sk_buff *\nnfp_net_tls_tx(struct nfp_net_dp *dp, struct nfp_net_r_vector *r_vec,\n\t       struct sk_buff *skb, u64 *tls_handle, int *nr_frags)\n{\n#ifdef CONFIG_TLS_DEVICE\n\tstruct nfp_net_tls_offload_ctx *ntls;\n\tstruct sk_buff *nskb;\n\tbool resync_pending;\n\tu32 datalen, seq;\n\n\tif (likely(!dp->ktls_tx))\n\t\treturn skb;\n\tif (!tls_is_skb_tx_device_offloaded(skb))\n\t\treturn skb;\n\n\tdatalen = skb->len - skb_tcp_all_headers(skb);\n\tseq = ntohl(tcp_hdr(skb)->seq);\n\tntls = tls_driver_ctx(skb->sk, TLS_OFFLOAD_CTX_DIR_TX);\n\tresync_pending = tls_offload_tx_resync_pending(skb->sk);\n\tif (unlikely(resync_pending || ntls->next_seq != seq)) {\n\t\t \n\t\tif (!datalen)\n\t\t\treturn skb;\n\n\t\tu64_stats_update_begin(&r_vec->tx_sync);\n\t\tr_vec->tls_tx_fallback++;\n\t\tu64_stats_update_end(&r_vec->tx_sync);\n\n\t\tnskb = tls_encrypt_skb(skb);\n\t\tif (!nskb) {\n\t\t\tu64_stats_update_begin(&r_vec->tx_sync);\n\t\t\tr_vec->tls_tx_no_fallback++;\n\t\t\tu64_stats_update_end(&r_vec->tx_sync);\n\t\t\treturn NULL;\n\t\t}\n\t\t \n\t\tif (nskb == skb)\n\t\t\treturn skb;\n\t\t \n\t\tif (unlikely(skb_is_nonlinear(nskb))) {\n\t\t\tnn_dp_warn(dp, \"tls_encrypt_skb() produced fragmented frame\\n\");\n\t\t\tu64_stats_update_begin(&r_vec->tx_sync);\n\t\t\tr_vec->tx_errors++;\n\t\t\tu64_stats_update_end(&r_vec->tx_sync);\n\t\t\tdev_kfree_skb_any(nskb);\n\t\t\treturn NULL;\n\t\t}\n\n\t\t \n\t\tif (!resync_pending && seq - ntls->next_seq < U32_MAX / 4)\n\t\t\ttls_offload_tx_resync_request(nskb->sk, seq,\n\t\t\t\t\t\t      ntls->next_seq);\n\n\t\t*nr_frags = 0;\n\t\treturn nskb;\n\t}\n\n\tif (datalen) {\n\t\tu64_stats_update_begin(&r_vec->tx_sync);\n\t\tif (!skb_is_gso(skb))\n\t\t\tr_vec->hw_tls_tx++;\n\t\telse\n\t\t\tr_vec->hw_tls_tx += skb_shinfo(skb)->gso_segs;\n\t\tu64_stats_update_end(&r_vec->tx_sync);\n\t}\n\n\tmemcpy(tls_handle, ntls->fw_handle, sizeof(ntls->fw_handle));\n\tntls->next_seq += datalen;\n#endif\n\treturn skb;\n}\n\nvoid nfp_net_tls_tx_undo(struct sk_buff *skb, u64 tls_handle)\n{\n#ifdef CONFIG_TLS_DEVICE\n\tstruct nfp_net_tls_offload_ctx *ntls;\n\tu32 datalen, seq;\n\n\tif (!tls_handle)\n\t\treturn;\n\tif (WARN_ON_ONCE(!tls_is_skb_tx_device_offloaded(skb)))\n\t\treturn;\n\n\tdatalen = skb->len - skb_tcp_all_headers(skb);\n\tseq = ntohl(tcp_hdr(skb)->seq);\n\n\tntls = tls_driver_ctx(skb->sk, TLS_OFFLOAD_CTX_DIR_TX);\n\tif (ntls->next_seq == seq + datalen)\n\t\tntls->next_seq = seq;\n\telse\n\t\tWARN_ON_ONCE(1);\n#endif\n}\n\nstatic void nfp_net_tx_timeout(struct net_device *netdev, unsigned int txqueue)\n{\n\tstruct nfp_net *nn = netdev_priv(netdev);\n\n\tnn_warn(nn, \"TX watchdog timeout on ring: %u\\n\", txqueue);\n}\n\n \nstatic unsigned int\nnfp_net_calc_fl_bufsz_data(struct nfp_net_dp *dp)\n{\n\tunsigned int fl_bufsz = 0;\n\n\tif (dp->rx_offset == NFP_NET_CFG_RX_OFFSET_DYNAMIC)\n\t\tfl_bufsz += NFP_NET_MAX_PREPEND;\n\telse\n\t\tfl_bufsz += dp->rx_offset;\n\tfl_bufsz += ETH_HLEN + VLAN_HLEN * 2 + dp->mtu;\n\n\treturn fl_bufsz;\n}\n\nstatic unsigned int nfp_net_calc_fl_bufsz(struct nfp_net_dp *dp)\n{\n\tunsigned int fl_bufsz;\n\n\tfl_bufsz = NFP_NET_RX_BUF_HEADROOM;\n\tfl_bufsz += dp->rx_dma_off;\n\tfl_bufsz += nfp_net_calc_fl_bufsz_data(dp);\n\n\tfl_bufsz = SKB_DATA_ALIGN(fl_bufsz);\n\tfl_bufsz += SKB_DATA_ALIGN(sizeof(struct skb_shared_info));\n\n\treturn fl_bufsz;\n}\n\nstatic unsigned int nfp_net_calc_fl_bufsz_xsk(struct nfp_net_dp *dp)\n{\n\tunsigned int fl_bufsz;\n\n\tfl_bufsz = XDP_PACKET_HEADROOM;\n\tfl_bufsz += nfp_net_calc_fl_bufsz_data(dp);\n\n\treturn fl_bufsz;\n}\n\n \n\n \nstatic void nfp_net_vecs_init(struct nfp_net *nn)\n{\n\tint numa_node = dev_to_node(&nn->pdev->dev);\n\tstruct nfp_net_r_vector *r_vec;\n\tunsigned int r;\n\n\tnn->lsc_handler = nfp_net_irq_lsc;\n\tnn->exn_handler = nfp_net_irq_exn;\n\n\tfor (r = 0; r < nn->max_r_vecs; r++) {\n\t\tstruct msix_entry *entry;\n\n\t\tentry = &nn->irq_entries[NFP_NET_NON_Q_VECTORS + r];\n\n\t\tr_vec = &nn->r_vecs[r];\n\t\tr_vec->nfp_net = nn;\n\t\tr_vec->irq_entry = entry->entry;\n\t\tr_vec->irq_vector = entry->vector;\n\n\t\tif (nn->dp.netdev) {\n\t\t\tr_vec->handler = nfp_net_irq_rxtx;\n\t\t} else {\n\t\t\tr_vec->handler = nfp_ctrl_irq_rxtx;\n\n\t\t\t__skb_queue_head_init(&r_vec->queue);\n\t\t\tspin_lock_init(&r_vec->lock);\n\t\t\ttasklet_setup(&r_vec->tasklet, nn->dp.ops->ctrl_poll);\n\t\t\ttasklet_disable(&r_vec->tasklet);\n\t\t}\n\n\t\tcpumask_set_cpu(cpumask_local_spread(r, numa_node), &r_vec->affinity_mask);\n\t}\n}\n\nstatic void\nnfp_net_napi_add(struct nfp_net_dp *dp, struct nfp_net_r_vector *r_vec, int idx)\n{\n\tif (dp->netdev)\n\t\tnetif_napi_add(dp->netdev, &r_vec->napi,\n\t\t\t       nfp_net_has_xsk_pool_slow(dp, idx) ? dp->ops->xsk_poll : dp->ops->poll);\n\telse\n\t\ttasklet_enable(&r_vec->tasklet);\n}\n\nstatic void\nnfp_net_napi_del(struct nfp_net_dp *dp, struct nfp_net_r_vector *r_vec)\n{\n\tif (dp->netdev)\n\t\tnetif_napi_del(&r_vec->napi);\n\telse\n\t\ttasklet_disable(&r_vec->tasklet);\n}\n\nstatic void\nnfp_net_vector_assign_rings(struct nfp_net_dp *dp,\n\t\t\t    struct nfp_net_r_vector *r_vec, int idx)\n{\n\tr_vec->rx_ring = idx < dp->num_rx_rings ? &dp->rx_rings[idx] : NULL;\n\tr_vec->tx_ring =\n\t\tidx < dp->num_stack_tx_rings ? &dp->tx_rings[idx] : NULL;\n\n\tr_vec->xdp_ring = idx < dp->num_tx_rings - dp->num_stack_tx_rings ?\n\t\t&dp->tx_rings[dp->num_stack_tx_rings + idx] : NULL;\n\n\tif (nfp_net_has_xsk_pool_slow(dp, idx) || r_vec->xsk_pool) {\n\t\tr_vec->xsk_pool = dp->xdp_prog ? dp->xsk_pools[idx] : NULL;\n\n\t\tif (r_vec->xsk_pool)\n\t\t\txsk_pool_set_rxq_info(r_vec->xsk_pool,\n\t\t\t\t\t      &r_vec->rx_ring->xdp_rxq);\n\n\t\tnfp_net_napi_del(dp, r_vec);\n\t\tnfp_net_napi_add(dp, r_vec, idx);\n\t}\n}\n\nstatic int\nnfp_net_prepare_vector(struct nfp_net *nn, struct nfp_net_r_vector *r_vec,\n\t\t       int idx)\n{\n\tint err;\n\n\tnfp_net_napi_add(&nn->dp, r_vec, idx);\n\n\tsnprintf(r_vec->name, sizeof(r_vec->name),\n\t\t \"%s-rxtx-%d\", nfp_net_name(nn), idx);\n\terr = request_irq(r_vec->irq_vector, r_vec->handler, 0, r_vec->name,\n\t\t\t  r_vec);\n\tif (err) {\n\t\tnfp_net_napi_del(&nn->dp, r_vec);\n\t\tnn_err(nn, \"Error requesting IRQ %d\\n\", r_vec->irq_vector);\n\t\treturn err;\n\t}\n\tdisable_irq(r_vec->irq_vector);\n\n\tirq_set_affinity_hint(r_vec->irq_vector, &r_vec->affinity_mask);\n\n\tnn_dbg(nn, \"RV%02d: irq=%03d/%03d\\n\", idx, r_vec->irq_vector,\n\t       r_vec->irq_entry);\n\n\treturn 0;\n}\n\nstatic void\nnfp_net_cleanup_vector(struct nfp_net *nn, struct nfp_net_r_vector *r_vec)\n{\n\tirq_set_affinity_hint(r_vec->irq_vector, NULL);\n\tnfp_net_napi_del(&nn->dp, r_vec);\n\tfree_irq(r_vec->irq_vector, r_vec);\n}\n\n \nvoid nfp_net_rss_write_itbl(struct nfp_net *nn)\n{\n\tint i;\n\n\tfor (i = 0; i < NFP_NET_CFG_RSS_ITBL_SZ; i += 4)\n\t\tnn_writel(nn, NFP_NET_CFG_RSS_ITBL + i,\n\t\t\t  get_unaligned_le32(nn->rss_itbl + i));\n}\n\n \nvoid nfp_net_rss_write_key(struct nfp_net *nn)\n{\n\tint i;\n\n\tfor (i = 0; i < nfp_net_rss_key_sz(nn); i += 4)\n\t\tnn_writel(nn, NFP_NET_CFG_RSS_KEY + i,\n\t\t\t  get_unaligned_le32(nn->rss_key + i));\n}\n\n \nvoid nfp_net_coalesce_write_cfg(struct nfp_net *nn)\n{\n\tu8 i;\n\tu32 factor;\n\tu32 value;\n\n\t \n\tfactor = nn->tlv_caps.me_freq_mhz / 16;\n\n\t \n\tvalue = (nn->rx_coalesce_max_frames << 16) |\n\t\t(factor * nn->rx_coalesce_usecs);\n\tfor (i = 0; i < nn->dp.num_rx_rings; i++)\n\t\tnn_writel(nn, NFP_NET_CFG_RXR_IRQ_MOD(i), value);\n\n\t \n\tvalue = (nn->tx_coalesce_max_frames << 16) |\n\t\t(factor * nn->tx_coalesce_usecs);\n\tfor (i = 0; i < nn->dp.num_tx_rings; i++)\n\t\tnn_writel(nn, NFP_NET_CFG_TXR_IRQ_MOD(i), value);\n}\n\n \nstatic void nfp_net_write_mac_addr(struct nfp_net *nn, const u8 *addr)\n{\n\tnn_writel(nn, NFP_NET_CFG_MACADDR + 0, get_unaligned_be32(addr));\n\tnn_writew(nn, NFP_NET_CFG_MACADDR + 6, get_unaligned_be16(addr + 4));\n}\n\n \nstatic void nfp_net_clear_config_and_disable(struct nfp_net *nn)\n{\n\tu32 new_ctrl, new_ctrl_w1, update;\n\tunsigned int r;\n\tint err;\n\n\tnew_ctrl = nn->dp.ctrl;\n\tnew_ctrl &= ~NFP_NET_CFG_CTRL_ENABLE;\n\tupdate = NFP_NET_CFG_UPDATE_GEN;\n\tupdate |= NFP_NET_CFG_UPDATE_MSIX;\n\tupdate |= NFP_NET_CFG_UPDATE_RING;\n\n\tif (nn->cap & NFP_NET_CFG_CTRL_RINGCFG)\n\t\tnew_ctrl &= ~NFP_NET_CFG_CTRL_RINGCFG;\n\n\tif (!(nn->cap_w1 & NFP_NET_CFG_CTRL_FREELIST_EN)) {\n\t\tnn_writeq(nn, NFP_NET_CFG_TXRS_ENABLE, 0);\n\t\tnn_writeq(nn, NFP_NET_CFG_RXRS_ENABLE, 0);\n\t}\n\n\tnn_writel(nn, NFP_NET_CFG_CTRL, new_ctrl);\n\terr = nfp_net_reconfig(nn, update);\n\tif (err)\n\t\tnn_err(nn, \"Could not disable device: %d\\n\", err);\n\n\tif (nn->cap_w1 & NFP_NET_CFG_CTRL_FREELIST_EN) {\n\t\tnew_ctrl_w1 = nn->dp.ctrl_w1;\n\t\tnew_ctrl_w1 &= ~NFP_NET_CFG_CTRL_FREELIST_EN;\n\t\tnn_writeq(nn, NFP_NET_CFG_TXRS_ENABLE, 0);\n\t\tnn_writeq(nn, NFP_NET_CFG_RXRS_ENABLE, 0);\n\n\t\tnn_writel(nn, NFP_NET_CFG_CTRL_WORD1, new_ctrl_w1);\n\t\terr = nfp_net_reconfig(nn, update);\n\t\tif (err)\n\t\t\tnn_err(nn, \"Could not disable FREELIST_EN: %d\\n\", err);\n\t\tnn->dp.ctrl_w1 = new_ctrl_w1;\n\t}\n\n\tfor (r = 0; r < nn->dp.num_rx_rings; r++) {\n\t\tnfp_net_rx_ring_reset(&nn->dp.rx_rings[r]);\n\t\tif (nfp_net_has_xsk_pool_slow(&nn->dp, nn->dp.rx_rings[r].idx))\n\t\t\tnfp_net_xsk_rx_bufs_free(&nn->dp.rx_rings[r]);\n\t}\n\tfor (r = 0; r < nn->dp.num_tx_rings; r++)\n\t\tnfp_net_tx_ring_reset(&nn->dp, &nn->dp.tx_rings[r]);\n\tfor (r = 0; r < nn->dp.num_r_vecs; r++)\n\t\tnfp_net_vec_clear_ring_data(nn, r);\n\n\tnn->dp.ctrl = new_ctrl;\n}\n\n \nstatic int nfp_net_set_config_and_enable(struct nfp_net *nn)\n{\n\tu32 bufsz, new_ctrl, new_ctrl_w1, update = 0;\n\tunsigned int r;\n\tint err;\n\n\tnew_ctrl = nn->dp.ctrl;\n\tnew_ctrl_w1 = nn->dp.ctrl_w1;\n\n\tif (nn->dp.ctrl & NFP_NET_CFG_CTRL_RSS_ANY) {\n\t\tnfp_net_rss_write_key(nn);\n\t\tnfp_net_rss_write_itbl(nn);\n\t\tnn_writel(nn, NFP_NET_CFG_RSS_CTRL, nn->rss_cfg);\n\t\tupdate |= NFP_NET_CFG_UPDATE_RSS;\n\t}\n\n\tif (nn->dp.ctrl & NFP_NET_CFG_CTRL_IRQMOD) {\n\t\tnfp_net_coalesce_write_cfg(nn);\n\t\tupdate |= NFP_NET_CFG_UPDATE_IRQMOD;\n\t}\n\n\tfor (r = 0; r < nn->dp.num_tx_rings; r++)\n\t\tnfp_net_tx_ring_hw_cfg_write(nn, &nn->dp.tx_rings[r], r);\n\tfor (r = 0; r < nn->dp.num_rx_rings; r++)\n\t\tnfp_net_rx_ring_hw_cfg_write(nn, &nn->dp.rx_rings[r], r);\n\n\tnn_writeq(nn, NFP_NET_CFG_TXRS_ENABLE,\n\t\t  U64_MAX >> (64 - nn->dp.num_tx_rings));\n\n\tnn_writeq(nn, NFP_NET_CFG_RXRS_ENABLE,\n\t\t  U64_MAX >> (64 - nn->dp.num_rx_rings));\n\n\tif (nn->dp.netdev)\n\t\tnfp_net_write_mac_addr(nn, nn->dp.netdev->dev_addr);\n\n\tnn_writel(nn, NFP_NET_CFG_MTU, nn->dp.mtu);\n\n\tbufsz = nn->dp.fl_bufsz - nn->dp.rx_dma_off - NFP_NET_RX_BUF_NON_DATA;\n\tnn_writel(nn, NFP_NET_CFG_FLBUFSZ, bufsz);\n\n\t \n\tif (nn->cap_w1 & NFP_NET_CFG_CTRL_FREELIST_EN)\n\t\tnew_ctrl_w1 |= NFP_NET_CFG_CTRL_FREELIST_EN;\n\telse\n\t\tnew_ctrl |= NFP_NET_CFG_CTRL_ENABLE;\n\tupdate |= NFP_NET_CFG_UPDATE_GEN;\n\tupdate |= NFP_NET_CFG_UPDATE_MSIX;\n\tupdate |= NFP_NET_CFG_UPDATE_RING;\n\tif (nn->cap & NFP_NET_CFG_CTRL_RINGCFG)\n\t\tnew_ctrl |= NFP_NET_CFG_CTRL_RINGCFG;\n\n\t \n\tnn_writel(nn, NFP_NET_CFG_CTRL, new_ctrl);\n\tnn_writel(nn, NFP_NET_CFG_CTRL_WORD1, new_ctrl_w1);\n\terr = nfp_net_reconfig(nn, update);\n\tif (err) {\n\t\tnfp_net_clear_config_and_disable(nn);\n\t\treturn err;\n\t}\n\n\tnn->dp.ctrl = new_ctrl;\n\tnn->dp.ctrl_w1 = new_ctrl_w1;\n\n\tfor (r = 0; r < nn->dp.num_rx_rings; r++)\n\t\tnfp_net_rx_ring_fill_freelist(&nn->dp, &nn->dp.rx_rings[r]);\n\n\t \n\tif (nn->cap_w1 & NFP_NET_CFG_CTRL_FREELIST_EN) {\n\t\tnew_ctrl |= NFP_NET_CFG_CTRL_ENABLE;\n\t\tnn_writel(nn, NFP_NET_CFG_CTRL, new_ctrl);\n\n\t\terr = nfp_net_reconfig(nn, update);\n\t\tif (err) {\n\t\t\tnfp_net_clear_config_and_disable(nn);\n\t\t\treturn err;\n\t\t}\n\t\tnn->dp.ctrl = new_ctrl;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void nfp_net_close_stack(struct nfp_net *nn)\n{\n\tstruct nfp_net_r_vector *r_vec;\n\tunsigned int r;\n\n\tdisable_irq(nn->irq_entries[NFP_NET_IRQ_LSC_IDX].vector);\n\tnetif_carrier_off(nn->dp.netdev);\n\tnn->link_up = false;\n\n\tfor (r = 0; r < nn->dp.num_r_vecs; r++) {\n\t\tr_vec = &nn->r_vecs[r];\n\n\t\tdisable_irq(r_vec->irq_vector);\n\t\tnapi_disable(&r_vec->napi);\n\n\t\tif (r_vec->rx_ring)\n\t\t\tcancel_work_sync(&r_vec->rx_dim.work);\n\n\t\tif (r_vec->tx_ring)\n\t\t\tcancel_work_sync(&r_vec->tx_dim.work);\n\t}\n\n\tnetif_tx_disable(nn->dp.netdev);\n}\n\n \nstatic void nfp_net_close_free_all(struct nfp_net *nn)\n{\n\tunsigned int r;\n\n\tnfp_net_tx_rings_free(&nn->dp);\n\tnfp_net_rx_rings_free(&nn->dp);\n\n\tfor (r = 0; r < nn->dp.num_r_vecs; r++)\n\t\tnfp_net_cleanup_vector(nn, &nn->r_vecs[r]);\n\n\tnfp_net_aux_irq_free(nn, NFP_NET_CFG_LSC, NFP_NET_IRQ_LSC_IDX);\n\tnfp_net_aux_irq_free(nn, NFP_NET_CFG_EXN, NFP_NET_IRQ_EXN_IDX);\n}\n\n \nstatic int nfp_net_netdev_close(struct net_device *netdev)\n{\n\tstruct nfp_net *nn = netdev_priv(netdev);\n\n\t \n\tnfp_net_close_stack(nn);\n\n\t \n\tif (nn->cap_w1 & NFP_NET_CFG_CTRL_MCAST_FILTER)\n\t\t__dev_mc_unsync(netdev, nfp_net_mc_unsync);\n\n\tnfp_net_clear_config_and_disable(nn);\n\tnfp_port_configure(netdev, false);\n\n\t \n\tnfp_net_close_free_all(nn);\n\n\tnn_dbg(nn, \"%s down\", netdev->name);\n\treturn 0;\n}\n\nvoid nfp_ctrl_close(struct nfp_net *nn)\n{\n\tint r;\n\n\trtnl_lock();\n\n\tfor (r = 0; r < nn->dp.num_r_vecs; r++) {\n\t\tdisable_irq(nn->r_vecs[r].irq_vector);\n\t\ttasklet_disable(&nn->r_vecs[r].tasklet);\n\t}\n\n\tnfp_net_clear_config_and_disable(nn);\n\n\tnfp_net_close_free_all(nn);\n\n\trtnl_unlock();\n}\n\nstatic void nfp_net_rx_dim_work(struct work_struct *work)\n{\n\tstruct nfp_net_r_vector *r_vec;\n\tunsigned int factor, value;\n\tstruct dim_cq_moder moder;\n\tstruct nfp_net *nn;\n\tstruct dim *dim;\n\n\tdim = container_of(work, struct dim, work);\n\tmoder = net_dim_get_rx_moderation(dim->mode, dim->profile_ix);\n\tr_vec = container_of(dim, struct nfp_net_r_vector, rx_dim);\n\tnn = r_vec->nfp_net;\n\n\t \n\tfactor = nn->tlv_caps.me_freq_mhz / 16;\n\tif (nfp_net_coalesce_para_check(factor * moder.usec, moder.pkts))\n\t\treturn;\n\n\t \n\tvalue = (moder.pkts << 16) | (factor * moder.usec);\n\tnn_writel(nn, NFP_NET_CFG_RXR_IRQ_MOD(r_vec->rx_ring->idx), value);\n\t(void)nfp_net_reconfig(nn, NFP_NET_CFG_UPDATE_IRQMOD);\n\n\tdim->state = DIM_START_MEASURE;\n}\n\nstatic void nfp_net_tx_dim_work(struct work_struct *work)\n{\n\tstruct nfp_net_r_vector *r_vec;\n\tunsigned int factor, value;\n\tstruct dim_cq_moder moder;\n\tstruct nfp_net *nn;\n\tstruct dim *dim;\n\n\tdim = container_of(work, struct dim, work);\n\tmoder = net_dim_get_tx_moderation(dim->mode, dim->profile_ix);\n\tr_vec = container_of(dim, struct nfp_net_r_vector, tx_dim);\n\tnn = r_vec->nfp_net;\n\n\t \n\tfactor = nn->tlv_caps.me_freq_mhz / 16;\n\tif (nfp_net_coalesce_para_check(factor * moder.usec, moder.pkts))\n\t\treturn;\n\n\t \n\tvalue = (moder.pkts << 16) | (factor * moder.usec);\n\tnn_writel(nn, NFP_NET_CFG_TXR_IRQ_MOD(r_vec->tx_ring->idx), value);\n\t(void)nfp_net_reconfig(nn, NFP_NET_CFG_UPDATE_IRQMOD);\n\n\tdim->state = DIM_START_MEASURE;\n}\n\n \nstatic void nfp_net_open_stack(struct nfp_net *nn)\n{\n\tstruct nfp_net_r_vector *r_vec;\n\tunsigned int r;\n\n\tfor (r = 0; r < nn->dp.num_r_vecs; r++) {\n\t\tr_vec = &nn->r_vecs[r];\n\n\t\tif (r_vec->rx_ring) {\n\t\t\tINIT_WORK(&r_vec->rx_dim.work, nfp_net_rx_dim_work);\n\t\t\tr_vec->rx_dim.mode = DIM_CQ_PERIOD_MODE_START_FROM_EQE;\n\t\t}\n\n\t\tif (r_vec->tx_ring) {\n\t\t\tINIT_WORK(&r_vec->tx_dim.work, nfp_net_tx_dim_work);\n\t\t\tr_vec->tx_dim.mode = DIM_CQ_PERIOD_MODE_START_FROM_EQE;\n\t\t}\n\n\t\tnapi_enable(&r_vec->napi);\n\t\tenable_irq(r_vec->irq_vector);\n\t}\n\n\tnetif_tx_wake_all_queues(nn->dp.netdev);\n\n\tenable_irq(nn->irq_entries[NFP_NET_IRQ_LSC_IDX].vector);\n\tnfp_net_read_link_status(nn);\n}\n\nstatic int nfp_net_open_alloc_all(struct nfp_net *nn)\n{\n\tint err, r;\n\n\terr = nfp_net_aux_irq_request(nn, NFP_NET_CFG_EXN, \"%s-exn\",\n\t\t\t\t      nn->exn_name, sizeof(nn->exn_name),\n\t\t\t\t      NFP_NET_IRQ_EXN_IDX, nn->exn_handler);\n\tif (err)\n\t\treturn err;\n\terr = nfp_net_aux_irq_request(nn, NFP_NET_CFG_LSC, \"%s-lsc\",\n\t\t\t\t      nn->lsc_name, sizeof(nn->lsc_name),\n\t\t\t\t      NFP_NET_IRQ_LSC_IDX, nn->lsc_handler);\n\tif (err)\n\t\tgoto err_free_exn;\n\tdisable_irq(nn->irq_entries[NFP_NET_IRQ_LSC_IDX].vector);\n\n\tfor (r = 0; r < nn->dp.num_r_vecs; r++) {\n\t\terr = nfp_net_prepare_vector(nn, &nn->r_vecs[r], r);\n\t\tif (err)\n\t\t\tgoto err_cleanup_vec_p;\n\t}\n\n\terr = nfp_net_rx_rings_prepare(nn, &nn->dp);\n\tif (err)\n\t\tgoto err_cleanup_vec;\n\n\terr = nfp_net_tx_rings_prepare(nn, &nn->dp);\n\tif (err)\n\t\tgoto err_free_rx_rings;\n\n\tfor (r = 0; r < nn->max_r_vecs; r++)\n\t\tnfp_net_vector_assign_rings(&nn->dp, &nn->r_vecs[r], r);\n\n\treturn 0;\n\nerr_free_rx_rings:\n\tnfp_net_rx_rings_free(&nn->dp);\nerr_cleanup_vec:\n\tr = nn->dp.num_r_vecs;\nerr_cleanup_vec_p:\n\twhile (r--)\n\t\tnfp_net_cleanup_vector(nn, &nn->r_vecs[r]);\n\tnfp_net_aux_irq_free(nn, NFP_NET_CFG_LSC, NFP_NET_IRQ_LSC_IDX);\nerr_free_exn:\n\tnfp_net_aux_irq_free(nn, NFP_NET_CFG_EXN, NFP_NET_IRQ_EXN_IDX);\n\treturn err;\n}\n\nstatic int nfp_net_netdev_open(struct net_device *netdev)\n{\n\tstruct nfp_net *nn = netdev_priv(netdev);\n\tint err;\n\n\t \n\terr = nfp_net_open_alloc_all(nn);\n\tif (err)\n\t\treturn err;\n\n\terr = netif_set_real_num_tx_queues(netdev, nn->dp.num_stack_tx_rings);\n\tif (err)\n\t\tgoto err_free_all;\n\n\terr = netif_set_real_num_rx_queues(netdev, nn->dp.num_rx_rings);\n\tif (err)\n\t\tgoto err_free_all;\n\n\t \n\terr = nfp_port_configure(netdev, true);\n\tif (err)\n\t\tgoto err_free_all;\n\n\terr = nfp_net_set_config_and_enable(nn);\n\tif (err)\n\t\tgoto err_port_disable;\n\n\t \n\tnfp_net_open_stack(nn);\n\n\treturn 0;\n\nerr_port_disable:\n\tnfp_port_configure(netdev, false);\nerr_free_all:\n\tnfp_net_close_free_all(nn);\n\treturn err;\n}\n\nint nfp_ctrl_open(struct nfp_net *nn)\n{\n\tint err, r;\n\n\t \n\trtnl_lock();\n\n\terr = nfp_net_open_alloc_all(nn);\n\tif (err)\n\t\tgoto err_unlock;\n\n\terr = nfp_net_set_config_and_enable(nn);\n\tif (err)\n\t\tgoto err_free_all;\n\n\tfor (r = 0; r < nn->dp.num_r_vecs; r++)\n\t\tenable_irq(nn->r_vecs[r].irq_vector);\n\n\trtnl_unlock();\n\n\treturn 0;\n\nerr_free_all:\n\tnfp_net_close_free_all(nn);\nerr_unlock:\n\trtnl_unlock();\n\treturn err;\n}\n\nint nfp_net_sched_mbox_amsg_work(struct nfp_net *nn, u32 cmd, const void *data, size_t len,\n\t\t\t\t int (*cb)(struct nfp_net *, struct nfp_mbox_amsg_entry *))\n{\n\tstruct nfp_mbox_amsg_entry *entry;\n\n\tentry = kmalloc(sizeof(*entry) + len, GFP_ATOMIC);\n\tif (!entry)\n\t\treturn -ENOMEM;\n\n\tmemcpy(entry->msg, data, len);\n\tentry->cmd = cmd;\n\tentry->cfg = cb;\n\n\tspin_lock_bh(&nn->mbox_amsg.lock);\n\tlist_add_tail(&entry->list, &nn->mbox_amsg.list);\n\tspin_unlock_bh(&nn->mbox_amsg.lock);\n\n\tschedule_work(&nn->mbox_amsg.work);\n\n\treturn 0;\n}\n\nstatic void nfp_net_mbox_amsg_work(struct work_struct *work)\n{\n\tstruct nfp_net *nn = container_of(work, struct nfp_net, mbox_amsg.work);\n\tstruct nfp_mbox_amsg_entry *entry, *tmp;\n\tstruct list_head tmp_list;\n\n\tINIT_LIST_HEAD(&tmp_list);\n\n\tspin_lock_bh(&nn->mbox_amsg.lock);\n\tlist_splice_init(&nn->mbox_amsg.list, &tmp_list);\n\tspin_unlock_bh(&nn->mbox_amsg.lock);\n\n\tlist_for_each_entry_safe(entry, tmp, &tmp_list, list) {\n\t\tint err = entry->cfg(nn, entry);\n\n\t\tif (err)\n\t\t\tnn_err(nn, \"Config cmd %d to HW failed %d.\\n\", entry->cmd, err);\n\n\t\tlist_del(&entry->list);\n\t\tkfree(entry);\n\t}\n}\n\nstatic int nfp_net_mc_cfg(struct nfp_net *nn, struct nfp_mbox_amsg_entry *entry)\n{\n\tunsigned char *addr = entry->msg;\n\tint ret;\n\n\tret = nfp_net_mbox_lock(nn, NFP_NET_CFG_MULTICAST_SZ);\n\tif (ret)\n\t\treturn ret;\n\n\tnn_writel(nn, nn->tlv_caps.mbox_off + NFP_NET_CFG_MULTICAST_MAC_HI,\n\t\t  get_unaligned_be32(addr));\n\tnn_writew(nn, nn->tlv_caps.mbox_off + NFP_NET_CFG_MULTICAST_MAC_LO,\n\t\t  get_unaligned_be16(addr + 4));\n\n\treturn nfp_net_mbox_reconfig_and_unlock(nn, entry->cmd);\n}\n\nstatic int nfp_net_mc_sync(struct net_device *netdev, const unsigned char *addr)\n{\n\tstruct nfp_net *nn = netdev_priv(netdev);\n\n\tif (netdev_mc_count(netdev) > NFP_NET_CFG_MAC_MC_MAX) {\n\t\tnn_err(nn, \"Requested number of MC addresses (%d) exceeds maximum (%d).\\n\",\n\t\t       netdev_mc_count(netdev), NFP_NET_CFG_MAC_MC_MAX);\n\t\treturn -EINVAL;\n\t}\n\n\treturn nfp_net_sched_mbox_amsg_work(nn, NFP_NET_CFG_MBOX_CMD_MULTICAST_ADD, addr,\n\t\t\t\t\t    NFP_NET_CFG_MULTICAST_SZ, nfp_net_mc_cfg);\n}\n\nstatic int nfp_net_mc_unsync(struct net_device *netdev, const unsigned char *addr)\n{\n\tstruct nfp_net *nn = netdev_priv(netdev);\n\n\treturn nfp_net_sched_mbox_amsg_work(nn, NFP_NET_CFG_MBOX_CMD_MULTICAST_DEL, addr,\n\t\t\t\t\t    NFP_NET_CFG_MULTICAST_SZ, nfp_net_mc_cfg);\n}\n\nstatic void nfp_net_set_rx_mode(struct net_device *netdev)\n{\n\tstruct nfp_net *nn = netdev_priv(netdev);\n\tu32 new_ctrl, new_ctrl_w1;\n\n\tnew_ctrl = nn->dp.ctrl;\n\tnew_ctrl_w1 = nn->dp.ctrl_w1;\n\n\tif (!netdev_mc_empty(netdev) || netdev->flags & IFF_ALLMULTI)\n\t\tnew_ctrl |= nn->cap & NFP_NET_CFG_CTRL_L2MC;\n\telse\n\t\tnew_ctrl &= ~NFP_NET_CFG_CTRL_L2MC;\n\n\tif (netdev->flags & IFF_ALLMULTI)\n\t\tnew_ctrl_w1 &= ~NFP_NET_CFG_CTRL_MCAST_FILTER;\n\telse\n\t\tnew_ctrl_w1 |= nn->cap_w1 & NFP_NET_CFG_CTRL_MCAST_FILTER;\n\n\tif (netdev->flags & IFF_PROMISC) {\n\t\tif (nn->cap & NFP_NET_CFG_CTRL_PROMISC)\n\t\t\tnew_ctrl |= NFP_NET_CFG_CTRL_PROMISC;\n\t\telse\n\t\t\tnn_warn(nn, \"FW does not support promiscuous mode\\n\");\n\t} else {\n\t\tnew_ctrl &= ~NFP_NET_CFG_CTRL_PROMISC;\n\t}\n\n\tif ((nn->cap_w1 & NFP_NET_CFG_CTRL_MCAST_FILTER) &&\n\t    __dev_mc_sync(netdev, nfp_net_mc_sync, nfp_net_mc_unsync))\n\t\tnetdev_err(netdev, \"Sync mc address failed\\n\");\n\n\tif (new_ctrl == nn->dp.ctrl && new_ctrl_w1 == nn->dp.ctrl_w1)\n\t\treturn;\n\n\tif (new_ctrl != nn->dp.ctrl)\n\t\tnn_writel(nn, NFP_NET_CFG_CTRL, new_ctrl);\n\tif (new_ctrl_w1 != nn->dp.ctrl_w1)\n\t\tnn_writel(nn, NFP_NET_CFG_CTRL_WORD1, new_ctrl_w1);\n\tnfp_net_reconfig_post(nn, NFP_NET_CFG_UPDATE_GEN);\n\n\tnn->dp.ctrl = new_ctrl;\n\tnn->dp.ctrl_w1 = new_ctrl_w1;\n}\n\nstatic void nfp_net_rss_init_itbl(struct nfp_net *nn)\n{\n\tint i;\n\n\tfor (i = 0; i < sizeof(nn->rss_itbl); i++)\n\t\tnn->rss_itbl[i] =\n\t\t\tethtool_rxfh_indir_default(i, nn->dp.num_rx_rings);\n}\n\nstatic void nfp_net_dp_swap(struct nfp_net *nn, struct nfp_net_dp *dp)\n{\n\tstruct nfp_net_dp new_dp = *dp;\n\n\t*dp = nn->dp;\n\tnn->dp = new_dp;\n\n\tnn->dp.netdev->mtu = new_dp.mtu;\n\n\tif (!netif_is_rxfh_configured(nn->dp.netdev))\n\t\tnfp_net_rss_init_itbl(nn);\n}\n\nstatic int nfp_net_dp_swap_enable(struct nfp_net *nn, struct nfp_net_dp *dp)\n{\n\tunsigned int r;\n\tint err;\n\n\tnfp_net_dp_swap(nn, dp);\n\n\tfor (r = 0; r <\tnn->max_r_vecs; r++)\n\t\tnfp_net_vector_assign_rings(&nn->dp, &nn->r_vecs[r], r);\n\n\terr = netif_set_real_num_queues(nn->dp.netdev,\n\t\t\t\t\tnn->dp.num_stack_tx_rings,\n\t\t\t\t\tnn->dp.num_rx_rings);\n\tif (err)\n\t\treturn err;\n\n\treturn nfp_net_set_config_and_enable(nn);\n}\n\nstruct nfp_net_dp *nfp_net_clone_dp(struct nfp_net *nn)\n{\n\tstruct nfp_net_dp *new;\n\n\tnew = kmalloc(sizeof(*new), GFP_KERNEL);\n\tif (!new)\n\t\treturn NULL;\n\n\t*new = nn->dp;\n\n\tnew->xsk_pools = kmemdup(new->xsk_pools,\n\t\t\t\t array_size(nn->max_r_vecs,\n\t\t\t\t\t    sizeof(new->xsk_pools)),\n\t\t\t\t GFP_KERNEL);\n\tif (!new->xsk_pools) {\n\t\tkfree(new);\n\t\treturn NULL;\n\t}\n\n\t \n\tnew->fl_bufsz = 0;\n\tnew->tx_rings = NULL;\n\tnew->rx_rings = NULL;\n\tnew->num_r_vecs = 0;\n\tnew->num_stack_tx_rings = 0;\n\tnew->txrwb = NULL;\n\tnew->txrwb_dma = 0;\n\n\treturn new;\n}\n\nstatic void nfp_net_free_dp(struct nfp_net_dp *dp)\n{\n\tkfree(dp->xsk_pools);\n\tkfree(dp);\n}\n\nstatic int\nnfp_net_check_config(struct nfp_net *nn, struct nfp_net_dp *dp,\n\t\t     struct netlink_ext_ack *extack)\n{\n\tunsigned int r, xsk_min_fl_bufsz;\n\n\t \n\tif (!dp->xdp_prog)\n\t\treturn 0;\n\tif (dp->fl_bufsz > PAGE_SIZE) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"MTU too large w/ XDP enabled\");\n\t\treturn -EINVAL;\n\t}\n\tif (dp->num_tx_rings > nn->max_tx_rings) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Insufficient number of TX rings w/ XDP enabled\");\n\t\treturn -EINVAL;\n\t}\n\n\txsk_min_fl_bufsz = nfp_net_calc_fl_bufsz_xsk(dp);\n\tfor (r = 0; r < nn->max_r_vecs; r++) {\n\t\tif (!dp->xsk_pools[r])\n\t\t\tcontinue;\n\n\t\tif (xsk_pool_get_rx_frame_size(dp->xsk_pools[r]) < xsk_min_fl_bufsz) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t   \"XSK buffer pool chunk size too small\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint nfp_net_ring_reconfig(struct nfp_net *nn, struct nfp_net_dp *dp,\n\t\t\t  struct netlink_ext_ack *extack)\n{\n\tint r, err;\n\n\tdp->fl_bufsz = nfp_net_calc_fl_bufsz(dp);\n\n\tdp->num_stack_tx_rings = dp->num_tx_rings;\n\tif (dp->xdp_prog)\n\t\tdp->num_stack_tx_rings -= dp->num_rx_rings;\n\n\tdp->num_r_vecs = max(dp->num_rx_rings, dp->num_stack_tx_rings);\n\n\terr = nfp_net_check_config(nn, dp, extack);\n\tif (err)\n\t\tgoto exit_free_dp;\n\n\tif (!netif_running(dp->netdev)) {\n\t\tnfp_net_dp_swap(nn, dp);\n\t\terr = 0;\n\t\tgoto exit_free_dp;\n\t}\n\n\t \n\tfor (r = nn->dp.num_r_vecs; r < dp->num_r_vecs; r++) {\n\t\terr = nfp_net_prepare_vector(nn, &nn->r_vecs[r], r);\n\t\tif (err) {\n\t\t\tdp->num_r_vecs = r;\n\t\t\tgoto err_cleanup_vecs;\n\t\t}\n\t}\n\n\terr = nfp_net_rx_rings_prepare(nn, dp);\n\tif (err)\n\t\tgoto err_cleanup_vecs;\n\n\terr = nfp_net_tx_rings_prepare(nn, dp);\n\tif (err)\n\t\tgoto err_free_rx;\n\n\t \n\tnfp_net_close_stack(nn);\n\tnfp_net_clear_config_and_disable(nn);\n\n\terr = nfp_net_dp_swap_enable(nn, dp);\n\tif (err) {\n\t\tint err2;\n\n\t\tnfp_net_clear_config_and_disable(nn);\n\n\t\t \n\t\terr2 = nfp_net_dp_swap_enable(nn, dp);\n\t\tif (err2)\n\t\t\tnn_err(nn, \"Can't restore ring config - FW communication failed (%d,%d)\\n\",\n\t\t\t       err, err2);\n\t}\n\tfor (r = dp->num_r_vecs - 1; r >= nn->dp.num_r_vecs; r--)\n\t\tnfp_net_cleanup_vector(nn, &nn->r_vecs[r]);\n\n\tnfp_net_rx_rings_free(dp);\n\tnfp_net_tx_rings_free(dp);\n\n\tnfp_net_open_stack(nn);\nexit_free_dp:\n\tnfp_net_free_dp(dp);\n\n\treturn err;\n\nerr_free_rx:\n\tnfp_net_rx_rings_free(dp);\nerr_cleanup_vecs:\n\tfor (r = dp->num_r_vecs - 1; r >= nn->dp.num_r_vecs; r--)\n\t\tnfp_net_cleanup_vector(nn, &nn->r_vecs[r]);\n\tnfp_net_free_dp(dp);\n\treturn err;\n}\n\nstatic int nfp_net_change_mtu(struct net_device *netdev, int new_mtu)\n{\n\tstruct nfp_net *nn = netdev_priv(netdev);\n\tstruct nfp_net_dp *dp;\n\tint err;\n\n\terr = nfp_app_check_mtu(nn->app, netdev, new_mtu);\n\tif (err)\n\t\treturn err;\n\n\tdp = nfp_net_clone_dp(nn);\n\tif (!dp)\n\t\treturn -ENOMEM;\n\n\tdp->mtu = new_mtu;\n\n\treturn nfp_net_ring_reconfig(nn, dp, NULL);\n}\n\nstatic int\nnfp_net_vlan_rx_add_vid(struct net_device *netdev, __be16 proto, u16 vid)\n{\n\tconst u32 cmd = NFP_NET_CFG_MBOX_CMD_CTAG_FILTER_ADD;\n\tstruct nfp_net *nn = netdev_priv(netdev);\n\tint err;\n\n\t \n\tif (!vid)\n\t\treturn 0;\n\n\terr = nfp_net_mbox_lock(nn, NFP_NET_CFG_VLAN_FILTER_SZ);\n\tif (err)\n\t\treturn err;\n\n\tnn_writew(nn, nn->tlv_caps.mbox_off + NFP_NET_CFG_VLAN_FILTER_VID, vid);\n\tnn_writew(nn, nn->tlv_caps.mbox_off + NFP_NET_CFG_VLAN_FILTER_PROTO,\n\t\t  ETH_P_8021Q);\n\n\treturn nfp_net_mbox_reconfig_and_unlock(nn, cmd);\n}\n\nstatic int\nnfp_net_vlan_rx_kill_vid(struct net_device *netdev, __be16 proto, u16 vid)\n{\n\tconst u32 cmd = NFP_NET_CFG_MBOX_CMD_CTAG_FILTER_KILL;\n\tstruct nfp_net *nn = netdev_priv(netdev);\n\tint err;\n\n\t \n\tif (!vid)\n\t\treturn 0;\n\n\terr = nfp_net_mbox_lock(nn, NFP_NET_CFG_VLAN_FILTER_SZ);\n\tif (err)\n\t\treturn err;\n\n\tnn_writew(nn, nn->tlv_caps.mbox_off + NFP_NET_CFG_VLAN_FILTER_VID, vid);\n\tnn_writew(nn, nn->tlv_caps.mbox_off + NFP_NET_CFG_VLAN_FILTER_PROTO,\n\t\t  ETH_P_8021Q);\n\n\treturn nfp_net_mbox_reconfig_and_unlock(nn, cmd);\n}\n\nstatic void nfp_net_stat64(struct net_device *netdev,\n\t\t\t   struct rtnl_link_stats64 *stats)\n{\n\tstruct nfp_net *nn = netdev_priv(netdev);\n\tint r;\n\n\t \n\tfor (r = 0; r < nn->max_r_vecs; r++) {\n\t\tstruct nfp_net_r_vector *r_vec = &nn->r_vecs[r];\n\t\tu64 data[3];\n\t\tunsigned int start;\n\n\t\tdo {\n\t\t\tstart = u64_stats_fetch_begin(&r_vec->rx_sync);\n\t\t\tdata[0] = r_vec->rx_pkts;\n\t\t\tdata[1] = r_vec->rx_bytes;\n\t\t\tdata[2] = r_vec->rx_drops;\n\t\t} while (u64_stats_fetch_retry(&r_vec->rx_sync, start));\n\t\tstats->rx_packets += data[0];\n\t\tstats->rx_bytes += data[1];\n\t\tstats->rx_dropped += data[2];\n\n\t\tdo {\n\t\t\tstart = u64_stats_fetch_begin(&r_vec->tx_sync);\n\t\t\tdata[0] = r_vec->tx_pkts;\n\t\t\tdata[1] = r_vec->tx_bytes;\n\t\t\tdata[2] = r_vec->tx_errors;\n\t\t} while (u64_stats_fetch_retry(&r_vec->tx_sync, start));\n\t\tstats->tx_packets += data[0];\n\t\tstats->tx_bytes += data[1];\n\t\tstats->tx_errors += data[2];\n\t}\n\n\t \n\tstats->multicast += nn_readq(nn, NFP_NET_CFG_STATS_RX_MC_FRAMES);\n\tstats->rx_dropped += nn_readq(nn, NFP_NET_CFG_STATS_RX_DISCARDS);\n\tstats->rx_errors += nn_readq(nn, NFP_NET_CFG_STATS_RX_ERRORS);\n\n\tstats->tx_dropped += nn_readq(nn, NFP_NET_CFG_STATS_TX_DISCARDS);\n\tstats->tx_errors += nn_readq(nn, NFP_NET_CFG_STATS_TX_ERRORS);\n}\n\nstatic int nfp_net_set_features(struct net_device *netdev,\n\t\t\t\tnetdev_features_t features)\n{\n\tnetdev_features_t changed = netdev->features ^ features;\n\tstruct nfp_net *nn = netdev_priv(netdev);\n\tu32 new_ctrl;\n\tint err;\n\n\t \n\n\tnew_ctrl = nn->dp.ctrl;\n\n\tif (changed & NETIF_F_RXCSUM) {\n\t\tif (features & NETIF_F_RXCSUM)\n\t\t\tnew_ctrl |= nn->cap & NFP_NET_CFG_CTRL_RXCSUM_ANY;\n\t\telse\n\t\t\tnew_ctrl &= ~NFP_NET_CFG_CTRL_RXCSUM_ANY;\n\t}\n\n\tif (changed & (NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM)) {\n\t\tif (features & (NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM))\n\t\t\tnew_ctrl |= NFP_NET_CFG_CTRL_TXCSUM;\n\t\telse\n\t\t\tnew_ctrl &= ~NFP_NET_CFG_CTRL_TXCSUM;\n\t}\n\n\tif (changed & (NETIF_F_TSO | NETIF_F_TSO6)) {\n\t\tif (features & (NETIF_F_TSO | NETIF_F_TSO6))\n\t\t\tnew_ctrl |= nn->cap & NFP_NET_CFG_CTRL_LSO2 ?:\n\t\t\t\t\t      NFP_NET_CFG_CTRL_LSO;\n\t\telse\n\t\t\tnew_ctrl &= ~NFP_NET_CFG_CTRL_LSO_ANY;\n\t}\n\n\tif (changed & NETIF_F_HW_VLAN_CTAG_RX) {\n\t\tif (features & NETIF_F_HW_VLAN_CTAG_RX)\n\t\t\tnew_ctrl |= nn->cap & NFP_NET_CFG_CTRL_RXVLAN_V2 ?:\n\t\t\t\t    NFP_NET_CFG_CTRL_RXVLAN;\n\t\telse\n\t\t\tnew_ctrl &= ~NFP_NET_CFG_CTRL_RXVLAN_ANY;\n\t}\n\n\tif (changed & NETIF_F_HW_VLAN_CTAG_TX) {\n\t\tif (features & NETIF_F_HW_VLAN_CTAG_TX)\n\t\t\tnew_ctrl |= nn->cap & NFP_NET_CFG_CTRL_TXVLAN_V2 ?:\n\t\t\t\t    NFP_NET_CFG_CTRL_TXVLAN;\n\t\telse\n\t\t\tnew_ctrl &= ~NFP_NET_CFG_CTRL_TXVLAN_ANY;\n\t}\n\n\tif (changed & NETIF_F_HW_VLAN_CTAG_FILTER) {\n\t\tif (features & NETIF_F_HW_VLAN_CTAG_FILTER)\n\t\t\tnew_ctrl |= NFP_NET_CFG_CTRL_CTAG_FILTER;\n\t\telse\n\t\t\tnew_ctrl &= ~NFP_NET_CFG_CTRL_CTAG_FILTER;\n\t}\n\n\tif (changed & NETIF_F_HW_VLAN_STAG_RX) {\n\t\tif (features & NETIF_F_HW_VLAN_STAG_RX)\n\t\t\tnew_ctrl |= NFP_NET_CFG_CTRL_RXQINQ;\n\t\telse\n\t\t\tnew_ctrl &= ~NFP_NET_CFG_CTRL_RXQINQ;\n\t}\n\n\tif (changed & NETIF_F_SG) {\n\t\tif (features & NETIF_F_SG)\n\t\t\tnew_ctrl |= NFP_NET_CFG_CTRL_GATHER;\n\t\telse\n\t\t\tnew_ctrl &= ~NFP_NET_CFG_CTRL_GATHER;\n\t}\n\n\terr = nfp_port_set_features(netdev, features);\n\tif (err)\n\t\treturn err;\n\n\tnn_dbg(nn, \"Feature change 0x%llx -> 0x%llx (changed=0x%llx)\\n\",\n\t       netdev->features, features, changed);\n\n\tif (new_ctrl == nn->dp.ctrl)\n\t\treturn 0;\n\n\tnn_dbg(nn, \"NIC ctrl: 0x%x -> 0x%x\\n\", nn->dp.ctrl, new_ctrl);\n\tnn_writel(nn, NFP_NET_CFG_CTRL, new_ctrl);\n\terr = nfp_net_reconfig(nn, NFP_NET_CFG_UPDATE_GEN);\n\tif (err)\n\t\treturn err;\n\n\tnn->dp.ctrl = new_ctrl;\n\n\treturn 0;\n}\n\nstatic netdev_features_t\nnfp_net_fix_features(struct net_device *netdev,\n\t\t     netdev_features_t features)\n{\n\tif ((features & NETIF_F_HW_VLAN_CTAG_RX) &&\n\t    (features & NETIF_F_HW_VLAN_STAG_RX)) {\n\t\tif (netdev->features & NETIF_F_HW_VLAN_CTAG_RX) {\n\t\t\tfeatures &= ~NETIF_F_HW_VLAN_CTAG_RX;\n\t\t\tnetdev->wanted_features &= ~NETIF_F_HW_VLAN_CTAG_RX;\n\t\t\tnetdev_warn(netdev,\n\t\t\t\t    \"S-tag and C-tag stripping can't be enabled at the same time. Enabling S-tag stripping and disabling C-tag stripping\\n\");\n\t\t} else if (netdev->features & NETIF_F_HW_VLAN_STAG_RX) {\n\t\t\tfeatures &= ~NETIF_F_HW_VLAN_STAG_RX;\n\t\t\tnetdev->wanted_features &= ~NETIF_F_HW_VLAN_STAG_RX;\n\t\t\tnetdev_warn(netdev,\n\t\t\t\t    \"S-tag and C-tag stripping can't be enabled at the same time. Enabling C-tag stripping and disabling S-tag stripping\\n\");\n\t\t}\n\t}\n\treturn features;\n}\n\nstatic netdev_features_t\nnfp_net_features_check(struct sk_buff *skb, struct net_device *dev,\n\t\t       netdev_features_t features)\n{\n\tu8 l4_hdr;\n\n\t \n\tfeatures &= vlan_features_check(skb, features);\n\n\tif (!skb->encapsulation)\n\t\treturn features;\n\n\t \n\tif (skb_is_gso(skb)) {\n\t\tu32 hdrlen;\n\n\t\thdrlen = skb_inner_tcp_all_headers(skb);\n\n\t\t \n\t\tif (unlikely(hdrlen > NFP_NET_LSO_MAX_HDR_SZ - 8))\n\t\t\tfeatures &= ~NETIF_F_GSO_MASK;\n\t}\n\n\tif (xfrm_offload(skb))\n\t\treturn features;\n\n\t \n\tswitch (vlan_get_protocol(skb)) {\n\tcase htons(ETH_P_IP):\n\t\tl4_hdr = ip_hdr(skb)->protocol;\n\t\tbreak;\n\tcase htons(ETH_P_IPV6):\n\t\tl4_hdr = ipv6_hdr(skb)->nexthdr;\n\t\tbreak;\n\tdefault:\n\t\treturn features & ~(NETIF_F_CSUM_MASK | NETIF_F_GSO_MASK);\n\t}\n\n\tif (skb->inner_protocol_type != ENCAP_TYPE_ETHER ||\n\t    skb->inner_protocol != htons(ETH_P_TEB) ||\n\t    (l4_hdr != IPPROTO_UDP && l4_hdr != IPPROTO_GRE) ||\n\t    (l4_hdr == IPPROTO_UDP &&\n\t     (skb_inner_mac_header(skb) - skb_transport_header(skb) !=\n\t      sizeof(struct udphdr) + sizeof(struct vxlanhdr))))\n\t\treturn features & ~(NETIF_F_CSUM_MASK | NETIF_F_GSO_MASK);\n\n\treturn features;\n}\n\nstatic int\nnfp_net_get_phys_port_name(struct net_device *netdev, char *name, size_t len)\n{\n\tstruct nfp_net *nn = netdev_priv(netdev);\n\tint n;\n\n\t \n\tif (nn->port)\n\t\treturn -EOPNOTSUPP;\n\n\tif (nn->dp.is_vf || nn->vnic_no_name)\n\t\treturn -EOPNOTSUPP;\n\n\tn = snprintf(name, len, \"n%d\", nn->id);\n\tif (n >= len)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int nfp_net_xdp_setup_drv(struct nfp_net *nn, struct netdev_bpf *bpf)\n{\n\tstruct bpf_prog *prog = bpf->prog;\n\tstruct nfp_net_dp *dp;\n\tint err;\n\n\tif (!prog == !nn->dp.xdp_prog) {\n\t\tWRITE_ONCE(nn->dp.xdp_prog, prog);\n\t\txdp_attachment_setup(&nn->xdp, bpf);\n\t\treturn 0;\n\t}\n\n\tdp = nfp_net_clone_dp(nn);\n\tif (!dp)\n\t\treturn -ENOMEM;\n\n\tdp->xdp_prog = prog;\n\tdp->num_tx_rings += prog ? nn->dp.num_rx_rings : -nn->dp.num_rx_rings;\n\tdp->rx_dma_dir = prog ? DMA_BIDIRECTIONAL : DMA_FROM_DEVICE;\n\tdp->rx_dma_off = prog ? XDP_PACKET_HEADROOM - nn->dp.rx_offset : 0;\n\n\t \n\terr = nfp_net_ring_reconfig(nn, dp, bpf->extack);\n\tif (err)\n\t\treturn err;\n\n\txdp_attachment_setup(&nn->xdp, bpf);\n\treturn 0;\n}\n\nstatic int nfp_net_xdp_setup_hw(struct nfp_net *nn, struct netdev_bpf *bpf)\n{\n\tint err;\n\n\terr = nfp_app_xdp_offload(nn->app, nn, bpf->prog, bpf->extack);\n\tif (err)\n\t\treturn err;\n\n\txdp_attachment_setup(&nn->xdp_hw, bpf);\n\treturn 0;\n}\n\nstatic int nfp_net_xdp(struct net_device *netdev, struct netdev_bpf *xdp)\n{\n\tstruct nfp_net *nn = netdev_priv(netdev);\n\n\tswitch (xdp->command) {\n\tcase XDP_SETUP_PROG:\n\t\treturn nfp_net_xdp_setup_drv(nn, xdp);\n\tcase XDP_SETUP_PROG_HW:\n\t\treturn nfp_net_xdp_setup_hw(nn, xdp);\n\tcase XDP_SETUP_XSK_POOL:\n\t\treturn nfp_net_xsk_setup_pool(netdev, xdp->xsk.pool,\n\t\t\t\t\t      xdp->xsk.queue_id);\n\tdefault:\n\t\treturn nfp_app_bpf(nn->app, nn, xdp);\n\t}\n}\n\nstatic int nfp_net_set_mac_address(struct net_device *netdev, void *addr)\n{\n\tstruct nfp_net *nn = netdev_priv(netdev);\n\tstruct sockaddr *saddr = addr;\n\tint err;\n\n\terr = eth_prepare_mac_addr_change(netdev, addr);\n\tif (err)\n\t\treturn err;\n\n\tnfp_net_write_mac_addr(nn, saddr->sa_data);\n\n\terr = nfp_net_reconfig(nn, NFP_NET_CFG_UPDATE_MACADDR);\n\tif (err)\n\t\treturn err;\n\n\teth_commit_mac_addr_change(netdev, addr);\n\n\treturn 0;\n}\n\nstatic int nfp_net_bridge_getlink(struct sk_buff *skb, u32 pid, u32 seq,\n\t\t\t\t  struct net_device *dev, u32 filter_mask,\n\t\t\t\t  int nlflags)\n{\n\tstruct nfp_net *nn = netdev_priv(dev);\n\tu16 mode;\n\n\tif (!(nn->cap & NFP_NET_CFG_CTRL_VEPA))\n\t\treturn -EOPNOTSUPP;\n\n\tmode = (nn->dp.ctrl & NFP_NET_CFG_CTRL_VEPA) ?\n\t       BRIDGE_MODE_VEPA : BRIDGE_MODE_VEB;\n\n\treturn ndo_dflt_bridge_getlink(skb, pid, seq, dev, mode, 0, 0,\n\t\t\t\t       nlflags, filter_mask, NULL);\n}\n\nstatic int nfp_net_bridge_setlink(struct net_device *dev, struct nlmsghdr *nlh,\n\t\t\t\t  u16 flags, struct netlink_ext_ack *extack)\n{\n\tstruct nfp_net *nn = netdev_priv(dev);\n\tstruct nlattr *attr, *br_spec;\n\tint rem, err;\n\tu32 new_ctrl;\n\tu16 mode;\n\n\tif (!(nn->cap & NFP_NET_CFG_CTRL_VEPA))\n\t\treturn -EOPNOTSUPP;\n\n\tbr_spec = nlmsg_find_attr(nlh, sizeof(struct ifinfomsg), IFLA_AF_SPEC);\n\tif (!br_spec)\n\t\treturn -EINVAL;\n\n\tnla_for_each_nested(attr, br_spec, rem) {\n\t\tif (nla_type(attr) != IFLA_BRIDGE_MODE)\n\t\t\tcontinue;\n\n\t\tnew_ctrl = nn->dp.ctrl;\n\t\tmode = nla_get_u16(attr);\n\t\tif (mode == BRIDGE_MODE_VEPA)\n\t\t\tnew_ctrl |= NFP_NET_CFG_CTRL_VEPA;\n\t\telse if (mode == BRIDGE_MODE_VEB)\n\t\t\tnew_ctrl &= ~NFP_NET_CFG_CTRL_VEPA;\n\t\telse\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tif (new_ctrl == nn->dp.ctrl)\n\t\t\treturn 0;\n\n\t\tnn_writel(nn, NFP_NET_CFG_CTRL, new_ctrl);\n\t\terr = nfp_net_reconfig(nn, NFP_NET_CFG_UPDATE_GEN);\n\t\tif (!err)\n\t\t\tnn->dp.ctrl = new_ctrl;\n\n\t\treturn err;\n\t}\n\n\treturn -EINVAL;\n}\n\nconst struct net_device_ops nfp_nfd3_netdev_ops = {\n\t.ndo_init\t\t= nfp_app_ndo_init,\n\t.ndo_uninit\t\t= nfp_app_ndo_uninit,\n\t.ndo_open\t\t= nfp_net_netdev_open,\n\t.ndo_stop\t\t= nfp_net_netdev_close,\n\t.ndo_start_xmit\t\t= nfp_net_tx,\n\t.ndo_get_stats64\t= nfp_net_stat64,\n\t.ndo_vlan_rx_add_vid\t= nfp_net_vlan_rx_add_vid,\n\t.ndo_vlan_rx_kill_vid\t= nfp_net_vlan_rx_kill_vid,\n\t.ndo_set_vf_mac         = nfp_app_set_vf_mac,\n\t.ndo_set_vf_vlan        = nfp_app_set_vf_vlan,\n\t.ndo_set_vf_rate\t= nfp_app_set_vf_rate,\n\t.ndo_set_vf_spoofchk    = nfp_app_set_vf_spoofchk,\n\t.ndo_set_vf_trust\t= nfp_app_set_vf_trust,\n\t.ndo_get_vf_config\t= nfp_app_get_vf_config,\n\t.ndo_set_vf_link_state  = nfp_app_set_vf_link_state,\n\t.ndo_setup_tc\t\t= nfp_port_setup_tc,\n\t.ndo_tx_timeout\t\t= nfp_net_tx_timeout,\n\t.ndo_set_rx_mode\t= nfp_net_set_rx_mode,\n\t.ndo_change_mtu\t\t= nfp_net_change_mtu,\n\t.ndo_set_mac_address\t= nfp_net_set_mac_address,\n\t.ndo_set_features\t= nfp_net_set_features,\n\t.ndo_fix_features\t= nfp_net_fix_features,\n\t.ndo_features_check\t= nfp_net_features_check,\n\t.ndo_get_phys_port_name\t= nfp_net_get_phys_port_name,\n\t.ndo_bpf\t\t= nfp_net_xdp,\n\t.ndo_xsk_wakeup\t\t= nfp_net_xsk_wakeup,\n\t.ndo_bridge_getlink     = nfp_net_bridge_getlink,\n\t.ndo_bridge_setlink     = nfp_net_bridge_setlink,\n};\n\nconst struct net_device_ops nfp_nfdk_netdev_ops = {\n\t.ndo_init\t\t= nfp_app_ndo_init,\n\t.ndo_uninit\t\t= nfp_app_ndo_uninit,\n\t.ndo_open\t\t= nfp_net_netdev_open,\n\t.ndo_stop\t\t= nfp_net_netdev_close,\n\t.ndo_start_xmit\t\t= nfp_net_tx,\n\t.ndo_get_stats64\t= nfp_net_stat64,\n\t.ndo_vlan_rx_add_vid\t= nfp_net_vlan_rx_add_vid,\n\t.ndo_vlan_rx_kill_vid\t= nfp_net_vlan_rx_kill_vid,\n\t.ndo_set_vf_mac         = nfp_app_set_vf_mac,\n\t.ndo_set_vf_vlan        = nfp_app_set_vf_vlan,\n\t.ndo_set_vf_rate\t= nfp_app_set_vf_rate,\n\t.ndo_set_vf_spoofchk    = nfp_app_set_vf_spoofchk,\n\t.ndo_set_vf_trust\t= nfp_app_set_vf_trust,\n\t.ndo_get_vf_config\t= nfp_app_get_vf_config,\n\t.ndo_set_vf_link_state  = nfp_app_set_vf_link_state,\n\t.ndo_setup_tc\t\t= nfp_port_setup_tc,\n\t.ndo_tx_timeout\t\t= nfp_net_tx_timeout,\n\t.ndo_set_rx_mode\t= nfp_net_set_rx_mode,\n\t.ndo_change_mtu\t\t= nfp_net_change_mtu,\n\t.ndo_set_mac_address\t= nfp_net_set_mac_address,\n\t.ndo_set_features\t= nfp_net_set_features,\n\t.ndo_fix_features\t= nfp_net_fix_features,\n\t.ndo_features_check\t= nfp_net_features_check,\n\t.ndo_get_phys_port_name\t= nfp_net_get_phys_port_name,\n\t.ndo_bpf\t\t= nfp_net_xdp,\n\t.ndo_bridge_getlink     = nfp_net_bridge_getlink,\n\t.ndo_bridge_setlink     = nfp_net_bridge_setlink,\n};\n\nstatic int nfp_udp_tunnel_sync(struct net_device *netdev, unsigned int table)\n{\n\tstruct nfp_net *nn = netdev_priv(netdev);\n\tint i;\n\n\tBUILD_BUG_ON(NFP_NET_N_VXLAN_PORTS & 1);\n\tfor (i = 0; i < NFP_NET_N_VXLAN_PORTS; i += 2) {\n\t\tstruct udp_tunnel_info ti0, ti1;\n\n\t\tudp_tunnel_nic_get_port(netdev, table, i, &ti0);\n\t\tudp_tunnel_nic_get_port(netdev, table, i + 1, &ti1);\n\n\t\tnn_writel(nn, NFP_NET_CFG_VXLAN_PORT + i * sizeof(ti0.port),\n\t\t\t  be16_to_cpu(ti1.port) << 16 | be16_to_cpu(ti0.port));\n\t}\n\n\treturn nfp_net_reconfig(nn, NFP_NET_CFG_UPDATE_VXLAN);\n}\n\nstatic const struct udp_tunnel_nic_info nfp_udp_tunnels = {\n\t.sync_table     = nfp_udp_tunnel_sync,\n\t.flags          = UDP_TUNNEL_NIC_INFO_MAY_SLEEP |\n\t\t\t  UDP_TUNNEL_NIC_INFO_OPEN_ONLY,\n\t.tables         = {\n\t\t{\n\t\t\t.n_entries      = NFP_NET_N_VXLAN_PORTS,\n\t\t\t.tunnel_types   = UDP_TUNNEL_TYPE_VXLAN,\n\t\t},\n\t},\n};\n\n \nvoid nfp_net_info(struct nfp_net *nn)\n{\n\tnn_info(nn, \"NFP-6xxx %sNetdev: TxQs=%d/%d RxQs=%d/%d\\n\",\n\t\tnn->dp.is_vf ? \"VF \" : \"\",\n\t\tnn->dp.num_tx_rings, nn->max_tx_rings,\n\t\tnn->dp.num_rx_rings, nn->max_rx_rings);\n\tnn_info(nn, \"VER: %d.%d.%d.%d, Maximum supported MTU: %d\\n\",\n\t\tnn->fw_ver.extend, nn->fw_ver.class,\n\t\tnn->fw_ver.major, nn->fw_ver.minor,\n\t\tnn->max_mtu);\n\tnn_info(nn, \"CAP: %#x %s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s\\n\",\n\t\tnn->cap,\n\t\tnn->cap & NFP_NET_CFG_CTRL_PROMISC  ? \"PROMISC \"  : \"\",\n\t\tnn->cap & NFP_NET_CFG_CTRL_L2BC     ? \"L2BCFILT \" : \"\",\n\t\tnn->cap & NFP_NET_CFG_CTRL_L2MC     ? \"L2MCFILT \" : \"\",\n\t\tnn->cap & NFP_NET_CFG_CTRL_RXCSUM   ? \"RXCSUM \"   : \"\",\n\t\tnn->cap & NFP_NET_CFG_CTRL_TXCSUM   ? \"TXCSUM \"   : \"\",\n\t\tnn->cap & NFP_NET_CFG_CTRL_RXVLAN   ? \"RXVLAN \"   : \"\",\n\t\tnn->cap & NFP_NET_CFG_CTRL_TXVLAN   ? \"TXVLAN \"   : \"\",\n\t\tnn->cap & NFP_NET_CFG_CTRL_RXQINQ   ? \"RXQINQ \"   : \"\",\n\t\tnn->cap & NFP_NET_CFG_CTRL_RXVLAN_V2 ? \"RXVLANv2 \"   : \"\",\n\t\tnn->cap & NFP_NET_CFG_CTRL_TXVLAN_V2   ? \"TXVLANv2 \"   : \"\",\n\t\tnn->cap & NFP_NET_CFG_CTRL_SCATTER  ? \"SCATTER \"  : \"\",\n\t\tnn->cap & NFP_NET_CFG_CTRL_GATHER   ? \"GATHER \"   : \"\",\n\t\tnn->cap & NFP_NET_CFG_CTRL_LSO      ? \"TSO1 \"     : \"\",\n\t\tnn->cap & NFP_NET_CFG_CTRL_LSO2     ? \"TSO2 \"     : \"\",\n\t\tnn->cap & NFP_NET_CFG_CTRL_RSS      ? \"RSS1 \"     : \"\",\n\t\tnn->cap & NFP_NET_CFG_CTRL_RSS2     ? \"RSS2 \"     : \"\",\n\t\tnn->cap & NFP_NET_CFG_CTRL_CTAG_FILTER ? \"CTAG_FILTER \" : \"\",\n\t\tnn->cap & NFP_NET_CFG_CTRL_MSIXAUTO ? \"AUTOMASK \" : \"\",\n\t\tnn->cap & NFP_NET_CFG_CTRL_IRQMOD   ? \"IRQMOD \"   : \"\",\n\t\tnn->cap & NFP_NET_CFG_CTRL_TXRWB    ? \"TXRWB \"    : \"\",\n\t\tnn->cap & NFP_NET_CFG_CTRL_VEPA     ? \"VEPA \"     : \"\",\n\t\tnn->cap & NFP_NET_CFG_CTRL_VXLAN    ? \"VXLAN \"    : \"\",\n\t\tnn->cap & NFP_NET_CFG_CTRL_NVGRE    ? \"NVGRE \"\t  : \"\",\n\t\tnn->cap & NFP_NET_CFG_CTRL_CSUM_COMPLETE ?\n\t\t\t\t\t\t      \"RXCSUM_COMPLETE \" : \"\",\n\t\tnn->cap & NFP_NET_CFG_CTRL_LIVE_ADDR ? \"LIVE_ADDR \" : \"\",\n\t\tnn->cap_w1 & NFP_NET_CFG_CTRL_MCAST_FILTER ? \"MULTICAST_FILTER \" : \"\",\n\t\tnfp_app_extra_cap(nn->app, nn));\n}\n\n \nstruct nfp_net *\nnfp_net_alloc(struct pci_dev *pdev, const struct nfp_dev_info *dev_info,\n\t      void __iomem *ctrl_bar, bool needs_netdev,\n\t      unsigned int max_tx_rings, unsigned int max_rx_rings)\n{\n\tu64 dma_mask = dma_get_mask(&pdev->dev);\n\tstruct nfp_net *nn;\n\tint err;\n\n\tif (needs_netdev) {\n\t\tstruct net_device *netdev;\n\n\t\tnetdev = alloc_etherdev_mqs(sizeof(struct nfp_net),\n\t\t\t\t\t    max_tx_rings, max_rx_rings);\n\t\tif (!netdev)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\n\t\tSET_NETDEV_DEV(netdev, &pdev->dev);\n\t\tnn = netdev_priv(netdev);\n\t\tnn->dp.netdev = netdev;\n\t} else {\n\t\tnn = vzalloc(sizeof(*nn));\n\t\tif (!nn)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tnn->dp.dev = &pdev->dev;\n\tnn->dp.ctrl_bar = ctrl_bar;\n\tnn->dev_info = dev_info;\n\tnn->pdev = pdev;\n\tnfp_net_get_fw_version(&nn->fw_ver, ctrl_bar);\n\n\tswitch (FIELD_GET(NFP_NET_CFG_VERSION_DP_MASK, nn->fw_ver.extend)) {\n\tcase NFP_NET_CFG_VERSION_DP_NFD3:\n\t\tnn->dp.ops = &nfp_nfd3_ops;\n\t\tbreak;\n\tcase NFP_NET_CFG_VERSION_DP_NFDK:\n\t\tif (nn->fw_ver.major < 5) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"NFDK must use ABI 5 or newer, found: %d\\n\",\n\t\t\t\tnn->fw_ver.major);\n\t\t\terr = -EINVAL;\n\t\t\tgoto err_free_nn;\n\t\t}\n\t\tnn->dp.ops = &nfp_nfdk_ops;\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t\tgoto err_free_nn;\n\t}\n\n\tif ((dma_mask & nn->dp.ops->dma_mask) != dma_mask) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"DMA mask of loaded firmware: %llx, required DMA mask: %llx\\n\",\n\t\t\tnn->dp.ops->dma_mask, dma_mask);\n\t\terr = -EINVAL;\n\t\tgoto err_free_nn;\n\t}\n\n\tnn->max_tx_rings = max_tx_rings;\n\tnn->max_rx_rings = max_rx_rings;\n\n\tnn->dp.num_tx_rings = min_t(unsigned int,\n\t\t\t\t    max_tx_rings, num_online_cpus());\n\tnn->dp.num_rx_rings = min_t(unsigned int, max_rx_rings,\n\t\t\t\t netif_get_num_default_rss_queues());\n\n\tnn->dp.num_r_vecs = max(nn->dp.num_tx_rings, nn->dp.num_rx_rings);\n\tnn->dp.num_r_vecs = min_t(unsigned int,\n\t\t\t\t  nn->dp.num_r_vecs, num_online_cpus());\n\tnn->max_r_vecs = nn->dp.num_r_vecs;\n\n\tnn->dp.xsk_pools = kcalloc(nn->max_r_vecs, sizeof(nn->dp.xsk_pools),\n\t\t\t\t   GFP_KERNEL);\n\tif (!nn->dp.xsk_pools) {\n\t\terr = -ENOMEM;\n\t\tgoto err_free_nn;\n\t}\n\n\tnn->dp.txd_cnt = NFP_NET_TX_DESCS_DEFAULT;\n\tnn->dp.rxd_cnt = NFP_NET_RX_DESCS_DEFAULT;\n\n\tsema_init(&nn->bar_lock, 1);\n\n\tspin_lock_init(&nn->reconfig_lock);\n\tspin_lock_init(&nn->link_status_lock);\n\n\ttimer_setup(&nn->reconfig_timer, nfp_net_reconfig_timer, 0);\n\n\terr = nfp_net_tlv_caps_parse(&nn->pdev->dev, nn->dp.ctrl_bar,\n\t\t\t\t     &nn->tlv_caps);\n\tif (err)\n\t\tgoto err_free_nn;\n\n\terr = nfp_ccm_mbox_alloc(nn);\n\tif (err)\n\t\tgoto err_free_nn;\n\n\treturn nn;\n\nerr_free_nn:\n\tif (nn->dp.netdev)\n\t\tfree_netdev(nn->dp.netdev);\n\telse\n\t\tvfree(nn);\n\treturn ERR_PTR(err);\n}\n\n \nvoid nfp_net_free(struct nfp_net *nn)\n{\n\tWARN_ON(timer_pending(&nn->reconfig_timer) || nn->reconfig_posted);\n\tnfp_ccm_mbox_free(nn);\n\n\tkfree(nn->dp.xsk_pools);\n\tif (nn->dp.netdev)\n\t\tfree_netdev(nn->dp.netdev);\n\telse\n\t\tvfree(nn);\n}\n\n \nunsigned int nfp_net_rss_key_sz(struct nfp_net *nn)\n{\n\tswitch (nn->rss_hfunc) {\n\tcase ETH_RSS_HASH_TOP:\n\t\treturn NFP_NET_CFG_RSS_KEY_SZ;\n\tcase ETH_RSS_HASH_XOR:\n\t\treturn 0;\n\tcase ETH_RSS_HASH_CRC32:\n\t\treturn 4;\n\t}\n\n\tnn_warn(nn, \"Unknown hash function: %u\\n\", nn->rss_hfunc);\n\treturn 0;\n}\n\n \nstatic void nfp_net_rss_init(struct nfp_net *nn)\n{\n\tunsigned long func_bit, rss_cap_hfunc;\n\tu32 reg;\n\n\t \n\treg = nn_readl(nn, NFP_NET_CFG_RSS_CAP);\n\trss_cap_hfunc =\tFIELD_GET(NFP_NET_CFG_RSS_CAP_HFUNC, reg);\n\tif (!rss_cap_hfunc)\n\t\trss_cap_hfunc =\tFIELD_GET(NFP_NET_CFG_RSS_CAP_HFUNC,\n\t\t\t\t\t  NFP_NET_CFG_RSS_TOEPLITZ);\n\n\tfunc_bit = find_first_bit(&rss_cap_hfunc, NFP_NET_CFG_RSS_HFUNCS);\n\tif (func_bit == NFP_NET_CFG_RSS_HFUNCS) {\n\t\tdev_warn(nn->dp.dev,\n\t\t\t \"Bad RSS config, defaulting to Toeplitz hash\\n\");\n\t\tfunc_bit = ETH_RSS_HASH_TOP_BIT;\n\t}\n\tnn->rss_hfunc = 1 << func_bit;\n\n\tnetdev_rss_key_fill(nn->rss_key, nfp_net_rss_key_sz(nn));\n\n\tnfp_net_rss_init_itbl(nn);\n\n\t \n\tnn->rss_cfg = NFP_NET_CFG_RSS_IPV4_TCP |\n\t\t      NFP_NET_CFG_RSS_IPV6_TCP |\n\t\t      NFP_NET_CFG_RSS_IPV4_UDP |\n\t\t      NFP_NET_CFG_RSS_IPV6_UDP |\n\t\t      FIELD_PREP(NFP_NET_CFG_RSS_HFUNC, nn->rss_hfunc) |\n\t\t      NFP_NET_CFG_RSS_MASK;\n}\n\n \nstatic void nfp_net_irqmod_init(struct nfp_net *nn)\n{\n\tnn->rx_coalesce_usecs      = 50;\n\tnn->rx_coalesce_max_frames = 64;\n\tnn->tx_coalesce_usecs      = 50;\n\tnn->tx_coalesce_max_frames = 64;\n\n\tnn->rx_coalesce_adapt_on   = true;\n\tnn->tx_coalesce_adapt_on   = true;\n}\n\nstatic void nfp_net_netdev_init(struct nfp_net *nn)\n{\n\tstruct net_device *netdev = nn->dp.netdev;\n\n\tnfp_net_write_mac_addr(nn, nn->dp.netdev->dev_addr);\n\n\tnetdev->mtu = nn->dp.mtu;\n\n\t \n\tif (nn->cap & NFP_NET_CFG_CTRL_LIVE_ADDR)\n\t\tnetdev->priv_flags |= IFF_LIVE_ADDR_CHANGE;\n\n\tnetdev->hw_features = NETIF_F_HIGHDMA;\n\tif (nn->cap & NFP_NET_CFG_CTRL_RXCSUM_ANY) {\n\t\tnetdev->hw_features |= NETIF_F_RXCSUM;\n\t\tnn->dp.ctrl |= nn->cap & NFP_NET_CFG_CTRL_RXCSUM_ANY;\n\t}\n\tif (nn->cap & NFP_NET_CFG_CTRL_TXCSUM) {\n\t\tnetdev->hw_features |= NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM;\n\t\tnn->dp.ctrl |= NFP_NET_CFG_CTRL_TXCSUM;\n\t}\n\tif (nn->cap & NFP_NET_CFG_CTRL_GATHER) {\n\t\tnetdev->hw_features |= NETIF_F_SG;\n\t\tnn->dp.ctrl |= NFP_NET_CFG_CTRL_GATHER;\n\t}\n\tif ((nn->cap & NFP_NET_CFG_CTRL_LSO && nn->fw_ver.major > 2) ||\n\t    nn->cap & NFP_NET_CFG_CTRL_LSO2) {\n\t\tnetdev->hw_features |= NETIF_F_TSO | NETIF_F_TSO6;\n\t\tnn->dp.ctrl |= nn->cap & NFP_NET_CFG_CTRL_LSO2 ?:\n\t\t\t\t\t NFP_NET_CFG_CTRL_LSO;\n\t}\n\tif (nn->cap & NFP_NET_CFG_CTRL_RSS_ANY)\n\t\tnetdev->hw_features |= NETIF_F_RXHASH;\n\n#ifdef CONFIG_NFP_NET_IPSEC\n\tif (nn->cap_w1 & NFP_NET_CFG_CTRL_IPSEC)\n\t\tnetdev->hw_features |= NETIF_F_HW_ESP | NETIF_F_HW_ESP_TX_CSUM;\n#endif\n\n\tif (nn->cap & NFP_NET_CFG_CTRL_VXLAN) {\n\t\tif (nn->cap & NFP_NET_CFG_CTRL_LSO) {\n\t\t\tnetdev->hw_features |= NETIF_F_GSO_UDP_TUNNEL |\n\t\t\t\t\t       NETIF_F_GSO_UDP_TUNNEL_CSUM |\n\t\t\t\t\t       NETIF_F_GSO_PARTIAL;\n\t\t\tnetdev->gso_partial_features = NETIF_F_GSO_UDP_TUNNEL_CSUM;\n\t\t}\n\t\tnetdev->udp_tunnel_nic_info = &nfp_udp_tunnels;\n\t\tnn->dp.ctrl |= NFP_NET_CFG_CTRL_VXLAN;\n\t}\n\tif (nn->cap & NFP_NET_CFG_CTRL_NVGRE) {\n\t\tif (nn->cap & NFP_NET_CFG_CTRL_LSO)\n\t\t\tnetdev->hw_features |= NETIF_F_GSO_GRE;\n\t\tnn->dp.ctrl |= NFP_NET_CFG_CTRL_NVGRE;\n\t}\n\tif (nn->cap & (NFP_NET_CFG_CTRL_VXLAN | NFP_NET_CFG_CTRL_NVGRE))\n\t\tnetdev->hw_enc_features = netdev->hw_features;\n\n\tnetdev->vlan_features = netdev->hw_features;\n\n\tif (nn->cap & NFP_NET_CFG_CTRL_RXVLAN_ANY) {\n\t\tnetdev->hw_features |= NETIF_F_HW_VLAN_CTAG_RX;\n\t\tnn->dp.ctrl |= nn->cap & NFP_NET_CFG_CTRL_RXVLAN_V2 ?:\n\t\t\t       NFP_NET_CFG_CTRL_RXVLAN;\n\t}\n\tif (nn->cap & NFP_NET_CFG_CTRL_TXVLAN_ANY) {\n\t\tif (nn->cap & NFP_NET_CFG_CTRL_LSO2) {\n\t\t\tnn_warn(nn, \"Device advertises both TSO2 and TXVLAN. Refusing to enable TXVLAN.\\n\");\n\t\t} else {\n\t\t\tnetdev->hw_features |= NETIF_F_HW_VLAN_CTAG_TX;\n\t\t\tnn->dp.ctrl |= nn->cap & NFP_NET_CFG_CTRL_TXVLAN_V2 ?:\n\t\t\t\t       NFP_NET_CFG_CTRL_TXVLAN;\n\t\t}\n\t}\n\tif (nn->cap & NFP_NET_CFG_CTRL_CTAG_FILTER) {\n\t\tnetdev->hw_features |= NETIF_F_HW_VLAN_CTAG_FILTER;\n\t\tnn->dp.ctrl |= NFP_NET_CFG_CTRL_CTAG_FILTER;\n\t}\n\tif (nn->cap & NFP_NET_CFG_CTRL_RXQINQ) {\n\t\tnetdev->hw_features |= NETIF_F_HW_VLAN_STAG_RX;\n\t\tnn->dp.ctrl |= NFP_NET_CFG_CTRL_RXQINQ;\n\t}\n\n\tnetdev->features = netdev->hw_features;\n\n\tif (nfp_app_has_tc(nn->app) && nn->port)\n\t\tnetdev->hw_features |= NETIF_F_HW_TC;\n\n\t \n\tnetdev->features &= ~NETIF_F_HW_VLAN_STAG_RX;\n\tnn->dp.ctrl &= ~NFP_NET_CFG_CTRL_RXQINQ;\n\n\tnetdev->xdp_features = NETDEV_XDP_ACT_BASIC;\n\tif (nn->app && nn->app->type->id == NFP_APP_BPF_NIC)\n\t\tnetdev->xdp_features |= NETDEV_XDP_ACT_HW_OFFLOAD;\n\n\t \n\tswitch (nn->dp.ops->version) {\n\tcase NFP_NFD_VER_NFD3:\n\t\tnetdev->netdev_ops = &nfp_nfd3_netdev_ops;\n\t\tnetdev->xdp_features |= NETDEV_XDP_ACT_XSK_ZEROCOPY;\n\t\tbreak;\n\tcase NFP_NFD_VER_NFDK:\n\t\tnetdev->netdev_ops = &nfp_nfdk_netdev_ops;\n\t\tbreak;\n\t}\n\n\tnetdev->watchdog_timeo = msecs_to_jiffies(5 * 1000);\n\n\t \n\tnetdev->min_mtu = ETH_MIN_MTU;\n\tnetdev->max_mtu = nn->max_mtu;\n\n\tnetif_set_tso_max_segs(netdev, NFP_NET_LSO_MAX_SEGS);\n\n\tnetif_carrier_off(netdev);\n\n\tnfp_net_set_ethtool_ops(netdev);\n}\n\nstatic int nfp_net_read_caps(struct nfp_net *nn)\n{\n\t \n\tnn->cap = nn_readl(nn, NFP_NET_CFG_CAP);\n\tnn->cap_w1 = nn_readl(nn, NFP_NET_CFG_CAP_WORD1);\n\tnn->max_mtu = nn_readl(nn, NFP_NET_CFG_MAX_MTU);\n\n\t \n\tnn->dp.chained_metadata_format = nn->fw_ver.major == 4 ||\n\t\t\t\t\t !nn->dp.netdev ||\n\t\t\t\t\t !(nn->cap & NFP_NET_CFG_CTRL_RSS) ||\n\t\t\t\t\t nn->cap & NFP_NET_CFG_CTRL_CHAIN_META;\n\t \n\tif (nn->dp.chained_metadata_format && nn->fw_ver.major != 4)\n\t\tnn->cap &= ~NFP_NET_CFG_CTRL_RSS;\n\n\t \n\tif (nn->fw_ver.major >= 2) {\n\t\tu32 reg;\n\n\t\treg = nn_readl(nn, NFP_NET_CFG_RX_OFFSET);\n\t\tif (reg > NFP_NET_MAX_PREPEND) {\n\t\t\tnn_err(nn, \"Invalid rx offset: %d\\n\", reg);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tnn->dp.rx_offset = reg;\n\t} else {\n\t\tnn->dp.rx_offset = NFP_NET_RX_OFFSET;\n\t}\n\n\t \n\tnn->cap &= nn->dp.ops->cap_mask;\n\n\t \n\tif (!nn->dp.netdev)\n\t\tnn->cap &= nn->app->type->ctrl_cap_mask;\n\n\treturn 0;\n}\n\n \nint nfp_net_init(struct nfp_net *nn)\n{\n\tint err;\n\n\tnn->dp.rx_dma_dir = DMA_FROM_DEVICE;\n\n\terr = nfp_net_read_caps(nn);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (!nfp_net_is_data_vnic(nn) && nn->app->ctrl_mtu) {\n\t\tnn->dp.mtu = min(nn->app->ctrl_mtu, nn->max_mtu);\n\t} else if (nn->max_mtu < NFP_NET_DEFAULT_MTU) {\n\t\tnn->dp.mtu = nn->max_mtu;\n\t} else {\n\t\tnn->dp.mtu = NFP_NET_DEFAULT_MTU;\n\t}\n\tnn->dp.fl_bufsz = nfp_net_calc_fl_bufsz(&nn->dp);\n\n\tif (nfp_app_ctrl_uses_data_vnics(nn->app))\n\t\tnn->dp.ctrl |= nn->cap & NFP_NET_CFG_CTRL_CMSG_DATA;\n\n\tif (nn->cap & NFP_NET_CFG_CTRL_RSS_ANY) {\n\t\tnfp_net_rss_init(nn);\n\t\tnn->dp.ctrl |= nn->cap & NFP_NET_CFG_CTRL_RSS2 ?:\n\t\t\t\t\t NFP_NET_CFG_CTRL_RSS;\n\t}\n\n\t \n\tif (nn->cap & NFP_NET_CFG_CTRL_L2BC)\n\t\tnn->dp.ctrl |= NFP_NET_CFG_CTRL_L2BC;\n\n\t \n\tif (nn->cap & NFP_NET_CFG_CTRL_IRQMOD) {\n\t\tnfp_net_irqmod_init(nn);\n\t\tnn->dp.ctrl |= NFP_NET_CFG_CTRL_IRQMOD;\n\t}\n\n\t \n\tif (nn->cap & NFP_NET_CFG_CTRL_TXRWB)\n\t\tnn->dp.ctrl |= NFP_NET_CFG_CTRL_TXRWB;\n\n\tif (nn->cap_w1 & NFP_NET_CFG_CTRL_MCAST_FILTER)\n\t\tnn->dp.ctrl_w1 |= NFP_NET_CFG_CTRL_MCAST_FILTER;\n\n\t \n\tnn->qcp_cfg = nn->tx_bar + NFP_QCP_QUEUE_ADDR_SZ;\n\n\t \n\tnn_writel(nn, NFP_NET_CFG_CTRL, 0);\n\tnn_writeq(nn, NFP_NET_CFG_TXRS_ENABLE, 0);\n\tnn_writeq(nn, NFP_NET_CFG_RXRS_ENABLE, 0);\n\tnn_writel(nn, NFP_NET_CFG_CTRL_WORD1, 0);\n\terr = nfp_net_reconfig(nn, NFP_NET_CFG_UPDATE_RING |\n\t\t\t\t   NFP_NET_CFG_UPDATE_GEN);\n\tif (err)\n\t\treturn err;\n\n\tif (nn->dp.netdev) {\n\t\tnfp_net_netdev_init(nn);\n\n\t\terr = nfp_ccm_mbox_init(nn);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = nfp_net_tls_init(nn);\n\t\tif (err)\n\t\t\tgoto err_clean_mbox;\n\n\t\tnfp_net_ipsec_init(nn);\n\t}\n\n\tnfp_net_vecs_init(nn);\n\n\tif (!nn->dp.netdev)\n\t\treturn 0;\n\n\tspin_lock_init(&nn->mbox_amsg.lock);\n\tINIT_LIST_HEAD(&nn->mbox_amsg.list);\n\tINIT_WORK(&nn->mbox_amsg.work, nfp_net_mbox_amsg_work);\n\n\treturn register_netdev(nn->dp.netdev);\n\nerr_clean_mbox:\n\tnfp_ccm_mbox_clean(nn);\n\treturn err;\n}\n\n \nvoid nfp_net_clean(struct nfp_net *nn)\n{\n\tif (!nn->dp.netdev)\n\t\treturn;\n\n\tunregister_netdev(nn->dp.netdev);\n\tnfp_net_ipsec_clean(nn);\n\tnfp_ccm_mbox_clean(nn);\n\tflush_work(&nn->mbox_amsg.work);\n\tnfp_net_reconfig_wait_posted(nn);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}