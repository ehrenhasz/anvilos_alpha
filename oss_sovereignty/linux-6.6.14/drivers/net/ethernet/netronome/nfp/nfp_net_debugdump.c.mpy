{
  "module_name": "nfp_net_debugdump.c",
  "hash_id": "b93e50dfe745123dc19b08314bc709f6faf5740200c9ee216ab6459f057ed49a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/netronome/nfp/nfp_net_debugdump.c",
  "human_readable_source": "\n \n\n#include <linux/ethtool.h>\n#include <linux/vmalloc.h>\n\n#include \"nfp_asm.h\"\n#include \"nfp_main.h\"\n#include \"nfpcore/nfp.h\"\n#include \"nfpcore/nfp_nffw.h\"\n#include \"nfpcore/nfp6000/nfp6000.h\"\n\n#define NFP_DUMP_SPEC_RTSYM\t\"_abi_dump_spec\"\n\n#define ALIGN8(x)\tALIGN(x, 8)\n\nenum nfp_dumpspec_type {\n\tNFP_DUMPSPEC_TYPE_CPP_CSR = 0,\n\tNFP_DUMPSPEC_TYPE_XPB_CSR = 1,\n\tNFP_DUMPSPEC_TYPE_ME_CSR = 2,\n\tNFP_DUMPSPEC_TYPE_INDIRECT_ME_CSR = 3,\n\tNFP_DUMPSPEC_TYPE_RTSYM = 4,\n\tNFP_DUMPSPEC_TYPE_HWINFO = 5,\n\tNFP_DUMPSPEC_TYPE_FWNAME = 6,\n\tNFP_DUMPSPEC_TYPE_HWINFO_FIELD = 7,\n\tNFP_DUMPSPEC_TYPE_PROLOG = 10000,\n\tNFP_DUMPSPEC_TYPE_ERROR = 10001,\n};\n\n \n\n \nstruct nfp_dump_tl {\n\t__be32 type;\n\t__be32 length;\t \n\tchar data[];\n};\n\n \nstruct nfp_dumpspec_cpp_isl_id {\n\tu8 target;\n\tu8 action;\n\tu8 token;\n\tu8 island;\n};\n\nstruct nfp_dump_common_cpp {\n\tstruct nfp_dumpspec_cpp_isl_id cpp_id;\n\t__be32 offset;\t\t \n\t__be32 dump_length;\t \n};\n\n \nstruct nfp_dumpspec_csr {\n\tstruct nfp_dump_tl tl;\n\tstruct nfp_dump_common_cpp cpp;\n\t__be32 register_width;\t \n};\n\nstruct nfp_dumpspec_rtsym {\n\tstruct nfp_dump_tl tl;\n\tchar rtsym[];\n};\n\n \nstruct nfp_dump_csr {\n\tstruct nfp_dump_tl tl;\n\tstruct nfp_dump_common_cpp cpp;\n\t__be32 register_width;\t \n\t__be32 error;\t\t \n\t__be32 error_offset;\t \n};\n\nstruct nfp_dump_rtsym {\n\tstruct nfp_dump_tl tl;\n\tstruct nfp_dump_common_cpp cpp;\n\t__be32 error;\t\t \n\tu8 padded_name_length;\t \n\tchar rtsym[];\n\t \n};\n\nstruct nfp_dump_prolog {\n\tstruct nfp_dump_tl tl;\n\t__be32 dump_level;\n};\n\nstruct nfp_dump_error {\n\tstruct nfp_dump_tl tl;\n\t__be32 error;\n\tchar padding[4];\n\tchar spec[];\n};\n\n \nstruct nfp_level_size {\n\t__be32 requested_level;\t \n\tu32 total_size;\t\t \n};\n\n \nstruct nfp_dump_state {\n\t__be32 requested_level;\t \n\tu32 dumped_size;\t \n\tu32 buf_size;\t\t \n\tvoid *p;\t\t \n};\n\ntypedef int (*nfp_tlv_visit)(struct nfp_pf *pf, struct nfp_dump_tl *tl,\n\t\t\t     void *param);\n\nstatic int\nnfp_traverse_tlvs(struct nfp_pf *pf, void *data, u32 data_length, void *param,\n\t\t  nfp_tlv_visit tlv_visit)\n{\n\tlong long remaining = data_length;\n\tstruct nfp_dump_tl *tl;\n\tu32 total_tlv_size;\n\tvoid *p = data;\n\tint err;\n\n\twhile (remaining >= sizeof(*tl)) {\n\t\ttl = p;\n\t\tif (!tl->type && !tl->length)\n\t\t\tbreak;\n\n\t\tif (be32_to_cpu(tl->length) > remaining - sizeof(*tl))\n\t\t\treturn -EINVAL;\n\n\t\ttotal_tlv_size = sizeof(*tl) + be32_to_cpu(tl->length);\n\n\t\t \n\t\tif (total_tlv_size % 4 != 0)\n\t\t\treturn -EINVAL;\n\n\t\tp += total_tlv_size;\n\t\tremaining -= total_tlv_size;\n\t\terr = tlv_visit(pf, tl, param);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic u32 nfp_get_numeric_cpp_id(struct nfp_dumpspec_cpp_isl_id *cpp_id)\n{\n\treturn NFP_CPP_ISLAND_ID(cpp_id->target, cpp_id->action, cpp_id->token,\n\t\t\t\t cpp_id->island);\n}\n\nstruct nfp_dumpspec *\nnfp_net_dump_load_dumpspec(struct nfp_cpp *cpp, struct nfp_rtsym_table *rtbl)\n{\n\tconst struct nfp_rtsym *specsym;\n\tstruct nfp_dumpspec *dumpspec;\n\tint bytes_read;\n\tu64 sym_size;\n\n\tspecsym = nfp_rtsym_lookup(rtbl, NFP_DUMP_SPEC_RTSYM);\n\tif (!specsym)\n\t\treturn NULL;\n\tsym_size = nfp_rtsym_size(specsym);\n\n\t \n\tdumpspec = vmalloc(sizeof(*dumpspec) + sym_size);\n\tif (!dumpspec)\n\t\treturn NULL;\n\tdumpspec->size = sym_size;\n\n\tbytes_read = nfp_rtsym_read(cpp, specsym, 0, dumpspec->data, sym_size);\n\tif (bytes_read != sym_size) {\n\t\tvfree(dumpspec);\n\t\tnfp_warn(cpp, \"Debug dump specification read failed.\\n\");\n\t\treturn NULL;\n\t}\n\n\treturn dumpspec;\n}\n\nstatic int nfp_dump_error_tlv_size(struct nfp_dump_tl *spec)\n{\n\treturn ALIGN8(sizeof(struct nfp_dump_error) + sizeof(*spec) +\n\t\t      be32_to_cpu(spec->length));\n}\n\nstatic int nfp_calc_fwname_tlv_size(struct nfp_pf *pf)\n{\n\tu32 fwname_len = strlen(nfp_mip_name(pf->mip));\n\n\treturn sizeof(struct nfp_dump_tl) + ALIGN8(fwname_len + 1);\n}\n\nstatic int nfp_calc_hwinfo_field_sz(struct nfp_pf *pf, struct nfp_dump_tl *spec)\n{\n\tu32 tl_len, key_len;\n\tconst char *value;\n\n\ttl_len = be32_to_cpu(spec->length);\n\tkey_len = strnlen(spec->data, tl_len);\n\tif (key_len == tl_len)\n\t\treturn nfp_dump_error_tlv_size(spec);\n\n\tvalue = nfp_hwinfo_lookup(pf->hwinfo, spec->data);\n\tif (!value)\n\t\treturn nfp_dump_error_tlv_size(spec);\n\n\treturn sizeof(struct nfp_dump_tl) + ALIGN8(key_len + strlen(value) + 2);\n}\n\nstatic bool nfp_csr_spec_valid(struct nfp_dumpspec_csr *spec_csr)\n{\n\tu32 required_read_sz = sizeof(*spec_csr) - sizeof(spec_csr->tl);\n\tu32 available_sz = be32_to_cpu(spec_csr->tl.length);\n\tu32 reg_width;\n\n\tif (available_sz < required_read_sz)\n\t\treturn false;\n\n\treg_width = be32_to_cpu(spec_csr->register_width);\n\n\treturn reg_width == 32 || reg_width == 64;\n}\n\nstatic int\nnfp_calc_rtsym_dump_sz(struct nfp_pf *pf, struct nfp_dump_tl *spec)\n{\n\tstruct nfp_rtsym_table *rtbl = pf->rtbl;\n\tstruct nfp_dumpspec_rtsym *spec_rtsym;\n\tconst struct nfp_rtsym *sym;\n\tu32 tl_len, key_len;\n\n\tspec_rtsym = (struct nfp_dumpspec_rtsym *)spec;\n\ttl_len = be32_to_cpu(spec->length);\n\tkey_len = strnlen(spec_rtsym->rtsym, tl_len);\n\tif (key_len == tl_len)\n\t\treturn nfp_dump_error_tlv_size(spec);\n\n\tsym = nfp_rtsym_lookup(rtbl, spec_rtsym->rtsym);\n\tif (!sym)\n\t\treturn nfp_dump_error_tlv_size(spec);\n\n\treturn ALIGN8(offsetof(struct nfp_dump_rtsym, rtsym) + key_len + 1) +\n\t       ALIGN8(nfp_rtsym_size(sym));\n}\n\nstatic int\nnfp_add_tlv_size(struct nfp_pf *pf, struct nfp_dump_tl *tl, void *param)\n{\n\tstruct nfp_dumpspec_csr *spec_csr;\n\tu32 *size = param;\n\tu32 hwinfo_size;\n\n\tswitch (be32_to_cpu(tl->type)) {\n\tcase NFP_DUMPSPEC_TYPE_FWNAME:\n\t\t*size += nfp_calc_fwname_tlv_size(pf);\n\t\tbreak;\n\tcase NFP_DUMPSPEC_TYPE_CPP_CSR:\n\tcase NFP_DUMPSPEC_TYPE_XPB_CSR:\n\tcase NFP_DUMPSPEC_TYPE_ME_CSR:\n\t\tspec_csr = (struct nfp_dumpspec_csr *)tl;\n\t\tif (!nfp_csr_spec_valid(spec_csr))\n\t\t\t*size += nfp_dump_error_tlv_size(tl);\n\t\telse\n\t\t\t*size += ALIGN8(sizeof(struct nfp_dump_csr)) +\n\t\t\t\t ALIGN8(be32_to_cpu(spec_csr->cpp.dump_length));\n\t\tbreak;\n\tcase NFP_DUMPSPEC_TYPE_INDIRECT_ME_CSR:\n\t\tspec_csr = (struct nfp_dumpspec_csr *)tl;\n\t\tif (!nfp_csr_spec_valid(spec_csr))\n\t\t\t*size += nfp_dump_error_tlv_size(tl);\n\t\telse\n\t\t\t*size += ALIGN8(sizeof(struct nfp_dump_csr)) +\n\t\t\t\t ALIGN8(be32_to_cpu(spec_csr->cpp.dump_length) *\n\t\t\t\t\tNFP_IND_NUM_CONTEXTS);\n\t\tbreak;\n\tcase NFP_DUMPSPEC_TYPE_RTSYM:\n\t\t*size += nfp_calc_rtsym_dump_sz(pf, tl);\n\t\tbreak;\n\tcase NFP_DUMPSPEC_TYPE_HWINFO:\n\t\thwinfo_size = nfp_hwinfo_get_packed_str_size(pf->hwinfo);\n\t\t*size += sizeof(struct nfp_dump_tl) + ALIGN8(hwinfo_size);\n\t\tbreak;\n\tcase NFP_DUMPSPEC_TYPE_HWINFO_FIELD:\n\t\t*size += nfp_calc_hwinfo_field_sz(pf, tl);\n\t\tbreak;\n\tdefault:\n\t\t*size += nfp_dump_error_tlv_size(tl);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nnfp_calc_specific_level_size(struct nfp_pf *pf, struct nfp_dump_tl *dump_level,\n\t\t\t     void *param)\n{\n\tstruct nfp_level_size *lev_sz = param;\n\n\tif (dump_level->type != lev_sz->requested_level)\n\t\treturn 0;\n\n\treturn nfp_traverse_tlvs(pf, dump_level->data,\n\t\t\t\t be32_to_cpu(dump_level->length),\n\t\t\t\t &lev_sz->total_size, nfp_add_tlv_size);\n}\n\ns64 nfp_net_dump_calculate_size(struct nfp_pf *pf, struct nfp_dumpspec *spec,\n\t\t\t\tu32 flag)\n{\n\tstruct nfp_level_size lev_sz;\n\tint err;\n\n\tlev_sz.requested_level = cpu_to_be32(flag);\n\tlev_sz.total_size = ALIGN8(sizeof(struct nfp_dump_prolog));\n\n\terr = nfp_traverse_tlvs(pf, spec->data, spec->size, &lev_sz,\n\t\t\t\tnfp_calc_specific_level_size);\n\tif (err)\n\t\treturn err;\n\n\treturn lev_sz.total_size;\n}\n\nstatic int nfp_add_tlv(u32 type, u32 total_tlv_sz, struct nfp_dump_state *dump)\n{\n\tstruct nfp_dump_tl *tl = dump->p;\n\n\tif (total_tlv_sz > dump->buf_size)\n\t\treturn -ENOSPC;\n\n\tif (dump->buf_size - total_tlv_sz < dump->dumped_size)\n\t\treturn -ENOSPC;\n\n\ttl->type = cpu_to_be32(type);\n\ttl->length = cpu_to_be32(total_tlv_sz - sizeof(*tl));\n\n\tdump->dumped_size += total_tlv_sz;\n\tdump->p += total_tlv_sz;\n\n\treturn 0;\n}\n\nstatic int\nnfp_dump_error_tlv(struct nfp_dump_tl *spec, int error,\n\t\t   struct nfp_dump_state *dump)\n{\n\tstruct nfp_dump_error *dump_header = dump->p;\n\tu32 total_spec_size, total_size;\n\tint err;\n\n\ttotal_spec_size = sizeof(*spec) + be32_to_cpu(spec->length);\n\ttotal_size = ALIGN8(sizeof(*dump_header) + total_spec_size);\n\n\terr = nfp_add_tlv(NFP_DUMPSPEC_TYPE_ERROR, total_size, dump);\n\tif (err)\n\t\treturn err;\n\n\tdump_header->error = cpu_to_be32(error);\n\tmemcpy(dump_header->spec, spec, total_spec_size);\n\n\treturn 0;\n}\n\nstatic int nfp_dump_fwname(struct nfp_pf *pf, struct nfp_dump_state *dump)\n{\n\tstruct nfp_dump_tl *dump_header = dump->p;\n\tu32 fwname_len, total_size;\n\tconst char *fwname;\n\tint err;\n\n\tfwname = nfp_mip_name(pf->mip);\n\tfwname_len = strlen(fwname);\n\ttotal_size = sizeof(*dump_header) + ALIGN8(fwname_len + 1);\n\n\terr = nfp_add_tlv(NFP_DUMPSPEC_TYPE_FWNAME, total_size, dump);\n\tif (err)\n\t\treturn err;\n\n\tmemcpy(dump_header->data, fwname, fwname_len);\n\n\treturn 0;\n}\n\nstatic int\nnfp_dump_hwinfo(struct nfp_pf *pf, struct nfp_dump_tl *spec,\n\t\tstruct nfp_dump_state *dump)\n{\n\tstruct nfp_dump_tl *dump_header = dump->p;\n\tu32 hwinfo_size, total_size;\n\tchar *hwinfo;\n\tint err;\n\n\thwinfo = nfp_hwinfo_get_packed_strings(pf->hwinfo);\n\thwinfo_size = nfp_hwinfo_get_packed_str_size(pf->hwinfo);\n\ttotal_size = sizeof(*dump_header) + ALIGN8(hwinfo_size);\n\n\terr = nfp_add_tlv(NFP_DUMPSPEC_TYPE_HWINFO, total_size, dump);\n\tif (err)\n\t\treturn err;\n\n\tmemcpy(dump_header->data, hwinfo, hwinfo_size);\n\n\treturn 0;\n}\n\nstatic int nfp_dump_hwinfo_field(struct nfp_pf *pf, struct nfp_dump_tl *spec,\n\t\t\t\t struct nfp_dump_state *dump)\n{\n\tstruct nfp_dump_tl *dump_header = dump->p;\n\tu32 tl_len, key_len, val_len;\n\tconst char *key, *value;\n\tu32 total_size;\n\tint err;\n\n\ttl_len = be32_to_cpu(spec->length);\n\tkey_len = strnlen(spec->data, tl_len);\n\tif (key_len == tl_len)\n\t\treturn nfp_dump_error_tlv(spec, -EINVAL, dump);\n\n\tkey = spec->data;\n\tvalue = nfp_hwinfo_lookup(pf->hwinfo, key);\n\tif (!value)\n\t\treturn nfp_dump_error_tlv(spec, -ENOENT, dump);\n\n\tval_len = strlen(value);\n\ttotal_size = sizeof(*dump_header) + ALIGN8(key_len + val_len + 2);\n\terr = nfp_add_tlv(NFP_DUMPSPEC_TYPE_HWINFO_FIELD, total_size, dump);\n\tif (err)\n\t\treturn err;\n\n\tmemcpy(dump_header->data, key, key_len + 1);\n\tmemcpy(dump_header->data + key_len + 1, value, val_len + 1);\n\n\treturn 0;\n}\n\nstatic bool is_xpb_read(struct nfp_dumpspec_cpp_isl_id *cpp_id)\n{\n\treturn cpp_id->target == NFP_CPP_TARGET_ISLAND_XPB &&\n\t       cpp_id->action == 0 && cpp_id->token == 0;\n}\n\nstatic int\nnfp_dump_csr_range(struct nfp_pf *pf, struct nfp_dumpspec_csr *spec_csr,\n\t\t   struct nfp_dump_state *dump)\n{\n\tstruct nfp_dump_csr *dump_header = dump->p;\n\tu32 reg_sz, header_size, total_size;\n\tu32 cpp_rd_addr, max_rd_addr;\n\tint bytes_read;\n\tvoid *dest;\n\tu32 cpp_id;\n\tint err;\n\n\tif (!nfp_csr_spec_valid(spec_csr))\n\t\treturn nfp_dump_error_tlv(&spec_csr->tl, -EINVAL, dump);\n\n\treg_sz = be32_to_cpu(spec_csr->register_width) / BITS_PER_BYTE;\n\theader_size = ALIGN8(sizeof(*dump_header));\n\ttotal_size = header_size +\n\t\t     ALIGN8(be32_to_cpu(spec_csr->cpp.dump_length));\n\tdest = dump->p + header_size;\n\n\terr = nfp_add_tlv(be32_to_cpu(spec_csr->tl.type), total_size, dump);\n\tif (err)\n\t\treturn err;\n\n\tdump_header->cpp = spec_csr->cpp;\n\tdump_header->register_width = spec_csr->register_width;\n\n\tcpp_id = nfp_get_numeric_cpp_id(&spec_csr->cpp.cpp_id);\n\tcpp_rd_addr = be32_to_cpu(spec_csr->cpp.offset);\n\tmax_rd_addr = cpp_rd_addr + be32_to_cpu(spec_csr->cpp.dump_length);\n\n\twhile (cpp_rd_addr < max_rd_addr) {\n\t\tif (is_xpb_read(&spec_csr->cpp.cpp_id)) {\n\t\t\terr = nfp_xpb_readl(pf->cpp, cpp_rd_addr, (u32 *)dest);\n\t\t} else {\n\t\t\tbytes_read = nfp_cpp_read(pf->cpp, cpp_id, cpp_rd_addr,\n\t\t\t\t\t\t  dest, reg_sz);\n\t\t\terr = bytes_read == reg_sz ? 0 : -EIO;\n\t\t}\n\t\tif (err) {\n\t\t\tdump_header->error = cpu_to_be32(err);\n\t\t\tdump_header->error_offset = cpu_to_be32(cpp_rd_addr);\n\t\t\tbreak;\n\t\t}\n\t\tcpp_rd_addr += reg_sz;\n\t\tdest += reg_sz;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int\nnfp_read_indirect_csr(struct nfp_cpp *cpp,\n\t\t      struct nfp_dumpspec_cpp_isl_id cpp_params, u32 offset,\n\t\t      u32 reg_sz, u32 context, void *dest)\n{\n\tu32 csr_ctx_ptr_offs;\n\tu32 cpp_id;\n\tint result;\n\n\tcsr_ctx_ptr_offs = nfp_get_ind_csr_ctx_ptr_offs(offset);\n\tcpp_id = NFP_CPP_ISLAND_ID(cpp_params.target,\n\t\t\t\t   NFP_IND_ME_REFL_WR_SIG_INIT,\n\t\t\t\t   cpp_params.token, cpp_params.island);\n\tresult = nfp_cpp_writel(cpp, cpp_id, csr_ctx_ptr_offs, context);\n\tif (result)\n\t\treturn result;\n\n\tcpp_id = nfp_get_numeric_cpp_id(&cpp_params);\n\tresult = nfp_cpp_read(cpp, cpp_id, csr_ctx_ptr_offs, dest, reg_sz);\n\tif (result != reg_sz)\n\t\treturn result < 0 ? result : -EIO;\n\n\tresult = nfp_cpp_read(cpp, cpp_id, offset, dest, reg_sz);\n\tif (result != reg_sz)\n\t\treturn result < 0 ? result : -EIO;\n\n\treturn 0;\n}\n\nstatic int\nnfp_read_all_indirect_csr_ctx(struct nfp_cpp *cpp,\n\t\t\t      struct nfp_dumpspec_csr *spec_csr, u32 address,\n\t\t\t      u32 reg_sz, void *dest)\n{\n\tu32 ctx;\n\tint err;\n\n\tfor (ctx = 0; ctx < NFP_IND_NUM_CONTEXTS; ctx++) {\n\t\terr = nfp_read_indirect_csr(cpp, spec_csr->cpp.cpp_id, address,\n\t\t\t\t\t    reg_sz, ctx, dest + ctx * reg_sz);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nnfp_dump_indirect_csr_range(struct nfp_pf *pf,\n\t\t\t    struct nfp_dumpspec_csr *spec_csr,\n\t\t\t    struct nfp_dump_state *dump)\n{\n\tstruct nfp_dump_csr *dump_header = dump->p;\n\tu32 reg_sz, header_size, total_size;\n\tu32 cpp_rd_addr, max_rd_addr;\n\tu32 reg_data_length;\n\tvoid *dest;\n\tint err;\n\n\tif (!nfp_csr_spec_valid(spec_csr))\n\t\treturn nfp_dump_error_tlv(&spec_csr->tl, -EINVAL, dump);\n\n\treg_sz = be32_to_cpu(spec_csr->register_width) / BITS_PER_BYTE;\n\theader_size = ALIGN8(sizeof(*dump_header));\n\treg_data_length = be32_to_cpu(spec_csr->cpp.dump_length) *\n\t\t\t  NFP_IND_NUM_CONTEXTS;\n\ttotal_size = header_size + ALIGN8(reg_data_length);\n\tdest = dump->p + header_size;\n\n\terr = nfp_add_tlv(be32_to_cpu(spec_csr->tl.type), total_size, dump);\n\tif (err)\n\t\treturn err;\n\n\tdump_header->cpp = spec_csr->cpp;\n\tdump_header->register_width = spec_csr->register_width;\n\n\tcpp_rd_addr = be32_to_cpu(spec_csr->cpp.offset);\n\tmax_rd_addr = cpp_rd_addr + be32_to_cpu(spec_csr->cpp.dump_length);\n\twhile (cpp_rd_addr < max_rd_addr) {\n\t\terr = nfp_read_all_indirect_csr_ctx(pf->cpp, spec_csr,\n\t\t\t\t\t\t    cpp_rd_addr, reg_sz, dest);\n\t\tif (err) {\n\t\t\tdump_header->error = cpu_to_be32(err);\n\t\t\tdump_header->error_offset = cpu_to_be32(cpp_rd_addr);\n\t\t\tbreak;\n\t\t}\n\t\tcpp_rd_addr += reg_sz;\n\t\tdest += reg_sz * NFP_IND_NUM_CONTEXTS;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nnfp_dump_single_rtsym(struct nfp_pf *pf, struct nfp_dumpspec_rtsym *spec,\n\t\t      struct nfp_dump_state *dump)\n{\n\tstruct nfp_dump_rtsym *dump_header = dump->p;\n\tstruct nfp_dumpspec_cpp_isl_id cpp_params;\n\tstruct nfp_rtsym_table *rtbl = pf->rtbl;\n\tu32 header_size, total_size, sym_size;\n\tconst struct nfp_rtsym *sym;\n\tu32 tl_len, key_len;\n\tint bytes_read;\n\tvoid *dest;\n\tint err;\n\n\ttl_len = be32_to_cpu(spec->tl.length);\n\tkey_len = strnlen(spec->rtsym, tl_len);\n\tif (key_len == tl_len)\n\t\treturn nfp_dump_error_tlv(&spec->tl, -EINVAL, dump);\n\n\tsym = nfp_rtsym_lookup(rtbl, spec->rtsym);\n\tif (!sym)\n\t\treturn nfp_dump_error_tlv(&spec->tl, -ENOENT, dump);\n\n\tsym_size = nfp_rtsym_size(sym);\n\theader_size =\n\t\tALIGN8(offsetof(struct nfp_dump_rtsym, rtsym) + key_len + 1);\n\ttotal_size = header_size + ALIGN8(sym_size);\n\tdest = dump->p + header_size;\n\n\terr = nfp_add_tlv(be32_to_cpu(spec->tl.type), total_size, dump);\n\tif (err)\n\t\treturn err;\n\n\tdump_header->padded_name_length =\n\t\theader_size - offsetof(struct nfp_dump_rtsym, rtsym);\n\tmemcpy(dump_header->rtsym, spec->rtsym, key_len + 1);\n\tdump_header->cpp.dump_length = cpu_to_be32(sym_size);\n\n\tif (sym->type != NFP_RTSYM_TYPE_ABS) {\n\t\tcpp_params.target = sym->target;\n\t\tcpp_params.action = NFP_CPP_ACTION_RW;\n\t\tcpp_params.token  = 0;\n\t\tcpp_params.island = sym->domain;\n\t\tdump_header->cpp.cpp_id = cpp_params;\n\t\tdump_header->cpp.offset = cpu_to_be32(sym->addr);\n\t}\n\n\tbytes_read = nfp_rtsym_read(pf->cpp, sym, 0, dest, sym_size);\n\tif (bytes_read != sym_size) {\n\t\tif (bytes_read >= 0)\n\t\t\tbytes_read = -EIO;\n\t\tdump_header->error = cpu_to_be32(bytes_read);\n\t}\n\n\treturn 0;\n}\n\nstatic int\nnfp_dump_for_tlv(struct nfp_pf *pf, struct nfp_dump_tl *tl, void *param)\n{\n\tstruct nfp_dumpspec_rtsym *spec_rtsym;\n\tstruct nfp_dump_state *dump = param;\n\tstruct nfp_dumpspec_csr *spec_csr;\n\tint err;\n\n\tswitch (be32_to_cpu(tl->type)) {\n\tcase NFP_DUMPSPEC_TYPE_FWNAME:\n\t\terr = nfp_dump_fwname(pf, dump);\n\t\tif (err)\n\t\t\treturn err;\n\t\tbreak;\n\tcase NFP_DUMPSPEC_TYPE_CPP_CSR:\n\tcase NFP_DUMPSPEC_TYPE_XPB_CSR:\n\tcase NFP_DUMPSPEC_TYPE_ME_CSR:\n\t\tspec_csr = (struct nfp_dumpspec_csr *)tl;\n\t\terr = nfp_dump_csr_range(pf, spec_csr, dump);\n\t\tif (err)\n\t\t\treturn err;\n\t\tbreak;\n\tcase NFP_DUMPSPEC_TYPE_INDIRECT_ME_CSR:\n\t\tspec_csr = (struct nfp_dumpspec_csr *)tl;\n\t\terr = nfp_dump_indirect_csr_range(pf, spec_csr, dump);\n\t\tif (err)\n\t\t\treturn err;\n\t\tbreak;\n\tcase NFP_DUMPSPEC_TYPE_RTSYM:\n\t\tspec_rtsym = (struct nfp_dumpspec_rtsym *)tl;\n\t\terr = nfp_dump_single_rtsym(pf, spec_rtsym, dump);\n\t\tif (err)\n\t\t\treturn err;\n\t\tbreak;\n\tcase NFP_DUMPSPEC_TYPE_HWINFO:\n\t\terr = nfp_dump_hwinfo(pf, tl, dump);\n\t\tif (err)\n\t\t\treturn err;\n\t\tbreak;\n\tcase NFP_DUMPSPEC_TYPE_HWINFO_FIELD:\n\t\terr = nfp_dump_hwinfo_field(pf, tl, dump);\n\t\tif (err)\n\t\t\treturn err;\n\t\tbreak;\n\tdefault:\n\t\terr = nfp_dump_error_tlv(tl, -EOPNOTSUPP, dump);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nnfp_dump_specific_level(struct nfp_pf *pf, struct nfp_dump_tl *dump_level,\n\t\t\tvoid *param)\n{\n\tstruct nfp_dump_state *dump = param;\n\n\tif (dump_level->type != dump->requested_level)\n\t\treturn 0;\n\n\treturn nfp_traverse_tlvs(pf, dump_level->data,\n\t\t\t\t be32_to_cpu(dump_level->length), dump,\n\t\t\t\t nfp_dump_for_tlv);\n}\n\nstatic int nfp_dump_populate_prolog(struct nfp_dump_state *dump)\n{\n\tstruct nfp_dump_prolog *prolog = dump->p;\n\tu32 total_size;\n\tint err;\n\n\ttotal_size = ALIGN8(sizeof(*prolog));\n\n\terr = nfp_add_tlv(NFP_DUMPSPEC_TYPE_PROLOG, total_size, dump);\n\tif (err)\n\t\treturn err;\n\n\tprolog->dump_level = dump->requested_level;\n\n\treturn 0;\n}\n\nint nfp_net_dump_populate_buffer(struct nfp_pf *pf, struct nfp_dumpspec *spec,\n\t\t\t\t struct ethtool_dump *dump_param, void *dest)\n{\n\tstruct nfp_dump_state dump;\n\tint err;\n\n\tdump.requested_level = cpu_to_be32(dump_param->flag);\n\tdump.dumped_size = 0;\n\tdump.p = dest;\n\tdump.buf_size = dump_param->len;\n\n\terr = nfp_dump_populate_prolog(&dump);\n\tif (err)\n\t\treturn err;\n\n\terr = nfp_traverse_tlvs(pf, spec->data, spec->size, &dump,\n\t\t\t\tnfp_dump_specific_level);\n\tif (err)\n\t\treturn err;\n\n\t \n\tdump_param->len = dump.dumped_size;\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}