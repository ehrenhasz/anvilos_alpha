{
  "module_name": "nfp_net_sriov.c",
  "hash_id": "8bb56da316669e81d47011ce6cea27bc1fc716ec4aea8ea802a29dc3d5bcd82b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/netronome/nfp/nfp_net_sriov.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/errno.h>\n#include <linux/etherdevice.h>\n#include <linux/if_link.h>\n#include <linux/if_ether.h>\n\n#include \"nfpcore/nfp_cpp.h\"\n#include \"nfp_app.h\"\n#include \"nfp_main.h\"\n#include \"nfp_net_ctrl.h\"\n#include \"nfp_net.h\"\n#include \"nfp_net_sriov.h\"\n\nstatic int\nnfp_net_sriov_check(struct nfp_app *app, int vf, u16 cap, const char *msg, bool warn)\n{\n\tu16 cap_vf;\n\n\tif (!app || !app->pf->vfcfg_tbl2)\n\t\treturn -EOPNOTSUPP;\n\n\tcap_vf = readw(app->pf->vfcfg_tbl2 + NFP_NET_VF_CFG_MB_CAP);\n\tif ((cap_vf & cap) != cap) {\n\t\tif (warn)\n\t\t\tnfp_warn(app->pf->cpp, \"ndo_set_vf_%s not supported\\n\", msg);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (vf < 0 || vf >= app->pf->num_vfs) {\n\t\tif (warn)\n\t\t\tnfp_warn(app->pf->cpp, \"invalid VF id %d\\n\", vf);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nnfp_net_sriov_update(struct nfp_app *app, int vf, u16 update, const char *msg)\n{\n\tstruct nfp_net *nn;\n\tint ret;\n\n\t \n\twriteb(vf, app->pf->vfcfg_tbl2 + NFP_NET_VF_CFG_MB_VF_NUM);\n\twritew(update, app->pf->vfcfg_tbl2 + NFP_NET_VF_CFG_MB_UPD);\n\n\tnn = list_first_entry(&app->pf->vnics, struct nfp_net, vnic_list);\n\t \n\tret = nfp_net_reconfig(nn, NFP_NET_CFG_UPDATE_VF);\n\tif (ret)\n\t\treturn ret;\n\n\tret = readw(app->pf->vfcfg_tbl2 + NFP_NET_VF_CFG_MB_RET);\n\tif (ret)\n\t\tnfp_warn(app->pf->cpp,\n\t\t\t \"FW refused VF %s update with errno: %d\\n\", msg, ret);\n\treturn -ret;\n}\n\nint nfp_app_set_vf_mac(struct net_device *netdev, int vf, u8 *mac)\n{\n\tstruct nfp_app *app = nfp_app_from_netdev(netdev);\n\tunsigned int vf_offset;\n\tint err;\n\n\terr = nfp_net_sriov_check(app, vf, NFP_NET_VF_CFG_MB_CAP_MAC, \"mac\", true);\n\tif (err)\n\t\treturn err;\n\n\tif (is_multicast_ether_addr(mac)) {\n\t\tnfp_warn(app->pf->cpp,\n\t\t\t \"invalid Ethernet address %pM for VF id %d\\n\",\n\t\t\t mac, vf);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tvf_offset = NFP_NET_VF_CFG_MB_SZ + vf * NFP_NET_VF_CFG_SZ;\n\twritel(get_unaligned_be32(mac), app->pf->vfcfg_tbl2 + vf_offset);\n\twritew(get_unaligned_be16(mac + 4),\n\t       app->pf->vfcfg_tbl2 + vf_offset + NFP_NET_VF_CFG_MAC_LO);\n\n\terr = nfp_net_sriov_update(app, vf, NFP_NET_VF_CFG_MB_UPD_MAC, \"MAC\");\n\tif (!err)\n\t\tnfp_info(app->pf->cpp,\n\t\t\t \"MAC %pM set on VF %d, reload the VF driver to make this change effective.\\n\",\n\t\t\t mac, vf);\n\n\treturn err;\n}\n\nint nfp_app_set_vf_vlan(struct net_device *netdev, int vf, u16 vlan, u8 qos,\n\t\t\t__be16 vlan_proto)\n{\n\tstruct nfp_app *app = nfp_app_from_netdev(netdev);\n\tu16 update = NFP_NET_VF_CFG_MB_UPD_VLAN;\n\tbool is_proto_sup = true;\n\tunsigned int vf_offset;\n\tu32 vlan_tag;\n\tint err;\n\n\terr = nfp_net_sriov_check(app, vf, NFP_NET_VF_CFG_MB_CAP_VLAN, \"vlan\", true);\n\tif (err)\n\t\treturn err;\n\n\tif (!eth_type_vlan(vlan_proto))\n\t\treturn -EOPNOTSUPP;\n\n\tif (vlan > 4095 || qos > 7) {\n\t\tnfp_warn(app->pf->cpp,\n\t\t\t \"invalid vlan id or qos for VF id %d\\n\", vf);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\terr = nfp_net_sriov_check(app, vf, NFP_NET_VF_CFG_MB_CAP_VLAN_PROTO, \"vlan_proto\", true);\n\tif (err)\n\t\tis_proto_sup = false;\n\n\tif (vlan_proto != htons(ETH_P_8021Q)) {\n\t\tif (!is_proto_sup)\n\t\t\treturn -EOPNOTSUPP;\n\t\tupdate |= NFP_NET_VF_CFG_MB_UPD_VLAN_PROTO;\n\t}\n\n\t \n\tvlan_tag = FIELD_PREP(NFP_NET_VF_CFG_VLAN_VID, vlan) |\n\t\tFIELD_PREP(NFP_NET_VF_CFG_VLAN_QOS, qos);\n\n\t \n\tif (vlan_tag && is_proto_sup)\n\t\tvlan_tag |= FIELD_PREP(NFP_NET_VF_CFG_VLAN_PROT, ntohs(vlan_proto));\n\n\tvf_offset = NFP_NET_VF_CFG_MB_SZ + vf * NFP_NET_VF_CFG_SZ;\n\twritel(vlan_tag, app->pf->vfcfg_tbl2 + vf_offset + NFP_NET_VF_CFG_VLAN);\n\n\treturn nfp_net_sriov_update(app, vf, update, \"vlan\");\n}\n\nint nfp_app_set_vf_rate(struct net_device *netdev, int vf,\n\t\t\tint min_tx_rate, int max_tx_rate)\n{\n\tstruct nfp_app *app = nfp_app_from_netdev(netdev);\n\tu32 vf_offset, ratevalue;\n\tint err;\n\n\terr = nfp_net_sriov_check(app, vf, NFP_NET_VF_CFG_MB_CAP_RATE, \"rate\", true);\n\tif (err)\n\t\treturn err;\n\n\tif (max_tx_rate >= NFP_NET_VF_RATE_MAX ||\n\t    min_tx_rate >= NFP_NET_VF_RATE_MAX) {\n\t\tnfp_warn(app->cpp, \"tx-rate exceeds %d.\\n\",\n\t\t\t NFP_NET_VF_RATE_MAX);\n\t\treturn -EINVAL;\n\t}\n\n\tvf_offset = NFP_NET_VF_CFG_MB_SZ + vf * NFP_NET_VF_CFG_SZ;\n\tratevalue = FIELD_PREP(NFP_NET_VF_CFG_MAX_RATE,\n\t\t\t       max_tx_rate ? max_tx_rate :\n\t\t\t       NFP_NET_VF_RATE_MAX) |\n\t\t    FIELD_PREP(NFP_NET_VF_CFG_MIN_RATE, min_tx_rate);\n\n\twritel(ratevalue,\n\t       app->pf->vfcfg_tbl2 + vf_offset + NFP_NET_VF_CFG_RATE);\n\n\treturn nfp_net_sriov_update(app, vf, NFP_NET_VF_CFG_MB_UPD_RATE,\n\t\t\t\t    \"rate\");\n}\n\nint nfp_app_set_vf_spoofchk(struct net_device *netdev, int vf, bool enable)\n{\n\tstruct nfp_app *app = nfp_app_from_netdev(netdev);\n\tunsigned int vf_offset;\n\tu8 vf_ctrl;\n\tint err;\n\n\terr = nfp_net_sriov_check(app, vf, NFP_NET_VF_CFG_MB_CAP_SPOOF,\n\t\t\t\t  \"spoofchk\", true);\n\tif (err)\n\t\treturn err;\n\n\t \n\tvf_offset = NFP_NET_VF_CFG_MB_SZ + vf * NFP_NET_VF_CFG_SZ +\n\t\tNFP_NET_VF_CFG_CTRL;\n\tvf_ctrl = readb(app->pf->vfcfg_tbl2 + vf_offset);\n\tvf_ctrl &= ~NFP_NET_VF_CFG_CTRL_SPOOF;\n\tvf_ctrl |= FIELD_PREP(NFP_NET_VF_CFG_CTRL_SPOOF, enable);\n\twriteb(vf_ctrl, app->pf->vfcfg_tbl2 + vf_offset);\n\n\treturn nfp_net_sriov_update(app, vf, NFP_NET_VF_CFG_MB_UPD_SPOOF,\n\t\t\t\t    \"spoofchk\");\n}\n\nint nfp_app_set_vf_trust(struct net_device *netdev, int vf, bool enable)\n{\n\tstruct nfp_app *app = nfp_app_from_netdev(netdev);\n\tunsigned int vf_offset;\n\tu8 vf_ctrl;\n\tint err;\n\n\terr = nfp_net_sriov_check(app, vf, NFP_NET_VF_CFG_MB_CAP_TRUST,\n\t\t\t\t  \"trust\", true);\n\tif (err)\n\t\treturn err;\n\n\t \n\tvf_offset = NFP_NET_VF_CFG_MB_SZ + vf * NFP_NET_VF_CFG_SZ +\n\t\tNFP_NET_VF_CFG_CTRL;\n\tvf_ctrl = readb(app->pf->vfcfg_tbl2 + vf_offset);\n\tvf_ctrl &= ~NFP_NET_VF_CFG_CTRL_TRUST;\n\tvf_ctrl |= FIELD_PREP(NFP_NET_VF_CFG_CTRL_TRUST, enable);\n\twriteb(vf_ctrl, app->pf->vfcfg_tbl2 + vf_offset);\n\n\treturn nfp_net_sriov_update(app, vf, NFP_NET_VF_CFG_MB_UPD_TRUST,\n\t\t\t\t    \"trust\");\n}\n\nint nfp_app_set_vf_link_state(struct net_device *netdev, int vf,\n\t\t\t      int link_state)\n{\n\tstruct nfp_app *app = nfp_app_from_netdev(netdev);\n\tunsigned int vf_offset;\n\tu8 vf_ctrl;\n\tint err;\n\n\terr = nfp_net_sriov_check(app, vf, NFP_NET_VF_CFG_MB_CAP_LINK_STATE,\n\t\t\t\t  \"link_state\", true);\n\tif (err)\n\t\treturn err;\n\n\tswitch (link_state) {\n\tcase IFLA_VF_LINK_STATE_AUTO:\n\tcase IFLA_VF_LINK_STATE_ENABLE:\n\tcase IFLA_VF_LINK_STATE_DISABLE:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tvf_offset = NFP_NET_VF_CFG_MB_SZ + vf * NFP_NET_VF_CFG_SZ +\n\t\tNFP_NET_VF_CFG_CTRL;\n\tvf_ctrl = readb(app->pf->vfcfg_tbl2 + vf_offset);\n\tvf_ctrl &= ~NFP_NET_VF_CFG_CTRL_LINK_STATE;\n\tvf_ctrl |= FIELD_PREP(NFP_NET_VF_CFG_CTRL_LINK_STATE, link_state);\n\twriteb(vf_ctrl, app->pf->vfcfg_tbl2 + vf_offset);\n\n\treturn nfp_net_sriov_update(app, vf, NFP_NET_VF_CFG_MB_UPD_LINK_STATE,\n\t\t\t\t    \"link state\");\n}\n\nint nfp_app_get_vf_config(struct net_device *netdev, int vf,\n\t\t\t  struct ifla_vf_info *ivi)\n{\n\tstruct nfp_app *app = nfp_app_from_netdev(netdev);\n\tu32 vf_offset, mac_hi, rate;\n\tu32 vlan_tag;\n\tu16 mac_lo;\n\tu8 flags;\n\tint err;\n\n\terr = nfp_net_sriov_check(app, vf, 0, \"\", true);\n\tif (err)\n\t\treturn err;\n\n\tvf_offset = NFP_NET_VF_CFG_MB_SZ + vf * NFP_NET_VF_CFG_SZ;\n\n\tmac_hi = readl(app->pf->vfcfg_tbl2 + vf_offset);\n\tmac_lo = readw(app->pf->vfcfg_tbl2 + vf_offset + NFP_NET_VF_CFG_MAC_LO);\n\n\tflags = readb(app->pf->vfcfg_tbl2 + vf_offset + NFP_NET_VF_CFG_CTRL);\n\tvlan_tag = readl(app->pf->vfcfg_tbl2 + vf_offset + NFP_NET_VF_CFG_VLAN);\n\n\tmemset(ivi, 0, sizeof(*ivi));\n\tivi->vf = vf;\n\n\tput_unaligned_be32(mac_hi, &ivi->mac[0]);\n\tput_unaligned_be16(mac_lo, &ivi->mac[4]);\n\n\tivi->vlan = FIELD_GET(NFP_NET_VF_CFG_VLAN_VID, vlan_tag);\n\tivi->qos = FIELD_GET(NFP_NET_VF_CFG_VLAN_QOS, vlan_tag);\n\tif (!nfp_net_sriov_check(app, vf, NFP_NET_VF_CFG_MB_CAP_VLAN_PROTO, \"vlan_proto\", false))\n\t\tivi->vlan_proto = htons(FIELD_GET(NFP_NET_VF_CFG_VLAN_PROT, vlan_tag));\n\tivi->spoofchk = FIELD_GET(NFP_NET_VF_CFG_CTRL_SPOOF, flags);\n\tivi->trusted = FIELD_GET(NFP_NET_VF_CFG_CTRL_TRUST, flags);\n\tivi->linkstate = FIELD_GET(NFP_NET_VF_CFG_CTRL_LINK_STATE, flags);\n\n\terr = nfp_net_sriov_check(app, vf, NFP_NET_VF_CFG_MB_CAP_RATE, \"rate\", false);\n\tif (!err) {\n\t\trate = readl(app->pf->vfcfg_tbl2 + vf_offset +\n\t\t\t     NFP_NET_VF_CFG_RATE);\n\n\t\tivi->max_tx_rate = FIELD_GET(NFP_NET_VF_CFG_MAX_RATE, rate);\n\t\tivi->min_tx_rate = FIELD_GET(NFP_NET_VF_CFG_MIN_RATE, rate);\n\n\t\tif (ivi->max_tx_rate == NFP_NET_VF_RATE_MAX)\n\t\t\tivi->max_tx_rate = 0;\n\t\tif (ivi->min_tx_rate == NFP_NET_VF_RATE_MAX)\n\t\t\tivi->min_tx_rate = 0;\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}