{
  "module_name": "tls.c",
  "hash_id": "8cdb29763729fbe4c0bc37a6973a8dedd270ec4081bc9e9726fb0e97d3c4a3d8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/netronome/nfp/crypto/tls.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/ipv6.h>\n#include <linux/skbuff.h>\n#include <linux/string.h>\n#include <net/inet6_hashtables.h>\n#include <net/tls.h>\n\n#include \"../ccm.h\"\n#include \"../nfp_net.h\"\n#include \"crypto.h\"\n#include \"fw.h\"\n\n#define NFP_NET_TLS_CCM_MBOX_OPS_MASK\t\t\\\n\t(BIT(NFP_CCM_TYPE_CRYPTO_RESET) |\t\\\n\t BIT(NFP_CCM_TYPE_CRYPTO_ADD) |\t\t\\\n\t BIT(NFP_CCM_TYPE_CRYPTO_DEL) |\t\t\\\n\t BIT(NFP_CCM_TYPE_CRYPTO_UPDATE))\n\n#define NFP_NET_TLS_OPCODE_MASK_RX\t\t\t\\\n\tBIT(NFP_NET_CRYPTO_OP_TLS_1_2_AES_GCM_128_DEC)\n\n#define NFP_NET_TLS_OPCODE_MASK_TX\t\t\t\\\n\tBIT(NFP_NET_CRYPTO_OP_TLS_1_2_AES_GCM_128_ENC)\n\n#define NFP_NET_TLS_OPCODE_MASK\t\t\t\t\t\t\\\n\t(NFP_NET_TLS_OPCODE_MASK_RX | NFP_NET_TLS_OPCODE_MASK_TX)\n\nstatic void nfp_net_crypto_set_op(struct nfp_net *nn, u8 opcode, bool on)\n{\n\tu32 off, val;\n\n\toff = nn->tlv_caps.crypto_enable_off + round_down(opcode / 8, 4);\n\n\tval = nn_readl(nn, off);\n\tif (on)\n\t\tval |= BIT(opcode & 31);\n\telse\n\t\tval &= ~BIT(opcode & 31);\n\tnn_writel(nn, off, val);\n}\n\nstatic bool\n__nfp_net_tls_conn_cnt_changed(struct nfp_net *nn, int add,\n\t\t\t       enum tls_offload_ctx_dir direction)\n{\n\tu8 opcode;\n\tint cnt;\n\n\tif (direction == TLS_OFFLOAD_CTX_DIR_TX) {\n\t\topcode = NFP_NET_CRYPTO_OP_TLS_1_2_AES_GCM_128_ENC;\n\t\tnn->ktls_tx_conn_cnt += add;\n\t\tcnt = nn->ktls_tx_conn_cnt;\n\t\tnn->dp.ktls_tx = !!nn->ktls_tx_conn_cnt;\n\t} else {\n\t\topcode = NFP_NET_CRYPTO_OP_TLS_1_2_AES_GCM_128_DEC;\n\t\tnn->ktls_rx_conn_cnt += add;\n\t\tcnt = nn->ktls_rx_conn_cnt;\n\t}\n\n\t \n\tif (cnt > 1)\n\t\treturn false;\n\n\tnfp_net_crypto_set_op(nn, opcode, cnt);\n\treturn true;\n}\n\nstatic int\nnfp_net_tls_conn_cnt_changed(struct nfp_net *nn, int add,\n\t\t\t     enum tls_offload_ctx_dir direction)\n{\n\tint ret = 0;\n\n\t \n\tnn_ctrl_bar_lock(nn);\n\tif (__nfp_net_tls_conn_cnt_changed(nn, add, direction)) {\n\t\tret = __nfp_net_reconfig(nn, NFP_NET_CFG_UPDATE_CRYPTO);\n\t\t \n\t\tif (ret)\n\t\t\t__nfp_net_tls_conn_cnt_changed(nn, -add, direction);\n\t}\n\tnn_ctrl_bar_unlock(nn);\n\n\treturn ret;\n}\n\nstatic int\nnfp_net_tls_conn_add(struct nfp_net *nn, enum tls_offload_ctx_dir direction)\n{\n\treturn nfp_net_tls_conn_cnt_changed(nn, 1, direction);\n}\n\nstatic int\nnfp_net_tls_conn_remove(struct nfp_net *nn, enum tls_offload_ctx_dir direction)\n{\n\treturn nfp_net_tls_conn_cnt_changed(nn, -1, direction);\n}\n\nstatic struct sk_buff *\nnfp_net_tls_alloc_simple(struct nfp_net *nn, size_t req_sz, gfp_t flags)\n{\n\treturn nfp_ccm_mbox_msg_alloc(nn, req_sz,\n\t\t\t\t      sizeof(struct nfp_crypto_reply_simple),\n\t\t\t\t      flags);\n}\n\nstatic int\nnfp_net_tls_communicate_simple(struct nfp_net *nn, struct sk_buff *skb,\n\t\t\t       const char *name, enum nfp_ccm_type type)\n{\n\tstruct nfp_crypto_reply_simple *reply;\n\tint err;\n\n\terr = __nfp_ccm_mbox_communicate(nn, skb, type,\n\t\t\t\t\t sizeof(*reply), sizeof(*reply),\n\t\t\t\t\t type == NFP_CCM_TYPE_CRYPTO_DEL);\n\tif (err) {\n\t\tnn_dp_warn(&nn->dp, \"failed to %s TLS: %d\\n\", name, err);\n\t\treturn err;\n\t}\n\n\treply = (void *)skb->data;\n\terr = -be32_to_cpu(reply->error);\n\tif (err)\n\t\tnn_dp_warn(&nn->dp, \"failed to %s TLS, fw replied: %d\\n\",\n\t\t\t   name, err);\n\tdev_consume_skb_any(skb);\n\n\treturn err;\n}\n\nstatic void nfp_net_tls_del_fw(struct nfp_net *nn, __be32 *fw_handle)\n{\n\tstruct nfp_crypto_req_del *req;\n\tstruct sk_buff *skb;\n\n\tskb = nfp_net_tls_alloc_simple(nn, sizeof(*req), GFP_KERNEL);\n\tif (!skb)\n\t\treturn;\n\n\treq = (void *)skb->data;\n\treq->ep_id = 0;\n\tmemcpy(req->handle, fw_handle, sizeof(req->handle));\n\n\tnfp_net_tls_communicate_simple(nn, skb, \"delete\",\n\t\t\t\t       NFP_CCM_TYPE_CRYPTO_DEL);\n}\n\nstatic void\nnfp_net_tls_set_ipver_vlan(struct nfp_crypto_req_add_front *front, u8 ipver)\n{\n\tfront->ipver_vlan = cpu_to_be16(FIELD_PREP(NFP_NET_TLS_IPVER, ipver) |\n\t\t\t\t\tFIELD_PREP(NFP_NET_TLS_VLAN,\n\t\t\t\t\t\t   NFP_NET_TLS_VLAN_UNUSED));\n}\n\nstatic void\nnfp_net_tls_assign_conn_id(struct nfp_net *nn,\n\t\t\t   struct nfp_crypto_req_add_front *front)\n{\n\tu32 len;\n\tu64 id;\n\n\tid = atomic64_inc_return(&nn->ktls_conn_id_gen);\n\tlen = front->key_len - NFP_NET_TLS_NON_ADDR_KEY_LEN;\n\n\tmemcpy(front->l3_addrs, &id, sizeof(id));\n\tmemset(front->l3_addrs + sizeof(id), 0, len - sizeof(id));\n}\n\nstatic struct nfp_crypto_req_add_back *\nnfp_net_tls_set_ipv4(struct nfp_net *nn, struct nfp_crypto_req_add_v4 *req,\n\t\t     struct sock *sk, int direction)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\n\treq->front.key_len += sizeof(__be32) * 2;\n\n\tif (direction == TLS_OFFLOAD_CTX_DIR_TX) {\n\t\tnfp_net_tls_assign_conn_id(nn, &req->front);\n\t} else {\n\t\treq->src_ip = inet->inet_daddr;\n\t\treq->dst_ip = inet->inet_saddr;\n\t}\n\n\treturn &req->back;\n}\n\nstatic struct nfp_crypto_req_add_back *\nnfp_net_tls_set_ipv6(struct nfp_net *nn, struct nfp_crypto_req_add_v6 *req,\n\t\t     struct sock *sk, int direction)\n{\n#if IS_ENABLED(CONFIG_IPV6)\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\n\treq->front.key_len += sizeof(struct in6_addr) * 2;\n\n\tif (direction == TLS_OFFLOAD_CTX_DIR_TX) {\n\t\tnfp_net_tls_assign_conn_id(nn, &req->front);\n\t} else {\n\t\tmemcpy(req->src_ip, &sk->sk_v6_daddr, sizeof(req->src_ip));\n\t\tmemcpy(req->dst_ip, &np->saddr, sizeof(req->dst_ip));\n\t}\n\n#endif\n\treturn &req->back;\n}\n\nstatic void\nnfp_net_tls_set_l4(struct nfp_crypto_req_add_front *front,\n\t\t   struct nfp_crypto_req_add_back *back, struct sock *sk,\n\t\t   int direction)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\n\tfront->l4_proto = IPPROTO_TCP;\n\n\tif (direction == TLS_OFFLOAD_CTX_DIR_TX) {\n\t\tback->src_port = 0;\n\t\tback->dst_port = 0;\n\t} else {\n\t\tback->src_port = inet->inet_dport;\n\t\tback->dst_port = inet->inet_sport;\n\t}\n}\n\nstatic u8 nfp_tls_1_2_dir_to_opcode(enum tls_offload_ctx_dir direction)\n{\n\tswitch (direction) {\n\tcase TLS_OFFLOAD_CTX_DIR_TX:\n\t\treturn NFP_NET_CRYPTO_OP_TLS_1_2_AES_GCM_128_ENC;\n\tcase TLS_OFFLOAD_CTX_DIR_RX:\n\t\treturn NFP_NET_CRYPTO_OP_TLS_1_2_AES_GCM_128_DEC;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\treturn 0;\n\t}\n}\n\nstatic bool\nnfp_net_cipher_supported(struct nfp_net *nn, u16 cipher_type,\n\t\t\t enum tls_offload_ctx_dir direction)\n{\n\tu8 bit;\n\n\tswitch (cipher_type) {\n\tcase TLS_CIPHER_AES_GCM_128:\n\t\tif (direction == TLS_OFFLOAD_CTX_DIR_TX)\n\t\t\tbit = NFP_NET_CRYPTO_OP_TLS_1_2_AES_GCM_128_ENC;\n\t\telse\n\t\t\tbit = NFP_NET_CRYPTO_OP_TLS_1_2_AES_GCM_128_DEC;\n\t\tbreak;\n\tdefault:\n\t\treturn false;\n\t}\n\n\treturn nn->tlv_caps.crypto_ops & BIT(bit);\n}\n\nstatic int\nnfp_net_tls_add(struct net_device *netdev, struct sock *sk,\n\t\tenum tls_offload_ctx_dir direction,\n\t\tstruct tls_crypto_info *crypto_info,\n\t\tu32 start_offload_tcp_sn)\n{\n\tstruct tls12_crypto_info_aes_gcm_128 *tls_ci;\n\tstruct nfp_net *nn = netdev_priv(netdev);\n\tstruct nfp_crypto_req_add_front *front;\n\tstruct nfp_net_tls_offload_ctx *ntls;\n\tstruct nfp_crypto_req_add_back *back;\n\tstruct nfp_crypto_reply_add *reply;\n\tstruct sk_buff *skb;\n\tsize_t req_sz;\n\tvoid *req;\n\tbool ipv6;\n\tint err;\n\n\tBUILD_BUG_ON(sizeof(struct nfp_net_tls_offload_ctx) >\n\t\t     TLS_DRIVER_STATE_SIZE_TX);\n\tBUILD_BUG_ON(offsetof(struct nfp_net_tls_offload_ctx, rx_end) >\n\t\t     TLS_DRIVER_STATE_SIZE_RX);\n\n\tif (!nfp_net_cipher_supported(nn, crypto_info->cipher_type, direction))\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (sk->sk_family) {\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase AF_INET6:\n\t\tif (ipv6_only_sock(sk) ||\n\t\t    ipv6_addr_type(&sk->sk_v6_daddr) != IPV6_ADDR_MAPPED) {\n\t\t\treq_sz = sizeof(struct nfp_crypto_req_add_v6);\n\t\t\tipv6 = true;\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n#endif\n\tcase AF_INET:\n\t\treq_sz = sizeof(struct nfp_crypto_req_add_v4);\n\t\tipv6 = false;\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\terr = nfp_net_tls_conn_add(nn, direction);\n\tif (err)\n\t\treturn err;\n\n\tskb = nfp_ccm_mbox_msg_alloc(nn, req_sz, sizeof(*reply), GFP_KERNEL);\n\tif (!skb) {\n\t\terr = -ENOMEM;\n\t\tgoto err_conn_remove;\n\t}\n\n\tfront = (void *)skb->data;\n\tfront->ep_id = 0;\n\tfront->key_len = NFP_NET_TLS_NON_ADDR_KEY_LEN;\n\tfront->opcode = nfp_tls_1_2_dir_to_opcode(direction);\n\tmemset(front->resv, 0, sizeof(front->resv));\n\n\tnfp_net_tls_set_ipver_vlan(front, ipv6 ? 6 : 4);\n\n\treq = (void *)skb->data;\n\tif (ipv6)\n\t\tback = nfp_net_tls_set_ipv6(nn, req, sk, direction);\n\telse\n\t\tback = nfp_net_tls_set_ipv4(nn, req, sk, direction);\n\n\tnfp_net_tls_set_l4(front, back, sk, direction);\n\n\tback->counter = 0;\n\tback->tcp_seq = cpu_to_be32(start_offload_tcp_sn);\n\n\ttls_ci = (struct tls12_crypto_info_aes_gcm_128 *)crypto_info;\n\tmemcpy(back->key, tls_ci->key, TLS_CIPHER_AES_GCM_128_KEY_SIZE);\n\tmemset(&back->key[TLS_CIPHER_AES_GCM_128_KEY_SIZE / 4], 0,\n\t       sizeof(back->key) - TLS_CIPHER_AES_GCM_128_KEY_SIZE);\n\tmemcpy(back->iv, tls_ci->iv, TLS_CIPHER_AES_GCM_128_IV_SIZE);\n\tmemcpy(&back->salt, tls_ci->salt, TLS_CIPHER_AES_GCM_128_SALT_SIZE);\n\tmemcpy(back->rec_no, tls_ci->rec_seq, sizeof(tls_ci->rec_seq));\n\n\t \n\tskb_get(skb);\n\n\terr = nfp_ccm_mbox_communicate(nn, skb, NFP_CCM_TYPE_CRYPTO_ADD,\n\t\t\t\t       sizeof(*reply), sizeof(*reply));\n\treply = (void *)skb->data;\n\n\t \n\tif (!WARN_ON_ONCE((u8 *)back < skb->head ||\n\t\t\t  (u8 *)back > skb_end_pointer(skb)) &&\n\t    !WARN_ON_ONCE((u8 *)&reply[1] > (u8 *)back))\n\t\tmemzero_explicit(back, sizeof(*back));\n\tdev_consume_skb_any(skb);  \n\n\tif (err) {\n\t\tnn_dp_warn(&nn->dp, \"failed to add TLS: %d (%d)\\n\",\n\t\t\t   err, direction == TLS_OFFLOAD_CTX_DIR_TX);\n\t\t \n\t\tgoto err_conn_remove;\n\t}\n\n\terr = -be32_to_cpu(reply->error);\n\tif (err) {\n\t\tif (err == -ENOSPC) {\n\t\t\tif (!atomic_fetch_inc(&nn->ktls_no_space))\n\t\t\t\tnn_info(nn, \"HW TLS table full\\n\");\n\t\t} else {\n\t\t\tnn_dp_warn(&nn->dp,\n\t\t\t\t   \"failed to add TLS, FW replied: %d\\n\", err);\n\t\t}\n\t\tgoto err_free_skb;\n\t}\n\n\tif (!reply->handle[0] && !reply->handle[1]) {\n\t\tnn_dp_warn(&nn->dp, \"FW returned NULL handle\\n\");\n\t\terr = -EINVAL;\n\t\tgoto err_fw_remove;\n\t}\n\n\tntls = tls_driver_ctx(sk, direction);\n\tmemcpy(ntls->fw_handle, reply->handle, sizeof(ntls->fw_handle));\n\tif (direction == TLS_OFFLOAD_CTX_DIR_TX)\n\t\tntls->next_seq = start_offload_tcp_sn;\n\tdev_consume_skb_any(skb);\n\n\tif (direction == TLS_OFFLOAD_CTX_DIR_TX)\n\t\treturn 0;\n\n\tif (!nn->tlv_caps.tls_resync_ss)\n\t\ttls_offload_rx_resync_set_type(sk, TLS_OFFLOAD_SYNC_TYPE_CORE_NEXT_HINT);\n\n\treturn 0;\n\nerr_fw_remove:\n\tnfp_net_tls_del_fw(nn, reply->handle);\nerr_free_skb:\n\tdev_consume_skb_any(skb);\nerr_conn_remove:\n\tnfp_net_tls_conn_remove(nn, direction);\n\treturn err;\n}\n\nstatic void\nnfp_net_tls_del(struct net_device *netdev, struct tls_context *tls_ctx,\n\t\tenum tls_offload_ctx_dir direction)\n{\n\tstruct nfp_net *nn = netdev_priv(netdev);\n\tstruct nfp_net_tls_offload_ctx *ntls;\n\n\tnfp_net_tls_conn_remove(nn, direction);\n\n\tntls = __tls_driver_ctx(tls_ctx, direction);\n\tnfp_net_tls_del_fw(nn, ntls->fw_handle);\n}\n\nstatic int\nnfp_net_tls_resync(struct net_device *netdev, struct sock *sk, u32 seq,\n\t\t   u8 *rcd_sn, enum tls_offload_ctx_dir direction)\n{\n\tstruct nfp_net *nn = netdev_priv(netdev);\n\tstruct nfp_net_tls_offload_ctx *ntls;\n\tstruct nfp_crypto_req_update *req;\n\tenum nfp_ccm_type type;\n\tstruct sk_buff *skb;\n\tgfp_t flags;\n\tint err;\n\n\tflags = direction == TLS_OFFLOAD_CTX_DIR_TX ? GFP_KERNEL : GFP_ATOMIC;\n\tskb = nfp_net_tls_alloc_simple(nn, sizeof(*req), flags);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tntls = tls_driver_ctx(sk, direction);\n\treq = (void *)skb->data;\n\treq->ep_id = 0;\n\treq->opcode = nfp_tls_1_2_dir_to_opcode(direction);\n\tmemset(req->resv, 0, sizeof(req->resv));\n\tmemcpy(req->handle, ntls->fw_handle, sizeof(ntls->fw_handle));\n\treq->tcp_seq = cpu_to_be32(seq);\n\tmemcpy(req->rec_no, rcd_sn, sizeof(req->rec_no));\n\n\ttype = NFP_CCM_TYPE_CRYPTO_UPDATE;\n\tif (direction == TLS_OFFLOAD_CTX_DIR_TX) {\n\t\terr = nfp_net_tls_communicate_simple(nn, skb, \"sync\", type);\n\t\tif (err)\n\t\t\treturn err;\n\t\tntls->next_seq = seq;\n\t} else {\n\t\tif (nn->tlv_caps.tls_resync_ss)\n\t\t\ttype = NFP_CCM_TYPE_CRYPTO_RESYNC;\n\t\tnfp_ccm_mbox_post(nn, skb, type,\n\t\t\t\t  sizeof(struct nfp_crypto_reply_simple));\n\t\tatomic_inc(&nn->ktls_rx_resync_sent);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct tlsdev_ops nfp_net_tls_ops = {\n\t.tls_dev_add = nfp_net_tls_add,\n\t.tls_dev_del = nfp_net_tls_del,\n\t.tls_dev_resync = nfp_net_tls_resync,\n};\n\nint nfp_net_tls_rx_resync_req(struct net_device *netdev,\n\t\t\t      struct nfp_net_tls_resync_req *req,\n\t\t\t      void *pkt, unsigned int pkt_len)\n{\n\tstruct nfp_net *nn = netdev_priv(netdev);\n\tstruct nfp_net_tls_offload_ctx *ntls;\n\tstruct net *net = dev_net(netdev);\n\tstruct ipv6hdr *ipv6h;\n\tstruct tcphdr *th;\n\tstruct iphdr *iph;\n\tstruct sock *sk;\n\t__be32 tcp_seq;\n\tint err;\n\n\tiph = pkt + req->l3_offset;\n\tipv6h = pkt + req->l3_offset;\n\tth = pkt + req->l4_offset;\n\n\tif ((u8 *)&th[1] > (u8 *)pkt + pkt_len) {\n\t\tnetdev_warn_once(netdev, \"invalid TLS RX resync request (l3_off: %hhu l4_off: %hhu pkt_len: %u)\\n\",\n\t\t\t\t req->l3_offset, req->l4_offset, pkt_len);\n\t\terr = -EINVAL;\n\t\tgoto err_cnt_ign;\n\t}\n\n\tswitch (ipv6h->version) {\n\tcase 4:\n\t\tsk = inet_lookup_established(net, net->ipv4.tcp_death_row.hashinfo,\n\t\t\t\t\t     iph->saddr, th->source, iph->daddr,\n\t\t\t\t\t     th->dest, netdev->ifindex);\n\t\tbreak;\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase 6:\n\t\tsk = __inet6_lookup_established(net, net->ipv4.tcp_death_row.hashinfo,\n\t\t\t\t\t\t&ipv6h->saddr, th->source,\n\t\t\t\t\t\t&ipv6h->daddr, ntohs(th->dest),\n\t\t\t\t\t\tnetdev->ifindex, 0);\n\t\tbreak;\n#endif\n\tdefault:\n\t\tnetdev_warn_once(netdev, \"invalid TLS RX resync request (l3_off: %hhu l4_off: %hhu ipver: %u)\\n\",\n\t\t\t\t req->l3_offset, req->l4_offset, iph->version);\n\t\terr = -EINVAL;\n\t\tgoto err_cnt_ign;\n\t}\n\n\terr = 0;\n\tif (!sk)\n\t\tgoto err_cnt_ign;\n\tif (!tls_is_sk_rx_device_offloaded(sk) ||\n\t    sk->sk_shutdown & RCV_SHUTDOWN)\n\t\tgoto err_put_sock;\n\n\tntls = tls_driver_ctx(sk, TLS_OFFLOAD_CTX_DIR_RX);\n\t \n\tif (memchr_inv(&req->fw_handle, 0, sizeof(req->fw_handle)) &&\n\t    memcmp(&req->fw_handle, &ntls->fw_handle, sizeof(ntls->fw_handle)))\n\t\tgoto err_put_sock;\n\n\t \n\tmemcpy(&tcp_seq, &req->tcp_seq, sizeof(tcp_seq));\n\ttls_offload_rx_resync_request(sk, tcp_seq);\n\tatomic_inc(&nn->ktls_rx_resync_req);\n\n\tsock_gen_put(sk);\n\treturn 0;\n\nerr_put_sock:\n\tsock_gen_put(sk);\nerr_cnt_ign:\n\tatomic_inc(&nn->ktls_rx_resync_ign);\n\treturn err;\n}\n\nstatic int nfp_net_tls_reset(struct nfp_net *nn)\n{\n\tstruct nfp_crypto_req_reset *req;\n\tstruct sk_buff *skb;\n\n\tskb = nfp_net_tls_alloc_simple(nn, sizeof(*req), GFP_KERNEL);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\treq = (void *)skb->data;\n\treq->ep_id = 0;\n\n\treturn nfp_net_tls_communicate_simple(nn, skb, \"reset\",\n\t\t\t\t\t      NFP_CCM_TYPE_CRYPTO_RESET);\n}\n\nint nfp_net_tls_init(struct nfp_net *nn)\n{\n\tstruct net_device *netdev = nn->dp.netdev;\n\tint err;\n\n\tif (!(nn->tlv_caps.crypto_ops & NFP_NET_TLS_OPCODE_MASK))\n\t\treturn 0;\n\n\tif ((nn->tlv_caps.mbox_cmsg_types & NFP_NET_TLS_CCM_MBOX_OPS_MASK) !=\n\t    NFP_NET_TLS_CCM_MBOX_OPS_MASK)\n\t\treturn 0;\n\n\tif (!nfp_ccm_mbox_fits(nn, sizeof(struct nfp_crypto_req_add_v6))) {\n\t\tnn_warn(nn, \"disabling TLS offload - mbox too small: %d\\n\",\n\t\t\tnn->tlv_caps.mbox_len);\n\t\treturn 0;\n\t}\n\n\terr = nfp_net_tls_reset(nn);\n\tif (err)\n\t\treturn err;\n\n\tnn_ctrl_bar_lock(nn);\n\tnn_writel(nn, nn->tlv_caps.crypto_enable_off, 0);\n\terr = __nfp_net_reconfig(nn, NFP_NET_CFG_UPDATE_CRYPTO);\n\tnn_ctrl_bar_unlock(nn);\n\tif (err)\n\t\treturn err;\n\n\tif (nn->tlv_caps.crypto_ops & NFP_NET_TLS_OPCODE_MASK_RX) {\n\t\tnetdev->hw_features |= NETIF_F_HW_TLS_RX;\n\t\tnetdev->features |= NETIF_F_HW_TLS_RX;\n\t}\n\tif (nn->tlv_caps.crypto_ops & NFP_NET_TLS_OPCODE_MASK_TX) {\n\t\tnetdev->hw_features |= NETIF_F_HW_TLS_TX;\n\t\tnetdev->features |= NETIF_F_HW_TLS_TX;\n\t}\n\n\tnetdev->tlsdev_ops = &nfp_net_tls_ops;\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}