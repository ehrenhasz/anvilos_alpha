{
  "module_name": "ipsec.c",
  "hash_id": "33f504c32a6641bbe6202979d897a741887fc982216341fc77b59c1b2b37c062",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/netronome/nfp/crypto/ipsec.c",
  "human_readable_source": "\n \n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/netdevice.h>\n#include <asm/unaligned.h>\n#include <linux/ktime.h>\n#include <net/xfrm.h>\n\n#include \"../nfpcore/nfp_dev.h\"\n#include \"../nfp_net_ctrl.h\"\n#include \"../nfp_net.h\"\n#include \"crypto.h\"\n\n#define NFP_NET_IPSEC_MAX_SA_CNT  (16 * 1024)  \n\n \nenum nfp_ipsec_cfg_mssg_cmd_codes {\n\tNFP_IPSEC_CFG_MSSG_ADD_SA,\t  \n\tNFP_IPSEC_CFG_MSSG_INV_SA\t  \n};\n\n \nenum nfp_ipsec_cfg_mssg_rsp_codes {\n\tNFP_IPSEC_CFG_MSSG_OK,\n\tNFP_IPSEC_CFG_MSSG_FAILED,\n\tNFP_IPSEC_CFG_MSSG_SA_VALID,\n\tNFP_IPSEC_CFG_MSSG_SA_HASH_ADD_FAILED,\n\tNFP_IPSEC_CFG_MSSG_SA_HASH_DEL_FAILED,\n\tNFP_IPSEC_CFG_MSSG_SA_INVALID_CMD\n};\n\n \nenum nfp_ipsec_sa_prot {\n\tNFP_IPSEC_PROTOCOL_AH = 0,\n\tNFP_IPSEC_PROTOCOL_ESP = 1\n};\n\n \nenum nfp_ipsec_sa_mode {\n\tNFP_IPSEC_PROTMODE_TRANSPORT = 0,\n\tNFP_IPSEC_PROTMODE_TUNNEL = 1\n};\n\n \nenum nfp_ipsec_sa_cipher {\n\tNFP_IPSEC_CIPHER_NULL,\n\tNFP_IPSEC_CIPHER_3DES,\n\tNFP_IPSEC_CIPHER_AES128,\n\tNFP_IPSEC_CIPHER_AES192,\n\tNFP_IPSEC_CIPHER_AES256,\n\tNFP_IPSEC_CIPHER_AES128_NULL,\n\tNFP_IPSEC_CIPHER_AES192_NULL,\n\tNFP_IPSEC_CIPHER_AES256_NULL,\n\tNFP_IPSEC_CIPHER_CHACHA20\n};\n\n \nenum nfp_ipsec_sa_cipher_mode {\n\tNFP_IPSEC_CIMODE_ECB,\n\tNFP_IPSEC_CIMODE_CBC,\n\tNFP_IPSEC_CIMODE_CFB,\n\tNFP_IPSEC_CIMODE_OFB,\n\tNFP_IPSEC_CIMODE_CTR\n};\n\n \nenum nfp_ipsec_sa_hash_type {\n\tNFP_IPSEC_HASH_NONE,\n\tNFP_IPSEC_HASH_MD5_96,\n\tNFP_IPSEC_HASH_SHA1_96,\n\tNFP_IPSEC_HASH_SHA256_96,\n\tNFP_IPSEC_HASH_SHA384_96,\n\tNFP_IPSEC_HASH_SHA512_96,\n\tNFP_IPSEC_HASH_MD5_128,\n\tNFP_IPSEC_HASH_SHA1_80,\n\tNFP_IPSEC_HASH_SHA256_128,\n\tNFP_IPSEC_HASH_SHA384_192,\n\tNFP_IPSEC_HASH_SHA512_256,\n\tNFP_IPSEC_HASH_GF128_128,\n\tNFP_IPSEC_HASH_POLY1305_128\n};\n\n \nstruct nfp_ipsec_cfg_add_sa {\n\tu32 ciph_key[8];\t\t   \n\tunion {\n\t\tu32 auth_key[16];\t   \n\t\tstruct nfp_ipsec_aesgcm {  \n\t\t\tu32 salt;\t   \n\t\t\tu32 resv[15];\n\t\t} aesgcm_fields;\n\t};\n\tstruct sa_ctrl_word {\n\t\tuint32_t hash   :4;\t   \n\t\tuint32_t cimode :4;\t   \n\t\tuint32_t cipher :4;\t   \n\t\tuint32_t mode   :2;\t   \n\t\tuint32_t proto  :2;\t   \n\t\tuint32_t dir :1;\t   \n\t\tuint32_t resv0 :12;\n\t\tuint32_t encap_dsbl:1;\t   \n\t\tuint32_t resv1 :2;\t   \n\t} ctrl_word;\n\tu32 spi;\t\t\t   \n\tuint32_t pmtu_limit :16;           \n\tuint32_t resv0 :5;\n\tuint32_t ipv6       :1;\t\t   \n\tuint32_t resv1\t :10;\n\tu32 resv2[2];\n\tu32 src_ip[4];\t\t\t   \n\tu32 dst_ip[4];\t\t\t   \n\tu32 resv3[6];\n};\n\n \nstruct nfp_ipsec_cfg_mssg {\n\tunion {\n\t\tstruct{\n\t\t\tuint32_t cmd:16;      \n\t\t\tuint32_t rsp:16;      \n\t\t\tuint32_t sa_idx:16;   \n\t\t\tuint32_t spare0:16;\n\t\t\tstruct nfp_ipsec_cfg_add_sa cfg_add_sa;\n\t\t};\n\t\tu32 raw[64];\n\t};\n};\n\nstatic int nfp_net_ipsec_cfg(struct nfp_net *nn, struct nfp_mbox_amsg_entry *entry)\n{\n\tunsigned int offset = nn->tlv_caps.mbox_off + NFP_NET_CFG_MBOX_SIMPLE_VAL;\n\tstruct nfp_ipsec_cfg_mssg *msg = (struct nfp_ipsec_cfg_mssg *)entry->msg;\n\tint i, msg_size, ret;\n\n\tret = nfp_net_mbox_lock(nn, sizeof(*msg));\n\tif (ret)\n\t\treturn ret;\n\n\tmsg_size = ARRAY_SIZE(msg->raw);\n\tfor (i = 0; i < msg_size; i++)\n\t\tnn_writel(nn, offset + 4 * i, msg->raw[i]);\n\n\tret = nfp_net_mbox_reconfig(nn, entry->cmd);\n\tif (ret < 0) {\n\t\tnn_ctrl_bar_unlock(nn);\n\t\treturn ret;\n\t}\n\n\t \n\tfor (i = 0; i < msg_size; i++)\n\t\tmsg->raw[i] = nn_readl(nn, offset + 4 * i);\n\n\tnn_ctrl_bar_unlock(nn);\n\n\tswitch (msg->rsp) {\n\tcase NFP_IPSEC_CFG_MSSG_OK:\n\t\treturn 0;\n\tcase NFP_IPSEC_CFG_MSSG_SA_INVALID_CMD:\n\t\treturn -EINVAL;\n\tcase NFP_IPSEC_CFG_MSSG_SA_VALID:\n\t\treturn -EEXIST;\n\tcase NFP_IPSEC_CFG_MSSG_FAILED:\n\tcase NFP_IPSEC_CFG_MSSG_SA_HASH_ADD_FAILED:\n\tcase NFP_IPSEC_CFG_MSSG_SA_HASH_DEL_FAILED:\n\t\treturn -EIO;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int set_aes_keylen(struct nfp_ipsec_cfg_add_sa *cfg, int alg, int keylen)\n{\n\tbool aes_gmac = (alg == SADB_X_EALG_NULL_AES_GMAC);\n\n\tswitch (keylen) {\n\tcase 128:\n\t\tcfg->ctrl_word.cipher = aes_gmac ? NFP_IPSEC_CIPHER_AES128_NULL :\n\t\t\t\t\t\t   NFP_IPSEC_CIPHER_AES128;\n\t\tbreak;\n\tcase 192:\n\t\tcfg->ctrl_word.cipher = aes_gmac ? NFP_IPSEC_CIPHER_AES192_NULL :\n\t\t\t\t\t\t   NFP_IPSEC_CIPHER_AES192;\n\t\tbreak;\n\tcase 256:\n\t\tcfg->ctrl_word.cipher = aes_gmac ? NFP_IPSEC_CIPHER_AES256_NULL :\n\t\t\t\t\t\t   NFP_IPSEC_CIPHER_AES256;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void set_md5hmac(struct nfp_ipsec_cfg_add_sa *cfg, int *trunc_len)\n{\n\tswitch (*trunc_len) {\n\tcase 96:\n\t\tcfg->ctrl_word.hash = NFP_IPSEC_HASH_MD5_96;\n\t\tbreak;\n\tcase 128:\n\t\tcfg->ctrl_word.hash = NFP_IPSEC_HASH_MD5_128;\n\t\tbreak;\n\tdefault:\n\t\t*trunc_len = 0;\n\t}\n}\n\nstatic void set_sha1hmac(struct nfp_ipsec_cfg_add_sa *cfg, int *trunc_len)\n{\n\tswitch (*trunc_len) {\n\tcase 96:\n\t\tcfg->ctrl_word.hash = NFP_IPSEC_HASH_SHA1_96;\n\t\tbreak;\n\tcase 80:\n\t\tcfg->ctrl_word.hash = NFP_IPSEC_HASH_SHA1_80;\n\t\tbreak;\n\tdefault:\n\t\t*trunc_len = 0;\n\t}\n}\n\nstatic void set_sha2_256hmac(struct nfp_ipsec_cfg_add_sa *cfg, int *trunc_len)\n{\n\tswitch (*trunc_len) {\n\tcase 96:\n\t\tcfg->ctrl_word.hash = NFP_IPSEC_HASH_SHA256_96;\n\t\tbreak;\n\tcase 128:\n\t\tcfg->ctrl_word.hash = NFP_IPSEC_HASH_SHA256_128;\n\t\tbreak;\n\tdefault:\n\t\t*trunc_len = 0;\n\t}\n}\n\nstatic void set_sha2_384hmac(struct nfp_ipsec_cfg_add_sa *cfg, int *trunc_len)\n{\n\tswitch (*trunc_len) {\n\tcase 96:\n\t\tcfg->ctrl_word.hash = NFP_IPSEC_HASH_SHA384_96;\n\t\tbreak;\n\tcase 192:\n\t\tcfg->ctrl_word.hash = NFP_IPSEC_HASH_SHA384_192;\n\t\tbreak;\n\tdefault:\n\t\t*trunc_len = 0;\n\t}\n}\n\nstatic void set_sha2_512hmac(struct nfp_ipsec_cfg_add_sa *cfg, int *trunc_len)\n{\n\tswitch (*trunc_len) {\n\tcase 96:\n\t\tcfg->ctrl_word.hash = NFP_IPSEC_HASH_SHA512_96;\n\t\tbreak;\n\tcase 256:\n\t\tcfg->ctrl_word.hash = NFP_IPSEC_HASH_SHA512_256;\n\t\tbreak;\n\tdefault:\n\t\t*trunc_len = 0;\n\t}\n}\n\nstatic int nfp_net_xfrm_add_state(struct xfrm_state *x,\n\t\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct net_device *netdev = x->xso.real_dev;\n\tstruct nfp_ipsec_cfg_mssg msg = {};\n\tint i, key_len, trunc_len, err = 0;\n\tstruct nfp_ipsec_cfg_add_sa *cfg;\n\tstruct nfp_net *nn;\n\tunsigned int saidx;\n\n\tnn = netdev_priv(netdev);\n\tcfg = &msg.cfg_add_sa;\n\n\t \n\tswitch (x->props.mode) {\n\tcase XFRM_MODE_TUNNEL:\n\t\tcfg->ctrl_word.mode = NFP_IPSEC_PROTMODE_TUNNEL;\n\t\tbreak;\n\tcase XFRM_MODE_TRANSPORT:\n\t\tcfg->ctrl_word.mode = NFP_IPSEC_PROTMODE_TRANSPORT;\n\t\tbreak;\n\tdefault:\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Unsupported mode for xfrm offload\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (x->id.proto) {\n\tcase IPPROTO_ESP:\n\t\tcfg->ctrl_word.proto = NFP_IPSEC_PROTOCOL_ESP;\n\t\tbreak;\n\tcase IPPROTO_AH:\n\t\tcfg->ctrl_word.proto = NFP_IPSEC_PROTOCOL_AH;\n\t\tbreak;\n\tdefault:\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Unsupported protocol for xfrm offload\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (x->props.flags & XFRM_STATE_ESN) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Unsupported XFRM_REPLAY_MODE_ESN for xfrm offload\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (x->xso.type != XFRM_DEV_OFFLOAD_CRYPTO) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Unsupported xfrm offload type\");\n\t\treturn -EINVAL;\n\t}\n\n\tcfg->spi = ntohl(x->id.spi);\n\n\t \n\tif (x->aalg)\n\t\ttrunc_len = x->aalg->alg_trunc_len;\n\telse\n\t\ttrunc_len = 0;\n\n\tswitch (x->props.aalgo) {\n\tcase SADB_AALG_NONE:\n\t\tif (x->aead) {\n\t\t\ttrunc_len = -1;\n\t\t} else {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Unsupported authentication algorithm\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase SADB_X_AALG_NULL:\n\t\tcfg->ctrl_word.hash = NFP_IPSEC_HASH_NONE;\n\t\ttrunc_len = -1;\n\t\tbreak;\n\tcase SADB_AALG_MD5HMAC:\n\t\tif (nn->pdev->device == PCI_DEVICE_ID_NFP3800) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Unsupported authentication algorithm\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tset_md5hmac(cfg, &trunc_len);\n\t\tbreak;\n\tcase SADB_AALG_SHA1HMAC:\n\t\tset_sha1hmac(cfg, &trunc_len);\n\t\tbreak;\n\tcase SADB_X_AALG_SHA2_256HMAC:\n\t\tset_sha2_256hmac(cfg, &trunc_len);\n\t\tbreak;\n\tcase SADB_X_AALG_SHA2_384HMAC:\n\t\tset_sha2_384hmac(cfg, &trunc_len);\n\t\tbreak;\n\tcase SADB_X_AALG_SHA2_512HMAC:\n\t\tset_sha2_512hmac(cfg, &trunc_len);\n\t\tbreak;\n\tdefault:\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Unsupported authentication algorithm\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!trunc_len) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Unsupported authentication algorithm trunc length\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (x->aalg) {\n\t\tkey_len = DIV_ROUND_UP(x->aalg->alg_key_len, BITS_PER_BYTE);\n\t\tif (key_len > sizeof(cfg->auth_key)) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Insufficient space for offloaded auth key\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tfor (i = 0; i < key_len / sizeof(cfg->auth_key[0]) ; i++)\n\t\t\tcfg->auth_key[i] = get_unaligned_be32(x->aalg->alg_key +\n\t\t\t\t\t\t\t      sizeof(cfg->auth_key[0]) * i);\n\t}\n\n\t \n\tswitch (x->props.ealgo) {\n\tcase SADB_EALG_NONE:\n\tcase SADB_EALG_NULL:\n\t\tcfg->ctrl_word.cimode = NFP_IPSEC_CIMODE_CBC;\n\t\tcfg->ctrl_word.cipher = NFP_IPSEC_CIPHER_NULL;\n\t\tbreak;\n\tcase SADB_EALG_3DESCBC:\n\t\tif (nn->pdev->device == PCI_DEVICE_ID_NFP3800) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Unsupported encryption algorithm for offload\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tcfg->ctrl_word.cimode = NFP_IPSEC_CIMODE_CBC;\n\t\tcfg->ctrl_word.cipher = NFP_IPSEC_CIPHER_3DES;\n\t\tbreak;\n\tcase SADB_X_EALG_AES_GCM_ICV16:\n\tcase SADB_X_EALG_NULL_AES_GMAC:\n\t\tif (!x->aead) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Invalid AES key data\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (x->aead->alg_icv_len != 128) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"ICV must be 128bit with SADB_X_EALG_AES_GCM_ICV16\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tcfg->ctrl_word.cimode = NFP_IPSEC_CIMODE_CTR;\n\t\tcfg->ctrl_word.hash = NFP_IPSEC_HASH_GF128_128;\n\n\t\t \n\t\tif (set_aes_keylen(cfg, x->props.ealgo, x->aead->alg_key_len - 32)) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Unsupported AES key length\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase SADB_X_EALG_AESCBC:\n\t\tcfg->ctrl_word.cimode = NFP_IPSEC_CIMODE_CBC;\n\t\tif (!x->ealg) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Invalid AES key data\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (set_aes_keylen(cfg, x->props.ealgo, x->ealg->alg_key_len) < 0) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Unsupported AES key length\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Unsupported encryption algorithm for offload\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (x->aead) {\n\t\tint salt_len = 4;\n\n\t\tkey_len = DIV_ROUND_UP(x->aead->alg_key_len, BITS_PER_BYTE);\n\t\tkey_len -= salt_len;\n\n\t\tif (key_len > sizeof(cfg->ciph_key)) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"aead: Insufficient space for offloaded key\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tfor (i = 0; i < key_len / sizeof(cfg->ciph_key[0]) ; i++)\n\t\t\tcfg->ciph_key[i] = get_unaligned_be32(x->aead->alg_key +\n\t\t\t\t\t\t\t      sizeof(cfg->ciph_key[0]) * i);\n\n\t\t \n\t\tcfg->aesgcm_fields.salt = get_unaligned_be32(x->aead->alg_key + key_len);\n\t}\n\n\tif (x->ealg) {\n\t\tkey_len = DIV_ROUND_UP(x->ealg->alg_key_len, BITS_PER_BYTE);\n\n\t\tif (key_len > sizeof(cfg->ciph_key)) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"ealg: Insufficient space for offloaded key\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tfor (i = 0; i < key_len / sizeof(cfg->ciph_key[0]) ; i++)\n\t\t\tcfg->ciph_key[i] = get_unaligned_be32(x->ealg->alg_key +\n\t\t\t\t\t\t\t      sizeof(cfg->ciph_key[0]) * i);\n\t}\n\n\t \n\tswitch (x->props.family) {\n\tcase AF_INET:\n\t\tcfg->ipv6 = 0;\n\t\tcfg->src_ip[0] = ntohl(x->props.saddr.a4);\n\t\tcfg->dst_ip[0] = ntohl(x->id.daddr.a4);\n\t\tbreak;\n\tcase AF_INET6:\n\t\tcfg->ipv6 = 1;\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tcfg->src_ip[i] = ntohl(x->props.saddr.a6[i]);\n\t\t\tcfg->dst_ip[i] = ntohl(x->id.daddr.a6[i]);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Unsupported address family\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tcfg->pmtu_limit = 0xffff;\n\tcfg->ctrl_word.encap_dsbl = 1;\n\n\t \n\tcfg->ctrl_word.dir = x->xso.dir;\n\n\t \n\terr = xa_alloc(&nn->xa_ipsec, &saidx, x,\n\t\t       XA_LIMIT(0, NFP_NET_IPSEC_MAX_SA_CNT - 1), GFP_KERNEL);\n\tif (err < 0) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Unable to get sa_data number for IPsec\");\n\t\treturn err;\n\t}\n\n\t \n\tmsg.cmd = NFP_IPSEC_CFG_MSSG_ADD_SA;\n\tmsg.sa_idx = saidx;\n\terr = nfp_net_sched_mbox_amsg_work(nn, NFP_NET_CFG_MBOX_CMD_IPSEC, &msg,\n\t\t\t\t\t   sizeof(msg), nfp_net_ipsec_cfg);\n\tif (err) {\n\t\txa_erase(&nn->xa_ipsec, saidx);\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Failed to issue IPsec command\");\n\t\treturn err;\n\t}\n\n\t \n\tx->xso.offload_handle = saidx + 1;\n\treturn 0;\n}\n\nstatic void nfp_net_xfrm_del_state(struct xfrm_state *x)\n{\n\tstruct nfp_ipsec_cfg_mssg msg = {\n\t\t.cmd = NFP_IPSEC_CFG_MSSG_INV_SA,\n\t\t.sa_idx = x->xso.offload_handle - 1,\n\t};\n\tstruct net_device *netdev = x->xso.real_dev;\n\tstruct nfp_net *nn;\n\tint err;\n\n\tnn = netdev_priv(netdev);\n\terr = nfp_net_sched_mbox_amsg_work(nn, NFP_NET_CFG_MBOX_CMD_IPSEC, &msg,\n\t\t\t\t\t   sizeof(msg), nfp_net_ipsec_cfg);\n\tif (err)\n\t\tnn_warn(nn, \"Failed to invalidate SA in hardware\\n\");\n\n\txa_erase(&nn->xa_ipsec, x->xso.offload_handle - 1);\n}\n\nstatic bool nfp_net_ipsec_offload_ok(struct sk_buff *skb, struct xfrm_state *x)\n{\n\tif (x->props.family == AF_INET)\n\t\t \n\t\treturn ip_hdr(skb)->ihl == 5;\n\n\t \n\treturn !(ipv6_ext_hdr(ipv6_hdr(skb)->nexthdr));\n}\n\nstatic const struct xfrmdev_ops nfp_net_ipsec_xfrmdev_ops = {\n\t.xdo_dev_state_add = nfp_net_xfrm_add_state,\n\t.xdo_dev_state_delete = nfp_net_xfrm_del_state,\n\t.xdo_dev_offload_ok = nfp_net_ipsec_offload_ok,\n};\n\nvoid nfp_net_ipsec_init(struct nfp_net *nn)\n{\n\tif (!(nn->cap_w1 & NFP_NET_CFG_CTRL_IPSEC))\n\t\treturn;\n\n\txa_init_flags(&nn->xa_ipsec, XA_FLAGS_ALLOC);\n\tnn->dp.netdev->xfrmdev_ops = &nfp_net_ipsec_xfrmdev_ops;\n}\n\nvoid nfp_net_ipsec_clean(struct nfp_net *nn)\n{\n\tif (!(nn->cap_w1 & NFP_NET_CFG_CTRL_IPSEC))\n\t\treturn;\n\n\tWARN_ON(!xa_empty(&nn->xa_ipsec));\n\txa_destroy(&nn->xa_ipsec);\n}\n\nbool nfp_net_ipsec_tx_prep(struct nfp_net_dp *dp, struct sk_buff *skb,\n\t\t\t   struct nfp_ipsec_offload *offload_info)\n{\n\tstruct xfrm_offload *xo = xfrm_offload(skb);\n\tstruct xfrm_state *x;\n\n\tx = xfrm_input_state(skb);\n\tif (!x)\n\t\treturn false;\n\n\toffload_info->seq_hi = xo->seq.hi;\n\toffload_info->seq_low = xo->seq.low;\n\toffload_info->handle = x->xso.offload_handle;\n\n\treturn true;\n}\n\nint nfp_net_ipsec_rx(struct nfp_meta_parsed *meta, struct sk_buff *skb)\n{\n\tstruct net_device *netdev = skb->dev;\n\tstruct xfrm_offload *xo;\n\tstruct xfrm_state *x;\n\tstruct sec_path *sp;\n\tstruct nfp_net *nn;\n\tu32 saidx;\n\n\tnn = netdev_priv(netdev);\n\n\tsaidx = meta->ipsec_saidx - 1;\n\tif (saidx >= NFP_NET_IPSEC_MAX_SA_CNT)\n\t\treturn -EINVAL;\n\n\tsp = secpath_set(skb);\n\tif (unlikely(!sp))\n\t\treturn -ENOMEM;\n\n\txa_lock(&nn->xa_ipsec);\n\tx = xa_load(&nn->xa_ipsec, saidx);\n\txa_unlock(&nn->xa_ipsec);\n\tif (!x)\n\t\treturn -EINVAL;\n\n\txfrm_state_hold(x);\n\tsp->xvec[sp->len++] = x;\n\tsp->olen++;\n\txo = xfrm_offload(skb);\n\txo->flags = CRYPTO_DONE;\n\txo->status = CRYPTO_SUCCESS;\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}