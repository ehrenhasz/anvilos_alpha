{
  "module_name": "offload.c",
  "hash_id": "b4bf953bc912b7f7cf8f1d6470235aa11fcb6a76afb44eb651d4925857204638",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/netronome/nfp/flower/offload.c",
  "human_readable_source": "\n \n\n#include <linux/skbuff.h>\n#include <net/devlink.h>\n#include <net/pkt_cls.h>\n\n#include \"cmsg.h\"\n#include \"main.h\"\n#include \"conntrack.h\"\n#include \"../nfpcore/nfp_cpp.h\"\n#include \"../nfpcore/nfp_nsp.h\"\n#include \"../nfp_app.h\"\n#include \"../nfp_main.h\"\n#include \"../nfp_net.h\"\n#include \"../nfp_port.h\"\n\n#define NFP_FLOWER_SUPPORTED_TCPFLAGS \\\n\t(TCPHDR_FIN | TCPHDR_SYN | TCPHDR_RST | \\\n\t TCPHDR_PSH | TCPHDR_URG)\n\n#define NFP_FLOWER_SUPPORTED_CTLFLAGS \\\n\t(FLOW_DIS_IS_FRAGMENT | \\\n\t FLOW_DIS_FIRST_FRAG)\n\n#define NFP_FLOWER_WHITELIST_DISSECTOR \\\n\t(BIT_ULL(FLOW_DISSECTOR_KEY_CONTROL) | \\\n\t BIT_ULL(FLOW_DISSECTOR_KEY_BASIC) | \\\n\t BIT_ULL(FLOW_DISSECTOR_KEY_IPV4_ADDRS) | \\\n\t BIT_ULL(FLOW_DISSECTOR_KEY_IPV6_ADDRS) | \\\n\t BIT_ULL(FLOW_DISSECTOR_KEY_TCP) | \\\n\t BIT_ULL(FLOW_DISSECTOR_KEY_PORTS) | \\\n\t BIT_ULL(FLOW_DISSECTOR_KEY_ETH_ADDRS) | \\\n\t BIT_ULL(FLOW_DISSECTOR_KEY_VLAN) | \\\n\t BIT_ULL(FLOW_DISSECTOR_KEY_CVLAN) | \\\n\t BIT_ULL(FLOW_DISSECTOR_KEY_ENC_KEYID) | \\\n\t BIT_ULL(FLOW_DISSECTOR_KEY_ENC_IPV4_ADDRS) | \\\n\t BIT_ULL(FLOW_DISSECTOR_KEY_ENC_IPV6_ADDRS) | \\\n\t BIT_ULL(FLOW_DISSECTOR_KEY_ENC_CONTROL) | \\\n\t BIT_ULL(FLOW_DISSECTOR_KEY_ENC_PORTS) | \\\n\t BIT_ULL(FLOW_DISSECTOR_KEY_ENC_OPTS) | \\\n\t BIT_ULL(FLOW_DISSECTOR_KEY_ENC_IP) | \\\n\t BIT_ULL(FLOW_DISSECTOR_KEY_MPLS) | \\\n\t BIT_ULL(FLOW_DISSECTOR_KEY_CT) | \\\n\t BIT_ULL(FLOW_DISSECTOR_KEY_META) | \\\n\t BIT_ULL(FLOW_DISSECTOR_KEY_IP))\n\n#define NFP_FLOWER_WHITELIST_TUN_DISSECTOR \\\n\t(BIT_ULL(FLOW_DISSECTOR_KEY_ENC_CONTROL) | \\\n\t BIT_ULL(FLOW_DISSECTOR_KEY_ENC_KEYID) | \\\n\t BIT_ULL(FLOW_DISSECTOR_KEY_ENC_IPV4_ADDRS) | \\\n\t BIT_ULL(FLOW_DISSECTOR_KEY_ENC_IPV6_ADDRS) | \\\n\t BIT_ULL(FLOW_DISSECTOR_KEY_ENC_OPTS) | \\\n\t BIT_ULL(FLOW_DISSECTOR_KEY_ENC_PORTS) | \\\n\t BIT_ULL(FLOW_DISSECTOR_KEY_ENC_IP))\n\n#define NFP_FLOWER_WHITELIST_TUN_DISSECTOR_R \\\n\t(BIT_ULL(FLOW_DISSECTOR_KEY_ENC_CONTROL) | \\\n\t BIT_ULL(FLOW_DISSECTOR_KEY_ENC_IPV4_ADDRS))\n\n#define NFP_FLOWER_WHITELIST_TUN_DISSECTOR_V6_R \\\n\t(BIT_ULL(FLOW_DISSECTOR_KEY_ENC_CONTROL) | \\\n\t BIT_ULL(FLOW_DISSECTOR_KEY_ENC_IPV6_ADDRS))\n\n#define NFP_FLOWER_MERGE_FIELDS \\\n\t(NFP_FLOWER_LAYER_PORT | \\\n\t NFP_FLOWER_LAYER_MAC | \\\n\t NFP_FLOWER_LAYER_TP | \\\n\t NFP_FLOWER_LAYER_IPV4 | \\\n\t NFP_FLOWER_LAYER_IPV6)\n\n#define NFP_FLOWER_PRE_TUN_RULE_FIELDS \\\n\t(NFP_FLOWER_LAYER_EXT_META | \\\n\t NFP_FLOWER_LAYER_PORT | \\\n\t NFP_FLOWER_LAYER_MAC | \\\n\t NFP_FLOWER_LAYER_IPV4 | \\\n\t NFP_FLOWER_LAYER_IPV6)\n\nstruct nfp_flower_merge_check {\n\tunion {\n\t\tstruct {\n\t\t\t__be16 tci;\n\t\t\tstruct nfp_flower_mac_mpls l2;\n\t\t\tstruct nfp_flower_tp_ports l4;\n\t\t\tunion {\n\t\t\t\tstruct nfp_flower_ipv4 ipv4;\n\t\t\t\tstruct nfp_flower_ipv6 ipv6;\n\t\t\t};\n\t\t};\n\t\tunsigned long vals[8];\n\t};\n};\n\nint\nnfp_flower_xmit_flow(struct nfp_app *app, struct nfp_fl_payload *nfp_flow,\n\t\t     u8 mtype)\n{\n\tu32 meta_len, key_len, mask_len, act_len, tot_len;\n\tstruct sk_buff *skb;\n\tunsigned char *msg;\n\n\tmeta_len =  sizeof(struct nfp_fl_rule_metadata);\n\tkey_len = nfp_flow->meta.key_len;\n\tmask_len = nfp_flow->meta.mask_len;\n\tact_len = nfp_flow->meta.act_len;\n\n\ttot_len = meta_len + key_len + mask_len + act_len;\n\n\t \n\tnfp_flow->meta.key_len >>= NFP_FL_LW_SIZ;\n\tnfp_flow->meta.mask_len >>= NFP_FL_LW_SIZ;\n\tnfp_flow->meta.act_len >>= NFP_FL_LW_SIZ;\n\n\tskb = nfp_flower_cmsg_alloc(app, tot_len, mtype, GFP_KERNEL);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tmsg = nfp_flower_cmsg_get_data(skb);\n\tmemcpy(msg, &nfp_flow->meta, meta_len);\n\tmemcpy(&msg[meta_len], nfp_flow->unmasked_data, key_len);\n\tmemcpy(&msg[meta_len + key_len], nfp_flow->mask_data, mask_len);\n\tmemcpy(&msg[meta_len + key_len + mask_len],\n\t       nfp_flow->action_data, act_len);\n\n\t \n\tnfp_flow->meta.key_len <<= NFP_FL_LW_SIZ;\n\tnfp_flow->meta.mask_len <<= NFP_FL_LW_SIZ;\n\tnfp_flow->meta.act_len <<= NFP_FL_LW_SIZ;\n\n\tnfp_ctrl_tx(app->ctrl, skb);\n\n\treturn 0;\n}\n\nstatic bool nfp_flower_check_higher_than_mac(struct flow_rule *rule)\n{\n\treturn flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_IPV4_ADDRS) ||\n\t       flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_IPV6_ADDRS) ||\n\t       flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_PORTS) ||\n\t       flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_ICMP);\n}\n\nstatic bool nfp_flower_check_higher_than_l3(struct flow_rule *rule)\n{\n\treturn flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_PORTS) ||\n\t       flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_ICMP);\n}\n\nstatic int\nnfp_flower_calc_opt_layer(struct flow_dissector_key_enc_opts *enc_opts,\n\t\t\t  u32 *key_layer_two, int *key_size, bool ipv6,\n\t\t\t  struct netlink_ext_ack *extack)\n{\n\tif (enc_opts->len > NFP_FL_MAX_GENEVE_OPT_KEY ||\n\t    (ipv6 && enc_opts->len > NFP_FL_MAX_GENEVE_OPT_KEY_V6)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"unsupported offload: geneve options exceed maximum length\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (enc_opts->len > 0) {\n\t\t*key_layer_two |= NFP_FLOWER_LAYER2_GENEVE_OP;\n\t\t*key_size += sizeof(struct nfp_flower_geneve_options);\n\t}\n\n\treturn 0;\n}\n\nstatic int\nnfp_flower_calc_udp_tun_layer(struct flow_dissector_key_ports *enc_ports,\n\t\t\t      struct flow_dissector_key_enc_opts *enc_op,\n\t\t\t      u32 *key_layer_two, u8 *key_layer, int *key_size,\n\t\t\t      struct nfp_flower_priv *priv,\n\t\t\t      enum nfp_flower_tun_type *tun_type, bool ipv6,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tint err;\n\n\tswitch (enc_ports->dst) {\n\tcase htons(IANA_VXLAN_UDP_PORT):\n\t\t*tun_type = NFP_FL_TUNNEL_VXLAN;\n\t\t*key_layer |= NFP_FLOWER_LAYER_VXLAN;\n\n\t\tif (ipv6) {\n\t\t\t*key_layer |= NFP_FLOWER_LAYER_EXT_META;\n\t\t\t*key_size += sizeof(struct nfp_flower_ext_meta);\n\t\t\t*key_layer_two |= NFP_FLOWER_LAYER2_TUN_IPV6;\n\t\t\t*key_size += sizeof(struct nfp_flower_ipv6_udp_tun);\n\t\t} else {\n\t\t\t*key_size += sizeof(struct nfp_flower_ipv4_udp_tun);\n\t\t}\n\n\t\tif (enc_op) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"unsupported offload: encap options not supported on vxlan tunnels\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tbreak;\n\tcase htons(GENEVE_UDP_PORT):\n\t\tif (!(priv->flower_ext_feats & NFP_FL_FEATS_GENEVE)) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"unsupported offload: loaded firmware does not support geneve offload\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\t*tun_type = NFP_FL_TUNNEL_GENEVE;\n\t\t*key_layer |= NFP_FLOWER_LAYER_EXT_META;\n\t\t*key_size += sizeof(struct nfp_flower_ext_meta);\n\t\t*key_layer_two |= NFP_FLOWER_LAYER2_GENEVE;\n\n\t\tif (ipv6) {\n\t\t\t*key_layer_two |= NFP_FLOWER_LAYER2_TUN_IPV6;\n\t\t\t*key_size += sizeof(struct nfp_flower_ipv6_udp_tun);\n\t\t} else {\n\t\t\t*key_size += sizeof(struct nfp_flower_ipv4_udp_tun);\n\t\t}\n\n\t\tif (!enc_op)\n\t\t\tbreak;\n\t\tif (!(priv->flower_ext_feats & NFP_FL_FEATS_GENEVE_OPT)) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"unsupported offload: loaded firmware does not support geneve option offload\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\terr = nfp_flower_calc_opt_layer(enc_op, key_layer_two, key_size,\n\t\t\t\t\t\tipv6, extack);\n\t\tif (err)\n\t\t\treturn err;\n\t\tbreak;\n\tdefault:\n\t\tNL_SET_ERR_MSG_MOD(extack, \"unsupported offload: tunnel type unknown\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nint\nnfp_flower_calculate_key_layers(struct nfp_app *app,\n\t\t\t\tstruct net_device *netdev,\n\t\t\t\tstruct nfp_fl_key_ls *ret_key_ls,\n\t\t\t\tstruct flow_rule *rule,\n\t\t\t\tenum nfp_flower_tun_type *tun_type,\n\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct flow_dissector *dissector = rule->match.dissector;\n\tstruct flow_match_basic basic = { NULL, NULL};\n\tstruct nfp_flower_priv *priv = app->priv;\n\tu32 key_layer_two;\n\tu8 key_layer;\n\tint key_size;\n\tint err;\n\n\tif (dissector->used_keys & ~NFP_FLOWER_WHITELIST_DISSECTOR) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"unsupported offload: match not supported\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t \n\tif (dissector->used_keys & NFP_FLOWER_WHITELIST_TUN_DISSECTOR &&\n\t    (dissector->used_keys & NFP_FLOWER_WHITELIST_TUN_DISSECTOR_V6_R)\n\t    != NFP_FLOWER_WHITELIST_TUN_DISSECTOR_V6_R &&\n\t    (dissector->used_keys & NFP_FLOWER_WHITELIST_TUN_DISSECTOR_R)\n\t    != NFP_FLOWER_WHITELIST_TUN_DISSECTOR_R) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"unsupported offload: tunnel match not supported\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tkey_layer_two = 0;\n\tkey_layer = NFP_FLOWER_LAYER_PORT;\n\tkey_size = sizeof(struct nfp_flower_meta_tci) +\n\t\t   sizeof(struct nfp_flower_in_port);\n\n\tif (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_ETH_ADDRS) ||\n\t    flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_MPLS)) {\n\t\tkey_layer |= NFP_FLOWER_LAYER_MAC;\n\t\tkey_size += sizeof(struct nfp_flower_mac_mpls);\n\t}\n\n\tif (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_VLAN)) {\n\t\tstruct flow_match_vlan vlan;\n\n\t\tflow_rule_match_vlan(rule, &vlan);\n\t\tif (!(priv->flower_ext_feats & NFP_FL_FEATS_VLAN_PCP) &&\n\t\t    vlan.key->vlan_priority) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"unsupported offload: loaded firmware does not support VLAN PCP offload\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tif (priv->flower_ext_feats & NFP_FL_FEATS_VLAN_QINQ &&\n\t\t    !(key_layer_two & NFP_FLOWER_LAYER2_QINQ)) {\n\t\t\tkey_layer |= NFP_FLOWER_LAYER_EXT_META;\n\t\t\tkey_size += sizeof(struct nfp_flower_ext_meta);\n\t\t\tkey_size += sizeof(struct nfp_flower_vlan);\n\t\t\tkey_layer_two |= NFP_FLOWER_LAYER2_QINQ;\n\t\t}\n\t}\n\n\tif (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_CVLAN)) {\n\t\tstruct flow_match_vlan cvlan;\n\n\t\tif (!(priv->flower_ext_feats & NFP_FL_FEATS_VLAN_QINQ)) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"unsupported offload: loaded firmware does not support VLAN QinQ offload\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\n\t\tflow_rule_match_vlan(rule, &cvlan);\n\t\tif (!(key_layer_two & NFP_FLOWER_LAYER2_QINQ)) {\n\t\t\tkey_layer |= NFP_FLOWER_LAYER_EXT_META;\n\t\t\tkey_size += sizeof(struct nfp_flower_ext_meta);\n\t\t\tkey_size += sizeof(struct nfp_flower_vlan);\n\t\t\tkey_layer_two |= NFP_FLOWER_LAYER2_QINQ;\n\t\t}\n\t}\n\n\tif (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_ENC_CONTROL)) {\n\t\tstruct flow_match_enc_opts enc_op = { NULL, NULL };\n\t\tstruct flow_match_ipv4_addrs ipv4_addrs;\n\t\tstruct flow_match_ipv6_addrs ipv6_addrs;\n\t\tstruct flow_match_control enc_ctl;\n\t\tstruct flow_match_ports enc_ports;\n\t\tbool ipv6_tun = false;\n\n\t\tflow_rule_match_enc_control(rule, &enc_ctl);\n\n\t\tif (enc_ctl.mask->addr_type != 0xffff) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"unsupported offload: wildcarded protocols on tunnels are not supported\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\n\t\tipv6_tun = enc_ctl.key->addr_type ==\n\t\t\t\tFLOW_DISSECTOR_KEY_IPV6_ADDRS;\n\t\tif (ipv6_tun &&\n\t\t    !(priv->flower_ext_feats & NFP_FL_FEATS_IPV6_TUN)) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"unsupported offload: firmware does not support IPv6 tunnels\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\n\t\tif (!ipv6_tun &&\n\t\t    enc_ctl.key->addr_type != FLOW_DISSECTOR_KEY_IPV4_ADDRS) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"unsupported offload: tunnel address type not IPv4 or IPv6\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\n\t\tif (ipv6_tun) {\n\t\t\tflow_rule_match_enc_ipv6_addrs(rule, &ipv6_addrs);\n\t\t\tif (memchr_inv(&ipv6_addrs.mask->dst, 0xff,\n\t\t\t\t       sizeof(ipv6_addrs.mask->dst))) {\n\t\t\t\tNL_SET_ERR_MSG_MOD(extack, \"unsupported offload: only an exact match IPv6 destination address is supported\");\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t\t}\n\t\t} else {\n\t\t\tflow_rule_match_enc_ipv4_addrs(rule, &ipv4_addrs);\n\t\t\tif (ipv4_addrs.mask->dst != cpu_to_be32(~0)) {\n\t\t\t\tNL_SET_ERR_MSG_MOD(extack, \"unsupported offload: only an exact match IPv4 destination address is supported\");\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t\t}\n\t\t}\n\n\t\tif (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_ENC_OPTS))\n\t\t\tflow_rule_match_enc_opts(rule, &enc_op);\n\n\t\tif (!flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_ENC_PORTS)) {\n\t\t\t \n\t\t\tif (!netif_is_gretap(netdev) && !netif_is_ip6gretap(netdev)) {\n\t\t\t\tNL_SET_ERR_MSG_MOD(extack, \"unsupported offload: an exact match on L4 destination port is required for non-GRE tunnels\");\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t\t}\n\n\t\t\t*tun_type = NFP_FL_TUNNEL_GRE;\n\t\t\tkey_layer |= NFP_FLOWER_LAYER_EXT_META;\n\t\t\tkey_size += sizeof(struct nfp_flower_ext_meta);\n\t\t\tkey_layer_two |= NFP_FLOWER_LAYER2_GRE;\n\n\t\t\tif (ipv6_tun) {\n\t\t\t\tkey_layer_two |= NFP_FLOWER_LAYER2_TUN_IPV6;\n\t\t\t\tkey_size +=\n\t\t\t\t\tsizeof(struct nfp_flower_ipv6_gre_tun);\n\t\t\t} else {\n\t\t\t\tkey_size +=\n\t\t\t\t\tsizeof(struct nfp_flower_ipv4_gre_tun);\n\t\t\t}\n\n\t\t\tif (enc_op.key) {\n\t\t\t\tNL_SET_ERR_MSG_MOD(extack, \"unsupported offload: encap options not supported on GRE tunnels\");\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t\t}\n\t\t} else {\n\t\t\tflow_rule_match_enc_ports(rule, &enc_ports);\n\t\t\tif (enc_ports.mask->dst != cpu_to_be16(~0)) {\n\t\t\t\tNL_SET_ERR_MSG_MOD(extack, \"unsupported offload: only an exact match L4 destination port is supported\");\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t\t}\n\n\t\t\terr = nfp_flower_calc_udp_tun_layer(enc_ports.key,\n\t\t\t\t\t\t\t    enc_op.key,\n\t\t\t\t\t\t\t    &key_layer_two,\n\t\t\t\t\t\t\t    &key_layer,\n\t\t\t\t\t\t\t    &key_size, priv,\n\t\t\t\t\t\t\t    tun_type, ipv6_tun,\n\t\t\t\t\t\t\t    extack);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\t \n\t\t\tif (!nfp_fl_netdev_is_tunnel_type(netdev, *tun_type)) {\n\t\t\t\tNL_SET_ERR_MSG_MOD(extack, \"unsupported offload: ingress netdev does not match the expected tunnel type\");\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_BASIC))\n\t\tflow_rule_match_basic(rule, &basic);\n\n\tif (basic.mask && basic.mask->n_proto) {\n\t\t \n\t\tswitch (basic.key->n_proto) {\n\t\tcase cpu_to_be16(ETH_P_IP):\n\t\t\tkey_layer |= NFP_FLOWER_LAYER_IPV4;\n\t\t\tkey_size += sizeof(struct nfp_flower_ipv4);\n\t\t\tbreak;\n\n\t\tcase cpu_to_be16(ETH_P_IPV6):\n\t\t\tkey_layer |= NFP_FLOWER_LAYER_IPV6;\n\t\t\tkey_size += sizeof(struct nfp_flower_ipv6);\n\t\t\tbreak;\n\n\t\t \n\t\tcase cpu_to_be16(ETH_P_ARP):\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"unsupported offload: ARP not supported\");\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tcase cpu_to_be16(ETH_P_MPLS_UC):\n\t\tcase cpu_to_be16(ETH_P_MPLS_MC):\n\t\t\tif (!(key_layer & NFP_FLOWER_LAYER_MAC)) {\n\t\t\t\tkey_layer |= NFP_FLOWER_LAYER_MAC;\n\t\t\t\tkey_size += sizeof(struct nfp_flower_mac_mpls);\n\t\t\t}\n\t\t\tbreak;\n\n\t\t \n\t\tcase cpu_to_be16(ETH_P_8021Q):\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"unsupported offload: match on given EtherType is not supported\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t} else if (nfp_flower_check_higher_than_mac(rule)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"unsupported offload: cannot match above L2 without specified EtherType\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (basic.mask && basic.mask->ip_proto) {\n\t\tswitch (basic.key->ip_proto) {\n\t\tcase IPPROTO_TCP:\n\t\tcase IPPROTO_UDP:\n\t\tcase IPPROTO_SCTP:\n\t\tcase IPPROTO_ICMP:\n\t\tcase IPPROTO_ICMPV6:\n\t\t\tkey_layer |= NFP_FLOWER_LAYER_TP;\n\t\t\tkey_size += sizeof(struct nfp_flower_tp_ports);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!(key_layer & NFP_FLOWER_LAYER_TP) &&\n\t    nfp_flower_check_higher_than_l3(rule)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"unsupported offload: cannot match on L4 information without specified IP protocol type\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_TCP)) {\n\t\tstruct flow_match_tcp tcp;\n\t\tu32 tcp_flags;\n\n\t\tflow_rule_match_tcp(rule, &tcp);\n\t\ttcp_flags = be16_to_cpu(tcp.key->flags);\n\n\t\tif (tcp_flags & ~NFP_FLOWER_SUPPORTED_TCPFLAGS) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"unsupported offload: no match support for selected TCP flags\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\n\t\t \n\t\tif ((tcp_flags & (TCPHDR_PSH | TCPHDR_URG)) &&\n\t\t    !(tcp_flags & (TCPHDR_FIN | TCPHDR_SYN | TCPHDR_RST))) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"unsupported offload: PSH and URG is only supported when used with FIN, SYN or RST\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\n\t\t \n\t\tif (!basic.key) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"unsupported offload: match on TCP flags requires a match on L3 protocol\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\n\t\tif (!(key_layer & NFP_FLOWER_LAYER_IPV4) &&\n\t\t    !(key_layer & NFP_FLOWER_LAYER_IPV6)) {\n\t\t\tswitch (basic.key->n_proto) {\n\t\t\tcase cpu_to_be16(ETH_P_IP):\n\t\t\t\tkey_layer |= NFP_FLOWER_LAYER_IPV4;\n\t\t\t\tkey_size += sizeof(struct nfp_flower_ipv4);\n\t\t\t\tbreak;\n\n\t\t\tcase cpu_to_be16(ETH_P_IPV6):\n\t\t\t\t\tkey_layer |= NFP_FLOWER_LAYER_IPV6;\n\t\t\t\tkey_size += sizeof(struct nfp_flower_ipv6);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tNL_SET_ERR_MSG_MOD(extack, \"unsupported offload: match on TCP flags requires a match on IPv4/IPv6\");\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_CONTROL)) {\n\t\tstruct flow_match_control ctl;\n\n\t\tflow_rule_match_control(rule, &ctl);\n\t\tif (ctl.key->flags & ~NFP_FLOWER_SUPPORTED_CTLFLAGS) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"unsupported offload: match on unknown control flag\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t}\n\n\tret_key_ls->key_layer = key_layer;\n\tret_key_ls->key_layer_two = key_layer_two;\n\tret_key_ls->key_size = key_size;\n\n\treturn 0;\n}\n\nstruct nfp_fl_payload *\nnfp_flower_allocate_new(struct nfp_fl_key_ls *key_layer)\n{\n\tstruct nfp_fl_payload *flow_pay;\n\n\tflow_pay = kmalloc(sizeof(*flow_pay), GFP_KERNEL);\n\tif (!flow_pay)\n\t\treturn NULL;\n\n\tflow_pay->meta.key_len = key_layer->key_size;\n\tflow_pay->unmasked_data = kmalloc(key_layer->key_size, GFP_KERNEL);\n\tif (!flow_pay->unmasked_data)\n\t\tgoto err_free_flow;\n\n\tflow_pay->meta.mask_len = key_layer->key_size;\n\tflow_pay->mask_data = kmalloc(key_layer->key_size, GFP_KERNEL);\n\tif (!flow_pay->mask_data)\n\t\tgoto err_free_unmasked;\n\n\tflow_pay->action_data = kmalloc(NFP_FL_MAX_A_SIZ, GFP_KERNEL);\n\tif (!flow_pay->action_data)\n\t\tgoto err_free_mask;\n\n\tflow_pay->nfp_tun_ipv4_addr = 0;\n\tflow_pay->nfp_tun_ipv6 = NULL;\n\tflow_pay->meta.flags = 0;\n\tINIT_LIST_HEAD(&flow_pay->linked_flows);\n\tflow_pay->in_hw = false;\n\tflow_pay->pre_tun_rule.dev = NULL;\n\n\treturn flow_pay;\n\nerr_free_mask:\n\tkfree(flow_pay->mask_data);\nerr_free_unmasked:\n\tkfree(flow_pay->unmasked_data);\nerr_free_flow:\n\tkfree(flow_pay);\n\treturn NULL;\n}\n\nstatic int\nnfp_flower_update_merge_with_actions(struct nfp_fl_payload *flow,\n\t\t\t\t     struct nfp_flower_merge_check *merge,\n\t\t\t\t     u8 *last_act_id, int *act_out)\n{\n\tstruct nfp_fl_set_ipv6_tc_hl_fl *ipv6_tc_hl_fl;\n\tstruct nfp_fl_set_ip4_ttl_tos *ipv4_ttl_tos;\n\tstruct nfp_fl_set_ip4_addrs *ipv4_add;\n\tstruct nfp_fl_set_ipv6_addr *ipv6_add;\n\tstruct nfp_fl_push_vlan *push_vlan;\n\tstruct nfp_fl_pre_tunnel *pre_tun;\n\tstruct nfp_fl_set_tport *tport;\n\tstruct nfp_fl_set_eth *eth;\n\tstruct nfp_fl_act_head *a;\n\tunsigned int act_off = 0;\n\tbool ipv6_tun = false;\n\tu8 act_id = 0;\n\tu8 *ports;\n\tint i;\n\n\twhile (act_off < flow->meta.act_len) {\n\t\ta = (struct nfp_fl_act_head *)&flow->action_data[act_off];\n\t\tact_id = a->jump_id;\n\n\t\tswitch (act_id) {\n\t\tcase NFP_FL_ACTION_OPCODE_OUTPUT:\n\t\t\tif (act_out)\n\t\t\t\t(*act_out)++;\n\t\t\tbreak;\n\t\tcase NFP_FL_ACTION_OPCODE_PUSH_VLAN:\n\t\t\tpush_vlan = (struct nfp_fl_push_vlan *)a;\n\t\t\tif (push_vlan->vlan_tci)\n\t\t\t\tmerge->tci = cpu_to_be16(0xffff);\n\t\t\tbreak;\n\t\tcase NFP_FL_ACTION_OPCODE_POP_VLAN:\n\t\t\tmerge->tci = cpu_to_be16(0);\n\t\t\tbreak;\n\t\tcase NFP_FL_ACTION_OPCODE_SET_TUNNEL:\n\t\t\t \n\t\t\teth_broadcast_addr(&merge->l2.mac_dst[0]);\n\t\t\teth_broadcast_addr(&merge->l2.mac_src[0]);\n\t\t\tmemset(&merge->l4, 0xff,\n\t\t\t       sizeof(struct nfp_flower_tp_ports));\n\t\t\tif (ipv6_tun)\n\t\t\t\tmemset(&merge->ipv6, 0xff,\n\t\t\t\t       sizeof(struct nfp_flower_ipv6));\n\t\t\telse\n\t\t\t\tmemset(&merge->ipv4, 0xff,\n\t\t\t\t       sizeof(struct nfp_flower_ipv4));\n\t\t\tbreak;\n\t\tcase NFP_FL_ACTION_OPCODE_SET_ETHERNET:\n\t\t\teth = (struct nfp_fl_set_eth *)a;\n\t\t\tfor (i = 0; i < ETH_ALEN; i++)\n\t\t\t\tmerge->l2.mac_dst[i] |= eth->eth_addr_mask[i];\n\t\t\tfor (i = 0; i < ETH_ALEN; i++)\n\t\t\t\tmerge->l2.mac_src[i] |=\n\t\t\t\t\teth->eth_addr_mask[ETH_ALEN + i];\n\t\t\tbreak;\n\t\tcase NFP_FL_ACTION_OPCODE_SET_IPV4_ADDRS:\n\t\t\tipv4_add = (struct nfp_fl_set_ip4_addrs *)a;\n\t\t\tmerge->ipv4.ipv4_src |= ipv4_add->ipv4_src_mask;\n\t\t\tmerge->ipv4.ipv4_dst |= ipv4_add->ipv4_dst_mask;\n\t\t\tbreak;\n\t\tcase NFP_FL_ACTION_OPCODE_SET_IPV4_TTL_TOS:\n\t\t\tipv4_ttl_tos = (struct nfp_fl_set_ip4_ttl_tos *)a;\n\t\t\tmerge->ipv4.ip_ext.ttl |= ipv4_ttl_tos->ipv4_ttl_mask;\n\t\t\tmerge->ipv4.ip_ext.tos |= ipv4_ttl_tos->ipv4_tos_mask;\n\t\t\tbreak;\n\t\tcase NFP_FL_ACTION_OPCODE_SET_IPV6_SRC:\n\t\t\tipv6_add = (struct nfp_fl_set_ipv6_addr *)a;\n\t\t\tfor (i = 0; i < 4; i++)\n\t\t\t\tmerge->ipv6.ipv6_src.in6_u.u6_addr32[i] |=\n\t\t\t\t\tipv6_add->ipv6[i].mask;\n\t\t\tbreak;\n\t\tcase NFP_FL_ACTION_OPCODE_SET_IPV6_DST:\n\t\t\tipv6_add = (struct nfp_fl_set_ipv6_addr *)a;\n\t\t\tfor (i = 0; i < 4; i++)\n\t\t\t\tmerge->ipv6.ipv6_dst.in6_u.u6_addr32[i] |=\n\t\t\t\t\tipv6_add->ipv6[i].mask;\n\t\t\tbreak;\n\t\tcase NFP_FL_ACTION_OPCODE_SET_IPV6_TC_HL_FL:\n\t\t\tipv6_tc_hl_fl = (struct nfp_fl_set_ipv6_tc_hl_fl *)a;\n\t\t\tmerge->ipv6.ip_ext.ttl |=\n\t\t\t\tipv6_tc_hl_fl->ipv6_hop_limit_mask;\n\t\t\tmerge->ipv6.ip_ext.tos |= ipv6_tc_hl_fl->ipv6_tc_mask;\n\t\t\tmerge->ipv6.ipv6_flow_label_exthdr |=\n\t\t\t\tipv6_tc_hl_fl->ipv6_label_mask;\n\t\t\tbreak;\n\t\tcase NFP_FL_ACTION_OPCODE_SET_UDP:\n\t\tcase NFP_FL_ACTION_OPCODE_SET_TCP:\n\t\t\ttport = (struct nfp_fl_set_tport *)a;\n\t\t\tports = (u8 *)&merge->l4.port_src;\n\t\t\tfor (i = 0; i < 4; i++)\n\t\t\t\tports[i] |= tport->tp_port_mask[i];\n\t\t\tbreak;\n\t\tcase NFP_FL_ACTION_OPCODE_PRE_TUNNEL:\n\t\t\tpre_tun = (struct nfp_fl_pre_tunnel *)a;\n\t\t\tipv6_tun = be16_to_cpu(pre_tun->flags) &\n\t\t\t\t\tNFP_FL_PRE_TUN_IPV6;\n\t\t\tbreak;\n\t\tcase NFP_FL_ACTION_OPCODE_PRE_LAG:\n\t\tcase NFP_FL_ACTION_OPCODE_PUSH_GENEVE:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\n\t\tact_off += a->len_lw << NFP_FL_LW_SIZ;\n\t}\n\n\tif (last_act_id)\n\t\t*last_act_id = act_id;\n\n\treturn 0;\n}\n\nstatic int\nnfp_flower_populate_merge_match(struct nfp_fl_payload *flow,\n\t\t\t\tstruct nfp_flower_merge_check *merge,\n\t\t\t\tbool extra_fields)\n{\n\tstruct nfp_flower_meta_tci *meta_tci;\n\tu8 *mask = flow->mask_data;\n\tu8 key_layer, match_size;\n\n\tmemset(merge, 0, sizeof(struct nfp_flower_merge_check));\n\n\tmeta_tci = (struct nfp_flower_meta_tci *)mask;\n\tkey_layer = meta_tci->nfp_flow_key_layer;\n\n\tif (key_layer & ~NFP_FLOWER_MERGE_FIELDS && !extra_fields)\n\t\treturn -EOPNOTSUPP;\n\n\tmerge->tci = meta_tci->tci;\n\tmask += sizeof(struct nfp_flower_meta_tci);\n\n\tif (key_layer & NFP_FLOWER_LAYER_EXT_META)\n\t\tmask += sizeof(struct nfp_flower_ext_meta);\n\n\tmask += sizeof(struct nfp_flower_in_port);\n\n\tif (key_layer & NFP_FLOWER_LAYER_MAC) {\n\t\tmatch_size = sizeof(struct nfp_flower_mac_mpls);\n\t\tmemcpy(&merge->l2, mask, match_size);\n\t\tmask += match_size;\n\t}\n\n\tif (key_layer & NFP_FLOWER_LAYER_TP) {\n\t\tmatch_size = sizeof(struct nfp_flower_tp_ports);\n\t\tmemcpy(&merge->l4, mask, match_size);\n\t\tmask += match_size;\n\t}\n\n\tif (key_layer & NFP_FLOWER_LAYER_IPV4) {\n\t\tmatch_size = sizeof(struct nfp_flower_ipv4);\n\t\tmemcpy(&merge->ipv4, mask, match_size);\n\t}\n\n\tif (key_layer & NFP_FLOWER_LAYER_IPV6) {\n\t\tmatch_size = sizeof(struct nfp_flower_ipv6);\n\t\tmemcpy(&merge->ipv6, mask, match_size);\n\t}\n\n\treturn 0;\n}\n\nstatic int\nnfp_flower_can_merge(struct nfp_fl_payload *sub_flow1,\n\t\t     struct nfp_fl_payload *sub_flow2)\n{\n\t \n\tstruct nfp_flower_merge_check sub_flow1_merge, sub_flow2_merge;\n\tint err, act_out = 0;\n\tu8 last_act_id = 0;\n\n\terr = nfp_flower_populate_merge_match(sub_flow1, &sub_flow1_merge,\n\t\t\t\t\t      true);\n\tif (err)\n\t\treturn err;\n\n\terr = nfp_flower_populate_merge_match(sub_flow2, &sub_flow2_merge,\n\t\t\t\t\t      false);\n\tif (err)\n\t\treturn err;\n\n\terr = nfp_flower_update_merge_with_actions(sub_flow1, &sub_flow1_merge,\n\t\t\t\t\t\t   &last_act_id, &act_out);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (act_out != 1 || last_act_id != NFP_FL_ACTION_OPCODE_OUTPUT)\n\t\treturn -EOPNOTSUPP;\n\n\t \n\terr = bitmap_andnot(sub_flow2_merge.vals, sub_flow2_merge.vals,\n\t\t\t    sub_flow1_merge.vals,\n\t\t\t    sizeof(struct nfp_flower_merge_check) * 8);\n\tif (err)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic unsigned int\nnfp_flower_copy_pre_actions(char *act_dst, char *act_src, int len,\n\t\t\t    bool *tunnel_act)\n{\n\tunsigned int act_off = 0, act_len;\n\tstruct nfp_fl_act_head *a;\n\tu8 act_id = 0;\n\n\twhile (act_off < len) {\n\t\ta = (struct nfp_fl_act_head *)&act_src[act_off];\n\t\tact_len = a->len_lw << NFP_FL_LW_SIZ;\n\t\tact_id = a->jump_id;\n\n\t\tswitch (act_id) {\n\t\tcase NFP_FL_ACTION_OPCODE_PRE_TUNNEL:\n\t\t\tif (tunnel_act)\n\t\t\t\t*tunnel_act = true;\n\t\t\tfallthrough;\n\t\tcase NFP_FL_ACTION_OPCODE_PRE_LAG:\n\t\t\tmemcpy(act_dst + act_off, act_src + act_off, act_len);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn act_off;\n\t\t}\n\n\t\tact_off += act_len;\n\t}\n\n\treturn act_off;\n}\n\nstatic int\nnfp_fl_verify_post_tun_acts(char *acts, int len, struct nfp_fl_push_vlan **vlan)\n{\n\tstruct nfp_fl_act_head *a;\n\tunsigned int act_off = 0;\n\n\twhile (act_off < len) {\n\t\ta = (struct nfp_fl_act_head *)&acts[act_off];\n\n\t\tif (a->jump_id == NFP_FL_ACTION_OPCODE_PUSH_VLAN && !act_off)\n\t\t\t*vlan = (struct nfp_fl_push_vlan *)a;\n\t\telse if (a->jump_id != NFP_FL_ACTION_OPCODE_OUTPUT)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tact_off += a->len_lw << NFP_FL_LW_SIZ;\n\t}\n\n\t \n\tif (*vlan && act_off <= sizeof(struct nfp_fl_push_vlan))\n\t\treturn -EOPNOTSUPP;\n\n\treturn 0;\n}\n\nstatic int\nnfp_fl_push_vlan_after_tun(char *acts, int len, struct nfp_fl_push_vlan *vlan)\n{\n\tstruct nfp_fl_set_tun *tun;\n\tstruct nfp_fl_act_head *a;\n\tunsigned int act_off = 0;\n\n\twhile (act_off < len) {\n\t\ta = (struct nfp_fl_act_head *)&acts[act_off];\n\n\t\tif (a->jump_id == NFP_FL_ACTION_OPCODE_SET_TUNNEL) {\n\t\t\ttun = (struct nfp_fl_set_tun *)a;\n\t\t\ttun->outer_vlan_tpid = vlan->vlan_tpid;\n\t\t\ttun->outer_vlan_tci = vlan->vlan_tci;\n\n\t\t\treturn 0;\n\t\t}\n\n\t\tact_off += a->len_lw << NFP_FL_LW_SIZ;\n\t}\n\n\t \n\treturn -EOPNOTSUPP;\n}\n\nstatic int\nnfp_flower_merge_action(struct nfp_fl_payload *sub_flow1,\n\t\t\tstruct nfp_fl_payload *sub_flow2,\n\t\t\tstruct nfp_fl_payload *merge_flow)\n{\n\tunsigned int sub1_act_len, sub2_act_len, pre_off1, pre_off2;\n\tstruct nfp_fl_push_vlan *post_tun_push_vlan = NULL;\n\tbool tunnel_act = false;\n\tchar *merge_act;\n\tint err;\n\n\t \n\tsub1_act_len = sub_flow1->meta.act_len - sizeof(struct nfp_fl_output);\n\tsub2_act_len = sub_flow2->meta.act_len;\n\n\tif (!sub2_act_len)\n\t\treturn -EINVAL;\n\n\tif (sub1_act_len + sub2_act_len > NFP_FL_MAX_A_SIZ)\n\t\treturn -EINVAL;\n\n\t \n\tif (sub1_act_len)\n\t\tmerge_flow->meta.shortcut = cpu_to_be32(NFP_FL_SC_ACT_NULL);\n\telse\n\t\tmerge_flow->meta.shortcut = sub_flow2->meta.shortcut;\n\n\tmerge_flow->meta.act_len = sub1_act_len + sub2_act_len;\n\tmerge_act = merge_flow->action_data;\n\n\t \n\tpre_off1 = nfp_flower_copy_pre_actions(merge_act,\n\t\t\t\t\t       sub_flow1->action_data,\n\t\t\t\t\t       sub1_act_len, &tunnel_act);\n\tmerge_act += pre_off1;\n\tsub1_act_len -= pre_off1;\n\tpre_off2 = nfp_flower_copy_pre_actions(merge_act,\n\t\t\t\t\t       sub_flow2->action_data,\n\t\t\t\t\t       sub2_act_len, NULL);\n\tmerge_act += pre_off2;\n\tsub2_act_len -= pre_off2;\n\n\t \n\tif (tunnel_act) {\n\t\tchar *post_tun_acts = &sub_flow2->action_data[pre_off2];\n\n\t\terr = nfp_fl_verify_post_tun_acts(post_tun_acts, sub2_act_len,\n\t\t\t\t\t\t  &post_tun_push_vlan);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (post_tun_push_vlan) {\n\t\t\tpre_off2 += sizeof(*post_tun_push_vlan);\n\t\t\tsub2_act_len -= sizeof(*post_tun_push_vlan);\n\t\t}\n\t}\n\n\t \n\tmemcpy(merge_act, sub_flow1->action_data + pre_off1, sub1_act_len);\n\n\tif (post_tun_push_vlan) {\n\t\t \n\t\terr = nfp_fl_push_vlan_after_tun(merge_act, sub1_act_len,\n\t\t\t\t\t\t post_tun_push_vlan);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tmerge_flow->meta.act_len -= sizeof(*post_tun_push_vlan);\n\t}\n\n\tmerge_act += sub1_act_len;\n\tmemcpy(merge_act, sub_flow2->action_data + pre_off2, sub2_act_len);\n\n\treturn 0;\n}\n\n \nstatic void nfp_flower_unlink_flow(struct nfp_fl_payload_link *link)\n{\n\tlist_del(&link->merge_flow.list);\n\tlist_del(&link->sub_flow.list);\n\tkfree(link);\n}\n\nstatic void nfp_flower_unlink_flows(struct nfp_fl_payload *merge_flow,\n\t\t\t\t    struct nfp_fl_payload *sub_flow)\n{\n\tstruct nfp_fl_payload_link *link;\n\n\tlist_for_each_entry(link, &merge_flow->linked_flows, merge_flow.list)\n\t\tif (link->sub_flow.flow == sub_flow) {\n\t\t\tnfp_flower_unlink_flow(link);\n\t\t\treturn;\n\t\t}\n}\n\nstatic int nfp_flower_link_flows(struct nfp_fl_payload *merge_flow,\n\t\t\t\t struct nfp_fl_payload *sub_flow)\n{\n\tstruct nfp_fl_payload_link *link;\n\n\tlink = kmalloc(sizeof(*link), GFP_KERNEL);\n\tif (!link)\n\t\treturn -ENOMEM;\n\n\tlink->merge_flow.flow = merge_flow;\n\tlist_add_tail(&link->merge_flow.list, &merge_flow->linked_flows);\n\tlink->sub_flow.flow = sub_flow;\n\tlist_add_tail(&link->sub_flow.list, &sub_flow->linked_flows);\n\n\treturn 0;\n}\n\n \nint nfp_flower_merge_offloaded_flows(struct nfp_app *app,\n\t\t\t\t     struct nfp_fl_payload *sub_flow1,\n\t\t\t\t     struct nfp_fl_payload *sub_flow2)\n{\n\tstruct nfp_flower_priv *priv = app->priv;\n\tstruct nfp_fl_payload *merge_flow;\n\tstruct nfp_fl_key_ls merge_key_ls;\n\tstruct nfp_merge_info *merge_info;\n\tu64 parent_ctx = 0;\n\tint err;\n\n\tif (sub_flow1 == sub_flow2 ||\n\t    nfp_flower_is_merge_flow(sub_flow1) ||\n\t    nfp_flower_is_merge_flow(sub_flow2))\n\t\treturn -EINVAL;\n\n\t \n\tparent_ctx = (u64)(be32_to_cpu(sub_flow1->meta.host_ctx_id)) << 32;\n\tparent_ctx |= (u64)(be32_to_cpu(sub_flow2->meta.host_ctx_id));\n\tif (rhashtable_lookup_fast(&priv->merge_table,\n\t\t\t\t   &parent_ctx, merge_table_params)) {\n\t\tnfp_flower_cmsg_warn(app, \"The two flows are already merged.\\n\");\n\t\treturn 0;\n\t}\n\n\terr = nfp_flower_can_merge(sub_flow1, sub_flow2);\n\tif (err)\n\t\treturn err;\n\n\tmerge_key_ls.key_size = sub_flow1->meta.key_len;\n\n\tmerge_flow = nfp_flower_allocate_new(&merge_key_ls);\n\tif (!merge_flow)\n\t\treturn -ENOMEM;\n\n\tmerge_flow->tc_flower_cookie = (unsigned long)merge_flow;\n\tmerge_flow->ingress_dev = sub_flow1->ingress_dev;\n\n\tmemcpy(merge_flow->unmasked_data, sub_flow1->unmasked_data,\n\t       sub_flow1->meta.key_len);\n\tmemcpy(merge_flow->mask_data, sub_flow1->mask_data,\n\t       sub_flow1->meta.mask_len);\n\n\terr = nfp_flower_merge_action(sub_flow1, sub_flow2, merge_flow);\n\tif (err)\n\t\tgoto err_destroy_merge_flow;\n\n\terr = nfp_flower_link_flows(merge_flow, sub_flow1);\n\tif (err)\n\t\tgoto err_destroy_merge_flow;\n\n\terr = nfp_flower_link_flows(merge_flow, sub_flow2);\n\tif (err)\n\t\tgoto err_unlink_sub_flow1;\n\n\terr = nfp_compile_flow_metadata(app, merge_flow->tc_flower_cookie, merge_flow,\n\t\t\t\t\tmerge_flow->ingress_dev, NULL);\n\tif (err)\n\t\tgoto err_unlink_sub_flow2;\n\n\terr = rhashtable_insert_fast(&priv->flow_table, &merge_flow->fl_node,\n\t\t\t\t     nfp_flower_table_params);\n\tif (err)\n\t\tgoto err_release_metadata;\n\n\tmerge_info = kmalloc(sizeof(*merge_info), GFP_KERNEL);\n\tif (!merge_info) {\n\t\terr = -ENOMEM;\n\t\tgoto err_remove_rhash;\n\t}\n\tmerge_info->parent_ctx = parent_ctx;\n\terr = rhashtable_insert_fast(&priv->merge_table, &merge_info->ht_node,\n\t\t\t\t     merge_table_params);\n\tif (err)\n\t\tgoto err_destroy_merge_info;\n\n\terr = nfp_flower_xmit_flow(app, merge_flow,\n\t\t\t\t   NFP_FLOWER_CMSG_TYPE_FLOW_MOD);\n\tif (err)\n\t\tgoto err_remove_merge_info;\n\n\tmerge_flow->in_hw = true;\n\tsub_flow1->in_hw = false;\n\n\treturn 0;\n\nerr_remove_merge_info:\n\tWARN_ON_ONCE(rhashtable_remove_fast(&priv->merge_table,\n\t\t\t\t\t    &merge_info->ht_node,\n\t\t\t\t\t    merge_table_params));\nerr_destroy_merge_info:\n\tkfree(merge_info);\nerr_remove_rhash:\n\tWARN_ON_ONCE(rhashtable_remove_fast(&priv->flow_table,\n\t\t\t\t\t    &merge_flow->fl_node,\n\t\t\t\t\t    nfp_flower_table_params));\nerr_release_metadata:\n\tnfp_modify_flow_metadata(app, merge_flow);\nerr_unlink_sub_flow2:\n\tnfp_flower_unlink_flows(merge_flow, sub_flow2);\nerr_unlink_sub_flow1:\n\tnfp_flower_unlink_flows(merge_flow, sub_flow1);\nerr_destroy_merge_flow:\n\tkfree(merge_flow->action_data);\n\tkfree(merge_flow->mask_data);\n\tkfree(merge_flow->unmasked_data);\n\tkfree(merge_flow);\n\treturn err;\n}\n\n \nstatic int\nnfp_flower_validate_pre_tun_rule(struct nfp_app *app,\n\t\t\t\t struct nfp_fl_payload *flow,\n\t\t\t\t struct nfp_fl_key_ls *key_ls,\n\t\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct nfp_flower_priv *priv = app->priv;\n\tstruct nfp_flower_meta_tci *meta_tci;\n\tstruct nfp_flower_mac_mpls *mac;\n\tu8 *ext = flow->unmasked_data;\n\tstruct nfp_fl_act_head *act;\n\tu8 *mask = flow->mask_data;\n\tbool vlan = false;\n\tint act_offset;\n\tu8 key_layer;\n\n\tmeta_tci = (struct nfp_flower_meta_tci *)flow->unmasked_data;\n\tkey_layer = key_ls->key_layer;\n\tif (!(priv->flower_ext_feats & NFP_FL_FEATS_VLAN_QINQ)) {\n\t\tif (meta_tci->tci & cpu_to_be16(NFP_FLOWER_MASK_VLAN_PRESENT)) {\n\t\t\tu16 vlan_tci = be16_to_cpu(meta_tci->tci);\n\n\t\t\tvlan_tci &= ~NFP_FLOWER_MASK_VLAN_PRESENT;\n\t\t\tflow->pre_tun_rule.vlan_tci = cpu_to_be16(vlan_tci);\n\t\t\tvlan = true;\n\t\t} else {\n\t\t\tflow->pre_tun_rule.vlan_tci = cpu_to_be16(0xffff);\n\t\t}\n\t}\n\n\tif (key_layer & ~NFP_FLOWER_PRE_TUN_RULE_FIELDS) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"unsupported pre-tunnel rule: too many match fields\");\n\t\treturn -EOPNOTSUPP;\n\t} else if (key_ls->key_layer_two & ~NFP_FLOWER_LAYER2_QINQ) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"unsupported pre-tunnel rule: non-vlan in extended match fields\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (!(key_layer & NFP_FLOWER_LAYER_MAC)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"unsupported pre-tunnel rule: MAC fields match required\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (!(key_layer & NFP_FLOWER_LAYER_IPV4) &&\n\t    !(key_layer & NFP_FLOWER_LAYER_IPV6)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"unsupported pre-tunnel rule: match on ipv4/ipv6 eth_type must be present\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (key_layer & NFP_FLOWER_LAYER_IPV6)\n\t\tflow->pre_tun_rule.is_ipv6 = true;\n\telse\n\t\tflow->pre_tun_rule.is_ipv6 = false;\n\n\t \n\tmask += sizeof(struct nfp_flower_meta_tci);\n\text += sizeof(struct nfp_flower_meta_tci);\n\tif (key_ls->key_layer_two) {\n\t\tmask += sizeof(struct nfp_flower_ext_meta);\n\t\text += sizeof(struct nfp_flower_ext_meta);\n\t}\n\tmask += sizeof(struct nfp_flower_in_port);\n\text += sizeof(struct nfp_flower_in_port);\n\n\t \n\tmac = (struct nfp_flower_mac_mpls *)mask;\n\tif (!is_broadcast_ether_addr(&mac->mac_dst[0])) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"unsupported pre-tunnel rule: dest MAC field must not be masked\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t \n\tif (priv->flower_ext_feats & NFP_FL_FEATS_DECAP_V2) {\n\t\tmac = (struct nfp_flower_mac_mpls *)mask;\n\t\tif (!is_broadcast_ether_addr(&mac->mac_src[0])) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t   \"unsupported pre-tunnel rule: source MAC field must not be masked\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t}\n\n\tif (mac->mpls_lse) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"unsupported pre-tunnel rule: MPLS not supported\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t \n\tmac = (struct nfp_flower_mac_mpls *)ext;\n\tif (memcmp(&mac->mac_dst[0], flow->pre_tun_rule.dev->dev_addr, 6)) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"unsupported pre-tunnel rule: dest MAC must match output dev MAC\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t \n\tmemcpy(&flow->pre_tun_rule.loc_mac, &mac->mac_dst[0], ETH_ALEN);\n\tmemcpy(&flow->pre_tun_rule.rem_mac, &mac->mac_src[0], ETH_ALEN);\n\n\tmask += sizeof(struct nfp_flower_mac_mpls);\n\text += sizeof(struct nfp_flower_mac_mpls);\n\tif (key_layer & NFP_FLOWER_LAYER_IPV4 ||\n\t    key_layer & NFP_FLOWER_LAYER_IPV6) {\n\t\t \n\t\tint ip_flags = offsetof(struct nfp_flower_ipv4, ip_ext.flags);\n\t\tint ip_proto = offsetof(struct nfp_flower_ipv4, ip_ext.proto);\n\t\tint size;\n\t\tint i;\n\n\t\tsize = key_layer & NFP_FLOWER_LAYER_IPV4 ?\n\t\t\tsizeof(struct nfp_flower_ipv4) :\n\t\t\tsizeof(struct nfp_flower_ipv6);\n\n\n\t\t \n\t\tfor (i = 0; i < size; i++)\n\t\t\tif (mask[i] && i != ip_flags && i != ip_proto) {\n\t\t\t\tNL_SET_ERR_MSG_MOD(extack, \"unsupported pre-tunnel rule: only flags and proto can be matched in ip header\");\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t\t}\n\t\text += size;\n\t\tmask += size;\n\t}\n\n\tif ((priv->flower_ext_feats & NFP_FL_FEATS_VLAN_QINQ)) {\n\t\tif (key_ls->key_layer_two & NFP_FLOWER_LAYER2_QINQ) {\n\t\t\tstruct nfp_flower_vlan *vlan_tags;\n\t\t\tu16 vlan_tpid;\n\t\t\tu16 vlan_tci;\n\n\t\t\tvlan_tags = (struct nfp_flower_vlan *)ext;\n\n\t\t\tvlan_tci = be16_to_cpu(vlan_tags->outer_tci);\n\t\t\tvlan_tpid = be16_to_cpu(vlan_tags->outer_tpid);\n\n\t\t\tvlan_tci &= ~NFP_FLOWER_MASK_VLAN_PRESENT;\n\t\t\tflow->pre_tun_rule.vlan_tci = cpu_to_be16(vlan_tci);\n\t\t\tflow->pre_tun_rule.vlan_tpid = cpu_to_be16(vlan_tpid);\n\t\t\tvlan = true;\n\t\t} else {\n\t\t\tflow->pre_tun_rule.vlan_tci = cpu_to_be16(0xffff);\n\t\t\tflow->pre_tun_rule.vlan_tpid = cpu_to_be16(0xffff);\n\t\t}\n\t}\n\n\t \n\tact_offset = 0;\n\tact = (struct nfp_fl_act_head *)&flow->action_data[act_offset];\n\tif (vlan) {\n\t\tif (act->jump_id != NFP_FL_ACTION_OPCODE_POP_VLAN) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"unsupported pre-tunnel rule: match on VLAN must have VLAN pop as first action\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\n\t\tact_offset += act->len_lw << NFP_FL_LW_SIZ;\n\t\tact = (struct nfp_fl_act_head *)&flow->action_data[act_offset];\n\t}\n\n\tif (act->jump_id != NFP_FL_ACTION_OPCODE_OUTPUT) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"unsupported pre-tunnel rule: non egress action detected where egress was expected\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tact_offset += act->len_lw << NFP_FL_LW_SIZ;\n\n\t \n\tif (act_offset != flow->meta.act_len) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"unsupported pre-tunnel rule: egress is not the last action\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic bool offload_pre_check(struct flow_cls_offload *flow)\n{\n\tstruct flow_rule *rule = flow_cls_offload_flow_rule(flow);\n\tstruct flow_dissector *dissector = rule->match.dissector;\n\tstruct flow_match_ct ct;\n\n\tif (dissector->used_keys & BIT_ULL(FLOW_DISSECTOR_KEY_CT)) {\n\t\tflow_rule_match_ct(rule, &ct);\n\t\t \n\t\tif (memchr_inv(ct.key, 0, sizeof(*ct.key)))\n\t\t\treturn false;\n\t}\n\n\tif (flow->common.chain_index)\n\t\treturn false;\n\n\treturn true;\n}\n\n \nstatic int\nnfp_flower_add_offload(struct nfp_app *app, struct net_device *netdev,\n\t\t       struct flow_cls_offload *flow)\n{\n\tstruct flow_rule *rule = flow_cls_offload_flow_rule(flow);\n\tenum nfp_flower_tun_type tun_type = NFP_FL_TUNNEL_NONE;\n\tstruct nfp_flower_priv *priv = app->priv;\n\tstruct netlink_ext_ack *extack = NULL;\n\tstruct nfp_fl_payload *flow_pay;\n\tstruct nfp_fl_key_ls *key_layer;\n\tstruct nfp_port *port = NULL;\n\tint err;\n\n\textack = flow->common.extack;\n\tif (nfp_netdev_is_nfp_repr(netdev))\n\t\tport = nfp_port_from_netdev(netdev);\n\n\tif (is_pre_ct_flow(flow))\n\t\treturn nfp_fl_ct_handle_pre_ct(priv, netdev, flow, extack, NULL);\n\n\tif (is_post_ct_flow(flow))\n\t\treturn nfp_fl_ct_handle_post_ct(priv, netdev, flow, extack);\n\n\tif (!offload_pre_check(flow))\n\t\treturn -EOPNOTSUPP;\n\n\tkey_layer = kmalloc(sizeof(*key_layer), GFP_KERNEL);\n\tif (!key_layer)\n\t\treturn -ENOMEM;\n\n\terr = nfp_flower_calculate_key_layers(app, netdev, key_layer, rule,\n\t\t\t\t\t      &tun_type, extack);\n\tif (err)\n\t\tgoto err_free_key_ls;\n\n\tflow_pay = nfp_flower_allocate_new(key_layer);\n\tif (!flow_pay) {\n\t\terr = -ENOMEM;\n\t\tgoto err_free_key_ls;\n\t}\n\n\terr = nfp_flower_compile_flow_match(app, rule, key_layer, netdev,\n\t\t\t\t\t    flow_pay, tun_type, extack);\n\tif (err)\n\t\tgoto err_destroy_flow;\n\n\terr = nfp_flower_compile_action(app, rule, netdev, flow_pay, extack);\n\tif (err)\n\t\tgoto err_destroy_flow;\n\n\tif (flow_pay->pre_tun_rule.dev) {\n\t\terr = nfp_flower_validate_pre_tun_rule(app, flow_pay, key_layer, extack);\n\t\tif (err)\n\t\t\tgoto err_destroy_flow;\n\t}\n\n\terr = nfp_compile_flow_metadata(app, flow->cookie, flow_pay, netdev, extack);\n\tif (err)\n\t\tgoto err_destroy_flow;\n\n\tflow_pay->tc_flower_cookie = flow->cookie;\n\terr = rhashtable_insert_fast(&priv->flow_table, &flow_pay->fl_node,\n\t\t\t\t     nfp_flower_table_params);\n\tif (err) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"invalid entry: cannot insert flow into tables for offloads\");\n\t\tgoto err_release_metadata;\n\t}\n\n\tif (flow_pay->pre_tun_rule.dev) {\n\t\tif (priv->flower_ext_feats & NFP_FL_FEATS_DECAP_V2) {\n\t\t\tstruct nfp_predt_entry *predt;\n\n\t\t\tpredt = kzalloc(sizeof(*predt), GFP_KERNEL);\n\t\t\tif (!predt) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto err_remove_rhash;\n\t\t\t}\n\t\t\tpredt->flow_pay = flow_pay;\n\t\t\tINIT_LIST_HEAD(&predt->nn_list);\n\t\t\tspin_lock_bh(&priv->predt_lock);\n\t\t\tlist_add(&predt->list_head, &priv->predt_list);\n\t\t\tflow_pay->pre_tun_rule.predt = predt;\n\t\t\tnfp_tun_link_and_update_nn_entries(app, predt);\n\t\t\tspin_unlock_bh(&priv->predt_lock);\n\t\t} else {\n\t\t\terr = nfp_flower_xmit_pre_tun_flow(app, flow_pay);\n\t\t}\n\t} else {\n\t\terr = nfp_flower_xmit_flow(app, flow_pay,\n\t\t\t\t\t   NFP_FLOWER_CMSG_TYPE_FLOW_ADD);\n\t}\n\n\tif (err)\n\t\tgoto err_remove_rhash;\n\n\tif (port)\n\t\tport->tc_offload_cnt++;\n\n\tflow_pay->in_hw = true;\n\n\t \n\tkfree(key_layer);\n\n\treturn 0;\n\nerr_remove_rhash:\n\tWARN_ON_ONCE(rhashtable_remove_fast(&priv->flow_table,\n\t\t\t\t\t    &flow_pay->fl_node,\n\t\t\t\t\t    nfp_flower_table_params));\nerr_release_metadata:\n\tnfp_modify_flow_metadata(app, flow_pay);\nerr_destroy_flow:\n\tif (flow_pay->nfp_tun_ipv6)\n\t\tnfp_tunnel_put_ipv6_off(app, flow_pay->nfp_tun_ipv6);\n\tkfree(flow_pay->action_data);\n\tkfree(flow_pay->mask_data);\n\tkfree(flow_pay->unmasked_data);\n\tkfree(flow_pay);\nerr_free_key_ls:\n\tkfree(key_layer);\n\treturn err;\n}\n\nstatic void\nnfp_flower_remove_merge_flow(struct nfp_app *app,\n\t\t\t     struct nfp_fl_payload *del_sub_flow,\n\t\t\t     struct nfp_fl_payload *merge_flow)\n{\n\tstruct nfp_flower_priv *priv = app->priv;\n\tstruct nfp_fl_payload_link *link, *temp;\n\tstruct nfp_merge_info *merge_info;\n\tstruct nfp_fl_payload *origin;\n\tu64 parent_ctx = 0;\n\tbool mod = false;\n\tint err;\n\n\tlink = list_first_entry(&merge_flow->linked_flows,\n\t\t\t\tstruct nfp_fl_payload_link, merge_flow.list);\n\torigin = link->sub_flow.flow;\n\n\t \n\tif (origin != del_sub_flow)\n\t\tmod = true;\n\n\terr = nfp_modify_flow_metadata(app, merge_flow);\n\tif (err) {\n\t\tnfp_flower_cmsg_warn(app, \"Metadata fail for merge flow delete.\\n\");\n\t\tgoto err_free_links;\n\t}\n\n\tif (!mod) {\n\t\terr = nfp_flower_xmit_flow(app, merge_flow,\n\t\t\t\t\t   NFP_FLOWER_CMSG_TYPE_FLOW_DEL);\n\t\tif (err) {\n\t\t\tnfp_flower_cmsg_warn(app, \"Failed to delete merged flow.\\n\");\n\t\t\tgoto err_free_links;\n\t\t}\n\t} else {\n\t\t__nfp_modify_flow_metadata(priv, origin);\n\t\terr = nfp_flower_xmit_flow(app, origin,\n\t\t\t\t\t   NFP_FLOWER_CMSG_TYPE_FLOW_MOD);\n\t\tif (err)\n\t\t\tnfp_flower_cmsg_warn(app, \"Failed to revert merge flow.\\n\");\n\t\torigin->in_hw = true;\n\t}\n\nerr_free_links:\n\t \n\tlist_for_each_entry_safe(link, temp, &merge_flow->linked_flows,\n\t\t\t\t merge_flow.list) {\n\t\tu32 ctx_id = be32_to_cpu(link->sub_flow.flow->meta.host_ctx_id);\n\n\t\tparent_ctx = (parent_ctx << 32) | (u64)(ctx_id);\n\t\tnfp_flower_unlink_flow(link);\n\t}\n\n\tmerge_info = rhashtable_lookup_fast(&priv->merge_table,\n\t\t\t\t\t    &parent_ctx,\n\t\t\t\t\t    merge_table_params);\n\tif (merge_info) {\n\t\tWARN_ON_ONCE(rhashtable_remove_fast(&priv->merge_table,\n\t\t\t\t\t\t    &merge_info->ht_node,\n\t\t\t\t\t\t    merge_table_params));\n\t\tkfree(merge_info);\n\t}\n\n\tkfree(merge_flow->action_data);\n\tkfree(merge_flow->mask_data);\n\tkfree(merge_flow->unmasked_data);\n\tWARN_ON_ONCE(rhashtable_remove_fast(&priv->flow_table,\n\t\t\t\t\t    &merge_flow->fl_node,\n\t\t\t\t\t    nfp_flower_table_params));\n\tkfree_rcu(merge_flow, rcu);\n}\n\nvoid\nnfp_flower_del_linked_merge_flows(struct nfp_app *app,\n\t\t\t\t  struct nfp_fl_payload *sub_flow)\n{\n\tstruct nfp_fl_payload_link *link, *temp;\n\n\t \n\tlist_for_each_entry_safe(link, temp, &sub_flow->linked_flows,\n\t\t\t\t sub_flow.list)\n\t\tnfp_flower_remove_merge_flow(app, sub_flow,\n\t\t\t\t\t     link->merge_flow.flow);\n}\n\n \nstatic int\nnfp_flower_del_offload(struct nfp_app *app, struct net_device *netdev,\n\t\t       struct flow_cls_offload *flow)\n{\n\tstruct nfp_flower_priv *priv = app->priv;\n\tstruct nfp_fl_ct_map_entry *ct_map_ent;\n\tstruct netlink_ext_ack *extack = NULL;\n\tstruct nfp_fl_payload *nfp_flow;\n\tstruct nfp_port *port = NULL;\n\tint err;\n\n\textack = flow->common.extack;\n\tif (nfp_netdev_is_nfp_repr(netdev))\n\t\tport = nfp_port_from_netdev(netdev);\n\n\t \n\tct_map_ent = rhashtable_lookup_fast(&priv->ct_map_table, &flow->cookie,\n\t\t\t\t\t    nfp_ct_map_params);\n\tif (ct_map_ent) {\n\t\terr = nfp_fl_ct_del_flow(ct_map_ent);\n\t\treturn err;\n\t}\n\n\tnfp_flow = nfp_flower_search_fl_table(app, flow->cookie, netdev);\n\tif (!nfp_flow) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"invalid entry: cannot remove flow that does not exist\");\n\t\treturn -ENOENT;\n\t}\n\n\terr = nfp_modify_flow_metadata(app, nfp_flow);\n\tif (err)\n\t\tgoto err_free_merge_flow;\n\n\tif (nfp_flow->nfp_tun_ipv4_addr)\n\t\tnfp_tunnel_del_ipv4_off(app, nfp_flow->nfp_tun_ipv4_addr);\n\n\tif (nfp_flow->nfp_tun_ipv6)\n\t\tnfp_tunnel_put_ipv6_off(app, nfp_flow->nfp_tun_ipv6);\n\n\tif (!nfp_flow->in_hw) {\n\t\terr = 0;\n\t\tgoto err_free_merge_flow;\n\t}\n\n\tif (nfp_flow->pre_tun_rule.dev) {\n\t\tif (priv->flower_ext_feats & NFP_FL_FEATS_DECAP_V2) {\n\t\t\tstruct nfp_predt_entry *predt;\n\n\t\t\tpredt = nfp_flow->pre_tun_rule.predt;\n\t\t\tif (predt) {\n\t\t\t\tspin_lock_bh(&priv->predt_lock);\n\t\t\t\tnfp_tun_unlink_and_update_nn_entries(app, predt);\n\t\t\t\tlist_del(&predt->list_head);\n\t\t\t\tspin_unlock_bh(&priv->predt_lock);\n\t\t\t\tkfree(predt);\n\t\t\t}\n\t\t} else {\n\t\t\terr = nfp_flower_xmit_pre_tun_del_flow(app, nfp_flow);\n\t\t}\n\t} else {\n\t\terr = nfp_flower_xmit_flow(app, nfp_flow,\n\t\t\t\t\t   NFP_FLOWER_CMSG_TYPE_FLOW_DEL);\n\t}\n\t \n\nerr_free_merge_flow:\n\tnfp_flower_del_linked_merge_flows(app, nfp_flow);\n\tif (port)\n\t\tport->tc_offload_cnt--;\n\tkfree(nfp_flow->action_data);\n\tkfree(nfp_flow->mask_data);\n\tkfree(nfp_flow->unmasked_data);\n\tWARN_ON_ONCE(rhashtable_remove_fast(&priv->flow_table,\n\t\t\t\t\t    &nfp_flow->fl_node,\n\t\t\t\t\t    nfp_flower_table_params));\n\tkfree_rcu(nfp_flow, rcu);\n\treturn err;\n}\n\nstatic void\n__nfp_flower_update_merge_stats(struct nfp_app *app,\n\t\t\t\tstruct nfp_fl_payload *merge_flow)\n{\n\tstruct nfp_flower_priv *priv = app->priv;\n\tstruct nfp_fl_payload_link *link;\n\tstruct nfp_fl_payload *sub_flow;\n\tu64 pkts, bytes, used;\n\tu32 ctx_id;\n\n\tctx_id = be32_to_cpu(merge_flow->meta.host_ctx_id);\n\tpkts = priv->stats[ctx_id].pkts;\n\t \n\tif (!pkts)\n\t\treturn;\n\tbytes = priv->stats[ctx_id].bytes;\n\tused = priv->stats[ctx_id].used;\n\n\t \n\tpriv->stats[ctx_id].pkts = 0;\n\tpriv->stats[ctx_id].bytes = 0;\n\n\t \n\tlist_for_each_entry(link, &merge_flow->linked_flows, merge_flow.list) {\n\t\tsub_flow = link->sub_flow.flow;\n\t\tctx_id = be32_to_cpu(sub_flow->meta.host_ctx_id);\n\t\tpriv->stats[ctx_id].pkts += pkts;\n\t\tpriv->stats[ctx_id].bytes += bytes;\n\t\tpriv->stats[ctx_id].used = max_t(u64, used,\n\t\t\t\t\t\t priv->stats[ctx_id].used);\n\t}\n}\n\nvoid\nnfp_flower_update_merge_stats(struct nfp_app *app,\n\t\t\t      struct nfp_fl_payload *sub_flow)\n{\n\tstruct nfp_fl_payload_link *link;\n\n\t \n\tlist_for_each_entry(link, &sub_flow->linked_flows, sub_flow.list)\n\t\t__nfp_flower_update_merge_stats(app, link->merge_flow.flow);\n}\n\n \nstatic int\nnfp_flower_get_stats(struct nfp_app *app, struct net_device *netdev,\n\t\t     struct flow_cls_offload *flow)\n{\n\tstruct nfp_flower_priv *priv = app->priv;\n\tstruct nfp_fl_ct_map_entry *ct_map_ent;\n\tstruct netlink_ext_ack *extack = NULL;\n\tstruct nfp_fl_payload *nfp_flow;\n\tu32 ctx_id;\n\n\t \n\tct_map_ent = rhashtable_lookup_fast(&priv->ct_map_table, &flow->cookie,\n\t\t\t\t\t    nfp_ct_map_params);\n\tif (ct_map_ent)\n\t\treturn nfp_fl_ct_stats(flow, ct_map_ent);\n\n\textack = flow->common.extack;\n\tnfp_flow = nfp_flower_search_fl_table(app, flow->cookie, netdev);\n\tif (!nfp_flow) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"invalid entry: cannot dump stats for flow that does not exist\");\n\t\treturn -EINVAL;\n\t}\n\n\tctx_id = be32_to_cpu(nfp_flow->meta.host_ctx_id);\n\n\tspin_lock_bh(&priv->stats_lock);\n\t \n\tif (!list_empty(&nfp_flow->linked_flows))\n\t\tnfp_flower_update_merge_stats(app, nfp_flow);\n\n\tflow_stats_update(&flow->stats, priv->stats[ctx_id].bytes,\n\t\t\t  priv->stats[ctx_id].pkts, 0, priv->stats[ctx_id].used,\n\t\t\t  FLOW_ACTION_HW_STATS_DELAYED);\n\n\tpriv->stats[ctx_id].pkts = 0;\n\tpriv->stats[ctx_id].bytes = 0;\n\tspin_unlock_bh(&priv->stats_lock);\n\n\treturn 0;\n}\n\nstatic int\nnfp_flower_repr_offload(struct nfp_app *app, struct net_device *netdev,\n\t\t\tstruct flow_cls_offload *flower)\n{\n\tstruct nfp_flower_priv *priv = app->priv;\n\tint ret;\n\n\tif (!eth_proto_is_802_3(flower->common.protocol))\n\t\treturn -EOPNOTSUPP;\n\n\tmutex_lock(&priv->nfp_fl_lock);\n\tswitch (flower->command) {\n\tcase FLOW_CLS_REPLACE:\n\t\tret = nfp_flower_add_offload(app, netdev, flower);\n\t\tbreak;\n\tcase FLOW_CLS_DESTROY:\n\t\tret = nfp_flower_del_offload(app, netdev, flower);\n\t\tbreak;\n\tcase FLOW_CLS_STATS:\n\t\tret = nfp_flower_get_stats(app, netdev, flower);\n\t\tbreak;\n\tdefault:\n\t\tret = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\tmutex_unlock(&priv->nfp_fl_lock);\n\n\treturn ret;\n}\n\nstatic int nfp_flower_setup_tc_block_cb(enum tc_setup_type type,\n\t\t\t\t\tvoid *type_data, void *cb_priv)\n{\n\tstruct flow_cls_common_offload *common = type_data;\n\tstruct nfp_repr *repr = cb_priv;\n\n\tif (!tc_can_offload_extack(repr->netdev, common->extack))\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (type) {\n\tcase TC_SETUP_CLSFLOWER:\n\t\treturn nfp_flower_repr_offload(repr->app, repr->netdev,\n\t\t\t\t\t       type_data);\n\tcase TC_SETUP_CLSMATCHALL:\n\t\treturn nfp_flower_setup_qos_offload(repr->app, repr->netdev,\n\t\t\t\t\t\t    type_data);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic LIST_HEAD(nfp_block_cb_list);\n\nstatic int nfp_flower_setup_tc_block(struct net_device *netdev,\n\t\t\t\t     struct flow_block_offload *f)\n{\n\tstruct nfp_repr *repr = netdev_priv(netdev);\n\tstruct nfp_flower_repr_priv *repr_priv;\n\tstruct flow_block_cb *block_cb;\n\n\tif (f->binder_type != FLOW_BLOCK_BINDER_TYPE_CLSACT_INGRESS)\n\t\treturn -EOPNOTSUPP;\n\n\trepr_priv = repr->app_priv;\n\trepr_priv->block_shared = f->block_shared;\n\tf->driver_block_list = &nfp_block_cb_list;\n\tf->unlocked_driver_cb = true;\n\n\tswitch (f->command) {\n\tcase FLOW_BLOCK_BIND:\n\t\tif (flow_block_cb_is_busy(nfp_flower_setup_tc_block_cb, repr,\n\t\t\t\t\t  &nfp_block_cb_list))\n\t\t\treturn -EBUSY;\n\n\t\tblock_cb = flow_block_cb_alloc(nfp_flower_setup_tc_block_cb,\n\t\t\t\t\t       repr, repr, NULL);\n\t\tif (IS_ERR(block_cb))\n\t\t\treturn PTR_ERR(block_cb);\n\n\t\tflow_block_cb_add(block_cb, f);\n\t\tlist_add_tail(&block_cb->driver_list, &nfp_block_cb_list);\n\t\treturn 0;\n\tcase FLOW_BLOCK_UNBIND:\n\t\tblock_cb = flow_block_cb_lookup(f->block,\n\t\t\t\t\t\tnfp_flower_setup_tc_block_cb,\n\t\t\t\t\t\trepr);\n\t\tif (!block_cb)\n\t\t\treturn -ENOENT;\n\n\t\tflow_block_cb_remove(block_cb, f);\n\t\tlist_del(&block_cb->driver_list);\n\t\treturn 0;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nint nfp_flower_setup_tc(struct nfp_app *app, struct net_device *netdev,\n\t\t\tenum tc_setup_type type, void *type_data)\n{\n\tswitch (type) {\n\tcase TC_SETUP_BLOCK:\n\t\treturn nfp_flower_setup_tc_block(netdev, type_data);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstruct nfp_flower_indr_block_cb_priv {\n\tstruct net_device *netdev;\n\tstruct nfp_app *app;\n\tstruct list_head list;\n};\n\nstatic struct nfp_flower_indr_block_cb_priv *\nnfp_flower_indr_block_cb_priv_lookup(struct nfp_app *app,\n\t\t\t\t     struct net_device *netdev)\n{\n\tstruct nfp_flower_indr_block_cb_priv *cb_priv;\n\tstruct nfp_flower_priv *priv = app->priv;\n\n\tlist_for_each_entry(cb_priv, &priv->indr_block_cb_priv, list)\n\t\tif (cb_priv->netdev == netdev)\n\t\t\treturn cb_priv;\n\n\treturn NULL;\n}\n\nstatic int nfp_flower_setup_indr_block_cb(enum tc_setup_type type,\n\t\t\t\t\t  void *type_data, void *cb_priv)\n{\n\tstruct nfp_flower_indr_block_cb_priv *priv = cb_priv;\n\n\tswitch (type) {\n\tcase TC_SETUP_CLSFLOWER:\n\t\treturn nfp_flower_repr_offload(priv->app, priv->netdev,\n\t\t\t\t\t       type_data);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nvoid nfp_flower_setup_indr_tc_release(void *cb_priv)\n{\n\tstruct nfp_flower_indr_block_cb_priv *priv = cb_priv;\n\n\tlist_del(&priv->list);\n\tkfree(priv);\n}\n\nstatic int\nnfp_flower_setup_indr_tc_block(struct net_device *netdev, struct Qdisc *sch, struct nfp_app *app,\n\t\t\t       struct flow_block_offload *f, void *data,\n\t\t\t       void (*cleanup)(struct flow_block_cb *block_cb))\n{\n\tstruct nfp_flower_indr_block_cb_priv *cb_priv;\n\tstruct nfp_flower_priv *priv = app->priv;\n\tstruct flow_block_cb *block_cb;\n\n\tif ((f->binder_type != FLOW_BLOCK_BINDER_TYPE_CLSACT_INGRESS &&\n\t     !nfp_flower_internal_port_can_offload(app, netdev)) ||\n\t    (f->binder_type != FLOW_BLOCK_BINDER_TYPE_CLSACT_EGRESS &&\n\t     nfp_flower_internal_port_can_offload(app, netdev)))\n\t\treturn -EOPNOTSUPP;\n\n\tf->unlocked_driver_cb = true;\n\n\tswitch (f->command) {\n\tcase FLOW_BLOCK_BIND:\n\t\tcb_priv = nfp_flower_indr_block_cb_priv_lookup(app, netdev);\n\t\tif (cb_priv &&\n\t\t    flow_block_cb_is_busy(nfp_flower_setup_indr_block_cb,\n\t\t\t\t\t  cb_priv,\n\t\t\t\t\t  &nfp_block_cb_list))\n\t\t\treturn -EBUSY;\n\n\t\tcb_priv = kmalloc(sizeof(*cb_priv), GFP_KERNEL);\n\t\tif (!cb_priv)\n\t\t\treturn -ENOMEM;\n\n\t\tcb_priv->netdev = netdev;\n\t\tcb_priv->app = app;\n\t\tlist_add(&cb_priv->list, &priv->indr_block_cb_priv);\n\n\t\tblock_cb = flow_indr_block_cb_alloc(nfp_flower_setup_indr_block_cb,\n\t\t\t\t\t\t    cb_priv, cb_priv,\n\t\t\t\t\t\t    nfp_flower_setup_indr_tc_release,\n\t\t\t\t\t\t    f, netdev, sch, data, app, cleanup);\n\t\tif (IS_ERR(block_cb)) {\n\t\t\tlist_del(&cb_priv->list);\n\t\t\tkfree(cb_priv);\n\t\t\treturn PTR_ERR(block_cb);\n\t\t}\n\n\t\tflow_block_cb_add(block_cb, f);\n\t\tlist_add_tail(&block_cb->driver_list, &nfp_block_cb_list);\n\t\treturn 0;\n\tcase FLOW_BLOCK_UNBIND:\n\t\tcb_priv = nfp_flower_indr_block_cb_priv_lookup(app, netdev);\n\t\tif (!cb_priv)\n\t\t\treturn -ENOENT;\n\n\t\tblock_cb = flow_block_cb_lookup(f->block,\n\t\t\t\t\t\tnfp_flower_setup_indr_block_cb,\n\t\t\t\t\t\tcb_priv);\n\t\tif (!block_cb)\n\t\t\treturn -ENOENT;\n\n\t\tflow_indr_block_cb_remove(block_cb, f);\n\t\tlist_del(&block_cb->driver_list);\n\t\treturn 0;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn 0;\n}\n\nstatic int\nnfp_setup_tc_no_dev(struct nfp_app *app, enum tc_setup_type type, void *data)\n{\n\tif (!data)\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (type) {\n\tcase TC_SETUP_ACT:\n\t\treturn nfp_setup_tc_act_offload(app, data);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nint\nnfp_flower_indr_setup_tc_cb(struct net_device *netdev, struct Qdisc *sch, void *cb_priv,\n\t\t\t    enum tc_setup_type type, void *type_data,\n\t\t\t    void *data,\n\t\t\t    void (*cleanup)(struct flow_block_cb *block_cb))\n{\n\tif (!netdev)\n\t\treturn nfp_setup_tc_no_dev(cb_priv, type, data);\n\n\tif (!nfp_fl_is_netdev_to_offload(netdev))\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (type) {\n\tcase TC_SETUP_BLOCK:\n\t\treturn nfp_flower_setup_indr_tc_block(netdev, sch, cb_priv,\n\t\t\t\t\t\t      type_data, data, cleanup);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}