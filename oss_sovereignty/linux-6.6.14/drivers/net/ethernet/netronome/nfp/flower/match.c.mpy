{
  "module_name": "match.c",
  "hash_id": "0a5ddfa11f21c23b91b3e312e29d1bc0ea07736d3a729b6dfdd985020250eadc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/netronome/nfp/flower/match.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <net/pkt_cls.h>\n\n#include \"cmsg.h\"\n#include \"main.h\"\n\nvoid\nnfp_flower_compile_meta(struct nfp_flower_meta_tci *ext,\n\t\t\tstruct nfp_flower_meta_tci *msk, u8 key_type)\n{\n\t \n\text->nfp_flow_key_layer = key_type;\n\text->mask_id = ~0;\n\n\tmsk->nfp_flow_key_layer = key_type;\n\tmsk->mask_id = ~0;\n}\n\nvoid\nnfp_flower_compile_tci(struct nfp_flower_meta_tci *ext,\n\t\t       struct nfp_flower_meta_tci *msk,\n\t\t       struct flow_rule *rule)\n{\n\tu16 msk_tci, key_tci;\n\n\tif (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_VLAN)) {\n\t\tstruct flow_match_vlan match;\n\n\t\tflow_rule_match_vlan(rule, &match);\n\t\t \n\t\tkey_tci = NFP_FLOWER_MASK_VLAN_PRESENT;\n\t\tkey_tci |= FIELD_PREP(NFP_FLOWER_MASK_VLAN_PRIO,\n\t\t\t\t      match.key->vlan_priority) |\n\t\t\t   FIELD_PREP(NFP_FLOWER_MASK_VLAN_VID,\n\t\t\t\t      match.key->vlan_id);\n\n\t\tmsk_tci = NFP_FLOWER_MASK_VLAN_PRESENT;\n\t\tmsk_tci |= FIELD_PREP(NFP_FLOWER_MASK_VLAN_PRIO,\n\t\t\t\t      match.mask->vlan_priority) |\n\t\t\t   FIELD_PREP(NFP_FLOWER_MASK_VLAN_VID,\n\t\t\t\t      match.mask->vlan_id);\n\n\t\text->tci |= cpu_to_be16((key_tci & msk_tci));\n\t\tmsk->tci |= cpu_to_be16(msk_tci);\n\t}\n}\n\nstatic void\nnfp_flower_compile_meta_tci(struct nfp_flower_meta_tci *ext,\n\t\t\t    struct nfp_flower_meta_tci *msk,\n\t\t\t    struct flow_rule *rule, u8 key_type, bool qinq_sup)\n{\n\tmemset(ext, 0, sizeof(struct nfp_flower_meta_tci));\n\tmemset(msk, 0, sizeof(struct nfp_flower_meta_tci));\n\n\tnfp_flower_compile_meta(ext, msk, key_type);\n\n\tif (!qinq_sup)\n\t\tnfp_flower_compile_tci(ext, msk, rule);\n}\n\nvoid\nnfp_flower_compile_ext_meta(struct nfp_flower_ext_meta *frame, u32 key_ext)\n{\n\tframe->nfp_flow_key_layer2 = cpu_to_be32(key_ext);\n}\n\nint\nnfp_flower_compile_port(struct nfp_flower_in_port *frame, u32 cmsg_port,\n\t\t\tbool mask_version, enum nfp_flower_tun_type tun_type,\n\t\t\tstruct netlink_ext_ack *extack)\n{\n\tif (mask_version) {\n\t\tframe->in_port = cpu_to_be32(~0);\n\t\treturn 0;\n\t}\n\n\tif (tun_type) {\n\t\tframe->in_port = cpu_to_be32(NFP_FL_PORT_TYPE_TUN | tun_type);\n\t} else {\n\t\tif (!cmsg_port) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"unsupported offload: invalid ingress interface for match offload\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tframe->in_port = cpu_to_be32(cmsg_port);\n\t}\n\n\treturn 0;\n}\n\nvoid\nnfp_flower_compile_mac(struct nfp_flower_mac_mpls *ext,\n\t\t       struct nfp_flower_mac_mpls *msk,\n\t\t       struct flow_rule *rule)\n{\n\tif (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_ETH_ADDRS)) {\n\t\tstruct flow_match_eth_addrs match;\n\t\tu8 tmp;\n\t\tint i;\n\n\t\tflow_rule_match_eth_addrs(rule, &match);\n\t\t \n\t\tfor (i = 0; i < ETH_ALEN; i++) {\n\t\t\ttmp = match.key->dst[i] & match.mask->dst[i];\n\t\t\text->mac_dst[i] |= tmp & (~msk->mac_dst[i]);\n\t\t\tmsk->mac_dst[i] |= match.mask->dst[i];\n\n\t\t\ttmp = match.key->src[i] & match.mask->src[i];\n\t\t\text->mac_src[i] |= tmp & (~msk->mac_src[i]);\n\t\t\tmsk->mac_src[i] |= match.mask->src[i];\n\t\t}\n\t}\n}\n\nint\nnfp_flower_compile_mpls(struct nfp_flower_mac_mpls *ext,\n\t\t\tstruct nfp_flower_mac_mpls *msk,\n\t\t\tstruct flow_rule *rule,\n\t\t\tstruct netlink_ext_ack *extack)\n{\n\tif (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_MPLS)) {\n\t\tstruct flow_match_mpls match;\n\t\tu32 key_mpls, msk_mpls;\n\n\t\tflow_rule_match_mpls(rule, &match);\n\n\t\t \n\t\tif (match.mask->used_lses != 1) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t   \"unsupported offload: invalid LSE depth for MPLS match offload\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\n\t\tkey_mpls = FIELD_PREP(NFP_FLOWER_MASK_MPLS_LB,\n\t\t\t\t      match.key->ls[0].mpls_label) |\n\t\t\t   FIELD_PREP(NFP_FLOWER_MASK_MPLS_TC,\n\t\t\t\t      match.key->ls[0].mpls_tc) |\n\t\t\t   FIELD_PREP(NFP_FLOWER_MASK_MPLS_BOS,\n\t\t\t\t      match.key->ls[0].mpls_bos) |\n\t\t\t   NFP_FLOWER_MASK_MPLS_Q;\n\n\t\tmsk_mpls = FIELD_PREP(NFP_FLOWER_MASK_MPLS_LB,\n\t\t\t\t      match.mask->ls[0].mpls_label) |\n\t\t\t   FIELD_PREP(NFP_FLOWER_MASK_MPLS_TC,\n\t\t\t\t      match.mask->ls[0].mpls_tc) |\n\t\t\t   FIELD_PREP(NFP_FLOWER_MASK_MPLS_BOS,\n\t\t\t\t      match.mask->ls[0].mpls_bos) |\n\t\t\t   NFP_FLOWER_MASK_MPLS_Q;\n\n\t\text->mpls_lse |= cpu_to_be32((key_mpls & msk_mpls));\n\t\tmsk->mpls_lse |= cpu_to_be32(msk_mpls);\n\t} else if (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_BASIC)) {\n\t\t \n\t\tstruct flow_match_basic match;\n\n\t\tflow_rule_match_basic(rule, &match);\n\t\tif (match.key->n_proto == cpu_to_be16(ETH_P_MPLS_UC) ||\n\t\t    match.key->n_proto == cpu_to_be16(ETH_P_MPLS_MC)) {\n\t\t\text->mpls_lse |= cpu_to_be32(NFP_FLOWER_MASK_MPLS_Q);\n\t\t\tmsk->mpls_lse |= cpu_to_be32(NFP_FLOWER_MASK_MPLS_Q);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int\nnfp_flower_compile_mac_mpls(struct nfp_flower_mac_mpls *ext,\n\t\t\t    struct nfp_flower_mac_mpls *msk,\n\t\t\t    struct flow_rule *rule,\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\tmemset(ext, 0, sizeof(struct nfp_flower_mac_mpls));\n\tmemset(msk, 0, sizeof(struct nfp_flower_mac_mpls));\n\n\tnfp_flower_compile_mac(ext, msk, rule);\n\n\treturn nfp_flower_compile_mpls(ext, msk, rule, extack);\n}\n\nvoid\nnfp_flower_compile_tport(struct nfp_flower_tp_ports *ext,\n\t\t\t struct nfp_flower_tp_ports *msk,\n\t\t\t struct flow_rule *rule)\n{\n\tif (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_PORTS)) {\n\t\tstruct flow_match_ports match;\n\t\t__be16 tmp;\n\n\t\tflow_rule_match_ports(rule, &match);\n\n\t\ttmp = match.key->src & match.mask->src;\n\t\text->port_src |= tmp & (~msk->port_src);\n\t\tmsk->port_src |= match.mask->src;\n\n\t\ttmp = match.key->dst & match.mask->dst;\n\t\text->port_dst |= tmp & (~msk->port_dst);\n\t\tmsk->port_dst |= match.mask->dst;\n\t}\n}\n\nstatic void\nnfp_flower_compile_ip_ext(struct nfp_flower_ip_ext *ext,\n\t\t\t  struct nfp_flower_ip_ext *msk, struct flow_rule *rule)\n{\n\tif (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_BASIC)) {\n\t\tstruct flow_match_basic match;\n\n\t\tflow_rule_match_basic(rule, &match);\n\t\text->proto |= match.key->ip_proto & match.mask->ip_proto;\n\t\tmsk->proto |= match.mask->ip_proto;\n\t}\n\n\tif (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_IP)) {\n\t\tstruct flow_match_ip match;\n\t\tu8 tmp;\n\n\t\tflow_rule_match_ip(rule, &match);\n\n\t\ttmp = match.key->tos & match.mask->tos;\n\t\text->tos |= tmp & (~msk->tos);\n\t\tmsk->tos |= match.mask->tos;\n\n\t\ttmp = match.key->ttl & match.mask->ttl;\n\t\text->ttl |= tmp & (~msk->ttl);\n\t\tmsk->ttl |= match.mask->ttl;\n\t}\n\n\tif (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_TCP)) {\n\t\tu16 tcp_flags, tcp_flags_mask;\n\t\tstruct flow_match_tcp match;\n\n\t\tflow_rule_match_tcp(rule, &match);\n\t\ttcp_flags = be16_to_cpu(match.key->flags);\n\t\ttcp_flags_mask = be16_to_cpu(match.mask->flags);\n\n\t\tif (tcp_flags & TCPHDR_FIN)\n\t\t\text->flags |= NFP_FL_TCP_FLAG_FIN;\n\t\tif (tcp_flags_mask & TCPHDR_FIN)\n\t\t\tmsk->flags |= NFP_FL_TCP_FLAG_FIN;\n\n\t\tif (tcp_flags & TCPHDR_SYN)\n\t\t\text->flags |= NFP_FL_TCP_FLAG_SYN;\n\t\tif (tcp_flags_mask & TCPHDR_SYN)\n\t\t\tmsk->flags |= NFP_FL_TCP_FLAG_SYN;\n\n\t\tif (tcp_flags & TCPHDR_RST)\n\t\t\text->flags |= NFP_FL_TCP_FLAG_RST;\n\t\tif (tcp_flags_mask & TCPHDR_RST)\n\t\t\tmsk->flags |= NFP_FL_TCP_FLAG_RST;\n\n\t\tif (tcp_flags & TCPHDR_PSH)\n\t\t\text->flags |= NFP_FL_TCP_FLAG_PSH;\n\t\tif (tcp_flags_mask & TCPHDR_PSH)\n\t\t\tmsk->flags |= NFP_FL_TCP_FLAG_PSH;\n\n\t\tif (tcp_flags & TCPHDR_URG)\n\t\t\text->flags |= NFP_FL_TCP_FLAG_URG;\n\t\tif (tcp_flags_mask & TCPHDR_URG)\n\t\t\tmsk->flags |= NFP_FL_TCP_FLAG_URG;\n\t}\n\n\tif (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_CONTROL)) {\n\t\tstruct flow_match_control match;\n\n\t\tflow_rule_match_control(rule, &match);\n\t\tif (match.key->flags & FLOW_DIS_IS_FRAGMENT)\n\t\t\text->flags |= NFP_FL_IP_FRAGMENTED;\n\t\tif (match.mask->flags & FLOW_DIS_IS_FRAGMENT)\n\t\t\tmsk->flags |= NFP_FL_IP_FRAGMENTED;\n\t\tif (match.key->flags & FLOW_DIS_FIRST_FRAG)\n\t\t\text->flags |= NFP_FL_IP_FRAG_FIRST;\n\t\tif (match.mask->flags & FLOW_DIS_FIRST_FRAG)\n\t\t\tmsk->flags |= NFP_FL_IP_FRAG_FIRST;\n\t}\n}\n\nstatic void\nnfp_flower_fill_vlan(struct flow_match_vlan *match,\n\t\t     struct nfp_flower_vlan *ext,\n\t\t     struct nfp_flower_vlan *msk, bool outer_vlan)\n{\n\tstruct flow_dissector_key_vlan *mask = match->mask;\n\tstruct flow_dissector_key_vlan *key = match->key;\n\tu16 msk_tci, key_tci;\n\n\tkey_tci = NFP_FLOWER_MASK_VLAN_PRESENT;\n\tkey_tci |= FIELD_PREP(NFP_FLOWER_MASK_VLAN_PRIO,\n\t\t\t      key->vlan_priority) |\n\t\t   FIELD_PREP(NFP_FLOWER_MASK_VLAN_VID,\n\t\t\t      key->vlan_id);\n\tmsk_tci = NFP_FLOWER_MASK_VLAN_PRESENT;\n\tmsk_tci |= FIELD_PREP(NFP_FLOWER_MASK_VLAN_PRIO,\n\t\t\t      mask->vlan_priority) |\n\t\t   FIELD_PREP(NFP_FLOWER_MASK_VLAN_VID,\n\t\t\t      mask->vlan_id);\n\n\tif (outer_vlan) {\n\t\text->outer_tci |= cpu_to_be16((key_tci & msk_tci));\n\t\text->outer_tpid |= key->vlan_tpid & mask->vlan_tpid;\n\t\tmsk->outer_tci |= cpu_to_be16(msk_tci);\n\t\tmsk->outer_tpid |= mask->vlan_tpid;\n\t} else {\n\t\text->inner_tci |= cpu_to_be16((key_tci & msk_tci));\n\t\text->inner_tpid |= key->vlan_tpid & mask->vlan_tpid;\n\t\tmsk->inner_tci |= cpu_to_be16(msk_tci);\n\t\tmsk->inner_tpid |= mask->vlan_tpid;\n\t}\n}\n\nvoid\nnfp_flower_compile_vlan(struct nfp_flower_vlan *ext,\n\t\t\tstruct nfp_flower_vlan *msk,\n\t\t\tstruct flow_rule *rule)\n{\n\tstruct flow_match_vlan match;\n\n\tif (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_VLAN)) {\n\t\tflow_rule_match_vlan(rule, &match);\n\t\tnfp_flower_fill_vlan(&match, ext, msk, true);\n\t}\n\tif (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_CVLAN)) {\n\t\tflow_rule_match_cvlan(rule, &match);\n\t\tnfp_flower_fill_vlan(&match, ext, msk, false);\n\t}\n}\n\nvoid\nnfp_flower_compile_ipv4(struct nfp_flower_ipv4 *ext,\n\t\t\tstruct nfp_flower_ipv4 *msk, struct flow_rule *rule)\n{\n\tif (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_IPV4_ADDRS)) {\n\t\tstruct flow_match_ipv4_addrs match;\n\t\t__be32 tmp;\n\n\t\tflow_rule_match_ipv4_addrs(rule, &match);\n\n\t\ttmp = match.key->src & match.mask->src;\n\t\text->ipv4_src |= tmp & (~msk->ipv4_src);\n\t\tmsk->ipv4_src |= match.mask->src;\n\n\t\ttmp = match.key->dst & match.mask->dst;\n\t\text->ipv4_dst |= tmp & (~msk->ipv4_dst);\n\t\tmsk->ipv4_dst |= match.mask->dst;\n\t}\n\n\tnfp_flower_compile_ip_ext(&ext->ip_ext, &msk->ip_ext, rule);\n}\n\nvoid\nnfp_flower_compile_ipv6(struct nfp_flower_ipv6 *ext,\n\t\t\tstruct nfp_flower_ipv6 *msk, struct flow_rule *rule)\n{\n\tif (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_IPV6_ADDRS)) {\n\t\tstruct flow_match_ipv6_addrs match;\n\t\tu8 tmp;\n\t\tint i;\n\n\t\tflow_rule_match_ipv6_addrs(rule, &match);\n\t\tfor (i = 0; i < sizeof(ext->ipv6_src); i++) {\n\t\t\ttmp = match.key->src.s6_addr[i] &\n\t\t\t      match.mask->src.s6_addr[i];\n\t\t\text->ipv6_src.s6_addr[i] |= tmp &\n\t\t\t\t\t\t    (~msk->ipv6_src.s6_addr[i]);\n\t\t\tmsk->ipv6_src.s6_addr[i] |= match.mask->src.s6_addr[i];\n\n\t\t\ttmp = match.key->dst.s6_addr[i] &\n\t\t\t      match.mask->dst.s6_addr[i];\n\t\t\text->ipv6_dst.s6_addr[i] |= tmp &\n\t\t\t\t\t\t    (~msk->ipv6_dst.s6_addr[i]);\n\t\t\tmsk->ipv6_dst.s6_addr[i] |= match.mask->dst.s6_addr[i];\n\t\t}\n\t}\n\n\tnfp_flower_compile_ip_ext(&ext->ip_ext, &msk->ip_ext, rule);\n}\n\nvoid\nnfp_flower_compile_geneve_opt(u8 *ext, u8 *msk, struct flow_rule *rule)\n{\n\tstruct flow_match_enc_opts match;\n\tint i;\n\n\tif (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_ENC_OPTS)) {\n\t\tflow_rule_match_enc_opts(rule, &match);\n\n\t\tfor (i = 0; i < match.mask->len; i++) {\n\t\t\text[i] |= match.key->data[i] & match.mask->data[i];\n\t\t\tmsk[i] |= match.mask->data[i];\n\t\t}\n\t}\n}\n\nstatic void\nnfp_flower_compile_tun_ipv4_addrs(struct nfp_flower_tun_ipv4 *ext,\n\t\t\t\t  struct nfp_flower_tun_ipv4 *msk,\n\t\t\t\t  struct flow_rule *rule)\n{\n\tif (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_ENC_IPV4_ADDRS)) {\n\t\tstruct flow_match_ipv4_addrs match;\n\n\t\tflow_rule_match_enc_ipv4_addrs(rule, &match);\n\t\text->src |= match.key->src & match.mask->src;\n\t\text->dst |= match.key->dst & match.mask->dst;\n\t\tmsk->src |= match.mask->src;\n\t\tmsk->dst |= match.mask->dst;\n\t}\n}\n\nstatic void\nnfp_flower_compile_tun_ipv6_addrs(struct nfp_flower_tun_ipv6 *ext,\n\t\t\t\t  struct nfp_flower_tun_ipv6 *msk,\n\t\t\t\t  struct flow_rule *rule)\n{\n\tif (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_ENC_IPV6_ADDRS)) {\n\t\tstruct flow_match_ipv6_addrs match;\n\t\tint i;\n\n\t\tflow_rule_match_enc_ipv6_addrs(rule, &match);\n\t\tfor (i = 0; i < sizeof(ext->src); i++) {\n\t\t\text->src.s6_addr[i] |= match.key->src.s6_addr[i] &\n\t\t\t\t\t       match.mask->src.s6_addr[i];\n\t\t\text->dst.s6_addr[i] |= match.key->dst.s6_addr[i] &\n\t\t\t\t\t       match.mask->dst.s6_addr[i];\n\t\t\tmsk->src.s6_addr[i] |= match.mask->src.s6_addr[i];\n\t\t\tmsk->dst.s6_addr[i] |= match.mask->dst.s6_addr[i];\n\t\t}\n\t}\n}\n\nstatic void\nnfp_flower_compile_tun_ip_ext(struct nfp_flower_tun_ip_ext *ext,\n\t\t\t      struct nfp_flower_tun_ip_ext *msk,\n\t\t\t      struct flow_rule *rule)\n{\n\tif (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_ENC_IP)) {\n\t\tstruct flow_match_ip match;\n\n\t\tflow_rule_match_enc_ip(rule, &match);\n\t\text->tos |= match.key->tos & match.mask->tos;\n\t\text->ttl |= match.key->ttl & match.mask->ttl;\n\t\tmsk->tos |= match.mask->tos;\n\t\tmsk->ttl |= match.mask->ttl;\n\t}\n}\n\nstatic void\nnfp_flower_compile_tun_udp_key(__be32 *key, __be32 *key_msk,\n\t\t\t       struct flow_rule *rule)\n{\n\tif (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_ENC_KEYID)) {\n\t\tstruct flow_match_enc_keyid match;\n\t\tu32 vni;\n\n\t\tflow_rule_match_enc_keyid(rule, &match);\n\t\tvni = be32_to_cpu((match.key->keyid & match.mask->keyid)) <<\n\t\t      NFP_FL_TUN_VNI_OFFSET;\n\t\t*key |= cpu_to_be32(vni);\n\t\tvni = be32_to_cpu(match.mask->keyid) << NFP_FL_TUN_VNI_OFFSET;\n\t\t*key_msk |= cpu_to_be32(vni);\n\t}\n}\n\nstatic void\nnfp_flower_compile_tun_gre_key(__be32 *key, __be32 *key_msk, __be16 *flags,\n\t\t\t       __be16 *flags_msk, struct flow_rule *rule)\n{\n\tif (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_ENC_KEYID)) {\n\t\tstruct flow_match_enc_keyid match;\n\n\t\tflow_rule_match_enc_keyid(rule, &match);\n\t\t*key |= match.key->keyid & match.mask->keyid;\n\t\t*key_msk |= match.mask->keyid;\n\n\t\t*flags = cpu_to_be16(NFP_FL_GRE_FLAG_KEY);\n\t\t*flags_msk = cpu_to_be16(NFP_FL_GRE_FLAG_KEY);\n\t}\n}\n\nvoid\nnfp_flower_compile_ipv4_gre_tun(struct nfp_flower_ipv4_gre_tun *ext,\n\t\t\t\tstruct nfp_flower_ipv4_gre_tun *msk,\n\t\t\t\tstruct flow_rule *rule)\n{\n\t \n\text->ethertype = cpu_to_be16(ETH_P_TEB);\n\tmsk->ethertype = cpu_to_be16(~0);\n\n\tnfp_flower_compile_tun_ipv4_addrs(&ext->ipv4, &msk->ipv4, rule);\n\tnfp_flower_compile_tun_ip_ext(&ext->ip_ext, &msk->ip_ext, rule);\n\tnfp_flower_compile_tun_gre_key(&ext->tun_key, &msk->tun_key,\n\t\t\t\t       &ext->tun_flags, &msk->tun_flags, rule);\n}\n\nvoid\nnfp_flower_compile_ipv4_udp_tun(struct nfp_flower_ipv4_udp_tun *ext,\n\t\t\t\tstruct nfp_flower_ipv4_udp_tun *msk,\n\t\t\t\tstruct flow_rule *rule)\n{\n\tnfp_flower_compile_tun_ipv4_addrs(&ext->ipv4, &msk->ipv4, rule);\n\tnfp_flower_compile_tun_ip_ext(&ext->ip_ext, &msk->ip_ext, rule);\n\tnfp_flower_compile_tun_udp_key(&ext->tun_id, &msk->tun_id, rule);\n}\n\nvoid\nnfp_flower_compile_ipv6_udp_tun(struct nfp_flower_ipv6_udp_tun *ext,\n\t\t\t\tstruct nfp_flower_ipv6_udp_tun *msk,\n\t\t\t\tstruct flow_rule *rule)\n{\n\tnfp_flower_compile_tun_ipv6_addrs(&ext->ipv6, &msk->ipv6, rule);\n\tnfp_flower_compile_tun_ip_ext(&ext->ip_ext, &msk->ip_ext, rule);\n\tnfp_flower_compile_tun_udp_key(&ext->tun_id, &msk->tun_id, rule);\n}\n\nvoid\nnfp_flower_compile_ipv6_gre_tun(struct nfp_flower_ipv6_gre_tun *ext,\n\t\t\t\tstruct nfp_flower_ipv6_gre_tun *msk,\n\t\t\t\tstruct flow_rule *rule)\n{\n\t \n\text->ethertype = cpu_to_be16(ETH_P_TEB);\n\tmsk->ethertype = cpu_to_be16(~0);\n\n\tnfp_flower_compile_tun_ipv6_addrs(&ext->ipv6, &msk->ipv6, rule);\n\tnfp_flower_compile_tun_ip_ext(&ext->ip_ext, &msk->ip_ext, rule);\n\tnfp_flower_compile_tun_gre_key(&ext->tun_key, &msk->tun_key,\n\t\t\t\t       &ext->tun_flags, &msk->tun_flags, rule);\n}\n\nint nfp_flower_compile_flow_match(struct nfp_app *app,\n\t\t\t\t  struct flow_rule *rule,\n\t\t\t\t  struct nfp_fl_key_ls *key_ls,\n\t\t\t\t  struct net_device *netdev,\n\t\t\t\t  struct nfp_fl_payload *nfp_flow,\n\t\t\t\t  enum nfp_flower_tun_type tun_type,\n\t\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct nfp_flower_priv *priv = app->priv;\n\tbool qinq_sup;\n\tu32 port_id;\n\tint ext_len;\n\tint err;\n\tu8 *ext;\n\tu8 *msk;\n\n\tport_id = nfp_flower_get_port_id_from_netdev(app, netdev);\n\n\tmemset(nfp_flow->unmasked_data, 0, key_ls->key_size);\n\tmemset(nfp_flow->mask_data, 0, key_ls->key_size);\n\n\text = nfp_flow->unmasked_data;\n\tmsk = nfp_flow->mask_data;\n\n\tqinq_sup = !!(priv->flower_ext_feats & NFP_FL_FEATS_VLAN_QINQ);\n\n\tnfp_flower_compile_meta_tci((struct nfp_flower_meta_tci *)ext,\n\t\t\t\t    (struct nfp_flower_meta_tci *)msk,\n\t\t\t\t    rule, key_ls->key_layer, qinq_sup);\n\text += sizeof(struct nfp_flower_meta_tci);\n\tmsk += sizeof(struct nfp_flower_meta_tci);\n\n\t \n\tif (NFP_FLOWER_LAYER_EXT_META & key_ls->key_layer) {\n\t\tnfp_flower_compile_ext_meta((struct nfp_flower_ext_meta *)ext,\n\t\t\t\t\t    key_ls->key_layer_two);\n\t\tnfp_flower_compile_ext_meta((struct nfp_flower_ext_meta *)msk,\n\t\t\t\t\t    key_ls->key_layer_two);\n\t\text += sizeof(struct nfp_flower_ext_meta);\n\t\tmsk += sizeof(struct nfp_flower_ext_meta);\n\t}\n\n\t \n\terr = nfp_flower_compile_port((struct nfp_flower_in_port *)ext,\n\t\t\t\t      port_id, false, tun_type, extack);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = nfp_flower_compile_port((struct nfp_flower_in_port *)msk,\n\t\t\t\t      port_id, true, tun_type, extack);\n\tif (err)\n\t\treturn err;\n\n\text += sizeof(struct nfp_flower_in_port);\n\tmsk += sizeof(struct nfp_flower_in_port);\n\n\tif (NFP_FLOWER_LAYER_MAC & key_ls->key_layer) {\n\t\terr = nfp_flower_compile_mac_mpls((struct nfp_flower_mac_mpls *)ext,\n\t\t\t\t\t\t  (struct nfp_flower_mac_mpls *)msk,\n\t\t\t\t\t\t  rule, extack);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\text += sizeof(struct nfp_flower_mac_mpls);\n\t\tmsk += sizeof(struct nfp_flower_mac_mpls);\n\t}\n\n\tif (NFP_FLOWER_LAYER_TP & key_ls->key_layer) {\n\t\tnfp_flower_compile_tport((struct nfp_flower_tp_ports *)ext,\n\t\t\t\t\t (struct nfp_flower_tp_ports *)msk,\n\t\t\t\t\t rule);\n\t\text += sizeof(struct nfp_flower_tp_ports);\n\t\tmsk += sizeof(struct nfp_flower_tp_ports);\n\t}\n\n\tif (NFP_FLOWER_LAYER_IPV4 & key_ls->key_layer) {\n\t\tnfp_flower_compile_ipv4((struct nfp_flower_ipv4 *)ext,\n\t\t\t\t\t(struct nfp_flower_ipv4 *)msk,\n\t\t\t\t\trule);\n\t\text += sizeof(struct nfp_flower_ipv4);\n\t\tmsk += sizeof(struct nfp_flower_ipv4);\n\t}\n\n\tif (NFP_FLOWER_LAYER_IPV6 & key_ls->key_layer) {\n\t\tnfp_flower_compile_ipv6((struct nfp_flower_ipv6 *)ext,\n\t\t\t\t\t(struct nfp_flower_ipv6 *)msk,\n\t\t\t\t\trule);\n\t\text += sizeof(struct nfp_flower_ipv6);\n\t\tmsk += sizeof(struct nfp_flower_ipv6);\n\t}\n\n\tif (NFP_FLOWER_LAYER2_QINQ & key_ls->key_layer_two) {\n\t\tnfp_flower_compile_vlan((struct nfp_flower_vlan *)ext,\n\t\t\t\t\t(struct nfp_flower_vlan *)msk,\n\t\t\t\t\trule);\n\t\text += sizeof(struct nfp_flower_vlan);\n\t\tmsk += sizeof(struct nfp_flower_vlan);\n\t}\n\n\tif (key_ls->key_layer_two & NFP_FLOWER_LAYER2_GRE) {\n\t\tif (key_ls->key_layer_two & NFP_FLOWER_LAYER2_TUN_IPV6) {\n\t\t\tstruct nfp_flower_ipv6_gre_tun *gre_match;\n\t\t\tstruct nfp_ipv6_addr_entry *entry;\n\t\t\tstruct in6_addr *dst;\n\n\t\t\tnfp_flower_compile_ipv6_gre_tun((void *)ext,\n\t\t\t\t\t\t\t(void *)msk, rule);\n\t\t\tgre_match = (struct nfp_flower_ipv6_gre_tun *)ext;\n\t\t\tdst = &gre_match->ipv6.dst;\n\t\t\text += sizeof(struct nfp_flower_ipv6_gre_tun);\n\t\t\tmsk += sizeof(struct nfp_flower_ipv6_gre_tun);\n\n\t\t\tentry = nfp_tunnel_add_ipv6_off(app, dst);\n\t\t\tif (!entry)\n\t\t\t\treturn -EOPNOTSUPP;\n\n\t\t\tnfp_flow->nfp_tun_ipv6 = entry;\n\t\t} else {\n\t\t\t__be32 dst;\n\n\t\t\tnfp_flower_compile_ipv4_gre_tun((void *)ext,\n\t\t\t\t\t\t\t(void *)msk, rule);\n\t\t\tdst = ((struct nfp_flower_ipv4_gre_tun *)ext)->ipv4.dst;\n\t\t\text += sizeof(struct nfp_flower_ipv4_gre_tun);\n\t\t\tmsk += sizeof(struct nfp_flower_ipv4_gre_tun);\n\n\t\t\t \n\t\t\tnfp_flow->nfp_tun_ipv4_addr = dst;\n\t\t\tnfp_tunnel_add_ipv4_off(app, dst);\n\t\t}\n\t}\n\n\tif (key_ls->key_layer & NFP_FLOWER_LAYER_VXLAN ||\n\t    key_ls->key_layer_two & NFP_FLOWER_LAYER2_GENEVE) {\n\t\tif (key_ls->key_layer_two & NFP_FLOWER_LAYER2_TUN_IPV6) {\n\t\t\tstruct nfp_flower_ipv6_udp_tun *udp_match;\n\t\t\tstruct nfp_ipv6_addr_entry *entry;\n\t\t\tstruct in6_addr *dst;\n\n\t\t\tnfp_flower_compile_ipv6_udp_tun((void *)ext,\n\t\t\t\t\t\t\t(void *)msk, rule);\n\t\t\tudp_match = (struct nfp_flower_ipv6_udp_tun *)ext;\n\t\t\tdst = &udp_match->ipv6.dst;\n\t\t\text += sizeof(struct nfp_flower_ipv6_udp_tun);\n\t\t\tmsk += sizeof(struct nfp_flower_ipv6_udp_tun);\n\n\t\t\tentry = nfp_tunnel_add_ipv6_off(app, dst);\n\t\t\tif (!entry)\n\t\t\t\treturn -EOPNOTSUPP;\n\n\t\t\tnfp_flow->nfp_tun_ipv6 = entry;\n\t\t} else {\n\t\t\t__be32 dst;\n\n\t\t\tnfp_flower_compile_ipv4_udp_tun((void *)ext,\n\t\t\t\t\t\t\t(void *)msk, rule);\n\t\t\tdst = ((struct nfp_flower_ipv4_udp_tun *)ext)->ipv4.dst;\n\t\t\text += sizeof(struct nfp_flower_ipv4_udp_tun);\n\t\t\tmsk += sizeof(struct nfp_flower_ipv4_udp_tun);\n\n\t\t\t \n\t\t\tnfp_flow->nfp_tun_ipv4_addr = dst;\n\t\t\tnfp_tunnel_add_ipv4_off(app, dst);\n\t\t}\n\n\t\tif (key_ls->key_layer_two & NFP_FLOWER_LAYER2_GENEVE_OP) {\n\t\t\tnfp_flower_compile_geneve_opt(ext, msk, rule);\n\t\t}\n\t}\n\n\t \n\text_len = (u32 *)ext - (u32 *)nfp_flow->unmasked_data;\n\tif (ext_len > NFP_FLOWER_KEY_MAX_LW) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"unsupported offload: flow key too long\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}