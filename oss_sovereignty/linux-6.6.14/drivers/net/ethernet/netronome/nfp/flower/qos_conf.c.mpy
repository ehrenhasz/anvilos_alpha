{
  "module_name": "qos_conf.c",
  "hash_id": "652fc7defb717c18b0047eba7e708e9d3cfff35398294a1a8dce529dae6d4c20",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/netronome/nfp/flower/qos_conf.c",
  "human_readable_source": "\n \n\n#include <linux/hash.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/math64.h>\n#include <linux/vmalloc.h>\n#include <net/pkt_cls.h>\n#include <net/pkt_sched.h>\n\n#include \"cmsg.h\"\n#include \"main.h\"\n#include \"../nfp_port.h\"\n\n#define NFP_FL_QOS_UPDATE\t\tmsecs_to_jiffies(1000)\n#define NFP_FL_QOS_PPS  BIT(15)\n#define NFP_FL_QOS_METER  BIT(10)\n\nstruct nfp_police_cfg_head {\n\t__be32 flags_opts;\n\tunion {\n\t\t__be32 meter_id;\n\t\t__be32 port;\n\t};\n};\n\nenum NFP_FL_QOS_TYPES {\n\tNFP_FL_QOS_TYPE_BPS,\n\tNFP_FL_QOS_TYPE_PPS,\n\tNFP_FL_QOS_TYPE_MAX,\n};\n\n \nstruct nfp_police_config {\n\tstruct nfp_police_cfg_head head;\n\t__be32 bkt_tkn_p;\n\t__be32 bkt_tkn_c;\n\t__be32 pbs;\n\t__be32 cbs;\n\t__be32 pir;\n\t__be32 cir;\n};\n\nstruct nfp_police_stats_reply {\n\tstruct nfp_police_cfg_head head;\n\t__be64 pass_bytes;\n\t__be64 pass_pkts;\n\t__be64 drop_bytes;\n\t__be64 drop_pkts;\n};\n\nint nfp_flower_offload_one_police(struct nfp_app *app, bool ingress,\n\t\t\t\t  bool pps, u32 id, u32 rate, u32 burst)\n{\n\tstruct nfp_police_config *config;\n\tstruct sk_buff *skb;\n\n\tskb = nfp_flower_cmsg_alloc(app, sizeof(struct nfp_police_config),\n\t\t\t\t    NFP_FLOWER_CMSG_TYPE_QOS_MOD, GFP_KERNEL);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tconfig = nfp_flower_cmsg_get_data(skb);\n\tmemset(config, 0, sizeof(struct nfp_police_config));\n\tif (pps)\n\t\tconfig->head.flags_opts |= cpu_to_be32(NFP_FL_QOS_PPS);\n\tif (!ingress)\n\t\tconfig->head.flags_opts |= cpu_to_be32(NFP_FL_QOS_METER);\n\n\tif (ingress)\n\t\tconfig->head.port = cpu_to_be32(id);\n\telse\n\t\tconfig->head.meter_id = cpu_to_be32(id);\n\n\tconfig->bkt_tkn_p = cpu_to_be32(burst);\n\tconfig->bkt_tkn_c = cpu_to_be32(burst);\n\tconfig->pbs = cpu_to_be32(burst);\n\tconfig->cbs = cpu_to_be32(burst);\n\tconfig->pir = cpu_to_be32(rate);\n\tconfig->cir = cpu_to_be32(rate);\n\tnfp_ctrl_tx(app->ctrl, skb);\n\n\treturn 0;\n}\n\nstatic int nfp_policer_validate(const struct flow_action *action,\n\t\t\t\tconst struct flow_action_entry *act,\n\t\t\t\tstruct netlink_ext_ack *extack,\n\t\t\t\tbool ingress)\n{\n\tif (act->police.exceed.act_id != FLOW_ACTION_DROP) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Offload not supported when exceed action is not drop\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (ingress) {\n\t\tif (act->police.notexceed.act_id != FLOW_ACTION_CONTINUE &&\n\t\t    act->police.notexceed.act_id != FLOW_ACTION_ACCEPT) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t   \"Offload not supported when conform action is not continue or ok\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t} else {\n\t\tif (act->police.notexceed.act_id != FLOW_ACTION_PIPE &&\n\t\t    act->police.notexceed.act_id != FLOW_ACTION_ACCEPT) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t   \"Offload not supported when conform action is not pipe or ok\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t}\n\n\tif (act->police.notexceed.act_id == FLOW_ACTION_ACCEPT &&\n\t    !flow_action_is_last_entry(action, act)) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Offload not supported when conform action is ok, but action is not last\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (act->police.peakrate_bytes_ps ||\n\t    act->police.avrate || act->police.overhead) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Offload not supported when peakrate/avrate/overhead is configured\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nnfp_flower_install_rate_limiter(struct nfp_app *app, struct net_device *netdev,\n\t\t\t\tstruct tc_cls_matchall_offload *flow,\n\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct flow_action_entry *paction = &flow->rule->action.entries[0];\n\tu32 action_num = flow->rule->action.num_entries;\n\tstruct nfp_flower_priv *fl_priv = app->priv;\n\tstruct flow_action_entry *action = NULL;\n\tstruct nfp_flower_repr_priv *repr_priv;\n\tu32 netdev_port_id, i;\n\tstruct nfp_repr *repr;\n\tbool pps_support;\n\tu32 bps_num = 0;\n\tu32 pps_num = 0;\n\tu32 burst;\n\tbool pps;\n\tu64 rate;\n\tint err;\n\n\tif (!nfp_netdev_is_nfp_repr(netdev)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"unsupported offload: qos rate limit offload not supported on higher level port\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\trepr = netdev_priv(netdev);\n\trepr_priv = repr->app_priv;\n\tnetdev_port_id = nfp_repr_get_port_id(netdev);\n\tpps_support = !!(fl_priv->flower_ext_feats & NFP_FL_FEATS_QOS_PPS);\n\n\tif (repr_priv->block_shared) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"unsupported offload: qos rate limit offload not supported on shared blocks\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (repr->port->type != NFP_PORT_VF_PORT) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"unsupported offload: qos rate limit offload not supported on non-VF ports\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (pps_support) {\n\t\tif (action_num > 2 || action_num == 0) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t   \"unsupported offload: qos rate limit offload only support action number 1 or 2\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t} else {\n\t\tif (!flow_offload_has_one_action(&flow->rule->action)) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t   \"unsupported offload: qos rate limit offload requires a single action\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t}\n\n\tif (flow->common.prio != 1) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"unsupported offload: qos rate limit offload requires highest priority\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tfor (i = 0 ; i < action_num; i++) {\n\t\taction = paction + i;\n\t\tif (action->id != FLOW_ACTION_POLICE) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t   \"unsupported offload: qos rate limit offload requires police action\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\n\t\terr = nfp_policer_validate(&flow->rule->action, action, extack, true);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (action->police.rate_bytes_ps > 0) {\n\t\t\tif (bps_num++) {\n\t\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t\t   \"unsupported offload: qos rate limit offload only support one BPS action\");\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t\t}\n\t\t}\n\t\tif (action->police.rate_pkt_ps > 0) {\n\t\t\tif (!pps_support) {\n\t\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t\t   \"unsupported offload: FW does not support PPS action\");\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t\t}\n\t\t\tif (pps_num++) {\n\t\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t\t   \"unsupported offload: qos rate limit offload only support one PPS action\");\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 0 ; i < action_num; i++) {\n\t\t \n\t\taction = paction + i;\n\t\tif (action->police.rate_bytes_ps > 0) {\n\t\t\trate = action->police.rate_bytes_ps;\n\t\t\tburst = action->police.burst;\n\t\t} else if (action->police.rate_pkt_ps > 0) {\n\t\t\trate = action->police.rate_pkt_ps;\n\t\t\tburst = action->police.burst_pkt;\n\t\t} else {\n\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t   \"unsupported offload: qos rate limit is not BPS or PPS\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (rate != 0) {\n\t\t\tpps = false;\n\t\t\tif (action->police.rate_pkt_ps > 0)\n\t\t\t\tpps = true;\n\t\t\tnfp_flower_offload_one_police(repr->app, true,\n\t\t\t\t\t\t      pps, netdev_port_id,\n\t\t\t\t\t\t      rate, burst);\n\t\t}\n\t}\n\trepr_priv->qos_table.netdev_port_id = netdev_port_id;\n\tfl_priv->qos_rate_limiters++;\n\tif (fl_priv->qos_rate_limiters == 1)\n\t\tschedule_delayed_work(&fl_priv->qos_stats_work,\n\t\t\t\t      NFP_FL_QOS_UPDATE);\n\n\treturn 0;\n}\n\nstatic int\nnfp_flower_remove_rate_limiter(struct nfp_app *app, struct net_device *netdev,\n\t\t\t       struct tc_cls_matchall_offload *flow,\n\t\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct nfp_flower_priv *fl_priv = app->priv;\n\tstruct nfp_flower_repr_priv *repr_priv;\n\tstruct nfp_police_config *config;\n\tu32 netdev_port_id, i;\n\tstruct nfp_repr *repr;\n\tstruct sk_buff *skb;\n\tbool pps_support;\n\n\tif (!nfp_netdev_is_nfp_repr(netdev)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"unsupported offload: qos rate limit offload not supported on higher level port\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\trepr = netdev_priv(netdev);\n\n\tnetdev_port_id = nfp_repr_get_port_id(netdev);\n\trepr_priv = repr->app_priv;\n\tpps_support = !!(fl_priv->flower_ext_feats & NFP_FL_FEATS_QOS_PPS);\n\n\tif (!repr_priv->qos_table.netdev_port_id) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"unsupported offload: cannot remove qos entry that does not exist\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tmemset(&repr_priv->qos_table, 0, sizeof(struct nfp_fl_qos));\n\tfl_priv->qos_rate_limiters--;\n\tif (!fl_priv->qos_rate_limiters)\n\t\tcancel_delayed_work_sync(&fl_priv->qos_stats_work);\n\tfor (i = 0 ; i < NFP_FL_QOS_TYPE_MAX; i++) {\n\t\tif (i == NFP_FL_QOS_TYPE_PPS && !pps_support)\n\t\t\tbreak;\n\t\t \n\t\tskb = nfp_flower_cmsg_alloc(repr->app, sizeof(struct nfp_police_config),\n\t\t\t\t\t    NFP_FLOWER_CMSG_TYPE_QOS_DEL, GFP_KERNEL);\n\t\tif (!skb)\n\t\t\treturn -ENOMEM;\n\n\t\tconfig = nfp_flower_cmsg_get_data(skb);\n\t\tmemset(config, 0, sizeof(struct nfp_police_config));\n\t\tif (i == NFP_FL_QOS_TYPE_PPS)\n\t\t\tconfig->head.flags_opts = cpu_to_be32(NFP_FL_QOS_PPS);\n\t\tconfig->head.port = cpu_to_be32(netdev_port_id);\n\t\tnfp_ctrl_tx(repr->app->ctrl, skb);\n\t}\n\n\treturn 0;\n}\n\nvoid nfp_flower_stats_rlim_reply(struct nfp_app *app, struct sk_buff *skb)\n{\n\tstruct nfp_flower_priv *fl_priv = app->priv;\n\tstruct nfp_flower_repr_priv *repr_priv;\n\tstruct nfp_police_stats_reply *msg;\n\tstruct nfp_stat_pair *curr_stats;\n\tstruct nfp_stat_pair *prev_stats;\n\tstruct net_device *netdev;\n\tstruct nfp_repr *repr;\n\tu32 netdev_port_id;\n\n\tmsg = nfp_flower_cmsg_get_data(skb);\n\tif (be32_to_cpu(msg->head.flags_opts) & NFP_FL_QOS_METER)\n\t\treturn nfp_act_stats_reply(app, msg);\n\n\tnetdev_port_id = be32_to_cpu(msg->head.port);\n\trcu_read_lock();\n\tnetdev = nfp_app_dev_get(app, netdev_port_id, NULL);\n\tif (!netdev)\n\t\tgoto exit_unlock_rcu;\n\n\trepr = netdev_priv(netdev);\n\trepr_priv = repr->app_priv;\n\tcurr_stats = &repr_priv->qos_table.curr_stats;\n\tprev_stats = &repr_priv->qos_table.prev_stats;\n\n\tspin_lock_bh(&fl_priv->qos_stats_lock);\n\tcurr_stats->pkts = be64_to_cpu(msg->pass_pkts) +\n\t\t\t   be64_to_cpu(msg->drop_pkts);\n\tcurr_stats->bytes = be64_to_cpu(msg->pass_bytes) +\n\t\t\t    be64_to_cpu(msg->drop_bytes);\n\n\tif (!repr_priv->qos_table.last_update) {\n\t\tprev_stats->pkts = curr_stats->pkts;\n\t\tprev_stats->bytes = curr_stats->bytes;\n\t}\n\n\trepr_priv->qos_table.last_update = jiffies;\n\tspin_unlock_bh(&fl_priv->qos_stats_lock);\n\nexit_unlock_rcu:\n\trcu_read_unlock();\n}\n\nstatic void\nnfp_flower_stats_rlim_request(struct nfp_flower_priv *fl_priv,\n\t\t\t      u32 id, bool ingress)\n{\n\tstruct nfp_police_cfg_head *head;\n\tstruct sk_buff *skb;\n\n\tskb = nfp_flower_cmsg_alloc(fl_priv->app,\n\t\t\t\t    sizeof(struct nfp_police_cfg_head),\n\t\t\t\t    NFP_FLOWER_CMSG_TYPE_QOS_STATS,\n\t\t\t\t    GFP_ATOMIC);\n\tif (!skb)\n\t\treturn;\n\thead = nfp_flower_cmsg_get_data(skb);\n\n\tmemset(head, 0, sizeof(struct nfp_police_cfg_head));\n\tif (ingress) {\n\t\thead->port = cpu_to_be32(id);\n\t} else {\n\t\thead->flags_opts = cpu_to_be32(NFP_FL_QOS_METER);\n\t\thead->meter_id = cpu_to_be32(id);\n\t}\n\n\tnfp_ctrl_tx(fl_priv->app->ctrl, skb);\n}\n\nstatic void\nnfp_flower_stats_rlim_request_all(struct nfp_flower_priv *fl_priv)\n{\n\tstruct nfp_reprs *repr_set;\n\tint i;\n\n\trcu_read_lock();\n\trepr_set = rcu_dereference(fl_priv->app->reprs[NFP_REPR_TYPE_VF]);\n\tif (!repr_set)\n\t\tgoto exit_unlock_rcu;\n\n\tfor (i = 0; i < repr_set->num_reprs; i++) {\n\t\tstruct net_device *netdev;\n\n\t\tnetdev = rcu_dereference(repr_set->reprs[i]);\n\t\tif (netdev) {\n\t\t\tstruct nfp_repr *priv = netdev_priv(netdev);\n\t\t\tstruct nfp_flower_repr_priv *repr_priv;\n\t\t\tu32 netdev_port_id;\n\n\t\t\trepr_priv = priv->app_priv;\n\t\t\tnetdev_port_id = repr_priv->qos_table.netdev_port_id;\n\t\t\tif (!netdev_port_id)\n\t\t\t\tcontinue;\n\n\t\t\tnfp_flower_stats_rlim_request(fl_priv,\n\t\t\t\t\t\t      netdev_port_id, true);\n\t\t}\n\t}\n\nexit_unlock_rcu:\n\trcu_read_unlock();\n}\n\nstatic void update_stats_cache(struct work_struct *work)\n{\n\tstruct delayed_work *delayed_work;\n\tstruct nfp_flower_priv *fl_priv;\n\n\tdelayed_work = to_delayed_work(work);\n\tfl_priv = container_of(delayed_work, struct nfp_flower_priv,\n\t\t\t       qos_stats_work);\n\n\tnfp_flower_stats_rlim_request_all(fl_priv);\n\tnfp_flower_stats_meter_request_all(fl_priv);\n\n\tschedule_delayed_work(&fl_priv->qos_stats_work, NFP_FL_QOS_UPDATE);\n}\n\nstatic int\nnfp_flower_stats_rate_limiter(struct nfp_app *app, struct net_device *netdev,\n\t\t\t      struct tc_cls_matchall_offload *flow,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct nfp_flower_priv *fl_priv = app->priv;\n\tstruct nfp_flower_repr_priv *repr_priv;\n\tstruct nfp_stat_pair *curr_stats;\n\tstruct nfp_stat_pair *prev_stats;\n\tu64 diff_bytes, diff_pkts;\n\tstruct nfp_repr *repr;\n\n\tif (!nfp_netdev_is_nfp_repr(netdev)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"unsupported offload: qos rate limit offload not supported on higher level port\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\trepr = netdev_priv(netdev);\n\n\trepr_priv = repr->app_priv;\n\tif (!repr_priv->qos_table.netdev_port_id) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"unsupported offload: cannot find qos entry for stats update\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tspin_lock_bh(&fl_priv->qos_stats_lock);\n\tcurr_stats = &repr_priv->qos_table.curr_stats;\n\tprev_stats = &repr_priv->qos_table.prev_stats;\n\tdiff_pkts = curr_stats->pkts - prev_stats->pkts;\n\tdiff_bytes = curr_stats->bytes - prev_stats->bytes;\n\tprev_stats->pkts = curr_stats->pkts;\n\tprev_stats->bytes = curr_stats->bytes;\n\tspin_unlock_bh(&fl_priv->qos_stats_lock);\n\n\tflow_stats_update(&flow->stats, diff_bytes, diff_pkts, 0,\n\t\t\t  repr_priv->qos_table.last_update,\n\t\t\t  FLOW_ACTION_HW_STATS_DELAYED);\n\treturn 0;\n}\n\nvoid nfp_flower_qos_init(struct nfp_app *app)\n{\n\tstruct nfp_flower_priv *fl_priv = app->priv;\n\n\tspin_lock_init(&fl_priv->qos_stats_lock);\n\tmutex_init(&fl_priv->meter_stats_lock);\n\tnfp_init_meter_table(app);\n\n\tINIT_DELAYED_WORK(&fl_priv->qos_stats_work, &update_stats_cache);\n}\n\nvoid nfp_flower_qos_cleanup(struct nfp_app *app)\n{\n\tstruct nfp_flower_priv *fl_priv = app->priv;\n\n\tcancel_delayed_work_sync(&fl_priv->qos_stats_work);\n}\n\nint nfp_flower_setup_qos_offload(struct nfp_app *app, struct net_device *netdev,\n\t\t\t\t struct tc_cls_matchall_offload *flow)\n{\n\tstruct netlink_ext_ack *extack = flow->common.extack;\n\tstruct nfp_flower_priv *fl_priv = app->priv;\n\tint ret;\n\n\tif (!(fl_priv->flower_ext_feats & NFP_FL_FEATS_VF_RLIM)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"unsupported offload: loaded firmware does not support qos rate limit offload\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tmutex_lock(&fl_priv->nfp_fl_lock);\n\tswitch (flow->command) {\n\tcase TC_CLSMATCHALL_REPLACE:\n\t\tret = nfp_flower_install_rate_limiter(app, netdev, flow, extack);\n\t\tbreak;\n\tcase TC_CLSMATCHALL_DESTROY:\n\t\tret = nfp_flower_remove_rate_limiter(app, netdev, flow, extack);\n\t\tbreak;\n\tcase TC_CLSMATCHALL_STATS:\n\t\tret = nfp_flower_stats_rate_limiter(app, netdev, flow, extack);\n\t\tbreak;\n\tdefault:\n\t\tret = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\tmutex_unlock(&fl_priv->nfp_fl_lock);\n\n\treturn ret;\n}\n\n \n\nstatic const struct rhashtable_params stats_meter_table_params = {\n\t.key_offset\t= offsetof(struct nfp_meter_entry, meter_id),\n\t.head_offset\t= offsetof(struct nfp_meter_entry, ht_node),\n\t.key_len\t= sizeof(u32),\n};\n\nstruct nfp_meter_entry *\nnfp_flower_search_meter_entry(struct nfp_app *app, u32 meter_id)\n{\n\tstruct nfp_flower_priv *priv = app->priv;\n\n\treturn rhashtable_lookup_fast(&priv->meter_table, &meter_id,\n\t\t\t\t      stats_meter_table_params);\n}\n\nstatic struct nfp_meter_entry *\nnfp_flower_add_meter_entry(struct nfp_app *app, u32 meter_id)\n{\n\tstruct nfp_meter_entry *meter_entry = NULL;\n\tstruct nfp_flower_priv *priv = app->priv;\n\n\tmeter_entry = rhashtable_lookup_fast(&priv->meter_table,\n\t\t\t\t\t     &meter_id,\n\t\t\t\t\t     stats_meter_table_params);\n\tif (meter_entry)\n\t\treturn meter_entry;\n\n\tmeter_entry = kzalloc(sizeof(*meter_entry), GFP_KERNEL);\n\tif (!meter_entry)\n\t\treturn NULL;\n\n\tmeter_entry->meter_id = meter_id;\n\tmeter_entry->used = jiffies;\n\tif (rhashtable_insert_fast(&priv->meter_table, &meter_entry->ht_node,\n\t\t\t\t   stats_meter_table_params)) {\n\t\tkfree(meter_entry);\n\t\treturn NULL;\n\t}\n\n\tpriv->qos_rate_limiters++;\n\tif (priv->qos_rate_limiters == 1)\n\t\tschedule_delayed_work(&priv->qos_stats_work,\n\t\t\t\t      NFP_FL_QOS_UPDATE);\n\n\treturn meter_entry;\n}\n\nstatic void nfp_flower_del_meter_entry(struct nfp_app *app, u32 meter_id)\n{\n\tstruct nfp_meter_entry *meter_entry = NULL;\n\tstruct nfp_flower_priv *priv = app->priv;\n\n\tmeter_entry = rhashtable_lookup_fast(&priv->meter_table, &meter_id,\n\t\t\t\t\t     stats_meter_table_params);\n\tif (!meter_entry)\n\t\treturn;\n\n\trhashtable_remove_fast(&priv->meter_table,\n\t\t\t       &meter_entry->ht_node,\n\t\t\t       stats_meter_table_params);\n\tkfree(meter_entry);\n\tpriv->qos_rate_limiters--;\n\tif (!priv->qos_rate_limiters)\n\t\tcancel_delayed_work_sync(&priv->qos_stats_work);\n}\n\nint nfp_flower_setup_meter_entry(struct nfp_app *app,\n\t\t\t\t const struct flow_action_entry *action,\n\t\t\t\t enum nfp_meter_op op,\n\t\t\t\t u32 meter_id)\n{\n\tstruct nfp_flower_priv *fl_priv = app->priv;\n\tstruct nfp_meter_entry *meter_entry = NULL;\n\tint err = 0;\n\n\tmutex_lock(&fl_priv->meter_stats_lock);\n\n\tswitch (op) {\n\tcase NFP_METER_DEL:\n\t\tnfp_flower_del_meter_entry(app, meter_id);\n\t\tgoto exit_unlock;\n\tcase NFP_METER_ADD:\n\t\tmeter_entry = nfp_flower_add_meter_entry(app, meter_id);\n\t\tbreak;\n\tdefault:\n\t\terr = -EOPNOTSUPP;\n\t\tgoto exit_unlock;\n\t}\n\n\tif (!meter_entry) {\n\t\terr = -ENOMEM;\n\t\tgoto exit_unlock;\n\t}\n\n\tif (action->police.rate_bytes_ps > 0) {\n\t\tmeter_entry->bps = true;\n\t\tmeter_entry->rate = action->police.rate_bytes_ps;\n\t\tmeter_entry->burst = action->police.burst;\n\t} else {\n\t\tmeter_entry->bps = false;\n\t\tmeter_entry->rate = action->police.rate_pkt_ps;\n\t\tmeter_entry->burst = action->police.burst_pkt;\n\t}\n\nexit_unlock:\n\tmutex_unlock(&fl_priv->meter_stats_lock);\n\treturn err;\n}\n\nint nfp_init_meter_table(struct nfp_app *app)\n{\n\tstruct nfp_flower_priv *priv = app->priv;\n\n\treturn rhashtable_init(&priv->meter_table, &stats_meter_table_params);\n}\n\nvoid\nnfp_flower_stats_meter_request_all(struct nfp_flower_priv *fl_priv)\n{\n\tstruct nfp_meter_entry *meter_entry = NULL;\n\tstruct rhashtable_iter iter;\n\n\tmutex_lock(&fl_priv->meter_stats_lock);\n\trhashtable_walk_enter(&fl_priv->meter_table, &iter);\n\trhashtable_walk_start(&iter);\n\n\twhile ((meter_entry = rhashtable_walk_next(&iter)) != NULL) {\n\t\tif (IS_ERR(meter_entry))\n\t\t\tcontinue;\n\t\tnfp_flower_stats_rlim_request(fl_priv,\n\t\t\t\t\t      meter_entry->meter_id, false);\n\t}\n\n\trhashtable_walk_stop(&iter);\n\trhashtable_walk_exit(&iter);\n\tmutex_unlock(&fl_priv->meter_stats_lock);\n}\n\nstatic int\nnfp_act_install_actions(struct nfp_app *app, struct flow_offload_action *fl_act,\n\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct flow_action_entry *paction = &fl_act->action.entries[0];\n\tu32 action_num = fl_act->action.num_entries;\n\tstruct nfp_flower_priv *fl_priv = app->priv;\n\tstruct flow_action_entry *action = NULL;\n\tu32 burst, i, meter_id;\n\tbool pps_support, pps;\n\tbool add = false;\n\tu64 rate;\n\tint err;\n\n\tpps_support = !!(fl_priv->flower_ext_feats & NFP_FL_FEATS_QOS_PPS);\n\n\tfor (i = 0 ; i < action_num; i++) {\n\t\t \n\t\taction = paction + i;\n\t\tif (action->id != FLOW_ACTION_POLICE) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t   \"unsupported offload: qos rate limit offload requires police action\");\n\t\t\tcontinue;\n\t\t}\n\n\t\terr = nfp_policer_validate(&fl_act->action, action, extack, false);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (action->police.rate_bytes_ps > 0) {\n\t\t\trate = action->police.rate_bytes_ps;\n\t\t\tburst = action->police.burst;\n\t\t} else if (action->police.rate_pkt_ps > 0 && pps_support) {\n\t\t\trate = action->police.rate_pkt_ps;\n\t\t\tburst = action->police.burst_pkt;\n\t\t} else {\n\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t   \"unsupported offload: unsupported qos rate limit\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (rate != 0) {\n\t\t\tmeter_id = action->hw_index;\n\t\t\tif (nfp_flower_setup_meter_entry(app, action, NFP_METER_ADD, meter_id))\n\t\t\t\tcontinue;\n\n\t\t\tpps = false;\n\t\t\tif (action->police.rate_pkt_ps > 0)\n\t\t\t\tpps = true;\n\t\t\tnfp_flower_offload_one_police(app, false, pps, meter_id,\n\t\t\t\t\t\t      rate, burst);\n\t\t\tadd = true;\n\t\t}\n\t}\n\n\treturn add ? 0 : -EOPNOTSUPP;\n}\n\nstatic int\nnfp_act_remove_actions(struct nfp_app *app, struct flow_offload_action *fl_act,\n\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct nfp_meter_entry *meter_entry = NULL;\n\tstruct nfp_police_config *config;\n\tstruct sk_buff *skb;\n\tu32 meter_id;\n\tbool pps;\n\n\t \n\tif (fl_act->id != FLOW_ACTION_POLICE) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"unsupported offload: qos rate limit offload requires police action\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tmeter_id = fl_act->index;\n\tmeter_entry = nfp_flower_search_meter_entry(app, meter_id);\n\tif (!meter_entry) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"no meter entry when delete the action index.\");\n\t\treturn -ENOENT;\n\t}\n\tpps = !meter_entry->bps;\n\n\tskb = nfp_flower_cmsg_alloc(app, sizeof(struct nfp_police_config),\n\t\t\t\t    NFP_FLOWER_CMSG_TYPE_QOS_DEL, GFP_KERNEL);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tconfig = nfp_flower_cmsg_get_data(skb);\n\tmemset(config, 0, sizeof(struct nfp_police_config));\n\tconfig->head.flags_opts = cpu_to_be32(NFP_FL_QOS_METER);\n\tconfig->head.meter_id = cpu_to_be32(meter_id);\n\tif (pps)\n\t\tconfig->head.flags_opts |= cpu_to_be32(NFP_FL_QOS_PPS);\n\n\tnfp_ctrl_tx(app->ctrl, skb);\n\tnfp_flower_setup_meter_entry(app, NULL, NFP_METER_DEL, meter_id);\n\n\treturn 0;\n}\n\nvoid\nnfp_act_stats_reply(struct nfp_app *app, void *pmsg)\n{\n\tstruct nfp_flower_priv *fl_priv = app->priv;\n\tstruct nfp_meter_entry *meter_entry = NULL;\n\tstruct nfp_police_stats_reply *msg = pmsg;\n\tu32 meter_id;\n\n\tmeter_id = be32_to_cpu(msg->head.meter_id);\n\tmutex_lock(&fl_priv->meter_stats_lock);\n\n\tmeter_entry = nfp_flower_search_meter_entry(app, meter_id);\n\tif (!meter_entry)\n\t\tgoto exit_unlock;\n\n\tmeter_entry->stats.curr.pkts = be64_to_cpu(msg->pass_pkts) +\n\t\t\t\t       be64_to_cpu(msg->drop_pkts);\n\tmeter_entry->stats.curr.bytes = be64_to_cpu(msg->pass_bytes) +\n\t\t\t\t\tbe64_to_cpu(msg->drop_bytes);\n\tmeter_entry->stats.curr.drops = be64_to_cpu(msg->drop_pkts);\n\tif (!meter_entry->stats.update) {\n\t\tmeter_entry->stats.prev.pkts = meter_entry->stats.curr.pkts;\n\t\tmeter_entry->stats.prev.bytes = meter_entry->stats.curr.bytes;\n\t\tmeter_entry->stats.prev.drops = meter_entry->stats.curr.drops;\n\t}\n\n\tmeter_entry->stats.update = jiffies;\n\nexit_unlock:\n\tmutex_unlock(&fl_priv->meter_stats_lock);\n}\n\nstatic int\nnfp_act_stats_actions(struct nfp_app *app, struct flow_offload_action *fl_act,\n\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct nfp_flower_priv *fl_priv = app->priv;\n\tstruct nfp_meter_entry *meter_entry = NULL;\n\tu64 diff_bytes, diff_pkts, diff_drops;\n\tint err = 0;\n\n\tif (fl_act->id != FLOW_ACTION_POLICE) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"unsupported offload: qos rate limit offload requires police action\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tmutex_lock(&fl_priv->meter_stats_lock);\n\tmeter_entry = nfp_flower_search_meter_entry(app, fl_act->index);\n\tif (!meter_entry) {\n\t\terr = -ENOENT;\n\t\tgoto exit_unlock;\n\t}\n\tdiff_pkts = meter_entry->stats.curr.pkts > meter_entry->stats.prev.pkts ?\n\t\t    meter_entry->stats.curr.pkts - meter_entry->stats.prev.pkts : 0;\n\tdiff_bytes = meter_entry->stats.curr.bytes > meter_entry->stats.prev.bytes ?\n\t\t     meter_entry->stats.curr.bytes - meter_entry->stats.prev.bytes : 0;\n\tdiff_drops = meter_entry->stats.curr.drops > meter_entry->stats.prev.drops ?\n\t\t     meter_entry->stats.curr.drops - meter_entry->stats.prev.drops : 0;\n\n\tflow_stats_update(&fl_act->stats, diff_bytes, diff_pkts, diff_drops,\n\t\t\t  meter_entry->stats.update,\n\t\t\t  FLOW_ACTION_HW_STATS_DELAYED);\n\n\tmeter_entry->stats.prev.pkts = meter_entry->stats.curr.pkts;\n\tmeter_entry->stats.prev.bytes = meter_entry->stats.curr.bytes;\n\tmeter_entry->stats.prev.drops = meter_entry->stats.curr.drops;\n\nexit_unlock:\n\tmutex_unlock(&fl_priv->meter_stats_lock);\n\treturn err;\n}\n\nint nfp_setup_tc_act_offload(struct nfp_app *app,\n\t\t\t     struct flow_offload_action *fl_act)\n{\n\tstruct netlink_ext_ack *extack = fl_act->extack;\n\tstruct nfp_flower_priv *fl_priv = app->priv;\n\n\tif (!(fl_priv->flower_ext_feats & NFP_FL_FEATS_QOS_METER))\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (fl_act->command) {\n\tcase FLOW_ACT_REPLACE:\n\t\treturn nfp_act_install_actions(app, fl_act, extack);\n\tcase FLOW_ACT_DESTROY:\n\t\treturn nfp_act_remove_actions(app, fl_act, extack);\n\tcase FLOW_ACT_STATS:\n\t\treturn nfp_act_stats_actions(app, fl_act, extack);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}