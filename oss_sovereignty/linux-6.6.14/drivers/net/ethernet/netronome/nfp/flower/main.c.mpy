{
  "module_name": "main.c",
  "hash_id": "30874810e38a068156b1343f5cb68d4493070b794c719b619c420b026f649895",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/netronome/nfp/flower/main.c",
  "human_readable_source": "\n \n\n#include <linux/etherdevice.h>\n#include <linux/lockdep.h>\n#include <linux/pci.h>\n#include <linux/skbuff.h>\n#include <linux/vmalloc.h>\n#include <net/devlink.h>\n#include <net/dst_metadata.h>\n\n#include \"main.h\"\n#include \"../nfpcore/nfp_cpp.h\"\n#include \"../nfpcore/nfp_nffw.h\"\n#include \"../nfpcore/nfp_nsp.h\"\n#include \"../nfp_app.h\"\n#include \"../nfp_main.h\"\n#include \"../nfp_net.h\"\n#include \"../nfp_net_repr.h\"\n#include \"../nfp_port.h\"\n#include \"./cmsg.h\"\n\n#define NFP_FLOWER_ALLOWED_VER 0x0001000000010000UL\n\n#define NFP_MIN_INT_PORT_ID\t1\n#define NFP_MAX_INT_PORT_ID\t256\n\nstatic const char *nfp_flower_extra_cap(struct nfp_app *app, struct nfp_net *nn)\n{\n\treturn \"FLOWER\";\n}\n\nstatic enum devlink_eswitch_mode eswitch_mode_get(struct nfp_app *app)\n{\n\treturn DEVLINK_ESWITCH_MODE_SWITCHDEV;\n}\n\nstatic int\nnfp_flower_lookup_internal_port_id(struct nfp_flower_priv *priv,\n\t\t\t\t   struct net_device *netdev)\n{\n\tstruct net_device *entry;\n\tint i, id = 0;\n\n\trcu_read_lock();\n\tidr_for_each_entry(&priv->internal_ports.port_ids, entry, i)\n\t\tif (entry == netdev) {\n\t\t\tid = i;\n\t\t\tbreak;\n\t\t}\n\trcu_read_unlock();\n\n\treturn id;\n}\n\nstatic int\nnfp_flower_get_internal_port_id(struct nfp_app *app, struct net_device *netdev)\n{\n\tstruct nfp_flower_priv *priv = app->priv;\n\tint id;\n\n\tid = nfp_flower_lookup_internal_port_id(priv, netdev);\n\tif (id > 0)\n\t\treturn id;\n\n\tidr_preload(GFP_ATOMIC);\n\tspin_lock_bh(&priv->internal_ports.lock);\n\tid = idr_alloc(&priv->internal_ports.port_ids, netdev,\n\t\t       NFP_MIN_INT_PORT_ID, NFP_MAX_INT_PORT_ID, GFP_ATOMIC);\n\tspin_unlock_bh(&priv->internal_ports.lock);\n\tidr_preload_end();\n\n\treturn id;\n}\n\nu32 nfp_flower_get_port_id_from_netdev(struct nfp_app *app,\n\t\t\t\t       struct net_device *netdev)\n{\n\tstruct nfp_flower_priv *priv = app->priv;\n\tint ext_port;\n\tint gid;\n\n\tif (nfp_netdev_is_nfp_repr(netdev)) {\n\t\treturn nfp_repr_get_port_id(netdev);\n\t} else if (nfp_flower_internal_port_can_offload(app, netdev)) {\n\t\text_port = nfp_flower_get_internal_port_id(app, netdev);\n\t\tif (ext_port < 0)\n\t\t\treturn 0;\n\n\t\treturn nfp_flower_internal_port_get_port_id(ext_port);\n\t} else if (netif_is_lag_master(netdev) &&\n\t\t   priv->flower_ext_feats & NFP_FL_FEATS_TUNNEL_NEIGH_LAG) {\n\t\tgid = nfp_flower_lag_get_output_id(app, netdev);\n\t\tif (gid < 0)\n\t\t\treturn 0;\n\n\t\treturn (NFP_FL_LAG_OUT | gid);\n\t}\n\n\treturn 0;\n}\n\nstatic struct net_device *\nnfp_flower_get_netdev_from_internal_port_id(struct nfp_app *app, int port_id)\n{\n\tstruct nfp_flower_priv *priv = app->priv;\n\tstruct net_device *netdev;\n\n\trcu_read_lock();\n\tnetdev = idr_find(&priv->internal_ports.port_ids, port_id);\n\trcu_read_unlock();\n\n\treturn netdev;\n}\n\nstatic void\nnfp_flower_free_internal_port_id(struct nfp_app *app, struct net_device *netdev)\n{\n\tstruct nfp_flower_priv *priv = app->priv;\n\tint id;\n\n\tid = nfp_flower_lookup_internal_port_id(priv, netdev);\n\tif (!id)\n\t\treturn;\n\n\tspin_lock_bh(&priv->internal_ports.lock);\n\tidr_remove(&priv->internal_ports.port_ids, id);\n\tspin_unlock_bh(&priv->internal_ports.lock);\n}\n\nstatic int\nnfp_flower_internal_port_event_handler(struct nfp_app *app,\n\t\t\t\t       struct net_device *netdev,\n\t\t\t\t       unsigned long event)\n{\n\tif (event == NETDEV_UNREGISTER &&\n\t    nfp_flower_internal_port_can_offload(app, netdev))\n\t\tnfp_flower_free_internal_port_id(app, netdev);\n\n\treturn NOTIFY_OK;\n}\n\nstatic void nfp_flower_internal_port_init(struct nfp_flower_priv *priv)\n{\n\tspin_lock_init(&priv->internal_ports.lock);\n\tidr_init(&priv->internal_ports.port_ids);\n}\n\nstatic void nfp_flower_internal_port_cleanup(struct nfp_flower_priv *priv)\n{\n\tidr_destroy(&priv->internal_ports.port_ids);\n}\n\nstatic struct nfp_flower_non_repr_priv *\nnfp_flower_non_repr_priv_lookup(struct nfp_app *app, struct net_device *netdev)\n{\n\tstruct nfp_flower_priv *priv = app->priv;\n\tstruct nfp_flower_non_repr_priv *entry;\n\n\tASSERT_RTNL();\n\n\tlist_for_each_entry(entry, &priv->non_repr_priv, list)\n\t\tif (entry->netdev == netdev)\n\t\t\treturn entry;\n\n\treturn NULL;\n}\n\nvoid\n__nfp_flower_non_repr_priv_get(struct nfp_flower_non_repr_priv *non_repr_priv)\n{\n\tnon_repr_priv->ref_count++;\n}\n\nstruct nfp_flower_non_repr_priv *\nnfp_flower_non_repr_priv_get(struct nfp_app *app, struct net_device *netdev)\n{\n\tstruct nfp_flower_priv *priv = app->priv;\n\tstruct nfp_flower_non_repr_priv *entry;\n\n\tentry = nfp_flower_non_repr_priv_lookup(app, netdev);\n\tif (entry)\n\t\tgoto inc_ref;\n\n\tentry = kzalloc(sizeof(*entry), GFP_KERNEL);\n\tif (!entry)\n\t\treturn NULL;\n\n\tentry->netdev = netdev;\n\tlist_add(&entry->list, &priv->non_repr_priv);\n\ninc_ref:\n\t__nfp_flower_non_repr_priv_get(entry);\n\treturn entry;\n}\n\nvoid\n__nfp_flower_non_repr_priv_put(struct nfp_flower_non_repr_priv *non_repr_priv)\n{\n\tif (--non_repr_priv->ref_count)\n\t\treturn;\n\n\tlist_del(&non_repr_priv->list);\n\tkfree(non_repr_priv);\n}\n\nvoid\nnfp_flower_non_repr_priv_put(struct nfp_app *app, struct net_device *netdev)\n{\n\tstruct nfp_flower_non_repr_priv *entry;\n\n\tentry = nfp_flower_non_repr_priv_lookup(app, netdev);\n\tif (!entry)\n\t\treturn;\n\n\t__nfp_flower_non_repr_priv_put(entry);\n}\n\nstatic enum nfp_repr_type\nnfp_flower_repr_get_type_and_port(struct nfp_app *app, u32 port_id, u8 *port)\n{\n\tswitch (FIELD_GET(NFP_FLOWER_CMSG_PORT_TYPE, port_id)) {\n\tcase NFP_FLOWER_CMSG_PORT_TYPE_PHYS_PORT:\n\t\t*port = FIELD_GET(NFP_FLOWER_CMSG_PORT_PHYS_PORT_NUM,\n\t\t\t\t  port_id);\n\t\treturn NFP_REPR_TYPE_PHYS_PORT;\n\n\tcase NFP_FLOWER_CMSG_PORT_TYPE_PCIE_PORT:\n\t\t*port = FIELD_GET(NFP_FLOWER_CMSG_PORT_VNIC, port_id);\n\t\tif (FIELD_GET(NFP_FLOWER_CMSG_PORT_VNIC_TYPE, port_id) ==\n\t\t    NFP_FLOWER_CMSG_PORT_VNIC_TYPE_PF)\n\t\t\treturn NFP_REPR_TYPE_PF;\n\t\telse\n\t\t\treturn NFP_REPR_TYPE_VF;\n\t}\n\n\treturn __NFP_REPR_TYPE_MAX;\n}\n\nstatic struct net_device *\nnfp_flower_dev_get(struct nfp_app *app, u32 port_id, bool *redir_egress)\n{\n\tenum nfp_repr_type repr_type;\n\tstruct nfp_reprs *reprs;\n\tu8 port = 0;\n\n\t \n\tif (FIELD_GET(NFP_FLOWER_CMSG_PORT_TYPE, port_id) ==\n\t    NFP_FLOWER_CMSG_PORT_TYPE_OTHER_PORT) {\n\t\tif (redir_egress)\n\t\t\t*redir_egress = true;\n\t\tport = FIELD_GET(NFP_FLOWER_CMSG_PORT_PHYS_PORT_NUM, port_id);\n\t\treturn nfp_flower_get_netdev_from_internal_port_id(app, port);\n\t}\n\n\trepr_type = nfp_flower_repr_get_type_and_port(app, port_id, &port);\n\tif (repr_type > NFP_REPR_TYPE_MAX)\n\t\treturn NULL;\n\n\treprs = rcu_dereference(app->reprs[repr_type]);\n\tif (!reprs)\n\t\treturn NULL;\n\n\tif (port >= reprs->num_reprs)\n\t\treturn NULL;\n\n\treturn rcu_dereference(reprs->reprs[port]);\n}\n\nstatic int\nnfp_flower_reprs_reify(struct nfp_app *app, enum nfp_repr_type type,\n\t\t       bool exists)\n{\n\tstruct nfp_reprs *reprs;\n\tint i, err, count = 0;\n\n\treprs = rcu_dereference_protected(app->reprs[type],\n\t\t\t\t\t  nfp_app_is_locked(app));\n\tif (!reprs)\n\t\treturn 0;\n\n\tfor (i = 0; i < reprs->num_reprs; i++) {\n\t\tstruct net_device *netdev;\n\n\t\tnetdev = nfp_repr_get_locked(app, reprs, i);\n\t\tif (netdev) {\n\t\t\tstruct nfp_repr *repr = netdev_priv(netdev);\n\n\t\t\terr = nfp_flower_cmsg_portreify(repr, exists);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tcount++;\n\t\t}\n\t}\n\n\treturn count;\n}\n\nstatic int\nnfp_flower_wait_repr_reify(struct nfp_app *app, atomic_t *replies, int tot_repl)\n{\n\tstruct nfp_flower_priv *priv = app->priv;\n\n\tif (!tot_repl)\n\t\treturn 0;\n\n\tassert_nfp_app_locked(app);\n\tif (!wait_event_timeout(priv->reify_wait_queue,\n\t\t\t\tatomic_read(replies) >= tot_repl,\n\t\t\t\tNFP_FL_REPLY_TIMEOUT)) {\n\t\tnfp_warn(app->cpp, \"Not all reprs responded to reify\\n\");\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nnfp_flower_repr_netdev_open(struct nfp_app *app, struct nfp_repr *repr)\n{\n\tint err;\n\n\terr = nfp_flower_cmsg_portmod(repr, true, repr->netdev->mtu, false);\n\tif (err)\n\t\treturn err;\n\n\tnetif_tx_wake_all_queues(repr->netdev);\n\n\treturn 0;\n}\n\nstatic int\nnfp_flower_repr_netdev_stop(struct nfp_app *app, struct nfp_repr *repr)\n{\n\tnetif_tx_disable(repr->netdev);\n\n\treturn nfp_flower_cmsg_portmod(repr, false, repr->netdev->mtu, false);\n}\n\nstatic void\nnfp_flower_repr_netdev_clean(struct nfp_app *app, struct net_device *netdev)\n{\n\tstruct nfp_repr *repr = netdev_priv(netdev);\n\n\tkfree(repr->app_priv);\n}\n\nstatic void\nnfp_flower_repr_netdev_preclean(struct nfp_app *app, struct net_device *netdev)\n{\n\tstruct nfp_repr *repr = netdev_priv(netdev);\n\tstruct nfp_flower_priv *priv = app->priv;\n\tatomic_t *replies = &priv->reify_replies;\n\tint err;\n\n\tatomic_set(replies, 0);\n\terr = nfp_flower_cmsg_portreify(repr, false);\n\tif (err) {\n\t\tnfp_warn(app->cpp, \"Failed to notify firmware about repr destruction\\n\");\n\t\treturn;\n\t}\n\n\tnfp_flower_wait_repr_reify(app, replies, 1);\n}\n\nstatic void nfp_flower_sriov_disable(struct nfp_app *app)\n{\n\tstruct nfp_flower_priv *priv = app->priv;\n\n\tif (!priv->nn)\n\t\treturn;\n\n\tnfp_reprs_clean_and_free_by_type(app, NFP_REPR_TYPE_VF);\n}\n\nstatic int\nnfp_flower_spawn_vnic_reprs(struct nfp_app *app,\n\t\t\t    enum nfp_flower_cmsg_port_vnic_type vnic_type,\n\t\t\t    enum nfp_repr_type repr_type, unsigned int cnt)\n{\n\tu8 nfp_pcie = nfp_cppcore_pcie_unit(app->pf->cpp);\n\tstruct nfp_flower_priv *priv = app->priv;\n\tatomic_t *replies = &priv->reify_replies;\n\tstruct nfp_flower_repr_priv *repr_priv;\n\tenum nfp_port_type port_type;\n\tstruct nfp_repr *nfp_repr;\n\tstruct nfp_reprs *reprs;\n\tint i, err, reify_cnt;\n\tconst u8 queue = 0;\n\n\tport_type = repr_type == NFP_REPR_TYPE_PF ? NFP_PORT_PF_PORT :\n\t\t\t\t\t\t    NFP_PORT_VF_PORT;\n\n\treprs = nfp_reprs_alloc(cnt);\n\tif (!reprs)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < cnt; i++) {\n\t\tstruct net_device *repr;\n\t\tstruct nfp_port *port;\n\t\tu32 port_id;\n\n\t\trepr = nfp_repr_alloc(app);\n\t\tif (!repr) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_reprs_clean;\n\t\t}\n\n\t\trepr_priv = kzalloc(sizeof(*repr_priv), GFP_KERNEL);\n\t\tif (!repr_priv) {\n\t\t\terr = -ENOMEM;\n\t\t\tnfp_repr_free(repr);\n\t\t\tgoto err_reprs_clean;\n\t\t}\n\n\t\tnfp_repr = netdev_priv(repr);\n\t\tnfp_repr->app_priv = repr_priv;\n\t\trepr_priv->nfp_repr = nfp_repr;\n\n\t\t \n\t\tWARN_ON(repr_type == NFP_REPR_TYPE_PF && i);\n\n\t\tport = nfp_port_alloc(app, port_type, repr);\n\t\tif (IS_ERR(port)) {\n\t\t\terr = PTR_ERR(port);\n\t\t\tkfree(repr_priv);\n\t\t\tnfp_repr_free(repr);\n\t\t\tgoto err_reprs_clean;\n\t\t}\n\t\tif (repr_type == NFP_REPR_TYPE_PF) {\n\t\t\tport->pf_id = i;\n\t\t\tport->vnic = priv->nn->dp.ctrl_bar;\n\t\t} else {\n\t\t\tport->pf_id = 0;\n\t\t\tport->vf_id = i;\n\t\t\tport->vnic =\n\t\t\t\tapp->pf->vf_cfg_mem + i * NFP_NET_CFG_BAR_SZ;\n\t\t}\n\n\t\teth_hw_addr_random(repr);\n\n\t\tport_id = nfp_flower_cmsg_pcie_port(nfp_pcie, vnic_type,\n\t\t\t\t\t\t    i, queue);\n\t\terr = nfp_repr_init(app, repr,\n\t\t\t\t    port_id, port, priv->nn->dp.netdev);\n\t\tif (err) {\n\t\t\tkfree(repr_priv);\n\t\t\tnfp_port_free(port);\n\t\t\tnfp_repr_free(repr);\n\t\t\tgoto err_reprs_clean;\n\t\t}\n\n\t\tRCU_INIT_POINTER(reprs->reprs[i], repr);\n\t\tnfp_info(app->cpp, \"%s%d Representor(%s) created\\n\",\n\t\t\t repr_type == NFP_REPR_TYPE_PF ? \"PF\" : \"VF\", i,\n\t\t\t repr->name);\n\t}\n\n\tnfp_app_reprs_set(app, repr_type, reprs);\n\n\tatomic_set(replies, 0);\n\treify_cnt = nfp_flower_reprs_reify(app, repr_type, true);\n\tif (reify_cnt < 0) {\n\t\terr = reify_cnt;\n\t\tnfp_warn(app->cpp, \"Failed to notify firmware about repr creation\\n\");\n\t\tgoto err_reprs_remove;\n\t}\n\n\terr = nfp_flower_wait_repr_reify(app, replies, reify_cnt);\n\tif (err)\n\t\tgoto err_reprs_remove;\n\n\treturn 0;\nerr_reprs_remove:\n\treprs = nfp_app_reprs_set(app, repr_type, NULL);\nerr_reprs_clean:\n\tnfp_reprs_clean_and_free(app, reprs);\n\treturn err;\n}\n\nstatic int nfp_flower_sriov_enable(struct nfp_app *app, int num_vfs)\n{\n\tstruct nfp_flower_priv *priv = app->priv;\n\n\tif (!priv->nn)\n\t\treturn 0;\n\n\treturn nfp_flower_spawn_vnic_reprs(app,\n\t\t\t\t\t   NFP_FLOWER_CMSG_PORT_VNIC_TYPE_VF,\n\t\t\t\t\t   NFP_REPR_TYPE_VF, num_vfs);\n}\n\nstatic int\nnfp_flower_spawn_phy_reprs(struct nfp_app *app, struct nfp_flower_priv *priv)\n{\n\tstruct nfp_eth_table *eth_tbl = app->pf->eth_tbl;\n\tatomic_t *replies = &priv->reify_replies;\n\tstruct nfp_flower_repr_priv *repr_priv;\n\tstruct nfp_repr *nfp_repr;\n\tstruct sk_buff *ctrl_skb;\n\tstruct nfp_reprs *reprs;\n\tint err, reify_cnt;\n\tunsigned int i;\n\n\tctrl_skb = nfp_flower_cmsg_mac_repr_start(app, eth_tbl->count);\n\tif (!ctrl_skb)\n\t\treturn -ENOMEM;\n\n\treprs = nfp_reprs_alloc(eth_tbl->max_index + 1);\n\tif (!reprs) {\n\t\terr = -ENOMEM;\n\t\tgoto err_free_ctrl_skb;\n\t}\n\n\tfor (i = 0; i < eth_tbl->count; i++) {\n\t\tunsigned int phys_port = eth_tbl->ports[i].index;\n\t\tstruct net_device *repr;\n\t\tstruct nfp_port *port;\n\t\tu32 cmsg_port_id;\n\n\t\trepr = nfp_repr_alloc(app);\n\t\tif (!repr) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_reprs_clean;\n\t\t}\n\n\t\trepr_priv = kzalloc(sizeof(*repr_priv), GFP_KERNEL);\n\t\tif (!repr_priv) {\n\t\t\terr = -ENOMEM;\n\t\t\tnfp_repr_free(repr);\n\t\t\tgoto err_reprs_clean;\n\t\t}\n\n\t\tnfp_repr = netdev_priv(repr);\n\t\tnfp_repr->app_priv = repr_priv;\n\t\trepr_priv->nfp_repr = nfp_repr;\n\n\t\tport = nfp_port_alloc(app, NFP_PORT_PHYS_PORT, repr);\n\t\tif (IS_ERR(port)) {\n\t\t\terr = PTR_ERR(port);\n\t\t\tkfree(repr_priv);\n\t\t\tnfp_repr_free(repr);\n\t\t\tgoto err_reprs_clean;\n\t\t}\n\t\terr = nfp_port_init_phy_port(app->pf, app, port, i);\n\t\tif (err) {\n\t\t\tkfree(repr_priv);\n\t\t\tnfp_port_free(port);\n\t\t\tnfp_repr_free(repr);\n\t\t\tgoto err_reprs_clean;\n\t\t}\n\n\t\tSET_NETDEV_DEV(repr, &priv->nn->pdev->dev);\n\t\tnfp_net_get_mac_addr(app->pf, repr, port);\n\n\t\tcmsg_port_id = nfp_flower_cmsg_phys_port(phys_port);\n\t\terr = nfp_repr_init(app, repr,\n\t\t\t\t    cmsg_port_id, port, priv->nn->dp.netdev);\n\t\tif (err) {\n\t\t\tkfree(repr_priv);\n\t\t\tnfp_port_free(port);\n\t\t\tnfp_repr_free(repr);\n\t\t\tgoto err_reprs_clean;\n\t\t}\n\n\t\tnfp_flower_cmsg_mac_repr_add(ctrl_skb, i,\n\t\t\t\t\t     eth_tbl->ports[i].nbi,\n\t\t\t\t\t     eth_tbl->ports[i].base,\n\t\t\t\t\t     phys_port);\n\n\t\tRCU_INIT_POINTER(reprs->reprs[phys_port], repr);\n\t\tnfp_info(app->cpp, \"Phys Port %d Representor(%s) created\\n\",\n\t\t\t phys_port, repr->name);\n\t}\n\n\tnfp_app_reprs_set(app, NFP_REPR_TYPE_PHYS_PORT, reprs);\n\n\t \n\tatomic_set(replies, 0);\n\treify_cnt = nfp_flower_reprs_reify(app, NFP_REPR_TYPE_PHYS_PORT, true);\n\tif (reify_cnt < 0) {\n\t\terr = reify_cnt;\n\t\tnfp_warn(app->cpp, \"Failed to notify firmware about repr creation\\n\");\n\t\tgoto err_reprs_remove;\n\t}\n\n\terr = nfp_flower_wait_repr_reify(app, replies, reify_cnt);\n\tif (err)\n\t\tgoto err_reprs_remove;\n\n\tnfp_ctrl_tx(app->ctrl, ctrl_skb);\n\n\treturn 0;\nerr_reprs_remove:\n\treprs = nfp_app_reprs_set(app, NFP_REPR_TYPE_PHYS_PORT, NULL);\nerr_reprs_clean:\n\tnfp_reprs_clean_and_free(app, reprs);\nerr_free_ctrl_skb:\n\tkfree_skb(ctrl_skb);\n\treturn err;\n}\n\nstatic int nfp_flower_vnic_alloc(struct nfp_app *app, struct nfp_net *nn,\n\t\t\t\t unsigned int id)\n{\n\tif (id > 0) {\n\t\tnfp_warn(app->cpp, \"FlowerNIC doesn't support more than one data vNIC\\n\");\n\t\tgoto err_invalid_port;\n\t}\n\n\teth_hw_addr_random(nn->dp.netdev);\n\tnetif_keep_dst(nn->dp.netdev);\n\tnn->vnic_no_name = true;\n\n\treturn 0;\n\nerr_invalid_port:\n\tnn->port = nfp_port_alloc(app, NFP_PORT_INVALID, nn->dp.netdev);\n\treturn PTR_ERR_OR_ZERO(nn->port);\n}\n\nstatic void nfp_flower_vnic_clean(struct nfp_app *app, struct nfp_net *nn)\n{\n\tstruct nfp_flower_priv *priv = app->priv;\n\n\tif (app->pf->num_vfs)\n\t\tnfp_reprs_clean_and_free_by_type(app, NFP_REPR_TYPE_VF);\n\tnfp_reprs_clean_and_free_by_type(app, NFP_REPR_TYPE_PF);\n\tnfp_reprs_clean_and_free_by_type(app, NFP_REPR_TYPE_PHYS_PORT);\n\n\tpriv->nn = NULL;\n}\n\nstatic int nfp_flower_vnic_init(struct nfp_app *app, struct nfp_net *nn)\n{\n\tstruct nfp_flower_priv *priv = app->priv;\n\tint err;\n\n\tpriv->nn = nn;\n\n\terr = nfp_flower_spawn_phy_reprs(app, app->priv);\n\tif (err)\n\t\tgoto err_clear_nn;\n\n\terr = nfp_flower_spawn_vnic_reprs(app,\n\t\t\t\t\t  NFP_FLOWER_CMSG_PORT_VNIC_TYPE_PF,\n\t\t\t\t\t  NFP_REPR_TYPE_PF, 1);\n\tif (err)\n\t\tgoto err_destroy_reprs_phy;\n\n\tif (app->pf->num_vfs) {\n\t\terr = nfp_flower_spawn_vnic_reprs(app,\n\t\t\t\t\t\t  NFP_FLOWER_CMSG_PORT_VNIC_TYPE_VF,\n\t\t\t\t\t\t  NFP_REPR_TYPE_VF,\n\t\t\t\t\t\t  app->pf->num_vfs);\n\t\tif (err)\n\t\t\tgoto err_destroy_reprs_pf;\n\t}\n\n\treturn 0;\n\nerr_destroy_reprs_pf:\n\tnfp_reprs_clean_and_free_by_type(app, NFP_REPR_TYPE_PF);\nerr_destroy_reprs_phy:\n\tnfp_reprs_clean_and_free_by_type(app, NFP_REPR_TYPE_PHYS_PORT);\nerr_clear_nn:\n\tpriv->nn = NULL;\n\treturn err;\n}\n\nstatic void nfp_flower_wait_host_bit(struct nfp_app *app)\n{\n\tunsigned long err_at;\n\tu64 feat;\n\tint err;\n\n\t \n\terr_at = jiffies + msecs_to_jiffies(100);\n\tdo {\n\t\tfeat = nfp_rtsym_read_le(app->pf->rtbl,\n\t\t\t\t\t \"_abi_flower_combined_features_global\",\n\t\t\t\t\t &err);\n\t\tif (time_is_before_eq_jiffies(err_at)) {\n\t\t\tnfp_warn(app->cpp,\n\t\t\t\t \"HOST_ACK bit not propagated in FW.\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tusleep_range(1000, 2000);\n\t} while (!err && !(feat & NFP_FL_FEATS_HOST_ACK));\n\n\tif (err)\n\t\tnfp_warn(app->cpp,\n\t\t\t \"Could not read global features entry from FW\\n\");\n}\n\nstatic int nfp_flower_sync_feature_bits(struct nfp_app *app)\n{\n\tstruct nfp_flower_priv *app_priv = app->priv;\n\tint err;\n\n\t \n\terr = nfp_rtsym_write_le(app->pf->rtbl, \"_abi_flower_host_mask\",\n\t\t\t\t app_priv->flower_ext_feats |\n\t\t\t\t NFP_FL_FEATS_HOST_ACK);\n\tif (!err)\n\t\tnfp_flower_wait_host_bit(app);\n\telse if (err != -ENOENT)\n\t\treturn err;\n\n\t \n\terr = nfp_rtsym_write_le(app->pf->rtbl,\n\t\t\t\t \"_abi_flower_balance_sync_enable\", 1);\n\tif (!err) {\n\t\tapp_priv->flower_en_feats |= NFP_FL_ENABLE_LAG;\n\t\tnfp_flower_lag_init(&app_priv->nfp_lag);\n\t} else if (err == -ENOENT) {\n\t\tnfp_warn(app->cpp, \"LAG not supported by FW.\\n\");\n\t} else {\n\t\treturn err;\n\t}\n\n\tif (app_priv->flower_ext_feats & NFP_FL_FEATS_FLOW_MOD) {\n\t\t \n\t\terr = nfp_rtsym_write_le(app->pf->rtbl,\n\t\t\t\t\t \"_abi_flower_merge_hint_enable\", 1);\n\t\tif (!err) {\n\t\t\tapp_priv->flower_en_feats |= NFP_FL_ENABLE_FLOW_MERGE;\n\t\t\tnfp_flower_internal_port_init(app_priv);\n\t\t} else if (err == -ENOENT) {\n\t\t\tnfp_warn(app->cpp,\n\t\t\t\t \"Flow merge not supported by FW.\\n\");\n\t\t} else {\n\t\t\treturn err;\n\t\t}\n\t} else {\n\t\tnfp_warn(app->cpp, \"Flow mod/merge not supported by FW.\\n\");\n\t}\n\n\treturn 0;\n}\n\nstatic int nfp_flower_init(struct nfp_app *app)\n{\n\tu64 version, features, ctx_count, num_mems;\n\tconst struct nfp_pf *pf = app->pf;\n\tstruct nfp_flower_priv *app_priv;\n\tint err;\n\n\tif (!pf->eth_tbl) {\n\t\tnfp_warn(app->cpp, \"FlowerNIC requires eth table\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!pf->mac_stats_bar) {\n\t\tnfp_warn(app->cpp, \"FlowerNIC requires mac_stats BAR\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!pf->vf_cfg_bar) {\n\t\tnfp_warn(app->cpp, \"FlowerNIC requires vf_cfg BAR\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tversion = nfp_rtsym_read_le(app->pf->rtbl, \"hw_flower_version\", &err);\n\tif (err) {\n\t\tnfp_warn(app->cpp, \"FlowerNIC requires hw_flower_version memory symbol\\n\");\n\t\treturn err;\n\t}\n\n\tnum_mems = nfp_rtsym_read_le(app->pf->rtbl, \"CONFIG_FC_HOST_CTX_SPLIT\",\n\t\t\t\t     &err);\n\tif (err) {\n\t\tnfp_warn(app->cpp,\n\t\t\t \"FlowerNIC: unsupported host context memory: %d\\n\",\n\t\t\t err);\n\t\terr = 0;\n\t\tnum_mems = 1;\n\t}\n\n\tif (!FIELD_FIT(NFP_FL_STAT_ID_MU_NUM, num_mems) || !num_mems) {\n\t\tnfp_warn(app->cpp,\n\t\t\t \"FlowerNIC: invalid host context memory: %llu\\n\",\n\t\t\t num_mems);\n\t\treturn -EINVAL;\n\t}\n\n\tctx_count = nfp_rtsym_read_le(app->pf->rtbl, \"CONFIG_FC_HOST_CTX_COUNT\",\n\t\t\t\t      &err);\n\tif (err) {\n\t\tnfp_warn(app->cpp,\n\t\t\t \"FlowerNIC: unsupported host context count: %d\\n\",\n\t\t\t err);\n\t\terr = 0;\n\t\tctx_count = BIT(17);\n\t}\n\n\t \n\tif (version != NFP_FLOWER_ALLOWED_VER) {\n\t\tnfp_warn(app->cpp, \"FlowerNIC: unsupported firmware version\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tapp_priv = vzalloc(sizeof(struct nfp_flower_priv));\n\tif (!app_priv)\n\t\treturn -ENOMEM;\n\n\tapp_priv->total_mem_units = num_mems;\n\tapp_priv->active_mem_unit = 0;\n\tapp_priv->stats_ring_size = roundup_pow_of_two(ctx_count);\n\tapp->priv = app_priv;\n\tapp_priv->app = app;\n\tskb_queue_head_init(&app_priv->cmsg_skbs_high);\n\tskb_queue_head_init(&app_priv->cmsg_skbs_low);\n\tINIT_WORK(&app_priv->cmsg_work, nfp_flower_cmsg_process_rx);\n\tinit_waitqueue_head(&app_priv->reify_wait_queue);\n\n\tinit_waitqueue_head(&app_priv->mtu_conf.wait_q);\n\tspin_lock_init(&app_priv->mtu_conf.lock);\n\n\terr = nfp_flower_metadata_init(app, ctx_count, num_mems);\n\tif (err)\n\t\tgoto err_free_app_priv;\n\n\t \n\tfeatures = nfp_rtsym_read_le(app->pf->rtbl,\n\t\t\t\t     \"_abi_flower_extra_features\", &err);\n\tif (err)\n\t\tapp_priv->flower_ext_feats = 0;\n\telse\n\t\tapp_priv->flower_ext_feats = features & NFP_FL_FEATS_HOST;\n\n\terr = nfp_flower_sync_feature_bits(app);\n\tif (err)\n\t\tgoto err_cleanup;\n\n\tif (app_priv->flower_ext_feats & NFP_FL_FEATS_VF_RLIM)\n\t\tnfp_flower_qos_init(app);\n\n\tINIT_LIST_HEAD(&app_priv->indr_block_cb_priv);\n\tINIT_LIST_HEAD(&app_priv->non_repr_priv);\n\tapp_priv->pre_tun_rule_cnt = 0;\n\n\treturn 0;\n\nerr_cleanup:\n\tif (app_priv->flower_en_feats & NFP_FL_ENABLE_LAG)\n\t\tnfp_flower_lag_cleanup(&app_priv->nfp_lag);\n\tnfp_flower_metadata_cleanup(app);\nerr_free_app_priv:\n\tvfree(app->priv);\n\treturn err;\n}\n\nstatic void nfp_flower_clean(struct nfp_app *app)\n{\n\tstruct nfp_flower_priv *app_priv = app->priv;\n\n\tskb_queue_purge(&app_priv->cmsg_skbs_high);\n\tskb_queue_purge(&app_priv->cmsg_skbs_low);\n\tflush_work(&app_priv->cmsg_work);\n\n\tif (app_priv->flower_ext_feats & NFP_FL_FEATS_VF_RLIM)\n\t\tnfp_flower_qos_cleanup(app);\n\n\tif (app_priv->flower_en_feats & NFP_FL_ENABLE_LAG)\n\t\tnfp_flower_lag_cleanup(&app_priv->nfp_lag);\n\n\tif (app_priv->flower_en_feats & NFP_FL_ENABLE_FLOW_MERGE)\n\t\tnfp_flower_internal_port_cleanup(app_priv);\n\n\tnfp_flower_metadata_cleanup(app);\n\tvfree(app->priv);\n\tapp->priv = NULL;\n}\n\nstatic bool nfp_flower_check_ack(struct nfp_flower_priv *app_priv)\n{\n\tbool ret;\n\n\tspin_lock_bh(&app_priv->mtu_conf.lock);\n\tret = app_priv->mtu_conf.ack;\n\tspin_unlock_bh(&app_priv->mtu_conf.lock);\n\n\treturn ret;\n}\n\nstatic int\nnfp_flower_repr_change_mtu(struct nfp_app *app, struct net_device *netdev,\n\t\t\t   int new_mtu)\n{\n\tstruct nfp_flower_priv *app_priv = app->priv;\n\tstruct nfp_repr *repr = netdev_priv(netdev);\n\tint err;\n\n\t \n\tif (repr->port->type != NFP_PORT_PHYS_PORT)\n\t\treturn 0;\n\n\tif (!(app_priv->flower_ext_feats & NFP_FL_NBI_MTU_SETTING)) {\n\t\tnfp_err(app->cpp, \"Physical port MTU setting not supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tspin_lock_bh(&app_priv->mtu_conf.lock);\n\tapp_priv->mtu_conf.ack = false;\n\tapp_priv->mtu_conf.requested_val = new_mtu;\n\tapp_priv->mtu_conf.portnum = repr->dst->u.port_info.port_id;\n\tspin_unlock_bh(&app_priv->mtu_conf.lock);\n\n\terr = nfp_flower_cmsg_portmod(repr, netif_carrier_ok(netdev), new_mtu,\n\t\t\t\t      true);\n\tif (err) {\n\t\tspin_lock_bh(&app_priv->mtu_conf.lock);\n\t\tapp_priv->mtu_conf.requested_val = 0;\n\t\tspin_unlock_bh(&app_priv->mtu_conf.lock);\n\t\treturn err;\n\t}\n\n\t \n\tif (!wait_event_timeout(app_priv->mtu_conf.wait_q,\n\t\t\t\tnfp_flower_check_ack(app_priv),\n\t\t\t\tNFP_FL_REPLY_TIMEOUT)) {\n\t\tspin_lock_bh(&app_priv->mtu_conf.lock);\n\t\tapp_priv->mtu_conf.requested_val = 0;\n\t\tspin_unlock_bh(&app_priv->mtu_conf.lock);\n\t\tnfp_warn(app->cpp, \"MTU change not verified with fw\\n\");\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int nfp_flower_start(struct nfp_app *app)\n{\n\tstruct nfp_flower_priv *app_priv = app->priv;\n\tint err;\n\n\tif (app_priv->flower_en_feats & NFP_FL_ENABLE_LAG) {\n\t\terr = nfp_flower_lag_reset(&app_priv->nfp_lag);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\terr = flow_indr_dev_register(nfp_flower_indr_setup_tc_cb, app);\n\tif (err)\n\t\treturn err;\n\n\terr = nfp_tunnel_config_start(app);\n\tif (err)\n\t\tgoto err_tunnel_config;\n\n\treturn 0;\n\nerr_tunnel_config:\n\tflow_indr_dev_unregister(nfp_flower_indr_setup_tc_cb, app,\n\t\t\t\t nfp_flower_setup_indr_tc_release);\n\treturn err;\n}\n\nstatic void nfp_flower_stop(struct nfp_app *app)\n{\n\tnfp_tunnel_config_stop(app);\n\n\tflow_indr_dev_unregister(nfp_flower_indr_setup_tc_cb, app,\n\t\t\t\t nfp_flower_setup_indr_tc_release);\n}\n\nstatic int\nnfp_flower_netdev_event(struct nfp_app *app, struct net_device *netdev,\n\t\t\tunsigned long event, void *ptr)\n{\n\tstruct nfp_flower_priv *app_priv = app->priv;\n\tint ret;\n\n\tif (app_priv->flower_en_feats & NFP_FL_ENABLE_LAG) {\n\t\tret = nfp_flower_lag_netdev_event(app_priv, netdev, event, ptr);\n\t\tif (ret & NOTIFY_STOP_MASK)\n\t\t\treturn ret;\n\t}\n\n\tret = nfp_flower_internal_port_event_handler(app, netdev, event);\n\tif (ret & NOTIFY_STOP_MASK)\n\t\treturn ret;\n\n\treturn nfp_tunnel_mac_event_handler(app, netdev, event, ptr);\n}\n\nconst struct nfp_app_type app_flower = {\n\t.id\t\t= NFP_APP_FLOWER_NIC,\n\t.name\t\t= \"flower\",\n\n\t.ctrl_cap_mask\t= ~0U,\n\t.ctrl_has_meta\t= true,\n\n\t.extra_cap\t= nfp_flower_extra_cap,\n\n\t.init\t\t= nfp_flower_init,\n\t.clean\t\t= nfp_flower_clean,\n\n\t.repr_change_mtu  = nfp_flower_repr_change_mtu,\n\n\t.vnic_alloc\t= nfp_flower_vnic_alloc,\n\t.vnic_init\t= nfp_flower_vnic_init,\n\t.vnic_clean\t= nfp_flower_vnic_clean,\n\n\t.repr_preclean\t= nfp_flower_repr_netdev_preclean,\n\t.repr_clean\t= nfp_flower_repr_netdev_clean,\n\n\t.repr_open\t= nfp_flower_repr_netdev_open,\n\t.repr_stop\t= nfp_flower_repr_netdev_stop,\n\n\t.start\t\t= nfp_flower_start,\n\t.stop\t\t= nfp_flower_stop,\n\n\t.netdev_event\t= nfp_flower_netdev_event,\n\n\t.ctrl_msg_rx\t= nfp_flower_cmsg_rx,\n\n\t.sriov_enable\t= nfp_flower_sriov_enable,\n\t.sriov_disable\t= nfp_flower_sriov_disable,\n\n\t.eswitch_mode_get  = eswitch_mode_get,\n\t.dev_get\t= nfp_flower_dev_get,\n\n\t.setup_tc\t= nfp_flower_setup_tc,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}