{
  "module_name": "metadata.c",
  "hash_id": "44274b3701a96421e1d1e5affe29c0f7f096ce62ec0f614454bb6b1c47c7c35b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/netronome/nfp/flower/metadata.c",
  "human_readable_source": "\n \n\n#include <linux/hash.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/math64.h>\n#include <linux/vmalloc.h>\n#include <net/pkt_cls.h>\n\n#include \"cmsg.h\"\n#include \"conntrack.h\"\n#include \"main.h\"\n#include \"../nfp_app.h\"\n\nstruct nfp_mask_id_table {\n\tstruct hlist_node link;\n\tu32 hash_key;\n\tu32 ref_cnt;\n\tu8 mask_id;\n};\n\nstruct nfp_fl_flow_table_cmp_arg {\n\tstruct net_device *netdev;\n\tunsigned long cookie;\n};\n\nstruct nfp_fl_stats_ctx_to_flow {\n\tstruct rhash_head ht_node;\n\tu32 stats_cxt;\n\tstruct nfp_fl_payload *flow;\n};\n\nstatic const struct rhashtable_params stats_ctx_table_params = {\n\t.key_offset\t= offsetof(struct nfp_fl_stats_ctx_to_flow, stats_cxt),\n\t.head_offset\t= offsetof(struct nfp_fl_stats_ctx_to_flow, ht_node),\n\t.key_len\t= sizeof(u32),\n};\n\nstatic int nfp_release_stats_entry(struct nfp_app *app, u32 stats_context_id)\n{\n\tstruct nfp_flower_priv *priv = app->priv;\n\tstruct circ_buf *ring;\n\n\tring = &priv->stats_ids.free_list;\n\t \n\tif (!CIRC_SPACE(ring->head, ring->tail, priv->stats_ring_size))\n\t\treturn -ENOBUFS;\n\n\t \n\tmemcpy(&ring->buf[ring->head * NFP_FL_STATS_ELEM_RS],\n\t       &stats_context_id, NFP_FL_STATS_ELEM_RS);\n\tring->head = (ring->head + 1) & (priv->stats_ring_size - 1);\n\n\treturn 0;\n}\n\nstatic int nfp_get_stats_entry(struct nfp_app *app, u32 *stats_context_id)\n{\n\tstruct nfp_flower_priv *priv = app->priv;\n\tu32 freed_stats_id, temp_stats_id;\n\tstruct circ_buf *ring;\n\n\tring = &priv->stats_ids.free_list;\n\tfreed_stats_id = priv->stats_ring_size;\n\t \n\tif (priv->stats_ids.init_unalloc > 0) {\n\t\t*stats_context_id =\n\t\t\tFIELD_PREP(NFP_FL_STAT_ID_STAT,\n\t\t\t\t   priv->stats_ids.init_unalloc - 1) |\n\t\t\tFIELD_PREP(NFP_FL_STAT_ID_MU_NUM,\n\t\t\t\t   priv->active_mem_unit);\n\n\t\tif (++priv->active_mem_unit == priv->total_mem_units) {\n\t\t\tpriv->stats_ids.init_unalloc--;\n\t\t\tpriv->active_mem_unit = 0;\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\t \n\tif (ring->head == ring->tail) {\n\t\t*stats_context_id = freed_stats_id;\n\t\treturn -ENOENT;\n\t}\n\n\t \n\tmemcpy(&temp_stats_id, &ring->buf[ring->tail * NFP_FL_STATS_ELEM_RS],\n\t       NFP_FL_STATS_ELEM_RS);\n\t*stats_context_id = temp_stats_id;\n\tmemcpy(&ring->buf[ring->tail * NFP_FL_STATS_ELEM_RS], &freed_stats_id,\n\t       NFP_FL_STATS_ELEM_RS);\n\t \n\tring->tail = (ring->tail + 1) & (priv->stats_ring_size - 1);\n\n\treturn 0;\n}\n\n \nstruct nfp_fl_payload *\nnfp_flower_search_fl_table(struct nfp_app *app, unsigned long tc_flower_cookie,\n\t\t\t   struct net_device *netdev)\n{\n\tstruct nfp_fl_flow_table_cmp_arg flower_cmp_arg;\n\tstruct nfp_flower_priv *priv = app->priv;\n\n\tflower_cmp_arg.netdev = netdev;\n\tflower_cmp_arg.cookie = tc_flower_cookie;\n\n\treturn rhashtable_lookup_fast(&priv->flow_table, &flower_cmp_arg,\n\t\t\t\t      nfp_flower_table_params);\n}\n\nvoid nfp_flower_rx_flow_stats(struct nfp_app *app, struct sk_buff *skb)\n{\n\tunsigned int msg_len = nfp_flower_cmsg_get_data_len(skb);\n\tstruct nfp_flower_priv *priv = app->priv;\n\tstruct nfp_fl_stats_frame *stats;\n\tunsigned char *msg;\n\tu32 ctx_id;\n\tint i;\n\n\tmsg = nfp_flower_cmsg_get_data(skb);\n\n\tspin_lock(&priv->stats_lock);\n\tfor (i = 0; i < msg_len / sizeof(*stats); i++) {\n\t\tstats = (struct nfp_fl_stats_frame *)msg + i;\n\t\tctx_id = be32_to_cpu(stats->stats_con_id);\n\t\tpriv->stats[ctx_id].pkts += be32_to_cpu(stats->pkt_count);\n\t\tpriv->stats[ctx_id].bytes += be64_to_cpu(stats->byte_count);\n\t\tpriv->stats[ctx_id].used = jiffies;\n\t}\n\tspin_unlock(&priv->stats_lock);\n}\n\nstatic int nfp_release_mask_id(struct nfp_app *app, u8 mask_id)\n{\n\tstruct nfp_flower_priv *priv = app->priv;\n\tstruct circ_buf *ring;\n\n\tring = &priv->mask_ids.mask_id_free_list;\n\t \n\tif (CIRC_SPACE(ring->head, ring->tail, NFP_FLOWER_MASK_ENTRY_RS) == 0)\n\t\treturn -ENOBUFS;\n\n\t \n\tmemcpy(&ring->buf[ring->head * NFP_FLOWER_MASK_ELEMENT_RS], &mask_id,\n\t       NFP_FLOWER_MASK_ELEMENT_RS);\n\tring->head = (ring->head + 1) & (NFP_FLOWER_MASK_ENTRY_RS - 1);\n\n\tpriv->mask_ids.last_used[mask_id] = ktime_get();\n\n\treturn 0;\n}\n\nstatic int nfp_mask_alloc(struct nfp_app *app, u8 *mask_id)\n{\n\tstruct nfp_flower_priv *priv = app->priv;\n\tktime_t reuse_timeout;\n\tstruct circ_buf *ring;\n\tu8 temp_id, freed_id;\n\n\tring = &priv->mask_ids.mask_id_free_list;\n\tfreed_id = NFP_FLOWER_MASK_ENTRY_RS - 1;\n\t \n\tif (priv->mask_ids.init_unallocated > 0) {\n\t\t*mask_id = priv->mask_ids.init_unallocated;\n\t\tpriv->mask_ids.init_unallocated--;\n\t\treturn 0;\n\t}\n\n\t \n\tif (ring->head == ring->tail)\n\t\tgoto err_not_found;\n\n\t \n\tmemcpy(&temp_id, &ring->buf[ring->tail * NFP_FLOWER_MASK_ELEMENT_RS],\n\t       NFP_FLOWER_MASK_ELEMENT_RS);\n\t*mask_id = temp_id;\n\n\treuse_timeout = ktime_add_ns(priv->mask_ids.last_used[*mask_id],\n\t\t\t\t     NFP_FL_MASK_REUSE_TIME_NS);\n\n\tif (ktime_before(ktime_get(), reuse_timeout))\n\t\tgoto err_not_found;\n\n\tmemcpy(&ring->buf[ring->tail * NFP_FLOWER_MASK_ELEMENT_RS], &freed_id,\n\t       NFP_FLOWER_MASK_ELEMENT_RS);\n\t \n\tring->tail = (ring->tail + 1) & (NFP_FLOWER_MASK_ENTRY_RS - 1);\n\n\treturn 0;\n\nerr_not_found:\n\t*mask_id = freed_id;\n\treturn -ENOENT;\n}\n\nstatic int\nnfp_add_mask_table(struct nfp_app *app, char *mask_data, u32 mask_len)\n{\n\tstruct nfp_flower_priv *priv = app->priv;\n\tstruct nfp_mask_id_table *mask_entry;\n\tunsigned long hash_key;\n\tu8 mask_id;\n\n\tif (nfp_mask_alloc(app, &mask_id))\n\t\treturn -ENOENT;\n\n\tmask_entry = kmalloc(sizeof(*mask_entry), GFP_KERNEL);\n\tif (!mask_entry) {\n\t\tnfp_release_mask_id(app, mask_id);\n\t\treturn -ENOMEM;\n\t}\n\n\tINIT_HLIST_NODE(&mask_entry->link);\n\tmask_entry->mask_id = mask_id;\n\thash_key = jhash(mask_data, mask_len, priv->mask_id_seed);\n\tmask_entry->hash_key = hash_key;\n\tmask_entry->ref_cnt = 1;\n\thash_add(priv->mask_table, &mask_entry->link, hash_key);\n\n\treturn mask_id;\n}\n\nstatic struct nfp_mask_id_table *\nnfp_search_mask_table(struct nfp_app *app, char *mask_data, u32 mask_len)\n{\n\tstruct nfp_flower_priv *priv = app->priv;\n\tstruct nfp_mask_id_table *mask_entry;\n\tunsigned long hash_key;\n\n\thash_key = jhash(mask_data, mask_len, priv->mask_id_seed);\n\n\thash_for_each_possible(priv->mask_table, mask_entry, link, hash_key)\n\t\tif (mask_entry->hash_key == hash_key)\n\t\t\treturn mask_entry;\n\n\treturn NULL;\n}\n\nstatic int\nnfp_find_in_mask_table(struct nfp_app *app, char *mask_data, u32 mask_len)\n{\n\tstruct nfp_mask_id_table *mask_entry;\n\n\tmask_entry = nfp_search_mask_table(app, mask_data, mask_len);\n\tif (!mask_entry)\n\t\treturn -ENOENT;\n\n\tmask_entry->ref_cnt++;\n\n\t \n\treturn mask_entry->mask_id;\n}\n\nstatic bool\nnfp_check_mask_add(struct nfp_app *app, char *mask_data, u32 mask_len,\n\t\t   u8 *meta_flags, u8 *mask_id)\n{\n\tint id;\n\n\tid = nfp_find_in_mask_table(app, mask_data, mask_len);\n\tif (id < 0) {\n\t\tid = nfp_add_mask_table(app, mask_data, mask_len);\n\t\tif (id < 0)\n\t\t\treturn false;\n\t\t*meta_flags |= NFP_FL_META_FLAG_MANAGE_MASK;\n\t}\n\t*mask_id = id;\n\n\treturn true;\n}\n\nstatic bool\nnfp_check_mask_remove(struct nfp_app *app, char *mask_data, u32 mask_len,\n\t\t      u8 *meta_flags, u8 *mask_id)\n{\n\tstruct nfp_mask_id_table *mask_entry;\n\n\tmask_entry = nfp_search_mask_table(app, mask_data, mask_len);\n\tif (!mask_entry)\n\t\treturn false;\n\n\t*mask_id = mask_entry->mask_id;\n\tmask_entry->ref_cnt--;\n\tif (!mask_entry->ref_cnt) {\n\t\thash_del(&mask_entry->link);\n\t\tnfp_release_mask_id(app, *mask_id);\n\t\tkfree(mask_entry);\n\t\tif (meta_flags)\n\t\t\t*meta_flags |= NFP_FL_META_FLAG_MANAGE_MASK;\n\t}\n\n\treturn true;\n}\n\nint nfp_compile_flow_metadata(struct nfp_app *app, u32 cookie,\n\t\t\t      struct nfp_fl_payload *nfp_flow,\n\t\t\t      struct net_device *netdev,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct nfp_fl_stats_ctx_to_flow *ctx_entry;\n\tstruct nfp_flower_priv *priv = app->priv;\n\tstruct nfp_fl_payload *check_entry;\n\tu8 new_mask_id;\n\tu32 stats_cxt;\n\tint err;\n\n\terr = nfp_get_stats_entry(app, &stats_cxt);\n\tif (err) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"invalid entry: cannot allocate new stats context\");\n\t\treturn err;\n\t}\n\n\tnfp_flow->meta.host_ctx_id = cpu_to_be32(stats_cxt);\n\tnfp_flow->meta.host_cookie = cpu_to_be64(cookie);\n\tnfp_flow->ingress_dev = netdev;\n\n\tctx_entry = kzalloc(sizeof(*ctx_entry), GFP_KERNEL);\n\tif (!ctx_entry) {\n\t\terr = -ENOMEM;\n\t\tgoto err_release_stats;\n\t}\n\n\tctx_entry->stats_cxt = stats_cxt;\n\tctx_entry->flow = nfp_flow;\n\n\tif (rhashtable_insert_fast(&priv->stats_ctx_table, &ctx_entry->ht_node,\n\t\t\t\t   stats_ctx_table_params)) {\n\t\terr = -ENOMEM;\n\t\tgoto err_free_ctx_entry;\n\t}\n\n\t \n\tnew_mask_id = 0;\n\tif (!nfp_flow->pre_tun_rule.dev &&\n\t    !nfp_check_mask_add(app, nfp_flow->mask_data,\n\t\t\t\tnfp_flow->meta.mask_len,\n\t\t\t\t&nfp_flow->meta.flags, &new_mask_id)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"invalid entry: cannot allocate a new mask id\");\n\t\terr = -ENOENT;\n\t\tgoto err_remove_rhash;\n\t}\n\n\tnfp_flow->meta.flow_version = cpu_to_be64(priv->flower_version);\n\tpriv->flower_version++;\n\n\t \n\tnfp_flow->unmasked_data[NFP_FL_MASK_ID_LOCATION] = new_mask_id;\n\tpriv->stats[stats_cxt].pkts = 0;\n\tpriv->stats[stats_cxt].bytes = 0;\n\tpriv->stats[stats_cxt].used = jiffies;\n\n\tcheck_entry = nfp_flower_search_fl_table(app, cookie, netdev);\n\tif (check_entry) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"invalid entry: cannot offload duplicate flow entry\");\n\t\terr = -EEXIST;\n\t\tgoto err_remove_mask;\n\t}\n\n\treturn 0;\n\nerr_remove_mask:\n\tif (!nfp_flow->pre_tun_rule.dev)\n\t\tnfp_check_mask_remove(app, nfp_flow->mask_data,\n\t\t\t\t      nfp_flow->meta.mask_len,\n\t\t\t\t      NULL, &new_mask_id);\nerr_remove_rhash:\n\tWARN_ON_ONCE(rhashtable_remove_fast(&priv->stats_ctx_table,\n\t\t\t\t\t    &ctx_entry->ht_node,\n\t\t\t\t\t    stats_ctx_table_params));\nerr_free_ctx_entry:\n\tkfree(ctx_entry);\nerr_release_stats:\n\tnfp_release_stats_entry(app, stats_cxt);\n\n\treturn err;\n}\n\nvoid __nfp_modify_flow_metadata(struct nfp_flower_priv *priv,\n\t\t\t\tstruct nfp_fl_payload *nfp_flow)\n{\n\tnfp_flow->meta.flags &= ~NFP_FL_META_FLAG_MANAGE_MASK;\n\tnfp_flow->meta.flow_version = cpu_to_be64(priv->flower_version);\n\tpriv->flower_version++;\n}\n\nint nfp_modify_flow_metadata(struct nfp_app *app,\n\t\t\t     struct nfp_fl_payload *nfp_flow)\n{\n\tstruct nfp_fl_stats_ctx_to_flow *ctx_entry;\n\tstruct nfp_flower_priv *priv = app->priv;\n\tu8 new_mask_id = 0;\n\tu32 temp_ctx_id;\n\n\t__nfp_modify_flow_metadata(priv, nfp_flow);\n\n\tif (!nfp_flow->pre_tun_rule.dev)\n\t\tnfp_check_mask_remove(app, nfp_flow->mask_data,\n\t\t\t\t      nfp_flow->meta.mask_len, &nfp_flow->meta.flags,\n\t\t\t\t      &new_mask_id);\n\n\t \n\tnfp_flow->unmasked_data[NFP_FL_MASK_ID_LOCATION] = new_mask_id;\n\n\t \n\ttemp_ctx_id = be32_to_cpu(nfp_flow->meta.host_ctx_id);\n\n\tctx_entry = rhashtable_lookup_fast(&priv->stats_ctx_table, &temp_ctx_id,\n\t\t\t\t\t   stats_ctx_table_params);\n\tif (!ctx_entry)\n\t\treturn -ENOENT;\n\n\tWARN_ON_ONCE(rhashtable_remove_fast(&priv->stats_ctx_table,\n\t\t\t\t\t    &ctx_entry->ht_node,\n\t\t\t\t\t    stats_ctx_table_params));\n\tkfree(ctx_entry);\n\n\treturn nfp_release_stats_entry(app, temp_ctx_id);\n}\n\nstruct nfp_fl_payload *\nnfp_flower_get_fl_payload_from_ctx(struct nfp_app *app, u32 ctx_id)\n{\n\tstruct nfp_fl_stats_ctx_to_flow *ctx_entry;\n\tstruct nfp_flower_priv *priv = app->priv;\n\n\tctx_entry = rhashtable_lookup_fast(&priv->stats_ctx_table, &ctx_id,\n\t\t\t\t\t   stats_ctx_table_params);\n\tif (!ctx_entry)\n\t\treturn NULL;\n\n\treturn ctx_entry->flow;\n}\n\nstatic int nfp_fl_obj_cmpfn(struct rhashtable_compare_arg *arg,\n\t\t\t    const void *obj)\n{\n\tconst struct nfp_fl_flow_table_cmp_arg *cmp_arg = arg->key;\n\tconst struct nfp_fl_payload *flow_entry = obj;\n\n\tif (flow_entry->ingress_dev == cmp_arg->netdev)\n\t\treturn flow_entry->tc_flower_cookie != cmp_arg->cookie;\n\n\treturn 1;\n}\n\nstatic u32 nfp_fl_obj_hashfn(const void *data, u32 len, u32 seed)\n{\n\tconst struct nfp_fl_payload *flower_entry = data;\n\n\treturn jhash2((u32 *)&flower_entry->tc_flower_cookie,\n\t\t      sizeof(flower_entry->tc_flower_cookie) / sizeof(u32),\n\t\t      seed);\n}\n\nstatic u32 nfp_fl_key_hashfn(const void *data, u32 len, u32 seed)\n{\n\tconst struct nfp_fl_flow_table_cmp_arg *cmp_arg = data;\n\n\treturn jhash2((u32 *)&cmp_arg->cookie,\n\t\t      sizeof(cmp_arg->cookie) / sizeof(u32), seed);\n}\n\nconst struct rhashtable_params nfp_flower_table_params = {\n\t.head_offset\t\t= offsetof(struct nfp_fl_payload, fl_node),\n\t.hashfn\t\t\t= nfp_fl_key_hashfn,\n\t.obj_cmpfn\t\t= nfp_fl_obj_cmpfn,\n\t.obj_hashfn\t\t= nfp_fl_obj_hashfn,\n\t.automatic_shrinking\t= true,\n};\n\nconst struct rhashtable_params merge_table_params = {\n\t.key_offset\t= offsetof(struct nfp_merge_info, parent_ctx),\n\t.head_offset\t= offsetof(struct nfp_merge_info, ht_node),\n\t.key_len\t= sizeof(u64),\n};\n\nconst struct rhashtable_params nfp_zone_table_params = {\n\t.head_offset\t\t= offsetof(struct nfp_fl_ct_zone_entry, hash_node),\n\t.key_len\t\t= sizeof(u16),\n\t.key_offset\t\t= offsetof(struct nfp_fl_ct_zone_entry, zone),\n\t.automatic_shrinking\t= false,\n};\n\nconst struct rhashtable_params nfp_ct_map_params = {\n\t.head_offset\t\t= offsetof(struct nfp_fl_ct_map_entry, hash_node),\n\t.key_len\t\t= sizeof(unsigned long),\n\t.key_offset\t\t= offsetof(struct nfp_fl_ct_map_entry, cookie),\n\t.automatic_shrinking\t= true,\n};\n\nconst struct rhashtable_params neigh_table_params = {\n\t.key_offset\t= offsetof(struct nfp_neigh_entry, neigh_cookie),\n\t.head_offset\t= offsetof(struct nfp_neigh_entry, ht_node),\n\t.key_len\t= sizeof(unsigned long),\n};\n\nint nfp_flower_metadata_init(struct nfp_app *app, u64 host_ctx_count,\n\t\t\t     unsigned int host_num_mems)\n{\n\tstruct nfp_flower_priv *priv = app->priv;\n\tint err, stats_size;\n\n\thash_init(priv->mask_table);\n\n\terr = rhashtable_init(&priv->flow_table, &nfp_flower_table_params);\n\tif (err)\n\t\treturn err;\n\n\terr = rhashtable_init(&priv->stats_ctx_table, &stats_ctx_table_params);\n\tif (err)\n\t\tgoto err_free_flow_table;\n\n\terr = rhashtable_init(&priv->merge_table, &merge_table_params);\n\tif (err)\n\t\tgoto err_free_stats_ctx_table;\n\n\tmutex_init(&priv->nfp_fl_lock);\n\n\terr = rhashtable_init(&priv->ct_zone_table, &nfp_zone_table_params);\n\tif (err)\n\t\tgoto err_free_merge_table;\n\n\terr = rhashtable_init(&priv->ct_map_table, &nfp_ct_map_params);\n\tif (err)\n\t\tgoto err_free_ct_zone_table;\n\n\terr = rhashtable_init(&priv->neigh_table, &neigh_table_params);\n\tif (err)\n\t\tgoto err_free_ct_map_table;\n\n\tINIT_LIST_HEAD(&priv->predt_list);\n\n\tget_random_bytes(&priv->mask_id_seed, sizeof(priv->mask_id_seed));\n\n\t \n\tpriv->mask_ids.mask_id_free_list.buf =\n\t\tkmalloc_array(NFP_FLOWER_MASK_ENTRY_RS,\n\t\t\t      NFP_FLOWER_MASK_ELEMENT_RS, GFP_KERNEL);\n\tif (!priv->mask_ids.mask_id_free_list.buf)\n\t\tgoto err_free_neigh_table;\n\n\tpriv->mask_ids.init_unallocated = NFP_FLOWER_MASK_ENTRY_RS - 1;\n\n\t \n\tpriv->mask_ids.last_used =\n\t\tkmalloc_array(NFP_FLOWER_MASK_ENTRY_RS,\n\t\t\t      sizeof(*priv->mask_ids.last_used), GFP_KERNEL);\n\tif (!priv->mask_ids.last_used)\n\t\tgoto err_free_mask_id;\n\n\t \n\tpriv->stats_ids.free_list.buf =\n\t\tvmalloc(array_size(NFP_FL_STATS_ELEM_RS,\n\t\t\t\t   priv->stats_ring_size));\n\tif (!priv->stats_ids.free_list.buf)\n\t\tgoto err_free_last_used;\n\n\tpriv->stats_ids.init_unalloc = div_u64(host_ctx_count, host_num_mems);\n\n\tstats_size = FIELD_PREP(NFP_FL_STAT_ID_STAT, host_ctx_count) |\n\t\t     FIELD_PREP(NFP_FL_STAT_ID_MU_NUM, host_num_mems - 1);\n\tpriv->stats = kvmalloc_array(stats_size, sizeof(struct nfp_fl_stats),\n\t\t\t\t     GFP_KERNEL);\n\tif (!priv->stats)\n\t\tgoto err_free_ring_buf;\n\n\tspin_lock_init(&priv->stats_lock);\n\tspin_lock_init(&priv->predt_lock);\n\n\treturn 0;\n\nerr_free_ring_buf:\n\tvfree(priv->stats_ids.free_list.buf);\nerr_free_last_used:\n\tkfree(priv->mask_ids.last_used);\nerr_free_mask_id:\n\tkfree(priv->mask_ids.mask_id_free_list.buf);\nerr_free_neigh_table:\n\trhashtable_destroy(&priv->neigh_table);\nerr_free_ct_map_table:\n\trhashtable_destroy(&priv->ct_map_table);\nerr_free_ct_zone_table:\n\trhashtable_destroy(&priv->ct_zone_table);\nerr_free_merge_table:\n\trhashtable_destroy(&priv->merge_table);\nerr_free_stats_ctx_table:\n\trhashtable_destroy(&priv->stats_ctx_table);\nerr_free_flow_table:\n\trhashtable_destroy(&priv->flow_table);\n\treturn -ENOMEM;\n}\n\nstatic void nfp_zone_table_entry_destroy(struct nfp_fl_ct_zone_entry *zt)\n{\n\tif (!zt)\n\t\treturn;\n\n\tif (!list_empty(&zt->pre_ct_list)) {\n\t\tstruct rhashtable *m_table = &zt->priv->ct_map_table;\n\t\tstruct nfp_fl_ct_flow_entry *entry, *tmp;\n\t\tstruct nfp_fl_ct_map_entry *map;\n\n\t\tWARN_ONCE(1, \"pre_ct_list not empty as expected, cleaning up\\n\");\n\t\tlist_for_each_entry_safe(entry, tmp, &zt->pre_ct_list,\n\t\t\t\t\t list_node) {\n\t\t\tmap = rhashtable_lookup_fast(m_table,\n\t\t\t\t\t\t     &entry->cookie,\n\t\t\t\t\t\t     nfp_ct_map_params);\n\t\t\tWARN_ON_ONCE(rhashtable_remove_fast(m_table,\n\t\t\t\t\t\t\t    &map->hash_node,\n\t\t\t\t\t\t\t    nfp_ct_map_params));\n\t\t\tnfp_fl_ct_clean_flow_entry(entry);\n\t\t\tkfree(map);\n\t\t}\n\t}\n\n\tif (!list_empty(&zt->post_ct_list)) {\n\t\tstruct rhashtable *m_table = &zt->priv->ct_map_table;\n\t\tstruct nfp_fl_ct_flow_entry *entry, *tmp;\n\t\tstruct nfp_fl_ct_map_entry *map;\n\n\t\tWARN_ONCE(1, \"post_ct_list not empty as expected, cleaning up\\n\");\n\t\tlist_for_each_entry_safe(entry, tmp, &zt->post_ct_list,\n\t\t\t\t\t list_node) {\n\t\t\tmap = rhashtable_lookup_fast(m_table,\n\t\t\t\t\t\t     &entry->cookie,\n\t\t\t\t\t\t     nfp_ct_map_params);\n\t\t\tWARN_ON_ONCE(rhashtable_remove_fast(m_table,\n\t\t\t\t\t\t\t    &map->hash_node,\n\t\t\t\t\t\t\t    nfp_ct_map_params));\n\t\t\tnfp_fl_ct_clean_flow_entry(entry);\n\t\t\tkfree(map);\n\t\t}\n\t}\n\n\tif (zt->nft) {\n\t\tnf_flow_table_offload_del_cb(zt->nft,\n\t\t\t\t\t     nfp_fl_ct_handle_nft_flow,\n\t\t\t\t\t     zt);\n\t\tzt->nft = NULL;\n\t}\n\n\tif (!list_empty(&zt->nft_flows_list)) {\n\t\tstruct rhashtable *m_table = &zt->priv->ct_map_table;\n\t\tstruct nfp_fl_ct_flow_entry *entry, *tmp;\n\t\tstruct nfp_fl_ct_map_entry *map;\n\n\t\tWARN_ONCE(1, \"nft_flows_list not empty as expected, cleaning up\\n\");\n\t\tlist_for_each_entry_safe(entry, tmp, &zt->nft_flows_list,\n\t\t\t\t\t list_node) {\n\t\t\tmap = rhashtable_lookup_fast(m_table,\n\t\t\t\t\t\t     &entry->cookie,\n\t\t\t\t\t\t     nfp_ct_map_params);\n\t\t\tWARN_ON_ONCE(rhashtable_remove_fast(m_table,\n\t\t\t\t\t\t\t    &map->hash_node,\n\t\t\t\t\t\t\t    nfp_ct_map_params));\n\t\t\tnfp_fl_ct_clean_flow_entry(entry);\n\t\t\tkfree(map);\n\t\t}\n\t}\n\n\trhashtable_free_and_destroy(&zt->tc_merge_tb,\n\t\t\t\t    nfp_check_rhashtable_empty, NULL);\n\trhashtable_free_and_destroy(&zt->nft_merge_tb,\n\t\t\t\t    nfp_check_rhashtable_empty, NULL);\n\n\tkfree(zt);\n}\n\nstatic void nfp_free_zone_table_entry(void *ptr, void *arg)\n{\n\tstruct nfp_fl_ct_zone_entry *zt = ptr;\n\n\tnfp_zone_table_entry_destroy(zt);\n}\n\nstatic void nfp_free_map_table_entry(void *ptr, void *arg)\n{\n\tstruct nfp_fl_ct_map_entry *map = ptr;\n\n\tif (!map)\n\t\treturn;\n\n\tkfree(map);\n}\n\nvoid nfp_flower_metadata_cleanup(struct nfp_app *app)\n{\n\tstruct nfp_flower_priv *priv = app->priv;\n\n\tif (!priv)\n\t\treturn;\n\n\trhashtable_free_and_destroy(&priv->flow_table,\n\t\t\t\t    nfp_check_rhashtable_empty, NULL);\n\trhashtable_free_and_destroy(&priv->stats_ctx_table,\n\t\t\t\t    nfp_check_rhashtable_empty, NULL);\n\trhashtable_free_and_destroy(&priv->merge_table,\n\t\t\t\t    nfp_check_rhashtable_empty, NULL);\n\trhashtable_free_and_destroy(&priv->ct_zone_table,\n\t\t\t\t    nfp_free_zone_table_entry, NULL);\n\tnfp_zone_table_entry_destroy(priv->ct_zone_wc);\n\n\trhashtable_free_and_destroy(&priv->ct_map_table,\n\t\t\t\t    nfp_free_map_table_entry, NULL);\n\trhashtable_free_and_destroy(&priv->neigh_table,\n\t\t\t\t    nfp_check_rhashtable_empty, NULL);\n\tkvfree(priv->stats);\n\tkfree(priv->mask_ids.mask_id_free_list.buf);\n\tkfree(priv->mask_ids.last_used);\n\tvfree(priv->stats_ids.free_list.buf);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}