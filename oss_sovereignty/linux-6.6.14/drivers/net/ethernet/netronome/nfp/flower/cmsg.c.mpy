{
  "module_name": "cmsg.c",
  "hash_id": "ed8be43fe280d2b7b0601f759dad8c03090bf38c8362d7e9e89568bcd6c30de3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/netronome/nfp/flower/cmsg.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/netdevice.h>\n#include <linux/skbuff.h>\n#include <linux/workqueue.h>\n#include <net/dst_metadata.h>\n\n#include \"main.h\"\n#include \"../nfp_net.h\"\n#include \"../nfp_net_repr.h\"\n#include \"./cmsg.h\"\n\nstatic struct nfp_flower_cmsg_hdr *\nnfp_flower_cmsg_get_hdr(struct sk_buff *skb)\n{\n\treturn (struct nfp_flower_cmsg_hdr *)skb->data;\n}\n\nstruct sk_buff *\nnfp_flower_cmsg_alloc(struct nfp_app *app, unsigned int size,\n\t\t      enum nfp_flower_cmsg_type_port type, gfp_t flag)\n{\n\tstruct nfp_flower_cmsg_hdr *ch;\n\tstruct sk_buff *skb;\n\n\tsize += NFP_FLOWER_CMSG_HLEN;\n\n\tskb = nfp_app_ctrl_msg_alloc(app, size, flag);\n\tif (!skb)\n\t\treturn NULL;\n\n\tch = nfp_flower_cmsg_get_hdr(skb);\n\tch->pad = 0;\n\tch->version = NFP_FLOWER_CMSG_VER1;\n\tch->type = type;\n\tskb_put(skb, size);\n\n\treturn skb;\n}\n\nstruct sk_buff *\nnfp_flower_cmsg_mac_repr_start(struct nfp_app *app, unsigned int num_ports)\n{\n\tstruct nfp_flower_cmsg_mac_repr *msg;\n\tstruct sk_buff *skb;\n\n\tskb = nfp_flower_cmsg_alloc(app, struct_size(msg, ports, num_ports),\n\t\t\t\t    NFP_FLOWER_CMSG_TYPE_MAC_REPR, GFP_KERNEL);\n\tif (!skb)\n\t\treturn NULL;\n\n\tmsg = nfp_flower_cmsg_get_data(skb);\n\tmemset(msg->reserved, 0, sizeof(msg->reserved));\n\tmsg->num_ports = num_ports;\n\n\treturn skb;\n}\n\nvoid\nnfp_flower_cmsg_mac_repr_add(struct sk_buff *skb, unsigned int idx,\n\t\t\t     unsigned int nbi, unsigned int nbi_port,\n\t\t\t     unsigned int phys_port)\n{\n\tstruct nfp_flower_cmsg_mac_repr *msg;\n\n\tmsg = nfp_flower_cmsg_get_data(skb);\n\tmsg->ports[idx].idx = idx;\n\tmsg->ports[idx].info = nbi & NFP_FLOWER_CMSG_MAC_REPR_NBI;\n\tmsg->ports[idx].nbi_port = nbi_port;\n\tmsg->ports[idx].phys_port = phys_port;\n}\n\nint nfp_flower_cmsg_portmod(struct nfp_repr *repr, bool carrier_ok,\n\t\t\t    unsigned int mtu, bool mtu_only)\n{\n\tstruct nfp_flower_cmsg_portmod *msg;\n\tstruct sk_buff *skb;\n\n\tskb = nfp_flower_cmsg_alloc(repr->app, sizeof(*msg),\n\t\t\t\t    NFP_FLOWER_CMSG_TYPE_PORT_MOD, GFP_KERNEL);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tmsg = nfp_flower_cmsg_get_data(skb);\n\tmsg->portnum = cpu_to_be32(repr->dst->u.port_info.port_id);\n\tmsg->reserved = 0;\n\tmsg->info = carrier_ok;\n\n\tif (mtu_only)\n\t\tmsg->info |= NFP_FLOWER_CMSG_PORTMOD_MTU_CHANGE_ONLY;\n\n\tmsg->mtu = cpu_to_be16(mtu);\n\n\tnfp_ctrl_tx(repr->app->ctrl, skb);\n\n\treturn 0;\n}\n\nint nfp_flower_cmsg_portreify(struct nfp_repr *repr, bool exists)\n{\n\tstruct nfp_flower_cmsg_portreify *msg;\n\tstruct sk_buff *skb;\n\n\tskb = nfp_flower_cmsg_alloc(repr->app, sizeof(*msg),\n\t\t\t\t    NFP_FLOWER_CMSG_TYPE_PORT_REIFY,\n\t\t\t\t    GFP_KERNEL);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tmsg = nfp_flower_cmsg_get_data(skb);\n\tmsg->portnum = cpu_to_be32(repr->dst->u.port_info.port_id);\n\tmsg->reserved = 0;\n\tmsg->info = cpu_to_be16(exists);\n\n\tnfp_ctrl_tx(repr->app->ctrl, skb);\n\n\treturn 0;\n}\n\nstatic bool\nnfp_flower_process_mtu_ack(struct nfp_app *app, struct sk_buff *skb)\n{\n\tstruct nfp_flower_priv *app_priv = app->priv;\n\tstruct nfp_flower_cmsg_portmod *msg;\n\n\tmsg = nfp_flower_cmsg_get_data(skb);\n\n\tif (!(msg->info & NFP_FLOWER_CMSG_PORTMOD_MTU_CHANGE_ONLY))\n\t\treturn false;\n\n\tspin_lock_bh(&app_priv->mtu_conf.lock);\n\tif (!app_priv->mtu_conf.requested_val ||\n\t    app_priv->mtu_conf.portnum != be32_to_cpu(msg->portnum) ||\n\t    be16_to_cpu(msg->mtu) != app_priv->mtu_conf.requested_val) {\n\t\t \n\t\tspin_unlock_bh(&app_priv->mtu_conf.lock);\n\t\treturn false;\n\t}\n\n\tapp_priv->mtu_conf.ack = true;\n\tapp_priv->mtu_conf.requested_val = 0;\n\twake_up(&app_priv->mtu_conf.wait_q);\n\tspin_unlock_bh(&app_priv->mtu_conf.lock);\n\n\treturn true;\n}\n\nstatic void\nnfp_flower_cmsg_portmod_rx(struct nfp_app *app, struct sk_buff *skb)\n{\n\tstruct nfp_flower_cmsg_portmod *msg;\n\tstruct net_device *netdev;\n\tbool link;\n\n\tmsg = nfp_flower_cmsg_get_data(skb);\n\tlink = msg->info & NFP_FLOWER_CMSG_PORTMOD_INFO_LINK;\n\n\trtnl_lock();\n\trcu_read_lock();\n\tnetdev = nfp_app_dev_get(app, be32_to_cpu(msg->portnum), NULL);\n\trcu_read_unlock();\n\tif (!netdev) {\n\t\tnfp_flower_cmsg_warn(app, \"ctrl msg for unknown port 0x%08x\\n\",\n\t\t\t\t     be32_to_cpu(msg->portnum));\n\t\trtnl_unlock();\n\t\treturn;\n\t}\n\n\tif (link) {\n\t\tu16 mtu = be16_to_cpu(msg->mtu);\n\n\t\tnetif_carrier_on(netdev);\n\n\t\t \n\t\tif (mtu)\n\t\t\tdev_set_mtu(netdev, mtu);\n\t} else {\n\t\tnetif_carrier_off(netdev);\n\t}\n\trtnl_unlock();\n}\n\nstatic void\nnfp_flower_cmsg_portreify_rx(struct nfp_app *app, struct sk_buff *skb)\n{\n\tstruct nfp_flower_priv *priv = app->priv;\n\tstruct nfp_flower_cmsg_portreify *msg;\n\tbool exists;\n\n\tmsg = nfp_flower_cmsg_get_data(skb);\n\n\trcu_read_lock();\n\texists = !!nfp_app_dev_get(app, be32_to_cpu(msg->portnum), NULL);\n\trcu_read_unlock();\n\tif (!exists) {\n\t\tnfp_flower_cmsg_warn(app, \"ctrl msg for unknown port 0x%08x\\n\",\n\t\t\t\t     be32_to_cpu(msg->portnum));\n\t\treturn;\n\t}\n\n\tatomic_inc(&priv->reify_replies);\n\twake_up(&priv->reify_wait_queue);\n}\n\nstatic void\nnfp_flower_cmsg_merge_hint_rx(struct nfp_app *app, struct sk_buff *skb)\n{\n\tunsigned int msg_len = nfp_flower_cmsg_get_data_len(skb);\n\tstruct nfp_flower_cmsg_merge_hint *msg;\n\tstruct nfp_fl_payload *sub_flows[2];\n\tstruct nfp_flower_priv *priv;\n\tint err, i, flow_cnt;\n\n\tmsg = nfp_flower_cmsg_get_data(skb);\n\t \n\tflow_cnt = msg->count + 1;\n\n\tif (msg_len < struct_size(msg, flow, flow_cnt)) {\n\t\tnfp_flower_cmsg_warn(app, \"Merge hint ctrl msg too short - %d bytes but expect %zd\\n\",\n\t\t\t\t     msg_len, struct_size(msg, flow, flow_cnt));\n\t\treturn;\n\t}\n\n\tif (flow_cnt != 2) {\n\t\tnfp_flower_cmsg_warn(app, \"Merge hint contains %d flows - two are expected\\n\",\n\t\t\t\t     flow_cnt);\n\t\treturn;\n\t}\n\n\tpriv = app->priv;\n\tmutex_lock(&priv->nfp_fl_lock);\n\tfor (i = 0; i < flow_cnt; i++) {\n\t\tu32 ctx = be32_to_cpu(msg->flow[i].host_ctx);\n\n\t\tsub_flows[i] = nfp_flower_get_fl_payload_from_ctx(app, ctx);\n\t\tif (!sub_flows[i]) {\n\t\t\tnfp_flower_cmsg_warn(app, \"Invalid flow in merge hint\\n\");\n\t\t\tgoto err_mutex_unlock;\n\t\t}\n\t}\n\n\terr = nfp_flower_merge_offloaded_flows(app, sub_flows[0], sub_flows[1]);\n\t \n\tif (err == -ENOMEM)\n\t\tnfp_flower_cmsg_warn(app, \"Flow merge memory fail.\\n\");\n\nerr_mutex_unlock:\n\tmutex_unlock(&priv->nfp_fl_lock);\n}\n\nstatic void\nnfp_flower_cmsg_process_one_rx(struct nfp_app *app, struct sk_buff *skb)\n{\n\tstruct nfp_flower_priv *app_priv = app->priv;\n\tstruct nfp_flower_cmsg_hdr *cmsg_hdr;\n\tenum nfp_flower_cmsg_type_port type;\n\tbool skb_stored = false;\n\n\tcmsg_hdr = nfp_flower_cmsg_get_hdr(skb);\n\n\ttype = cmsg_hdr->type;\n\tswitch (type) {\n\tcase NFP_FLOWER_CMSG_TYPE_PORT_MOD:\n\t\tnfp_flower_cmsg_portmod_rx(app, skb);\n\t\tbreak;\n\tcase NFP_FLOWER_CMSG_TYPE_MERGE_HINT:\n\t\tif (app_priv->flower_en_feats & NFP_FL_ENABLE_FLOW_MERGE) {\n\t\t\tnfp_flower_cmsg_merge_hint_rx(app, skb);\n\t\t\tbreak;\n\t\t}\n\t\tgoto err_default;\n\tcase NFP_FLOWER_CMSG_TYPE_NO_NEIGH:\n\t\tnfp_tunnel_request_route_v4(app, skb);\n\t\tbreak;\n\tcase NFP_FLOWER_CMSG_TYPE_NO_NEIGH_V6:\n\t\tnfp_tunnel_request_route_v6(app, skb);\n\t\tbreak;\n\tcase NFP_FLOWER_CMSG_TYPE_ACTIVE_TUNS:\n\t\tnfp_tunnel_keep_alive(app, skb);\n\t\tbreak;\n\tcase NFP_FLOWER_CMSG_TYPE_ACTIVE_TUNS_V6:\n\t\tnfp_tunnel_keep_alive_v6(app, skb);\n\t\tbreak;\n\tcase NFP_FLOWER_CMSG_TYPE_QOS_STATS:\n\t\tnfp_flower_stats_rlim_reply(app, skb);\n\t\tbreak;\n\tcase NFP_FLOWER_CMSG_TYPE_LAG_CONFIG:\n\t\tif (app_priv->flower_en_feats & NFP_FL_ENABLE_LAG) {\n\t\t\tskb_stored = nfp_flower_lag_unprocessed_msg(app, skb);\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tdefault:\nerr_default:\n\t\tnfp_flower_cmsg_warn(app, \"Cannot handle invalid repr control type %u\\n\",\n\t\t\t\t     type);\n\t\tgoto out;\n\t}\n\n\tif (!skb_stored)\n\t\tdev_consume_skb_any(skb);\n\treturn;\nout:\n\tdev_kfree_skb_any(skb);\n}\n\nvoid nfp_flower_cmsg_process_rx(struct work_struct *work)\n{\n\tstruct sk_buff_head cmsg_joined;\n\tstruct nfp_flower_priv *priv;\n\tstruct sk_buff *skb;\n\n\tpriv = container_of(work, struct nfp_flower_priv, cmsg_work);\n\tskb_queue_head_init(&cmsg_joined);\n\n\tspin_lock_bh(&priv->cmsg_skbs_high.lock);\n\tskb_queue_splice_tail_init(&priv->cmsg_skbs_high, &cmsg_joined);\n\tspin_unlock_bh(&priv->cmsg_skbs_high.lock);\n\n\tspin_lock_bh(&priv->cmsg_skbs_low.lock);\n\tskb_queue_splice_tail_init(&priv->cmsg_skbs_low, &cmsg_joined);\n\tspin_unlock_bh(&priv->cmsg_skbs_low.lock);\n\n\twhile ((skb = __skb_dequeue(&cmsg_joined)))\n\t\tnfp_flower_cmsg_process_one_rx(priv->app, skb);\n}\n\nstatic void\nnfp_flower_queue_ctl_msg(struct nfp_app *app, struct sk_buff *skb, int type)\n{\n\tstruct nfp_flower_priv *priv = app->priv;\n\tstruct sk_buff_head *skb_head;\n\n\tif (type == NFP_FLOWER_CMSG_TYPE_PORT_MOD)\n\t\tskb_head = &priv->cmsg_skbs_high;\n\telse\n\t\tskb_head = &priv->cmsg_skbs_low;\n\n\tif (skb_queue_len(skb_head) >= NFP_FLOWER_WORKQ_MAX_SKBS) {\n\t\tnfp_flower_cmsg_warn(app, \"Dropping queued control messages\\n\");\n\t\tdev_kfree_skb_any(skb);\n\t\treturn;\n\t}\n\n\tskb_queue_tail(skb_head, skb);\n\tschedule_work(&priv->cmsg_work);\n}\n\nvoid nfp_flower_cmsg_rx(struct nfp_app *app, struct sk_buff *skb)\n{\n\tstruct nfp_flower_cmsg_hdr *cmsg_hdr;\n\n\tcmsg_hdr = nfp_flower_cmsg_get_hdr(skb);\n\n\tif (unlikely(cmsg_hdr->version != NFP_FLOWER_CMSG_VER1)) {\n\t\tnfp_flower_cmsg_warn(app, \"Cannot handle repr control version %u\\n\",\n\t\t\t\t     cmsg_hdr->version);\n\t\tdev_kfree_skb_any(skb);\n\t\treturn;\n\t}\n\n\tif (cmsg_hdr->type == NFP_FLOWER_CMSG_TYPE_FLOW_STATS) {\n\t\t \n\t\tnfp_flower_rx_flow_stats(app, skb);\n\t\tdev_consume_skb_any(skb);\n\t} else if (cmsg_hdr->type == NFP_FLOWER_CMSG_TYPE_PORT_MOD &&\n\t\t   nfp_flower_process_mtu_ack(app, skb)) {\n\t\t \n\t\tdev_consume_skb_any(skb);\n\t} else if (cmsg_hdr->type == NFP_FLOWER_CMSG_TYPE_TUN_NEIGH ||\n\t\t   cmsg_hdr->type == NFP_FLOWER_CMSG_TYPE_TUN_NEIGH_V6) {\n\t\t \n\t\tdev_consume_skb_any(skb);\n\t} else if (cmsg_hdr->type == NFP_FLOWER_CMSG_TYPE_PORT_REIFY) {\n\t\t \n\t\tnfp_flower_cmsg_portreify_rx(app, skb);\n\t\tdev_consume_skb_any(skb);\n\t} else {\n\t\tnfp_flower_queue_ctl_msg(app, skb, cmsg_hdr->type);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}