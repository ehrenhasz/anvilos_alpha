{
  "module_name": "conntrack.h",
  "hash_id": "26609f2feed5ebfd813f8d470e6867fd9347359111d31cadc01f45b4216d5c78",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/netronome/nfp/flower/conntrack.h",
  "human_readable_source": " \n \n\n#ifndef __NFP_FLOWER_CONNTRACK_H__\n#define __NFP_FLOWER_CONNTRACK_H__ 1\n\n#include <net/netfilter/nf_flow_table.h>\n#include \"main.h\"\n\n#define NFP_FL_CT_NO_TUN\t0xff\n\n#define COMPARE_UNMASKED_FIELDS(__match1, __match2, __out)\t\\\n\tdo {\t\t\t\t\t\t\t\\\n\t\ttypeof(__match1) _match1 = (__match1);\t\t\\\n\t\ttypeof(__match2) _match2 = (__match2);\t\t\\\n\t\tbool *_out = (__out);\t\t\\\n\t\tint i, size = sizeof(*(_match1).key);\t\t\\\n\t\tchar *k1, *m1, *k2, *m2;\t\t\t\\\n\t\t*_out = false;\t\t\t\t\t\\\n\t\tk1 = (char *)_match1.key;\t\t\t\\\n\t\tm1 = (char *)_match1.mask;\t\t\t\\\n\t\tk2 = (char *)_match2.key;\t\t\t\\\n\t\tm2 = (char *)_match2.mask;\t\t\t\\\n\t\tfor (i = 0; i < size; i++)\t\t\t\\\n\t\t\tif ((k1[i] & m1[i] & m2[i]) ^\t\t\\\n\t\t\t    (k2[i] & m1[i] & m2[i])) {\t\t\\\n\t\t\t\t*_out = true;\t\t\t\\\n\t\t\t\tbreak;\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\\\n\t} while (0)\t\t\t\t\t\t\\\n\nextern const struct rhashtable_params nfp_zone_table_params;\nextern const struct rhashtable_params nfp_ct_map_params;\nextern const struct rhashtable_params nfp_tc_ct_merge_params;\nextern const struct rhashtable_params nfp_nft_ct_merge_params;\n\n \nstruct nfp_fl_ct_zone_entry {\n\tu16 zone;\n\tstruct rhash_head hash_node;\n\n\tstruct nfp_flower_priv *priv;\n\tstruct nf_flowtable *nft;\n\n\tstruct list_head pre_ct_list;\n\tunsigned int pre_ct_count;\n\n\tstruct list_head post_ct_list;\n\tunsigned int post_ct_count;\n\n\tstruct rhashtable tc_merge_tb;\n\tunsigned int tc_merge_count;\n\n\tstruct list_head nft_flows_list;\n\tunsigned int nft_flows_count;\n\n\tstruct rhashtable nft_merge_tb;\n\tunsigned int nft_merge_count;\n};\n\nenum ct_entry_type {\n\tCT_TYPE_PRE_CT,\n\tCT_TYPE_NFT,\n\tCT_TYPE_POST_CT,\n\t_CT_TYPE_MAX,\n};\n\n#define NFP_MAX_RECIRC_CT_ZONES 4\n#define NFP_MAX_ENTRY_RULES  (NFP_MAX_RECIRC_CT_ZONES * 2 + 1)\n\nenum nfp_nfp_layer_name {\n\tFLOW_PAY_META_TCI =    0,\n\tFLOW_PAY_INPORT,\n\tFLOW_PAY_EXT_META,\n\tFLOW_PAY_MAC_MPLS,\n\tFLOW_PAY_L4,\n\tFLOW_PAY_IPV4,\n\tFLOW_PAY_IPV6,\n\tFLOW_PAY_CT,\n\tFLOW_PAY_GRE,\n\tFLOW_PAY_QINQ,\n\tFLOW_PAY_UDP_TUN,\n\tFLOW_PAY_GENEVE_OPT,\n\n\t_FLOW_PAY_LAYERS_MAX\n};\n\n \n#define NFP_FL_ACTION_DO_NAT\t\tBIT(0)\n#define NFP_FL_ACTION_DO_MANGLE\t\tBIT(1)\n\n \nstruct nfp_fl_ct_flow_entry {\n\tunsigned long cookie;\n\tstruct list_head list_node;\n\tu32 chain_index;\n\tu32 goto_chain_index;\n\tstruct net_device *netdev;\n\tstruct nfp_fl_ct_zone_entry *zt;\n\tstruct list_head children;\n\tstruct flow_rule *rule;\n\tstruct flow_stats stats;\n\tstruct nfp_fl_nft_tc_merge *prev_m_entries[NFP_MAX_RECIRC_CT_ZONES - 1];\n\tu8 num_prev_m_entries;\n\tu8 tun_offset;\t\t\n\tu8 flags;\n\tu8 type;\n};\n\n \nstruct nfp_fl_ct_tc_merge {\n\tunsigned long cookie[2];\n\tstruct rhash_head hash_node;\n\tstruct list_head pre_ct_list;\n\tstruct list_head post_ct_list;\n\tstruct nfp_fl_ct_zone_entry *zt;\n\tstruct nfp_fl_ct_flow_entry *pre_ct_parent;\n\tstruct nfp_fl_ct_flow_entry *post_ct_parent;\n\tstruct list_head children;\n};\n\n \nstruct nfp_fl_nft_tc_merge {\n\tstruct net_device *netdev;\n\tunsigned long cookie[3];\n\tstruct rhash_head hash_node;\n\tstruct nfp_fl_ct_zone_entry *zt;\n\tstruct list_head nft_flow_list;\n\tstruct list_head tc_merge_list;\n\tstruct nfp_fl_ct_tc_merge *tc_m_parent;\n\tstruct nfp_fl_ct_flow_entry *nft_parent;\n\tunsigned long tc_flower_cookie;\n\tstruct nfp_fl_payload *flow_pay;\n\tstruct nfp_fl_ct_flow_entry *next_pre_ct_entry;\n};\n\n \nstruct nfp_fl_ct_map_entry {\n\tunsigned long cookie;\n\tstruct rhash_head hash_node;\n\tstruct nfp_fl_ct_flow_entry *ct_entry;\n};\n\nbool is_pre_ct_flow(struct flow_cls_offload *flow);\nbool is_post_ct_flow(struct flow_cls_offload *flow);\n\n \nint nfp_fl_ct_handle_pre_ct(struct nfp_flower_priv *priv,\n\t\t\t    struct net_device *netdev,\n\t\t\t    struct flow_cls_offload *flow,\n\t\t\t    struct netlink_ext_ack *extack,\n\t\t\t    struct nfp_fl_nft_tc_merge *m_entry);\n \nint nfp_fl_ct_handle_post_ct(struct nfp_flower_priv *priv,\n\t\t\t     struct net_device *netdev,\n\t\t\t     struct flow_cls_offload *flow,\n\t\t\t     struct netlink_ext_ack *extack);\n\n \nint nfp_fl_create_new_pre_ct(struct nfp_fl_nft_tc_merge *m_entry);\n\n \nvoid nfp_fl_ct_clean_flow_entry(struct nfp_fl_ct_flow_entry *entry);\n\n \nint nfp_fl_ct_del_flow(struct nfp_fl_ct_map_entry *ct_map_ent);\n\n \nint nfp_fl_ct_handle_nft_flow(enum tc_setup_type type, void *type_data,\n\t\t\t      void *cb_priv);\n\n \nint nfp_fl_ct_stats(struct flow_cls_offload *flow,\n\t\t    struct nfp_fl_ct_map_entry *ct_map_ent);\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}