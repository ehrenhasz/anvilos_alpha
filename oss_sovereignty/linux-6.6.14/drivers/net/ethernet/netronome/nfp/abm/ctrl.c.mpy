{
  "module_name": "ctrl.c",
  "hash_id": "c1ef44765e4ef8a8e6de5fa1dc5ccb3656393ccf2f57e53b2af1a5d7a5467446",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/netronome/nfp/abm/ctrl.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/kernel.h>\n#include <linux/log2.h>\n\n#include \"../nfpcore/nfp_cpp.h\"\n#include \"../nfpcore/nfp_nffw.h\"\n#include \"../nfp_app.h\"\n#include \"../nfp_abi.h\"\n#include \"../nfp_main.h\"\n#include \"../nfp_net.h\"\n#include \"main.h\"\n\n#define NFP_NUM_PRIOS_SYM_NAME\t\"_abi_pci_dscp_num_prio_%u\"\n#define NFP_NUM_BANDS_SYM_NAME\t\"_abi_pci_dscp_num_band_%u\"\n#define NFP_ACT_MASK_SYM_NAME\t\"_abi_nfd_out_q_actions_%u\"\n\n#define NFP_RED_SUPPORT_SYM_NAME\t\"_abi_nfd_out_red_offload_%u\"\n\n#define NFP_QLVL_SYM_NAME\t\"_abi_nfd_out_q_lvls_%u%s\"\n#define NFP_QLVL_STRIDE\t\t16\n#define NFP_QLVL_BLOG_BYTES\t0\n#define NFP_QLVL_BLOG_PKTS\t4\n#define NFP_QLVL_THRS\t\t8\n#define NFP_QLVL_ACT\t\t12\n\n#define NFP_QMSTAT_SYM_NAME\t\"_abi_nfdqm%u_stats%s\"\n#define NFP_QMSTAT_STRIDE\t32\n#define NFP_QMSTAT_NON_STO\t0\n#define NFP_QMSTAT_STO\t\t8\n#define NFP_QMSTAT_DROP\t\t16\n#define NFP_QMSTAT_ECN\t\t24\n\n#define NFP_Q_STAT_SYM_NAME\t\"_abi_nfd_rxq_stats%u%s\"\n#define NFP_Q_STAT_STRIDE\t16\n#define NFP_Q_STAT_PKTS\t\t0\n#define NFP_Q_STAT_BYTES\t8\n\n#define NFP_NET_ABM_MBOX_CMD\t\tNFP_NET_CFG_MBOX_SIMPLE_CMD\n#define NFP_NET_ABM_MBOX_RET\t\tNFP_NET_CFG_MBOX_SIMPLE_RET\n#define NFP_NET_ABM_MBOX_DATALEN\tNFP_NET_CFG_MBOX_SIMPLE_VAL\n#define NFP_NET_ABM_MBOX_RESERVED\t(NFP_NET_CFG_MBOX_SIMPLE_VAL + 4)\n#define NFP_NET_ABM_MBOX_DATA\t\t(NFP_NET_CFG_MBOX_SIMPLE_VAL + 8)\n\nstatic int\nnfp_abm_ctrl_stat(struct nfp_abm_link *alink, const struct nfp_rtsym *sym,\n\t\t  unsigned int stride, unsigned int offset, unsigned int band,\n\t\t  unsigned int queue, bool is_u64, u64 *res)\n{\n\tstruct nfp_cpp *cpp = alink->abm->app->cpp;\n\tu64 val, sym_offset;\n\tunsigned int qid;\n\tu32 val32;\n\tint err;\n\n\tqid = band * NFP_NET_MAX_RX_RINGS + alink->queue_base + queue;\n\n\tsym_offset = qid * stride + offset;\n\tif (is_u64)\n\t\terr = __nfp_rtsym_readq(cpp, sym, 3, 0, sym_offset, &val);\n\telse\n\t\terr = __nfp_rtsym_readl(cpp, sym, 3, 0, sym_offset, &val32);\n\tif (err) {\n\t\tnfp_err(cpp, \"RED offload reading stat failed on vNIC %d band %d queue %d (+ %d)\\n\",\n\t\t\talink->id, band, queue, alink->queue_base);\n\t\treturn err;\n\t}\n\n\t*res = is_u64 ? val : val32;\n\treturn 0;\n}\n\nint __nfp_abm_ctrl_set_q_lvl(struct nfp_abm *abm, unsigned int id, u32 val)\n{\n\tstruct nfp_cpp *cpp = abm->app->cpp;\n\tu64 sym_offset;\n\tint err;\n\n\t__clear_bit(id, abm->threshold_undef);\n\tif (abm->thresholds[id] == val)\n\t\treturn 0;\n\n\tsym_offset = id * NFP_QLVL_STRIDE + NFP_QLVL_THRS;\n\terr = __nfp_rtsym_writel(cpp, abm->q_lvls, 4, 0, sym_offset, val);\n\tif (err) {\n\t\tnfp_err(cpp,\n\t\t\t\"RED offload setting level failed on subqueue %d\\n\",\n\t\t\tid);\n\t\treturn err;\n\t}\n\n\tabm->thresholds[id] = val;\n\treturn 0;\n}\n\nint nfp_abm_ctrl_set_q_lvl(struct nfp_abm_link *alink, unsigned int band,\n\t\t\t   unsigned int queue, u32 val)\n{\n\tunsigned int threshold;\n\n\tthreshold = band * NFP_NET_MAX_RX_RINGS + alink->queue_base + queue;\n\n\treturn __nfp_abm_ctrl_set_q_lvl(alink->abm, threshold, val);\n}\n\nint __nfp_abm_ctrl_set_q_act(struct nfp_abm *abm, unsigned int id,\n\t\t\t     enum nfp_abm_q_action act)\n{\n\tstruct nfp_cpp *cpp = abm->app->cpp;\n\tu64 sym_offset;\n\tint err;\n\n\tif (abm->actions[id] == act)\n\t\treturn 0;\n\n\tsym_offset = id * NFP_QLVL_STRIDE + NFP_QLVL_ACT;\n\terr = __nfp_rtsym_writel(cpp, abm->q_lvls, 4, 0, sym_offset, act);\n\tif (err) {\n\t\tnfp_err(cpp,\n\t\t\t\"RED offload setting action failed on subqueue %d\\n\",\n\t\t\tid);\n\t\treturn err;\n\t}\n\n\tabm->actions[id] = act;\n\treturn 0;\n}\n\nint nfp_abm_ctrl_set_q_act(struct nfp_abm_link *alink, unsigned int band,\n\t\t\t   unsigned int queue, enum nfp_abm_q_action act)\n{\n\tunsigned int qid;\n\n\tqid = band * NFP_NET_MAX_RX_RINGS + alink->queue_base + queue;\n\n\treturn __nfp_abm_ctrl_set_q_act(alink->abm, qid, act);\n}\n\nu64 nfp_abm_ctrl_stat_non_sto(struct nfp_abm_link *alink, unsigned int queue)\n{\n\tunsigned int band;\n\tu64 val, sum = 0;\n\n\tfor (band = 0; band < alink->abm->num_bands; band++) {\n\t\tif (nfp_abm_ctrl_stat(alink, alink->abm->qm_stats,\n\t\t\t\t      NFP_QMSTAT_STRIDE, NFP_QMSTAT_NON_STO,\n\t\t\t\t      band, queue, true, &val))\n\t\t\treturn 0;\n\t\tsum += val;\n\t}\n\n\treturn sum;\n}\n\nu64 nfp_abm_ctrl_stat_sto(struct nfp_abm_link *alink, unsigned int queue)\n{\n\tunsigned int band;\n\tu64 val, sum = 0;\n\n\tfor (band = 0; band < alink->abm->num_bands; band++) {\n\t\tif (nfp_abm_ctrl_stat(alink, alink->abm->qm_stats,\n\t\t\t\t      NFP_QMSTAT_STRIDE, NFP_QMSTAT_STO,\n\t\t\t\t      band, queue, true, &val))\n\t\t\treturn 0;\n\t\tsum += val;\n\t}\n\n\treturn sum;\n}\n\nstatic int\nnfp_abm_ctrl_stat_basic(struct nfp_abm_link *alink, unsigned int band,\n\t\t\tunsigned int queue, unsigned int off, u64 *val)\n{\n\tif (!nfp_abm_has_prio(alink->abm)) {\n\t\tif (!band) {\n\t\t\tunsigned int id = alink->queue_base + queue;\n\n\t\t\t*val = nn_readq(alink->vnic,\n\t\t\t\t\tNFP_NET_CFG_RXR_STATS(id) + off);\n\t\t} else {\n\t\t\t*val = 0;\n\t\t}\n\n\t\treturn 0;\n\t} else {\n\t\treturn nfp_abm_ctrl_stat(alink, alink->abm->q_stats,\n\t\t\t\t\t NFP_Q_STAT_STRIDE, off, band, queue,\n\t\t\t\t\t true, val);\n\t}\n}\n\nint nfp_abm_ctrl_read_q_stats(struct nfp_abm_link *alink, unsigned int band,\n\t\t\t      unsigned int queue, struct nfp_alink_stats *stats)\n{\n\tint err;\n\n\terr = nfp_abm_ctrl_stat_basic(alink, band, queue, NFP_Q_STAT_PKTS,\n\t\t\t\t      &stats->tx_pkts);\n\tif (err)\n\t\treturn err;\n\n\terr = nfp_abm_ctrl_stat_basic(alink, band, queue, NFP_Q_STAT_BYTES,\n\t\t\t\t      &stats->tx_bytes);\n\tif (err)\n\t\treturn err;\n\n\terr = nfp_abm_ctrl_stat(alink, alink->abm->q_lvls, NFP_QLVL_STRIDE,\n\t\t\t\tNFP_QLVL_BLOG_BYTES, band, queue, false,\n\t\t\t\t&stats->backlog_bytes);\n\tif (err)\n\t\treturn err;\n\n\terr = nfp_abm_ctrl_stat(alink, alink->abm->q_lvls,\n\t\t\t\tNFP_QLVL_STRIDE, NFP_QLVL_BLOG_PKTS,\n\t\t\t\tband, queue, false, &stats->backlog_pkts);\n\tif (err)\n\t\treturn err;\n\n\terr = nfp_abm_ctrl_stat(alink, alink->abm->qm_stats,\n\t\t\t\tNFP_QMSTAT_STRIDE, NFP_QMSTAT_DROP,\n\t\t\t\tband, queue, true, &stats->drops);\n\tif (err)\n\t\treturn err;\n\n\treturn nfp_abm_ctrl_stat(alink, alink->abm->qm_stats,\n\t\t\t\t NFP_QMSTAT_STRIDE, NFP_QMSTAT_ECN,\n\t\t\t\t band, queue, true, &stats->overlimits);\n}\n\nint nfp_abm_ctrl_read_q_xstats(struct nfp_abm_link *alink,\n\t\t\t       unsigned int band, unsigned int queue,\n\t\t\t       struct nfp_alink_xstats *xstats)\n{\n\tint err;\n\n\terr = nfp_abm_ctrl_stat(alink, alink->abm->qm_stats,\n\t\t\t\tNFP_QMSTAT_STRIDE, NFP_QMSTAT_DROP,\n\t\t\t\tband, queue, true, &xstats->pdrop);\n\tif (err)\n\t\treturn err;\n\n\treturn nfp_abm_ctrl_stat(alink, alink->abm->qm_stats,\n\t\t\t\t NFP_QMSTAT_STRIDE, NFP_QMSTAT_ECN,\n\t\t\t\t band, queue, true, &xstats->ecn_marked);\n}\n\nint nfp_abm_ctrl_qm_enable(struct nfp_abm *abm)\n{\n\treturn nfp_mbox_cmd(abm->app->pf, NFP_MBOX_PCIE_ABM_ENABLE,\n\t\t\t    NULL, 0, NULL, 0);\n}\n\nint nfp_abm_ctrl_qm_disable(struct nfp_abm *abm)\n{\n\treturn nfp_mbox_cmd(abm->app->pf, NFP_MBOX_PCIE_ABM_DISABLE,\n\t\t\t    NULL, 0, NULL, 0);\n}\n\nint nfp_abm_ctrl_prio_map_update(struct nfp_abm_link *alink, u32 *packed)\n{\n\tconst u32 cmd = NFP_NET_CFG_MBOX_CMD_PCI_DSCP_PRIOMAP_SET;\n\tstruct nfp_net *nn = alink->vnic;\n\tunsigned int i;\n\tint err;\n\n\terr = nfp_net_mbox_lock(nn, alink->abm->prio_map_len);\n\tif (err)\n\t\treturn err;\n\n\t \n\tnn_writeq(nn, nn->tlv_caps.mbox_off + NFP_NET_ABM_MBOX_DATALEN,\n\t\t  alink->abm->prio_map_len);\n\n\tfor (i = 0; i < alink->abm->prio_map_len; i += sizeof(u32))\n\t\tnn_writel(nn, nn->tlv_caps.mbox_off + NFP_NET_ABM_MBOX_DATA + i,\n\t\t\t  packed[i / sizeof(u32)]);\n\n\terr = nfp_net_mbox_reconfig_and_unlock(nn, cmd);\n\tif (err)\n\t\tnfp_err(alink->abm->app->cpp,\n\t\t\t\"setting DSCP -> VQ map failed with error %d\\n\", err);\n\treturn err;\n}\n\nstatic int nfp_abm_ctrl_prio_check_params(struct nfp_abm_link *alink)\n{\n\tstruct nfp_abm *abm = alink->abm;\n\tstruct nfp_net *nn = alink->vnic;\n\tunsigned int min_mbox_sz;\n\n\tif (!nfp_abm_has_prio(alink->abm))\n\t\treturn 0;\n\n\tmin_mbox_sz = NFP_NET_ABM_MBOX_DATA + alink->abm->prio_map_len;\n\tif (nn->tlv_caps.mbox_len < min_mbox_sz) {\n\t\tnfp_err(abm->app->pf->cpp, \"vNIC mailbox too small for prio offload: %u, need: %u\\n\",\n\t\t\tnn->tlv_caps.mbox_len,  min_mbox_sz);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nint nfp_abm_ctrl_read_params(struct nfp_abm_link *alink)\n{\n\talink->queue_base = nn_readl(alink->vnic, NFP_NET_CFG_START_RXQ);\n\talink->queue_base /= alink->vnic->stride_rx;\n\n\treturn nfp_abm_ctrl_prio_check_params(alink);\n}\n\nstatic unsigned int nfp_abm_ctrl_prio_map_size(struct nfp_abm *abm)\n{\n\tunsigned int size;\n\n\tsize = roundup_pow_of_two(order_base_2(abm->num_bands));\n\tsize = DIV_ROUND_UP(size * abm->num_prios, BITS_PER_BYTE);\n\tsize = round_up(size, sizeof(u32));\n\n\treturn size;\n}\n\nstatic const struct nfp_rtsym *\nnfp_abm_ctrl_find_rtsym(struct nfp_pf *pf, const char *name, unsigned int size)\n{\n\tconst struct nfp_rtsym *sym;\n\n\tsym = nfp_rtsym_lookup(pf->rtbl, name);\n\tif (!sym) {\n\t\tnfp_err(pf->cpp, \"Symbol '%s' not found\\n\", name);\n\t\treturn ERR_PTR(-ENOENT);\n\t}\n\tif (nfp_rtsym_size(sym) != size) {\n\t\tnfp_err(pf->cpp,\n\t\t\t\"Symbol '%s' wrong size: expected %u got %llu\\n\",\n\t\t\tname, size, nfp_rtsym_size(sym));\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn sym;\n}\n\nstatic const struct nfp_rtsym *\nnfp_abm_ctrl_find_q_rtsym(struct nfp_abm *abm, const char *name_fmt,\n\t\t\t  size_t size)\n{\n\tchar pf_symbol[64];\n\n\tsize = array3_size(size, abm->num_bands, NFP_NET_MAX_RX_RINGS);\n\tsnprintf(pf_symbol, sizeof(pf_symbol), name_fmt,\n\t\t abm->pf_id, nfp_abm_has_prio(abm) ? \"_per_band\" : \"\");\n\n\treturn nfp_abm_ctrl_find_rtsym(abm->app->pf, pf_symbol, size);\n}\n\nint nfp_abm_ctrl_find_addrs(struct nfp_abm *abm)\n{\n\tstruct nfp_pf *pf = abm->app->pf;\n\tconst struct nfp_rtsym *sym;\n\tint res;\n\n\tabm->pf_id = nfp_cppcore_pcie_unit(pf->cpp);\n\n\t \n\tres = nfp_pf_rtsym_read_optional(pf, NFP_RED_SUPPORT_SYM_NAME, 1);\n\tif (res < 0)\n\t\treturn res;\n\tabm->red_support = res;\n\n\t \n\tres = nfp_pf_rtsym_read_optional(pf, NFP_NUM_BANDS_SYM_NAME, 1);\n\tif (res < 0)\n\t\treturn res;\n\tabm->num_bands = res;\n\n\tres = nfp_pf_rtsym_read_optional(pf, NFP_NUM_PRIOS_SYM_NAME, 1);\n\tif (res < 0)\n\t\treturn res;\n\tabm->num_prios = res;\n\n\t \n\tres = nfp_pf_rtsym_read_optional(pf, NFP_ACT_MASK_SYM_NAME,\n\t\t\t\t\t BIT(NFP_ABM_ACT_MARK_DROP));\n\tif (res < 0)\n\t\treturn res;\n\tabm->action_mask = res;\n\n\tabm->prio_map_len = nfp_abm_ctrl_prio_map_size(abm);\n\tabm->dscp_mask = GENMASK(7, 8 - order_base_2(abm->num_prios));\n\n\t \n\tif (!is_power_of_2(abm->num_bands) || !is_power_of_2(abm->num_prios) ||\n\t    abm->num_bands > U16_MAX || abm->num_prios > U16_MAX ||\n\t    (abm->num_bands == 1) != (abm->num_prios == 1)) {\n\t\tnfp_err(pf->cpp,\n\t\t\t\"invalid priomap description num bands: %u and num prios: %u\\n\",\n\t\t\tabm->num_bands, abm->num_prios);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (!abm->red_support)\n\t\treturn 0;\n\n\tsym = nfp_abm_ctrl_find_q_rtsym(abm, NFP_QLVL_SYM_NAME,\n\t\t\t\t\tNFP_QLVL_STRIDE);\n\tif (IS_ERR(sym))\n\t\treturn PTR_ERR(sym);\n\tabm->q_lvls = sym;\n\n\tsym = nfp_abm_ctrl_find_q_rtsym(abm, NFP_QMSTAT_SYM_NAME,\n\t\t\t\t\tNFP_QMSTAT_STRIDE);\n\tif (IS_ERR(sym))\n\t\treturn PTR_ERR(sym);\n\tabm->qm_stats = sym;\n\n\tif (nfp_abm_has_prio(abm)) {\n\t\tsym = nfp_abm_ctrl_find_q_rtsym(abm, NFP_Q_STAT_SYM_NAME,\n\t\t\t\t\t\tNFP_Q_STAT_STRIDE);\n\t\tif (IS_ERR(sym))\n\t\t\treturn PTR_ERR(sym);\n\t\tabm->q_stats = sym;\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}