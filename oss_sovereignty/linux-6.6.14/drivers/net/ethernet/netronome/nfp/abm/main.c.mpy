{
  "module_name": "main.c",
  "hash_id": "45e7c470c3c2884702f759de240fb1f320ef894f7c1dbbf90b43d29a1ca7e7df",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/netronome/nfp/abm/main.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/bitmap.h>\n#include <linux/etherdevice.h>\n#include <linux/lockdep.h>\n#include <linux/netdevice.h>\n#include <linux/rcupdate.h>\n#include <linux/rtnetlink.h>\n#include <linux/slab.h>\n\n#include \"../nfpcore/nfp.h\"\n#include \"../nfpcore/nfp_cpp.h\"\n#include \"../nfpcore/nfp_nsp.h\"\n#include \"../nfp_app.h\"\n#include \"../nfp_main.h\"\n#include \"../nfp_net.h\"\n#include \"../nfp_net_repr.h\"\n#include \"../nfp_port.h\"\n#include \"main.h\"\n\nstatic u32 nfp_abm_portid(enum nfp_repr_type rtype, unsigned int id)\n{\n\treturn FIELD_PREP(NFP_ABM_PORTID_TYPE, rtype) |\n\t       FIELD_PREP(NFP_ABM_PORTID_ID, id);\n}\n\nstatic int\nnfp_abm_setup_tc(struct nfp_app *app, struct net_device *netdev,\n\t\t enum tc_setup_type type, void *type_data)\n{\n\tstruct nfp_repr *repr = netdev_priv(netdev);\n\tstruct nfp_port *port;\n\n\tport = nfp_port_from_netdev(netdev);\n\tif (!port || port->type != NFP_PORT_PF_PORT)\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (type) {\n\tcase TC_SETUP_ROOT_QDISC:\n\t\treturn nfp_abm_setup_root(netdev, repr->app_priv, type_data);\n\tcase TC_SETUP_QDISC_MQ:\n\t\treturn nfp_abm_setup_tc_mq(netdev, repr->app_priv, type_data);\n\tcase TC_SETUP_QDISC_RED:\n\t\treturn nfp_abm_setup_tc_red(netdev, repr->app_priv, type_data);\n\tcase TC_SETUP_QDISC_GRED:\n\t\treturn nfp_abm_setup_tc_gred(netdev, repr->app_priv, type_data);\n\tcase TC_SETUP_BLOCK:\n\t\treturn nfp_abm_setup_cls_block(netdev, repr, type_data);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic struct net_device *\nnfp_abm_repr_get(struct nfp_app *app, u32 port_id, bool *redir_egress)\n{\n\tenum nfp_repr_type rtype;\n\tstruct nfp_reprs *reprs;\n\tu8 port;\n\n\trtype = FIELD_GET(NFP_ABM_PORTID_TYPE, port_id);\n\tport = FIELD_GET(NFP_ABM_PORTID_ID, port_id);\n\n\treprs = rcu_dereference(app->reprs[rtype]);\n\tif (!reprs)\n\t\treturn NULL;\n\n\tif (port >= reprs->num_reprs)\n\t\treturn NULL;\n\n\treturn rcu_dereference(reprs->reprs[port]);\n}\n\nstatic int\nnfp_abm_spawn_repr(struct nfp_app *app, struct nfp_abm_link *alink,\n\t\t   enum nfp_port_type ptype)\n{\n\tstruct net_device *netdev;\n\tenum nfp_repr_type rtype;\n\tstruct nfp_reprs *reprs;\n\tstruct nfp_repr *repr;\n\tstruct nfp_port *port;\n\tunsigned int txqs;\n\tint err;\n\n\tif (ptype == NFP_PORT_PHYS_PORT) {\n\t\trtype = NFP_REPR_TYPE_PHYS_PORT;\n\t\ttxqs = 1;\n\t} else {\n\t\trtype = NFP_REPR_TYPE_PF;\n\t\ttxqs = alink->vnic->max_rx_rings;\n\t}\n\n\tnetdev = nfp_repr_alloc_mqs(app, txqs, 1);\n\tif (!netdev)\n\t\treturn -ENOMEM;\n\trepr = netdev_priv(netdev);\n\trepr->app_priv = alink;\n\n\tport = nfp_port_alloc(app, ptype, netdev);\n\tif (IS_ERR(port)) {\n\t\terr = PTR_ERR(port);\n\t\tgoto err_free_repr;\n\t}\n\n\tif (ptype == NFP_PORT_PHYS_PORT) {\n\t\tport->eth_forced = true;\n\t\terr = nfp_port_init_phy_port(app->pf, app, port, alink->id);\n\t\tif (err)\n\t\t\tgoto err_free_port;\n\t} else {\n\t\tport->pf_id = alink->abm->pf_id;\n\t\tport->pf_split = app->pf->max_data_vnics > 1;\n\t\tport->pf_split_id = alink->id;\n\t\tport->vnic = alink->vnic->dp.ctrl_bar;\n\t}\n\n\tSET_NETDEV_DEV(netdev, &alink->vnic->pdev->dev);\n\teth_hw_addr_random(netdev);\n\n\terr = nfp_repr_init(app, netdev, nfp_abm_portid(rtype, alink->id),\n\t\t\t    port, alink->vnic->dp.netdev);\n\tif (err)\n\t\tgoto err_free_port;\n\n\treprs = nfp_reprs_get_locked(app, rtype);\n\tWARN(nfp_repr_get_locked(app, reprs, alink->id), \"duplicate repr\");\n\trtnl_lock();\n\trcu_assign_pointer(reprs->reprs[alink->id], netdev);\n\trtnl_unlock();\n\n\tnfp_info(app->cpp, \"%s Port %d Representor(%s) created\\n\",\n\t\t ptype == NFP_PORT_PF_PORT ? \"PCIe\" : \"Phys\",\n\t\t alink->id, netdev->name);\n\n\treturn 0;\n\nerr_free_port:\n\tnfp_port_free(port);\nerr_free_repr:\n\tnfp_repr_free(netdev);\n\treturn err;\n}\n\nstatic void\nnfp_abm_kill_repr(struct nfp_app *app, struct nfp_abm_link *alink,\n\t\t  enum nfp_repr_type rtype)\n{\n\tstruct net_device *netdev;\n\tstruct nfp_reprs *reprs;\n\n\treprs = nfp_reprs_get_locked(app, rtype);\n\tnetdev = nfp_repr_get_locked(app, reprs, alink->id);\n\tif (!netdev)\n\t\treturn;\n\trtnl_lock();\n\trcu_assign_pointer(reprs->reprs[alink->id], NULL);\n\trtnl_unlock();\n\tsynchronize_rcu();\n\t \n\tnfp_repr_clean_and_free((struct nfp_repr *)netdev_priv(netdev));\n}\n\nstatic void\nnfp_abm_kill_reprs(struct nfp_abm *abm, struct nfp_abm_link *alink)\n{\n\tnfp_abm_kill_repr(abm->app, alink, NFP_REPR_TYPE_PF);\n\tnfp_abm_kill_repr(abm->app, alink, NFP_REPR_TYPE_PHYS_PORT);\n}\n\nstatic void nfp_abm_kill_reprs_all(struct nfp_abm *abm)\n{\n\tstruct nfp_pf *pf = abm->app->pf;\n\tstruct nfp_net *nn;\n\n\tlist_for_each_entry(nn, &pf->vnics, vnic_list)\n\t\tnfp_abm_kill_reprs(abm, (struct nfp_abm_link *)nn->app_priv);\n}\n\nstatic enum devlink_eswitch_mode nfp_abm_eswitch_mode_get(struct nfp_app *app)\n{\n\tstruct nfp_abm *abm = app->priv;\n\n\treturn abm->eswitch_mode;\n}\n\nstatic int nfp_abm_eswitch_set_legacy(struct nfp_abm *abm)\n{\n\tnfp_abm_kill_reprs_all(abm);\n\tnfp_abm_ctrl_qm_disable(abm);\n\n\tabm->eswitch_mode = DEVLINK_ESWITCH_MODE_LEGACY;\n\treturn 0;\n}\n\nstatic void nfp_abm_eswitch_clean_up(struct nfp_abm *abm)\n{\n\tif (abm->eswitch_mode != DEVLINK_ESWITCH_MODE_LEGACY)\n\t\tWARN_ON(nfp_abm_eswitch_set_legacy(abm));\n}\n\nstatic int nfp_abm_eswitch_set_switchdev(struct nfp_abm *abm)\n{\n\tstruct nfp_app *app = abm->app;\n\tstruct nfp_pf *pf = app->pf;\n\tstruct nfp_net *nn;\n\tint err;\n\n\tif (!abm->red_support)\n\t\treturn -EOPNOTSUPP;\n\n\terr = nfp_abm_ctrl_qm_enable(abm);\n\tif (err)\n\t\treturn err;\n\n\tlist_for_each_entry(nn, &pf->vnics, vnic_list) {\n\t\tstruct nfp_abm_link *alink = nn->app_priv;\n\n\t\terr = nfp_abm_spawn_repr(app, alink, NFP_PORT_PHYS_PORT);\n\t\tif (err)\n\t\t\tgoto err_kill_all_reprs;\n\n\t\terr = nfp_abm_spawn_repr(app, alink, NFP_PORT_PF_PORT);\n\t\tif (err)\n\t\t\tgoto err_kill_all_reprs;\n\t}\n\n\tabm->eswitch_mode = DEVLINK_ESWITCH_MODE_SWITCHDEV;\n\treturn 0;\n\nerr_kill_all_reprs:\n\tnfp_abm_kill_reprs_all(abm);\n\tnfp_abm_ctrl_qm_disable(abm);\n\treturn err;\n}\n\nstatic int nfp_abm_eswitch_mode_set(struct nfp_app *app, u16 mode)\n{\n\tstruct nfp_abm *abm = app->priv;\n\n\tif (abm->eswitch_mode == mode)\n\t\treturn 0;\n\n\tswitch (mode) {\n\tcase DEVLINK_ESWITCH_MODE_LEGACY:\n\t\treturn nfp_abm_eswitch_set_legacy(abm);\n\tcase DEVLINK_ESWITCH_MODE_SWITCHDEV:\n\t\treturn nfp_abm_eswitch_set_switchdev(abm);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic void\nnfp_abm_vnic_set_mac(struct nfp_pf *pf, struct nfp_abm *abm, struct nfp_net *nn,\n\t\t     unsigned int id)\n{\n\tstruct nfp_eth_table_port *eth_port = &pf->eth_tbl->ports[id];\n\tu8 mac_addr[ETH_ALEN];\n\tstruct nfp_nsp *nsp;\n\tchar hwinfo[32];\n\tint err;\n\n\tif (id > pf->eth_tbl->count) {\n\t\tnfp_warn(pf->cpp, \"No entry for persistent MAC address\\n\");\n\t\teth_hw_addr_random(nn->dp.netdev);\n\t\treturn;\n\t}\n\n\tsnprintf(hwinfo, sizeof(hwinfo), \"eth%u.mac.pf%u\",\n\t\t eth_port->eth_index, abm->pf_id);\n\n\tnsp = nfp_nsp_open(pf->cpp);\n\tif (IS_ERR(nsp)) {\n\t\tnfp_warn(pf->cpp, \"Failed to access the NSP for persistent MAC address: %ld\\n\",\n\t\t\t PTR_ERR(nsp));\n\t\teth_hw_addr_random(nn->dp.netdev);\n\t\treturn;\n\t}\n\n\tif (!nfp_nsp_has_hwinfo_lookup(nsp)) {\n\t\tnfp_warn(pf->cpp, \"NSP doesn't support PF MAC generation\\n\");\n\t\teth_hw_addr_random(nn->dp.netdev);\n\t\tnfp_nsp_close(nsp);\n\t\treturn;\n\t}\n\n\terr = nfp_nsp_hwinfo_lookup(nsp, hwinfo, sizeof(hwinfo));\n\tnfp_nsp_close(nsp);\n\tif (err) {\n\t\tnfp_warn(pf->cpp, \"Reading persistent MAC address failed: %d\\n\",\n\t\t\t err);\n\t\teth_hw_addr_random(nn->dp.netdev);\n\t\treturn;\n\t}\n\n\tif (sscanf(hwinfo, \"%02hhx:%02hhx:%02hhx:%02hhx:%02hhx:%02hhx\",\n\t\t   &mac_addr[0], &mac_addr[1], &mac_addr[2],\n\t\t   &mac_addr[3], &mac_addr[4], &mac_addr[5]) != 6) {\n\t\tnfp_warn(pf->cpp, \"Can't parse persistent MAC address (%s)\\n\",\n\t\t\t hwinfo);\n\t\teth_hw_addr_random(nn->dp.netdev);\n\t\treturn;\n\t}\n\n\teth_hw_addr_set(nn->dp.netdev, mac_addr);\n\tether_addr_copy(nn->dp.netdev->perm_addr, mac_addr);\n}\n\nstatic int\nnfp_abm_vnic_alloc(struct nfp_app *app, struct nfp_net *nn, unsigned int id)\n{\n\tstruct nfp_eth_table_port *eth_port = &app->pf->eth_tbl->ports[id];\n\tstruct nfp_abm *abm = app->priv;\n\tstruct nfp_abm_link *alink;\n\tint err;\n\n\talink = kzalloc(sizeof(*alink), GFP_KERNEL);\n\tif (!alink)\n\t\treturn -ENOMEM;\n\tnn->app_priv = alink;\n\talink->abm = abm;\n\talink->vnic = nn;\n\talink->id = id;\n\talink->total_queues = alink->vnic->max_rx_rings;\n\n\tINIT_LIST_HEAD(&alink->dscp_map);\n\n\terr = nfp_abm_ctrl_read_params(alink);\n\tif (err)\n\t\tgoto err_free_alink;\n\n\talink->prio_map = kzalloc(abm->prio_map_len, GFP_KERNEL);\n\tif (!alink->prio_map) {\n\t\terr = -ENOMEM;\n\t\tgoto err_free_alink;\n\t}\n\n\t \n\terr = nfp_eth_set_configured(app->cpp, eth_port->index, true);\n\tif (err < 0)\n\t\tgoto err_free_priomap;\n\n\tnetif_keep_dst(nn->dp.netdev);\n\n\tnfp_abm_vnic_set_mac(app->pf, abm, nn, id);\n\tINIT_RADIX_TREE(&alink->qdiscs, GFP_KERNEL);\n\n\treturn 0;\n\nerr_free_priomap:\n\tkfree(alink->prio_map);\nerr_free_alink:\n\tkfree(alink);\n\treturn err;\n}\n\nstatic void nfp_abm_vnic_free(struct nfp_app *app, struct nfp_net *nn)\n{\n\tstruct nfp_abm_link *alink = nn->app_priv;\n\n\tnfp_abm_kill_reprs(alink->abm, alink);\n\tWARN(!radix_tree_empty(&alink->qdiscs), \"left over qdiscs\\n\");\n\tkfree(alink->prio_map);\n\tkfree(alink);\n}\n\nstatic int nfp_abm_vnic_init(struct nfp_app *app, struct nfp_net *nn)\n{\n\tstruct nfp_abm_link *alink = nn->app_priv;\n\n\tif (nfp_abm_has_prio(alink->abm))\n\t\treturn nfp_abm_ctrl_prio_map_update(alink, alink->prio_map);\n\treturn 0;\n}\n\nstatic u64 *\nnfp_abm_port_get_stats(struct nfp_app *app, struct nfp_port *port, u64 *data)\n{\n\tstruct nfp_repr *repr = netdev_priv(port->netdev);\n\tstruct nfp_abm_link *alink;\n\tunsigned int i;\n\n\tif (port->type != NFP_PORT_PF_PORT)\n\t\treturn data;\n\talink = repr->app_priv;\n\tfor (i = 0; i < alink->vnic->dp.num_r_vecs; i++) {\n\t\t*data++ = nfp_abm_ctrl_stat_non_sto(alink, i);\n\t\t*data++ = nfp_abm_ctrl_stat_sto(alink, i);\n\t}\n\treturn data;\n}\n\nstatic int\nnfp_abm_port_get_stats_count(struct nfp_app *app, struct nfp_port *port)\n{\n\tstruct nfp_repr *repr = netdev_priv(port->netdev);\n\tstruct nfp_abm_link *alink;\n\n\tif (port->type != NFP_PORT_PF_PORT)\n\t\treturn 0;\n\talink = repr->app_priv;\n\treturn alink->vnic->dp.num_r_vecs * 2;\n}\n\nstatic u8 *\nnfp_abm_port_get_stats_strings(struct nfp_app *app, struct nfp_port *port,\n\t\t\t       u8 *data)\n{\n\tstruct nfp_repr *repr = netdev_priv(port->netdev);\n\tstruct nfp_abm_link *alink;\n\tunsigned int i;\n\n\tif (port->type != NFP_PORT_PF_PORT)\n\t\treturn data;\n\talink = repr->app_priv;\n\tfor (i = 0; i < alink->vnic->dp.num_r_vecs; i++) {\n\t\tethtool_sprintf(&data, \"q%u_no_wait\", i);\n\t\tethtool_sprintf(&data, \"q%u_delayed\", i);\n\t}\n\treturn data;\n}\n\nstatic int nfp_abm_fw_init_reset(struct nfp_abm *abm)\n{\n\tunsigned int i;\n\n\tif (!abm->red_support)\n\t\treturn 0;\n\n\tfor (i = 0; i < abm->num_bands * NFP_NET_MAX_RX_RINGS; i++) {\n\t\t__nfp_abm_ctrl_set_q_lvl(abm, i, NFP_ABM_LVL_INFINITY);\n\t\t__nfp_abm_ctrl_set_q_act(abm, i, NFP_ABM_ACT_DROP);\n\t}\n\n\treturn nfp_abm_ctrl_qm_disable(abm);\n}\n\nstatic int nfp_abm_init(struct nfp_app *app)\n{\n\tstruct nfp_pf *pf = app->pf;\n\tstruct nfp_reprs *reprs;\n\tstruct nfp_abm *abm;\n\tint err;\n\n\tif (!pf->eth_tbl) {\n\t\tnfp_err(pf->cpp, \"ABM NIC requires ETH table\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (pf->max_data_vnics != pf->eth_tbl->count) {\n\t\tnfp_err(pf->cpp, \"ETH entries don't match vNICs (%d vs %d)\\n\",\n\t\t\tpf->max_data_vnics, pf->eth_tbl->count);\n\t\treturn -EINVAL;\n\t}\n\tif (!pf->mac_stats_bar) {\n\t\tnfp_warn(app->cpp, \"ABM NIC requires mac_stats symbol\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tabm = kzalloc(sizeof(*abm), GFP_KERNEL);\n\tif (!abm)\n\t\treturn -ENOMEM;\n\tapp->priv = abm;\n\tabm->app = app;\n\n\terr = nfp_abm_ctrl_find_addrs(abm);\n\tif (err)\n\t\tgoto err_free_abm;\n\n\terr = -ENOMEM;\n\tabm->num_thresholds = array_size(abm->num_bands, NFP_NET_MAX_RX_RINGS);\n\tabm->threshold_undef = bitmap_zalloc(abm->num_thresholds, GFP_KERNEL);\n\tif (!abm->threshold_undef)\n\t\tgoto err_free_abm;\n\n\tabm->thresholds = kvcalloc(abm->num_thresholds,\n\t\t\t\t   sizeof(*abm->thresholds), GFP_KERNEL);\n\tif (!abm->thresholds)\n\t\tgoto err_free_thresh_umap;\n\n\tabm->actions = kvcalloc(abm->num_thresholds, sizeof(*abm->actions),\n\t\t\t\tGFP_KERNEL);\n\tif (!abm->actions)\n\t\tgoto err_free_thresh;\n\n\t \n\terr = nfp_abm_fw_init_reset(abm);\n\tif (err)\n\t\tgoto err_free_act;\n\n\terr = -ENOMEM;\n\treprs = nfp_reprs_alloc(pf->max_data_vnics);\n\tif (!reprs)\n\t\tgoto err_free_act;\n\tRCU_INIT_POINTER(app->reprs[NFP_REPR_TYPE_PHYS_PORT], reprs);\n\n\treprs = nfp_reprs_alloc(pf->max_data_vnics);\n\tif (!reprs)\n\t\tgoto err_free_phys;\n\tRCU_INIT_POINTER(app->reprs[NFP_REPR_TYPE_PF], reprs);\n\n\treturn 0;\n\nerr_free_phys:\n\tnfp_reprs_clean_and_free_by_type(app, NFP_REPR_TYPE_PHYS_PORT);\nerr_free_act:\n\tkvfree(abm->actions);\nerr_free_thresh:\n\tkvfree(abm->thresholds);\nerr_free_thresh_umap:\n\tbitmap_free(abm->threshold_undef);\nerr_free_abm:\n\tkfree(abm);\n\tapp->priv = NULL;\n\treturn err;\n}\n\nstatic void nfp_abm_clean(struct nfp_app *app)\n{\n\tstruct nfp_abm *abm = app->priv;\n\n\tnfp_abm_eswitch_clean_up(abm);\n\tnfp_reprs_clean_and_free_by_type(app, NFP_REPR_TYPE_PF);\n\tnfp_reprs_clean_and_free_by_type(app, NFP_REPR_TYPE_PHYS_PORT);\n\tbitmap_free(abm->threshold_undef);\n\tkvfree(abm->actions);\n\tkvfree(abm->thresholds);\n\tkfree(abm);\n\tapp->priv = NULL;\n}\n\nconst struct nfp_app_type app_abm = {\n\t.id\t\t= NFP_APP_ACTIVE_BUFFER_MGMT_NIC,\n\t.name\t\t= \"abm\",\n\n\t.init\t\t= nfp_abm_init,\n\t.clean\t\t= nfp_abm_clean,\n\n\t.vnic_alloc\t= nfp_abm_vnic_alloc,\n\t.vnic_free\t= nfp_abm_vnic_free,\n\t.vnic_init\t= nfp_abm_vnic_init,\n\n\t.port_get_stats\t\t= nfp_abm_port_get_stats,\n\t.port_get_stats_count\t= nfp_abm_port_get_stats_count,\n\t.port_get_stats_strings\t= nfp_abm_port_get_stats_strings,\n\n\t.setup_tc\t= nfp_abm_setup_tc,\n\n\t.eswitch_mode_get\t= nfp_abm_eswitch_mode_get,\n\t.eswitch_mode_set\t= nfp_abm_eswitch_mode_set,\n\n\t.dev_get\t= nfp_abm_repr_get,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}