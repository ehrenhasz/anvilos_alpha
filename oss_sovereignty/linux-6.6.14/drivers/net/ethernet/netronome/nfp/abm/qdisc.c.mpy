{
  "module_name": "qdisc.c",
  "hash_id": "de600a707578097b5b8604096a58c5aaf3218a63ec48578b80ee2fc9046b6c62",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/netronome/nfp/abm/qdisc.c",
  "human_readable_source": "\n \n\n#include <linux/rtnetlink.h>\n#include <net/pkt_cls.h>\n#include <net/pkt_sched.h>\n#include <net/red.h>\n\n#include \"../nfpcore/nfp_cpp.h\"\n#include \"../nfp_app.h\"\n#include \"../nfp_main.h\"\n#include \"../nfp_net.h\"\n#include \"../nfp_port.h\"\n#include \"main.h\"\n\nstatic bool nfp_abm_qdisc_is_red(struct nfp_qdisc *qdisc)\n{\n\treturn qdisc->type == NFP_QDISC_RED || qdisc->type == NFP_QDISC_GRED;\n}\n\nstatic bool nfp_abm_qdisc_child_valid(struct nfp_qdisc *qdisc, unsigned int id)\n{\n\treturn qdisc->children[id] &&\n\t       qdisc->children[id] != NFP_QDISC_UNTRACKED;\n}\n\nstatic void *nfp_abm_qdisc_tree_deref_slot(void __rcu **slot)\n{\n\treturn rtnl_dereference(*slot);\n}\n\nstatic void\nnfp_abm_stats_propagate(struct nfp_alink_stats *parent,\n\t\t\tstruct nfp_alink_stats *child)\n{\n\tparent->tx_pkts\t\t+= child->tx_pkts;\n\tparent->tx_bytes\t+= child->tx_bytes;\n\tparent->backlog_pkts\t+= child->backlog_pkts;\n\tparent->backlog_bytes\t+= child->backlog_bytes;\n\tparent->overlimits\t+= child->overlimits;\n\tparent->drops\t\t+= child->drops;\n}\n\nstatic void\nnfp_abm_stats_update_red(struct nfp_abm_link *alink, struct nfp_qdisc *qdisc,\n\t\t\t unsigned int queue)\n{\n\tstruct nfp_cpp *cpp = alink->abm->app->cpp;\n\tunsigned int i;\n\tint err;\n\n\tif (!qdisc->offloaded)\n\t\treturn;\n\n\tfor (i = 0; i < qdisc->red.num_bands; i++) {\n\t\terr = nfp_abm_ctrl_read_q_stats(alink, i, queue,\n\t\t\t\t\t\t&qdisc->red.band[i].stats);\n\t\tif (err)\n\t\t\tnfp_err(cpp, \"RED stats (%d, %d) read failed with error %d\\n\",\n\t\t\t\ti, queue, err);\n\n\t\terr = nfp_abm_ctrl_read_q_xstats(alink, i, queue,\n\t\t\t\t\t\t &qdisc->red.band[i].xstats);\n\t\tif (err)\n\t\t\tnfp_err(cpp, \"RED xstats (%d, %d) read failed with error %d\\n\",\n\t\t\t\ti, queue, err);\n\t}\n}\n\nstatic void\nnfp_abm_stats_update_mq(struct nfp_abm_link *alink, struct nfp_qdisc *qdisc)\n{\n\tunsigned int i;\n\n\tif (qdisc->type != NFP_QDISC_MQ)\n\t\treturn;\n\n\tfor (i = 0; i < alink->total_queues; i++)\n\t\tif (nfp_abm_qdisc_child_valid(qdisc, i))\n\t\t\tnfp_abm_stats_update_red(alink, qdisc->children[i], i);\n}\n\nstatic void __nfp_abm_stats_update(struct nfp_abm_link *alink, u64 time_now)\n{\n\talink->last_stats_update = time_now;\n\tif (alink->root_qdisc)\n\t\tnfp_abm_stats_update_mq(alink, alink->root_qdisc);\n}\n\nstatic void nfp_abm_stats_update(struct nfp_abm_link *alink)\n{\n\tu64 now;\n\n\t \n\tnow = ktime_get();\n\tif (now - alink->last_stats_update < NFP_ABM_STATS_REFRESH_IVAL)\n\t\treturn;\n\n\t__nfp_abm_stats_update(alink, now);\n}\n\nstatic void\nnfp_abm_qdisc_unlink_children(struct nfp_qdisc *qdisc,\n\t\t\t      unsigned int start, unsigned int end)\n{\n\tunsigned int i;\n\n\tfor (i = start; i < end; i++)\n\t\tif (nfp_abm_qdisc_child_valid(qdisc, i)) {\n\t\t\tqdisc->children[i]->use_cnt--;\n\t\t\tqdisc->children[i] = NULL;\n\t\t}\n}\n\nstatic void\nnfp_abm_qdisc_offload_stop(struct nfp_abm_link *alink, struct nfp_qdisc *qdisc)\n{\n\tunsigned int i;\n\n\t \n\tif (qdisc->use_cnt)\n\t\tnfp_warn(alink->abm->app->cpp, \"Offload of '%08x' stopped\\n\",\n\t\t\t qdisc->handle);\n\n\tif (!nfp_abm_qdisc_is_red(qdisc))\n\t\treturn;\n\n\tfor (i = 0; i < qdisc->red.num_bands; i++) {\n\t\tqdisc->red.band[i].stats.backlog_pkts = 0;\n\t\tqdisc->red.band[i].stats.backlog_bytes = 0;\n\t}\n}\n\nstatic int\n__nfp_abm_stats_init(struct nfp_abm_link *alink, unsigned int band,\n\t\t     unsigned int queue, struct nfp_alink_stats *prev_stats,\n\t\t     struct nfp_alink_xstats *prev_xstats)\n{\n\tu64 backlog_pkts, backlog_bytes;\n\tint err;\n\n\t \n\tbacklog_pkts = prev_stats->backlog_pkts;\n\tbacklog_bytes = prev_stats->backlog_bytes;\n\n\terr = nfp_abm_ctrl_read_q_stats(alink, band, queue, prev_stats);\n\tif (err) {\n\t\tnfp_err(alink->abm->app->cpp,\n\t\t\t\"RED stats init (%d, %d) failed with error %d\\n\",\n\t\t\tband, queue, err);\n\t\treturn err;\n\t}\n\n\terr = nfp_abm_ctrl_read_q_xstats(alink, band, queue, prev_xstats);\n\tif (err) {\n\t\tnfp_err(alink->abm->app->cpp,\n\t\t\t\"RED xstats init (%d, %d) failed with error %d\\n\",\n\t\t\tband, queue, err);\n\t\treturn err;\n\t}\n\n\tprev_stats->backlog_pkts = backlog_pkts;\n\tprev_stats->backlog_bytes = backlog_bytes;\n\treturn 0;\n}\n\nstatic int\nnfp_abm_stats_init(struct nfp_abm_link *alink, struct nfp_qdisc *qdisc,\n\t\t   unsigned int queue)\n{\n\tunsigned int i;\n\tint err;\n\n\tfor (i = 0; i < qdisc->red.num_bands; i++) {\n\t\terr = __nfp_abm_stats_init(alink, i, queue,\n\t\t\t\t\t   &qdisc->red.band[i].prev_stats,\n\t\t\t\t\t   &qdisc->red.band[i].prev_xstats);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic void\nnfp_abm_offload_compile_red(struct nfp_abm_link *alink, struct nfp_qdisc *qdisc,\n\t\t\t    unsigned int queue)\n{\n\tbool good_red, good_gred;\n\tunsigned int i;\n\n\tgood_red = qdisc->type == NFP_QDISC_RED &&\n\t\t   qdisc->params_ok &&\n\t\t   qdisc->use_cnt == 1 &&\n\t\t   !alink->has_prio &&\n\t\t   !qdisc->children[0];\n\tgood_gred = qdisc->type == NFP_QDISC_GRED &&\n\t\t    qdisc->params_ok &&\n\t\t    qdisc->use_cnt == 1;\n\tqdisc->offload_mark = good_red || good_gred;\n\n\t \n\tif (qdisc->offload_mark && !qdisc->offloaded)\n\t\tif (nfp_abm_stats_init(alink, qdisc, queue))\n\t\t\tqdisc->offload_mark = false;\n\n\tif (!qdisc->offload_mark)\n\t\treturn;\n\n\tfor (i = 0; i < alink->abm->num_bands; i++) {\n\t\tenum nfp_abm_q_action act;\n\n\t\tnfp_abm_ctrl_set_q_lvl(alink, i, queue,\n\t\t\t\t       qdisc->red.band[i].threshold);\n\t\tact = qdisc->red.band[i].ecn ?\n\t\t\tNFP_ABM_ACT_MARK_DROP : NFP_ABM_ACT_DROP;\n\t\tnfp_abm_ctrl_set_q_act(alink, i, queue, act);\n\t}\n}\n\nstatic void\nnfp_abm_offload_compile_mq(struct nfp_abm_link *alink, struct nfp_qdisc *qdisc)\n{\n\tunsigned int i;\n\n\tqdisc->offload_mark = qdisc->type == NFP_QDISC_MQ;\n\tif (!qdisc->offload_mark)\n\t\treturn;\n\n\tfor (i = 0; i < alink->total_queues; i++) {\n\t\tstruct nfp_qdisc *child = qdisc->children[i];\n\n\t\tif (!nfp_abm_qdisc_child_valid(qdisc, i))\n\t\t\tcontinue;\n\n\t\tnfp_abm_offload_compile_red(alink, child, i);\n\t}\n}\n\nvoid nfp_abm_qdisc_offload_update(struct nfp_abm_link *alink)\n{\n\tstruct nfp_abm *abm = alink->abm;\n\tstruct radix_tree_iter iter;\n\tstruct nfp_qdisc *qdisc;\n\tvoid __rcu **slot;\n\tsize_t i;\n\n\t \n\tfor (i = 0; i < abm->num_bands; i++)\n\t\t__bitmap_set(abm->threshold_undef,\n\t\t\t     i * NFP_NET_MAX_RX_RINGS + alink->queue_base,\n\t\t\t     alink->total_queues);\n\n\t \n\tradix_tree_for_each_slot(slot, &alink->qdiscs, &iter, 0) {\n\t\tqdisc = nfp_abm_qdisc_tree_deref_slot(slot);\n\t\tqdisc->offload_mark = false;\n\t}\n\n\tif (alink->root_qdisc)\n\t\tnfp_abm_offload_compile_mq(alink, alink->root_qdisc);\n\n\t \n\tradix_tree_for_each_slot(slot, &alink->qdiscs, &iter, 0) {\n\t\tqdisc = nfp_abm_qdisc_tree_deref_slot(slot);\n\t\tif (!qdisc->offload_mark && qdisc->offloaded)\n\t\t\tnfp_abm_qdisc_offload_stop(alink, qdisc);\n\t\tqdisc->offloaded = qdisc->offload_mark;\n\t}\n\n\t \n\tfor (i = 0; i < abm->num_thresholds; i++)\n\t\tif (test_bit(i, abm->threshold_undef))\n\t\t\t__nfp_abm_ctrl_set_q_lvl(abm, i, NFP_ABM_LVL_INFINITY);\n\n\t__nfp_abm_stats_update(alink, ktime_get());\n}\n\nstatic void\nnfp_abm_qdisc_clear_mq(struct net_device *netdev, struct nfp_abm_link *alink,\n\t\t       struct nfp_qdisc *qdisc)\n{\n\tstruct radix_tree_iter iter;\n\tunsigned int mq_refs = 0;\n\tvoid __rcu **slot;\n\n\tif (!qdisc->use_cnt)\n\t\treturn;\n\t \n\tif (qdisc->type == NFP_QDISC_MQ &&\n\t    qdisc == alink->root_qdisc &&\n\t    netdev->reg_state == NETREG_UNREGISTERING)\n\t\treturn;\n\n\t \n\tradix_tree_for_each_slot(slot, &alink->qdiscs, &iter, 0) {\n\t\tstruct nfp_qdisc *mq = nfp_abm_qdisc_tree_deref_slot(slot);\n\t\tunsigned int i;\n\n\t\tif (mq->type != NFP_QDISC_MQ || mq->netdev != netdev)\n\t\t\tcontinue;\n\t\tfor (i = 0; i < mq->num_children; i++)\n\t\t\tif (mq->children[i] == qdisc) {\n\t\t\t\tmq->children[i] = NULL;\n\t\t\t\tmq_refs++;\n\t\t\t}\n\t}\n\n\tWARN(qdisc->use_cnt != mq_refs, \"non-zero qdisc use count: %d (- %d)\\n\",\n\t     qdisc->use_cnt, mq_refs);\n}\n\nstatic void\nnfp_abm_qdisc_free(struct net_device *netdev, struct nfp_abm_link *alink,\n\t\t   struct nfp_qdisc *qdisc)\n{\n\tstruct nfp_port *port = nfp_port_from_netdev(netdev);\n\n\tif (!qdisc)\n\t\treturn;\n\tnfp_abm_qdisc_clear_mq(netdev, alink, qdisc);\n\tWARN_ON(radix_tree_delete(&alink->qdiscs,\n\t\t\t\t  TC_H_MAJ(qdisc->handle)) != qdisc);\n\n\tkfree(qdisc->children);\n\tkfree(qdisc);\n\n\tport->tc_offload_cnt--;\n}\n\nstatic struct nfp_qdisc *\nnfp_abm_qdisc_alloc(struct net_device *netdev, struct nfp_abm_link *alink,\n\t\t    enum nfp_qdisc_type type, u32 parent_handle, u32 handle,\n\t\t    unsigned int children)\n{\n\tstruct nfp_port *port = nfp_port_from_netdev(netdev);\n\tstruct nfp_qdisc *qdisc;\n\tint err;\n\n\tqdisc = kzalloc(sizeof(*qdisc), GFP_KERNEL);\n\tif (!qdisc)\n\t\treturn NULL;\n\n\tif (children) {\n\t\tqdisc->children = kcalloc(children, sizeof(void *), GFP_KERNEL);\n\t\tif (!qdisc->children)\n\t\t\tgoto err_free_qdisc;\n\t}\n\n\tqdisc->netdev = netdev;\n\tqdisc->type = type;\n\tqdisc->parent_handle = parent_handle;\n\tqdisc->handle = handle;\n\tqdisc->num_children = children;\n\n\terr = radix_tree_insert(&alink->qdiscs, TC_H_MAJ(qdisc->handle), qdisc);\n\tif (err) {\n\t\tnfp_err(alink->abm->app->cpp,\n\t\t\t\"Qdisc insertion into radix tree failed: %d\\n\", err);\n\t\tgoto err_free_child_tbl;\n\t}\n\n\tport->tc_offload_cnt++;\n\treturn qdisc;\n\nerr_free_child_tbl:\n\tkfree(qdisc->children);\nerr_free_qdisc:\n\tkfree(qdisc);\n\treturn NULL;\n}\n\nstatic struct nfp_qdisc *\nnfp_abm_qdisc_find(struct nfp_abm_link *alink, u32 handle)\n{\n\treturn radix_tree_lookup(&alink->qdiscs, TC_H_MAJ(handle));\n}\n\nstatic int\nnfp_abm_qdisc_replace(struct net_device *netdev, struct nfp_abm_link *alink,\n\t\t      enum nfp_qdisc_type type, u32 parent_handle, u32 handle,\n\t\t      unsigned int children, struct nfp_qdisc **qdisc)\n{\n\t*qdisc = nfp_abm_qdisc_find(alink, handle);\n\tif (*qdisc) {\n\t\tif (WARN_ON((*qdisc)->type != type))\n\t\t\treturn -EINVAL;\n\t\treturn 1;\n\t}\n\n\t*qdisc = nfp_abm_qdisc_alloc(netdev, alink, type, parent_handle, handle,\n\t\t\t\t     children);\n\treturn *qdisc ? 0 : -ENOMEM;\n}\n\nstatic void\nnfp_abm_qdisc_destroy(struct net_device *netdev, struct nfp_abm_link *alink,\n\t\t      u32 handle)\n{\n\tstruct nfp_qdisc *qdisc;\n\n\tqdisc = nfp_abm_qdisc_find(alink, handle);\n\tif (!qdisc)\n\t\treturn;\n\n\t \n\tif (alink->root_qdisc == qdisc)\n\t\tqdisc->use_cnt--;\n\n\tnfp_abm_qdisc_unlink_children(qdisc, 0, qdisc->num_children);\n\tnfp_abm_qdisc_free(netdev, alink, qdisc);\n\n\tif (alink->root_qdisc == qdisc) {\n\t\talink->root_qdisc = NULL;\n\t\t \n\t\tnfp_abm_qdisc_offload_update(alink);\n\t}\n}\n\nstatic int\nnfp_abm_qdisc_graft(struct nfp_abm_link *alink, u32 handle, u32 child_handle,\n\t\t    unsigned int id)\n{\n\tstruct nfp_qdisc *parent, *child;\n\n\tparent = nfp_abm_qdisc_find(alink, handle);\n\tif (!parent)\n\t\treturn 0;\n\n\tif (WARN(id >= parent->num_children,\n\t\t \"graft child out of bound %d >= %d\\n\",\n\t\t id, parent->num_children))\n\t\treturn -EINVAL;\n\n\tnfp_abm_qdisc_unlink_children(parent, id, id + 1);\n\n\tchild = nfp_abm_qdisc_find(alink, child_handle);\n\tif (child)\n\t\tchild->use_cnt++;\n\telse\n\t\tchild = NFP_QDISC_UNTRACKED;\n\tparent->children[id] = child;\n\n\tnfp_abm_qdisc_offload_update(alink);\n\n\treturn 0;\n}\n\nstatic void\nnfp_abm_stats_calculate(struct nfp_alink_stats *new,\n\t\t\tstruct nfp_alink_stats *old,\n\t\t\tstruct gnet_stats_basic_sync *bstats,\n\t\t\tstruct gnet_stats_queue *qstats)\n{\n\t_bstats_update(bstats, new->tx_bytes - old->tx_bytes,\n\t\t       new->tx_pkts - old->tx_pkts);\n\tqstats->qlen += new->backlog_pkts - old->backlog_pkts;\n\tqstats->backlog += new->backlog_bytes - old->backlog_bytes;\n\tqstats->overlimits += new->overlimits - old->overlimits;\n\tqstats->drops += new->drops - old->drops;\n}\n\nstatic void\nnfp_abm_stats_red_calculate(struct nfp_alink_xstats *new,\n\t\t\t    struct nfp_alink_xstats *old,\n\t\t\t    struct red_stats *stats)\n{\n\tstats->forced_mark += new->ecn_marked - old->ecn_marked;\n\tstats->pdrop += new->pdrop - old->pdrop;\n}\n\nstatic int\nnfp_abm_gred_stats(struct nfp_abm_link *alink, u32 handle,\n\t\t   struct tc_gred_qopt_offload_stats *stats)\n{\n\tstruct nfp_qdisc *qdisc;\n\tunsigned int i;\n\n\tnfp_abm_stats_update(alink);\n\n\tqdisc = nfp_abm_qdisc_find(alink, handle);\n\tif (!qdisc)\n\t\treturn -EOPNOTSUPP;\n\t \n\n\tfor (i = 0; i < qdisc->red.num_bands; i++) {\n\t\tif (!stats->xstats[i])\n\t\t\tcontinue;\n\n\t\tnfp_abm_stats_calculate(&qdisc->red.band[i].stats,\n\t\t\t\t\t&qdisc->red.band[i].prev_stats,\n\t\t\t\t\t&stats->bstats[i], &stats->qstats[i]);\n\t\tqdisc->red.band[i].prev_stats = qdisc->red.band[i].stats;\n\n\t\tnfp_abm_stats_red_calculate(&qdisc->red.band[i].xstats,\n\t\t\t\t\t    &qdisc->red.band[i].prev_xstats,\n\t\t\t\t\t    stats->xstats[i]);\n\t\tqdisc->red.band[i].prev_xstats = qdisc->red.band[i].xstats;\n\t}\n\n\treturn qdisc->offloaded ? 0 : -EOPNOTSUPP;\n}\n\nstatic bool\nnfp_abm_gred_check_params(struct nfp_abm_link *alink,\n\t\t\t  struct tc_gred_qopt_offload *opt)\n{\n\tstruct nfp_cpp *cpp = alink->abm->app->cpp;\n\tstruct nfp_abm *abm = alink->abm;\n\tunsigned int i;\n\n\tif (opt->set.grio_on || opt->set.wred_on) {\n\t\tnfp_warn(cpp, \"GRED offload failed - GRIO and WRED not supported (p:%08x h:%08x)\\n\",\n\t\t\t opt->parent, opt->handle);\n\t\treturn false;\n\t}\n\tif (opt->set.dp_def != alink->def_band) {\n\t\tnfp_warn(cpp, \"GRED offload failed - default band must be %d (p:%08x h:%08x)\\n\",\n\t\t\t alink->def_band, opt->parent, opt->handle);\n\t\treturn false;\n\t}\n\tif (opt->set.dp_cnt != abm->num_bands) {\n\t\tnfp_warn(cpp, \"GRED offload failed - band count must be %d (p:%08x h:%08x)\\n\",\n\t\t\t abm->num_bands, opt->parent, opt->handle);\n\t\treturn false;\n\t}\n\n\tfor (i = 0; i < abm->num_bands; i++) {\n\t\tstruct tc_gred_vq_qopt_offload_params *band = &opt->set.tab[i];\n\n\t\tif (!band->present)\n\t\t\treturn false;\n\t\tif (!band->is_ecn && !nfp_abm_has_drop(abm)) {\n\t\t\tnfp_warn(cpp, \"GRED offload failed - drop is not supported (ECN option required) (p:%08x h:%08x vq:%d)\\n\",\n\t\t\t\t opt->parent, opt->handle, i);\n\t\t\treturn false;\n\t\t}\n\t\tif (band->is_ecn && !nfp_abm_has_mark(abm)) {\n\t\t\tnfp_warn(cpp, \"GRED offload failed - ECN marking not supported (p:%08x h:%08x vq:%d)\\n\",\n\t\t\t\t opt->parent, opt->handle, i);\n\t\t\treturn false;\n\t\t}\n\t\tif (band->is_harddrop) {\n\t\t\tnfp_warn(cpp, \"GRED offload failed - harddrop is not supported (p:%08x h:%08x vq:%d)\\n\",\n\t\t\t\t opt->parent, opt->handle, i);\n\t\t\treturn false;\n\t\t}\n\t\tif (band->min != band->max) {\n\t\t\tnfp_warn(cpp, \"GRED offload failed - threshold mismatch (p:%08x h:%08x vq:%d)\\n\",\n\t\t\t\t opt->parent, opt->handle, i);\n\t\t\treturn false;\n\t\t}\n\t\tif (band->min > S32_MAX) {\n\t\t\tnfp_warn(cpp, \"GRED offload failed - threshold too large %d > %d (p:%08x h:%08x vq:%d)\\n\",\n\t\t\t\t band->min, S32_MAX, opt->parent, opt->handle,\n\t\t\t\t i);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nstatic int\nnfp_abm_gred_replace(struct net_device *netdev, struct nfp_abm_link *alink,\n\t\t     struct tc_gred_qopt_offload *opt)\n{\n\tstruct nfp_qdisc *qdisc;\n\tunsigned int i;\n\tint ret;\n\n\tret = nfp_abm_qdisc_replace(netdev, alink, NFP_QDISC_GRED, opt->parent,\n\t\t\t\t    opt->handle, 0, &qdisc);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tqdisc->params_ok = nfp_abm_gred_check_params(alink, opt);\n\tif (qdisc->params_ok) {\n\t\tqdisc->red.num_bands = opt->set.dp_cnt;\n\t\tfor (i = 0; i < qdisc->red.num_bands; i++) {\n\t\t\tqdisc->red.band[i].ecn = opt->set.tab[i].is_ecn;\n\t\t\tqdisc->red.band[i].threshold = opt->set.tab[i].min;\n\t\t}\n\t}\n\n\tif (qdisc->use_cnt)\n\t\tnfp_abm_qdisc_offload_update(alink);\n\n\treturn 0;\n}\n\nint nfp_abm_setup_tc_gred(struct net_device *netdev, struct nfp_abm_link *alink,\n\t\t\t  struct tc_gred_qopt_offload *opt)\n{\n\tswitch (opt->command) {\n\tcase TC_GRED_REPLACE:\n\t\treturn nfp_abm_gred_replace(netdev, alink, opt);\n\tcase TC_GRED_DESTROY:\n\t\tnfp_abm_qdisc_destroy(netdev, alink, opt->handle);\n\t\treturn 0;\n\tcase TC_GRED_STATS:\n\t\treturn nfp_abm_gred_stats(alink, opt->handle, &opt->stats);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int\nnfp_abm_red_xstats(struct nfp_abm_link *alink, struct tc_red_qopt_offload *opt)\n{\n\tstruct nfp_qdisc *qdisc;\n\n\tnfp_abm_stats_update(alink);\n\n\tqdisc = nfp_abm_qdisc_find(alink, opt->handle);\n\tif (!qdisc || !qdisc->offloaded)\n\t\treturn -EOPNOTSUPP;\n\n\tnfp_abm_stats_red_calculate(&qdisc->red.band[0].xstats,\n\t\t\t\t    &qdisc->red.band[0].prev_xstats,\n\t\t\t\t    opt->xstats);\n\tqdisc->red.band[0].prev_xstats = qdisc->red.band[0].xstats;\n\treturn 0;\n}\n\nstatic int\nnfp_abm_red_stats(struct nfp_abm_link *alink, u32 handle,\n\t\t  struct tc_qopt_offload_stats *stats)\n{\n\tstruct nfp_qdisc *qdisc;\n\n\tnfp_abm_stats_update(alink);\n\n\tqdisc = nfp_abm_qdisc_find(alink, handle);\n\tif (!qdisc)\n\t\treturn -EOPNOTSUPP;\n\t \n\n\tnfp_abm_stats_calculate(&qdisc->red.band[0].stats,\n\t\t\t\t&qdisc->red.band[0].prev_stats,\n\t\t\t\tstats->bstats, stats->qstats);\n\tqdisc->red.band[0].prev_stats = qdisc->red.band[0].stats;\n\n\treturn qdisc->offloaded ? 0 : -EOPNOTSUPP;\n}\n\nstatic bool\nnfp_abm_red_check_params(struct nfp_abm_link *alink,\n\t\t\t struct tc_red_qopt_offload *opt)\n{\n\tstruct nfp_cpp *cpp = alink->abm->app->cpp;\n\tstruct nfp_abm *abm = alink->abm;\n\n\tif (!opt->set.is_ecn && !nfp_abm_has_drop(abm)) {\n\t\tnfp_warn(cpp, \"RED offload failed - drop is not supported (ECN option required) (p:%08x h:%08x)\\n\",\n\t\t\t opt->parent, opt->handle);\n\t\treturn false;\n\t}\n\tif (opt->set.is_ecn && !nfp_abm_has_mark(abm)) {\n\t\tnfp_warn(cpp, \"RED offload failed - ECN marking not supported (p:%08x h:%08x)\\n\",\n\t\t\t opt->parent, opt->handle);\n\t\treturn false;\n\t}\n\tif (opt->set.is_harddrop) {\n\t\tnfp_warn(cpp, \"RED offload failed - harddrop is not supported (p:%08x h:%08x)\\n\",\n\t\t\t opt->parent, opt->handle);\n\t\treturn false;\n\t}\n\tif (opt->set.min != opt->set.max) {\n\t\tnfp_warn(cpp, \"RED offload failed - unsupported min/max parameters (p:%08x h:%08x)\\n\",\n\t\t\t opt->parent, opt->handle);\n\t\treturn false;\n\t}\n\tif (opt->set.min > NFP_ABM_LVL_INFINITY) {\n\t\tnfp_warn(cpp, \"RED offload failed - threshold too large %d > %d (p:%08x h:%08x)\\n\",\n\t\t\t opt->set.min, NFP_ABM_LVL_INFINITY, opt->parent,\n\t\t\t opt->handle);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic int\nnfp_abm_red_replace(struct net_device *netdev, struct nfp_abm_link *alink,\n\t\t    struct tc_red_qopt_offload *opt)\n{\n\tstruct nfp_qdisc *qdisc;\n\tint ret;\n\n\tret = nfp_abm_qdisc_replace(netdev, alink, NFP_QDISC_RED, opt->parent,\n\t\t\t\t    opt->handle, 1, &qdisc);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tif (opt->set.limit) {\n\t\tif (nfp_abm_qdisc_child_valid(qdisc, 0))\n\t\t\tqdisc->children[0]->use_cnt--;\n\t\tqdisc->children[0] = NULL;\n\t} else {\n\t\t \n\t\tif (!ret)\n\t\t\tqdisc->children[0] = NFP_QDISC_UNTRACKED;\n\t}\n\n\tqdisc->params_ok = nfp_abm_red_check_params(alink, opt);\n\tif (qdisc->params_ok) {\n\t\tqdisc->red.num_bands = 1;\n\t\tqdisc->red.band[0].ecn = opt->set.is_ecn;\n\t\tqdisc->red.band[0].threshold = opt->set.min;\n\t}\n\n\tif (qdisc->use_cnt == 1)\n\t\tnfp_abm_qdisc_offload_update(alink);\n\n\treturn 0;\n}\n\nint nfp_abm_setup_tc_red(struct net_device *netdev, struct nfp_abm_link *alink,\n\t\t\t struct tc_red_qopt_offload *opt)\n{\n\tswitch (opt->command) {\n\tcase TC_RED_REPLACE:\n\t\treturn nfp_abm_red_replace(netdev, alink, opt);\n\tcase TC_RED_DESTROY:\n\t\tnfp_abm_qdisc_destroy(netdev, alink, opt->handle);\n\t\treturn 0;\n\tcase TC_RED_STATS:\n\t\treturn nfp_abm_red_stats(alink, opt->handle, &opt->stats);\n\tcase TC_RED_XSTATS:\n\t\treturn nfp_abm_red_xstats(alink, opt);\n\tcase TC_RED_GRAFT:\n\t\treturn nfp_abm_qdisc_graft(alink, opt->handle,\n\t\t\t\t\t   opt->child_handle, 0);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int\nnfp_abm_mq_create(struct net_device *netdev, struct nfp_abm_link *alink,\n\t\t  struct tc_mq_qopt_offload *opt)\n{\n\tstruct nfp_qdisc *qdisc;\n\tint ret;\n\n\tret = nfp_abm_qdisc_replace(netdev, alink, NFP_QDISC_MQ,\n\t\t\t\t    TC_H_ROOT, opt->handle, alink->total_queues,\n\t\t\t\t    &qdisc);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tqdisc->params_ok = true;\n\tqdisc->offloaded = true;\n\tnfp_abm_qdisc_offload_update(alink);\n\treturn 0;\n}\n\nstatic int\nnfp_abm_mq_stats(struct nfp_abm_link *alink, u32 handle,\n\t\t struct tc_qopt_offload_stats *stats)\n{\n\tstruct nfp_qdisc *qdisc, *red;\n\tunsigned int i, j;\n\n\tqdisc = nfp_abm_qdisc_find(alink, handle);\n\tif (!qdisc)\n\t\treturn -EOPNOTSUPP;\n\n\tnfp_abm_stats_update(alink);\n\n\t \n\tmemset(&qdisc->mq.stats, 0, sizeof(qdisc->mq.stats));\n\tmemset(&qdisc->mq.prev_stats, 0, sizeof(qdisc->mq.prev_stats));\n\n\tfor (i = 0; i < qdisc->num_children; i++) {\n\t\tif (!nfp_abm_qdisc_child_valid(qdisc, i))\n\t\t\tcontinue;\n\n\t\tif (!nfp_abm_qdisc_is_red(qdisc->children[i]))\n\t\t\tcontinue;\n\t\tred = qdisc->children[i];\n\n\t\tfor (j = 0; j < red->red.num_bands; j++) {\n\t\t\tnfp_abm_stats_propagate(&qdisc->mq.stats,\n\t\t\t\t\t\t&red->red.band[j].stats);\n\t\t\tnfp_abm_stats_propagate(&qdisc->mq.prev_stats,\n\t\t\t\t\t\t&red->red.band[j].prev_stats);\n\t\t}\n\t}\n\n\tnfp_abm_stats_calculate(&qdisc->mq.stats, &qdisc->mq.prev_stats,\n\t\t\t\tstats->bstats, stats->qstats);\n\n\treturn qdisc->offloaded ? 0 : -EOPNOTSUPP;\n}\n\nint nfp_abm_setup_tc_mq(struct net_device *netdev, struct nfp_abm_link *alink,\n\t\t\tstruct tc_mq_qopt_offload *opt)\n{\n\tswitch (opt->command) {\n\tcase TC_MQ_CREATE:\n\t\treturn nfp_abm_mq_create(netdev, alink, opt);\n\tcase TC_MQ_DESTROY:\n\t\tnfp_abm_qdisc_destroy(netdev, alink, opt->handle);\n\t\treturn 0;\n\tcase TC_MQ_STATS:\n\t\treturn nfp_abm_mq_stats(alink, opt->handle, &opt->stats);\n\tcase TC_MQ_GRAFT:\n\t\treturn nfp_abm_qdisc_graft(alink, opt->handle,\n\t\t\t\t\t   opt->graft_params.child_handle,\n\t\t\t\t\t   opt->graft_params.queue);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nint nfp_abm_setup_root(struct net_device *netdev, struct nfp_abm_link *alink,\n\t\t       struct tc_root_qopt_offload *opt)\n{\n\tif (opt->ingress)\n\t\treturn -EOPNOTSUPP;\n\tif (alink->root_qdisc)\n\t\talink->root_qdisc->use_cnt--;\n\talink->root_qdisc = nfp_abm_qdisc_find(alink, opt->handle);\n\tif (alink->root_qdisc)\n\t\talink->root_qdisc->use_cnt++;\n\n\tnfp_abm_qdisc_offload_update(alink);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}