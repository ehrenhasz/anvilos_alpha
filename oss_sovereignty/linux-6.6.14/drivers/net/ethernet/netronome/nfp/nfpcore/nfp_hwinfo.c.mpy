{
  "module_name": "nfp_hwinfo.c",
  "hash_id": "f79042bed2472e2e5c9743dbf7d12185c8b1c97f9d63f8c00f48c49fcc98b84f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/netronome/nfp/nfpcore/nfp_hwinfo.c",
  "human_readable_source": "\n \n\n \n\n#include <asm/byteorder.h>\n#include <asm/unaligned.h>\n#include <linux/delay.h>\n#include <linux/log2.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\n#define NFP_SUBSYS \"nfp_hwinfo\"\n\n#include \"crc32.h\"\n#include \"nfp.h\"\n#include \"nfp_cpp.h\"\n#include \"nfp6000/nfp6000.h\"\n\n#define HWINFO_SIZE_MIN\t0x100\n#define HWINFO_WAIT\t20\t \n\n \n\n#define NFP_HWINFO_VERSION_1 ('H' << 24 | 'I' << 16 | 1 << 8 | 0 << 1 | 0)\n#define NFP_HWINFO_VERSION_2 ('H' << 24 | 'I' << 16 | 2 << 8 | 0 << 1 | 0)\n#define NFP_HWINFO_VERSION_UPDATING\tBIT(0)\n\nstruct nfp_hwinfo {\n\tu8 start[0];\n\n\t__le32 version;\n\t__le32 size;\n\n\t \n\t__le32 limit;\n\t__le32 resv;\n\n\tchar data[];\n};\n\nstatic bool nfp_hwinfo_is_updating(struct nfp_hwinfo *hwinfo)\n{\n\treturn le32_to_cpu(hwinfo->version) & NFP_HWINFO_VERSION_UPDATING;\n}\n\nstatic int\nhwinfo_db_walk(struct nfp_cpp *cpp, struct nfp_hwinfo *hwinfo, u32 size)\n{\n\tconst char *key, *val, *end = hwinfo->data + size;\n\n\tfor (key = hwinfo->data; *key && key < end;\n\t     key = val + strlen(val) + 1) {\n\n\t\tval = key + strlen(key) + 1;\n\t\tif (val >= end) {\n\t\t\tnfp_warn(cpp, \"Bad HWINFO - overflowing key\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (val + strlen(val) + 1 > end) {\n\t\t\tnfp_warn(cpp, \"Bad HWINFO - overflowing value\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int\nhwinfo_db_validate(struct nfp_cpp *cpp, struct nfp_hwinfo *db, u32 len)\n{\n\tu32 size, crc;\n\n\tsize = le32_to_cpu(db->size);\n\tif (size > len) {\n\t\tnfp_err(cpp, \"Unsupported hwinfo size %u > %u\\n\", size, len);\n\t\treturn -EINVAL;\n\t}\n\n\tsize -= sizeof(u32);\n\tcrc = crc32_posix(db, size);\n\tif (crc != get_unaligned_le32(db->start + size)) {\n\t\tnfp_err(cpp, \"Corrupt hwinfo table (CRC mismatch), calculated 0x%x, expected 0x%x\\n\",\n\t\t\tcrc, get_unaligned_le32(db->start + size));\n\n\t\treturn -EINVAL;\n\t}\n\n\treturn hwinfo_db_walk(cpp, db, size);\n}\n\nstatic struct nfp_hwinfo *\nhwinfo_try_fetch(struct nfp_cpp *cpp, size_t *cpp_size)\n{\n\tstruct nfp_hwinfo *header;\n\tstruct nfp_resource *res;\n\tu64 cpp_addr;\n\tu32 cpp_id;\n\tint err;\n\tu8 *db;\n\n\tres = nfp_resource_acquire(cpp, NFP_RESOURCE_NFP_HWINFO);\n\tif (!IS_ERR(res)) {\n\t\tcpp_id = nfp_resource_cpp_id(res);\n\t\tcpp_addr = nfp_resource_address(res);\n\t\t*cpp_size = nfp_resource_size(res);\n\n\t\tnfp_resource_release(res);\n\n\t\tif (*cpp_size < HWINFO_SIZE_MIN)\n\t\t\treturn NULL;\n\t} else if (PTR_ERR(res) == -ENOENT) {\n\t\t \n\t\tcpp_id = NFP_CPP_ISLAND_ID(NFP_CPP_TARGET_MU,\n\t\t\t\t\t   NFP_CPP_ACTION_RW, 0, 1);\n\t\tcpp_addr = 0x30000;\n\t\t*cpp_size = 0x0e000;\n\t} else {\n\t\treturn NULL;\n\t}\n\n\tdb = kmalloc(*cpp_size + 1, GFP_KERNEL);\n\tif (!db)\n\t\treturn NULL;\n\n\terr = nfp_cpp_read(cpp, cpp_id, cpp_addr, db, *cpp_size);\n\tif (err != *cpp_size)\n\t\tgoto exit_free;\n\n\theader = (void *)db;\n\tif (nfp_hwinfo_is_updating(header))\n\t\tgoto exit_free;\n\n\tif (le32_to_cpu(header->version) != NFP_HWINFO_VERSION_2) {\n\t\tnfp_err(cpp, \"Unknown HWInfo version: 0x%08x\\n\",\n\t\t\tle32_to_cpu(header->version));\n\t\tgoto exit_free;\n\t}\n\n\t \n\tdb[*cpp_size] = '\\0';\n\n\treturn (void *)db;\nexit_free:\n\tkfree(db);\n\treturn NULL;\n}\n\nstatic struct nfp_hwinfo *hwinfo_fetch(struct nfp_cpp *cpp, size_t *hwdb_size)\n{\n\tconst unsigned long wait_until = jiffies + HWINFO_WAIT * HZ;\n\tstruct nfp_hwinfo *db;\n\tint err;\n\n\tfor (;;) {\n\t\tconst unsigned long start_time = jiffies;\n\n\t\tdb = hwinfo_try_fetch(cpp, hwdb_size);\n\t\tif (db)\n\t\t\treturn db;\n\n\t\terr = msleep_interruptible(100);\n\t\tif (err || time_after(start_time, wait_until)) {\n\t\t\tnfp_err(cpp, \"NFP access error\\n\");\n\t\t\treturn NULL;\n\t\t}\n\t}\n}\n\nstruct nfp_hwinfo *nfp_hwinfo_read(struct nfp_cpp *cpp)\n{\n\tstruct nfp_hwinfo *db;\n\tsize_t hwdb_size = 0;\n\tint err;\n\n\tdb = hwinfo_fetch(cpp, &hwdb_size);\n\tif (!db)\n\t\treturn NULL;\n\n\terr = hwinfo_db_validate(cpp, db, hwdb_size);\n\tif (err) {\n\t\tkfree(db);\n\t\treturn NULL;\n\t}\n\n\treturn db;\n}\n\n \nconst char *nfp_hwinfo_lookup(struct nfp_hwinfo *hwinfo, const char *lookup)\n{\n\tconst char *key, *val, *end;\n\n\tif (!hwinfo || !lookup)\n\t\treturn NULL;\n\n\tend = hwinfo->data + le32_to_cpu(hwinfo->size) - sizeof(u32);\n\n\tfor (key = hwinfo->data; *key && key < end;\n\t     key = val + strlen(val) + 1) {\n\n\t\tval = key + strlen(key) + 1;\n\n\t\tif (strcmp(key, lookup) == 0)\n\t\t\treturn val;\n\t}\n\n\treturn NULL;\n}\n\nchar *nfp_hwinfo_get_packed_strings(struct nfp_hwinfo *hwinfo)\n{\n\treturn hwinfo->data;\n}\n\nu32 nfp_hwinfo_get_packed_str_size(struct nfp_hwinfo *hwinfo)\n{\n\treturn le32_to_cpu(hwinfo->size) - sizeof(u32);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}