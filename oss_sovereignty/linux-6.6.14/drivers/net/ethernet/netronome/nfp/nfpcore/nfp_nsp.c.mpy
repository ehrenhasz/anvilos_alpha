{
  "module_name": "nfp_nsp.c",
  "hash_id": "c062f20efd347835808ee9a7da7268df8c58da60b876c5463b9f53b6764587ee",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/netronome/nfp/nfpcore/nfp_nsp.c",
  "human_readable_source": "\n \n\n \n\n#include <asm/unaligned.h>\n#include <linux/bitfield.h>\n#include <linux/delay.h>\n#include <linux/firmware.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/overflow.h>\n#include <linux/sizes.h>\n#include <linux/slab.h>\n\n#define NFP_SUBSYS \"nfp_nsp\"\n\n#include \"nfp.h\"\n#include \"nfp_cpp.h\"\n#include \"nfp_nsp.h\"\n\n#define NFP_NSP_TIMEOUT_DEFAULT\t30\n#define NFP_NSP_TIMEOUT_BOOT\t30\n\n \n#define NSP_STATUS\t\t0x00\n#define   NSP_STATUS_MAGIC\tGENMASK_ULL(63, 48)\n#define   NSP_STATUS_MAJOR\tGENMASK_ULL(47, 44)\n#define   NSP_STATUS_MINOR\tGENMASK_ULL(43, 32)\n#define   NSP_STATUS_CODE\tGENMASK_ULL(31, 16)\n#define   NSP_STATUS_RESULT\tGENMASK_ULL(15, 8)\n#define   NSP_STATUS_BUSY\tBIT_ULL(0)\n\n#define NSP_COMMAND\t\t0x08\n#define   NSP_COMMAND_OPTION\tGENMASK_ULL(63, 32)\n#define   NSP_COMMAND_CODE\tGENMASK_ULL(31, 16)\n#define   NSP_COMMAND_DMA_BUF\tBIT_ULL(1)\n#define   NSP_COMMAND_START\tBIT_ULL(0)\n\n \n#define NSP_BUFFER\t\t0x10\n#define   NSP_BUFFER_CPP\tGENMASK_ULL(63, 40)\n#define   NSP_BUFFER_ADDRESS\tGENMASK_ULL(39, 0)\n\n#define NSP_DFLT_BUFFER\t\t0x18\n#define   NSP_DFLT_BUFFER_CPP\tGENMASK_ULL(63, 40)\n#define   NSP_DFLT_BUFFER_ADDRESS\tGENMASK_ULL(39, 0)\n\n#define NSP_DFLT_BUFFER_CONFIG\t0x20\n#define   NSP_DFLT_BUFFER_DMA_CHUNK_ORDER\tGENMASK_ULL(63, 58)\n#define   NSP_DFLT_BUFFER_SIZE_4KB\tGENMASK_ULL(15, 8)\n#define   NSP_DFLT_BUFFER_SIZE_MB\tGENMASK_ULL(7, 0)\n\n#define NFP_CAP_CMD_DMA_SG\t0x28\n\n#define NSP_MAGIC\t\t0xab10\n#define NSP_MAJOR\t\t0\n#define NSP_MINOR\t\t8\n\n#define NSP_CODE_MAJOR\t\tGENMASK(15, 12)\n#define NSP_CODE_MINOR\t\tGENMASK(11, 0)\n\n#define NFP_FW_LOAD_RET_MAJOR\tGENMASK(15, 8)\n#define NFP_FW_LOAD_RET_MINOR\tGENMASK(23, 16)\n\n#define NFP_HWINFO_LOOKUP_SIZE\tGENMASK(11, 0)\n\n#define NFP_VERSIONS_SIZE\tGENMASK(11, 0)\n#define NFP_VERSIONS_CNT_OFF\t0\n#define NFP_VERSIONS_BSP_OFF\t2\n#define NFP_VERSIONS_CPLD_OFF\t6\n#define NFP_VERSIONS_APP_OFF\t10\n#define NFP_VERSIONS_BUNDLE_OFF\t14\n#define NFP_VERSIONS_UNDI_OFF\t18\n#define NFP_VERSIONS_NCSI_OFF\t22\n#define NFP_VERSIONS_CFGR_OFF\t26\n\n#define NSP_SFF_EEPROM_BLOCK_LEN\t8\n\nenum nfp_nsp_cmd {\n\tSPCODE_NOOP\t\t= 0,  \n\tSPCODE_SOFT_RESET\t= 1,  \n\tSPCODE_FW_DEFAULT\t= 2,  \n\tSPCODE_PHY_INIT\t\t= 3,  \n\tSPCODE_MAC_INIT\t\t= 4,  \n\tSPCODE_PHY_RXADAPT\t= 5,  \n\tSPCODE_FW_LOAD\t\t= 6,  \n\tSPCODE_ETH_RESCAN\t= 7,  \n\tSPCODE_ETH_CONTROL\t= 8,  \n\tSPCODE_NSP_WRITE_FLASH\t= 11,  \n\tSPCODE_NSP_SENSORS\t= 12,  \n\tSPCODE_NSP_IDENTIFY\t= 13,  \n\tSPCODE_FW_STORED\t= 16,  \n\tSPCODE_HWINFO_LOOKUP\t= 17,  \n\tSPCODE_HWINFO_SET\t= 18,  \n\tSPCODE_FW_LOADED\t= 19,  \n\tSPCODE_VERSIONS\t\t= 21,  \n\tSPCODE_READ_SFF_EEPROM\t= 22,  \n\tSPCODE_READ_MEDIA\t= 23,  \n};\n\nstruct nfp_nsp_dma_buf {\n\t__le32 chunk_cnt;\n\t__le32 reserved[3];\n\tstruct {\n\t\t__le32 size;\n\t\t__le32 reserved;\n\t\t__le64 addr;\n\t} descs[];\n};\n\nstatic const struct {\n\tint code;\n\tconst char *msg;\n} nsp_errors[] = {\n\t{ 6010, \"could not map to phy for port\" },\n\t{ 6011, \"not an allowed rate/lanes for port\" },\n\t{ 6012, \"not an allowed rate/lanes for port\" },\n\t{ 6013, \"high/low error, change other port first\" },\n\t{ 6014, \"config not found in flash\" },\n};\n\nstruct nfp_nsp {\n\tstruct nfp_cpp *cpp;\n\tstruct nfp_resource *res;\n\tstruct {\n\t\tu16 major;\n\t\tu16 minor;\n\t} ver;\n\n\t \n\tbool modified;\n\tunsigned int idx;\n\tvoid *entries;\n};\n\n \nstruct nfp_nsp_command_arg {\n\tu16 code;\n\tbool dma;\n\tunsigned int timeout_sec;\n\tu32 option;\n\tu64 buf;\n\tvoid (*error_cb)(struct nfp_nsp *state, u32 ret_val);\n\tbool error_quiet;\n};\n\n \nstruct nfp_nsp_command_buf_arg {\n\tstruct nfp_nsp_command_arg arg;\n\tconst void *in_buf;\n\tunsigned int in_size;\n\tvoid *out_buf;\n\tunsigned int out_size;\n};\n\nstruct nfp_cpp *nfp_nsp_cpp(struct nfp_nsp *state)\n{\n\treturn state->cpp;\n}\n\nbool nfp_nsp_config_modified(struct nfp_nsp *state)\n{\n\treturn state->modified;\n}\n\nvoid nfp_nsp_config_set_modified(struct nfp_nsp *state, bool modified)\n{\n\tstate->modified = modified;\n}\n\nvoid *nfp_nsp_config_entries(struct nfp_nsp *state)\n{\n\treturn state->entries;\n}\n\nunsigned int nfp_nsp_config_idx(struct nfp_nsp *state)\n{\n\treturn state->idx;\n}\n\nvoid\nnfp_nsp_config_set_state(struct nfp_nsp *state, void *entries, unsigned int idx)\n{\n\tstate->entries = entries;\n\tstate->idx = idx;\n}\n\nvoid nfp_nsp_config_clear_state(struct nfp_nsp *state)\n{\n\tstate->entries = NULL;\n\tstate->idx = 0;\n}\n\nstatic void nfp_nsp_print_extended_error(struct nfp_nsp *state, u32 ret_val)\n{\n\tint i;\n\n\tif (!ret_val)\n\t\treturn;\n\n\tfor (i = 0; i < ARRAY_SIZE(nsp_errors); i++)\n\t\tif (ret_val == nsp_errors[i].code)\n\t\t\tnfp_err(state->cpp, \"err msg: %s\\n\", nsp_errors[i].msg);\n}\n\nstatic int nfp_nsp_check(struct nfp_nsp *state)\n{\n\tstruct nfp_cpp *cpp = state->cpp;\n\tu64 nsp_status, reg;\n\tu32 nsp_cpp;\n\tint err;\n\n\tnsp_cpp = nfp_resource_cpp_id(state->res);\n\tnsp_status = nfp_resource_address(state->res) + NSP_STATUS;\n\n\terr = nfp_cpp_readq(cpp, nsp_cpp, nsp_status, &reg);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (FIELD_GET(NSP_STATUS_MAGIC, reg) != NSP_MAGIC) {\n\t\tnfp_err(cpp, \"Cannot detect NFP Service Processor\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tstate->ver.major = FIELD_GET(NSP_STATUS_MAJOR, reg);\n\tstate->ver.minor = FIELD_GET(NSP_STATUS_MINOR, reg);\n\n\tif (state->ver.major != NSP_MAJOR) {\n\t\tnfp_err(cpp, \"Unsupported ABI %hu.%hu\\n\",\n\t\t\tstate->ver.major, state->ver.minor);\n\t\treturn -EINVAL;\n\t}\n\tif (state->ver.minor < NSP_MINOR) {\n\t\tnfp_err(cpp, \"ABI too old to support NIC operation (%u.%hu < %u.%u), please update the management FW on the flash\\n\",\n\t\t\tNSP_MAJOR, state->ver.minor, NSP_MAJOR, NSP_MINOR);\n\t\treturn -EINVAL;\n\t}\n\n\tif (reg & NSP_STATUS_BUSY) {\n\t\tnfp_err(cpp, \"Service processor busy!\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\treturn 0;\n}\n\n \nstruct nfp_nsp *nfp_nsp_open(struct nfp_cpp *cpp)\n{\n\tstruct nfp_resource *res;\n\tstruct nfp_nsp *state;\n\tint err;\n\n\tres = nfp_resource_acquire(cpp, NFP_RESOURCE_NSP);\n\tif (IS_ERR(res))\n\t\treturn (void *)res;\n\n\tstate = kzalloc(sizeof(*state), GFP_KERNEL);\n\tif (!state) {\n\t\tnfp_resource_release(res);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tstate->cpp = cpp;\n\tstate->res = res;\n\n\terr = nfp_nsp_check(state);\n\tif (err) {\n\t\tnfp_nsp_close(state);\n\t\treturn ERR_PTR(err);\n\t}\n\n\treturn state;\n}\n\n \nvoid nfp_nsp_close(struct nfp_nsp *state)\n{\n\tnfp_resource_release(state->res);\n\tkfree(state);\n}\n\nu16 nfp_nsp_get_abi_ver_major(struct nfp_nsp *state)\n{\n\treturn state->ver.major;\n}\n\nu16 nfp_nsp_get_abi_ver_minor(struct nfp_nsp *state)\n{\n\treturn state->ver.minor;\n}\n\nstatic int\nnfp_nsp_wait_reg(struct nfp_cpp *cpp, u64 *reg, u32 nsp_cpp, u64 addr,\n\t\t u64 mask, u64 val, u32 timeout_sec)\n{\n\tconst unsigned long wait_until = jiffies + timeout_sec * HZ;\n\tint err;\n\n\tfor (;;) {\n\t\tconst unsigned long start_time = jiffies;\n\n\t\terr = nfp_cpp_readq(cpp, nsp_cpp, addr, reg);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tif ((*reg & mask) == val)\n\t\t\treturn 0;\n\n\t\tmsleep(25);\n\n\t\tif (time_after(start_time, wait_until))\n\t\t\treturn -ETIMEDOUT;\n\t}\n}\n\n \nstatic int\n__nfp_nsp_command(struct nfp_nsp *state, const struct nfp_nsp_command_arg *arg)\n{\n\tu64 reg, ret_val, nsp_base, nsp_buffer, nsp_status, nsp_command;\n\tstruct nfp_cpp *cpp = state->cpp;\n\tu32 nsp_cpp;\n\tint err;\n\n\tnsp_cpp = nfp_resource_cpp_id(state->res);\n\tnsp_base = nfp_resource_address(state->res);\n\tnsp_status = nsp_base + NSP_STATUS;\n\tnsp_command = nsp_base + NSP_COMMAND;\n\tnsp_buffer = nsp_base + NSP_BUFFER;\n\n\terr = nfp_nsp_check(state);\n\tif (err)\n\t\treturn err;\n\n\terr = nfp_cpp_writeq(cpp, nsp_cpp, nsp_buffer, arg->buf);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = nfp_cpp_writeq(cpp, nsp_cpp, nsp_command,\n\t\t\t     FIELD_PREP(NSP_COMMAND_OPTION, arg->option) |\n\t\t\t     FIELD_PREP(NSP_COMMAND_CODE, arg->code) |\n\t\t\t     FIELD_PREP(NSP_COMMAND_DMA_BUF, arg->dma) |\n\t\t\t     FIELD_PREP(NSP_COMMAND_START, 1));\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\terr = nfp_nsp_wait_reg(cpp, &reg, nsp_cpp, nsp_command,\n\t\t\t       NSP_COMMAND_START, 0, NFP_NSP_TIMEOUT_DEFAULT);\n\tif (err) {\n\t\tnfp_err(cpp, \"Error %d waiting for code 0x%04x to start\\n\",\n\t\t\terr, arg->code);\n\t\treturn err;\n\t}\n\n\t \n\terr = nfp_nsp_wait_reg(cpp, &reg, nsp_cpp, nsp_status, NSP_STATUS_BUSY,\n\t\t\t       0, arg->timeout_sec ?: NFP_NSP_TIMEOUT_DEFAULT);\n\tif (err) {\n\t\tnfp_err(cpp, \"Error %d waiting for code 0x%04x to complete\\n\",\n\t\t\terr, arg->code);\n\t\treturn err;\n\t}\n\n\terr = nfp_cpp_readq(cpp, nsp_cpp, nsp_command, &ret_val);\n\tif (err < 0)\n\t\treturn err;\n\tret_val = FIELD_GET(NSP_COMMAND_OPTION, ret_val);\n\n\terr = FIELD_GET(NSP_STATUS_RESULT, reg);\n\tif (err) {\n\t\tif (!arg->error_quiet)\n\t\t\tnfp_warn(cpp, \"Result (error) code set: %d (%d) command: %d\\n\",\n\t\t\t\t -err, (int)ret_val, arg->code);\n\n\t\tif (arg->error_cb)\n\t\t\targ->error_cb(state, ret_val);\n\t\telse\n\t\t\tnfp_nsp_print_extended_error(state, ret_val);\n\t\treturn -err;\n\t}\n\n\treturn ret_val;\n}\n\nstatic int nfp_nsp_command(struct nfp_nsp *state, u16 code)\n{\n\tconst struct nfp_nsp_command_arg arg = {\n\t\t.code\t\t= code,\n\t};\n\n\treturn __nfp_nsp_command(state, &arg);\n}\n\nstatic int\nnfp_nsp_command_buf_def(struct nfp_nsp *nsp,\n\t\t\tstruct nfp_nsp_command_buf_arg *arg)\n{\n\tstruct nfp_cpp *cpp = nsp->cpp;\n\tu64 reg, cpp_buf;\n\tint err, ret;\n\tu32 cpp_id;\n\n\terr = nfp_cpp_readq(cpp, nfp_resource_cpp_id(nsp->res),\n\t\t\t    nfp_resource_address(nsp->res) +\n\t\t\t    NSP_DFLT_BUFFER,\n\t\t\t    &reg);\n\tif (err < 0)\n\t\treturn err;\n\n\tcpp_id = FIELD_GET(NSP_DFLT_BUFFER_CPP, reg) << 8;\n\tcpp_buf = FIELD_GET(NSP_DFLT_BUFFER_ADDRESS, reg);\n\n\tif (arg->in_buf && arg->in_size) {\n\t\terr = nfp_cpp_write(cpp, cpp_id, cpp_buf,\n\t\t\t\t    arg->in_buf, arg->in_size);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\t \n\tif (arg->out_buf && arg->out_size && arg->out_size > arg->in_size) {\n\t\terr = nfp_cpp_write(cpp, cpp_id, cpp_buf + arg->in_size,\n\t\t\t\t    arg->out_buf, arg->out_size - arg->in_size);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tif (!FIELD_FIT(NSP_BUFFER_CPP, cpp_id >> 8) ||\n\t    !FIELD_FIT(NSP_BUFFER_ADDRESS, cpp_buf)) {\n\t\tnfp_err(cpp, \"Buffer out of reach %08x %016llx\\n\",\n\t\t\tcpp_id, cpp_buf);\n\t\treturn -EINVAL;\n\t}\n\n\targ->arg.buf = FIELD_PREP(NSP_BUFFER_CPP, cpp_id >> 8) |\n\t\t       FIELD_PREP(NSP_BUFFER_ADDRESS, cpp_buf);\n\tret = __nfp_nsp_command(nsp, &arg->arg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (arg->out_buf && arg->out_size) {\n\t\terr = nfp_cpp_read(cpp, cpp_id, cpp_buf,\n\t\t\t\t   arg->out_buf, arg->out_size);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\treturn ret;\n}\n\nstatic int\nnfp_nsp_command_buf_dma_sg(struct nfp_nsp *nsp,\n\t\t\t   struct nfp_nsp_command_buf_arg *arg,\n\t\t\t   unsigned int max_size, unsigned int chunk_order,\n\t\t\t   unsigned int dma_order)\n{\n\tstruct nfp_cpp *cpp = nsp->cpp;\n\tstruct nfp_nsp_dma_buf *desc;\n\tstruct {\n\t\tdma_addr_t dma_addr;\n\t\tunsigned long len;\n\t\tvoid *chunk;\n\t} *chunks;\n\tsize_t chunk_size, dma_size;\n\tdma_addr_t dma_desc;\n\tstruct device *dev;\n\tunsigned long off;\n\tint i, ret, nseg;\n\tsize_t desc_sz;\n\n\tchunk_size = BIT_ULL(chunk_order);\n\tdma_size = BIT_ULL(dma_order);\n\tnseg = DIV_ROUND_UP(max_size, chunk_size);\n\n\tchunks = kcalloc(nseg, sizeof(*chunks), GFP_KERNEL);\n\tif (!chunks)\n\t\treturn -ENOMEM;\n\n\toff = 0;\n\tret = -ENOMEM;\n\tfor (i = 0; i < nseg; i++) {\n\t\tunsigned long coff;\n\n\t\tchunks[i].chunk = kmalloc(chunk_size,\n\t\t\t\t\t  GFP_KERNEL | __GFP_NOWARN);\n\t\tif (!chunks[i].chunk)\n\t\t\tgoto exit_free_prev;\n\n\t\tchunks[i].len = min_t(u64, chunk_size, max_size - off);\n\n\t\tcoff = 0;\n\t\tif (arg->in_size > off) {\n\t\t\tcoff = min_t(u64, arg->in_size - off, chunk_size);\n\t\t\tmemcpy(chunks[i].chunk, arg->in_buf + off, coff);\n\t\t}\n\t\tmemset(chunks[i].chunk + coff, 0, chunk_size - coff);\n\n\t\toff += chunks[i].len;\n\t}\n\n\tdev = nfp_cpp_device(cpp)->parent;\n\n\tfor (i = 0; i < nseg; i++) {\n\t\tdma_addr_t addr;\n\n\t\taddr = dma_map_single(dev, chunks[i].chunk, chunks[i].len,\n\t\t\t\t      DMA_BIDIRECTIONAL);\n\t\tchunks[i].dma_addr = addr;\n\n\t\tret = dma_mapping_error(dev, addr);\n\t\tif (ret)\n\t\t\tgoto exit_unmap_prev;\n\n\t\tif (WARN_ONCE(round_down(addr, dma_size) !=\n\t\t\t      round_down(addr + chunks[i].len - 1, dma_size),\n\t\t\t      \"unaligned DMA address: %pad %lu %zd\\n\",\n\t\t\t      &addr, chunks[i].len, dma_size)) {\n\t\t\tret = -EFAULT;\n\t\t\ti++;\n\t\t\tgoto exit_unmap_prev;\n\t\t}\n\t}\n\n\tdesc_sz = struct_size(desc, descs, nseg);\n\tdesc = kmalloc(desc_sz, GFP_KERNEL);\n\tif (!desc) {\n\t\tret = -ENOMEM;\n\t\tgoto exit_unmap_all;\n\t}\n\n\tdesc->chunk_cnt = cpu_to_le32(nseg);\n\tfor (i = 0; i < nseg; i++) {\n\t\tdesc->descs[i].size = cpu_to_le32(chunks[i].len);\n\t\tdesc->descs[i].addr = cpu_to_le64(chunks[i].dma_addr);\n\t}\n\n\tdma_desc = dma_map_single(dev, desc, desc_sz, DMA_TO_DEVICE);\n\tret = dma_mapping_error(dev, dma_desc);\n\tif (ret)\n\t\tgoto exit_free_desc;\n\n\targ->arg.dma = true;\n\targ->arg.buf = dma_desc;\n\tret = __nfp_nsp_command(nsp, &arg->arg);\n\tif (ret < 0)\n\t\tgoto exit_unmap_desc;\n\n\ti = 0;\n\toff = 0;\n\twhile (off < arg->out_size) {\n\t\tunsigned int len;\n\n\t\tlen = min_t(u64, chunks[i].len, arg->out_size - off);\n\t\tmemcpy(arg->out_buf + off, chunks[i].chunk, len);\n\t\toff += len;\n\t\ti++;\n\t}\n\nexit_unmap_desc:\n\tdma_unmap_single(dev, dma_desc, desc_sz, DMA_TO_DEVICE);\nexit_free_desc:\n\tkfree(desc);\nexit_unmap_all:\n\ti = nseg;\nexit_unmap_prev:\n\twhile (--i >= 0)\n\t\tdma_unmap_single(dev, chunks[i].dma_addr, chunks[i].len,\n\t\t\t\t DMA_BIDIRECTIONAL);\n\ti = nseg;\nexit_free_prev:\n\twhile (--i >= 0)\n\t\tkfree(chunks[i].chunk);\n\tkfree(chunks);\n\tif (ret < 0)\n\t\tnfp_err(cpp, \"NSP: SG DMA failed for command 0x%04x: %d (sz:%d cord:%d)\\n\",\n\t\t\targ->arg.code, ret, max_size, chunk_order);\n\treturn ret;\n}\n\nstatic int\nnfp_nsp_command_buf_dma(struct nfp_nsp *nsp,\n\t\t\tstruct nfp_nsp_command_buf_arg *arg,\n\t\t\tunsigned int max_size, unsigned int dma_order)\n{\n\tunsigned int chunk_order, buf_order;\n\tstruct nfp_cpp *cpp = nsp->cpp;\n\tbool sg_ok;\n\tu64 reg;\n\tint err;\n\n\tbuf_order = order_base_2(roundup_pow_of_two(max_size));\n\n\terr = nfp_cpp_readq(cpp, nfp_resource_cpp_id(nsp->res),\n\t\t\t    nfp_resource_address(nsp->res) + NFP_CAP_CMD_DMA_SG,\n\t\t\t    &reg);\n\tif (err < 0)\n\t\treturn err;\n\tsg_ok = reg & BIT_ULL(arg->arg.code - 1);\n\n\tif (!sg_ok) {\n\t\tif (buf_order > dma_order) {\n\t\t\tnfp_err(cpp, \"NSP: can't service non-SG DMA for command 0x%04x\\n\",\n\t\t\t\targ->arg.code);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tchunk_order = buf_order;\n\t} else {\n\t\tchunk_order = min_t(unsigned int, dma_order, PAGE_SHIFT);\n\t}\n\n\treturn nfp_nsp_command_buf_dma_sg(nsp, arg, max_size, chunk_order,\n\t\t\t\t\t  dma_order);\n}\n\nstatic int\nnfp_nsp_command_buf(struct nfp_nsp *nsp, struct nfp_nsp_command_buf_arg *arg)\n{\n\tunsigned int dma_order, def_size, max_size;\n\tstruct nfp_cpp *cpp = nsp->cpp;\n\tu64 reg;\n\tint err;\n\n\tif (nsp->ver.minor < 13) {\n\t\tnfp_err(cpp, \"NSP: Code 0x%04x with buffer not supported (ABI %hu.%hu)\\n\",\n\t\t\targ->arg.code, nsp->ver.major, nsp->ver.minor);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\terr = nfp_cpp_readq(cpp, nfp_resource_cpp_id(nsp->res),\n\t\t\t    nfp_resource_address(nsp->res) +\n\t\t\t    NSP_DFLT_BUFFER_CONFIG,\n\t\t\t    &reg);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tif (arg->out_buf && arg->out_size && arg->out_size > arg->in_size)\n\t\tmemset(arg->out_buf, 0, arg->out_size - arg->in_size);\n\n\tmax_size = max(arg->in_size, arg->out_size);\n\tdef_size = FIELD_GET(NSP_DFLT_BUFFER_SIZE_MB, reg) * SZ_1M +\n\t\t   FIELD_GET(NSP_DFLT_BUFFER_SIZE_4KB, reg) * SZ_4K;\n\tdma_order = FIELD_GET(NSP_DFLT_BUFFER_DMA_CHUNK_ORDER, reg);\n\tif (def_size >= max_size) {\n\t\treturn nfp_nsp_command_buf_def(nsp, arg);\n\t} else if (!dma_order) {\n\t\tnfp_err(cpp, \"NSP: default buffer too small for command 0x%04x (%u < %u)\\n\",\n\t\t\targ->arg.code, def_size, max_size);\n\t\treturn -EINVAL;\n\t}\n\n\treturn nfp_nsp_command_buf_dma(nsp, arg, max_size, dma_order);\n}\n\nint nfp_nsp_wait(struct nfp_nsp *state)\n{\n\tconst unsigned long wait_until = jiffies + NFP_NSP_TIMEOUT_BOOT * HZ;\n\tint err;\n\n\tnfp_dbg(state->cpp, \"Waiting for NSP to respond (%u sec max).\\n\",\n\t\tNFP_NSP_TIMEOUT_BOOT);\n\n\tfor (;;) {\n\t\tconst unsigned long start_time = jiffies;\n\n\t\terr = nfp_nsp_command(state, SPCODE_NOOP);\n\t\tif (err != -EAGAIN)\n\t\t\tbreak;\n\n\t\tif (msleep_interruptible(25)) {\n\t\t\terr = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (time_after(start_time, wait_until)) {\n\t\t\terr = -ETIMEDOUT;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (err)\n\t\tnfp_err(state->cpp, \"NSP failed to respond %d\\n\", err);\n\n\treturn err;\n}\n\nint nfp_nsp_device_soft_reset(struct nfp_nsp *state)\n{\n\treturn nfp_nsp_command(state, SPCODE_SOFT_RESET);\n}\n\nint nfp_nsp_mac_reinit(struct nfp_nsp *state)\n{\n\treturn nfp_nsp_command(state, SPCODE_MAC_INIT);\n}\n\nstatic void nfp_nsp_load_fw_extended_msg(struct nfp_nsp *state, u32 ret_val)\n{\n\tstatic const char * const major_msg[] = {\n\t\t  \"Firmware from driver loaded\",\n\t\t  \"Firmware from flash loaded\",\n\t\t  \"Firmware loading failure\",\n\t};\n\tstatic const char * const minor_msg[] = {\n\t\t  \"\",\n\t\t  \"no named partition on flash\",\n\t\t  \"error reading from flash\",\n\t\t  \"can not deflate\",\n\t\t  \"not a trusted file\",\n\t\t  \"can not parse FW file\",\n\t\t  \"MIP not found in FW file\",\n\t\t  \"null firmware name in MIP\",\n\t\t  \"FW version none\",\n\t\t  \"FW build number none\",\n\t\t  \"no FW selection policy HWInfo key found\",\n\t\t  \"static FW selection policy\",\n\t\t  \"FW version has precedence\",\n\t\t  \"different FW application load requested\",\n\t\t  \"development build\",\n\t};\n\tunsigned int major, minor;\n\tconst char *level;\n\n\tmajor = FIELD_GET(NFP_FW_LOAD_RET_MAJOR, ret_val);\n\tminor = FIELD_GET(NFP_FW_LOAD_RET_MINOR, ret_val);\n\n\tif (!nfp_nsp_has_stored_fw_load(state))\n\t\treturn;\n\n\t \n\tif (major == 0 && (minor == 0 || minor == 10))\n\t\tlevel = KERN_DEBUG;\n\telse if (major == 2)\n\t\tlevel = KERN_ERR;\n\telse\n\t\tlevel = KERN_INFO;\n\n\tif (major >= ARRAY_SIZE(major_msg))\n\t\tnfp_printk(level, state->cpp, \"FW loading status: %x\\n\",\n\t\t\t   ret_val);\n\telse if (minor >= ARRAY_SIZE(minor_msg))\n\t\tnfp_printk(level, state->cpp, \"%s, reason code: %d\\n\",\n\t\t\t   major_msg[major], minor);\n\telse\n\t\tnfp_printk(level, state->cpp, \"%s%c %s\\n\",\n\t\t\t   major_msg[major], minor ? ',' : '.',\n\t\t\t   minor_msg[minor]);\n}\n\nint nfp_nsp_load_fw(struct nfp_nsp *state, const struct firmware *fw)\n{\n\tstruct nfp_nsp_command_buf_arg load_fw = {\n\t\t{\n\t\t\t.code\t\t= SPCODE_FW_LOAD,\n\t\t\t.option\t\t= fw->size,\n\t\t\t.error_cb\t= nfp_nsp_load_fw_extended_msg,\n\t\t},\n\t\t.in_buf\t\t= fw->data,\n\t\t.in_size\t= fw->size,\n\t};\n\tint ret;\n\n\tret = nfp_nsp_command_buf(state, &load_fw);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tnfp_nsp_load_fw_extended_msg(state, ret);\n\treturn 0;\n}\n\nint nfp_nsp_write_flash(struct nfp_nsp *state, const struct firmware *fw)\n{\n\tstruct nfp_nsp_command_buf_arg write_flash = {\n\t\t{\n\t\t\t.code\t\t= SPCODE_NSP_WRITE_FLASH,\n\t\t\t.option\t\t= fw->size,\n\t\t\t.timeout_sec\t= 900,\n\t\t},\n\t\t.in_buf\t\t= fw->data,\n\t\t.in_size\t= fw->size,\n\t};\n\n\treturn nfp_nsp_command_buf(state, &write_flash);\n}\n\nint nfp_nsp_read_eth_table(struct nfp_nsp *state, void *buf, unsigned int size)\n{\n\tstruct nfp_nsp_command_buf_arg eth_rescan = {\n\t\t{\n\t\t\t.code\t\t= SPCODE_ETH_RESCAN,\n\t\t\t.option\t\t= size,\n\t\t},\n\t\t.out_buf\t= buf,\n\t\t.out_size\t= size,\n\t};\n\n\treturn nfp_nsp_command_buf(state, &eth_rescan);\n}\n\nint nfp_nsp_write_eth_table(struct nfp_nsp *state,\n\t\t\t    const void *buf, unsigned int size)\n{\n\tstruct nfp_nsp_command_buf_arg eth_ctrl = {\n\t\t{\n\t\t\t.code\t\t= SPCODE_ETH_CONTROL,\n\t\t\t.option\t\t= size,\n\t\t},\n\t\t.in_buf\t\t= buf,\n\t\t.in_size\t= size,\n\t};\n\n\treturn nfp_nsp_command_buf(state, &eth_ctrl);\n}\n\nint nfp_nsp_read_identify(struct nfp_nsp *state, void *buf, unsigned int size)\n{\n\tstruct nfp_nsp_command_buf_arg identify = {\n\t\t{\n\t\t\t.code\t\t= SPCODE_NSP_IDENTIFY,\n\t\t\t.option\t\t= size,\n\t\t},\n\t\t.out_buf\t= buf,\n\t\t.out_size\t= size,\n\t};\n\n\treturn nfp_nsp_command_buf(state, &identify);\n}\n\nint nfp_nsp_read_sensors(struct nfp_nsp *state, unsigned int sensor_mask,\n\t\t\t void *buf, unsigned int size)\n{\n\tstruct nfp_nsp_command_buf_arg sensors = {\n\t\t{\n\t\t\t.code\t\t= SPCODE_NSP_SENSORS,\n\t\t\t.option\t\t= sensor_mask,\n\t\t},\n\t\t.out_buf\t= buf,\n\t\t.out_size\t= size,\n\t};\n\n\treturn nfp_nsp_command_buf(state, &sensors);\n}\n\nint nfp_nsp_load_stored_fw(struct nfp_nsp *state)\n{\n\tconst struct nfp_nsp_command_arg arg = {\n\t\t.code\t\t= SPCODE_FW_STORED,\n\t\t.error_cb\t= nfp_nsp_load_fw_extended_msg,\n\t};\n\tint ret;\n\n\tret = __nfp_nsp_command(state, &arg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tnfp_nsp_load_fw_extended_msg(state, ret);\n\treturn 0;\n}\n\nstatic int\n__nfp_nsp_hwinfo_lookup(struct nfp_nsp *state, void *buf, unsigned int size,\n\t\t\tbool optional)\n{\n\tstruct nfp_nsp_command_buf_arg hwinfo_lookup = {\n\t\t{\n\t\t\t.code\t\t= SPCODE_HWINFO_LOOKUP,\n\t\t\t.option\t\t= size,\n\t\t\t.error_quiet\t= optional,\n\t\t},\n\t\t.in_buf\t\t= buf,\n\t\t.in_size\t= size,\n\t\t.out_buf\t= buf,\n\t\t.out_size\t= size,\n\t};\n\n\treturn nfp_nsp_command_buf(state, &hwinfo_lookup);\n}\n\nint nfp_nsp_hwinfo_lookup(struct nfp_nsp *state, void *buf, unsigned int size)\n{\n\tint err;\n\n\tsize = min_t(u32, size, NFP_HWINFO_LOOKUP_SIZE);\n\n\terr = __nfp_nsp_hwinfo_lookup(state, buf, size, false);\n\tif (err)\n\t\treturn err;\n\n\tif (strnlen(buf, size) == size) {\n\t\tnfp_err(state->cpp, \"NSP HWinfo value not NULL-terminated\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nint nfp_nsp_hwinfo_lookup_optional(struct nfp_nsp *state, void *buf,\n\t\t\t\t   unsigned int size, const char *default_val)\n{\n\tint err;\n\n\t \n\tif (strnlen(default_val, size) == size)\n\t\treturn -EINVAL;\n\n\tif (!nfp_nsp_has_hwinfo_lookup(state)) {\n\t\tstrcpy(buf, default_val);\n\t\treturn 0;\n\t}\n\n\tsize = min_t(u32, size, NFP_HWINFO_LOOKUP_SIZE);\n\n\terr = __nfp_nsp_hwinfo_lookup(state, buf, size, true);\n\tif (err) {\n\t\tif (err == -ENOENT) {\n\t\t\tstrcpy(buf, default_val);\n\t\t\treturn 0;\n\t\t}\n\n\t\tnfp_err(state->cpp, \"NSP HWinfo lookup failed: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tif (strnlen(buf, size) == size) {\n\t\tnfp_err(state->cpp, \"NSP HWinfo value not NULL-terminated\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nint nfp_nsp_hwinfo_set(struct nfp_nsp *state, void *buf, unsigned int size)\n{\n\tstruct nfp_nsp_command_buf_arg hwinfo_set = {\n\t\t{\n\t\t\t.code\t\t= SPCODE_HWINFO_SET,\n\t\t\t.option\t\t= size,\n\t\t},\n\t\t.in_buf\t\t= buf,\n\t\t.in_size\t= size,\n\t};\n\n\treturn nfp_nsp_command_buf(state, &hwinfo_set);\n}\n\nint nfp_nsp_fw_loaded(struct nfp_nsp *state)\n{\n\tconst struct nfp_nsp_command_arg arg = {\n\t\t.code\t\t= SPCODE_FW_LOADED,\n\t};\n\n\treturn __nfp_nsp_command(state, &arg);\n}\n\nint nfp_nsp_versions(struct nfp_nsp *state, void *buf, unsigned int size)\n{\n\tstruct nfp_nsp_command_buf_arg versions = {\n\t\t{\n\t\t\t.code\t\t= SPCODE_VERSIONS,\n\t\t\t.option\t\t= min_t(u32, size, NFP_VERSIONS_SIZE),\n\t\t},\n\t\t.out_buf\t= buf,\n\t\t.out_size\t= min_t(u32, size, NFP_VERSIONS_SIZE),\n\t};\n\n\treturn nfp_nsp_command_buf(state, &versions);\n}\n\nconst char *nfp_nsp_versions_get(enum nfp_nsp_versions id, bool flash,\n\t\t\t\t const u8 *buf, unsigned int size)\n{\n\tstatic const u32 id2off[] = {\n\t\t[NFP_VERSIONS_BSP] =\tNFP_VERSIONS_BSP_OFF,\n\t\t[NFP_VERSIONS_CPLD] =\tNFP_VERSIONS_CPLD_OFF,\n\t\t[NFP_VERSIONS_APP] =\tNFP_VERSIONS_APP_OFF,\n\t\t[NFP_VERSIONS_BUNDLE] =\tNFP_VERSIONS_BUNDLE_OFF,\n\t\t[NFP_VERSIONS_UNDI] =\tNFP_VERSIONS_UNDI_OFF,\n\t\t[NFP_VERSIONS_NCSI] =\tNFP_VERSIONS_NCSI_OFF,\n\t\t[NFP_VERSIONS_CFGR] =\tNFP_VERSIONS_CFGR_OFF,\n\t};\n\tunsigned int field, buf_field_cnt, buf_off;\n\n\tif (id >= ARRAY_SIZE(id2off) || !id2off[id])\n\t\treturn ERR_PTR(-EINVAL);\n\n\tfield = id * 2 + flash;\n\n\tbuf_field_cnt = get_unaligned_le16(buf);\n\tif (buf_field_cnt <= field)\n\t\treturn ERR_PTR(-ENOENT);\n\n\tbuf_off = get_unaligned_le16(buf + id2off[id] + flash * 2);\n\tif (!buf_off)\n\t\treturn ERR_PTR(-ENOENT);\n\n\tif (buf_off >= size)\n\t\treturn ERR_PTR(-EINVAL);\n\tif (strnlen(&buf[buf_off], size - buf_off) == size - buf_off)\n\t\treturn ERR_PTR(-EINVAL);\n\n\treturn (const char *)&buf[buf_off];\n}\n\nstatic int\n__nfp_nsp_module_eeprom(struct nfp_nsp *state, void *buf, unsigned int size)\n{\n\tstruct nfp_nsp_command_buf_arg module_eeprom = {\n\t\t{\n\t\t\t.code\t\t= SPCODE_READ_SFF_EEPROM,\n\t\t\t.option\t\t= size,\n\t\t},\n\t\t.in_buf\t\t= buf,\n\t\t.in_size\t= size,\n\t\t.out_buf\t= buf,\n\t\t.out_size\t= size,\n\t};\n\n\treturn nfp_nsp_command_buf(state, &module_eeprom);\n}\n\nint nfp_nsp_read_module_eeprom(struct nfp_nsp *state, int eth_index,\n\t\t\t       unsigned int offset, void *data,\n\t\t\t       unsigned int len, unsigned int *read_len)\n{\n\tstruct eeprom_buf {\n\t\tu8 metalen;\n\t\t__le16 length;\n\t\t__le16 offset;\n\t\t__le16 readlen;\n\t\tu8 eth_index;\n\t\tu8 data[];\n\t} __packed *buf;\n\tint bufsz, ret;\n\n\tBUILD_BUG_ON(offsetof(struct eeprom_buf, data) % 8);\n\n\t \n\tbufsz = struct_size(buf, data, round_up(len, NSP_SFF_EEPROM_BLOCK_LEN));\n\tbuf = kzalloc(bufsz, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tbuf->metalen =\n\t\toffsetof(struct eeprom_buf, data) / NSP_SFF_EEPROM_BLOCK_LEN;\n\tbuf->length = cpu_to_le16(len);\n\tbuf->offset = cpu_to_le16(offset);\n\tbuf->eth_index = eth_index;\n\n\tret = __nfp_nsp_module_eeprom(state, buf, bufsz);\n\n\t*read_len = min_t(unsigned int, len, le16_to_cpu(buf->readlen));\n\tif (*read_len)\n\t\tmemcpy(data, buf->data, *read_len);\n\n\tif (!ret && *read_len < len)\n\t\tret = -EIO;\n\n\tkfree(buf);\n\n\treturn ret;\n};\n\nint nfp_nsp_read_media(struct nfp_nsp *state, void *buf, unsigned int size)\n{\n\tstruct nfp_nsp_command_buf_arg media = {\n\t\t{\n\t\t\t.code\t\t= SPCODE_READ_MEDIA,\n\t\t\t.option\t\t= size,\n\t\t},\n\t\t.in_buf\t\t= buf,\n\t\t.in_size\t= size,\n\t\t.out_buf\t= buf,\n\t\t.out_size\t= size,\n\t};\n\n\treturn nfp_nsp_command_buf(state, &media);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}