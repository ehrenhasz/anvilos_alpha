{
  "module_name": "nfp_target.c",
  "hash_id": "d4208b7457f2e56db4cec8378095a1d298c7a658923db72a0c1ddc6e580cf8ed",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/netronome/nfp/nfpcore/nfp_target.c",
  "human_readable_source": "\n \n\n \n\n#define pr_fmt(fmt)       \"NFP target: \" fmt\n\n#include <linux/bitops.h>\n#include <linux/kernel.h>\n#include <linux/printk.h>\n\n#include \"nfp_cpp.h\"\n\n#include \"nfp6000/nfp6000.h\"\n\n#define P32 1\n#define P64 2\n\n \n\n#define AT(_action, _token, _pull, _push)\t\t\t\t\\\n\tcase NFP_CPP_ID(0, (_action), (_token)):\t\t\t\\\n\t\treturn PUSHPULL((_pull), (_push))\n\nstatic int target_rw(u32 cpp_id, int pp, int start, int len)\n{\n\tswitch (cpp_id & NFP_CPP_ID(0, ~0, ~0)) {\n\tAT(0, 0,  0, pp);\n\tAT(1, 0, pp,  0);\n\tAT(NFP_CPP_ACTION_RW, 0, pp, pp);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int nfp6000_nbi_dma(u32 cpp_id)\n{\n\tswitch (cpp_id & NFP_CPP_ID(0, ~0, ~0)) {\n\tAT(0, 0,   0, P64);\t \n\tAT(1, 0,   P64, 0);\t \n\tAT(NFP_CPP_ACTION_RW, 0, P64, P64);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int nfp6000_nbi_stats(u32 cpp_id)\n{\n\tswitch (cpp_id & NFP_CPP_ID(0, ~0, ~0)) {\n\tAT(0, 0,   0, P32);\t \n\tAT(1, 0,   P32, 0);\t \n\tAT(NFP_CPP_ACTION_RW, 0, P32, P32);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int nfp6000_nbi_tm(u32 cpp_id)\n{\n\tswitch (cpp_id & NFP_CPP_ID(0, ~0, ~0)) {\n\tAT(0, 0,   0, P64);\t \n\tAT(1, 0,   P64, 0);\t \n\tAT(NFP_CPP_ACTION_RW, 0, P64, P64);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int nfp6000_nbi_ppc(u32 cpp_id)\n{\n\tswitch (cpp_id & NFP_CPP_ID(0, ~0, ~0)) {\n\tAT(0, 0,   0, P64);\t \n\tAT(1, 0,   P64, 0);\t \n\tAT(NFP_CPP_ACTION_RW, 0, P64, P64);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int nfp6000_nbi(u32 cpp_id, u64 address)\n{\n\tu64 rel_addr = address & 0x3fFFFF;\n\n\tif (rel_addr < (1 << 20))\n\t\treturn nfp6000_nbi_dma(cpp_id);\n\tif (rel_addr < (2 << 20))\n\t\treturn nfp6000_nbi_stats(cpp_id);\n\tif (rel_addr < (3 << 20))\n\t\treturn nfp6000_nbi_tm(cpp_id);\n\treturn nfp6000_nbi_ppc(cpp_id);\n}\n\n \nstatic int nfp6000_mu_common(u32 cpp_id)\n{\n\tswitch (cpp_id & NFP_CPP_ID(0, ~0, ~0)) {\n\tAT(NFP_CPP_ACTION_RW, 0, P64, P64);\t \n\tAT(NFP_CPP_ACTION_RW, 1, P64, P64);\t \n\tAT(NFP_CPP_ACTION_RW, 2, P64, P64);\t \n\tAT(NFP_CPP_ACTION_RW, 3, P64, P64);\t \n\tAT(0, 0,   0, P64);\t \n\tAT(0, 1,   0, P64);\t \n\tAT(0, 2,   0, P64);\t \n\tAT(0, 3,   0, P64);\t \n\tAT(1, 0, P64,   0);\t \n\tAT(1, 1, P64,   0);\t \n\tAT(1, 2, P64,   0);\t \n\tAT(1, 3, P64,   0);\t \n\tAT(3, 0,   0, P32);\t \n\tAT(3, 2, P32,   0);\t \n\tAT(4, 0, P32,   0);\t \n\tAT(4, 2,   0,   0);\t \n\tAT(4, 3,   0, P32);\t \n\tAT(5, 0, P32,   0);\t \n\tAT(5, 3,   0, P32);\t \n\tAT(6, 0, P32,   0);\t \n\tAT(6, 3,   0, P32);\t \n\tAT(7, 0, P32,   0);\t \n\tAT(7, 3,   0, P32);\t \n\tAT(8, 0, P32,   0);\t \n\tAT(8, 3,   0, P32);\t \n\tAT(9, 0, P32,   0);\t \n\tAT(9, 3,   0, P32);\t \n\tAT(10, 0, P32,   0);\t \n\tAT(10, 3,   0, P32);\t \n\tAT(13, 0,   0, P32);\t \n\tAT(13, 1,   0, P32);\t \n\tAT(13, 2, P32,   0);\t \n\tAT(15, 0, P32,   0);\t \n\tAT(15, 3,   0, P32);\t \n\tAT(28, 0,   0, P32);\t \n\tAT(28, 1,   0, P32);\t \n\tAT(28, 2,   0, P32);\t \n\tAT(28, 3,   0, P32);\t \n\tAT(31, 0, P32,   0);\t \n\tAT(31, 1, P32,   0);\t \n\tAT(31, 2, P32,   0);\t \n\tAT(31, 3, P32,   0);\t \n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int nfp6000_mu_ctm(u32 cpp_id)\n{\n\tswitch (cpp_id & NFP_CPP_ID(0, ~0, ~0)) {\n\tAT(16, 1,   0, P32);\t \n\tAT(17, 1,   0, P32);\t \n\tAT(17, 3,   0, P64);\t \n\tAT(18, 2,   0, P64);\t \n\tAT(18, 3,   0, P64);\t \n\tAT(21, 0,   0, P64);\t \n\tAT(21, 1,   0, P64);\t \n\tAT(21, 2,   0, P64);\t \n\tAT(21, 3,   0, P64);\t \n\tdefault:\n\t\treturn nfp6000_mu_common(cpp_id);\n\t}\n}\n\nstatic int nfp6000_mu_emu(u32 cpp_id)\n{\n\tswitch (cpp_id & NFP_CPP_ID(0, ~0, ~0)) {\n\tAT(18, 0,   0, P32);\t \n\tAT(18, 1,   0, P32);\t \n\tAT(18, 2, P32,   0);\t \n\tAT(18, 3, P32,   0);\t \n\tAT(20, 2, P32,   0);\t \n\tAT(21, 0,   0, P32);\t \n\tAT(21, 1,   0, P32);\t \n\tAT(21, 2,   0, P32);\t \n\tAT(22, 0,   0, P32);\t \n\tAT(22, 1,   0, P32);\t \n\tAT(22, 2,   0, P32);\t \n\tdefault:\n\t\treturn nfp6000_mu_common(cpp_id);\n\t}\n}\n\nstatic int nfp6000_mu_imu(u32 cpp_id)\n{\n\treturn nfp6000_mu_common(cpp_id);\n}\n\nstatic int nfp6000_mu(u32 cpp_id, u64 address)\n{\n\tint pp;\n\n\tif (address < 0x2000000000ULL)\n\t\tpp = nfp6000_mu_ctm(cpp_id);\n\telse if (address < 0x8000000000ULL)\n\t\tpp = nfp6000_mu_emu(cpp_id);\n\telse if (address < 0x9800000000ULL)\n\t\tpp = nfp6000_mu_ctm(cpp_id);\n\telse if (address < 0x9C00000000ULL)\n\t\tpp = nfp6000_mu_emu(cpp_id);\n\telse if (address < 0xA000000000ULL)\n\t\tpp = nfp6000_mu_imu(cpp_id);\n\telse\n\t\tpp = nfp6000_mu_ctm(cpp_id);\n\n\treturn pp;\n}\n\nstatic int nfp6000_ila(u32 cpp_id)\n{\n\tswitch (cpp_id & NFP_CPP_ID(0, ~0, ~0)) {\n\tAT(0, 1,   0, P32);\t \n\tAT(2, 0,   0, P32);\t \n\tAT(3, 0, P32,   0);\t \n\tdefault:\n\t\treturn target_rw(cpp_id, P32, 48, 4);\n\t}\n}\n\nstatic int nfp6000_pci(u32 cpp_id)\n{\n\tswitch (cpp_id & NFP_CPP_ID(0, ~0, ~0)) {\n\tAT(2, 0,   0, P32);\n\tAT(3, 0, P32,   0);\n\tdefault:\n\t\treturn target_rw(cpp_id, P32, 4, 4);\n\t}\n}\n\nstatic int nfp6000_crypto(u32 cpp_id)\n{\n\tswitch (cpp_id & NFP_CPP_ID(0, ~0, ~0)) {\n\tAT(2, 0, P64,   0);\n\tdefault:\n\t\treturn target_rw(cpp_id, P64, 12, 4);\n\t}\n}\n\nstatic int nfp6000_cap_xpb(u32 cpp_id)\n{\n\tswitch (cpp_id & NFP_CPP_ID(0, ~0, ~0)) {\n\tAT(0, 1,   0, P32);  \n\tAT(0, 2, P32,   0);  \n\tAT(1, 1, P32,   0);  \n\tAT(1, 2, P32,   0);  \n\tAT(2, 0,   0, P32);  \n\tAT(2, 1,   0, P32);  \n\tAT(2, 2,   0, P32);  \n\tAT(2, 3,   0, P32);  \n\tAT(3, 0, P32,   0);  \n\tAT(3, 1, P32,   0);  \n\tAT(3, 2, P32,   0);  \n\tAT(3, 3, P32,   0);  \n\tAT(NFP_CPP_ACTION_RW, 1, P32, P32);\n\tdefault:\n\t\treturn target_rw(cpp_id, P32, 1, 63);\n\t}\n}\n\nstatic int nfp6000_cls(u32 cpp_id)\n{\n\tswitch (cpp_id & NFP_CPP_ID(0, ~0, ~0)) {\n\tAT(0, 3, P32,  0);  \n\tAT(2, 0, P32,  0);  \n\tAT(2, 1, P32,  0);  \n\tAT(4, 0, P32,  0);  \n\tAT(4, 1, P32,  0);  \n\tAT(6, 0, P32,  0);  \n\tAT(6, 1, P32,  0);  \n\tAT(6, 2, P32,  0);  \n\tAT(8, 2, P32,  0);  \n\tAT(8, 3, P32,  0);  \n\tAT(9, 0,  0, P32);  \n\tAT(9, 1,  0, P32);  \n\tAT(9, 2,  0, P32);  \n\tAT(9, 3,  0, P32);  \n\tAT(10, 0, P32,  0);  \n\tAT(10, 2, P32,  0);  \n\tAT(14, 0,  P32, 0);  \n\tAT(15, 1,  0, P32);  \n\tAT(17, 2, P32,  0);  \n\tAT(24, 0,  0, P32);  \n\tAT(24, 1, P32,  0);  \n\tAT(25, 0,  0, P32);  \n\tAT(25, 1, P32,  0);  \n\tdefault:\n\t\treturn target_rw(cpp_id, P32, 0, 64);\n\t}\n}\n\nint nfp_target_pushpull(u32 cpp_id, u64 address)\n{\n\tswitch (NFP_CPP_ID_TARGET_of(cpp_id)) {\n\tcase NFP_CPP_TARGET_NBI:\n\t\treturn nfp6000_nbi(cpp_id, address);\n\tcase NFP_CPP_TARGET_QDR:\n\t\treturn target_rw(cpp_id, P32, 24, 4);\n\tcase NFP_CPP_TARGET_ILA:\n\t\treturn nfp6000_ila(cpp_id);\n\tcase NFP_CPP_TARGET_MU:\n\t\treturn nfp6000_mu(cpp_id, address);\n\tcase NFP_CPP_TARGET_PCIE:\n\t\treturn nfp6000_pci(cpp_id);\n\tcase NFP_CPP_TARGET_ARM:\n\t\tif (address < 0x10000)\n\t\t\treturn target_rw(cpp_id, P64, 1, 1);\n\t\telse\n\t\t\treturn target_rw(cpp_id, P32, 1, 1);\n\tcase NFP_CPP_TARGET_CRYPTO:\n\t\treturn nfp6000_crypto(cpp_id);\n\tcase NFP_CPP_TARGET_CT_XPB:\n\t\treturn nfp6000_cap_xpb(cpp_id);\n\tcase NFP_CPP_TARGET_CLS:\n\t\treturn nfp6000_cls(cpp_id);\n\tcase 0:\n\t\treturn target_rw(cpp_id, P32, 4, 4);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\n#undef AT\n#undef P32\n#undef P64\n\n \n\n#define _NIC_NFP6000_MU_LOCALITY_DIRECT     2\n\nstatic int nfp_decode_basic(u64 addr, int *dest_island, int cpp_tgt,\n\t\t\t    int mode, bool addr40, int isld1, int isld0)\n{\n\tint iid_lsb, idx_lsb;\n\n\t \n\tif (cpp_tgt == NFP_CPP_TARGET_MU || cpp_tgt == NFP_CPP_TARGET_CT_XPB)\n\t\treturn -EINVAL;\n\n\tswitch (mode) {\n\tcase 0:\n\t\t \n\t\tiid_lsb = addr40 ? 34 : 26;\n\t\t*dest_island = (addr >> iid_lsb) & 0x3F;\n\t\treturn 0;\n\tcase 1:\n\t\t \n\t\tidx_lsb = addr40 ? 39 : 31;\n\t\tif (addr & BIT_ULL(idx_lsb))\n\t\t\t*dest_island = isld1;\n\t\telse\n\t\t\t*dest_island = isld0;\n\n\t\treturn 0;\n\tcase 2:\n\t\t \n\t\tisld0 &= ~1;\n\t\tisld1 &= ~1;\n\n\t\tidx_lsb = addr40 ? 39 : 31;\n\t\tiid_lsb = idx_lsb - 1;\n\n\t\tif (addr & BIT_ULL(idx_lsb))\n\t\t\t*dest_island = isld1 | (int)((addr >> iid_lsb) & 1);\n\t\telse\n\t\t\t*dest_island = isld0 | (int)((addr >> iid_lsb) & 1);\n\n\t\treturn 0;\n\tcase 3:\n\t\t \n\t\tisld0 &= ~3;\n\t\tisld1 &= ~3;\n\n\t\tidx_lsb = addr40 ? 39 : 31;\n\t\tiid_lsb = idx_lsb - 2;\n\n\t\tif (addr & BIT_ULL(idx_lsb))\n\t\t\t*dest_island = isld1 | (int)((addr >> iid_lsb) & 3);\n\t\telse\n\t\t\t*dest_island = isld0 | (int)((addr >> iid_lsb) & 3);\n\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int nfp_encode_basic_qdr(u64 addr, int dest_island, int cpp_tgt,\n\t\t\t\tint mode, bool addr40, int isld1, int isld0)\n{\n\tint v, ret;\n\n\t \n\tret = nfp_decode_basic(addr, &v, cpp_tgt, mode, addr40, isld1, isld0);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (dest_island != -1 && dest_island != v)\n\t\treturn -EINVAL;\n\n\t \n\treturn 0;\n}\n\n \nstatic int nfp_encode_basic_search(u64 *addr, int dest_island, int *isld,\n\t\t\t\t   int iid_lsb, int idx_lsb, int v_max)\n{\n\tint i, v;\n\n\tfor (i = 0; i < 2; i++)\n\t\tfor (v = 0; v < v_max; v++) {\n\t\t\tif (dest_island != (isld[i] | v))\n\t\t\t\tcontinue;\n\n\t\t\t*addr &= ~GENMASK_ULL(idx_lsb, iid_lsb);\n\t\t\t*addr |= ((u64)i << idx_lsb);\n\t\t\t*addr |= ((u64)v << iid_lsb);\n\t\t\treturn 0;\n\t\t}\n\n\treturn -ENODEV;\n}\n\n \nstatic int nfp_encode_basic(u64 *addr, int dest_island, int cpp_tgt,\n\t\t\t    int mode, bool addr40, int isld1, int isld0)\n{\n\tint iid_lsb, idx_lsb;\n\tint isld[2];\n\tu64 v64;\n\n\tisld[0] = isld0;\n\tisld[1] = isld1;\n\n\t \n\tif (cpp_tgt == NFP_CPP_TARGET_MU || cpp_tgt == NFP_CPP_TARGET_CT_XPB)\n\t\treturn -EINVAL;\n\n\tswitch (mode) {\n\tcase 0:\n\t\tif (cpp_tgt == NFP_CPP_TARGET_QDR && !addr40)\n\t\t\t \n\t\t\treturn nfp_encode_basic_qdr(*addr, cpp_tgt, dest_island,\n\t\t\t\t\t\t    mode, addr40, isld1, isld0);\n\n\t\tiid_lsb = addr40 ? 34 : 26;\n\t\t \n\t\tv64 = GENMASK_ULL(iid_lsb + 5, iid_lsb);\n\t\t*addr &= ~v64;\n\t\t*addr |= ((u64)dest_island << iid_lsb) & v64;\n\t\treturn 0;\n\tcase 1:\n\t\tif (cpp_tgt == NFP_CPP_TARGET_QDR && !addr40)\n\t\t\treturn nfp_encode_basic_qdr(*addr, cpp_tgt, dest_island,\n\t\t\t\t\t\t    mode, addr40, isld1, isld0);\n\n\t\tidx_lsb = addr40 ? 39 : 31;\n\t\tif (dest_island == isld0) {\n\t\t\t \n\t\t\t*addr &= ~BIT_ULL(idx_lsb);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (dest_island == isld1) {\n\t\t\t \n\t\t\t*addr |= BIT_ULL(idx_lsb);\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn -ENODEV;\n\tcase 2:\n\t\t \n\t\tif (cpp_tgt == NFP_CPP_TARGET_QDR && !addr40)\n\t\t\t \n\t\t\treturn nfp_encode_basic_qdr(*addr, cpp_tgt, dest_island,\n\t\t\t\t\t\t    mode, addr40, isld1, isld0);\n\n\t\t \n\t\tisld[0] &= ~1;\n\t\tisld[1] &= ~1;\n\n\t\tidx_lsb = addr40 ? 39 : 31;\n\t\tiid_lsb = idx_lsb - 1;\n\n\t\treturn nfp_encode_basic_search(addr, dest_island, isld,\n\t\t\t\t\t       iid_lsb, idx_lsb, 2);\n\tcase 3:\n\t\tif (cpp_tgt == NFP_CPP_TARGET_QDR && !addr40)\n\t\t\t \n\t\t\treturn nfp_encode_basic_qdr(*addr, cpp_tgt, dest_island,\n\t\t\t\t\t\t    mode, addr40, isld1, isld0);\n\n\t\tisld[0] &= ~3;\n\t\tisld[1] &= ~3;\n\n\t\tidx_lsb = addr40 ? 39 : 31;\n\t\tiid_lsb = idx_lsb - 2;\n\n\t\treturn nfp_encode_basic_search(addr, dest_island, isld,\n\t\t\t\t\t       iid_lsb, idx_lsb, 4);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int nfp_encode_mu(u64 *addr, int dest_island, int mode,\n\t\t\t bool addr40, int isld1, int isld0)\n{\n\tint iid_lsb, idx_lsb, locality_lsb;\n\tint isld[2];\n\tu64 v64;\n\tint da;\n\n\tisld[0] = isld0;\n\tisld[1] = isld1;\n\tlocality_lsb = nfp_cppat_mu_locality_lsb(mode, addr40);\n\n\tif (((*addr >> locality_lsb) & 3) == _NIC_NFP6000_MU_LOCALITY_DIRECT)\n\t\tda = 1;\n\telse\n\t\tda = 0;\n\n\tswitch (mode) {\n\tcase 0:\n\t\tiid_lsb = addr40 ? 32 : 24;\n\t\tv64 = GENMASK_ULL(iid_lsb + 5, iid_lsb);\n\t\t*addr &= ~v64;\n\t\t*addr |= (((u64)dest_island) << iid_lsb) & v64;\n\t\treturn 0;\n\tcase 1:\n\t\tif (da) {\n\t\t\tiid_lsb = addr40 ? 32 : 24;\n\t\t\tv64 = GENMASK_ULL(iid_lsb + 5, iid_lsb);\n\t\t\t*addr &= ~v64;\n\t\t\t*addr |= (((u64)dest_island) << iid_lsb) & v64;\n\t\t\treturn 0;\n\t\t}\n\n\t\tidx_lsb = addr40 ? 37 : 29;\n\t\tif (dest_island == isld0) {\n\t\t\t*addr &= ~BIT_ULL(idx_lsb);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (dest_island == isld1) {\n\t\t\t*addr |= BIT_ULL(idx_lsb);\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn -ENODEV;\n\tcase 2:\n\t\tif (da) {\n\t\t\tiid_lsb = addr40 ? 32 : 24;\n\t\t\tv64 = GENMASK_ULL(iid_lsb + 5, iid_lsb);\n\t\t\t*addr &= ~v64;\n\t\t\t*addr |= (((u64)dest_island) << iid_lsb) & v64;\n\t\t\treturn 0;\n\t\t}\n\n\t\t \n\t\tisld[0] &= ~1;\n\t\tisld[1] &= ~1;\n\n\t\tidx_lsb = addr40 ? 37 : 29;\n\t\tiid_lsb = idx_lsb - 1;\n\n\t\treturn nfp_encode_basic_search(addr, dest_island, isld,\n\t\t\t\t\t       iid_lsb, idx_lsb, 2);\n\tcase 3:\n\t\t \n\t\tif (dest_island > 0 && (dest_island < 24 || dest_island > 26)) {\n\t\t\t*addr |= ((u64)_NIC_NFP6000_MU_LOCALITY_DIRECT)\n\t\t\t\t\t\t\t<< locality_lsb;\n\t\t\tda = 1;\n\t\t}\n\n\t\tif (da) {\n\t\t\tiid_lsb = addr40 ? 32 : 24;\n\t\t\tv64 = GENMASK_ULL(iid_lsb + 5, iid_lsb);\n\t\t\t*addr &= ~v64;\n\t\t\t*addr |= (((u64)dest_island) << iid_lsb) & v64;\n\t\t\treturn 0;\n\t\t}\n\n\t\tisld[0] &= ~3;\n\t\tisld[1] &= ~3;\n\n\t\tidx_lsb = addr40 ? 37 : 29;\n\t\tiid_lsb = idx_lsb - 2;\n\n\t\treturn nfp_encode_basic_search(addr, dest_island, isld,\n\t\t\t\t\t       iid_lsb, idx_lsb, 4);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int nfp_cppat_addr_encode(u64 *addr, int dest_island, int cpp_tgt,\n\t\t\t\t int mode, bool addr40, int isld1, int isld0)\n{\n\tswitch (cpp_tgt) {\n\tcase NFP_CPP_TARGET_NBI:\n\tcase NFP_CPP_TARGET_QDR:\n\tcase NFP_CPP_TARGET_ILA:\n\tcase NFP_CPP_TARGET_PCIE:\n\tcase NFP_CPP_TARGET_ARM:\n\tcase NFP_CPP_TARGET_CRYPTO:\n\tcase NFP_CPP_TARGET_CLS:\n\t\treturn nfp_encode_basic(addr, dest_island, cpp_tgt, mode,\n\t\t\t\t\taddr40, isld1, isld0);\n\n\tcase NFP_CPP_TARGET_MU:\n\t\treturn nfp_encode_mu(addr, dest_island, mode,\n\t\t\t\t     addr40, isld1, isld0);\n\n\tcase NFP_CPP_TARGET_CT_XPB:\n\t\tif (mode != 1 || addr40)\n\t\t\treturn -EINVAL;\n\t\t*addr &= ~GENMASK_ULL(29, 24);\n\t\t*addr |= ((u64)dest_island << 24) & GENMASK_ULL(29, 24);\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nint nfp_target_cpp(u32 cpp_island_id, u64 cpp_island_address,\n\t\t   u32 *cpp_target_id, u64 *cpp_target_address,\n\t\t   const u32 *imb_table)\n{\n\tconst int island = NFP_CPP_ID_ISLAND_of(cpp_island_id);\n\tconst int target = NFP_CPP_ID_TARGET_of(cpp_island_id);\n\tu32 imb;\n\tint err;\n\n\tif (target < 0 || target >= 16) {\n\t\tpr_err(\"Invalid CPP target: %d\\n\", target);\n\t\treturn -EINVAL;\n\t}\n\n\tif (island == 0) {\n\t\t \n\t\t*cpp_target_id = cpp_island_id;\n\t\t*cpp_target_address = cpp_island_address;\n\t\treturn 0;\n\t}\n\n\t \n\tif (!imb_table)\n\t\treturn -EINVAL;\n\n\timb = imb_table[target];\n\n\t*cpp_target_address = cpp_island_address;\n\terr = nfp_cppat_addr_encode(cpp_target_address, island, target,\n\t\t\t\t    ((imb >> 13) & 7), ((imb >> 12) & 1),\n\t\t\t\t    ((imb >> 6)  & 0x3f), ((imb >> 0)  & 0x3f));\n\tif (err) {\n\t\tpr_err(\"Can't encode CPP address: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\t*cpp_target_id = NFP_CPP_ID(target,\n\t\t\t\t    NFP_CPP_ID_ACTION_of(cpp_island_id),\n\t\t\t\t    NFP_CPP_ID_TOKEN_of(cpp_island_id));\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}