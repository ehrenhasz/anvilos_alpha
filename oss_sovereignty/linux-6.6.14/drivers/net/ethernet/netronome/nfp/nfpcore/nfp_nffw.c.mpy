{
  "module_name": "nfp_nffw.c",
  "hash_id": "c6d9fc1e10935532bdbb503ecf5ab825ee089aecfe0d83dd61b3a702fb24aece",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/netronome/nfp/nfpcore/nfp_nffw.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/kernel.h>\n#include <linux/slab.h>\n\n#include \"nfp.h\"\n#include \"nfp_cpp.h\"\n#include \"nfp_nffw.h\"\n#include \"nfp6000/nfp6000.h\"\n\n \n#define NFFW_FWID_EXT   3  \n#define NFFW_FWID_BASE  4\n\n#define NFFW_FWID_ALL   255\n\n \n#define NFFW_INFO_VERSION_CURRENT 2\n\n \n#define NFFW_MEINFO_CNT_V1 120\n#define NFFW_FWINFO_CNT_V1 120\n#define NFFW_MEINFO_CNT_V2 200\n#define NFFW_FWINFO_CNT_V2 200\n\n \n\n \nstruct nffw_meinfo {\n\t__le32 ctxmask__fwid__meid;\n};\n\nstruct nffw_fwinfo {\n\t__le32 loaded__mu_da__mip_off_hi;\n\t__le32 mip_cppid;  \n\t__le32 mip_offset_lo;\n};\n\nstruct nfp_nffw_info_v1 {\n\tstruct nffw_meinfo meinfo[NFFW_MEINFO_CNT_V1];\n\tstruct nffw_fwinfo fwinfo[NFFW_FWINFO_CNT_V1];\n};\n\nstruct nfp_nffw_info_v2 {\n\tstruct nffw_meinfo meinfo[NFFW_MEINFO_CNT_V2];\n\tstruct nffw_fwinfo fwinfo[NFFW_FWINFO_CNT_V2];\n};\n\n \nstruct nfp_nffw_info_data {\n\t__le32 flags[2];\n\tunion {\n\t\tstruct nfp_nffw_info_v1 v1;\n\t\tstruct nfp_nffw_info_v2 v2;\n\t} info;\n};\n\nstruct nfp_nffw_info {\n\tstruct nfp_cpp *cpp;\n\tstruct nfp_resource *res;\n\n\tstruct nfp_nffw_info_data fwinf;\n};\n\n \nstatic u32 nffw_res_info_version_get(const struct nfp_nffw_info_data *res)\n{\n\treturn (le32_to_cpu(res->flags[0]) >> 16) & 0xfff;\n}\n\n \nstatic u32 nffw_res_flg_init_get(const struct nfp_nffw_info_data *res)\n{\n\treturn (le32_to_cpu(res->flags[0]) >> 0) & 1;\n}\n\n \nstatic u32 nffw_fwinfo_loaded_get(const struct nffw_fwinfo *fi)\n{\n\treturn (le32_to_cpu(fi->loaded__mu_da__mip_off_hi) >> 31) & 1;\n}\n\n \nstatic u32 nffw_fwinfo_mip_cppid_get(const struct nffw_fwinfo *fi)\n{\n\treturn le32_to_cpu(fi->mip_cppid);\n}\n\n \nstatic u32 nffw_fwinfo_mip_mu_da_get(const struct nffw_fwinfo *fi)\n{\n\treturn (le32_to_cpu(fi->loaded__mu_da__mip_off_hi) >> 8) & 1;\n}\n\n \nstatic u64 nffw_fwinfo_mip_offset_get(const struct nffw_fwinfo *fi)\n{\n\tu64 mip_off_hi = le32_to_cpu(fi->loaded__mu_da__mip_off_hi);\n\n\treturn (mip_off_hi & 0xFF) << 32 | le32_to_cpu(fi->mip_offset_lo);\n}\n\nstatic unsigned int\nnffw_res_fwinfos(struct nfp_nffw_info_data *fwinf, struct nffw_fwinfo **arr)\n{\n\t \n\tswitch (nffw_res_info_version_get(fwinf)) {\n\tcase 0:\n\tcase 1:\n\t\t*arr = &fwinf->info.v1.fwinfo[0];\n\t\treturn NFFW_FWINFO_CNT_V1;\n\tcase 2:\n\t\t*arr = &fwinf->info.v2.fwinfo[0];\n\t\treturn NFFW_FWINFO_CNT_V2;\n\tdefault:\n\t\t*arr = NULL;\n\t\treturn 0;\n\t}\n}\n\n \nstruct nfp_nffw_info *nfp_nffw_info_open(struct nfp_cpp *cpp)\n{\n\tstruct nfp_nffw_info_data *fwinf;\n\tstruct nfp_nffw_info *state;\n\tu32 info_ver;\n\tint err;\n\n\tstate = kzalloc(sizeof(*state), GFP_KERNEL);\n\tif (!state)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tstate->res = nfp_resource_acquire(cpp, NFP_RESOURCE_NFP_NFFW);\n\tif (IS_ERR(state->res))\n\t\tgoto err_free;\n\n\tfwinf = &state->fwinf;\n\n\tif (sizeof(*fwinf) > nfp_resource_size(state->res))\n\t\tgoto err_release;\n\n\terr = nfp_cpp_read(cpp, nfp_resource_cpp_id(state->res),\n\t\t\t   nfp_resource_address(state->res),\n\t\t\t   fwinf, sizeof(*fwinf));\n\tif (err < (int)sizeof(*fwinf))\n\t\tgoto err_release;\n\n\tif (!nffw_res_flg_init_get(fwinf))\n\t\tgoto err_release;\n\n\tinfo_ver = nffw_res_info_version_get(fwinf);\n\tif (info_ver > NFFW_INFO_VERSION_CURRENT)\n\t\tgoto err_release;\n\n\tstate->cpp = cpp;\n\treturn state;\n\nerr_release:\n\tnfp_resource_release(state->res);\nerr_free:\n\tkfree(state);\n\treturn ERR_PTR(-EIO);\n}\n\n \nvoid nfp_nffw_info_close(struct nfp_nffw_info *state)\n{\n\tnfp_resource_release(state->res);\n\tkfree(state);\n}\n\n \nstatic struct nffw_fwinfo *nfp_nffw_info_fwid_first(struct nfp_nffw_info *state)\n{\n\tstruct nffw_fwinfo *fwinfo;\n\tunsigned int cnt, i;\n\n\tcnt = nffw_res_fwinfos(&state->fwinf, &fwinfo);\n\tif (!cnt)\n\t\treturn NULL;\n\n\tfor (i = 0; i < cnt; i++)\n\t\tif (nffw_fwinfo_loaded_get(&fwinfo[i]))\n\t\t\treturn &fwinfo[i];\n\n\treturn NULL;\n}\n\n \nint nfp_nffw_info_mip_first(struct nfp_nffw_info *state, u32 *cpp_id, u64 *off)\n{\n\tstruct nffw_fwinfo *fwinfo;\n\n\tfwinfo = nfp_nffw_info_fwid_first(state);\n\tif (!fwinfo)\n\t\treturn -EINVAL;\n\n\t*cpp_id = nffw_fwinfo_mip_cppid_get(fwinfo);\n\t*off = nffw_fwinfo_mip_offset_get(fwinfo);\n\n\tif (nffw_fwinfo_mip_mu_da_get(fwinfo)) {\n\t\tint locality_off = nfp_cpp_mu_locality_lsb(state->cpp);\n\n\t\t*off &= ~(NFP_MU_ADDR_ACCESS_TYPE_MASK << locality_off);\n\t\t*off |= NFP_MU_ADDR_ACCESS_TYPE_DIRECT << locality_off;\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}