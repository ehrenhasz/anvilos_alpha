{
  "module_name": "nfp_mutex.c",
  "hash_id": "c1260345e7e754365e36f31f6500284822c56f11571310e82514d9f296010c0e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/netronome/nfp/nfpcore/nfp_mutex.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/jiffies.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n\n#include \"nfp_cpp.h\"\n#include \"nfp6000/nfp6000.h\"\n\nstruct nfp_cpp_mutex {\n\tstruct nfp_cpp *cpp;\n\tint target;\n\tu16 depth;\n\tunsigned long long address;\n\tu32 key;\n};\n\nstatic u32 nfp_mutex_locked(u16 interface)\n{\n\treturn (u32)interface << 16 | 0x000f;\n}\n\nstatic u32 nfp_mutex_unlocked(u16 interface)\n{\n\treturn (u32)interface << 16 | 0x0000;\n}\n\nstatic u32 nfp_mutex_owner(u32 val)\n{\n\treturn val >> 16;\n}\n\nstatic bool nfp_mutex_is_locked(u32 val)\n{\n\treturn (val & 0xffff) == 0x000f;\n}\n\nstatic bool nfp_mutex_is_unlocked(u32 val)\n{\n\treturn (val & 0xffff) == 0000;\n}\n\n \n#define NFP_MUTEX_DEPTH_MAX         0xffff\n\nstatic int\nnfp_cpp_mutex_validate(u16 interface, int *target, unsigned long long address)\n{\n\t \n\tif (NFP_CPP_INTERFACE_TYPE_of(interface) ==\n\t    NFP_CPP_INTERFACE_TYPE_INVALID)\n\t\treturn -EINVAL;\n\n\t \n\tif (address & 7)\n\t\treturn -EINVAL;\n\n\tif (*target != NFP_CPP_TARGET_MU)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n \nint nfp_cpp_mutex_init(struct nfp_cpp *cpp,\n\t\t       int target, unsigned long long address, u32 key)\n{\n\tconst u32 muw = NFP_CPP_ID(target, 4, 0);     \n\tu16 interface = nfp_cpp_interface(cpp);\n\tint err;\n\n\terr = nfp_cpp_mutex_validate(interface, &target, address);\n\tif (err)\n\t\treturn err;\n\n\terr = nfp_cpp_writel(cpp, muw, address + 4, key);\n\tif (err)\n\t\treturn err;\n\n\terr = nfp_cpp_writel(cpp, muw, address, nfp_mutex_locked(interface));\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\n \nstruct nfp_cpp_mutex *nfp_cpp_mutex_alloc(struct nfp_cpp *cpp, int target,\n\t\t\t\t\t  unsigned long long address, u32 key)\n{\n\tconst u32 mur = NFP_CPP_ID(target, 3, 0);     \n\tu16 interface = nfp_cpp_interface(cpp);\n\tstruct nfp_cpp_mutex *mutex;\n\tint err;\n\tu32 tmp;\n\n\terr = nfp_cpp_mutex_validate(interface, &target, address);\n\tif (err)\n\t\treturn NULL;\n\n\terr = nfp_cpp_readl(cpp, mur, address + 4, &tmp);\n\tif (err < 0)\n\t\treturn NULL;\n\n\tif (tmp != key)\n\t\treturn NULL;\n\n\tmutex = kzalloc(sizeof(*mutex), GFP_KERNEL);\n\tif (!mutex)\n\t\treturn NULL;\n\n\tmutex->cpp = cpp;\n\tmutex->target = target;\n\tmutex->address = address;\n\tmutex->key = key;\n\tmutex->depth = 0;\n\n\treturn mutex;\n}\n\n \nvoid nfp_cpp_mutex_free(struct nfp_cpp_mutex *mutex)\n{\n\tkfree(mutex);\n}\n\n \nint nfp_cpp_mutex_lock(struct nfp_cpp_mutex *mutex)\n{\n\tunsigned long warn_at = jiffies + NFP_MUTEX_WAIT_FIRST_WARN * HZ;\n\tunsigned long err_at = jiffies + NFP_MUTEX_WAIT_ERROR * HZ;\n\tunsigned int timeout_ms = 1;\n\tint err;\n\n\t \n\tfor (;;) {\n\t\terr = nfp_cpp_mutex_trylock(mutex);\n\t\tif (err != -EBUSY)\n\t\t\tbreak;\n\n\t\terr = msleep_interruptible(timeout_ms);\n\t\tif (err != 0) {\n\t\t\tnfp_info(mutex->cpp,\n\t\t\t\t \"interrupted waiting for NFP mutex\\n\");\n\t\t\treturn -ERESTARTSYS;\n\t\t}\n\n\t\tif (time_is_before_eq_jiffies(warn_at)) {\n\t\t\twarn_at = jiffies + NFP_MUTEX_WAIT_NEXT_WARN * HZ;\n\t\t\tnfp_warn(mutex->cpp,\n\t\t\t\t \"Warning: waiting for NFP mutex [depth:%hd target:%d addr:%llx key:%08x]\\n\",\n\t\t\t\t mutex->depth,\n\t\t\t\t mutex->target, mutex->address, mutex->key);\n\t\t}\n\t\tif (time_is_before_eq_jiffies(err_at)) {\n\t\t\tnfp_err(mutex->cpp, \"Error: mutex wait timed out\\n\");\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\n\treturn err;\n}\n\n \nint nfp_cpp_mutex_unlock(struct nfp_cpp_mutex *mutex)\n{\n\tconst u32 muw = NFP_CPP_ID(mutex->target, 4, 0);     \n\tconst u32 mur = NFP_CPP_ID(mutex->target, 3, 0);     \n\tstruct nfp_cpp *cpp = mutex->cpp;\n\tu32 key, value;\n\tu16 interface;\n\tint err;\n\n\tinterface = nfp_cpp_interface(cpp);\n\n\tif (mutex->depth > 1) {\n\t\tmutex->depth--;\n\t\treturn 0;\n\t}\n\n\terr = nfp_cpp_readl(mutex->cpp, mur, mutex->address + 4, &key);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (key != mutex->key)\n\t\treturn -EPERM;\n\n\terr = nfp_cpp_readl(mutex->cpp, mur, mutex->address, &value);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (value != nfp_mutex_locked(interface))\n\t\treturn -EACCES;\n\n\terr = nfp_cpp_writel(cpp, muw, mutex->address,\n\t\t\t     nfp_mutex_unlocked(interface));\n\tif (err < 0)\n\t\treturn err;\n\n\tmutex->depth = 0;\n\treturn 0;\n}\n\n \nint nfp_cpp_mutex_trylock(struct nfp_cpp_mutex *mutex)\n{\n\tconst u32 muw = NFP_CPP_ID(mutex->target, 4, 0);     \n\tconst u32 mus = NFP_CPP_ID(mutex->target, 5, 3);     \n\tconst u32 mur = NFP_CPP_ID(mutex->target, 3, 0);     \n\tstruct nfp_cpp *cpp = mutex->cpp;\n\tu32 key, value, tmp;\n\tint err;\n\n\tif (mutex->depth > 0) {\n\t\tif (mutex->depth == NFP_MUTEX_DEPTH_MAX)\n\t\t\treturn -E2BIG;\n\t\tmutex->depth++;\n\t\treturn 0;\n\t}\n\n\t \n\terr = nfp_cpp_readl(cpp, mur, mutex->address + 4, &key);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (key != mutex->key)\n\t\treturn -EPERM;\n\n\t \n\tvalue = nfp_mutex_locked(nfp_cpp_interface(cpp));\n\n\t \n\terr = nfp_cpp_readl(cpp, mus, mutex->address, &tmp);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tif (nfp_mutex_is_unlocked(tmp)) {\n\t\t \n\n\t\t \n\t\terr = nfp_cpp_writel(cpp, muw, mutex->address, value);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tmutex->depth = 1;\n\t\treturn 0;\n\t}\n\n\treturn nfp_mutex_is_locked(tmp) ? -EBUSY : -EINVAL;\n}\n\n \nint nfp_cpp_mutex_reclaim(struct nfp_cpp *cpp, int target,\n\t\t\t  unsigned long long address)\n{\n\tconst u32 mur = NFP_CPP_ID(target, 3, 0);\t \n\tconst u32 muw = NFP_CPP_ID(target, 4, 0);\t \n\tu16 interface = nfp_cpp_interface(cpp);\n\tint err;\n\tu32 tmp;\n\n\terr = nfp_cpp_mutex_validate(interface, &target, address);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = nfp_cpp_readl(cpp, mur, address, &tmp);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (nfp_mutex_is_unlocked(tmp) || nfp_mutex_owner(tmp) != interface)\n\t\treturn 0;\n\n\t \n\terr = nfp_cpp_writel(cpp, muw, address, nfp_mutex_unlocked(interface));\n\tif (err < 0)\n\t\treturn err;\n\n\treturn 1;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}