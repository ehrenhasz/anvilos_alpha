{
  "module_name": "nfp_rtsym.c",
  "hash_id": "d27b328ad94db4119d9c5cc694e2c85c8bc178e9f7865e39e55c61c2ec0db1f1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/netronome/nfp/nfpcore/nfp_rtsym.c",
  "human_readable_source": "\n \n\n \n\n#include <asm/unaligned.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/io-64-nonatomic-hi-lo.h>\n\n#include \"nfp.h\"\n#include \"nfp_cpp.h\"\n#include \"nfp_nffw.h\"\n#include \"nfp6000/nfp6000.h\"\n\n \n#define SYM_TGT_LMEM\t\t0\n#define SYM_TGT_EMU_CACHE\t0x17\n\nstruct nfp_rtsym_entry {\n\tu8\ttype;\n\tu8\ttarget;\n\tu8\tisland;\n\tu8\taddr_hi;\n\t__le32\taddr_lo;\n\t__le16\tname;\n\tu8\tmenum;\n\tu8\tsize_hi;\n\t__le32\tsize_lo;\n};\n\nstruct nfp_rtsym_table {\n\tstruct nfp_cpp *cpp;\n\tint num;\n\tchar *strtab;\n\tstruct nfp_rtsym symtab[];\n};\n\nstatic int nfp_meid(u8 island_id, u8 menum)\n{\n\treturn (island_id & 0x3F) == island_id && menum < 12 ?\n\t\t(island_id << 4) | (menum + 4) : -1;\n}\n\nstatic void\nnfp_rtsym_sw_entry_init(struct nfp_rtsym_table *cache, u32 strtab_size,\n\t\t\tstruct nfp_rtsym *sw, struct nfp_rtsym_entry *fw)\n{\n\tsw->type = fw->type;\n\tsw->name = cache->strtab + le16_to_cpu(fw->name) % strtab_size;\n\tsw->addr = ((u64)fw->addr_hi << 32) | le32_to_cpu(fw->addr_lo);\n\tsw->size = ((u64)fw->size_hi << 32) | le32_to_cpu(fw->size_lo);\n\n\tswitch (fw->target) {\n\tcase SYM_TGT_LMEM:\n\t\tsw->target = NFP_RTSYM_TARGET_LMEM;\n\t\tbreak;\n\tcase SYM_TGT_EMU_CACHE:\n\t\tsw->target = NFP_RTSYM_TARGET_EMU_CACHE;\n\t\tbreak;\n\tdefault:\n\t\tsw->target = fw->target;\n\t\tbreak;\n\t}\n\n\tif (fw->menum != 0xff)\n\t\tsw->domain = nfp_meid(fw->island, fw->menum);\n\telse if (fw->island != 0xff)\n\t\tsw->domain = fw->island;\n\telse\n\t\tsw->domain = -1;\n}\n\nstruct nfp_rtsym_table *nfp_rtsym_table_read(struct nfp_cpp *cpp)\n{\n\tstruct nfp_rtsym_table *rtbl;\n\tconst struct nfp_mip *mip;\n\n\tmip = nfp_mip_open(cpp);\n\trtbl = __nfp_rtsym_table_read(cpp, mip);\n\tnfp_mip_close(mip);\n\n\treturn rtbl;\n}\n\nstruct nfp_rtsym_table *\n__nfp_rtsym_table_read(struct nfp_cpp *cpp, const struct nfp_mip *mip)\n{\n\tconst u32 dram = NFP_CPP_ID(NFP_CPP_TARGET_MU, NFP_CPP_ACTION_RW, 0) |\n\t\tNFP_ISL_EMEM0;\n\tu32 strtab_addr, symtab_addr, strtab_size, symtab_size;\n\tstruct nfp_rtsym_entry *rtsymtab;\n\tstruct nfp_rtsym_table *cache;\n\tint err, n, size;\n\n\tif (!mip)\n\t\treturn NULL;\n\n\tnfp_mip_strtab(mip, &strtab_addr, &strtab_size);\n\tnfp_mip_symtab(mip, &symtab_addr, &symtab_size);\n\n\tif (!symtab_size || !strtab_size || symtab_size % sizeof(*rtsymtab))\n\t\treturn NULL;\n\n\t \n\tsymtab_size = round_up(symtab_size, 8);\n\tstrtab_size = round_up(strtab_size, 8);\n\n\trtsymtab = kmalloc(symtab_size, GFP_KERNEL);\n\tif (!rtsymtab)\n\t\treturn NULL;\n\n\tsize = sizeof(*cache);\n\tsize += symtab_size / sizeof(*rtsymtab) * sizeof(struct nfp_rtsym);\n\tsize +=\tstrtab_size + 1;\n\tcache = kmalloc(size, GFP_KERNEL);\n\tif (!cache)\n\t\tgoto exit_free_rtsym_raw;\n\n\tcache->cpp = cpp;\n\tcache->num = symtab_size / sizeof(*rtsymtab);\n\tcache->strtab = (void *)&cache->symtab[cache->num];\n\n\terr = nfp_cpp_read(cpp, dram, symtab_addr, rtsymtab, symtab_size);\n\tif (err != symtab_size)\n\t\tgoto exit_free_cache;\n\n\terr = nfp_cpp_read(cpp, dram, strtab_addr, cache->strtab, strtab_size);\n\tif (err != strtab_size)\n\t\tgoto exit_free_cache;\n\tcache->strtab[strtab_size] = '\\0';\n\n\tfor (n = 0; n < cache->num; n++)\n\t\tnfp_rtsym_sw_entry_init(cache, strtab_size,\n\t\t\t\t\t&cache->symtab[n], &rtsymtab[n]);\n\n\tkfree(rtsymtab);\n\n\treturn cache;\n\nexit_free_cache:\n\tkfree(cache);\nexit_free_rtsym_raw:\n\tkfree(rtsymtab);\n\treturn NULL;\n}\n\n \nint nfp_rtsym_count(struct nfp_rtsym_table *rtbl)\n{\n\tif (!rtbl)\n\t\treturn -EINVAL;\n\treturn rtbl->num;\n}\n\n \nconst struct nfp_rtsym *nfp_rtsym_get(struct nfp_rtsym_table *rtbl, int idx)\n{\n\tif (!rtbl)\n\t\treturn NULL;\n\tif (idx >= rtbl->num)\n\t\treturn NULL;\n\n\treturn &rtbl->symtab[idx];\n}\n\n \nconst struct nfp_rtsym *\nnfp_rtsym_lookup(struct nfp_rtsym_table *rtbl, const char *name)\n{\n\tint n;\n\n\tif (!rtbl)\n\t\treturn NULL;\n\n\tfor (n = 0; n < rtbl->num; n++)\n\t\tif (strcmp(name, rtbl->symtab[n].name) == 0)\n\t\t\treturn &rtbl->symtab[n];\n\n\treturn NULL;\n}\n\nu64 nfp_rtsym_size(const struct nfp_rtsym *sym)\n{\n\tswitch (sym->type) {\n\tcase NFP_RTSYM_TYPE_NONE:\n\t\tpr_err(\"rtsym '%s': type NONE\\n\", sym->name);\n\t\treturn 0;\n\tdefault:\n\t\tpr_warn(\"rtsym '%s': unknown type: %d\\n\", sym->name, sym->type);\n\t\tfallthrough;\n\tcase NFP_RTSYM_TYPE_OBJECT:\n\tcase NFP_RTSYM_TYPE_FUNCTION:\n\t\treturn sym->size;\n\tcase NFP_RTSYM_TYPE_ABS:\n\t\treturn sizeof(u64);\n\t}\n}\n\nstatic int\nnfp_rtsym_to_dest(struct nfp_cpp *cpp, const struct nfp_rtsym *sym,\n\t\t  u8 action, u8 token, u64 off, u32 *cpp_id, u64 *addr)\n{\n\tif (sym->type != NFP_RTSYM_TYPE_OBJECT) {\n\t\tnfp_err(cpp, \"rtsym '%s': direct access to non-object rtsym\\n\",\n\t\t\tsym->name);\n\t\treturn -EINVAL;\n\t}\n\n\t*addr = sym->addr + off;\n\n\tif (sym->target == NFP_RTSYM_TARGET_EMU_CACHE) {\n\t\tint locality_off = nfp_cpp_mu_locality_lsb(cpp);\n\n\t\t*addr &= ~(NFP_MU_ADDR_ACCESS_TYPE_MASK << locality_off);\n\t\t*addr |= NFP_MU_ADDR_ACCESS_TYPE_DIRECT << locality_off;\n\n\t\t*cpp_id = NFP_CPP_ISLAND_ID(NFP_CPP_TARGET_MU, action, token,\n\t\t\t\t\t    sym->domain);\n\t} else if (sym->target < 0) {\n\t\tnfp_err(cpp, \"rtsym '%s': unhandled target encoding: %d\\n\",\n\t\t\tsym->name, sym->target);\n\t\treturn -EINVAL;\n\t} else {\n\t\t*cpp_id = NFP_CPP_ISLAND_ID(sym->target, action, token,\n\t\t\t\t\t    sym->domain);\n\t}\n\n\treturn 0;\n}\n\nint __nfp_rtsym_read(struct nfp_cpp *cpp, const struct nfp_rtsym *sym,\n\t\t     u8 action, u8 token, u64 off, void *buf, size_t len)\n{\n\tu64 sym_size = nfp_rtsym_size(sym);\n\tu32 cpp_id;\n\tu64 addr;\n\tint err;\n\n\tif (off > sym_size) {\n\t\tnfp_err(cpp, \"rtsym '%s': read out of bounds: off: %lld + len: %zd > size: %lld\\n\",\n\t\t\tsym->name, off, len, sym_size);\n\t\treturn -ENXIO;\n\t}\n\tlen = min_t(size_t, len, sym_size - off);\n\n\tif (sym->type == NFP_RTSYM_TYPE_ABS) {\n\t\tu8 tmp[8];\n\n\t\tput_unaligned_le64(sym->addr, tmp);\n\t\tmemcpy(buf, &tmp[off], len);\n\n\t\treturn len;\n\t}\n\n\terr = nfp_rtsym_to_dest(cpp, sym, action, token, off, &cpp_id, &addr);\n\tif (err)\n\t\treturn err;\n\n\treturn nfp_cpp_read(cpp, cpp_id, addr, buf, len);\n}\n\nint nfp_rtsym_read(struct nfp_cpp *cpp, const struct nfp_rtsym *sym, u64 off,\n\t\t   void *buf, size_t len)\n{\n\treturn __nfp_rtsym_read(cpp, sym, NFP_CPP_ACTION_RW, 0, off, buf, len);\n}\n\nint __nfp_rtsym_readl(struct nfp_cpp *cpp, const struct nfp_rtsym *sym,\n\t\t      u8 action, u8 token, u64 off, u32 *value)\n{\n\tu32 cpp_id;\n\tu64 addr;\n\tint err;\n\n\tif (off + 4 > nfp_rtsym_size(sym)) {\n\t\tnfp_err(cpp, \"rtsym '%s': readl out of bounds: off: %lld + 4 > size: %lld\\n\",\n\t\t\tsym->name, off, nfp_rtsym_size(sym));\n\t\treturn -ENXIO;\n\t}\n\n\terr = nfp_rtsym_to_dest(cpp, sym, action, token, off, &cpp_id, &addr);\n\tif (err)\n\t\treturn err;\n\n\treturn nfp_cpp_readl(cpp, cpp_id, addr, value);\n}\n\nint nfp_rtsym_readl(struct nfp_cpp *cpp, const struct nfp_rtsym *sym, u64 off,\n\t\t    u32 *value)\n{\n\treturn __nfp_rtsym_readl(cpp, sym, NFP_CPP_ACTION_RW, 0, off, value);\n}\n\nint __nfp_rtsym_readq(struct nfp_cpp *cpp, const struct nfp_rtsym *sym,\n\t\t      u8 action, u8 token, u64 off, u64 *value)\n{\n\tu32 cpp_id;\n\tu64 addr;\n\tint err;\n\n\tif (off + 8 > nfp_rtsym_size(sym)) {\n\t\tnfp_err(cpp, \"rtsym '%s': readq out of bounds: off: %lld + 8 > size: %lld\\n\",\n\t\t\tsym->name, off, nfp_rtsym_size(sym));\n\t\treturn -ENXIO;\n\t}\n\n\tif (sym->type == NFP_RTSYM_TYPE_ABS) {\n\t\t*value = sym->addr;\n\t\treturn 0;\n\t}\n\n\terr = nfp_rtsym_to_dest(cpp, sym, action, token, off, &cpp_id, &addr);\n\tif (err)\n\t\treturn err;\n\n\treturn nfp_cpp_readq(cpp, cpp_id, addr, value);\n}\n\nint nfp_rtsym_readq(struct nfp_cpp *cpp, const struct nfp_rtsym *sym, u64 off,\n\t\t    u64 *value)\n{\n\treturn __nfp_rtsym_readq(cpp, sym, NFP_CPP_ACTION_RW, 0, off, value);\n}\n\nint __nfp_rtsym_write(struct nfp_cpp *cpp, const struct nfp_rtsym *sym,\n\t\t      u8 action, u8 token, u64 off, void *buf, size_t len)\n{\n\tu64 sym_size = nfp_rtsym_size(sym);\n\tu32 cpp_id;\n\tu64 addr;\n\tint err;\n\n\tif (off > sym_size) {\n\t\tnfp_err(cpp, \"rtsym '%s': write out of bounds: off: %lld + len: %zd > size: %lld\\n\",\n\t\t\tsym->name, off, len, sym_size);\n\t\treturn -ENXIO;\n\t}\n\tlen = min_t(size_t, len, sym_size - off);\n\n\terr = nfp_rtsym_to_dest(cpp, sym, action, token, off, &cpp_id, &addr);\n\tif (err)\n\t\treturn err;\n\n\treturn nfp_cpp_write(cpp, cpp_id, addr, buf, len);\n}\n\nint nfp_rtsym_write(struct nfp_cpp *cpp, const struct nfp_rtsym *sym, u64 off,\n\t\t    void *buf, size_t len)\n{\n\treturn __nfp_rtsym_write(cpp, sym, NFP_CPP_ACTION_RW, 0, off, buf, len);\n}\n\nint __nfp_rtsym_writel(struct nfp_cpp *cpp, const struct nfp_rtsym *sym,\n\t\t       u8 action, u8 token, u64 off, u32 value)\n{\n\tu32 cpp_id;\n\tu64 addr;\n\tint err;\n\n\tif (off + 4 > nfp_rtsym_size(sym)) {\n\t\tnfp_err(cpp, \"rtsym '%s': writel out of bounds: off: %lld + 4 > size: %lld\\n\",\n\t\t\tsym->name, off, nfp_rtsym_size(sym));\n\t\treturn -ENXIO;\n\t}\n\n\terr = nfp_rtsym_to_dest(cpp, sym, action, token, off, &cpp_id, &addr);\n\tif (err)\n\t\treturn err;\n\n\treturn nfp_cpp_writel(cpp, cpp_id, addr, value);\n}\n\nint nfp_rtsym_writel(struct nfp_cpp *cpp, const struct nfp_rtsym *sym, u64 off,\n\t\t     u32 value)\n{\n\treturn __nfp_rtsym_writel(cpp, sym, NFP_CPP_ACTION_RW, 0, off, value);\n}\n\nint __nfp_rtsym_writeq(struct nfp_cpp *cpp, const struct nfp_rtsym *sym,\n\t\t       u8 action, u8 token, u64 off, u64 value)\n{\n\tu32 cpp_id;\n\tu64 addr;\n\tint err;\n\n\tif (off + 8 > nfp_rtsym_size(sym)) {\n\t\tnfp_err(cpp, \"rtsym '%s': writeq out of bounds: off: %lld + 8 > size: %lld\\n\",\n\t\t\tsym->name, off, nfp_rtsym_size(sym));\n\t\treturn -ENXIO;\n\t}\n\n\terr = nfp_rtsym_to_dest(cpp, sym, action, token, off, &cpp_id, &addr);\n\tif (err)\n\t\treturn err;\n\n\treturn nfp_cpp_writeq(cpp, cpp_id, addr, value);\n}\n\nint nfp_rtsym_writeq(struct nfp_cpp *cpp, const struct nfp_rtsym *sym, u64 off,\n\t\t     u64 value)\n{\n\treturn __nfp_rtsym_writeq(cpp, sym, NFP_CPP_ACTION_RW, 0, off, value);\n}\n\n \nu64 nfp_rtsym_read_le(struct nfp_rtsym_table *rtbl, const char *name,\n\t\t      int *error)\n{\n\tconst struct nfp_rtsym *sym;\n\tu32 val32;\n\tu64 val;\n\tint err;\n\n\tsym = nfp_rtsym_lookup(rtbl, name);\n\tif (!sym) {\n\t\terr = -ENOENT;\n\t\tgoto exit;\n\t}\n\n\tswitch (nfp_rtsym_size(sym)) {\n\tcase 4:\n\t\terr = nfp_rtsym_readl(rtbl->cpp, sym, 0, &val32);\n\t\tval = val32;\n\t\tbreak;\n\tcase 8:\n\t\terr = nfp_rtsym_readq(rtbl->cpp, sym, 0, &val);\n\t\tbreak;\n\tdefault:\n\t\tnfp_err(rtbl->cpp,\n\t\t\t\"rtsym '%s': unsupported or non-scalar size: %lld\\n\",\n\t\t\tname, nfp_rtsym_size(sym));\n\t\terr = -EINVAL;\n\t\tbreak;\n\t}\n\nexit:\n\tif (error)\n\t\t*error = err;\n\n\tif (err)\n\t\treturn ~0ULL;\n\treturn val;\n}\n\n \nint nfp_rtsym_write_le(struct nfp_rtsym_table *rtbl, const char *name,\n\t\t       u64 value)\n{\n\tconst struct nfp_rtsym *sym;\n\tint err;\n\n\tsym = nfp_rtsym_lookup(rtbl, name);\n\tif (!sym)\n\t\treturn -ENOENT;\n\n\tswitch (nfp_rtsym_size(sym)) {\n\tcase 4:\n\t\terr = nfp_rtsym_writel(rtbl->cpp, sym, 0, value);\n\t\tbreak;\n\tcase 8:\n\t\terr = nfp_rtsym_writeq(rtbl->cpp, sym, 0, value);\n\t\tbreak;\n\tdefault:\n\t\tnfp_err(rtbl->cpp,\n\t\t\t\"rtsym '%s': unsupported or non-scalar size: %lld\\n\",\n\t\t\tname, nfp_rtsym_size(sym));\n\t\terr = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nu8 __iomem *\nnfp_rtsym_map(struct nfp_rtsym_table *rtbl, const char *name, const char *id,\n\t      unsigned int min_size, struct nfp_cpp_area **area)\n{\n\tconst struct nfp_rtsym *sym;\n\tu8 __iomem *mem;\n\tu32 cpp_id;\n\tu64 addr;\n\tint err;\n\n\tsym = nfp_rtsym_lookup(rtbl, name);\n\tif (!sym)\n\t\treturn (u8 __iomem *)ERR_PTR(-ENOENT);\n\n\terr = nfp_rtsym_to_dest(rtbl->cpp, sym, NFP_CPP_ACTION_RW, 0, 0,\n\t\t\t\t&cpp_id, &addr);\n\tif (err) {\n\t\tnfp_err(rtbl->cpp, \"rtsym '%s': mapping failed\\n\", name);\n\t\treturn (u8 __iomem *)ERR_PTR(err);\n\t}\n\n\tif (sym->size < min_size) {\n\t\tnfp_err(rtbl->cpp, \"rtsym '%s': too small\\n\", name);\n\t\treturn (u8 __iomem *)ERR_PTR(-EINVAL);\n\t}\n\n\tmem = nfp_cpp_map_area(rtbl->cpp, id, cpp_id, addr, sym->size, area);\n\tif (IS_ERR(mem)) {\n\t\tnfp_err(rtbl->cpp, \"rtysm '%s': failed to map: %ld\\n\",\n\t\t\tname, PTR_ERR(mem));\n\t\treturn mem;\n\t}\n\n\treturn mem;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}