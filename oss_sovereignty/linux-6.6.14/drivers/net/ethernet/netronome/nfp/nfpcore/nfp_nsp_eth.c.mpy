{
  "module_name": "nfp_nsp_eth.c",
  "hash_id": "e48fa2b31ffa20b3ca3e9f7db6ed8f4ab51fd45ffbc8326decfc1fad59f8dab8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/netronome/nfp/nfpcore/nfp_nsp_eth.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/bitfield.h>\n#include <linux/ethtool.h>\n#include <linux/if_ether.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\n#include \"nfp.h\"\n#include \"nfp_nsp.h\"\n#include \"nfp6000/nfp6000.h\"\n\n#define NSP_ETH_NBI_PORT_COUNT\t\t24\n#define NSP_ETH_MAX_COUNT\t\t(2 * NSP_ETH_NBI_PORT_COUNT)\n#define NSP_ETH_TABLE_SIZE\t\t(NSP_ETH_MAX_COUNT *\t\t\\\n\t\t\t\t\t sizeof(union eth_table_entry))\n\n#define NSP_ETH_PORT_LANES\t\tGENMASK_ULL(3, 0)\n#define NSP_ETH_PORT_INDEX\t\tGENMASK_ULL(15, 8)\n#define NSP_ETH_PORT_LABEL\t\tGENMASK_ULL(53, 48)\n#define NSP_ETH_PORT_PHYLABEL\t\tGENMASK_ULL(59, 54)\n#define NSP_ETH_PORT_FEC_SUPP_BASER\tBIT_ULL(60)\n#define NSP_ETH_PORT_FEC_SUPP_RS\tBIT_ULL(61)\n#define NSP_ETH_PORT_SUPP_ANEG\t\tBIT_ULL(63)\n\n#define NSP_ETH_PORT_LANES_MASK\t\tcpu_to_le64(NSP_ETH_PORT_LANES)\n\n#define NSP_ETH_STATE_CONFIGURED\tBIT_ULL(0)\n#define NSP_ETH_STATE_ENABLED\t\tBIT_ULL(1)\n#define NSP_ETH_STATE_TX_ENABLED\tBIT_ULL(2)\n#define NSP_ETH_STATE_RX_ENABLED\tBIT_ULL(3)\n#define NSP_ETH_STATE_RATE\t\tGENMASK_ULL(11, 8)\n#define NSP_ETH_STATE_INTERFACE\t\tGENMASK_ULL(19, 12)\n#define NSP_ETH_STATE_MEDIA\t\tGENMASK_ULL(21, 20)\n#define NSP_ETH_STATE_OVRD_CHNG\t\tBIT_ULL(22)\n#define NSP_ETH_STATE_ANEG\t\tGENMASK_ULL(25, 23)\n#define NSP_ETH_STATE_FEC\t\tGENMASK_ULL(27, 26)\n#define NSP_ETH_STATE_ACT_FEC\t\tGENMASK_ULL(29, 28)\n\n#define NSP_ETH_CTRL_CONFIGURED\t\tBIT_ULL(0)\n#define NSP_ETH_CTRL_ENABLED\t\tBIT_ULL(1)\n#define NSP_ETH_CTRL_TX_ENABLED\t\tBIT_ULL(2)\n#define NSP_ETH_CTRL_RX_ENABLED\t\tBIT_ULL(3)\n#define NSP_ETH_CTRL_SET_RATE\t\tBIT_ULL(4)\n#define NSP_ETH_CTRL_SET_LANES\t\tBIT_ULL(5)\n#define NSP_ETH_CTRL_SET_ANEG\t\tBIT_ULL(6)\n#define NSP_ETH_CTRL_SET_FEC\t\tBIT_ULL(7)\n#define NSP_ETH_CTRL_SET_IDMODE\t\tBIT_ULL(8)\n\nenum nfp_eth_raw {\n\tNSP_ETH_RAW_PORT = 0,\n\tNSP_ETH_RAW_STATE,\n\tNSP_ETH_RAW_MAC,\n\tNSP_ETH_RAW_CONTROL,\n\n\tNSP_ETH_NUM_RAW\n};\n\nenum nfp_eth_rate {\n\tRATE_INVALID = 0,\n\tRATE_10M,\n\tRATE_100M,\n\tRATE_1G,\n\tRATE_10G,\n\tRATE_25G,\n};\n\nunion eth_table_entry {\n\tstruct {\n\t\t__le64 port;\n\t\t__le64 state;\n\t\tu8 mac_addr[6];\n\t\tu8 resv[2];\n\t\t__le64 control;\n\t};\n\t__le64 raw[NSP_ETH_NUM_RAW];\n};\n\nstatic const struct {\n\tenum nfp_eth_rate rate;\n\tunsigned int speed;\n} nsp_eth_rate_tbl[] = {\n\t{ RATE_INVALID,\t0, },\n\t{ RATE_10M,\tSPEED_10, },\n\t{ RATE_100M,\tSPEED_100, },\n\t{ RATE_1G,\tSPEED_1000, },\n\t{ RATE_10G,\tSPEED_10000, },\n\t{ RATE_25G,\tSPEED_25000, },\n};\n\nstatic unsigned int nfp_eth_rate2speed(enum nfp_eth_rate rate)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(nsp_eth_rate_tbl); i++)\n\t\tif (nsp_eth_rate_tbl[i].rate == rate)\n\t\t\treturn nsp_eth_rate_tbl[i].speed;\n\n\treturn 0;\n}\n\nstatic unsigned int nfp_eth_speed2rate(unsigned int speed)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(nsp_eth_rate_tbl); i++)\n\t\tif (nsp_eth_rate_tbl[i].speed == speed)\n\t\t\treturn nsp_eth_rate_tbl[i].rate;\n\n\treturn RATE_INVALID;\n}\n\nstatic void nfp_eth_copy_mac_reverse(u8 *dst, const u8 *src)\n{\n\tint i;\n\n\tfor (i = 0; i < ETH_ALEN; i++)\n\t\tdst[ETH_ALEN - i - 1] = src[i];\n}\n\nstatic void\nnfp_eth_port_translate(struct nfp_nsp *nsp, const union eth_table_entry *src,\n\t\t       unsigned int index, struct nfp_eth_table_port *dst)\n{\n\tunsigned int rate;\n\tunsigned int fec;\n\tu64 port, state;\n\n\tport = le64_to_cpu(src->port);\n\tstate = le64_to_cpu(src->state);\n\n\tdst->eth_index = FIELD_GET(NSP_ETH_PORT_INDEX, port);\n\tdst->index = index;\n\tdst->nbi = index / NSP_ETH_NBI_PORT_COUNT;\n\tdst->base = index % NSP_ETH_NBI_PORT_COUNT;\n\tdst->lanes = FIELD_GET(NSP_ETH_PORT_LANES, port);\n\n\tdst->enabled = FIELD_GET(NSP_ETH_STATE_ENABLED, state);\n\tdst->tx_enabled = FIELD_GET(NSP_ETH_STATE_TX_ENABLED, state);\n\tdst->rx_enabled = FIELD_GET(NSP_ETH_STATE_RX_ENABLED, state);\n\n\trate = nfp_eth_rate2speed(FIELD_GET(NSP_ETH_STATE_RATE, state));\n\tdst->speed = dst->lanes * rate;\n\n\tdst->interface = FIELD_GET(NSP_ETH_STATE_INTERFACE, state);\n\tdst->media = FIELD_GET(NSP_ETH_STATE_MEDIA, state);\n\n\tnfp_eth_copy_mac_reverse(dst->mac_addr, src->mac_addr);\n\n\tdst->label_port = FIELD_GET(NSP_ETH_PORT_PHYLABEL, port);\n\tdst->label_subport = FIELD_GET(NSP_ETH_PORT_LABEL, port);\n\n\tif (nfp_nsp_get_abi_ver_minor(nsp) < 17)\n\t\treturn;\n\n\tdst->override_changed = FIELD_GET(NSP_ETH_STATE_OVRD_CHNG, state);\n\tdst->aneg = FIELD_GET(NSP_ETH_STATE_ANEG, state);\n\n\tif (nfp_nsp_get_abi_ver_minor(nsp) < 22)\n\t\treturn;\n\n\tfec = FIELD_GET(NSP_ETH_PORT_FEC_SUPP_BASER, port);\n\tdst->fec_modes_supported |= fec << NFP_FEC_BASER_BIT;\n\tfec = FIELD_GET(NSP_ETH_PORT_FEC_SUPP_RS, port);\n\tdst->fec_modes_supported |= fec << NFP_FEC_REED_SOLOMON_BIT;\n\tif (dst->fec_modes_supported)\n\t\tdst->fec_modes_supported |= NFP_FEC_AUTO | NFP_FEC_DISABLED;\n\n\tdst->fec = FIELD_GET(NSP_ETH_STATE_FEC, state);\n\tdst->act_fec = dst->fec;\n\n\tif (nfp_nsp_get_abi_ver_minor(nsp) < 33)\n\t\treturn;\n\n\tdst->act_fec = FIELD_GET(NSP_ETH_STATE_ACT_FEC, state);\n\tdst->supp_aneg = FIELD_GET(NSP_ETH_PORT_SUPP_ANEG, port);\n}\n\nstatic void\nnfp_eth_calc_port_geometry(struct nfp_cpp *cpp, struct nfp_eth_table *table)\n{\n\tunsigned int i, j;\n\n\tfor (i = 0; i < table->count; i++) {\n\t\ttable->max_index = max(table->max_index, table->ports[i].index);\n\n\t\tfor (j = 0; j < table->count; j++) {\n\t\t\tif (table->ports[i].label_port !=\n\t\t\t    table->ports[j].label_port)\n\t\t\t\tcontinue;\n\t\t\ttable->ports[i].port_lanes += table->ports[j].lanes;\n\n\t\t\tif (i == j)\n\t\t\t\tcontinue;\n\t\t\tif (table->ports[i].label_subport ==\n\t\t\t    table->ports[j].label_subport)\n\t\t\t\tnfp_warn(cpp,\n\t\t\t\t\t \"Port %d subport %d is a duplicate\\n\",\n\t\t\t\t\t table->ports[i].label_port,\n\t\t\t\t\t table->ports[i].label_subport);\n\n\t\t\ttable->ports[i].is_split = true;\n\t\t}\n\t}\n}\n\nstatic void\nnfp_eth_calc_port_type(struct nfp_cpp *cpp, struct nfp_eth_table_port *entry)\n{\n\tif (entry->interface == NFP_INTERFACE_NONE) {\n\t\tentry->port_type = PORT_NONE;\n\t\treturn;\n\t} else if (entry->interface == NFP_INTERFACE_RJ45) {\n\t\tentry->port_type = PORT_TP;\n\t\treturn;\n\t}\n\n\tif (entry->media == NFP_MEDIA_FIBRE)\n\t\tentry->port_type = PORT_FIBRE;\n\telse\n\t\tentry->port_type = PORT_DA;\n}\n\nstatic void\nnfp_eth_read_media(struct nfp_cpp *cpp, struct nfp_nsp *nsp, struct nfp_eth_table_port *entry)\n{\n\tstruct nfp_eth_media_buf ethm = {\n\t\t.eth_index = entry->eth_index,\n\t};\n\tunsigned int i;\n\tint ret;\n\n\tif (!nfp_nsp_has_read_media(nsp))\n\t\treturn;\n\n\tret = nfp_nsp_read_media(nsp, &ethm, sizeof(ethm));\n\tif (ret) {\n\t\tnfp_err(cpp, \"Reading media link modes failed: %d\\n\", ret);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < 2; i++) {\n\t\tentry->link_modes_supp[i] = le64_to_cpu(ethm.supported_modes[i]);\n\t\tentry->link_modes_ad[i] = le64_to_cpu(ethm.advertised_modes[i]);\n\t}\n}\n\n \nstruct nfp_eth_table *nfp_eth_read_ports(struct nfp_cpp *cpp)\n{\n\tstruct nfp_eth_table *ret;\n\tstruct nfp_nsp *nsp;\n\n\tnsp = nfp_nsp_open(cpp);\n\tif (IS_ERR(nsp))\n\t\treturn NULL;\n\n\tret = __nfp_eth_read_ports(cpp, nsp);\n\tnfp_nsp_close(nsp);\n\n\treturn ret;\n}\n\nstruct nfp_eth_table *\n__nfp_eth_read_ports(struct nfp_cpp *cpp, struct nfp_nsp *nsp)\n{\n\tunion eth_table_entry *entries;\n\tstruct nfp_eth_table *table;\n\tint i, j, ret, cnt = 0;\n\n\tentries = kzalloc(NSP_ETH_TABLE_SIZE, GFP_KERNEL);\n\tif (!entries)\n\t\treturn NULL;\n\n\tret = nfp_nsp_read_eth_table(nsp, entries, NSP_ETH_TABLE_SIZE);\n\tif (ret < 0) {\n\t\tnfp_err(cpp, \"reading port table failed %d\\n\", ret);\n\t\tgoto err;\n\t}\n\n\tfor (i = 0; i < NSP_ETH_MAX_COUNT; i++)\n\t\tif (entries[i].port & NSP_ETH_PORT_LANES_MASK)\n\t\t\tcnt++;\n\n\t \n\tif (ret && ret != cnt) {\n\t\tnfp_err(cpp, \"table entry count reported (%d) does not match entries present (%d)\\n\",\n\t\t\tret, cnt);\n\t\tgoto err;\n\t}\n\n\ttable = kzalloc(struct_size(table, ports, cnt), GFP_KERNEL);\n\tif (!table)\n\t\tgoto err;\n\n\ttable->count = cnt;\n\tfor (i = 0, j = 0; i < NSP_ETH_MAX_COUNT; i++)\n\t\tif (entries[i].port & NSP_ETH_PORT_LANES_MASK)\n\t\t\tnfp_eth_port_translate(nsp, &entries[i], i,\n\t\t\t\t\t       &table->ports[j++]);\n\n\tnfp_eth_calc_port_geometry(cpp, table);\n\tfor (i = 0; i < table->count; i++) {\n\t\tnfp_eth_calc_port_type(cpp, &table->ports[i]);\n\t\tnfp_eth_read_media(cpp, nsp, &table->ports[i]);\n\t}\n\n\tkfree(entries);\n\n\treturn table;\n\nerr:\n\tkfree(entries);\n\treturn NULL;\n}\n\nstruct nfp_nsp *nfp_eth_config_start(struct nfp_cpp *cpp, unsigned int idx)\n{\n\tunion eth_table_entry *entries;\n\tstruct nfp_nsp *nsp;\n\tint ret;\n\n\tentries = kzalloc(NSP_ETH_TABLE_SIZE, GFP_KERNEL);\n\tif (!entries)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tnsp = nfp_nsp_open(cpp);\n\tif (IS_ERR(nsp)) {\n\t\tkfree(entries);\n\t\treturn nsp;\n\t}\n\n\tret = nfp_nsp_read_eth_table(nsp, entries, NSP_ETH_TABLE_SIZE);\n\tif (ret < 0) {\n\t\tnfp_err(cpp, \"reading port table failed %d\\n\", ret);\n\t\tgoto err;\n\t}\n\n\tif (!(entries[idx].port & NSP_ETH_PORT_LANES_MASK)) {\n\t\tnfp_warn(cpp, \"trying to set port state on disabled port %d\\n\",\n\t\t\t idx);\n\t\tgoto err;\n\t}\n\n\tnfp_nsp_config_set_state(nsp, entries, idx);\n\treturn nsp;\n\nerr:\n\tnfp_nsp_close(nsp);\n\tkfree(entries);\n\treturn ERR_PTR(-EIO);\n}\n\nvoid nfp_eth_config_cleanup_end(struct nfp_nsp *nsp)\n{\n\tunion eth_table_entry *entries = nfp_nsp_config_entries(nsp);\n\n\tnfp_nsp_config_set_modified(nsp, false);\n\tnfp_nsp_config_clear_state(nsp);\n\tnfp_nsp_close(nsp);\n\tkfree(entries);\n}\n\n \nint nfp_eth_config_commit_end(struct nfp_nsp *nsp)\n{\n\tunion eth_table_entry *entries = nfp_nsp_config_entries(nsp);\n\tint ret = 1;\n\n\tif (nfp_nsp_config_modified(nsp)) {\n\t\tret = nfp_nsp_write_eth_table(nsp, entries, NSP_ETH_TABLE_SIZE);\n\t\tret = ret < 0 ? ret : 0;\n\t}\n\n\tnfp_eth_config_cleanup_end(nsp);\n\n\treturn ret;\n}\n\n \nint nfp_eth_set_mod_enable(struct nfp_cpp *cpp, unsigned int idx, bool enable)\n{\n\tunion eth_table_entry *entries;\n\tstruct nfp_nsp *nsp;\n\tu64 reg;\n\n\tnsp = nfp_eth_config_start(cpp, idx);\n\tif (IS_ERR(nsp))\n\t\treturn PTR_ERR(nsp);\n\n\tentries = nfp_nsp_config_entries(nsp);\n\n\t \n\treg = le64_to_cpu(entries[idx].state);\n\tif (enable != FIELD_GET(NSP_ETH_CTRL_ENABLED, reg)) {\n\t\treg = le64_to_cpu(entries[idx].control);\n\t\treg &= ~NSP_ETH_CTRL_ENABLED;\n\t\treg |= FIELD_PREP(NSP_ETH_CTRL_ENABLED, enable);\n\t\tentries[idx].control = cpu_to_le64(reg);\n\n\t\tnfp_nsp_config_set_modified(nsp, true);\n\t}\n\n\treturn nfp_eth_config_commit_end(nsp);\n}\n\n \nint nfp_eth_set_configured(struct nfp_cpp *cpp, unsigned int idx, bool configed)\n{\n\tunion eth_table_entry *entries;\n\tstruct nfp_nsp *nsp;\n\tu64 reg;\n\n\tnsp = nfp_eth_config_start(cpp, idx);\n\tif (IS_ERR(nsp))\n\t\treturn PTR_ERR(nsp);\n\n\t \n\tif (nfp_nsp_get_abi_ver_minor(nsp) < 20) {\n\t\tnfp_eth_config_cleanup_end(nsp);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tentries = nfp_nsp_config_entries(nsp);\n\n\t \n\treg = le64_to_cpu(entries[idx].state);\n\tif (configed != FIELD_GET(NSP_ETH_STATE_CONFIGURED, reg)) {\n\t\treg = le64_to_cpu(entries[idx].control);\n\t\treg &= ~NSP_ETH_CTRL_CONFIGURED;\n\t\treg |= FIELD_PREP(NSP_ETH_CTRL_CONFIGURED, configed);\n\t\tentries[idx].control = cpu_to_le64(reg);\n\n\t\tnfp_nsp_config_set_modified(nsp, true);\n\t}\n\n\treturn nfp_eth_config_commit_end(nsp);\n}\n\nstatic int\nnfp_eth_set_bit_config(struct nfp_nsp *nsp, unsigned int raw_idx,\n\t\t       const u64 mask, const unsigned int shift,\n\t\t       unsigned int val, const u64 ctrl_bit)\n{\n\tunion eth_table_entry *entries = nfp_nsp_config_entries(nsp);\n\tunsigned int idx = nfp_nsp_config_idx(nsp);\n\tu64 reg;\n\n\t \n\tif (nfp_nsp_get_abi_ver_minor(nsp) < 17) {\n\t\tnfp_err(nfp_nsp_cpp(nsp),\n\t\t\t\"set operations not supported, please update flash\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t \n\treg = le64_to_cpu(entries[idx].raw[raw_idx]);\n\tif (val == (reg & mask) >> shift)\n\t\treturn 0;\n\n\treg &= ~mask;\n\treg |= (val << shift) & mask;\n\tentries[idx].raw[raw_idx] = cpu_to_le64(reg);\n\n\tentries[idx].control |= cpu_to_le64(ctrl_bit);\n\n\tnfp_nsp_config_set_modified(nsp, true);\n\n\treturn 0;\n}\n\nint nfp_eth_set_idmode(struct nfp_cpp *cpp, unsigned int idx, bool state)\n{\n\tunion eth_table_entry *entries;\n\tstruct nfp_nsp *nsp;\n\tu64 reg;\n\n\tnsp = nfp_eth_config_start(cpp, idx);\n\tif (IS_ERR(nsp))\n\t\treturn PTR_ERR(nsp);\n\n\t \n\tif (nfp_nsp_get_abi_ver_minor(nsp) < 32) {\n\t\tnfp_err(nfp_nsp_cpp(nsp),\n\t\t\t\"set id mode operation not supported, please update flash\\n\");\n\t\tnfp_eth_config_cleanup_end(nsp);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tentries = nfp_nsp_config_entries(nsp);\n\n\treg = le64_to_cpu(entries[idx].control);\n\treg &= ~NSP_ETH_CTRL_SET_IDMODE;\n\treg |= FIELD_PREP(NSP_ETH_CTRL_SET_IDMODE, state);\n\tentries[idx].control = cpu_to_le64(reg);\n\n\tnfp_nsp_config_set_modified(nsp, true);\n\n\treturn nfp_eth_config_commit_end(nsp);\n}\n\n#define NFP_ETH_SET_BIT_CONFIG(nsp, raw_idx, mask, val, ctrl_bit)\t\\\n\t({\t\t\t\t\t\t\t\t\\\n\t\t__BF_FIELD_CHECK(mask, 0ULL, val, \"NFP_ETH_SET_BIT_CONFIG: \"); \\\n\t\tnfp_eth_set_bit_config(nsp, raw_idx, mask, __bf_shf(mask), \\\n\t\t\t\t       val, ctrl_bit);\t\t\t\\\n\t})\n\n \nint __nfp_eth_set_aneg(struct nfp_nsp *nsp, enum nfp_eth_aneg mode)\n{\n\treturn NFP_ETH_SET_BIT_CONFIG(nsp, NSP_ETH_RAW_STATE,\n\t\t\t\t      NSP_ETH_STATE_ANEG, mode,\n\t\t\t\t      NSP_ETH_CTRL_SET_ANEG);\n}\n\n \nstatic int __nfp_eth_set_fec(struct nfp_nsp *nsp, enum nfp_eth_fec mode)\n{\n\treturn NFP_ETH_SET_BIT_CONFIG(nsp, NSP_ETH_RAW_STATE,\n\t\t\t\t      NSP_ETH_STATE_FEC, mode,\n\t\t\t\t      NSP_ETH_CTRL_SET_FEC);\n}\n\n \nint\nnfp_eth_set_fec(struct nfp_cpp *cpp, unsigned int idx, enum nfp_eth_fec mode)\n{\n\tstruct nfp_nsp *nsp;\n\tint err;\n\n\tnsp = nfp_eth_config_start(cpp, idx);\n\tif (IS_ERR(nsp))\n\t\treturn PTR_ERR(nsp);\n\n\terr = __nfp_eth_set_fec(nsp, mode);\n\tif (err) {\n\t\tnfp_eth_config_cleanup_end(nsp);\n\t\treturn err;\n\t}\n\n\treturn nfp_eth_config_commit_end(nsp);\n}\n\n \nint __nfp_eth_set_speed(struct nfp_nsp *nsp, unsigned int speed)\n{\n\tenum nfp_eth_rate rate;\n\n\trate = nfp_eth_speed2rate(speed);\n\tif (rate == RATE_INVALID) {\n\t\tnfp_warn(nfp_nsp_cpp(nsp),\n\t\t\t \"could not find matching lane rate for speed %u\\n\",\n\t\t\t speed);\n\t\treturn -EINVAL;\n\t}\n\n\treturn NFP_ETH_SET_BIT_CONFIG(nsp, NSP_ETH_RAW_STATE,\n\t\t\t\t      NSP_ETH_STATE_RATE, rate,\n\t\t\t\t      NSP_ETH_CTRL_SET_RATE);\n}\n\n \nint __nfp_eth_set_split(struct nfp_nsp *nsp, unsigned int lanes)\n{\n\treturn NFP_ETH_SET_BIT_CONFIG(nsp, NSP_ETH_RAW_PORT, NSP_ETH_PORT_LANES,\n\t\t\t\t      lanes, NSP_ETH_CTRL_SET_LANES);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}