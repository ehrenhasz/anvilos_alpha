{
  "module_name": "nfp6000_pcie.c",
  "hash_id": "c63c9cba50d3f41c713b92cdf3d031d1275bfe93d1135a881d0e6ca56319c5d7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/netronome/nfp/nfpcore/nfp6000_pcie.c",
  "human_readable_source": "\n \n\n \n\n#include <asm/unaligned.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/kref.h>\n#include <linux/io.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/sort.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/pci.h>\n\n#include \"nfp_cpp.h\"\n#include \"nfp_dev.h\"\n\n#include \"nfp6000/nfp6000.h\"\n\n#include \"nfp6000_pcie.h\"\n\n#define NFP_PCIE_BAR(_pf)\t(0x30000 + ((_pf) & 7) * 0xc0)\n#define NFP_PCIE_BAR_EXPLICIT_BAR0(_x, _y) \\\n\t(0x00000080 + (0x40 * ((_x) & 0x3)) + (0x10 * ((_y) & 0x3)))\n#define   NFP_PCIE_BAR_EXPLICIT_BAR0_SignalType(_x)     (((_x) & 0x3) << 30)\n#define   NFP_PCIE_BAR_EXPLICIT_BAR0_SignalType_of(_x)  (((_x) >> 30) & 0x3)\n#define   NFP_PCIE_BAR_EXPLICIT_BAR0_Token(_x)          (((_x) & 0x3) << 28)\n#define   NFP_PCIE_BAR_EXPLICIT_BAR0_Token_of(_x)       (((_x) >> 28) & 0x3)\n#define   NFP_PCIE_BAR_EXPLICIT_BAR0_Address(_x)        (((_x) & 0xffffff) << 0)\n#define   NFP_PCIE_BAR_EXPLICIT_BAR0_Address_of(_x)     (((_x) >> 0) & 0xffffff)\n#define NFP_PCIE_BAR_EXPLICIT_BAR1(_x, _y) \\\n\t(0x00000084 + (0x40 * ((_x) & 0x3)) + (0x10 * ((_y) & 0x3)))\n#define   NFP_PCIE_BAR_EXPLICIT_BAR1_SignalRef(_x)      (((_x) & 0x7f) << 24)\n#define   NFP_PCIE_BAR_EXPLICIT_BAR1_SignalRef_of(_x)   (((_x) >> 24) & 0x7f)\n#define   NFP_PCIE_BAR_EXPLICIT_BAR1_DataMaster(_x)     (((_x) & 0x3ff) << 14)\n#define   NFP_PCIE_BAR_EXPLICIT_BAR1_DataMaster_of(_x)  (((_x) >> 14) & 0x3ff)\n#define   NFP_PCIE_BAR_EXPLICIT_BAR1_DataRef(_x)        (((_x) & 0x3fff) << 0)\n#define   NFP_PCIE_BAR_EXPLICIT_BAR1_DataRef_of(_x)     (((_x) >> 0) & 0x3fff)\n#define NFP_PCIE_BAR_EXPLICIT_BAR2(_x, _y) \\\n\t(0x00000088 + (0x40 * ((_x) & 0x3)) + (0x10 * ((_y) & 0x3)))\n#define   NFP_PCIE_BAR_EXPLICIT_BAR2_Target(_x)         (((_x) & 0xf) << 28)\n#define   NFP_PCIE_BAR_EXPLICIT_BAR2_Target_of(_x)      (((_x) >> 28) & 0xf)\n#define   NFP_PCIE_BAR_EXPLICIT_BAR2_Action(_x)         (((_x) & 0x1f) << 23)\n#define   NFP_PCIE_BAR_EXPLICIT_BAR2_Action_of(_x)      (((_x) >> 23) & 0x1f)\n#define   NFP_PCIE_BAR_EXPLICIT_BAR2_Length(_x)         (((_x) & 0x1f) << 18)\n#define   NFP_PCIE_BAR_EXPLICIT_BAR2_Length_of(_x)      (((_x) >> 18) & 0x1f)\n#define   NFP_PCIE_BAR_EXPLICIT_BAR2_ByteMask(_x)       (((_x) & 0xff) << 10)\n#define   NFP_PCIE_BAR_EXPLICIT_BAR2_ByteMask_of(_x)    (((_x) >> 10) & 0xff)\n#define   NFP_PCIE_BAR_EXPLICIT_BAR2_SignalMaster(_x)   (((_x) & 0x3ff) << 0)\n#define   NFP_PCIE_BAR_EXPLICIT_BAR2_SignalMaster_of(_x) (((_x) >> 0) & 0x3ff)\n\n#define   NFP_PCIE_BAR_PCIE2CPP_Action_BaseAddress(_x)  (((_x) & 0x1f) << 16)\n#define   NFP_PCIE_BAR_PCIE2CPP_Action_BaseAddress_of(_x) (((_x) >> 16) & 0x1f)\n#define   NFP_PCIE_BAR_PCIE2CPP_BaseAddress(_x)         (((_x) & 0xffff) << 0)\n#define   NFP_PCIE_BAR_PCIE2CPP_BaseAddress_of(_x)      (((_x) >> 0) & 0xffff)\n#define   NFP_PCIE_BAR_PCIE2CPP_LengthSelect(_x)        (((_x) & 0x3) << 27)\n#define   NFP_PCIE_BAR_PCIE2CPP_LengthSelect_of(_x)     (((_x) >> 27) & 0x3)\n#define     NFP_PCIE_BAR_PCIE2CPP_LengthSelect_32BIT    0\n#define     NFP_PCIE_BAR_PCIE2CPP_LengthSelect_64BIT    1\n#define     NFP_PCIE_BAR_PCIE2CPP_LengthSelect_0BYTE    3\n#define   NFP_PCIE_BAR_PCIE2CPP_MapType(_x)             (((_x) & 0x7) << 29)\n#define   NFP_PCIE_BAR_PCIE2CPP_MapType_of(_x)          (((_x) >> 29) & 0x7)\n#define     NFP_PCIE_BAR_PCIE2CPP_MapType_FIXED         0\n#define     NFP_PCIE_BAR_PCIE2CPP_MapType_BULK          1\n#define     NFP_PCIE_BAR_PCIE2CPP_MapType_TARGET        2\n#define     NFP_PCIE_BAR_PCIE2CPP_MapType_GENERAL       3\n#define     NFP_PCIE_BAR_PCIE2CPP_MapType_EXPLICIT0     4\n#define     NFP_PCIE_BAR_PCIE2CPP_MapType_EXPLICIT1     5\n#define     NFP_PCIE_BAR_PCIE2CPP_MapType_EXPLICIT2     6\n#define     NFP_PCIE_BAR_PCIE2CPP_MapType_EXPLICIT3     7\n#define   NFP_PCIE_BAR_PCIE2CPP_Target_BaseAddress(_x)  (((_x) & 0xf) << 23)\n#define   NFP_PCIE_BAR_PCIE2CPP_Target_BaseAddress_of(_x) (((_x) >> 23) & 0xf)\n#define   NFP_PCIE_BAR_PCIE2CPP_Token_BaseAddress(_x)   (((_x) & 0x3) << 21)\n#define   NFP_PCIE_BAR_PCIE2CPP_Token_BaseAddress_of(_x) (((_x) >> 21) & 0x3)\n#define NFP_PCIE_EM                                     0x020000\n#define NFP_PCIE_SRAM                                   0x000000\n\n \n#define NFP_PCI_MIN_MAP_SIZE\t\t\t\t0x080000\n\n#define NFP_PCIE_P2C_FIXED_SIZE(bar)               (1 << (bar)->bitsize)\n#define NFP_PCIE_P2C_BULK_SIZE(bar)                (1 << (bar)->bitsize)\n#define NFP_PCIE_P2C_GENERAL_TARGET_OFFSET(bar, x) ((x) << ((bar)->bitsize - 2))\n#define NFP_PCIE_P2C_GENERAL_TOKEN_OFFSET(bar, x) ((x) << ((bar)->bitsize - 4))\n#define NFP_PCIE_P2C_GENERAL_SIZE(bar)             (1 << ((bar)->bitsize - 4))\n\n#define NFP_PCIE_P2C_EXPBAR_OFFSET(bar_index)\t\t((bar_index) * 4)\n\n \n#define NFP_PCIE_EXPLICIT_BARS\t\t2\n\nstruct nfp6000_pcie;\nstruct nfp6000_area_priv;\n\n \nstruct nfp_bar {\n\tstruct nfp6000_pcie *nfp;\n\tu32 barcfg;\n\tu64 base;           \n\tu64 mask;           \n\tu32 bitsize;        \n\tint index;\n\tatomic_t refcnt;\n\n\tvoid __iomem *iomem;\n\tstruct resource *resource;\n};\n\n#define NFP_PCI_BAR_MAX    (PCI_64BIT_BAR_COUNT * 8)\n\nstruct nfp6000_pcie {\n\tstruct pci_dev *pdev;\n\tstruct device *dev;\n\tconst struct nfp_dev_info *dev_info;\n\n\t \n\tspinlock_t bar_lock;\t\t \n\tint bars;\n\tstruct nfp_bar bar[NFP_PCI_BAR_MAX];\n\twait_queue_head_t bar_waiters;\n\n\t \n\tstruct {\n\t\tvoid __iomem *csr;\n\t\tvoid __iomem *em;\n\t\tvoid __iomem *expl[4];\n\t} iomem;\n\n\t \n\tstruct {\n\t\tstruct mutex mutex;  \n\t\tu8 master_id;\n\t\tu8 signal_ref;\n\t\tvoid __iomem *data;\n\t\tstruct {\n\t\t\tvoid __iomem *addr;\n\t\t\tint bitsize;\n\t\t\tint free[4];\n\t\t} group[4];\n\t} expl;\n};\n\nstatic u32 nfp_bar_maptype(struct nfp_bar *bar)\n{\n\treturn NFP_PCIE_BAR_PCIE2CPP_MapType_of(bar->barcfg);\n}\n\nstatic resource_size_t nfp_bar_resource_len(struct nfp_bar *bar)\n{\n\treturn pci_resource_len(bar->nfp->pdev, (bar->index / 8) * 2) / 8;\n}\n\nstatic resource_size_t nfp_bar_resource_start(struct nfp_bar *bar)\n{\n\treturn pci_resource_start(bar->nfp->pdev, (bar->index / 8) * 2)\n\t\t+ nfp_bar_resource_len(bar) * (bar->index & 7);\n}\n\n#define TARGET_WIDTH_32    4\n#define TARGET_WIDTH_64    8\n\nstatic int\ncompute_bar(const struct nfp6000_pcie *nfp, const struct nfp_bar *bar,\n\t    u32 *bar_config, u64 *bar_base,\n\t    int tgt, int act, int tok, u64 offset, size_t size, int width)\n{\n\tint bitsize;\n\tu32 newcfg;\n\n\tif (tgt >= NFP_CPP_NUM_TARGETS)\n\t\treturn -EINVAL;\n\n\tswitch (width) {\n\tcase 8:\n\t\tnewcfg = NFP_PCIE_BAR_PCIE2CPP_LengthSelect(\n\t\t\tNFP_PCIE_BAR_PCIE2CPP_LengthSelect_64BIT);\n\t\tbreak;\n\tcase 4:\n\t\tnewcfg = NFP_PCIE_BAR_PCIE2CPP_LengthSelect(\n\t\t\tNFP_PCIE_BAR_PCIE2CPP_LengthSelect_32BIT);\n\t\tbreak;\n\tcase 0:\n\t\tnewcfg = NFP_PCIE_BAR_PCIE2CPP_LengthSelect(\n\t\t\tNFP_PCIE_BAR_PCIE2CPP_LengthSelect_0BYTE);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (act != NFP_CPP_ACTION_RW && act != 0) {\n\t\t \n\t\tu64 mask = ~(NFP_PCIE_P2C_FIXED_SIZE(bar) - 1);\n\n\t\tnewcfg |= NFP_PCIE_BAR_PCIE2CPP_MapType(\n\t\t\t  NFP_PCIE_BAR_PCIE2CPP_MapType_FIXED);\n\t\tnewcfg |= NFP_PCIE_BAR_PCIE2CPP_Target_BaseAddress(tgt);\n\t\tnewcfg |= NFP_PCIE_BAR_PCIE2CPP_Action_BaseAddress(act);\n\t\tnewcfg |= NFP_PCIE_BAR_PCIE2CPP_Token_BaseAddress(tok);\n\n\t\tif ((offset & mask) != ((offset + size - 1) & mask))\n\t\t\treturn -EINVAL;\n\t\toffset &= mask;\n\n\t\tbitsize = 40 - 16;\n\t} else {\n\t\tu64 mask = ~(NFP_PCIE_P2C_BULK_SIZE(bar) - 1);\n\n\t\t \n\t\tnewcfg |= NFP_PCIE_BAR_PCIE2CPP_MapType(\n\t\t\tNFP_PCIE_BAR_PCIE2CPP_MapType_BULK);\n\t\tnewcfg |= NFP_PCIE_BAR_PCIE2CPP_Target_BaseAddress(tgt);\n\t\tnewcfg |= NFP_PCIE_BAR_PCIE2CPP_Token_BaseAddress(tok);\n\n\t\tif ((offset & mask) != ((offset + size - 1) & mask))\n\t\t\treturn -EINVAL;\n\n\t\toffset &= mask;\n\n\t\tbitsize = 40 - 21;\n\t}\n\n\tif (bar->bitsize < bitsize)\n\t\treturn -EINVAL;\n\n\tnewcfg |= offset >> bitsize;\n\n\tif (bar_base)\n\t\t*bar_base = offset;\n\n\tif (bar_config)\n\t\t*bar_config = newcfg;\n\n\treturn 0;\n}\n\nstatic int\nnfp6000_bar_write(struct nfp6000_pcie *nfp, struct nfp_bar *bar, u32 newcfg)\n{\n\tunsigned int xbar;\n\n\txbar = NFP_PCIE_P2C_EXPBAR_OFFSET(bar->index);\n\n\tif (nfp->iomem.csr) {\n\t\twritel(newcfg, nfp->iomem.csr + xbar);\n\t\t \n\t\treadl(nfp->iomem.csr + xbar);\n\t} else {\n\t\txbar += nfp->dev_info->pcie_cfg_expbar_offset;\n\t\tpci_write_config_dword(nfp->pdev, xbar, newcfg);\n\t}\n\n\tbar->barcfg = newcfg;\n\n\treturn 0;\n}\n\nstatic int\nreconfigure_bar(struct nfp6000_pcie *nfp, struct nfp_bar *bar,\n\t\tint tgt, int act, int tok, u64 offset, size_t size, int width)\n{\n\tu64 newbase;\n\tu32 newcfg;\n\tint err;\n\n\terr = compute_bar(nfp, bar, &newcfg, &newbase,\n\t\t\t  tgt, act, tok, offset, size, width);\n\tif (err)\n\t\treturn err;\n\n\tbar->base = newbase;\n\n\treturn nfp6000_bar_write(nfp, bar, newcfg);\n}\n\n \nstatic int matching_bar(struct nfp_bar *bar, u32 tgt, u32 act, u32 tok,\n\t\t\tu64 offset, size_t size, int width)\n{\n\tint bartgt, baract, bartok;\n\tint barwidth;\n\tu32 maptype;\n\n\tmaptype = NFP_PCIE_BAR_PCIE2CPP_MapType_of(bar->barcfg);\n\tbartgt = NFP_PCIE_BAR_PCIE2CPP_Target_BaseAddress_of(bar->barcfg);\n\tbartok = NFP_PCIE_BAR_PCIE2CPP_Token_BaseAddress_of(bar->barcfg);\n\tbaract = NFP_PCIE_BAR_PCIE2CPP_Action_BaseAddress_of(bar->barcfg);\n\n\tbarwidth = NFP_PCIE_BAR_PCIE2CPP_LengthSelect_of(bar->barcfg);\n\tswitch (barwidth) {\n\tcase NFP_PCIE_BAR_PCIE2CPP_LengthSelect_32BIT:\n\t\tbarwidth = 4;\n\t\tbreak;\n\tcase NFP_PCIE_BAR_PCIE2CPP_LengthSelect_64BIT:\n\t\tbarwidth = 8;\n\t\tbreak;\n\tcase NFP_PCIE_BAR_PCIE2CPP_LengthSelect_0BYTE:\n\t\tbarwidth = 0;\n\t\tbreak;\n\tdefault:\n\t\tbarwidth = -1;\n\t\tbreak;\n\t}\n\n\tswitch (maptype) {\n\tcase NFP_PCIE_BAR_PCIE2CPP_MapType_TARGET:\n\t\tbartok = -1;\n\t\tfallthrough;\n\tcase NFP_PCIE_BAR_PCIE2CPP_MapType_BULK:\n\t\tbaract = NFP_CPP_ACTION_RW;\n\t\tif (act == 0)\n\t\t\tact = NFP_CPP_ACTION_RW;\n\t\tfallthrough;\n\tcase NFP_PCIE_BAR_PCIE2CPP_MapType_FIXED:\n\t\tbreak;\n\tdefault:\n\t\t \n\t\treturn 0;\n\t}\n\n\t \n\tif (barwidth != width)\n\t\treturn 0;\n\n\tif ((bartgt < 0 || bartgt == tgt) &&\n\t    (bartok < 0 || bartok == tok) &&\n\t    (baract == act) &&\n\t    bar->base <= offset &&\n\t    (bar->base + (1 << bar->bitsize)) >= (offset + size))\n\t\treturn 1;\n\n\t \n\treturn 0;\n}\n\nstatic int\nfind_matching_bar(struct nfp6000_pcie *nfp,\n\t\t  u32 tgt, u32 act, u32 tok, u64 offset, size_t size, int width)\n{\n\tint n;\n\n\tfor (n = 0; n < nfp->bars; n++) {\n\t\tstruct nfp_bar *bar = &nfp->bar[n];\n\n\t\tif (matching_bar(bar, tgt, act, tok, offset, size, width))\n\t\t\treturn n;\n\t}\n\n\treturn -1;\n}\n\n \nstatic int\nfind_unused_bar_noblock(const struct nfp6000_pcie *nfp,\n\t\t\tint tgt, int act, int tok,\n\t\t\tu64 offset, size_t size, int width)\n{\n\tint n, busy = 0;\n\n\tfor (n = 0; n < nfp->bars; n++) {\n\t\tconst struct nfp_bar *bar = &nfp->bar[n];\n\t\tint err;\n\n\t\tif (!bar->bitsize)\n\t\t\tcontinue;\n\n\t\t \n\t\terr = compute_bar(nfp, bar, NULL, NULL,\n\t\t\t\t  tgt, act, tok, offset, size, width);\n\t\tif (err)\n\t\t\tcontinue;\n\n\t\tif (!atomic_read(&bar->refcnt))\n\t\t\treturn n;\n\n\t\tbusy++;\n\t}\n\n\tif (WARN(!busy, \"No suitable BAR found for request tgt:0x%x act:0x%x tok:0x%x off:0x%llx size:%zd width:%d\\n\",\n\t\t tgt, act, tok, offset, size, width))\n\t\treturn -EINVAL;\n\n\treturn -EAGAIN;\n}\n\nstatic int\nfind_unused_bar_and_lock(struct nfp6000_pcie *nfp,\n\t\t\t int tgt, int act, int tok,\n\t\t\t u64 offset, size_t size, int width)\n{\n\tunsigned long flags;\n\tint n;\n\n\tspin_lock_irqsave(&nfp->bar_lock, flags);\n\n\tn = find_unused_bar_noblock(nfp, tgt, act, tok, offset, size, width);\n\tif (n < 0)\n\t\tspin_unlock_irqrestore(&nfp->bar_lock, flags);\n\telse\n\t\t__release(&nfp->bar_lock);\n\n\treturn n;\n}\n\nstatic void nfp_bar_get(struct nfp6000_pcie *nfp, struct nfp_bar *bar)\n{\n\tatomic_inc(&bar->refcnt);\n}\n\nstatic void nfp_bar_put(struct nfp6000_pcie *nfp, struct nfp_bar *bar)\n{\n\tif (atomic_dec_and_test(&bar->refcnt))\n\t\twake_up_interruptible(&nfp->bar_waiters);\n}\n\nstatic int\nnfp_wait_for_bar(struct nfp6000_pcie *nfp, int *barnum,\n\t\t u32 tgt, u32 act, u32 tok, u64 offset, size_t size, int width)\n{\n\treturn wait_event_interruptible(nfp->bar_waiters,\n\t\t(*barnum = find_unused_bar_and_lock(nfp, tgt, act, tok,\n\t\t\t\t\t\t    offset, size, width))\n\t\t\t\t\t!= -EAGAIN);\n}\n\nstatic int\nnfp_alloc_bar(struct nfp6000_pcie *nfp,\n\t      u32 tgt, u32 act, u32 tok,\n\t      u64 offset, size_t size, int width, int nonblocking)\n{\n\tunsigned long irqflags;\n\tint barnum, retval;\n\n\tif (size > (1 << 24))\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&nfp->bar_lock, irqflags);\n\tbarnum = find_matching_bar(nfp, tgt, act, tok, offset, size, width);\n\tif (barnum >= 0) {\n\t\t \n\t\tnfp_bar_get(nfp, &nfp->bar[barnum]);\n\t\tspin_unlock_irqrestore(&nfp->bar_lock, irqflags);\n\t\treturn barnum;\n\t}\n\n\tbarnum = find_unused_bar_noblock(nfp, tgt, act, tok,\n\t\t\t\t\t offset, size, width);\n\tif (barnum < 0) {\n\t\tif (nonblocking)\n\t\t\tgoto err_nobar;\n\n\t\t \n\t\tspin_unlock_irqrestore(&nfp->bar_lock, irqflags);\n\t\tretval = nfp_wait_for_bar(nfp, &barnum, tgt, act, tok,\n\t\t\t\t\t  offset, size, width);\n\t\tif (retval)\n\t\t\treturn retval;\n\t\t__acquire(&nfp->bar_lock);\n\t}\n\n\tnfp_bar_get(nfp, &nfp->bar[barnum]);\n\tretval = reconfigure_bar(nfp, &nfp->bar[barnum],\n\t\t\t\t tgt, act, tok, offset, size, width);\n\tif (retval < 0) {\n\t\tnfp_bar_put(nfp, &nfp->bar[barnum]);\n\t\tbarnum = retval;\n\t}\n\nerr_nobar:\n\tspin_unlock_irqrestore(&nfp->bar_lock, irqflags);\n\treturn barnum;\n}\n\nstatic void disable_bars(struct nfp6000_pcie *nfp);\n\nstatic int bar_cmp(const void *aptr, const void *bptr)\n{\n\tconst struct nfp_bar *a = aptr, *b = bptr;\n\n\tif (a->bitsize == b->bitsize)\n\t\treturn a->index - b->index;\n\telse\n\t\treturn a->bitsize - b->bitsize;\n}\n\n \nstatic int enable_bars(struct nfp6000_pcie *nfp, u16 interface)\n{\n\tconst u32 barcfg_msix_general =\n\t\tNFP_PCIE_BAR_PCIE2CPP_MapType(\n\t\t\tNFP_PCIE_BAR_PCIE2CPP_MapType_GENERAL) |\n\t\tNFP_PCIE_BAR_PCIE2CPP_LengthSelect_32BIT;\n\tconst u32 barcfg_msix_xpb =\n\t\tNFP_PCIE_BAR_PCIE2CPP_MapType(\n\t\t\tNFP_PCIE_BAR_PCIE2CPP_MapType_BULK) |\n\t\tNFP_PCIE_BAR_PCIE2CPP_LengthSelect_32BIT |\n\t\tNFP_PCIE_BAR_PCIE2CPP_Target_BaseAddress(\n\t\t\tNFP_CPP_TARGET_ISLAND_XPB);\n\tconst u32 barcfg_explicit[4] = {\n\t\tNFP_PCIE_BAR_PCIE2CPP_MapType(\n\t\t\tNFP_PCIE_BAR_PCIE2CPP_MapType_EXPLICIT0),\n\t\tNFP_PCIE_BAR_PCIE2CPP_MapType(\n\t\t\tNFP_PCIE_BAR_PCIE2CPP_MapType_EXPLICIT1),\n\t\tNFP_PCIE_BAR_PCIE2CPP_MapType(\n\t\t\tNFP_PCIE_BAR_PCIE2CPP_MapType_EXPLICIT2),\n\t\tNFP_PCIE_BAR_PCIE2CPP_MapType(\n\t\t\tNFP_PCIE_BAR_PCIE2CPP_MapType_EXPLICIT3),\n\t};\n\tchar status_msg[196] = {};\n\tint i, err, bars_free;\n\tstruct nfp_bar *bar;\n\tint expl_groups;\n\tchar *msg, *end;\n\n\tmsg = status_msg +\n\t\tsnprintf(status_msg, sizeof(status_msg) - 1, \"RESERVED BARs: \");\n\tend = status_msg + sizeof(status_msg) - 1;\n\n\tbar = &nfp->bar[0];\n\tfor (i = 0; i < ARRAY_SIZE(nfp->bar); i++, bar++) {\n\t\tstruct resource *res;\n\n\t\tres = &nfp->pdev->resource[(i >> 3) * 2];\n\n\t\t \n\t\tif (!(resource_type(res) & IORESOURCE_MEM)) {\n\t\t\tbar--;\n\t\t\tcontinue;\n\t\t}\n\n\t\tbar->resource = res;\n\t\tbar->barcfg = 0;\n\n\t\tbar->nfp = nfp;\n\t\tbar->index = i;\n\t\tbar->mask = nfp_bar_resource_len(bar) - 1;\n\t\tbar->bitsize = fls(bar->mask);\n\t\tbar->base = 0;\n\t\tbar->iomem = NULL;\n\t}\n\n\tnfp->bars = bar - &nfp->bar[0];\n\tif (nfp->bars < 8) {\n\t\tdev_err(nfp->dev, \"No usable BARs found!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tbars_free = nfp->bars;\n\n\t \n\tmutex_init(&nfp->expl.mutex);\n\n\tnfp->expl.master_id = ((NFP_CPP_INTERFACE_UNIT_of(interface) & 3) + 4)\n\t\t<< 4;\n\tnfp->expl.signal_ref = 0x10;\n\n\t \n\tbar = &nfp->bar[0];\n\tif (nfp_bar_resource_len(bar) >= NFP_PCI_MIN_MAP_SIZE)\n\t\tbar->iomem = ioremap(nfp_bar_resource_start(bar),\n\t\t\t\t\t     nfp_bar_resource_len(bar));\n\tif (bar->iomem) {\n\t\tint pf;\n\n\t\tmsg += scnprintf(msg, end - msg, \"0.0: General/MSI-X SRAM, \");\n\t\tatomic_inc(&bar->refcnt);\n\t\tbars_free--;\n\n\t\tnfp6000_bar_write(nfp, bar, barcfg_msix_general);\n\n\t\tnfp->expl.data = bar->iomem + NFP_PCIE_SRAM +\n\t\t\tnfp->dev_info->pcie_expl_offset;\n\n\t\tswitch (nfp->pdev->device) {\n\t\tcase PCI_DEVICE_ID_NFP3800:\n\t\t\tpf = nfp->pdev->devfn & 7;\n\t\t\tnfp->iomem.csr = bar->iomem + NFP_PCIE_BAR(pf);\n\t\t\tbreak;\n\t\tcase PCI_DEVICE_ID_NFP4000:\n\t\tcase PCI_DEVICE_ID_NFP5000:\n\t\tcase PCI_DEVICE_ID_NFP6000:\n\t\t\tnfp->iomem.csr = bar->iomem + NFP_PCIE_BAR(0);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(nfp->dev, \"Unsupported device ID: %04hx!\\n\",\n\t\t\t\tnfp->pdev->device);\n\t\t\terr = -EINVAL;\n\t\t\tgoto err_unmap_bar0;\n\t\t}\n\t\tnfp->iomem.em = bar->iomem + NFP_PCIE_EM;\n\t}\n\n\tswitch (nfp->pdev->device) {\n\tcase PCI_DEVICE_ID_NFP3800:\n\t\texpl_groups = 1;\n\t\tbreak;\n\tcase PCI_DEVICE_ID_NFP4000:\n\tcase PCI_DEVICE_ID_NFP5000:\n\tcase PCI_DEVICE_ID_NFP6000:\n\t\texpl_groups = 4;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(nfp->dev, \"Unsupported device ID: %04hx!\\n\",\n\t\t\tnfp->pdev->device);\n\t\terr = -EINVAL;\n\t\tgoto err_unmap_bar0;\n\t}\n\n\t \n\tbar = &nfp->bar[1];\n\tmsg += scnprintf(msg, end - msg, \"0.1: PCIe XPB/MSI-X PBA, \");\n\tatomic_inc(&bar->refcnt);\n\tbars_free--;\n\n\tnfp6000_bar_write(nfp, bar, barcfg_msix_xpb);\n\n\t \n\tfor (i = 0; i < 4; i++) {\n\t\tint j;\n\n\t\tif (i >= NFP_PCIE_EXPLICIT_BARS || i >= expl_groups) {\n\t\t\tnfp->expl.group[i].bitsize = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tbar = &nfp->bar[4 + i];\n\t\tbar->iomem = ioremap(nfp_bar_resource_start(bar),\n\t\t\t\t\t     nfp_bar_resource_len(bar));\n\t\tif (bar->iomem) {\n\t\t\tmsg += scnprintf(msg, end - msg,\n\t\t\t\t\t \"0.%d: Explicit%d, \", 4 + i, i);\n\t\t\tatomic_inc(&bar->refcnt);\n\t\t\tbars_free--;\n\n\t\t\tnfp->expl.group[i].bitsize = bar->bitsize;\n\t\t\tnfp->expl.group[i].addr = bar->iomem;\n\t\t\tnfp6000_bar_write(nfp, bar, barcfg_explicit[i]);\n\n\t\t\tfor (j = 0; j < 4; j++)\n\t\t\t\tnfp->expl.group[i].free[j] = true;\n\t\t}\n\t\tnfp->iomem.expl[i] = bar->iomem;\n\t}\n\n\t \n\tsort(&nfp->bar[0], nfp->bars, sizeof(nfp->bar[0]),\n\t     bar_cmp, NULL);\n\n\tdev_info(nfp->dev, \"%sfree: %d/%d\\n\", status_msg, bars_free, nfp->bars);\n\n\treturn 0;\n\nerr_unmap_bar0:\n\tif (nfp->bar[0].iomem)\n\t\tiounmap(nfp->bar[0].iomem);\n\treturn err;\n}\n\nstatic void disable_bars(struct nfp6000_pcie *nfp)\n{\n\tstruct nfp_bar *bar = &nfp->bar[0];\n\tint n;\n\n\tfor (n = 0; n < nfp->bars; n++, bar++) {\n\t\tif (bar->iomem) {\n\t\t\tiounmap(bar->iomem);\n\t\t\tbar->iomem = NULL;\n\t\t}\n\t}\n}\n\n \n\nstruct nfp6000_area_priv {\n\tatomic_t refcnt;\n\n\tstruct nfp_bar *bar;\n\tu32 bar_offset;\n\n\tu32 target;\n\tu32 action;\n\tu32 token;\n\tu64 offset;\n\tstruct {\n\t\tint read;\n\t\tint write;\n\t\tint bar;\n\t} width;\n\tsize_t size;\n\n\tvoid __iomem *iomem;\n\tphys_addr_t phys;\n\tstruct resource resource;\n};\n\nstatic int nfp6000_area_init(struct nfp_cpp_area *area, u32 dest,\n\t\t\t     unsigned long long address, unsigned long size)\n{\n\tstruct nfp6000_area_priv *priv = nfp_cpp_area_priv(area);\n\tu32 target = NFP_CPP_ID_TARGET_of(dest);\n\tu32 action = NFP_CPP_ID_ACTION_of(dest);\n\tu32 token = NFP_CPP_ID_TOKEN_of(dest);\n\tint pp;\n\n\tpp = nfp_target_pushpull(NFP_CPP_ID(target, action, token), address);\n\tif (pp < 0)\n\t\treturn pp;\n\n\tpriv->width.read = PUSH_WIDTH(pp);\n\tpriv->width.write = PULL_WIDTH(pp);\n\tif (priv->width.read > 0 &&\n\t    priv->width.write > 0 &&\n\t    priv->width.read != priv->width.write) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (priv->width.read > 0)\n\t\tpriv->width.bar = priv->width.read;\n\telse\n\t\tpriv->width.bar = priv->width.write;\n\n\tatomic_set(&priv->refcnt, 0);\n\tpriv->bar = NULL;\n\n\tpriv->target = target;\n\tpriv->action = action;\n\tpriv->token = token;\n\tpriv->offset = address;\n\tpriv->size = size;\n\tmemset(&priv->resource, 0, sizeof(priv->resource));\n\n\treturn 0;\n}\n\nstatic void nfp6000_area_cleanup(struct nfp_cpp_area *area)\n{\n}\n\nstatic void priv_area_get(struct nfp_cpp_area *area)\n{\n\tstruct nfp6000_area_priv *priv = nfp_cpp_area_priv(area);\n\n\tatomic_inc(&priv->refcnt);\n}\n\nstatic int priv_area_put(struct nfp_cpp_area *area)\n{\n\tstruct nfp6000_area_priv *priv = nfp_cpp_area_priv(area);\n\n\tif (WARN_ON(!atomic_read(&priv->refcnt)))\n\t\treturn 0;\n\n\treturn atomic_dec_and_test(&priv->refcnt);\n}\n\nstatic int nfp6000_area_acquire(struct nfp_cpp_area *area)\n{\n\tstruct nfp6000_pcie *nfp = nfp_cpp_priv(nfp_cpp_area_cpp(area));\n\tstruct nfp6000_area_priv *priv = nfp_cpp_area_priv(area);\n\tint barnum, err;\n\n\tif (priv->bar) {\n\t\t \n\t\tpriv_area_get(area);\n\t\treturn 0;\n\t}\n\n\tbarnum = nfp_alloc_bar(nfp, priv->target, priv->action, priv->token,\n\t\t\t       priv->offset, priv->size, priv->width.bar, 1);\n\n\tif (barnum < 0) {\n\t\terr = barnum;\n\t\tgoto err_alloc_bar;\n\t}\n\tpriv->bar = &nfp->bar[barnum];\n\n\t \n\tif (nfp_bar_maptype(priv->bar) ==\n\t    NFP_PCIE_BAR_PCIE2CPP_MapType_GENERAL) {\n\t\tpriv->bar_offset = priv->offset &\n\t\t\t(NFP_PCIE_P2C_GENERAL_SIZE(priv->bar) - 1);\n\t\tpriv->bar_offset += NFP_PCIE_P2C_GENERAL_TARGET_OFFSET(\n\t\t\tpriv->bar, priv->target);\n\t\tpriv->bar_offset += NFP_PCIE_P2C_GENERAL_TOKEN_OFFSET(\n\t\t\tpriv->bar, priv->token);\n\t} else {\n\t\tpriv->bar_offset = priv->offset & priv->bar->mask;\n\t}\n\n\t \n\tpriv->phys = nfp_bar_resource_start(priv->bar) + priv->bar_offset;\n\tpriv->resource.name = nfp_cpp_area_name(area);\n\tpriv->resource.start = priv->phys;\n\tpriv->resource.end = priv->resource.start + priv->size - 1;\n\tpriv->resource.flags = IORESOURCE_MEM;\n\n\t \n\tif (priv->bar->iomem)\n\t\tpriv->iomem = priv->bar->iomem + priv->bar_offset;\n\telse\n\t\t \n\t\tpriv->iomem = ioremap(priv->phys, priv->size);\n\n\tif (IS_ERR_OR_NULL(priv->iomem)) {\n\t\tdev_err(nfp->dev, \"Can't ioremap() a %d byte region of BAR %d\\n\",\n\t\t\t(int)priv->size, priv->bar->index);\n\t\terr = !priv->iomem ? -ENOMEM : PTR_ERR(priv->iomem);\n\t\tpriv->iomem = NULL;\n\t\tgoto err_iomem_remap;\n\t}\n\n\tpriv_area_get(area);\n\treturn 0;\n\nerr_iomem_remap:\n\tnfp_bar_put(nfp, priv->bar);\n\tpriv->bar = NULL;\nerr_alloc_bar:\n\treturn err;\n}\n\nstatic void nfp6000_area_release(struct nfp_cpp_area *area)\n{\n\tstruct nfp6000_pcie *nfp = nfp_cpp_priv(nfp_cpp_area_cpp(area));\n\tstruct nfp6000_area_priv *priv = nfp_cpp_area_priv(area);\n\n\tif (!priv_area_put(area))\n\t\treturn;\n\n\tif (!priv->bar->iomem)\n\t\tiounmap(priv->iomem);\n\n\tnfp_bar_put(nfp, priv->bar);\n\n\tpriv->bar = NULL;\n\tpriv->iomem = NULL;\n}\n\nstatic phys_addr_t nfp6000_area_phys(struct nfp_cpp_area *area)\n{\n\tstruct nfp6000_area_priv *priv = nfp_cpp_area_priv(area);\n\n\treturn priv->phys;\n}\n\nstatic void __iomem *nfp6000_area_iomem(struct nfp_cpp_area *area)\n{\n\tstruct nfp6000_area_priv *priv = nfp_cpp_area_priv(area);\n\n\treturn priv->iomem;\n}\n\nstatic struct resource *nfp6000_area_resource(struct nfp_cpp_area *area)\n{\n\t \n\tstruct nfp6000_area_priv *priv = nfp_cpp_area_priv(area);\n\n\treturn priv->bar->resource;\n}\n\nstatic int nfp6000_area_read(struct nfp_cpp_area *area, void *kernel_vaddr,\n\t\t\t     unsigned long offset, unsigned int length)\n{\n\tu64 __maybe_unused *wrptr64 = kernel_vaddr;\n\tconst u64 __iomem __maybe_unused *rdptr64;\n\tstruct nfp6000_area_priv *priv;\n\tu32 *wrptr32 = kernel_vaddr;\n\tconst u32 __iomem *rdptr32;\n\tint n, width;\n\n\tpriv = nfp_cpp_area_priv(area);\n\trdptr64 = priv->iomem + offset;\n\trdptr32 = priv->iomem + offset;\n\n\tif (offset + length > priv->size)\n\t\treturn -EFAULT;\n\n\twidth = priv->width.read;\n\tif (width <= 0)\n\t\treturn -EINVAL;\n\n\t \n\tif (priv->target == (NFP_CPP_TARGET_MU & NFP_CPP_TARGET_ID_MASK) &&\n\t    priv->action == NFP_CPP_ACTION_RW &&\n\t    (offset % sizeof(u64) == 4 || length % sizeof(u64) == 4))\n\t\twidth = TARGET_WIDTH_32;\n\n\t \n\tif ((priv->offset + offset) & (width - 1))\n\t\treturn nfp_cpp_explicit_read(nfp_cpp_area_cpp(area),\n\t\t\t\t\t     NFP_CPP_ID(priv->target,\n\t\t\t\t\t\t\tpriv->action,\n\t\t\t\t\t\t\tpriv->token),\n\t\t\t\t\t     priv->offset + offset,\n\t\t\t\t\t     kernel_vaddr, length, width);\n\n\tif (WARN_ON(!priv->bar))\n\t\treturn -EFAULT;\n\n\tswitch (width) {\n\tcase TARGET_WIDTH_32:\n\t\tif (offset % sizeof(u32) != 0 || length % sizeof(u32) != 0)\n\t\t\treturn -EINVAL;\n\n\t\tfor (n = 0; n < length; n += sizeof(u32))\n\t\t\t*wrptr32++ = __raw_readl(rdptr32++);\n\t\treturn n;\n#ifdef __raw_readq\n\tcase TARGET_WIDTH_64:\n\t\tif (offset % sizeof(u64) != 0 || length % sizeof(u64) != 0)\n\t\t\treturn -EINVAL;\n\n\t\tfor (n = 0; n < length; n += sizeof(u64))\n\t\t\t*wrptr64++ = __raw_readq(rdptr64++);\n\t\treturn n;\n#endif\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int\nnfp6000_area_write(struct nfp_cpp_area *area,\n\t\t   const void *kernel_vaddr,\n\t\t   unsigned long offset, unsigned int length)\n{\n\tconst u64 __maybe_unused *rdptr64 = kernel_vaddr;\n\tu64 __iomem __maybe_unused *wrptr64;\n\tconst u32 *rdptr32 = kernel_vaddr;\n\tstruct nfp6000_area_priv *priv;\n\tu32 __iomem *wrptr32;\n\tint n, width;\n\n\tpriv = nfp_cpp_area_priv(area);\n\twrptr64 = priv->iomem + offset;\n\twrptr32 = priv->iomem + offset;\n\n\tif (offset + length > priv->size)\n\t\treturn -EFAULT;\n\n\twidth = priv->width.write;\n\tif (width <= 0)\n\t\treturn -EINVAL;\n\n\t \n\tif (priv->target == (NFP_CPP_TARGET_ID_MASK & NFP_CPP_TARGET_MU) &&\n\t    priv->action == NFP_CPP_ACTION_RW &&\n\t    (offset % sizeof(u64) == 4 || length % sizeof(u64) == 4))\n\t\twidth = TARGET_WIDTH_32;\n\n\t \n\tif ((priv->offset + offset) & (width - 1))\n\t\treturn nfp_cpp_explicit_write(nfp_cpp_area_cpp(area),\n\t\t\t\t\t      NFP_CPP_ID(priv->target,\n\t\t\t\t\t\t\t priv->action,\n\t\t\t\t\t\t\t priv->token),\n\t\t\t\t\t      priv->offset + offset,\n\t\t\t\t\t      kernel_vaddr, length, width);\n\n\tif (WARN_ON(!priv->bar))\n\t\treturn -EFAULT;\n\n\tswitch (width) {\n\tcase TARGET_WIDTH_32:\n\t\tif (offset % sizeof(u32) != 0 || length % sizeof(u32) != 0)\n\t\t\treturn -EINVAL;\n\n\t\tfor (n = 0; n < length; n += sizeof(u32)) {\n\t\t\t__raw_writel(*rdptr32++, wrptr32++);\n\t\t\twmb();\n\t\t}\n\t\treturn n;\n#ifdef __raw_writeq\n\tcase TARGET_WIDTH_64:\n\t\tif (offset % sizeof(u64) != 0 || length % sizeof(u64) != 0)\n\t\t\treturn -EINVAL;\n\n\t\tfor (n = 0; n < length; n += sizeof(u64)) {\n\t\t\t__raw_writeq(*rdptr64++, wrptr64++);\n\t\t\twmb();\n\t\t}\n\t\treturn n;\n#endif\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstruct nfp6000_explicit_priv {\n\tstruct nfp6000_pcie *nfp;\n\tstruct {\n\t\tint group;\n\t\tint area;\n\t} bar;\n\tint bitsize;\n\tvoid __iomem *data;\n\tvoid __iomem *addr;\n};\n\nstatic int nfp6000_explicit_acquire(struct nfp_cpp_explicit *expl)\n{\n\tstruct nfp6000_pcie *nfp = nfp_cpp_priv(nfp_cpp_explicit_cpp(expl));\n\tstruct nfp6000_explicit_priv *priv = nfp_cpp_explicit_priv(expl);\n\tint i, j;\n\n\tmutex_lock(&nfp->expl.mutex);\n\tfor (i = 0; i < ARRAY_SIZE(nfp->expl.group); i++) {\n\t\tif (!nfp->expl.group[i].bitsize)\n\t\t\tcontinue;\n\n\t\tfor (j = 0; j < ARRAY_SIZE(nfp->expl.group[i].free); j++) {\n\t\t\tu16 data_offset;\n\n\t\t\tif (!nfp->expl.group[i].free[j])\n\t\t\t\tcontinue;\n\n\t\t\tpriv->nfp = nfp;\n\t\t\tpriv->bar.group = i;\n\t\t\tpriv->bar.area = j;\n\t\t\tpriv->bitsize = nfp->expl.group[i].bitsize - 2;\n\n\t\t\tdata_offset = (priv->bar.group << 9) +\n\t\t\t\t(priv->bar.area << 7);\n\t\t\tpriv->data = nfp->expl.data + data_offset;\n\t\t\tpriv->addr = nfp->expl.group[i].addr +\n\t\t\t\t(priv->bar.area << priv->bitsize);\n\t\t\tnfp->expl.group[i].free[j] = false;\n\n\t\t\tmutex_unlock(&nfp->expl.mutex);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tmutex_unlock(&nfp->expl.mutex);\n\n\treturn -EAGAIN;\n}\n\nstatic void nfp6000_explicit_release(struct nfp_cpp_explicit *expl)\n{\n\tstruct nfp6000_explicit_priv *priv = nfp_cpp_explicit_priv(expl);\n\tstruct nfp6000_pcie *nfp = priv->nfp;\n\n\tmutex_lock(&nfp->expl.mutex);\n\tnfp->expl.group[priv->bar.group].free[priv->bar.area] = true;\n\tmutex_unlock(&nfp->expl.mutex);\n}\n\nstatic int nfp6000_explicit_put(struct nfp_cpp_explicit *expl,\n\t\t\t\tconst void *buff, size_t len)\n{\n\tstruct nfp6000_explicit_priv *priv = nfp_cpp_explicit_priv(expl);\n\tconst u32 *src = buff;\n\tsize_t i;\n\n\tfor (i = 0; i < len; i += sizeof(u32))\n\t\twritel(*(src++), priv->data + i);\n\n\treturn i;\n}\n\nstatic int\nnfp6000_explicit_do(struct nfp_cpp_explicit *expl,\n\t\t    const struct nfp_cpp_explicit_command *cmd, u64 address)\n{\n\tstruct nfp6000_explicit_priv *priv = nfp_cpp_explicit_priv(expl);\n\tu8 signal_master, signal_ref, data_master;\n\tstruct nfp6000_pcie *nfp = priv->nfp;\n\tint sigmask = 0;\n\tu16 data_ref;\n\tu32 csr[3];\n\n\tif (cmd->siga_mode)\n\t\tsigmask |= 1 << cmd->siga;\n\tif (cmd->sigb_mode)\n\t\tsigmask |= 1 << cmd->sigb;\n\n\tsignal_master = cmd->signal_master;\n\tif (!signal_master)\n\t\tsignal_master = nfp->expl.master_id;\n\n\tsignal_ref = cmd->signal_ref;\n\tif (signal_master == nfp->expl.master_id)\n\t\tsignal_ref = nfp->expl.signal_ref +\n\t\t\t((priv->bar.group * 4 + priv->bar.area) << 1);\n\n\tdata_master = cmd->data_master;\n\tif (!data_master)\n\t\tdata_master = nfp->expl.master_id;\n\n\tdata_ref = cmd->data_ref;\n\tif (data_master == nfp->expl.master_id)\n\t\tdata_ref = 0x1000 +\n\t\t\t(priv->bar.group << 9) + (priv->bar.area << 7);\n\n\tcsr[0] = NFP_PCIE_BAR_EXPLICIT_BAR0_SignalType(sigmask) |\n\t\tNFP_PCIE_BAR_EXPLICIT_BAR0_Token(\n\t\t\tNFP_CPP_ID_TOKEN_of(cmd->cpp_id)) |\n\t\tNFP_PCIE_BAR_EXPLICIT_BAR0_Address(address >> 16);\n\n\tcsr[1] = NFP_PCIE_BAR_EXPLICIT_BAR1_SignalRef(signal_ref) |\n\t\tNFP_PCIE_BAR_EXPLICIT_BAR1_DataMaster(data_master) |\n\t\tNFP_PCIE_BAR_EXPLICIT_BAR1_DataRef(data_ref);\n\n\tcsr[2] = NFP_PCIE_BAR_EXPLICIT_BAR2_Target(\n\t\t\tNFP_CPP_ID_TARGET_of(cmd->cpp_id)) |\n\t\tNFP_PCIE_BAR_EXPLICIT_BAR2_Action(\n\t\t\tNFP_CPP_ID_ACTION_of(cmd->cpp_id)) |\n\t\tNFP_PCIE_BAR_EXPLICIT_BAR2_Length(cmd->len) |\n\t\tNFP_PCIE_BAR_EXPLICIT_BAR2_ByteMask(cmd->byte_mask) |\n\t\tNFP_PCIE_BAR_EXPLICIT_BAR2_SignalMaster(signal_master);\n\n\tif (nfp->iomem.csr) {\n\t\twritel(csr[0], nfp->iomem.csr +\n\t\t       NFP_PCIE_BAR_EXPLICIT_BAR0(priv->bar.group,\n\t\t\t\t\t\t  priv->bar.area));\n\t\twritel(csr[1], nfp->iomem.csr +\n\t\t       NFP_PCIE_BAR_EXPLICIT_BAR1(priv->bar.group,\n\t\t\t\t\t\t  priv->bar.area));\n\t\twritel(csr[2], nfp->iomem.csr +\n\t\t       NFP_PCIE_BAR_EXPLICIT_BAR2(priv->bar.group,\n\t\t\t\t\t\t  priv->bar.area));\n\t\t \n\t\treadl(nfp->iomem.csr +\n\t\t      NFP_PCIE_BAR_EXPLICIT_BAR0(priv->bar.group,\n\t\t\t\t\t\t priv->bar.area));\n\t\treadl(nfp->iomem.csr +\n\t\t      NFP_PCIE_BAR_EXPLICIT_BAR1(priv->bar.group,\n\t\t\t\t\t\t priv->bar.area));\n\t\treadl(nfp->iomem.csr +\n\t\t      NFP_PCIE_BAR_EXPLICIT_BAR2(priv->bar.group,\n\t\t\t\t\t\t priv->bar.area));\n\t} else {\n\t\tpci_write_config_dword(nfp->pdev, 0x400 +\n\t\t\t\t       NFP_PCIE_BAR_EXPLICIT_BAR0(\n\t\t\t\t\t       priv->bar.group, priv->bar.area),\n\t\t\t\t       csr[0]);\n\n\t\tpci_write_config_dword(nfp->pdev, 0x400 +\n\t\t\t\t       NFP_PCIE_BAR_EXPLICIT_BAR1(\n\t\t\t\t\t       priv->bar.group, priv->bar.area),\n\t\t\t\t       csr[1]);\n\n\t\tpci_write_config_dword(nfp->pdev, 0x400 +\n\t\t\t\t       NFP_PCIE_BAR_EXPLICIT_BAR2(\n\t\t\t\t\t       priv->bar.group, priv->bar.area),\n\t\t\t\t       csr[2]);\n\t}\n\n\t \n\treadb(priv->addr + (address & ((1 << priv->bitsize) - 1)));\n\n\treturn sigmask;\n}\n\nstatic int nfp6000_explicit_get(struct nfp_cpp_explicit *expl,\n\t\t\t\tvoid *buff, size_t len)\n{\n\tstruct nfp6000_explicit_priv *priv = nfp_cpp_explicit_priv(expl);\n\tu32 *dst = buff;\n\tsize_t i;\n\n\tfor (i = 0; i < len; i += sizeof(u32))\n\t\t*(dst++) = readl(priv->data + i);\n\n\treturn i;\n}\n\nstatic int nfp6000_init(struct nfp_cpp *cpp)\n{\n\tnfp_cpp_area_cache_add(cpp, SZ_64K);\n\tnfp_cpp_area_cache_add(cpp, SZ_64K);\n\tnfp_cpp_area_cache_add(cpp, SZ_256K);\n\n\treturn 0;\n}\n\nstatic void nfp6000_free(struct nfp_cpp *cpp)\n{\n\tstruct nfp6000_pcie *nfp = nfp_cpp_priv(cpp);\n\n\tdisable_bars(nfp);\n\tkfree(nfp);\n}\n\nstatic int nfp6000_read_serial(struct device *dev, u8 *serial)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tu64 dsn;\n\n\tdsn = pci_get_dsn(pdev);\n\tif (!dsn) {\n\t\tdev_err(dev, \"can't find PCIe Serial Number Capability\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tput_unaligned_be32((u32)(dsn >> 32), serial);\n\tput_unaligned_be16((u16)(dsn >> 16), serial + 4);\n\n\treturn 0;\n}\n\nstatic int nfp6000_get_interface(struct device *dev)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tu64 dsn;\n\n\tdsn = pci_get_dsn(pdev);\n\tif (!dsn) {\n\t\tdev_err(dev, \"can't find PCIe Serial Number Capability\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn dsn & 0xffff;\n}\n\nstatic const struct nfp_cpp_operations nfp6000_pcie_ops = {\n\t.owner\t\t\t= THIS_MODULE,\n\n\t.init\t\t\t= nfp6000_init,\n\t.free\t\t\t= nfp6000_free,\n\n\t.read_serial\t\t= nfp6000_read_serial,\n\t.get_interface\t\t= nfp6000_get_interface,\n\n\t.area_priv_size\t\t= sizeof(struct nfp6000_area_priv),\n\t.area_init\t\t= nfp6000_area_init,\n\t.area_cleanup\t\t= nfp6000_area_cleanup,\n\t.area_acquire\t\t= nfp6000_area_acquire,\n\t.area_release\t\t= nfp6000_area_release,\n\t.area_phys\t\t= nfp6000_area_phys,\n\t.area_iomem\t\t= nfp6000_area_iomem,\n\t.area_resource\t\t= nfp6000_area_resource,\n\t.area_read\t\t= nfp6000_area_read,\n\t.area_write\t\t= nfp6000_area_write,\n\n\t.explicit_priv_size\t= sizeof(struct nfp6000_explicit_priv),\n\t.explicit_acquire\t= nfp6000_explicit_acquire,\n\t.explicit_release\t= nfp6000_explicit_release,\n\t.explicit_put\t\t= nfp6000_explicit_put,\n\t.explicit_do\t\t= nfp6000_explicit_do,\n\t.explicit_get\t\t= nfp6000_explicit_get,\n};\n\n \nstruct nfp_cpp *\nnfp_cpp_from_nfp6000_pcie(struct pci_dev *pdev, const struct nfp_dev_info *dev_info)\n{\n\tstruct nfp6000_pcie *nfp;\n\tu16 interface;\n\tint err;\n\n\t \n\tdev_info(&pdev->dev, \"Network Flow Processor %s PCIe Card Probe\\n\",\n\t\t dev_info->chip_names);\n\tpcie_print_link_status(pdev);\n\n\tnfp = kzalloc(sizeof(*nfp), GFP_KERNEL);\n\tif (!nfp) {\n\t\terr = -ENOMEM;\n\t\tgoto err_ret;\n\t}\n\n\tnfp->dev = &pdev->dev;\n\tnfp->pdev = pdev;\n\tnfp->dev_info = dev_info;\n\tinit_waitqueue_head(&nfp->bar_waiters);\n\tspin_lock_init(&nfp->bar_lock);\n\n\tinterface = nfp6000_get_interface(&pdev->dev);\n\n\tif (NFP_CPP_INTERFACE_TYPE_of(interface) !=\n\t    NFP_CPP_INTERFACE_TYPE_PCI) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Interface type %d is not the expected %d\\n\",\n\t\t\tNFP_CPP_INTERFACE_TYPE_of(interface),\n\t\t\tNFP_CPP_INTERFACE_TYPE_PCI);\n\t\terr = -ENODEV;\n\t\tgoto err_free_nfp;\n\t}\n\n\tif (NFP_CPP_INTERFACE_CHANNEL_of(interface) !=\n\t    NFP_CPP_INTERFACE_CHANNEL_PEROPENER) {\n\t\tdev_err(&pdev->dev, \"Interface channel %d is not the expected %d\\n\",\n\t\t\tNFP_CPP_INTERFACE_CHANNEL_of(interface),\n\t\t\tNFP_CPP_INTERFACE_CHANNEL_PEROPENER);\n\t\terr = -ENODEV;\n\t\tgoto err_free_nfp;\n\t}\n\n\terr = enable_bars(nfp, interface);\n\tif (err)\n\t\tgoto err_free_nfp;\n\n\t \n\treturn nfp_cpp_from_operations(&nfp6000_pcie_ops, &pdev->dev, nfp);\n\nerr_free_nfp:\n\tkfree(nfp);\nerr_ret:\n\tdev_err(&pdev->dev, \"NFP6000 PCI setup failed\\n\");\n\treturn ERR_PTR(err);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}