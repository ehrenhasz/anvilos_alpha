{
  "module_name": "nfp_cpplib.c",
  "hash_id": "0fdd348b09d335f2b156cb692be465c848b4f71a08b004ab14f8fb931d411295",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/netronome/nfp/nfpcore/nfp_cpplib.c",
  "human_readable_source": "\n \n\n \n\n#include <asm/unaligned.h>\n#include <linux/bitfield.h>\n#include <linux/delay.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\n#include \"nfp_cpp.h\"\n#include \"nfp6000/nfp6000.h\"\n#include \"nfp6000/nfp_xpb.h\"\n\n \n#define NFP_PL_DEVICE_PART_NFP6000\t\t0x6200\n#define NFP_PL_DEVICE_ID\t\t\t0x00000004\n#define   NFP_PL_DEVICE_ID_MASK\t\t\tGENMASK(7, 0)\n#define   NFP_PL_DEVICE_PART_MASK\t\tGENMASK(31, 16)\n#define NFP_PL_DEVICE_MODEL_MASK\t\t(NFP_PL_DEVICE_PART_MASK | \\\n\t\t\t\t\t\t NFP_PL_DEVICE_ID_MASK)\n\n \nint nfp_cpp_readl(struct nfp_cpp *cpp, u32 cpp_id,\n\t\t  unsigned long long address, u32 *value)\n{\n\tu8 tmp[4];\n\tint n;\n\n\tn = nfp_cpp_read(cpp, cpp_id, address, tmp, sizeof(tmp));\n\tif (n != sizeof(tmp))\n\t\treturn n < 0 ? n : -EIO;\n\n\t*value = get_unaligned_le32(tmp);\n\treturn 0;\n}\n\n \nint nfp_cpp_writel(struct nfp_cpp *cpp, u32 cpp_id,\n\t\t   unsigned long long address, u32 value)\n{\n\tu8 tmp[4];\n\tint n;\n\n\tput_unaligned_le32(value, tmp);\n\tn = nfp_cpp_write(cpp, cpp_id, address, tmp, sizeof(tmp));\n\n\treturn n == sizeof(tmp) ? 0 : n < 0 ? n : -EIO;\n}\n\n \nint nfp_cpp_readq(struct nfp_cpp *cpp, u32 cpp_id,\n\t\t  unsigned long long address, u64 *value)\n{\n\tu8 tmp[8];\n\tint n;\n\n\tn = nfp_cpp_read(cpp, cpp_id, address, tmp, sizeof(tmp));\n\tif (n != sizeof(tmp))\n\t\treturn n < 0 ? n : -EIO;\n\n\t*value = get_unaligned_le64(tmp);\n\treturn 0;\n}\n\n \nint nfp_cpp_writeq(struct nfp_cpp *cpp, u32 cpp_id,\n\t\t   unsigned long long address, u64 value)\n{\n\tu8 tmp[8];\n\tint n;\n\n\tput_unaligned_le64(value, tmp);\n\tn = nfp_cpp_write(cpp, cpp_id, address, tmp, sizeof(tmp));\n\n\treturn n == sizeof(tmp) ? 0 : n < 0 ? n : -EIO;\n}\n\n \nint nfp_cpp_model_autodetect(struct nfp_cpp *cpp, u32 *model)\n{\n\tu32 reg;\n\tint err;\n\n\terr = nfp_xpb_readl(cpp, NFP_XPB_DEVICE(1, 1, 16) + NFP_PL_DEVICE_ID,\n\t\t\t    &reg);\n\tif (err < 0)\n\t\treturn err;\n\n\t*model = reg & NFP_PL_DEVICE_MODEL_MASK;\n\t \n\tif (FIELD_GET(NFP_PL_DEVICE_PART_MASK, reg) ==\n\t    NFP_PL_DEVICE_PART_NFP6000) {\n\t\tif (*model & NFP_PL_DEVICE_ID_MASK)\n\t\t\t*model -= 0x10;\n\t}\n\n\treturn 0;\n}\n\nstatic u8 nfp_bytemask(int width, u64 addr)\n{\n\tif (width == 8)\n\t\treturn 0xff;\n\telse if (width == 4)\n\t\treturn 0x0f << (addr & 4);\n\telse if (width == 2)\n\t\treturn 0x03 << (addr & 6);\n\telse if (width == 1)\n\t\treturn 0x01 << (addr & 7);\n\telse\n\t\treturn 0;\n}\n\nint nfp_cpp_explicit_read(struct nfp_cpp *cpp, u32 cpp_id,\n\t\t\t  u64 addr, void *buff, size_t len, int width_read)\n{\n\tstruct nfp_cpp_explicit *expl;\n\tchar *tmp = buff;\n\tint err, i, incr;\n\tu8 byte_mask;\n\n\tif (len & (width_read - 1))\n\t\treturn -EINVAL;\n\n\texpl = nfp_cpp_explicit_acquire(cpp);\n\tif (!expl)\n\t\treturn -EBUSY;\n\n\tincr = min_t(int, 16 * width_read, 128);\n\tincr = min_t(int, incr, len);\n\n\t \n\tif (NFP_CPP_ID_ACTION_of(cpp_id) == NFP_CPP_ACTION_RW)\n\t\tcpp_id = NFP_CPP_ID(NFP_CPP_ID_TARGET_of(cpp_id), 0,\n\t\t\t\t    NFP_CPP_ID_TOKEN_of(cpp_id));\n\n\tbyte_mask = nfp_bytemask(width_read, addr);\n\n\tnfp_cpp_explicit_set_target(expl, cpp_id,\n\t\t\t\t    incr / width_read - 1, byte_mask);\n\tnfp_cpp_explicit_set_posted(expl, 1, 0, NFP_SIGNAL_PUSH,\n\t\t\t\t    0, NFP_SIGNAL_NONE);\n\n\tfor (i = 0; i < len; i += incr, addr += incr, tmp += incr) {\n\t\tif (i + incr > len) {\n\t\t\tincr = len - i;\n\t\t\tnfp_cpp_explicit_set_target(expl, cpp_id,\n\t\t\t\t\t\t    incr / width_read - 1,\n\t\t\t\t\t\t    0xff);\n\t\t}\n\n\t\terr = nfp_cpp_explicit_do(expl, addr);\n\t\tif (err < 0)\n\t\t\tgoto exit_release;\n\n\t\terr = nfp_cpp_explicit_get(expl, tmp, incr);\n\t\tif (err < 0)\n\t\t\tgoto exit_release;\n\t}\n\terr = len;\nexit_release:\n\tnfp_cpp_explicit_release(expl);\n\n\treturn err;\n}\n\nint nfp_cpp_explicit_write(struct nfp_cpp *cpp, u32 cpp_id, u64 addr,\n\t\t\t   const void *buff, size_t len, int width_write)\n{\n\tstruct nfp_cpp_explicit *expl;\n\tconst char *tmp = buff;\n\tint err, i, incr;\n\tu8 byte_mask;\n\n\tif (len & (width_write - 1))\n\t\treturn -EINVAL;\n\n\texpl = nfp_cpp_explicit_acquire(cpp);\n\tif (!expl)\n\t\treturn -EBUSY;\n\n\tincr = min_t(int, 16 * width_write, 128);\n\tincr = min_t(int, incr, len);\n\n\t \n\tif (NFP_CPP_ID_ACTION_of(cpp_id) == NFP_CPP_ACTION_RW)\n\t\tcpp_id = NFP_CPP_ID(NFP_CPP_ID_TARGET_of(cpp_id), 1,\n\t\t\t\t    NFP_CPP_ID_TOKEN_of(cpp_id));\n\n\tbyte_mask = nfp_bytemask(width_write, addr);\n\n\tnfp_cpp_explicit_set_target(expl, cpp_id,\n\t\t\t\t    incr / width_write - 1, byte_mask);\n\tnfp_cpp_explicit_set_posted(expl, 1, 0, NFP_SIGNAL_PULL,\n\t\t\t\t    0, NFP_SIGNAL_NONE);\n\n\tfor (i = 0; i < len; i += incr, addr += incr, tmp += incr) {\n\t\tif (i + incr > len) {\n\t\t\tincr = len - i;\n\t\t\tnfp_cpp_explicit_set_target(expl, cpp_id,\n\t\t\t\t\t\t    incr / width_write - 1,\n\t\t\t\t\t\t    0xff);\n\t\t}\n\n\t\terr = nfp_cpp_explicit_put(expl, tmp, incr);\n\t\tif (err < 0)\n\t\t\tgoto exit_release;\n\n\t\terr = nfp_cpp_explicit_do(expl, addr);\n\t\tif (err < 0)\n\t\t\tgoto exit_release;\n\t}\n\terr = len;\nexit_release:\n\tnfp_cpp_explicit_release(expl);\n\n\treturn err;\n}\n\n \nu8 __iomem *\nnfp_cpp_map_area(struct nfp_cpp *cpp, const char *name, u32 cpp_id, u64 addr,\n\t\t unsigned long size, struct nfp_cpp_area **area)\n{\n\tu8 __iomem *res;\n\n\t*area = nfp_cpp_area_alloc_acquire(cpp, name, cpp_id, addr, size);\n\tif (!*area)\n\t\tgoto err_eio;\n\n\tres = nfp_cpp_area_iomem(*area);\n\tif (!res)\n\t\tgoto err_release_free;\n\n\treturn res;\n\nerr_release_free:\n\tnfp_cpp_area_release_free(*area);\nerr_eio:\n\treturn (u8 __iomem *)ERR_PTR(-EIO);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}