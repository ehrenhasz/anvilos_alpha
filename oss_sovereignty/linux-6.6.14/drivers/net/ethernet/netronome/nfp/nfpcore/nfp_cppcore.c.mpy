{
  "module_name": "nfp_cppcore.c",
  "hash_id": "164aadcfbdbb37e15caccf7198eb5ef137de2ce73f22d6c7c3ee8eb31eae128d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/netronome/nfp/nfpcore/nfp_cppcore.c",
  "human_readable_source": "\n \n\n \n\n#include <asm/unaligned.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/ioport.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n\n#include \"nfp_arm.h\"\n#include \"nfp_cpp.h\"\n#include \"nfp6000/nfp6000.h\"\n\n#define NFP_ARM_GCSR_SOFTMODEL2                              0x0000014c\n#define NFP_ARM_GCSR_SOFTMODEL3                              0x00000150\n\nstruct nfp_cpp_resource {\n\tstruct list_head list;\n\tconst char *name;\n\tu32 cpp_id;\n\tu64 start;\n\tu64 end;\n};\n\n \nstruct nfp_cpp {\n\tstruct device dev;\n\n\tvoid *priv;\n\n\tu32 model;\n\tu16 interface;\n\tu8 serial[NFP_SERIAL_LEN];\n\n\tconst struct nfp_cpp_operations *op;\n\tstruct list_head resource_list;\n\trwlock_t resource_lock;\n\twait_queue_head_t waitq;\n\n\tu32 imb_cat_table[16];\n\tunsigned int mu_locality_lsb;\n\n\tstruct mutex area_cache_mutex;\n\tstruct list_head area_cache_list;\n};\n\n \nstruct nfp_cpp_area_cache {\n\tstruct list_head entry;\n\tu32 id;\n\tu64 addr;\n\tu32 size;\n\tstruct nfp_cpp_area *area;\n};\n\nstruct nfp_cpp_area {\n\tstruct nfp_cpp *cpp;\n\tstruct kref kref;\n\tatomic_t refcount;\n\tstruct mutex mutex;\t \n\tunsigned long long offset;\n\tunsigned long size;\n\tstruct nfp_cpp_resource resource;\n\tvoid __iomem *iomem;\n\t \n};\n\nstruct nfp_cpp_explicit {\n\tstruct nfp_cpp *cpp;\n\tstruct nfp_cpp_explicit_command cmd;\n\t \n};\n\nstatic void __resource_add(struct list_head *head, struct nfp_cpp_resource *res)\n{\n\tstruct nfp_cpp_resource *tmp;\n\tstruct list_head *pos;\n\n\tlist_for_each(pos, head) {\n\t\ttmp = container_of(pos, struct nfp_cpp_resource, list);\n\n\t\tif (tmp->cpp_id > res->cpp_id)\n\t\t\tbreak;\n\n\t\tif (tmp->cpp_id == res->cpp_id && tmp->start > res->start)\n\t\t\tbreak;\n\t}\n\n\tlist_add_tail(&res->list, pos);\n}\n\nstatic void __resource_del(struct nfp_cpp_resource *res)\n{\n\tlist_del_init(&res->list);\n}\n\nstatic void __release_cpp_area(struct kref *kref)\n{\n\tstruct nfp_cpp_area *area =\n\t\tcontainer_of(kref, struct nfp_cpp_area, kref);\n\tstruct nfp_cpp *cpp = nfp_cpp_area_cpp(area);\n\n\tif (area->cpp->op->area_cleanup)\n\t\tarea->cpp->op->area_cleanup(area);\n\n\twrite_lock(&cpp->resource_lock);\n\t__resource_del(&area->resource);\n\twrite_unlock(&cpp->resource_lock);\n\tkfree(area);\n}\n\nstatic void nfp_cpp_area_put(struct nfp_cpp_area *area)\n{\n\tkref_put(&area->kref, __release_cpp_area);\n}\n\nstatic struct nfp_cpp_area *nfp_cpp_area_get(struct nfp_cpp_area *area)\n{\n\tkref_get(&area->kref);\n\n\treturn area;\n}\n\n \nvoid nfp_cpp_free(struct nfp_cpp *cpp)\n{\n\tstruct nfp_cpp_area_cache *cache, *ctmp;\n\tstruct nfp_cpp_resource *res, *rtmp;\n\n\t \n\tlist_for_each_entry_safe(cache, ctmp, &cpp->area_cache_list, entry) {\n\t\tlist_del(&cache->entry);\n\t\tif (cache->id)\n\t\t\tnfp_cpp_area_release(cache->area);\n\t\tnfp_cpp_area_free(cache->area);\n\t\tkfree(cache);\n\t}\n\n\t \n\tWARN_ON(!list_empty(&cpp->resource_list));\n\n\t \n\tlist_for_each_entry_safe(res, rtmp, &cpp->resource_list, list) {\n\t\tstruct nfp_cpp_area *area = container_of(res,\n\t\t\t\t\t\t\t struct nfp_cpp_area,\n\t\t\t\t\t\t\t resource);\n\n\t\tdev_err(cpp->dev.parent, \"Dangling area: %d:%d:%d:0x%0llx-0x%0llx%s%s\\n\",\n\t\t\tNFP_CPP_ID_TARGET_of(res->cpp_id),\n\t\t\tNFP_CPP_ID_ACTION_of(res->cpp_id),\n\t\t\tNFP_CPP_ID_TOKEN_of(res->cpp_id),\n\t\t\tres->start, res->end,\n\t\t\tres->name ? \" \" : \"\",\n\t\t\tres->name ? res->name : \"\");\n\n\t\tif (area->cpp->op->area_release)\n\t\t\tarea->cpp->op->area_release(area);\n\n\t\t__release_cpp_area(&area->kref);\n\t}\n\n\tif (cpp->op->free)\n\t\tcpp->op->free(cpp);\n\n\tdevice_unregister(&cpp->dev);\n\n\tkfree(cpp);\n}\n\n \nu32 nfp_cpp_model(struct nfp_cpp *cpp)\n{\n\treturn cpp->model;\n}\n\n \nu16 nfp_cpp_interface(struct nfp_cpp *cpp)\n{\n\treturn cpp->interface;\n}\n\n \nint nfp_cpp_serial(struct nfp_cpp *cpp, const u8 **serial)\n{\n\t*serial = &cpp->serial[0];\n\treturn sizeof(cpp->serial);\n}\n\n#define NFP_IMB_TGTADDRESSMODECFG_MODE_of(_x)\t\t(((_x) >> 13) & 0x7)\n#define NFP_IMB_TGTADDRESSMODECFG_ADDRMODE\t\tBIT(12)\n#define   NFP_IMB_TGTADDRESSMODECFG_ADDRMODE_32_BIT\t0\n#define   NFP_IMB_TGTADDRESSMODECFG_ADDRMODE_40_BIT\tBIT(12)\n\nstatic int nfp_cpp_set_mu_locality_lsb(struct nfp_cpp *cpp)\n{\n\tunsigned int mode, addr40;\n\tu32 imbcppat;\n\tint res;\n\n\timbcppat = cpp->imb_cat_table[NFP_CPP_TARGET_MU];\n\tmode = NFP_IMB_TGTADDRESSMODECFG_MODE_of(imbcppat);\n\taddr40 = !!(imbcppat & NFP_IMB_TGTADDRESSMODECFG_ADDRMODE);\n\n\tres = nfp_cppat_mu_locality_lsb(mode, addr40);\n\tif (res < 0)\n\t\treturn res;\n\tcpp->mu_locality_lsb = res;\n\n\treturn 0;\n}\n\nunsigned int nfp_cpp_mu_locality_lsb(struct nfp_cpp *cpp)\n{\n\treturn cpp->mu_locality_lsb;\n}\n\n \nstruct nfp_cpp_area *\nnfp_cpp_area_alloc_with_name(struct nfp_cpp *cpp, u32 dest, const char *name,\n\t\t\t     unsigned long long address, unsigned long size)\n{\n\tstruct nfp_cpp_area *area;\n\tu64 tmp64 = address;\n\tint err, name_len;\n\n\t \n\terr = nfp_target_cpp(dest, tmp64, &dest, &tmp64, cpp->imb_cat_table);\n\tif (err < 0)\n\t\treturn NULL;\n\n\taddress = tmp64;\n\n\tif (!name)\n\t\tname = \"(reserved)\";\n\n\tname_len = strlen(name) + 1;\n\tarea = kzalloc(sizeof(*area) + cpp->op->area_priv_size + name_len,\n\t\t       GFP_KERNEL);\n\tif (!area)\n\t\treturn NULL;\n\n\tarea->cpp = cpp;\n\tarea->resource.name = (void *)area + sizeof(*area) +\n\t\tcpp->op->area_priv_size;\n\tmemcpy((char *)area->resource.name, name, name_len);\n\n\tarea->resource.cpp_id = dest;\n\tarea->resource.start = address;\n\tarea->resource.end = area->resource.start + size - 1;\n\tINIT_LIST_HEAD(&area->resource.list);\n\n\tatomic_set(&area->refcount, 0);\n\tkref_init(&area->kref);\n\tmutex_init(&area->mutex);\n\n\tif (cpp->op->area_init) {\n\t\tint err;\n\n\t\terr = cpp->op->area_init(area, dest, address, size);\n\t\tif (err < 0) {\n\t\t\tkfree(area);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\twrite_lock(&cpp->resource_lock);\n\t__resource_add(&cpp->resource_list, &area->resource);\n\twrite_unlock(&cpp->resource_lock);\n\n\tarea->offset = address;\n\tarea->size = size;\n\n\treturn area;\n}\n\n \nstruct nfp_cpp_area *\nnfp_cpp_area_alloc(struct nfp_cpp *cpp, u32 dest,\n\t\t   unsigned long long address, unsigned long size)\n{\n\treturn nfp_cpp_area_alloc_with_name(cpp, dest, NULL, address, size);\n}\n\n \nstruct nfp_cpp_area *\nnfp_cpp_area_alloc_acquire(struct nfp_cpp *cpp, const char *name, u32 dest,\n\t\t\t   unsigned long long address, unsigned long size)\n{\n\tstruct nfp_cpp_area *area;\n\n\tarea = nfp_cpp_area_alloc_with_name(cpp, dest, name, address, size);\n\tif (!area)\n\t\treturn NULL;\n\n\tif (nfp_cpp_area_acquire(area)) {\n\t\tnfp_cpp_area_free(area);\n\t\treturn NULL;\n\t}\n\n\treturn area;\n}\n\n \nvoid nfp_cpp_area_free(struct nfp_cpp_area *area)\n{\n\tif (atomic_read(&area->refcount))\n\t\tnfp_warn(area->cpp, \"Warning: freeing busy area\\n\");\n\tnfp_cpp_area_put(area);\n}\n\nstatic bool nfp_cpp_area_acquire_try(struct nfp_cpp_area *area, int *status)\n{\n\t*status = area->cpp->op->area_acquire(area);\n\n\treturn *status != -EAGAIN;\n}\n\nstatic int __nfp_cpp_area_acquire(struct nfp_cpp_area *area)\n{\n\tint err, status;\n\n\tif (atomic_inc_return(&area->refcount) > 1)\n\t\treturn 0;\n\n\tif (!area->cpp->op->area_acquire)\n\t\treturn 0;\n\n\terr = wait_event_interruptible(area->cpp->waitq,\n\t\t\t\t       nfp_cpp_area_acquire_try(area, &status));\n\tif (!err)\n\t\terr = status;\n\tif (err) {\n\t\tnfp_warn(area->cpp, \"Warning: area wait failed: %d\\n\", err);\n\t\tatomic_dec(&area->refcount);\n\t\treturn err;\n\t}\n\n\tnfp_cpp_area_get(area);\n\n\treturn 0;\n}\n\n \nint nfp_cpp_area_acquire(struct nfp_cpp_area *area)\n{\n\tint ret;\n\n\tmutex_lock(&area->mutex);\n\tret = __nfp_cpp_area_acquire(area);\n\tmutex_unlock(&area->mutex);\n\n\treturn ret;\n}\n\n \nint nfp_cpp_area_acquire_nonblocking(struct nfp_cpp_area *area)\n{\n\tmutex_lock(&area->mutex);\n\tif (atomic_inc_return(&area->refcount) == 1) {\n\t\tif (area->cpp->op->area_acquire) {\n\t\t\tint err;\n\n\t\t\terr = area->cpp->op->area_acquire(area);\n\t\t\tif (err < 0) {\n\t\t\t\tatomic_dec(&area->refcount);\n\t\t\t\tmutex_unlock(&area->mutex);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\t}\n\tmutex_unlock(&area->mutex);\n\n\tnfp_cpp_area_get(area);\n\treturn 0;\n}\n\n \nvoid nfp_cpp_area_release(struct nfp_cpp_area *area)\n{\n\tmutex_lock(&area->mutex);\n\t \n\tif (atomic_dec_and_test(&area->refcount)) {\n\t\tif (area->cpp->op->area_release) {\n\t\t\tarea->cpp->op->area_release(area);\n\t\t\t \n\t\t\twake_up_interruptible_all(&area->cpp->waitq);\n\t\t}\n\t}\n\tmutex_unlock(&area->mutex);\n\n\tnfp_cpp_area_put(area);\n}\n\n \nvoid nfp_cpp_area_release_free(struct nfp_cpp_area *area)\n{\n\tnfp_cpp_area_release(area);\n\tnfp_cpp_area_free(area);\n}\n\n \nint nfp_cpp_area_read(struct nfp_cpp_area *area,\n\t\t      unsigned long offset, void *kernel_vaddr,\n\t\t      size_t length)\n{\n\treturn area->cpp->op->area_read(area, kernel_vaddr, offset, length);\n}\n\n \nint nfp_cpp_area_write(struct nfp_cpp_area *area,\n\t\t       unsigned long offset, const void *kernel_vaddr,\n\t\t       size_t length)\n{\n\treturn area->cpp->op->area_write(area, kernel_vaddr, offset, length);\n}\n\n \nsize_t nfp_cpp_area_size(struct nfp_cpp_area *cpp_area)\n{\n\treturn cpp_area->size;\n}\n\n \nconst char *nfp_cpp_area_name(struct nfp_cpp_area *cpp_area)\n{\n\treturn cpp_area->resource.name;\n}\n\n \nvoid *nfp_cpp_area_priv(struct nfp_cpp_area *cpp_area)\n{\n\treturn &cpp_area[1];\n}\n\n \nstruct nfp_cpp *nfp_cpp_area_cpp(struct nfp_cpp_area *cpp_area)\n{\n\treturn cpp_area->cpp;\n}\n\n \nstruct resource *nfp_cpp_area_resource(struct nfp_cpp_area *area)\n{\n\tstruct resource *res = NULL;\n\n\tif (area->cpp->op->area_resource)\n\t\tres = area->cpp->op->area_resource(area);\n\n\treturn res;\n}\n\n \nphys_addr_t nfp_cpp_area_phys(struct nfp_cpp_area *area)\n{\n\tphys_addr_t addr = ~0;\n\n\tif (area->cpp->op->area_phys)\n\t\taddr = area->cpp->op->area_phys(area);\n\n\treturn addr;\n}\n\n \nvoid __iomem *nfp_cpp_area_iomem(struct nfp_cpp_area *area)\n{\n\tvoid __iomem *iomem = NULL;\n\n\tif (area->cpp->op->area_iomem)\n\t\tiomem = area->cpp->op->area_iomem(area);\n\n\treturn iomem;\n}\n\n \nint nfp_cpp_area_readl(struct nfp_cpp_area *area,\n\t\t       unsigned long offset, u32 *value)\n{\n\tu8 tmp[4];\n\tint n;\n\n\tn = nfp_cpp_area_read(area, offset, &tmp, sizeof(tmp));\n\tif (n != sizeof(tmp))\n\t\treturn n < 0 ? n : -EIO;\n\n\t*value = get_unaligned_le32(tmp);\n\treturn 0;\n}\n\n \nint nfp_cpp_area_writel(struct nfp_cpp_area *area,\n\t\t\tunsigned long offset, u32 value)\n{\n\tu8 tmp[4];\n\tint n;\n\n\tput_unaligned_le32(value, tmp);\n\tn = nfp_cpp_area_write(area, offset, &tmp, sizeof(tmp));\n\n\treturn n == sizeof(tmp) ? 0 : n < 0 ? n : -EIO;\n}\n\n \nint nfp_cpp_area_readq(struct nfp_cpp_area *area,\n\t\t       unsigned long offset, u64 *value)\n{\n\tu8 tmp[8];\n\tint n;\n\n\tn = nfp_cpp_area_read(area, offset, &tmp, sizeof(tmp));\n\tif (n != sizeof(tmp))\n\t\treturn n < 0 ? n : -EIO;\n\n\t*value = get_unaligned_le64(tmp);\n\treturn 0;\n}\n\n \nint nfp_cpp_area_writeq(struct nfp_cpp_area *area,\n\t\t\tunsigned long offset, u64 value)\n{\n\tu8 tmp[8];\n\tint n;\n\n\tput_unaligned_le64(value, tmp);\n\tn = nfp_cpp_area_write(area, offset, &tmp, sizeof(tmp));\n\n\treturn n == sizeof(tmp) ? 0 : n < 0 ? n : -EIO;\n}\n\n \nint nfp_cpp_area_fill(struct nfp_cpp_area *area,\n\t\t      unsigned long offset, u32 value, size_t length)\n{\n\tu8 tmp[4];\n\tsize_t i;\n\tint k;\n\n\tput_unaligned_le32(value, tmp);\n\n\tif (offset % sizeof(tmp) || length % sizeof(tmp))\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < length; i += sizeof(tmp)) {\n\t\tk = nfp_cpp_area_write(area, offset + i, &tmp, sizeof(tmp));\n\t\tif (k < 0)\n\t\t\treturn k;\n\t}\n\n\treturn i;\n}\n\n \nint nfp_cpp_area_cache_add(struct nfp_cpp *cpp, size_t size)\n{\n\tstruct nfp_cpp_area_cache *cache;\n\tstruct nfp_cpp_area *area;\n\n\t \n\tarea = nfp_cpp_area_alloc(cpp, NFP_CPP_ID(7, NFP_CPP_ACTION_RW, 0),\n\t\t\t\t  0, size);\n\tif (!area)\n\t\treturn -ENOMEM;\n\n\tcache = kzalloc(sizeof(*cache), GFP_KERNEL);\n\tif (!cache) {\n\t\tnfp_cpp_area_free(area);\n\t\treturn -ENOMEM;\n\t}\n\n\tcache->id = 0;\n\tcache->addr = 0;\n\tcache->size = size;\n\tcache->area = area;\n\tmutex_lock(&cpp->area_cache_mutex);\n\tlist_add_tail(&cache->entry, &cpp->area_cache_list);\n\tmutex_unlock(&cpp->area_cache_mutex);\n\n\treturn 0;\n}\n\nstatic struct nfp_cpp_area_cache *\narea_cache_get(struct nfp_cpp *cpp, u32 id,\n\t       u64 addr, unsigned long *offset, size_t length)\n{\n\tstruct nfp_cpp_area_cache *cache;\n\tint err;\n\n\t \n\tif (length == 0 || id == 0)\n\t\treturn NULL;\n\n\t \n\terr = nfp_target_cpp(id, addr, &id, &addr, cpp->imb_cat_table);\n\tif (err < 0)\n\t\treturn NULL;\n\n\tmutex_lock(&cpp->area_cache_mutex);\n\n\tif (list_empty(&cpp->area_cache_list)) {\n\t\tmutex_unlock(&cpp->area_cache_mutex);\n\t\treturn NULL;\n\t}\n\n\taddr += *offset;\n\n\t \n\tlist_for_each_entry(cache, &cpp->area_cache_list, entry) {\n\t\tif (id == cache->id &&\n\t\t    addr >= cache->addr &&\n\t\t    addr + length <= cache->addr + cache->size)\n\t\t\tgoto exit;\n\t}\n\n\t \n\tcache = list_entry(cpp->area_cache_list.prev,\n\t\t\t   struct nfp_cpp_area_cache, entry);\n\n\t \n\tif (round_down(addr + length - 1, cache->size) !=\n\t    round_down(addr, cache->size)) {\n\t\tmutex_unlock(&cpp->area_cache_mutex);\n\t\treturn NULL;\n\t}\n\n\t \n\tif (cache->id) {\n\t\tnfp_cpp_area_release(cache->area);\n\t\tcache->id = 0;\n\t\tcache->addr = 0;\n\t}\n\n\t \n\tcache->addr = addr & ~(u64)(cache->size - 1);\n\n\t \n\tif (cpp->op->area_init) {\n\t\terr = cpp->op->area_init(cache->area,\n\t\t\t\t\t id, cache->addr, cache->size);\n\t\tif (err < 0) {\n\t\t\tmutex_unlock(&cpp->area_cache_mutex);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\t \n\terr = nfp_cpp_area_acquire(cache->area);\n\tif (err < 0) {\n\t\tmutex_unlock(&cpp->area_cache_mutex);\n\t\treturn NULL;\n\t}\n\n\tcache->id = id;\n\nexit:\n\t \n\t*offset = addr - cache->addr;\n\treturn cache;\n}\n\nstatic void\narea_cache_put(struct nfp_cpp *cpp, struct nfp_cpp_area_cache *cache)\n{\n\tif (!cache)\n\t\treturn;\n\n\t \n\tlist_move(&cache->entry, &cpp->area_cache_list);\n\n\tmutex_unlock(&cpp->area_cache_mutex);\n}\n\nstatic int __nfp_cpp_read(struct nfp_cpp *cpp, u32 destination,\n\t\t\t  unsigned long long address, void *kernel_vaddr,\n\t\t\t  size_t length)\n{\n\tstruct nfp_cpp_area_cache *cache;\n\tstruct nfp_cpp_area *area;\n\tunsigned long offset = 0;\n\tint err;\n\n\tcache = area_cache_get(cpp, destination, address, &offset, length);\n\tif (cache) {\n\t\tarea = cache->area;\n\t} else {\n\t\tarea = nfp_cpp_area_alloc(cpp, destination, address, length);\n\t\tif (!area)\n\t\t\treturn -ENOMEM;\n\n\t\terr = nfp_cpp_area_acquire(area);\n\t\tif (err) {\n\t\t\tnfp_cpp_area_free(area);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\terr = nfp_cpp_area_read(area, offset, kernel_vaddr, length);\n\n\tif (cache)\n\t\tarea_cache_put(cpp, cache);\n\telse\n\t\tnfp_cpp_area_release_free(area);\n\n\treturn err;\n}\n\n \nint nfp_cpp_read(struct nfp_cpp *cpp, u32 destination,\n\t\t unsigned long long address, void *kernel_vaddr,\n\t\t size_t length)\n{\n\tsize_t n, offset;\n\tint ret;\n\n\tfor (offset = 0; offset < length; offset += n) {\n\t\tunsigned long long r_addr = address + offset;\n\n\t\t \n\t\tn = min_t(size_t, length - offset,\n\t\t\t  ALIGN(r_addr + 1, NFP_CPP_SAFE_AREA_SIZE) - r_addr);\n\n\t\tret = __nfp_cpp_read(cpp, destination, address + offset,\n\t\t\t\t     kernel_vaddr + offset, n);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (ret != n)\n\t\t\treturn offset + n;\n\t}\n\n\treturn length;\n}\n\nstatic int __nfp_cpp_write(struct nfp_cpp *cpp, u32 destination,\n\t\t\t   unsigned long long address,\n\t\t\t   const void *kernel_vaddr, size_t length)\n{\n\tstruct nfp_cpp_area_cache *cache;\n\tstruct nfp_cpp_area *area;\n\tunsigned long offset = 0;\n\tint err;\n\n\tcache = area_cache_get(cpp, destination, address, &offset, length);\n\tif (cache) {\n\t\tarea = cache->area;\n\t} else {\n\t\tarea = nfp_cpp_area_alloc(cpp, destination, address, length);\n\t\tif (!area)\n\t\t\treturn -ENOMEM;\n\n\t\terr = nfp_cpp_area_acquire(area);\n\t\tif (err) {\n\t\t\tnfp_cpp_area_free(area);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\terr = nfp_cpp_area_write(area, offset, kernel_vaddr, length);\n\n\tif (cache)\n\t\tarea_cache_put(cpp, cache);\n\telse\n\t\tnfp_cpp_area_release_free(area);\n\n\treturn err;\n}\n\n \nint nfp_cpp_write(struct nfp_cpp *cpp, u32 destination,\n\t\t  unsigned long long address,\n\t\t  const void *kernel_vaddr, size_t length)\n{\n\tsize_t n, offset;\n\tint ret;\n\n\tfor (offset = 0; offset < length; offset += n) {\n\t\tunsigned long long w_addr = address + offset;\n\n\t\t \n\t\tn = min_t(size_t, length - offset,\n\t\t\t  ALIGN(w_addr + 1, NFP_CPP_SAFE_AREA_SIZE) - w_addr);\n\n\t\tret = __nfp_cpp_write(cpp, destination, address + offset,\n\t\t\t\t      kernel_vaddr + offset, n);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (ret != n)\n\t\t\treturn offset + n;\n\t}\n\n\treturn length;\n}\n\n \nstatic u32 nfp_xpb_to_cpp(struct nfp_cpp *cpp, u32 *xpb_addr)\n{\n\tint island;\n\tu32 xpb;\n\n\txpb = NFP_CPP_ID(14, NFP_CPP_ACTION_RW, 0);\n\t \n\tisland = (*xpb_addr >> 24) & 0x3f;\n\tif (!island)\n\t\treturn xpb;\n\n\tif (island != 1) {\n\t\t*xpb_addr |= 1 << 30;\n\t\treturn xpb;\n\t}\n\n\t \n\t*xpb_addr &= ~0x7f000000;\n\tif (*xpb_addr < 0x60000) {\n\t\t*xpb_addr |= 1 << 30;\n\t} else {\n\t\t \n\t\tif (NFP_CPP_INTERFACE_TYPE_of(nfp_cpp_interface(cpp))\n\t\t    != NFP_CPP_INTERFACE_TYPE_ARM)\n\t\t\t*xpb_addr |= 1 << 24;\n\t}\n\n\treturn xpb;\n}\n\n \nint nfp_xpb_readl(struct nfp_cpp *cpp, u32 xpb_addr, u32 *value)\n{\n\tu32 cpp_dest = nfp_xpb_to_cpp(cpp, &xpb_addr);\n\n\treturn nfp_cpp_readl(cpp, cpp_dest, xpb_addr, value);\n}\n\n \nint nfp_xpb_writel(struct nfp_cpp *cpp, u32 xpb_addr, u32 value)\n{\n\tu32 cpp_dest = nfp_xpb_to_cpp(cpp, &xpb_addr);\n\n\treturn nfp_cpp_writel(cpp, cpp_dest, xpb_addr, value);\n}\n\n \nint nfp_xpb_writelm(struct nfp_cpp *cpp, u32 xpb_tgt,\n\t\t    u32 mask, u32 value)\n{\n\tint err;\n\tu32 tmp;\n\n\terr = nfp_xpb_readl(cpp, xpb_tgt, &tmp);\n\tif (err < 0)\n\t\treturn err;\n\n\ttmp &= ~mask;\n\ttmp |= mask & value;\n\treturn nfp_xpb_writel(cpp, xpb_tgt, tmp);\n}\n\n \nstatic struct lock_class_key nfp_cpp_resource_lock_key;\n\nstatic void nfp_cpp_dev_release(struct device *dev)\n{\n\t \n}\n\n \nstruct nfp_cpp *\nnfp_cpp_from_operations(const struct nfp_cpp_operations *ops,\n\t\t\tstruct device *parent, void *priv)\n{\n\tconst u32 arm = NFP_CPP_ID(NFP_CPP_TARGET_ARM, NFP_CPP_ACTION_RW, 0);\n\tstruct nfp_cpp *cpp;\n\tint ifc, err;\n\tu32 mask[2];\n\tu32 xpbaddr;\n\tsize_t tgt;\n\n\tcpp = kzalloc(sizeof(*cpp), GFP_KERNEL);\n\tif (!cpp) {\n\t\terr = -ENOMEM;\n\t\tgoto err_malloc;\n\t}\n\n\tcpp->op = ops;\n\tcpp->priv = priv;\n\n\tifc = ops->get_interface(parent);\n\tif (ifc < 0) {\n\t\terr = ifc;\n\t\tgoto err_free_cpp;\n\t}\n\tcpp->interface = ifc;\n\tif (ops->read_serial) {\n\t\terr = ops->read_serial(parent, cpp->serial);\n\t\tif (err)\n\t\t\tgoto err_free_cpp;\n\t}\n\n\trwlock_init(&cpp->resource_lock);\n\tinit_waitqueue_head(&cpp->waitq);\n\tlockdep_set_class(&cpp->resource_lock, &nfp_cpp_resource_lock_key);\n\tINIT_LIST_HEAD(&cpp->resource_list);\n\tINIT_LIST_HEAD(&cpp->area_cache_list);\n\tmutex_init(&cpp->area_cache_mutex);\n\tcpp->dev.init_name = \"cpp\";\n\tcpp->dev.parent = parent;\n\tcpp->dev.release = nfp_cpp_dev_release;\n\terr = device_register(&cpp->dev);\n\tif (err < 0) {\n\t\tput_device(&cpp->dev);\n\t\tgoto err_free_cpp;\n\t}\n\n\tdev_set_drvdata(&cpp->dev, cpp);\n\n\t \n\tif (cpp->op->init) {\n\t\terr = cpp->op->init(cpp);\n\t\tif (err < 0) {\n\t\t\tdev_err(parent,\n\t\t\t\t\"NFP interface initialization failed\\n\");\n\t\t\tgoto err_out;\n\t\t}\n\t}\n\n\terr = nfp_cpp_model_autodetect(cpp, &cpp->model);\n\tif (err < 0) {\n\t\tdev_err(parent, \"NFP model detection failed\\n\");\n\t\tgoto err_out;\n\t}\n\n\tfor (tgt = 0; tgt < ARRAY_SIZE(cpp->imb_cat_table); tgt++) {\n\t\t\t \n\t\txpbaddr = 0x000a0000 + (tgt * 4);\n\t\terr = nfp_xpb_readl(cpp, xpbaddr,\n\t\t\t\t    &cpp->imb_cat_table[tgt]);\n\t\tif (err < 0) {\n\t\t\tdev_err(parent,\n\t\t\t\t\"Can't read CPP mapping from device\\n\");\n\t\t\tgoto err_out;\n\t\t}\n\t}\n\n\tnfp_cpp_readl(cpp, arm, NFP_ARM_GCSR + NFP_ARM_GCSR_SOFTMODEL2,\n\t\t      &mask[0]);\n\tnfp_cpp_readl(cpp, arm, NFP_ARM_GCSR + NFP_ARM_GCSR_SOFTMODEL3,\n\t\t      &mask[1]);\n\n\terr = nfp_cpp_set_mu_locality_lsb(cpp);\n\tif (err < 0) {\n\t\tdev_err(parent,\t\"Can't calculate MU locality bit offset\\n\");\n\t\tgoto err_out;\n\t}\n\n\tdev_info(cpp->dev.parent, \"Model: 0x%08x, SN: %pM, Ifc: 0x%04x\\n\",\n\t\t nfp_cpp_model(cpp), cpp->serial, nfp_cpp_interface(cpp));\n\n\treturn cpp;\n\nerr_out:\n\tdevice_unregister(&cpp->dev);\nerr_free_cpp:\n\tkfree(cpp);\nerr_malloc:\n\treturn ERR_PTR(err);\n}\n\n \nvoid *nfp_cpp_priv(struct nfp_cpp *cpp)\n{\n\treturn cpp->priv;\n}\n\n \nstruct device *nfp_cpp_device(struct nfp_cpp *cpp)\n{\n\treturn &cpp->dev;\n}\n\n#define NFP_EXPL_OP(func, expl, args...)\t\t\t  \\\n\t({\t\t\t\t\t\t\t  \\\n\t\tstruct nfp_cpp *cpp = nfp_cpp_explicit_cpp(expl); \\\n\t\tint err = -ENODEV;\t\t\t\t  \\\n\t\t\t\t\t\t\t\t  \\\n\t\tif (cpp->op->func)\t\t\t\t  \\\n\t\t\terr = cpp->op->func(expl, ##args);\t  \\\n\t\terr;\t\t\t\t\t\t  \\\n\t})\n\n#define NFP_EXPL_OP_NR(func, expl, args...)\t\t\t  \\\n\t({\t\t\t\t\t\t\t  \\\n\t\tstruct nfp_cpp *cpp = nfp_cpp_explicit_cpp(expl); \\\n\t\t\t\t\t\t\t\t  \\\n\t\tif (cpp->op->func)\t\t\t\t  \\\n\t\t\tcpp->op->func(expl, ##args);\t\t  \\\n\t\t\t\t\t\t\t\t  \\\n\t})\n\n \nstruct nfp_cpp_explicit *nfp_cpp_explicit_acquire(struct nfp_cpp *cpp)\n{\n\tstruct nfp_cpp_explicit *expl;\n\tint err;\n\n\texpl = kzalloc(sizeof(*expl) + cpp->op->explicit_priv_size, GFP_KERNEL);\n\tif (!expl)\n\t\treturn NULL;\n\n\texpl->cpp = cpp;\n\terr = NFP_EXPL_OP(explicit_acquire, expl);\n\tif (err < 0) {\n\t\tkfree(expl);\n\t\treturn NULL;\n\t}\n\n\treturn expl;\n}\n\n \nint nfp_cpp_explicit_set_target(struct nfp_cpp_explicit *expl,\n\t\t\t\tu32 cpp_id, u8 len, u8 mask)\n{\n\texpl->cmd.cpp_id = cpp_id;\n\texpl->cmd.len = len;\n\texpl->cmd.byte_mask = mask;\n\n\treturn 0;\n}\n\n \nint nfp_cpp_explicit_set_data(struct nfp_cpp_explicit *expl,\n\t\t\t      u8 data_master, u16 data_ref)\n{\n\texpl->cmd.data_master = data_master;\n\texpl->cmd.data_ref = data_ref;\n\n\treturn 0;\n}\n\n \nint nfp_cpp_explicit_set_signal(struct nfp_cpp_explicit *expl,\n\t\t\t\tu8 signal_master, u8 signal_ref)\n{\n\texpl->cmd.signal_master = signal_master;\n\texpl->cmd.signal_ref = signal_ref;\n\n\treturn 0;\n}\n\n \nint nfp_cpp_explicit_set_posted(struct nfp_cpp_explicit *expl, int posted,\n\t\t\t\tu8 siga,\n\t\t\t\tenum nfp_cpp_explicit_signal_mode siga_mode,\n\t\t\t\tu8 sigb,\n\t\t\t\tenum nfp_cpp_explicit_signal_mode sigb_mode)\n{\n\texpl->cmd.posted = posted;\n\texpl->cmd.siga = siga;\n\texpl->cmd.sigb = sigb;\n\texpl->cmd.siga_mode = siga_mode;\n\texpl->cmd.sigb_mode = sigb_mode;\n\n\treturn 0;\n}\n\n \nint nfp_cpp_explicit_put(struct nfp_cpp_explicit *expl,\n\t\t\t const void *buff, size_t len)\n{\n\treturn NFP_EXPL_OP(explicit_put, expl, buff, len);\n}\n\n \nint nfp_cpp_explicit_do(struct nfp_cpp_explicit *expl, u64 address)\n{\n\treturn NFP_EXPL_OP(explicit_do, expl, &expl->cmd, address);\n}\n\n \nint nfp_cpp_explicit_get(struct nfp_cpp_explicit *expl, void *buff, size_t len)\n{\n\treturn NFP_EXPL_OP(explicit_get, expl, buff, len);\n}\n\n \nvoid nfp_cpp_explicit_release(struct nfp_cpp_explicit *expl)\n{\n\tNFP_EXPL_OP_NR(explicit_release, expl);\n\tkfree(expl);\n}\n\n \nstruct nfp_cpp *nfp_cpp_explicit_cpp(struct nfp_cpp_explicit *cpp_explicit)\n{\n\treturn cpp_explicit->cpp;\n}\n\n \nvoid *nfp_cpp_explicit_priv(struct nfp_cpp_explicit *cpp_explicit)\n{\n\treturn &cpp_explicit[1];\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}