{
  "module_name": "nfp_nsp.h",
  "hash_id": "3583eb0dfb7ee1dfe4ac6e4ed39d9bd9569c0a2f4cc0a36634f8d8bbec25c6f8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/netronome/nfp/nfpcore/nfp_nsp.h",
  "human_readable_source": " \n \n\n#ifndef NSP_NSP_H\n#define NSP_NSP_H 1\n\n#include <linux/types.h>\n#include <linux/if_ether.h>\n\nstruct firmware;\nstruct nfp_cpp;\nstruct nfp_nsp;\n\nstruct nfp_nsp *nfp_nsp_open(struct nfp_cpp *cpp);\nvoid nfp_nsp_close(struct nfp_nsp *state);\nu16 nfp_nsp_get_abi_ver_major(struct nfp_nsp *state);\nu16 nfp_nsp_get_abi_ver_minor(struct nfp_nsp *state);\nint nfp_nsp_wait(struct nfp_nsp *state);\nint nfp_nsp_device_soft_reset(struct nfp_nsp *state);\nint nfp_nsp_load_fw(struct nfp_nsp *state, const struct firmware *fw);\nint nfp_nsp_write_flash(struct nfp_nsp *state, const struct firmware *fw);\nint nfp_nsp_mac_reinit(struct nfp_nsp *state);\nint nfp_nsp_load_stored_fw(struct nfp_nsp *state);\nint nfp_nsp_hwinfo_lookup(struct nfp_nsp *state, void *buf, unsigned int size);\nint nfp_nsp_hwinfo_lookup_optional(struct nfp_nsp *state, void *buf,\n\t\t\t\t   unsigned int size, const char *default_val);\nint nfp_nsp_hwinfo_set(struct nfp_nsp *state, void *buf, unsigned int size);\nint nfp_nsp_fw_loaded(struct nfp_nsp *state);\nint nfp_nsp_read_module_eeprom(struct nfp_nsp *state, int eth_index,\n\t\t\t       unsigned int offset, void *data,\n\t\t\t       unsigned int len, unsigned int *read_len);\n\nstatic inline bool nfp_nsp_has_mac_reinit(struct nfp_nsp *state)\n{\n\treturn nfp_nsp_get_abi_ver_minor(state) > 20;\n}\n\nstatic inline bool nfp_nsp_has_stored_fw_load(struct nfp_nsp *state)\n{\n\treturn nfp_nsp_get_abi_ver_minor(state) > 23;\n}\n\nstatic inline bool nfp_nsp_has_hwinfo_lookup(struct nfp_nsp *state)\n{\n\treturn nfp_nsp_get_abi_ver_minor(state) > 24;\n}\n\nstatic inline bool nfp_nsp_has_hwinfo_set(struct nfp_nsp *state)\n{\n\treturn nfp_nsp_get_abi_ver_minor(state) > 25;\n}\n\nstatic inline bool nfp_nsp_has_fw_loaded(struct nfp_nsp *state)\n{\n\treturn nfp_nsp_get_abi_ver_minor(state) > 25;\n}\n\nstatic inline bool nfp_nsp_has_versions(struct nfp_nsp *state)\n{\n\treturn nfp_nsp_get_abi_ver_minor(state) > 27;\n}\n\nstatic inline bool nfp_nsp_has_read_module_eeprom(struct nfp_nsp *state)\n{\n\treturn nfp_nsp_get_abi_ver_minor(state) > 28;\n}\n\nstatic inline bool nfp_nsp_has_read_media(struct nfp_nsp *state)\n{\n\treturn nfp_nsp_get_abi_ver_minor(state) > 33;\n}\n\nenum nfp_eth_interface {\n\tNFP_INTERFACE_NONE\t= 0,\n\tNFP_INTERFACE_SFP\t= 1,\n\tNFP_INTERFACE_SFPP\t= 10,\n\tNFP_INTERFACE_SFP28\t= 28,\n\tNFP_INTERFACE_QSFP\t= 40,\n\tNFP_INTERFACE_RJ45\t= 45,\n\tNFP_INTERFACE_CXP\t= 100,\n\tNFP_INTERFACE_QSFP28\t= 112,\n};\n\nenum nfp_eth_media {\n\tNFP_MEDIA_DAC_PASSIVE = 0,\n\tNFP_MEDIA_DAC_ACTIVE,\n\tNFP_MEDIA_FIBRE,\n};\n\nenum nfp_eth_aneg {\n\tNFP_ANEG_AUTO = 0,\n\tNFP_ANEG_SEARCH,\n\tNFP_ANEG_25G_CONSORTIUM,\n\tNFP_ANEG_25G_IEEE,\n\tNFP_ANEG_DISABLED,\n};\n\nenum nfp_eth_fec {\n\tNFP_FEC_AUTO_BIT = 0,\n\tNFP_FEC_BASER_BIT,\n\tNFP_FEC_REED_SOLOMON_BIT,\n\tNFP_FEC_DISABLED_BIT,\n};\n\n \nenum nfp_ethtool_link_mode_list {\n\tNFP_MEDIA_W0_RJ45_10M,\n\tNFP_MEDIA_W0_RJ45_10M_HD,\n\tNFP_MEDIA_W0_RJ45_100M,\n\tNFP_MEDIA_W0_RJ45_100M_HD,\n\tNFP_MEDIA_W0_RJ45_1G,\n\tNFP_MEDIA_W0_RJ45_2P5G,\n\tNFP_MEDIA_W0_RJ45_5G,\n\tNFP_MEDIA_W0_RJ45_10G,\n\tNFP_MEDIA_1000BASE_CX,\n\tNFP_MEDIA_1000BASE_KX,\n\tNFP_MEDIA_10GBASE_KX4,\n\tNFP_MEDIA_10GBASE_KR,\n\tNFP_MEDIA_10GBASE_CX4,\n\tNFP_MEDIA_10GBASE_CR,\n\tNFP_MEDIA_10GBASE_SR,\n\tNFP_MEDIA_10GBASE_ER,\n\tNFP_MEDIA_25GBASE_KR,\n\tNFP_MEDIA_25GBASE_KR_S,\n\tNFP_MEDIA_25GBASE_CR,\n\tNFP_MEDIA_25GBASE_CR_S,\n\tNFP_MEDIA_25GBASE_SR,\n\tNFP_MEDIA_40GBASE_CR4,\n\tNFP_MEDIA_40GBASE_KR4,\n\tNFP_MEDIA_40GBASE_SR4,\n\tNFP_MEDIA_40GBASE_LR4,\n\tNFP_MEDIA_50GBASE_KR,\n\tNFP_MEDIA_50GBASE_SR,\n\tNFP_MEDIA_50GBASE_CR,\n\tNFP_MEDIA_50GBASE_LR,\n\tNFP_MEDIA_50GBASE_ER,\n\tNFP_MEDIA_50GBASE_FR,\n\tNFP_MEDIA_100GBASE_KR4,\n\tNFP_MEDIA_100GBASE_SR4,\n\tNFP_MEDIA_100GBASE_CR4,\n\tNFP_MEDIA_100GBASE_KP4,\n\tNFP_MEDIA_100GBASE_CR10,\n\tNFP_MEDIA_10GBASE_LR,\n\tNFP_MEDIA_25GBASE_LR,\n\tNFP_MEDIA_25GBASE_ER,\n\tNFP_MEDIA_LINK_MODES_NUMBER\n};\n\n#define NFP_FEC_AUTO\t\tBIT(NFP_FEC_AUTO_BIT)\n#define NFP_FEC_BASER\t\tBIT(NFP_FEC_BASER_BIT)\n#define NFP_FEC_REED_SOLOMON\tBIT(NFP_FEC_REED_SOLOMON_BIT)\n#define NFP_FEC_DISABLED\tBIT(NFP_FEC_DISABLED_BIT)\n\n \n#define NFP_NSP_DRV_RESET_DISK\t\t\t0\n#define NFP_NSP_DRV_RESET_ALWAYS\t\t1\n#define NFP_NSP_DRV_RESET_NEVER\t\t\t2\n#define NFP_NSP_DRV_RESET_DEFAULT\t\t\"0\"\n\n \n#define NFP_NSP_APP_FW_LOAD_DISK\t\t0\n#define NFP_NSP_APP_FW_LOAD_FLASH\t\t1\n#define NFP_NSP_APP_FW_LOAD_PREF\t\t2\n#define NFP_NSP_APP_FW_LOAD_DEFAULT\t\t\"2\"\n\n \n#define NFP_NSP_DRV_LOAD_IFC_DEFAULT\t\t\"0x10ff\"\n\n \nstruct nfp_eth_table {\n\tunsigned int count;\n\tunsigned int max_index;\n\tstruct nfp_eth_table_port {\n\t\tunsigned int eth_index;\n\t\tunsigned int index;\n\t\tunsigned int nbi;\n\t\tunsigned int base;\n\t\tunsigned int lanes;\n\t\tunsigned int speed;\n\n\t\tunsigned int interface;\n\t\tenum nfp_eth_media media;\n\n\t\tenum nfp_eth_fec fec;\n\t\tenum nfp_eth_fec act_fec;\n\t\tenum nfp_eth_aneg aneg;\n\n\t\tu8 mac_addr[ETH_ALEN];\n\n\t\tu8 label_port;\n\t\tu8 label_subport;\n\n\t\tbool enabled;\n\t\tbool tx_enabled;\n\t\tbool rx_enabled;\n\t\tbool supp_aneg;\n\n\t\tbool override_changed;\n\n\t\t \n\t\tu8 port_type;\n\n\t\tunsigned int port_lanes;\n\n\t\tbool is_split;\n\n\t\tunsigned int fec_modes_supported;\n\n\t\tu64 link_modes_supp[2];\n\t\tu64 link_modes_ad[2];\n\t} ports[];\n};\n\nstruct nfp_eth_table *nfp_eth_read_ports(struct nfp_cpp *cpp);\nstruct nfp_eth_table *\n__nfp_eth_read_ports(struct nfp_cpp *cpp, struct nfp_nsp *nsp);\n\nint nfp_eth_set_mod_enable(struct nfp_cpp *cpp, unsigned int idx, bool enable);\nint nfp_eth_set_configured(struct nfp_cpp *cpp, unsigned int idx,\n\t\t\t   bool configed);\nint\nnfp_eth_set_fec(struct nfp_cpp *cpp, unsigned int idx, enum nfp_eth_fec mode);\n\nint nfp_eth_set_idmode(struct nfp_cpp *cpp, unsigned int idx, bool state);\n\nstatic inline bool nfp_eth_can_support_fec(struct nfp_eth_table_port *eth_port)\n{\n\treturn !!eth_port->fec_modes_supported;\n}\n\nstatic inline unsigned int\nnfp_eth_supported_fec_modes(struct nfp_eth_table_port *eth_port)\n{\n\treturn eth_port->fec_modes_supported;\n}\n\nstruct nfp_nsp *nfp_eth_config_start(struct nfp_cpp *cpp, unsigned int idx);\nint nfp_eth_config_commit_end(struct nfp_nsp *nsp);\nvoid nfp_eth_config_cleanup_end(struct nfp_nsp *nsp);\n\nint __nfp_eth_set_aneg(struct nfp_nsp *nsp, enum nfp_eth_aneg mode);\nint __nfp_eth_set_speed(struct nfp_nsp *nsp, unsigned int speed);\nint __nfp_eth_set_split(struct nfp_nsp *nsp, unsigned int lanes);\n\n \nstruct nfp_nsp_identify {\n\tchar version[40];\n\tu8 flags;\n\tu8 br_primary;\n\tu8 br_secondary;\n\tu8 br_nsp;\n\tu16 primary;\n\tu16 secondary;\n\tu16 nsp;\n\tu64 sensor_mask;\n};\n\nstruct nfp_nsp_identify *__nfp_nsp_identify(struct nfp_nsp *nsp);\n\nenum nfp_nsp_sensor_id {\n\tNFP_SENSOR_CHIP_TEMPERATURE,\n\tNFP_SENSOR_ASSEMBLY_POWER,\n\tNFP_SENSOR_ASSEMBLY_12V_POWER,\n\tNFP_SENSOR_ASSEMBLY_3V3_POWER,\n};\n\nint nfp_hwmon_read_sensor(struct nfp_cpp *cpp, enum nfp_nsp_sensor_id id,\n\t\t\t  long *val);\n\nstruct nfp_eth_media_buf {\n\tu8 eth_index;\n\tu8 reserved[7];\n\t__le64 supported_modes[2];\n\t__le64 advertised_modes[2];\n};\n\nint nfp_nsp_read_media(struct nfp_nsp *state, void *buf, unsigned int size);\n\n#define NFP_NSP_VERSION_BUFSZ\t1024  \n\nenum nfp_nsp_versions {\n\tNFP_VERSIONS_BSP,\n\tNFP_VERSIONS_CPLD,\n\tNFP_VERSIONS_APP,\n\tNFP_VERSIONS_BUNDLE,\n\tNFP_VERSIONS_UNDI,\n\tNFP_VERSIONS_NCSI,\n\tNFP_VERSIONS_CFGR,\n};\n\nint nfp_nsp_versions(struct nfp_nsp *state, void *buf, unsigned int size);\nconst char *nfp_nsp_versions_get(enum nfp_nsp_versions id, bool flash,\n\t\t\t\t const u8 *buf, unsigned int size);\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}