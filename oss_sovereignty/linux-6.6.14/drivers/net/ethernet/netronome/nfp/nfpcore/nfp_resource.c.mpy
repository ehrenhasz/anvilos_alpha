{
  "module_name": "nfp_resource.c",
  "hash_id": "c100059a750765ca32972fc5537122ae90887de513cf7940c9439473f62c9cb3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/netronome/nfp/nfpcore/nfp_resource.c",
  "human_readable_source": "\n \n\n \n#include <linux/delay.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n\n#include \"crc32.h\"\n#include \"nfp.h\"\n#include \"nfp_cpp.h\"\n#include \"nfp6000/nfp6000.h\"\n\n#define NFP_RESOURCE_TBL_TARGET\t\tNFP_CPP_TARGET_MU\n#define NFP_RESOURCE_TBL_BASE\t\t0x8100000000ULL\n\n \n#define NFP_RESOURCE_TBL_NAME\t\t\"nfp.res\"\n#define NFP_RESOURCE_TBL_KEY\t\t0x00000000  \n\n#define NFP_RESOURCE_ENTRY_NAME_SZ\t8\n\n \nstruct nfp_resource_entry {\n\tstruct nfp_resource_entry_mutex {\n\t\tu32 owner;\n\t\tu32 key;\n\t} mutex;\n\tstruct nfp_resource_entry_region {\n\t\tu8  name[NFP_RESOURCE_ENTRY_NAME_SZ];\n\t\tu8  reserved[5];\n\t\tu8  cpp_action;\n\t\tu8  cpp_token;\n\t\tu8  cpp_target;\n\t\tu32 page_offset;\n\t\tu32 page_size;\n\t} region;\n};\n\n#define NFP_RESOURCE_TBL_SIZE\t\t4096\n#define NFP_RESOURCE_TBL_ENTRIES\t(NFP_RESOURCE_TBL_SIZE /\t\\\n\t\t\t\t\t sizeof(struct nfp_resource_entry))\n\nstruct nfp_resource {\n\tchar name[NFP_RESOURCE_ENTRY_NAME_SZ + 1];\n\tu32 cpp_id;\n\tu64 addr;\n\tu64 size;\n\tstruct nfp_cpp_mutex *mutex;\n};\n\nstatic int nfp_cpp_resource_find(struct nfp_cpp *cpp, struct nfp_resource *res)\n{\n\tstruct nfp_resource_entry entry;\n\tu32 cpp_id, key;\n\tint ret, i;\n\n\tcpp_id = NFP_CPP_ID(NFP_RESOURCE_TBL_TARGET, 3, 0);   \n\n\t \n\tif (!strcmp(res->name, NFP_RESOURCE_TBL_NAME)) {\n\t\tnfp_err(cpp, \"Grabbing device lock not supported\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\tkey = crc32_posix(res->name, NFP_RESOURCE_ENTRY_NAME_SZ);\n\n\tfor (i = 0; i < NFP_RESOURCE_TBL_ENTRIES; i++) {\n\t\tu64 addr = NFP_RESOURCE_TBL_BASE +\n\t\t\tsizeof(struct nfp_resource_entry) * i;\n\n\t\tret = nfp_cpp_read(cpp, cpp_id, addr, &entry, sizeof(entry));\n\t\tif (ret != sizeof(entry))\n\t\t\treturn -EIO;\n\n\t\tif (entry.mutex.key != key)\n\t\t\tcontinue;\n\n\t\t \n\t\tres->mutex =\n\t\t\tnfp_cpp_mutex_alloc(cpp,\n\t\t\t\t\t    NFP_RESOURCE_TBL_TARGET, addr, key);\n\t\tres->cpp_id = NFP_CPP_ID(entry.region.cpp_target,\n\t\t\t\t\t entry.region.cpp_action,\n\t\t\t\t\t entry.region.cpp_token);\n\t\tres->addr = (u64)entry.region.page_offset << 8;\n\t\tres->size = (u64)entry.region.page_size << 8;\n\n\t\treturn 0;\n\t}\n\n\treturn -ENOENT;\n}\n\nstatic int\nnfp_resource_try_acquire(struct nfp_cpp *cpp, struct nfp_resource *res,\n\t\t\t struct nfp_cpp_mutex *dev_mutex)\n{\n\tint err;\n\n\tif (nfp_cpp_mutex_lock(dev_mutex))\n\t\treturn -EINVAL;\n\n\terr = nfp_cpp_resource_find(cpp, res);\n\tif (err)\n\t\tgoto err_unlock_dev;\n\n\terr = nfp_cpp_mutex_trylock(res->mutex);\n\tif (err)\n\t\tgoto err_res_mutex_free;\n\n\tnfp_cpp_mutex_unlock(dev_mutex);\n\n\treturn 0;\n\nerr_res_mutex_free:\n\tnfp_cpp_mutex_free(res->mutex);\nerr_unlock_dev:\n\tnfp_cpp_mutex_unlock(dev_mutex);\n\n\treturn err;\n}\n\n \nstruct nfp_resource *\nnfp_resource_acquire(struct nfp_cpp *cpp, const char *name)\n{\n\tunsigned long warn_at = jiffies + NFP_MUTEX_WAIT_FIRST_WARN * HZ;\n\tunsigned long err_at = jiffies + NFP_MUTEX_WAIT_ERROR * HZ;\n\tstruct nfp_cpp_mutex *dev_mutex;\n\tstruct nfp_resource *res;\n\tint err;\n\n\tres = kzalloc(sizeof(*res), GFP_KERNEL);\n\tif (!res)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tstrncpy(res->name, name, NFP_RESOURCE_ENTRY_NAME_SZ);\n\n\tdev_mutex = nfp_cpp_mutex_alloc(cpp, NFP_RESOURCE_TBL_TARGET,\n\t\t\t\t\tNFP_RESOURCE_TBL_BASE,\n\t\t\t\t\tNFP_RESOURCE_TBL_KEY);\n\tif (!dev_mutex) {\n\t\tkfree(res);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tfor (;;) {\n\t\terr = nfp_resource_try_acquire(cpp, res, dev_mutex);\n\t\tif (!err)\n\t\t\tbreak;\n\t\tif (err != -EBUSY)\n\t\t\tgoto err_free;\n\n\t\terr = msleep_interruptible(1);\n\t\tif (err != 0) {\n\t\t\terr = -ERESTARTSYS;\n\t\t\tgoto err_free;\n\t\t}\n\n\t\tif (time_is_before_eq_jiffies(warn_at)) {\n\t\t\twarn_at = jiffies + NFP_MUTEX_WAIT_NEXT_WARN * HZ;\n\t\t\tnfp_warn(cpp, \"Warning: waiting for NFP resource %s\\n\",\n\t\t\t\t name);\n\t\t}\n\t\tif (time_is_before_eq_jiffies(err_at)) {\n\t\t\tnfp_err(cpp, \"Error: resource %s timed out\\n\", name);\n\t\t\terr = -EBUSY;\n\t\t\tgoto err_free;\n\t\t}\n\t}\n\n\tnfp_cpp_mutex_free(dev_mutex);\n\n\treturn res;\n\nerr_free:\n\tnfp_cpp_mutex_free(dev_mutex);\n\tkfree(res);\n\treturn ERR_PTR(err);\n}\n\n \nvoid nfp_resource_release(struct nfp_resource *res)\n{\n\tnfp_cpp_mutex_unlock(res->mutex);\n\tnfp_cpp_mutex_free(res->mutex);\n\tkfree(res);\n}\n\n \nint nfp_resource_wait(struct nfp_cpp *cpp, const char *name, unsigned int secs)\n{\n\tunsigned long warn_at = jiffies + NFP_MUTEX_WAIT_FIRST_WARN * HZ;\n\tunsigned long err_at = jiffies + secs * HZ;\n\tstruct nfp_resource *res;\n\n\twhile (true) {\n\t\tres = nfp_resource_acquire(cpp, name);\n\t\tif (!IS_ERR(res)) {\n\t\t\tnfp_resource_release(res);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (PTR_ERR(res) != -ENOENT) {\n\t\t\tnfp_err(cpp, \"error waiting for resource %s: %ld\\n\",\n\t\t\t\tname, PTR_ERR(res));\n\t\t\treturn PTR_ERR(res);\n\t\t}\n\t\tif (time_is_before_eq_jiffies(err_at)) {\n\t\t\tnfp_err(cpp, \"timeout waiting for resource %s\\n\", name);\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t\tif (time_is_before_eq_jiffies(warn_at)) {\n\t\t\twarn_at = jiffies + NFP_MUTEX_WAIT_NEXT_WARN * HZ;\n\t\t\tnfp_info(cpp, \"waiting for NFP resource %s\\n\", name);\n\t\t}\n\t\tif (msleep_interruptible(10)) {\n\t\t\tnfp_err(cpp, \"wait for resource %s interrupted\\n\",\n\t\t\t\tname);\n\t\t\treturn -ERESTARTSYS;\n\t\t}\n\t}\n}\n\n \nu32 nfp_resource_cpp_id(struct nfp_resource *res)\n{\n\treturn res->cpp_id;\n}\n\n \nconst char *nfp_resource_name(struct nfp_resource *res)\n{\n\treturn res->name;\n}\n\n \nu64 nfp_resource_address(struct nfp_resource *res)\n{\n\treturn res->addr;\n}\n\n \nu64 nfp_resource_size(struct nfp_resource *res)\n{\n\treturn res->size;\n}\n\n \nint nfp_resource_table_init(struct nfp_cpp *cpp)\n{\n\tstruct nfp_cpp_mutex *dev_mutex;\n\tint i, err;\n\n\terr = nfp_cpp_mutex_reclaim(cpp, NFP_RESOURCE_TBL_TARGET,\n\t\t\t\t    NFP_RESOURCE_TBL_BASE);\n\tif (err < 0) {\n\t\tnfp_err(cpp, \"Error: failed to reclaim resource table mutex\\n\");\n\t\treturn err;\n\t}\n\tif (err)\n\t\tnfp_warn(cpp, \"Warning: busted main resource table mutex\\n\");\n\n\tdev_mutex = nfp_cpp_mutex_alloc(cpp, NFP_RESOURCE_TBL_TARGET,\n\t\t\t\t\tNFP_RESOURCE_TBL_BASE,\n\t\t\t\t\tNFP_RESOURCE_TBL_KEY);\n\tif (!dev_mutex)\n\t\treturn -ENOMEM;\n\n\tif (nfp_cpp_mutex_lock(dev_mutex)) {\n\t\tnfp_err(cpp, \"Error: failed to claim resource table mutex\\n\");\n\t\tnfp_cpp_mutex_free(dev_mutex);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tfor (i = 1; i < NFP_RESOURCE_TBL_ENTRIES; i++) {\n\t\tu64 addr = NFP_RESOURCE_TBL_BASE +\n\t\t\tsizeof(struct nfp_resource_entry) * i;\n\n\t\terr = nfp_cpp_mutex_reclaim(cpp, NFP_RESOURCE_TBL_TARGET, addr);\n\t\tif (err < 0) {\n\t\t\tnfp_err(cpp,\n\t\t\t\t\"Error: failed to reclaim resource %d mutex\\n\",\n\t\t\t\ti);\n\t\t\tgoto err_unlock;\n\t\t}\n\t\tif (err)\n\t\t\tnfp_warn(cpp, \"Warning: busted resource %d mutex\\n\", i);\n\t}\n\n\terr = 0;\nerr_unlock:\n\tnfp_cpp_mutex_unlock(dev_mutex);\n\tnfp_cpp_mutex_free(dev_mutex);\n\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}