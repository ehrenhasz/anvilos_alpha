{
  "module_name": "nfp_net_ctrl.c",
  "hash_id": "e34b9b5a00534b90d5673c6b97268a96d623dd7058a903d0aaed284df1d89bc7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/netronome/nfp/nfp_net_ctrl.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#include \"nfp_net_ctrl.h\"\n#include \"nfp_net.h\"\n\nstatic void nfp_net_tlv_caps_reset(struct nfp_net_tlv_caps *caps)\n{\n\tmemset(caps, 0, sizeof(*caps));\n\tcaps->me_freq_mhz = 1200;\n\tcaps->mbox_off = NFP_NET_CFG_MBOX_BASE;\n\tcaps->mbox_len = NFP_NET_CFG_MBOX_VAL_MAX_SZ;\n}\n\nstatic bool\nnfp_net_tls_parse_crypto_ops(struct device *dev, struct nfp_net_tlv_caps *caps,\n\t\t\t     u8 __iomem *ctrl_mem, u8 __iomem *data,\n\t\t\t     unsigned int length, unsigned int offset,\n\t\t\t     bool rx_stream_scan)\n{\n\t \n\tif (caps->tls_resync_ss && !rx_stream_scan)\n\t\treturn true;\n\n\tif (length < 32) {\n\t\tdev_err(dev,\n\t\t\t\"CRYPTO OPS TLV should be at least 32B, is %dB offset:%u\\n\",\n\t\t\tlength, offset);\n\t\treturn false;\n\t}\n\n\tcaps->crypto_ops = readl(data);\n\tcaps->crypto_enable_off = data - ctrl_mem + 16;\n\tcaps->tls_resync_ss = rx_stream_scan;\n\n\treturn true;\n}\n\nint nfp_net_tlv_caps_parse(struct device *dev, u8 __iomem *ctrl_mem,\n\t\t\t   struct nfp_net_tlv_caps *caps)\n{\n\tu8 __iomem *data = ctrl_mem + NFP_NET_CFG_TLV_BASE;\n\tu8 __iomem *end = ctrl_mem + NFP_NET_CFG_BAR_SZ;\n\tu32 hdr;\n\n\tnfp_net_tlv_caps_reset(caps);\n\n\thdr = readl(data);\n\tif (!hdr)\n\t\treturn 0;\n\n\twhile (true) {\n\t\tunsigned int length, offset;\n\t\tu32 hdr = readl(data);\n\n\t\tlength = FIELD_GET(NFP_NET_CFG_TLV_HEADER_LENGTH, hdr);\n\t\toffset = data - ctrl_mem;\n\n\t\t \n\t\tdata += 4;\n\n\t\tif (length % NFP_NET_CFG_TLV_LENGTH_INC) {\n\t\t\tdev_err(dev, \"TLV size not multiple of %u offset:%u len:%u\\n\",\n\t\t\t\tNFP_NET_CFG_TLV_LENGTH_INC, offset, length);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (data + length > end) {\n\t\t\tdev_err(dev, \"oversized TLV offset:%u len:%u\\n\",\n\t\t\t\toffset, length);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tswitch (FIELD_GET(NFP_NET_CFG_TLV_HEADER_TYPE, hdr)) {\n\t\tcase NFP_NET_CFG_TLV_TYPE_UNKNOWN:\n\t\t\tdev_err(dev, \"NULL TLV at offset:%u\\n\", offset);\n\t\t\treturn -EINVAL;\n\t\tcase NFP_NET_CFG_TLV_TYPE_RESERVED:\n\t\t\tbreak;\n\t\tcase NFP_NET_CFG_TLV_TYPE_END:\n\t\t\tif (!length)\n\t\t\t\treturn 0;\n\n\t\t\tdev_err(dev, \"END TLV should be empty, has offset:%u len:%d\\n\",\n\t\t\t\toffset, length);\n\t\t\treturn -EINVAL;\n\t\tcase NFP_NET_CFG_TLV_TYPE_ME_FREQ:\n\t\t\tif (length != 4) {\n\t\t\t\tdev_err(dev,\n\t\t\t\t\t\"ME FREQ TLV should be 4B, is %dB offset:%u\\n\",\n\t\t\t\t\tlength, offset);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tcaps->me_freq_mhz = readl(data);\n\t\t\tbreak;\n\t\tcase NFP_NET_CFG_TLV_TYPE_MBOX:\n\t\t\tif (!length) {\n\t\t\t\tcaps->mbox_off = 0;\n\t\t\t\tcaps->mbox_len = 0;\n\t\t\t} else {\n\t\t\t\tcaps->mbox_off = data - ctrl_mem;\n\t\t\t\tcaps->mbox_len = length;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase NFP_NET_CFG_TLV_TYPE_EXPERIMENTAL0:\n\t\tcase NFP_NET_CFG_TLV_TYPE_EXPERIMENTAL1:\n\t\t\tdev_warn(dev,\n\t\t\t\t \"experimental TLV type:%u offset:%u len:%u\\n\",\n\t\t\t\t FIELD_GET(NFP_NET_CFG_TLV_HEADER_TYPE, hdr),\n\t\t\t\t offset, length);\n\t\t\tbreak;\n\t\tcase NFP_NET_CFG_TLV_TYPE_REPR_CAP:\n\t\t\tif (length < 4) {\n\t\t\t\tdev_err(dev, \"REPR CAP TLV short %dB < 4B offset:%u\\n\",\n\t\t\t\t\tlength, offset);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tcaps->repr_cap = readl(data);\n\t\t\tbreak;\n\t\tcase NFP_NET_CFG_TLV_TYPE_MBOX_CMSG_TYPES:\n\t\t\tif (length >= 4)\n\t\t\t\tcaps->mbox_cmsg_types = readl(data);\n\t\t\tbreak;\n\t\tcase NFP_NET_CFG_TLV_TYPE_CRYPTO_OPS:\n\t\t\tif (!nfp_net_tls_parse_crypto_ops(dev, caps, ctrl_mem,\n\t\t\t\t\t\t\t  data, length, offset,\n\t\t\t\t\t\t\t  false))\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase NFP_NET_CFG_TLV_TYPE_VNIC_STATS:\n\t\t\tif ((data - ctrl_mem) % 8) {\n\t\t\t\tdev_warn(dev, \"VNIC STATS TLV misaligned, ignoring offset:%u len:%u\\n\",\n\t\t\t\t\t offset, length);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcaps->vnic_stats_off = data - ctrl_mem;\n\t\t\tcaps->vnic_stats_cnt = length / 10;\n\t\t\tbreak;\n\t\tcase NFP_NET_CFG_TLV_TYPE_CRYPTO_OPS_RX_SCAN:\n\t\t\tif (!nfp_net_tls_parse_crypto_ops(dev, caps, ctrl_mem,\n\t\t\t\t\t\t\t  data, length, offset,\n\t\t\t\t\t\t\t  true))\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (!FIELD_GET(NFP_NET_CFG_TLV_HEADER_REQUIRED, hdr))\n\t\t\t\tbreak;\n\n\t\t\tdev_err(dev, \"unknown TLV type:%u offset:%u len:%u\\n\",\n\t\t\t\tFIELD_GET(NFP_NET_CFG_TLV_HEADER_TYPE, hdr),\n\t\t\t\toffset, length);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tdata += length;\n\t\tif (data + 4 > end) {\n\t\t\tdev_err(dev, \"reached end of BAR without END TLV\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t \n\treturn -EINVAL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}