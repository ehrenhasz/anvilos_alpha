{
  "module_name": "smc91x.c",
  "hash_id": "24c9eba640ea81d4b899a7d5bb97be5d68aa3a6555f1822ceb8bd3e0d9dcfbf3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/smsc/smc91x.c",
  "human_readable_source": "\n \nstatic const char version[] =\n\t\"smc91x.c: v1.1, sep 22 2004 by Nicolas Pitre <nico@fluxnic.net>\";\n\n \n#ifndef SMC_DEBUG\n#define SMC_DEBUG\t\t0\n#endif\n\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/errno.h>\n#include <linux/ioport.h>\n#include <linux/crc32.h>\n#include <linux/platform_device.h>\n#include <linux/spinlock.h>\n#include <linux/ethtool.h>\n#include <linux/mii.h>\n#include <linux/workqueue.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/skbuff.h>\n\n#include <asm/io.h>\n\n#include \"smc91x.h\"\n\n#if defined(CONFIG_ASSABET_NEPONSET)\n#include <mach/assabet.h>\n#include <mach/neponset.h>\n#endif\n\n#ifndef SMC_NOWAIT\n# define SMC_NOWAIT\t\t0\n#endif\nstatic int nowait = SMC_NOWAIT;\nmodule_param(nowait, int, 0400);\nMODULE_PARM_DESC(nowait, \"set to 1 for no wait state\");\n\n \nstatic int watchdog = 1000;\nmodule_param(watchdog, int, 0400);\nMODULE_PARM_DESC(watchdog, \"transmit timeout in milliseconds\");\n\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:smc91x\");\n\n \n#define CARDNAME \"smc91x\"\n\n \n#define POWER_DOWN\t\t1\n\n \n#define MEMORY_WAIT_TIME\t16\n\n \n#define MAX_IRQ_LOOPS\t\t8\n\n \n#define THROTTLE_TX_PKTS\t0\n\n \n#define MII_DELAY\t\t1\n\n#define DBG(n, dev, fmt, ...)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\\\n\t\tif (SMC_DEBUG >= (n))\t\t\t\t\\\n\t\t\tnetdev_dbg(dev, fmt, ##__VA_ARGS__);\t\\\n\t} while (0)\n\n#define PRINTK(dev, fmt, ...)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\\\n\t\tif (SMC_DEBUG > 0)\t\t\t\t\\\n\t\t\tnetdev_info(dev, fmt, ##__VA_ARGS__);\t\\\n\t\telse\t\t\t\t\t\t\\\n\t\t\tnetdev_dbg(dev, fmt, ##__VA_ARGS__);\t\\\n\t} while (0)\n\n#if SMC_DEBUG > 3\nstatic void PRINT_PKT(u_char *buf, int length)\n{\n\tint i;\n\tint remainder;\n\tint lines;\n\n\tlines = length / 16;\n\tremainder = length % 16;\n\n\tfor (i = 0; i < lines ; i ++) {\n\t\tint cur;\n\t\tprintk(KERN_DEBUG);\n\t\tfor (cur = 0; cur < 8; cur++) {\n\t\t\tu_char a, b;\n\t\t\ta = *buf++;\n\t\t\tb = *buf++;\n\t\t\tpr_cont(\"%02x%02x \", a, b);\n\t\t}\n\t\tpr_cont(\"\\n\");\n\t}\n\tprintk(KERN_DEBUG);\n\tfor (i = 0; i < remainder/2 ; i++) {\n\t\tu_char a, b;\n\t\ta = *buf++;\n\t\tb = *buf++;\n\t\tpr_cont(\"%02x%02x \", a, b);\n\t}\n\tpr_cont(\"\\n\");\n}\n#else\nstatic inline void PRINT_PKT(u_char *buf, int length) { }\n#endif\n\n\n \n#define SMC_ENABLE_INT(lp, x) do {\t\t\t\t\t\\\n\tunsigned char mask;\t\t\t\t\t\t\\\n\tunsigned long smc_enable_flags;\t\t\t\t\t\\\n\tspin_lock_irqsave(&lp->lock, smc_enable_flags);\t\t\t\\\n\tmask = SMC_GET_INT_MASK(lp);\t\t\t\t\t\\\n\tmask |= (x);\t\t\t\t\t\t\t\\\n\tSMC_SET_INT_MASK(lp, mask);\t\t\t\t\t\\\n\tspin_unlock_irqrestore(&lp->lock, smc_enable_flags);\t\t\\\n} while (0)\n\n \n#define SMC_DISABLE_INT(lp, x) do {\t\t\t\t\t\\\n\tunsigned char mask;\t\t\t\t\t\t\\\n\tunsigned long smc_disable_flags;\t\t\t\t\\\n\tspin_lock_irqsave(&lp->lock, smc_disable_flags);\t\t\\\n\tmask = SMC_GET_INT_MASK(lp);\t\t\t\t\t\\\n\tmask &= ~(x);\t\t\t\t\t\t\t\\\n\tSMC_SET_INT_MASK(lp, mask);\t\t\t\t\t\\\n\tspin_unlock_irqrestore(&lp->lock, smc_disable_flags);\t\t\\\n} while (0)\n\n \n#define SMC_WAIT_MMU_BUSY(lp) do {\t\t\t\t\t\\\n\tif (unlikely(SMC_GET_MMU_CMD(lp) & MC_BUSY)) {\t\t\\\n\t\tunsigned long timeout = jiffies + 2;\t\t\t\\\n\t\twhile (SMC_GET_MMU_CMD(lp) & MC_BUSY) {\t\t\\\n\t\t\tif (time_after(jiffies, timeout)) {\t\t\\\n\t\t\t\tnetdev_dbg(dev, \"timeout %s line %d\\n\",\t\\\n\t\t\t\t\t   __FILE__, __LINE__);\t\t\\\n\t\t\t\tbreak;\t\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\\\n\t\t\tcpu_relax();\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n} while (0)\n\n\n \nstatic void smc_reset(struct net_device *dev)\n{\n\tstruct smc_local *lp = netdev_priv(dev);\n\tvoid __iomem *ioaddr = lp->base;\n\tunsigned int ctl, cfg;\n\tstruct sk_buff *pending_skb;\n\n\tDBG(2, dev, \"%s\\n\", __func__);\n\n\t \n\tspin_lock_irq(&lp->lock);\n\tSMC_SELECT_BANK(lp, 2);\n\tSMC_SET_INT_MASK(lp, 0);\n\tpending_skb = lp->pending_tx_skb;\n\tlp->pending_tx_skb = NULL;\n\tspin_unlock_irq(&lp->lock);\n\n\t \n\tif (pending_skb) {\n\t\tdev_kfree_skb(pending_skb);\n\t\tdev->stats.tx_errors++;\n\t\tdev->stats.tx_aborted_errors++;\n\t}\n\n\t \n\tSMC_SELECT_BANK(lp, 0);\n\tSMC_SET_RCR(lp, RCR_SOFTRST);\n\n\t \n\tSMC_SELECT_BANK(lp, 1);\n\n\tcfg = CONFIG_DEFAULT;\n\n\t \n\tif (lp->cfg.flags & SMC91X_NOWAIT)\n\t\tcfg |= CONFIG_NO_WAIT;\n\n\t \n\tcfg |= CONFIG_EPH_POWER_EN;\n\n\tSMC_SET_CONFIG(lp, cfg);\n\n\t \n\t \n\tudelay(1);\n\n\t \n\tSMC_SELECT_BANK(lp, 0);\n\tSMC_SET_RCR(lp, RCR_CLEAR);\n\tSMC_SET_TCR(lp, TCR_CLEAR);\n\n\tSMC_SELECT_BANK(lp, 1);\n\tctl = SMC_GET_CTL(lp) | CTL_LE_ENABLE;\n\n\t \n\tif(!THROTTLE_TX_PKTS)\n\t\tctl |= CTL_AUTO_RELEASE;\n\telse\n\t\tctl &= ~CTL_AUTO_RELEASE;\n\tSMC_SET_CTL(lp, ctl);\n\n\t \n\tSMC_SELECT_BANK(lp, 2);\n\tSMC_SET_MMU_CMD(lp, MC_RESET);\n\tSMC_WAIT_MMU_BUSY(lp);\n}\n\n \nstatic void smc_enable(struct net_device *dev)\n{\n\tstruct smc_local *lp = netdev_priv(dev);\n\tvoid __iomem *ioaddr = lp->base;\n\tint mask;\n\n\tDBG(2, dev, \"%s\\n\", __func__);\n\n\t \n\tSMC_SELECT_BANK(lp, 0);\n\tSMC_SET_TCR(lp, lp->tcr_cur_mode);\n\tSMC_SET_RCR(lp, lp->rcr_cur_mode);\n\n\tSMC_SELECT_BANK(lp, 1);\n\tSMC_SET_MAC_ADDR(lp, dev->dev_addr);\n\n\t \n\tmask = IM_EPH_INT|IM_RX_OVRN_INT|IM_RCV_INT;\n\tif (lp->version >= (CHIP_91100 << 4))\n\t\tmask |= IM_MDINT;\n\tSMC_SELECT_BANK(lp, 2);\n\tSMC_SET_INT_MASK(lp, mask);\n\n\t \n}\n\n \nstatic void smc_shutdown(struct net_device *dev)\n{\n\tstruct smc_local *lp = netdev_priv(dev);\n\tvoid __iomem *ioaddr = lp->base;\n\tstruct sk_buff *pending_skb;\n\n\tDBG(2, dev, \"%s: %s\\n\", CARDNAME, __func__);\n\n\t \n\tspin_lock_irq(&lp->lock);\n\tSMC_SELECT_BANK(lp, 2);\n\tSMC_SET_INT_MASK(lp, 0);\n\tpending_skb = lp->pending_tx_skb;\n\tlp->pending_tx_skb = NULL;\n\tspin_unlock_irq(&lp->lock);\n\tdev_kfree_skb(pending_skb);\n\n\t \n\tSMC_SELECT_BANK(lp, 0);\n\tSMC_SET_RCR(lp, RCR_CLEAR);\n\tSMC_SET_TCR(lp, TCR_CLEAR);\n\n#ifdef POWER_DOWN\n\t \n\tSMC_SELECT_BANK(lp, 1);\n\tSMC_SET_CONFIG(lp, SMC_GET_CONFIG(lp) & ~CONFIG_EPH_POWER_EN);\n#endif\n}\n\n \nstatic inline void  smc_rcv(struct net_device *dev)\n{\n\tstruct smc_local *lp = netdev_priv(dev);\n\tvoid __iomem *ioaddr = lp->base;\n\tunsigned int packet_number, status, packet_len;\n\n\tDBG(3, dev, \"%s\\n\", __func__);\n\n\tpacket_number = SMC_GET_RXFIFO(lp);\n\tif (unlikely(packet_number & RXFIFO_REMPTY)) {\n\t\tPRINTK(dev, \"smc_rcv with nothing on FIFO.\\n\");\n\t\treturn;\n\t}\n\n\t \n\tSMC_SET_PTR(lp, PTR_READ | PTR_RCV | PTR_AUTOINC);\n\n\t \n\tSMC_GET_PKT_HDR(lp, status, packet_len);\n\tpacket_len &= 0x07ff;   \n\tDBG(2, dev, \"RX PNR 0x%x STATUS 0x%04x LENGTH 0x%04x (%d)\\n\",\n\t    packet_number, status, packet_len, packet_len);\n\n\tback:\n\tif (unlikely(packet_len < 6 || status & RS_ERRORS)) {\n\t\tif (status & RS_TOOLONG && packet_len <= (1514 + 4 + 6)) {\n\t\t\t \n\t\t\tstatus &= ~RS_TOOLONG;\n\t\t\tgoto back;\n\t\t}\n\t\tif (packet_len < 6) {\n\t\t\t \n\t\t\tnetdev_err(dev, \"fubar (rxlen %u status %x\\n\",\n\t\t\t\t   packet_len, status);\n\t\t\tstatus |= RS_TOOSHORT;\n\t\t}\n\t\tSMC_WAIT_MMU_BUSY(lp);\n\t\tSMC_SET_MMU_CMD(lp, MC_RELEASE);\n\t\tdev->stats.rx_errors++;\n\t\tif (status & RS_ALGNERR)\n\t\t\tdev->stats.rx_frame_errors++;\n\t\tif (status & (RS_TOOSHORT | RS_TOOLONG))\n\t\t\tdev->stats.rx_length_errors++;\n\t\tif (status & RS_BADCRC)\n\t\t\tdev->stats.rx_crc_errors++;\n\t} else {\n\t\tstruct sk_buff *skb;\n\t\tunsigned char *data;\n\t\tunsigned int data_len;\n\n\t\t \n\t\tif (status & RS_MULTICAST)\n\t\t\tdev->stats.multicast++;\n\n\t\t \n\t\tskb = netdev_alloc_skb(dev, packet_len);\n\t\tif (unlikely(skb == NULL)) {\n\t\t\tSMC_WAIT_MMU_BUSY(lp);\n\t\t\tSMC_SET_MMU_CMD(lp, MC_RELEASE);\n\t\t\tdev->stats.rx_dropped++;\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tskb_reserve(skb, 2);\n\n\t\t \n\t\tif (lp->version == 0x90)\n\t\t\tstatus |= RS_ODDFRAME;\n\n\t\t \n\t\tdata_len = packet_len - ((status & RS_ODDFRAME) ? 5 : 6);\n\t\tdata = skb_put(skb, data_len);\n\t\tSMC_PULL_DATA(lp, data, packet_len - 4);\n\n\t\tSMC_WAIT_MMU_BUSY(lp);\n\t\tSMC_SET_MMU_CMD(lp, MC_RELEASE);\n\n\t\tPRINT_PKT(data, packet_len - 4);\n\n\t\tskb->protocol = eth_type_trans(skb, dev);\n\t\tnetif_rx(skb);\n\t\tdev->stats.rx_packets++;\n\t\tdev->stats.rx_bytes += data_len;\n\t}\n}\n\n#ifdef CONFIG_SMP\n \n#define smc_special_trylock(lock, flags)\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tint __ret;\t\t\t\t\t\t\t\\\n\tlocal_irq_save(flags);\t\t\t\t\t\t\\\n\t__ret = spin_trylock(lock);\t\t\t\t\t\\\n\tif (!__ret)\t\t\t\t\t\t\t\\\n\t\tlocal_irq_restore(flags);\t\t\t\t\\\n\t__ret;\t\t\t\t\t\t\t\t\\\n})\n#define smc_special_lock(lock, flags)\t\tspin_lock_irqsave(lock, flags)\n#define smc_special_unlock(lock, flags) \tspin_unlock_irqrestore(lock, flags)\n#else\n#define smc_special_trylock(lock, flags)\t((void)flags, true)\n#define smc_special_lock(lock, flags)   \tdo { flags = 0; } while (0)\n#define smc_special_unlock(lock, flags)\tdo { flags = 0; } while (0)\n#endif\n\n \nstatic void smc_hardware_send_pkt(struct tasklet_struct *t)\n{\n\tstruct smc_local *lp = from_tasklet(lp, t, tx_task);\n\tstruct net_device *dev = lp->dev;\n\tvoid __iomem *ioaddr = lp->base;\n\tstruct sk_buff *skb;\n\tunsigned int packet_no, len;\n\tunsigned char *buf;\n\tunsigned long flags;\n\n\tDBG(3, dev, \"%s\\n\", __func__);\n\n\tif (!smc_special_trylock(&lp->lock, flags)) {\n\t\tnetif_stop_queue(dev);\n\t\ttasklet_schedule(&lp->tx_task);\n\t\treturn;\n\t}\n\n\tskb = lp->pending_tx_skb;\n\tif (unlikely(!skb)) {\n\t\tsmc_special_unlock(&lp->lock, flags);\n\t\treturn;\n\t}\n\tlp->pending_tx_skb = NULL;\n\n\tpacket_no = SMC_GET_AR(lp);\n\tif (unlikely(packet_no & AR_FAILED)) {\n\t\tnetdev_err(dev, \"Memory allocation failed.\\n\");\n\t\tdev->stats.tx_errors++;\n\t\tdev->stats.tx_fifo_errors++;\n\t\tsmc_special_unlock(&lp->lock, flags);\n\t\tgoto done;\n\t}\n\n\t \n\tSMC_SET_PN(lp, packet_no);\n\tSMC_SET_PTR(lp, PTR_AUTOINC);\n\n\tbuf = skb->data;\n\tlen = skb->len;\n\tDBG(2, dev, \"TX PNR 0x%x LENGTH 0x%04x (%d) BUF 0x%p\\n\",\n\t    packet_no, len, len, buf);\n\tPRINT_PKT(buf, len);\n\n\t \n\tSMC_PUT_PKT_HDR(lp, 0, len + 6);\n\n\t \n\tSMC_PUSH_DATA(lp, buf, len & ~1);\n\n\t \n\tSMC_outw(lp, ((len & 1) ? (0x2000 | buf[len - 1]) : 0), ioaddr,\n\t\t DATA_REG(lp));\n\n\t \n\tif (THROTTLE_TX_PKTS)\n\t\tnetif_stop_queue(dev);\n\n\t \n\tSMC_SET_MMU_CMD(lp, MC_ENQUEUE);\n\tsmc_special_unlock(&lp->lock, flags);\n\n\tnetif_trans_update(dev);\n\tdev->stats.tx_packets++;\n\tdev->stats.tx_bytes += len;\n\n\tSMC_ENABLE_INT(lp, IM_TX_INT | IM_TX_EMPTY_INT);\n\ndone:\tif (!THROTTLE_TX_PKTS)\n\t\tnetif_wake_queue(dev);\n\n\tdev_consume_skb_any(skb);\n}\n\n \nstatic netdev_tx_t\nsmc_hard_start_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct smc_local *lp = netdev_priv(dev);\n\tvoid __iomem *ioaddr = lp->base;\n\tunsigned int numPages, poll_count, status;\n\tunsigned long flags;\n\n\tDBG(3, dev, \"%s\\n\", __func__);\n\n\tBUG_ON(lp->pending_tx_skb != NULL);\n\n\t \n\tnumPages = ((skb->len & ~1) + (6 - 1)) >> 8;\n\tif (unlikely(numPages > 7)) {\n\t\tnetdev_warn(dev, \"Far too big packet error.\\n\");\n\t\tdev->stats.tx_errors++;\n\t\tdev->stats.tx_dropped++;\n\t\tdev_kfree_skb_any(skb);\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\tsmc_special_lock(&lp->lock, flags);\n\n\t \n\tSMC_SET_MMU_CMD(lp, MC_ALLOC | numPages);\n\n\t \n\tpoll_count = MEMORY_WAIT_TIME;\n\tdo {\n\t\tstatus = SMC_GET_INT(lp);\n\t\tif (status & IM_ALLOC_INT) {\n\t\t\tSMC_ACK_INT(lp, IM_ALLOC_INT);\n\t\t\tbreak;\n\t\t}\n\t} while (--poll_count);\n\n\tsmc_special_unlock(&lp->lock, flags);\n\n\tlp->pending_tx_skb = skb;\n\tif (!poll_count) {\n\t\t \n\t\tnetif_stop_queue(dev);\n\t\tDBG(2, dev, \"TX memory allocation deferred.\\n\");\n\t\tSMC_ENABLE_INT(lp, IM_ALLOC_INT);\n\t} else {\n\t\t \n\t\tsmc_hardware_send_pkt(&lp->tx_task);\n\t}\n\n\treturn NETDEV_TX_OK;\n}\n\n \nstatic void smc_tx(struct net_device *dev)\n{\n\tstruct smc_local *lp = netdev_priv(dev);\n\tvoid __iomem *ioaddr = lp->base;\n\tunsigned int saved_packet, packet_no, tx_status;\n\tunsigned int pkt_len __always_unused;\n\n\tDBG(3, dev, \"%s\\n\", __func__);\n\n\t \n\tpacket_no = SMC_GET_TXFIFO(lp);\n\tif (unlikely(packet_no & TXFIFO_TEMPTY)) {\n\t\tPRINTK(dev, \"smc_tx with nothing on FIFO.\\n\");\n\t\treturn;\n\t}\n\n\t \n\tsaved_packet = SMC_GET_PN(lp);\n\tSMC_SET_PN(lp, packet_no);\n\n\t \n\tSMC_SET_PTR(lp, PTR_AUTOINC | PTR_READ);\n\tSMC_GET_PKT_HDR(lp, tx_status, pkt_len);\n\tDBG(2, dev, \"TX STATUS 0x%04x PNR 0x%02x\\n\",\n\t    tx_status, packet_no);\n\n\tif (!(tx_status & ES_TX_SUC))\n\t\tdev->stats.tx_errors++;\n\n\tif (tx_status & ES_LOSTCARR)\n\t\tdev->stats.tx_carrier_errors++;\n\n\tif (tx_status & (ES_LATCOL | ES_16COL)) {\n\t\tPRINTK(dev, \"%s occurred on last xmit\\n\",\n\t\t       (tx_status & ES_LATCOL) ?\n\t\t\t\"late collision\" : \"too many collisions\");\n\t\tdev->stats.tx_window_errors++;\n\t\tif (!(dev->stats.tx_window_errors & 63) && net_ratelimit()) {\n\t\t\tnetdev_info(dev, \"unexpectedly large number of bad collisions. Please check duplex setting.\\n\");\n\t\t}\n\t}\n\n\t \n\tSMC_WAIT_MMU_BUSY(lp);\n\tSMC_SET_MMU_CMD(lp, MC_FREEPKT);\n\n\t \n\tSMC_WAIT_MMU_BUSY(lp);\n\tSMC_SET_PN(lp, saved_packet);\n\n\t \n\tSMC_SELECT_BANK(lp, 0);\n\tSMC_SET_TCR(lp, lp->tcr_cur_mode);\n\tSMC_SELECT_BANK(lp, 2);\n}\n\n\n \n\nstatic void smc_mii_out(struct net_device *dev, unsigned int val, int bits)\n{\n\tstruct smc_local *lp = netdev_priv(dev);\n\tvoid __iomem *ioaddr = lp->base;\n\tunsigned int mii_reg, mask;\n\n\tmii_reg = SMC_GET_MII(lp) & ~(MII_MCLK | MII_MDOE | MII_MDO);\n\tmii_reg |= MII_MDOE;\n\n\tfor (mask = 1 << (bits - 1); mask; mask >>= 1) {\n\t\tif (val & mask)\n\t\t\tmii_reg |= MII_MDO;\n\t\telse\n\t\t\tmii_reg &= ~MII_MDO;\n\n\t\tSMC_SET_MII(lp, mii_reg);\n\t\tudelay(MII_DELAY);\n\t\tSMC_SET_MII(lp, mii_reg | MII_MCLK);\n\t\tudelay(MII_DELAY);\n\t}\n}\n\nstatic unsigned int smc_mii_in(struct net_device *dev, int bits)\n{\n\tstruct smc_local *lp = netdev_priv(dev);\n\tvoid __iomem *ioaddr = lp->base;\n\tunsigned int mii_reg, mask, val;\n\n\tmii_reg = SMC_GET_MII(lp) & ~(MII_MCLK | MII_MDOE | MII_MDO);\n\tSMC_SET_MII(lp, mii_reg);\n\n\tfor (mask = 1 << (bits - 1), val = 0; mask; mask >>= 1) {\n\t\tif (SMC_GET_MII(lp) & MII_MDI)\n\t\t\tval |= mask;\n\n\t\tSMC_SET_MII(lp, mii_reg);\n\t\tudelay(MII_DELAY);\n\t\tSMC_SET_MII(lp, mii_reg | MII_MCLK);\n\t\tudelay(MII_DELAY);\n\t}\n\n\treturn val;\n}\n\n \nstatic int smc_phy_read(struct net_device *dev, int phyaddr, int phyreg)\n{\n\tstruct smc_local *lp = netdev_priv(dev);\n\tvoid __iomem *ioaddr = lp->base;\n\tunsigned int phydata;\n\n\tSMC_SELECT_BANK(lp, 3);\n\n\t \n\tsmc_mii_out(dev, 0xffffffff, 32);\n\n\t \n\tsmc_mii_out(dev, 6 << 10 | phyaddr << 5 | phyreg, 14);\n\n\t \n\tphydata = smc_mii_in(dev, 18);\n\n\t \n\tSMC_SET_MII(lp, SMC_GET_MII(lp) & ~(MII_MCLK|MII_MDOE|MII_MDO));\n\n\tDBG(3, dev, \"%s: phyaddr=0x%x, phyreg=0x%x, phydata=0x%x\\n\",\n\t    __func__, phyaddr, phyreg, phydata);\n\n\tSMC_SELECT_BANK(lp, 2);\n\treturn phydata;\n}\n\n \nstatic void smc_phy_write(struct net_device *dev, int phyaddr, int phyreg,\n\t\t\t  int phydata)\n{\n\tstruct smc_local *lp = netdev_priv(dev);\n\tvoid __iomem *ioaddr = lp->base;\n\n\tSMC_SELECT_BANK(lp, 3);\n\n\t \n\tsmc_mii_out(dev, 0xffffffff, 32);\n\n\t \n\tsmc_mii_out(dev, 5 << 28 | phyaddr << 23 | phyreg << 18 | 2 << 16 | phydata, 32);\n\n\t \n\tSMC_SET_MII(lp, SMC_GET_MII(lp) & ~(MII_MCLK|MII_MDOE|MII_MDO));\n\n\tDBG(3, dev, \"%s: phyaddr=0x%x, phyreg=0x%x, phydata=0x%x\\n\",\n\t    __func__, phyaddr, phyreg, phydata);\n\n\tSMC_SELECT_BANK(lp, 2);\n}\n\n \nstatic void smc_phy_detect(struct net_device *dev)\n{\n\tstruct smc_local *lp = netdev_priv(dev);\n\tint phyaddr;\n\n\tDBG(2, dev, \"%s\\n\", __func__);\n\n\tlp->phy_type = 0;\n\n\t \n\tfor (phyaddr = 1; phyaddr < 33; ++phyaddr) {\n\t\tunsigned int id1, id2;\n\n\t\t \n\t\tid1 = smc_phy_read(dev, phyaddr & 31, MII_PHYSID1);\n\t\tid2 = smc_phy_read(dev, phyaddr & 31, MII_PHYSID2);\n\n\t\tDBG(3, dev, \"phy_id1=0x%x, phy_id2=0x%x\\n\",\n\t\t    id1, id2);\n\n\t\t \n\t\tif (id1 != 0x0000 && id1 != 0xffff && id1 != 0x8000 &&\n\t\t    id2 != 0x0000 && id2 != 0xffff && id2 != 0x8000) {\n\t\t\t \n\t\t\tlp->mii.phy_id = phyaddr & 31;\n\t\t\tlp->phy_type = id1 << 16 | id2;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n \nstatic int smc_phy_fixed(struct net_device *dev)\n{\n\tstruct smc_local *lp = netdev_priv(dev);\n\tvoid __iomem *ioaddr = lp->base;\n\tint phyaddr = lp->mii.phy_id;\n\tint bmcr, cfg1;\n\n\tDBG(3, dev, \"%s\\n\", __func__);\n\n\t \n\tcfg1 = smc_phy_read(dev, phyaddr, PHY_CFG1_REG);\n\tcfg1 |= PHY_CFG1_LNKDIS;\n\tsmc_phy_write(dev, phyaddr, PHY_CFG1_REG, cfg1);\n\n\t \n\tbmcr = 0;\n\n\tif (lp->ctl_rfduplx)\n\t\tbmcr |= BMCR_FULLDPLX;\n\n\tif (lp->ctl_rspeed == 100)\n\t\tbmcr |= BMCR_SPEED100;\n\n\t \n\tsmc_phy_write(dev, phyaddr, MII_BMCR, bmcr);\n\n\t \n\tSMC_SELECT_BANK(lp, 0);\n\tSMC_SET_RPC(lp, lp->rpc_cur_mode);\n\tSMC_SELECT_BANK(lp, 2);\n\n\treturn 1;\n}\n\n \nstatic int smc_phy_reset(struct net_device *dev, int phy)\n{\n\tstruct smc_local *lp = netdev_priv(dev);\n\tunsigned int bmcr;\n\tint timeout;\n\n\tsmc_phy_write(dev, phy, MII_BMCR, BMCR_RESET);\n\n\tfor (timeout = 2; timeout; timeout--) {\n\t\tspin_unlock_irq(&lp->lock);\n\t\tmsleep(50);\n\t\tspin_lock_irq(&lp->lock);\n\n\t\tbmcr = smc_phy_read(dev, phy, MII_BMCR);\n\t\tif (!(bmcr & BMCR_RESET))\n\t\t\tbreak;\n\t}\n\n\treturn bmcr & BMCR_RESET;\n}\n\n \nstatic void smc_phy_powerdown(struct net_device *dev)\n{\n\tstruct smc_local *lp = netdev_priv(dev);\n\tunsigned int bmcr;\n\tint phy = lp->mii.phy_id;\n\n\tif (lp->phy_type == 0)\n\t\treturn;\n\n\t \n\tcancel_work_sync(&lp->phy_configure);\n\n\tbmcr = smc_phy_read(dev, phy, MII_BMCR);\n\tsmc_phy_write(dev, phy, MII_BMCR, bmcr | BMCR_PDOWN);\n}\n\n \nstatic void smc_phy_check_media(struct net_device *dev, int init)\n{\n\tstruct smc_local *lp = netdev_priv(dev);\n\tvoid __iomem *ioaddr = lp->base;\n\n\tif (mii_check_media(&lp->mii, netif_msg_link(lp), init)) {\n\t\t \n\t\tif (lp->mii.full_duplex) {\n\t\t\tlp->tcr_cur_mode |= TCR_SWFDUP;\n\t\t} else {\n\t\t\tlp->tcr_cur_mode &= ~TCR_SWFDUP;\n\t\t}\n\n\t\tSMC_SELECT_BANK(lp, 0);\n\t\tSMC_SET_TCR(lp, lp->tcr_cur_mode);\n\t}\n}\n\n \nstatic void smc_phy_configure(struct work_struct *work)\n{\n\tstruct smc_local *lp =\n\t\tcontainer_of(work, struct smc_local, phy_configure);\n\tstruct net_device *dev = lp->dev;\n\tvoid __iomem *ioaddr = lp->base;\n\tint phyaddr = lp->mii.phy_id;\n\tint my_phy_caps;  \n\tint my_ad_caps;  \n\n\tDBG(3, dev, \"smc_program_phy()\\n\");\n\n\tspin_lock_irq(&lp->lock);\n\n\t \n\tif (lp->phy_type == 0)\n\t\tgoto smc_phy_configure_exit;\n\n\tif (smc_phy_reset(dev, phyaddr)) {\n\t\tnetdev_info(dev, \"PHY reset timed out\\n\");\n\t\tgoto smc_phy_configure_exit;\n\t}\n\n\t \n\tsmc_phy_write(dev, phyaddr, PHY_MASK_REG,\n\t\tPHY_INT_LOSSSYNC | PHY_INT_CWRD | PHY_INT_SSD |\n\t\tPHY_INT_ESD | PHY_INT_RPOL | PHY_INT_JAB |\n\t\tPHY_INT_SPDDET | PHY_INT_DPLXDET);\n\n\t \n\tSMC_SELECT_BANK(lp, 0);\n\tSMC_SET_RPC(lp, lp->rpc_cur_mode);\n\n\t \n\tif (lp->mii.force_media) {\n\t\tsmc_phy_fixed(dev);\n\t\tgoto smc_phy_configure_exit;\n\t}\n\n\t \n\tmy_phy_caps = smc_phy_read(dev, phyaddr, MII_BMSR);\n\n\tif (!(my_phy_caps & BMSR_ANEGCAPABLE)) {\n\t\tnetdev_info(dev, \"Auto negotiation NOT supported\\n\");\n\t\tsmc_phy_fixed(dev);\n\t\tgoto smc_phy_configure_exit;\n\t}\n\n\tmy_ad_caps = ADVERTISE_CSMA;  \n\n\tif (my_phy_caps & BMSR_100BASE4)\n\t\tmy_ad_caps |= ADVERTISE_100BASE4;\n\tif (my_phy_caps & BMSR_100FULL)\n\t\tmy_ad_caps |= ADVERTISE_100FULL;\n\tif (my_phy_caps & BMSR_100HALF)\n\t\tmy_ad_caps |= ADVERTISE_100HALF;\n\tif (my_phy_caps & BMSR_10FULL)\n\t\tmy_ad_caps |= ADVERTISE_10FULL;\n\tif (my_phy_caps & BMSR_10HALF)\n\t\tmy_ad_caps |= ADVERTISE_10HALF;\n\n\t \n\tif (lp->ctl_rspeed != 100)\n\t\tmy_ad_caps &= ~(ADVERTISE_100BASE4|ADVERTISE_100FULL|ADVERTISE_100HALF);\n\n\tif (!lp->ctl_rfduplx)\n\t\tmy_ad_caps &= ~(ADVERTISE_100FULL|ADVERTISE_10FULL);\n\n\t \n\tsmc_phy_write(dev, phyaddr, MII_ADVERTISE, my_ad_caps);\n\tlp->mii.advertising = my_ad_caps;\n\n\t \n\tsmc_phy_read(dev, phyaddr, MII_ADVERTISE);\n\n\tDBG(2, dev, \"phy caps=%x\\n\", my_phy_caps);\n\tDBG(2, dev, \"phy advertised caps=%x\\n\", my_ad_caps);\n\n\t \n\tsmc_phy_write(dev, phyaddr, MII_BMCR, BMCR_ANENABLE | BMCR_ANRESTART);\n\n\tsmc_phy_check_media(dev, 1);\n\nsmc_phy_configure_exit:\n\tSMC_SELECT_BANK(lp, 2);\n\tspin_unlock_irq(&lp->lock);\n}\n\n \nstatic void smc_phy_interrupt(struct net_device *dev)\n{\n\tstruct smc_local *lp = netdev_priv(dev);\n\tint phyaddr = lp->mii.phy_id;\n\tint phy18;\n\n\tDBG(2, dev, \"%s\\n\", __func__);\n\n\tif (lp->phy_type == 0)\n\t\treturn;\n\n\tfor(;;) {\n\t\tsmc_phy_check_media(dev, 0);\n\n\t\t \n\t\tphy18 = smc_phy_read(dev, phyaddr, PHY_INT_REG);\n\t\tif ((phy18 & PHY_INT_INT) == 0)\n\t\t\tbreak;\n\t}\n}\n\n \n\nstatic void smc_10bt_check_media(struct net_device *dev, int init)\n{\n\tstruct smc_local *lp = netdev_priv(dev);\n\tvoid __iomem *ioaddr = lp->base;\n\tunsigned int old_carrier, new_carrier;\n\n\told_carrier = netif_carrier_ok(dev) ? 1 : 0;\n\n\tSMC_SELECT_BANK(lp, 0);\n\tnew_carrier = (SMC_GET_EPH_STATUS(lp) & ES_LINK_OK) ? 1 : 0;\n\tSMC_SELECT_BANK(lp, 2);\n\n\tif (init || (old_carrier != new_carrier)) {\n\t\tif (!new_carrier) {\n\t\t\tnetif_carrier_off(dev);\n\t\t} else {\n\t\t\tnetif_carrier_on(dev);\n\t\t}\n\t\tif (netif_msg_link(lp))\n\t\t\tnetdev_info(dev, \"link %s\\n\",\n\t\t\t\t    new_carrier ? \"up\" : \"down\");\n\t}\n}\n\nstatic void smc_eph_interrupt(struct net_device *dev)\n{\n\tstruct smc_local *lp = netdev_priv(dev);\n\tvoid __iomem *ioaddr = lp->base;\n\tunsigned int ctl;\n\n\tsmc_10bt_check_media(dev, 0);\n\n\tSMC_SELECT_BANK(lp, 1);\n\tctl = SMC_GET_CTL(lp);\n\tSMC_SET_CTL(lp, ctl & ~CTL_LE_ENABLE);\n\tSMC_SET_CTL(lp, ctl);\n\tSMC_SELECT_BANK(lp, 2);\n}\n\n \nstatic irqreturn_t smc_interrupt(int irq, void *dev_id)\n{\n\tstruct net_device *dev = dev_id;\n\tstruct smc_local *lp = netdev_priv(dev);\n\tvoid __iomem *ioaddr = lp->base;\n\tint status, mask, timeout, card_stats;\n\tint saved_pointer;\n\n\tDBG(3, dev, \"%s\\n\", __func__);\n\n\tspin_lock(&lp->lock);\n\n\t \n\tSMC_INTERRUPT_PREAMBLE;\n\n\tsaved_pointer = SMC_GET_PTR(lp);\n\tmask = SMC_GET_INT_MASK(lp);\n\tSMC_SET_INT_MASK(lp, 0);\n\n\t \n\ttimeout = MAX_IRQ_LOOPS;\n\n\tdo {\n\t\tstatus = SMC_GET_INT(lp);\n\n\t\tDBG(2, dev, \"INT 0x%02x MASK 0x%02x MEM 0x%04x FIFO 0x%04x\\n\",\n\t\t    status, mask,\n\t\t    ({ int meminfo; SMC_SELECT_BANK(lp, 0);\n\t\t       meminfo = SMC_GET_MIR(lp);\n\t\t       SMC_SELECT_BANK(lp, 2); meminfo; }),\n\t\t    SMC_GET_FIFO(lp));\n\n\t\tstatus &= mask;\n\t\tif (!status)\n\t\t\tbreak;\n\n\t\tif (status & IM_TX_INT) {\n\t\t\t \n\t\t\tDBG(3, dev, \"TX int\\n\");\n\t\t\tsmc_tx(dev);\n\t\t\tSMC_ACK_INT(lp, IM_TX_INT);\n\t\t\tif (THROTTLE_TX_PKTS)\n\t\t\t\tnetif_wake_queue(dev);\n\t\t} else if (status & IM_RCV_INT) {\n\t\t\tDBG(3, dev, \"RX irq\\n\");\n\t\t\tsmc_rcv(dev);\n\t\t} else if (status & IM_ALLOC_INT) {\n\t\t\tDBG(3, dev, \"Allocation irq\\n\");\n\t\t\ttasklet_hi_schedule(&lp->tx_task);\n\t\t\tmask &= ~IM_ALLOC_INT;\n\t\t} else if (status & IM_TX_EMPTY_INT) {\n\t\t\tDBG(3, dev, \"TX empty\\n\");\n\t\t\tmask &= ~IM_TX_EMPTY_INT;\n\n\t\t\t \n\t\t\tSMC_SELECT_BANK(lp, 0);\n\t\t\tcard_stats = SMC_GET_COUNTER(lp);\n\t\t\tSMC_SELECT_BANK(lp, 2);\n\n\t\t\t \n\t\t\tdev->stats.collisions += card_stats & 0xF;\n\t\t\tcard_stats >>= 4;\n\n\t\t\t \n\t\t\tdev->stats.collisions += card_stats & 0xF;\n\t\t} else if (status & IM_RX_OVRN_INT) {\n\t\t\tDBG(1, dev, \"RX overrun (EPH_ST 0x%04x)\\n\",\n\t\t\t    ({ int eph_st; SMC_SELECT_BANK(lp, 0);\n\t\t\t       eph_st = SMC_GET_EPH_STATUS(lp);\n\t\t\t       SMC_SELECT_BANK(lp, 2); eph_st; }));\n\t\t\tSMC_ACK_INT(lp, IM_RX_OVRN_INT);\n\t\t\tdev->stats.rx_errors++;\n\t\t\tdev->stats.rx_fifo_errors++;\n\t\t} else if (status & IM_EPH_INT) {\n\t\t\tsmc_eph_interrupt(dev);\n\t\t} else if (status & IM_MDINT) {\n\t\t\tSMC_ACK_INT(lp, IM_MDINT);\n\t\t\tsmc_phy_interrupt(dev);\n\t\t} else if (status & IM_ERCV_INT) {\n\t\t\tSMC_ACK_INT(lp, IM_ERCV_INT);\n\t\t\tPRINTK(dev, \"UNSUPPORTED: ERCV INTERRUPT\\n\");\n\t\t}\n\t} while (--timeout);\n\n\t \n\tSMC_SET_PTR(lp, saved_pointer);\n\tSMC_SET_INT_MASK(lp, mask);\n\tspin_unlock(&lp->lock);\n\n#ifndef CONFIG_NET_POLL_CONTROLLER\n\tif (timeout == MAX_IRQ_LOOPS)\n\t\tPRINTK(dev, \"spurious interrupt (mask = 0x%02x)\\n\",\n\t\t       mask);\n#endif\n\tDBG(3, dev, \"Interrupt done (%d loops)\\n\",\n\t    MAX_IRQ_LOOPS - timeout);\n\n\t \n\treturn IRQ_HANDLED;\n}\n\n#ifdef CONFIG_NET_POLL_CONTROLLER\n \nstatic void smc_poll_controller(struct net_device *dev)\n{\n\tdisable_irq(dev->irq);\n\tsmc_interrupt(dev->irq, dev);\n\tenable_irq(dev->irq);\n}\n#endif\n\n \nstatic void smc_timeout(struct net_device *dev, unsigned int txqueue)\n{\n\tstruct smc_local *lp = netdev_priv(dev);\n\tvoid __iomem *ioaddr = lp->base;\n\tint status, mask, eph_st, meminfo, fifo;\n\n\tDBG(2, dev, \"%s\\n\", __func__);\n\n\tspin_lock_irq(&lp->lock);\n\tstatus = SMC_GET_INT(lp);\n\tmask = SMC_GET_INT_MASK(lp);\n\tfifo = SMC_GET_FIFO(lp);\n\tSMC_SELECT_BANK(lp, 0);\n\teph_st = SMC_GET_EPH_STATUS(lp);\n\tmeminfo = SMC_GET_MIR(lp);\n\tSMC_SELECT_BANK(lp, 2);\n\tspin_unlock_irq(&lp->lock);\n\tPRINTK(dev, \"TX timeout (INT 0x%02x INTMASK 0x%02x MEM 0x%04x FIFO 0x%04x EPH_ST 0x%04x)\\n\",\n\t       status, mask, meminfo, fifo, eph_st);\n\n\tsmc_reset(dev);\n\tsmc_enable(dev);\n\n\t \n\tif (lp->phy_type != 0)\n\t\tschedule_work(&lp->phy_configure);\n\n\t \n\tnetif_trans_update(dev);  \n\tnetif_wake_queue(dev);\n}\n\n \nstatic void smc_set_multicast_list(struct net_device *dev)\n{\n\tstruct smc_local *lp = netdev_priv(dev);\n\tvoid __iomem *ioaddr = lp->base;\n\tunsigned char multicast_table[8];\n\tint update_multicast = 0;\n\n\tDBG(2, dev, \"%s\\n\", __func__);\n\n\tif (dev->flags & IFF_PROMISC) {\n\t\tDBG(2, dev, \"RCR_PRMS\\n\");\n\t\tlp->rcr_cur_mode |= RCR_PRMS;\n\t}\n\n \n\n\t \n\telse if (dev->flags & IFF_ALLMULTI || netdev_mc_count(dev) > 16) {\n\t\tDBG(2, dev, \"RCR_ALMUL\\n\");\n\t\tlp->rcr_cur_mode |= RCR_ALMUL;\n\t}\n\n\t \n\telse if (!netdev_mc_empty(dev)) {\n\t\tstruct netdev_hw_addr *ha;\n\n\t\t \n\t\tstatic const unsigned char invert3[] = {0, 4, 2, 6, 1, 5, 3, 7};\n\n\t\t \n\t\tmemset(multicast_table, 0, sizeof(multicast_table));\n\n\t\tnetdev_for_each_mc_addr(ha, dev) {\n\t\t\tint position;\n\n\t\t\t \n\t\t\tposition = crc32_le(~0, ha->addr, 6) & 0x3f;\n\n\t\t\t \n\t\t\tmulticast_table[invert3[position&7]] |=\n\t\t\t\t(1<<invert3[(position>>3)&7]);\n\t\t}\n\n\t\t \n\t\tlp->rcr_cur_mode &= ~(RCR_PRMS | RCR_ALMUL);\n\n\t\t \n\t\tupdate_multicast = 1;\n\t} else  {\n\t\tDBG(2, dev, \"~(RCR_PRMS|RCR_ALMUL)\\n\");\n\t\tlp->rcr_cur_mode &= ~(RCR_PRMS | RCR_ALMUL);\n\n\t\t \n\t\tmemset(multicast_table, 0, sizeof(multicast_table));\n\t\tupdate_multicast = 1;\n\t}\n\n\tspin_lock_irq(&lp->lock);\n\tSMC_SELECT_BANK(lp, 0);\n\tSMC_SET_RCR(lp, lp->rcr_cur_mode);\n\tif (update_multicast) {\n\t\tSMC_SELECT_BANK(lp, 3);\n\t\tSMC_SET_MCAST(lp, multicast_table);\n\t}\n\tSMC_SELECT_BANK(lp, 2);\n\tspin_unlock_irq(&lp->lock);\n}\n\n\n \nstatic int\nsmc_open(struct net_device *dev)\n{\n\tstruct smc_local *lp = netdev_priv(dev);\n\n\tDBG(2, dev, \"%s\\n\", __func__);\n\n\t \n\tlp->tcr_cur_mode = TCR_DEFAULT;\n\tlp->rcr_cur_mode = RCR_DEFAULT;\n\tlp->rpc_cur_mode = RPC_DEFAULT |\n\t\t\t\tlp->cfg.leda << RPC_LSXA_SHFT |\n\t\t\t\tlp->cfg.ledb << RPC_LSXB_SHFT;\n\n\t \n\tif (lp->phy_type == 0)\n\t\tlp->tcr_cur_mode |= TCR_MON_CSN;\n\n\t \n\tsmc_reset(dev);\n\tsmc_enable(dev);\n\n\t \n\tif (lp->phy_type != 0)\n\t\tsmc_phy_configure(&lp->phy_configure);\n\telse {\n\t\tspin_lock_irq(&lp->lock);\n\t\tsmc_10bt_check_media(dev, 1);\n\t\tspin_unlock_irq(&lp->lock);\n\t}\n\n\tnetif_start_queue(dev);\n\treturn 0;\n}\n\n \nstatic int smc_close(struct net_device *dev)\n{\n\tstruct smc_local *lp = netdev_priv(dev);\n\n\tDBG(2, dev, \"%s\\n\", __func__);\n\n\tnetif_stop_queue(dev);\n\tnetif_carrier_off(dev);\n\n\t \n\tsmc_shutdown(dev);\n\ttasklet_kill(&lp->tx_task);\n\tsmc_phy_powerdown(dev);\n\treturn 0;\n}\n\n \nstatic int\nsmc_ethtool_get_link_ksettings(struct net_device *dev,\n\t\t\t       struct ethtool_link_ksettings *cmd)\n{\n\tstruct smc_local *lp = netdev_priv(dev);\n\n\tif (lp->phy_type != 0) {\n\t\tspin_lock_irq(&lp->lock);\n\t\tmii_ethtool_get_link_ksettings(&lp->mii, cmd);\n\t\tspin_unlock_irq(&lp->lock);\n\t} else {\n\t\tu32 supported = SUPPORTED_10baseT_Half |\n\t\t\t\t SUPPORTED_10baseT_Full |\n\t\t\t\t SUPPORTED_TP | SUPPORTED_AUI;\n\n\t\tif (lp->ctl_rspeed == 10)\n\t\t\tcmd->base.speed = SPEED_10;\n\t\telse if (lp->ctl_rspeed == 100)\n\t\t\tcmd->base.speed = SPEED_100;\n\n\t\tcmd->base.autoneg = AUTONEG_DISABLE;\n\t\tcmd->base.port = 0;\n\t\tcmd->base.duplex = lp->tcr_cur_mode & TCR_SWFDUP ?\n\t\t\tDUPLEX_FULL : DUPLEX_HALF;\n\n\t\tethtool_convert_legacy_u32_to_link_mode(\n\t\t\tcmd->link_modes.supported, supported);\n\t}\n\n\treturn 0;\n}\n\nstatic int\nsmc_ethtool_set_link_ksettings(struct net_device *dev,\n\t\t\t       const struct ethtool_link_ksettings *cmd)\n{\n\tstruct smc_local *lp = netdev_priv(dev);\n\tint ret;\n\n\tif (lp->phy_type != 0) {\n\t\tspin_lock_irq(&lp->lock);\n\t\tret = mii_ethtool_set_link_ksettings(&lp->mii, cmd);\n\t\tspin_unlock_irq(&lp->lock);\n\t} else {\n\t\tif (cmd->base.autoneg != AUTONEG_DISABLE ||\n\t\t    cmd->base.speed != SPEED_10 ||\n\t\t    (cmd->base.duplex != DUPLEX_HALF &&\n\t\t     cmd->base.duplex != DUPLEX_FULL) ||\n\t\t    (cmd->base.port != PORT_TP && cmd->base.port != PORT_AUI))\n\t\t\treturn -EINVAL;\n\n\n\t\tlp->ctl_rfduplx = cmd->base.duplex == DUPLEX_FULL;\n\n\n\n\n\t\tret = 0;\n\t}\n\n\treturn ret;\n}\n\nstatic void\nsmc_ethtool_getdrvinfo(struct net_device *dev, struct ethtool_drvinfo *info)\n{\n\tstrscpy(info->driver, CARDNAME, sizeof(info->driver));\n\tstrscpy(info->version, version, sizeof(info->version));\n\tstrscpy(info->bus_info, dev_name(dev->dev.parent),\n\t\tsizeof(info->bus_info));\n}\n\nstatic int smc_ethtool_nwayreset(struct net_device *dev)\n{\n\tstruct smc_local *lp = netdev_priv(dev);\n\tint ret = -EINVAL;\n\n\tif (lp->phy_type != 0) {\n\t\tspin_lock_irq(&lp->lock);\n\t\tret = mii_nway_restart(&lp->mii);\n\t\tspin_unlock_irq(&lp->lock);\n\t}\n\n\treturn ret;\n}\n\nstatic u32 smc_ethtool_getmsglevel(struct net_device *dev)\n{\n\tstruct smc_local *lp = netdev_priv(dev);\n\treturn lp->msg_enable;\n}\n\nstatic void smc_ethtool_setmsglevel(struct net_device *dev, u32 level)\n{\n\tstruct smc_local *lp = netdev_priv(dev);\n\tlp->msg_enable = level;\n}\n\nstatic int smc_write_eeprom_word(struct net_device *dev, u16 addr, u16 word)\n{\n\tu16 ctl;\n\tstruct smc_local *lp = netdev_priv(dev);\n\tvoid __iomem *ioaddr = lp->base;\n\n\tspin_lock_irq(&lp->lock);\n\t \n\tSMC_SELECT_BANK(lp, 1);\n\tSMC_SET_GP(lp, word);\n\t \n\tSMC_SELECT_BANK(lp, 2);\n\tSMC_SET_PTR(lp, addr);\n\t \n\tSMC_SELECT_BANK(lp, 1);\n\tctl = SMC_GET_CTL(lp);\n\tSMC_SET_CTL(lp, ctl | (CTL_EEPROM_SELECT | CTL_STORE));\n\t \n\tdo {\n\t\tudelay(1);\n\t} while (SMC_GET_CTL(lp) & CTL_STORE);\n\t \n\tSMC_SET_CTL(lp, ctl);\n\tSMC_SELECT_BANK(lp, 2);\n\tspin_unlock_irq(&lp->lock);\n\treturn 0;\n}\n\nstatic int smc_read_eeprom_word(struct net_device *dev, u16 addr, u16 *word)\n{\n\tu16 ctl;\n\tstruct smc_local *lp = netdev_priv(dev);\n\tvoid __iomem *ioaddr = lp->base;\n\n\tspin_lock_irq(&lp->lock);\n\t \n\tSMC_SELECT_BANK(lp, 2);\n\tSMC_SET_PTR(lp, addr | PTR_READ);\n\t \n\tSMC_SELECT_BANK(lp, 1);\n\tSMC_SET_GP(lp, 0xffff);\t \n\tctl = SMC_GET_CTL(lp);\n\tSMC_SET_CTL(lp, ctl | (CTL_EEPROM_SELECT | CTL_RELOAD));\n\t \n\tdo {\n\t\tudelay(1);\n\t} while (SMC_GET_CTL(lp) & CTL_RELOAD);\n\t \n\t*word = SMC_GET_GP(lp);\n\t \n\tSMC_SET_CTL(lp, ctl);\n\tSMC_SELECT_BANK(lp, 2);\n\tspin_unlock_irq(&lp->lock);\n\treturn 0;\n}\n\nstatic int smc_ethtool_geteeprom_len(struct net_device *dev)\n{\n\treturn 0x23 * 2;\n}\n\nstatic int smc_ethtool_geteeprom(struct net_device *dev,\n\t\tstruct ethtool_eeprom *eeprom, u8 *data)\n{\n\tint i;\n\tint imax;\n\n\tDBG(1, dev, \"Reading %d bytes at %d(0x%x)\\n\",\n\t\teeprom->len, eeprom->offset, eeprom->offset);\n\timax = smc_ethtool_geteeprom_len(dev);\n\tfor (i = 0; i < eeprom->len; i += 2) {\n\t\tint ret;\n\t\tu16 wbuf;\n\t\tint offset = i + eeprom->offset;\n\t\tif (offset > imax)\n\t\t\tbreak;\n\t\tret = smc_read_eeprom_word(dev, offset >> 1, &wbuf);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t\tDBG(2, dev, \"Read 0x%x from 0x%x\\n\", wbuf, offset >> 1);\n\t\tdata[i] = (wbuf >> 8) & 0xff;\n\t\tdata[i+1] = wbuf & 0xff;\n\t}\n\treturn 0;\n}\n\nstatic int smc_ethtool_seteeprom(struct net_device *dev,\n\t\tstruct ethtool_eeprom *eeprom, u8 *data)\n{\n\tint i;\n\tint imax;\n\n\tDBG(1, dev, \"Writing %d bytes to %d(0x%x)\\n\",\n\t    eeprom->len, eeprom->offset, eeprom->offset);\n\timax = smc_ethtool_geteeprom_len(dev);\n\tfor (i = 0; i < eeprom->len; i += 2) {\n\t\tint ret;\n\t\tu16 wbuf;\n\t\tint offset = i + eeprom->offset;\n\t\tif (offset > imax)\n\t\t\tbreak;\n\t\twbuf = (data[i] << 8) | data[i + 1];\n\t\tDBG(2, dev, \"Writing 0x%x to 0x%x\\n\", wbuf, offset >> 1);\n\t\tret = smc_write_eeprom_word(dev, offset >> 1, wbuf);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}\n\n\nstatic const struct ethtool_ops smc_ethtool_ops = {\n\t.get_drvinfo\t= smc_ethtool_getdrvinfo,\n\n\t.get_msglevel\t= smc_ethtool_getmsglevel,\n\t.set_msglevel\t= smc_ethtool_setmsglevel,\n\t.nway_reset\t= smc_ethtool_nwayreset,\n\t.get_link\t= ethtool_op_get_link,\n\t.get_eeprom_len = smc_ethtool_geteeprom_len,\n\t.get_eeprom\t= smc_ethtool_geteeprom,\n\t.set_eeprom\t= smc_ethtool_seteeprom,\n\t.get_link_ksettings\t= smc_ethtool_get_link_ksettings,\n\t.set_link_ksettings\t= smc_ethtool_set_link_ksettings,\n};\n\nstatic const struct net_device_ops smc_netdev_ops = {\n\t.ndo_open\t\t= smc_open,\n\t.ndo_stop\t\t= smc_close,\n\t.ndo_start_xmit\t\t= smc_hard_start_xmit,\n\t.ndo_tx_timeout\t\t= smc_timeout,\n\t.ndo_set_rx_mode\t= smc_set_multicast_list,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_set_mac_address \t= eth_mac_addr,\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\t.ndo_poll_controller\t= smc_poll_controller,\n#endif\n};\n\n \n \nstatic int smc_findirq(struct smc_local *lp)\n{\n\tvoid __iomem *ioaddr = lp->base;\n\tint timeout = 20;\n\tunsigned long cookie;\n\n\tDBG(2, lp->dev, \"%s: %s\\n\", CARDNAME, __func__);\n\n\tcookie = probe_irq_on();\n\n\t \n\t \n\tSMC_SELECT_BANK(lp, 2);\n\tSMC_SET_INT_MASK(lp, IM_ALLOC_INT);\n\n\t \n\tSMC_SET_MMU_CMD(lp, MC_ALLOC | 1);\n\n\t \n\tdo {\n\t\tint int_status;\n\t\tudelay(10);\n\t\tint_status = SMC_GET_INT(lp);\n\t\tif (int_status & IM_ALLOC_INT)\n\t\t\tbreak;\t\t \n\t} while (--timeout);\n\n\t \n\n\t \n\tSMC_SET_INT_MASK(lp, 0);\n\n\t \n\treturn probe_irq_off(cookie);\n}\n\n \nstatic int smc_probe(struct net_device *dev, void __iomem *ioaddr,\n\t\t     unsigned long irq_flags)\n{\n\tstruct smc_local *lp = netdev_priv(dev);\n\tint retval;\n\tunsigned int val, revision_register;\n\tconst char *version_string;\n\tu8 addr[ETH_ALEN];\n\n\tDBG(2, dev, \"%s: %s\\n\", CARDNAME, __func__);\n\n\t \n\tval = SMC_CURRENT_BANK(lp);\n\tDBG(2, dev, \"%s: bank signature probe returned 0x%04x\\n\",\n\t    CARDNAME, val);\n\tif ((val & 0xFF00) != 0x3300) {\n\t\tif ((val & 0xFF) == 0x33) {\n\t\t\tnetdev_warn(dev,\n\t\t\t\t    \"%s: Detected possible byte-swapped interface at IOADDR %p\\n\",\n\t\t\t\t    CARDNAME, ioaddr);\n\t\t}\n\t\tretval = -ENODEV;\n\t\tgoto err_out;\n\t}\n\n\t \n\tSMC_SELECT_BANK(lp, 0);\n\tval = SMC_CURRENT_BANK(lp);\n\tif ((val & 0xFF00) != 0x3300) {\n\t\tretval = -ENODEV;\n\t\tgoto err_out;\n\t}\n\n\t \n\tSMC_SELECT_BANK(lp, 1);\n\tval = SMC_GET_BASE(lp);\n\tval = ((val & 0x1F00) >> 3) << SMC_IO_SHIFT;\n\tif (((unsigned long)ioaddr & (0x3e0 << SMC_IO_SHIFT)) != val) {\n\t\tnetdev_warn(dev, \"%s: IOADDR %p doesn't match configuration (%x).\\n\",\n\t\t\t    CARDNAME, ioaddr, val);\n\t}\n\n\t \n\tSMC_SELECT_BANK(lp, 3);\n\trevision_register = SMC_GET_REV(lp);\n\tDBG(2, dev, \"%s: revision = 0x%04x\\n\", CARDNAME, revision_register);\n\tversion_string = chip_ids[ (revision_register >> 4) & 0xF];\n\tif (!version_string || (revision_register & 0xff00) != 0x3300) {\n\t\t \n\t\tnetdev_warn(dev, \"%s: IO %p: Unrecognized revision register 0x%04x, Contact author.\\n\",\n\t\t\t    CARDNAME, ioaddr, revision_register);\n\n\t\tretval = -ENODEV;\n\t\tgoto err_out;\n\t}\n\n\t \n\tpr_info_once(\"%s\\n\", version);\n\n\t \n\tdev->base_addr = (unsigned long)ioaddr;\n\tlp->base = ioaddr;\n\tlp->version = revision_register & 0xff;\n\tspin_lock_init(&lp->lock);\n\n\t \n\tSMC_SELECT_BANK(lp, 1);\n\tSMC_GET_MAC_ADDR(lp, addr);\n\teth_hw_addr_set(dev, addr);\n\n\t \n\tsmc_reset(dev);\n\n\t \n\tif (dev->irq < 1) {\n\t\tint trials;\n\n\t\ttrials = 3;\n\t\twhile (trials--) {\n\t\t\tdev->irq = smc_findirq(lp);\n\t\t\tif (dev->irq)\n\t\t\t\tbreak;\n\t\t\t \n\t\t\tsmc_reset(dev);\n\t\t}\n\t}\n\tif (dev->irq == 0) {\n\t\tnetdev_warn(dev, \"Couldn't autodetect your IRQ. Use irq=xx.\\n\");\n\t\tretval = -ENODEV;\n\t\tgoto err_out;\n\t}\n\tdev->irq = irq_canonicalize(dev->irq);\n\n\tdev->watchdog_timeo = msecs_to_jiffies(watchdog);\n\tdev->netdev_ops = &smc_netdev_ops;\n\tdev->ethtool_ops = &smc_ethtool_ops;\n\n\ttasklet_setup(&lp->tx_task, smc_hardware_send_pkt);\n\tINIT_WORK(&lp->phy_configure, smc_phy_configure);\n\tlp->dev = dev;\n\tlp->mii.phy_id_mask = 0x1f;\n\tlp->mii.reg_num_mask = 0x1f;\n\tlp->mii.force_media = 0;\n\tlp->mii.full_duplex = 0;\n\tlp->mii.dev = dev;\n\tlp->mii.mdio_read = smc_phy_read;\n\tlp->mii.mdio_write = smc_phy_write;\n\n\t \n\tif (lp->version >= (CHIP_91100 << 4))\n\t\tsmc_phy_detect(dev);\n\n\t \n\tsmc_shutdown(dev);\n\tsmc_phy_powerdown(dev);\n\n\t \n\tlp->msg_enable = NETIF_MSG_LINK;\n\tlp->ctl_rfduplx = 0;\n\tlp->ctl_rspeed = 10;\n\n\tif (lp->version >= (CHIP_91100 << 4)) {\n\t\tlp->ctl_rfduplx = 1;\n\t\tlp->ctl_rspeed = 100;\n\t}\n\n\t \n\tretval = request_irq(dev->irq, smc_interrupt, irq_flags, dev->name, dev);\n\tif (retval)\n\t\tgoto err_out;\n\n#ifdef CONFIG_ARCH_PXA\n#  ifdef SMC_USE_PXA_DMA\n\tlp->cfg.flags |= SMC91X_USE_DMA;\n#  endif\n\tif (lp->cfg.flags & SMC91X_USE_DMA) {\n\t\tdma_cap_mask_t mask;\n\n\t\tdma_cap_zero(mask);\n\t\tdma_cap_set(DMA_SLAVE, mask);\n\t\tlp->dma_chan = dma_request_channel(mask, NULL, NULL);\n\t}\n#endif\n\n\tretval = register_netdev(dev);\n\tif (retval == 0) {\n\t\t \n\t\tnetdev_info(dev, \"%s (rev %d) at %p IRQ %d\",\n\t\t\t    version_string, revision_register & 0x0f,\n\t\t\t    lp->base, dev->irq);\n\n\t\tif (lp->dma_chan)\n\t\t\tpr_cont(\" DMA %p\", lp->dma_chan);\n\n\t\tpr_cont(\"%s%s\\n\",\n\t\t\tlp->cfg.flags & SMC91X_NOWAIT ? \" [nowait]\" : \"\",\n\t\t\tTHROTTLE_TX_PKTS ? \" [throttle_tx]\" : \"\");\n\n\t\tif (!is_valid_ether_addr(dev->dev_addr)) {\n\t\t\tnetdev_warn(dev, \"Invalid ethernet MAC address. Please set using ifconfig\\n\");\n\t\t} else {\n\t\t\t \n\t\t\tnetdev_info(dev, \"Ethernet addr: %pM\\n\",\n\t\t\t\t    dev->dev_addr);\n\t\t}\n\n\t\tif (lp->phy_type == 0) {\n\t\t\tPRINTK(dev, \"No PHY found\\n\");\n\t\t} else if ((lp->phy_type & 0xfffffff0) == 0x0016f840) {\n\t\t\tPRINTK(dev, \"PHY LAN83C183 (LAN91C111 Internal)\\n\");\n\t\t} else if ((lp->phy_type & 0xfffffff0) == 0x02821c50) {\n\t\t\tPRINTK(dev, \"PHY LAN83C180\\n\");\n\t\t}\n\t}\n\nerr_out:\n#ifdef CONFIG_ARCH_PXA\n\tif (retval && lp->dma_chan)\n\t\tdma_release_channel(lp->dma_chan);\n#endif\n\treturn retval;\n}\n\nstatic int smc_enable_device(struct platform_device *pdev)\n{\n\tstruct net_device *ndev = platform_get_drvdata(pdev);\n\tstruct smc_local *lp = netdev_priv(ndev);\n\tunsigned long flags;\n\tunsigned char ecor, ecsr;\n\tvoid __iomem *addr;\n\tstruct resource * res;\n\n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"smc91x-attrib\");\n\tif (!res)\n\t\treturn 0;\n\n\t \n\taddr = ioremap(res->start, ATTRIB_SIZE);\n\tif (!addr)\n\t\treturn -ENOMEM;\n\n\t \n\tlocal_irq_save(flags);\n\tecor = readb(addr + (ECOR << SMC_IO_SHIFT)) & ~ECOR_RESET;\n\twriteb(ecor | ECOR_RESET, addr + (ECOR << SMC_IO_SHIFT));\n\treadb(addr + (ECOR << SMC_IO_SHIFT));\n\n\t \n\tudelay(100);\n\n\t \n\twriteb(ecor, addr + (ECOR << SMC_IO_SHIFT));\n\twriteb(ecor | ECOR_ENABLE, addr + (ECOR << SMC_IO_SHIFT));\n\n\t \n\tecsr = readb(addr + (ECSR << SMC_IO_SHIFT)) & ~ECSR_IOIS8;\n\tif (!SMC_16BIT(lp))\n\t\tecsr |= ECSR_IOIS8;\n\twriteb(ecsr, addr + (ECSR << SMC_IO_SHIFT));\n\tlocal_irq_restore(flags);\n\n\tiounmap(addr);\n\n\t \n\tmsleep(1);\n\n\treturn 0;\n}\n\nstatic int smc_request_attrib(struct platform_device *pdev,\n\t\t\t      struct net_device *ndev)\n{\n\tstruct resource * res = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"smc91x-attrib\");\n\tstruct smc_local *lp __maybe_unused = netdev_priv(ndev);\n\n\tif (!res)\n\t\treturn 0;\n\n\tif (!request_mem_region(res->start, ATTRIB_SIZE, CARDNAME))\n\t\treturn -EBUSY;\n\n\treturn 0;\n}\n\nstatic void smc_release_attrib(struct platform_device *pdev,\n\t\t\t       struct net_device *ndev)\n{\n\tstruct resource * res = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"smc91x-attrib\");\n\tstruct smc_local *lp __maybe_unused = netdev_priv(ndev);\n\n\tif (res)\n\t\trelease_mem_region(res->start, ATTRIB_SIZE);\n}\n\nstatic inline void smc_request_datacs(struct platform_device *pdev, struct net_device *ndev)\n{\n\tif (SMC_CAN_USE_DATACS) {\n\t\tstruct resource * res = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"smc91x-data32\");\n\t\tstruct smc_local *lp = netdev_priv(ndev);\n\n\t\tif (!res)\n\t\t\treturn;\n\n\t\tif(!request_mem_region(res->start, SMC_DATA_EXTENT, CARDNAME)) {\n\t\t\tnetdev_info(ndev, \"%s: failed to request datacs memory region.\\n\",\n\t\t\t\t    CARDNAME);\n\t\t\treturn;\n\t\t}\n\n\t\tlp->datacs = ioremap(res->start, SMC_DATA_EXTENT);\n\t}\n}\n\nstatic void smc_release_datacs(struct platform_device *pdev, struct net_device *ndev)\n{\n\tif (SMC_CAN_USE_DATACS) {\n\t\tstruct smc_local *lp = netdev_priv(ndev);\n\t\tstruct resource * res = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"smc91x-data32\");\n\n\t\tif (lp->datacs)\n\t\t\tiounmap(lp->datacs);\n\n\t\tlp->datacs = NULL;\n\n\t\tif (res)\n\t\t\trelease_mem_region(res->start, SMC_DATA_EXTENT);\n\t}\n}\n\nstatic const struct acpi_device_id smc91x_acpi_match[] = {\n\t{ \"LNRO0003\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(acpi, smc91x_acpi_match);\n\n#if IS_BUILTIN(CONFIG_OF)\nstatic const struct of_device_id smc91x_match[] = {\n\t{ .compatible = \"smsc,lan91c94\", },\n\t{ .compatible = \"smsc,lan91c111\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, smc91x_match);\n\n \nstatic int try_toggle_control_gpio(struct device *dev,\n\t\t\t\t   struct gpio_desc **desc,\n\t\t\t\t   const char *name, int index,\n\t\t\t\t   int value, unsigned int nsdelay)\n{\n\tstruct gpio_desc *gpio;\n\tenum gpiod_flags flags = value ? GPIOD_OUT_LOW : GPIOD_OUT_HIGH;\n\n\tgpio = devm_gpiod_get_index_optional(dev, name, index, flags);\n\tif (IS_ERR(gpio))\n\t\treturn PTR_ERR(gpio);\n\n\tif (gpio) {\n\t\tif (nsdelay)\n\t\t\tusleep_range(nsdelay, 2 * nsdelay);\n\t\tgpiod_set_value_cansleep(gpio, value);\n\t}\n\t*desc = gpio;\n\n\treturn 0;\n}\n#endif\n\n \nstatic int smc_drv_probe(struct platform_device *pdev)\n{\n\tstruct smc91x_platdata *pd = dev_get_platdata(&pdev->dev);\n\tconst struct of_device_id *match = NULL;\n\tstruct smc_local *lp;\n\tstruct net_device *ndev;\n\tstruct resource *res;\n\tunsigned int __iomem *addr;\n\tunsigned long irq_flags = SMC_IRQ_FLAGS;\n\tunsigned long irq_resflags;\n\tint ret;\n\n\tndev = alloc_etherdev(sizeof(struct smc_local));\n\tif (!ndev) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tSET_NETDEV_DEV(ndev, &pdev->dev);\n\n\t \n\n\tlp = netdev_priv(ndev);\n\tlp->cfg.flags = 0;\n\n\tif (pd) {\n\t\tmemcpy(&lp->cfg, pd, sizeof(lp->cfg));\n\t\tlp->io_shift = SMC91X_IO_SHIFT(lp->cfg.flags);\n\n\t\tif (!SMC_8BIT(lp) && !SMC_16BIT(lp)) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"at least one of 8-bit or 16-bit access support is required.\\n\");\n\t\t\tret = -ENXIO;\n\t\t\tgoto out_free_netdev;\n\t\t}\n\t}\n\n#if IS_BUILTIN(CONFIG_OF)\n\tmatch = of_match_device(of_match_ptr(smc91x_match), &pdev->dev);\n\tif (match) {\n\t\tu32 val;\n\n\t\t \n\t\tret = try_toggle_control_gpio(&pdev->dev, &lp->power_gpio,\n\t\t\t\t\t      \"power\", 0, 0, 100);\n\t\tif (ret)\n\t\t\tgoto out_free_netdev;\n\n\t\t \n\t\tret = try_toggle_control_gpio(&pdev->dev, &lp->reset_gpio,\n\t\t\t\t\t      \"reset\", 0, 0, 100);\n\t\tif (ret)\n\t\t\tgoto out_free_netdev;\n\n\t\t \n\t\tif (lp->reset_gpio)\n\t\t\tusleep_range(750, 1000);\n\n\t\t \n\t\tif (!device_property_read_u32(&pdev->dev, \"reg-io-width\",\n\t\t\t\t\t      &val)) {\n\t\t\tif (val & 1)\n\t\t\t\tlp->cfg.flags |= SMC91X_USE_8BIT;\n\t\t\tif ((val == 0) || (val & 2))\n\t\t\t\tlp->cfg.flags |= SMC91X_USE_16BIT;\n\t\t\tif (val & 4)\n\t\t\t\tlp->cfg.flags |= SMC91X_USE_32BIT;\n\t\t} else {\n\t\t\tlp->cfg.flags |= SMC91X_USE_16BIT;\n\t\t}\n\t\tif (!device_property_read_u32(&pdev->dev, \"reg-shift\",\n\t\t\t\t\t      &val))\n\t\t\tlp->io_shift = val;\n\t\tlp->cfg.pxa_u16_align4 =\n\t\t\tdevice_property_read_bool(&pdev->dev, \"pxa-u16-align4\");\n\t}\n#endif\n\n\tif (!pd && !match) {\n\t\tlp->cfg.flags |= (SMC_CAN_USE_8BIT)  ? SMC91X_USE_8BIT  : 0;\n\t\tlp->cfg.flags |= (SMC_CAN_USE_16BIT) ? SMC91X_USE_16BIT : 0;\n\t\tlp->cfg.flags |= (SMC_CAN_USE_32BIT) ? SMC91X_USE_32BIT : 0;\n\t\tlp->cfg.flags |= (nowait) ? SMC91X_NOWAIT : 0;\n\t}\n\n\tif (!lp->cfg.leda && !lp->cfg.ledb) {\n\t\tlp->cfg.leda = RPC_LSA_DEFAULT;\n\t\tlp->cfg.ledb = RPC_LSB_DEFAULT;\n\t}\n\n\tndev->dma = (unsigned char)-1;\n\n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"smc91x-regs\");\n\tif (!res)\n\t\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res) {\n\t\tret = -ENODEV;\n\t\tgoto out_free_netdev;\n\t}\n\n\n\tif (!request_mem_region(res->start, SMC_IO_EXTENT, CARDNAME)) {\n\t\tret = -EBUSY;\n\t\tgoto out_free_netdev;\n\t}\n\n\tndev->irq = platform_get_irq(pdev, 0);\n\tif (ndev->irq < 0) {\n\t\tret = ndev->irq;\n\t\tgoto out_release_io;\n\t}\n\t \n\tirq_resflags = irqd_get_trigger_type(irq_get_irq_data(ndev->irq));\n\tif (irq_flags == -1 || irq_resflags & IRQF_TRIGGER_MASK)\n\t\tirq_flags = irq_resflags & IRQF_TRIGGER_MASK;\n\n\tret = smc_request_attrib(pdev, ndev);\n\tif (ret)\n\t\tgoto out_release_io;\n#if defined(CONFIG_ASSABET_NEPONSET)\n\tif (machine_is_assabet() && machine_has_neponset())\n\t\tneponset_ncr_set(NCR_ENET_OSC_EN);\n#endif\n\tplatform_set_drvdata(pdev, ndev);\n\tret = smc_enable_device(pdev);\n\tif (ret)\n\t\tgoto out_release_attrib;\n\n\taddr = ioremap(res->start, SMC_IO_EXTENT);\n\tif (!addr) {\n\t\tret = -ENOMEM;\n\t\tgoto out_release_attrib;\n\t}\n\n#ifdef CONFIG_ARCH_PXA\n\t{\n\t\tstruct smc_local *lp = netdev_priv(ndev);\n\t\tlp->device = &pdev->dev;\n\t\tlp->physaddr = res->start;\n\n\t}\n#endif\n\n\tret = smc_probe(ndev, addr, irq_flags);\n\tif (ret != 0)\n\t\tgoto out_iounmap;\n\n\tsmc_request_datacs(pdev, ndev);\n\n\treturn 0;\n\n out_iounmap:\n\tiounmap(addr);\n out_release_attrib:\n\tsmc_release_attrib(pdev, ndev);\n out_release_io:\n\trelease_mem_region(res->start, SMC_IO_EXTENT);\n out_free_netdev:\n\tfree_netdev(ndev);\n out:\n\tpr_info(\"%s: not found (%d).\\n\", CARDNAME, ret);\n\n\treturn ret;\n}\n\nstatic int smc_drv_remove(struct platform_device *pdev)\n{\n\tstruct net_device *ndev = platform_get_drvdata(pdev);\n\tstruct smc_local *lp = netdev_priv(ndev);\n\tstruct resource *res;\n\n\tunregister_netdev(ndev);\n\n\tfree_irq(ndev->irq, ndev);\n\n#ifdef CONFIG_ARCH_PXA\n\tif (lp->dma_chan)\n\t\tdma_release_channel(lp->dma_chan);\n#endif\n\tiounmap(lp->base);\n\n\tsmc_release_datacs(pdev,ndev);\n\tsmc_release_attrib(pdev,ndev);\n\n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"smc91x-regs\");\n\tif (!res)\n\t\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\trelease_mem_region(res->start, SMC_IO_EXTENT);\n\n\tfree_netdev(ndev);\n\n\treturn 0;\n}\n\nstatic int smc_drv_suspend(struct device *dev)\n{\n\tstruct net_device *ndev = dev_get_drvdata(dev);\n\n\tif (ndev) {\n\t\tif (netif_running(ndev)) {\n\t\t\tnetif_device_detach(ndev);\n\t\t\tsmc_shutdown(ndev);\n\t\t\tsmc_phy_powerdown(ndev);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int smc_drv_resume(struct device *dev)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct net_device *ndev = platform_get_drvdata(pdev);\n\n\tif (ndev) {\n\t\tstruct smc_local *lp = netdev_priv(ndev);\n\t\tsmc_enable_device(pdev);\n\t\tif (netif_running(ndev)) {\n\t\t\tsmc_reset(ndev);\n\t\t\tsmc_enable(ndev);\n\t\t\tif (lp->phy_type != 0)\n\t\t\t\tsmc_phy_configure(&lp->phy_configure);\n\t\t\tnetif_device_attach(ndev);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops smc_drv_pm_ops = {\n\t.suspend\t= smc_drv_suspend,\n\t.resume\t\t= smc_drv_resume,\n};\n\nstatic struct platform_driver smc_driver = {\n\t.probe\t\t= smc_drv_probe,\n\t.remove\t\t= smc_drv_remove,\n\t.driver\t\t= {\n\t\t.name\t= CARDNAME,\n\t\t.pm\t= &smc_drv_pm_ops,\n\t\t.of_match_table   = of_match_ptr(smc91x_match),\n\t\t.acpi_match_table = smc91x_acpi_match,\n\t},\n};\n\nmodule_platform_driver(smc_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}