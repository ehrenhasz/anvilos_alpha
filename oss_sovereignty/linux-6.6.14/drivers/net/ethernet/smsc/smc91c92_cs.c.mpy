{
  "module_name": "smc91c92_cs.c",
  "hash_id": "df5ef7a22be906fa2e153dd48f781da063287b895543cd05c4c78ed28d3cf8f0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/smsc/smc91c92_cs.c",
  "human_readable_source": " \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/timer.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n#include <linux/crc32.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/skbuff.h>\n#include <linux/if_arp.h>\n#include <linux/ioport.h>\n#include <linux/ethtool.h>\n#include <linux/mii.h>\n#include <linux/jiffies.h>\n#include <linux/firmware.h>\n\n#include <pcmcia/cistpl.h>\n#include <pcmcia/cisreg.h>\n#include <pcmcia/ciscode.h>\n#include <pcmcia/ds.h>\n#include <pcmcia/ss.h>\n\n#include <asm/io.h>\n#include <linux/uaccess.h>\n\n \n\nstatic const char *if_names[] = { \"auto\", \"10baseT\", \"10base2\"};\n\n \n#define FIRMWARE_NAME\t\t\"ositech/Xilinx7OD.bin\"\n\n \n\nMODULE_DESCRIPTION(\"SMC 91c92 series PCMCIA ethernet driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_FIRMWARE(FIRMWARE_NAME);\n\n#define INT_MODULE_PARM(n, v) static int n = v; module_param(n, int, 0)\n\n \nINT_MODULE_PARM(if_port, 0);\n\n\n#define DRV_NAME\t\"smc91c92_cs\"\n#define DRV_VERSION\t\"1.123\"\n\n \n\n \n\n \n#define TX_TIMEOUT\t\t((400*HZ)/1000)\n\n \n#define INTR_WORK\t\t4\n\n \n#define MEMORY_WAIT_TIME       \t8\n\nstruct smc_private {\n\tstruct pcmcia_device\t*p_dev;\n    spinlock_t\t\t\tlock;\n    u_short\t\t\tmanfid;\n    u_short\t\t\tcardid;\n\n    struct sk_buff\t\t*saved_skb;\n    int\t\t\t\tpackets_waiting;\n    void\t\t\t__iomem *base;\n    u_short\t\t\tcfg;\n    struct timer_list\t\tmedia;\n    int\t\t\t\twatchdog, tx_err;\n    u_short\t\t\tmedia_status;\n    u_short\t\t\tfast_poll;\n    u_short\t\t\tlink_status;\n    struct mii_if_info\t\tmii_if;\n    int\t\t\t\tduplex;\n    int\t\t\t\trx_ovrn;\n    unsigned long\t\tlast_rx;\n};\n\n \n#define MEGAHERTZ_ISR\t\t0x0380\n\n \n#define MOT_LAN\t\t\t0x0000\n#define MOT_UART\t\t0x0020\n#define MOT_EEPROM\t\t0x20\n\n#define MOT_NORMAL \\\n(COR_LEVEL_REQ | COR_FUNC_ENA | COR_ADDR_DECODE | COR_IREQ_ENA)\n\n \n#define OSITECH_AUI_CTL\t\t0x0c\n#define OSITECH_PWRDOWN\t\t0x0d\n#define OSITECH_RESET\t\t0x0e\n#define OSITECH_ISR\t\t0x0f\n#define OSITECH_AUI_PWR\t\t0x0c\n#define OSITECH_RESET_ISR\t0x0e\n\n#define OSI_AUI_PWR\t\t0x40\n#define OSI_LAN_PWRDOWN\t\t0x02\n#define OSI_MODEM_PWRDOWN\t0x01\n#define OSI_LAN_RESET\t\t0x02\n#define OSI_MODEM_RESET\t\t0x01\n\n \n#define\tBANK_SELECT\t\t14\t\t \n#define SMC_SELECT_BANK(x)  { outw(x, ioaddr + BANK_SELECT); }\n\n \n#define\tTCR \t\t0\t \n#define\t TCR_CLEAR\t0\t \n#define  TCR_ENABLE\t0x0001\t \n#define\t TCR_PAD_EN\t0x0080\t \n#define  TCR_MONCSN\t0x0400   \n#define  TCR_FDUPLX\t0x0800   \n#define\t TCR_NORMAL TCR_ENABLE | TCR_PAD_EN\n\n#define EPH\t\t2\t \n#define  EPH_TX_SUC\t0x0001\n#define  EPH_SNGLCOL\t0x0002\n#define  EPH_MULCOL\t0x0004\n#define  EPH_LTX_MULT\t0x0008\n#define  EPH_16COL\t0x0010\n#define  EPH_SQET\t0x0020\n#define  EPH_LTX_BRD\t0x0040\n#define  EPH_TX_DEFR\t0x0080\n#define  EPH_LAT_COL\t0x0200\n#define  EPH_LOST_CAR\t0x0400\n#define  EPH_EXC_DEF\t0x0800\n#define  EPH_CTR_ROL\t0x1000\n#define  EPH_RX_OVRN\t0x2000\n#define  EPH_LINK_OK\t0x4000\n#define  EPH_TX_UNRN\t0x8000\n#define MEMINFO\t\t8\t \n#define MEMCFG\t\t10\t \n\n \n#define CONFIG\t\t\t0\n#define  CFG_MII_SELECT\t\t0x8000\t \n#define  CFG_NO_WAIT\t\t0x1000\n#define  CFG_FULL_STEP\t\t0x0400\n#define  CFG_SET_SQLCH\t\t0x0200\n#define  CFG_AUI_SELECT\t \t0x0100\n#define  CFG_16BIT\t\t0x0080\n#define  CFG_DIS_LINK\t\t0x0040\n#define  CFG_STATIC\t\t0x0030\n#define  CFG_IRQ_SEL_1\t\t0x0004\n#define  CFG_IRQ_SEL_0\t\t0x0002\n#define BASE_ADDR\t\t2\n#define\tADDR0\t\t\t4\n#define\tGENERAL\t\t\t10\n#define\tCONTROL\t\t\t12\n#define  CTL_STORE\t\t0x0001\n#define  CTL_RELOAD\t\t0x0002\n#define  CTL_EE_SELECT\t\t0x0004\n#define  CTL_TE_ENABLE\t\t0x0020\n#define  CTL_CR_ENABLE\t\t0x0040\n#define  CTL_LE_ENABLE\t\t0x0080\n#define  CTL_AUTO_RELEASE\t0x0800\n#define\t CTL_POWERDOWN\t\t0x2000\n\n \n#define MMU_CMD\t\t0\n#define\t MC_ALLOC\t0x20  \t \n#define\t MC_RESET\t0x40\n#define  MC_RELEASE  \t0x80  \t \n#define  MC_FREEPKT  \t0xA0  \t \n#define  MC_ENQUEUE\t0xC0 \t \n#define\tPNR_ARR\t\t2\n#define FIFO_PORTS\t4\n#define  FP_RXEMPTY\t0x8000\n#define\tPOINTER\t\t6\n#define  PTR_AUTO_INC\t0x0040\n#define  PTR_READ\t0x2000\n#define\t PTR_AUTOINC \t0x4000\n#define\t PTR_RCV\t0x8000\n#define\tDATA_1\t\t8\n#define\tINTERRUPT\t12\n#define  IM_RCV_INT\t\t0x1\n#define\t IM_TX_INT\t\t0x2\n#define\t IM_TX_EMPTY_INT\t0x4\n#define\t IM_ALLOC_INT\t\t0x8\n#define\t IM_RX_OVRN_INT\t\t0x10\n#define\t IM_EPH_INT\t\t0x20\n\n#define\tRCR\t\t4\nenum RxCfg { RxAllMulti = 0x0004, RxPromisc = 0x0002,\n\t     RxEnable = 0x0100, RxStripCRC = 0x0200};\n#define  RCR_SOFTRESET\t0x8000 \t \n#define\t RCR_STRIP_CRC\t0x200\t \n#define  RCR_ENABLE\t0x100\t \n#define  RCR_ALMUL\t0x4 \t \n#define\t RCR_PROMISC\t0x2\t \n\n \n#define\t RCR_NORMAL\t(RCR_STRIP_CRC | RCR_ENABLE)\n#define  RCR_CLEAR\t0x0\t\t \n#define\tCOUNTER\t\t6\n\n \n#define\tMULTICAST0\t0\n#define\tMULTICAST2\t2\n#define\tMULTICAST4\t4\n#define\tMULTICAST6\t6\n#define MGMT    \t8\n#define REVISION\t0x0a\n\n \n#define TS_SUCCESS 0x0001\n#define TS_16COL   0x0010\n#define TS_LATCOL  0x0200\n#define TS_LOSTCAR 0x0400\n\n \n#define RS_ALGNERR\t0x8000\n#define RS_BADCRC\t0x2000\n#define RS_ODDFRAME\t0x1000\n#define RS_TOOLONG\t0x0800\n#define RS_TOOSHORT\t0x0400\n#define RS_MULTICAST\t0x0001\n#define RS_ERRORS\t(RS_ALGNERR | RS_BADCRC | RS_TOOLONG | RS_TOOSHORT)\n\n#define set_bits(v, p) outw(inw(p)|(v), (p))\n#define mask_bits(v, p) outw(inw(p)&(v), (p))\n\n \n\nstatic void smc91c92_detach(struct pcmcia_device *p_dev);\nstatic int smc91c92_config(struct pcmcia_device *link);\nstatic void smc91c92_release(struct pcmcia_device *link);\n\nstatic int smc_open(struct net_device *dev);\nstatic int smc_close(struct net_device *dev);\nstatic int smc_ioctl(struct net_device *dev, struct ifreq *rq, int cmd);\nstatic void smc_tx_timeout(struct net_device *dev, unsigned int txqueue);\nstatic netdev_tx_t smc_start_xmit(struct sk_buff *skb,\n\t\t\t\t\tstruct net_device *dev);\nstatic irqreturn_t smc_interrupt(int irq, void *dev_id);\nstatic void smc_rx(struct net_device *dev);\nstatic void set_rx_mode(struct net_device *dev);\nstatic int s9k_config(struct net_device *dev, struct ifmap *map);\nstatic void smc_set_xcvr(struct net_device *dev, int if_port);\nstatic void smc_reset(struct net_device *dev);\nstatic void media_check(struct timer_list *t);\nstatic void mdio_sync(unsigned int addr);\nstatic int mdio_read(struct net_device *dev, int phy_id, int loc);\nstatic void mdio_write(struct net_device *dev, int phy_id, int loc, int value);\nstatic int smc_link_ok(struct net_device *dev);\nstatic const struct ethtool_ops ethtool_ops;\n\nstatic const struct net_device_ops smc_netdev_ops = {\n\t.ndo_open\t\t= smc_open,\n\t.ndo_stop\t\t= smc_close,\n\t.ndo_start_xmit\t\t= smc_start_xmit,\n\t.ndo_tx_timeout \t= smc_tx_timeout,\n\t.ndo_set_config \t= s9k_config,\n\t.ndo_set_rx_mode\t= set_rx_mode,\n\t.ndo_eth_ioctl\t\t= smc_ioctl,\n\t.ndo_set_mac_address \t= eth_mac_addr,\n\t.ndo_validate_addr\t= eth_validate_addr,\n};\n\nstatic int smc91c92_probe(struct pcmcia_device *link)\n{\n    struct smc_private *smc;\n    struct net_device *dev;\n\n    dev_dbg(&link->dev, \"smc91c92_attach()\\n\");\n\n     \n    dev = alloc_etherdev(sizeof(struct smc_private));\n    if (!dev)\n\treturn -ENOMEM;\n    smc = netdev_priv(dev);\n    smc->p_dev = link;\n    link->priv = dev;\n\n    spin_lock_init(&smc->lock);\n\n     \n    dev->netdev_ops = &smc_netdev_ops;\n    dev->ethtool_ops = &ethtool_ops;\n    dev->watchdog_timeo = TX_TIMEOUT;\n\n    smc->mii_if.dev = dev;\n    smc->mii_if.mdio_read = mdio_read;\n    smc->mii_if.mdio_write = mdio_write;\n    smc->mii_if.phy_id_mask = 0x1f;\n    smc->mii_if.reg_num_mask = 0x1f;\n\n    return smc91c92_config(link);\n}  \n\nstatic void smc91c92_detach(struct pcmcia_device *link)\n{\n    struct net_device *dev = link->priv;\n\n    dev_dbg(&link->dev, \"smc91c92_detach\\n\");\n\n    unregister_netdev(dev);\n\n    smc91c92_release(link);\n\n    free_netdev(dev);\n}  \n\n \n\nstatic int cvt_ascii_address(struct net_device *dev, char *s)\n{\n    u8 mac[ETH_ALEN];\n    int i, j, da, c;\n\n    if (strlen(s) != 12)\n\treturn -1;\n    for (i = 0; i < 6; i++) {\n\tda = 0;\n\tfor (j = 0; j < 2; j++) {\n\t    c = *s++;\n\t    da <<= 4;\n\t    da += ((c >= '0') && (c <= '9')) ?\n\t\t(c - '0') : ((c & 0x0f) + 9);\n\t}\n\tmac[i] = da;\n    }\n    eth_hw_addr_set(dev, mac);\n    return 0;\n}\n\n \n\nstatic int mhz_3288_power(struct pcmcia_device *link)\n{\n    struct net_device *dev = link->priv;\n    struct smc_private *smc = netdev_priv(dev);\n    u_char tmp;\n\n     \n    readb(smc->base+MEGAHERTZ_ISR);\n    udelay(5);\n    readb(smc->base+MEGAHERTZ_ISR);\n\n     \n    mdelay(200);\n\n     \n    tmp = readb(smc->base + link->config_base + CISREG_COR);\n    udelay(5);\n    writeb(tmp, smc->base + link->config_base + CISREG_COR);\n\n    return 0;\n}\n\nstatic int mhz_mfc_config_check(struct pcmcia_device *p_dev, void *priv_data)\n{\n\tint k;\n\tp_dev->io_lines = 16;\n\tp_dev->resource[1]->start = p_dev->resource[0]->start;\n\tp_dev->resource[1]->end = 8;\n\tp_dev->resource[1]->flags &= ~IO_DATA_PATH_WIDTH;\n\tp_dev->resource[1]->flags |= IO_DATA_PATH_WIDTH_8;\n\tp_dev->resource[0]->end = 16;\n\tp_dev->resource[0]->flags &= ~IO_DATA_PATH_WIDTH;\n\tp_dev->resource[0]->flags |= IO_DATA_PATH_WIDTH_AUTO;\n\tfor (k = 0; k < 0x400; k += 0x10) {\n\t\tif (k & 0x80)\n\t\t\tcontinue;\n\t\tp_dev->resource[0]->start = k ^ 0x300;\n\t\tif (!pcmcia_request_io(p_dev))\n\t\t\treturn 0;\n\t}\n\treturn -ENODEV;\n}\n\nstatic int mhz_mfc_config(struct pcmcia_device *link)\n{\n    struct net_device *dev = link->priv;\n    struct smc_private *smc = netdev_priv(dev);\n    unsigned int offset;\n    int i;\n\n    link->config_flags |= CONF_ENABLE_SPKR | CONF_ENABLE_IRQ |\n\t    CONF_AUTO_SET_IO;\n\n     \n    if (pcmcia_loop_config(link, mhz_mfc_config_check, NULL))\n\t    return -ENODEV;\n\n    dev->base_addr = link->resource[0]->start;\n\n     \n    link->resource[2]->flags = WIN_DATA_WIDTH_8|WIN_MEMORY_TYPE_AM|WIN_ENABLE;\n    link->resource[2]->start = link->resource[2]->end = 0;\n    i = pcmcia_request_window(link, link->resource[2], 0);\n    if (i != 0)\n\t    return -ENODEV;\n\n    smc->base = ioremap(link->resource[2]->start,\n\t\t    resource_size(link->resource[2]));\n    offset = (smc->manfid == MANFID_MOTOROLA) ? link->config_base : 0;\n    i = pcmcia_map_mem_page(link, link->resource[2], offset);\n    if ((i == 0) &&\n\t(smc->manfid == MANFID_MEGAHERTZ) &&\n\t(smc->cardid == PRODID_MEGAHERTZ_EM3288))\n\t    mhz_3288_power(link);\n\n    return 0;\n}\n\nstatic int pcmcia_get_versmac(struct pcmcia_device *p_dev,\n\t\t\t      tuple_t *tuple,\n\t\t\t      void *priv)\n{\n\tstruct net_device *dev = priv;\n\tcisparse_t parse;\n\tu8 *buf;\n\n\tif (pcmcia_parse_tuple(tuple, &parse))\n\t\treturn -EINVAL;\n\n\tbuf = parse.version_1.str + parse.version_1.ofs[3];\n\n\tif ((parse.version_1.ns > 3) && (cvt_ascii_address(dev, buf) == 0))\n\t\treturn 0;\n\n\treturn -EINVAL;\n};\n\nstatic int mhz_setup(struct pcmcia_device *link)\n{\n    struct net_device *dev = link->priv;\n    size_t len;\n    u8 *buf;\n    int rc;\n\n     \n    if ((link->prod_id[3]) &&\n\t(cvt_ascii_address(dev, link->prod_id[3]) == 0))\n\t    return 0;\n\n     \n     \n    if (!pcmcia_loop_tuple(link, CISTPL_VERS_1, pcmcia_get_versmac, dev))\n\t    return 0;\n\n     \n    rc = -1;\n    len = pcmcia_get_tuple(link, 0x81, &buf);\n    if (buf && len >= 13) {\n\t    buf[12] = '\\0';\n\t    if (cvt_ascii_address(dev, buf) == 0)\n\t\t    rc = 0;\n    }\n    kfree(buf);\n\n    return rc;\n};\n\n \n\nstatic void mot_config(struct pcmcia_device *link)\n{\n    struct net_device *dev = link->priv;\n    struct smc_private *smc = netdev_priv(dev);\n    unsigned int ioaddr = dev->base_addr;\n    unsigned int iouart = link->resource[1]->start;\n\n     \n    writeb(iouart & 0xff,        smc->base + MOT_UART + CISREG_IOBASE_0);\n    writeb((iouart >> 8) & 0xff, smc->base + MOT_UART + CISREG_IOBASE_1);\n    writeb(MOT_NORMAL,           smc->base + MOT_UART + CISREG_COR);\n\n     \n    writeb(ioaddr & 0xff,        smc->base + MOT_LAN + CISREG_IOBASE_0);\n    writeb((ioaddr >> 8) & 0xff, smc->base + MOT_LAN + CISREG_IOBASE_1);\n    writeb(MOT_NORMAL,           smc->base + MOT_LAN + CISREG_COR);\n\n     \n    mdelay(100);\n}\n\nstatic int mot_setup(struct pcmcia_device *link)\n{\n    struct net_device *dev = link->priv;\n    unsigned int ioaddr = dev->base_addr;\n    int i, wait, loop;\n    u8 mac[ETH_ALEN];\n    u_int addr;\n\n     \n\n    for (i = 0; i < 3; i++) {\n\tSMC_SELECT_BANK(2);\n\toutw(MOT_EEPROM + i, ioaddr + POINTER);\n\tSMC_SELECT_BANK(1);\n\toutw((CTL_RELOAD | CTL_EE_SELECT), ioaddr + CONTROL);\n\n\tfor (loop = wait = 0; loop < 200; loop++) {\n\t    udelay(10);\n\t    wait = ((CTL_RELOAD | CTL_STORE) & inw(ioaddr + CONTROL));\n\t    if (wait == 0) break;\n\t}\n\t\n\tif (wait)\n\t    return -1;\n\t\n\taddr = inw(ioaddr + GENERAL);\n\tmac[2*i]   = addr & 0xff;\n\tmac[2*i+1] = (addr >> 8) & 0xff;\n    }\n    eth_hw_addr_set(dev, mac);\n\n    return 0;\n}\n\n \n\nstatic int smc_configcheck(struct pcmcia_device *p_dev, void *priv_data)\n{\n\tp_dev->resource[0]->end = 16;\n\tp_dev->resource[0]->flags &= ~IO_DATA_PATH_WIDTH;\n\tp_dev->resource[0]->flags |= IO_DATA_PATH_WIDTH_AUTO;\n\n\treturn pcmcia_request_io(p_dev);\n}\n\nstatic int smc_config(struct pcmcia_device *link)\n{\n    struct net_device *dev = link->priv;\n    int i;\n\n    link->config_flags |= CONF_ENABLE_IRQ | CONF_AUTO_SET_IO;\n\n    i = pcmcia_loop_config(link, smc_configcheck, NULL);\n    if (!i)\n\t    dev->base_addr = link->resource[0]->start;\n\n    return i;\n}\n\n\nstatic int smc_setup(struct pcmcia_device *link)\n{\n    struct net_device *dev = link->priv;\n\n     \n    if (!pcmcia_get_mac_from_cis(link, dev))\n\t    return 0;\n\n     \n    if (link->prod_id[2]) {\n\t    if (cvt_ascii_address(dev, link->prod_id[2]) == 0)\n\t\t    return 0;\n    }\n    return -1;\n}\n\n \n\nstatic int osi_config(struct pcmcia_device *link)\n{\n    struct net_device *dev = link->priv;\n    static const unsigned int com[4] = { 0x3f8, 0x2f8, 0x3e8, 0x2e8 };\n    int i, j;\n\n    link->config_flags |= CONF_ENABLE_SPKR | CONF_ENABLE_IRQ;\n    link->resource[0]->end = 64;\n    link->resource[1]->flags |= IO_DATA_PATH_WIDTH_8;\n    link->resource[1]->end = 8;\n\n     \n    link->io_lines = 16;\n    link->config_index = 0x23;\n\n    for (i = j = 0; j < 4; j++) {\n\tlink->resource[1]->start = com[j];\n\ti = pcmcia_request_io(link);\n\tif (i == 0)\n\t\tbreak;\n    }\n    if (i != 0) {\n\t \n\tlink->config_index = 0x03;\n\tlink->resource[1]->end = 0;\n\ti = pcmcia_request_io(link);\n    }\n    dev->base_addr = link->resource[0]->start + 0x10;\n    return i;\n}\n\nstatic int osi_load_firmware(struct pcmcia_device *link)\n{\n\tconst struct firmware *fw;\n\tint i, err;\n\n\terr = request_firmware(&fw, FIRMWARE_NAME, &link->dev);\n\tif (err) {\n\t\tpr_err(\"Failed to load firmware \\\"%s\\\"\\n\", FIRMWARE_NAME);\n\t\treturn err;\n\t}\n\n\t \n\tfor (i = 0; i < fw->size; i++) {\n\t    outb(fw->data[i], link->resource[0]->start + 2);\n\t    udelay(50);\n\t}\n\trelease_firmware(fw);\n\treturn err;\n}\n\nstatic int pcmcia_osi_mac(struct pcmcia_device *p_dev,\n\t\t\t  tuple_t *tuple,\n\t\t\t  void *priv)\n{\n\tstruct net_device *dev = priv;\n\n\tif (tuple->TupleDataLen < 8)\n\t\treturn -EINVAL;\n\tif (tuple->TupleData[0] != 0x04)\n\t\treturn -EINVAL;\n\n\teth_hw_addr_set(dev, &tuple->TupleData[2]);\n\treturn 0;\n};\n\n\nstatic int osi_setup(struct pcmcia_device *link, u_short manfid, u_short cardid)\n{\n    struct net_device *dev = link->priv;\n    int rc;\n\n     \n    if (pcmcia_loop_tuple(link, 0x90, pcmcia_osi_mac, dev))\n\t    return -1;\n\n    if (((manfid == MANFID_OSITECH) &&\n\t (cardid == PRODID_OSITECH_SEVEN)) ||\n\t((manfid == MANFID_PSION) &&\n\t (cardid == PRODID_PSION_NET100))) {\n\trc = osi_load_firmware(link);\n\tif (rc)\n\t\treturn rc;\n    } else if (manfid == MANFID_OSITECH) {\n\t \n\tset_bits(0x300, link->resource[0]->start + OSITECH_AUI_PWR);\n\t \n\tset_bits(0x300, link->resource[0]->start + OSITECH_RESET_ISR);\n\tdev_dbg(&link->dev, \"AUI/PWR: %4.4x RESET/ISR: %4.4x\\n\",\n\t      inw(link->resource[0]->start + OSITECH_AUI_PWR),\n\t      inw(link->resource[0]->start + OSITECH_RESET_ISR));\n    }\n    return 0;\n}\n\nstatic int smc91c92_suspend(struct pcmcia_device *link)\n{\n\tstruct net_device *dev = link->priv;\n\n\tif (link->open)\n\t\tnetif_device_detach(dev);\n\n\treturn 0;\n}\n\nstatic int smc91c92_resume(struct pcmcia_device *link)\n{\n\tstruct net_device *dev = link->priv;\n\tstruct smc_private *smc = netdev_priv(dev);\n\tint i;\n\n\tif ((smc->manfid == MANFID_MEGAHERTZ) &&\n\t    (smc->cardid == PRODID_MEGAHERTZ_EM3288))\n\t\tmhz_3288_power(link);\n\tif (smc->manfid == MANFID_MOTOROLA)\n\t\tmot_config(link);\n\tif ((smc->manfid == MANFID_OSITECH) &&\n\t    (smc->cardid != PRODID_OSITECH_SEVEN)) {\n\t\t \n\t\tset_bits(0x0300, dev->base_addr-0x10+OSITECH_AUI_PWR);\n\t\tset_bits(0x0300, dev->base_addr-0x10+OSITECH_RESET_ISR);\n\t}\n\tif (((smc->manfid == MANFID_OSITECH) &&\n\t     (smc->cardid == PRODID_OSITECH_SEVEN)) ||\n\t    ((smc->manfid == MANFID_PSION) &&\n\t     (smc->cardid == PRODID_PSION_NET100))) {\n\t\ti = osi_load_firmware(link);\n\t\tif (i) {\n\t\t\tnetdev_err(dev, \"Failed to load firmware\\n\");\n\t\t\treturn i;\n\t\t}\n\t}\n\tif (link->open) {\n\t\tsmc_reset(dev);\n\t\tnetif_device_attach(dev);\n\t}\n\n\treturn 0;\n}\n\n\n \n\nstatic int check_sig(struct pcmcia_device *link)\n{\n    struct net_device *dev = link->priv;\n    unsigned int ioaddr = dev->base_addr;\n    int width;\n    u_short s;\n\n    SMC_SELECT_BANK(1);\n    if (inw(ioaddr + BANK_SELECT) >> 8 != 0x33) {\n\t \n\toutw(0, ioaddr + CONTROL);\n\tmdelay(55);\n    }\n\n     \n    width = (link->resource[0]->flags == IO_DATA_PATH_WIDTH_AUTO);\n    s = inb(ioaddr + CONFIG);\n    if (width)\n\ts |= CFG_16BIT;\n    else\n\ts &= ~CFG_16BIT;\n    outb(s, ioaddr + CONFIG);\n\n     \n    s = inw(ioaddr + BASE_ADDR);\n    if ((inw(ioaddr + BANK_SELECT) >> 8 == 0x33) &&\n\t((s >> 8) != (s & 0xff))) {\n\tSMC_SELECT_BANK(3);\n\ts = inw(ioaddr + REVISION);\n\treturn s & 0xff;\n    }\n\n    if (width) {\n\t    netdev_info(dev, \"using 8-bit IO window\\n\");\n\n\t    smc91c92_suspend(link);\n\t    pcmcia_fixup_iowidth(link);\n\t    smc91c92_resume(link);\n\t    return check_sig(link);\n    }\n    return -ENODEV;\n}\n\nstatic int smc91c92_config(struct pcmcia_device *link)\n{\n    struct net_device *dev = link->priv;\n    struct smc_private *smc = netdev_priv(dev);\n    char *name;\n    int i, rev, j = 0;\n    unsigned int ioaddr;\n    u_long mir;\n\n    dev_dbg(&link->dev, \"smc91c92_config\\n\");\n\n    smc->manfid = link->manf_id;\n    smc->cardid = link->card_id;\n\n    if ((smc->manfid == MANFID_OSITECH) &&\n\t(smc->cardid != PRODID_OSITECH_SEVEN)) {\n\ti = osi_config(link);\n    } else if ((smc->manfid == MANFID_MOTOROLA) ||\n\t       ((smc->manfid == MANFID_MEGAHERTZ) &&\n\t\t((smc->cardid == PRODID_MEGAHERTZ_VARIOUS) ||\n\t\t (smc->cardid == PRODID_MEGAHERTZ_EM3288)))) {\n\ti = mhz_mfc_config(link);\n    } else {\n\ti = smc_config(link);\n    }\n    if (i)\n\t    goto config_failed;\n\n    i = pcmcia_request_irq(link, smc_interrupt);\n    if (i)\n\t    goto config_failed;\n    i = pcmcia_enable_device(link);\n    if (i)\n\t    goto config_failed;\n\n    if (smc->manfid == MANFID_MOTOROLA)\n\tmot_config(link);\n\n    dev->irq = link->irq;\n\n    if ((if_port >= 0) && (if_port <= 2))\n\tdev->if_port = if_port;\n    else\n\tdev_notice(&link->dev, \"invalid if_port requested\\n\");\n\n    switch (smc->manfid) {\n    case MANFID_OSITECH:\n    case MANFID_PSION:\n\ti = osi_setup(link, smc->manfid, smc->cardid); break;\n    case MANFID_SMC:\n    case MANFID_NEW_MEDIA:\n\ti = smc_setup(link); break;\n    case 0x128:  \n    case MANFID_MEGAHERTZ:\n\ti = mhz_setup(link); break;\n    case MANFID_MOTOROLA:\n    default:  \n\ti = mot_setup(link); break;\n    }\n\n    if (i != 0) {\n\tdev_notice(&link->dev, \"Unable to find hardware address.\\n\");\n\tgoto config_failed;\n    }\n\n    smc->duplex = 0;\n    smc->rx_ovrn = 0;\n\n    rev = check_sig(link);\n    name = \"???\";\n    if (rev > 0)\n\tswitch (rev >> 4) {\n\tcase 3: name = \"92\"; break;\n\tcase 4: name = ((rev & 15) >= 6) ? \"96\" : \"94\"; break;\n\tcase 5: name = \"95\"; break;\n\tcase 7: name = \"100\"; break;\n\tcase 8: name = \"100-FD\"; break;\n\tcase 9: name = \"110\"; break;\n\t}\n\n    ioaddr = dev->base_addr;\n    if (rev > 0) {\n\tu_long mcr;\n\tSMC_SELECT_BANK(0);\n\tmir = inw(ioaddr + MEMINFO) & 0xff;\n\tif (mir == 0xff) mir++;\n\t \n\tmcr = ((rev >> 4) > 3) ? inw(ioaddr + MEMCFG) : 0x0200;\n\tmir *= 128 * (1<<((mcr >> 9) & 7));\n\tSMC_SELECT_BANK(1);\n\tsmc->cfg = inw(ioaddr + CONFIG) & ~CFG_AUI_SELECT;\n\tsmc->cfg |= CFG_NO_WAIT | CFG_16BIT | CFG_STATIC;\n\tif (smc->manfid == MANFID_OSITECH)\n\t    smc->cfg |= CFG_IRQ_SEL_1 | CFG_IRQ_SEL_0;\n\tif ((rev >> 4) >= 7)\n\t    smc->cfg |= CFG_MII_SELECT;\n    } else\n\tmir = 0;\n\n    if (smc->cfg & CFG_MII_SELECT) {\n\tSMC_SELECT_BANK(3);\n\n\tfor (i = 0; i < 32; i++) {\n\t    j = mdio_read(dev, i, 1);\n\t    if ((j != 0) && (j != 0xffff)) break;\n\t}\n\tsmc->mii_if.phy_id = (i < 32) ? i : -1;\n\n\tSMC_SELECT_BANK(0);\n    }\n\n    SET_NETDEV_DEV(dev, &link->dev);\n\n    if (register_netdev(dev) != 0) {\n\tdev_err(&link->dev, \"register_netdev() failed\\n\");\n\tgoto config_undo;\n    }\n\n    netdev_info(dev, \"smc91c%s rev %d: io %#3lx, irq %d, hw_addr %pM\\n\",\n\t\tname, (rev & 0x0f), dev->base_addr, dev->irq, dev->dev_addr);\n\n    if (rev > 0) {\n\tif (mir & 0x3ff)\n\t    netdev_info(dev, \"  %lu byte\", mir);\n\telse\n\t    netdev_info(dev, \"  %lu kb\", mir>>10);\n\tpr_cont(\" buffer, %s xcvr\\n\",\n\t\t(smc->cfg & CFG_MII_SELECT) ? \"MII\" : if_names[dev->if_port]);\n    }\n\n    if (smc->cfg & CFG_MII_SELECT) {\n\tif (smc->mii_if.phy_id != -1) {\n\t    netdev_dbg(dev, \"  MII transceiver at index %d, status %x\\n\",\n\t\t       smc->mii_if.phy_id, j);\n\t} else {\n\t    netdev_notice(dev, \"  No MII transceivers found!\\n\");\n\t}\n    }\n    return 0;\n\nconfig_undo:\n    unregister_netdev(dev);\nconfig_failed:\n    smc91c92_release(link);\n    free_netdev(dev);\n    return -ENODEV;\n}  \n\nstatic void smc91c92_release(struct pcmcia_device *link)\n{\n\tdev_dbg(&link->dev, \"smc91c92_release\\n\");\n\tif (link->resource[2]->end) {\n\t\tstruct net_device *dev = link->priv;\n\t\tstruct smc_private *smc = netdev_priv(dev);\n\t\tiounmap(smc->base);\n\t}\n\tpcmcia_disable_device(link);\n}\n\n \n\n#define MDIO_SHIFT_CLK\t\t0x04\n#define MDIO_DATA_OUT\t\t0x01\n#define MDIO_DIR_WRITE\t\t0x08\n#define MDIO_DATA_WRITE0\t(MDIO_DIR_WRITE)\n#define MDIO_DATA_WRITE1\t(MDIO_DIR_WRITE | MDIO_DATA_OUT)\n#define MDIO_DATA_READ\t\t0x02\n\nstatic void mdio_sync(unsigned int addr)\n{\n    int bits;\n    for (bits = 0; bits < 32; bits++) {\n\toutb(MDIO_DATA_WRITE1, addr);\n\toutb(MDIO_DATA_WRITE1 | MDIO_SHIFT_CLK, addr);\n    }\n}\n\nstatic int mdio_read(struct net_device *dev, int phy_id, int loc)\n{\n    unsigned int addr = dev->base_addr + MGMT;\n    u_int cmd = (0x06<<10)|(phy_id<<5)|loc;\n    int i, retval = 0;\n\n    mdio_sync(addr);\n    for (i = 13; i >= 0; i--) {\n\tint dat = (cmd&(1<<i)) ? MDIO_DATA_WRITE1 : MDIO_DATA_WRITE0;\n\toutb(dat, addr);\n\toutb(dat | MDIO_SHIFT_CLK, addr);\n    }\n    for (i = 19; i > 0; i--) {\n\toutb(0, addr);\n\tretval = (retval << 1) | ((inb(addr) & MDIO_DATA_READ) != 0);\n\toutb(MDIO_SHIFT_CLK, addr);\n    }\n    return (retval>>1) & 0xffff;\n}\n\nstatic void mdio_write(struct net_device *dev, int phy_id, int loc, int value)\n{\n    unsigned int addr = dev->base_addr + MGMT;\n    u_int cmd = (0x05<<28)|(phy_id<<23)|(loc<<18)|(1<<17)|value;\n    int i;\n\n    mdio_sync(addr);\n    for (i = 31; i >= 0; i--) {\n\tint dat = (cmd&(1<<i)) ? MDIO_DATA_WRITE1 : MDIO_DATA_WRITE0;\n\toutb(dat, addr);\n\toutb(dat | MDIO_SHIFT_CLK, addr);\n    }\n    for (i = 1; i >= 0; i--) {\n\toutb(0, addr);\n\toutb(MDIO_SHIFT_CLK, addr);\n    }\n}\n\n \n\n#ifdef PCMCIA_DEBUG\nstatic void smc_dump(struct net_device *dev)\n{\n    unsigned int ioaddr = dev->base_addr;\n    u_short i, w, save;\n    save = inw(ioaddr + BANK_SELECT);\n    for (w = 0; w < 4; w++) {\n\tSMC_SELECT_BANK(w);\n\tnetdev_dbg(dev, \"bank %d: \", w);\n\tfor (i = 0; i < 14; i += 2)\n\t    pr_cont(\" %04x\", inw(ioaddr + i));\n\tpr_cont(\"\\n\");\n    }\n    outw(save, ioaddr + BANK_SELECT);\n}\n#endif\n\nstatic int smc_open(struct net_device *dev)\n{\n    struct smc_private *smc = netdev_priv(dev);\n    struct pcmcia_device *link = smc->p_dev;\n\n    dev_dbg(&link->dev, \"%s: smc_open(%p), ID/Window %4.4x.\\n\",\n\t  dev->name, dev, inw(dev->base_addr + BANK_SELECT));\n#ifdef PCMCIA_DEBUG\n    smc_dump(dev);\n#endif\n\n     \n    if (!pcmcia_dev_present(link))\n\treturn -ENODEV;\n     \n    if (check_sig(link) < 0) {\n\tnetdev_info(dev, \"Yikes!  Bad chip signature!\\n\");\n\treturn -ENODEV;\n    }\n    link->open++;\n\n    netif_start_queue(dev);\n    smc->saved_skb = NULL;\n    smc->packets_waiting = 0;\n\n    smc_reset(dev);\n    timer_setup(&smc->media, media_check, 0);\n    mod_timer(&smc->media, jiffies + HZ);\n\n    return 0;\n}  \n\n \n\nstatic int smc_close(struct net_device *dev)\n{\n    struct smc_private *smc = netdev_priv(dev);\n    struct pcmcia_device *link = smc->p_dev;\n    unsigned int ioaddr = dev->base_addr;\n\n    dev_dbg(&link->dev, \"%s: smc_close(), status %4.4x.\\n\",\n\t  dev->name, inw(ioaddr + BANK_SELECT));\n\n    netif_stop_queue(dev);\n\n     \n    SMC_SELECT_BANK(2);\t \n    outw(0, ioaddr + INTERRUPT);\n    SMC_SELECT_BANK(0);\n    mask_bits(0xff00, ioaddr + RCR);\n    mask_bits(0xff00, ioaddr + TCR);\n\n     \n    SMC_SELECT_BANK(1);\n    outw(CTL_POWERDOWN, ioaddr + CONTROL );\n\n    link->open--;\n    del_timer_sync(&smc->media);\n\n    return 0;\n}  \n\n \n\nstatic void smc_hardware_send_packet(struct net_device * dev)\n{\n    struct smc_private *smc = netdev_priv(dev);\n    struct sk_buff *skb = smc->saved_skb;\n    unsigned int ioaddr = dev->base_addr;\n    u_char packet_no;\n\n    if (!skb) {\n\tnetdev_err(dev, \"In XMIT with no packet to send\\n\");\n\treturn;\n    }\n\n     \n    packet_no = inw(ioaddr + PNR_ARR) >> 8;\n    if (packet_no & 0x80) {\n\t \n\tnetdev_warn(dev, \"hardware Tx buffer allocation failed, status %#2.2x\\n\",\n\t\t    packet_no);\n\tdev_kfree_skb_irq(skb);\n\tsmc->saved_skb = NULL;\n\tnetif_start_queue(dev);\n\treturn;\n    }\n\n    dev->stats.tx_bytes += skb->len;\n     \n    outw(packet_no, ioaddr + PNR_ARR);\n     \n    outw(PTR_AUTOINC , ioaddr + POINTER);\n\n     \n    {\n\tu_char *buf = skb->data;\n\tu_int length = skb->len;  \n\n\tnetdev_dbg(dev, \"Trying to xmit packet of length %d\\n\", length);\n\t\n\t \n\toutw(0, ioaddr + DATA_1);\n\toutw(length + 6, ioaddr + DATA_1);\n\toutsw(ioaddr + DATA_1, buf, length >> 1);\n\t\n\t \n\toutw((length & 1) ? 0x2000 | buf[length-1] : 0, ioaddr + DATA_1);\n    }\n\n     \n    outw(((IM_TX_INT|IM_TX_EMPTY_INT)<<8) |\n\t (inw(ioaddr + INTERRUPT) & 0xff00),\n\t ioaddr + INTERRUPT);\n\n     \n    outw(MC_ENQUEUE , ioaddr + MMU_CMD);\n\n    smc->saved_skb = NULL;\n    dev_kfree_skb_irq(skb);\n    netif_trans_update(dev);\n    netif_start_queue(dev);\n}\n\n \n\nstatic void smc_tx_timeout(struct net_device *dev, unsigned int txqueue)\n{\n    struct smc_private *smc = netdev_priv(dev);\n    unsigned int ioaddr = dev->base_addr;\n\n    netdev_notice(dev, \"transmit timed out, Tx_status %2.2x status %4.4x.\\n\",\n\t\t  inw(ioaddr)&0xff, inw(ioaddr + 2));\n    dev->stats.tx_errors++;\n    smc_reset(dev);\n    netif_trans_update(dev);  \n    smc->saved_skb = NULL;\n    netif_wake_queue(dev);\n}\n\nstatic netdev_tx_t smc_start_xmit(struct sk_buff *skb,\n\t\t\t\t\tstruct net_device *dev)\n{\n    struct smc_private *smc = netdev_priv(dev);\n    unsigned int ioaddr = dev->base_addr;\n    u_short num_pages;\n    short time_out, ir;\n    unsigned long flags;\n\n    netif_stop_queue(dev);\n\n    netdev_dbg(dev, \"smc_start_xmit(length = %d) called, status %04x\\n\",\n\t       skb->len, inw(ioaddr + 2));\n\n    if (smc->saved_skb) {\n\t \n\tdev->stats.tx_aborted_errors++;\n\tnetdev_dbg(dev, \"Internal error -- sent packet while busy\\n\");\n\treturn NETDEV_TX_BUSY;\n    }\n    smc->saved_skb = skb;\n\n    num_pages = skb->len >> 8;\n\n    if (num_pages > 7) {\n\tnetdev_err(dev, \"Far too big packet error: %d pages\\n\", num_pages);\n\tdev_kfree_skb (skb);\n\tsmc->saved_skb = NULL;\n\tdev->stats.tx_dropped++;\n\treturn NETDEV_TX_OK;\t\t \n    }\n     \n    smc->packets_waiting++;\n\n    spin_lock_irqsave(&smc->lock, flags);\n    SMC_SELECT_BANK(2);\t \n\n     \n    if (smc->rx_ovrn) {\n\toutw(MC_RESET, ioaddr + MMU_CMD);\n\tsmc->rx_ovrn = 0;\n    }\n\n     \n    outw(MC_ALLOC | num_pages, ioaddr + MMU_CMD);\n    for (time_out = MEMORY_WAIT_TIME; time_out >= 0; time_out--) {\n\tir = inw(ioaddr+INTERRUPT);\n\tif (ir & IM_ALLOC_INT) {\n\t     \n\t    outw((ir&0xff00) | IM_ALLOC_INT, ioaddr + INTERRUPT);\n\t    smc_hardware_send_packet(dev);\t \n\t    spin_unlock_irqrestore(&smc->lock, flags);\n\t    return NETDEV_TX_OK;\n\t}\n    }\n\n     \n    netdev_dbg(dev, \"memory allocation deferred.\\n\");\n    outw((IM_ALLOC_INT << 8) | (ir & 0xff00), ioaddr + INTERRUPT);\n    spin_unlock_irqrestore(&smc->lock, flags);\n\n    return NETDEV_TX_OK;\n}\n\n \n\nstatic void smc_tx_err(struct net_device * dev)\n{\n    struct smc_private *smc = netdev_priv(dev);\n    unsigned int ioaddr = dev->base_addr;\n    int saved_packet = inw(ioaddr + PNR_ARR) & 0xff;\n    int packet_no = inw(ioaddr + FIFO_PORTS) & 0x7f;\n    int tx_status;\n\n     \n    outw(packet_no, ioaddr + PNR_ARR);\n\n     \n    outw(PTR_AUTOINC | PTR_READ | 0, ioaddr + POINTER);\n\n    tx_status = inw(ioaddr + DATA_1);\n\n    dev->stats.tx_errors++;\n    if (tx_status & TS_LOSTCAR) dev->stats.tx_carrier_errors++;\n    if (tx_status & TS_LATCOL)  dev->stats.tx_window_errors++;\n    if (tx_status & TS_16COL) {\n\tdev->stats.tx_aborted_errors++;\n\tsmc->tx_err++;\n    }\n\n    if (tx_status & TS_SUCCESS) {\n\tnetdev_notice(dev, \"Successful packet caused error interrupt?\\n\");\n    }\n     \n    SMC_SELECT_BANK(0);\n    outw(inw(ioaddr + TCR) | TCR_ENABLE | smc->duplex, ioaddr + TCR);\n    SMC_SELECT_BANK(2);\n\n    outw(MC_FREEPKT, ioaddr + MMU_CMD); \t \n\n     \n    smc->packets_waiting--;\n\n    outw(saved_packet, ioaddr + PNR_ARR);\n}\n\n \n\nstatic void smc_eph_irq(struct net_device *dev)\n{\n    struct smc_private *smc = netdev_priv(dev);\n    unsigned int ioaddr = dev->base_addr;\n    u_short card_stats, ephs;\n\n    SMC_SELECT_BANK(0);\n    ephs = inw(ioaddr + EPH);\n    netdev_dbg(dev, \"Ethernet protocol handler interrupt, status %4.4x.\\n\",\n\t       ephs);\n     \n    card_stats = inw(ioaddr + COUNTER);\n     \n    dev->stats.collisions += card_stats & 0xF;\n    card_stats >>= 4;\n     \n    dev->stats.collisions += card_stats & 0xF;\n#if 0 \t\t \n    card_stats >>= 4;\t\t\t \n    card_stats >>= 4;\t\t\t \n#endif\n     \n    outw(inw(ioaddr + TCR) | TCR_ENABLE | smc->duplex, ioaddr + TCR);\n\n     \n    SMC_SELECT_BANK(1);\n    outw(CTL_AUTO_RELEASE | 0x0000, ioaddr + CONTROL);\n    outw(CTL_AUTO_RELEASE | CTL_TE_ENABLE | CTL_CR_ENABLE,\n\t ioaddr + CONTROL);\n    SMC_SELECT_BANK(2);\n}\n\n \n\nstatic irqreturn_t smc_interrupt(int irq, void *dev_id)\n{\n    struct net_device *dev = dev_id;\n    struct smc_private *smc = netdev_priv(dev);\n    unsigned int ioaddr;\n    u_short saved_bank, saved_pointer, mask, status;\n    unsigned int handled = 1;\n    char bogus_cnt = INTR_WORK;\t\t \n\n    if (!netif_device_present(dev))\n\treturn IRQ_NONE;\n\n    ioaddr = dev->base_addr;\n\n    netdev_dbg(dev, \"SMC91c92 interrupt %d at %#x.\\n\",\n\t       irq, ioaddr);\n\n    spin_lock(&smc->lock);\n    smc->watchdog = 0;\n    saved_bank = inw(ioaddr + BANK_SELECT);\n    if ((saved_bank & 0xff00) != 0x3300) {\n\t \n\tnetdev_dbg(dev, \"SMC91c92 interrupt %d for non-existent/ejected device.\\n\",\n\t\t   irq);\n\thandled = 0;\n\tgoto irq_done;\n    }\n\n    SMC_SELECT_BANK(2);\n    saved_pointer = inw(ioaddr + POINTER);\n    mask = inw(ioaddr + INTERRUPT) >> 8;\n     \n    outw(0, ioaddr + INTERRUPT);\n\n    do {  \n\tstatus = inw(ioaddr + INTERRUPT) & 0xff;\n\tnetdev_dbg(dev, \"Status is %#2.2x (mask %#2.2x).\\n\",\n\t\t   status, mask);\n\tif ((status & mask) == 0) {\n\t    if (bogus_cnt == INTR_WORK)\n\t\thandled = 0;\n\t    break;\n\t}\n\tif (status & IM_RCV_INT) {\n\t     \n\t    smc_rx(dev);\n\t}\n\tif (status & IM_TX_INT) {\n\t    smc_tx_err(dev);\n\t    outw(IM_TX_INT, ioaddr + INTERRUPT);\n\t}\n\tstatus &= mask;\n\tif (status & IM_TX_EMPTY_INT) {\n\t    outw(IM_TX_EMPTY_INT, ioaddr + INTERRUPT);\n\t    mask &= ~IM_TX_EMPTY_INT;\n\t    dev->stats.tx_packets += smc->packets_waiting;\n\t    smc->packets_waiting = 0;\n\t}\n\tif (status & IM_ALLOC_INT) {\n\t     \n\t    mask &= ~IM_ALLOC_INT;\n\t\n\t    smc_hardware_send_packet(dev);\n\t\n\t     \n\t    mask |= (IM_TX_EMPTY_INT | IM_TX_INT);\n\t\n\t     \n\t    netif_wake_queue(dev);\n\t}\n\tif (status & IM_RX_OVRN_INT) {\n\t    dev->stats.rx_errors++;\n\t    dev->stats.rx_fifo_errors++;\n\t    if (smc->duplex)\n\t\tsmc->rx_ovrn = 1;  \n\t    outw(IM_RX_OVRN_INT, ioaddr + INTERRUPT);\n\t}\n\tif (status & IM_EPH_INT)\n\t    smc_eph_irq(dev);\n    } while (--bogus_cnt);\n\n    netdev_dbg(dev, \"  Restoring saved registers mask %2.2x bank %4.4x pointer %4.4x.\\n\",\n\t       mask, saved_bank, saved_pointer);\n\n     \n    outw((mask<<8), ioaddr + INTERRUPT);\n    outw(saved_pointer, ioaddr + POINTER);\n    SMC_SELECT_BANK(saved_bank);\n\n    netdev_dbg(dev, \"Exiting interrupt IRQ%d.\\n\", irq);\n\nirq_done:\n\n    if ((smc->manfid == MANFID_OSITECH) &&\n\t(smc->cardid != PRODID_OSITECH_SEVEN)) {\n\t \n\tmask_bits(0x00ff, ioaddr-0x10+OSITECH_RESET_ISR);\n\tset_bits(0x0300, ioaddr-0x10+OSITECH_RESET_ISR);\n    }\n    if (smc->manfid == MANFID_MOTOROLA) {\n\tu_char cor;\n\tcor = readb(smc->base + MOT_UART + CISREG_COR);\n\twriteb(cor & ~COR_IREQ_ENA, smc->base + MOT_UART + CISREG_COR);\n\twriteb(cor, smc->base + MOT_UART + CISREG_COR);\n\tcor = readb(smc->base + MOT_LAN + CISREG_COR);\n\twriteb(cor & ~COR_IREQ_ENA, smc->base + MOT_LAN + CISREG_COR);\n\twriteb(cor, smc->base + MOT_LAN + CISREG_COR);\n    }\n\n    if ((smc->base != NULL) &&   \n\t(smc->manfid == MANFID_MEGAHERTZ) &&\n\t(smc->cardid == PRODID_MEGAHERTZ_EM3288)) {\n\n\tu_char tmp;\n\ttmp = readb(smc->base+MEGAHERTZ_ISR);\n\ttmp = readb(smc->base+MEGAHERTZ_ISR);\n\n\t \n\twriteb(tmp, smc->base + MEGAHERTZ_ISR);\n\twriteb(tmp, smc->base + MEGAHERTZ_ISR);\n    }\n\n    spin_unlock(&smc->lock);\n    return IRQ_RETVAL(handled);\n}\n\n \n\nstatic void smc_rx(struct net_device *dev)\n{\n    unsigned int ioaddr = dev->base_addr;\n    int rx_status;\n    int packet_length;\t \n\n     \n\n    if (inw(ioaddr + FIFO_PORTS) & FP_RXEMPTY) {\n\tnetdev_err(dev, \"smc_rx() with nothing on Rx FIFO\\n\");\n\treturn;\n    }\n\n     \n    outw(PTR_READ | PTR_RCV | PTR_AUTOINC, ioaddr + POINTER);\n    rx_status = inw(ioaddr + DATA_1);\n    packet_length = inw(ioaddr + DATA_1) & 0x07ff;\n\n    netdev_dbg(dev, \"Receive status %4.4x length %d.\\n\",\n\t       rx_status, packet_length);\n\n    if (!(rx_status & RS_ERRORS)) {\n\t \n\tstruct sk_buff *skb;\n\tstruct smc_private *smc = netdev_priv(dev);\n\t\n\t \n\tskb = netdev_alloc_skb(dev, packet_length+2);\n\t\n\tif (skb == NULL) {\n\t    netdev_dbg(dev, \"Low memory, packet dropped.\\n\");\n\t    dev->stats.rx_dropped++;\n\t    outw(MC_RELEASE, ioaddr + MMU_CMD);\n\t    return;\n\t}\n\t\n\tpacket_length -= (rx_status & RS_ODDFRAME ? 5 : 6);\n\tskb_reserve(skb, 2);\n\tinsw(ioaddr+DATA_1, skb_put(skb, packet_length),\n\t     (packet_length+1)>>1);\n\tskb->protocol = eth_type_trans(skb, dev);\n\t\n\tnetif_rx(skb);\n\tsmc->last_rx = jiffies;\n\tdev->stats.rx_packets++;\n\tdev->stats.rx_bytes += packet_length;\n\tif (rx_status & RS_MULTICAST)\n\t    dev->stats.multicast++;\n    } else {\n\t \n\tdev->stats.rx_errors++;\n\t\n\tif (rx_status & RS_ALGNERR)  dev->stats.rx_frame_errors++;\n\tif (rx_status & (RS_TOOSHORT | RS_TOOLONG))\n\t    dev->stats.rx_length_errors++;\n\tif (rx_status & RS_BADCRC)\tdev->stats.rx_crc_errors++;\n    }\n     \n    outw(MC_RELEASE, ioaddr + MMU_CMD);\n}\n\n \n\nstatic void set_rx_mode(struct net_device *dev)\n{\n    unsigned int ioaddr = dev->base_addr;\n    struct smc_private *smc = netdev_priv(dev);\n    unsigned char multicast_table[8];\n    unsigned long flags;\n    u_short rx_cfg_setting;\n    int i;\n\n    memset(multicast_table, 0, sizeof(multicast_table));\n\n    if (dev->flags & IFF_PROMISC) {\n\trx_cfg_setting = RxStripCRC | RxEnable | RxPromisc | RxAllMulti;\n    } else if (dev->flags & IFF_ALLMULTI)\n\trx_cfg_setting = RxStripCRC | RxEnable | RxAllMulti;\n    else {\n\tif (!netdev_mc_empty(dev)) {\n\t    struct netdev_hw_addr *ha;\n\n\t    netdev_for_each_mc_addr(ha, dev) {\n\t\tu_int position = ether_crc(6, ha->addr);\n\t\tmulticast_table[position >> 29] |= 1 << ((position >> 26) & 7);\n\t    }\n\t}\n\trx_cfg_setting = RxStripCRC | RxEnable;\n    }\n\n     \n    spin_lock_irqsave(&smc->lock, flags);\n    SMC_SELECT_BANK(3);\n    for (i = 0; i < 8; i++)\n\toutb(multicast_table[i], ioaddr + MULTICAST0 + i);\n    SMC_SELECT_BANK(0);\n    outw(rx_cfg_setting, ioaddr + RCR);\n    SMC_SELECT_BANK(2);\n    spin_unlock_irqrestore(&smc->lock, flags);\n}\n\n \n\nstatic int s9k_config(struct net_device *dev, struct ifmap *map)\n{\n    struct smc_private *smc = netdev_priv(dev);\n    if ((map->port != (u_char)(-1)) && (map->port != dev->if_port)) {\n\tif (smc->cfg & CFG_MII_SELECT)\n\t    return -EOPNOTSUPP;\n\telse if (map->port > 2)\n\t    return -EINVAL;\n\tdev->if_port = map->port;\n\tnetdev_info(dev, \"switched to %s port\\n\", if_names[dev->if_port]);\n\tsmc_reset(dev);\n    }\n    return 0;\n}\n\n \n\n \nstatic void smc_set_xcvr(struct net_device *dev, int if_port)\n{\n    struct smc_private *smc = netdev_priv(dev);\n    unsigned int ioaddr = dev->base_addr;\n    u_short saved_bank;\n\n    saved_bank = inw(ioaddr + BANK_SELECT);\n    SMC_SELECT_BANK(1);\n    if (if_port == 2) {\n\toutw(smc->cfg | CFG_AUI_SELECT, ioaddr + CONFIG);\n\tif ((smc->manfid == MANFID_OSITECH) &&\n\t    (smc->cardid != PRODID_OSITECH_SEVEN))\n\t    set_bits(OSI_AUI_PWR, ioaddr - 0x10 + OSITECH_AUI_PWR);\n\tsmc->media_status = ((dev->if_port == 0) ? 0x0001 : 0x0002);\n    } else {\n\toutw(smc->cfg, ioaddr + CONFIG);\n\tif ((smc->manfid == MANFID_OSITECH) &&\n\t    (smc->cardid != PRODID_OSITECH_SEVEN))\n\t    mask_bits(~OSI_AUI_PWR, ioaddr - 0x10 + OSITECH_AUI_PWR);\n\tsmc->media_status = ((dev->if_port == 0) ? 0x0012 : 0x4001);\n    }\n    SMC_SELECT_BANK(saved_bank);\n}\n\nstatic void smc_reset(struct net_device *dev)\n{\n    unsigned int ioaddr = dev->base_addr;\n    struct smc_private *smc = netdev_priv(dev);\n    int i;\n\n    netdev_dbg(dev, \"smc91c92 reset called.\\n\");\n\n     \n    SMC_SELECT_BANK(0);\n     \n    outw(RCR_SOFTRESET, ioaddr + RCR);\n    udelay(10);\n\n     \n    outw(RCR_CLEAR, ioaddr + RCR);\n    outw(TCR_CLEAR, ioaddr + TCR);\n\n     \n    SMC_SELECT_BANK(1);\n     \n    outw(CTL_AUTO_RELEASE | CTL_TE_ENABLE | CTL_CR_ENABLE,\n\t ioaddr + CONTROL);\n    smc_set_xcvr(dev, dev->if_port);\n    if ((smc->manfid == MANFID_OSITECH) &&\n\t(smc->cardid != PRODID_OSITECH_SEVEN))\n\toutw((dev->if_port == 2 ? OSI_AUI_PWR : 0) |\n\t     (inw(ioaddr-0x10+OSITECH_AUI_PWR) & 0xff00),\n\t     ioaddr - 0x10 + OSITECH_AUI_PWR);\n\n     \n    for (i = 0; i < 6; i += 2)\n\toutw((dev->dev_addr[i+1]<<8)+dev->dev_addr[i],\n\t     ioaddr + ADDR0 + i);\n\n     \n    SMC_SELECT_BANK(2);\n    outw(MC_RESET, ioaddr + MMU_CMD);\n    outw(0, ioaddr + INTERRUPT);\n\n     \n    SMC_SELECT_BANK(0);\n    outw(((smc->cfg & CFG_MII_SELECT) ? 0 : TCR_MONCSN) |\n\t TCR_ENABLE | TCR_PAD_EN | smc->duplex, ioaddr + TCR);\n    set_rx_mode(dev);\n\n    if (smc->cfg & CFG_MII_SELECT) {\n\tSMC_SELECT_BANK(3);\n\n\t \n\tmdio_write(dev, smc->mii_if.phy_id, 0, 0x8000);\n\n\t \n\tmdio_write(dev, smc->mii_if.phy_id, 4, 0x01e1);\n\n\t \n\tmdio_write(dev, smc->mii_if.phy_id, 0, 0x0000);\n\tmdio_write(dev, smc->mii_if.phy_id, 0, 0x1200);\n    }\n\n     \n    SMC_SELECT_BANK(2);\n    outw((IM_EPH_INT | IM_RX_OVRN_INT | IM_RCV_INT) << 8,\n\t ioaddr + INTERRUPT);\n}\n\n \n\nstatic void media_check(struct timer_list *t)\n{\n    struct smc_private *smc = from_timer(smc, t, media);\n    struct net_device *dev = smc->mii_if.dev;\n    unsigned int ioaddr = dev->base_addr;\n    u_short i, media, saved_bank;\n    u_short link;\n    unsigned long flags;\n\n    spin_lock_irqsave(&smc->lock, flags);\n\n    saved_bank = inw(ioaddr + BANK_SELECT);\n\n    if (!netif_device_present(dev))\n\tgoto reschedule;\n\n    SMC_SELECT_BANK(2);\n\n     \n    if (smc->rx_ovrn) {\n\toutw(MC_RESET, ioaddr + MMU_CMD);\n\tsmc->rx_ovrn = 0;\n    }\n    i = inw(ioaddr + INTERRUPT);\n    SMC_SELECT_BANK(0);\n    media = inw(ioaddr + EPH) & EPH_LINK_OK;\n    SMC_SELECT_BANK(1);\n    media |= (inw(ioaddr + CONFIG) & CFG_AUI_SELECT) ? 2 : 1;\n\n    SMC_SELECT_BANK(saved_bank);\n    spin_unlock_irqrestore(&smc->lock, flags);\n\n     \n    if (smc->watchdog++ && ((i>>8) & i)) {\n\tif (!smc->fast_poll)\n\t    netdev_info(dev, \"interrupt(s) dropped!\\n\");\n\tlocal_irq_save(flags);\n\tsmc_interrupt(dev->irq, dev);\n\tlocal_irq_restore(flags);\n\tsmc->fast_poll = HZ;\n    }\n    if (smc->fast_poll) {\n\tsmc->fast_poll--;\n\tsmc->media.expires = jiffies + HZ/100;\n\tadd_timer(&smc->media);\n\treturn;\n    }\n\n    spin_lock_irqsave(&smc->lock, flags);\n\n    saved_bank = inw(ioaddr + BANK_SELECT);\n\n    if (smc->cfg & CFG_MII_SELECT) {\n\tif (smc->mii_if.phy_id < 0)\n\t    goto reschedule;\n\n\tSMC_SELECT_BANK(3);\n\tlink = mdio_read(dev, smc->mii_if.phy_id, 1);\n\tif (!link || (link == 0xffff)) {\n\t    netdev_info(dev, \"MII is missing!\\n\");\n\t    smc->mii_if.phy_id = -1;\n\t    goto reschedule;\n\t}\n\n\tlink &= 0x0004;\n\tif (link != smc->link_status) {\n\t    u_short p = mdio_read(dev, smc->mii_if.phy_id, 5);\n\t    netdev_info(dev, \"%s link beat\\n\", link ? \"found\" : \"lost\");\n\t    smc->duplex = (((p & 0x0100) || ((p & 0x1c0) == 0x40))\n\t\t\t   ? TCR_FDUPLX : 0);\n\t    if (link) {\n\t\tnetdev_info(dev, \"autonegotiation complete: \"\n\t\t\t    \"%dbaseT-%cD selected\\n\",\n\t\t\t    (p & 0x0180) ? 100 : 10, smc->duplex ? 'F' : 'H');\n\t    }\n\t    SMC_SELECT_BANK(0);\n\t    outw(inw(ioaddr + TCR) | smc->duplex, ioaddr + TCR);\n\t    smc->link_status = link;\n\t}\n\tgoto reschedule;\n    }\n\n     \n    if (time_after(jiffies, smc->last_rx + HZ)) {\n\tif (smc->tx_err || (smc->media_status & EPH_16COL))\n\t    media |= EPH_16COL;\n    }\n    smc->tx_err = 0;\n\n    if (media != smc->media_status) {\n\tif ((media & smc->media_status & 1) &&\n\t    ((smc->media_status ^ media) & EPH_LINK_OK))\n\t    netdev_info(dev, \"%s link beat\\n\",\n\t\t\tsmc->media_status & EPH_LINK_OK ? \"lost\" : \"found\");\n\telse if ((media & smc->media_status & 2) &&\n\t\t ((smc->media_status ^ media) & EPH_16COL))\n\t    netdev_info(dev, \"coax cable %s\\n\",\n\t\t\tmedia & EPH_16COL ? \"problem\" : \"ok\");\n\tif (dev->if_port == 0) {\n\t    if (media & 1) {\n\t\tif (media & EPH_LINK_OK)\n\t\t    netdev_info(dev, \"flipped to 10baseT\\n\");\n\t\telse\n\t\t    smc_set_xcvr(dev, 2);\n\t    } else {\n\t\tif (media & EPH_16COL)\n\t\t    smc_set_xcvr(dev, 1);\n\t\telse\n\t\t    netdev_info(dev, \"flipped to 10base2\\n\");\n\t    }\n\t}\n\tsmc->media_status = media;\n    }\n\nreschedule:\n    smc->media.expires = jiffies + HZ;\n    add_timer(&smc->media);\n    SMC_SELECT_BANK(saved_bank);\n    spin_unlock_irqrestore(&smc->lock, flags);\n}\n\nstatic int smc_link_ok(struct net_device *dev)\n{\n    unsigned int ioaddr = dev->base_addr;\n    struct smc_private *smc = netdev_priv(dev);\n\n    if (smc->cfg & CFG_MII_SELECT) {\n\treturn mii_link_ok(&smc->mii_if);\n    } else {\n        SMC_SELECT_BANK(0);\n\treturn inw(ioaddr + EPH) & EPH_LINK_OK;\n    }\n}\n\nstatic void smc_netdev_get_ecmd(struct net_device *dev,\n\t\t\t\tstruct ethtool_link_ksettings *ecmd)\n{\n\tu16 tmp;\n\tunsigned int ioaddr = dev->base_addr;\n\tu32 supported;\n\n\tsupported = (SUPPORTED_TP | SUPPORTED_AUI |\n\t\t     SUPPORTED_10baseT_Half | SUPPORTED_10baseT_Full);\n\n\tSMC_SELECT_BANK(1);\n\ttmp = inw(ioaddr + CONFIG);\n\tecmd->base.port = (tmp & CFG_AUI_SELECT) ? PORT_AUI : PORT_TP;\n\tecmd->base.speed = SPEED_10;\n\tecmd->base.phy_address = ioaddr + MGMT;\n\n\tSMC_SELECT_BANK(0);\n\ttmp = inw(ioaddr + TCR);\n\tecmd->base.duplex = (tmp & TCR_FDUPLX) ? DUPLEX_FULL : DUPLEX_HALF;\n\n\tethtool_convert_legacy_u32_to_link_mode(ecmd->link_modes.supported,\n\t\t\t\t\t\tsupported);\n}\n\nstatic int smc_netdev_set_ecmd(struct net_device *dev,\n\t\t\t       const struct ethtool_link_ksettings *ecmd)\n{\n\tu16 tmp;\n\tunsigned int ioaddr = dev->base_addr;\n\n\tif (ecmd->base.speed != SPEED_10)\n\t\treturn -EINVAL;\n\tif (ecmd->base.duplex != DUPLEX_HALF &&\n\t    ecmd->base.duplex != DUPLEX_FULL)\n\t\treturn -EINVAL;\n\tif (ecmd->base.port != PORT_TP && ecmd->base.port != PORT_AUI)\n\t\treturn -EINVAL;\n\n\tif (ecmd->base.port == PORT_AUI)\n\t\tsmc_set_xcvr(dev, 1);\n\telse\n\t\tsmc_set_xcvr(dev, 0);\n\n\tSMC_SELECT_BANK(0);\n\ttmp = inw(ioaddr + TCR);\n\tif (ecmd->base.duplex == DUPLEX_FULL)\n\t\ttmp |= TCR_FDUPLX;\n\telse\n\t\ttmp &= ~TCR_FDUPLX;\n\toutw(tmp, ioaddr + TCR);\n\n\treturn 0;\n}\n\nstatic int check_if_running(struct net_device *dev)\n{\n\tif (!netif_running(dev))\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic void smc_get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *info)\n{\n\tstrscpy(info->driver, DRV_NAME, sizeof(info->driver));\n\tstrscpy(info->version, DRV_VERSION, sizeof(info->version));\n}\n\nstatic int smc_get_link_ksettings(struct net_device *dev,\n\t\t\t\t  struct ethtool_link_ksettings *ecmd)\n{\n\tstruct smc_private *smc = netdev_priv(dev);\n\tunsigned int ioaddr = dev->base_addr;\n\tu16 saved_bank = inw(ioaddr + BANK_SELECT);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&smc->lock, flags);\n\tSMC_SELECT_BANK(3);\n\tif (smc->cfg & CFG_MII_SELECT)\n\t\tmii_ethtool_get_link_ksettings(&smc->mii_if, ecmd);\n\telse\n\t\tsmc_netdev_get_ecmd(dev, ecmd);\n\tSMC_SELECT_BANK(saved_bank);\n\tspin_unlock_irqrestore(&smc->lock, flags);\n\treturn 0;\n}\n\nstatic int smc_set_link_ksettings(struct net_device *dev,\n\t\t\t\t  const struct ethtool_link_ksettings *ecmd)\n{\n\tstruct smc_private *smc = netdev_priv(dev);\n\tunsigned int ioaddr = dev->base_addr;\n\tu16 saved_bank = inw(ioaddr + BANK_SELECT);\n\tint ret;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&smc->lock, flags);\n\tSMC_SELECT_BANK(3);\n\tif (smc->cfg & CFG_MII_SELECT)\n\t\tret = mii_ethtool_set_link_ksettings(&smc->mii_if, ecmd);\n\telse\n\t\tret = smc_netdev_set_ecmd(dev, ecmd);\n\tSMC_SELECT_BANK(saved_bank);\n\tspin_unlock_irqrestore(&smc->lock, flags);\n\treturn ret;\n}\n\nstatic u32 smc_get_link(struct net_device *dev)\n{\n\tstruct smc_private *smc = netdev_priv(dev);\n\tunsigned int ioaddr = dev->base_addr;\n\tu16 saved_bank = inw(ioaddr + BANK_SELECT);\n\tu32 ret;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&smc->lock, flags);\n\tSMC_SELECT_BANK(3);\n\tret = smc_link_ok(dev);\n\tSMC_SELECT_BANK(saved_bank);\n\tspin_unlock_irqrestore(&smc->lock, flags);\n\treturn ret;\n}\n\nstatic int smc_nway_reset(struct net_device *dev)\n{\n\tstruct smc_private *smc = netdev_priv(dev);\n\tif (smc->cfg & CFG_MII_SELECT) {\n\t\tunsigned int ioaddr = dev->base_addr;\n\t\tu16 saved_bank = inw(ioaddr + BANK_SELECT);\n\t\tint res;\n\n\t\tSMC_SELECT_BANK(3);\n\t\tres = mii_nway_restart(&smc->mii_if);\n\t\tSMC_SELECT_BANK(saved_bank);\n\n\t\treturn res;\n\t} else\n\t\treturn -EOPNOTSUPP;\n}\n\nstatic const struct ethtool_ops ethtool_ops = {\n\t.begin = check_if_running,\n\t.get_drvinfo = smc_get_drvinfo,\n\t.get_link = smc_get_link,\n\t.nway_reset = smc_nway_reset,\n\t.get_link_ksettings = smc_get_link_ksettings,\n\t.set_link_ksettings = smc_set_link_ksettings,\n};\n\nstatic int smc_ioctl (struct net_device *dev, struct ifreq *rq, int cmd)\n{\n\tstruct smc_private *smc = netdev_priv(dev);\n\tstruct mii_ioctl_data *mii = if_mii(rq);\n\tint rc = 0;\n\tu16 saved_bank;\n\tunsigned int ioaddr = dev->base_addr;\n\tunsigned long flags;\n\n\tif (!netif_running(dev))\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&smc->lock, flags);\n\tsaved_bank = inw(ioaddr + BANK_SELECT);\n\tSMC_SELECT_BANK(3);\n\trc = generic_mii_ioctl(&smc->mii_if, mii, cmd, NULL);\n\tSMC_SELECT_BANK(saved_bank);\n\tspin_unlock_irqrestore(&smc->lock, flags);\n\treturn rc;\n}\n\nstatic const struct pcmcia_device_id smc91c92_ids[] = {\n\tPCMCIA_PFC_DEVICE_MANF_CARD(0, 0x0109, 0x0501),\n\tPCMCIA_PFC_DEVICE_MANF_CARD(0, 0x0140, 0x000a),\n\tPCMCIA_PFC_DEVICE_PROD_ID123(0, \"MEGAHERTZ\", \"CC/XJEM3288\", \"DATA/FAX/CELL ETHERNET MODEM\", 0xf510db04, 0x04cd2988, 0x46a52d63),\n\tPCMCIA_PFC_DEVICE_PROD_ID123(0, \"MEGAHERTZ\", \"CC/XJEM3336\", \"DATA/FAX/CELL ETHERNET MODEM\", 0xf510db04, 0x0143b773, 0x46a52d63),\n\tPCMCIA_PFC_DEVICE_PROD_ID123(0, \"MEGAHERTZ\", \"EM1144T\", \"PCMCIA MODEM\", 0xf510db04, 0x856d66c8, 0xbd6c43ef),\n\tPCMCIA_PFC_DEVICE_PROD_ID123(0, \"MEGAHERTZ\", \"XJEM1144/CCEM1144\", \"PCMCIA MODEM\", 0xf510db04, 0x52d21e1e, 0xbd6c43ef),\n\tPCMCIA_PFC_DEVICE_PROD_ID12(0, \"Gateway 2000\", \"XJEM3336\", 0xdd9989be, 0x662c394c),\n\tPCMCIA_PFC_DEVICE_PROD_ID12(0, \"MEGAHERTZ\", \"XJEM1144/CCEM1144\", 0xf510db04, 0x52d21e1e),\n\tPCMCIA_PFC_DEVICE_PROD_ID12(0, \"Ositech\", \"Trumpcard:Jack of Diamonds Modem+Ethernet\", 0xc2f80cd, 0x656947b9),\n\tPCMCIA_PFC_DEVICE_PROD_ID12(0, \"Ositech\", \"Trumpcard:Jack of Hearts Modem+Ethernet\", 0xc2f80cd, 0xdc9ba5ed),\n\tPCMCIA_MFC_DEVICE_MANF_CARD(0, 0x016c, 0x0020),\n\tPCMCIA_DEVICE_MANF_CARD(0x016c, 0x0023),\n\tPCMCIA_DEVICE_PROD_ID123(\"BASICS by New Media Corporation\", \"Ethernet\", \"SMC91C94\", 0x23c78a9d, 0x00b2e941, 0xcef397fb),\n\tPCMCIA_DEVICE_PROD_ID12(\"ARGOSY\", \"Fast Ethernet PCCard\", 0x78f308dc, 0xdcea68bc),\n\tPCMCIA_DEVICE_PROD_ID12(\"dit Co., Ltd.\", \"PC Card-10/100BTX\", 0xe59365c8, 0x6a2161d1),\n\tPCMCIA_DEVICE_PROD_ID12(\"DYNALINK\", \"L100C\", 0x6a26d1cf, 0xc16ce9c5),\n\tPCMCIA_DEVICE_PROD_ID12(\"Farallon\", \"Farallon Enet\", 0x58d93fc4, 0x244734e9),\n\tPCMCIA_DEVICE_PROD_ID12(\"Megahertz\", \"CC10BT/2\", 0x33234748, 0x3c95b953),\n\tPCMCIA_DEVICE_PROD_ID12(\"MELCO/SMC\", \"LPC-TX\", 0xa2cd8e6d, 0x42da662a),\n\tPCMCIA_DEVICE_PROD_ID12(\"Ositech\", \"Trumpcard:Four of Diamonds Ethernet\", 0xc2f80cd, 0xb3466314),\n\tPCMCIA_DEVICE_PROD_ID12(\"Ositech\", \"Trumpcard:Seven of Diamonds Ethernet\", 0xc2f80cd, 0x194b650a),\n\tPCMCIA_DEVICE_PROD_ID12(\"PCMCIA\", \"Fast Ethernet PCCard\", 0x281f1c5d, 0xdcea68bc),\n\tPCMCIA_DEVICE_PROD_ID12(\"Psion\", \"10Mb Ethernet\", 0x4ef00b21, 0x844be9e9),\n\tPCMCIA_DEVICE_PROD_ID12(\"SMC\", \"EtherEZ Ethernet 8020\", 0xc4f8b18b, 0x4a0eeb2d),\n\t \n\t \n\t \n\tPCMCIA_DEVICE_NULL,\n};\nMODULE_DEVICE_TABLE(pcmcia, smc91c92_ids);\n\nstatic struct pcmcia_driver smc91c92_cs_driver = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"smc91c92_cs\",\n\t.probe\t\t= smc91c92_probe,\n\t.remove\t\t= smc91c92_detach,\n\t.id_table       = smc91c92_ids,\n\t.suspend\t= smc91c92_suspend,\n\t.resume\t\t= smc91c92_resume,\n};\nmodule_pcmcia_driver(smc91c92_cs_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}