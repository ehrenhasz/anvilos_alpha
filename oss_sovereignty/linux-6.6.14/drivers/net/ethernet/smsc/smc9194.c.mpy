{
  "module_name": "smc9194.c",
  "hash_id": "7ac4522026e5db9227c8bb61b840a9b59901026a17891adc3e8805bb8460ad46",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/smsc/smc9194.c",
  "human_readable_source": " \n\nstatic const char version[] =\n\t\"smc9194.c:v0.14 12/15/00 by Erik Stahlman (erik@vt.edu)\";\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/fcntl.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/in.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/crc32.h>\n#include <linux/errno.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/skbuff.h>\n#include <linux/bitops.h>\n\n#include <asm/io.h>\n\n#include \"smc9194.h\"\n\n#define DRV_NAME \"smc9194\"\n\n \n\n \n#ifdef __sh__\n#undef USE_32_BIT\n#else\n#define USE_32_BIT 1\n#endif\n\n \n\nstruct devlist {\n\tunsigned int port;\n\tunsigned int irq;\n};\n\nstatic struct devlist smc_devlist[] __initdata = {\n\t{.port = 0x200, .irq = 0},\n\t{.port = 0x220, .irq = 0},\n\t{.port = 0x240, .irq = 0},\n\t{.port = 0x260, .irq = 0},\n\t{.port = 0x280, .irq = 0},\n\t{.port = 0x2A0, .irq = 0},\n\t{.port = 0x2C0, .irq = 0},\n\t{.port = 0x2E0, .irq = 0},\n\t{.port = 0x300, .irq = 0},\n\t{.port = 0x320, .irq = 0},\n\t{.port = 0x340, .irq = 0},\n\t{.port = 0x360, .irq = 0},\n\t{.port = 0x380, .irq = 0},\n\t{.port = 0x3A0, .irq = 0},\n\t{.port = 0x3C0, .irq = 0},\n\t{.port = 0x3E0, .irq = 0},\n\t{.port = 0,     .irq = 0},\n};\n \n#define MEMORY_WAIT_TIME 16\n\n \n#define SMC_DEBUG 0\n\n#if (SMC_DEBUG > 2 )\n#define PRINTK3(x) printk x\n#else\n#define PRINTK3(x)\n#endif\n\n#if SMC_DEBUG > 1\n#define PRINTK2(x) printk x\n#else\n#define PRINTK2(x)\n#endif\n\n#ifdef SMC_DEBUG\n#define PRINTK(x) printk x\n#else\n#define PRINTK(x)\n#endif\n\n\n \n#define CARDNAME \"SMC9194\"\n\n\n \nstruct smc_local {\n\t \n\tstruct sk_buff * saved_skb;\n\n\t \n\tint\tpackets_waiting;\n};\n\n\n \n\n \nstruct net_device *smc_init(int unit);\n\n \nstatic int smc_open(struct net_device *dev);\n\n \nstatic void smc_timeout(struct net_device *dev, unsigned int txqueue);\n\n \nstatic int smc_close(struct net_device *dev);\n\n \nstatic void smc_set_multicast_list(struct net_device *dev);\n\n\n \n\n \nstatic irqreturn_t smc_interrupt(int irq, void *);\n \nstatic inline void smc_rcv( struct net_device *dev );\n \nstatic inline void smc_tx( struct net_device * dev );\n\n \n\n \nstatic int smc_probe(struct net_device *dev, int ioaddr);\n\n \n#if SMC_DEBUG > 2\nstatic void print_packet( byte *, int );\n#endif\n\n#define tx_done(dev) 1\n\n \nstatic void smc_hardware_send_packet( struct net_device * dev );\n\n \nstatic netdev_tx_t  smc_wait_to_send_packet( struct sk_buff * skb,\n\t\t\t\t\t     struct net_device *dev );\n\n \nstatic void smc_reset( int ioaddr );\n\n \nstatic void smc_enable( int ioaddr );\n\n \nstatic void smc_shutdown( int ioaddr );\n\n \nstatic int smc_findirq( int ioaddr );\n\n \nstatic void smc_reset( int ioaddr )\n{\n\t \n\tSMC_SELECT_BANK( 0 );\n\toutw( RCR_SOFTRESET, ioaddr + RCR );\n\n\t \n\tSMC_DELAY( );\n\n\t \n\toutw( RCR_CLEAR, ioaddr + RCR );\n\toutw( TCR_CLEAR, ioaddr + TCR );\n\n\t \n\tSMC_SELECT_BANK( 1 );\n\toutw( inw( ioaddr + CONTROL ) | CTL_AUTO_RELEASE , ioaddr + CONTROL );\n\n\t \n\tSMC_SELECT_BANK( 2 );\n\toutw( MC_RESET, ioaddr + MMU_CMD );\n\n\t \n\n\toutb( 0, ioaddr + INT_MASK );\n}\n\n \nstatic void smc_enable( int ioaddr )\n{\n\tSMC_SELECT_BANK( 0 );\n\t \n\toutw( TCR_NORMAL, ioaddr + TCR );\n\toutw( RCR_NORMAL, ioaddr + RCR );\n\n\t \n\tSMC_SELECT_BANK( 2 );\n\toutb( SMC_INTERRUPT_MASK, ioaddr + INT_MASK );\n}\n\n \nstatic void smc_shutdown( int ioaddr )\n{\n\t \n\tSMC_SELECT_BANK( 2 );\n\toutb( 0, ioaddr + INT_MASK );\n\n\t \n\tSMC_SELECT_BANK( 0 );\n\toutb( RCR_CLEAR, ioaddr + RCR );\n\toutb( TCR_CLEAR, ioaddr + TCR );\n#if 0\n\t \n\tSMC_SELECT_BANK( 1 );\n\toutw( inw( ioaddr + CONTROL ), CTL_POWERDOWN, ioaddr + CONTROL  );\n#endif\n}\n\n\n \n\n\nstatic void smc_setmulticast(int ioaddr, struct net_device *dev)\n{\n\tint\t\t\ti;\n\tunsigned char\t\tmulticast_table[ 8 ];\n\tstruct netdev_hw_addr *ha;\n\t \n\tunsigned char invert3[] = { 0, 4, 2, 6, 1, 5, 3, 7 };\n\n\t \n\tmemset( multicast_table, 0, sizeof( multicast_table ) );\n\n\tnetdev_for_each_mc_addr(ha, dev) {\n\t\tint position;\n\n\t\t \n\t\tposition = ether_crc_le(6, ha->addr) & 0x3f;\n\n\t\t \n\t\tmulticast_table[invert3[position&7]] |=\n\t\t\t\t\t(1<<invert3[(position>>3)&7]);\n\n\t}\n\t \n\tSMC_SELECT_BANK( 3 );\n\n\tfor ( i = 0; i < 8 ; i++ ) {\n\t\toutb( multicast_table[i], ioaddr + MULTICAST1 + i );\n\t}\n}\n\n \nstatic netdev_tx_t smc_wait_to_send_packet(struct sk_buff *skb,\n\t\t\t\t\t   struct net_device *dev)\n{\n\tstruct smc_local *lp = netdev_priv(dev);\n\tunsigned int ioaddr \t= dev->base_addr;\n\tword \t\t\tlength;\n\tunsigned short \t\tnumPages;\n\tword\t\t\ttime_out;\n\n\tnetif_stop_queue(dev);\n\t \n\n\tif ( lp->saved_skb) {\n\t\t \n\t\tdev->stats.tx_aborted_errors++;\n\t\tprintk(CARDNAME\": Bad Craziness - sent packet while busy.\\n\" );\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\tlp->saved_skb = skb;\n\n\tlength = skb->len;\n\n\tif (length < ETH_ZLEN) {\n\t\tif (skb_padto(skb, ETH_ZLEN)) {\n\t\t\tnetif_wake_queue(dev);\n\t\t\treturn NETDEV_TX_OK;\n\t\t}\n\t\tlength = ETH_ZLEN;\n\t}\n\n\t \n\tnumPages =  ((length & 0xfffe) + 6) / 256;\n\n\tif (numPages > 7 ) {\n\t\tprintk(CARDNAME\": Far too big packet error.\\n\");\n\t\t \n\t\tdev_kfree_skb (skb);\n\t\tlp->saved_skb = NULL;\n\t\t \n\t\tnetif_wake_queue(dev);\n\t\treturn NETDEV_TX_OK;\n\t}\n\t \n\tlp->packets_waiting++;\n\n\t \n\tSMC_SELECT_BANK( 2 );\n\toutw( MC_ALLOC | numPages, ioaddr + MMU_CMD );\n\t \n\ttime_out = MEMORY_WAIT_TIME;\n\tdo {\n\t\tword\tstatus;\n\n\t\tstatus = inb( ioaddr + INTERRUPT );\n\t\tif ( status & IM_ALLOC_INT ) {\n\t\t\t \n\t\t\toutb( IM_ALLOC_INT, ioaddr + INTERRUPT );\n\t\t\tbreak;\n\t\t}\n\t} while ( -- time_out );\n\n\tif ( !time_out ) {\n\t\t \n\t\tSMC_ENABLE_INT( IM_ALLOC_INT );\n\t\tPRINTK2((CARDNAME\": memory allocation deferred.\\n\"));\n\t\t \n\t\treturn NETDEV_TX_OK;\n\t}\n\t \n\tsmc_hardware_send_packet(dev);\n\tnetif_wake_queue(dev);\n\treturn NETDEV_TX_OK;\n}\n\n \nstatic void smc_hardware_send_packet( struct net_device * dev )\n{\n\tstruct smc_local *lp = netdev_priv(dev);\n\tbyte\t \t\tpacket_no;\n\tstruct sk_buff * \tskb = lp->saved_skb;\n\tword\t\t\tlength;\n\tunsigned int\t\tioaddr;\n\tbyte\t\t\t* buf;\n\n\tioaddr = dev->base_addr;\n\n\tif ( !skb ) {\n\t\tPRINTK((CARDNAME\": In XMIT with no packet to send\\n\"));\n\t\treturn;\n\t}\n\tlength = ETH_ZLEN < skb->len ? skb->len : ETH_ZLEN;\n\tbuf = skb->data;\n\n\t \n\tpacket_no = inb( ioaddr + PNR_ARR + 1 );\n\tif ( packet_no & 0x80 ) {\n\t\t \n\t\tnetdev_dbg(dev, CARDNAME\": Memory allocation failed.\\n\");\n\t\tdev_kfree_skb_any(skb);\n\t\tlp->saved_skb = NULL;\n\t\tnetif_wake_queue(dev);\n\t\treturn;\n\t}\n\n\t \n\toutb( packet_no, ioaddr + PNR_ARR );\n\n\t \n\toutw( PTR_AUTOINC , ioaddr + POINTER );\n\n\tPRINTK3((CARDNAME\": Trying to xmit packet of length %x\\n\", length));\n#if SMC_DEBUG > 2\n\tprint_packet( buf, length );\n#endif\n\n\t \n#ifdef USE_32_BIT\n\toutl(  (length +6 ) << 16 , ioaddr + DATA_1 );\n#else\n\toutw( 0, ioaddr + DATA_1 );\n\t \n\toutb( (length+6) & 0xFF,ioaddr + DATA_1 );\n\toutb( (length+6) >> 8 , ioaddr + DATA_1 );\n#endif\n\n\t \n#ifdef USE_32_BIT\n\tif ( length & 0x2  ) {\n\t\toutsl(ioaddr + DATA_1, buf,  length >> 2 );\n\t\toutw( *((word *)(buf + (length & 0xFFFFFFFC))),ioaddr +DATA_1);\n\t}\n\telse\n\t\toutsl(ioaddr + DATA_1, buf,  length >> 2 );\n#else\n\toutsw(ioaddr + DATA_1 , buf, (length ) >> 1);\n#endif\n\t \n\n\tif ( (length & 1) == 0 ) {\n\t\toutw( 0, ioaddr + DATA_1 );\n\t} else {\n\t\toutb( buf[length -1 ], ioaddr + DATA_1 );\n\t\toutb( 0x20, ioaddr + DATA_1);\n\t}\n\n\t \n\tSMC_ENABLE_INT( (IM_TX_INT | IM_TX_EMPTY_INT) );\n\n\t \n\toutw( MC_ENQUEUE , ioaddr + MMU_CMD );\n\n\tPRINTK2((CARDNAME\": Sent packet of length %d\\n\", length));\n\n\tlp->saved_skb = NULL;\n\tdev_kfree_skb_any (skb);\n\n\tnetif_trans_update(dev);\n\n\t \n\tnetif_wake_queue(dev);\n}\n\n \nstatic int io;\nstatic int irq;\nstatic int ifport;\n\nstruct net_device * __init smc_init(int unit)\n{\n\tstruct net_device *dev = alloc_etherdev(sizeof(struct smc_local));\n\tstruct devlist *smcdev = smc_devlist;\n\tint err = 0;\n\n\tif (!dev)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tif (unit >= 0) {\n\t\tsprintf(dev->name, \"eth%d\", unit);\n\t\tnetdev_boot_setup_check(dev);\n\t\tio = dev->base_addr;\n\t\tirq = dev->irq;\n\t}\n\n\tif (io > 0x1ff) {\t \n\t\terr = smc_probe(dev, io);\n\t} else if (io != 0) {\t \n\t\terr = -ENXIO;\n\t} else {\n\t\tfor (;smcdev->port; smcdev++) {\n\t\t\tif (smc_probe(dev, smcdev->port) == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!smcdev->port)\n\t\t\terr = -ENODEV;\n\t}\n\tif (err)\n\t\tgoto out;\n\terr = register_netdev(dev);\n\tif (err)\n\t\tgoto out1;\n\treturn dev;\nout1:\n\tfree_irq(dev->irq, dev);\n\trelease_region(dev->base_addr, SMC_IO_EXTENT);\nout:\n\tfree_netdev(dev);\n\treturn ERR_PTR(err);\n}\n\n \nstatic int __init smc_findirq(int ioaddr)\n{\n#ifndef NO_AUTOPROBE\n\tint\ttimeout = 20;\n\tunsigned long cookie;\n\n\n\tcookie = probe_irq_on();\n\n\t \n\n\n\tSMC_SELECT_BANK(2);\n\t \n\toutb( IM_ALLOC_INT, ioaddr + INT_MASK );\n\n\t \n\toutw( MC_ALLOC | 1, ioaddr + MMU_CMD );\n\n\t \n\twhile ( timeout ) {\n\t\tbyte\tint_status;\n\n\t\tint_status = inb( ioaddr + INTERRUPT );\n\n\t\tif ( int_status & IM_ALLOC_INT )\n\t\t\tbreak;\t\t \n\t\ttimeout--;\n\t}\n\t \n\n\t \n\tSMC_DELAY();\n\tSMC_DELAY();\n\n\t \n\toutb( 0, ioaddr + INT_MASK );\n\n\t \n\treturn probe_irq_off(cookie);\n#else  \n\tstruct devlist *smcdev;\n\tfor (smcdev = smc_devlist; smcdev->port; smcdev++) {\n\t\tif (smcdev->port == ioaddr)\n\t\t\treturn smcdev->irq;\n\t}\n\treturn 0;\n#endif\n}\n\nstatic const struct net_device_ops smc_netdev_ops = {\n\t.ndo_open\t\t = smc_open,\n\t.ndo_stop\t\t= smc_close,\n\t.ndo_start_xmit    \t= smc_wait_to_send_packet,\n\t.ndo_tx_timeout\t    \t= smc_timeout,\n\t.ndo_set_rx_mode\t= smc_set_multicast_list,\n\t.ndo_set_mac_address \t= eth_mac_addr,\n\t.ndo_validate_addr\t= eth_validate_addr,\n};\n\n \n\n \nstatic int __init smc_probe(struct net_device *dev, int ioaddr)\n{\n\tint i, memory, retval;\n\tunsigned int bank;\n\n\tconst char *version_string;\n\tconst char *if_string;\n\n\t \n\tword revision_register;\n\tword base_address_register;\n\tword configuration_register;\n\tword memory_info_register;\n\tword memory_cfg_register;\n\tu8 addr[ETH_ALEN];\n\n\t \n\tif (!request_region(ioaddr, SMC_IO_EXTENT, DRV_NAME))\n\t\treturn -EBUSY;\n\n\tdev->irq = irq;\n\tdev->if_port = ifport;\n\n\t \n\tbank = inw( ioaddr + BANK_SELECT );\n\tif ( (bank & 0xFF00) != 0x3300 ) {\n\t\tretval = -ENODEV;\n\t\tgoto err_out;\n\t}\n\t \n\toutw( 0x0, ioaddr + BANK_SELECT );\n\tbank = inw( ioaddr + BANK_SELECT );\n\tif ( (bank & 0xFF00 ) != 0x3300 ) {\n\t\tretval = -ENODEV;\n\t\tgoto err_out;\n\t}\n\t \n\tSMC_SELECT_BANK(1);\n\tbase_address_register = inw( ioaddr + BASE );\n\tif ( ioaddr != ( base_address_register >> 3 & 0x3E0 ) )  {\n\t\tprintk(CARDNAME \": IOADDR %x doesn't match configuration (%x). \"\n\t\t\t\"Probably not a SMC chip\\n\",\n\t\t\tioaddr, base_address_register >> 3 & 0x3E0 );\n\t\t \n\t\tretval = -ENODEV;\n\t\tgoto err_out;\n\t}\n\n\t \n\tSMC_SELECT_BANK(3);\n\trevision_register  = inw( ioaddr + REVISION );\n\tif ( !chip_ids[ ( revision_register  >> 4 ) & 0xF  ] ) {\n\t\t \n\t\tprintk(CARDNAME \": IO %x: Unrecognized revision register:\"\n\t\t\t\" %x, Contact author.\\n\", ioaddr, revision_register);\n\n\t\tretval = -ENODEV;\n\t\tgoto err_out;\n\t}\n\n\t \n\n\tpr_info_once(\"%s\\n\", version);\n\n\t \n\tdev->base_addr = ioaddr;\n\n\t \n\tSMC_SELECT_BANK( 1 );\n\tfor ( i = 0; i < 6; i += 2 ) {\n\t\tword\taddress;\n\n\t\taddress = inw( ioaddr + ADDR0 + i  );\n\t\taddr[i + 1] = address >> 8;\n\t\taddr[i] = address & 0xFF;\n\t}\n\teth_hw_addr_set(dev, addr);\n\n\t \n\n\tSMC_SELECT_BANK( 0 );\n\tmemory_info_register = inw( ioaddr + MIR );\n\tmemory_cfg_register  = inw( ioaddr + MCR );\n\tmemory = ( memory_cfg_register >> 9 )  & 0x7;   \n\tmemory *= 256 * ( memory_info_register & 0xFF );\n\n\t \n\tSMC_SELECT_BANK(3);\n\trevision_register  = inw( ioaddr + REVISION );\n\tversion_string = chip_ids[ ( revision_register  >> 4 ) & 0xF  ];\n\tif ( !version_string ) {\n\t\t \n\t\tretval = -ENODEV;\n\t\tgoto err_out;\n\t}\n\n\t \n\tif ( dev->if_port == 0 ) {\n\t\tSMC_SELECT_BANK(1);\n\t\tconfiguration_register = inw( ioaddr + CONFIG );\n\t\tif ( configuration_register & CFG_AUI_SELECT )\n\t\t\tdev->if_port = 2;\n\t\telse\n\t\t\tdev->if_port = 1;\n\t}\n\tif_string = interfaces[ dev->if_port - 1 ];\n\n\t \n\tsmc_reset( ioaddr );\n\n\t \n\tif ( dev->irq < 2 ) {\n\t\tint\ttrials;\n\n\t\ttrials = 3;\n\t\twhile ( trials-- ) {\n\t\t\tdev->irq = smc_findirq( ioaddr );\n\t\t\tif ( dev->irq )\n\t\t\t\tbreak;\n\t\t\t \n\t\t\tsmc_reset( ioaddr );\n\t\t}\n\t}\n\tif (dev->irq == 0 ) {\n\t\tprintk(CARDNAME\": Couldn't autodetect your IRQ. Use irq=xx.\\n\");\n\t\tretval = -ENODEV;\n\t\tgoto err_out;\n\t}\n\n\t \n\n\tnetdev_info(dev, \"%s(r:%d) at %#3x IRQ:%d INTF:%s MEM:%db \",\n\t\t    version_string, revision_register & 0xF, ioaddr, dev->irq,\n\t\t    if_string, memory);\n\t \n\tnetdev_info(dev, \"ADDR: %pM\\n\", dev->dev_addr);\n\n\t \n\tretval = request_irq(dev->irq, smc_interrupt, 0, DRV_NAME, dev);\n\tif (retval) {\n\t\tnetdev_warn(dev, \"%s: unable to get IRQ %d (irqval=%d).\\n\",\n\t\t\t    DRV_NAME, dev->irq, retval);\n\t\tgoto err_out;\n\t}\n\n\tdev->netdev_ops\t\t\t= &smc_netdev_ops;\n\tdev->watchdog_timeo\t\t= HZ/20;\n\n\treturn 0;\n\nerr_out:\n\trelease_region(ioaddr, SMC_IO_EXTENT);\n\treturn retval;\n}\n\n#if SMC_DEBUG > 2\nstatic void print_packet( byte * buf, int length )\n{\n#if 0\n\tprint_hex_dump_debug(DRV_NAME, DUMP_PREFIX_OFFSET, 16, 1,\n\t\t\t     buf, length, true);\n#endif\n}\n#endif\n\n\n \nstatic int smc_open(struct net_device *dev)\n{\n\tint\tioaddr = dev->base_addr;\n\n\tint\ti;\t \n\n\t \n\tmemset(netdev_priv(dev), 0, sizeof(struct smc_local));\n\n\t \n\n\tsmc_reset( ioaddr );\n\tsmc_enable( ioaddr );\n\n\t \n\n\tSMC_SELECT_BANK( 1 );\n\tif ( dev->if_port == 1 ) {\n\t\toutw( inw( ioaddr + CONFIG ) & ~CFG_AUI_SELECT,\n\t\t\tioaddr + CONFIG );\n\t}\n\telse if ( dev->if_port == 2 ) {\n\t\toutw( inw( ioaddr + CONFIG ) | CFG_AUI_SELECT,\n\t\t\tioaddr + CONFIG );\n\t}\n\n\t \n\tSMC_SELECT_BANK( 1 );\n\tfor ( i = 0; i < 6; i += 2 ) {\n\t\tword\taddress;\n\n\t\taddress = dev->dev_addr[ i + 1 ] << 8 ;\n\t\taddress  |= dev->dev_addr[ i ];\n\t\toutw( address, ioaddr + ADDR0 + i );\n\t}\n\n\tnetif_start_queue(dev);\n\treturn 0;\n}\n\n \n\nstatic void smc_timeout(struct net_device *dev, unsigned int txqueue)\n{\n\t \n\tnetdev_warn(dev, CARDNAME\": transmit timed out, %s?\\n\",\n\t\t    tx_done(dev) ? \"IRQ conflict\" : \"network cable problem\");\n\t \n\tsmc_reset( dev->base_addr );\n\tsmc_enable( dev->base_addr );\n\tnetif_trans_update(dev);  \n\t \n\t((struct smc_local *)netdev_priv(dev))->saved_skb = NULL;\n\tnetif_wake_queue(dev);\n}\n\n \nstatic void smc_rcv(struct net_device *dev)\n{\n\tint \tioaddr = dev->base_addr;\n\tint \tpacket_number;\n\tword\tstatus;\n\tword\tpacket_length;\n\n\t \n\n\tpacket_number = inw( ioaddr + FIFO_PORTS );\n\n\tif ( packet_number & FP_RXEMPTY ) {\n\t\t \n\t\tPRINTK((CARDNAME \": WARNING: smc_rcv with nothing on FIFO.\\n\"));\n\t\t \n\t\treturn;\n\t}\n\n\t \n\toutw( PTR_READ | PTR_RCV | PTR_AUTOINC, ioaddr + POINTER );\n\n\t \n\tstatus \t\t= inw( ioaddr + DATA_1 );\n\tpacket_length \t= inw( ioaddr + DATA_1 );\n\n\tpacket_length &= 0x07ff;   \n\n\tPRINTK2((\"RCV: STATUS %4x LENGTH %4x\\n\", status, packet_length ));\n\t \n\tpacket_length -= 6;\n\n\tif ( !(status & RS_ERRORS ) ){\n\t\t \n\t\tstruct sk_buff  * skb;\n\t\tbyte\t\t* data;\n\n\t\t \n\t\tif ( status & RS_ODDFRAME )\n\t\t\tpacket_length++;\n\n\t\t \n\t\tif ( status & RS_MULTICAST )\n\t\t\tdev->stats.multicast++;\n\n\t\tskb = netdev_alloc_skb(dev, packet_length + 5);\n\t\tif ( skb == NULL ) {\n\t\t\tdev->stats.rx_dropped++;\n\t\t\tgoto done;\n\t\t}\n\n\t\t \n\n\t\tskb_reserve( skb, 2 );    \n\n\t\tdata = skb_put( skb, packet_length);\n\n#ifdef USE_32_BIT\n\t\t \n\t\tPRINTK3((\" Reading %d dwords (and %d bytes)\\n\",\n\t\t\tpacket_length >> 2, packet_length & 3 ));\n\t\tinsl(ioaddr + DATA_1 , data, packet_length >> 2 );\n\t\t \n\t\tinsb( ioaddr + DATA_1, data + (packet_length & 0xFFFFFC),\n\t\t\tpacket_length & 0x3  );\n#else\n\t\tPRINTK3((\" Reading %d words and %d byte(s)\\n\",\n\t\t\t(packet_length >> 1 ), packet_length & 1 ));\n\t\tinsw(ioaddr + DATA_1 , data, packet_length >> 1);\n\t\tif ( packet_length & 1 ) {\n\t\t\tdata += packet_length & ~1;\n\t\t\t*(data++) = inb( ioaddr + DATA_1 );\n\t\t}\n#endif\n#if\tSMC_DEBUG > 2\n\t\t\tprint_packet( data, packet_length );\n#endif\n\n\t\tskb->protocol = eth_type_trans(skb, dev );\n\t\tnetif_rx(skb);\n\t\tdev->stats.rx_packets++;\n\t\tdev->stats.rx_bytes += packet_length;\n\t} else {\n\t\t \n\t\tdev->stats.rx_errors++;\n\n\t\tif ( status & RS_ALGNERR )  dev->stats.rx_frame_errors++;\n\t\tif ( status & (RS_TOOSHORT | RS_TOOLONG ) )\n\t\t\tdev->stats.rx_length_errors++;\n\t\tif ( status & RS_BADCRC)\tdev->stats.rx_crc_errors++;\n\t}\n\ndone:\n\t \n\toutw( MC_RELEASE, ioaddr + MMU_CMD );\n}\n\n\n \nstatic void smc_tx( struct net_device * dev )\n{\n\tint\tioaddr = dev->base_addr;\n\tstruct smc_local *lp = netdev_priv(dev);\n\tbyte saved_packet;\n\tbyte packet_no;\n\tword tx_status;\n\n\n\t \n\n\tsaved_packet = inb( ioaddr + PNR_ARR );\n\tpacket_no = inw( ioaddr + FIFO_PORTS );\n\tpacket_no &= 0x7F;\n\n\t \n\toutb( packet_no, ioaddr + PNR_ARR );\n\n\t \n\toutw( PTR_AUTOINC | PTR_READ, ioaddr + POINTER );\n\n\ttx_status = inw( ioaddr + DATA_1 );\n\tPRINTK3((CARDNAME\": TX DONE STATUS: %4x\\n\", tx_status));\n\n\tdev->stats.tx_errors++;\n\tif ( tx_status & TS_LOSTCAR ) dev->stats.tx_carrier_errors++;\n\tif ( tx_status & TS_LATCOL  ) {\n\t\tnetdev_dbg(dev, CARDNAME\": Late collision occurred on last xmit.\\n\");\n\t\tdev->stats.tx_window_errors++;\n\t}\n#if 0\n\t\tif ( tx_status & TS_16COL ) { ... }\n#endif\n\n\tif ( tx_status & TS_SUCCESS ) {\n\t\tnetdev_info(dev, CARDNAME\": Successful packet caused interrupt\\n\");\n\t}\n\t \n\tSMC_SELECT_BANK( 0 );\n\toutw( inw( ioaddr + TCR ) | TCR_ENABLE, ioaddr + TCR );\n\n\t \n\tSMC_SELECT_BANK( 2 );\n\toutw( MC_FREEPKT, ioaddr + MMU_CMD );\n\n\t \n\tlp->packets_waiting--;\n\n\toutb( saved_packet, ioaddr + PNR_ARR );\n}\n\n \n\nstatic irqreturn_t smc_interrupt(int irq, void * dev_id)\n{\n\tstruct net_device *dev \t= dev_id;\n\tint ioaddr \t\t= dev->base_addr;\n\tstruct smc_local *lp = netdev_priv(dev);\n\n\tbyte\tstatus;\n\tword\tcard_stats;\n\tbyte\tmask;\n\tint\ttimeout;\n\t \n\tword\tsaved_bank;\n\tword\tsaved_pointer;\n\tint handled = 0;\n\n\n\tPRINTK3((CARDNAME\": SMC interrupt started\\n\"));\n\n\tsaved_bank = inw( ioaddr + BANK_SELECT );\n\n\tSMC_SELECT_BANK(2);\n\tsaved_pointer = inw( ioaddr + POINTER );\n\n\tmask = inb( ioaddr + INT_MASK );\n\t \n\toutb( 0, ioaddr + INT_MASK );\n\n\n\t \n\ttimeout = 4;\n\n\tPRINTK2((KERN_WARNING CARDNAME \": MASK IS %x\\n\", mask));\n\tdo {\n\t\t \n\t\tstatus = inb( ioaddr + INTERRUPT ) & mask;\n\t\tif (!status )\n\t\t\tbreak;\n\n\t\thandled = 1;\n\n\t\tPRINTK3((KERN_WARNING CARDNAME\n\t\t\t\": Handling interrupt status %x\\n\", status));\n\n\t\tif (status & IM_RCV_INT) {\n\t\t\t \n\t\t\tPRINTK2((KERN_WARNING CARDNAME\n\t\t\t\t\": Receive Interrupt\\n\"));\n\t\t\tsmc_rcv(dev);\n\t\t} else if (status & IM_TX_INT ) {\n\t\t\tPRINTK2((KERN_WARNING CARDNAME\n\t\t\t\t\": TX ERROR handled\\n\"));\n\t\t\tsmc_tx(dev);\n\t\t\toutb(IM_TX_INT, ioaddr + INTERRUPT );\n\t\t} else if (status & IM_TX_EMPTY_INT ) {\n\t\t\t \n\t\t\tSMC_SELECT_BANK( 0 );\n\t\t\tcard_stats = inw( ioaddr + COUNTER );\n\t\t\t \n\t\t\tdev->stats.collisions += card_stats & 0xF;\n\t\t\tcard_stats >>= 4;\n\t\t\t \n\t\t\tdev->stats.collisions += card_stats & 0xF;\n\n\t\t\t \n\n\t\t\tSMC_SELECT_BANK( 2 );\n\t\t\tPRINTK2((KERN_WARNING CARDNAME\n\t\t\t\t\": TX_BUFFER_EMPTY handled\\n\"));\n\t\t\toutb( IM_TX_EMPTY_INT, ioaddr + INTERRUPT );\n\t\t\tmask &= ~IM_TX_EMPTY_INT;\n\t\t\tdev->stats.tx_packets += lp->packets_waiting;\n\t\t\tlp->packets_waiting = 0;\n\n\t\t} else if (status & IM_ALLOC_INT ) {\n\t\t\tPRINTK2((KERN_DEBUG CARDNAME\n\t\t\t\t\": Allocation interrupt\\n\"));\n\t\t\t \n\t\t\tmask &= ~IM_ALLOC_INT;\n\n\t\t\tsmc_hardware_send_packet( dev );\n\n\t\t\t \n\t\t\tmask |= ( IM_TX_EMPTY_INT | IM_TX_INT );\n\n\t\t\t \n\t\t\tnetif_wake_queue(dev);\n\n\t\t\tPRINTK2((CARDNAME\": Handoff done successfully.\\n\"));\n\t\t} else if (status & IM_RX_OVRN_INT ) {\n\t\t\tdev->stats.rx_errors++;\n\t\t\tdev->stats.rx_fifo_errors++;\n\t\t\toutb( IM_RX_OVRN_INT, ioaddr + INTERRUPT );\n\t\t} else if (status & IM_EPH_INT ) {\n\t\t\tPRINTK((CARDNAME \": UNSUPPORTED: EPH INTERRUPT\\n\"));\n\t\t} else if (status & IM_ERCV_INT ) {\n\t\t\tPRINTK((CARDNAME \": UNSUPPORTED: ERCV INTERRUPT\\n\"));\n\t\t\toutb( IM_ERCV_INT, ioaddr + INTERRUPT );\n\t\t}\n\t} while ( timeout -- );\n\n\n\t \n\tSMC_SELECT_BANK( 2 );\n\toutb( mask, ioaddr + INT_MASK );\n\n\tPRINTK3((KERN_WARNING CARDNAME \": MASK is now %x\\n\", mask));\n\toutw( saved_pointer, ioaddr + POINTER );\n\n\tSMC_SELECT_BANK( saved_bank );\n\n\tPRINTK3((CARDNAME \": Interrupt done\\n\"));\n\treturn IRQ_RETVAL(handled);\n}\n\n\n \nstatic int smc_close(struct net_device *dev)\n{\n\tnetif_stop_queue(dev);\n\t \n\tsmc_shutdown( dev->base_addr );\n\n\t \n\treturn 0;\n}\n\n \nstatic void smc_set_multicast_list(struct net_device *dev)\n{\n\tshort ioaddr = dev->base_addr;\n\n\tSMC_SELECT_BANK(0);\n\tif ( dev->flags & IFF_PROMISC )\n\t\toutw( inw(ioaddr + RCR ) | RCR_PROMISC, ioaddr + RCR );\n\n \n\n\t \n\telse if (dev->flags & IFF_ALLMULTI)\n\t\toutw( inw(ioaddr + RCR ) | RCR_ALMUL, ioaddr + RCR );\n\n\t \n\telse if (!netdev_mc_empty(dev)) {\n\t\t \n\n\t\t \n\t\toutw( inw( ioaddr + RCR ) & ~(RCR_PROMISC | RCR_ALMUL),\n\t\t\tioaddr + RCR );\n\t\t \n\t\tsmc_setmulticast(ioaddr, dev);\n\t}\n\telse  {\n\t\toutw( inw( ioaddr + RCR ) & ~(RCR_PROMISC | RCR_ALMUL),\n\t\t\tioaddr + RCR );\n\n\t\t \n\t\tSMC_SELECT_BANK( 3 );\n\t\toutw( 0, ioaddr + MULTICAST1 );\n\t\toutw( 0, ioaddr + MULTICAST2 );\n\t\toutw( 0, ioaddr + MULTICAST3 );\n\t\toutw( 0, ioaddr + MULTICAST4 );\n\t}\n}\n\n#ifdef MODULE\n\nstatic struct net_device *devSMC9194;\nMODULE_LICENSE(\"GPL\");\n\nmodule_param_hw(io, int, ioport, 0);\nmodule_param_hw(irq, int, irq, 0);\nmodule_param(ifport, int, 0);\nMODULE_PARM_DESC(io, \"SMC 99194 I/O base address\");\nMODULE_PARM_DESC(irq, \"SMC 99194 IRQ number\");\nMODULE_PARM_DESC(ifport, \"SMC 99194 interface port (0-default, 1-TP, 2-AUI)\");\n\nstatic int __init smc_init_module(void)\n{\n\tif (io == 0)\n\t\tprintk(KERN_WARNING\n\t\tCARDNAME\": You shouldn't use auto-probing with insmod!\\n\" );\n\n\t \n\tdevSMC9194 = smc_init(-1);\n\treturn PTR_ERR_OR_ZERO(devSMC9194);\n}\nmodule_init(smc_init_module);\n\nstatic void __exit smc_cleanup_module(void)\n{\n\tunregister_netdev(devSMC9194);\n\tfree_irq(devSMC9194->irq, devSMC9194);\n\trelease_region(devSMC9194->base_addr, SMC_IO_EXTENT);\n\tfree_netdev(devSMC9194);\n}\nmodule_exit(smc_cleanup_module);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}