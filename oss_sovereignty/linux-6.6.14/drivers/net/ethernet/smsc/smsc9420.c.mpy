{
  "module_name": "smsc9420.c",
  "hash_id": "0c8b1da2226779779dcf919a954b223d6032fa5e70e1309c0ab8e7ca004648ff",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/smsc/smsc9420.c",
  "human_readable_source": "\n  \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/netdevice.h>\n#include <linux/phy.h>\n#include <linux/pci.h>\n#include <linux/if_vlan.h>\n#include <linux/dma-mapping.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <asm/unaligned.h>\n#include \"smsc9420.h\"\n\n#define DRV_NAME\t\t\"smsc9420\"\n#define DRV_MDIONAME\t\t\"smsc9420-mdio\"\n#define DRV_DESCRIPTION\t\t\"SMSC LAN9420 driver\"\n#define DRV_VERSION\t\t\"1.01\"\n\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(DRV_VERSION);\n\nstruct smsc9420_dma_desc {\n\tu32 status;\n\tu32 length;\n\tu32 buffer1;\n\tu32 buffer2;\n};\n\nstruct smsc9420_ring_info {\n\tstruct sk_buff *skb;\n\tdma_addr_t mapping;\n};\n\nstruct smsc9420_pdata {\n\tvoid __iomem *ioaddr;\n\tstruct pci_dev *pdev;\n\tstruct net_device *dev;\n\n\tstruct smsc9420_dma_desc *rx_ring;\n\tstruct smsc9420_dma_desc *tx_ring;\n\tstruct smsc9420_ring_info *tx_buffers;\n\tstruct smsc9420_ring_info *rx_buffers;\n\tdma_addr_t rx_dma_addr;\n\tdma_addr_t tx_dma_addr;\n\tint tx_ring_head, tx_ring_tail;\n\tint rx_ring_head, rx_ring_tail;\n\n\tspinlock_t int_lock;\n\tspinlock_t phy_lock;\n\n\tstruct napi_struct napi;\n\n\tbool software_irq_signal;\n\tbool rx_csum;\n\tu32 msg_enable;\n\n\tstruct mii_bus *mii_bus;\n\tint last_duplex;\n\tint last_carrier;\n};\n\nstatic const struct pci_device_id smsc9420_id_table[] = {\n\t{ PCI_VENDOR_ID_9420, PCI_DEVICE_ID_9420, PCI_ANY_ID, PCI_ANY_ID, },\n\t{ 0, }\n};\n\nMODULE_DEVICE_TABLE(pci, smsc9420_id_table);\n\n#define SMSC_MSG_DEFAULT (NETIF_MSG_DRV | NETIF_MSG_PROBE | NETIF_MSG_LINK)\n\nstatic uint smsc_debug;\nstatic uint debug = -1;\nmodule_param(debug, uint, 0);\nMODULE_PARM_DESC(debug, \"debug level\");\n\nstatic inline u32 smsc9420_reg_read(struct smsc9420_pdata *pd, u32 offset)\n{\n\treturn ioread32(pd->ioaddr + offset);\n}\n\nstatic inline void\nsmsc9420_reg_write(struct smsc9420_pdata *pd, u32 offset, u32 value)\n{\n\tiowrite32(value, pd->ioaddr + offset);\n}\n\nstatic inline void smsc9420_pci_flush_write(struct smsc9420_pdata *pd)\n{\n\t \n\tsmsc9420_reg_read(pd, ID_REV);\n}\n\nstatic int smsc9420_mii_read(struct mii_bus *bus, int phyaddr, int regidx)\n{\n\tstruct smsc9420_pdata *pd = bus->priv;\n\tunsigned long flags;\n\tu32 addr;\n\tint i, reg = -EIO;\n\n\tspin_lock_irqsave(&pd->phy_lock, flags);\n\n\t \n\tif ((smsc9420_reg_read(pd, MII_ACCESS) & MII_ACCESS_MII_BUSY_)) {\n\t\tnetif_warn(pd, drv, pd->dev, \"MII is busy???\\n\");\n\t\tgoto out;\n\t}\n\n\t \n\taddr = ((phyaddr & 0x1F) << 11) | ((regidx & 0x1F) << 6) |\n\t\tMII_ACCESS_MII_READ_;\n\tsmsc9420_reg_write(pd, MII_ACCESS, addr);\n\n\t \n\tfor (i = 0; i < 5; i++) {\n\t\tif (!(smsc9420_reg_read(pd, MII_ACCESS) &\n\t\t\tMII_ACCESS_MII_BUSY_)) {\n\t\t\treg = (u16)smsc9420_reg_read(pd, MII_DATA);\n\t\t\tgoto out;\n\t\t}\n\t\tudelay(10);\n\t}\n\n\tnetif_warn(pd, drv, pd->dev, \"MII busy timeout!\\n\");\n\nout:\n\tspin_unlock_irqrestore(&pd->phy_lock, flags);\n\treturn reg;\n}\n\nstatic int smsc9420_mii_write(struct mii_bus *bus, int phyaddr, int regidx,\n\t\t\t   u16 val)\n{\n\tstruct smsc9420_pdata *pd = bus->priv;\n\tunsigned long flags;\n\tu32 addr;\n\tint i, reg = -EIO;\n\n\tspin_lock_irqsave(&pd->phy_lock, flags);\n\n\t \n\tif ((smsc9420_reg_read(pd, MII_ACCESS) & MII_ACCESS_MII_BUSY_)) {\n\t\tnetif_warn(pd, drv, pd->dev, \"MII is busy???\\n\");\n\t\tgoto out;\n\t}\n\n\t \n\tsmsc9420_reg_write(pd, MII_DATA, (u32)val);\n\n\t \n\taddr = ((phyaddr & 0x1F) << 11) | ((regidx & 0x1F) << 6) |\n\t\tMII_ACCESS_MII_WRITE_;\n\tsmsc9420_reg_write(pd, MII_ACCESS, addr);\n\n\t \n\tfor (i = 0; i < 5; i++) {\n\t\tif (!(smsc9420_reg_read(pd, MII_ACCESS) &\n\t\t\tMII_ACCESS_MII_BUSY_)) {\n\t\t\treg = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tudelay(10);\n\t}\n\n\tnetif_warn(pd, drv, pd->dev, \"MII busy timeout!\\n\");\n\nout:\n\tspin_unlock_irqrestore(&pd->phy_lock, flags);\n\treturn reg;\n}\n\n \nstatic u32 smsc9420_hash(u8 addr[ETH_ALEN])\n{\n\treturn (ether_crc(ETH_ALEN, addr) >> 26) & 0x3f;\n}\n\nstatic int smsc9420_eeprom_reload(struct smsc9420_pdata *pd)\n{\n\tint timeout = 100000;\n\n\tBUG_ON(!pd);\n\n\tif (smsc9420_reg_read(pd, E2P_CMD) & E2P_CMD_EPC_BUSY_) {\n\t\tnetif_dbg(pd, drv, pd->dev, \"%s: Eeprom busy\\n\", __func__);\n\t\treturn -EIO;\n\t}\n\n\tsmsc9420_reg_write(pd, E2P_CMD,\n\t\t(E2P_CMD_EPC_BUSY_ | E2P_CMD_EPC_CMD_RELOAD_));\n\n\tdo {\n\t\tudelay(10);\n\t\tif (!(smsc9420_reg_read(pd, E2P_CMD) & E2P_CMD_EPC_BUSY_))\n\t\t\treturn 0;\n\t} while (timeout--);\n\n\tnetif_warn(pd, drv, pd->dev, \"%s: Eeprom timed out\\n\", __func__);\n\treturn -EIO;\n}\n\nstatic void smsc9420_ethtool_get_drvinfo(struct net_device *netdev,\n\t\t\t\t\t struct ethtool_drvinfo *drvinfo)\n{\n\tstruct smsc9420_pdata *pd = netdev_priv(netdev);\n\n\tstrscpy(drvinfo->driver, DRV_NAME, sizeof(drvinfo->driver));\n\tstrscpy(drvinfo->bus_info, pci_name(pd->pdev),\n\t\tsizeof(drvinfo->bus_info));\n\tstrscpy(drvinfo->version, DRV_VERSION, sizeof(drvinfo->version));\n}\n\nstatic u32 smsc9420_ethtool_get_msglevel(struct net_device *netdev)\n{\n\tstruct smsc9420_pdata *pd = netdev_priv(netdev);\n\treturn pd->msg_enable;\n}\n\nstatic void smsc9420_ethtool_set_msglevel(struct net_device *netdev, u32 data)\n{\n\tstruct smsc9420_pdata *pd = netdev_priv(netdev);\n\tpd->msg_enable = data;\n}\n\nstatic int smsc9420_ethtool_getregslen(struct net_device *dev)\n{\n\t \n\treturn 0x100 + (32 * sizeof(u32));\n}\n\nstatic void\nsmsc9420_ethtool_getregs(struct net_device *dev, struct ethtool_regs *regs,\n\t\t\t void *buf)\n{\n\tstruct smsc9420_pdata *pd = netdev_priv(dev);\n\tstruct phy_device *phy_dev = dev->phydev;\n\tunsigned int i, j = 0;\n\tu32 *data = buf;\n\n\tregs->version = smsc9420_reg_read(pd, ID_REV);\n\tfor (i = 0; i < 0x100; i += (sizeof(u32)))\n\t\tdata[j++] = smsc9420_reg_read(pd, i);\n\n\t\n\tif (!phy_dev)\n\t\treturn;\n\n\tfor (i = 0; i <= 31; i++)\n\t\tdata[j++] = smsc9420_mii_read(phy_dev->mdio.bus,\n\t\t\t\t\t      phy_dev->mdio.addr, i);\n}\n\nstatic void smsc9420_eeprom_enable_access(struct smsc9420_pdata *pd)\n{\n\tunsigned int temp = smsc9420_reg_read(pd, GPIO_CFG);\n\ttemp &= ~GPIO_CFG_EEPR_EN_;\n\tsmsc9420_reg_write(pd, GPIO_CFG, temp);\n\tmsleep(1);\n}\n\nstatic int smsc9420_eeprom_send_cmd(struct smsc9420_pdata *pd, u32 op)\n{\n\tint timeout = 100;\n\tu32 e2cmd;\n\n\tnetif_dbg(pd, hw, pd->dev, \"op 0x%08x\\n\", op);\n\tif (smsc9420_reg_read(pd, E2P_CMD) & E2P_CMD_EPC_BUSY_) {\n\t\tnetif_warn(pd, hw, pd->dev, \"Busy at start\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\te2cmd = op | E2P_CMD_EPC_BUSY_;\n\tsmsc9420_reg_write(pd, E2P_CMD, e2cmd);\n\n\tdo {\n\t\tmsleep(1);\n\t\te2cmd = smsc9420_reg_read(pd, E2P_CMD);\n\t} while ((e2cmd & E2P_CMD_EPC_BUSY_) && (--timeout));\n\n\tif (!timeout) {\n\t\tnetif_info(pd, hw, pd->dev, \"TIMED OUT\\n\");\n\t\treturn -EAGAIN;\n\t}\n\n\tif (e2cmd & E2P_CMD_EPC_TIMEOUT_) {\n\t\tnetif_info(pd, hw, pd->dev,\n\t\t\t   \"Error occurred during eeprom operation\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int smsc9420_eeprom_read_location(struct smsc9420_pdata *pd,\n\t\t\t\t\t u8 address, u8 *data)\n{\n\tu32 op = E2P_CMD_EPC_CMD_READ_ | address;\n\tint ret;\n\n\tnetif_dbg(pd, hw, pd->dev, \"address 0x%x\\n\", address);\n\tret = smsc9420_eeprom_send_cmd(pd, op);\n\n\tif (!ret)\n\t\tdata[address] = smsc9420_reg_read(pd, E2P_DATA);\n\n\treturn ret;\n}\n\nstatic int smsc9420_eeprom_write_location(struct smsc9420_pdata *pd,\n\t\t\t\t\t  u8 address, u8 data)\n{\n\tu32 op = E2P_CMD_EPC_CMD_ERASE_ | address;\n\tint ret;\n\n\tnetif_dbg(pd, hw, pd->dev, \"address 0x%x, data 0x%x\\n\", address, data);\n\tret = smsc9420_eeprom_send_cmd(pd, op);\n\n\tif (!ret) {\n\t\top = E2P_CMD_EPC_CMD_WRITE_ | address;\n\t\tsmsc9420_reg_write(pd, E2P_DATA, (u32)data);\n\t\tret = smsc9420_eeprom_send_cmd(pd, op);\n\t}\n\n\treturn ret;\n}\n\nstatic int smsc9420_ethtool_get_eeprom_len(struct net_device *dev)\n{\n\treturn SMSC9420_EEPROM_SIZE;\n}\n\nstatic int smsc9420_ethtool_get_eeprom(struct net_device *dev,\n\t\t\t\t       struct ethtool_eeprom *eeprom, u8 *data)\n{\n\tstruct smsc9420_pdata *pd = netdev_priv(dev);\n\tu8 eeprom_data[SMSC9420_EEPROM_SIZE];\n\tint len, i;\n\n\tsmsc9420_eeprom_enable_access(pd);\n\n\tlen = min(eeprom->len, SMSC9420_EEPROM_SIZE);\n\tfor (i = 0; i < len; i++) {\n\t\tint ret = smsc9420_eeprom_read_location(pd, i, eeprom_data);\n\t\tif (ret < 0) {\n\t\t\teeprom->len = 0;\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tmemcpy(data, &eeprom_data[eeprom->offset], len);\n\teeprom->magic = SMSC9420_EEPROM_MAGIC;\n\teeprom->len = len;\n\treturn 0;\n}\n\nstatic int smsc9420_ethtool_set_eeprom(struct net_device *dev,\n\t\t\t\t       struct ethtool_eeprom *eeprom, u8 *data)\n{\n\tstruct smsc9420_pdata *pd = netdev_priv(dev);\n\tint ret;\n\n\tif (eeprom->magic != SMSC9420_EEPROM_MAGIC)\n\t\treturn -EINVAL;\n\n\tsmsc9420_eeprom_enable_access(pd);\n\tsmsc9420_eeprom_send_cmd(pd, E2P_CMD_EPC_CMD_EWEN_);\n\tret = smsc9420_eeprom_write_location(pd, eeprom->offset, *data);\n\tsmsc9420_eeprom_send_cmd(pd, E2P_CMD_EPC_CMD_EWDS_);\n\n\t \n\teeprom->len = 1;\n\n\treturn ret;\n}\n\nstatic const struct ethtool_ops smsc9420_ethtool_ops = {\n\t.get_drvinfo = smsc9420_ethtool_get_drvinfo,\n\t.get_msglevel = smsc9420_ethtool_get_msglevel,\n\t.set_msglevel = smsc9420_ethtool_set_msglevel,\n\t.nway_reset = phy_ethtool_nway_reset,\n\t.get_link = ethtool_op_get_link,\n\t.get_eeprom_len = smsc9420_ethtool_get_eeprom_len,\n\t.get_eeprom = smsc9420_ethtool_get_eeprom,\n\t.set_eeprom = smsc9420_ethtool_set_eeprom,\n\t.get_regs_len = smsc9420_ethtool_getregslen,\n\t.get_regs = smsc9420_ethtool_getregs,\n\t.get_ts_info = ethtool_op_get_ts_info,\n\t.get_link_ksettings = phy_ethtool_get_link_ksettings,\n\t.set_link_ksettings = phy_ethtool_set_link_ksettings,\n};\n\n \nstatic void smsc9420_set_mac_address(struct net_device *dev)\n{\n\tstruct smsc9420_pdata *pd = netdev_priv(dev);\n\tconst u8 *dev_addr = dev->dev_addr;\n\tu32 mac_high16 = (dev_addr[5] << 8) | dev_addr[4];\n\tu32 mac_low32 = (dev_addr[3] << 24) | (dev_addr[2] << 16) |\n\t    (dev_addr[1] << 8) | dev_addr[0];\n\n\tsmsc9420_reg_write(pd, ADDRH, mac_high16);\n\tsmsc9420_reg_write(pd, ADDRL, mac_low32);\n}\n\nstatic void smsc9420_check_mac_address(struct net_device *dev)\n{\n\tstruct smsc9420_pdata *pd = netdev_priv(dev);\n\tu8 addr[ETH_ALEN];\n\n\t \n\tif (is_valid_ether_addr(dev->dev_addr)) {\n\t\tsmsc9420_set_mac_address(dev);\n\t\tnetif_dbg(pd, probe, pd->dev,\n\t\t\t  \"MAC Address is specified by configuration\\n\");\n\t} else {\n\t\t \n\t\tu32 mac_high16 = smsc9420_reg_read(pd, ADDRH);\n\t\tu32 mac_low32 = smsc9420_reg_read(pd, ADDRL);\n\t\taddr[0] = (u8)(mac_low32);\n\t\taddr[1] = (u8)(mac_low32 >> 8);\n\t\taddr[2] = (u8)(mac_low32 >> 16);\n\t\taddr[3] = (u8)(mac_low32 >> 24);\n\t\taddr[4] = (u8)(mac_high16);\n\t\taddr[5] = (u8)(mac_high16 >> 8);\n\n\t\tif (is_valid_ether_addr(addr)) {\n\t\t\t \n\t\t\teth_hw_addr_set(dev, addr);\n\t\t\tnetif_dbg(pd, probe, pd->dev,\n\t\t\t\t  \"Mac Address is read from EEPROM\\n\");\n\t\t} else {\n\t\t\t \n\t\t\teth_hw_addr_random(dev);\n\t\t\tsmsc9420_set_mac_address(dev);\n\t\t\tnetif_dbg(pd, probe, pd->dev,\n\t\t\t\t  \"MAC Address is set to random\\n\");\n\t\t}\n\t}\n}\n\nstatic void smsc9420_stop_tx(struct smsc9420_pdata *pd)\n{\n\tu32 dmac_control, mac_cr, dma_intr_ena;\n\tint timeout = 1000;\n\n\t \n\tdmac_control = smsc9420_reg_read(pd, DMAC_CONTROL);\n\tdmac_control &= (~DMAC_CONTROL_ST_);\n\tsmsc9420_reg_write(pd, DMAC_CONTROL, dmac_control);\n\n\t \n\twhile (--timeout) {\n\t\tif (smsc9420_reg_read(pd, DMAC_STATUS) & DMAC_STS_TS_)\n\t\t\tbreak;\n\t\tudelay(10);\n\t}\n\n\tif (!timeout)\n\t\tnetif_warn(pd, ifdown, pd->dev, \"TX DMAC failed to stop\\n\");\n\n\t \n\tsmsc9420_reg_write(pd, DMAC_STATUS, DMAC_STS_TXPS_);\n\n\t \n\tdma_intr_ena = smsc9420_reg_read(pd, DMAC_INTR_ENA);\n\tdma_intr_ena &= ~(DMAC_INTR_ENA_TX_);\n\tsmsc9420_reg_write(pd, DMAC_INTR_ENA, dma_intr_ena);\n\tsmsc9420_pci_flush_write(pd);\n\n\t \n\tmac_cr = smsc9420_reg_read(pd, MAC_CR) & (~MAC_CR_TXEN_);\n\tsmsc9420_reg_write(pd, MAC_CR, mac_cr);\n\tsmsc9420_pci_flush_write(pd);\n}\n\nstatic void smsc9420_free_tx_ring(struct smsc9420_pdata *pd)\n{\n\tint i;\n\n\tBUG_ON(!pd->tx_ring);\n\n\tif (!pd->tx_buffers)\n\t\treturn;\n\n\tfor (i = 0; i < TX_RING_SIZE; i++) {\n\t\tstruct sk_buff *skb = pd->tx_buffers[i].skb;\n\n\t\tif (skb) {\n\t\t\tBUG_ON(!pd->tx_buffers[i].mapping);\n\t\t\tdma_unmap_single(&pd->pdev->dev,\n\t\t\t\t\t pd->tx_buffers[i].mapping, skb->len,\n\t\t\t\t\t DMA_TO_DEVICE);\n\t\t\tdev_kfree_skb_any(skb);\n\t\t}\n\n\t\tpd->tx_ring[i].status = 0;\n\t\tpd->tx_ring[i].length = 0;\n\t\tpd->tx_ring[i].buffer1 = 0;\n\t\tpd->tx_ring[i].buffer2 = 0;\n\t}\n\twmb();\n\n\tkfree(pd->tx_buffers);\n\tpd->tx_buffers = NULL;\n\n\tpd->tx_ring_head = 0;\n\tpd->tx_ring_tail = 0;\n}\n\nstatic void smsc9420_free_rx_ring(struct smsc9420_pdata *pd)\n{\n\tint i;\n\n\tBUG_ON(!pd->rx_ring);\n\n\tif (!pd->rx_buffers)\n\t\treturn;\n\n\tfor (i = 0; i < RX_RING_SIZE; i++) {\n\t\tif (pd->rx_buffers[i].skb)\n\t\t\tdev_kfree_skb_any(pd->rx_buffers[i].skb);\n\n\t\tif (pd->rx_buffers[i].mapping)\n\t\t\tdma_unmap_single(&pd->pdev->dev,\n\t\t\t\t\t pd->rx_buffers[i].mapping,\n\t\t\t\t\t PKT_BUF_SZ, DMA_FROM_DEVICE);\n\n\t\tpd->rx_ring[i].status = 0;\n\t\tpd->rx_ring[i].length = 0;\n\t\tpd->rx_ring[i].buffer1 = 0;\n\t\tpd->rx_ring[i].buffer2 = 0;\n\t}\n\twmb();\n\n\tkfree(pd->rx_buffers);\n\tpd->rx_buffers = NULL;\n\n\tpd->rx_ring_head = 0;\n\tpd->rx_ring_tail = 0;\n}\n\nstatic void smsc9420_stop_rx(struct smsc9420_pdata *pd)\n{\n\tint timeout = 1000;\n\tu32 mac_cr, dmac_control, dma_intr_ena;\n\n\t \n\tdma_intr_ena = smsc9420_reg_read(pd, DMAC_INTR_ENA);\n\tdma_intr_ena &= (~DMAC_INTR_ENA_RX_);\n\tsmsc9420_reg_write(pd, DMAC_INTR_ENA, dma_intr_ena);\n\tsmsc9420_pci_flush_write(pd);\n\n\t \n\tmac_cr = smsc9420_reg_read(pd, MAC_CR) & (~MAC_CR_RXEN_);\n\tsmsc9420_reg_write(pd, MAC_CR, mac_cr);\n\tsmsc9420_pci_flush_write(pd);\n\n\t \n\tdmac_control = smsc9420_reg_read(pd, DMAC_CONTROL);\n\tdmac_control &= (~DMAC_CONTROL_SR_);\n\tsmsc9420_reg_write(pd, DMAC_CONTROL, dmac_control);\n\tsmsc9420_pci_flush_write(pd);\n\n\t \n\twhile (--timeout) {\n\t\tif (smsc9420_reg_read(pd, DMAC_STATUS) & DMAC_STS_RS_)\n\t\t\tbreak;\n\t\tudelay(10);\n\t}\n\n\tif (!timeout)\n\t\tnetif_warn(pd, ifdown, pd->dev,\n\t\t\t   \"RX DMAC did not stop! timeout\\n\");\n\n\t \n\tsmsc9420_reg_write(pd, DMAC_STATUS, DMAC_STS_RXPS_);\n}\n\nstatic irqreturn_t smsc9420_isr(int irq, void *dev_id)\n{\n\tstruct smsc9420_pdata *pd = dev_id;\n\tu32 int_cfg, int_sts, int_ctl;\n\tirqreturn_t ret = IRQ_NONE;\n\tulong flags;\n\n\tBUG_ON(!pd);\n\tBUG_ON(!pd->ioaddr);\n\n\tint_cfg = smsc9420_reg_read(pd, INT_CFG);\n\n\t \n\tif ((int_cfg & (INT_CFG_IRQ_EN_ | INT_CFG_IRQ_INT_)) !=\n\t    (INT_CFG_IRQ_EN_ | INT_CFG_IRQ_INT_))\n\t\treturn IRQ_NONE;\n\n\tint_sts = smsc9420_reg_read(pd, INT_STAT);\n\n\tif (likely(INT_STAT_DMAC_INT_ & int_sts)) {\n\t\tu32 status = smsc9420_reg_read(pd, DMAC_STATUS);\n\t\tu32 ints_to_clear = 0;\n\n\t\tif (status & DMAC_STS_TX_) {\n\t\t\tints_to_clear |= (DMAC_STS_TX_ | DMAC_STS_NIS_);\n\t\t\tnetif_wake_queue(pd->dev);\n\t\t}\n\n\t\tif (status & DMAC_STS_RX_) {\n\t\t\t \n\t\t\tu32 dma_intr_ena = smsc9420_reg_read(pd, DMAC_INTR_ENA);\n\t\t\tdma_intr_ena &= (~DMAC_INTR_ENA_RX_);\n\t\t\tsmsc9420_reg_write(pd, DMAC_INTR_ENA, dma_intr_ena);\n\t\t\tsmsc9420_pci_flush_write(pd);\n\n\t\t\tints_to_clear |= (DMAC_STS_RX_ | DMAC_STS_NIS_);\n\t\t\tnapi_schedule(&pd->napi);\n\t\t}\n\n\t\tif (ints_to_clear)\n\t\t\tsmsc9420_reg_write(pd, DMAC_STATUS, ints_to_clear);\n\n\t\tret = IRQ_HANDLED;\n\t}\n\n\tif (unlikely(INT_STAT_SW_INT_ & int_sts)) {\n\t\t \n\t\tspin_lock_irqsave(&pd->int_lock, flags);\n\t\tint_ctl = smsc9420_reg_read(pd, INT_CTL);\n\t\tint_ctl &= (~INT_CTL_SW_INT_EN_);\n\t\tsmsc9420_reg_write(pd, INT_CTL, int_ctl);\n\t\tspin_unlock_irqrestore(&pd->int_lock, flags);\n\n\t\tsmsc9420_reg_write(pd, INT_STAT, INT_STAT_SW_INT_);\n\t\tpd->software_irq_signal = true;\n\t\tsmp_wmb();\n\n\t\tret = IRQ_HANDLED;\n\t}\n\n\t \n\tsmsc9420_pci_flush_write(pd);\n\n\treturn ret;\n}\n\n#ifdef CONFIG_NET_POLL_CONTROLLER\nstatic void smsc9420_poll_controller(struct net_device *dev)\n{\n\tstruct smsc9420_pdata *pd = netdev_priv(dev);\n\tconst int irq = pd->pdev->irq;\n\n\tdisable_irq(irq);\n\tsmsc9420_isr(0, dev);\n\tenable_irq(irq);\n}\n#endif  \n\nstatic void smsc9420_dmac_soft_reset(struct smsc9420_pdata *pd)\n{\n\tsmsc9420_reg_write(pd, BUS_MODE, BUS_MODE_SWR_);\n\tsmsc9420_reg_read(pd, BUS_MODE);\n\tudelay(2);\n\tif (smsc9420_reg_read(pd, BUS_MODE) & BUS_MODE_SWR_)\n\t\tnetif_warn(pd, drv, pd->dev, \"Software reset not cleared\\n\");\n}\n\nstatic int smsc9420_stop(struct net_device *dev)\n{\n\tstruct smsc9420_pdata *pd = netdev_priv(dev);\n\tu32 int_cfg;\n\tulong flags;\n\n\tBUG_ON(!pd);\n\tBUG_ON(!dev->phydev);\n\n\t \n\tspin_lock_irqsave(&pd->int_lock, flags);\n\tint_cfg = smsc9420_reg_read(pd, INT_CFG) & (~INT_CFG_IRQ_EN_);\n\tsmsc9420_reg_write(pd, INT_CFG, int_cfg);\n\tspin_unlock_irqrestore(&pd->int_lock, flags);\n\n\tnetif_tx_disable(dev);\n\tnapi_disable(&pd->napi);\n\n\tsmsc9420_stop_tx(pd);\n\tsmsc9420_free_tx_ring(pd);\n\n\tsmsc9420_stop_rx(pd);\n\tsmsc9420_free_rx_ring(pd);\n\n\tfree_irq(pd->pdev->irq, pd);\n\n\tsmsc9420_dmac_soft_reset(pd);\n\n\tphy_stop(dev->phydev);\n\n\tphy_disconnect(dev->phydev);\n\tmdiobus_unregister(pd->mii_bus);\n\tmdiobus_free(pd->mii_bus);\n\n\treturn 0;\n}\n\nstatic void smsc9420_rx_count_stats(struct net_device *dev, u32 desc_status)\n{\n\tif (unlikely(desc_status & RDES0_ERROR_SUMMARY_)) {\n\t\tdev->stats.rx_errors++;\n\t\tif (desc_status & RDES0_DESCRIPTOR_ERROR_)\n\t\t\tdev->stats.rx_over_errors++;\n\t\telse if (desc_status & (RDES0_FRAME_TOO_LONG_ |\n\t\t\tRDES0_RUNT_FRAME_ | RDES0_COLLISION_SEEN_))\n\t\t\tdev->stats.rx_frame_errors++;\n\t\telse if (desc_status & RDES0_CRC_ERROR_)\n\t\t\tdev->stats.rx_crc_errors++;\n\t}\n\n\tif (unlikely(desc_status & RDES0_LENGTH_ERROR_))\n\t\tdev->stats.rx_length_errors++;\n\n\tif (unlikely(!((desc_status & RDES0_LAST_DESCRIPTOR_) &&\n\t\t(desc_status & RDES0_FIRST_DESCRIPTOR_))))\n\t\tdev->stats.rx_length_errors++;\n\n\tif (desc_status & RDES0_MULTICAST_FRAME_)\n\t\tdev->stats.multicast++;\n}\n\nstatic void smsc9420_rx_handoff(struct smsc9420_pdata *pd, const int index,\n\t\t\t\tconst u32 status)\n{\n\tstruct net_device *dev = pd->dev;\n\tstruct sk_buff *skb;\n\tu16 packet_length = (status & RDES0_FRAME_LENGTH_MASK_)\n\t\t>> RDES0_FRAME_LENGTH_SHFT_;\n\n\t \n\tpacket_length -= 4;\n\n\tif (pd->rx_csum)\n\t\tpacket_length -= 2;\n\n\tdev->stats.rx_packets++;\n\tdev->stats.rx_bytes += packet_length;\n\n\tdma_unmap_single(&pd->pdev->dev, pd->rx_buffers[index].mapping,\n\t\t\t PKT_BUF_SZ, DMA_FROM_DEVICE);\n\tpd->rx_buffers[index].mapping = 0;\n\n\tskb = pd->rx_buffers[index].skb;\n\tpd->rx_buffers[index].skb = NULL;\n\n\tif (pd->rx_csum) {\n\t\tu16 hw_csum = get_unaligned_le16(skb_tail_pointer(skb) +\n\t\t\tNET_IP_ALIGN + packet_length + 4);\n\t\tput_unaligned_le16(hw_csum, &skb->csum);\n\t\tskb->ip_summed = CHECKSUM_COMPLETE;\n\t}\n\n\tskb_reserve(skb, NET_IP_ALIGN);\n\tskb_put(skb, packet_length);\n\n\tskb->protocol = eth_type_trans(skb, dev);\n\n\tnetif_receive_skb(skb);\n}\n\nstatic int smsc9420_alloc_rx_buffer(struct smsc9420_pdata *pd, int index)\n{\n\tstruct sk_buff *skb = netdev_alloc_skb(pd->dev, PKT_BUF_SZ);\n\tdma_addr_t mapping;\n\n\tBUG_ON(pd->rx_buffers[index].skb);\n\tBUG_ON(pd->rx_buffers[index].mapping);\n\n\tif (unlikely(!skb))\n\t\treturn -ENOMEM;\n\n\tmapping = dma_map_single(&pd->pdev->dev, skb_tail_pointer(skb),\n\t\t\t\t PKT_BUF_SZ, DMA_FROM_DEVICE);\n\tif (dma_mapping_error(&pd->pdev->dev, mapping)) {\n\t\tdev_kfree_skb_any(skb);\n\t\tnetif_warn(pd, rx_err, pd->dev, \"dma_map_single failed!\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tpd->rx_buffers[index].skb = skb;\n\tpd->rx_buffers[index].mapping = mapping;\n\tpd->rx_ring[index].buffer1 = mapping + NET_IP_ALIGN;\n\tpd->rx_ring[index].status = RDES0_OWN_;\n\twmb();\n\n\treturn 0;\n}\n\nstatic void smsc9420_alloc_new_rx_buffers(struct smsc9420_pdata *pd)\n{\n\twhile (pd->rx_ring_tail != pd->rx_ring_head) {\n\t\tif (smsc9420_alloc_rx_buffer(pd, pd->rx_ring_tail))\n\t\t\tbreak;\n\n\t\tpd->rx_ring_tail = (pd->rx_ring_tail + 1) % RX_RING_SIZE;\n\t}\n}\n\nstatic int smsc9420_rx_poll(struct napi_struct *napi, int budget)\n{\n\tstruct smsc9420_pdata *pd =\n\t\tcontainer_of(napi, struct smsc9420_pdata, napi);\n\tstruct net_device *dev = pd->dev;\n\tu32 drop_frame_cnt, dma_intr_ena, status;\n\tint work_done;\n\n\tfor (work_done = 0; work_done < budget; work_done++) {\n\t\trmb();\n\t\tstatus = pd->rx_ring[pd->rx_ring_head].status;\n\n\t\t \n\t\tif (status & RDES0_OWN_)\n\t\t\tbreak;\n\n\t\tsmsc9420_rx_count_stats(dev, status);\n\t\tsmsc9420_rx_handoff(pd, pd->rx_ring_head, status);\n\t\tpd->rx_ring_head = (pd->rx_ring_head + 1) % RX_RING_SIZE;\n\t\tsmsc9420_alloc_new_rx_buffers(pd);\n\t}\n\n\tdrop_frame_cnt = smsc9420_reg_read(pd, MISS_FRAME_CNTR);\n\tdev->stats.rx_dropped +=\n\t    (drop_frame_cnt & 0xFFFF) + ((drop_frame_cnt >> 17) & 0x3FF);\n\n\t \n\tsmsc9420_reg_write(pd, RX_POLL_DEMAND, 1);\n\tsmsc9420_pci_flush_write(pd);\n\n\tif (work_done < budget) {\n\t\tnapi_complete_done(&pd->napi, work_done);\n\n\t\t \n\t\tdma_intr_ena = smsc9420_reg_read(pd, DMAC_INTR_ENA);\n\t\tdma_intr_ena |= (DMAC_INTR_ENA_RX_ | DMAC_INTR_ENA_NIS_);\n\t\tsmsc9420_reg_write(pd, DMAC_INTR_ENA, dma_intr_ena);\n\t\tsmsc9420_pci_flush_write(pd);\n\t}\n\treturn work_done;\n}\n\nstatic void\nsmsc9420_tx_update_stats(struct net_device *dev, u32 status, u32 length)\n{\n\tif (unlikely(status & TDES0_ERROR_SUMMARY_)) {\n\t\tdev->stats.tx_errors++;\n\t\tif (status & (TDES0_EXCESSIVE_DEFERRAL_ |\n\t\t\tTDES0_EXCESSIVE_COLLISIONS_))\n\t\t\tdev->stats.tx_aborted_errors++;\n\n\t\tif (status & (TDES0_LOSS_OF_CARRIER_ | TDES0_NO_CARRIER_))\n\t\t\tdev->stats.tx_carrier_errors++;\n\t} else {\n\t\tdev->stats.tx_packets++;\n\t\tdev->stats.tx_bytes += (length & 0x7FF);\n\t}\n\n\tif (unlikely(status & TDES0_EXCESSIVE_COLLISIONS_)) {\n\t\tdev->stats.collisions += 16;\n\t} else {\n\t\tdev->stats.collisions +=\n\t\t\t(status & TDES0_COLLISION_COUNT_MASK_) >>\n\t\t\tTDES0_COLLISION_COUNT_SHFT_;\n\t}\n\n\tif (unlikely(status & TDES0_HEARTBEAT_FAIL_))\n\t\tdev->stats.tx_heartbeat_errors++;\n}\n\n \nstatic void smsc9420_complete_tx(struct net_device *dev)\n{\n\tstruct smsc9420_pdata *pd = netdev_priv(dev);\n\n\twhile (pd->tx_ring_tail != pd->tx_ring_head) {\n\t\tint index = pd->tx_ring_tail;\n\t\tu32 status, length;\n\n\t\trmb();\n\t\tstatus = pd->tx_ring[index].status;\n\t\tlength = pd->tx_ring[index].length;\n\n\t\t \n\t\tif (unlikely(TDES0_OWN_ & status))\n\t\t\tbreak;\n\n\t\tsmsc9420_tx_update_stats(dev, status, length);\n\n\t\tBUG_ON(!pd->tx_buffers[index].skb);\n\t\tBUG_ON(!pd->tx_buffers[index].mapping);\n\n\t\tdma_unmap_single(&pd->pdev->dev,\n\t\t\t\t pd->tx_buffers[index].mapping,\n\t\t\t\t pd->tx_buffers[index].skb->len,\n\t\t\t\t DMA_TO_DEVICE);\n\t\tpd->tx_buffers[index].mapping = 0;\n\n\t\tdev_kfree_skb_any(pd->tx_buffers[index].skb);\n\t\tpd->tx_buffers[index].skb = NULL;\n\n\t\tpd->tx_ring[index].buffer1 = 0;\n\t\twmb();\n\n\t\tpd->tx_ring_tail = (pd->tx_ring_tail + 1) % TX_RING_SIZE;\n\t}\n}\n\nstatic netdev_tx_t smsc9420_hard_start_xmit(struct sk_buff *skb,\n\t\t\t\t\t    struct net_device *dev)\n{\n\tstruct smsc9420_pdata *pd = netdev_priv(dev);\n\tdma_addr_t mapping;\n\tint index = pd->tx_ring_head;\n\tu32 tmp_desc1;\n\tbool about_to_take_last_desc =\n\t\t(((pd->tx_ring_head + 2) % TX_RING_SIZE) == pd->tx_ring_tail);\n\n\tsmsc9420_complete_tx(dev);\n\n\trmb();\n\tBUG_ON(pd->tx_ring[index].status & TDES0_OWN_);\n\tBUG_ON(pd->tx_buffers[index].skb);\n\tBUG_ON(pd->tx_buffers[index].mapping);\n\n\tmapping = dma_map_single(&pd->pdev->dev, skb->data, skb->len,\n\t\t\t\t DMA_TO_DEVICE);\n\tif (dma_mapping_error(&pd->pdev->dev, mapping)) {\n\t\tnetif_warn(pd, tx_err, pd->dev,\n\t\t\t   \"dma_map_single failed, dropping packet\\n\");\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\n\tpd->tx_buffers[index].skb = skb;\n\tpd->tx_buffers[index].mapping = mapping;\n\n\ttmp_desc1 = (TDES1_LS_ | ((u32)skb->len & 0x7FF));\n\tif (unlikely(about_to_take_last_desc)) {\n\t\ttmp_desc1 |= TDES1_IC_;\n\t\tnetif_stop_queue(pd->dev);\n\t}\n\n\t \n\tif (unlikely(index == (TX_RING_SIZE - 1)))\n\t\ttmp_desc1 |= TDES1_TER_;\n\n\tpd->tx_ring[index].buffer1 = mapping;\n\tpd->tx_ring[index].length = tmp_desc1;\n\twmb();\n\n\t \n\tpd->tx_ring_head = (pd->tx_ring_head + 1) % TX_RING_SIZE;\n\n\t \n\tpd->tx_ring[index].status = TDES0_OWN_;\n\twmb();\n\n\tskb_tx_timestamp(skb);\n\n\t \n\tsmsc9420_reg_write(pd, TX_POLL_DEMAND, 1);\n\tsmsc9420_pci_flush_write(pd);\n\n\treturn NETDEV_TX_OK;\n}\n\nstatic struct net_device_stats *smsc9420_get_stats(struct net_device *dev)\n{\n\tstruct smsc9420_pdata *pd = netdev_priv(dev);\n\tu32 counter = smsc9420_reg_read(pd, MISS_FRAME_CNTR);\n\tdev->stats.rx_dropped +=\n\t    (counter & 0x0000FFFF) + ((counter >> 17) & 0x000003FF);\n\treturn &dev->stats;\n}\n\nstatic void smsc9420_set_multicast_list(struct net_device *dev)\n{\n\tstruct smsc9420_pdata *pd = netdev_priv(dev);\n\tu32 mac_cr = smsc9420_reg_read(pd, MAC_CR);\n\n\tif (dev->flags & IFF_PROMISC) {\n\t\tnetif_dbg(pd, hw, pd->dev, \"Promiscuous Mode Enabled\\n\");\n\t\tmac_cr |= MAC_CR_PRMS_;\n\t\tmac_cr &= (~MAC_CR_MCPAS_);\n\t\tmac_cr &= (~MAC_CR_HPFILT_);\n\t} else if (dev->flags & IFF_ALLMULTI) {\n\t\tnetif_dbg(pd, hw, pd->dev, \"Receive all Multicast Enabled\\n\");\n\t\tmac_cr &= (~MAC_CR_PRMS_);\n\t\tmac_cr |= MAC_CR_MCPAS_;\n\t\tmac_cr &= (~MAC_CR_HPFILT_);\n\t} else if (!netdev_mc_empty(dev)) {\n\t\tstruct netdev_hw_addr *ha;\n\t\tu32 hash_lo = 0, hash_hi = 0;\n\n\t\tnetif_dbg(pd, hw, pd->dev, \"Multicast filter enabled\\n\");\n\t\tnetdev_for_each_mc_addr(ha, dev) {\n\t\t\tu32 bit_num = smsc9420_hash(ha->addr);\n\t\t\tu32 mask = 1 << (bit_num & 0x1F);\n\n\t\t\tif (bit_num & 0x20)\n\t\t\t\thash_hi |= mask;\n\t\t\telse\n\t\t\t\thash_lo |= mask;\n\n\t\t}\n\t\tsmsc9420_reg_write(pd, HASHH, hash_hi);\n\t\tsmsc9420_reg_write(pd, HASHL, hash_lo);\n\n\t\tmac_cr &= (~MAC_CR_PRMS_);\n\t\tmac_cr &= (~MAC_CR_MCPAS_);\n\t\tmac_cr |= MAC_CR_HPFILT_;\n\t} else {\n\t\tnetif_dbg(pd, hw, pd->dev, \"Receive own packets only\\n\");\n\t\tsmsc9420_reg_write(pd, HASHH, 0);\n\t\tsmsc9420_reg_write(pd, HASHL, 0);\n\n\t\tmac_cr &= (~MAC_CR_PRMS_);\n\t\tmac_cr &= (~MAC_CR_MCPAS_);\n\t\tmac_cr &= (~MAC_CR_HPFILT_);\n\t}\n\n\tsmsc9420_reg_write(pd, MAC_CR, mac_cr);\n\tsmsc9420_pci_flush_write(pd);\n}\n\nstatic void smsc9420_phy_update_flowcontrol(struct smsc9420_pdata *pd)\n{\n\tstruct net_device *dev = pd->dev;\n\tstruct phy_device *phy_dev = dev->phydev;\n\tu32 flow;\n\n\tif (phy_dev->duplex == DUPLEX_FULL) {\n\t\tu16 lcladv = phy_read(phy_dev, MII_ADVERTISE);\n\t\tu16 rmtadv = phy_read(phy_dev, MII_LPA);\n\t\tu8 cap = mii_resolve_flowctrl_fdx(lcladv, rmtadv);\n\n\t\tif (cap & FLOW_CTRL_RX)\n\t\t\tflow = 0xFFFF0002;\n\t\telse\n\t\t\tflow = 0;\n\n\t\tnetif_info(pd, link, pd->dev, \"rx pause %s, tx pause %s\\n\",\n\t\t\t   cap & FLOW_CTRL_RX ? \"enabled\" : \"disabled\",\n\t\t\t   cap & FLOW_CTRL_TX ? \"enabled\" : \"disabled\");\n\t} else {\n\t\tnetif_info(pd, link, pd->dev, \"half duplex\\n\");\n\t\tflow = 0;\n\t}\n\n\tsmsc9420_reg_write(pd, FLOW, flow);\n}\n\n \nstatic void smsc9420_phy_adjust_link(struct net_device *dev)\n{\n\tstruct smsc9420_pdata *pd = netdev_priv(dev);\n\tstruct phy_device *phy_dev = dev->phydev;\n\tint carrier;\n\n\tif (phy_dev->duplex != pd->last_duplex) {\n\t\tu32 mac_cr = smsc9420_reg_read(pd, MAC_CR);\n\t\tif (phy_dev->duplex) {\n\t\t\tnetif_dbg(pd, link, pd->dev, \"full duplex mode\\n\");\n\t\t\tmac_cr |= MAC_CR_FDPX_;\n\t\t} else {\n\t\t\tnetif_dbg(pd, link, pd->dev, \"half duplex mode\\n\");\n\t\t\tmac_cr &= ~MAC_CR_FDPX_;\n\t\t}\n\t\tsmsc9420_reg_write(pd, MAC_CR, mac_cr);\n\n\t\tsmsc9420_phy_update_flowcontrol(pd);\n\t\tpd->last_duplex = phy_dev->duplex;\n\t}\n\n\tcarrier = netif_carrier_ok(dev);\n\tif (carrier != pd->last_carrier) {\n\t\tif (carrier)\n\t\t\tnetif_dbg(pd, link, pd->dev, \"carrier OK\\n\");\n\t\telse\n\t\t\tnetif_dbg(pd, link, pd->dev, \"no carrier\\n\");\n\t\tpd->last_carrier = carrier;\n\t}\n}\n\nstatic int smsc9420_mii_probe(struct net_device *dev)\n{\n\tstruct smsc9420_pdata *pd = netdev_priv(dev);\n\tstruct phy_device *phydev = NULL;\n\n\tBUG_ON(dev->phydev);\n\n\t \n\tphydev = mdiobus_get_phy(pd->mii_bus, 1);\n\tif (!phydev) {\n\t\tnetdev_err(dev, \"no PHY found at address 1\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tphydev = phy_connect(dev, phydev_name(phydev),\n\t\t\t     smsc9420_phy_adjust_link, PHY_INTERFACE_MODE_MII);\n\n\tif (IS_ERR(phydev)) {\n\t\tnetdev_err(dev, \"Could not attach to PHY\\n\");\n\t\treturn PTR_ERR(phydev);\n\t}\n\n\tphy_set_max_speed(phydev, SPEED_100);\n\n\t \n\tphy_support_asym_pause(phydev);\n\n\tphy_attached_info(phydev);\n\n\tpd->last_duplex = -1;\n\tpd->last_carrier = -1;\n\n\treturn 0;\n}\n\nstatic int smsc9420_mii_init(struct net_device *dev)\n{\n\tstruct smsc9420_pdata *pd = netdev_priv(dev);\n\tint err = -ENXIO;\n\n\tpd->mii_bus = mdiobus_alloc();\n\tif (!pd->mii_bus) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out_1;\n\t}\n\tpd->mii_bus->name = DRV_MDIONAME;\n\tsnprintf(pd->mii_bus->id, MII_BUS_ID_SIZE, \"%x\", pci_dev_id(pd->pdev));\n\tpd->mii_bus->priv = pd;\n\tpd->mii_bus->read = smsc9420_mii_read;\n\tpd->mii_bus->write = smsc9420_mii_write;\n\n\t \n\tpd->mii_bus->phy_mask = ~(1 << 1);\n\n\tif (mdiobus_register(pd->mii_bus)) {\n\t\tnetif_warn(pd, probe, pd->dev, \"Error registering mii bus\\n\");\n\t\tgoto err_out_free_bus_2;\n\t}\n\n\tif (smsc9420_mii_probe(dev) < 0) {\n\t\tnetif_warn(pd, probe, pd->dev, \"Error probing mii bus\\n\");\n\t\tgoto err_out_unregister_bus_3;\n\t}\n\n\treturn 0;\n\nerr_out_unregister_bus_3:\n\tmdiobus_unregister(pd->mii_bus);\nerr_out_free_bus_2:\n\tmdiobus_free(pd->mii_bus);\nerr_out_1:\n\treturn err;\n}\n\nstatic int smsc9420_alloc_tx_ring(struct smsc9420_pdata *pd)\n{\n\tint i;\n\n\tBUG_ON(!pd->tx_ring);\n\n\tpd->tx_buffers = kmalloc_array(TX_RING_SIZE,\n\t\t\t\t       sizeof(struct smsc9420_ring_info),\n\t\t\t\t       GFP_KERNEL);\n\tif (!pd->tx_buffers)\n\t\treturn -ENOMEM;\n\n\t \n\tfor (i = 0; i < TX_RING_SIZE; i++) {\n\t\tpd->tx_buffers[i].skb = NULL;\n\t\tpd->tx_buffers[i].mapping = 0;\n\t\tpd->tx_ring[i].status = 0;\n\t\tpd->tx_ring[i].length = 0;\n\t\tpd->tx_ring[i].buffer1 = 0;\n\t\tpd->tx_ring[i].buffer2 = 0;\n\t}\n\tpd->tx_ring[TX_RING_SIZE - 1].length = TDES1_TER_;\n\twmb();\n\n\tpd->tx_ring_head = 0;\n\tpd->tx_ring_tail = 0;\n\n\tsmsc9420_reg_write(pd, TX_BASE_ADDR, pd->tx_dma_addr);\n\tsmsc9420_pci_flush_write(pd);\n\n\treturn 0;\n}\n\nstatic int smsc9420_alloc_rx_ring(struct smsc9420_pdata *pd)\n{\n\tint i;\n\n\tBUG_ON(!pd->rx_ring);\n\n\tpd->rx_buffers = kmalloc_array(RX_RING_SIZE,\n\t\t\t\t       sizeof(struct smsc9420_ring_info),\n\t\t\t\t       GFP_KERNEL);\n\tif (pd->rx_buffers == NULL)\n\t\tgoto out;\n\n\t \n\tfor (i = 0; i < RX_RING_SIZE; i++) {\n\t\tpd->rx_ring[i].status = 0;\n\t\tpd->rx_ring[i].length = PKT_BUF_SZ;\n\t\tpd->rx_ring[i].buffer2 = 0;\n\t\tpd->rx_buffers[i].skb = NULL;\n\t\tpd->rx_buffers[i].mapping = 0;\n\t}\n\tpd->rx_ring[RX_RING_SIZE - 1].length = (PKT_BUF_SZ | RDES1_RER_);\n\n\t \n\tfor (i = 0; i < RX_RING_SIZE; i++) {\n\t\tif (smsc9420_alloc_rx_buffer(pd, i)) {\n\t\t\tnetif_warn(pd, ifup, pd->dev,\n\t\t\t\t   \"failed to allocate rx skb %d\\n\", i);\n\t\t\tgoto out_free_rx_skbs;\n\t\t}\n\t}\n\n\tpd->rx_ring_head = 0;\n\tpd->rx_ring_tail = 0;\n\n\tsmsc9420_reg_write(pd, VLAN1, ETH_P_8021Q);\n\tnetif_dbg(pd, ifup, pd->dev, \"VLAN1 = 0x%08x\\n\",\n\t\t  smsc9420_reg_read(pd, VLAN1));\n\n\tif (pd->rx_csum) {\n\t\t \n\t\tu32 coe = smsc9420_reg_read(pd, COE_CR) | RX_COE_EN;\n\t\tsmsc9420_reg_write(pd, COE_CR, coe);\n\t\tnetif_dbg(pd, ifup, pd->dev, \"COE_CR = 0x%08x\\n\", coe);\n\t}\n\n\tsmsc9420_reg_write(pd, RX_BASE_ADDR, pd->rx_dma_addr);\n\tsmsc9420_pci_flush_write(pd);\n\n\treturn 0;\n\nout_free_rx_skbs:\n\tsmsc9420_free_rx_ring(pd);\nout:\n\treturn -ENOMEM;\n}\n\nstatic int smsc9420_open(struct net_device *dev)\n{\n\tstruct smsc9420_pdata *pd = netdev_priv(dev);\n\tu32 bus_mode, mac_cr, dmac_control, int_cfg, dma_intr_ena, int_ctl;\n\tconst int irq = pd->pdev->irq;\n\tunsigned long flags;\n\tint result = 0, timeout;\n\n\tif (!is_valid_ether_addr(dev->dev_addr)) {\n\t\tnetif_warn(pd, ifup, pd->dev,\n\t\t\t   \"dev_addr is not a valid MAC address\\n\");\n\t\tresult = -EADDRNOTAVAIL;\n\t\tgoto out_0;\n\t}\n\n\tnetif_carrier_off(dev);\n\n\t \n\tspin_lock_irqsave(&pd->int_lock, flags);\n\tint_cfg = smsc9420_reg_read(pd, INT_CFG) & (~INT_CFG_IRQ_EN_);\n\tsmsc9420_reg_write(pd, INT_CFG, int_cfg);\n\tsmsc9420_reg_write(pd, INT_CTL, 0);\n\tspin_unlock_irqrestore(&pd->int_lock, flags);\n\tsmsc9420_reg_write(pd, DMAC_INTR_ENA, 0);\n\tsmsc9420_reg_write(pd, INT_STAT, 0xFFFFFFFF);\n\tsmsc9420_pci_flush_write(pd);\n\n\tresult = request_irq(irq, smsc9420_isr, IRQF_SHARED, DRV_NAME, pd);\n\tif (result) {\n\t\tnetif_warn(pd, ifup, pd->dev, \"Unable to use IRQ = %d\\n\", irq);\n\t\tresult = -ENODEV;\n\t\tgoto out_0;\n\t}\n\n\tsmsc9420_dmac_soft_reset(pd);\n\n\t \n\tsmsc9420_reg_write(pd, MAC_CR, 0);\n\n\tsmsc9420_set_mac_address(dev);\n\n\t \n\tsmsc9420_reg_write(pd, GPIO_CFG,\n\t\t(GPIO_CFG_LED_3_ | GPIO_CFG_LED_2_ | GPIO_CFG_LED_1_));\n\n\tbus_mode = BUS_MODE_DMA_BURST_LENGTH_16;\n\n#ifdef __BIG_ENDIAN\n\tbus_mode |= BUS_MODE_DBO_;\n#endif\n\n\tsmsc9420_reg_write(pd, BUS_MODE, bus_mode);\n\n\tsmsc9420_pci_flush_write(pd);\n\n\t \n\tsmsc9420_reg_write(pd, BUS_CFG, BUS_CFG_RXTXWEIGHT_4_1);\n\n\tsmsc9420_reg_write(pd, DMAC_CONTROL,\n\t\t(DMAC_CONTROL_SF_ | DMAC_CONTROL_OSF_));\n\n\tsmsc9420_pci_flush_write(pd);\n\n\t \n\tnetif_dbg(pd, ifup, pd->dev, \"Testing ISR using IRQ %d\\n\", irq);\n\tpd->software_irq_signal = false;\n\n\tspin_lock_irqsave(&pd->int_lock, flags);\n\t \n\tint_cfg = smsc9420_reg_read(pd, INT_CFG) | INT_CFG_IRQ_EN_;\n\tint_cfg &= ~(INT_CFG_INT_DEAS_MASK);\n\tint_cfg |= (INT_DEAS_TIME & INT_CFG_INT_DEAS_MASK);\n\tsmsc9420_reg_write(pd, INT_CFG, int_cfg);\n\n\t \n\tint_ctl = smsc9420_reg_read(pd, INT_CTL) | INT_CTL_SW_INT_EN_;\n\tsmsc9420_reg_write(pd, INT_CTL, int_ctl);\n\tspin_unlock_irqrestore(&pd->int_lock, flags);\n\tsmsc9420_pci_flush_write(pd);\n\n\ttimeout = 1000;\n\twhile (timeout--) {\n\t\tif (pd->software_irq_signal)\n\t\t\tbreak;\n\t\tmsleep(1);\n\t}\n\n\t \n\tspin_lock_irqsave(&pd->int_lock, flags);\n\tint_cfg = smsc9420_reg_read(pd, INT_CFG) & (~INT_CFG_IRQ_EN_);\n\tsmsc9420_reg_write(pd, INT_CFG, int_cfg);\n\tspin_unlock_irqrestore(&pd->int_lock, flags);\n\n\tif (!pd->software_irq_signal) {\n\t\tnetif_warn(pd, ifup, pd->dev, \"ISR failed signaling test\\n\");\n\t\tresult = -ENODEV;\n\t\tgoto out_free_irq_1;\n\t}\n\n\tnetif_dbg(pd, ifup, pd->dev, \"ISR passed test using IRQ %d\\n\", irq);\n\n\tresult = smsc9420_alloc_tx_ring(pd);\n\tif (result) {\n\t\tnetif_warn(pd, ifup, pd->dev,\n\t\t\t   \"Failed to Initialize tx dma ring\\n\");\n\t\tresult = -ENOMEM;\n\t\tgoto out_free_irq_1;\n\t}\n\n\tresult = smsc9420_alloc_rx_ring(pd);\n\tif (result) {\n\t\tnetif_warn(pd, ifup, pd->dev,\n\t\t\t   \"Failed to Initialize rx dma ring\\n\");\n\t\tresult = -ENOMEM;\n\t\tgoto out_free_tx_ring_2;\n\t}\n\n\tresult = smsc9420_mii_init(dev);\n\tif (result) {\n\t\tnetif_warn(pd, ifup, pd->dev, \"Failed to initialize Phy\\n\");\n\t\tresult = -ENODEV;\n\t\tgoto out_free_rx_ring_3;\n\t}\n\n\t \n\tphy_start(dev->phydev);\n\n\tnapi_enable(&pd->napi);\n\n\t \n\tmac_cr = smsc9420_reg_read(pd, MAC_CR) | MAC_CR_TXEN_ | MAC_CR_RXEN_;\n\tsmsc9420_reg_write(pd, MAC_CR, mac_cr);\n\n\tdmac_control = smsc9420_reg_read(pd, DMAC_CONTROL);\n\tdmac_control |= DMAC_CONTROL_ST_ | DMAC_CONTROL_SR_;\n\tsmsc9420_reg_write(pd, DMAC_CONTROL, dmac_control);\n\tsmsc9420_pci_flush_write(pd);\n\n\tdma_intr_ena = smsc9420_reg_read(pd, DMAC_INTR_ENA);\n\tdma_intr_ena |=\n\t\t(DMAC_INTR_ENA_TX_ | DMAC_INTR_ENA_RX_ | DMAC_INTR_ENA_NIS_);\n\tsmsc9420_reg_write(pd, DMAC_INTR_ENA, dma_intr_ena);\n\tsmsc9420_pci_flush_write(pd);\n\n\tnetif_wake_queue(dev);\n\n\tsmsc9420_reg_write(pd, RX_POLL_DEMAND, 1);\n\n\t \n\tspin_lock_irqsave(&pd->int_lock, flags);\n\tint_cfg = smsc9420_reg_read(pd, INT_CFG) | INT_CFG_IRQ_EN_;\n\tsmsc9420_reg_write(pd, INT_CFG, int_cfg);\n\tspin_unlock_irqrestore(&pd->int_lock, flags);\n\n\treturn 0;\n\nout_free_rx_ring_3:\n\tsmsc9420_free_rx_ring(pd);\nout_free_tx_ring_2:\n\tsmsc9420_free_tx_ring(pd);\nout_free_irq_1:\n\tfree_irq(irq, pd);\nout_0:\n\treturn result;\n}\n\nstatic int __maybe_unused smsc9420_suspend(struct device *dev_d)\n{\n\tstruct net_device *dev = dev_get_drvdata(dev_d);\n\tstruct smsc9420_pdata *pd = netdev_priv(dev);\n\tu32 int_cfg;\n\tulong flags;\n\n\t \n\tspin_lock_irqsave(&pd->int_lock, flags);\n\tint_cfg = smsc9420_reg_read(pd, INT_CFG) & (~INT_CFG_IRQ_EN_);\n\tsmsc9420_reg_write(pd, INT_CFG, int_cfg);\n\tspin_unlock_irqrestore(&pd->int_lock, flags);\n\n\tif (netif_running(dev)) {\n\t\tnetif_tx_disable(dev);\n\t\tsmsc9420_stop_tx(pd);\n\t\tsmsc9420_free_tx_ring(pd);\n\n\t\tnapi_disable(&pd->napi);\n\t\tsmsc9420_stop_rx(pd);\n\t\tsmsc9420_free_rx_ring(pd);\n\n\t\tfree_irq(pd->pdev->irq, pd);\n\n\t\tnetif_device_detach(dev);\n\t}\n\n\tdevice_wakeup_disable(dev_d);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused smsc9420_resume(struct device *dev_d)\n{\n\tstruct net_device *dev = dev_get_drvdata(dev_d);\n\tint err;\n\n\tpci_set_master(to_pci_dev(dev_d));\n\n\tdevice_wakeup_disable(dev_d);\n\n\terr = 0;\n\tif (netif_running(dev)) {\n\t\t \n\t\terr = smsc9420_open(dev);\n\t\tnetif_device_attach(dev);\n\t}\n\treturn err;\n}\n\nstatic const struct net_device_ops smsc9420_netdev_ops = {\n\t.ndo_open\t\t= smsc9420_open,\n\t.ndo_stop\t\t= smsc9420_stop,\n\t.ndo_start_xmit\t\t= smsc9420_hard_start_xmit,\n\t.ndo_get_stats\t\t= smsc9420_get_stats,\n\t.ndo_set_rx_mode\t= smsc9420_set_multicast_list,\n\t.ndo_eth_ioctl\t\t= phy_do_ioctl_running,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_set_mac_address \t= eth_mac_addr,\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\t.ndo_poll_controller\t= smsc9420_poll_controller,\n#endif  \n};\n\nstatic int\nsmsc9420_probe(struct pci_dev *pdev, const struct pci_device_id *id)\n{\n\tstruct net_device *dev;\n\tstruct smsc9420_pdata *pd;\n\tvoid __iomem *virt_addr;\n\tint result = 0;\n\tu32 id_rev;\n\n\tpr_info(\"%s version %s\\n\", DRV_DESCRIPTION, DRV_VERSION);\n\n\t \n\tresult = pci_enable_device(pdev);\n\tif (unlikely(result)) {\n\t\tpr_err(\"Cannot enable smsc9420\\n\");\n\t\tgoto out_0;\n\t}\n\n\tpci_set_master(pdev);\n\n\tdev = alloc_etherdev(sizeof(*pd));\n\tif (!dev)\n\t\tgoto out_disable_pci_device_1;\n\n\tSET_NETDEV_DEV(dev, &pdev->dev);\n\n\tif (!(pci_resource_flags(pdev, SMSC_BAR) & IORESOURCE_MEM)) {\n\t\tnetdev_err(dev, \"Cannot find PCI device base address\\n\");\n\t\tgoto out_free_netdev_2;\n\t}\n\n\tif ((pci_request_regions(pdev, DRV_NAME))) {\n\t\tnetdev_err(dev, \"Cannot obtain PCI resources, aborting\\n\");\n\t\tgoto out_free_netdev_2;\n\t}\n\n\tif (dma_set_mask(&pdev->dev, DMA_BIT_MASK(32))) {\n\t\tnetdev_err(dev, \"No usable DMA configuration, aborting\\n\");\n\t\tgoto out_free_regions_3;\n\t}\n\n\tvirt_addr = ioremap(pci_resource_start(pdev, SMSC_BAR),\n\t\tpci_resource_len(pdev, SMSC_BAR));\n\tif (!virt_addr) {\n\t\tnetdev_err(dev, \"Cannot map device registers, aborting\\n\");\n\t\tgoto out_free_regions_3;\n\t}\n\n\t \n\tvirt_addr += LAN9420_CPSR_ENDIAN_OFFSET;\n\n\tpd = netdev_priv(dev);\n\n\t \n\tpd->rx_ring = dma_alloc_coherent(&pdev->dev,\n\t\tsizeof(struct smsc9420_dma_desc) * (RX_RING_SIZE + TX_RING_SIZE),\n\t\t&pd->rx_dma_addr, GFP_KERNEL);\n\n\tif (!pd->rx_ring)\n\t\tgoto out_free_io_4;\n\n\t \n\tpd->tx_ring = (pd->rx_ring + RX_RING_SIZE);\n\tpd->tx_dma_addr = pd->rx_dma_addr +\n\t    sizeof(struct smsc9420_dma_desc) * RX_RING_SIZE;\n\n\tpd->pdev = pdev;\n\tpd->dev = dev;\n\tpd->ioaddr = virt_addr;\n\tpd->msg_enable = smsc_debug;\n\tpd->rx_csum = true;\n\n\tnetif_dbg(pd, probe, pd->dev, \"lan_base=0x%08lx\\n\", (ulong)virt_addr);\n\n\tid_rev = smsc9420_reg_read(pd, ID_REV);\n\tswitch (id_rev & 0xFFFF0000) {\n\tcase 0x94200000:\n\t\tnetif_info(pd, probe, pd->dev,\n\t\t\t   \"LAN9420 identified, ID_REV=0x%08X\\n\", id_rev);\n\t\tbreak;\n\tdefault:\n\t\tnetif_warn(pd, probe, pd->dev, \"LAN9420 NOT identified\\n\");\n\t\tnetif_warn(pd, probe, pd->dev, \"ID_REV=0x%08X\\n\", id_rev);\n\t\tgoto out_free_dmadesc_5;\n\t}\n\n\tsmsc9420_dmac_soft_reset(pd);\n\tsmsc9420_eeprom_reload(pd);\n\tsmsc9420_check_mac_address(dev);\n\n\tdev->netdev_ops = &smsc9420_netdev_ops;\n\tdev->ethtool_ops = &smsc9420_ethtool_ops;\n\n\tnetif_napi_add(dev, &pd->napi, smsc9420_rx_poll);\n\n\tresult = register_netdev(dev);\n\tif (result) {\n\t\tnetif_warn(pd, probe, pd->dev, \"error %i registering device\\n\",\n\t\t\t   result);\n\t\tgoto out_free_dmadesc_5;\n\t}\n\n\tpci_set_drvdata(pdev, dev);\n\n\tspin_lock_init(&pd->int_lock);\n\tspin_lock_init(&pd->phy_lock);\n\n\tdev_info(&dev->dev, \"MAC Address: %pM\\n\", dev->dev_addr);\n\n\treturn 0;\n\nout_free_dmadesc_5:\n\tdma_free_coherent(&pdev->dev,\n\t\t\t  sizeof(struct smsc9420_dma_desc) * (RX_RING_SIZE + TX_RING_SIZE),\n\t\t\t  pd->rx_ring, pd->rx_dma_addr);\nout_free_io_4:\n\tiounmap(virt_addr - LAN9420_CPSR_ENDIAN_OFFSET);\nout_free_regions_3:\n\tpci_release_regions(pdev);\nout_free_netdev_2:\n\tfree_netdev(dev);\nout_disable_pci_device_1:\n\tpci_disable_device(pdev);\nout_0:\n\treturn -ENODEV;\n}\n\nstatic void smsc9420_remove(struct pci_dev *pdev)\n{\n\tstruct net_device *dev;\n\tstruct smsc9420_pdata *pd;\n\n\tdev = pci_get_drvdata(pdev);\n\tif (!dev)\n\t\treturn;\n\n\tpd = netdev_priv(dev);\n\tunregister_netdev(dev);\n\n\t \n\tBUG_ON(pd->tx_buffers);\n\tBUG_ON(pd->rx_buffers);\n\n\tBUG_ON(!pd->tx_ring);\n\tBUG_ON(!pd->rx_ring);\n\n\tdma_free_coherent(&pdev->dev,\n\t\t\t  sizeof(struct smsc9420_dma_desc) * (RX_RING_SIZE + TX_RING_SIZE),\n\t\t\t  pd->rx_ring, pd->rx_dma_addr);\n\n\tiounmap(pd->ioaddr - LAN9420_CPSR_ENDIAN_OFFSET);\n\tpci_release_regions(pdev);\n\tfree_netdev(dev);\n\tpci_disable_device(pdev);\n}\n\nstatic SIMPLE_DEV_PM_OPS(smsc9420_pm_ops, smsc9420_suspend, smsc9420_resume);\n\nstatic struct pci_driver smsc9420_driver = {\n\t.name = DRV_NAME,\n\t.id_table = smsc9420_id_table,\n\t.probe = smsc9420_probe,\n\t.remove = smsc9420_remove,\n\t.driver.pm = &smsc9420_pm_ops,\n};\n\nstatic int __init smsc9420_init_module(void)\n{\n\tsmsc_debug = netif_msg_init(debug, SMSC_MSG_DEFAULT);\n\n\treturn pci_register_driver(&smsc9420_driver);\n}\n\nstatic void __exit smsc9420_exit_module(void)\n{\n\tpci_unregister_driver(&smsc9420_driver);\n}\n\nmodule_init(smsc9420_init_module);\nmodule_exit(smsc9420_exit_module);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}