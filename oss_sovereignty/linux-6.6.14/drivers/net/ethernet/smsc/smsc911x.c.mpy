{
  "module_name": "smsc911x.c",
  "hash_id": "af695b44a858e33cd041ee98bbb1b64a67b2c175d34d3466dd86276dc77cf587",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/smsc/smsc911x.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/crc32.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/errno.h>\n#include <linux/etherdevice.h>\n#include <linux/ethtool.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/platform_device.h>\n#include <linux/regulator/consumer.h>\n#include <linux/sched.h>\n#include <linux/timer.h>\n#include <linux/bug.h>\n#include <linux/bitops.h>\n#include <linux/irq.h>\n#include <linux/io.h>\n#include <linux/swab.h>\n#include <linux/phy.h>\n#include <linux/smsc911x.h>\n#include <linux/device.h>\n#include <linux/of.h>\n#include <linux/of_gpio.h>\n#include <linux/of_net.h>\n#include <linux/acpi.h>\n#include <linux/pm_runtime.h>\n#include <linux/property.h>\n#include <linux/gpio/consumer.h>\n\n#include \"smsc911x.h\"\n\n#define SMSC_CHIPNAME\t\t\"smsc911x\"\n#define SMSC_MDIONAME\t\t\"smsc911x-mdio\"\n#define SMSC_DRV_VERSION\t\"2008-10-21\"\n\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(SMSC_DRV_VERSION);\nMODULE_ALIAS(\"platform:smsc911x\");\n\n#if USE_DEBUG > 0\nstatic int debug = 16;\n#else\nstatic int debug = 3;\n#endif\n\nmodule_param(debug, int, 0);\nMODULE_PARM_DESC(debug, \"Debug level (0=none,...,16=all)\");\n\nstruct smsc911x_data;\n\nstruct smsc911x_ops {\n\tu32 (*reg_read)(struct smsc911x_data *pdata, u32 reg);\n\tvoid (*reg_write)(struct smsc911x_data *pdata, u32 reg, u32 val);\n\tvoid (*rx_readfifo)(struct smsc911x_data *pdata,\n\t\t\t\tunsigned int *buf, unsigned int wordcount);\n\tvoid (*tx_writefifo)(struct smsc911x_data *pdata,\n\t\t\t\tunsigned int *buf, unsigned int wordcount);\n};\n\n#define SMSC911X_NUM_SUPPLIES 2\n\nstruct smsc911x_data {\n\tvoid __iomem *ioaddr;\n\n\tunsigned int idrev;\n\n\t \n\tunsigned int generation;\n\n\t \n\tstruct smsc911x_platform_config config;\n\n\t \n\tspinlock_t mac_lock;\n\n\t \n\tspinlock_t dev_lock;\n\n\tstruct mii_bus *mii_bus;\n\tunsigned int using_extphy;\n\tint last_duplex;\n\tint last_carrier;\n\n\tu32 msg_enable;\n\tunsigned int gpio_setting;\n\tunsigned int gpio_orig_setting;\n\tstruct net_device *dev;\n\tstruct napi_struct napi;\n\n\tunsigned int software_irq_signal;\n\n#ifdef USE_PHY_WORK_AROUND\n#define MIN_PACKET_SIZE (64)\n\tchar loopback_tx_pkt[MIN_PACKET_SIZE];\n\tchar loopback_rx_pkt[MIN_PACKET_SIZE];\n\tunsigned int resetcount;\n#endif\n\n\t \n\tunsigned int multicast_update_pending;\n\tunsigned int set_bits_mask;\n\tunsigned int clear_bits_mask;\n\tunsigned int hashhi;\n\tunsigned int hashlo;\n\n\t \n\tconst struct smsc911x_ops *ops;\n\n\t \n\tstruct regulator_bulk_data supplies[SMSC911X_NUM_SUPPLIES];\n\n\t \n\tstruct gpio_desc *reset_gpiod;\n\n\t \n\tstruct clk *clk;\n};\n\n \n#define __smsc_shift(pdata, reg) ((reg) << ((pdata)->config.shift))\n\nstatic inline u32 __smsc911x_reg_read(struct smsc911x_data *pdata, u32 reg)\n{\n\tif (pdata->config.flags & SMSC911X_USE_32BIT)\n\t\treturn readl(pdata->ioaddr + reg);\n\n\tif (pdata->config.flags & SMSC911X_USE_16BIT)\n\t\treturn ((readw(pdata->ioaddr + reg) & 0xFFFF) |\n\t\t\t((readw(pdata->ioaddr + reg + 2) & 0xFFFF) << 16));\n\n\tBUG();\n\treturn 0;\n}\n\nstatic inline u32\n__smsc911x_reg_read_shift(struct smsc911x_data *pdata, u32 reg)\n{\n\tif (pdata->config.flags & SMSC911X_USE_32BIT)\n\t\treturn readl(pdata->ioaddr + __smsc_shift(pdata, reg));\n\n\tif (pdata->config.flags & SMSC911X_USE_16BIT)\n\t\treturn (readw(pdata->ioaddr +\n\t\t\t\t__smsc_shift(pdata, reg)) & 0xFFFF) |\n\t\t\t((readw(pdata->ioaddr +\n\t\t\t__smsc_shift(pdata, reg + 2)) & 0xFFFF) << 16);\n\n\tBUG();\n\treturn 0;\n}\n\nstatic inline u32 smsc911x_reg_read(struct smsc911x_data *pdata, u32 reg)\n{\n\tu32 data;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&pdata->dev_lock, flags);\n\tdata = pdata->ops->reg_read(pdata, reg);\n\tspin_unlock_irqrestore(&pdata->dev_lock, flags);\n\n\treturn data;\n}\n\nstatic inline void __smsc911x_reg_write(struct smsc911x_data *pdata, u32 reg,\n\t\t\t\t\tu32 val)\n{\n\tif (pdata->config.flags & SMSC911X_USE_32BIT) {\n\t\twritel(val, pdata->ioaddr + reg);\n\t\treturn;\n\t}\n\n\tif (pdata->config.flags & SMSC911X_USE_16BIT) {\n\t\twritew(val & 0xFFFF, pdata->ioaddr + reg);\n\t\twritew((val >> 16) & 0xFFFF, pdata->ioaddr + reg + 2);\n\t\treturn;\n\t}\n\n\tBUG();\n}\n\nstatic inline void\n__smsc911x_reg_write_shift(struct smsc911x_data *pdata, u32 reg, u32 val)\n{\n\tif (pdata->config.flags & SMSC911X_USE_32BIT) {\n\t\twritel(val, pdata->ioaddr + __smsc_shift(pdata, reg));\n\t\treturn;\n\t}\n\n\tif (pdata->config.flags & SMSC911X_USE_16BIT) {\n\t\twritew(val & 0xFFFF,\n\t\t\tpdata->ioaddr + __smsc_shift(pdata, reg));\n\t\twritew((val >> 16) & 0xFFFF,\n\t\t\tpdata->ioaddr + __smsc_shift(pdata, reg + 2));\n\t\treturn;\n\t}\n\n\tBUG();\n}\n\nstatic inline void smsc911x_reg_write(struct smsc911x_data *pdata, u32 reg,\n\t\t\t\t      u32 val)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&pdata->dev_lock, flags);\n\tpdata->ops->reg_write(pdata, reg, val);\n\tspin_unlock_irqrestore(&pdata->dev_lock, flags);\n}\n\n \nstatic inline void\nsmsc911x_tx_writefifo(struct smsc911x_data *pdata, unsigned int *buf,\n\t\t      unsigned int wordcount)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&pdata->dev_lock, flags);\n\n\tif (pdata->config.flags & SMSC911X_SWAP_FIFO) {\n\t\twhile (wordcount--)\n\t\t\t__smsc911x_reg_write(pdata, TX_DATA_FIFO,\n\t\t\t\t\t     swab32(*buf++));\n\t\tgoto out;\n\t}\n\n\tif (pdata->config.flags & SMSC911X_USE_32BIT) {\n\t\tiowrite32_rep(pdata->ioaddr + TX_DATA_FIFO, buf, wordcount);\n\t\tgoto out;\n\t}\n\n\tif (pdata->config.flags & SMSC911X_USE_16BIT) {\n\t\twhile (wordcount--)\n\t\t\t__smsc911x_reg_write(pdata, TX_DATA_FIFO, *buf++);\n\t\tgoto out;\n\t}\n\n\tBUG();\nout:\n\tspin_unlock_irqrestore(&pdata->dev_lock, flags);\n}\n\n \nstatic inline void\nsmsc911x_tx_writefifo_shift(struct smsc911x_data *pdata, unsigned int *buf,\n\t\t      unsigned int wordcount)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&pdata->dev_lock, flags);\n\n\tif (pdata->config.flags & SMSC911X_SWAP_FIFO) {\n\t\twhile (wordcount--)\n\t\t\t__smsc911x_reg_write_shift(pdata, TX_DATA_FIFO,\n\t\t\t\t\t     swab32(*buf++));\n\t\tgoto out;\n\t}\n\n\tif (pdata->config.flags & SMSC911X_USE_32BIT) {\n\t\tiowrite32_rep(pdata->ioaddr + __smsc_shift(pdata,\n\t\t\t\t\t\tTX_DATA_FIFO), buf, wordcount);\n\t\tgoto out;\n\t}\n\n\tif (pdata->config.flags & SMSC911X_USE_16BIT) {\n\t\twhile (wordcount--)\n\t\t\t__smsc911x_reg_write_shift(pdata,\n\t\t\t\t\t\t TX_DATA_FIFO, *buf++);\n\t\tgoto out;\n\t}\n\n\tBUG();\nout:\n\tspin_unlock_irqrestore(&pdata->dev_lock, flags);\n}\n\n \nstatic inline void\nsmsc911x_rx_readfifo(struct smsc911x_data *pdata, unsigned int *buf,\n\t\t     unsigned int wordcount)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&pdata->dev_lock, flags);\n\n\tif (pdata->config.flags & SMSC911X_SWAP_FIFO) {\n\t\twhile (wordcount--)\n\t\t\t*buf++ = swab32(__smsc911x_reg_read(pdata,\n\t\t\t\t\t\t\t    RX_DATA_FIFO));\n\t\tgoto out;\n\t}\n\n\tif (pdata->config.flags & SMSC911X_USE_32BIT) {\n\t\tioread32_rep(pdata->ioaddr + RX_DATA_FIFO, buf, wordcount);\n\t\tgoto out;\n\t}\n\n\tif (pdata->config.flags & SMSC911X_USE_16BIT) {\n\t\twhile (wordcount--)\n\t\t\t*buf++ = __smsc911x_reg_read(pdata, RX_DATA_FIFO);\n\t\tgoto out;\n\t}\n\n\tBUG();\nout:\n\tspin_unlock_irqrestore(&pdata->dev_lock, flags);\n}\n\n \nstatic inline void\nsmsc911x_rx_readfifo_shift(struct smsc911x_data *pdata, unsigned int *buf,\n\t\t     unsigned int wordcount)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&pdata->dev_lock, flags);\n\n\tif (pdata->config.flags & SMSC911X_SWAP_FIFO) {\n\t\twhile (wordcount--)\n\t\t\t*buf++ = swab32(__smsc911x_reg_read_shift(pdata,\n\t\t\t\t\t\t\t    RX_DATA_FIFO));\n\t\tgoto out;\n\t}\n\n\tif (pdata->config.flags & SMSC911X_USE_32BIT) {\n\t\tioread32_rep(pdata->ioaddr + __smsc_shift(pdata,\n\t\t\t\t\t\tRX_DATA_FIFO), buf, wordcount);\n\t\tgoto out;\n\t}\n\n\tif (pdata->config.flags & SMSC911X_USE_16BIT) {\n\t\twhile (wordcount--)\n\t\t\t*buf++ = __smsc911x_reg_read_shift(pdata,\n\t\t\t\t\t\t\t\tRX_DATA_FIFO);\n\t\tgoto out;\n\t}\n\n\tBUG();\nout:\n\tspin_unlock_irqrestore(&pdata->dev_lock, flags);\n}\n\n \nstatic int smsc911x_enable_resources(struct platform_device *pdev)\n{\n\tstruct net_device *ndev = platform_get_drvdata(pdev);\n\tstruct smsc911x_data *pdata = netdev_priv(ndev);\n\tint ret = 0;\n\n\tret = regulator_bulk_enable(ARRAY_SIZE(pdata->supplies),\n\t\t\tpdata->supplies);\n\tif (ret)\n\t\tnetdev_err(ndev, \"failed to enable regulators %d\\n\",\n\t\t\t\tret);\n\n\tif (!IS_ERR(pdata->clk)) {\n\t\tret = clk_prepare_enable(pdata->clk);\n\t\tif (ret < 0)\n\t\t\tnetdev_err(ndev, \"failed to enable clock %d\\n\", ret);\n\t}\n\n\treturn ret;\n}\n\n \nstatic int smsc911x_disable_resources(struct platform_device *pdev)\n{\n\tstruct net_device *ndev = platform_get_drvdata(pdev);\n\tstruct smsc911x_data *pdata = netdev_priv(ndev);\n\tint ret = 0;\n\n\tret = regulator_bulk_disable(ARRAY_SIZE(pdata->supplies),\n\t\t\tpdata->supplies);\n\n\tif (!IS_ERR(pdata->clk))\n\t\tclk_disable_unprepare(pdata->clk);\n\n\treturn ret;\n}\n\n \nstatic int smsc911x_request_resources(struct platform_device *pdev)\n{\n\tstruct net_device *ndev = platform_get_drvdata(pdev);\n\tstruct smsc911x_data *pdata = netdev_priv(ndev);\n\tint ret = 0;\n\n\t \n\tpdata->supplies[0].supply = \"vdd33a\";\n\tpdata->supplies[1].supply = \"vddvario\";\n\tret = regulator_bulk_get(&pdev->dev,\n\t\t\tARRAY_SIZE(pdata->supplies),\n\t\t\tpdata->supplies);\n\tif (ret) {\n\t\t \n\t\tif (ret == -EPROBE_DEFER)\n\t\t\treturn ret;\n\t\tnetdev_err(ndev, \"couldn't get regulators %d\\n\",\n\t\t\t\tret);\n\t}\n\n\t \n\tpdata->reset_gpiod = devm_gpiod_get_optional(&pdev->dev,\n\t\t\t\t\t\t     \"reset\",\n\t\t\t\t\t\t     GPIOD_OUT_LOW);\n\n\t \n\tpdata->clk = clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(pdata->clk))\n\t\tdev_dbg(&pdev->dev, \"couldn't get clock %li\\n\",\n\t\t\tPTR_ERR(pdata->clk));\n\n\treturn ret;\n}\n\n \nstatic void smsc911x_free_resources(struct platform_device *pdev)\n{\n\tstruct net_device *ndev = platform_get_drvdata(pdev);\n\tstruct smsc911x_data *pdata = netdev_priv(ndev);\n\n\t \n\tregulator_bulk_free(ARRAY_SIZE(pdata->supplies),\n\t\t\tpdata->supplies);\n\n\t \n\tif (!IS_ERR(pdata->clk)) {\n\t\tclk_put(pdata->clk);\n\t\tpdata->clk = NULL;\n\t}\n}\n\n \nstatic int smsc911x_mac_complete(struct smsc911x_data *pdata)\n{\n\tint i;\n\tu32 val;\n\n\tSMSC_ASSERT_MAC_LOCK(pdata);\n\n\tfor (i = 0; i < 40; i++) {\n\t\tval = smsc911x_reg_read(pdata, MAC_CSR_CMD);\n\t\tif (!(val & MAC_CSR_CMD_CSR_BUSY_))\n\t\t\treturn 0;\n\t}\n\tSMSC_WARN(pdata, hw, \"Timed out waiting for MAC not BUSY. \"\n\t\t  \"MAC_CSR_CMD: 0x%08X\", val);\n\treturn -EIO;\n}\n\n \nstatic u32 smsc911x_mac_read(struct smsc911x_data *pdata, unsigned int offset)\n{\n\tunsigned int temp;\n\n\tSMSC_ASSERT_MAC_LOCK(pdata);\n\n\ttemp = smsc911x_reg_read(pdata, MAC_CSR_CMD);\n\tif (unlikely(temp & MAC_CSR_CMD_CSR_BUSY_)) {\n\t\tSMSC_WARN(pdata, hw, \"MAC busy at entry\");\n\t\treturn 0xFFFFFFFF;\n\t}\n\n\t \n\tsmsc911x_reg_write(pdata, MAC_CSR_CMD, ((offset & 0xFF) |\n\t\tMAC_CSR_CMD_CSR_BUSY_ | MAC_CSR_CMD_R_NOT_W_));\n\n\t \n\ttemp = smsc911x_reg_read(pdata, BYTE_TEST);\n\n\t \n\tif (likely(smsc911x_mac_complete(pdata) == 0))\n\t\treturn smsc911x_reg_read(pdata, MAC_CSR_DATA);\n\n\tSMSC_WARN(pdata, hw, \"MAC busy after read\");\n\treturn 0xFFFFFFFF;\n}\n\n \nstatic void smsc911x_mac_write(struct smsc911x_data *pdata,\n\t\t\t       unsigned int offset, u32 val)\n{\n\tunsigned int temp;\n\n\tSMSC_ASSERT_MAC_LOCK(pdata);\n\n\ttemp = smsc911x_reg_read(pdata, MAC_CSR_CMD);\n\tif (unlikely(temp & MAC_CSR_CMD_CSR_BUSY_)) {\n\t\tSMSC_WARN(pdata, hw,\n\t\t\t  \"smsc911x_mac_write failed, MAC busy at entry\");\n\t\treturn;\n\t}\n\n\t \n\tsmsc911x_reg_write(pdata, MAC_CSR_DATA, val);\n\n\t \n\tsmsc911x_reg_write(pdata, MAC_CSR_CMD, ((offset & 0xFF) |\n\t\tMAC_CSR_CMD_CSR_BUSY_));\n\n\t \n\ttemp = smsc911x_reg_read(pdata, BYTE_TEST);\n\n\t \n\tif (likely(smsc911x_mac_complete(pdata) == 0))\n\t\treturn;\n\n\tSMSC_WARN(pdata, hw, \"smsc911x_mac_write failed, MAC busy after write\");\n}\n\n \nstatic int smsc911x_mii_read(struct mii_bus *bus, int phyaddr, int regidx)\n{\n\tstruct smsc911x_data *pdata = bus->priv;\n\tunsigned long flags;\n\tunsigned int addr;\n\tint i, reg;\n\n\tpm_runtime_get_sync(bus->parent);\n\tspin_lock_irqsave(&pdata->mac_lock, flags);\n\n\t \n\tif (unlikely(smsc911x_mac_read(pdata, MII_ACC) & MII_ACC_MII_BUSY_)) {\n\t\tSMSC_WARN(pdata, hw, \"MII is busy in smsc911x_mii_read???\");\n\t\treg = -EIO;\n\t\tgoto out;\n\t}\n\n\t \n\taddr = ((phyaddr & 0x1F) << 11) | ((regidx & 0x1F) << 6);\n\tsmsc911x_mac_write(pdata, MII_ACC, addr);\n\n\t \n\tfor (i = 0; i < 100; i++)\n\t\tif (!(smsc911x_mac_read(pdata, MII_ACC) & MII_ACC_MII_BUSY_)) {\n\t\t\treg = smsc911x_mac_read(pdata, MII_DATA);\n\t\t\tgoto out;\n\t\t}\n\n\tSMSC_WARN(pdata, hw, \"Timed out waiting for MII read to finish\");\n\treg = -EIO;\n\nout:\n\tspin_unlock_irqrestore(&pdata->mac_lock, flags);\n\tpm_runtime_put(bus->parent);\n\treturn reg;\n}\n\n \nstatic int smsc911x_mii_write(struct mii_bus *bus, int phyaddr, int regidx,\n\t\t\t   u16 val)\n{\n\tstruct smsc911x_data *pdata = bus->priv;\n\tunsigned long flags;\n\tunsigned int addr;\n\tint i, reg;\n\n\tpm_runtime_get_sync(bus->parent);\n\tspin_lock_irqsave(&pdata->mac_lock, flags);\n\n\t \n\tif (unlikely(smsc911x_mac_read(pdata, MII_ACC) & MII_ACC_MII_BUSY_)) {\n\t\tSMSC_WARN(pdata, hw, \"MII is busy in smsc911x_mii_write???\");\n\t\treg = -EIO;\n\t\tgoto out;\n\t}\n\n\t \n\tsmsc911x_mac_write(pdata, MII_DATA, val);\n\n\t \n\taddr = ((phyaddr & 0x1F) << 11) | ((regidx & 0x1F) << 6) |\n\t\tMII_ACC_MII_WRITE_;\n\tsmsc911x_mac_write(pdata, MII_ACC, addr);\n\n\t \n\tfor (i = 0; i < 100; i++)\n\t\tif (!(smsc911x_mac_read(pdata, MII_ACC) & MII_ACC_MII_BUSY_)) {\n\t\t\treg = 0;\n\t\t\tgoto out;\n\t\t}\n\n\tSMSC_WARN(pdata, hw, \"Timed out waiting for MII write to finish\");\n\treg = -EIO;\n\nout:\n\tspin_unlock_irqrestore(&pdata->mac_lock, flags);\n\tpm_runtime_put(bus->parent);\n\treturn reg;\n}\n\n \nstatic void smsc911x_phy_enable_external(struct smsc911x_data *pdata)\n{\n\tunsigned int hwcfg = smsc911x_reg_read(pdata, HW_CFG);\n\n\t \n\thwcfg &= (~HW_CFG_PHY_CLK_SEL_);\n\thwcfg |= HW_CFG_PHY_CLK_SEL_CLK_DIS_;\n\tsmsc911x_reg_write(pdata, HW_CFG, hwcfg);\n\tudelay(10);\t \n\n\t \n\thwcfg |= HW_CFG_EXT_PHY_EN_;\n\tsmsc911x_reg_write(pdata, HW_CFG, hwcfg);\n\n\t \n\thwcfg &= (~HW_CFG_PHY_CLK_SEL_);\n\thwcfg |= HW_CFG_PHY_CLK_SEL_EXT_PHY_;\n\tsmsc911x_reg_write(pdata, HW_CFG, hwcfg);\n\tudelay(10);\t \n\n\thwcfg |= HW_CFG_SMI_SEL_;\n\tsmsc911x_reg_write(pdata, HW_CFG, hwcfg);\n}\n\n \nstatic void smsc911x_phy_initialise_external(struct smsc911x_data *pdata)\n{\n\tunsigned int hwcfg = smsc911x_reg_read(pdata, HW_CFG);\n\n\tif (pdata->config.flags & SMSC911X_FORCE_INTERNAL_PHY) {\n\t\tSMSC_TRACE(pdata, hw, \"Forcing internal PHY\");\n\t\tpdata->using_extphy = 0;\n\t} else if (pdata->config.flags & SMSC911X_FORCE_EXTERNAL_PHY) {\n\t\tSMSC_TRACE(pdata, hw, \"Forcing external PHY\");\n\t\tsmsc911x_phy_enable_external(pdata);\n\t\tpdata->using_extphy = 1;\n\t} else if (hwcfg & HW_CFG_EXT_PHY_DET_) {\n\t\tSMSC_TRACE(pdata, hw,\n\t\t\t   \"HW_CFG EXT_PHY_DET set, using external PHY\");\n\t\tsmsc911x_phy_enable_external(pdata);\n\t\tpdata->using_extphy = 1;\n\t} else {\n\t\tSMSC_TRACE(pdata, hw,\n\t\t\t   \"HW_CFG EXT_PHY_DET clear, using internal PHY\");\n\t\tpdata->using_extphy = 0;\n\t}\n}\n\n \nstatic unsigned int smsc911x_tx_get_txstatus(struct smsc911x_data *pdata)\n{\n\tunsigned int result =\n\t    smsc911x_reg_read(pdata, TX_FIFO_INF) & TX_FIFO_INF_TSUSED_;\n\n\tif (result != 0)\n\t\tresult = smsc911x_reg_read(pdata, TX_STATUS_FIFO);\n\n\treturn result;\n}\n\n \nstatic unsigned int smsc911x_rx_get_rxstatus(struct smsc911x_data *pdata)\n{\n\tunsigned int result =\n\t    smsc911x_reg_read(pdata, RX_FIFO_INF) & RX_FIFO_INF_RXSUSED_;\n\n\tif (result != 0)\n\t\tresult = smsc911x_reg_read(pdata, RX_STATUS_FIFO);\n\n\treturn result;\n}\n\n#ifdef USE_PHY_WORK_AROUND\nstatic int smsc911x_phy_check_loopbackpkt(struct smsc911x_data *pdata)\n{\n\tunsigned int tries;\n\tu32 wrsz;\n\tu32 rdsz;\n\tulong bufp;\n\n\tfor (tries = 0; tries < 10; tries++) {\n\t\tunsigned int txcmd_a;\n\t\tunsigned int txcmd_b;\n\t\tunsigned int status;\n\t\tunsigned int pktlength;\n\t\tunsigned int i;\n\n\t\t \n\t\tmemset(pdata->loopback_rx_pkt, 0, MIN_PACKET_SIZE);\n\n\t\t \n\t\ttxcmd_a = (u32)((ulong)pdata->loopback_tx_pkt & 0x03) << 16;\n\t\ttxcmd_a |= TX_CMD_A_FIRST_SEG_ | TX_CMD_A_LAST_SEG_;\n\t\ttxcmd_a |= MIN_PACKET_SIZE;\n\n\t\ttxcmd_b = MIN_PACKET_SIZE << 16 | MIN_PACKET_SIZE;\n\n\t\tsmsc911x_reg_write(pdata, TX_DATA_FIFO, txcmd_a);\n\t\tsmsc911x_reg_write(pdata, TX_DATA_FIFO, txcmd_b);\n\n\t\tbufp = (ulong)pdata->loopback_tx_pkt & (~0x3);\n\t\twrsz = MIN_PACKET_SIZE + 3;\n\t\twrsz += (u32)((ulong)pdata->loopback_tx_pkt & 0x3);\n\t\twrsz >>= 2;\n\n\t\tpdata->ops->tx_writefifo(pdata, (unsigned int *)bufp, wrsz);\n\n\t\t \n\t\ti = 60;\n\t\tdo {\n\t\t\tudelay(5);\n\t\t\tstatus = smsc911x_tx_get_txstatus(pdata);\n\t\t} while ((i--) && (!status));\n\n\t\tif (!status) {\n\t\t\tSMSC_WARN(pdata, hw,\n\t\t\t\t  \"Failed to transmit during loopback test\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (status & TX_STS_ES_) {\n\t\t\tSMSC_WARN(pdata, hw,\n\t\t\t\t  \"Transmit encountered errors during loopback test\");\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\ti = 60;\n\t\tdo {\n\t\t\tudelay(5);\n\t\t\tstatus = smsc911x_rx_get_rxstatus(pdata);\n\t\t} while ((i--) && (!status));\n\n\t\tif (!status) {\n\t\t\tSMSC_WARN(pdata, hw,\n\t\t\t\t  \"Failed to receive during loopback test\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (status & RX_STS_ES_) {\n\t\t\tSMSC_WARN(pdata, hw,\n\t\t\t\t  \"Receive encountered errors during loopback test\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tpktlength = ((status & 0x3FFF0000UL) >> 16);\n\t\tbufp = (ulong)pdata->loopback_rx_pkt;\n\t\trdsz = pktlength + 3;\n\t\trdsz += (u32)((ulong)pdata->loopback_rx_pkt & 0x3);\n\t\trdsz >>= 2;\n\n\t\tpdata->ops->rx_readfifo(pdata, (unsigned int *)bufp, rdsz);\n\n\t\tif (pktlength != (MIN_PACKET_SIZE + 4)) {\n\t\t\tSMSC_WARN(pdata, hw, \"Unexpected packet size \"\n\t\t\t\t  \"during loop back test, size=%d, will retry\",\n\t\t\t\t  pktlength);\n\t\t} else {\n\t\t\tunsigned int j;\n\t\t\tint mismatch = 0;\n\t\t\tfor (j = 0; j < MIN_PACKET_SIZE; j++) {\n\t\t\t\tif (pdata->loopback_tx_pkt[j]\n\t\t\t\t    != pdata->loopback_rx_pkt[j]) {\n\t\t\t\t\tmismatch = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!mismatch) {\n\t\t\t\tSMSC_TRACE(pdata, hw, \"Successfully verified \"\n\t\t\t\t\t   \"loopback packet\");\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\tSMSC_WARN(pdata, hw, \"Data mismatch \"\n\t\t\t\t\t  \"during loop back test, will retry\");\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -EIO;\n}\n\nstatic int smsc911x_phy_reset(struct smsc911x_data *pdata)\n{\n\tunsigned int temp;\n\tunsigned int i = 100000;\n\n\ttemp = smsc911x_reg_read(pdata, PMT_CTRL);\n\tsmsc911x_reg_write(pdata, PMT_CTRL, temp | PMT_CTRL_PHY_RST_);\n\tdo {\n\t\tmsleep(1);\n\t\ttemp = smsc911x_reg_read(pdata, PMT_CTRL);\n\t} while ((i--) && (temp & PMT_CTRL_PHY_RST_));\n\n\tif (unlikely(temp & PMT_CTRL_PHY_RST_)) {\n\t\tSMSC_WARN(pdata, hw, \"PHY reset failed to complete\");\n\t\treturn -EIO;\n\t}\n\t \n\tmsleep(1);\n\n\treturn 0;\n}\n\nstatic int smsc911x_phy_loopbacktest(struct net_device *dev)\n{\n\tstruct smsc911x_data *pdata = netdev_priv(dev);\n\tstruct phy_device *phy_dev = dev->phydev;\n\tint result = -EIO;\n\tunsigned int i, val;\n\tunsigned long flags;\n\n\t \n\teth_broadcast_addr(pdata->loopback_tx_pkt);\n\n\t \n\tfor (i = 6; i < 12; i++)\n\t\tpdata->loopback_tx_pkt[i] = (char)i;\n\n\t \n\tpdata->loopback_tx_pkt[12] = 0x00;\n\tpdata->loopback_tx_pkt[13] = 0x00;\n\n\tfor (i = 14; i < MIN_PACKET_SIZE; i++)\n\t\tpdata->loopback_tx_pkt[i] = (char)i;\n\n\tval = smsc911x_reg_read(pdata, HW_CFG);\n\tval &= HW_CFG_TX_FIF_SZ_;\n\tval |= HW_CFG_SF_;\n\tsmsc911x_reg_write(pdata, HW_CFG, val);\n\n\tsmsc911x_reg_write(pdata, TX_CFG, TX_CFG_TX_ON_);\n\tsmsc911x_reg_write(pdata, RX_CFG,\n\t\t(u32)((ulong)pdata->loopback_rx_pkt & 0x03) << 8);\n\n\tfor (i = 0; i < 10; i++) {\n\t\t \n\t\tsmsc911x_mii_write(phy_dev->mdio.bus, phy_dev->mdio.addr,\n\t\t\t\t   MII_BMCR, BMCR_LOOPBACK | BMCR_FULLDPLX);\n\n\t\t \n\t\tspin_lock_irqsave(&pdata->mac_lock, flags);\n\t\tsmsc911x_mac_write(pdata, MAC_CR, MAC_CR_FDPX_\n\t\t\t\t   | MAC_CR_TXEN_ | MAC_CR_RXEN_);\n\t\tspin_unlock_irqrestore(&pdata->mac_lock, flags);\n\n\t\tif (smsc911x_phy_check_loopbackpkt(pdata) == 0) {\n\t\t\tresult = 0;\n\t\t\tbreak;\n\t\t}\n\t\tpdata->resetcount++;\n\n\t\t \n\t\tspin_lock_irqsave(&pdata->mac_lock, flags);\n\t\tsmsc911x_mac_write(pdata, MAC_CR, 0);\n\t\tspin_unlock_irqrestore(&pdata->mac_lock, flags);\n\n\t\tsmsc911x_phy_reset(pdata);\n\t}\n\n\t \n\tspin_lock_irqsave(&pdata->mac_lock, flags);\n\tsmsc911x_mac_write(pdata, MAC_CR, 0);\n\tspin_unlock_irqrestore(&pdata->mac_lock, flags);\n\n\t \n\tsmsc911x_mii_write(phy_dev->mdio.bus, phy_dev->mdio.addr, MII_BMCR, 0);\n\n\tsmsc911x_reg_write(pdata, TX_CFG, 0);\n\tsmsc911x_reg_write(pdata, RX_CFG, 0);\n\n\treturn result;\n}\n#endif\t\t\t\t \n\nstatic void smsc911x_phy_update_flowcontrol(struct smsc911x_data *pdata)\n{\n\tstruct net_device *ndev = pdata->dev;\n\tstruct phy_device *phy_dev = ndev->phydev;\n\tu32 afc = smsc911x_reg_read(pdata, AFC_CFG);\n\tu32 flow;\n\tunsigned long flags;\n\n\tif (phy_dev->duplex == DUPLEX_FULL) {\n\t\tu16 lcladv = phy_read(phy_dev, MII_ADVERTISE);\n\t\tu16 rmtadv = phy_read(phy_dev, MII_LPA);\n\t\tu8 cap = mii_resolve_flowctrl_fdx(lcladv, rmtadv);\n\n\t\tif (cap & FLOW_CTRL_RX)\n\t\t\tflow = 0xFFFF0002;\n\t\telse\n\t\t\tflow = 0;\n\n\t\tif (cap & FLOW_CTRL_TX)\n\t\t\tafc |= 0xF;\n\t\telse\n\t\t\tafc &= ~0xF;\n\n\t\tSMSC_TRACE(pdata, hw, \"rx pause %s, tx pause %s\",\n\t\t\t   (cap & FLOW_CTRL_RX ? \"enabled\" : \"disabled\"),\n\t\t\t   (cap & FLOW_CTRL_TX ? \"enabled\" : \"disabled\"));\n\t} else {\n\t\tSMSC_TRACE(pdata, hw, \"half duplex\");\n\t\tflow = 0;\n\t\tafc |= 0xF;\n\t}\n\n\tspin_lock_irqsave(&pdata->mac_lock, flags);\n\tsmsc911x_mac_write(pdata, FLOW, flow);\n\tspin_unlock_irqrestore(&pdata->mac_lock, flags);\n\n\tsmsc911x_reg_write(pdata, AFC_CFG, afc);\n}\n\n \nstatic void smsc911x_phy_adjust_link(struct net_device *dev)\n{\n\tstruct smsc911x_data *pdata = netdev_priv(dev);\n\tstruct phy_device *phy_dev = dev->phydev;\n\tunsigned long flags;\n\tint carrier;\n\n\tif (phy_dev->duplex != pdata->last_duplex) {\n\t\tunsigned int mac_cr;\n\t\tSMSC_TRACE(pdata, hw, \"duplex state has changed\");\n\n\t\tspin_lock_irqsave(&pdata->mac_lock, flags);\n\t\tmac_cr = smsc911x_mac_read(pdata, MAC_CR);\n\t\tif (phy_dev->duplex) {\n\t\t\tSMSC_TRACE(pdata, hw,\n\t\t\t\t   \"configuring for full duplex mode\");\n\t\t\tmac_cr |= MAC_CR_FDPX_;\n\t\t} else {\n\t\t\tSMSC_TRACE(pdata, hw,\n\t\t\t\t   \"configuring for half duplex mode\");\n\t\t\tmac_cr &= ~MAC_CR_FDPX_;\n\t\t}\n\t\tsmsc911x_mac_write(pdata, MAC_CR, mac_cr);\n\t\tspin_unlock_irqrestore(&pdata->mac_lock, flags);\n\n\t\tsmsc911x_phy_update_flowcontrol(pdata);\n\t\tpdata->last_duplex = phy_dev->duplex;\n\t}\n\n\tcarrier = netif_carrier_ok(dev);\n\tif (carrier != pdata->last_carrier) {\n\t\tSMSC_TRACE(pdata, hw, \"carrier state has changed\");\n\t\tif (carrier) {\n\t\t\tSMSC_TRACE(pdata, hw, \"configuring for carrier OK\");\n\t\t\tif ((pdata->gpio_orig_setting & GPIO_CFG_LED1_EN_) &&\n\t\t\t    (!pdata->using_extphy)) {\n\t\t\t\t \n\t\t\t\tpdata->gpio_setting = pdata->gpio_orig_setting;\n\t\t\t\tsmsc911x_reg_write(pdata, GPIO_CFG,\n\t\t\t\t\tpdata->gpio_setting);\n\t\t\t}\n\t\t} else {\n\t\t\tSMSC_TRACE(pdata, hw, \"configuring for no carrier\");\n\t\t\t \n\t\t\tpdata->gpio_setting = smsc911x_reg_read(pdata,\n\t\t\t\tGPIO_CFG);\n\t\t\tif ((pdata->gpio_setting & GPIO_CFG_LED1_EN_) &&\n\t\t\t    (!pdata->using_extphy)) {\n\t\t\t\t \n\t\t\t\tpdata->gpio_orig_setting = pdata->gpio_setting;\n\n\t\t\t\tpdata->gpio_setting &= ~GPIO_CFG_LED1_EN_;\n\t\t\t\tpdata->gpio_setting |= (GPIO_CFG_GPIOBUF0_\n\t\t\t\t\t\t\t| GPIO_CFG_GPIODIR0_\n\t\t\t\t\t\t\t| GPIO_CFG_GPIOD0_);\n\t\t\t\tsmsc911x_reg_write(pdata, GPIO_CFG,\n\t\t\t\t\tpdata->gpio_setting);\n\t\t\t}\n\t\t}\n\t\tpdata->last_carrier = carrier;\n\t}\n}\n\nstatic int smsc911x_mii_probe(struct net_device *dev)\n{\n\tstruct smsc911x_data *pdata = netdev_priv(dev);\n\tstruct phy_device *phydev;\n\tint ret;\n\n\t \n\tphydev = phy_find_first(pdata->mii_bus);\n\tif (!phydev) {\n\t\tnetdev_err(dev, \"no PHY found\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tSMSC_TRACE(pdata, probe, \"PHY: addr %d, phy_id 0x%08X\",\n\t\t   phydev->mdio.addr, phydev->phy_id);\n\n\tret = phy_connect_direct(dev, phydev, &smsc911x_phy_adjust_link,\n\t\t\t\t pdata->config.phy_interface);\n\n\tif (ret) {\n\t\tnetdev_err(dev, \"Could not attach to PHY\\n\");\n\t\treturn ret;\n\t}\n\n\tphy_attached_info(phydev);\n\n\tphy_set_max_speed(phydev, SPEED_100);\n\n\t \n\tphy_support_asym_pause(phydev);\n\n\tpdata->last_duplex = -1;\n\tpdata->last_carrier = -1;\n\n#ifdef USE_PHY_WORK_AROUND\n\tif (smsc911x_phy_loopbacktest(dev) < 0) {\n\t\tSMSC_WARN(pdata, hw, \"Failed Loop Back Test\");\n\t\tphy_disconnect(phydev);\n\t\treturn -ENODEV;\n\t}\n\tSMSC_TRACE(pdata, hw, \"Passed Loop Back Test\");\n#endif\t\t\t\t \n\n\tSMSC_TRACE(pdata, hw, \"phy initialised successfully\");\n\treturn 0;\n}\n\nstatic int smsc911x_mii_init(struct platform_device *pdev,\n\t\t\t     struct net_device *dev)\n{\n\tstruct smsc911x_data *pdata = netdev_priv(dev);\n\tstruct phy_device *phydev;\n\tint err = -ENXIO;\n\n\tpdata->mii_bus = mdiobus_alloc();\n\tif (!pdata->mii_bus) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out_1;\n\t}\n\n\tpdata->mii_bus->name = SMSC_MDIONAME;\n\tsnprintf(pdata->mii_bus->id, MII_BUS_ID_SIZE, \"%s-%x\",\n\t\tpdev->name, pdev->id);\n\tpdata->mii_bus->priv = pdata;\n\tpdata->mii_bus->read = smsc911x_mii_read;\n\tpdata->mii_bus->write = smsc911x_mii_write;\n\n\tpdata->mii_bus->parent = &pdev->dev;\n\n\tswitch (pdata->idrev & 0xFFFF0000) {\n\tcase 0x01170000:\n\tcase 0x01150000:\n\tcase 0x117A0000:\n\tcase 0x115A0000:\n\t\t \n\t\tsmsc911x_phy_initialise_external(pdata);\n\t\tbreak;\n\tdefault:\n\t\tSMSC_TRACE(pdata, hw, \"External PHY is not supported, \"\n\t\t\t   \"using internal PHY\");\n\t\tpdata->using_extphy = 0;\n\t\tbreak;\n\t}\n\n\tif (!pdata->using_extphy) {\n\t\t \n\t\tpdata->mii_bus->phy_mask = ~(1 << 1);\n\t}\n\n\tif (mdiobus_register(pdata->mii_bus)) {\n\t\tSMSC_WARN(pdata, probe, \"Error registering mii bus\");\n\t\tgoto err_out_free_bus_2;\n\t}\n\n\tphydev = phy_find_first(pdata->mii_bus);\n\tif (phydev)\n\t\tphydev->mac_managed_pm = true;\n\n\treturn 0;\n\nerr_out_free_bus_2:\n\tmdiobus_free(pdata->mii_bus);\nerr_out_1:\n\treturn err;\n}\n\n \nstatic unsigned int smsc911x_tx_get_txstatcount(struct smsc911x_data *pdata)\n{\n\treturn (smsc911x_reg_read(pdata, TX_FIFO_INF)\n\t\t& TX_FIFO_INF_TSUSED_) >> 16;\n}\n\n \nstatic void smsc911x_tx_update_txcounters(struct net_device *dev)\n{\n\tstruct smsc911x_data *pdata = netdev_priv(dev);\n\tunsigned int tx_stat;\n\n\twhile ((tx_stat = smsc911x_tx_get_txstatus(pdata)) != 0) {\n\t\tif (unlikely(tx_stat & 0x80000000)) {\n\t\t\t \n\t\t\tSMSC_WARN(pdata, hw, \"Packet tag reserved bit is high\");\n\t\t} else {\n\t\t\tif (unlikely(tx_stat & TX_STS_ES_)) {\n\t\t\t\tdev->stats.tx_errors++;\n\t\t\t} else {\n\t\t\t\tdev->stats.tx_packets++;\n\t\t\t\tdev->stats.tx_bytes += (tx_stat >> 16);\n\t\t\t}\n\t\t\tif (unlikely(tx_stat & TX_STS_EXCESS_COL_)) {\n\t\t\t\tdev->stats.collisions += 16;\n\t\t\t\tdev->stats.tx_aborted_errors += 1;\n\t\t\t} else {\n\t\t\t\tdev->stats.collisions +=\n\t\t\t\t    ((tx_stat >> 3) & 0xF);\n\t\t\t}\n\t\t\tif (unlikely(tx_stat & TX_STS_LOST_CARRIER_))\n\t\t\t\tdev->stats.tx_carrier_errors += 1;\n\t\t\tif (unlikely(tx_stat & TX_STS_LATE_COL_)) {\n\t\t\t\tdev->stats.collisions++;\n\t\t\t\tdev->stats.tx_aborted_errors++;\n\t\t\t}\n\t\t}\n\t}\n}\n\n \nstatic void\nsmsc911x_rx_counterrors(struct net_device *dev, unsigned int rxstat)\n{\n\tint crc_err = 0;\n\n\tif (unlikely(rxstat & RX_STS_ES_)) {\n\t\tdev->stats.rx_errors++;\n\t\tif (unlikely(rxstat & RX_STS_CRC_ERR_)) {\n\t\t\tdev->stats.rx_crc_errors++;\n\t\t\tcrc_err = 1;\n\t\t}\n\t}\n\tif (likely(!crc_err)) {\n\t\tif (unlikely((rxstat & RX_STS_FRAME_TYPE_) &&\n\t\t\t     (rxstat & RX_STS_LENGTH_ERR_)))\n\t\t\tdev->stats.rx_length_errors++;\n\t\tif (rxstat & RX_STS_MCAST_)\n\t\t\tdev->stats.multicast++;\n\t}\n}\n\n \nstatic void\nsmsc911x_rx_fastforward(struct smsc911x_data *pdata, unsigned int pktwords)\n{\n\tif (likely(pktwords >= 4)) {\n\t\tunsigned int timeout = 500;\n\t\tunsigned int val;\n\t\tsmsc911x_reg_write(pdata, RX_DP_CTRL, RX_DP_CTRL_RX_FFWD_);\n\t\tdo {\n\t\t\tudelay(1);\n\t\t\tval = smsc911x_reg_read(pdata, RX_DP_CTRL);\n\t\t} while ((val & RX_DP_CTRL_RX_FFWD_) && --timeout);\n\n\t\tif (unlikely(timeout == 0))\n\t\t\tSMSC_WARN(pdata, hw, \"Timed out waiting for \"\n\t\t\t\t  \"RX FFWD to finish, RX_DP_CTRL: 0x%08X\", val);\n\t} else {\n\t\twhile (pktwords--)\n\t\t\tsmsc911x_reg_read(pdata, RX_DATA_FIFO);\n\t}\n}\n\n \nstatic int smsc911x_poll(struct napi_struct *napi, int budget)\n{\n\tstruct smsc911x_data *pdata =\n\t\tcontainer_of(napi, struct smsc911x_data, napi);\n\tstruct net_device *dev = pdata->dev;\n\tint npackets = 0;\n\n\twhile (npackets < budget) {\n\t\tunsigned int pktlength;\n\t\tunsigned int pktwords;\n\t\tstruct sk_buff *skb;\n\t\tunsigned int rxstat = smsc911x_rx_get_rxstatus(pdata);\n\n\t\tif (!rxstat) {\n\t\t\tunsigned int temp;\n\t\t\t \n\t\t\tsmsc911x_reg_write(pdata, INT_STS, INT_STS_RSFL_);\n\t\t\tnapi_complete(napi);\n\t\t\ttemp = smsc911x_reg_read(pdata, INT_EN);\n\t\t\ttemp |= INT_EN_RSFL_EN_;\n\t\t\tsmsc911x_reg_write(pdata, INT_EN, temp);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tnpackets++;\n\n\t\tpktlength = ((rxstat & 0x3FFF0000) >> 16);\n\t\tpktwords = (pktlength + NET_IP_ALIGN + 3) >> 2;\n\t\tsmsc911x_rx_counterrors(dev, rxstat);\n\n\t\tif (unlikely(rxstat & RX_STS_ES_)) {\n\t\t\tSMSC_WARN(pdata, rx_err,\n\t\t\t\t  \"Discarding packet with error bit set\");\n\t\t\t \n\t\t\tsmsc911x_rx_fastforward(pdata, pktwords);\n\t\t\tdev->stats.rx_dropped++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tskb = netdev_alloc_skb(dev, pktwords << 2);\n\t\tif (unlikely(!skb)) {\n\t\t\tSMSC_WARN(pdata, rx_err,\n\t\t\t\t  \"Unable to allocate skb for rx packet\");\n\t\t\t \n\t\t\tsmsc911x_rx_fastforward(pdata, pktwords);\n\t\t\tdev->stats.rx_dropped++;\n\t\t\tbreak;\n\t\t}\n\n\t\tpdata->ops->rx_readfifo(pdata,\n\t\t\t\t (unsigned int *)skb->data, pktwords);\n\n\t\t \n\t\tskb_reserve(skb, NET_IP_ALIGN);\n\t\tskb_put(skb, pktlength - 4);\n\t\tskb->protocol = eth_type_trans(skb, dev);\n\t\tskb_checksum_none_assert(skb);\n\t\tnetif_receive_skb(skb);\n\n\t\t \n\t\tdev->stats.rx_packets++;\n\t\tdev->stats.rx_bytes += (pktlength - 4);\n\t}\n\n\t \n\treturn npackets;\n}\n\n \nstatic unsigned int smsc911x_hash(char addr[ETH_ALEN])\n{\n\treturn (ether_crc(ETH_ALEN, addr) >> 26) & 0x3f;\n}\n\nstatic void smsc911x_rx_multicast_update(struct smsc911x_data *pdata)\n{\n\t \n\tunsigned int mac_cr;\n\n\tSMSC_ASSERT_MAC_LOCK(pdata);\n\n\tmac_cr = smsc911x_mac_read(pdata, MAC_CR);\n\tmac_cr |= pdata->set_bits_mask;\n\tmac_cr &= ~(pdata->clear_bits_mask);\n\tsmsc911x_mac_write(pdata, MAC_CR, mac_cr);\n\tsmsc911x_mac_write(pdata, HASHH, pdata->hashhi);\n\tsmsc911x_mac_write(pdata, HASHL, pdata->hashlo);\n\tSMSC_TRACE(pdata, hw, \"maccr 0x%08X, HASHH 0x%08X, HASHL 0x%08X\",\n\t\t   mac_cr, pdata->hashhi, pdata->hashlo);\n}\n\nstatic void smsc911x_rx_multicast_update_workaround(struct smsc911x_data *pdata)\n{\n\tunsigned int mac_cr;\n\n\t \n\n\tspin_lock(&pdata->mac_lock);\n\n\t \n\tif (smsc911x_mac_read(pdata, MAC_CR) & MAC_CR_RXEN_)\n\t\tSMSC_WARN(pdata, drv, \"Rx not stopped\");\n\n\t \n\tsmsc911x_rx_multicast_update(pdata);\n\n\t \n\tmac_cr = smsc911x_mac_read(pdata, MAC_CR);\n\tmac_cr |= MAC_CR_RXEN_;\n\tsmsc911x_mac_write(pdata, MAC_CR, mac_cr);\n\n\tpdata->multicast_update_pending = 0;\n\n\tspin_unlock(&pdata->mac_lock);\n}\n\nstatic int smsc911x_phy_general_power_up(struct smsc911x_data *pdata)\n{\n\tstruct net_device *ndev = pdata->dev;\n\tstruct phy_device *phy_dev = ndev->phydev;\n\tint rc = 0;\n\n\tif (!phy_dev)\n\t\treturn rc;\n\n\t \n\trc = phy_read(phy_dev, MII_BMCR);\n\tif (rc < 0) {\n\t\tSMSC_WARN(pdata, drv, \"Failed reading PHY control reg\");\n\t\treturn rc;\n\t}\n\n\t \n\tif (rc & BMCR_PDOWN) {\n\t\trc = phy_write(phy_dev, MII_BMCR, rc & ~BMCR_PDOWN);\n\t\tif (rc < 0) {\n\t\t\tSMSC_WARN(pdata, drv, \"Failed writing PHY control reg\");\n\t\t\treturn rc;\n\t\t}\n\n\t\tusleep_range(1000, 1500);\n\t}\n\n\treturn 0;\n}\n\nstatic int smsc911x_phy_disable_energy_detect(struct smsc911x_data *pdata)\n{\n\tstruct net_device *ndev = pdata->dev;\n\tstruct phy_device *phy_dev = ndev->phydev;\n\tint rc = 0;\n\n\tif (!phy_dev)\n\t\treturn rc;\n\n\trc = phy_read(phy_dev, MII_LAN83C185_CTRL_STATUS);\n\n\tif (rc < 0) {\n\t\tSMSC_WARN(pdata, drv, \"Failed reading PHY control reg\");\n\t\treturn rc;\n\t}\n\n\t \n\tif (rc & MII_LAN83C185_EDPWRDOWN) {\n\t\t \n\t\trc = phy_write(phy_dev, MII_LAN83C185_CTRL_STATUS,\n\t\t\t       rc & (~MII_LAN83C185_EDPWRDOWN));\n\n\t\tif (rc < 0) {\n\t\t\tSMSC_WARN(pdata, drv, \"Failed writing PHY control reg\");\n\t\t\treturn rc;\n\t\t}\n\t\t \n\t\tmdelay(2);\n\t}\n\n\treturn 0;\n}\n\nstatic int smsc911x_phy_enable_energy_detect(struct smsc911x_data *pdata)\n{\n\tstruct net_device *ndev = pdata->dev;\n\tstruct phy_device *phy_dev = ndev->phydev;\n\tint rc = 0;\n\n\tif (!phy_dev)\n\t\treturn rc;\n\n\trc = phy_read(phy_dev, MII_LAN83C185_CTRL_STATUS);\n\n\tif (rc < 0) {\n\t\tSMSC_WARN(pdata, drv, \"Failed reading PHY control reg\");\n\t\treturn rc;\n\t}\n\n\t \n\tif (!(rc & MII_LAN83C185_EDPWRDOWN)) {\n\t\t \n\t\trc = phy_write(phy_dev, MII_LAN83C185_CTRL_STATUS,\n\t\t\t       rc | MII_LAN83C185_EDPWRDOWN);\n\n\t\tif (rc < 0) {\n\t\t\tSMSC_WARN(pdata, drv, \"Failed writing PHY control reg\");\n\t\t\treturn rc;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int smsc911x_soft_reset(struct smsc911x_data *pdata)\n{\n\tunsigned int timeout;\n\tunsigned int temp;\n\tint ret;\n\tunsigned int reset_offset = HW_CFG;\n\tunsigned int reset_mask = HW_CFG_SRST_;\n\n\t \n\tret = smsc911x_phy_general_power_up(pdata);\n\tif (ret) {\n\t\tSMSC_WARN(pdata, drv, \"Failed to power-up the PHY chip\");\n\t\treturn ret;\n\t}\n\n\t \n\tif (pdata->generation == 4) {\n\t\tret = smsc911x_phy_disable_energy_detect(pdata);\n\n\t\tif (ret) {\n\t\t\tSMSC_WARN(pdata, drv, \"Failed to wakeup the PHY chip\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif ((pdata->idrev & 0xFFFF0000) == LAN9250) {\n\t\t \n\t\treset_offset = RESET_CTL;\n\t\treset_mask = RESET_CTL_DIGITAL_RST_;\n\t}\n\n\t \n\tsmsc911x_reg_write(pdata, reset_offset, reset_mask);\n\n\t \n\ttimeout = 10;\n\tdo {\n\t\tudelay(10);\n\t\ttemp = smsc911x_reg_read(pdata, reset_offset);\n\t} while ((--timeout) && (temp & reset_mask));\n\n\tif (unlikely(temp & reset_mask)) {\n\t\tSMSC_WARN(pdata, drv, \"Failed to complete reset\");\n\t\treturn -EIO;\n\t}\n\n\tif (pdata->generation == 4) {\n\t\tret = smsc911x_phy_enable_energy_detect(pdata);\n\n\t\tif (ret) {\n\t\t\tSMSC_WARN(pdata, drv, \"Failed to wakeup the PHY chip\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic void\nsmsc911x_set_hw_mac_address(struct smsc911x_data *pdata, const u8 dev_addr[6])\n{\n\tu32 mac_high16 = (dev_addr[5] << 8) | dev_addr[4];\n\tu32 mac_low32 = (dev_addr[3] << 24) | (dev_addr[2] << 16) |\n\t    (dev_addr[1] << 8) | dev_addr[0];\n\n\tSMSC_ASSERT_MAC_LOCK(pdata);\n\n\tsmsc911x_mac_write(pdata, ADDRH, mac_high16);\n\tsmsc911x_mac_write(pdata, ADDRL, mac_low32);\n}\n\nstatic void smsc911x_disable_irq_chip(struct net_device *dev)\n{\n\tstruct smsc911x_data *pdata = netdev_priv(dev);\n\n\tsmsc911x_reg_write(pdata, INT_EN, 0);\n\tsmsc911x_reg_write(pdata, INT_STS, 0xFFFFFFFF);\n}\n\nstatic irqreturn_t smsc911x_irqhandler(int irq, void *dev_id)\n{\n\tstruct net_device *dev = dev_id;\n\tstruct smsc911x_data *pdata = netdev_priv(dev);\n\tu32 intsts = smsc911x_reg_read(pdata, INT_STS);\n\tu32 inten = smsc911x_reg_read(pdata, INT_EN);\n\tint serviced = IRQ_NONE;\n\tu32 temp;\n\n\tif (unlikely(intsts & inten & INT_STS_SW_INT_)) {\n\t\ttemp = smsc911x_reg_read(pdata, INT_EN);\n\t\ttemp &= (~INT_EN_SW_INT_EN_);\n\t\tsmsc911x_reg_write(pdata, INT_EN, temp);\n\t\tsmsc911x_reg_write(pdata, INT_STS, INT_STS_SW_INT_);\n\t\tpdata->software_irq_signal = 1;\n\t\tsmp_wmb();\n\t\tserviced = IRQ_HANDLED;\n\t}\n\n\tif (unlikely(intsts & inten & INT_STS_RXSTOP_INT_)) {\n\t\t \n\t\tSMSC_TRACE(pdata, intr, \"RX Stop interrupt\");\n\t\tsmsc911x_reg_write(pdata, INT_STS, INT_STS_RXSTOP_INT_);\n\t\tif (pdata->multicast_update_pending)\n\t\t\tsmsc911x_rx_multicast_update_workaround(pdata);\n\t\tserviced = IRQ_HANDLED;\n\t}\n\n\tif (intsts & inten & INT_STS_TDFA_) {\n\t\ttemp = smsc911x_reg_read(pdata, FIFO_INT);\n\t\ttemp |= FIFO_INT_TX_AVAIL_LEVEL_;\n\t\tsmsc911x_reg_write(pdata, FIFO_INT, temp);\n\t\tsmsc911x_reg_write(pdata, INT_STS, INT_STS_TDFA_);\n\t\tnetif_wake_queue(dev);\n\t\tserviced = IRQ_HANDLED;\n\t}\n\n\tif (unlikely(intsts & inten & INT_STS_RXE_)) {\n\t\tSMSC_TRACE(pdata, intr, \"RX Error interrupt\");\n\t\tsmsc911x_reg_write(pdata, INT_STS, INT_STS_RXE_);\n\t\tserviced = IRQ_HANDLED;\n\t}\n\n\tif (likely(intsts & inten & INT_STS_RSFL_)) {\n\t\tif (likely(napi_schedule_prep(&pdata->napi))) {\n\t\t\t \n\t\t\ttemp = smsc911x_reg_read(pdata, INT_EN);\n\t\t\ttemp &= (~INT_EN_RSFL_EN_);\n\t\t\tsmsc911x_reg_write(pdata, INT_EN, temp);\n\t\t\t \n\t\t\t__napi_schedule(&pdata->napi);\n\t\t} else {\n\t\t\tSMSC_WARN(pdata, rx_err, \"napi_schedule_prep failed\");\n\t\t}\n\t\tserviced = IRQ_HANDLED;\n\t}\n\n\treturn serviced;\n}\n\nstatic int smsc911x_open(struct net_device *dev)\n{\n\tstruct smsc911x_data *pdata = netdev_priv(dev);\n\tunsigned int timeout;\n\tunsigned int temp;\n\tunsigned int intcfg;\n\tint retval;\n\tint irq_flags;\n\n\tpm_runtime_get_sync(dev->dev.parent);\n\n\t \n\tif (!dev->phydev) {\n\t\tretval = smsc911x_mii_probe(dev);\n\t\tif (retval < 0) {\n\t\t\tSMSC_WARN(pdata, probe, \"Error starting phy\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tretval = smsc911x_soft_reset(pdata);\n\tif (retval) {\n\t\tSMSC_WARN(pdata, hw, \"soft reset failed\");\n\t\tgoto mii_free_out;\n\t}\n\n\tsmsc911x_reg_write(pdata, HW_CFG, 0x00050000);\n\tsmsc911x_reg_write(pdata, AFC_CFG, 0x006E3740);\n\n\t \n\tspin_lock_irq(&pdata->mac_lock);\n\tsmsc911x_mac_write(pdata, VLAN1, ETH_P_8021Q);\n\tspin_unlock_irq(&pdata->mac_lock);\n\n\t \n\ttimeout = 50;\n\twhile ((smsc911x_reg_read(pdata, E2P_CMD) & E2P_CMD_EPC_BUSY_) &&\n\t       --timeout) {\n\t\tudelay(10);\n\t}\n\n\tif (unlikely(timeout == 0))\n\t\tSMSC_WARN(pdata, ifup,\n\t\t\t  \"Timed out waiting for EEPROM busy bit to clear\");\n\n\tsmsc911x_reg_write(pdata, GPIO_CFG, 0x70070000);\n\n\t \n\tspin_lock_irq(&pdata->mac_lock);\n\tsmsc911x_set_hw_mac_address(pdata, dev->dev_addr);\n\tspin_unlock_irq(&pdata->mac_lock);\n\n\t \n\tsmsc911x_disable_irq_chip(dev);\n\n\t \n\tintcfg = ((10 << 24) | INT_CFG_IRQ_EN_);\n\n\tif (pdata->config.irq_polarity) {\n\t\tSMSC_TRACE(pdata, ifup, \"irq polarity: active high\");\n\t\tintcfg |= INT_CFG_IRQ_POL_;\n\t} else {\n\t\tSMSC_TRACE(pdata, ifup, \"irq polarity: active low\");\n\t}\n\n\tif (pdata->config.irq_type) {\n\t\tSMSC_TRACE(pdata, ifup, \"irq type: push-pull\");\n\t\tintcfg |= INT_CFG_IRQ_TYPE_;\n\t} else {\n\t\tSMSC_TRACE(pdata, ifup, \"irq type: open drain\");\n\t}\n\n\tsmsc911x_reg_write(pdata, INT_CFG, intcfg);\n\n\tSMSC_TRACE(pdata, ifup, \"Testing irq handler using IRQ %d\", dev->irq);\n\tpdata->software_irq_signal = 0;\n\tsmp_wmb();\n\n\tirq_flags = irq_get_trigger_type(dev->irq);\n\tretval = request_irq(dev->irq, smsc911x_irqhandler,\n\t\t\t     irq_flags | IRQF_SHARED, dev->name, dev);\n\tif (retval) {\n\t\tSMSC_WARN(pdata, probe,\n\t\t\t  \"Unable to claim requested irq: %d\", dev->irq);\n\t\tgoto mii_free_out;\n\t}\n\n\ttemp = smsc911x_reg_read(pdata, INT_EN);\n\ttemp |= INT_EN_SW_INT_EN_;\n\tsmsc911x_reg_write(pdata, INT_EN, temp);\n\n\ttimeout = 1000;\n\twhile (timeout--) {\n\t\tif (pdata->software_irq_signal)\n\t\t\tbreak;\n\t\tmsleep(1);\n\t}\n\n\tif (!pdata->software_irq_signal) {\n\t\tnetdev_warn(dev, \"ISR failed signaling test (IRQ %d)\\n\",\n\t\t\t    dev->irq);\n\t\tretval = -ENODEV;\n\t\tgoto irq_stop_out;\n\t}\n\tSMSC_TRACE(pdata, ifup, \"IRQ handler passed test using IRQ %d\",\n\t\t   dev->irq);\n\n\tnetdev_info(dev, \"SMSC911x/921x identified at %#08lx, IRQ: %d\\n\",\n\t\t    (unsigned long)pdata->ioaddr, dev->irq);\n\n\t \n\tpdata->last_duplex = -1;\n\tpdata->last_carrier = -1;\n\n\t \n\tphy_start(dev->phydev);\n\n\ttemp = smsc911x_reg_read(pdata, HW_CFG);\n\t \n\ttemp &= (HW_CFG_TX_FIF_SZ_|0x00000FFF);\n\ttemp |= HW_CFG_SF_;\n\tsmsc911x_reg_write(pdata, HW_CFG, temp);\n\n\ttemp = smsc911x_reg_read(pdata, FIFO_INT);\n\ttemp |= FIFO_INT_TX_AVAIL_LEVEL_;\n\ttemp &= ~(FIFO_INT_RX_STS_LEVEL_);\n\tsmsc911x_reg_write(pdata, FIFO_INT, temp);\n\n\t \n\tsmsc911x_reg_write(pdata, RX_CFG, (NET_IP_ALIGN << 8));\n\n\t \n\tnapi_enable(&pdata->napi);\n\n\ttemp = smsc911x_reg_read(pdata, INT_EN);\n\ttemp |= (INT_EN_TDFA_EN_ | INT_EN_RSFL_EN_ | INT_EN_RXSTOP_INT_EN_);\n\tsmsc911x_reg_write(pdata, INT_EN, temp);\n\n\tspin_lock_irq(&pdata->mac_lock);\n\ttemp = smsc911x_mac_read(pdata, MAC_CR);\n\ttemp |= (MAC_CR_TXEN_ | MAC_CR_RXEN_ | MAC_CR_HBDIS_);\n\tsmsc911x_mac_write(pdata, MAC_CR, temp);\n\tspin_unlock_irq(&pdata->mac_lock);\n\n\tsmsc911x_reg_write(pdata, TX_CFG, TX_CFG_TX_ON_);\n\n\tnetif_start_queue(dev);\n\treturn 0;\n\nirq_stop_out:\n\tfree_irq(dev->irq, dev);\nmii_free_out:\n\tphy_disconnect(dev->phydev);\nout:\n\tpm_runtime_put(dev->dev.parent);\n\treturn retval;\n}\n\n \nstatic int smsc911x_stop(struct net_device *dev)\n{\n\tstruct smsc911x_data *pdata = netdev_priv(dev);\n\tunsigned int temp;\n\n\t \n\ttemp = smsc911x_reg_read(pdata, INT_CFG);\n\ttemp &= ~INT_CFG_IRQ_EN_;\n\tsmsc911x_reg_write(pdata, INT_CFG, temp);\n\n\t \n\tnetif_stop_queue(dev);\n\tnapi_disable(&pdata->napi);\n\n\t \n\tdev->stats.rx_dropped += smsc911x_reg_read(pdata, RX_DROP);\n\tsmsc911x_tx_update_txcounters(dev);\n\n\tfree_irq(dev->irq, dev);\n\n\t \n\tif (dev->phydev) {\n\t\tphy_stop(dev->phydev);\n\t\tphy_disconnect(dev->phydev);\n\t}\n\tnetif_carrier_off(dev);\n\tpm_runtime_put(dev->dev.parent);\n\n\tSMSC_TRACE(pdata, ifdown, \"Interface stopped\");\n\treturn 0;\n}\n\n \nstatic netdev_tx_t\nsmsc911x_hard_start_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct smsc911x_data *pdata = netdev_priv(dev);\n\tunsigned int freespace;\n\tunsigned int tx_cmd_a;\n\tunsigned int tx_cmd_b;\n\tunsigned int temp;\n\tu32 wrsz;\n\tulong bufp;\n\n\tfreespace = smsc911x_reg_read(pdata, TX_FIFO_INF) & TX_FIFO_INF_TDFREE_;\n\n\tif (unlikely(freespace < TX_FIFO_LOW_THRESHOLD))\n\t\tSMSC_WARN(pdata, tx_err,\n\t\t\t  \"Tx data fifo low, space available: %d\", freespace);\n\n\t \n\ttx_cmd_a = (u32)((ulong)skb->data & 0x03) << 16;\n\ttx_cmd_a |= TX_CMD_A_FIRST_SEG_ | TX_CMD_A_LAST_SEG_;\n\ttx_cmd_a |= (unsigned int)skb->len;\n\n\ttx_cmd_b = ((unsigned int)skb->len) << 16;\n\ttx_cmd_b |= (unsigned int)skb->len;\n\n\tsmsc911x_reg_write(pdata, TX_DATA_FIFO, tx_cmd_a);\n\tsmsc911x_reg_write(pdata, TX_DATA_FIFO, tx_cmd_b);\n\n\tbufp = (ulong)skb->data & (~0x3);\n\twrsz = (u32)skb->len + 3;\n\twrsz += (u32)((ulong)skb->data & 0x3);\n\twrsz >>= 2;\n\n\tpdata->ops->tx_writefifo(pdata, (unsigned int *)bufp, wrsz);\n\tfreespace -= (skb->len + 32);\n\tskb_tx_timestamp(skb);\n\tdev_consume_skb_any(skb);\n\n\tif (unlikely(smsc911x_tx_get_txstatcount(pdata) >= 30))\n\t\tsmsc911x_tx_update_txcounters(dev);\n\n\tif (freespace < TX_FIFO_LOW_THRESHOLD) {\n\t\tnetif_stop_queue(dev);\n\t\ttemp = smsc911x_reg_read(pdata, FIFO_INT);\n\t\ttemp &= 0x00FFFFFF;\n\t\ttemp |= 0x32000000;\n\t\tsmsc911x_reg_write(pdata, FIFO_INT, temp);\n\t}\n\n\treturn NETDEV_TX_OK;\n}\n\n \nstatic struct net_device_stats *smsc911x_get_stats(struct net_device *dev)\n{\n\tstruct smsc911x_data *pdata = netdev_priv(dev);\n\tsmsc911x_tx_update_txcounters(dev);\n\tdev->stats.rx_dropped += smsc911x_reg_read(pdata, RX_DROP);\n\treturn &dev->stats;\n}\n\n \nstatic void smsc911x_set_multicast_list(struct net_device *dev)\n{\n\tstruct smsc911x_data *pdata = netdev_priv(dev);\n\tunsigned long flags;\n\n\tif (dev->flags & IFF_PROMISC) {\n\t\t \n\t\tpdata->set_bits_mask = MAC_CR_PRMS_;\n\t\tpdata->clear_bits_mask = (MAC_CR_MCPAS_ | MAC_CR_HPFILT_);\n\t\tpdata->hashhi = 0;\n\t\tpdata->hashlo = 0;\n\t} else if (dev->flags & IFF_ALLMULTI) {\n\t\t \n\t\tpdata->set_bits_mask = MAC_CR_MCPAS_;\n\t\tpdata->clear_bits_mask = (MAC_CR_PRMS_ | MAC_CR_HPFILT_);\n\t\tpdata->hashhi = 0;\n\t\tpdata->hashlo = 0;\n\t} else if (!netdev_mc_empty(dev)) {\n\t\t \n\t\tunsigned int hash_high = 0;\n\t\tunsigned int hash_low = 0;\n\t\tstruct netdev_hw_addr *ha;\n\n\t\tpdata->set_bits_mask = MAC_CR_HPFILT_;\n\t\tpdata->clear_bits_mask = (MAC_CR_PRMS_ | MAC_CR_MCPAS_);\n\n\t\tnetdev_for_each_mc_addr(ha, dev) {\n\t\t\tunsigned int bitnum = smsc911x_hash(ha->addr);\n\t\t\tunsigned int mask = 0x01 << (bitnum & 0x1F);\n\n\t\t\tif (bitnum & 0x20)\n\t\t\t\thash_high |= mask;\n\t\t\telse\n\t\t\t\thash_low |= mask;\n\t\t}\n\n\t\tpdata->hashhi = hash_high;\n\t\tpdata->hashlo = hash_low;\n\t} else {\n\t\t \n\t\tpdata->set_bits_mask = 0;\n\t\tpdata->clear_bits_mask =\n\t\t    (MAC_CR_PRMS_ | MAC_CR_MCPAS_ | MAC_CR_HPFILT_);\n\t\tpdata->hashhi = 0;\n\t\tpdata->hashlo = 0;\n\t}\n\n\tspin_lock_irqsave(&pdata->mac_lock, flags);\n\n\tif (pdata->generation <= 1) {\n\t\t \n\t\tif (!pdata->multicast_update_pending) {\n\t\t\tunsigned int temp;\n\t\t\tSMSC_TRACE(pdata, hw, \"scheduling mcast update\");\n\t\t\tpdata->multicast_update_pending = 1;\n\n\t\t\t \n\t\t\ttemp = smsc911x_mac_read(pdata, MAC_CR);\n\t\t\ttemp &= ~(MAC_CR_RXEN_);\n\t\t\tsmsc911x_mac_write(pdata, MAC_CR, temp);\n\t\t} else {\n\t\t\t \n\t\t}\n\t} else {\n\t\t \n\t\tsmsc911x_rx_multicast_update(pdata);\n\t}\n\n\tspin_unlock_irqrestore(&pdata->mac_lock, flags);\n}\n\n#ifdef CONFIG_NET_POLL_CONTROLLER\nstatic void smsc911x_poll_controller(struct net_device *dev)\n{\n\tdisable_irq(dev->irq);\n\tsmsc911x_irqhandler(0, dev);\n\tenable_irq(dev->irq);\n}\n#endif\t\t\t\t \n\nstatic int smsc911x_set_mac_address(struct net_device *dev, void *p)\n{\n\tstruct smsc911x_data *pdata = netdev_priv(dev);\n\tstruct sockaddr *addr = p;\n\n\t \n\tif (pdata->generation <= 1 && netif_running(dev))\n\t\treturn -EBUSY;\n\n\tif (!is_valid_ether_addr(addr->sa_data))\n\t\treturn -EADDRNOTAVAIL;\n\n\teth_hw_addr_set(dev, addr->sa_data);\n\n\tspin_lock_irq(&pdata->mac_lock);\n\tsmsc911x_set_hw_mac_address(pdata, dev->dev_addr);\n\tspin_unlock_irq(&pdata->mac_lock);\n\n\tnetdev_info(dev, \"MAC Address: %pM\\n\", dev->dev_addr);\n\n\treturn 0;\n}\n\nstatic void smsc911x_ethtool_getdrvinfo(struct net_device *dev,\n\t\t\t\t\tstruct ethtool_drvinfo *info)\n{\n\tstrscpy(info->driver, SMSC_CHIPNAME, sizeof(info->driver));\n\tstrscpy(info->version, SMSC_DRV_VERSION, sizeof(info->version));\n\tstrscpy(info->bus_info, dev_name(dev->dev.parent),\n\t\tsizeof(info->bus_info));\n}\n\nstatic u32 smsc911x_ethtool_getmsglevel(struct net_device *dev)\n{\n\tstruct smsc911x_data *pdata = netdev_priv(dev);\n\treturn pdata->msg_enable;\n}\n\nstatic void smsc911x_ethtool_setmsglevel(struct net_device *dev, u32 level)\n{\n\tstruct smsc911x_data *pdata = netdev_priv(dev);\n\tpdata->msg_enable = level;\n}\n\nstatic int smsc911x_ethtool_getregslen(struct net_device *dev)\n{\n\treturn (((E2P_DATA - ID_REV) / 4 + 1) + (WUCSR - MAC_CR) + 1 + 32) *\n\t    sizeof(u32);\n}\n\nstatic void\nsmsc911x_ethtool_getregs(struct net_device *dev, struct ethtool_regs *regs,\n\t\t\t void *buf)\n{\n\tstruct smsc911x_data *pdata = netdev_priv(dev);\n\tstruct phy_device *phy_dev = dev->phydev;\n\tunsigned long flags;\n\tunsigned int i;\n\tunsigned int j = 0;\n\tu32 *data = buf;\n\n\tregs->version = pdata->idrev;\n\tfor (i = ID_REV; i <= E2P_DATA; i += (sizeof(u32)))\n\t\tdata[j++] = smsc911x_reg_read(pdata, i);\n\n\tfor (i = MAC_CR; i <= WUCSR; i++) {\n\t\tspin_lock_irqsave(&pdata->mac_lock, flags);\n\t\tdata[j++] = smsc911x_mac_read(pdata, i);\n\t\tspin_unlock_irqrestore(&pdata->mac_lock, flags);\n\t}\n\n\tfor (i = 0; i <= 31; i++)\n\t\tdata[j++] = smsc911x_mii_read(phy_dev->mdio.bus,\n\t\t\t\t\t      phy_dev->mdio.addr, i);\n}\n\nstatic void smsc911x_eeprom_enable_access(struct smsc911x_data *pdata)\n{\n\tunsigned int temp = smsc911x_reg_read(pdata, GPIO_CFG);\n\ttemp &= ~GPIO_CFG_EEPR_EN_;\n\tsmsc911x_reg_write(pdata, GPIO_CFG, temp);\n\tmsleep(1);\n}\n\nstatic int smsc911x_eeprom_send_cmd(struct smsc911x_data *pdata, u32 op)\n{\n\tint timeout = 100;\n\tu32 e2cmd;\n\n\tSMSC_TRACE(pdata, drv, \"op 0x%08x\", op);\n\tif (smsc911x_reg_read(pdata, E2P_CMD) & E2P_CMD_EPC_BUSY_) {\n\t\tSMSC_WARN(pdata, drv, \"Busy at start\");\n\t\treturn -EBUSY;\n\t}\n\n\te2cmd = op | E2P_CMD_EPC_BUSY_;\n\tsmsc911x_reg_write(pdata, E2P_CMD, e2cmd);\n\n\tdo {\n\t\tmsleep(1);\n\t\te2cmd = smsc911x_reg_read(pdata, E2P_CMD);\n\t} while ((e2cmd & E2P_CMD_EPC_BUSY_) && (--timeout));\n\n\tif (!timeout) {\n\t\tSMSC_TRACE(pdata, drv, \"TIMED OUT\");\n\t\treturn -EAGAIN;\n\t}\n\n\tif (e2cmd & E2P_CMD_EPC_TIMEOUT_) {\n\t\tSMSC_TRACE(pdata, drv, \"Error occurred during eeprom operation\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int smsc911x_eeprom_read_location(struct smsc911x_data *pdata,\n\t\t\t\t\t u8 address, u8 *data)\n{\n\tu32 op = E2P_CMD_EPC_CMD_READ_ | address;\n\tint ret;\n\n\tSMSC_TRACE(pdata, drv, \"address 0x%x\", address);\n\tret = smsc911x_eeprom_send_cmd(pdata, op);\n\n\tif (!ret)\n\t\tdata[address] = smsc911x_reg_read(pdata, E2P_DATA);\n\n\treturn ret;\n}\n\nstatic int smsc911x_eeprom_write_location(struct smsc911x_data *pdata,\n\t\t\t\t\t  u8 address, u8 data)\n{\n\tu32 op = E2P_CMD_EPC_CMD_ERASE_ | address;\n\tint ret;\n\n\tSMSC_TRACE(pdata, drv, \"address 0x%x, data 0x%x\", address, data);\n\tret = smsc911x_eeprom_send_cmd(pdata, op);\n\n\tif (!ret) {\n\t\top = E2P_CMD_EPC_CMD_WRITE_ | address;\n\t\tsmsc911x_reg_write(pdata, E2P_DATA, (u32)data);\n\n\t\t \n\t\tsmsc911x_reg_read(pdata, BYTE_TEST);\n\n\t\tret = smsc911x_eeprom_send_cmd(pdata, op);\n\t}\n\n\treturn ret;\n}\n\nstatic int smsc911x_ethtool_get_eeprom_len(struct net_device *dev)\n{\n\treturn SMSC911X_EEPROM_SIZE;\n}\n\nstatic int smsc911x_ethtool_get_eeprom(struct net_device *dev,\n\t\t\t\t       struct ethtool_eeprom *eeprom, u8 *data)\n{\n\tstruct smsc911x_data *pdata = netdev_priv(dev);\n\tu8 eeprom_data[SMSC911X_EEPROM_SIZE];\n\tint len;\n\tint i;\n\n\tsmsc911x_eeprom_enable_access(pdata);\n\n\tlen = min(eeprom->len, SMSC911X_EEPROM_SIZE);\n\tfor (i = 0; i < len; i++) {\n\t\tint ret = smsc911x_eeprom_read_location(pdata, i, eeprom_data);\n\t\tif (ret < 0) {\n\t\t\teeprom->len = 0;\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tmemcpy(data, &eeprom_data[eeprom->offset], len);\n\teeprom->len = len;\n\treturn 0;\n}\n\nstatic int smsc911x_ethtool_set_eeprom(struct net_device *dev,\n\t\t\t\t       struct ethtool_eeprom *eeprom, u8 *data)\n{\n\tint ret;\n\tstruct smsc911x_data *pdata = netdev_priv(dev);\n\n\tsmsc911x_eeprom_enable_access(pdata);\n\tsmsc911x_eeprom_send_cmd(pdata, E2P_CMD_EPC_CMD_EWEN_);\n\tret = smsc911x_eeprom_write_location(pdata, eeprom->offset, *data);\n\tsmsc911x_eeprom_send_cmd(pdata, E2P_CMD_EPC_CMD_EWDS_);\n\n\t \n\teeprom->len = 1;\n\n\treturn ret;\n}\n\nstatic const struct ethtool_ops smsc911x_ethtool_ops = {\n\t.get_link = ethtool_op_get_link,\n\t.get_drvinfo = smsc911x_ethtool_getdrvinfo,\n\t.nway_reset = phy_ethtool_nway_reset,\n\t.get_msglevel = smsc911x_ethtool_getmsglevel,\n\t.set_msglevel = smsc911x_ethtool_setmsglevel,\n\t.get_regs_len = smsc911x_ethtool_getregslen,\n\t.get_regs = smsc911x_ethtool_getregs,\n\t.get_eeprom_len = smsc911x_ethtool_get_eeprom_len,\n\t.get_eeprom = smsc911x_ethtool_get_eeprom,\n\t.set_eeprom = smsc911x_ethtool_set_eeprom,\n\t.get_ts_info = ethtool_op_get_ts_info,\n\t.get_link_ksettings = phy_ethtool_get_link_ksettings,\n\t.set_link_ksettings = phy_ethtool_set_link_ksettings,\n};\n\nstatic const struct net_device_ops smsc911x_netdev_ops = {\n\t.ndo_open\t\t= smsc911x_open,\n\t.ndo_stop\t\t= smsc911x_stop,\n\t.ndo_start_xmit\t\t= smsc911x_hard_start_xmit,\n\t.ndo_get_stats\t\t= smsc911x_get_stats,\n\t.ndo_set_rx_mode\t= smsc911x_set_multicast_list,\n\t.ndo_eth_ioctl\t\t= phy_do_ioctl_running,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_set_mac_address \t= smsc911x_set_mac_address,\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\t.ndo_poll_controller\t= smsc911x_poll_controller,\n#endif\n};\n\n \nstatic void smsc911x_read_mac_address(struct net_device *dev)\n{\n\tstruct smsc911x_data *pdata = netdev_priv(dev);\n\tu32 mac_high16 = smsc911x_mac_read(pdata, ADDRH);\n\tu32 mac_low32 = smsc911x_mac_read(pdata, ADDRL);\n\tu8 addr[ETH_ALEN];\n\n\taddr[0] = (u8)(mac_low32);\n\taddr[1] = (u8)(mac_low32 >> 8);\n\taddr[2] = (u8)(mac_low32 >> 16);\n\taddr[3] = (u8)(mac_low32 >> 24);\n\taddr[4] = (u8)(mac_high16);\n\taddr[5] = (u8)(mac_high16 >> 8);\n\teth_hw_addr_set(dev, addr);\n}\n\n \nstatic int smsc911x_init(struct net_device *dev)\n{\n\tstruct smsc911x_data *pdata = netdev_priv(dev);\n\tunsigned int byte_test, mask;\n\tunsigned int to = 100;\n\n\tSMSC_TRACE(pdata, probe, \"Driver Parameters:\");\n\tSMSC_TRACE(pdata, probe, \"LAN base: 0x%08lX\",\n\t\t   (unsigned long)pdata->ioaddr);\n\tSMSC_TRACE(pdata, probe, \"IRQ: %d\", dev->irq);\n\tSMSC_TRACE(pdata, probe, \"PHY will be autodetected.\");\n\n\tspin_lock_init(&pdata->dev_lock);\n\tspin_lock_init(&pdata->mac_lock);\n\n\tif (pdata->ioaddr == NULL) {\n\t\tSMSC_WARN(pdata, probe, \"pdata->ioaddr: 0x00000000\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\n\tmask = PMT_CTRL_READY_ | swahw32(PMT_CTRL_READY_);\n\twhile (!(smsc911x_reg_read(pdata, PMT_CTRL) & mask) && --to)\n\t\tudelay(1000);\n\n\tif (to == 0) {\n\t\tnetdev_err(dev, \"Device not READY in 100ms aborting\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tbyte_test = smsc911x_reg_read(pdata, BYTE_TEST);\n\tSMSC_TRACE(pdata, probe, \"BYTE_TEST: 0x%08X\", byte_test);\n\tif (byte_test == 0x43218765) {\n\t\tSMSC_TRACE(pdata, probe, \"BYTE_TEST looks swapped, \"\n\t\t\t   \"applying WORD_SWAP\");\n\t\tsmsc911x_reg_write(pdata, WORD_SWAP, 0xffffffff);\n\n\t\t \n\t\tbyte_test = smsc911x_reg_read(pdata, BYTE_TEST);\n\n\t\tbyte_test = smsc911x_reg_read(pdata, BYTE_TEST);\n\t}\n\n\tif (byte_test != 0x87654321) {\n\t\tSMSC_WARN(pdata, drv, \"BYTE_TEST: 0x%08X\", byte_test);\n\t\tif (((byte_test >> 16) & 0xFFFF) == (byte_test & 0xFFFF)) {\n\t\t\tSMSC_WARN(pdata, probe,\n\t\t\t\t  \"top 16 bits equal to bottom 16 bits\");\n\t\t\tSMSC_TRACE(pdata, probe,\n\t\t\t\t   \"This may mean the chip is set \"\n\t\t\t\t   \"for 32 bit while the bus is reading 16 bit\");\n\t\t}\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tpdata->generation = 0;\n\n\tpdata->idrev = smsc911x_reg_read(pdata, ID_REV);\n\tswitch (pdata->idrev & 0xFFFF0000) {\n\tcase LAN9118:\n\tcase LAN9117:\n\tcase LAN9116:\n\tcase LAN9115:\n\tcase LAN89218:\n\t\t \n\t\tpdata->generation = pdata->idrev & 0x0000FFFF;\n\t\tbreak;\n\n\tcase LAN9218:\n\tcase LAN9217:\n\tcase LAN9216:\n\tcase LAN9215:\n\t\t \n\t\tpdata->generation = 3;\n\t\tbreak;\n\n\tcase LAN9210:\n\tcase LAN9211:\n\tcase LAN9220:\n\tcase LAN9221:\n\tcase LAN9250:\n\t\t \n\t\tpdata->generation = 4;\n\t\tbreak;\n\n\tdefault:\n\t\tSMSC_WARN(pdata, probe, \"LAN911x not identified, idrev: 0x%08X\",\n\t\t\t  pdata->idrev);\n\t\treturn -ENODEV;\n\t}\n\n\tSMSC_TRACE(pdata, probe,\n\t\t   \"LAN911x identified, idrev: 0x%08X, generation: %d\",\n\t\t   pdata->idrev, pdata->generation);\n\n\tif (pdata->generation == 0)\n\t\tSMSC_WARN(pdata, probe,\n\t\t\t  \"This driver is not intended for this chip revision\");\n\n\t \n\tif (pdata->config.flags & SMSC911X_SAVE_MAC_ADDRESS) {\n\t\tspin_lock_irq(&pdata->mac_lock);\n\t\tsmsc911x_read_mac_address(dev);\n\t\tspin_unlock_irq(&pdata->mac_lock);\n\t}\n\n\t \n\tif (smsc911x_phy_reset(pdata) || smsc911x_soft_reset(pdata))\n\t\treturn -ENODEV;\n\n\tdev->flags |= IFF_MULTICAST;\n\tnetif_napi_add_weight(dev, &pdata->napi, smsc911x_poll,\n\t\t\t      SMSC_NAPI_WEIGHT);\n\tdev->netdev_ops = &smsc911x_netdev_ops;\n\tdev->ethtool_ops = &smsc911x_ethtool_ops;\n\n\treturn 0;\n}\n\nstatic int smsc911x_drv_remove(struct platform_device *pdev)\n{\n\tstruct net_device *dev;\n\tstruct smsc911x_data *pdata;\n\tstruct resource *res;\n\n\tdev = platform_get_drvdata(pdev);\n\tBUG_ON(!dev);\n\tpdata = netdev_priv(dev);\n\tBUG_ON(!pdata);\n\tBUG_ON(!pdata->ioaddr);\n\n\tSMSC_TRACE(pdata, ifdown, \"Stopping driver\");\n\n\tunregister_netdev(dev);\n\n\tmdiobus_unregister(pdata->mii_bus);\n\tmdiobus_free(pdata->mii_bus);\n\n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM,\n\t\t\t\t\t   \"smsc911x-memory\");\n\tif (!res)\n\t\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\n\trelease_mem_region(res->start, resource_size(res));\n\n\tiounmap(pdata->ioaddr);\n\n\t(void)smsc911x_disable_resources(pdev);\n\tsmsc911x_free_resources(pdev);\n\n\tfree_netdev(dev);\n\n\tpm_runtime_disable(&pdev->dev);\n\n\treturn 0;\n}\n\n \nstatic const struct smsc911x_ops standard_smsc911x_ops = {\n\t.reg_read = __smsc911x_reg_read,\n\t.reg_write = __smsc911x_reg_write,\n\t.rx_readfifo = smsc911x_rx_readfifo,\n\t.tx_writefifo = smsc911x_tx_writefifo,\n};\n\n \nstatic const struct smsc911x_ops shifted_smsc911x_ops = {\n\t.reg_read = __smsc911x_reg_read_shift,\n\t.reg_write = __smsc911x_reg_write_shift,\n\t.rx_readfifo = smsc911x_rx_readfifo_shift,\n\t.tx_writefifo = smsc911x_tx_writefifo_shift,\n};\n\nstatic int smsc911x_probe_config(struct smsc911x_platform_config *config,\n\t\t\t\t struct device *dev)\n{\n\tint phy_interface;\n\tu32 width = 0;\n\tint err;\n\n\tphy_interface = device_get_phy_mode(dev);\n\tif (phy_interface < 0)\n\t\tphy_interface = PHY_INTERFACE_MODE_NA;\n\tconfig->phy_interface = phy_interface;\n\n\tdevice_get_mac_address(dev, config->mac);\n\n\terr = device_property_read_u32(dev, \"reg-io-width\", &width);\n\tif (err == -ENXIO)\n\t\treturn err;\n\tif (!err && width == 4)\n\t\tconfig->flags |= SMSC911X_USE_32BIT;\n\telse\n\t\tconfig->flags |= SMSC911X_USE_16BIT;\n\n\tdevice_property_read_u32(dev, \"reg-shift\", &config->shift);\n\n\tif (device_property_present(dev, \"smsc,irq-active-high\"))\n\t\tconfig->irq_polarity = SMSC911X_IRQ_POLARITY_ACTIVE_HIGH;\n\n\tif (device_property_present(dev, \"smsc,irq-push-pull\"))\n\t\tconfig->irq_type = SMSC911X_IRQ_TYPE_PUSH_PULL;\n\n\tif (device_property_present(dev, \"smsc,force-internal-phy\"))\n\t\tconfig->flags |= SMSC911X_FORCE_INTERNAL_PHY;\n\n\tif (device_property_present(dev, \"smsc,force-external-phy\"))\n\t\tconfig->flags |= SMSC911X_FORCE_EXTERNAL_PHY;\n\n\tif (device_property_present(dev, \"smsc,save-mac-address\"))\n\t\tconfig->flags |= SMSC911X_SAVE_MAC_ADDRESS;\n\n\treturn 0;\n}\n\nstatic int smsc911x_drv_probe(struct platform_device *pdev)\n{\n\tstruct net_device *dev;\n\tstruct smsc911x_data *pdata;\n\tstruct smsc911x_platform_config *config = dev_get_platdata(&pdev->dev);\n\tstruct resource *res;\n\tint res_size, irq;\n\tint retval;\n\n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM,\n\t\t\t\t\t   \"smsc911x-memory\");\n\tif (!res)\n\t\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res) {\n\t\tpr_warn(\"Could not allocate resource\\n\");\n\t\tretval = -ENODEV;\n\t\tgoto out_0;\n\t}\n\tres_size = resource_size(res);\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq == -EPROBE_DEFER) {\n\t\tretval = -EPROBE_DEFER;\n\t\tgoto out_0;\n\t} else if (irq < 0) {\n\t\tpr_warn(\"Could not allocate irq resource\\n\");\n\t\tretval = -ENODEV;\n\t\tgoto out_0;\n\t}\n\n\tif (!request_mem_region(res->start, res_size, SMSC_CHIPNAME)) {\n\t\tretval = -EBUSY;\n\t\tgoto out_0;\n\t}\n\n\tdev = alloc_etherdev(sizeof(struct smsc911x_data));\n\tif (!dev) {\n\t\tretval = -ENOMEM;\n\t\tgoto out_release_io_1;\n\t}\n\n\tSET_NETDEV_DEV(dev, &pdev->dev);\n\n\tpdata = netdev_priv(dev);\n\tdev->irq = irq;\n\tpdata->ioaddr = ioremap(res->start, res_size);\n\tif (!pdata->ioaddr) {\n\t\tretval = -ENOMEM;\n\t\tgoto out_ioremap_fail;\n\t}\n\n\tpdata->dev = dev;\n\tpdata->msg_enable = ((1 << debug) - 1);\n\n\tplatform_set_drvdata(pdev, dev);\n\n\tretval = smsc911x_request_resources(pdev);\n\tif (retval)\n\t\tgoto out_request_resources_fail;\n\n\tretval = smsc911x_enable_resources(pdev);\n\tif (retval)\n\t\tgoto out_enable_resources_fail;\n\n\tif (pdata->ioaddr == NULL) {\n\t\tSMSC_WARN(pdata, probe, \"Error smsc911x base address invalid\");\n\t\tretval = -ENOMEM;\n\t\tgoto out_disable_resources;\n\t}\n\n\tretval = smsc911x_probe_config(&pdata->config, &pdev->dev);\n\tif (retval && config) {\n\t\t \n\t\tmemcpy(&pdata->config, config, sizeof(pdata->config));\n\t\tretval = 0;\n\t}\n\n\tif (retval) {\n\t\tSMSC_WARN(pdata, probe, \"Error smsc911x config not found\");\n\t\tgoto out_disable_resources;\n\t}\n\n\t \n\tpdata->ops = &standard_smsc911x_ops;\n\t \n\tif (pdata->config.shift)\n\t\tpdata->ops = &shifted_smsc911x_ops;\n\n\tpm_runtime_enable(&pdev->dev);\n\tpm_runtime_get_sync(&pdev->dev);\n\n\tretval = smsc911x_init(dev);\n\tif (retval < 0)\n\t\tgoto out_init_fail;\n\n\tnetif_carrier_off(dev);\n\n\tretval = smsc911x_mii_init(pdev, dev);\n\tif (retval) {\n\t\tSMSC_WARN(pdata, probe, \"Error %i initialising mii\", retval);\n\t\tgoto out_init_fail;\n\t}\n\n\tretval = register_netdev(dev);\n\tif (retval) {\n\t\tSMSC_WARN(pdata, probe, \"Error %i registering device\", retval);\n\t\tgoto out_init_fail;\n\t} else {\n\t\tSMSC_TRACE(pdata, probe,\n\t\t\t   \"Network interface: \\\"%s\\\"\", dev->name);\n\t}\n\n\tspin_lock_irq(&pdata->mac_lock);\n\n\t \n\tif (is_valid_ether_addr(dev->dev_addr)) {\n\t\tsmsc911x_set_hw_mac_address(pdata, dev->dev_addr);\n\t\tSMSC_TRACE(pdata, probe,\n\t\t\t   \"MAC Address is specified by configuration\");\n\t} else if (is_valid_ether_addr(pdata->config.mac)) {\n\t\teth_hw_addr_set(dev, pdata->config.mac);\n\t\tSMSC_TRACE(pdata, probe,\n\t\t\t   \"MAC Address specified by platform data\");\n\t} else {\n\t\t \n\t\tsmsc_get_mac(dev);\n\n\t\tif (is_valid_ether_addr(dev->dev_addr)) {\n\t\t\t \n\t\t\tSMSC_TRACE(pdata, probe,\n\t\t\t\t   \"Mac Address is read from LAN911x EEPROM\");\n\t\t} else {\n\t\t\t \n\t\t\teth_hw_addr_random(dev);\n\t\t\tsmsc911x_set_hw_mac_address(pdata, dev->dev_addr);\n\t\t\tSMSC_TRACE(pdata, probe,\n\t\t\t\t   \"MAC Address is set to eth_random_addr\");\n\t\t}\n\t}\n\n\tspin_unlock_irq(&pdata->mac_lock);\n\tpm_runtime_put(&pdev->dev);\n\n\tnetdev_info(dev, \"MAC Address: %pM\\n\", dev->dev_addr);\n\n\treturn 0;\n\nout_init_fail:\n\tpm_runtime_put(&pdev->dev);\n\tpm_runtime_disable(&pdev->dev);\nout_disable_resources:\n\t(void)smsc911x_disable_resources(pdev);\nout_enable_resources_fail:\n\tsmsc911x_free_resources(pdev);\nout_request_resources_fail:\n\tiounmap(pdata->ioaddr);\nout_ioremap_fail:\n\tfree_netdev(dev);\nout_release_io_1:\n\trelease_mem_region(res->start, resource_size(res));\nout_0:\n\treturn retval;\n}\n\n#ifdef CONFIG_PM\n \n\n \n\nstatic int smsc911x_suspend(struct device *dev)\n{\n\tstruct net_device *ndev = dev_get_drvdata(dev);\n\tstruct smsc911x_data *pdata = netdev_priv(ndev);\n\n\tif (netif_running(ndev)) {\n\t\tnetif_stop_queue(ndev);\n\t\tnetif_device_detach(ndev);\n\t\tif (!device_may_wakeup(dev))\n\t\t\tphy_stop(ndev->phydev);\n\t}\n\n\t \n\tsmsc911x_reg_write(pdata, PMT_CTRL,\n\t\tPMT_CTRL_PM_MODE_D1_ | PMT_CTRL_WOL_EN_ |\n\t\tPMT_CTRL_ED_EN_ | PMT_CTRL_PME_EN_);\n\n\tpm_runtime_disable(dev);\n\tpm_runtime_set_suspended(dev);\n\n\treturn 0;\n}\n\nstatic int smsc911x_resume(struct device *dev)\n{\n\tstruct net_device *ndev = dev_get_drvdata(dev);\n\tstruct smsc911x_data *pdata = netdev_priv(ndev);\n\tunsigned int to = 100;\n\n\tpm_runtime_enable(dev);\n\tpm_runtime_resume(dev);\n\n\t \n\tsmsc911x_reg_write(pdata, BYTE_TEST, 0);\n\n\t \n\twhile (!(smsc911x_reg_read(pdata, PMT_CTRL) & PMT_CTRL_READY_) && --to)\n\t\tudelay(1000);\n\n\tif (to == 0)\n\t\treturn -EIO;\n\n\tif (netif_running(ndev)) {\n\t\tnetif_device_attach(ndev);\n\t\tnetif_start_queue(ndev);\n\t\tif (!device_may_wakeup(dev))\n\t\t\tphy_start(ndev->phydev);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops smsc911x_pm_ops = {\n\t.suspend\t= smsc911x_suspend,\n\t.resume\t\t= smsc911x_resume,\n};\n\n#define SMSC911X_PM_OPS (&smsc911x_pm_ops)\n\n#else\n#define SMSC911X_PM_OPS NULL\n#endif\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id smsc911x_dt_ids[] = {\n\t{ .compatible = \"smsc,lan9115\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, smsc911x_dt_ids);\n#endif\n\n#ifdef CONFIG_ACPI\nstatic const struct acpi_device_id smsc911x_acpi_match[] = {\n\t{ \"ARMH9118\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(acpi, smsc911x_acpi_match);\n#endif\n\nstatic struct platform_driver smsc911x_driver = {\n\t.probe = smsc911x_drv_probe,\n\t.remove = smsc911x_drv_remove,\n\t.driver = {\n\t\t.name\t= SMSC_CHIPNAME,\n\t\t.pm\t= SMSC911X_PM_OPS,\n\t\t.of_match_table = of_match_ptr(smsc911x_dt_ids),\n\t\t.acpi_match_table = ACPI_PTR(smsc911x_acpi_match),\n\t},\n};\n\n \nstatic int __init smsc911x_init_module(void)\n{\n\tSMSC_INITIALIZE();\n\treturn platform_driver_register(&smsc911x_driver);\n}\n\n \nstatic void __exit smsc911x_cleanup_module(void)\n{\n\tplatform_driver_unregister(&smsc911x_driver);\n}\n\nmodule_init(smsc911x_init_module);\nmodule_exit(smsc911x_cleanup_module);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}