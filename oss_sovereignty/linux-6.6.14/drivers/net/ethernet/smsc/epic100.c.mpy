{
  "module_name": "epic100.c",
  "hash_id": "279524b3e957523f6688bb15591b211e30b7492dcea507702849b3791413a404",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/smsc/epic100.c",
  "human_readable_source": " \n \n\n#define DRV_NAME        \"epic100\"\n#define DRV_VERSION     \"2.1\"\n#define DRV_RELDATE     \"Sept 11, 2006\"\n\n \n\nstatic int debug = 1;\t\t\t \n\n \n#define MAX_UNITS 8\t\t \nstatic int options[MAX_UNITS] = {-1, -1, -1, -1, -1, -1, -1, -1};\nstatic int full_duplex[MAX_UNITS] = {-1, -1, -1, -1, -1, -1, -1, -1};\n\n \nstatic int rx_copybreak;\n\n \n\n \n#define TX_RING_SIZE\t256\n#define TX_QUEUE_LEN\t240\t\t \n#define RX_RING_SIZE\t256\n#define TX_TOTAL_SIZE\tTX_RING_SIZE*sizeof(struct epic_tx_desc)\n#define RX_TOTAL_SIZE\tRX_RING_SIZE*sizeof(struct epic_rx_desc)\n\n \n \n#define TX_TIMEOUT  (2*HZ)\n\n#define PKT_BUF_SZ\t\t1536\t\t\t \n\n \n \n#define TX_FIFO_THRESH 256\n#define RX_FIFO_THRESH 1\t\t \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/timer.h>\n#include <linux/errno.h>\n#include <linux/ioport.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/delay.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/spinlock.h>\n#include <linux/ethtool.h>\n#include <linux/mii.h>\n#include <linux/crc32.h>\n#include <linux/bitops.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <asm/byteorder.h>\n\n \nstatic char version[] =\nDRV_NAME \".c:v1.11 1/7/2001 Written by Donald Becker <becker@scyld.com>\";\nstatic char version2[] =\n\"  (unofficial 2.4.x kernel port, version \" DRV_VERSION \", \" DRV_RELDATE \")\";\n\nMODULE_AUTHOR(\"Donald Becker <becker@scyld.com>\");\nMODULE_DESCRIPTION(\"SMC 83c170 EPIC series Ethernet driver\");\nMODULE_LICENSE(\"GPL\");\n\nmodule_param(debug, int, 0);\nmodule_param(rx_copybreak, int, 0);\nmodule_param_array(options, int, NULL, 0);\nmodule_param_array(full_duplex, int, NULL, 0);\nMODULE_PARM_DESC(debug, \"EPIC/100 debug level (0-5)\");\nMODULE_PARM_DESC(options, \"EPIC/100: Bits 0-3: media type, bit 4: full duplex\");\nMODULE_PARM_DESC(rx_copybreak, \"EPIC/100 copy breakpoint for copy-only-tiny-frames\");\nMODULE_PARM_DESC(full_duplex, \"EPIC/100 full duplex setting(s) (1)\");\n\n \n\n\nenum chip_capability_flags { MII_PWRDWN=1, TYPE2_INTR=2, NO_MII=4 };\n\n#define EPIC_TOTAL_SIZE 0x100\n#define USE_IO_OPS 1\n\n#ifdef USE_IO_OPS\n#define EPIC_BAR\t0\n#else\n#define EPIC_BAR\t1\n#endif\n\ntypedef enum {\n\tSMSC_83C170_0,\n\tSMSC_83C170,\n\tSMSC_83C175,\n} chip_t;\n\n\nstruct epic_chip_info {\n\tconst char *name;\n        int drv_flags;                           \n};\n\n\n \nstatic const struct epic_chip_info pci_id_tbl[] = {\n\t{ \"SMSC EPIC/100 83c170\",\tTYPE2_INTR | NO_MII | MII_PWRDWN },\n\t{ \"SMSC EPIC/100 83c170\",\tTYPE2_INTR },\n\t{ \"SMSC EPIC/C 83c175\",\t\tTYPE2_INTR | MII_PWRDWN },\n};\n\n\nstatic const struct pci_device_id epic_pci_tbl[] = {\n\t{ 0x10B8, 0x0005, 0x1092, 0x0AB4, 0, 0, SMSC_83C170_0 },\n\t{ 0x10B8, 0x0005, PCI_ANY_ID, PCI_ANY_ID, 0, 0, SMSC_83C170 },\n\t{ 0x10B8, 0x0006, PCI_ANY_ID, PCI_ANY_ID,\n\t  PCI_CLASS_NETWORK_ETHERNET << 8, 0xffff00, SMSC_83C175 },\n\t{ 0,}\n};\nMODULE_DEVICE_TABLE (pci, epic_pci_tbl);\n\n#define ew16(reg, val)\tiowrite16(val, ioaddr + (reg))\n#define ew32(reg, val)\tiowrite32(val, ioaddr + (reg))\n#define er8(reg)\tioread8(ioaddr + (reg))\n#define er16(reg)\tioread16(ioaddr + (reg))\n#define er32(reg)\tioread32(ioaddr + (reg))\n\n \nenum epic_registers {\n  COMMAND=0, INTSTAT=4, INTMASK=8, GENCTL=0x0C, NVCTL=0x10, EECTL=0x14,\n  PCIBurstCnt=0x18,\n  TEST1=0x1C, CRCCNT=0x20, ALICNT=0x24, MPCNT=0x28,\t \n  MIICtrl=0x30, MIIData=0x34, MIICfg=0x38,\n  LAN0=64,\t\t\t\t\t\t \n  MC0=80,\t\t\t\t\t\t \n  RxCtrl=96, TxCtrl=112, TxSTAT=0x74,\n  PRxCDAR=0x84, RxSTAT=0xA4, EarlyRx=0xB0, PTxCDAR=0xC4, TxThresh=0xDC,\n};\n\n \nenum IntrStatus {\n\tTxIdle=0x40000, RxIdle=0x20000, IntrSummary=0x010000,\n\tPCIBusErr170=0x7000, PCIBusErr175=0x1000, PhyEvent175=0x8000,\n\tRxStarted=0x0800, RxEarlyWarn=0x0400, CntFull=0x0200, TxUnderrun=0x0100,\n\tTxEmpty=0x0080, TxDone=0x0020, RxError=0x0010,\n\tRxOverflow=0x0008, RxFull=0x0004, RxHeader=0x0002, RxDone=0x0001,\n};\nenum CommandBits {\n\tStopRx=1, StartRx=2, TxQueued=4, RxQueued=8,\n\tStopTxDMA=0x20, StopRxDMA=0x40, RestartTx=0x80,\n};\n\n#define EpicRemoved\t0xffffffff\t \n\n#define EpicNapiEvent\t(TxEmpty | TxDone | \\\n\t\t\t RxDone | RxStarted | RxEarlyWarn | RxOverflow | RxFull)\n#define EpicNormalEvent\t(0x0000ffff & ~EpicNapiEvent)\n\nstatic const u16 media2miictl[16] = {\n\t0, 0x0C00, 0x0C00, 0x2000,  0x0100, 0x2100, 0, 0,\n\t0, 0, 0, 0,  0, 0, 0, 0 };\n\n \n\nstruct epic_tx_desc {\n\tu32 txstatus;\n\tu32 bufaddr;\n\tu32 buflength;\n\tu32 next;\n};\n\nstruct epic_rx_desc {\n\tu32 rxstatus;\n\tu32 bufaddr;\n\tu32 buflength;\n\tu32 next;\n};\n\nenum desc_status_bits {\n\tDescOwn=0x8000,\n};\n\n#define PRIV_ALIGN\t15 \t \nstruct epic_private {\n\tstruct epic_rx_desc *rx_ring;\n\tstruct epic_tx_desc *tx_ring;\n\t \n\tstruct sk_buff* tx_skbuff[TX_RING_SIZE];\n\t \n\tstruct sk_buff* rx_skbuff[RX_RING_SIZE];\n\n\tdma_addr_t tx_ring_dma;\n\tdma_addr_t rx_ring_dma;\n\n\t \n\tspinlock_t lock;\t\t\t\t \n\tspinlock_t napi_lock;\n\tstruct napi_struct napi;\n\tunsigned int cur_tx, dirty_tx;\n\n\tunsigned int cur_rx, dirty_rx;\n\tu32 irq_mask;\n\tunsigned int rx_buf_sz;\t\t\t\t \n\n\tvoid __iomem *ioaddr;\n\tstruct pci_dev *pci_dev;\t\t\t \n\tint chip_id, chip_flags;\n\n\tstruct timer_list timer;\t\t\t \n\tint tx_threshold;\n\tunsigned char mc_filter[8];\n\tsigned char phys[4];\t\t\t\t \n\tu16 advertising;\t\t\t\t\t \n\tint mii_phy_cnt;\n\tu32 ethtool_ops_nesting;\n\tstruct mii_if_info mii;\n\tunsigned int tx_full:1;\t\t\t\t \n\tunsigned int default_port:4;\t\t \n};\n\nstatic int epic_open(struct net_device *dev);\nstatic int read_eeprom(struct epic_private *, int);\nstatic int mdio_read(struct net_device *dev, int phy_id, int location);\nstatic void mdio_write(struct net_device *dev, int phy_id, int loc, int val);\nstatic void epic_restart(struct net_device *dev);\nstatic void epic_timer(struct timer_list *t);\nstatic void epic_tx_timeout(struct net_device *dev, unsigned int txqueue);\nstatic void epic_init_ring(struct net_device *dev);\nstatic netdev_tx_t epic_start_xmit(struct sk_buff *skb,\n\t\t\t\t   struct net_device *dev);\nstatic int epic_rx(struct net_device *dev, int budget);\nstatic int epic_poll(struct napi_struct *napi, int budget);\nstatic irqreturn_t epic_interrupt(int irq, void *dev_instance);\nstatic int netdev_ioctl(struct net_device *dev, struct ifreq *rq, int cmd);\nstatic const struct ethtool_ops netdev_ethtool_ops;\nstatic int epic_close(struct net_device *dev);\nstatic struct net_device_stats *epic_get_stats(struct net_device *dev);\nstatic void set_rx_mode(struct net_device *dev);\n\nstatic const struct net_device_ops epic_netdev_ops = {\n\t.ndo_open\t\t= epic_open,\n\t.ndo_stop\t\t= epic_close,\n\t.ndo_start_xmit\t\t= epic_start_xmit,\n\t.ndo_tx_timeout \t= epic_tx_timeout,\n\t.ndo_get_stats\t\t= epic_get_stats,\n\t.ndo_set_rx_mode\t= set_rx_mode,\n\t.ndo_eth_ioctl\t\t= netdev_ioctl,\n\t.ndo_set_mac_address \t= eth_mac_addr,\n\t.ndo_validate_addr\t= eth_validate_addr,\n};\n\nstatic int epic_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tstatic int card_idx = -1;\n\tvoid __iomem *ioaddr;\n\tint chip_idx = (int) ent->driver_data;\n\tstruct net_device *dev;\n\tstruct epic_private *ep;\n\tint i, ret, option = 0, duplex = 0;\n\t__le16 addr[ETH_ALEN / 2];\n\tvoid *ring_space;\n\tdma_addr_t ring_dma;\n\n \n#ifndef MODULE\n\tpr_info_once(\"%s%s\\n\", version, version2);\n#endif\n\n\tcard_idx++;\n\n\tret = pci_enable_device(pdev);\n\tif (ret)\n\t\tgoto out;\n\n\tif (pci_resource_len(pdev, 0) < EPIC_TOTAL_SIZE) {\n\t\tdev_err(&pdev->dev, \"no PCI region space\\n\");\n\t\tret = -ENODEV;\n\t\tgoto err_out_disable;\n\t}\n\n\tpci_set_master(pdev);\n\n\tret = pci_request_regions(pdev, DRV_NAME);\n\tif (ret < 0)\n\t\tgoto err_out_disable;\n\n\tret = -ENOMEM;\n\n\tdev = alloc_etherdev(sizeof (*ep));\n\tif (!dev)\n\t\tgoto err_out_free_res;\n\n\tSET_NETDEV_DEV(dev, &pdev->dev);\n\n\tioaddr = pci_iomap(pdev, EPIC_BAR, 0);\n\tif (!ioaddr) {\n\t\tdev_err(&pdev->dev, \"ioremap failed\\n\");\n\t\tgoto err_out_free_netdev;\n\t}\n\n\tpci_set_drvdata(pdev, dev);\n\tep = netdev_priv(dev);\n\tep->ioaddr = ioaddr;\n\tep->mii.dev = dev;\n\tep->mii.mdio_read = mdio_read;\n\tep->mii.mdio_write = mdio_write;\n\tep->mii.phy_id_mask = 0x1f;\n\tep->mii.reg_num_mask = 0x1f;\n\n\tring_space = dma_alloc_coherent(&pdev->dev, TX_TOTAL_SIZE, &ring_dma,\n\t\t\t\t\tGFP_KERNEL);\n\tif (!ring_space)\n\t\tgoto err_out_iounmap;\n\tep->tx_ring = ring_space;\n\tep->tx_ring_dma = ring_dma;\n\n\tring_space = dma_alloc_coherent(&pdev->dev, RX_TOTAL_SIZE, &ring_dma,\n\t\t\t\t\tGFP_KERNEL);\n\tif (!ring_space)\n\t\tgoto err_out_unmap_tx;\n\tep->rx_ring = ring_space;\n\tep->rx_ring_dma = ring_dma;\n\n\tif (dev->mem_start) {\n\t\toption = dev->mem_start;\n\t\tduplex = (dev->mem_start & 16) ? 1 : 0;\n\t} else if (card_idx >= 0  &&  card_idx < MAX_UNITS) {\n\t\tif (options[card_idx] >= 0)\n\t\t\toption = options[card_idx];\n\t\tif (full_duplex[card_idx] >= 0)\n\t\t\tduplex = full_duplex[card_idx];\n\t}\n\n\tspin_lock_init(&ep->lock);\n\tspin_lock_init(&ep->napi_lock);\n\n\t \n\tew32(GENCTL, 0x4200);\n\t \n\t \n\tfor (i = 16; i > 0; i--)\n\t\tew32(TEST1, 0x0008);\n\n\t \n\tew32(MIICfg, 0x12);\n\tif (chip_idx == 1)\n\t\tew32(NVCTL, (er32(NVCTL) & ~0x003c) | 0x4800);\n\tew32(GENCTL, 0x0200);\n\n\t \n\tfor (i = 0; i < 3; i++)\n\t\taddr[i] = cpu_to_le16(er16(LAN0 + i*4));\n\teth_hw_addr_set(dev, (u8 *)addr);\n\n\tif (debug > 2) {\n\t\tdev_dbg(&pdev->dev, \"EEPROM contents:\\n\");\n\t\tfor (i = 0; i < 64; i++)\n\t\t\tpr_cont(\" %4.4x%s\", read_eeprom(ep, i),\n\t\t\t\t   i % 16 == 15 ? \"\\n\" : \"\");\n\t}\n\n\tep->pci_dev = pdev;\n\tep->chip_id = chip_idx;\n\tep->chip_flags = pci_id_tbl[chip_idx].drv_flags;\n\tep->irq_mask =\n\t\t(ep->chip_flags & TYPE2_INTR ?  PCIBusErr175 : PCIBusErr170)\n\t\t | CntFull | TxUnderrun | EpicNapiEvent;\n\n\t \n\t{\n\t\tint phy, phy_idx = 0;\n\t\tfor (phy = 1; phy < 32 && phy_idx < sizeof(ep->phys); phy++) {\n\t\t\tint mii_status = mdio_read(dev, phy, MII_BMSR);\n\t\t\tif (mii_status != 0xffff  &&  mii_status != 0x0000) {\n\t\t\t\tep->phys[phy_idx++] = phy;\n\t\t\t\tdev_info(&pdev->dev,\n\t\t\t\t\t\"MII transceiver #%d control \"\n\t\t\t\t\t\"%4.4x status %4.4x.\\n\",\n\t\t\t\t\tphy, mdio_read(dev, phy, 0), mii_status);\n\t\t\t}\n\t\t}\n\t\tep->mii_phy_cnt = phy_idx;\n\t\tif (phy_idx != 0) {\n\t\t\tphy = ep->phys[0];\n\t\t\tep->mii.advertising = mdio_read(dev, phy, MII_ADVERTISE);\n\t\t\tdev_info(&pdev->dev,\n\t\t\t\t\"Autonegotiation advertising %4.4x link \"\n\t\t\t\t   \"partner %4.4x.\\n\",\n\t\t\t\t   ep->mii.advertising, mdio_read(dev, phy, 5));\n\t\t} else if ( ! (ep->chip_flags & NO_MII)) {\n\t\t\tdev_warn(&pdev->dev,\n\t\t\t\t\"***WARNING***: No MII transceiver found!\\n\");\n\t\t\t \n\t\t\tep->phys[0] = 3;\n\t\t}\n\t\tep->mii.phy_id = ep->phys[0];\n\t}\n\n\t \n\tif (ep->chip_flags & MII_PWRDWN)\n\t\tew32(NVCTL, er32(NVCTL) & ~0x483c);\n\tew32(GENCTL, 0x0008);\n\n\t \n\tif (duplex) {\n\t\tep->mii.force_media = ep->mii.full_duplex = 1;\n\t\tdev_info(&pdev->dev, \"Forced full duplex requested.\\n\");\n\t}\n\tdev->if_port = ep->default_port = option;\n\n\t \n\tdev->netdev_ops = &epic_netdev_ops;\n\tdev->ethtool_ops = &netdev_ethtool_ops;\n\tdev->watchdog_timeo = TX_TIMEOUT;\n\tnetif_napi_add(dev, &ep->napi, epic_poll);\n\n\tret = register_netdev(dev);\n\tif (ret < 0)\n\t\tgoto err_out_unmap_rx;\n\n\tnetdev_info(dev, \"%s at %lx, IRQ %d, %pM\\n\",\n\t\t    pci_id_tbl[chip_idx].name,\n\t\t    (long)pci_resource_start(pdev, EPIC_BAR), pdev->irq,\n\t\t    dev->dev_addr);\n\nout:\n\treturn ret;\n\nerr_out_unmap_rx:\n\tdma_free_coherent(&pdev->dev, RX_TOTAL_SIZE, ep->rx_ring,\n\t\t\t  ep->rx_ring_dma);\nerr_out_unmap_tx:\n\tdma_free_coherent(&pdev->dev, TX_TOTAL_SIZE, ep->tx_ring,\n\t\t\t  ep->tx_ring_dma);\nerr_out_iounmap:\n\tpci_iounmap(pdev, ioaddr);\nerr_out_free_netdev:\n\tfree_netdev(dev);\nerr_out_free_res:\n\tpci_release_regions(pdev);\nerr_out_disable:\n\tpci_disable_device(pdev);\n\tgoto out;\n}\n\n \n\n \n#define EE_SHIFT_CLK\t0x04\t \n#define EE_CS\t\t\t0x02\t \n#define EE_DATA_WRITE\t0x08\t \n#define EE_WRITE_0\t\t0x01\n#define EE_WRITE_1\t\t0x09\n#define EE_DATA_READ\t0x10\t \n#define EE_ENB\t\t\t(0x0001 | EE_CS)\n\n \n\n#define eeprom_delay()\ter32(EECTL)\n\n \n#define EE_WRITE_CMD\t(5 << 6)\n#define EE_READ64_CMD\t(6 << 6)\n#define EE_READ256_CMD\t(6 << 8)\n#define EE_ERASE_CMD\t(7 << 6)\n\nstatic void epic_disable_int(struct net_device *dev, struct epic_private *ep)\n{\n\tvoid __iomem *ioaddr = ep->ioaddr;\n\n\tew32(INTMASK, 0x00000000);\n}\n\nstatic inline void __epic_pci_commit(void __iomem *ioaddr)\n{\n#ifndef USE_IO_OPS\n\ter32(INTMASK);\n#endif\n}\n\nstatic inline void epic_napi_irq_off(struct net_device *dev,\n\t\t\t\t     struct epic_private *ep)\n{\n\tvoid __iomem *ioaddr = ep->ioaddr;\n\n\tew32(INTMASK, ep->irq_mask & ~EpicNapiEvent);\n\t__epic_pci_commit(ioaddr);\n}\n\nstatic inline void epic_napi_irq_on(struct net_device *dev,\n\t\t\t\t    struct epic_private *ep)\n{\n\tvoid __iomem *ioaddr = ep->ioaddr;\n\n\t \n\tew32(INTMASK, ep->irq_mask | EpicNapiEvent);\n}\n\nstatic int read_eeprom(struct epic_private *ep, int location)\n{\n\tvoid __iomem *ioaddr = ep->ioaddr;\n\tint i;\n\tint retval = 0;\n\tint read_cmd = location |\n\t\t(er32(EECTL) & 0x40 ? EE_READ64_CMD : EE_READ256_CMD);\n\n\tew32(EECTL, EE_ENB & ~EE_CS);\n\tew32(EECTL, EE_ENB);\n\n\t \n\tfor (i = 12; i >= 0; i--) {\n\t\tshort dataval = (read_cmd & (1 << i)) ? EE_WRITE_1 : EE_WRITE_0;\n\t\tew32(EECTL, EE_ENB | dataval);\n\t\teeprom_delay();\n\t\tew32(EECTL, EE_ENB | dataval | EE_SHIFT_CLK);\n\t\teeprom_delay();\n\t}\n\tew32(EECTL, EE_ENB);\n\n\tfor (i = 16; i > 0; i--) {\n\t\tew32(EECTL, EE_ENB | EE_SHIFT_CLK);\n\t\teeprom_delay();\n\t\tretval = (retval << 1) | ((er32(EECTL) & EE_DATA_READ) ? 1 : 0);\n\t\tew32(EECTL, EE_ENB);\n\t\teeprom_delay();\n\t}\n\n\t \n\tew32(EECTL, EE_ENB & ~EE_CS);\n\treturn retval;\n}\n\n#define MII_READOP\t\t1\n#define MII_WRITEOP\t\t2\nstatic int mdio_read(struct net_device *dev, int phy_id, int location)\n{\n\tstruct epic_private *ep = netdev_priv(dev);\n\tvoid __iomem *ioaddr = ep->ioaddr;\n\tint read_cmd = (phy_id << 9) | (location << 4) | MII_READOP;\n\tint i;\n\n\tew32(MIICtrl, read_cmd);\n\t \n\tfor (i = 400; i > 0; i--) {\n\t\tbarrier();\n\t\tif ((er32(MIICtrl) & MII_READOP) == 0) {\n\t\t\t \n\t\t\tif (phy_id == 1 && location < 6 &&\n\t\t\t    er16(MIIData) == 0xffff) {\n\t\t\t\tew32(MIICtrl, read_cmd);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\treturn er16(MIIData);\n\t\t}\n\t}\n\treturn 0xffff;\n}\n\nstatic void mdio_write(struct net_device *dev, int phy_id, int loc, int value)\n{\n\tstruct epic_private *ep = netdev_priv(dev);\n\tvoid __iomem *ioaddr = ep->ioaddr;\n\tint i;\n\n\tew16(MIIData, value);\n\tew32(MIICtrl, (phy_id << 9) | (loc << 4) | MII_WRITEOP);\n\tfor (i = 10000; i > 0; i--) {\n\t\tbarrier();\n\t\tif ((er32(MIICtrl) & MII_WRITEOP) == 0)\n\t\t\tbreak;\n\t}\n}\n\n\nstatic int epic_open(struct net_device *dev)\n{\n\tstruct epic_private *ep = netdev_priv(dev);\n\tvoid __iomem *ioaddr = ep->ioaddr;\n\tconst int irq = ep->pci_dev->irq;\n\tint rc, i;\n\n\t \n\tew32(GENCTL, 0x4001);\n\n\tnapi_enable(&ep->napi);\n\trc = request_irq(irq, epic_interrupt, IRQF_SHARED, dev->name, dev);\n\tif (rc) {\n\t\tnapi_disable(&ep->napi);\n\t\treturn rc;\n\t}\n\n\tepic_init_ring(dev);\n\n\tew32(GENCTL, 0x4000);\n\t \n\tfor (i = 16; i > 0; i--)\n\t\tew32(TEST1, 0x0008);\n\n\t \n#if 0\n\tew32(MIICfg, dev->if_port == 1 ? 0x13 : 0x12);\n#endif\n\tif (ep->chip_flags & MII_PWRDWN)\n\t\tew32(NVCTL, (er32(NVCTL) & ~0x003c) | 0x4800);\n\n\t \n#ifdef __BIG_ENDIAN\n\tew32(GENCTL, 0x4432 | (RX_FIFO_THRESH << 8));\n\ter32(GENCTL);\n\tew32(GENCTL, 0x0432 | (RX_FIFO_THRESH << 8));\n#else\n\tew32(GENCTL, 0x4412 | (RX_FIFO_THRESH << 8));\n\ter32(GENCTL);\n\tew32(GENCTL, 0x0412 | (RX_FIFO_THRESH << 8));\n#endif\n\n\tudelay(20);  \n\n\tfor (i = 0; i < 3; i++)\n\t\tew32(LAN0 + i*4, le16_to_cpu(((__le16*)dev->dev_addr)[i]));\n\n\tep->tx_threshold = TX_FIFO_THRESH;\n\tew32(TxThresh, ep->tx_threshold);\n\n\tif (media2miictl[dev->if_port & 15]) {\n\t\tif (ep->mii_phy_cnt)\n\t\t\tmdio_write(dev, ep->phys[0], MII_BMCR, media2miictl[dev->if_port&15]);\n\t\tif (dev->if_port == 1) {\n\t\t\tif (debug > 1)\n\t\t\t\tnetdev_info(dev, \"Using the 10base2 transceiver, MII status %4.4x.\\n\",\n\t\t\t\t\t    mdio_read(dev, ep->phys[0], MII_BMSR));\n\t\t}\n\t} else {\n\t\tint mii_lpa = mdio_read(dev, ep->phys[0], MII_LPA);\n\t\tif (mii_lpa != 0xffff) {\n\t\t\tif ((mii_lpa & LPA_100FULL) || (mii_lpa & 0x01C0) == LPA_10FULL)\n\t\t\t\tep->mii.full_duplex = 1;\n\t\t\telse if (! (mii_lpa & LPA_LPACK))\n\t\t\t\tmdio_write(dev, ep->phys[0], MII_BMCR, BMCR_ANENABLE|BMCR_ANRESTART);\n\t\t\tif (debug > 1)\n\t\t\t\tnetdev_info(dev, \"Setting %s-duplex based on MII xcvr %d register read of %4.4x.\\n\",\n\t\t\t\t\t    ep->mii.full_duplex ? \"full\"\n\t\t\t\t\t\t\t\t: \"half\",\n\t\t\t\t\t    ep->phys[0], mii_lpa);\n\t\t}\n\t}\n\n\tew32(TxCtrl, ep->mii.full_duplex ? 0x7f : 0x79);\n\tew32(PRxCDAR, ep->rx_ring_dma);\n\tew32(PTxCDAR, ep->tx_ring_dma);\n\n\t \n\tset_rx_mode(dev);\n\tew32(COMMAND, StartRx | RxQueued);\n\n\tnetif_start_queue(dev);\n\n\t \n\tew32(INTMASK, RxError | RxHeader | EpicNapiEvent | CntFull |\n\t     ((ep->chip_flags & TYPE2_INTR) ? PCIBusErr175 : PCIBusErr170) |\n\t     TxUnderrun);\n\n\tif (debug > 1) {\n\t\tnetdev_dbg(dev, \"epic_open() ioaddr %p IRQ %d status %4.4x %s-duplex.\\n\",\n\t\t\t   ioaddr, irq, er32(GENCTL),\n\t\t\t   ep->mii.full_duplex ? \"full\" : \"half\");\n\t}\n\n\t \n\ttimer_setup(&ep->timer, epic_timer, 0);\n\tep->timer.expires = jiffies + 3*HZ;\n\tadd_timer(&ep->timer);\n\n\treturn rc;\n}\n\n \nstatic void epic_pause(struct net_device *dev)\n{\n\tstruct net_device_stats *stats = &dev->stats;\n\tstruct epic_private *ep = netdev_priv(dev);\n\tvoid __iomem *ioaddr = ep->ioaddr;\n\n\tnetif_stop_queue (dev);\n\n\t \n\tew32(INTMASK, 0x00000000);\n\t \n\tew16(COMMAND, StopRx | StopTxDMA | StopRxDMA);\n\n\t \n\tif (er16(COMMAND) != 0xffff) {\n\t\tstats->rx_missed_errors\t+= er8(MPCNT);\n\t\tstats->rx_frame_errors\t+= er8(ALICNT);\n\t\tstats->rx_crc_errors\t+= er8(CRCCNT);\n\t}\n\n\t \n\tepic_rx(dev, RX_RING_SIZE);\n}\n\nstatic void epic_restart(struct net_device *dev)\n{\n\tstruct epic_private *ep = netdev_priv(dev);\n\tvoid __iomem *ioaddr = ep->ioaddr;\n\tint i;\n\n\t \n\tew32(GENCTL, 0x4001);\n\n\tnetdev_dbg(dev, \"Restarting the EPIC chip, Rx %d/%d Tx %d/%d.\\n\",\n\t\t   ep->cur_rx, ep->dirty_rx, ep->dirty_tx, ep->cur_tx);\n\tudelay(1);\n\n\t \n\tfor (i = 16; i > 0; i--)\n\t\tew32(TEST1, 0x0008);\n\n#ifdef __BIG_ENDIAN\n\tew32(GENCTL, 0x0432 | (RX_FIFO_THRESH << 8));\n#else\n\tew32(GENCTL, 0x0412 | (RX_FIFO_THRESH << 8));\n#endif\n\tew32(MIICfg, dev->if_port == 1 ? 0x13 : 0x12);\n\tif (ep->chip_flags & MII_PWRDWN)\n\t\tew32(NVCTL, (er32(NVCTL) & ~0x003c) | 0x4800);\n\n\tfor (i = 0; i < 3; i++)\n\t\tew32(LAN0 + i*4, le16_to_cpu(((__le16*)dev->dev_addr)[i]));\n\n\tep->tx_threshold = TX_FIFO_THRESH;\n\tew32(TxThresh, ep->tx_threshold);\n\tew32(TxCtrl, ep->mii.full_duplex ? 0x7f : 0x79);\n\tew32(PRxCDAR, ep->rx_ring_dma +\n\t     (ep->cur_rx % RX_RING_SIZE) * sizeof(struct epic_rx_desc));\n\tew32(PTxCDAR, ep->tx_ring_dma +\n\t     (ep->dirty_tx % TX_RING_SIZE) * sizeof(struct epic_tx_desc));\n\n\t \n\tset_rx_mode(dev);\n\tew32(COMMAND, StartRx | RxQueued);\n\n\t \n\tew32(INTMASK, RxError | RxHeader | EpicNapiEvent | CntFull |\n\t     ((ep->chip_flags & TYPE2_INTR) ? PCIBusErr175 : PCIBusErr170) |\n\t     TxUnderrun);\n\n\tnetdev_dbg(dev, \"epic_restart() done, cmd status %4.4x, ctl %4.4x interrupt %4.4x.\\n\",\n\t\t   er32(COMMAND), er32(GENCTL), er32(INTSTAT));\n}\n\nstatic void check_media(struct net_device *dev)\n{\n\tstruct epic_private *ep = netdev_priv(dev);\n\tvoid __iomem *ioaddr = ep->ioaddr;\n\tint mii_lpa = ep->mii_phy_cnt ? mdio_read(dev, ep->phys[0], MII_LPA) : 0;\n\tint negotiated = mii_lpa & ep->mii.advertising;\n\tint duplex = (negotiated & 0x0100) || (negotiated & 0x01C0) == 0x0040;\n\n\tif (ep->mii.force_media)\n\t\treturn;\n\tif (mii_lpa == 0xffff)\t\t \n\t\treturn;\n\tif (ep->mii.full_duplex != duplex) {\n\t\tep->mii.full_duplex = duplex;\n\t\tnetdev_info(dev, \"Setting %s-duplex based on MII #%d link partner capability of %4.4x.\\n\",\n\t\t\t    ep->mii.full_duplex ? \"full\" : \"half\",\n\t\t\t    ep->phys[0], mii_lpa);\n\t\tew32(TxCtrl, ep->mii.full_duplex ? 0x7F : 0x79);\n\t}\n}\n\nstatic void epic_timer(struct timer_list *t)\n{\n\tstruct epic_private *ep = from_timer(ep, t, timer);\n\tstruct net_device *dev = ep->mii.dev;\n\tvoid __iomem *ioaddr = ep->ioaddr;\n\tint next_tick = 5*HZ;\n\n\tif (debug > 3) {\n\t\tnetdev_dbg(dev, \"Media monitor tick, Tx status %8.8x.\\n\",\n\t\t\t   er32(TxSTAT));\n\t\tnetdev_dbg(dev, \"Other registers are IntMask %4.4x IntStatus %4.4x RxStatus %4.4x.\\n\",\n\t\t\t   er32(INTMASK), er32(INTSTAT), er32(RxSTAT));\n\t}\n\n\tcheck_media(dev);\n\n\tep->timer.expires = jiffies + next_tick;\n\tadd_timer(&ep->timer);\n}\n\nstatic void epic_tx_timeout(struct net_device *dev, unsigned int txqueue)\n{\n\tstruct epic_private *ep = netdev_priv(dev);\n\tvoid __iomem *ioaddr = ep->ioaddr;\n\n\tif (debug > 0) {\n\t\tnetdev_warn(dev, \"Transmit timeout using MII device, Tx status %4.4x.\\n\",\n\t\t\t    er16(TxSTAT));\n\t\tif (debug > 1) {\n\t\t\tnetdev_dbg(dev, \"Tx indices: dirty_tx %d, cur_tx %d.\\n\",\n\t\t\t\t   ep->dirty_tx, ep->cur_tx);\n\t\t}\n\t}\n\tif (er16(TxSTAT) & 0x10) {\t\t \n\t\tdev->stats.tx_fifo_errors++;\n\t\tew32(COMMAND, RestartTx);\n\t} else {\n\t\tepic_restart(dev);\n\t\tew32(COMMAND, TxQueued);\n\t}\n\n\tnetif_trans_update(dev);  \n\tdev->stats.tx_errors++;\n\tif (!ep->tx_full)\n\t\tnetif_wake_queue(dev);\n}\n\n \nstatic void epic_init_ring(struct net_device *dev)\n{\n\tstruct epic_private *ep = netdev_priv(dev);\n\tint i;\n\n\tep->tx_full = 0;\n\tep->dirty_tx = ep->cur_tx = 0;\n\tep->cur_rx = ep->dirty_rx = 0;\n\tep->rx_buf_sz = (dev->mtu <= 1500 ? PKT_BUF_SZ : dev->mtu + 32);\n\n\t \n\tfor (i = 0; i < RX_RING_SIZE; i++) {\n\t\tep->rx_ring[i].rxstatus = 0;\n\t\tep->rx_ring[i].buflength = ep->rx_buf_sz;\n\t\tep->rx_ring[i].next = ep->rx_ring_dma +\n\t\t\t\t      (i+1)*sizeof(struct epic_rx_desc);\n\t\tep->rx_skbuff[i] = NULL;\n\t}\n\t \n\tep->rx_ring[i-1].next = ep->rx_ring_dma;\n\n\t \n\tfor (i = 0; i < RX_RING_SIZE; i++) {\n\t\tstruct sk_buff *skb = netdev_alloc_skb(dev, ep->rx_buf_sz + 2);\n\t\tep->rx_skbuff[i] = skb;\n\t\tif (skb == NULL)\n\t\t\tbreak;\n\t\tskb_reserve(skb, 2);\t \n\t\tep->rx_ring[i].bufaddr = dma_map_single(&ep->pci_dev->dev,\n\t\t\t\t\t\t\tskb->data,\n\t\t\t\t\t\t\tep->rx_buf_sz,\n\t\t\t\t\t\t\tDMA_FROM_DEVICE);\n\t\tep->rx_ring[i].rxstatus = DescOwn;\n\t}\n\tep->dirty_rx = (unsigned int)(i - RX_RING_SIZE);\n\n\t \n\tfor (i = 0; i < TX_RING_SIZE; i++) {\n\t\tep->tx_skbuff[i] = NULL;\n\t\tep->tx_ring[i].txstatus = 0x0000;\n\t\tep->tx_ring[i].next = ep->tx_ring_dma +\n\t\t\t(i+1)*sizeof(struct epic_tx_desc);\n\t}\n\tep->tx_ring[i-1].next = ep->tx_ring_dma;\n}\n\nstatic netdev_tx_t epic_start_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct epic_private *ep = netdev_priv(dev);\n\tvoid __iomem *ioaddr = ep->ioaddr;\n\tint entry, free_count;\n\tu32 ctrl_word;\n\tunsigned long flags;\n\n\tif (skb_padto(skb, ETH_ZLEN))\n\t\treturn NETDEV_TX_OK;\n\n\t \n\n\t \n\tspin_lock_irqsave(&ep->lock, flags);\n\tfree_count = ep->cur_tx - ep->dirty_tx;\n\tentry = ep->cur_tx % TX_RING_SIZE;\n\n\tep->tx_skbuff[entry] = skb;\n\tep->tx_ring[entry].bufaddr = dma_map_single(&ep->pci_dev->dev,\n\t\t\t\t\t\t    skb->data, skb->len,\n\t\t\t\t\t\t    DMA_TO_DEVICE);\n\tif (free_count < TX_QUEUE_LEN/2) { \n\t\tctrl_word = 0x100000;  \n\t} else if (free_count == TX_QUEUE_LEN/2) {\n\t\tctrl_word = 0x140000;  \n\t} else if (free_count < TX_QUEUE_LEN - 1) {\n\t\tctrl_word = 0x100000;  \n\t} else {\n\t\t \n\t\tctrl_word = 0x140000;  \n\t\tep->tx_full = 1;\n\t}\n\tep->tx_ring[entry].buflength = ctrl_word | skb->len;\n\tep->tx_ring[entry].txstatus =\n\t\t((skb->len >= ETH_ZLEN ? skb->len : ETH_ZLEN) << 16)\n\t\t\t    | DescOwn;\n\n\tep->cur_tx++;\n\tif (ep->tx_full)\n\t\tnetif_stop_queue(dev);\n\n\tspin_unlock_irqrestore(&ep->lock, flags);\n\t \n\tew32(COMMAND, TxQueued);\n\n\tif (debug > 4)\n\t\tnetdev_dbg(dev, \"Queued Tx packet size %d to slot %d, flag %2.2x Tx status %8.8x.\\n\",\n\t\t\t   skb->len, entry, ctrl_word, er32(TxSTAT));\n\n\treturn NETDEV_TX_OK;\n}\n\nstatic void epic_tx_error(struct net_device *dev, struct epic_private *ep,\n\t\t\t  int status)\n{\n\tstruct net_device_stats *stats = &dev->stats;\n\n#ifndef final_version\n\t \n\tif (debug > 1)\n\t\tnetdev_dbg(dev, \"Transmit error, Tx status %8.8x.\\n\",\n\t\t\t   status);\n#endif\n\tstats->tx_errors++;\n\tif (status & 0x1050)\n\t\tstats->tx_aborted_errors++;\n\tif (status & 0x0008)\n\t\tstats->tx_carrier_errors++;\n\tif (status & 0x0040)\n\t\tstats->tx_window_errors++;\n\tif (status & 0x0010)\n\t\tstats->tx_fifo_errors++;\n}\n\nstatic void epic_tx(struct net_device *dev, struct epic_private *ep)\n{\n\tunsigned int dirty_tx, cur_tx;\n\n\t \n\tcur_tx = ep->cur_tx;\n\tfor (dirty_tx = ep->dirty_tx; cur_tx - dirty_tx > 0; dirty_tx++) {\n\t\tstruct sk_buff *skb;\n\t\tint entry = dirty_tx % TX_RING_SIZE;\n\t\tint txstatus = ep->tx_ring[entry].txstatus;\n\n\t\tif (txstatus & DescOwn)\n\t\t\tbreak;\t \n\n\t\tif (likely(txstatus & 0x0001)) {\n\t\t\tdev->stats.collisions += (txstatus >> 8) & 15;\n\t\t\tdev->stats.tx_packets++;\n\t\t\tdev->stats.tx_bytes += ep->tx_skbuff[entry]->len;\n\t\t} else\n\t\t\tepic_tx_error(dev, ep, txstatus);\n\n\t\t \n\t\tskb = ep->tx_skbuff[entry];\n\t\tdma_unmap_single(&ep->pci_dev->dev,\n\t\t\t\t ep->tx_ring[entry].bufaddr, skb->len,\n\t\t\t\t DMA_TO_DEVICE);\n\t\tdev_consume_skb_irq(skb);\n\t\tep->tx_skbuff[entry] = NULL;\n\t}\n\n#ifndef final_version\n\tif (cur_tx - dirty_tx > TX_RING_SIZE) {\n\t\tnetdev_warn(dev, \"Out-of-sync dirty pointer, %d vs. %d, full=%d.\\n\",\n\t\t\t    dirty_tx, cur_tx, ep->tx_full);\n\t\tdirty_tx += TX_RING_SIZE;\n\t}\n#endif\n\tep->dirty_tx = dirty_tx;\n\tif (ep->tx_full && cur_tx - dirty_tx < TX_QUEUE_LEN - 4) {\n\t\t \n\t\tep->tx_full = 0;\n\t\tnetif_wake_queue(dev);\n\t}\n}\n\n \nstatic irqreturn_t epic_interrupt(int irq, void *dev_instance)\n{\n\tstruct net_device *dev = dev_instance;\n\tstruct epic_private *ep = netdev_priv(dev);\n\tvoid __iomem *ioaddr = ep->ioaddr;\n\tunsigned int handled = 0;\n\tint status;\n\n\tstatus = er32(INTSTAT);\n\t \n\tew32(INTSTAT, status & EpicNormalEvent);\n\n\tif (debug > 4) {\n\t\tnetdev_dbg(dev, \"Interrupt, status=%#8.8x new intstat=%#8.8x.\\n\",\n\t\t\t   status, er32(INTSTAT));\n\t}\n\n\tif ((status & IntrSummary) == 0)\n\t\tgoto out;\n\n\thandled = 1;\n\n\tif (status & EpicNapiEvent) {\n\t\tspin_lock(&ep->napi_lock);\n\t\tif (napi_schedule_prep(&ep->napi)) {\n\t\t\tepic_napi_irq_off(dev, ep);\n\t\t\t__napi_schedule(&ep->napi);\n\t\t}\n\t\tspin_unlock(&ep->napi_lock);\n\t}\n\tstatus &= ~EpicNapiEvent;\n\n\t \n\tif (status & (CntFull | TxUnderrun | PCIBusErr170 | PCIBusErr175)) {\n\t\tstruct net_device_stats *stats = &dev->stats;\n\n\t\tif (status == EpicRemoved)\n\t\t\tgoto out;\n\n\t\t \n\t\tstats->rx_missed_errors\t+= er8(MPCNT);\n\t\tstats->rx_frame_errors\t+= er8(ALICNT);\n\t\tstats->rx_crc_errors\t+= er8(CRCCNT);\n\n\t\tif (status & TxUnderrun) {  \n\t\t\tstats->tx_fifo_errors++;\n\t\t\tew32(TxThresh, ep->tx_threshold += 128);\n\t\t\t \n\t\t\tew32(COMMAND, RestartTx);\n\t\t}\n\t\tif (status & PCIBusErr170) {\n\t\t\tnetdev_err(dev, \"PCI Bus Error! status %4.4x.\\n\",\n\t\t\t\t   status);\n\t\t\tepic_pause(dev);\n\t\t\tepic_restart(dev);\n\t\t}\n\t\t \n\t\tew32(INTSTAT, status & 0x7f18);\n\t}\n\nout:\n\tif (debug > 3) {\n\t\tnetdev_dbg(dev, \"exit interrupt, intr_status=%#4.4x.\\n\",\n\t\t\t   status);\n\t}\n\n\treturn IRQ_RETVAL(handled);\n}\n\nstatic int epic_rx(struct net_device *dev, int budget)\n{\n\tstruct epic_private *ep = netdev_priv(dev);\n\tint entry = ep->cur_rx % RX_RING_SIZE;\n\tint rx_work_limit = ep->dirty_rx + RX_RING_SIZE - ep->cur_rx;\n\tint work_done = 0;\n\n\tif (debug > 4)\n\t\tnetdev_dbg(dev, \" In epic_rx(), entry %d %8.8x.\\n\", entry,\n\t\t\t   ep->rx_ring[entry].rxstatus);\n\n\tif (rx_work_limit > budget)\n\t\trx_work_limit = budget;\n\n\t \n\twhile ((ep->rx_ring[entry].rxstatus & DescOwn) == 0) {\n\t\tint status = ep->rx_ring[entry].rxstatus;\n\n\t\tif (debug > 4)\n\t\t\tnetdev_dbg(dev, \"  epic_rx() status was %8.8x.\\n\",\n\t\t\t\t   status);\n\t\tif (--rx_work_limit < 0)\n\t\t\tbreak;\n\t\tif (status & 0x2006) {\n\t\t\tif (debug > 2)\n\t\t\t\tnetdev_dbg(dev, \"epic_rx() error status was %8.8x.\\n\",\n\t\t\t\t\t   status);\n\t\t\tif (status & 0x2000) {\n\t\t\t\tnetdev_warn(dev, \"Oversized Ethernet frame spanned multiple buffers, status %4.4x!\\n\",\n\t\t\t\t\t    status);\n\t\t\t\tdev->stats.rx_length_errors++;\n\t\t\t} else if (status & 0x0006)\n\t\t\t\t \n\t\t\t\tdev->stats.rx_errors++;\n\t\t} else {\n\t\t\t \n\t\t\t \n\t\t\tshort pkt_len = (status >> 16) - 4;\n\t\t\tstruct sk_buff *skb;\n\n\t\t\tif (pkt_len > PKT_BUF_SZ - 4) {\n\t\t\t\tnetdev_err(dev, \"Oversized Ethernet frame, status %x %d bytes.\\n\",\n\t\t\t\t\t   status, pkt_len);\n\t\t\t\tpkt_len = 1514;\n\t\t\t}\n\t\t\t \n\t\t\tif (pkt_len < rx_copybreak &&\n\t\t\t    (skb = netdev_alloc_skb(dev, pkt_len + 2)) != NULL) {\n\t\t\t\tskb_reserve(skb, 2);\t \n\t\t\t\tdma_sync_single_for_cpu(&ep->pci_dev->dev,\n\t\t\t\t\t\t\tep->rx_ring[entry].bufaddr,\n\t\t\t\t\t\t\tep->rx_buf_sz,\n\t\t\t\t\t\t\tDMA_FROM_DEVICE);\n\t\t\t\tskb_copy_to_linear_data(skb, ep->rx_skbuff[entry]->data, pkt_len);\n\t\t\t\tskb_put(skb, pkt_len);\n\t\t\t\tdma_sync_single_for_device(&ep->pci_dev->dev,\n\t\t\t\t\t\t\t   ep->rx_ring[entry].bufaddr,\n\t\t\t\t\t\t\t   ep->rx_buf_sz,\n\t\t\t\t\t\t\t   DMA_FROM_DEVICE);\n\t\t\t} else {\n\t\t\t\tdma_unmap_single(&ep->pci_dev->dev,\n\t\t\t\t\t\t ep->rx_ring[entry].bufaddr,\n\t\t\t\t\t\t ep->rx_buf_sz,\n\t\t\t\t\t\t DMA_FROM_DEVICE);\n\t\t\t\tskb_put(skb = ep->rx_skbuff[entry], pkt_len);\n\t\t\t\tep->rx_skbuff[entry] = NULL;\n\t\t\t}\n\t\t\tskb->protocol = eth_type_trans(skb, dev);\n\t\t\tnetif_receive_skb(skb);\n\t\t\tdev->stats.rx_packets++;\n\t\t\tdev->stats.rx_bytes += pkt_len;\n\t\t}\n\t\twork_done++;\n\t\tentry = (++ep->cur_rx) % RX_RING_SIZE;\n\t}\n\n\t \n\tfor (; ep->cur_rx - ep->dirty_rx > 0; ep->dirty_rx++) {\n\t\tentry = ep->dirty_rx % RX_RING_SIZE;\n\t\tif (ep->rx_skbuff[entry] == NULL) {\n\t\t\tstruct sk_buff *skb;\n\t\t\tskb = ep->rx_skbuff[entry] = netdev_alloc_skb(dev, ep->rx_buf_sz + 2);\n\t\t\tif (skb == NULL)\n\t\t\t\tbreak;\n\t\t\tskb_reserve(skb, 2);\t \n\t\t\tep->rx_ring[entry].bufaddr = dma_map_single(&ep->pci_dev->dev,\n\t\t\t\t\t\t\t\t    skb->data,\n\t\t\t\t\t\t\t\t    ep->rx_buf_sz,\n\t\t\t\t\t\t\t\t    DMA_FROM_DEVICE);\n\t\t\twork_done++;\n\t\t}\n\t\t \n\t\tep->rx_ring[entry].rxstatus = DescOwn;\n\t}\n\treturn work_done;\n}\n\nstatic void epic_rx_err(struct net_device *dev, struct epic_private *ep)\n{\n\tvoid __iomem *ioaddr = ep->ioaddr;\n\tint status;\n\n\tstatus = er32(INTSTAT);\n\n\tif (status == EpicRemoved)\n\t\treturn;\n\tif (status & RxOverflow) \t \n\t\tdev->stats.rx_errors++;\n\tif (status & (RxOverflow | RxFull))\n\t\tew16(COMMAND, RxQueued);\n}\n\nstatic int epic_poll(struct napi_struct *napi, int budget)\n{\n\tstruct epic_private *ep = container_of(napi, struct epic_private, napi);\n\tstruct net_device *dev = ep->mii.dev;\n\tvoid __iomem *ioaddr = ep->ioaddr;\n\tint work_done;\n\n\tepic_tx(dev, ep);\n\n\twork_done = epic_rx(dev, budget);\n\n\tepic_rx_err(dev, ep);\n\n\tif (work_done < budget && napi_complete_done(napi, work_done)) {\n\t\tunsigned long flags;\n\n\t\tspin_lock_irqsave(&ep->napi_lock, flags);\n\n\t\tew32(INTSTAT, EpicNapiEvent);\n\t\tepic_napi_irq_on(dev, ep);\n\t\tspin_unlock_irqrestore(&ep->napi_lock, flags);\n\t}\n\n\treturn work_done;\n}\n\nstatic int epic_close(struct net_device *dev)\n{\n\tstruct epic_private *ep = netdev_priv(dev);\n\tstruct pci_dev *pdev = ep->pci_dev;\n\tvoid __iomem *ioaddr = ep->ioaddr;\n\tstruct sk_buff *skb;\n\tint i;\n\n\tnetif_stop_queue(dev);\n\tnapi_disable(&ep->napi);\n\n\tif (debug > 1)\n\t\tnetdev_dbg(dev, \"Shutting down ethercard, status was %2.2x.\\n\",\n\t\t\t   er32(INTSTAT));\n\n\tdel_timer_sync(&ep->timer);\n\n\tepic_disable_int(dev, ep);\n\n\tfree_irq(pdev->irq, dev);\n\n\tepic_pause(dev);\n\n\t \n\tfor (i = 0; i < RX_RING_SIZE; i++) {\n\t\tskb = ep->rx_skbuff[i];\n\t\tep->rx_skbuff[i] = NULL;\n\t\tep->rx_ring[i].rxstatus = 0;\t\t \n\t\tep->rx_ring[i].buflength = 0;\n\t\tif (skb) {\n\t\t\tdma_unmap_single(&pdev->dev, ep->rx_ring[i].bufaddr,\n\t\t\t\t\t ep->rx_buf_sz, DMA_FROM_DEVICE);\n\t\t\tdev_kfree_skb(skb);\n\t\t}\n\t\tep->rx_ring[i].bufaddr = 0xBADF00D0;  \n\t}\n\tfor (i = 0; i < TX_RING_SIZE; i++) {\n\t\tskb = ep->tx_skbuff[i];\n\t\tep->tx_skbuff[i] = NULL;\n\t\tif (!skb)\n\t\t\tcontinue;\n\t\tdma_unmap_single(&pdev->dev, ep->tx_ring[i].bufaddr, skb->len,\n\t\t\t\t DMA_TO_DEVICE);\n\t\tdev_kfree_skb(skb);\n\t}\n\n\t \n\tew32(GENCTL, 0x0008);\n\n\treturn 0;\n}\n\nstatic struct net_device_stats *epic_get_stats(struct net_device *dev)\n{\n\tstruct epic_private *ep = netdev_priv(dev);\n\tvoid __iomem *ioaddr = ep->ioaddr;\n\n\tif (netif_running(dev)) {\n\t\tstruct net_device_stats *stats = &dev->stats;\n\n\t\tstats->rx_missed_errors\t+= er8(MPCNT);\n\t\tstats->rx_frame_errors\t+= er8(ALICNT);\n\t\tstats->rx_crc_errors\t+= er8(CRCCNT);\n\t}\n\n\treturn &dev->stats;\n}\n\n \n\nstatic void set_rx_mode(struct net_device *dev)\n{\n\tstruct epic_private *ep = netdev_priv(dev);\n\tvoid __iomem *ioaddr = ep->ioaddr;\n\tunsigned char mc_filter[8];\t\t  \n\tint i;\n\n\tif (dev->flags & IFF_PROMISC) {\t\t\t \n\t\tew32(RxCtrl, 0x002c);\n\t\t \n\t\tmemset(mc_filter, 0xff, sizeof(mc_filter));\n\t} else if ((!netdev_mc_empty(dev)) || (dev->flags & IFF_ALLMULTI)) {\n\t\t \n\t\t \n\t\tmemset(mc_filter, 0xff, sizeof(mc_filter));\n\t\tew32(RxCtrl, 0x000c);\n\t} else if (netdev_mc_empty(dev)) {\n\t\tew32(RxCtrl, 0x0004);\n\t\treturn;\n\t} else {\t\t\t\t\t \n\t\tstruct netdev_hw_addr *ha;\n\n\t\tmemset(mc_filter, 0, sizeof(mc_filter));\n\t\tnetdev_for_each_mc_addr(ha, dev) {\n\t\t\tunsigned int bit_nr =\n\t\t\t\tether_crc_le(ETH_ALEN, ha->addr) & 0x3f;\n\t\t\tmc_filter[bit_nr >> 3] |= (1 << bit_nr);\n\t\t}\n\t}\n\t \n\tif (memcmp(mc_filter, ep->mc_filter, sizeof(mc_filter))) {\n\t\tfor (i = 0; i < 4; i++)\n\t\t\tew16(MC0 + i*4, ((u16 *)mc_filter)[i]);\n\t\tmemcpy(ep->mc_filter, mc_filter, sizeof(mc_filter));\n\t}\n}\n\nstatic void netdev_get_drvinfo (struct net_device *dev, struct ethtool_drvinfo *info)\n{\n\tstruct epic_private *np = netdev_priv(dev);\n\n\tstrscpy(info->driver, DRV_NAME, sizeof(info->driver));\n\tstrscpy(info->version, DRV_VERSION, sizeof(info->version));\n\tstrscpy(info->bus_info, pci_name(np->pci_dev), sizeof(info->bus_info));\n}\n\nstatic int netdev_get_link_ksettings(struct net_device *dev,\n\t\t\t\t     struct ethtool_link_ksettings *cmd)\n{\n\tstruct epic_private *np = netdev_priv(dev);\n\n\tspin_lock_irq(&np->lock);\n\tmii_ethtool_get_link_ksettings(&np->mii, cmd);\n\tspin_unlock_irq(&np->lock);\n\n\treturn 0;\n}\n\nstatic int netdev_set_link_ksettings(struct net_device *dev,\n\t\t\t\t     const struct ethtool_link_ksettings *cmd)\n{\n\tstruct epic_private *np = netdev_priv(dev);\n\tint rc;\n\n\tspin_lock_irq(&np->lock);\n\trc = mii_ethtool_set_link_ksettings(&np->mii, cmd);\n\tspin_unlock_irq(&np->lock);\n\n\treturn rc;\n}\n\nstatic int netdev_nway_reset(struct net_device *dev)\n{\n\tstruct epic_private *np = netdev_priv(dev);\n\treturn mii_nway_restart(&np->mii);\n}\n\nstatic u32 netdev_get_link(struct net_device *dev)\n{\n\tstruct epic_private *np = netdev_priv(dev);\n\treturn mii_link_ok(&np->mii);\n}\n\nstatic u32 netdev_get_msglevel(struct net_device *dev)\n{\n\treturn debug;\n}\n\nstatic void netdev_set_msglevel(struct net_device *dev, u32 value)\n{\n\tdebug = value;\n}\n\nstatic int ethtool_begin(struct net_device *dev)\n{\n\tstruct epic_private *ep = netdev_priv(dev);\n\tvoid __iomem *ioaddr = ep->ioaddr;\n\n\tif (ep->ethtool_ops_nesting == U32_MAX)\n\t\treturn -EBUSY;\n\t \n\tif (!ep->ethtool_ops_nesting++ && !netif_running(dev)) {\n\t\tew32(GENCTL, 0x0200);\n\t\tew32(NVCTL, (er32(NVCTL) & ~0x003c) | 0x4800);\n\t}\n\treturn 0;\n}\n\nstatic void ethtool_complete(struct net_device *dev)\n{\n\tstruct epic_private *ep = netdev_priv(dev);\n\tvoid __iomem *ioaddr = ep->ioaddr;\n\n\t \n\tif (!--ep->ethtool_ops_nesting && !netif_running(dev)) {\n\t\tew32(GENCTL, 0x0008);\n\t\tew32(NVCTL, (er32(NVCTL) & ~0x483c) | 0x0000);\n\t}\n}\n\nstatic const struct ethtool_ops netdev_ethtool_ops = {\n\t.get_drvinfo\t\t= netdev_get_drvinfo,\n\t.nway_reset\t\t= netdev_nway_reset,\n\t.get_link\t\t= netdev_get_link,\n\t.get_msglevel\t\t= netdev_get_msglevel,\n\t.set_msglevel\t\t= netdev_set_msglevel,\n\t.begin\t\t\t= ethtool_begin,\n\t.complete\t\t= ethtool_complete,\n\t.get_link_ksettings\t= netdev_get_link_ksettings,\n\t.set_link_ksettings\t= netdev_set_link_ksettings,\n};\n\nstatic int netdev_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)\n{\n\tstruct epic_private *np = netdev_priv(dev);\n\tvoid __iomem *ioaddr = np->ioaddr;\n\tstruct mii_ioctl_data *data = if_mii(rq);\n\tint rc;\n\n\t \n\tif (! netif_running(dev)) {\n\t\tew32(GENCTL, 0x0200);\n\t\tew32(NVCTL, (er32(NVCTL) & ~0x003c) | 0x4800);\n\t}\n\n\t \n\tspin_lock_irq(&np->lock);\n\trc = generic_mii_ioctl(&np->mii, data, cmd, NULL);\n\tspin_unlock_irq(&np->lock);\n\n\t \n\tif (! netif_running(dev)) {\n\t\tew32(GENCTL, 0x0008);\n\t\tew32(NVCTL, (er32(NVCTL) & ~0x483c) | 0x0000);\n\t}\n\treturn rc;\n}\n\n\nstatic void epic_remove_one(struct pci_dev *pdev)\n{\n\tstruct net_device *dev = pci_get_drvdata(pdev);\n\tstruct epic_private *ep = netdev_priv(dev);\n\n\tunregister_netdev(dev);\n\tdma_free_coherent(&pdev->dev, TX_TOTAL_SIZE, ep->tx_ring,\n\t\t\t  ep->tx_ring_dma);\n\tdma_free_coherent(&pdev->dev, RX_TOTAL_SIZE, ep->rx_ring,\n\t\t\t  ep->rx_ring_dma);\n\tpci_iounmap(pdev, ep->ioaddr);\n\tfree_netdev(dev);\n\tpci_release_regions(pdev);\n\tpci_disable_device(pdev);\n\t \n}\n\nstatic int __maybe_unused epic_suspend(struct device *dev_d)\n{\n\tstruct net_device *dev = dev_get_drvdata(dev_d);\n\tstruct epic_private *ep = netdev_priv(dev);\n\tvoid __iomem *ioaddr = ep->ioaddr;\n\n\tif (!netif_running(dev))\n\t\treturn 0;\n\tepic_pause(dev);\n\t \n\tew32(GENCTL, 0x0008);\n\t \n\treturn 0;\n}\n\n\nstatic int __maybe_unused epic_resume(struct device *dev_d)\n{\n\tstruct net_device *dev = dev_get_drvdata(dev_d);\n\n\tif (!netif_running(dev))\n\t\treturn 0;\n\tepic_restart(dev);\n\t \n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(epic_pm_ops, epic_suspend, epic_resume);\n\nstatic struct pci_driver epic_driver = {\n\t.name\t\t= DRV_NAME,\n\t.id_table\t= epic_pci_tbl,\n\t.probe\t\t= epic_init_one,\n\t.remove\t\t= epic_remove_one,\n\t.driver.pm\t= &epic_pm_ops,\n};\n\n\nstatic int __init epic_init (void)\n{\n \n#ifdef MODULE\n\tpr_info(\"%s%s\\n\", version, version2);\n#endif\n\n\treturn pci_register_driver(&epic_driver);\n}\n\n\nstatic void __exit epic_cleanup (void)\n{\n\tpci_unregister_driver (&epic_driver);\n}\n\n\nmodule_init(epic_init);\nmodule_exit(epic_cleanup);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}