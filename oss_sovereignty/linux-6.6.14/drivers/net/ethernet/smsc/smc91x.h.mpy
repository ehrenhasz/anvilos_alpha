{
  "module_name": "smc91x.h",
  "hash_id": "5a8887ef9c37f02e5168d4cc031de3a3d035217a40bd3c21b8e6a73bab306071",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/smsc/smc91x.h",
  "human_readable_source": " \n \n#ifndef _SMC91X_H_\n#define _SMC91X_H_\n\n#include <linux/dmaengine.h>\n#include <linux/smc91x.h>\n\n \n#define SMC_outw_b(x, a, r)\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tunsigned int __val16 = (x);\t\t\t\t\\\n\t\tunsigned int __reg = (r);\t\t\t\t\\\n\t\tSMC_outb(__val16, a, __reg);\t\t\t\t\\\n\t\tSMC_outb(__val16 >> 8, a, __reg + (1 << SMC_IO_SHIFT));\t\\\n\t} while (0)\n\n#define SMC_inw_b(a, r)\t\t\t\t\t\t\t\\\n\t({\t\t\t\t\t\t\t\t\\\n\t\tunsigned int __val16;\t\t\t\t\t\\\n\t\tunsigned int __reg = r;\t\t\t\t\t\\\n\t\t__val16  = SMC_inb(a, __reg);\t\t\t\t\\\n\t\t__val16 |= SMC_inb(a, __reg + (1 << SMC_IO_SHIFT)) << 8; \\\n\t\t__val16;\t\t\t\t\t\t\\\n\t})\n\n \n\n#if defined(CONFIG_ARM)\n\n#include <asm/mach-types.h>\n\n \n#define SMC_CAN_USE_8BIT\t1\n#define SMC_CAN_USE_16BIT\t1\n#define SMC_CAN_USE_32BIT\t1\n#define SMC_NOWAIT\t\t1\n\n#define SMC_IO_SHIFT\t\t(lp->io_shift)\n\n#define SMC_inb(a, r)\t\treadb((a) + (r))\n#define SMC_inw(a, r)\t\t\t\t\t\t\t\\\n\t({\t\t\t\t\t\t\t\t\\\n\t\tunsigned int __smc_r = r;\t\t\t\t\\\n\t\tSMC_16BIT(lp) ? readw((a) + __smc_r) :\t\t\t\\\n\t\tSMC_8BIT(lp) ? SMC_inw_b(a, __smc_r) :\t\t\t\\\n\t\t({ BUG(); 0; });\t\t\t\t\t\\\n\t})\n\n#define SMC_inl(a, r)\t\treadl((a) + (r))\n#define SMC_outb(v, a, r)\twriteb(v, (a) + (r))\n#define SMC_outw(lp, v, a, r)\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tunsigned int __v = v, __smc_r = r;\t\t\t\\\n\t\tif (SMC_16BIT(lp))\t\t\t\t\t\\\n\t\t\t__SMC_outw(lp, __v, a, __smc_r);\t\t\\\n\t\telse if (SMC_8BIT(lp))\t\t\t\t\t\\\n\t\t\tSMC_outw_b(__v, a, __smc_r);\t\t\t\\\n\t\telse\t\t\t\t\t\t\t\\\n\t\t\tBUG();\t\t\t\t\t\t\\\n\t} while (0)\n\n#define SMC_outl(v, a, r)\twritel(v, (a) + (r))\n#define SMC_insb(a, r, p, l)\treadsb((a) + (r), p, l)\n#define SMC_outsb(a, r, p, l)\twritesb((a) + (r), p, l)\n#define SMC_insw(a, r, p, l)\treadsw((a) + (r), p, l)\n#define SMC_outsw(a, r, p, l)\twritesw((a) + (r), p, l)\n#define SMC_insl(a, r, p, l)\treadsl((a) + (r), p, l)\n#define SMC_outsl(a, r, p, l)\twritesl((a) + (r), p, l)\n#define SMC_IRQ_FLAGS\t\t(-1)\t \n\n \nstatic inline void _SMC_outw_align4(u16 val, void __iomem *ioaddr, int reg,\n\t\t\t\t    bool use_align4_workaround)\n{\n\tif (use_align4_workaround) {\n\t\tunsigned int v = val << 16;\n\t\tv |= readl(ioaddr + (reg & ~2)) & 0xffff;\n\t\twritel(v, ioaddr + (reg & ~2));\n\t} else {\n\t\twritew(val, ioaddr + reg);\n\t}\n}\n\n#define __SMC_outw(lp, v, a, r)\t\t\t\t\t\t\\\n\t_SMC_outw_align4((v), (a), (r),\t\t\t\t\t\\\n\t\t\t IS_BUILTIN(CONFIG_ARCH_PXA) && ((r) & 2) &&\t\\\n\t\t\t (lp)->cfg.pxa_u16_align4)\n\n\n#elif\tdefined(CONFIG_SH_SH4202_MICRODEV)\n\n#define SMC_CAN_USE_8BIT\t0\n#define SMC_CAN_USE_16BIT\t1\n#define SMC_CAN_USE_32BIT\t0\n\n#define SMC_inb(a, r)\t\tinb((a) + (r) - 0xa0000000)\n#define SMC_inw(a, r)\t\tinw((a) + (r) - 0xa0000000)\n#define SMC_inl(a, r)\t\tinl((a) + (r) - 0xa0000000)\n#define SMC_outb(v, a, r)\toutb(v, (a) + (r) - 0xa0000000)\n#define SMC_outw(lp, v, a, r)\toutw(v, (a) + (r) - 0xa0000000)\n#define SMC_outl(v, a, r)\toutl(v, (a) + (r) - 0xa0000000)\n#define SMC_insl(a, r, p, l)\tinsl((a) + (r) - 0xa0000000, p, l)\n#define SMC_outsl(a, r, p, l)\toutsl((a) + (r) - 0xa0000000, p, l)\n#define SMC_insw(a, r, p, l)\tinsw((a) + (r) - 0xa0000000, p, l)\n#define SMC_outsw(a, r, p, l)\toutsw((a) + (r) - 0xa0000000, p, l)\n\n#define SMC_IRQ_FLAGS\t\t(0)\n\n#elif defined(CONFIG_ATARI)\n\n#define SMC_CAN_USE_8BIT        1\n#define SMC_CAN_USE_16BIT       1\n#define SMC_CAN_USE_32BIT       1\n#define SMC_NOWAIT              1\n\n#define SMC_inb(a, r)           readb((a) + (r))\n#define SMC_inw(a, r)           readw((a) + (r))\n#define SMC_inl(a, r)           readl((a) + (r))\n#define SMC_outb(v, a, r)       writeb(v, (a) + (r))\n#define SMC_outw(lp, v, a, r)   writew(v, (a) + (r))\n#define SMC_outl(v, a, r)       writel(v, (a) + (r))\n#define SMC_insw(a, r, p, l)    readsw((a) + (r), p, l)\n#define SMC_outsw(a, r, p, l)   writesw((a) + (r), p, l)\n#define SMC_insl(a, r, p, l)    readsl((a) + (r), p, l)\n#define SMC_outsl(a, r, p, l)   writesl((a) + (r), p, l)\n\n#define RPC_LSA_DEFAULT         RPC_LED_100_10\n#define RPC_LSB_DEFAULT         RPC_LED_TX_RX\n\n#elif defined(CONFIG_COLDFIRE)\n\n#define SMC_CAN_USE_8BIT\t0\n#define SMC_CAN_USE_16BIT\t1\n#define SMC_CAN_USE_32BIT\t0\n#define SMC_NOWAIT\t\t1\n\nstatic inline void mcf_insw(void *a, unsigned char *p, int l)\n{\n\tu16 *wp = (u16 *) p;\n\twhile (l-- > 0)\n\t\t*wp++ = readw(a);\n}\n\nstatic inline void mcf_outsw(void *a, unsigned char *p, int l)\n{\n\tu16 *wp = (u16 *) p;\n\twhile (l-- > 0)\n\t\twritew(*wp++, a);\n}\n\n#define SMC_inw(a, r)\t\t_swapw(readw((a) + (r)))\n#define SMC_outw(lp, v, a, r)\twritew(_swapw(v), (a) + (r))\n#define SMC_insw(a, r, p, l)\tmcf_insw(a + r, p, l)\n#define SMC_outsw(a, r, p, l)\tmcf_outsw(a + r, p, l)\n\n#define SMC_IRQ_FLAGS\t\t0\n\n#else\n\n \n\n#define SMC_CAN_USE_8BIT\t1\n#define SMC_CAN_USE_16BIT\t1\n#define SMC_CAN_USE_32BIT\t1\n#define SMC_NOWAIT\t\t1\n\n#define SMC_IO_SHIFT\t\t(lp->io_shift)\n\n#define SMC_inb(a, r)\t\tioread8((a) + (r))\n#define SMC_inw(a, r)\t\tioread16((a) + (r))\n#define SMC_inl(a, r)\t\tioread32((a) + (r))\n#define SMC_outb(v, a, r)\tiowrite8(v, (a) + (r))\n#define SMC_outw(lp, v, a, r)\tiowrite16(v, (a) + (r))\n#define SMC_outl(v, a, r)\tiowrite32(v, (a) + (r))\n#define SMC_insw(a, r, p, l)\tioread16_rep((a) + (r), p, l)\n#define SMC_outsw(a, r, p, l)\tiowrite16_rep((a) + (r), p, l)\n#define SMC_insl(a, r, p, l)\tioread32_rep((a) + (r), p, l)\n#define SMC_outsl(a, r, p, l)\tiowrite32_rep((a) + (r), p, l)\n\n#define RPC_LSA_DEFAULT\t\tRPC_LED_100_10\n#define RPC_LSB_DEFAULT\t\tRPC_LED_TX_RX\n\n#endif\n\n\n \nstruct smc_local {\n\t \n\tstruct sk_buff *pending_tx_skb;\n\tstruct tasklet_struct tx_task;\n\n\tstruct gpio_desc *power_gpio;\n\tstruct gpio_desc *reset_gpio;\n\n\t \n\tint\tversion;\n\n\t \n\tint\ttcr_cur_mode;\n\n\t \n\tint\trcr_cur_mode;\n\n\t \n\tint\trpc_cur_mode;\n\tint\tctl_rfduplx;\n\tint\tctl_rspeed;\n\n\tu32\tmsg_enable;\n\tu32\tphy_type;\n\tstruct mii_if_info mii;\n\n\t \n\tstruct work_struct phy_configure;\n\tstruct net_device *dev;\n\tint\twork_pending;\n\n\tspinlock_t lock;\n\n#ifdef CONFIG_ARCH_PXA\n\t \n\tu_long physaddr;\n\tstruct device *device;\n#endif\n\tstruct dma_chan *dma_chan;\n\tvoid __iomem *base;\n\tvoid __iomem *datacs;\n\n\t \n\tint\tio_shift;\n\t \n\tbool\thalf_word_align4;\n\n\tstruct smc91x_platdata cfg;\n};\n\n#define SMC_8BIT(p)\t((p)->cfg.flags & SMC91X_USE_8BIT)\n#define SMC_16BIT(p)\t((p)->cfg.flags & SMC91X_USE_16BIT)\n#define SMC_32BIT(p)\t((p)->cfg.flags & SMC91X_USE_32BIT)\n\n#ifdef CONFIG_ARCH_PXA\n \n#include <linux/dma-mapping.h>\n\n#ifdef SMC_insl\n#undef SMC_insl\n#define SMC_insl(a, r, p, l) \\\n\tsmc_pxa_dma_insl(a, lp, r, dev->dma, p, l)\nstatic inline void\nsmc_pxa_dma_inpump(struct smc_local *lp, u_char *buf, int len)\n{\n\tdma_addr_t dmabuf;\n\tstruct dma_async_tx_descriptor *tx;\n\tdma_cookie_t cookie;\n\tenum dma_status status;\n\tstruct dma_tx_state state;\n\n\tdmabuf = dma_map_single(lp->device, buf, len, DMA_FROM_DEVICE);\n\ttx = dmaengine_prep_slave_single(lp->dma_chan, dmabuf, len,\n\t\t\t\t\t DMA_DEV_TO_MEM, 0);\n\tif (tx) {\n\t\tcookie = dmaengine_submit(tx);\n\t\tdma_async_issue_pending(lp->dma_chan);\n\t\tdo {\n\t\t\tstatus = dmaengine_tx_status(lp->dma_chan, cookie,\n\t\t\t\t\t\t     &state);\n\t\t\tcpu_relax();\n\t\t} while (status != DMA_COMPLETE && status != DMA_ERROR &&\n\t\t\t state.residue);\n\t\tdmaengine_terminate_all(lp->dma_chan);\n\t}\n\tdma_unmap_single(lp->device, dmabuf, len, DMA_FROM_DEVICE);\n}\n\nstatic inline void\nsmc_pxa_dma_insl(void __iomem *ioaddr, struct smc_local *lp, int reg, int dma,\n\t\t u_char *buf, int len)\n{\n\tstruct dma_slave_config\tconfig;\n\tint ret;\n\n\t \n\tif (!lp->dma_chan) {\n\t\treadsl(ioaddr + reg, buf, len);\n\t\treturn;\n\t}\n\n\t \n\tif ((long)buf & 4) {\n\t\t*((u32 *)buf) = SMC_inl(ioaddr, reg);\n\t\tbuf += 4;\n\t\tlen--;\n\t}\n\n\tmemset(&config, 0, sizeof(config));\n\tconfig.src_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\n\tconfig.dst_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\n\tconfig.src_addr = lp->physaddr + reg;\n\tconfig.dst_addr = lp->physaddr + reg;\n\tconfig.src_maxburst = 32;\n\tconfig.dst_maxburst = 32;\n\tret = dmaengine_slave_config(lp->dma_chan, &config);\n\tif (ret) {\n\t\tdev_err(lp->device, \"dma channel configuration failed: %d\\n\",\n\t\t\tret);\n\t\treturn;\n\t}\n\n\tlen *= 4;\n\tsmc_pxa_dma_inpump(lp, buf, len);\n}\n#endif\n\n#ifdef SMC_insw\n#undef SMC_insw\n#define SMC_insw(a, r, p, l) \\\n\tsmc_pxa_dma_insw(a, lp, r, dev->dma, p, l)\nstatic inline void\nsmc_pxa_dma_insw(void __iomem *ioaddr, struct smc_local *lp, int reg, int dma,\n\t\t u_char *buf, int len)\n{\n\tstruct dma_slave_config\tconfig;\n\tint ret;\n\n\t \n\tif (!lp->dma_chan) {\n\t\treadsw(ioaddr + reg, buf, len);\n\t\treturn;\n\t}\n\n\t \n\twhile ((long)buf & 6) {\n\t\t*((u16 *)buf) = SMC_inw(ioaddr, reg);\n\t\tbuf += 2;\n\t\tlen--;\n\t}\n\n\tmemset(&config, 0, sizeof(config));\n\tconfig.src_addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;\n\tconfig.dst_addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;\n\tconfig.src_addr = lp->physaddr + reg;\n\tconfig.dst_addr = lp->physaddr + reg;\n\tconfig.src_maxburst = 32;\n\tconfig.dst_maxburst = 32;\n\tret = dmaengine_slave_config(lp->dma_chan, &config);\n\tif (ret) {\n\t\tdev_err(lp->device, \"dma channel configuration failed: %d\\n\",\n\t\t\tret);\n\t\treturn;\n\t}\n\n\tlen *= 2;\n\tsmc_pxa_dma_inpump(lp, buf, len);\n}\n#endif\n\n#endif   \n\n\n \n\n#if ! SMC_CAN_USE_32BIT\n#define SMC_inl(ioaddr, reg)\t\t({ BUG(); 0; })\n#define SMC_outl(x, ioaddr, reg)\tBUG()\n#define SMC_insl(a, r, p, l)\t\tBUG()\n#define SMC_outsl(a, r, p, l)\t\tBUG()\n#endif\n\n#if !defined(SMC_insl) || !defined(SMC_outsl)\n#define SMC_insl(a, r, p, l)\t\tBUG()\n#define SMC_outsl(a, r, p, l)\t\tBUG()\n#endif\n\n#if ! SMC_CAN_USE_16BIT\n\n#define SMC_outw(lp, x, ioaddr, reg)\tSMC_outw_b(x, ioaddr, reg)\n#define SMC_inw(ioaddr, reg)\t\tSMC_inw_b(ioaddr, reg)\n#define SMC_insw(a, r, p, l)\t\tBUG()\n#define SMC_outsw(a, r, p, l)\t\tBUG()\n\n#endif\n\n#if !defined(SMC_insw) || !defined(SMC_outsw)\n#define SMC_insw(a, r, p, l)\t\tBUG()\n#define SMC_outsw(a, r, p, l)\t\tBUG()\n#endif\n\n#if ! SMC_CAN_USE_8BIT\n#undef SMC_inb\n#define SMC_inb(ioaddr, reg)\t\t({ BUG(); 0; })\n#undef SMC_outb\n#define SMC_outb(x, ioaddr, reg)\tBUG()\n#define SMC_insb(a, r, p, l)\t\tBUG()\n#define SMC_outsb(a, r, p, l)\t\tBUG()\n#endif\n\n#if !defined(SMC_insb) || !defined(SMC_outsb)\n#define SMC_insb(a, r, p, l)\t\tBUG()\n#define SMC_outsb(a, r, p, l)\t\tBUG()\n#endif\n\n#ifndef SMC_CAN_USE_DATACS\n#define SMC_CAN_USE_DATACS\t0\n#endif\n\n#ifndef SMC_IO_SHIFT\n#define SMC_IO_SHIFT\t0\n#endif\n\n#ifndef\tSMC_IRQ_FLAGS\n#define\tSMC_IRQ_FLAGS\t\tIRQF_TRIGGER_RISING\n#endif\n\n#ifndef SMC_INTERRUPT_PREAMBLE\n#define SMC_INTERRUPT_PREAMBLE\n#endif\n\n\n \n#define SMC_IO_EXTENT\t(16 << SMC_IO_SHIFT)\n#define SMC_DATA_EXTENT (4)\n\n \n#define BANK_SELECT\t\t(14 << SMC_IO_SHIFT)\n\n\n \n \n#define TCR_REG(lp) \tSMC_REG(lp, 0x0000, 0)\n#define TCR_ENABLE\t0x0001\t \n#define TCR_LOOP\t0x0002\t \n#define TCR_FORCOL\t0x0004\t \n#define TCR_PAD_EN\t0x0080\t \n#define TCR_NOCRC\t0x0100\t \n#define TCR_MON_CSN\t0x0400\t \n#define TCR_FDUPLX    \t0x0800   \n#define TCR_STP_SQET\t0x1000\t \n#define TCR_EPH_LOOP\t0x2000\t \n#define TCR_SWFDUP\t0x8000\t \n\n#define TCR_CLEAR\t0\t \n \n#define TCR_DEFAULT\t(TCR_ENABLE | TCR_PAD_EN)\n\n\n \n \n#define EPH_STATUS_REG(lp)\tSMC_REG(lp, 0x0002, 0)\n#define ES_TX_SUC\t0x0001\t \n#define ES_SNGL_COL\t0x0002\t \n#define ES_MUL_COL\t0x0004\t \n#define ES_LTX_MULT\t0x0008\t \n#define ES_16COL\t0x0010\t \n#define ES_SQET\t\t0x0020\t \n#define ES_LTXBRD\t0x0040\t \n#define ES_TXDEFR\t0x0080\t \n#define ES_LATCOL\t0x0200\t \n#define ES_LOSTCARR\t0x0400\t \n#define ES_EXC_DEF\t0x0800\t \n#define ES_CTR_ROL\t0x1000\t \n#define ES_LINK_OK\t0x4000\t \n#define ES_TXUNRN\t0x8000\t \n\n\n \n \n#define RCR_REG(lp)\t\tSMC_REG(lp, 0x0004, 0)\n#define RCR_RX_ABORT\t0x0001\t \n#define RCR_PRMS\t0x0002\t \n#define RCR_ALMUL\t0x0004\t \n#define RCR_RXEN\t0x0100\t \n#define RCR_STRIP_CRC\t0x0200\t \n#define RCR_ABORT_ENB\t0x0200\t \n#define RCR_FILT_CAR\t0x0400\t \n#define RCR_SOFTRST\t0x8000 \t \n\n \n#define RCR_DEFAULT\t(RCR_STRIP_CRC | RCR_RXEN)\n#define RCR_CLEAR\t0x0\t \n\n\n \n \n#define COUNTER_REG(lp)\tSMC_REG(lp, 0x0006, 0)\n\n\n \n \n#define MIR_REG(lp)\t\tSMC_REG(lp, 0x0008, 0)\n\n\n \n \n#define RPC_REG(lp)\t\tSMC_REG(lp, 0x000A, 0)\n#define RPC_SPEED\t0x2000\t \n#define RPC_DPLX\t0x1000\t \n#define RPC_ANEG\t0x0800\t \n#define RPC_LSXA_SHFT\t5\t \n#define RPC_LSXB_SHFT\t2\t \n\n#ifndef RPC_LSA_DEFAULT\n#define RPC_LSA_DEFAULT\tRPC_LED_100\n#endif\n#ifndef RPC_LSB_DEFAULT\n#define RPC_LSB_DEFAULT RPC_LED_FD\n#endif\n\n#define RPC_DEFAULT (RPC_ANEG | RPC_SPEED | RPC_DPLX)\n\n\n \n\n \n \n#define BSR_REG\t\t0x000E\n\n\n \n \n#define CONFIG_REG(lp)\tSMC_REG(lp, 0x0000,\t1)\n#define CONFIG_EXT_PHY\t0x0200\t \n#define CONFIG_GPCNTRL\t0x0400\t \n#define CONFIG_NO_WAIT\t0x1000\t \n#define CONFIG_EPH_POWER_EN 0x8000  \n\n \n#define CONFIG_DEFAULT\t(CONFIG_EPH_POWER_EN)\n\n\n \n \n#define BASE_REG(lp)\tSMC_REG(lp, 0x0002, 1)\n\n\n \n \n#define ADDR0_REG(lp)\tSMC_REG(lp, 0x0004, 1)\n#define ADDR1_REG(lp)\tSMC_REG(lp, 0x0006, 1)\n#define ADDR2_REG(lp)\tSMC_REG(lp, 0x0008, 1)\n\n\n \n \n#define GP_REG(lp)\t\tSMC_REG(lp, 0x000A, 1)\n\n\n \n \n#define CTL_REG(lp)\t\tSMC_REG(lp, 0x000C, 1)\n#define CTL_RCV_BAD\t0x4000  \n#define CTL_AUTO_RELEASE 0x0800  \n#define CTL_LE_ENABLE\t0x0080  \n#define CTL_CR_ENABLE\t0x0040  \n#define CTL_TE_ENABLE\t0x0020  \n#define CTL_EEPROM_SELECT 0x0004  \n#define CTL_RELOAD\t0x0002  \n#define CTL_STORE\t0x0001  \n\n\n \n \n#define MMU_CMD_REG(lp)\tSMC_REG(lp, 0x0000, 2)\n#define MC_BUSY\t\t1\t \n#define MC_NOP\t\t(0<<5)\t \n#define MC_ALLOC\t(1<<5) \t \n#define MC_RESET\t(2<<5)\t \n#define MC_REMOVE\t(3<<5) \t \n#define MC_RELEASE  \t(4<<5) \t \n#define MC_FREEPKT  \t(5<<5) \t \n#define MC_ENQUEUE\t(6<<5)\t \n#define MC_RSTTXFIFO\t(7<<5)\t \n\n\n \n \n#define PN_REG(lp)\t\tSMC_REG(lp, 0x0002, 2)\n\n\n \n \n#define AR_REG(lp)\t\tSMC_REG(lp, 0x0003, 2)\n#define AR_FAILED\t0x80\t \n\n\n \n \n#define TXFIFO_REG(lp)\tSMC_REG(lp, 0x0004, 2)\n#define TXFIFO_TEMPTY\t0x80\t \n\n \n \n#define RXFIFO_REG(lp)\tSMC_REG(lp, 0x0005, 2)\n#define RXFIFO_REMPTY\t0x80\t \n\n#define FIFO_REG(lp)\tSMC_REG(lp, 0x0004, 2)\n\n \n \n#define PTR_REG(lp)\t\tSMC_REG(lp, 0x0006, 2)\n#define PTR_RCV\t\t0x8000  \n#define PTR_AUTOINC \t0x4000  \n#define PTR_READ\t0x2000  \n\n\n \n \n#define DATA_REG(lp)\tSMC_REG(lp, 0x0008, 2)\n\n\n \n \n#define INT_REG(lp)\t\tSMC_REG(lp, 0x000C, 2)\n\n\n \n \n#define IM_REG(lp)\t\tSMC_REG(lp, 0x000D, 2)\n#define IM_MDINT\t0x80  \n#define IM_ERCV_INT\t0x40  \n#define IM_EPH_INT\t0x20  \n#define IM_RX_OVRN_INT\t0x10  \n#define IM_ALLOC_INT\t0x08  \n#define IM_TX_EMPTY_INT\t0x04  \n#define IM_TX_INT\t0x02  \n#define IM_RCV_INT\t0x01  \n\n\n \n \n#define MCAST_REG1(lp)\tSMC_REG(lp, 0x0000, 3)\n#define MCAST_REG2(lp)\tSMC_REG(lp, 0x0002, 3)\n#define MCAST_REG3(lp)\tSMC_REG(lp, 0x0004, 3)\n#define MCAST_REG4(lp)\tSMC_REG(lp, 0x0006, 3)\n\n\n \n \n#define MII_REG(lp)\t\tSMC_REG(lp, 0x0008, 3)\n#define MII_MSK_CRS100\t0x4000  \n#define MII_MDOE\t0x0008  \n#define MII_MCLK\t0x0004  \n#define MII_MDI\t\t0x0002  \n#define MII_MDO\t\t0x0001  \n\n\n \n \n \n#define REV_REG(lp)\t\tSMC_REG(lp, 0x000A, 3)\n\n\n \n \n \n#define ERCV_REG(lp)\tSMC_REG(lp, 0x000C, 3)\n#define ERCV_RCV_DISCRD\t0x0080  \n#define ERCV_THRESHOLD\t0x001F  \n\n\n \n \n#define EXT_REG(lp)\t\tSMC_REG(lp, 0x0000, 7)\n\n\n#define CHIP_9192\t3\n#define CHIP_9194\t4\n#define CHIP_9195\t5\n#define CHIP_9196\t6\n#define CHIP_91100\t7\n#define CHIP_91100FD\t8\n#define CHIP_91111FD\t9\n\nstatic const char * chip_ids[ 16 ] =  {\n\tNULL, NULL, NULL,\n\t  \"SMC91C90/91C92\",\n\t  \"SMC91C94\",\n\t  \"SMC91C95\",\n\t  \"SMC91C96\",\n\t  \"SMC91C100\",\n\t  \"SMC91C100FD\",\n\t  \"SMC91C11xFD\",\n\tNULL, NULL, NULL,\n\tNULL, NULL, NULL};\n\n\n \n#define RS_ALGNERR\t0x8000\n#define RS_BRODCAST\t0x4000\n#define RS_BADCRC\t0x2000\n#define RS_ODDFRAME\t0x1000\n#define RS_TOOLONG\t0x0800\n#define RS_TOOSHORT\t0x0400\n#define RS_MULTICAST\t0x0001\n#define RS_ERRORS\t(RS_ALGNERR | RS_BADCRC | RS_TOOLONG | RS_TOOSHORT)\n\n\n \n#define PHY_LAN83C183\t0x0016f840\n#define PHY_LAN83C180\t0x02821c50\n\n \n\n \n#define PHY_CFG1_REG\t\t0x10\n#define PHY_CFG1_LNKDIS\t\t0x8000\t \n#define PHY_CFG1_XMTDIS\t\t0x4000\t \n#define PHY_CFG1_XMTPDN\t\t0x2000\t \n#define PHY_CFG1_BYPSCR\t\t0x0400\t \n#define PHY_CFG1_UNSCDS\t\t0x0200\t \n#define PHY_CFG1_EQLZR\t\t0x0100\t \n#define PHY_CFG1_CABLE\t\t0x0080\t \n#define PHY_CFG1_RLVL0\t\t0x0040\t \n#define PHY_CFG1_TLVL_SHIFT\t2\t \n#define PHY_CFG1_TLVL_MASK\t0x003C\n#define PHY_CFG1_TRF_MASK\t0x0003\t \n\n\n \n#define PHY_CFG2_REG\t\t0x11\n#define PHY_CFG2_APOLDIS\t0x0020\t \n#define PHY_CFG2_JABDIS\t\t0x0010\t \n#define PHY_CFG2_MREG\t\t0x0008\t \n#define PHY_CFG2_INTMDIO\t0x0004\t \n\n \n#define PHY_INT_REG\t\t0x12\t \n#define PHY_INT_INT\t\t0x8000\t \n#define PHY_INT_LNKFAIL\t\t0x4000\t \n#define PHY_INT_LOSSSYNC\t0x2000\t \n#define PHY_INT_CWRD\t\t0x1000\t \n#define PHY_INT_SSD\t\t0x0800\t \n#define PHY_INT_ESD\t\t0x0400\t \n#define PHY_INT_RPOL\t\t0x0200\t \n#define PHY_INT_JAB\t\t0x0100\t \n#define PHY_INT_SPDDET\t\t0x0080\t \n#define PHY_INT_DPLXDET\t\t0x0040\t \n\n \n#define PHY_MASK_REG\t\t0x13\t \n \n\n\n \n#define ECOR\t\t\t0x8000\n#define ECOR_RESET\t\t0x80\n#define ECOR_LEVEL_IRQ\t\t0x40\n#define ECOR_WR_ATTRIB\t\t0x04\n#define ECOR_ENABLE\t\t0x01\n\n#define ECSR\t\t\t0x8002\n#define ECSR_IOIS8\t\t0x20\n#define ECSR_PWRDWN\t\t0x04\n#define ECSR_INT\t\t0x02\n\n#define ATTRIB_SIZE\t\t((64*1024) << SMC_IO_SHIFT)\n\n\n \n\n#if SMC_DEBUG > 0\n#define SMC_REG(lp, reg, bank)\t\t\t\t\t\\\n\t({\t\t\t\t\t\t\t\t\\\n\t\tint __b = SMC_CURRENT_BANK(lp);\t\t\t\\\n\t\tif (unlikely((__b & ~0xf0) != (0x3300 | bank))) {\t\\\n\t\t\tpr_err(\"%s: bank reg screwed (0x%04x)\\n\",\t\\\n\t\t\t       CARDNAME, __b);\t\t\t\t\\\n\t\t\tBUG();\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t\treg<<SMC_IO_SHIFT;\t\t\t\t\t\\\n\t})\n#else\n#define SMC_REG(lp, reg, bank)\t(reg<<SMC_IO_SHIFT)\n#endif\n\n \n#define SMC_MUST_ALIGN_WRITE(lp)\tSMC_32BIT(lp)\n\n#define SMC_GET_PN(lp)\t\t\t\t\t\t\\\n\t(SMC_8BIT(lp)\t? (SMC_inb(ioaddr, PN_REG(lp)))\t\\\n\t\t\t\t: (SMC_inw(ioaddr, PN_REG(lp)) & 0xFF))\n\n#define SMC_SET_PN(lp, x)\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tif (SMC_MUST_ALIGN_WRITE(lp))\t\t\t\t\\\n\t\t\tSMC_outl((x)<<16, ioaddr, SMC_REG(lp, 0, 2));\t\\\n\t\telse if (SMC_8BIT(lp))\t\t\t\t\\\n\t\t\tSMC_outb(x, ioaddr, PN_REG(lp));\t\t\\\n\t\telse\t\t\t\t\t\t\t\\\n\t\t\tSMC_outw(lp, x, ioaddr, PN_REG(lp));\t\t\\\n\t} while (0)\n\n#define SMC_GET_AR(lp)\t\t\t\t\t\t\\\n\t(SMC_8BIT(lp)\t? (SMC_inb(ioaddr, AR_REG(lp)))\t\\\n\t\t\t\t: (SMC_inw(ioaddr, PN_REG(lp)) >> 8))\n\n#define SMC_GET_TXFIFO(lp)\t\t\t\t\t\t\\\n\t(SMC_8BIT(lp)\t? (SMC_inb(ioaddr, TXFIFO_REG(lp)))\t\\\n\t\t\t\t: (SMC_inw(ioaddr, TXFIFO_REG(lp)) & 0xFF))\n\n#define SMC_GET_RXFIFO(lp)\t\t\t\t\t\t\\\n\t(SMC_8BIT(lp)\t? (SMC_inb(ioaddr, RXFIFO_REG(lp)))\t\\\n\t\t\t\t: (SMC_inw(ioaddr, TXFIFO_REG(lp)) >> 8))\n\n#define SMC_GET_INT(lp)\t\t\t\t\t\t\\\n\t(SMC_8BIT(lp)\t? (SMC_inb(ioaddr, INT_REG(lp)))\t\\\n\t\t\t\t: (SMC_inw(ioaddr, INT_REG(lp)) & 0xFF))\n\n#define SMC_ACK_INT(lp, x)\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tif (SMC_8BIT(lp))\t\t\t\t\t\\\n\t\t\tSMC_outb(x, ioaddr, INT_REG(lp));\t\t\\\n\t\telse {\t\t\t\t\t\t\t\\\n\t\t\tunsigned long __flags;\t\t\t\t\\\n\t\t\tint __mask;\t\t\t\t\t\\\n\t\t\tlocal_irq_save(__flags);\t\t\t\\\n\t\t\t__mask = SMC_inw(ioaddr, INT_REG(lp)) & ~0xff; \\\n\t\t\tSMC_outw(lp, __mask | (x), ioaddr, INT_REG(lp)); \\\n\t\t\tlocal_irq_restore(__flags);\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t} while (0)\n\n#define SMC_GET_INT_MASK(lp)\t\t\t\t\t\t\\\n\t(SMC_8BIT(lp)\t? (SMC_inb(ioaddr, IM_REG(lp)))\t\\\n\t\t\t\t: (SMC_inw(ioaddr, INT_REG(lp)) >> 8))\n\n#define SMC_SET_INT_MASK(lp, x)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tif (SMC_8BIT(lp))\t\t\t\t\t\\\n\t\t\tSMC_outb(x, ioaddr, IM_REG(lp));\t\t\\\n\t\telse\t\t\t\t\t\t\t\\\n\t\t\tSMC_outw(lp, (x) << 8, ioaddr, INT_REG(lp));\t\\\n\t} while (0)\n\n#define SMC_CURRENT_BANK(lp)\tSMC_inw(ioaddr, BANK_SELECT)\n\n#define SMC_SELECT_BANK(lp, x)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tif (SMC_MUST_ALIGN_WRITE(lp))\t\t\t\t\\\n\t\t\tSMC_outl((x)<<16, ioaddr, 12<<SMC_IO_SHIFT);\t\\\n\t\telse\t\t\t\t\t\t\t\\\n\t\t\tSMC_outw(lp, x, ioaddr, BANK_SELECT);\t\t\\\n\t} while (0)\n\n#define SMC_GET_BASE(lp)\t\tSMC_inw(ioaddr, BASE_REG(lp))\n\n#define SMC_SET_BASE(lp, x)\tSMC_outw(lp, x, ioaddr, BASE_REG(lp))\n\n#define SMC_GET_CONFIG(lp)\tSMC_inw(ioaddr, CONFIG_REG(lp))\n\n#define SMC_SET_CONFIG(lp, x)\tSMC_outw(lp, x, ioaddr, CONFIG_REG(lp))\n\n#define SMC_GET_COUNTER(lp)\tSMC_inw(ioaddr, COUNTER_REG(lp))\n\n#define SMC_GET_CTL(lp)\t\tSMC_inw(ioaddr, CTL_REG(lp))\n\n#define SMC_SET_CTL(lp, x)\tSMC_outw(lp, x, ioaddr, CTL_REG(lp))\n\n#define SMC_GET_MII(lp)\t\tSMC_inw(ioaddr, MII_REG(lp))\n\n#define SMC_GET_GP(lp)\t\tSMC_inw(ioaddr, GP_REG(lp))\n\n#define SMC_SET_GP(lp, x)\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tif (SMC_MUST_ALIGN_WRITE(lp))\t\t\t\t\\\n\t\t\tSMC_outl((x)<<16, ioaddr, SMC_REG(lp, 8, 1));\t\\\n\t\telse\t\t\t\t\t\t\t\\\n\t\t\tSMC_outw(lp, x, ioaddr, GP_REG(lp));\t\t\\\n\t} while (0)\n\n#define SMC_SET_MII(lp, x)\tSMC_outw(lp, x, ioaddr, MII_REG(lp))\n\n#define SMC_GET_MIR(lp)\t\tSMC_inw(ioaddr, MIR_REG(lp))\n\n#define SMC_SET_MIR(lp, x)\tSMC_outw(lp, x, ioaddr, MIR_REG(lp))\n\n#define SMC_GET_MMU_CMD(lp)\tSMC_inw(ioaddr, MMU_CMD_REG(lp))\n\n#define SMC_SET_MMU_CMD(lp, x)\tSMC_outw(lp, x, ioaddr, MMU_CMD_REG(lp))\n\n#define SMC_GET_FIFO(lp)\tSMC_inw(ioaddr, FIFO_REG(lp))\n\n#define SMC_GET_PTR(lp)\t\tSMC_inw(ioaddr, PTR_REG(lp))\n\n#define SMC_SET_PTR(lp, x)\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tif (SMC_MUST_ALIGN_WRITE(lp))\t\t\t\t\\\n\t\t\tSMC_outl((x)<<16, ioaddr, SMC_REG(lp, 4, 2));\t\\\n\t\telse\t\t\t\t\t\t\t\\\n\t\t\tSMC_outw(lp, x, ioaddr, PTR_REG(lp));\t\t\\\n\t} while (0)\n\n#define SMC_GET_EPH_STATUS(lp)\tSMC_inw(ioaddr, EPH_STATUS_REG(lp))\n\n#define SMC_GET_RCR(lp)\t\tSMC_inw(ioaddr, RCR_REG(lp))\n\n#define SMC_SET_RCR(lp, x)\t\tSMC_outw(lp, x, ioaddr, RCR_REG(lp))\n\n#define SMC_GET_REV(lp)\t\tSMC_inw(ioaddr, REV_REG(lp))\n\n#define SMC_GET_RPC(lp)\t\tSMC_inw(ioaddr, RPC_REG(lp))\n\n#define SMC_SET_RPC(lp, x)\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tif (SMC_MUST_ALIGN_WRITE(lp))\t\t\t\t\\\n\t\t\tSMC_outl((x)<<16, ioaddr, SMC_REG(lp, 8, 0));\t\\\n\t\telse\t\t\t\t\t\t\t\\\n\t\t\tSMC_outw(lp, x, ioaddr, RPC_REG(lp));\t\t\\\n\t} while (0)\n\n#define SMC_GET_TCR(lp)\t\tSMC_inw(ioaddr, TCR_REG(lp))\n\n#define SMC_SET_TCR(lp, x)\tSMC_outw(lp, x, ioaddr, TCR_REG(lp))\n\n#ifndef SMC_GET_MAC_ADDR\n#define SMC_GET_MAC_ADDR(lp, addr)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tunsigned int __v;\t\t\t\t\t\\\n\t\t__v = SMC_inw(ioaddr, ADDR0_REG(lp));\t\t\t\\\n\t\taddr[0] = __v; addr[1] = __v >> 8;\t\t\t\\\n\t\t__v = SMC_inw(ioaddr, ADDR1_REG(lp));\t\t\t\\\n\t\taddr[2] = __v; addr[3] = __v >> 8;\t\t\t\\\n\t\t__v = SMC_inw(ioaddr, ADDR2_REG(lp));\t\t\t\\\n\t\taddr[4] = __v; addr[5] = __v >> 8;\t\t\t\\\n\t} while (0)\n#endif\n\n#define SMC_SET_MAC_ADDR(lp, addr)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tSMC_outw(lp, addr[0] | (addr[1] << 8), ioaddr, ADDR0_REG(lp)); \\\n\t\tSMC_outw(lp, addr[2] | (addr[3] << 8), ioaddr, ADDR1_REG(lp)); \\\n\t\tSMC_outw(lp, addr[4] | (addr[5] << 8), ioaddr, ADDR2_REG(lp)); \\\n\t} while (0)\n\n#define SMC_SET_MCAST(lp, x)\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tconst unsigned char *mt = (x);\t\t\t\t\\\n\t\tSMC_outw(lp, mt[0] | (mt[1] << 8), ioaddr, MCAST_REG1(lp)); \\\n\t\tSMC_outw(lp, mt[2] | (mt[3] << 8), ioaddr, MCAST_REG2(lp)); \\\n\t\tSMC_outw(lp, mt[4] | (mt[5] << 8), ioaddr, MCAST_REG3(lp)); \\\n\t\tSMC_outw(lp, mt[6] | (mt[7] << 8), ioaddr, MCAST_REG4(lp)); \\\n\t} while (0)\n\n#define SMC_PUT_PKT_HDR(lp, status, length)\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tif (SMC_32BIT(lp))\t\t\t\t\t\\\n\t\t\tSMC_outl((status) | (length)<<16, ioaddr,\t\\\n\t\t\t\t DATA_REG(lp));\t\t\t\\\n\t\telse {\t\t\t\t\t\t\t\\\n\t\t\tSMC_outw(lp, status, ioaddr, DATA_REG(lp));\t\\\n\t\t\tSMC_outw(lp, length, ioaddr, DATA_REG(lp));\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t} while (0)\n\n#define SMC_GET_PKT_HDR(lp, status, length)\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tif (SMC_32BIT(lp)) {\t\t\t\t\\\n\t\t\tunsigned int __val = SMC_inl(ioaddr, DATA_REG(lp)); \\\n\t\t\t(status) = __val & 0xffff;\t\t\t\\\n\t\t\t(length) = __val >> 16;\t\t\t\t\\\n\t\t} else {\t\t\t\t\t\t\\\n\t\t\t(status) = SMC_inw(ioaddr, DATA_REG(lp));\t\\\n\t\t\t(length) = SMC_inw(ioaddr, DATA_REG(lp));\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t} while (0)\n\n#define SMC_PUSH_DATA(lp, p, l)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tif (SMC_32BIT(lp)) {\t\t\t\t\\\n\t\t\tvoid *__ptr = (p);\t\t\t\t\\\n\t\t\tint __len = (l);\t\t\t\t\\\n\t\t\tvoid __iomem *__ioaddr = ioaddr;\t\t\\\n\t\t\tif (__len >= 2 && (unsigned long)__ptr & 2) {\t\\\n\t\t\t\t__len -= 2;\t\t\t\t\\\n\t\t\t\tSMC_outsw(ioaddr, DATA_REG(lp), __ptr, 1); \\\n\t\t\t\t__ptr += 2;\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\\\n\t\t\tif (SMC_CAN_USE_DATACS && lp->datacs)\t\t\\\n\t\t\t\t__ioaddr = lp->datacs;\t\t\t\\\n\t\t\tSMC_outsl(__ioaddr, DATA_REG(lp), __ptr, __len>>2); \\\n\t\t\tif (__len & 2) {\t\t\t\t\\\n\t\t\t\t__ptr += (__len & ~3);\t\t\t\\\n\t\t\t\tSMC_outsw(ioaddr, DATA_REG(lp), __ptr, 1); \\\n\t\t\t}\t\t\t\t\t\t\\\n\t\t} else if (SMC_16BIT(lp))\t\t\t\t\\\n\t\t\tSMC_outsw(ioaddr, DATA_REG(lp), p, (l) >> 1);\t\\\n\t\telse if (SMC_8BIT(lp))\t\t\t\t\\\n\t\t\tSMC_outsb(ioaddr, DATA_REG(lp), p, l);\t\\\n\t} while (0)\n\n#define SMC_PULL_DATA(lp, p, l)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tif (SMC_32BIT(lp)) {\t\t\t\t\\\n\t\t\tvoid *__ptr = (p);\t\t\t\t\\\n\t\t\tint __len = (l);\t\t\t\t\\\n\t\t\tvoid __iomem *__ioaddr = ioaddr;\t\t\\\n\t\t\tif ((unsigned long)__ptr & 2) {\t\t\t\\\n\t\t\t\t \t\t\t\t\t\\\n\t\t\t\t__ptr -= 2;\t\t\t\t\\\n\t\t\t\t__len += 2;\t\t\t\t\\\n\t\t\t\tSMC_SET_PTR(lp,\t\t\t\\\n\t\t\t\t\t2|PTR_READ|PTR_RCV|PTR_AUTOINC); \\\n\t\t\t}\t\t\t\t\t\t\\\n\t\t\tif (SMC_CAN_USE_DATACS && lp->datacs)\t\t\\\n\t\t\t\t__ioaddr = lp->datacs;\t\t\t\\\n\t\t\t__len += 2;\t\t\t\t\t\\\n\t\t\tSMC_insl(__ioaddr, DATA_REG(lp), __ptr, __len>>2); \\\n\t\t} else if (SMC_16BIT(lp))\t\t\t\t\\\n\t\t\tSMC_insw(ioaddr, DATA_REG(lp), p, (l) >> 1);\t\\\n\t\telse if (SMC_8BIT(lp))\t\t\t\t\\\n\t\t\tSMC_insb(ioaddr, DATA_REG(lp), p, l);\t\t\\\n\t} while (0)\n\n#endif   \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}