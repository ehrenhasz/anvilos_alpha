{
  "module_name": "tsi108_eth.c",
  "hash_id": "6396ebb84876485c34d3fbd8912b0460d702016b85701ada1fa31b15b146bad6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/tundra/tsi108_eth.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/interrupt.h>\n#include <linux/net.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/ethtool.h>\n#include <linux/skbuff.h>\n#include <linux/spinlock.h>\n#include <linux/delay.h>\n#include <linux/crc32.h>\n#include <linux/mii.h>\n#include <linux/device.h>\n#include <linux/pci.h>\n#include <linux/rtnetlink.h>\n#include <linux/timer.h>\n#include <linux/platform_device.h>\n#include <linux/gfp.h>\n\n#include <asm/io.h>\n#include <asm/tsi108.h>\n\n#include \"tsi108_eth.h\"\n\n#define MII_READ_DELAY 10000\t \n\n#define TSI108_RXRING_LEN     256\n\n \n#define TSI108_RXBUF_SIZE     1536\n\n#define TSI108_TXRING_LEN     256\n\n#define TSI108_TX_INT_FREQ    64\n\n \n#define CHECK_PHY_INTERVAL (HZ/2)\n\nstruct tsi108_prv_data {\n\tvoid  __iomem *regs;\t \n\tvoid  __iomem *phyregs;\t \n\n\tstruct net_device *dev;\n\tstruct napi_struct napi;\n\n\tunsigned int phy;\t\t \n\tunsigned int irq_num;\n\tunsigned int id;\n\tunsigned int phy_type;\n\n\tstruct timer_list timer; \n\tunsigned int rxtail;\t \n\tunsigned int rxhead;\t \n\tunsigned int rxfree;\t \n\n\tunsigned int rxpending;\t \n\n\tunsigned int txtail;\t \n\tunsigned int txhead;\t \n\n\t \n\n\tunsigned int txfree;\n\n\tunsigned int phy_ok;\t\t \n\n\t \n\n\tunsigned int link_up;\n\tunsigned int speed;\n\tunsigned int duplex;\n\n\ttx_desc *txring;\n\trx_desc *rxring;\n\tstruct sk_buff *txskbs[TSI108_TXRING_LEN];\n\tstruct sk_buff *rxskbs[TSI108_RXRING_LEN];\n\n\tdma_addr_t txdma, rxdma;\n\n\t \n\n\tspinlock_t txlock, misclock;\n\n\t \n\n\tstruct net_device_stats stats;\n\tstruct net_device_stats tmpstats;\n\n\t \n\n\tunsigned long rx_fcs;\t \n\tunsigned long rx_short_fcs;\t \n\tunsigned long rx_long_fcs;\t \n\tunsigned long rx_underruns;\t \n\tunsigned long rx_overruns;\t \n\n\tunsigned long tx_coll_abort;\t \n\tunsigned long tx_pause_drop;\t \n\n\tunsigned long mc_hash[16];\n\tu32 msg_enable;\t\t\t \n\tstruct mii_if_info mii_if;\n\tunsigned int init_media;\n\n\tstruct platform_device *pdev;\n};\n\nstatic void tsi108_timed_checker(struct timer_list *t);\n\n#ifdef DEBUG\nstatic void dump_eth_one(struct net_device *dev)\n{\n\tstruct tsi108_prv_data *data = netdev_priv(dev);\n\n\tprintk(\"Dumping %s...\\n\", dev->name);\n\tprintk(\"intstat %x intmask %x phy_ok %d\"\n\t       \" link %d speed %d duplex %d\\n\",\n\t       TSI_READ(TSI108_EC_INTSTAT),\n\t       TSI_READ(TSI108_EC_INTMASK), data->phy_ok,\n\t       data->link_up, data->speed, data->duplex);\n\n\tprintk(\"TX: head %d, tail %d, free %d, stat %x, estat %x, err %x\\n\",\n\t       data->txhead, data->txtail, data->txfree,\n\t       TSI_READ(TSI108_EC_TXSTAT),\n\t       TSI_READ(TSI108_EC_TXESTAT),\n\t       TSI_READ(TSI108_EC_TXERR));\n\n\tprintk(\"RX: head %d, tail %d, free %d, stat %x,\"\n\t       \" estat %x, err %x, pending %d\\n\\n\",\n\t       data->rxhead, data->rxtail, data->rxfree,\n\t       TSI_READ(TSI108_EC_RXSTAT),\n\t       TSI_READ(TSI108_EC_RXESTAT),\n\t       TSI_READ(TSI108_EC_RXERR), data->rxpending);\n}\n#endif\n\n \n\nstatic DEFINE_SPINLOCK(phy_lock);\n\nstatic int tsi108_read_mii(struct tsi108_prv_data *data, int reg)\n{\n\tunsigned i;\n\n\tTSI_WRITE_PHY(TSI108_MAC_MII_ADDR,\n\t\t\t\t(data->phy << TSI108_MAC_MII_ADDR_PHY) |\n\t\t\t\t(reg << TSI108_MAC_MII_ADDR_REG));\n\tTSI_WRITE_PHY(TSI108_MAC_MII_CMD, 0);\n\tTSI_WRITE_PHY(TSI108_MAC_MII_CMD, TSI108_MAC_MII_CMD_READ);\n\tfor (i = 0; i < 100; i++) {\n\t\tif (!(TSI_READ_PHY(TSI108_MAC_MII_IND) &\n\t\t      (TSI108_MAC_MII_IND_NOTVALID | TSI108_MAC_MII_IND_BUSY)))\n\t\t\tbreak;\n\t\tudelay(10);\n\t}\n\n\tif (i == 100)\n\t\treturn 0xffff;\n\telse\n\t\treturn TSI_READ_PHY(TSI108_MAC_MII_DATAIN);\n}\n\nstatic void tsi108_write_mii(struct tsi108_prv_data *data,\n\t\t\t\tint reg, u16 val)\n{\n\tunsigned i = 100;\n\tTSI_WRITE_PHY(TSI108_MAC_MII_ADDR,\n\t\t\t\t(data->phy << TSI108_MAC_MII_ADDR_PHY) |\n\t\t\t\t(reg << TSI108_MAC_MII_ADDR_REG));\n\tTSI_WRITE_PHY(TSI108_MAC_MII_DATAOUT, val);\n\twhile (i--) {\n\t\tif(!(TSI_READ_PHY(TSI108_MAC_MII_IND) &\n\t\t\tTSI108_MAC_MII_IND_BUSY))\n\t\t\tbreak;\n\t\tudelay(10);\n\t}\n}\n\nstatic int tsi108_mdio_read(struct net_device *dev, int addr, int reg)\n{\n\tstruct tsi108_prv_data *data = netdev_priv(dev);\n\treturn tsi108_read_mii(data, reg);\n}\n\nstatic void tsi108_mdio_write(struct net_device *dev, int addr, int reg, int val)\n{\n\tstruct tsi108_prv_data *data = netdev_priv(dev);\n\ttsi108_write_mii(data, reg, val);\n}\n\nstatic inline void tsi108_write_tbi(struct tsi108_prv_data *data,\n\t\t\t\t\tint reg, u16 val)\n{\n\tunsigned i = 1000;\n\tTSI_WRITE(TSI108_MAC_MII_ADDR,\n\t\t\t     (0x1e << TSI108_MAC_MII_ADDR_PHY)\n\t\t\t     | (reg << TSI108_MAC_MII_ADDR_REG));\n\tTSI_WRITE(TSI108_MAC_MII_DATAOUT, val);\n\twhile(i--) {\n\t\tif(!(TSI_READ(TSI108_MAC_MII_IND) & TSI108_MAC_MII_IND_BUSY))\n\t\t\treturn;\n\t\tudelay(10);\n\t}\n\tprintk(KERN_ERR \"%s function time out\\n\", __func__);\n}\n\nstatic int mii_speed(struct mii_if_info *mii)\n{\n\tint advert, lpa, val, media;\n\tint lpa2 = 0;\n\tint speed;\n\n\tif (!mii_link_ok(mii))\n\t\treturn 0;\n\n\tval = (*mii->mdio_read) (mii->dev, mii->phy_id, MII_BMSR);\n\tif ((val & BMSR_ANEGCOMPLETE) == 0)\n\t\treturn 0;\n\n\tadvert = (*mii->mdio_read) (mii->dev, mii->phy_id, MII_ADVERTISE);\n\tlpa = (*mii->mdio_read) (mii->dev, mii->phy_id, MII_LPA);\n\tmedia = mii_nway_result(advert & lpa);\n\n\tif (mii->supports_gmii)\n\t\tlpa2 = mii->mdio_read(mii->dev, mii->phy_id, MII_STAT1000);\n\n\tspeed = lpa2 & (LPA_1000FULL | LPA_1000HALF) ? 1000 :\n\t\t\t(media & (ADVERTISE_100FULL | ADVERTISE_100HALF) ? 100 : 10);\n\treturn speed;\n}\n\nstatic void tsi108_check_phy(struct net_device *dev)\n{\n\tstruct tsi108_prv_data *data = netdev_priv(dev);\n\tu32 mac_cfg2_reg, portctrl_reg;\n\tu32 duplex;\n\tu32 speed;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&phy_lock, flags);\n\n\tif (!data->phy_ok)\n\t\tgoto out;\n\n\tduplex = mii_check_media(&data->mii_if, netif_msg_link(data), data->init_media);\n\tdata->init_media = 0;\n\n\tif (netif_carrier_ok(dev)) {\n\n\t\tspeed = mii_speed(&data->mii_if);\n\n\t\tif ((speed != data->speed) || duplex) {\n\n\t\t\tmac_cfg2_reg = TSI_READ(TSI108_MAC_CFG2);\n\t\t\tportctrl_reg = TSI_READ(TSI108_EC_PORTCTRL);\n\n\t\t\tmac_cfg2_reg &= ~TSI108_MAC_CFG2_IFACE_MASK;\n\n\t\t\tif (speed == 1000) {\n\t\t\t\tmac_cfg2_reg |= TSI108_MAC_CFG2_GIG;\n\t\t\t\tportctrl_reg &= ~TSI108_EC_PORTCTRL_NOGIG;\n\t\t\t} else {\n\t\t\t\tmac_cfg2_reg |= TSI108_MAC_CFG2_NOGIG;\n\t\t\t\tportctrl_reg |= TSI108_EC_PORTCTRL_NOGIG;\n\t\t\t}\n\n\t\t\tdata->speed = speed;\n\n\t\t\tif (data->mii_if.full_duplex) {\n\t\t\t\tmac_cfg2_reg |= TSI108_MAC_CFG2_FULLDUPLEX;\n\t\t\t\tportctrl_reg &= ~TSI108_EC_PORTCTRL_HALFDUPLEX;\n\t\t\t\tdata->duplex = 2;\n\t\t\t} else {\n\t\t\t\tmac_cfg2_reg &= ~TSI108_MAC_CFG2_FULLDUPLEX;\n\t\t\t\tportctrl_reg |= TSI108_EC_PORTCTRL_HALFDUPLEX;\n\t\t\t\tdata->duplex = 1;\n\t\t\t}\n\n\t\t\tTSI_WRITE(TSI108_MAC_CFG2, mac_cfg2_reg);\n\t\t\tTSI_WRITE(TSI108_EC_PORTCTRL, portctrl_reg);\n\t\t}\n\n\t\tif (data->link_up == 0) {\n\t\t\t \n\t\t\tudelay(5);\n\n\t\t\tspin_lock(&data->txlock);\n\t\t\tif (is_valid_ether_addr(dev->dev_addr) && data->txfree)\n\t\t\t\tnetif_wake_queue(dev);\n\n\t\t\tdata->link_up = 1;\n\t\t\tspin_unlock(&data->txlock);\n\t\t}\n\t} else {\n\t\tif (data->link_up == 1) {\n\t\t\tnetif_stop_queue(dev);\n\t\t\tdata->link_up = 0;\n\t\t\tprintk(KERN_NOTICE \"%s : link is down\\n\", dev->name);\n\t\t}\n\n\t\tgoto out;\n\t}\n\n\nout:\n\tspin_unlock_irqrestore(&phy_lock, flags);\n}\n\nstatic inline void\ntsi108_stat_carry_one(int carry, int carry_bit, int carry_shift,\n\t\t      unsigned long *upper)\n{\n\tif (carry & carry_bit)\n\t\t*upper += carry_shift;\n}\n\nstatic void tsi108_stat_carry(struct net_device *dev)\n{\n\tstruct tsi108_prv_data *data = netdev_priv(dev);\n\tunsigned long flags;\n\tu32 carry1, carry2;\n\n\tspin_lock_irqsave(&data->misclock, flags);\n\n\tcarry1 = TSI_READ(TSI108_STAT_CARRY1);\n\tcarry2 = TSI_READ(TSI108_STAT_CARRY2);\n\n\tTSI_WRITE(TSI108_STAT_CARRY1, carry1);\n\tTSI_WRITE(TSI108_STAT_CARRY2, carry2);\n\n\ttsi108_stat_carry_one(carry1, TSI108_STAT_CARRY1_RXBYTES,\n\t\t\t      TSI108_STAT_RXBYTES_CARRY, &data->stats.rx_bytes);\n\n\ttsi108_stat_carry_one(carry1, TSI108_STAT_CARRY1_RXPKTS,\n\t\t\t      TSI108_STAT_RXPKTS_CARRY,\n\t\t\t      &data->stats.rx_packets);\n\n\ttsi108_stat_carry_one(carry1, TSI108_STAT_CARRY1_RXFCS,\n\t\t\t      TSI108_STAT_RXFCS_CARRY, &data->rx_fcs);\n\n\ttsi108_stat_carry_one(carry1, TSI108_STAT_CARRY1_RXMCAST,\n\t\t\t      TSI108_STAT_RXMCAST_CARRY,\n\t\t\t      &data->stats.multicast);\n\n\ttsi108_stat_carry_one(carry1, TSI108_STAT_CARRY1_RXALIGN,\n\t\t\t      TSI108_STAT_RXALIGN_CARRY,\n\t\t\t      &data->stats.rx_frame_errors);\n\n\ttsi108_stat_carry_one(carry1, TSI108_STAT_CARRY1_RXLENGTH,\n\t\t\t      TSI108_STAT_RXLENGTH_CARRY,\n\t\t\t      &data->stats.rx_length_errors);\n\n\ttsi108_stat_carry_one(carry1, TSI108_STAT_CARRY1_RXRUNT,\n\t\t\t      TSI108_STAT_RXRUNT_CARRY, &data->rx_underruns);\n\n\ttsi108_stat_carry_one(carry1, TSI108_STAT_CARRY1_RXJUMBO,\n\t\t\t      TSI108_STAT_RXJUMBO_CARRY, &data->rx_overruns);\n\n\ttsi108_stat_carry_one(carry1, TSI108_STAT_CARRY1_RXFRAG,\n\t\t\t      TSI108_STAT_RXFRAG_CARRY, &data->rx_short_fcs);\n\n\ttsi108_stat_carry_one(carry1, TSI108_STAT_CARRY1_RXJABBER,\n\t\t\t      TSI108_STAT_RXJABBER_CARRY, &data->rx_long_fcs);\n\n\ttsi108_stat_carry_one(carry1, TSI108_STAT_CARRY1_RXDROP,\n\t\t\t      TSI108_STAT_RXDROP_CARRY,\n\t\t\t      &data->stats.rx_missed_errors);\n\n\ttsi108_stat_carry_one(carry2, TSI108_STAT_CARRY2_TXBYTES,\n\t\t\t      TSI108_STAT_TXBYTES_CARRY, &data->stats.tx_bytes);\n\n\ttsi108_stat_carry_one(carry2, TSI108_STAT_CARRY2_TXPKTS,\n\t\t\t      TSI108_STAT_TXPKTS_CARRY,\n\t\t\t      &data->stats.tx_packets);\n\n\ttsi108_stat_carry_one(carry2, TSI108_STAT_CARRY2_TXEXDEF,\n\t\t\t      TSI108_STAT_TXEXDEF_CARRY,\n\t\t\t      &data->stats.tx_aborted_errors);\n\n\ttsi108_stat_carry_one(carry2, TSI108_STAT_CARRY2_TXEXCOL,\n\t\t\t      TSI108_STAT_TXEXCOL_CARRY, &data->tx_coll_abort);\n\n\ttsi108_stat_carry_one(carry2, TSI108_STAT_CARRY2_TXTCOL,\n\t\t\t      TSI108_STAT_TXTCOL_CARRY,\n\t\t\t      &data->stats.collisions);\n\n\ttsi108_stat_carry_one(carry2, TSI108_STAT_CARRY2_TXPAUSE,\n\t\t\t      TSI108_STAT_TXPAUSEDROP_CARRY,\n\t\t\t      &data->tx_pause_drop);\n\n\tspin_unlock_irqrestore(&data->misclock, flags);\n}\n\n \nstatic inline unsigned long\ntsi108_read_stat(struct tsi108_prv_data * data, int reg, int carry_bit,\n\t\t int carry_shift, unsigned long *upper)\n{\n\tint carryreg;\n\tunsigned long val;\n\n\tif (reg < 0xb0)\n\t\tcarryreg = TSI108_STAT_CARRY1;\n\telse\n\t\tcarryreg = TSI108_STAT_CARRY2;\n\n      again:\n\tval = TSI_READ(reg) | *upper;\n\n\t \n\n\tif (unlikely(TSI_READ(carryreg) & carry_bit)) {\n\t\t*upper += carry_shift;\n\t\tTSI_WRITE(carryreg, carry_bit);\n\t\tgoto again;\n\t}\n\n\treturn val;\n}\n\nstatic struct net_device_stats *tsi108_get_stats(struct net_device *dev)\n{\n\tunsigned long excol;\n\n\tstruct tsi108_prv_data *data = netdev_priv(dev);\n\tspin_lock_irq(&data->misclock);\n\n\tdata->tmpstats.rx_packets =\n\t    tsi108_read_stat(data, TSI108_STAT_RXPKTS,\n\t\t\t     TSI108_STAT_CARRY1_RXPKTS,\n\t\t\t     TSI108_STAT_RXPKTS_CARRY, &data->stats.rx_packets);\n\n\tdata->tmpstats.tx_packets =\n\t    tsi108_read_stat(data, TSI108_STAT_TXPKTS,\n\t\t\t     TSI108_STAT_CARRY2_TXPKTS,\n\t\t\t     TSI108_STAT_TXPKTS_CARRY, &data->stats.tx_packets);\n\n\tdata->tmpstats.rx_bytes =\n\t    tsi108_read_stat(data, TSI108_STAT_RXBYTES,\n\t\t\t     TSI108_STAT_CARRY1_RXBYTES,\n\t\t\t     TSI108_STAT_RXBYTES_CARRY, &data->stats.rx_bytes);\n\n\tdata->tmpstats.tx_bytes =\n\t    tsi108_read_stat(data, TSI108_STAT_TXBYTES,\n\t\t\t     TSI108_STAT_CARRY2_TXBYTES,\n\t\t\t     TSI108_STAT_TXBYTES_CARRY, &data->stats.tx_bytes);\n\n\tdata->tmpstats.multicast =\n\t    tsi108_read_stat(data, TSI108_STAT_RXMCAST,\n\t\t\t     TSI108_STAT_CARRY1_RXMCAST,\n\t\t\t     TSI108_STAT_RXMCAST_CARRY, &data->stats.multicast);\n\n\texcol = tsi108_read_stat(data, TSI108_STAT_TXEXCOL,\n\t\t\t\t TSI108_STAT_CARRY2_TXEXCOL,\n\t\t\t\t TSI108_STAT_TXEXCOL_CARRY,\n\t\t\t\t &data->tx_coll_abort);\n\n\tdata->tmpstats.collisions =\n\t    tsi108_read_stat(data, TSI108_STAT_TXTCOL,\n\t\t\t     TSI108_STAT_CARRY2_TXTCOL,\n\t\t\t     TSI108_STAT_TXTCOL_CARRY, &data->stats.collisions);\n\n\tdata->tmpstats.collisions += excol;\n\n\tdata->tmpstats.rx_length_errors =\n\t    tsi108_read_stat(data, TSI108_STAT_RXLENGTH,\n\t\t\t     TSI108_STAT_CARRY1_RXLENGTH,\n\t\t\t     TSI108_STAT_RXLENGTH_CARRY,\n\t\t\t     &data->stats.rx_length_errors);\n\n\tdata->tmpstats.rx_length_errors +=\n\t    tsi108_read_stat(data, TSI108_STAT_RXRUNT,\n\t\t\t     TSI108_STAT_CARRY1_RXRUNT,\n\t\t\t     TSI108_STAT_RXRUNT_CARRY, &data->rx_underruns);\n\n\tdata->tmpstats.rx_length_errors +=\n\t    tsi108_read_stat(data, TSI108_STAT_RXJUMBO,\n\t\t\t     TSI108_STAT_CARRY1_RXJUMBO,\n\t\t\t     TSI108_STAT_RXJUMBO_CARRY, &data->rx_overruns);\n\n\tdata->tmpstats.rx_frame_errors =\n\t    tsi108_read_stat(data, TSI108_STAT_RXALIGN,\n\t\t\t     TSI108_STAT_CARRY1_RXALIGN,\n\t\t\t     TSI108_STAT_RXALIGN_CARRY,\n\t\t\t     &data->stats.rx_frame_errors);\n\n\tdata->tmpstats.rx_frame_errors +=\n\t    tsi108_read_stat(data, TSI108_STAT_RXFCS,\n\t\t\t     TSI108_STAT_CARRY1_RXFCS, TSI108_STAT_RXFCS_CARRY,\n\t\t\t     &data->rx_fcs);\n\n\tdata->tmpstats.rx_frame_errors +=\n\t    tsi108_read_stat(data, TSI108_STAT_RXFRAG,\n\t\t\t     TSI108_STAT_CARRY1_RXFRAG,\n\t\t\t     TSI108_STAT_RXFRAG_CARRY, &data->rx_short_fcs);\n\n\tdata->tmpstats.rx_missed_errors =\n\t    tsi108_read_stat(data, TSI108_STAT_RXDROP,\n\t\t\t     TSI108_STAT_CARRY1_RXDROP,\n\t\t\t     TSI108_STAT_RXDROP_CARRY,\n\t\t\t     &data->stats.rx_missed_errors);\n\n\t \n\tdata->tmpstats.rx_fifo_errors = data->stats.rx_fifo_errors;\n\tdata->tmpstats.rx_crc_errors = data->stats.rx_crc_errors;\n\n\tdata->tmpstats.tx_aborted_errors =\n\t    tsi108_read_stat(data, TSI108_STAT_TXEXDEF,\n\t\t\t     TSI108_STAT_CARRY2_TXEXDEF,\n\t\t\t     TSI108_STAT_TXEXDEF_CARRY,\n\t\t\t     &data->stats.tx_aborted_errors);\n\n\tdata->tmpstats.tx_aborted_errors +=\n\t    tsi108_read_stat(data, TSI108_STAT_TXPAUSEDROP,\n\t\t\t     TSI108_STAT_CARRY2_TXPAUSE,\n\t\t\t     TSI108_STAT_TXPAUSEDROP_CARRY,\n\t\t\t     &data->tx_pause_drop);\n\n\tdata->tmpstats.tx_aborted_errors += excol;\n\n\tdata->tmpstats.tx_errors = data->tmpstats.tx_aborted_errors;\n\tdata->tmpstats.rx_errors = data->tmpstats.rx_length_errors +\n\t    data->tmpstats.rx_crc_errors +\n\t    data->tmpstats.rx_frame_errors +\n\t    data->tmpstats.rx_fifo_errors + data->tmpstats.rx_missed_errors;\n\n\tspin_unlock_irq(&data->misclock);\n\treturn &data->tmpstats;\n}\n\nstatic void tsi108_restart_rx(struct tsi108_prv_data * data, struct net_device *dev)\n{\n\tTSI_WRITE(TSI108_EC_RXQ_PTRHIGH,\n\t\t\t     TSI108_EC_RXQ_PTRHIGH_VALID);\n\n\tTSI_WRITE(TSI108_EC_RXCTRL, TSI108_EC_RXCTRL_GO\n\t\t\t     | TSI108_EC_RXCTRL_QUEUE0);\n}\n\nstatic void tsi108_restart_tx(struct tsi108_prv_data * data)\n{\n\tTSI_WRITE(TSI108_EC_TXQ_PTRHIGH,\n\t\t\t     TSI108_EC_TXQ_PTRHIGH_VALID);\n\n\tTSI_WRITE(TSI108_EC_TXCTRL, TSI108_EC_TXCTRL_IDLEINT |\n\t\t\t     TSI108_EC_TXCTRL_GO | TSI108_EC_TXCTRL_QUEUE0);\n}\n\n \nstatic void tsi108_complete_tx(struct net_device *dev)\n{\n\tstruct tsi108_prv_data *data = netdev_priv(dev);\n\tint tx;\n\tstruct sk_buff *skb;\n\tint release = 0;\n\n\twhile (!data->txfree || data->txhead != data->txtail) {\n\t\ttx = data->txtail;\n\n\t\tif (data->txring[tx].misc & TSI108_TX_OWN)\n\t\t\tbreak;\n\n\t\tskb = data->txskbs[tx];\n\n\t\tif (!(data->txring[tx].misc & TSI108_TX_OK))\n\t\t\tprintk(\"%s: bad tx packet, misc %x\\n\",\n\t\t\t       dev->name, data->txring[tx].misc);\n\n\t\tdata->txtail = (data->txtail + 1) % TSI108_TXRING_LEN;\n\t\tdata->txfree++;\n\n\t\tif (data->txring[tx].misc & TSI108_TX_EOF) {\n\t\t\tdev_kfree_skb_any(skb);\n\t\t\trelease++;\n\t\t}\n\t}\n\n\tif (release) {\n\t\tif (is_valid_ether_addr(dev->dev_addr) && data->link_up)\n\t\t\tnetif_wake_queue(dev);\n\t}\n}\n\nstatic int tsi108_send_packet(struct sk_buff * skb, struct net_device *dev)\n{\n\tstruct tsi108_prv_data *data = netdev_priv(dev);\n\tint frags = skb_shinfo(skb)->nr_frags + 1;\n\tint i;\n\n\tif (!data->phy_ok && net_ratelimit())\n\t\tprintk(KERN_ERR \"%s: Transmit while PHY is down!\\n\", dev->name);\n\n\tif (!data->link_up) {\n\t\tprintk(KERN_ERR \"%s: Transmit while link is down!\\n\",\n\t\t       dev->name);\n\t\tnetif_stop_queue(dev);\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\n\tif (data->txfree < MAX_SKB_FRAGS + 1) {\n\t\tnetif_stop_queue(dev);\n\n\t\tif (net_ratelimit())\n\t\t\tprintk(KERN_ERR \"%s: Transmit with full tx ring!\\n\",\n\t\t\t       dev->name);\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\n\tif (data->txfree - frags < MAX_SKB_FRAGS + 1) {\n\t\tnetif_stop_queue(dev);\n\t}\n\n\tspin_lock_irq(&data->txlock);\n\n\tfor (i = 0; i < frags; i++) {\n\t\tint misc = 0;\n\t\tint tx = data->txhead;\n\n\t\t \n\n\t\tif ((tx % TSI108_TX_INT_FREQ == 0) &&\n\t\t    ((TSI108_TXRING_LEN - data->txfree) >= TSI108_TX_INT_FREQ))\n\t\t\tmisc = TSI108_TX_INT;\n\n\t\tdata->txskbs[tx] = skb;\n\n\t\tif (i == 0) {\n\t\t\tdata->txring[tx].buf0 = dma_map_single(&data->pdev->dev,\n\t\t\t\t\tskb->data, skb_headlen(skb),\n\t\t\t\t\tDMA_TO_DEVICE);\n\t\t\tdata->txring[tx].len = skb_headlen(skb);\n\t\t\tmisc |= TSI108_TX_SOF;\n\t\t} else {\n\t\t\tconst skb_frag_t *frag = &skb_shinfo(skb)->frags[i - 1];\n\n\t\t\tdata->txring[tx].buf0 =\n\t\t\t\tskb_frag_dma_map(&data->pdev->dev, frag,\n\t\t\t\t\t\t0, skb_frag_size(frag),\n\t\t\t\t\t\tDMA_TO_DEVICE);\n\t\t\tdata->txring[tx].len = skb_frag_size(frag);\n\t\t}\n\n\t\tif (i == frags - 1)\n\t\t\tmisc |= TSI108_TX_EOF;\n\n\t\tif (netif_msg_pktdata(data)) {\n\t\t\tint i;\n\t\t\tprintk(\"%s: Tx Frame contents (%d)\\n\", dev->name,\n\t\t\t       skb->len);\n\t\t\tfor (i = 0; i < skb->len; i++)\n\t\t\t\tprintk(\" %2.2x\", skb->data[i]);\n\t\t\tprintk(\".\\n\");\n\t\t}\n\t\tdata->txring[tx].misc = misc | TSI108_TX_OWN;\n\n\t\tdata->txhead = (data->txhead + 1) % TSI108_TXRING_LEN;\n\t\tdata->txfree--;\n\t}\n\n\ttsi108_complete_tx(dev);\n\n\t \n\n\tif (!(TSI_READ(TSI108_EC_TXSTAT) & TSI108_EC_TXSTAT_QUEUE0))\n\t\ttsi108_restart_tx(data);\n\n\tspin_unlock_irq(&data->txlock);\n\treturn NETDEV_TX_OK;\n}\n\nstatic int tsi108_complete_rx(struct net_device *dev, int budget)\n{\n\tstruct tsi108_prv_data *data = netdev_priv(dev);\n\tint done = 0;\n\n\twhile (data->rxfree && done != budget) {\n\t\tint rx = data->rxtail;\n\t\tstruct sk_buff *skb;\n\n\t\tif (data->rxring[rx].misc & TSI108_RX_OWN)\n\t\t\tbreak;\n\n\t\tskb = data->rxskbs[rx];\n\t\tdata->rxtail = (data->rxtail + 1) % TSI108_RXRING_LEN;\n\t\tdata->rxfree--;\n\t\tdone++;\n\n\t\tif (data->rxring[rx].misc & TSI108_RX_BAD) {\n\t\t\tspin_lock_irq(&data->misclock);\n\n\t\t\tif (data->rxring[rx].misc & TSI108_RX_CRC)\n\t\t\t\tdata->stats.rx_crc_errors++;\n\t\t\tif (data->rxring[rx].misc & TSI108_RX_OVER)\n\t\t\t\tdata->stats.rx_fifo_errors++;\n\n\t\t\tspin_unlock_irq(&data->misclock);\n\n\t\t\tdev_kfree_skb_any(skb);\n\t\t\tcontinue;\n\t\t}\n\t\tif (netif_msg_pktdata(data)) {\n\t\t\tint i;\n\t\t\tprintk(\"%s: Rx Frame contents (%d)\\n\",\n\t\t\t       dev->name, data->rxring[rx].len);\n\t\t\tfor (i = 0; i < data->rxring[rx].len; i++)\n\t\t\t\tprintk(\" %2.2x\", skb->data[i]);\n\t\t\tprintk(\".\\n\");\n\t\t}\n\n\t\tskb_put(skb, data->rxring[rx].len);\n\t\tskb->protocol = eth_type_trans(skb, dev);\n\t\tnetif_receive_skb(skb);\n\t}\n\n\treturn done;\n}\n\nstatic int tsi108_refill_rx(struct net_device *dev, int budget)\n{\n\tstruct tsi108_prv_data *data = netdev_priv(dev);\n\tint done = 0;\n\n\twhile (data->rxfree != TSI108_RXRING_LEN && done != budget) {\n\t\tint rx = data->rxhead;\n\t\tstruct sk_buff *skb;\n\n\t\tskb = netdev_alloc_skb_ip_align(dev, TSI108_RXBUF_SIZE);\n\t\tdata->rxskbs[rx] = skb;\n\t\tif (!skb)\n\t\t\tbreak;\n\n\t\tdata->rxring[rx].buf0 = dma_map_single(&data->pdev->dev,\n\t\t\t\tskb->data, TSI108_RX_SKB_SIZE,\n\t\t\t\tDMA_FROM_DEVICE);\n\n\t\t \n\n\t\tdata->rxring[rx].blen = TSI108_RX_SKB_SIZE;\n\t\tdata->rxring[rx].misc = TSI108_RX_OWN | TSI108_RX_INT;\n\n\t\tdata->rxhead = (data->rxhead + 1) % TSI108_RXRING_LEN;\n\t\tdata->rxfree++;\n\t\tdone++;\n\t}\n\n\tif (done != 0 && !(TSI_READ(TSI108_EC_RXSTAT) &\n\t\t\t   TSI108_EC_RXSTAT_QUEUE0))\n\t\ttsi108_restart_rx(data, dev);\n\n\treturn done;\n}\n\nstatic int tsi108_poll(struct napi_struct *napi, int budget)\n{\n\tstruct tsi108_prv_data *data = container_of(napi, struct tsi108_prv_data, napi);\n\tstruct net_device *dev = data->dev;\n\tu32 estat = TSI_READ(TSI108_EC_RXESTAT);\n\tu32 intstat = TSI_READ(TSI108_EC_INTSTAT);\n\tint num_received = 0, num_filled = 0;\n\n\tintstat &= TSI108_INT_RXQUEUE0 | TSI108_INT_RXTHRESH |\n\t    TSI108_INT_RXOVERRUN | TSI108_INT_RXERROR | TSI108_INT_RXWAIT;\n\n\tTSI_WRITE(TSI108_EC_RXESTAT, estat);\n\tTSI_WRITE(TSI108_EC_INTSTAT, intstat);\n\n\tif (data->rxpending || (estat & TSI108_EC_RXESTAT_Q0_DESCINT))\n\t\tnum_received = tsi108_complete_rx(dev, budget);\n\n\t \n\n\tif (data->rxfree < TSI108_RXRING_LEN)\n\t\tnum_filled = tsi108_refill_rx(dev, budget * 2);\n\n\tif (intstat & TSI108_INT_RXERROR) {\n\t\tu32 err = TSI_READ(TSI108_EC_RXERR);\n\t\tTSI_WRITE(TSI108_EC_RXERR, err);\n\n\t\tif (err) {\n\t\t\tif (net_ratelimit())\n\t\t\t\tprintk(KERN_DEBUG \"%s: RX error %x\\n\",\n\t\t\t\t       dev->name, err);\n\n\t\t\tif (!(TSI_READ(TSI108_EC_RXSTAT) &\n\t\t\t      TSI108_EC_RXSTAT_QUEUE0))\n\t\t\t\ttsi108_restart_rx(data, dev);\n\t\t}\n\t}\n\n\tif (intstat & TSI108_INT_RXOVERRUN) {\n\t\tspin_lock_irq(&data->misclock);\n\t\tdata->stats.rx_fifo_errors++;\n\t\tspin_unlock_irq(&data->misclock);\n\t}\n\n\tif (num_received < budget) {\n\t\tdata->rxpending = 0;\n\t\tnapi_complete_done(napi, num_received);\n\n\t\tTSI_WRITE(TSI108_EC_INTMASK,\n\t\t\t\t     TSI_READ(TSI108_EC_INTMASK)\n\t\t\t\t     & ~(TSI108_INT_RXQUEUE0\n\t\t\t\t\t | TSI108_INT_RXTHRESH |\n\t\t\t\t\t TSI108_INT_RXOVERRUN |\n\t\t\t\t\t TSI108_INT_RXERROR |\n\t\t\t\t\t TSI108_INT_RXWAIT));\n\t} else {\n\t\tdata->rxpending = 1;\n\t}\n\n\treturn num_received;\n}\n\nstatic void tsi108_rx_int(struct net_device *dev)\n{\n\tstruct tsi108_prv_data *data = netdev_priv(dev);\n\n\t \n\n\tif (napi_schedule_prep(&data->napi)) {\n\t\t \n\n\t\tTSI_WRITE(TSI108_EC_INTMASK,\n\t\t\t\t     TSI_READ(TSI108_EC_INTMASK) |\n\t\t\t\t     TSI108_INT_RXQUEUE0\n\t\t\t\t     | TSI108_INT_RXTHRESH |\n\t\t\t\t     TSI108_INT_RXOVERRUN | TSI108_INT_RXERROR |\n\t\t\t\t     TSI108_INT_RXWAIT);\n\t\t__napi_schedule(&data->napi);\n\t} else {\n\t\tif (!netif_running(dev)) {\n\t\t\t \n\n\t\t\tTSI_WRITE(TSI108_EC_INTMASK,\n\t\t\t\t\t     TSI_READ\n\t\t\t\t\t     (TSI108_EC_INTMASK) |\n\t\t\t\t\t     TSI108_INT_RXQUEUE0 |\n\t\t\t\t\t     TSI108_INT_RXTHRESH |\n\t\t\t\t\t     TSI108_INT_RXOVERRUN |\n\t\t\t\t\t     TSI108_INT_RXERROR |\n\t\t\t\t\t     TSI108_INT_RXWAIT);\n\t\t}\n\t}\n}\n\n \n\nstatic void tsi108_check_rxring(struct net_device *dev)\n{\n\tstruct tsi108_prv_data *data = netdev_priv(dev);\n\n\t \n\n\tif (netif_running(dev) && data->rxfree < TSI108_RXRING_LEN / 4)\n\t\ttsi108_rx_int(dev);\n}\n\nstatic void tsi108_tx_int(struct net_device *dev)\n{\n\tstruct tsi108_prv_data *data = netdev_priv(dev);\n\tu32 estat = TSI_READ(TSI108_EC_TXESTAT);\n\n\tTSI_WRITE(TSI108_EC_TXESTAT, estat);\n\tTSI_WRITE(TSI108_EC_INTSTAT, TSI108_INT_TXQUEUE0 |\n\t\t\t     TSI108_INT_TXIDLE | TSI108_INT_TXERROR);\n\tif (estat & TSI108_EC_TXESTAT_Q0_ERR) {\n\t\tu32 err = TSI_READ(TSI108_EC_TXERR);\n\t\tTSI_WRITE(TSI108_EC_TXERR, err);\n\n\t\tif (err && net_ratelimit())\n\t\t\tprintk(KERN_ERR \"%s: TX error %x\\n\", dev->name, err);\n\t}\n\n\tif (estat & (TSI108_EC_TXESTAT_Q0_DESCINT | TSI108_EC_TXESTAT_Q0_EOQ)) {\n\t\tspin_lock(&data->txlock);\n\t\ttsi108_complete_tx(dev);\n\t\tspin_unlock(&data->txlock);\n\t}\n}\n\n\nstatic irqreturn_t tsi108_irq(int irq, void *dev_id)\n{\n\tstruct net_device *dev = dev_id;\n\tstruct tsi108_prv_data *data = netdev_priv(dev);\n\tu32 stat = TSI_READ(TSI108_EC_INTSTAT);\n\n\tif (!(stat & TSI108_INT_ANY))\n\t\treturn IRQ_NONE;\t \n\n\tstat &= ~TSI_READ(TSI108_EC_INTMASK);\n\n\tif (stat & (TSI108_INT_TXQUEUE0 | TSI108_INT_TXIDLE |\n\t\t    TSI108_INT_TXERROR))\n\t\ttsi108_tx_int(dev);\n\tif (stat & (TSI108_INT_RXQUEUE0 | TSI108_INT_RXTHRESH |\n\t\t    TSI108_INT_RXWAIT | TSI108_INT_RXOVERRUN |\n\t\t    TSI108_INT_RXERROR))\n\t\ttsi108_rx_int(dev);\n\n\tif (stat & TSI108_INT_SFN) {\n\t\tif (net_ratelimit())\n\t\t\tprintk(KERN_DEBUG \"%s: SFN error\\n\", dev->name);\n\t\tTSI_WRITE(TSI108_EC_INTSTAT, TSI108_INT_SFN);\n\t}\n\n\tif (stat & TSI108_INT_STATCARRY) {\n\t\ttsi108_stat_carry(dev);\n\t\tTSI_WRITE(TSI108_EC_INTSTAT, TSI108_INT_STATCARRY);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void tsi108_stop_ethernet(struct net_device *dev)\n{\n\tstruct tsi108_prv_data *data = netdev_priv(dev);\n\tint i = 1000;\n\t \n\tTSI_WRITE(TSI108_EC_TXCTRL, 0);\n\tTSI_WRITE(TSI108_EC_RXCTRL, 0);\n\n\t \n\twhile(i--) {\n\t\tif(!(TSI_READ(TSI108_EC_TXSTAT) & TSI108_EC_TXSTAT_ACTIVE))\n\t\t\tbreak;\n\t\tudelay(10);\n\t}\n\ti = 1000;\n\twhile(i--){\n\t\tif(!(TSI_READ(TSI108_EC_RXSTAT) & TSI108_EC_RXSTAT_ACTIVE))\n\t\t\treturn;\n\t\tudelay(10);\n\t}\n\tprintk(KERN_ERR \"%s function time out\\n\", __func__);\n}\n\nstatic void tsi108_reset_ether(struct tsi108_prv_data * data)\n{\n\tTSI_WRITE(TSI108_MAC_CFG1, TSI108_MAC_CFG1_SOFTRST);\n\tudelay(100);\n\tTSI_WRITE(TSI108_MAC_CFG1, 0);\n\n\tTSI_WRITE(TSI108_EC_PORTCTRL, TSI108_EC_PORTCTRL_STATRST);\n\tudelay(100);\n\tTSI_WRITE(TSI108_EC_PORTCTRL,\n\t\t\t     TSI_READ(TSI108_EC_PORTCTRL) &\n\t\t\t     ~TSI108_EC_PORTCTRL_STATRST);\n\n\tTSI_WRITE(TSI108_EC_TXCFG, TSI108_EC_TXCFG_RST);\n\tudelay(100);\n\tTSI_WRITE(TSI108_EC_TXCFG,\n\t\t\t     TSI_READ(TSI108_EC_TXCFG) &\n\t\t\t     ~TSI108_EC_TXCFG_RST);\n\n\tTSI_WRITE(TSI108_EC_RXCFG, TSI108_EC_RXCFG_RST);\n\tudelay(100);\n\tTSI_WRITE(TSI108_EC_RXCFG,\n\t\t\t     TSI_READ(TSI108_EC_RXCFG) &\n\t\t\t     ~TSI108_EC_RXCFG_RST);\n\n\tTSI_WRITE(TSI108_MAC_MII_MGMT_CFG,\n\t\t\t     TSI_READ(TSI108_MAC_MII_MGMT_CFG) |\n\t\t\t     TSI108_MAC_MII_MGMT_RST);\n\tudelay(100);\n\tTSI_WRITE(TSI108_MAC_MII_MGMT_CFG,\n\t\t\t     (TSI_READ(TSI108_MAC_MII_MGMT_CFG) &\n\t\t\t     ~(TSI108_MAC_MII_MGMT_RST |\n\t\t\t       TSI108_MAC_MII_MGMT_CLK)) | 0x07);\n}\n\nstatic int tsi108_get_mac(struct net_device *dev)\n{\n\tstruct tsi108_prv_data *data = netdev_priv(dev);\n\tu32 word1 = TSI_READ(TSI108_MAC_ADDR1);\n\tu32 word2 = TSI_READ(TSI108_MAC_ADDR2);\n\tu8 addr[ETH_ALEN];\n\n\t \n\tif (word2 == 0 && word1 == 0) {\n\t\taddr[0] = 0x00;\n\t\taddr[1] = 0x06;\n\t\taddr[2] = 0xd2;\n\t\taddr[3] = 0x00;\n\t\taddr[4] = 0x00;\n\t\tif (0x8 == data->phy)\n\t\t\taddr[5] = 0x01;\n\t\telse\n\t\t\taddr[5] = 0x02;\n\t\teth_hw_addr_set(dev, addr);\n\n\t\tword2 = (dev->dev_addr[0] << 16) | (dev->dev_addr[1] << 24);\n\n\t\tword1 = (dev->dev_addr[2] << 0) | (dev->dev_addr[3] << 8) |\n\t\t    (dev->dev_addr[4] << 16) | (dev->dev_addr[5] << 24);\n\n\t\tTSI_WRITE(TSI108_MAC_ADDR1, word1);\n\t\tTSI_WRITE(TSI108_MAC_ADDR2, word2);\n\t} else {\n\t\taddr[0] = (word2 >> 16) & 0xff;\n\t\taddr[1] = (word2 >> 24) & 0xff;\n\t\taddr[2] = (word1 >> 0) & 0xff;\n\t\taddr[3] = (word1 >> 8) & 0xff;\n\t\taddr[4] = (word1 >> 16) & 0xff;\n\t\taddr[5] = (word1 >> 24) & 0xff;\n\t\teth_hw_addr_set(dev, addr);\n\t}\n\n\tif (!is_valid_ether_addr(dev->dev_addr)) {\n\t\tprintk(KERN_ERR\n\t\t       \"%s: Invalid MAC address. word1: %08x, word2: %08x\\n\",\n\t\t       dev->name, word1, word2);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int tsi108_set_mac(struct net_device *dev, void *addr)\n{\n\tstruct tsi108_prv_data *data = netdev_priv(dev);\n\tu32 word1, word2;\n\n\tif (!is_valid_ether_addr(addr))\n\t\treturn -EADDRNOTAVAIL;\n\n\t \n\teth_hw_addr_set(dev, ((unsigned char *)addr) + 2);\n\n\tword2 = (dev->dev_addr[0] << 16) | (dev->dev_addr[1] << 24);\n\n\tword1 = (dev->dev_addr[2] << 0) | (dev->dev_addr[3] << 8) |\n\t    (dev->dev_addr[4] << 16) | (dev->dev_addr[5] << 24);\n\n\tspin_lock_irq(&data->misclock);\n\tTSI_WRITE(TSI108_MAC_ADDR1, word1);\n\tTSI_WRITE(TSI108_MAC_ADDR2, word2);\n\tspin_lock(&data->txlock);\n\n\tif (data->txfree && data->link_up)\n\t\tnetif_wake_queue(dev);\n\n\tspin_unlock(&data->txlock);\n\tspin_unlock_irq(&data->misclock);\n\treturn 0;\n}\n\n \nstatic void tsi108_set_rx_mode(struct net_device *dev)\n{\n\tstruct tsi108_prv_data *data = netdev_priv(dev);\n\tu32 rxcfg = TSI_READ(TSI108_EC_RXCFG);\n\n\tif (dev->flags & IFF_PROMISC) {\n\t\trxcfg &= ~(TSI108_EC_RXCFG_UC_HASH | TSI108_EC_RXCFG_MC_HASH);\n\t\trxcfg |= TSI108_EC_RXCFG_UFE | TSI108_EC_RXCFG_MFE;\n\t\tgoto out;\n\t}\n\n\trxcfg &= ~(TSI108_EC_RXCFG_UFE | TSI108_EC_RXCFG_MFE);\n\n\tif (dev->flags & IFF_ALLMULTI || !netdev_mc_empty(dev)) {\n\t\tint i;\n\t\tstruct netdev_hw_addr *ha;\n\t\trxcfg |= TSI108_EC_RXCFG_MFE | TSI108_EC_RXCFG_MC_HASH;\n\n\t\tmemset(data->mc_hash, 0, sizeof(data->mc_hash));\n\n\t\tnetdev_for_each_mc_addr(ha, dev) {\n\t\t\tu32 hash, crc;\n\n\t\t\tcrc = ether_crc(6, ha->addr);\n\t\t\thash = crc >> 23;\n\t\t\t__set_bit(hash, &data->mc_hash[0]);\n\t\t}\n\n\t\tTSI_WRITE(TSI108_EC_HASHADDR,\n\t\t\t\t     TSI108_EC_HASHADDR_AUTOINC |\n\t\t\t\t     TSI108_EC_HASHADDR_MCAST);\n\n\t\tfor (i = 0; i < 16; i++) {\n\t\t\t \n\t\t\tudelay(1);\n\t\t\tTSI_WRITE(TSI108_EC_HASHDATA,\n\t\t\t\t\t     data->mc_hash[i]);\n\t\t}\n\t}\n\n      out:\n\tTSI_WRITE(TSI108_EC_RXCFG, rxcfg);\n}\n\nstatic void tsi108_init_phy(struct net_device *dev)\n{\n\tstruct tsi108_prv_data *data = netdev_priv(dev);\n\tu32 i = 0;\n\tu16 phyval = 0;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&phy_lock, flags);\n\n\ttsi108_write_mii(data, MII_BMCR, BMCR_RESET);\n\twhile (--i) {\n\t\tif(!(tsi108_read_mii(data, MII_BMCR) & BMCR_RESET))\n\t\t\tbreak;\n\t\tudelay(10);\n\t}\n\tif (i == 0)\n\t\tprintk(KERN_ERR \"%s function time out\\n\", __func__);\n\n\tif (data->phy_type == TSI108_PHY_BCM54XX) {\n\t\ttsi108_write_mii(data, 0x09, 0x0300);\n\t\ttsi108_write_mii(data, 0x10, 0x1020);\n\t\ttsi108_write_mii(data, 0x1c, 0x8c00);\n\t}\n\n\ttsi108_write_mii(data,\n\t\t\t MII_BMCR,\n\t\t\t BMCR_ANENABLE | BMCR_ANRESTART);\n\twhile (tsi108_read_mii(data, MII_BMCR) & BMCR_ANRESTART)\n\t\tcpu_relax();\n\n\t \n\n\ttsi108_write_tbi(data, 0x11, 0x30);\n\n\t \n\n\tdata->link_up = 0;\n\n\twhile (!((phyval = tsi108_read_mii(data, MII_BMSR)) &\n\t\t BMSR_LSTATUS)) {\n\t\tif (i++ > (MII_READ_DELAY / 10)) {\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock_irqrestore(&phy_lock, flags);\n\t\tmsleep(10);\n\t\tspin_lock_irqsave(&phy_lock, flags);\n\t}\n\n\tdata->mii_if.supports_gmii = mii_check_gmii_support(&data->mii_if);\n\tprintk(KERN_DEBUG \"PHY_STAT reg contains %08x\\n\", phyval);\n\tdata->phy_ok = 1;\n\tdata->init_media = 1;\n\tspin_unlock_irqrestore(&phy_lock, flags);\n}\n\nstatic void tsi108_kill_phy(struct net_device *dev)\n{\n\tstruct tsi108_prv_data *data = netdev_priv(dev);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&phy_lock, flags);\n\ttsi108_write_mii(data, MII_BMCR, BMCR_PDOWN);\n\tdata->phy_ok = 0;\n\tspin_unlock_irqrestore(&phy_lock, flags);\n}\n\nstatic int tsi108_open(struct net_device *dev)\n{\n\tint i;\n\tstruct tsi108_prv_data *data = netdev_priv(dev);\n\tunsigned int rxring_size = TSI108_RXRING_LEN * sizeof(rx_desc);\n\tunsigned int txring_size = TSI108_TXRING_LEN * sizeof(tx_desc);\n\n\ti = request_irq(data->irq_num, tsi108_irq, 0, dev->name, dev);\n\tif (i != 0) {\n\t\tprintk(KERN_ERR \"tsi108_eth%d: Could not allocate IRQ%d.\\n\",\n\t\t       data->id, data->irq_num);\n\t\treturn i;\n\t} else {\n\t\tdev->irq = data->irq_num;\n\t\tprintk(KERN_NOTICE\n\t\t       \"tsi108_open : Port %d Assigned IRQ %d to %s\\n\",\n\t\t       data->id, dev->irq, dev->name);\n\t}\n\n\tdata->rxring = dma_alloc_coherent(&data->pdev->dev, rxring_size,\n\t\t\t\t\t  &data->rxdma, GFP_KERNEL);\n\tif (!data->rxring) {\n\t\tfree_irq(data->irq_num, dev);\n\t\treturn -ENOMEM;\n\t}\n\n\tdata->txring = dma_alloc_coherent(&data->pdev->dev, txring_size,\n\t\t\t\t\t  &data->txdma, GFP_KERNEL);\n\tif (!data->txring) {\n\t\tfree_irq(data->irq_num, dev);\n\t\tdma_free_coherent(&data->pdev->dev, rxring_size, data->rxring,\n\t\t\t\t    data->rxdma);\n\t\treturn -ENOMEM;\n\t}\n\n\tfor (i = 0; i < TSI108_RXRING_LEN; i++) {\n\t\tdata->rxring[i].next0 = data->rxdma + (i + 1) * sizeof(rx_desc);\n\t\tdata->rxring[i].blen = TSI108_RXBUF_SIZE;\n\t\tdata->rxring[i].vlan = 0;\n\t}\n\n\tdata->rxring[TSI108_RXRING_LEN - 1].next0 = data->rxdma;\n\n\tdata->rxtail = 0;\n\tdata->rxhead = 0;\n\n\tfor (i = 0; i < TSI108_RXRING_LEN; i++) {\n\t\tstruct sk_buff *skb;\n\n\t\tskb = netdev_alloc_skb_ip_align(dev, TSI108_RXBUF_SIZE);\n\t\tif (!skb) {\n\t\t\t \n\t\t\tprintk(KERN_WARNING\n\t\t\t       \"%s: Could only allocate %d receive skb(s).\\n\",\n\t\t\t       dev->name, i);\n\t\t\tdata->rxhead = i;\n\t\t\tbreak;\n\t\t}\n\n\t\tdata->rxskbs[i] = skb;\n\t\tdata->rxring[i].buf0 = virt_to_phys(data->rxskbs[i]->data);\n\t\tdata->rxring[i].misc = TSI108_RX_OWN | TSI108_RX_INT;\n\t}\n\n\tdata->rxfree = i;\n\tTSI_WRITE(TSI108_EC_RXQ_PTRLOW, data->rxdma);\n\n\tfor (i = 0; i < TSI108_TXRING_LEN; i++) {\n\t\tdata->txring[i].next0 = data->txdma + (i + 1) * sizeof(tx_desc);\n\t\tdata->txring[i].misc = 0;\n\t}\n\n\tdata->txring[TSI108_TXRING_LEN - 1].next0 = data->txdma;\n\tdata->txtail = 0;\n\tdata->txhead = 0;\n\tdata->txfree = TSI108_TXRING_LEN;\n\tTSI_WRITE(TSI108_EC_TXQ_PTRLOW, data->txdma);\n\ttsi108_init_phy(dev);\n\n\tnapi_enable(&data->napi);\n\n\ttimer_setup(&data->timer, tsi108_timed_checker, 0);\n\tmod_timer(&data->timer, jiffies + 1);\n\n\ttsi108_restart_rx(data, dev);\n\n\tTSI_WRITE(TSI108_EC_INTSTAT, ~0);\n\n\tTSI_WRITE(TSI108_EC_INTMASK,\n\t\t\t     ~(TSI108_INT_TXQUEUE0 | TSI108_INT_RXERROR |\n\t\t\t       TSI108_INT_RXTHRESH | TSI108_INT_RXQUEUE0 |\n\t\t\t       TSI108_INT_RXOVERRUN | TSI108_INT_RXWAIT |\n\t\t\t       TSI108_INT_SFN | TSI108_INT_STATCARRY));\n\n\tTSI_WRITE(TSI108_MAC_CFG1,\n\t\t\t     TSI108_MAC_CFG1_RXEN | TSI108_MAC_CFG1_TXEN);\n\tnetif_start_queue(dev);\n\treturn 0;\n}\n\nstatic int tsi108_close(struct net_device *dev)\n{\n\tstruct tsi108_prv_data *data = netdev_priv(dev);\n\n\tnetif_stop_queue(dev);\n\tnapi_disable(&data->napi);\n\n\tdel_timer_sync(&data->timer);\n\n\ttsi108_stop_ethernet(dev);\n\ttsi108_kill_phy(dev);\n\tTSI_WRITE(TSI108_EC_INTMASK, ~0);\n\tTSI_WRITE(TSI108_MAC_CFG1, 0);\n\n\t \n\n\twhile (!data->txfree || data->txhead != data->txtail) {\n\t\tint tx = data->txtail;\n\t\tstruct sk_buff *skb;\n\t\tskb = data->txskbs[tx];\n\t\tdata->txtail = (data->txtail + 1) % TSI108_TXRING_LEN;\n\t\tdata->txfree++;\n\t\tdev_kfree_skb(skb);\n\t}\n\n\tfree_irq(data->irq_num, dev);\n\n\t \n\n\twhile (data->rxfree) {\n\t\tint rx = data->rxtail;\n\t\tstruct sk_buff *skb;\n\n\t\tskb = data->rxskbs[rx];\n\t\tdata->rxtail = (data->rxtail + 1) % TSI108_RXRING_LEN;\n\t\tdata->rxfree--;\n\t\tdev_kfree_skb(skb);\n\t}\n\n\tdma_free_coherent(&data->pdev->dev,\n\t\t\t    TSI108_RXRING_LEN * sizeof(rx_desc),\n\t\t\t    data->rxring, data->rxdma);\n\tdma_free_coherent(&data->pdev->dev,\n\t\t\t    TSI108_TXRING_LEN * sizeof(tx_desc),\n\t\t\t    data->txring, data->txdma);\n\n\treturn 0;\n}\n\nstatic void tsi108_init_mac(struct net_device *dev)\n{\n\tstruct tsi108_prv_data *data = netdev_priv(dev);\n\n\tTSI_WRITE(TSI108_MAC_CFG2, TSI108_MAC_CFG2_DFLT_PREAMBLE |\n\t\t\t     TSI108_MAC_CFG2_PADCRC);\n\n\tTSI_WRITE(TSI108_EC_TXTHRESH,\n\t\t\t     (192 << TSI108_EC_TXTHRESH_STARTFILL) |\n\t\t\t     (192 << TSI108_EC_TXTHRESH_STOPFILL));\n\n\tTSI_WRITE(TSI108_STAT_CARRYMASK1,\n\t\t\t     ~(TSI108_STAT_CARRY1_RXBYTES |\n\t\t\t       TSI108_STAT_CARRY1_RXPKTS |\n\t\t\t       TSI108_STAT_CARRY1_RXFCS |\n\t\t\t       TSI108_STAT_CARRY1_RXMCAST |\n\t\t\t       TSI108_STAT_CARRY1_RXALIGN |\n\t\t\t       TSI108_STAT_CARRY1_RXLENGTH |\n\t\t\t       TSI108_STAT_CARRY1_RXRUNT |\n\t\t\t       TSI108_STAT_CARRY1_RXJUMBO |\n\t\t\t       TSI108_STAT_CARRY1_RXFRAG |\n\t\t\t       TSI108_STAT_CARRY1_RXJABBER |\n\t\t\t       TSI108_STAT_CARRY1_RXDROP));\n\n\tTSI_WRITE(TSI108_STAT_CARRYMASK2,\n\t\t\t     ~(TSI108_STAT_CARRY2_TXBYTES |\n\t\t\t       TSI108_STAT_CARRY2_TXPKTS |\n\t\t\t       TSI108_STAT_CARRY2_TXEXDEF |\n\t\t\t       TSI108_STAT_CARRY2_TXEXCOL |\n\t\t\t       TSI108_STAT_CARRY2_TXTCOL |\n\t\t\t       TSI108_STAT_CARRY2_TXPAUSE));\n\n\tTSI_WRITE(TSI108_EC_PORTCTRL, TSI108_EC_PORTCTRL_STATEN);\n\tTSI_WRITE(TSI108_MAC_CFG1, 0);\n\n\tTSI_WRITE(TSI108_EC_RXCFG,\n\t\t\t     TSI108_EC_RXCFG_SE | TSI108_EC_RXCFG_BFE);\n\n\tTSI_WRITE(TSI108_EC_TXQ_CFG, TSI108_EC_TXQ_CFG_DESC_INT |\n\t\t\t     TSI108_EC_TXQ_CFG_EOQ_OWN_INT |\n\t\t\t     TSI108_EC_TXQ_CFG_WSWP | (TSI108_PBM_PORT <<\n\t\t\t\t\t\tTSI108_EC_TXQ_CFG_SFNPORT));\n\n\tTSI_WRITE(TSI108_EC_RXQ_CFG, TSI108_EC_RXQ_CFG_DESC_INT |\n\t\t\t     TSI108_EC_RXQ_CFG_EOQ_OWN_INT |\n\t\t\t     TSI108_EC_RXQ_CFG_WSWP | (TSI108_PBM_PORT <<\n\t\t\t\t\t\tTSI108_EC_RXQ_CFG_SFNPORT));\n\n\tTSI_WRITE(TSI108_EC_TXQ_BUFCFG,\n\t\t\t     TSI108_EC_TXQ_BUFCFG_BURST256 |\n\t\t\t     TSI108_EC_TXQ_BUFCFG_BSWP | (TSI108_PBM_PORT <<\n\t\t\t\t\t\tTSI108_EC_TXQ_BUFCFG_SFNPORT));\n\n\tTSI_WRITE(TSI108_EC_RXQ_BUFCFG,\n\t\t\t     TSI108_EC_RXQ_BUFCFG_BURST256 |\n\t\t\t     TSI108_EC_RXQ_BUFCFG_BSWP | (TSI108_PBM_PORT <<\n\t\t\t\t\t\tTSI108_EC_RXQ_BUFCFG_SFNPORT));\n\n\tTSI_WRITE(TSI108_EC_INTMASK, ~0);\n}\n\nstatic int tsi108_get_link_ksettings(struct net_device *dev,\n\t\t\t\t     struct ethtool_link_ksettings *cmd)\n{\n\tstruct tsi108_prv_data *data = netdev_priv(dev);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&data->txlock, flags);\n\tmii_ethtool_get_link_ksettings(&data->mii_if, cmd);\n\tspin_unlock_irqrestore(&data->txlock, flags);\n\n\treturn 0;\n}\n\nstatic int tsi108_set_link_ksettings(struct net_device *dev,\n\t\t\t\t     const struct ethtool_link_ksettings *cmd)\n{\n\tstruct tsi108_prv_data *data = netdev_priv(dev);\n\tunsigned long flags;\n\tint rc;\n\n\tspin_lock_irqsave(&data->txlock, flags);\n\trc = mii_ethtool_set_link_ksettings(&data->mii_if, cmd);\n\tspin_unlock_irqrestore(&data->txlock, flags);\n\n\treturn rc;\n}\n\nstatic int tsi108_do_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)\n{\n\tstruct tsi108_prv_data *data = netdev_priv(dev);\n\tif (!netif_running(dev))\n\t\treturn -EINVAL;\n\treturn generic_mii_ioctl(&data->mii_if, if_mii(rq), cmd, NULL);\n}\n\nstatic const struct ethtool_ops tsi108_ethtool_ops = {\n\t.get_link \t= ethtool_op_get_link,\n\t.get_link_ksettings\t= tsi108_get_link_ksettings,\n\t.set_link_ksettings\t= tsi108_set_link_ksettings,\n};\n\nstatic const struct net_device_ops tsi108_netdev_ops = {\n\t.ndo_open\t\t= tsi108_open,\n\t.ndo_stop\t\t= tsi108_close,\n\t.ndo_start_xmit\t\t= tsi108_send_packet,\n\t.ndo_set_rx_mode\t= tsi108_set_rx_mode,\n\t.ndo_get_stats\t\t= tsi108_get_stats,\n\t.ndo_eth_ioctl\t\t= tsi108_do_ioctl,\n\t.ndo_set_mac_address\t= tsi108_set_mac,\n\t.ndo_validate_addr\t= eth_validate_addr,\n};\n\nstatic int\ntsi108_init_one(struct platform_device *pdev)\n{\n\tstruct net_device *dev = NULL;\n\tstruct tsi108_prv_data *data = NULL;\n\thw_info *einfo;\n\tint err = 0;\n\n\teinfo = dev_get_platdata(&pdev->dev);\n\n\tif (NULL == einfo) {\n\t\tprintk(KERN_ERR \"tsi-eth %d: Missing additional data!\\n\",\n\t\t       pdev->id);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\n\tdev = alloc_etherdev(sizeof(struct tsi108_prv_data));\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tprintk(\"tsi108_eth%d: probe...\\n\", pdev->id);\n\tdata = netdev_priv(dev);\n\tdata->dev = dev;\n\tdata->pdev = pdev;\n\n\tpr_debug(\"tsi108_eth%d:regs:phyresgs:phy:irq_num=0x%x:0x%x:0x%x:0x%x\\n\",\n\t\t\tpdev->id, einfo->regs, einfo->phyregs,\n\t\t\teinfo->phy, einfo->irq_num);\n\n\tdata->regs = ioremap(einfo->regs, 0x400);\n\tif (NULL == data->regs) {\n\t\terr = -ENOMEM;\n\t\tgoto regs_fail;\n\t}\n\n\tdata->phyregs = ioremap(einfo->phyregs, 0x400);\n\tif (NULL == data->phyregs) {\n\t\terr = -ENOMEM;\n\t\tgoto phyregs_fail;\n\t}\n \n\tdata->mii_if.dev = dev;\n\tdata->mii_if.mdio_read = tsi108_mdio_read;\n\tdata->mii_if.mdio_write = tsi108_mdio_write;\n\tdata->mii_if.phy_id = einfo->phy;\n\tdata->mii_if.phy_id_mask = 0x1f;\n\tdata->mii_if.reg_num_mask = 0x1f;\n\n\tdata->phy = einfo->phy;\n\tdata->phy_type = einfo->phy_type;\n\tdata->irq_num = einfo->irq_num;\n\tdata->id = pdev->id;\n\tnetif_napi_add(dev, &data->napi, tsi108_poll);\n\tdev->netdev_ops = &tsi108_netdev_ops;\n\tdev->ethtool_ops = &tsi108_ethtool_ops;\n\n\t \n\n\tdev->features = NETIF_F_HIGHDMA;\n\n\tspin_lock_init(&data->txlock);\n\tspin_lock_init(&data->misclock);\n\n\ttsi108_reset_ether(data);\n\ttsi108_kill_phy(dev);\n\n\tif ((err = tsi108_get_mac(dev)) != 0) {\n\t\tprintk(KERN_ERR \"%s: Invalid MAC address.  Please correct.\\n\",\n\t\t       dev->name);\n\t\tgoto register_fail;\n\t}\n\n\ttsi108_init_mac(dev);\n\terr = register_netdev(dev);\n\tif (err) {\n\t\tprintk(KERN_ERR \"%s: Cannot register net device, aborting.\\n\",\n\t\t\t\tdev->name);\n\t\tgoto register_fail;\n\t}\n\n\tplatform_set_drvdata(pdev, dev);\n\tprintk(KERN_INFO \"%s: Tsi108 Gigabit Ethernet, MAC: %pM\\n\",\n\t       dev->name, dev->dev_addr);\n#ifdef DEBUG\n\tdata->msg_enable = DEBUG;\n\tdump_eth_one(dev);\n#endif\n\n\treturn 0;\n\nregister_fail:\n\tiounmap(data->phyregs);\n\nphyregs_fail:\n\tiounmap(data->regs);\n\nregs_fail:\n\tfree_netdev(dev);\n\treturn err;\n}\n\n \n\nstatic void tsi108_timed_checker(struct timer_list *t)\n{\n\tstruct tsi108_prv_data *data = from_timer(data, t, timer);\n\tstruct net_device *dev = data->dev;\n\n\ttsi108_check_phy(dev);\n\ttsi108_check_rxring(dev);\n\tmod_timer(&data->timer, jiffies + CHECK_PHY_INTERVAL);\n}\n\nstatic int tsi108_ether_remove(struct platform_device *pdev)\n{\n\tstruct net_device *dev = platform_get_drvdata(pdev);\n\tstruct tsi108_prv_data *priv = netdev_priv(dev);\n\n\tunregister_netdev(dev);\n\ttsi108_stop_ethernet(dev);\n\tiounmap(priv->regs);\n\tiounmap(priv->phyregs);\n\tfree_netdev(dev);\n\n\treturn 0;\n}\n\n \n\nstatic struct platform_driver tsi_eth_driver = {\n\t.probe = tsi108_init_one,\n\t.remove = tsi108_ether_remove,\n\t.driver\t= {\n\t\t.name = \"tsi-ethernet\",\n\t},\n};\nmodule_platform_driver(tsi_eth_driver);\n\nMODULE_AUTHOR(\"Tundra Semiconductor Corporation\");\nMODULE_DESCRIPTION(\"Tsi108 Gigabit Ethernet driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:tsi-ethernet\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}