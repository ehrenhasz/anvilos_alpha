{
  "module_name": "dm9000.c",
  "hash_id": "ecfe5fbc22a6b4760b963ff7e6304dc833a6fadc36860c18be5b8cdfc0455708",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/davicom/dm9000.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/ioport.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/interrupt.h>\n#include <linux/skbuff.h>\n#include <linux/spinlock.h>\n#include <linux/crc32.h>\n#include <linux/mii.h>\n#include <linux/of.h>\n#include <linux/of_net.h>\n#include <linux/ethtool.h>\n#include <linux/dm9000.h>\n#include <linux/delay.h>\n#include <linux/platform_device.h>\n#include <linux/irq.h>\n#include <linux/slab.h>\n#include <linux/regulator/consumer.h>\n#include <linux/gpio/consumer.h>\n\n#include <asm/delay.h>\n#include <asm/irq.h>\n#include <asm/io.h>\n\n#include \"dm9000.h\"\n\n \n\n#define DM9000_PHY\t\t0x40\t \n\n#define CARDNAME\t\"dm9000\"\n\n \nstatic int watchdog = 5000;\nmodule_param(watchdog, int, 0400);\nMODULE_PARM_DESC(watchdog, \"transmit timeout in milliseconds\");\n\n \nstatic int debug;\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug, \"dm9000 debug level (0-6)\");\n\n \n\n \n\nenum dm9000_type {\n\tTYPE_DM9000E,\t \n\tTYPE_DM9000A,\n\tTYPE_DM9000B\n};\n\n \nstruct board_info {\n\n\tvoid __iomem\t*io_addr;\t \n\tvoid __iomem\t*io_data;\t \n\tu16\t\t irq;\t\t \n\n\tu16\t\ttx_pkt_cnt;\n\tu16\t\tqueue_pkt_len;\n\tu16\t\tqueue_start_addr;\n\tu16\t\tqueue_ip_summed;\n\tu16\t\tdbug_cnt;\n\tu8\t\tio_mode;\t\t \n\tu8\t\tphy_addr;\n\tu8\t\timr_all;\n\n\tunsigned int\tflags;\n\tunsigned int\tin_timeout:1;\n\tunsigned int\tin_suspend:1;\n\tunsigned int\twake_supported:1;\n\n\tenum dm9000_type type;\n\n\tvoid (*inblk)(void __iomem *port, void *data, int length);\n\tvoid (*outblk)(void __iomem *port, void *data, int length);\n\tvoid (*dumpblk)(void __iomem *port, int length);\n\n\tstruct device\t*dev;\t      \n\n\tstruct resource\t*addr_res;    \n\tstruct resource *data_res;\n\tstruct resource\t*addr_req;    \n\tstruct resource *data_req;\n\n\tint\t\t irq_wake;\n\n\tstruct mutex\t addr_lock;\t \n\n\tstruct delayed_work phy_poll;\n\tstruct net_device  *ndev;\n\n\tspinlock_t\tlock;\n\n\tstruct mii_if_info mii;\n\tu32\t\tmsg_enable;\n\tu32\t\twake_state;\n\n\tint\t\tip_summed;\n\n\tstruct regulator *power_supply;\n};\n\n \n\n#define dm9000_dbg(db, lev, msg...) do {\t\t\\\n\tif ((lev) < debug) {\t\t\t\t\\\n\t\tdev_dbg(db->dev, msg);\t\t\t\\\n\t}\t\t\t\t\t\t\\\n} while (0)\n\nstatic inline struct board_info *to_dm9000_board(struct net_device *dev)\n{\n\treturn netdev_priv(dev);\n}\n\n \n\n \nstatic u8\nior(struct board_info *db, int reg)\n{\n\twriteb(reg, db->io_addr);\n\treturn readb(db->io_data);\n}\n\n \n\nstatic void\niow(struct board_info *db, int reg, int value)\n{\n\twriteb(reg, db->io_addr);\n\twriteb(value, db->io_data);\n}\n\nstatic void\ndm9000_reset(struct board_info *db)\n{\n\tdev_dbg(db->dev, \"resetting device\\n\");\n\n\t \n\tiow(db, DM9000_NCR, NCR_RST | NCR_MAC_LBK);\n\tudelay(100);  \n\tif (ior(db, DM9000_NCR) & 1)\n\t\tdev_err(db->dev, \"dm9000 did not respond to first reset\\n\");\n\n\tiow(db, DM9000_NCR, 0);\n\tiow(db, DM9000_NCR, NCR_RST | NCR_MAC_LBK);\n\tudelay(100);\n\tif (ior(db, DM9000_NCR) & 1)\n\t\tdev_err(db->dev, \"dm9000 did not respond to second reset\\n\");\n}\n\n \n\nstatic void dm9000_outblk_8bit(void __iomem *reg, void *data, int count)\n{\n\tiowrite8_rep(reg, data, count);\n}\n\nstatic void dm9000_outblk_16bit(void __iomem *reg, void *data, int count)\n{\n\tiowrite16_rep(reg, data, (count+1) >> 1);\n}\n\nstatic void dm9000_outblk_32bit(void __iomem *reg, void *data, int count)\n{\n\tiowrite32_rep(reg, data, (count+3) >> 2);\n}\n\n \n\nstatic void dm9000_inblk_8bit(void __iomem *reg, void *data, int count)\n{\n\tioread8_rep(reg, data, count);\n}\n\n\nstatic void dm9000_inblk_16bit(void __iomem *reg, void *data, int count)\n{\n\tioread16_rep(reg, data, (count+1) >> 1);\n}\n\nstatic void dm9000_inblk_32bit(void __iomem *reg, void *data, int count)\n{\n\tioread32_rep(reg, data, (count+3) >> 2);\n}\n\n \n\nstatic void dm9000_dumpblk_8bit(void __iomem *reg, int count)\n{\n\tint i;\n\n\tfor (i = 0; i < count; i++)\n\t\treadb(reg);\n}\n\nstatic void dm9000_dumpblk_16bit(void __iomem *reg, int count)\n{\n\tint i;\n\n\tcount = (count + 1) >> 1;\n\n\tfor (i = 0; i < count; i++)\n\t\treadw(reg);\n}\n\nstatic void dm9000_dumpblk_32bit(void __iomem *reg, int count)\n{\n\tint i;\n\n\tcount = (count + 3) >> 2;\n\n\tfor (i = 0; i < count; i++)\n\t\treadl(reg);\n}\n\n \nstatic void dm9000_msleep(struct board_info *db, unsigned int ms)\n{\n\tif (db->in_suspend || db->in_timeout)\n\t\tmdelay(ms);\n\telse\n\t\tmsleep(ms);\n}\n\n \nstatic int\ndm9000_phy_read(struct net_device *dev, int phy_reg_unused, int reg)\n{\n\tstruct board_info *db = netdev_priv(dev);\n\tunsigned long flags;\n\tunsigned int reg_save;\n\tint ret;\n\n\tmutex_lock(&db->addr_lock);\n\n\tspin_lock_irqsave(&db->lock, flags);\n\n\t \n\treg_save = readb(db->io_addr);\n\n\t \n\tiow(db, DM9000_EPAR, DM9000_PHY | reg);\n\n\t \n\tiow(db, DM9000_EPCR, EPCR_ERPRR | EPCR_EPOS);\n\n\twriteb(reg_save, db->io_addr);\n\tspin_unlock_irqrestore(&db->lock, flags);\n\n\tdm9000_msleep(db, 1);\t\t \n\n\tspin_lock_irqsave(&db->lock, flags);\n\treg_save = readb(db->io_addr);\n\n\tiow(db, DM9000_EPCR, 0x0);\t \n\n\t \n\tret = (ior(db, DM9000_EPDRH) << 8) | ior(db, DM9000_EPDRL);\n\n\t \n\twriteb(reg_save, db->io_addr);\n\tspin_unlock_irqrestore(&db->lock, flags);\n\n\tmutex_unlock(&db->addr_lock);\n\n\tdm9000_dbg(db, 5, \"phy_read[%02x] -> %04x\\n\", reg, ret);\n\treturn ret;\n}\n\n \nstatic void\ndm9000_phy_write(struct net_device *dev,\n\t\t int phyaddr_unused, int reg, int value)\n{\n\tstruct board_info *db = netdev_priv(dev);\n\tunsigned long flags;\n\tunsigned long reg_save;\n\n\tdm9000_dbg(db, 5, \"phy_write[%02x] = %04x\\n\", reg, value);\n\tif (!db->in_timeout)\n\t\tmutex_lock(&db->addr_lock);\n\n\tspin_lock_irqsave(&db->lock, flags);\n\n\t \n\treg_save = readb(db->io_addr);\n\n\t \n\tiow(db, DM9000_EPAR, DM9000_PHY | reg);\n\n\t \n\tiow(db, DM9000_EPDRL, value);\n\tiow(db, DM9000_EPDRH, value >> 8);\n\n\t \n\tiow(db, DM9000_EPCR, EPCR_EPOS | EPCR_ERPRW);\n\n\twriteb(reg_save, db->io_addr);\n\tspin_unlock_irqrestore(&db->lock, flags);\n\n\tdm9000_msleep(db, 1);\t\t \n\n\tspin_lock_irqsave(&db->lock, flags);\n\treg_save = readb(db->io_addr);\n\n\tiow(db, DM9000_EPCR, 0x0);\t \n\n\t \n\twriteb(reg_save, db->io_addr);\n\n\tspin_unlock_irqrestore(&db->lock, flags);\n\tif (!db->in_timeout)\n\t\tmutex_unlock(&db->addr_lock);\n}\n\n \n\nstatic void dm9000_set_io(struct board_info *db, int byte_width)\n{\n\t \n\n\tswitch (byte_width) {\n\tcase 1:\n\t\tdb->dumpblk = dm9000_dumpblk_8bit;\n\t\tdb->outblk  = dm9000_outblk_8bit;\n\t\tdb->inblk   = dm9000_inblk_8bit;\n\t\tbreak;\n\n\n\tcase 3:\n\t\tdev_dbg(db->dev, \": 3 byte IO, falling back to 16bit\\n\");\n\t\tfallthrough;\n\tcase 2:\n\t\tdb->dumpblk = dm9000_dumpblk_16bit;\n\t\tdb->outblk  = dm9000_outblk_16bit;\n\t\tdb->inblk   = dm9000_inblk_16bit;\n\t\tbreak;\n\n\tcase 4:\n\tdefault:\n\t\tdb->dumpblk = dm9000_dumpblk_32bit;\n\t\tdb->outblk  = dm9000_outblk_32bit;\n\t\tdb->inblk   = dm9000_inblk_32bit;\n\t\tbreak;\n\t}\n}\n\nstatic void dm9000_schedule_poll(struct board_info *db)\n{\n\tif (db->type == TYPE_DM9000E)\n\t\tschedule_delayed_work(&db->phy_poll, HZ * 2);\n}\n\nstatic int dm9000_ioctl(struct net_device *dev, struct ifreq *req, int cmd)\n{\n\tstruct board_info *dm = to_dm9000_board(dev);\n\n\tif (!netif_running(dev))\n\t\treturn -EINVAL;\n\n\treturn generic_mii_ioctl(&dm->mii, if_mii(req), cmd, NULL);\n}\n\nstatic unsigned int\ndm9000_read_locked(struct board_info *db, int reg)\n{\n\tunsigned long flags;\n\tunsigned int ret;\n\n\tspin_lock_irqsave(&db->lock, flags);\n\tret = ior(db, reg);\n\tspin_unlock_irqrestore(&db->lock, flags);\n\n\treturn ret;\n}\n\nstatic int dm9000_wait_eeprom(struct board_info *db)\n{\n\tunsigned int status;\n\tint timeout = 8;\t \n\n\t \n\n\twhile (1) {\n\t\tstatus = dm9000_read_locked(db, DM9000_EPCR);\n\n\t\tif ((status & EPCR_ERRE) == 0)\n\t\t\tbreak;\n\n\t\tmsleep(1);\n\n\t\tif (timeout-- < 0) {\n\t\t\tdev_dbg(db->dev, \"timeout waiting EEPROM\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic void\ndm9000_read_eeprom(struct board_info *db, int offset, u8 *to)\n{\n\tunsigned long flags;\n\n\tif (db->flags & DM9000_PLATF_NO_EEPROM) {\n\t\tto[0] = 0xff;\n\t\tto[1] = 0xff;\n\t\treturn;\n\t}\n\n\tmutex_lock(&db->addr_lock);\n\n\tspin_lock_irqsave(&db->lock, flags);\n\n\tiow(db, DM9000_EPAR, offset);\n\tiow(db, DM9000_EPCR, EPCR_ERPRR);\n\n\tspin_unlock_irqrestore(&db->lock, flags);\n\n\tdm9000_wait_eeprom(db);\n\n\t \n\tmsleep(1);\n\n\tspin_lock_irqsave(&db->lock, flags);\n\n\tiow(db, DM9000_EPCR, 0x0);\n\n\tto[0] = ior(db, DM9000_EPDRL);\n\tto[1] = ior(db, DM9000_EPDRH);\n\n\tspin_unlock_irqrestore(&db->lock, flags);\n\n\tmutex_unlock(&db->addr_lock);\n}\n\n \nstatic void\ndm9000_write_eeprom(struct board_info *db, int offset, u8 *data)\n{\n\tunsigned long flags;\n\n\tif (db->flags & DM9000_PLATF_NO_EEPROM)\n\t\treturn;\n\n\tmutex_lock(&db->addr_lock);\n\n\tspin_lock_irqsave(&db->lock, flags);\n\tiow(db, DM9000_EPAR, offset);\n\tiow(db, DM9000_EPDRH, data[1]);\n\tiow(db, DM9000_EPDRL, data[0]);\n\tiow(db, DM9000_EPCR, EPCR_WEP | EPCR_ERPRW);\n\tspin_unlock_irqrestore(&db->lock, flags);\n\n\tdm9000_wait_eeprom(db);\n\n\tmdelay(1);\t \n\n\tspin_lock_irqsave(&db->lock, flags);\n\tiow(db, DM9000_EPCR, 0);\n\tspin_unlock_irqrestore(&db->lock, flags);\n\n\tmutex_unlock(&db->addr_lock);\n}\n\n \n\nstatic void dm9000_get_drvinfo(struct net_device *dev,\n\t\t\t       struct ethtool_drvinfo *info)\n{\n\tstruct board_info *dm = to_dm9000_board(dev);\n\n\tstrscpy(info->driver, CARDNAME, sizeof(info->driver));\n\tstrscpy(info->bus_info, to_platform_device(dm->dev)->name,\n\t\tsizeof(info->bus_info));\n}\n\nstatic u32 dm9000_get_msglevel(struct net_device *dev)\n{\n\tstruct board_info *dm = to_dm9000_board(dev);\n\n\treturn dm->msg_enable;\n}\n\nstatic void dm9000_set_msglevel(struct net_device *dev, u32 value)\n{\n\tstruct board_info *dm = to_dm9000_board(dev);\n\n\tdm->msg_enable = value;\n}\n\nstatic int dm9000_get_link_ksettings(struct net_device *dev,\n\t\t\t\t     struct ethtool_link_ksettings *cmd)\n{\n\tstruct board_info *dm = to_dm9000_board(dev);\n\n\tmii_ethtool_get_link_ksettings(&dm->mii, cmd);\n\treturn 0;\n}\n\nstatic int dm9000_set_link_ksettings(struct net_device *dev,\n\t\t\t\t     const struct ethtool_link_ksettings *cmd)\n{\n\tstruct board_info *dm = to_dm9000_board(dev);\n\n\treturn mii_ethtool_set_link_ksettings(&dm->mii, cmd);\n}\n\nstatic int dm9000_nway_reset(struct net_device *dev)\n{\n\tstruct board_info *dm = to_dm9000_board(dev);\n\treturn mii_nway_restart(&dm->mii);\n}\n\nstatic int dm9000_set_features(struct net_device *dev,\n\tnetdev_features_t features)\n{\n\tstruct board_info *dm = to_dm9000_board(dev);\n\tnetdev_features_t changed = dev->features ^ features;\n\tunsigned long flags;\n\n\tif (!(changed & NETIF_F_RXCSUM))\n\t\treturn 0;\n\n\tspin_lock_irqsave(&dm->lock, flags);\n\tiow(dm, DM9000_RCSR, (features & NETIF_F_RXCSUM) ? RCSR_CSUM : 0);\n\tspin_unlock_irqrestore(&dm->lock, flags);\n\n\treturn 0;\n}\n\nstatic u32 dm9000_get_link(struct net_device *dev)\n{\n\tstruct board_info *dm = to_dm9000_board(dev);\n\tu32 ret;\n\n\tif (dm->flags & DM9000_PLATF_EXT_PHY)\n\t\tret = mii_link_ok(&dm->mii);\n\telse\n\t\tret = dm9000_read_locked(dm, DM9000_NSR) & NSR_LINKST ? 1 : 0;\n\n\treturn ret;\n}\n\n#define DM_EEPROM_MAGIC\t\t(0x444D394B)\n\nstatic int dm9000_get_eeprom_len(struct net_device *dev)\n{\n\treturn 128;\n}\n\nstatic int dm9000_get_eeprom(struct net_device *dev,\n\t\t\t     struct ethtool_eeprom *ee, u8 *data)\n{\n\tstruct board_info *dm = to_dm9000_board(dev);\n\tint offset = ee->offset;\n\tint len = ee->len;\n\tint i;\n\n\t \n\n\tif ((len & 1) != 0 || (offset & 1) != 0)\n\t\treturn -EINVAL;\n\n\tif (dm->flags & DM9000_PLATF_NO_EEPROM)\n\t\treturn -ENOENT;\n\n\tee->magic = DM_EEPROM_MAGIC;\n\n\tfor (i = 0; i < len; i += 2)\n\t\tdm9000_read_eeprom(dm, (offset + i) / 2, data + i);\n\n\treturn 0;\n}\n\nstatic int dm9000_set_eeprom(struct net_device *dev,\n\t\t\t     struct ethtool_eeprom *ee, u8 *data)\n{\n\tstruct board_info *dm = to_dm9000_board(dev);\n\tint offset = ee->offset;\n\tint len = ee->len;\n\tint done;\n\n\t \n\n\tif (dm->flags & DM9000_PLATF_NO_EEPROM)\n\t\treturn -ENOENT;\n\n\tif (ee->magic != DM_EEPROM_MAGIC)\n\t\treturn -EINVAL;\n\n\twhile (len > 0) {\n\t\tif (len & 1 || offset & 1) {\n\t\t\tint which = offset & 1;\n\t\t\tu8 tmp[2];\n\n\t\t\tdm9000_read_eeprom(dm, offset / 2, tmp);\n\t\t\ttmp[which] = *data;\n\t\t\tdm9000_write_eeprom(dm, offset / 2, tmp);\n\n\t\t\tdone = 1;\n\t\t} else {\n\t\t\tdm9000_write_eeprom(dm, offset / 2, data);\n\t\t\tdone = 2;\n\t\t}\n\n\t\tdata += done;\n\t\toffset += done;\n\t\tlen -= done;\n\t}\n\n\treturn 0;\n}\n\nstatic void dm9000_get_wol(struct net_device *dev, struct ethtool_wolinfo *w)\n{\n\tstruct board_info *dm = to_dm9000_board(dev);\n\n\tmemset(w, 0, sizeof(struct ethtool_wolinfo));\n\n\t \n\tw->supported = dm->wake_supported ? WAKE_MAGIC : 0;\n\tw->wolopts = dm->wake_state;\n}\n\nstatic int dm9000_set_wol(struct net_device *dev, struct ethtool_wolinfo *w)\n{\n\tstruct board_info *dm = to_dm9000_board(dev);\n\tunsigned long flags;\n\tu32 opts = w->wolopts;\n\tu32 wcr = 0;\n\n\tif (!dm->wake_supported)\n\t\treturn -EOPNOTSUPP;\n\n\tif (opts & ~WAKE_MAGIC)\n\t\treturn -EINVAL;\n\n\tif (opts & WAKE_MAGIC)\n\t\twcr |= WCR_MAGICEN;\n\n\tmutex_lock(&dm->addr_lock);\n\n\tspin_lock_irqsave(&dm->lock, flags);\n\tiow(dm, DM9000_WCR, wcr);\n\tspin_unlock_irqrestore(&dm->lock, flags);\n\n\tmutex_unlock(&dm->addr_lock);\n\n\tif (dm->wake_state != opts) {\n\t\t \n\n\t\tif (!dm->wake_state)\n\t\t\tirq_set_irq_wake(dm->irq_wake, 1);\n\t\telse if (dm->wake_state && !opts)\n\t\t\tirq_set_irq_wake(dm->irq_wake, 0);\n\t}\n\n\tdm->wake_state = opts;\n\treturn 0;\n}\n\nstatic const struct ethtool_ops dm9000_ethtool_ops = {\n\t.get_drvinfo\t\t= dm9000_get_drvinfo,\n\t.get_msglevel\t\t= dm9000_get_msglevel,\n\t.set_msglevel\t\t= dm9000_set_msglevel,\n\t.nway_reset\t\t= dm9000_nway_reset,\n\t.get_link\t\t= dm9000_get_link,\n\t.get_wol\t\t= dm9000_get_wol,\n\t.set_wol\t\t= dm9000_set_wol,\n\t.get_eeprom_len\t\t= dm9000_get_eeprom_len,\n\t.get_eeprom\t\t= dm9000_get_eeprom,\n\t.set_eeprom\t\t= dm9000_set_eeprom,\n\t.get_link_ksettings\t= dm9000_get_link_ksettings,\n\t.set_link_ksettings\t= dm9000_set_link_ksettings,\n};\n\nstatic void dm9000_show_carrier(struct board_info *db,\n\t\t\t\tunsigned carrier, unsigned nsr)\n{\n\tint lpa;\n\tstruct net_device *ndev = db->ndev;\n\tstruct mii_if_info *mii = &db->mii;\n\tunsigned ncr = dm9000_read_locked(db, DM9000_NCR);\n\n\tif (carrier) {\n\t\tlpa = mii->mdio_read(mii->dev, mii->phy_id, MII_LPA);\n\t\tdev_info(db->dev,\n\t\t\t \"%s: link up, %dMbps, %s-duplex, lpa 0x%04X\\n\",\n\t\t\t ndev->name, (nsr & NSR_SPEED) ? 10 : 100,\n\t\t\t (ncr & NCR_FDX) ? \"full\" : \"half\", lpa);\n\t} else {\n\t\tdev_info(db->dev, \"%s: link down\\n\", ndev->name);\n\t}\n}\n\nstatic void\ndm9000_poll_work(struct work_struct *w)\n{\n\tstruct delayed_work *dw = to_delayed_work(w);\n\tstruct board_info *db = container_of(dw, struct board_info, phy_poll);\n\tstruct net_device *ndev = db->ndev;\n\n\tif (db->flags & DM9000_PLATF_SIMPLE_PHY &&\n\t    !(db->flags & DM9000_PLATF_EXT_PHY)) {\n\t\tunsigned nsr = dm9000_read_locked(db, DM9000_NSR);\n\t\tunsigned old_carrier = netif_carrier_ok(ndev) ? 1 : 0;\n\t\tunsigned new_carrier;\n\n\t\tnew_carrier = (nsr & NSR_LINKST) ? 1 : 0;\n\n\t\tif (old_carrier != new_carrier) {\n\t\t\tif (netif_msg_link(db))\n\t\t\t\tdm9000_show_carrier(db, new_carrier, nsr);\n\n\t\t\tif (!new_carrier)\n\t\t\t\tnetif_carrier_off(ndev);\n\t\t\telse\n\t\t\t\tnetif_carrier_on(ndev);\n\t\t}\n\t} else\n\t\tmii_check_media(&db->mii, netif_msg_link(db), 0);\n\n\tif (netif_running(ndev))\n\t\tdm9000_schedule_poll(db);\n}\n\n \n\nstatic void\ndm9000_release_board(struct platform_device *pdev, struct board_info *db)\n{\n\t \n\n\tiounmap(db->io_addr);\n\tiounmap(db->io_data);\n\n\t \n\n\tif (db->data_req)\n\t\trelease_resource(db->data_req);\n\tkfree(db->data_req);\n\n\tif (db->addr_req)\n\t\trelease_resource(db->addr_req);\n\tkfree(db->addr_req);\n}\n\nstatic unsigned char dm9000_type_to_char(enum dm9000_type type)\n{\n\tswitch (type) {\n\tcase TYPE_DM9000E: return 'e';\n\tcase TYPE_DM9000A: return 'a';\n\tcase TYPE_DM9000B: return 'b';\n\t}\n\n\treturn '?';\n}\n\n \nstatic void\ndm9000_hash_table_unlocked(struct net_device *dev)\n{\n\tstruct board_info *db = netdev_priv(dev);\n\tstruct netdev_hw_addr *ha;\n\tint i, oft;\n\tu32 hash_val;\n\tu16 hash_table[4] = { 0, 0, 0, 0x8000 };  \n\tu8 rcr = RCR_DIS_LONG | RCR_DIS_CRC | RCR_RXEN;\n\n\tdm9000_dbg(db, 1, \"entering %s\\n\", __func__);\n\n\tfor (i = 0, oft = DM9000_PAR; i < 6; i++, oft++)\n\t\tiow(db, oft, dev->dev_addr[i]);\n\n\tif (dev->flags & IFF_PROMISC)\n\t\trcr |= RCR_PRMSC;\n\n\tif (dev->flags & IFF_ALLMULTI)\n\t\trcr |= RCR_ALL;\n\n\t \n\tnetdev_for_each_mc_addr(ha, dev) {\n\t\thash_val = ether_crc_le(6, ha->addr) & 0x3f;\n\t\thash_table[hash_val / 16] |= (u16) 1 << (hash_val % 16);\n\t}\n\n\t \n\tfor (i = 0, oft = DM9000_MAR; i < 4; i++) {\n\t\tiow(db, oft++, hash_table[i]);\n\t\tiow(db, oft++, hash_table[i] >> 8);\n\t}\n\n\tiow(db, DM9000_RCR, rcr);\n}\n\nstatic void\ndm9000_hash_table(struct net_device *dev)\n{\n\tstruct board_info *db = netdev_priv(dev);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&db->lock, flags);\n\tdm9000_hash_table_unlocked(dev);\n\tspin_unlock_irqrestore(&db->lock, flags);\n}\n\nstatic void\ndm9000_mask_interrupts(struct board_info *db)\n{\n\tiow(db, DM9000_IMR, IMR_PAR);\n}\n\nstatic void\ndm9000_unmask_interrupts(struct board_info *db)\n{\n\tiow(db, DM9000_IMR, db->imr_all);\n}\n\n \nstatic void\ndm9000_init_dm9000(struct net_device *dev)\n{\n\tstruct board_info *db = netdev_priv(dev);\n\tunsigned int imr;\n\tunsigned int ncr;\n\n\tdm9000_dbg(db, 1, \"entering %s\\n\", __func__);\n\n\tdm9000_reset(db);\n\tdm9000_mask_interrupts(db);\n\n\t \n\tdb->io_mode = ior(db, DM9000_ISR) >> 6;\t \n\n\t \n\tif (dev->hw_features & NETIF_F_RXCSUM)\n\t\tiow(db, DM9000_RCSR,\n\t\t\t(dev->features & NETIF_F_RXCSUM) ? RCSR_CSUM : 0);\n\n\tiow(db, DM9000_GPCR, GPCR_GEP_CNTL);\t \n\tiow(db, DM9000_GPR, 0);\n\n\t \n\tif (db->type == TYPE_DM9000B) {\n\t\tdm9000_phy_write(dev, 0, MII_BMCR, BMCR_RESET);\n\t\tdm9000_phy_write(dev, 0, MII_DM_DSPCR, DSPCR_INIT_PARAM);\n\t}\n\n\tncr = (db->flags & DM9000_PLATF_EXT_PHY) ? NCR_EXT_PHY : 0;\n\n\t \n\tif (db->wake_supported)\n\t\tncr |= NCR_WAKEEN;\n\n\tiow(db, DM9000_NCR, ncr);\n\n\t \n\tiow(db, DM9000_TCR, 0);\t         \n\tiow(db, DM9000_BPTR, 0x3f);\t \n\tiow(db, DM9000_FCR, 0xff);\t \n\tiow(db, DM9000_SMCR, 0);         \n\t \n\tiow(db, DM9000_NSR, NSR_WAKEST | NSR_TX2END | NSR_TX1END);\n\tiow(db, DM9000_ISR, ISR_CLR_STATUS);  \n\n\t \n\tdm9000_hash_table_unlocked(dev);\n\n\timr = IMR_PAR | IMR_PTM | IMR_PRM;\n\tif (db->type != TYPE_DM9000E)\n\t\timr |= IMR_LNKCHNG;\n\n\tdb->imr_all = imr;\n\n\t \n\tdb->tx_pkt_cnt = 0;\n\tdb->queue_pkt_len = 0;\n\tnetif_trans_update(dev);\n}\n\n \nstatic void dm9000_timeout(struct net_device *dev, unsigned int txqueue)\n{\n\tstruct board_info *db = netdev_priv(dev);\n\tu8 reg_save;\n\tunsigned long flags;\n\n\t \n\tspin_lock_irqsave(&db->lock, flags);\n\tdb->in_timeout = 1;\n\treg_save = readb(db->io_addr);\n\n\tnetif_stop_queue(dev);\n\tdm9000_init_dm9000(dev);\n\tdm9000_unmask_interrupts(db);\n\t \n\tnetif_trans_update(dev);  \n\tnetif_wake_queue(dev);\n\n\t \n\twriteb(reg_save, db->io_addr);\n\tdb->in_timeout = 0;\n\tspin_unlock_irqrestore(&db->lock, flags);\n}\n\nstatic void dm9000_send_packet(struct net_device *dev,\n\t\t\t       int ip_summed,\n\t\t\t       u16 pkt_len)\n{\n\tstruct board_info *dm = to_dm9000_board(dev);\n\n\t \n\tif (dm->ip_summed != ip_summed) {\n\t\tif (ip_summed == CHECKSUM_NONE)\n\t\t\tiow(dm, DM9000_TCCR, 0);\n\t\telse\n\t\t\tiow(dm, DM9000_TCCR, TCCR_IP | TCCR_UDP | TCCR_TCP);\n\t\tdm->ip_summed = ip_summed;\n\t}\n\n\t \n\tiow(dm, DM9000_TXPLL, pkt_len);\n\tiow(dm, DM9000_TXPLH, pkt_len >> 8);\n\n\t \n\tiow(dm, DM9000_TCR, TCR_TXREQ);\t \n}\n\n \nstatic netdev_tx_t\ndm9000_start_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tunsigned long flags;\n\tstruct board_info *db = netdev_priv(dev);\n\n\tdm9000_dbg(db, 3, \"%s:\\n\", __func__);\n\n\tif (db->tx_pkt_cnt > 1)\n\t\treturn NETDEV_TX_BUSY;\n\n\tspin_lock_irqsave(&db->lock, flags);\n\n\t \n\twriteb(DM9000_MWCMD, db->io_addr);\n\n\t(db->outblk)(db->io_data, skb->data, skb->len);\n\tdev->stats.tx_bytes += skb->len;\n\n\tdb->tx_pkt_cnt++;\n\t \n\tif (db->tx_pkt_cnt == 1) {\n\t\tdm9000_send_packet(dev, skb->ip_summed, skb->len);\n\t} else {\n\t\t \n\t\tdb->queue_pkt_len = skb->len;\n\t\tdb->queue_ip_summed = skb->ip_summed;\n\t\tnetif_stop_queue(dev);\n\t}\n\n\tspin_unlock_irqrestore(&db->lock, flags);\n\n\t \n\tdev_consume_skb_any(skb);\n\n\treturn NETDEV_TX_OK;\n}\n\n \n\nstatic void dm9000_tx_done(struct net_device *dev, struct board_info *db)\n{\n\tint tx_status = ior(db, DM9000_NSR);\t \n\n\tif (tx_status & (NSR_TX2END | NSR_TX1END)) {\n\t\t \n\t\tdb->tx_pkt_cnt--;\n\t\tdev->stats.tx_packets++;\n\n\t\tif (netif_msg_tx_done(db))\n\t\t\tdev_dbg(db->dev, \"tx done, NSR %02x\\n\", tx_status);\n\n\t\t \n\t\tif (db->tx_pkt_cnt > 0)\n\t\t\tdm9000_send_packet(dev, db->queue_ip_summed,\n\t\t\t\t\t   db->queue_pkt_len);\n\t\tnetif_wake_queue(dev);\n\t}\n}\n\nstruct dm9000_rxhdr {\n\tu8\tRxPktReady;\n\tu8\tRxStatus;\n\t__le16\tRxLen;\n} __packed;\n\n \nstatic void\ndm9000_rx(struct net_device *dev)\n{\n\tstruct board_info *db = netdev_priv(dev);\n\tstruct dm9000_rxhdr rxhdr;\n\tstruct sk_buff *skb;\n\tu8 rxbyte, *rdptr;\n\tbool GoodPacket;\n\tint RxLen;\n\n\t \n\tdo {\n\t\tior(db, DM9000_MRCMDX);\t \n\n\t\t \n\t\trxbyte = readb(db->io_data);\n\n\t\t \n\t\tif (rxbyte & DM9000_PKT_ERR) {\n\t\t\tdev_warn(db->dev, \"status check fail: %d\\n\", rxbyte);\n\t\t\tiow(db, DM9000_RCR, 0x00);\t \n\t\t\treturn;\n\t\t}\n\n\t\tif (!(rxbyte & DM9000_PKT_RDY))\n\t\t\treturn;\n\n\t\t \n\t\tGoodPacket = true;\n\t\twriteb(DM9000_MRCMD, db->io_addr);\n\n\t\t(db->inblk)(db->io_data, &rxhdr, sizeof(rxhdr));\n\n\t\tRxLen = le16_to_cpu(rxhdr.RxLen);\n\n\t\tif (netif_msg_rx_status(db))\n\t\t\tdev_dbg(db->dev, \"RX: status %02x, length %04x\\n\",\n\t\t\t\trxhdr.RxStatus, RxLen);\n\n\t\t \n\t\tif (RxLen < 0x40) {\n\t\t\tGoodPacket = false;\n\t\t\tif (netif_msg_rx_err(db))\n\t\t\t\tdev_dbg(db->dev, \"RX: Bad Packet (runt)\\n\");\n\t\t}\n\n\t\tif (RxLen > DM9000_PKT_MAX) {\n\t\t\tdev_dbg(db->dev, \"RST: RX Len:%x\\n\", RxLen);\n\t\t}\n\n\t\t \n\t\tif (rxhdr.RxStatus & (RSR_FOE | RSR_CE | RSR_AE |\n\t\t\t\t      RSR_PLE | RSR_RWTO |\n\t\t\t\t      RSR_LCS | RSR_RF)) {\n\t\t\tGoodPacket = false;\n\t\t\tif (rxhdr.RxStatus & RSR_FOE) {\n\t\t\t\tif (netif_msg_rx_err(db))\n\t\t\t\t\tdev_dbg(db->dev, \"fifo error\\n\");\n\t\t\t\tdev->stats.rx_fifo_errors++;\n\t\t\t}\n\t\t\tif (rxhdr.RxStatus & RSR_CE) {\n\t\t\t\tif (netif_msg_rx_err(db))\n\t\t\t\t\tdev_dbg(db->dev, \"crc error\\n\");\n\t\t\t\tdev->stats.rx_crc_errors++;\n\t\t\t}\n\t\t\tif (rxhdr.RxStatus & RSR_RF) {\n\t\t\t\tif (netif_msg_rx_err(db))\n\t\t\t\t\tdev_dbg(db->dev, \"length error\\n\");\n\t\t\t\tdev->stats.rx_length_errors++;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (GoodPacket &&\n\t\t    ((skb = netdev_alloc_skb(dev, RxLen + 4)) != NULL)) {\n\t\t\tskb_reserve(skb, 2);\n\t\t\trdptr = skb_put(skb, RxLen - 4);\n\n\t\t\t \n\n\t\t\t(db->inblk)(db->io_data, rdptr, RxLen);\n\t\t\tdev->stats.rx_bytes += RxLen;\n\n\t\t\t \n\t\t\tskb->protocol = eth_type_trans(skb, dev);\n\t\t\tif (dev->features & NETIF_F_RXCSUM) {\n\t\t\t\tif ((((rxbyte & 0x1c) << 3) & rxbyte) == 0)\n\t\t\t\t\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\t\t\t\telse\n\t\t\t\t\tskb_checksum_none_assert(skb);\n\t\t\t}\n\t\t\tnetif_rx(skb);\n\t\t\tdev->stats.rx_packets++;\n\n\t\t} else {\n\t\t\t \n\n\t\t\t(db->dumpblk)(db->io_data, RxLen);\n\t\t}\n\t} while (rxbyte & DM9000_PKT_RDY);\n}\n\nstatic irqreturn_t dm9000_interrupt(int irq, void *dev_id)\n{\n\tstruct net_device *dev = dev_id;\n\tstruct board_info *db = netdev_priv(dev);\n\tint int_status;\n\tunsigned long flags;\n\tu8 reg_save;\n\n\tdm9000_dbg(db, 3, \"entering %s\\n\", __func__);\n\n\t \n\n\t \n\tspin_lock_irqsave(&db->lock, flags);\n\n\t \n\treg_save = readb(db->io_addr);\n\n\tdm9000_mask_interrupts(db);\n\t \n\tint_status = ior(db, DM9000_ISR);\t \n\tiow(db, DM9000_ISR, int_status);\t \n\n\tif (netif_msg_intr(db))\n\t\tdev_dbg(db->dev, \"interrupt status %02x\\n\", int_status);\n\n\t \n\tif (int_status & ISR_PRS)\n\t\tdm9000_rx(dev);\n\n\t \n\tif (int_status & ISR_PTS)\n\t\tdm9000_tx_done(dev, db);\n\n\tif (db->type != TYPE_DM9000E) {\n\t\tif (int_status & ISR_LNKCHNG) {\n\t\t\t \n\t\t\tschedule_delayed_work(&db->phy_poll, 1);\n\t\t}\n\t}\n\n\tdm9000_unmask_interrupts(db);\n\t \n\twriteb(reg_save, db->io_addr);\n\n\tspin_unlock_irqrestore(&db->lock, flags);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t dm9000_wol_interrupt(int irq, void *dev_id)\n{\n\tstruct net_device *dev = dev_id;\n\tstruct board_info *db = netdev_priv(dev);\n\tunsigned long flags;\n\tunsigned nsr, wcr;\n\n\tspin_lock_irqsave(&db->lock, flags);\n\n\tnsr = ior(db, DM9000_NSR);\n\twcr = ior(db, DM9000_WCR);\n\n\tdev_dbg(db->dev, \"%s: NSR=0x%02x, WCR=0x%02x\\n\", __func__, nsr, wcr);\n\n\tif (nsr & NSR_WAKEST) {\n\t\t \n\t\tiow(db, DM9000_NSR, NSR_WAKEST);\n\n\t\tif (wcr & WCR_LINKST)\n\t\t\tdev_info(db->dev, \"wake by link status change\\n\");\n\t\tif (wcr & WCR_SAMPLEST)\n\t\t\tdev_info(db->dev, \"wake by sample packet\\n\");\n\t\tif (wcr & WCR_MAGICST)\n\t\t\tdev_info(db->dev, \"wake by magic packet\\n\");\n\t\tif (!(wcr & (WCR_LINKST | WCR_SAMPLEST | WCR_MAGICST)))\n\t\t\tdev_err(db->dev, \"wake signalled with no reason? \"\n\t\t\t\t\"NSR=0x%02x, WSR=0x%02x\\n\", nsr, wcr);\n\t}\n\n\tspin_unlock_irqrestore(&db->lock, flags);\n\n\treturn (nsr & NSR_WAKEST) ? IRQ_HANDLED : IRQ_NONE;\n}\n\n#ifdef CONFIG_NET_POLL_CONTROLLER\n \nstatic void dm9000_poll_controller(struct net_device *dev)\n{\n\tdisable_irq(dev->irq);\n\tdm9000_interrupt(dev->irq, dev);\n\tenable_irq(dev->irq);\n}\n#endif\n\n \nstatic int\ndm9000_open(struct net_device *dev)\n{\n\tstruct board_info *db = netdev_priv(dev);\n\tunsigned int irq_flags = irq_get_trigger_type(dev->irq);\n\n\tif (netif_msg_ifup(db))\n\t\tdev_dbg(db->dev, \"enabling %s\\n\", dev->name);\n\n\t \n\tif (irq_flags == IRQF_TRIGGER_NONE)\n\t\tdev_warn(db->dev, \"WARNING: no IRQ resource flags set.\\n\");\n\n\tirq_flags |= IRQF_SHARED;\n\n\t \n\tiow(db, DM9000_GPR, 0);\t \n\tmdelay(1);  \n\n\t \n\tdm9000_init_dm9000(dev);\n\n\tif (request_irq(dev->irq, dm9000_interrupt, irq_flags, dev->name, dev))\n\t\treturn -EAGAIN;\n\t \n\tdm9000_unmask_interrupts(db);\n\n\t \n\tdb->dbug_cnt = 0;\n\n\tmii_check_media(&db->mii, netif_msg_link(db), 1);\n\tnetif_start_queue(dev);\n\n\t \n\tschedule_delayed_work(&db->phy_poll, 1);\n\n\treturn 0;\n}\n\nstatic void\ndm9000_shutdown(struct net_device *dev)\n{\n\tstruct board_info *db = netdev_priv(dev);\n\n\t \n\tdm9000_phy_write(dev, 0, MII_BMCR, BMCR_RESET);\t \n\tiow(db, DM9000_GPR, 0x01);\t \n\tdm9000_mask_interrupts(db);\n\tiow(db, DM9000_RCR, 0x00);\t \n}\n\n \nstatic int\ndm9000_stop(struct net_device *ndev)\n{\n\tstruct board_info *db = netdev_priv(ndev);\n\n\tif (netif_msg_ifdown(db))\n\t\tdev_dbg(db->dev, \"shutting down %s\\n\", ndev->name);\n\n\tcancel_delayed_work_sync(&db->phy_poll);\n\n\tnetif_stop_queue(ndev);\n\tnetif_carrier_off(ndev);\n\n\t \n\tfree_irq(ndev->irq, ndev);\n\n\tdm9000_shutdown(ndev);\n\n\treturn 0;\n}\n\nstatic const struct net_device_ops dm9000_netdev_ops = {\n\t.ndo_open\t\t= dm9000_open,\n\t.ndo_stop\t\t= dm9000_stop,\n\t.ndo_start_xmit\t\t= dm9000_start_xmit,\n\t.ndo_tx_timeout\t\t= dm9000_timeout,\n\t.ndo_set_rx_mode\t= dm9000_hash_table,\n\t.ndo_eth_ioctl\t\t= dm9000_ioctl,\n\t.ndo_set_features\t= dm9000_set_features,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_set_mac_address\t= eth_mac_addr,\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\t.ndo_poll_controller\t= dm9000_poll_controller,\n#endif\n};\n\nstatic struct dm9000_plat_data *dm9000_parse_dt(struct device *dev)\n{\n\tstruct dm9000_plat_data *pdata;\n\tstruct device_node *np = dev->of_node;\n\tint ret;\n\n\tif (!IS_ENABLED(CONFIG_OF) || !np)\n\t\treturn ERR_PTR(-ENXIO);\n\n\tpdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);\n\tif (!pdata)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (of_property_read_bool(np, \"davicom,ext-phy\"))\n\t\tpdata->flags |= DM9000_PLATF_EXT_PHY;\n\tif (of_property_read_bool(np, \"davicom,no-eeprom\"))\n\t\tpdata->flags |= DM9000_PLATF_NO_EEPROM;\n\n\tret = of_get_mac_address(np, pdata->dev_addr);\n\tif (ret == -EPROBE_DEFER)\n\t\treturn ERR_PTR(ret);\n\n\treturn pdata;\n}\n\n \nstatic int\ndm9000_probe(struct platform_device *pdev)\n{\n\tstruct dm9000_plat_data *pdata = dev_get_platdata(&pdev->dev);\n\tstruct board_info *db;\t \n\tstruct net_device *ndev;\n\tstruct device *dev = &pdev->dev;\n\tconst unsigned char *mac_src;\n\tint ret = 0;\n\tint iosize;\n\tint i;\n\tu32 id_val;\n\tstruct gpio_desc *reset_gpio;\n\tstruct regulator *power;\n\tbool inv_mac_addr = false;\n\tu8 addr[ETH_ALEN];\n\n\tpower = devm_regulator_get(dev, \"vcc\");\n\tif (IS_ERR(power)) {\n\t\tif (PTR_ERR(power) == -EPROBE_DEFER)\n\t\t\treturn -EPROBE_DEFER;\n\t\tdev_dbg(dev, \"no regulator provided\\n\");\n\t} else {\n\t\tret = regulator_enable(power);\n\t\tif (ret != 0) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"Failed to enable power regulator: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t\tdev_dbg(dev, \"regulator enabled\\n\");\n\t}\n\n\treset_gpio = devm_gpiod_get_optional(dev, \"reset\", GPIOD_OUT_HIGH);\n\tret = PTR_ERR_OR_ZERO(reset_gpio);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to request reset gpio: %d\\n\", ret);\n\t\tgoto out_regulator_disable;\n\t}\n\n\tif (reset_gpio) {\n\t\tret = gpiod_set_consumer_name(reset_gpio, \"dm9000_reset\");\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"failed to set reset gpio name: %d\\n\",\n\t\t\t\tret);\n\t\t\tgoto out_regulator_disable;\n\t\t}\n\n\t\t \n\t\tmsleep(2);\n\t\tgpiod_set_value_cansleep(reset_gpio, 0);\n\t\t \n\t\tmsleep(4);\n\t}\n\n\tif (!pdata) {\n\t\tpdata = dm9000_parse_dt(&pdev->dev);\n\t\tif (IS_ERR(pdata)) {\n\t\t\tret = PTR_ERR(pdata);\n\t\t\tgoto out_regulator_disable;\n\t\t}\n\t}\n\n\t \n\tndev = alloc_etherdev(sizeof(struct board_info));\n\tif (!ndev) {\n\t\tret = -ENOMEM;\n\t\tgoto out_regulator_disable;\n\t}\n\n\tSET_NETDEV_DEV(ndev, &pdev->dev);\n\n\tdev_dbg(&pdev->dev, \"dm9000_probe()\\n\");\n\n\t \n\tdb = netdev_priv(ndev);\n\n\tdb->dev = &pdev->dev;\n\tdb->ndev = ndev;\n\tif (!IS_ERR(power))\n\t\tdb->power_supply = power;\n\n\tspin_lock_init(&db->lock);\n\tmutex_init(&db->addr_lock);\n\n\tINIT_DELAYED_WORK(&db->phy_poll, dm9000_poll_work);\n\n\tdb->addr_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tdb->data_res = platform_get_resource(pdev, IORESOURCE_MEM, 1);\n\n\tif (!db->addr_res || !db->data_res) {\n\t\tdev_err(db->dev, \"insufficient resources addr=%p data=%p\\n\",\n\t\t\tdb->addr_res, db->data_res);\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tndev->irq = platform_get_irq(pdev, 0);\n\tif (ndev->irq < 0) {\n\t\tret = ndev->irq;\n\t\tgoto out;\n\t}\n\n\tdb->irq_wake = platform_get_irq_optional(pdev, 1);\n\tif (db->irq_wake >= 0) {\n\t\tdev_dbg(db->dev, \"wakeup irq %d\\n\", db->irq_wake);\n\n\t\tret = request_irq(db->irq_wake, dm9000_wol_interrupt,\n\t\t\t\t  IRQF_SHARED, dev_name(db->dev), ndev);\n\t\tif (ret) {\n\t\t\tdev_err(db->dev, \"cannot get wakeup irq (%d)\\n\", ret);\n\t\t} else {\n\n\t\t\t \n\t\t\tret = irq_set_irq_wake(db->irq_wake, 1);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(db->dev, \"irq %d cannot set wakeup (%d)\\n\",\n\t\t\t\t\tdb->irq_wake, ret);\n\t\t\t} else {\n\t\t\t\tirq_set_irq_wake(db->irq_wake, 0);\n\t\t\t\tdb->wake_supported = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tiosize = resource_size(db->addr_res);\n\tdb->addr_req = request_mem_region(db->addr_res->start, iosize,\n\t\t\t\t\t  pdev->name);\n\n\tif (db->addr_req == NULL) {\n\t\tdev_err(db->dev, \"cannot claim address reg area\\n\");\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\tdb->io_addr = ioremap(db->addr_res->start, iosize);\n\n\tif (db->io_addr == NULL) {\n\t\tdev_err(db->dev, \"failed to ioremap address reg\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tiosize = resource_size(db->data_res);\n\tdb->data_req = request_mem_region(db->data_res->start, iosize,\n\t\t\t\t\t  pdev->name);\n\n\tif (db->data_req == NULL) {\n\t\tdev_err(db->dev, \"cannot claim data reg area\\n\");\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\tdb->io_data = ioremap(db->data_res->start, iosize);\n\n\tif (db->io_data == NULL) {\n\t\tdev_err(db->dev, \"failed to ioremap data reg\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t \n\tndev->base_addr = (unsigned long)db->io_addr;\n\n\t \n\tdm9000_set_io(db, iosize);\n\n\t \n\tif (pdata != NULL) {\n\t\t \n\n\t\tif (pdata->flags & DM9000_PLATF_8BITONLY)\n\t\t\tdm9000_set_io(db, 1);\n\n\t\tif (pdata->flags & DM9000_PLATF_16BITONLY)\n\t\t\tdm9000_set_io(db, 2);\n\n\t\tif (pdata->flags & DM9000_PLATF_32BITONLY)\n\t\t\tdm9000_set_io(db, 4);\n\n\t\t \n\n\t\tif (pdata->inblk != NULL)\n\t\t\tdb->inblk = pdata->inblk;\n\n\t\tif (pdata->outblk != NULL)\n\t\t\tdb->outblk = pdata->outblk;\n\n\t\tif (pdata->dumpblk != NULL)\n\t\t\tdb->dumpblk = pdata->dumpblk;\n\n\t\tdb->flags = pdata->flags;\n\t}\n\n#ifdef CONFIG_DM9000_FORCE_SIMPLE_PHY_POLL\n\tdb->flags |= DM9000_PLATF_SIMPLE_PHY;\n#endif\n\n\tdm9000_reset(db);\n\n\t \n\tfor (i = 0; i < 8; i++) {\n\t\tid_val  = ior(db, DM9000_VIDL);\n\t\tid_val |= (u32)ior(db, DM9000_VIDH) << 8;\n\t\tid_val |= (u32)ior(db, DM9000_PIDL) << 16;\n\t\tid_val |= (u32)ior(db, DM9000_PIDH) << 24;\n\n\t\tif (id_val == DM9000_ID)\n\t\t\tbreak;\n\t\tdev_err(db->dev, \"read wrong id 0x%08x\\n\", id_val);\n\t}\n\n\tif (id_val != DM9000_ID) {\n\t\tdev_err(db->dev, \"wrong id: 0x%08x\\n\", id_val);\n\t\tret = -ENODEV;\n\t\tgoto out;\n\t}\n\n\t \n\n\tid_val = ior(db, DM9000_CHIPR);\n\tdev_dbg(db->dev, \"dm9000 revision 0x%02x\\n\", id_val);\n\n\tswitch (id_val) {\n\tcase CHIPR_DM9000A:\n\t\tdb->type = TYPE_DM9000A;\n\t\tbreak;\n\tcase CHIPR_DM9000B:\n\t\tdb->type = TYPE_DM9000B;\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(db->dev, \"ID %02x => defaulting to DM9000E\\n\", id_val);\n\t\tdb->type = TYPE_DM9000E;\n\t}\n\n\t \n\tif (db->type == TYPE_DM9000A || db->type == TYPE_DM9000B) {\n\t\tndev->hw_features = NETIF_F_RXCSUM | NETIF_F_IP_CSUM;\n\t\tndev->features |= ndev->hw_features;\n\t}\n\n\t \n\n\tndev->netdev_ops\t= &dm9000_netdev_ops;\n\tndev->watchdog_timeo\t= msecs_to_jiffies(watchdog);\n\tndev->ethtool_ops\t= &dm9000_ethtool_ops;\n\n\tdb->msg_enable       = NETIF_MSG_LINK;\n\tdb->mii.phy_id_mask  = 0x1f;\n\tdb->mii.reg_num_mask = 0x1f;\n\tdb->mii.force_media  = 0;\n\tdb->mii.full_duplex  = 0;\n\tdb->mii.dev\t     = ndev;\n\tdb->mii.mdio_read    = dm9000_phy_read;\n\tdb->mii.mdio_write   = dm9000_phy_write;\n\n\tmac_src = \"eeprom\";\n\n\t \n\tfor (i = 0; i < 6; i += 2)\n\t\tdm9000_read_eeprom(db, i / 2, addr + i);\n\teth_hw_addr_set(ndev, addr);\n\n\tif (!is_valid_ether_addr(ndev->dev_addr) && pdata != NULL) {\n\t\tmac_src = \"platform data\";\n\t\teth_hw_addr_set(ndev, pdata->dev_addr);\n\t}\n\n\tif (!is_valid_ether_addr(ndev->dev_addr)) {\n\t\t \n\n\t\tmac_src = \"chip\";\n\t\tfor (i = 0; i < 6; i++)\n\t\t\taddr[i] = ior(db, i + DM9000_PAR);\n\t\teth_hw_addr_set(ndev, pdata->dev_addr);\n\t}\n\n\tif (!is_valid_ether_addr(ndev->dev_addr)) {\n\t\tinv_mac_addr = true;\n\t\teth_hw_addr_random(ndev);\n\t\tmac_src = \"random\";\n\t}\n\n\n\tplatform_set_drvdata(pdev, ndev);\n\tret = register_netdev(ndev);\n\n\tif (ret == 0) {\n\t\tif (inv_mac_addr)\n\t\t\tdev_warn(db->dev, \"%s: Invalid ethernet MAC address. Please set using ip\\n\",\n\t\t\t\t ndev->name);\n\t\tprintk(KERN_INFO \"%s: dm9000%c at %p,%p IRQ %d MAC: %pM (%s)\\n\",\n\t\t       ndev->name, dm9000_type_to_char(db->type),\n\t\t       db->io_addr, db->io_data, ndev->irq,\n\t\t       ndev->dev_addr, mac_src);\n\t}\n\treturn 0;\n\nout:\n\tdev_err(db->dev, \"not found (%d).\\n\", ret);\n\n\tdm9000_release_board(pdev, db);\n\tfree_netdev(ndev);\n\nout_regulator_disable:\n\tif (!IS_ERR(power))\n\t\tregulator_disable(power);\n\n\treturn ret;\n}\n\nstatic int\ndm9000_drv_suspend(struct device *dev)\n{\n\tstruct net_device *ndev = dev_get_drvdata(dev);\n\tstruct board_info *db;\n\n\tif (ndev) {\n\t\tdb = netdev_priv(ndev);\n\t\tdb->in_suspend = 1;\n\n\t\tif (!netif_running(ndev))\n\t\t\treturn 0;\n\n\t\tnetif_device_detach(ndev);\n\n\t\t \n\t\tif (!db->wake_state)\n\t\t\tdm9000_shutdown(ndev);\n\t}\n\treturn 0;\n}\n\nstatic int\ndm9000_drv_resume(struct device *dev)\n{\n\tstruct net_device *ndev = dev_get_drvdata(dev);\n\tstruct board_info *db = netdev_priv(ndev);\n\n\tif (ndev) {\n\t\tif (netif_running(ndev)) {\n\t\t\t \n\t\t\tif (!db->wake_state) {\n\t\t\t\tdm9000_init_dm9000(ndev);\n\t\t\t\tdm9000_unmask_interrupts(db);\n\t\t\t}\n\n\t\t\tnetif_device_attach(ndev);\n\t\t}\n\n\t\tdb->in_suspend = 0;\n\t}\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops dm9000_drv_pm_ops = {\n\t.suspend\t= dm9000_drv_suspend,\n\t.resume\t\t= dm9000_drv_resume,\n};\n\nstatic int\ndm9000_drv_remove(struct platform_device *pdev)\n{\n\tstruct net_device *ndev = platform_get_drvdata(pdev);\n\tstruct board_info *dm = to_dm9000_board(ndev);\n\n\tunregister_netdev(ndev);\n\tdm9000_release_board(pdev, dm);\n\tfree_netdev(ndev);\t\t \n\tif (dm->power_supply)\n\t\tregulator_disable(dm->power_supply);\n\n\tdev_dbg(&pdev->dev, \"released and freed device\\n\");\n\treturn 0;\n}\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id dm9000_of_matches[] = {\n\t{ .compatible = \"davicom,dm9000\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, dm9000_of_matches);\n#endif\n\nstatic struct platform_driver dm9000_driver = {\n\t.driver\t= {\n\t\t.name    = \"dm9000\",\n\t\t.pm\t = &dm9000_drv_pm_ops,\n\t\t.of_match_table = of_match_ptr(dm9000_of_matches),\n\t},\n\t.probe   = dm9000_probe,\n\t.remove  = dm9000_drv_remove,\n};\n\nmodule_platform_driver(dm9000_driver);\n\nMODULE_AUTHOR(\"Sascha Hauer, Ben Dooks\");\nMODULE_DESCRIPTION(\"Davicom DM9000 network driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:dm9000\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}