{
  "module_name": "dm9051.c",
  "hash_id": "9f24e15ef52ae8ecd41916fb7efa337714679a95ca52ad3b8f0c36bcd13a3b0a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/davicom/dm9051.c",
  "human_readable_source": "\n \n\n#include <linux/etherdevice.h>\n#include <linux/ethtool.h>\n#include <linux/interrupt.h>\n#include <linux/iopoll.h>\n#include <linux/irq.h>\n#include <linux/mii.h>\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/phy.h>\n#include <linux/regmap.h>\n#include <linux/skbuff.h>\n#include <linux/spinlock.h>\n#include <linux/spi/spi.h>\n#include <linux/types.h>\n\n#include \"dm9051.h\"\n\n#define DRVNAME_9051\t\"dm9051\"\n\n \nstruct rx_ctl_mach {\n\tu16\t\t\t\tstatus_err_counter;\n\tu16\t\t\t\tlarge_err_counter;\n\tu16\t\t\t\trx_err_counter;\n\tu16\t\t\t\ttx_err_counter;\n\tu16\t\t\t\tfifo_rst_counter;\n};\n\n \nstruct dm9051_rxctrl {\n\tu16\t\t\t\thash_table[4];\n\tu8\t\t\t\trcr_all;\n};\n\n \nstruct dm9051_rxhdr {\n\tu8\t\t\t\theadbyte;\n\tu8\t\t\t\tstatus;\n\t__le16\t\t\t\trxlen;\n};\n\n \nstruct board_info {\n\tu32\t\t\t\tmsg_enable;\n\tstruct spi_device\t\t*spidev;\n\tstruct net_device\t\t*ndev;\n\tstruct mii_bus\t\t\t*mdiobus;\n\tstruct phy_device\t\t*phydev;\n\tstruct sk_buff_head\t\ttxq;\n\tstruct regmap\t\t\t*regmap_dm;\n\tstruct regmap\t\t\t*regmap_dmbulk;\n\tstruct work_struct\t\trxctrl_work;\n\tstruct work_struct\t\ttx_work;\n\tstruct ethtool_pauseparam\tpause;\n\tstruct mutex\t\t\tspi_lockm;\n\tstruct mutex\t\t\treg_mutex;\n\tstruct rx_ctl_mach\t\tbc;\n\tstruct dm9051_rxhdr\t\trxhdr;\n\tstruct dm9051_rxctrl\t\trctl;\n\tu8\t\t\t\timr_all;\n\tu8\t\t\t\tlcr_all;\n};\n\nstatic int dm9051_set_reg(struct board_info *db, unsigned int reg, unsigned int val)\n{\n\tint ret;\n\n\tret = regmap_write(db->regmap_dm, reg, val);\n\tif (ret < 0)\n\t\tnetif_err(db, drv, db->ndev, \"%s: error %d set reg %02x\\n\",\n\t\t\t  __func__, ret, reg);\n\treturn ret;\n}\n\nstatic int dm9051_update_bits(struct board_info *db, unsigned int reg, unsigned int mask,\n\t\t\t      unsigned int val)\n{\n\tint ret;\n\n\tret = regmap_update_bits(db->regmap_dm, reg, mask, val);\n\tif (ret < 0)\n\t\tnetif_err(db, drv, db->ndev, \"%s: error %d update bits reg %02x\\n\",\n\t\t\t  __func__, ret, reg);\n\treturn ret;\n}\n\n \nstatic int dm9051_dumpblk(struct board_info *db, u8 reg, size_t count)\n{\n\tstruct net_device *ndev = db->ndev;\n\tunsigned int rb;\n\tint ret;\n\n\t \n\tdo {\n\t\tret = regmap_read(db->regmap_dm, reg, &rb);\n\t\tif (ret < 0) {\n\t\t\tnetif_err(db, drv, ndev, \"%s: error %d dumping read reg %02x\\n\",\n\t\t\t\t  __func__, ret, reg);\n\t\t\tbreak;\n\t\t}\n\t} while (--count);\n\n\treturn ret;\n}\n\nstatic int dm9051_set_regs(struct board_info *db, unsigned int reg, const void *val,\n\t\t\t   size_t val_count)\n{\n\tint ret;\n\n\tret = regmap_bulk_write(db->regmap_dmbulk, reg, val, val_count);\n\tif (ret < 0)\n\t\tnetif_err(db, drv, db->ndev, \"%s: error %d bulk writing regs %02x\\n\",\n\t\t\t  __func__, ret, reg);\n\treturn ret;\n}\n\nstatic int dm9051_get_regs(struct board_info *db, unsigned int reg, void *val,\n\t\t\t   size_t val_count)\n{\n\tint ret;\n\n\tret = regmap_bulk_read(db->regmap_dmbulk, reg, val, val_count);\n\tif (ret < 0)\n\t\tnetif_err(db, drv, db->ndev, \"%s: error %d bulk reading regs %02x\\n\",\n\t\t\t  __func__, ret, reg);\n\treturn ret;\n}\n\nstatic int dm9051_write_mem(struct board_info *db, unsigned int reg, const void *buff,\n\t\t\t    size_t len)\n{\n\tint ret;\n\n\tret = regmap_noinc_write(db->regmap_dm, reg, buff, len);\n\tif (ret < 0)\n\t\tnetif_err(db, drv, db->ndev, \"%s: error %d noinc writing regs %02x\\n\",\n\t\t\t  __func__, ret, reg);\n\treturn ret;\n}\n\nstatic int dm9051_read_mem(struct board_info *db, unsigned int reg, void *buff,\n\t\t\t   size_t len)\n{\n\tint ret;\n\n\tret = regmap_noinc_read(db->regmap_dm, reg, buff, len);\n\tif (ret < 0)\n\t\tnetif_err(db, drv, db->ndev, \"%s: error %d noinc reading regs %02x\\n\",\n\t\t\t  __func__, ret, reg);\n\treturn ret;\n}\n\n \nstatic int dm9051_nsr_poll(struct board_info *db)\n{\n\tunsigned int mval;\n\tint ret;\n\n\tret = regmap_read_poll_timeout(db->regmap_dm, DM9051_NSR, mval,\n\t\t\t\t       mval & (NSR_TX2END | NSR_TX1END), 1, 20);\n\tif (ret == -ETIMEDOUT)\n\t\tnetdev_err(db->ndev, \"timeout in checking for tx end\\n\");\n\treturn ret;\n}\n\nstatic int dm9051_epcr_poll(struct board_info *db)\n{\n\tunsigned int mval;\n\tint ret;\n\n\tret = regmap_read_poll_timeout(db->regmap_dm, DM9051_EPCR, mval,\n\t\t\t\t       !(mval & EPCR_ERRE), 100, 10000);\n\tif (ret == -ETIMEDOUT)\n\t\tnetdev_err(db->ndev, \"eeprom/phy in processing get timeout\\n\");\n\treturn ret;\n}\n\nstatic int dm9051_irq_flag(struct board_info *db)\n{\n\tstruct spi_device *spi = db->spidev;\n\tint irq_type = irq_get_trigger_type(spi->irq);\n\n\tif (irq_type)\n\t\treturn irq_type;\n\n\treturn IRQF_TRIGGER_LOW;\n}\n\nstatic unsigned int dm9051_intcr_value(struct board_info *db)\n{\n\treturn (dm9051_irq_flag(db) == IRQF_TRIGGER_LOW) ?\n\t\tINTCR_POL_LOW : INTCR_POL_HIGH;\n}\n\nstatic int dm9051_set_fcr(struct board_info *db)\n{\n\tu8 fcr = 0;\n\n\tif (db->pause.rx_pause)\n\t\tfcr |= FCR_BKPM | FCR_FLCE;\n\tif (db->pause.tx_pause)\n\t\tfcr |= FCR_TXPEN;\n\n\treturn dm9051_set_reg(db, DM9051_FCR, fcr);\n}\n\nstatic int dm9051_set_recv(struct board_info *db)\n{\n\tint ret;\n\n\tret = dm9051_set_regs(db, DM9051_MAR, db->rctl.hash_table, sizeof(db->rctl.hash_table));\n\tif (ret)\n\t\treturn ret;\n\n\treturn dm9051_set_reg(db, DM9051_RCR, db->rctl.rcr_all);  \n}\n\nstatic int dm9051_core_reset(struct board_info *db)\n{\n\tint ret;\n\n\tdb->bc.fifo_rst_counter++;\n\n\tret = regmap_write(db->regmap_dm, DM9051_NCR, NCR_RST);  \n\tif (ret)\n\t\treturn ret;\n\tret = regmap_write(db->regmap_dm, DM9051_MBNDRY, MBNDRY_BYTE);  \n\tif (ret)\n\t\treturn ret;\n\tret = regmap_write(db->regmap_dm, DM9051_PPCR, PPCR_PAUSE_COUNT);  \n\tif (ret)\n\t\treturn ret;\n\tret = regmap_write(db->regmap_dm, DM9051_LMCR, db->lcr_all);  \n\tif (ret)\n\t\treturn ret;\n\n\treturn dm9051_set_reg(db, DM9051_INTCR, dm9051_intcr_value(db));\n}\n\nstatic int dm9051_update_fcr(struct board_info *db)\n{\n\tu8 fcr = 0;\n\n\tif (db->pause.rx_pause)\n\t\tfcr |= FCR_BKPM | FCR_FLCE;\n\tif (db->pause.tx_pause)\n\t\tfcr |= FCR_TXPEN;\n\n\treturn dm9051_update_bits(db, DM9051_FCR, FCR_RXTX_BITS, fcr);\n}\n\nstatic int dm9051_disable_interrupt(struct board_info *db)\n{\n\treturn dm9051_set_reg(db, DM9051_IMR, IMR_PAR);  \n}\n\nstatic int dm9051_enable_interrupt(struct board_info *db)\n{\n\treturn dm9051_set_reg(db, DM9051_IMR, db->imr_all);  \n}\n\nstatic int dm9051_stop_mrcmd(struct board_info *db)\n{\n\treturn dm9051_set_reg(db, DM9051_ISR, ISR_STOP_MRCMD);  \n}\n\nstatic int dm9051_clear_interrupt(struct board_info *db)\n{\n\treturn dm9051_update_bits(db, DM9051_ISR, ISR_CLR_INT, ISR_CLR_INT);\n}\n\nstatic int dm9051_eeprom_read(struct board_info *db, int offset, u8 *to)\n{\n\tint ret;\n\n\tret = regmap_write(db->regmap_dm, DM9051_EPAR, offset);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_write(db->regmap_dm, DM9051_EPCR, EPCR_ERPRR);\n\tif (ret)\n\t\treturn ret;\n\n\tret = dm9051_epcr_poll(db);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_write(db->regmap_dm, DM9051_EPCR, 0);\n\tif (ret)\n\t\treturn ret;\n\n\treturn regmap_bulk_read(db->regmap_dmbulk, DM9051_EPDRL, to, 2);\n}\n\nstatic int dm9051_eeprom_write(struct board_info *db, int offset, u8 *data)\n{\n\tint ret;\n\n\tret = regmap_write(db->regmap_dm, DM9051_EPAR, offset);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_bulk_write(db->regmap_dmbulk, DM9051_EPDRL, data, 2);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_write(db->regmap_dm, DM9051_EPCR, EPCR_WEP | EPCR_ERPRW);\n\tif (ret)\n\t\treturn ret;\n\n\tret = dm9051_epcr_poll(db);\n\tif (ret)\n\t\treturn ret;\n\n\treturn regmap_write(db->regmap_dm, DM9051_EPCR, 0);\n}\n\nstatic int dm9051_phyread(void *context, unsigned int reg, unsigned int *val)\n{\n\tstruct board_info *db = context;\n\tint ret;\n\n\tret = regmap_write(db->regmap_dm, DM9051_EPAR, DM9051_PHY | reg);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_write(db->regmap_dm, DM9051_EPCR, EPCR_ERPRR | EPCR_EPOS);\n\tif (ret)\n\t\treturn ret;\n\n\tret = dm9051_epcr_poll(db);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_write(db->regmap_dm, DM9051_EPCR, 0);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\t*val = 0;\n\treturn regmap_bulk_read(db->regmap_dmbulk, DM9051_EPDRL, val, 2);\n}\n\nstatic int dm9051_phywrite(void *context, unsigned int reg, unsigned int val)\n{\n\tstruct board_info *db = context;\n\tint ret;\n\n\tret = regmap_write(db->regmap_dm, DM9051_EPAR, DM9051_PHY | reg);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_bulk_write(db->regmap_dmbulk, DM9051_EPDRL, &val, 2);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_write(db->regmap_dm, DM9051_EPCR, EPCR_EPOS | EPCR_ERPRW);\n\tif (ret)\n\t\treturn ret;\n\n\tret = dm9051_epcr_poll(db);\n\tif (ret)\n\t\treturn ret;\n\n\treturn regmap_write(db->regmap_dm, DM9051_EPCR, 0);\n}\n\nstatic int dm9051_mdio_read(struct mii_bus *bus, int addr, int regnum)\n{\n\tstruct board_info *db = bus->priv;\n\tunsigned int val = 0xffff;\n\tint ret;\n\n\tif (addr == DM9051_PHY_ADDR) {\n\t\tret = dm9051_phyread(db, regnum, &val);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn val;\n}\n\nstatic int dm9051_mdio_write(struct mii_bus *bus, int addr, int regnum, u16 val)\n{\n\tstruct board_info *db = bus->priv;\n\n\tif (addr == DM9051_PHY_ADDR)\n\t\treturn dm9051_phywrite(db, regnum, val);\n\n\treturn -ENODEV;\n}\n\nstatic void dm9051_reg_lock_mutex(void *dbcontext)\n{\n\tstruct board_info *db = dbcontext;\n\n\tmutex_lock(&db->reg_mutex);\n}\n\nstatic void dm9051_reg_unlock_mutex(void *dbcontext)\n{\n\tstruct board_info *db = dbcontext;\n\n\tmutex_unlock(&db->reg_mutex);\n}\n\nstatic struct regmap_config regconfigdm = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.max_register = 0xff,\n\t.reg_stride = 1,\n\t.cache_type = REGCACHE_NONE,\n\t.read_flag_mask = 0,\n\t.write_flag_mask = DM_SPI_WR,\n\t.val_format_endian = REGMAP_ENDIAN_LITTLE,\n\t.lock = dm9051_reg_lock_mutex,\n\t.unlock = dm9051_reg_unlock_mutex,\n};\n\nstatic struct regmap_config regconfigdmbulk = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.max_register = 0xff,\n\t.reg_stride = 1,\n\t.cache_type = REGCACHE_NONE,\n\t.read_flag_mask = 0,\n\t.write_flag_mask = DM_SPI_WR,\n\t.val_format_endian = REGMAP_ENDIAN_LITTLE,\n\t.lock = dm9051_reg_lock_mutex,\n\t.unlock = dm9051_reg_unlock_mutex,\n\t.use_single_read = true,\n\t.use_single_write = true,\n};\n\nstatic int dm9051_map_init(struct spi_device *spi, struct board_info *db)\n{\n\t \n\tregconfigdm.lock_arg = db;\n\tdb->regmap_dm = devm_regmap_init_spi(db->spidev, &regconfigdm);\n\tif (IS_ERR(db->regmap_dm))\n\t\treturn PTR_ERR(db->regmap_dm);\n\n\tregconfigdmbulk.lock_arg = db;\n\tdb->regmap_dmbulk = devm_regmap_init_spi(db->spidev, &regconfigdmbulk);\n\treturn PTR_ERR_OR_ZERO(db->regmap_dmbulk);\n}\n\nstatic int dm9051_map_chipid(struct board_info *db)\n{\n\tstruct device *dev = &db->spidev->dev;\n\tunsigned short wid;\n\tu8 buff[6];\n\tint ret;\n\n\tret = dm9051_get_regs(db, DM9051_VIDL, buff, sizeof(buff));\n\tif (ret < 0)\n\t\treturn ret;\n\n\twid = get_unaligned_le16(buff + 2);\n\tif (wid != DM9051_ID) {\n\t\tdev_err(dev, \"chipid error as %04x !\\n\", wid);\n\t\treturn -ENODEV;\n\t}\n\n\tdev_info(dev, \"chip %04x found\\n\", wid);\n\treturn 0;\n}\n\n \nstatic int dm9051_map_etherdev_par(struct net_device *ndev, struct board_info *db)\n{\n\tu8 addr[ETH_ALEN];\n\tint ret;\n\n\tret = dm9051_get_regs(db, DM9051_PAR, addr, sizeof(addr));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (!is_valid_ether_addr(addr)) {\n\t\teth_hw_addr_random(ndev);\n\n\t\tret = dm9051_set_regs(db, DM9051_PAR, ndev->dev_addr, sizeof(ndev->dev_addr));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tdev_dbg(&db->spidev->dev, \"Use random MAC address\\n\");\n\t\treturn 0;\n\t}\n\n\teth_hw_addr_set(ndev, addr);\n\treturn 0;\n}\n\n \nstatic void dm9051_get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *info)\n{\n\tstrscpy(info->driver, DRVNAME_9051, sizeof(info->driver));\n}\n\nstatic void dm9051_set_msglevel(struct net_device *ndev, u32 value)\n{\n\tstruct board_info *db = to_dm9051_board(ndev);\n\n\tdb->msg_enable = value;\n}\n\nstatic u32 dm9051_get_msglevel(struct net_device *ndev)\n{\n\tstruct board_info *db = to_dm9051_board(ndev);\n\n\treturn db->msg_enable;\n}\n\nstatic int dm9051_get_eeprom_len(struct net_device *dev)\n{\n\treturn 128;\n}\n\nstatic int dm9051_get_eeprom(struct net_device *ndev,\n\t\t\t     struct ethtool_eeprom *ee, u8 *data)\n{\n\tstruct board_info *db = to_dm9051_board(ndev);\n\tint offset = ee->offset;\n\tint len = ee->len;\n\tint i, ret;\n\n\tif ((len | offset) & 1)\n\t\treturn -EINVAL;\n\n\tee->magic = DM_EEPROM_MAGIC;\n\n\tfor (i = 0; i < len; i += 2) {\n\t\tret = dm9051_eeprom_read(db, (offset + i) / 2, data + i);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic int dm9051_set_eeprom(struct net_device *ndev,\n\t\t\t     struct ethtool_eeprom *ee, u8 *data)\n{\n\tstruct board_info *db = to_dm9051_board(ndev);\n\tint offset = ee->offset;\n\tint len = ee->len;\n\tint i, ret;\n\n\tif ((len | offset) & 1)\n\t\treturn -EINVAL;\n\n\tif (ee->magic != DM_EEPROM_MAGIC)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < len; i += 2) {\n\t\tret = dm9051_eeprom_write(db, (offset + i) / 2, data + i);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic void dm9051_get_pauseparam(struct net_device *ndev,\n\t\t\t\t  struct ethtool_pauseparam *pause)\n{\n\tstruct board_info *db = to_dm9051_board(ndev);\n\n\t*pause = db->pause;\n}\n\nstatic int dm9051_set_pauseparam(struct net_device *ndev,\n\t\t\t\t struct ethtool_pauseparam *pause)\n{\n\tstruct board_info *db = to_dm9051_board(ndev);\n\n\tdb->pause = *pause;\n\n\tif (pause->autoneg == AUTONEG_DISABLE)\n\t\treturn dm9051_update_fcr(db);\n\n\tphy_set_sym_pause(db->phydev, pause->rx_pause, pause->tx_pause,\n\t\t\t  pause->autoneg);\n\tphy_start_aneg(db->phydev);\n\treturn 0;\n}\n\nstatic const struct ethtool_ops dm9051_ethtool_ops = {\n\t.get_drvinfo = dm9051_get_drvinfo,\n\t.get_link_ksettings = phy_ethtool_get_link_ksettings,\n\t.set_link_ksettings = phy_ethtool_set_link_ksettings,\n\t.get_msglevel = dm9051_get_msglevel,\n\t.set_msglevel = dm9051_set_msglevel,\n\t.nway_reset = phy_ethtool_nway_reset,\n\t.get_link = ethtool_op_get_link,\n\t.get_eeprom_len = dm9051_get_eeprom_len,\n\t.get_eeprom = dm9051_get_eeprom,\n\t.set_eeprom = dm9051_set_eeprom,\n\t.get_pauseparam = dm9051_get_pauseparam,\n\t.set_pauseparam = dm9051_set_pauseparam,\n};\n\nstatic int dm9051_all_start(struct board_info *db)\n{\n\tint ret;\n\n\t \n\tret = dm9051_set_reg(db, DM9051_GPR, 0);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tmsleep(1);\n\n\tret = dm9051_core_reset(db);\n\tif (ret)\n\t\treturn ret;\n\n\treturn dm9051_enable_interrupt(db);\n}\n\nstatic int dm9051_all_stop(struct board_info *db)\n{\n\tint ret;\n\n\t \n\tret = dm9051_set_reg(db, DM9051_GPR, GPR_PHY_OFF);\n\tif (ret)\n\t\treturn ret;\n\n\treturn dm9051_set_reg(db, DM9051_RCR, RCR_RX_DISABLE);\n}\n\n \nstatic int dm9051_all_restart(struct board_info *db)\n{\n\tstruct net_device *ndev = db->ndev;\n\tint ret;\n\n\tret = dm9051_core_reset(db);\n\tif (ret)\n\t\treturn ret;\n\n\tret = dm9051_enable_interrupt(db);\n\tif (ret)\n\t\treturn ret;\n\n\tnetdev_dbg(ndev, \" rxstatus_Er & rxlen_Er %d, RST_c %d\\n\",\n\t\t   db->bc.status_err_counter + db->bc.large_err_counter,\n\t\t   db->bc.fifo_rst_counter);\n\n\tret = dm9051_set_recv(db);\n\tif (ret)\n\t\treturn ret;\n\n\treturn dm9051_set_fcr(db);\n}\n\n \nstatic int dm9051_loop_rx(struct board_info *db)\n{\n\tstruct net_device *ndev = db->ndev;\n\tunsigned int rxbyte;\n\tint ret, rxlen;\n\tstruct sk_buff *skb;\n\tu8 *rdptr;\n\tint scanrr = 0;\n\n\tdo {\n\t\tret = dm9051_read_mem(db, DM_SPI_MRCMDX, &rxbyte, 2);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif ((rxbyte & GENMASK(7, 0)) != DM9051_PKT_RDY)\n\t\t\tbreak;  \n\n\t\tret = dm9051_read_mem(db, DM_SPI_MRCMD, &db->rxhdr, DM_RXHDR_SIZE);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = dm9051_stop_mrcmd(db);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\trxlen = le16_to_cpu(db->rxhdr.rxlen);\n\t\tif (db->rxhdr.status & RSR_ERR_BITS || rxlen > DM9051_PKT_MAX) {\n\t\t\tnetdev_dbg(ndev, \"rxhdr-byte (%02x)\\n\",\n\t\t\t\t   db->rxhdr.headbyte);\n\n\t\t\tif (db->rxhdr.status & RSR_ERR_BITS) {\n\t\t\t\tdb->bc.status_err_counter++;\n\t\t\t\tnetdev_dbg(ndev, \"check rxstatus-error (%02x)\\n\",\n\t\t\t\t\t   db->rxhdr.status);\n\t\t\t} else {\n\t\t\t\tdb->bc.large_err_counter++;\n\t\t\t\tnetdev_dbg(ndev, \"check rxlen large-error (%d > %d)\\n\",\n\t\t\t\t\t   rxlen, DM9051_PKT_MAX);\n\t\t\t}\n\t\t\treturn dm9051_all_restart(db);\n\t\t}\n\n\t\tskb = dev_alloc_skb(rxlen);\n\t\tif (!skb) {\n\t\t\tret = dm9051_dumpblk(db, DM_SPI_MRCMD, rxlen);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\treturn scanrr;\n\t\t}\n\n\t\trdptr = skb_put(skb, rxlen - 4);\n\t\tret = dm9051_read_mem(db, DM_SPI_MRCMD, rdptr, rxlen);\n\t\tif (ret) {\n\t\t\tdb->bc.rx_err_counter++;\n\t\t\tdev_kfree_skb(skb);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = dm9051_stop_mrcmd(db);\n\t\tif (ret) {\n\t\t\tdev_kfree_skb(skb);\n\t\t\treturn ret;\n\t\t}\n\n\t\tskb->protocol = eth_type_trans(skb, db->ndev);\n\t\tif (db->ndev->features & NETIF_F_RXCSUM)\n\t\t\tskb_checksum_none_assert(skb);\n\t\tnetif_rx(skb);\n\t\tdb->ndev->stats.rx_bytes += rxlen;\n\t\tdb->ndev->stats.rx_packets++;\n\t\tscanrr++;\n\t} while (!ret);\n\n\treturn scanrr;\n}\n\n \nstatic int dm9051_single_tx(struct board_info *db, u8 *buff, unsigned int len)\n{\n\tint ret;\n\n\tret = dm9051_nsr_poll(db);\n\tif (ret)\n\t\treturn ret;\n\n\tret = dm9051_write_mem(db, DM_SPI_MWCMD, buff, len);\n\tif (ret)\n\t\treturn ret;\n\n\tret = dm9051_set_regs(db, DM9051_TXPLL, &len, 2);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn dm9051_set_reg(db, DM9051_TCR, TCR_TXREQ);\n}\n\nstatic int dm9051_loop_tx(struct board_info *db)\n{\n\tstruct net_device *ndev = db->ndev;\n\tint ntx = 0;\n\tint ret;\n\n\twhile (!skb_queue_empty(&db->txq)) {\n\t\tstruct sk_buff *skb;\n\t\tunsigned int len;\n\n\t\tskb = skb_dequeue(&db->txq);\n\t\tif (skb) {\n\t\t\tntx++;\n\t\t\tret = dm9051_single_tx(db, skb->data, skb->len);\n\t\t\tlen = skb->len;\n\t\t\tdev_kfree_skb(skb);\n\t\t\tif (ret < 0) {\n\t\t\t\tdb->bc.tx_err_counter++;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tndev->stats.tx_bytes += len;\n\t\t\tndev->stats.tx_packets++;\n\t\t}\n\n\t\tif (netif_queue_stopped(ndev) &&\n\t\t    (skb_queue_len(&db->txq) < DM9051_TX_QUE_LO_WATER))\n\t\t\tnetif_wake_queue(ndev);\n\t}\n\n\treturn ntx;\n}\n\nstatic irqreturn_t dm9051_rx_threaded_irq(int irq, void *pw)\n{\n\tstruct board_info *db = pw;\n\tint result, result_tx;\n\n\tmutex_lock(&db->spi_lockm);\n\n\tresult = dm9051_disable_interrupt(db);\n\tif (result)\n\t\tgoto out_unlock;\n\n\tresult = dm9051_clear_interrupt(db);\n\tif (result)\n\t\tgoto out_unlock;\n\n\tdo {\n\t\tresult = dm9051_loop_rx(db);  \n\t\tif (result < 0)\n\t\t\tgoto out_unlock;\n\t\tresult_tx = dm9051_loop_tx(db);  \n\t\tif (result_tx < 0)\n\t\t\tgoto out_unlock;\n\t} while (result > 0);\n\n\tdm9051_enable_interrupt(db);\n\n\t \nout_unlock:\n\tmutex_unlock(&db->spi_lockm);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void dm9051_tx_delay(struct work_struct *work)\n{\n\tstruct board_info *db = container_of(work, struct board_info, tx_work);\n\tint result;\n\n\tmutex_lock(&db->spi_lockm);\n\n\tresult = dm9051_loop_tx(db);\n\tif (result < 0)\n\t\tnetdev_err(db->ndev, \"transmit packet error\\n\");\n\n\tmutex_unlock(&db->spi_lockm);\n}\n\nstatic void dm9051_rxctl_delay(struct work_struct *work)\n{\n\tstruct board_info *db = container_of(work, struct board_info, rxctrl_work);\n\tstruct net_device *ndev = db->ndev;\n\tint result;\n\n\tmutex_lock(&db->spi_lockm);\n\n\tresult = dm9051_set_regs(db, DM9051_PAR, ndev->dev_addr, sizeof(ndev->dev_addr));\n\tif (result < 0)\n\t\tgoto out_unlock;\n\n\tdm9051_set_recv(db);\n\n\t \nout_unlock:\n\tmutex_unlock(&db->spi_lockm);\n}\n\n \nstatic int dm9051_open(struct net_device *ndev)\n{\n\tstruct board_info *db = to_dm9051_board(ndev);\n\tstruct spi_device *spi = db->spidev;\n\tint ret;\n\n\tdb->imr_all = IMR_PAR | IMR_PRM;\n\tdb->lcr_all = LMCR_MODE1;\n\tdb->rctl.rcr_all = RCR_DIS_LONG | RCR_DIS_CRC | RCR_RXEN;\n\tmemset(db->rctl.hash_table, 0, sizeof(db->rctl.hash_table));\n\n\tndev->irq = spi->irq;  \n\tret = request_threaded_irq(spi->irq, NULL, dm9051_rx_threaded_irq,\n\t\t\t\t   dm9051_irq_flag(db) | IRQF_ONESHOT,\n\t\t\t\t   ndev->name, db);\n\tif (ret < 0) {\n\t\tnetdev_err(ndev, \"failed to get irq\\n\");\n\t\treturn ret;\n\t}\n\n\tphy_support_sym_pause(db->phydev);\n\tphy_start(db->phydev);\n\n\t \n\tdb->pause.rx_pause = true;\n\tdb->pause.tx_pause = true;\n\tdb->pause.autoneg = AUTONEG_DISABLE;\n\n\tif (db->phydev->autoneg)\n\t\tdb->pause.autoneg = AUTONEG_ENABLE;\n\n\tret = dm9051_all_start(db);\n\tif (ret) {\n\t\tphy_stop(db->phydev);\n\t\tfree_irq(spi->irq, db);\n\t\treturn ret;\n\t}\n\n\tnetif_wake_queue(ndev);\n\n\treturn 0;\n}\n\n \nstatic int dm9051_stop(struct net_device *ndev)\n{\n\tstruct board_info *db = to_dm9051_board(ndev);\n\tint ret;\n\n\tret = dm9051_all_stop(db);\n\tif (ret)\n\t\treturn ret;\n\n\tflush_work(&db->tx_work);\n\tflush_work(&db->rxctrl_work);\n\n\tphy_stop(db->phydev);\n\n\tfree_irq(db->spidev->irq, db);\n\n\tnetif_stop_queue(ndev);\n\n\tskb_queue_purge(&db->txq);\n\n\treturn 0;\n}\n\n \nstatic netdev_tx_t dm9051_start_xmit(struct sk_buff *skb, struct net_device *ndev)\n{\n\tstruct board_info *db = to_dm9051_board(ndev);\n\n\tskb_queue_tail(&db->txq, skb);\n\tif (skb_queue_len(&db->txq) > DM9051_TX_QUE_HI_WATER)\n\t\tnetif_stop_queue(ndev);  \n\n\tschedule_work(&db->tx_work);\n\n\treturn NETDEV_TX_OK;\n}\n\n \nstatic void dm9051_set_rx_mode(struct net_device *ndev)\n{\n\tstruct board_info *db = to_dm9051_board(ndev);\n\tstruct dm9051_rxctrl rxctrl;\n\tstruct netdev_hw_addr *ha;\n\tu8 rcr = RCR_DIS_LONG | RCR_DIS_CRC | RCR_RXEN;\n\tu32 hash_val;\n\n\tmemset(&rxctrl, 0, sizeof(rxctrl));\n\n\t \n\tif (ndev->flags & IFF_PROMISC) {\n\t\trcr |= RCR_PRMSC;\n\t\tnetdev_dbg(ndev, \"set_multicast rcr |= RCR_PRMSC, rcr= %02x\\n\", rcr);\n\t}\n\n\tif (ndev->flags & IFF_ALLMULTI) {\n\t\trcr |= RCR_ALL;\n\t\tnetdev_dbg(ndev, \"set_multicast rcr |= RCR_ALLMULTI, rcr= %02x\\n\", rcr);\n\t}\n\n\trxctrl.rcr_all = rcr;\n\n\t \n\trxctrl.hash_table[0] = 0;\n\trxctrl.hash_table[1] = 0;\n\trxctrl.hash_table[2] = 0;\n\trxctrl.hash_table[3] = 0x8000;\n\n\t \n\tnetdev_for_each_mc_addr(ha, ndev) {\n\t\thash_val = ether_crc_le(ETH_ALEN, ha->addr) & GENMASK(5, 0);\n\t\trxctrl.hash_table[hash_val / 16] |= BIT(0) << (hash_val % 16);\n\t}\n\n\t \n\n\tif (memcmp(&db->rctl, &rxctrl, sizeof(rxctrl))) {\n\t\tmemcpy(&db->rctl, &rxctrl, sizeof(rxctrl));\n\t\tschedule_work(&db->rxctrl_work);\n\t}\n}\n\n \nstatic int dm9051_set_mac_address(struct net_device *ndev, void *p)\n{\n\tstruct board_info *db = to_dm9051_board(ndev);\n\tint ret;\n\n\tret = eth_prepare_mac_addr_change(ndev, p);\n\tif (ret < 0)\n\t\treturn ret;\n\n\teth_commit_mac_addr_change(ndev, p);\n\treturn dm9051_set_regs(db, DM9051_PAR, ndev->dev_addr, sizeof(ndev->dev_addr));\n}\n\nstatic const struct net_device_ops dm9051_netdev_ops = {\n\t.ndo_open = dm9051_open,\n\t.ndo_stop = dm9051_stop,\n\t.ndo_start_xmit = dm9051_start_xmit,\n\t.ndo_set_rx_mode = dm9051_set_rx_mode,\n\t.ndo_validate_addr = eth_validate_addr,\n\t.ndo_set_mac_address = dm9051_set_mac_address,\n};\n\nstatic void dm9051_operation_clear(struct board_info *db)\n{\n\tdb->bc.status_err_counter = 0;\n\tdb->bc.large_err_counter = 0;\n\tdb->bc.rx_err_counter = 0;\n\tdb->bc.tx_err_counter = 0;\n\tdb->bc.fifo_rst_counter = 0;\n}\n\nstatic int dm9051_mdio_register(struct board_info *db)\n{\n\tstruct spi_device *spi = db->spidev;\n\tint ret;\n\n\tdb->mdiobus = devm_mdiobus_alloc(&spi->dev);\n\tif (!db->mdiobus)\n\t\treturn -ENOMEM;\n\n\tdb->mdiobus->priv = db;\n\tdb->mdiobus->read = dm9051_mdio_read;\n\tdb->mdiobus->write = dm9051_mdio_write;\n\tdb->mdiobus->name = \"dm9051-mdiobus\";\n\tdb->mdiobus->phy_mask = (u32)~BIT(1);\n\tdb->mdiobus->parent = &spi->dev;\n\tsnprintf(db->mdiobus->id, MII_BUS_ID_SIZE,\n\t\t \"dm9051-%s.%u\", dev_name(&spi->dev), spi_get_chipselect(spi, 0));\n\n\tret = devm_mdiobus_register(&spi->dev, db->mdiobus);\n\tif (ret)\n\t\tdev_err(&spi->dev, \"Could not register MDIO bus\\n\");\n\n\treturn ret;\n}\n\nstatic void dm9051_handle_link_change(struct net_device *ndev)\n{\n\tstruct board_info *db = to_dm9051_board(ndev);\n\n\tphy_print_status(db->phydev);\n\n\t \n\tif (db->phydev->link) {\n\t\tif (db->phydev->pause) {\n\t\t\tdb->pause.rx_pause = true;\n\t\t\tdb->pause.tx_pause = true;\n\t\t}\n\t\tdm9051_update_fcr(db);\n\t}\n}\n\n \nstatic int dm9051_phy_connect(struct board_info *db)\n{\n\tchar phy_id[MII_BUS_ID_SIZE + 3];\n\n\tsnprintf(phy_id, sizeof(phy_id), PHY_ID_FMT,\n\t\t db->mdiobus->id, DM9051_PHY_ADDR);\n\n\tdb->phydev = phy_connect(db->ndev, phy_id, dm9051_handle_link_change,\n\t\t\t\t PHY_INTERFACE_MODE_MII);\n\treturn PTR_ERR_OR_ZERO(db->phydev);\n}\n\nstatic int dm9051_probe(struct spi_device *spi)\n{\n\tstruct device *dev = &spi->dev;\n\tstruct net_device *ndev;\n\tstruct board_info *db;\n\tint ret;\n\n\tndev = devm_alloc_etherdev(dev, sizeof(struct board_info));\n\tif (!ndev)\n\t\treturn -ENOMEM;\n\n\tSET_NETDEV_DEV(ndev, dev);\n\tdev_set_drvdata(dev, ndev);\n\n\tdb = netdev_priv(ndev);\n\n\tdb->msg_enable = 0;\n\tdb->spidev = spi;\n\tdb->ndev = ndev;\n\n\tndev->netdev_ops = &dm9051_netdev_ops;\n\tndev->ethtool_ops = &dm9051_ethtool_ops;\n\n\tmutex_init(&db->spi_lockm);\n\tmutex_init(&db->reg_mutex);\n\n\tINIT_WORK(&db->rxctrl_work, dm9051_rxctl_delay);\n\tINIT_WORK(&db->tx_work, dm9051_tx_delay);\n\n\tret = dm9051_map_init(spi, db);\n\tif (ret)\n\t\treturn ret;\n\n\tret = dm9051_map_chipid(db);\n\tif (ret)\n\t\treturn ret;\n\n\tret = dm9051_map_etherdev_par(ndev, db);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = dm9051_mdio_register(db);\n\tif (ret)\n\t\treturn ret;\n\n\tret = dm9051_phy_connect(db);\n\tif (ret)\n\t\treturn ret;\n\n\tdm9051_operation_clear(db);\n\tskb_queue_head_init(&db->txq);\n\n\tret = devm_register_netdev(dev, ndev);\n\tif (ret) {\n\t\tphy_disconnect(db->phydev);\n\t\treturn dev_err_probe(dev, ret, \"device register failed\");\n\t}\n\n\treturn 0;\n}\n\nstatic void dm9051_drv_remove(struct spi_device *spi)\n{\n\tstruct device *dev = &spi->dev;\n\tstruct net_device *ndev = dev_get_drvdata(dev);\n\tstruct board_info *db = to_dm9051_board(ndev);\n\n\tphy_disconnect(db->phydev);\n}\n\nstatic const struct of_device_id dm9051_match_table[] = {\n\t{ .compatible = \"davicom,dm9051\" },\n\t{}\n};\n\nstatic const struct spi_device_id dm9051_id_table[] = {\n\t{ \"dm9051\", 0 },\n\t{}\n};\n\nstatic struct spi_driver dm9051_driver = {\n\t.driver = {\n\t\t.name = DRVNAME_9051,\n\t\t.of_match_table = dm9051_match_table,\n\t},\n\t.probe = dm9051_probe,\n\t.remove = dm9051_drv_remove,\n\t.id_table = dm9051_id_table,\n};\nmodule_spi_driver(dm9051_driver);\n\nMODULE_AUTHOR(\"Joseph CHANG <joseph_chang@davicom.com.tw>\");\nMODULE_DESCRIPTION(\"Davicom DM9051 network SPI driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}