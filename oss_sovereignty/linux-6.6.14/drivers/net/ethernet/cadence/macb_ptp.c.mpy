{
  "module_name": "macb_ptp.c",
  "hash_id": "10d5ef415e6d94e83a6c6772afc01231d11e1edf5edc6ce35905766661eccaa3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/cadence/macb_ptp.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/clk.h>\n#include <linux/device.h>\n#include <linux/etherdevice.h>\n#include <linux/platform_device.h>\n#include <linux/time64.h>\n#include <linux/ptp_classify.h>\n#include <linux/if_ether.h>\n#include <linux/if_vlan.h>\n#include <linux/net_tstamp.h>\n#include <linux/circ_buf.h>\n#include <linux/spinlock.h>\n\n#include \"macb.h\"\n\n#define  GEM_PTP_TIMER_NAME \"gem-ptp-timer\"\n\nstatic struct macb_dma_desc_ptp *macb_ptp_desc(struct macb *bp,\n\t\t\t\t\t       struct macb_dma_desc *desc)\n{\n\tif (bp->hw_dma_cap == HW_DMA_CAP_PTP)\n\t\treturn (struct macb_dma_desc_ptp *)\n\t\t\t\t((u8 *)desc + sizeof(struct macb_dma_desc));\n\tif (bp->hw_dma_cap == HW_DMA_CAP_64B_PTP)\n\t\treturn (struct macb_dma_desc_ptp *)\n\t\t\t\t((u8 *)desc + sizeof(struct macb_dma_desc)\n\t\t\t\t+ sizeof(struct macb_dma_desc_64));\n\treturn NULL;\n}\n\nstatic int gem_tsu_get_time(struct ptp_clock_info *ptp, struct timespec64 *ts,\n\t\t\t    struct ptp_system_timestamp *sts)\n{\n\tstruct macb *bp = container_of(ptp, struct macb, ptp_clock_info);\n\tunsigned long flags;\n\tlong first, second;\n\tu32 secl, sech;\n\n\tspin_lock_irqsave(&bp->tsu_clk_lock, flags);\n\tptp_read_system_prets(sts);\n\tfirst = gem_readl(bp, TN);\n\tptp_read_system_postts(sts);\n\tsecl = gem_readl(bp, TSL);\n\tsech = gem_readl(bp, TSH);\n\tsecond = gem_readl(bp, TN);\n\n\t \n\tif (first > second) {\n\t\t \n\t\tptp_read_system_prets(sts);\n\t\tts->tv_nsec = gem_readl(bp, TN);\n\t\tptp_read_system_postts(sts);\n\t\tsecl = gem_readl(bp, TSL);\n\t\tsech = gem_readl(bp, TSH);\n\t} else {\n\t\tts->tv_nsec = first;\n\t}\n\n\tspin_unlock_irqrestore(&bp->tsu_clk_lock, flags);\n\tts->tv_sec = (((u64)sech << GEM_TSL_SIZE) | secl)\n\t\t\t& TSU_SEC_MAX_VAL;\n\treturn 0;\n}\n\nstatic int gem_tsu_set_time(struct ptp_clock_info *ptp,\n\t\t\t    const struct timespec64 *ts)\n{\n\tstruct macb *bp = container_of(ptp, struct macb, ptp_clock_info);\n\tunsigned long flags;\n\tu32 ns, sech, secl;\n\n\tsecl = (u32)ts->tv_sec;\n\tsech = (ts->tv_sec >> GEM_TSL_SIZE) & ((1 << GEM_TSH_SIZE) - 1);\n\tns = ts->tv_nsec;\n\n\tspin_lock_irqsave(&bp->tsu_clk_lock, flags);\n\n\t \n\tgem_writel(bp, TN, 0);  \n\tgem_writel(bp, TSH, sech);\n\t \n\tgem_writel(bp, TSL, secl);\n\tgem_writel(bp, TN, ns);\n\n\tspin_unlock_irqrestore(&bp->tsu_clk_lock, flags);\n\n\treturn 0;\n}\n\nstatic int gem_tsu_incr_set(struct macb *bp, struct tsu_incr *incr_spec)\n{\n\tunsigned long flags;\n\n\t \n\tspin_lock_irqsave(&bp->tsu_clk_lock, flags);\n\t \n\tgem_writel(bp, TISUBN, GEM_BF(SUBNSINCRL, incr_spec->sub_ns) |\n\t\t   GEM_BF(SUBNSINCRH, (incr_spec->sub_ns >>\n\t\t\t  GEM_SUBNSINCRL_SIZE)));\n\tgem_writel(bp, TI, GEM_BF(NSINCR, incr_spec->ns));\n\tspin_unlock_irqrestore(&bp->tsu_clk_lock, flags);\n\n\treturn 0;\n}\n\nstatic int gem_ptp_adjfine(struct ptp_clock_info *ptp, long scaled_ppm)\n{\n\tstruct macb *bp = container_of(ptp, struct macb, ptp_clock_info);\n\tstruct tsu_incr incr_spec;\n\tbool neg_adj = false;\n\tu32 word;\n\tu64 adj;\n\n\tif (scaled_ppm < 0) {\n\t\tneg_adj = true;\n\t\tscaled_ppm = -scaled_ppm;\n\t}\n\n\t \n\tincr_spec.sub_ns = bp->tsu_incr.sub_ns;\n\tincr_spec.ns = bp->tsu_incr.ns;\n\n\t \n\tword = ((u64)incr_spec.ns << GEM_SUBNSINCR_SIZE) + incr_spec.sub_ns;\n\tadj = (u64)scaled_ppm * word;\n\t \n\tadj += (USEC_PER_SEC >> 1);\n\tadj >>= PPM_FRACTION;  \n\tadj = div_u64(adj, USEC_PER_SEC);\n\tadj = neg_adj ? (word - adj) : (word + adj);\n\n\tincr_spec.ns = (adj >> GEM_SUBNSINCR_SIZE)\n\t\t\t& ((1 << GEM_NSINCR_SIZE) - 1);\n\tincr_spec.sub_ns = adj & ((1 << GEM_SUBNSINCR_SIZE) - 1);\n\tgem_tsu_incr_set(bp, &incr_spec);\n\treturn 0;\n}\n\nstatic int gem_ptp_adjtime(struct ptp_clock_info *ptp, s64 delta)\n{\n\tstruct macb *bp = container_of(ptp, struct macb, ptp_clock_info);\n\tstruct timespec64 now, then = ns_to_timespec64(delta);\n\tu32 adj, sign = 0;\n\n\tif (delta < 0) {\n\t\tsign = 1;\n\t\tdelta = -delta;\n\t}\n\n\tif (delta > TSU_NSEC_MAX_VAL) {\n\t\tgem_tsu_get_time(&bp->ptp_clock_info, &now, NULL);\n\t\tnow = timespec64_add(now, then);\n\n\t\tgem_tsu_set_time(&bp->ptp_clock_info,\n\t\t\t\t (const struct timespec64 *)&now);\n\t} else {\n\t\tadj = (sign << GEM_ADDSUB_OFFSET) | delta;\n\n\t\tgem_writel(bp, TA, adj);\n\t}\n\n\treturn 0;\n}\n\nstatic int gem_ptp_enable(struct ptp_clock_info *ptp,\n\t\t\t  struct ptp_clock_request *rq, int on)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic const struct ptp_clock_info gem_ptp_caps_template = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= GEM_PTP_TIMER_NAME,\n\t.max_adj\t= 0,\n\t.n_alarm\t= 0,\n\t.n_ext_ts\t= 0,\n\t.n_per_out\t= 0,\n\t.n_pins\t\t= 0,\n\t.pps\t\t= 1,\n\t.adjfine\t= gem_ptp_adjfine,\n\t.adjtime\t= gem_ptp_adjtime,\n\t.gettimex64\t= gem_tsu_get_time,\n\t.settime64\t= gem_tsu_set_time,\n\t.enable\t\t= gem_ptp_enable,\n};\n\nstatic void gem_ptp_init_timer(struct macb *bp)\n{\n\tu32 rem = 0;\n\tu64 adj;\n\n\tbp->tsu_incr.ns = div_u64_rem(NSEC_PER_SEC, bp->tsu_rate, &rem);\n\tif (rem) {\n\t\tadj = rem;\n\t\tadj <<= GEM_SUBNSINCR_SIZE;\n\t\tbp->tsu_incr.sub_ns = div_u64(adj, bp->tsu_rate);\n\t} else {\n\t\tbp->tsu_incr.sub_ns = 0;\n\t}\n}\n\nstatic void gem_ptp_init_tsu(struct macb *bp)\n{\n\tstruct timespec64 ts;\n\n\t \n\tts = ns_to_timespec64(ktime_to_ns(ktime_get_real()));\n\n\t \n\tgem_tsu_set_time(&bp->ptp_clock_info, &ts);\n\n\t \n\tgem_tsu_incr_set(bp, &bp->tsu_incr);\n\n\tgem_writel(bp, TA, 0);\n}\n\nstatic void gem_ptp_clear_timer(struct macb *bp)\n{\n\tbp->tsu_incr.sub_ns = 0;\n\tbp->tsu_incr.ns = 0;\n\n\tgem_writel(bp, TISUBN, GEM_BF(SUBNSINCR, 0));\n\tgem_writel(bp, TI, GEM_BF(NSINCR, 0));\n\tgem_writel(bp, TA, 0);\n}\n\nstatic int gem_hw_timestamp(struct macb *bp, u32 dma_desc_ts_1,\n\t\t\t    u32 dma_desc_ts_2, struct timespec64 *ts)\n{\n\tstruct timespec64 tsu;\n\n\tts->tv_sec = (GEM_BFEXT(DMA_SECH, dma_desc_ts_2) << GEM_DMA_SECL_SIZE) |\n\t\t\tGEM_BFEXT(DMA_SECL, dma_desc_ts_1);\n\tts->tv_nsec = GEM_BFEXT(DMA_NSEC, dma_desc_ts_1);\n\n\t \n\tgem_tsu_get_time(&bp->ptp_clock_info, &tsu, NULL);\n\n\tts->tv_sec |= ((~GEM_DMA_SEC_MASK) & tsu.tv_sec);\n\n\t \n\tif ((ts->tv_sec & (GEM_DMA_SEC_TOP >> 1)) &&\n\t    !(tsu.tv_sec & (GEM_DMA_SEC_TOP >> 1)))\n\t\tts->tv_sec -= GEM_DMA_SEC_TOP;\n\n\treturn 0;\n}\n\nvoid gem_ptp_rxstamp(struct macb *bp, struct sk_buff *skb,\n\t\t     struct macb_dma_desc *desc)\n{\n\tstruct skb_shared_hwtstamps *shhwtstamps = skb_hwtstamps(skb);\n\tstruct macb_dma_desc_ptp *desc_ptp;\n\tstruct timespec64 ts;\n\n\tif (GEM_BFEXT(DMA_RXVALID, desc->addr)) {\n\t\tdesc_ptp = macb_ptp_desc(bp, desc);\n\t\t \n\t\tif (!desc_ptp) {\n\t\t\tdev_warn_ratelimited(&bp->pdev->dev,\n\t\t\t\t\t     \"Timestamp not supported in BD\\n\");\n\t\t\treturn;\n\t\t}\n\t\tgem_hw_timestamp(bp, desc_ptp->ts_1, desc_ptp->ts_2, &ts);\n\t\tmemset(shhwtstamps, 0, sizeof(struct skb_shared_hwtstamps));\n\t\tshhwtstamps->hwtstamp = ktime_set(ts.tv_sec, ts.tv_nsec);\n\t}\n}\n\nvoid gem_ptp_txstamp(struct macb *bp, struct sk_buff *skb,\n\t\t     struct macb_dma_desc *desc)\n{\n\tstruct skb_shared_hwtstamps shhwtstamps;\n\tstruct macb_dma_desc_ptp *desc_ptp;\n\tstruct timespec64 ts;\n\n\tif (!GEM_BFEXT(DMA_TXVALID, desc->ctrl)) {\n\t\tdev_warn_ratelimited(&bp->pdev->dev,\n\t\t\t\t     \"Timestamp not set in TX BD as expected\\n\");\n\t\treturn;\n\t}\n\n\tdesc_ptp = macb_ptp_desc(bp, desc);\n\t \n\tif (!desc_ptp) {\n\t\tdev_warn_ratelimited(&bp->pdev->dev,\n\t\t\t\t     \"Timestamp not supported in BD\\n\");\n\t\treturn;\n\t}\n\n\t \n\tdma_rmb();\n\tgem_hw_timestamp(bp, desc_ptp->ts_1, desc_ptp->ts_2, &ts);\n\n\tmemset(&shhwtstamps, 0, sizeof(shhwtstamps));\n\tshhwtstamps.hwtstamp = ktime_set(ts.tv_sec, ts.tv_nsec);\n\tskb_tstamp_tx(skb, &shhwtstamps);\n}\n\nvoid gem_ptp_init(struct net_device *dev)\n{\n\tstruct macb *bp = netdev_priv(dev);\n\n\tbp->ptp_clock_info = gem_ptp_caps_template;\n\n\t \n\tbp->tsu_rate = bp->ptp_info->get_tsu_rate(bp);\n\tbp->ptp_clock_info.max_adj = bp->ptp_info->get_ptp_max_adj();\n\tgem_ptp_init_timer(bp);\n\tbp->ptp_clock = ptp_clock_register(&bp->ptp_clock_info, &dev->dev);\n\tif (IS_ERR(bp->ptp_clock)) {\n\t\tpr_err(\"ptp clock register failed: %ld\\n\",\n\t\t\tPTR_ERR(bp->ptp_clock));\n\t\tbp->ptp_clock = NULL;\n\t\treturn;\n\t} else if (bp->ptp_clock == NULL) {\n\t\tpr_err(\"ptp clock register failed\\n\");\n\t\treturn;\n\t}\n\n\tspin_lock_init(&bp->tsu_clk_lock);\n\n\tgem_ptp_init_tsu(bp);\n\n\tdev_info(&bp->pdev->dev, \"%s ptp clock registered.\\n\",\n\t\t GEM_PTP_TIMER_NAME);\n}\n\nvoid gem_ptp_remove(struct net_device *ndev)\n{\n\tstruct macb *bp = netdev_priv(ndev);\n\n\tif (bp->ptp_clock)\n\t\tptp_clock_unregister(bp->ptp_clock);\n\n\tgem_ptp_clear_timer(bp);\n\n\tdev_info(&bp->pdev->dev, \"%s ptp clock unregistered.\\n\",\n\t\t GEM_PTP_TIMER_NAME);\n}\n\nstatic int gem_ptp_set_ts_mode(struct macb *bp,\n\t\t\t       enum macb_bd_control tx_bd_control,\n\t\t\t       enum macb_bd_control rx_bd_control)\n{\n\tgem_writel(bp, TXBDCTRL, GEM_BF(TXTSMODE, tx_bd_control));\n\tgem_writel(bp, RXBDCTRL, GEM_BF(RXTSMODE, rx_bd_control));\n\n\treturn 0;\n}\n\nint gem_get_hwtst(struct net_device *dev, struct ifreq *rq)\n{\n\tstruct hwtstamp_config *tstamp_config;\n\tstruct macb *bp = netdev_priv(dev);\n\n\ttstamp_config = &bp->tstamp_config;\n\tif ((bp->hw_dma_cap & HW_DMA_CAP_PTP) == 0)\n\t\treturn -EOPNOTSUPP;\n\n\tif (copy_to_user(rq->ifr_data, tstamp_config, sizeof(*tstamp_config)))\n\t\treturn -EFAULT;\n\telse\n\t\treturn 0;\n}\n\nstatic void gem_ptp_set_one_step_sync(struct macb *bp, u8 enable)\n{\n\tu32 reg_val;\n\n\treg_val = macb_readl(bp, NCR);\n\n\tif (enable)\n\t\tmacb_writel(bp, NCR, reg_val | MACB_BIT(OSSMODE));\n\telse\n\t\tmacb_writel(bp, NCR, reg_val & ~MACB_BIT(OSSMODE));\n}\n\nint gem_set_hwtst(struct net_device *dev, struct ifreq *ifr, int cmd)\n{\n\tenum macb_bd_control tx_bd_control = TSTAMP_DISABLED;\n\tenum macb_bd_control rx_bd_control = TSTAMP_DISABLED;\n\tstruct hwtstamp_config *tstamp_config;\n\tstruct macb *bp = netdev_priv(dev);\n\tu32 regval;\n\n\ttstamp_config = &bp->tstamp_config;\n\tif ((bp->hw_dma_cap & HW_DMA_CAP_PTP) == 0)\n\t\treturn -EOPNOTSUPP;\n\n\tif (copy_from_user(tstamp_config, ifr->ifr_data,\n\t\t\t   sizeof(*tstamp_config)))\n\t\treturn -EFAULT;\n\n\tswitch (tstamp_config->tx_type) {\n\tcase HWTSTAMP_TX_OFF:\n\t\tbreak;\n\tcase HWTSTAMP_TX_ONESTEP_SYNC:\n\t\tgem_ptp_set_one_step_sync(bp, 1);\n\t\ttx_bd_control = TSTAMP_ALL_FRAMES;\n\t\tbreak;\n\tcase HWTSTAMP_TX_ON:\n\t\tgem_ptp_set_one_step_sync(bp, 0);\n\t\ttx_bd_control = TSTAMP_ALL_FRAMES;\n\t\tbreak;\n\tdefault:\n\t\treturn -ERANGE;\n\t}\n\n\tswitch (tstamp_config->rx_filter) {\n\tcase HWTSTAMP_FILTER_NONE:\n\t\tbreak;\n\tcase HWTSTAMP_FILTER_PTP_V1_L4_SYNC:\n\t\tbreak;\n\tcase HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ:\n\t\tbreak;\n\tcase HWTSTAMP_FILTER_PTP_V2_EVENT:\n\tcase HWTSTAMP_FILTER_PTP_V2_L2_EVENT:\n\tcase HWTSTAMP_FILTER_PTP_V2_L4_EVENT:\n\tcase HWTSTAMP_FILTER_PTP_V2_SYNC:\n\tcase HWTSTAMP_FILTER_PTP_V2_L2_SYNC:\n\tcase HWTSTAMP_FILTER_PTP_V2_L4_SYNC:\n\tcase HWTSTAMP_FILTER_PTP_V2_DELAY_REQ:\n\tcase HWTSTAMP_FILTER_PTP_V2_L2_DELAY_REQ:\n\tcase HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ:\n\t\trx_bd_control =  TSTAMP_ALL_PTP_FRAMES;\n\t\ttstamp_config->rx_filter = HWTSTAMP_FILTER_PTP_V2_EVENT;\n\t\tregval = macb_readl(bp, NCR);\n\t\tmacb_writel(bp, NCR, (regval | MACB_BIT(SRTSM)));\n\t\tbreak;\n\tcase HWTSTAMP_FILTER_PTP_V1_L4_EVENT:\n\tcase HWTSTAMP_FILTER_ALL:\n\t\trx_bd_control = TSTAMP_ALL_FRAMES;\n\t\ttstamp_config->rx_filter = HWTSTAMP_FILTER_ALL;\n\t\tbreak;\n\tdefault:\n\t\ttstamp_config->rx_filter = HWTSTAMP_FILTER_NONE;\n\t\treturn -ERANGE;\n\t}\n\n\tif (gem_ptp_set_ts_mode(bp, tx_bd_control, rx_bd_control) != 0)\n\t\treturn -ERANGE;\n\n\tif (copy_to_user(ifr->ifr_data, tstamp_config, sizeof(*tstamp_config)))\n\t\treturn -EFAULT;\n\telse\n\t\treturn 0;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}