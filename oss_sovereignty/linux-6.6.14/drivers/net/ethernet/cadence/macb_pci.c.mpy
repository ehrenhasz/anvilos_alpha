{
  "module_name": "macb_pci.c",
  "hash_id": "6cba1c4fed60028000b81b5c1e4913fbc676ea7857d92f533bccf167bf5f6ec6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/cadence/macb_pci.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/etherdevice.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/platform_device.h>\n#include \"macb.h\"\n\n#define PCI_DRIVER_NAME \"macb_pci\"\n#define PLAT_DRIVER_NAME \"macb\"\n\n#define CDNS_VENDOR_ID 0x17cd\n#define CDNS_DEVICE_ID 0xe007\n\n#define GEM_PCLK_RATE 50000000\n#define GEM_HCLK_RATE 50000000\n\nstatic int macb_probe(struct pci_dev *pdev, const struct pci_device_id *id)\n{\n\tint err;\n\tstruct platform_device *plat_dev;\n\tstruct platform_device_info plat_info;\n\tstruct macb_platform_data plat_data;\n\tstruct resource res[2];\n\n\t \n\terr = pcim_enable_device(pdev);\n\tif (err < 0) {\n\t\tdev_err(&pdev->dev, \"Enabling PCI device has failed: %d\", err);\n\t\treturn err;\n\t}\n\n\tpci_set_master(pdev);\n\n\t \n\tmemset(res, 0x00, sizeof(struct resource) * ARRAY_SIZE(res));\n\tres[0].start = pci_resource_start(pdev, 0);\n\tres[0].end = pci_resource_end(pdev, 0);\n\tres[0].name = PCI_DRIVER_NAME;\n\tres[0].flags = IORESOURCE_MEM;\n\tres[1].start = pci_irq_vector(pdev, 0);\n\tres[1].name = PCI_DRIVER_NAME;\n\tres[1].flags = IORESOURCE_IRQ;\n\n\tdev_info(&pdev->dev, \"EMAC physical base addr: %pa\\n\",\n\t\t &res[0].start);\n\n\t \n\tmemset(&plat_data, 0, sizeof(plat_data));\n\n\t \n\tplat_data.pclk = clk_register_fixed_rate(&pdev->dev, \"pclk\", NULL, 0,\n\t\t\t\t\t\t GEM_PCLK_RATE);\n\tif (IS_ERR(plat_data.pclk)) {\n\t\terr = PTR_ERR(plat_data.pclk);\n\t\tgoto err_pclk_register;\n\t}\n\n\tplat_data.hclk = clk_register_fixed_rate(&pdev->dev, \"hclk\", NULL, 0,\n\t\t\t\t\t\t GEM_HCLK_RATE);\n\tif (IS_ERR(plat_data.hclk)) {\n\t\terr = PTR_ERR(plat_data.hclk);\n\t\tgoto err_hclk_register;\n\t}\n\n\t \n\tmemset(&plat_info, 0, sizeof(plat_info));\n\tplat_info.parent = &pdev->dev;\n\tplat_info.fwnode = pdev->dev.fwnode;\n\tplat_info.name = PLAT_DRIVER_NAME;\n\tplat_info.id = pdev->devfn;\n\tplat_info.res = res;\n\tplat_info.num_res = ARRAY_SIZE(res);\n\tplat_info.data = &plat_data;\n\tplat_info.size_data = sizeof(plat_data);\n\tplat_info.dma_mask = pdev->dma_mask;\n\n\t \n\tplat_dev = platform_device_register_full(&plat_info);\n\tif (IS_ERR(plat_dev)) {\n\t\terr = PTR_ERR(plat_dev);\n\t\tgoto err_plat_dev_register;\n\t}\n\n\tpci_set_drvdata(pdev, plat_dev);\n\n\treturn 0;\n\nerr_plat_dev_register:\n\tclk_unregister(plat_data.hclk);\n\nerr_hclk_register:\n\tclk_unregister(plat_data.pclk);\n\nerr_pclk_register:\n\treturn err;\n}\n\nstatic void macb_remove(struct pci_dev *pdev)\n{\n\tstruct platform_device *plat_dev = pci_get_drvdata(pdev);\n\tstruct macb_platform_data *plat_data = dev_get_platdata(&plat_dev->dev);\n\n\tclk_unregister(plat_data->pclk);\n\tclk_unregister(plat_data->hclk);\n\tplatform_device_unregister(plat_dev);\n}\n\nstatic const struct pci_device_id dev_id_table[] = {\n\t{ PCI_DEVICE(CDNS_VENDOR_ID, CDNS_DEVICE_ID), },\n\t{ 0, }\n};\n\nstatic struct pci_driver macb_pci_driver = {\n\t.name     = PCI_DRIVER_NAME,\n\t.id_table = dev_id_table,\n\t.probe    = macb_probe,\n\t.remove\t  = macb_remove,\n};\n\nmodule_pci_driver(macb_pci_driver);\nMODULE_DEVICE_TABLE(pci, dev_id_table);\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Cadence NIC PCI wrapper\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}