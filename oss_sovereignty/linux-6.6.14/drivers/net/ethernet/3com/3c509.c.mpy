{
  "module_name": "3c509.c",
  "hash_id": "0b00a5913e9847e31ff3119ab38f8583d46b788cb083c7db074a4fed9972e446",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/3com/3c509.c",
  "human_readable_source": " \n \n\n#define DRV_NAME\t\"3c509\"\n\n \n\n \n#define TX_TIMEOUT  (400*HZ/1000)\n\n#include <linux/module.h>\n#include <linux/isa.h>\n#include <linux/pnp.h>\n#include <linux/string.h>\n#include <linux/interrupt.h>\n#include <linux/errno.h>\n#include <linux/in.h>\n#include <linux/ioport.h>\n#include <linux/init.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/pm.h>\n#include <linux/skbuff.h>\n#include <linux/delay.h>\t \n#include <linux/spinlock.h>\n#include <linux/ethtool.h>\n#include <linux/device.h>\n#include <linux/eisa.h>\n#include <linux/bitops.h>\n\n#include <linux/uaccess.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n\n#ifdef EL3_DEBUG\nstatic int el3_debug = EL3_DEBUG;\n#else\nstatic int el3_debug = 2;\n#endif\n\n \nstatic int el3_cards = 0;\n#define EL3_MAX_CARDS 8\n\n \n \n#define EL3_DATA 0x00\n#define EL3_CMD 0x0e\n#define EL3_STATUS 0x0e\n#define\tEEPROM_READ 0x80\n\n#define EL3_IO_EXTENT\t16\n\n#define EL3WINDOW(win_num) outw(SelectWindow + (win_num), ioaddr + EL3_CMD)\n\n\n \nenum c509cmd {\n\tTotalReset = 0<<11, SelectWindow = 1<<11, StartCoax = 2<<11,\n\tRxDisable = 3<<11, RxEnable = 4<<11, RxReset = 5<<11, RxDiscard = 8<<11,\n\tTxEnable = 9<<11, TxDisable = 10<<11, TxReset = 11<<11,\n\tFakeIntr = 12<<11, AckIntr = 13<<11, SetIntrEnb = 14<<11,\n\tSetStatusEnb = 15<<11, SetRxFilter = 16<<11, SetRxThreshold = 17<<11,\n\tSetTxThreshold = 18<<11, SetTxStart = 19<<11, StatsEnable = 21<<11,\n\tStatsDisable = 22<<11, StopCoax = 23<<11, PowerUp = 27<<11,\n\tPowerDown = 28<<11, PowerAuto = 29<<11};\n\nenum c509status {\n\tIntLatch = 0x0001, AdapterFailure = 0x0002, TxComplete = 0x0004,\n\tTxAvailable = 0x0008, RxComplete = 0x0010, RxEarly = 0x0020,\n\tIntReq = 0x0040, StatsFull = 0x0080, CmdBusy = 0x1000, };\n\n \nenum RxFilter {\n\tRxStation = 1, RxMulticast = 2, RxBroadcast = 4, RxProm = 8 };\n\n \n#define TX_FIFO\t\t0x00\n#define RX_FIFO\t\t0x00\n#define RX_STATUS \t0x08\n#define TX_STATUS \t0x0B\n#define TX_FREE\t\t0x0C\t\t \n\n#define WN0_CONF_CTRL\t0x04\t\t \n#define WN0_ADDR_CONF\t0x06\t\t \n#define WN0_IRQ\t\t0x08\t\t \n#define WN4_MEDIA\t0x0A\t\t \n#define\tMEDIA_TP\t0x00C0\t\t \n#define WN4_NETDIAG\t0x06\t\t \n#define FD_ENABLE\t0x8000\t\t \n\n \n#define SKB_QUEUE_SIZE\t64\n\nenum el3_cardtype { EL3_ISA, EL3_PNP, EL3_EISA };\n\nstruct el3_private {\n\tspinlock_t lock;\n\t \n\tint head, size;\n\tstruct sk_buff *queue[SKB_QUEUE_SIZE];\n\tenum el3_cardtype type;\n};\nstatic int id_port;\nstatic int current_tag;\nstatic struct net_device *el3_devs[EL3_MAX_CARDS];\n\n \nstatic int debug = -1;\nstatic int irq[] = {-1, -1, -1, -1, -1, -1, -1, -1};\n \nstatic int max_interrupt_work = 10;\n#ifdef CONFIG_PNP\nstatic int nopnp;\n#endif\n\nstatic int el3_common_init(struct net_device *dev);\nstatic void el3_common_remove(struct net_device *dev);\nstatic ushort id_read_eeprom(int index);\nstatic ushort read_eeprom(int ioaddr, int index);\nstatic int el3_open(struct net_device *dev);\nstatic netdev_tx_t el3_start_xmit(struct sk_buff *skb, struct net_device *dev);\nstatic irqreturn_t el3_interrupt(int irq, void *dev_id);\nstatic void update_stats(struct net_device *dev);\nstatic struct net_device_stats *el3_get_stats(struct net_device *dev);\nstatic int el3_rx(struct net_device *dev);\nstatic int el3_close(struct net_device *dev);\nstatic void set_multicast_list(struct net_device *dev);\nstatic void el3_tx_timeout (struct net_device *dev, unsigned int txqueue);\nstatic void el3_down(struct net_device *dev);\nstatic void el3_up(struct net_device *dev);\nstatic const struct ethtool_ops ethtool_ops;\n#ifdef CONFIG_PM\nstatic int el3_suspend(struct device *, pm_message_t);\nstatic int el3_resume(struct device *);\n#else\n#define el3_suspend NULL\n#define el3_resume NULL\n#endif\n\n\n \nstatic int el3_device_remove (struct device *device);\n#ifdef CONFIG_NET_POLL_CONTROLLER\nstatic void el3_poll_controller(struct net_device *dev);\n#endif\n\n \nstatic int el3_isa_id_sequence(__be16 *phys_addr)\n{\n\tshort lrs_state = 0xff;\n\tint i;\n\n\t \n\n\toutb(0x00, id_port);\n\toutb(0x00, id_port);\n\tfor (i = 0; i < 255; i++) {\n\t\toutb(lrs_state, id_port);\n\t\tlrs_state <<= 1;\n\t\tlrs_state = lrs_state & 0x100 ? lrs_state ^ 0xcf : lrs_state;\n\t}\n\t \n\tif (current_tag == 0)\n\t\toutb(0xd0, id_port);\n\telse\t\t\t \n\t\toutb(0xd8, id_port);\n\tif (id_read_eeprom(7) != 0x6d50)\n\t\treturn 1;\n\t \n\tfor (i = 0; i < 3; i++)\n\t\tphys_addr[i] = htons(id_read_eeprom(i));\n#ifdef CONFIG_PNP\n\tif (!nopnp) {\n\t\t \n\t\tfor (i = 0; i < el3_cards; i++) {\n\t\t\tstruct el3_private *lp = netdev_priv(el3_devs[i]);\n\t\t\tif (lp->type == EL3_PNP &&\n\t\t\t    ether_addr_equal((u8 *)phys_addr, el3_devs[i]->dev_addr)) {\n\t\t\t\tif (el3_debug > 3)\n\t\t\t\t\tpr_debug(\"3c509 with address %02x %02x %02x %02x %02x %02x was found by ISAPnP\\n\",\n\t\t\t\t\t\tphys_addr[0] & 0xff, phys_addr[0] >> 8,\n\t\t\t\t\t\tphys_addr[1] & 0xff, phys_addr[1] >> 8,\n\t\t\t\t\t\tphys_addr[2] & 0xff, phys_addr[2] >> 8);\n\t\t\t\t \n\t\t\t\toutb(0xd0 + ++current_tag, id_port);\n\t\t\t\treturn 2;\n\t\t\t}\n\t\t}\n\t}\n#endif  \n\treturn 0;\n\n}\n\nstatic void el3_dev_fill(struct net_device *dev, __be16 *phys_addr, int ioaddr,\n\t\t\t int irq, int if_port, enum el3_cardtype type)\n{\n\tstruct el3_private *lp = netdev_priv(dev);\n\n\teth_hw_addr_set(dev, (u8 *)phys_addr);\n\tdev->base_addr = ioaddr;\n\tdev->irq = irq;\n\tdev->if_port = if_port;\n\tlp->type = type;\n}\n\nstatic int el3_isa_match(struct device *pdev, unsigned int ndev)\n{\n\tstruct net_device *dev;\n\tint ioaddr, isa_irq, if_port, err;\n\tunsigned int iobase;\n\t__be16 phys_addr[3];\n\n\twhile ((err = el3_isa_id_sequence(phys_addr)) == 2)\n\t\t;\t \n\tif (err == 1)\n\t\treturn 0;\n\n\tiobase = id_read_eeprom(8);\n\tif_port = iobase >> 14;\n\tioaddr = 0x200 + ((iobase & 0x1f) << 4);\n\tif (irq[el3_cards] > 1 && irq[el3_cards] < 16)\n\t\tisa_irq = irq[el3_cards];\n\telse\n\t\tisa_irq = id_read_eeprom(9) >> 12;\n\n\tdev = alloc_etherdev(sizeof(struct el3_private));\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tSET_NETDEV_DEV(dev, pdev);\n\n\tif (!request_region(ioaddr, EL3_IO_EXTENT, \"3c509-isa\")) {\n\t\tfree_netdev(dev);\n\t\treturn 0;\n\t}\n\n\t \n\toutb(0xd0 + ++current_tag, id_port);\n\n\t \n\toutb((ioaddr >> 4) | 0xe0, id_port);\n\n\tEL3WINDOW(0);\n\tif (inw(ioaddr) != 0x6d50) {\n\t\tfree_netdev(dev);\n\t\treturn 0;\n\t}\n\n\t \n\toutw(0x0f00, ioaddr + WN0_IRQ);\n\n\tel3_dev_fill(dev, phys_addr, ioaddr, isa_irq, if_port, EL3_ISA);\n\tdev_set_drvdata(pdev, dev);\n\tif (el3_common_init(dev)) {\n\t\tfree_netdev(dev);\n\t\treturn 0;\n\t}\n\n\tel3_devs[el3_cards++] = dev;\n\treturn 1;\n}\n\nstatic void el3_isa_remove(struct device *pdev,\n\t\t\t\t    unsigned int ndev)\n{\n\tel3_device_remove(pdev);\n\tdev_set_drvdata(pdev, NULL);\n}\n\n#ifdef CONFIG_PM\nstatic int el3_isa_suspend(struct device *dev, unsigned int n,\n\t\t\t   pm_message_t state)\n{\n\tcurrent_tag = 0;\n\treturn el3_suspend(dev, state);\n}\n\nstatic int el3_isa_resume(struct device *dev, unsigned int n)\n{\n\tstruct net_device *ndev = dev_get_drvdata(dev);\n\tint ioaddr = ndev->base_addr, err;\n\t__be16 phys_addr[3];\n\n\twhile ((err = el3_isa_id_sequence(phys_addr)) == 2)\n\t\t;\t \n\tif (err == 1)\n\t\treturn 0;\n\t \n\toutb(0xd0 + ++current_tag, id_port);\n\t \n\toutb((ioaddr >> 4) | 0xe0, id_port);\n\tEL3WINDOW(0);\n\tif (inw(ioaddr) != 0x6d50)\n\t\treturn 1;\n\t \n\toutw(0x0f00, ioaddr + WN0_IRQ);\n\treturn el3_resume(dev);\n}\n#endif\n\nstatic struct isa_driver el3_isa_driver = {\n\t.match\t\t= el3_isa_match,\n\t.remove\t\t= el3_isa_remove,\n#ifdef CONFIG_PM\n\t.suspend\t= el3_isa_suspend,\n\t.resume\t\t= el3_isa_resume,\n#endif\n\t.driver\t\t= {\n\t\t.name\t= \"3c509\"\n\t},\n};\nstatic int isa_registered;\n\n#ifdef CONFIG_PNP\nstatic const struct pnp_device_id el3_pnp_ids[] = {\n\t{ .id = \"TCM5090\" },  \n\t{ .id = \"TCM5091\" },  \n\t{ .id = \"TCM5094\" },  \n\t{ .id = \"TCM5095\" },  \n\t{ .id = \"TCM5098\" },  \n\t{ .id = \"PNP80f7\" },  \n\t{ .id = \"PNP80f8\" },  \n\t{ .id = \"\" }\n};\nMODULE_DEVICE_TABLE(pnp, el3_pnp_ids);\n\nstatic int el3_pnp_probe(struct pnp_dev *pdev, const struct pnp_device_id *id)\n{\n\tshort i;\n\tint ioaddr, irq, if_port;\n\t__be16 phys_addr[3];\n\tstruct net_device *dev = NULL;\n\tint err;\n\n\tioaddr = pnp_port_start(pdev, 0);\n\tif (!request_region(ioaddr, EL3_IO_EXTENT, \"3c509-pnp\"))\n\t\treturn -EBUSY;\n\tirq = pnp_irq(pdev, 0);\n\tEL3WINDOW(0);\n\tfor (i = 0; i < 3; i++)\n\t\tphys_addr[i] = htons(read_eeprom(ioaddr, i));\n\tif_port = read_eeprom(ioaddr, 8) >> 14;\n\tdev = alloc_etherdev(sizeof(struct el3_private));\n\tif (!dev) {\n\t\trelease_region(ioaddr, EL3_IO_EXTENT);\n\t\treturn -ENOMEM;\n\t}\n\tSET_NETDEV_DEV(dev, &pdev->dev);\n\n\tel3_dev_fill(dev, phys_addr, ioaddr, irq, if_port, EL3_PNP);\n\tpnp_set_drvdata(pdev, dev);\n\terr = el3_common_init(dev);\n\n\tif (err) {\n\t\tpnp_set_drvdata(pdev, NULL);\n\t\tfree_netdev(dev);\n\t\treturn err;\n\t}\n\n\tel3_devs[el3_cards++] = dev;\n\treturn 0;\n}\n\nstatic void el3_pnp_remove(struct pnp_dev *pdev)\n{\n\tel3_common_remove(pnp_get_drvdata(pdev));\n\tpnp_set_drvdata(pdev, NULL);\n}\n\n#ifdef CONFIG_PM\nstatic int el3_pnp_suspend(struct pnp_dev *pdev, pm_message_t state)\n{\n\treturn el3_suspend(&pdev->dev, state);\n}\n\nstatic int el3_pnp_resume(struct pnp_dev *pdev)\n{\n\treturn el3_resume(&pdev->dev);\n}\n#endif\n\nstatic struct pnp_driver el3_pnp_driver = {\n\t.name\t\t= \"3c509\",\n\t.id_table\t= el3_pnp_ids,\n\t.probe\t\t= el3_pnp_probe,\n\t.remove\t\t= el3_pnp_remove,\n#ifdef CONFIG_PM\n\t.suspend\t= el3_pnp_suspend,\n\t.resume\t\t= el3_pnp_resume,\n#endif\n};\nstatic int pnp_registered;\n#endif  \n\n#ifdef CONFIG_EISA\nstatic const struct eisa_device_id el3_eisa_ids[] = {\n\t\t{ \"TCM5090\" },\n\t\t{ \"TCM5091\" },\n\t\t{ \"TCM5092\" },\n\t\t{ \"TCM5093\" },\n\t\t{ \"TCM5094\" },\n\t\t{ \"TCM5095\" },\n\t\t{ \"TCM5098\" },\n\t\t{ \"\" }\n};\nMODULE_DEVICE_TABLE(eisa, el3_eisa_ids);\n\nstatic int el3_eisa_probe (struct device *device);\n\nstatic struct eisa_driver el3_eisa_driver = {\n\t\t.id_table = el3_eisa_ids,\n\t\t.driver   = {\n\t\t\t\t.name    = \"3c579\",\n\t\t\t\t.probe   = el3_eisa_probe,\n\t\t\t\t.remove  = el3_device_remove,\n\t\t\t\t.suspend = el3_suspend,\n\t\t\t\t.resume  = el3_resume,\n\t\t}\n};\nstatic int eisa_registered;\n#endif\n\nstatic const struct net_device_ops netdev_ops = {\n\t.ndo_open \t\t= el3_open,\n\t.ndo_stop\t \t= el3_close,\n\t.ndo_start_xmit \t= el3_start_xmit,\n\t.ndo_get_stats \t\t= el3_get_stats,\n\t.ndo_set_rx_mode\t= set_multicast_list,\n\t.ndo_tx_timeout \t= el3_tx_timeout,\n\t.ndo_set_mac_address \t= eth_mac_addr,\n\t.ndo_validate_addr\t= eth_validate_addr,\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\t.ndo_poll_controller\t= el3_poll_controller,\n#endif\n};\n\nstatic int el3_common_init(struct net_device *dev)\n{\n\tstruct el3_private *lp = netdev_priv(dev);\n\tint err;\n\tstatic const char * const if_names[] = {\n\t\t\"10baseT\", \"AUI\", \"undefined\", \"BNC\"\n\t};\n\n\tspin_lock_init(&lp->lock);\n\n\tif (dev->mem_start & 0x05) {  \n\t\tdev->if_port = (dev->mem_start & 0x0f);\n\t} else {  \n\t\t \n\t\tdev->if_port |= (dev->mem_start & 0x08);\n\t}\n\n\t \n\tdev->netdev_ops = &netdev_ops;\n\tdev->watchdog_timeo = TX_TIMEOUT;\n\tdev->ethtool_ops = &ethtool_ops;\n\n\terr = register_netdev(dev);\n\tif (err) {\n\t\tpr_err(\"Failed to register 3c5x9 at %#3.3lx, IRQ %d.\\n\",\n\t\t\tdev->base_addr, dev->irq);\n\t\trelease_region(dev->base_addr, EL3_IO_EXTENT);\n\t\treturn err;\n\t}\n\n\tpr_info(\"%s: 3c5x9 found at %#3.3lx, %s port, address %pM, IRQ %d.\\n\",\n\t       dev->name, dev->base_addr, if_names[(dev->if_port & 0x03)],\n\t       dev->dev_addr, dev->irq);\n\n\treturn 0;\n\n}\n\nstatic void el3_common_remove (struct net_device *dev)\n{\n\tunregister_netdev (dev);\n\trelease_region(dev->base_addr, EL3_IO_EXTENT);\n\tfree_netdev (dev);\n}\n\n#ifdef CONFIG_EISA\nstatic int el3_eisa_probe(struct device *device)\n{\n\tshort i;\n\tint ioaddr, irq, if_port;\n\t__be16 phys_addr[3];\n\tstruct net_device *dev = NULL;\n\tstruct eisa_device *edev;\n\tint err;\n\n\t \n\tedev = to_eisa_device (device);\n\tioaddr = edev->base_addr;\n\n\tif (!request_region(ioaddr, EL3_IO_EXTENT, \"3c579-eisa\"))\n\t\treturn -EBUSY;\n\n\t \n\toutw(SelectWindow | 0, ioaddr + 0xC80 + EL3_CMD);\n\n\tirq = inw(ioaddr + WN0_IRQ) >> 12;\n\tif_port = inw(ioaddr + 6)>>14;\n\tfor (i = 0; i < 3; i++)\n\t\tphys_addr[i] = htons(read_eeprom(ioaddr, i));\n\n\t \n\tread_eeprom(ioaddr, 3);\n\n\tdev = alloc_etherdev(sizeof (struct el3_private));\n\tif (dev == NULL) {\n\t\trelease_region(ioaddr, EL3_IO_EXTENT);\n\t\treturn -ENOMEM;\n\t}\n\n\tSET_NETDEV_DEV(dev, device);\n\n\tel3_dev_fill(dev, phys_addr, ioaddr, irq, if_port, EL3_EISA);\n\teisa_set_drvdata (edev, dev);\n\terr = el3_common_init(dev);\n\n\tif (err) {\n\t\teisa_set_drvdata (edev, NULL);\n\t\tfree_netdev(dev);\n\t\treturn err;\n\t}\n\n\tel3_devs[el3_cards++] = dev;\n\treturn 0;\n}\n#endif\n\n \nstatic int el3_device_remove(struct device *device)\n{\n\tstruct net_device *dev;\n\n\tdev = dev_get_drvdata(device);\n\n\tel3_common_remove (dev);\n\treturn 0;\n}\n\n \nstatic ushort read_eeprom(int ioaddr, int index)\n{\n\toutw(EEPROM_READ + index, ioaddr + 10);\n\t \n\tmdelay(2);\n\treturn inw(ioaddr + 12);\n}\n\n \nstatic ushort id_read_eeprom(int index)\n{\n\tint bit, word = 0;\n\n\t \n\toutb(EEPROM_READ + index, id_port);\n\n\t \n\t \n\tmdelay(4);\n\n\tfor (bit = 15; bit >= 0; bit--)\n\t\tword = (word << 1) + (inb(id_port) & 0x01);\n\n\tif (el3_debug > 3)\n\t\tpr_debug(\"  3c509 EEPROM word %d %#4.4x.\\n\", index, word);\n\n\treturn word;\n}\n\n\nstatic int\nel3_open(struct net_device *dev)\n{\n\tint ioaddr = dev->base_addr;\n\tint i;\n\n\toutw(TxReset, ioaddr + EL3_CMD);\n\toutw(RxReset, ioaddr + EL3_CMD);\n\toutw(SetStatusEnb | 0x00, ioaddr + EL3_CMD);\n\n\ti = request_irq(dev->irq, el3_interrupt, 0, dev->name, dev);\n\tif (i)\n\t\treturn i;\n\n\tEL3WINDOW(0);\n\tif (el3_debug > 3)\n\t\tpr_debug(\"%s: Opening, IRQ %d\t status@%x %4.4x.\\n\", dev->name,\n\t\t\t   dev->irq, ioaddr + EL3_STATUS, inw(ioaddr + EL3_STATUS));\n\n\tel3_up(dev);\n\n\tif (el3_debug > 3)\n\t\tpr_debug(\"%s: Opened 3c509  IRQ %d  status %4.4x.\\n\",\n\t\t\t   dev->name, dev->irq, inw(ioaddr + EL3_STATUS));\n\n\treturn 0;\n}\n\nstatic void\nel3_tx_timeout (struct net_device *dev, unsigned int txqueue)\n{\n\tint ioaddr = dev->base_addr;\n\n\t \n\tpr_warn(\"%s: transmit timed out, Tx_status %2.2x status %4.4x Tx FIFO room %d\\n\",\n\t\tdev->name, inb(ioaddr + TX_STATUS), inw(ioaddr + EL3_STATUS),\n\t\tinw(ioaddr + TX_FREE));\n\tdev->stats.tx_errors++;\n\tnetif_trans_update(dev);  \n\t \n\toutw(TxReset, ioaddr + EL3_CMD);\n\toutw(TxEnable, ioaddr + EL3_CMD);\n\tnetif_wake_queue(dev);\n}\n\n\nstatic netdev_tx_t\nel3_start_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct el3_private *lp = netdev_priv(dev);\n\tint ioaddr = dev->base_addr;\n\tunsigned long flags;\n\n\tnetif_stop_queue (dev);\n\n\tdev->stats.tx_bytes += skb->len;\n\n\tif (el3_debug > 4) {\n\t\tpr_debug(\"%s: el3_start_xmit(length = %u) called, status %4.4x.\\n\",\n\t\t\t   dev->name, skb->len, inw(ioaddr + EL3_STATUS));\n\t}\n\t \n\n\tspin_lock_irqsave(&lp->lock, flags);\n\n\t \n\toutw(skb->len, ioaddr + TX_FIFO);\n\toutw(0x00, ioaddr + TX_FIFO);\n\t \n\toutsl(ioaddr + TX_FIFO, skb->data, (skb->len + 3) >> 2);\n\n\tif (inw(ioaddr + TX_FREE) > 1536)\n\t\tnetif_start_queue(dev);\n\telse\n\t\t \n\t\toutw(SetTxThreshold + 1536, ioaddr + EL3_CMD);\n\n\tspin_unlock_irqrestore(&lp->lock, flags);\n\n\tdev_consume_skb_any (skb);\n\n\t \n\t{\n\t\tshort tx_status;\n\t\tint i = 4;\n\n\t\twhile (--i > 0\t&&\t(tx_status = inb(ioaddr + TX_STATUS)) > 0) {\n\t\t\tif (tx_status & 0x38) dev->stats.tx_aborted_errors++;\n\t\t\tif (tx_status & 0x30) outw(TxReset, ioaddr + EL3_CMD);\n\t\t\tif (tx_status & 0x3C) outw(TxEnable, ioaddr + EL3_CMD);\n\t\t\toutb(0x00, ioaddr + TX_STATUS);  \n\t\t}\n\t}\n\treturn NETDEV_TX_OK;\n}\n\n \nstatic irqreturn_t\nel3_interrupt(int irq, void *dev_id)\n{\n\tstruct net_device *dev = dev_id;\n\tstruct el3_private *lp;\n\tint ioaddr, status;\n\tint i = max_interrupt_work;\n\n\tlp = netdev_priv(dev);\n\tspin_lock(&lp->lock);\n\n\tioaddr = dev->base_addr;\n\n\tif (el3_debug > 4) {\n\t\tstatus = inw(ioaddr + EL3_STATUS);\n\t\tpr_debug(\"%s: interrupt, status %4.4x.\\n\", dev->name, status);\n\t}\n\n\twhile ((status = inw(ioaddr + EL3_STATUS)) &\n\t\t   (IntLatch | RxComplete | StatsFull)) {\n\n\t\tif (status & RxComplete)\n\t\t\tel3_rx(dev);\n\n\t\tif (status & TxAvailable) {\n\t\t\tif (el3_debug > 5)\n\t\t\t\tpr_debug(\"\tTX room bit was handled.\\n\");\n\t\t\t \n\t\t\toutw(AckIntr | TxAvailable, ioaddr + EL3_CMD);\n\t\t\tnetif_wake_queue (dev);\n\t\t}\n\t\tif (status & (AdapterFailure | RxEarly | StatsFull | TxComplete)) {\n\t\t\t \n\t\t\tif (status & StatsFull)\t\t\t\t \n\t\t\t\tupdate_stats(dev);\n\t\t\tif (status & RxEarly) {\t\t\t\t \n\t\t\t\tel3_rx(dev);\n\t\t\t\toutw(AckIntr | RxEarly, ioaddr + EL3_CMD);\n\t\t\t}\n\t\t\tif (status & TxComplete) {\t\t\t \n\t\t\t\tshort tx_status;\n\t\t\t\tint i = 4;\n\n\t\t\t\twhile (--i>0 && (tx_status = inb(ioaddr + TX_STATUS)) > 0) {\n\t\t\t\t\tif (tx_status & 0x38) dev->stats.tx_aborted_errors++;\n\t\t\t\t\tif (tx_status & 0x30) outw(TxReset, ioaddr + EL3_CMD);\n\t\t\t\t\tif (tx_status & 0x3C) outw(TxEnable, ioaddr + EL3_CMD);\n\t\t\t\t\toutb(0x00, ioaddr + TX_STATUS);  \n\t\t\t\t}\n\t\t\t}\n\t\t\tif (status & AdapterFailure) {\n\t\t\t\t \n\t\t\t\toutw(RxReset, ioaddr + EL3_CMD);\n\t\t\t\t \n\t\t\t\toutw(SetRxFilter | RxStation | RxBroadcast\n\t\t\t\t\t | (dev->flags & IFF_ALLMULTI ? RxMulticast : 0)\n\t\t\t\t\t | (dev->flags & IFF_PROMISC ? RxProm : 0),\n\t\t\t\t\t ioaddr + EL3_CMD);\n\t\t\t\toutw(RxEnable, ioaddr + EL3_CMD);  \n\t\t\t\toutw(AckIntr | AdapterFailure, ioaddr + EL3_CMD);\n\t\t\t}\n\t\t}\n\n\t\tif (--i < 0) {\n\t\t\tpr_err(\"%s: Infinite loop in interrupt, status %4.4x.\\n\",\n\t\t\t\t   dev->name, status);\n\t\t\t \n\t\t\toutw(AckIntr | 0xFF, ioaddr + EL3_CMD);\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\toutw(AckIntr | IntReq | IntLatch, ioaddr + EL3_CMD);  \n\t}\n\n\tif (el3_debug > 4) {\n\t\tpr_debug(\"%s: exiting interrupt, status %4.4x.\\n\", dev->name,\n\t\t\t   inw(ioaddr + EL3_STATUS));\n\t}\n\tspin_unlock(&lp->lock);\n\treturn IRQ_HANDLED;\n}\n\n\n#ifdef CONFIG_NET_POLL_CONTROLLER\n \nstatic void el3_poll_controller(struct net_device *dev)\n{\n\tdisable_irq(dev->irq);\n\tel3_interrupt(dev->irq, dev);\n\tenable_irq(dev->irq);\n}\n#endif\n\nstatic struct net_device_stats *\nel3_get_stats(struct net_device *dev)\n{\n\tstruct el3_private *lp = netdev_priv(dev);\n\tunsigned long flags;\n\n\t \n\n\tspin_lock_irqsave(&lp->lock, flags);\n\tupdate_stats(dev);\n\tspin_unlock_irqrestore(&lp->lock, flags);\n\treturn &dev->stats;\n}\n\n \nstatic void update_stats(struct net_device *dev)\n{\n\tint ioaddr = dev->base_addr;\n\n\tif (el3_debug > 5)\n\t\tpr_debug(\"   Updating the statistics.\\n\");\n\t \n\toutw(StatsDisable, ioaddr + EL3_CMD);\n\t \n\tEL3WINDOW(6);\n\tdev->stats.tx_carrier_errors \t+= inb(ioaddr + 0);\n\tdev->stats.tx_heartbeat_errors\t+= inb(ioaddr + 1);\n\t \t   inb(ioaddr + 2);\n\tdev->stats.collisions\t\t+= inb(ioaddr + 3);\n\tdev->stats.tx_window_errors\t+= inb(ioaddr + 4);\n\tdev->stats.rx_fifo_errors\t+= inb(ioaddr + 5);\n\tdev->stats.tx_packets\t\t+= inb(ioaddr + 6);\n\t \t\t   inb(ioaddr + 7);\n\t \t\t   inb(ioaddr + 8);\n\tinw(ioaddr + 10);\t \n\tinw(ioaddr + 12);\n\n\t \n\tEL3WINDOW(1);\n\toutw(StatsEnable, ioaddr + EL3_CMD);\n}\n\nstatic int\nel3_rx(struct net_device *dev)\n{\n\tint ioaddr = dev->base_addr;\n\tshort rx_status;\n\n\tif (el3_debug > 5)\n\t\tpr_debug(\"   In rx_packet(), status %4.4x, rx_status %4.4x.\\n\",\n\t\t\t   inw(ioaddr+EL3_STATUS), inw(ioaddr+RX_STATUS));\n\twhile ((rx_status = inw(ioaddr + RX_STATUS)) > 0) {\n\t\tif (rx_status & 0x4000) {  \n\t\t\tshort error = rx_status & 0x3800;\n\n\t\t\toutw(RxDiscard, ioaddr + EL3_CMD);\n\t\t\tdev->stats.rx_errors++;\n\t\t\tswitch (error) {\n\t\t\tcase 0x0000:\t\tdev->stats.rx_over_errors++; break;\n\t\t\tcase 0x0800:\t\tdev->stats.rx_length_errors++; break;\n\t\t\tcase 0x1000:\t\tdev->stats.rx_frame_errors++; break;\n\t\t\tcase 0x1800:\t\tdev->stats.rx_length_errors++; break;\n\t\t\tcase 0x2000:\t\tdev->stats.rx_frame_errors++; break;\n\t\t\tcase 0x2800:\t\tdev->stats.rx_crc_errors++; break;\n\t\t\t}\n\t\t} else {\n\t\t\tshort pkt_len = rx_status & 0x7ff;\n\t\t\tstruct sk_buff *skb;\n\n\t\t\tskb = netdev_alloc_skb(dev, pkt_len + 5);\n\t\t\tif (el3_debug > 4)\n\t\t\t\tpr_debug(\"Receiving packet size %d status %4.4x.\\n\",\n\t\t\t\t\t   pkt_len, rx_status);\n\t\t\tif (skb != NULL) {\n\t\t\t\tskb_reserve(skb, 2);      \n\n\t\t\t\t \n\t\t\t\tinsl(ioaddr + RX_FIFO, skb_put(skb,pkt_len),\n\t\t\t\t\t (pkt_len + 3) >> 2);\n\n\t\t\t\toutw(RxDiscard, ioaddr + EL3_CMD);  \n\t\t\t\tskb->protocol = eth_type_trans(skb,dev);\n\t\t\t\tnetif_rx(skb);\n\t\t\t\tdev->stats.rx_bytes += pkt_len;\n\t\t\t\tdev->stats.rx_packets++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\toutw(RxDiscard, ioaddr + EL3_CMD);\n\t\t\tdev->stats.rx_dropped++;\n\t\t\tif (el3_debug)\n\t\t\t\tpr_debug(\"%s: Couldn't allocate a sk_buff of size %d.\\n\",\n\t\t\t\t\t   dev->name, pkt_len);\n\t\t}\n\t\tinw(ioaddr + EL3_STATUS); \t\t\t\t \n\t\twhile (inw(ioaddr + EL3_STATUS) & 0x1000)\n\t\t\tpr_debug(\"\tWaiting for 3c509 to discard packet, status %x.\\n\",\n\t\t\t\t   inw(ioaddr + EL3_STATUS) );\n\t}\n\n\treturn 0;\n}\n\n \nstatic void\nset_multicast_list(struct net_device *dev)\n{\n\tunsigned long flags;\n\tstruct el3_private *lp = netdev_priv(dev);\n\tint ioaddr = dev->base_addr;\n\tint mc_count = netdev_mc_count(dev);\n\n\tif (el3_debug > 1) {\n\t\tstatic int old;\n\t\tif (old != mc_count) {\n\t\t\told = mc_count;\n\t\t\tpr_debug(\"%s: Setting Rx mode to %d addresses.\\n\",\n\t\t\t\t dev->name, mc_count);\n\t\t}\n\t}\n\tspin_lock_irqsave(&lp->lock, flags);\n\tif (dev->flags&IFF_PROMISC) {\n\t\toutw(SetRxFilter | RxStation | RxMulticast | RxBroadcast | RxProm,\n\t\t\t ioaddr + EL3_CMD);\n\t}\n\telse if (mc_count || (dev->flags&IFF_ALLMULTI)) {\n\t\toutw(SetRxFilter | RxStation | RxMulticast | RxBroadcast, ioaddr + EL3_CMD);\n\t}\n\telse\n\t\toutw(SetRxFilter | RxStation | RxBroadcast, ioaddr + EL3_CMD);\n\tspin_unlock_irqrestore(&lp->lock, flags);\n}\n\nstatic int\nel3_close(struct net_device *dev)\n{\n\tint ioaddr = dev->base_addr;\n\tstruct el3_private *lp = netdev_priv(dev);\n\n\tif (el3_debug > 2)\n\t\tpr_debug(\"%s: Shutting down ethercard.\\n\", dev->name);\n\n\tel3_down(dev);\n\n\tfree_irq(dev->irq, dev);\n\t \n\tEL3WINDOW(0);\n\tif (lp->type != EL3_EISA) {\n\t\t \n\t\toutw(0x0f00, ioaddr + WN0_IRQ);\n\t}\n\n\treturn 0;\n}\n\nstatic int\nel3_link_ok(struct net_device *dev)\n{\n\tint ioaddr = dev->base_addr;\n\tu16 tmp;\n\n\tEL3WINDOW(4);\n\ttmp = inw(ioaddr + WN4_MEDIA);\n\tEL3WINDOW(1);\n\treturn tmp & (1<<11);\n}\n\nstatic void\nel3_netdev_get_ecmd(struct net_device *dev, struct ethtool_link_ksettings *cmd)\n{\n\tu16 tmp;\n\tint ioaddr = dev->base_addr;\n\tu32 supported;\n\n\tEL3WINDOW(0);\n\t \n\ttmp = inw(ioaddr + WN0_ADDR_CONF);\n\tswitch (tmp >> 14) {\n\tcase 0:\n\t\tcmd->base.port = PORT_TP;\n\t\tbreak;\n\tcase 1:\n\t\tcmd->base.port = PORT_AUI;\n\t\tbreak;\n\tcase 3:\n\t\tcmd->base.port = PORT_BNC;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tcmd->base.duplex = DUPLEX_HALF;\n\tsupported = 0;\n\ttmp = inw(ioaddr + WN0_CONF_CTRL);\n\tif (tmp & (1<<13))\n\t\tsupported |= SUPPORTED_AUI;\n\tif (tmp & (1<<12))\n\t\tsupported |= SUPPORTED_BNC;\n\tif (tmp & (1<<9)) {\n\t\tsupported |= SUPPORTED_TP | SUPPORTED_10baseT_Half |\n\t\t\t\tSUPPORTED_10baseT_Full;\t \n\t\tEL3WINDOW(4);\n\t\ttmp = inw(ioaddr + WN4_NETDIAG);\n\t\tif (tmp & FD_ENABLE)\n\t\t\tcmd->base.duplex = DUPLEX_FULL;\n\t}\n\n\tethtool_convert_legacy_u32_to_link_mode(cmd->link_modes.supported,\n\t\t\t\t\t\tsupported);\n\tcmd->base.speed = SPEED_10;\n\tEL3WINDOW(1);\n}\n\nstatic int\nel3_netdev_set_ecmd(struct net_device *dev,\n\t\t    const struct ethtool_link_ksettings *cmd)\n{\n\tu16 tmp;\n\tint ioaddr = dev->base_addr;\n\n\tif (cmd->base.speed != SPEED_10)\n\t\treturn -EINVAL;\n\tif ((cmd->base.duplex != DUPLEX_HALF) &&\n\t    (cmd->base.duplex != DUPLEX_FULL))\n\t\treturn -EINVAL;\n\n\t \n\tEL3WINDOW(0);\n\ttmp = inw(ioaddr + WN0_ADDR_CONF);\n\tswitch (cmd->base.port) {\n\tcase PORT_TP:\n\t\ttmp &= ~(3<<14);\n\t\tdev->if_port = 0;\n\t\tbreak;\n\tcase PORT_AUI:\n\t\ttmp |= (1<<14);\n\t\tdev->if_port = 1;\n\t\tbreak;\n\tcase PORT_BNC:\n\t\ttmp |= (3<<14);\n\t\tdev->if_port = 3;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\toutw(tmp, ioaddr + WN0_ADDR_CONF);\n\tif (dev->if_port == 3) {\n\t\t \n\t\ttmp = inw(ioaddr + WN0_ADDR_CONF);\n\t\tif (tmp & (3 << 14)) {\n\t\t\toutw(StartCoax, ioaddr + EL3_CMD);\n\t\t\tudelay(800);\n\t\t} else\n\t\t\treturn -EIO;\n\t}\n\n\tEL3WINDOW(4);\n\ttmp = inw(ioaddr + WN4_NETDIAG);\n\tif (cmd->base.duplex == DUPLEX_FULL)\n\t\ttmp |= FD_ENABLE;\n\telse\n\t\ttmp &= ~FD_ENABLE;\n\toutw(tmp, ioaddr + WN4_NETDIAG);\n\tEL3WINDOW(1);\n\n\treturn 0;\n}\n\nstatic void el3_get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *info)\n{\n\tstrscpy(info->driver, DRV_NAME, sizeof(info->driver));\n}\n\nstatic int el3_get_link_ksettings(struct net_device *dev,\n\t\t\t\t  struct ethtool_link_ksettings *cmd)\n{\n\tstruct el3_private *lp = netdev_priv(dev);\n\n\tspin_lock_irq(&lp->lock);\n\tel3_netdev_get_ecmd(dev, cmd);\n\tspin_unlock_irq(&lp->lock);\n\treturn 0;\n}\n\nstatic int el3_set_link_ksettings(struct net_device *dev,\n\t\t\t\t  const struct ethtool_link_ksettings *cmd)\n{\n\tstruct el3_private *lp = netdev_priv(dev);\n\tint ret;\n\n\tspin_lock_irq(&lp->lock);\n\tret = el3_netdev_set_ecmd(dev, cmd);\n\tspin_unlock_irq(&lp->lock);\n\treturn ret;\n}\n\nstatic u32 el3_get_link(struct net_device *dev)\n{\n\tstruct el3_private *lp = netdev_priv(dev);\n\tu32 ret;\n\n\tspin_lock_irq(&lp->lock);\n\tret = el3_link_ok(dev);\n\tspin_unlock_irq(&lp->lock);\n\treturn ret;\n}\n\nstatic u32 el3_get_msglevel(struct net_device *dev)\n{\n\treturn el3_debug;\n}\n\nstatic void el3_set_msglevel(struct net_device *dev, u32 v)\n{\n\tel3_debug = v;\n}\n\nstatic const struct ethtool_ops ethtool_ops = {\n\t.get_drvinfo = el3_get_drvinfo,\n\t.get_link = el3_get_link,\n\t.get_msglevel = el3_get_msglevel,\n\t.set_msglevel = el3_set_msglevel,\n\t.get_link_ksettings = el3_get_link_ksettings,\n\t.set_link_ksettings = el3_set_link_ksettings,\n};\n\nstatic void\nel3_down(struct net_device *dev)\n{\n\tint ioaddr = dev->base_addr;\n\n\tnetif_stop_queue(dev);\n\n\t \n\toutw(StatsDisable, ioaddr + EL3_CMD);\n\n\t \n\toutw(RxDisable, ioaddr + EL3_CMD);\n\toutw(TxDisable, ioaddr + EL3_CMD);\n\n\tif (dev->if_port == 3)\n\t\t \n\t\toutw(StopCoax, ioaddr + EL3_CMD);\n\telse if (dev->if_port == 0) {\n\t\t \n\t\tEL3WINDOW(4);\n\t\toutw(inw(ioaddr + WN4_MEDIA) & ~MEDIA_TP, ioaddr + WN4_MEDIA);\n\t}\n\n\toutw(SetIntrEnb | 0x0000, ioaddr + EL3_CMD);\n\n\tupdate_stats(dev);\n}\n\nstatic void\nel3_up(struct net_device *dev)\n{\n\tint i, sw_info, net_diag;\n\tint ioaddr = dev->base_addr;\n\n\t \n\toutw(0x0001, ioaddr + 4);\n\n\t \n\toutw((dev->irq << 12) | 0x0f00, ioaddr + WN0_IRQ);\n\n\t \n\tEL3WINDOW(2);\n\n\tfor (i = 0; i < 6; i++)\n\t\toutb(dev->dev_addr[i], ioaddr + i);\n\n\tif ((dev->if_port & 0x03) == 3)  \n\t\t \n\t\toutw(StartCoax, ioaddr + EL3_CMD);\n\telse if ((dev->if_port & 0x03) == 0) {  \n\t\t \n\t\tEL3WINDOW(0);\n\t\tsw_info = (read_eeprom(ioaddr, 0x14) & 0x400f) |\n\t\t\t(read_eeprom(ioaddr, 0x0d) & 0xBff0);\n\n\t\tEL3WINDOW(4);\n\t\tnet_diag = inw(ioaddr + WN4_NETDIAG);\n\t\tnet_diag = (net_diag | FD_ENABLE);  \n\t\tpr_info(\"%s: \", dev->name);\n\t\tswitch (dev->if_port & 0x0c) {\n\t\t\tcase 12:\n\t\t\t\t \n\t\t\t\tif (sw_info & 0x000f) {\n\t\t\t\t\tpr_cont(\"Forcing 3c5x9b full-duplex mode\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfallthrough;\n\t\t\tcase 8:\n\t\t\t\t \n\t\t\t\tif ((sw_info & 0x000f) && (sw_info & 0x8000)) {\n\t\t\t\t\tpr_cont(\"Setting 3c5x9b full-duplex mode (from EEPROM configuration bit)\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfallthrough;\n\t\t\tdefault:\n\t\t\t\t \n\t\t\t\tpr_cont(\"Setting 3c5x9/3c5x9B half-duplex mode\");\n\t\t\t\tnet_diag = (net_diag & ~FD_ENABLE);  \n\t\t}\n\n\t\toutw(net_diag, ioaddr + WN4_NETDIAG);\n\t\tpr_cont(\" if_port: %d, sw_info: %4.4x\\n\", dev->if_port, sw_info);\n\t\tif (el3_debug > 3)\n\t\t\tpr_debug(\"%s: 3c5x9 net diag word is now: %4.4x.\\n\", dev->name, net_diag);\n\t\t \n\t\toutw(inw(ioaddr + WN4_MEDIA) | MEDIA_TP, ioaddr + WN4_MEDIA);\n\t}\n\n\t \n\toutw(StatsDisable, ioaddr + EL3_CMD);\n\tEL3WINDOW(6);\n\tfor (i = 0; i < 9; i++)\n\t\tinb(ioaddr + i);\n\tinw(ioaddr + 10);\n\tinw(ioaddr + 12);\n\n\t \n\tEL3WINDOW(1);\n\n\t \n\toutw(SetRxFilter | RxStation | RxBroadcast, ioaddr + EL3_CMD);\n\toutw(StatsEnable, ioaddr + EL3_CMD);  \n\n\toutw(RxEnable, ioaddr + EL3_CMD);  \n\toutw(TxEnable, ioaddr + EL3_CMD);  \n\t \n\toutw(SetStatusEnb | 0xff, ioaddr + EL3_CMD);\n\t \n\toutw(AckIntr | IntLatch | TxAvailable | RxEarly | IntReq,\n\t\t ioaddr + EL3_CMD);\n\toutw(SetIntrEnb | IntLatch|TxAvailable|TxComplete|RxComplete|StatsFull,\n\t\t ioaddr + EL3_CMD);\n\n\tnetif_start_queue(dev);\n}\n\n \n#ifdef CONFIG_PM\n\nstatic int\nel3_suspend(struct device *pdev, pm_message_t state)\n{\n\tunsigned long flags;\n\tstruct net_device *dev;\n\tstruct el3_private *lp;\n\tint ioaddr;\n\n\tdev = dev_get_drvdata(pdev);\n\tlp = netdev_priv(dev);\n\tioaddr = dev->base_addr;\n\n\tspin_lock_irqsave(&lp->lock, flags);\n\n\tif (netif_running(dev))\n\t\tnetif_device_detach(dev);\n\n\tel3_down(dev);\n\toutw(PowerDown, ioaddr + EL3_CMD);\n\n\tspin_unlock_irqrestore(&lp->lock, flags);\n\treturn 0;\n}\n\nstatic int\nel3_resume(struct device *pdev)\n{\n\tunsigned long flags;\n\tstruct net_device *dev;\n\tstruct el3_private *lp;\n\tint ioaddr;\n\n\tdev = dev_get_drvdata(pdev);\n\tlp = netdev_priv(dev);\n\tioaddr = dev->base_addr;\n\n\tspin_lock_irqsave(&lp->lock, flags);\n\n\toutw(PowerUp, ioaddr + EL3_CMD);\n\tEL3WINDOW(0);\n\tel3_up(dev);\n\n\tif (netif_running(dev))\n\t\tnetif_device_attach(dev);\n\n\tspin_unlock_irqrestore(&lp->lock, flags);\n\treturn 0;\n}\n\n#endif  \n\nmodule_param(debug,int, 0);\nmodule_param_hw_array(irq, int, irq, NULL, 0);\nmodule_param(max_interrupt_work, int, 0);\nMODULE_PARM_DESC(debug, \"debug level (0-6)\");\nMODULE_PARM_DESC(irq, \"IRQ number(s) (assigned)\");\nMODULE_PARM_DESC(max_interrupt_work, \"maximum events handled per interrupt\");\n#ifdef CONFIG_PNP\nmodule_param(nopnp, int, 0);\nMODULE_PARM_DESC(nopnp, \"disable ISA PnP support (0-1)\");\n#endif\t \nMODULE_DESCRIPTION(\"3Com Etherlink III (3c509, 3c509B, 3c529, 3c579) ethernet driver\");\nMODULE_LICENSE(\"GPL\");\n\nstatic int __init el3_init_module(void)\n{\n\tint ret = 0;\n\n\tif (debug >= 0)\n\t\tel3_debug = debug;\n\n#ifdef CONFIG_PNP\n\tif (!nopnp) {\n\t\tret = pnp_register_driver(&el3_pnp_driver);\n\t\tif (!ret)\n\t\t\tpnp_registered = 1;\n\t}\n#endif\n\t \n\t \n\tfor (id_port = 0x110 ; id_port < 0x200; id_port += 0x10) {\n\t\tif (!request_region(id_port, 1, \"3c509-control\"))\n\t\t\tcontinue;\n\t\toutb(0x00, id_port);\n\t\toutb(0xff, id_port);\n\t\tif (inb(id_port) & 0x01)\n\t\t\tbreak;\n\t\telse\n\t\t\trelease_region(id_port, 1);\n\t}\n\tif (id_port >= 0x200) {\n\t\tid_port = 0;\n\t\tpr_err(\"No I/O port available for 3c509 activation.\\n\");\n\t} else {\n\t\tret = isa_register_driver(&el3_isa_driver, EL3_MAX_CARDS);\n\t\tif (!ret)\n\t\t\tisa_registered = 1;\n\t}\n#ifdef CONFIG_EISA\n\tret = eisa_driver_register(&el3_eisa_driver);\n\tif (!ret)\n\t\teisa_registered = 1;\n#endif\n\n#ifdef CONFIG_PNP\n\tif (pnp_registered)\n\t\tret = 0;\n#endif\n\tif (isa_registered)\n\t\tret = 0;\n#ifdef CONFIG_EISA\n\tif (eisa_registered)\n\t\tret = 0;\n#endif\n\treturn ret;\n}\n\nstatic void __exit el3_cleanup_module(void)\n{\n#ifdef CONFIG_PNP\n\tif (pnp_registered)\n\t\tpnp_unregister_driver(&el3_pnp_driver);\n#endif\n\tif (isa_registered)\n\t\tisa_unregister_driver(&el3_isa_driver);\n\tif (id_port)\n\t\trelease_region(id_port, 1);\n#ifdef CONFIG_EISA\n\tif (eisa_registered)\n\t\teisa_driver_unregister(&el3_eisa_driver);\n#endif\n}\n\nmodule_init (el3_init_module);\nmodule_exit (el3_cleanup_module);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}