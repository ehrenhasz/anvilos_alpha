{
  "module_name": "3c515.c",
  "hash_id": "71f8ca0cb251efca6e4fcf56d5fc64106a7c86583a04b16ed6cea8bcba074340",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/3com/3c515.c",
  "human_readable_source": " \n\n#define DRV_NAME\t\t\"3c515\"\n\n#define CORKSCREW 1\n\n \n \nstatic int rx_copybreak = 200;\n\n \nstatic const int mtu = 1500;\n\n \nstatic int max_interrupt_work = 20;\n\n \n#define AUTOMEDIA 1\n\n \n#define VORTEX_BUS_MASTER\n\n \n \n#define TX_RING_SIZE\t16\n#define RX_RING_SIZE\t16\n#define PKT_BUF_SZ\t\t1536\t \n\n#include <linux/module.h>\n#include <linux/isapnp.h>\n#include <linux/kernel.h>\n#include <linux/netdevice.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/in.h>\n#include <linux/ioport.h>\n#include <linux/skbuff.h>\n#include <linux/etherdevice.h>\n#include <linux/interrupt.h>\n#include <linux/timer.h>\n#include <linux/ethtool.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n\n#include <net/Space.h>\n\n#include <asm/io.h>\n#include <asm/dma.h>\n\n#define NEW_MULTICAST\n#include <linux/delay.h>\n\n#define MAX_UNITS 8\n\nMODULE_AUTHOR(\"Donald Becker <becker@scyld.com>\");\nMODULE_DESCRIPTION(\"3Com 3c515 Corkscrew driver\");\nMODULE_LICENSE(\"GPL\");\n\n \n \n#define DRIVER_DEBUG 1\n \nstatic int rx_nocopy, rx_copy, queued_packet;\n\n \n#define WAIT_TX_AVAIL 200\n\n \n#define TX_TIMEOUT  ((4*HZ)/10)\t \n\n \n#define CORKSCREW_TOTAL_SIZE 0x20\n\n#ifdef DRIVER_DEBUG\nstatic int corkscrew_debug = DRIVER_DEBUG;\n#else\nstatic int corkscrew_debug = 1;\n#endif\n\n#define CORKSCREW_ID 10\n\n \n\n \n#define EL3WINDOW(win_num) outw(SelectWindow + (win_num), ioaddr + EL3_CMD)\n#define EL3_CMD 0x0e\n#define EL3_STATUS 0x0e\n\n \n\nenum corkscrew_cmd {\n\tTotalReset = 0 << 11, SelectWindow = 1 << 11, StartCoax = 2 << 11,\n\tRxDisable = 3 << 11, RxEnable = 4 << 11, RxReset = 5 << 11,\n\tUpStall = 6 << 11, UpUnstall = (6 << 11) + 1, DownStall = (6 << 11) + 2,\n\tDownUnstall = (6 << 11) + 3, RxDiscard = 8 << 11, TxEnable = 9 << 11,\n\tTxDisable = 10 << 11, TxReset = 11 << 11, FakeIntr = 12 << 11,\n\tAckIntr = 13 << 11, SetIntrEnb = 14 << 11, SetStatusEnb = 15 << 11,\n\tSetRxFilter = 16 << 11, SetRxThreshold = 17 << 11,\n\tSetTxThreshold = 18 << 11, SetTxStart = 19 << 11, StartDMAUp = 20 << 11,\n\tStartDMADown = (20 << 11) + 1, StatsEnable = 21 << 11,\n\tStatsDisable = 22 << 11, StopCoax = 23 << 11,\n};\n\n \nenum RxFilter {\n\tRxStation = 1, RxMulticast = 2, RxBroadcast = 4, RxProm = 8\n};\n\n \nenum corkscrew_status {\n\tIntLatch = 0x0001, AdapterFailure = 0x0002, TxComplete = 0x0004,\n\tTxAvailable = 0x0008, RxComplete = 0x0010, RxEarly = 0x0020,\n\tIntReq = 0x0040, StatsFull = 0x0080,\n\tDMADone = 1 << 8, DownComplete = 1 << 9, UpComplete = 1 << 10,\n\tDMAInProgress = 1 << 11,\t \n\tCmdInProgress = 1 << 12,\t \n};\n\n \nenum Window1 {\n\tTX_FIFO = 0x10, RX_FIFO = 0x10, RxErrors = 0x14,\n\tRxStatus = 0x18, Timer = 0x1A, TxStatus = 0x1B,\n\tTxFree = 0x1C,\t\t \n};\nenum Window0 {\n\tWn0IRQ = 0x08,\n#if defined(CORKSCREW)\n\tWn0EepromCmd = 0x200A,\t \n\tWn0EepromData = 0x200C,\t \n#else\n\tWn0EepromCmd = 10,\t \n\tWn0EepromData = 12,\t \n#endif\n};\nenum Win0_EEPROM_bits {\n\tEEPROM_Read = 0x80, EEPROM_WRITE = 0x40, EEPROM_ERASE = 0xC0,\n\tEEPROM_EWENB = 0x30,\t \n\tEEPROM_EWDIS = 0x00,\t \n};\n\n \nenum eeprom_offset {\n\tPhysAddr01 = 0, PhysAddr23 = 1, PhysAddr45 = 2, ModelID = 3,\n\tEtherLink3ID = 7,\n};\n\nenum Window3 {\t\t\t \n\tWn3_Config = 0, Wn3_MAC_Ctrl = 6, Wn3_Options = 8,\n};\nenum wn3_config {\n\tRam_size = 7,\n\tRam_width = 8,\n\tRam_speed = 0x30,\n\tRom_size = 0xc0,\n\tRam_split_shift = 16,\n\tRam_split = 3 << Ram_split_shift,\n\tXcvr_shift = 20,\n\tXcvr = 7 << Xcvr_shift,\n\tAutoselect = 0x1000000,\n};\n\nenum Window4 {\n\tWn4_NetDiag = 6, Wn4_Media = 10,\t \n};\nenum Win4_Media_bits {\n\tMedia_SQE = 0x0008,\t \n\tMedia_10TP = 0x00C0,\t \n\tMedia_Lnk = 0x0080,\t \n\tMedia_LnkBeat = 0x0800,\n};\nenum Window7 {\t\t\t \n\tWn7_MasterAddr = 0, Wn7_MasterLen = 6, Wn7_MasterStatus = 12,\n};\n\n \nenum MasterCtrl {\n\tPktStatus = 0x400, DownListPtr = 0x404, FragAddr = 0x408, FragLen =\n\t    0x40c,\n\tTxFreeThreshold = 0x40f, UpPktStatus = 0x410, UpListPtr = 0x418,\n};\n\n \nstruct boom_rx_desc {\n\tu32 next;\n\ts32 status;\n\tu32 addr;\n\ts32 length;\n};\n\n \nenum rx_desc_status {\n\tRxDComplete = 0x00008000, RxDError = 0x4000,\n\t \n};\n\nstruct boom_tx_desc {\n\tu32 next;\n\ts32 status;\n\tu32 addr;\n\ts32 length;\n};\n\nstruct corkscrew_private {\n\tconst char *product_name;\n\tstruct list_head list;\n\tstruct net_device *our_dev;\n\t \n\tstruct boom_rx_desc rx_ring[RX_RING_SIZE];\n\tstruct boom_tx_desc tx_ring[TX_RING_SIZE];\n\t \n\tstruct sk_buff *rx_skbuff[RX_RING_SIZE];\n\tstruct sk_buff *tx_skbuff[TX_RING_SIZE];\n\tunsigned int cur_rx, cur_tx;\t \n\tunsigned int dirty_rx, dirty_tx; \n\tstruct sk_buff *tx_skb;\t \n\tstruct timer_list timer;\t \n\tint capabilities\t;\t \n\tint options;\t\t\t \n\tint last_rx_packets;\t\t \n\tunsigned int available_media:8,\t \n\t\tmedia_override:3,\t \n\t\tdefault_media:3,\t \n\t\tfull_duplex:1, autoselect:1, bus_master:1,\t \n\t\tfull_bus_master_tx:1, full_bus_master_rx:1,\t \n\t\ttx_full:1;\n\tspinlock_t lock;\n\tstruct device *dev;\n};\n\n \nenum xcvr_types {\n\tXCVR_10baseT = 0, XCVR_AUI, XCVR_10baseTOnly, XCVR_10base2, XCVR_100baseTx,\n\tXCVR_100baseFx, XCVR_MII = 6, XCVR_Default = 8,\n};\n\nstatic struct media_table {\n\tchar *name;\n\tunsigned int media_bits:16,\t \n\t\tmask:8,\t\t\t \n\t\tnext:8;\t\t\t \n\tshort wait;\t\t\t \n} media_tbl[] = {\n\t{ \"10baseT\", Media_10TP, 0x08, XCVR_10base2, (14 * HZ) / 10 },\n\t{ \"10Mbs AUI\", Media_SQE, 0x20, XCVR_Default, (1 * HZ) / 10},\n\t{ \"undefined\", 0, 0x80, XCVR_10baseT, 10000},\n\t{ \"10base2\", 0, 0x10, XCVR_AUI, (1 * HZ) / 10},\n\t{ \"100baseTX\", Media_Lnk, 0x02, XCVR_100baseFx, (14 * HZ) / 10},\n\t{ \"100baseFX\", Media_Lnk, 0x04, XCVR_MII, (14 * HZ) / 10},\n\t{ \"MII\", 0, 0x40, XCVR_10baseT, 3 * HZ},\n\t{ \"undefined\", 0, 0x01, XCVR_10baseT, 10000},\n\t{ \"Default\", 0, 0xFF, XCVR_10baseT, 10000},\n};\n\n#ifdef __ISAPNP__\nstatic struct isapnp_device_id corkscrew_isapnp_adapters[] = {\n\t{\tISAPNP_ANY_ID, ISAPNP_ANY_ID,\n\t\tISAPNP_VENDOR('T', 'C', 'M'), ISAPNP_FUNCTION(0x5051),\n\t\t(long) \"3Com Fast EtherLink ISA\" },\n\t{ }\t \n};\n\nMODULE_DEVICE_TABLE(isapnp, corkscrew_isapnp_adapters);\n\nstatic int nopnp;\n#endif  \n\nstatic struct net_device *corkscrew_scan(int unit);\nstatic int corkscrew_setup(struct net_device *dev, int ioaddr,\n\t\t\t    struct pnp_dev *idev, int card_number);\nstatic int corkscrew_open(struct net_device *dev);\nstatic void corkscrew_timer(struct timer_list *t);\nstatic netdev_tx_t corkscrew_start_xmit(struct sk_buff *skb,\n\t\t\t\t\tstruct net_device *dev);\nstatic int corkscrew_rx(struct net_device *dev);\nstatic void corkscrew_timeout(struct net_device *dev, unsigned int txqueue);\nstatic int boomerang_rx(struct net_device *dev);\nstatic irqreturn_t corkscrew_interrupt(int irq, void *dev_id);\nstatic int corkscrew_close(struct net_device *dev);\nstatic void update_stats(int addr, struct net_device *dev);\nstatic struct net_device_stats *corkscrew_get_stats(struct net_device *dev);\nstatic void set_rx_mode(struct net_device *dev);\nstatic const struct ethtool_ops netdev_ethtool_ops;\n\n\n \n \n \nstatic int options[MAX_UNITS] = { -1, -1, -1, -1, -1, -1, -1, -1, };\n\n#ifdef MODULE\nstatic int debug = -1;\n\nmodule_param(debug, int, 0);\nmodule_param_array(options, int, NULL, 0);\nmodule_param(rx_copybreak, int, 0);\nmodule_param(max_interrupt_work, int, 0);\nMODULE_PARM_DESC(debug, \"3c515 debug level (0-6)\");\nMODULE_PARM_DESC(options, \"3c515: Bits 0-2: media type, bit 3: full duplex, bit 4: bus mastering\");\nMODULE_PARM_DESC(rx_copybreak, \"3c515 copy breakpoint for copy-only-tiny-frames\");\nMODULE_PARM_DESC(max_interrupt_work, \"3c515 maximum events handled per interrupt\");\n\n \n \nstatic LIST_HEAD(root_corkscrew_dev);\n\nstatic int corkscrew_init_module(void)\n{\n\tint found = 0;\n\tif (debug >= 0)\n\t\tcorkscrew_debug = debug;\n\twhile (corkscrew_scan(-1))\n\t\tfound++;\n\treturn found ? 0 : -ENODEV;\n}\nmodule_init(corkscrew_init_module);\n\n#else\nstruct net_device *tc515_probe(int unit)\n{\n\tstruct net_device *dev = corkscrew_scan(unit);\n\n\tif (!dev)\n\t\treturn ERR_PTR(-ENODEV);\n\n\treturn dev;\n}\n#endif\t\t\t\t \n\nstatic int check_device(unsigned ioaddr)\n{\n\tint timer;\n\n\tif (!request_region(ioaddr, CORKSCREW_TOTAL_SIZE, \"3c515\"))\n\t\treturn 0;\n\t \n\tif ((inw(ioaddr + 0x2002) & 0x1f0) != (ioaddr & 0x1f0)) {\n\t\trelease_region(ioaddr, CORKSCREW_TOTAL_SIZE);\n\t\treturn 0;\n\t}\n\t \n\toutw(EEPROM_Read + 7, ioaddr + Wn0EepromCmd);\n\t \n\tfor (timer = 4; timer >= 0; timer--) {\n\t\tudelay(162);\n\t\tif ((inw(ioaddr + Wn0EepromCmd) & 0x0200) == 0)\n\t\t\tbreak;\n\t}\n\tif (inw(ioaddr + Wn0EepromData) != 0x6d50) {\n\t\trelease_region(ioaddr, CORKSCREW_TOTAL_SIZE);\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nstatic void cleanup_card(struct net_device *dev)\n{\n\tstruct corkscrew_private *vp = netdev_priv(dev);\n\tlist_del_init(&vp->list);\n\tif (dev->dma)\n\t\tfree_dma(dev->dma);\n\toutw(TotalReset, dev->base_addr + EL3_CMD);\n\trelease_region(dev->base_addr, CORKSCREW_TOTAL_SIZE);\n\tif (vp->dev)\n\t\tpnp_device_detach(to_pnp_dev(vp->dev));\n}\n\nstatic struct net_device *corkscrew_scan(int unit)\n{\n\tstruct net_device *dev;\n\tstatic int cards_found = 0;\n\tstatic int ioaddr;\n\tint err;\n#ifdef __ISAPNP__\n\tshort i;\n\tstatic int pnp_cards;\n#endif\n\n\tdev = alloc_etherdev(sizeof(struct corkscrew_private));\n\tif (!dev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (unit >= 0) {\n\t\tsprintf(dev->name, \"eth%d\", unit);\n\t\tnetdev_boot_setup_check(dev);\n\t}\n\n#ifdef __ISAPNP__\n\tif(nopnp == 1)\n\t\tgoto no_pnp;\n\tfor(i=0; corkscrew_isapnp_adapters[i].vendor != 0; i++) {\n\t\tstruct pnp_dev *idev = NULL;\n\t\tint irq;\n\t\twhile((idev = pnp_find_dev(NULL,\n\t\t\t\t\t   corkscrew_isapnp_adapters[i].vendor,\n\t\t\t\t\t   corkscrew_isapnp_adapters[i].function,\n\t\t\t\t\t   idev))) {\n\n\t\t\tif (pnp_device_attach(idev) < 0)\n\t\t\t\tcontinue;\n\t\t\tif (pnp_activate_dev(idev) < 0) {\n\t\t\t\tpr_warn(\"pnp activate failed (out of resources?)\\n\");\n\t\t\t\tpnp_device_detach(idev);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!pnp_port_valid(idev, 0) || !pnp_irq_valid(idev, 0)) {\n\t\t\t\tpnp_device_detach(idev);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tioaddr = pnp_port_start(idev, 0);\n\t\t\tirq = pnp_irq(idev, 0);\n\t\t\tif (!check_device(ioaddr)) {\n\t\t\t\tpnp_device_detach(idev);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(corkscrew_debug)\n\t\t\t\tpr_debug(\"ISAPNP reports %s at i/o 0x%x, irq %d\\n\",\n\t\t\t\t\t(char*) corkscrew_isapnp_adapters[i].driver_data, ioaddr, irq);\n\t\t\tpr_info(\"3c515 Resource configuration register %#4.4x, DCR %4.4x.\\n\",\n\t\t     \t\tinl(ioaddr + 0x2002), inw(ioaddr + 0x2000));\n\t\t\t   \n\t\t\tSET_NETDEV_DEV(dev, &idev->dev);\n\t\t\tpnp_cards++;\n\t\t\terr = corkscrew_setup(dev, ioaddr, idev, cards_found++);\n\t\t\tif (!err)\n\t\t\t\treturn dev;\n\t\t\tcleanup_card(dev);\n\t\t}\n\t}\nno_pnp:\n#endif  \n\n\t \n\tfor (ioaddr = 0x100; ioaddr < 0x400; ioaddr += 0x20) {\n\t\tif (!check_device(ioaddr))\n\t\t\tcontinue;\n\n\t\tpr_info(\"3c515 Resource configuration register %#4.4x, DCR %4.4x.\\n\",\n\t\t     inl(ioaddr + 0x2002), inw(ioaddr + 0x2000));\n\t\terr = corkscrew_setup(dev, ioaddr, NULL, cards_found++);\n\t\tif (!err)\n\t\t\treturn dev;\n\t\tcleanup_card(dev);\n\t}\n\tfree_netdev(dev);\n\treturn NULL;\n}\n\n\nstatic const struct net_device_ops netdev_ops = {\n\t.ndo_open\t\t= corkscrew_open,\n\t.ndo_stop\t\t= corkscrew_close,\n\t.ndo_start_xmit\t\t= corkscrew_start_xmit,\n\t.ndo_tx_timeout\t\t= corkscrew_timeout,\n\t.ndo_get_stats\t\t= corkscrew_get_stats,\n\t.ndo_set_rx_mode\t= set_rx_mode,\n\t.ndo_set_mac_address \t= eth_mac_addr,\n\t.ndo_validate_addr\t= eth_validate_addr,\n};\n\n\nstatic int corkscrew_setup(struct net_device *dev, int ioaddr,\n\t\t\t    struct pnp_dev *idev, int card_number)\n{\n\tstruct corkscrew_private *vp = netdev_priv(dev);\n\tunsigned int eeprom[0x40], checksum = 0;\t \n\t__be16 addr[ETH_ALEN / 2];\n\tint i;\n\tint irq;\n\n#ifdef __ISAPNP__\n\tif (idev) {\n\t\tirq = pnp_irq(idev, 0);\n\t\tvp->dev = &idev->dev;\n\t} else {\n\t\tirq = inw(ioaddr + 0x2002) & 15;\n\t}\n#else\n\tirq = inw(ioaddr + 0x2002) & 15;\n#endif\n\n\tdev->base_addr = ioaddr;\n\tdev->irq = irq;\n\tdev->dma = inw(ioaddr + 0x2000) & 7;\n\tvp->product_name = \"3c515\";\n\tvp->options = dev->mem_start;\n\tvp->our_dev = dev;\n\n\tif (!vp->options) {\n\t\t if (card_number >= MAX_UNITS)\n\t\t\tvp->options = -1;\n\t\telse\n\t\t\tvp->options = options[card_number];\n\t}\n\n\tif (vp->options >= 0) {\n\t\tvp->media_override = vp->options & 7;\n\t\tif (vp->media_override == 2)\n\t\t\tvp->media_override = 0;\n\t\tvp->full_duplex = (vp->options & 8) ? 1 : 0;\n\t\tvp->bus_master = (vp->options & 16) ? 1 : 0;\n\t} else {\n\t\tvp->media_override = 7;\n\t\tvp->full_duplex = 0;\n\t\tvp->bus_master = 0;\n\t}\n#ifdef MODULE\n\tlist_add(&vp->list, &root_corkscrew_dev);\n#endif\n\n\tpr_info(\"%s: 3Com %s at %#3x,\", dev->name, vp->product_name, ioaddr);\n\n\tspin_lock_init(&vp->lock);\n\n\ttimer_setup(&vp->timer, corkscrew_timer, 0);\n\n\t \n\tEL3WINDOW(0);\n\tfor (i = 0; i < 0x18; i++) {\n\t\tint timer;\n\t\toutw(EEPROM_Read + i, ioaddr + Wn0EepromCmd);\n\t\t \n\t\tfor (timer = 4; timer >= 0; timer--) {\n\t\t\tudelay(162);\n\t\t\tif ((inw(ioaddr + Wn0EepromCmd) & 0x0200) == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\teeprom[i] = inw(ioaddr + Wn0EepromData);\n\t\tchecksum ^= eeprom[i];\n\t\tif (i < 3)\n\t\t\taddr[i] = htons(eeprom[i]);\n\t}\n\teth_hw_addr_set(dev, (u8 *)addr);\n\tchecksum = (checksum ^ (checksum >> 8)) & 0xff;\n\tif (checksum != 0x00)\n\t\tpr_cont(\" ***INVALID CHECKSUM %4.4x*** \", checksum);\n\tpr_cont(\" %pM\", dev->dev_addr);\n\tif (eeprom[16] == 0x11c7) {\t \n\t\tif (request_dma(dev->dma, \"3c515\")) {\n\t\t\tpr_cont(\", DMA %d allocation failed\", dev->dma);\n\t\t\tdev->dma = 0;\n\t\t} else\n\t\t\tpr_cont(\", DMA %d\", dev->dma);\n\t}\n\tpr_cont(\", IRQ %d\\n\", dev->irq);\n\t \n\tif (corkscrew_debug && (dev->irq <= 0 || dev->irq > 15))\n\t\tpr_warn(\" *** Warning: this IRQ is unlikely to work! ***\\n\");\n\n\t{\n\t\tstatic const char * const ram_split[] = {\n\t\t\t\"5:3\", \"3:1\", \"1:1\", \"3:5\"\n\t\t};\n\t\t__u32 config;\n\t\tEL3WINDOW(3);\n\t\tvp->available_media = inw(ioaddr + Wn3_Options);\n\t\tconfig = inl(ioaddr + Wn3_Config);\n\t\tif (corkscrew_debug > 1)\n\t\t\tpr_info(\"  Internal config register is %4.4x, transceivers %#x.\\n\",\n\t\t\t\tconfig, inw(ioaddr + Wn3_Options));\n\t\tpr_info(\"  %dK %s-wide RAM %s Rx:Tx split, %s%s interface.\\n\",\n\t\t\t8 << config & Ram_size,\n\t\t\tconfig & Ram_width ? \"word\" : \"byte\",\n\t\t\tram_split[(config & Ram_split) >> Ram_split_shift],\n\t\t\tconfig & Autoselect ? \"autoselect/\" : \"\",\n\t\t\tmedia_tbl[(config & Xcvr) >> Xcvr_shift].name);\n\t\tvp->default_media = (config & Xcvr) >> Xcvr_shift;\n\t\tvp->autoselect = config & Autoselect ? 1 : 0;\n\t\tdev->if_port = vp->default_media;\n\t}\n\tif (vp->media_override != 7) {\n\t\tpr_info(\"  Media override to transceiver type %d (%s).\\n\",\n\t\t       vp->media_override,\n\t\t       media_tbl[vp->media_override].name);\n\t\tdev->if_port = vp->media_override;\n\t}\n\n\tvp->capabilities = eeprom[16];\n\tvp->full_bus_master_tx = (vp->capabilities & 0x20) ? 1 : 0;\n\t \n\t \n\tvp->full_bus_master_rx = (vp->capabilities & 0x20) ? 1 : 0;\n\n\t \n\tdev->netdev_ops = &netdev_ops;\n\tdev->watchdog_timeo = (400 * HZ) / 1000;\n\tdev->ethtool_ops = &netdev_ethtool_ops;\n\n\treturn register_netdev(dev);\n}\n\n\nstatic int corkscrew_open(struct net_device *dev)\n{\n\tint ioaddr = dev->base_addr;\n\tstruct corkscrew_private *vp = netdev_priv(dev);\n\tbool armtimer = false;\n\t__u32 config;\n\tint i;\n\n\t \n\tEL3WINDOW(3);\n\tif (vp->full_duplex)\n\t\toutb(0x20, ioaddr + Wn3_MAC_Ctrl);\t \n\tconfig = inl(ioaddr + Wn3_Config);\n\n\tif (vp->media_override != 7) {\n\t\tif (corkscrew_debug > 1)\n\t\t\tpr_info(\"%s: Media override to transceiver %d (%s).\\n\",\n\t\t\t\tdev->name, vp->media_override,\n\t\t\t\tmedia_tbl[vp->media_override].name);\n\t\tdev->if_port = vp->media_override;\n\t} else if (vp->autoselect) {\n\t\t \n\t\tdev->if_port = 4;\n\t\twhile (!(vp->available_media & media_tbl[dev->if_port].mask))\n\t\t\tdev->if_port = media_tbl[dev->if_port].next;\n\n\t\tif (corkscrew_debug > 1)\n\t\t\tpr_debug(\"%s: Initial media type %s.\\n\",\n\t\t\t       dev->name, media_tbl[dev->if_port].name);\n\t\tarmtimer = true;\n\t} else\n\t\tdev->if_port = vp->default_media;\n\n\tconfig = (config & ~Xcvr) | (dev->if_port << Xcvr_shift);\n\toutl(config, ioaddr + Wn3_Config);\n\n\tif (corkscrew_debug > 1) {\n\t\tpr_debug(\"%s: corkscrew_open() InternalConfig %8.8x.\\n\",\n\t\t       dev->name, config);\n\t}\n\n\toutw(TxReset, ioaddr + EL3_CMD);\n\tfor (i = 20; i >= 0; i--)\n\t\tif (!(inw(ioaddr + EL3_STATUS) & CmdInProgress))\n\t\t\tbreak;\n\n\toutw(RxReset, ioaddr + EL3_CMD);\n\t \n\tfor (i = 20; i >= 0; i--)\n\t\tif (!(inw(ioaddr + EL3_STATUS) & CmdInProgress))\n\t\t\tbreak;\n\n\toutw(SetStatusEnb | 0x00, ioaddr + EL3_CMD);\n\n\t \n\tif (vp->capabilities == 0x11c7) {\n\t\t \n\t\tif (dev->irq == 0 ||\n\t\t    dev->dma == 0 ||\n\t\t    request_irq(dev->irq, corkscrew_interrupt, 0,\n\t\t\t\tvp->product_name, dev))\n\t\t\treturn -EAGAIN;\n\t\tenable_dma(dev->dma);\n\t\tset_dma_mode(dev->dma, DMA_MODE_CASCADE);\n\t} else if (request_irq(dev->irq, corkscrew_interrupt, IRQF_SHARED,\n\t\t\t       vp->product_name, dev)) {\n\t\treturn -EAGAIN;\n\t}\n\n\tif (armtimer)\n\t\tmod_timer(&vp->timer, jiffies + media_tbl[dev->if_port].wait);\n\n\tif (corkscrew_debug > 1) {\n\t\tEL3WINDOW(4);\n\t\tpr_debug(\"%s: corkscrew_open() irq %d media status %4.4x.\\n\",\n\t\t       dev->name, dev->irq, inw(ioaddr + Wn4_Media));\n\t}\n\n\t \n\tEL3WINDOW(2);\n\tfor (i = 0; i < 6; i++)\n\t\toutb(dev->dev_addr[i], ioaddr + i);\n\tfor (; i < 12; i += 2)\n\t\toutw(0, ioaddr + i);\n\n\tif (dev->if_port == 3)\n\t\t \n\t\toutw(StartCoax, ioaddr + EL3_CMD);\n\tEL3WINDOW(4);\n\toutw((inw(ioaddr + Wn4_Media) & ~(Media_10TP | Media_SQE)) |\n\t     media_tbl[dev->if_port].media_bits, ioaddr + Wn4_Media);\n\n\t \n\toutw(StatsDisable, ioaddr + EL3_CMD);\n\tEL3WINDOW(6);\n\tfor (i = 0; i < 10; i++)\n\t\tinb(ioaddr + i);\n\tinw(ioaddr + 10);\n\tinw(ioaddr + 12);\n\t \n\tEL3WINDOW(4);\n\tinb(ioaddr + 12);\n\t \n\toutw(0x0040, ioaddr + Wn4_NetDiag);\n\n\t \n\tEL3WINDOW(7);\n\n\tif (vp->full_bus_master_rx) {\t \n\t\tvp->cur_rx = vp->dirty_rx = 0;\n\t\tif (corkscrew_debug > 2)\n\t\t\tpr_debug(\"%s:  Filling in the Rx ring.\\n\", dev->name);\n\t\tfor (i = 0; i < RX_RING_SIZE; i++) {\n\t\t\tstruct sk_buff *skb;\n\t\t\tif (i < (RX_RING_SIZE - 1))\n\t\t\t\tvp->rx_ring[i].next =\n\t\t\t\t    isa_virt_to_bus(&vp->rx_ring[i + 1]);\n\t\t\telse\n\t\t\t\tvp->rx_ring[i].next = 0;\n\t\t\tvp->rx_ring[i].status = 0;\t \n\t\t\tvp->rx_ring[i].length = PKT_BUF_SZ | 0x80000000;\n\t\t\tskb = netdev_alloc_skb(dev, PKT_BUF_SZ);\n\t\t\tvp->rx_skbuff[i] = skb;\n\t\t\tif (skb == NULL)\n\t\t\t\tbreak;\t \n\t\t\tskb_reserve(skb, 2);\t \n\t\t\tvp->rx_ring[i].addr = isa_virt_to_bus(skb->data);\n\t\t}\n\t\tif (i != 0)\n\t\t\tvp->rx_ring[i - 1].next =\n\t\t\t\tisa_virt_to_bus(&vp->rx_ring[0]);\t \n\t\toutl(isa_virt_to_bus(&vp->rx_ring[0]), ioaddr + UpListPtr);\n\t}\n\tif (vp->full_bus_master_tx) {\t \n\t\tvp->cur_tx = vp->dirty_tx = 0;\n\t\toutb(PKT_BUF_SZ >> 8, ioaddr + TxFreeThreshold);\t \n\t\t \n\t\tfor (i = 0; i < TX_RING_SIZE; i++)\n\t\t\tvp->tx_skbuff[i] = NULL;\n\t\toutl(0, ioaddr + DownListPtr);\n\t}\n\t \n\tset_rx_mode(dev);\n\toutw(StatsEnable, ioaddr + EL3_CMD);\t \n\n\tnetif_start_queue(dev);\n\n\toutw(RxEnable, ioaddr + EL3_CMD);\t \n\toutw(TxEnable, ioaddr + EL3_CMD);\t \n\t \n\toutw(SetStatusEnb | AdapterFailure | IntReq | StatsFull |\n\t     (vp->full_bus_master_tx ? DownComplete : TxAvailable) |\n\t     (vp->full_bus_master_rx ? UpComplete : RxComplete) |\n\t     (vp->bus_master ? DMADone : 0), ioaddr + EL3_CMD);\n\t \n\toutw(AckIntr | IntLatch | TxAvailable | RxEarly | IntReq,\n\t     ioaddr + EL3_CMD);\n\toutw(SetIntrEnb | IntLatch | TxAvailable | RxComplete | StatsFull\n\t     | (vp->bus_master ? DMADone : 0) | UpComplete | DownComplete,\n\t     ioaddr + EL3_CMD);\n\n\treturn 0;\n}\n\nstatic void corkscrew_timer(struct timer_list *t)\n{\n#ifdef AUTOMEDIA\n\tstruct corkscrew_private *vp = from_timer(vp, t, timer);\n\tstruct net_device *dev = vp->our_dev;\n\tint ioaddr = dev->base_addr;\n\tunsigned long flags;\n\tint ok = 0;\n\n\tif (corkscrew_debug > 1)\n\t\tpr_debug(\"%s: Media selection timer tick happened, %s.\\n\",\n\t\t       dev->name, media_tbl[dev->if_port].name);\n\n\tspin_lock_irqsave(&vp->lock, flags);\n\n\t{\n\t\tint old_window = inw(ioaddr + EL3_CMD) >> 13;\n\t\tint media_status;\n\t\tEL3WINDOW(4);\n\t\tmedia_status = inw(ioaddr + Wn4_Media);\n\t\tswitch (dev->if_port) {\n\t\tcase 0:\n\t\tcase 4:\n\t\tcase 5:\t \n\t\t\tif (media_status & Media_LnkBeat) {\n\t\t\t\tok = 1;\n\t\t\t\tif (corkscrew_debug > 1)\n\t\t\t\t\tpr_debug(\"%s: Media %s has link beat, %x.\\n\",\n\t\t\t\t\t\tdev->name,\n\t\t\t\t\t\tmedia_tbl[dev->if_port].name,\n\t\t\t\t\t\tmedia_status);\n\t\t\t} else if (corkscrew_debug > 1)\n\t\t\t\tpr_debug(\"%s: Media %s is has no link beat, %x.\\n\",\n\t\t\t\t\tdev->name,\n\t\t\t\t\tmedia_tbl[dev->if_port].name,\n\t\t\t\t\tmedia_status);\n\n\t\t\tbreak;\n\t\tdefault:\t \n\t\t\tif (corkscrew_debug > 1)\n\t\t\t\tpr_debug(\"%s: Media %s is has no indication, %x.\\n\",\n\t\t\t\t\tdev->name,\n\t\t\t\t\tmedia_tbl[dev->if_port].name,\n\t\t\t\t\tmedia_status);\n\t\t\tok = 1;\n\t\t}\n\t\tif (!ok) {\n\t\t\t__u32 config;\n\n\t\t\tdo {\n\t\t\t\tdev->if_port =\n\t\t\t\t    media_tbl[dev->if_port].next;\n\t\t\t}\n\t\t\twhile (!(vp->available_media & media_tbl[dev->if_port].mask));\n\n\t\t\tif (dev->if_port == 8) {\t \n\t\t\t\tdev->if_port = vp->default_media;\n\t\t\t\tif (corkscrew_debug > 1)\n\t\t\t\t\tpr_debug(\"%s: Media selection failing, using default %s port.\\n\",\n\t\t\t\t\t\tdev->name,\n\t\t\t\t\t\tmedia_tbl[dev->if_port].name);\n\t\t\t} else {\n\t\t\t\tif (corkscrew_debug > 1)\n\t\t\t\t\tpr_debug(\"%s: Media selection failed, now trying %s port.\\n\",\n\t\t\t\t\t\tdev->name,\n\t\t\t\t\t\tmedia_tbl[dev->if_port].name);\n\t\t\t\tvp->timer.expires = jiffies + media_tbl[dev->if_port].wait;\n\t\t\t\tadd_timer(&vp->timer);\n\t\t\t}\n\t\t\toutw((media_status & ~(Media_10TP | Media_SQE)) |\n\t\t\t     media_tbl[dev->if_port].media_bits,\n\t\t\t     ioaddr + Wn4_Media);\n\n\t\t\tEL3WINDOW(3);\n\t\t\tconfig = inl(ioaddr + Wn3_Config);\n\t\t\tconfig = (config & ~Xcvr) | (dev->if_port << Xcvr_shift);\n\t\t\toutl(config, ioaddr + Wn3_Config);\n\n\t\t\toutw(dev->if_port == 3 ? StartCoax : StopCoax,\n\t\t\t     ioaddr + EL3_CMD);\n\t\t}\n\t\tEL3WINDOW(old_window);\n\t}\n\n\tspin_unlock_irqrestore(&vp->lock, flags);\n\tif (corkscrew_debug > 1)\n\t\tpr_debug(\"%s: Media selection timer finished, %s.\\n\",\n\t\t       dev->name, media_tbl[dev->if_port].name);\n\n#endif\t\t\t\t \n}\n\nstatic void corkscrew_timeout(struct net_device *dev, unsigned int txqueue)\n{\n\tint i;\n\tstruct corkscrew_private *vp = netdev_priv(dev);\n\tint ioaddr = dev->base_addr;\n\n\tpr_warn(\"%s: transmit timed out, tx_status %2.2x status %4.4x\\n\",\n\t\tdev->name, inb(ioaddr + TxStatus),\n\t\tinw(ioaddr + EL3_STATUS));\n\t \n\tif ((inb(ioaddr + TxStatus) & 0x88) == 0x88)\n\t\tpr_warn(\"%s: Transmitter encountered 16 collisions -- network cable problem?\\n\",\n\t\t\tdev->name);\n#ifndef final_version\n\tpr_debug(\"  Flags; bus-master %d, full %d; dirty %d current %d.\\n\",\n\t       vp->full_bus_master_tx, vp->tx_full, vp->dirty_tx,\n\t       vp->cur_tx);\n\tpr_debug(\"  Down list %8.8x vs. %p.\\n\", inl(ioaddr + DownListPtr),\n\t       &vp->tx_ring[0]);\n\tfor (i = 0; i < TX_RING_SIZE; i++) {\n\t\tpr_debug(\"  %d: %p  length %8.8x status %8.8x\\n\", i,\n\t\t       &vp->tx_ring[i],\n\t\t       vp->tx_ring[i].length, vp->tx_ring[i].status);\n\t}\n#endif\n\t \n\toutw(TxReset, ioaddr + EL3_CMD);\n\tfor (i = 20; i >= 0; i--)\n\t\tif (!(inw(ioaddr + EL3_STATUS) & CmdInProgress))\n\t\t\tbreak;\n\toutw(TxEnable, ioaddr + EL3_CMD);\n\tnetif_trans_update(dev);  \n\tdev->stats.tx_errors++;\n\tdev->stats.tx_dropped++;\n\tnetif_wake_queue(dev);\n}\n\nstatic netdev_tx_t corkscrew_start_xmit(struct sk_buff *skb,\n\t\t\t\t\tstruct net_device *dev)\n{\n\tstruct corkscrew_private *vp = netdev_priv(dev);\n\tint ioaddr = dev->base_addr;\n\n\t \n\n\tnetif_stop_queue(dev);\n\n\tif (vp->full_bus_master_tx) {\t \n\t\t \n\t\tint entry = vp->cur_tx % TX_RING_SIZE;\n\t\tstruct boom_tx_desc *prev_entry;\n\t\tunsigned long flags;\n\t\tint i;\n\n\t\tif (vp->tx_full)\t \n\t\t\treturn NETDEV_TX_BUSY;\n\t\tif (vp->cur_tx != 0)\n\t\t\tprev_entry = &vp->tx_ring[(vp->cur_tx - 1) % TX_RING_SIZE];\n\t\telse\n\t\t\tprev_entry = NULL;\n\t\tif (corkscrew_debug > 3)\n\t\t\tpr_debug(\"%s: Trying to send a packet, Tx index %d.\\n\",\n\t\t\t\tdev->name, vp->cur_tx);\n\t\t \n\t\tvp->tx_skbuff[entry] = skb;\n\t\tvp->tx_ring[entry].next = 0;\n\t\tvp->tx_ring[entry].addr = isa_virt_to_bus(skb->data);\n\t\tvp->tx_ring[entry].length = skb->len | 0x80000000;\n\t\tvp->tx_ring[entry].status = skb->len | 0x80000000;\n\n\t\tspin_lock_irqsave(&vp->lock, flags);\n\t\toutw(DownStall, ioaddr + EL3_CMD);\n\t\t \n\t\tfor (i = 20; i >= 0; i--)\n\t\t\tif ((inw(ioaddr + EL3_STATUS) & CmdInProgress) == 0)\n\t\t\t\tbreak;\n\t\tif (prev_entry)\n\t\t\tprev_entry->next = isa_virt_to_bus(&vp->tx_ring[entry]);\n\t\tif (inl(ioaddr + DownListPtr) == 0) {\n\t\t\toutl(isa_virt_to_bus(&vp->tx_ring[entry]),\n\t\t\t     ioaddr + DownListPtr);\n\t\t\tqueued_packet++;\n\t\t}\n\t\toutw(DownUnstall, ioaddr + EL3_CMD);\n\t\tspin_unlock_irqrestore(&vp->lock, flags);\n\n\t\tvp->cur_tx++;\n\t\tif (vp->cur_tx - vp->dirty_tx > TX_RING_SIZE - 1)\n\t\t\tvp->tx_full = 1;\n\t\telse {\t\t \n\t\t\tif (prev_entry)\n\t\t\t\tprev_entry->status &= ~0x80000000;\n\t\t\tnetif_wake_queue(dev);\n\t\t}\n\t\treturn NETDEV_TX_OK;\n\t}\n\t \n\toutl(skb->len, ioaddr + TX_FIFO);\n\tdev->stats.tx_bytes += skb->len;\n#ifdef VORTEX_BUS_MASTER\n\tif (vp->bus_master) {\n\t\t \n\t\toutl(isa_virt_to_bus(skb->data), ioaddr + Wn7_MasterAddr);\n\t\toutw((skb->len + 3) & ~3, ioaddr + Wn7_MasterLen);\n\t\tvp->tx_skb = skb;\n\t\toutw(StartDMADown, ioaddr + EL3_CMD);\n\t\t \n\t} else {\n\t\t \n\t\toutsl(ioaddr + TX_FIFO, skb->data, (skb->len + 3) >> 2);\n\t\tdev_kfree_skb(skb);\n\t\tif (inw(ioaddr + TxFree) > 1536) {\n\t\t\tnetif_wake_queue(dev);\n\t\t} else\n\t\t\t \n\t\t\toutw(SetTxThreshold + (1536 >> 2),\n\t\t\t     ioaddr + EL3_CMD);\n\t}\n#else\n\t \n\toutsl(ioaddr + TX_FIFO, skb->data, (skb->len + 3) >> 2);\n\tdev_kfree_skb(skb);\n\tif (inw(ioaddr + TxFree) > 1536) {\n\t\tnetif_wake_queue(dev);\n\t} else\n\t\t \n\t\toutw(SetTxThreshold + (1536 >> 2), ioaddr + EL3_CMD);\n#endif\t\t\t\t \n\n\n\t \n\t{\n\t\tshort tx_status;\n\t\tint i = 4;\n\n\t\twhile (--i > 0 && (tx_status = inb(ioaddr + TxStatus)) > 0) {\n\t\t\tif (tx_status & 0x3C) {\t \n\t\t\t\tif (corkscrew_debug > 2)\n\t\t\t\t\tpr_debug(\"%s: Tx error, status %2.2x.\\n\",\n\t\t\t\t\t\tdev->name, tx_status);\n\t\t\t\tif (tx_status & 0x04)\n\t\t\t\t\tdev->stats.tx_fifo_errors++;\n\t\t\t\tif (tx_status & 0x38)\n\t\t\t\t\tdev->stats.tx_aborted_errors++;\n\t\t\t\tif (tx_status & 0x30) {\n\t\t\t\t\tint j;\n\t\t\t\t\toutw(TxReset, ioaddr + EL3_CMD);\n\t\t\t\t\tfor (j = 20; j >= 0; j--)\n\t\t\t\t\t\tif (!(inw(ioaddr + EL3_STATUS) & CmdInProgress))\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\toutw(TxEnable, ioaddr + EL3_CMD);\n\t\t\t}\n\t\t\toutb(0x00, ioaddr + TxStatus);\t \n\t\t}\n\t}\n\treturn NETDEV_TX_OK;\n}\n\n \n\nstatic irqreturn_t corkscrew_interrupt(int irq, void *dev_id)\n{\n\t \n\tstruct net_device *dev = dev_id;\n\tstruct corkscrew_private *lp = netdev_priv(dev);\n\tint ioaddr, status;\n\tint latency;\n\tint i = max_interrupt_work;\n\n\tioaddr = dev->base_addr;\n\tlatency = inb(ioaddr + Timer);\n\n\tspin_lock(&lp->lock);\n\n\tstatus = inw(ioaddr + EL3_STATUS);\n\n\tif (corkscrew_debug > 4)\n\t\tpr_debug(\"%s: interrupt, status %4.4x, timer %d.\\n\",\n\t\t\tdev->name, status, latency);\n\tif ((status & 0xE000) != 0xE000) {\n\t\tstatic int donedidthis;\n\t\t \n\t\tif (donedidthis++ > 100) {\n\t\t\tpr_err(\"%s: Bogus interrupt, bailing. Status %4.4x, start=%d.\\n\",\n\t\t\t\t   dev->name, status, netif_running(dev));\n\t\t\tfree_irq(dev->irq, dev);\n\t\t\tdev->irq = -1;\n\t\t}\n\t}\n\n\tdo {\n\t\tif (corkscrew_debug > 5)\n\t\t\tpr_debug(\"%s: In interrupt loop, status %4.4x.\\n\",\n\t\t\t       dev->name, status);\n\t\tif (status & RxComplete)\n\t\t\tcorkscrew_rx(dev);\n\n\t\tif (status & TxAvailable) {\n\t\t\tif (corkscrew_debug > 5)\n\t\t\t\tpr_debug(\"\tTX room bit was handled.\\n\");\n\t\t\t \n\t\t\toutw(AckIntr | TxAvailable, ioaddr + EL3_CMD);\n\t\t\tnetif_wake_queue(dev);\n\t\t}\n\t\tif (status & DownComplete) {\n\t\t\tunsigned int dirty_tx = lp->dirty_tx;\n\n\t\t\twhile (lp->cur_tx - dirty_tx > 0) {\n\t\t\t\tint entry = dirty_tx % TX_RING_SIZE;\n\t\t\t\tif (inl(ioaddr + DownListPtr) == isa_virt_to_bus(&lp->tx_ring[entry]))\n\t\t\t\t\tbreak;\t \n\t\t\t\tif (lp->tx_skbuff[entry]) {\n\t\t\t\t\tdev_consume_skb_irq(lp->tx_skbuff[entry]);\n\t\t\t\t\tlp->tx_skbuff[entry] = NULL;\n\t\t\t\t}\n\t\t\t\tdirty_tx++;\n\t\t\t}\n\t\t\tlp->dirty_tx = dirty_tx;\n\t\t\toutw(AckIntr | DownComplete, ioaddr + EL3_CMD);\n\t\t\tif (lp->tx_full && (lp->cur_tx - dirty_tx <= TX_RING_SIZE - 1)) {\n\t\t\t\tlp->tx_full = 0;\n\t\t\t\tnetif_wake_queue(dev);\n\t\t\t}\n\t\t}\n#ifdef VORTEX_BUS_MASTER\n\t\tif (status & DMADone) {\n\t\t\toutw(0x1000, ioaddr + Wn7_MasterStatus);\t \n\t\t\tdev_consume_skb_irq(lp->tx_skb);\t \n\t\t\tnetif_wake_queue(dev);\n\t\t}\n#endif\n\t\tif (status & UpComplete) {\n\t\t\tboomerang_rx(dev);\n\t\t\toutw(AckIntr | UpComplete, ioaddr + EL3_CMD);\n\t\t}\n\t\tif (status & (AdapterFailure | RxEarly | StatsFull)) {\n\t\t\t \n\t\t\tif (status & RxEarly) {\t \n\t\t\t\tcorkscrew_rx(dev);\n\t\t\t\toutw(AckIntr | RxEarly, ioaddr + EL3_CMD);\n\t\t\t}\n\t\t\tif (status & StatsFull) {\t \n\t\t\t\tstatic int DoneDidThat;\n\t\t\t\tif (corkscrew_debug > 4)\n\t\t\t\t\tpr_debug(\"%s: Updating stats.\\n\", dev->name);\n\t\t\t\tupdate_stats(ioaddr, dev);\n\t\t\t\t \n\t\t\t\t \n\t\t\t\tif (DoneDidThat == 0 && inw(ioaddr + EL3_STATUS) & StatsFull) {\n\t\t\t\t\tint win, reg;\n\t\t\t\t\tpr_notice(\"%s: Updating stats failed, disabling stats as an interrupt source.\\n\",\n\t\t\t\t\t\tdev->name);\n\t\t\t\t\tfor (win = 0; win < 8; win++) {\n\t\t\t\t\t\tEL3WINDOW(win);\n\t\t\t\t\t\tpr_notice(\"Vortex window %d:\", win);\n\t\t\t\t\t\tfor (reg = 0; reg < 16; reg++)\n\t\t\t\t\t\t\tpr_cont(\" %2.2x\", inb(ioaddr + reg));\n\t\t\t\t\t\tpr_cont(\"\\n\");\n\t\t\t\t\t}\n\t\t\t\t\tEL3WINDOW(7);\n\t\t\t\t\toutw(SetIntrEnb | TxAvailable |\n\t\t\t\t\t     RxComplete | AdapterFailure |\n\t\t\t\t\t     UpComplete | DownComplete |\n\t\t\t\t\t     TxComplete, ioaddr + EL3_CMD);\n\t\t\t\t\tDoneDidThat++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (status & AdapterFailure) {\n\t\t\t\t \n\t\t\t\toutw(RxReset, ioaddr + EL3_CMD);\n\t\t\t\t \n\t\t\t\tset_rx_mode(dev);\n\t\t\t\toutw(RxEnable, ioaddr + EL3_CMD);\t \n\t\t\t\toutw(AckIntr | AdapterFailure,\n\t\t\t\t     ioaddr + EL3_CMD);\n\t\t\t}\n\t\t}\n\n\t\tif (--i < 0) {\n\t\t\tpr_err(\"%s: Too much work in interrupt, status %4.4x. Disabling functions (%4.4x).\\n\",\n\t\t\t\tdev->name, status, SetStatusEnb | ((~status) & 0x7FE));\n\t\t\t \n\t\t\toutw(SetStatusEnb | ((~status) & 0x7FE), ioaddr + EL3_CMD);\n\t\t\toutw(AckIntr | 0x7FF, ioaddr + EL3_CMD);\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\toutw(AckIntr | IntReq | IntLatch, ioaddr + EL3_CMD);\n\n\t} while ((status = inw(ioaddr + EL3_STATUS)) & (IntLatch | RxComplete));\n\n\tspin_unlock(&lp->lock);\n\n\tif (corkscrew_debug > 4)\n\t\tpr_debug(\"%s: exiting interrupt, status %4.4x.\\n\", dev->name, status);\n\treturn IRQ_HANDLED;\n}\n\nstatic int corkscrew_rx(struct net_device *dev)\n{\n\tint ioaddr = dev->base_addr;\n\tint i;\n\tshort rx_status;\n\n\tif (corkscrew_debug > 5)\n\t\tpr_debug(\"   In rx_packet(), status %4.4x, rx_status %4.4x.\\n\",\n\t\t     inw(ioaddr + EL3_STATUS), inw(ioaddr + RxStatus));\n\twhile ((rx_status = inw(ioaddr + RxStatus)) > 0) {\n\t\tif (rx_status & 0x4000) {\t \n\t\t\tunsigned char rx_error = inb(ioaddr + RxErrors);\n\t\t\tif (corkscrew_debug > 2)\n\t\t\t\tpr_debug(\" Rx error: status %2.2x.\\n\",\n\t\t\t\t       rx_error);\n\t\t\tdev->stats.rx_errors++;\n\t\t\tif (rx_error & 0x01)\n\t\t\t\tdev->stats.rx_over_errors++;\n\t\t\tif (rx_error & 0x02)\n\t\t\t\tdev->stats.rx_length_errors++;\n\t\t\tif (rx_error & 0x04)\n\t\t\t\tdev->stats.rx_frame_errors++;\n\t\t\tif (rx_error & 0x08)\n\t\t\t\tdev->stats.rx_crc_errors++;\n\t\t\tif (rx_error & 0x10)\n\t\t\t\tdev->stats.rx_length_errors++;\n\t\t} else {\n\t\t\t \n\t\t\tshort pkt_len = rx_status & 0x1fff;\n\t\t\tstruct sk_buff *skb;\n\n\t\t\tskb = netdev_alloc_skb(dev, pkt_len + 5 + 2);\n\t\t\tif (corkscrew_debug > 4)\n\t\t\t\tpr_debug(\"Receiving packet size %d status %4.4x.\\n\",\n\t\t\t\t     pkt_len, rx_status);\n\t\t\tif (skb != NULL) {\n\t\t\t\tskb_reserve(skb, 2);\t \n\t\t\t\t \n\t\t\t\tinsl(ioaddr + RX_FIFO,\n\t\t\t\t     skb_put(skb, pkt_len),\n\t\t\t\t     (pkt_len + 3) >> 2);\n\t\t\t\toutw(RxDiscard, ioaddr + EL3_CMD);\t \n\t\t\t\tskb->protocol = eth_type_trans(skb, dev);\n\t\t\t\tnetif_rx(skb);\n\t\t\t\tdev->stats.rx_packets++;\n\t\t\t\tdev->stats.rx_bytes += pkt_len;\n\t\t\t\t \n\t\t\t\tfor (i = 200; i >= 0; i--)\n\t\t\t\t\tif (! (inw(ioaddr + EL3_STATUS) & CmdInProgress))\n\t\t\t\t\t\tbreak;\n\t\t\t\tcontinue;\n\t\t\t} else if (corkscrew_debug)\n\t\t\t\tpr_debug(\"%s: Couldn't allocate a sk_buff of size %d.\\n\", dev->name, pkt_len);\n\t\t}\n\t\toutw(RxDiscard, ioaddr + EL3_CMD);\n\t\tdev->stats.rx_dropped++;\n\t\t \n\t\tfor (i = 200; i >= 0; i--)\n\t\t\tif (!(inw(ioaddr + EL3_STATUS) & CmdInProgress))\n\t\t\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int boomerang_rx(struct net_device *dev)\n{\n\tstruct corkscrew_private *vp = netdev_priv(dev);\n\tint entry = vp->cur_rx % RX_RING_SIZE;\n\tint ioaddr = dev->base_addr;\n\tint rx_status;\n\n\tif (corkscrew_debug > 5)\n\t\tpr_debug(\"   In boomerang_rx(), status %4.4x, rx_status %4.4x.\\n\",\n\t\t\tinw(ioaddr + EL3_STATUS), inw(ioaddr + RxStatus));\n\twhile ((rx_status = vp->rx_ring[entry].status) & RxDComplete) {\n\t\tif (rx_status & RxDError) {\t \n\t\t\tunsigned char rx_error = rx_status >> 16;\n\t\t\tif (corkscrew_debug > 2)\n\t\t\t\tpr_debug(\" Rx error: status %2.2x.\\n\",\n\t\t\t\t       rx_error);\n\t\t\tdev->stats.rx_errors++;\n\t\t\tif (rx_error & 0x01)\n\t\t\t\tdev->stats.rx_over_errors++;\n\t\t\tif (rx_error & 0x02)\n\t\t\t\tdev->stats.rx_length_errors++;\n\t\t\tif (rx_error & 0x04)\n\t\t\t\tdev->stats.rx_frame_errors++;\n\t\t\tif (rx_error & 0x08)\n\t\t\t\tdev->stats.rx_crc_errors++;\n\t\t\tif (rx_error & 0x10)\n\t\t\t\tdev->stats.rx_length_errors++;\n\t\t} else {\n\t\t\t \n\t\t\tshort pkt_len = rx_status & 0x1fff;\n\t\t\tstruct sk_buff *skb;\n\n\t\t\tdev->stats.rx_bytes += pkt_len;\n\t\t\tif (corkscrew_debug > 4)\n\t\t\t\tpr_debug(\"Receiving packet size %d status %4.4x.\\n\",\n\t\t\t\t     pkt_len, rx_status);\n\n\t\t\t \n\t\t\tif (pkt_len < rx_copybreak &&\n\t\t\t    (skb = netdev_alloc_skb(dev, pkt_len + 4)) != NULL) {\n\t\t\t\tskb_reserve(skb, 2);\t \n\t\t\t\t \n\t\t\t\tskb_put_data(skb,\n\t\t\t\t\t     isa_bus_to_virt(vp->rx_ring[entry].addr),\n\t\t\t\t\t     pkt_len);\n\t\t\t\trx_copy++;\n\t\t\t} else {\n\t\t\t\tvoid *temp;\n\t\t\t\t \n\t\t\t\tskb = vp->rx_skbuff[entry];\n\t\t\t\tvp->rx_skbuff[entry] = NULL;\n\t\t\t\ttemp = skb_put(skb, pkt_len);\n\t\t\t\t \n\t\t\t\tif (isa_bus_to_virt(vp->rx_ring[entry].addr) != temp)\n\t\t\t\t\tpr_warn(\"%s: Warning -- the skbuff addresses do not match in boomerang_rx: %p vs. %p / %p\\n\",\n\t\t\t\t\t\tdev->name,\n\t\t\t\t\t\tisa_bus_to_virt(vp->rx_ring[entry].addr),\n\t\t\t\t\t\tskb->head, temp);\n\t\t\t\trx_nocopy++;\n\t\t\t}\n\t\t\tskb->protocol = eth_type_trans(skb, dev);\n\t\t\tnetif_rx(skb);\n\t\t\tdev->stats.rx_packets++;\n\t\t}\n\t\tentry = (++vp->cur_rx) % RX_RING_SIZE;\n\t}\n\t \n\tfor (; vp->cur_rx - vp->dirty_rx > 0; vp->dirty_rx++) {\n\t\tstruct sk_buff *skb;\n\t\tentry = vp->dirty_rx % RX_RING_SIZE;\n\t\tif (vp->rx_skbuff[entry] == NULL) {\n\t\t\tskb = netdev_alloc_skb(dev, PKT_BUF_SZ);\n\t\t\tif (skb == NULL)\n\t\t\t\tbreak;\t \n\t\t\tskb_reserve(skb, 2);\t \n\t\t\tvp->rx_ring[entry].addr = isa_virt_to_bus(skb->data);\n\t\t\tvp->rx_skbuff[entry] = skb;\n\t\t}\n\t\tvp->rx_ring[entry].status = 0;\t \n\t}\n\treturn 0;\n}\n\nstatic int corkscrew_close(struct net_device *dev)\n{\n\tstruct corkscrew_private *vp = netdev_priv(dev);\n\tint ioaddr = dev->base_addr;\n\tint i;\n\n\tnetif_stop_queue(dev);\n\n\tif (corkscrew_debug > 1) {\n\t\tpr_debug(\"%s: corkscrew_close() status %4.4x, Tx status %2.2x.\\n\",\n\t\t     dev->name, inw(ioaddr + EL3_STATUS),\n\t\t     inb(ioaddr + TxStatus));\n\t\tpr_debug(\"%s: corkscrew close stats: rx_nocopy %d rx_copy %d tx_queued %d.\\n\",\n\t\t\tdev->name, rx_nocopy, rx_copy, queued_packet);\n\t}\n\n\tdel_timer_sync(&vp->timer);\n\n\t \n\toutw(StatsDisable, ioaddr + EL3_CMD);\n\n\t \n\toutw(RxDisable, ioaddr + EL3_CMD);\n\toutw(TxDisable, ioaddr + EL3_CMD);\n\n\tif (dev->if_port == XCVR_10base2)\n\t\t \n\t\toutw(StopCoax, ioaddr + EL3_CMD);\n\n\tfree_irq(dev->irq, dev);\n\n\toutw(SetIntrEnb | 0x0000, ioaddr + EL3_CMD);\n\n\tupdate_stats(ioaddr, dev);\n\tif (vp->full_bus_master_rx) {\t \n\t\toutl(0, ioaddr + UpListPtr);\n\t\tfor (i = 0; i < RX_RING_SIZE; i++)\n\t\t\tif (vp->rx_skbuff[i]) {\n\t\t\t\tdev_kfree_skb(vp->rx_skbuff[i]);\n\t\t\t\tvp->rx_skbuff[i] = NULL;\n\t\t\t}\n\t}\n\tif (vp->full_bus_master_tx) {\t \n\t\toutl(0, ioaddr + DownListPtr);\n\t\tfor (i = 0; i < TX_RING_SIZE; i++)\n\t\t\tif (vp->tx_skbuff[i]) {\n\t\t\t\tdev_kfree_skb(vp->tx_skbuff[i]);\n\t\t\t\tvp->tx_skbuff[i] = NULL;\n\t\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic struct net_device_stats *corkscrew_get_stats(struct net_device *dev)\n{\n\tstruct corkscrew_private *vp = netdev_priv(dev);\n\tunsigned long flags;\n\n\tif (netif_running(dev)) {\n\t\tspin_lock_irqsave(&vp->lock, flags);\n\t\tupdate_stats(dev->base_addr, dev);\n\t\tspin_unlock_irqrestore(&vp->lock, flags);\n\t}\n\treturn &dev->stats;\n}\n\n \nstatic void update_stats(int ioaddr, struct net_device *dev)\n{\n\t \n\t \n\tEL3WINDOW(6);\n\tdev->stats.tx_carrier_errors += inb(ioaddr + 0);\n\tdev->stats.tx_heartbeat_errors += inb(ioaddr + 1);\n\t  inb(ioaddr + 2);\n\tdev->stats.collisions += inb(ioaddr + 3);\n\tdev->stats.tx_window_errors += inb(ioaddr + 4);\n\tdev->stats.rx_fifo_errors += inb(ioaddr + 5);\n\tdev->stats.tx_packets += inb(ioaddr + 6);\n\tdev->stats.tx_packets += (inb(ioaddr + 9) & 0x30) << 4;\n\t\t\t\t\t\t  inb(ioaddr + 7);\n\t\t\t\t\t\t \n\t  inb(ioaddr + 8);\n\t \n\tinw(ioaddr + 10);\t \n\tinw(ioaddr + 12);\n\t \n\tEL3WINDOW(4);\n\tinb(ioaddr + 12);\n\n\t \n\tEL3WINDOW(7);\n}\n\n \nstatic void set_rx_mode(struct net_device *dev)\n{\n\tint ioaddr = dev->base_addr;\n\tunsigned short new_mode;\n\n\tif (dev->flags & IFF_PROMISC) {\n\t\tif (corkscrew_debug > 3)\n\t\t\tpr_debug(\"%s: Setting promiscuous mode.\\n\",\n\t\t\t       dev->name);\n\t\tnew_mode = SetRxFilter | RxStation | RxMulticast | RxBroadcast | RxProm;\n\t} else if (!netdev_mc_empty(dev) || dev->flags & IFF_ALLMULTI) {\n\t\tnew_mode = SetRxFilter | RxStation | RxMulticast | RxBroadcast;\n\t} else\n\t\tnew_mode = SetRxFilter | RxStation | RxBroadcast;\n\n\toutw(new_mode, ioaddr + EL3_CMD);\n}\n\nstatic void netdev_get_drvinfo(struct net_device *dev,\n\t\t\t       struct ethtool_drvinfo *info)\n{\n\tstrscpy(info->driver, DRV_NAME, sizeof(info->driver));\n\tsnprintf(info->bus_info, sizeof(info->bus_info), \"ISA 0x%lx\",\n\t\t dev->base_addr);\n}\n\nstatic u32 netdev_get_msglevel(struct net_device *dev)\n{\n\treturn corkscrew_debug;\n}\n\nstatic void netdev_set_msglevel(struct net_device *dev, u32 level)\n{\n\tcorkscrew_debug = level;\n}\n\nstatic const struct ethtool_ops netdev_ethtool_ops = {\n\t.get_drvinfo\t\t= netdev_get_drvinfo,\n\t.get_msglevel\t\t= netdev_get_msglevel,\n\t.set_msglevel\t\t= netdev_set_msglevel,\n};\n\n\n#ifdef MODULE\nvoid cleanup_module(void)\n{\n\twhile (!list_empty(&root_corkscrew_dev)) {\n\t\tstruct net_device *dev;\n\t\tstruct corkscrew_private *vp;\n\n\t\tvp = list_entry(root_corkscrew_dev.next,\n\t\t\t\tstruct corkscrew_private, list);\n\t\tdev = vp->our_dev;\n\t\tunregister_netdev(dev);\n\t\tcleanup_card(dev);\n\t\tfree_netdev(dev);\n\t}\n}\n#endif\t\t\t\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}