{
  "module_name": "3c589_cs.c",
  "hash_id": "5c8acaa867ccaabd5ce0072b7d399d265bc9b643c5c7c044778473ebaca42c5e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/3com/3c589_cs.c",
  "human_readable_source": " \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#define DRV_NAME\t\"3c589_cs\"\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/ptrace.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/timer.h>\n#include <linux/interrupt.h>\n#include <linux/in.h>\n#include <linux/delay.h>\n#include <linux/ethtool.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/skbuff.h>\n#include <linux/if_arp.h>\n#include <linux/ioport.h>\n#include <linux/bitops.h>\n#include <linux/jiffies.h>\n#include <linux/uaccess.h>\n#include <linux/io.h>\n\n#include <pcmcia/cistpl.h>\n#include <pcmcia/cisreg.h>\n#include <pcmcia/ciscode.h>\n#include <pcmcia/ds.h>\n\n\n \n\n \n#define EL3_DATA\t0x00\n#define EL3_TIMER\t0x0a\n#define EL3_CMD\t\t0x0e\n#define EL3_STATUS\t0x0e\n\n#define EEPROM_READ\t0x0080\n#define EEPROM_BUSY\t0x8000\n\n#define EL3WINDOW(win_num) outw(SelectWindow + (win_num), ioaddr + EL3_CMD)\n\n \n\nenum c509cmd {\n\tTotalReset\t= 0<<11,\n\tSelectWindow\t= 1<<11,\n\tStartCoax\t= 2<<11,\n\tRxDisable\t= 3<<11,\n\tRxEnable\t= 4<<11,\n\tRxReset\t\t= 5<<11,\n\tRxDiscard\t= 8<<11,\n\tTxEnable\t= 9<<11,\n\tTxDisable\t= 10<<11,\n\tTxReset\t\t= 11<<11,\n\tFakeIntr\t= 12<<11,\n\tAckIntr\t\t= 13<<11,\n\tSetIntrEnb\t= 14<<11,\n\tSetStatusEnb\t= 15<<11,\n\tSetRxFilter\t= 16<<11,\n\tSetRxThreshold\t= 17<<11,\n\tSetTxThreshold\t= 18<<11,\n\tSetTxStart\t= 19<<11,\n\tStatsEnable\t= 21<<11,\n\tStatsDisable\t= 22<<11,\n\tStopCoax\t= 23<<11\n};\n\nenum c509status {\n\tIntLatch\t= 0x0001,\n\tAdapterFailure\t= 0x0002,\n\tTxComplete\t= 0x0004,\n\tTxAvailable\t= 0x0008,\n\tRxComplete\t= 0x0010,\n\tRxEarly\t\t= 0x0020,\n\tIntReq\t\t= 0x0040,\n\tStatsFull\t= 0x0080,\n\tCmdBusy\t\t= 0x1000\n};\n\n \nenum RxFilter {\n\tRxStation\t= 1,\n\tRxMulticast\t= 2,\n\tRxBroadcast\t= 4,\n\tRxProm\t\t= 8\n};\n\n \n#define TX_FIFO\t\t0x00\n#define RX_FIFO\t\t0x00\n#define RX_STATUS\t0x08\n#define TX_STATUS\t0x0B\n#define TX_FREE\t\t0x0C\t \n\n#define WN0_IRQ\t\t0x08\t \n#define WN4_MEDIA\t0x0A\t \n#define MEDIA_TP\t0x00C0\t \n#define MEDIA_LED\t0x0001\t \n\n \n#define TX_TIMEOUT\t((400*HZ)/1000)\n\nstruct el3_private {\n\tstruct pcmcia_device\t*p_dev;\n\t \n\tstruct timer_list\tmedia;\n\tu16\t\t\tmedia_status;\n\tu16\t\t\tfast_poll;\n\tunsigned long\t\tlast_irq;\n\tspinlock_t\t\tlock;\n};\n\nstatic const char *if_names[] = { \"auto\", \"10baseT\", \"10base2\", \"AUI\" };\n\n \n\n \n\nMODULE_AUTHOR(\"David Hinds <dahinds@users.sourceforge.net>\");\nMODULE_DESCRIPTION(\"3Com 3c589 series PCMCIA ethernet driver\");\nMODULE_LICENSE(\"GPL\");\n\n#define INT_MODULE_PARM(n, v) static int n = v; module_param(n, int, 0)\n\n \nINT_MODULE_PARM(if_port, 0);\n\n\n \n\nstatic int tc589_config(struct pcmcia_device *link);\nstatic void tc589_release(struct pcmcia_device *link);\n\nstatic u16 read_eeprom(unsigned int ioaddr, int index);\nstatic void tc589_reset(struct net_device *dev);\nstatic void media_check(struct timer_list *t);\nstatic int el3_config(struct net_device *dev, struct ifmap *map);\nstatic int el3_open(struct net_device *dev);\nstatic netdev_tx_t el3_start_xmit(struct sk_buff *skb,\n\t\t\t\t\tstruct net_device *dev);\nstatic irqreturn_t el3_interrupt(int irq, void *dev_id);\nstatic void update_stats(struct net_device *dev);\nstatic struct net_device_stats *el3_get_stats(struct net_device *dev);\nstatic int el3_rx(struct net_device *dev);\nstatic int el3_close(struct net_device *dev);\nstatic void el3_tx_timeout(struct net_device *dev, unsigned int txqueue);\nstatic void set_rx_mode(struct net_device *dev);\nstatic void set_multicast_list(struct net_device *dev);\nstatic const struct ethtool_ops netdev_ethtool_ops;\n\nstatic void tc589_detach(struct pcmcia_device *p_dev);\n\nstatic const struct net_device_ops el3_netdev_ops = {\n\t.ndo_open\t\t= el3_open,\n\t.ndo_stop\t\t= el3_close,\n\t.ndo_start_xmit\t\t= el3_start_xmit,\n\t.ndo_tx_timeout\t\t= el3_tx_timeout,\n\t.ndo_set_config\t\t= el3_config,\n\t.ndo_get_stats\t\t= el3_get_stats,\n\t.ndo_set_rx_mode\t= set_multicast_list,\n\t.ndo_set_mac_address\t= eth_mac_addr,\n\t.ndo_validate_addr\t= eth_validate_addr,\n};\n\nstatic int tc589_probe(struct pcmcia_device *link)\n{\n\tstruct el3_private *lp;\n\tstruct net_device *dev;\n\tint ret;\n\n\tdev_dbg(&link->dev, \"3c589_attach()\\n\");\n\n\t \n\tdev = alloc_etherdev(sizeof(struct el3_private));\n\tif (!dev)\n\t\treturn -ENOMEM;\n\tlp = netdev_priv(dev);\n\tlink->priv = dev;\n\tlp->p_dev = link;\n\n\tspin_lock_init(&lp->lock);\n\tlink->resource[0]->end = 16;\n\tlink->resource[0]->flags |= IO_DATA_PATH_WIDTH_16;\n\n\tlink->config_flags |= CONF_ENABLE_IRQ;\n\tlink->config_index = 1;\n\n\tdev->netdev_ops = &el3_netdev_ops;\n\tdev->watchdog_timeo = TX_TIMEOUT;\n\n\tdev->ethtool_ops = &netdev_ethtool_ops;\n\n\tret = tc589_config(link);\n\tif (ret)\n\t\tgoto err_free_netdev;\n\n\treturn 0;\n\nerr_free_netdev:\n\tfree_netdev(dev);\n\treturn ret;\n}\n\nstatic void tc589_detach(struct pcmcia_device *link)\n{\n\tstruct net_device *dev = link->priv;\n\n\tdev_dbg(&link->dev, \"3c589_detach\\n\");\n\n\tunregister_netdev(dev);\n\n\ttc589_release(link);\n\n\tfree_netdev(dev);\n}  \n\nstatic int tc589_config(struct pcmcia_device *link)\n{\n\tstruct net_device *dev = link->priv;\n\tint ret, i, j, multi = 0, fifo;\n\t__be16 addr[ETH_ALEN / 2];\n\tunsigned int ioaddr;\n\tstatic const char * const ram_split[] = {\"5:3\", \"3:1\", \"1:1\", \"3:5\"};\n\tu8 *buf;\n\tsize_t len;\n\n\tdev_dbg(&link->dev, \"3c589_config\\n\");\n\n\t \n\tif (link->manf_id != MANFID_3COM)\n\t\tdev_info(&link->dev, \"hmmm, is this really a 3Com card??\\n\");\n\tmulti = (link->card_id == PRODID_3COM_3C562);\n\n\tlink->io_lines = 16;\n\n\t \n\tfor (i = j = 0; j < 0x400; j += 0x10) {\n\t\tif (multi && (j & 0x80))\n\t\t\tcontinue;\n\t\tlink->resource[0]->start = j ^ 0x300;\n\t\ti = pcmcia_request_io(link);\n\t\tif (i == 0)\n\t\t\tbreak;\n\t}\n\tif (i != 0)\n\t\tgoto failed;\n\n\tret = pcmcia_request_irq(link, el3_interrupt);\n\tif (ret)\n\t\tgoto failed;\n\n\tret = pcmcia_enable_device(link);\n\tif (ret)\n\t\tgoto failed;\n\n\tdev->irq = link->irq;\n\tdev->base_addr = link->resource[0]->start;\n\tioaddr = dev->base_addr;\n\tEL3WINDOW(0);\n\n\t \n\tlen = pcmcia_get_tuple(link, 0x88, &buf);\n\tif (buf && len >= 6) {\n\t\tfor (i = 0; i < 3; i++)\n\t\t\taddr[i] = htons(le16_to_cpu(buf[i*2]));\n\t\tkfree(buf);\n\t} else {\n\t\tkfree(buf);  \n\t\tfor (i = 0; i < 3; i++)\n\t\t\taddr[i] = htons(read_eeprom(ioaddr, i));\n\t\tif (addr[0] == htons(0x6060)) {\n\t\t\tdev_err(&link->dev, \"IO port conflict at 0x%03lx-0x%03lx\\n\",\n\t\t\t\t\tdev->base_addr, dev->base_addr+15);\n\t\t\tgoto failed;\n\t\t}\n\t}\n\teth_hw_addr_set(dev, (u8 *)addr);\n\n\t \n\n\toutw(0x3f00, ioaddr + 8);\n\tfifo = inl(ioaddr);\n\n\t \n\tif ((if_port >= 0) && (if_port <= 3))\n\t\tdev->if_port = if_port;\n\telse\n\t\tdev_err(&link->dev, \"invalid if_port requested\\n\");\n\n\tSET_NETDEV_DEV(dev, &link->dev);\n\n\tif (register_netdev(dev) != 0) {\n\t\tdev_err(&link->dev, \"register_netdev() failed\\n\");\n\t\tgoto failed;\n\t}\n\n\tnetdev_info(dev, \"3Com 3c%s, io %#3lx, irq %d, hw_addr %pM\\n\",\n\t\t\t(multi ? \"562\" : \"589\"), dev->base_addr, dev->irq,\n\t\t\tdev->dev_addr);\n\tnetdev_info(dev, \"  %dK FIFO split %s Rx:Tx, %s xcvr\\n\",\n\t\t\t(fifo & 7) ? 32 : 8, ram_split[(fifo >> 16) & 3],\n\t\t\tif_names[dev->if_port]);\n\treturn 0;\n\nfailed:\n\ttc589_release(link);\n\treturn -ENODEV;\n}  \n\nstatic void tc589_release(struct pcmcia_device *link)\n{\n\tpcmcia_disable_device(link);\n}\n\nstatic int tc589_suspend(struct pcmcia_device *link)\n{\n\tstruct net_device *dev = link->priv;\n\n\tif (link->open)\n\t\tnetif_device_detach(dev);\n\n\treturn 0;\n}\n\nstatic int tc589_resume(struct pcmcia_device *link)\n{\n\tstruct net_device *dev = link->priv;\n\n\tif (link->open) {\n\t\ttc589_reset(dev);\n\t\tnetif_device_attach(dev);\n\t}\n\n\treturn 0;\n}\n\n \n\n \n\nstatic void tc589_wait_for_completion(struct net_device *dev, int cmd)\n{\n\tint i = 100;\n\toutw(cmd, dev->base_addr + EL3_CMD);\n\twhile (--i > 0)\n\t\tif (!(inw(dev->base_addr + EL3_STATUS) & 0x1000))\n\t\t\tbreak;\n\tif (i == 0)\n\t\tnetdev_warn(dev, \"command 0x%04x did not complete!\\n\", cmd);\n}\n\n \n\nstatic u16 read_eeprom(unsigned int ioaddr, int index)\n{\n\tint i;\n\toutw(EEPROM_READ + index, ioaddr + 10);\n\t \n\tfor (i = 1620; i >= 0; i--)\n\t\tif ((inw(ioaddr + 10) & EEPROM_BUSY) == 0)\n\t\t\tbreak;\n\treturn inw(ioaddr + 12);\n}\n\n \n\nstatic void tc589_set_xcvr(struct net_device *dev, int if_port)\n{\n\tstruct el3_private *lp = netdev_priv(dev);\n\tunsigned int ioaddr = dev->base_addr;\n\n\tEL3WINDOW(0);\n\tswitch (if_port) {\n\tcase 0:\n\tcase 1:\n\t\toutw(0, ioaddr + 6);\n\t\tbreak;\n\tcase 2:\n\t\toutw(3<<14, ioaddr + 6);\n\t\tbreak;\n\tcase 3:\n\t\toutw(1<<14, ioaddr + 6);\n\t\tbreak;\n\t}\n\t \n\toutw((if_port == 2) ? StartCoax : StopCoax, ioaddr + EL3_CMD);\n\t \n\tEL3WINDOW(4);\n\toutw(MEDIA_LED | ((if_port < 2) ? MEDIA_TP : 0), ioaddr + WN4_MEDIA);\n\tEL3WINDOW(1);\n\tif (if_port == 2)\n\t\tlp->media_status = ((dev->if_port == 0) ? 0x8000 : 0x4000);\n\telse\n\t\tlp->media_status = ((dev->if_port == 0) ? 0x4010 : 0x8800);\n}\n\nstatic void dump_status(struct net_device *dev)\n{\n\tunsigned int ioaddr = dev->base_addr;\n\tEL3WINDOW(1);\n\tnetdev_info(dev, \"  irq status %04x, rx status %04x, tx status %02x  tx free %04x\\n\",\n\t\t\tinw(ioaddr+EL3_STATUS), inw(ioaddr+RX_STATUS),\n\t\t\tinb(ioaddr+TX_STATUS), inw(ioaddr+TX_FREE));\n\tEL3WINDOW(4);\n\tnetdev_info(dev, \"  diagnostics: fifo %04x net %04x ethernet %04x media %04x\\n\",\n\t\t\tinw(ioaddr+0x04), inw(ioaddr+0x06), inw(ioaddr+0x08),\n\t\t\tinw(ioaddr+0x0a));\n\tEL3WINDOW(1);\n}\n\n \nstatic void tc589_reset(struct net_device *dev)\n{\n\tunsigned int ioaddr = dev->base_addr;\n\tint i;\n\n\tEL3WINDOW(0);\n\toutw(0x0001, ioaddr + 4);\t\t\t \n\toutw(0x3f00, ioaddr + 8);\t\t\t \n\n\t \n\tEL3WINDOW(2);\n\tfor (i = 0; i < 6; i++)\n\t\toutb(dev->dev_addr[i], ioaddr + i);\n\n\ttc589_set_xcvr(dev, dev->if_port);\n\n\t \n\toutw(StatsDisable, ioaddr + EL3_CMD);\n\tEL3WINDOW(6);\n\tfor (i = 0; i < 9; i++)\n\t\tinb(ioaddr+i);\n\tinw(ioaddr + 10);\n\tinw(ioaddr + 12);\n\n\t \n\tEL3WINDOW(1);\n\n\tset_rx_mode(dev);\n\toutw(StatsEnable, ioaddr + EL3_CMD);  \n\toutw(RxEnable, ioaddr + EL3_CMD);  \n\toutw(TxEnable, ioaddr + EL3_CMD);  \n\t \n\toutw(SetStatusEnb | 0xff, ioaddr + EL3_CMD);\n\t \n\toutw(AckIntr | IntLatch | TxAvailable | RxEarly | IntReq,\n\t ioaddr + EL3_CMD);\n\toutw(SetIntrEnb | IntLatch | TxAvailable | RxComplete | StatsFull\n\t | AdapterFailure, ioaddr + EL3_CMD);\n}\n\nstatic void netdev_get_drvinfo(struct net_device *dev,\n\t\t\t       struct ethtool_drvinfo *info)\n{\n\tstrscpy(info->driver, DRV_NAME, sizeof(info->driver));\n\tsnprintf(info->bus_info, sizeof(info->bus_info),\n\t\t\"PCMCIA 0x%lx\", dev->base_addr);\n}\n\nstatic const struct ethtool_ops netdev_ethtool_ops = {\n\t.get_drvinfo\t\t= netdev_get_drvinfo,\n};\n\nstatic int el3_config(struct net_device *dev, struct ifmap *map)\n{\n\tif ((map->port != (u_char)(-1)) && (map->port != dev->if_port)) {\n\t\tif (map->port <= 3) {\n\t\t\tdev->if_port = map->port;\n\t\t\tnetdev_info(dev, \"switched to %s port\\n\", if_names[dev->if_port]);\n\t\t\ttc589_set_xcvr(dev, dev->if_port);\n\t\t} else {\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int el3_open(struct net_device *dev)\n{\n\tstruct el3_private *lp = netdev_priv(dev);\n\tstruct pcmcia_device *link = lp->p_dev;\n\n\tif (!pcmcia_dev_present(link))\n\t\treturn -ENODEV;\n\n\tlink->open++;\n\tnetif_start_queue(dev);\n\n\ttc589_reset(dev);\n\ttimer_setup(&lp->media, media_check, 0);\n\tmod_timer(&lp->media, jiffies + HZ);\n\n\tdev_dbg(&link->dev, \"%s: opened, status %4.4x.\\n\",\n\t  dev->name, inw(dev->base_addr + EL3_STATUS));\n\n\treturn 0;\n}\n\nstatic void el3_tx_timeout(struct net_device *dev, unsigned int txqueue)\n{\n\tunsigned int ioaddr = dev->base_addr;\n\n\tnetdev_warn(dev, \"Transmit timed out!\\n\");\n\tdump_status(dev);\n\tdev->stats.tx_errors++;\n\tnetif_trans_update(dev);  \n\t \n\ttc589_wait_for_completion(dev, TxReset);\n\toutw(TxEnable, ioaddr + EL3_CMD);\n\tnetif_wake_queue(dev);\n}\n\nstatic void pop_tx_status(struct net_device *dev)\n{\n\tunsigned int ioaddr = dev->base_addr;\n\tint i;\n\n\t \n\tfor (i = 32; i > 0; i--) {\n\t\tu_char tx_status = inb(ioaddr + TX_STATUS);\n\t\tif (!(tx_status & 0x84))\n\t\t\tbreak;\n\t\t \n\t\tif (tx_status & 0x30)\n\t\t\ttc589_wait_for_completion(dev, TxReset);\n\t\tif (tx_status & 0x38) {\n\t\t\tnetdev_dbg(dev, \"transmit error: status 0x%02x\\n\", tx_status);\n\t\t\toutw(TxEnable, ioaddr + EL3_CMD);\n\t\t\tdev->stats.tx_aborted_errors++;\n\t\t}\n\t\toutb(0x00, ioaddr + TX_STATUS);  \n\t}\n}\n\nstatic netdev_tx_t el3_start_xmit(struct sk_buff *skb,\n\t\t\t\t\tstruct net_device *dev)\n{\n\tunsigned int ioaddr = dev->base_addr;\n\tstruct el3_private *priv = netdev_priv(dev);\n\tunsigned long flags;\n\n\tnetdev_dbg(dev, \"el3_start_xmit(length = %ld) called, status %4.4x.\\n\",\n\t       (long)skb->len, inw(ioaddr + EL3_STATUS));\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\n\tdev->stats.tx_bytes += skb->len;\n\n\t \n\toutw(skb->len, ioaddr + TX_FIFO);\n\toutw(0x00, ioaddr + TX_FIFO);\n\t \n\toutsl(ioaddr + TX_FIFO, skb->data, (skb->len + 3) >> 2);\n\n\tif (inw(ioaddr + TX_FREE) <= 1536) {\n\t\tnetif_stop_queue(dev);\n\t\t \n\t\toutw(SetTxThreshold + 1536, ioaddr + EL3_CMD);\n\t}\n\n\tpop_tx_status(dev);\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\tdev_kfree_skb(skb);\n\n\treturn NETDEV_TX_OK;\n}\n\n \nstatic irqreturn_t el3_interrupt(int irq, void *dev_id)\n{\n\tstruct net_device *dev = (struct net_device *) dev_id;\n\tstruct el3_private *lp = netdev_priv(dev);\n\tunsigned int ioaddr;\n\t__u16 status;\n\tint i = 0, handled = 1;\n\n\tif (!netif_device_present(dev))\n\t\treturn IRQ_NONE;\n\n\tioaddr = dev->base_addr;\n\n\tnetdev_dbg(dev, \"interrupt, status %4.4x.\\n\", inw(ioaddr + EL3_STATUS));\n\n\tspin_lock(&lp->lock);\n\twhile ((status = inw(ioaddr + EL3_STATUS)) &\n\t(IntLatch | RxComplete | StatsFull)) {\n\t\tif ((status & 0xe000) != 0x2000) {\n\t\t\tnetdev_dbg(dev, \"interrupt from dead card\\n\");\n\t\t\thandled = 0;\n\t\t\tbreak;\n\t\t}\n\t\tif (status & RxComplete)\n\t\t\tel3_rx(dev);\n\t\tif (status & TxAvailable) {\n\t\t\tnetdev_dbg(dev, \"    TX room bit was handled.\\n\");\n\t\t\t \n\t\t\toutw(AckIntr | TxAvailable, ioaddr + EL3_CMD);\n\t\t\tnetif_wake_queue(dev);\n\t\t}\n\t\tif (status & TxComplete)\n\t\t\tpop_tx_status(dev);\n\t\tif (status & (AdapterFailure | RxEarly | StatsFull)) {\n\t\t\t \n\t\t\tif (status & StatsFull)\t\t \n\t\t\t\tupdate_stats(dev);\n\t\t\tif (status & RxEarly) {\n\t\t\t\t \n\t\t\t\tel3_rx(dev);\n\t\t\t\toutw(AckIntr | RxEarly, ioaddr + EL3_CMD);\n\t\t\t}\n\t\t\tif (status & AdapterFailure) {\n\t\t\t\tu16 fifo_diag;\n\t\t\t\tEL3WINDOW(4);\n\t\t\t\tfifo_diag = inw(ioaddr + 4);\n\t\t\t\tEL3WINDOW(1);\n\t\t\t\tnetdev_warn(dev, \"adapter failure, FIFO diagnostic register %04x.\\n\",\n\t\t\t    fifo_diag);\n\t\t\t\tif (fifo_diag & 0x0400) {\n\t\t\t\t\t \n\t\t\t\t\ttc589_wait_for_completion(dev, TxReset);\n\t\t\t\t\toutw(TxEnable, ioaddr + EL3_CMD);\n\t\t\t\t}\n\t\t\t\tif (fifo_diag & 0x2000) {\n\t\t\t\t\t \n\t\t\t\t\ttc589_wait_for_completion(dev, RxReset);\n\t\t\t\t\tset_rx_mode(dev);\n\t\t\t\t\toutw(RxEnable, ioaddr + EL3_CMD);\n\t\t\t\t}\n\t\t\t\toutw(AckIntr | AdapterFailure, ioaddr + EL3_CMD);\n\t\t\t}\n\t\t}\n\t\tif (++i > 10) {\n\t\t\tnetdev_err(dev, \"infinite loop in interrupt, status %4.4x.\\n\",\n\t\t\t\t\tstatus);\n\t\t\t \n\t\t\toutw(AckIntr | 0xFF, ioaddr + EL3_CMD);\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\toutw(AckIntr | IntReq | IntLatch, ioaddr + EL3_CMD);\n\t}\n\tlp->last_irq = jiffies;\n\tspin_unlock(&lp->lock);\n\tnetdev_dbg(dev, \"exiting interrupt, status %4.4x.\\n\",\n\t\t\tinw(ioaddr + EL3_STATUS));\n\treturn IRQ_RETVAL(handled);\n}\n\nstatic void media_check(struct timer_list *t)\n{\n\tstruct el3_private *lp = from_timer(lp, t, media);\n\tstruct net_device *dev = lp->p_dev->priv;\n\tunsigned int ioaddr = dev->base_addr;\n\tu16 media, errs;\n\tunsigned long flags;\n\n\tif (!netif_device_present(dev))\n\t\tgoto reschedule;\n\n\t \n\tif ((inw(ioaddr + EL3_STATUS) & IntLatch) &&\n\t(inb(ioaddr + EL3_TIMER) == 0xff)) {\n\t\tif (!lp->fast_poll)\n\t\t\tnetdev_warn(dev, \"interrupt(s) dropped!\\n\");\n\n\t\tlocal_irq_save(flags);\n\t\tel3_interrupt(dev->irq, dev);\n\t\tlocal_irq_restore(flags);\n\n\t\tlp->fast_poll = HZ;\n\t}\n\tif (lp->fast_poll) {\n\t\tlp->fast_poll--;\n\t\tlp->media.expires = jiffies + HZ/100;\n\t\tadd_timer(&lp->media);\n\t\treturn;\n\t}\n\n\t \n\n\tspin_lock_irqsave(&lp->lock, flags);\n\tEL3WINDOW(4);\n\tmedia = inw(ioaddr+WN4_MEDIA) & 0xc810;\n\n\t \n\tif (time_before(jiffies, lp->last_irq + HZ)) {\n\t\tmedia &= ~0x0010;\n\t} else {\n\t\t \n\t\tEL3WINDOW(6);\n\t\toutw(StatsDisable, ioaddr + EL3_CMD);\n\t\terrs = inb(ioaddr + 0);\n\t\toutw(StatsEnable, ioaddr + EL3_CMD);\n\t\tdev->stats.tx_carrier_errors += errs;\n\t\tif (errs || (lp->media_status & 0x0010))\n\t\t\tmedia |= 0x0010;\n\t}\n\n\tif (media != lp->media_status) {\n\t\tif ((media & lp->media_status & 0x8000) &&\n\t\t\t\t((lp->media_status ^ media) & 0x0800))\n\t\tnetdev_info(dev, \"%s link beat\\n\",\n\t\t\t\t(lp->media_status & 0x0800 ? \"lost\" : \"found\"));\n\t\telse if ((media & lp->media_status & 0x4000) &&\n\t\t ((lp->media_status ^ media) & 0x0010))\n\t\tnetdev_info(dev, \"coax cable %s\\n\",\n\t\t\t\t(lp->media_status & 0x0010 ? \"ok\" : \"problem\"));\n\t\tif (dev->if_port == 0) {\n\t\t\tif (media & 0x8000) {\n\t\t\t\tif (media & 0x0800)\n\t\t\t\t\tnetdev_info(dev, \"flipped to 10baseT\\n\");\n\t\t\t\telse\n\t\t\ttc589_set_xcvr(dev, 2);\n\t\t\t} else if (media & 0x4000) {\n\t\t\t\tif (media & 0x0010)\n\t\t\t\t\ttc589_set_xcvr(dev, 1);\n\t\t\t\telse\n\t\t\t\t\tnetdev_info(dev, \"flipped to 10base2\\n\");\n\t\t\t}\n\t\t}\n\t\tlp->media_status = media;\n\t}\n\n\tEL3WINDOW(1);\n\tspin_unlock_irqrestore(&lp->lock, flags);\n\nreschedule:\n\tlp->media.expires = jiffies + HZ;\n\tadd_timer(&lp->media);\n}\n\nstatic struct net_device_stats *el3_get_stats(struct net_device *dev)\n{\n\tstruct el3_private *lp = netdev_priv(dev);\n\tunsigned long flags;\n\tstruct pcmcia_device *link = lp->p_dev;\n\n\tif (pcmcia_dev_present(link)) {\n\t\tspin_lock_irqsave(&lp->lock, flags);\n\t\tupdate_stats(dev);\n\t\tspin_unlock_irqrestore(&lp->lock, flags);\n\t}\n\treturn &dev->stats;\n}\n\n \n\nstatic void update_stats(struct net_device *dev)\n{\n\tunsigned int ioaddr = dev->base_addr;\n\n\tnetdev_dbg(dev, \"updating the statistics.\\n\");\n\t \n\toutw(StatsDisable, ioaddr + EL3_CMD);\n\t \n\tEL3WINDOW(6);\n\tdev->stats.tx_carrier_errors\t+= inb(ioaddr + 0);\n\tdev->stats.tx_heartbeat_errors\t+= inb(ioaddr + 1);\n\t \n\tinb(ioaddr + 2);\n\tdev->stats.collisions\t\t+= inb(ioaddr + 3);\n\tdev->stats.tx_window_errors\t\t+= inb(ioaddr + 4);\n\tdev->stats.rx_fifo_errors\t\t+= inb(ioaddr + 5);\n\tdev->stats.tx_packets\t\t+= inb(ioaddr + 6);\n\t \n\tinb(ioaddr + 7);\n\t \n\tinb(ioaddr + 8);\n\t \n\tinw(ioaddr + 10);\n\t \n\tinw(ioaddr + 12);\n\n\t \n\tEL3WINDOW(1);\n\toutw(StatsEnable, ioaddr + EL3_CMD);\n}\n\nstatic int el3_rx(struct net_device *dev)\n{\n\tunsigned int ioaddr = dev->base_addr;\n\tint worklimit = 32;\n\tshort rx_status;\n\n\tnetdev_dbg(dev, \"in rx_packet(), status %4.4x, rx_status %4.4x.\\n\",\n\t       inw(ioaddr+EL3_STATUS), inw(ioaddr+RX_STATUS));\n\twhile (!((rx_status = inw(ioaddr + RX_STATUS)) & 0x8000) &&\n\t\t    worklimit > 0) {\n\t\tworklimit--;\n\t\tif (rx_status & 0x4000) {  \n\t\t\tshort error = rx_status & 0x3800;\n\t\t\tdev->stats.rx_errors++;\n\t\t\tswitch (error) {\n\t\t\tcase 0x0000:\n\t\t\t\tdev->stats.rx_over_errors++;\n\t\t\t\tbreak;\n\t\t\tcase 0x0800:\n\t\t\t\tdev->stats.rx_length_errors++;\n\t\t\t\tbreak;\n\t\t\tcase 0x1000:\n\t\t\t\tdev->stats.rx_frame_errors++;\n\t\t\t\tbreak;\n\t\t\tcase 0x1800:\n\t\t\t\tdev->stats.rx_length_errors++;\n\t\t\t\tbreak;\n\t\t\tcase 0x2000:\n\t\t\t\tdev->stats.rx_frame_errors++;\n\t\t\t\tbreak;\n\t\t\tcase 0x2800:\n\t\t\t\tdev->stats.rx_crc_errors++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tshort pkt_len = rx_status & 0x7ff;\n\t\t\tstruct sk_buff *skb;\n\n\t\t\tskb = netdev_alloc_skb(dev, pkt_len + 5);\n\n\t\t\tnetdev_dbg(dev, \"    Receiving packet size %d status %4.4x.\\n\",\n\t\t       pkt_len, rx_status);\n\t\t\tif (skb != NULL) {\n\t\t\t\tskb_reserve(skb, 2);\n\t\t\t\tinsl(ioaddr+RX_FIFO, skb_put(skb, pkt_len),\n\t\t\t(pkt_len+3)>>2);\n\t\t\t\tskb->protocol = eth_type_trans(skb, dev);\n\t\t\t\tnetif_rx(skb);\n\t\t\t\tdev->stats.rx_packets++;\n\t\t\t\tdev->stats.rx_bytes += pkt_len;\n\t\t\t} else {\n\t\t\t\tnetdev_dbg(dev, \"couldn't allocate a sk_buff of size %d.\\n\",\n\t\t\t   pkt_len);\n\t\t\t\tdev->stats.rx_dropped++;\n\t\t\t}\n\t\t}\n\t\t \n\t\ttc589_wait_for_completion(dev, RxDiscard);\n\t}\n\tif (worklimit == 0)\n\t\tnetdev_warn(dev, \"too much work in el3_rx!\\n\");\n\treturn 0;\n}\n\nstatic void set_rx_mode(struct net_device *dev)\n{\n\tunsigned int ioaddr = dev->base_addr;\n\tu16 opts = SetRxFilter | RxStation | RxBroadcast;\n\n\tif (dev->flags & IFF_PROMISC)\n\t\topts |= RxMulticast | RxProm;\n\telse if (!netdev_mc_empty(dev) || (dev->flags & IFF_ALLMULTI))\n\t\topts |= RxMulticast;\n\toutw(opts, ioaddr + EL3_CMD);\n}\n\nstatic void set_multicast_list(struct net_device *dev)\n{\n\tstruct el3_private *priv = netdev_priv(dev);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\tset_rx_mode(dev);\n\tspin_unlock_irqrestore(&priv->lock, flags);\n}\n\nstatic int el3_close(struct net_device *dev)\n{\n\tstruct el3_private *lp = netdev_priv(dev);\n\tstruct pcmcia_device *link = lp->p_dev;\n\tunsigned int ioaddr = dev->base_addr;\n\n\tdev_dbg(&link->dev, \"%s: shutting down ethercard.\\n\", dev->name);\n\n\tif (pcmcia_dev_present(link)) {\n\t\t \n\t\toutw(StatsDisable, ioaddr + EL3_CMD);\n\n\t\t \n\t\toutw(RxDisable, ioaddr + EL3_CMD);\n\t\toutw(TxDisable, ioaddr + EL3_CMD);\n\n\t\tif (dev->if_port == 2)\n\t\t\t \n\t\t\toutw(StopCoax, ioaddr + EL3_CMD);\n\t\telse if (dev->if_port == 1) {\n\t\t\t \n\t\t\tEL3WINDOW(4);\n\t\t\toutw(0, ioaddr + WN4_MEDIA);\n\t\t}\n\n\t\t \n\t\tEL3WINDOW(0);\n\t\t \n\t\toutw(0x0f00, ioaddr + WN0_IRQ);\n\n\t\t \n\t\tif ((inw(ioaddr+EL3_STATUS) & 0xe000) == 0x2000)\n\t\t\tupdate_stats(dev);\n\t}\n\n\tlink->open--;\n\tnetif_stop_queue(dev);\n\tdel_timer_sync(&lp->media);\n\n\treturn 0;\n}\n\nstatic const struct pcmcia_device_id tc589_ids[] = {\n\tPCMCIA_MFC_DEVICE_MANF_CARD(0, 0x0101, 0x0562),\n\tPCMCIA_MFC_DEVICE_PROD_ID1(0, \"Motorola MARQUIS\", 0xf03e4e77),\n\tPCMCIA_DEVICE_MANF_CARD(0x0101, 0x0589),\n\tPCMCIA_DEVICE_PROD_ID12(\"Farallon\", \"ENet\", 0x58d93fc4, 0x992c2202),\n\tPCMCIA_MFC_DEVICE_CIS_MANF_CARD(0, 0x0101, 0x0035, \"cis/3CXEM556.cis\"),\n\tPCMCIA_MFC_DEVICE_CIS_MANF_CARD(0, 0x0101, 0x003d, \"cis/3CXEM556.cis\"),\n\tPCMCIA_DEVICE_NULL,\n};\nMODULE_DEVICE_TABLE(pcmcia, tc589_ids);\n\nstatic struct pcmcia_driver tc589_driver = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"3c589_cs\",\n\t.probe\t\t= tc589_probe,\n\t.remove\t\t= tc589_detach,\n\t.id_table\t= tc589_ids,\n\t.suspend\t= tc589_suspend,\n\t.resume\t\t= tc589_resume,\n};\nmodule_pcmcia_driver(tc589_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}