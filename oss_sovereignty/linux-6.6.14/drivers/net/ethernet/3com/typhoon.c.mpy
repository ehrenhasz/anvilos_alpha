{
  "module_name": "typhoon.c",
  "hash_id": "0566b500f1b5eaa5f43e28f60c979dcebafa00ebb7268a4425ebe5a7c107caf3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/3com/typhoon.c",
  "human_readable_source": " \n \n\n \nstatic int rx_copybreak = 200;\n\n \nstatic unsigned int use_mmio = 2;\n\n \n\n \nstatic const int multicast_filter_limit = 32;\n\n \n\n \n#define TXHI_ENTRIES\t\t2\n#define TXLO_ENTRIES\t\t128\n#define RX_ENTRIES\t\t32\n#define COMMAND_ENTRIES\t\t16\n#define RESPONSE_ENTRIES\t32\n\n#define COMMAND_RING_SIZE\t(COMMAND_ENTRIES * sizeof(struct cmd_desc))\n#define RESPONSE_RING_SIZE\t(RESPONSE_ENTRIES * sizeof(struct resp_desc))\n\n \n#define RXFREE_ENTRIES\t\t128\n#define RXENT_ENTRIES\t\t(RXFREE_ENTRIES - 1)\n\n \n\n \n#define TX_TIMEOUT  (2*HZ)\n\n#define PKT_BUF_SZ\t\t1536\n#define FIRMWARE_NAME\t\t\"3com/typhoon.bin\"\n\n#define pr_fmt(fmt)\t\tKBUILD_MODNAME \" \" fmt\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/timer.h>\n#include <linux/errno.h>\n#include <linux/ioport.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/skbuff.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/ethtool.h>\n#include <linux/if_vlan.h>\n#include <linux/crc32.h>\n#include <linux/bitops.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/in6.h>\n#include <linux/dma-mapping.h>\n#include <linux/firmware.h>\n\n#include \"typhoon.h\"\n\nMODULE_AUTHOR(\"David Dillow <dave@thedillows.org>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_FIRMWARE(FIRMWARE_NAME);\nMODULE_DESCRIPTION(\"3Com Typhoon Family (3C990, 3CR990, and variants)\");\nMODULE_PARM_DESC(rx_copybreak, \"Packets smaller than this are copied and \"\n\t\t\t       \"the buffer given back to the NIC. Default \"\n\t\t\t       \"is 200.\");\nMODULE_PARM_DESC(use_mmio, \"Use MMIO (1) or PIO(0) to access the NIC. \"\n\t\t\t   \"Default is to try MMIO and fallback to PIO.\");\nmodule_param(rx_copybreak, int, 0);\nmodule_param(use_mmio, int, 0);\n\n#if TXLO_ENTRIES <= (2 * MAX_SKB_FRAGS)\n#error TX ring too small!\n#endif\n\nstruct typhoon_card_info {\n\tconst char *name;\n\tconst int capabilities;\n};\n\n#define TYPHOON_CRYPTO_NONE\t\t0x00\n#define TYPHOON_CRYPTO_DES\t\t0x01\n#define TYPHOON_CRYPTO_3DES\t\t0x02\n#define\tTYPHOON_CRYPTO_VARIABLE\t\t0x04\n#define TYPHOON_FIBER\t\t\t0x08\n#define TYPHOON_WAKEUP_NEEDS_RESET\t0x10\n\nenum typhoon_cards {\n\tTYPHOON_TX = 0, TYPHOON_TX95, TYPHOON_TX97, TYPHOON_SVR,\n\tTYPHOON_SVR95, TYPHOON_SVR97, TYPHOON_TXM, TYPHOON_BSVR,\n\tTYPHOON_FX95, TYPHOON_FX97, TYPHOON_FX95SVR, TYPHOON_FX97SVR,\n\tTYPHOON_FXM,\n};\n\n \nstatic struct typhoon_card_info typhoon_card_info[] = {\n\t{ \"3Com Typhoon (3C990-TX)\",\n\t\tTYPHOON_CRYPTO_NONE},\n\t{ \"3Com Typhoon (3CR990-TX-95)\",\n\t\tTYPHOON_CRYPTO_DES},\n\t{ \"3Com Typhoon (3CR990-TX-97)\",\n\t \tTYPHOON_CRYPTO_DES | TYPHOON_CRYPTO_3DES},\n\t{ \"3Com Typhoon (3C990SVR)\",\n\t\tTYPHOON_CRYPTO_NONE},\n\t{ \"3Com Typhoon (3CR990SVR95)\",\n\t\tTYPHOON_CRYPTO_DES},\n\t{ \"3Com Typhoon (3CR990SVR97)\",\n\t \tTYPHOON_CRYPTO_DES | TYPHOON_CRYPTO_3DES},\n\t{ \"3Com Typhoon2 (3C990B-TX-M)\",\n\t\tTYPHOON_CRYPTO_VARIABLE},\n\t{ \"3Com Typhoon2 (3C990BSVR)\",\n\t\tTYPHOON_CRYPTO_VARIABLE},\n\t{ \"3Com Typhoon (3CR990-FX-95)\",\n\t\tTYPHOON_CRYPTO_DES | TYPHOON_FIBER},\n\t{ \"3Com Typhoon (3CR990-FX-97)\",\n\t \tTYPHOON_CRYPTO_DES | TYPHOON_CRYPTO_3DES | TYPHOON_FIBER},\n\t{ \"3Com Typhoon (3CR990-FX-95 Server)\",\n\t \tTYPHOON_CRYPTO_DES | TYPHOON_FIBER},\n\t{ \"3Com Typhoon (3CR990-FX-97 Server)\",\n\t \tTYPHOON_CRYPTO_DES | TYPHOON_CRYPTO_3DES | TYPHOON_FIBER},\n\t{ \"3Com Typhoon2 (3C990B-FX-97)\",\n\t\tTYPHOON_CRYPTO_VARIABLE | TYPHOON_FIBER},\n};\n\n \nstatic const struct pci_device_id typhoon_pci_tbl[] = {\n\t{ PCI_VENDOR_ID_3COM, PCI_DEVICE_ID_3COM_3CR990,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0,TYPHOON_TX },\n\t{ PCI_VENDOR_ID_3COM, PCI_DEVICE_ID_3COM_3CR990_TX_95,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, TYPHOON_TX95 },\n\t{ PCI_VENDOR_ID_3COM, PCI_DEVICE_ID_3COM_3CR990_TX_97,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, TYPHOON_TX97 },\n\t{ PCI_VENDOR_ID_3COM, PCI_DEVICE_ID_3COM_3CR990B,\n\t  PCI_ANY_ID, 0x1000, 0, 0, TYPHOON_TXM },\n\t{ PCI_VENDOR_ID_3COM, PCI_DEVICE_ID_3COM_3CR990B,\n\t  PCI_ANY_ID, 0x1102, 0, 0, TYPHOON_FXM },\n\t{ PCI_VENDOR_ID_3COM, PCI_DEVICE_ID_3COM_3CR990B,\n\t  PCI_ANY_ID, 0x2000, 0, 0, TYPHOON_BSVR },\n\t{ PCI_VENDOR_ID_3COM, PCI_DEVICE_ID_3COM_3CR990_FX,\n\t  PCI_ANY_ID, 0x1101, 0, 0, TYPHOON_FX95 },\n\t{ PCI_VENDOR_ID_3COM, PCI_DEVICE_ID_3COM_3CR990_FX,\n\t  PCI_ANY_ID, 0x1102, 0, 0, TYPHOON_FX97 },\n\t{ PCI_VENDOR_ID_3COM, PCI_DEVICE_ID_3COM_3CR990_FX,\n\t  PCI_ANY_ID, 0x2101, 0, 0, TYPHOON_FX95SVR },\n\t{ PCI_VENDOR_ID_3COM, PCI_DEVICE_ID_3COM_3CR990_FX,\n\t  PCI_ANY_ID, 0x2102, 0, 0, TYPHOON_FX97SVR },\n\t{ PCI_VENDOR_ID_3COM, PCI_DEVICE_ID_3COM_3CR990SVR95,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, TYPHOON_SVR95 },\n\t{ PCI_VENDOR_ID_3COM, PCI_DEVICE_ID_3COM_3CR990SVR97,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, TYPHOON_SVR97 },\n\t{ PCI_VENDOR_ID_3COM, PCI_DEVICE_ID_3COM_3CR990SVR,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, TYPHOON_SVR },\n\t{ 0, }\n};\nMODULE_DEVICE_TABLE(pci, typhoon_pci_tbl);\n\n \n#define __3xp_aligned\t____cacheline_aligned\nstruct typhoon_shared {\n\tstruct typhoon_interface\tiface;\n\tstruct typhoon_indexes\t\tindexes\t\t\t__3xp_aligned;\n\tstruct tx_desc\t\t\ttxLo[TXLO_ENTRIES] \t__3xp_aligned;\n\tstruct rx_desc\t\t\trxLo[RX_ENTRIES]\t__3xp_aligned;\n\tstruct rx_desc\t\t\trxHi[RX_ENTRIES]\t__3xp_aligned;\n\tstruct cmd_desc\t\t\tcmd[COMMAND_ENTRIES]\t__3xp_aligned;\n\tstruct resp_desc\t\tresp[RESPONSE_ENTRIES]\t__3xp_aligned;\n\tstruct rx_free\t\t\trxBuff[RXFREE_ENTRIES]\t__3xp_aligned;\n\tu32\t\t\t\tzeroWord;\n\tstruct tx_desc\t\t\ttxHi[TXHI_ENTRIES];\n} __packed;\n\nstruct rxbuff_ent {\n\tstruct sk_buff *skb;\n\tdma_addr_t\tdma_addr;\n};\n\nstruct typhoon {\n\t \n\tstruct transmit_ring \ttxLoRing\t____cacheline_aligned;\n\tstruct pci_dev *\ttx_pdev;\n\tvoid __iomem\t\t*tx_ioaddr;\n\tu32\t\t\ttxlo_dma_addr;\n\n\t \n\tvoid __iomem\t\t*ioaddr\t\t____cacheline_aligned;\n\tstruct typhoon_indexes *indexes;\n\tu8\t\t\tawaiting_resp;\n\tu8\t\t\tduplex;\n\tu8\t\t\tspeed;\n\tu8\t\t\tcard_state;\n\tstruct basic_ring\trxLoRing;\n\tstruct pci_dev *\tpdev;\n\tstruct net_device *\tdev;\n\tstruct napi_struct\tnapi;\n\tstruct basic_ring\trxHiRing;\n\tstruct basic_ring\trxBuffRing;\n\tstruct rxbuff_ent\trxbuffers[RXENT_ENTRIES];\n\n\t \n\tspinlock_t\t\tcommand_lock\t____cacheline_aligned;\n\tstruct basic_ring\tcmdRing;\n\tstruct basic_ring\trespRing;\n\tstruct net_device_stats\tstats_saved;\n\tstruct typhoon_shared *\tshared;\n\tdma_addr_t\t\tshared_dma;\n\t__le16\t\t\txcvr_select;\n\t__le16\t\t\twol_events;\n\t__le32\t\t\toffload;\n\n\t \n\tint\t\t\tcapabilities;\n\tstruct transmit_ring \ttxHiRing;\n};\n\nenum completion_wait_values {\n\tNoWait = 0, WaitNoSleep, WaitSleep,\n};\n\n \nenum state_values {\n\tSleeping = 0, Running,\n};\n\n \n#define typhoon_post_pci_writes(x) \\\n\tdo { if (likely(use_mmio)) ioread32(x+TYPHOON_REG_HEARTBEAT); } while (0)\n\n \n#define TYPHOON_UDELAY\t\t\t50\n#define TYPHOON_RESET_TIMEOUT_SLEEP\t(6 * HZ)\n#define TYPHOON_RESET_TIMEOUT_NOSLEEP\t((6 * 1000000) / TYPHOON_UDELAY)\n#define TYPHOON_WAIT_TIMEOUT\t\t((1000000 / 2) / TYPHOON_UDELAY)\n\n#if defined(NETIF_F_TSO)\n#define skb_tso_size(x)\t\t(skb_shinfo(x)->gso_size)\n#define TSO_NUM_DESCRIPTORS\t2\n#define TSO_OFFLOAD_ON\t\tTYPHOON_OFFLOAD_TCP_SEGMENT\n#else\n#define NETIF_F_TSO \t\t0\n#define skb_tso_size(x) \t0\n#define TSO_NUM_DESCRIPTORS\t0\n#define TSO_OFFLOAD_ON\t\t0\n#endif\n\nstatic inline void\ntyphoon_inc_index(u32 *index, const int count, const int num_entries)\n{\n\t \n\t*index += count * sizeof(struct cmd_desc);\n\t*index %= num_entries * sizeof(struct cmd_desc);\n}\n\nstatic inline void\ntyphoon_inc_cmd_index(u32 *index, const int count)\n{\n\ttyphoon_inc_index(index, count, COMMAND_ENTRIES);\n}\n\nstatic inline void\ntyphoon_inc_resp_index(u32 *index, const int count)\n{\n\ttyphoon_inc_index(index, count, RESPONSE_ENTRIES);\n}\n\nstatic inline void\ntyphoon_inc_rxfree_index(u32 *index, const int count)\n{\n\ttyphoon_inc_index(index, count, RXFREE_ENTRIES);\n}\n\nstatic inline void\ntyphoon_inc_tx_index(u32 *index, const int count)\n{\n\t \n\ttyphoon_inc_index(index, count, TXLO_ENTRIES);\n}\n\nstatic inline void\ntyphoon_inc_rx_index(u32 *index, const int count)\n{\n\t \n\t*index += count * sizeof(struct rx_desc);\n\t*index %= RX_ENTRIES * sizeof(struct rx_desc);\n}\n\nstatic int\ntyphoon_reset(void __iomem *ioaddr, int wait_type)\n{\n\tint i, err = 0;\n\tint timeout;\n\n\tif (wait_type == WaitNoSleep)\n\t\ttimeout = TYPHOON_RESET_TIMEOUT_NOSLEEP;\n\telse\n\t\ttimeout = TYPHOON_RESET_TIMEOUT_SLEEP;\n\n\tiowrite32(TYPHOON_INTR_ALL, ioaddr + TYPHOON_REG_INTR_MASK);\n\tiowrite32(TYPHOON_INTR_ALL, ioaddr + TYPHOON_REG_INTR_STATUS);\n\n\tiowrite32(TYPHOON_RESET_ALL, ioaddr + TYPHOON_REG_SOFT_RESET);\n\ttyphoon_post_pci_writes(ioaddr);\n\tudelay(1);\n\tiowrite32(TYPHOON_RESET_NONE, ioaddr + TYPHOON_REG_SOFT_RESET);\n\n\tif (wait_type != NoWait) {\n\t\tfor (i = 0; i < timeout; i++) {\n\t\t\tif (ioread32(ioaddr + TYPHOON_REG_STATUS) ==\n\t\t\t   TYPHOON_STATUS_WAITING_FOR_HOST)\n\t\t\t\tgoto out;\n\n\t\t\tif (wait_type == WaitSleep)\n\t\t\t\tschedule_timeout_uninterruptible(1);\n\t\t\telse\n\t\t\t\tudelay(TYPHOON_UDELAY);\n\t\t}\n\n\t\terr = -ETIMEDOUT;\n\t}\n\nout:\n\tiowrite32(TYPHOON_INTR_ALL, ioaddr + TYPHOON_REG_INTR_MASK);\n\tiowrite32(TYPHOON_INTR_ALL, ioaddr + TYPHOON_REG_INTR_STATUS);\n\n\t \n\tif (wait_type == WaitSleep)\n\t\tmsleep(5);\n\telse\n\t\tudelay(500);\n\treturn err;\n}\n\nstatic int\ntyphoon_wait_status(void __iomem *ioaddr, u32 wait_value)\n{\n\tint i, err = 0;\n\n\tfor (i = 0; i < TYPHOON_WAIT_TIMEOUT; i++) {\n\t\tif (ioread32(ioaddr + TYPHOON_REG_STATUS) == wait_value)\n\t\t\tgoto out;\n\t\tudelay(TYPHOON_UDELAY);\n\t}\n\n\terr = -ETIMEDOUT;\n\nout:\n\treturn err;\n}\n\nstatic inline void\ntyphoon_media_status(struct net_device *dev, struct resp_desc *resp)\n{\n\tif (resp->parm1 & TYPHOON_MEDIA_STAT_NO_LINK)\n\t\tnetif_carrier_off(dev);\n\telse\n\t\tnetif_carrier_on(dev);\n}\n\nstatic inline void\ntyphoon_hello(struct typhoon *tp)\n{\n\tstruct basic_ring *ring = &tp->cmdRing;\n\tstruct cmd_desc *cmd;\n\n\t \n\tif (spin_trylock(&tp->command_lock)) {\n\t\tcmd = (struct cmd_desc *)(ring->ringBase + ring->lastWrite);\n\t\ttyphoon_inc_cmd_index(&ring->lastWrite, 1);\n\n\t\tINIT_COMMAND_NO_RESPONSE(cmd, TYPHOON_CMD_HELLO_RESP);\n\t\twmb();\n\t\tiowrite32(ring->lastWrite, tp->ioaddr + TYPHOON_REG_CMD_READY);\n\t\tspin_unlock(&tp->command_lock);\n\t}\n}\n\nstatic int\ntyphoon_process_response(struct typhoon *tp, int resp_size,\n\t\t\t\tstruct resp_desc *resp_save)\n{\n\tstruct typhoon_indexes *indexes = tp->indexes;\n\tstruct resp_desc *resp;\n\tu8 *base = tp->respRing.ringBase;\n\tint count, len, wrap_len;\n\tu32 cleared;\n\tu32 ready;\n\n\tcleared = le32_to_cpu(indexes->respCleared);\n\tready = le32_to_cpu(indexes->respReady);\n\twhile (cleared != ready) {\n\t\tresp = (struct resp_desc *)(base + cleared);\n\t\tcount = resp->numDesc + 1;\n\t\tif (resp_save && resp->seqNo) {\n\t\t\tif (count > resp_size) {\n\t\t\t\tresp_save->flags = TYPHOON_RESP_ERROR;\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\n\t\t\twrap_len = 0;\n\t\t\tlen = count * sizeof(*resp);\n\t\t\tif (unlikely(cleared + len > RESPONSE_RING_SIZE)) {\n\t\t\t\twrap_len = cleared + len - RESPONSE_RING_SIZE;\n\t\t\t\tlen = RESPONSE_RING_SIZE - cleared;\n\t\t\t}\n\n\t\t\tmemcpy(resp_save, resp, len);\n\t\t\tif (unlikely(wrap_len)) {\n\t\t\t\tresp_save += len / sizeof(*resp);\n\t\t\t\tmemcpy(resp_save, base, wrap_len);\n\t\t\t}\n\n\t\t\tresp_save = NULL;\n\t\t} else if (resp->cmd == TYPHOON_CMD_READ_MEDIA_STATUS) {\n\t\t\ttyphoon_media_status(tp->dev, resp);\n\t\t} else if (resp->cmd == TYPHOON_CMD_HELLO_RESP) {\n\t\t\ttyphoon_hello(tp);\n\t\t} else {\n\t\t\tnetdev_err(tp->dev,\n\t\t\t\t   \"dumping unexpected response 0x%04x:%d:0x%02x:0x%04x:%08x:%08x\\n\",\n\t\t\t\t   le16_to_cpu(resp->cmd),\n\t\t\t\t   resp->numDesc, resp->flags,\n\t\t\t\t   le16_to_cpu(resp->parm1),\n\t\t\t\t   le32_to_cpu(resp->parm2),\n\t\t\t\t   le32_to_cpu(resp->parm3));\n\t\t}\n\ncleanup:\n\t\ttyphoon_inc_resp_index(&cleared, count);\n\t}\n\n\tindexes->respCleared = cpu_to_le32(cleared);\n\twmb();\n\treturn resp_save == NULL;\n}\n\nstatic inline int\ntyphoon_num_free(int lastWrite, int lastRead, int ringSize)\n{\n\t \n\tlastWrite /= sizeof(struct cmd_desc);\n\tlastRead /= sizeof(struct cmd_desc);\n\treturn (ringSize + lastRead - lastWrite - 1) % ringSize;\n}\n\nstatic inline int\ntyphoon_num_free_cmd(struct typhoon *tp)\n{\n\tint lastWrite = tp->cmdRing.lastWrite;\n\tint cmdCleared = le32_to_cpu(tp->indexes->cmdCleared);\n\n\treturn typhoon_num_free(lastWrite, cmdCleared, COMMAND_ENTRIES);\n}\n\nstatic inline int\ntyphoon_num_free_resp(struct typhoon *tp)\n{\n\tint respReady = le32_to_cpu(tp->indexes->respReady);\n\tint respCleared = le32_to_cpu(tp->indexes->respCleared);\n\n\treturn typhoon_num_free(respReady, respCleared, RESPONSE_ENTRIES);\n}\n\nstatic inline int\ntyphoon_num_free_tx(struct transmit_ring *ring)\n{\n\t \n\treturn typhoon_num_free(ring->lastWrite, ring->lastRead, TXLO_ENTRIES);\n}\n\nstatic int\ntyphoon_issue_command(struct typhoon *tp, int num_cmd, struct cmd_desc *cmd,\n\t\t      int num_resp, struct resp_desc *resp)\n{\n\tstruct typhoon_indexes *indexes = tp->indexes;\n\tstruct basic_ring *ring = &tp->cmdRing;\n\tstruct resp_desc local_resp;\n\tint i, err = 0;\n\tint got_resp;\n\tint freeCmd, freeResp;\n\tint len, wrap_len;\n\n\tspin_lock(&tp->command_lock);\n\n\tfreeCmd = typhoon_num_free_cmd(tp);\n\tfreeResp = typhoon_num_free_resp(tp);\n\n\tif (freeCmd < num_cmd || freeResp < num_resp) {\n\t\tnetdev_err(tp->dev, \"no descs for cmd, had (needed) %d (%d) cmd, %d (%d) resp\\n\",\n\t\t\t   freeCmd, num_cmd, freeResp, num_resp);\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (cmd->flags & TYPHOON_CMD_RESPOND) {\n\t\t \n\t\ttp->awaiting_resp = 1;\n\t\tif (resp == NULL) {\n\t\t\tresp = &local_resp;\n\t\t\tnum_resp = 1;\n\t\t}\n\t}\n\n\twrap_len = 0;\n\tlen = num_cmd * sizeof(*cmd);\n\tif (unlikely(ring->lastWrite + len > COMMAND_RING_SIZE)) {\n\t\twrap_len = ring->lastWrite + len - COMMAND_RING_SIZE;\n\t\tlen = COMMAND_RING_SIZE - ring->lastWrite;\n\t}\n\n\tmemcpy(ring->ringBase + ring->lastWrite, cmd, len);\n\tif (unlikely(wrap_len)) {\n\t\tstruct cmd_desc *wrap_ptr = cmd;\n\t\twrap_ptr += len / sizeof(*cmd);\n\t\tmemcpy(ring->ringBase, wrap_ptr, wrap_len);\n\t}\n\n\ttyphoon_inc_cmd_index(&ring->lastWrite, num_cmd);\n\n\t \n\twmb();\n\tiowrite32(ring->lastWrite, tp->ioaddr + TYPHOON_REG_CMD_READY);\n\ttyphoon_post_pci_writes(tp->ioaddr);\n\n\tif ((cmd->flags & TYPHOON_CMD_RESPOND) == 0)\n\t\tgoto out;\n\n\t \n\tgot_resp = 0;\n\tfor (i = 0; i < TYPHOON_WAIT_TIMEOUT && !got_resp; i++) {\n\t\tif (indexes->respCleared != indexes->respReady)\n\t\t\tgot_resp = typhoon_process_response(tp, num_resp,\n\t\t\t\t\t\t\t\tresp);\n\t\tudelay(TYPHOON_UDELAY);\n\t}\n\n\tif (!got_resp) {\n\t\terr = -ETIMEDOUT;\n\t\tgoto out;\n\t}\n\n\t \n\tif (resp->flags & TYPHOON_RESP_ERROR)\n\t\terr = -EIO;\n\nout:\n\tif (tp->awaiting_resp) {\n\t\ttp->awaiting_resp = 0;\n\t\tsmp_wmb();\n\n\t\t \n\t\tif (indexes->respCleared != indexes->respReady)\n\t\t\tiowrite32(1, tp->ioaddr + TYPHOON_REG_SELF_INTERRUPT);\n\t}\n\n\tspin_unlock(&tp->command_lock);\n\treturn err;\n}\n\nstatic inline void\ntyphoon_tso_fill(struct sk_buff *skb, struct transmit_ring *txRing,\n\t\t\tu32 ring_dma)\n{\n\tstruct tcpopt_desc *tcpd;\n\tu32 tcpd_offset = ring_dma;\n\n\ttcpd = (struct tcpopt_desc *) (txRing->ringBase + txRing->lastWrite);\n\ttcpd_offset += txRing->lastWrite;\n\ttcpd_offset += offsetof(struct tcpopt_desc, bytesTx);\n\ttyphoon_inc_tx_index(&txRing->lastWrite, 1);\n\n\ttcpd->flags = TYPHOON_OPT_DESC | TYPHOON_OPT_TCP_SEG;\n\ttcpd->numDesc = 1;\n\ttcpd->mss_flags = cpu_to_le16(skb_tso_size(skb));\n\ttcpd->mss_flags |= TYPHOON_TSO_FIRST | TYPHOON_TSO_LAST;\n\ttcpd->respAddrLo = cpu_to_le32(tcpd_offset);\n\ttcpd->bytesTx = cpu_to_le32(skb->len);\n\ttcpd->status = 0;\n}\n\nstatic netdev_tx_t\ntyphoon_start_tx(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct typhoon *tp = netdev_priv(dev);\n\tstruct transmit_ring *txRing;\n\tstruct tx_desc *txd, *first_txd;\n\tdma_addr_t skb_dma;\n\tint numDesc;\n\n\t \n\ttxRing = &tp->txLoRing;\n\n\t \n\tnumDesc = skb_shinfo(skb)->nr_frags + 1;\n\tif (skb_is_gso(skb))\n\t\tnumDesc++;\n\n\t \n\twhile (unlikely(typhoon_num_free_tx(txRing) < (numDesc + 2)))\n\t\tsmp_rmb();\n\n\tfirst_txd = (struct tx_desc *) (txRing->ringBase + txRing->lastWrite);\n\ttyphoon_inc_tx_index(&txRing->lastWrite, 1);\n\n\tfirst_txd->flags = TYPHOON_TX_DESC | TYPHOON_DESC_VALID;\n\tfirst_txd->numDesc = 0;\n\tfirst_txd->len = 0;\n\tfirst_txd->tx_addr = (u64)((unsigned long) skb);\n\tfirst_txd->processFlags = 0;\n\n\tif (skb->ip_summed == CHECKSUM_PARTIAL) {\n\t\t \n\t\tfirst_txd->processFlags |= TYPHOON_TX_PF_TCP_CHKSUM;\n\t\tfirst_txd->processFlags |= TYPHOON_TX_PF_UDP_CHKSUM;\n\t\tfirst_txd->processFlags |= TYPHOON_TX_PF_IP_CHKSUM;\n\t}\n\n\tif (skb_vlan_tag_present(skb)) {\n\t\tfirst_txd->processFlags |=\n\t\t    TYPHOON_TX_PF_INSERT_VLAN | TYPHOON_TX_PF_VLAN_PRIORITY;\n\t\tfirst_txd->processFlags |=\n\t\t    cpu_to_le32(htons(skb_vlan_tag_get(skb)) <<\n\t\t\t\tTYPHOON_TX_PF_VLAN_TAG_SHIFT);\n\t}\n\n\tif (skb_is_gso(skb)) {\n\t\tfirst_txd->processFlags |= TYPHOON_TX_PF_TCP_SEGMENT;\n\t\tfirst_txd->numDesc++;\n\n\t\ttyphoon_tso_fill(skb, txRing, tp->txlo_dma_addr);\n\t}\n\n\ttxd = (struct tx_desc *) (txRing->ringBase + txRing->lastWrite);\n\ttyphoon_inc_tx_index(&txRing->lastWrite, 1);\n\n\t \n\tif (skb_shinfo(skb)->nr_frags == 0) {\n\t\tskb_dma = dma_map_single(&tp->tx_pdev->dev, skb->data,\n\t\t\t\t\t skb->len, DMA_TO_DEVICE);\n\t\ttxd->flags = TYPHOON_FRAG_DESC | TYPHOON_DESC_VALID;\n\t\ttxd->len = cpu_to_le16(skb->len);\n\t\ttxd->frag.addr = cpu_to_le32(skb_dma);\n\t\ttxd->frag.addrHi = 0;\n\t\tfirst_txd->numDesc++;\n\t} else {\n\t\tint i, len;\n\n\t\tlen = skb_headlen(skb);\n\t\tskb_dma = dma_map_single(&tp->tx_pdev->dev, skb->data, len,\n\t\t\t\t\t DMA_TO_DEVICE);\n\t\ttxd->flags = TYPHOON_FRAG_DESC | TYPHOON_DESC_VALID;\n\t\ttxd->len = cpu_to_le16(len);\n\t\ttxd->frag.addr = cpu_to_le32(skb_dma);\n\t\ttxd->frag.addrHi = 0;\n\t\tfirst_txd->numDesc++;\n\n\t\tfor (i = 0; i < skb_shinfo(skb)->nr_frags; i++) {\n\t\t\tconst skb_frag_t *frag = &skb_shinfo(skb)->frags[i];\n\t\t\tvoid *frag_addr;\n\n\t\t\ttxd = (struct tx_desc *) (txRing->ringBase +\n\t\t\t\t\t\ttxRing->lastWrite);\n\t\t\ttyphoon_inc_tx_index(&txRing->lastWrite, 1);\n\n\t\t\tlen = skb_frag_size(frag);\n\t\t\tfrag_addr = skb_frag_address(frag);\n\t\t\tskb_dma = dma_map_single(&tp->tx_pdev->dev, frag_addr,\n\t\t\t\t\t\t len, DMA_TO_DEVICE);\n\t\t\ttxd->flags = TYPHOON_FRAG_DESC | TYPHOON_DESC_VALID;\n\t\t\ttxd->len = cpu_to_le16(len);\n\t\t\ttxd->frag.addr = cpu_to_le32(skb_dma);\n\t\t\ttxd->frag.addrHi = 0;\n\t\t\tfirst_txd->numDesc++;\n\t\t}\n\t}\n\n\t \n\twmb();\n\tiowrite32(txRing->lastWrite, tp->tx_ioaddr + txRing->writeRegister);\n\n\t \n\tnumDesc = MAX_SKB_FRAGS + TSO_NUM_DESCRIPTORS + 1;\n\n\tif (typhoon_num_free_tx(txRing) < (numDesc + 2)) {\n\t\tnetif_stop_queue(dev);\n\n\t\t \n\t\tif (typhoon_num_free_tx(txRing) >= (numDesc + 2))\n\t\t\tnetif_wake_queue(dev);\n\t}\n\n\treturn NETDEV_TX_OK;\n}\n\nstatic void\ntyphoon_set_rx_mode(struct net_device *dev)\n{\n\tstruct typhoon *tp = netdev_priv(dev);\n\tstruct cmd_desc xp_cmd;\n\tu32 mc_filter[2];\n\t__le16 filter;\n\n\tfilter = TYPHOON_RX_FILTER_DIRECTED | TYPHOON_RX_FILTER_BROADCAST;\n\tif (dev->flags & IFF_PROMISC) {\n\t\tfilter |= TYPHOON_RX_FILTER_PROMISCOUS;\n\t} else if ((netdev_mc_count(dev) > multicast_filter_limit) ||\n\t\t  (dev->flags & IFF_ALLMULTI)) {\n\t\t \n\t\tfilter |= TYPHOON_RX_FILTER_ALL_MCAST;\n\t} else if (!netdev_mc_empty(dev)) {\n\t\tstruct netdev_hw_addr *ha;\n\n\t\tmemset(mc_filter, 0, sizeof(mc_filter));\n\t\tnetdev_for_each_mc_addr(ha, dev) {\n\t\t\tint bit = ether_crc(ETH_ALEN, ha->addr) & 0x3f;\n\t\t\tmc_filter[bit >> 5] |= 1 << (bit & 0x1f);\n\t\t}\n\n\t\tINIT_COMMAND_NO_RESPONSE(&xp_cmd,\n\t\t\t\t\t TYPHOON_CMD_SET_MULTICAST_HASH);\n\t\txp_cmd.parm1 = TYPHOON_MCAST_HASH_SET;\n\t\txp_cmd.parm2 = cpu_to_le32(mc_filter[0]);\n\t\txp_cmd.parm3 = cpu_to_le32(mc_filter[1]);\n\t\ttyphoon_issue_command(tp, 1, &xp_cmd, 0, NULL);\n\n\t\tfilter |= TYPHOON_RX_FILTER_MCAST_HASH;\n\t}\n\n\tINIT_COMMAND_WITH_RESPONSE(&xp_cmd, TYPHOON_CMD_SET_RX_FILTER);\n\txp_cmd.parm1 = filter;\n\ttyphoon_issue_command(tp, 1, &xp_cmd, 0, NULL);\n}\n\nstatic int\ntyphoon_do_get_stats(struct typhoon *tp)\n{\n\tstruct net_device_stats *stats = &tp->dev->stats;\n\tstruct net_device_stats *saved = &tp->stats_saved;\n\tstruct cmd_desc xp_cmd;\n\tstruct resp_desc xp_resp[7];\n\tstruct stats_resp *s = (struct stats_resp *) xp_resp;\n\tint err;\n\n\tINIT_COMMAND_WITH_RESPONSE(&xp_cmd, TYPHOON_CMD_READ_STATS);\n\terr = typhoon_issue_command(tp, 1, &xp_cmd, 7, xp_resp);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tstats->tx_packets = le32_to_cpu(s->txPackets) +\n\t\t\tsaved->tx_packets;\n\tstats->tx_bytes = le64_to_cpu(s->txBytes) +\n\t\t\tsaved->tx_bytes;\n\tstats->tx_errors = le32_to_cpu(s->txCarrierLost) +\n\t\t\tsaved->tx_errors;\n\tstats->tx_carrier_errors = le32_to_cpu(s->txCarrierLost) +\n\t\t\tsaved->tx_carrier_errors;\n\tstats->collisions = le32_to_cpu(s->txMultipleCollisions) +\n\t\t\tsaved->collisions;\n\tstats->rx_packets = le32_to_cpu(s->rxPacketsGood) +\n\t\t\tsaved->rx_packets;\n\tstats->rx_bytes = le64_to_cpu(s->rxBytesGood) +\n\t\t\tsaved->rx_bytes;\n\tstats->rx_fifo_errors = le32_to_cpu(s->rxFifoOverruns) +\n\t\t\tsaved->rx_fifo_errors;\n\tstats->rx_errors = le32_to_cpu(s->rxFifoOverruns) +\n\t\t\tle32_to_cpu(s->BadSSD) + le32_to_cpu(s->rxCrcErrors) +\n\t\t\tsaved->rx_errors;\n\tstats->rx_crc_errors = le32_to_cpu(s->rxCrcErrors) +\n\t\t\tsaved->rx_crc_errors;\n\tstats->rx_length_errors = le32_to_cpu(s->rxOversized) +\n\t\t\tsaved->rx_length_errors;\n\ttp->speed = (s->linkStatus & TYPHOON_LINK_100MBPS) ?\n\t\t\tSPEED_100 : SPEED_10;\n\ttp->duplex = (s->linkStatus & TYPHOON_LINK_FULL_DUPLEX) ?\n\t\t\tDUPLEX_FULL : DUPLEX_HALF;\n\n\treturn 0;\n}\n\nstatic struct net_device_stats *\ntyphoon_get_stats(struct net_device *dev)\n{\n\tstruct typhoon *tp = netdev_priv(dev);\n\tstruct net_device_stats *stats = &tp->dev->stats;\n\tstruct net_device_stats *saved = &tp->stats_saved;\n\n\tsmp_rmb();\n\tif (tp->card_state == Sleeping)\n\t\treturn saved;\n\n\tif (typhoon_do_get_stats(tp) < 0) {\n\t\tnetdev_err(dev, \"error getting stats\\n\");\n\t\treturn saved;\n\t}\n\n\treturn stats;\n}\n\nstatic void\ntyphoon_get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *info)\n{\n\tstruct typhoon *tp = netdev_priv(dev);\n\tstruct pci_dev *pci_dev = tp->pdev;\n\tstruct cmd_desc xp_cmd;\n\tstruct resp_desc xp_resp[3];\n\n\tsmp_rmb();\n\tif (tp->card_state == Sleeping) {\n\t\tstrscpy(info->fw_version, \"Sleep image\",\n\t\t\tsizeof(info->fw_version));\n\t} else {\n\t\tINIT_COMMAND_WITH_RESPONSE(&xp_cmd, TYPHOON_CMD_READ_VERSIONS);\n\t\tif (typhoon_issue_command(tp, 1, &xp_cmd, 3, xp_resp) < 0) {\n\t\t\tstrscpy(info->fw_version, \"Unknown runtime\",\n\t\t\t\tsizeof(info->fw_version));\n\t\t} else {\n\t\t\tu32 sleep_ver = le32_to_cpu(xp_resp[0].parm2);\n\t\t\tsnprintf(info->fw_version, sizeof(info->fw_version),\n\t\t\t\t\"%02x.%03x.%03x\", sleep_ver >> 24,\n\t\t\t\t(sleep_ver >> 12) & 0xfff, sleep_ver & 0xfff);\n\t\t}\n\t}\n\n\tstrscpy(info->driver, KBUILD_MODNAME, sizeof(info->driver));\n\tstrscpy(info->bus_info, pci_name(pci_dev), sizeof(info->bus_info));\n}\n\nstatic int\ntyphoon_get_link_ksettings(struct net_device *dev,\n\t\t\t   struct ethtool_link_ksettings *cmd)\n{\n\tstruct typhoon *tp = netdev_priv(dev);\n\tu32 supported, advertising = 0;\n\n\tsupported = SUPPORTED_100baseT_Half | SUPPORTED_100baseT_Full |\n\t\t\t\tSUPPORTED_Autoneg;\n\n\tswitch (tp->xcvr_select) {\n\tcase TYPHOON_XCVR_10HALF:\n\t\tadvertising = ADVERTISED_10baseT_Half;\n\t\tbreak;\n\tcase TYPHOON_XCVR_10FULL:\n\t\tadvertising = ADVERTISED_10baseT_Full;\n\t\tbreak;\n\tcase TYPHOON_XCVR_100HALF:\n\t\tadvertising = ADVERTISED_100baseT_Half;\n\t\tbreak;\n\tcase TYPHOON_XCVR_100FULL:\n\t\tadvertising = ADVERTISED_100baseT_Full;\n\t\tbreak;\n\tcase TYPHOON_XCVR_AUTONEG:\n\t\tadvertising = ADVERTISED_10baseT_Half |\n\t\t\t\t\t    ADVERTISED_10baseT_Full |\n\t\t\t\t\t    ADVERTISED_100baseT_Half |\n\t\t\t\t\t    ADVERTISED_100baseT_Full |\n\t\t\t\t\t    ADVERTISED_Autoneg;\n\t\tbreak;\n\t}\n\n\tif (tp->capabilities & TYPHOON_FIBER) {\n\t\tsupported |= SUPPORTED_FIBRE;\n\t\tadvertising |= ADVERTISED_FIBRE;\n\t\tcmd->base.port = PORT_FIBRE;\n\t} else {\n\t\tsupported |= SUPPORTED_10baseT_Half |\n\t\t    \t\t\tSUPPORTED_10baseT_Full |\n\t\t\t\t\tSUPPORTED_TP;\n\t\tadvertising |= ADVERTISED_TP;\n\t\tcmd->base.port = PORT_TP;\n\t}\n\n\t \n\ttyphoon_do_get_stats(tp);\n\tcmd->base.speed = tp->speed;\n\tcmd->base.duplex = tp->duplex;\n\tcmd->base.phy_address = 0;\n\tif (tp->xcvr_select == TYPHOON_XCVR_AUTONEG)\n\t\tcmd->base.autoneg = AUTONEG_ENABLE;\n\telse\n\t\tcmd->base.autoneg = AUTONEG_DISABLE;\n\n\tethtool_convert_legacy_u32_to_link_mode(cmd->link_modes.supported,\n\t\t\t\t\t\tsupported);\n\tethtool_convert_legacy_u32_to_link_mode(cmd->link_modes.advertising,\n\t\t\t\t\t\tadvertising);\n\n\treturn 0;\n}\n\nstatic int\ntyphoon_set_link_ksettings(struct net_device *dev,\n\t\t\t   const struct ethtool_link_ksettings *cmd)\n{\n\tstruct typhoon *tp = netdev_priv(dev);\n\tu32 speed = cmd->base.speed;\n\tstruct cmd_desc xp_cmd;\n\t__le16 xcvr;\n\tint err;\n\n\terr = -EINVAL;\n\tif (cmd->base.autoneg == AUTONEG_ENABLE) {\n\t\txcvr = TYPHOON_XCVR_AUTONEG;\n\t} else {\n\t\tif (cmd->base.duplex == DUPLEX_HALF) {\n\t\t\tif (speed == SPEED_10)\n\t\t\t\txcvr = TYPHOON_XCVR_10HALF;\n\t\t\telse if (speed == SPEED_100)\n\t\t\t\txcvr = TYPHOON_XCVR_100HALF;\n\t\t\telse\n\t\t\t\tgoto out;\n\t\t} else if (cmd->base.duplex == DUPLEX_FULL) {\n\t\t\tif (speed == SPEED_10)\n\t\t\t\txcvr = TYPHOON_XCVR_10FULL;\n\t\t\telse if (speed == SPEED_100)\n\t\t\t\txcvr = TYPHOON_XCVR_100FULL;\n\t\t\telse\n\t\t\t\tgoto out;\n\t\t} else\n\t\t\tgoto out;\n\t}\n\n\tINIT_COMMAND_NO_RESPONSE(&xp_cmd, TYPHOON_CMD_XCVR_SELECT);\n\txp_cmd.parm1 = xcvr;\n\terr = typhoon_issue_command(tp, 1, &xp_cmd, 0, NULL);\n\tif (err < 0)\n\t\tgoto out;\n\n\ttp->xcvr_select = xcvr;\n\tif (cmd->base.autoneg == AUTONEG_ENABLE) {\n\t\ttp->speed = 0xff;\t \n\t\ttp->duplex = 0xff;\t \n\t} else {\n\t\ttp->speed = speed;\n\t\ttp->duplex = cmd->base.duplex;\n\t}\n\nout:\n\treturn err;\n}\n\nstatic void\ntyphoon_get_wol(struct net_device *dev, struct ethtool_wolinfo *wol)\n{\n\tstruct typhoon *tp = netdev_priv(dev);\n\n\twol->supported = WAKE_PHY | WAKE_MAGIC;\n\twol->wolopts = 0;\n\tif (tp->wol_events & TYPHOON_WAKE_LINK_EVENT)\n\t\twol->wolopts |= WAKE_PHY;\n\tif (tp->wol_events & TYPHOON_WAKE_MAGIC_PKT)\n\t\twol->wolopts |= WAKE_MAGIC;\n\tmemset(&wol->sopass, 0, sizeof(wol->sopass));\n}\n\nstatic int\ntyphoon_set_wol(struct net_device *dev, struct ethtool_wolinfo *wol)\n{\n\tstruct typhoon *tp = netdev_priv(dev);\n\n\tif (wol->wolopts & ~(WAKE_PHY | WAKE_MAGIC))\n\t\treturn -EINVAL;\n\n\ttp->wol_events = 0;\n\tif (wol->wolopts & WAKE_PHY)\n\t\ttp->wol_events |= TYPHOON_WAKE_LINK_EVENT;\n\tif (wol->wolopts & WAKE_MAGIC)\n\t\ttp->wol_events |= TYPHOON_WAKE_MAGIC_PKT;\n\n\treturn 0;\n}\n\nstatic void\ntyphoon_get_ringparam(struct net_device *dev, struct ethtool_ringparam *ering,\n\t\t      struct kernel_ethtool_ringparam *kernel_ering,\n\t\t      struct netlink_ext_ack *extack)\n{\n\tering->rx_max_pending = RXENT_ENTRIES;\n\tering->tx_max_pending = TXLO_ENTRIES - 1;\n\n\tering->rx_pending = RXENT_ENTRIES;\n\tering->tx_pending = TXLO_ENTRIES - 1;\n}\n\nstatic const struct ethtool_ops typhoon_ethtool_ops = {\n\t.get_drvinfo\t\t= typhoon_get_drvinfo,\n\t.get_wol\t\t= typhoon_get_wol,\n\t.set_wol\t\t= typhoon_set_wol,\n\t.get_link\t\t= ethtool_op_get_link,\n\t.get_ringparam\t\t= typhoon_get_ringparam,\n\t.get_link_ksettings\t= typhoon_get_link_ksettings,\n\t.set_link_ksettings\t= typhoon_set_link_ksettings,\n};\n\nstatic int\ntyphoon_wait_interrupt(void __iomem *ioaddr)\n{\n\tint i, err = 0;\n\n\tfor (i = 0; i < TYPHOON_WAIT_TIMEOUT; i++) {\n\t\tif (ioread32(ioaddr + TYPHOON_REG_INTR_STATUS) &\n\t\t   TYPHOON_INTR_BOOTCMD)\n\t\t\tgoto out;\n\t\tudelay(TYPHOON_UDELAY);\n\t}\n\n\terr = -ETIMEDOUT;\n\nout:\n\tiowrite32(TYPHOON_INTR_BOOTCMD, ioaddr + TYPHOON_REG_INTR_STATUS);\n\treturn err;\n}\n\n#define shared_offset(x)\toffsetof(struct typhoon_shared, x)\n\nstatic void\ntyphoon_init_interface(struct typhoon *tp)\n{\n\tstruct typhoon_interface *iface = &tp->shared->iface;\n\tdma_addr_t shared_dma;\n\n\tmemset(tp->shared, 0, sizeof(struct typhoon_shared));\n\n\t \n\tshared_dma = tp->shared_dma + shared_offset(indexes);\n\tiface->ringIndex = cpu_to_le32(shared_dma);\n\n\tshared_dma = tp->shared_dma + shared_offset(txLo);\n\tiface->txLoAddr = cpu_to_le32(shared_dma);\n\tiface->txLoSize = cpu_to_le32(TXLO_ENTRIES * sizeof(struct tx_desc));\n\n\tshared_dma = tp->shared_dma + shared_offset(txHi);\n\tiface->txHiAddr = cpu_to_le32(shared_dma);\n\tiface->txHiSize = cpu_to_le32(TXHI_ENTRIES * sizeof(struct tx_desc));\n\n\tshared_dma = tp->shared_dma + shared_offset(rxBuff);\n\tiface->rxBuffAddr = cpu_to_le32(shared_dma);\n\tiface->rxBuffSize = cpu_to_le32(RXFREE_ENTRIES *\n\t\t\t\t\tsizeof(struct rx_free));\n\n\tshared_dma = tp->shared_dma + shared_offset(rxLo);\n\tiface->rxLoAddr = cpu_to_le32(shared_dma);\n\tiface->rxLoSize = cpu_to_le32(RX_ENTRIES * sizeof(struct rx_desc));\n\n\tshared_dma = tp->shared_dma + shared_offset(rxHi);\n\tiface->rxHiAddr = cpu_to_le32(shared_dma);\n\tiface->rxHiSize = cpu_to_le32(RX_ENTRIES * sizeof(struct rx_desc));\n\n\tshared_dma = tp->shared_dma + shared_offset(cmd);\n\tiface->cmdAddr = cpu_to_le32(shared_dma);\n\tiface->cmdSize = cpu_to_le32(COMMAND_RING_SIZE);\n\n\tshared_dma = tp->shared_dma + shared_offset(resp);\n\tiface->respAddr = cpu_to_le32(shared_dma);\n\tiface->respSize = cpu_to_le32(RESPONSE_RING_SIZE);\n\n\tshared_dma = tp->shared_dma + shared_offset(zeroWord);\n\tiface->zeroAddr = cpu_to_le32(shared_dma);\n\n\ttp->indexes = &tp->shared->indexes;\n\ttp->txLoRing.ringBase = (u8 *) tp->shared->txLo;\n\ttp->txHiRing.ringBase = (u8 *) tp->shared->txHi;\n\ttp->rxLoRing.ringBase = (u8 *) tp->shared->rxLo;\n\ttp->rxHiRing.ringBase = (u8 *) tp->shared->rxHi;\n\ttp->rxBuffRing.ringBase = (u8 *) tp->shared->rxBuff;\n\ttp->cmdRing.ringBase = (u8 *) tp->shared->cmd;\n\ttp->respRing.ringBase = (u8 *) tp->shared->resp;\n\n\ttp->txLoRing.writeRegister = TYPHOON_REG_TX_LO_READY;\n\ttp->txHiRing.writeRegister = TYPHOON_REG_TX_HI_READY;\n\n\ttp->txlo_dma_addr = le32_to_cpu(iface->txLoAddr);\n\ttp->card_state = Sleeping;\n\n\ttp->offload = TYPHOON_OFFLOAD_IP_CHKSUM | TYPHOON_OFFLOAD_TCP_CHKSUM;\n\ttp->offload |= TYPHOON_OFFLOAD_UDP_CHKSUM | TSO_OFFLOAD_ON;\n\ttp->offload |= TYPHOON_OFFLOAD_VLAN;\n\n\tspin_lock_init(&tp->command_lock);\n\n\t \n\twmb();\n}\n\nstatic void\ntyphoon_init_rings(struct typhoon *tp)\n{\n\tmemset(tp->indexes, 0, sizeof(struct typhoon_indexes));\n\n\ttp->txLoRing.lastWrite = 0;\n\ttp->txHiRing.lastWrite = 0;\n\ttp->rxLoRing.lastWrite = 0;\n\ttp->rxHiRing.lastWrite = 0;\n\ttp->rxBuffRing.lastWrite = 0;\n\ttp->cmdRing.lastWrite = 0;\n\ttp->respRing.lastWrite = 0;\n\n\ttp->txLoRing.lastRead = 0;\n\ttp->txHiRing.lastRead = 0;\n}\n\nstatic const struct firmware *typhoon_fw;\n\nstatic int\ntyphoon_request_firmware(struct typhoon *tp)\n{\n\tconst struct typhoon_file_header *fHdr;\n\tconst struct typhoon_section_header *sHdr;\n\tconst u8 *image_data;\n\tu32 numSections;\n\tu32 section_len;\n\tu32 remaining;\n\tint err;\n\n\tif (typhoon_fw)\n\t\treturn 0;\n\n\terr = request_firmware(&typhoon_fw, FIRMWARE_NAME, &tp->pdev->dev);\n\tif (err) {\n\t\tnetdev_err(tp->dev, \"Failed to load firmware \\\"%s\\\"\\n\",\n\t\t\t   FIRMWARE_NAME);\n\t\treturn err;\n\t}\n\n\timage_data = typhoon_fw->data;\n\tremaining = typhoon_fw->size;\n\tif (remaining < sizeof(struct typhoon_file_header))\n\t\tgoto invalid_fw;\n\n\tfHdr = (struct typhoon_file_header *) image_data;\n\tif (memcmp(fHdr->tag, \"TYPHOON\", 8))\n\t\tgoto invalid_fw;\n\n\tnumSections = le32_to_cpu(fHdr->numSections);\n\timage_data += sizeof(struct typhoon_file_header);\n\tremaining -= sizeof(struct typhoon_file_header);\n\n\twhile (numSections--) {\n\t\tif (remaining < sizeof(struct typhoon_section_header))\n\t\t\tgoto invalid_fw;\n\n\t\tsHdr = (struct typhoon_section_header *) image_data;\n\t\timage_data += sizeof(struct typhoon_section_header);\n\t\tsection_len = le32_to_cpu(sHdr->len);\n\n\t\tif (remaining < section_len)\n\t\t\tgoto invalid_fw;\n\n\t\timage_data += section_len;\n\t\tremaining -= section_len;\n\t}\n\n\treturn 0;\n\ninvalid_fw:\n\tnetdev_err(tp->dev, \"Invalid firmware image\\n\");\n\trelease_firmware(typhoon_fw);\n\ttyphoon_fw = NULL;\n\treturn -EINVAL;\n}\n\nstatic int\ntyphoon_download_firmware(struct typhoon *tp)\n{\n\tvoid __iomem *ioaddr = tp->ioaddr;\n\tstruct pci_dev *pdev = tp->pdev;\n\tconst struct typhoon_file_header *fHdr;\n\tconst struct typhoon_section_header *sHdr;\n\tconst u8 *image_data;\n\tvoid *dpage;\n\tdma_addr_t dpage_dma;\n\t__sum16 csum;\n\tu32 irqEnabled;\n\tu32 irqMasked;\n\tu32 numSections;\n\tu32 section_len;\n\tu32 len;\n\tu32 load_addr;\n\tu32 hmac;\n\tint i;\n\tint err;\n\n\timage_data = typhoon_fw->data;\n\tfHdr = (struct typhoon_file_header *) image_data;\n\n\t \n\terr = -ENOMEM;\n\tdpage = dma_alloc_coherent(&pdev->dev, PAGE_SIZE, &dpage_dma, GFP_ATOMIC);\n\tif (!dpage) {\n\t\tnetdev_err(tp->dev, \"no DMA mem for firmware\\n\");\n\t\tgoto err_out;\n\t}\n\n\tirqEnabled = ioread32(ioaddr + TYPHOON_REG_INTR_ENABLE);\n\tiowrite32(irqEnabled | TYPHOON_INTR_BOOTCMD,\n\t       ioaddr + TYPHOON_REG_INTR_ENABLE);\n\tirqMasked = ioread32(ioaddr + TYPHOON_REG_INTR_MASK);\n\tiowrite32(irqMasked | TYPHOON_INTR_BOOTCMD,\n\t       ioaddr + TYPHOON_REG_INTR_MASK);\n\n\terr = -ETIMEDOUT;\n\tif (typhoon_wait_status(ioaddr, TYPHOON_STATUS_WAITING_FOR_HOST) < 0) {\n\t\tnetdev_err(tp->dev, \"card ready timeout\\n\");\n\t\tgoto err_out_irq;\n\t}\n\n\tnumSections = le32_to_cpu(fHdr->numSections);\n\tload_addr = le32_to_cpu(fHdr->startAddr);\n\n\tiowrite32(TYPHOON_INTR_BOOTCMD, ioaddr + TYPHOON_REG_INTR_STATUS);\n\tiowrite32(load_addr, ioaddr + TYPHOON_REG_DOWNLOAD_BOOT_ADDR);\n\thmac = le32_to_cpu(fHdr->hmacDigest[0]);\n\tiowrite32(hmac, ioaddr + TYPHOON_REG_DOWNLOAD_HMAC_0);\n\thmac = le32_to_cpu(fHdr->hmacDigest[1]);\n\tiowrite32(hmac, ioaddr + TYPHOON_REG_DOWNLOAD_HMAC_1);\n\thmac = le32_to_cpu(fHdr->hmacDigest[2]);\n\tiowrite32(hmac, ioaddr + TYPHOON_REG_DOWNLOAD_HMAC_2);\n\thmac = le32_to_cpu(fHdr->hmacDigest[3]);\n\tiowrite32(hmac, ioaddr + TYPHOON_REG_DOWNLOAD_HMAC_3);\n\thmac = le32_to_cpu(fHdr->hmacDigest[4]);\n\tiowrite32(hmac, ioaddr + TYPHOON_REG_DOWNLOAD_HMAC_4);\n\ttyphoon_post_pci_writes(ioaddr);\n\tiowrite32(TYPHOON_BOOTCMD_RUNTIME_IMAGE, ioaddr + TYPHOON_REG_COMMAND);\n\n\timage_data += sizeof(struct typhoon_file_header);\n\n\t \n\tfor (i = 0; i < numSections; i++) {\n\t\tsHdr = (struct typhoon_section_header *) image_data;\n\t\timage_data += sizeof(struct typhoon_section_header);\n\t\tload_addr = le32_to_cpu(sHdr->startAddr);\n\t\tsection_len = le32_to_cpu(sHdr->len);\n\n\t\twhile (section_len) {\n\t\t\tlen = min_t(u32, section_len, PAGE_SIZE);\n\n\t\t\tif (typhoon_wait_interrupt(ioaddr) < 0 ||\n\t\t\t   ioread32(ioaddr + TYPHOON_REG_STATUS) !=\n\t\t\t   TYPHOON_STATUS_WAITING_FOR_SEGMENT) {\n\t\t\t\tnetdev_err(tp->dev, \"segment ready timeout\\n\");\n\t\t\t\tgoto err_out_irq;\n\t\t\t}\n\n\t\t\t \n\t\t\tcsum = csum_fold(csum_partial_copy_nocheck(image_data,\n\t\t\t\t\t\t\t\t   dpage, len));\n\n\t\t\tiowrite32(len, ioaddr + TYPHOON_REG_BOOT_LENGTH);\n\t\t\tiowrite32(le16_to_cpu((__force __le16)csum),\n\t\t\t\t\tioaddr + TYPHOON_REG_BOOT_CHECKSUM);\n\t\t\tiowrite32(load_addr,\n\t\t\t\t\tioaddr + TYPHOON_REG_BOOT_DEST_ADDR);\n\t\t\tiowrite32(0, ioaddr + TYPHOON_REG_BOOT_DATA_HI);\n\t\t\tiowrite32(dpage_dma, ioaddr + TYPHOON_REG_BOOT_DATA_LO);\n\t\t\ttyphoon_post_pci_writes(ioaddr);\n\t\t\tiowrite32(TYPHOON_BOOTCMD_SEG_AVAILABLE,\n\t\t\t\t\tioaddr + TYPHOON_REG_COMMAND);\n\n\t\t\timage_data += len;\n\t\t\tload_addr += len;\n\t\t\tsection_len -= len;\n\t\t}\n\t}\n\n\tif (typhoon_wait_interrupt(ioaddr) < 0 ||\n\t   ioread32(ioaddr + TYPHOON_REG_STATUS) !=\n\t   TYPHOON_STATUS_WAITING_FOR_SEGMENT) {\n\t\tnetdev_err(tp->dev, \"final segment ready timeout\\n\");\n\t\tgoto err_out_irq;\n\t}\n\n\tiowrite32(TYPHOON_BOOTCMD_DNLD_COMPLETE, ioaddr + TYPHOON_REG_COMMAND);\n\n\tif (typhoon_wait_status(ioaddr, TYPHOON_STATUS_WAITING_FOR_BOOT) < 0) {\n\t\tnetdev_err(tp->dev, \"boot ready timeout, status 0x%0x\\n\",\n\t\t\t   ioread32(ioaddr + TYPHOON_REG_STATUS));\n\t\tgoto err_out_irq;\n\t}\n\n\terr = 0;\n\nerr_out_irq:\n\tiowrite32(irqMasked, ioaddr + TYPHOON_REG_INTR_MASK);\n\tiowrite32(irqEnabled, ioaddr + TYPHOON_REG_INTR_ENABLE);\n\n\tdma_free_coherent(&pdev->dev, PAGE_SIZE, dpage, dpage_dma);\n\nerr_out:\n\treturn err;\n}\n\nstatic int\ntyphoon_boot_3XP(struct typhoon *tp, u32 initial_status)\n{\n\tvoid __iomem *ioaddr = tp->ioaddr;\n\n\tif (typhoon_wait_status(ioaddr, initial_status) < 0) {\n\t\tnetdev_err(tp->dev, \"boot ready timeout\\n\");\n\t\tgoto out_timeout;\n\t}\n\n\tiowrite32(0, ioaddr + TYPHOON_REG_BOOT_RECORD_ADDR_HI);\n\tiowrite32(tp->shared_dma, ioaddr + TYPHOON_REG_BOOT_RECORD_ADDR_LO);\n\ttyphoon_post_pci_writes(ioaddr);\n\tiowrite32(TYPHOON_BOOTCMD_REG_BOOT_RECORD,\n\t\t\t\tioaddr + TYPHOON_REG_COMMAND);\n\n\tif (typhoon_wait_status(ioaddr, TYPHOON_STATUS_RUNNING) < 0) {\n\t\tnetdev_err(tp->dev, \"boot finish timeout (status 0x%x)\\n\",\n\t\t\t   ioread32(ioaddr + TYPHOON_REG_STATUS));\n\t\tgoto out_timeout;\n\t}\n\n\t \n\tiowrite32(0, ioaddr + TYPHOON_REG_TX_HI_READY);\n\tiowrite32(0, ioaddr + TYPHOON_REG_CMD_READY);\n\tiowrite32(0, ioaddr + TYPHOON_REG_TX_LO_READY);\n\ttyphoon_post_pci_writes(ioaddr);\n\tiowrite32(TYPHOON_BOOTCMD_BOOT, ioaddr + TYPHOON_REG_COMMAND);\n\n\treturn 0;\n\nout_timeout:\n\treturn -ETIMEDOUT;\n}\n\nstatic u32\ntyphoon_clean_tx(struct typhoon *tp, struct transmit_ring *txRing,\n\t\t\tvolatile __le32 * index)\n{\n\tu32 lastRead = txRing->lastRead;\n\tstruct tx_desc *tx;\n\tdma_addr_t skb_dma;\n\tint dma_len;\n\tint type;\n\n\twhile (lastRead != le32_to_cpu(*index)) {\n\t\ttx = (struct tx_desc *) (txRing->ringBase + lastRead);\n\t\ttype = tx->flags & TYPHOON_TYPE_MASK;\n\n\t\tif (type == TYPHOON_TX_DESC) {\n\t\t\t \n\t\t\tunsigned long ptr = tx->tx_addr;\n\t\t\tstruct sk_buff *skb = (struct sk_buff *) ptr;\n\t\t\tdev_kfree_skb_irq(skb);\n\t\t} else if (type == TYPHOON_FRAG_DESC) {\n\t\t\t \n\t\t\tskb_dma = (dma_addr_t) le32_to_cpu(tx->frag.addr);\n\t\t\tdma_len = le16_to_cpu(tx->len);\n\t\t\tdma_unmap_single(&tp->pdev->dev, skb_dma, dma_len,\n\t\t\t\t\t DMA_TO_DEVICE);\n\t\t}\n\n\t\ttx->flags = 0;\n\t\ttyphoon_inc_tx_index(&lastRead, 1);\n\t}\n\n\treturn lastRead;\n}\n\nstatic void\ntyphoon_tx_complete(struct typhoon *tp, struct transmit_ring *txRing,\n\t\t\tvolatile __le32 * index)\n{\n\tu32 lastRead;\n\tint numDesc = MAX_SKB_FRAGS + 1;\n\n\t \n\tlastRead = typhoon_clean_tx(tp, txRing, index);\n\tif (netif_queue_stopped(tp->dev) && typhoon_num_free(txRing->lastWrite,\n\t\t\t\tlastRead, TXLO_ENTRIES) > (numDesc + 2))\n\t\tnetif_wake_queue(tp->dev);\n\n\ttxRing->lastRead = lastRead;\n\tsmp_wmb();\n}\n\nstatic void\ntyphoon_recycle_rx_skb(struct typhoon *tp, u32 idx)\n{\n\tstruct typhoon_indexes *indexes = tp->indexes;\n\tstruct rxbuff_ent *rxb = &tp->rxbuffers[idx];\n\tstruct basic_ring *ring = &tp->rxBuffRing;\n\tstruct rx_free *r;\n\n\tif ((ring->lastWrite + sizeof(*r)) % (RXFREE_ENTRIES * sizeof(*r)) ==\n\t\t\t\tle32_to_cpu(indexes->rxBuffCleared)) {\n\t\t \n\t\tdev_kfree_skb_any(rxb->skb);\n\t\trxb->skb = NULL;\n\t\treturn;\n\t}\n\n\tr = (struct rx_free *) (ring->ringBase + ring->lastWrite);\n\ttyphoon_inc_rxfree_index(&ring->lastWrite, 1);\n\tr->virtAddr = idx;\n\tr->physAddr = cpu_to_le32(rxb->dma_addr);\n\n\t \n\twmb();\n\tindexes->rxBuffReady = cpu_to_le32(ring->lastWrite);\n}\n\nstatic int\ntyphoon_alloc_rx_skb(struct typhoon *tp, u32 idx)\n{\n\tstruct typhoon_indexes *indexes = tp->indexes;\n\tstruct rxbuff_ent *rxb = &tp->rxbuffers[idx];\n\tstruct basic_ring *ring = &tp->rxBuffRing;\n\tstruct rx_free *r;\n\tstruct sk_buff *skb;\n\tdma_addr_t dma_addr;\n\n\trxb->skb = NULL;\n\n\tif ((ring->lastWrite + sizeof(*r)) % (RXFREE_ENTRIES * sizeof(*r)) ==\n\t\t\t\tle32_to_cpu(indexes->rxBuffCleared))\n\t\treturn -ENOMEM;\n\n\tskb = netdev_alloc_skb(tp->dev, PKT_BUF_SZ);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n#if 0\n\t \n\tskb_reserve(skb, 2);\n#endif\n\n\tdma_addr = dma_map_single(&tp->pdev->dev, skb->data, PKT_BUF_SZ,\n\t\t\t\t  DMA_FROM_DEVICE);\n\n\t \n\tr = (struct rx_free *) (ring->ringBase + ring->lastWrite);\n\ttyphoon_inc_rxfree_index(&ring->lastWrite, 1);\n\tr->virtAddr = idx;\n\tr->physAddr = cpu_to_le32(dma_addr);\n\trxb->skb = skb;\n\trxb->dma_addr = dma_addr;\n\n\t \n\twmb();\n\tindexes->rxBuffReady = cpu_to_le32(ring->lastWrite);\n\treturn 0;\n}\n\nstatic int\ntyphoon_rx(struct typhoon *tp, struct basic_ring *rxRing, volatile __le32 * ready,\n\t   volatile __le32 * cleared, int budget)\n{\n\tstruct rx_desc *rx;\n\tstruct sk_buff *skb, *new_skb;\n\tstruct rxbuff_ent *rxb;\n\tdma_addr_t dma_addr;\n\tu32 local_ready;\n\tu32 rxaddr;\n\tint pkt_len;\n\tu32 idx;\n\t__le32 csum_bits;\n\tint received;\n\n\treceived = 0;\n\tlocal_ready = le32_to_cpu(*ready);\n\trxaddr = le32_to_cpu(*cleared);\n\twhile (rxaddr != local_ready && budget > 0) {\n\t\trx = (struct rx_desc *) (rxRing->ringBase + rxaddr);\n\t\tidx = rx->addr;\n\t\trxb = &tp->rxbuffers[idx];\n\t\tskb = rxb->skb;\n\t\tdma_addr = rxb->dma_addr;\n\n\t\ttyphoon_inc_rx_index(&rxaddr, 1);\n\n\t\tif (rx->flags & TYPHOON_RX_ERROR) {\n\t\t\ttyphoon_recycle_rx_skb(tp, idx);\n\t\t\tcontinue;\n\t\t}\n\n\t\tpkt_len = le16_to_cpu(rx->frameLen);\n\n\t\tif (pkt_len < rx_copybreak &&\n\t\t   (new_skb = netdev_alloc_skb(tp->dev, pkt_len + 2)) != NULL) {\n\t\t\tskb_reserve(new_skb, 2);\n\t\t\tdma_sync_single_for_cpu(&tp->pdev->dev, dma_addr,\n\t\t\t\t\t\tPKT_BUF_SZ, DMA_FROM_DEVICE);\n\t\t\tskb_copy_to_linear_data(new_skb, skb->data, pkt_len);\n\t\t\tdma_sync_single_for_device(&tp->pdev->dev, dma_addr,\n\t\t\t\t\t\t   PKT_BUF_SZ,\n\t\t\t\t\t\t   DMA_FROM_DEVICE);\n\t\t\tskb_put(new_skb, pkt_len);\n\t\t\ttyphoon_recycle_rx_skb(tp, idx);\n\t\t} else {\n\t\t\tnew_skb = skb;\n\t\t\tskb_put(new_skb, pkt_len);\n\t\t\tdma_unmap_single(&tp->pdev->dev, dma_addr, PKT_BUF_SZ,\n\t\t\t\t\t DMA_FROM_DEVICE);\n\t\t\ttyphoon_alloc_rx_skb(tp, idx);\n\t\t}\n\t\tnew_skb->protocol = eth_type_trans(new_skb, tp->dev);\n\t\tcsum_bits = rx->rxStatus & (TYPHOON_RX_IP_CHK_GOOD |\n\t\t\tTYPHOON_RX_UDP_CHK_GOOD | TYPHOON_RX_TCP_CHK_GOOD);\n\t\tif (csum_bits ==\n\t\t   (TYPHOON_RX_IP_CHK_GOOD | TYPHOON_RX_TCP_CHK_GOOD) ||\n\t\t   csum_bits ==\n\t\t   (TYPHOON_RX_IP_CHK_GOOD | TYPHOON_RX_UDP_CHK_GOOD)) {\n\t\t\tnew_skb->ip_summed = CHECKSUM_UNNECESSARY;\n\t\t} else\n\t\t\tskb_checksum_none_assert(new_skb);\n\n\t\tif (rx->rxStatus & TYPHOON_RX_VLAN)\n\t\t\t__vlan_hwaccel_put_tag(new_skb, htons(ETH_P_8021Q),\n\t\t\t\t\t       ntohl(rx->vlanTag) & 0xffff);\n\t\tnetif_receive_skb(new_skb);\n\n\t\treceived++;\n\t\tbudget--;\n\t}\n\t*cleared = cpu_to_le32(rxaddr);\n\n\treturn received;\n}\n\nstatic void\ntyphoon_fill_free_ring(struct typhoon *tp)\n{\n\tu32 i;\n\n\tfor (i = 0; i < RXENT_ENTRIES; i++) {\n\t\tstruct rxbuff_ent *rxb = &tp->rxbuffers[i];\n\t\tif (rxb->skb)\n\t\t\tcontinue;\n\t\tif (typhoon_alloc_rx_skb(tp, i) < 0)\n\t\t\tbreak;\n\t}\n}\n\nstatic int\ntyphoon_poll(struct napi_struct *napi, int budget)\n{\n\tstruct typhoon *tp = container_of(napi, struct typhoon, napi);\n\tstruct typhoon_indexes *indexes = tp->indexes;\n\tint work_done;\n\n\trmb();\n\tif (!tp->awaiting_resp && indexes->respReady != indexes->respCleared)\n\t\t\ttyphoon_process_response(tp, 0, NULL);\n\n\tif (le32_to_cpu(indexes->txLoCleared) != tp->txLoRing.lastRead)\n\t\ttyphoon_tx_complete(tp, &tp->txLoRing, &indexes->txLoCleared);\n\n\twork_done = 0;\n\n\tif (indexes->rxHiCleared != indexes->rxHiReady) {\n\t\twork_done += typhoon_rx(tp, &tp->rxHiRing, &indexes->rxHiReady,\n\t\t\t   \t\t&indexes->rxHiCleared, budget);\n\t}\n\n\tif (indexes->rxLoCleared != indexes->rxLoReady) {\n\t\twork_done += typhoon_rx(tp, &tp->rxLoRing, &indexes->rxLoReady,\n\t\t\t\t\t&indexes->rxLoCleared, budget - work_done);\n\t}\n\n\tif (le32_to_cpu(indexes->rxBuffCleared) == tp->rxBuffRing.lastWrite) {\n\t\t \n\t\ttyphoon_fill_free_ring(tp);\n\t}\n\n\tif (work_done < budget) {\n\t\tnapi_complete_done(napi, work_done);\n\t\tiowrite32(TYPHOON_INTR_NONE,\n\t\t\t\ttp->ioaddr + TYPHOON_REG_INTR_MASK);\n\t\ttyphoon_post_pci_writes(tp->ioaddr);\n\t}\n\n\treturn work_done;\n}\n\nstatic irqreturn_t\ntyphoon_interrupt(int irq, void *dev_instance)\n{\n\tstruct net_device *dev = dev_instance;\n\tstruct typhoon *tp = netdev_priv(dev);\n\tvoid __iomem *ioaddr = tp->ioaddr;\n\tu32 intr_status;\n\n\tintr_status = ioread32(ioaddr + TYPHOON_REG_INTR_STATUS);\n\tif (!(intr_status & TYPHOON_INTR_HOST_INT))\n\t\treturn IRQ_NONE;\n\n\tiowrite32(intr_status, ioaddr + TYPHOON_REG_INTR_STATUS);\n\n\tif (napi_schedule_prep(&tp->napi)) {\n\t\tiowrite32(TYPHOON_INTR_ALL, ioaddr + TYPHOON_REG_INTR_MASK);\n\t\ttyphoon_post_pci_writes(ioaddr);\n\t\t__napi_schedule(&tp->napi);\n\t} else {\n\t\tnetdev_err(dev, \"Error, poll already scheduled\\n\");\n\t}\n\treturn IRQ_HANDLED;\n}\n\nstatic void\ntyphoon_free_rx_rings(struct typhoon *tp)\n{\n\tu32 i;\n\n\tfor (i = 0; i < RXENT_ENTRIES; i++) {\n\t\tstruct rxbuff_ent *rxb = &tp->rxbuffers[i];\n\t\tif (rxb->skb) {\n\t\t\tdma_unmap_single(&tp->pdev->dev, rxb->dma_addr,\n\t\t\t\t\t PKT_BUF_SZ, DMA_FROM_DEVICE);\n\t\t\tdev_kfree_skb(rxb->skb);\n\t\t\trxb->skb = NULL;\n\t\t}\n\t}\n}\n\nstatic int\ntyphoon_sleep_early(struct typhoon *tp, __le16 events)\n{\n\tvoid __iomem *ioaddr = tp->ioaddr;\n\tstruct cmd_desc xp_cmd;\n\tint err;\n\n\tINIT_COMMAND_WITH_RESPONSE(&xp_cmd, TYPHOON_CMD_ENABLE_WAKE_EVENTS);\n\txp_cmd.parm1 = events;\n\terr = typhoon_issue_command(tp, 1, &xp_cmd, 0, NULL);\n\tif (err < 0) {\n\t\tnetdev_err(tp->dev, \"typhoon_sleep(): wake events cmd err %d\\n\",\n\t\t\t   err);\n\t\treturn err;\n\t}\n\n\tINIT_COMMAND_NO_RESPONSE(&xp_cmd, TYPHOON_CMD_GOTO_SLEEP);\n\terr = typhoon_issue_command(tp, 1, &xp_cmd, 0, NULL);\n\tif (err < 0) {\n\t\tnetdev_err(tp->dev, \"typhoon_sleep(): sleep cmd err %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tif (typhoon_wait_status(ioaddr, TYPHOON_STATUS_SLEEPING) < 0)\n\t\treturn -ETIMEDOUT;\n\n\t \n\tnetif_carrier_off(tp->dev);\n\n\treturn 0;\n}\n\nstatic int\ntyphoon_sleep(struct typhoon *tp, pci_power_t state, __le16 events)\n{\n\tint err;\n\n\terr = typhoon_sleep_early(tp, events);\n\n\tif (err)\n\t\treturn err;\n\n\tpci_enable_wake(tp->pdev, state, 1);\n\tpci_disable_device(tp->pdev);\n\treturn pci_set_power_state(tp->pdev, state);\n}\n\nstatic int\ntyphoon_wakeup(struct typhoon *tp, int wait_type)\n{\n\tvoid __iomem *ioaddr = tp->ioaddr;\n\n\t \n\tiowrite32(TYPHOON_BOOTCMD_WAKEUP, ioaddr + TYPHOON_REG_COMMAND);\n\tif (typhoon_wait_status(ioaddr, TYPHOON_STATUS_WAITING_FOR_HOST) < 0 ||\n\t\t\t(tp->capabilities & TYPHOON_WAKEUP_NEEDS_RESET))\n\t\treturn typhoon_reset(ioaddr, wait_type);\n\n\treturn 0;\n}\n\nstatic int\ntyphoon_start_runtime(struct typhoon *tp)\n{\n\tstruct net_device *dev = tp->dev;\n\tvoid __iomem *ioaddr = tp->ioaddr;\n\tstruct cmd_desc xp_cmd;\n\tint err;\n\n\ttyphoon_init_rings(tp);\n\ttyphoon_fill_free_ring(tp);\n\n\terr = typhoon_download_firmware(tp);\n\tif (err < 0) {\n\t\tnetdev_err(tp->dev, \"cannot load runtime on 3XP\\n\");\n\t\tgoto error_out;\n\t}\n\n\tif (typhoon_boot_3XP(tp, TYPHOON_STATUS_WAITING_FOR_BOOT) < 0) {\n\t\tnetdev_err(tp->dev, \"cannot boot 3XP\\n\");\n\t\terr = -EIO;\n\t\tgoto error_out;\n\t}\n\n\tINIT_COMMAND_NO_RESPONSE(&xp_cmd, TYPHOON_CMD_SET_MAX_PKT_SIZE);\n\txp_cmd.parm1 = cpu_to_le16(PKT_BUF_SZ);\n\terr = typhoon_issue_command(tp, 1, &xp_cmd, 0, NULL);\n\tif (err < 0)\n\t\tgoto error_out;\n\n\tINIT_COMMAND_NO_RESPONSE(&xp_cmd, TYPHOON_CMD_SET_MAC_ADDRESS);\n\txp_cmd.parm1 = cpu_to_le16(ntohs(*(__be16 *)&dev->dev_addr[0]));\n\txp_cmd.parm2 = cpu_to_le32(ntohl(*(__be32 *)&dev->dev_addr[2]));\n\terr = typhoon_issue_command(tp, 1, &xp_cmd, 0, NULL);\n\tif (err < 0)\n\t\tgoto error_out;\n\n\t \n\tINIT_COMMAND_WITH_RESPONSE(&xp_cmd, TYPHOON_CMD_IRQ_COALESCE_CTRL);\n\txp_cmd.parm1 = 0;\n\terr = typhoon_issue_command(tp, 1, &xp_cmd, 0, NULL);\n\tif (err < 0)\n\t\tgoto error_out;\n\n\tINIT_COMMAND_NO_RESPONSE(&xp_cmd, TYPHOON_CMD_XCVR_SELECT);\n\txp_cmd.parm1 = tp->xcvr_select;\n\terr = typhoon_issue_command(tp, 1, &xp_cmd, 0, NULL);\n\tif (err < 0)\n\t\tgoto error_out;\n\n\tINIT_COMMAND_NO_RESPONSE(&xp_cmd, TYPHOON_CMD_VLAN_TYPE_WRITE);\n\txp_cmd.parm1 = cpu_to_le16(ETH_P_8021Q);\n\terr = typhoon_issue_command(tp, 1, &xp_cmd, 0, NULL);\n\tif (err < 0)\n\t\tgoto error_out;\n\n\tINIT_COMMAND_NO_RESPONSE(&xp_cmd, TYPHOON_CMD_SET_OFFLOAD_TASKS);\n\txp_cmd.parm2 = tp->offload;\n\txp_cmd.parm3 = tp->offload;\n\terr = typhoon_issue_command(tp, 1, &xp_cmd, 0, NULL);\n\tif (err < 0)\n\t\tgoto error_out;\n\n\ttyphoon_set_rx_mode(dev);\n\n\tINIT_COMMAND_NO_RESPONSE(&xp_cmd, TYPHOON_CMD_TX_ENABLE);\n\terr = typhoon_issue_command(tp, 1, &xp_cmd, 0, NULL);\n\tif (err < 0)\n\t\tgoto error_out;\n\n\tINIT_COMMAND_WITH_RESPONSE(&xp_cmd, TYPHOON_CMD_RX_ENABLE);\n\terr = typhoon_issue_command(tp, 1, &xp_cmd, 0, NULL);\n\tif (err < 0)\n\t\tgoto error_out;\n\n\ttp->card_state = Running;\n\tsmp_wmb();\n\n\tiowrite32(TYPHOON_INTR_ENABLE_ALL, ioaddr + TYPHOON_REG_INTR_ENABLE);\n\tiowrite32(TYPHOON_INTR_NONE, ioaddr + TYPHOON_REG_INTR_MASK);\n\ttyphoon_post_pci_writes(ioaddr);\n\n\treturn 0;\n\nerror_out:\n\ttyphoon_reset(ioaddr, WaitNoSleep);\n\ttyphoon_free_rx_rings(tp);\n\ttyphoon_init_rings(tp);\n\treturn err;\n}\n\nstatic int\ntyphoon_stop_runtime(struct typhoon *tp, int wait_type)\n{\n\tstruct typhoon_indexes *indexes = tp->indexes;\n\tstruct transmit_ring *txLo = &tp->txLoRing;\n\tvoid __iomem *ioaddr = tp->ioaddr;\n\tstruct cmd_desc xp_cmd;\n\tint i;\n\n\t \n\tiowrite32(TYPHOON_INTR_NONE, ioaddr + TYPHOON_REG_INTR_ENABLE);\n\n\tINIT_COMMAND_NO_RESPONSE(&xp_cmd, TYPHOON_CMD_RX_DISABLE);\n\ttyphoon_issue_command(tp, 1, &xp_cmd, 0, NULL);\n\n\t \n\tfor (i = 0; i < TYPHOON_WAIT_TIMEOUT; i++) {\n\t\tif (indexes->txLoCleared == cpu_to_le32(txLo->lastWrite))\n\t\t\tbreak;\n\t\tudelay(TYPHOON_UDELAY);\n\t}\n\n\tif (i == TYPHOON_WAIT_TIMEOUT)\n\t\tnetdev_err(tp->dev, \"halt timed out waiting for Tx to complete\\n\");\n\n\tINIT_COMMAND_NO_RESPONSE(&xp_cmd, TYPHOON_CMD_TX_DISABLE);\n\ttyphoon_issue_command(tp, 1, &xp_cmd, 0, NULL);\n\n\t \n\ttp->card_state = Sleeping;\n\tsmp_wmb();\n\ttyphoon_do_get_stats(tp);\n\tmemcpy(&tp->stats_saved, &tp->dev->stats, sizeof(struct net_device_stats));\n\n\tINIT_COMMAND_NO_RESPONSE(&xp_cmd, TYPHOON_CMD_HALT);\n\ttyphoon_issue_command(tp, 1, &xp_cmd, 0, NULL);\n\n\tif (typhoon_wait_status(ioaddr, TYPHOON_STATUS_HALTED) < 0)\n\t\tnetdev_err(tp->dev, \"timed out waiting for 3XP to halt\\n\");\n\n\tif (typhoon_reset(ioaddr, wait_type) < 0) {\n\t\tnetdev_err(tp->dev, \"unable to reset 3XP\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\t \n\tif (indexes->txLoCleared != cpu_to_le32(txLo->lastWrite)) {\n\t\tindexes->txLoCleared = cpu_to_le32(txLo->lastWrite);\n\t\ttyphoon_clean_tx(tp, &tp->txLoRing, &indexes->txLoCleared);\n\t}\n\n\treturn 0;\n}\n\nstatic void\ntyphoon_tx_timeout(struct net_device *dev, unsigned int txqueue)\n{\n\tstruct typhoon *tp = netdev_priv(dev);\n\n\tif (typhoon_reset(tp->ioaddr, WaitNoSleep) < 0) {\n\t\tnetdev_warn(dev, \"could not reset in tx timeout\\n\");\n\t\tgoto truly_dead;\n\t}\n\n\t \n\ttyphoon_clean_tx(tp, &tp->txLoRing, &tp->indexes->txLoCleared);\n\ttyphoon_free_rx_rings(tp);\n\n\tif (typhoon_start_runtime(tp) < 0) {\n\t\tnetdev_err(dev, \"could not start runtime in tx timeout\\n\");\n\t\tgoto truly_dead;\n        }\n\n\tnetif_wake_queue(dev);\n\treturn;\n\ntruly_dead:\n\t \n\ttyphoon_reset(tp->ioaddr, NoWait);\n\tnetif_carrier_off(dev);\n}\n\nstatic int\ntyphoon_open(struct net_device *dev)\n{\n\tstruct typhoon *tp = netdev_priv(dev);\n\tint err;\n\n\terr = typhoon_request_firmware(tp);\n\tif (err)\n\t\tgoto out;\n\n\tpci_set_power_state(tp->pdev, PCI_D0);\n\tpci_restore_state(tp->pdev);\n\n\terr = typhoon_wakeup(tp, WaitSleep);\n\tif (err < 0) {\n\t\tnetdev_err(dev, \"unable to wakeup device\\n\");\n\t\tgoto out_sleep;\n\t}\n\n\terr = request_irq(dev->irq, typhoon_interrupt, IRQF_SHARED,\n\t\t\t\tdev->name, dev);\n\tif (err < 0)\n\t\tgoto out_sleep;\n\n\tnapi_enable(&tp->napi);\n\n\terr = typhoon_start_runtime(tp);\n\tif (err < 0) {\n\t\tnapi_disable(&tp->napi);\n\t\tgoto out_irq;\n\t}\n\n\tnetif_start_queue(dev);\n\treturn 0;\n\nout_irq:\n\tfree_irq(dev->irq, dev);\n\nout_sleep:\n\tif (typhoon_boot_3XP(tp, TYPHOON_STATUS_WAITING_FOR_HOST) < 0) {\n\t\tnetdev_err(dev, \"unable to reboot into sleep img\\n\");\n\t\ttyphoon_reset(tp->ioaddr, NoWait);\n\t\tgoto out;\n\t}\n\n\tif (typhoon_sleep(tp, PCI_D3hot, 0) < 0)\n\t\tnetdev_err(dev, \"unable to go back to sleep\\n\");\n\nout:\n\treturn err;\n}\n\nstatic int\ntyphoon_close(struct net_device *dev)\n{\n\tstruct typhoon *tp = netdev_priv(dev);\n\n\tnetif_stop_queue(dev);\n\tnapi_disable(&tp->napi);\n\n\tif (typhoon_stop_runtime(tp, WaitSleep) < 0)\n\t\tnetdev_err(dev, \"unable to stop runtime\\n\");\n\n\t \n\tfree_irq(dev->irq, dev);\n\n\ttyphoon_free_rx_rings(tp);\n\ttyphoon_init_rings(tp);\n\n\tif (typhoon_boot_3XP(tp, TYPHOON_STATUS_WAITING_FOR_HOST) < 0)\n\t\tnetdev_err(dev, \"unable to boot sleep image\\n\");\n\n\tif (typhoon_sleep(tp, PCI_D3hot, 0) < 0)\n\t\tnetdev_err(dev, \"unable to put card to sleep\\n\");\n\n\treturn 0;\n}\n\nstatic int __maybe_unused\ntyphoon_resume(struct device *dev_d)\n{\n\tstruct net_device *dev = dev_get_drvdata(dev_d);\n\tstruct typhoon *tp = netdev_priv(dev);\n\n\t \n\tif (!netif_running(dev))\n\t\treturn 0;\n\n\tif (typhoon_wakeup(tp, WaitNoSleep) < 0) {\n\t\tnetdev_err(dev, \"critical: could not wake up in resume\\n\");\n\t\tgoto reset;\n\t}\n\n\tif (typhoon_start_runtime(tp) < 0) {\n\t\tnetdev_err(dev, \"critical: could not start runtime in resume\\n\");\n\t\tgoto reset;\n\t}\n\n\tnetif_device_attach(dev);\n\treturn 0;\n\nreset:\n\ttyphoon_reset(tp->ioaddr, NoWait);\n\treturn -EBUSY;\n}\n\nstatic int __maybe_unused\ntyphoon_suspend(struct device *dev_d)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev_d);\n\tstruct net_device *dev = pci_get_drvdata(pdev);\n\tstruct typhoon *tp = netdev_priv(dev);\n\tstruct cmd_desc xp_cmd;\n\n\t \n\tif (!netif_running(dev))\n\t\treturn 0;\n\n\t \n\tif (tp->wol_events & TYPHOON_WAKE_MAGIC_PKT)\n\t\tnetdev_warn(dev, \"cannot do WAKE_MAGIC with VLAN offloading\\n\");\n\n\tnetif_device_detach(dev);\n\n\tif (typhoon_stop_runtime(tp, WaitNoSleep) < 0) {\n\t\tnetdev_err(dev, \"unable to stop runtime\\n\");\n\t\tgoto need_resume;\n\t}\n\n\ttyphoon_free_rx_rings(tp);\n\ttyphoon_init_rings(tp);\n\n\tif (typhoon_boot_3XP(tp, TYPHOON_STATUS_WAITING_FOR_HOST) < 0) {\n\t\tnetdev_err(dev, \"unable to boot sleep image\\n\");\n\t\tgoto need_resume;\n\t}\n\n\tINIT_COMMAND_NO_RESPONSE(&xp_cmd, TYPHOON_CMD_SET_MAC_ADDRESS);\n\txp_cmd.parm1 = cpu_to_le16(ntohs(*(__be16 *)&dev->dev_addr[0]));\n\txp_cmd.parm2 = cpu_to_le32(ntohl(*(__be32 *)&dev->dev_addr[2]));\n\tif (typhoon_issue_command(tp, 1, &xp_cmd, 0, NULL) < 0) {\n\t\tnetdev_err(dev, \"unable to set mac address in suspend\\n\");\n\t\tgoto need_resume;\n\t}\n\n\tINIT_COMMAND_NO_RESPONSE(&xp_cmd, TYPHOON_CMD_SET_RX_FILTER);\n\txp_cmd.parm1 = TYPHOON_RX_FILTER_DIRECTED | TYPHOON_RX_FILTER_BROADCAST;\n\tif (typhoon_issue_command(tp, 1, &xp_cmd, 0, NULL) < 0) {\n\t\tnetdev_err(dev, \"unable to set rx filter in suspend\\n\");\n\t\tgoto need_resume;\n\t}\n\n\tif (typhoon_sleep_early(tp, tp->wol_events) < 0) {\n\t\tnetdev_err(dev, \"unable to put card to sleep\\n\");\n\t\tgoto need_resume;\n\t}\n\n\tdevice_wakeup_enable(dev_d);\n\n\treturn 0;\n\nneed_resume:\n\ttyphoon_resume(dev_d);\n\treturn -EBUSY;\n}\n\nstatic int\ntyphoon_test_mmio(struct pci_dev *pdev)\n{\n\tvoid __iomem *ioaddr = pci_iomap(pdev, 1, 128);\n\tint mode = 0;\n\tu32 val;\n\n\tif (!ioaddr)\n\t\tgoto out;\n\n\tif (ioread32(ioaddr + TYPHOON_REG_STATUS) !=\n\t\t\t\tTYPHOON_STATUS_WAITING_FOR_HOST)\n\t\tgoto out_unmap;\n\n\tiowrite32(TYPHOON_INTR_ALL, ioaddr + TYPHOON_REG_INTR_MASK);\n\tiowrite32(TYPHOON_INTR_ALL, ioaddr + TYPHOON_REG_INTR_STATUS);\n\tiowrite32(TYPHOON_INTR_ALL, ioaddr + TYPHOON_REG_INTR_ENABLE);\n\n\t \n\tval = ioread32(ioaddr + TYPHOON_REG_INTR_STATUS);\n\tif ((val & TYPHOON_INTR_SELF) == 0) {\n\t\tiowrite32(1, ioaddr + TYPHOON_REG_SELF_INTERRUPT);\n\t\tioread32(ioaddr + TYPHOON_REG_INTR_STATUS);\n\t\tudelay(50);\n\t\tval = ioread32(ioaddr + TYPHOON_REG_INTR_STATUS);\n\t\tif (val & TYPHOON_INTR_SELF)\n\t\t\tmode = 1;\n\t}\n\n\tiowrite32(TYPHOON_INTR_ALL, ioaddr + TYPHOON_REG_INTR_MASK);\n\tiowrite32(TYPHOON_INTR_ALL, ioaddr + TYPHOON_REG_INTR_STATUS);\n\tiowrite32(TYPHOON_INTR_NONE, ioaddr + TYPHOON_REG_INTR_ENABLE);\n\tioread32(ioaddr + TYPHOON_REG_INTR_STATUS);\n\nout_unmap:\n\tpci_iounmap(pdev, ioaddr);\n\nout:\n\tif (!mode)\n\t\tpr_info(\"%s: falling back to port IO\\n\", pci_name(pdev));\n\treturn mode;\n}\n\n#if MAX_SKB_FRAGS > 32\n\n#include <net/vxlan.h>\n\nstatic netdev_features_t typhoon_features_check(struct sk_buff *skb,\n\t\t\t\t\t\tstruct net_device *dev,\n\t\t\t\t\t\tnetdev_features_t features)\n{\n\tif (skb_shinfo(skb)->nr_frags > 32 && skb_is_gso(skb))\n\t\tfeatures &= ~NETIF_F_GSO_MASK;\n\n\tfeatures = vlan_features_check(skb, features);\n\treturn vxlan_features_check(skb, features);\n}\n#endif\n\nstatic const struct net_device_ops typhoon_netdev_ops = {\n\t.ndo_open\t\t= typhoon_open,\n\t.ndo_stop\t\t= typhoon_close,\n#if MAX_SKB_FRAGS > 32\n\t.ndo_features_check\t= typhoon_features_check,\n#endif\n\t.ndo_start_xmit\t\t= typhoon_start_tx,\n\t.ndo_set_rx_mode\t= typhoon_set_rx_mode,\n\t.ndo_tx_timeout\t\t= typhoon_tx_timeout,\n\t.ndo_get_stats\t\t= typhoon_get_stats,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_set_mac_address\t= eth_mac_addr,\n};\n\nstatic int\ntyphoon_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tstruct net_device *dev;\n\tstruct typhoon *tp;\n\tint card_id = (int) ent->driver_data;\n\tu8 addr[ETH_ALEN] __aligned(4);\n\tvoid __iomem *ioaddr;\n\tvoid *shared;\n\tdma_addr_t shared_dma;\n\tstruct cmd_desc xp_cmd;\n\tstruct resp_desc xp_resp[3];\n\tint err = 0;\n\tconst char *err_msg;\n\n\tdev = alloc_etherdev(sizeof(*tp));\n\tif (dev == NULL) {\n\t\terr_msg = \"unable to alloc new net device\";\n\t\terr = -ENOMEM;\n\t\tgoto error_out;\n\t}\n\tSET_NETDEV_DEV(dev, &pdev->dev);\n\n\terr = pci_enable_device(pdev);\n\tif (err < 0) {\n\t\terr_msg = \"unable to enable device\";\n\t\tgoto error_out_dev;\n\t}\n\n\terr = pci_set_mwi(pdev);\n\tif (err < 0) {\n\t\terr_msg = \"unable to set MWI\";\n\t\tgoto error_out_disable;\n\t}\n\n\terr = dma_set_mask(&pdev->dev, DMA_BIT_MASK(32));\n\tif (err < 0) {\n\t\terr_msg = \"No usable DMA configuration\";\n\t\tgoto error_out_mwi;\n\t}\n\n\t \n\tif (!(pci_resource_flags(pdev, 0) & IORESOURCE_IO)) {\n\t\terr_msg = \"region #1 not a PCI IO resource, aborting\";\n\t\terr = -ENODEV;\n\t\tgoto error_out_mwi;\n\t}\n\tif (pci_resource_len(pdev, 0) < 128) {\n\t\terr_msg = \"Invalid PCI IO region size, aborting\";\n\t\terr = -ENODEV;\n\t\tgoto error_out_mwi;\n\t}\n\tif (!(pci_resource_flags(pdev, 1) & IORESOURCE_MEM)) {\n\t\terr_msg = \"region #1 not a PCI MMIO resource, aborting\";\n\t\terr = -ENODEV;\n\t\tgoto error_out_mwi;\n\t}\n\tif (pci_resource_len(pdev, 1) < 128) {\n\t\terr_msg = \"Invalid PCI MMIO region size, aborting\";\n\t\terr = -ENODEV;\n\t\tgoto error_out_mwi;\n\t}\n\n\terr = pci_request_regions(pdev, KBUILD_MODNAME);\n\tif (err < 0) {\n\t\terr_msg = \"could not request regions\";\n\t\tgoto error_out_mwi;\n\t}\n\n\t \n\tif (use_mmio != 0 && use_mmio != 1)\n\t\tuse_mmio = typhoon_test_mmio(pdev);\n\n\tioaddr = pci_iomap(pdev, use_mmio, 128);\n\tif (!ioaddr) {\n\t\terr_msg = \"cannot remap registers, aborting\";\n\t\terr = -EIO;\n\t\tgoto error_out_regions;\n\t}\n\n\t \n\tshared = dma_alloc_coherent(&pdev->dev, sizeof(struct typhoon_shared),\n\t\t\t\t    &shared_dma, GFP_KERNEL);\n\tif (!shared) {\n\t\terr_msg = \"could not allocate DMA memory\";\n\t\terr = -ENOMEM;\n\t\tgoto error_out_remap;\n\t}\n\n\tdev->irq = pdev->irq;\n\ttp = netdev_priv(dev);\n\ttp->shared = shared;\n\ttp->shared_dma = shared_dma;\n\ttp->pdev = pdev;\n\ttp->tx_pdev = pdev;\n\ttp->ioaddr = ioaddr;\n\ttp->tx_ioaddr = ioaddr;\n\ttp->dev = dev;\n\n\t \n\terr = typhoon_reset(ioaddr, WaitSleep);\n\tif (err < 0) {\n\t\terr_msg = \"could not reset 3XP\";\n\t\tgoto error_out_dma;\n\t}\n\n\t \n\tpci_set_master(pdev);\n\tpci_save_state(pdev);\n\n\ttyphoon_init_interface(tp);\n\ttyphoon_init_rings(tp);\n\n\terr = typhoon_boot_3XP(tp, TYPHOON_STATUS_WAITING_FOR_HOST);\n\tif (err < 0) {\n\t\terr_msg = \"cannot boot 3XP sleep image\";\n\t\tgoto error_out_reset;\n\t}\n\n\tINIT_COMMAND_WITH_RESPONSE(&xp_cmd, TYPHOON_CMD_READ_MAC_ADDRESS);\n\terr = typhoon_issue_command(tp, 1, &xp_cmd, 1, xp_resp);\n\tif (err < 0) {\n\t\terr_msg = \"cannot read MAC address\";\n\t\tgoto error_out_reset;\n\t}\n\n\t*(__be16 *)&addr[0] = htons(le16_to_cpu(xp_resp[0].parm1));\n\t*(__be32 *)&addr[2] = htonl(le32_to_cpu(xp_resp[0].parm2));\n\teth_hw_addr_set(dev, addr);\n\n\tif (!is_valid_ether_addr(dev->dev_addr)) {\n\t\terr_msg = \"Could not obtain valid ethernet address, aborting\";\n\t\terr = -EIO;\n\t\tgoto error_out_reset;\n\t}\n\n\t \n\tINIT_COMMAND_WITH_RESPONSE(&xp_cmd, TYPHOON_CMD_READ_VERSIONS);\n\terr = typhoon_issue_command(tp, 1, &xp_cmd, 3, xp_resp);\n\tif (err < 0) {\n\t\terr_msg = \"Could not get Sleep Image version\";\n\t\tgoto error_out_reset;\n\t}\n\n\ttp->capabilities = typhoon_card_info[card_id].capabilities;\n\ttp->xcvr_select = TYPHOON_XCVR_AUTONEG;\n\n\t \n\tif (xp_resp[0].numDesc != 0)\n\t\ttp->capabilities |= TYPHOON_WAKEUP_NEEDS_RESET;\n\n\terr = typhoon_sleep(tp, PCI_D3hot, 0);\n\tif (err < 0) {\n\t\terr_msg = \"cannot put adapter to sleep\";\n\t\tgoto error_out_reset;\n\t}\n\n\t \n\tdev->netdev_ops\t\t= &typhoon_netdev_ops;\n\tnetif_napi_add_weight(dev, &tp->napi, typhoon_poll, 16);\n\tdev->watchdog_timeo\t= TX_TIMEOUT;\n\n\tdev->ethtool_ops = &typhoon_ethtool_ops;\n\n\t \n\tdev->hw_features = NETIF_F_SG | NETIF_F_IP_CSUM | NETIF_F_TSO |\n\t\tNETIF_F_HW_VLAN_CTAG_TX;\n\tdev->features = dev->hw_features |\n\t\tNETIF_F_HW_VLAN_CTAG_RX | NETIF_F_RXCSUM;\n\n\terr = register_netdev(dev);\n\tif (err < 0) {\n\t\terr_msg = \"unable to register netdev\";\n\t\tgoto error_out_reset;\n\t}\n\n\tpci_set_drvdata(pdev, dev);\n\n\tnetdev_info(dev, \"%s at %s 0x%llx, %pM\\n\",\n\t\t    typhoon_card_info[card_id].name,\n\t\t    use_mmio ? \"MMIO\" : \"IO\",\n\t\t    (unsigned long long)pci_resource_start(pdev, use_mmio),\n\t\t    dev->dev_addr);\n\n\t \n\tif (xp_resp[0].numDesc == 0) {\n\t\t \n\t\tu16 monthday = le32_to_cpu(xp_resp[0].parm2) & 0xffff;\n\t\tnetdev_info(dev, \"Typhoon 1.0 Sleep Image built %02u/%02u/2000\\n\",\n\t\t\t    monthday >> 8, monthday & 0xff);\n\t} else if (xp_resp[0].numDesc == 2) {\n\t\t \n\t\tu32 sleep_ver = le32_to_cpu(xp_resp[0].parm2);\n\t\tu8 *ver_string = (u8 *) &xp_resp[1];\n\t\tver_string[25] = 0;\n\t\tnetdev_info(dev, \"Typhoon 1.1+ Sleep Image version %02x.%03x.%03x %s\\n\",\n\t\t\t    sleep_ver >> 24, (sleep_ver >> 12) & 0xfff,\n\t\t\t    sleep_ver & 0xfff, ver_string);\n\t} else {\n\t\tnetdev_warn(dev, \"Unknown Sleep Image version (%u:%04x)\\n\",\n\t\t\t    xp_resp[0].numDesc, le32_to_cpu(xp_resp[0].parm2));\n\t}\n\n\treturn 0;\n\nerror_out_reset:\n\ttyphoon_reset(ioaddr, NoWait);\n\nerror_out_dma:\n\tdma_free_coherent(&pdev->dev, sizeof(struct typhoon_shared), shared,\n\t\t\t  shared_dma);\nerror_out_remap:\n\tpci_iounmap(pdev, ioaddr);\nerror_out_regions:\n\tpci_release_regions(pdev);\nerror_out_mwi:\n\tpci_clear_mwi(pdev);\nerror_out_disable:\n\tpci_disable_device(pdev);\nerror_out_dev:\n\tfree_netdev(dev);\nerror_out:\n\tpr_err(\"%s: %s\\n\", pci_name(pdev), err_msg);\n\treturn err;\n}\n\nstatic void\ntyphoon_remove_one(struct pci_dev *pdev)\n{\n\tstruct net_device *dev = pci_get_drvdata(pdev);\n\tstruct typhoon *tp = netdev_priv(dev);\n\n\tunregister_netdev(dev);\n\tpci_set_power_state(pdev, PCI_D0);\n\tpci_restore_state(pdev);\n\ttyphoon_reset(tp->ioaddr, NoWait);\n\tpci_iounmap(pdev, tp->ioaddr);\n\tdma_free_coherent(&pdev->dev, sizeof(struct typhoon_shared),\n\t\t\t  tp->shared, tp->shared_dma);\n\tpci_release_regions(pdev);\n\tpci_clear_mwi(pdev);\n\tpci_disable_device(pdev);\n\tfree_netdev(dev);\n}\n\nstatic SIMPLE_DEV_PM_OPS(typhoon_pm_ops, typhoon_suspend, typhoon_resume);\n\nstatic struct pci_driver typhoon_driver = {\n\t.name\t\t= KBUILD_MODNAME,\n\t.id_table\t= typhoon_pci_tbl,\n\t.probe\t\t= typhoon_init_one,\n\t.remove\t\t= typhoon_remove_one,\n\t.driver.pm\t= &typhoon_pm_ops,\n};\n\nstatic int __init\ntyphoon_init(void)\n{\n\treturn pci_register_driver(&typhoon_driver);\n}\n\nstatic void __exit\ntyphoon_cleanup(void)\n{\n\trelease_firmware(typhoon_fw);\n\tpci_unregister_driver(&typhoon_driver);\n}\n\nmodule_init(typhoon_init);\nmodule_exit(typhoon_cleanup);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}