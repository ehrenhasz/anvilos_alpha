{
  "module_name": "3c574_cs.c",
  "hash_id": "7a06e692636b83f907264f3f16e6b8649b294d33a73ac1cc374296d63cd4ddca",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/3com/3c574_cs.c",
  "human_readable_source": " \n\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/timer.h>\n#include <linux/interrupt.h>\n#include <linux/in.h>\n#include <linux/delay.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/skbuff.h>\n#include <linux/if_arp.h>\n#include <linux/ioport.h>\n#include <linux/bitops.h>\n#include <linux/mii.h>\n\n#include <pcmcia/cistpl.h>\n#include <pcmcia/cisreg.h>\n#include <pcmcia/ciscode.h>\n#include <pcmcia/ds.h>\n\n#include <linux/uaccess.h>\n#include <asm/io.h>\n\n \n\n \n\nMODULE_AUTHOR(\"David Hinds <dahinds@users.sourceforge.net>\");\nMODULE_DESCRIPTION(\"3Com 3c574 series PCMCIA ethernet driver\");\nMODULE_LICENSE(\"GPL\");\n\n#define INT_MODULE_PARM(n, v) static int n = v; module_param(n, int, 0)\n\n \nINT_MODULE_PARM(max_interrupt_work, 32);\n\n \nINT_MODULE_PARM(full_duplex, 0);\n\n \nINT_MODULE_PARM(auto_polarity, 1);\n\n\n \n\n \n#define TX_TIMEOUT  ((800*HZ)/1000)\n\n \n \n#define EL3_DATA\t0x00\n#define EL3_CMD\t\t0x0e\n#define EL3_STATUS\t0x0e\n\n#define EL3WINDOW(win_num) outw(SelectWindow + (win_num), ioaddr + EL3_CMD)\n\n \nenum el3_cmds {\n\tTotalReset = 0<<11, SelectWindow = 1<<11, StartCoax = 2<<11,\n\tRxDisable = 3<<11, RxEnable = 4<<11, RxReset = 5<<11, RxDiscard = 8<<11,\n\tTxEnable = 9<<11, TxDisable = 10<<11, TxReset = 11<<11,\n\tFakeIntr = 12<<11, AckIntr = 13<<11, SetIntrEnb = 14<<11,\n\tSetStatusEnb = 15<<11, SetRxFilter = 16<<11, SetRxThreshold = 17<<11,\n\tSetTxThreshold = 18<<11, SetTxStart = 19<<11, StatsEnable = 21<<11,\n\tStatsDisable = 22<<11, StopCoax = 23<<11,\n};\n\nenum elxl_status {\n\tIntLatch = 0x0001, AdapterFailure = 0x0002, TxComplete = 0x0004,\n\tTxAvailable = 0x0008, RxComplete = 0x0010, RxEarly = 0x0020,\n\tIntReq = 0x0040, StatsFull = 0x0080, CmdBusy = 0x1000 };\n\n \nenum RxFilter {\n\tRxStation = 1, RxMulticast = 2, RxBroadcast = 4, RxProm = 8\n};\n\nenum Window0 {\n\tWn0EepromCmd = 10, Wn0EepromData = 12,  \n\tIntrStatus=0x0E,\t\t \n};\n \nenum Win0_EEPROM_cmds {\n\tEEPROM_Read = 0x200, EEPROM_WRITE = 0x100, EEPROM_ERASE = 0x300,\n\tEEPROM_EWENB = 0x30,\t\t \n\tEEPROM_EWDIS = 0x00,\t\t \n};\n\n \nenum Window1 {\n\tTX_FIFO = 0x10,  RX_FIFO = 0x10,  RxErrors = 0x14,\n\tRxStatus = 0x18,  Timer=0x1A, TxStatus = 0x1B,\n\tTxFree = 0x0C,  \n\tRunnerRdCtrl = 0x16, RunnerWrCtrl = 0x1c,\n};\n\nenum Window3 {\t\t\t \n\tWn3_Config=0, Wn3_MAC_Ctrl=6, Wn3_Options=8,\n};\nenum wn3_config {\n\tRam_size = 7,\n\tRam_width = 8,\n\tRam_speed = 0x30,\n\tRom_size = 0xc0,\n\tRam_split_shift = 16,\n\tRam_split = 3 << Ram_split_shift,\n\tXcvr_shift = 20,\n\tXcvr = 7 << Xcvr_shift,\n\tAutoselect = 0x1000000,\n};\n\nenum Window4 {\t\t \n\tWn4_FIFODiag = 4, Wn4_NetDiag = 6, Wn4_PhysicalMgmt=8, Wn4_Media = 10,\n};\n\n#define MEDIA_TP\t0x00C0\t \n\nstruct el3_private {\n\tstruct pcmcia_device\t*p_dev;\n\tu16 advertising, partner;\t\t \n\tunsigned char phys;\t\t\t \n\tunsigned int autoselect:1, default_media:3;\t \n\t \n\tstruct timer_list media;\n\tunsigned short media_status;\n\tunsigned short fast_poll;\n\tunsigned long last_irq;\n\tspinlock_t window_lock;\t\t\t \n};\n\n \nstatic char mii_preamble_required = 0;\n\n \n\nstatic int tc574_config(struct pcmcia_device *link);\nstatic void tc574_release(struct pcmcia_device *link);\n\nstatic void mdio_sync(unsigned int ioaddr, int bits);\nstatic int mdio_read(unsigned int ioaddr, int phy_id, int location);\nstatic void mdio_write(unsigned int ioaddr, int phy_id, int location,\n\t\t       int value);\nstatic unsigned short read_eeprom(unsigned int ioaddr, int index);\nstatic void tc574_wait_for_completion(struct net_device *dev, int cmd);\n\nstatic void tc574_reset(struct net_device *dev);\nstatic void media_check(struct timer_list *t);\nstatic int el3_open(struct net_device *dev);\nstatic netdev_tx_t el3_start_xmit(struct sk_buff *skb,\n\t\t\t\t\tstruct net_device *dev);\nstatic irqreturn_t el3_interrupt(int irq, void *dev_id);\nstatic void update_stats(struct net_device *dev);\nstatic struct net_device_stats *el3_get_stats(struct net_device *dev);\nstatic int el3_rx(struct net_device *dev, int worklimit);\nstatic int el3_close(struct net_device *dev);\nstatic void el3_tx_timeout(struct net_device *dev, unsigned int txqueue);\nstatic int el3_ioctl(struct net_device *dev, struct ifreq *rq, int cmd);\nstatic void set_rx_mode(struct net_device *dev);\nstatic void set_multicast_list(struct net_device *dev);\n\nstatic void tc574_detach(struct pcmcia_device *p_dev);\n\n \nstatic const struct net_device_ops el3_netdev_ops = {\n\t.ndo_open \t\t= el3_open,\n\t.ndo_stop \t\t= el3_close,\n\t.ndo_start_xmit\t\t= el3_start_xmit,\n\t.ndo_tx_timeout \t= el3_tx_timeout,\n\t.ndo_get_stats\t\t= el3_get_stats,\n\t.ndo_eth_ioctl\t\t= el3_ioctl,\n\t.ndo_set_rx_mode\t= set_multicast_list,\n\t.ndo_set_mac_address \t= eth_mac_addr,\n\t.ndo_validate_addr\t= eth_validate_addr,\n};\n\nstatic int tc574_probe(struct pcmcia_device *link)\n{\n\tstruct el3_private *lp;\n\tstruct net_device *dev;\n\n\tdev_dbg(&link->dev, \"3c574_attach()\\n\");\n\n\t \n\tdev = alloc_etherdev(sizeof(struct el3_private));\n\tif (!dev)\n\t\treturn -ENOMEM;\n\tlp = netdev_priv(dev);\n\tlink->priv = dev;\n\tlp->p_dev = link;\n\n\tspin_lock_init(&lp->window_lock);\n\tlink->resource[0]->end = 32;\n\tlink->resource[0]->flags |= IO_DATA_PATH_WIDTH_16;\n\tlink->config_flags |= CONF_ENABLE_IRQ;\n\tlink->config_index = 1;\n\n\tdev->netdev_ops = &el3_netdev_ops;\n\tdev->watchdog_timeo = TX_TIMEOUT;\n\n\treturn tc574_config(link);\n}\n\nstatic void tc574_detach(struct pcmcia_device *link)\n{\n\tstruct net_device *dev = link->priv;\n\n\tdev_dbg(&link->dev, \"3c574_detach()\\n\");\n\n\tunregister_netdev(dev);\n\n\ttc574_release(link);\n\n\tfree_netdev(dev);\n}  \n\nstatic const char *ram_split[] = {\"5:3\", \"3:1\", \"1:1\", \"3:5\"};\n\nstatic int tc574_config(struct pcmcia_device *link)\n{\n\tstruct net_device *dev = link->priv;\n\tstruct el3_private *lp = netdev_priv(dev);\n\tint ret, i, j;\n\t__be16 addr[ETH_ALEN / 2];\n\tunsigned int ioaddr;\n\tchar *cardname;\n\t__u32 config;\n\tu8 *buf;\n\tsize_t len;\n\n\tdev_dbg(&link->dev, \"3c574_config()\\n\");\n\n\tlink->io_lines = 16;\n\n\tfor (i = j = 0; j < 0x400; j += 0x20) {\n\t\tlink->resource[0]->start = j ^ 0x300;\n\t\ti = pcmcia_request_io(link);\n\t\tif (i == 0)\n\t\t\tbreak;\n\t}\n\tif (i != 0)\n\t\tgoto failed;\n\n\tret = pcmcia_request_irq(link, el3_interrupt);\n\tif (ret)\n\t\tgoto failed;\n\n\tret = pcmcia_enable_device(link);\n\tif (ret)\n\t\tgoto failed;\n\n\tdev->irq = link->irq;\n\tdev->base_addr = link->resource[0]->start;\n\n\tioaddr = dev->base_addr;\n\n\t \n\n\tlen = pcmcia_get_tuple(link, 0x88, &buf);\n\tif (buf && len >= 6) {\n\t\tfor (i = 0; i < 3; i++)\n\t\t\taddr[i] = htons(le16_to_cpu(buf[i * 2]));\n\t\tkfree(buf);\n\t} else {\n\t\tkfree(buf);  \n\t\tEL3WINDOW(0);\n\t\tfor (i = 0; i < 3; i++)\n\t\t\taddr[i] = htons(read_eeprom(ioaddr, i + 10));\n\t\tif (addr[0] == htons(0x6060)) {\n\t\t\tpr_notice(\"IO port conflict at 0x%03lx-0x%03lx\\n\",\n\t\t\t\t  dev->base_addr, dev->base_addr+15);\n\t\t\tgoto failed;\n\t\t}\n\t}\n\teth_hw_addr_set(dev, (u8 *)addr);\n\tif (link->prod_id[1])\n\t\tcardname = link->prod_id[1];\n\telse\n\t\tcardname = \"3Com 3c574\";\n\n\t{\n\t\tu_char mcr;\n\t\toutw(2<<11, ioaddr + RunnerRdCtrl);\n\t\tmcr = inb(ioaddr + 2);\n\t\toutw(0<<11, ioaddr + RunnerRdCtrl);\n\t\tpr_info(\"  ASIC rev %d,\", mcr>>3);\n\t\tEL3WINDOW(3);\n\t\tconfig = inl(ioaddr + Wn3_Config);\n\t\tlp->default_media = (config & Xcvr) >> Xcvr_shift;\n\t\tlp->autoselect = config & Autoselect ? 1 : 0;\n\t}\n\n\ttimer_setup(&lp->media, media_check, 0);\n\n\t{\n\t\tint phy;\n\t\t\n\t\t \n\t\toutw(0x8040, ioaddr + Wn3_Options);\n\t\tmdelay(1);\n\t\toutw(0xc040, ioaddr + Wn3_Options);\n\t\ttc574_wait_for_completion(dev, TxReset);\n\t\ttc574_wait_for_completion(dev, RxReset);\n\t\tmdelay(1);\n\t\toutw(0x8040, ioaddr + Wn3_Options);\n\t\t\n\t\tEL3WINDOW(4);\n\t\tfor (phy = 1; phy <= 32; phy++) {\n\t\t\tint mii_status;\n\t\t\tmdio_sync(ioaddr, 32);\n\t\t\tmii_status = mdio_read(ioaddr, phy & 0x1f, 1);\n\t\t\tif (mii_status != 0xffff) {\n\t\t\t\tlp->phys = phy & 0x1f;\n\t\t\t\tdev_dbg(&link->dev, \"  MII transceiver at \"\n\t\t\t\t\t\"index %d, status %x.\\n\",\n\t\t\t\t\t  phy, mii_status);\n\t\t\t\tif ((mii_status & 0x0040) == 0)\n\t\t\t\t\tmii_preamble_required = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (phy > 32) {\n\t\t\tpr_notice(\"  No MII transceivers found!\\n\");\n\t\t\tgoto failed;\n\t\t}\n\t\ti = mdio_read(ioaddr, lp->phys, 16) | 0x40;\n\t\tmdio_write(ioaddr, lp->phys, 16, i);\n\t\tlp->advertising = mdio_read(ioaddr, lp->phys, 4);\n\t\tif (full_duplex) {\n\t\t\t \n\t\t\tlp->advertising &= ~0x02a0;\n\t\t\tmdio_write(ioaddr, lp->phys, 4, lp->advertising);\n\t\t}\n\t}\n\n\tSET_NETDEV_DEV(dev, &link->dev);\n\n\tif (register_netdev(dev) != 0) {\n\t\tpr_notice(\"register_netdev() failed\\n\");\n\t\tgoto failed;\n\t}\n\n\tnetdev_info(dev, \"%s at io %#3lx, irq %d, hw_addr %pM\\n\",\n\t\t    cardname, dev->base_addr, dev->irq, dev->dev_addr);\n\tnetdev_info(dev, \" %dK FIFO split %s Rx:Tx, %sMII interface.\\n\",\n\t\t    8 << (config & Ram_size),\n\t\t    ram_split[(config & Ram_split) >> Ram_split_shift],\n\t\t    config & Autoselect ? \"autoselect \" : \"\");\n\n\treturn 0;\n\nfailed:\n\ttc574_release(link);\n\treturn -ENODEV;\n\n}  \n\nstatic void tc574_release(struct pcmcia_device *link)\n{\n\tpcmcia_disable_device(link);\n}\n\nstatic int tc574_suspend(struct pcmcia_device *link)\n{\n\tstruct net_device *dev = link->priv;\n\n\tif (link->open)\n\t\tnetif_device_detach(dev);\n\n\treturn 0;\n}\n\nstatic int tc574_resume(struct pcmcia_device *link)\n{\n\tstruct net_device *dev = link->priv;\n\n\tif (link->open) {\n\t\ttc574_reset(dev);\n\t\tnetif_device_attach(dev);\n\t}\n\n\treturn 0;\n}\n\nstatic void dump_status(struct net_device *dev)\n{\n\tunsigned int ioaddr = dev->base_addr;\n\tEL3WINDOW(1);\n\tnetdev_info(dev, \"  irq status %04x, rx status %04x, tx status %02x, tx free %04x\\n\",\n\t\t    inw(ioaddr+EL3_STATUS),\n\t\t    inw(ioaddr+RxStatus), inb(ioaddr+TxStatus),\n\t\t    inw(ioaddr+TxFree));\n\tEL3WINDOW(4);\n\tnetdev_info(dev, \"  diagnostics: fifo %04x net %04x ethernet %04x media %04x\\n\",\n\t\t    inw(ioaddr+0x04), inw(ioaddr+0x06),\n\t\t    inw(ioaddr+0x08), inw(ioaddr+0x0a));\n\tEL3WINDOW(1);\n}\n\n \nstatic void tc574_wait_for_completion(struct net_device *dev, int cmd)\n{\n\tint i = 1500;\n\toutw(cmd, dev->base_addr + EL3_CMD);\n\twhile (--i > 0)\n\t\tif (!(inw(dev->base_addr + EL3_STATUS) & 0x1000)) break;\n\tif (i == 0)\n\t\tnetdev_notice(dev, \"command 0x%04x did not complete!\\n\", cmd);\n}\n\n \nstatic unsigned short read_eeprom(unsigned int ioaddr, int index)\n{\n\tint timer;\n\toutw(EEPROM_Read + index, ioaddr + Wn0EepromCmd);\n\t \n\tfor (timer = 1620; timer >= 0; timer--) {\n\t\tif ((inw(ioaddr + Wn0EepromCmd) & 0x8000) == 0)\n\t\t\tbreak;\n\t}\n\treturn inw(ioaddr + Wn0EepromData);\n}\n\n \n\n#define MDIO_SHIFT_CLK\t0x01\n#define MDIO_DIR_WRITE\t0x04\n#define MDIO_DATA_WRITE0 (0x00 | MDIO_DIR_WRITE)\n#define MDIO_DATA_WRITE1 (0x02 | MDIO_DIR_WRITE)\n#define MDIO_DATA_READ\t0x02\n#define MDIO_ENB_IN\t\t0x00\n\n \nstatic void mdio_sync(unsigned int ioaddr, int bits)\n{\n\tunsigned int mdio_addr = ioaddr + Wn4_PhysicalMgmt;\n\n\t \n\twhile (-- bits >= 0) {\n\t\toutw(MDIO_DATA_WRITE1, mdio_addr);\n\t\toutw(MDIO_DATA_WRITE1 | MDIO_SHIFT_CLK, mdio_addr);\n\t}\n}\n\nstatic int mdio_read(unsigned int ioaddr, int phy_id, int location)\n{\n\tint i;\n\tint read_cmd = (0xf6 << 10) | (phy_id << 5) | location;\n\tunsigned int retval = 0;\n\tunsigned int mdio_addr = ioaddr + Wn4_PhysicalMgmt;\n\n\tif (mii_preamble_required)\n\t\tmdio_sync(ioaddr, 32);\n\n\t \n\tfor (i = 14; i >= 0; i--) {\n\t\tint dataval = (read_cmd&(1<<i)) ? MDIO_DATA_WRITE1 : MDIO_DATA_WRITE0;\n\t\toutw(dataval, mdio_addr);\n\t\toutw(dataval | MDIO_SHIFT_CLK, mdio_addr);\n\t}\n\t \n\tfor (i = 19; i > 0; i--) {\n\t\toutw(MDIO_ENB_IN, mdio_addr);\n\t\tretval = (retval << 1) | ((inw(mdio_addr) & MDIO_DATA_READ) ? 1 : 0);\n\t\toutw(MDIO_ENB_IN | MDIO_SHIFT_CLK, mdio_addr);\n\t}\n\treturn (retval>>1) & 0xffff;\n}\n\nstatic void mdio_write(unsigned int ioaddr, int phy_id, int location, int value)\n{\n\tint write_cmd = 0x50020000 | (phy_id << 23) | (location << 18) | value;\n\tunsigned int mdio_addr = ioaddr + Wn4_PhysicalMgmt;\n\tint i;\n\n\tif (mii_preamble_required)\n\t\tmdio_sync(ioaddr, 32);\n\n\t \n\tfor (i = 31; i >= 0; i--) {\n\t\tint dataval = (write_cmd&(1<<i)) ? MDIO_DATA_WRITE1 : MDIO_DATA_WRITE0;\n\t\toutw(dataval, mdio_addr);\n\t\toutw(dataval | MDIO_SHIFT_CLK, mdio_addr);\n\t}\n\t \n\tfor (i = 1; i >= 0; i--) {\n\t\toutw(MDIO_ENB_IN, mdio_addr);\n\t\toutw(MDIO_ENB_IN | MDIO_SHIFT_CLK, mdio_addr);\n\t}\n}\n\n \nstatic void tc574_reset(struct net_device *dev)\n{\n\tstruct el3_private *lp = netdev_priv(dev);\n\tint i;\n\tunsigned int ioaddr = dev->base_addr;\n\tunsigned long flags;\n\n\ttc574_wait_for_completion(dev, TotalReset|0x10);\n\n\tspin_lock_irqsave(&lp->window_lock, flags);\n\t \n\toutw(0, ioaddr + RunnerWrCtrl);\n\toutw(0, ioaddr + RunnerRdCtrl);\n\n\t \n\tEL3WINDOW(2);\n\tfor (i = 0; i < 6; i++)\n\t\toutb(dev->dev_addr[i], ioaddr + i);\n\tfor (; i < 12; i+=2)\n\t\toutw(0, ioaddr + i);\n\n\t \n\tEL3WINDOW(3);\n\toutb((dev->mtu > 1500 ? 0x40 : 0), ioaddr + Wn3_MAC_Ctrl);\n\toutl((lp->autoselect ? 0x01000000 : 0) | 0x0062001b,\n\t\t ioaddr + Wn3_Config);\n\t \n\toutw(0x8040, ioaddr + Wn3_Options);\n\tmdelay(1);\n\toutw(0xc040, ioaddr + Wn3_Options);\n\tEL3WINDOW(1);\n\tspin_unlock_irqrestore(&lp->window_lock, flags);\n\t\n\ttc574_wait_for_completion(dev, TxReset);\n\ttc574_wait_for_completion(dev, RxReset);\n\tmdelay(1);\n\tspin_lock_irqsave(&lp->window_lock, flags);\n\tEL3WINDOW(3);\n\toutw(0x8040, ioaddr + Wn3_Options);\n\n\t \n\toutw(StatsDisable, ioaddr + EL3_CMD);\n\tEL3WINDOW(6);\n\tfor (i = 0; i < 10; i++)\n\t\tinb(ioaddr + i);\n\tinw(ioaddr + 10);\n\tinw(ioaddr + 12);\n\tEL3WINDOW(4);\n\tinb(ioaddr + 12);\n\tinb(ioaddr + 13);\n\n\t \n\toutw(0x0040, ioaddr + Wn4_NetDiag);\n\t\n\tEL3WINDOW(1);\n\tspin_unlock_irqrestore(&lp->window_lock, flags);\n\t\n\t \n\tmdio_sync(ioaddr, 32);\n\tmdio_write(ioaddr, lp->phys, 4, lp->advertising);\n\tif (!auto_polarity) {\n\t\t \n\t\ti = mdio_read(ioaddr, lp->phys, 16) | 0x20;\n\t\tmdio_write(ioaddr, lp->phys, 16, i);\n\t}\n\n\tspin_lock_irqsave(&lp->window_lock, flags);\n\t \n\tset_rx_mode(dev);\n\tspin_unlock_irqrestore(&lp->window_lock, flags);\n\toutw(StatsEnable, ioaddr + EL3_CMD);  \n\toutw(RxEnable, ioaddr + EL3_CMD);  \n\toutw(TxEnable, ioaddr + EL3_CMD);  \n\t \n\toutw(SetStatusEnb | 0xff, ioaddr + EL3_CMD);\n\t \n\toutw(AckIntr | IntLatch | TxAvailable | RxEarly | IntReq,\n\t\t ioaddr + EL3_CMD);\n\toutw(SetIntrEnb | IntLatch | TxAvailable | RxComplete | StatsFull\n\t\t | AdapterFailure | RxEarly, ioaddr + EL3_CMD);\n}\n\nstatic int el3_open(struct net_device *dev)\n{\n\tstruct el3_private *lp = netdev_priv(dev);\n\tstruct pcmcia_device *link = lp->p_dev;\n\n\tif (!pcmcia_dev_present(link))\n\t\treturn -ENODEV;\n\t\n\tlink->open++;\n\tnetif_start_queue(dev);\n\t\n\ttc574_reset(dev);\n\tlp->media.expires = jiffies + HZ;\n\tadd_timer(&lp->media);\n\t\n\tdev_dbg(&link->dev, \"%s: opened, status %4.4x.\\n\",\n\t\t  dev->name, inw(dev->base_addr + EL3_STATUS));\n\t\n\treturn 0;\n}\n\nstatic void el3_tx_timeout(struct net_device *dev, unsigned int txqueue)\n{\n\tunsigned int ioaddr = dev->base_addr;\n\t\n\tnetdev_notice(dev, \"Transmit timed out!\\n\");\n\tdump_status(dev);\n\tdev->stats.tx_errors++;\n\tnetif_trans_update(dev);  \n\t \n\ttc574_wait_for_completion(dev, TxReset);\n\toutw(TxEnable, ioaddr + EL3_CMD);\n\tnetif_wake_queue(dev);\n}\n\nstatic void pop_tx_status(struct net_device *dev)\n{\n\tunsigned int ioaddr = dev->base_addr;\n\tint i;\n    \n\t \n\tfor (i = 32; i > 0; i--) {\n\t\tu_char tx_status = inb(ioaddr + TxStatus);\n\t\tif (!(tx_status & 0x84))\n\t\t\tbreak;\n\t\t \n\t\tif (tx_status & 0x30)\n\t\t\ttc574_wait_for_completion(dev, TxReset);\n\t\tif (tx_status & 0x38) {\n\t\t\tpr_debug(\"%s: transmit error: status 0x%02x\\n\",\n\t\t\t\t  dev->name, tx_status);\n\t\t\toutw(TxEnable, ioaddr + EL3_CMD);\n\t\t\tdev->stats.tx_aborted_errors++;\n\t\t}\n\t\toutb(0x00, ioaddr + TxStatus);  \n\t}\n}\n\nstatic netdev_tx_t el3_start_xmit(struct sk_buff *skb,\n\t\t\t\t\tstruct net_device *dev)\n{\n\tunsigned int ioaddr = dev->base_addr;\n\tstruct el3_private *lp = netdev_priv(dev);\n\tunsigned long flags;\n\n\tpr_debug(\"%s: el3_start_xmit(length = %ld) called, \"\n\t\t  \"status %4.4x.\\n\", dev->name, (long)skb->len,\n\t\t  inw(ioaddr + EL3_STATUS));\n\n\tspin_lock_irqsave(&lp->window_lock, flags);\n\n\tdev->stats.tx_bytes += skb->len;\n\n\t \n\toutw(skb->len, ioaddr + TX_FIFO);\n\toutw(0, ioaddr + TX_FIFO);\n\t \n\toutsl(ioaddr + TX_FIFO, skb->data, (skb->len+3)>>2);\n\n\t \n\tif (inw(ioaddr + TxFree) <= 1536) {\n\t\tnetif_stop_queue(dev);\n\t\t \n\t\toutw(SetTxThreshold + (1536>>2), ioaddr + EL3_CMD);\n\t}\n\n\tpop_tx_status(dev);\n\tspin_unlock_irqrestore(&lp->window_lock, flags);\n\tdev_kfree_skb(skb);\n\treturn NETDEV_TX_OK;\n}\n\n \nstatic irqreturn_t el3_interrupt(int irq, void *dev_id)\n{\n\tstruct net_device *dev = (struct net_device *) dev_id;\n\tstruct el3_private *lp = netdev_priv(dev);\n\tunsigned int ioaddr;\n\tunsigned status;\n\tint work_budget = max_interrupt_work;\n\tint handled = 0;\n\n\tif (!netif_device_present(dev))\n\t\treturn IRQ_NONE;\n\tioaddr = dev->base_addr;\n\n\tpr_debug(\"%s: interrupt, status %4.4x.\\n\",\n\t\t  dev->name, inw(ioaddr + EL3_STATUS));\n\n\tspin_lock(&lp->window_lock);\n\t\n\twhile ((status = inw(ioaddr + EL3_STATUS)) &\n\t\t   (IntLatch | RxComplete | RxEarly | StatsFull)) {\n\t\tif (!netif_device_present(dev) ||\n\t\t\t((status & 0xe000) != 0x2000)) {\n\t\t\tpr_debug(\"%s: Interrupt from dead card\\n\", dev->name);\n\t\t\tbreak;\n\t\t}\n\n\t\thandled = 1;\n\n\t\tif (status & RxComplete)\n\t\t\twork_budget = el3_rx(dev, work_budget);\n\n\t\tif (status & TxAvailable) {\n\t\t\tpr_debug(\"  TX room bit was handled.\\n\");\n\t\t\t \n\t\t\toutw(AckIntr | TxAvailable, ioaddr + EL3_CMD);\n\t\t\tnetif_wake_queue(dev);\n\t\t}\n\n\t\tif (status & TxComplete)\n\t\t\tpop_tx_status(dev);\n\n\t\tif (status & (AdapterFailure | RxEarly | StatsFull)) {\n\t\t\t \n\t\t\tif (status & StatsFull)\n\t\t\t\tupdate_stats(dev);\n\t\t\tif (status & RxEarly) {\n\t\t\t\twork_budget = el3_rx(dev, work_budget);\n\t\t\t\toutw(AckIntr | RxEarly, ioaddr + EL3_CMD);\n\t\t\t}\n\t\t\tif (status & AdapterFailure) {\n\t\t\t\tu16 fifo_diag;\n\t\t\t\tEL3WINDOW(4);\n\t\t\t\tfifo_diag = inw(ioaddr + Wn4_FIFODiag);\n\t\t\t\tEL3WINDOW(1);\n\t\t\t\tnetdev_notice(dev, \"adapter failure, FIFO diagnostic register %04x\\n\",\n\t\t\t\t\t      fifo_diag);\n\t\t\t\tif (fifo_diag & 0x0400) {\n\t\t\t\t\t \n\t\t\t\t\ttc574_wait_for_completion(dev, TxReset);\n\t\t\t\t\toutw(TxEnable, ioaddr + EL3_CMD);\n\t\t\t\t}\n\t\t\t\tif (fifo_diag & 0x2000) {\n\t\t\t\t\t \n\t\t\t\t\ttc574_wait_for_completion(dev, RxReset);\n\t\t\t\t\tset_rx_mode(dev);\n\t\t\t\t\toutw(RxEnable, ioaddr + EL3_CMD);\n\t\t\t\t}\n\t\t\t\toutw(AckIntr | AdapterFailure, ioaddr + EL3_CMD);\n\t\t\t}\n\t\t}\n\n\t\tif (--work_budget < 0) {\n\t\t\tpr_debug(\"%s: Too much work in interrupt, \"\n\t\t\t\t  \"status %4.4x.\\n\", dev->name, status);\n\t\t\t \n\t\t\toutw(AckIntr | 0xFF, ioaddr + EL3_CMD);\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\toutw(AckIntr | IntReq | IntLatch, ioaddr + EL3_CMD);\n\t}\n\n\tpr_debug(\"%s: exiting interrupt, status %4.4x.\\n\",\n\t\t  dev->name, inw(ioaddr + EL3_STATUS));\n\t\t  \n\tspin_unlock(&lp->window_lock);\n\treturn IRQ_RETVAL(handled);\n}\n\n \nstatic void media_check(struct timer_list *t)\n{\n\tstruct el3_private *lp = from_timer(lp, t, media);\n\tstruct net_device *dev = lp->p_dev->priv;\n\tunsigned int ioaddr = dev->base_addr;\n\tunsigned long flags;\n\tunsigned short   media, partner;\n\n\tif (!netif_device_present(dev))\n\t\tgoto reschedule;\n\t\n\t \n\tif ((inw(ioaddr + EL3_STATUS) & IntLatch) && (inb(ioaddr + Timer) == 0xff)) {\n\t\tif (!lp->fast_poll)\n\t\t\tnetdev_info(dev, \"interrupt(s) dropped!\\n\");\n\n\t\tlocal_irq_save(flags);\n\t\tel3_interrupt(dev->irq, dev);\n\t\tlocal_irq_restore(flags);\n\n\t\tlp->fast_poll = HZ;\n\t}\n\tif (lp->fast_poll) {\n\t\tlp->fast_poll--;\n\t\tlp->media.expires = jiffies + 2*HZ/100;\n\t\tadd_timer(&lp->media);\n\t\treturn;\n\t}\n\n\tspin_lock_irqsave(&lp->window_lock, flags);\n\tEL3WINDOW(4);\n\tmedia = mdio_read(ioaddr, lp->phys, 1);\n\tpartner = mdio_read(ioaddr, lp->phys, 5);\n\tEL3WINDOW(1);\n\t\n\tif (media != lp->media_status) {\n\t\tif ((media ^ lp->media_status) & 0x0004)\n\t\t\tnetdev_info(dev, \"%s link beat\\n\",\n\t\t\t\t    (lp->media_status & 0x0004) ? \"lost\" : \"found\");\n\t\tif ((media ^ lp->media_status) & 0x0020) {\n\t\t\tlp->partner = 0;\n\t\t\tif (lp->media_status & 0x0020) {\n\t\t\t\tnetdev_info(dev, \"autonegotiation restarted\\n\");\n\t\t\t} else if (partner) {\n\t\t\t\tpartner &= lp->advertising;\n\t\t\t\tlp->partner = partner;\n\t\t\t\tnetdev_info(dev, \"autonegotiation complete: \"\n\t\t\t\t\t    \"%dbaseT-%cD selected\\n\",\n\t\t\t\t\t    (partner & 0x0180) ? 100 : 10,\n\t\t\t\t\t    (partner & 0x0140) ? 'F' : 'H');\n\t\t\t} else {\n\t\t\t\tnetdev_info(dev, \"link partner did not autonegotiate\\n\");\n\t\t\t}\n\n\t\t\tEL3WINDOW(3);\n\t\t\toutb((partner & 0x0140 ? 0x20 : 0) |\n\t\t\t\t (dev->mtu > 1500 ? 0x40 : 0), ioaddr + Wn3_MAC_Ctrl);\n\t\t\tEL3WINDOW(1);\n\n\t\t}\n\t\tif (media & 0x0010)\n\t\t\tnetdev_info(dev, \"remote fault detected\\n\");\n\t\tif (media & 0x0002)\n\t\t\tnetdev_info(dev, \"jabber detected\\n\");\n\t\tlp->media_status = media;\n\t}\n\tspin_unlock_irqrestore(&lp->window_lock, flags);\n\nreschedule:\n\tlp->media.expires = jiffies + HZ;\n\tadd_timer(&lp->media);\n}\n\nstatic struct net_device_stats *el3_get_stats(struct net_device *dev)\n{\n\tstruct el3_private *lp = netdev_priv(dev);\n\n\tif (netif_device_present(dev)) {\n\t\tunsigned long flags;\n\t\tspin_lock_irqsave(&lp->window_lock, flags);\n\t\tupdate_stats(dev);\n\t\tspin_unlock_irqrestore(&lp->window_lock, flags);\n\t}\n\treturn &dev->stats;\n}\n\n \nstatic void update_stats(struct net_device *dev)\n{\n\tunsigned int ioaddr = dev->base_addr;\n\tu8 up;\n\n\tpr_debug(\"%s: updating the statistics.\\n\", dev->name);\n\n\tif (inw(ioaddr+EL3_STATUS) == 0xffff)  \n\t\treturn;\n\t\t\n\t \n\t \n\tEL3WINDOW(6);\n\tdev->stats.tx_carrier_errors \t\t+= inb(ioaddr + 0);\n\tdev->stats.tx_heartbeat_errors\t\t+= inb(ioaddr + 1);\n\t \t   \tinb(ioaddr + 2);\n\tdev->stats.collisions\t\t\t+= inb(ioaddr + 3);\n\tdev->stats.tx_window_errors\t\t+= inb(ioaddr + 4);\n\tdev->stats.rx_fifo_errors\t\t+= inb(ioaddr + 5);\n\tdev->stats.tx_packets\t\t\t+= inb(ioaddr + 6);\n\tup\t\t \t\t\t = inb(ioaddr + 9);\n\tdev->stats.tx_packets\t\t\t+= (up&0x30) << 4;\n\t \t\t\t   inb(ioaddr + 7);\n\t \t\t\t   inb(ioaddr + 8);\n\t \t\t\t\t   inw(ioaddr + 10);\n\t \t\t\t\t   inw(ioaddr + 12);\n\n\tEL3WINDOW(4);\n\t \t\t\t\t   inb(ioaddr + 12);\n\tup\t\t\t\t\t = inb(ioaddr + 13);\n\n\tEL3WINDOW(1);\n}\n\nstatic int el3_rx(struct net_device *dev, int worklimit)\n{\n\tunsigned int ioaddr = dev->base_addr;\n\tshort rx_status;\n\t\n\tpr_debug(\"%s: in rx_packet(), status %4.4x, rx_status %4.4x.\\n\",\n\t\t  dev->name, inw(ioaddr+EL3_STATUS), inw(ioaddr+RxStatus));\n\twhile (!((rx_status = inw(ioaddr + RxStatus)) & 0x8000) &&\n\t\t\tworklimit > 0) {\n\t\tworklimit--;\n\t\tif (rx_status & 0x4000) {  \n\t\t\tshort error = rx_status & 0x3800;\n\t\t\tdev->stats.rx_errors++;\n\t\t\tswitch (error) {\n\t\t\tcase 0x0000:\tdev->stats.rx_over_errors++; break;\n\t\t\tcase 0x0800:\tdev->stats.rx_length_errors++; break;\n\t\t\tcase 0x1000:\tdev->stats.rx_frame_errors++; break;\n\t\t\tcase 0x1800:\tdev->stats.rx_length_errors++; break;\n\t\t\tcase 0x2000:\tdev->stats.rx_frame_errors++; break;\n\t\t\tcase 0x2800:\tdev->stats.rx_crc_errors++; break;\n\t\t\t}\n\t\t} else {\n\t\t\tshort pkt_len = rx_status & 0x7ff;\n\t\t\tstruct sk_buff *skb;\n\n\t\t\tskb = netdev_alloc_skb(dev, pkt_len + 5);\n\n\t\t\tpr_debug(\"  Receiving packet size %d status %4.4x.\\n\",\n\t\t\t\t  pkt_len, rx_status);\n\t\t\tif (skb != NULL) {\n\t\t\t\tskb_reserve(skb, 2);\n\t\t\t\tinsl(ioaddr+RX_FIFO, skb_put(skb, pkt_len),\n\t\t\t\t\t\t((pkt_len+3)>>2));\n\t\t\t\tskb->protocol = eth_type_trans(skb, dev);\n\t\t\t\tnetif_rx(skb);\n\t\t\t\tdev->stats.rx_packets++;\n\t\t\t\tdev->stats.rx_bytes += pkt_len;\n\t\t\t} else {\n\t\t\t\tpr_debug(\"%s: couldn't allocate a sk_buff of\"\n\t\t\t\t\t  \" size %d.\\n\", dev->name, pkt_len);\n\t\t\t\tdev->stats.rx_dropped++;\n\t\t\t}\n\t\t}\n\t\ttc574_wait_for_completion(dev, RxDiscard);\n\t}\n\n\treturn worklimit;\n}\n\n \nstatic int el3_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)\n{\n\tstruct el3_private *lp = netdev_priv(dev);\n\tunsigned int ioaddr = dev->base_addr;\n\tstruct mii_ioctl_data *data = if_mii(rq);\n\tint phy = lp->phys & 0x1f;\n\n\tpr_debug(\"%s: In ioct(%-.6s, %#4.4x) %4.4x %4.4x %4.4x %4.4x.\\n\",\n\t\t  dev->name, rq->ifr_ifrn.ifrn_name, cmd,\n\t\t  data->phy_id, data->reg_num, data->val_in, data->val_out);\n\n\tswitch(cmd) {\n\tcase SIOCGMIIPHY:\t\t \n\t\tdata->phy_id = phy;\n\t\tfallthrough;\n\tcase SIOCGMIIREG:\t\t \n\t\t{\n\t\t\tint saved_window;\n\t\t\tunsigned long flags;\n\n\t\t\tspin_lock_irqsave(&lp->window_lock, flags);\n\t\t\tsaved_window = inw(ioaddr + EL3_CMD) >> 13;\n\t\t\tEL3WINDOW(4);\n\t\t\tdata->val_out = mdio_read(ioaddr, data->phy_id & 0x1f,\n\t\t\t\t\t\t  data->reg_num & 0x1f);\n\t\t\tEL3WINDOW(saved_window);\n\t\t\tspin_unlock_irqrestore(&lp->window_lock, flags);\n\t\t\treturn 0;\n\t\t}\n\tcase SIOCSMIIREG:\t\t \n\t\t{\n\t\t\tint saved_window;\n                       unsigned long flags;\n\n\t\t\tspin_lock_irqsave(&lp->window_lock, flags);\n\t\t\tsaved_window = inw(ioaddr + EL3_CMD) >> 13;\n\t\t\tEL3WINDOW(4);\n\t\t\tmdio_write(ioaddr, data->phy_id & 0x1f,\n\t\t\t\t   data->reg_num & 0x1f, data->val_in);\n\t\t\tEL3WINDOW(saved_window);\n\t\t\tspin_unlock_irqrestore(&lp->window_lock, flags);\n\t\t\treturn 0;\n\t\t}\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\n \n\nstatic void set_rx_mode(struct net_device *dev)\n{\n\tunsigned int ioaddr = dev->base_addr;\n\n\tif (dev->flags & IFF_PROMISC)\n\t\toutw(SetRxFilter | RxStation | RxMulticast | RxBroadcast | RxProm,\n\t\t\t ioaddr + EL3_CMD);\n\telse if (!netdev_mc_empty(dev) || (dev->flags & IFF_ALLMULTI))\n\t\toutw(SetRxFilter|RxStation|RxMulticast|RxBroadcast, ioaddr + EL3_CMD);\n\telse\n\t\toutw(SetRxFilter | RxStation | RxBroadcast, ioaddr + EL3_CMD);\n}\n\nstatic void set_multicast_list(struct net_device *dev)\n{\n\tstruct el3_private *lp = netdev_priv(dev);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&lp->window_lock, flags);\n\tset_rx_mode(dev);\n\tspin_unlock_irqrestore(&lp->window_lock, flags);\n}\n\nstatic int el3_close(struct net_device *dev)\n{\n\tunsigned int ioaddr = dev->base_addr;\n\tstruct el3_private *lp = netdev_priv(dev);\n\tstruct pcmcia_device *link = lp->p_dev;\n\n\tdev_dbg(&link->dev, \"%s: shutting down ethercard.\\n\", dev->name);\n\t\n\tif (pcmcia_dev_present(link)) {\n\t\tunsigned long flags;\n\n\t\t \n\t\toutw(StatsDisable, ioaddr + EL3_CMD);\n\t\t\n\t\t \n\t\toutw(RxDisable, ioaddr + EL3_CMD);\n\t\toutw(TxDisable, ioaddr + EL3_CMD);\n\t\t\n\t\t \n\t\tEL3WINDOW(0);\n\t\tspin_lock_irqsave(&lp->window_lock, flags);\n\t\tupdate_stats(dev);\n\t\tspin_unlock_irqrestore(&lp->window_lock, flags);\n\n\t\t \n\t\toutw(SetIntrEnb | 0x0000, ioaddr + EL3_CMD);\n\t}\n\n\tlink->open--;\n\tnetif_stop_queue(dev);\n\tdel_timer_sync(&lp->media);\n\n\treturn 0;\n}\n\nstatic const struct pcmcia_device_id tc574_ids[] = {\n\tPCMCIA_DEVICE_MANF_CARD(0x0101, 0x0574),\n\tPCMCIA_MFC_DEVICE_CIS_MANF_CARD(0, 0x0101, 0x0556, \"cis/3CCFEM556.cis\"),\n\tPCMCIA_DEVICE_NULL,\n};\nMODULE_DEVICE_TABLE(pcmcia, tc574_ids);\n\nstatic struct pcmcia_driver tc574_driver = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"3c574_cs\",\n\t.probe\t\t= tc574_probe,\n\t.remove\t\t= tc574_detach,\n\t.id_table       = tc574_ids,\n\t.suspend\t= tc574_suspend,\n\t.resume\t\t= tc574_resume,\n};\nmodule_pcmcia_driver(tc574_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}