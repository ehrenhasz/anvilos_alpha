{
  "module_name": "3c59x.c",
  "hash_id": "4ba49b14c88b69b95af8f62eef8e87a87940198462b6ce5d9d449fe4dd168ee7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/3com/3c59x.c",
  "human_readable_source": " \n \n\n \n\n\n#define DRV_NAME\t\"3c59x\"\n\n\n\n \n \n#define TX_RING_SIZE\t16\n#define RX_RING_SIZE\t32\n#define PKT_BUF_SZ\t\t1536\t\t\t \n\n \n \n#ifndef __arm__\nstatic int rx_copybreak = 200;\n#else\n \nstatic int rx_copybreak = 1513;\n#endif\n \nstatic const int mtu = 1500;\n \nstatic int max_interrupt_work = 32;\n \nstatic int watchdog = 5000;\n\n \n#define tx_interrupt_mitigation 1\n\n \n#define vortex_debug debug\n#ifdef VORTEX_DEBUG\nstatic int vortex_debug = VORTEX_DEBUG;\n#else\nstatic int vortex_debug = 1;\n#endif\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/timer.h>\n#include <linux/errno.h>\n#include <linux/in.h>\n#include <linux/ioport.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/mii.h>\n#include <linux/init.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/skbuff.h>\n#include <linux/ethtool.h>\n#include <linux/highmem.h>\n#include <linux/eisa.h>\n#include <linux/bitops.h>\n#include <linux/jiffies.h>\n#include <linux/gfp.h>\n#include <asm/irq.h>\t\t\t \n#include <asm/io.h>\n#include <linux/uaccess.h>\n\n \n\n#define RUN_AT(x) (jiffies + (x))\n\n#include <linux/delay.h>\n\n\nstatic const char version[] =\n\tDRV_NAME \": Donald Becker and others.\\n\";\n\nMODULE_AUTHOR(\"Donald Becker <becker@scyld.com>\");\nMODULE_DESCRIPTION(\"3Com 3c59x/3c9xx ethernet driver \");\nMODULE_LICENSE(\"GPL\");\n\n\n \n\n \n#define VORTEX_TOTAL_SIZE 0x20\n#define BOOMERANG_TOTAL_SIZE 0x40\n\n \nstatic char mii_preamble_required;\n\n#define PFX DRV_NAME \": \"\n\n\n\n \n\n \nenum pci_flags_bit {\n\tPCI_USES_MASTER=4,\n};\n\nenum {\tIS_VORTEX=1, IS_BOOMERANG=2, IS_CYCLONE=4, IS_TORNADO=8,\n\tEEPROM_8BIT=0x10,\t \n\tHAS_PWR_CTRL=0x20, HAS_MII=0x40, HAS_NWAY=0x80, HAS_CB_FNS=0x100,\n\tINVERT_MII_PWR=0x200, INVERT_LED_PWR=0x400, MAX_COLLISION_RESET=0x800,\n\tEEPROM_OFFSET=0x1000, HAS_HWCKSM=0x2000, WNO_XCVR_PWR=0x4000,\n\tEXTRA_PREAMBLE=0x8000, EEPROM_RESET=0x10000, };\n\nenum vortex_chips {\n\tCH_3C590 = 0,\n\tCH_3C592,\n\tCH_3C597,\n\tCH_3C595_1,\n\tCH_3C595_2,\n\n\tCH_3C595_3,\n\tCH_3C900_1,\n\tCH_3C900_2,\n\tCH_3C900_3,\n\tCH_3C900_4,\n\n\tCH_3C900_5,\n\tCH_3C900B_FL,\n\tCH_3C905_1,\n\tCH_3C905_2,\n\tCH_3C905B_TX,\n\tCH_3C905B_1,\n\n\tCH_3C905B_2,\n\tCH_3C905B_FX,\n\tCH_3C905C,\n\tCH_3C9202,\n\tCH_3C980,\n\tCH_3C9805,\n\n\tCH_3CSOHO100_TX,\n\tCH_3C555,\n\tCH_3C556,\n\tCH_3C556B,\n\tCH_3C575,\n\n\tCH_3C575_1,\n\tCH_3CCFE575,\n\tCH_3CCFE575CT,\n\tCH_3CCFE656,\n\tCH_3CCFEM656,\n\n\tCH_3CCFEM656_1,\n\tCH_3C450,\n\tCH_3C920,\n\tCH_3C982A,\n\tCH_3C982B,\n\n\tCH_905BT4,\n\tCH_920B_EMB_WNM,\n};\n\n\n \nstatic struct vortex_chip_info {\n\tconst char *name;\n\tint flags;\n\tint drv_flags;\n\tint io_size;\n} vortex_info_tbl[] = {\n\t{\"3c590 Vortex 10Mbps\",\n\t PCI_USES_MASTER, IS_VORTEX, 32, },\n\t{\"3c592 EISA 10Mbps Demon/Vortex\",\t\t\t\t\t \n\t PCI_USES_MASTER, IS_VORTEX, 32, },\n\t{\"3c597 EISA Fast Demon/Vortex\",\t\t\t\t\t \n\t PCI_USES_MASTER, IS_VORTEX, 32, },\n\t{\"3c595 Vortex 100baseTx\",\n\t PCI_USES_MASTER, IS_VORTEX, 32, },\n\t{\"3c595 Vortex 100baseT4\",\n\t PCI_USES_MASTER, IS_VORTEX, 32, },\n\n\t{\"3c595 Vortex 100base-MII\",\n\t PCI_USES_MASTER, IS_VORTEX, 32, },\n\t{\"3c900 Boomerang 10baseT\",\n\t PCI_USES_MASTER, IS_BOOMERANG|EEPROM_RESET, 64, },\n\t{\"3c900 Boomerang 10Mbps Combo\",\n\t PCI_USES_MASTER, IS_BOOMERANG|EEPROM_RESET, 64, },\n\t{\"3c900 Cyclone 10Mbps TPO\",\t\t\t\t\t\t \n\t PCI_USES_MASTER, IS_CYCLONE|HAS_HWCKSM, 128, },\n\t{\"3c900 Cyclone 10Mbps Combo\",\n\t PCI_USES_MASTER, IS_CYCLONE|HAS_HWCKSM, 128, },\n\n\t{\"3c900 Cyclone 10Mbps TPC\",\t\t\t\t\t\t \n\t PCI_USES_MASTER, IS_CYCLONE|HAS_HWCKSM, 128, },\n\t{\"3c900B-FL Cyclone 10base-FL\",\n\t PCI_USES_MASTER, IS_CYCLONE|HAS_HWCKSM, 128, },\n\t{\"3c905 Boomerang 100baseTx\",\n\t PCI_USES_MASTER, IS_BOOMERANG|HAS_MII|EEPROM_RESET, 64, },\n\t{\"3c905 Boomerang 100baseT4\",\n\t PCI_USES_MASTER, IS_BOOMERANG|HAS_MII|EEPROM_RESET, 64, },\n\t{\"3C905B-TX Fast Etherlink XL PCI\",\n\t PCI_USES_MASTER, IS_CYCLONE|HAS_NWAY|HAS_HWCKSM|EXTRA_PREAMBLE, 128, },\n\t{\"3c905B Cyclone 100baseTx\",\n\t PCI_USES_MASTER, IS_CYCLONE|HAS_NWAY|HAS_HWCKSM|EXTRA_PREAMBLE, 128, },\n\n\t{\"3c905B Cyclone 10/100/BNC\",\n\t PCI_USES_MASTER, IS_CYCLONE|HAS_NWAY|HAS_HWCKSM, 128, },\n\t{\"3c905B-FX Cyclone 100baseFx\",\n\t PCI_USES_MASTER, IS_CYCLONE|HAS_HWCKSM, 128, },\n\t{\"3c905C Tornado\",\n\tPCI_USES_MASTER, IS_TORNADO|HAS_NWAY|HAS_HWCKSM|EXTRA_PREAMBLE, 128, },\n\t{\"3c920B-EMB-WNM (ATI Radeon 9100 IGP)\",\n\t PCI_USES_MASTER, IS_TORNADO|HAS_MII|HAS_HWCKSM, 128, },\n\t{\"3c980 Cyclone\",\n\t PCI_USES_MASTER, IS_CYCLONE|HAS_HWCKSM|EXTRA_PREAMBLE, 128, },\n\n\t{\"3c980C Python-T\",\n\t PCI_USES_MASTER, IS_CYCLONE|HAS_NWAY|HAS_HWCKSM, 128, },\n\t{\"3cSOHO100-TX Hurricane\",\n\t PCI_USES_MASTER, IS_CYCLONE|HAS_NWAY|HAS_HWCKSM|EXTRA_PREAMBLE, 128, },\n\t{\"3c555 Laptop Hurricane\",\n\t PCI_USES_MASTER, IS_CYCLONE|EEPROM_8BIT|HAS_HWCKSM, 128, },\n\t{\"3c556 Laptop Tornado\",\n\t PCI_USES_MASTER, IS_TORNADO|HAS_NWAY|EEPROM_8BIT|HAS_CB_FNS|INVERT_MII_PWR|\n\t\t\t\t\t\t\t\t\tHAS_HWCKSM, 128, },\n\t{\"3c556B Laptop Hurricane\",\n\t PCI_USES_MASTER, IS_TORNADO|HAS_NWAY|EEPROM_OFFSET|HAS_CB_FNS|INVERT_MII_PWR|\n\t                                WNO_XCVR_PWR|HAS_HWCKSM, 128, },\n\n\t{\"3c575 [Megahertz] 10/100 LAN \tCardBus\",\n\tPCI_USES_MASTER, IS_BOOMERANG|HAS_MII|EEPROM_8BIT, 128, },\n\t{\"3c575 Boomerang CardBus\",\n\t PCI_USES_MASTER, IS_BOOMERANG|HAS_MII|EEPROM_8BIT, 128, },\n\t{\"3CCFE575BT Cyclone CardBus\",\n\t PCI_USES_MASTER, IS_CYCLONE|HAS_NWAY|HAS_CB_FNS|EEPROM_8BIT|\n\t\t\t\t\t\t\t\t\tINVERT_LED_PWR|HAS_HWCKSM, 128, },\n\t{\"3CCFE575CT Tornado CardBus\",\n\t PCI_USES_MASTER, IS_TORNADO|HAS_NWAY|HAS_CB_FNS|EEPROM_8BIT|INVERT_MII_PWR|\n\t\t\t\t\t\t\t\t\tMAX_COLLISION_RESET|HAS_HWCKSM, 128, },\n\t{\"3CCFE656 Cyclone CardBus\",\n\t PCI_USES_MASTER, IS_CYCLONE|HAS_NWAY|HAS_CB_FNS|EEPROM_8BIT|INVERT_MII_PWR|\n\t\t\t\t\t\t\t\t\tINVERT_LED_PWR|HAS_HWCKSM, 128, },\n\n\t{\"3CCFEM656B Cyclone+Winmodem CardBus\",\n\t PCI_USES_MASTER, IS_CYCLONE|HAS_NWAY|HAS_CB_FNS|EEPROM_8BIT|INVERT_MII_PWR|\n\t\t\t\t\t\t\t\t\tINVERT_LED_PWR|HAS_HWCKSM, 128, },\n\t{\"3CXFEM656C Tornado+Winmodem CardBus\",\t\t\t \n\t PCI_USES_MASTER, IS_TORNADO|HAS_NWAY|HAS_CB_FNS|EEPROM_8BIT|INVERT_MII_PWR|\n\t\t\t\t\t\t\t\t\tMAX_COLLISION_RESET|HAS_HWCKSM, 128, },\n\t{\"3c450 HomePNA Tornado\",\t\t\t\t\t\t \n\t PCI_USES_MASTER, IS_TORNADO|HAS_NWAY|HAS_HWCKSM, 128, },\n\t{\"3c920 Tornado\",\n\t PCI_USES_MASTER, IS_TORNADO|HAS_NWAY|HAS_HWCKSM, 128, },\n\t{\"3c982 Hydra Dual Port A\",\n\t PCI_USES_MASTER, IS_TORNADO|HAS_HWCKSM|HAS_NWAY, 128, },\n\n\t{\"3c982 Hydra Dual Port B\",\n\t PCI_USES_MASTER, IS_TORNADO|HAS_HWCKSM|HAS_NWAY, 128, },\n\t{\"3c905B-T4\",\n\t PCI_USES_MASTER, IS_CYCLONE|HAS_NWAY|HAS_HWCKSM|EXTRA_PREAMBLE, 128, },\n\t{\"3c920B-EMB-WNM Tornado\",\n\t PCI_USES_MASTER, IS_TORNADO|HAS_NWAY|HAS_HWCKSM, 128, },\n\n\t{NULL,},  \n};\n\n\nstatic const struct pci_device_id vortex_pci_tbl[] = {\n\t{ 0x10B7, 0x5900, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CH_3C590 },\n\t{ 0x10B7, 0x5920, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CH_3C592 },\n\t{ 0x10B7, 0x5970, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CH_3C597 },\n\t{ 0x10B7, 0x5950, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CH_3C595_1 },\n\t{ 0x10B7, 0x5951, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CH_3C595_2 },\n\n\t{ 0x10B7, 0x5952, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CH_3C595_3 },\n\t{ 0x10B7, 0x9000, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CH_3C900_1 },\n\t{ 0x10B7, 0x9001, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CH_3C900_2 },\n\t{ 0x10B7, 0x9004, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CH_3C900_3 },\n\t{ 0x10B7, 0x9005, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CH_3C900_4 },\n\n\t{ 0x10B7, 0x9006, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CH_3C900_5 },\n\t{ 0x10B7, 0x900A, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CH_3C900B_FL },\n\t{ 0x10B7, 0x9050, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CH_3C905_1 },\n\t{ 0x10B7, 0x9051, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CH_3C905_2 },\n\t{ 0x10B7, 0x9054, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CH_3C905B_TX },\n\t{ 0x10B7, 0x9055, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CH_3C905B_1 },\n\n\t{ 0x10B7, 0x9058, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CH_3C905B_2 },\n\t{ 0x10B7, 0x905A, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CH_3C905B_FX },\n\t{ 0x10B7, 0x9200, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CH_3C905C },\n\t{ 0x10B7, 0x9202, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CH_3C9202 },\n\t{ 0x10B7, 0x9800, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CH_3C980 },\n\t{ 0x10B7, 0x9805, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CH_3C9805 },\n\n\t{ 0x10B7, 0x7646, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CH_3CSOHO100_TX },\n\t{ 0x10B7, 0x5055, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CH_3C555 },\n\t{ 0x10B7, 0x6055, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CH_3C556 },\n\t{ 0x10B7, 0x6056, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CH_3C556B },\n\t{ 0x10B7, 0x5b57, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CH_3C575 },\n\n\t{ 0x10B7, 0x5057, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CH_3C575_1 },\n\t{ 0x10B7, 0x5157, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CH_3CCFE575 },\n\t{ 0x10B7, 0x5257, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CH_3CCFE575CT },\n\t{ 0x10B7, 0x6560, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CH_3CCFE656 },\n\t{ 0x10B7, 0x6562, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CH_3CCFEM656 },\n\n\t{ 0x10B7, 0x6564, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CH_3CCFEM656_1 },\n\t{ 0x10B7, 0x4500, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CH_3C450 },\n\t{ 0x10B7, 0x9201, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CH_3C920 },\n\t{ 0x10B7, 0x1201, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CH_3C982A },\n\t{ 0x10B7, 0x1202, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CH_3C982B },\n\n\t{ 0x10B7, 0x9056, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CH_905BT4 },\n\t{ 0x10B7, 0x9210, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CH_920B_EMB_WNM },\n\n\t{0,}\t\t\t\t\t\t \n};\nMODULE_DEVICE_TABLE(pci, vortex_pci_tbl);\n\n\n \n#define EL3_CMD 0x0e\n#define EL3_STATUS 0x0e\n\n \n\nenum vortex_cmd {\n\tTotalReset = 0<<11, SelectWindow = 1<<11, StartCoax = 2<<11,\n\tRxDisable = 3<<11, RxEnable = 4<<11, RxReset = 5<<11,\n\tUpStall = 6<<11, UpUnstall = (6<<11)+1,\n\tDownStall = (6<<11)+2, DownUnstall = (6<<11)+3,\n\tRxDiscard = 8<<11, TxEnable = 9<<11, TxDisable = 10<<11, TxReset = 11<<11,\n\tFakeIntr = 12<<11, AckIntr = 13<<11, SetIntrEnb = 14<<11,\n\tSetStatusEnb = 15<<11, SetRxFilter = 16<<11, SetRxThreshold = 17<<11,\n\tSetTxThreshold = 18<<11, SetTxStart = 19<<11,\n\tStartDMAUp = 20<<11, StartDMADown = (20<<11)+1, StatsEnable = 21<<11,\n\tStatsDisable = 22<<11, StopCoax = 23<<11, SetFilterBit = 25<<11,};\n\n \nenum RxFilter {\n\tRxStation = 1, RxMulticast = 2, RxBroadcast = 4, RxProm = 8 };\n\n \nenum vortex_status {\n\tIntLatch = 0x0001, HostError = 0x0002, TxComplete = 0x0004,\n\tTxAvailable = 0x0008, RxComplete = 0x0010, RxEarly = 0x0020,\n\tIntReq = 0x0040, StatsFull = 0x0080,\n\tDMADone = 1<<8, DownComplete = 1<<9, UpComplete = 1<<10,\n\tDMAInProgress = 1<<11,\t\t\t \n\tCmdInProgress = 1<<12,\t\t\t \n};\n\n \nenum Window1 {\n\tTX_FIFO = 0x10,  RX_FIFO = 0x10,  RxErrors = 0x14,\n\tRxStatus = 0x18,  Timer=0x1A, TxStatus = 0x1B,\n\tTxFree = 0x1C,  \n};\nenum Window0 {\n\tWn0EepromCmd = 10,\t\t \n\tWn0EepromData = 12,\t\t \n\tIntrStatus=0x0E,\t\t \n};\nenum Win0_EEPROM_bits {\n\tEEPROM_Read = 0x80, EEPROM_WRITE = 0x40, EEPROM_ERASE = 0xC0,\n\tEEPROM_EWENB = 0x30,\t\t \n\tEEPROM_EWDIS = 0x00,\t\t \n};\n \nenum eeprom_offset {\n\tPhysAddr01=0, PhysAddr23=1, PhysAddr45=2, ModelID=3,\n\tEtherLink3ID=7, IFXcvrIO=8, IRQLine=9,\n\tNodeAddr01=10, NodeAddr23=11, NodeAddr45=12,\n\tDriverTune=13, Checksum=15};\n\nenum Window2 {\t\t\t \n\tWn2_ResetOptions=12,\n};\nenum Window3 {\t\t\t \n\tWn3_Config=0, Wn3_MaxPktSize=4, Wn3_MAC_Ctrl=6, Wn3_Options=8,\n};\n\n#define BFEXT(value, offset, bitcount)  \\\n    ((((unsigned long)(value)) >> (offset)) & ((1 << (bitcount)) - 1))\n\n#define BFINS(lhs, rhs, offset, bitcount)\t\t\t\t\t\\\n\t(((lhs) & ~((((1 << (bitcount)) - 1)) << (offset))) |\t\\\n\t(((rhs) & ((1 << (bitcount)) - 1)) << (offset)))\n\n#define RAM_SIZE(v)\t\tBFEXT(v, 0, 3)\n#define RAM_WIDTH(v)\tBFEXT(v, 3, 1)\n#define RAM_SPEED(v)\tBFEXT(v, 4, 2)\n#define ROM_SIZE(v)\t\tBFEXT(v, 6, 2)\n#define RAM_SPLIT(v)\tBFEXT(v, 16, 2)\n#define XCVR(v)\t\t\tBFEXT(v, 20, 4)\n#define AUTOSELECT(v)\tBFEXT(v, 24, 1)\n\nenum Window4 {\t\t \n\tWn4_FIFODiag = 4, Wn4_NetDiag = 6, Wn4_PhysicalMgmt=8, Wn4_Media = 10,\n};\nenum Win4_Media_bits {\n\tMedia_SQE = 0x0008,\t\t \n\tMedia_10TP = 0x00C0,\t \n\tMedia_Lnk = 0x0080,\t\t \n\tMedia_LnkBeat = 0x0800,\n};\nenum Window7 {\t\t\t\t\t \n\tWn7_MasterAddr = 0, Wn7_VlanEtherType=4, Wn7_MasterLen = 6,\n\tWn7_MasterStatus = 12,\n};\n \nenum MasterCtrl {\n\tPktStatus = 0x20, DownListPtr = 0x24, FragAddr = 0x28, FragLen = 0x2c,\n\tTxFreeThreshold = 0x2f, UpPktStatus = 0x30, UpListPtr = 0x38,\n};\n\n \n#define LAST_FRAG \t0x80000000\t\t\t \n#define DN_COMPLETE\t0x00010000\t\t\t \nstruct boom_rx_desc {\n\t__le32 next;\t\t\t\t\t \n\t__le32 status;\n\t__le32 addr;\t\t\t\t\t \n\t__le32 length;\t\t\t\t\t \n};\n \nenum rx_desc_status {\n\tRxDComplete=0x00008000, RxDError=0x4000,\n\t \n\tIPChksumErr=1<<25, TCPChksumErr=1<<26, UDPChksumErr=1<<27,\n\tIPChksumValid=1<<29, TCPChksumValid=1<<30, UDPChksumValid=1<<31,\n};\n\n#ifdef MAX_SKB_FRAGS\n#define DO_ZEROCOPY 1\n#else\n#define DO_ZEROCOPY 0\n#endif\n\nstruct boom_tx_desc {\n\t__le32 next;\t\t\t\t\t \n\t__le32 status;\t\t\t\t\t \n#if DO_ZEROCOPY\n\tstruct {\n\t\t__le32 addr;\n\t\t__le32 length;\n\t} frag[1+MAX_SKB_FRAGS];\n#else\n\t\t__le32 addr;\n\t\t__le32 length;\n#endif\n};\n\n \nenum tx_desc_status {\n\tCRCDisable=0x2000, TxDComplete=0x8000,\n\tAddIPChksum=0x02000000, AddTCPChksum=0x04000000, AddUDPChksum=0x08000000,\n\tTxIntrUploaded=0x80000000,\t\t \n};\n\n \nenum ChipCaps { CapBusMaster=0x20, CapPwrMgmt=0x2000 };\n\nstruct vortex_extra_stats {\n\tunsigned long tx_deferred;\n\tunsigned long tx_max_collisions;\n\tunsigned long tx_multiple_collisions;\n\tunsigned long tx_single_collisions;\n\tunsigned long rx_bad_ssd;\n};\n\nstruct vortex_private {\n\t \n\tstruct boom_rx_desc* rx_ring;\n\tstruct boom_tx_desc* tx_ring;\n\tdma_addr_t rx_ring_dma;\n\tdma_addr_t tx_ring_dma;\n\t \n\tstruct sk_buff* rx_skbuff[RX_RING_SIZE];\n\tstruct sk_buff* tx_skbuff[TX_RING_SIZE];\n\tunsigned int cur_rx, cur_tx;\t\t \n\tunsigned int dirty_tx;\t \n\tstruct vortex_extra_stats xstats;\t \n\tstruct sk_buff *tx_skb;\t\t\t\t \n\tdma_addr_t tx_skb_dma;\t\t\t\t \n\n\t \n\tstruct device *gendev;\n\tvoid __iomem *ioaddr;\t\t\t \n\tvoid __iomem *cb_fn_base;\t\t \n\n\t \n\tint rx_nocopy, rx_copy, queued_packet, rx_csumhits;\n\tint card_idx;\n\n\t \n\tstruct timer_list timer;\t\t\t \n\tint options;\t\t\t\t\t\t \n\tunsigned int media_override:4, \t\t \n\t\tdefault_media:4,\t\t\t\t \n\t\tfull_duplex:1, autoselect:1,\n\t\tbus_master:1,\t\t\t\t\t \n\t\tfull_bus_master_tx:1, full_bus_master_rx:2,  \n\t\tflow_ctrl:1,\t\t\t\t\t \n\t\tpartner_flow_ctrl:1,\t\t\t \n\t\thas_nway:1,\n\t\tenable_wol:1,\t\t\t\t\t \n\t\tpm_state_valid:1,\t\t\t\t \n\t\topen:1,\n\t\tmedialock:1,\n\t\tlarge_frames:1,\t\t\t \n\t\thandling_irq:1;\t\t\t \n\t \n\tint drv_flags;\n\tu16 status_enable;\n\tu16 intr_enable;\n\tu16 available_media;\t\t\t\t \n\tu16 capabilities, info1, info2;\t\t \n\tu16 advertising;\t\t\t\t\t \n\tunsigned char phys[2];\t\t\t\t \n\tu16 deferred;\t\t\t\t\t\t \n\tu16 io_size;\t\t\t\t\t\t \n\n\t \n\tspinlock_t lock;\n\n\tspinlock_t mii_lock;\t\t \n\tstruct mii_if_info mii;\t\t \n\tspinlock_t window_lock;\t\t \n\tint window;\t\t\t \n};\n\nstatic void window_set(struct vortex_private *vp, int window)\n{\n\tif (window != vp->window) {\n\t\tiowrite16(SelectWindow + window, vp->ioaddr + EL3_CMD);\n\t\tvp->window = window;\n\t}\n}\n\n#define DEFINE_WINDOW_IO(size)\t\t\t\t\t\t\\\nstatic u ## size\t\t\t\t\t\t\t\\\nwindow_read ## size(struct vortex_private *vp, int window, int addr)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tunsigned long flags;\t\t\t\t\t\t\\\n\tu ## size ret;\t\t\t\t\t\t\t\\\n\tspin_lock_irqsave(&vp->window_lock, flags);\t\t\t\\\n\twindow_set(vp, window);\t\t\t\t\t\t\\\n\tret = ioread ## size(vp->ioaddr + addr);\t\t\t\\\n\tspin_unlock_irqrestore(&vp->window_lock, flags);\t\t\\\n\treturn ret;\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic void\t\t\t\t\t\t\t\t\\\nwindow_write ## size(struct vortex_private *vp, u ## size value,\t\\\n\t\t     int window, int addr)\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tunsigned long flags;\t\t\t\t\t\t\\\n\tspin_lock_irqsave(&vp->window_lock, flags);\t\t\t\\\n\twindow_set(vp, window);\t\t\t\t\t\t\\\n\tiowrite ## size(value, vp->ioaddr + addr);\t\t\t\\\n\tspin_unlock_irqrestore(&vp->window_lock, flags);\t\t\\\n}\nDEFINE_WINDOW_IO(8)\nDEFINE_WINDOW_IO(16)\nDEFINE_WINDOW_IO(32)\n\n#ifdef CONFIG_PCI\n#define DEVICE_PCI(dev) ((dev_is_pci(dev)) ? to_pci_dev((dev)) : NULL)\n#else\n#define DEVICE_PCI(dev) NULL\n#endif\n\n#define VORTEX_PCI(vp)\t\t\t\t\t\t\t\\\n\t((struct pci_dev *) (((vp)->gendev) ? DEVICE_PCI((vp)->gendev) : NULL))\n\n#ifdef CONFIG_EISA\n#define DEVICE_EISA(dev) (((dev)->bus == &eisa_bus_type) ? to_eisa_device((dev)) : NULL)\n#else\n#define DEVICE_EISA(dev) NULL\n#endif\n\n#define VORTEX_EISA(vp)\t\t\t\t\t\t\t\\\n\t((struct eisa_device *) (((vp)->gendev) ? DEVICE_EISA((vp)->gendev) : NULL))\n\n \nenum xcvr_types {\n\tXCVR_10baseT=0, XCVR_AUI, XCVR_10baseTOnly, XCVR_10base2, XCVR_100baseTx,\n\tXCVR_100baseFx, XCVR_MII=6, XCVR_NWAY=8, XCVR_ExtMII=9, XCVR_Default=10,\n};\n\nstatic const struct media_table {\n\tchar *name;\n\tunsigned int media_bits:16,\t\t \n\t\tmask:8,\t\t\t\t\t\t \n\t\tnext:8;\t\t\t\t\t\t \n\tint wait;\t\t\t\t\t\t \n} media_tbl[] = {\n  {\t\"10baseT\",   Media_10TP,0x08, XCVR_10base2, (14*HZ)/10},\n  { \"10Mbs AUI\", Media_SQE, 0x20, XCVR_Default, (1*HZ)/10},\n  { \"undefined\", 0,\t\t\t0x80, XCVR_10baseT, 10000},\n  { \"10base2\",   0,\t\t\t0x10, XCVR_AUI,\t\t(1*HZ)/10},\n  { \"100baseTX\", Media_Lnk, 0x02, XCVR_100baseFx, (14*HZ)/10},\n  { \"100baseFX\", Media_Lnk, 0x04, XCVR_MII,\t\t(14*HZ)/10},\n  { \"MII\",\t\t 0,\t\t\t0x41, XCVR_10baseT, 3*HZ },\n  { \"undefined\", 0,\t\t\t0x01, XCVR_10baseT, 10000},\n  { \"Autonegotiate\", 0,\t\t0x41, XCVR_10baseT, 3*HZ},\n  { \"MII-External\",\t 0,\t\t0x41, XCVR_10baseT, 3*HZ },\n  { \"Default\",\t 0,\t\t\t0xFF, XCVR_10baseT, 10000},\n};\n\nstatic struct {\n\tconst char str[ETH_GSTRING_LEN];\n} ethtool_stats_keys[] = {\n\t{ \"tx_deferred\" },\n\t{ \"tx_max_collisions\" },\n\t{ \"tx_multiple_collisions\" },\n\t{ \"tx_single_collisions\" },\n\t{ \"rx_bad_ssd\" },\n};\n\n \n#define VORTEX_NUM_STATS    5\n\nstatic int vortex_probe1(struct device *gendev, void __iomem *ioaddr, int irq,\n\t\t\t\t   int chip_idx, int card_idx);\nstatic int vortex_up(struct net_device *dev);\nstatic void vortex_down(struct net_device *dev, int final);\nstatic int vortex_open(struct net_device *dev);\nstatic void mdio_sync(struct vortex_private *vp, int bits);\nstatic int mdio_read(struct net_device *dev, int phy_id, int location);\nstatic void mdio_write(struct net_device *vp, int phy_id, int location, int value);\nstatic void vortex_timer(struct timer_list *t);\nstatic netdev_tx_t vortex_start_xmit(struct sk_buff *skb,\n\t\t\t\t     struct net_device *dev);\nstatic netdev_tx_t boomerang_start_xmit(struct sk_buff *skb,\n\t\t\t\t\tstruct net_device *dev);\nstatic int vortex_rx(struct net_device *dev);\nstatic int boomerang_rx(struct net_device *dev);\nstatic irqreturn_t vortex_boomerang_interrupt(int irq, void *dev_id);\nstatic irqreturn_t _vortex_interrupt(int irq, struct net_device *dev);\nstatic irqreturn_t _boomerang_interrupt(int irq, struct net_device *dev);\nstatic int vortex_close(struct net_device *dev);\nstatic void dump_tx_ring(struct net_device *dev);\nstatic void update_stats(void __iomem *ioaddr, struct net_device *dev);\nstatic struct net_device_stats *vortex_get_stats(struct net_device *dev);\nstatic void set_rx_mode(struct net_device *dev);\n#ifdef CONFIG_PCI\nstatic int vortex_ioctl(struct net_device *dev, struct ifreq *rq, int cmd);\n#endif\nstatic void vortex_tx_timeout(struct net_device *dev, unsigned int txqueue);\nstatic void acpi_set_WOL(struct net_device *dev);\nstatic const struct ethtool_ops vortex_ethtool_ops;\nstatic void set_8021q_mode(struct net_device *dev, int enable);\n\n \n \n#define MAX_UNITS 8\nstatic int options[MAX_UNITS] = { [0 ... MAX_UNITS-1] = -1 };\nstatic int full_duplex[MAX_UNITS] = {[0 ... MAX_UNITS-1] = -1 };\nstatic int hw_checksums[MAX_UNITS] = {[0 ... MAX_UNITS-1] = -1 };\nstatic int flow_ctrl[MAX_UNITS] = {[0 ... MAX_UNITS-1] = -1 };\nstatic int enable_wol[MAX_UNITS] = {[0 ... MAX_UNITS-1] = -1 };\nstatic int use_mmio[MAX_UNITS] = {[0 ... MAX_UNITS-1] = -1 };\nstatic int global_options = -1;\nstatic int global_full_duplex = -1;\nstatic int global_enable_wol = -1;\nstatic int global_use_mmio = -1;\n\n \nstatic int compaq_ioaddr, compaq_irq, compaq_device_id = 0x5900;\nstatic struct net_device *compaq_net_device;\n\nstatic int vortex_cards_found;\n\nmodule_param(debug, int, 0);\nmodule_param(global_options, int, 0);\nmodule_param_array(options, int, NULL, 0);\nmodule_param(global_full_duplex, int, 0);\nmodule_param_array(full_duplex, int, NULL, 0);\nmodule_param_array(hw_checksums, int, NULL, 0);\nmodule_param_array(flow_ctrl, int, NULL, 0);\nmodule_param(global_enable_wol, int, 0);\nmodule_param_array(enable_wol, int, NULL, 0);\nmodule_param(rx_copybreak, int, 0);\nmodule_param(max_interrupt_work, int, 0);\nmodule_param_hw(compaq_ioaddr, int, ioport, 0);\nmodule_param_hw(compaq_irq, int, irq, 0);\nmodule_param(compaq_device_id, int, 0);\nmodule_param(watchdog, int, 0);\nmodule_param(global_use_mmio, int, 0);\nmodule_param_array(use_mmio, int, NULL, 0);\nMODULE_PARM_DESC(debug, \"3c59x debug level (0-6)\");\nMODULE_PARM_DESC(options, \"3c59x: Bits 0-3: media type, bit 4: bus mastering, bit 9: full duplex\");\nMODULE_PARM_DESC(global_options, \"3c59x: same as options, but applies to all NICs if options is unset\");\nMODULE_PARM_DESC(full_duplex, \"3c59x full duplex setting(s) (1)\");\nMODULE_PARM_DESC(global_full_duplex, \"3c59x: same as full_duplex, but applies to all NICs if full_duplex is unset\");\nMODULE_PARM_DESC(hw_checksums, \"3c59x Hardware checksum checking by adapter(s) (0-1)\");\nMODULE_PARM_DESC(flow_ctrl, \"3c59x 802.3x flow control usage (PAUSE only) (0-1)\");\nMODULE_PARM_DESC(enable_wol, \"3c59x: Turn on Wake-on-LAN for adapter(s) (0-1)\");\nMODULE_PARM_DESC(global_enable_wol, \"3c59x: same as enable_wol, but applies to all NICs if enable_wol is unset\");\nMODULE_PARM_DESC(rx_copybreak, \"3c59x copy breakpoint for copy-only-tiny-frames\");\nMODULE_PARM_DESC(max_interrupt_work, \"3c59x maximum events handled per interrupt\");\nMODULE_PARM_DESC(compaq_ioaddr, \"3c59x PCI I/O base address (Compaq BIOS problem workaround)\");\nMODULE_PARM_DESC(compaq_irq, \"3c59x PCI IRQ number (Compaq BIOS problem workaround)\");\nMODULE_PARM_DESC(compaq_device_id, \"3c59x PCI device ID (Compaq BIOS problem workaround)\");\nMODULE_PARM_DESC(watchdog, \"3c59x transmit timeout in milliseconds\");\nMODULE_PARM_DESC(global_use_mmio, \"3c59x: same as use_mmio, but applies to all NICs if options is unset\");\nMODULE_PARM_DESC(use_mmio, \"3c59x: use memory-mapped PCI I/O resource (0-1)\");\n\n#ifdef CONFIG_NET_POLL_CONTROLLER\nstatic void poll_vortex(struct net_device *dev)\n{\n\tvortex_boomerang_interrupt(dev->irq, dev);\n}\n#endif\n\n#ifdef CONFIG_PM\n\nstatic int vortex_suspend(struct device *dev)\n{\n\tstruct net_device *ndev = dev_get_drvdata(dev);\n\n\tif (!ndev || !netif_running(ndev))\n\t\treturn 0;\n\n\tnetif_device_detach(ndev);\n\tvortex_down(ndev, 1);\n\n\treturn 0;\n}\n\nstatic int vortex_resume(struct device *dev)\n{\n\tstruct net_device *ndev = dev_get_drvdata(dev);\n\tint err;\n\n\tif (!ndev || !netif_running(ndev))\n\t\treturn 0;\n\n\terr = vortex_up(ndev);\n\tif (err)\n\t\treturn err;\n\n\tnetif_device_attach(ndev);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops vortex_pm_ops = {\n\t.suspend = vortex_suspend,\n\t.resume = vortex_resume,\n\t.freeze = vortex_suspend,\n\t.thaw = vortex_resume,\n\t.poweroff = vortex_suspend,\n\t.restore = vortex_resume,\n};\n\n#define VORTEX_PM_OPS (&vortex_pm_ops)\n\n#else  \n\n#define VORTEX_PM_OPS NULL\n\n#endif  \n\n#ifdef CONFIG_EISA\nstatic const struct eisa_device_id vortex_eisa_ids[] = {\n\t{ \"TCM5920\", CH_3C592 },\n\t{ \"TCM5970\", CH_3C597 },\n\t{ \"\" }\n};\nMODULE_DEVICE_TABLE(eisa, vortex_eisa_ids);\n\nstatic int vortex_eisa_probe(struct device *device)\n{\n\tvoid __iomem *ioaddr;\n\tstruct eisa_device *edev;\n\n\tedev = to_eisa_device(device);\n\n\tif (!request_region(edev->base_addr, VORTEX_TOTAL_SIZE, DRV_NAME))\n\t\treturn -EBUSY;\n\n\tioaddr = ioport_map(edev->base_addr, VORTEX_TOTAL_SIZE);\n\n\tif (vortex_probe1(device, ioaddr, ioread16(ioaddr + 0xC88) >> 12,\n\t\t\t\t\t  edev->id.driver_data, vortex_cards_found)) {\n\t\trelease_region(edev->base_addr, VORTEX_TOTAL_SIZE);\n\t\treturn -ENODEV;\n\t}\n\n\tvortex_cards_found++;\n\n\treturn 0;\n}\n\nstatic int vortex_eisa_remove(struct device *device)\n{\n\tstruct eisa_device *edev;\n\tstruct net_device *dev;\n\tstruct vortex_private *vp;\n\tvoid __iomem *ioaddr;\n\n\tedev = to_eisa_device(device);\n\tdev = eisa_get_drvdata(edev);\n\n\tif (!dev) {\n\t\tpr_err(\"vortex_eisa_remove called for Compaq device!\\n\");\n\t\tBUG();\n\t}\n\n\tvp = netdev_priv(dev);\n\tioaddr = vp->ioaddr;\n\n\tunregister_netdev(dev);\n\tiowrite16(TotalReset|0x14, ioaddr + EL3_CMD);\n\trelease_region(edev->base_addr, VORTEX_TOTAL_SIZE);\n\n\tfree_netdev(dev);\n\treturn 0;\n}\n\nstatic struct eisa_driver vortex_eisa_driver = {\n\t.id_table = vortex_eisa_ids,\n\t.driver   = {\n\t\t.name    = \"3c59x\",\n\t\t.probe   = vortex_eisa_probe,\n\t\t.remove  = vortex_eisa_remove\n\t}\n};\n\n#endif  \n\n \nstatic int __init vortex_eisa_init(void)\n{\n\tint eisa_found = 0;\n\tint orig_cards_found = vortex_cards_found;\n\n#ifdef CONFIG_EISA\n\tint err;\n\n\terr = eisa_driver_register (&vortex_eisa_driver);\n\tif (!err) {\n\t\t \n\t\teisa_found = 1;\n\t}\n#endif\n\n\t \n\tif (compaq_ioaddr) {\n\t\tvortex_probe1(NULL, ioport_map(compaq_ioaddr, VORTEX_TOTAL_SIZE),\n\t\t\t      compaq_irq, compaq_device_id, vortex_cards_found++);\n\t}\n\n\treturn vortex_cards_found - orig_cards_found + eisa_found;\n}\n\n \nstatic int vortex_init_one(struct pci_dev *pdev,\n\t\t\t   const struct pci_device_id *ent)\n{\n\tint rc, unit, pci_bar;\n\tstruct vortex_chip_info *vci;\n\tvoid __iomem *ioaddr;\n\n\t \n\trc = pci_enable_device(pdev);\n\tif (rc < 0)\n\t\tgoto out;\n\n\trc = pci_request_regions(pdev, DRV_NAME);\n\tif (rc < 0)\n\t\tgoto out_disable;\n\n\tunit = vortex_cards_found;\n\n\tif (global_use_mmio < 0 && (unit >= MAX_UNITS || use_mmio[unit] < 0)) {\n\t\t \n\t\tvci = &vortex_info_tbl[ent->driver_data];\n\t\tpci_bar = vci->drv_flags & (IS_CYCLONE | IS_TORNADO) ? 1 : 0;\n\t} else if (unit < MAX_UNITS && use_mmio[unit] >= 0)\n\t\tpci_bar = use_mmio[unit] ? 1 : 0;\n\telse\n\t\tpci_bar = global_use_mmio ? 1 : 0;\n\n\tioaddr = pci_iomap(pdev, pci_bar, 0);\n\tif (!ioaddr)  \n\t\tioaddr = pci_iomap(pdev, 0, 0);\n\tif (!ioaddr) {\n\t\trc = -ENOMEM;\n\t\tgoto out_release;\n\t}\n\n\trc = vortex_probe1(&pdev->dev, ioaddr, pdev->irq,\n\t\t\t   ent->driver_data, unit);\n\tif (rc < 0)\n\t\tgoto out_iounmap;\n\n\tvortex_cards_found++;\n\tgoto out;\n\nout_iounmap:\n\tpci_iounmap(pdev, ioaddr);\nout_release:\n\tpci_release_regions(pdev);\nout_disable:\n\tpci_disable_device(pdev);\nout:\n\treturn rc;\n}\n\nstatic const struct net_device_ops boomrang_netdev_ops = {\n\t.ndo_open\t\t= vortex_open,\n\t.ndo_stop\t\t= vortex_close,\n\t.ndo_start_xmit\t\t= boomerang_start_xmit,\n\t.ndo_tx_timeout\t\t= vortex_tx_timeout,\n\t.ndo_get_stats\t\t= vortex_get_stats,\n#ifdef CONFIG_PCI\n\t.ndo_eth_ioctl\t\t= vortex_ioctl,\n#endif\n\t.ndo_set_rx_mode\t= set_rx_mode,\n\t.ndo_set_mac_address \t= eth_mac_addr,\n\t.ndo_validate_addr\t= eth_validate_addr,\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\t.ndo_poll_controller\t= poll_vortex,\n#endif\n};\n\nstatic const struct net_device_ops vortex_netdev_ops = {\n\t.ndo_open\t\t= vortex_open,\n\t.ndo_stop\t\t= vortex_close,\n\t.ndo_start_xmit\t\t= vortex_start_xmit,\n\t.ndo_tx_timeout\t\t= vortex_tx_timeout,\n\t.ndo_get_stats\t\t= vortex_get_stats,\n#ifdef CONFIG_PCI\n\t.ndo_eth_ioctl\t\t= vortex_ioctl,\n#endif\n\t.ndo_set_rx_mode\t= set_rx_mode,\n\t.ndo_set_mac_address \t= eth_mac_addr,\n\t.ndo_validate_addr\t= eth_validate_addr,\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\t.ndo_poll_controller\t= poll_vortex,\n#endif\n};\n\n \nstatic int vortex_probe1(struct device *gendev, void __iomem *ioaddr, int irq,\n\t\t\t int chip_idx, int card_idx)\n{\n\tstruct vortex_private *vp;\n\tint option;\n\tunsigned int eeprom[0x40], checksum = 0;\t\t \n\t__be16 addr[ETH_ALEN / 2];\n\tint i, step;\n\tstruct net_device *dev;\n\tstatic int printed_version;\n\tint retval, print_info;\n\tstruct vortex_chip_info * const vci = &vortex_info_tbl[chip_idx];\n\tconst char *print_name = \"3c59x\";\n\tstruct pci_dev *pdev = NULL;\n\tstruct eisa_device *edev = NULL;\n\n\tif (!printed_version) {\n\t\tpr_info(\"%s\", version);\n\t\tprinted_version = 1;\n\t}\n\n\tif (gendev) {\n\t\tif ((pdev = DEVICE_PCI(gendev))) {\n\t\t\tprint_name = pci_name(pdev);\n\t\t}\n\n\t\tif ((edev = DEVICE_EISA(gendev))) {\n\t\t\tprint_name = dev_name(&edev->dev);\n\t\t}\n\t}\n\n\tdev = alloc_etherdev(sizeof(*vp));\n\tretval = -ENOMEM;\n\tif (!dev)\n\t\tgoto out;\n\n\tSET_NETDEV_DEV(dev, gendev);\n\tvp = netdev_priv(dev);\n\n\toption = global_options;\n\n\t \n\tif (dev->mem_start) {\n\t\t \n\t\toption = dev->mem_start;\n\t}\n\telse if (card_idx < MAX_UNITS) {\n\t\tif (options[card_idx] >= 0)\n\t\t\toption = options[card_idx];\n\t}\n\n\tif (option > 0) {\n\t\tif (option & 0x8000)\n\t\t\tvortex_debug = 7;\n\t\tif (option & 0x4000)\n\t\t\tvortex_debug = 2;\n\t\tif (option & 0x0400)\n\t\t\tvp->enable_wol = 1;\n\t}\n\n\tprint_info = (vortex_debug > 1);\n\tif (print_info)\n\t\tpr_info(\"See Documentation/networking/device_drivers/ethernet/3com/vortex.rst\\n\");\n\n\tpr_info(\"%s: 3Com %s %s at %p.\\n\",\n\t       print_name,\n\t       pdev ? \"PCI\" : \"EISA\",\n\t       vci->name,\n\t       ioaddr);\n\n\tdev->base_addr = (unsigned long)ioaddr;\n\tdev->irq = irq;\n\tdev->mtu = mtu;\n\tvp->ioaddr = ioaddr;\n\tvp->large_frames = mtu > 1500;\n\tvp->drv_flags = vci->drv_flags;\n\tvp->has_nway = (vci->drv_flags & HAS_NWAY) ? 1 : 0;\n\tvp->io_size = vci->io_size;\n\tvp->card_idx = card_idx;\n\tvp->window = -1;\n\n\t \n\tif (gendev == NULL) {\n\t\tcompaq_net_device = dev;\n\t}\n\n\t \n\tif (pdev) {\n\t\t \n\t\tif (vci->flags & PCI_USES_MASTER)\n\t\t\tpci_set_master(pdev);\n\n\t\tif (vci->drv_flags & IS_VORTEX) {\n\t\t\tu8 pci_latency;\n\t\t\tu8 new_latency = 248;\n\n\t\t\t \n\t\t\tpci_read_config_byte(pdev, PCI_LATENCY_TIMER, &pci_latency);\n\t\t\tif (pci_latency < new_latency) {\n\t\t\t\tpr_info(\"%s: Overriding PCI latency timer (CFLT) setting of %d, new value is %d.\\n\",\n\t\t\t\t\tprint_name, pci_latency, new_latency);\n\t\t\t\tpci_write_config_byte(pdev, PCI_LATENCY_TIMER, new_latency);\n\t\t\t}\n\t\t}\n\t}\n\n\tspin_lock_init(&vp->lock);\n\tspin_lock_init(&vp->mii_lock);\n\tspin_lock_init(&vp->window_lock);\n\tvp->gendev = gendev;\n\tvp->mii.dev = dev;\n\tvp->mii.mdio_read = mdio_read;\n\tvp->mii.mdio_write = mdio_write;\n\tvp->mii.phy_id_mask = 0x1f;\n\tvp->mii.reg_num_mask = 0x1f;\n\n\t \n\tvp->rx_ring = dma_alloc_coherent(gendev, sizeof(struct boom_rx_desc) * RX_RING_SIZE\n\t\t\t\t\t   + sizeof(struct boom_tx_desc) * TX_RING_SIZE,\n\t\t\t\t\t   &vp->rx_ring_dma, GFP_KERNEL);\n\tretval = -ENOMEM;\n\tif (!vp->rx_ring)\n\t\tgoto free_device;\n\n\tvp->tx_ring = (struct boom_tx_desc *)(vp->rx_ring + RX_RING_SIZE);\n\tvp->tx_ring_dma = vp->rx_ring_dma + sizeof(struct boom_rx_desc) * RX_RING_SIZE;\n\n\t \n\tif (pdev)\n\t\tpci_set_drvdata(pdev, dev);\n\tif (edev)\n\t\teisa_set_drvdata(edev, dev);\n\n\tvp->media_override = 7;\n\tif (option >= 0) {\n\t\tvp->media_override = ((option & 7) == 2)  ?  0  :  option & 15;\n\t\tif (vp->media_override != 7)\n\t\t\tvp->medialock = 1;\n\t\tvp->full_duplex = (option & 0x200) ? 1 : 0;\n\t\tvp->bus_master = (option & 16) ? 1 : 0;\n\t}\n\n\tif (global_full_duplex > 0)\n\t\tvp->full_duplex = 1;\n\tif (global_enable_wol > 0)\n\t\tvp->enable_wol = 1;\n\n\tif (card_idx < MAX_UNITS) {\n\t\tif (full_duplex[card_idx] > 0)\n\t\t\tvp->full_duplex = 1;\n\t\tif (flow_ctrl[card_idx] > 0)\n\t\t\tvp->flow_ctrl = 1;\n\t\tif (enable_wol[card_idx] > 0)\n\t\t\tvp->enable_wol = 1;\n\t}\n\n\tvp->mii.force_media = vp->full_duplex;\n\tvp->options = option;\n\t \n\t{\n\t\tint base;\n\n\t\tif (vci->drv_flags & EEPROM_8BIT)\n\t\t\tbase = 0x230;\n\t\telse if (vci->drv_flags & EEPROM_OFFSET)\n\t\t\tbase = EEPROM_Read + 0x30;\n\t\telse\n\t\t\tbase = EEPROM_Read;\n\n\t\tfor (i = 0; i < 0x40; i++) {\n\t\t\tint timer;\n\t\t\twindow_write16(vp, base + i, 0, Wn0EepromCmd);\n\t\t\t \n\t\t\tfor (timer = 10; timer >= 0; timer--) {\n\t\t\t\tudelay(162);\n\t\t\t\tif ((window_read16(vp, 0, Wn0EepromCmd) &\n\t\t\t\t     0x8000) == 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\teeprom[i] = window_read16(vp, 0, Wn0EepromData);\n\t\t}\n\t}\n\tfor (i = 0; i < 0x18; i++)\n\t\tchecksum ^= eeprom[i];\n\tchecksum = (checksum ^ (checksum >> 8)) & 0xff;\n\tif (checksum != 0x00) {\t\t \n\t\twhile (i < 0x21)\n\t\t\tchecksum ^= eeprom[i++];\n\t\tchecksum = (checksum ^ (checksum >> 8)) & 0xff;\n\t}\n\tif ((checksum != 0x00) && !(vci->drv_flags & IS_TORNADO))\n\t\tpr_cont(\" ***INVALID CHECKSUM %4.4x*** \", checksum);\n\tfor (i = 0; i < 3; i++)\n\t\taddr[i] = htons(eeprom[i + 10]);\n\teth_hw_addr_set(dev, (u8 *)addr);\n\tif (print_info)\n\t\tpr_cont(\" %pM\", dev->dev_addr);\n\t \n\tif (!is_valid_ether_addr(dev->dev_addr)) {\n\t\tretval = -EINVAL;\n\t\tpr_err(\"*** EEPROM MAC address is invalid.\\n\");\n\t\tgoto free_ring;\t \n\t}\n\tfor (i = 0; i < 6; i++)\n\t\twindow_write8(vp, dev->dev_addr[i], 2, i);\n\n\tif (print_info)\n\t\tpr_cont(\", IRQ %d\\n\", dev->irq);\n\t \n\tif (dev->irq <= 0 || dev->irq >= nr_irqs)\n\t\tpr_warn(\" *** Warning: IRQ %d is unlikely to work! ***\\n\",\n\t\t\tdev->irq);\n\n\tstep = (window_read8(vp, 4, Wn4_NetDiag) & 0x1e) >> 1;\n\tif (print_info) {\n\t\tpr_info(\"  product code %02x%02x rev %02x.%d date %02d-%02d-%02d\\n\",\n\t\t\teeprom[6]&0xff, eeprom[6]>>8, eeprom[0x14],\n\t\t\tstep, (eeprom[4]>>5) & 15, eeprom[4] & 31, eeprom[4]>>9);\n\t}\n\n\n\tif (pdev && vci->drv_flags & HAS_CB_FNS) {\n\t\tunsigned short n;\n\n\t\tvp->cb_fn_base = pci_iomap(pdev, 2, 0);\n\t\tif (!vp->cb_fn_base) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto free_ring;\n\t\t}\n\n\t\tif (print_info) {\n\t\t\tpr_info(\"%s: CardBus functions mapped %16.16llx->%p\\n\",\n\t\t\t\tprint_name,\n\t\t\t\t(unsigned long long)pci_resource_start(pdev, 2),\n\t\t\t\tvp->cb_fn_base);\n\t\t}\n\n\t\tn = window_read16(vp, 2, Wn2_ResetOptions) & ~0x4010;\n\t\tif (vp->drv_flags & INVERT_LED_PWR)\n\t\t\tn |= 0x10;\n\t\tif (vp->drv_flags & INVERT_MII_PWR)\n\t\t\tn |= 0x4000;\n\t\twindow_write16(vp, n, 2, Wn2_ResetOptions);\n\t\tif (vp->drv_flags & WNO_XCVR_PWR) {\n\t\t\twindow_write16(vp, 0x0800, 0, 0);\n\t\t}\n\t}\n\n\t \n\tvp->info1 = eeprom[13];\n\tvp->info2 = eeprom[15];\n\tvp->capabilities = eeprom[16];\n\n\tif (vp->info1 & 0x8000) {\n\t\tvp->full_duplex = 1;\n\t\tif (print_info)\n\t\t\tpr_info(\"Full duplex capable\\n\");\n\t}\n\n\t{\n\t\tstatic const char * const ram_split[] = {\"5:3\", \"3:1\", \"1:1\", \"3:5\"};\n\t\tunsigned int config;\n\t\tvp->available_media = window_read16(vp, 3, Wn3_Options);\n\t\tif ((vp->available_media & 0xff) == 0)\t\t \n\t\t\tvp->available_media = 0x40;\n\t\tconfig = window_read32(vp, 3, Wn3_Config);\n\t\tif (print_info) {\n\t\t\tpr_debug(\"  Internal config register is %4.4x, transceivers %#x.\\n\",\n\t\t\t\tconfig, window_read16(vp, 3, Wn3_Options));\n\t\t\tpr_info(\"  %dK %s-wide RAM %s Rx:Tx split, %s%s interface.\\n\",\n\t\t\t\t   8 << RAM_SIZE(config),\n\t\t\t\t   RAM_WIDTH(config) ? \"word\" : \"byte\",\n\t\t\t\t   ram_split[RAM_SPLIT(config)],\n\t\t\t\t   AUTOSELECT(config) ? \"autoselect/\" : \"\",\n\t\t\t\t   XCVR(config) > XCVR_ExtMII ? \"<invalid transceiver>\" :\n\t\t\t\t   media_tbl[XCVR(config)].name);\n\t\t}\n\t\tvp->default_media = XCVR(config);\n\t\tif (vp->default_media == XCVR_NWAY)\n\t\t\tvp->has_nway = 1;\n\t\tvp->autoselect = AUTOSELECT(config);\n\t}\n\n\tif (vp->media_override != 7) {\n\t\tpr_info(\"%s:  Media override to transceiver type %d (%s).\\n\",\n\t\t\t\tprint_name, vp->media_override,\n\t\t\t\tmedia_tbl[vp->media_override].name);\n\t\tdev->if_port = vp->media_override;\n\t} else\n\t\tdev->if_port = vp->default_media;\n\n\tif ((vp->available_media & 0x40) || (vci->drv_flags & HAS_NWAY) ||\n\t\tdev->if_port == XCVR_MII || dev->if_port == XCVR_NWAY) {\n\t\tint phy, phy_idx = 0;\n\t\tmii_preamble_required++;\n\t\tif (vp->drv_flags & EXTRA_PREAMBLE)\n\t\t\tmii_preamble_required++;\n\t\tmdio_sync(vp, 32);\n\t\tmdio_read(dev, 24, MII_BMSR);\n\t\tfor (phy = 0; phy < 32 && phy_idx < 1; phy++) {\n\t\t\tint mii_status, phyx;\n\n\t\t\t \n\t\t\tif (phy == 0)\n\t\t\t\tphyx = 24;\n\t\t\telse if (phy <= 24)\n\t\t\t\tphyx = phy - 1;\n\t\t\telse\n\t\t\t\tphyx = phy;\n\t\t\tmii_status = mdio_read(dev, phyx, MII_BMSR);\n\t\t\tif (mii_status  &&  mii_status != 0xffff) {\n\t\t\t\tvp->phys[phy_idx++] = phyx;\n\t\t\t\tif (print_info) {\n\t\t\t\t\tpr_info(\"  MII transceiver found at address %d, status %4x.\\n\",\n\t\t\t\t\t\tphyx, mii_status);\n\t\t\t\t}\n\t\t\t\tif ((mii_status & 0x0040) == 0)\n\t\t\t\t\tmii_preamble_required++;\n\t\t\t}\n\t\t}\n\t\tmii_preamble_required--;\n\t\tif (phy_idx == 0) {\n\t\t\tpr_warn(\"  ***WARNING*** No MII transceivers found!\\n\");\n\t\t\tvp->phys[0] = 24;\n\t\t} else {\n\t\t\tvp->advertising = mdio_read(dev, vp->phys[0], MII_ADVERTISE);\n\t\t\tif (vp->full_duplex) {\n\t\t\t\t \n\t\t\t\tvp->advertising &= ~0x02A0;\n\t\t\t\tmdio_write(dev, vp->phys[0], 4, vp->advertising);\n\t\t\t}\n\t\t}\n\t\tvp->mii.phy_id = vp->phys[0];\n\t}\n\n\tif (vp->capabilities & CapBusMaster) {\n\t\tvp->full_bus_master_tx = 1;\n\t\tif (print_info) {\n\t\t\tpr_info(\"  Enabling bus-master transmits and %s receives.\\n\",\n\t\t\t(vp->info2 & 1) ? \"early\" : \"whole-frame\" );\n\t\t}\n\t\tvp->full_bus_master_rx = (vp->info2 & 1) ? 1 : 2;\n\t\tvp->bus_master = 0;\t\t \n\t}\n\n\t \n\tif (vp->full_bus_master_tx) {\n\t\tdev->netdev_ops = &boomrang_netdev_ops;\n\t\t \n\t\tif (card_idx < MAX_UNITS &&\n\t\t    ((hw_checksums[card_idx] == -1 && (vp->drv_flags & HAS_HWCKSM)) ||\n\t\t\t\thw_checksums[card_idx] == 1)) {\n\t\t\tdev->features |= NETIF_F_IP_CSUM | NETIF_F_SG;\n\t\t}\n\t} else\n\t\tdev->netdev_ops =  &vortex_netdev_ops;\n\n\tif (print_info) {\n\t\tpr_info(\"%s: scatter/gather %sabled. h/w checksums %sabled\\n\",\n\t\t\t\tprint_name,\n\t\t\t\t(dev->features & NETIF_F_SG) ? \"en\":\"dis\",\n\t\t\t\t(dev->features & NETIF_F_IP_CSUM) ? \"en\":\"dis\");\n\t}\n\n\tdev->ethtool_ops = &vortex_ethtool_ops;\n\tdev->watchdog_timeo = (watchdog * HZ) / 1000;\n\n\tif (pdev) {\n\t\tvp->pm_state_valid = 1;\n\t\tpci_save_state(pdev);\n\t\tacpi_set_WOL(dev);\n\t}\n\tretval = register_netdev(dev);\n\tif (retval == 0)\n\t\treturn 0;\n\nfree_ring:\n\tdma_free_coherent(&pdev->dev,\n\t\tsizeof(struct boom_rx_desc) * RX_RING_SIZE +\n\t\tsizeof(struct boom_tx_desc) * TX_RING_SIZE,\n\t\tvp->rx_ring, vp->rx_ring_dma);\nfree_device:\n\tfree_netdev(dev);\n\tpr_err(PFX \"vortex_probe1 fails.  Returns %d\\n\", retval);\nout:\n\treturn retval;\n}\n\nstatic void\nissue_and_wait(struct net_device *dev, int cmd)\n{\n\tstruct vortex_private *vp = netdev_priv(dev);\n\tvoid __iomem *ioaddr = vp->ioaddr;\n\tint i;\n\n\tiowrite16(cmd, ioaddr + EL3_CMD);\n\tfor (i = 0; i < 2000; i++) {\n\t\tif (!(ioread16(ioaddr + EL3_STATUS) & CmdInProgress))\n\t\t\treturn;\n\t}\n\n\t \n\tfor (i = 0; i < 100000; i++) {\n\t\tif (!(ioread16(ioaddr + EL3_STATUS) & CmdInProgress)) {\n\t\t\tif (vortex_debug > 1)\n\t\t\t\tpr_info(\"%s: command 0x%04x took %d usecs\\n\",\n\t\t\t\t\t   dev->name, cmd, i * 10);\n\t\t\treturn;\n\t\t}\n\t\tudelay(10);\n\t}\n\tpr_err(\"%s: command 0x%04x did not complete! Status=0x%x\\n\",\n\t\t\t   dev->name, cmd, ioread16(ioaddr + EL3_STATUS));\n}\n\nstatic void\nvortex_set_duplex(struct net_device *dev)\n{\n\tstruct vortex_private *vp = netdev_priv(dev);\n\n\tpr_info(\"%s:  setting %s-duplex.\\n\",\n\t\tdev->name, (vp->full_duplex) ? \"full\" : \"half\");\n\n\t \n\twindow_write16(vp,\n\t\t       ((vp->info1 & 0x8000) || vp->full_duplex ? 0x20 : 0) |\n\t\t       (vp->large_frames ? 0x40 : 0) |\n\t\t       ((vp->full_duplex && vp->flow_ctrl && vp->partner_flow_ctrl) ?\n\t\t\t0x100 : 0),\n\t\t       3, Wn3_MAC_Ctrl);\n}\n\nstatic void vortex_check_media(struct net_device *dev, unsigned int init)\n{\n\tstruct vortex_private *vp = netdev_priv(dev);\n\tunsigned int ok_to_print = 0;\n\n\tif (vortex_debug > 3)\n\t\tok_to_print = 1;\n\n\tif (mii_check_media(&vp->mii, ok_to_print, init)) {\n\t\tvp->full_duplex = vp->mii.full_duplex;\n\t\tvortex_set_duplex(dev);\n\t} else if (init) {\n\t\tvortex_set_duplex(dev);\n\t}\n}\n\nstatic int\nvortex_up(struct net_device *dev)\n{\n\tstruct vortex_private *vp = netdev_priv(dev);\n\tvoid __iomem *ioaddr = vp->ioaddr;\n\tunsigned int config;\n\tint i, mii_reg5, err = 0;\n\n\tif (VORTEX_PCI(vp)) {\n\t\tpci_set_power_state(VORTEX_PCI(vp), PCI_D0);\t \n\t\tif (vp->pm_state_valid)\n\t\t\tpci_restore_state(VORTEX_PCI(vp));\n\t\terr = pci_enable_device(VORTEX_PCI(vp));\n\t\tif (err) {\n\t\t\tpr_warn(\"%s: Could not enable device\\n\", dev->name);\n\t\t\tgoto err_out;\n\t\t}\n\t}\n\n\t \n\tconfig = window_read32(vp, 3, Wn3_Config);\n\n\tif (vp->media_override != 7) {\n\t\tpr_info(\"%s: Media override to transceiver %d (%s).\\n\",\n\t\t\t   dev->name, vp->media_override,\n\t\t\t   media_tbl[vp->media_override].name);\n\t\tdev->if_port = vp->media_override;\n\t} else if (vp->autoselect) {\n\t\tif (vp->has_nway) {\n\t\t\tif (vortex_debug > 1)\n\t\t\t\tpr_info(\"%s: using NWAY device table, not %d\\n\",\n\t\t\t\t\t\t\t\tdev->name, dev->if_port);\n\t\t\tdev->if_port = XCVR_NWAY;\n\t\t} else {\n\t\t\t \n\t\t\tdev->if_port = XCVR_100baseTx;\n\t\t\twhile (! (vp->available_media & media_tbl[dev->if_port].mask))\n\t\t\t\tdev->if_port = media_tbl[dev->if_port].next;\n\t\t\tif (vortex_debug > 1)\n\t\t\t\tpr_info(\"%s: first available media type: %s\\n\",\n\t\t\t\t\tdev->name, media_tbl[dev->if_port].name);\n\t\t}\n\t} else {\n\t\tdev->if_port = vp->default_media;\n\t\tif (vortex_debug > 1)\n\t\t\tpr_info(\"%s: using default media %s\\n\",\n\t\t\t\tdev->name, media_tbl[dev->if_port].name);\n\t}\n\n\ttimer_setup(&vp->timer, vortex_timer, 0);\n\tmod_timer(&vp->timer, RUN_AT(media_tbl[dev->if_port].wait));\n\n\tif (vortex_debug > 1)\n\t\tpr_debug(\"%s: Initial media type %s.\\n\",\n\t\t\t   dev->name, media_tbl[dev->if_port].name);\n\n\tvp->full_duplex = vp->mii.force_media;\n\tconfig = BFINS(config, dev->if_port, 20, 4);\n\tif (vortex_debug > 6)\n\t\tpr_debug(\"vortex_up(): writing 0x%x to InternalConfig\\n\", config);\n\twindow_write32(vp, config, 3, Wn3_Config);\n\n\tif (dev->if_port == XCVR_MII || dev->if_port == XCVR_NWAY) {\n\t\tmdio_read(dev, vp->phys[0], MII_BMSR);\n\t\tmii_reg5 = mdio_read(dev, vp->phys[0], MII_LPA);\n\t\tvp->partner_flow_ctrl = ((mii_reg5 & 0x0400) != 0);\n\t\tvp->mii.full_duplex = vp->full_duplex;\n\n\t\tvortex_check_media(dev, 1);\n\t}\n\telse\n\t\tvortex_set_duplex(dev);\n\n\tissue_and_wait(dev, TxReset);\n\t \n\tissue_and_wait(dev, RxReset|0x04);\n\n\n\tiowrite16(SetStatusEnb | 0x00, ioaddr + EL3_CMD);\n\n\tif (vortex_debug > 1) {\n\t\tpr_debug(\"%s: vortex_up() irq %d media status %4.4x.\\n\",\n\t\t\t   dev->name, dev->irq, window_read16(vp, 4, Wn4_Media));\n\t}\n\n\t \n\tfor (i = 0; i < 6; i++)\n\t\twindow_write8(vp, dev->dev_addr[i], 2, i);\n\tfor (; i < 12; i+=2)\n\t\twindow_write16(vp, 0, 2, i);\n\n\tif (vp->cb_fn_base) {\n\t\tunsigned short n = window_read16(vp, 2, Wn2_ResetOptions) & ~0x4010;\n\t\tif (vp->drv_flags & INVERT_LED_PWR)\n\t\t\tn |= 0x10;\n\t\tif (vp->drv_flags & INVERT_MII_PWR)\n\t\t\tn |= 0x4000;\n\t\twindow_write16(vp, n, 2, Wn2_ResetOptions);\n\t}\n\n\tif (dev->if_port == XCVR_10base2)\n\t\t \n\t\tiowrite16(StartCoax, ioaddr + EL3_CMD);\n\tif (dev->if_port != XCVR_NWAY) {\n\t\twindow_write16(vp,\n\t\t\t       (window_read16(vp, 4, Wn4_Media) &\n\t\t\t\t~(Media_10TP|Media_SQE)) |\n\t\t\t       media_tbl[dev->if_port].media_bits,\n\t\t\t       4, Wn4_Media);\n\t}\n\n\t \n\tiowrite16(StatsDisable, ioaddr + EL3_CMD);\n\tfor (i = 0; i < 10; i++)\n\t\twindow_read8(vp, 6, i);\n\twindow_read16(vp, 6, 10);\n\twindow_read16(vp, 6, 12);\n\t \n\twindow_read8(vp, 4, 12);\n\t \n\twindow_write16(vp, 0x0040, 4, Wn4_NetDiag);\n\n\tif (vp->full_bus_master_rx) {  \n\t\tvp->cur_rx = 0;\n\t\t \n\t\tiowrite16(SetRxThreshold + (1536>>2), ioaddr + EL3_CMD);\n\t\tiowrite32(0x0020, ioaddr + PktStatus);\n\t\tiowrite32(vp->rx_ring_dma, ioaddr + UpListPtr);\n\t}\n\tif (vp->full_bus_master_tx) { \t\t \n\t\tvp->cur_tx = vp->dirty_tx = 0;\n\t\tif (vp->drv_flags & IS_BOOMERANG)\n\t\t\tiowrite8(PKT_BUF_SZ>>8, ioaddr + TxFreeThreshold);  \n\t\t \n\t\tfor (i = 0; i < RX_RING_SIZE; i++)\t \n\t\t\tvp->rx_ring[i].status = 0;\n\t\tfor (i = 0; i < TX_RING_SIZE; i++)\n\t\t\tvp->tx_skbuff[i] = NULL;\n\t\tiowrite32(0, ioaddr + DownListPtr);\n\t}\n\t \n\tset_rx_mode(dev);\n\t \n\tset_8021q_mode(dev, 1);\n\tiowrite16(StatsEnable, ioaddr + EL3_CMD);  \n\n\tiowrite16(RxEnable, ioaddr + EL3_CMD);  \n\tiowrite16(TxEnable, ioaddr + EL3_CMD);  \n\t \n\tvp->status_enable = SetStatusEnb | HostError|IntReq|StatsFull|TxComplete|\n\t\t(vp->full_bus_master_tx ? DownComplete : TxAvailable) |\n\t\t(vp->full_bus_master_rx ? UpComplete : RxComplete) |\n\t\t(vp->bus_master ? DMADone : 0);\n\tvp->intr_enable = SetIntrEnb | IntLatch | TxAvailable |\n\t\t(vp->full_bus_master_rx ? 0 : RxComplete) |\n\t\tStatsFull | HostError | TxComplete | IntReq\n\t\t| (vp->bus_master ? DMADone : 0) | UpComplete | DownComplete;\n\tiowrite16(vp->status_enable, ioaddr + EL3_CMD);\n\t \n\tiowrite16(AckIntr | IntLatch | TxAvailable | RxEarly | IntReq,\n\t\t ioaddr + EL3_CMD);\n\tiowrite16(vp->intr_enable, ioaddr + EL3_CMD);\n\tif (vp->cb_fn_base)\t\t\t \n\t\tiowrite32(0x8000, vp->cb_fn_base + 4);\n\tnetif_start_queue (dev);\n\tnetdev_reset_queue(dev);\nerr_out:\n\treturn err;\n}\n\nstatic int\nvortex_open(struct net_device *dev)\n{\n\tstruct vortex_private *vp = netdev_priv(dev);\n\tint i;\n\tint retval;\n\tdma_addr_t dma;\n\n\t \n\tif ((retval = request_irq(dev->irq, vortex_boomerang_interrupt, IRQF_SHARED, dev->name, dev))) {\n\t\tpr_err(\"%s: Could not reserve IRQ %d\\n\", dev->name, dev->irq);\n\t\tgoto err;\n\t}\n\n\tif (vp->full_bus_master_rx) {  \n\t\tif (vortex_debug > 2)\n\t\t\tpr_debug(\"%s:  Filling in the Rx ring.\\n\", dev->name);\n\t\tfor (i = 0; i < RX_RING_SIZE; i++) {\n\t\t\tstruct sk_buff *skb;\n\t\t\tvp->rx_ring[i].next = cpu_to_le32(vp->rx_ring_dma + sizeof(struct boom_rx_desc) * (i+1));\n\t\t\tvp->rx_ring[i].status = 0;\t \n\t\t\tvp->rx_ring[i].length = cpu_to_le32(PKT_BUF_SZ | LAST_FRAG);\n\n\t\t\tskb = __netdev_alloc_skb(dev, PKT_BUF_SZ + NET_IP_ALIGN,\n\t\t\t\t\t\t GFP_KERNEL);\n\t\t\tvp->rx_skbuff[i] = skb;\n\t\t\tif (skb == NULL)\n\t\t\t\tbreak;\t\t\t \n\n\t\t\tskb_reserve(skb, NET_IP_ALIGN);\t \n\t\t\tdma = dma_map_single(vp->gendev, skb->data,\n\t\t\t\t\t     PKT_BUF_SZ, DMA_FROM_DEVICE);\n\t\t\tif (dma_mapping_error(vp->gendev, dma))\n\t\t\t\tbreak;\n\t\t\tvp->rx_ring[i].addr = cpu_to_le32(dma);\n\t\t}\n\t\tif (i != RX_RING_SIZE) {\n\t\t\tpr_emerg(\"%s: no memory for rx ring\\n\", dev->name);\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto err_free_skb;\n\t\t}\n\t\t \n\t\tvp->rx_ring[i-1].next = cpu_to_le32(vp->rx_ring_dma);\n\t}\n\n\tretval = vortex_up(dev);\n\tif (!retval)\n\t\tgoto out;\n\nerr_free_skb:\n\tfor (i = 0; i < RX_RING_SIZE; i++) {\n\t\tif (vp->rx_skbuff[i]) {\n\t\t\tdev_kfree_skb(vp->rx_skbuff[i]);\n\t\t\tvp->rx_skbuff[i] = NULL;\n\t\t}\n\t}\n\tfree_irq(dev->irq, dev);\nerr:\n\tif (vortex_debug > 1)\n\t\tpr_err(\"%s: vortex_open() fails: returning %d\\n\", dev->name, retval);\nout:\n\treturn retval;\n}\n\nstatic void\nvortex_timer(struct timer_list *t)\n{\n\tstruct vortex_private *vp = from_timer(vp, t, timer);\n\tstruct net_device *dev = vp->mii.dev;\n\tvoid __iomem *ioaddr = vp->ioaddr;\n\tint next_tick = 60*HZ;\n\tint ok = 0;\n\tint media_status;\n\n\tif (vortex_debug > 2) {\n\t\tpr_debug(\"%s: Media selection timer tick happened, %s.\\n\",\n\t\t\t   dev->name, media_tbl[dev->if_port].name);\n\t\tpr_debug(\"dev->watchdog_timeo=%d\\n\", dev->watchdog_timeo);\n\t}\n\n\tmedia_status = window_read16(vp, 4, Wn4_Media);\n\tswitch (dev->if_port) {\n\tcase XCVR_10baseT:  case XCVR_100baseTx:  case XCVR_100baseFx:\n\t\tif (media_status & Media_LnkBeat) {\n\t\t\tnetif_carrier_on(dev);\n\t\t\tok = 1;\n\t\t\tif (vortex_debug > 1)\n\t\t\t\tpr_debug(\"%s: Media %s has link beat, %x.\\n\",\n\t\t\t\t\t   dev->name, media_tbl[dev->if_port].name, media_status);\n\t\t} else {\n\t\t\tnetif_carrier_off(dev);\n\t\t\tif (vortex_debug > 1) {\n\t\t\t\tpr_debug(\"%s: Media %s has no link beat, %x.\\n\",\n\t\t\t\t\t   dev->name, media_tbl[dev->if_port].name, media_status);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase XCVR_MII: case XCVR_NWAY:\n\t\t{\n\t\t\tok = 1;\n\t\t\tvortex_check_media(dev, 0);\n\t\t}\n\t\tbreak;\n\t  default:\t\t\t\t\t \n\t\tif (vortex_debug > 1)\n\t\t  pr_debug(\"%s: Media %s has no indication, %x.\\n\",\n\t\t\t\t dev->name, media_tbl[dev->if_port].name, media_status);\n\t\tok = 1;\n\t}\n\n\tif (dev->flags & IFF_SLAVE || !netif_carrier_ok(dev))\n\t\tnext_tick = 5*HZ;\n\n\tif (vp->medialock)\n\t\tgoto leave_media_alone;\n\n\tif (!ok) {\n\t\tunsigned int config;\n\n\t\tspin_lock_irq(&vp->lock);\n\n\t\tdo {\n\t\t\tdev->if_port = media_tbl[dev->if_port].next;\n\t\t} while ( ! (vp->available_media & media_tbl[dev->if_port].mask));\n\t\tif (dev->if_port == XCVR_Default) {  \n\t\t  dev->if_port = vp->default_media;\n\t\t  if (vortex_debug > 1)\n\t\t\tpr_debug(\"%s: Media selection failing, using default %s port.\\n\",\n\t\t\t\t   dev->name, media_tbl[dev->if_port].name);\n\t\t} else {\n\t\t\tif (vortex_debug > 1)\n\t\t\t\tpr_debug(\"%s: Media selection failed, now trying %s port.\\n\",\n\t\t\t\t\t   dev->name, media_tbl[dev->if_port].name);\n\t\t\tnext_tick = media_tbl[dev->if_port].wait;\n\t\t}\n\t\twindow_write16(vp,\n\t\t\t       (media_status & ~(Media_10TP|Media_SQE)) |\n\t\t\t       media_tbl[dev->if_port].media_bits,\n\t\t\t       4, Wn4_Media);\n\n\t\tconfig = window_read32(vp, 3, Wn3_Config);\n\t\tconfig = BFINS(config, dev->if_port, 20, 4);\n\t\twindow_write32(vp, config, 3, Wn3_Config);\n\n\t\tiowrite16(dev->if_port == XCVR_10base2 ? StartCoax : StopCoax,\n\t\t\t ioaddr + EL3_CMD);\n\t\tif (vortex_debug > 1)\n\t\t\tpr_debug(\"wrote 0x%08x to Wn3_Config\\n\", config);\n\t\t \n\n\t\tspin_unlock_irq(&vp->lock);\n\t}\n\nleave_media_alone:\n\tif (vortex_debug > 2)\n\t  pr_debug(\"%s: Media selection timer finished, %s.\\n\",\n\t\t\t dev->name, media_tbl[dev->if_port].name);\n\n\tmod_timer(&vp->timer, RUN_AT(next_tick));\n\tif (vp->deferred)\n\t\tiowrite16(FakeIntr, ioaddr + EL3_CMD);\n}\n\nstatic void vortex_tx_timeout(struct net_device *dev, unsigned int txqueue)\n{\n\tstruct vortex_private *vp = netdev_priv(dev);\n\tvoid __iomem *ioaddr = vp->ioaddr;\n\n\tpr_err(\"%s: transmit timed out, tx_status %2.2x status %4.4x.\\n\",\n\t\t   dev->name, ioread8(ioaddr + TxStatus),\n\t\t   ioread16(ioaddr + EL3_STATUS));\n\tpr_err(\"  diagnostics: net %04x media %04x dma %08x fifo %04x\\n\",\n\t\t\twindow_read16(vp, 4, Wn4_NetDiag),\n\t\t\twindow_read16(vp, 4, Wn4_Media),\n\t\t\tioread32(ioaddr + PktStatus),\n\t\t\twindow_read16(vp, 4, Wn4_FIFODiag));\n\t \n\tif ((ioread8(ioaddr + TxStatus) & 0x88) == 0x88)\n\t\tpr_err(\"%s: Transmitter encountered 16 collisions --\"\n\t\t\t   \" network cable problem?\\n\", dev->name);\n\tif (ioread16(ioaddr + EL3_STATUS) & IntLatch) {\n\t\tpr_err(\"%s: Interrupt posted but not delivered --\"\n\t\t\t   \" IRQ blocked by another device?\\n\", dev->name);\n\t\t \n\t\tvortex_boomerang_interrupt(dev->irq, dev);\n\t}\n\n\tif (vortex_debug > 0)\n\t\tdump_tx_ring(dev);\n\n\tissue_and_wait(dev, TxReset);\n\n\tdev->stats.tx_errors++;\n\tif (vp->full_bus_master_tx) {\n\t\tpr_debug(\"%s: Resetting the Tx ring pointer.\\n\", dev->name);\n\t\tif (vp->cur_tx - vp->dirty_tx > 0  &&  ioread32(ioaddr + DownListPtr) == 0)\n\t\t\tiowrite32(vp->tx_ring_dma + (vp->dirty_tx % TX_RING_SIZE) * sizeof(struct boom_tx_desc),\n\t\t\t\t ioaddr + DownListPtr);\n\t\tif (vp->cur_tx - vp->dirty_tx < TX_RING_SIZE) {\n\t\t\tnetif_wake_queue (dev);\n\t\t\tnetdev_reset_queue (dev);\n\t\t}\n\t\tif (vp->drv_flags & IS_BOOMERANG)\n\t\t\tiowrite8(PKT_BUF_SZ>>8, ioaddr + TxFreeThreshold);\n\t\tiowrite16(DownUnstall, ioaddr + EL3_CMD);\n\t} else {\n\t\tdev->stats.tx_dropped++;\n\t\tnetif_wake_queue(dev);\n\t\tnetdev_reset_queue(dev);\n\t}\n\t \n\tiowrite16(TxEnable, ioaddr + EL3_CMD);\n\tnetif_trans_update(dev);  \n}\n\n \nstatic void\nvortex_error(struct net_device *dev, int status)\n{\n\tstruct vortex_private *vp = netdev_priv(dev);\n\tvoid __iomem *ioaddr = vp->ioaddr;\n\tint do_tx_reset = 0, reset_mask = 0;\n\tunsigned char tx_status = 0;\n\n\tif (vortex_debug > 2) {\n\t\tpr_err(\"%s: vortex_error(), status=0x%x\\n\", dev->name, status);\n\t}\n\n\tif (status & TxComplete) {\t\t\t \n\t\ttx_status = ioread8(ioaddr + TxStatus);\n\t\t \n\t\tif (vortex_debug > 2 ||\n\t\t    (tx_status != 0x88 && vortex_debug > 0)) {\n\t\t\tpr_err(\"%s: Transmit error, Tx status register %2.2x.\\n\",\n\t\t\t\t   dev->name, tx_status);\n\t\t\tif (tx_status == 0x82) {\n\t\t\t\tpr_err(\"Probably a duplex mismatch.  See \"\n\t\t\t\t\t\t\"Documentation/networking/device_drivers/ethernet/3com/vortex.rst\\n\");\n\t\t\t}\n\t\t\tdump_tx_ring(dev);\n\t\t}\n\t\tif (tx_status & 0x14)  dev->stats.tx_fifo_errors++;\n\t\tif (tx_status & 0x38)  dev->stats.tx_aborted_errors++;\n\t\tif (tx_status & 0x08)  vp->xstats.tx_max_collisions++;\n\t\tiowrite8(0, ioaddr + TxStatus);\n\t\tif (tx_status & 0x30) {\t\t\t \n\t\t\tdo_tx_reset = 1;\n\t\t} else if ((tx_status & 0x08) && (vp->drv_flags & MAX_COLLISION_RESET))  {\t \n\t\t\tdo_tx_reset = 1;\n\t\t\treset_mask = 0x0108;\t\t \n\t\t} else {\t\t\t\t \n\t\t\tiowrite16(TxEnable, ioaddr + EL3_CMD);\n\t\t}\n\t}\n\n\tif (status & RxEarly)\t\t\t\t \n\t\tiowrite16(AckIntr | RxEarly, ioaddr + EL3_CMD);\n\n\tif (status & StatsFull) {\t\t\t \n\t\tstatic int DoneDidThat;\n\t\tif (vortex_debug > 4)\n\t\t\tpr_debug(\"%s: Updating stats.\\n\", dev->name);\n\t\tupdate_stats(ioaddr, dev);\n\t\t \n\t\t \n\t\tif (DoneDidThat == 0  &&\n\t\t\tioread16(ioaddr + EL3_STATUS) & StatsFull) {\n\t\t\tpr_warn(\"%s: Updating statistics failed, disabling stats as an interrupt source\\n\",\n\t\t\t\tdev->name);\n\t\t\tiowrite16(SetIntrEnb |\n\t\t\t\t  (window_read16(vp, 5, 10) & ~StatsFull),\n\t\t\t\t  ioaddr + EL3_CMD);\n\t\t\tvp->intr_enable &= ~StatsFull;\n\t\t\tDoneDidThat++;\n\t\t}\n\t}\n\tif (status & IntReq) {\t\t \n\t\tiowrite16(vp->status_enable, ioaddr + EL3_CMD);\n\t\tiowrite16(vp->intr_enable, ioaddr + EL3_CMD);\n\t}\n\tif (status & HostError) {\n\t\tu16 fifo_diag;\n\t\tfifo_diag = window_read16(vp, 4, Wn4_FIFODiag);\n\t\tpr_err(\"%s: Host error, FIFO diagnostic register %4.4x.\\n\",\n\t\t\t   dev->name, fifo_diag);\n\t\t \n\t\tif (vp->full_bus_master_tx) {\n\t\t\tint bus_status = ioread32(ioaddr + PktStatus);\n\t\t\t \n\t\t\t \n\t\t\tif (vortex_debug)\n\t\t\t\tpr_err(\"%s: PCI bus error, bus status %8.8x\\n\", dev->name, bus_status);\n\n\t\t\t \n\t\t\t \n\t\t\tvortex_down(dev, 0);\n\t\t\tissue_and_wait(dev, TotalReset | 0xff);\n\t\t\tvortex_up(dev);\t\t \n\t\t} else if (fifo_diag & 0x0400)\n\t\t\tdo_tx_reset = 1;\n\t\tif (fifo_diag & 0x3000) {\n\t\t\t \n\t\t\tissue_and_wait(dev, RxReset|0x07);\n\t\t\t \n\t\t\tset_rx_mode(dev);\n\t\t\t \n\t\t\tset_8021q_mode(dev, 1);\n\t\t\tiowrite16(RxEnable, ioaddr + EL3_CMD);  \n\t\t\tiowrite16(AckIntr | HostError, ioaddr + EL3_CMD);\n\t\t}\n\t}\n\n\tif (do_tx_reset) {\n\t\tissue_and_wait(dev, TxReset|reset_mask);\n\t\tiowrite16(TxEnable, ioaddr + EL3_CMD);\n\t\tif (!vp->full_bus_master_tx)\n\t\t\tnetif_wake_queue(dev);\n\t}\n}\n\nstatic netdev_tx_t\nvortex_start_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct vortex_private *vp = netdev_priv(dev);\n\tvoid __iomem *ioaddr = vp->ioaddr;\n\tint skblen = skb->len;\n\n\t \n\tiowrite32(skb->len, ioaddr + TX_FIFO);\n\tif (vp->bus_master) {\n\t\t \n\t\tint len = (skb->len + 3) & ~3;\n\t\tvp->tx_skb_dma = dma_map_single(vp->gendev, skb->data, len,\n\t\t\t\t\t\tDMA_TO_DEVICE);\n\t\tif (dma_mapping_error(vp->gendev, vp->tx_skb_dma)) {\n\t\t\tdev_kfree_skb_any(skb);\n\t\t\tdev->stats.tx_dropped++;\n\t\t\treturn NETDEV_TX_OK;\n\t\t}\n\n\t\tspin_lock_irq(&vp->window_lock);\n\t\twindow_set(vp, 7);\n\t\tiowrite32(vp->tx_skb_dma, ioaddr + Wn7_MasterAddr);\n\t\tiowrite16(len, ioaddr + Wn7_MasterLen);\n\t\tspin_unlock_irq(&vp->window_lock);\n\t\tvp->tx_skb = skb;\n\t\tskb_tx_timestamp(skb);\n\t\tiowrite16(StartDMADown, ioaddr + EL3_CMD);\n\t\t \n\t} else {\n\t\t \n\t\tskb_tx_timestamp(skb);\n\t\tiowrite32_rep(ioaddr + TX_FIFO, skb->data, (skb->len + 3) >> 2);\n\t\tdev_consume_skb_any (skb);\n\t\tif (ioread16(ioaddr + TxFree) > 1536) {\n\t\t\tnetif_start_queue (dev);\t \n\t\t} else {\n\t\t\t \n\t\t\tnetif_stop_queue(dev);\n\t\t\tiowrite16(SetTxThreshold + (1536>>2), ioaddr + EL3_CMD);\n\t\t}\n\t}\n\n\tnetdev_sent_queue(dev, skblen);\n\n\t \n\t{\n\t\tint tx_status;\n\t\tint i = 32;\n\n\t\twhile (--i > 0\t&&\t(tx_status = ioread8(ioaddr + TxStatus)) > 0) {\n\t\t\tif (tx_status & 0x3C) {\t\t \n\t\t\t\tif (vortex_debug > 2)\n\t\t\t\t  pr_debug(\"%s: Tx error, status %2.2x.\\n\",\n\t\t\t\t\t\t dev->name, tx_status);\n\t\t\t\tif (tx_status & 0x04) dev->stats.tx_fifo_errors++;\n\t\t\t\tif (tx_status & 0x38) dev->stats.tx_aborted_errors++;\n\t\t\t\tif (tx_status & 0x30) {\n\t\t\t\t\tissue_and_wait(dev, TxReset);\n\t\t\t\t}\n\t\t\t\tiowrite16(TxEnable, ioaddr + EL3_CMD);\n\t\t\t}\n\t\t\tiowrite8(0x00, ioaddr + TxStatus);  \n\t\t}\n\t}\n\treturn NETDEV_TX_OK;\n}\n\nstatic netdev_tx_t\nboomerang_start_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct vortex_private *vp = netdev_priv(dev);\n\tvoid __iomem *ioaddr = vp->ioaddr;\n\t \n\tint entry = vp->cur_tx % TX_RING_SIZE;\n\tint skblen = skb->len;\n\tstruct boom_tx_desc *prev_entry = &vp->tx_ring[(vp->cur_tx-1) % TX_RING_SIZE];\n\tunsigned long flags;\n\tdma_addr_t dma_addr;\n\n\tif (vortex_debug > 6) {\n\t\tpr_debug(\"boomerang_start_xmit()\\n\");\n\t\tpr_debug(\"%s: Trying to send a packet, Tx index %d.\\n\",\n\t\t\t   dev->name, vp->cur_tx);\n\t}\n\n\t \n\tif (vp->handling_irq)\n\t\treturn NETDEV_TX_BUSY;\n\n\tif (vp->cur_tx - vp->dirty_tx >= TX_RING_SIZE) {\n\t\tif (vortex_debug > 0)\n\t\t\tpr_warn(\"%s: BUG! Tx Ring full, refusing to send buffer\\n\",\n\t\t\t\tdev->name);\n\t\tnetif_stop_queue(dev);\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\n\tvp->tx_skbuff[entry] = skb;\n\n\tvp->tx_ring[entry].next = 0;\n#if DO_ZEROCOPY\n\tif (skb->ip_summed != CHECKSUM_PARTIAL)\n\t\t\tvp->tx_ring[entry].status = cpu_to_le32(skb->len | TxIntrUploaded);\n\telse\n\t\t\tvp->tx_ring[entry].status = cpu_to_le32(skb->len | TxIntrUploaded | AddTCPChksum | AddUDPChksum);\n\n\tif (!skb_shinfo(skb)->nr_frags) {\n\t\tdma_addr = dma_map_single(vp->gendev, skb->data, skb->len,\n\t\t\t\t\t  DMA_TO_DEVICE);\n\t\tif (dma_mapping_error(vp->gendev, dma_addr))\n\t\t\tgoto out_dma_err;\n\n\t\tvp->tx_ring[entry].frag[0].addr = cpu_to_le32(dma_addr);\n\t\tvp->tx_ring[entry].frag[0].length = cpu_to_le32(skb->len | LAST_FRAG);\n\t} else {\n\t\tint i;\n\n\t\tdma_addr = dma_map_single(vp->gendev, skb->data,\n\t\t\t\t\t  skb_headlen(skb), DMA_TO_DEVICE);\n\t\tif (dma_mapping_error(vp->gendev, dma_addr))\n\t\t\tgoto out_dma_err;\n\n\t\tvp->tx_ring[entry].frag[0].addr = cpu_to_le32(dma_addr);\n\t\tvp->tx_ring[entry].frag[0].length = cpu_to_le32(skb_headlen(skb));\n\n\t\tfor (i = 0; i < skb_shinfo(skb)->nr_frags; i++) {\n\t\t\tskb_frag_t *frag = &skb_shinfo(skb)->frags[i];\n\n\t\t\tdma_addr = skb_frag_dma_map(vp->gendev, frag,\n\t\t\t\t\t\t    0,\n\t\t\t\t\t\t    skb_frag_size(frag),\n\t\t\t\t\t\t    DMA_TO_DEVICE);\n\t\t\tif (dma_mapping_error(vp->gendev, dma_addr)) {\n\t\t\t\tfor(i = i-1; i >= 0; i--)\n\t\t\t\t\tdma_unmap_page(vp->gendev,\n\t\t\t\t\t\t       le32_to_cpu(vp->tx_ring[entry].frag[i+1].addr),\n\t\t\t\t\t\t       le32_to_cpu(vp->tx_ring[entry].frag[i+1].length),\n\t\t\t\t\t\t       DMA_TO_DEVICE);\n\n\t\t\t\tdma_unmap_single(vp->gendev,\n\t\t\t\t\t\t le32_to_cpu(vp->tx_ring[entry].frag[0].addr),\n\t\t\t\t\t\t le32_to_cpu(vp->tx_ring[entry].frag[0].length),\n\t\t\t\t\t\t DMA_TO_DEVICE);\n\n\t\t\t\tgoto out_dma_err;\n\t\t\t}\n\n\t\t\tvp->tx_ring[entry].frag[i+1].addr =\n\t\t\t\t\t\tcpu_to_le32(dma_addr);\n\n\t\t\tif (i == skb_shinfo(skb)->nr_frags-1)\n\t\t\t\t\tvp->tx_ring[entry].frag[i+1].length = cpu_to_le32(skb_frag_size(frag)|LAST_FRAG);\n\t\t\telse\n\t\t\t\t\tvp->tx_ring[entry].frag[i+1].length = cpu_to_le32(skb_frag_size(frag));\n\t\t}\n\t}\n#else\n\tdma_addr = dma_map_single(vp->gendev, skb->data, skb->len, DMA_TO_DEVICE);\n\tif (dma_mapping_error(vp->gendev, dma_addr))\n\t\tgoto out_dma_err;\n\tvp->tx_ring[entry].addr = cpu_to_le32(dma_addr);\n\tvp->tx_ring[entry].length = cpu_to_le32(skb->len | LAST_FRAG);\n\tvp->tx_ring[entry].status = cpu_to_le32(skb->len | TxIntrUploaded);\n#endif\n\n\tspin_lock_irqsave(&vp->lock, flags);\n\t \n\tissue_and_wait(dev, DownStall);\n\tprev_entry->next = cpu_to_le32(vp->tx_ring_dma + entry * sizeof(struct boom_tx_desc));\n\tif (ioread32(ioaddr + DownListPtr) == 0) {\n\t\tiowrite32(vp->tx_ring_dma + entry * sizeof(struct boom_tx_desc), ioaddr + DownListPtr);\n\t\tvp->queued_packet++;\n\t}\n\n\tvp->cur_tx++;\n\tnetdev_sent_queue(dev, skblen);\n\n\tif (vp->cur_tx - vp->dirty_tx > TX_RING_SIZE - 1) {\n\t\tnetif_stop_queue (dev);\n\t} else {\t\t\t\t\t \n#if defined(tx_interrupt_mitigation)\n\t\t \n\t\tprev_entry->status &= cpu_to_le32(~TxIntrUploaded);\n#endif\n\t}\n\tskb_tx_timestamp(skb);\n\tiowrite16(DownUnstall, ioaddr + EL3_CMD);\n\tspin_unlock_irqrestore(&vp->lock, flags);\nout:\n\treturn NETDEV_TX_OK;\nout_dma_err:\n\tdev_err(vp->gendev, \"Error mapping dma buffer\\n\");\n\tgoto out;\n}\n\n \n\n \n\nstatic irqreturn_t\n_vortex_interrupt(int irq, struct net_device *dev)\n{\n\tstruct vortex_private *vp = netdev_priv(dev);\n\tvoid __iomem *ioaddr;\n\tint status;\n\tint work_done = max_interrupt_work;\n\tint handled = 0;\n\tunsigned int bytes_compl = 0, pkts_compl = 0;\n\n\tioaddr = vp->ioaddr;\n\n\tstatus = ioread16(ioaddr + EL3_STATUS);\n\n\tif (vortex_debug > 6)\n\t\tpr_debug(\"vortex_interrupt(). status=0x%4x\\n\", status);\n\n\tif ((status & IntLatch) == 0)\n\t\tgoto handler_exit;\t\t \n\thandled = 1;\n\n\tif (status & IntReq) {\n\t\tstatus |= vp->deferred;\n\t\tvp->deferred = 0;\n\t}\n\n\tif (status == 0xffff)\t\t \n\t\tgoto handler_exit;\n\n\tif (vortex_debug > 4)\n\t\tpr_debug(\"%s: interrupt, status %4.4x, latency %d ticks.\\n\",\n\t\t\t   dev->name, status, ioread8(ioaddr + Timer));\n\n\tspin_lock(&vp->window_lock);\n\twindow_set(vp, 7);\n\n\tdo {\n\t\tif (vortex_debug > 5)\n\t\t\t\tpr_debug(\"%s: In interrupt loop, status %4.4x.\\n\",\n\t\t\t\t\t   dev->name, status);\n\t\tif (status & RxComplete)\n\t\t\tvortex_rx(dev);\n\n\t\tif (status & TxAvailable) {\n\t\t\tif (vortex_debug > 5)\n\t\t\t\tpr_debug(\"\tTX room bit was handled.\\n\");\n\t\t\t \n\t\t\tiowrite16(AckIntr | TxAvailable, ioaddr + EL3_CMD);\n\t\t\tnetif_wake_queue (dev);\n\t\t}\n\n\t\tif (status & DMADone) {\n\t\t\tif (ioread16(ioaddr + Wn7_MasterStatus) & 0x1000) {\n\t\t\t\tiowrite16(0x1000, ioaddr + Wn7_MasterStatus);  \n\t\t\t\tdma_unmap_single(vp->gendev, vp->tx_skb_dma, (vp->tx_skb->len + 3) & ~3, DMA_TO_DEVICE);\n\t\t\t\tpkts_compl++;\n\t\t\t\tbytes_compl += vp->tx_skb->len;\n\t\t\t\tdev_consume_skb_irq(vp->tx_skb);  \n\t\t\t\tif (ioread16(ioaddr + TxFree) > 1536) {\n\t\t\t\t\t \n\t\t\t\t\tnetif_wake_queue(dev);\n\t\t\t\t} else {  \n\t\t\t\t\tiowrite16(SetTxThreshold + (1536>>2), ioaddr + EL3_CMD);\n\t\t\t\t\tnetif_stop_queue(dev);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t \n\t\tif (status & (HostError | RxEarly | StatsFull | TxComplete | IntReq)) {\n\t\t\tif (status == 0xffff)\n\t\t\t\tbreak;\n\t\t\tif (status & RxEarly)\n\t\t\t\tvortex_rx(dev);\n\t\t\tspin_unlock(&vp->window_lock);\n\t\t\tvortex_error(dev, status);\n\t\t\tspin_lock(&vp->window_lock);\n\t\t\twindow_set(vp, 7);\n\t\t}\n\n\t\tif (--work_done < 0) {\n\t\t\tpr_warn(\"%s: Too much work in interrupt, status %4.4x\\n\",\n\t\t\t\tdev->name, status);\n\t\t\t \n\t\t\tdo {\n\t\t\t\tvp->deferred |= status;\n\t\t\t\tiowrite16(SetStatusEnb | (~vp->deferred & vp->status_enable),\n\t\t\t\t\t ioaddr + EL3_CMD);\n\t\t\t\tiowrite16(AckIntr | (vp->deferred & 0x7ff), ioaddr + EL3_CMD);\n\t\t\t} while ((status = ioread16(ioaddr + EL3_CMD)) & IntLatch);\n\t\t\t \n\t\t\tmod_timer(&vp->timer, jiffies + 1*HZ);\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tiowrite16(AckIntr | IntReq | IntLatch, ioaddr + EL3_CMD);\n\t} while ((status = ioread16(ioaddr + EL3_STATUS)) & (IntLatch | RxComplete));\n\n\tnetdev_completed_queue(dev, pkts_compl, bytes_compl);\n\tspin_unlock(&vp->window_lock);\n\n\tif (vortex_debug > 4)\n\t\tpr_debug(\"%s: exiting interrupt, status %4.4x.\\n\",\n\t\t\t   dev->name, status);\nhandler_exit:\n\treturn IRQ_RETVAL(handled);\n}\n\n \n\nstatic irqreturn_t\n_boomerang_interrupt(int irq, struct net_device *dev)\n{\n\tstruct vortex_private *vp = netdev_priv(dev);\n\tvoid __iomem *ioaddr;\n\tint status;\n\tint work_done = max_interrupt_work;\n\tint handled = 0;\n\tunsigned int bytes_compl = 0, pkts_compl = 0;\n\n\tioaddr = vp->ioaddr;\n\n\tvp->handling_irq = 1;\n\n\tstatus = ioread16(ioaddr + EL3_STATUS);\n\n\tif (vortex_debug > 6)\n\t\tpr_debug(\"boomerang_interrupt. status=0x%4x\\n\", status);\n\n\tif ((status & IntLatch) == 0)\n\t\tgoto handler_exit;\t\t \n\thandled = 1;\n\n\tif (status == 0xffff) {\t\t \n\t\tif (vortex_debug > 1)\n\t\t\tpr_debug(\"boomerang_interrupt(1): status = 0xffff\\n\");\n\t\tgoto handler_exit;\n\t}\n\n\tif (status & IntReq) {\n\t\tstatus |= vp->deferred;\n\t\tvp->deferred = 0;\n\t}\n\n\tif (vortex_debug > 4)\n\t\tpr_debug(\"%s: interrupt, status %4.4x, latency %d ticks.\\n\",\n\t\t\t   dev->name, status, ioread8(ioaddr + Timer));\n\tdo {\n\t\tif (vortex_debug > 5)\n\t\t\t\tpr_debug(\"%s: In interrupt loop, status %4.4x.\\n\",\n\t\t\t\t\t   dev->name, status);\n\t\tif (status & UpComplete) {\n\t\t\tiowrite16(AckIntr | UpComplete, ioaddr + EL3_CMD);\n\t\t\tif (vortex_debug > 5)\n\t\t\t\tpr_debug(\"boomerang_interrupt->boomerang_rx\\n\");\n\t\t\tboomerang_rx(dev);\n\t\t}\n\n\t\tif (status & DownComplete) {\n\t\t\tunsigned int dirty_tx = vp->dirty_tx;\n\n\t\t\tiowrite16(AckIntr | DownComplete, ioaddr + EL3_CMD);\n\t\t\twhile (vp->cur_tx - dirty_tx > 0) {\n\t\t\t\tint entry = dirty_tx % TX_RING_SIZE;\n#if 1\t \n\t\t\t\tif (ioread32(ioaddr + DownListPtr) ==\n\t\t\t\t\tvp->tx_ring_dma + entry * sizeof(struct boom_tx_desc))\n\t\t\t\t\tbreak;\t\t\t \n#else\n\t\t\t\tif ((vp->tx_ring[entry].status & DN_COMPLETE) == 0)\n\t\t\t\t\tbreak;\t\t\t \n#endif\n\n\t\t\t\tif (vp->tx_skbuff[entry]) {\n\t\t\t\t\tstruct sk_buff *skb = vp->tx_skbuff[entry];\n#if DO_ZEROCOPY\n\t\t\t\t\tint i;\n\t\t\t\t\tdma_unmap_single(vp->gendev,\n\t\t\t\t\t\t\tle32_to_cpu(vp->tx_ring[entry].frag[0].addr),\n\t\t\t\t\t\t\tle32_to_cpu(vp->tx_ring[entry].frag[0].length)&0xFFF,\n\t\t\t\t\t\t\tDMA_TO_DEVICE);\n\n\t\t\t\t\tfor (i=1; i<=skb_shinfo(skb)->nr_frags; i++)\n\t\t\t\t\t\t\tdma_unmap_page(vp->gendev,\n\t\t\t\t\t\t\t\t\t\t\t le32_to_cpu(vp->tx_ring[entry].frag[i].addr),\n\t\t\t\t\t\t\t\t\t\t\t le32_to_cpu(vp->tx_ring[entry].frag[i].length)&0xFFF,\n\t\t\t\t\t\t\t\t\t\t\t DMA_TO_DEVICE);\n#else\n\t\t\t\t\tdma_unmap_single(vp->gendev,\n\t\t\t\t\t\tle32_to_cpu(vp->tx_ring[entry].addr), skb->len, DMA_TO_DEVICE);\n#endif\n\t\t\t\t\tpkts_compl++;\n\t\t\t\t\tbytes_compl += skb->len;\n\t\t\t\t\tdev_consume_skb_irq(skb);\n\t\t\t\t\tvp->tx_skbuff[entry] = NULL;\n\t\t\t\t} else {\n\t\t\t\t\tpr_debug(\"boomerang_interrupt: no skb!\\n\");\n\t\t\t\t}\n\t\t\t\t \n\t\t\t\tdirty_tx++;\n\t\t\t}\n\t\t\tvp->dirty_tx = dirty_tx;\n\t\t\tif (vp->cur_tx - dirty_tx <= TX_RING_SIZE - 1) {\n\t\t\t\tif (vortex_debug > 6)\n\t\t\t\t\tpr_debug(\"boomerang_interrupt: wake queue\\n\");\n\t\t\t\tnetif_wake_queue (dev);\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (status & (HostError | RxEarly | StatsFull | TxComplete | IntReq))\n\t\t\tvortex_error(dev, status);\n\n\t\tif (--work_done < 0) {\n\t\t\tpr_warn(\"%s: Too much work in interrupt, status %4.4x\\n\",\n\t\t\t\tdev->name, status);\n\t\t\t \n\t\t\tdo {\n\t\t\t\tvp->deferred |= status;\n\t\t\t\tiowrite16(SetStatusEnb | (~vp->deferred & vp->status_enable),\n\t\t\t\t\t ioaddr + EL3_CMD);\n\t\t\t\tiowrite16(AckIntr | (vp->deferred & 0x7ff), ioaddr + EL3_CMD);\n\t\t\t} while ((status = ioread16(ioaddr + EL3_CMD)) & IntLatch);\n\t\t\t \n\t\t\tmod_timer(&vp->timer, jiffies + 1*HZ);\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tiowrite16(AckIntr | IntReq | IntLatch, ioaddr + EL3_CMD);\n\t\tif (vp->cb_fn_base)\t\t\t \n\t\t\tiowrite32(0x8000, vp->cb_fn_base + 4);\n\n\t} while ((status = ioread16(ioaddr + EL3_STATUS)) & IntLatch);\n\tnetdev_completed_queue(dev, pkts_compl, bytes_compl);\n\n\tif (vortex_debug > 4)\n\t\tpr_debug(\"%s: exiting interrupt, status %4.4x.\\n\",\n\t\t\t   dev->name, status);\nhandler_exit:\n\tvp->handling_irq = 0;\n\treturn IRQ_RETVAL(handled);\n}\n\nstatic irqreturn_t\nvortex_boomerang_interrupt(int irq, void *dev_id)\n{\n\tstruct net_device *dev = dev_id;\n\tstruct vortex_private *vp = netdev_priv(dev);\n\tunsigned long flags;\n\tirqreturn_t ret;\n\n\tspin_lock_irqsave(&vp->lock, flags);\n\n\tif (vp->full_bus_master_rx)\n\t\tret = _boomerang_interrupt(dev->irq, dev);\n\telse\n\t\tret = _vortex_interrupt(dev->irq, dev);\n\n\tspin_unlock_irqrestore(&vp->lock, flags);\n\n\treturn ret;\n}\n\nstatic int vortex_rx(struct net_device *dev)\n{\n\tstruct vortex_private *vp = netdev_priv(dev);\n\tvoid __iomem *ioaddr = vp->ioaddr;\n\tint i;\n\tshort rx_status;\n\n\tif (vortex_debug > 5)\n\t\tpr_debug(\"vortex_rx(): status %4.4x, rx_status %4.4x.\\n\",\n\t\t\t   ioread16(ioaddr+EL3_STATUS), ioread16(ioaddr+RxStatus));\n\twhile ((rx_status = ioread16(ioaddr + RxStatus)) > 0) {\n\t\tif (rx_status & 0x4000) {  \n\t\t\tunsigned char rx_error = ioread8(ioaddr + RxErrors);\n\t\t\tif (vortex_debug > 2)\n\t\t\t\tpr_debug(\" Rx error: status %2.2x.\\n\", rx_error);\n\t\t\tdev->stats.rx_errors++;\n\t\t\tif (rx_error & 0x01)  dev->stats.rx_over_errors++;\n\t\t\tif (rx_error & 0x02)  dev->stats.rx_length_errors++;\n\t\t\tif (rx_error & 0x04)  dev->stats.rx_frame_errors++;\n\t\t\tif (rx_error & 0x08)  dev->stats.rx_crc_errors++;\n\t\t\tif (rx_error & 0x10)  dev->stats.rx_length_errors++;\n\t\t} else {\n\t\t\t \n\t\t\tint pkt_len = rx_status & 0x1fff;\n\t\t\tstruct sk_buff *skb;\n\n\t\t\tskb = netdev_alloc_skb(dev, pkt_len + 5);\n\t\t\tif (vortex_debug > 4)\n\t\t\t\tpr_debug(\"Receiving packet size %d status %4.4x.\\n\",\n\t\t\t\t\t   pkt_len, rx_status);\n\t\t\tif (skb != NULL) {\n\t\t\t\tskb_reserve(skb, 2);\t \n\t\t\t\t \n\t\t\t\tif (vp->bus_master &&\n\t\t\t\t\t! (ioread16(ioaddr + Wn7_MasterStatus) & 0x8000)) {\n\t\t\t\t\tdma_addr_t dma = dma_map_single(vp->gendev, skb_put(skb, pkt_len),\n\t\t\t\t\t\t\t\t\t   pkt_len, DMA_FROM_DEVICE);\n\t\t\t\t\tiowrite32(dma, ioaddr + Wn7_MasterAddr);\n\t\t\t\t\tiowrite16((skb->len + 3) & ~3, ioaddr + Wn7_MasterLen);\n\t\t\t\t\tiowrite16(StartDMAUp, ioaddr + EL3_CMD);\n\t\t\t\t\twhile (ioread16(ioaddr + Wn7_MasterStatus) & 0x8000)\n\t\t\t\t\t\t;\n\t\t\t\t\tdma_unmap_single(vp->gendev, dma, pkt_len, DMA_FROM_DEVICE);\n\t\t\t\t} else {\n\t\t\t\t\tioread32_rep(ioaddr + RX_FIFO,\n\t\t\t\t\t             skb_put(skb, pkt_len),\n\t\t\t\t\t\t     (pkt_len + 3) >> 2);\n\t\t\t\t}\n\t\t\t\tiowrite16(RxDiscard, ioaddr + EL3_CMD);  \n\t\t\t\tskb->protocol = eth_type_trans(skb, dev);\n\t\t\t\tnetif_rx(skb);\n\t\t\t\tdev->stats.rx_packets++;\n\t\t\t\t \n\t\t\t\tfor (i = 200; i >= 0; i--)\n\t\t\t\t\tif ( ! (ioread16(ioaddr + EL3_STATUS) & CmdInProgress))\n\t\t\t\t\t\tbreak;\n\t\t\t\tcontinue;\n\t\t\t} else if (vortex_debug > 0)\n\t\t\t\tpr_notice(\"%s: No memory to allocate a sk_buff of size %d.\\n\",\n\t\t\t\t\tdev->name, pkt_len);\n\t\t\tdev->stats.rx_dropped++;\n\t\t}\n\t\tissue_and_wait(dev, RxDiscard);\n\t}\n\n\treturn 0;\n}\n\nstatic int\nboomerang_rx(struct net_device *dev)\n{\n\tstruct vortex_private *vp = netdev_priv(dev);\n\tint entry = vp->cur_rx % RX_RING_SIZE;\n\tvoid __iomem *ioaddr = vp->ioaddr;\n\tint rx_status;\n\tint rx_work_limit = RX_RING_SIZE;\n\n\tif (vortex_debug > 5)\n\t\tpr_debug(\"boomerang_rx(): status %4.4x\\n\", ioread16(ioaddr+EL3_STATUS));\n\n\twhile ((rx_status = le32_to_cpu(vp->rx_ring[entry].status)) & RxDComplete){\n\t\tif (--rx_work_limit < 0)\n\t\t\tbreak;\n\t\tif (rx_status & RxDError) {  \n\t\t\tunsigned char rx_error = rx_status >> 16;\n\t\t\tif (vortex_debug > 2)\n\t\t\t\tpr_debug(\" Rx error: status %2.2x.\\n\", rx_error);\n\t\t\tdev->stats.rx_errors++;\n\t\t\tif (rx_error & 0x01)  dev->stats.rx_over_errors++;\n\t\t\tif (rx_error & 0x02)  dev->stats.rx_length_errors++;\n\t\t\tif (rx_error & 0x04)  dev->stats.rx_frame_errors++;\n\t\t\tif (rx_error & 0x08)  dev->stats.rx_crc_errors++;\n\t\t\tif (rx_error & 0x10)  dev->stats.rx_length_errors++;\n\t\t} else {\n\t\t\t \n\t\t\tint pkt_len = rx_status & 0x1fff;\n\t\t\tstruct sk_buff *skb, *newskb;\n\t\t\tdma_addr_t newdma;\n\t\t\tdma_addr_t dma = le32_to_cpu(vp->rx_ring[entry].addr);\n\n\t\t\tif (vortex_debug > 4)\n\t\t\t\tpr_debug(\"Receiving packet size %d status %4.4x.\\n\",\n\t\t\t\t\t   pkt_len, rx_status);\n\n\t\t\t \n\t\t\tif (pkt_len < rx_copybreak &&\n\t\t\t    (skb = netdev_alloc_skb(dev, pkt_len + 2)) != NULL) {\n\t\t\t\tskb_reserve(skb, 2);\t \n\t\t\t\tdma_sync_single_for_cpu(vp->gendev, dma, PKT_BUF_SZ, DMA_FROM_DEVICE);\n\t\t\t\t \n\t\t\t\tskb_put_data(skb, vp->rx_skbuff[entry]->data,\n\t\t\t\t\t     pkt_len);\n\t\t\t\tdma_sync_single_for_device(vp->gendev, dma, PKT_BUF_SZ, DMA_FROM_DEVICE);\n\t\t\t\tvp->rx_copy++;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tnewskb = netdev_alloc_skb_ip_align(dev, PKT_BUF_SZ);\n\t\t\t\tif (!newskb) {\n\t\t\t\t\tdev->stats.rx_dropped++;\n\t\t\t\t\tgoto clear_complete;\n\t\t\t\t}\n\t\t\t\tnewdma = dma_map_single(vp->gendev, newskb->data,\n\t\t\t\t\t\t\tPKT_BUF_SZ, DMA_FROM_DEVICE);\n\t\t\t\tif (dma_mapping_error(vp->gendev, newdma)) {\n\t\t\t\t\tdev->stats.rx_dropped++;\n\t\t\t\t\tconsume_skb(newskb);\n\t\t\t\t\tgoto clear_complete;\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tskb = vp->rx_skbuff[entry];\n\t\t\t\tvp->rx_skbuff[entry] = newskb;\n\t\t\t\tvp->rx_ring[entry].addr = cpu_to_le32(newdma);\n\t\t\t\tskb_put(skb, pkt_len);\n\t\t\t\tdma_unmap_single(vp->gendev, dma, PKT_BUF_SZ, DMA_FROM_DEVICE);\n\t\t\t\tvp->rx_nocopy++;\n\t\t\t}\n\t\t\tskb->protocol = eth_type_trans(skb, dev);\n\t\t\t{\t\t\t\t\t \n\t\t\t\tint csum_bits = rx_status & 0xee000000;\n\t\t\t\tif (csum_bits &&\n\t\t\t\t\t(csum_bits == (IPChksumValid | TCPChksumValid) ||\n\t\t\t\t\t csum_bits == (IPChksumValid | UDPChksumValid))) {\n\t\t\t\t\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\t\t\t\t\tvp->rx_csumhits++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tnetif_rx(skb);\n\t\t\tdev->stats.rx_packets++;\n\t\t}\n\nclear_complete:\n\t\tvp->rx_ring[entry].status = 0;\t \n\t\tiowrite16(UpUnstall, ioaddr + EL3_CMD);\n\t\tentry = (++vp->cur_rx) % RX_RING_SIZE;\n\t}\n\treturn 0;\n}\n\nstatic void\nvortex_down(struct net_device *dev, int final_down)\n{\n\tstruct vortex_private *vp = netdev_priv(dev);\n\tvoid __iomem *ioaddr = vp->ioaddr;\n\n\tnetdev_reset_queue(dev);\n\tnetif_stop_queue(dev);\n\n\tdel_timer_sync(&vp->timer);\n\n\t \n\tiowrite16(StatsDisable, ioaddr + EL3_CMD);\n\n\t \n\tiowrite16(RxDisable, ioaddr + EL3_CMD);\n\tiowrite16(TxDisable, ioaddr + EL3_CMD);\n\n\t \n\tset_8021q_mode(dev, 0);\n\n\tif (dev->if_port == XCVR_10base2)\n\t\t \n\t\tiowrite16(StopCoax, ioaddr + EL3_CMD);\n\n\tiowrite16(SetIntrEnb | 0x0000, ioaddr + EL3_CMD);\n\n\tupdate_stats(ioaddr, dev);\n\tif (vp->full_bus_master_rx)\n\t\tiowrite32(0, ioaddr + UpListPtr);\n\tif (vp->full_bus_master_tx)\n\t\tiowrite32(0, ioaddr + DownListPtr);\n\n\tif (final_down && VORTEX_PCI(vp)) {\n\t\tvp->pm_state_valid = 1;\n\t\tpci_save_state(VORTEX_PCI(vp));\n\t\tacpi_set_WOL(dev);\n\t}\n}\n\nstatic int\nvortex_close(struct net_device *dev)\n{\n\tstruct vortex_private *vp = netdev_priv(dev);\n\tvoid __iomem *ioaddr = vp->ioaddr;\n\tint i;\n\n\tif (netif_device_present(dev))\n\t\tvortex_down(dev, 1);\n\n\tif (vortex_debug > 1) {\n\t\tpr_debug(\"%s: vortex_close() status %4.4x, Tx status %2.2x.\\n\",\n\t\t\t   dev->name, ioread16(ioaddr + EL3_STATUS), ioread8(ioaddr + TxStatus));\n\t\tpr_debug(\"%s: vortex close stats: rx_nocopy %d rx_copy %d\"\n\t\t\t   \" tx_queued %d Rx pre-checksummed %d.\\n\",\n\t\t\t   dev->name, vp->rx_nocopy, vp->rx_copy, vp->queued_packet, vp->rx_csumhits);\n\t}\n\n#if DO_ZEROCOPY\n\tif (vp->rx_csumhits &&\n\t    (vp->drv_flags & HAS_HWCKSM) == 0 &&\n\t    (vp->card_idx >= MAX_UNITS || hw_checksums[vp->card_idx] == -1)) {\n\t\tpr_warn(\"%s supports hardware checksums, and we're not using them!\\n\",\n\t\t\tdev->name);\n\t}\n#endif\n\n\tfree_irq(dev->irq, dev);\n\n\tif (vp->full_bus_master_rx) {  \n\t\tfor (i = 0; i < RX_RING_SIZE; i++)\n\t\t\tif (vp->rx_skbuff[i]) {\n\t\t\t\tdma_unmap_single(vp->gendev, le32_to_cpu(vp->rx_ring[i].addr),\n\t\t\t\t\t\t\t\t\tPKT_BUF_SZ, DMA_FROM_DEVICE);\n\t\t\t\tdev_kfree_skb(vp->rx_skbuff[i]);\n\t\t\t\tvp->rx_skbuff[i] = NULL;\n\t\t\t}\n\t}\n\tif (vp->full_bus_master_tx) {  \n\t\tfor (i = 0; i < TX_RING_SIZE; i++) {\n\t\t\tif (vp->tx_skbuff[i]) {\n\t\t\t\tstruct sk_buff *skb = vp->tx_skbuff[i];\n#if DO_ZEROCOPY\n\t\t\t\tint k;\n\n\t\t\t\tfor (k=0; k<=skb_shinfo(skb)->nr_frags; k++)\n\t\t\t\t\t\tdma_unmap_single(vp->gendev,\n\t\t\t\t\t\t\t\t\t\t le32_to_cpu(vp->tx_ring[i].frag[k].addr),\n\t\t\t\t\t\t\t\t\t\t le32_to_cpu(vp->tx_ring[i].frag[k].length)&0xFFF,\n\t\t\t\t\t\t\t\t\t\t DMA_TO_DEVICE);\n#else\n\t\t\t\tdma_unmap_single(vp->gendev, le32_to_cpu(vp->tx_ring[i].addr), skb->len, DMA_TO_DEVICE);\n#endif\n\t\t\t\tdev_kfree_skb(skb);\n\t\t\t\tvp->tx_skbuff[i] = NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void\ndump_tx_ring(struct net_device *dev)\n{\n\tif (vortex_debug > 0) {\n\t\tstruct vortex_private *vp = netdev_priv(dev);\n\t\tvoid __iomem *ioaddr = vp->ioaddr;\n\n\t\tif (vp->full_bus_master_tx) {\n\t\t\tint i;\n\t\t\tint stalled = ioread32(ioaddr + PktStatus) & 0x04;\t \n\n\t\t\tpr_err(\"  Flags; bus-master %d, dirty %d(%d) current %d(%d)\\n\",\n\t\t\t\t\tvp->full_bus_master_tx,\n\t\t\t\t\tvp->dirty_tx, vp->dirty_tx % TX_RING_SIZE,\n\t\t\t\t\tvp->cur_tx, vp->cur_tx % TX_RING_SIZE);\n\t\t\tpr_err(\"  Transmit list %8.8x vs. %p.\\n\",\n\t\t\t\t   ioread32(ioaddr + DownListPtr),\n\t\t\t\t   &vp->tx_ring[vp->dirty_tx % TX_RING_SIZE]);\n\t\t\tissue_and_wait(dev, DownStall);\n\t\t\tfor (i = 0; i < TX_RING_SIZE; i++) {\n\t\t\t\tunsigned int length;\n\n#if DO_ZEROCOPY\n\t\t\t\tlength = le32_to_cpu(vp->tx_ring[i].frag[0].length);\n#else\n\t\t\t\tlength = le32_to_cpu(vp->tx_ring[i].length);\n#endif\n\t\t\t\tpr_err(\"  %d: @%p  length %8.8x status %8.8x\\n\",\n\t\t\t\t\t   i, &vp->tx_ring[i], length,\n\t\t\t\t\t   le32_to_cpu(vp->tx_ring[i].status));\n\t\t\t}\n\t\t\tif (!stalled)\n\t\t\t\tiowrite16(DownUnstall, ioaddr + EL3_CMD);\n\t\t}\n\t}\n}\n\nstatic struct net_device_stats *vortex_get_stats(struct net_device *dev)\n{\n\tstruct vortex_private *vp = netdev_priv(dev);\n\tvoid __iomem *ioaddr = vp->ioaddr;\n\tunsigned long flags;\n\n\tif (netif_device_present(dev)) {\t \n\t\tspin_lock_irqsave (&vp->lock, flags);\n\t\tupdate_stats(ioaddr, dev);\n\t\tspin_unlock_irqrestore (&vp->lock, flags);\n\t}\n\treturn &dev->stats;\n}\n\n \nstatic void update_stats(void __iomem *ioaddr, struct net_device *dev)\n{\n\tstruct vortex_private *vp = netdev_priv(dev);\n\n\t \n\t \n\tdev->stats.tx_carrier_errors\t\t+= window_read8(vp, 6, 0);\n\tdev->stats.tx_heartbeat_errors\t\t+= window_read8(vp, 6, 1);\n\tdev->stats.tx_window_errors\t\t+= window_read8(vp, 6, 4);\n\tdev->stats.rx_fifo_errors\t\t+= window_read8(vp, 6, 5);\n\tdev->stats.tx_packets\t\t\t+= window_read8(vp, 6, 6);\n\tdev->stats.tx_packets\t\t\t+= (window_read8(vp, 6, 9) &\n\t\t\t\t\t\t    0x30) << 4;\n\t \t\t\twindow_read8(vp, 6, 7);    \n\t \n\tdev->stats.rx_bytes \t\t\t+= window_read16(vp, 6, 10);\n\tdev->stats.tx_bytes \t\t\t+= window_read16(vp, 6, 12);\n\t \n\tvp->xstats.tx_multiple_collisions\t+= window_read8(vp, 6, 2);\n\tvp->xstats.tx_single_collisions         += window_read8(vp, 6, 3);\n\tvp->xstats.tx_deferred\t\t\t+= window_read8(vp, 6, 8);\n\tvp->xstats.rx_bad_ssd\t\t\t+= window_read8(vp, 4, 12);\n\n\tdev->stats.collisions = vp->xstats.tx_multiple_collisions\n\t\t+ vp->xstats.tx_single_collisions\n\t\t+ vp->xstats.tx_max_collisions;\n\n\t{\n\t\tu8 up = window_read8(vp, 4, 13);\n\t\tdev->stats.rx_bytes += (up & 0x0f) << 16;\n\t\tdev->stats.tx_bytes += (up & 0xf0) << 12;\n\t}\n}\n\nstatic int vortex_nway_reset(struct net_device *dev)\n{\n\tstruct vortex_private *vp = netdev_priv(dev);\n\n\treturn mii_nway_restart(&vp->mii);\n}\n\nstatic int vortex_get_link_ksettings(struct net_device *dev,\n\t\t\t\t     struct ethtool_link_ksettings *cmd)\n{\n\tstruct vortex_private *vp = netdev_priv(dev);\n\n\tmii_ethtool_get_link_ksettings(&vp->mii, cmd);\n\n\treturn 0;\n}\n\nstatic int vortex_set_link_ksettings(struct net_device *dev,\n\t\t\t\t     const struct ethtool_link_ksettings *cmd)\n{\n\tstruct vortex_private *vp = netdev_priv(dev);\n\n\treturn mii_ethtool_set_link_ksettings(&vp->mii, cmd);\n}\n\nstatic u32 vortex_get_msglevel(struct net_device *dev)\n{\n\treturn vortex_debug;\n}\n\nstatic void vortex_set_msglevel(struct net_device *dev, u32 dbg)\n{\n\tvortex_debug = dbg;\n}\n\nstatic int vortex_get_sset_count(struct net_device *dev, int sset)\n{\n\tswitch (sset) {\n\tcase ETH_SS_STATS:\n\t\treturn VORTEX_NUM_STATS;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic void vortex_get_ethtool_stats(struct net_device *dev,\n\tstruct ethtool_stats *stats, u64 *data)\n{\n\tstruct vortex_private *vp = netdev_priv(dev);\n\tvoid __iomem *ioaddr = vp->ioaddr;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&vp->lock, flags);\n\tupdate_stats(ioaddr, dev);\n\tspin_unlock_irqrestore(&vp->lock, flags);\n\n\tdata[0] = vp->xstats.tx_deferred;\n\tdata[1] = vp->xstats.tx_max_collisions;\n\tdata[2] = vp->xstats.tx_multiple_collisions;\n\tdata[3] = vp->xstats.tx_single_collisions;\n\tdata[4] = vp->xstats.rx_bad_ssd;\n}\n\n\nstatic void vortex_get_strings(struct net_device *dev, u32 stringset, u8 *data)\n{\n\tswitch (stringset) {\n\tcase ETH_SS_STATS:\n\t\tmemcpy(data, &ethtool_stats_keys, sizeof(ethtool_stats_keys));\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\tbreak;\n\t}\n}\n\nstatic void vortex_get_drvinfo(struct net_device *dev,\n\t\t\t\t\tstruct ethtool_drvinfo *info)\n{\n\tstruct vortex_private *vp = netdev_priv(dev);\n\n\tstrscpy(info->driver, DRV_NAME, sizeof(info->driver));\n\tif (VORTEX_PCI(vp)) {\n\t\tstrscpy(info->bus_info, pci_name(VORTEX_PCI(vp)),\n\t\t\tsizeof(info->bus_info));\n\t} else {\n\t\tif (VORTEX_EISA(vp))\n\t\t\tstrscpy(info->bus_info, dev_name(vp->gendev),\n\t\t\t\tsizeof(info->bus_info));\n\t\telse\n\t\t\tsnprintf(info->bus_info, sizeof(info->bus_info),\n\t\t\t\t\"EISA 0x%lx %d\", dev->base_addr, dev->irq);\n\t}\n}\n\nstatic void vortex_get_wol(struct net_device *dev, struct ethtool_wolinfo *wol)\n{\n\tstruct vortex_private *vp = netdev_priv(dev);\n\n\tif (!VORTEX_PCI(vp))\n\t\treturn;\n\n\twol->supported = WAKE_MAGIC;\n\n\twol->wolopts = 0;\n\tif (vp->enable_wol)\n\t\twol->wolopts |= WAKE_MAGIC;\n}\n\nstatic int vortex_set_wol(struct net_device *dev, struct ethtool_wolinfo *wol)\n{\n\tstruct vortex_private *vp = netdev_priv(dev);\n\n\tif (!VORTEX_PCI(vp))\n\t\treturn -EOPNOTSUPP;\n\n\tif (wol->wolopts & ~WAKE_MAGIC)\n\t\treturn -EINVAL;\n\n\tif (wol->wolopts & WAKE_MAGIC)\n\t\tvp->enable_wol = 1;\n\telse\n\t\tvp->enable_wol = 0;\n\tacpi_set_WOL(dev);\n\n\treturn 0;\n}\n\nstatic const struct ethtool_ops vortex_ethtool_ops = {\n\t.get_drvinfo\t\t= vortex_get_drvinfo,\n\t.get_strings            = vortex_get_strings,\n\t.get_msglevel           = vortex_get_msglevel,\n\t.set_msglevel           = vortex_set_msglevel,\n\t.get_ethtool_stats      = vortex_get_ethtool_stats,\n\t.get_sset_count\t\t= vortex_get_sset_count,\n\t.get_link               = ethtool_op_get_link,\n\t.nway_reset             = vortex_nway_reset,\n\t.get_wol                = vortex_get_wol,\n\t.set_wol                = vortex_set_wol,\n\t.get_ts_info\t\t= ethtool_op_get_ts_info,\n\t.get_link_ksettings     = vortex_get_link_ksettings,\n\t.set_link_ksettings     = vortex_set_link_ksettings,\n};\n\n#ifdef CONFIG_PCI\n \nstatic int vortex_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)\n{\n\tint err;\n\tstruct vortex_private *vp = netdev_priv(dev);\n\tpci_power_t state = 0;\n\n\tif(VORTEX_PCI(vp))\n\t\tstate = VORTEX_PCI(vp)->current_state;\n\n\t \n\n\tif(state != 0)\n\t\tpci_set_power_state(VORTEX_PCI(vp), PCI_D0);\n\terr = generic_mii_ioctl(&vp->mii, if_mii(rq), cmd, NULL);\n\tif(state != 0)\n\t\tpci_set_power_state(VORTEX_PCI(vp), state);\n\n\treturn err;\n}\n#endif\n\n\n \nstatic void set_rx_mode(struct net_device *dev)\n{\n\tstruct vortex_private *vp = netdev_priv(dev);\n\tvoid __iomem *ioaddr = vp->ioaddr;\n\tint new_mode;\n\n\tif (dev->flags & IFF_PROMISC) {\n\t\tif (vortex_debug > 3)\n\t\t\tpr_notice(\"%s: Setting promiscuous mode.\\n\", dev->name);\n\t\tnew_mode = SetRxFilter|RxStation|RxMulticast|RxBroadcast|RxProm;\n\t} else\tif (!netdev_mc_empty(dev) || dev->flags & IFF_ALLMULTI) {\n\t\tnew_mode = SetRxFilter|RxStation|RxMulticast|RxBroadcast;\n\t} else\n\t\tnew_mode = SetRxFilter | RxStation | RxBroadcast;\n\n\tiowrite16(new_mode, ioaddr + EL3_CMD);\n}\n\n#if IS_ENABLED(CONFIG_VLAN_8021Q)\n \n\n \n#define VLAN_ETHER_TYPE 0x8100\n\nstatic void set_8021q_mode(struct net_device *dev, int enable)\n{\n\tstruct vortex_private *vp = netdev_priv(dev);\n\tint mac_ctrl;\n\n\tif ((vp->drv_flags&IS_CYCLONE) || (vp->drv_flags&IS_TORNADO)) {\n\t\t \n\n\t\tint max_pkt_size = dev->mtu+14;\t \n\t\tif (enable)\n\t\t\tmax_pkt_size += 4;\t \n\n\t\twindow_write16(vp, max_pkt_size, 3, Wn3_MaxPktSize);\n\n\t\t \n\t\twindow_write16(vp, VLAN_ETHER_TYPE, 7, Wn7_VlanEtherType);\n\t} else {\n\t\t \n\n\t\tvp->large_frames = dev->mtu > 1500 || enable;\n\n\t\tmac_ctrl = window_read16(vp, 3, Wn3_MAC_Ctrl);\n\t\tif (vp->large_frames)\n\t\t\tmac_ctrl |= 0x40;\n\t\telse\n\t\t\tmac_ctrl &= ~0x40;\n\t\twindow_write16(vp, mac_ctrl, 3, Wn3_MAC_Ctrl);\n\t}\n}\n#else\n\nstatic void set_8021q_mode(struct net_device *dev, int enable)\n{\n}\n\n\n#endif\n\n \n\n \nstatic void mdio_delay(struct vortex_private *vp)\n{\n\twindow_read32(vp, 4, Wn4_PhysicalMgmt);\n}\n\n#define MDIO_SHIFT_CLK\t0x01\n#define MDIO_DIR_WRITE\t0x04\n#define MDIO_DATA_WRITE0 (0x00 | MDIO_DIR_WRITE)\n#define MDIO_DATA_WRITE1 (0x02 | MDIO_DIR_WRITE)\n#define MDIO_DATA_READ\t0x02\n#define MDIO_ENB_IN\t\t0x00\n\n \nstatic void mdio_sync(struct vortex_private *vp, int bits)\n{\n\t \n\twhile (-- bits >= 0) {\n\t\twindow_write16(vp, MDIO_DATA_WRITE1, 4, Wn4_PhysicalMgmt);\n\t\tmdio_delay(vp);\n\t\twindow_write16(vp, MDIO_DATA_WRITE1 | MDIO_SHIFT_CLK,\n\t\t\t       4, Wn4_PhysicalMgmt);\n\t\tmdio_delay(vp);\n\t}\n}\n\nstatic int mdio_read(struct net_device *dev, int phy_id, int location)\n{\n\tint i;\n\tstruct vortex_private *vp = netdev_priv(dev);\n\tint read_cmd = (0xf6 << 10) | (phy_id << 5) | location;\n\tunsigned int retval = 0;\n\n\tspin_lock_bh(&vp->mii_lock);\n\n\tif (mii_preamble_required)\n\t\tmdio_sync(vp, 32);\n\n\t \n\tfor (i = 14; i >= 0; i--) {\n\t\tint dataval = (read_cmd&(1<<i)) ? MDIO_DATA_WRITE1 : MDIO_DATA_WRITE0;\n\t\twindow_write16(vp, dataval, 4, Wn4_PhysicalMgmt);\n\t\tmdio_delay(vp);\n\t\twindow_write16(vp, dataval | MDIO_SHIFT_CLK,\n\t\t\t       4, Wn4_PhysicalMgmt);\n\t\tmdio_delay(vp);\n\t}\n\t \n\tfor (i = 19; i > 0; i--) {\n\t\twindow_write16(vp, MDIO_ENB_IN, 4, Wn4_PhysicalMgmt);\n\t\tmdio_delay(vp);\n\t\tretval = (retval << 1) |\n\t\t\t((window_read16(vp, 4, Wn4_PhysicalMgmt) &\n\t\t\t  MDIO_DATA_READ) ? 1 : 0);\n\t\twindow_write16(vp, MDIO_ENB_IN | MDIO_SHIFT_CLK,\n\t\t\t       4, Wn4_PhysicalMgmt);\n\t\tmdio_delay(vp);\n\t}\n\n\tspin_unlock_bh(&vp->mii_lock);\n\n\treturn retval & 0x20000 ? 0xffff : retval>>1 & 0xffff;\n}\n\nstatic void mdio_write(struct net_device *dev, int phy_id, int location, int value)\n{\n\tstruct vortex_private *vp = netdev_priv(dev);\n\tint write_cmd = 0x50020000 | (phy_id << 23) | (location << 18) | value;\n\tint i;\n\n\tspin_lock_bh(&vp->mii_lock);\n\n\tif (mii_preamble_required)\n\t\tmdio_sync(vp, 32);\n\n\t \n\tfor (i = 31; i >= 0; i--) {\n\t\tint dataval = (write_cmd&(1<<i)) ? MDIO_DATA_WRITE1 : MDIO_DATA_WRITE0;\n\t\twindow_write16(vp, dataval, 4, Wn4_PhysicalMgmt);\n\t\tmdio_delay(vp);\n\t\twindow_write16(vp, dataval | MDIO_SHIFT_CLK,\n\t\t\t       4, Wn4_PhysicalMgmt);\n\t\tmdio_delay(vp);\n\t}\n\t \n\tfor (i = 1; i >= 0; i--) {\n\t\twindow_write16(vp, MDIO_ENB_IN, 4, Wn4_PhysicalMgmt);\n\t\tmdio_delay(vp);\n\t\twindow_write16(vp, MDIO_ENB_IN | MDIO_SHIFT_CLK,\n\t\t\t       4, Wn4_PhysicalMgmt);\n\t\tmdio_delay(vp);\n\t}\n\n\tspin_unlock_bh(&vp->mii_lock);\n}\n\n \n \nstatic void acpi_set_WOL(struct net_device *dev)\n{\n\tstruct vortex_private *vp = netdev_priv(dev);\n\tvoid __iomem *ioaddr = vp->ioaddr;\n\n\tdevice_set_wakeup_enable(vp->gendev, vp->enable_wol);\n\n\tif (vp->enable_wol) {\n\t\t \n\t\twindow_write16(vp, 2, 7, 0x0c);\n\t\t \n\t\tiowrite16(SetRxFilter|RxStation|RxMulticast|RxBroadcast, ioaddr + EL3_CMD);\n\t\tiowrite16(RxEnable, ioaddr + EL3_CMD);\n\n\t\tif (pci_enable_wake(VORTEX_PCI(vp), PCI_D3hot, 1)) {\n\t\t\tpr_info(\"%s: WOL not supported.\\n\", pci_name(VORTEX_PCI(vp)));\n\n\t\t\tvp->enable_wol = 0;\n\t\t\treturn;\n\t\t}\n\n\t\tif (VORTEX_PCI(vp)->current_state < PCI_D3hot)\n\t\t\treturn;\n\n\t\t \n\t\tpci_set_power_state(VORTEX_PCI(vp), PCI_D3hot);\n\t}\n}\n\n\nstatic void vortex_remove_one(struct pci_dev *pdev)\n{\n\tstruct net_device *dev = pci_get_drvdata(pdev);\n\tstruct vortex_private *vp;\n\n\tif (!dev) {\n\t\tpr_err(\"vortex_remove_one called for Compaq device!\\n\");\n\t\tBUG();\n\t}\n\n\tvp = netdev_priv(dev);\n\n\tif (vp->cb_fn_base)\n\t\tpci_iounmap(pdev, vp->cb_fn_base);\n\n\tunregister_netdev(dev);\n\n\tpci_set_power_state(pdev, PCI_D0);\t \n\tif (vp->pm_state_valid)\n\t\tpci_restore_state(pdev);\n\tpci_disable_device(pdev);\n\n\t \n\tiowrite16(TotalReset | ((vp->drv_flags & EEPROM_RESET) ? 0x04 : 0x14),\n\t     vp->ioaddr + EL3_CMD);\n\n\tpci_iounmap(pdev, vp->ioaddr);\n\n\tdma_free_coherent(&pdev->dev,\n\t\t\tsizeof(struct boom_rx_desc) * RX_RING_SIZE +\n\t\t\tsizeof(struct boom_tx_desc) * TX_RING_SIZE,\n\t\t\tvp->rx_ring, vp->rx_ring_dma);\n\n\tpci_release_regions(pdev);\n\n\tfree_netdev(dev);\n}\n\n\nstatic struct pci_driver vortex_driver = {\n\t.name\t\t= \"3c59x\",\n\t.probe\t\t= vortex_init_one,\n\t.remove\t\t= vortex_remove_one,\n\t.id_table\t= vortex_pci_tbl,\n\t.driver.pm\t= VORTEX_PM_OPS,\n};\n\n\nstatic int vortex_have_pci;\nstatic int vortex_have_eisa;\n\n\nstatic int __init vortex_init(void)\n{\n\tint pci_rc, eisa_rc;\n\n\tpci_rc = pci_register_driver(&vortex_driver);\n\teisa_rc = vortex_eisa_init();\n\n\tif (pci_rc == 0)\n\t\tvortex_have_pci = 1;\n\tif (eisa_rc > 0)\n\t\tvortex_have_eisa = 1;\n\n\treturn (vortex_have_pci + vortex_have_eisa) ? 0 : -ENODEV;\n}\n\n\nstatic void __exit vortex_eisa_cleanup(void)\n{\n\tvoid __iomem *ioaddr;\n\n#ifdef CONFIG_EISA\n\t \n\teisa_driver_unregister(&vortex_eisa_driver);\n#endif\n\n\tif (compaq_net_device) {\n\t\tioaddr = ioport_map(compaq_net_device->base_addr,\n\t\t                    VORTEX_TOTAL_SIZE);\n\n\t\tunregister_netdev(compaq_net_device);\n\t\tiowrite16(TotalReset, ioaddr + EL3_CMD);\n\t\trelease_region(compaq_net_device->base_addr,\n\t\t               VORTEX_TOTAL_SIZE);\n\n\t\tfree_netdev(compaq_net_device);\n\t}\n}\n\n\nstatic void __exit vortex_cleanup(void)\n{\n\tif (vortex_have_pci)\n\t\tpci_unregister_driver(&vortex_driver);\n\tif (vortex_have_eisa)\n\t\tvortex_eisa_cleanup();\n}\n\n\nmodule_init(vortex_init);\nmodule_exit(vortex_cleanup);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}