{
  "module_name": "emac_rockchip.c",
  "hash_id": "02b3024f3a99dc5f124ad8e17687704dac8df6cd1aea39eac6d5b7c87f13c351",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/arc/emac_rockchip.c",
  "human_readable_source": "\n \n\n#include <linux/etherdevice.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of_net.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n\n#include \"emac.h\"\n\n#define DRV_NAME        \"rockchip_emac\"\n\nstruct emac_rockchip_soc_data {\n\tunsigned int grf_offset;\n\tunsigned int grf_mode_offset;\n\tunsigned int grf_speed_offset;\n\tbool need_div_macclk;\n};\n\nstruct rockchip_priv_data {\n\tstruct arc_emac_priv emac;\n\tstruct regmap *grf;\n\tconst struct emac_rockchip_soc_data *soc_data;\n\tstruct regulator *regulator;\n\tstruct clk *refclk;\n\tstruct clk *macclk;\n};\n\nstatic void emac_rockchip_set_mac_speed(void *priv, unsigned int speed)\n{\n\tstruct rockchip_priv_data *emac = priv;\n\tu32 speed_offset = emac->soc_data->grf_speed_offset;\n\tu32 data;\n\tint err = 0;\n\n\tswitch (speed) {\n\tcase 10:\n\t\tdata = (1 << (speed_offset + 16)) | (0 << speed_offset);\n\t\tbreak;\n\tcase 100:\n\t\tdata = (1 << (speed_offset + 16)) | (1 << speed_offset);\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"speed %u not supported\\n\", speed);\n\t\treturn;\n\t}\n\n\terr = regmap_write(emac->grf, emac->soc_data->grf_offset, data);\n\tif (err)\n\t\tpr_err(\"unable to apply speed %u to grf (%d)\\n\", speed, err);\n}\n\nstatic const struct emac_rockchip_soc_data emac_rk3036_emac_data = {\n\t.grf_offset = 0x140,   .grf_mode_offset = 8,\n\t.grf_speed_offset = 9, .need_div_macclk = 1,\n};\n\nstatic const struct emac_rockchip_soc_data emac_rk3066_emac_data = {\n\t.grf_offset = 0x154,   .grf_mode_offset = 0,\n\t.grf_speed_offset = 1, .need_div_macclk = 0,\n};\n\nstatic const struct emac_rockchip_soc_data emac_rk3188_emac_data = {\n\t.grf_offset = 0x0a4,   .grf_mode_offset = 0,\n\t.grf_speed_offset = 1, .need_div_macclk = 0,\n};\n\nstatic const struct of_device_id emac_rockchip_dt_ids[] = {\n\t{\n\t\t.compatible = \"rockchip,rk3036-emac\",\n\t\t.data = &emac_rk3036_emac_data,\n\t},\n\t{\n\t\t.compatible = \"rockchip,rk3066-emac\",\n\t\t.data = &emac_rk3066_emac_data,\n\t},\n\t{\n\t\t.compatible = \"rockchip,rk3188-emac\",\n\t\t.data = &emac_rk3188_emac_data,\n\t},\n\t{   }\n};\n\nMODULE_DEVICE_TABLE(of, emac_rockchip_dt_ids);\n\nstatic int emac_rockchip_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct net_device *ndev;\n\tstruct rockchip_priv_data *priv;\n\tconst struct of_device_id *match;\n\tphy_interface_t interface;\n\tu32 data;\n\tint err;\n\n\tif (!pdev->dev.of_node)\n\t\treturn -ENODEV;\n\n\tndev = alloc_etherdev(sizeof(struct rockchip_priv_data));\n\tif (!ndev)\n\t\treturn -ENOMEM;\n\tplatform_set_drvdata(pdev, ndev);\n\tSET_NETDEV_DEV(ndev, dev);\n\n\tpriv = netdev_priv(ndev);\n\tpriv->emac.drv_name = DRV_NAME;\n\tpriv->emac.set_mac_speed = emac_rockchip_set_mac_speed;\n\n\terr = of_get_phy_mode(dev->of_node, &interface);\n\tif (err)\n\t\tgoto out_netdev;\n\n\t \n\tif (interface != PHY_INTERFACE_MODE_RMII) {\n\t\tdev_err(dev, \"unsupported phy interface mode %d\\n\", interface);\n\t\terr = -ENOTSUPP;\n\t\tgoto out_netdev;\n\t}\n\n\tpriv->grf = syscon_regmap_lookup_by_phandle(dev->of_node,\n\t\t\t\t\t\t    \"rockchip,grf\");\n\tif (IS_ERR(priv->grf)) {\n\t\tdev_err(dev, \"failed to retrieve global register file (%ld)\\n\",\n\t\t\tPTR_ERR(priv->grf));\n\t\terr = PTR_ERR(priv->grf);\n\t\tgoto out_netdev;\n\t}\n\n\tmatch = of_match_node(emac_rockchip_dt_ids, dev->of_node);\n\tpriv->soc_data = match->data;\n\n\tpriv->emac.clk = devm_clk_get(dev, \"hclk\");\n\tif (IS_ERR(priv->emac.clk)) {\n\t\tdev_err(dev, \"failed to retrieve host clock (%ld)\\n\",\n\t\t\tPTR_ERR(priv->emac.clk));\n\t\terr = PTR_ERR(priv->emac.clk);\n\t\tgoto out_netdev;\n\t}\n\n\tpriv->refclk = devm_clk_get(dev, \"macref\");\n\tif (IS_ERR(priv->refclk)) {\n\t\tdev_err(dev, \"failed to retrieve reference clock (%ld)\\n\",\n\t\t\tPTR_ERR(priv->refclk));\n\t\terr = PTR_ERR(priv->refclk);\n\t\tgoto out_netdev;\n\t}\n\n\terr = clk_prepare_enable(priv->refclk);\n\tif (err) {\n\t\tdev_err(dev, \"failed to enable reference clock (%d)\\n\", err);\n\t\tgoto out_netdev;\n\t}\n\n\t \n\tpriv->regulator = devm_regulator_get_optional(dev, \"phy\");\n\tif (IS_ERR(priv->regulator)) {\n\t\tif (PTR_ERR(priv->regulator) == -EPROBE_DEFER) {\n\t\t\terr = -EPROBE_DEFER;\n\t\t\tgoto out_clk_disable;\n\t\t}\n\t\tdev_err(dev, \"no regulator found\\n\");\n\t\tpriv->regulator = NULL;\n\t}\n\n\tif (priv->regulator) {\n\t\terr = regulator_enable(priv->regulator);\n\t\tif (err) {\n\t\t\tdev_err(dev, \"failed to enable phy-supply (%d)\\n\", err);\n\t\t\tgoto out_clk_disable;\n\t\t}\n\t}\n\n\t \n\tdata = (1 << (priv->soc_data->grf_speed_offset + 16)) |\n\t       (1 << priv->soc_data->grf_speed_offset);\n\t \n\tdata |= (1 << (priv->soc_data->grf_mode_offset + 16)) |\n\t\t(0 << priv->soc_data->grf_mode_offset);\n\n\terr = regmap_write(priv->grf, priv->soc_data->grf_offset, data);\n\tif (err) {\n\t\tdev_err(dev, \"unable to apply initial settings to grf (%d)\\n\",\n\t\t\terr);\n\t\tgoto out_regulator_disable;\n\t}\n\n\t \n\terr = clk_set_rate(priv->refclk, 50000000);\n\tif (err) {\n\t\tdev_err(dev,\n\t\t\t\"failed to change reference clock rate (%d)\\n\", err);\n\t\tgoto out_regulator_disable;\n\t}\n\n\tif (priv->soc_data->need_div_macclk) {\n\t\tpriv->macclk = devm_clk_get(dev, \"macclk\");\n\t\tif (IS_ERR(priv->macclk)) {\n\t\t\tdev_err(dev, \"failed to retrieve mac clock (%ld)\\n\",\n\t\t\t\tPTR_ERR(priv->macclk));\n\t\t\terr = PTR_ERR(priv->macclk);\n\t\t\tgoto out_regulator_disable;\n\t\t}\n\n\t\terr = clk_prepare_enable(priv->macclk);\n\t\tif (err) {\n\t\t\tdev_err(dev, \"failed to enable mac clock (%d)\\n\", err);\n\t\t\tgoto out_regulator_disable;\n\t\t}\n\n\t\t \n\t\terr = clk_set_rate(priv->macclk, 25000000);\n\t\tif (err) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"failed to change mac clock rate (%d)\\n\", err);\n\t\t\tgoto out_clk_disable_macclk;\n\t\t}\n\t}\n\n\terr = arc_emac_probe(ndev, interface);\n\tif (err) {\n\t\tdev_err(dev, \"failed to probe arc emac (%d)\\n\", err);\n\t\tgoto out_clk_disable_macclk;\n\t}\n\n\treturn 0;\n\nout_clk_disable_macclk:\n\tif (priv->soc_data->need_div_macclk)\n\t\tclk_disable_unprepare(priv->macclk);\nout_regulator_disable:\n\tif (priv->regulator)\n\t\tregulator_disable(priv->regulator);\nout_clk_disable:\n\tclk_disable_unprepare(priv->refclk);\nout_netdev:\n\tfree_netdev(ndev);\n\treturn err;\n}\n\nstatic int emac_rockchip_remove(struct platform_device *pdev)\n{\n\tstruct net_device *ndev = platform_get_drvdata(pdev);\n\tstruct rockchip_priv_data *priv = netdev_priv(ndev);\n\n\tarc_emac_remove(ndev);\n\n\tclk_disable_unprepare(priv->refclk);\n\n\tif (priv->regulator)\n\t\tregulator_disable(priv->regulator);\n\n\tif (priv->soc_data->need_div_macclk)\n\t\tclk_disable_unprepare(priv->macclk);\n\n\tfree_netdev(ndev);\n\treturn 0;\n}\n\nstatic struct platform_driver emac_rockchip_driver = {\n\t.probe = emac_rockchip_probe,\n\t.remove = emac_rockchip_remove,\n\t.driver = {\n\t\t.name = DRV_NAME,\n\t\t.of_match_table  = emac_rockchip_dt_ids,\n\t},\n};\n\nmodule_platform_driver(emac_rockchip_driver);\n\nMODULE_AUTHOR(\"Romain Perier <romain.perier@gmail.com>\");\nMODULE_DESCRIPTION(\"Rockchip EMAC platform driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}