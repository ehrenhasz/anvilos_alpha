{
  "module_name": "emac_mdio.c",
  "hash_id": "3146d887dc7f1a1b76e7a387348d8da7bd8da44f6d947635fcdefd480c49ef0f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/arc/emac_mdio.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/of_mdio.h>\n#include <linux/platform_device.h>\n#include <linux/gpio/consumer.h>\n\n#include \"emac.h\"\n\n \n#define ARC_MDIO_COMPLETE_POLL_COUNT\t1\n\n \nstatic int arc_mdio_complete_wait(struct arc_emac_priv *priv)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARC_MDIO_COMPLETE_POLL_COUNT * 40; i++) {\n\t\tunsigned int status = arc_reg_get(priv, R_STATUS);\n\n\t\tstatus &= MDIO_MASK;\n\n\t\tif (status) {\n\t\t\t \n\t\t\tarc_reg_set(priv, R_STATUS, status);\n\t\t\treturn 0;\n\t\t}\n\n\t\tmsleep(25);\n\t}\n\n\treturn -ETIMEDOUT;\n}\n\n \nstatic int arc_mdio_read(struct mii_bus *bus, int phy_addr, int reg_num)\n{\n\tstruct arc_emac_priv *priv = bus->priv;\n\tunsigned int value;\n\tint error;\n\n\tarc_reg_set(priv, R_MDIO,\n\t\t    0x60020000 | (phy_addr << 23) | (reg_num << 18));\n\n\terror = arc_mdio_complete_wait(priv);\n\tif (error < 0)\n\t\treturn error;\n\n\tvalue = arc_reg_get(priv, R_MDIO) & 0xffff;\n\n\tdev_dbg(priv->dev, \"arc_mdio_read(phy_addr=%i, reg_num=%x) = %x\\n\",\n\t\tphy_addr, reg_num, value);\n\n\treturn value;\n}\n\n \nstatic int arc_mdio_write(struct mii_bus *bus, int phy_addr,\n\t\t\t  int reg_num, u16 value)\n{\n\tstruct arc_emac_priv *priv = bus->priv;\n\n\tdev_dbg(priv->dev,\n\t\t\"arc_mdio_write(phy_addr=%i, reg_num=%x, value=%x)\\n\",\n\t\tphy_addr, reg_num, value);\n\n\tarc_reg_set(priv, R_MDIO,\n\t\t    0x50020000 | (phy_addr << 23) | (reg_num << 18) | value);\n\n\treturn arc_mdio_complete_wait(priv);\n}\n\n \nstatic int arc_mdio_reset(struct mii_bus *bus)\n{\n\tstruct arc_emac_priv *priv = bus->priv;\n\tstruct arc_emac_mdio_bus_data *data = &priv->bus_data;\n\n\tif (data->reset_gpio) {\n\t\tgpiod_set_value_cansleep(data->reset_gpio, 1);\n\t\tmsleep(data->msec);\n\t\tgpiod_set_value_cansleep(data->reset_gpio, 0);\n\t}\n\n\treturn 0;\n}\n\n \nint arc_mdio_probe(struct arc_emac_priv *priv)\n{\n\tstruct arc_emac_mdio_bus_data *data = &priv->bus_data;\n\tstruct device_node *np = priv->dev->of_node;\n\tconst char *name = \"Synopsys MII Bus\";\n\tstruct mii_bus *bus;\n\tint error;\n\n\tbus = mdiobus_alloc();\n\tif (!bus)\n\t\treturn -ENOMEM;\n\n\tpriv->bus = bus;\n\tbus->priv = priv;\n\tbus->parent = priv->dev;\n\tbus->name = name;\n\tbus->read = &arc_mdio_read;\n\tbus->write = &arc_mdio_write;\n\tbus->reset = &arc_mdio_reset;\n\n\t \n\tdata->reset_gpio = devm_gpiod_get_optional(priv->dev, \"phy-reset\",\n\t\t\t\t\t\t   GPIOD_OUT_LOW);\n\tif (IS_ERR(data->reset_gpio)) {\n\t\tmdiobus_free(bus);\n\t\treturn dev_err_probe(priv->dev, PTR_ERR(data->reset_gpio),\n\t\t\t\t     \"Failed to request gpio\\n\");\n\t}\n\n\tof_property_read_u32(np, \"phy-reset-duration\", &data->msec);\n\t \n\tif (data->msec > 1000)\n\t\tdata->msec = 1;\n\n\tsnprintf(bus->id, MII_BUS_ID_SIZE, \"%s\", bus->name);\n\n\terror = of_mdiobus_register(bus, priv->dev->of_node);\n\tif (error) {\n\t\tmdiobus_free(bus);\n\t\treturn dev_err_probe(priv->dev, error,\n\t\t\t\t     \"cannot register MDIO bus %s\\n\", name);\n\t}\n\n\treturn 0;\n}\n\n \nint arc_mdio_remove(struct arc_emac_priv *priv)\n{\n\tmdiobus_unregister(priv->bus);\n\tmdiobus_free(priv->bus);\n\tpriv->bus = NULL;\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}