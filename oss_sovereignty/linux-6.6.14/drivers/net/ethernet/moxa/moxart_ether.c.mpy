{
  "module_name": "moxart_ether.c",
  "hash_id": "8ac3ec99dc0e73767cbb2ff90af7f41a2c2671e318ba749ffc3b8f23029ea8c3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/moxa/moxart_ether.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/skbuff.h>\n#include <linux/dma-mapping.h>\n#include <linux/ethtool.h>\n#include <linux/platform_device.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/crc32.h>\n#include <linux/crc32c.h>\n#include <linux/circ_buf.h>\n\n#include \"moxart_ether.h\"\n\nstatic inline void moxart_desc_write(u32 data, __le32 *desc)\n{\n\t*desc = cpu_to_le32(data);\n}\n\nstatic inline u32 moxart_desc_read(__le32 *desc)\n{\n\treturn le32_to_cpu(*desc);\n}\n\nstatic inline void moxart_emac_write(struct net_device *ndev,\n\t\t\t\t     unsigned int reg, unsigned long value)\n{\n\tstruct moxart_mac_priv_t *priv = netdev_priv(ndev);\n\n\twritel(value, priv->base + reg);\n}\n\nstatic void moxart_update_mac_address(struct net_device *ndev)\n{\n\tmoxart_emac_write(ndev, REG_MAC_MS_ADDRESS,\n\t\t\t  ((ndev->dev_addr[0] << 8) | (ndev->dev_addr[1])));\n\tmoxart_emac_write(ndev, REG_MAC_MS_ADDRESS + 4,\n\t\t\t  ((ndev->dev_addr[2] << 24) |\n\t\t\t   (ndev->dev_addr[3] << 16) |\n\t\t\t   (ndev->dev_addr[4] << 8) |\n\t\t\t   (ndev->dev_addr[5])));\n}\n\nstatic int moxart_set_mac_address(struct net_device *ndev, void *addr)\n{\n\tstruct sockaddr *address = addr;\n\n\teth_hw_addr_set(ndev, address->sa_data);\n\tmoxart_update_mac_address(ndev);\n\n\treturn 0;\n}\n\nstatic void moxart_mac_free_memory(struct net_device *ndev)\n{\n\tstruct moxart_mac_priv_t *priv = netdev_priv(ndev);\n\n\tif (priv->tx_desc_base)\n\t\tdma_free_coherent(&priv->pdev->dev,\n\t\t\t\t  TX_REG_DESC_SIZE * TX_DESC_NUM,\n\t\t\t\t  priv->tx_desc_base, priv->tx_base);\n\n\tif (priv->rx_desc_base)\n\t\tdma_free_coherent(&priv->pdev->dev,\n\t\t\t\t  RX_REG_DESC_SIZE * RX_DESC_NUM,\n\t\t\t\t  priv->rx_desc_base, priv->rx_base);\n\n\tkfree(priv->tx_buf_base);\n\tkfree(priv->rx_buf_base);\n}\n\nstatic void moxart_mac_reset(struct net_device *ndev)\n{\n\tstruct moxart_mac_priv_t *priv = netdev_priv(ndev);\n\n\twritel(SW_RST, priv->base + REG_MAC_CTRL);\n\twhile (readl(priv->base + REG_MAC_CTRL) & SW_RST)\n\t\tmdelay(10);\n\n\twritel(0, priv->base + REG_INTERRUPT_MASK);\n\n\tpriv->reg_maccr = RX_BROADPKT | FULLDUP | CRC_APD | RX_FTL;\n}\n\nstatic void moxart_mac_enable(struct net_device *ndev)\n{\n\tstruct moxart_mac_priv_t *priv = netdev_priv(ndev);\n\n\twritel(0x00001010, priv->base + REG_INT_TIMER_CTRL);\n\twritel(0x00000001, priv->base + REG_APOLL_TIMER_CTRL);\n\twritel(0x00000390, priv->base + REG_DMA_BLEN_CTRL);\n\n\tpriv->reg_imr |= (RPKT_FINISH_M | XPKT_FINISH_M);\n\twritel(priv->reg_imr, priv->base + REG_INTERRUPT_MASK);\n\n\tpriv->reg_maccr |= (RCV_EN | XMT_EN | RDMA_EN | XDMA_EN);\n\twritel(priv->reg_maccr, priv->base + REG_MAC_CTRL);\n}\n\nstatic void moxart_mac_setup_desc_ring(struct net_device *ndev)\n{\n\tstruct moxart_mac_priv_t *priv = netdev_priv(ndev);\n\tvoid *desc;\n\tint i;\n\n\tfor (i = 0; i < TX_DESC_NUM; i++) {\n\t\tdesc = priv->tx_desc_base + i * TX_REG_DESC_SIZE;\n\t\tmemset(desc, 0, TX_REG_DESC_SIZE);\n\n\t\tpriv->tx_buf[i] = priv->tx_buf_base + priv->tx_buf_size * i;\n\t}\n\tmoxart_desc_write(TX_DESC1_END, desc + TX_REG_OFFSET_DESC1);\n\n\tpriv->tx_head = 0;\n\tpriv->tx_tail = 0;\n\n\tfor (i = 0; i < RX_DESC_NUM; i++) {\n\t\tdesc = priv->rx_desc_base + i * RX_REG_DESC_SIZE;\n\t\tmemset(desc, 0, RX_REG_DESC_SIZE);\n\t\tmoxart_desc_write(RX_DESC0_DMA_OWN, desc + RX_REG_OFFSET_DESC0);\n\t\tmoxart_desc_write(RX_BUF_SIZE & RX_DESC1_BUF_SIZE_MASK,\n\t\t       desc + RX_REG_OFFSET_DESC1);\n\n\t\tpriv->rx_buf[i] = priv->rx_buf_base + priv->rx_buf_size * i;\n\t\tpriv->rx_mapping[i] = dma_map_single(&priv->pdev->dev,\n\t\t\t\t\t\t     priv->rx_buf[i],\n\t\t\t\t\t\t     priv->rx_buf_size,\n\t\t\t\t\t\t     DMA_FROM_DEVICE);\n\t\tif (dma_mapping_error(&priv->pdev->dev, priv->rx_mapping[i]))\n\t\t\tnetdev_err(ndev, \"DMA mapping error\\n\");\n\n\t\tmoxart_desc_write(priv->rx_mapping[i],\n\t\t       desc + RX_REG_OFFSET_DESC2 + RX_DESC2_ADDRESS_PHYS);\n\t\tmoxart_desc_write((uintptr_t)priv->rx_buf[i],\n\t\t       desc + RX_REG_OFFSET_DESC2 + RX_DESC2_ADDRESS_VIRT);\n\t}\n\tmoxart_desc_write(RX_DESC1_END, desc + RX_REG_OFFSET_DESC1);\n\n\tpriv->rx_head = 0;\n\n\t \n\twritel(priv->tx_base, priv->base + REG_TXR_BASE_ADDRESS);\n\twritel(priv->rx_base, priv->base + REG_RXR_BASE_ADDRESS);\n}\n\nstatic int moxart_mac_open(struct net_device *ndev)\n{\n\tstruct moxart_mac_priv_t *priv = netdev_priv(ndev);\n\n\tnapi_enable(&priv->napi);\n\n\tmoxart_mac_reset(ndev);\n\tmoxart_update_mac_address(ndev);\n\tmoxart_mac_setup_desc_ring(ndev);\n\tmoxart_mac_enable(ndev);\n\tnetif_start_queue(ndev);\n\n\tnetdev_dbg(ndev, \"%s: IMR=0x%x, MACCR=0x%x\\n\",\n\t\t   __func__, readl(priv->base + REG_INTERRUPT_MASK),\n\t\t   readl(priv->base + REG_MAC_CTRL));\n\n\treturn 0;\n}\n\nstatic int moxart_mac_stop(struct net_device *ndev)\n{\n\tstruct moxart_mac_priv_t *priv = netdev_priv(ndev);\n\tint i;\n\n\tnapi_disable(&priv->napi);\n\n\tnetif_stop_queue(ndev);\n\n\t \n\twritel(0, priv->base + REG_INTERRUPT_MASK);\n\n\t \n\twritel(0, priv->base + REG_MAC_CTRL);\n\n\t \n\tfor (i = 0; i < RX_DESC_NUM; i++)\n\t\tdma_unmap_single(&priv->pdev->dev, priv->rx_mapping[i],\n\t\t\t\t priv->rx_buf_size, DMA_FROM_DEVICE);\n\n\treturn 0;\n}\n\nstatic int moxart_rx_poll(struct napi_struct *napi, int budget)\n{\n\tstruct moxart_mac_priv_t *priv = container_of(napi,\n\t\t\t\t\t\t      struct moxart_mac_priv_t,\n\t\t\t\t\t\t      napi);\n\tstruct net_device *ndev = priv->ndev;\n\tstruct sk_buff *skb;\n\tvoid *desc;\n\tunsigned int desc0, len;\n\tint rx_head = priv->rx_head;\n\tint rx = 0;\n\n\twhile (rx < budget) {\n\t\tdesc = priv->rx_desc_base + (RX_REG_DESC_SIZE * rx_head);\n\t\tdesc0 = moxart_desc_read(desc + RX_REG_OFFSET_DESC0);\n\t\trmb();  \n\n\t\tif (desc0 & RX_DESC0_DMA_OWN)\n\t\t\tbreak;\n\n\t\tif (desc0 & (RX_DESC0_ERR | RX_DESC0_CRC_ERR | RX_DESC0_FTL |\n\t\t\t     RX_DESC0_RUNT | RX_DESC0_ODD_NB)) {\n\t\t\tnet_dbg_ratelimited(\"packet error\\n\");\n\t\t\tndev->stats.rx_dropped++;\n\t\t\tndev->stats.rx_errors++;\n\t\t\tgoto rx_next;\n\t\t}\n\n\t\tlen = desc0 & RX_DESC0_FRAME_LEN_MASK;\n\n\t\tif (len > RX_BUF_SIZE)\n\t\t\tlen = RX_BUF_SIZE;\n\n\t\tdma_sync_single_for_cpu(&priv->pdev->dev,\n\t\t\t\t\tpriv->rx_mapping[rx_head],\n\t\t\t\t\tpriv->rx_buf_size, DMA_FROM_DEVICE);\n\t\tskb = netdev_alloc_skb_ip_align(ndev, len);\n\n\t\tif (unlikely(!skb)) {\n\t\t\tnet_dbg_ratelimited(\"netdev_alloc_skb_ip_align failed\\n\");\n\t\t\tndev->stats.rx_dropped++;\n\t\t\tndev->stats.rx_errors++;\n\t\t\tgoto rx_next;\n\t\t}\n\n\t\tmemcpy(skb->data, priv->rx_buf[rx_head], len);\n\t\tskb_put(skb, len);\n\t\tskb->protocol = eth_type_trans(skb, ndev);\n\t\tnapi_gro_receive(&priv->napi, skb);\n\t\trx++;\n\n\t\tndev->stats.rx_packets++;\n\t\tndev->stats.rx_bytes += len;\n\t\tif (desc0 & RX_DESC0_MULTICAST)\n\t\t\tndev->stats.multicast++;\n\nrx_next:\n\t\twmb();  \n\t\tmoxart_desc_write(RX_DESC0_DMA_OWN, desc + RX_REG_OFFSET_DESC0);\n\n\t\trx_head = RX_NEXT(rx_head);\n\t\tpriv->rx_head = rx_head;\n\t}\n\n\tif (rx < budget)\n\t\tnapi_complete_done(napi, rx);\n\n\tpriv->reg_imr |= RPKT_FINISH_M;\n\twritel(priv->reg_imr, priv->base + REG_INTERRUPT_MASK);\n\n\treturn rx;\n}\n\nstatic int moxart_tx_queue_space(struct net_device *ndev)\n{\n\tstruct moxart_mac_priv_t *priv = netdev_priv(ndev);\n\n\treturn CIRC_SPACE(priv->tx_head, priv->tx_tail, TX_DESC_NUM);\n}\n\nstatic void moxart_tx_finished(struct net_device *ndev)\n{\n\tstruct moxart_mac_priv_t *priv = netdev_priv(ndev);\n\tunsigned int tx_head = priv->tx_head;\n\tunsigned int tx_tail = priv->tx_tail;\n\n\twhile (tx_tail != tx_head) {\n\t\tdma_unmap_single(&priv->pdev->dev, priv->tx_mapping[tx_tail],\n\t\t\t\t priv->tx_len[tx_tail], DMA_TO_DEVICE);\n\n\t\tndev->stats.tx_packets++;\n\t\tndev->stats.tx_bytes += priv->tx_skb[tx_tail]->len;\n\n\t\tdev_consume_skb_irq(priv->tx_skb[tx_tail]);\n\t\tpriv->tx_skb[tx_tail] = NULL;\n\n\t\ttx_tail = TX_NEXT(tx_tail);\n\t}\n\tpriv->tx_tail = tx_tail;\n\tif (netif_queue_stopped(ndev) &&\n\t    moxart_tx_queue_space(ndev) >= TX_WAKE_THRESHOLD)\n\t\tnetif_wake_queue(ndev);\n}\n\nstatic irqreturn_t moxart_mac_interrupt(int irq, void *dev_id)\n{\n\tstruct net_device *ndev = (struct net_device *)dev_id;\n\tstruct moxart_mac_priv_t *priv = netdev_priv(ndev);\n\tunsigned int ists = readl(priv->base + REG_INTERRUPT_STATUS);\n\n\tif (ists & XPKT_OK_INT_STS)\n\t\tmoxart_tx_finished(ndev);\n\n\tif (ists & RPKT_FINISH) {\n\t\tif (napi_schedule_prep(&priv->napi)) {\n\t\t\tpriv->reg_imr &= ~RPKT_FINISH_M;\n\t\t\twritel(priv->reg_imr, priv->base + REG_INTERRUPT_MASK);\n\t\t\t__napi_schedule(&priv->napi);\n\t\t}\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic netdev_tx_t moxart_mac_start_xmit(struct sk_buff *skb,\n\t\t\t\t\t struct net_device *ndev)\n{\n\tstruct moxart_mac_priv_t *priv = netdev_priv(ndev);\n\tvoid *desc;\n\tunsigned int len;\n\tunsigned int tx_head;\n\tu32 txdes1;\n\tnetdev_tx_t ret = NETDEV_TX_BUSY;\n\n\tspin_lock_irq(&priv->txlock);\n\n\ttx_head = priv->tx_head;\n\tdesc = priv->tx_desc_base + (TX_REG_DESC_SIZE * tx_head);\n\n\tif (moxart_tx_queue_space(ndev) == 1)\n\t\tnetif_stop_queue(ndev);\n\n\tif (moxart_desc_read(desc + TX_REG_OFFSET_DESC0) & TX_DESC0_DMA_OWN) {\n\t\tnet_dbg_ratelimited(\"no TX space for packet\\n\");\n\t\tndev->stats.tx_dropped++;\n\t\tgoto out_unlock;\n\t}\n\trmb();  \n\n\tlen = skb->len > TX_BUF_SIZE ? TX_BUF_SIZE : skb->len;\n\n\tpriv->tx_mapping[tx_head] = dma_map_single(&priv->pdev->dev, skb->data,\n\t\t\t\t\t\t   len, DMA_TO_DEVICE);\n\tif (dma_mapping_error(&priv->pdev->dev, priv->tx_mapping[tx_head])) {\n\t\tnetdev_err(ndev, \"DMA mapping error\\n\");\n\t\tgoto out_unlock;\n\t}\n\n\tpriv->tx_len[tx_head] = len;\n\tpriv->tx_skb[tx_head] = skb;\n\n\tmoxart_desc_write(priv->tx_mapping[tx_head],\n\t       desc + TX_REG_OFFSET_DESC2 + TX_DESC2_ADDRESS_PHYS);\n\tmoxart_desc_write((uintptr_t)skb->data,\n\t       desc + TX_REG_OFFSET_DESC2 + TX_DESC2_ADDRESS_VIRT);\n\n\tif (skb->len < ETH_ZLEN) {\n\t\tmemset(&skb->data[skb->len],\n\t\t       0, ETH_ZLEN - skb->len);\n\t\tlen = ETH_ZLEN;\n\t}\n\n\tdma_sync_single_for_device(&priv->pdev->dev, priv->tx_mapping[tx_head],\n\t\t\t\t   priv->tx_buf_size, DMA_TO_DEVICE);\n\n\ttxdes1 = TX_DESC1_LTS | TX_DESC1_FTS | (len & TX_DESC1_BUF_SIZE_MASK);\n\tif (tx_head == TX_DESC_NUM_MASK)\n\t\ttxdes1 |= TX_DESC1_END;\n\tmoxart_desc_write(txdes1, desc + TX_REG_OFFSET_DESC1);\n\twmb();  \n\tmoxart_desc_write(TX_DESC0_DMA_OWN, desc + TX_REG_OFFSET_DESC0);\n\n\t \n\twritel(0xffffffff, priv->base + REG_TX_POLL_DEMAND);\n\n\tpriv->tx_head = TX_NEXT(tx_head);\n\n\tnetif_trans_update(ndev);\n\tret = NETDEV_TX_OK;\nout_unlock:\n\tspin_unlock_irq(&priv->txlock);\n\n\treturn ret;\n}\n\nstatic void moxart_mac_setmulticast(struct net_device *ndev)\n{\n\tstruct moxart_mac_priv_t *priv = netdev_priv(ndev);\n\tstruct netdev_hw_addr *ha;\n\tint crc_val;\n\n\tnetdev_for_each_mc_addr(ha, ndev) {\n\t\tcrc_val = crc32_le(~0, ha->addr, ETH_ALEN);\n\t\tcrc_val = (crc_val >> 26) & 0x3f;\n\t\tif (crc_val >= 32) {\n\t\t\twritel(readl(priv->base + REG_MCAST_HASH_TABLE1) |\n\t\t\t       (1UL << (crc_val - 32)),\n\t\t\t       priv->base + REG_MCAST_HASH_TABLE1);\n\t\t} else {\n\t\t\twritel(readl(priv->base + REG_MCAST_HASH_TABLE0) |\n\t\t\t       (1UL << crc_val),\n\t\t\t       priv->base + REG_MCAST_HASH_TABLE0);\n\t\t}\n\t}\n}\n\nstatic void moxart_mac_set_rx_mode(struct net_device *ndev)\n{\n\tstruct moxart_mac_priv_t *priv = netdev_priv(ndev);\n\n\tspin_lock_irq(&priv->txlock);\n\n\t(ndev->flags & IFF_PROMISC) ? (priv->reg_maccr |= RCV_ALL) :\n\t\t\t\t      (priv->reg_maccr &= ~RCV_ALL);\n\n\t(ndev->flags & IFF_ALLMULTI) ? (priv->reg_maccr |= RX_MULTIPKT) :\n\t\t\t\t       (priv->reg_maccr &= ~RX_MULTIPKT);\n\n\tif ((ndev->flags & IFF_MULTICAST) && netdev_mc_count(ndev)) {\n\t\tpriv->reg_maccr |= HT_MULTI_EN;\n\t\tmoxart_mac_setmulticast(ndev);\n\t} else {\n\t\tpriv->reg_maccr &= ~HT_MULTI_EN;\n\t}\n\n\twritel(priv->reg_maccr, priv->base + REG_MAC_CTRL);\n\n\tspin_unlock_irq(&priv->txlock);\n}\n\nstatic const struct net_device_ops moxart_netdev_ops = {\n\t.ndo_open\t\t= moxart_mac_open,\n\t.ndo_stop\t\t= moxart_mac_stop,\n\t.ndo_start_xmit\t\t= moxart_mac_start_xmit,\n\t.ndo_set_rx_mode\t= moxart_mac_set_rx_mode,\n\t.ndo_set_mac_address\t= moxart_set_mac_address,\n\t.ndo_validate_addr\t= eth_validate_addr,\n};\n\nstatic int moxart_mac_probe(struct platform_device *pdev)\n{\n\tstruct device *p_dev = &pdev->dev;\n\tstruct device_node *node = p_dev->of_node;\n\tstruct net_device *ndev;\n\tstruct moxart_mac_priv_t *priv;\n\tstruct resource *res;\n\tunsigned int irq;\n\tint ret;\n\n\tndev = alloc_etherdev(sizeof(struct moxart_mac_priv_t));\n\tif (!ndev)\n\t\treturn -ENOMEM;\n\n\tirq = irq_of_parse_and_map(node, 0);\n\tif (irq <= 0) {\n\t\tnetdev_err(ndev, \"irq_of_parse_and_map failed\\n\");\n\t\tret = -EINVAL;\n\t\tgoto irq_map_fail;\n\t}\n\n\tpriv = netdev_priv(ndev);\n\tpriv->ndev = ndev;\n\tpriv->pdev = pdev;\n\n\tpriv->base = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(priv->base)) {\n\t\tret = PTR_ERR(priv->base);\n\t\tgoto init_fail;\n\t}\n\tndev->base_addr = res->start;\n\n\tret = platform_get_ethdev_address(p_dev, ndev);\n\tif (ret == -EPROBE_DEFER)\n\t\tgoto init_fail;\n\tif (ret)\n\t\teth_hw_addr_random(ndev);\n\tmoxart_update_mac_address(ndev);\n\n\tspin_lock_init(&priv->txlock);\n\n\tpriv->tx_buf_size = TX_BUF_SIZE;\n\tpriv->rx_buf_size = RX_BUF_SIZE;\n\n\tpriv->tx_desc_base = dma_alloc_coherent(p_dev, TX_REG_DESC_SIZE *\n\t\t\t\t\t\tTX_DESC_NUM, &priv->tx_base,\n\t\t\t\t\t\tGFP_DMA | GFP_KERNEL);\n\tif (!priv->tx_desc_base) {\n\t\tret = -ENOMEM;\n\t\tgoto init_fail;\n\t}\n\n\tpriv->rx_desc_base = dma_alloc_coherent(p_dev, RX_REG_DESC_SIZE *\n\t\t\t\t\t\tRX_DESC_NUM, &priv->rx_base,\n\t\t\t\t\t\tGFP_DMA | GFP_KERNEL);\n\tif (!priv->rx_desc_base) {\n\t\tret = -ENOMEM;\n\t\tgoto init_fail;\n\t}\n\n\tpriv->tx_buf_base = kmalloc_array(priv->tx_buf_size, TX_DESC_NUM,\n\t\t\t\t\t  GFP_KERNEL);\n\tif (!priv->tx_buf_base) {\n\t\tret = -ENOMEM;\n\t\tgoto init_fail;\n\t}\n\n\tpriv->rx_buf_base = kmalloc_array(priv->rx_buf_size, RX_DESC_NUM,\n\t\t\t\t\t  GFP_KERNEL);\n\tif (!priv->rx_buf_base) {\n\t\tret = -ENOMEM;\n\t\tgoto init_fail;\n\t}\n\n\tplatform_set_drvdata(pdev, ndev);\n\n\tret = devm_request_irq(p_dev, irq, moxart_mac_interrupt, 0,\n\t\t\t       pdev->name, ndev);\n\tif (ret) {\n\t\tnetdev_err(ndev, \"devm_request_irq failed\\n\");\n\t\tgoto init_fail;\n\t}\n\n\tndev->netdev_ops = &moxart_netdev_ops;\n\tnetif_napi_add_weight(ndev, &priv->napi, moxart_rx_poll, RX_DESC_NUM);\n\tndev->priv_flags |= IFF_UNICAST_FLT;\n\tndev->irq = irq;\n\n\tSET_NETDEV_DEV(ndev, &pdev->dev);\n\n\tret = register_netdev(ndev);\n\tif (ret)\n\t\tgoto init_fail;\n\n\tnetdev_dbg(ndev, \"%s: IRQ=%d address=%pM\\n\",\n\t\t   __func__, ndev->irq, ndev->dev_addr);\n\n\treturn 0;\n\ninit_fail:\n\tnetdev_err(ndev, \"init failed\\n\");\n\tmoxart_mac_free_memory(ndev);\nirq_map_fail:\n\tfree_netdev(ndev);\n\treturn ret;\n}\n\nstatic int moxart_remove(struct platform_device *pdev)\n{\n\tstruct net_device *ndev = platform_get_drvdata(pdev);\n\n\tunregister_netdev(ndev);\n\tdevm_free_irq(&pdev->dev, ndev->irq, ndev);\n\tmoxart_mac_free_memory(ndev);\n\tfree_netdev(ndev);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id moxart_mac_match[] = {\n\t{ .compatible = \"moxa,moxart-mac\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, moxart_mac_match);\n\nstatic struct platform_driver moxart_mac_driver = {\n\t.probe\t= moxart_mac_probe,\n\t.remove\t= moxart_remove,\n\t.driver\t= {\n\t\t.name\t\t= \"moxart-ethernet\",\n\t\t.of_match_table\t= moxart_mac_match,\n\t},\n};\nmodule_platform_driver(moxart_mac_driver);\n\nMODULE_DESCRIPTION(\"MOXART RTL8201CP Ethernet driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Jonas Jensen <jonas.jensen@gmail.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}