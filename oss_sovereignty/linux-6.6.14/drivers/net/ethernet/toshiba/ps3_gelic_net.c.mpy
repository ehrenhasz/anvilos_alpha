{
  "module_name": "ps3_gelic_net.c",
  "hash_id": "044547f6d93449da3ed33b4345217e7a708d8655b4c105f5cb7dadcb53a3538c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/toshiba/ps3_gelic_net.c",
  "human_readable_source": "\n \n\n#undef DEBUG\n\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\n#include <linux/etherdevice.h>\n#include <linux/ethtool.h>\n#include <linux/if_vlan.h>\n\n#include <linux/in.h>\n#include <linux/ip.h>\n#include <linux/tcp.h>\n\n#include <linux/dma-mapping.h>\n#include <net/checksum.h>\n#include <asm/firmware.h>\n#include <asm/ps3.h>\n#include <asm/lv1call.h>\n\n#include \"ps3_gelic_net.h\"\n#include \"ps3_gelic_wireless.h\"\n\n#define DRV_NAME \"Gelic Network Driver\"\n#define DRV_VERSION \"2.0\"\n\nMODULE_AUTHOR(\"SCE Inc.\");\nMODULE_DESCRIPTION(\"Gelic Network driver\");\nMODULE_LICENSE(\"GPL\");\n\n\n \nint gelic_card_set_irq_mask(struct gelic_card *card, u64 mask)\n{\n\tint status;\n\n\tstatus = lv1_net_set_interrupt_mask(bus_id(card), dev_id(card),\n\t\t\t\t\t    mask, 0);\n\tif (status)\n\t\tdev_info(ctodev(card),\n\t\t\t \"%s failed %d\\n\", __func__, status);\n\treturn status;\n}\n\nstatic void gelic_card_rx_irq_on(struct gelic_card *card)\n{\n\tcard->irq_mask |= GELIC_CARD_RXINT;\n\tgelic_card_set_irq_mask(card, card->irq_mask);\n}\nstatic void gelic_card_rx_irq_off(struct gelic_card *card)\n{\n\tcard->irq_mask &= ~GELIC_CARD_RXINT;\n\tgelic_card_set_irq_mask(card, card->irq_mask);\n}\n\nstatic void gelic_card_get_ether_port_status(struct gelic_card *card,\n\t\t\t\t\t     int inform)\n{\n\tu64 v2;\n\tstruct net_device *ether_netdev;\n\n\tlv1_net_control(bus_id(card), dev_id(card),\n\t\t\tGELIC_LV1_GET_ETH_PORT_STATUS,\n\t\t\tGELIC_LV1_VLAN_TX_ETHERNET_0, 0, 0,\n\t\t\t&card->ether_port_status, &v2);\n\n\tif (inform) {\n\t\tether_netdev = card->netdev[GELIC_PORT_ETHERNET_0];\n\t\tif (card->ether_port_status & GELIC_LV1_ETHER_LINK_UP)\n\t\t\tnetif_carrier_on(ether_netdev);\n\t\telse\n\t\t\tnetif_carrier_off(ether_netdev);\n\t}\n}\n\n \nstatic enum gelic_descr_dma_status\ngelic_descr_get_status(struct gelic_descr *descr)\n{\n\treturn be32_to_cpu(descr->dmac_cmd_status) & GELIC_DESCR_DMA_STAT_MASK;\n}\n\nstatic int gelic_card_set_link_mode(struct gelic_card *card, int mode)\n{\n\tint status;\n\tu64 v1, v2;\n\n\tstatus = lv1_net_control(bus_id(card), dev_id(card),\n\t\t\t\t GELIC_LV1_SET_NEGOTIATION_MODE,\n\t\t\t\t GELIC_LV1_PHY_ETHERNET_0, mode, 0, &v1, &v2);\n\tif (status) {\n\t\tpr_info(\"%s: failed setting negotiation mode %d\\n\", __func__,\n\t\t\tstatus);\n\t\treturn -EBUSY;\n\t}\n\n\tcard->link_mode = mode;\n\treturn 0;\n}\n\n \nstatic void gelic_card_disable_txdmac(struct gelic_card *card)\n{\n\tint status;\n\n\t \n\tstatus = lv1_net_stop_tx_dma(bus_id(card), dev_id(card));\n\tif (status)\n\t\tdev_err(ctodev(card),\n\t\t\t\"lv1_net_stop_tx_dma failed, status=%d\\n\", status);\n}\n\n \nstatic void gelic_card_enable_rxdmac(struct gelic_card *card)\n{\n\tint status;\n\n#ifdef DEBUG\n\tif (gelic_descr_get_status(card->rx_chain.head) !=\n\t    GELIC_DESCR_DMA_CARDOWNED) {\n\t\tprintk(KERN_ERR \"%s: status=%x\\n\", __func__,\n\t\t       be32_to_cpu(card->rx_chain.head->dmac_cmd_status));\n\t\tprintk(KERN_ERR \"%s: nextphy=%x\\n\", __func__,\n\t\t       be32_to_cpu(card->rx_chain.head->next_descr_addr));\n\t\tprintk(KERN_ERR \"%s: head=%p\\n\", __func__,\n\t\t       card->rx_chain.head);\n\t}\n#endif\n\tstatus = lv1_net_start_rx_dma(bus_id(card), dev_id(card),\n\t\t\t\tcard->rx_chain.head->bus_addr, 0);\n\tif (status)\n\t\tdev_info(ctodev(card),\n\t\t\t \"lv1_net_start_rx_dma failed, status=%d\\n\", status);\n}\n\n \nstatic void gelic_card_disable_rxdmac(struct gelic_card *card)\n{\n\tint status;\n\n\t \n\tstatus = lv1_net_stop_rx_dma(bus_id(card), dev_id(card));\n\tif (status)\n\t\tdev_err(ctodev(card),\n\t\t\t\"lv1_net_stop_rx_dma failed, %d\\n\", status);\n}\n\n \nstatic void gelic_descr_set_status(struct gelic_descr *descr,\n\t\t\t\t   enum gelic_descr_dma_status status)\n{\n\tdescr->dmac_cmd_status = cpu_to_be32(status |\n\t\t\t(be32_to_cpu(descr->dmac_cmd_status) &\n\t\t\t ~GELIC_DESCR_DMA_STAT_MASK));\n\t \n\twmb();\n}\n\n \nstatic void gelic_card_reset_chain(struct gelic_card *card,\n\t\t\t\t   struct gelic_descr_chain *chain,\n\t\t\t\t   struct gelic_descr *start_descr)\n{\n\tstruct gelic_descr *descr;\n\n\tfor (descr = start_descr; start_descr != descr->next; descr++) {\n\t\tgelic_descr_set_status(descr, GELIC_DESCR_DMA_CARDOWNED);\n\t\tdescr->next_descr_addr = cpu_to_be32(descr->next->bus_addr);\n\t}\n\n\tchain->head = start_descr;\n\tchain->tail = (descr - 1);\n\n\t(descr - 1)->next_descr_addr = 0;\n}\n\nvoid gelic_card_up(struct gelic_card *card)\n{\n\tpr_debug(\"%s: called\\n\", __func__);\n\tmutex_lock(&card->updown_lock);\n\tif (atomic_inc_return(&card->users) == 1) {\n\t\tpr_debug(\"%s: real do\\n\", __func__);\n\t\t \n\t\tgelic_card_set_irq_mask(card, card->irq_mask);\n\t\t \n\t\tgelic_card_enable_rxdmac(card);\n\n\t\tnapi_enable(&card->napi);\n\t}\n\tmutex_unlock(&card->updown_lock);\n\tpr_debug(\"%s: done\\n\", __func__);\n}\n\nvoid gelic_card_down(struct gelic_card *card)\n{\n\tu64 mask;\n\tpr_debug(\"%s: called\\n\", __func__);\n\tmutex_lock(&card->updown_lock);\n\tif (atomic_dec_if_positive(&card->users) == 0) {\n\t\tpr_debug(\"%s: real do\\n\", __func__);\n\t\tnapi_disable(&card->napi);\n\t\t \n\t\tmask = card->irq_mask & (GELIC_CARD_WLAN_EVENT_RECEIVED |\n\t\t\t\t\t GELIC_CARD_WLAN_COMMAND_COMPLETED);\n\t\tgelic_card_set_irq_mask(card, mask);\n\t\t \n\t\tgelic_card_disable_rxdmac(card);\n\t\tgelic_card_reset_chain(card, &card->rx_chain,\n\t\t\t\t       card->descr + GELIC_NET_TX_DESCRIPTORS);\n\t\t \n\t\tgelic_card_disable_txdmac(card);\n\t}\n\tmutex_unlock(&card->updown_lock);\n\tpr_debug(\"%s: done\\n\", __func__);\n}\n\n \nstatic void gelic_card_free_chain(struct gelic_card *card,\n\t\t\t\t  struct gelic_descr *descr_in)\n{\n\tstruct gelic_descr *descr;\n\n\tfor (descr = descr_in; descr && descr->bus_addr; descr = descr->next) {\n\t\tdma_unmap_single(ctodev(card), descr->bus_addr,\n\t\t\t\t GELIC_DESCR_SIZE, DMA_BIDIRECTIONAL);\n\t\tdescr->bus_addr = 0;\n\t}\n}\n\n \nstatic int gelic_card_init_chain(struct gelic_card *card,\n\t\t\t\t struct gelic_descr_chain *chain,\n\t\t\t\t struct gelic_descr *start_descr, int no)\n{\n\tint i;\n\tstruct gelic_descr *descr;\n\n\tdescr = start_descr;\n\tmemset(descr, 0, sizeof(*descr) * no);\n\n\t \n\tfor (i = 0; i < no; i++, descr++) {\n\t\tdma_addr_t cpu_addr;\n\n\t\tgelic_descr_set_status(descr, GELIC_DESCR_DMA_NOT_IN_USE);\n\n\t\tcpu_addr = dma_map_single(ctodev(card), descr,\n\t\t\t\t\t  GELIC_DESCR_SIZE, DMA_BIDIRECTIONAL);\n\n\t\tif (dma_mapping_error(ctodev(card), cpu_addr))\n\t\t\tgoto iommu_error;\n\n\t\tdescr->bus_addr = cpu_to_be32(cpu_addr);\n\t\tdescr->next = descr + 1;\n\t\tdescr->prev = descr - 1;\n\t}\n\t \n\t(descr - 1)->next = start_descr;\n\tstart_descr->prev = (descr - 1);\n\n\t \n\tdescr = start_descr;\n\tfor (i = 0; i < no; i++, descr++) {\n\t\tdescr->next_descr_addr = cpu_to_be32(descr->next->bus_addr);\n\t}\n\n\tchain->head = start_descr;\n\tchain->tail = start_descr;\n\n\t \n\t(descr - 1)->next_descr_addr = 0;\n\n\treturn 0;\n\niommu_error:\n\tfor (i--, descr--; 0 <= i; i--, descr--)\n\t\tif (descr->bus_addr)\n\t\t\tdma_unmap_single(ctodev(card), descr->bus_addr,\n\t\t\t\t\t GELIC_DESCR_SIZE,\n\t\t\t\t\t DMA_BIDIRECTIONAL);\n\treturn -ENOMEM;\n}\n\n \nstatic int gelic_descr_prepare_rx(struct gelic_card *card,\n\t\t\t\t  struct gelic_descr *descr)\n{\n\tstatic const unsigned int rx_skb_size =\n\t\tALIGN(GELIC_NET_MAX_FRAME, GELIC_NET_RXBUF_ALIGN) +\n\t\tGELIC_NET_RXBUF_ALIGN - 1;\n\tdma_addr_t cpu_addr;\n\tint offset;\n\n\tif (gelic_descr_get_status(descr) !=  GELIC_DESCR_DMA_NOT_IN_USE)\n\t\tdev_info(ctodev(card), \"%s: ERROR status\\n\", __func__);\n\n\tdescr->skb = netdev_alloc_skb(*card->netdev, rx_skb_size);\n\tif (!descr->skb) {\n\t\tdescr->buf_addr = 0;  \n\t\treturn -ENOMEM;\n\t}\n\tdescr->buf_size = cpu_to_be32(rx_skb_size);\n\tdescr->dmac_cmd_status = 0;\n\tdescr->result_size = 0;\n\tdescr->valid_size = 0;\n\tdescr->data_error = 0;\n\n\toffset = ((unsigned long)descr->skb->data) &\n\t\t(GELIC_NET_RXBUF_ALIGN - 1);\n\tif (offset)\n\t\tskb_reserve(descr->skb, GELIC_NET_RXBUF_ALIGN - offset);\n\t \n\tcpu_addr = dma_map_single(ctodev(card), descr->skb->data,\n\t\t\t\t  GELIC_NET_MAX_FRAME, DMA_FROM_DEVICE);\n\tdescr->buf_addr = cpu_to_be32(cpu_addr);\n\tif (dma_mapping_error(ctodev(card), cpu_addr)) {\n\t\tdev_kfree_skb_any(descr->skb);\n\t\tdescr->skb = NULL;\n\t\tdev_info(ctodev(card),\n\t\t\t \"%s:Could not iommu-map rx buffer\\n\", __func__);\n\t\tgelic_descr_set_status(descr, GELIC_DESCR_DMA_NOT_IN_USE);\n\t\treturn -ENOMEM;\n\t} else {\n\t\tgelic_descr_set_status(descr, GELIC_DESCR_DMA_CARDOWNED);\n\t\treturn 0;\n\t}\n}\n\n \nstatic void gelic_card_release_rx_chain(struct gelic_card *card)\n{\n\tstruct gelic_descr *descr = card->rx_chain.head;\n\n\tdo {\n\t\tif (descr->skb) {\n\t\t\tdma_unmap_single(ctodev(card),\n\t\t\t\t\t be32_to_cpu(descr->buf_addr),\n\t\t\t\t\t descr->skb->len,\n\t\t\t\t\t DMA_FROM_DEVICE);\n\t\t\tdescr->buf_addr = 0;\n\t\t\tdev_kfree_skb_any(descr->skb);\n\t\t\tdescr->skb = NULL;\n\t\t\tgelic_descr_set_status(descr,\n\t\t\t\t\t       GELIC_DESCR_DMA_NOT_IN_USE);\n\t\t}\n\t\tdescr = descr->next;\n\t} while (descr != card->rx_chain.head);\n}\n\n \nstatic int gelic_card_fill_rx_chain(struct gelic_card *card)\n{\n\tstruct gelic_descr *descr = card->rx_chain.head;\n\tint ret;\n\n\tdo {\n\t\tif (!descr->skb) {\n\t\t\tret = gelic_descr_prepare_rx(card, descr);\n\t\t\tif (ret)\n\t\t\t\tgoto rewind;\n\t\t}\n\t\tdescr = descr->next;\n\t} while (descr != card->rx_chain.head);\n\n\treturn 0;\nrewind:\n\tgelic_card_release_rx_chain(card);\n\treturn ret;\n}\n\n \nstatic int gelic_card_alloc_rx_skbs(struct gelic_card *card)\n{\n\tstruct gelic_descr_chain *chain;\n\tint ret;\n\tchain = &card->rx_chain;\n\tret = gelic_card_fill_rx_chain(card);\n\tchain->tail = card->rx_top->prev;  \n\treturn ret;\n}\n\n \nstatic void gelic_descr_release_tx(struct gelic_card *card,\n\t\t\t\t       struct gelic_descr *descr)\n{\n\tstruct sk_buff *skb = descr->skb;\n\n\tBUG_ON(!(be32_to_cpu(descr->data_status) & GELIC_DESCR_TX_TAIL));\n\n\tdma_unmap_single(ctodev(card), be32_to_cpu(descr->buf_addr), skb->len,\n\t\t\t DMA_TO_DEVICE);\n\tdev_kfree_skb_any(skb);\n\n\tdescr->buf_addr = 0;\n\tdescr->buf_size = 0;\n\tdescr->next_descr_addr = 0;\n\tdescr->result_size = 0;\n\tdescr->valid_size = 0;\n\tdescr->data_status = 0;\n\tdescr->data_error = 0;\n\tdescr->skb = NULL;\n\n\t \n\tgelic_descr_set_status(descr, GELIC_DESCR_DMA_NOT_IN_USE);\n}\n\nstatic void gelic_card_stop_queues(struct gelic_card *card)\n{\n\tnetif_stop_queue(card->netdev[GELIC_PORT_ETHERNET_0]);\n\n\tif (card->netdev[GELIC_PORT_WIRELESS])\n\t\tnetif_stop_queue(card->netdev[GELIC_PORT_WIRELESS]);\n}\nstatic void gelic_card_wake_queues(struct gelic_card *card)\n{\n\tnetif_wake_queue(card->netdev[GELIC_PORT_ETHERNET_0]);\n\n\tif (card->netdev[GELIC_PORT_WIRELESS])\n\t\tnetif_wake_queue(card->netdev[GELIC_PORT_WIRELESS]);\n}\n \nstatic void gelic_card_release_tx_chain(struct gelic_card *card, int stop)\n{\n\tstruct gelic_descr_chain *tx_chain;\n\tenum gelic_descr_dma_status status;\n\tstruct net_device *netdev;\n\tint release = 0;\n\n\tfor (tx_chain = &card->tx_chain;\n\t     tx_chain->head != tx_chain->tail && tx_chain->tail;\n\t     tx_chain->tail = tx_chain->tail->next) {\n\t\tstatus = gelic_descr_get_status(tx_chain->tail);\n\t\tnetdev = tx_chain->tail->skb->dev;\n\t\tswitch (status) {\n\t\tcase GELIC_DESCR_DMA_RESPONSE_ERROR:\n\t\tcase GELIC_DESCR_DMA_PROTECTION_ERROR:\n\t\tcase GELIC_DESCR_DMA_FORCE_END:\n\t\t\tif (printk_ratelimit())\n\t\t\t\tdev_info(ctodev(card),\n\t\t\t\t\t \"%s: forcing end of tx descriptor \" \\\n\t\t\t\t\t \"with status %x\\n\",\n\t\t\t\t\t __func__, status);\n\t\t\tnetdev->stats.tx_dropped++;\n\t\t\tbreak;\n\n\t\tcase GELIC_DESCR_DMA_COMPLETE:\n\t\t\tif (tx_chain->tail->skb) {\n\t\t\t\tnetdev->stats.tx_packets++;\n\t\t\t\tnetdev->stats.tx_bytes +=\n\t\t\t\t\ttx_chain->tail->skb->len;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase GELIC_DESCR_DMA_CARDOWNED:\n\t\t\t \n\t\tdefault:\n\t\t\t \n\t\t\tif (!stop)\n\t\t\t\tgoto out;\n\t\t}\n\t\tgelic_descr_release_tx(card, tx_chain->tail);\n\t\trelease ++;\n\t}\nout:\n\tif (!stop && release)\n\t\tgelic_card_wake_queues(card);\n}\n\n \nvoid gelic_net_set_multi(struct net_device *netdev)\n{\n\tstruct gelic_card *card = netdev_card(netdev);\n\tstruct netdev_hw_addr *ha;\n\tunsigned int i;\n\tuint8_t *p;\n\tu64 addr;\n\tint status;\n\n\t \n\tstatus = lv1_net_remove_multicast_address(bus_id(card), dev_id(card),\n\t\t\t\t\t\t  0, 1);\n\tif (status)\n\t\tdev_err(ctodev(card),\n\t\t\t\"lv1_net_remove_multicast_address failed %d\\n\",\n\t\t\tstatus);\n\t \n\tstatus = lv1_net_add_multicast_address(bus_id(card), dev_id(card),\n\t\t\t\t\t       GELIC_NET_BROADCAST_ADDR, 0);\n\tif (status)\n\t\tdev_err(ctodev(card),\n\t\t\t\"lv1_net_add_multicast_address failed, %d\\n\",\n\t\t\tstatus);\n\n\tif ((netdev->flags & IFF_ALLMULTI) ||\n\t    (netdev_mc_count(netdev) > GELIC_NET_MC_COUNT_MAX)) {\n\t\tstatus = lv1_net_add_multicast_address(bus_id(card),\n\t\t\t\t\t\t       dev_id(card),\n\t\t\t\t\t\t       0, 1);\n\t\tif (status)\n\t\t\tdev_err(ctodev(card),\n\t\t\t\t\"lv1_net_add_multicast_address failed, %d\\n\",\n\t\t\t\tstatus);\n\t\treturn;\n\t}\n\n\t \n\tnetdev_for_each_mc_addr(ha, netdev) {\n\t\taddr = 0;\n\t\tp = ha->addr;\n\t\tfor (i = 0; i < ETH_ALEN; i++) {\n\t\t\taddr <<= 8;\n\t\t\taddr |= *p++;\n\t\t}\n\t\tstatus = lv1_net_add_multicast_address(bus_id(card),\n\t\t\t\t\t\t       dev_id(card),\n\t\t\t\t\t\t       addr, 0);\n\t\tif (status)\n\t\t\tdev_err(ctodev(card),\n\t\t\t\t\"lv1_net_add_multicast_address failed, %d\\n\",\n\t\t\t\tstatus);\n\t}\n}\n\n \nint gelic_net_stop(struct net_device *netdev)\n{\n\tstruct gelic_card *card;\n\n\tpr_debug(\"%s: start\\n\", __func__);\n\n\tnetif_stop_queue(netdev);\n\tnetif_carrier_off(netdev);\n\n\tcard = netdev_card(netdev);\n\tgelic_card_down(card);\n\n\tpr_debug(\"%s: done\\n\", __func__);\n\treturn 0;\n}\n\n \nstatic struct gelic_descr *\ngelic_card_get_next_tx_descr(struct gelic_card *card)\n{\n\tif (!card->tx_chain.head)\n\t\treturn NULL;\n\t \n\tif (card->tx_chain.tail != card->tx_chain.head->next &&\n\t    gelic_descr_get_status(card->tx_chain.head) ==\n\t    GELIC_DESCR_DMA_NOT_IN_USE)\n\t\treturn card->tx_chain.head;\n\telse\n\t\treturn NULL;\n\n}\n\n \nstatic void gelic_descr_set_tx_cmdstat(struct gelic_descr *descr,\n\t\t\t\t       struct sk_buff *skb)\n{\n\tif (skb->ip_summed != CHECKSUM_PARTIAL)\n\t\tdescr->dmac_cmd_status =\n\t\t\tcpu_to_be32(GELIC_DESCR_DMA_CMD_NO_CHKSUM |\n\t\t\t\t    GELIC_DESCR_TX_DMA_FRAME_TAIL);\n\telse {\n\t\t \n\t\tif (skb->protocol == htons(ETH_P_IP)) {\n\t\t\tif (ip_hdr(skb)->protocol == IPPROTO_TCP)\n\t\t\t\tdescr->dmac_cmd_status =\n\t\t\t\tcpu_to_be32(GELIC_DESCR_DMA_CMD_TCP_CHKSUM |\n\t\t\t\t\t    GELIC_DESCR_TX_DMA_FRAME_TAIL);\n\n\t\t\telse if (ip_hdr(skb)->protocol == IPPROTO_UDP)\n\t\t\t\tdescr->dmac_cmd_status =\n\t\t\t\tcpu_to_be32(GELIC_DESCR_DMA_CMD_UDP_CHKSUM |\n\t\t\t\t\t    GELIC_DESCR_TX_DMA_FRAME_TAIL);\n\t\t\telse\t \n\t\t\t\tdescr->dmac_cmd_status =\n\t\t\t\tcpu_to_be32(GELIC_DESCR_DMA_CMD_NO_CHKSUM |\n\t\t\t\t\t    GELIC_DESCR_TX_DMA_FRAME_TAIL);\n\t\t}\n\t}\n}\n\nstatic struct sk_buff *gelic_put_vlan_tag(struct sk_buff *skb,\n\t\t\t\t\t\t unsigned short tag)\n{\n\tstruct vlan_ethhdr *veth;\n\tstatic unsigned int c;\n\n\tif (skb_headroom(skb) < VLAN_HLEN) {\n\t\tstruct sk_buff *sk_tmp = skb;\n\t\tpr_debug(\"%s: hd=%d c=%ud\\n\", __func__, skb_headroom(skb), c);\n\t\tskb = skb_realloc_headroom(sk_tmp, VLAN_HLEN);\n\t\tif (!skb)\n\t\t\treturn NULL;\n\t\tdev_kfree_skb_any(sk_tmp);\n\t}\n\tveth = skb_push(skb, VLAN_HLEN);\n\n\t \n\tmemmove(skb->data, skb->data + VLAN_HLEN, 2 * ETH_ALEN);\n\n\tveth->h_vlan_proto = cpu_to_be16(ETH_P_8021Q);\n\tveth->h_vlan_TCI = htons(tag);\n\n\treturn skb;\n}\n\n \nstatic int gelic_descr_prepare_tx(struct gelic_card *card,\n\t\t\t\t  struct gelic_descr *descr,\n\t\t\t\t  struct sk_buff *skb)\n{\n\tdma_addr_t buf;\n\n\tif (card->vlan_required) {\n\t\tstruct sk_buff *skb_tmp;\n\t\tenum gelic_port_type type;\n\n\t\ttype = netdev_port(skb->dev)->type;\n\t\tskb_tmp = gelic_put_vlan_tag(skb,\n\t\t\t\t\t     card->vlan[type].tx);\n\t\tif (!skb_tmp)\n\t\t\treturn -ENOMEM;\n\t\tskb = skb_tmp;\n\t}\n\n\tbuf = dma_map_single(ctodev(card), skb->data, skb->len, DMA_TO_DEVICE);\n\n\tif (dma_mapping_error(ctodev(card), buf)) {\n\t\tdev_err(ctodev(card),\n\t\t\t\"dma map 2 failed (%p, %i). Dropping packet\\n\",\n\t\t\tskb->data, skb->len);\n\t\treturn -ENOMEM;\n\t}\n\n\tdescr->buf_addr = cpu_to_be32(buf);\n\tdescr->buf_size = cpu_to_be32(skb->len);\n\tdescr->skb = skb;\n\tdescr->data_status = 0;\n\tdescr->next_descr_addr = 0;  \n\tgelic_descr_set_tx_cmdstat(descr, skb);\n\n\t \n\tcard->tx_chain.head = descr->next;\n\treturn 0;\n}\n\n \nstatic int gelic_card_kick_txdma(struct gelic_card *card,\n\t\t\t\t struct gelic_descr *descr)\n{\n\tint status = 0;\n\n\tif (card->tx_dma_progress)\n\t\treturn 0;\n\n\tif (gelic_descr_get_status(descr) == GELIC_DESCR_DMA_CARDOWNED) {\n\t\tcard->tx_dma_progress = 1;\n\t\tstatus = lv1_net_start_tx_dma(bus_id(card), dev_id(card),\n\t\t\t\t\t      descr->bus_addr, 0);\n\t\tif (status) {\n\t\t\tcard->tx_dma_progress = 0;\n\t\t\tdev_info(ctodev(card), \"lv1_net_start_txdma failed,\" \\\n\t\t\t\t \"status=%d\\n\", status);\n\t\t}\n\t}\n\treturn status;\n}\n\n \nnetdev_tx_t gelic_net_xmit(struct sk_buff *skb, struct net_device *netdev)\n{\n\tstruct gelic_card *card = netdev_card(netdev);\n\tstruct gelic_descr *descr;\n\tint result;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&card->tx_lock, flags);\n\n\tgelic_card_release_tx_chain(card, 0);\n\n\tdescr = gelic_card_get_next_tx_descr(card);\n\tif (!descr) {\n\t\t \n\t\tgelic_card_stop_queues(card);\n\t\tspin_unlock_irqrestore(&card->tx_lock, flags);\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\n\tresult = gelic_descr_prepare_tx(card, descr, skb);\n\tif (result) {\n\t\t \n\t\tnetdev->stats.tx_dropped++;\n\t\tdev_kfree_skb_any(skb);\n\t\tspin_unlock_irqrestore(&card->tx_lock, flags);\n\t\treturn NETDEV_TX_OK;\n\t}\n\t \n\tdescr->prev->next_descr_addr = cpu_to_be32(descr->bus_addr);\n\t \n\twmb();\n\tif (gelic_card_kick_txdma(card, descr)) {\n\t\t \n\t\tnetdev->stats.tx_dropped++;\n\t\t \n\t\tdescr->data_status = cpu_to_be32(GELIC_DESCR_TX_TAIL);\n\t\tgelic_descr_release_tx(card, descr);\n\t\t \n\t\tcard->tx_chain.head = descr;\n\t\t \n\t\tdescr->prev->next_descr_addr = 0;\n\t\tdev_info(ctodev(card), \"%s: kick failure\\n\", __func__);\n\t}\n\n\tspin_unlock_irqrestore(&card->tx_lock, flags);\n\treturn NETDEV_TX_OK;\n}\n\n \nstatic void gelic_net_pass_skb_up(struct gelic_descr *descr,\n\t\t\t\t  struct gelic_card *card,\n\t\t\t\t  struct net_device *netdev)\n\n{\n\tstruct sk_buff *skb = descr->skb;\n\tu32 data_status, data_error;\n\n\tdata_status = be32_to_cpu(descr->data_status);\n\tdata_error = be32_to_cpu(descr->data_error);\n\t \n\tdma_unmap_single(ctodev(card), be32_to_cpu(descr->buf_addr),\n\t\t\t GELIC_NET_MAX_FRAME,\n\t\t\t DMA_FROM_DEVICE);\n\n\tskb_put(skb, be32_to_cpu(descr->valid_size)?\n\t\tbe32_to_cpu(descr->valid_size) :\n\t\tbe32_to_cpu(descr->result_size));\n\tif (!descr->valid_size)\n\t\tdev_info(ctodev(card), \"buffer full %x %x %x\\n\",\n\t\t\t be32_to_cpu(descr->result_size),\n\t\t\t be32_to_cpu(descr->buf_size),\n\t\t\t be32_to_cpu(descr->dmac_cmd_status));\n\n\tdescr->skb = NULL;\n\t \n\tskb_pull(skb, 2);\n\tskb->protocol = eth_type_trans(skb, netdev);\n\n\t \n\tif (netdev->features & NETIF_F_RXCSUM) {\n\t\tif ((data_status & GELIC_DESCR_DATA_STATUS_CHK_MASK) &&\n\t\t    (!(data_error & GELIC_DESCR_DATA_ERROR_CHK_MASK)))\n\t\t\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\t\telse\n\t\t\tskb_checksum_none_assert(skb);\n\t} else\n\t\tskb_checksum_none_assert(skb);\n\n\t \n\tnetdev->stats.rx_packets++;\n\tnetdev->stats.rx_bytes += skb->len;\n\n\t \n\tnetif_receive_skb(skb);\n}\n\n \nstatic int gelic_card_decode_one_descr(struct gelic_card *card)\n{\n\tenum gelic_descr_dma_status status;\n\tstruct gelic_descr_chain *chain = &card->rx_chain;\n\tstruct gelic_descr *descr = chain->head;\n\tstruct net_device *netdev = NULL;\n\tint dmac_chain_ended;\n\n\tstatus = gelic_descr_get_status(descr);\n\n\tif (status == GELIC_DESCR_DMA_CARDOWNED)\n\t\treturn 0;\n\n\tif (status == GELIC_DESCR_DMA_NOT_IN_USE) {\n\t\tdev_dbg(ctodev(card), \"dormant descr? %p\\n\", descr);\n\t\treturn 0;\n\t}\n\n\t \n\tif (card->vlan_required) {\n\t\tunsigned int i;\n\t\tu16 vid;\n\t\tvid = *(u16 *)(descr->skb->data) & VLAN_VID_MASK;\n\t\tfor (i = 0; i < GELIC_PORT_MAX; i++) {\n\t\t\tif (card->vlan[i].rx == vid) {\n\t\t\t\tnetdev = card->netdev[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (GELIC_PORT_MAX <= i) {\n\t\t\tpr_info(\"%s: unknown packet vid=%x\\n\", __func__, vid);\n\t\t\tgoto refill;\n\t\t}\n\t} else\n\t\tnetdev = card->netdev[GELIC_PORT_ETHERNET_0];\n\n\tif ((status == GELIC_DESCR_DMA_RESPONSE_ERROR) ||\n\t    (status == GELIC_DESCR_DMA_PROTECTION_ERROR) ||\n\t    (status == GELIC_DESCR_DMA_FORCE_END)) {\n\t\tdev_info(ctodev(card), \"dropping RX descriptor with state %x\\n\",\n\t\t\t status);\n\t\tnetdev->stats.rx_dropped++;\n\t\tgoto refill;\n\t}\n\n\tif (status == GELIC_DESCR_DMA_BUFFER_FULL) {\n\t\t \n\t\tdev_info(ctodev(card), \"overlength frame\\n\");\n\t\tgoto refill;\n\t}\n\t \n\tif (status != GELIC_DESCR_DMA_FRAME_END) {\n\t\tdev_dbg(ctodev(card), \"RX descriptor with state %x\\n\",\n\t\t\tstatus);\n\t\tgoto refill;\n\t}\n\n\t \n\tgelic_net_pass_skb_up(descr, card, netdev);\nrefill:\n\n\t \n\tdmac_chain_ended =\n\t\tbe32_to_cpu(descr->dmac_cmd_status) &\n\t\tGELIC_DESCR_RX_DMA_CHAIN_END;\n\t \n\tdescr->next_descr_addr = 0;\n\n\t \n\tgelic_descr_set_status(descr, GELIC_DESCR_DMA_NOT_IN_USE);\n\n\t \n\tgelic_descr_prepare_rx(card, descr);\n\n\tchain->tail = descr;\n\tchain->head = descr->next;\n\n\t \n\tdescr->prev->next_descr_addr = cpu_to_be32(descr->bus_addr);\n\n\t \n\n\tif (dmac_chain_ended)\n\t\tgelic_card_enable_rxdmac(card);\n\n\treturn 1;\n}\n\n \nstatic int gelic_net_poll(struct napi_struct *napi, int budget)\n{\n\tstruct gelic_card *card = container_of(napi, struct gelic_card, napi);\n\tint packets_done = 0;\n\n\twhile (packets_done < budget) {\n\t\tif (!gelic_card_decode_one_descr(card))\n\t\t\tbreak;\n\n\t\tpackets_done++;\n\t}\n\n\tif (packets_done < budget) {\n\t\tnapi_complete_done(napi, packets_done);\n\t\tgelic_card_rx_irq_on(card);\n\t}\n\treturn packets_done;\n}\n\n \nstatic irqreturn_t gelic_card_interrupt(int irq, void *ptr)\n{\n\tunsigned long flags;\n\tstruct gelic_card *card = ptr;\n\tu64 status;\n\n\tstatus = card->irq_status;\n\n\tif (!status)\n\t\treturn IRQ_NONE;\n\n\tstatus &= card->irq_mask;\n\n\tif (status & GELIC_CARD_RXINT) {\n\t\tgelic_card_rx_irq_off(card);\n\t\tnapi_schedule(&card->napi);\n\t}\n\n\tif (status & GELIC_CARD_TXINT) {\n\t\tspin_lock_irqsave(&card->tx_lock, flags);\n\t\tcard->tx_dma_progress = 0;\n\t\tgelic_card_release_tx_chain(card, 0);\n\t\t \n\t\tgelic_card_kick_txdma(card, card->tx_chain.tail);\n\t\tspin_unlock_irqrestore(&card->tx_lock, flags);\n\t}\n\n\t \n\tif (status & GELIC_CARD_PORT_STATUS_CHANGED)\n\t\tgelic_card_get_ether_port_status(card, 1);\n\n#ifdef CONFIG_GELIC_WIRELESS\n\tif (status & (GELIC_CARD_WLAN_EVENT_RECEIVED |\n\t\t      GELIC_CARD_WLAN_COMMAND_COMPLETED))\n\t\tgelic_wl_interrupt(card->netdev[GELIC_PORT_WIRELESS], status);\n#endif\n\n\treturn IRQ_HANDLED;\n}\n\n#ifdef CONFIG_NET_POLL_CONTROLLER\n \nvoid gelic_net_poll_controller(struct net_device *netdev)\n{\n\tstruct gelic_card *card = netdev_card(netdev);\n\n\tgelic_card_set_irq_mask(card, 0);\n\tgelic_card_interrupt(netdev->irq, netdev);\n\tgelic_card_set_irq_mask(card, card->irq_mask);\n}\n#endif  \n\n \nint gelic_net_open(struct net_device *netdev)\n{\n\tstruct gelic_card *card = netdev_card(netdev);\n\n\tdev_dbg(ctodev(card), \" -> %s %p\\n\", __func__, netdev);\n\n\tgelic_card_up(card);\n\n\tnetif_start_queue(netdev);\n\tgelic_card_get_ether_port_status(card, 1);\n\n\tdev_dbg(ctodev(card), \" <- %s\\n\", __func__);\n\treturn 0;\n}\n\nvoid gelic_net_get_drvinfo(struct net_device *netdev,\n\t\t\t   struct ethtool_drvinfo *info)\n{\n\tstrscpy(info->driver, DRV_NAME, sizeof(info->driver));\n\tstrscpy(info->version, DRV_VERSION, sizeof(info->version));\n}\n\nstatic int gelic_ether_get_link_ksettings(struct net_device *netdev,\n\t\t\t\t\t  struct ethtool_link_ksettings *cmd)\n{\n\tstruct gelic_card *card = netdev_card(netdev);\n\tu32 supported, advertising;\n\n\tgelic_card_get_ether_port_status(card, 0);\n\n\tif (card->ether_port_status & GELIC_LV1_ETHER_FULL_DUPLEX)\n\t\tcmd->base.duplex = DUPLEX_FULL;\n\telse\n\t\tcmd->base.duplex = DUPLEX_HALF;\n\n\tswitch (card->ether_port_status & GELIC_LV1_ETHER_SPEED_MASK) {\n\tcase GELIC_LV1_ETHER_SPEED_10:\n\t\tcmd->base.speed = SPEED_10;\n\t\tbreak;\n\tcase GELIC_LV1_ETHER_SPEED_100:\n\t\tcmd->base.speed = SPEED_100;\n\t\tbreak;\n\tcase GELIC_LV1_ETHER_SPEED_1000:\n\t\tcmd->base.speed = SPEED_1000;\n\t\tbreak;\n\tdefault:\n\t\tpr_info(\"%s: speed unknown\\n\", __func__);\n\t\tcmd->base.speed = SPEED_10;\n\t\tbreak;\n\t}\n\n\tsupported = SUPPORTED_TP | SUPPORTED_Autoneg |\n\t\t\tSUPPORTED_10baseT_Half | SUPPORTED_10baseT_Full |\n\t\t\tSUPPORTED_100baseT_Half | SUPPORTED_100baseT_Full |\n\t\t\tSUPPORTED_1000baseT_Full;\n\tadvertising = supported;\n\tif (card->link_mode & GELIC_LV1_ETHER_AUTO_NEG) {\n\t\tcmd->base.autoneg = AUTONEG_ENABLE;\n\t} else {\n\t\tcmd->base.autoneg = AUTONEG_DISABLE;\n\t\tadvertising &= ~ADVERTISED_Autoneg;\n\t}\n\tcmd->base.port = PORT_TP;\n\n\tethtool_convert_legacy_u32_to_link_mode(cmd->link_modes.supported,\n\t\t\t\t\t\tsupported);\n\tethtool_convert_legacy_u32_to_link_mode(cmd->link_modes.advertising,\n\t\t\t\t\t\tadvertising);\n\n\treturn 0;\n}\n\nstatic int\ngelic_ether_set_link_ksettings(struct net_device *netdev,\n\t\t\t       const struct ethtool_link_ksettings *cmd)\n{\n\tstruct gelic_card *card = netdev_card(netdev);\n\tu64 mode;\n\tint ret;\n\n\tif (cmd->base.autoneg == AUTONEG_ENABLE) {\n\t\tmode = GELIC_LV1_ETHER_AUTO_NEG;\n\t} else {\n\t\tswitch (cmd->base.speed) {\n\t\tcase SPEED_10:\n\t\t\tmode = GELIC_LV1_ETHER_SPEED_10;\n\t\t\tbreak;\n\t\tcase SPEED_100:\n\t\t\tmode = GELIC_LV1_ETHER_SPEED_100;\n\t\t\tbreak;\n\t\tcase SPEED_1000:\n\t\t\tmode = GELIC_LV1_ETHER_SPEED_1000;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (cmd->base.duplex == DUPLEX_FULL) {\n\t\t\tmode |= GELIC_LV1_ETHER_FULL_DUPLEX;\n\t\t} else if (cmd->base.speed == SPEED_1000) {\n\t\t\tpr_info(\"1000 half duplex is not supported.\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tret = gelic_card_set_link_mode(card, mode);\n\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic void gelic_net_get_wol(struct net_device *netdev,\n\t\t\t      struct ethtool_wolinfo *wol)\n{\n\tif (0 <= ps3_compare_firmware_version(2, 2, 0))\n\t\twol->supported = WAKE_MAGIC;\n\telse\n\t\twol->supported = 0;\n\n\twol->wolopts = ps3_sys_manager_get_wol() ? wol->supported : 0;\n\tmemset(&wol->sopass, 0, sizeof(wol->sopass));\n}\nstatic int gelic_net_set_wol(struct net_device *netdev,\n\t\t\t     struct ethtool_wolinfo *wol)\n{\n\tint status;\n\tstruct gelic_card *card;\n\tu64 v1, v2;\n\n\tif (ps3_compare_firmware_version(2, 2, 0) < 0 ||\n\t    !capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tif (wol->wolopts & ~WAKE_MAGIC)\n\t\treturn -EINVAL;\n\n\tcard = netdev_card(netdev);\n\tif (wol->wolopts & WAKE_MAGIC) {\n\t\tstatus = lv1_net_control(bus_id(card), dev_id(card),\n\t\t\t\t\t GELIC_LV1_SET_WOL,\n\t\t\t\t\t GELIC_LV1_WOL_MAGIC_PACKET,\n\t\t\t\t\t 0, GELIC_LV1_WOL_MP_ENABLE,\n\t\t\t\t\t &v1, &v2);\n\t\tif (status) {\n\t\t\tpr_info(\"%s: enabling WOL failed %d\\n\", __func__,\n\t\t\t\tstatus);\n\t\t\tstatus = -EIO;\n\t\t\tgoto done;\n\t\t}\n\t\tstatus = lv1_net_control(bus_id(card), dev_id(card),\n\t\t\t\t\t GELIC_LV1_SET_WOL,\n\t\t\t\t\t GELIC_LV1_WOL_ADD_MATCH_ADDR,\n\t\t\t\t\t 0, GELIC_LV1_WOL_MATCH_ALL,\n\t\t\t\t\t &v1, &v2);\n\t\tif (!status)\n\t\t\tps3_sys_manager_set_wol(1);\n\t\telse {\n\t\t\tpr_info(\"%s: enabling WOL filter failed %d\\n\",\n\t\t\t\t__func__, status);\n\t\t\tstatus = -EIO;\n\t\t}\n\t} else {\n\t\tstatus = lv1_net_control(bus_id(card), dev_id(card),\n\t\t\t\t\t GELIC_LV1_SET_WOL,\n\t\t\t\t\t GELIC_LV1_WOL_MAGIC_PACKET,\n\t\t\t\t\t 0, GELIC_LV1_WOL_MP_DISABLE,\n\t\t\t\t\t &v1, &v2);\n\t\tif (status) {\n\t\t\tpr_info(\"%s: disabling WOL failed %d\\n\", __func__,\n\t\t\t\tstatus);\n\t\t\tstatus = -EIO;\n\t\t\tgoto done;\n\t\t}\n\t\tstatus = lv1_net_control(bus_id(card), dev_id(card),\n\t\t\t\t\t GELIC_LV1_SET_WOL,\n\t\t\t\t\t GELIC_LV1_WOL_DELETE_MATCH_ADDR,\n\t\t\t\t\t 0, GELIC_LV1_WOL_MATCH_ALL,\n\t\t\t\t\t &v1, &v2);\n\t\tif (!status)\n\t\t\tps3_sys_manager_set_wol(0);\n\t\telse {\n\t\t\tpr_info(\"%s: removing WOL filter failed %d\\n\",\n\t\t\t\t__func__, status);\n\t\t\tstatus = -EIO;\n\t\t}\n\t}\ndone:\n\treturn status;\n}\n\nstatic const struct ethtool_ops gelic_ether_ethtool_ops = {\n\t.get_drvinfo\t= gelic_net_get_drvinfo,\n\t.get_link\t= ethtool_op_get_link,\n\t.get_wol\t= gelic_net_get_wol,\n\t.set_wol\t= gelic_net_set_wol,\n\t.get_link_ksettings = gelic_ether_get_link_ksettings,\n\t.set_link_ksettings = gelic_ether_set_link_ksettings,\n};\n\n \nstatic void gelic_net_tx_timeout_task(struct work_struct *work)\n{\n\tstruct gelic_card *card =\n\t\tcontainer_of(work, struct gelic_card, tx_timeout_task);\n\tstruct net_device *netdev = card->netdev[GELIC_PORT_ETHERNET_0];\n\n\tdev_info(ctodev(card), \"%s:Timed out. Restarting...\\n\", __func__);\n\n\tif (!(netdev->flags & IFF_UP))\n\t\tgoto out;\n\n\tnetif_device_detach(netdev);\n\tgelic_net_stop(netdev);\n\n\tgelic_net_open(netdev);\n\tnetif_device_attach(netdev);\n\nout:\n\tatomic_dec(&card->tx_timeout_task_counter);\n}\n\n \nvoid gelic_net_tx_timeout(struct net_device *netdev, unsigned int txqueue)\n{\n\tstruct gelic_card *card;\n\n\tcard = netdev_card(netdev);\n\tatomic_inc(&card->tx_timeout_task_counter);\n\tif (netdev->flags & IFF_UP)\n\t\tschedule_work(&card->tx_timeout_task);\n\telse\n\t\tatomic_dec(&card->tx_timeout_task_counter);\n}\n\nstatic const struct net_device_ops gelic_netdevice_ops = {\n\t.ndo_open = gelic_net_open,\n\t.ndo_stop = gelic_net_stop,\n\t.ndo_start_xmit = gelic_net_xmit,\n\t.ndo_set_rx_mode = gelic_net_set_multi,\n\t.ndo_tx_timeout = gelic_net_tx_timeout,\n\t.ndo_set_mac_address = eth_mac_addr,\n\t.ndo_validate_addr = eth_validate_addr,\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\t.ndo_poll_controller = gelic_net_poll_controller,\n#endif\n};\n\n \nstatic void gelic_ether_setup_netdev_ops(struct net_device *netdev,\n\t\t\t\t\t struct napi_struct *napi)\n{\n\tnetdev->watchdog_timeo = GELIC_NET_WATCHDOG_TIMEOUT;\n\t \n\tnetif_napi_add(netdev, napi, gelic_net_poll);\n\tnetdev->ethtool_ops = &gelic_ether_ethtool_ops;\n\tnetdev->netdev_ops = &gelic_netdevice_ops;\n}\n\n \nint gelic_net_setup_netdev(struct net_device *netdev, struct gelic_card *card)\n{\n\tint status;\n\tu64 v1, v2;\n\n\tnetdev->hw_features = NETIF_F_IP_CSUM | NETIF_F_RXCSUM;\n\n\tnetdev->features = NETIF_F_IP_CSUM;\n\tif (GELIC_CARD_RX_CSUM_DEFAULT)\n\t\tnetdev->features |= NETIF_F_RXCSUM;\n\n\tstatus = lv1_net_control(bus_id(card), dev_id(card),\n\t\t\t\t GELIC_LV1_GET_MAC_ADDRESS,\n\t\t\t\t 0, 0, 0, &v1, &v2);\n\tv1 <<= 16;\n\tif (status || !is_valid_ether_addr((u8 *)&v1)) {\n\t\tdev_info(ctodev(card),\n\t\t\t \"%s:lv1_net_control GET_MAC_ADDR failed %d\\n\",\n\t\t\t __func__, status);\n\t\treturn -EINVAL;\n\t}\n\teth_hw_addr_set(netdev, (u8 *)&v1);\n\n\tif (card->vlan_required) {\n\t\tnetdev->hard_header_len += VLAN_HLEN;\n\t\t \n\t\tnetdev->features |= NETIF_F_VLAN_CHALLENGED;\n\t}\n\n\t \n\tnetdev->min_mtu = GELIC_NET_MIN_MTU;\n\tnetdev->max_mtu = GELIC_NET_MAX_MTU;\n\n\tstatus = register_netdev(netdev);\n\tif (status) {\n\t\tdev_err(ctodev(card), \"%s:Couldn't register %s %d\\n\",\n\t\t\t__func__, netdev->name, status);\n\t\treturn status;\n\t}\n\tdev_info(ctodev(card), \"%s: MAC addr %pM\\n\",\n\t\t netdev->name, netdev->dev_addr);\n\n\treturn 0;\n}\n\n \n#define GELIC_ALIGN (32)\nstatic struct gelic_card *gelic_alloc_card_net(struct net_device **netdev)\n{\n\tstruct gelic_card *card;\n\tstruct gelic_port *port;\n\tvoid *p;\n\tsize_t alloc_size;\n\t \n\tBUILD_BUG_ON(offsetof(struct gelic_card, irq_status) % 8);\n\tBUILD_BUG_ON(offsetof(struct gelic_card, descr) % 32);\n\talloc_size =\n\t\tsizeof(struct gelic_card) +\n\t\tsizeof(struct gelic_descr) * GELIC_NET_RX_DESCRIPTORS +\n\t\tsizeof(struct gelic_descr) * GELIC_NET_TX_DESCRIPTORS +\n\t\tGELIC_ALIGN - 1;\n\n\tp  = kzalloc(alloc_size, GFP_KERNEL);\n\tif (!p)\n\t\treturn NULL;\n\tcard = PTR_ALIGN(p, GELIC_ALIGN);\n\tcard->unalign = p;\n\n\t \n\t*netdev = alloc_etherdev(sizeof(struct gelic_port));\n\tif (!*netdev) {\n\t\tkfree(card->unalign);\n\t\treturn NULL;\n\t}\n\tport = netdev_priv(*netdev);\n\n\t \n\tport->netdev = *netdev;\n\tport->card = card;\n\tport->type = GELIC_PORT_ETHERNET_0;\n\n\t \n\tcard->netdev[GELIC_PORT_ETHERNET_0] = *netdev;\n\n\tINIT_WORK(&card->tx_timeout_task, gelic_net_tx_timeout_task);\n\tinit_waitqueue_head(&card->waitq);\n\tatomic_set(&card->tx_timeout_task_counter, 0);\n\tmutex_init(&card->updown_lock);\n\tatomic_set(&card->users, 0);\n\n\treturn card;\n}\n\nstatic void gelic_card_get_vlan_info(struct gelic_card *card)\n{\n\tu64 v1, v2;\n\tint status;\n\tunsigned int i;\n\tstruct {\n\t\tint tx;\n\t\tint rx;\n\t} vlan_id_ix[2] = {\n\t\t[GELIC_PORT_ETHERNET_0] = {\n\t\t\t.tx = GELIC_LV1_VLAN_TX_ETHERNET_0,\n\t\t\t.rx = GELIC_LV1_VLAN_RX_ETHERNET_0\n\t\t},\n\t\t[GELIC_PORT_WIRELESS] = {\n\t\t\t.tx = GELIC_LV1_VLAN_TX_WIRELESS,\n\t\t\t.rx = GELIC_LV1_VLAN_RX_WIRELESS\n\t\t}\n\t};\n\n\tfor (i = 0; i < ARRAY_SIZE(vlan_id_ix); i++) {\n\t\t \n\t\tstatus = lv1_net_control(bus_id(card), dev_id(card),\n\t\t\t\t\t GELIC_LV1_GET_VLAN_ID,\n\t\t\t\t\t vlan_id_ix[i].tx,\n\t\t\t\t\t 0, 0, &v1, &v2);\n\t\tif (status || !v1) {\n\t\t\tif (status != LV1_NO_ENTRY)\n\t\t\t\tdev_dbg(ctodev(card),\n\t\t\t\t\t\"get vlan id for tx(%d) failed(%d)\\n\",\n\t\t\t\t\tvlan_id_ix[i].tx, status);\n\t\t\tcard->vlan[i].tx = 0;\n\t\t\tcard->vlan[i].rx = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tcard->vlan[i].tx = (u16)v1;\n\n\t\t \n\t\tstatus = lv1_net_control(bus_id(card), dev_id(card),\n\t\t\t\t\t GELIC_LV1_GET_VLAN_ID,\n\t\t\t\t\t vlan_id_ix[i].rx,\n\t\t\t\t\t 0, 0, &v1, &v2);\n\t\tif (status || !v1) {\n\t\t\tif (status != LV1_NO_ENTRY)\n\t\t\t\tdev_info(ctodev(card),\n\t\t\t\t\t \"get vlan id for rx(%d) failed(%d)\\n\",\n\t\t\t\t\t vlan_id_ix[i].rx, status);\n\t\t\tcard->vlan[i].tx = 0;\n\t\t\tcard->vlan[i].rx = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tcard->vlan[i].rx = (u16)v1;\n\n\t\tdev_dbg(ctodev(card), \"vlan_id[%d] tx=%02x rx=%02x\\n\",\n\t\t\ti, card->vlan[i].tx, card->vlan[i].rx);\n\t}\n\n\tif (card->vlan[GELIC_PORT_ETHERNET_0].tx) {\n\t\tBUG_ON(!card->vlan[GELIC_PORT_WIRELESS].tx);\n\t\tcard->vlan_required = 1;\n\t} else\n\t\tcard->vlan_required = 0;\n\n\t \n\tif (ps3_compare_firmware_version(1, 6, 0) < 0) {\n\t\tcard->vlan[GELIC_PORT_WIRELESS].tx = 0;\n\t\tcard->vlan[GELIC_PORT_WIRELESS].rx = 0;\n\t}\n\n\tdev_info(ctodev(card), \"internal vlan %s\\n\",\n\t\t card->vlan_required? \"enabled\" : \"disabled\");\n}\n \nstatic int ps3_gelic_driver_probe(struct ps3_system_bus_device *dev)\n{\n\tstruct gelic_card *card;\n\tstruct net_device *netdev;\n\tint result;\n\n\tpr_debug(\"%s: called\\n\", __func__);\n\n\tudbg_shutdown_ps3gelic();\n\n\tresult = ps3_open_hv_device(dev);\n\n\tif (result) {\n\t\tdev_dbg(&dev->core, \"%s:ps3_open_hv_device failed\\n\",\n\t\t\t__func__);\n\t\tgoto fail_open;\n\t}\n\n\tresult = ps3_dma_region_create(dev->d_region);\n\n\tif (result) {\n\t\tdev_dbg(&dev->core, \"%s:ps3_dma_region_create failed(%d)\\n\",\n\t\t\t__func__, result);\n\t\tBUG_ON(\"check region type\");\n\t\tgoto fail_dma_region;\n\t}\n\n\t \n\tcard = gelic_alloc_card_net(&netdev);\n\tif (!card) {\n\t\tdev_info(&dev->core, \"%s:gelic_net_alloc_card failed\\n\",\n\t\t\t __func__);\n\t\tresult = -ENOMEM;\n\t\tgoto fail_alloc_card;\n\t}\n\tps3_system_bus_set_drvdata(dev, card);\n\tcard->dev = dev;\n\n\t \n\tgelic_card_get_vlan_info(card);\n\n\tcard->link_mode = GELIC_LV1_ETHER_AUTO_NEG;\n\n\t \n\tresult = lv1_net_set_interrupt_status_indicator(bus_id(card),\n\t\t\t\t\t\t\tdev_id(card),\n\t\tps3_mm_phys_to_lpar(__pa(&card->irq_status)),\n\t\t0);\n\n\tif (result) {\n\t\tdev_dbg(&dev->core,\n\t\t\t\"%s:set_interrupt_status_indicator failed: %s\\n\",\n\t\t\t__func__, ps3_result(result));\n\t\tresult = -EIO;\n\t\tgoto fail_status_indicator;\n\t}\n\n\tresult = ps3_sb_event_receive_port_setup(dev, PS3_BINDING_CPU_ANY,\n\t\t&card->irq);\n\n\tif (result) {\n\t\tdev_info(ctodev(card),\n\t\t\t \"%s:gelic_net_open_device failed (%d)\\n\",\n\t\t\t __func__, result);\n\t\tresult = -EPERM;\n\t\tgoto fail_alloc_irq;\n\t}\n\tresult = request_irq(card->irq, gelic_card_interrupt,\n\t\t\t     0, netdev->name, card);\n\n\tif (result) {\n\t\tdev_info(ctodev(card), \"%s:request_irq failed (%d)\\n\",\n\t\t\t__func__, result);\n\t\tgoto fail_request_irq;\n\t}\n\n\t \n\tcard->irq_mask = GELIC_CARD_RXINT | GELIC_CARD_TXINT |\n\t\tGELIC_CARD_PORT_STATUS_CHANGED;\n\n\n\tresult = gelic_card_init_chain(card, &card->tx_chain,\n\t\t\t\t       card->descr, GELIC_NET_TX_DESCRIPTORS);\n\tif (result)\n\t\tgoto fail_alloc_tx;\n\tresult = gelic_card_init_chain(card, &card->rx_chain,\n\t\t\t\t       card->descr + GELIC_NET_TX_DESCRIPTORS,\n\t\t\t\t       GELIC_NET_RX_DESCRIPTORS);\n\tif (result)\n\t\tgoto fail_alloc_rx;\n\n\t \n\tcard->tx_top = card->tx_chain.head;\n\tcard->rx_top = card->rx_chain.head;\n\tdev_dbg(ctodev(card), \"descr rx %p, tx %p, size %#lx, num %#x\\n\",\n\t\tcard->rx_top, card->tx_top, sizeof(struct gelic_descr),\n\t\tGELIC_NET_RX_DESCRIPTORS);\n\t \n\tresult = gelic_card_alloc_rx_skbs(card);\n\tif (result)\n\t\tgoto fail_alloc_skbs;\n\n\tspin_lock_init(&card->tx_lock);\n\tcard->tx_dma_progress = 0;\n\n\t \n\tnetdev->irq = card->irq;\n\tSET_NETDEV_DEV(netdev, &card->dev->core);\n\tgelic_ether_setup_netdev_ops(netdev, &card->napi);\n\tresult = gelic_net_setup_netdev(netdev, card);\n\tif (result) {\n\t\tdev_dbg(&dev->core, \"%s: setup_netdev failed %d\\n\",\n\t\t\t__func__, result);\n\t\tgoto fail_setup_netdev;\n\t}\n\n#ifdef CONFIG_GELIC_WIRELESS\n\tresult = gelic_wl_driver_probe(card);\n\tif (result) {\n\t\tdev_dbg(&dev->core, \"%s: WL init failed\\n\", __func__);\n\t\tgoto fail_setup_netdev;\n\t}\n#endif\n\tpr_debug(\"%s: done\\n\", __func__);\n\treturn 0;\n\nfail_setup_netdev:\nfail_alloc_skbs:\n\tgelic_card_free_chain(card, card->rx_chain.head);\nfail_alloc_rx:\n\tgelic_card_free_chain(card, card->tx_chain.head);\nfail_alloc_tx:\n\tfree_irq(card->irq, card);\n\tnetdev->irq = 0;\nfail_request_irq:\n\tps3_sb_event_receive_port_destroy(dev, card->irq);\nfail_alloc_irq:\n\tlv1_net_set_interrupt_status_indicator(bus_id(card),\n\t\t\t\t\t       bus_id(card),\n\t\t\t\t\t       0, 0);\nfail_status_indicator:\n\tps3_system_bus_set_drvdata(dev, NULL);\n\tkfree(netdev_card(netdev)->unalign);\n\tfree_netdev(netdev);\nfail_alloc_card:\n\tps3_dma_region_free(dev->d_region);\nfail_dma_region:\n\tps3_close_hv_device(dev);\nfail_open:\n\treturn result;\n}\n\n \n\nstatic void ps3_gelic_driver_remove(struct ps3_system_bus_device *dev)\n{\n\tstruct gelic_card *card = ps3_system_bus_get_drvdata(dev);\n\tstruct net_device *netdev0;\n\tpr_debug(\"%s: called\\n\", __func__);\n\n\t \n\tgelic_card_set_link_mode(card, GELIC_LV1_ETHER_AUTO_NEG);\n\n#ifdef CONFIG_GELIC_WIRELESS\n\tgelic_wl_driver_remove(card);\n#endif\n\t \n\tgelic_card_set_irq_mask(card, 0);\n\n\t \n\tgelic_card_disable_rxdmac(card);\n\tgelic_card_disable_txdmac(card);\n\n\t \n\tgelic_card_release_tx_chain(card, 1);\n\tgelic_card_release_rx_chain(card);\n\n\tgelic_card_free_chain(card, card->tx_top);\n\tgelic_card_free_chain(card, card->rx_top);\n\n\tnetdev0 = card->netdev[GELIC_PORT_ETHERNET_0];\n\t \n\tfree_irq(card->irq, card);\n\tnetdev0->irq = 0;\n\tps3_sb_event_receive_port_destroy(card->dev, card->irq);\n\n\twait_event(card->waitq,\n\t\t   atomic_read(&card->tx_timeout_task_counter) == 0);\n\n\tlv1_net_set_interrupt_status_indicator(bus_id(card), dev_id(card),\n\t\t\t\t\t       0 , 0);\n\n\tunregister_netdev(netdev0);\n\tkfree(netdev_card(netdev0)->unalign);\n\tfree_netdev(netdev0);\n\n\tps3_system_bus_set_drvdata(dev, NULL);\n\n\tps3_dma_region_free(dev->d_region);\n\n\tps3_close_hv_device(dev);\n\n\tpr_debug(\"%s: done\\n\", __func__);\n}\n\nstatic struct ps3_system_bus_driver ps3_gelic_driver = {\n\t.match_id = PS3_MATCH_ID_GELIC,\n\t.probe = ps3_gelic_driver_probe,\n\t.remove = ps3_gelic_driver_remove,\n\t.shutdown = ps3_gelic_driver_remove,\n\t.core.name = \"ps3_gelic_driver\",\n\t.core.owner = THIS_MODULE,\n};\n\nstatic int __init ps3_gelic_driver_init (void)\n{\n\treturn firmware_has_feature(FW_FEATURE_PS3_LV1)\n\t\t? ps3_system_bus_driver_register(&ps3_gelic_driver)\n\t\t: -ENODEV;\n}\n\nstatic void __exit ps3_gelic_driver_exit (void)\n{\n\tps3_system_bus_driver_unregister(&ps3_gelic_driver);\n}\n\nmodule_init(ps3_gelic_driver_init);\nmodule_exit(ps3_gelic_driver_exit);\n\nMODULE_ALIAS(PS3_MODULE_ALIAS_GELIC);\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}