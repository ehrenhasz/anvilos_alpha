{
  "module_name": "spider_net.c",
  "hash_id": "c027a81d9ce674f301ac8d245310daafe2a96511e772609ec6a4b56596e31876",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/toshiba/spider_net.c",
  "human_readable_source": "\n \n\n#include <linux/compiler.h>\n#include <linux/crc32.h>\n#include <linux/delay.h>\n#include <linux/etherdevice.h>\n#include <linux/ethtool.h>\n#include <linux/firmware.h>\n#include <linux/if_vlan.h>\n#include <linux/in.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/gfp.h>\n#include <linux/ioport.h>\n#include <linux/ip.h>\n#include <linux/kernel.h>\n#include <linux/mii.h>\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/device.h>\n#include <linux/pci.h>\n#include <linux/skbuff.h>\n#include <linux/tcp.h>\n#include <linux/types.h>\n#include <linux/vmalloc.h>\n#include <linux/wait.h>\n#include <linux/workqueue.h>\n#include <linux/bitops.h>\n#include <linux/of.h>\n#include <net/checksum.h>\n\n#include \"spider_net.h\"\n\nMODULE_AUTHOR(\"Utz Bacher <utz.bacher@de.ibm.com> and Jens Osterkamp \" \\\n\t      \"<Jens.Osterkamp@de.ibm.com>\");\nMODULE_DESCRIPTION(\"Spider Southbridge Gigabit Ethernet driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(VERSION);\nMODULE_FIRMWARE(SPIDER_NET_FIRMWARE_NAME);\n\nstatic int rx_descriptors = SPIDER_NET_RX_DESCRIPTORS_DEFAULT;\nstatic int tx_descriptors = SPIDER_NET_TX_DESCRIPTORS_DEFAULT;\n\nmodule_param(rx_descriptors, int, 0444);\nmodule_param(tx_descriptors, int, 0444);\n\nMODULE_PARM_DESC(rx_descriptors, \"number of descriptors used \" \\\n\t\t \"in rx chains\");\nMODULE_PARM_DESC(tx_descriptors, \"number of descriptors used \" \\\n\t\t \"in tx chain\");\n\nchar spider_net_driver_name[] = \"spidernet\";\n\nstatic const struct pci_device_id spider_net_pci_tbl[] = {\n\t{ PCI_VENDOR_ID_TOSHIBA_2, PCI_DEVICE_ID_TOSHIBA_SPIDER_NET,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0UL },\n\t{ 0, }\n};\n\nMODULE_DEVICE_TABLE(pci, spider_net_pci_tbl);\n\n \nstatic inline u32\nspider_net_read_reg(struct spider_net_card *card, u32 reg)\n{\n\t \n\treturn in_be32(card->regs + reg);\n}\n\n \nstatic inline void\nspider_net_write_reg(struct spider_net_card *card, u32 reg, u32 value)\n{\n\t \n\tout_be32(card->regs + reg, value);\n}\n\n \nstatic void\nspider_net_write_phy(struct net_device *netdev, int mii_id,\n\t\t     int reg, int val)\n{\n\tstruct spider_net_card *card = netdev_priv(netdev);\n\tu32 writevalue;\n\n\twritevalue = ((u32)mii_id << 21) |\n\t\t((u32)reg << 16) | ((u32)val);\n\n\tspider_net_write_reg(card, SPIDER_NET_GPCWOPCMD, writevalue);\n}\n\n \nstatic int\nspider_net_read_phy(struct net_device *netdev, int mii_id, int reg)\n{\n\tstruct spider_net_card *card = netdev_priv(netdev);\n\tu32 readvalue;\n\n\treadvalue = ((u32)mii_id << 21) | ((u32)reg << 16);\n\tspider_net_write_reg(card, SPIDER_NET_GPCROPCMD, readvalue);\n\n\t \n\tdo {\n\t\treadvalue = spider_net_read_reg(card, SPIDER_NET_GPCROPCMD);\n\t} while (readvalue & SPIDER_NET_GPREXEC);\n\n\treadvalue &= SPIDER_NET_GPRDAT_MASK;\n\n\treturn readvalue;\n}\n\n \nstatic void\nspider_net_setup_aneg(struct spider_net_card *card)\n{\n\tstruct mii_phy *phy = &card->phy;\n\tu32 advertise = 0;\n\tu16 bmsr, estat;\n\n\tbmsr  = spider_net_read_phy(card->netdev, phy->mii_id, MII_BMSR);\n\testat = spider_net_read_phy(card->netdev, phy->mii_id, MII_ESTATUS);\n\n\tif (bmsr & BMSR_10HALF)\n\t\tadvertise |= ADVERTISED_10baseT_Half;\n\tif (bmsr & BMSR_10FULL)\n\t\tadvertise |= ADVERTISED_10baseT_Full;\n\tif (bmsr & BMSR_100HALF)\n\t\tadvertise |= ADVERTISED_100baseT_Half;\n\tif (bmsr & BMSR_100FULL)\n\t\tadvertise |= ADVERTISED_100baseT_Full;\n\n\tif ((bmsr & BMSR_ESTATEN) && (estat & ESTATUS_1000_TFULL))\n\t\tadvertise |= SUPPORTED_1000baseT_Full;\n\tif ((bmsr & BMSR_ESTATEN) && (estat & ESTATUS_1000_THALF))\n\t\tadvertise |= SUPPORTED_1000baseT_Half;\n\n\tsungem_phy_probe(phy, phy->mii_id);\n\tphy->def->ops->setup_aneg(phy, advertise);\n\n}\n\n \nstatic void\nspider_net_rx_irq_off(struct spider_net_card *card)\n{\n\tu32 regvalue;\n\n\tregvalue = SPIDER_NET_INT0_MASK_VALUE & (~SPIDER_NET_RXINT);\n\tspider_net_write_reg(card, SPIDER_NET_GHIINT0MSK, regvalue);\n}\n\n \nstatic void\nspider_net_rx_irq_on(struct spider_net_card *card)\n{\n\tu32 regvalue;\n\n\tregvalue = SPIDER_NET_INT0_MASK_VALUE | SPIDER_NET_RXINT;\n\tspider_net_write_reg(card, SPIDER_NET_GHIINT0MSK, regvalue);\n}\n\n \nstatic void\nspider_net_set_promisc(struct spider_net_card *card)\n{\n\tu32 macu, macl;\n\tstruct net_device *netdev = card->netdev;\n\n\tif (netdev->flags & IFF_PROMISC) {\n\t\t \n\t\tspider_net_write_reg(card, SPIDER_NET_GMRUAFILnR, 0);\n\t\tspider_net_write_reg(card, SPIDER_NET_GMRUAFILnR + 0x04, 0);\n\t\tspider_net_write_reg(card, SPIDER_NET_GMRUA0FIL15R,\n\t\t\t\t     SPIDER_NET_PROMISC_VALUE);\n\t} else {\n\t\tmacu = netdev->dev_addr[0];\n\t\tmacu <<= 8;\n\t\tmacu |= netdev->dev_addr[1];\n\t\tmemcpy(&macl, &netdev->dev_addr[2], sizeof(macl));\n\n\t\tmacu |= SPIDER_NET_UA_DESCR_VALUE;\n\t\tspider_net_write_reg(card, SPIDER_NET_GMRUAFILnR, macu);\n\t\tspider_net_write_reg(card, SPIDER_NET_GMRUAFILnR + 0x04, macl);\n\t\tspider_net_write_reg(card, SPIDER_NET_GMRUA0FIL15R,\n\t\t\t\t     SPIDER_NET_NONPROMISC_VALUE);\n\t}\n}\n\n \nstatic inline int\nspider_net_get_descr_status(struct spider_net_hw_descr *hwdescr)\n{\n\treturn hwdescr->dmac_cmd_status & SPIDER_NET_DESCR_IND_PROC_MASK;\n}\n\n \nstatic void\nspider_net_free_chain(struct spider_net_card *card,\n\t\t      struct spider_net_descr_chain *chain)\n{\n\tstruct spider_net_descr *descr;\n\n\tdescr = chain->ring;\n\tdo {\n\t\tdescr->bus_addr = 0;\n\t\tdescr->hwdescr->next_descr_addr = 0;\n\t\tdescr = descr->next;\n\t} while (descr != chain->ring);\n\n\tdma_free_coherent(&card->pdev->dev, chain->num_desc * sizeof(struct spider_net_hw_descr),\n\t\t\t  chain->hwring, chain->dma_addr);\n}\n\n \nstatic int\nspider_net_init_chain(struct spider_net_card *card,\n\t\t       struct spider_net_descr_chain *chain)\n{\n\tint i;\n\tstruct spider_net_descr *descr;\n\tstruct spider_net_hw_descr *hwdescr;\n\tdma_addr_t buf;\n\tsize_t alloc_size;\n\n\talloc_size = chain->num_desc * sizeof(struct spider_net_hw_descr);\n\n\tchain->hwring = dma_alloc_coherent(&card->pdev->dev, alloc_size,\n\t\t\t\t\t   &chain->dma_addr, GFP_KERNEL);\n\tif (!chain->hwring)\n\t\treturn -ENOMEM;\n\n\t \n\tdescr = chain->ring;\n\thwdescr = chain->hwring;\n\tbuf = chain->dma_addr;\n\tfor (i=0; i < chain->num_desc; i++, descr++, hwdescr++) {\n\t\thwdescr->dmac_cmd_status = SPIDER_NET_DESCR_NOT_IN_USE;\n\t\thwdescr->next_descr_addr = 0;\n\n\t\tdescr->hwdescr = hwdescr;\n\t\tdescr->bus_addr = buf;\n\t\tdescr->next = descr + 1;\n\t\tdescr->prev = descr - 1;\n\n\t\tbuf += sizeof(struct spider_net_hw_descr);\n\t}\n\t \n\t(descr-1)->next = chain->ring;\n\tchain->ring->prev = descr-1;\n\n\tspin_lock_init(&chain->lock);\n\tchain->head = chain->ring;\n\tchain->tail = chain->ring;\n\treturn 0;\n}\n\n \nstatic void\nspider_net_free_rx_chain_contents(struct spider_net_card *card)\n{\n\tstruct spider_net_descr *descr;\n\n\tdescr = card->rx_chain.head;\n\tdo {\n\t\tif (descr->skb) {\n\t\t\tdma_unmap_single(&card->pdev->dev,\n\t\t\t\t\t descr->hwdescr->buf_addr,\n\t\t\t\t\t SPIDER_NET_MAX_FRAME,\n\t\t\t\t\t DMA_BIDIRECTIONAL);\n\t\t\tdev_kfree_skb(descr->skb);\n\t\t\tdescr->skb = NULL;\n\t\t}\n\t\tdescr = descr->next;\n\t} while (descr != card->rx_chain.head);\n}\n\n \nstatic int\nspider_net_prepare_rx_descr(struct spider_net_card *card,\n\t\t\t    struct spider_net_descr *descr)\n{\n\tstruct spider_net_hw_descr *hwdescr = descr->hwdescr;\n\tdma_addr_t buf;\n\tint offset;\n\tint bufsize;\n\n\t \n\tbufsize = (SPIDER_NET_MAX_FRAME + SPIDER_NET_RXBUF_ALIGN - 1) &\n\t\t(~(SPIDER_NET_RXBUF_ALIGN - 1));\n\n\t \n\t \n\tdescr->skb = netdev_alloc_skb(card->netdev,\n\t\t\t\t      bufsize + SPIDER_NET_RXBUF_ALIGN - 1);\n\tif (!descr->skb) {\n\t\tif (netif_msg_rx_err(card) && net_ratelimit())\n\t\t\tdev_err(&card->netdev->dev,\n\t\t\t        \"Not enough memory to allocate rx buffer\\n\");\n\t\tcard->spider_stats.alloc_rx_skb_error++;\n\t\treturn -ENOMEM;\n\t}\n\thwdescr->buf_size = bufsize;\n\thwdescr->result_size = 0;\n\thwdescr->valid_size = 0;\n\thwdescr->data_status = 0;\n\thwdescr->data_error = 0;\n\n\toffset = ((unsigned long)descr->skb->data) &\n\t\t(SPIDER_NET_RXBUF_ALIGN - 1);\n\tif (offset)\n\t\tskb_reserve(descr->skb, SPIDER_NET_RXBUF_ALIGN - offset);\n\t \n\tbuf = dma_map_single(&card->pdev->dev, descr->skb->data,\n\t\t\t     SPIDER_NET_MAX_FRAME, DMA_FROM_DEVICE);\n\tif (dma_mapping_error(&card->pdev->dev, buf)) {\n\t\tdev_kfree_skb_any(descr->skb);\n\t\tdescr->skb = NULL;\n\t\tif (netif_msg_rx_err(card) && net_ratelimit())\n\t\t\tdev_err(&card->netdev->dev, \"Could not iommu-map rx buffer\\n\");\n\t\tcard->spider_stats.rx_iommu_map_error++;\n\t\thwdescr->dmac_cmd_status = SPIDER_NET_DESCR_NOT_IN_USE;\n\t} else {\n\t\thwdescr->buf_addr = buf;\n\t\twmb();\n\t\thwdescr->dmac_cmd_status = SPIDER_NET_DESCR_CARDOWNED |\n\t\t\t\t\t SPIDER_NET_DMAC_NOINTR_COMPLETE;\n\t}\n\n\treturn 0;\n}\n\n \nstatic inline void\nspider_net_enable_rxchtails(struct spider_net_card *card)\n{\n\t \n\tspider_net_write_reg(card, SPIDER_NET_GDADCHA ,\n\t\t\t     card->rx_chain.tail->bus_addr);\n}\n\n \nstatic inline void\nspider_net_enable_rxdmac(struct spider_net_card *card)\n{\n\twmb();\n\tspider_net_write_reg(card, SPIDER_NET_GDADMACCNTR,\n\t\t\t     SPIDER_NET_DMA_RX_VALUE);\n}\n\n \nstatic inline void\nspider_net_disable_rxdmac(struct spider_net_card *card)\n{\n\tspider_net_write_reg(card, SPIDER_NET_GDADMACCNTR,\n\t\t\t     SPIDER_NET_DMA_RX_FEND_VALUE);\n}\n\n \nstatic void\nspider_net_refill_rx_chain(struct spider_net_card *card)\n{\n\tstruct spider_net_descr_chain *chain = &card->rx_chain;\n\tunsigned long flags;\n\n\t \n\tif (!spin_trylock_irqsave(&chain->lock, flags))\n\t\treturn;\n\n\twhile (spider_net_get_descr_status(chain->head->hwdescr) ==\n\t\t\tSPIDER_NET_DESCR_NOT_IN_USE) {\n\t\tif (spider_net_prepare_rx_descr(card, chain->head))\n\t\t\tbreak;\n\t\tchain->head = chain->head->next;\n\t}\n\n\tspin_unlock_irqrestore(&chain->lock, flags);\n}\n\n \nstatic int\nspider_net_alloc_rx_skbs(struct spider_net_card *card)\n{\n\tstruct spider_net_descr_chain *chain = &card->rx_chain;\n\tstruct spider_net_descr *start = chain->tail;\n\tstruct spider_net_descr *descr = start;\n\n\t \n\tdo {\n\t\tdescr->prev->hwdescr->next_descr_addr = descr->bus_addr;\n\t\tdescr = descr->next;\n\t} while (descr != start);\n\n\t \n\tif (spider_net_prepare_rx_descr(card, chain->head))\n\t\tgoto error;\n\telse\n\t\tchain->head = chain->head->next;\n\n\t \n\tspider_net_refill_rx_chain(card);\n\tspider_net_enable_rxdmac(card);\n\treturn 0;\n\nerror:\n\tspider_net_free_rx_chain_contents(card);\n\treturn -ENOMEM;\n}\n\n \nstatic u8\nspider_net_get_multicast_hash(struct net_device *netdev, __u8 *addr)\n{\n\tu32 crc;\n\tu8 hash;\n\tchar addr_for_crc[ETH_ALEN] = { 0, };\n\tint i, bit;\n\n\tfor (i = 0; i < ETH_ALEN * 8; i++) {\n\t\tbit = (addr[i / 8] >> (i % 8)) & 1;\n\t\taddr_for_crc[ETH_ALEN - 1 - i / 8] += bit << (7 - (i % 8));\n\t}\n\n\tcrc = crc32_be(~0, addr_for_crc, netdev->addr_len);\n\n\thash = (crc >> 27);\n\thash <<= 3;\n\thash |= crc & 7;\n\thash &= 0xff;\n\n\treturn hash;\n}\n\n \nstatic void\nspider_net_set_multi(struct net_device *netdev)\n{\n\tstruct netdev_hw_addr *ha;\n\tu8 hash;\n\tint i;\n\tu32 reg;\n\tstruct spider_net_card *card = netdev_priv(netdev);\n\tDECLARE_BITMAP(bitmask, SPIDER_NET_MULTICAST_HASHES);\n\n\tspider_net_set_promisc(card);\n\n\tif (netdev->flags & IFF_ALLMULTI) {\n\t\tbitmap_fill(bitmask, SPIDER_NET_MULTICAST_HASHES);\n\t\tgoto write_hash;\n\t}\n\n\tbitmap_zero(bitmask, SPIDER_NET_MULTICAST_HASHES);\n\n\t \n\t__set_bit(0xfd, bitmask);\n\n\tnetdev_for_each_mc_addr(ha, netdev) {\n\t\thash = spider_net_get_multicast_hash(netdev, ha->addr);\n\t\t__set_bit(hash, bitmask);\n\t}\n\nwrite_hash:\n\tfor (i = 0; i < SPIDER_NET_MULTICAST_HASHES / 4; i++) {\n\t\treg = 0;\n\t\tif (test_bit(i * 4, bitmask))\n\t\t\treg += 0x08;\n\t\treg <<= 8;\n\t\tif (test_bit(i * 4 + 1, bitmask))\n\t\t\treg += 0x08;\n\t\treg <<= 8;\n\t\tif (test_bit(i * 4 + 2, bitmask))\n\t\t\treg += 0x08;\n\t\treg <<= 8;\n\t\tif (test_bit(i * 4 + 3, bitmask))\n\t\t\treg += 0x08;\n\n\t\tspider_net_write_reg(card, SPIDER_NET_GMRMHFILnR + i * 4, reg);\n\t}\n}\n\n \nstatic int\nspider_net_prepare_tx_descr(struct spider_net_card *card,\n\t\t\t    struct sk_buff *skb)\n{\n\tstruct spider_net_descr_chain *chain = &card->tx_chain;\n\tstruct spider_net_descr *descr;\n\tstruct spider_net_hw_descr *hwdescr;\n\tdma_addr_t buf;\n\tunsigned long flags;\n\n\tbuf = dma_map_single(&card->pdev->dev, skb->data, skb->len,\n\t\t\t     DMA_TO_DEVICE);\n\tif (dma_mapping_error(&card->pdev->dev, buf)) {\n\t\tif (netif_msg_tx_err(card) && net_ratelimit())\n\t\t\tdev_err(&card->netdev->dev, \"could not iommu-map packet (%p, %i). \"\n\t\t\t\t  \"Dropping packet\\n\", skb->data, skb->len);\n\t\tcard->spider_stats.tx_iommu_map_error++;\n\t\treturn -ENOMEM;\n\t}\n\n\tspin_lock_irqsave(&chain->lock, flags);\n\tdescr = card->tx_chain.head;\n\tif (descr->next == chain->tail->prev) {\n\t\tspin_unlock_irqrestore(&chain->lock, flags);\n\t\tdma_unmap_single(&card->pdev->dev, buf, skb->len,\n\t\t\t\t DMA_TO_DEVICE);\n\t\treturn -ENOMEM;\n\t}\n\thwdescr = descr->hwdescr;\n\tchain->head = descr->next;\n\n\tdescr->skb = skb;\n\thwdescr->buf_addr = buf;\n\thwdescr->buf_size = skb->len;\n\thwdescr->next_descr_addr = 0;\n\thwdescr->data_status = 0;\n\n\thwdescr->dmac_cmd_status =\n\t\t\tSPIDER_NET_DESCR_CARDOWNED | SPIDER_NET_DMAC_TXFRMTL;\n\tspin_unlock_irqrestore(&chain->lock, flags);\n\n\tif (skb->ip_summed == CHECKSUM_PARTIAL)\n\t\tswitch (ip_hdr(skb)->protocol) {\n\t\tcase IPPROTO_TCP:\n\t\t\thwdescr->dmac_cmd_status |= SPIDER_NET_DMAC_TCP;\n\t\t\tbreak;\n\t\tcase IPPROTO_UDP:\n\t\t\thwdescr->dmac_cmd_status |= SPIDER_NET_DMAC_UDP;\n\t\t\tbreak;\n\t\t}\n\n\t \n\twmb();\n\tdescr->prev->hwdescr->next_descr_addr = descr->bus_addr;\n\n\tnetif_trans_update(card->netdev);  \n\treturn 0;\n}\n\nstatic int\nspider_net_set_low_watermark(struct spider_net_card *card)\n{\n\tstruct spider_net_descr *descr = card->tx_chain.tail;\n\tstruct spider_net_hw_descr *hwdescr;\n\tunsigned long flags;\n\tint status;\n\tint cnt=0;\n\tint i;\n\n\t \n\twhile (descr != card->tx_chain.head) {\n\t\tstatus = descr->hwdescr->dmac_cmd_status & SPIDER_NET_DESCR_NOT_IN_USE;\n\t\tif (status == SPIDER_NET_DESCR_NOT_IN_USE)\n\t\t\tbreak;\n\t\tdescr = descr->next;\n\t\tcnt++;\n\t}\n\n\t \n\tif (cnt < card->tx_chain.num_desc/4)\n\t\treturn cnt;\n\n\t \n\tdescr = card->tx_chain.tail;\n\tcnt = (cnt*3)/4;\n\tfor (i=0;i<cnt; i++)\n\t\tdescr = descr->next;\n\n\t \n\tspin_lock_irqsave(&card->tx_chain.lock, flags);\n\tdescr->hwdescr->dmac_cmd_status |= SPIDER_NET_DESCR_TXDESFLG;\n\tif (card->low_watermark && card->low_watermark != descr) {\n\t\thwdescr = card->low_watermark->hwdescr;\n\t\thwdescr->dmac_cmd_status =\n\t\t     hwdescr->dmac_cmd_status & ~SPIDER_NET_DESCR_TXDESFLG;\n\t}\n\tcard->low_watermark = descr;\n\tspin_unlock_irqrestore(&card->tx_chain.lock, flags);\n\treturn cnt;\n}\n\n \nstatic int\nspider_net_release_tx_chain(struct spider_net_card *card, int brutal)\n{\n\tstruct net_device *dev = card->netdev;\n\tstruct spider_net_descr_chain *chain = &card->tx_chain;\n\tstruct spider_net_descr *descr;\n\tstruct spider_net_hw_descr *hwdescr;\n\tstruct sk_buff *skb;\n\tu32 buf_addr;\n\tunsigned long flags;\n\tint status;\n\n\twhile (1) {\n\t\tspin_lock_irqsave(&chain->lock, flags);\n\t\tif (chain->tail == chain->head) {\n\t\t\tspin_unlock_irqrestore(&chain->lock, flags);\n\t\t\treturn 0;\n\t\t}\n\t\tdescr = chain->tail;\n\t\thwdescr = descr->hwdescr;\n\n\t\tstatus = spider_net_get_descr_status(hwdescr);\n\t\tswitch (status) {\n\t\tcase SPIDER_NET_DESCR_COMPLETE:\n\t\t\tdev->stats.tx_packets++;\n\t\t\tdev->stats.tx_bytes += descr->skb->len;\n\t\t\tbreak;\n\n\t\tcase SPIDER_NET_DESCR_CARDOWNED:\n\t\t\tif (!brutal) {\n\t\t\t\tspin_unlock_irqrestore(&chain->lock, flags);\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\t \n\t\t\tfallthrough;\n\n\t\tcase SPIDER_NET_DESCR_RESPONSE_ERROR:\n\t\tcase SPIDER_NET_DESCR_PROTECTION_ERROR:\n\t\tcase SPIDER_NET_DESCR_FORCE_END:\n\t\t\tif (netif_msg_tx_err(card))\n\t\t\t\tdev_err(&card->netdev->dev, \"forcing end of tx descriptor \"\n\t\t\t\t       \"with status x%02x\\n\", status);\n\t\t\tdev->stats.tx_errors++;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tdev->stats.tx_dropped++;\n\t\t\tif (!brutal) {\n\t\t\t\tspin_unlock_irqrestore(&chain->lock, flags);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\n\t\tchain->tail = descr->next;\n\t\thwdescr->dmac_cmd_status |= SPIDER_NET_DESCR_NOT_IN_USE;\n\t\tskb = descr->skb;\n\t\tdescr->skb = NULL;\n\t\tbuf_addr = hwdescr->buf_addr;\n\t\tspin_unlock_irqrestore(&chain->lock, flags);\n\n\t\t \n\t\tif (skb) {\n\t\t\tdma_unmap_single(&card->pdev->dev, buf_addr, skb->len,\n\t\t\t\t\t DMA_TO_DEVICE);\n\t\t\tdev_consume_skb_any(skb);\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nstatic inline void\nspider_net_kick_tx_dma(struct spider_net_card *card)\n{\n\tstruct spider_net_descr *descr;\n\n\tif (spider_net_read_reg(card, SPIDER_NET_GDTDMACCNTR) &\n\t\t\tSPIDER_NET_TX_DMA_EN)\n\t\tgoto out;\n\n\tdescr = card->tx_chain.tail;\n\tfor (;;) {\n\t\tif (spider_net_get_descr_status(descr->hwdescr) ==\n\t\t\t\tSPIDER_NET_DESCR_CARDOWNED) {\n\t\t\tspider_net_write_reg(card, SPIDER_NET_GDTDCHA,\n\t\t\t\t\tdescr->bus_addr);\n\t\t\tspider_net_write_reg(card, SPIDER_NET_GDTDMACCNTR,\n\t\t\t\t\tSPIDER_NET_DMA_TX_VALUE);\n\t\t\tbreak;\n\t\t}\n\t\tif (descr == card->tx_chain.head)\n\t\t\tbreak;\n\t\tdescr = descr->next;\n\t}\n\nout:\n\tmod_timer(&card->tx_timer, jiffies + SPIDER_NET_TX_TIMER);\n}\n\n \nstatic netdev_tx_t\nspider_net_xmit(struct sk_buff *skb, struct net_device *netdev)\n{\n\tint cnt;\n\tstruct spider_net_card *card = netdev_priv(netdev);\n\n\tspider_net_release_tx_chain(card, 0);\n\n\tif (spider_net_prepare_tx_descr(card, skb) != 0) {\n\t\tnetdev->stats.tx_dropped++;\n\t\tnetif_stop_queue(netdev);\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\n\tcnt = spider_net_set_low_watermark(card);\n\tif (cnt < 5)\n\t\tspider_net_kick_tx_dma(card);\n\treturn NETDEV_TX_OK;\n}\n\n \nstatic void\nspider_net_cleanup_tx_ring(struct timer_list *t)\n{\n\tstruct spider_net_card *card = from_timer(card, t, tx_timer);\n\tif ((spider_net_release_tx_chain(card, 0) != 0) &&\n\t    (card->netdev->flags & IFF_UP)) {\n\t\tspider_net_kick_tx_dma(card);\n\t\tnetif_wake_queue(card->netdev);\n\t}\n}\n\n \nstatic int\nspider_net_do_ioctl(struct net_device *netdev, struct ifreq *ifr, int cmd)\n{\n\tswitch (cmd) {\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\n \nstatic void\nspider_net_pass_skb_up(struct spider_net_descr *descr,\n\t\t       struct spider_net_card *card)\n{\n\tstruct spider_net_hw_descr *hwdescr = descr->hwdescr;\n\tstruct sk_buff *skb = descr->skb;\n\tstruct net_device *netdev = card->netdev;\n\tu32 data_status = hwdescr->data_status;\n\tu32 data_error = hwdescr->data_error;\n\n\tskb_put(skb, hwdescr->valid_size);\n\n\t \n#define SPIDER_MISALIGN\t\t2\n\tskb_pull(skb, SPIDER_MISALIGN);\n\tskb->protocol = eth_type_trans(skb, netdev);\n\n\t \n\tskb_checksum_none_assert(skb);\n\tif (netdev->features & NETIF_F_RXCSUM) {\n\t\tif ( ( (data_status & SPIDER_NET_DATA_STATUS_CKSUM_MASK) ==\n\t\t       SPIDER_NET_DATA_STATUS_CKSUM_MASK) &&\n\t\t     !(data_error & SPIDER_NET_DATA_ERR_CKSUM_MASK))\n\t\t\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\t}\n\n\tif (data_status & SPIDER_NET_VLAN_PACKET) {\n\t\t \n\t}\n\n\t \n\tnetdev->stats.rx_packets++;\n\tnetdev->stats.rx_bytes += skb->len;\n\n\t \n\tnetif_receive_skb(skb);\n}\n\nstatic void show_rx_chain(struct spider_net_card *card)\n{\n\tstruct spider_net_descr_chain *chain = &card->rx_chain;\n\tstruct spider_net_descr *start= chain->tail;\n\tstruct spider_net_descr *descr= start;\n\tstruct spider_net_hw_descr *hwd = start->hwdescr;\n\tstruct device *dev = &card->netdev->dev;\n\tu32 curr_desc, next_desc;\n\tint status;\n\n\tint tot = 0;\n\tint cnt = 0;\n\tint off = start - chain->ring;\n\tint cstat = hwd->dmac_cmd_status;\n\n\tdev_info(dev, \"Total number of descrs=%d\\n\",\n\t\tchain->num_desc);\n\tdev_info(dev, \"Chain tail located at descr=%d, status=0x%x\\n\",\n\t\toff, cstat);\n\n\tcurr_desc = spider_net_read_reg(card, SPIDER_NET_GDACTDPA);\n\tnext_desc = spider_net_read_reg(card, SPIDER_NET_GDACNEXTDA);\n\n\tstatus = cstat;\n\tdo\n\t{\n\t\thwd = descr->hwdescr;\n\t\toff = descr - chain->ring;\n\t\tstatus = hwd->dmac_cmd_status;\n\n\t\tif (descr == chain->head)\n\t\t\tdev_info(dev, \"Chain head is at %d, head status=0x%x\\n\",\n\t\t\t         off, status);\n\n\t\tif (curr_desc == descr->bus_addr)\n\t\t\tdev_info(dev, \"HW curr desc (GDACTDPA) is at %d, status=0x%x\\n\",\n\t\t\t         off, status);\n\n\t\tif (next_desc == descr->bus_addr)\n\t\t\tdev_info(dev, \"HW next desc (GDACNEXTDA) is at %d, status=0x%x\\n\",\n\t\t\t         off, status);\n\n\t\tif (hwd->next_descr_addr == 0)\n\t\t\tdev_info(dev, \"chain is cut at %d\\n\", off);\n\n\t\tif (cstat != status) {\n\t\t\tint from = (chain->num_desc + off - cnt) % chain->num_desc;\n\t\t\tint to = (chain->num_desc + off - 1) % chain->num_desc;\n\t\t\tdev_info(dev, \"Have %d (from %d to %d) descrs \"\n\t\t\t         \"with stat=0x%08x\\n\", cnt, from, to, cstat);\n\t\t\tcstat = status;\n\t\t\tcnt = 0;\n\t\t}\n\n\t\tcnt ++;\n\t\ttot ++;\n\t\tdescr = descr->next;\n\t} while (descr != start);\n\n\tdev_info(dev, \"Last %d descrs with stat=0x%08x \"\n\t         \"for a total of %d descrs\\n\", cnt, cstat, tot);\n\n#ifdef DEBUG\n\t \n\tdescr = start;\n\tdo\n\t{\n\t\tstruct spider_net_hw_descr *hwd = descr->hwdescr;\n\t\tstatus = spider_net_get_descr_status(hwd);\n\t\tcnt = descr - chain->ring;\n\t\tdev_info(dev, \"Descr %d stat=0x%08x skb=%p\\n\",\n\t\t         cnt, status, descr->skb);\n\t\tdev_info(dev, \"bus addr=%08x buf addr=%08x sz=%d\\n\",\n\t\t         descr->bus_addr, hwd->buf_addr, hwd->buf_size);\n\t\tdev_info(dev, \"next=%08x result sz=%d valid sz=%d\\n\",\n\t\t         hwd->next_descr_addr, hwd->result_size,\n\t\t         hwd->valid_size);\n\t\tdev_info(dev, \"dmac=%08x data stat=%08x data err=%08x\\n\",\n\t\t         hwd->dmac_cmd_status, hwd->data_status,\n\t\t         hwd->data_error);\n\t\tdev_info(dev, \"\\n\");\n\n\t\tdescr = descr->next;\n\t} while (descr != start);\n#endif\n\n}\n\n \nstatic void spider_net_resync_head_ptr(struct spider_net_card *card)\n{\n\tunsigned long flags;\n\tstruct spider_net_descr_chain *chain = &card->rx_chain;\n\tstruct spider_net_descr *descr;\n\tint i, status;\n\n\t \n\tdescr = chain->head;\n\tstatus = spider_net_get_descr_status(descr->hwdescr);\n\n\tif (status == SPIDER_NET_DESCR_NOT_IN_USE)\n\t\treturn;\n\n\tspin_lock_irqsave(&chain->lock, flags);\n\n\tdescr = chain->head;\n\tstatus = spider_net_get_descr_status(descr->hwdescr);\n\tfor (i=0; i<chain->num_desc; i++) {\n\t\tif (status != SPIDER_NET_DESCR_CARDOWNED) break;\n\t\tdescr = descr->next;\n\t\tstatus = spider_net_get_descr_status(descr->hwdescr);\n\t}\n\tchain->head = descr;\n\n\tspin_unlock_irqrestore(&chain->lock, flags);\n}\n\nstatic int spider_net_resync_tail_ptr(struct spider_net_card *card)\n{\n\tstruct spider_net_descr_chain *chain = &card->rx_chain;\n\tstruct spider_net_descr *descr;\n\tint i, status;\n\n\t \n\tdescr = chain->tail;\n\tstatus = spider_net_get_descr_status(descr->hwdescr);\n\n\tfor (i=0; i<chain->num_desc; i++) {\n\t\tif ((status != SPIDER_NET_DESCR_CARDOWNED) &&\n\t\t    (status != SPIDER_NET_DESCR_NOT_IN_USE)) break;\n\t\tdescr = descr->next;\n\t\tstatus = spider_net_get_descr_status(descr->hwdescr);\n\t}\n\tchain->tail = descr;\n\n\tif ((i == chain->num_desc) || (i == 0))\n\t\treturn 1;\n\treturn 0;\n}\n\n \nstatic int\nspider_net_decode_one_descr(struct spider_net_card *card)\n{\n\tstruct net_device *dev = card->netdev;\n\tstruct spider_net_descr_chain *chain = &card->rx_chain;\n\tstruct spider_net_descr *descr = chain->tail;\n\tstruct spider_net_hw_descr *hwdescr = descr->hwdescr;\n\tu32 hw_buf_addr;\n\tint status;\n\n\tstatus = spider_net_get_descr_status(hwdescr);\n\n\t \n\tif ((status == SPIDER_NET_DESCR_CARDOWNED) ||\n\t    (status == SPIDER_NET_DESCR_NOT_IN_USE))\n\t\treturn 0;\n\n\t \n\tchain->tail = descr->next;\n\n\t \n\thw_buf_addr = hwdescr->buf_addr;\n\thwdescr->buf_addr = 0xffffffff;\n\tdma_unmap_single(&card->pdev->dev, hw_buf_addr, SPIDER_NET_MAX_FRAME,\n\t\t\t DMA_FROM_DEVICE);\n\n\tif ( (status == SPIDER_NET_DESCR_RESPONSE_ERROR) ||\n\t     (status == SPIDER_NET_DESCR_PROTECTION_ERROR) ||\n\t     (status == SPIDER_NET_DESCR_FORCE_END) ) {\n\t\tif (netif_msg_rx_err(card))\n\t\t\tdev_err(&dev->dev,\n\t\t\t       \"dropping RX descriptor with state %d\\n\", status);\n\t\tdev->stats.rx_dropped++;\n\t\tgoto bad_desc;\n\t}\n\n\tif ( (status != SPIDER_NET_DESCR_COMPLETE) &&\n\t     (status != SPIDER_NET_DESCR_FRAME_END) ) {\n\t\tif (netif_msg_rx_err(card))\n\t\t\tdev_err(&card->netdev->dev,\n\t\t\t       \"RX descriptor with unknown state %d\\n\", status);\n\t\tcard->spider_stats.rx_desc_unk_state++;\n\t\tgoto bad_desc;\n\t}\n\n\t \n\tif (hwdescr->data_error & SPIDER_NET_DESTROY_RX_FLAGS) {\n\t\tif (netif_msg_rx_err(card))\n\t\t\tdev_err(&card->netdev->dev,\n\t\t\t       \"error in received descriptor found, \"\n\t\t\t       \"data_status=x%08x, data_error=x%08x\\n\",\n\t\t\t       hwdescr->data_status, hwdescr->data_error);\n\t\tgoto bad_desc;\n\t}\n\n\tif (hwdescr->dmac_cmd_status & SPIDER_NET_DESCR_BAD_STATUS) {\n\t\tdev_err(&card->netdev->dev, \"bad status, cmd_status=x%08x\\n\",\n\t\t\t       hwdescr->dmac_cmd_status);\n\t\tpr_err(\"buf_addr=x%08x\\n\", hw_buf_addr);\n\t\tpr_err(\"buf_size=x%08x\\n\", hwdescr->buf_size);\n\t\tpr_err(\"next_descr_addr=x%08x\\n\", hwdescr->next_descr_addr);\n\t\tpr_err(\"result_size=x%08x\\n\", hwdescr->result_size);\n\t\tpr_err(\"valid_size=x%08x\\n\", hwdescr->valid_size);\n\t\tpr_err(\"data_status=x%08x\\n\", hwdescr->data_status);\n\t\tpr_err(\"data_error=x%08x\\n\", hwdescr->data_error);\n\t\tpr_err(\"which=%ld\\n\", descr - card->rx_chain.ring);\n\n\t\tcard->spider_stats.rx_desc_error++;\n\t\tgoto bad_desc;\n\t}\n\n\t \n\tspider_net_pass_skb_up(descr, card);\n\tdescr->skb = NULL;\n\thwdescr->dmac_cmd_status = SPIDER_NET_DESCR_NOT_IN_USE;\n\treturn 1;\n\nbad_desc:\n\tif (netif_msg_rx_err(card))\n\t\tshow_rx_chain(card);\n\tdev_kfree_skb_irq(descr->skb);\n\tdescr->skb = NULL;\n\thwdescr->dmac_cmd_status = SPIDER_NET_DESCR_NOT_IN_USE;\n\treturn 0;\n}\n\n \nstatic int spider_net_poll(struct napi_struct *napi, int budget)\n{\n\tstruct spider_net_card *card = container_of(napi, struct spider_net_card, napi);\n\tint packets_done = 0;\n\n\twhile (packets_done < budget) {\n\t\tif (!spider_net_decode_one_descr(card))\n\t\t\tbreak;\n\n\t\tpackets_done++;\n\t}\n\n\tif ((packets_done == 0) && (card->num_rx_ints != 0)) {\n\t\tif (!spider_net_resync_tail_ptr(card))\n\t\t\tpackets_done = budget;\n\t\tspider_net_resync_head_ptr(card);\n\t}\n\tcard->num_rx_ints = 0;\n\n\tspider_net_refill_rx_chain(card);\n\tspider_net_enable_rxdmac(card);\n\n\tspider_net_cleanup_tx_ring(&card->tx_timer);\n\n\t \n\t \n\tif (packets_done < budget) {\n\t\tnapi_complete_done(napi, packets_done);\n\t\tspider_net_rx_irq_on(card);\n\t\tcard->ignore_rx_ramfull = 0;\n\t}\n\n\treturn packets_done;\n}\n\n \nstatic int\nspider_net_set_mac(struct net_device *netdev, void *p)\n{\n\tstruct spider_net_card *card = netdev_priv(netdev);\n\tu32 macl, macu, regvalue;\n\tstruct sockaddr *addr = p;\n\n\tif (!is_valid_ether_addr(addr->sa_data))\n\t\treturn -EADDRNOTAVAIL;\n\n\teth_hw_addr_set(netdev, addr->sa_data);\n\n\t \n\tregvalue = spider_net_read_reg(card, SPIDER_NET_GMACOPEMD);\n\tregvalue &= ~((1 << 5) | (1 << 6));\n\tspider_net_write_reg(card, SPIDER_NET_GMACOPEMD, regvalue);\n\n\t \n\tmacu = (netdev->dev_addr[0]<<24) + (netdev->dev_addr[1]<<16) +\n\t\t(netdev->dev_addr[2]<<8) + (netdev->dev_addr[3]);\n\tmacl = (netdev->dev_addr[4]<<8) + (netdev->dev_addr[5]);\n\tspider_net_write_reg(card, SPIDER_NET_GMACUNIMACU, macu);\n\tspider_net_write_reg(card, SPIDER_NET_GMACUNIMACL, macl);\n\n\t \n\tregvalue = spider_net_read_reg(card, SPIDER_NET_GMACOPEMD);\n\tregvalue |= ((1 << 5) | (1 << 6));\n\tspider_net_write_reg(card, SPIDER_NET_GMACOPEMD, regvalue);\n\n\tspider_net_set_promisc(card);\n\n\treturn 0;\n}\n\n \nstatic void\nspider_net_link_reset(struct net_device *netdev)\n{\n\n\tstruct spider_net_card *card = netdev_priv(netdev);\n\n\tdel_timer_sync(&card->aneg_timer);\n\n\t \n\tspider_net_write_reg(card, SPIDER_NET_GMACST,\n\t\t\t     spider_net_read_reg(card, SPIDER_NET_GMACST));\n\tspider_net_write_reg(card, SPIDER_NET_GMACINTEN, 0);\n\n\t \n\tcard->aneg_count = 0;\n\tcard->medium = BCM54XX_COPPER;\n\tspider_net_setup_aneg(card);\n\tmod_timer(&card->aneg_timer, jiffies + SPIDER_NET_ANEG_TIMER);\n\n}\n\n \nstatic void\nspider_net_handle_error_irq(struct spider_net_card *card, u32 status_reg,\n\t\t\t    u32 error_reg1, u32 error_reg2)\n{\n\tu32 i;\n\tint show_error = 1;\n\n\t \n\tif (status_reg)\n\t\tfor (i = 0; i < 32; i++)\n\t\t\tif (status_reg & (1<<i))\n\t\t\t\tswitch (i)\n\t{\n\t \n\n\tcase SPIDER_NET_GIPSINT:\n\t\tshow_error = 0;\n\t\tbreak;\n\n\tcase SPIDER_NET_GPWOPCMPINT:\n\t\t \n\t\tshow_error = 0;\n\t\tbreak;\n\tcase SPIDER_NET_GPROPCMPINT:\n\t\t \n\t\t \n\t\tshow_error = 0;\n\t\tbreak;\n\tcase SPIDER_NET_GPWFFINT:\n\t\t \n\t\tif (netif_msg_intr(card))\n\t\t\tdev_err(&card->netdev->dev, \"PHY write queue full\\n\");\n\t\tshow_error = 0;\n\t\tbreak;\n\n\t \n\t \n\t \n\n\tcase SPIDER_NET_GDTDEN0INT:\n\t\t \n\t\tshow_error = 0;\n\t\tbreak;\n\n\tcase SPIDER_NET_GDDDEN0INT:\n\tcase SPIDER_NET_GDCDEN0INT:\n\tcase SPIDER_NET_GDBDEN0INT:\n\tcase SPIDER_NET_GDADEN0INT:\n\t\t \n\t\tshow_error = 0;\n\t\tbreak;\n\n\t \n\tcase SPIDER_NET_GDDFDCINT:\n\tcase SPIDER_NET_GDCFDCINT:\n\tcase SPIDER_NET_GDBFDCINT:\n\tcase SPIDER_NET_GDAFDCINT:\n\t \n\t \n\t \n\t \n\t \n\t\tshow_error = 0;\n\t\tbreak;\n\n\t \n\tcase SPIDER_NET_GDTFDCINT:\n\t\tshow_error = 0;\n\t\tbreak;\n\tcase SPIDER_NET_GTTEDINT:\n\t\tshow_error = 0;\n\t\tbreak;\n\tcase SPIDER_NET_GDTDCEINT:\n\t\t \n\t\tshow_error = 0;\n\t\tbreak;\n\n\t \n\t \n\t}\n\n\t \n\tif (error_reg1)\n\t\tfor (i = 0; i < 32; i++)\n\t\t\tif (error_reg1 & (1<<i))\n\t\t\t\tswitch (i)\n\t{\n\tcase SPIDER_NET_GTMFLLINT:\n\t\t \n\t\tshow_error = 0;\n\t\tbreak;\n\tcase SPIDER_NET_GRFDFLLINT:\n\tcase SPIDER_NET_GRFCFLLINT:\n\tcase SPIDER_NET_GRFBFLLINT:\n\tcase SPIDER_NET_GRFAFLLINT:\n\tcase SPIDER_NET_GRMFLLINT:\n\t\t \n\t\tif (card->ignore_rx_ramfull == 0) {\n\t\t\tcard->ignore_rx_ramfull = 1;\n\t\t\tspider_net_resync_head_ptr(card);\n\t\t\tspider_net_refill_rx_chain(card);\n\t\t\tspider_net_enable_rxdmac(card);\n\t\t\tcard->num_rx_ints ++;\n\t\t\tnapi_schedule(&card->napi);\n\t\t}\n\t\tshow_error = 0;\n\t\tbreak;\n\n\t \n\tcase SPIDER_NET_GDTINVDINT:\n\t\t \n\t\tshow_error = 0;\n\t\tbreak;\n\n\t \n\tcase SPIDER_NET_GDDDCEINT:\n\tcase SPIDER_NET_GDCDCEINT:\n\tcase SPIDER_NET_GDBDCEINT:\n\tcase SPIDER_NET_GDADCEINT:\n\t\tspider_net_resync_head_ptr(card);\n\t\tspider_net_refill_rx_chain(card);\n\t\tspider_net_enable_rxdmac(card);\n\t\tcard->num_rx_ints ++;\n\t\tnapi_schedule(&card->napi);\n\t\tshow_error = 0;\n\t\tbreak;\n\n\t \n\tcase SPIDER_NET_GDDINVDINT:\n\tcase SPIDER_NET_GDCINVDINT:\n\tcase SPIDER_NET_GDBINVDINT:\n\tcase SPIDER_NET_GDAINVDINT:\n\t\t \n\t\tspider_net_resync_head_ptr(card);\n\t\tspider_net_refill_rx_chain(card);\n\t\tspider_net_enable_rxdmac(card);\n\t\tcard->num_rx_ints ++;\n\t\tnapi_schedule(&card->napi);\n\t\tshow_error = 0;\n\t\tbreak;\n\n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\tdefault:\n\t\tshow_error = 1;\n\t\tbreak;\n\t}\n\n\t \n\tif (error_reg2)\n\t\tfor (i = 0; i < 32; i++)\n\t\t\tif (error_reg2 & (1<<i))\n\t\t\t\tswitch (i)\n\t{\n\t \n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\tif ((show_error) && (netif_msg_intr(card)) && net_ratelimit())\n\t\tdev_err(&card->netdev->dev, \"Error interrupt, GHIINT0STS = 0x%08x, \"\n\t\t       \"GHIINT1STS = 0x%08x, GHIINT2STS = 0x%08x\\n\",\n\t\t       status_reg, error_reg1, error_reg2);\n\n\t \n\tspider_net_write_reg(card, SPIDER_NET_GHIINT1STS, error_reg1);\n\tspider_net_write_reg(card, SPIDER_NET_GHIINT2STS, error_reg2);\n}\n\n \nstatic irqreturn_t\nspider_net_interrupt(int irq, void *ptr)\n{\n\tstruct net_device *netdev = ptr;\n\tstruct spider_net_card *card = netdev_priv(netdev);\n\tu32 status_reg, error_reg1, error_reg2;\n\n\tstatus_reg = spider_net_read_reg(card, SPIDER_NET_GHIINT0STS);\n\terror_reg1 = spider_net_read_reg(card, SPIDER_NET_GHIINT1STS);\n\terror_reg2 = spider_net_read_reg(card, SPIDER_NET_GHIINT2STS);\n\n\tif (!(status_reg & SPIDER_NET_INT0_MASK_VALUE) &&\n\t    !(error_reg1 & SPIDER_NET_INT1_MASK_VALUE) &&\n\t    !(error_reg2 & SPIDER_NET_INT2_MASK_VALUE))\n\t\treturn IRQ_NONE;\n\n\tif (status_reg & SPIDER_NET_RXINT ) {\n\t\tspider_net_rx_irq_off(card);\n\t\tnapi_schedule(&card->napi);\n\t\tcard->num_rx_ints ++;\n\t}\n\tif (status_reg & SPIDER_NET_TXINT)\n\t\tnapi_schedule(&card->napi);\n\n\tif (status_reg & SPIDER_NET_LINKINT)\n\t\tspider_net_link_reset(netdev);\n\n\tif (status_reg & SPIDER_NET_ERRINT )\n\t\tspider_net_handle_error_irq(card, status_reg,\n\t\t\t\t\t    error_reg1, error_reg2);\n\n\t \n\tspider_net_write_reg(card, SPIDER_NET_GHIINT0STS, status_reg);\n\n\treturn IRQ_HANDLED;\n}\n\n#ifdef CONFIG_NET_POLL_CONTROLLER\n \nstatic void\nspider_net_poll_controller(struct net_device *netdev)\n{\n\tdisable_irq(netdev->irq);\n\tspider_net_interrupt(netdev->irq, netdev);\n\tenable_irq(netdev->irq);\n}\n#endif  \n\n \nstatic void\nspider_net_enable_interrupts(struct spider_net_card *card)\n{\n\tspider_net_write_reg(card, SPIDER_NET_GHIINT0MSK,\n\t\t\t     SPIDER_NET_INT0_MASK_VALUE);\n\tspider_net_write_reg(card, SPIDER_NET_GHIINT1MSK,\n\t\t\t     SPIDER_NET_INT1_MASK_VALUE);\n\tspider_net_write_reg(card, SPIDER_NET_GHIINT2MSK,\n\t\t\t     SPIDER_NET_INT2_MASK_VALUE);\n}\n\n \nstatic void\nspider_net_disable_interrupts(struct spider_net_card *card)\n{\n\tspider_net_write_reg(card, SPIDER_NET_GHIINT0MSK, 0);\n\tspider_net_write_reg(card, SPIDER_NET_GHIINT1MSK, 0);\n\tspider_net_write_reg(card, SPIDER_NET_GHIINT2MSK, 0);\n\tspider_net_write_reg(card, SPIDER_NET_GMACINTEN, 0);\n}\n\n \nstatic void\nspider_net_init_card(struct spider_net_card *card)\n{\n\tspider_net_write_reg(card, SPIDER_NET_CKRCTRL,\n\t\t\t     SPIDER_NET_CKRCTRL_STOP_VALUE);\n\n\tspider_net_write_reg(card, SPIDER_NET_CKRCTRL,\n\t\t\t     SPIDER_NET_CKRCTRL_RUN_VALUE);\n\n\t \n\tspider_net_write_reg(card, SPIDER_NET_GMACOPEMD,\n\t\tspider_net_read_reg(card, SPIDER_NET_GMACOPEMD) | 0x4);\n\n\tspider_net_disable_interrupts(card);\n}\n\n \nstatic void\nspider_net_enable_card(struct spider_net_card *card)\n{\n\tint i;\n\t \n\tu32 regs[][2] = {\n\t\t{ SPIDER_NET_GRESUMINTNUM, 0 },\n\t\t{ SPIDER_NET_GREINTNUM, 0 },\n\n\t\t \n\t\t \n\t\t{ SPIDER_NET_GFAFRMNUM, SPIDER_NET_GFXFRAMES_VALUE },\n\t\t{ SPIDER_NET_GFBFRMNUM, SPIDER_NET_GFXFRAMES_VALUE },\n\t\t{ SPIDER_NET_GFCFRMNUM, SPIDER_NET_GFXFRAMES_VALUE },\n\t\t{ SPIDER_NET_GFDFRMNUM, SPIDER_NET_GFXFRAMES_VALUE },\n\t\t \n\t\t{ SPIDER_NET_GFFRMNUM, SPIDER_NET_FRAMENUM_VALUE },\n\n\t\t \n\t\t{ SPIDER_NET_GFREECNNUM, 0 },\n\t\t{ SPIDER_NET_GONETIMENUM, 0 },\n\t\t{ SPIDER_NET_GTOUTFRMNUM, 0 },\n\n\t\t \n\t\t{ SPIDER_NET_GRXMDSET, SPIDER_NET_RXMODE_VALUE },\n\t\t \n\t\t{ SPIDER_NET_GTXMDSET, SPIDER_NET_TXMODE_VALUE },\n\t\t \n\t\t{ SPIDER_NET_GIPSECINIT, SPIDER_NET_IPSECINIT_VALUE },\n\n\t\t{ SPIDER_NET_GFTRESTRT, SPIDER_NET_RESTART_VALUE },\n\n\t\t{ SPIDER_NET_GMRWOLCTRL, 0 },\n\t\t{ SPIDER_NET_GTESTMD, 0x10000000 },\n\t\t{ SPIDER_NET_GTTQMSK, 0x00400040 },\n\n\t\t{ SPIDER_NET_GMACINTEN, 0 },\n\n\t\t \n\t\t{ SPIDER_NET_GMACAPAUSE, SPIDER_NET_MACAPAUSE_VALUE },\n\t\t{ SPIDER_NET_GMACTXPAUSE, SPIDER_NET_TXPAUSE_VALUE },\n\n\t\t{ SPIDER_NET_GMACBSTLMT, SPIDER_NET_BURSTLMT_VALUE },\n\t\t{ 0, 0}\n\t};\n\n\ti = 0;\n\twhile (regs[i][0]) {\n\t\tspider_net_write_reg(card, regs[i][0], regs[i][1]);\n\t\ti++;\n\t}\n\n\t \n\tfor (i = 1; i <= 14; i++) {\n\t\tspider_net_write_reg(card,\n\t\t\t\t     SPIDER_NET_GMRUAFILnR + i * 8,\n\t\t\t\t     0x00080000);\n\t\tspider_net_write_reg(card,\n\t\t\t\t     SPIDER_NET_GMRUAFILnR + i * 8 + 4,\n\t\t\t\t     0x00000000);\n\t}\n\n\tspider_net_write_reg(card, SPIDER_NET_GMRUA0FIL15R, 0x08080000);\n\n\tspider_net_write_reg(card, SPIDER_NET_ECMODE, SPIDER_NET_ECMODE_VALUE);\n\n\t \n\tspider_net_enable_rxchtails(card);\n\tspider_net_enable_rxdmac(card);\n\n\tspider_net_write_reg(card, SPIDER_NET_GRXDMAEN, SPIDER_NET_WOL_VALUE);\n\n\tspider_net_write_reg(card, SPIDER_NET_GMACLENLMT,\n\t\t\t     SPIDER_NET_LENLMT_VALUE);\n\tspider_net_write_reg(card, SPIDER_NET_GMACOPEMD,\n\t\t\t     SPIDER_NET_OPMODE_VALUE);\n\n\tspider_net_write_reg(card, SPIDER_NET_GDTDMACCNTR,\n\t\t\t     SPIDER_NET_GDTBSTA);\n}\n\n \nstatic int\nspider_net_download_firmware(struct spider_net_card *card,\n\t\t\t     const void *firmware_ptr)\n{\n\tint sequencer, i;\n\tconst u32 *fw_ptr = firmware_ptr;\n\n\t \n\tspider_net_write_reg(card, SPIDER_NET_GSINIT,\n\t\t\t     SPIDER_NET_STOP_SEQ_VALUE);\n\n\tfor (sequencer = 0; sequencer < SPIDER_NET_FIRMWARE_SEQS;\n\t     sequencer++) {\n\t\tspider_net_write_reg(card,\n\t\t\t\t     SPIDER_NET_GSnPRGADR + sequencer * 8, 0);\n\t\tfor (i = 0; i < SPIDER_NET_FIRMWARE_SEQWORDS; i++) {\n\t\t\tspider_net_write_reg(card, SPIDER_NET_GSnPRGDAT +\n\t\t\t\t\t     sequencer * 8, *fw_ptr);\n\t\t\tfw_ptr++;\n\t\t}\n\t}\n\n\tif (spider_net_read_reg(card, SPIDER_NET_GSINIT))\n\t\treturn -EIO;\n\n\tspider_net_write_reg(card, SPIDER_NET_GSINIT,\n\t\t\t     SPIDER_NET_RUN_SEQ_VALUE);\n\n\treturn 0;\n}\n\n \nstatic int\nspider_net_init_firmware(struct spider_net_card *card)\n{\n\tstruct firmware *firmware = NULL;\n\tstruct device_node *dn;\n\tconst u8 *fw_prop = NULL;\n\tint err = -ENOENT;\n\tint fw_size;\n\n\tif (request_firmware((const struct firmware **)&firmware,\n\t\t\t     SPIDER_NET_FIRMWARE_NAME, &card->pdev->dev) == 0) {\n\t\tif ( (firmware->size != SPIDER_NET_FIRMWARE_LEN) &&\n\t\t     netif_msg_probe(card) ) {\n\t\t\tdev_err(&card->netdev->dev,\n\t\t\t       \"Incorrect size of spidernet firmware in \" \\\n\t\t\t       \"filesystem. Looking in host firmware...\\n\");\n\t\t\tgoto try_host_fw;\n\t\t}\n\t\terr = spider_net_download_firmware(card, firmware->data);\n\n\t\trelease_firmware(firmware);\n\t\tif (err)\n\t\t\tgoto try_host_fw;\n\n\t\tgoto done;\n\t}\n\ntry_host_fw:\n\tdn = pci_device_to_OF_node(card->pdev);\n\tif (!dn)\n\t\tgoto out_err;\n\n\tfw_prop = of_get_property(dn, \"firmware\", &fw_size);\n\tif (!fw_prop)\n\t\tgoto out_err;\n\n\tif ( (fw_size != SPIDER_NET_FIRMWARE_LEN) &&\n\t     netif_msg_probe(card) ) {\n\t\tdev_err(&card->netdev->dev,\n\t\t       \"Incorrect size of spidernet firmware in host firmware\\n\");\n\t\tgoto done;\n\t}\n\n\terr = spider_net_download_firmware(card, fw_prop);\n\ndone:\n\treturn err;\nout_err:\n\tif (netif_msg_probe(card))\n\t\tdev_err(&card->netdev->dev,\n\t\t       \"Couldn't find spidernet firmware in filesystem \" \\\n\t\t       \"or host firmware\\n\");\n\treturn err;\n}\n\n \nint\nspider_net_open(struct net_device *netdev)\n{\n\tstruct spider_net_card *card = netdev_priv(netdev);\n\tint result;\n\n\tresult = spider_net_init_firmware(card);\n\tif (result)\n\t\tgoto init_firmware_failed;\n\n\t \n\tcard->aneg_count = 0;\n\tcard->medium = BCM54XX_COPPER;\n\tspider_net_setup_aneg(card);\n\tif (card->phy.def->phy_id)\n\t\tmod_timer(&card->aneg_timer, jiffies + SPIDER_NET_ANEG_TIMER);\n\n\tresult = spider_net_init_chain(card, &card->tx_chain);\n\tif (result)\n\t\tgoto alloc_tx_failed;\n\tcard->low_watermark = NULL;\n\n\tresult = spider_net_init_chain(card, &card->rx_chain);\n\tif (result)\n\t\tgoto alloc_rx_failed;\n\n\t \n\tresult = spider_net_alloc_rx_skbs(card);\n\tif (result)\n\t\tgoto alloc_skbs_failed;\n\n\tspider_net_set_multi(netdev);\n\n\t \n\n\tresult = -EBUSY;\n\tif (request_irq(netdev->irq, spider_net_interrupt,\n\t\t\t     IRQF_SHARED, netdev->name, netdev))\n\t\tgoto register_int_failed;\n\n\tspider_net_enable_card(card);\n\n\tnetif_start_queue(netdev);\n\tnetif_carrier_on(netdev);\n\tnapi_enable(&card->napi);\n\n\tspider_net_enable_interrupts(card);\n\n\treturn 0;\n\nregister_int_failed:\n\tspider_net_free_rx_chain_contents(card);\nalloc_skbs_failed:\n\tspider_net_free_chain(card, &card->rx_chain);\nalloc_rx_failed:\n\tspider_net_free_chain(card, &card->tx_chain);\nalloc_tx_failed:\n\tdel_timer_sync(&card->aneg_timer);\ninit_firmware_failed:\n\treturn result;\n}\n\n \nstatic void spider_net_link_phy(struct timer_list *t)\n{\n\tstruct spider_net_card *card = from_timer(card, t, aneg_timer);\n\tstruct mii_phy *phy = &card->phy;\n\n\t \n\tif (card->aneg_count > SPIDER_NET_ANEG_TIMEOUT) {\n\n\t\tpr_debug(\"%s: link is down trying to bring it up\\n\",\n\t\t\t card->netdev->name);\n\n\t\tswitch (card->medium) {\n\t\tcase BCM54XX_COPPER:\n\t\t\t \n\t\t\tif (phy->def->ops->enable_fiber)\n\t\t\t\tphy->def->ops->enable_fiber(phy, 1);\n\t\t\tcard->medium = BCM54XX_FIBER;\n\t\t\tbreak;\n\n\t\tcase BCM54XX_FIBER:\n\t\t\t \n\t\t\tif (phy->def->ops->enable_fiber)\n\t\t\t\tphy->def->ops->enable_fiber(phy, 0);\n\t\t\tcard->medium = BCM54XX_UNKNOWN;\n\t\t\tbreak;\n\n\t\tcase BCM54XX_UNKNOWN:\n\t\t\t \n\t\t\tspider_net_setup_aneg(card);\n\t\t\tcard->medium = BCM54XX_COPPER;\n\t\t\tbreak;\n\t\t}\n\n\t\tcard->aneg_count = 0;\n\t\tmod_timer(&card->aneg_timer, jiffies + SPIDER_NET_ANEG_TIMER);\n\t\treturn;\n\t}\n\n\t \n\tif (!(phy->def->ops->poll_link(phy))) {\n\t\tcard->aneg_count++;\n\t\tmod_timer(&card->aneg_timer, jiffies + SPIDER_NET_ANEG_TIMER);\n\t\treturn;\n\t}\n\n\t \n\tphy->def->ops->read_link(phy);\n\n\tspider_net_write_reg(card, SPIDER_NET_GMACST,\n\t\t\t     spider_net_read_reg(card, SPIDER_NET_GMACST));\n\tspider_net_write_reg(card, SPIDER_NET_GMACINTEN, 0x4);\n\n\tif (phy->speed == 1000)\n\t\tspider_net_write_reg(card, SPIDER_NET_GMACMODE, 0x00000001);\n\telse\n\t\tspider_net_write_reg(card, SPIDER_NET_GMACMODE, 0);\n\n\tcard->aneg_count = 0;\n\n\tpr_info(\"%s: link up, %i Mbps, %s-duplex %sautoneg.\\n\",\n\t\tcard->netdev->name, phy->speed,\n\t\tphy->duplex == 1 ? \"Full\" : \"Half\",\n\t\tphy->autoneg == 1 ? \"\" : \"no \");\n}\n\n \nstatic int\nspider_net_setup_phy(struct spider_net_card *card)\n{\n\tstruct mii_phy *phy = &card->phy;\n\n\tspider_net_write_reg(card, SPIDER_NET_GDTDMASEL,\n\t\t\t     SPIDER_NET_DMASEL_VALUE);\n\tspider_net_write_reg(card, SPIDER_NET_GPCCTRL,\n\t\t\t     SPIDER_NET_PHY_CTRL_VALUE);\n\n\tphy->dev = card->netdev;\n\tphy->mdio_read = spider_net_read_phy;\n\tphy->mdio_write = spider_net_write_phy;\n\n\tfor (phy->mii_id = 1; phy->mii_id <= 31; phy->mii_id++) {\n\t\tunsigned short id;\n\t\tid = spider_net_read_phy(card->netdev, phy->mii_id, MII_BMSR);\n\t\tif (id != 0x0000 && id != 0xffff) {\n\t\t\tif (!sungem_phy_probe(phy, phy->mii_id)) {\n\t\t\t\tpr_info(\"Found %s.\\n\", phy->def->name);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic void\nspider_net_workaround_rxramfull(struct spider_net_card *card)\n{\n\tint i, sequencer = 0;\n\n\t \n\tspider_net_write_reg(card, SPIDER_NET_CKRCTRL,\n\t\t\t     SPIDER_NET_CKRCTRL_RUN_VALUE);\n\n\t \n\tfor (sequencer = 0; sequencer < SPIDER_NET_FIRMWARE_SEQS;\n\t     sequencer++) {\n\t\tspider_net_write_reg(card, SPIDER_NET_GSnPRGADR +\n\t\t\t\t     sequencer * 8, 0x0);\n\t\tfor (i = 0; i < SPIDER_NET_FIRMWARE_SEQWORDS; i++) {\n\t\t\tspider_net_write_reg(card, SPIDER_NET_GSnPRGDAT +\n\t\t\t\t\t     sequencer * 8, 0x0);\n\t\t}\n\t}\n\n\t \n\tspider_net_write_reg(card, SPIDER_NET_GSINIT, 0x000000fe);\n\n\t \n\tspider_net_write_reg(card, SPIDER_NET_CKRCTRL,\n\t\t\t     SPIDER_NET_CKRCTRL_STOP_VALUE);\n}\n\n \nint\nspider_net_stop(struct net_device *netdev)\n{\n\tstruct spider_net_card *card = netdev_priv(netdev);\n\n\tnapi_disable(&card->napi);\n\tnetif_carrier_off(netdev);\n\tnetif_stop_queue(netdev);\n\tdel_timer_sync(&card->tx_timer);\n\tdel_timer_sync(&card->aneg_timer);\n\n\tspider_net_disable_interrupts(card);\n\n\tfree_irq(netdev->irq, netdev);\n\n\tspider_net_write_reg(card, SPIDER_NET_GDTDMACCNTR,\n\t\t\t     SPIDER_NET_DMA_TX_FEND_VALUE);\n\n\t \n\tspider_net_disable_rxdmac(card);\n\n\t \n\tspider_net_release_tx_chain(card, 1);\n\tspider_net_free_rx_chain_contents(card);\n\n\tspider_net_free_chain(card, &card->tx_chain);\n\tspider_net_free_chain(card, &card->rx_chain);\n\n\treturn 0;\n}\n\n \nstatic void\nspider_net_tx_timeout_task(struct work_struct *work)\n{\n\tstruct spider_net_card *card =\n\t\tcontainer_of(work, struct spider_net_card, tx_timeout_task);\n\tstruct net_device *netdev = card->netdev;\n\n\tif (!(netdev->flags & IFF_UP))\n\t\tgoto out;\n\n\tnetif_device_detach(netdev);\n\tspider_net_stop(netdev);\n\n\tspider_net_workaround_rxramfull(card);\n\tspider_net_init_card(card);\n\n\tif (spider_net_setup_phy(card))\n\t\tgoto out;\n\n\tspider_net_open(netdev);\n\tspider_net_kick_tx_dma(card);\n\tnetif_device_attach(netdev);\n\nout:\n\tatomic_dec(&card->tx_timeout_task_counter);\n}\n\n \nstatic void\nspider_net_tx_timeout(struct net_device *netdev, unsigned int txqueue)\n{\n\tstruct spider_net_card *card;\n\n\tcard = netdev_priv(netdev);\n\tatomic_inc(&card->tx_timeout_task_counter);\n\tif (netdev->flags & IFF_UP)\n\t\tschedule_work(&card->tx_timeout_task);\n\telse\n\t\tatomic_dec(&card->tx_timeout_task_counter);\n\tcard->spider_stats.tx_timeouts++;\n}\n\nstatic const struct net_device_ops spider_net_ops = {\n\t.ndo_open\t\t= spider_net_open,\n\t.ndo_stop\t\t= spider_net_stop,\n\t.ndo_start_xmit\t\t= spider_net_xmit,\n\t.ndo_set_rx_mode\t= spider_net_set_multi,\n\t.ndo_set_mac_address\t= spider_net_set_mac,\n\t.ndo_eth_ioctl\t\t= spider_net_do_ioctl,\n\t.ndo_tx_timeout\t\t= spider_net_tx_timeout,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t \n#ifdef CONFIG_NET_POLL_CONTROLLER\n\t \n\t.ndo_poll_controller\t= spider_net_poll_controller,\n#endif  \n};\n\n \nstatic void\nspider_net_setup_netdev_ops(struct net_device *netdev)\n{\n\tnetdev->netdev_ops = &spider_net_ops;\n\tnetdev->watchdog_timeo = SPIDER_NET_WATCHDOG_TIMEOUT;\n\t \n\tnetdev->ethtool_ops = &spider_net_ethtool_ops;\n}\n\n \nstatic int\nspider_net_setup_netdev(struct spider_net_card *card)\n{\n\tint result;\n\tstruct net_device *netdev = card->netdev;\n\tstruct device_node *dn;\n\tstruct sockaddr addr;\n\tconst u8 *mac;\n\n\tSET_NETDEV_DEV(netdev, &card->pdev->dev);\n\n\tpci_set_drvdata(card->pdev, netdev);\n\n\ttimer_setup(&card->tx_timer, spider_net_cleanup_tx_ring, 0);\n\tnetdev->irq = card->pdev->irq;\n\n\tcard->aneg_count = 0;\n\ttimer_setup(&card->aneg_timer, spider_net_link_phy, 0);\n\n\tnetif_napi_add(netdev, &card->napi, spider_net_poll);\n\n\tspider_net_setup_netdev_ops(netdev);\n\n\tnetdev->hw_features = NETIF_F_RXCSUM | NETIF_F_IP_CSUM;\n\tif (SPIDER_NET_RX_CSUM_DEFAULT)\n\t\tnetdev->features |= NETIF_F_RXCSUM;\n\tnetdev->features |= NETIF_F_IP_CSUM | NETIF_F_LLTX;\n\t \n\n\t \n\tnetdev->min_mtu = SPIDER_NET_MIN_MTU;\n\tnetdev->max_mtu = SPIDER_NET_MAX_MTU;\n\n\tnetdev->irq = card->pdev->irq;\n\tcard->num_rx_ints = 0;\n\tcard->ignore_rx_ramfull = 0;\n\n\tdn = pci_device_to_OF_node(card->pdev);\n\tif (!dn)\n\t\treturn -EIO;\n\n\tmac = of_get_property(dn, \"local-mac-address\", NULL);\n\tif (!mac)\n\t\treturn -EIO;\n\tmemcpy(addr.sa_data, mac, ETH_ALEN);\n\n\tresult = spider_net_set_mac(netdev, &addr);\n\tif ((result) && (netif_msg_probe(card)))\n\t\tdev_err(&card->netdev->dev,\n\t\t        \"Failed to set MAC address: %i\\n\", result);\n\n\tresult = register_netdev(netdev);\n\tif (result) {\n\t\tif (netif_msg_probe(card))\n\t\t\tdev_err(&card->netdev->dev,\n\t\t\t        \"Couldn't register net_device: %i\\n\", result);\n\t\treturn result;\n\t}\n\n\tif (netif_msg_probe(card))\n\t\tpr_info(\"Initialized device %s.\\n\", netdev->name);\n\n\treturn 0;\n}\n\n \nstatic struct spider_net_card *\nspider_net_alloc_card(void)\n{\n\tstruct net_device *netdev;\n\tstruct spider_net_card *card;\n\n\tnetdev = alloc_etherdev(struct_size(card, darray,\n\t\t\t\t\t    size_add(tx_descriptors, rx_descriptors)));\n\tif (!netdev)\n\t\treturn NULL;\n\n\tcard = netdev_priv(netdev);\n\tcard->netdev = netdev;\n\tcard->msg_enable = SPIDER_NET_DEFAULT_MSG;\n\tINIT_WORK(&card->tx_timeout_task, spider_net_tx_timeout_task);\n\tinit_waitqueue_head(&card->waitq);\n\tatomic_set(&card->tx_timeout_task_counter, 0);\n\n\tcard->rx_chain.num_desc = rx_descriptors;\n\tcard->rx_chain.ring = card->darray;\n\tcard->tx_chain.num_desc = tx_descriptors;\n\tcard->tx_chain.ring = card->darray + rx_descriptors;\n\n\treturn card;\n}\n\n \nstatic void\nspider_net_undo_pci_setup(struct spider_net_card *card)\n{\n\tiounmap(card->regs);\n\tpci_release_regions(card->pdev);\n}\n\n \nstatic struct spider_net_card *\nspider_net_setup_pci_dev(struct pci_dev *pdev)\n{\n\tstruct spider_net_card *card;\n\tunsigned long mmio_start, mmio_len;\n\n\tif (pci_enable_device(pdev)) {\n\t\tdev_err(&pdev->dev, \"Couldn't enable PCI device\\n\");\n\t\treturn NULL;\n\t}\n\n\tif (!(pci_resource_flags(pdev, 0) & IORESOURCE_MEM)) {\n\t\tdev_err(&pdev->dev,\n\t\t        \"Couldn't find proper PCI device base address.\\n\");\n\t\tgoto out_disable_dev;\n\t}\n\n\tif (pci_request_regions(pdev, spider_net_driver_name)) {\n\t\tdev_err(&pdev->dev,\n\t\t        \"Couldn't obtain PCI resources, aborting.\\n\");\n\t\tgoto out_disable_dev;\n\t}\n\n\tpci_set_master(pdev);\n\n\tcard = spider_net_alloc_card();\n\tif (!card) {\n\t\tdev_err(&pdev->dev,\n\t\t        \"Couldn't allocate net_device structure, aborting.\\n\");\n\t\tgoto out_release_regions;\n\t}\n\tcard->pdev = pdev;\n\n\t \n\tmmio_start = pci_resource_start(pdev, 0);\n\tmmio_len = pci_resource_len(pdev, 0);\n\n\tcard->netdev->mem_start = mmio_start;\n\tcard->netdev->mem_end = mmio_start + mmio_len;\n\tcard->regs = ioremap(mmio_start, mmio_len);\n\n\tif (!card->regs) {\n\t\tdev_err(&pdev->dev,\n\t\t        \"Couldn't obtain PCI resources, aborting.\\n\");\n\t\tgoto out_release_regions;\n\t}\n\n\treturn card;\n\nout_release_regions:\n\tpci_release_regions(pdev);\nout_disable_dev:\n\tpci_disable_device(pdev);\n\treturn NULL;\n}\n\n \nstatic int\nspider_net_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tint err = -EIO;\n\tstruct spider_net_card *card;\n\n\tcard = spider_net_setup_pci_dev(pdev);\n\tif (!card)\n\t\tgoto out;\n\n\tspider_net_workaround_rxramfull(card);\n\tspider_net_init_card(card);\n\n\terr = spider_net_setup_phy(card);\n\tif (err)\n\t\tgoto out_undo_pci;\n\n\terr = spider_net_setup_netdev(card);\n\tif (err)\n\t\tgoto out_undo_pci;\n\n\treturn 0;\n\nout_undo_pci:\n\tspider_net_undo_pci_setup(card);\n\tfree_netdev(card->netdev);\nout:\n\treturn err;\n}\n\n \nstatic void\nspider_net_remove(struct pci_dev *pdev)\n{\n\tstruct net_device *netdev;\n\tstruct spider_net_card *card;\n\n\tnetdev = pci_get_drvdata(pdev);\n\tcard = netdev_priv(netdev);\n\n\twait_event(card->waitq,\n\t\t   atomic_read(&card->tx_timeout_task_counter) == 0);\n\n\tunregister_netdev(netdev);\n\n\t \n\tspider_net_write_reg(card, SPIDER_NET_CKRCTRL,\n\t\t\t     SPIDER_NET_CKRCTRL_STOP_VALUE);\n\tspider_net_write_reg(card, SPIDER_NET_CKRCTRL,\n\t\t\t     SPIDER_NET_CKRCTRL_RUN_VALUE);\n\n\tspider_net_undo_pci_setup(card);\n\tfree_netdev(netdev);\n}\n\nstatic struct pci_driver spider_net_driver = {\n\t.name\t\t= spider_net_driver_name,\n\t.id_table\t= spider_net_pci_tbl,\n\t.probe\t\t= spider_net_probe,\n\t.remove\t\t= spider_net_remove\n};\n\n \nstatic int __init spider_net_init(void)\n{\n\tprintk(KERN_INFO \"Spidernet version %s.\\n\", VERSION);\n\n\tif (rx_descriptors < SPIDER_NET_RX_DESCRIPTORS_MIN) {\n\t\trx_descriptors = SPIDER_NET_RX_DESCRIPTORS_MIN;\n\t\tpr_info(\"adjusting rx descriptors to %i.\\n\", rx_descriptors);\n\t}\n\tif (rx_descriptors > SPIDER_NET_RX_DESCRIPTORS_MAX) {\n\t\trx_descriptors = SPIDER_NET_RX_DESCRIPTORS_MAX;\n\t\tpr_info(\"adjusting rx descriptors to %i.\\n\", rx_descriptors);\n\t}\n\tif (tx_descriptors < SPIDER_NET_TX_DESCRIPTORS_MIN) {\n\t\ttx_descriptors = SPIDER_NET_TX_DESCRIPTORS_MIN;\n\t\tpr_info(\"adjusting tx descriptors to %i.\\n\", tx_descriptors);\n\t}\n\tif (tx_descriptors > SPIDER_NET_TX_DESCRIPTORS_MAX) {\n\t\ttx_descriptors = SPIDER_NET_TX_DESCRIPTORS_MAX;\n\t\tpr_info(\"adjusting tx descriptors to %i.\\n\", tx_descriptors);\n\t}\n\n\treturn pci_register_driver(&spider_net_driver);\n}\n\n \nstatic void __exit spider_net_cleanup(void)\n{\n\tpci_unregister_driver(&spider_net_driver);\n}\n\nmodule_init(spider_net_init);\nmodule_exit(spider_net_cleanup);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}