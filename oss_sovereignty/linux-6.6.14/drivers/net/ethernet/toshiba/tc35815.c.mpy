{
  "module_name": "tc35815.c",
  "hash_id": "3949b9dac8d9bdbf331c6f9899cd160001dd60d16e6b858c35d42f67453f416e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/toshiba/tc35815.c",
  "human_readable_source": " \n\n#define DRV_VERSION\t\"1.39\"\nstatic const char version[] = \"tc35815.c:v\" DRV_VERSION \"\\n\";\n#define MODNAME\t\t\t\"tc35815\"\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/fcntl.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/in.h>\n#include <linux/if_vlan.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/errno.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/skbuff.h>\n#include <linux/delay.h>\n#include <linux/pci.h>\n#include <linux/phy.h>\n#include <linux/workqueue.h>\n#include <linux/platform_device.h>\n#include <linux/prefetch.h>\n#include <asm/io.h>\n#include <asm/byteorder.h>\n\nenum tc35815_chiptype {\n\tTC35815CF = 0,\n\tTC35815_NWU,\n\tTC35815_TX4939,\n};\n\n \nstatic const struct {\n\tconst char *name;\n} chip_info[] = {\n\t{ \"TOSHIBA TC35815CF 10/100BaseTX\" },\n\t{ \"TOSHIBA TC35815 with Wake on LAN\" },\n\t{ \"TOSHIBA TC35815/TX4939\" },\n};\n\nstatic const struct pci_device_id tc35815_pci_tbl[] = {\n\t{PCI_DEVICE(PCI_VENDOR_ID_TOSHIBA_2, PCI_DEVICE_ID_TOSHIBA_TC35815CF), .driver_data = TC35815CF },\n\t{PCI_DEVICE(PCI_VENDOR_ID_TOSHIBA_2, PCI_DEVICE_ID_TOSHIBA_TC35815_NWU), .driver_data = TC35815_NWU },\n\t{PCI_DEVICE(PCI_VENDOR_ID_TOSHIBA_2, PCI_DEVICE_ID_TOSHIBA_TC35815_TX4939), .driver_data = TC35815_TX4939 },\n\t{0,}\n};\nMODULE_DEVICE_TABLE(pci, tc35815_pci_tbl);\n\n \nstatic struct tc35815_options {\n\tint speed;\n\tint duplex;\n} options;\n\n \nstruct tc35815_regs {\n\t__u32 DMA_Ctl;\t\t \n\t__u32 TxFrmPtr;\n\t__u32 TxThrsh;\n\t__u32 TxPollCtr;\n\t__u32 BLFrmPtr;\n\t__u32 RxFragSize;\n\t__u32 Int_En;\n\t__u32 FDA_Bas;\n\t__u32 FDA_Lim;\t\t \n\t__u32 Int_Src;\n\t__u32 unused0[2];\n\t__u32 PauseCnt;\n\t__u32 RemPauCnt;\n\t__u32 TxCtlFrmStat;\n\t__u32 unused1;\n\t__u32 MAC_Ctl;\t\t \n\t__u32 CAM_Ctl;\n\t__u32 Tx_Ctl;\n\t__u32 Tx_Stat;\n\t__u32 Rx_Ctl;\n\t__u32 Rx_Stat;\n\t__u32 MD_Data;\n\t__u32 MD_CA;\n\t__u32 CAM_Adr;\t\t \n\t__u32 CAM_Data;\n\t__u32 CAM_Ena;\n\t__u32 PROM_Ctl;\n\t__u32 PROM_Data;\n\t__u32 Algn_Cnt;\n\t__u32 CRC_Cnt;\n\t__u32 Miss_Cnt;\n};\n\n \n \n#define DMA_RxAlign\t       0x00c00000  \n#define DMA_RxAlign_1\t       0x00400000\n#define DMA_RxAlign_2\t       0x00800000\n#define DMA_RxAlign_3\t       0x00c00000\n#define DMA_M66EnStat\t       0x00080000  \n#define DMA_IntMask\t       0x00040000  \n#define DMA_SWIntReq\t       0x00020000  \n#define DMA_TxWakeUp\t       0x00010000  \n#define DMA_RxBigE\t       0x00008000  \n#define DMA_TxBigE\t       0x00004000  \n#define DMA_TestMode\t       0x00002000  \n#define DMA_PowrMgmnt\t       0x00001000  \n#define DMA_DmBurst_Mask       0x000001fc  \n\n \n#define RxFrag_EnPack\t       0x00008000  \n#define RxFrag_MinFragMask     0x00000ffc  \n\n \n#define MAC_Link10\t       0x00008000  \n#define MAC_EnMissRoll\t       0x00002000  \n#define MAC_MissRoll\t       0x00000400  \n#define MAC_Loop10\t       0x00000080  \n#define MAC_Conn_Auto\t       0x00000000  \n#define MAC_Conn_10M\t       0x00000020  \n#define MAC_Conn_Mll\t       0x00000040  \n#define MAC_MacLoop\t       0x00000010  \n#define MAC_FullDup\t       0x00000008  \n#define MAC_Reset\t       0x00000004  \n#define MAC_HaltImm\t       0x00000002  \n#define MAC_HaltReq\t       0x00000001  \n\n \n#define PROM_Busy\t       0x00008000  \n#define PROM_Read\t       0x00004000  \n#define PROM_Write\t       0x00002000  \n#define PROM_Erase\t       0x00006000  \n\t\t\t\t\t   \n\t\t\t\t\t   \n#define PROM_Addr_Ena\t       0x00000030  \n\t\t\t\t\t   \n\n \n#define CAM_CompEn\t       0x00000010  \n#define CAM_NegCAM\t       0x00000008  \n\t\t\t\t\t   \n#define CAM_BroadAcc\t       0x00000004  \n#define CAM_GroupAcc\t       0x00000002  \n#define CAM_StationAcc\t       0x00000001  \n\n \n#define CAM_ENTRY_MAX\t\t       21    \n#define CAM_Ena_Mask ((1<<CAM_ENTRY_MAX)-1)  \n#define CAM_Ena_Bit(index)\t(1 << (index))\n#define CAM_ENTRY_DESTINATION\t0\n#define CAM_ENTRY_SOURCE\t1\n#define CAM_ENTRY_MACCTL\t20\n\n \n#define Tx_En\t\t       0x00000001  \n#define Tx_TxHalt\t       0x00000002  \n#define Tx_NoPad\t       0x00000004  \n#define Tx_NoCRC\t       0x00000008  \n#define Tx_FBack\t       0x00000010  \n#define Tx_EnUnder\t       0x00000100  \n#define Tx_EnExDefer\t       0x00000200  \n#define Tx_EnLCarr\t       0x00000400  \n#define Tx_EnExColl\t       0x00000800  \n#define Tx_EnLateColl\t       0x00001000  \n#define Tx_EnTxPar\t       0x00002000  \n#define Tx_EnComp\t       0x00004000  \n\n \n#define Tx_TxColl_MASK\t       0x0000000F  \n#define Tx_ExColl\t       0x00000010  \n#define Tx_TXDefer\t       0x00000020  \n#define Tx_Paused\t       0x00000040  \n#define Tx_IntTx\t       0x00000080  \n#define Tx_Under\t       0x00000100  \n#define Tx_Defer\t       0x00000200  \n#define Tx_NCarr\t       0x00000400  \n#define Tx_10Stat\t       0x00000800  \n#define Tx_LateColl\t       0x00001000  \n#define Tx_TxPar\t       0x00002000  \n#define Tx_Comp\t\t       0x00004000  \n#define Tx_Halted\t       0x00008000  \n#define Tx_SQErr\t       0x00010000  \n\n \n#define Rx_EnGood\t       0x00004000  \n#define Rx_EnRxPar\t       0x00002000  \n#define Rx_EnLongErr\t       0x00000800  \n#define Rx_EnOver\t       0x00000400  \n#define Rx_EnCRCErr\t       0x00000200  \n#define Rx_EnAlign\t       0x00000100  \n#define Rx_IgnoreCRC\t       0x00000040  \n#define Rx_StripCRC\t       0x00000010  \n#define Rx_ShortEn\t       0x00000008  \n#define Rx_LongEn\t       0x00000004  \n#define Rx_RxHalt\t       0x00000002  \n#define Rx_RxEn\t\t       0x00000001  \n\n \n#define Rx_Halted\t       0x00008000  \n#define Rx_Good\t\t       0x00004000  \n#define Rx_RxPar\t       0x00002000  \n#define Rx_TypePkt\t       0x00001000  \n#define Rx_LongErr\t       0x00000800  \n#define Rx_Over\t\t       0x00000400  \n#define Rx_CRCErr\t       0x00000200  \n#define Rx_Align\t       0x00000100  \n#define Rx_10Stat\t       0x00000080  \n#define Rx_IntRx\t       0x00000040  \n#define Rx_CtlRecd\t       0x00000020  \n#define Rx_InLenErr\t       0x00000010  \n\n#define Rx_Stat_Mask\t       0x0000FFF0  \n\n \n#define Int_NRAbtEn\t       0x00000800  \n#define Int_TxCtlCmpEn\t       0x00000400  \n#define Int_DmParErrEn\t       0x00000200  \n#define Int_DParDEn\t       0x00000100  \n#define Int_EarNotEn\t       0x00000080  \n#define Int_DParErrEn\t       0x00000040  \n#define Int_SSysErrEn\t       0x00000020  \n#define Int_RMasAbtEn\t       0x00000010  \n#define Int_RTargAbtEn\t       0x00000008  \n#define Int_STargAbtEn\t       0x00000004  \n#define Int_BLExEn\t       0x00000002  \n#define Int_FDAExEn\t       0x00000001  \n\t\t\t\t\t   \n\n \n#define Int_NRabt\t       0x00004000  \n#define Int_DmParErrStat       0x00002000  \n#define Int_BLEx\t       0x00001000  \n#define Int_FDAEx\t       0x00000800  \n#define Int_IntNRAbt\t       0x00000400  \n#define Int_IntCmp\t       0x00000200  \n#define Int_IntExBD\t       0x00000100  \n#define Int_DmParErr\t       0x00000080  \n#define Int_IntEarNot\t       0x00000040  \n#define Int_SWInt\t       0x00000020  \n#define Int_IntBLEx\t       0x00000010  \n#define Int_IntFDAEx\t       0x00000008  \n#define Int_IntPCI\t       0x00000004  \n#define Int_IntMacRx\t       0x00000002  \n#define Int_IntMacTx\t       0x00000001  \n\n \n#define MD_CA_PreSup\t       0x00001000  \n#define MD_CA_Busy\t       0x00000800  \n#define MD_CA_Wr\t       0x00000400  \n\n\n \n\n \nstruct FDesc {\n\tvolatile __u32 FDNext;\n\tvolatile __u32 FDSystem;\n\tvolatile __u32 FDStat;\n\tvolatile __u32 FDCtl;\n};\n\n \nstruct BDesc {\n\tvolatile __u32 BuffData;\n\tvolatile __u32 BDCtl;\n};\n\n#define FD_ALIGN\t16\n\n \n#define FD_FDLength_MASK       0x0000FFFF  \n#define FD_BDCnt_MASK\t       0x001F0000  \n#define FD_FrmOpt_MASK\t       0x7C000000  \n#define FD_FrmOpt_BigEndian    0x40000000  \n#define FD_FrmOpt_IntTx\t       0x20000000  \n#define FD_FrmOpt_NoCRC\t       0x10000000  \n#define FD_FrmOpt_NoPadding    0x08000000  \n#define FD_FrmOpt_Packing      0x04000000  \n#define FD_CownsFD\t       0x80000000  \n#define FD_Next_EOL\t       0x00000001  \n#define FD_BDCnt_SHIFT\t       16\n\n \n#define BD_BuffLength_MASK     0x0000FFFF  \n#define BD_RxBDID_MASK\t       0x00FF0000  \n#define BD_RxBDSeqN_MASK       0x7F000000  \n#define BD_CownsBD\t       0x80000000  \n#define BD_RxBDID_SHIFT\t       16\n#define BD_RxBDSeqN_SHIFT      24\n\n\n \n\n#define TX_CTL_CMD\t(Tx_EnTxPar | Tx_EnLateColl | \\\n\tTx_EnExColl | Tx_EnLCarr | Tx_EnExDefer | Tx_EnUnder | \\\n\tTx_En)\t \n \n#define RX_CTL_CMD\t(Rx_EnGood | Rx_EnRxPar | Rx_EnLongErr | Rx_EnOver \\\n\t| Rx_EnCRCErr | Rx_EnAlign | Rx_RxEn)  \n#define INT_EN_CMD  (Int_NRAbtEn | \\\n\tInt_DmParErrEn | Int_DParDEn | Int_DParErrEn | \\\n\tInt_SSysErrEn  | Int_RMasAbtEn | Int_RTargAbtEn | \\\n\tInt_STargAbtEn | \\\n\tInt_BLExEn  | Int_FDAExEn)  \n#define DMA_CTL_CMD\tDMA_BURST_SIZE\n#define HAVE_DMA_RXALIGN(lp)\tlikely((lp)->chiptype != TC35815CF)\n\n \n#define DMA_BURST_SIZE\t32\n#define TX_THRESHOLD\t1024\n \n#define TX_THRESHOLD_MAX 1536\n \n#define TX_THRESHOLD_KEEP_LIMIT 10\n\n \n#define FD_PAGE_NUM 4\n#define RX_BUF_NUM\t128\t \n#define RX_FD_NUM\t256\t \n#define TX_FD_NUM\t128\n#if RX_CTL_CMD & Rx_LongEn\n#define RX_BUF_SIZE\tPAGE_SIZE\n#elif RX_CTL_CMD & Rx_StripCRC\n#define RX_BUF_SIZE\t\\\n\tL1_CACHE_ALIGN(ETH_FRAME_LEN + VLAN_HLEN + NET_IP_ALIGN)\n#else\n#define RX_BUF_SIZE\t\\\n\tL1_CACHE_ALIGN(ETH_FRAME_LEN + VLAN_HLEN + ETH_FCS_LEN + NET_IP_ALIGN)\n#endif\n#define RX_FD_RESERVE\t(2 / 2)\t \n#define NAPI_WEIGHT\t16\n\nstruct TxFD {\n\tstruct FDesc fd;\n\tstruct BDesc bd;\n\tstruct BDesc unused;\n};\n\nstruct RxFD {\n\tstruct FDesc fd;\n\tstruct BDesc bd[];\t \n};\n\nstruct FrFD {\n\tstruct FDesc fd;\n\tstruct BDesc bd[RX_BUF_NUM];\n};\n\n\n#define tc_readl(addr)\tioread32(addr)\n#define tc_writel(d, addr)\tiowrite32(d, addr)\n\n#define TC35815_TX_TIMEOUT  msecs_to_jiffies(400)\n\n \nstruct tc35815_local {\n\tstruct pci_dev *pci_dev;\n\n\tstruct net_device *dev;\n\tstruct napi_struct napi;\n\n\t \n\tstruct {\n\t\tint max_tx_qlen;\n\t\tint tx_ints;\n\t\tint rx_ints;\n\t\tint tx_underrun;\n\t} lstats;\n\n\t \n\tspinlock_t lock;\n\tspinlock_t rx_lock;\n\n\tstruct mii_bus *mii_bus;\n\tint duplex;\n\tint speed;\n\tint link;\n\tstruct work_struct restart_work;\n\n\t \n\tvoid *fd_buf;\t \n\tdma_addr_t fd_buf_dma;\n\tstruct TxFD *tfd_base;\n\tunsigned int tfd_start;\n\tunsigned int tfd_end;\n\tstruct RxFD *rfd_base;\n\tstruct RxFD *rfd_limit;\n\tstruct RxFD *rfd_cur;\n\tstruct FrFD *fbl_ptr;\n\tunsigned int fbl_count;\n\tstruct {\n\t\tstruct sk_buff *skb;\n\t\tdma_addr_t skb_dma;\n\t} tx_skbs[TX_FD_NUM], rx_skbs[RX_BUF_NUM];\n\tu32 msg_enable;\n\tenum tc35815_chiptype chiptype;\n};\n\nstatic inline dma_addr_t fd_virt_to_bus(struct tc35815_local *lp, void *virt)\n{\n\treturn lp->fd_buf_dma + ((u8 *)virt - (u8 *)lp->fd_buf);\n}\n#ifdef DEBUG\nstatic inline void *fd_bus_to_virt(struct tc35815_local *lp, dma_addr_t bus)\n{\n\treturn (void *)((u8 *)lp->fd_buf + (bus - lp->fd_buf_dma));\n}\n#endif\nstatic struct sk_buff *alloc_rxbuf_skb(struct net_device *dev,\n\t\t\t\t       struct pci_dev *hwdev,\n\t\t\t\t       dma_addr_t *dma_handle)\n{\n\tstruct sk_buff *skb;\n\tskb = netdev_alloc_skb(dev, RX_BUF_SIZE);\n\tif (!skb)\n\t\treturn NULL;\n\t*dma_handle = dma_map_single(&hwdev->dev, skb->data, RX_BUF_SIZE,\n\t\t\t\t     DMA_FROM_DEVICE);\n\tif (dma_mapping_error(&hwdev->dev, *dma_handle)) {\n\t\tdev_kfree_skb_any(skb);\n\t\treturn NULL;\n\t}\n\tskb_reserve(skb, 2);\t \n\treturn skb;\n}\n\nstatic void free_rxbuf_skb(struct pci_dev *hwdev, struct sk_buff *skb, dma_addr_t dma_handle)\n{\n\tdma_unmap_single(&hwdev->dev, dma_handle, RX_BUF_SIZE,\n\t\t\t DMA_FROM_DEVICE);\n\tdev_kfree_skb_any(skb);\n}\n\n \n\nstatic int\ttc35815_open(struct net_device *dev);\nstatic netdev_tx_t\ttc35815_send_packet(struct sk_buff *skb,\n\t\t\t\t\t    struct net_device *dev);\nstatic irqreturn_t\ttc35815_interrupt(int irq, void *dev_id);\nstatic int\ttc35815_rx(struct net_device *dev, int limit);\nstatic int\ttc35815_poll(struct napi_struct *napi, int budget);\nstatic void\ttc35815_txdone(struct net_device *dev);\nstatic int\ttc35815_close(struct net_device *dev);\nstatic struct\tnet_device_stats *tc35815_get_stats(struct net_device *dev);\nstatic void\ttc35815_set_multicast_list(struct net_device *dev);\nstatic void\ttc35815_tx_timeout(struct net_device *dev, unsigned int txqueue);\n#ifdef CONFIG_NET_POLL_CONTROLLER\nstatic void\ttc35815_poll_controller(struct net_device *dev);\n#endif\nstatic const struct ethtool_ops tc35815_ethtool_ops;\n\n \nstatic void\ttc35815_chip_reset(struct net_device *dev);\nstatic void\ttc35815_chip_init(struct net_device *dev);\n\n#ifdef DEBUG\nstatic void\tpanic_queues(struct net_device *dev);\n#endif\n\nstatic void tc35815_restart_work(struct work_struct *work);\n\nstatic int tc_mdio_read(struct mii_bus *bus, int mii_id, int regnum)\n{\n\tstruct net_device *dev = bus->priv;\n\tstruct tc35815_regs __iomem *tr =\n\t\t(struct tc35815_regs __iomem *)dev->base_addr;\n\tunsigned long timeout = jiffies + HZ;\n\n\ttc_writel(MD_CA_Busy | (mii_id << 5) | (regnum & 0x1f), &tr->MD_CA);\n\tudelay(12);  \n\twhile (tc_readl(&tr->MD_CA) & MD_CA_Busy) {\n\t\tif (time_after(jiffies, timeout))\n\t\t\treturn -EIO;\n\t\tcpu_relax();\n\t}\n\treturn tc_readl(&tr->MD_Data) & 0xffff;\n}\n\nstatic int tc_mdio_write(struct mii_bus *bus, int mii_id, int regnum, u16 val)\n{\n\tstruct net_device *dev = bus->priv;\n\tstruct tc35815_regs __iomem *tr =\n\t\t(struct tc35815_regs __iomem *)dev->base_addr;\n\tunsigned long timeout = jiffies + HZ;\n\n\ttc_writel(val, &tr->MD_Data);\n\ttc_writel(MD_CA_Busy | MD_CA_Wr | (mii_id << 5) | (regnum & 0x1f),\n\t\t  &tr->MD_CA);\n\tudelay(12);  \n\twhile (tc_readl(&tr->MD_CA) & MD_CA_Busy) {\n\t\tif (time_after(jiffies, timeout))\n\t\t\treturn -EIO;\n\t\tcpu_relax();\n\t}\n\treturn 0;\n}\n\nstatic void tc_handle_link_change(struct net_device *dev)\n{\n\tstruct tc35815_local *lp = netdev_priv(dev);\n\tstruct phy_device *phydev = dev->phydev;\n\tunsigned long flags;\n\tint status_change = 0;\n\n\tspin_lock_irqsave(&lp->lock, flags);\n\tif (phydev->link &&\n\t    (lp->speed != phydev->speed || lp->duplex != phydev->duplex)) {\n\t\tstruct tc35815_regs __iomem *tr =\n\t\t\t(struct tc35815_regs __iomem *)dev->base_addr;\n\t\tu32 reg;\n\n\t\treg = tc_readl(&tr->MAC_Ctl);\n\t\treg |= MAC_HaltReq;\n\t\ttc_writel(reg, &tr->MAC_Ctl);\n\t\tif (phydev->duplex == DUPLEX_FULL)\n\t\t\treg |= MAC_FullDup;\n\t\telse\n\t\t\treg &= ~MAC_FullDup;\n\t\ttc_writel(reg, &tr->MAC_Ctl);\n\t\treg &= ~MAC_HaltReq;\n\t\ttc_writel(reg, &tr->MAC_Ctl);\n\n\t\t \n\t\t \n\t\tif (phydev->duplex == DUPLEX_HALF &&\n\t\t    lp->chiptype != TC35815_TX4939)\n\t\t\ttc_writel(tc_readl(&tr->Tx_Ctl) | Tx_EnLCarr,\n\t\t\t\t  &tr->Tx_Ctl);\n\n\t\tlp->speed = phydev->speed;\n\t\tlp->duplex = phydev->duplex;\n\t\tstatus_change = 1;\n\t}\n\n\tif (phydev->link != lp->link) {\n\t\tif (phydev->link) {\n\t\t\t \n\t\t\tif (dev->flags & IFF_PROMISC)\n\t\t\t\ttc35815_set_multicast_list(dev);\n\t\t} else {\n\t\t\tlp->speed = 0;\n\t\t\tlp->duplex = -1;\n\t\t}\n\t\tlp->link = phydev->link;\n\n\t\tstatus_change = 1;\n\t}\n\tspin_unlock_irqrestore(&lp->lock, flags);\n\n\tif (status_change && netif_msg_link(lp)) {\n\t\tphy_print_status(phydev);\n\t\tpr_debug(\"%s: MII BMCR %04x BMSR %04x LPA %04x\\n\",\n\t\t\t dev->name,\n\t\t\t phy_read(phydev, MII_BMCR),\n\t\t\t phy_read(phydev, MII_BMSR),\n\t\t\t phy_read(phydev, MII_LPA));\n\t}\n}\n\nstatic int tc_mii_probe(struct net_device *dev)\n{\n\t__ETHTOOL_DECLARE_LINK_MODE_MASK(mask) = { 0, };\n\tstruct tc35815_local *lp = netdev_priv(dev);\n\tstruct phy_device *phydev;\n\n\tphydev = phy_find_first(lp->mii_bus);\n\tif (!phydev) {\n\t\tprintk(KERN_ERR \"%s: no PHY found\\n\", dev->name);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tphydev = phy_connect(dev, phydev_name(phydev),\n\t\t\t     &tc_handle_link_change,\n\t\t\t     lp->chiptype == TC35815_TX4939 ? PHY_INTERFACE_MODE_RMII : PHY_INTERFACE_MODE_MII);\n\tif (IS_ERR(phydev)) {\n\t\tprintk(KERN_ERR \"%s: Could not attach to PHY\\n\", dev->name);\n\t\treturn PTR_ERR(phydev);\n\t}\n\n\tphy_attached_info(phydev);\n\n\t \n\tphy_set_max_speed(phydev, SPEED_100);\n\tif (options.speed == 10) {\n\t\tlinkmode_set_bit(ETHTOOL_LINK_MODE_100baseT_Half_BIT, mask);\n\t\tlinkmode_set_bit(ETHTOOL_LINK_MODE_100baseT_Full_BIT, mask);\n\t} else if (options.speed == 100) {\n\t\tlinkmode_set_bit(ETHTOOL_LINK_MODE_10baseT_Half_BIT, mask);\n\t\tlinkmode_set_bit(ETHTOOL_LINK_MODE_10baseT_Full_BIT, mask);\n\t}\n\tif (options.duplex == 1) {\n\t\tlinkmode_set_bit(ETHTOOL_LINK_MODE_10baseT_Full_BIT, mask);\n\t\tlinkmode_set_bit(ETHTOOL_LINK_MODE_100baseT_Full_BIT, mask);\n\t} else if (options.duplex == 2) {\n\t\tlinkmode_set_bit(ETHTOOL_LINK_MODE_10baseT_Half_BIT, mask);\n\t\tlinkmode_set_bit(ETHTOOL_LINK_MODE_100baseT_Half_BIT, mask);\n\t}\n\tlinkmode_andnot(phydev->supported, phydev->supported, mask);\n\tlinkmode_copy(phydev->advertising, phydev->supported);\n\n\tlp->link = 0;\n\tlp->speed = 0;\n\tlp->duplex = -1;\n\n\treturn 0;\n}\n\nstatic int tc_mii_init(struct net_device *dev)\n{\n\tstruct tc35815_local *lp = netdev_priv(dev);\n\tint err;\n\n\tlp->mii_bus = mdiobus_alloc();\n\tif (lp->mii_bus == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\n\tlp->mii_bus->name = \"tc35815_mii_bus\";\n\tlp->mii_bus->read = tc_mdio_read;\n\tlp->mii_bus->write = tc_mdio_write;\n\tsnprintf(lp->mii_bus->id, MII_BUS_ID_SIZE, \"%x\", pci_dev_id(lp->pci_dev));\n\tlp->mii_bus->priv = dev;\n\tlp->mii_bus->parent = &lp->pci_dev->dev;\n\terr = mdiobus_register(lp->mii_bus);\n\tif (err)\n\t\tgoto err_out_free_mii_bus;\n\terr = tc_mii_probe(dev);\n\tif (err)\n\t\tgoto err_out_unregister_bus;\n\treturn 0;\n\nerr_out_unregister_bus:\n\tmdiobus_unregister(lp->mii_bus);\nerr_out_free_mii_bus:\n\tmdiobus_free(lp->mii_bus);\nerr_out:\n\treturn err;\n}\n\n#ifdef CONFIG_CPU_TX49XX\n \nstatic int tc35815_mac_match(struct device *dev, const void *data)\n{\n\tstruct platform_device *plat_dev = to_platform_device(dev);\n\tconst struct pci_dev *pci_dev = data;\n\tunsigned int id = pci_dev->irq;\n\treturn !strcmp(plat_dev->name, \"tc35815-mac\") && plat_dev->id == id;\n}\n\nstatic int tc35815_read_plat_dev_addr(struct net_device *dev)\n{\n\tstruct tc35815_local *lp = netdev_priv(dev);\n\tstruct device *pd = bus_find_device(&platform_bus_type, NULL,\n\t\t\t\t\t    lp->pci_dev, tc35815_mac_match);\n\tif (pd) {\n\t\tif (pd->platform_data)\n\t\t\teth_hw_addr_set(dev, pd->platform_data);\n\t\tput_device(pd);\n\t\treturn is_valid_ether_addr(dev->dev_addr) ? 0 : -ENODEV;\n\t}\n\treturn -ENODEV;\n}\n#else\nstatic int tc35815_read_plat_dev_addr(struct net_device *dev)\n{\n\treturn -ENODEV;\n}\n#endif\n\nstatic int tc35815_init_dev_addr(struct net_device *dev)\n{\n\tstruct tc35815_regs __iomem *tr =\n\t\t(struct tc35815_regs __iomem *)dev->base_addr;\n\tu8 addr[ETH_ALEN];\n\tint i;\n\n\twhile (tc_readl(&tr->PROM_Ctl) & PROM_Busy)\n\t\t;\n\tfor (i = 0; i < 6; i += 2) {\n\t\tunsigned short data;\n\t\ttc_writel(PROM_Busy | PROM_Read | (i / 2 + 2), &tr->PROM_Ctl);\n\t\twhile (tc_readl(&tr->PROM_Ctl) & PROM_Busy)\n\t\t\t;\n\t\tdata = tc_readl(&tr->PROM_Data);\n\t\taddr[i] = data & 0xff;\n\t\taddr[i+1] = data >> 8;\n\t}\n\teth_hw_addr_set(dev, addr);\n\tif (!is_valid_ether_addr(dev->dev_addr))\n\t\treturn tc35815_read_plat_dev_addr(dev);\n\treturn 0;\n}\n\nstatic const struct net_device_ops tc35815_netdev_ops = {\n\t.ndo_open\t\t= tc35815_open,\n\t.ndo_stop\t\t= tc35815_close,\n\t.ndo_start_xmit\t\t= tc35815_send_packet,\n\t.ndo_get_stats\t\t= tc35815_get_stats,\n\t.ndo_set_rx_mode\t= tc35815_set_multicast_list,\n\t.ndo_tx_timeout\t\t= tc35815_tx_timeout,\n\t.ndo_eth_ioctl\t\t= phy_do_ioctl_running,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_set_mac_address\t= eth_mac_addr,\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\t.ndo_poll_controller\t= tc35815_poll_controller,\n#endif\n};\n\nstatic int tc35815_init_one(struct pci_dev *pdev,\n\t\t\t    const struct pci_device_id *ent)\n{\n\tvoid __iomem *ioaddr = NULL;\n\tstruct net_device *dev;\n\tstruct tc35815_local *lp;\n\tint rc;\n\n\tstatic int printed_version;\n\tif (!printed_version++) {\n\t\tprintk(version);\n\t\tdev_printk(KERN_DEBUG, &pdev->dev,\n\t\t\t   \"speed:%d duplex:%d\\n\",\n\t\t\t   options.speed, options.duplex);\n\t}\n\n\tif (!pdev->irq) {\n\t\tdev_warn(&pdev->dev, \"no IRQ assigned.\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tdev = alloc_etherdev(sizeof(*lp));\n\tif (dev == NULL)\n\t\treturn -ENOMEM;\n\n\tSET_NETDEV_DEV(dev, &pdev->dev);\n\tlp = netdev_priv(dev);\n\tlp->dev = dev;\n\n\t \n\trc = pcim_enable_device(pdev);\n\tif (rc)\n\t\tgoto err_out;\n\trc = pcim_iomap_regions(pdev, 1 << 1, MODNAME);\n\tif (rc)\n\t\tgoto err_out;\n\tpci_set_master(pdev);\n\tioaddr = pcim_iomap_table(pdev)[1];\n\n\t \n\tdev->netdev_ops = &tc35815_netdev_ops;\n\tdev->ethtool_ops = &tc35815_ethtool_ops;\n\tdev->watchdog_timeo = TC35815_TX_TIMEOUT;\n\tnetif_napi_add_weight(dev, &lp->napi, tc35815_poll, NAPI_WEIGHT);\n\n\tdev->irq = pdev->irq;\n\tdev->base_addr = (unsigned long)ioaddr;\n\n\tINIT_WORK(&lp->restart_work, tc35815_restart_work);\n\tspin_lock_init(&lp->lock);\n\tspin_lock_init(&lp->rx_lock);\n\tlp->pci_dev = pdev;\n\tlp->chiptype = ent->driver_data;\n\n\tlp->msg_enable = NETIF_MSG_TX_ERR | NETIF_MSG_HW | NETIF_MSG_DRV | NETIF_MSG_LINK;\n\tpci_set_drvdata(pdev, dev);\n\n\t \n\ttc35815_chip_reset(dev);\n\n\t \n\tif (tc35815_init_dev_addr(dev)) {\n\t\tdev_warn(&pdev->dev, \"not valid ether addr\\n\");\n\t\teth_hw_addr_random(dev);\n\t}\n\n\trc = register_netdev(dev);\n\tif (rc)\n\t\tgoto err_out;\n\n\tprintk(KERN_INFO \"%s: %s at 0x%lx, %pM, IRQ %d\\n\",\n\t\tdev->name,\n\t\tchip_info[ent->driver_data].name,\n\t\tdev->base_addr,\n\t\tdev->dev_addr,\n\t\tdev->irq);\n\n\trc = tc_mii_init(dev);\n\tif (rc)\n\t\tgoto err_out_unregister;\n\n\treturn 0;\n\nerr_out_unregister:\n\tunregister_netdev(dev);\nerr_out:\n\tfree_netdev(dev);\n\treturn rc;\n}\n\n\nstatic void tc35815_remove_one(struct pci_dev *pdev)\n{\n\tstruct net_device *dev = pci_get_drvdata(pdev);\n\tstruct tc35815_local *lp = netdev_priv(dev);\n\n\tphy_disconnect(dev->phydev);\n\tmdiobus_unregister(lp->mii_bus);\n\tmdiobus_free(lp->mii_bus);\n\tunregister_netdev(dev);\n\tfree_netdev(dev);\n}\n\nstatic int\ntc35815_init_queues(struct net_device *dev)\n{\n\tstruct tc35815_local *lp = netdev_priv(dev);\n\tint i;\n\tunsigned long fd_addr;\n\n\tif (!lp->fd_buf) {\n\t\tBUG_ON(sizeof(struct FDesc) +\n\t\t       sizeof(struct BDesc) * RX_BUF_NUM +\n\t\t       sizeof(struct FDesc) * RX_FD_NUM +\n\t\t       sizeof(struct TxFD) * TX_FD_NUM >\n\t\t       PAGE_SIZE * FD_PAGE_NUM);\n\n\t\tlp->fd_buf = dma_alloc_coherent(&lp->pci_dev->dev,\n\t\t\t\t\t\tPAGE_SIZE * FD_PAGE_NUM,\n\t\t\t\t\t\t&lp->fd_buf_dma, GFP_ATOMIC);\n\t\tif (!lp->fd_buf)\n\t\t\treturn -ENOMEM;\n\t\tfor (i = 0; i < RX_BUF_NUM; i++) {\n\t\t\tlp->rx_skbs[i].skb =\n\t\t\t\talloc_rxbuf_skb(dev, lp->pci_dev,\n\t\t\t\t\t\t&lp->rx_skbs[i].skb_dma);\n\t\t\tif (!lp->rx_skbs[i].skb) {\n\t\t\t\twhile (--i >= 0) {\n\t\t\t\t\tfree_rxbuf_skb(lp->pci_dev,\n\t\t\t\t\t\t       lp->rx_skbs[i].skb,\n\t\t\t\t\t\t       lp->rx_skbs[i].skb_dma);\n\t\t\t\t\tlp->rx_skbs[i].skb = NULL;\n\t\t\t\t}\n\t\t\t\tdma_free_coherent(&lp->pci_dev->dev,\n\t\t\t\t\t\t  PAGE_SIZE * FD_PAGE_NUM,\n\t\t\t\t\t\t  lp->fd_buf, lp->fd_buf_dma);\n\t\t\t\tlp->fd_buf = NULL;\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t}\n\t\tprintk(KERN_DEBUG \"%s: FD buf %p DataBuf\",\n\t\t       dev->name, lp->fd_buf);\n\t\tprintk(\"\\n\");\n\t} else {\n\t\tfor (i = 0; i < FD_PAGE_NUM; i++)\n\t\t\tclear_page((void *)((unsigned long)lp->fd_buf +\n\t\t\t\t\t    i * PAGE_SIZE));\n\t}\n\tfd_addr = (unsigned long)lp->fd_buf;\n\n\t \n\tlp->rfd_base = (struct RxFD *)fd_addr;\n\tfd_addr += sizeof(struct RxFD) * RX_FD_NUM;\n\tfor (i = 0; i < RX_FD_NUM; i++)\n\t\tlp->rfd_base[i].fd.FDCtl = cpu_to_le32(FD_CownsFD);\n\tlp->rfd_cur = lp->rfd_base;\n\tlp->rfd_limit = (struct RxFD *)fd_addr - (RX_FD_RESERVE + 1);\n\n\t \n\tlp->tfd_base = (struct TxFD *)fd_addr;\n\tfd_addr += sizeof(struct TxFD) * TX_FD_NUM;\n\tfor (i = 0; i < TX_FD_NUM; i++) {\n\t\tlp->tfd_base[i].fd.FDNext = cpu_to_le32(fd_virt_to_bus(lp, &lp->tfd_base[i+1]));\n\t\tlp->tfd_base[i].fd.FDSystem = cpu_to_le32(0xffffffff);\n\t\tlp->tfd_base[i].fd.FDCtl = cpu_to_le32(0);\n\t}\n\tlp->tfd_base[TX_FD_NUM-1].fd.FDNext = cpu_to_le32(fd_virt_to_bus(lp, &lp->tfd_base[0]));\n\tlp->tfd_start = 0;\n\tlp->tfd_end = 0;\n\n\t \n\tlp->fbl_ptr = (struct FrFD *)fd_addr;\n\tlp->fbl_ptr->fd.FDNext = cpu_to_le32(fd_virt_to_bus(lp, lp->fbl_ptr));\n\tlp->fbl_ptr->fd.FDCtl = cpu_to_le32(RX_BUF_NUM | FD_CownsFD);\n\t \n\tlp->fbl_count = 0;\n\tfor (i = 0; i < RX_BUF_NUM; i++) {\n\t\tif (lp->rx_skbs[i].skb) {\n\t\t\tif (i != lp->fbl_count) {\n\t\t\t\tlp->rx_skbs[lp->fbl_count].skb =\n\t\t\t\t\tlp->rx_skbs[i].skb;\n\t\t\t\tlp->rx_skbs[lp->fbl_count].skb_dma =\n\t\t\t\t\tlp->rx_skbs[i].skb_dma;\n\t\t\t}\n\t\t\tlp->fbl_count++;\n\t\t}\n\t}\n\tfor (i = 0; i < RX_BUF_NUM; i++) {\n\t\tif (i >= lp->fbl_count) {\n\t\t\tlp->fbl_ptr->bd[i].BuffData = 0;\n\t\t\tlp->fbl_ptr->bd[i].BDCtl = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tlp->fbl_ptr->bd[i].BuffData =\n\t\t\tcpu_to_le32(lp->rx_skbs[i].skb_dma);\n\t\t \n\t\tlp->fbl_ptr->bd[i].BDCtl =\n\t\t\tcpu_to_le32(BD_CownsBD | (i << BD_RxBDID_SHIFT) |\n\t\t\t\t    RX_BUF_SIZE);\n\t}\n\n\tprintk(KERN_DEBUG \"%s: TxFD %p RxFD %p FrFD %p\\n\",\n\t       dev->name, lp->tfd_base, lp->rfd_base, lp->fbl_ptr);\n\treturn 0;\n}\n\nstatic void\ntc35815_clear_queues(struct net_device *dev)\n{\n\tstruct tc35815_local *lp = netdev_priv(dev);\n\tint i;\n\n\tfor (i = 0; i < TX_FD_NUM; i++) {\n\t\tu32 fdsystem = le32_to_cpu(lp->tfd_base[i].fd.FDSystem);\n\t\tstruct sk_buff *skb =\n\t\t\tfdsystem != 0xffffffff ?\n\t\t\tlp->tx_skbs[fdsystem].skb : NULL;\n#ifdef DEBUG\n\t\tif (lp->tx_skbs[i].skb != skb) {\n\t\t\tprintk(\"%s: tx_skbs mismatch(%d).\\n\", dev->name, i);\n\t\t\tpanic_queues(dev);\n\t\t}\n#else\n\t\tBUG_ON(lp->tx_skbs[i].skb != skb);\n#endif\n\t\tif (skb) {\n\t\t\tdma_unmap_single(&lp->pci_dev->dev,\n\t\t\t\t\t lp->tx_skbs[i].skb_dma, skb->len,\n\t\t\t\t\t DMA_TO_DEVICE);\n\t\t\tlp->tx_skbs[i].skb = NULL;\n\t\t\tlp->tx_skbs[i].skb_dma = 0;\n\t\t\tdev_kfree_skb_any(skb);\n\t\t}\n\t\tlp->tfd_base[i].fd.FDSystem = cpu_to_le32(0xffffffff);\n\t}\n\n\ttc35815_init_queues(dev);\n}\n\nstatic void\ntc35815_free_queues(struct net_device *dev)\n{\n\tstruct tc35815_local *lp = netdev_priv(dev);\n\tint i;\n\n\tif (lp->tfd_base) {\n\t\tfor (i = 0; i < TX_FD_NUM; i++) {\n\t\t\tu32 fdsystem = le32_to_cpu(lp->tfd_base[i].fd.FDSystem);\n\t\t\tstruct sk_buff *skb =\n\t\t\t\tfdsystem != 0xffffffff ?\n\t\t\t\tlp->tx_skbs[fdsystem].skb : NULL;\n#ifdef DEBUG\n\t\t\tif (lp->tx_skbs[i].skb != skb) {\n\t\t\t\tprintk(\"%s: tx_skbs mismatch(%d).\\n\", dev->name, i);\n\t\t\t\tpanic_queues(dev);\n\t\t\t}\n#else\n\t\t\tBUG_ON(lp->tx_skbs[i].skb != skb);\n#endif\n\t\t\tif (skb) {\n\t\t\t\tdma_unmap_single(&lp->pci_dev->dev,\n\t\t\t\t\t\t lp->tx_skbs[i].skb_dma,\n\t\t\t\t\t\t skb->len, DMA_TO_DEVICE);\n\t\t\t\tdev_kfree_skb(skb);\n\t\t\t\tlp->tx_skbs[i].skb = NULL;\n\t\t\t\tlp->tx_skbs[i].skb_dma = 0;\n\t\t\t}\n\t\t\tlp->tfd_base[i].fd.FDSystem = cpu_to_le32(0xffffffff);\n\t\t}\n\t}\n\n\tlp->rfd_base = NULL;\n\tlp->rfd_limit = NULL;\n\tlp->rfd_cur = NULL;\n\tlp->fbl_ptr = NULL;\n\n\tfor (i = 0; i < RX_BUF_NUM; i++) {\n\t\tif (lp->rx_skbs[i].skb) {\n\t\t\tfree_rxbuf_skb(lp->pci_dev, lp->rx_skbs[i].skb,\n\t\t\t\t       lp->rx_skbs[i].skb_dma);\n\t\t\tlp->rx_skbs[i].skb = NULL;\n\t\t}\n\t}\n\tif (lp->fd_buf) {\n\t\tdma_free_coherent(&lp->pci_dev->dev, PAGE_SIZE * FD_PAGE_NUM,\n\t\t\t\t  lp->fd_buf, lp->fd_buf_dma);\n\t\tlp->fd_buf = NULL;\n\t}\n}\n\nstatic void\ndump_txfd(struct TxFD *fd)\n{\n\tprintk(\"TxFD(%p): %08x %08x %08x %08x\\n\", fd,\n\t       le32_to_cpu(fd->fd.FDNext),\n\t       le32_to_cpu(fd->fd.FDSystem),\n\t       le32_to_cpu(fd->fd.FDStat),\n\t       le32_to_cpu(fd->fd.FDCtl));\n\tprintk(\"BD: \");\n\tprintk(\" %08x %08x\",\n\t       le32_to_cpu(fd->bd.BuffData),\n\t       le32_to_cpu(fd->bd.BDCtl));\n\tprintk(\"\\n\");\n}\n\nstatic int\ndump_rxfd(struct RxFD *fd)\n{\n\tint i, bd_count = (le32_to_cpu(fd->fd.FDCtl) & FD_BDCnt_MASK) >> FD_BDCnt_SHIFT;\n\tif (bd_count > 8)\n\t\tbd_count = 8;\n\tprintk(\"RxFD(%p): %08x %08x %08x %08x\\n\", fd,\n\t       le32_to_cpu(fd->fd.FDNext),\n\t       le32_to_cpu(fd->fd.FDSystem),\n\t       le32_to_cpu(fd->fd.FDStat),\n\t       le32_to_cpu(fd->fd.FDCtl));\n\tif (le32_to_cpu(fd->fd.FDCtl) & FD_CownsFD)\n\t\treturn 0;\n\tprintk(\"BD: \");\n\tfor (i = 0; i < bd_count; i++)\n\t\tprintk(\" %08x %08x\",\n\t\t       le32_to_cpu(fd->bd[i].BuffData),\n\t\t       le32_to_cpu(fd->bd[i].BDCtl));\n\tprintk(\"\\n\");\n\treturn bd_count;\n}\n\n#ifdef DEBUG\nstatic void\ndump_frfd(struct FrFD *fd)\n{\n\tint i;\n\tprintk(\"FrFD(%p): %08x %08x %08x %08x\\n\", fd,\n\t       le32_to_cpu(fd->fd.FDNext),\n\t       le32_to_cpu(fd->fd.FDSystem),\n\t       le32_to_cpu(fd->fd.FDStat),\n\t       le32_to_cpu(fd->fd.FDCtl));\n\tprintk(\"BD: \");\n\tfor (i = 0; i < RX_BUF_NUM; i++)\n\t\tprintk(\" %08x %08x\",\n\t\t       le32_to_cpu(fd->bd[i].BuffData),\n\t\t       le32_to_cpu(fd->bd[i].BDCtl));\n\tprintk(\"\\n\");\n}\n\nstatic void\npanic_queues(struct net_device *dev)\n{\n\tstruct tc35815_local *lp = netdev_priv(dev);\n\tint i;\n\n\tprintk(\"TxFD base %p, start %u, end %u\\n\",\n\t       lp->tfd_base, lp->tfd_start, lp->tfd_end);\n\tprintk(\"RxFD base %p limit %p cur %p\\n\",\n\t       lp->rfd_base, lp->rfd_limit, lp->rfd_cur);\n\tprintk(\"FrFD %p\\n\", lp->fbl_ptr);\n\tfor (i = 0; i < TX_FD_NUM; i++)\n\t\tdump_txfd(&lp->tfd_base[i]);\n\tfor (i = 0; i < RX_FD_NUM; i++) {\n\t\tint bd_count = dump_rxfd(&lp->rfd_base[i]);\n\t\ti += (bd_count + 1) / 2;\t \n\t}\n\tdump_frfd(lp->fbl_ptr);\n\tpanic(\"%s: Illegal queue state.\", dev->name);\n}\n#endif\n\nstatic void print_eth(const u8 *add)\n{\n\tprintk(KERN_DEBUG \"print_eth(%p)\\n\", add);\n\tprintk(KERN_DEBUG \" %pM => %pM : %02x%02x\\n\",\n\t\tadd + 6, add, add[12], add[13]);\n}\n\nstatic int tc35815_tx_full(struct net_device *dev)\n{\n\tstruct tc35815_local *lp = netdev_priv(dev);\n\treturn (lp->tfd_start + 1) % TX_FD_NUM == lp->tfd_end;\n}\n\nstatic void tc35815_restart(struct net_device *dev)\n{\n\tstruct tc35815_local *lp = netdev_priv(dev);\n\tint ret;\n\n\tif (dev->phydev) {\n\t\tret = phy_init_hw(dev->phydev);\n\t\tif (ret)\n\t\t\tprintk(KERN_ERR \"%s: PHY init failed.\\n\", dev->name);\n\t}\n\n\tspin_lock_bh(&lp->rx_lock);\n\tspin_lock_irq(&lp->lock);\n\ttc35815_chip_reset(dev);\n\ttc35815_clear_queues(dev);\n\ttc35815_chip_init(dev);\n\t \n\ttc35815_set_multicast_list(dev);\n\tspin_unlock_irq(&lp->lock);\n\tspin_unlock_bh(&lp->rx_lock);\n\n\tnetif_wake_queue(dev);\n}\n\nstatic void tc35815_restart_work(struct work_struct *work)\n{\n\tstruct tc35815_local *lp =\n\t\tcontainer_of(work, struct tc35815_local, restart_work);\n\tstruct net_device *dev = lp->dev;\n\n\ttc35815_restart(dev);\n}\n\nstatic void tc35815_schedule_restart(struct net_device *dev)\n{\n\tstruct tc35815_local *lp = netdev_priv(dev);\n\tstruct tc35815_regs __iomem *tr =\n\t\t(struct tc35815_regs __iomem *)dev->base_addr;\n\tunsigned long flags;\n\n\t \n\tspin_lock_irqsave(&lp->lock, flags);\n\ttc_writel(0, &tr->Int_En);\n\ttc_writel(tc_readl(&tr->DMA_Ctl) | DMA_IntMask, &tr->DMA_Ctl);\n\tschedule_work(&lp->restart_work);\n\tspin_unlock_irqrestore(&lp->lock, flags);\n}\n\nstatic void tc35815_tx_timeout(struct net_device *dev, unsigned int txqueue)\n{\n\tstruct tc35815_regs __iomem *tr =\n\t\t(struct tc35815_regs __iomem *)dev->base_addr;\n\n\tprintk(KERN_WARNING \"%s: transmit timed out, status %#x\\n\",\n\t       dev->name, tc_readl(&tr->Tx_Stat));\n\n\t \n\ttc35815_schedule_restart(dev);\n\tdev->stats.tx_errors++;\n}\n\n \nstatic int\ntc35815_open(struct net_device *dev)\n{\n\tstruct tc35815_local *lp = netdev_priv(dev);\n\n\t \n\tif (request_irq(dev->irq, tc35815_interrupt, IRQF_SHARED,\n\t\t\tdev->name, dev))\n\t\treturn -EAGAIN;\n\n\ttc35815_chip_reset(dev);\n\n\tif (tc35815_init_queues(dev) != 0) {\n\t\tfree_irq(dev->irq, dev);\n\t\treturn -EAGAIN;\n\t}\n\n\tnapi_enable(&lp->napi);\n\n\t \n\tspin_lock_irq(&lp->lock);\n\ttc35815_chip_init(dev);\n\tspin_unlock_irq(&lp->lock);\n\n\tnetif_carrier_off(dev);\n\t \n\tphy_start(dev->phydev);\n\n\t \n\tnetif_start_queue(dev);\n\n\treturn 0;\n}\n\n \nstatic netdev_tx_t\ntc35815_send_packet(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct tc35815_local *lp = netdev_priv(dev);\n\tstruct TxFD *txfd;\n\tunsigned long flags;\n\n\t \n\n\t \n\tspin_lock_irqsave(&lp->lock, flags);\n\n\t \n\tif ((lp->tfd_start + TX_FD_NUM - lp->tfd_end) % TX_FD_NUM >\n\t    TX_FD_NUM / 2)\n\t\ttc35815_txdone(dev);\n\n\tif (netif_msg_pktdata(lp))\n\t\tprint_eth(skb->data);\n#ifdef DEBUG\n\tif (lp->tx_skbs[lp->tfd_start].skb) {\n\t\tprintk(\"%s: tx_skbs conflict.\\n\", dev->name);\n\t\tpanic_queues(dev);\n\t}\n#else\n\tBUG_ON(lp->tx_skbs[lp->tfd_start].skb);\n#endif\n\tlp->tx_skbs[lp->tfd_start].skb = skb;\n\tlp->tx_skbs[lp->tfd_start].skb_dma = dma_map_single(&lp->pci_dev->dev,\n\t\t\t\t\t\t\t    skb->data,\n\t\t\t\t\t\t\t    skb->len,\n\t\t\t\t\t\t\t    DMA_TO_DEVICE);\n\n\t \n\ttxfd = &lp->tfd_base[lp->tfd_start];\n\ttxfd->bd.BuffData = cpu_to_le32(lp->tx_skbs[lp->tfd_start].skb_dma);\n\ttxfd->bd.BDCtl = cpu_to_le32(skb->len);\n\ttxfd->fd.FDSystem = cpu_to_le32(lp->tfd_start);\n\ttxfd->fd.FDCtl = cpu_to_le32(FD_CownsFD | (1 << FD_BDCnt_SHIFT));\n\n\tif (lp->tfd_start == lp->tfd_end) {\n\t\tstruct tc35815_regs __iomem *tr =\n\t\t\t(struct tc35815_regs __iomem *)dev->base_addr;\n\t\t \n\t\ttxfd->fd.FDNext |= cpu_to_le32(FD_Next_EOL);\n\t\ttxfd->fd.FDCtl |= cpu_to_le32(FD_FrmOpt_IntTx);\n\t\tif (netif_msg_tx_queued(lp)) {\n\t\t\tprintk(\"%s: starting TxFD.\\n\", dev->name);\n\t\t\tdump_txfd(txfd);\n\t\t}\n\t\ttc_writel(fd_virt_to_bus(lp, txfd), &tr->TxFrmPtr);\n\t} else {\n\t\ttxfd->fd.FDNext &= cpu_to_le32(~FD_Next_EOL);\n\t\tif (netif_msg_tx_queued(lp)) {\n\t\t\tprintk(\"%s: queueing TxFD.\\n\", dev->name);\n\t\t\tdump_txfd(txfd);\n\t\t}\n\t}\n\tlp->tfd_start = (lp->tfd_start + 1) % TX_FD_NUM;\n\n\t \n\tif (tc35815_tx_full(dev)) {\n\t\tif (netif_msg_tx_queued(lp))\n\t\t\tprintk(KERN_WARNING \"%s: TxFD Exhausted.\\n\", dev->name);\n\t\tnetif_stop_queue(dev);\n\t}\n\n\t \n\n\tspin_unlock_irqrestore(&lp->lock, flags);\n\treturn NETDEV_TX_OK;\n}\n\n#define FATAL_ERROR_INT \\\n\t(Int_IntPCI | Int_DmParErr | Int_IntNRAbt)\nstatic void tc35815_fatal_error_interrupt(struct net_device *dev, u32 status)\n{\n\tstatic int count;\n\tprintk(KERN_WARNING \"%s: Fatal Error Interrupt (%#x):\",\n\t       dev->name, status);\n\tif (status & Int_IntPCI)\n\t\tprintk(\" IntPCI\");\n\tif (status & Int_DmParErr)\n\t\tprintk(\" DmParErr\");\n\tif (status & Int_IntNRAbt)\n\t\tprintk(\" IntNRAbt\");\n\tprintk(\"\\n\");\n\tif (count++ > 100)\n\t\tpanic(\"%s: Too many fatal errors.\", dev->name);\n\tprintk(KERN_WARNING \"%s: Resetting ...\\n\", dev->name);\n\t \n\ttc35815_schedule_restart(dev);\n}\n\nstatic int tc35815_do_interrupt(struct net_device *dev, u32 status, int limit)\n{\n\tstruct tc35815_local *lp = netdev_priv(dev);\n\tint ret = -1;\n\n\t \n\tif (status & FATAL_ERROR_INT) {\n\t\ttc35815_fatal_error_interrupt(dev, status);\n\t\treturn 0;\n\t}\n\t \n\tif (status & Int_IntFDAEx) {\n\t\tif (netif_msg_rx_err(lp))\n\t\t\tdev_warn(&dev->dev,\n\t\t\t\t \"Free Descriptor Area Exhausted (%#x).\\n\",\n\t\t\t\t status);\n\t\tdev->stats.rx_dropped++;\n\t\tret = 0;\n\t}\n\tif (status & Int_IntBLEx) {\n\t\tif (netif_msg_rx_err(lp))\n\t\t\tdev_warn(&dev->dev,\n\t\t\t\t \"Buffer List Exhausted (%#x).\\n\",\n\t\t\t\t status);\n\t\tdev->stats.rx_dropped++;\n\t\tret = 0;\n\t}\n\tif (status & Int_IntExBD) {\n\t\tif (netif_msg_rx_err(lp))\n\t\t\tdev_warn(&dev->dev,\n\t\t\t\t \"Excessive Buffer Descriptors (%#x).\\n\",\n\t\t\t\t status);\n\t\tdev->stats.rx_length_errors++;\n\t\tret = 0;\n\t}\n\n\t \n\tif (status & Int_IntMacRx) {\n\t\t \n\t\tret = tc35815_rx(dev, limit);\n\t\tlp->lstats.rx_ints++;\n\t}\n\tif (status & Int_IntMacTx) {\n\t\t \n\t\tlp->lstats.tx_ints++;\n\t\tspin_lock_irq(&lp->lock);\n\t\ttc35815_txdone(dev);\n\t\tspin_unlock_irq(&lp->lock);\n\t\tif (ret < 0)\n\t\t\tret = 0;\n\t}\n\treturn ret;\n}\n\n \nstatic irqreturn_t tc35815_interrupt(int irq, void *dev_id)\n{\n\tstruct net_device *dev = dev_id;\n\tstruct tc35815_local *lp = netdev_priv(dev);\n\tstruct tc35815_regs __iomem *tr =\n\t\t(struct tc35815_regs __iomem *)dev->base_addr;\n\tu32 dmactl = tc_readl(&tr->DMA_Ctl);\n\n\tif (!(dmactl & DMA_IntMask)) {\n\t\t \n\t\ttc_writel(dmactl | DMA_IntMask, &tr->DMA_Ctl);\n\t\tif (napi_schedule_prep(&lp->napi))\n\t\t\t__napi_schedule(&lp->napi);\n\t\telse {\n\t\t\tprintk(KERN_ERR \"%s: interrupt taken in poll\\n\",\n\t\t\t       dev->name);\n\t\t\tBUG();\n\t\t}\n\t\t(void)tc_readl(&tr->Int_Src);\t \n\t\treturn IRQ_HANDLED;\n\t}\n\treturn IRQ_NONE;\n}\n\n#ifdef CONFIG_NET_POLL_CONTROLLER\nstatic void tc35815_poll_controller(struct net_device *dev)\n{\n\tdisable_irq(dev->irq);\n\ttc35815_interrupt(dev->irq, dev);\n\tenable_irq(dev->irq);\n}\n#endif\n\n \nstatic int\ntc35815_rx(struct net_device *dev, int limit)\n{\n\tstruct tc35815_local *lp = netdev_priv(dev);\n\tunsigned int fdctl;\n\tint i;\n\tint received = 0;\n\n\twhile (!((fdctl = le32_to_cpu(lp->rfd_cur->fd.FDCtl)) & FD_CownsFD)) {\n\t\tint status = le32_to_cpu(lp->rfd_cur->fd.FDStat);\n\t\tint pkt_len = fdctl & FD_FDLength_MASK;\n\t\tint bd_count = (fdctl & FD_BDCnt_MASK) >> FD_BDCnt_SHIFT;\n#ifdef DEBUG\n\t\tstruct RxFD *next_rfd;\n#endif\n#if (RX_CTL_CMD & Rx_StripCRC) == 0\n\t\tpkt_len -= ETH_FCS_LEN;\n#endif\n\n\t\tif (netif_msg_rx_status(lp))\n\t\t\tdump_rxfd(lp->rfd_cur);\n\t\tif (status & Rx_Good) {\n\t\t\tstruct sk_buff *skb;\n\t\t\tunsigned char *data;\n\t\t\tint cur_bd;\n\n\t\t\tif (--limit < 0)\n\t\t\t\tbreak;\n\t\t\tBUG_ON(bd_count > 1);\n\t\t\tcur_bd = (le32_to_cpu(lp->rfd_cur->bd[0].BDCtl)\n\t\t\t\t  & BD_RxBDID_MASK) >> BD_RxBDID_SHIFT;\n#ifdef DEBUG\n\t\t\tif (cur_bd >= RX_BUF_NUM) {\n\t\t\t\tprintk(\"%s: invalid BDID.\\n\", dev->name);\n\t\t\t\tpanic_queues(dev);\n\t\t\t}\n\t\t\tBUG_ON(lp->rx_skbs[cur_bd].skb_dma !=\n\t\t\t       (le32_to_cpu(lp->rfd_cur->bd[0].BuffData) & ~3));\n\t\t\tif (!lp->rx_skbs[cur_bd].skb) {\n\t\t\t\tprintk(\"%s: NULL skb.\\n\", dev->name);\n\t\t\t\tpanic_queues(dev);\n\t\t\t}\n#else\n\t\t\tBUG_ON(cur_bd >= RX_BUF_NUM);\n#endif\n\t\t\tskb = lp->rx_skbs[cur_bd].skb;\n\t\t\tprefetch(skb->data);\n\t\t\tlp->rx_skbs[cur_bd].skb = NULL;\n\t\t\tdma_unmap_single(&lp->pci_dev->dev,\n\t\t\t\t\t lp->rx_skbs[cur_bd].skb_dma,\n\t\t\t\t\t RX_BUF_SIZE, DMA_FROM_DEVICE);\n\t\t\tif (!HAVE_DMA_RXALIGN(lp) && NET_IP_ALIGN != 0)\n\t\t\t\tmemmove(skb->data, skb->data - NET_IP_ALIGN,\n\t\t\t\t\tpkt_len);\n\t\t\tdata = skb_put(skb, pkt_len);\n\t\t\tif (netif_msg_pktdata(lp))\n\t\t\t\tprint_eth(data);\n\t\t\tskb->protocol = eth_type_trans(skb, dev);\n\t\t\tnetif_receive_skb(skb);\n\t\t\treceived++;\n\t\t\tdev->stats.rx_packets++;\n\t\t\tdev->stats.rx_bytes += pkt_len;\n\t\t} else {\n\t\t\tdev->stats.rx_errors++;\n\t\t\tif (netif_msg_rx_err(lp))\n\t\t\t\tdev_info(&dev->dev, \"Rx error (status %x)\\n\",\n\t\t\t\t\t status & Rx_Stat_Mask);\n\t\t\t \n\t\t\tif ((status & Rx_LongErr) && (status & Rx_CRCErr)) {\n\t\t\t\tstatus &= ~(Rx_LongErr|Rx_CRCErr);\n\t\t\t\tstatus |= Rx_Over;\n\t\t\t}\n\t\t\tif (status & Rx_LongErr)\n\t\t\t\tdev->stats.rx_length_errors++;\n\t\t\tif (status & Rx_Over)\n\t\t\t\tdev->stats.rx_fifo_errors++;\n\t\t\tif (status & Rx_CRCErr)\n\t\t\t\tdev->stats.rx_crc_errors++;\n\t\t\tif (status & Rx_Align)\n\t\t\t\tdev->stats.rx_frame_errors++;\n\t\t}\n\n\t\tif (bd_count > 0) {\n\t\t\t \n\t\t\tint bdctl = le32_to_cpu(lp->rfd_cur->bd[bd_count - 1].BDCtl);\n\t\t\tunsigned char id =\n\t\t\t\t(bdctl & BD_RxBDID_MASK) >> BD_RxBDID_SHIFT;\n#ifdef DEBUG\n\t\t\tif (id >= RX_BUF_NUM) {\n\t\t\t\tprintk(\"%s: invalid BDID.\\n\", dev->name);\n\t\t\t\tpanic_queues(dev);\n\t\t\t}\n#else\n\t\t\tBUG_ON(id >= RX_BUF_NUM);\n#endif\n\t\t\t \n\t\t\tlp->fbl_count--;\n\t\t\twhile (lp->fbl_count < RX_BUF_NUM)\n\t\t\t{\n\t\t\t\tunsigned char curid =\n\t\t\t\t\t(id + 1 + lp->fbl_count) % RX_BUF_NUM;\n\t\t\t\tstruct BDesc *bd = &lp->fbl_ptr->bd[curid];\n#ifdef DEBUG\n\t\t\t\tbdctl = le32_to_cpu(bd->BDCtl);\n\t\t\t\tif (bdctl & BD_CownsBD) {\n\t\t\t\t\tprintk(\"%s: Freeing invalid BD.\\n\",\n\t\t\t\t\t       dev->name);\n\t\t\t\t\tpanic_queues(dev);\n\t\t\t\t}\n#endif\n\t\t\t\t \n\t\t\t\tif (!lp->rx_skbs[curid].skb) {\n\t\t\t\t\tlp->rx_skbs[curid].skb =\n\t\t\t\t\t\talloc_rxbuf_skb(dev,\n\t\t\t\t\t\t\t\tlp->pci_dev,\n\t\t\t\t\t\t\t\t&lp->rx_skbs[curid].skb_dma);\n\t\t\t\t\tif (!lp->rx_skbs[curid].skb)\n\t\t\t\t\t\tbreak;  \n\t\t\t\t\tbd->BuffData = cpu_to_le32(lp->rx_skbs[curid].skb_dma);\n\t\t\t\t}\n\t\t\t\t \n\t\t\t\tbd->BDCtl = cpu_to_le32(BD_CownsBD |\n\t\t\t\t\t\t\t(curid << BD_RxBDID_SHIFT) |\n\t\t\t\t\t\t\tRX_BUF_SIZE);\n\t\t\t\tlp->fbl_count++;\n\t\t\t}\n\t\t}\n\n\t\t \n#ifdef DEBUG\n\t\tnext_rfd = fd_bus_to_virt(lp,\n\t\t\t\t\t  le32_to_cpu(lp->rfd_cur->fd.FDNext));\n\t\tif (next_rfd < lp->rfd_base || next_rfd > lp->rfd_limit) {\n\t\t\tprintk(\"%s: RxFD FDNext invalid.\\n\", dev->name);\n\t\t\tpanic_queues(dev);\n\t\t}\n#endif\n\t\tfor (i = 0; i < (bd_count + 1) / 2 + 1; i++) {\n\t\t\t \n#ifdef DEBUG\n\t\t\tlp->rfd_cur->fd.FDNext = cpu_to_le32(0xdeaddead);\n#else\n\t\t\tlp->rfd_cur->fd.FDNext = cpu_to_le32(FD_Next_EOL);\n#endif\n\t\t\tlp->rfd_cur->fd.FDCtl = cpu_to_le32(FD_CownsFD);\n\t\t\tlp->rfd_cur++;\n\t\t}\n\t\tif (lp->rfd_cur > lp->rfd_limit)\n\t\t\tlp->rfd_cur = lp->rfd_base;\n#ifdef DEBUG\n\t\tif (lp->rfd_cur != next_rfd)\n\t\t\tprintk(\"rfd_cur = %p, next_rfd %p\\n\",\n\t\t\t       lp->rfd_cur, next_rfd);\n#endif\n\t}\n\n\treturn received;\n}\n\nstatic int tc35815_poll(struct napi_struct *napi, int budget)\n{\n\tstruct tc35815_local *lp = container_of(napi, struct tc35815_local, napi);\n\tstruct net_device *dev = lp->dev;\n\tstruct tc35815_regs __iomem *tr =\n\t\t(struct tc35815_regs __iomem *)dev->base_addr;\n\tint received = 0, handled;\n\tu32 status;\n\n\tif (budget <= 0)\n\t\treturn received;\n\n\tspin_lock(&lp->rx_lock);\n\tstatus = tc_readl(&tr->Int_Src);\n\tdo {\n\t\t \n\t\ttc_writel(status & ~(Int_BLEx | Int_FDAEx),\n\t\t\t  &tr->Int_Src);\t \n\n\t\thandled = tc35815_do_interrupt(dev, status, budget - received);\n\t\tif (status & (Int_BLEx | Int_FDAEx))\n\t\t\ttc_writel(status & (Int_BLEx | Int_FDAEx),\n\t\t\t\t  &tr->Int_Src);\n\t\tif (handled >= 0) {\n\t\t\treceived += handled;\n\t\t\tif (received >= budget)\n\t\t\t\tbreak;\n\t\t}\n\t\tstatus = tc_readl(&tr->Int_Src);\n\t} while (status);\n\tspin_unlock(&lp->rx_lock);\n\n\tif (received < budget) {\n\t\tnapi_complete_done(napi, received);\n\t\t \n\t\ttc_writel(tc_readl(&tr->DMA_Ctl) & ~DMA_IntMask, &tr->DMA_Ctl);\n\t}\n\treturn received;\n}\n\n#define TX_STA_ERR\t(Tx_ExColl|Tx_Under|Tx_Defer|Tx_NCarr|Tx_LateColl|Tx_TxPar|Tx_SQErr)\n\nstatic void\ntc35815_check_tx_stat(struct net_device *dev, int status)\n{\n\tstruct tc35815_local *lp = netdev_priv(dev);\n\tconst char *msg = NULL;\n\n\t \n\tif (status & Tx_ExColl)\n\t\tdev->stats.collisions += 16;\n\tif (status & Tx_TxColl_MASK)\n\t\tdev->stats.collisions += status & Tx_TxColl_MASK;\n\n\t \n\tif (lp->chiptype == TC35815_TX4939)\n\t\tstatus &= ~Tx_NCarr;\n\t \n\tif (!lp->link || lp->duplex == DUPLEX_FULL)\n\t\tstatus &= ~Tx_NCarr;\n\n\tif (!(status & TX_STA_ERR)) {\n\t\t \n\t\tdev->stats.tx_packets++;\n\t\treturn;\n\t}\n\n\tdev->stats.tx_errors++;\n\tif (status & Tx_ExColl) {\n\t\tdev->stats.tx_aborted_errors++;\n\t\tmsg = \"Excessive Collision.\";\n\t}\n\tif (status & Tx_Under) {\n\t\tdev->stats.tx_fifo_errors++;\n\t\tmsg = \"Tx FIFO Underrun.\";\n\t\tif (lp->lstats.tx_underrun < TX_THRESHOLD_KEEP_LIMIT) {\n\t\t\tlp->lstats.tx_underrun++;\n\t\t\tif (lp->lstats.tx_underrun >= TX_THRESHOLD_KEEP_LIMIT) {\n\t\t\t\tstruct tc35815_regs __iomem *tr =\n\t\t\t\t\t(struct tc35815_regs __iomem *)dev->base_addr;\n\t\t\t\ttc_writel(TX_THRESHOLD_MAX, &tr->TxThrsh);\n\t\t\t\tmsg = \"Tx FIFO Underrun.Change Tx threshold to max.\";\n\t\t\t}\n\t\t}\n\t}\n\tif (status & Tx_Defer) {\n\t\tdev->stats.tx_fifo_errors++;\n\t\tmsg = \"Excessive Deferral.\";\n\t}\n\tif (status & Tx_NCarr) {\n\t\tdev->stats.tx_carrier_errors++;\n\t\tmsg = \"Lost Carrier Sense.\";\n\t}\n\tif (status & Tx_LateColl) {\n\t\tdev->stats.tx_aborted_errors++;\n\t\tmsg = \"Late Collision.\";\n\t}\n\tif (status & Tx_TxPar) {\n\t\tdev->stats.tx_fifo_errors++;\n\t\tmsg = \"Transmit Parity Error.\";\n\t}\n\tif (status & Tx_SQErr) {\n\t\tdev->stats.tx_heartbeat_errors++;\n\t\tmsg = \"Signal Quality Error.\";\n\t}\n\tif (msg && netif_msg_tx_err(lp))\n\t\tprintk(KERN_WARNING \"%s: %s (%#x)\\n\", dev->name, msg, status);\n}\n\n \nstatic void\ntc35815_txdone(struct net_device *dev)\n{\n\tstruct tc35815_local *lp = netdev_priv(dev);\n\tstruct TxFD *txfd;\n\tunsigned int fdctl;\n\n\ttxfd = &lp->tfd_base[lp->tfd_end];\n\twhile (lp->tfd_start != lp->tfd_end &&\n\t       !((fdctl = le32_to_cpu(txfd->fd.FDCtl)) & FD_CownsFD)) {\n\t\tint status = le32_to_cpu(txfd->fd.FDStat);\n\t\tstruct sk_buff *skb;\n\t\tunsigned long fdnext = le32_to_cpu(txfd->fd.FDNext);\n\t\tu32 fdsystem = le32_to_cpu(txfd->fd.FDSystem);\n\n\t\tif (netif_msg_tx_done(lp)) {\n\t\t\tprintk(\"%s: complete TxFD.\\n\", dev->name);\n\t\t\tdump_txfd(txfd);\n\t\t}\n\t\ttc35815_check_tx_stat(dev, status);\n\n\t\tskb = fdsystem != 0xffffffff ?\n\t\t\tlp->tx_skbs[fdsystem].skb : NULL;\n#ifdef DEBUG\n\t\tif (lp->tx_skbs[lp->tfd_end].skb != skb) {\n\t\t\tprintk(\"%s: tx_skbs mismatch.\\n\", dev->name);\n\t\t\tpanic_queues(dev);\n\t\t}\n#else\n\t\tBUG_ON(lp->tx_skbs[lp->tfd_end].skb != skb);\n#endif\n\t\tif (skb) {\n\t\t\tdev->stats.tx_bytes += skb->len;\n\t\t\tdma_unmap_single(&lp->pci_dev->dev,\n\t\t\t\t\t lp->tx_skbs[lp->tfd_end].skb_dma,\n\t\t\t\t\t skb->len, DMA_TO_DEVICE);\n\t\t\tlp->tx_skbs[lp->tfd_end].skb = NULL;\n\t\t\tlp->tx_skbs[lp->tfd_end].skb_dma = 0;\n\t\t\tdev_kfree_skb_any(skb);\n\t\t}\n\t\ttxfd->fd.FDSystem = cpu_to_le32(0xffffffff);\n\n\t\tlp->tfd_end = (lp->tfd_end + 1) % TX_FD_NUM;\n\t\ttxfd = &lp->tfd_base[lp->tfd_end];\n#ifdef DEBUG\n\t\tif ((fdnext & ~FD_Next_EOL) != fd_virt_to_bus(lp, txfd)) {\n\t\t\tprintk(\"%s: TxFD FDNext invalid.\\n\", dev->name);\n\t\t\tpanic_queues(dev);\n\t\t}\n#endif\n\t\tif (fdnext & FD_Next_EOL) {\n\t\t\t \n\t\t\tif (lp->tfd_end != lp->tfd_start) {\n\t\t\t\tstruct tc35815_regs __iomem *tr =\n\t\t\t\t\t(struct tc35815_regs __iomem *)dev->base_addr;\n\t\t\t\tint head = (lp->tfd_start + TX_FD_NUM - 1) % TX_FD_NUM;\n\t\t\t\tstruct TxFD *txhead = &lp->tfd_base[head];\n\t\t\t\tint qlen = (lp->tfd_start + TX_FD_NUM\n\t\t\t\t\t    - lp->tfd_end) % TX_FD_NUM;\n\n#ifdef DEBUG\n\t\t\t\tif (!(le32_to_cpu(txfd->fd.FDCtl) & FD_CownsFD)) {\n\t\t\t\t\tprintk(\"%s: TxFD FDCtl invalid.\\n\", dev->name);\n\t\t\t\t\tpanic_queues(dev);\n\t\t\t\t}\n#endif\n\t\t\t\t \n\t\t\t\tif (lp->lstats.max_tx_qlen < qlen)\n\t\t\t\t\tlp->lstats.max_tx_qlen = qlen;\n\n\n\t\t\t\t \n\t\t\t\ttxhead->fd.FDNext |= cpu_to_le32(FD_Next_EOL);\n\t\t\t\ttxhead->fd.FDCtl |= cpu_to_le32(FD_FrmOpt_IntTx);\n\t\t\t\tif (netif_msg_tx_queued(lp)) {\n\t\t\t\t\tprintk(\"%s: start TxFD on queue.\\n\",\n\t\t\t\t\t       dev->name);\n\t\t\t\t\tdump_txfd(txfd);\n\t\t\t\t}\n\t\t\t\ttc_writel(fd_virt_to_bus(lp, txfd), &tr->TxFrmPtr);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (netif_queue_stopped(dev) && !tc35815_tx_full(dev))\n\t\tnetif_wake_queue(dev);\n}\n\n \nstatic int\ntc35815_close(struct net_device *dev)\n{\n\tstruct tc35815_local *lp = netdev_priv(dev);\n\n\tnetif_stop_queue(dev);\n\tnapi_disable(&lp->napi);\n\tif (dev->phydev)\n\t\tphy_stop(dev->phydev);\n\tcancel_work_sync(&lp->restart_work);\n\n\t \n\ttc35815_chip_reset(dev);\n\tfree_irq(dev->irq, dev);\n\n\ttc35815_free_queues(dev);\n\n\treturn 0;\n\n}\n\n \nstatic struct net_device_stats *tc35815_get_stats(struct net_device *dev)\n{\n\tstruct tc35815_regs __iomem *tr =\n\t\t(struct tc35815_regs __iomem *)dev->base_addr;\n\tif (netif_running(dev))\n\t\t \n\t\tdev->stats.rx_missed_errors += tc_readl(&tr->Miss_Cnt);\n\n\treturn &dev->stats;\n}\n\nstatic void tc35815_set_cam_entry(struct net_device *dev, int index,\n\t\t\t\t  const unsigned char *addr)\n{\n\tstruct tc35815_local *lp = netdev_priv(dev);\n\tstruct tc35815_regs __iomem *tr =\n\t\t(struct tc35815_regs __iomem *)dev->base_addr;\n\tint cam_index = index * 6;\n\tu32 cam_data;\n\tu32 saved_addr;\n\n\tsaved_addr = tc_readl(&tr->CAM_Adr);\n\n\tif (netif_msg_hw(lp))\n\t\tprintk(KERN_DEBUG \"%s: CAM %d: %pM\\n\",\n\t\t\tdev->name, index, addr);\n\tif (index & 1) {\n\t\t \n\t\ttc_writel(cam_index - 2, &tr->CAM_Adr);\n\t\tcam_data = tc_readl(&tr->CAM_Data) & 0xffff0000;\n\t\tcam_data |= addr[0] << 8 | addr[1];\n\t\ttc_writel(cam_data, &tr->CAM_Data);\n\t\t \n\t\ttc_writel(cam_index + 2, &tr->CAM_Adr);\n\t\tcam_data = (addr[2] << 24) | (addr[3] << 16) | (addr[4] << 8) | addr[5];\n\t\ttc_writel(cam_data, &tr->CAM_Data);\n\t} else {\n\t\t \n\t\ttc_writel(cam_index, &tr->CAM_Adr);\n\t\tcam_data = (addr[0] << 24) | (addr[1] << 16) | (addr[2] << 8) | addr[3];\n\t\ttc_writel(cam_data, &tr->CAM_Data);\n\t\t \n\t\ttc_writel(cam_index + 4, &tr->CAM_Adr);\n\t\tcam_data = tc_readl(&tr->CAM_Data) & 0x0000ffff;\n\t\tcam_data |= addr[4] << 24 | (addr[5] << 16);\n\t\ttc_writel(cam_data, &tr->CAM_Data);\n\t}\n\n\ttc_writel(saved_addr, &tr->CAM_Adr);\n}\n\n\n \nstatic void\ntc35815_set_multicast_list(struct net_device *dev)\n{\n\tstruct tc35815_regs __iomem *tr =\n\t\t(struct tc35815_regs __iomem *)dev->base_addr;\n\n\tif (dev->flags & IFF_PROMISC) {\n\t\t \n\t\tstruct tc35815_local *lp = netdev_priv(dev);\n\n\t\tif (!lp->link)\n\t\t\treturn;\n\t\t \n\t\ttc_writel(CAM_CompEn | CAM_BroadAcc | CAM_GroupAcc | CAM_StationAcc, &tr->CAM_Ctl);\n\t} else if ((dev->flags & IFF_ALLMULTI) ||\n\t\t  netdev_mc_count(dev) > CAM_ENTRY_MAX - 3) {\n\t\t \n\t\t \n\t\ttc_writel(CAM_CompEn | CAM_BroadAcc | CAM_GroupAcc, &tr->CAM_Ctl);\n\t} else if (!netdev_mc_empty(dev)) {\n\t\tstruct netdev_hw_addr *ha;\n\t\tint i;\n\t\tint ena_bits = CAM_Ena_Bit(CAM_ENTRY_SOURCE);\n\n\t\ttc_writel(0, &tr->CAM_Ctl);\n\t\t \n\t\ti = 0;\n\t\tnetdev_for_each_mc_addr(ha, dev) {\n\t\t\t \n\t\t\ttc35815_set_cam_entry(dev, i + 2, ha->addr);\n\t\t\tena_bits |= CAM_Ena_Bit(i + 2);\n\t\t\ti++;\n\t\t}\n\t\ttc_writel(ena_bits, &tr->CAM_Ena);\n\t\ttc_writel(CAM_CompEn | CAM_BroadAcc, &tr->CAM_Ctl);\n\t} else {\n\t\ttc_writel(CAM_Ena_Bit(CAM_ENTRY_SOURCE), &tr->CAM_Ena);\n\t\ttc_writel(CAM_CompEn | CAM_BroadAcc, &tr->CAM_Ctl);\n\t}\n}\n\nstatic void tc35815_get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *info)\n{\n\tstruct tc35815_local *lp = netdev_priv(dev);\n\n\tstrscpy(info->driver, MODNAME, sizeof(info->driver));\n\tstrscpy(info->version, DRV_VERSION, sizeof(info->version));\n\tstrscpy(info->bus_info, pci_name(lp->pci_dev), sizeof(info->bus_info));\n}\n\nstatic u32 tc35815_get_msglevel(struct net_device *dev)\n{\n\tstruct tc35815_local *lp = netdev_priv(dev);\n\treturn lp->msg_enable;\n}\n\nstatic void tc35815_set_msglevel(struct net_device *dev, u32 datum)\n{\n\tstruct tc35815_local *lp = netdev_priv(dev);\n\tlp->msg_enable = datum;\n}\n\nstatic int tc35815_get_sset_count(struct net_device *dev, int sset)\n{\n\tstruct tc35815_local *lp = netdev_priv(dev);\n\n\tswitch (sset) {\n\tcase ETH_SS_STATS:\n\t\treturn sizeof(lp->lstats) / sizeof(int);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic void tc35815_get_ethtool_stats(struct net_device *dev, struct ethtool_stats *stats, u64 *data)\n{\n\tstruct tc35815_local *lp = netdev_priv(dev);\n\tdata[0] = lp->lstats.max_tx_qlen;\n\tdata[1] = lp->lstats.tx_ints;\n\tdata[2] = lp->lstats.rx_ints;\n\tdata[3] = lp->lstats.tx_underrun;\n}\n\nstatic struct {\n\tconst char str[ETH_GSTRING_LEN];\n} ethtool_stats_keys[] = {\n\t{ \"max_tx_qlen\" },\n\t{ \"tx_ints\" },\n\t{ \"rx_ints\" },\n\t{ \"tx_underrun\" },\n};\n\nstatic void tc35815_get_strings(struct net_device *dev, u32 stringset, u8 *data)\n{\n\tmemcpy(data, ethtool_stats_keys, sizeof(ethtool_stats_keys));\n}\n\nstatic const struct ethtool_ops tc35815_ethtool_ops = {\n\t.get_drvinfo\t\t= tc35815_get_drvinfo,\n\t.get_link\t\t= ethtool_op_get_link,\n\t.get_msglevel\t\t= tc35815_get_msglevel,\n\t.set_msglevel\t\t= tc35815_set_msglevel,\n\t.get_strings\t\t= tc35815_get_strings,\n\t.get_sset_count\t\t= tc35815_get_sset_count,\n\t.get_ethtool_stats\t= tc35815_get_ethtool_stats,\n\t.get_link_ksettings = phy_ethtool_get_link_ksettings,\n\t.set_link_ksettings = phy_ethtool_set_link_ksettings,\n};\n\nstatic void tc35815_chip_reset(struct net_device *dev)\n{\n\tstruct tc35815_regs __iomem *tr =\n\t\t(struct tc35815_regs __iomem *)dev->base_addr;\n\tint i;\n\t \n\ttc_writel(MAC_Reset, &tr->MAC_Ctl);\n\tudelay(4);  \n\ti = 0;\n\twhile (tc_readl(&tr->MAC_Ctl) & MAC_Reset) {\n\t\tif (i++ > 100) {\n\t\t\tprintk(KERN_ERR \"%s: MAC reset failed.\\n\", dev->name);\n\t\t\tbreak;\n\t\t}\n\t\tmdelay(1);\n\t}\n\ttc_writel(0, &tr->MAC_Ctl);\n\n\t \n\ttc_writel(0, &tr->DMA_Ctl);\n\ttc_writel(0, &tr->TxThrsh);\n\ttc_writel(0, &tr->TxPollCtr);\n\ttc_writel(0, &tr->RxFragSize);\n\ttc_writel(0, &tr->Int_En);\n\ttc_writel(0, &tr->FDA_Bas);\n\ttc_writel(0, &tr->FDA_Lim);\n\ttc_writel(0xffffffff, &tr->Int_Src);\t \n\ttc_writel(0, &tr->CAM_Ctl);\n\ttc_writel(0, &tr->Tx_Ctl);\n\ttc_writel(0, &tr->Rx_Ctl);\n\ttc_writel(0, &tr->CAM_Ena);\n\t(void)tc_readl(&tr->Miss_Cnt);\t \n\n\t \n\ttc_writel(DMA_TestMode, &tr->DMA_Ctl);\n\tfor (i = 0; i < 0x1000; i += 4) {\n\t\ttc_writel(i, &tr->CAM_Adr);\n\t\ttc_writel(0, &tr->CAM_Data);\n\t}\n\ttc_writel(0, &tr->DMA_Ctl);\n}\n\nstatic void tc35815_chip_init(struct net_device *dev)\n{\n\tstruct tc35815_local *lp = netdev_priv(dev);\n\tstruct tc35815_regs __iomem *tr =\n\t\t(struct tc35815_regs __iomem *)dev->base_addr;\n\tunsigned long txctl = TX_CTL_CMD;\n\n\t \n\ttc35815_set_cam_entry(dev, CAM_ENTRY_SOURCE, dev->dev_addr);\n\n\t \n\ttc_writel(CAM_Ena_Bit(CAM_ENTRY_SOURCE), &tr->CAM_Ena);\n\ttc_writel(CAM_CompEn | CAM_BroadAcc, &tr->CAM_Ctl);\n\n\t \n\tif (HAVE_DMA_RXALIGN(lp))\n\t\ttc_writel(DMA_BURST_SIZE | DMA_RxAlign_2, &tr->DMA_Ctl);\n\telse\n\t\ttc_writel(DMA_BURST_SIZE, &tr->DMA_Ctl);\n\ttc_writel(0, &tr->TxPollCtr);\t \n\ttc_writel(TX_THRESHOLD, &tr->TxThrsh);\n\ttc_writel(INT_EN_CMD, &tr->Int_En);\n\n\t \n\ttc_writel(fd_virt_to_bus(lp, lp->rfd_base), &tr->FDA_Bas);\n\ttc_writel((unsigned long)lp->rfd_limit - (unsigned long)lp->rfd_base,\n\t\t  &tr->FDA_Lim);\n\t \n\ttc_writel(fd_virt_to_bus(lp, lp->fbl_ptr), &tr->BLFrmPtr);\t \n\ttc_writel(RX_CTL_CMD, &tr->Rx_Ctl);\t \n\n\t \n\t \n\tif (lp->chiptype == TC35815_TX4939)\n\t\ttxctl &= ~Tx_EnLCarr;\n\t \n\tif (!dev->phydev || !lp->link || lp->duplex == DUPLEX_FULL)\n\t\ttxctl &= ~Tx_EnLCarr;\n\ttc_writel(txctl, &tr->Tx_Ctl);\n}\n\n#ifdef CONFIG_PM\nstatic int tc35815_suspend(struct pci_dev *pdev, pm_message_t state)\n{\n\tstruct net_device *dev = pci_get_drvdata(pdev);\n\tstruct tc35815_local *lp = netdev_priv(dev);\n\tunsigned long flags;\n\n\tpci_save_state(pdev);\n\tif (!netif_running(dev))\n\t\treturn 0;\n\tnetif_device_detach(dev);\n\tif (dev->phydev)\n\t\tphy_stop(dev->phydev);\n\tspin_lock_irqsave(&lp->lock, flags);\n\ttc35815_chip_reset(dev);\n\tspin_unlock_irqrestore(&lp->lock, flags);\n\tpci_set_power_state(pdev, PCI_D3hot);\n\treturn 0;\n}\n\nstatic int tc35815_resume(struct pci_dev *pdev)\n{\n\tstruct net_device *dev = pci_get_drvdata(pdev);\n\n\tpci_restore_state(pdev);\n\tif (!netif_running(dev))\n\t\treturn 0;\n\tpci_set_power_state(pdev, PCI_D0);\n\ttc35815_restart(dev);\n\tnetif_carrier_off(dev);\n\tif (dev->phydev)\n\t\tphy_start(dev->phydev);\n\tnetif_device_attach(dev);\n\treturn 0;\n}\n#endif  \n\nstatic struct pci_driver tc35815_pci_driver = {\n\t.name\t\t= MODNAME,\n\t.id_table\t= tc35815_pci_tbl,\n\t.probe\t\t= tc35815_init_one,\n\t.remove\t\t= tc35815_remove_one,\n#ifdef CONFIG_PM\n\t.suspend\t= tc35815_suspend,\n\t.resume\t\t= tc35815_resume,\n#endif\n};\n\nmodule_param_named(speed, options.speed, int, 0);\nMODULE_PARM_DESC(speed, \"0:auto, 10:10Mbps, 100:100Mbps\");\nmodule_param_named(duplex, options.duplex, int, 0);\nMODULE_PARM_DESC(duplex, \"0:auto, 1:half, 2:full\");\n\nmodule_pci_driver(tc35815_pci_driver);\nMODULE_DESCRIPTION(\"TOSHIBA TC35815 PCI 10M/100M Ethernet driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}