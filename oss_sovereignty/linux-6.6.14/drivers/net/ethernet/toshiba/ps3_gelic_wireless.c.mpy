{
  "module_name": "ps3_gelic_wireless.c",
  "hash_id": "504a53a4b93087426906806cf933efc08169d211111e4b6b986dcc8d9c4385f3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/toshiba/ps3_gelic_wireless.c",
  "human_readable_source": "\n \n#undef DEBUG\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\n#include <linux/etherdevice.h>\n#include <linux/ethtool.h>\n#include <linux/if_vlan.h>\n\n#include <linux/in.h>\n#include <linux/ip.h>\n#include <linux/tcp.h>\n#include <linux/wireless.h>\n#include <linux/ieee80211.h>\n#include <linux/if_arp.h>\n#include <linux/ctype.h>\n#include <linux/string.h>\n#include <net/iw_handler.h>\n\n#include <linux/dma-mapping.h>\n#include <net/checksum.h>\n#include <asm/firmware.h>\n#include <asm/ps3.h>\n#include <asm/lv1call.h>\n\n#include \"ps3_gelic_net.h\"\n#include \"ps3_gelic_wireless.h\"\n\n\nstatic int gelic_wl_start_scan(struct gelic_wl_info *wl, int always_scan,\n\t\t\t       u8 *essid, size_t essid_len);\nstatic int gelic_wl_try_associate(struct net_device *netdev);\n\n \n\n \nstatic const int channel_freq[] = {\n\t2412, 2417, 2422, 2427, 2432,\n\t2437, 2442, 2447, 2452, 2457,\n\t2462, 2467, 2472, 2484\n};\n#define NUM_CHANNELS ARRAY_SIZE(channel_freq)\n\n \nstatic const int bitrate_list[] = {\n\t  1000000,\n\t  2000000,\n\t  5500000,\n\t 11000000,\n\t  6000000,\n\t  9000000,\n\t 12000000,\n\t 18000000,\n\t 24000000,\n\t 36000000,\n\t 48000000,\n\t 54000000\n};\n#define NUM_BITRATES ARRAY_SIZE(bitrate_list)\n\n \nstatic inline int wpa2_capable(void)\n{\n\treturn 0 <= ps3_compare_firmware_version(2, 0, 0);\n}\n\nstatic inline int precise_ie(void)\n{\n\treturn 0 <= ps3_compare_firmware_version(2, 2, 0);\n}\n \nstruct eurus_cmd_arg_info {\n\tint pre_arg;  \n\tint post_arg;  \n};\n\nstatic const struct eurus_cmd_arg_info cmd_info[GELIC_EURUS_CMD_MAX_INDEX] = {\n\t[GELIC_EURUS_CMD_SET_COMMON_CFG] = { .pre_arg = 1},\n\t[GELIC_EURUS_CMD_SET_WEP_CFG]    = { .pre_arg = 1},\n\t[GELIC_EURUS_CMD_SET_WPA_CFG]    = { .pre_arg = 1},\n\t[GELIC_EURUS_CMD_GET_COMMON_CFG] = { .post_arg = 1},\n\t[GELIC_EURUS_CMD_GET_WEP_CFG]    = { .post_arg = 1},\n\t[GELIC_EURUS_CMD_GET_WPA_CFG]    = { .post_arg = 1},\n\t[GELIC_EURUS_CMD_GET_RSSI_CFG]   = { .post_arg = 1},\n\t[GELIC_EURUS_CMD_START_SCAN]     = { .pre_arg = 1},\n\t[GELIC_EURUS_CMD_GET_SCAN]       = { .post_arg = 1},\n};\n\n#ifdef DEBUG\nstatic const char *cmdstr(enum gelic_eurus_command ix)\n{\n\tswitch (ix) {\n\tcase GELIC_EURUS_CMD_ASSOC:\n\t\treturn \"ASSOC\";\n\tcase GELIC_EURUS_CMD_DISASSOC:\n\t\treturn \"DISASSOC\";\n\tcase GELIC_EURUS_CMD_START_SCAN:\n\t\treturn \"SCAN\";\n\tcase GELIC_EURUS_CMD_GET_SCAN:\n\t\treturn \"GET SCAN\";\n\tcase GELIC_EURUS_CMD_SET_COMMON_CFG:\n\t\treturn \"SET_COMMON_CFG\";\n\tcase GELIC_EURUS_CMD_GET_COMMON_CFG:\n\t\treturn \"GET_COMMON_CFG\";\n\tcase GELIC_EURUS_CMD_SET_WEP_CFG:\n\t\treturn \"SET_WEP_CFG\";\n\tcase GELIC_EURUS_CMD_GET_WEP_CFG:\n\t\treturn \"GET_WEP_CFG\";\n\tcase GELIC_EURUS_CMD_SET_WPA_CFG:\n\t\treturn \"SET_WPA_CFG\";\n\tcase GELIC_EURUS_CMD_GET_WPA_CFG:\n\t\treturn \"GET_WPA_CFG\";\n\tcase GELIC_EURUS_CMD_GET_RSSI_CFG:\n\t\treturn \"GET_RSSI\";\n\tdefault:\n\t\tbreak;\n\t}\n\treturn \"\";\n};\n#else\nstatic inline const char *cmdstr(enum gelic_eurus_command ix)\n{\n\treturn \"\";\n}\n#endif\n\n \nstatic void gelic_eurus_sync_cmd_worker(struct work_struct *work)\n{\n\tstruct gelic_eurus_cmd *cmd;\n\tstruct gelic_card *card;\n\tstruct gelic_wl_info *wl;\n\n\tu64 arg1, arg2;\n\n\tpr_debug(\"%s: <-\\n\", __func__);\n\tcmd = container_of(work, struct gelic_eurus_cmd, work);\n\tBUG_ON(cmd_info[cmd->cmd].pre_arg &&\n\t       cmd_info[cmd->cmd].post_arg);\n\twl = cmd->wl;\n\tcard = port_to_card(wl_port(wl));\n\n\tif (cmd_info[cmd->cmd].pre_arg) {\n\t\targ1 = (cmd->buffer) ?\n\t\t\tps3_mm_phys_to_lpar(__pa(cmd->buffer)) :\n\t\t\t0;\n\t\targ2 = cmd->buf_size;\n\t} else {\n\t\targ1 = 0;\n\t\targ2 = 0;\n\t}\n\tinit_completion(&wl->cmd_done_intr);\n\tpr_debug(\"%s: cmd='%s' start\\n\", __func__, cmdstr(cmd->cmd));\n\tcmd->status = lv1_net_control(bus_id(card), dev_id(card),\n\t\t\t\t      GELIC_LV1_POST_WLAN_CMD,\n\t\t\t\t      cmd->cmd, arg1, arg2,\n\t\t\t\t      &cmd->tag, &cmd->size);\n\tif (cmd->status) {\n\t\tcomplete(&cmd->done);\n\t\tpr_info(\"%s: cmd issue failed\\n\", __func__);\n\t\treturn;\n\t}\n\n\twait_for_completion(&wl->cmd_done_intr);\n\n\tif (cmd_info[cmd->cmd].post_arg) {\n\t\targ1 = ps3_mm_phys_to_lpar(__pa(cmd->buffer));\n\t\targ2 = cmd->buf_size;\n\t} else {\n\t\targ1 = 0;\n\t\targ2 = 0;\n\t}\n\n\tcmd->status = lv1_net_control(bus_id(card), dev_id(card),\n\t\t\t\t      GELIC_LV1_GET_WLAN_CMD_RESULT,\n\t\t\t\t      cmd->tag, arg1, arg2,\n\t\t\t\t      &cmd->cmd_status, &cmd->size);\n#ifdef DEBUG\n\tif (cmd->status || cmd->cmd_status) {\n\tpr_debug(\"%s: cmd done tag=%#lx arg1=%#lx, arg2=%#lx\\n\", __func__,\n\t\t cmd->tag, arg1, arg2);\n\tpr_debug(\"%s: cmd done status=%#x cmd_status=%#lx size=%#lx\\n\",\n\t\t __func__, cmd->status, cmd->cmd_status, cmd->size);\n\t}\n#endif\n\tcomplete(&cmd->done);\n\tpr_debug(\"%s: cmd='%s' done\\n\", __func__, cmdstr(cmd->cmd));\n}\n\nstatic struct gelic_eurus_cmd *gelic_eurus_sync_cmd(struct gelic_wl_info *wl,\n\t\t\t\t\t\t    unsigned int eurus_cmd,\n\t\t\t\t\t\t    void *buffer,\n\t\t\t\t\t\t    unsigned int buf_size)\n{\n\tstruct gelic_eurus_cmd *cmd;\n\n\t \n\tcmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (!cmd)\n\t\treturn NULL;\n\n\t \n\tcmd->cmd = eurus_cmd;\n\tcmd->buffer = buffer;\n\tcmd->buf_size = buf_size;\n\tcmd->wl = wl;\n\tINIT_WORK(&cmd->work, gelic_eurus_sync_cmd_worker);\n\tinit_completion(&cmd->done);\n\tqueue_work(wl->eurus_cmd_queue, &cmd->work);\n\n\t \n\twait_for_completion(&cmd->done);\n\n\treturn cmd;\n}\n\nstatic u32 gelic_wl_get_link(struct net_device *netdev)\n{\n\tstruct gelic_wl_info *wl = port_wl(netdev_port(netdev));\n\tu32 ret;\n\n\tpr_debug(\"%s: <-\\n\", __func__);\n\tmutex_lock(&wl->assoc_stat_lock);\n\tif (wl->assoc_stat == GELIC_WL_ASSOC_STAT_ASSOCIATED)\n\t\tret = 1;\n\telse\n\t\tret = 0;\n\tmutex_unlock(&wl->assoc_stat_lock);\n\tpr_debug(\"%s: ->\\n\", __func__);\n\treturn ret;\n}\n\nstatic void gelic_wl_send_iwap_event(struct gelic_wl_info *wl, u8 *bssid)\n{\n\tunion iwreq_data data;\n\n\tmemset(&data, 0, sizeof(data));\n\tif (bssid)\n\t\tmemcpy(data.ap_addr.sa_data, bssid, ETH_ALEN);\n\tdata.ap_addr.sa_family = ARPHRD_ETHER;\n\twireless_send_event(port_to_netdev(wl_port(wl)), SIOCGIWAP,\n\t\t\t    &data, NULL);\n}\n\n \n\n \nstatic int gelic_wl_get_name(struct net_device *dev,\n\t\t\t     struct iw_request_info *info,\n\t\t\t     union iwreq_data *iwreq, char *extra)\n{\n\tstrcpy(iwreq->name, \"IEEE 802.11bg\");\n\treturn 0;\n}\n\nstatic void gelic_wl_get_ch_info(struct gelic_wl_info *wl)\n{\n\tstruct gelic_card *card = port_to_card(wl_port(wl));\n\tu64 ch_info_raw, tmp;\n\tint status;\n\n\tif (!test_and_set_bit(GELIC_WL_STAT_CH_INFO, &wl->stat)) {\n\t\tstatus = lv1_net_control(bus_id(card), dev_id(card),\n\t\t\t\t\t GELIC_LV1_GET_CHANNEL, 0, 0, 0,\n\t\t\t\t\t &ch_info_raw,\n\t\t\t\t\t &tmp);\n\t\t \n\t\tif (status) {\n\t\t\tif (status != LV1_NO_ENTRY)\n\t\t\t\tpr_info(\"%s: available ch unknown\\n\", __func__);\n\t\t\twl->ch_info = 0x07ff; \n\t\t} else\n\t\t\t \n\t\t\twl->ch_info = ch_info_raw >> 48;\n\t}\n}\n\n \nstatic int gelic_wl_get_range(struct net_device *netdev,\n\t\t\t      struct iw_request_info *info,\n\t\t\t      union iwreq_data *iwreq, char *extra)\n{\n\tstruct iw_point *point = &iwreq->data;\n\tstruct iw_range *range = (struct iw_range *)extra;\n\tstruct gelic_wl_info *wl = port_wl(netdev_port(netdev));\n\tunsigned int i, chs;\n\n\tpr_debug(\"%s: <-\\n\", __func__);\n\tpoint->length = sizeof(struct iw_range);\n\tmemset(range, 0, sizeof(struct iw_range));\n\n\trange->we_version_compiled = WIRELESS_EXT;\n\trange->we_version_source = 22;\n\n\t \n\tgelic_wl_get_ch_info(wl);\n\n\tfor (i = 0, chs = 0;\n\t     i < NUM_CHANNELS && chs < IW_MAX_FREQUENCIES; i++)\n\t\tif (wl->ch_info & (1 << i)) {\n\t\t\trange->freq[chs].i = i + 1;\n\t\t\trange->freq[chs].m = channel_freq[i];\n\t\t\trange->freq[chs].e = 6;\n\t\t\tchs++;\n\t\t}\n\trange->num_frequency = chs;\n\trange->old_num_frequency = chs;\n\trange->num_channels = chs;\n\trange->old_num_channels = chs;\n\n\t \n\tfor (i = 0; i < NUM_BITRATES; i++)\n\t\trange->bitrate[i] = bitrate_list[i];\n\trange->num_bitrates = i;\n\n\t \n\trange->max_qual.qual = 100;  \n\trange->max_qual.level = 100;\n\trange->avg_qual.qual = 50;\n\trange->avg_qual.level = 50;\n\trange->sensitivity = 0;\n\n\t \n\tIW_EVENT_CAPA_SET_KERNEL(range->event_capa);\n\tIW_EVENT_CAPA_SET(range->event_capa, SIOCGIWAP);\n\tIW_EVENT_CAPA_SET(range->event_capa, SIOCGIWSCAN);\n\n\t \n\trange->enc_capa = IW_ENC_CAPA_WPA |\n\t\tIW_ENC_CAPA_CIPHER_TKIP | IW_ENC_CAPA_CIPHER_CCMP |\n\t\tIW_ENC_CAPA_4WAY_HANDSHAKE;\n\tif (wpa2_capable())\n\t\trange->enc_capa |= IW_ENC_CAPA_WPA2;\n\trange->encoding_size[0] = 5;\t \n\trange->encoding_size[1] = 13;\t \n\trange->encoding_size[2] = 32;\t \n\trange->num_encoding_sizes = 3;\n\trange->max_encoding_tokens = GELIC_WEP_KEYS;\n\n\t \n\trange->scan_capa = IW_SCAN_CAPA_ESSID;\n\n\tpr_debug(\"%s: ->\\n\", __func__);\n\treturn 0;\n\n}\n\n \nstatic int gelic_wl_set_scan(struct net_device *netdev,\n\t\t\t   struct iw_request_info *info,\n\t\t\t   union iwreq_data *wrqu, char *extra)\n{\n\tstruct gelic_wl_info *wl = port_wl(netdev_priv(netdev));\n\tstruct iw_scan_req *req;\n\tu8 *essid = NULL;\n\tsize_t essid_len = 0;\n\n\tif (wrqu->data.length == sizeof(struct iw_scan_req) &&\n\t    wrqu->data.flags & IW_SCAN_THIS_ESSID) {\n\t\treq = (struct iw_scan_req*)extra;\n\t\tessid = req->essid;\n\t\tessid_len = req->essid_len;\n\t\tpr_debug(\"%s: ESSID scan =%s\\n\", __func__, essid);\n\t}\n\treturn gelic_wl_start_scan(wl, 1, essid, essid_len);\n}\n\n#define OUI_LEN 3\nstatic const u8 rsn_oui[OUI_LEN] = { 0x00, 0x0f, 0xac };\nstatic const u8 wpa_oui[OUI_LEN] = { 0x00, 0x50, 0xf2 };\n\n \nstatic size_t gelic_wl_synthesize_ie(u8 *buf,\n\t\t\t\t     struct gelic_eurus_scan_info *scan)\n{\n\n\tconst u8 *oui_header;\n\tu8 *start = buf;\n\tint rsn;\n\tint ccmp;\n\n\tpr_debug(\"%s: <- sec=%16x\\n\", __func__, scan->security);\n\tswitch (be16_to_cpu(scan->security) & GELIC_EURUS_SCAN_SEC_MASK) {\n\tcase GELIC_EURUS_SCAN_SEC_WPA:\n\t\trsn = 0;\n\t\tbreak;\n\tcase GELIC_EURUS_SCAN_SEC_WPA2:\n\t\trsn = 1;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\treturn 0;\n\t}\n\n\tswitch (be16_to_cpu(scan->security) & GELIC_EURUS_SCAN_SEC_WPA_MASK) {\n\tcase GELIC_EURUS_SCAN_SEC_WPA_TKIP:\n\t\tccmp = 0;\n\t\tbreak;\n\tcase GELIC_EURUS_SCAN_SEC_WPA_AES:\n\t\tccmp = 1;\n\t\tbreak;\n\tdefault:\n\t\tif (rsn) {\n\t\t\tccmp = 1;\n\t\t\tpr_info(\"%s: no cipher info. defaulted to CCMP\\n\",\n\t\t\t\t__func__);\n\t\t} else {\n\t\t\tccmp = 0;\n\t\t\tpr_info(\"%s: no cipher info. defaulted to TKIP\\n\",\n\t\t\t\t__func__);\n\t\t}\n\t}\n\n\tif (rsn)\n\t\toui_header = rsn_oui;\n\telse\n\t\toui_header = wpa_oui;\n\n\t \n\tif (rsn)\n\t\t*buf++ = WLAN_EID_RSN;\n\telse\n\t\t*buf++ = WLAN_EID_VENDOR_SPECIFIC;\n\n\t \n\tbuf++;\n\n\t \n\tif (!rsn) {\n\t\tmemcpy(buf, wpa_oui, OUI_LEN);\n\t\tbuf += OUI_LEN;\n\t\t*buf++ = 0x01;\n\t}\n\n\t \n\t*buf++ = 0x01;  \n\t*buf++ = 0x00;\n\n\t \n\tmemcpy(buf, oui_header, OUI_LEN);\n\tbuf += OUI_LEN;\n\n\tif (ccmp)\n\t\t*buf++ = 0x04;  \n\telse\n\t\t*buf++ = 0x02;  \n\n\t \n\t*buf++ = 0x01;\n\t*buf++ = 0x00;\n\n\t \n\tmemcpy(buf, oui_header, OUI_LEN);\n\tbuf += OUI_LEN;\n\tif (ccmp)\n\t\t*buf++ = 0x04;  \n\telse\n\t\t*buf++ = 0x02;  \n\n\t \n\t*buf++ = 0x01;\n\t*buf++ = 0x00;\n\n\t \n\tmemcpy(buf, oui_header, OUI_LEN);\n\tbuf += OUI_LEN;\n\t*buf++ = 0x02;  \n\n\t \n\t*buf++ = 0x00;\n\t*buf++ = 0x00;\n\n\t \n\tstart[1] = (buf - start - 2);\n\n\tpr_debug(\"%s: ->\\n\", __func__);\n\treturn buf - start;\n}\n\nstruct ie_item {\n\tu8 *data;\n\tu8 len;\n};\n\nstruct ie_info {\n\tstruct ie_item wpa;\n\tstruct ie_item rsn;\n};\n\nstatic void gelic_wl_parse_ie(u8 *data, size_t len,\n\t\t\t      struct ie_info *ie_info)\n{\n\tsize_t data_left = len;\n\tu8 *pos = data;\n\tu8 item_len;\n\tu8 item_id;\n\n\tpr_debug(\"%s: data=%p len=%ld\\n\", __func__,\n\t\t data, len);\n\tmemset(ie_info, 0, sizeof(struct ie_info));\n\n\twhile (2 <= data_left) {\n\t\titem_id = *pos++;\n\t\titem_len = *pos++;\n\t\tdata_left -= 2;\n\n\t\tif (data_left < item_len)\n\t\t\tbreak;\n\n\t\tswitch (item_id) {\n\t\tcase WLAN_EID_VENDOR_SPECIFIC:\n\t\t\tif ((OUI_LEN + 1 <= item_len) &&\n\t\t\t    !memcmp(pos, wpa_oui, OUI_LEN) &&\n\t\t\t    pos[OUI_LEN] == 0x01) {\n\t\t\t\tie_info->wpa.data = pos - 2;\n\t\t\t\tie_info->wpa.len = item_len + 2;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase WLAN_EID_RSN:\n\t\t\tie_info->rsn.data = pos - 2;\n\t\t\t \n\t\t\tie_info->rsn.len = item_len + 2;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_debug(\"%s: ignore %#x,%d\\n\", __func__,\n\t\t\t\t item_id, item_len);\n\t\t\tbreak;\n\t\t}\n\t\tpos += item_len;\n\t\tdata_left -= item_len;\n\t}\n\tpr_debug(\"%s: wpa=%p,%d wpa2=%p,%d\\n\", __func__,\n\t\t ie_info->wpa.data, ie_info->wpa.len,\n\t\t ie_info->rsn.data, ie_info->rsn.len);\n}\n\n\n \nstatic char *gelic_wl_translate_scan(struct net_device *netdev,\n\t\t\t\t     struct iw_request_info *info,\n\t\t\t\t     char *ev,\n\t\t\t\t     char *stop,\n\t\t\t\t     struct gelic_wl_scan_info *network)\n{\n\tstruct iw_event iwe;\n\tstruct gelic_eurus_scan_info *scan = network->hwinfo;\n\tchar *tmp;\n\tu8 rate;\n\tunsigned int i, j, len;\n\tu8 buf[64];  \n\n\tpr_debug(\"%s: <-\\n\", __func__);\n\n\t \n\tiwe.cmd = SIOCGIWAP;\n\tiwe.u.ap_addr.sa_family = ARPHRD_ETHER;\n\tmemcpy(iwe.u.ap_addr.sa_data, &scan->bssid[2], ETH_ALEN);\n\tev = iwe_stream_add_event(info, ev, stop, &iwe, IW_EV_ADDR_LEN);\n\n\t \n\tiwe.cmd = SIOCGIWESSID;\n\tiwe.u.data.flags = 1;\n\tiwe.u.data.length = strnlen(scan->essid, 32);\n\tev = iwe_stream_add_point(info, ev, stop, &iwe, scan->essid);\n\n\t \n\tiwe.cmd = SIOCGIWFREQ;\n\tiwe.u.freq.m = be16_to_cpu(scan->channel);\n\tiwe.u.freq.e = 0;  \n\tiwe.u.freq.i = 0;\n\tev = iwe_stream_add_event(info, ev, stop, &iwe, IW_EV_FREQ_LEN);\n\n\t \n\tiwe.cmd = SIOCGIWRATE;\n\tiwe.u.bitrate.fixed = iwe.u.bitrate.disabled = 0;\n\t \n\ttmp = ev + iwe_stream_lcp_len(info);\n\t \n\ti = 0;\n\tj = 0;\n\tpr_debug(\"%s: rates=%d rate=%d\\n\", __func__,\n\t\t network->rate_len, network->rate_ext_len);\n\twhile (i < network->rate_len) {\n\t\tif (j < network->rate_ext_len &&\n\t\t    ((scan->ext_rate[j] & 0x7f) < (scan->rate[i] & 0x7f)))\n\t\t    rate = scan->ext_rate[j++] & 0x7f;\n\t\telse\n\t\t    rate = scan->rate[i++] & 0x7f;\n\t\tiwe.u.bitrate.value = rate * 500000;  \n\t\ttmp = iwe_stream_add_value(info, ev, tmp, stop, &iwe,\n\t\t\t\t\t   IW_EV_PARAM_LEN);\n\t}\n\twhile (j < network->rate_ext_len) {\n\t\tiwe.u.bitrate.value = (scan->ext_rate[j++] & 0x7f) * 500000;\n\t\ttmp = iwe_stream_add_value(info, ev, tmp, stop, &iwe,\n\t\t\t\t\t   IW_EV_PARAM_LEN);\n\t}\n\t \n\tif (iwe_stream_lcp_len(info) < (tmp - ev))\n\t\tev = tmp;\n\n\t \n\tiwe.cmd = SIOCGIWENCODE;\n\tif (be16_to_cpu(scan->capability) & WLAN_CAPABILITY_PRIVACY)\n\t\tiwe.u.data.flags = IW_ENCODE_ENABLED | IW_ENCODE_NOKEY;\n\telse\n\t\tiwe.u.data.flags = IW_ENCODE_DISABLED;\n\tiwe.u.data.length = 0;\n\tev = iwe_stream_add_point(info, ev, stop, &iwe, scan->essid);\n\n\t \n\tiwe.cmd = SIOCGIWMODE;\n\tif (be16_to_cpu(scan->capability) &\n\t    (WLAN_CAPABILITY_ESS | WLAN_CAPABILITY_IBSS)) {\n\t\tif (be16_to_cpu(scan->capability) & WLAN_CAPABILITY_ESS)\n\t\t\tiwe.u.mode = IW_MODE_MASTER;\n\t\telse\n\t\t\tiwe.u.mode = IW_MODE_ADHOC;\n\t\tev = iwe_stream_add_event(info, ev, stop, &iwe, IW_EV_UINT_LEN);\n\t}\n\n\t \n\tiwe.cmd = IWEVQUAL;\n\tiwe.u.qual.updated  = IW_QUAL_ALL_UPDATED |\n\t\t\tIW_QUAL_QUAL_INVALID | IW_QUAL_NOISE_INVALID;\n\tiwe.u.qual.level = be16_to_cpu(scan->rssi);\n\tiwe.u.qual.qual = be16_to_cpu(scan->rssi);\n\tiwe.u.qual.noise = 0;\n\tev  = iwe_stream_add_event(info, ev, stop, &iwe, IW_EV_QUAL_LEN);\n\n\t \n\tmemset(&iwe, 0, sizeof(iwe));\n\tif (be16_to_cpu(scan->size) <= sizeof(*scan)) {\n\t\t \n\t\tlen = gelic_wl_synthesize_ie(buf, scan);\n\t\tif (len) {\n\t\t\tiwe.cmd = IWEVGENIE;\n\t\t\tiwe.u.data.length = len;\n\t\t\tev = iwe_stream_add_point(info, ev, stop, &iwe, buf);\n\t\t}\n\t} else {\n\t\t \n\t\tstruct ie_info ie_info;\n\t\tsize_t data_len;\n\n\t\tdata_len = be16_to_cpu(scan->size) - sizeof(*scan);\n\n\t\tgelic_wl_parse_ie(scan->elements, data_len, &ie_info);\n\n\t\tif (ie_info.wpa.len && (ie_info.wpa.len <= sizeof(buf))) {\n\t\t\tmemcpy(buf, ie_info.wpa.data, ie_info.wpa.len);\n\t\t\tiwe.cmd = IWEVGENIE;\n\t\t\tiwe.u.data.length = ie_info.wpa.len;\n\t\t\tev = iwe_stream_add_point(info, ev, stop, &iwe, buf);\n\t\t}\n\n\t\tif (ie_info.rsn.len && (ie_info.rsn.len <= sizeof(buf))) {\n\t\t\tmemset(&iwe, 0, sizeof(iwe));\n\t\t\tmemcpy(buf, ie_info.rsn.data, ie_info.rsn.len);\n\t\t\tiwe.cmd = IWEVGENIE;\n\t\t\tiwe.u.data.length = ie_info.rsn.len;\n\t\t\tev = iwe_stream_add_point(info, ev, stop, &iwe, buf);\n\t\t}\n\t}\n\n\tpr_debug(\"%s: ->\\n\", __func__);\n\treturn ev;\n}\n\n\nstatic int gelic_wl_get_scan(struct net_device *netdev,\n\t\t\t     struct iw_request_info *info,\n\t\t\t     union iwreq_data *wrqu, char *extra)\n{\n\tstruct gelic_wl_info *wl = port_wl(netdev_priv(netdev));\n\tstruct gelic_wl_scan_info *scan_info;\n\tchar *ev = extra;\n\tchar *stop = ev + wrqu->data.length;\n\tint ret = 0;\n\tunsigned long this_time = jiffies;\n\n\tpr_debug(\"%s: <-\\n\", __func__);\n\tif (mutex_lock_interruptible(&wl->scan_lock))\n\t\treturn -EAGAIN;\n\n\tswitch (wl->scan_stat) {\n\tcase GELIC_WL_SCAN_STAT_SCANNING:\n\t\t \n\t\tret = -EAGAIN;\n\t\tgoto out;\n\tcase GELIC_WL_SCAN_STAT_INIT:\n\t\t \n\t\tret = -ENODEV;\n\t\tgoto out;\n\tcase GELIC_WL_SCAN_STAT_GOT_LIST:\n\t\t \n\t\tbreak;\n\t}\n\n\tlist_for_each_entry(scan_info, &wl->network_list, list) {\n\t\tif (wl->scan_age == 0 ||\n\t\t    time_after(scan_info->last_scanned + wl->scan_age,\n\t\t\t       this_time))\n\t\t\tev = gelic_wl_translate_scan(netdev, info,\n\t\t\t\t\t\t     ev, stop,\n\t\t\t\t\t\t     scan_info);\n\t\telse\n\t\t\tpr_debug(\"%s:entry too old\\n\", __func__);\n\n\t\tif (stop - ev <= IW_EV_ADDR_LEN) {\n\t\t\tret = -E2BIG;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\twrqu->data.length = ev - extra;\n\twrqu->data.flags = 0;\nout:\n\tmutex_unlock(&wl->scan_lock);\n\tpr_debug(\"%s: -> %d %d\\n\", __func__, ret, wrqu->data.length);\n\treturn ret;\n}\n\n#ifdef DEBUG\nstatic void scan_list_dump(struct gelic_wl_info *wl)\n{\n\tstruct gelic_wl_scan_info *scan_info;\n\tint i;\n\n\ti = 0;\n\tlist_for_each_entry(scan_info, &wl->network_list, list) {\n\t\tpr_debug(\"%s: item %d\\n\", __func__, i++);\n\t\tpr_debug(\"valid=%d eurusindex=%d last=%lx\\n\",\n\t\t\t scan_info->valid, scan_info->eurus_index,\n\t\t\t scan_info->last_scanned);\n\t\tpr_debug(\"r_len=%d r_ext_len=%d essid_len=%d\\n\",\n\t\t\t scan_info->rate_len, scan_info->rate_ext_len,\n\t\t\t scan_info->essid_len);\n\t\t \n\t\tpr_debug(\"bssid=%pM\\n\", &scan_info->hwinfo->bssid[2]);\n\t\tpr_debug(\"essid=%s\\n\", scan_info->hwinfo->essid);\n\t}\n}\n#endif\n\nstatic int gelic_wl_set_auth(struct net_device *netdev,\n\t\t\t     struct iw_request_info *info,\n\t\t\t     union iwreq_data *data, char *extra)\n{\n\tstruct iw_param *param = &data->param;\n\tstruct gelic_wl_info *wl = port_wl(netdev_port(netdev));\n\tunsigned long irqflag;\n\tint ret = 0;\n\n\tpr_debug(\"%s: <- %d\\n\", __func__, param->flags & IW_AUTH_INDEX);\n\tspin_lock_irqsave(&wl->lock, irqflag);\n\tswitch (param->flags & IW_AUTH_INDEX) {\n\tcase IW_AUTH_WPA_VERSION:\n\t\tif (param->value & IW_AUTH_WPA_VERSION_DISABLED) {\n\t\t\tpr_debug(\"%s: NO WPA selected\\n\", __func__);\n\t\t\twl->wpa_level = GELIC_WL_WPA_LEVEL_NONE;\n\t\t\twl->group_cipher_method = GELIC_WL_CIPHER_WEP;\n\t\t\twl->pairwise_cipher_method = GELIC_WL_CIPHER_WEP;\n\t\t}\n\t\tif (param->value & IW_AUTH_WPA_VERSION_WPA) {\n\t\t\tpr_debug(\"%s: WPA version 1 selected\\n\", __func__);\n\t\t\twl->wpa_level = GELIC_WL_WPA_LEVEL_WPA;\n\t\t\twl->group_cipher_method = GELIC_WL_CIPHER_TKIP;\n\t\t\twl->pairwise_cipher_method = GELIC_WL_CIPHER_TKIP;\n\t\t\twl->auth_method = GELIC_EURUS_AUTH_OPEN;\n\t\t}\n\t\tif (param->value & IW_AUTH_WPA_VERSION_WPA2) {\n\t\t\t \n\t\t\tif (!precise_ie())\n\t\t\t\tpr_info(\"%s: WPA2 may not work\\n\", __func__);\n\t\t\tif (wpa2_capable()) {\n\t\t\t\twl->wpa_level = GELIC_WL_WPA_LEVEL_WPA2;\n\t\t\t\twl->group_cipher_method = GELIC_WL_CIPHER_AES;\n\t\t\t\twl->pairwise_cipher_method =\n\t\t\t\t\tGELIC_WL_CIPHER_AES;\n\t\t\t\twl->auth_method = GELIC_EURUS_AUTH_OPEN;\n\t\t\t} else\n\t\t\t\tret = -EINVAL;\n\t\t}\n\t\tbreak;\n\n\tcase IW_AUTH_CIPHER_PAIRWISE:\n\t\tif (param->value &\n\t\t    (IW_AUTH_CIPHER_WEP104 | IW_AUTH_CIPHER_WEP40)) {\n\t\t\tpr_debug(\"%s: WEP selected\\n\", __func__);\n\t\t\twl->pairwise_cipher_method = GELIC_WL_CIPHER_WEP;\n\t\t}\n\t\tif (param->value & IW_AUTH_CIPHER_TKIP) {\n\t\t\tpr_debug(\"%s: TKIP selected\\n\", __func__);\n\t\t\twl->pairwise_cipher_method = GELIC_WL_CIPHER_TKIP;\n\t\t}\n\t\tif (param->value & IW_AUTH_CIPHER_CCMP) {\n\t\t\tpr_debug(\"%s: CCMP selected\\n\", __func__);\n\t\t\twl->pairwise_cipher_method = GELIC_WL_CIPHER_AES;\n\t\t}\n\t\tif (param->value & IW_AUTH_CIPHER_NONE) {\n\t\t\tpr_debug(\"%s: no auth selected\\n\", __func__);\n\t\t\twl->pairwise_cipher_method = GELIC_WL_CIPHER_NONE;\n\t\t}\n\t\tbreak;\n\tcase IW_AUTH_CIPHER_GROUP:\n\t\tif (param->value &\n\t\t    (IW_AUTH_CIPHER_WEP104 | IW_AUTH_CIPHER_WEP40)) {\n\t\t\tpr_debug(\"%s: WEP selected\\n\", __func__);\n\t\t\twl->group_cipher_method = GELIC_WL_CIPHER_WEP;\n\t\t}\n\t\tif (param->value & IW_AUTH_CIPHER_TKIP) {\n\t\t\tpr_debug(\"%s: TKIP selected\\n\", __func__);\n\t\t\twl->group_cipher_method = GELIC_WL_CIPHER_TKIP;\n\t\t}\n\t\tif (param->value & IW_AUTH_CIPHER_CCMP) {\n\t\t\tpr_debug(\"%s: CCMP selected\\n\", __func__);\n\t\t\twl->group_cipher_method = GELIC_WL_CIPHER_AES;\n\t\t}\n\t\tif (param->value & IW_AUTH_CIPHER_NONE) {\n\t\t\tpr_debug(\"%s: no auth selected\\n\", __func__);\n\t\t\twl->group_cipher_method = GELIC_WL_CIPHER_NONE;\n\t\t}\n\t\tbreak;\n\tcase IW_AUTH_80211_AUTH_ALG:\n\t\tif (param->value & IW_AUTH_ALG_SHARED_KEY) {\n\t\t\tpr_debug(\"%s: shared key specified\\n\", __func__);\n\t\t\twl->auth_method = GELIC_EURUS_AUTH_SHARED;\n\t\t} else if (param->value & IW_AUTH_ALG_OPEN_SYSTEM) {\n\t\t\tpr_debug(\"%s: open system specified\\n\", __func__);\n\t\t\twl->auth_method = GELIC_EURUS_AUTH_OPEN;\n\t\t} else\n\t\t\tret = -EINVAL;\n\t\tbreak;\n\n\tcase IW_AUTH_WPA_ENABLED:\n\t\tif (param->value) {\n\t\t\tpr_debug(\"%s: WPA enabled\\n\", __func__);\n\t\t\twl->wpa_level = GELIC_WL_WPA_LEVEL_WPA;\n\t\t} else {\n\t\t\tpr_debug(\"%s: WPA disabled\\n\", __func__);\n\t\t\twl->wpa_level = GELIC_WL_WPA_LEVEL_NONE;\n\t\t}\n\t\tbreak;\n\n\tcase IW_AUTH_KEY_MGMT:\n\t\tif (param->value & IW_AUTH_KEY_MGMT_PSK)\n\t\t\tbreak;\n\t\tfallthrough;\n\tdefault:\n\t\tret = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\n\tif (!ret)\n\t\tset_bit(GELIC_WL_STAT_CONFIGURED, &wl->stat);\n\n\tspin_unlock_irqrestore(&wl->lock, irqflag);\n\tpr_debug(\"%s: -> %d\\n\", __func__, ret);\n\treturn ret;\n}\n\nstatic int gelic_wl_get_auth(struct net_device *netdev,\n\t\t\t     struct iw_request_info *info,\n\t\t\t     union iwreq_data *iwreq, char *extra)\n{\n\tstruct iw_param *param = &iwreq->param;\n\tstruct gelic_wl_info *wl = port_wl(netdev_port(netdev));\n\tunsigned long irqflag;\n\tint ret = 0;\n\n\tpr_debug(\"%s: <- %d\\n\", __func__, param->flags & IW_AUTH_INDEX);\n\tspin_lock_irqsave(&wl->lock, irqflag);\n\tswitch (param->flags & IW_AUTH_INDEX) {\n\tcase IW_AUTH_WPA_VERSION:\n\t\tswitch (wl->wpa_level) {\n\t\tcase GELIC_WL_WPA_LEVEL_WPA:\n\t\t\tparam->value |= IW_AUTH_WPA_VERSION_WPA;\n\t\t\tbreak;\n\t\tcase GELIC_WL_WPA_LEVEL_WPA2:\n\t\t\tparam->value |= IW_AUTH_WPA_VERSION_WPA2;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tparam->value |= IW_AUTH_WPA_VERSION_DISABLED;\n\t\t}\n\t\tbreak;\n\n\tcase IW_AUTH_80211_AUTH_ALG:\n\t\tif (wl->auth_method == GELIC_EURUS_AUTH_SHARED)\n\t\t\tparam->value = IW_AUTH_ALG_SHARED_KEY;\n\t\telse if (wl->auth_method == GELIC_EURUS_AUTH_OPEN)\n\t\t\tparam->value = IW_AUTH_ALG_OPEN_SYSTEM;\n\t\tbreak;\n\n\tcase IW_AUTH_WPA_ENABLED:\n\t\tswitch (wl->wpa_level) {\n\t\tcase GELIC_WL_WPA_LEVEL_WPA:\n\t\tcase GELIC_WL_WPA_LEVEL_WPA2:\n\t\t\tparam->value = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tparam->value = 0;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tret = -EOPNOTSUPP;\n\t}\n\n\tspin_unlock_irqrestore(&wl->lock, irqflag);\n\tpr_debug(\"%s: -> %d\\n\", __func__, ret);\n\treturn ret;\n}\n\n \nstatic int gelic_wl_set_essid(struct net_device *netdev,\n\t\t\t      struct iw_request_info *info,\n\t\t\t      union iwreq_data *data, char *extra)\n{\n\tstruct gelic_wl_info *wl = port_wl(netdev_priv(netdev));\n\tunsigned long irqflag;\n\n\tpr_debug(\"%s: <- l=%d f=%d\\n\", __func__,\n\t\t data->essid.length, data->essid.flags);\n\tif (IW_ESSID_MAX_SIZE < data->essid.length)\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&wl->lock, irqflag);\n\tif (data->essid.flags) {\n\t\twl->essid_len = data->essid.length;\n\t\tmemcpy(wl->essid, extra, wl->essid_len);\n\t\tpr_debug(\"%s: essid = '%s'\\n\", __func__, extra);\n\t\tset_bit(GELIC_WL_STAT_ESSID_SET, &wl->stat);\n\t} else {\n\t\tpr_debug(\"%s: ESSID any\\n\", __func__);\n\t\tclear_bit(GELIC_WL_STAT_ESSID_SET, &wl->stat);\n\t}\n\tset_bit(GELIC_WL_STAT_CONFIGURED, &wl->stat);\n\tspin_unlock_irqrestore(&wl->lock, irqflag);\n\n\n\tgelic_wl_try_associate(netdev);  \n\tpr_debug(\"%s: ->\\n\", __func__);\n\treturn 0;\n}\n\nstatic int gelic_wl_get_essid(struct net_device *netdev,\n\t\t\t      struct iw_request_info *info,\n\t\t\t      union iwreq_data *data, char *extra)\n{\n\tstruct gelic_wl_info *wl = port_wl(netdev_priv(netdev));\n\tunsigned long irqflag;\n\n\tpr_debug(\"%s: <-\\n\", __func__);\n\tmutex_lock(&wl->assoc_stat_lock);\n\tspin_lock_irqsave(&wl->lock, irqflag);\n\tif (test_bit(GELIC_WL_STAT_ESSID_SET, &wl->stat) ||\n\t    wl->assoc_stat == GELIC_WL_ASSOC_STAT_ASSOCIATED) {\n\t\tmemcpy(extra, wl->essid, wl->essid_len);\n\t\tdata->essid.length = wl->essid_len;\n\t\tdata->essid.flags = 1;\n\t} else\n\t\tdata->essid.flags = 0;\n\n\tmutex_unlock(&wl->assoc_stat_lock);\n\tspin_unlock_irqrestore(&wl->lock, irqflag);\n\tpr_debug(\"%s: -> len=%d\\n\", __func__, data->essid.length);\n\n\treturn 0;\n}\n\n \nstatic int gelic_wl_set_encode(struct net_device *netdev,\n\t\t\t       struct iw_request_info *info,\n\t\t\t       union iwreq_data *data, char *extra)\n{\n\tstruct gelic_wl_info *wl = port_wl(netdev_priv(netdev));\n\tstruct iw_point *enc = &data->encoding;\n\t__u16 flags;\n\tunsigned long irqflag;\n\tint key_index, index_specified;\n\tint ret = 0;\n\n\tpr_debug(\"%s: <-\\n\", __func__);\n\tflags = enc->flags & IW_ENCODE_FLAGS;\n\tkey_index = enc->flags & IW_ENCODE_INDEX;\n\n\tpr_debug(\"%s: key_index = %d\\n\", __func__, key_index);\n\tpr_debug(\"%s: key_len = %d\\n\", __func__, enc->length);\n\tpr_debug(\"%s: flag=%x\\n\", __func__, enc->flags & IW_ENCODE_FLAGS);\n\n\tif (GELIC_WEP_KEYS < key_index)\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&wl->lock, irqflag);\n\tif (key_index) {\n\t\tindex_specified = 1;\n\t\tkey_index--;\n\t} else {\n\t\tindex_specified = 0;\n\t\tkey_index = wl->current_key;\n\t}\n\n\tif (flags & IW_ENCODE_NOKEY) {\n\t\t \n\t\tif (!flags && index_specified) {\n\t\t\twl->current_key = key_index;\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (flags & IW_ENCODE_DISABLED) {\n\t\t\tif (!index_specified) {\n\t\t\t\t \n\t\t\t\twl->group_cipher_method = GELIC_WL_CIPHER_NONE;\n\t\t\t\twl->pairwise_cipher_method =\n\t\t\t\t\tGELIC_WL_CIPHER_NONE;\n\t\t\t\t \n\t\t\t\twl->key_enabled = 0;\n\t\t\t} else\n\t\t\t\tclear_bit(key_index, &wl->key_enabled);\n\t\t}\n\n\t\tif (flags & IW_ENCODE_OPEN)\n\t\t\twl->auth_method = GELIC_EURUS_AUTH_OPEN;\n\t\tif (flags & IW_ENCODE_RESTRICTED) {\n\t\t\tpr_info(\"%s: shared key mode enabled\\n\", __func__);\n\t\t\twl->auth_method = GELIC_EURUS_AUTH_SHARED;\n\t\t}\n\t} else {\n\t\tif (IW_ENCODING_TOKEN_MAX < enc->length) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto done;\n\t\t}\n\t\twl->key_len[key_index] = enc->length;\n\t\tmemcpy(wl->key[key_index], extra, enc->length);\n\t\tset_bit(key_index, &wl->key_enabled);\n\t\twl->pairwise_cipher_method = GELIC_WL_CIPHER_WEP;\n\t\twl->group_cipher_method = GELIC_WL_CIPHER_WEP;\n\t}\n\tset_bit(GELIC_WL_STAT_CONFIGURED, &wl->stat);\ndone:\n\tspin_unlock_irqrestore(&wl->lock, irqflag);\n\tpr_debug(\"%s: ->\\n\", __func__);\n\treturn ret;\n}\n\nstatic int gelic_wl_get_encode(struct net_device *netdev,\n\t\t\t       struct iw_request_info *info,\n\t\t\t       union iwreq_data *data, char *extra)\n{\n\tstruct gelic_wl_info *wl = port_wl(netdev_priv(netdev));\n\tstruct iw_point *enc = &data->encoding;\n\tunsigned long irqflag;\n\tunsigned int key_index;\n\tint ret = 0;\n\n\tpr_debug(\"%s: <-\\n\", __func__);\n\tkey_index = enc->flags & IW_ENCODE_INDEX;\n\tpr_debug(\"%s: flag=%#x point=%p len=%d extra=%p\\n\", __func__,\n\t\t enc->flags, enc->pointer, enc->length, extra);\n\tif (GELIC_WEP_KEYS < key_index)\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&wl->lock, irqflag);\n\tif (key_index)\n\t\tkey_index--;\n\telse\n\t\tkey_index = wl->current_key;\n\n\tif (wl->group_cipher_method == GELIC_WL_CIPHER_WEP) {\n\t\tswitch (wl->auth_method) {\n\t\tcase GELIC_EURUS_AUTH_OPEN:\n\t\t\tenc->flags = IW_ENCODE_OPEN;\n\t\t\tbreak;\n\t\tcase GELIC_EURUS_AUTH_SHARED:\n\t\t\tenc->flags = IW_ENCODE_RESTRICTED;\n\t\t\tbreak;\n\t\t}\n\t} else\n\t\tenc->flags = IW_ENCODE_DISABLED;\n\n\tif (test_bit(key_index, &wl->key_enabled)) {\n\t\tif (enc->length < wl->key_len[key_index]) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto done;\n\t\t}\n\t\tenc->length = wl->key_len[key_index];\n\t\tmemcpy(extra, wl->key[key_index], wl->key_len[key_index]);\n\t} else {\n\t\tenc->length = 0;\n\t\tenc->flags |= IW_ENCODE_NOKEY;\n\t}\n\tenc->flags |= key_index + 1;\n\tpr_debug(\"%s: -> flag=%x len=%d\\n\", __func__,\n\t\t enc->flags, enc->length);\n\ndone:\n\tspin_unlock_irqrestore(&wl->lock, irqflag);\n\treturn ret;\n}\n\n \nstatic int gelic_wl_set_ap(struct net_device *netdev,\n\t\t\t   struct iw_request_info *info,\n\t\t\t   union iwreq_data *data, char *extra)\n{\n\tstruct gelic_wl_info *wl = port_wl(netdev_priv(netdev));\n\tunsigned long irqflag;\n\n\tpr_debug(\"%s: <-\\n\", __func__);\n\tif (data->ap_addr.sa_family != ARPHRD_ETHER)\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&wl->lock, irqflag);\n\tif (is_valid_ether_addr(data->ap_addr.sa_data)) {\n\t\tmemcpy(wl->bssid, data->ap_addr.sa_data,\n\t\t       ETH_ALEN);\n\t\tset_bit(GELIC_WL_STAT_BSSID_SET, &wl->stat);\n\t\tset_bit(GELIC_WL_STAT_CONFIGURED, &wl->stat);\n\t\tpr_debug(\"%s: bss=%pM\\n\", __func__, wl->bssid);\n\t} else {\n\t\tpr_debug(\"%s: clear bssid\\n\", __func__);\n\t\tclear_bit(GELIC_WL_STAT_BSSID_SET, &wl->stat);\n\t\teth_zero_addr(wl->bssid);\n\t}\n\tspin_unlock_irqrestore(&wl->lock, irqflag);\n\tpr_debug(\"%s: ->\\n\", __func__);\n\treturn 0;\n}\n\nstatic int gelic_wl_get_ap(struct net_device *netdev,\n\t\t\t   struct iw_request_info *info,\n\t\t\t   union iwreq_data *data, char *extra)\n{\n\tstruct gelic_wl_info *wl = port_wl(netdev_priv(netdev));\n\tunsigned long irqflag;\n\n\tpr_debug(\"%s: <-\\n\", __func__);\n\tmutex_lock(&wl->assoc_stat_lock);\n\tspin_lock_irqsave(&wl->lock, irqflag);\n\tif (wl->assoc_stat == GELIC_WL_ASSOC_STAT_ASSOCIATED) {\n\t\tdata->ap_addr.sa_family = ARPHRD_ETHER;\n\t\tmemcpy(data->ap_addr.sa_data, wl->active_bssid,\n\t\t       ETH_ALEN);\n\t} else\n\t\teth_zero_addr(data->ap_addr.sa_data);\n\n\tspin_unlock_irqrestore(&wl->lock, irqflag);\n\tmutex_unlock(&wl->assoc_stat_lock);\n\tpr_debug(\"%s: ->\\n\", __func__);\n\treturn 0;\n}\n\n \nstatic int gelic_wl_set_encodeext(struct net_device *netdev,\n\t\t\t\t  struct iw_request_info *info,\n\t\t\t\t  union iwreq_data *data, char *extra)\n{\n\tstruct gelic_wl_info *wl = port_wl(netdev_priv(netdev));\n\tstruct iw_point *enc = &data->encoding;\n\tstruct iw_encode_ext *ext = (struct iw_encode_ext *)extra;\n\t__u16 alg;\n\t__u16 flags;\n\tunsigned long irqflag;\n\tint key_index;\n\tint ret = 0;\n\n\tpr_debug(\"%s: <-\\n\", __func__);\n\tflags = enc->flags & IW_ENCODE_FLAGS;\n\talg = ext->alg;\n\tkey_index = enc->flags & IW_ENCODE_INDEX;\n\n\tpr_debug(\"%s: key_index = %d\\n\", __func__, key_index);\n\tpr_debug(\"%s: key_len = %d\\n\", __func__, enc->length);\n\tpr_debug(\"%s: flag=%x\\n\", __func__, enc->flags & IW_ENCODE_FLAGS);\n\tpr_debug(\"%s: ext_flag=%x\\n\", __func__, ext->ext_flags);\n\tpr_debug(\"%s: ext_key_len=%x\\n\", __func__, ext->key_len);\n\n\tif (GELIC_WEP_KEYS < key_index)\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&wl->lock, irqflag);\n\tif (key_index)\n\t\tkey_index--;\n\telse\n\t\tkey_index = wl->current_key;\n\n\tif (!enc->length && (ext->ext_flags & IW_ENCODE_EXT_SET_TX_KEY)) {\n\t\t \n\t\tpr_debug(\"%s: request to change default key to %d\\n\",\n\t\t\t __func__, key_index);\n\t\twl->current_key = key_index;\n\t\tgoto done;\n\t}\n\n\tif (alg == IW_ENCODE_ALG_NONE || (flags & IW_ENCODE_DISABLED)) {\n\t\tpr_debug(\"%s: alg disabled\\n\", __func__);\n\t\twl->wpa_level = GELIC_WL_WPA_LEVEL_NONE;\n\t\twl->group_cipher_method = GELIC_WL_CIPHER_NONE;\n\t\twl->pairwise_cipher_method = GELIC_WL_CIPHER_NONE;\n\t\twl->auth_method = GELIC_EURUS_AUTH_OPEN;  \n\t} else if (alg == IW_ENCODE_ALG_WEP) {\n\t\tpr_debug(\"%s: WEP requested\\n\", __func__);\n\t\tif (flags & IW_ENCODE_OPEN) {\n\t\t\tpr_debug(\"%s: open key mode\\n\", __func__);\n\t\t\twl->auth_method = GELIC_EURUS_AUTH_OPEN;\n\t\t}\n\t\tif (flags & IW_ENCODE_RESTRICTED) {\n\t\t\tpr_debug(\"%s: shared key mode\\n\", __func__);\n\t\t\twl->auth_method = GELIC_EURUS_AUTH_SHARED;\n\t\t}\n\t\tif (IW_ENCODING_TOKEN_MAX < ext->key_len) {\n\t\t\tpr_info(\"%s: key is too long %d\\n\", __func__,\n\t\t\t\text->key_len);\n\t\t\tret = -EINVAL;\n\t\t\tgoto done;\n\t\t}\n\t\t \n\t\twl->key_len[key_index] = ext->key_len;\n\t\tmemset(wl->key[key_index], 0, IW_ENCODING_TOKEN_MAX);\n\t\tmemcpy(wl->key[key_index], ext->key, ext->key_len);\n\t\tset_bit(key_index, &wl->key_enabled);\n\t\t \n\t\tset_bit(GELIC_WL_STAT_CONFIGURED, &wl->stat);\n\t} else if (alg == IW_ENCODE_ALG_PMK) {\n\t\tif (ext->key_len != WPA_PSK_LEN) {\n\t\t\tpr_err(\"%s: PSK length wrong %d\\n\", __func__,\n\t\t\t       ext->key_len);\n\t\t\tret = -EINVAL;\n\t\t\tgoto done;\n\t\t}\n\t\tmemset(wl->psk, 0, sizeof(wl->psk));\n\t\tmemcpy(wl->psk, ext->key, ext->key_len);\n\t\twl->psk_len = ext->key_len;\n\t\twl->psk_type = GELIC_EURUS_WPA_PSK_BIN;\n\t\t \n\t\tset_bit(GELIC_WL_STAT_WPA_PSK_SET, &wl->stat);\n\t}\ndone:\n\tspin_unlock_irqrestore(&wl->lock, irqflag);\n\tpr_debug(\"%s: ->\\n\", __func__);\n\treturn ret;\n}\n\nstatic int gelic_wl_get_encodeext(struct net_device *netdev,\n\t\t\t\t  struct iw_request_info *info,\n\t\t\t\t  union iwreq_data *data, char *extra)\n{\n\tstruct gelic_wl_info *wl = port_wl(netdev_priv(netdev));\n\tstruct iw_point *enc = &data->encoding;\n\tstruct iw_encode_ext *ext = (struct iw_encode_ext *)extra;\n\tunsigned long irqflag;\n\tint key_index;\n\tint ret = 0;\n\tint max_key_len;\n\n\tpr_debug(\"%s: <-\\n\", __func__);\n\n\tmax_key_len = enc->length - sizeof(struct iw_encode_ext);\n\tif (max_key_len < 0)\n\t\treturn -EINVAL;\n\tkey_index = enc->flags & IW_ENCODE_INDEX;\n\n\tpr_debug(\"%s: key_index = %d\\n\", __func__, key_index);\n\tpr_debug(\"%s: key_len = %d\\n\", __func__, enc->length);\n\tpr_debug(\"%s: flag=%x\\n\", __func__, enc->flags & IW_ENCODE_FLAGS);\n\n\tif (GELIC_WEP_KEYS < key_index)\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&wl->lock, irqflag);\n\tif (key_index)\n\t\tkey_index--;\n\telse\n\t\tkey_index = wl->current_key;\n\n\tmemset(ext, 0, sizeof(struct iw_encode_ext));\n\tswitch (wl->group_cipher_method) {\n\tcase GELIC_WL_CIPHER_WEP:\n\t\text->alg = IW_ENCODE_ALG_WEP;\n\t\tenc->flags |= IW_ENCODE_ENABLED;\n\t\tbreak;\n\tcase GELIC_WL_CIPHER_TKIP:\n\t\text->alg = IW_ENCODE_ALG_TKIP;\n\t\tenc->flags |= IW_ENCODE_ENABLED;\n\t\tbreak;\n\tcase GELIC_WL_CIPHER_AES:\n\t\text->alg = IW_ENCODE_ALG_CCMP;\n\t\tenc->flags |= IW_ENCODE_ENABLED;\n\t\tbreak;\n\tcase GELIC_WL_CIPHER_NONE:\n\tdefault:\n\t\text->alg = IW_ENCODE_ALG_NONE;\n\t\tenc->flags |= IW_ENCODE_NOKEY;\n\t\tbreak;\n\t}\n\n\tif (!(enc->flags & IW_ENCODE_NOKEY)) {\n\t\tif (max_key_len < wl->key_len[key_index]) {\n\t\t\tret = -E2BIG;\n\t\t\tgoto out;\n\t\t}\n\t\tif (test_bit(key_index, &wl->key_enabled))\n\t\t\tmemcpy(ext->key, wl->key[key_index],\n\t\t\t       wl->key_len[key_index]);\n\t\telse\n\t\t\tpr_debug(\"%s: disabled key requested ix=%d\\n\",\n\t\t\t\t __func__, key_index);\n\t}\nout:\n\tspin_unlock_irqrestore(&wl->lock, irqflag);\n\tpr_debug(\"%s: ->\\n\", __func__);\n\treturn ret;\n}\n \nstatic int gelic_wl_set_mode(struct net_device *netdev,\n\t\t\t     struct iw_request_info *info,\n\t\t\t     union iwreq_data *data, char *extra)\n{\n\t__u32 mode = data->mode;\n\tint ret;\n\n\tpr_debug(\"%s: <-\\n\", __func__);\n\tif (mode == IW_MODE_INFRA)\n\t\tret = 0;\n\telse\n\t\tret = -EOPNOTSUPP;\n\tpr_debug(\"%s: -> %d\\n\", __func__, ret);\n\treturn ret;\n}\n\nstatic int gelic_wl_get_mode(struct net_device *netdev,\n\t\t\t     struct iw_request_info *info,\n\t\t\t     union iwreq_data *data, char *extra)\n{\n\t__u32 *mode = &data->mode;\n\tpr_debug(\"%s: <-\\n\", __func__);\n\t*mode = IW_MODE_INFRA;\n\tpr_debug(\"%s: ->\\n\", __func__);\n\treturn 0;\n}\n\n \nstatic int gelic_wl_get_nick(struct net_device *net_dev,\n\t\t\t\t  struct iw_request_info *info,\n\t\t\t\t  union iwreq_data *data, char *extra)\n{\n\tstrcpy(extra, \"gelic_wl\");\n\tdata->data.length = strlen(extra);\n\tdata->data.flags = 1;\n\treturn 0;\n}\n\n\n \n\nstatic struct iw_statistics *gelic_wl_get_wireless_stats(\n\tstruct net_device *netdev)\n{\n\n\tstruct gelic_wl_info *wl = port_wl(netdev_priv(netdev));\n\tstruct gelic_eurus_cmd *cmd;\n\tstruct iw_statistics *is;\n\tstruct gelic_eurus_rssi_info *rssi;\n\tvoid *buf;\n\n\tpr_debug(\"%s: <-\\n\", __func__);\n\n\tbuf = (void *)__get_free_page(GFP_KERNEL);\n\tif (!buf)\n\t\treturn NULL;\n\n\tis = &wl->iwstat;\n\tmemset(is, 0, sizeof(*is));\n\tcmd = gelic_eurus_sync_cmd(wl, GELIC_EURUS_CMD_GET_RSSI_CFG,\n\t\t\t\t   buf, sizeof(*rssi));\n\tif (cmd && !cmd->status && !cmd->cmd_status) {\n\t\trssi = buf;\n\t\tis->qual.level = be16_to_cpu(rssi->rssi);\n\t\tis->qual.updated = IW_QUAL_LEVEL_UPDATED |\n\t\t\tIW_QUAL_QUAL_INVALID | IW_QUAL_NOISE_INVALID;\n\t} else\n\t\t \n\t\tis->qual.updated = IW_QUAL_ALL_INVALID;\n\n\tkfree(cmd);\n\tfree_page((unsigned long)buf);\n\tpr_debug(\"%s: ->\\n\", __func__);\n\treturn is;\n}\n\n \nstatic int gelic_wl_start_scan(struct gelic_wl_info *wl, int always_scan,\n\t\t\t       u8 *essid, size_t essid_len)\n{\n\tstruct gelic_eurus_cmd *cmd;\n\tint ret = 0;\n\tvoid *buf = NULL;\n\tsize_t len;\n\n\tpr_debug(\"%s: <- always=%d\\n\", __func__, always_scan);\n\tif (mutex_lock_interruptible(&wl->scan_lock))\n\t\treturn -ERESTARTSYS;\n\n\t \n\tif (wl->scan_stat == GELIC_WL_SCAN_STAT_SCANNING) {\n\t\tpr_debug(\"%s: scanning now\\n\", __func__);\n\t\tgoto out;\n\t}\n\n\tinit_completion(&wl->scan_done);\n\t \n\tif ((!essid_len && !always_scan)\n\t    && wl->scan_stat == GELIC_WL_SCAN_STAT_GOT_LIST) {\n\t\tpr_debug(\"%s: already has the list\\n\", __func__);\n\t\tcomplete(&wl->scan_done);\n\t\tgoto out;\n\t}\n\n\t \n\tif (essid_len && essid) {\n\t\tbuf = (void *)__get_free_page(GFP_KERNEL);\n\t\tif (!buf) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tlen = IW_ESSID_MAX_SIZE;  \n\t\tmemset(buf, 0, len);\n\t\tmemcpy(buf, essid, essid_len);\n\t\tpr_debug(\"%s: essid scan='%s'\\n\", __func__, (char *)buf);\n\t} else\n\t\tlen = 0;\n\n\t \n\twl->scan_stat = GELIC_WL_SCAN_STAT_SCANNING;\n\tcmd = gelic_eurus_sync_cmd(wl, GELIC_EURUS_CMD_START_SCAN,\n\t\t\t\t   buf, len);\n\tif (!cmd || cmd->status || cmd->cmd_status) {\n\t\twl->scan_stat = GELIC_WL_SCAN_STAT_INIT;\n\t\tcomplete(&wl->scan_done);\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tkfree(cmd);\nout:\n\tfree_page((unsigned long)buf);\n\tmutex_unlock(&wl->scan_lock);\n\tpr_debug(\"%s: ->\\n\", __func__);\n\treturn ret;\n}\n\n \nstatic void gelic_wl_scan_complete_event(struct gelic_wl_info *wl)\n{\n\tstruct gelic_eurus_cmd *cmd = NULL;\n\tstruct gelic_wl_scan_info *target, *tmp;\n\tstruct gelic_wl_scan_info *oldest = NULL;\n\tstruct gelic_eurus_scan_info *scan_info;\n\tunsigned int scan_info_size;\n\tunion iwreq_data data;\n\tunsigned long this_time = jiffies;\n\tunsigned int data_len, i, found, r;\n\tvoid *buf;\n\n\tpr_debug(\"%s:start\\n\", __func__);\n\tmutex_lock(&wl->scan_lock);\n\n\tbuf = (void *)__get_free_page(GFP_KERNEL);\n\tif (!buf) {\n\t\tpr_info(\"%s: scan buffer alloc failed\\n\", __func__);\n\t\tgoto out;\n\t}\n\n\tif (wl->scan_stat != GELIC_WL_SCAN_STAT_SCANNING) {\n\t\t \n\t\tpr_debug(\"%s: scan complete when stat != scanning(%d)\\n\",\n\t\t\t __func__, wl->scan_stat);\n\t\tgoto out;\n\t}\n\n\tcmd = gelic_eurus_sync_cmd(wl, GELIC_EURUS_CMD_GET_SCAN,\n\t\t\t\t   buf, PAGE_SIZE);\n\tif (!cmd || cmd->status || cmd->cmd_status) {\n\t\twl->scan_stat = GELIC_WL_SCAN_STAT_INIT;\n\t\tpr_info(\"%s:cmd failed\\n\", __func__);\n\t\tkfree(cmd);\n\t\tgoto out;\n\t}\n\tdata_len = cmd->size;\n\tpr_debug(\"%s: data_len = %d\\n\", __func__, data_len);\n\tkfree(cmd);\n\n\t \n\twl->scan_stat = GELIC_WL_SCAN_STAT_GOT_LIST;\n\n\t \n\tlist_for_each_entry_safe(target, tmp, &wl->network_list, list) {\n\t\ttarget->valid = 0;\n\t\t \n\t\tif (time_before(target->last_scanned + wl->scan_age,\n\t\t\t\tthis_time)) {\n\t\t\tkfree(target->hwinfo);\n\t\t\ttarget->hwinfo = NULL;\n\t\t\tlist_move_tail(&target->list, &wl->network_free_list);\n\t\t}\n\t}\n\n\t \n\tfor (i = 0, scan_info_size = 0, scan_info = buf;\n\t     scan_info_size < data_len;\n\t     i++, scan_info_size += be16_to_cpu(scan_info->size),\n\t     scan_info = (void *)scan_info + be16_to_cpu(scan_info->size)) {\n\t\tpr_debug(\"%s:size=%d bssid=%pM scan_info=%p\\n\", __func__,\n\t\t\t be16_to_cpu(scan_info->size),\n\t\t\t &scan_info->bssid[2], scan_info);\n\n\t\t \n\t\tif (!be16_to_cpu(scan_info->channel) || !scan_info->rate[0]) {\n\t\t\tpr_debug(\"%s: invalid scan info\\n\", __func__);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfound = 0;\n\t\toldest = NULL;\n\t\tlist_for_each_entry(target, &wl->network_list, list) {\n\t\t\tif (ether_addr_equal(&target->hwinfo->bssid[2],\n\t\t\t\t\t     &scan_info->bssid[2])) {\n\t\t\t\tfound = 1;\n\t\t\t\tpr_debug(\"%s: same BBS found scanned list\\n\",\n\t\t\t\t\t __func__);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!oldest ||\n\t\t\t    (target->last_scanned < oldest->last_scanned))\n\t\t\t\toldest = target;\n\t\t}\n\n\t\tif (!found) {\n\t\t\t \n\t\t\tif (list_empty(&wl->network_free_list)) {\n\t\t\t\t \n\t\t\t\ttarget = oldest;\n\t\t\t} else {\n\t\t\t\ttarget = list_entry(wl->network_free_list.next,\n\t\t\t\t\t\t    struct gelic_wl_scan_info,\n\t\t\t\t\t\t    list);\n\t\t\t}\n\t\t}\n\n\t\t \n\t\ttarget->last_scanned = this_time;\n\t\ttarget->valid = 1;\n\t\ttarget->eurus_index = i;\n\t\tkfree(target->hwinfo);\n\t\ttarget->hwinfo = kmemdup(scan_info,\n\t\t\t\t\t be16_to_cpu(scan_info->size),\n\t\t\t\t\t GFP_KERNEL);\n\t\tif (!target->hwinfo)\n\t\t\tcontinue;\n\n\t\t \n\t\ttarget->essid_len = strnlen(scan_info->essid,\n\t\t\t\t\t    sizeof(scan_info->essid));\n\t\ttarget->rate_len = 0;\n\t\tfor (r = 0; r < 12; r++)\n\t\t\tif (scan_info->rate[r])\n\t\t\t\ttarget->rate_len++;\n\t\tif (8 < target->rate_len)\n\t\t\tpr_info(\"%s: AP returns %d rates\\n\", __func__,\n\t\t\t\ttarget->rate_len);\n\t\ttarget->rate_ext_len = 0;\n\t\tfor (r = 0; r < 16; r++)\n\t\t\tif (scan_info->ext_rate[r])\n\t\t\t\ttarget->rate_ext_len++;\n\t\tlist_move_tail(&target->list, &wl->network_list);\n\t}\n\tmemset(&data, 0, sizeof(data));\n\twireless_send_event(port_to_netdev(wl_port(wl)), SIOCGIWSCAN, &data,\n\t\t\t    NULL);\nout:\n\tfree_page((unsigned long)buf);\n\tcomplete(&wl->scan_done);\n\tmutex_unlock(&wl->scan_lock);\n\tpr_debug(\"%s:end\\n\", __func__);\n}\n\n \nstatic void update_best(struct gelic_wl_scan_info **best,\n\t\t\tstruct gelic_wl_scan_info *candid,\n\t\t\tint *best_weight,\n\t\t\tint *weight)\n{\n\tif (*best_weight < ++(*weight)) {\n\t\t*best_weight = *weight;\n\t\t*best = candid;\n\t}\n}\n\nstatic\nstruct gelic_wl_scan_info *gelic_wl_find_best_bss(struct gelic_wl_info *wl)\n{\n\tstruct gelic_wl_scan_info *scan_info;\n\tstruct gelic_wl_scan_info *best_bss;\n\tint weight, best_weight;\n\tu16 security;\n\n\tpr_debug(\"%s: <-\\n\", __func__);\n\n\tbest_bss = NULL;\n\tbest_weight = 0;\n\n\tlist_for_each_entry(scan_info, &wl->network_list, list) {\n\t\tpr_debug(\"%s: station %p\\n\", __func__, scan_info);\n\n\t\tif (!scan_info->valid) {\n\t\t\tpr_debug(\"%s: station invalid\\n\", __func__);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (test_bit(GELIC_WL_STAT_BSSID_SET, &wl->stat)) {\n\t\t\tif (ether_addr_equal(&scan_info->hwinfo->bssid[2],\n\t\t\t\t\t     wl->bssid)) {\n\t\t\t\tbest_bss = scan_info;\n\t\t\t\tpr_debug(\"%s: bssid matched\\n\", __func__);\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tpr_debug(\"%s: bssid unmatched\\n\", __func__);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tweight = 0;\n\n\t\t \n\t\tsecurity = be16_to_cpu(scan_info->hwinfo->security) &\n\t\t\tGELIC_EURUS_SCAN_SEC_MASK;\n\t\tif (wl->wpa_level == GELIC_WL_WPA_LEVEL_WPA2) {\n\t\t\tif (security == GELIC_EURUS_SCAN_SEC_WPA2)\n\t\t\t\tupdate_best(&best_bss, scan_info,\n\t\t\t\t\t    &best_weight, &weight);\n\t\t\telse\n\t\t\t\tcontinue;\n\t\t} else if (wl->wpa_level == GELIC_WL_WPA_LEVEL_WPA) {\n\t\t\tif (security == GELIC_EURUS_SCAN_SEC_WPA)\n\t\t\t\tupdate_best(&best_bss, scan_info,\n\t\t\t\t\t    &best_weight, &weight);\n\t\t\telse\n\t\t\t\tcontinue;\n\t\t} else if (wl->wpa_level == GELIC_WL_WPA_LEVEL_NONE &&\n\t\t\t   wl->group_cipher_method == GELIC_WL_CIPHER_WEP) {\n\t\t\tif (security == GELIC_EURUS_SCAN_SEC_WEP)\n\t\t\t\tupdate_best(&best_bss, scan_info,\n\t\t\t\t\t    &best_weight, &weight);\n\t\t\telse\n\t\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (test_bit(GELIC_WL_STAT_ESSID_SET, &wl->stat)) {\n\t\t\tif ((scan_info->essid_len == wl->essid_len) &&\n\t\t\t    !strncmp(wl->essid,\n\t\t\t\t     scan_info->hwinfo->essid,\n\t\t\t\t     scan_info->essid_len))\n\t\t\t\tupdate_best(&best_bss, scan_info,\n\t\t\t\t\t    &best_weight, &weight);\n\t\t\telse\n\t\t\t\tcontinue;\n\t\t}\n\t}\n\n#ifdef DEBUG\n\tpr_debug(\"%s: -> bss=%p\\n\", __func__, best_bss);\n\tif (best_bss) {\n\t\tpr_debug(\"%s:addr=%pM\\n\", __func__,\n\t\t\t &best_bss->hwinfo->bssid[2]);\n\t}\n#endif\n\treturn best_bss;\n}\n\n \nstatic int gelic_wl_do_wep_setup(struct gelic_wl_info *wl)\n{\n\tunsigned int i;\n\tstruct gelic_eurus_wep_cfg *wep;\n\tstruct gelic_eurus_cmd *cmd;\n\tint wep104 = 0;\n\tint have_key = 0;\n\tint ret = 0;\n\n\tpr_debug(\"%s: <-\\n\", __func__);\n\t \n\twep = (struct gelic_eurus_wep_cfg *)__get_free_page(GFP_KERNEL);\n\tif (!wep)\n\t\treturn -ENOMEM;\n\n\tmemset(wep, 0, sizeof(*wep));\n\n\tif (wl->group_cipher_method == GELIC_WL_CIPHER_WEP) {\n\t\tpr_debug(\"%s: WEP mode\\n\", __func__);\n\t\tfor (i = 0; i < GELIC_WEP_KEYS; i++) {\n\t\t\tif (!test_bit(i, &wl->key_enabled))\n\t\t\t\tcontinue;\n\n\t\t\tpr_debug(\"%s: key#%d enabled\\n\", __func__, i);\n\t\t\thave_key = 1;\n\t\t\tif (wl->key_len[i] == 13)\n\t\t\t\twep104 = 1;\n\t\t\telse if (wl->key_len[i] != 5) {\n\t\t\t\tpr_info(\"%s: wrong wep key[%d]=%d\\n\",\n\t\t\t\t\t__func__, i, wl->key_len[i]);\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tmemcpy(wep->key[i], wl->key[i], wl->key_len[i]);\n\t\t}\n\n\t\tif (!have_key) {\n\t\t\tpr_info(\"%s: all wep key disabled\\n\", __func__);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (wep104) {\n\t\t\tpr_debug(\"%s: 104bit key\\n\", __func__);\n\t\t\twep->security = cpu_to_be16(GELIC_EURUS_WEP_SEC_104BIT);\n\t\t} else {\n\t\t\tpr_debug(\"%s: 40bit key\\n\", __func__);\n\t\t\twep->security = cpu_to_be16(GELIC_EURUS_WEP_SEC_40BIT);\n\t\t}\n\t} else {\n\t\tpr_debug(\"%s: NO encryption\\n\", __func__);\n\t\twep->security = cpu_to_be16(GELIC_EURUS_WEP_SEC_NONE);\n\t}\n\n\t \n\tcmd = gelic_eurus_sync_cmd(wl, GELIC_EURUS_CMD_SET_WEP_CFG,\n\t\t\t\t   wep, sizeof(*wep));\n\tif (!cmd)\n\t\tret = -ENOMEM;\n\telse if (cmd->status || cmd->cmd_status)\n\t\tret = -ENXIO;\n\n\tkfree(cmd);\nout:\n\tfree_page((unsigned long)wep);\n\tpr_debug(\"%s: ->\\n\", __func__);\n\treturn ret;\n}\n\n#ifdef DEBUG\nstatic const char *wpasecstr(enum gelic_eurus_wpa_security sec)\n{\n\tswitch (sec) {\n\tcase GELIC_EURUS_WPA_SEC_NONE:\n\t\treturn \"NONE\";\n\tcase GELIC_EURUS_WPA_SEC_WPA_TKIP_TKIP:\n\t\treturn \"WPA_TKIP_TKIP\";\n\tcase GELIC_EURUS_WPA_SEC_WPA_TKIP_AES:\n\t\treturn \"WPA_TKIP_AES\";\n\tcase GELIC_EURUS_WPA_SEC_WPA_AES_AES:\n\t\treturn \"WPA_AES_AES\";\n\tcase GELIC_EURUS_WPA_SEC_WPA2_TKIP_TKIP:\n\t\treturn \"WPA2_TKIP_TKIP\";\n\tcase GELIC_EURUS_WPA_SEC_WPA2_TKIP_AES:\n\t\treturn \"WPA2_TKIP_AES\";\n\tcase GELIC_EURUS_WPA_SEC_WPA2_AES_AES:\n\t\treturn \"WPA2_AES_AES\";\n\t}\n\treturn \"\";\n};\n#endif\n\nstatic int gelic_wl_do_wpa_setup(struct gelic_wl_info *wl)\n{\n\tstruct gelic_eurus_wpa_cfg *wpa;\n\tstruct gelic_eurus_cmd *cmd;\n\tu16 security;\n\tint ret = 0;\n\n\tpr_debug(\"%s: <-\\n\", __func__);\n\t \n\twpa = (struct gelic_eurus_wpa_cfg *)__get_free_page(GFP_KERNEL);\n\tif (!wpa)\n\t\treturn -ENOMEM;\n\n\tmemset(wpa, 0, sizeof(*wpa));\n\n\tif (!test_bit(GELIC_WL_STAT_WPA_PSK_SET, &wl->stat))\n\t\tpr_info(\"%s: PSK not configured yet\\n\", __func__);\n\n\t \n\tmemcpy(wpa->psk, wl->psk, wl->psk_len);\n\n\t \n\tif (wl->wpa_level == GELIC_WL_WPA_LEVEL_WPA2) {\n\t\tif (wl->group_cipher_method == GELIC_WL_CIPHER_AES) {\n\t\t\tsecurity = GELIC_EURUS_WPA_SEC_WPA2_AES_AES;\n\t\t} else {\n\t\t\tif (wl->pairwise_cipher_method == GELIC_WL_CIPHER_AES &&\n\t\t\t    precise_ie())\n\t\t\t\tsecurity = GELIC_EURUS_WPA_SEC_WPA2_TKIP_AES;\n\t\t\telse\n\t\t\t\tsecurity = GELIC_EURUS_WPA_SEC_WPA2_TKIP_TKIP;\n\t\t}\n\t} else {\n\t\tif (wl->group_cipher_method == GELIC_WL_CIPHER_AES) {\n\t\t\tsecurity = GELIC_EURUS_WPA_SEC_WPA_AES_AES;\n\t\t} else {\n\t\t\tif (wl->pairwise_cipher_method == GELIC_WL_CIPHER_AES &&\n\t\t\t    precise_ie())\n\t\t\t\tsecurity = GELIC_EURUS_WPA_SEC_WPA_TKIP_AES;\n\t\t\telse\n\t\t\t\tsecurity = GELIC_EURUS_WPA_SEC_WPA_TKIP_TKIP;\n\t\t}\n\t}\n\twpa->security = cpu_to_be16(security);\n\n\t \n\twpa->psk_type = cpu_to_be16(wl->psk_type);\n#ifdef DEBUG\n\tpr_debug(\"%s: sec=%s psktype=%s\\n\", __func__,\n\t\t wpasecstr(wpa->security),\n\t\t (wpa->psk_type == GELIC_EURUS_WPA_PSK_BIN) ?\n\t\t \"BIN\" : \"passphrase\");\n#if 0\n\t \n\tpr_debug(\"%s: psk=%s\\n\", __func__,\n\t\t (wpa->psk_type == GELIC_EURUS_WPA_PSK_BIN) ?\n\t\t \"N/A\" : wpa->psk);\n#endif\n#endif\n\t \n\tcmd = gelic_eurus_sync_cmd(wl, GELIC_EURUS_CMD_SET_WPA_CFG,\n\t\t\t\t   wpa, sizeof(*wpa));\n\tif (!cmd)\n\t\tret = -ENOMEM;\n\telse if (cmd->status || cmd->cmd_status)\n\t\tret = -ENXIO;\n\tkfree(cmd);\n\tfree_page((unsigned long)wpa);\n\tpr_debug(\"%s: --> %d\\n\", __func__, ret);\n\treturn ret;\n}\n\n \nstatic int gelic_wl_associate_bss(struct gelic_wl_info *wl,\n\t\t\t\t  struct gelic_wl_scan_info *bss)\n{\n\tstruct gelic_eurus_cmd *cmd;\n\tstruct gelic_eurus_common_cfg *common;\n\tint ret = 0;\n\tunsigned long rc;\n\n\tpr_debug(\"%s: <-\\n\", __func__);\n\n\t \n\tcommon = (struct gelic_eurus_common_cfg *)__get_free_page(GFP_KERNEL);\n\tif (!common)\n\t\treturn -ENOMEM;\n\n\tmemset(common, 0, sizeof(*common));\n\tcommon->bss_type = cpu_to_be16(GELIC_EURUS_BSS_INFRA);\n\tcommon->op_mode = cpu_to_be16(GELIC_EURUS_OPMODE_11BG);\n\n\tcommon->scan_index = cpu_to_be16(bss->eurus_index);\n\tswitch (wl->auth_method) {\n\tcase GELIC_EURUS_AUTH_OPEN:\n\t\tcommon->auth_method = cpu_to_be16(GELIC_EURUS_AUTH_OPEN);\n\t\tbreak;\n\tcase GELIC_EURUS_AUTH_SHARED:\n\t\tcommon->auth_method = cpu_to_be16(GELIC_EURUS_AUTH_SHARED);\n\t\tbreak;\n\t}\n\n#ifdef DEBUG\n\tscan_list_dump(wl);\n#endif\n\tpr_debug(\"%s: common cfg index=%d bsstype=%d auth=%d\\n\", __func__,\n\t\t be16_to_cpu(common->scan_index),\n\t\t be16_to_cpu(common->bss_type),\n\t\t be16_to_cpu(common->auth_method));\n\n\tcmd = gelic_eurus_sync_cmd(wl, GELIC_EURUS_CMD_SET_COMMON_CFG,\n\t\t\t\t   common, sizeof(*common));\n\tif (!cmd || cmd->status || cmd->cmd_status) {\n\t\tret = -ENOMEM;\n\t\tkfree(cmd);\n\t\tgoto out;\n\t}\n\tkfree(cmd);\n\n\t \n\tswitch (wl->wpa_level) {\n\tcase GELIC_WL_WPA_LEVEL_NONE:\n\t\t \n\t\tret = gelic_wl_do_wep_setup(wl);\n\t\tbreak;\n\tcase GELIC_WL_WPA_LEVEL_WPA:\n\tcase GELIC_WL_WPA_LEVEL_WPA2:\n\t\tret = gelic_wl_do_wpa_setup(wl);\n\t\tbreak;\n\t}\n\n\tif (ret) {\n\t\tpr_debug(\"%s: WEP/WPA setup failed %d\\n\", __func__,\n\t\t\t ret);\n\t\tret = -EPERM;\n\t\tgelic_wl_send_iwap_event(wl, NULL);\n\t\tgoto out;\n\t}\n\n\t \n\tinit_completion(&wl->assoc_done);\n\twl->assoc_stat = GELIC_WL_ASSOC_STAT_ASSOCIATING;\n\tcmd = gelic_eurus_sync_cmd(wl, GELIC_EURUS_CMD_ASSOC,\n\t\t\t\t   NULL, 0);\n\tif (!cmd || cmd->status || cmd->cmd_status) {\n\t\tpr_debug(\"%s: assoc request failed\\n\", __func__);\n\t\twl->assoc_stat = GELIC_WL_ASSOC_STAT_DISCONN;\n\t\tkfree(cmd);\n\t\tret = -ENOMEM;\n\t\tgelic_wl_send_iwap_event(wl, NULL);\n\t\tgoto out;\n\t}\n\tkfree(cmd);\n\n\t \n\trc = wait_for_completion_timeout(&wl->assoc_done, HZ * 4); \n\n\tif (!rc) {\n\t\t \n\t\tpr_info(\"%s: connect timeout\\n\", __func__);\n\t\tcmd = gelic_eurus_sync_cmd(wl, GELIC_EURUS_CMD_DISASSOC,\n\t\t\t\t\t   NULL, 0);\n\t\tkfree(cmd);\n\t\twl->assoc_stat = GELIC_WL_ASSOC_STAT_DISCONN;\n\t\tgelic_wl_send_iwap_event(wl, NULL);\n\t\tret = -ENXIO;\n\t} else {\n\t\twl->assoc_stat = GELIC_WL_ASSOC_STAT_ASSOCIATED;\n\t\t \n\t\tmemcpy(wl->active_bssid, &bss->hwinfo->bssid[2], ETH_ALEN);\n\n\t\t \n\t\tgelic_wl_send_iwap_event(wl, wl->active_bssid);\n\t\tpr_info(\"%s: connected\\n\", __func__);\n\t}\nout:\n\tfree_page((unsigned long)common);\n\tpr_debug(\"%s: ->\\n\", __func__);\n\treturn ret;\n}\n\n \nstatic void gelic_wl_connected_event(struct gelic_wl_info *wl,\n\t\t\t\t     u64 event)\n{\n\tu64 desired_event = 0;\n\n\tswitch (wl->wpa_level) {\n\tcase GELIC_WL_WPA_LEVEL_NONE:\n\t\tdesired_event = GELIC_LV1_WL_EVENT_CONNECTED;\n\t\tbreak;\n\tcase GELIC_WL_WPA_LEVEL_WPA:\n\tcase GELIC_WL_WPA_LEVEL_WPA2:\n\t\tdesired_event = GELIC_LV1_WL_EVENT_WPA_CONNECTED;\n\t\tbreak;\n\t}\n\n\tif (desired_event == event) {\n\t\tpr_debug(\"%s: completed\\n\", __func__);\n\t\tcomplete(&wl->assoc_done);\n\t\tnetif_carrier_on(port_to_netdev(wl_port(wl)));\n\t} else\n\t\tpr_debug(\"%s: event %#llx under wpa\\n\",\n\t\t\t\t __func__, event);\n}\n\n \nstatic void gelic_wl_disconnect_event(struct gelic_wl_info *wl,\n\t\t\t\t      u64 event)\n{\n\tstruct gelic_eurus_cmd *cmd;\n\tint lock;\n\n\t \n\tif (!mutex_trylock(&wl->assoc_stat_lock)) {\n\t\tpr_debug(\"%s: already locked\\n\", __func__);\n\t\tlock = 0;\n\t} else {\n\t\tpr_debug(\"%s: obtain lock\\n\", __func__);\n\t\tlock = 1;\n\t}\n\n\tcmd = gelic_eurus_sync_cmd(wl, GELIC_EURUS_CMD_DISASSOC, NULL, 0);\n\tkfree(cmd);\n\n\t \n\tif (wl->assoc_stat == GELIC_WL_ASSOC_STAT_ASSOCIATED)\n\t\tgelic_wl_send_iwap_event(wl, NULL);\n\n\twl->assoc_stat = GELIC_WL_ASSOC_STAT_DISCONN;\n\tnetif_carrier_off(port_to_netdev(wl_port(wl)));\n\n\tif (lock)\n\t\tmutex_unlock(&wl->assoc_stat_lock);\n}\n \n#ifdef DEBUG\nstatic const char *eventstr(enum gelic_lv1_wl_event event)\n{\n\tstatic char buf[32];\n\tchar *ret;\n\tif (event & GELIC_LV1_WL_EVENT_DEVICE_READY)\n\t\tret = \"EURUS_READY\";\n\telse if (event & GELIC_LV1_WL_EVENT_SCAN_COMPLETED)\n\t\tret = \"SCAN_COMPLETED\";\n\telse if (event & GELIC_LV1_WL_EVENT_DEAUTH)\n\t\tret = \"DEAUTH\";\n\telse if (event & GELIC_LV1_WL_EVENT_BEACON_LOST)\n\t\tret = \"BEACON_LOST\";\n\telse if (event & GELIC_LV1_WL_EVENT_CONNECTED)\n\t\tret = \"CONNECTED\";\n\telse if (event & GELIC_LV1_WL_EVENT_WPA_CONNECTED)\n\t\tret = \"WPA_CONNECTED\";\n\telse if (event & GELIC_LV1_WL_EVENT_WPA_ERROR)\n\t\tret = \"WPA_ERROR\";\n\telse {\n\t\tsprintf(buf, \"Unknown(%#x)\", event);\n\t\tret = buf;\n\t}\n\treturn ret;\n}\n#else\nstatic const char *eventstr(enum gelic_lv1_wl_event event)\n{\n\treturn NULL;\n}\n#endif\nstatic void gelic_wl_event_worker(struct work_struct *work)\n{\n\tstruct gelic_wl_info *wl;\n\tstruct gelic_port *port;\n\tu64 event, tmp;\n\tint status;\n\n\tpr_debug(\"%s:start\\n\", __func__);\n\twl = container_of(work, struct gelic_wl_info, event_work.work);\n\tport = wl_port(wl);\n\twhile (1) {\n\t\tstatus = lv1_net_control(bus_id(port->card), dev_id(port->card),\n\t\t\t\t\t GELIC_LV1_GET_WLAN_EVENT, 0, 0, 0,\n\t\t\t\t\t &event, &tmp);\n\t\tif (status) {\n\t\t\tif (status != LV1_NO_ENTRY)\n\t\t\t\tpr_debug(\"%s:wlan event failed %d\\n\",\n\t\t\t\t\t __func__, status);\n\t\t\t \n\t\t\tpr_debug(\"%s:end\\n\", __func__);\n\t\t\treturn;\n\t\t}\n\t\tpr_debug(\"%s: event=%s\\n\", __func__, eventstr(event));\n\t\tswitch (event) {\n\t\tcase GELIC_LV1_WL_EVENT_SCAN_COMPLETED:\n\t\t\tgelic_wl_scan_complete_event(wl);\n\t\t\tbreak;\n\t\tcase GELIC_LV1_WL_EVENT_BEACON_LOST:\n\t\tcase GELIC_LV1_WL_EVENT_DEAUTH:\n\t\t\tgelic_wl_disconnect_event(wl, event);\n\t\t\tbreak;\n\t\tcase GELIC_LV1_WL_EVENT_CONNECTED:\n\t\tcase GELIC_LV1_WL_EVENT_WPA_CONNECTED:\n\t\t\tgelic_wl_connected_event(wl, event);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}  \n}\n \nstatic void gelic_wl_assoc_worker(struct work_struct *work)\n{\n\tstruct gelic_wl_info *wl;\n\n\tstruct gelic_wl_scan_info *best_bss;\n\tint ret;\n\tunsigned long irqflag;\n\tu8 *essid;\n\tsize_t essid_len;\n\n\twl = container_of(work, struct gelic_wl_info, assoc_work.work);\n\n\tmutex_lock(&wl->assoc_stat_lock);\n\n\tif (wl->assoc_stat != GELIC_WL_ASSOC_STAT_DISCONN)\n\t\tgoto out;\n\n\tspin_lock_irqsave(&wl->lock, irqflag);\n\tif (test_bit(GELIC_WL_STAT_ESSID_SET, &wl->stat)) {\n\t\tpr_debug(\"%s: assoc ESSID configured %s\\n\", __func__,\n\t\t\t wl->essid);\n\t\tessid = wl->essid;\n\t\tessid_len = wl->essid_len;\n\t} else {\n\t\tessid = NULL;\n\t\tessid_len = 0;\n\t}\n\tspin_unlock_irqrestore(&wl->lock, irqflag);\n\n\tret = gelic_wl_start_scan(wl, 0, essid, essid_len);\n\tif (ret == -ERESTARTSYS) {\n\t\tpr_debug(\"%s: scan start failed association\\n\", __func__);\n\t\tschedule_delayed_work(&wl->assoc_work, HZ/10);  \n\t\tgoto out;\n\t} else if (ret) {\n\t\tpr_info(\"%s: scan prerequisite failed\\n\", __func__);\n\t\tgoto out;\n\t}\n\n\t \n\twait_for_completion(&wl->scan_done);\n\n\tpr_debug(\"%s: scan done\\n\", __func__);\n\tmutex_lock(&wl->scan_lock);\n\tif (wl->scan_stat != GELIC_WL_SCAN_STAT_GOT_LIST) {\n\t\tgelic_wl_send_iwap_event(wl, NULL);\n\t\tpr_info(\"%s: no scan list. association failed\\n\", __func__);\n\t\tgoto scan_lock_out;\n\t}\n\n\t \n\tbest_bss = gelic_wl_find_best_bss(wl);\n\tif (!best_bss) {\n\t\tgelic_wl_send_iwap_event(wl, NULL);\n\t\tpr_info(\"%s: no bss matched. association failed\\n\", __func__);\n\t\tgoto scan_lock_out;\n\t}\n\n\t \n\tret = gelic_wl_associate_bss(wl, best_bss);\n\tif (ret)\n\t\tpr_info(\"%s: association failed %d\\n\", __func__, ret);\nscan_lock_out:\n\tmutex_unlock(&wl->scan_lock);\nout:\n\tmutex_unlock(&wl->assoc_stat_lock);\n}\n \nvoid gelic_wl_interrupt(struct net_device *netdev, u64 status)\n{\n\tstruct gelic_wl_info *wl = port_wl(netdev_priv(netdev));\n\n\tif (status & GELIC_CARD_WLAN_COMMAND_COMPLETED) {\n\t\tpr_debug(\"%s:cmd complete\\n\", __func__);\n\t\tcomplete(&wl->cmd_done_intr);\n\t}\n\n\tif (status & GELIC_CARD_WLAN_EVENT_RECEIVED) {\n\t\tpr_debug(\"%s:event received\\n\", __func__);\n\t\tqueue_delayed_work(wl->event_queue, &wl->event_work, 0);\n\t}\n}\n\n \nstatic const iw_handler gelic_wl_wext_handler[] =\n{\n\tIW_HANDLER(SIOCGIWNAME, gelic_wl_get_name),\n\tIW_HANDLER(SIOCGIWRANGE, gelic_wl_get_range),\n\tIW_HANDLER(SIOCSIWSCAN, gelic_wl_set_scan),\n\tIW_HANDLER(SIOCGIWSCAN, gelic_wl_get_scan),\n\tIW_HANDLER(SIOCSIWAUTH, gelic_wl_set_auth),\n\tIW_HANDLER(SIOCGIWAUTH, gelic_wl_get_auth),\n\tIW_HANDLER(SIOCSIWESSID, gelic_wl_set_essid),\n\tIW_HANDLER(SIOCGIWESSID, gelic_wl_get_essid),\n\tIW_HANDLER(SIOCSIWENCODE, gelic_wl_set_encode),\n\tIW_HANDLER(SIOCGIWENCODE, gelic_wl_get_encode),\n\tIW_HANDLER(SIOCSIWAP, gelic_wl_set_ap),\n\tIW_HANDLER(SIOCGIWAP, gelic_wl_get_ap),\n\tIW_HANDLER(SIOCSIWENCODEEXT, gelic_wl_set_encodeext),\n\tIW_HANDLER(SIOCGIWENCODEEXT, gelic_wl_get_encodeext),\n\tIW_HANDLER(SIOCSIWMODE, gelic_wl_set_mode),\n\tIW_HANDLER(SIOCGIWMODE, gelic_wl_get_mode),\n\tIW_HANDLER(SIOCGIWNICKN, gelic_wl_get_nick),\n};\n\nstatic const struct iw_handler_def gelic_wl_wext_handler_def = {\n\t.num_standard\t\t= ARRAY_SIZE(gelic_wl_wext_handler),\n\t.standard\t\t= gelic_wl_wext_handler,\n\t.get_wireless_stats\t= gelic_wl_get_wireless_stats,\n};\n\nstatic struct net_device *gelic_wl_alloc(struct gelic_card *card)\n{\n\tstruct net_device *netdev;\n\tstruct gelic_port *port;\n\tstruct gelic_wl_info *wl;\n\tunsigned int i;\n\n\tpr_debug(\"%s:start\\n\", __func__);\n\tnetdev = alloc_etherdev(sizeof(struct gelic_port) +\n\t\t\t\tsizeof(struct gelic_wl_info));\n\tpr_debug(\"%s: netdev =%p card=%p\\n\", __func__, netdev, card);\n\tif (!netdev)\n\t\treturn NULL;\n\n\tstrcpy(netdev->name, \"wlan%d\");\n\n\tport = netdev_priv(netdev);\n\tport->netdev = netdev;\n\tport->card = card;\n\tport->type = GELIC_PORT_WIRELESS;\n\n\twl = port_wl(port);\n\tpr_debug(\"%s: wl=%p port=%p\\n\", __func__, wl, port);\n\n\t \n\twl->networks = kcalloc(GELIC_WL_BSS_MAX_ENT,\n\t\t\t       sizeof(struct gelic_wl_scan_info),\n\t\t\t       GFP_KERNEL);\n\n\tif (!wl->networks)\n\t\tgoto fail_bss;\n\n\twl->eurus_cmd_queue = create_singlethread_workqueue(\"gelic_cmd\");\n\tif (!wl->eurus_cmd_queue)\n\t\tgoto fail_cmd_workqueue;\n\n\twl->event_queue = create_singlethread_workqueue(\"gelic_event\");\n\tif (!wl->event_queue)\n\t\tgoto fail_event_workqueue;\n\n\tINIT_LIST_HEAD(&wl->network_free_list);\n\tINIT_LIST_HEAD(&wl->network_list);\n\tfor (i = 0; i < GELIC_WL_BSS_MAX_ENT; i++)\n\t\tlist_add_tail(&wl->networks[i].list,\n\t\t\t      &wl->network_free_list);\n\tinit_completion(&wl->cmd_done_intr);\n\n\tINIT_DELAYED_WORK(&wl->event_work, gelic_wl_event_worker);\n\tINIT_DELAYED_WORK(&wl->assoc_work, gelic_wl_assoc_worker);\n\tmutex_init(&wl->scan_lock);\n\tmutex_init(&wl->assoc_stat_lock);\n\n\tinit_completion(&wl->scan_done);\n\t \n\tcomplete(&wl->scan_done);\n\n\tspin_lock_init(&wl->lock);\n\n\twl->scan_age = 5*HZ;  \n\n\t \n\tBUILD_BUG_ON(PAGE_SIZE <\n\t\t     sizeof(struct gelic_eurus_scan_info) *\n\t\t     GELIC_EURUS_MAX_SCAN);\n\tpr_debug(\"%s:end\\n\", __func__);\n\treturn netdev;\n\nfail_event_workqueue:\n\tdestroy_workqueue(wl->eurus_cmd_queue);\nfail_cmd_workqueue:\n\tkfree(wl->networks);\nfail_bss:\n\tfree_netdev(netdev);\n\tpr_debug(\"%s:end error\\n\", __func__);\n\treturn NULL;\n\n}\n\nstatic void gelic_wl_free(struct gelic_wl_info *wl)\n{\n\tstruct gelic_wl_scan_info *scan_info;\n\tunsigned int i;\n\n\tpr_debug(\"%s: <-\\n\", __func__);\n\n\tpr_debug(\"%s: destroy queues\\n\", __func__);\n\tdestroy_workqueue(wl->eurus_cmd_queue);\n\tdestroy_workqueue(wl->event_queue);\n\n\tscan_info = wl->networks;\n\tfor (i = 0; i < GELIC_WL_BSS_MAX_ENT; i++, scan_info++)\n\t\tkfree(scan_info->hwinfo);\n\tkfree(wl->networks);\n\n\tfree_netdev(port_to_netdev(wl_port(wl)));\n\n\tpr_debug(\"%s: ->\\n\", __func__);\n}\n\nstatic int gelic_wl_try_associate(struct net_device *netdev)\n{\n\tstruct gelic_wl_info *wl = port_wl(netdev_priv(netdev));\n\tint ret = -1;\n\tunsigned int i;\n\n\tpr_debug(\"%s: <-\\n\", __func__);\n\n\t \n\t \n\tif (wl->group_cipher_method == GELIC_WL_CIPHER_NONE) {\n\t\tif (test_bit(GELIC_WL_STAT_CONFIGURED,\n\t\t\t     &wl->stat))\n\t\t\tgoto do_associate;\n\t\telse {\n\t\t\tpr_debug(\"%s: no wep, not configured\\n\", __func__);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tif (wl->group_cipher_method == GELIC_WL_CIPHER_WEP) {\n\t\t \n\t\tfor (i = 0; i < GELIC_WEP_KEYS; i++) {\n\t\t\tif (test_bit(i, &wl->key_enabled))\n\t\t\t    goto do_associate;\n\t\t}\n\t\tpr_debug(\"%s: WEP, but no key specified\\n\", __func__);\n\t\treturn ret;\n\t}\n\n\t \n\tif ((wl->group_cipher_method == GELIC_WL_CIPHER_TKIP) ||\n\t    (wl->group_cipher_method == GELIC_WL_CIPHER_AES)) {\n\t\tif (test_bit(GELIC_WL_STAT_WPA_PSK_SET,\n\t\t\t     &wl->stat))\n\t\t\tgoto do_associate;\n\t\telse {\n\t\t\tpr_debug(\"%s: AES/TKIP, but PSK not configured\\n\",\n\t\t\t\t __func__);\n\t\t\treturn ret;\n\t\t}\n\t}\n\ndo_associate:\n\tret = schedule_delayed_work(&wl->assoc_work, 0);\n\tpr_debug(\"%s: start association work %d\\n\", __func__, ret);\n\treturn ret;\n}\n\n \nstatic int gelic_wl_open(struct net_device *netdev)\n{\n\tstruct gelic_card *card = netdev_card(netdev);\n\n\tpr_debug(\"%s:->%p\\n\", __func__, netdev);\n\n\tgelic_card_up(card);\n\n\t \n\tgelic_wl_try_associate(netdev);\n\n\tnetif_start_queue(netdev);\n\n\tpr_debug(\"%s:<-\\n\", __func__);\n\treturn 0;\n}\n\n \nstatic int gelic_wl_reset_state(struct gelic_wl_info *wl)\n{\n\tstruct gelic_wl_scan_info *target;\n\tstruct gelic_wl_scan_info *tmp;\n\n\t \n\tlist_for_each_entry_safe(target, tmp, &wl->network_list, list) {\n\t\tlist_move_tail(&target->list, &wl->network_free_list);\n\t}\n\twl->scan_stat = GELIC_WL_SCAN_STAT_INIT;\n\n\t \n\twl->auth_method = GELIC_EURUS_AUTH_OPEN;\n\twl->group_cipher_method = GELIC_WL_CIPHER_NONE;\n\twl->pairwise_cipher_method = GELIC_WL_CIPHER_NONE;\n\twl->wpa_level = GELIC_WL_WPA_LEVEL_NONE;\n\n\twl->key_enabled = 0;\n\twl->current_key = 0;\n\n\twl->psk_type = GELIC_EURUS_WPA_PSK_PASSPHRASE;\n\twl->psk_len = 0;\n\n\twl->essid_len = 0;\n\tmemset(wl->essid, 0, sizeof(wl->essid));\n\tmemset(wl->bssid, 0, sizeof(wl->bssid));\n\tmemset(wl->active_bssid, 0, sizeof(wl->active_bssid));\n\n\twl->assoc_stat = GELIC_WL_ASSOC_STAT_DISCONN;\n\n\tmemset(&wl->iwstat, 0, sizeof(wl->iwstat));\n\t \n\twl->stat = 0;\n\treturn 0;\n}\n\n \nstatic void gelic_wl_disconnect(struct net_device *netdev)\n{\n\tstruct gelic_port *port = netdev_priv(netdev);\n\tstruct gelic_wl_info *wl = port_wl(port);\n\tstruct gelic_eurus_cmd *cmd;\n\n\t \n\tif (wl->scan_stat == GELIC_WL_SCAN_STAT_SCANNING)\n\t\twait_for_completion_timeout(&wl->scan_done, HZ);\n\n\tcmd = gelic_eurus_sync_cmd(wl, GELIC_EURUS_CMD_DISASSOC, NULL, 0);\n\tkfree(cmd);\n\tgelic_wl_send_iwap_event(wl, NULL);\n};\n\nstatic int gelic_wl_stop(struct net_device *netdev)\n{\n\tstruct gelic_port *port = netdev_priv(netdev);\n\tstruct gelic_wl_info *wl = port_wl(port);\n\tstruct gelic_card *card = netdev_card(netdev);\n\n\tpr_debug(\"%s:<-\\n\", __func__);\n\n\t \n\tcancel_delayed_work(&wl->assoc_work);\n\n\tif (wl->assoc_stat == GELIC_WL_ASSOC_STAT_ASSOCIATED)\n\t\tgelic_wl_disconnect(netdev);\n\n\t \n\tgelic_wl_reset_state(wl);\n\n\tnetif_stop_queue(netdev);\n\n\tgelic_card_down(card);\n\n\tpr_debug(\"%s:->\\n\", __func__);\n\treturn 0;\n}\n\n \n\nstatic const struct net_device_ops gelic_wl_netdevice_ops = {\n\t.ndo_open = gelic_wl_open,\n\t.ndo_stop = gelic_wl_stop,\n\t.ndo_start_xmit = gelic_net_xmit,\n\t.ndo_set_rx_mode = gelic_net_set_multi,\n\t.ndo_tx_timeout = gelic_net_tx_timeout,\n\t.ndo_set_mac_address = eth_mac_addr,\n\t.ndo_validate_addr = eth_validate_addr,\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\t.ndo_poll_controller = gelic_net_poll_controller,\n#endif\n};\n\nstatic const struct ethtool_ops gelic_wl_ethtool_ops = {\n\t.get_drvinfo\t= gelic_net_get_drvinfo,\n\t.get_link\t= gelic_wl_get_link,\n};\n\nstatic void gelic_wl_setup_netdev_ops(struct net_device *netdev)\n{\n\tstruct gelic_wl_info *wl;\n\twl = port_wl(netdev_priv(netdev));\n\tBUG_ON(!wl);\n\tnetdev->watchdog_timeo = GELIC_NET_WATCHDOG_TIMEOUT;\n\n\tnetdev->ethtool_ops = &gelic_wl_ethtool_ops;\n\tnetdev->netdev_ops = &gelic_wl_netdevice_ops;\n\tnetdev->wireless_data = &wl->wireless_data;\n\tnetdev->wireless_handlers = &gelic_wl_wext_handler_def;\n}\n\n \nint gelic_wl_driver_probe(struct gelic_card *card)\n{\n\tint ret;\n\tstruct net_device *netdev;\n\n\tpr_debug(\"%s:start\\n\", __func__);\n\n\tif (ps3_compare_firmware_version(1, 6, 0) < 0)\n\t\treturn 0;\n\tif (!card->vlan[GELIC_PORT_WIRELESS].tx)\n\t\treturn 0;\n\n\t \n\tnetdev = gelic_wl_alloc(card);\n\tif (!netdev)\n\t\treturn -ENOMEM;\n\n\t \n\tSET_NETDEV_DEV(netdev, &card->dev->core);\n\tgelic_wl_setup_netdev_ops(netdev);\n\n\t \n\tret = gelic_net_setup_netdev(netdev, card);\n\tif (ret)\n\t\tgoto fail_setup;\n\tcard->netdev[GELIC_PORT_WIRELESS] = netdev;\n\n\t \n\tcard->irq_mask |= GELIC_CARD_WLAN_EVENT_RECEIVED |\n\t\tGELIC_CARD_WLAN_COMMAND_COMPLETED;\n\t \n\tgelic_card_set_irq_mask(card, GELIC_CARD_WLAN_EVENT_RECEIVED |\n\t\t\t\tGELIC_CARD_WLAN_COMMAND_COMPLETED);\n\tpr_debug(\"%s:end\\n\", __func__);\n\treturn 0;\n\nfail_setup:\n\tgelic_wl_free(port_wl(netdev_port(netdev)));\n\n\treturn ret;\n}\n\nint gelic_wl_driver_remove(struct gelic_card *card)\n{\n\tstruct gelic_wl_info *wl;\n\tstruct net_device *netdev;\n\n\tpr_debug(\"%s:start\\n\", __func__);\n\n\tif (ps3_compare_firmware_version(1, 6, 0) < 0)\n\t\treturn 0;\n\tif (!card->vlan[GELIC_PORT_WIRELESS].tx)\n\t\treturn 0;\n\n\tnetdev = card->netdev[GELIC_PORT_WIRELESS];\n\twl = port_wl(netdev_priv(netdev));\n\n\t \n\tif (wl->assoc_stat == GELIC_WL_ASSOC_STAT_ASSOCIATED)\n\t\tgelic_wl_disconnect(netdev);\n\n\tcomplete(&wl->cmd_done_intr);\n\n\t \n\tcancel_delayed_work(&wl->assoc_work);\n\tcancel_delayed_work(&wl->event_work);\n\tflush_workqueue(wl->eurus_cmd_queue);\n\tflush_workqueue(wl->event_queue);\n\n\tunregister_netdev(netdev);\n\n\t \n\tpr_debug(\"%s: disable intr\\n\", __func__);\n\tcard->irq_mask &= ~(GELIC_CARD_WLAN_EVENT_RECEIVED |\n\t\t\t    GELIC_CARD_WLAN_COMMAND_COMPLETED);\n\t \n\tgelic_wl_free(wl);\n\tpr_debug(\"%s:end\\n\", __func__);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}