{
  "module_name": "dwc-xlgmac-common.c",
  "hash_id": "5e4dca1bd67b8a5339f1218dff910ba01c3aa3fa276bc1e794db26f6b9df4b62",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/synopsys/dwc-xlgmac-common.c",
  "human_readable_source": " \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n\n#include \"dwc-xlgmac.h\"\n#include \"dwc-xlgmac-reg.h\"\n\nMODULE_LICENSE(\"Dual BSD/GPL\");\n\nstatic int debug = -1;\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug, \"DWC ethernet debug level (0=none,...,16=all)\");\nstatic const u32 default_msg_level = (NETIF_MSG_LINK | NETIF_MSG_IFDOWN |\n\t\t\t\t      NETIF_MSG_IFUP);\n\nstatic unsigned char dev_addr[6] = {0, 0x55, 0x7b, 0xb5, 0x7d, 0xf7};\n\nstatic void xlgmac_read_mac_addr(struct xlgmac_pdata *pdata)\n{\n\tstruct net_device *netdev = pdata->netdev;\n\n\t \n\tmemcpy(pdata->mac_addr, dev_addr, netdev->addr_len);\n}\n\nstatic void xlgmac_default_config(struct xlgmac_pdata *pdata)\n{\n\tpdata->tx_osp_mode = DMA_OSP_ENABLE;\n\tpdata->tx_sf_mode = MTL_TSF_ENABLE;\n\tpdata->rx_sf_mode = MTL_RSF_DISABLE;\n\tpdata->pblx8 = DMA_PBL_X8_ENABLE;\n\tpdata->tx_pbl = DMA_PBL_32;\n\tpdata->rx_pbl = DMA_PBL_32;\n\tpdata->tx_threshold = MTL_TX_THRESHOLD_128;\n\tpdata->rx_threshold = MTL_RX_THRESHOLD_128;\n\tpdata->tx_pause = 1;\n\tpdata->rx_pause = 1;\n\tpdata->phy_speed = SPEED_25000;\n\tpdata->sysclk_rate = XLGMAC_SYSCLOCK;\n\n\tstrscpy(pdata->drv_name, XLGMAC_DRV_NAME, sizeof(pdata->drv_name));\n\tstrscpy(pdata->drv_ver, XLGMAC_DRV_VERSION, sizeof(pdata->drv_ver));\n}\n\nstatic void xlgmac_init_all_ops(struct xlgmac_pdata *pdata)\n{\n\txlgmac_init_desc_ops(&pdata->desc_ops);\n\txlgmac_init_hw_ops(&pdata->hw_ops);\n}\n\nstatic int xlgmac_init(struct xlgmac_pdata *pdata)\n{\n\tstruct xlgmac_hw_ops *hw_ops = &pdata->hw_ops;\n\tstruct net_device *netdev = pdata->netdev;\n\tunsigned int i;\n\tint ret;\n\n\t \n\txlgmac_default_config(pdata);\n\n\t \n\tnetdev->irq = pdata->dev_irq;\n\tnetdev->base_addr = (unsigned long)pdata->mac_regs;\n\txlgmac_read_mac_addr(pdata);\n\teth_hw_addr_set(netdev, pdata->mac_addr);\n\n\t \n\txlgmac_init_all_ops(pdata);\n\n\t \n\thw_ops->exit(pdata);\n\n\t \n\txlgmac_get_all_hw_features(pdata);\n\txlgmac_print_all_hw_features(pdata);\n\n\t \n\n\t \n\tret = dma_set_mask_and_coherent(pdata->dev,\n\t\t\t\t\tDMA_BIT_MASK(pdata->hw_feat.dma_width));\n\tif (ret) {\n\t\tdev_err(pdata->dev, \"dma_set_mask_and_coherent failed\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tBUILD_BUG_ON_NOT_POWER_OF_2(XLGMAC_TX_DESC_CNT);\n\tpdata->tx_desc_count = XLGMAC_TX_DESC_CNT;\n\tif (pdata->tx_desc_count & (pdata->tx_desc_count - 1)) {\n\t\tdev_err(pdata->dev, \"tx descriptor count (%d) is not valid\\n\",\n\t\t\tpdata->tx_desc_count);\n\t\tret = -EINVAL;\n\t\treturn ret;\n\t}\n\tBUILD_BUG_ON_NOT_POWER_OF_2(XLGMAC_RX_DESC_CNT);\n\tpdata->rx_desc_count = XLGMAC_RX_DESC_CNT;\n\tif (pdata->rx_desc_count & (pdata->rx_desc_count - 1)) {\n\t\tdev_err(pdata->dev, \"rx descriptor count (%d) is not valid\\n\",\n\t\t\tpdata->rx_desc_count);\n\t\tret = -EINVAL;\n\t\treturn ret;\n\t}\n\n\tpdata->tx_ring_count = min_t(unsigned int, num_online_cpus(),\n\t\t\t\t     pdata->hw_feat.tx_ch_cnt);\n\tpdata->tx_ring_count = min_t(unsigned int, pdata->tx_ring_count,\n\t\t\t\t     pdata->hw_feat.tx_q_cnt);\n\tpdata->tx_q_count = pdata->tx_ring_count;\n\tret = netif_set_real_num_tx_queues(netdev, pdata->tx_q_count);\n\tif (ret) {\n\t\tdev_err(pdata->dev, \"error setting real tx queue count\\n\");\n\t\treturn ret;\n\t}\n\n\tpdata->rx_ring_count = min_t(unsigned int,\n\t\t\t\t     netif_get_num_default_rss_queues(),\n\t\t\t\t     pdata->hw_feat.rx_ch_cnt);\n\tpdata->rx_ring_count = min_t(unsigned int, pdata->rx_ring_count,\n\t\t\t\t     pdata->hw_feat.rx_q_cnt);\n\tpdata->rx_q_count = pdata->rx_ring_count;\n\tret = netif_set_real_num_rx_queues(netdev, pdata->rx_q_count);\n\tif (ret) {\n\t\tdev_err(pdata->dev, \"error setting real rx queue count\\n\");\n\t\treturn ret;\n\t}\n\n\tpdata->channel_count =\n\t\tmax_t(unsigned int, pdata->tx_ring_count, pdata->rx_ring_count);\n\n\t \n\tnetdev_rss_key_fill(pdata->rss_key, sizeof(pdata->rss_key));\n\n\tfor (i = 0; i < XLGMAC_RSS_MAX_TABLE_SIZE; i++)\n\t\tpdata->rss_table[i] = XLGMAC_SET_REG_BITS(\n\t\t\t\t\tpdata->rss_table[i],\n\t\t\t\t\tMAC_RSSDR_DMCH_POS,\n\t\t\t\t\tMAC_RSSDR_DMCH_LEN,\n\t\t\t\t\ti % pdata->rx_ring_count);\n\n\tpdata->rss_options = XLGMAC_SET_REG_BITS(\n\t\t\t\tpdata->rss_options,\n\t\t\t\tMAC_RSSCR_IP2TE_POS,\n\t\t\t\tMAC_RSSCR_IP2TE_LEN, 1);\n\tpdata->rss_options = XLGMAC_SET_REG_BITS(\n\t\t\t\tpdata->rss_options,\n\t\t\t\tMAC_RSSCR_TCP4TE_POS,\n\t\t\t\tMAC_RSSCR_TCP4TE_LEN, 1);\n\tpdata->rss_options = XLGMAC_SET_REG_BITS(\n\t\t\t\tpdata->rss_options,\n\t\t\t\tMAC_RSSCR_UDP4TE_POS,\n\t\t\t\tMAC_RSSCR_UDP4TE_LEN, 1);\n\n\t \n\tnetdev->netdev_ops = xlgmac_get_netdev_ops();\n\tnetdev->ethtool_ops = xlgmac_get_ethtool_ops();\n\n\t \n\tif (pdata->hw_feat.tso) {\n\t\tnetdev->hw_features = NETIF_F_TSO;\n\t\tnetdev->hw_features |= NETIF_F_TSO6;\n\t\tnetdev->hw_features |= NETIF_F_SG;\n\t\tnetdev->hw_features |= NETIF_F_IP_CSUM;\n\t\tnetdev->hw_features |= NETIF_F_IPV6_CSUM;\n\t} else if (pdata->hw_feat.tx_coe) {\n\t\tnetdev->hw_features = NETIF_F_IP_CSUM;\n\t\tnetdev->hw_features |= NETIF_F_IPV6_CSUM;\n\t}\n\n\tif (pdata->hw_feat.rx_coe) {\n\t\tnetdev->hw_features |= NETIF_F_RXCSUM;\n\t\tnetdev->hw_features |= NETIF_F_GRO;\n\t}\n\n\tif (pdata->hw_feat.rss)\n\t\tnetdev->hw_features |= NETIF_F_RXHASH;\n\n\tnetdev->vlan_features |= netdev->hw_features;\n\n\tnetdev->hw_features |= NETIF_F_HW_VLAN_CTAG_RX;\n\tif (pdata->hw_feat.sa_vlan_ins)\n\t\tnetdev->hw_features |= NETIF_F_HW_VLAN_CTAG_TX;\n\tif (pdata->hw_feat.vlhash)\n\t\tnetdev->hw_features |= NETIF_F_HW_VLAN_CTAG_FILTER;\n\n\tnetdev->features |= netdev->hw_features;\n\tpdata->netdev_features = netdev->features;\n\n\tnetdev->priv_flags |= IFF_UNICAST_FLT;\n\n\t \n\tnetdev->watchdog_timeo = 0;\n\n\t \n\tpdata->tx_usecs = XLGMAC_INIT_DMA_TX_USECS;\n\tpdata->tx_frames = XLGMAC_INIT_DMA_TX_FRAMES;\n\n\t \n\tpdata->rx_riwt = hw_ops->usec_to_riwt(pdata, XLGMAC_INIT_DMA_RX_USECS);\n\tpdata->rx_usecs = XLGMAC_INIT_DMA_RX_USECS;\n\tpdata->rx_frames = XLGMAC_INIT_DMA_RX_FRAMES;\n\n\treturn 0;\n}\n\nint xlgmac_drv_probe(struct device *dev, struct xlgmac_resources *res)\n{\n\tstruct xlgmac_pdata *pdata;\n\tstruct net_device *netdev;\n\tint ret;\n\n\tnetdev = alloc_etherdev_mq(sizeof(struct xlgmac_pdata),\n\t\t\t\t   XLGMAC_MAX_DMA_CHANNELS);\n\n\tif (!netdev) {\n\t\tdev_err(dev, \"alloc_etherdev failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tSET_NETDEV_DEV(netdev, dev);\n\tdev_set_drvdata(dev, netdev);\n\tpdata = netdev_priv(netdev);\n\tpdata->dev = dev;\n\tpdata->netdev = netdev;\n\n\tpdata->dev_irq = res->irq;\n\tpdata->mac_regs = res->addr;\n\n\tmutex_init(&pdata->rss_mutex);\n\tpdata->msg_enable = netif_msg_init(debug, default_msg_level);\n\n\tret = xlgmac_init(pdata);\n\tif (ret) {\n\t\tdev_err(dev, \"xlgmac init failed\\n\");\n\t\tgoto err_free_netdev;\n\t}\n\n\tret = register_netdev(netdev);\n\tif (ret) {\n\t\tdev_err(dev, \"net device registration failed\\n\");\n\t\tgoto err_free_netdev;\n\t}\n\n\treturn 0;\n\nerr_free_netdev:\n\tfree_netdev(netdev);\n\n\treturn ret;\n}\n\nint xlgmac_drv_remove(struct device *dev)\n{\n\tstruct net_device *netdev = dev_get_drvdata(dev);\n\n\tunregister_netdev(netdev);\n\tfree_netdev(netdev);\n\n\treturn 0;\n}\n\nvoid xlgmac_dump_tx_desc(struct xlgmac_pdata *pdata,\n\t\t\t struct xlgmac_ring *ring,\n\t\t\t unsigned int idx,\n\t\t\t unsigned int count,\n\t\t\t unsigned int flag)\n{\n\tstruct xlgmac_desc_data *desc_data;\n\tstruct xlgmac_dma_desc *dma_desc;\n\n\twhile (count--) {\n\t\tdesc_data = XLGMAC_GET_DESC_DATA(ring, idx);\n\t\tdma_desc = desc_data->dma_desc;\n\n\t\tnetdev_dbg(pdata->netdev, \"TX: dma_desc=%p, dma_desc_addr=%pad\\n\",\n\t\t\t   desc_data->dma_desc, &desc_data->dma_desc_addr);\n\t\tnetdev_dbg(pdata->netdev,\n\t\t\t   \"TX_NORMAL_DESC[%d %s] = %08x:%08x:%08x:%08x\\n\", idx,\n\t\t\t   (flag == 1) ? \"QUEUED FOR TX\" : \"TX BY DEVICE\",\n\t\t\t   le32_to_cpu(dma_desc->desc0),\n\t\t\t   le32_to_cpu(dma_desc->desc1),\n\t\t\t   le32_to_cpu(dma_desc->desc2),\n\t\t\t   le32_to_cpu(dma_desc->desc3));\n\n\t\tidx++;\n\t}\n}\n\nvoid xlgmac_dump_rx_desc(struct xlgmac_pdata *pdata,\n\t\t\t struct xlgmac_ring *ring,\n\t\t\t unsigned int idx)\n{\n\tstruct xlgmac_desc_data *desc_data;\n\tstruct xlgmac_dma_desc *dma_desc;\n\n\tdesc_data = XLGMAC_GET_DESC_DATA(ring, idx);\n\tdma_desc = desc_data->dma_desc;\n\n\tnetdev_dbg(pdata->netdev, \"RX: dma_desc=%p, dma_desc_addr=%pad\\n\",\n\t\t   desc_data->dma_desc, &desc_data->dma_desc_addr);\n\tnetdev_dbg(pdata->netdev,\n\t\t   \"RX_NORMAL_DESC[%d RX BY DEVICE] = %08x:%08x:%08x:%08x\\n\",\n\t\t   idx,\n\t\t   le32_to_cpu(dma_desc->desc0),\n\t\t   le32_to_cpu(dma_desc->desc1),\n\t\t   le32_to_cpu(dma_desc->desc2),\n\t\t   le32_to_cpu(dma_desc->desc3));\n}\n\nvoid xlgmac_print_pkt(struct net_device *netdev,\n\t\t      struct sk_buff *skb, bool tx_rx)\n{\n\tstruct ethhdr *eth = (struct ethhdr *)skb->data;\n\tunsigned char buffer[128];\n\tunsigned int i;\n\n\tnetdev_dbg(netdev, \"\\n************** SKB dump ****************\\n\");\n\n\tnetdev_dbg(netdev, \"%s packet of %d bytes\\n\",\n\t\t   (tx_rx ? \"TX\" : \"RX\"), skb->len);\n\n\tnetdev_dbg(netdev, \"Dst MAC addr: %pM\\n\", eth->h_dest);\n\tnetdev_dbg(netdev, \"Src MAC addr: %pM\\n\", eth->h_source);\n\tnetdev_dbg(netdev, \"Protocol: %#06hx\\n\", ntohs(eth->h_proto));\n\n\tfor (i = 0; i < skb->len; i += 32) {\n\t\tunsigned int len = min(skb->len - i, 32U);\n\n\t\thex_dump_to_buffer(&skb->data[i], len, 32, 1,\n\t\t\t\t   buffer, sizeof(buffer), false);\n\t\tnetdev_dbg(netdev, \"  %#06x: %s\\n\", i, buffer);\n\t}\n\n\tnetdev_dbg(netdev, \"\\n************** SKB dump ****************\\n\");\n}\n\nvoid xlgmac_get_all_hw_features(struct xlgmac_pdata *pdata)\n{\n\tstruct xlgmac_hw_features *hw_feat = &pdata->hw_feat;\n\tunsigned int mac_hfr0, mac_hfr1, mac_hfr2;\n\n\tmac_hfr0 = readl(pdata->mac_regs + MAC_HWF0R);\n\tmac_hfr1 = readl(pdata->mac_regs + MAC_HWF1R);\n\tmac_hfr2 = readl(pdata->mac_regs + MAC_HWF2R);\n\n\tmemset(hw_feat, 0, sizeof(*hw_feat));\n\n\thw_feat->version = readl(pdata->mac_regs + MAC_VR);\n\n\t \n\thw_feat->phyifsel    = XLGMAC_GET_REG_BITS(mac_hfr0,\n\t\t\t\t\t\tMAC_HWF0R_PHYIFSEL_POS,\n\t\t\t\t\t\tMAC_HWF0R_PHYIFSEL_LEN);\n\thw_feat->vlhash      = XLGMAC_GET_REG_BITS(mac_hfr0,\n\t\t\t\t\t\tMAC_HWF0R_VLHASH_POS,\n\t\t\t\t\t\tMAC_HWF0R_VLHASH_LEN);\n\thw_feat->sma         = XLGMAC_GET_REG_BITS(mac_hfr0,\n\t\t\t\t\t\tMAC_HWF0R_SMASEL_POS,\n\t\t\t\t\t\tMAC_HWF0R_SMASEL_LEN);\n\thw_feat->rwk         = XLGMAC_GET_REG_BITS(mac_hfr0,\n\t\t\t\t\t\tMAC_HWF0R_RWKSEL_POS,\n\t\t\t\t\t\tMAC_HWF0R_RWKSEL_LEN);\n\thw_feat->mgk         = XLGMAC_GET_REG_BITS(mac_hfr0,\n\t\t\t\t\t\tMAC_HWF0R_MGKSEL_POS,\n\t\t\t\t\t\tMAC_HWF0R_MGKSEL_LEN);\n\thw_feat->mmc         = XLGMAC_GET_REG_BITS(mac_hfr0,\n\t\t\t\t\t\tMAC_HWF0R_MMCSEL_POS,\n\t\t\t\t\t\tMAC_HWF0R_MMCSEL_LEN);\n\thw_feat->aoe         = XLGMAC_GET_REG_BITS(mac_hfr0,\n\t\t\t\t\t\tMAC_HWF0R_ARPOFFSEL_POS,\n\t\t\t\t\t\tMAC_HWF0R_ARPOFFSEL_LEN);\n\thw_feat->ts          = XLGMAC_GET_REG_BITS(mac_hfr0,\n\t\t\t\t\t\tMAC_HWF0R_TSSEL_POS,\n\t\t\t\t\t\tMAC_HWF0R_TSSEL_LEN);\n\thw_feat->eee         = XLGMAC_GET_REG_BITS(mac_hfr0,\n\t\t\t\t\t\tMAC_HWF0R_EEESEL_POS,\n\t\t\t\t\t\tMAC_HWF0R_EEESEL_LEN);\n\thw_feat->tx_coe      = XLGMAC_GET_REG_BITS(mac_hfr0,\n\t\t\t\t\t\tMAC_HWF0R_TXCOESEL_POS,\n\t\t\t\t\t\tMAC_HWF0R_TXCOESEL_LEN);\n\thw_feat->rx_coe      = XLGMAC_GET_REG_BITS(mac_hfr0,\n\t\t\t\t\t\tMAC_HWF0R_RXCOESEL_POS,\n\t\t\t\t\t\tMAC_HWF0R_RXCOESEL_LEN);\n\thw_feat->addn_mac    = XLGMAC_GET_REG_BITS(mac_hfr0,\n\t\t\t\t\t\tMAC_HWF0R_ADDMACADRSEL_POS,\n\t\t\t\t\t\tMAC_HWF0R_ADDMACADRSEL_LEN);\n\thw_feat->ts_src      = XLGMAC_GET_REG_BITS(mac_hfr0,\n\t\t\t\t\t\tMAC_HWF0R_TSSTSSEL_POS,\n\t\t\t\t\t\tMAC_HWF0R_TSSTSSEL_LEN);\n\thw_feat->sa_vlan_ins = XLGMAC_GET_REG_BITS(mac_hfr0,\n\t\t\t\t\t\tMAC_HWF0R_SAVLANINS_POS,\n\t\t\t\t\t\tMAC_HWF0R_SAVLANINS_LEN);\n\n\t \n\thw_feat->rx_fifo_size  = XLGMAC_GET_REG_BITS(mac_hfr1,\n\t\t\t\t\t\tMAC_HWF1R_RXFIFOSIZE_POS,\n\t\t\t\t\t\tMAC_HWF1R_RXFIFOSIZE_LEN);\n\thw_feat->tx_fifo_size  = XLGMAC_GET_REG_BITS(mac_hfr1,\n\t\t\t\t\t\tMAC_HWF1R_TXFIFOSIZE_POS,\n\t\t\t\t\t\tMAC_HWF1R_TXFIFOSIZE_LEN);\n\thw_feat->adv_ts_hi     = XLGMAC_GET_REG_BITS(mac_hfr1,\n\t\t\t\t\t\tMAC_HWF1R_ADVTHWORD_POS,\n\t\t\t\t\t\tMAC_HWF1R_ADVTHWORD_LEN);\n\thw_feat->dma_width     = XLGMAC_GET_REG_BITS(mac_hfr1,\n\t\t\t\t\t\tMAC_HWF1R_ADDR64_POS,\n\t\t\t\t\t\tMAC_HWF1R_ADDR64_LEN);\n\thw_feat->dcb           = XLGMAC_GET_REG_BITS(mac_hfr1,\n\t\t\t\t\t\tMAC_HWF1R_DCBEN_POS,\n\t\t\t\t\t\tMAC_HWF1R_DCBEN_LEN);\n\thw_feat->sph           = XLGMAC_GET_REG_BITS(mac_hfr1,\n\t\t\t\t\t\tMAC_HWF1R_SPHEN_POS,\n\t\t\t\t\t\tMAC_HWF1R_SPHEN_LEN);\n\thw_feat->tso           = XLGMAC_GET_REG_BITS(mac_hfr1,\n\t\t\t\t\t\tMAC_HWF1R_TSOEN_POS,\n\t\t\t\t\t\tMAC_HWF1R_TSOEN_LEN);\n\thw_feat->dma_debug     = XLGMAC_GET_REG_BITS(mac_hfr1,\n\t\t\t\t\t\tMAC_HWF1R_DBGMEMA_POS,\n\t\t\t\t\t\tMAC_HWF1R_DBGMEMA_LEN);\n\thw_feat->rss           = XLGMAC_GET_REG_BITS(mac_hfr1,\n\t\t\t\t\t\tMAC_HWF1R_RSSEN_POS,\n\t\t\t\t\t\tMAC_HWF1R_RSSEN_LEN);\n\thw_feat->tc_cnt\t       = XLGMAC_GET_REG_BITS(mac_hfr1,\n\t\t\t\t\t\tMAC_HWF1R_NUMTC_POS,\n\t\t\t\t\t\tMAC_HWF1R_NUMTC_LEN);\n\thw_feat->hash_table_size = XLGMAC_GET_REG_BITS(mac_hfr1,\n\t\t\t\t\t\tMAC_HWF1R_HASHTBLSZ_POS,\n\t\t\t\t\t\tMAC_HWF1R_HASHTBLSZ_LEN);\n\thw_feat->l3l4_filter_num = XLGMAC_GET_REG_BITS(mac_hfr1,\n\t\t\t\t\t\tMAC_HWF1R_L3L4FNUM_POS,\n\t\t\t\t\t\tMAC_HWF1R_L3L4FNUM_LEN);\n\n\t \n\thw_feat->rx_q_cnt     = XLGMAC_GET_REG_BITS(mac_hfr2,\n\t\t\t\t\t\tMAC_HWF2R_RXQCNT_POS,\n\t\t\t\t\t\tMAC_HWF2R_RXQCNT_LEN);\n\thw_feat->tx_q_cnt     = XLGMAC_GET_REG_BITS(mac_hfr2,\n\t\t\t\t\t\tMAC_HWF2R_TXQCNT_POS,\n\t\t\t\t\t\tMAC_HWF2R_TXQCNT_LEN);\n\thw_feat->rx_ch_cnt    = XLGMAC_GET_REG_BITS(mac_hfr2,\n\t\t\t\t\t\tMAC_HWF2R_RXCHCNT_POS,\n\t\t\t\t\t\tMAC_HWF2R_RXCHCNT_LEN);\n\thw_feat->tx_ch_cnt    = XLGMAC_GET_REG_BITS(mac_hfr2,\n\t\t\t\t\t\tMAC_HWF2R_TXCHCNT_POS,\n\t\t\t\t\t\tMAC_HWF2R_TXCHCNT_LEN);\n\thw_feat->pps_out_num  = XLGMAC_GET_REG_BITS(mac_hfr2,\n\t\t\t\t\t\tMAC_HWF2R_PPSOUTNUM_POS,\n\t\t\t\t\t\tMAC_HWF2R_PPSOUTNUM_LEN);\n\thw_feat->aux_snap_num = XLGMAC_GET_REG_BITS(mac_hfr2,\n\t\t\t\t\t\tMAC_HWF2R_AUXSNAPNUM_POS,\n\t\t\t\t\t\tMAC_HWF2R_AUXSNAPNUM_LEN);\n\n\t \n\tswitch (hw_feat->hash_table_size) {\n\tcase 0:\n\t\tbreak;\n\tcase 1:\n\t\thw_feat->hash_table_size = 64;\n\t\tbreak;\n\tcase 2:\n\t\thw_feat->hash_table_size = 128;\n\t\tbreak;\n\tcase 3:\n\t\thw_feat->hash_table_size = 256;\n\t\tbreak;\n\t}\n\n\t \n\tswitch (hw_feat->dma_width) {\n\tcase 0:\n\t\thw_feat->dma_width = 32;\n\t\tbreak;\n\tcase 1:\n\t\thw_feat->dma_width = 40;\n\t\tbreak;\n\tcase 2:\n\t\thw_feat->dma_width = 48;\n\t\tbreak;\n\tdefault:\n\t\thw_feat->dma_width = 32;\n\t}\n\n\t \n\thw_feat->rx_q_cnt++;\n\thw_feat->tx_q_cnt++;\n\thw_feat->rx_ch_cnt++;\n\thw_feat->tx_ch_cnt++;\n\thw_feat->tc_cnt++;\n}\n\nvoid xlgmac_print_all_hw_features(struct xlgmac_pdata *pdata)\n{\n\tchar __maybe_unused *str = NULL;\n\n\tXLGMAC_PR(\"\\n\");\n\tXLGMAC_PR(\"=====================================================\\n\");\n\tXLGMAC_PR(\"\\n\");\n\tXLGMAC_PR(\"HW support following features\\n\");\n\tXLGMAC_PR(\"\\n\");\n\t \n\tXLGMAC_PR(\"VLAN Hash Filter Selected                   : %s\\n\",\n\t\t  pdata->hw_feat.vlhash ? \"YES\" : \"NO\");\n\tXLGMAC_PR(\"SMA (MDIO) Interface                        : %s\\n\",\n\t\t  pdata->hw_feat.sma ? \"YES\" : \"NO\");\n\tXLGMAC_PR(\"PMT Remote Wake-up Packet Enable            : %s\\n\",\n\t\t  pdata->hw_feat.rwk ? \"YES\" : \"NO\");\n\tXLGMAC_PR(\"PMT Magic Packet Enable                     : %s\\n\",\n\t\t  pdata->hw_feat.mgk ? \"YES\" : \"NO\");\n\tXLGMAC_PR(\"RMON/MMC Module Enable                      : %s\\n\",\n\t\t  pdata->hw_feat.mmc ? \"YES\" : \"NO\");\n\tXLGMAC_PR(\"ARP Offload Enabled                         : %s\\n\",\n\t\t  pdata->hw_feat.aoe ? \"YES\" : \"NO\");\n\tXLGMAC_PR(\"IEEE 1588-2008 Timestamp Enabled            : %s\\n\",\n\t\t  pdata->hw_feat.ts ? \"YES\" : \"NO\");\n\tXLGMAC_PR(\"Energy Efficient Ethernet Enabled           : %s\\n\",\n\t\t  pdata->hw_feat.eee ? \"YES\" : \"NO\");\n\tXLGMAC_PR(\"Transmit Checksum Offload Enabled           : %s\\n\",\n\t\t  pdata->hw_feat.tx_coe ? \"YES\" : \"NO\");\n\tXLGMAC_PR(\"Receive Checksum Offload Enabled            : %s\\n\",\n\t\t  pdata->hw_feat.rx_coe ? \"YES\" : \"NO\");\n\tXLGMAC_PR(\"Additional MAC Addresses 1-31 Selected      : %s\\n\",\n\t\t  pdata->hw_feat.addn_mac ? \"YES\" : \"NO\");\n\n\tswitch (pdata->hw_feat.ts_src) {\n\tcase 0:\n\t\tstr = \"RESERVED\";\n\t\tbreak;\n\tcase 1:\n\t\tstr = \"INTERNAL\";\n\t\tbreak;\n\tcase 2:\n\t\tstr = \"EXTERNAL\";\n\t\tbreak;\n\tcase 3:\n\t\tstr = \"BOTH\";\n\t\tbreak;\n\t}\n\tXLGMAC_PR(\"Timestamp System Time Source                : %s\\n\", str);\n\n\tXLGMAC_PR(\"Source Address or VLAN Insertion Enable     : %s\\n\",\n\t\t  pdata->hw_feat.sa_vlan_ins ? \"YES\" : \"NO\");\n\n\t \n\tswitch (pdata->hw_feat.rx_fifo_size) {\n\tcase 0:\n\t\tstr = \"128 bytes\";\n\t\tbreak;\n\tcase 1:\n\t\tstr = \"256 bytes\";\n\t\tbreak;\n\tcase 2:\n\t\tstr = \"512 bytes\";\n\t\tbreak;\n\tcase 3:\n\t\tstr = \"1 KBytes\";\n\t\tbreak;\n\tcase 4:\n\t\tstr = \"2 KBytes\";\n\t\tbreak;\n\tcase 5:\n\t\tstr = \"4 KBytes\";\n\t\tbreak;\n\tcase 6:\n\t\tstr = \"8 KBytes\";\n\t\tbreak;\n\tcase 7:\n\t\tstr = \"16 KBytes\";\n\t\tbreak;\n\tcase 8:\n\t\tstr = \"32 kBytes\";\n\t\tbreak;\n\tcase 9:\n\t\tstr = \"64 KBytes\";\n\t\tbreak;\n\tcase 10:\n\t\tstr = \"128 KBytes\";\n\t\tbreak;\n\tcase 11:\n\t\tstr = \"256 KBytes\";\n\t\tbreak;\n\tdefault:\n\t\tstr = \"RESERVED\";\n\t}\n\tXLGMAC_PR(\"MTL Receive FIFO Size                       : %s\\n\", str);\n\n\tswitch (pdata->hw_feat.tx_fifo_size) {\n\tcase 0:\n\t\tstr = \"128 bytes\";\n\t\tbreak;\n\tcase 1:\n\t\tstr = \"256 bytes\";\n\t\tbreak;\n\tcase 2:\n\t\tstr = \"512 bytes\";\n\t\tbreak;\n\tcase 3:\n\t\tstr = \"1 KBytes\";\n\t\tbreak;\n\tcase 4:\n\t\tstr = \"2 KBytes\";\n\t\tbreak;\n\tcase 5:\n\t\tstr = \"4 KBytes\";\n\t\tbreak;\n\tcase 6:\n\t\tstr = \"8 KBytes\";\n\t\tbreak;\n\tcase 7:\n\t\tstr = \"16 KBytes\";\n\t\tbreak;\n\tcase 8:\n\t\tstr = \"32 kBytes\";\n\t\tbreak;\n\tcase 9:\n\t\tstr = \"64 KBytes\";\n\t\tbreak;\n\tcase 10:\n\t\tstr = \"128 KBytes\";\n\t\tbreak;\n\tcase 11:\n\t\tstr = \"256 KBytes\";\n\t\tbreak;\n\tdefault:\n\t\tstr = \"RESERVED\";\n\t}\n\tXLGMAC_PR(\"MTL Transmit FIFO Size                      : %s\\n\", str);\n\n\tXLGMAC_PR(\"IEEE 1588 High Word Register Enable         : %s\\n\",\n\t\t  pdata->hw_feat.adv_ts_hi ? \"YES\" : \"NO\");\n\tXLGMAC_PR(\"Address width                               : %u\\n\",\n\t\t  pdata->hw_feat.dma_width);\n\tXLGMAC_PR(\"DCB Feature Enable                          : %s\\n\",\n\t\t  pdata->hw_feat.dcb ? \"YES\" : \"NO\");\n\tXLGMAC_PR(\"Split Header Feature Enable                 : %s\\n\",\n\t\t  pdata->hw_feat.sph ? \"YES\" : \"NO\");\n\tXLGMAC_PR(\"TCP Segmentation Offload Enable             : %s\\n\",\n\t\t  pdata->hw_feat.tso ? \"YES\" : \"NO\");\n\tXLGMAC_PR(\"DMA Debug Registers Enabled                 : %s\\n\",\n\t\t  pdata->hw_feat.dma_debug ? \"YES\" : \"NO\");\n\tXLGMAC_PR(\"RSS Feature Enabled                         : %s\\n\",\n\t\t  pdata->hw_feat.rss ? \"YES\" : \"NO\");\n\tXLGMAC_PR(\"Number of Traffic classes                   : %u\\n\",\n\t\t  (pdata->hw_feat.tc_cnt));\n\tXLGMAC_PR(\"Hash Table Size                             : %u\\n\",\n\t\t  pdata->hw_feat.hash_table_size);\n\tXLGMAC_PR(\"Total number of L3 or L4 Filters            : %u\\n\",\n\t\t  pdata->hw_feat.l3l4_filter_num);\n\n\t \n\tXLGMAC_PR(\"Number of MTL Receive Queues                : %u\\n\",\n\t\t  pdata->hw_feat.rx_q_cnt);\n\tXLGMAC_PR(\"Number of MTL Transmit Queues               : %u\\n\",\n\t\t  pdata->hw_feat.tx_q_cnt);\n\tXLGMAC_PR(\"Number of DMA Receive Channels              : %u\\n\",\n\t\t  pdata->hw_feat.rx_ch_cnt);\n\tXLGMAC_PR(\"Number of DMA Transmit Channels             : %u\\n\",\n\t\t  pdata->hw_feat.tx_ch_cnt);\n\n\tswitch (pdata->hw_feat.pps_out_num) {\n\tcase 0:\n\t\tstr = \"No PPS output\";\n\t\tbreak;\n\tcase 1:\n\t\tstr = \"1 PPS output\";\n\t\tbreak;\n\tcase 2:\n\t\tstr = \"2 PPS output\";\n\t\tbreak;\n\tcase 3:\n\t\tstr = \"3 PPS output\";\n\t\tbreak;\n\tcase 4:\n\t\tstr = \"4 PPS output\";\n\t\tbreak;\n\tdefault:\n\t\tstr = \"RESERVED\";\n\t}\n\tXLGMAC_PR(\"Number of PPS Outputs                       : %s\\n\", str);\n\n\tswitch (pdata->hw_feat.aux_snap_num) {\n\tcase 0:\n\t\tstr = \"No auxiliary input\";\n\t\tbreak;\n\tcase 1:\n\t\tstr = \"1 auxiliary input\";\n\t\tbreak;\n\tcase 2:\n\t\tstr = \"2 auxiliary input\";\n\t\tbreak;\n\tcase 3:\n\t\tstr = \"3 auxiliary input\";\n\t\tbreak;\n\tcase 4:\n\t\tstr = \"4 auxiliary input\";\n\t\tbreak;\n\tdefault:\n\t\tstr = \"RESERVED\";\n\t}\n\tXLGMAC_PR(\"Number of Auxiliary Snapshot Inputs         : %s\", str);\n\n\tXLGMAC_PR(\"\\n\");\n\tXLGMAC_PR(\"=====================================================\\n\");\n\tXLGMAC_PR(\"\\n\");\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}