{
  "module_name": "dwc-xlgmac-desc.c",
  "hash_id": "7a8815f6416542faeed86899dca623b33232d2a6ee4004ba04cee279c0863f88",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/synopsys/dwc-xlgmac-desc.c",
  "human_readable_source": " \n\n#include \"dwc-xlgmac.h\"\n#include \"dwc-xlgmac-reg.h\"\n\nstatic void xlgmac_unmap_desc_data(struct xlgmac_pdata *pdata,\n\t\t\t\t   struct xlgmac_desc_data *desc_data)\n{\n\tif (desc_data->skb_dma) {\n\t\tif (desc_data->mapped_as_page) {\n\t\t\tdma_unmap_page(pdata->dev, desc_data->skb_dma,\n\t\t\t\t       desc_data->skb_dma_len, DMA_TO_DEVICE);\n\t\t} else {\n\t\t\tdma_unmap_single(pdata->dev, desc_data->skb_dma,\n\t\t\t\t\t desc_data->skb_dma_len, DMA_TO_DEVICE);\n\t\t}\n\t\tdesc_data->skb_dma = 0;\n\t\tdesc_data->skb_dma_len = 0;\n\t}\n\n\tif (desc_data->skb) {\n\t\tdev_kfree_skb_any(desc_data->skb);\n\t\tdesc_data->skb = NULL;\n\t}\n\n\tif (desc_data->rx.hdr.pa.pages)\n\t\tput_page(desc_data->rx.hdr.pa.pages);\n\n\tif (desc_data->rx.hdr.pa_unmap.pages) {\n\t\tdma_unmap_page(pdata->dev, desc_data->rx.hdr.pa_unmap.pages_dma,\n\t\t\t       desc_data->rx.hdr.pa_unmap.pages_len,\n\t\t\t       DMA_FROM_DEVICE);\n\t\tput_page(desc_data->rx.hdr.pa_unmap.pages);\n\t}\n\n\tif (desc_data->rx.buf.pa.pages)\n\t\tput_page(desc_data->rx.buf.pa.pages);\n\n\tif (desc_data->rx.buf.pa_unmap.pages) {\n\t\tdma_unmap_page(pdata->dev, desc_data->rx.buf.pa_unmap.pages_dma,\n\t\t\t       desc_data->rx.buf.pa_unmap.pages_len,\n\t\t\t       DMA_FROM_DEVICE);\n\t\tput_page(desc_data->rx.buf.pa_unmap.pages);\n\t}\n\n\tmemset(&desc_data->tx, 0, sizeof(desc_data->tx));\n\tmemset(&desc_data->rx, 0, sizeof(desc_data->rx));\n\n\tdesc_data->mapped_as_page = 0;\n\n\tif (desc_data->state_saved) {\n\t\tdesc_data->state_saved = 0;\n\t\tdesc_data->state.skb = NULL;\n\t\tdesc_data->state.len = 0;\n\t\tdesc_data->state.error = 0;\n\t}\n}\n\nstatic void xlgmac_free_ring(struct xlgmac_pdata *pdata,\n\t\t\t     struct xlgmac_ring *ring)\n{\n\tstruct xlgmac_desc_data *desc_data;\n\tunsigned int i;\n\n\tif (!ring)\n\t\treturn;\n\n\tif (ring->desc_data_head) {\n\t\tfor (i = 0; i < ring->dma_desc_count; i++) {\n\t\t\tdesc_data = XLGMAC_GET_DESC_DATA(ring, i);\n\t\t\txlgmac_unmap_desc_data(pdata, desc_data);\n\t\t}\n\n\t\tkfree(ring->desc_data_head);\n\t\tring->desc_data_head = NULL;\n\t}\n\n\tif (ring->rx_hdr_pa.pages) {\n\t\tdma_unmap_page(pdata->dev, ring->rx_hdr_pa.pages_dma,\n\t\t\t       ring->rx_hdr_pa.pages_len, DMA_FROM_DEVICE);\n\t\tput_page(ring->rx_hdr_pa.pages);\n\n\t\tring->rx_hdr_pa.pages = NULL;\n\t\tring->rx_hdr_pa.pages_len = 0;\n\t\tring->rx_hdr_pa.pages_offset = 0;\n\t\tring->rx_hdr_pa.pages_dma = 0;\n\t}\n\n\tif (ring->rx_buf_pa.pages) {\n\t\tdma_unmap_page(pdata->dev, ring->rx_buf_pa.pages_dma,\n\t\t\t       ring->rx_buf_pa.pages_len, DMA_FROM_DEVICE);\n\t\tput_page(ring->rx_buf_pa.pages);\n\n\t\tring->rx_buf_pa.pages = NULL;\n\t\tring->rx_buf_pa.pages_len = 0;\n\t\tring->rx_buf_pa.pages_offset = 0;\n\t\tring->rx_buf_pa.pages_dma = 0;\n\t}\n\n\tif (ring->dma_desc_head) {\n\t\tdma_free_coherent(pdata->dev,\n\t\t\t\t  (sizeof(struct xlgmac_dma_desc) *\n\t\t\t\t  ring->dma_desc_count),\n\t\t\t\t  ring->dma_desc_head,\n\t\t\t\t  ring->dma_desc_head_addr);\n\t\tring->dma_desc_head = NULL;\n\t}\n}\n\nstatic int xlgmac_init_ring(struct xlgmac_pdata *pdata,\n\t\t\t    struct xlgmac_ring *ring,\n\t\t\t    unsigned int dma_desc_count)\n{\n\tif (!ring)\n\t\treturn 0;\n\n\t \n\tring->dma_desc_count = dma_desc_count;\n\tring->dma_desc_head = dma_alloc_coherent(pdata->dev,\n\t\t\t\t\t(sizeof(struct xlgmac_dma_desc) *\n\t\t\t\t\t dma_desc_count),\n\t\t\t\t\t&ring->dma_desc_head_addr,\n\t\t\t\t\tGFP_KERNEL);\n\tif (!ring->dma_desc_head)\n\t\treturn -ENOMEM;\n\n\t \n\tring->desc_data_head = kcalloc(dma_desc_count,\n\t\t\t\t\tsizeof(struct xlgmac_desc_data),\n\t\t\t\t\tGFP_KERNEL);\n\tif (!ring->desc_data_head)\n\t\treturn -ENOMEM;\n\n\tnetif_dbg(pdata, drv, pdata->netdev,\n\t\t  \"dma_desc_head=%p, dma_desc_head_addr=%pad, desc_data_head=%p\\n\",\n\t\tring->dma_desc_head,\n\t\t&ring->dma_desc_head_addr,\n\t\tring->desc_data_head);\n\n\treturn 0;\n}\n\nstatic void xlgmac_free_rings(struct xlgmac_pdata *pdata)\n{\n\tstruct xlgmac_channel *channel;\n\tunsigned int i;\n\n\tif (!pdata->channel_head)\n\t\treturn;\n\n\tchannel = pdata->channel_head;\n\tfor (i = 0; i < pdata->channel_count; i++, channel++) {\n\t\txlgmac_free_ring(pdata, channel->tx_ring);\n\t\txlgmac_free_ring(pdata, channel->rx_ring);\n\t}\n}\n\nstatic int xlgmac_alloc_rings(struct xlgmac_pdata *pdata)\n{\n\tstruct xlgmac_channel *channel;\n\tunsigned int i;\n\tint ret;\n\n\tchannel = pdata->channel_head;\n\tfor (i = 0; i < pdata->channel_count; i++, channel++) {\n\t\tnetif_dbg(pdata, drv, pdata->netdev, \"%s - Tx ring:\\n\",\n\t\t\t  channel->name);\n\n\t\tret = xlgmac_init_ring(pdata, channel->tx_ring,\n\t\t\t\t       pdata->tx_desc_count);\n\n\t\tif (ret) {\n\t\t\tnetdev_alert(pdata->netdev,\n\t\t\t\t     \"error initializing Tx ring\");\n\t\t\tgoto err_init_ring;\n\t\t}\n\n\t\tnetif_dbg(pdata, drv, pdata->netdev, \"%s - Rx ring:\\n\",\n\t\t\t  channel->name);\n\n\t\tret = xlgmac_init_ring(pdata, channel->rx_ring,\n\t\t\t\t       pdata->rx_desc_count);\n\t\tif (ret) {\n\t\t\tnetdev_alert(pdata->netdev,\n\t\t\t\t     \"error initializing Rx ring\\n\");\n\t\t\tgoto err_init_ring;\n\t\t}\n\t}\n\n\treturn 0;\n\nerr_init_ring:\n\txlgmac_free_rings(pdata);\n\n\treturn ret;\n}\n\nstatic void xlgmac_free_channels(struct xlgmac_pdata *pdata)\n{\n\tif (!pdata->channel_head)\n\t\treturn;\n\n\tkfree(pdata->channel_head->tx_ring);\n\tpdata->channel_head->tx_ring = NULL;\n\n\tkfree(pdata->channel_head->rx_ring);\n\tpdata->channel_head->rx_ring = NULL;\n\n\tkfree(pdata->channel_head);\n\n\tpdata->channel_head = NULL;\n\tpdata->channel_count = 0;\n}\n\nstatic int xlgmac_alloc_channels(struct xlgmac_pdata *pdata)\n{\n\tstruct xlgmac_channel *channel_head, *channel;\n\tstruct xlgmac_ring *tx_ring, *rx_ring;\n\tint ret = -ENOMEM;\n\tunsigned int i;\n\n\tchannel_head = kcalloc(pdata->channel_count,\n\t\t\t       sizeof(struct xlgmac_channel), GFP_KERNEL);\n\tif (!channel_head)\n\t\treturn ret;\n\n\tnetif_dbg(pdata, drv, pdata->netdev,\n\t\t  \"channel_head=%p\\n\", channel_head);\n\n\ttx_ring = kcalloc(pdata->tx_ring_count, sizeof(struct xlgmac_ring),\n\t\t\t  GFP_KERNEL);\n\tif (!tx_ring)\n\t\tgoto err_tx_ring;\n\n\trx_ring = kcalloc(pdata->rx_ring_count, sizeof(struct xlgmac_ring),\n\t\t\t  GFP_KERNEL);\n\tif (!rx_ring)\n\t\tgoto err_rx_ring;\n\n\tfor (i = 0, channel = channel_head; i < pdata->channel_count;\n\t\ti++, channel++) {\n\t\tsnprintf(channel->name, sizeof(channel->name), \"channel-%u\", i);\n\t\tchannel->pdata = pdata;\n\t\tchannel->queue_index = i;\n\t\tchannel->dma_regs = pdata->mac_regs + DMA_CH_BASE +\n\t\t\t\t    (DMA_CH_INC * i);\n\n\t\tif (pdata->per_channel_irq) {\n\t\t\t \n\t\t\tret = pdata->channel_irq[i];\n\t\t\tif (ret < 0) {\n\t\t\t\tnetdev_err(pdata->netdev,\n\t\t\t\t\t   \"get_irq %u failed\\n\",\n\t\t\t\t\t   i + 1);\n\t\t\t\tgoto err_irq;\n\t\t\t}\n\t\t\tchannel->dma_irq = ret;\n\t\t}\n\n\t\tif (i < pdata->tx_ring_count)\n\t\t\tchannel->tx_ring = tx_ring++;\n\n\t\tif (i < pdata->rx_ring_count)\n\t\t\tchannel->rx_ring = rx_ring++;\n\n\t\tnetif_dbg(pdata, drv, pdata->netdev,\n\t\t\t  \"%s: dma_regs=%p, tx_ring=%p, rx_ring=%p\\n\",\n\t\t\t  channel->name, channel->dma_regs,\n\t\t\t  channel->tx_ring, channel->rx_ring);\n\t}\n\n\tpdata->channel_head = channel_head;\n\n\treturn 0;\n\nerr_irq:\n\tkfree(rx_ring);\n\nerr_rx_ring:\n\tkfree(tx_ring);\n\nerr_tx_ring:\n\tkfree(channel_head);\n\n\treturn ret;\n}\n\nstatic void xlgmac_free_channels_and_rings(struct xlgmac_pdata *pdata)\n{\n\txlgmac_free_rings(pdata);\n\n\txlgmac_free_channels(pdata);\n}\n\nstatic int xlgmac_alloc_channels_and_rings(struct xlgmac_pdata *pdata)\n{\n\tint ret;\n\n\tret = xlgmac_alloc_channels(pdata);\n\tif (ret)\n\t\tgoto err_alloc;\n\n\tret = xlgmac_alloc_rings(pdata);\n\tif (ret)\n\t\tgoto err_alloc;\n\n\treturn 0;\n\nerr_alloc:\n\txlgmac_free_channels_and_rings(pdata);\n\n\treturn ret;\n}\n\nstatic int xlgmac_alloc_pages(struct xlgmac_pdata *pdata,\n\t\t\t      struct xlgmac_page_alloc *pa,\n\t\t\t      gfp_t gfp, int order)\n{\n\tstruct page *pages = NULL;\n\tdma_addr_t pages_dma;\n\n\t \n\tgfp |= __GFP_COMP | __GFP_NOWARN;\n\twhile (order >= 0) {\n\t\tpages = alloc_pages(gfp, order);\n\t\tif (pages)\n\t\t\tbreak;\n\n\t\torder--;\n\t}\n\tif (!pages)\n\t\treturn -ENOMEM;\n\n\t \n\tpages_dma = dma_map_page(pdata->dev, pages, 0,\n\t\t\t\t PAGE_SIZE << order, DMA_FROM_DEVICE);\n\tif (dma_mapping_error(pdata->dev, pages_dma)) {\n\t\tput_page(pages);\n\t\treturn -ENOMEM;\n\t}\n\n\tpa->pages = pages;\n\tpa->pages_len = PAGE_SIZE << order;\n\tpa->pages_offset = 0;\n\tpa->pages_dma = pages_dma;\n\n\treturn 0;\n}\n\nstatic void xlgmac_set_buffer_data(struct xlgmac_buffer_data *bd,\n\t\t\t\t   struct xlgmac_page_alloc *pa,\n\t\t\t\t   unsigned int len)\n{\n\tget_page(pa->pages);\n\tbd->pa = *pa;\n\n\tbd->dma_base = pa->pages_dma;\n\tbd->dma_off = pa->pages_offset;\n\tbd->dma_len = len;\n\n\tpa->pages_offset += len;\n\tif ((pa->pages_offset + len) > pa->pages_len) {\n\t\t \n\t\tbd->pa_unmap = *pa;\n\n\t\t \n\t\tpa->pages = NULL;\n\t\tpa->pages_len = 0;\n\t\tpa->pages_offset = 0;\n\t\tpa->pages_dma = 0;\n\t}\n}\n\nstatic int xlgmac_map_rx_buffer(struct xlgmac_pdata *pdata,\n\t\t\t\tstruct xlgmac_ring *ring,\n\t\t\t\tstruct xlgmac_desc_data *desc_data)\n{\n\tint order, ret;\n\n\tif (!ring->rx_hdr_pa.pages) {\n\t\tret = xlgmac_alloc_pages(pdata, &ring->rx_hdr_pa,\n\t\t\t\t\t GFP_ATOMIC, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (!ring->rx_buf_pa.pages) {\n\t\torder = max_t(int, PAGE_ALLOC_COSTLY_ORDER - 1, 0);\n\t\tret = xlgmac_alloc_pages(pdata, &ring->rx_buf_pa,\n\t\t\t\t\t GFP_ATOMIC, order);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\txlgmac_set_buffer_data(&desc_data->rx.hdr, &ring->rx_hdr_pa,\n\t\t\t       XLGMAC_SKB_ALLOC_SIZE);\n\n\t \n\txlgmac_set_buffer_data(&desc_data->rx.buf, &ring->rx_buf_pa,\n\t\t\t       pdata->rx_buf_size);\n\n\treturn 0;\n}\n\nstatic void xlgmac_tx_desc_init(struct xlgmac_pdata *pdata)\n{\n\tstruct xlgmac_hw_ops *hw_ops = &pdata->hw_ops;\n\tstruct xlgmac_desc_data *desc_data;\n\tstruct xlgmac_dma_desc *dma_desc;\n\tstruct xlgmac_channel *channel;\n\tstruct xlgmac_ring *ring;\n\tdma_addr_t dma_desc_addr;\n\tunsigned int i, j;\n\n\tchannel = pdata->channel_head;\n\tfor (i = 0; i < pdata->channel_count; i++, channel++) {\n\t\tring = channel->tx_ring;\n\t\tif (!ring)\n\t\t\tbreak;\n\n\t\tdma_desc = ring->dma_desc_head;\n\t\tdma_desc_addr = ring->dma_desc_head_addr;\n\n\t\tfor (j = 0; j < ring->dma_desc_count; j++) {\n\t\t\tdesc_data = XLGMAC_GET_DESC_DATA(ring, j);\n\n\t\t\tdesc_data->dma_desc = dma_desc;\n\t\t\tdesc_data->dma_desc_addr = dma_desc_addr;\n\n\t\t\tdma_desc++;\n\t\t\tdma_desc_addr += sizeof(struct xlgmac_dma_desc);\n\t\t}\n\n\t\tring->cur = 0;\n\t\tring->dirty = 0;\n\t\tmemset(&ring->tx, 0, sizeof(ring->tx));\n\n\t\thw_ops->tx_desc_init(channel);\n\t}\n}\n\nstatic void xlgmac_rx_desc_init(struct xlgmac_pdata *pdata)\n{\n\tstruct xlgmac_hw_ops *hw_ops = &pdata->hw_ops;\n\tstruct xlgmac_desc_data *desc_data;\n\tstruct xlgmac_dma_desc *dma_desc;\n\tstruct xlgmac_channel *channel;\n\tstruct xlgmac_ring *ring;\n\tdma_addr_t dma_desc_addr;\n\tunsigned int i, j;\n\n\tchannel = pdata->channel_head;\n\tfor (i = 0; i < pdata->channel_count; i++, channel++) {\n\t\tring = channel->rx_ring;\n\t\tif (!ring)\n\t\t\tbreak;\n\n\t\tdma_desc = ring->dma_desc_head;\n\t\tdma_desc_addr = ring->dma_desc_head_addr;\n\n\t\tfor (j = 0; j < ring->dma_desc_count; j++) {\n\t\t\tdesc_data = XLGMAC_GET_DESC_DATA(ring, j);\n\n\t\t\tdesc_data->dma_desc = dma_desc;\n\t\t\tdesc_data->dma_desc_addr = dma_desc_addr;\n\n\t\t\tif (xlgmac_map_rx_buffer(pdata, ring, desc_data))\n\t\t\t\tbreak;\n\n\t\t\tdma_desc++;\n\t\t\tdma_desc_addr += sizeof(struct xlgmac_dma_desc);\n\t\t}\n\n\t\tring->cur = 0;\n\t\tring->dirty = 0;\n\n\t\thw_ops->rx_desc_init(channel);\n\t}\n}\n\nstatic int xlgmac_map_tx_skb(struct xlgmac_channel *channel,\n\t\t\t     struct sk_buff *skb)\n{\n\tstruct xlgmac_pdata *pdata = channel->pdata;\n\tstruct xlgmac_ring *ring = channel->tx_ring;\n\tunsigned int start_index, cur_index;\n\tstruct xlgmac_desc_data *desc_data;\n\tunsigned int offset, datalen, len;\n\tstruct xlgmac_pkt_info *pkt_info;\n\tskb_frag_t *frag;\n\tunsigned int tso, vlan;\n\tdma_addr_t skb_dma;\n\tunsigned int i;\n\n\toffset = 0;\n\tstart_index = ring->cur;\n\tcur_index = ring->cur;\n\n\tpkt_info = &ring->pkt_info;\n\tpkt_info->desc_count = 0;\n\tpkt_info->length = 0;\n\n\ttso = XLGMAC_GET_REG_BITS(pkt_info->attributes,\n\t\t\t\t  TX_PACKET_ATTRIBUTES_TSO_ENABLE_POS,\n\t\t\t\t  TX_PACKET_ATTRIBUTES_TSO_ENABLE_LEN);\n\tvlan = XLGMAC_GET_REG_BITS(pkt_info->attributes,\n\t\t\t\t   TX_PACKET_ATTRIBUTES_VLAN_CTAG_POS,\n\t\t\t\t   TX_PACKET_ATTRIBUTES_VLAN_CTAG_LEN);\n\n\t \n\tif ((tso && (pkt_info->mss != ring->tx.cur_mss)) ||\n\t    (vlan && (pkt_info->vlan_ctag != ring->tx.cur_vlan_ctag)))\n\t\tcur_index++;\n\tdesc_data = XLGMAC_GET_DESC_DATA(ring, cur_index);\n\n\tif (tso) {\n\t\t \n\t\tskb_dma = dma_map_single(pdata->dev, skb->data,\n\t\t\t\t\t pkt_info->header_len, DMA_TO_DEVICE);\n\t\tif (dma_mapping_error(pdata->dev, skb_dma)) {\n\t\t\tnetdev_alert(pdata->netdev, \"dma_map_single failed\\n\");\n\t\t\tgoto err_out;\n\t\t}\n\t\tdesc_data->skb_dma = skb_dma;\n\t\tdesc_data->skb_dma_len = pkt_info->header_len;\n\t\tnetif_dbg(pdata, tx_queued, pdata->netdev,\n\t\t\t  \"skb header: index=%u, dma=%pad, len=%u\\n\",\n\t\t\t  cur_index, &skb_dma, pkt_info->header_len);\n\n\t\toffset = pkt_info->header_len;\n\n\t\tpkt_info->length += pkt_info->header_len;\n\n\t\tcur_index++;\n\t\tdesc_data = XLGMAC_GET_DESC_DATA(ring, cur_index);\n\t}\n\n\t \n\tfor (datalen = skb_headlen(skb) - offset; datalen; ) {\n\t\tlen = min_t(unsigned int, datalen, XLGMAC_TX_MAX_BUF_SIZE);\n\n\t\tskb_dma = dma_map_single(pdata->dev, skb->data + offset, len,\n\t\t\t\t\t DMA_TO_DEVICE);\n\t\tif (dma_mapping_error(pdata->dev, skb_dma)) {\n\t\t\tnetdev_alert(pdata->netdev, \"dma_map_single failed\\n\");\n\t\t\tgoto err_out;\n\t\t}\n\t\tdesc_data->skb_dma = skb_dma;\n\t\tdesc_data->skb_dma_len = len;\n\t\tnetif_dbg(pdata, tx_queued, pdata->netdev,\n\t\t\t  \"skb data: index=%u, dma=%pad, len=%u\\n\",\n\t\t\t  cur_index, &skb_dma, len);\n\n\t\tdatalen -= len;\n\t\toffset += len;\n\n\t\tpkt_info->length += len;\n\n\t\tcur_index++;\n\t\tdesc_data = XLGMAC_GET_DESC_DATA(ring, cur_index);\n\t}\n\n\tfor (i = 0; i < skb_shinfo(skb)->nr_frags; i++) {\n\t\tnetif_dbg(pdata, tx_queued, pdata->netdev,\n\t\t\t  \"mapping frag %u\\n\", i);\n\n\t\tfrag = &skb_shinfo(skb)->frags[i];\n\t\toffset = 0;\n\n\t\tfor (datalen = skb_frag_size(frag); datalen; ) {\n\t\t\tlen = min_t(unsigned int, datalen,\n\t\t\t\t    XLGMAC_TX_MAX_BUF_SIZE);\n\n\t\t\tskb_dma = skb_frag_dma_map(pdata->dev, frag, offset,\n\t\t\t\t\t\t   len, DMA_TO_DEVICE);\n\t\t\tif (dma_mapping_error(pdata->dev, skb_dma)) {\n\t\t\t\tnetdev_alert(pdata->netdev,\n\t\t\t\t\t     \"skb_frag_dma_map failed\\n\");\n\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t\tdesc_data->skb_dma = skb_dma;\n\t\t\tdesc_data->skb_dma_len = len;\n\t\t\tdesc_data->mapped_as_page = 1;\n\t\t\tnetif_dbg(pdata, tx_queued, pdata->netdev,\n\t\t\t\t  \"skb frag: index=%u, dma=%pad, len=%u\\n\",\n\t\t\t\t  cur_index, &skb_dma, len);\n\n\t\t\tdatalen -= len;\n\t\t\toffset += len;\n\n\t\t\tpkt_info->length += len;\n\n\t\t\tcur_index++;\n\t\t\tdesc_data = XLGMAC_GET_DESC_DATA(ring, cur_index);\n\t\t}\n\t}\n\n\t \n\tdesc_data = XLGMAC_GET_DESC_DATA(ring, cur_index - 1);\n\tdesc_data->skb = skb;\n\n\t \n\tpkt_info->desc_count = cur_index - start_index;\n\n\treturn pkt_info->desc_count;\n\nerr_out:\n\twhile (start_index < cur_index) {\n\t\tdesc_data = XLGMAC_GET_DESC_DATA(ring, start_index++);\n\t\txlgmac_unmap_desc_data(pdata, desc_data);\n\t}\n\n\treturn 0;\n}\n\nvoid xlgmac_init_desc_ops(struct xlgmac_desc_ops *desc_ops)\n{\n\tdesc_ops->alloc_channels_and_rings = xlgmac_alloc_channels_and_rings;\n\tdesc_ops->free_channels_and_rings = xlgmac_free_channels_and_rings;\n\tdesc_ops->map_tx_skb = xlgmac_map_tx_skb;\n\tdesc_ops->map_rx_buffer = xlgmac_map_rx_buffer;\n\tdesc_ops->unmap_desc_data = xlgmac_unmap_desc_data;\n\tdesc_ops->tx_desc_init = xlgmac_tx_desc_init;\n\tdesc_ops->rx_desc_init = xlgmac_rx_desc_init;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}