{
  "module_name": "fealnx.c",
  "hash_id": "fd17f7f919121552e927b9c633d5e92c241495e77bb4c8e6e06d345f1c06feb7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/fealnx.c",
  "human_readable_source": " \n\n#define DRV_NAME\t\"fealnx\"\n\nstatic int debug;\t\t \nstatic int max_interrupt_work = 20;\n\n \nstatic int multicast_filter_limit = 32;\n\n \n \nstatic int rx_copybreak;\n\n \n \n \n \n#define MAX_UNITS 8\t\t \nstatic int options[MAX_UNITS] = { -1, -1, -1, -1, -1, -1, -1, -1 };\nstatic int full_duplex[MAX_UNITS] = { -1, -1, -1, -1, -1, -1, -1, -1 };\n\n \n \n \n \n \n \n\n\n\n#define TX_RING_SIZE    6\n#define RX_RING_SIZE    12\n#define TX_TOTAL_SIZE\tTX_RING_SIZE*sizeof(struct fealnx_desc)\n#define RX_TOTAL_SIZE\tRX_RING_SIZE*sizeof(struct fealnx_desc)\n\n \n \n#define TX_TIMEOUT      (2*HZ)\n\n#define PKT_BUF_SZ      1536\t \n\n\n \n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/timer.h>\n#include <linux/errno.h>\n#include <linux/ioport.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/mii.h>\n#include <linux/ethtool.h>\n#include <linux/crc32.h>\n#include <linux/delay.h>\n#include <linux/bitops.h>\n\n#include <asm/processor.h>\t \n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <asm/byteorder.h>\n\n \n#ifndef __alpha__\n#define USE_IO_OPS\n#endif\n\n \n \n\n#define RUN_AT(x) (jiffies + (x))\n\nMODULE_AUTHOR(\"Myson or whoever\");\nMODULE_DESCRIPTION(\"Myson MTD-8xx 100/10M Ethernet PCI Adapter Driver\");\nMODULE_LICENSE(\"GPL\");\nmodule_param(max_interrupt_work, int, 0);\nmodule_param(debug, int, 0);\nmodule_param(rx_copybreak, int, 0);\nmodule_param(multicast_filter_limit, int, 0);\nmodule_param_array(options, int, NULL, 0);\nmodule_param_array(full_duplex, int, NULL, 0);\nMODULE_PARM_DESC(max_interrupt_work, \"fealnx maximum events handled per interrupt\");\nMODULE_PARM_DESC(debug, \"fealnx enable debugging (0-1)\");\nMODULE_PARM_DESC(rx_copybreak, \"fealnx copy breakpoint for copy-only-tiny-frames\");\nMODULE_PARM_DESC(multicast_filter_limit, \"fealnx maximum number of filtered multicast addresses\");\nMODULE_PARM_DESC(options, \"fealnx: Bits 0-3: media type, bit 17: full duplex\");\nMODULE_PARM_DESC(full_duplex, \"fealnx full duplex setting(s) (1)\");\n\nenum {\n\tMIN_REGION_SIZE\t\t= 136,\n};\n\n \nenum chip_capability_flags {\n\tHAS_MII_XCVR,\n\tHAS_CHIP_XCVR,\n};\n\n \n \nenum phy_type_flags {\n\tMysonPHY = 1,\n\tAhdocPHY = 2,\n\tSeeqPHY = 3,\n\tMarvellPHY = 4,\n\tMyson981 = 5,\n\tLevelOnePHY = 6,\n\tOtherPHY = 10,\n};\n\nstruct chip_info {\n\tchar *chip_name;\n\tint flags;\n};\n\nstatic const struct chip_info skel_netdrv_tbl[] = {\n\t{ \"100/10M Ethernet PCI Adapter\",\tHAS_MII_XCVR },\n\t{ \"100/10M Ethernet PCI Adapter\",\tHAS_CHIP_XCVR },\n\t{ \"1000/100/10M Ethernet PCI Adapter\",\tHAS_MII_XCVR },\n};\n\n \nenum fealnx_offsets {\n\tPAR0 = 0x0,\t\t \n\tPAR1 = 0x04,\t\t \n\tMAR0 = 0x08,\t\t \n\tMAR1 = 0x0C,\t\t \n\tFAR0 = 0x10,\t\t \n\tFAR1 = 0x14,\t\t \n\tTCRRCR = 0x18,\t\t \n\tBCR = 0x1C,\t\t \n\tTXPDR = 0x20,\t\t \n\tRXPDR = 0x24,\t\t \n\tRXCWP = 0x28,\t\t \n\tTXLBA = 0x2C,\t\t \n\tRXLBA = 0x30,\t\t \n\tISR = 0x34,\t\t \n\tIMR = 0x38,\t\t \n\tFTH = 0x3C,\t\t \n\tMANAGEMENT = 0x40,\t \n\tTALLY = 0x44,\t\t \n\tTSR = 0x48,\t\t \n\tBMCRSR = 0x4c,\t\t \n\tPHYIDENTIFIER = 0x50,\t \n\tANARANLPAR = 0x54,\t \n\tANEROCR = 0x58,\t\t \n\tBPREMRPSR = 0x5c,\t \n};\n\n \n \nenum intr_status_bits {\n\tRFCON = 0x00020000,\t \n\tRFCOFF = 0x00010000,\t \n\tLSCStatus = 0x00008000,\t \n\tANCStatus = 0x00004000,\t \n\tFBE = 0x00002000,\t \n\tFBEMask = 0x00001800,\t \n\tParityErr = 0x00000000,\t \n\tTargetErr = 0x00001000,\t \n\tMasterErr = 0x00000800,\t \n\tTUNF = 0x00000400,\t \n\tROVF = 0x00000200,\t \n\tETI = 0x00000100,\t \n\tERI = 0x00000080,\t \n\tCNTOVF = 0x00000040,\t \n\tRBU = 0x00000020,\t \n\tTBU = 0x00000010,\t \n\tTI = 0x00000008,\t \n\tRI = 0x00000004,\t \n\tRxErr = 0x00000002,\t \n};\n\n \n \n \nenum rx_mode_bits {\n\tCR_W_ENH\t= 0x02000000,\t \n\tCR_W_FD\t\t= 0x00100000,\t \n\tCR_W_PS10\t= 0x00080000,\t \n\tCR_W_TXEN\t= 0x00040000,\t \n\tCR_W_PS1000\t= 0x00010000,\t \n      \n\tCR_W_RXMODEMASK\t= 0x000000e0,\n\tCR_W_PROM\t= 0x00000080,\t \n\tCR_W_AB\t\t= 0x00000040,\t \n\tCR_W_AM\t\t= 0x00000020,\t \n\tCR_W_ARP\t= 0x00000008,\t \n\tCR_W_ALP\t= 0x00000004,\t \n\tCR_W_SEP\t= 0x00000002,\t \n\tCR_W_RXEN\t= 0x00000001,\t \n\n\tCR_R_TXSTOP\t= 0x04000000,\t \n\tCR_R_FD\t\t= 0x00100000,\t \n\tCR_R_PS10\t= 0x00080000,\t \n\tCR_R_RXSTOP\t= 0x00008000,\t \n};\n\n \nstruct fealnx_desc {\n\ts32 status;\n\ts32 control;\n\tu32 buffer;\n\tu32 next_desc;\n\tstruct fealnx_desc *next_desc_logical;\n\tstruct sk_buff *skbuff;\n\tu32 reserved1;\n\tu32 reserved2;\n};\n\n \nenum rx_desc_status_bits {\n\tRXOWN = 0x80000000,\t \n\tFLNGMASK = 0x0fff0000,\t \n\tFLNGShift = 16,\n\tMARSTATUS = 0x00004000,\t \n\tBARSTATUS = 0x00002000,\t \n\tPHYSTATUS = 0x00001000,\t \n\tRXFSD = 0x00000800,\t \n\tRXLSD = 0x00000400,\t \n\tErrorSummary = 0x80,\t \n\tRUNTPKT = 0x40,\t\t \n\tLONGPKT = 0x20,\t\t \n\tFAE = 0x10,\t\t \n\tCRC = 0x08,\t\t \n\tRXER = 0x04,\t\t \n};\n\nenum rx_desc_control_bits {\n\tRXIC = 0x00800000,\t \n\tRBSShift = 0,\n};\n\nenum tx_desc_status_bits {\n\tTXOWN = 0x80000000,\t \n\tJABTO = 0x00004000,\t \n\tCSL = 0x00002000,\t \n\tLC = 0x00001000,\t \n\tEC = 0x00000800,\t \n\tUDF = 0x00000400,\t \n\tDFR = 0x00000200,\t \n\tHF = 0x00000100,\t \n\tNCRMask = 0x000000ff,\t \n\tNCRShift = 0,\n};\n\nenum tx_desc_control_bits {\n\tTXIC = 0x80000000,\t \n\tETIControl = 0x40000000,\t \n\tTXLD = 0x20000000,\t \n\tTXFD = 0x10000000,\t \n\tCRCEnable = 0x08000000,\t \n\tPADEnable = 0x04000000,\t \n\tRetryTxLC = 0x02000000,\t \n\tPKTSMask = 0x3ff800,\t \n\tPKTSShift = 11,\n\tTBSMask = 0x000007ff,\t \n\tTBSShift = 0,\n};\n\n \n#define MASK_MIIR_MII_READ       0x00000000\n#define MASK_MIIR_MII_WRITE      0x00000008\n#define MASK_MIIR_MII_MDO        0x00000004\n#define MASK_MIIR_MII_MDI        0x00000002\n#define MASK_MIIR_MII_MDC        0x00000001\n\n \n#define OP_READ             0x6000\t \n#define OP_WRITE            0x5002\t \n\n \n \n \n#define MysonPHYID      0xd0000302\n \n#define MysonPHYID0     0x0302\n#define StatusRegister  18\n#define SPEED100        0x0400\t\n#define FULLMODE        0x0800\t\n \n\n \n \n \n#define SeeqPHYID0      0x0016\n\n#define MIIRegister18   18\n#define SPD_DET_100     0x80\n#define DPLX_DET_FULL   0x40\n\n \n \n \n#define AhdocPHYID0     0x0022\n\n#define DiagnosticReg   18\n#define DPLX_FULL       0x0800\n#define Speed_100       0x0400\n\n \n \n \n \n#define MarvellPHYID0           0x0141\n#define LevelOnePHYID0\t\t0x0013\n\n#define MII1000BaseTControlReg  9\n#define MII1000BaseTStatusReg   10\n#define SpecificReg\t\t17\n\n \n#define PHYAbletoPerform1000FullDuplex  0x0200\n#define PHYAbletoPerform1000HalfDuplex  0x0100\n#define PHY1000AbilityMask              0x300\n\n\n#define SpeedMask       0x0c000\n#define Speed_1000M     0x08000\n#define Speed_100M      0x4000\n#define Speed_10M       0\n#define Full_Duplex     0x2000\n\n\n#define LXT1000_100M    0x08000\n#define LXT1000_1000M   0x0c000\n#define LXT1000_Full    0x200\n\n\n \n#define LinkIsUp2\t0x00040000\n\n \n#define LinkIsUp        0x0004\n\n\nstruct netdev_private {\n\t \n\tstruct fealnx_desc *rx_ring;\n\tstruct fealnx_desc *tx_ring;\n\n\tdma_addr_t rx_ring_dma;\n\tdma_addr_t tx_ring_dma;\n\n\tspinlock_t lock;\n\n\t \n\tstruct timer_list timer;\n\n\t \n\tstruct timer_list reset_timer;\n\tint reset_timer_armed;\n\tunsigned long crvalue_sv;\n\tunsigned long imrvalue_sv;\n\n\t \n\tint flags;\n\tstruct pci_dev *pci_dev;\n\tunsigned long crvalue;\n\tunsigned long bcrvalue;\n\tunsigned long imrvalue;\n\tstruct fealnx_desc *cur_rx;\n\tstruct fealnx_desc *lack_rxbuf;\n\tint really_rx_count;\n\tstruct fealnx_desc *cur_tx;\n\tstruct fealnx_desc *cur_tx_copy;\n\tint really_tx_count;\n\tint free_tx_count;\n\tunsigned int rx_buf_sz;\t \n\n\t \n\tunsigned int linkok;\n\tunsigned int line_speed;\n\tunsigned int duplexmode;\n\tunsigned int default_port:4;\t \n\tunsigned int PHYType;\n\n\t \n\tint mii_cnt;\t\t \n\tunsigned char phys[2];\t \n\tstruct mii_if_info mii;\n\tvoid __iomem *mem;\n};\n\n\nstatic int mdio_read(struct net_device *dev, int phy_id, int location);\nstatic void mdio_write(struct net_device *dev, int phy_id, int location, int value);\nstatic int netdev_open(struct net_device *dev);\nstatic void getlinktype(struct net_device *dev);\nstatic void getlinkstatus(struct net_device *dev);\nstatic void netdev_timer(struct timer_list *t);\nstatic void reset_timer(struct timer_list *t);\nstatic void fealnx_tx_timeout(struct net_device *dev, unsigned int txqueue);\nstatic void init_ring(struct net_device *dev);\nstatic netdev_tx_t start_tx(struct sk_buff *skb, struct net_device *dev);\nstatic irqreturn_t intr_handler(int irq, void *dev_instance);\nstatic int netdev_rx(struct net_device *dev);\nstatic void set_rx_mode(struct net_device *dev);\nstatic void __set_rx_mode(struct net_device *dev);\nstatic struct net_device_stats *get_stats(struct net_device *dev);\nstatic int mii_ioctl(struct net_device *dev, struct ifreq *rq, int cmd);\nstatic const struct ethtool_ops netdev_ethtool_ops;\nstatic int netdev_close(struct net_device *dev);\nstatic void reset_rx_descriptors(struct net_device *dev);\nstatic void reset_tx_descriptors(struct net_device *dev);\n\nstatic void stop_nic_rx(void __iomem *ioaddr, long crvalue)\n{\n\tint delay = 0x1000;\n\tiowrite32(crvalue & ~(CR_W_RXEN), ioaddr + TCRRCR);\n\twhile (--delay) {\n\t\tif ( (ioread32(ioaddr + TCRRCR) & CR_R_RXSTOP) == CR_R_RXSTOP)\n\t\t\tbreak;\n\t}\n}\n\n\nstatic void stop_nic_rxtx(void __iomem *ioaddr, long crvalue)\n{\n\tint delay = 0x1000;\n\tiowrite32(crvalue & ~(CR_W_RXEN+CR_W_TXEN), ioaddr + TCRRCR);\n\twhile (--delay) {\n\t\tif ( (ioread32(ioaddr + TCRRCR) & (CR_R_RXSTOP+CR_R_TXSTOP))\n\t\t\t\t\t    == (CR_R_RXSTOP+CR_R_TXSTOP) )\n\t\t\tbreak;\n\t}\n}\n\nstatic const struct net_device_ops netdev_ops = {\n\t.ndo_open\t\t= netdev_open,\n\t.ndo_stop\t\t= netdev_close,\n\t.ndo_start_xmit\t\t= start_tx,\n\t.ndo_get_stats \t\t= get_stats,\n\t.ndo_set_rx_mode\t= set_rx_mode,\n\t.ndo_eth_ioctl\t\t= mii_ioctl,\n\t.ndo_tx_timeout\t\t= fealnx_tx_timeout,\n\t.ndo_set_mac_address \t= eth_mac_addr,\n\t.ndo_validate_addr\t= eth_validate_addr,\n};\n\nstatic int fealnx_init_one(struct pci_dev *pdev,\n\t\t\t   const struct pci_device_id *ent)\n{\n\tstruct netdev_private *np;\n\tint i, option, err, irq;\n\tstatic int card_idx = -1;\n\tchar boardname[12];\n\tvoid __iomem *ioaddr;\n\tunsigned long len;\n\tunsigned int chip_id = ent->driver_data;\n\tstruct net_device *dev;\n\tvoid *ring_space;\n\tdma_addr_t ring_dma;\n\tu8 addr[ETH_ALEN];\n#ifdef USE_IO_OPS\n\tint bar = 0;\n#else\n\tint bar = 1;\n#endif\n\n\tcard_idx++;\n\tsprintf(boardname, \"fealnx%d\", card_idx);\n\n\toption = card_idx < MAX_UNITS ? options[card_idx] : 0;\n\n\ti = pci_enable_device(pdev);\n\tif (i) return i;\n\tpci_set_master(pdev);\n\n\tlen = pci_resource_len(pdev, bar);\n\tif (len < MIN_REGION_SIZE) {\n\t\tdev_err(&pdev->dev,\n\t\t\t   \"region size %ld too small, aborting\\n\", len);\n\t\treturn -ENODEV;\n\t}\n\n\ti = pci_request_regions(pdev, boardname);\n\tif (i)\n\t\treturn i;\n\n\tirq = pdev->irq;\n\n\tioaddr = pci_iomap(pdev, bar, len);\n\tif (!ioaddr) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out_res;\n\t}\n\n\tdev = alloc_etherdev(sizeof(struct netdev_private));\n\tif (!dev) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out_unmap;\n\t}\n\tSET_NETDEV_DEV(dev, &pdev->dev);\n\n\t \n\tfor (i = 0; i < 6; ++i)\n\t\taddr[i] = ioread8(ioaddr + PAR0 + i);\n\teth_hw_addr_set(dev, addr);\n\n\t \n\tiowrite32(0x00000001, ioaddr + BCR);\n\n\t \n\tnp = netdev_priv(dev);\n\tnp->mem = ioaddr;\n\tspin_lock_init(&np->lock);\n\tnp->pci_dev = pdev;\n\tnp->flags = skel_netdrv_tbl[chip_id].flags;\n\tpci_set_drvdata(pdev, dev);\n\tnp->mii.dev = dev;\n\tnp->mii.mdio_read = mdio_read;\n\tnp->mii.mdio_write = mdio_write;\n\tnp->mii.phy_id_mask = 0x1f;\n\tnp->mii.reg_num_mask = 0x1f;\n\n\tring_space = dma_alloc_coherent(&pdev->dev, RX_TOTAL_SIZE, &ring_dma,\n\t\t\t\t\tGFP_KERNEL);\n\tif (!ring_space) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out_free_dev;\n\t}\n\tnp->rx_ring = ring_space;\n\tnp->rx_ring_dma = ring_dma;\n\n\tring_space = dma_alloc_coherent(&pdev->dev, TX_TOTAL_SIZE, &ring_dma,\n\t\t\t\t\tGFP_KERNEL);\n\tif (!ring_space) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out_free_rx;\n\t}\n\tnp->tx_ring = ring_space;\n\tnp->tx_ring_dma = ring_dma;\n\n\t \n\tif (np->flags == HAS_MII_XCVR) {\n\t\tint phy, phy_idx = 0;\n\n\t\tfor (phy = 1; phy < 32 && phy_idx < ARRAY_SIZE(np->phys);\n\t\t\t       phy++) {\n\t\t\tint mii_status = mdio_read(dev, phy, 1);\n\n\t\t\tif (mii_status != 0xffff && mii_status != 0x0000) {\n\t\t\t\tnp->phys[phy_idx++] = phy;\n\t\t\t\tdev_info(&pdev->dev,\n\t\t\t\t       \"MII PHY found at address %d, status \"\n\t\t\t\t       \"0x%4.4x.\\n\", phy, mii_status);\n\t\t\t\t \n\t\t\t\t{\n\t\t\t\t\tunsigned int data;\n\n\t\t\t\t\tdata = mdio_read(dev, np->phys[0], 2);\n\t\t\t\t\tif (data == SeeqPHYID0)\n\t\t\t\t\t\tnp->PHYType = SeeqPHY;\n\t\t\t\t\telse if (data == AhdocPHYID0)\n\t\t\t\t\t\tnp->PHYType = AhdocPHY;\n\t\t\t\t\telse if (data == MarvellPHYID0)\n\t\t\t\t\t\tnp->PHYType = MarvellPHY;\n\t\t\t\t\telse if (data == MysonPHYID0)\n\t\t\t\t\t\tnp->PHYType = Myson981;\n\t\t\t\t\telse if (data == LevelOnePHYID0)\n\t\t\t\t\t\tnp->PHYType = LevelOnePHY;\n\t\t\t\t\telse\n\t\t\t\t\t\tnp->PHYType = OtherPHY;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tnp->mii_cnt = phy_idx;\n\t\tif (phy_idx == 0)\n\t\t\tdev_warn(&pdev->dev,\n\t\t\t\t\"MII PHY not found -- this device may \"\n\t\t\t       \"not operate correctly.\\n\");\n\t} else {\n\t\tnp->phys[0] = 32;\n \n\t\t \n\t\tif (ioread32(ioaddr + PHYIDENTIFIER) == MysonPHYID)\n\t\t\tnp->PHYType = MysonPHY;\n\t\telse\n\t\t\tnp->PHYType = OtherPHY;\n\t}\n\tnp->mii.phy_id = np->phys[0];\n\n\tif (dev->mem_start)\n\t\toption = dev->mem_start;\n\n\t \n\tif (option > 0) {\n\t\tif (option & 0x200)\n\t\t\tnp->mii.full_duplex = 1;\n\t\tnp->default_port = option & 15;\n\t}\n\n\tif (card_idx < MAX_UNITS && full_duplex[card_idx] > 0)\n\t\tnp->mii.full_duplex = full_duplex[card_idx];\n\n\tif (np->mii.full_duplex) {\n\t\tdev_info(&pdev->dev, \"Media type forced to Full Duplex.\\n\");\n \n\n\t\tif ((np->PHYType == MarvellPHY) || (np->PHYType == LevelOnePHY)) {\n\t\t\tunsigned int data;\n\n\t\t\tdata = mdio_read(dev, np->phys[0], 9);\n\t\t\tdata = (data & 0xfcff) | 0x0200;\n\t\t\tmdio_write(dev, np->phys[0], 9, data);\n\t\t}\n \n\t\tif (np->flags == HAS_MII_XCVR)\n\t\t\tmdio_write(dev, np->phys[0], MII_ADVERTISE, ADVERTISE_FULL);\n\t\telse\n\t\t\tiowrite32(ADVERTISE_FULL, ioaddr + ANARANLPAR);\n\t\tnp->mii.force_media = 1;\n\t}\n\n\tdev->netdev_ops = &netdev_ops;\n\tdev->ethtool_ops = &netdev_ethtool_ops;\n\tdev->watchdog_timeo = TX_TIMEOUT;\n\n\terr = register_netdev(dev);\n\tif (err)\n\t\tgoto err_out_free_tx;\n\n\tprintk(KERN_INFO \"%s: %s at %p, %pM, IRQ %d.\\n\",\n\t       dev->name, skel_netdrv_tbl[chip_id].chip_name, ioaddr,\n\t       dev->dev_addr, irq);\n\n\treturn 0;\n\nerr_out_free_tx:\n\tdma_free_coherent(&pdev->dev, TX_TOTAL_SIZE, np->tx_ring,\n\t\t\t  np->tx_ring_dma);\nerr_out_free_rx:\n\tdma_free_coherent(&pdev->dev, RX_TOTAL_SIZE, np->rx_ring,\n\t\t\t  np->rx_ring_dma);\nerr_out_free_dev:\n\tfree_netdev(dev);\nerr_out_unmap:\n\tpci_iounmap(pdev, ioaddr);\nerr_out_res:\n\tpci_release_regions(pdev);\n\treturn err;\n}\n\n\nstatic void fealnx_remove_one(struct pci_dev *pdev)\n{\n\tstruct net_device *dev = pci_get_drvdata(pdev);\n\n\tif (dev) {\n\t\tstruct netdev_private *np = netdev_priv(dev);\n\n\t\tdma_free_coherent(&pdev->dev, TX_TOTAL_SIZE, np->tx_ring,\n\t\t\t\t  np->tx_ring_dma);\n\t\tdma_free_coherent(&pdev->dev, RX_TOTAL_SIZE, np->rx_ring,\n\t\t\t\t  np->rx_ring_dma);\n\t\tunregister_netdev(dev);\n\t\tpci_iounmap(pdev, np->mem);\n\t\tfree_netdev(dev);\n\t\tpci_release_regions(pdev);\n\t} else\n\t\tprintk(KERN_ERR \"fealnx: remove for unknown device\\n\");\n}\n\n\nstatic ulong m80x_send_cmd_to_phy(void __iomem *miiport, int opcode, int phyad, int regad)\n{\n\tulong miir;\n\tint i;\n\tunsigned int mask, data;\n\n\t \n\tmiir = (ulong) ioread32(miiport);\n\tmiir &= 0xfffffff0;\n\n\tmiir |= MASK_MIIR_MII_WRITE + MASK_MIIR_MII_MDO;\n\n\t \n\tfor (i = 0; i < 32; i++) {\n\t\t \n\t\tmiir &= ~MASK_MIIR_MII_MDC;\n\t\tiowrite32(miir, miiport);\n\n\t\t \n\t\tmiir |= MASK_MIIR_MII_MDC;\n\t\tiowrite32(miir, miiport);\n\t}\n\n\t \n\tdata = opcode | (phyad << 7) | (regad << 2);\n\n\t \n\tmask = 0x8000;\n\twhile (mask) {\n\t\t \n\t\tmiir &= ~(MASK_MIIR_MII_MDC + MASK_MIIR_MII_MDO);\n\t\tif (mask & data)\n\t\t\tmiir |= MASK_MIIR_MII_MDO;\n\n\t\tiowrite32(miir, miiport);\n\t\t \n\t\tmiir |= MASK_MIIR_MII_MDC;\n\t\tiowrite32(miir, miiport);\n\t\tudelay(30);\n\n\t\t \n\t\tmask >>= 1;\n\t\tif (mask == 0x2 && opcode == OP_READ)\n\t\t\tmiir &= ~MASK_MIIR_MII_WRITE;\n\t}\n\treturn miir;\n}\n\n\nstatic int mdio_read(struct net_device *dev, int phyad, int regad)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tvoid __iomem *miiport = np->mem + MANAGEMENT;\n\tulong miir;\n\tunsigned int mask, data;\n\n\tmiir = m80x_send_cmd_to_phy(miiport, OP_READ, phyad, regad);\n\n\t \n\tmask = 0x8000;\n\tdata = 0;\n\twhile (mask) {\n\t\t \n\t\tmiir &= ~MASK_MIIR_MII_MDC;\n\t\tiowrite32(miir, miiport);\n\n\t\t \n\t\tmiir = ioread32(miiport);\n\t\tif (miir & MASK_MIIR_MII_MDI)\n\t\t\tdata |= mask;\n\n\t\t \n\t\tmiir |= MASK_MIIR_MII_MDC;\n\t\tiowrite32(miir, miiport);\n\t\tudelay(30);\n\n\t\t \n\t\tmask >>= 1;\n\t}\n\n\t \n\tmiir &= ~MASK_MIIR_MII_MDC;\n\tiowrite32(miir, miiport);\n\n\treturn data & 0xffff;\n}\n\n\nstatic void mdio_write(struct net_device *dev, int phyad, int regad, int data)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tvoid __iomem *miiport = np->mem + MANAGEMENT;\n\tulong miir;\n\tunsigned int mask;\n\n\tmiir = m80x_send_cmd_to_phy(miiport, OP_WRITE, phyad, regad);\n\n\t \n\tmask = 0x8000;\n\twhile (mask) {\n\t\t \n\t\tmiir &= ~(MASK_MIIR_MII_MDC + MASK_MIIR_MII_MDO);\n\t\tif (mask & data)\n\t\t\tmiir |= MASK_MIIR_MII_MDO;\n\t\tiowrite32(miir, miiport);\n\n\t\t \n\t\tmiir |= MASK_MIIR_MII_MDC;\n\t\tiowrite32(miir, miiport);\n\n\t\t \n\t\tmask >>= 1;\n\t}\n\n\t \n\tmiir &= ~MASK_MIIR_MII_MDC;\n\tiowrite32(miir, miiport);\n}\n\n\nstatic int netdev_open(struct net_device *dev)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tvoid __iomem *ioaddr = np->mem;\n\tconst int irq = np->pci_dev->irq;\n\tint rc, i;\n\n\tiowrite32(0x00000001, ioaddr + BCR);\t \n\n\trc = request_irq(irq, intr_handler, IRQF_SHARED, dev->name, dev);\n\tif (rc)\n\t\treturn -EAGAIN;\n\n\tfor (i = 0; i < 3; i++)\n\t\tiowrite16(((const unsigned short *)dev->dev_addr)[i],\n\t\t\t\tioaddr + PAR0 + i*2);\n\n\tinit_ring(dev);\n\n\tiowrite32(np->rx_ring_dma, ioaddr + RXLBA);\n\tiowrite32(np->tx_ring_dma, ioaddr + TXLBA);\n\n\t \n\t \n\n\tnp->bcrvalue = 0x10;\t \n#ifdef __BIG_ENDIAN\n\tnp->bcrvalue |= 0x04;\t \n#endif\n\n#if defined(__i386__) && !defined(MODULE) && !defined(CONFIG_UML)\n\tif (boot_cpu_data.x86 <= 4)\n\t\tnp->crvalue = 0xa00;\n\telse\n#endif\n\t\tnp->crvalue = 0xe00;\t \n\n\n \n \n \n\tnp->imrvalue = TUNF | CNTOVF | RBU | TI | RI;\n\tif (np->pci_dev->device == 0x891) {\n\t\tnp->bcrvalue |= 0x200;\t \n\t\tnp->crvalue |= CR_W_ENH;\t \n\t\tnp->imrvalue |= ETI;\n\t}\n\tiowrite32(np->bcrvalue, ioaddr + BCR);\n\n\tif (dev->if_port == 0)\n\t\tdev->if_port = np->default_port;\n\n\tiowrite32(0, ioaddr + RXPDR);\n \n \n\tnp->crvalue |= 0x00e40001;\t \n\tnp->mii.full_duplex = np->mii.force_media;\n\tgetlinkstatus(dev);\n\tif (np->linkok)\n\t\tgetlinktype(dev);\n\t__set_rx_mode(dev);\n\n\tnetif_start_queue(dev);\n\n\t \n\tiowrite32(FBE | TUNF | CNTOVF | RBU | TI | RI, ioaddr + ISR);\n\tiowrite32(np->imrvalue, ioaddr + IMR);\n\n\tif (debug)\n\t\tprintk(KERN_DEBUG \"%s: Done netdev_open().\\n\", dev->name);\n\n\t \n\ttimer_setup(&np->timer, netdev_timer, 0);\n\tnp->timer.expires = RUN_AT(3 * HZ);\n\n\t \n\tadd_timer(&np->timer);\n\n\ttimer_setup(&np->reset_timer, reset_timer, 0);\n\tnp->reset_timer_armed = 0;\n\treturn rc;\n}\n\n\nstatic void getlinkstatus(struct net_device *dev)\n \n \n \n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tunsigned int i, DelayTime = 0x1000;\n\n\tnp->linkok = 0;\n\n\tif (np->PHYType == MysonPHY) {\n\t\tfor (i = 0; i < DelayTime; ++i) {\n\t\t\tif (ioread32(np->mem + BMCRSR) & LinkIsUp2) {\n\t\t\t\tnp->linkok = 1;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tudelay(100);\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < DelayTime; ++i) {\n\t\t\tif (mdio_read(dev, np->phys[0], MII_BMSR) & BMSR_LSTATUS) {\n\t\t\t\tnp->linkok = 1;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tudelay(100);\n\t\t}\n\t}\n}\n\n\nstatic void getlinktype(struct net_device *dev)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\n\tif (np->PHYType == MysonPHY) {\t \n\t\tif (ioread32(np->mem + TCRRCR) & CR_R_FD)\n\t\t\tnp->duplexmode = 2;\t \n\t\telse\n\t\t\tnp->duplexmode = 1;\t \n\t\tif (ioread32(np->mem + TCRRCR) & CR_R_PS10)\n\t\t\tnp->line_speed = 1;\t \n\t\telse\n\t\t\tnp->line_speed = 2;\t \n\t} else {\n\t\tif (np->PHYType == SeeqPHY) {\t \n\t\t\tunsigned int data;\n\n\t\t\tdata = mdio_read(dev, np->phys[0], MIIRegister18);\n\t\t\tif (data & SPD_DET_100)\n\t\t\t\tnp->line_speed = 2;\t \n\t\t\telse\n\t\t\t\tnp->line_speed = 1;\t \n\t\t\tif (data & DPLX_DET_FULL)\n\t\t\t\tnp->duplexmode = 2;\t \n\t\t\telse\n\t\t\t\tnp->duplexmode = 1;\t \n\t\t} else if (np->PHYType == AhdocPHY) {\n\t\t\tunsigned int data;\n\n\t\t\tdata = mdio_read(dev, np->phys[0], DiagnosticReg);\n\t\t\tif (data & Speed_100)\n\t\t\t\tnp->line_speed = 2;\t \n\t\t\telse\n\t\t\t\tnp->line_speed = 1;\t \n\t\t\tif (data & DPLX_FULL)\n\t\t\t\tnp->duplexmode = 2;\t \n\t\t\telse\n\t\t\t\tnp->duplexmode = 1;\t \n\t\t}\n \n\t\telse if (np->PHYType == MarvellPHY) {\n\t\t\tunsigned int data;\n\n\t\t\tdata = mdio_read(dev, np->phys[0], SpecificReg);\n\t\t\tif (data & Full_Duplex)\n\t\t\t\tnp->duplexmode = 2;\t \n\t\t\telse\n\t\t\t\tnp->duplexmode = 1;\t \n\t\t\tdata &= SpeedMask;\n\t\t\tif (data == Speed_1000M)\n\t\t\t\tnp->line_speed = 3;\t \n\t\t\telse if (data == Speed_100M)\n\t\t\t\tnp->line_speed = 2;\t \n\t\t\telse\n\t\t\t\tnp->line_speed = 1;\t \n\t\t}\n \n \n\t\telse if (np->PHYType == Myson981) {\n\t\t\tunsigned int data;\n\n\t\t\tdata = mdio_read(dev, np->phys[0], StatusRegister);\n\n\t\t\tif (data & SPEED100)\n\t\t\t\tnp->line_speed = 2;\n\t\t\telse\n\t\t\t\tnp->line_speed = 1;\n\n\t\t\tif (data & FULLMODE)\n\t\t\t\tnp->duplexmode = 2;\n\t\t\telse\n\t\t\t\tnp->duplexmode = 1;\n\t\t}\n \n \n\t\telse if (np->PHYType == LevelOnePHY) {\n\t\t\tunsigned int data;\n\n\t\t\tdata = mdio_read(dev, np->phys[0], SpecificReg);\n\t\t\tif (data & LXT1000_Full)\n\t\t\t\tnp->duplexmode = 2;\t \n\t\t\telse\n\t\t\t\tnp->duplexmode = 1;\t \n\t\t\tdata &= SpeedMask;\n\t\t\tif (data == LXT1000_1000M)\n\t\t\t\tnp->line_speed = 3;\t \n\t\t\telse if (data == LXT1000_100M)\n\t\t\t\tnp->line_speed = 2;\t \n\t\t\telse\n\t\t\t\tnp->line_speed = 1;\t \n\t\t}\n\t\tnp->crvalue &= (~CR_W_PS10) & (~CR_W_FD) & (~CR_W_PS1000);\n\t\tif (np->line_speed == 1)\n\t\t\tnp->crvalue |= CR_W_PS10;\n\t\telse if (np->line_speed == 3)\n\t\t\tnp->crvalue |= CR_W_PS1000;\n\t\tif (np->duplexmode == 2)\n\t\t\tnp->crvalue |= CR_W_FD;\n\t}\n}\n\n\n \nstatic void allocate_rx_buffers(struct net_device *dev)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\n\t \n\twhile (np->really_rx_count != RX_RING_SIZE) {\n\t\tstruct sk_buff *skb;\n\n\t\tskb = netdev_alloc_skb(dev, np->rx_buf_sz);\n\t\tif (skb == NULL)\n\t\t\tbreak;\t \n\n\t\twhile (np->lack_rxbuf->skbuff)\n\t\t\tnp->lack_rxbuf = np->lack_rxbuf->next_desc_logical;\n\n\t\tnp->lack_rxbuf->skbuff = skb;\n\t\tnp->lack_rxbuf->buffer = dma_map_single(&np->pci_dev->dev,\n\t\t\t\t\t\t\tskb->data,\n\t\t\t\t\t\t\tnp->rx_buf_sz,\n\t\t\t\t\t\t\tDMA_FROM_DEVICE);\n\t\tnp->lack_rxbuf->status = RXOWN;\n\t\t++np->really_rx_count;\n\t}\n}\n\n\nstatic void netdev_timer(struct timer_list *t)\n{\n\tstruct netdev_private *np = from_timer(np, t, timer);\n\tstruct net_device *dev = np->mii.dev;\n\tvoid __iomem *ioaddr = np->mem;\n\tint old_crvalue = np->crvalue;\n\tunsigned int old_linkok = np->linkok;\n\tunsigned long flags;\n\n\tif (debug)\n\t\tprintk(KERN_DEBUG \"%s: Media selection timer tick, status %8.8x \"\n\t\t       \"config %8.8x.\\n\", dev->name, ioread32(ioaddr + ISR),\n\t\t       ioread32(ioaddr + TCRRCR));\n\n\tspin_lock_irqsave(&np->lock, flags);\n\n\tif (np->flags == HAS_MII_XCVR) {\n\t\tgetlinkstatus(dev);\n\t\tif ((old_linkok == 0) && (np->linkok == 1)) {\t \n\t\t\tgetlinktype(dev);\n\t\t\tif (np->crvalue != old_crvalue) {\n\t\t\t\tstop_nic_rxtx(ioaddr, np->crvalue);\n\t\t\t\tiowrite32(np->crvalue, ioaddr + TCRRCR);\n\t\t\t}\n\t\t}\n\t}\n\n\tallocate_rx_buffers(dev);\n\n\tspin_unlock_irqrestore(&np->lock, flags);\n\n\tnp->timer.expires = RUN_AT(10 * HZ);\n\tadd_timer(&np->timer);\n}\n\n\n \n \nstatic void reset_and_disable_rxtx(struct net_device *dev)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tvoid __iomem *ioaddr = np->mem;\n\tint delay=51;\n\n\t \n\tstop_nic_rxtx(ioaddr, 0);\n\n\t \n\tiowrite32(0, ioaddr + IMR);\n\n\t \n\tiowrite32(0x00000001, ioaddr + BCR);\n\n\t \n\twhile (--delay) {\n\t\tioread32(ioaddr + BCR);\n\t\trmb();\n\t}\n}\n\n\n \n \nstatic void enable_rxtx(struct net_device *dev)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tvoid __iomem *ioaddr = np->mem;\n\n\treset_rx_descriptors(dev);\n\n\tiowrite32(np->tx_ring_dma + ((char*)np->cur_tx - (char*)np->tx_ring),\n\t\tioaddr + TXLBA);\n\tiowrite32(np->rx_ring_dma + ((char*)np->cur_rx - (char*)np->rx_ring),\n\t\tioaddr + RXLBA);\n\n\tiowrite32(np->bcrvalue, ioaddr + BCR);\n\n\tiowrite32(0, ioaddr + RXPDR);\n\t__set_rx_mode(dev);  \n\n\t \n\tiowrite32(FBE | TUNF | CNTOVF | RBU | TI | RI, ioaddr + ISR);\n\tiowrite32(np->imrvalue, ioaddr + IMR);\n\n\tiowrite32(0, ioaddr + TXPDR);\n}\n\n\nstatic void reset_timer(struct timer_list *t)\n{\n\tstruct netdev_private *np = from_timer(np, t, reset_timer);\n\tstruct net_device *dev = np->mii.dev;\n\tunsigned long flags;\n\n\tprintk(KERN_WARNING \"%s: resetting tx and rx machinery\\n\", dev->name);\n\n\tspin_lock_irqsave(&np->lock, flags);\n\tnp->crvalue = np->crvalue_sv;\n\tnp->imrvalue = np->imrvalue_sv;\n\n\treset_and_disable_rxtx(dev);\n\t \n\tenable_rxtx(dev);\n\tnetif_start_queue(dev);  \n\n\tnp->reset_timer_armed = 0;\n\n\tspin_unlock_irqrestore(&np->lock, flags);\n}\n\n\nstatic void fealnx_tx_timeout(struct net_device *dev, unsigned int txqueue)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tvoid __iomem *ioaddr = np->mem;\n\tunsigned long flags;\n\tint i;\n\n\tprintk(KERN_WARNING\n\t       \"%s: Transmit timed out, status %8.8x, resetting...\\n\",\n\t       dev->name, ioread32(ioaddr + ISR));\n\n\t{\n\t\tprintk(KERN_DEBUG \"  Rx ring %p: \", np->rx_ring);\n\t\tfor (i = 0; i < RX_RING_SIZE; i++)\n\t\t\tprintk(KERN_CONT \" %8.8x\",\n\t\t\t       (unsigned int) np->rx_ring[i].status);\n\t\tprintk(KERN_CONT \"\\n\");\n\t\tprintk(KERN_DEBUG \"  Tx ring %p: \", np->tx_ring);\n\t\tfor (i = 0; i < TX_RING_SIZE; i++)\n\t\t\tprintk(KERN_CONT \" %4.4x\", np->tx_ring[i].status);\n\t\tprintk(KERN_CONT \"\\n\");\n\t}\n\n\tspin_lock_irqsave(&np->lock, flags);\n\n\treset_and_disable_rxtx(dev);\n\treset_tx_descriptors(dev);\n\tenable_rxtx(dev);\n\n\tspin_unlock_irqrestore(&np->lock, flags);\n\n\tnetif_trans_update(dev);  \n\tdev->stats.tx_errors++;\n\tnetif_wake_queue(dev);  \n}\n\n\n \nstatic void init_ring(struct net_device *dev)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tint i;\n\n\t \n\tnp->rx_buf_sz = (dev->mtu <= 1500 ? PKT_BUF_SZ : dev->mtu + 32);\n\tnp->cur_rx = &np->rx_ring[0];\n\tnp->lack_rxbuf = np->rx_ring;\n\tnp->really_rx_count = 0;\n\n\t \n\tfor (i = 0; i < RX_RING_SIZE; i++) {\n\t\tnp->rx_ring[i].status = 0;\n\t\tnp->rx_ring[i].control = np->rx_buf_sz << RBSShift;\n\t\tnp->rx_ring[i].next_desc = np->rx_ring_dma +\n\t\t\t(i + 1)*sizeof(struct fealnx_desc);\n\t\tnp->rx_ring[i].next_desc_logical = &np->rx_ring[i + 1];\n\t\tnp->rx_ring[i].skbuff = NULL;\n\t}\n\n\t \n\tnp->rx_ring[i - 1].next_desc = np->rx_ring_dma;\n\tnp->rx_ring[i - 1].next_desc_logical = np->rx_ring;\n\n\t \n\tfor (i = 0; i < RX_RING_SIZE; i++) {\n\t\tstruct sk_buff *skb = netdev_alloc_skb(dev, np->rx_buf_sz);\n\n\t\tif (skb == NULL) {\n\t\t\tnp->lack_rxbuf = &np->rx_ring[i];\n\t\t\tbreak;\n\t\t}\n\n\t\t++np->really_rx_count;\n\t\tnp->rx_ring[i].skbuff = skb;\n\t\tnp->rx_ring[i].buffer = dma_map_single(&np->pci_dev->dev,\n\t\t\t\t\t\t       skb->data,\n\t\t\t\t\t\t       np->rx_buf_sz,\n\t\t\t\t\t\t       DMA_FROM_DEVICE);\n\t\tnp->rx_ring[i].status = RXOWN;\n\t\tnp->rx_ring[i].control |= RXIC;\n\t}\n\n\t \n\tnp->cur_tx = &np->tx_ring[0];\n\tnp->cur_tx_copy = &np->tx_ring[0];\n\tnp->really_tx_count = 0;\n\tnp->free_tx_count = TX_RING_SIZE;\n\n\tfor (i = 0; i < TX_RING_SIZE; i++) {\n\t\tnp->tx_ring[i].status = 0;\n\t\t \n\t\tnp->tx_ring[i].next_desc = np->tx_ring_dma +\n\t\t\t(i + 1)*sizeof(struct fealnx_desc);\n\t\tnp->tx_ring[i].next_desc_logical = &np->tx_ring[i + 1];\n\t\tnp->tx_ring[i].skbuff = NULL;\n\t}\n\n\t \n\tnp->tx_ring[i - 1].next_desc = np->tx_ring_dma;\n\tnp->tx_ring[i - 1].next_desc_logical = &np->tx_ring[0];\n}\n\n\nstatic netdev_tx_t start_tx(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&np->lock, flags);\n\n\tnp->cur_tx_copy->skbuff = skb;\n\n#define one_buffer\n#define BPT 1022\n#if defined(one_buffer)\n\tnp->cur_tx_copy->buffer = dma_map_single(&np->pci_dev->dev, skb->data,\n\t\t\t\t\t\t skb->len, DMA_TO_DEVICE);\n\tnp->cur_tx_copy->control = TXIC | TXLD | TXFD | CRCEnable | PADEnable;\n\tnp->cur_tx_copy->control |= (skb->len << PKTSShift);\t \n\tnp->cur_tx_copy->control |= (skb->len << TBSShift);\t \n\n\tif (np->pci_dev->device == 0x891)\n\t\tnp->cur_tx_copy->control |= ETIControl | RetryTxLC;\n\tnp->cur_tx_copy->status = TXOWN;\n\tnp->cur_tx_copy = np->cur_tx_copy->next_desc_logical;\n\t--np->free_tx_count;\n#elif defined(two_buffer)\n\tif (skb->len > BPT) {\n\t\tstruct fealnx_desc *next;\n\n\t\t \n\t\tnp->cur_tx_copy->buffer = dma_map_single(&np->pci_dev->dev,\n\t\t\t\t\t\t\t skb->data, BPT,\n\t\t\t\t\t\t\t DMA_TO_DEVICE);\n\t\tnp->cur_tx_copy->control = TXIC | TXFD | CRCEnable | PADEnable;\n\t\tnp->cur_tx_copy->control |= (skb->len << PKTSShift);\t \n\t\tnp->cur_tx_copy->control |= (BPT << TBSShift);\t \n\n\t\t \n\t\tnext = np->cur_tx_copy->next_desc_logical;\n\t\tnext->skbuff = skb;\n\t\tnext->control = TXIC | TXLD | CRCEnable | PADEnable;\n\t\tnext->control |= (skb->len << PKTSShift);\t \n\t\tnext->control |= ((skb->len - BPT) << TBSShift);\t \n\n\t\tif (np->pci_dev->device == 0x891)\n\t\t\tnp->cur_tx_copy->control |= ETIControl | RetryTxLC;\n\t\tnext->buffer = dma_map_single(&ep->pci_dev->dev,\n\t\t\t\t\t      skb->data + BPT, skb->len - BPT,\n\t\t\t\t\t      DMA_TO_DEVICE);\n\n\t\tnext->status = TXOWN;\n\t\tnp->cur_tx_copy->status = TXOWN;\n\n\t\tnp->cur_tx_copy = next->next_desc_logical;\n\t\tnp->free_tx_count -= 2;\n\t} else {\n\t\tnp->cur_tx_copy->buffer = dma_map_single(&np->pci_dev->dev,\n\t\t\t\t\t\t\t skb->data, skb->len,\n\t\t\t\t\t\t\t DMA_TO_DEVICE);\n\t\tnp->cur_tx_copy->control = TXIC | TXLD | TXFD | CRCEnable | PADEnable;\n\t\tnp->cur_tx_copy->control |= (skb->len << PKTSShift);\t \n\t\tnp->cur_tx_copy->control |= (skb->len << TBSShift);\t \n\n\t\tif (np->pci_dev->device == 0x891)\n\t\t\tnp->cur_tx_copy->control |= ETIControl | RetryTxLC;\n\t\tnp->cur_tx_copy->status = TXOWN;\n\t\tnp->cur_tx_copy = np->cur_tx_copy->next_desc_logical;\n\t\t--np->free_tx_count;\n\t}\n#endif\n\n\tif (np->free_tx_count < 2)\n\t\tnetif_stop_queue(dev);\n\t++np->really_tx_count;\n\tiowrite32(0, np->mem + TXPDR);\n\n\tspin_unlock_irqrestore(&np->lock, flags);\n\treturn NETDEV_TX_OK;\n}\n\n\n \n \nstatic void reset_tx_descriptors(struct net_device *dev)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tstruct fealnx_desc *cur;\n\tint i;\n\n\t \n\tnp->cur_tx = &np->tx_ring[0];\n\tnp->cur_tx_copy = &np->tx_ring[0];\n\tnp->really_tx_count = 0;\n\tnp->free_tx_count = TX_RING_SIZE;\n\n\tfor (i = 0; i < TX_RING_SIZE; i++) {\n\t\tcur = &np->tx_ring[i];\n\t\tif (cur->skbuff) {\n\t\t\tdma_unmap_single(&np->pci_dev->dev, cur->buffer,\n\t\t\t\t\t cur->skbuff->len, DMA_TO_DEVICE);\n\t\t\tdev_kfree_skb_any(cur->skbuff);\n\t\t\tcur->skbuff = NULL;\n\t\t}\n\t\tcur->status = 0;\n\t\tcur->control = 0;\t \n\t\t \n\t\tcur->next_desc = np->tx_ring_dma +\n\t\t\t(i + 1)*sizeof(struct fealnx_desc);\n\t\tcur->next_desc_logical = &np->tx_ring[i + 1];\n\t}\n\t \n\tnp->tx_ring[TX_RING_SIZE - 1].next_desc = np->tx_ring_dma;\n\tnp->tx_ring[TX_RING_SIZE - 1].next_desc_logical = &np->tx_ring[0];\n}\n\n\n \nstatic void reset_rx_descriptors(struct net_device *dev)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tstruct fealnx_desc *cur = np->cur_rx;\n\tint i;\n\n\tallocate_rx_buffers(dev);\n\n\tfor (i = 0; i < RX_RING_SIZE; i++) {\n\t\tif (cur->skbuff)\n\t\t\tcur->status = RXOWN;\n\t\tcur = cur->next_desc_logical;\n\t}\n\n\tiowrite32(np->rx_ring_dma + ((char*)np->cur_rx - (char*)np->rx_ring),\n\t\tnp->mem + RXLBA);\n}\n\n\n \nstatic irqreturn_t intr_handler(int irq, void *dev_instance)\n{\n\tstruct net_device *dev = (struct net_device *) dev_instance;\n\tstruct netdev_private *np = netdev_priv(dev);\n\tvoid __iomem *ioaddr = np->mem;\n\tlong boguscnt = max_interrupt_work;\n\tunsigned int num_tx = 0;\n\tint handled = 0;\n\n\tspin_lock(&np->lock);\n\n\tiowrite32(0, ioaddr + IMR);\n\n\tdo {\n\t\tu32 intr_status = ioread32(ioaddr + ISR);\n\n\t\t \n\t\tiowrite32(intr_status, ioaddr + ISR);\n\n\t\tif (debug)\n\t\t\tprintk(KERN_DEBUG \"%s: Interrupt, status %4.4x.\\n\", dev->name,\n\t\t\t       intr_status);\n\n\t\tif (!(intr_status & np->imrvalue))\n\t\t\tbreak;\n\n\t\thandled = 1;\n\n\n\n\n\n\n\n\n\n\n\t\tif (intr_status & TUNF)\n\t\t\tiowrite32(0, ioaddr + TXPDR);\n\n\t\tif (intr_status & CNTOVF) {\n\t\t\t \n\t\t\tdev->stats.rx_missed_errors +=\n\t\t\t\tioread32(ioaddr + TALLY) & 0x7fff;\n\n\t\t\t \n\t\t\tdev->stats.rx_crc_errors +=\n\t\t\t    (ioread32(ioaddr + TALLY) & 0x7fff0000) >> 16;\n\t\t}\n\n\t\tif (intr_status & (RI | RBU)) {\n\t\t\tif (intr_status & RI)\n\t\t\t\tnetdev_rx(dev);\n\t\t\telse {\n\t\t\t\tstop_nic_rx(ioaddr, np->crvalue);\n\t\t\t\treset_rx_descriptors(dev);\n\t\t\t\tiowrite32(np->crvalue, ioaddr + TCRRCR);\n\t\t\t}\n\t\t}\n\n\t\twhile (np->really_tx_count) {\n\t\t\tlong tx_status = np->cur_tx->status;\n\t\t\tlong tx_control = np->cur_tx->control;\n\n\t\t\tif (!(tx_control & TXLD)) {\t \n\t\t\t\tstruct fealnx_desc *next;\n\n\t\t\t\tnext = np->cur_tx->next_desc_logical;\n\t\t\t\ttx_status = next->status;\n\t\t\t\ttx_control = next->control;\n\t\t\t}\n\n\t\t\tif (tx_status & TXOWN)\n\t\t\t\tbreak;\n\n\t\t\tif (!(np->crvalue & CR_W_ENH)) {\n\t\t\t\tif (tx_status & (CSL | LC | EC | UDF | HF)) {\n\t\t\t\t\tdev->stats.tx_errors++;\n\t\t\t\t\tif (tx_status & EC)\n\t\t\t\t\t\tdev->stats.tx_aborted_errors++;\n\t\t\t\t\tif (tx_status & CSL)\n\t\t\t\t\t\tdev->stats.tx_carrier_errors++;\n\t\t\t\t\tif (tx_status & LC)\n\t\t\t\t\t\tdev->stats.tx_window_errors++;\n\t\t\t\t\tif (tx_status & UDF)\n\t\t\t\t\t\tdev->stats.tx_fifo_errors++;\n\t\t\t\t\tif ((tx_status & HF) && np->mii.full_duplex == 0)\n\t\t\t\t\t\tdev->stats.tx_heartbeat_errors++;\n\n\t\t\t\t} else {\n\t\t\t\t\tdev->stats.tx_bytes +=\n\t\t\t\t\t    ((tx_control & PKTSMask) >> PKTSShift);\n\n\t\t\t\t\tdev->stats.collisions +=\n\t\t\t\t\t    ((tx_status & NCRMask) >> NCRShift);\n\t\t\t\t\tdev->stats.tx_packets++;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdev->stats.tx_bytes +=\n\t\t\t\t    ((tx_control & PKTSMask) >> PKTSShift);\n\t\t\t\tdev->stats.tx_packets++;\n\t\t\t}\n\n\t\t\t \n\t\t\tdma_unmap_single(&np->pci_dev->dev,\n\t\t\t\t\t np->cur_tx->buffer,\n\t\t\t\t\t np->cur_tx->skbuff->len,\n\t\t\t\t\t DMA_TO_DEVICE);\n\t\t\tdev_consume_skb_irq(np->cur_tx->skbuff);\n\t\t\tnp->cur_tx->skbuff = NULL;\n\t\t\t--np->really_tx_count;\n\t\t\tif (np->cur_tx->control & TXLD) {\n\t\t\t\tnp->cur_tx = np->cur_tx->next_desc_logical;\n\t\t\t\t++np->free_tx_count;\n\t\t\t} else {\n\t\t\t\tnp->cur_tx = np->cur_tx->next_desc_logical;\n\t\t\t\tnp->cur_tx = np->cur_tx->next_desc_logical;\n\t\t\t\tnp->free_tx_count += 2;\n\t\t\t}\n\t\t\tnum_tx++;\n\t\t}\t\t \n\n\t\tif (num_tx && np->free_tx_count >= 2)\n\t\t\tnetif_wake_queue(dev);\n\n\t\t \n\t\tif (np->crvalue & CR_W_ENH) {\n\t\t\tlong data;\n\n\t\t\tdata = ioread32(ioaddr + TSR);\n\t\t\tdev->stats.tx_errors += (data & 0xff000000) >> 24;\n\t\t\tdev->stats.tx_aborted_errors +=\n\t\t\t\t(data & 0xff000000) >> 24;\n\t\t\tdev->stats.tx_window_errors +=\n\t\t\t\t(data & 0x00ff0000) >> 16;\n\t\t\tdev->stats.collisions += (data & 0x0000ffff);\n\t\t}\n\n\t\tif (--boguscnt < 0) {\n\t\t\tprintk(KERN_WARNING \"%s: Too much work at interrupt, \"\n\t\t\t       \"status=0x%4.4x.\\n\", dev->name, intr_status);\n\t\t\tif (!np->reset_timer_armed) {\n\t\t\t\tnp->reset_timer_armed = 1;\n\t\t\t\tnp->reset_timer.expires = RUN_AT(HZ/2);\n\t\t\t\tadd_timer(&np->reset_timer);\n\t\t\t\tstop_nic_rxtx(ioaddr, 0);\n\t\t\t\tnetif_stop_queue(dev);\n\t\t\t\t \n\t\t\t\t \n\t\t\t\tnp->crvalue_sv = np->crvalue;\n\t\t\t\tnp->imrvalue_sv = np->imrvalue;\n\t\t\t\tnp->crvalue &= ~(CR_W_TXEN | CR_W_RXEN);  \n\t\t\t\tnp->imrvalue = 0;\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\t} while (1);\n\n\t \n\t \n\tdev->stats.rx_missed_errors += ioread32(ioaddr + TALLY) & 0x7fff;\n\n\t \n\tdev->stats.rx_crc_errors +=\n\t\t(ioread32(ioaddr + TALLY) & 0x7fff0000) >> 16;\n\n\tif (debug)\n\t\tprintk(KERN_DEBUG \"%s: exiting interrupt, status=%#4.4x.\\n\",\n\t\t       dev->name, ioread32(ioaddr + ISR));\n\n\tiowrite32(np->imrvalue, ioaddr + IMR);\n\n\tspin_unlock(&np->lock);\n\n\treturn IRQ_RETVAL(handled);\n}\n\n\n \nstatic int netdev_rx(struct net_device *dev)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tvoid __iomem *ioaddr = np->mem;\n\n\t \n\twhile (!(np->cur_rx->status & RXOWN) && np->cur_rx->skbuff) {\n\t\ts32 rx_status = np->cur_rx->status;\n\n\t\tif (np->really_rx_count == 0)\n\t\t\tbreak;\n\n\t\tif (debug)\n\t\t\tprintk(KERN_DEBUG \"  netdev_rx() status was %8.8x.\\n\", rx_status);\n\n\t\tif ((!((rx_status & RXFSD) && (rx_status & RXLSD))) ||\n\t\t    (rx_status & ErrorSummary)) {\n\t\t\tif (rx_status & ErrorSummary) {\t \n\t\t\t\tif (debug)\n\t\t\t\t\tprintk(KERN_DEBUG\n\t\t\t\t\t       \"%s: Receive error, Rx status %8.8x.\\n\",\n\t\t\t\t\t       dev->name, rx_status);\n\n\t\t\t\tdev->stats.rx_errors++;\t \n\t\t\t\tif (rx_status & (LONGPKT | RUNTPKT))\n\t\t\t\t\tdev->stats.rx_length_errors++;\n\t\t\t\tif (rx_status & RXER)\n\t\t\t\t\tdev->stats.rx_frame_errors++;\n\t\t\t\tif (rx_status & CRC)\n\t\t\t\t\tdev->stats.rx_crc_errors++;\n\t\t\t} else {\n\t\t\t\tint need_to_reset = 0;\n\t\t\t\tint desno = 0;\n\n\t\t\t\tif (rx_status & RXFSD) {\t \n\t\t\t\t\tstruct fealnx_desc *cur;\n\n\t\t\t\t\t \n\t\t\t\t\tcur = np->cur_rx;\n\t\t\t\t\twhile (desno <= np->really_rx_count) {\n\t\t\t\t\t\t++desno;\n\t\t\t\t\t\tif ((!(cur->status & RXOWN)) &&\n\t\t\t\t\t\t    (cur->status & RXLSD))\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t \n\t\t\t\t\t\tcur = cur->next_desc_logical;\n\t\t\t\t\t}\n\t\t\t\t\tif (desno > np->really_rx_count)\n\t\t\t\t\t\tneed_to_reset = 1;\n\t\t\t\t} else\t \n\t\t\t\t\tneed_to_reset = 1;\n\n\t\t\t\tif (need_to_reset == 0) {\n\t\t\t\t\tint i;\n\n\t\t\t\t\tdev->stats.rx_length_errors++;\n\n\t\t\t\t\t \n\t\t\t\t\tfor (i = 0; i < desno; ++i) {\n\t\t\t\t\t\tif (!np->cur_rx->skbuff) {\n\t\t\t\t\t\t\tprintk(KERN_DEBUG\n\t\t\t\t\t\t\t\t\"%s: I'm scared\\n\", dev->name);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnp->cur_rx->status = RXOWN;\n\t\t\t\t\t\tnp->cur_rx = np->cur_rx->next_desc_logical;\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t} else {         \n\t\t\t\t\tstop_nic_rx(ioaddr, np->crvalue);\n\t\t\t\t\treset_rx_descriptors(dev);\n\t\t\t\t\tiowrite32(np->crvalue, ioaddr + TCRRCR);\n\t\t\t\t}\n\t\t\t\tbreak;\t \n\t\t\t}\n\t\t} else {\t \n\n\t\t\tstruct sk_buff *skb;\n\t\t\t \n\t\t\tshort pkt_len = ((rx_status & FLNGMASK) >> FLNGShift) - 4;\n\n#ifndef final_version\n\t\t\tif (debug)\n\t\t\t\tprintk(KERN_DEBUG \"  netdev_rx() normal Rx pkt length %d\"\n\t\t\t\t       \" status %x.\\n\", pkt_len, rx_status);\n#endif\n\n\t\t\t \n\t\t\tif (pkt_len < rx_copybreak &&\n\t\t\t    (skb = netdev_alloc_skb(dev, pkt_len + 2)) != NULL) {\n\t\t\t\tskb_reserve(skb, 2);\t \n\t\t\t\tdma_sync_single_for_cpu(&np->pci_dev->dev,\n\t\t\t\t\t\t\tnp->cur_rx->buffer,\n\t\t\t\t\t\t\tnp->rx_buf_sz,\n\t\t\t\t\t\t\tDMA_FROM_DEVICE);\n\t\t\t\t \n\n#if ! defined(__alpha__)\n\t\t\t\tskb_copy_to_linear_data(skb,\n\t\t\t\t\tnp->cur_rx->skbuff->data, pkt_len);\n\t\t\t\tskb_put(skb, pkt_len);\n#else\n\t\t\t\tskb_put_data(skb, np->cur_rx->skbuff->data,\n\t\t\t\t\t     pkt_len);\n#endif\n\t\t\t\tdma_sync_single_for_device(&np->pci_dev->dev,\n\t\t\t\t\t\t\t   np->cur_rx->buffer,\n\t\t\t\t\t\t\t   np->rx_buf_sz,\n\t\t\t\t\t\t\t   DMA_FROM_DEVICE);\n\t\t\t} else {\n\t\t\t\tdma_unmap_single(&np->pci_dev->dev,\n\t\t\t\t\t\t np->cur_rx->buffer,\n\t\t\t\t\t\t np->rx_buf_sz,\n\t\t\t\t\t\t DMA_FROM_DEVICE);\n\t\t\t\tskb_put(skb = np->cur_rx->skbuff, pkt_len);\n\t\t\t\tnp->cur_rx->skbuff = NULL;\n\t\t\t\t--np->really_rx_count;\n\t\t\t}\n\t\t\tskb->protocol = eth_type_trans(skb, dev);\n\t\t\tnetif_rx(skb);\n\t\t\tdev->stats.rx_packets++;\n\t\t\tdev->stats.rx_bytes += pkt_len;\n\t\t}\n\n\t\tnp->cur_rx = np->cur_rx->next_desc_logical;\n\t}\t\t\t \n\n\t \n\tallocate_rx_buffers(dev);\n\n\treturn 0;\n}\n\n\nstatic struct net_device_stats *get_stats(struct net_device *dev)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tvoid __iomem *ioaddr = np->mem;\n\n\t \n\tif (netif_running(dev)) {\n\t\tdev->stats.rx_missed_errors +=\n\t\t\tioread32(ioaddr + TALLY) & 0x7fff;\n\t\tdev->stats.rx_crc_errors +=\n\t\t\t(ioread32(ioaddr + TALLY) & 0x7fff0000) >> 16;\n\t}\n\n\treturn &dev->stats;\n}\n\n\n \nstatic void set_rx_mode(struct net_device *dev)\n{\n\tspinlock_t *lp = &((struct netdev_private *)netdev_priv(dev))->lock;\n\tunsigned long flags;\n\tspin_lock_irqsave(lp, flags);\n\t__set_rx_mode(dev);\n\tspin_unlock_irqrestore(lp, flags);\n}\n\n\n \nstatic void __set_rx_mode(struct net_device *dev)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tvoid __iomem *ioaddr = np->mem;\n\tu32 mc_filter[2];\t \n\tu32 rx_mode;\n\n\tif (dev->flags & IFF_PROMISC) {\t \n\t\tmemset(mc_filter, 0xff, sizeof(mc_filter));\n\t\trx_mode = CR_W_PROM | CR_W_AB | CR_W_AM;\n\t} else if ((netdev_mc_count(dev) > multicast_filter_limit) ||\n\t\t   (dev->flags & IFF_ALLMULTI)) {\n\t\t \n\t\tmemset(mc_filter, 0xff, sizeof(mc_filter));\n\t\trx_mode = CR_W_AB | CR_W_AM;\n\t} else {\n\t\tstruct netdev_hw_addr *ha;\n\n\t\tmemset(mc_filter, 0, sizeof(mc_filter));\n\t\tnetdev_for_each_mc_addr(ha, dev) {\n\t\t\tunsigned int bit;\n\t\t\tbit = (ether_crc(ETH_ALEN, ha->addr) >> 26) ^ 0x3F;\n\t\t\tmc_filter[bit >> 5] |= (1 << bit);\n\t\t}\n\t\trx_mode = CR_W_AB | CR_W_AM;\n\t}\n\n\tstop_nic_rxtx(ioaddr, np->crvalue);\n\n\tiowrite32(mc_filter[0], ioaddr + MAR0);\n\tiowrite32(mc_filter[1], ioaddr + MAR1);\n\tnp->crvalue &= ~CR_W_RXMODEMASK;\n\tnp->crvalue |= rx_mode;\n\tiowrite32(np->crvalue, ioaddr + TCRRCR);\n}\n\nstatic void netdev_get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *info)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\n\tstrscpy(info->driver, DRV_NAME, sizeof(info->driver));\n\tstrscpy(info->bus_info, pci_name(np->pci_dev), sizeof(info->bus_info));\n}\n\nstatic int netdev_get_link_ksettings(struct net_device *dev,\n\t\t\t\t     struct ethtool_link_ksettings *cmd)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\n\tspin_lock_irq(&np->lock);\n\tmii_ethtool_get_link_ksettings(&np->mii, cmd);\n\tspin_unlock_irq(&np->lock);\n\n\treturn 0;\n}\n\nstatic int netdev_set_link_ksettings(struct net_device *dev,\n\t\t\t\t     const struct ethtool_link_ksettings *cmd)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tint rc;\n\n\tspin_lock_irq(&np->lock);\n\trc = mii_ethtool_set_link_ksettings(&np->mii, cmd);\n\tspin_unlock_irq(&np->lock);\n\n\treturn rc;\n}\n\nstatic int netdev_nway_reset(struct net_device *dev)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\treturn mii_nway_restart(&np->mii);\n}\n\nstatic u32 netdev_get_link(struct net_device *dev)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\treturn mii_link_ok(&np->mii);\n}\n\nstatic u32 netdev_get_msglevel(struct net_device *dev)\n{\n\treturn debug;\n}\n\nstatic void netdev_set_msglevel(struct net_device *dev, u32 value)\n{\n\tdebug = value;\n}\n\nstatic const struct ethtool_ops netdev_ethtool_ops = {\n\t.get_drvinfo\t\t= netdev_get_drvinfo,\n\t.nway_reset\t\t= netdev_nway_reset,\n\t.get_link\t\t= netdev_get_link,\n\t.get_msglevel\t\t= netdev_get_msglevel,\n\t.set_msglevel\t\t= netdev_set_msglevel,\n\t.get_link_ksettings\t= netdev_get_link_ksettings,\n\t.set_link_ksettings\t= netdev_set_link_ksettings,\n};\n\nstatic int mii_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tint rc;\n\n\tif (!netif_running(dev))\n\t\treturn -EINVAL;\n\n\tspin_lock_irq(&np->lock);\n\trc = generic_mii_ioctl(&np->mii, if_mii(rq), cmd, NULL);\n\tspin_unlock_irq(&np->lock);\n\n\treturn rc;\n}\n\n\nstatic int netdev_close(struct net_device *dev)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tvoid __iomem *ioaddr = np->mem;\n\tint i;\n\n\tnetif_stop_queue(dev);\n\n\t \n\tiowrite32(0x0000, ioaddr + IMR);\n\n\t \n\tstop_nic_rxtx(ioaddr, 0);\n\n\tdel_timer_sync(&np->timer);\n\tdel_timer_sync(&np->reset_timer);\n\n\tfree_irq(np->pci_dev->irq, dev);\n\n\t \n\tfor (i = 0; i < RX_RING_SIZE; i++) {\n\t\tstruct sk_buff *skb = np->rx_ring[i].skbuff;\n\n\t\tnp->rx_ring[i].status = 0;\n\t\tif (skb) {\n\t\t\tdma_unmap_single(&np->pci_dev->dev,\n\t\t\t\t\t np->rx_ring[i].buffer, np->rx_buf_sz,\n\t\t\t\t\t DMA_FROM_DEVICE);\n\t\t\tdev_kfree_skb(skb);\n\t\t\tnp->rx_ring[i].skbuff = NULL;\n\t\t}\n\t}\n\n\tfor (i = 0; i < TX_RING_SIZE; i++) {\n\t\tstruct sk_buff *skb = np->tx_ring[i].skbuff;\n\n\t\tif (skb) {\n\t\t\tdma_unmap_single(&np->pci_dev->dev,\n\t\t\t\t\t np->tx_ring[i].buffer, skb->len,\n\t\t\t\t\t DMA_TO_DEVICE);\n\t\t\tdev_kfree_skb(skb);\n\t\t\tnp->tx_ring[i].skbuff = NULL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic const struct pci_device_id fealnx_pci_tbl[] = {\n\t{0x1516, 0x0800, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},\n\t{0x1516, 0x0803, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 1},\n\t{0x1516, 0x0891, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 2},\n\t{}  \n};\nMODULE_DEVICE_TABLE(pci, fealnx_pci_tbl);\n\n\nstatic struct pci_driver fealnx_driver = {\n\t.name\t\t= \"fealnx\",\n\t.id_table\t= fealnx_pci_tbl,\n\t.probe\t\t= fealnx_init_one,\n\t.remove\t\t= fealnx_remove_one,\n};\n\nmodule_pci_driver(fealnx_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}