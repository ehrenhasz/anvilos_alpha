{
  "module_name": "qlcnic_sriov_common.c",
  "hash_id": "034ca27964dc2609236d9d315aed3c0515ddf580753b9c718006d0a47904a1c2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/qlogic/qlcnic/qlcnic_sriov_common.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n\n#include \"qlcnic_sriov.h\"\n#include \"qlcnic.h\"\n#include \"qlcnic_83xx_hw.h\"\n\n#define QLC_BC_COMMAND\t0\n#define QLC_BC_RESPONSE\t1\n\n#define QLC_MBOX_RESP_TIMEOUT\t\t(10 * HZ)\n#define QLC_MBOX_CH_FREE_TIMEOUT\t(10 * HZ)\n\n#define QLC_BC_MSG\t\t0\n#define QLC_BC_CFREE\t\t1\n#define QLC_BC_FLR\t\t2\n#define QLC_BC_HDR_SZ\t\t16\n#define QLC_BC_PAYLOAD_SZ\t(1024 - QLC_BC_HDR_SZ)\n\n#define QLC_DEFAULT_RCV_DESCRIPTORS_SRIOV_VF\t\t2048\n#define QLC_DEFAULT_JUMBO_RCV_DESCRIPTORS_SRIOV_VF\t512\n\n#define QLC_83XX_VF_RESET_FAIL_THRESH\t8\n#define QLC_BC_CMD_MAX_RETRY_CNT\t5\n\nstatic void qlcnic_sriov_handle_async_issue_cmd(struct work_struct *work);\nstatic void qlcnic_sriov_vf_free_mac_list(struct qlcnic_adapter *);\nstatic int qlcnic_sriov_alloc_bc_mbx_args(struct qlcnic_cmd_args *, u32);\nstatic void qlcnic_sriov_vf_poll_dev_state(struct work_struct *);\nstatic void qlcnic_sriov_vf_cancel_fw_work(struct qlcnic_adapter *);\nstatic void qlcnic_sriov_cleanup_transaction(struct qlcnic_bc_trans *);\nstatic int qlcnic_sriov_issue_cmd(struct qlcnic_adapter *,\n\t\t\t\t  struct qlcnic_cmd_args *);\nstatic int qlcnic_sriov_channel_cfg_cmd(struct qlcnic_adapter *, u8);\nstatic void qlcnic_sriov_process_bc_cmd(struct work_struct *);\nstatic int qlcnic_sriov_vf_shutdown(struct pci_dev *);\nstatic int qlcnic_sriov_vf_resume(struct qlcnic_adapter *);\nstatic int qlcnic_sriov_async_issue_cmd(struct qlcnic_adapter *,\n\t\t\t\t\tstruct qlcnic_cmd_args *);\n\nstatic struct qlcnic_hardware_ops qlcnic_sriov_vf_hw_ops = {\n\t.read_crb\t\t\t= qlcnic_83xx_read_crb,\n\t.write_crb\t\t\t= qlcnic_83xx_write_crb,\n\t.read_reg\t\t\t= qlcnic_83xx_rd_reg_indirect,\n\t.write_reg\t\t\t= qlcnic_83xx_wrt_reg_indirect,\n\t.get_mac_address\t\t= qlcnic_83xx_get_mac_address,\n\t.setup_intr\t\t\t= qlcnic_83xx_setup_intr,\n\t.alloc_mbx_args\t\t\t= qlcnic_83xx_alloc_mbx_args,\n\t.mbx_cmd\t\t\t= qlcnic_sriov_issue_cmd,\n\t.get_func_no\t\t\t= qlcnic_83xx_get_func_no,\n\t.api_lock\t\t\t= qlcnic_83xx_cam_lock,\n\t.api_unlock\t\t\t= qlcnic_83xx_cam_unlock,\n\t.process_lb_rcv_ring_diag\t= qlcnic_83xx_process_rcv_ring_diag,\n\t.create_rx_ctx\t\t\t= qlcnic_83xx_create_rx_ctx,\n\t.create_tx_ctx\t\t\t= qlcnic_83xx_create_tx_ctx,\n\t.del_rx_ctx\t\t\t= qlcnic_83xx_del_rx_ctx,\n\t.del_tx_ctx\t\t\t= qlcnic_83xx_del_tx_ctx,\n\t.setup_link_event\t\t= qlcnic_83xx_setup_link_event,\n\t.get_nic_info\t\t\t= qlcnic_83xx_get_nic_info,\n\t.get_pci_info\t\t\t= qlcnic_83xx_get_pci_info,\n\t.set_nic_info\t\t\t= qlcnic_83xx_set_nic_info,\n\t.change_macvlan\t\t\t= qlcnic_83xx_sre_macaddr_change,\n\t.napi_enable\t\t\t= qlcnic_83xx_napi_enable,\n\t.napi_disable\t\t\t= qlcnic_83xx_napi_disable,\n\t.config_intr_coal\t\t= qlcnic_83xx_config_intr_coal,\n\t.config_rss\t\t\t= qlcnic_83xx_config_rss,\n\t.config_hw_lro\t\t\t= qlcnic_83xx_config_hw_lro,\n\t.config_promisc_mode\t\t= qlcnic_83xx_nic_set_promisc,\n\t.change_l2_filter\t\t= qlcnic_83xx_change_l2_filter,\n\t.get_board_info\t\t\t= qlcnic_83xx_get_port_info,\n\t.free_mac_list\t\t\t= qlcnic_sriov_vf_free_mac_list,\n\t.enable_sds_intr\t\t= qlcnic_83xx_enable_sds_intr,\n\t.disable_sds_intr\t\t= qlcnic_83xx_disable_sds_intr,\n\t.encap_rx_offload               = qlcnic_83xx_encap_rx_offload,\n\t.encap_tx_offload               = qlcnic_83xx_encap_tx_offload,\n};\n\nstatic struct qlcnic_nic_template qlcnic_sriov_vf_ops = {\n\t.config_bridged_mode\t= qlcnic_config_bridged_mode,\n\t.config_led\t\t= qlcnic_config_led,\n\t.cancel_idc_work        = qlcnic_sriov_vf_cancel_fw_work,\n\t.napi_add\t\t= qlcnic_83xx_napi_add,\n\t.napi_del\t\t= qlcnic_83xx_napi_del,\n\t.shutdown\t\t= qlcnic_sriov_vf_shutdown,\n\t.resume\t\t\t= qlcnic_sriov_vf_resume,\n\t.config_ipaddr\t\t= qlcnic_83xx_config_ipaddr,\n\t.clear_legacy_intr\t= qlcnic_83xx_clear_legacy_intr,\n};\n\nstatic const struct qlcnic_mailbox_metadata qlcnic_sriov_bc_mbx_tbl[] = {\n\t{QLCNIC_BC_CMD_CHANNEL_INIT, 2, 2},\n\t{QLCNIC_BC_CMD_CHANNEL_TERM, 2, 2},\n\t{QLCNIC_BC_CMD_GET_ACL, 3, 14},\n\t{QLCNIC_BC_CMD_CFG_GUEST_VLAN, 2, 2},\n};\n\nstatic inline bool qlcnic_sriov_bc_msg_check(u32 val)\n{\n\treturn (val & (1 << QLC_BC_MSG)) ? true : false;\n}\n\nstatic inline bool qlcnic_sriov_channel_free_check(u32 val)\n{\n\treturn (val & (1 << QLC_BC_CFREE)) ? true : false;\n}\n\nstatic inline bool qlcnic_sriov_flr_check(u32 val)\n{\n\treturn (val & (1 << QLC_BC_FLR)) ? true : false;\n}\n\nstatic inline u8 qlcnic_sriov_target_func_id(u32 val)\n{\n\treturn (val >> 4) & 0xff;\n}\n\nstatic int qlcnic_sriov_virtid_fn(struct qlcnic_adapter *adapter, int vf_id)\n{\n\tstruct pci_dev *dev = adapter->pdev;\n\tint pos;\n\tu16 stride, offset;\n\n\tif (qlcnic_sriov_vf_check(adapter))\n\t\treturn 0;\n\n\tpos = pci_find_ext_capability(dev, PCI_EXT_CAP_ID_SRIOV);\n\tif (!pos)\n\t\treturn 0;\n\tpci_read_config_word(dev, pos + PCI_SRIOV_VF_OFFSET, &offset);\n\tpci_read_config_word(dev, pos + PCI_SRIOV_VF_STRIDE, &stride);\n\n\treturn (dev->devfn + offset + stride * vf_id) & 0xff;\n}\n\nint qlcnic_sriov_init(struct qlcnic_adapter *adapter, int num_vfs)\n{\n\tstruct qlcnic_sriov *sriov;\n\tstruct qlcnic_back_channel *bc;\n\tstruct workqueue_struct *wq;\n\tstruct qlcnic_vport *vp;\n\tstruct qlcnic_vf_info *vf;\n\tint err, i;\n\n\tif (!qlcnic_sriov_enable_check(adapter))\n\t\treturn -EIO;\n\n\tsriov  = kzalloc(sizeof(struct qlcnic_sriov), GFP_KERNEL);\n\tif (!sriov)\n\t\treturn -ENOMEM;\n\n\tadapter->ahw->sriov = sriov;\n\tsriov->num_vfs = num_vfs;\n\tbc = &sriov->bc;\n\tsriov->vf_info = kcalloc(num_vfs, sizeof(struct qlcnic_vf_info),\n\t\t\t\t GFP_KERNEL);\n\tif (!sriov->vf_info) {\n\t\terr = -ENOMEM;\n\t\tgoto qlcnic_free_sriov;\n\t}\n\n\twq = create_singlethread_workqueue(\"bc-trans\");\n\tif (wq == NULL) {\n\t\terr = -ENOMEM;\n\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\"Cannot create bc-trans workqueue\\n\");\n\t\tgoto qlcnic_free_vf_info;\n\t}\n\n\tbc->bc_trans_wq = wq;\n\n\twq = create_singlethread_workqueue(\"async\");\n\tif (wq == NULL) {\n\t\terr = -ENOMEM;\n\t\tdev_err(&adapter->pdev->dev, \"Cannot create async workqueue\\n\");\n\t\tgoto qlcnic_destroy_trans_wq;\n\t}\n\n\tbc->bc_async_wq =  wq;\n\tINIT_LIST_HEAD(&bc->async_cmd_list);\n\tINIT_WORK(&bc->vf_async_work, qlcnic_sriov_handle_async_issue_cmd);\n\tspin_lock_init(&bc->queue_lock);\n\tbc->adapter = adapter;\n\n\tfor (i = 0; i < num_vfs; i++) {\n\t\tvf = &sriov->vf_info[i];\n\t\tvf->adapter = adapter;\n\t\tvf->pci_func = qlcnic_sriov_virtid_fn(adapter, i);\n\t\tmutex_init(&vf->send_cmd_lock);\n\t\tspin_lock_init(&vf->vlan_list_lock);\n\t\tINIT_LIST_HEAD(&vf->rcv_act.wait_list);\n\t\tINIT_LIST_HEAD(&vf->rcv_pend.wait_list);\n\t\tspin_lock_init(&vf->rcv_act.lock);\n\t\tspin_lock_init(&vf->rcv_pend.lock);\n\t\tinit_completion(&vf->ch_free_cmpl);\n\n\t\tINIT_WORK(&vf->trans_work, qlcnic_sriov_process_bc_cmd);\n\n\t\tif (qlcnic_sriov_pf_check(adapter)) {\n\t\t\tvp = kzalloc(sizeof(struct qlcnic_vport), GFP_KERNEL);\n\t\t\tif (!vp) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto qlcnic_destroy_async_wq;\n\t\t\t}\n\t\t\tsriov->vf_info[i].vp = vp;\n\t\t\tvp->vlan_mode = QLC_GUEST_VLAN_MODE;\n\t\t\tvp->max_tx_bw = MAX_BW;\n\t\t\tvp->min_tx_bw = MIN_BW;\n\t\t\tvp->spoofchk = false;\n\t\t\teth_random_addr(vp->mac);\n\t\t\tdev_info(&adapter->pdev->dev,\n\t\t\t\t \"MAC Address %pM is configured for VF %d\\n\",\n\t\t\t\t vp->mac, i);\n\t\t}\n\t}\n\n\treturn 0;\n\nqlcnic_destroy_async_wq:\n\twhile (i--)\n\t\tkfree(sriov->vf_info[i].vp);\n\tdestroy_workqueue(bc->bc_async_wq);\n\nqlcnic_destroy_trans_wq:\n\tdestroy_workqueue(bc->bc_trans_wq);\n\nqlcnic_free_vf_info:\n\tkfree(sriov->vf_info);\n\nqlcnic_free_sriov:\n\tkfree(adapter->ahw->sriov);\n\treturn err;\n}\n\nvoid qlcnic_sriov_cleanup_list(struct qlcnic_trans_list *t_list)\n{\n\tstruct qlcnic_bc_trans *trans;\n\tstruct qlcnic_cmd_args cmd;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&t_list->lock, flags);\n\n\twhile (!list_empty(&t_list->wait_list)) {\n\t\ttrans = list_first_entry(&t_list->wait_list,\n\t\t\t\t\t struct qlcnic_bc_trans, list);\n\t\tlist_del(&trans->list);\n\t\tt_list->count--;\n\t\tcmd.req.arg = (u32 *)trans->req_pay;\n\t\tcmd.rsp.arg = (u32 *)trans->rsp_pay;\n\t\tqlcnic_free_mbx_args(&cmd);\n\t\tqlcnic_sriov_cleanup_transaction(trans);\n\t}\n\n\tspin_unlock_irqrestore(&t_list->lock, flags);\n}\n\nvoid __qlcnic_sriov_cleanup(struct qlcnic_adapter *adapter)\n{\n\tstruct qlcnic_sriov *sriov = adapter->ahw->sriov;\n\tstruct qlcnic_back_channel *bc = &sriov->bc;\n\tstruct qlcnic_vf_info *vf;\n\tint i;\n\n\tif (!qlcnic_sriov_enable_check(adapter))\n\t\treturn;\n\n\tqlcnic_sriov_cleanup_async_list(bc);\n\tdestroy_workqueue(bc->bc_async_wq);\n\n\tfor (i = 0; i < sriov->num_vfs; i++) {\n\t\tvf = &sriov->vf_info[i];\n\t\tqlcnic_sriov_cleanup_list(&vf->rcv_pend);\n\t\tcancel_work_sync(&vf->trans_work);\n\t\tqlcnic_sriov_cleanup_list(&vf->rcv_act);\n\t}\n\n\tdestroy_workqueue(bc->bc_trans_wq);\n\n\tfor (i = 0; i < sriov->num_vfs; i++)\n\t\tkfree(sriov->vf_info[i].vp);\n\n\tkfree(sriov->vf_info);\n\tkfree(adapter->ahw->sriov);\n}\n\nstatic void qlcnic_sriov_vf_cleanup(struct qlcnic_adapter *adapter)\n{\n\tqlcnic_sriov_channel_cfg_cmd(adapter, QLCNIC_BC_CMD_CHANNEL_TERM);\n\tqlcnic_sriov_cfg_bc_intr(adapter, 0);\n\t__qlcnic_sriov_cleanup(adapter);\n}\n\nvoid qlcnic_sriov_cleanup(struct qlcnic_adapter *adapter)\n{\n\tif (!test_bit(__QLCNIC_SRIOV_ENABLE, &adapter->state))\n\t\treturn;\n\n\tqlcnic_sriov_free_vlans(adapter);\n\n\tif (qlcnic_sriov_pf_check(adapter))\n\t\tqlcnic_sriov_pf_cleanup(adapter);\n\n\tif (qlcnic_sriov_vf_check(adapter))\n\t\tqlcnic_sriov_vf_cleanup(adapter);\n}\n\nstatic int qlcnic_sriov_post_bc_msg(struct qlcnic_adapter *adapter, u32 *hdr,\n\t\t\t\t    u32 *pay, u8 pci_func, u8 size)\n{\n\tstruct qlcnic_hardware_context *ahw = adapter->ahw;\n\tstruct qlcnic_mailbox *mbx = ahw->mailbox;\n\tstruct qlcnic_cmd_args cmd;\n\tunsigned long timeout;\n\tint err;\n\n\tmemset(&cmd, 0, sizeof(struct qlcnic_cmd_args));\n\tcmd.hdr = hdr;\n\tcmd.pay = pay;\n\tcmd.pay_size = size;\n\tcmd.func_num = pci_func;\n\tcmd.op_type = QLC_83XX_MBX_POST_BC_OP;\n\tcmd.cmd_op = ((struct qlcnic_bc_hdr *)hdr)->cmd_op;\n\n\terr = mbx->ops->enqueue_cmd(adapter, &cmd, &timeout);\n\tif (err) {\n\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\"%s: Mailbox not available, cmd_op=0x%x, cmd_type=0x%x, pci_func=0x%x, op_mode=0x%x\\n\",\n\t\t\t__func__, cmd.cmd_op, cmd.type, ahw->pci_func,\n\t\t\tahw->op_mode);\n\t\treturn err;\n\t}\n\n\tif (!wait_for_completion_timeout(&cmd.completion, timeout)) {\n\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\"%s: Mailbox command timed out, cmd_op=0x%x, cmd_type=0x%x, pci_func=0x%x, op_mode=0x%x\\n\",\n\t\t\t__func__, cmd.cmd_op, cmd.type, ahw->pci_func,\n\t\t\tahw->op_mode);\n\t\tflush_workqueue(mbx->work_q);\n\t}\n\n\treturn cmd.rsp_opcode;\n}\n\nstatic void qlcnic_sriov_vf_cfg_buff_desc(struct qlcnic_adapter *adapter)\n{\n\tadapter->num_rxd = QLC_DEFAULT_RCV_DESCRIPTORS_SRIOV_VF;\n\tadapter->max_rxd = MAX_RCV_DESCRIPTORS_10G;\n\tadapter->num_jumbo_rxd = QLC_DEFAULT_JUMBO_RCV_DESCRIPTORS_SRIOV_VF;\n\tadapter->max_jumbo_rxd = MAX_JUMBO_RCV_DESCRIPTORS_10G;\n\tadapter->num_txd = MAX_CMD_DESCRIPTORS;\n\tadapter->max_rds_rings = MAX_RDS_RINGS;\n}\n\nint qlcnic_sriov_get_vf_vport_info(struct qlcnic_adapter *adapter,\n\t\t\t\t   struct qlcnic_info *npar_info, u16 vport_id)\n{\n\tstruct device *dev = &adapter->pdev->dev;\n\tstruct qlcnic_cmd_args cmd;\n\tint err;\n\tu32 status;\n\n\terr = qlcnic_alloc_mbx_args(&cmd, adapter, QLCNIC_CMD_GET_NIC_INFO);\n\tif (err)\n\t\treturn err;\n\n\tcmd.req.arg[1] = vport_id << 16 | 0x1;\n\terr = qlcnic_issue_cmd(adapter, &cmd);\n\tif (err) {\n\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\"Failed to get vport info, err=%d\\n\", err);\n\t\tqlcnic_free_mbx_args(&cmd);\n\t\treturn err;\n\t}\n\n\tstatus = cmd.rsp.arg[2] & 0xffff;\n\tif (status & BIT_0)\n\t\tnpar_info->min_tx_bw = MSW(cmd.rsp.arg[2]);\n\tif (status & BIT_1)\n\t\tnpar_info->max_tx_bw = LSW(cmd.rsp.arg[3]);\n\tif (status & BIT_2)\n\t\tnpar_info->max_tx_ques = MSW(cmd.rsp.arg[3]);\n\tif (status & BIT_3)\n\t\tnpar_info->max_tx_mac_filters = LSW(cmd.rsp.arg[4]);\n\tif (status & BIT_4)\n\t\tnpar_info->max_rx_mcast_mac_filters = MSW(cmd.rsp.arg[4]);\n\tif (status & BIT_5)\n\t\tnpar_info->max_rx_ucast_mac_filters = LSW(cmd.rsp.arg[5]);\n\tif (status & BIT_6)\n\t\tnpar_info->max_rx_ip_addr = MSW(cmd.rsp.arg[5]);\n\tif (status & BIT_7)\n\t\tnpar_info->max_rx_lro_flow = LSW(cmd.rsp.arg[6]);\n\tif (status & BIT_8)\n\t\tnpar_info->max_rx_status_rings = MSW(cmd.rsp.arg[6]);\n\tif (status & BIT_9)\n\t\tnpar_info->max_rx_buf_rings = LSW(cmd.rsp.arg[7]);\n\n\tnpar_info->max_rx_ques = MSW(cmd.rsp.arg[7]);\n\tnpar_info->max_tx_vlan_keys = LSW(cmd.rsp.arg[8]);\n\tnpar_info->max_local_ipv6_addrs = MSW(cmd.rsp.arg[8]);\n\tnpar_info->max_remote_ipv6_addrs = LSW(cmd.rsp.arg[9]);\n\n\tdev_info(dev, \"\\n\\tmin_tx_bw: %d, max_tx_bw: %d max_tx_ques: %d,\\n\"\n\t\t \"\\tmax_tx_mac_filters: %d max_rx_mcast_mac_filters: %d,\\n\"\n\t\t \"\\tmax_rx_ucast_mac_filters: 0x%x, max_rx_ip_addr: %d,\\n\"\n\t\t \"\\tmax_rx_lro_flow: %d max_rx_status_rings: %d,\\n\"\n\t\t \"\\tmax_rx_buf_rings: %d, max_rx_ques: %d, max_tx_vlan_keys %d\\n\"\n\t\t \"\\tlocal_ipv6_addr: %d, remote_ipv6_addr: %d\\n\",\n\t\t npar_info->min_tx_bw, npar_info->max_tx_bw,\n\t\t npar_info->max_tx_ques, npar_info->max_tx_mac_filters,\n\t\t npar_info->max_rx_mcast_mac_filters,\n\t\t npar_info->max_rx_ucast_mac_filters, npar_info->max_rx_ip_addr,\n\t\t npar_info->max_rx_lro_flow, npar_info->max_rx_status_rings,\n\t\t npar_info->max_rx_buf_rings, npar_info->max_rx_ques,\n\t\t npar_info->max_tx_vlan_keys, npar_info->max_local_ipv6_addrs,\n\t\t npar_info->max_remote_ipv6_addrs);\n\n\tqlcnic_free_mbx_args(&cmd);\n\treturn err;\n}\n\nstatic int qlcnic_sriov_set_pvid_mode(struct qlcnic_adapter *adapter,\n\t\t\t\t      struct qlcnic_cmd_args *cmd)\n{\n\tadapter->rx_pvid = MSW(cmd->rsp.arg[1]) & 0xffff;\n\tadapter->flags &= ~QLCNIC_TAGGING_ENABLED;\n\treturn 0;\n}\n\nstatic int qlcnic_sriov_set_guest_vlan_mode(struct qlcnic_adapter *adapter,\n\t\t\t\t\t    struct qlcnic_cmd_args *cmd)\n{\n\tstruct qlcnic_sriov *sriov = adapter->ahw->sriov;\n\tint i, num_vlans, ret;\n\tu16 *vlans;\n\n\tif (sriov->allowed_vlans)\n\t\treturn 0;\n\n\tsriov->any_vlan = cmd->rsp.arg[2] & 0xf;\n\tsriov->num_allowed_vlans = cmd->rsp.arg[2] >> 16;\n\tdev_info(&adapter->pdev->dev, \"Number of allowed Guest VLANs = %d\\n\",\n\t\t sriov->num_allowed_vlans);\n\n\tret = qlcnic_sriov_alloc_vlans(adapter);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!sriov->any_vlan)\n\t\treturn 0;\n\n\tnum_vlans = sriov->num_allowed_vlans;\n\tsriov->allowed_vlans = kcalloc(num_vlans, sizeof(u16), GFP_KERNEL);\n\tif (!sriov->allowed_vlans)\n\t\treturn -ENOMEM;\n\n\tvlans = (u16 *)&cmd->rsp.arg[3];\n\tfor (i = 0; i < num_vlans; i++)\n\t\tsriov->allowed_vlans[i] = vlans[i];\n\n\treturn 0;\n}\n\nstatic int qlcnic_sriov_get_vf_acl(struct qlcnic_adapter *adapter)\n{\n\tstruct qlcnic_sriov *sriov = adapter->ahw->sriov;\n\tstruct qlcnic_cmd_args cmd;\n\tint ret = 0;\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\tret = qlcnic_sriov_alloc_bc_mbx_args(&cmd, QLCNIC_BC_CMD_GET_ACL);\n\tif (ret)\n\t\treturn ret;\n\n\tret = qlcnic_issue_cmd(adapter, &cmd);\n\tif (ret) {\n\t\tdev_err(&adapter->pdev->dev, \"Failed to get ACL, err=%d\\n\",\n\t\t\tret);\n\t} else {\n\t\tsriov->vlan_mode = cmd.rsp.arg[1] & 0x3;\n\t\tswitch (sriov->vlan_mode) {\n\t\tcase QLC_GUEST_VLAN_MODE:\n\t\t\tret = qlcnic_sriov_set_guest_vlan_mode(adapter, &cmd);\n\t\t\tbreak;\n\t\tcase QLC_PVID_MODE:\n\t\t\tret = qlcnic_sriov_set_pvid_mode(adapter, &cmd);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tqlcnic_free_mbx_args(&cmd);\n\treturn ret;\n}\n\nstatic int qlcnic_sriov_vf_init_driver(struct qlcnic_adapter *adapter)\n{\n\tstruct qlcnic_hardware_context *ahw = adapter->ahw;\n\tstruct qlcnic_info nic_info;\n\tint err;\n\n\terr = qlcnic_sriov_get_vf_vport_info(adapter, &nic_info, 0);\n\tif (err)\n\t\treturn err;\n\n\tahw->max_mc_count = nic_info.max_rx_mcast_mac_filters;\n\n\terr = qlcnic_get_nic_info(adapter, &nic_info, ahw->pci_func);\n\tif (err)\n\t\treturn -EIO;\n\n\tif (qlcnic_83xx_get_port_info(adapter))\n\t\treturn -EIO;\n\n\tqlcnic_sriov_vf_cfg_buff_desc(adapter);\n\tadapter->flags |= QLCNIC_ADAPTER_INITIALIZED;\n\tdev_info(&adapter->pdev->dev, \"HAL Version: %d\\n\",\n\t\t adapter->ahw->fw_hal_version);\n\n\tahw->physical_port = (u8) nic_info.phys_port;\n\tahw->switch_mode = nic_info.switch_mode;\n\tahw->max_mtu = nic_info.max_mtu;\n\tahw->op_mode = nic_info.op_mode;\n\tahw->capabilities = nic_info.capabilities;\n\treturn 0;\n}\n\nstatic int qlcnic_sriov_setup_vf(struct qlcnic_adapter *adapter)\n{\n\tint err;\n\n\tadapter->flags |= QLCNIC_VLAN_FILTERING;\n\tadapter->ahw->total_nic_func = 1;\n\tINIT_LIST_HEAD(&adapter->vf_mc_list);\n\tif (!qlcnic_use_msi_x && !!qlcnic_use_msi)\n\t\tdev_warn(&adapter->pdev->dev,\n\t\t\t \"Device does not support MSI interrupts\\n\");\n\n\t \n\tqlcnic_set_tx_ring_count(adapter, QLCNIC_SINGLE_RING);\n\tqlcnic_set_sds_ring_count(adapter, QLCNIC_SINGLE_RING);\n\n\terr = qlcnic_setup_intr(adapter);\n\tif (err) {\n\t\tdev_err(&adapter->pdev->dev, \"Failed to setup interrupt\\n\");\n\t\tgoto err_out_disable_msi;\n\t}\n\n\terr = qlcnic_83xx_setup_mbx_intr(adapter);\n\tif (err)\n\t\tgoto err_out_disable_msi;\n\n\terr = qlcnic_sriov_init(adapter, 1);\n\tif (err)\n\t\tgoto err_out_disable_mbx_intr;\n\n\terr = qlcnic_sriov_cfg_bc_intr(adapter, 1);\n\tif (err)\n\t\tgoto err_out_cleanup_sriov;\n\n\terr = qlcnic_sriov_channel_cfg_cmd(adapter, QLCNIC_BC_CMD_CHANNEL_INIT);\n\tif (err)\n\t\tgoto err_out_disable_bc_intr;\n\n\terr = qlcnic_sriov_vf_init_driver(adapter);\n\tif (err)\n\t\tgoto err_out_send_channel_term;\n\n\terr = qlcnic_sriov_get_vf_acl(adapter);\n\tif (err)\n\t\tgoto err_out_send_channel_term;\n\n\terr = qlcnic_setup_netdev(adapter, adapter->netdev);\n\tif (err)\n\t\tgoto err_out_send_channel_term;\n\n\tpci_set_drvdata(adapter->pdev, adapter);\n\tdev_info(&adapter->pdev->dev, \"%s: XGbE port initialized\\n\",\n\t\t adapter->netdev->name);\n\n\tqlcnic_schedule_work(adapter, qlcnic_sriov_vf_poll_dev_state,\n\t\t\t     adapter->ahw->idc.delay);\n\treturn 0;\n\nerr_out_send_channel_term:\n\tqlcnic_sriov_channel_cfg_cmd(adapter, QLCNIC_BC_CMD_CHANNEL_TERM);\n\nerr_out_disable_bc_intr:\n\tqlcnic_sriov_cfg_bc_intr(adapter, 0);\n\nerr_out_cleanup_sriov:\n\t__qlcnic_sriov_cleanup(adapter);\n\nerr_out_disable_mbx_intr:\n\tqlcnic_83xx_free_mbx_intr(adapter);\n\nerr_out_disable_msi:\n\tqlcnic_teardown_intr(adapter);\n\treturn err;\n}\n\nstatic int qlcnic_sriov_check_dev_ready(struct qlcnic_adapter *adapter)\n{\n\tu32 state;\n\n\tdo {\n\t\tmsleep(20);\n\t\tif (++adapter->fw_fail_cnt > QLC_BC_CMD_MAX_RETRY_CNT)\n\t\t\treturn -EIO;\n\t\tstate = QLCRDX(adapter->ahw, QLC_83XX_IDC_DEV_STATE);\n\t} while (state != QLC_83XX_IDC_DEV_READY);\n\n\treturn 0;\n}\n\nint qlcnic_sriov_vf_init(struct qlcnic_adapter *adapter)\n{\n\tstruct qlcnic_hardware_context *ahw = adapter->ahw;\n\tint err;\n\n\tset_bit(QLC_83XX_MODULE_LOADED, &ahw->idc.status);\n\tahw->idc.delay = QLC_83XX_IDC_FW_POLL_DELAY;\n\tahw->reset_context = 0;\n\tadapter->fw_fail_cnt = 0;\n\tahw->msix_supported = 1;\n\tadapter->need_fw_reset = 0;\n\tadapter->flags |= QLCNIC_TX_INTR_SHARED;\n\n\terr = qlcnic_sriov_check_dev_ready(adapter);\n\tif (err)\n\t\treturn err;\n\n\terr = qlcnic_sriov_setup_vf(adapter);\n\tif (err)\n\t\treturn err;\n\n\tif (qlcnic_read_mac_addr(adapter))\n\t\tdev_warn(&adapter->pdev->dev, \"failed to read mac addr\\n\");\n\n\tINIT_DELAYED_WORK(&adapter->idc_aen_work, qlcnic_83xx_idc_aen_work);\n\n\tclear_bit(__QLCNIC_RESETTING, &adapter->state);\n\treturn 0;\n}\n\nvoid qlcnic_sriov_vf_set_ops(struct qlcnic_adapter *adapter)\n{\n\tstruct qlcnic_hardware_context *ahw = adapter->ahw;\n\n\tahw->op_mode = QLCNIC_SRIOV_VF_FUNC;\n\tdev_info(&adapter->pdev->dev,\n\t\t \"HAL Version: %d Non Privileged SRIOV function\\n\",\n\t\t ahw->fw_hal_version);\n\tadapter->nic_ops = &qlcnic_sriov_vf_ops;\n\tset_bit(__QLCNIC_SRIOV_ENABLE, &adapter->state);\n\treturn;\n}\n\nvoid qlcnic_sriov_vf_register_map(struct qlcnic_hardware_context *ahw)\n{\n\tahw->hw_ops\t\t= &qlcnic_sriov_vf_hw_ops;\n\tahw->reg_tbl\t\t= (u32 *)qlcnic_83xx_reg_tbl;\n\tahw->ext_reg_tbl\t= (u32 *)qlcnic_83xx_ext_reg_tbl;\n}\n\nstatic u32 qlcnic_sriov_get_bc_paysize(u32 real_pay_size, u8 curr_frag)\n{\n\tu32 pay_size;\n\n\tpay_size = real_pay_size / ((curr_frag + 1) * QLC_BC_PAYLOAD_SZ);\n\n\tif (pay_size)\n\t\tpay_size = QLC_BC_PAYLOAD_SZ;\n\telse\n\t\tpay_size = real_pay_size % QLC_BC_PAYLOAD_SZ;\n\n\treturn pay_size;\n}\n\nint qlcnic_sriov_func_to_index(struct qlcnic_adapter *adapter, u8 pci_func)\n{\n\tstruct qlcnic_vf_info *vf_info = adapter->ahw->sriov->vf_info;\n\tu8 i;\n\n\tif (qlcnic_sriov_vf_check(adapter))\n\t\treturn 0;\n\n\tfor (i = 0; i < adapter->ahw->sriov->num_vfs; i++) {\n\t\tif (vf_info[i].pci_func == pci_func)\n\t\t\treturn i;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic inline int qlcnic_sriov_alloc_bc_trans(struct qlcnic_bc_trans **trans)\n{\n\t*trans = kzalloc(sizeof(struct qlcnic_bc_trans), GFP_ATOMIC);\n\tif (!*trans)\n\t\treturn -ENOMEM;\n\n\tinit_completion(&(*trans)->resp_cmpl);\n\treturn 0;\n}\n\nstatic inline int qlcnic_sriov_alloc_bc_msg(struct qlcnic_bc_hdr **hdr,\n\t\t\t\t\t    u32 size)\n{\n\t*hdr = kcalloc(size, sizeof(struct qlcnic_bc_hdr), GFP_ATOMIC);\n\tif (!*hdr)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic int qlcnic_sriov_alloc_bc_mbx_args(struct qlcnic_cmd_args *mbx, u32 type)\n{\n\tconst struct qlcnic_mailbox_metadata *mbx_tbl;\n\tint i, size;\n\n\tmbx_tbl = qlcnic_sriov_bc_mbx_tbl;\n\tsize = ARRAY_SIZE(qlcnic_sriov_bc_mbx_tbl);\n\n\tfor (i = 0; i < size; i++) {\n\t\tif (type == mbx_tbl[i].cmd) {\n\t\t\tmbx->op_type = QLC_BC_CMD;\n\t\t\tmbx->req.num = mbx_tbl[i].in_args;\n\t\t\tmbx->rsp.num = mbx_tbl[i].out_args;\n\t\t\tmbx->req.arg = kcalloc(mbx->req.num, sizeof(u32),\n\t\t\t\t\t       GFP_ATOMIC);\n\t\t\tif (!mbx->req.arg)\n\t\t\t\treturn -ENOMEM;\n\t\t\tmbx->rsp.arg = kcalloc(mbx->rsp.num, sizeof(u32),\n\t\t\t\t\t       GFP_ATOMIC);\n\t\t\tif (!mbx->rsp.arg) {\n\t\t\t\tkfree(mbx->req.arg);\n\t\t\t\tmbx->req.arg = NULL;\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tmbx->req.arg[0] = (type | (mbx->req.num << 16) |\n\t\t\t\t\t   (3 << 29));\n\t\t\tmbx->rsp.arg[0] = (type & 0xffff) | mbx->rsp.num << 16;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -EINVAL;\n}\n\nstatic int qlcnic_sriov_prepare_bc_hdr(struct qlcnic_bc_trans *trans,\n\t\t\t\t       struct qlcnic_cmd_args *cmd,\n\t\t\t\t       u16 seq, u8 msg_type)\n{\n\tstruct qlcnic_bc_hdr *hdr;\n\tint i;\n\tu32 num_regs, bc_pay_sz;\n\tu16 remainder;\n\tu8 cmd_op, num_frags, t_num_frags;\n\n\tbc_pay_sz = QLC_BC_PAYLOAD_SZ;\n\tif (msg_type == QLC_BC_COMMAND) {\n\t\ttrans->req_pay = (struct qlcnic_bc_payload *)cmd->req.arg;\n\t\ttrans->rsp_pay = (struct qlcnic_bc_payload *)cmd->rsp.arg;\n\t\tnum_regs = cmd->req.num;\n\t\ttrans->req_pay_size = (num_regs * 4);\n\t\tnum_regs = cmd->rsp.num;\n\t\ttrans->rsp_pay_size = (num_regs * 4);\n\t\tcmd_op = cmd->req.arg[0] & 0xff;\n\t\tremainder = (trans->req_pay_size) % (bc_pay_sz);\n\t\tnum_frags = (trans->req_pay_size) / (bc_pay_sz);\n\t\tif (remainder)\n\t\t\tnum_frags++;\n\t\tt_num_frags = num_frags;\n\t\tif (qlcnic_sriov_alloc_bc_msg(&trans->req_hdr, num_frags))\n\t\t\treturn -ENOMEM;\n\t\tremainder = (trans->rsp_pay_size) % (bc_pay_sz);\n\t\tnum_frags = (trans->rsp_pay_size) / (bc_pay_sz);\n\t\tif (remainder)\n\t\t\tnum_frags++;\n\t\tif (qlcnic_sriov_alloc_bc_msg(&trans->rsp_hdr, num_frags))\n\t\t\treturn -ENOMEM;\n\t\tnum_frags  = t_num_frags;\n\t\thdr = trans->req_hdr;\n\t}  else {\n\t\tcmd->req.arg = (u32 *)trans->req_pay;\n\t\tcmd->rsp.arg = (u32 *)trans->rsp_pay;\n\t\tcmd_op = cmd->req.arg[0] & 0xff;\n\t\tcmd->cmd_op = cmd_op;\n\t\tremainder = (trans->rsp_pay_size) % (bc_pay_sz);\n\t\tnum_frags = (trans->rsp_pay_size) / (bc_pay_sz);\n\t\tif (remainder)\n\t\t\tnum_frags++;\n\t\tcmd->req.num = trans->req_pay_size / 4;\n\t\tcmd->rsp.num = trans->rsp_pay_size / 4;\n\t\thdr = trans->rsp_hdr;\n\t\tcmd->op_type = trans->req_hdr->op_type;\n\t}\n\n\ttrans->trans_id = seq;\n\ttrans->cmd_id = cmd_op;\n\tfor (i = 0; i < num_frags; i++) {\n\t\thdr[i].version = 2;\n\t\thdr[i].msg_type = msg_type;\n\t\thdr[i].op_type = cmd->op_type;\n\t\thdr[i].num_cmds = 1;\n\t\thdr[i].num_frags = num_frags;\n\t\thdr[i].frag_num = i + 1;\n\t\thdr[i].cmd_op = cmd_op;\n\t\thdr[i].seq_id = seq;\n\t}\n\treturn 0;\n}\n\nstatic void qlcnic_sriov_cleanup_transaction(struct qlcnic_bc_trans *trans)\n{\n\tif (!trans)\n\t\treturn;\n\tkfree(trans->req_hdr);\n\tkfree(trans->rsp_hdr);\n\tkfree(trans);\n}\n\nstatic int qlcnic_sriov_clear_trans(struct qlcnic_vf_info *vf,\n\t\t\t\t    struct qlcnic_bc_trans *trans, u8 type)\n{\n\tstruct qlcnic_trans_list *t_list;\n\tunsigned long flags;\n\tint ret = 0;\n\n\tif (type == QLC_BC_RESPONSE) {\n\t\tt_list = &vf->rcv_act;\n\t\tspin_lock_irqsave(&t_list->lock, flags);\n\t\tt_list->count--;\n\t\tlist_del(&trans->list);\n\t\tif (t_list->count > 0)\n\t\t\tret = 1;\n\t\tspin_unlock_irqrestore(&t_list->lock, flags);\n\t}\n\tif (type == QLC_BC_COMMAND) {\n\t\twhile (test_and_set_bit(QLC_BC_VF_SEND, &vf->state))\n\t\t\tmsleep(100);\n\t\tvf->send_cmd = NULL;\n\t\tclear_bit(QLC_BC_VF_SEND, &vf->state);\n\t}\n\treturn ret;\n}\n\nstatic void qlcnic_sriov_schedule_bc_cmd(struct qlcnic_sriov *sriov,\n\t\t\t\t\t struct qlcnic_vf_info *vf,\n\t\t\t\t\t work_func_t func)\n{\n\tif (test_bit(QLC_BC_VF_FLR, &vf->state) ||\n\t    vf->adapter->need_fw_reset)\n\t\treturn;\n\n\tqueue_work(sriov->bc.bc_trans_wq, &vf->trans_work);\n}\n\nstatic inline void qlcnic_sriov_wait_for_resp(struct qlcnic_bc_trans *trans)\n{\n\tstruct completion *cmpl = &trans->resp_cmpl;\n\n\tif (wait_for_completion_timeout(cmpl, QLC_MBOX_RESP_TIMEOUT))\n\t\ttrans->trans_state = QLC_END;\n\telse\n\t\ttrans->trans_state = QLC_ABORT;\n\n\treturn;\n}\n\nstatic void qlcnic_sriov_handle_multi_frags(struct qlcnic_bc_trans *trans,\n\t\t\t\t\t    u8 type)\n{\n\tif (type == QLC_BC_RESPONSE) {\n\t\ttrans->curr_rsp_frag++;\n\t\tif (trans->curr_rsp_frag < trans->rsp_hdr->num_frags)\n\t\t\ttrans->trans_state = QLC_INIT;\n\t\telse\n\t\t\ttrans->trans_state = QLC_END;\n\t} else {\n\t\ttrans->curr_req_frag++;\n\t\tif (trans->curr_req_frag < trans->req_hdr->num_frags)\n\t\t\ttrans->trans_state = QLC_INIT;\n\t\telse\n\t\t\ttrans->trans_state = QLC_WAIT_FOR_RESP;\n\t}\n}\n\nstatic void qlcnic_sriov_wait_for_channel_free(struct qlcnic_bc_trans *trans,\n\t\t\t\t\t       u8 type)\n{\n\tstruct qlcnic_vf_info *vf = trans->vf;\n\tstruct completion *cmpl = &vf->ch_free_cmpl;\n\n\tif (!wait_for_completion_timeout(cmpl, QLC_MBOX_CH_FREE_TIMEOUT)) {\n\t\ttrans->trans_state = QLC_ABORT;\n\t\treturn;\n\t}\n\n\tclear_bit(QLC_BC_VF_CHANNEL, &vf->state);\n\tqlcnic_sriov_handle_multi_frags(trans, type);\n}\n\nstatic void qlcnic_sriov_pull_bc_msg(struct qlcnic_adapter *adapter,\n\t\t\t\t     u32 *hdr, u32 *pay, u32 size)\n{\n\tstruct qlcnic_hardware_context *ahw = adapter->ahw;\n\tu8 i, max = 2, hdr_size, j;\n\n\thdr_size = (sizeof(struct qlcnic_bc_hdr) / sizeof(u32));\n\tmax = (size / sizeof(u32)) + hdr_size;\n\n\tfor (i = 2, j = 0; j < hdr_size; i++, j++)\n\t\t*(hdr++) = readl(QLCNIC_MBX_FW(ahw, i));\n\tfor (; j < max; i++, j++)\n\t\t*(pay++) = readl(QLCNIC_MBX_FW(ahw, i));\n}\n\nstatic int __qlcnic_sriov_issue_bc_post(struct qlcnic_vf_info *vf)\n{\n\tint ret = -EBUSY;\n\tu32 timeout = 10000;\n\n\tdo {\n\t\tif (!test_and_set_bit(QLC_BC_VF_CHANNEL, &vf->state)) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t\tmdelay(1);\n\t} while (--timeout);\n\n\treturn ret;\n}\n\nstatic int qlcnic_sriov_issue_bc_post(struct qlcnic_bc_trans *trans, u8 type)\n{\n\tstruct qlcnic_vf_info *vf = trans->vf;\n\tu32 pay_size;\n\tu32 *hdr, *pay;\n\tint ret;\n\tu8 pci_func = trans->func_id;\n\n\tif (__qlcnic_sriov_issue_bc_post(vf))\n\t\treturn -EBUSY;\n\n\tif (type == QLC_BC_COMMAND) {\n\t\thdr = (u32 *)(trans->req_hdr + trans->curr_req_frag);\n\t\tpay = (u32 *)(trans->req_pay + trans->curr_req_frag);\n\t\tpay_size = qlcnic_sriov_get_bc_paysize(trans->req_pay_size,\n\t\t\t\t\t\t       trans->curr_req_frag);\n\t\tpay_size = (pay_size / sizeof(u32));\n\t} else {\n\t\thdr = (u32 *)(trans->rsp_hdr + trans->curr_rsp_frag);\n\t\tpay = (u32 *)(trans->rsp_pay + trans->curr_rsp_frag);\n\t\tpay_size = qlcnic_sriov_get_bc_paysize(trans->rsp_pay_size,\n\t\t\t\t\t\t       trans->curr_rsp_frag);\n\t\tpay_size = (pay_size / sizeof(u32));\n\t}\n\n\tret = qlcnic_sriov_post_bc_msg(vf->adapter, hdr, pay,\n\t\t\t\t       pci_func, pay_size);\n\treturn ret;\n}\n\nstatic int __qlcnic_sriov_send_bc_msg(struct qlcnic_bc_trans *trans,\n\t\t\t\t      struct qlcnic_vf_info *vf, u8 type)\n{\n\tbool flag = true;\n\tint err = -EIO;\n\n\twhile (flag) {\n\t\tif (test_bit(QLC_BC_VF_FLR, &vf->state) ||\n\t\t    vf->adapter->need_fw_reset)\n\t\t\ttrans->trans_state = QLC_ABORT;\n\n\t\tswitch (trans->trans_state) {\n\t\tcase QLC_INIT:\n\t\t\ttrans->trans_state = QLC_WAIT_FOR_CHANNEL_FREE;\n\t\t\tif (qlcnic_sriov_issue_bc_post(trans, type))\n\t\t\t\ttrans->trans_state = QLC_ABORT;\n\t\t\tbreak;\n\t\tcase QLC_WAIT_FOR_CHANNEL_FREE:\n\t\t\tqlcnic_sriov_wait_for_channel_free(trans, type);\n\t\t\tbreak;\n\t\tcase QLC_WAIT_FOR_RESP:\n\t\t\tqlcnic_sriov_wait_for_resp(trans);\n\t\t\tbreak;\n\t\tcase QLC_END:\n\t\t\terr = 0;\n\t\t\tflag = false;\n\t\t\tbreak;\n\t\tcase QLC_ABORT:\n\t\t\terr = -EIO;\n\t\t\tflag = false;\n\t\t\tclear_bit(QLC_BC_VF_CHANNEL, &vf->state);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = -EIO;\n\t\t\tflag = false;\n\t\t}\n\t}\n\treturn err;\n}\n\nstatic int qlcnic_sriov_send_bc_cmd(struct qlcnic_adapter *adapter,\n\t\t\t\t    struct qlcnic_bc_trans *trans, int pci_func)\n{\n\tstruct qlcnic_vf_info *vf;\n\tint err, index = qlcnic_sriov_func_to_index(adapter, pci_func);\n\n\tif (index < 0)\n\t\treturn -EIO;\n\n\tvf = &adapter->ahw->sriov->vf_info[index];\n\ttrans->vf = vf;\n\ttrans->func_id = pci_func;\n\n\tif (!test_bit(QLC_BC_VF_STATE, &vf->state)) {\n\t\tif (qlcnic_sriov_pf_check(adapter))\n\t\t\treturn -EIO;\n\t\tif (qlcnic_sriov_vf_check(adapter) &&\n\t\t    trans->cmd_id != QLCNIC_BC_CMD_CHANNEL_INIT)\n\t\t\treturn -EIO;\n\t}\n\n\tmutex_lock(&vf->send_cmd_lock);\n\tvf->send_cmd = trans;\n\terr = __qlcnic_sriov_send_bc_msg(trans, vf, QLC_BC_COMMAND);\n\tqlcnic_sriov_clear_trans(vf, trans, QLC_BC_COMMAND);\n\tmutex_unlock(&vf->send_cmd_lock);\n\treturn err;\n}\n\nstatic void __qlcnic_sriov_process_bc_cmd(struct qlcnic_adapter *adapter,\n\t\t\t\t\t  struct qlcnic_bc_trans *trans,\n\t\t\t\t\t  struct qlcnic_cmd_args *cmd)\n{\n#ifdef CONFIG_QLCNIC_SRIOV\n\tif (qlcnic_sriov_pf_check(adapter)) {\n\t\tqlcnic_sriov_pf_process_bc_cmd(adapter, trans, cmd);\n\t\treturn;\n\t}\n#endif\n\tcmd->rsp.arg[0] |= (0x9 << 25);\n\treturn;\n}\n\nstatic void qlcnic_sriov_process_bc_cmd(struct work_struct *work)\n{\n\tstruct qlcnic_vf_info *vf = container_of(work, struct qlcnic_vf_info,\n\t\t\t\t\t\t trans_work);\n\tstruct qlcnic_bc_trans *trans = NULL;\n\tstruct qlcnic_adapter *adapter  = vf->adapter;\n\tstruct qlcnic_cmd_args cmd;\n\tu8 req;\n\n\tif (adapter->need_fw_reset)\n\t\treturn;\n\n\tif (test_bit(QLC_BC_VF_FLR, &vf->state))\n\t\treturn;\n\n\tmemset(&cmd, 0, sizeof(struct qlcnic_cmd_args));\n\ttrans = list_first_entry(&vf->rcv_act.wait_list,\n\t\t\t\t struct qlcnic_bc_trans, list);\n\tadapter = vf->adapter;\n\n\tif (qlcnic_sriov_prepare_bc_hdr(trans, &cmd, trans->req_hdr->seq_id,\n\t\t\t\t\tQLC_BC_RESPONSE))\n\t\tgoto cleanup_trans;\n\n\t__qlcnic_sriov_process_bc_cmd(adapter, trans, &cmd);\n\ttrans->trans_state = QLC_INIT;\n\t__qlcnic_sriov_send_bc_msg(trans, vf, QLC_BC_RESPONSE);\n\ncleanup_trans:\n\tqlcnic_free_mbx_args(&cmd);\n\treq = qlcnic_sriov_clear_trans(vf, trans, QLC_BC_RESPONSE);\n\tqlcnic_sriov_cleanup_transaction(trans);\n\tif (req)\n\t\tqlcnic_sriov_schedule_bc_cmd(adapter->ahw->sriov, vf,\n\t\t\t\t\t     qlcnic_sriov_process_bc_cmd);\n}\n\nstatic void qlcnic_sriov_handle_bc_resp(struct qlcnic_bc_hdr *hdr,\n\t\t\t\t\tstruct qlcnic_vf_info *vf)\n{\n\tstruct qlcnic_bc_trans *trans;\n\tu32 pay_size;\n\n\tif (test_and_set_bit(QLC_BC_VF_SEND, &vf->state))\n\t\treturn;\n\n\ttrans = vf->send_cmd;\n\n\tif (trans == NULL)\n\t\tgoto clear_send;\n\n\tif (trans->trans_id != hdr->seq_id)\n\t\tgoto clear_send;\n\n\tpay_size = qlcnic_sriov_get_bc_paysize(trans->rsp_pay_size,\n\t\t\t\t\t       trans->curr_rsp_frag);\n\tqlcnic_sriov_pull_bc_msg(vf->adapter,\n\t\t\t\t (u32 *)(trans->rsp_hdr + trans->curr_rsp_frag),\n\t\t\t\t (u32 *)(trans->rsp_pay + trans->curr_rsp_frag),\n\t\t\t\t pay_size);\n\tif (++trans->curr_rsp_frag < trans->rsp_hdr->num_frags)\n\t\tgoto clear_send;\n\n\tcomplete(&trans->resp_cmpl);\n\nclear_send:\n\tclear_bit(QLC_BC_VF_SEND, &vf->state);\n}\n\nint __qlcnic_sriov_add_act_list(struct qlcnic_sriov *sriov,\n\t\t\t\tstruct qlcnic_vf_info *vf,\n\t\t\t\tstruct qlcnic_bc_trans *trans)\n{\n\tstruct qlcnic_trans_list *t_list = &vf->rcv_act;\n\n\tt_list->count++;\n\tlist_add_tail(&trans->list, &t_list->wait_list);\n\tif (t_list->count == 1)\n\t\tqlcnic_sriov_schedule_bc_cmd(sriov, vf,\n\t\t\t\t\t     qlcnic_sriov_process_bc_cmd);\n\treturn 0;\n}\n\nstatic int qlcnic_sriov_add_act_list(struct qlcnic_sriov *sriov,\n\t\t\t\t     struct qlcnic_vf_info *vf,\n\t\t\t\t     struct qlcnic_bc_trans *trans)\n{\n\tstruct qlcnic_trans_list *t_list = &vf->rcv_act;\n\n\tspin_lock(&t_list->lock);\n\n\t__qlcnic_sriov_add_act_list(sriov, vf, trans);\n\n\tspin_unlock(&t_list->lock);\n\treturn 0;\n}\n\nstatic void qlcnic_sriov_handle_pending_trans(struct qlcnic_sriov *sriov,\n\t\t\t\t\t      struct qlcnic_vf_info *vf,\n\t\t\t\t\t      struct qlcnic_bc_hdr *hdr)\n{\n\tstruct qlcnic_bc_trans *trans = NULL;\n\tstruct list_head *node;\n\tu32 pay_size, curr_frag;\n\tu8 found = 0, active = 0;\n\n\tspin_lock(&vf->rcv_pend.lock);\n\tif (vf->rcv_pend.count > 0) {\n\t\tlist_for_each(node, &vf->rcv_pend.wait_list) {\n\t\t\ttrans = list_entry(node, struct qlcnic_bc_trans, list);\n\t\t\tif (trans->trans_id == hdr->seq_id) {\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (found) {\n\t\tcurr_frag = trans->curr_req_frag;\n\t\tpay_size = qlcnic_sriov_get_bc_paysize(trans->req_pay_size,\n\t\t\t\t\t\t       curr_frag);\n\t\tqlcnic_sriov_pull_bc_msg(vf->adapter,\n\t\t\t\t\t (u32 *)(trans->req_hdr + curr_frag),\n\t\t\t\t\t (u32 *)(trans->req_pay + curr_frag),\n\t\t\t\t\t pay_size);\n\t\ttrans->curr_req_frag++;\n\t\tif (trans->curr_req_frag >= hdr->num_frags) {\n\t\t\tvf->rcv_pend.count--;\n\t\t\tlist_del(&trans->list);\n\t\t\tactive = 1;\n\t\t}\n\t}\n\tspin_unlock(&vf->rcv_pend.lock);\n\n\tif (active)\n\t\tif (qlcnic_sriov_add_act_list(sriov, vf, trans))\n\t\t\tqlcnic_sriov_cleanup_transaction(trans);\n\n\treturn;\n}\n\nstatic void qlcnic_sriov_handle_bc_cmd(struct qlcnic_sriov *sriov,\n\t\t\t\t       struct qlcnic_bc_hdr *hdr,\n\t\t\t\t       struct qlcnic_vf_info *vf)\n{\n\tstruct qlcnic_bc_trans *trans;\n\tstruct qlcnic_adapter *adapter = vf->adapter;\n\tstruct qlcnic_cmd_args cmd;\n\tu32 pay_size;\n\tint err;\n\tu8 cmd_op;\n\n\tif (adapter->need_fw_reset)\n\t\treturn;\n\n\tif (!test_bit(QLC_BC_VF_STATE, &vf->state) &&\n\t    hdr->op_type != QLC_BC_CMD &&\n\t    hdr->cmd_op != QLCNIC_BC_CMD_CHANNEL_INIT)\n\t\treturn;\n\n\tif (hdr->frag_num > 1) {\n\t\tqlcnic_sriov_handle_pending_trans(sriov, vf, hdr);\n\t\treturn;\n\t}\n\n\tmemset(&cmd, 0, sizeof(struct qlcnic_cmd_args));\n\tcmd_op = hdr->cmd_op;\n\tif (qlcnic_sriov_alloc_bc_trans(&trans))\n\t\treturn;\n\n\tif (hdr->op_type == QLC_BC_CMD)\n\t\terr = qlcnic_sriov_alloc_bc_mbx_args(&cmd, cmd_op);\n\telse\n\t\terr = qlcnic_alloc_mbx_args(&cmd, adapter, cmd_op);\n\n\tif (err) {\n\t\tqlcnic_sriov_cleanup_transaction(trans);\n\t\treturn;\n\t}\n\n\tcmd.op_type = hdr->op_type;\n\tif (qlcnic_sriov_prepare_bc_hdr(trans, &cmd, hdr->seq_id,\n\t\t\t\t\tQLC_BC_COMMAND)) {\n\t\tqlcnic_free_mbx_args(&cmd);\n\t\tqlcnic_sriov_cleanup_transaction(trans);\n\t\treturn;\n\t}\n\n\tpay_size = qlcnic_sriov_get_bc_paysize(trans->req_pay_size,\n\t\t\t\t\t trans->curr_req_frag);\n\tqlcnic_sriov_pull_bc_msg(vf->adapter,\n\t\t\t\t (u32 *)(trans->req_hdr + trans->curr_req_frag),\n\t\t\t\t (u32 *)(trans->req_pay + trans->curr_req_frag),\n\t\t\t\t pay_size);\n\ttrans->func_id = vf->pci_func;\n\ttrans->vf = vf;\n\ttrans->trans_id = hdr->seq_id;\n\ttrans->curr_req_frag++;\n\n\tif (qlcnic_sriov_soft_flr_check(adapter, trans, vf))\n\t\treturn;\n\n\tif (trans->curr_req_frag == trans->req_hdr->num_frags) {\n\t\tif (qlcnic_sriov_add_act_list(sriov, vf, trans)) {\n\t\t\tqlcnic_free_mbx_args(&cmd);\n\t\t\tqlcnic_sriov_cleanup_transaction(trans);\n\t\t}\n\t} else {\n\t\tspin_lock(&vf->rcv_pend.lock);\n\t\tlist_add_tail(&trans->list, &vf->rcv_pend.wait_list);\n\t\tvf->rcv_pend.count++;\n\t\tspin_unlock(&vf->rcv_pend.lock);\n\t}\n}\n\nstatic void qlcnic_sriov_handle_msg_event(struct qlcnic_sriov *sriov,\n\t\t\t\t\t  struct qlcnic_vf_info *vf)\n{\n\tstruct qlcnic_bc_hdr hdr;\n\tu32 *ptr = (u32 *)&hdr;\n\tu8 msg_type, i;\n\n\tfor (i = 2; i < 6; i++)\n\t\tptr[i - 2] = readl(QLCNIC_MBX_FW(vf->adapter->ahw, i));\n\tmsg_type = hdr.msg_type;\n\n\tswitch (msg_type) {\n\tcase QLC_BC_COMMAND:\n\t\tqlcnic_sriov_handle_bc_cmd(sriov, &hdr, vf);\n\t\tbreak;\n\tcase QLC_BC_RESPONSE:\n\t\tqlcnic_sriov_handle_bc_resp(&hdr, vf);\n\t\tbreak;\n\t}\n}\n\nstatic void qlcnic_sriov_handle_flr_event(struct qlcnic_sriov *sriov,\n\t\t\t\t\t  struct qlcnic_vf_info *vf)\n{\n\tstruct qlcnic_adapter *adapter = vf->adapter;\n\n\tif (qlcnic_sriov_pf_check(adapter))\n\t\tqlcnic_sriov_pf_handle_flr(sriov, vf);\n\telse\n\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\"Invalid event to VF. VF should not get FLR event\\n\");\n}\n\nvoid qlcnic_sriov_handle_bc_event(struct qlcnic_adapter *adapter, u32 event)\n{\n\tstruct qlcnic_vf_info *vf;\n\tstruct qlcnic_sriov *sriov;\n\tint index;\n\tu8 pci_func;\n\n\tsriov = adapter->ahw->sriov;\n\tpci_func = qlcnic_sriov_target_func_id(event);\n\tindex = qlcnic_sriov_func_to_index(adapter, pci_func);\n\n\tif (index < 0)\n\t\treturn;\n\n\tvf = &sriov->vf_info[index];\n\tvf->pci_func = pci_func;\n\n\tif (qlcnic_sriov_channel_free_check(event))\n\t\tcomplete(&vf->ch_free_cmpl);\n\n\tif (qlcnic_sriov_flr_check(event)) {\n\t\tqlcnic_sriov_handle_flr_event(sriov, vf);\n\t\treturn;\n\t}\n\n\tif (qlcnic_sriov_bc_msg_check(event))\n\t\tqlcnic_sriov_handle_msg_event(sriov, vf);\n}\n\nint qlcnic_sriov_cfg_bc_intr(struct qlcnic_adapter *adapter, u8 enable)\n{\n\tstruct qlcnic_cmd_args cmd;\n\tint err;\n\n\tif (!test_bit(__QLCNIC_SRIOV_ENABLE, &adapter->state))\n\t\treturn 0;\n\n\tif (qlcnic_alloc_mbx_args(&cmd, adapter, QLCNIC_CMD_BC_EVENT_SETUP))\n\t\treturn -ENOMEM;\n\n\tif (enable)\n\t\tcmd.req.arg[1] = (1 << 4) | (1 << 5) | (1 << 6) | (1 << 7);\n\n\terr = qlcnic_83xx_issue_cmd(adapter, &cmd);\n\n\tif (err != QLCNIC_RCODE_SUCCESS) {\n\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\"Failed to %s bc events, err=%d\\n\",\n\t\t\t(enable ? \"enable\" : \"disable\"), err);\n\t}\n\n\tqlcnic_free_mbx_args(&cmd);\n\treturn err;\n}\n\nstatic int qlcnic_sriov_retry_bc_cmd(struct qlcnic_adapter *adapter,\n\t\t\t\t     struct qlcnic_bc_trans *trans)\n{\n\tu8 max = QLC_BC_CMD_MAX_RETRY_CNT;\n\tu32 state;\n\n\tstate = QLCRDX(adapter->ahw, QLC_83XX_IDC_DEV_STATE);\n\tif (state == QLC_83XX_IDC_DEV_READY) {\n\t\tmsleep(20);\n\t\tclear_bit(QLC_BC_VF_CHANNEL, &trans->vf->state);\n\t\ttrans->trans_state = QLC_INIT;\n\t\tif (++adapter->fw_fail_cnt > max)\n\t\t\treturn -EIO;\n\t\telse\n\t\t\treturn 0;\n\t}\n\n\treturn -EIO;\n}\n\nstatic int __qlcnic_sriov_issue_cmd(struct qlcnic_adapter *adapter,\n\t\t\t\t  struct qlcnic_cmd_args *cmd)\n{\n\tstruct qlcnic_hardware_context *ahw = adapter->ahw;\n\tstruct qlcnic_mailbox *mbx = ahw->mailbox;\n\tstruct device *dev = &adapter->pdev->dev;\n\tstruct qlcnic_bc_trans *trans;\n\tint err;\n\tu32 rsp_data, opcode, mbx_err_code, rsp;\n\tu16 seq = ++adapter->ahw->sriov->bc.trans_counter;\n\tu8 func = ahw->pci_func;\n\n\trsp = qlcnic_sriov_alloc_bc_trans(&trans);\n\tif (rsp)\n\t\tgoto free_cmd;\n\n\trsp = qlcnic_sriov_prepare_bc_hdr(trans, cmd, seq, QLC_BC_COMMAND);\n\tif (rsp)\n\t\tgoto cleanup_transaction;\n\nretry:\n\tif (!test_bit(QLC_83XX_MBX_READY, &mbx->status)) {\n\t\trsp = -EIO;\n\t\tQLCDB(adapter, DRV, \"MBX not Ready!(cmd 0x%x) for VF 0x%x\\n\",\n\t\t      QLCNIC_MBX_RSP(cmd->req.arg[0]), func);\n\t\tgoto err_out;\n\t}\n\n\terr = qlcnic_sriov_send_bc_cmd(adapter, trans, func);\n\tif (err) {\n\t\tdev_err(dev, \"MBX command 0x%x timed out for VF %d\\n\",\n\t\t\t(cmd->req.arg[0] & 0xffff), func);\n\t\trsp = QLCNIC_RCODE_TIMEOUT;\n\n\t\t \n\t\tif ((trans->req_hdr->cmd_op == QLCNIC_BC_CMD_CHANNEL_INIT) &&\n\t\t    !qlcnic_sriov_retry_bc_cmd(adapter, trans))\n\t\t\tgoto retry;\n\n\t\tgoto err_out;\n\t}\n\n\trsp_data = cmd->rsp.arg[0];\n\tmbx_err_code = QLCNIC_MBX_STATUS(rsp_data);\n\topcode = QLCNIC_MBX_RSP(cmd->req.arg[0]);\n\n\tif ((mbx_err_code == QLCNIC_MBX_RSP_OK) ||\n\t    (mbx_err_code == QLCNIC_MBX_PORT_RSP_OK)) {\n\t\trsp = QLCNIC_RCODE_SUCCESS;\n\t} else {\n\t\tif (cmd->type == QLC_83XX_MBX_CMD_NO_WAIT) {\n\t\t\trsp = QLCNIC_RCODE_SUCCESS;\n\t\t} else {\n\t\t\trsp = mbx_err_code;\n\t\t\tif (!rsp)\n\t\t\t\trsp = 1;\n\n\t\t\tdev_err(dev,\n\t\t\t\t\"MBX command 0x%x failed with err:0x%x for VF %d\\n\",\n\t\t\t\topcode, mbx_err_code, func);\n\t\t}\n\t}\n\nerr_out:\n\tif (rsp == QLCNIC_RCODE_TIMEOUT) {\n\t\tahw->reset_context = 1;\n\t\tadapter->need_fw_reset = 1;\n\t\tclear_bit(QLC_83XX_MBX_READY, &mbx->status);\n\t}\n\ncleanup_transaction:\n\tqlcnic_sriov_cleanup_transaction(trans);\n\nfree_cmd:\n\tif (cmd->type == QLC_83XX_MBX_CMD_NO_WAIT) {\n\t\tqlcnic_free_mbx_args(cmd);\n\t\tkfree(cmd);\n\t}\n\n\treturn rsp;\n}\n\n\nstatic int qlcnic_sriov_issue_cmd(struct qlcnic_adapter *adapter,\n\t\t\t\t  struct qlcnic_cmd_args *cmd)\n{\n\tif (cmd->type == QLC_83XX_MBX_CMD_NO_WAIT)\n\t\treturn qlcnic_sriov_async_issue_cmd(adapter, cmd);\n\telse\n\t\treturn __qlcnic_sriov_issue_cmd(adapter, cmd);\n}\n\nstatic int qlcnic_sriov_channel_cfg_cmd(struct qlcnic_adapter *adapter, u8 cmd_op)\n{\n\tstruct qlcnic_cmd_args cmd;\n\tstruct qlcnic_vf_info *vf = &adapter->ahw->sriov->vf_info[0];\n\tint ret;\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\tif (qlcnic_sriov_alloc_bc_mbx_args(&cmd, cmd_op))\n\t\treturn -ENOMEM;\n\n\tret = qlcnic_issue_cmd(adapter, &cmd);\n\tif (ret) {\n\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\"Failed bc channel %s %d\\n\", cmd_op ? \"term\" : \"init\",\n\t\t\tret);\n\t\tgoto out;\n\t}\n\n\tcmd_op = (cmd.rsp.arg[0] & 0xff);\n\tif (cmd.rsp.arg[0] >> 25 == 2)\n\t\treturn 2;\n\tif (cmd_op == QLCNIC_BC_CMD_CHANNEL_INIT)\n\t\tset_bit(QLC_BC_VF_STATE, &vf->state);\n\telse\n\t\tclear_bit(QLC_BC_VF_STATE, &vf->state);\n\nout:\n\tqlcnic_free_mbx_args(&cmd);\n\treturn ret;\n}\n\nstatic void qlcnic_vf_add_mc_list(struct net_device *netdev, const u8 *mac,\n\t\t\t\t  enum qlcnic_mac_type mac_type)\n{\n\tstruct qlcnic_adapter *adapter = netdev_priv(netdev);\n\tstruct qlcnic_sriov *sriov = adapter->ahw->sriov;\n\tstruct qlcnic_vf_info *vf;\n\tu16 vlan_id;\n\tint i;\n\n\tvf = &adapter->ahw->sriov->vf_info[0];\n\n\tif (!qlcnic_sriov_check_any_vlan(vf)) {\n\t\tqlcnic_nic_add_mac(adapter, mac, 0, mac_type);\n\t} else {\n\t\tspin_lock(&vf->vlan_list_lock);\n\t\tfor (i = 0; i < sriov->num_allowed_vlans; i++) {\n\t\t\tvlan_id = vf->sriov_vlans[i];\n\t\t\tif (vlan_id)\n\t\t\t\tqlcnic_nic_add_mac(adapter, mac, vlan_id,\n\t\t\t\t\t\t   mac_type);\n\t\t}\n\t\tspin_unlock(&vf->vlan_list_lock);\n\t\tif (qlcnic_84xx_check(adapter))\n\t\t\tqlcnic_nic_add_mac(adapter, mac, 0, mac_type);\n\t}\n}\n\nvoid qlcnic_sriov_cleanup_async_list(struct qlcnic_back_channel *bc)\n{\n\tstruct list_head *head = &bc->async_cmd_list;\n\tstruct qlcnic_async_cmd *entry;\n\n\tflush_workqueue(bc->bc_async_wq);\n\tcancel_work_sync(&bc->vf_async_work);\n\n\tspin_lock(&bc->queue_lock);\n\twhile (!list_empty(head)) {\n\t\tentry = list_entry(head->next, struct qlcnic_async_cmd,\n\t\t\t\t   list);\n\t\tlist_del(&entry->list);\n\t\tkfree(entry->cmd);\n\t\tkfree(entry);\n\t}\n\tspin_unlock(&bc->queue_lock);\n}\n\nvoid qlcnic_sriov_vf_set_multi(struct net_device *netdev)\n{\n\tstruct qlcnic_adapter *adapter = netdev_priv(netdev);\n\tstruct qlcnic_hardware_context *ahw = adapter->ahw;\n\tstatic const u8 bcast_addr[ETH_ALEN] = {\n\t\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff\n\t};\n\tstruct netdev_hw_addr *ha;\n\tu32 mode = VPORT_MISS_MODE_DROP;\n\n\tif (!test_bit(__QLCNIC_FW_ATTACHED, &adapter->state))\n\t\treturn;\n\n\tif (netdev->flags & IFF_PROMISC) {\n\t\tif (!(adapter->flags & QLCNIC_PROMISC_DISABLED))\n\t\t\tmode = VPORT_MISS_MODE_ACCEPT_ALL;\n\t} else if ((netdev->flags & IFF_ALLMULTI) ||\n\t\t   (netdev_mc_count(netdev) > ahw->max_mc_count)) {\n\t\tmode = VPORT_MISS_MODE_ACCEPT_MULTI;\n\t} else {\n\t\tqlcnic_vf_add_mc_list(netdev, bcast_addr, QLCNIC_BROADCAST_MAC);\n\t\tif (!netdev_mc_empty(netdev)) {\n\t\t\tqlcnic_flush_mcast_mac(adapter);\n\t\t\tnetdev_for_each_mc_addr(ha, netdev)\n\t\t\t\tqlcnic_vf_add_mc_list(netdev, ha->addr,\n\t\t\t\t\t\t      QLCNIC_MULTICAST_MAC);\n\t\t}\n\t}\n\n\t \n\tif (netdev_uc_count(netdev) > ahw->max_uc_count) {\n\t\tmode = VPORT_MISS_MODE_ACCEPT_ALL;\n\t} else if (!netdev_uc_empty(netdev)) {\n\t\tnetdev_for_each_uc_addr(ha, netdev)\n\t\t\tqlcnic_vf_add_mc_list(netdev, ha->addr,\n\t\t\t\t\t      QLCNIC_UNICAST_MAC);\n\t}\n\n\tif (adapter->pdev->is_virtfn) {\n\t\tif (mode == VPORT_MISS_MODE_ACCEPT_ALL &&\n\t\t    !adapter->fdb_mac_learn) {\n\t\t\tqlcnic_alloc_lb_filters_mem(adapter);\n\t\t\tadapter->drv_mac_learn = true;\n\t\t\tadapter->rx_mac_learn = true;\n\t\t} else {\n\t\t\tadapter->drv_mac_learn = false;\n\t\t\tadapter->rx_mac_learn = false;\n\t\t}\n\t}\n\n\tqlcnic_nic_set_promisc(adapter, mode);\n}\n\nstatic void qlcnic_sriov_handle_async_issue_cmd(struct work_struct *work)\n{\n\tstruct qlcnic_async_cmd *entry, *tmp;\n\tstruct qlcnic_back_channel *bc;\n\tstruct qlcnic_cmd_args *cmd;\n\tstruct list_head *head;\n\tLIST_HEAD(del_list);\n\n\tbc = container_of(work, struct qlcnic_back_channel, vf_async_work);\n\thead = &bc->async_cmd_list;\n\n\tspin_lock(&bc->queue_lock);\n\tlist_splice_init(head, &del_list);\n\tspin_unlock(&bc->queue_lock);\n\n\tlist_for_each_entry_safe(entry, tmp, &del_list, list) {\n\t\tlist_del(&entry->list);\n\t\tcmd = entry->cmd;\n\t\t__qlcnic_sriov_issue_cmd(bc->adapter, cmd);\n\t\tkfree(entry);\n\t}\n\n\tif (!list_empty(head))\n\t\tqueue_work(bc->bc_async_wq, &bc->vf_async_work);\n\n\treturn;\n}\n\nstatic struct qlcnic_async_cmd *\nqlcnic_sriov_alloc_async_cmd(struct qlcnic_back_channel *bc,\n\t\t\t     struct qlcnic_cmd_args *cmd)\n{\n\tstruct qlcnic_async_cmd *entry = NULL;\n\n\tentry = kzalloc(sizeof(*entry), GFP_ATOMIC);\n\tif (!entry)\n\t\treturn NULL;\n\n\tentry->cmd = cmd;\n\n\tspin_lock(&bc->queue_lock);\n\tlist_add_tail(&entry->list, &bc->async_cmd_list);\n\tspin_unlock(&bc->queue_lock);\n\n\treturn entry;\n}\n\nstatic void qlcnic_sriov_schedule_async_cmd(struct qlcnic_back_channel *bc,\n\t\t\t\t\t    struct qlcnic_cmd_args *cmd)\n{\n\tstruct qlcnic_async_cmd *entry = NULL;\n\n\tentry = qlcnic_sriov_alloc_async_cmd(bc, cmd);\n\tif (!entry) {\n\t\tqlcnic_free_mbx_args(cmd);\n\t\tkfree(cmd);\n\t\treturn;\n\t}\n\n\tqueue_work(bc->bc_async_wq, &bc->vf_async_work);\n}\n\nstatic int qlcnic_sriov_async_issue_cmd(struct qlcnic_adapter *adapter,\n\t\t\t\t\tstruct qlcnic_cmd_args *cmd)\n{\n\n\tstruct qlcnic_back_channel *bc = &adapter->ahw->sriov->bc;\n\n\tif (adapter->need_fw_reset)\n\t\treturn -EIO;\n\n\tqlcnic_sriov_schedule_async_cmd(bc, cmd);\n\n\treturn 0;\n}\n\nstatic int qlcnic_sriov_vf_reinit_driver(struct qlcnic_adapter *adapter)\n{\n\tint err;\n\n\tadapter->need_fw_reset = 0;\n\tqlcnic_83xx_reinit_mbx_work(adapter->ahw->mailbox);\n\tqlcnic_83xx_enable_mbx_interrupt(adapter);\n\n\terr = qlcnic_sriov_cfg_bc_intr(adapter, 1);\n\tif (err)\n\t\treturn err;\n\n\terr = qlcnic_sriov_channel_cfg_cmd(adapter, QLCNIC_BC_CMD_CHANNEL_INIT);\n\tif (err)\n\t\tgoto err_out_cleanup_bc_intr;\n\n\terr = qlcnic_sriov_vf_init_driver(adapter);\n\tif (err)\n\t\tgoto err_out_term_channel;\n\n\treturn 0;\n\nerr_out_term_channel:\n\tqlcnic_sriov_channel_cfg_cmd(adapter, QLCNIC_BC_CMD_CHANNEL_TERM);\n\nerr_out_cleanup_bc_intr:\n\tqlcnic_sriov_cfg_bc_intr(adapter, 0);\n\treturn err;\n}\n\nstatic void qlcnic_sriov_vf_attach(struct qlcnic_adapter *adapter)\n{\n\tstruct net_device *netdev = adapter->netdev;\n\n\tif (netif_running(netdev)) {\n\t\tif (!qlcnic_up(adapter, netdev))\n\t\t\tqlcnic_restore_indev_addr(netdev, NETDEV_UP);\n\t}\n\n\tnetif_device_attach(netdev);\n}\n\nstatic void qlcnic_sriov_vf_detach(struct qlcnic_adapter *adapter)\n{\n\tstruct qlcnic_hardware_context *ahw = adapter->ahw;\n\tstruct qlcnic_intrpt_config *intr_tbl = ahw->intr_tbl;\n\tstruct net_device *netdev = adapter->netdev;\n\tu8 i, max_ints = ahw->num_msix - 1;\n\n\tnetif_device_detach(netdev);\n\tqlcnic_83xx_detach_mailbox_work(adapter);\n\tqlcnic_83xx_disable_mbx_intr(adapter);\n\n\tif (netif_running(netdev))\n\t\tqlcnic_down(adapter, netdev);\n\n\tfor (i = 0; i < max_ints; i++) {\n\t\tintr_tbl[i].id = i;\n\t\tintr_tbl[i].enabled = 0;\n\t\tintr_tbl[i].src = 0;\n\t}\n\tahw->reset_context = 0;\n}\n\nstatic int qlcnic_sriov_vf_handle_dev_ready(struct qlcnic_adapter *adapter)\n{\n\tstruct qlcnic_hardware_context *ahw = adapter->ahw;\n\tstruct device *dev = &adapter->pdev->dev;\n\tstruct qlc_83xx_idc *idc = &ahw->idc;\n\tu8 func = ahw->pci_func;\n\tu32 state;\n\n\tif ((idc->prev_state == QLC_83XX_IDC_DEV_NEED_RESET) ||\n\t    (idc->prev_state == QLC_83XX_IDC_DEV_INIT)) {\n\t\tif (!qlcnic_sriov_vf_reinit_driver(adapter)) {\n\t\t\tqlcnic_sriov_vf_attach(adapter);\n\t\t\tadapter->fw_fail_cnt = 0;\n\t\t\tdev_info(dev,\n\t\t\t\t \"%s: Reinitialization of VF 0x%x done after FW reset\\n\",\n\t\t\t\t __func__, func);\n\t\t} else {\n\t\t\tdev_err(dev,\n\t\t\t\t\"%s: Reinitialization of VF 0x%x failed after FW reset\\n\",\n\t\t\t\t__func__, func);\n\t\t\tstate = QLCRDX(ahw, QLC_83XX_IDC_DEV_STATE);\n\t\t\tdev_info(dev, \"Current state 0x%x after FW reset\\n\",\n\t\t\t\t state);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int qlcnic_sriov_vf_handle_context_reset(struct qlcnic_adapter *adapter)\n{\n\tstruct qlcnic_hardware_context *ahw = adapter->ahw;\n\tstruct qlcnic_mailbox *mbx = ahw->mailbox;\n\tstruct device *dev = &adapter->pdev->dev;\n\tstruct qlc_83xx_idc *idc = &ahw->idc;\n\tu8 func = ahw->pci_func;\n\tu32 state;\n\n\tadapter->reset_ctx_cnt++;\n\n\t \n\tif (adapter->reset_ctx_cnt < 3) {\n\t\tadapter->need_fw_reset = 1;\n\t\tclear_bit(QLC_83XX_MBX_READY, &mbx->status);\n\t\tdev_info(dev,\n\t\t\t \"Resetting context, wait here to check if FW is in failed state\\n\");\n\t\treturn 0;\n\t}\n\n\t \n\tif (adapter->reset_ctx_cnt > QLC_83XX_VF_RESET_FAIL_THRESH) {\n\t\tclear_bit(QLC_83XX_MODULE_LOADED, &idc->status);\n\t\tadapter->tx_timeo_cnt = 0;\n\t\tadapter->fw_fail_cnt = 0;\n\t\tadapter->reset_ctx_cnt = 0;\n\t\tqlcnic_sriov_vf_detach(adapter);\n\t\tdev_err(dev,\n\t\t\t\"Device context resets have exceeded the threshold, device interface will be shutdown\\n\");\n\t\treturn -EIO;\n\t}\n\n\tdev_info(dev, \"Resetting context of VF 0x%x\\n\", func);\n\tdev_info(dev, \"%s: Context reset count %d for VF 0x%x\\n\",\n\t\t __func__, adapter->reset_ctx_cnt, func);\n\tset_bit(__QLCNIC_RESETTING, &adapter->state);\n\tadapter->need_fw_reset = 1;\n\tclear_bit(QLC_83XX_MBX_READY, &mbx->status);\n\tqlcnic_sriov_vf_detach(adapter);\n\tadapter->need_fw_reset = 0;\n\n\tif (!qlcnic_sriov_vf_reinit_driver(adapter)) {\n\t\tqlcnic_sriov_vf_attach(adapter);\n\t\tadapter->tx_timeo_cnt = 0;\n\t\tadapter->reset_ctx_cnt = 0;\n\t\tadapter->fw_fail_cnt = 0;\n\t\tdev_info(dev, \"Done resetting context for VF 0x%x\\n\", func);\n\t} else {\n\t\tdev_err(dev, \"%s: Reinitialization of VF 0x%x failed\\n\",\n\t\t\t__func__, func);\n\t\tstate = QLCRDX(ahw, QLC_83XX_IDC_DEV_STATE);\n\t\tdev_info(dev, \"%s: Current state 0x%x\\n\", __func__, state);\n\t}\n\n\treturn 0;\n}\n\nstatic int qlcnic_sriov_vf_idc_ready_state(struct qlcnic_adapter *adapter)\n{\n\tstruct qlcnic_hardware_context *ahw = adapter->ahw;\n\tint ret = 0;\n\n\tif (ahw->idc.prev_state != QLC_83XX_IDC_DEV_READY)\n\t\tret = qlcnic_sriov_vf_handle_dev_ready(adapter);\n\telse if (ahw->reset_context)\n\t\tret = qlcnic_sriov_vf_handle_context_reset(adapter);\n\n\tclear_bit(__QLCNIC_RESETTING, &adapter->state);\n\treturn ret;\n}\n\nstatic int qlcnic_sriov_vf_idc_failed_state(struct qlcnic_adapter *adapter)\n{\n\tstruct qlc_83xx_idc *idc = &adapter->ahw->idc;\n\n\tdev_err(&adapter->pdev->dev, \"Device is in failed state\\n\");\n\tif (idc->prev_state == QLC_83XX_IDC_DEV_READY)\n\t\tqlcnic_sriov_vf_detach(adapter);\n\n\tclear_bit(QLC_83XX_MODULE_LOADED, &idc->status);\n\tclear_bit(__QLCNIC_RESETTING, &adapter->state);\n\treturn -EIO;\n}\n\nstatic int\nqlcnic_sriov_vf_idc_need_quiescent_state(struct qlcnic_adapter *adapter)\n{\n\tstruct qlcnic_mailbox *mbx = adapter->ahw->mailbox;\n\tstruct qlc_83xx_idc *idc = &adapter->ahw->idc;\n\n\tdev_info(&adapter->pdev->dev, \"Device is in quiescent state\\n\");\n\tif (idc->prev_state == QLC_83XX_IDC_DEV_READY) {\n\t\tset_bit(__QLCNIC_RESETTING, &adapter->state);\n\t\tadapter->tx_timeo_cnt = 0;\n\t\tadapter->reset_ctx_cnt = 0;\n\t\tclear_bit(QLC_83XX_MBX_READY, &mbx->status);\n\t\tqlcnic_sriov_vf_detach(adapter);\n\t}\n\n\treturn 0;\n}\n\nstatic int qlcnic_sriov_vf_idc_init_reset_state(struct qlcnic_adapter *adapter)\n{\n\tstruct qlcnic_mailbox *mbx = adapter->ahw->mailbox;\n\tstruct qlc_83xx_idc *idc = &adapter->ahw->idc;\n\tu8 func = adapter->ahw->pci_func;\n\n\tif (idc->prev_state == QLC_83XX_IDC_DEV_READY) {\n\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\"Firmware hang detected by VF 0x%x\\n\", func);\n\t\tset_bit(__QLCNIC_RESETTING, &adapter->state);\n\t\tadapter->tx_timeo_cnt = 0;\n\t\tadapter->reset_ctx_cnt = 0;\n\t\tclear_bit(QLC_83XX_MBX_READY, &mbx->status);\n\t\tqlcnic_sriov_vf_detach(adapter);\n\t}\n\treturn 0;\n}\n\nstatic int qlcnic_sriov_vf_idc_unknown_state(struct qlcnic_adapter *adapter)\n{\n\tdev_err(&adapter->pdev->dev, \"%s: Device in unknown state\\n\", __func__);\n\treturn 0;\n}\n\nstatic void qlcnic_sriov_vf_periodic_tasks(struct qlcnic_adapter *adapter)\n{\n\tif (adapter->fhash.fnum)\n\t\tqlcnic_prune_lb_filters(adapter);\n}\n\nstatic void qlcnic_sriov_vf_poll_dev_state(struct work_struct *work)\n{\n\tstruct qlcnic_adapter *adapter;\n\tstruct qlc_83xx_idc *idc;\n\tint ret = 0;\n\n\tadapter = container_of(work, struct qlcnic_adapter, fw_work.work);\n\tidc = &adapter->ahw->idc;\n\tidc->curr_state = QLCRDX(adapter->ahw, QLC_83XX_IDC_DEV_STATE);\n\n\tswitch (idc->curr_state) {\n\tcase QLC_83XX_IDC_DEV_READY:\n\t\tret = qlcnic_sriov_vf_idc_ready_state(adapter);\n\t\tbreak;\n\tcase QLC_83XX_IDC_DEV_NEED_RESET:\n\tcase QLC_83XX_IDC_DEV_INIT:\n\t\tret = qlcnic_sriov_vf_idc_init_reset_state(adapter);\n\t\tbreak;\n\tcase QLC_83XX_IDC_DEV_NEED_QUISCENT:\n\t\tret = qlcnic_sriov_vf_idc_need_quiescent_state(adapter);\n\t\tbreak;\n\tcase QLC_83XX_IDC_DEV_FAILED:\n\t\tret = qlcnic_sriov_vf_idc_failed_state(adapter);\n\t\tbreak;\n\tcase QLC_83XX_IDC_DEV_QUISCENT:\n\t\tbreak;\n\tdefault:\n\t\tret = qlcnic_sriov_vf_idc_unknown_state(adapter);\n\t}\n\n\tidc->prev_state = idc->curr_state;\n\tqlcnic_sriov_vf_periodic_tasks(adapter);\n\n\tif (!ret && test_bit(QLC_83XX_MODULE_LOADED, &idc->status))\n\t\tqlcnic_schedule_work(adapter, qlcnic_sriov_vf_poll_dev_state,\n\t\t\t\t     idc->delay);\n}\n\nstatic void qlcnic_sriov_vf_cancel_fw_work(struct qlcnic_adapter *adapter)\n{\n\twhile (test_and_set_bit(__QLCNIC_RESETTING, &adapter->state))\n\t\tmsleep(20);\n\n\tclear_bit(QLC_83XX_MODULE_LOADED, &adapter->ahw->idc.status);\n\tclear_bit(__QLCNIC_RESETTING, &adapter->state);\n\tcancel_delayed_work_sync(&adapter->fw_work);\n}\n\nstatic int qlcnic_sriov_check_vlan_id(struct qlcnic_sriov *sriov,\n\t\t\t\t      struct qlcnic_vf_info *vf, u16 vlan_id)\n{\n\tint i, err = -EINVAL;\n\n\tif (!vf->sriov_vlans)\n\t\treturn err;\n\n\tspin_lock_bh(&vf->vlan_list_lock);\n\n\tfor (i = 0; i < sriov->num_allowed_vlans; i++) {\n\t\tif (vf->sriov_vlans[i] == vlan_id) {\n\t\t\terr = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock_bh(&vf->vlan_list_lock);\n\treturn err;\n}\n\nstatic int qlcnic_sriov_validate_num_vlans(struct qlcnic_sriov *sriov,\n\t\t\t\t\t   struct qlcnic_vf_info *vf)\n{\n\tint err = 0;\n\n\tspin_lock_bh(&vf->vlan_list_lock);\n\n\tif (vf->num_vlan >= sriov->num_allowed_vlans)\n\t\terr = -EINVAL;\n\n\tspin_unlock_bh(&vf->vlan_list_lock);\n\treturn err;\n}\n\nstatic int qlcnic_sriov_validate_vlan_cfg(struct qlcnic_adapter *adapter,\n\t\t\t\t\t  u16 vid, u8 enable)\n{\n\tstruct qlcnic_sriov *sriov = adapter->ahw->sriov;\n\tstruct qlcnic_vf_info *vf;\n\tbool vlan_exist;\n\tu8 allowed = 0;\n\tint i;\n\n\tvf = &adapter->ahw->sriov->vf_info[0];\n\tvlan_exist = qlcnic_sriov_check_any_vlan(vf);\n\tif (sriov->vlan_mode != QLC_GUEST_VLAN_MODE)\n\t\treturn -EINVAL;\n\n\tif (enable) {\n\t\tif (qlcnic_83xx_vf_check(adapter) && vlan_exist)\n\t\t\treturn -EINVAL;\n\n\t\tif (qlcnic_sriov_validate_num_vlans(sriov, vf))\n\t\t\treturn -EINVAL;\n\n\t\tif (sriov->any_vlan) {\n\t\t\tfor (i = 0; i < sriov->num_allowed_vlans; i++) {\n\t\t\t\tif (sriov->allowed_vlans[i] == vid)\n\t\t\t\t\tallowed = 1;\n\t\t\t}\n\n\t\t\tif (!allowed)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\tif (!vlan_exist || qlcnic_sriov_check_vlan_id(sriov, vf, vid))\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void qlcnic_sriov_vlan_operation(struct qlcnic_vf_info *vf, u16 vlan_id,\n\t\t\t\t\tenum qlcnic_vlan_operations opcode)\n{\n\tstruct qlcnic_adapter *adapter = vf->adapter;\n\tstruct qlcnic_sriov *sriov;\n\n\tsriov = adapter->ahw->sriov;\n\n\tif (!vf->sriov_vlans)\n\t\treturn;\n\n\tspin_lock_bh(&vf->vlan_list_lock);\n\n\tswitch (opcode) {\n\tcase QLC_VLAN_ADD:\n\t\tqlcnic_sriov_add_vlan_id(sriov, vf, vlan_id);\n\t\tbreak;\n\tcase QLC_VLAN_DELETE:\n\t\tqlcnic_sriov_del_vlan_id(sriov, vf, vlan_id);\n\t\tbreak;\n\tdefault:\n\t\tnetdev_err(adapter->netdev, \"Invalid VLAN operation\\n\");\n\t}\n\n\tspin_unlock_bh(&vf->vlan_list_lock);\n\treturn;\n}\n\nint qlcnic_sriov_cfg_vf_guest_vlan(struct qlcnic_adapter *adapter,\n\t\t\t\t   u16 vid, u8 enable)\n{\n\tstruct qlcnic_sriov *sriov = adapter->ahw->sriov;\n\tstruct net_device *netdev = adapter->netdev;\n\tstruct qlcnic_vf_info *vf;\n\tstruct qlcnic_cmd_args cmd;\n\tint ret;\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\tif (vid == 0)\n\t\treturn 0;\n\n\tvf = &adapter->ahw->sriov->vf_info[0];\n\tret = qlcnic_sriov_validate_vlan_cfg(adapter, vid, enable);\n\tif (ret)\n\t\treturn ret;\n\n\tret = qlcnic_sriov_alloc_bc_mbx_args(&cmd,\n\t\t\t\t\t     QLCNIC_BC_CMD_CFG_GUEST_VLAN);\n\tif (ret)\n\t\treturn ret;\n\n\tcmd.req.arg[1] = (enable & 1) | vid << 16;\n\n\tqlcnic_sriov_cleanup_async_list(&sriov->bc);\n\tret = qlcnic_issue_cmd(adapter, &cmd);\n\tif (ret) {\n\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\"Failed to configure guest VLAN, err=%d\\n\", ret);\n\t} else {\n\t\tnetif_addr_lock_bh(netdev);\n\t\tqlcnic_free_mac_list(adapter);\n\t\tnetif_addr_unlock_bh(netdev);\n\n\t\tif (enable)\n\t\t\tqlcnic_sriov_vlan_operation(vf, vid, QLC_VLAN_ADD);\n\t\telse\n\t\t\tqlcnic_sriov_vlan_operation(vf, vid, QLC_VLAN_DELETE);\n\n\t\tnetif_addr_lock_bh(netdev);\n\t\tqlcnic_set_multi(netdev);\n\t\tnetif_addr_unlock_bh(netdev);\n\t}\n\n\tqlcnic_free_mbx_args(&cmd);\n\treturn ret;\n}\n\nstatic void qlcnic_sriov_vf_free_mac_list(struct qlcnic_adapter *adapter)\n{\n\tstruct list_head *head = &adapter->mac_list;\n\tstruct qlcnic_mac_vlan_list *cur;\n\n\twhile (!list_empty(head)) {\n\t\tcur = list_entry(head->next, struct qlcnic_mac_vlan_list, list);\n\t\tqlcnic_sre_macaddr_change(adapter, cur->mac_addr, cur->vlan_id,\n\t\t\t\t\t  QLCNIC_MAC_DEL);\n\t\tlist_del(&cur->list);\n\t\tkfree(cur);\n\t}\n}\n\n\nstatic int qlcnic_sriov_vf_shutdown(struct pci_dev *pdev)\n{\n\tstruct qlcnic_adapter *adapter = pci_get_drvdata(pdev);\n\tstruct net_device *netdev = adapter->netdev;\n\n\tnetif_device_detach(netdev);\n\tqlcnic_cancel_idc_work(adapter);\n\n\tif (netif_running(netdev))\n\t\tqlcnic_down(adapter, netdev);\n\n\tqlcnic_sriov_channel_cfg_cmd(adapter, QLCNIC_BC_CMD_CHANNEL_TERM);\n\tqlcnic_sriov_cfg_bc_intr(adapter, 0);\n\tqlcnic_83xx_disable_mbx_intr(adapter);\n\tcancel_delayed_work_sync(&adapter->idc_aen_work);\n\n\treturn pci_save_state(pdev);\n}\n\nstatic int qlcnic_sriov_vf_resume(struct qlcnic_adapter *adapter)\n{\n\tstruct qlc_83xx_idc *idc = &adapter->ahw->idc;\n\tstruct net_device *netdev = adapter->netdev;\n\tint err;\n\n\tset_bit(QLC_83XX_MODULE_LOADED, &idc->status);\n\tqlcnic_83xx_enable_mbx_interrupt(adapter);\n\terr = qlcnic_sriov_cfg_bc_intr(adapter, 1);\n\tif (err)\n\t\treturn err;\n\n\terr = qlcnic_sriov_channel_cfg_cmd(adapter, QLCNIC_BC_CMD_CHANNEL_INIT);\n\tif (!err) {\n\t\tif (netif_running(netdev)) {\n\t\t\terr = qlcnic_up(adapter, netdev);\n\t\t\tif (!err)\n\t\t\t\tqlcnic_restore_indev_addr(netdev, NETDEV_UP);\n\t\t}\n\t}\n\n\tnetif_device_attach(netdev);\n\tqlcnic_schedule_work(adapter, qlcnic_sriov_vf_poll_dev_state,\n\t\t\t     idc->delay);\n\treturn err;\n}\n\nint qlcnic_sriov_alloc_vlans(struct qlcnic_adapter *adapter)\n{\n\tstruct qlcnic_sriov *sriov = adapter->ahw->sriov;\n\tstruct qlcnic_vf_info *vf;\n\tint i;\n\n\tfor (i = 0; i < sriov->num_vfs; i++) {\n\t\tvf = &sriov->vf_info[i];\n\t\tvf->sriov_vlans = kcalloc(sriov->num_allowed_vlans,\n\t\t\t\t\t  sizeof(*vf->sriov_vlans), GFP_KERNEL);\n\t\tif (!vf->sriov_vlans)\n\t\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nvoid qlcnic_sriov_free_vlans(struct qlcnic_adapter *adapter)\n{\n\tstruct qlcnic_sriov *sriov = adapter->ahw->sriov;\n\tstruct qlcnic_vf_info *vf;\n\tint i;\n\n\tfor (i = 0; i < sriov->num_vfs; i++) {\n\t\tvf = &sriov->vf_info[i];\n\t\tkfree(vf->sriov_vlans);\n\t\tvf->sriov_vlans = NULL;\n\t}\n}\n\nvoid qlcnic_sriov_add_vlan_id(struct qlcnic_sriov *sriov,\n\t\t\t      struct qlcnic_vf_info *vf, u16 vlan_id)\n{\n\tint i;\n\n\tfor (i = 0; i < sriov->num_allowed_vlans; i++) {\n\t\tif (!vf->sriov_vlans[i]) {\n\t\t\tvf->sriov_vlans[i] = vlan_id;\n\t\t\tvf->num_vlan++;\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nvoid qlcnic_sriov_del_vlan_id(struct qlcnic_sriov *sriov,\n\t\t\t      struct qlcnic_vf_info *vf, u16 vlan_id)\n{\n\tint i;\n\n\tfor (i = 0; i < sriov->num_allowed_vlans; i++) {\n\t\tif (vf->sriov_vlans[i] == vlan_id) {\n\t\t\tvf->sriov_vlans[i] = 0;\n\t\t\tvf->num_vlan--;\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nbool qlcnic_sriov_check_any_vlan(struct qlcnic_vf_info *vf)\n{\n\tbool err = false;\n\n\tspin_lock_bh(&vf->vlan_list_lock);\n\n\tif (vf->num_vlan)\n\t\terr = true;\n\n\tspin_unlock_bh(&vf->vlan_list_lock);\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}