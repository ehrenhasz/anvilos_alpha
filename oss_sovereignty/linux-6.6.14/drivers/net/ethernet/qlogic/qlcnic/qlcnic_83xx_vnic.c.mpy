{
  "module_name": "qlcnic_83xx_vnic.c",
  "hash_id": "861fb4b638d2aff9b55bc43a94efcc0f9027192eb64f47147d762b2a1c3fcfdc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_vnic.c",
  "human_readable_source": "\n \n\n#include \"qlcnic.h\"\n#include \"qlcnic_hw.h\"\n\nstatic int qlcnic_83xx_enable_vnic_mode(struct qlcnic_adapter *adapter, int lock)\n{\n\tif (lock) {\n\t\tif (qlcnic_83xx_lock_driver(adapter))\n\t\t\treturn -EBUSY;\n\t}\n\tQLCWRX(adapter->ahw, QLC_83XX_VNIC_STATE, QLCNIC_DEV_NPAR_OPER);\n\tif (lock)\n\t\tqlcnic_83xx_unlock_driver(adapter);\n\n\treturn 0;\n}\n\nint qlcnic_83xx_disable_vnic_mode(struct qlcnic_adapter *adapter, int lock)\n{\n\tstruct qlcnic_hardware_context *ahw = adapter->ahw;\n\n\tif (lock) {\n\t\tif (qlcnic_83xx_lock_driver(adapter))\n\t\t\treturn -EBUSY;\n\t}\n\n\tQLCWRX(adapter->ahw, QLC_83XX_VNIC_STATE, QLCNIC_DEV_NPAR_NON_OPER);\n\tahw->idc.vnic_state = QLCNIC_DEV_NPAR_NON_OPER;\n\n\tif (lock)\n\t\tqlcnic_83xx_unlock_driver(adapter);\n\n\treturn 0;\n}\n\nint qlcnic_83xx_set_vnic_opmode(struct qlcnic_adapter *adapter)\n{\n\tu8 id;\n\tint ret = -EBUSY;\n\tu32 data = QLCNIC_MGMT_FUNC;\n\tstruct qlcnic_hardware_context *ahw = adapter->ahw;\n\n\tif (qlcnic_83xx_lock_driver(adapter))\n\t\treturn ret;\n\n\tid = ahw->pci_func;\n\tdata = QLCRDX(adapter->ahw, QLC_83XX_DRV_OP_MODE);\n\tdata = (data & ~QLC_83XX_SET_FUNC_OPMODE(0x3, id)) |\n\t       QLC_83XX_SET_FUNC_OPMODE(QLCNIC_MGMT_FUNC, id);\n\n\tQLCWRX(adapter->ahw, QLC_83XX_DRV_OP_MODE, data);\n\n\tqlcnic_83xx_unlock_driver(adapter);\n\n\treturn 0;\n}\n\nstatic void\nqlcnic_83xx_config_vnic_buff_descriptors(struct qlcnic_adapter *adapter)\n{\n\tstruct qlcnic_hardware_context *ahw = adapter->ahw;\n\n\tif (ahw->port_type == QLCNIC_XGBE) {\n\t\tadapter->num_rxd = DEFAULT_RCV_DESCRIPTORS_VF;\n\t\tadapter->max_rxd = MAX_RCV_DESCRIPTORS_VF;\n\t\tadapter->num_jumbo_rxd = MAX_JUMBO_RCV_DESCRIPTORS_10G;\n\t\tadapter->max_jumbo_rxd = MAX_JUMBO_RCV_DESCRIPTORS_10G;\n\n\t} else if (ahw->port_type == QLCNIC_GBE) {\n\t\tadapter->num_rxd = DEFAULT_RCV_DESCRIPTORS_1G;\n\t\tadapter->num_jumbo_rxd = MAX_JUMBO_RCV_DESCRIPTORS_1G;\n\t\tadapter->max_jumbo_rxd = MAX_JUMBO_RCV_DESCRIPTORS_1G;\n\t\tadapter->max_rxd = MAX_RCV_DESCRIPTORS_1G;\n\t}\n\tadapter->num_txd = MAX_CMD_DESCRIPTORS;\n\tadapter->max_rds_rings = MAX_RDS_RINGS;\n}\n\n\n \nstatic int qlcnic_83xx_init_mgmt_vnic(struct qlcnic_adapter *adapter)\n{\n\tstruct qlcnic_hardware_context *ahw = adapter->ahw;\n\tstruct device *dev = &adapter->pdev->dev;\n\tstruct qlcnic_npar_info *npar;\n\tint i, err = -EIO;\n\n\tqlcnic_83xx_get_minidump_template(adapter);\n\n\tif (!(adapter->flags & QLCNIC_ADAPTER_INITIALIZED)) {\n\t\tif (qlcnic_init_pci_info(adapter))\n\t\t\treturn err;\n\n\t\tnpar = adapter->npars;\n\n\t\tfor (i = 0; i < ahw->total_nic_func; i++, npar++) {\n\t\t\tdev_info(dev, \"id:%d active:%d type:%d port:%d min_bw:%d max_bw:%d mac_addr:%pM\\n\",\n\t\t\t\t npar->pci_func, npar->active, npar->type,\n\t\t\t\t npar->phy_port, npar->min_bw, npar->max_bw,\n\t\t\t\t npar->mac);\n\t\t}\n\n\t\tdev_info(dev, \"Max functions = %d, active functions = %d\\n\",\n\t\t\t ahw->max_pci_func, ahw->total_nic_func);\n\n\t\tif (qlcnic_83xx_set_vnic_opmode(adapter))\n\t\t\treturn err;\n\n\t\tif (qlcnic_set_default_offload_settings(adapter))\n\t\t\treturn err;\n\t} else {\n\t\tif (qlcnic_reset_npar_config(adapter))\n\t\t\treturn err;\n\t}\n\n\tif (qlcnic_83xx_get_port_info(adapter))\n\t\treturn err;\n\n\tqlcnic_83xx_config_vnic_buff_descriptors(adapter);\n\tahw->msix_supported = qlcnic_use_msi_x ? 1 : 0;\n\tadapter->flags |= QLCNIC_ADAPTER_INITIALIZED;\n\tqlcnic_83xx_enable_vnic_mode(adapter, 1);\n\n\tdev_info(dev, \"HAL Version: %d, Management function\\n\",\n\t\t ahw->fw_hal_version);\n\n\treturn 0;\n}\n\nstatic int qlcnic_83xx_init_privileged_vnic(struct qlcnic_adapter *adapter)\n{\n\tint err = -EIO;\n\n\tqlcnic_83xx_get_minidump_template(adapter);\n\tif (qlcnic_83xx_get_port_info(adapter))\n\t\treturn err;\n\n\tqlcnic_83xx_config_vnic_buff_descriptors(adapter);\n\tadapter->ahw->msix_supported = !!qlcnic_use_msi_x;\n\tadapter->flags |= QLCNIC_ADAPTER_INITIALIZED;\n\n\tdev_info(&adapter->pdev->dev,\n\t\t \"HAL Version: %d, Privileged function\\n\",\n\t\t adapter->ahw->fw_hal_version);\n\treturn 0;\n}\n\nstatic int qlcnic_83xx_init_non_privileged_vnic(struct qlcnic_adapter *adapter)\n{\n\tint err = -EIO;\n\n\tqlcnic_83xx_get_fw_version(adapter);\n\tif (qlcnic_set_eswitch_port_config(adapter))\n\t\treturn err;\n\n\tif (qlcnic_83xx_get_port_info(adapter))\n\t\treturn err;\n\n\tqlcnic_83xx_config_vnic_buff_descriptors(adapter);\n\tadapter->ahw->msix_supported = !!qlcnic_use_msi_x;\n\tadapter->flags |= QLCNIC_ADAPTER_INITIALIZED;\n\n\tdev_info(&adapter->pdev->dev, \"HAL Version: %d, Virtual function\\n\",\n\t\t adapter->ahw->fw_hal_version);\n\n\treturn 0;\n}\n\n \nint qlcnic_83xx_config_vnic_opmode(struct qlcnic_adapter *adapter)\n{\n\tu32 op_mode, priv_level;\n\tstruct qlcnic_hardware_context *ahw = adapter->ahw;\n\tstruct qlcnic_nic_template *nic_ops = adapter->nic_ops;\n\n\tqlcnic_get_func_no(adapter);\n\top_mode = QLCRDX(adapter->ahw, QLC_83XX_DRV_OP_MODE);\n\n\tif (op_mode == QLC_83XX_DEFAULT_OPMODE)\n\t\tpriv_level = QLCNIC_MGMT_FUNC;\n\telse\n\t\tpriv_level = QLC_83XX_GET_FUNC_PRIVILEGE(op_mode,\n\t\t\t\t\t\t\t ahw->pci_func);\n\tswitch (priv_level) {\n\tcase QLCNIC_NON_PRIV_FUNC:\n\t\tahw->op_mode = QLCNIC_NON_PRIV_FUNC;\n\t\tahw->idc.state_entry = qlcnic_83xx_idc_ready_state_entry;\n\t\tnic_ops->init_driver = qlcnic_83xx_init_non_privileged_vnic;\n\t\tbreak;\n\tcase QLCNIC_PRIV_FUNC:\n\t\tahw->op_mode = QLCNIC_PRIV_FUNC;\n\t\tahw->idc.state_entry = qlcnic_83xx_idc_vnic_pf_entry;\n\t\tnic_ops->init_driver = qlcnic_83xx_init_privileged_vnic;\n\t\tbreak;\n\tcase QLCNIC_MGMT_FUNC:\n\t\tahw->op_mode = QLCNIC_MGMT_FUNC;\n\t\tahw->idc.state_entry = qlcnic_83xx_idc_ready_state_entry;\n\t\tnic_ops->init_driver = qlcnic_83xx_init_mgmt_vnic;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&adapter->pdev->dev, \"Invalid Virtual NIC opmode\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ahw->capabilities & QLC_83XX_ESWITCH_CAPABILITY) {\n\t\tadapter->flags |= QLCNIC_ESWITCH_ENABLED;\n\t\tif (adapter->drv_mac_learn)\n\t\t\tadapter->rx_mac_learn = true;\n\t} else {\n\t\tadapter->flags &= ~QLCNIC_ESWITCH_ENABLED;\n\t\tadapter->rx_mac_learn = false;\n\t}\n\n\tahw->idc.vnic_state = QLCNIC_DEV_NPAR_NON_OPER;\n\tahw->idc.vnic_wait_limit = QLCNIC_DEV_NPAR_OPER_TIMEO;\n\n\treturn 0;\n}\n\nint qlcnic_83xx_check_vnic_state(struct qlcnic_adapter *adapter)\n{\n\tstruct qlcnic_hardware_context *ahw = adapter->ahw;\n\tstruct qlc_83xx_idc *idc = &ahw->idc;\n\tu32 state;\n\n\tstate = QLCRDX(ahw, QLC_83XX_VNIC_STATE);\n\twhile (state != QLCNIC_DEV_NPAR_OPER && idc->vnic_wait_limit) {\n\t\tidc->vnic_wait_limit--;\n\t\tmsleep(1000);\n\t\tstate = QLCRDX(ahw, QLC_83XX_VNIC_STATE);\n\t}\n\n\tif (state != QLCNIC_DEV_NPAR_OPER) {\n\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\"vNIC mode not operational, state check timed out.\\n\");\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nint qlcnic_83xx_set_port_eswitch_status(struct qlcnic_adapter *adapter,\n\t\t\t\t\tint func, int *port_id)\n{\n\tstruct qlcnic_info nic_info;\n\tint err = 0;\n\n\tmemset(&nic_info, 0, sizeof(struct qlcnic_info));\n\n\terr = qlcnic_get_nic_info(adapter, &nic_info, func);\n\tif (err)\n\t\treturn err;\n\n\tif (nic_info.capabilities & QLC_83XX_ESWITCH_CAPABILITY)\n\t\t*port_id = nic_info.phys_port;\n\telse\n\t\terr = -EIO;\n\n\tif (!err)\n\t\tadapter->eswitch[*port_id].flags |= QLCNIC_SWITCH_ENABLE;\n\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}