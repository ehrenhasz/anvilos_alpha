{
  "module_name": "qlcnic_init.c",
  "hash_id": "f399971cebe381cb9150f5ffbc7fc1f46421faa52d2e9cdcb67a462022ded453",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/qlogic/qlcnic/qlcnic_init.c",
  "human_readable_source": "\n \n\n#include \"qlcnic.h\"\n#include \"qlcnic_hw.h\"\n\nstruct crb_addr_pair {\n\tu32 addr;\n\tu32 data;\n};\n\n#define QLCNIC_MAX_CRB_XFORM 60\nstatic unsigned int crb_addr_xform[QLCNIC_MAX_CRB_XFORM];\n\n#define crb_addr_transform(name) \\\n\t(crb_addr_xform[QLCNIC_HW_PX_MAP_CRB_##name] = \\\n\tQLCNIC_HW_CRB_HUB_AGT_ADR_##name << 20)\n\n#define QLCNIC_ADDR_ERROR (0xffffffff)\n\nstatic int\nqlcnic_check_fw_hearbeat(struct qlcnic_adapter *adapter);\n\nstatic void crb_addr_transform_setup(void)\n{\n\tcrb_addr_transform(XDMA);\n\tcrb_addr_transform(TIMR);\n\tcrb_addr_transform(SRE);\n\tcrb_addr_transform(SQN3);\n\tcrb_addr_transform(SQN2);\n\tcrb_addr_transform(SQN1);\n\tcrb_addr_transform(SQN0);\n\tcrb_addr_transform(SQS3);\n\tcrb_addr_transform(SQS2);\n\tcrb_addr_transform(SQS1);\n\tcrb_addr_transform(SQS0);\n\tcrb_addr_transform(RPMX7);\n\tcrb_addr_transform(RPMX6);\n\tcrb_addr_transform(RPMX5);\n\tcrb_addr_transform(RPMX4);\n\tcrb_addr_transform(RPMX3);\n\tcrb_addr_transform(RPMX2);\n\tcrb_addr_transform(RPMX1);\n\tcrb_addr_transform(RPMX0);\n\tcrb_addr_transform(ROMUSB);\n\tcrb_addr_transform(SN);\n\tcrb_addr_transform(QMN);\n\tcrb_addr_transform(QMS);\n\tcrb_addr_transform(PGNI);\n\tcrb_addr_transform(PGND);\n\tcrb_addr_transform(PGN3);\n\tcrb_addr_transform(PGN2);\n\tcrb_addr_transform(PGN1);\n\tcrb_addr_transform(PGN0);\n\tcrb_addr_transform(PGSI);\n\tcrb_addr_transform(PGSD);\n\tcrb_addr_transform(PGS3);\n\tcrb_addr_transform(PGS2);\n\tcrb_addr_transform(PGS1);\n\tcrb_addr_transform(PGS0);\n\tcrb_addr_transform(PS);\n\tcrb_addr_transform(PH);\n\tcrb_addr_transform(NIU);\n\tcrb_addr_transform(I2Q);\n\tcrb_addr_transform(EG);\n\tcrb_addr_transform(MN);\n\tcrb_addr_transform(MS);\n\tcrb_addr_transform(CAS2);\n\tcrb_addr_transform(CAS1);\n\tcrb_addr_transform(CAS0);\n\tcrb_addr_transform(CAM);\n\tcrb_addr_transform(C2C1);\n\tcrb_addr_transform(C2C0);\n\tcrb_addr_transform(SMB);\n\tcrb_addr_transform(OCM0);\n\tcrb_addr_transform(I2C0);\n}\n\nvoid qlcnic_release_rx_buffers(struct qlcnic_adapter *adapter)\n{\n\tstruct qlcnic_recv_context *recv_ctx;\n\tstruct qlcnic_host_rds_ring *rds_ring;\n\tstruct qlcnic_rx_buffer *rx_buf;\n\tint i, ring;\n\n\trecv_ctx = adapter->recv_ctx;\n\tfor (ring = 0; ring < adapter->max_rds_rings; ring++) {\n\t\trds_ring = &recv_ctx->rds_rings[ring];\n\t\tfor (i = 0; i < rds_ring->num_desc; ++i) {\n\t\t\trx_buf = &(rds_ring->rx_buf_arr[i]);\n\t\t\tif (rx_buf->skb == NULL)\n\t\t\t\tcontinue;\n\n\t\t\tdma_unmap_single(&adapter->pdev->dev, rx_buf->dma,\n\t\t\t\t\t rds_ring->dma_size, DMA_FROM_DEVICE);\n\n\t\t\tdev_kfree_skb_any(rx_buf->skb);\n\t\t}\n\t}\n}\n\nvoid qlcnic_reset_rx_buffers_list(struct qlcnic_adapter *adapter)\n{\n\tstruct qlcnic_recv_context *recv_ctx;\n\tstruct qlcnic_host_rds_ring *rds_ring;\n\tstruct qlcnic_rx_buffer *rx_buf;\n\tint i, ring;\n\n\trecv_ctx = adapter->recv_ctx;\n\tfor (ring = 0; ring < adapter->max_rds_rings; ring++) {\n\t\trds_ring = &recv_ctx->rds_rings[ring];\n\n\t\tINIT_LIST_HEAD(&rds_ring->free_list);\n\n\t\trx_buf = rds_ring->rx_buf_arr;\n\t\tfor (i = 0; i < rds_ring->num_desc; i++) {\n\t\t\tlist_add_tail(&rx_buf->list,\n\t\t\t\t\t&rds_ring->free_list);\n\t\t\trx_buf++;\n\t\t}\n\t}\n}\n\nvoid qlcnic_release_tx_buffers(struct qlcnic_adapter *adapter,\n\t\t\t       struct qlcnic_host_tx_ring *tx_ring)\n{\n\tstruct qlcnic_cmd_buffer *cmd_buf;\n\tstruct qlcnic_skb_frag *buffrag;\n\tint i, j;\n\n\tspin_lock(&tx_ring->tx_clean_lock);\n\n\tcmd_buf = tx_ring->cmd_buf_arr;\n\tfor (i = 0; i < tx_ring->num_desc; i++) {\n\t\tbuffrag = cmd_buf->frag_array;\n\t\tif (buffrag->dma) {\n\t\t\tdma_unmap_single(&adapter->pdev->dev, buffrag->dma,\n\t\t\t\t\t buffrag->length, DMA_TO_DEVICE);\n\t\t\tbuffrag->dma = 0ULL;\n\t\t}\n\t\tfor (j = 1; j < cmd_buf->frag_count; j++) {\n\t\t\tbuffrag++;\n\t\t\tif (buffrag->dma) {\n\t\t\t\tdma_unmap_page(&adapter->pdev->dev,\n\t\t\t\t\t       buffrag->dma, buffrag->length,\n\t\t\t\t\t       DMA_TO_DEVICE);\n\t\t\t\tbuffrag->dma = 0ULL;\n\t\t\t}\n\t\t}\n\t\tif (cmd_buf->skb) {\n\t\t\tdev_kfree_skb_any(cmd_buf->skb);\n\t\t\tcmd_buf->skb = NULL;\n\t\t}\n\t\tcmd_buf++;\n\t}\n\n\tspin_unlock(&tx_ring->tx_clean_lock);\n}\n\nvoid qlcnic_free_sw_resources(struct qlcnic_adapter *adapter)\n{\n\tstruct qlcnic_recv_context *recv_ctx;\n\tstruct qlcnic_host_rds_ring *rds_ring;\n\tint ring;\n\n\trecv_ctx = adapter->recv_ctx;\n\n\tif (recv_ctx->rds_rings == NULL)\n\t\treturn;\n\n\tfor (ring = 0; ring < adapter->max_rds_rings; ring++) {\n\t\trds_ring = &recv_ctx->rds_rings[ring];\n\t\tvfree(rds_ring->rx_buf_arr);\n\t\trds_ring->rx_buf_arr = NULL;\n\t}\n\tkfree(recv_ctx->rds_rings);\n}\n\nint qlcnic_alloc_sw_resources(struct qlcnic_adapter *adapter)\n{\n\tstruct qlcnic_recv_context *recv_ctx;\n\tstruct qlcnic_host_rds_ring *rds_ring;\n\tstruct qlcnic_host_sds_ring *sds_ring;\n\tstruct qlcnic_rx_buffer *rx_buf;\n\tint ring, i;\n\n\trecv_ctx = adapter->recv_ctx;\n\n\trds_ring = kcalloc(adapter->max_rds_rings,\n\t\t\t   sizeof(struct qlcnic_host_rds_ring), GFP_KERNEL);\n\tif (rds_ring == NULL)\n\t\tgoto err_out;\n\n\trecv_ctx->rds_rings = rds_ring;\n\n\tfor (ring = 0; ring < adapter->max_rds_rings; ring++) {\n\t\trds_ring = &recv_ctx->rds_rings[ring];\n\t\tswitch (ring) {\n\t\tcase RCV_RING_NORMAL:\n\t\t\trds_ring->num_desc = adapter->num_rxd;\n\t\t\trds_ring->dma_size = QLCNIC_P3P_RX_BUF_MAX_LEN;\n\t\t\trds_ring->skb_size = rds_ring->dma_size + NET_IP_ALIGN;\n\t\t\tbreak;\n\n\t\tcase RCV_RING_JUMBO:\n\t\t\trds_ring->num_desc = adapter->num_jumbo_rxd;\n\t\t\trds_ring->dma_size =\n\t\t\t\tQLCNIC_P3P_RX_JUMBO_BUF_MAX_LEN;\n\n\t\t\tif (adapter->ahw->capabilities &\n\t\t\t    QLCNIC_FW_CAPABILITY_HW_LRO)\n\t\t\t\trds_ring->dma_size += QLCNIC_LRO_BUFFER_EXTRA;\n\n\t\t\trds_ring->skb_size =\n\t\t\t\trds_ring->dma_size + NET_IP_ALIGN;\n\t\t\tbreak;\n\t\t}\n\t\trds_ring->rx_buf_arr = vzalloc(RCV_BUFF_RINGSIZE(rds_ring));\n\t\tif (rds_ring->rx_buf_arr == NULL)\n\t\t\tgoto err_out;\n\n\t\tINIT_LIST_HEAD(&rds_ring->free_list);\n\t\t \n\t\trx_buf = rds_ring->rx_buf_arr;\n\t\tfor (i = 0; i < rds_ring->num_desc; i++) {\n\t\t\tlist_add_tail(&rx_buf->list,\n\t\t\t\t\t&rds_ring->free_list);\n\t\t\trx_buf->ref_handle = i;\n\t\t\trx_buf++;\n\t\t}\n\t\tspin_lock_init(&rds_ring->lock);\n\t}\n\n\tfor (ring = 0; ring < adapter->drv_sds_rings; ring++) {\n\t\tsds_ring = &recv_ctx->sds_rings[ring];\n\t\tsds_ring->irq = adapter->msix_entries[ring].vector;\n\t\tsds_ring->adapter = adapter;\n\t\tsds_ring->num_desc = adapter->num_rxd;\n\t\tif (qlcnic_82xx_check(adapter)) {\n\t\t\tif (qlcnic_check_multi_tx(adapter) &&\n\t\t\t    !adapter->ahw->diag_test)\n\t\t\t\tsds_ring->tx_ring = &adapter->tx_ring[ring];\n\t\t\telse\n\t\t\t\tsds_ring->tx_ring = &adapter->tx_ring[0];\n\t\t}\n\t\tfor (i = 0; i < NUM_RCV_DESC_RINGS; i++)\n\t\t\tINIT_LIST_HEAD(&sds_ring->free_list[i]);\n\t}\n\n\treturn 0;\n\nerr_out:\n\tqlcnic_free_sw_resources(adapter);\n\treturn -ENOMEM;\n}\n\n \nstatic u32 qlcnic_decode_crb_addr(u32 addr)\n{\n\tint i;\n\tu32 base_addr, offset, pci_base;\n\n\tcrb_addr_transform_setup();\n\n\tpci_base = QLCNIC_ADDR_ERROR;\n\tbase_addr = addr & 0xfff00000;\n\toffset = addr & 0x000fffff;\n\n\tfor (i = 0; i < QLCNIC_MAX_CRB_XFORM; i++) {\n\t\tif (crb_addr_xform[i] == base_addr) {\n\t\t\tpci_base = i << 20;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (pci_base == QLCNIC_ADDR_ERROR)\n\t\treturn pci_base;\n\telse\n\t\treturn pci_base + offset;\n}\n\n#define QLCNIC_MAX_ROM_WAIT_USEC\t100\n\nstatic int qlcnic_wait_rom_done(struct qlcnic_adapter *adapter)\n{\n\tlong timeout = 0;\n\tlong done = 0;\n\tint err = 0;\n\n\tcond_resched();\n\twhile (done == 0) {\n\t\tdone = QLCRD32(adapter, QLCNIC_ROMUSB_GLB_STATUS, &err);\n\t\tdone &= 2;\n\t\tif (++timeout >= QLCNIC_MAX_ROM_WAIT_USEC) {\n\t\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\t\"Timeout reached  waiting for rom done\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tudelay(1);\n\t}\n\treturn 0;\n}\n\nstatic int do_rom_fast_read(struct qlcnic_adapter *adapter,\n\t\t\t    u32 addr, u32 *valp)\n{\n\tint err = 0;\n\n\tQLCWR32(adapter, QLCNIC_ROMUSB_ROM_ADDRESS, addr);\n\tQLCWR32(adapter, QLCNIC_ROMUSB_ROM_DUMMY_BYTE_CNT, 0);\n\tQLCWR32(adapter, QLCNIC_ROMUSB_ROM_ABYTE_CNT, 3);\n\tQLCWR32(adapter, QLCNIC_ROMUSB_ROM_INSTR_OPCODE, 0xb);\n\tif (qlcnic_wait_rom_done(adapter)) {\n\t\tdev_err(&adapter->pdev->dev, \"Error waiting for rom done\\n\");\n\t\treturn -EIO;\n\t}\n\t \n\tQLCWR32(adapter, QLCNIC_ROMUSB_ROM_ABYTE_CNT, 0);\n\tudelay(10);\n\tQLCWR32(adapter, QLCNIC_ROMUSB_ROM_DUMMY_BYTE_CNT, 0);\n\n\t*valp = QLCRD32(adapter, QLCNIC_ROMUSB_ROM_RDATA, &err);\n\tif (err == -EIO)\n\t\treturn err;\n\treturn 0;\n}\n\nstatic int do_rom_fast_read_words(struct qlcnic_adapter *adapter, int addr,\n\t\t\t\t  u8 *bytes, size_t size)\n{\n\tint addridx;\n\tint ret = 0;\n\n\tfor (addridx = addr; addridx < (addr + size); addridx += 4) {\n\t\tint v;\n\t\tret = do_rom_fast_read(adapter, addridx, &v);\n\t\tif (ret != 0)\n\t\t\tbreak;\n\t\t*(__le32 *)bytes = cpu_to_le32(v);\n\t\tbytes += 4;\n\t}\n\n\treturn ret;\n}\n\nint\nqlcnic_rom_fast_read_words(struct qlcnic_adapter *adapter, int addr,\n\t\t\t\tu8 *bytes, size_t size)\n{\n\tint ret;\n\n\tret = qlcnic_rom_lock(adapter);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = do_rom_fast_read_words(adapter, addr, bytes, size);\n\n\tqlcnic_rom_unlock(adapter);\n\treturn ret;\n}\n\nint qlcnic_rom_fast_read(struct qlcnic_adapter *adapter, u32 addr, u32 *valp)\n{\n\tint ret;\n\n\tif (qlcnic_rom_lock(adapter) != 0)\n\t\treturn -EIO;\n\n\tret = do_rom_fast_read(adapter, addr, valp);\n\tqlcnic_rom_unlock(adapter);\n\treturn ret;\n}\n\nint qlcnic_pinit_from_rom(struct qlcnic_adapter *adapter)\n{\n\tint addr, err = 0;\n\tint i, n, init_delay;\n\tstruct crb_addr_pair *buf;\n\tunsigned offset;\n\tu32 off, val;\n\tstruct pci_dev *pdev = adapter->pdev;\n\n\tQLC_SHARED_REG_WR32(adapter, QLCNIC_CMDPEG_STATE, 0);\n\tQLC_SHARED_REG_WR32(adapter, QLCNIC_RCVPEG_STATE, 0);\n\n\t \n\t \n\tQLCWR32(adapter, QLCNIC_CRB_I2Q + 0x10, 0x0);\n\tQLCWR32(adapter, QLCNIC_CRB_I2Q + 0x14, 0x0);\n\tQLCWR32(adapter, QLCNIC_CRB_I2Q + 0x18, 0x0);\n\tQLCWR32(adapter, QLCNIC_CRB_I2Q + 0x1c, 0x0);\n\tQLCWR32(adapter, QLCNIC_CRB_I2Q + 0x20, 0x0);\n\tQLCWR32(adapter, QLCNIC_CRB_I2Q + 0x24, 0x0);\n\n\t \n\tQLCWR32(adapter, QLCNIC_CRB_NIU + 0x40, 0xff);\n\t \n\tQLCWR32(adapter, QLCNIC_CRB_NIU + 0x70000, 0x00);\n\t \n\tQLCWR32(adapter, QLCNIC_CRB_NIU + 0x80000, 0x00);\n\t \n\tQLCWR32(adapter, QLCNIC_CRB_NIU + 0x90000, 0x00);\n\t \n\tQLCWR32(adapter, QLCNIC_CRB_NIU + 0xa0000, 0x00);\n\t \n\tQLCWR32(adapter, QLCNIC_CRB_NIU + 0xb0000, 0x00);\n\n\t \n\tval = QLCRD32(adapter, QLCNIC_CRB_SRE + 0x1000, &err);\n\tif (err == -EIO)\n\t\treturn err;\n\tQLCWR32(adapter, QLCNIC_CRB_SRE + 0x1000, val & (~(0x1)));\n\n\t \n\tQLCWR32(adapter, QLCNIC_CRB_EPG + 0x1300, 0x1);\n\n\t \n\tQLCWR32(adapter, QLCNIC_CRB_TIMER + 0x0, 0x0);\n\tQLCWR32(adapter, QLCNIC_CRB_TIMER + 0x8, 0x0);\n\tQLCWR32(adapter, QLCNIC_CRB_TIMER + 0x10, 0x0);\n\tQLCWR32(adapter, QLCNIC_CRB_TIMER + 0x18, 0x0);\n\tQLCWR32(adapter, QLCNIC_CRB_TIMER + 0x100, 0x0);\n\tQLCWR32(adapter, QLCNIC_CRB_TIMER + 0x200, 0x0);\n\t \n\tQLCWR32(adapter, QLCNIC_CRB_PEG_NET_0 + 0x3c, 1);\n\tQLCWR32(adapter, QLCNIC_CRB_PEG_NET_1 + 0x3c, 1);\n\tQLCWR32(adapter, QLCNIC_CRB_PEG_NET_2 + 0x3c, 1);\n\tQLCWR32(adapter, QLCNIC_CRB_PEG_NET_3 + 0x3c, 1);\n\tQLCWR32(adapter, QLCNIC_CRB_PEG_NET_4 + 0x3c, 1);\n\tmsleep(20);\n\n\t \n\tQLCWR32(adapter, QLCNIC_ROMUSB_GLB_SW_RESET, 0xfeffffff);\n\n\t \n\tif (qlcnic_rom_fast_read(adapter, 0, &n) != 0 || (n != 0xcafecafe) ||\n\t\t\tqlcnic_rom_fast_read(adapter, 4, &n) != 0) {\n\t\tdev_err(&pdev->dev, \"ERROR Reading crb_init area: val:%x\\n\", n);\n\t\treturn -EIO;\n\t}\n\toffset = n & 0xffffU;\n\tn = (n >> 16) & 0xffffU;\n\n\tif (n >= 1024) {\n\t\tdev_err(&pdev->dev, \"QLOGIC card flash not initialized.\\n\");\n\t\treturn -EIO;\n\t}\n\n\tbuf = kcalloc(n, sizeof(struct crb_addr_pair), GFP_KERNEL);\n\tif (buf == NULL)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < n; i++) {\n\t\tif (qlcnic_rom_fast_read(adapter, 8*i + 4*offset, &val) != 0 ||\n\t\tqlcnic_rom_fast_read(adapter, 8*i + 4*offset + 4, &addr) != 0) {\n\t\t\tkfree(buf);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tbuf[i].addr = addr;\n\t\tbuf[i].data = val;\n\t}\n\n\tfor (i = 0; i < n; i++) {\n\n\t\toff = qlcnic_decode_crb_addr(buf[i].addr);\n\t\tif (off == QLCNIC_ADDR_ERROR) {\n\t\t\tdev_err(&pdev->dev, \"CRB init value out of range %x\\n\",\n\t\t\t\t\tbuf[i].addr);\n\t\t\tcontinue;\n\t\t}\n\t\toff += QLCNIC_PCI_CRBSPACE;\n\n\t\tif (off & 1)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (off == QLCNIC_CAM_RAM(0x1fc))\n\t\t\tcontinue;\n\t\tif (off == (QLCNIC_CRB_I2C0 + 0x1c))\n\t\t\tcontinue;\n\t\tif (off == (ROMUSB_GLB + 0xbc))  \n\t\t\tcontinue;\n\t\tif (off == (ROMUSB_GLB + 0xa8))\n\t\t\tcontinue;\n\t\tif (off == (ROMUSB_GLB + 0xc8))  \n\t\t\tcontinue;\n\t\tif (off == (ROMUSB_GLB + 0x24))  \n\t\t\tcontinue;\n\t\tif (off == (ROMUSB_GLB + 0x1c))  \n\t\t\tcontinue;\n\t\tif ((off & 0x0ff00000) == QLCNIC_CRB_DDR_NET)\n\t\t\tcontinue;\n\t\t \n\t\tif (off == QLCNIC_PCIE_REG(PCIE_SETUP_FUNCTION))\n\t\t\tcontinue;\n\t\tif (off == QLCNIC_PCIE_REG(PCIE_SETUP_FUNCTION2))\n\t\t\tcontinue;\n\t\tif ((off & 0x0ff00000) == QLCNIC_CRB_SMB)\n\t\t\tcontinue;\n\n\t\tinit_delay = 1;\n\t\t \n\t\t \n\t\tif (off == QLCNIC_ROMUSB_GLB_SW_RESET)\n\t\t\tinit_delay = 1000;\n\n\t\tQLCWR32(adapter, off, buf[i].data);\n\n\t\tmsleep(init_delay);\n\t}\n\tkfree(buf);\n\n\t \n\tQLCWR32(adapter, QLCNIC_CRB_PEG_NET_D + 0xec, 0x1e);\n\tQLCWR32(adapter, QLCNIC_CRB_PEG_NET_D + 0x4c, 8);\n\tQLCWR32(adapter, QLCNIC_CRB_PEG_NET_I + 0x4c, 8);\n\tQLCWR32(adapter, QLCNIC_CRB_PEG_NET_0 + 0x8, 0);\n\tQLCWR32(adapter, QLCNIC_CRB_PEG_NET_0 + 0xc, 0);\n\tQLCWR32(adapter, QLCNIC_CRB_PEG_NET_1 + 0x8, 0);\n\tQLCWR32(adapter, QLCNIC_CRB_PEG_NET_1 + 0xc, 0);\n\tQLCWR32(adapter, QLCNIC_CRB_PEG_NET_2 + 0x8, 0);\n\tQLCWR32(adapter, QLCNIC_CRB_PEG_NET_2 + 0xc, 0);\n\tQLCWR32(adapter, QLCNIC_CRB_PEG_NET_3 + 0x8, 0);\n\tQLCWR32(adapter, QLCNIC_CRB_PEG_NET_3 + 0xc, 0);\n\tQLCWR32(adapter, QLCNIC_CRB_PEG_NET_4 + 0x8, 0);\n\tQLCWR32(adapter, QLCNIC_CRB_PEG_NET_4 + 0xc, 0);\n\tusleep_range(1000, 1500);\n\n\tQLC_SHARED_REG_WR32(adapter, QLCNIC_PEG_HALT_STATUS1, 0);\n\tQLC_SHARED_REG_WR32(adapter, QLCNIC_PEG_HALT_STATUS2, 0);\n\n\treturn 0;\n}\n\nstatic int qlcnic_cmd_peg_ready(struct qlcnic_adapter *adapter)\n{\n\tu32 val;\n\tint retries = QLCNIC_CMDPEG_CHECK_RETRY_COUNT;\n\n\tdo {\n\t\tval = QLC_SHARED_REG_RD32(adapter, QLCNIC_CMDPEG_STATE);\n\n\t\tswitch (val) {\n\t\tcase PHAN_INITIALIZE_COMPLETE:\n\t\tcase PHAN_INITIALIZE_ACK:\n\t\t\treturn 0;\n\t\tcase PHAN_INITIALIZE_FAILED:\n\t\t\tgoto out_err;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tmsleep(QLCNIC_CMDPEG_CHECK_DELAY);\n\n\t} while (--retries);\n\n\tQLC_SHARED_REG_WR32(adapter, QLCNIC_CMDPEG_STATE,\n\t\t\t    PHAN_INITIALIZE_FAILED);\n\nout_err:\n\tdev_err(&adapter->pdev->dev, \"Command Peg initialization not \"\n\t\t      \"complete, state: 0x%x.\\n\", val);\n\treturn -EIO;\n}\n\nstatic int\nqlcnic_receive_peg_ready(struct qlcnic_adapter *adapter)\n{\n\tu32 val;\n\tint retries = QLCNIC_RCVPEG_CHECK_RETRY_COUNT;\n\n\tdo {\n\t\tval = QLC_SHARED_REG_RD32(adapter, QLCNIC_RCVPEG_STATE);\n\n\t\tif (val == PHAN_PEG_RCV_INITIALIZED)\n\t\t\treturn 0;\n\n\t\tmsleep(QLCNIC_RCVPEG_CHECK_DELAY);\n\n\t} while (--retries);\n\n\tdev_err(&adapter->pdev->dev, \"Receive Peg initialization not complete, state: 0x%x.\\n\",\n\t\tval);\n\treturn -EIO;\n}\n\nint\nqlcnic_check_fw_status(struct qlcnic_adapter *adapter)\n{\n\tint err;\n\n\terr = qlcnic_cmd_peg_ready(adapter);\n\tif (err)\n\t\treturn err;\n\n\terr = qlcnic_receive_peg_ready(adapter);\n\tif (err)\n\t\treturn err;\n\n\tQLC_SHARED_REG_WR32(adapter, QLCNIC_CMDPEG_STATE, PHAN_INITIALIZE_ACK);\n\n\treturn err;\n}\n\nint\nqlcnic_setup_idc_param(struct qlcnic_adapter *adapter) {\n\n\tint timeo;\n\tu32 val;\n\n\tval = QLC_SHARED_REG_RD32(adapter, QLCNIC_CRB_DEV_PARTITION_INFO);\n\tval = QLC_DEV_GET_DRV(val, adapter->portnum);\n\tif ((val & 0x3) != QLCNIC_TYPE_NIC) {\n\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\"Not an Ethernet NIC func=%u\\n\", val);\n\t\treturn -EIO;\n\t}\n\tadapter->ahw->physical_port = (val >> 2);\n\tif (qlcnic_rom_fast_read(adapter, QLCNIC_ROM_DEV_INIT_TIMEOUT, &timeo))\n\t\ttimeo = QLCNIC_INIT_TIMEOUT_SECS;\n\n\tadapter->dev_init_timeo = timeo;\n\n\tif (qlcnic_rom_fast_read(adapter, QLCNIC_ROM_DRV_RESET_TIMEOUT, &timeo))\n\t\ttimeo = QLCNIC_RESET_TIMEOUT_SECS;\n\n\tadapter->reset_ack_timeo = timeo;\n\n\treturn 0;\n}\n\nstatic int qlcnic_get_flt_entry(struct qlcnic_adapter *adapter, u8 region,\n\t\t\t\tstruct qlcnic_flt_entry *region_entry)\n{\n\tstruct qlcnic_flt_header flt_hdr;\n\tstruct qlcnic_flt_entry *flt_entry;\n\tint i = 0, ret;\n\tu32 entry_size;\n\n\tmemset(region_entry, 0, sizeof(struct qlcnic_flt_entry));\n\tret = qlcnic_rom_fast_read_words(adapter, QLCNIC_FLT_LOCATION,\n\t\t\t\t\t (u8 *)&flt_hdr,\n\t\t\t\t\t sizeof(struct qlcnic_flt_header));\n\tif (ret) {\n\t\tdev_warn(&adapter->pdev->dev,\n\t\t\t \"error reading flash layout header\\n\");\n\t\treturn -EIO;\n\t}\n\n\tentry_size = flt_hdr.len - sizeof(struct qlcnic_flt_header);\n\tflt_entry = vzalloc(entry_size);\n\tif (flt_entry == NULL)\n\t\treturn -EIO;\n\n\tret = qlcnic_rom_fast_read_words(adapter, QLCNIC_FLT_LOCATION +\n\t\t\t\t\t sizeof(struct qlcnic_flt_header),\n\t\t\t\t\t (u8 *)flt_entry, entry_size);\n\tif (ret) {\n\t\tdev_warn(&adapter->pdev->dev,\n\t\t\t \"error reading flash layout entries\\n\");\n\t\tgoto err_out;\n\t}\n\n\twhile (i < (entry_size/sizeof(struct qlcnic_flt_entry))) {\n\t\tif (flt_entry[i].region == region)\n\t\t\tbreak;\n\t\ti++;\n\t}\n\tif (i >= (entry_size/sizeof(struct qlcnic_flt_entry))) {\n\t\tdev_warn(&adapter->pdev->dev,\n\t\t\t \"region=%x not found in %d regions\\n\", region, i);\n\t\tret = -EIO;\n\t\tgoto err_out;\n\t}\n\tmemcpy(region_entry, &flt_entry[i], sizeof(struct qlcnic_flt_entry));\n\nerr_out:\n\tvfree(flt_entry);\n\treturn ret;\n}\n\nint\nqlcnic_check_flash_fw_ver(struct qlcnic_adapter *adapter)\n{\n\tstruct qlcnic_flt_entry fw_entry;\n\tu32 ver = -1, min_ver;\n\tint ret;\n\n\tif (adapter->ahw->revision_id == QLCNIC_P3P_C0)\n\t\tret = qlcnic_get_flt_entry(adapter, QLCNIC_C0_FW_IMAGE_REGION,\n\t\t\t\t\t\t &fw_entry);\n\telse\n\t\tret = qlcnic_get_flt_entry(adapter, QLCNIC_B0_FW_IMAGE_REGION,\n\t\t\t\t\t\t &fw_entry);\n\n\tif (!ret)\n\t\t \n\t\tqlcnic_rom_fast_read(adapter, fw_entry.start_addr + 4,\n\t\t\t\t     (int *)&ver);\n\telse\n\t\tqlcnic_rom_fast_read(adapter, QLCNIC_FW_VERSION_OFFSET,\n\t\t\t\t     (int *)&ver);\n\n\tver = QLCNIC_DECODE_VERSION(ver);\n\tmin_ver = QLCNIC_MIN_FW_VERSION;\n\n\tif (ver < min_ver) {\n\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\"firmware version %d.%d.%d unsupported.\"\n\t\t\t\"Min supported version %d.%d.%d\\n\",\n\t\t\t_major(ver), _minor(ver), _build(ver),\n\t\t\t_major(min_ver), _minor(min_ver), _build(min_ver));\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nqlcnic_has_mn(struct qlcnic_adapter *adapter)\n{\n\tu32 capability = 0;\n\tint err = 0;\n\n\tcapability = QLCRD32(adapter, QLCNIC_PEG_TUNE_CAPABILITY, &err);\n\tif (err == -EIO)\n\t\treturn err;\n\tif (capability & QLCNIC_PEG_TUNE_MN_PRESENT)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic\nstruct uni_table_desc *qlcnic_get_table_desc(const u8 *unirom, int section)\n{\n\tu32 i, entries;\n\tstruct uni_table_desc *directory = (struct uni_table_desc *) &unirom[0];\n\tentries = le32_to_cpu(directory->num_entries);\n\n\tfor (i = 0; i < entries; i++) {\n\n\t\tu32 offs = le32_to_cpu(directory->findex) +\n\t\t\t   i * le32_to_cpu(directory->entry_size);\n\t\tu32 tab_type = le32_to_cpu(*((__le32 *)&unirom[offs] + 8));\n\n\t\tif (tab_type == section)\n\t\t\treturn (struct uni_table_desc *) &unirom[offs];\n\t}\n\n\treturn NULL;\n}\n\n#define FILEHEADER_SIZE (14 * 4)\n\nstatic int\nqlcnic_validate_header(struct qlcnic_adapter *adapter)\n{\n\tconst u8 *unirom = adapter->fw->data;\n\tstruct uni_table_desc *directory = (struct uni_table_desc *) &unirom[0];\n\tu32 entries, entry_size, tab_size, fw_file_size;\n\n\tfw_file_size = adapter->fw->size;\n\n\tif (fw_file_size < FILEHEADER_SIZE)\n\t\treturn -EINVAL;\n\n\tentries = le32_to_cpu(directory->num_entries);\n\tentry_size = le32_to_cpu(directory->entry_size);\n\ttab_size = le32_to_cpu(directory->findex) + (entries * entry_size);\n\n\tif (fw_file_size < tab_size)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int\nqlcnic_validate_bootld(struct qlcnic_adapter *adapter)\n{\n\tstruct uni_table_desc *tab_desc;\n\tstruct uni_data_desc *descr;\n\tu32 offs, tab_size, data_size, idx;\n\tconst u8 *unirom = adapter->fw->data;\n\t__le32 temp;\n\n\ttemp = *((__le32 *)&unirom[adapter->file_prd_off] +\n\t\t QLCNIC_UNI_BOOTLD_IDX_OFF);\n\tidx = le32_to_cpu(temp);\n\ttab_desc = qlcnic_get_table_desc(unirom, QLCNIC_UNI_DIR_SECT_BOOTLD);\n\n\tif (!tab_desc)\n\t\treturn -EINVAL;\n\n\ttab_size = le32_to_cpu(tab_desc->findex) +\n\t\t   le32_to_cpu(tab_desc->entry_size) * (idx + 1);\n\n\tif (adapter->fw->size < tab_size)\n\t\treturn -EINVAL;\n\n\toffs = le32_to_cpu(tab_desc->findex) +\n\t       le32_to_cpu(tab_desc->entry_size) * idx;\n\tdescr = (struct uni_data_desc *)&unirom[offs];\n\n\tdata_size = le32_to_cpu(descr->findex) + le32_to_cpu(descr->size);\n\n\tif (adapter->fw->size < data_size)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int\nqlcnic_validate_fw(struct qlcnic_adapter *adapter)\n{\n\tstruct uni_table_desc *tab_desc;\n\tstruct uni_data_desc *descr;\n\tconst u8 *unirom = adapter->fw->data;\n\tu32 offs, tab_size, data_size, idx;\n\t__le32 temp;\n\n\ttemp = *((__le32 *)&unirom[adapter->file_prd_off] +\n\t\t QLCNIC_UNI_FIRMWARE_IDX_OFF);\n\tidx = le32_to_cpu(temp);\n\ttab_desc = qlcnic_get_table_desc(unirom, QLCNIC_UNI_DIR_SECT_FW);\n\n\tif (!tab_desc)\n\t\treturn -EINVAL;\n\n\ttab_size = le32_to_cpu(tab_desc->findex) +\n\t\t   le32_to_cpu(tab_desc->entry_size) * (idx + 1);\n\n\tif (adapter->fw->size < tab_size)\n\t\treturn -EINVAL;\n\n\toffs = le32_to_cpu(tab_desc->findex) +\n\t       le32_to_cpu(tab_desc->entry_size) * idx;\n\tdescr = (struct uni_data_desc *)&unirom[offs];\n\tdata_size = le32_to_cpu(descr->findex) + le32_to_cpu(descr->size);\n\n\tif (adapter->fw->size < data_size)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int\nqlcnic_validate_product_offs(struct qlcnic_adapter *adapter)\n{\n\tstruct uni_table_desc *ptab_descr;\n\tconst u8 *unirom = adapter->fw->data;\n\tint mn_present = qlcnic_has_mn(adapter);\n\tu32 entries, entry_size, tab_size, i;\n\t__le32 temp;\n\n\tptab_descr = qlcnic_get_table_desc(unirom,\n\t\t\t\tQLCNIC_UNI_DIR_SECT_PRODUCT_TBL);\n\tif (!ptab_descr)\n\t\treturn -EINVAL;\n\n\tentries = le32_to_cpu(ptab_descr->num_entries);\n\tentry_size = le32_to_cpu(ptab_descr->entry_size);\n\ttab_size = le32_to_cpu(ptab_descr->findex) + (entries * entry_size);\n\n\tif (adapter->fw->size < tab_size)\n\t\treturn -EINVAL;\n\nnomn:\n\tfor (i = 0; i < entries; i++) {\n\n\t\tu32 flags, file_chiprev, offs;\n\t\tu8 chiprev = adapter->ahw->revision_id;\n\t\tu32 flagbit;\n\n\t\toffs = le32_to_cpu(ptab_descr->findex) +\n\t\t       i * le32_to_cpu(ptab_descr->entry_size);\n\t\ttemp = *((__le32 *)&unirom[offs] + QLCNIC_UNI_FLAGS_OFF);\n\t\tflags = le32_to_cpu(temp);\n\t\ttemp = *((__le32 *)&unirom[offs] + QLCNIC_UNI_CHIP_REV_OFF);\n\t\tfile_chiprev = le32_to_cpu(temp);\n\n\t\tflagbit = mn_present ? 1 : 2;\n\n\t\tif ((chiprev == file_chiprev) &&\n\t\t\t\t\t((1ULL << flagbit) & flags)) {\n\t\t\tadapter->file_prd_off = offs;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (mn_present) {\n\t\tmn_present = 0;\n\t\tgoto nomn;\n\t}\n\treturn -EINVAL;\n}\n\nstatic int\nqlcnic_validate_unified_romimage(struct qlcnic_adapter *adapter)\n{\n\tif (qlcnic_validate_header(adapter)) {\n\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\t\"unified image: header validation failed\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (qlcnic_validate_product_offs(adapter)) {\n\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\t\"unified image: product validation failed\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (qlcnic_validate_bootld(adapter)) {\n\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\t\"unified image: bootld validation failed\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (qlcnic_validate_fw(adapter)) {\n\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\t\"unified image: firmware validation failed\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic\nstruct uni_data_desc *qlcnic_get_data_desc(struct qlcnic_adapter *adapter,\n\t\t\tu32 section, u32 idx_offset)\n{\n\tconst u8 *unirom = adapter->fw->data;\n\tstruct uni_table_desc *tab_desc;\n\tu32 offs, idx;\n\t__le32 temp;\n\n\ttemp = *((__le32 *)&unirom[adapter->file_prd_off] + idx_offset);\n\tidx = le32_to_cpu(temp);\n\n\ttab_desc = qlcnic_get_table_desc(unirom, section);\n\n\tif (tab_desc == NULL)\n\t\treturn NULL;\n\n\toffs = le32_to_cpu(tab_desc->findex) +\n\t       le32_to_cpu(tab_desc->entry_size) * idx;\n\n\treturn (struct uni_data_desc *)&unirom[offs];\n}\n\nstatic u8 *\nqlcnic_get_bootld_offs(struct qlcnic_adapter *adapter)\n{\n\tu32 offs = QLCNIC_BOOTLD_START;\n\tstruct uni_data_desc *data_desc;\n\n\tdata_desc = qlcnic_get_data_desc(adapter, QLCNIC_UNI_DIR_SECT_BOOTLD,\n\t\t\t\t\t QLCNIC_UNI_BOOTLD_IDX_OFF);\n\n\tif (adapter->ahw->fw_type == QLCNIC_UNIFIED_ROMIMAGE)\n\t\toffs = le32_to_cpu(data_desc->findex);\n\n\treturn (u8 *)&adapter->fw->data[offs];\n}\n\nstatic u8 *\nqlcnic_get_fw_offs(struct qlcnic_adapter *adapter)\n{\n\tu32 offs = QLCNIC_IMAGE_START;\n\tstruct uni_data_desc *data_desc;\n\n\tdata_desc = qlcnic_get_data_desc(adapter, QLCNIC_UNI_DIR_SECT_FW,\n\t\t\t\t\t QLCNIC_UNI_FIRMWARE_IDX_OFF);\n\tif (adapter->ahw->fw_type == QLCNIC_UNIFIED_ROMIMAGE)\n\t\toffs = le32_to_cpu(data_desc->findex);\n\n\treturn (u8 *)&adapter->fw->data[offs];\n}\n\nstatic u32 qlcnic_get_fw_size(struct qlcnic_adapter *adapter)\n{\n\tstruct uni_data_desc *data_desc;\n\tconst u8 *unirom = adapter->fw->data;\n\n\tdata_desc = qlcnic_get_data_desc(adapter, QLCNIC_UNI_DIR_SECT_FW,\n\t\t\t\t\t QLCNIC_UNI_FIRMWARE_IDX_OFF);\n\n\tif (adapter->ahw->fw_type == QLCNIC_UNIFIED_ROMIMAGE)\n\t\treturn le32_to_cpu(data_desc->size);\n\telse\n\t\treturn le32_to_cpu(*(__le32 *)&unirom[QLCNIC_FW_SIZE_OFFSET]);\n}\n\nstatic u32 qlcnic_get_fw_version(struct qlcnic_adapter *adapter)\n{\n\tstruct uni_data_desc *fw_data_desc;\n\tconst struct firmware *fw = adapter->fw;\n\tu32 major, minor, sub;\n\t__le32 version_offset;\n\tconst u8 *ver_str;\n\tint i, ret;\n\n\tif (adapter->ahw->fw_type != QLCNIC_UNIFIED_ROMIMAGE) {\n\t\tversion_offset = *(__le32 *)&fw->data[QLCNIC_FW_VERSION_OFFSET];\n\t\treturn le32_to_cpu(version_offset);\n\t}\n\n\tfw_data_desc = qlcnic_get_data_desc(adapter, QLCNIC_UNI_DIR_SECT_FW,\n\t\t\tQLCNIC_UNI_FIRMWARE_IDX_OFF);\n\tver_str = fw->data + le32_to_cpu(fw_data_desc->findex) +\n\t\t  le32_to_cpu(fw_data_desc->size) - 17;\n\n\tfor (i = 0; i < 12; i++) {\n\t\tif (!strncmp(&ver_str[i], \"REV=\", 4)) {\n\t\t\tret = sscanf(&ver_str[i+4], \"%u.%u.%u \",\n\t\t\t\t\t&major, &minor, &sub);\n\t\t\tif (ret != 3)\n\t\t\t\treturn 0;\n\t\t\telse\n\t\t\t\treturn major + (minor << 8) + (sub << 16);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic u32 qlcnic_get_bios_version(struct qlcnic_adapter *adapter)\n{\n\tconst struct firmware *fw = adapter->fw;\n\tu32 bios_ver, prd_off = adapter->file_prd_off;\n\tu8 *version_offset;\n\t__le32 temp;\n\n\tif (adapter->ahw->fw_type != QLCNIC_UNIFIED_ROMIMAGE) {\n\t\tversion_offset = (u8 *)&fw->data[QLCNIC_BIOS_VERSION_OFFSET];\n\t\treturn le32_to_cpu(*(__le32 *)version_offset);\n\t}\n\n\ttemp = *((__le32 *)(&fw->data[prd_off]) + QLCNIC_UNI_BIOS_VERSION_OFF);\n\tbios_ver = le32_to_cpu(temp);\n\n\treturn (bios_ver << 16) + ((bios_ver >> 8) & 0xff00) + (bios_ver >> 24);\n}\n\nstatic void qlcnic_rom_lock_recovery(struct qlcnic_adapter *adapter)\n{\n\tif (qlcnic_pcie_sem_lock(adapter, 2, QLCNIC_ROM_LOCK_ID))\n\t\tdev_info(&adapter->pdev->dev, \"Resetting rom_lock\\n\");\n\n\tqlcnic_pcie_sem_unlock(adapter, 2);\n}\n\nstatic int\nqlcnic_check_fw_hearbeat(struct qlcnic_adapter *adapter)\n{\n\tu32 heartbeat, ret = -EIO;\n\tint retries = QLCNIC_HEARTBEAT_CHECK_RETRY_COUNT;\n\n\tadapter->heartbeat = QLC_SHARED_REG_RD32(adapter,\n\t\t\t\t\t\t QLCNIC_PEG_ALIVE_COUNTER);\n\n\tdo {\n\t\tmsleep(QLCNIC_HEARTBEAT_PERIOD_MSECS);\n\t\theartbeat = QLC_SHARED_REG_RD32(adapter,\n\t\t\t\t\t\tQLCNIC_PEG_ALIVE_COUNTER);\n\t\tif (heartbeat != adapter->heartbeat) {\n\t\t\tret = QLCNIC_RCODE_SUCCESS;\n\t\t\tbreak;\n\t\t}\n\t} while (--retries);\n\n\treturn ret;\n}\n\nint\nqlcnic_need_fw_reset(struct qlcnic_adapter *adapter)\n{\n\tif ((adapter->flags & QLCNIC_FW_HANG) ||\n\t\t\tqlcnic_check_fw_hearbeat(adapter)) {\n\t\tqlcnic_rom_lock_recovery(adapter);\n\t\treturn 1;\n\t}\n\n\tif (adapter->need_fw_reset)\n\t\treturn 1;\n\n\tif (adapter->fw)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic const char *fw_name[] = {\n\tQLCNIC_UNIFIED_ROMIMAGE_NAME,\n\tQLCNIC_FLASH_ROMIMAGE_NAME,\n};\n\nint\nqlcnic_load_firmware(struct qlcnic_adapter *adapter)\n{\n\t__le64 *ptr64;\n\tu32 i, flashaddr, size;\n\tconst struct firmware *fw = adapter->fw;\n\tstruct pci_dev *pdev = adapter->pdev;\n\n\tdev_info(&pdev->dev, \"loading firmware from %s\\n\",\n\t\t fw_name[adapter->ahw->fw_type]);\n\n\tif (fw) {\n\t\tu64 data;\n\n\t\tsize = (QLCNIC_IMAGE_START - QLCNIC_BOOTLD_START) / 8;\n\n\t\tptr64 = (__le64 *)qlcnic_get_bootld_offs(adapter);\n\t\tflashaddr = QLCNIC_BOOTLD_START;\n\n\t\tfor (i = 0; i < size; i++) {\n\t\t\tdata = le64_to_cpu(ptr64[i]);\n\n\t\t\tif (qlcnic_pci_mem_write_2M(adapter, flashaddr, data))\n\t\t\t\treturn -EIO;\n\n\t\t\tflashaddr += 8;\n\t\t}\n\n\t\tsize = qlcnic_get_fw_size(adapter) / 8;\n\n\t\tptr64 = (__le64 *)qlcnic_get_fw_offs(adapter);\n\t\tflashaddr = QLCNIC_IMAGE_START;\n\n\t\tfor (i = 0; i < size; i++) {\n\t\t\tdata = le64_to_cpu(ptr64[i]);\n\n\t\t\tif (qlcnic_pci_mem_write_2M(adapter,\n\t\t\t\t\t\tflashaddr, data))\n\t\t\t\treturn -EIO;\n\n\t\t\tflashaddr += 8;\n\t\t}\n\n\t\tsize = qlcnic_get_fw_size(adapter) % 8;\n\t\tif (size) {\n\t\t\tdata = le64_to_cpu(ptr64[i]);\n\n\t\t\tif (qlcnic_pci_mem_write_2M(adapter,\n\t\t\t\t\t\tflashaddr, data))\n\t\t\t\treturn -EIO;\n\t\t}\n\n\t} else {\n\t\tu64 data;\n\t\tu32 hi, lo;\n\t\tint ret;\n\t\tstruct qlcnic_flt_entry bootld_entry;\n\n\t\tret = qlcnic_get_flt_entry(adapter, QLCNIC_BOOTLD_REGION,\n\t\t\t\t\t&bootld_entry);\n\t\tif (!ret) {\n\t\t\tsize = bootld_entry.size / 8;\n\t\t\tflashaddr = bootld_entry.start_addr;\n\t\t} else {\n\t\t\tsize = (QLCNIC_IMAGE_START - QLCNIC_BOOTLD_START) / 8;\n\t\t\tflashaddr = QLCNIC_BOOTLD_START;\n\t\t\tdev_info(&pdev->dev,\n\t\t\t\t\"using legacy method to get flash fw region\");\n\t\t}\n\n\t\tfor (i = 0; i < size; i++) {\n\t\t\tif (qlcnic_rom_fast_read(adapter,\n\t\t\t\t\tflashaddr, (int *)&lo) != 0)\n\t\t\t\treturn -EIO;\n\t\t\tif (qlcnic_rom_fast_read(adapter,\n\t\t\t\t\tflashaddr + 4, (int *)&hi) != 0)\n\t\t\t\treturn -EIO;\n\n\t\t\tdata = (((u64)hi << 32) | lo);\n\n\t\t\tif (qlcnic_pci_mem_write_2M(adapter,\n\t\t\t\t\t\tflashaddr, data))\n\t\t\t\treturn -EIO;\n\n\t\t\tflashaddr += 8;\n\t\t}\n\t}\n\tusleep_range(1000, 1500);\n\n\tQLCWR32(adapter, QLCNIC_CRB_PEG_NET_0 + 0x18, 0x1020);\n\tQLCWR32(adapter, QLCNIC_ROMUSB_GLB_SW_RESET, 0x80001e);\n\treturn 0;\n}\n\nstatic int\nqlcnic_validate_firmware(struct qlcnic_adapter *adapter)\n{\n\tu32 val;\n\tu32 ver, bios, min_size;\n\tstruct pci_dev *pdev = adapter->pdev;\n\tconst struct firmware *fw = adapter->fw;\n\tu8 fw_type = adapter->ahw->fw_type;\n\n\tif (fw_type == QLCNIC_UNIFIED_ROMIMAGE) {\n\t\tif (qlcnic_validate_unified_romimage(adapter))\n\t\t\treturn -EINVAL;\n\n\t\tmin_size = QLCNIC_UNI_FW_MIN_SIZE;\n\t} else {\n\t\tval = le32_to_cpu(*(__le32 *)&fw->data[QLCNIC_FW_MAGIC_OFFSET]);\n\t\tif (val != QLCNIC_BDINFO_MAGIC)\n\t\t\treturn -EINVAL;\n\n\t\tmin_size = QLCNIC_FW_MIN_SIZE;\n\t}\n\n\tif (fw->size < min_size)\n\t\treturn -EINVAL;\n\n\tval = qlcnic_get_fw_version(adapter);\n\tver = QLCNIC_DECODE_VERSION(val);\n\n\tif (ver < QLCNIC_MIN_FW_VERSION) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\t\"%s: firmware version %d.%d.%d unsupported\\n\",\n\t\tfw_name[fw_type], _major(ver), _minor(ver), _build(ver));\n\t\treturn -EINVAL;\n\t}\n\n\tval = qlcnic_get_bios_version(adapter);\n\tqlcnic_rom_fast_read(adapter, QLCNIC_BIOS_VERSION_OFFSET, (int *)&bios);\n\tif (val != bios) {\n\t\tdev_err(&pdev->dev, \"%s: firmware bios is incompatible\\n\",\n\t\t\t\tfw_name[fw_type]);\n\t\treturn -EINVAL;\n\t}\n\n\tQLC_SHARED_REG_WR32(adapter, QLCNIC_FW_IMG_VALID, QLCNIC_BDINFO_MAGIC);\n\treturn 0;\n}\n\nstatic void\nqlcnic_get_next_fwtype(struct qlcnic_adapter *adapter)\n{\n\tu8 fw_type;\n\n\tswitch (adapter->ahw->fw_type) {\n\tcase QLCNIC_UNKNOWN_ROMIMAGE:\n\t\tfw_type = QLCNIC_UNIFIED_ROMIMAGE;\n\t\tbreak;\n\n\tcase QLCNIC_UNIFIED_ROMIMAGE:\n\tdefault:\n\t\tfw_type = QLCNIC_FLASH_ROMIMAGE;\n\t\tbreak;\n\t}\n\n\tadapter->ahw->fw_type = fw_type;\n}\n\n\n\nvoid qlcnic_request_firmware(struct qlcnic_adapter *adapter)\n{\n\tstruct pci_dev *pdev = adapter->pdev;\n\tint rc;\n\n\tadapter->ahw->fw_type = QLCNIC_UNKNOWN_ROMIMAGE;\n\nnext:\n\tqlcnic_get_next_fwtype(adapter);\n\n\tif (adapter->ahw->fw_type == QLCNIC_FLASH_ROMIMAGE) {\n\t\tadapter->fw = NULL;\n\t} else {\n\t\trc = request_firmware(&adapter->fw,\n\t\t\t\t      fw_name[adapter->ahw->fw_type],\n\t\t\t\t      &pdev->dev);\n\t\tif (rc != 0)\n\t\t\tgoto next;\n\n\t\trc = qlcnic_validate_firmware(adapter);\n\t\tif (rc != 0) {\n\t\t\trelease_firmware(adapter->fw);\n\t\t\tusleep_range(1000, 1500);\n\t\t\tgoto next;\n\t\t}\n\t}\n}\n\n\nvoid\nqlcnic_release_firmware(struct qlcnic_adapter *adapter)\n{\n\trelease_firmware(adapter->fw);\n\tadapter->fw = NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}