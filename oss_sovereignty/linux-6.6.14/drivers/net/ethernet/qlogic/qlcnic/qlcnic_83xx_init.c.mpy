{
  "module_name": "qlcnic_83xx_init.c",
  "hash_id": "3896723dd6a22d15a6d2e7ca007d2dc90b515fa15b6477954f982b77bb1ae8fa",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_init.c",
  "human_readable_source": "\n \n\n#include \"qlcnic_sriov.h\"\n#include \"qlcnic.h\"\n#include \"qlcnic_hw.h\"\n\n \n#define QLC_83XX_RESTART_TEMPLATE_SIZE\t\t0x2000\n#define QLC_83XX_RESET_TEMPLATE_ADDR\t\t0x4F0000\n#define QLC_83XX_RESET_SEQ_VERSION\t\t0x0101\n\n#define QLC_83XX_OPCODE_NOP\t\t\t0x0000\n#define QLC_83XX_OPCODE_WRITE_LIST\t\t0x0001\n#define QLC_83XX_OPCODE_READ_WRITE_LIST\t\t0x0002\n#define QLC_83XX_OPCODE_POLL_LIST\t\t0x0004\n#define QLC_83XX_OPCODE_POLL_WRITE_LIST\t\t0x0008\n#define QLC_83XX_OPCODE_READ_MODIFY_WRITE\t0x0010\n#define QLC_83XX_OPCODE_SEQ_PAUSE\t\t0x0020\n#define QLC_83XX_OPCODE_SEQ_END\t\t\t0x0040\n#define QLC_83XX_OPCODE_TMPL_END\t\t0x0080\n#define QLC_83XX_OPCODE_POLL_READ_LIST\t\t0x0100\n\n \n#define QLC_83XX_RESET_CONTROL\t\t\t0x28084E50\n#define QLC_83XX_RESET_REG\t\t\t0x28084E60\n#define QLC_83XX_RESET_PORT0\t\t\t0x28084E70\n#define QLC_83XX_RESET_PORT1\t\t\t0x28084E80\n#define QLC_83XX_RESET_PORT2\t\t\t0x28084E90\n#define QLC_83XX_RESET_PORT3\t\t\t0x28084EA0\n#define QLC_83XX_RESET_SRESHIM\t\t\t0x28084EB0\n#define QLC_83XX_RESET_EPGSHIM\t\t\t0x28084EC0\n#define QLC_83XX_RESET_ETHERPCS\t\t\t0x28084ED0\n\nstatic int qlcnic_83xx_init_default_driver(struct qlcnic_adapter *adapter);\nstatic int qlcnic_83xx_check_heartbeat(struct qlcnic_adapter *p_dev);\nstatic int qlcnic_83xx_restart_hw(struct qlcnic_adapter *adapter);\nstatic int qlcnic_83xx_check_hw_status(struct qlcnic_adapter *p_dev);\nstatic int qlcnic_83xx_get_reset_instruction_template(struct qlcnic_adapter *);\nstatic void qlcnic_83xx_stop_hw(struct qlcnic_adapter *);\n\n \nstruct qlc_83xx_reset_hdr {\n#if defined(__LITTLE_ENDIAN)\n\tu16\tversion;\n\tu16\tsignature;\n\tu16\tsize;\n\tu16\tentries;\n\tu16\thdr_size;\n\tu16\tchecksum;\n\tu16\tinit_offset;\n\tu16\tstart_offset;\n#elif defined(__BIG_ENDIAN)\n\tu16\tsignature;\n\tu16\tversion;\n\tu16\tentries;\n\tu16\tsize;\n\tu16\tchecksum;\n\tu16\thdr_size;\n\tu16\tstart_offset;\n\tu16\tinit_offset;\n#endif\n} __packed;\n\n \nstruct qlc_83xx_entry_hdr {\n#if defined(__LITTLE_ENDIAN)\n\tu16\tcmd;\n\tu16\tsize;\n\tu16\tcount;\n\tu16\tdelay;\n#elif defined(__BIG_ENDIAN)\n\tu16\tsize;\n\tu16\tcmd;\n\tu16\tdelay;\n\tu16\tcount;\n#endif\n} __packed;\n\n \nstruct qlc_83xx_poll {\n\tu32\tmask;\n\tu32\tstatus;\n} __packed;\n\n \nstruct qlc_83xx_rmw {\n\tu32\tmask;\n\tu32\txor_value;\n\tu32\tor_value;\n#if defined(__LITTLE_ENDIAN)\n\tu8\tshl;\n\tu8\tshr;\n\tu8\tindex_a;\n\tu8\trsvd;\n#elif defined(__BIG_ENDIAN)\n\tu8\trsvd;\n\tu8\tindex_a;\n\tu8\tshr;\n\tu8\tshl;\n#endif\n} __packed;\n\n \nstruct qlc_83xx_entry {\n\tu32 arg1;\n\tu32 arg2;\n} __packed;\n\n \nstruct qlc_83xx_quad_entry {\n\tu32 dr_addr;\n\tu32 dr_value;\n\tu32 ar_addr;\n\tu32 ar_value;\n} __packed;\nstatic const char *const qlc_83xx_idc_states[] = {\n\t\"Unknown\",\n\t\"Cold\",\n\t\"Init\",\n\t\"Ready\",\n\t\"Need Reset\",\n\t\"Need Quiesce\",\n\t\"Failed\",\n\t\"Quiesce\"\n};\n\nstatic int\nqlcnic_83xx_idc_check_driver_presence_reg(struct qlcnic_adapter *adapter)\n{\n\tu32 val;\n\n\tval = QLCRDX(adapter->ahw, QLC_83XX_IDC_DRV_PRESENCE);\n\tif ((val & 0xFFFF))\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\nstatic void qlcnic_83xx_idc_log_state_history(struct qlcnic_adapter *adapter)\n{\n\tu32 cur, prev;\n\tcur = adapter->ahw->idc.curr_state;\n\tprev = adapter->ahw->idc.prev_state;\n\n\tdev_info(&adapter->pdev->dev,\n\t\t \"current state  = %s,  prev state = %s\\n\",\n\t\t adapter->ahw->idc.name[cur],\n\t\t adapter->ahw->idc.name[prev]);\n}\n\nstatic int qlcnic_83xx_idc_update_audit_reg(struct qlcnic_adapter *adapter,\n\t\t\t\t\t    u8 mode, int lock)\n{\n\tu32 val;\n\tint seconds;\n\n\tif (lock) {\n\t\tif (qlcnic_83xx_lock_driver(adapter))\n\t\t\treturn -EBUSY;\n\t}\n\n\tval = QLCRDX(adapter->ahw, QLC_83XX_IDC_DRV_AUDIT);\n\tval |= (adapter->portnum & 0xf);\n\tval |= mode << 7;\n\tif (mode)\n\t\tseconds = jiffies / HZ - adapter->ahw->idc.sec_counter;\n\telse\n\t\tseconds = jiffies / HZ;\n\n\tval |= seconds << 8;\n\tQLCWRX(adapter->ahw, QLC_83XX_IDC_DRV_AUDIT, val);\n\tadapter->ahw->idc.sec_counter = jiffies / HZ;\n\n\tif (lock)\n\t\tqlcnic_83xx_unlock_driver(adapter);\n\n\treturn 0;\n}\n\nstatic void qlcnic_83xx_idc_update_minor_version(struct qlcnic_adapter *adapter)\n{\n\tu32 val;\n\n\tval = QLCRDX(adapter->ahw, QLC_83XX_IDC_MIN_VERSION);\n\tval = val & ~(0x3 << (adapter->portnum * 2));\n\tval = val | (QLC_83XX_IDC_MINOR_VERSION << (adapter->portnum * 2));\n\tQLCWRX(adapter->ahw, QLC_83XX_IDC_MIN_VERSION, val);\n}\n\nstatic int qlcnic_83xx_idc_update_major_version(struct qlcnic_adapter *adapter,\n\t\t\t\t\t\tint lock)\n{\n\tu32 val;\n\n\tif (lock) {\n\t\tif (qlcnic_83xx_lock_driver(adapter))\n\t\t\treturn -EBUSY;\n\t}\n\n\tval = QLCRDX(adapter->ahw, QLC_83XX_IDC_MAJ_VERSION);\n\tval = val & ~0xFF;\n\tval = val | QLC_83XX_IDC_MAJOR_VERSION;\n\tQLCWRX(adapter->ahw, QLC_83XX_IDC_MAJ_VERSION, val);\n\n\tif (lock)\n\t\tqlcnic_83xx_unlock_driver(adapter);\n\n\treturn 0;\n}\n\nstatic int\nqlcnic_83xx_idc_update_drv_presence_reg(struct qlcnic_adapter *adapter,\n\t\t\t\t\tint status, int lock)\n{\n\tu32 val;\n\n\tif (lock) {\n\t\tif (qlcnic_83xx_lock_driver(adapter))\n\t\t\treturn -EBUSY;\n\t}\n\n\tval = QLCRDX(adapter->ahw, QLC_83XX_IDC_DRV_PRESENCE);\n\n\tif (status)\n\t\tval = val | (1 << adapter->portnum);\n\telse\n\t\tval = val & ~(1 << adapter->portnum);\n\n\tQLCWRX(adapter->ahw, QLC_83XX_IDC_DRV_PRESENCE, val);\n\tqlcnic_83xx_idc_update_minor_version(adapter);\n\n\tif (lock)\n\t\tqlcnic_83xx_unlock_driver(adapter);\n\n\treturn 0;\n}\n\nstatic int qlcnic_83xx_idc_check_major_version(struct qlcnic_adapter *adapter)\n{\n\tu32 val;\n\tu8 version;\n\n\tval = QLCRDX(adapter->ahw, QLC_83XX_IDC_MAJ_VERSION);\n\tversion = val & 0xFF;\n\n\tif (version != QLC_83XX_IDC_MAJOR_VERSION) {\n\t\tdev_info(&adapter->pdev->dev,\n\t\t\t \"%s:mismatch. version 0x%x, expected version 0x%x\\n\",\n\t\t\t __func__, version, QLC_83XX_IDC_MAJOR_VERSION);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int qlcnic_83xx_idc_clear_registers(struct qlcnic_adapter *adapter,\n\t\t\t\t\t   int lock)\n{\n\tu32 val;\n\n\tif (lock) {\n\t\tif (qlcnic_83xx_lock_driver(adapter))\n\t\t\treturn -EBUSY;\n\t}\n\n\tQLCWRX(adapter->ahw, QLC_83XX_IDC_DRV_ACK, 0);\n\t \n\tval = QLCRDX(adapter->ahw, QLC_83XX_IDC_CTRL);\n\tval &= ~QLC_83XX_IDC_GRACEFULL_RESET;\n\tQLCWRX(adapter->ahw, QLC_83XX_IDC_CTRL, val);\n\n\tif (lock)\n\t\tqlcnic_83xx_unlock_driver(adapter);\n\n\treturn 0;\n}\n\nstatic int qlcnic_83xx_idc_update_drv_ack_reg(struct qlcnic_adapter *adapter,\n\t\t\t\t\t      int flag, int lock)\n{\n\tu32 val;\n\n\tif (lock) {\n\t\tif (qlcnic_83xx_lock_driver(adapter))\n\t\t\treturn -EBUSY;\n\t}\n\n\tval = QLCRDX(adapter->ahw, QLC_83XX_IDC_DRV_ACK);\n\tif (flag)\n\t\tval = val | (1 << adapter->portnum);\n\telse\n\t\tval = val & ~(1 << adapter->portnum);\n\tQLCWRX(adapter->ahw, QLC_83XX_IDC_DRV_ACK, val);\n\n\tif (lock)\n\t\tqlcnic_83xx_unlock_driver(adapter);\n\n\treturn 0;\n}\n\nstatic int qlcnic_83xx_idc_check_timeout(struct qlcnic_adapter *adapter,\n\t\t\t\t\t int time_limit)\n{\n\tu64 seconds;\n\n\tseconds = jiffies / HZ - adapter->ahw->idc.sec_counter;\n\tif (seconds <= time_limit)\n\t\treturn 0;\n\telse\n\t\treturn -EBUSY;\n}\n\n \nstatic int qlcnic_83xx_idc_check_reset_ack_reg(struct qlcnic_adapter *adapter)\n{\n\tint timeout;\n\tu32 ack, presence, val;\n\n\ttimeout = QLC_83XX_IDC_RESET_TIMEOUT_SECS;\n\tack = QLCRDX(adapter->ahw, QLC_83XX_IDC_DRV_ACK);\n\tpresence = QLCRDX(adapter->ahw, QLC_83XX_IDC_DRV_PRESENCE);\n\tdev_info(&adapter->pdev->dev,\n\t\t \"%s: ack = 0x%x, presence = 0x%x\\n\", __func__, ack, presence);\n\tif (!((ack & presence) == presence)) {\n\t\tif (qlcnic_83xx_idc_check_timeout(adapter, timeout)) {\n\t\t\t \n\t\t\tdev_info(&adapter->pdev->dev,\n\t\t\t\t \"%s: ACK wait exceeds time limit\\n\", __func__);\n\t\t\tval = QLCRDX(adapter->ahw, QLC_83XX_IDC_DRV_PRESENCE);\n\t\t\tval = val & ~(ack ^ presence);\n\t\t\tif (qlcnic_83xx_lock_driver(adapter))\n\t\t\t\treturn -EBUSY;\n\t\t\tQLCWRX(adapter->ahw, QLC_83XX_IDC_DRV_PRESENCE, val);\n\t\t\tdev_info(&adapter->pdev->dev,\n\t\t\t\t \"%s: updated drv presence reg = 0x%x\\n\",\n\t\t\t\t __func__, val);\n\t\t\tqlcnic_83xx_unlock_driver(adapter);\n\t\t\treturn 0;\n\n\t\t} else {\n\t\t\treturn 1;\n\t\t}\n\t} else {\n\t\tdev_info(&adapter->pdev->dev,\n\t\t\t \"%s: Reset ACK received from all functions\\n\",\n\t\t\t __func__);\n\t\treturn 0;\n\t}\n}\n\n \nstatic int qlcnic_83xx_idc_tx_soft_reset(struct qlcnic_adapter *adapter)\n{\n\tstruct net_device *netdev = adapter->netdev;\n\n\tif (test_and_set_bit(__QLCNIC_RESETTING, &adapter->state))\n\t\treturn -EBUSY;\n\n\tnetif_device_detach(netdev);\n\tqlcnic_down(adapter, netdev);\n\tqlcnic_up(adapter, netdev);\n\tnetif_device_attach(netdev);\n\tclear_bit(__QLCNIC_RESETTING, &adapter->state);\n\tnetdev_info(adapter->netdev, \"%s: soft reset complete.\\n\", __func__);\n\n\treturn 0;\n}\n\n \nstatic void qlcnic_83xx_idc_detach_driver(struct qlcnic_adapter *adapter)\n{\n\tint i;\n\tstruct net_device *netdev = adapter->netdev;\n\n\tnetif_device_detach(netdev);\n\tqlcnic_83xx_detach_mailbox_work(adapter);\n\n\t \n\tqlcnic_83xx_disable_mbx_intr(adapter);\n\tqlcnic_down(adapter, netdev);\n\tfor (i = 0; i < adapter->ahw->num_msix; i++) {\n\t\tadapter->ahw->intr_tbl[i].id = i;\n\t\tadapter->ahw->intr_tbl[i].enabled = 0;\n\t\tadapter->ahw->intr_tbl[i].src = 0;\n\t}\n\n\tif (qlcnic_sriov_pf_check(adapter))\n\t\tqlcnic_sriov_pf_reset(adapter);\n}\n\n \nstatic void qlcnic_83xx_idc_attach_driver(struct qlcnic_adapter *adapter)\n{\n\tstruct net_device *netdev = adapter->netdev;\n\n\tif (netif_running(netdev)) {\n\t\tif (qlcnic_up(adapter, netdev))\n\t\t\tgoto done;\n\t\tqlcnic_restore_indev_addr(netdev, NETDEV_UP);\n\t}\ndone:\n\tnetif_device_attach(netdev);\n}\n\nstatic int qlcnic_83xx_idc_enter_failed_state(struct qlcnic_adapter *adapter,\n\t\t\t\t\t      int lock)\n{\n\tif (lock) {\n\t\tif (qlcnic_83xx_lock_driver(adapter))\n\t\t\treturn -EBUSY;\n\t}\n\n\tqlcnic_83xx_idc_clear_registers(adapter, 0);\n\tQLCWRX(adapter->ahw, QLC_83XX_IDC_DEV_STATE, QLC_83XX_IDC_DEV_FAILED);\n\tif (lock)\n\t\tqlcnic_83xx_unlock_driver(adapter);\n\n\tqlcnic_83xx_idc_log_state_history(adapter);\n\tdev_info(&adapter->pdev->dev, \"Device will enter failed state\\n\");\n\n\treturn 0;\n}\n\nstatic int qlcnic_83xx_idc_enter_init_state(struct qlcnic_adapter *adapter,\n\t\t\t\t\t    int lock)\n{\n\tif (lock) {\n\t\tif (qlcnic_83xx_lock_driver(adapter))\n\t\t\treturn -EBUSY;\n\t}\n\n\tQLCWRX(adapter->ahw, QLC_83XX_IDC_DEV_STATE, QLC_83XX_IDC_DEV_INIT);\n\n\tif (lock)\n\t\tqlcnic_83xx_unlock_driver(adapter);\n\n\treturn 0;\n}\n\nstatic int qlcnic_83xx_idc_enter_need_quiesce(struct qlcnic_adapter *adapter,\n\t\t\t\t\t      int lock)\n{\n\tif (lock) {\n\t\tif (qlcnic_83xx_lock_driver(adapter))\n\t\t\treturn -EBUSY;\n\t}\n\n\tQLCWRX(adapter->ahw, QLC_83XX_IDC_DEV_STATE,\n\t       QLC_83XX_IDC_DEV_NEED_QUISCENT);\n\n\tif (lock)\n\t\tqlcnic_83xx_unlock_driver(adapter);\n\n\treturn 0;\n}\n\nstatic int\nqlcnic_83xx_idc_enter_need_reset_state(struct qlcnic_adapter *adapter, int lock)\n{\n\tif (lock) {\n\t\tif (qlcnic_83xx_lock_driver(adapter))\n\t\t\treturn -EBUSY;\n\t}\n\n\tQLCWRX(adapter->ahw, QLC_83XX_IDC_DEV_STATE,\n\t       QLC_83XX_IDC_DEV_NEED_RESET);\n\n\tif (lock)\n\t\tqlcnic_83xx_unlock_driver(adapter);\n\n\treturn 0;\n}\n\nstatic int qlcnic_83xx_idc_enter_ready_state(struct qlcnic_adapter *adapter,\n\t\t\t\t\t     int lock)\n{\n\tif (lock) {\n\t\tif (qlcnic_83xx_lock_driver(adapter))\n\t\t\treturn -EBUSY;\n\t}\n\n\tQLCWRX(adapter->ahw, QLC_83XX_IDC_DEV_STATE, QLC_83XX_IDC_DEV_READY);\n\tif (lock)\n\t\tqlcnic_83xx_unlock_driver(adapter);\n\n\treturn 0;\n}\n\n \nstatic int qlcnic_83xx_idc_find_reset_owner_id(struct qlcnic_adapter *adapter)\n{\n\tu32 reg, reg1, reg2, i, j, owner, class;\n\n\treg1 = QLCRDX(adapter->ahw, QLC_83XX_IDC_DEV_PARTITION_INFO_1);\n\treg2 = QLCRDX(adapter->ahw, QLC_83XX_IDC_DEV_PARTITION_INFO_2);\n\towner = QLCNIC_TYPE_NIC;\n\ti = 0;\n\tj = 0;\n\treg = reg1;\n\n\tdo {\n\t\tclass = (((reg & (0xF << j * 4)) >> j * 4) & 0x3);\n\t\tif (class == owner)\n\t\t\tbreak;\n\t\tif (i == (QLC_83XX_IDC_MAX_FUNC_PER_PARTITION_INFO - 1)) {\n\t\t\treg = reg2;\n\t\t\tj = 0;\n\t\t} else {\n\t\t\tj++;\n\t\t}\n\n\t\tif (i == (QLC_83XX_IDC_MAX_CNA_FUNCTIONS - 1)) {\n\t\t\tif (owner == QLCNIC_TYPE_NIC)\n\t\t\t\towner = QLCNIC_TYPE_ISCSI;\n\t\t\telse if (owner == QLCNIC_TYPE_ISCSI)\n\t\t\t\towner = QLCNIC_TYPE_FCOE;\n\t\t\telse if (owner == QLCNIC_TYPE_FCOE)\n\t\t\t\treturn -EIO;\n\t\t\treg = reg1;\n\t\t\tj = 0;\n\t\t\ti = 0;\n\t\t}\n\t} while (i++ < QLC_83XX_IDC_MAX_CNA_FUNCTIONS);\n\n\treturn i;\n}\n\nstatic int qlcnic_83xx_idc_restart_hw(struct qlcnic_adapter *adapter, int lock)\n{\n\tint ret = 0;\n\n\tret = qlcnic_83xx_restart_hw(adapter);\n\n\tif (ret) {\n\t\tqlcnic_83xx_idc_enter_failed_state(adapter, lock);\n\t} else {\n\t\tqlcnic_83xx_idc_clear_registers(adapter, lock);\n\t\tret = qlcnic_83xx_idc_enter_ready_state(adapter, lock);\n\t}\n\n\treturn ret;\n}\n\nstatic int qlcnic_83xx_idc_check_fan_failure(struct qlcnic_adapter *adapter)\n{\n\tu32 status;\n\n\tstatus = QLC_SHARED_REG_RD32(adapter, QLCNIC_PEG_HALT_STATUS1);\n\n\tif (status & QLCNIC_RCODE_FATAL_ERROR) {\n\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\"peg halt status1=0x%x\\n\", status);\n\t\tif (QLCNIC_FWERROR_CODE(status) == QLCNIC_FWERROR_FAN_FAILURE) {\n\t\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\t\"On board active cooling fan failed. \"\n\t\t\t\t\"Device has been halted.\\n\");\n\t\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\t\"Replace the adapter.\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint qlcnic_83xx_idc_reattach_driver(struct qlcnic_adapter *adapter)\n{\n\tint err;\n\n\tqlcnic_83xx_reinit_mbx_work(adapter->ahw->mailbox);\n\tqlcnic_83xx_enable_mbx_interrupt(adapter);\n\n\tqlcnic_83xx_initialize_nic(adapter, 1);\n\n\terr = qlcnic_sriov_pf_reinit(adapter);\n\tif (err)\n\t\treturn err;\n\n\tqlcnic_83xx_enable_mbx_interrupt(adapter);\n\n\tif (qlcnic_83xx_configure_opmode(adapter)) {\n\t\tqlcnic_83xx_idc_enter_failed_state(adapter, 1);\n\t\treturn -EIO;\n\t}\n\n\tif (adapter->nic_ops->init_driver(adapter)) {\n\t\tqlcnic_83xx_idc_enter_failed_state(adapter, 1);\n\t\treturn -EIO;\n\t}\n\n\tif (adapter->portnum == 0)\n\t\tqlcnic_set_drv_version(adapter);\n\n\tqlcnic_dcb_get_info(adapter->dcb);\n\tqlcnic_83xx_idc_attach_driver(adapter);\n\n\treturn 0;\n}\n\nstatic void qlcnic_83xx_idc_update_idc_params(struct qlcnic_adapter *adapter)\n{\n\tstruct qlcnic_hardware_context *ahw = adapter->ahw;\n\n\tqlcnic_83xx_idc_update_drv_presence_reg(adapter, 1, 1);\n\tqlcnic_83xx_idc_update_audit_reg(adapter, 0, 1);\n\tset_bit(QLC_83XX_MODULE_LOADED, &adapter->ahw->idc.status);\n\n\tahw->idc.quiesce_req = 0;\n\tahw->idc.delay = QLC_83XX_IDC_FW_POLL_DELAY;\n\tahw->idc.err_code = 0;\n\tahw->idc.collect_dump = 0;\n\tahw->reset_context = 0;\n\tadapter->tx_timeo_cnt = 0;\n\tahw->idc.delay_reset = 0;\n\n\tclear_bit(__QLCNIC_RESETTING, &adapter->state);\n}\n\n \nint qlcnic_83xx_idc_ready_state_entry(struct qlcnic_adapter *adapter)\n{\n\tstruct qlcnic_hardware_context *ahw = adapter->ahw;\n\n\tif (ahw->idc.prev_state != QLC_83XX_IDC_DEV_READY) {\n\t\tqlcnic_83xx_idc_update_idc_params(adapter);\n\t\t \n\t\tif ((ahw->idc.prev_state == QLC_83XX_IDC_DEV_NEED_RESET) ||\n\t\t    (ahw->idc.prev_state == QLC_83XX_IDC_DEV_INIT)) {\n\t\t\tif (qlcnic_83xx_idc_reattach_driver(adapter))\n\t\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nint qlcnic_83xx_idc_vnic_pf_entry(struct qlcnic_adapter *adapter)\n{\n\tu32 state;\n\tstruct qlcnic_hardware_context *ahw = adapter->ahw;\n\n\t \n\tstate = QLCRDX(adapter->ahw, QLC_83XX_VNIC_STATE);\n\tif (state != QLCNIC_DEV_NPAR_OPER) {\n\t\tif (!ahw->idc.vnic_wait_limit--) {\n\t\t\tqlcnic_83xx_idc_enter_failed_state(adapter, 1);\n\t\t\treturn -EIO;\n\t\t}\n\t\tdev_info(&adapter->pdev->dev, \"vNIC mode disabled\\n\");\n\t\treturn -EIO;\n\n\t} else {\n\t\t \n\t\tif (ahw->idc.vnic_state != QLCNIC_DEV_NPAR_OPER) {\n\t\t\tqlcnic_83xx_idc_update_idc_params(adapter);\n\n\t\t\t \n\t\t\tif (ahw->idc.prev_state != QLC_83XX_IDC_DEV_UNKNOWN) {\n\t\t\t\tif (qlcnic_83xx_idc_reattach_driver(adapter))\n\t\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t\tadapter->ahw->idc.vnic_state =  QLCNIC_DEV_NPAR_OPER;\n\t\t\tdev_info(&adapter->pdev->dev, \"vNIC mode enabled\\n\");\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int qlcnic_83xx_idc_unknown_state(struct qlcnic_adapter *adapter)\n{\n\tadapter->ahw->idc.err_code = -EIO;\n\tdev_err(&adapter->pdev->dev,\n\t\t\"%s: Device in unknown state\\n\", __func__);\n\tclear_bit(__QLCNIC_RESETTING, &adapter->state);\n\treturn 0;\n}\n\n \nstatic int qlcnic_83xx_idc_cold_state_handler(struct qlcnic_adapter *adapter)\n{\n\tqlcnic_83xx_idc_update_drv_presence_reg(adapter, 1, 0);\n\tqlcnic_83xx_idc_update_audit_reg(adapter, 1, 0);\n\n\tif (qlcnic_load_fw_file) {\n\t\tqlcnic_83xx_idc_restart_hw(adapter, 0);\n\t} else {\n\t\tif (qlcnic_83xx_check_hw_status(adapter)) {\n\t\t\tqlcnic_83xx_idc_enter_failed_state(adapter, 0);\n\t\t\treturn -EIO;\n\t\t} else {\n\t\t\tqlcnic_83xx_idc_enter_ready_state(adapter, 0);\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nstatic int qlcnic_83xx_idc_init_state(struct qlcnic_adapter *adapter)\n{\n\tint timeout, ret = 0;\n\tu32 owner;\n\n\ttimeout = QLC_83XX_IDC_INIT_TIMEOUT_SECS;\n\tif (adapter->ahw->idc.prev_state == QLC_83XX_IDC_DEV_NEED_RESET) {\n\t\towner = qlcnic_83xx_idc_find_reset_owner_id(adapter);\n\t\tif (adapter->ahw->pci_func == owner)\n\t\t\tret = qlcnic_83xx_idc_restart_hw(adapter, 1);\n\t} else {\n\t\tret = qlcnic_83xx_idc_check_timeout(adapter, timeout);\n\t}\n\n\treturn ret;\n}\n\n \nstatic int qlcnic_83xx_idc_ready_state(struct qlcnic_adapter *adapter)\n{\n\tstruct qlcnic_hardware_context *ahw = adapter->ahw;\n\tstruct qlcnic_mailbox *mbx = ahw->mailbox;\n\tint ret = 0;\n\tu32 val;\n\n\t \n\tif (ahw->idc.state_entry(adapter))\n\t\treturn -EIO;\n\n\tif (qlcnic_check_temp(adapter)) {\n\t\tif (ahw->temp == QLCNIC_TEMP_PANIC) {\n\t\t\tqlcnic_83xx_idc_check_fan_failure(adapter);\n\t\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\t\"Error: device temperature %d above limits\\n\",\n\t\t\t\tadapter->ahw->temp);\n\t\t\tclear_bit(QLC_83XX_MBX_READY, &mbx->status);\n\t\t\tset_bit(__QLCNIC_RESETTING, &adapter->state);\n\t\t\tqlcnic_83xx_idc_detach_driver(adapter);\n\t\t\tqlcnic_83xx_idc_enter_failed_state(adapter, 1);\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\tval = QLCRDX(adapter->ahw, QLC_83XX_IDC_CTRL);\n\tret = qlcnic_83xx_check_heartbeat(adapter);\n\tif (ret) {\n\t\tadapter->flags |= QLCNIC_FW_HANG;\n\t\tif (!(val & QLC_83XX_IDC_DISABLE_FW_RESET_RECOVERY)) {\n\t\t\tclear_bit(QLC_83XX_MBX_READY, &mbx->status);\n\t\t\tset_bit(__QLCNIC_RESETTING, &adapter->state);\n\t\t\tqlcnic_83xx_idc_enter_need_reset_state(adapter, 1);\n\t\t}  else {\n\t\t\tnetdev_info(adapter->netdev, \"%s: Auto firmware recovery is disabled\\n\",\n\t\t\t\t    __func__);\n\t\t\tqlcnic_83xx_idc_enter_failed_state(adapter, 1);\n\t\t}\n\t\treturn -EIO;\n\t}\n\n\tif ((val & QLC_83XX_IDC_GRACEFULL_RESET) || ahw->idc.collect_dump) {\n\t\tclear_bit(QLC_83XX_MBX_READY, &mbx->status);\n\n\t\t \n\t\tqlcnic_83xx_idc_enter_need_reset_state(adapter, 1);\n\t\treturn ret;\n\t}\n\n\t \n\tif (ahw->reset_context &&\n\t    !(val & QLC_83XX_IDC_DISABLE_FW_RESET_RECOVERY)) {\n\t\tadapter->ahw->reset_context = 0;\n\t\tqlcnic_83xx_idc_tx_soft_reset(adapter);\n\t\treturn ret;\n\t}\n\n\t \n\tif (adapter->ahw->idc.quiesce_req) {\n\t\tqlcnic_83xx_idc_enter_need_quiesce(adapter, 1);\n\t\tqlcnic_83xx_idc_update_audit_reg(adapter, 0, 1);\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\n \nstatic int qlcnic_83xx_idc_need_reset_state(struct qlcnic_adapter *adapter)\n{\n\tstruct qlcnic_mailbox *mbx = adapter->ahw->mailbox;\n\tint ret = 0;\n\n\tif (adapter->ahw->idc.prev_state != QLC_83XX_IDC_DEV_NEED_RESET) {\n\t\tqlcnic_83xx_idc_update_audit_reg(adapter, 0, 1);\n\t\tset_bit(__QLCNIC_RESETTING, &adapter->state);\n\t\tclear_bit(QLC_83XX_MBX_READY, &mbx->status);\n\t\tif (adapter->ahw->nic_mode == QLCNIC_VNIC_MODE)\n\t\t\tqlcnic_83xx_disable_vnic_mode(adapter, 1);\n\n\t\tif (qlcnic_check_diag_status(adapter)) {\n\t\t\tdev_info(&adapter->pdev->dev,\n\t\t\t\t \"%s: Wait for diag completion\\n\", __func__);\n\t\t\tadapter->ahw->idc.delay_reset = 1;\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tqlcnic_83xx_idc_update_drv_ack_reg(adapter, 1, 1);\n\t\t\tqlcnic_83xx_idc_detach_driver(adapter);\n\t\t}\n\t}\n\n\tif (qlcnic_check_diag_status(adapter)) {\n\t\tdev_info(&adapter->pdev->dev,\n\t\t\t \"%s: Wait for diag completion\\n\", __func__);\n\t\treturn  -1;\n\t} else {\n\t\tif (adapter->ahw->idc.delay_reset) {\n\t\t\tqlcnic_83xx_idc_update_drv_ack_reg(adapter, 1, 1);\n\t\t\tqlcnic_83xx_idc_detach_driver(adapter);\n\t\t\tadapter->ahw->idc.delay_reset = 0;\n\t\t}\n\n\t\t \n\t\tret = qlcnic_83xx_idc_check_reset_ack_reg(adapter);\n\t\tif (ret) {\n\t\t\tdev_info(&adapter->pdev->dev,\n\t\t\t\t \"%s: Waiting for reset ACK\\n\", __func__);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t \n\tqlcnic_83xx_idc_enter_init_state(adapter, 1);\n\n\treturn ret;\n}\n\nstatic int qlcnic_83xx_idc_need_quiesce_state(struct qlcnic_adapter *adapter)\n{\n\tdev_err(&adapter->pdev->dev, \"%s: TBD\\n\", __func__);\n\treturn 0;\n}\n\nstatic void qlcnic_83xx_idc_failed_state(struct qlcnic_adapter *adapter)\n{\n\tstruct qlcnic_hardware_context *ahw = adapter->ahw;\n\tu32 val, owner;\n\n\tval = QLCRDX(adapter->ahw, QLC_83XX_IDC_CTRL);\n\tif (val & QLC_83XX_IDC_DISABLE_FW_RESET_RECOVERY) {\n\t\towner = qlcnic_83xx_idc_find_reset_owner_id(adapter);\n\t\tif (ahw->pci_func == owner) {\n\t\t\tqlcnic_83xx_stop_hw(adapter);\n\t\t\tqlcnic_dump_fw(adapter);\n\t\t}\n\t}\n\n\tnetdev_warn(adapter->netdev, \"%s: Reboot will be required to recover the adapter!!\\n\",\n\t\t    __func__);\n\tclear_bit(__QLCNIC_RESETTING, &adapter->state);\n\tahw->idc.err_code = -EIO;\n\n\treturn;\n}\n\nstatic int qlcnic_83xx_idc_quiesce_state(struct qlcnic_adapter *adapter)\n{\n\tdev_info(&adapter->pdev->dev, \"%s: TBD\\n\", __func__);\n\treturn 0;\n}\n\nstatic int qlcnic_83xx_idc_check_state_validity(struct qlcnic_adapter *adapter,\n\t\t\t\t\t\tu32 state)\n{\n\tu32 cur, prev, next;\n\n\tcur = adapter->ahw->idc.curr_state;\n\tprev = adapter->ahw->idc.prev_state;\n\tnext = state;\n\n\tif ((next < QLC_83XX_IDC_DEV_COLD) ||\n\t    (next > QLC_83XX_IDC_DEV_QUISCENT)) {\n\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\"%s: curr %d, prev %d, next state %d is  invalid\\n\",\n\t\t\t__func__, cur, prev, state);\n\t\treturn 1;\n\t}\n\n\tif ((cur == QLC_83XX_IDC_DEV_UNKNOWN) &&\n\t    (prev == QLC_83XX_IDC_DEV_UNKNOWN)) {\n\t\tif ((next != QLC_83XX_IDC_DEV_COLD) &&\n\t\t    (next != QLC_83XX_IDC_DEV_READY)) {\n\t\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\t\"%s: failed, cur %d prev %d next %d\\n\",\n\t\t\t\t__func__, cur, prev, next);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tif (next == QLC_83XX_IDC_DEV_INIT) {\n\t\tif ((prev != QLC_83XX_IDC_DEV_INIT) &&\n\t\t    (prev != QLC_83XX_IDC_DEV_COLD) &&\n\t\t    (prev != QLC_83XX_IDC_DEV_NEED_RESET)) {\n\t\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\t\"%s: failed, cur %d prev %d next %d\\n\",\n\t\t\t\t__func__, cur, prev, next);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n#define QLC_83XX_ENCAP_TYPE_VXLAN\tBIT_1\n#define QLC_83XX_MATCH_ENCAP_ID\t\tBIT_2\n#define QLC_83XX_SET_VXLAN_UDP_DPORT\tBIT_3\n#define QLC_83XX_VXLAN_UDP_DPORT(PORT)\t((PORT & 0xffff) << 16)\n\n#define QLCNIC_ENABLE_INGRESS_ENCAP_PARSING 1\n#define QLCNIC_DISABLE_INGRESS_ENCAP_PARSING 0\n\nint qlcnic_set_vxlan_port(struct qlcnic_adapter *adapter, u16 port)\n{\n\tstruct qlcnic_cmd_args cmd;\n\tint ret = 0;\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\n\tret = qlcnic_alloc_mbx_args(&cmd, adapter,\n\t\t\t\t    QLCNIC_CMD_INIT_NIC_FUNC);\n\tif (ret)\n\t\treturn ret;\n\n\tcmd.req.arg[1] = QLC_83XX_MULTI_TENANCY_INFO;\n\tcmd.req.arg[2] = QLC_83XX_ENCAP_TYPE_VXLAN |\n\t\t\t QLC_83XX_SET_VXLAN_UDP_DPORT |\n\t\t\t QLC_83XX_VXLAN_UDP_DPORT(port);\n\n\tret = qlcnic_issue_cmd(adapter, &cmd);\n\tif (ret)\n\t\tnetdev_err(adapter->netdev,\n\t\t\t   \"Failed to set VXLAN port %d in adapter\\n\",\n\t\t\t   port);\n\n\tqlcnic_free_mbx_args(&cmd);\n\n\treturn ret;\n}\n\nint qlcnic_set_vxlan_parsing(struct qlcnic_adapter *adapter, u16 port)\n{\n\tstruct qlcnic_cmd_args cmd;\n\tint ret = 0;\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\n\tret = qlcnic_alloc_mbx_args(&cmd, adapter,\n\t\t\t\t    QLCNIC_CMD_SET_INGRESS_ENCAP);\n\tif (ret)\n\t\treturn ret;\n\n\tcmd.req.arg[1] = port ? QLCNIC_ENABLE_INGRESS_ENCAP_PARSING :\n\t\t\t\tQLCNIC_DISABLE_INGRESS_ENCAP_PARSING;\n\n\tret = qlcnic_issue_cmd(adapter, &cmd);\n\tif (ret)\n\t\tnetdev_err(adapter->netdev,\n\t\t\t   \"Failed to %s VXLAN parsing for port %d\\n\",\n\t\t\t   port ? \"enable\" : \"disable\", port);\n\telse\n\t\tnetdev_info(adapter->netdev,\n\t\t\t    \"%s VXLAN parsing for port %d\\n\",\n\t\t\t    port ? \"Enabled\" : \"Disabled\", port);\n\n\tqlcnic_free_mbx_args(&cmd);\n\n\treturn ret;\n}\n\nstatic void qlcnic_83xx_periodic_tasks(struct qlcnic_adapter *adapter)\n{\n\tif (adapter->fhash.fnum)\n\t\tqlcnic_prune_lb_filters(adapter);\n}\n\n \nvoid qlcnic_83xx_idc_poll_dev_state(struct work_struct *work)\n{\n\tstruct qlcnic_adapter *adapter;\n\tu32 state;\n\n\tadapter = container_of(work, struct qlcnic_adapter, fw_work.work);\n\tstate =\tQLCRDX(adapter->ahw, QLC_83XX_IDC_DEV_STATE);\n\n\tif (qlcnic_83xx_idc_check_state_validity(adapter, state)) {\n\t\tqlcnic_83xx_idc_log_state_history(adapter);\n\t\tadapter->ahw->idc.curr_state = QLC_83XX_IDC_DEV_UNKNOWN;\n\t} else {\n\t\tadapter->ahw->idc.curr_state = state;\n\t}\n\n\tswitch (adapter->ahw->idc.curr_state) {\n\tcase QLC_83XX_IDC_DEV_READY:\n\t\tqlcnic_83xx_idc_ready_state(adapter);\n\t\tbreak;\n\tcase QLC_83XX_IDC_DEV_NEED_RESET:\n\t\tqlcnic_83xx_idc_need_reset_state(adapter);\n\t\tbreak;\n\tcase QLC_83XX_IDC_DEV_NEED_QUISCENT:\n\t\tqlcnic_83xx_idc_need_quiesce_state(adapter);\n\t\tbreak;\n\tcase QLC_83XX_IDC_DEV_FAILED:\n\t\tqlcnic_83xx_idc_failed_state(adapter);\n\t\treturn;\n\tcase QLC_83XX_IDC_DEV_INIT:\n\t\tqlcnic_83xx_idc_init_state(adapter);\n\t\tbreak;\n\tcase QLC_83XX_IDC_DEV_QUISCENT:\n\t\tqlcnic_83xx_idc_quiesce_state(adapter);\n\t\tbreak;\n\tdefault:\n\t\tqlcnic_83xx_idc_unknown_state(adapter);\n\t\treturn;\n\t}\n\tadapter->ahw->idc.prev_state = adapter->ahw->idc.curr_state;\n\tqlcnic_83xx_periodic_tasks(adapter);\n\n\t \n\tif (test_bit(QLC_83XX_MODULE_LOADED, &adapter->ahw->idc.status))\n\t\tqlcnic_schedule_work(adapter, qlcnic_83xx_idc_poll_dev_state,\n\t\t\t\t     adapter->ahw->idc.delay);\n}\n\nstatic void qlcnic_83xx_setup_idc_parameters(struct qlcnic_adapter *adapter)\n{\n\tu32 idc_params, val;\n\n\tif (qlcnic_83xx_flash_read32(adapter, QLC_83XX_IDC_FLASH_PARAM_ADDR,\n\t\t\t\t     (u8 *)&idc_params, 1)) {\n\t\tdev_info(&adapter->pdev->dev,\n\t\t\t \"%s:failed to get IDC params from flash\\n\", __func__);\n\t\tadapter->dev_init_timeo = QLC_83XX_IDC_INIT_TIMEOUT_SECS;\n\t\tadapter->reset_ack_timeo = QLC_83XX_IDC_RESET_TIMEOUT_SECS;\n\t} else {\n\t\tadapter->dev_init_timeo = idc_params & 0xFFFF;\n\t\tadapter->reset_ack_timeo = ((idc_params >> 16) & 0xFFFF);\n\t}\n\n\tadapter->ahw->idc.curr_state = QLC_83XX_IDC_DEV_UNKNOWN;\n\tadapter->ahw->idc.prev_state = QLC_83XX_IDC_DEV_UNKNOWN;\n\tadapter->ahw->idc.delay = QLC_83XX_IDC_FW_POLL_DELAY;\n\tadapter->ahw->idc.err_code = 0;\n\tadapter->ahw->idc.collect_dump = 0;\n\tadapter->ahw->idc.name = (char **)qlc_83xx_idc_states;\n\n\tclear_bit(__QLCNIC_RESETTING, &adapter->state);\n\tset_bit(QLC_83XX_MODULE_LOADED, &adapter->ahw->idc.status);\n\n\t \n\tif (!qlcnic_auto_fw_reset) {\n\t\t \n\t\tval = QLCRDX(adapter->ahw, QLC_83XX_IDC_CTRL);\n\t\tval = val | QLC_83XX_IDC_DISABLE_FW_RESET_RECOVERY;\n\t\tQLCWRX(adapter->ahw, QLC_83XX_IDC_CTRL, val);\n\t}\n}\n\nstatic int\nqlcnic_83xx_idc_first_to_load_function_handler(struct qlcnic_adapter *adapter)\n{\n\tu32 state, val;\n\n\tif (qlcnic_83xx_lock_driver(adapter))\n\t\treturn -EIO;\n\n\t \n\tQLCWRX(adapter->ahw, QLC_83XX_RECOVER_DRV_LOCK, 0);\n\tif (qlcnic_83xx_idc_update_major_version(adapter, 0)) {\n\t\tqlcnic_83xx_unlock_driver(adapter);\n\t\treturn -EIO;\n\t}\n\n\tstate =\tQLCRDX(adapter->ahw, QLC_83XX_IDC_DEV_STATE);\n\tif (qlcnic_83xx_idc_check_state_validity(adapter, state)) {\n\t\tqlcnic_83xx_unlock_driver(adapter);\n\t\treturn -EIO;\n\t}\n\n\tif (state != QLC_83XX_IDC_DEV_COLD && qlcnic_load_fw_file) {\n\t\tQLCWRX(adapter->ahw, QLC_83XX_IDC_DEV_STATE,\n\t\t       QLC_83XX_IDC_DEV_COLD);\n\t\tstate = QLC_83XX_IDC_DEV_COLD;\n\t}\n\n\tadapter->ahw->idc.curr_state = state;\n\t \n\tif (state == QLC_83XX_IDC_DEV_COLD)\n\t\tqlcnic_83xx_idc_cold_state_handler(adapter);\n\n\t \n\tif (qlcnic_auto_fw_reset) {\n\t\tval = QLCRDX(adapter->ahw, QLC_83XX_IDC_CTRL);\n\t\tval = val & ~QLC_83XX_IDC_DISABLE_FW_RESET_RECOVERY;\n\t\tQLCWRX(adapter->ahw, QLC_83XX_IDC_CTRL, val);\n\t}\n\n\tqlcnic_83xx_unlock_driver(adapter);\n\n\treturn 0;\n}\n\nint qlcnic_83xx_idc_init(struct qlcnic_adapter *adapter)\n{\n\tint ret = -EIO;\n\n\tqlcnic_83xx_setup_idc_parameters(adapter);\n\n\tif (qlcnic_83xx_get_reset_instruction_template(adapter))\n\t\treturn ret;\n\n\tif (!qlcnic_83xx_idc_check_driver_presence_reg(adapter)) {\n\t\tif (qlcnic_83xx_idc_first_to_load_function_handler(adapter))\n\t\t\treturn -EIO;\n\t} else {\n\t\tif (qlcnic_83xx_idc_check_major_version(adapter))\n\t\t\treturn -EIO;\n\t}\n\n\tqlcnic_83xx_idc_update_audit_reg(adapter, 0, 1);\n\n\treturn 0;\n}\n\nvoid qlcnic_83xx_idc_exit(struct qlcnic_adapter *adapter)\n{\n\tint id;\n\tu32 val;\n\n\twhile (test_and_set_bit(__QLCNIC_RESETTING, &adapter->state))\n\t\tusleep_range(10000, 11000);\n\n\tid = QLCRDX(adapter->ahw, QLC_83XX_DRV_LOCK_ID);\n\tid = id & 0xFF;\n\n\tif (id == adapter->portnum) {\n\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\"%s: wait for lock recovery.. %d\\n\", __func__, id);\n\t\tmsleep(20);\n\t\tid = QLCRDX(adapter->ahw, QLC_83XX_DRV_LOCK_ID);\n\t\tid = id & 0xFF;\n\t}\n\n\t \n\tval = QLCRDX(adapter->ahw, QLC_83XX_IDC_DRV_PRESENCE);\n\tval = val & ~(1 << adapter->portnum);\n\tQLCWRX(adapter->ahw, QLC_83XX_IDC_DRV_PRESENCE, val);\n\tclear_bit(QLC_83XX_MODULE_LOADED, &adapter->ahw->idc.status);\n\tclear_bit(__QLCNIC_RESETTING, &adapter->state);\n\n\tcancel_delayed_work_sync(&adapter->fw_work);\n}\n\nvoid qlcnic_83xx_idc_request_reset(struct qlcnic_adapter *adapter, u32 key)\n{\n\tu32 val;\n\n\tif (qlcnic_sriov_vf_check(adapter))\n\t\treturn;\n\n\tif (qlcnic_83xx_lock_driver(adapter)) {\n\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\"%s:failed, please retry\\n\", __func__);\n\t\treturn;\n\t}\n\n\tval = QLCRDX(adapter->ahw, QLC_83XX_IDC_CTRL);\n\tif (val & QLC_83XX_IDC_DISABLE_FW_RESET_RECOVERY) {\n\t\tnetdev_info(adapter->netdev, \"%s: Auto firmware recovery is disabled\\n\",\n\t\t\t    __func__);\n\t\tqlcnic_83xx_idc_enter_failed_state(adapter, 0);\n\t\tqlcnic_83xx_unlock_driver(adapter);\n\t\treturn;\n\t}\n\n\tif (key == QLCNIC_FORCE_FW_RESET) {\n\t\tval = QLCRDX(adapter->ahw, QLC_83XX_IDC_CTRL);\n\t\tval = val | QLC_83XX_IDC_GRACEFULL_RESET;\n\t\tQLCWRX(adapter->ahw, QLC_83XX_IDC_CTRL, val);\n\t} else if (key == QLCNIC_FORCE_FW_DUMP_KEY) {\n\t\tadapter->ahw->idc.collect_dump = 1;\n\t}\n\n\tqlcnic_83xx_unlock_driver(adapter);\n\treturn;\n}\n\nstatic int qlcnic_83xx_copy_bootloader(struct qlcnic_adapter *adapter)\n{\n\tu8 *p_cache;\n\tu32 src, size;\n\tu64 dest;\n\tint ret = -EIO;\n\n\tsrc = QLC_83XX_BOOTLOADER_FLASH_ADDR;\n\tdest = QLCRDX(adapter->ahw, QLCNIC_BOOTLOADER_ADDR);\n\tsize = QLCRDX(adapter->ahw, QLCNIC_BOOTLOADER_SIZE);\n\n\t \n\tif (size & 0xF)\n\t\tsize = (size + 16) & ~0xF;\n\n\tp_cache = vzalloc(size);\n\tif (p_cache == NULL)\n\t\treturn -ENOMEM;\n\n\tret = qlcnic_83xx_lockless_flash_read32(adapter, src, p_cache,\n\t\t\t\t\t\tsize / sizeof(u32));\n\tif (ret) {\n\t\tvfree(p_cache);\n\t\treturn ret;\n\t}\n\t \n\tret = qlcnic_ms_mem_write128(adapter, dest, (u32 *)p_cache,\n\t\t\t\t     size / 16);\n\tif (ret) {\n\t\tvfree(p_cache);\n\t\treturn ret;\n\t}\n\tvfree(p_cache);\n\n\treturn ret;\n}\n\nstatic int qlcnic_83xx_copy_fw_file(struct qlcnic_adapter *adapter)\n{\n\tstruct qlc_83xx_fw_info *fw_info = adapter->ahw->fw_info;\n\tconst struct firmware *fw = fw_info->fw;\n\tu32 dest, *p_cache, *temp;\n\t__le32 *temp_le;\n\tu8 data[16];\n\tsize_t size;\n\tint i, ret;\n\tu64 addr;\n\n\ttemp = vzalloc(fw->size);\n\tif (!temp) {\n\t\trelease_firmware(fw);\n\t\tfw_info->fw = NULL;\n\t\treturn -ENOMEM;\n\t}\n\n\ttemp_le = (__le32 *)fw->data;\n\n\t \n\tfor (i = 0; i < fw->size / sizeof(u32); i++)\n\t\ttemp[i] = __le32_to_cpu(temp_le[i]);\n\n\tdest = QLCRDX(adapter->ahw, QLCNIC_FW_IMAGE_ADDR);\n\tsize = (fw->size & ~0xF);\n\tp_cache = temp;\n\taddr = (u64)dest;\n\n\tret = qlcnic_ms_mem_write128(adapter, addr,\n\t\t\t\t     p_cache, size / 16);\n\tif (ret) {\n\t\tdev_err(&adapter->pdev->dev, \"MS memory write failed\\n\");\n\t\tgoto exit;\n\t}\n\n\t \n\tif (fw->size & 0xF) {\n\t\taddr = dest + size;\n\t\tfor (i = 0; i < (fw->size & 0xF); i++)\n\t\t\tdata[i] = ((u8 *)temp)[size + i];\n\t\tfor (; i < 16; i++)\n\t\t\tdata[i] = 0;\n\t\tret = qlcnic_ms_mem_write128(adapter, addr,\n\t\t\t\t\t     (u32 *)data, 1);\n\t\tif (ret) {\n\t\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\t\"MS memory write failed\\n\");\n\t\t\tgoto exit;\n\t\t}\n\t}\n\nexit:\n\trelease_firmware(fw);\n\tfw_info->fw = NULL;\n\tvfree(temp);\n\n\treturn ret;\n}\n\nstatic void qlcnic_83xx_dump_pause_control_regs(struct qlcnic_adapter *adapter)\n{\n\tint i, j;\n\tu32 val = 0, val1 = 0, reg = 0;\n\tint err = 0;\n\n\tval = QLCRD32(adapter, QLC_83XX_SRE_SHIM_REG, &err);\n\tif (err == -EIO)\n\t\treturn;\n\tdev_info(&adapter->pdev->dev, \"SRE-Shim Ctrl:0x%x\\n\", val);\n\n\tfor (j = 0; j < 2; j++) {\n\t\tif (j == 0) {\n\t\t\tdev_info(&adapter->pdev->dev,\n\t\t\t\t \"Port 0 RxB Pause Threshold Regs[TC7..TC0]:\");\n\t\t\treg = QLC_83XX_PORT0_THRESHOLD;\n\t\t} else if (j == 1) {\n\t\t\tdev_info(&adapter->pdev->dev,\n\t\t\t\t \"Port 1 RxB Pause Threshold Regs[TC7..TC0]:\");\n\t\t\treg = QLC_83XX_PORT1_THRESHOLD;\n\t\t}\n\t\tfor (i = 0; i < 8; i++) {\n\t\t\tval = QLCRD32(adapter, reg + (i * 0x4), &err);\n\t\t\tif (err == -EIO)\n\t\t\t\treturn;\n\t\t\tdev_info(&adapter->pdev->dev, \"0x%x  \", val);\n\t\t}\n\t\tdev_info(&adapter->pdev->dev, \"\\n\");\n\t}\n\n\tfor (j = 0; j < 2; j++) {\n\t\tif (j == 0) {\n\t\t\tdev_info(&adapter->pdev->dev,\n\t\t\t\t \"Port 0 RxB TC Max Cell Registers[4..1]:\");\n\t\t\treg = QLC_83XX_PORT0_TC_MC_REG;\n\t\t} else if (j == 1) {\n\t\t\tdev_info(&adapter->pdev->dev,\n\t\t\t\t \"Port 1 RxB TC Max Cell Registers[4..1]:\");\n\t\t\treg = QLC_83XX_PORT1_TC_MC_REG;\n\t\t}\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tval = QLCRD32(adapter, reg + (i * 0x4), &err);\n\t\t\tif (err == -EIO)\n\t\t\t\treturn;\n\t\t\tdev_info(&adapter->pdev->dev, \"0x%x  \", val);\n\t\t}\n\t\tdev_info(&adapter->pdev->dev, \"\\n\");\n\t}\n\n\tfor (j = 0; j < 2; j++) {\n\t\tif (j == 0) {\n\t\t\tdev_info(&adapter->pdev->dev,\n\t\t\t\t \"Port 0 RxB Rx TC Stats[TC7..TC0]:\");\n\t\t\treg = QLC_83XX_PORT0_TC_STATS;\n\t\t} else if (j == 1) {\n\t\t\tdev_info(&adapter->pdev->dev,\n\t\t\t\t \"Port 1 RxB Rx TC Stats[TC7..TC0]:\");\n\t\t\treg = QLC_83XX_PORT1_TC_STATS;\n\t\t}\n\t\tfor (i = 7; i >= 0; i--) {\n\t\t\tval = QLCRD32(adapter, reg, &err);\n\t\t\tif (err == -EIO)\n\t\t\t\treturn;\n\t\t\tval &= ~(0x7 << 29);     \n\t\t\tQLCWR32(adapter, reg, (val | (i << 29)));\n\t\t\tval = QLCRD32(adapter, reg, &err);\n\t\t\tif (err == -EIO)\n\t\t\t\treturn;\n\t\t\tdev_info(&adapter->pdev->dev, \"0x%x  \", val);\n\t\t}\n\t\tdev_info(&adapter->pdev->dev, \"\\n\");\n\t}\n\n\tval = QLCRD32(adapter, QLC_83XX_PORT2_IFB_THRESHOLD, &err);\n\tif (err == -EIO)\n\t\treturn;\n\tval1 = QLCRD32(adapter, QLC_83XX_PORT3_IFB_THRESHOLD, &err);\n\tif (err == -EIO)\n\t\treturn;\n\tdev_info(&adapter->pdev->dev,\n\t\t \"IFB-Pause Thresholds: Port 2:0x%x, Port 3:0x%x\\n\",\n\t\t val, val1);\n}\n\n\nstatic void qlcnic_83xx_disable_pause_frames(struct qlcnic_adapter *adapter)\n{\n\tu32 reg = 0, i, j;\n\n\tif (qlcnic_83xx_lock_driver(adapter)) {\n\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\"%s:failed to acquire driver lock\\n\", __func__);\n\t\treturn;\n\t}\n\n\tqlcnic_83xx_dump_pause_control_regs(adapter);\n\tQLCWR32(adapter, QLC_83XX_SRE_SHIM_REG, 0x0);\n\n\tfor (j = 0; j < 2; j++) {\n\t\tif (j == 0)\n\t\t\treg = QLC_83XX_PORT0_THRESHOLD;\n\t\telse if (j == 1)\n\t\t\treg = QLC_83XX_PORT1_THRESHOLD;\n\n\t\tfor (i = 0; i < 8; i++)\n\t\t\tQLCWR32(adapter, reg + (i * 0x4), 0x0);\n\t}\n\n\tfor (j = 0; j < 2; j++) {\n\t\tif (j == 0)\n\t\t\treg = QLC_83XX_PORT0_TC_MC_REG;\n\t\telse if (j == 1)\n\t\t\treg = QLC_83XX_PORT1_TC_MC_REG;\n\n\t\tfor (i = 0; i < 4; i++)\n\t\t\tQLCWR32(adapter, reg + (i * 0x4), 0x03FF03FF);\n\t}\n\n\tQLCWR32(adapter, QLC_83XX_PORT2_IFB_THRESHOLD, 0);\n\tQLCWR32(adapter, QLC_83XX_PORT3_IFB_THRESHOLD, 0);\n\tdev_info(&adapter->pdev->dev,\n\t\t \"Disabled pause frames successfully on all ports\\n\");\n\tqlcnic_83xx_unlock_driver(adapter);\n}\n\nstatic void qlcnic_83xx_take_eport_out_of_reset(struct qlcnic_adapter *adapter)\n{\n\tQLCWR32(adapter, QLC_83XX_RESET_REG, 0);\n\tQLCWR32(adapter, QLC_83XX_RESET_PORT0, 0);\n\tQLCWR32(adapter, QLC_83XX_RESET_PORT1, 0);\n\tQLCWR32(adapter, QLC_83XX_RESET_PORT2, 0);\n\tQLCWR32(adapter, QLC_83XX_RESET_PORT3, 0);\n\tQLCWR32(adapter, QLC_83XX_RESET_SRESHIM, 0);\n\tQLCWR32(adapter, QLC_83XX_RESET_EPGSHIM, 0);\n\tQLCWR32(adapter, QLC_83XX_RESET_ETHERPCS, 0);\n\tQLCWR32(adapter, QLC_83XX_RESET_CONTROL, 1);\n}\n\nstatic int qlcnic_83xx_check_heartbeat(struct qlcnic_adapter *p_dev)\n{\n\tu32 heartbeat, peg_status;\n\tint retries, ret = -EIO, err = 0;\n\n\tretries = QLCNIC_HEARTBEAT_CHECK_RETRY_COUNT;\n\tp_dev->heartbeat = QLC_SHARED_REG_RD32(p_dev,\n\t\t\t\t\t       QLCNIC_PEG_ALIVE_COUNTER);\n\n\tdo {\n\t\tmsleep(QLCNIC_HEARTBEAT_PERIOD_MSECS);\n\t\theartbeat = QLC_SHARED_REG_RD32(p_dev,\n\t\t\t\t\t\tQLCNIC_PEG_ALIVE_COUNTER);\n\t\tif (heartbeat != p_dev->heartbeat) {\n\t\t\tret = QLCNIC_RCODE_SUCCESS;\n\t\t\tbreak;\n\t\t}\n\t} while (--retries);\n\n\tif (ret) {\n\t\tdev_err(&p_dev->pdev->dev, \"firmware hang detected\\n\");\n\t\tqlcnic_83xx_take_eport_out_of_reset(p_dev);\n\t\tqlcnic_83xx_disable_pause_frames(p_dev);\n\t\tpeg_status = QLC_SHARED_REG_RD32(p_dev,\n\t\t\t\t\t\t QLCNIC_PEG_HALT_STATUS1);\n\t\tdev_info(&p_dev->pdev->dev, \"Dumping HW/FW registers\\n\"\n\t\t\t \"PEG_HALT_STATUS1: 0x%x, PEG_HALT_STATUS2: 0x%x,\\n\"\n\t\t\t \"PEG_NET_0_PC: 0x%x, PEG_NET_1_PC: 0x%x,\\n\"\n\t\t\t \"PEG_NET_2_PC: 0x%x, PEG_NET_3_PC: 0x%x,\\n\"\n\t\t\t \"PEG_NET_4_PC: 0x%x\\n\", peg_status,\n\t\t\t QLC_SHARED_REG_RD32(p_dev, QLCNIC_PEG_HALT_STATUS2),\n\t\t\t QLCRD32(p_dev, QLC_83XX_CRB_PEG_NET_0, &err),\n\t\t\t QLCRD32(p_dev, QLC_83XX_CRB_PEG_NET_1, &err),\n\t\t\t QLCRD32(p_dev, QLC_83XX_CRB_PEG_NET_2, &err),\n\t\t\t QLCRD32(p_dev, QLC_83XX_CRB_PEG_NET_3, &err),\n\t\t\t QLCRD32(p_dev, QLC_83XX_CRB_PEG_NET_4, &err));\n\n\t\tif (QLCNIC_FWERROR_CODE(peg_status) == 0x67)\n\t\t\tdev_err(&p_dev->pdev->dev,\n\t\t\t\t\"Device is being reset err code 0x00006700.\\n\");\n\t}\n\n\treturn ret;\n}\n\nstatic int qlcnic_83xx_check_cmd_peg_status(struct qlcnic_adapter *p_dev)\n{\n\tint retries = QLCNIC_CMDPEG_CHECK_RETRY_COUNT;\n\tu32 val;\n\n\tdo {\n\t\tval = QLC_SHARED_REG_RD32(p_dev, QLCNIC_CMDPEG_STATE);\n\t\tif (val == QLC_83XX_CMDPEG_COMPLETE)\n\t\t\treturn 0;\n\t\tmsleep(QLCNIC_CMDPEG_CHECK_DELAY);\n\t} while (--retries);\n\n\tdev_err(&p_dev->pdev->dev, \"%s: failed, state = 0x%x\\n\", __func__, val);\n\treturn -EIO;\n}\n\nstatic int qlcnic_83xx_check_hw_status(struct qlcnic_adapter *p_dev)\n{\n\tint err;\n\n\terr = qlcnic_83xx_check_cmd_peg_status(p_dev);\n\tif (err)\n\t\treturn err;\n\n\terr = qlcnic_83xx_check_heartbeat(p_dev);\n\tif (err)\n\t\treturn err;\n\n\treturn err;\n}\n\nstatic int qlcnic_83xx_poll_reg(struct qlcnic_adapter *p_dev, u32 addr,\n\t\t\t\tint duration, u32 mask, u32 status)\n{\n\tint timeout_error, err = 0;\n\tu32 value;\n\tu8 retries;\n\n\tvalue = QLCRD32(p_dev, addr, &err);\n\tif (err == -EIO)\n\t\treturn err;\n\tretries = duration / 10;\n\n\tdo {\n\t\tif ((value & mask) != status) {\n\t\t\ttimeout_error = 1;\n\t\t\tmsleep(duration / 10);\n\t\t\tvalue = QLCRD32(p_dev, addr, &err);\n\t\t\tif (err == -EIO)\n\t\t\t\treturn err;\n\t\t} else {\n\t\t\ttimeout_error = 0;\n\t\t\tbreak;\n\t\t}\n\t} while (retries--);\n\n\tif (timeout_error) {\n\t\tp_dev->ahw->reset.seq_error++;\n\t\tdev_err(&p_dev->pdev->dev,\n\t\t\t\"%s: Timeout Err, entry_num = %d\\n\",\n\t\t\t__func__, p_dev->ahw->reset.seq_index);\n\t\tdev_err(&p_dev->pdev->dev,\n\t\t\t\"0x%08x 0x%08x 0x%08x\\n\",\n\t\t\tvalue, mask, status);\n\t}\n\n\treturn timeout_error;\n}\n\nstatic int qlcnic_83xx_reset_template_checksum(struct qlcnic_adapter *p_dev)\n{\n\tu32 sum = 0;\n\tu16 *buff = (u16 *)p_dev->ahw->reset.buff;\n\tint count = p_dev->ahw->reset.hdr->size / sizeof(u16);\n\n\twhile (count-- > 0)\n\t\tsum += *buff++;\n\n\twhile (sum >> 16)\n\t\tsum = (sum & 0xFFFF) + (sum >> 16);\n\n\tif (~sum) {\n\t\treturn 0;\n\t} else {\n\t\tdev_err(&p_dev->pdev->dev, \"%s: failed\\n\", __func__);\n\t\treturn -1;\n\t}\n}\n\nstatic int qlcnic_83xx_get_reset_instruction_template(struct qlcnic_adapter *p_dev)\n{\n\tstruct qlcnic_hardware_context *ahw = p_dev->ahw;\n\tu32 addr, count, prev_ver, curr_ver;\n\tu8 *p_buff;\n\n\tif (ahw->reset.buff != NULL) {\n\t\tprev_ver = p_dev->fw_version;\n\t\tcurr_ver = qlcnic_83xx_get_fw_version(p_dev);\n\t\tif (curr_ver > prev_ver)\n\t\t\tkfree(ahw->reset.buff);\n\t\telse\n\t\t\treturn 0;\n\t}\n\n\tahw->reset.seq_error = 0;\n\tahw->reset.buff = kzalloc(QLC_83XX_RESTART_TEMPLATE_SIZE, GFP_KERNEL);\n\tif (ahw->reset.buff == NULL)\n\t\treturn -ENOMEM;\n\n\tp_buff = p_dev->ahw->reset.buff;\n\taddr = QLC_83XX_RESET_TEMPLATE_ADDR;\n\tcount = sizeof(struct qlc_83xx_reset_hdr) / sizeof(u32);\n\n\t \n\tif (qlcnic_83xx_flash_read32(p_dev, addr, p_buff, count)) {\n\t\tdev_err(&p_dev->pdev->dev, \"%s: flash read failed\\n\", __func__);\n\t\treturn -EIO;\n\t}\n\tahw->reset.hdr = (struct qlc_83xx_reset_hdr *)ahw->reset.buff;\n\taddr = QLC_83XX_RESET_TEMPLATE_ADDR + ahw->reset.hdr->hdr_size;\n\tp_buff = ahw->reset.buff + ahw->reset.hdr->hdr_size;\n\tcount = (ahw->reset.hdr->size - ahw->reset.hdr->hdr_size) / sizeof(u32);\n\n\t \n\tif (qlcnic_83xx_flash_read32(p_dev, addr, p_buff, count)) {\n\t\tdev_err(&p_dev->pdev->dev, \"%s: flash read failed\\n\", __func__);\n\t\treturn -EIO;\n\t}\n\n\tif (qlcnic_83xx_reset_template_checksum(p_dev))\n\t\treturn -EIO;\n\t \n\tahw->reset.init_offset = ahw->reset.buff + ahw->reset.hdr->init_offset;\n\tahw->reset.start_offset = ahw->reset.buff +\n\t\t\t\t  ahw->reset.hdr->start_offset;\n\tahw->reset.stop_offset = ahw->reset.buff + ahw->reset.hdr->hdr_size;\n\treturn 0;\n}\n\n \nstatic void qlcnic_83xx_read_write_crb_reg(struct qlcnic_adapter *p_dev,\n\t\t\t\t\t   u32 raddr, u32 waddr)\n{\n\tint err = 0;\n\tu32 value;\n\n\tvalue = QLCRD32(p_dev, raddr, &err);\n\tif (err == -EIO)\n\t\treturn;\n\tqlcnic_83xx_wrt_reg_indirect(p_dev, waddr, value);\n}\n\n \nstatic void qlcnic_83xx_rmw_crb_reg(struct qlcnic_adapter *p_dev,\n\t\t\t\t    u32 raddr, u32 waddr,\n\t\t\t\t    struct qlc_83xx_rmw *p_rmw_hdr)\n{\n\tint err = 0;\n\tu32 value;\n\n\tif (p_rmw_hdr->index_a) {\n\t\tvalue = p_dev->ahw->reset.array[p_rmw_hdr->index_a];\n\t} else {\n\t\tvalue = QLCRD32(p_dev, raddr, &err);\n\t\tif (err == -EIO)\n\t\t\treturn;\n\t}\n\n\tvalue &= p_rmw_hdr->mask;\n\tvalue <<= p_rmw_hdr->shl;\n\tvalue >>= p_rmw_hdr->shr;\n\tvalue |= p_rmw_hdr->or_value;\n\tvalue ^= p_rmw_hdr->xor_value;\n\tqlcnic_83xx_wrt_reg_indirect(p_dev, waddr, value);\n}\n\n \nstatic void qlcnic_83xx_write_list(struct qlcnic_adapter *p_dev,\n\t\t\t\t   struct qlc_83xx_entry_hdr *p_hdr)\n{\n\tint i;\n\tstruct qlc_83xx_entry *entry;\n\n\tentry = (struct qlc_83xx_entry *)((char *)p_hdr +\n\t\t\t\t\t  sizeof(struct qlc_83xx_entry_hdr));\n\n\tfor (i = 0; i < p_hdr->count; i++, entry++) {\n\t\tqlcnic_83xx_wrt_reg_indirect(p_dev, entry->arg1,\n\t\t\t\t\t     entry->arg2);\n\t\tif (p_hdr->delay)\n\t\t\tudelay((u32)(p_hdr->delay));\n\t}\n}\n\n \nstatic void qlcnic_83xx_read_write_list(struct qlcnic_adapter *p_dev,\n\t\t\t\t\tstruct qlc_83xx_entry_hdr *p_hdr)\n{\n\tint i;\n\tstruct qlc_83xx_entry *entry;\n\n\tentry = (struct qlc_83xx_entry *)((char *)p_hdr +\n\t\t\t\t\t  sizeof(struct qlc_83xx_entry_hdr));\n\n\tfor (i = 0; i < p_hdr->count; i++, entry++) {\n\t\tqlcnic_83xx_read_write_crb_reg(p_dev, entry->arg1,\n\t\t\t\t\t       entry->arg2);\n\t\tif (p_hdr->delay)\n\t\t\tudelay((u32)(p_hdr->delay));\n\t}\n}\n\n \nstatic void qlcnic_83xx_poll_list(struct qlcnic_adapter *p_dev,\n\t\t\t\t  struct qlc_83xx_entry_hdr *p_hdr)\n{\n\tlong delay;\n\tstruct qlc_83xx_entry *entry;\n\tstruct qlc_83xx_poll *poll;\n\tint i, err = 0;\n\tunsigned long arg1, arg2;\n\n\tpoll = (struct qlc_83xx_poll *)((char *)p_hdr +\n\t\t\t\t\tsizeof(struct qlc_83xx_entry_hdr));\n\n\tentry = (struct qlc_83xx_entry *)((char *)poll +\n\t\t\t\t\t  sizeof(struct qlc_83xx_poll));\n\tdelay = (long)p_hdr->delay;\n\n\tif (!delay) {\n\t\tfor (i = 0; i < p_hdr->count; i++, entry++)\n\t\t\tqlcnic_83xx_poll_reg(p_dev, entry->arg1,\n\t\t\t\t\t     delay, poll->mask,\n\t\t\t\t\t     poll->status);\n\t} else {\n\t\tfor (i = 0; i < p_hdr->count; i++, entry++) {\n\t\t\targ1 = entry->arg1;\n\t\t\targ2 = entry->arg2;\n\t\t\tif (delay) {\n\t\t\t\tif (qlcnic_83xx_poll_reg(p_dev,\n\t\t\t\t\t\t\t arg1, delay,\n\t\t\t\t\t\t\t poll->mask,\n\t\t\t\t\t\t\t poll->status)){\n\t\t\t\t\tQLCRD32(p_dev, arg1, &err);\n\t\t\t\t\tif (err == -EIO)\n\t\t\t\t\t\treturn;\n\t\t\t\t\tQLCRD32(p_dev, arg2, &err);\n\t\t\t\t\tif (err == -EIO)\n\t\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n \nstatic void qlcnic_83xx_poll_write_list(struct qlcnic_adapter *p_dev,\n\t\t\t\t\tstruct qlc_83xx_entry_hdr *p_hdr)\n{\n\tint i;\n\tlong delay;\n\tstruct qlc_83xx_quad_entry *entry;\n\tstruct qlc_83xx_poll *poll;\n\n\tpoll = (struct qlc_83xx_poll *)((char *)p_hdr +\n\t\t\t\t\tsizeof(struct qlc_83xx_entry_hdr));\n\tentry = (struct qlc_83xx_quad_entry *)((char *)poll +\n\t\t\t\t\t       sizeof(struct qlc_83xx_poll));\n\tdelay = (long)p_hdr->delay;\n\n\tfor (i = 0; i < p_hdr->count; i++, entry++) {\n\t\tqlcnic_83xx_wrt_reg_indirect(p_dev, entry->dr_addr,\n\t\t\t\t\t     entry->dr_value);\n\t\tqlcnic_83xx_wrt_reg_indirect(p_dev, entry->ar_addr,\n\t\t\t\t\t     entry->ar_value);\n\t\tif (delay)\n\t\t\tqlcnic_83xx_poll_reg(p_dev, entry->ar_addr, delay,\n\t\t\t\t\t     poll->mask, poll->status);\n\t}\n}\n\n \nstatic void qlcnic_83xx_read_modify_write(struct qlcnic_adapter *p_dev,\n\t\t\t\t\t  struct qlc_83xx_entry_hdr *p_hdr)\n{\n\tint i;\n\tstruct qlc_83xx_entry *entry;\n\tstruct qlc_83xx_rmw *rmw_hdr;\n\n\trmw_hdr = (struct qlc_83xx_rmw *)((char *)p_hdr +\n\t\t\t\t\t  sizeof(struct qlc_83xx_entry_hdr));\n\n\tentry = (struct qlc_83xx_entry *)((char *)rmw_hdr +\n\t\t\t\t\t  sizeof(struct qlc_83xx_rmw));\n\n\tfor (i = 0; i < p_hdr->count; i++, entry++) {\n\t\tqlcnic_83xx_rmw_crb_reg(p_dev, entry->arg1,\n\t\t\t\t\tentry->arg2, rmw_hdr);\n\t\tif (p_hdr->delay)\n\t\t\tudelay((u32)(p_hdr->delay));\n\t}\n}\n\nstatic void qlcnic_83xx_pause(struct qlc_83xx_entry_hdr *p_hdr)\n{\n\tif (p_hdr->delay)\n\t\tmdelay((u32)((long)p_hdr->delay));\n}\n\n \nstatic void qlcnic_83xx_poll_read_list(struct qlcnic_adapter *p_dev,\n\t\t\t\t       struct qlc_83xx_entry_hdr *p_hdr)\n{\n\tlong delay;\n\tint index, i, j, err;\n\tstruct qlc_83xx_quad_entry *entry;\n\tstruct qlc_83xx_poll *poll;\n\tunsigned long addr;\n\n\tpoll = (struct qlc_83xx_poll *)((char *)p_hdr +\n\t\t\t\t\tsizeof(struct qlc_83xx_entry_hdr));\n\n\tentry = (struct qlc_83xx_quad_entry *)((char *)poll +\n\t\t\t\t\t       sizeof(struct qlc_83xx_poll));\n\tdelay = (long)p_hdr->delay;\n\n\tfor (i = 0; i < p_hdr->count; i++, entry++) {\n\t\tqlcnic_83xx_wrt_reg_indirect(p_dev, entry->ar_addr,\n\t\t\t\t\t     entry->ar_value);\n\t\tif (delay) {\n\t\t\tif (!qlcnic_83xx_poll_reg(p_dev, entry->ar_addr, delay,\n\t\t\t\t\t\t  poll->mask, poll->status)){\n\t\t\t\tindex = p_dev->ahw->reset.array_index;\n\t\t\t\taddr = entry->dr_addr;\n\t\t\t\tj = QLCRD32(p_dev, addr, &err);\n\t\t\t\tif (err == -EIO)\n\t\t\t\t\treturn;\n\n\t\t\t\tp_dev->ahw->reset.array[index++] = j;\n\n\t\t\t\tif (index == QLC_83XX_MAX_RESET_SEQ_ENTRIES)\n\t\t\t\t\tp_dev->ahw->reset.array_index = 1;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic inline void qlcnic_83xx_seq_end(struct qlcnic_adapter *p_dev)\n{\n\tp_dev->ahw->reset.seq_end = 1;\n}\n\nstatic void qlcnic_83xx_template_end(struct qlcnic_adapter *p_dev)\n{\n\tp_dev->ahw->reset.template_end = 1;\n\tif (p_dev->ahw->reset.seq_error == 0)\n\t\tdev_err(&p_dev->pdev->dev,\n\t\t\t\"HW restart process completed successfully.\\n\");\n\telse\n\t\tdev_err(&p_dev->pdev->dev,\n\t\t\t\"HW restart completed with timeout errors.\\n\");\n}\n\n \nstatic void qlcnic_83xx_exec_template_cmd(struct qlcnic_adapter *p_dev,\n\t\t\t\t\t  char *p_buff)\n{\n\tint index, entries;\n\tstruct qlc_83xx_entry_hdr *p_hdr;\n\tchar *entry = p_buff;\n\n\tp_dev->ahw->reset.seq_end = 0;\n\tp_dev->ahw->reset.template_end = 0;\n\tentries = p_dev->ahw->reset.hdr->entries;\n\tindex = p_dev->ahw->reset.seq_index;\n\n\tfor (; (!p_dev->ahw->reset.seq_end) && (index < entries); index++) {\n\t\tp_hdr = (struct qlc_83xx_entry_hdr *)entry;\n\n\t\tswitch (p_hdr->cmd) {\n\t\tcase QLC_83XX_OPCODE_NOP:\n\t\t\tbreak;\n\t\tcase QLC_83XX_OPCODE_WRITE_LIST:\n\t\t\tqlcnic_83xx_write_list(p_dev, p_hdr);\n\t\t\tbreak;\n\t\tcase QLC_83XX_OPCODE_READ_WRITE_LIST:\n\t\t\tqlcnic_83xx_read_write_list(p_dev, p_hdr);\n\t\t\tbreak;\n\t\tcase QLC_83XX_OPCODE_POLL_LIST:\n\t\t\tqlcnic_83xx_poll_list(p_dev, p_hdr);\n\t\t\tbreak;\n\t\tcase QLC_83XX_OPCODE_POLL_WRITE_LIST:\n\t\t\tqlcnic_83xx_poll_write_list(p_dev, p_hdr);\n\t\t\tbreak;\n\t\tcase QLC_83XX_OPCODE_READ_MODIFY_WRITE:\n\t\t\tqlcnic_83xx_read_modify_write(p_dev, p_hdr);\n\t\t\tbreak;\n\t\tcase QLC_83XX_OPCODE_SEQ_PAUSE:\n\t\t\tqlcnic_83xx_pause(p_hdr);\n\t\t\tbreak;\n\t\tcase QLC_83XX_OPCODE_SEQ_END:\n\t\t\tqlcnic_83xx_seq_end(p_dev);\n\t\t\tbreak;\n\t\tcase QLC_83XX_OPCODE_TMPL_END:\n\t\t\tqlcnic_83xx_template_end(p_dev);\n\t\t\tbreak;\n\t\tcase QLC_83XX_OPCODE_POLL_READ_LIST:\n\t\t\tqlcnic_83xx_poll_read_list(p_dev, p_hdr);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(&p_dev->pdev->dev,\n\t\t\t\t\"%s: Unknown opcode 0x%04x in template %d\\n\",\n\t\t\t\t__func__, p_hdr->cmd, index);\n\t\t\tbreak;\n\t\t}\n\t\tentry += p_hdr->size;\n\t\tcond_resched();\n\t}\n\tp_dev->ahw->reset.seq_index = index;\n}\n\nstatic void qlcnic_83xx_stop_hw(struct qlcnic_adapter *p_dev)\n{\n\tp_dev->ahw->reset.seq_index = 0;\n\n\tqlcnic_83xx_exec_template_cmd(p_dev, p_dev->ahw->reset.stop_offset);\n\tif (p_dev->ahw->reset.seq_end != 1)\n\t\tdev_err(&p_dev->pdev->dev, \"%s: failed\\n\", __func__);\n}\n\nstatic void qlcnic_83xx_start_hw(struct qlcnic_adapter *p_dev)\n{\n\tqlcnic_83xx_exec_template_cmd(p_dev, p_dev->ahw->reset.start_offset);\n\tif (p_dev->ahw->reset.template_end != 1)\n\t\tdev_err(&p_dev->pdev->dev, \"%s: failed\\n\", __func__);\n}\n\nstatic void qlcnic_83xx_init_hw(struct qlcnic_adapter *p_dev)\n{\n\tqlcnic_83xx_exec_template_cmd(p_dev, p_dev->ahw->reset.init_offset);\n\tif (p_dev->ahw->reset.seq_end != 1)\n\t\tdev_err(&p_dev->pdev->dev, \"%s: failed\\n\", __func__);\n}\n\n \n#define QLC_83XX_POST_SIGNATURE_REG\t0x41602014\n#define QLC_83XX_POST_MODE_REG\t\t0x41602018\n#define QLC_83XX_POST_FAST_MODE\t\t0\n#define QLC_83XX_POST_MEDIUM_MODE\t1\n#define QLC_83XX_POST_SLOW_MODE\t\t2\n\n \n#define QLC_83XX_POST_FAST_MODE_TIMEOUT\t690\n#define QLC_83XX_POST_MED_MODE_TIMEOUT\t2930\n#define QLC_83XX_POST_SLOW_MODE_TIMEOUT\t7500\n\n \n#define QLC_83XX_POST_PASS\t\t\t0xfffffff0\n#define QLC_83XX_POST_ASIC_STRESS_TEST_FAIL\t0xffffffff\n#define QLC_83XX_POST_DDR_TEST_FAIL\t\t0xfffffffe\n#define QLC_83XX_POST_ASIC_MEMORY_TEST_FAIL\t0xfffffffc\n#define QLC_83XX_POST_FLASH_TEST_FAIL\t\t0xfffffff8\n\nstatic int qlcnic_83xx_run_post(struct qlcnic_adapter *adapter)\n{\n\tstruct qlc_83xx_fw_info *fw_info = adapter->ahw->fw_info;\n\tstruct device *dev = &adapter->pdev->dev;\n\tint timeout, count, ret = 0;\n\tu32 signature;\n\n\t \n\tswitch (adapter->ahw->post_mode) {\n\tcase QLC_83XX_POST_FAST_MODE:\n\t\ttimeout = QLC_83XX_POST_FAST_MODE_TIMEOUT + 2000;\n\t\tbreak;\n\tcase QLC_83XX_POST_MEDIUM_MODE:\n\t\ttimeout = QLC_83XX_POST_MED_MODE_TIMEOUT + 2000;\n\t\tbreak;\n\tcase QLC_83XX_POST_SLOW_MODE:\n\t\ttimeout = QLC_83XX_POST_SLOW_MODE_TIMEOUT + 2000;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tstrncpy(fw_info->fw_file_name, QLC_83XX_POST_FW_FILE_NAME,\n\t\tQLC_FW_FILE_NAME_LEN);\n\n\tret = request_firmware(&fw_info->fw, fw_info->fw_file_name, dev);\n\tif (ret) {\n\t\tdev_err(dev, \"POST firmware can not be loaded, skipping POST\\n\");\n\t\treturn 0;\n\t}\n\n\tret = qlcnic_83xx_copy_fw_file(adapter);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tqlcnic_ind_wr(adapter, QLC_83XX_POST_SIGNATURE_REG, 0);\n\n\t \n\tqlcnic_ind_wr(adapter, QLC_83XX_POST_MODE_REG,\n\t\t      adapter->ahw->post_mode);\n\n\tQLC_SHARED_REG_WR32(adapter, QLCNIC_FW_IMG_VALID,\n\t\t\t    QLC_83XX_BOOT_FROM_FILE);\n\n\tqlcnic_83xx_start_hw(adapter);\n\n\tcount = 0;\n\tdo {\n\t\tmsleep(100);\n\t\tcount += 100;\n\n\t\tsignature = qlcnic_ind_rd(adapter, QLC_83XX_POST_SIGNATURE_REG);\n\t\tif (signature == QLC_83XX_POST_PASS)\n\t\t\tbreak;\n\t} while (timeout > count);\n\n\tif (timeout <= count) {\n\t\tdev_err(dev, \"POST timed out, signature = 0x%08x\\n\", signature);\n\t\treturn -EIO;\n\t}\n\n\tswitch (signature) {\n\tcase QLC_83XX_POST_PASS:\n\t\tdev_info(dev, \"POST passed, Signature = 0x%08x\\n\", signature);\n\t\tbreak;\n\tcase QLC_83XX_POST_ASIC_STRESS_TEST_FAIL:\n\t\tdev_err(dev, \"POST failed, Test case : ASIC STRESS TEST, Signature = 0x%08x\\n\",\n\t\t\tsignature);\n\t\tret = -EIO;\n\t\tbreak;\n\tcase QLC_83XX_POST_DDR_TEST_FAIL:\n\t\tdev_err(dev, \"POST failed, Test case : DDT TEST, Signature = 0x%08x\\n\",\n\t\t\tsignature);\n\t\tret = -EIO;\n\t\tbreak;\n\tcase QLC_83XX_POST_ASIC_MEMORY_TEST_FAIL:\n\t\tdev_err(dev, \"POST failed, Test case : ASIC MEMORY TEST, Signature = 0x%08x\\n\",\n\t\t\tsignature);\n\t\tret = -EIO;\n\t\tbreak;\n\tcase QLC_83XX_POST_FLASH_TEST_FAIL:\n\t\tdev_err(dev, \"POST failed, Test case : FLASH TEST, Signature = 0x%08x\\n\",\n\t\t\tsignature);\n\t\tret = -EIO;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"POST failed, Test case : INVALID, Signature = 0x%08x\\n\",\n\t\t\tsignature);\n\t\tret = -EIO;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int qlcnic_83xx_load_fw_image_from_host(struct qlcnic_adapter *adapter)\n{\n\tstruct qlc_83xx_fw_info *fw_info = adapter->ahw->fw_info;\n\tint err = -EIO;\n\n\tif (request_firmware(&fw_info->fw, fw_info->fw_file_name,\n\t\t\t     &(adapter->pdev->dev))) {\n\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\"No file FW image, loading flash FW image.\\n\");\n\t\tQLC_SHARED_REG_WR32(adapter, QLCNIC_FW_IMG_VALID,\n\t\t\t\t    QLC_83XX_BOOT_FROM_FLASH);\n\t} else {\n\t\tif (qlcnic_83xx_copy_fw_file(adapter))\n\t\t\treturn err;\n\t\tQLC_SHARED_REG_WR32(adapter, QLCNIC_FW_IMG_VALID,\n\t\t\t\t    QLC_83XX_BOOT_FROM_FILE);\n\t}\n\n\treturn 0;\n}\n\nstatic int qlcnic_83xx_restart_hw(struct qlcnic_adapter *adapter)\n{\n\tu32 val;\n\tint err = -EIO;\n\n\tqlcnic_83xx_stop_hw(adapter);\n\n\t \n\tval = QLCRDX(adapter->ahw, QLC_83XX_IDC_CTRL);\n\tif (!(val & QLC_83XX_IDC_GRACEFULL_RESET))\n\t\tqlcnic_dump_fw(adapter);\n\n\tif (val & QLC_83XX_IDC_DISABLE_FW_RESET_RECOVERY) {\n\t\tnetdev_info(adapter->netdev, \"%s: Auto firmware recovery is disabled\\n\",\n\t\t\t    __func__);\n\t\tqlcnic_83xx_idc_enter_failed_state(adapter, 1);\n\t\treturn err;\n\t}\n\n\tqlcnic_83xx_init_hw(adapter);\n\n\tif (qlcnic_83xx_copy_bootloader(adapter))\n\t\treturn err;\n\n\t \n\tif (adapter->ahw->run_post) {\n\t\terr = qlcnic_83xx_run_post(adapter);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\t \n\t\tadapter->ahw->run_post = false;\n\n\t\t \n\t\tqlcnic_83xx_stop_hw(adapter);\n\t\tqlcnic_83xx_init_hw(adapter);\n\n\t\terr = qlcnic_83xx_copy_bootloader(adapter);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t \n\tif (qlcnic_load_fw_file == 1) {\n\t\terr = qlcnic_83xx_load_fw_image_from_host(adapter);\n\t\tif (err)\n\t\t\treturn err;\n\t} else {\n\t\tQLC_SHARED_REG_WR32(adapter, QLCNIC_FW_IMG_VALID,\n\t\t\t\t    QLC_83XX_BOOT_FROM_FLASH);\n\t}\n\n\tqlcnic_83xx_start_hw(adapter);\n\tif (qlcnic_83xx_check_hw_status(adapter))\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic int qlcnic_83xx_get_nic_configuration(struct qlcnic_adapter *adapter)\n{\n\tint err;\n\tstruct qlcnic_info nic_info;\n\tstruct qlcnic_hardware_context *ahw = adapter->ahw;\n\n\tmemset(&nic_info, 0, sizeof(struct qlcnic_info));\n\terr = qlcnic_get_nic_info(adapter, &nic_info, ahw->pci_func);\n\tif (err)\n\t\treturn -EIO;\n\n\tahw->physical_port = (u8) nic_info.phys_port;\n\tahw->switch_mode = nic_info.switch_mode;\n\tahw->max_tx_ques = nic_info.max_tx_ques;\n\tahw->max_rx_ques = nic_info.max_rx_ques;\n\tahw->capabilities = nic_info.capabilities;\n\tahw->max_mac_filters = nic_info.max_mac_filters;\n\tahw->max_mtu = nic_info.max_mtu;\n\n\t \n\tif (test_bit(__QLCNIC_SRIOV_CAPABLE, &adapter->state))\n\t\treturn QLC_83XX_DEFAULT_OPMODE;\n\n\tif (ahw->capabilities & QLC_83XX_ESWITCH_CAPABILITY)\n\t\treturn QLCNIC_VNIC_MODE;\n\n\treturn QLC_83XX_DEFAULT_OPMODE;\n}\n\nint qlcnic_83xx_configure_opmode(struct qlcnic_adapter *adapter)\n{\n\tstruct qlcnic_hardware_context *ahw = adapter->ahw;\n\tu16 max_sds_rings, max_tx_rings;\n\tint ret;\n\n\tret = qlcnic_83xx_get_nic_configuration(adapter);\n\tif (ret == -EIO)\n\t\treturn -EIO;\n\n\tif (ret == QLCNIC_VNIC_MODE) {\n\t\tahw->nic_mode = QLCNIC_VNIC_MODE;\n\n\t\tif (qlcnic_83xx_config_vnic_opmode(adapter))\n\t\t\treturn -EIO;\n\n\t\tmax_sds_rings = QLCNIC_MAX_VNIC_SDS_RINGS;\n\t\tmax_tx_rings = QLCNIC_MAX_VNIC_TX_RINGS;\n\t} else if (ret == QLC_83XX_DEFAULT_OPMODE) {\n\t\tahw->nic_mode = QLCNIC_DEFAULT_MODE;\n\t\tadapter->nic_ops->init_driver = qlcnic_83xx_init_default_driver;\n\t\tahw->idc.state_entry = qlcnic_83xx_idc_ready_state_entry;\n\t\tmax_sds_rings = QLCNIC_MAX_SDS_RINGS;\n\t\tmax_tx_rings = QLCNIC_MAX_TX_RINGS;\n\t} else {\n\t\tdev_err(&adapter->pdev->dev, \"%s: Invalid opmode %d\\n\",\n\t\t\t__func__, ret);\n\t\treturn -EIO;\n\t}\n\n\tadapter->max_sds_rings = min(ahw->max_rx_ques, max_sds_rings);\n\tadapter->max_tx_rings = min(ahw->max_tx_ques, max_tx_rings);\n\n\treturn 0;\n}\n\nstatic void qlcnic_83xx_config_buff_descriptors(struct qlcnic_adapter *adapter)\n{\n\tstruct qlcnic_hardware_context *ahw = adapter->ahw;\n\n\tif (ahw->port_type == QLCNIC_XGBE) {\n\t\tadapter->num_rxd = DEFAULT_RCV_DESCRIPTORS_10G;\n\t\tadapter->max_rxd = MAX_RCV_DESCRIPTORS_10G;\n\t\tadapter->num_jumbo_rxd = MAX_JUMBO_RCV_DESCRIPTORS_10G;\n\t\tadapter->max_jumbo_rxd = MAX_JUMBO_RCV_DESCRIPTORS_10G;\n\n\t} else if (ahw->port_type == QLCNIC_GBE) {\n\t\tadapter->num_rxd = DEFAULT_RCV_DESCRIPTORS_1G;\n\t\tadapter->num_jumbo_rxd = MAX_JUMBO_RCV_DESCRIPTORS_1G;\n\t\tadapter->max_jumbo_rxd = MAX_JUMBO_RCV_DESCRIPTORS_1G;\n\t\tadapter->max_rxd = MAX_RCV_DESCRIPTORS_1G;\n\t}\n\tadapter->num_txd = MAX_CMD_DESCRIPTORS;\n\tadapter->max_rds_rings = MAX_RDS_RINGS;\n}\n\nstatic int qlcnic_83xx_init_default_driver(struct qlcnic_adapter *adapter)\n{\n\tint err = -EIO;\n\n\tqlcnic_83xx_get_minidump_template(adapter);\n\tif (qlcnic_83xx_get_port_info(adapter))\n\t\treturn err;\n\n\tqlcnic_83xx_config_buff_descriptors(adapter);\n\tadapter->ahw->msix_supported = !!qlcnic_use_msi_x;\n\tadapter->flags |= QLCNIC_ADAPTER_INITIALIZED;\n\n\tdev_info(&adapter->pdev->dev, \"HAL Version: %d\\n\",\n\t\t adapter->ahw->fw_hal_version);\n\n\treturn 0;\n}\n\n#define IS_QLC_83XX_USED(a, b, c) (((1 << a->portnum) & b) || ((c >> 6) & 0x1))\nstatic void qlcnic_83xx_clear_function_resources(struct qlcnic_adapter *adapter)\n{\n\tstruct qlcnic_cmd_args cmd;\n\tu32 presence_mask, audit_mask;\n\tint status;\n\n\tpresence_mask = QLCRDX(adapter->ahw, QLC_83XX_IDC_DRV_PRESENCE);\n\taudit_mask = QLCRDX(adapter->ahw, QLC_83XX_IDC_DRV_AUDIT);\n\n\tif (IS_QLC_83XX_USED(adapter, presence_mask, audit_mask)) {\n\t\tstatus = qlcnic_alloc_mbx_args(&cmd, adapter,\n\t\t\t\t\t       QLCNIC_CMD_STOP_NIC_FUNC);\n\t\tif (status)\n\t\t\treturn;\n\n\t\tcmd.req.arg[1] = BIT_31;\n\t\tstatus = qlcnic_issue_cmd(adapter, &cmd);\n\t\tif (status)\n\t\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\t\"Failed to clean up the function resources\\n\");\n\t\tqlcnic_free_mbx_args(&cmd);\n\t}\n}\n\nstatic int qlcnic_83xx_get_fw_info(struct qlcnic_adapter *adapter)\n{\n\tstruct qlcnic_hardware_context *ahw = adapter->ahw;\n\tstruct pci_dev *pdev = adapter->pdev;\n\tstruct qlc_83xx_fw_info *fw_info;\n\tint err = 0;\n\n\tahw->fw_info = kzalloc(sizeof(*fw_info), GFP_KERNEL);\n\tif (!ahw->fw_info) {\n\t\terr = -ENOMEM;\n\t} else {\n\t\tfw_info = ahw->fw_info;\n\t\tswitch (pdev->device) {\n\t\tcase PCI_DEVICE_ID_QLOGIC_QLE834X:\n\t\tcase PCI_DEVICE_ID_QLOGIC_QLE8830:\n\t\t\tstrncpy(fw_info->fw_file_name, QLC_83XX_FW_FILE_NAME,\n\t\t\t\tQLC_FW_FILE_NAME_LEN);\n\t\t\tbreak;\n\t\tcase PCI_DEVICE_ID_QLOGIC_QLE844X:\n\t\t\tstrncpy(fw_info->fw_file_name, QLC_84XX_FW_FILE_NAME,\n\t\t\t\tQLC_FW_FILE_NAME_LEN);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(&pdev->dev, \"%s: Invalid device id\\n\",\n\t\t\t\t__func__);\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn err;\n}\n\nstatic void qlcnic_83xx_init_rings(struct qlcnic_adapter *adapter)\n{\n\tu8 rx_cnt = QLCNIC_DEF_SDS_RINGS;\n\tu8 tx_cnt = QLCNIC_DEF_TX_RINGS;\n\n\tadapter->max_tx_rings = QLCNIC_MAX_TX_RINGS;\n\tadapter->max_sds_rings = QLCNIC_MAX_SDS_RINGS;\n\n\tif (!adapter->ahw->msix_supported) {\n\t\trx_cnt = QLCNIC_SINGLE_RING;\n\t\ttx_cnt = QLCNIC_SINGLE_RING;\n\t}\n\n\t \n\tqlcnic_set_tx_ring_count(adapter, tx_cnt);\n\tqlcnic_set_sds_ring_count(adapter, rx_cnt);\n}\n\nint qlcnic_83xx_init(struct qlcnic_adapter *adapter)\n{\n\tstruct qlcnic_hardware_context *ahw = adapter->ahw;\n\tint err = 0;\n\n\tadapter->rx_mac_learn = false;\n\tahw->msix_supported = !!qlcnic_use_msi_x;\n\n\t \n\tswitch (qlcnic_load_fw_file) {\n\tcase 2:\n\t\tahw->post_mode = QLC_83XX_POST_FAST_MODE;\n\t\tahw->run_post = true;\n\t\tbreak;\n\tcase 3:\n\t\tahw->post_mode = QLC_83XX_POST_MEDIUM_MODE;\n\t\tahw->run_post = true;\n\t\tbreak;\n\tcase 4:\n\t\tahw->post_mode = QLC_83XX_POST_SLOW_MODE;\n\t\tahw->run_post = true;\n\t\tbreak;\n\tdefault:\n\t\tahw->run_post = false;\n\t\tbreak;\n\t}\n\n\tqlcnic_83xx_init_rings(adapter);\n\n\terr = qlcnic_83xx_init_mailbox_work(adapter);\n\tif (err)\n\t\tgoto exit;\n\n\tif (qlcnic_sriov_vf_check(adapter)) {\n\t\terr = qlcnic_sriov_vf_init(adapter);\n\t\tif (err)\n\t\t\tgoto detach_mbx;\n\t\telse\n\t\t\treturn err;\n\t}\n\n\tif (qlcnic_83xx_read_flash_descriptor_table(adapter) ||\n\t    qlcnic_83xx_read_flash_mfg_id(adapter)) {\n\t\tdev_err(&adapter->pdev->dev, \"Failed reading flash mfg id\\n\");\n\t\terr = -ENOTRECOVERABLE;\n\t\tgoto detach_mbx;\n\t}\n\n\terr = qlcnic_83xx_check_hw_status(adapter);\n\tif (err)\n\t\tgoto detach_mbx;\n\n\terr = qlcnic_83xx_get_fw_info(adapter);\n\tif (err)\n\t\tgoto detach_mbx;\n\n\terr = qlcnic_83xx_idc_init(adapter);\n\tif (err)\n\t\tgoto detach_mbx;\n\n\terr = qlcnic_setup_intr(adapter);\n\tif (err) {\n\t\tdev_err(&adapter->pdev->dev, \"Failed to setup interrupt\\n\");\n\t\tgoto disable_intr;\n\t}\n\n\tINIT_DELAYED_WORK(&adapter->idc_aen_work, qlcnic_83xx_idc_aen_work);\n\n\terr = qlcnic_83xx_setup_mbx_intr(adapter);\n\tif (err)\n\t\tgoto disable_mbx_intr;\n\n\tqlcnic_83xx_clear_function_resources(adapter);\n\n\terr = qlcnic_dcb_enable(adapter->dcb);\n\tif (err) {\n\t\tqlcnic_dcb_free(adapter->dcb);\n\t\tgoto disable_mbx_intr;\n\t}\n\n\tqlcnic_83xx_initialize_nic(adapter, 1);\n\tqlcnic_dcb_get_info(adapter->dcb);\n\n\t \n\terr = qlcnic_83xx_configure_opmode(adapter);\n\tif (err)\n\t\tgoto disable_mbx_intr;\n\n\n\t \n\terr = adapter->nic_ops->init_driver(adapter);\n\tif (err)\n\t\tgoto disable_mbx_intr;\n\n\t \n\tqlcnic_83xx_idc_poll_dev_state(&adapter->fw_work.work);\n\treturn 0;\n\ndisable_mbx_intr:\n\tqlcnic_83xx_free_mbx_intr(adapter);\n\ndisable_intr:\n\tqlcnic_teardown_intr(adapter);\n\ndetach_mbx:\n\tqlcnic_83xx_detach_mailbox_work(adapter);\n\tqlcnic_83xx_free_mailbox(ahw->mailbox);\n\tahw->mailbox = NULL;\nexit:\n\treturn err;\n}\n\nvoid qlcnic_83xx_aer_stop_poll_work(struct qlcnic_adapter *adapter)\n{\n\tstruct qlcnic_hardware_context *ahw = adapter->ahw;\n\tstruct qlc_83xx_idc *idc = &ahw->idc;\n\n\tclear_bit(QLC_83XX_MBX_READY, &idc->status);\n\tcancel_delayed_work_sync(&adapter->fw_work);\n\n\tif (ahw->nic_mode == QLCNIC_VNIC_MODE)\n\t\tqlcnic_83xx_disable_vnic_mode(adapter, 1);\n\n\tqlcnic_83xx_idc_detach_driver(adapter);\n\tqlcnic_83xx_initialize_nic(adapter, 0);\n\n\tcancel_delayed_work_sync(&adapter->idc_aen_work);\n}\n\nint qlcnic_83xx_aer_reset(struct qlcnic_adapter *adapter)\n{\n\tstruct qlcnic_hardware_context *ahw = adapter->ahw;\n\tstruct qlc_83xx_idc *idc = &ahw->idc;\n\tint ret = 0;\n\tu32 owner;\n\n\t \n\tidc->prev_state = QLC_83XX_IDC_DEV_NEED_RESET;\n\towner = qlcnic_83xx_idc_find_reset_owner_id(adapter);\n\tif (ahw->pci_func == owner) {\n\t\tret = qlcnic_83xx_restart_hw(adapter);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tqlcnic_83xx_idc_clear_registers(adapter, 0);\n\t}\n\n\tret = idc->state_entry(adapter);\n\treturn ret;\n}\n\nvoid qlcnic_83xx_aer_start_poll_work(struct qlcnic_adapter *adapter)\n{\n\tstruct qlcnic_hardware_context *ahw = adapter->ahw;\n\tstruct qlc_83xx_idc *idc = &ahw->idc;\n\tu32 owner;\n\n\tidc->prev_state = QLC_83XX_IDC_DEV_READY;\n\towner = qlcnic_83xx_idc_find_reset_owner_id(adapter);\n\tif (ahw->pci_func == owner)\n\t\tqlcnic_83xx_idc_enter_ready_state(adapter, 0);\n\n\tqlcnic_schedule_work(adapter, qlcnic_83xx_idc_poll_dev_state, 0);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}