{
  "module_name": "qlcnic_hw.c",
  "hash_id": "a7946a9640d9eda8572a5c035ac0c10603160ce717f13ccaf0c6497505de3c4e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/qlogic/qlcnic/qlcnic_hw.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <net/ip.h>\n#include <linux/bitops.h>\n\n#include \"qlcnic.h\"\n#include \"qlcnic_hdr.h\"\n\n#define MASK(n) ((1ULL<<(n))-1)\n#define OCM_WIN_P3P(addr) (addr & 0xffc0000)\n\n#define GET_MEM_OFFS_2M(addr) (addr & MASK(18))\n\n#define CRB_BLK(off)\t((off >> 20) & 0x3f)\n#define CRB_SUBBLK(off)\t((off >> 16) & 0xf)\n#define CRB_WINDOW_2M\t(0x130060)\n#define CRB_HI(off)\t((crb_hub_agt[CRB_BLK(off)] << 20) | ((off) & 0xf0000))\n#define CRB_INDIRECT_2M\t(0x1e0000UL)\n\nstruct qlcnic_ms_reg_ctrl {\n\tu32 ocm_window;\n\tu32 control;\n\tu32 hi;\n\tu32 low;\n\tu32 rd[4];\n\tu32 wd[4];\n\tu64 off;\n};\n\n#ifndef readq\nstatic inline u64 readq(void __iomem *addr)\n{\n\treturn readl(addr) | (((u64) readl(addr + 4)) << 32LL);\n}\n#endif\n\n#ifndef writeq\nstatic inline void writeq(u64 val, void __iomem *addr)\n{\n\twritel(((u32) (val)), (addr));\n\twritel(((u32) (val >> 32)), (addr + 4));\n}\n#endif\n\nstatic struct crb_128M_2M_block_map\ncrb_128M_2M_map[64] __cacheline_aligned_in_smp = {\n    {{{0, 0,         0,         0} } },\t\t \n    {{{1, 0x0100000, 0x0102000, 0x120000},\t \n\t  {1, 0x0110000, 0x0120000, 0x130000},\n\t  {1, 0x0120000, 0x0122000, 0x124000},\n\t  {1, 0x0130000, 0x0132000, 0x126000},\n\t  {1, 0x0140000, 0x0142000, 0x128000},\n\t  {1, 0x0150000, 0x0152000, 0x12a000},\n\t  {1, 0x0160000, 0x0170000, 0x110000},\n\t  {1, 0x0170000, 0x0172000, 0x12e000},\n\t  {0, 0x0000000, 0x0000000, 0x000000},\n\t  {0, 0x0000000, 0x0000000, 0x000000},\n\t  {0, 0x0000000, 0x0000000, 0x000000},\n\t  {0, 0x0000000, 0x0000000, 0x000000},\n\t  {0, 0x0000000, 0x0000000, 0x000000},\n\t  {0, 0x0000000, 0x0000000, 0x000000},\n\t  {1, 0x01e0000, 0x01e0800, 0x122000},\n\t  {0, 0x0000000, 0x0000000, 0x000000} } },\n\t{{{1, 0x0200000, 0x0210000, 0x180000} } }, \n    {{{0, 0,         0,         0} } },\t     \n    {{{1, 0x0400000, 0x0401000, 0x169000} } }, \n    {{{1, 0x0500000, 0x0510000, 0x140000} } }, \n    {{{1, 0x0600000, 0x0610000, 0x1c0000} } }, \n    {{{1, 0x0700000, 0x0704000, 0x1b8000} } }, \n    {{{1, 0x0800000, 0x0802000, 0x170000},   \n      {0, 0x0000000, 0x0000000, 0x000000},\n      {0, 0x0000000, 0x0000000, 0x000000},\n      {0, 0x0000000, 0x0000000, 0x000000},\n      {0, 0x0000000, 0x0000000, 0x000000},\n      {0, 0x0000000, 0x0000000, 0x000000},\n      {0, 0x0000000, 0x0000000, 0x000000},\n      {0, 0x0000000, 0x0000000, 0x000000},\n      {0, 0x0000000, 0x0000000, 0x000000},\n      {0, 0x0000000, 0x0000000, 0x000000},\n      {0, 0x0000000, 0x0000000, 0x000000},\n      {0, 0x0000000, 0x0000000, 0x000000},\n      {0, 0x0000000, 0x0000000, 0x000000},\n      {0, 0x0000000, 0x0000000, 0x000000},\n      {0, 0x0000000, 0x0000000, 0x000000},\n      {1, 0x08f0000, 0x08f2000, 0x172000} } },\n    {{{1, 0x0900000, 0x0902000, 0x174000},\t \n      {0, 0x0000000, 0x0000000, 0x000000},\n      {0, 0x0000000, 0x0000000, 0x000000},\n      {0, 0x0000000, 0x0000000, 0x000000},\n      {0, 0x0000000, 0x0000000, 0x000000},\n      {0, 0x0000000, 0x0000000, 0x000000},\n      {0, 0x0000000, 0x0000000, 0x000000},\n      {0, 0x0000000, 0x0000000, 0x000000},\n      {0, 0x0000000, 0x0000000, 0x000000},\n      {0, 0x0000000, 0x0000000, 0x000000},\n      {0, 0x0000000, 0x0000000, 0x000000},\n      {0, 0x0000000, 0x0000000, 0x000000},\n      {0, 0x0000000, 0x0000000, 0x000000},\n      {0, 0x0000000, 0x0000000, 0x000000},\n      {0, 0x0000000, 0x0000000, 0x000000},\n      {1, 0x09f0000, 0x09f2000, 0x176000} } },\n    {{{0, 0x0a00000, 0x0a02000, 0x178000},\t \n      {0, 0x0000000, 0x0000000, 0x000000},\n      {0, 0x0000000, 0x0000000, 0x000000},\n      {0, 0x0000000, 0x0000000, 0x000000},\n      {0, 0x0000000, 0x0000000, 0x000000},\n      {0, 0x0000000, 0x0000000, 0x000000},\n      {0, 0x0000000, 0x0000000, 0x000000},\n      {0, 0x0000000, 0x0000000, 0x000000},\n      {0, 0x0000000, 0x0000000, 0x000000},\n      {0, 0x0000000, 0x0000000, 0x000000},\n      {0, 0x0000000, 0x0000000, 0x000000},\n      {0, 0x0000000, 0x0000000, 0x000000},\n      {0, 0x0000000, 0x0000000, 0x000000},\n      {0, 0x0000000, 0x0000000, 0x000000},\n      {0, 0x0000000, 0x0000000, 0x000000},\n      {1, 0x0af0000, 0x0af2000, 0x17a000} } },\n    {{{0, 0x0b00000, 0x0b02000, 0x17c000},\t \n      {0, 0x0000000, 0x0000000, 0x000000},\n      {0, 0x0000000, 0x0000000, 0x000000},\n      {0, 0x0000000, 0x0000000, 0x000000},\n      {0, 0x0000000, 0x0000000, 0x000000},\n      {0, 0x0000000, 0x0000000, 0x000000},\n      {0, 0x0000000, 0x0000000, 0x000000},\n      {0, 0x0000000, 0x0000000, 0x000000},\n      {0, 0x0000000, 0x0000000, 0x000000},\n      {0, 0x0000000, 0x0000000, 0x000000},\n      {0, 0x0000000, 0x0000000, 0x000000},\n      {0, 0x0000000, 0x0000000, 0x000000},\n      {0, 0x0000000, 0x0000000, 0x000000},\n      {0, 0x0000000, 0x0000000, 0x000000},\n      {0, 0x0000000, 0x0000000, 0x000000},\n      {1, 0x0bf0000, 0x0bf2000, 0x17e000} } },\n\t{{{1, 0x0c00000, 0x0c04000, 0x1d4000} } }, \n\t{{{1, 0x0d00000, 0x0d04000, 0x1a4000} } }, \n\t{{{1, 0x0e00000, 0x0e04000, 0x1a0000} } }, \n\t{{{1, 0x0f00000, 0x0f01000, 0x164000} } }, \n\t{{{0, 0x1000000, 0x1004000, 0x1a8000} } }, \n\t{{{1, 0x1100000, 0x1101000, 0x160000} } }, \n\t{{{1, 0x1200000, 0x1201000, 0x161000} } }, \n\t{{{1, 0x1300000, 0x1301000, 0x162000} } }, \n\t{{{1, 0x1400000, 0x1401000, 0x163000} } }, \n\t{{{1, 0x1500000, 0x1501000, 0x165000} } }, \n\t{{{1, 0x1600000, 0x1601000, 0x166000} } }, \n\t{{{0, 0,         0,         0} } },\t \n\t{{{0, 0,         0,         0} } },\t \n\t{{{0, 0,         0,         0} } },\t \n\t{{{0, 0,         0,         0} } },\t \n\t{{{0, 0,         0,         0} } },\t \n\t{{{0, 0,         0,         0} } },\t \n\t{{{1, 0x1d00000, 0x1d10000, 0x190000} } }, \n    {{{1, 0x1e00000, 0x1e01000, 0x16a000} } }, \n    {{{1, 0x1f00000, 0x1f10000, 0x150000} } }, \n\t{{{0} } },\t\t\t\t \n\t{{{1, 0x2100000, 0x2102000, 0x120000},\t \n\t  {1, 0x2110000, 0x2120000, 0x130000},\n\t  {1, 0x2120000, 0x2122000, 0x124000},\n\t  {1, 0x2130000, 0x2132000, 0x126000},\n\t  {1, 0x2140000, 0x2142000, 0x128000},\n\t  {1, 0x2150000, 0x2152000, 0x12a000},\n\t  {1, 0x2160000, 0x2170000, 0x110000},\n\t  {1, 0x2170000, 0x2172000, 0x12e000},\n\t  {0, 0x0000000, 0x0000000, 0x000000},\n\t  {0, 0x0000000, 0x0000000, 0x000000},\n\t  {0, 0x0000000, 0x0000000, 0x000000},\n\t  {0, 0x0000000, 0x0000000, 0x000000},\n\t  {0, 0x0000000, 0x0000000, 0x000000},\n\t  {0, 0x0000000, 0x0000000, 0x000000},\n\t  {0, 0x0000000, 0x0000000, 0x000000},\n\t  {0, 0x0000000, 0x0000000, 0x000000} } },\n\t{{{1, 0x2200000, 0x2204000, 0x1b0000} } }, \n\t{{{0} } },\t\t\t\t \n\t{{{0} } },\t\t\t\t \n\t{{{0} } },\t\t\t\t \n\t{{{0} } },\t\t\t\t \n\t{{{0} } },\t\t\t\t \n\t{{{1, 0x2800000, 0x2804000, 0x1a4000} } }, \n\t{{{1, 0x2900000, 0x2901000, 0x16b000} } }, \n\t{{{1, 0x2a00000, 0x2a00400, 0x1ac400} } }, \n\t{{{1, 0x2b00000, 0x2b00400, 0x1ac800} } }, \n\t{{{1, 0x2c00000, 0x2c00400, 0x1acc00} } }, \n\t{{{1, 0x2d00000, 0x2d00400, 0x1ad000} } }, \n\t{{{1, 0x2e00000, 0x2e00400, 0x1ad400} } }, \n\t{{{1, 0x2f00000, 0x2f00400, 0x1ad800} } }, \n\t{{{1, 0x3000000, 0x3000400, 0x1adc00} } }, \n\t{{{0, 0x3100000, 0x3104000, 0x1a8000} } }, \n\t{{{1, 0x3200000, 0x3204000, 0x1d4000} } }, \n\t{{{1, 0x3300000, 0x3304000, 0x1a0000} } }, \n\t{{{0} } },\t\t\t\t \n\t{{{1, 0x3500000, 0x3500400, 0x1ac000} } }, \n\t{{{1, 0x3600000, 0x3600400, 0x1ae000} } }, \n\t{{{1, 0x3700000, 0x3700400, 0x1ae400} } }, \n\t{{{1, 0x3800000, 0x3804000, 0x1d0000} } }, \n\t{{{1, 0x3900000, 0x3904000, 0x1b4000} } }, \n\t{{{1, 0x3a00000, 0x3a04000, 0x1d8000} } }, \n\t{{{0} } },\t\t\t\t \n\t{{{0} } },\t\t\t\t \n\t{{{1, 0x3d00000, 0x3d04000, 0x1d8000} } }, \n\t{{{1, 0x3e00000, 0x3e01000, 0x167000} } }, \n\t{{{1, 0x3f00000, 0x3f01000, 0x168000} } }\t \n};\n\n \nstatic const unsigned crb_hub_agt[64] = {\n\t0,\n\tQLCNIC_HW_CRB_HUB_AGT_ADR_PS,\n\tQLCNIC_HW_CRB_HUB_AGT_ADR_MN,\n\tQLCNIC_HW_CRB_HUB_AGT_ADR_MS,\n\t0,\n\tQLCNIC_HW_CRB_HUB_AGT_ADR_SRE,\n\tQLCNIC_HW_CRB_HUB_AGT_ADR_NIU,\n\tQLCNIC_HW_CRB_HUB_AGT_ADR_QMN,\n\tQLCNIC_HW_CRB_HUB_AGT_ADR_SQN0,\n\tQLCNIC_HW_CRB_HUB_AGT_ADR_SQN1,\n\tQLCNIC_HW_CRB_HUB_AGT_ADR_SQN2,\n\tQLCNIC_HW_CRB_HUB_AGT_ADR_SQN3,\n\tQLCNIC_HW_CRB_HUB_AGT_ADR_I2Q,\n\tQLCNIC_HW_CRB_HUB_AGT_ADR_TIMR,\n\tQLCNIC_HW_CRB_HUB_AGT_ADR_ROMUSB,\n\tQLCNIC_HW_CRB_HUB_AGT_ADR_PGN4,\n\tQLCNIC_HW_CRB_HUB_AGT_ADR_XDMA,\n\tQLCNIC_HW_CRB_HUB_AGT_ADR_PGN0,\n\tQLCNIC_HW_CRB_HUB_AGT_ADR_PGN1,\n\tQLCNIC_HW_CRB_HUB_AGT_ADR_PGN2,\n\tQLCNIC_HW_CRB_HUB_AGT_ADR_PGN3,\n\tQLCNIC_HW_CRB_HUB_AGT_ADR_PGND,\n\tQLCNIC_HW_CRB_HUB_AGT_ADR_PGNI,\n\tQLCNIC_HW_CRB_HUB_AGT_ADR_PGS0,\n\tQLCNIC_HW_CRB_HUB_AGT_ADR_PGS1,\n\tQLCNIC_HW_CRB_HUB_AGT_ADR_PGS2,\n\tQLCNIC_HW_CRB_HUB_AGT_ADR_PGS3,\n\t0,\n\tQLCNIC_HW_CRB_HUB_AGT_ADR_PGSI,\n\tQLCNIC_HW_CRB_HUB_AGT_ADR_SN,\n\t0,\n\tQLCNIC_HW_CRB_HUB_AGT_ADR_EG,\n\t0,\n\tQLCNIC_HW_CRB_HUB_AGT_ADR_PS,\n\tQLCNIC_HW_CRB_HUB_AGT_ADR_CAM,\n\t0,\n\t0,\n\t0,\n\t0,\n\t0,\n\tQLCNIC_HW_CRB_HUB_AGT_ADR_TIMR,\n\t0,\n\tQLCNIC_HW_CRB_HUB_AGT_ADR_RPMX1,\n\tQLCNIC_HW_CRB_HUB_AGT_ADR_RPMX2,\n\tQLCNIC_HW_CRB_HUB_AGT_ADR_RPMX3,\n\tQLCNIC_HW_CRB_HUB_AGT_ADR_RPMX4,\n\tQLCNIC_HW_CRB_HUB_AGT_ADR_RPMX5,\n\tQLCNIC_HW_CRB_HUB_AGT_ADR_RPMX6,\n\tQLCNIC_HW_CRB_HUB_AGT_ADR_RPMX7,\n\tQLCNIC_HW_CRB_HUB_AGT_ADR_XDMA,\n\tQLCNIC_HW_CRB_HUB_AGT_ADR_I2Q,\n\tQLCNIC_HW_CRB_HUB_AGT_ADR_ROMUSB,\n\t0,\n\tQLCNIC_HW_CRB_HUB_AGT_ADR_RPMX0,\n\tQLCNIC_HW_CRB_HUB_AGT_ADR_RPMX8,\n\tQLCNIC_HW_CRB_HUB_AGT_ADR_RPMX9,\n\tQLCNIC_HW_CRB_HUB_AGT_ADR_OCM0,\n\t0,\n\tQLCNIC_HW_CRB_HUB_AGT_ADR_SMB,\n\tQLCNIC_HW_CRB_HUB_AGT_ADR_I2C0,\n\tQLCNIC_HW_CRB_HUB_AGT_ADR_I2C1,\n\t0,\n\tQLCNIC_HW_CRB_HUB_AGT_ADR_PGNC,\n\t0,\n};\n\n \n\n#define QLCNIC_PCIE_SEM_TIMEOUT\t10000\n\nstatic void qlcnic_read_window_reg(u32 addr, void __iomem *bar0, u32 *data)\n{\n\tu32 dest;\n\tvoid __iomem *val;\n\n\tdest = addr & 0xFFFF0000;\n\tval = bar0 + QLCNIC_FW_DUMP_REG1;\n\twritel(dest, val);\n\treadl(val);\n\tval = bar0 + QLCNIC_FW_DUMP_REG2 + LSW(addr);\n\t*data = readl(val);\n}\n\nstatic void qlcnic_write_window_reg(u32 addr, void __iomem *bar0, u32 data)\n{\n\tu32 dest;\n\tvoid __iomem *val;\n\n\tdest = addr & 0xFFFF0000;\n\tval = bar0 + QLCNIC_FW_DUMP_REG1;\n\twritel(dest, val);\n\treadl(val);\n\tval = bar0 + QLCNIC_FW_DUMP_REG2 + LSW(addr);\n\twritel(data, val);\n\treadl(val);\n}\n\nint\nqlcnic_pcie_sem_lock(struct qlcnic_adapter *adapter, int sem, u32 id_reg)\n{\n\tint timeout = 0, err = 0, done = 0;\n\n\twhile (!done) {\n\t\tdone = QLCRD32(adapter, QLCNIC_PCIE_REG(PCIE_SEM_LOCK(sem)),\n\t\t\t       &err);\n\t\tif (done == 1)\n\t\t\tbreak;\n\t\tif (++timeout >= QLCNIC_PCIE_SEM_TIMEOUT) {\n\t\t\tif (id_reg) {\n\t\t\t\tdone = QLCRD32(adapter, id_reg, &err);\n\t\t\t\tif (done != -1)\n\t\t\t\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\t\t\t\"Failed to acquire sem=%d lock held by=%d\\n\",\n\t\t\t\t\t\tsem, done);\n\t\t\t\telse\n\t\t\t\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\t\t\t\"Failed to acquire sem=%d lock\",\n\t\t\t\t\t\tsem);\n\t\t\t} else {\n\t\t\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\t\t\"Failed to acquire sem=%d lock\", sem);\n\t\t\t}\n\t\t\treturn -EIO;\n\t\t}\n\t\tudelay(1200);\n\t}\n\n\tif (id_reg)\n\t\tQLCWR32(adapter, id_reg, adapter->portnum);\n\n\treturn 0;\n}\n\nvoid\nqlcnic_pcie_sem_unlock(struct qlcnic_adapter *adapter, int sem)\n{\n\tint err = 0;\n\n\tQLCRD32(adapter, QLCNIC_PCIE_REG(PCIE_SEM_UNLOCK(sem)), &err);\n}\n\nint qlcnic_ind_rd(struct qlcnic_adapter *adapter, u32 addr)\n{\n\tint err = 0;\n\tu32 data;\n\n\tif (qlcnic_82xx_check(adapter))\n\t\tqlcnic_read_window_reg(addr, adapter->ahw->pci_base0, &data);\n\telse {\n\t\tdata = QLCRD32(adapter, addr, &err);\n\t\tif (err == -EIO)\n\t\t\treturn err;\n\t}\n\treturn data;\n}\n\nint qlcnic_ind_wr(struct qlcnic_adapter *adapter, u32 addr, u32 data)\n{\n\tint ret = 0;\n\n\tif (qlcnic_82xx_check(adapter))\n\t\tqlcnic_write_window_reg(addr, adapter->ahw->pci_base0, data);\n\telse\n\t\tret = qlcnic_83xx_wrt_reg_indirect(adapter, addr, data);\n\n\treturn ret;\n}\n\nstatic int\nqlcnic_send_cmd_descs(struct qlcnic_adapter *adapter,\n\t\tstruct cmd_desc_type0 *cmd_desc_arr, int nr_desc)\n{\n\tu32 i, producer;\n\tstruct qlcnic_cmd_buffer *pbuf;\n\tstruct cmd_desc_type0 *cmd_desc;\n\tstruct qlcnic_host_tx_ring *tx_ring;\n\n\ti = 0;\n\n\tif (!test_bit(__QLCNIC_FW_ATTACHED, &adapter->state))\n\t\treturn -EIO;\n\n\ttx_ring = &adapter->tx_ring[0];\n\t__netif_tx_lock_bh(tx_ring->txq);\n\n\tproducer = tx_ring->producer;\n\n\tif (nr_desc >= qlcnic_tx_avail(tx_ring)) {\n\t\tnetif_tx_stop_queue(tx_ring->txq);\n\t\tsmp_mb();\n\t\tif (qlcnic_tx_avail(tx_ring) > nr_desc) {\n\t\t\tif (qlcnic_tx_avail(tx_ring) > TX_STOP_THRESH)\n\t\t\t\tnetif_tx_wake_queue(tx_ring->txq);\n\t\t} else {\n\t\t\tadapter->stats.xmit_off++;\n\t\t\t__netif_tx_unlock_bh(tx_ring->txq);\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\n\tdo {\n\t\tcmd_desc = &cmd_desc_arr[i];\n\n\t\tpbuf = &tx_ring->cmd_buf_arr[producer];\n\t\tpbuf->skb = NULL;\n\t\tpbuf->frag_count = 0;\n\n\t\tmemcpy(&tx_ring->desc_head[producer],\n\t\t       cmd_desc, sizeof(struct cmd_desc_type0));\n\n\t\tproducer = get_next_index(producer, tx_ring->num_desc);\n\t\ti++;\n\n\t} while (i != nr_desc);\n\n\ttx_ring->producer = producer;\n\n\tqlcnic_update_cmd_producer(tx_ring);\n\n\t__netif_tx_unlock_bh(tx_ring->txq);\n\n\treturn 0;\n}\n\nint qlcnic_82xx_sre_macaddr_change(struct qlcnic_adapter *adapter, u8 *addr,\n\t\t\t\t   u16 vlan_id, u8 op)\n{\n\tstruct qlcnic_nic_req req;\n\tstruct qlcnic_mac_req *mac_req;\n\tstruct qlcnic_vlan_req *vlan_req;\n\tu64 word;\n\n\tmemset(&req, 0, sizeof(struct qlcnic_nic_req));\n\treq.qhdr = cpu_to_le64(QLCNIC_REQUEST << 23);\n\n\tword = QLCNIC_MAC_EVENT | ((u64)adapter->portnum << 16);\n\treq.req_hdr = cpu_to_le64(word);\n\n\tmac_req = (struct qlcnic_mac_req *)&req.words[0];\n\tmac_req->op = op;\n\tmemcpy(mac_req->mac_addr, addr, ETH_ALEN);\n\n\tvlan_req = (struct qlcnic_vlan_req *)&req.words[1];\n\tvlan_req->vlan_id = cpu_to_le16(vlan_id);\n\n\treturn qlcnic_send_cmd_descs(adapter, (struct cmd_desc_type0 *)&req, 1);\n}\n\nint qlcnic_nic_del_mac(struct qlcnic_adapter *adapter, const u8 *addr)\n{\n\tstruct qlcnic_mac_vlan_list *cur;\n\tint err = -EINVAL;\n\n\t \n\tlist_for_each_entry(cur, &adapter->mac_list, list) {\n\t\tif (ether_addr_equal(addr, cur->mac_addr)) {\n\t\t\terr = qlcnic_sre_macaddr_change(adapter, cur->mac_addr,\n\t\t\t\t\t\t\t0, QLCNIC_MAC_DEL);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tlist_del(&cur->list);\n\t\t\tkfree(cur);\n\t\t\treturn err;\n\t\t}\n\t}\n\treturn err;\n}\n\nint qlcnic_nic_add_mac(struct qlcnic_adapter *adapter, const u8 *addr, u16 vlan,\n\t\t       enum qlcnic_mac_type mac_type)\n{\n\tstruct qlcnic_mac_vlan_list *cur;\n\n\t \n\tlist_for_each_entry(cur, &adapter->mac_list, list) {\n\t\tif (ether_addr_equal(addr, cur->mac_addr) &&\n\t\t    cur->vlan_id == vlan)\n\t\t\treturn 0;\n\t}\n\n\tcur = kzalloc(sizeof(*cur), GFP_ATOMIC);\n\tif (cur == NULL)\n\t\treturn -ENOMEM;\n\n\tmemcpy(cur->mac_addr, addr, ETH_ALEN);\n\n\tif (qlcnic_sre_macaddr_change(adapter,\n\t\t\t\tcur->mac_addr, vlan, QLCNIC_MAC_ADD)) {\n\t\tkfree(cur);\n\t\treturn -EIO;\n\t}\n\n\tcur->vlan_id = vlan;\n\tcur->mac_type = mac_type;\n\n\tlist_add_tail(&cur->list, &adapter->mac_list);\n\treturn 0;\n}\n\nvoid qlcnic_flush_mcast_mac(struct qlcnic_adapter *adapter)\n{\n\tstruct qlcnic_mac_vlan_list *cur;\n\tstruct list_head *head, *tmp;\n\n\tlist_for_each_safe(head, tmp, &adapter->mac_list) {\n\t\tcur = list_entry(head, struct qlcnic_mac_vlan_list, list);\n\t\tif (cur->mac_type != QLCNIC_MULTICAST_MAC)\n\t\t\tcontinue;\n\n\t\tqlcnic_sre_macaddr_change(adapter, cur->mac_addr,\n\t\t\t\t\t  cur->vlan_id, QLCNIC_MAC_DEL);\n\t\tlist_del(&cur->list);\n\t\tkfree(cur);\n\t}\n}\n\nstatic void __qlcnic_set_multi(struct net_device *netdev, u16 vlan)\n{\n\tstruct qlcnic_adapter *adapter = netdev_priv(netdev);\n\tstruct qlcnic_hardware_context *ahw = adapter->ahw;\n\tstruct netdev_hw_addr *ha;\n\tstatic const u8 bcast_addr[ETH_ALEN] = {\n\t\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff\n\t};\n\tu32 mode = VPORT_MISS_MODE_DROP;\n\n\tif (!test_bit(__QLCNIC_FW_ATTACHED, &adapter->state))\n\t\treturn;\n\n\tqlcnic_nic_add_mac(adapter, adapter->mac_addr, vlan,\n\t\t\t   QLCNIC_UNICAST_MAC);\n\tqlcnic_nic_add_mac(adapter, bcast_addr, vlan, QLCNIC_BROADCAST_MAC);\n\n\tif (netdev->flags & IFF_PROMISC) {\n\t\tif (!(adapter->flags & QLCNIC_PROMISC_DISABLED))\n\t\t\tmode = VPORT_MISS_MODE_ACCEPT_ALL;\n\t} else if ((netdev->flags & IFF_ALLMULTI) ||\n\t\t   (netdev_mc_count(netdev) > ahw->max_mc_count)) {\n\t\tmode = VPORT_MISS_MODE_ACCEPT_MULTI;\n\t} else if (!netdev_mc_empty(netdev)) {\n\t\tqlcnic_flush_mcast_mac(adapter);\n\t\tnetdev_for_each_mc_addr(ha, netdev)\n\t\t\tqlcnic_nic_add_mac(adapter, ha->addr, vlan,\n\t\t\t\t\t   QLCNIC_MULTICAST_MAC);\n\t}\n\n\t \n\tif (netdev_uc_count(netdev) > ahw->max_uc_count) {\n\t\tmode = VPORT_MISS_MODE_ACCEPT_ALL;\n\t} else if (!netdev_uc_empty(netdev)) {\n\t\tnetdev_for_each_uc_addr(ha, netdev)\n\t\t\tqlcnic_nic_add_mac(adapter, ha->addr, vlan,\n\t\t\t\t\t   QLCNIC_UNICAST_MAC);\n\t}\n\n\tif (mode == VPORT_MISS_MODE_ACCEPT_ALL &&\n\t    !adapter->fdb_mac_learn) {\n\t\tqlcnic_alloc_lb_filters_mem(adapter);\n\t\tadapter->drv_mac_learn = 1;\n\t\tif (adapter->flags & QLCNIC_ESWITCH_ENABLED)\n\t\t\tadapter->rx_mac_learn = true;\n\t} else {\n\t\tadapter->drv_mac_learn = 0;\n\t\tadapter->rx_mac_learn = false;\n\t}\n\n\tqlcnic_nic_set_promisc(adapter, mode);\n}\n\nvoid qlcnic_set_multi(struct net_device *netdev)\n{\n\tstruct qlcnic_adapter *adapter = netdev_priv(netdev);\n\n\tif (!test_bit(__QLCNIC_FW_ATTACHED, &adapter->state))\n\t\treturn;\n\n\tif (qlcnic_sriov_vf_check(adapter))\n\t\tqlcnic_sriov_vf_set_multi(netdev);\n\telse\n\t\t__qlcnic_set_multi(netdev, 0);\n}\n\nint qlcnic_82xx_nic_set_promisc(struct qlcnic_adapter *adapter, u32 mode)\n{\n\tstruct qlcnic_nic_req req;\n\tu64 word;\n\n\tmemset(&req, 0, sizeof(struct qlcnic_nic_req));\n\n\treq.qhdr = cpu_to_le64(QLCNIC_HOST_REQUEST << 23);\n\n\tword = QLCNIC_H2C_OPCODE_SET_MAC_RECEIVE_MODE |\n\t\t\t((u64)adapter->portnum << 16);\n\treq.req_hdr = cpu_to_le64(word);\n\n\treq.words[0] = cpu_to_le64(mode);\n\n\treturn qlcnic_send_cmd_descs(adapter,\n\t\t\t\t(struct cmd_desc_type0 *)&req, 1);\n}\n\nvoid qlcnic_82xx_free_mac_list(struct qlcnic_adapter *adapter)\n{\n\tstruct list_head *head = &adapter->mac_list;\n\tstruct qlcnic_mac_vlan_list *cur;\n\n\twhile (!list_empty(head)) {\n\t\tcur = list_entry(head->next, struct qlcnic_mac_vlan_list, list);\n\t\tqlcnic_sre_macaddr_change(adapter,\n\t\t\t\tcur->mac_addr, 0, QLCNIC_MAC_DEL);\n\t\tlist_del(&cur->list);\n\t\tkfree(cur);\n\t}\n}\n\nvoid qlcnic_prune_lb_filters(struct qlcnic_adapter *adapter)\n{\n\tstruct qlcnic_filter *tmp_fil;\n\tstruct hlist_node *n;\n\tstruct hlist_head *head;\n\tint i;\n\tunsigned long expires;\n\tu8 cmd;\n\n\tfor (i = 0; i < adapter->fhash.fbucket_size; i++) {\n\t\thead = &(adapter->fhash.fhead[i]);\n\t\thlist_for_each_entry_safe(tmp_fil, n, head, fnode) {\n\t\t\tcmd =  tmp_fil->vlan_id ? QLCNIC_MAC_VLAN_DEL :\n\t\t\t\t\t\t  QLCNIC_MAC_DEL;\n\t\t\texpires = tmp_fil->ftime + QLCNIC_FILTER_AGE * HZ;\n\t\t\tif (time_before(expires, jiffies)) {\n\t\t\t\tqlcnic_sre_macaddr_change(adapter,\n\t\t\t\t\t\t\t  tmp_fil->faddr,\n\t\t\t\t\t\t\t  tmp_fil->vlan_id,\n\t\t\t\t\t\t\t  cmd);\n\t\t\t\tspin_lock_bh(&adapter->mac_learn_lock);\n\t\t\t\tadapter->fhash.fnum--;\n\t\t\t\thlist_del(&tmp_fil->fnode);\n\t\t\t\tspin_unlock_bh(&adapter->mac_learn_lock);\n\t\t\t\tkfree(tmp_fil);\n\t\t\t}\n\t\t}\n\t}\n\tfor (i = 0; i < adapter->rx_fhash.fbucket_size; i++) {\n\t\thead = &(adapter->rx_fhash.fhead[i]);\n\n\t\thlist_for_each_entry_safe(tmp_fil, n, head, fnode)\n\t\t{\n\t\t\texpires = tmp_fil->ftime + QLCNIC_FILTER_AGE * HZ;\n\t\t\tif (time_before(expires, jiffies)) {\n\t\t\t\tspin_lock_bh(&adapter->rx_mac_learn_lock);\n\t\t\t\tadapter->rx_fhash.fnum--;\n\t\t\t\thlist_del(&tmp_fil->fnode);\n\t\t\t\tspin_unlock_bh(&adapter->rx_mac_learn_lock);\n\t\t\t\tkfree(tmp_fil);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid qlcnic_delete_lb_filters(struct qlcnic_adapter *adapter)\n{\n\tstruct qlcnic_filter *tmp_fil;\n\tstruct hlist_node *n;\n\tstruct hlist_head *head;\n\tint i;\n\tu8 cmd;\n\n\tfor (i = 0; i < adapter->fhash.fbucket_size; i++) {\n\t\thead = &(adapter->fhash.fhead[i]);\n\t\thlist_for_each_entry_safe(tmp_fil, n, head, fnode) {\n\t\t\tcmd =  tmp_fil->vlan_id ? QLCNIC_MAC_VLAN_DEL :\n\t\t\t\t\t\t  QLCNIC_MAC_DEL;\n\t\t\tqlcnic_sre_macaddr_change(adapter,\n\t\t\t\t\t\t  tmp_fil->faddr,\n\t\t\t\t\t\t  tmp_fil->vlan_id,\n\t\t\t\t\t\t  cmd);\n\t\t\tspin_lock_bh(&adapter->mac_learn_lock);\n\t\t\tadapter->fhash.fnum--;\n\t\t\thlist_del(&tmp_fil->fnode);\n\t\t\tspin_unlock_bh(&adapter->mac_learn_lock);\n\t\t\tkfree(tmp_fil);\n\t\t}\n\t}\n}\n\nstatic int qlcnic_set_fw_loopback(struct qlcnic_adapter *adapter, u8 flag)\n{\n\tstruct qlcnic_nic_req req;\n\tint rv;\n\n\tmemset(&req, 0, sizeof(struct qlcnic_nic_req));\n\n\treq.qhdr = cpu_to_le64(QLCNIC_HOST_REQUEST << 23);\n\treq.req_hdr = cpu_to_le64(QLCNIC_H2C_OPCODE_CONFIG_LOOPBACK |\n\t\t((u64) adapter->portnum << 16) | ((u64) 0x1 << 32));\n\n\treq.words[0] = cpu_to_le64(flag);\n\n\trv = qlcnic_send_cmd_descs(adapter, (struct cmd_desc_type0 *)&req, 1);\n\tif (rv != 0)\n\t\tdev_err(&adapter->pdev->dev, \"%sting loopback mode failed\\n\",\n\t\t\t\tflag ? \"Set\" : \"Reset\");\n\treturn rv;\n}\n\nint qlcnic_82xx_set_lb_mode(struct qlcnic_adapter *adapter, u8 mode)\n{\n\tif (qlcnic_set_fw_loopback(adapter, mode))\n\t\treturn -EIO;\n\n\tif (qlcnic_nic_set_promisc(adapter,\n\t\t\t\t   VPORT_MISS_MODE_ACCEPT_ALL)) {\n\t\tqlcnic_set_fw_loopback(adapter, 0);\n\t\treturn -EIO;\n\t}\n\n\tmsleep(1000);\n\treturn 0;\n}\n\nint qlcnic_82xx_clear_lb_mode(struct qlcnic_adapter *adapter, u8 mode)\n{\n\tstruct net_device *netdev = adapter->netdev;\n\n\tmode = VPORT_MISS_MODE_DROP;\n\tqlcnic_set_fw_loopback(adapter, 0);\n\n\tif (netdev->flags & IFF_PROMISC)\n\t\tmode = VPORT_MISS_MODE_ACCEPT_ALL;\n\telse if (netdev->flags & IFF_ALLMULTI)\n\t\tmode = VPORT_MISS_MODE_ACCEPT_MULTI;\n\n\tqlcnic_nic_set_promisc(adapter, mode);\n\tmsleep(1000);\n\treturn 0;\n}\n\nint qlcnic_82xx_read_phys_port_id(struct qlcnic_adapter *adapter)\n{\n\tu8 mac[ETH_ALEN];\n\tint ret;\n\n\tret = qlcnic_get_mac_address(adapter, mac,\n\t\t\t\t     adapter->ahw->physical_port);\n\tif (ret)\n\t\treturn ret;\n\n\tmemcpy(adapter->ahw->phys_port_id, mac, ETH_ALEN);\n\tadapter->flags |= QLCNIC_HAS_PHYS_PORT_ID;\n\n\treturn 0;\n}\n\nint qlcnic_82xx_set_rx_coalesce(struct qlcnic_adapter *adapter)\n{\n\tstruct qlcnic_nic_req req;\n\tint rv;\n\n\tmemset(&req, 0, sizeof(struct qlcnic_nic_req));\n\n\treq.qhdr = cpu_to_le64(QLCNIC_HOST_REQUEST << 23);\n\n\treq.req_hdr = cpu_to_le64(QLCNIC_CONFIG_INTR_COALESCE |\n\t\t((u64) adapter->portnum << 16));\n\n\treq.words[0] = cpu_to_le64(((u64) adapter->ahw->coal.flag) << 32);\n\treq.words[2] = cpu_to_le64(adapter->ahw->coal.rx_packets |\n\t\t\t((u64) adapter->ahw->coal.rx_time_us) << 16);\n\treq.words[5] = cpu_to_le64(adapter->ahw->coal.timer_out |\n\t\t\t((u64) adapter->ahw->coal.type) << 32 |\n\t\t\t((u64) adapter->ahw->coal.sts_ring_mask) << 40);\n\trv = qlcnic_send_cmd_descs(adapter, (struct cmd_desc_type0 *)&req, 1);\n\tif (rv != 0)\n\t\tdev_err(&adapter->netdev->dev,\n\t\t\t\"Could not send interrupt coalescing parameters\\n\");\n\n\treturn rv;\n}\n\n \nint qlcnic_82xx_config_intr_coalesce(struct qlcnic_adapter *adapter,\n\t\t\t\t     struct ethtool_coalesce *ethcoal)\n{\n\tstruct qlcnic_nic_intr_coalesce *coal = &adapter->ahw->coal;\n\tint rv;\n\n\tcoal->flag = QLCNIC_INTR_DEFAULT;\n\tcoal->rx_time_us = ethcoal->rx_coalesce_usecs;\n\tcoal->rx_packets = ethcoal->rx_max_coalesced_frames;\n\n\trv = qlcnic_82xx_set_rx_coalesce(adapter);\n\n\tif (rv)\n\t\tnetdev_err(adapter->netdev,\n\t\t\t   \"Failed to set Rx coalescing parameters\\n\");\n\n\treturn rv;\n}\n\n#define QLCNIC_ENABLE_IPV4_LRO\t\tBIT_0\n#define QLCNIC_ENABLE_IPV6_LRO\t\t(BIT_1 | BIT_9)\n\nint qlcnic_82xx_config_hw_lro(struct qlcnic_adapter *adapter, int enable)\n{\n\tstruct qlcnic_nic_req req;\n\tu64 word;\n\tint rv;\n\n\tif (!test_bit(__QLCNIC_FW_ATTACHED, &adapter->state))\n\t\treturn 0;\n\n\tmemset(&req, 0, sizeof(struct qlcnic_nic_req));\n\n\treq.qhdr = cpu_to_le64(QLCNIC_HOST_REQUEST << 23);\n\n\tword = QLCNIC_H2C_OPCODE_CONFIG_HW_LRO | ((u64)adapter->portnum << 16);\n\treq.req_hdr = cpu_to_le64(word);\n\n\tword = 0;\n\tif (enable) {\n\t\tword = QLCNIC_ENABLE_IPV4_LRO;\n\t\tif (adapter->ahw->extra_capability[0] &\n\t\t    QLCNIC_FW_CAP2_HW_LRO_IPV6)\n\t\t\tword |= QLCNIC_ENABLE_IPV6_LRO;\n\t}\n\n\treq.words[0] = cpu_to_le64(word);\n\n\trv = qlcnic_send_cmd_descs(adapter, (struct cmd_desc_type0 *)&req, 1);\n\tif (rv != 0)\n\t\tdev_err(&adapter->netdev->dev,\n\t\t\t\"Could not send configure hw lro request\\n\");\n\n\treturn rv;\n}\n\nint qlcnic_config_bridged_mode(struct qlcnic_adapter *adapter, u32 enable)\n{\n\tstruct qlcnic_nic_req req;\n\tu64 word;\n\tint rv;\n\n\tif (!!(adapter->flags & QLCNIC_BRIDGE_ENABLED) == enable)\n\t\treturn 0;\n\n\tmemset(&req, 0, sizeof(struct qlcnic_nic_req));\n\n\treq.qhdr = cpu_to_le64(QLCNIC_HOST_REQUEST << 23);\n\n\tword = QLCNIC_H2C_OPCODE_CONFIG_BRIDGING |\n\t\t((u64)adapter->portnum << 16);\n\treq.req_hdr = cpu_to_le64(word);\n\n\treq.words[0] = cpu_to_le64(enable);\n\n\trv = qlcnic_send_cmd_descs(adapter, (struct cmd_desc_type0 *)&req, 1);\n\tif (rv != 0)\n\t\tdev_err(&adapter->netdev->dev,\n\t\t\t\"Could not send configure bridge mode request\\n\");\n\n\tadapter->flags ^= QLCNIC_BRIDGE_ENABLED;\n\n\treturn rv;\n}\n\n\n#define QLCNIC_RSS_HASHTYPE_IP_TCP\t0x3\n#define QLCNIC_ENABLE_TYPE_C_RSS\tBIT_10\n#define QLCNIC_RSS_FEATURE_FLAG\t(1ULL << 63)\n#define QLCNIC_RSS_IND_TABLE_MASK\t0x7ULL\n\nint qlcnic_82xx_config_rss(struct qlcnic_adapter *adapter, int enable)\n{\n\tstruct qlcnic_nic_req req;\n\tu64 word;\n\tint i, rv;\n\n\tstatic const u64 key[] = {\n\t\t0xbeac01fa6a42b73bULL, 0x8030f20c77cb2da3ULL,\n\t\t0xae7b30b4d0ca2bcbULL, 0x43a38fb04167253dULL,\n\t\t0x255b0ec26d5a56daULL\n\t};\n\n\tmemset(&req, 0, sizeof(struct qlcnic_nic_req));\n\treq.qhdr = cpu_to_le64(QLCNIC_HOST_REQUEST << 23);\n\n\tword = QLCNIC_H2C_OPCODE_CONFIG_RSS | ((u64)adapter->portnum << 16);\n\treq.req_hdr = cpu_to_le64(word);\n\n\t \n\tword =  ((u64)(QLCNIC_RSS_HASHTYPE_IP_TCP & 0x3) << 4) |\n\t\t((u64)(QLCNIC_RSS_HASHTYPE_IP_TCP & 0x3) << 6) |\n\t\t((u64)(enable & 0x1) << 8) |\n\t\t((u64)QLCNIC_RSS_IND_TABLE_MASK << 48) |\n\t\t(u64)QLCNIC_ENABLE_TYPE_C_RSS |\n\t\t(u64)QLCNIC_RSS_FEATURE_FLAG;\n\n\treq.words[0] = cpu_to_le64(word);\n\tfor (i = 0; i < 5; i++)\n\t\treq.words[i+1] = cpu_to_le64(key[i]);\n\n\trv = qlcnic_send_cmd_descs(adapter, (struct cmd_desc_type0 *)&req, 1);\n\tif (rv != 0)\n\t\tdev_err(&adapter->netdev->dev, \"could not configure RSS\\n\");\n\n\treturn rv;\n}\n\nvoid qlcnic_82xx_config_ipaddr(struct qlcnic_adapter *adapter,\n\t\t\t       __be32 ip, int cmd)\n{\n\tstruct qlcnic_nic_req req;\n\tstruct qlcnic_ipaddr *ipa;\n\tu64 word;\n\tint rv;\n\n\tmemset(&req, 0, sizeof(struct qlcnic_nic_req));\n\treq.qhdr = cpu_to_le64(QLCNIC_HOST_REQUEST << 23);\n\n\tword = QLCNIC_H2C_OPCODE_CONFIG_IPADDR | ((u64)adapter->portnum << 16);\n\treq.req_hdr = cpu_to_le64(word);\n\n\treq.words[0] = cpu_to_le64(cmd);\n\tipa = (struct qlcnic_ipaddr *)&req.words[1];\n\tipa->ipv4 = ip;\n\n\trv = qlcnic_send_cmd_descs(adapter, (struct cmd_desc_type0 *)&req, 1);\n\tif (rv != 0)\n\t\tdev_err(&adapter->netdev->dev,\n\t\t\t\t\"could not notify %s IP 0x%x request\\n\",\n\t\t\t\t(cmd == QLCNIC_IP_UP) ? \"Add\" : \"Remove\", ip);\n}\n\nint qlcnic_82xx_linkevent_request(struct qlcnic_adapter *adapter, int enable)\n{\n\tstruct qlcnic_nic_req req;\n\tu64 word;\n\tint rv;\n\tmemset(&req, 0, sizeof(struct qlcnic_nic_req));\n\treq.qhdr = cpu_to_le64(QLCNIC_HOST_REQUEST << 23);\n\n\tword = QLCNIC_H2C_OPCODE_GET_LINKEVENT | ((u64)adapter->portnum << 16);\n\treq.req_hdr = cpu_to_le64(word);\n\treq.words[0] = cpu_to_le64(enable | (enable << 8));\n\trv = qlcnic_send_cmd_descs(adapter, (struct cmd_desc_type0 *)&req, 1);\n\tif (rv != 0)\n\t\tdev_err(&adapter->netdev->dev,\n\t\t\t\t\"could not configure link notification\\n\");\n\n\treturn rv;\n}\n\nstatic int qlcnic_send_lro_cleanup(struct qlcnic_adapter *adapter)\n{\n\tstruct qlcnic_nic_req req;\n\tu64 word;\n\tint rv;\n\n\tif (!test_bit(__QLCNIC_FW_ATTACHED, &adapter->state))\n\t\treturn 0;\n\n\tmemset(&req, 0, sizeof(struct qlcnic_nic_req));\n\treq.qhdr = cpu_to_le64(QLCNIC_HOST_REQUEST << 23);\n\n\tword = QLCNIC_H2C_OPCODE_LRO_REQUEST |\n\t\t((u64)adapter->portnum << 16) |\n\t\t((u64)QLCNIC_LRO_REQUEST_CLEANUP << 56) ;\n\n\treq.req_hdr = cpu_to_le64(word);\n\n\trv = qlcnic_send_cmd_descs(adapter, (struct cmd_desc_type0 *)&req, 1);\n\tif (rv != 0)\n\t\tdev_err(&adapter->netdev->dev,\n\t\t\t\t \"could not cleanup lro flows\\n\");\n\n\treturn rv;\n}\n\n \n\nint qlcnic_change_mtu(struct net_device *netdev, int mtu)\n{\n\tstruct qlcnic_adapter *adapter = netdev_priv(netdev);\n\tint rc = 0;\n\n\trc = qlcnic_fw_cmd_set_mtu(adapter, mtu);\n\n\tif (!rc)\n\t\tnetdev->mtu = mtu;\n\n\treturn rc;\n}\n\nstatic netdev_features_t qlcnic_process_flags(struct qlcnic_adapter *adapter,\n\t\t\t\t\t      netdev_features_t features)\n{\n\tu32 offload_flags = adapter->offload_flags;\n\n\tif (offload_flags & BIT_0) {\n\t\tfeatures |= NETIF_F_RXCSUM | NETIF_F_IP_CSUM |\n\t\t\t    NETIF_F_IPV6_CSUM;\n\t\tadapter->rx_csum = 1;\n\t\tif (QLCNIC_IS_TSO_CAPABLE(adapter)) {\n\t\t\tif (!(offload_flags & BIT_1))\n\t\t\t\tfeatures &= ~NETIF_F_TSO;\n\t\t\telse\n\t\t\t\tfeatures |= NETIF_F_TSO;\n\n\t\t\tif (!(offload_flags & BIT_2))\n\t\t\t\tfeatures &= ~NETIF_F_TSO6;\n\t\t\telse\n\t\t\t\tfeatures |= NETIF_F_TSO6;\n\t\t}\n\t} else {\n\t\tfeatures &= ~(NETIF_F_RXCSUM |\n\t\t\t      NETIF_F_IP_CSUM |\n\t\t\t      NETIF_F_IPV6_CSUM);\n\n\t\tif (QLCNIC_IS_TSO_CAPABLE(adapter))\n\t\t\tfeatures &= ~(NETIF_F_TSO | NETIF_F_TSO6);\n\t\tadapter->rx_csum = 0;\n\t}\n\n\treturn features;\n}\n\nnetdev_features_t qlcnic_fix_features(struct net_device *netdev,\n\tnetdev_features_t features)\n{\n\tstruct qlcnic_adapter *adapter = netdev_priv(netdev);\n\tnetdev_features_t changed;\n\n\tif (qlcnic_82xx_check(adapter) &&\n\t    (adapter->flags & QLCNIC_ESWITCH_ENABLED)) {\n\t\tif (adapter->flags & QLCNIC_APP_CHANGED_FLAGS) {\n\t\t\tfeatures = qlcnic_process_flags(adapter, features);\n\t\t} else {\n\t\t\tchanged = features ^ netdev->features;\n\t\t\tfeatures ^= changed & (NETIF_F_RXCSUM |\n\t\t\t\t\t       NETIF_F_IP_CSUM |\n\t\t\t\t\t       NETIF_F_IPV6_CSUM |\n\t\t\t\t\t       NETIF_F_TSO |\n\t\t\t\t\t       NETIF_F_TSO6);\n\t\t}\n\t}\n\n\tif (!(features & NETIF_F_RXCSUM))\n\t\tfeatures &= ~NETIF_F_LRO;\n\n\treturn features;\n}\n\n\nint qlcnic_set_features(struct net_device *netdev, netdev_features_t features)\n{\n\tstruct qlcnic_adapter *adapter = netdev_priv(netdev);\n\tnetdev_features_t changed = netdev->features ^ features;\n\tint hw_lro = (features & NETIF_F_LRO) ? QLCNIC_LRO_ENABLED : 0;\n\n\tif (!(changed & NETIF_F_LRO))\n\t\treturn 0;\n\n\tnetdev->features ^= NETIF_F_LRO;\n\n\tif (qlcnic_config_hw_lro(adapter, hw_lro))\n\t\treturn -EIO;\n\n\tif (!hw_lro && qlcnic_82xx_check(adapter)) {\n\t\tif (qlcnic_send_lro_cleanup(adapter))\n\t\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\n \n  \nstatic int qlcnic_pci_get_crb_addr_2M(struct qlcnic_hardware_context *ahw,\n\t\t\t\t      ulong off, void __iomem **addr)\n{\n\tconst struct crb_128M_2M_sub_block_map *m;\n\n\tif ((off >= QLCNIC_CRB_MAX) || (off < QLCNIC_PCI_CRBSPACE))\n\t\treturn -EINVAL;\n\n\toff -= QLCNIC_PCI_CRBSPACE;\n\n\t \n\tm = &crb_128M_2M_map[CRB_BLK(off)].sub_block[CRB_SUBBLK(off)];\n\n\tif (m->valid && (m->start_128M <= off) && (m->end_128M > off)) {\n\t\t*addr = ahw->pci_base0 + m->start_2M +\n\t\t\t(off - m->start_128M);\n\t\treturn 0;\n\t}\n\n\t \n\t*addr = ahw->pci_base0 + CRB_INDIRECT_2M + (off & MASK(16));\n\treturn 1;\n}\n\n \nstatic int\nqlcnic_pci_set_crbwindow_2M(struct qlcnic_adapter *adapter, ulong off)\n{\n\tu32 window;\n\tvoid __iomem *addr = adapter->ahw->pci_base0 + CRB_WINDOW_2M;\n\n\toff -= QLCNIC_PCI_CRBSPACE;\n\n\twindow = CRB_HI(off);\n\tif (window == 0) {\n\t\tdev_err(&adapter->pdev->dev, \"Invalid offset 0x%lx\\n\", off);\n\t\treturn -EIO;\n\t}\n\n\twritel(window, addr);\n\tif (readl(addr) != window) {\n\t\tif (printk_ratelimit())\n\t\t\tdev_warn(&adapter->pdev->dev,\n\t\t\t\t\"failed to set CRB window to %d off 0x%lx\\n\",\n\t\t\t\twindow, off);\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}\n\nint qlcnic_82xx_hw_write_wx_2M(struct qlcnic_adapter *adapter, ulong off,\n\t\t\t       u32 data)\n{\n\tunsigned long flags;\n\tint rv;\n\tvoid __iomem *addr = NULL;\n\n\trv = qlcnic_pci_get_crb_addr_2M(adapter->ahw, off, &addr);\n\n\tif (rv == 0) {\n\t\twritel(data, addr);\n\t\treturn 0;\n\t}\n\n\tif (rv > 0) {\n\t\t \n\t\twrite_lock_irqsave(&adapter->ahw->crb_lock, flags);\n\t\tcrb_win_lock(adapter);\n\t\trv = qlcnic_pci_set_crbwindow_2M(adapter, off);\n\t\tif (!rv)\n\t\t\twritel(data, addr);\n\t\tcrb_win_unlock(adapter);\n\t\twrite_unlock_irqrestore(&adapter->ahw->crb_lock, flags);\n\t\treturn rv;\n\t}\n\n\tdev_err(&adapter->pdev->dev,\n\t\t\t\"%s: invalid offset: 0x%016lx\\n\", __func__, off);\n\tdump_stack();\n\treturn -EIO;\n}\n\nint qlcnic_82xx_hw_read_wx_2M(struct qlcnic_adapter *adapter, ulong off,\n\t\t\t      int *err)\n{\n\tunsigned long flags;\n\tint rv;\n\tu32 data = -1;\n\tvoid __iomem *addr = NULL;\n\n\trv = qlcnic_pci_get_crb_addr_2M(adapter->ahw, off, &addr);\n\n\tif (rv == 0)\n\t\treturn readl(addr);\n\n\tif (rv > 0) {\n\t\t \n\t\twrite_lock_irqsave(&adapter->ahw->crb_lock, flags);\n\t\tcrb_win_lock(adapter);\n\t\tif (!qlcnic_pci_set_crbwindow_2M(adapter, off))\n\t\t\tdata = readl(addr);\n\t\tcrb_win_unlock(adapter);\n\t\twrite_unlock_irqrestore(&adapter->ahw->crb_lock, flags);\n\t\treturn data;\n\t}\n\n\tdev_err(&adapter->pdev->dev,\n\t\t\t\"%s: invalid offset: 0x%016lx\\n\", __func__, off);\n\tdump_stack();\n\treturn -1;\n}\n\nvoid __iomem *qlcnic_get_ioaddr(struct qlcnic_hardware_context *ahw,\n\t\t\t\tu32 offset)\n{\n\tvoid __iomem *addr = NULL;\n\n\tWARN_ON(qlcnic_pci_get_crb_addr_2M(ahw, offset, &addr));\n\n\treturn addr;\n}\n\nstatic int qlcnic_pci_mem_access_direct(struct qlcnic_adapter *adapter,\n\t\t\t\t\tu32 window, u64 off, u64 *data, int op)\n{\n\tvoid __iomem *addr;\n\tu32 start;\n\n\tmutex_lock(&adapter->ahw->mem_lock);\n\n\twritel(window, adapter->ahw->ocm_win_crb);\n\t \n\treadl(adapter->ahw->ocm_win_crb);\n\tstart = QLCNIC_PCI_OCM0_2M + off;\n\n\taddr = adapter->ahw->pci_base0 + start;\n\n\tif (op == 0)\t \n\t\t*data = readq(addr);\n\telse\t\t \n\t\twriteq(*data, addr);\n\n\t \n\twritel(0, adapter->ahw->ocm_win_crb);\n\treadl(adapter->ahw->ocm_win_crb);\n\n\tmutex_unlock(&adapter->ahw->mem_lock);\n\treturn 0;\n}\n\nstatic void\nqlcnic_pci_camqm_read_2M(struct qlcnic_adapter *adapter, u64 off, u64 *data)\n{\n\tvoid __iomem *addr = adapter->ahw->pci_base0 +\n\t\tQLCNIC_PCI_CAMQM_2M_BASE + (off - QLCNIC_PCI_CAMQM);\n\n\tmutex_lock(&adapter->ahw->mem_lock);\n\t*data = readq(addr);\n\tmutex_unlock(&adapter->ahw->mem_lock);\n}\n\nstatic void\nqlcnic_pci_camqm_write_2M(struct qlcnic_adapter *adapter, u64 off, u64 data)\n{\n\tvoid __iomem *addr = adapter->ahw->pci_base0 +\n\t\tQLCNIC_PCI_CAMQM_2M_BASE + (off - QLCNIC_PCI_CAMQM);\n\n\tmutex_lock(&adapter->ahw->mem_lock);\n\twriteq(data, addr);\n\tmutex_unlock(&adapter->ahw->mem_lock);\n}\n\n\n\n \nstatic void qlcnic_set_ms_controls(struct qlcnic_adapter *adapter, u64 off,\n\t\t\t\t   struct qlcnic_ms_reg_ctrl *ms)\n{\n\tms->control = QLCNIC_MS_CTRL;\n\tms->low = QLCNIC_MS_ADDR_LO;\n\tms->hi = QLCNIC_MS_ADDR_HI;\n\tif (off & 0xf) {\n\t\tms->wd[0] = QLCNIC_MS_WRTDATA_LO;\n\t\tms->rd[0] = QLCNIC_MS_RDDATA_LO;\n\t\tms->wd[1] = QLCNIC_MS_WRTDATA_HI;\n\t\tms->rd[1] = QLCNIC_MS_RDDATA_HI;\n\t\tms->wd[2] = QLCNIC_MS_WRTDATA_ULO;\n\t\tms->wd[3] = QLCNIC_MS_WRTDATA_UHI;\n\t\tms->rd[2] = QLCNIC_MS_RDDATA_ULO;\n\t\tms->rd[3] = QLCNIC_MS_RDDATA_UHI;\n\t} else {\n\t\tms->wd[0] = QLCNIC_MS_WRTDATA_ULO;\n\t\tms->rd[0] = QLCNIC_MS_RDDATA_ULO;\n\t\tms->wd[1] = QLCNIC_MS_WRTDATA_UHI;\n\t\tms->rd[1] = QLCNIC_MS_RDDATA_UHI;\n\t\tms->wd[2] = QLCNIC_MS_WRTDATA_LO;\n\t\tms->wd[3] = QLCNIC_MS_WRTDATA_HI;\n\t\tms->rd[2] = QLCNIC_MS_RDDATA_LO;\n\t\tms->rd[3] = QLCNIC_MS_RDDATA_HI;\n\t}\n\n\tms->ocm_window = OCM_WIN_P3P(off);\n\tms->off = GET_MEM_OFFS_2M(off);\n}\n\nint qlcnic_pci_mem_write_2M(struct qlcnic_adapter *adapter, u64 off, u64 data)\n{\n\tint j, ret = 0;\n\tu32 temp, off8;\n\tstruct qlcnic_ms_reg_ctrl ms;\n\n\t \n\tif (off & 7)\n\t\treturn -EIO;\n\n\tmemset(&ms, 0, sizeof(struct qlcnic_ms_reg_ctrl));\n\tif (!(ADDR_IN_RANGE(off, QLCNIC_ADDR_QDR_NET,\n\t\t\t    QLCNIC_ADDR_QDR_NET_MAX) ||\n\t      ADDR_IN_RANGE(off, QLCNIC_ADDR_DDR_NET,\n\t\t\t    QLCNIC_ADDR_DDR_NET_MAX)))\n\t\treturn -EIO;\n\n\tqlcnic_set_ms_controls(adapter, off, &ms);\n\n\tif (ADDR_IN_RANGE(off, QLCNIC_ADDR_OCM0, QLCNIC_ADDR_OCM0_MAX))\n\t\treturn qlcnic_pci_mem_access_direct(adapter, ms.ocm_window,\n\t\t\t\t\t\t    ms.off, &data, 1);\n\n\toff8 = off & ~0xf;\n\n\tmutex_lock(&adapter->ahw->mem_lock);\n\n\tqlcnic_ind_wr(adapter, ms.low, off8);\n\tqlcnic_ind_wr(adapter, ms.hi, 0);\n\n\tqlcnic_ind_wr(adapter, ms.control, TA_CTL_ENABLE);\n\tqlcnic_ind_wr(adapter, ms.control, QLCNIC_TA_START_ENABLE);\n\n\tfor (j = 0; j < MAX_CTL_CHECK; j++) {\n\t\ttemp = qlcnic_ind_rd(adapter, ms.control);\n\t\tif ((temp & TA_CTL_BUSY) == 0)\n\t\t\tbreak;\n\t}\n\n\tif (j >= MAX_CTL_CHECK) {\n\t\tret = -EIO;\n\t\tgoto done;\n\t}\n\n\t \n\tqlcnic_ind_wr(adapter, ms.wd[0], qlcnic_ind_rd(adapter, ms.rd[0]));\n\tqlcnic_ind_wr(adapter, ms.wd[1], qlcnic_ind_rd(adapter, ms.rd[1]));\n\t \n\tqlcnic_ind_wr(adapter, ms.wd[2], data & 0xffffffff);\n\tqlcnic_ind_wr(adapter, ms.wd[3], (data >> 32) & 0xffffffff);\n\n\tqlcnic_ind_wr(adapter, ms.control, QLCNIC_TA_WRITE_ENABLE);\n\tqlcnic_ind_wr(adapter, ms.control, QLCNIC_TA_WRITE_START);\n\n\tfor (j = 0; j < MAX_CTL_CHECK; j++) {\n\t\ttemp = qlcnic_ind_rd(adapter, ms.control);\n\t\tif ((temp & TA_CTL_BUSY) == 0)\n\t\t\tbreak;\n\t}\n\n\tif (j >= MAX_CTL_CHECK) {\n\t\tif (printk_ratelimit())\n\t\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\t\t\"failed to write through agent\\n\");\n\t\tret = -EIO;\n\t} else\n\t\tret = 0;\n\ndone:\n\tmutex_unlock(&adapter->ahw->mem_lock);\n\n\treturn ret;\n}\n\nint qlcnic_pci_mem_read_2M(struct qlcnic_adapter *adapter, u64 off, u64 *data)\n{\n\tint j, ret;\n\tu32 temp, off8;\n\tu64 val;\n\tstruct qlcnic_ms_reg_ctrl ms;\n\n\t \n\tif (off & 7)\n\t\treturn -EIO;\n\tif (!(ADDR_IN_RANGE(off, QLCNIC_ADDR_QDR_NET,\n\t\t\t    QLCNIC_ADDR_QDR_NET_MAX) ||\n\t      ADDR_IN_RANGE(off, QLCNIC_ADDR_DDR_NET,\n\t\t\t    QLCNIC_ADDR_DDR_NET_MAX)))\n\t\treturn -EIO;\n\n\tmemset(&ms, 0, sizeof(struct qlcnic_ms_reg_ctrl));\n\tqlcnic_set_ms_controls(adapter, off, &ms);\n\n\tif (ADDR_IN_RANGE(off, QLCNIC_ADDR_OCM0, QLCNIC_ADDR_OCM0_MAX))\n\t\treturn qlcnic_pci_mem_access_direct(adapter, ms.ocm_window,\n\t\t\t\t\t\t    ms.off, data, 0);\n\n\tmutex_lock(&adapter->ahw->mem_lock);\n\n\toff8 = off & ~0xf;\n\n\tqlcnic_ind_wr(adapter, ms.low, off8);\n\tqlcnic_ind_wr(adapter, ms.hi, 0);\n\n\tqlcnic_ind_wr(adapter, ms.control, TA_CTL_ENABLE);\n\tqlcnic_ind_wr(adapter, ms.control, QLCNIC_TA_START_ENABLE);\n\n\tfor (j = 0; j < MAX_CTL_CHECK; j++) {\n\t\ttemp = qlcnic_ind_rd(adapter, ms.control);\n\t\tif ((temp & TA_CTL_BUSY) == 0)\n\t\t\tbreak;\n\t}\n\n\tif (j >= MAX_CTL_CHECK) {\n\t\tif (printk_ratelimit())\n\t\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\t\t\"failed to read through agent\\n\");\n\t\tret = -EIO;\n\t} else {\n\n\t\ttemp = qlcnic_ind_rd(adapter, ms.rd[3]);\n\t\tval = (u64)temp << 32;\n\t\tval |= qlcnic_ind_rd(adapter, ms.rd[2]);\n\t\t*data = val;\n\t\tret = 0;\n\t}\n\n\tmutex_unlock(&adapter->ahw->mem_lock);\n\n\treturn ret;\n}\n\nint qlcnic_82xx_get_board_info(struct qlcnic_adapter *adapter)\n{\n\tint offset, board_type, magic, err = 0;\n\tstruct pci_dev *pdev = adapter->pdev;\n\n\toffset = QLCNIC_FW_MAGIC_OFFSET;\n\tif (qlcnic_rom_fast_read(adapter, offset, &magic))\n\t\treturn -EIO;\n\n\tif (magic != QLCNIC_BDINFO_MAGIC) {\n\t\tdev_err(&pdev->dev, \"invalid board config, magic=%08x\\n\",\n\t\t\tmagic);\n\t\treturn -EIO;\n\t}\n\n\toffset = QLCNIC_BRDTYPE_OFFSET;\n\tif (qlcnic_rom_fast_read(adapter, offset, &board_type))\n\t\treturn -EIO;\n\n\tadapter->ahw->board_type = board_type;\n\n\tif (board_type == QLCNIC_BRDTYPE_P3P_4_GB_MM) {\n\t\tu32 gpio = QLCRD32(adapter, QLCNIC_ROMUSB_GLB_PAD_GPIO_I, &err);\n\t\tif (err == -EIO)\n\t\t\treturn err;\n\t\tif ((gpio & 0x8000) == 0)\n\t\t\tboard_type = QLCNIC_BRDTYPE_P3P_10G_TP;\n\t}\n\n\tswitch (board_type) {\n\tcase QLCNIC_BRDTYPE_P3P_HMEZ:\n\tcase QLCNIC_BRDTYPE_P3P_XG_LOM:\n\tcase QLCNIC_BRDTYPE_P3P_10G_CX4:\n\tcase QLCNIC_BRDTYPE_P3P_10G_CX4_LP:\n\tcase QLCNIC_BRDTYPE_P3P_IMEZ:\n\tcase QLCNIC_BRDTYPE_P3P_10G_SFP_PLUS:\n\tcase QLCNIC_BRDTYPE_P3P_10G_SFP_CT:\n\tcase QLCNIC_BRDTYPE_P3P_10G_SFP_QT:\n\tcase QLCNIC_BRDTYPE_P3P_10G_XFP:\n\tcase QLCNIC_BRDTYPE_P3P_10000_BASE_T:\n\t\tadapter->ahw->port_type = QLCNIC_XGBE;\n\t\tbreak;\n\tcase QLCNIC_BRDTYPE_P3P_REF_QG:\n\tcase QLCNIC_BRDTYPE_P3P_4_GB:\n\tcase QLCNIC_BRDTYPE_P3P_4_GB_MM:\n\t\tadapter->ahw->port_type = QLCNIC_GBE;\n\t\tbreak;\n\tcase QLCNIC_BRDTYPE_P3P_10G_TP:\n\t\tadapter->ahw->port_type = (adapter->portnum < 2) ?\n\t\t\tQLCNIC_XGBE : QLCNIC_GBE;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&pdev->dev, \"unknown board type %x\\n\", board_type);\n\t\tadapter->ahw->port_type = QLCNIC_XGBE;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nqlcnic_wol_supported(struct qlcnic_adapter *adapter)\n{\n\tu32 wol_cfg;\n\tint err = 0;\n\n\twol_cfg = QLCRD32(adapter, QLCNIC_WOL_CONFIG_NV, &err);\n\tif (wol_cfg & (1UL << adapter->portnum)) {\n\t\twol_cfg = QLCRD32(adapter, QLCNIC_WOL_CONFIG, &err);\n\t\tif (err == -EIO)\n\t\t\treturn err;\n\t\tif (wol_cfg & (1 << adapter->portnum))\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nint qlcnic_82xx_config_led(struct qlcnic_adapter *adapter, u32 state, u32 rate)\n{\n\tstruct qlcnic_nic_req   req;\n\tint rv;\n\tu64 word;\n\n\tmemset(&req, 0, sizeof(struct qlcnic_nic_req));\n\treq.qhdr = cpu_to_le64(QLCNIC_HOST_REQUEST << 23);\n\n\tword = QLCNIC_H2C_OPCODE_CONFIG_LED | ((u64)adapter->portnum << 16);\n\treq.req_hdr = cpu_to_le64(word);\n\n\treq.words[0] = cpu_to_le64(((u64)rate << 32) | adapter->portnum);\n\treq.words[1] = cpu_to_le64(state);\n\n\trv = qlcnic_send_cmd_descs(adapter, (struct cmd_desc_type0 *)&req, 1);\n\tif (rv)\n\t\tdev_err(&adapter->pdev->dev, \"LED configuration failed.\\n\");\n\n\treturn rv;\n}\n\nvoid qlcnic_82xx_get_beacon_state(struct qlcnic_adapter *adapter)\n{\n\tstruct qlcnic_hardware_context *ahw = adapter->ahw;\n\tstruct qlcnic_cmd_args cmd;\n\tu8 beacon_state;\n\tint err = 0;\n\n\tif (ahw->extra_capability[0] & QLCNIC_FW_CAPABILITY_2_BEACON) {\n\t\terr = qlcnic_alloc_mbx_args(&cmd, adapter,\n\t\t\t\t\t    QLCNIC_CMD_GET_LED_STATUS);\n\t\tif (!err) {\n\t\t\terr = qlcnic_issue_cmd(adapter, &cmd);\n\t\t\tif (err) {\n\t\t\t\tnetdev_err(adapter->netdev,\n\t\t\t\t\t   \"Failed to get current beacon state, err=%d\\n\",\n\t\t\t\t\t   err);\n\t\t\t} else {\n\t\t\t\tbeacon_state = cmd.rsp.arg[1];\n\t\t\t\tif (beacon_state == QLCNIC_BEACON_DISABLE)\n\t\t\t\t\tahw->beacon_state = QLCNIC_BEACON_OFF;\n\t\t\t\telse if (beacon_state == QLCNIC_BEACON_EANBLE)\n\t\t\t\t\tahw->beacon_state = QLCNIC_BEACON_ON;\n\t\t\t}\n\t\t}\n\t\tqlcnic_free_mbx_args(&cmd);\n\t}\n\n\treturn;\n}\n\nvoid qlcnic_82xx_get_func_no(struct qlcnic_adapter *adapter)\n{\n\tvoid __iomem *msix_base_addr;\n\tu32 func;\n\tu32 msix_base;\n\n\tpci_read_config_dword(adapter->pdev, QLCNIC_MSIX_TABLE_OFFSET, &func);\n\tmsix_base_addr = adapter->ahw->pci_base0 + QLCNIC_MSIX_BASE;\n\tmsix_base = readl(msix_base_addr);\n\tfunc = (func - msix_base) / QLCNIC_MSIX_TBL_PGSIZE;\n\tadapter->ahw->pci_func = func;\n}\n\nvoid qlcnic_82xx_read_crb(struct qlcnic_adapter *adapter, char *buf,\n\t\t\t  loff_t offset, size_t size)\n{\n\tint err = 0;\n\tu32 data;\n\tu64 qmdata;\n\n\tif (ADDR_IN_RANGE(offset, QLCNIC_PCI_CAMQM, QLCNIC_PCI_CAMQM_END)) {\n\t\tqlcnic_pci_camqm_read_2M(adapter, offset, &qmdata);\n\t\tmemcpy(buf, &qmdata, size);\n\t} else {\n\t\tdata = QLCRD32(adapter, offset, &err);\n\t\tmemcpy(buf, &data, size);\n\t}\n}\n\nvoid qlcnic_82xx_write_crb(struct qlcnic_adapter *adapter, char *buf,\n\t\t\t   loff_t offset, size_t size)\n{\n\tu32 data;\n\tu64 qmdata;\n\n\tif (ADDR_IN_RANGE(offset, QLCNIC_PCI_CAMQM, QLCNIC_PCI_CAMQM_END)) {\n\t\tmemcpy(&qmdata, buf, size);\n\t\tqlcnic_pci_camqm_write_2M(adapter, offset, qmdata);\n\t} else {\n\t\tmemcpy(&data, buf, size);\n\t\tQLCWR32(adapter, offset, data);\n\t}\n}\n\nint qlcnic_82xx_api_lock(struct qlcnic_adapter *adapter)\n{\n\treturn qlcnic_pcie_sem_lock(adapter, 5, 0);\n}\n\nvoid qlcnic_82xx_api_unlock(struct qlcnic_adapter *adapter)\n{\n\tqlcnic_pcie_sem_unlock(adapter, 5);\n}\n\nint qlcnic_82xx_shutdown(struct pci_dev *pdev)\n{\n\tstruct qlcnic_adapter *adapter = pci_get_drvdata(pdev);\n\tstruct net_device *netdev = adapter->netdev;\n\n\tnetif_device_detach(netdev);\n\n\tqlcnic_cancel_idc_work(adapter);\n\n\tif (netif_running(netdev))\n\t\tqlcnic_down(adapter, netdev);\n\n\tqlcnic_clr_all_drv_state(adapter, 0);\n\n\tclear_bit(__QLCNIC_RESETTING, &adapter->state);\n\n\tif (qlcnic_wol_supported(adapter))\n\t\tdevice_wakeup_enable(&pdev->dev);\n\n\treturn 0;\n}\n\nint qlcnic_82xx_resume(struct qlcnic_adapter *adapter)\n{\n\tstruct net_device *netdev = adapter->netdev;\n\tint err;\n\n\terr = qlcnic_start_firmware(adapter);\n\tif (err) {\n\t\tdev_err(&adapter->pdev->dev, \"failed to start firmware\\n\");\n\t\treturn err;\n\t}\n\n\tif (netif_running(netdev)) {\n\t\terr = qlcnic_up(adapter, netdev);\n\t\tif (!err)\n\t\t\tqlcnic_restore_indev_addr(netdev, NETDEV_UP);\n\t}\n\n\tnetif_device_attach(netdev);\n\tqlcnic_schedule_work(adapter, qlcnic_fw_poll_work, FW_POLL_DELAY);\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}