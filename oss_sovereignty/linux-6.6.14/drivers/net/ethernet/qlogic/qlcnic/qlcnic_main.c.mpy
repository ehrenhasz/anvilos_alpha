{
  "module_name": "qlcnic_main.c",
  "hash_id": "a1bc5b45b61561a1eefe7d8ade1cb187649ce44e7dedb1798298b253e7c8e62e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c",
  "human_readable_source": "\n \n\n#include <linux/vmalloc.h>\n#include <linux/interrupt.h>\n#include <linux/swab.h>\n#include <linux/dma-mapping.h>\n#include <linux/if_vlan.h>\n#include <net/ip.h>\n#include <linux/ipv6.h>\n#include <linux/inetdevice.h>\n#include <linux/log2.h>\n#include <linux/pci.h>\n#include <net/vxlan.h>\n\n#include \"qlcnic.h\"\n#include \"qlcnic_sriov.h\"\n#include \"qlcnic_hw.h\"\n\nMODULE_DESCRIPTION(\"QLogic 1/10 GbE Converged/Intelligent Ethernet Driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(QLCNIC_LINUX_VERSIONID);\nMODULE_FIRMWARE(QLCNIC_UNIFIED_ROMIMAGE_NAME);\n\nchar qlcnic_driver_name[] = \"qlcnic\";\nstatic const char qlcnic_driver_string[] = \"QLogic 1/10 GbE \"\n\t\"Converged/Intelligent Ethernet Driver v\" QLCNIC_LINUX_VERSIONID;\n\nstatic int qlcnic_mac_learn;\nmodule_param(qlcnic_mac_learn, int, 0444);\nMODULE_PARM_DESC(qlcnic_mac_learn,\n\t\t \"Mac Filter (0=learning is disabled, 1=Driver learning is enabled, 2=FDB learning is enabled)\");\n\nint qlcnic_use_msi = 1;\nMODULE_PARM_DESC(use_msi, \"MSI interrupt (0=disabled, 1=enabled)\");\nmodule_param_named(use_msi, qlcnic_use_msi, int, 0444);\n\nint qlcnic_use_msi_x = 1;\nMODULE_PARM_DESC(use_msi_x, \"MSI-X interrupt (0=disabled, 1=enabled)\");\nmodule_param_named(use_msi_x, qlcnic_use_msi_x, int, 0444);\n\nint qlcnic_auto_fw_reset = 1;\nMODULE_PARM_DESC(auto_fw_reset, \"Auto firmware reset (0=disabled, 1=enabled)\");\nmodule_param_named(auto_fw_reset, qlcnic_auto_fw_reset, int, 0644);\n\nint qlcnic_load_fw_file;\nMODULE_PARM_DESC(load_fw_file, \"Load firmware from (0=flash, 1=file, 2=POST in fast mode, 3= POST in medium mode, 4=POST in slow mode)\");\nmodule_param_named(load_fw_file, qlcnic_load_fw_file, int, 0444);\n\nstatic int qlcnic_probe(struct pci_dev *pdev, const struct pci_device_id *ent);\nstatic void qlcnic_remove(struct pci_dev *pdev);\nstatic int qlcnic_open(struct net_device *netdev);\nstatic int qlcnic_close(struct net_device *netdev);\nstatic void qlcnic_tx_timeout(struct net_device *netdev, unsigned int txqueue);\nstatic void qlcnic_attach_work(struct work_struct *work);\nstatic void qlcnic_fwinit_work(struct work_struct *work);\n\nstatic void qlcnic_idc_debug_info(struct qlcnic_adapter *adapter, u8 encoding);\nstatic int qlcnic_can_start_firmware(struct qlcnic_adapter *adapter);\n\nstatic irqreturn_t qlcnic_tmp_intr(int irq, void *data);\nstatic irqreturn_t qlcnic_intr(int irq, void *data);\nstatic irqreturn_t qlcnic_msi_intr(int irq, void *data);\nstatic irqreturn_t qlcnic_msix_intr(int irq, void *data);\nstatic irqreturn_t qlcnic_msix_tx_intr(int irq, void *data);\n\nstatic struct net_device_stats *qlcnic_get_stats(struct net_device *netdev);\nstatic int qlcnic_start_firmware(struct qlcnic_adapter *);\n\nstatic void qlcnic_free_lb_filters_mem(struct qlcnic_adapter *adapter);\nstatic void qlcnic_dev_set_npar_ready(struct qlcnic_adapter *);\nstatic int qlcnicvf_start_firmware(struct qlcnic_adapter *);\nstatic int qlcnic_vlan_rx_add(struct net_device *, __be16, u16);\nstatic int qlcnic_vlan_rx_del(struct net_device *, __be16, u16);\n\nstatic int qlcnic_82xx_setup_intr(struct qlcnic_adapter *);\nstatic void qlcnic_82xx_dev_request_reset(struct qlcnic_adapter *, u32);\nstatic irqreturn_t qlcnic_82xx_clear_legacy_intr(struct qlcnic_adapter *);\nstatic pci_ers_result_t qlcnic_82xx_io_slot_reset(struct pci_dev *);\nstatic int qlcnic_82xx_start_firmware(struct qlcnic_adapter *);\nstatic void qlcnic_82xx_io_resume(struct pci_dev *);\nstatic void qlcnic_82xx_set_mac_filter_count(struct qlcnic_adapter *);\nstatic pci_ers_result_t qlcnic_82xx_io_error_detected(struct pci_dev *,\n\t\t\t\t\t\t      pci_channel_state_t);\nstatic u32 qlcnic_vlan_tx_check(struct qlcnic_adapter *adapter)\n{\n\tstruct qlcnic_hardware_context *ahw = adapter->ahw;\n\n\tif (adapter->pdev->device == PCI_DEVICE_ID_QLOGIC_QLE824X)\n\t\treturn ahw->capabilities & QLCNIC_FW_CAPABILITY_FVLANTX;\n\telse\n\t\treturn 1;\n}\n\n \n#define ENTRY(device) \\\n\t{PCI_DEVICE(PCI_VENDOR_ID_QLOGIC, (device)), \\\n\t.class = PCI_CLASS_NETWORK_ETHERNET << 8, .class_mask = ~0}\n\nstatic const struct pci_device_id qlcnic_pci_tbl[] = {\n\tENTRY(PCI_DEVICE_ID_QLOGIC_QLE824X),\n\tENTRY(PCI_DEVICE_ID_QLOGIC_QLE834X),\n\tENTRY(PCI_DEVICE_ID_QLOGIC_VF_QLE834X),\n\tENTRY(PCI_DEVICE_ID_QLOGIC_QLE8830),\n\tENTRY(PCI_DEVICE_ID_QLOGIC_VF_QLE8C30),\n\tENTRY(PCI_DEVICE_ID_QLOGIC_QLE844X),\n\tENTRY(PCI_DEVICE_ID_QLOGIC_VF_QLE844X),\n\t{0,}\n};\n\nMODULE_DEVICE_TABLE(pci, qlcnic_pci_tbl);\n\n\ninline void qlcnic_update_cmd_producer(struct qlcnic_host_tx_ring *tx_ring)\n{\n\twritel(tx_ring->producer, tx_ring->crb_cmd_producer);\n}\n\nstatic const u32 msi_tgt_status[8] = {\n\tISR_INT_TARGET_STATUS, ISR_INT_TARGET_STATUS_F1,\n\tISR_INT_TARGET_STATUS_F2, ISR_INT_TARGET_STATUS_F3,\n\tISR_INT_TARGET_STATUS_F4, ISR_INT_TARGET_STATUS_F5,\n\tISR_INT_TARGET_STATUS_F6, ISR_INT_TARGET_STATUS_F7\n};\n\nstatic const u32 qlcnic_reg_tbl[] = {\n\t0x1B20A8,\t \n\t0x1B20AC,\t \n\t0x1B20B0,\t \n\t0x1B2100,\t \n\t0x1B2128,\t \n\t0x1B2138,\t \n\t0x1B2140,\t \n\t0x1B2144,\t \n\t0x1B2148,\t \n\t0x1B214C,\t \n\t0x1B2174,\t \n\t0x1B2150,\t \n\t0x1B2154,\t \n\t0x1B2158,\t \n\t0x1B219C,\t \n\t0x1B21FC,\t \n\t0x1B2250,\t \n\t0x1B233C,\t \n\t0x1B23B4,\t \n\t0x1B216C,\t \n\t0x1B2170,\t \n\t0x13C010,\t \n\t0x13C014,\t \n};\n\nstatic const struct qlcnic_board_info qlcnic_boards[] = {\n\t{ PCI_VENDOR_ID_QLOGIC,\n\t  PCI_DEVICE_ID_QLOGIC_QLE844X,\n\t  0x0,\n\t  0x0,\n\t  \"8400 series 10GbE Converged Network Adapter (TCP/IP Networking)\" },\n\t{ PCI_VENDOR_ID_QLOGIC,\n\t  PCI_DEVICE_ID_QLOGIC_QLE834X,\n\t  PCI_VENDOR_ID_QLOGIC,\n\t  0x24e,\n\t  \"8300 Series Dual Port 10GbE Converged Network Adapter \"\n\t  \"(TCP/IP Networking)\" },\n\t{ PCI_VENDOR_ID_QLOGIC,\n\t  PCI_DEVICE_ID_QLOGIC_QLE834X,\n\t  PCI_VENDOR_ID_QLOGIC,\n\t  0x243,\n\t  \"8300 Series Single Port 10GbE Converged Network Adapter \"\n\t  \"(TCP/IP Networking)\" },\n\t{ PCI_VENDOR_ID_QLOGIC,\n\t  PCI_DEVICE_ID_QLOGIC_QLE834X,\n\t  PCI_VENDOR_ID_QLOGIC,\n\t  0x24a,\n\t  \"8300 Series Dual Port 10GbE Converged Network Adapter \"\n\t  \"(TCP/IP Networking)\" },\n\t{ PCI_VENDOR_ID_QLOGIC,\n\t  PCI_DEVICE_ID_QLOGIC_QLE834X,\n\t  PCI_VENDOR_ID_QLOGIC,\n\t  0x246,\n\t  \"8300 Series Dual Port 10GbE Converged Network Adapter \"\n\t  \"(TCP/IP Networking)\" },\n\t{ PCI_VENDOR_ID_QLOGIC,\n\t  PCI_DEVICE_ID_QLOGIC_QLE834X,\n\t  PCI_VENDOR_ID_QLOGIC,\n\t  0x252,\n\t  \"8300 Series Dual Port 10GbE Converged Network Adapter \"\n\t  \"(TCP/IP Networking)\" },\n\t{ PCI_VENDOR_ID_QLOGIC,\n\t  PCI_DEVICE_ID_QLOGIC_QLE834X,\n\t  PCI_VENDOR_ID_QLOGIC,\n\t  0x26e,\n\t  \"8300 Series Dual Port 10GbE Converged Network Adapter \"\n\t  \"(TCP/IP Networking)\" },\n\t{ PCI_VENDOR_ID_QLOGIC,\n\t  PCI_DEVICE_ID_QLOGIC_QLE834X,\n\t  PCI_VENDOR_ID_QLOGIC,\n\t  0x260,\n\t  \"8300 Series Dual Port 10GbE Converged Network Adapter \"\n\t  \"(TCP/IP Networking)\" },\n\t{ PCI_VENDOR_ID_QLOGIC,\n\t  PCI_DEVICE_ID_QLOGIC_QLE834X,\n\t  PCI_VENDOR_ID_QLOGIC,\n\t  0x266,\n\t  \"8300 Series Single Port 10GbE Converged Network Adapter \"\n\t  \"(TCP/IP Networking)\" },\n\t{ PCI_VENDOR_ID_QLOGIC,\n\t  PCI_DEVICE_ID_QLOGIC_QLE834X,\n\t  PCI_VENDOR_ID_QLOGIC,\n\t  0x269,\n\t  \"8300 Series Dual Port 10GbE Converged Network Adapter \"\n\t  \"(TCP/IP Networking)\" },\n\t{ PCI_VENDOR_ID_QLOGIC,\n\t  PCI_DEVICE_ID_QLOGIC_QLE834X,\n\t  PCI_VENDOR_ID_QLOGIC,\n\t  0x271,\n\t  \"8300 Series Dual Port 10GbE Converged Network Adapter \"\n\t  \"(TCP/IP Networking)\" },\n\t{ PCI_VENDOR_ID_QLOGIC,\n\t  PCI_DEVICE_ID_QLOGIC_QLE834X,\n\t  0x0, 0x0, \"8300 Series 1/10GbE Controller\" },\n\t{ PCI_VENDOR_ID_QLOGIC,\n\t  PCI_DEVICE_ID_QLOGIC_QLE8830,\n\t  0x0,\n\t  0x0,\n\t  \"8830 Series 1/10GbE Controller\" },\n\t{ PCI_VENDOR_ID_QLOGIC,\n\t  PCI_DEVICE_ID_QLOGIC_QLE824X,\n\t  PCI_VENDOR_ID_QLOGIC,\n\t  0x203,\n\t  \"8200 Series Single Port 10GbE Converged Network Adapter\"\n\t  \"(TCP/IP Networking)\" },\n\t{ PCI_VENDOR_ID_QLOGIC,\n\t  PCI_DEVICE_ID_QLOGIC_QLE824X,\n\t  PCI_VENDOR_ID_QLOGIC,\n\t  0x207,\n\t  \"8200 Series Dual Port 10GbE Converged Network Adapter\"\n\t  \"(TCP/IP Networking)\" },\n\t{ PCI_VENDOR_ID_QLOGIC,\n\t  PCI_DEVICE_ID_QLOGIC_QLE824X,\n\t  PCI_VENDOR_ID_QLOGIC,\n\t  0x20b,\n\t  \"3200 Series Dual Port 10Gb Intelligent Ethernet Adapter\" },\n\t{ PCI_VENDOR_ID_QLOGIC,\n\t  PCI_DEVICE_ID_QLOGIC_QLE824X,\n\t  PCI_VENDOR_ID_QLOGIC,\n\t  0x20c,\n\t  \"3200 Series Quad Port 1Gb Intelligent Ethernet Adapter\" },\n\t{ PCI_VENDOR_ID_QLOGIC,\n\t  PCI_DEVICE_ID_QLOGIC_QLE824X,\n\t  PCI_VENDOR_ID_QLOGIC,\n\t  0x20f,\n\t  \"3200 Series Single Port 10Gb Intelligent Ethernet Adapter\" },\n\t{ PCI_VENDOR_ID_QLOGIC,\n\t  PCI_DEVICE_ID_QLOGIC_QLE824X,\n\t  0x103c, 0x3733,\n\t  \"NC523SFP 10Gb 2-port Server Adapter\" },\n\t{ PCI_VENDOR_ID_QLOGIC,\n\t  PCI_DEVICE_ID_QLOGIC_QLE824X,\n\t  0x103c, 0x3346,\n\t  \"CN1000Q Dual Port Converged Network Adapter\" },\n\t{ PCI_VENDOR_ID_QLOGIC,\n\t  PCI_DEVICE_ID_QLOGIC_QLE824X,\n\t  PCI_VENDOR_ID_QLOGIC,\n\t  0x210,\n\t  \"QME8242-k 10GbE Dual Port Mezzanine Card\" },\n\t{ PCI_VENDOR_ID_QLOGIC,\n\t  PCI_DEVICE_ID_QLOGIC_QLE824X,\n\t  0x0, 0x0, \"cLOM8214 1/10GbE Controller\" },\n};\n\n#define NUM_SUPPORTED_BOARDS ARRAY_SIZE(qlcnic_boards)\n\nstatic const\nstruct qlcnic_legacy_intr_set legacy_intr[] = QLCNIC_LEGACY_INTR_CONFIG;\n\nint qlcnic_alloc_sds_rings(struct qlcnic_recv_context *recv_ctx, int count)\n{\n\tint size = sizeof(struct qlcnic_host_sds_ring) * count;\n\n\trecv_ctx->sds_rings = kzalloc(size, GFP_KERNEL);\n\n\treturn recv_ctx->sds_rings == NULL;\n}\n\nvoid qlcnic_free_sds_rings(struct qlcnic_recv_context *recv_ctx)\n{\n\tkfree(recv_ctx->sds_rings);\n\trecv_ctx->sds_rings = NULL;\n}\n\nint qlcnic_read_mac_addr(struct qlcnic_adapter *adapter)\n{\n\tstruct net_device *netdev = adapter->netdev;\n\tstruct pci_dev *pdev = adapter->pdev;\n\tu8 mac_addr[ETH_ALEN];\n\tint ret;\n\n\tret = qlcnic_get_mac_address(adapter, mac_addr,\n\t\t\t\t     adapter->ahw->pci_func);\n\tif (ret)\n\t\treturn ret;\n\n\teth_hw_addr_set(netdev, mac_addr);\n\tmemcpy(adapter->mac_addr, netdev->dev_addr, netdev->addr_len);\n\n\t \n\n\tif (!is_valid_ether_addr(netdev->dev_addr))\n\t\tdev_warn(&pdev->dev, \"Bad MAC address %pM.\\n\",\n\t\t\t\t\tnetdev->dev_addr);\n\n\treturn 0;\n}\n\nstatic void qlcnic_delete_adapter_mac(struct qlcnic_adapter *adapter)\n{\n\tstruct qlcnic_mac_vlan_list *cur;\n\n\tlist_for_each_entry(cur, &adapter->mac_list, list) {\n\t\tif (ether_addr_equal_unaligned(adapter->mac_addr, cur->mac_addr)) {\n\t\t\tqlcnic_sre_macaddr_change(adapter, cur->mac_addr,\n\t\t\t\t\t\t  0, QLCNIC_MAC_DEL);\n\t\t\tlist_del(&cur->list);\n\t\t\tkfree(cur);\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nstatic int qlcnic_set_mac(struct net_device *netdev, void *p)\n{\n\tstruct qlcnic_adapter *adapter = netdev_priv(netdev);\n\tstruct sockaddr *addr = p;\n\n\tif (qlcnic_sriov_vf_check(adapter))\n\t\treturn -EINVAL;\n\n\tif ((adapter->flags & QLCNIC_MAC_OVERRIDE_DISABLED))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!is_valid_ether_addr(addr->sa_data))\n\t\treturn -EINVAL;\n\n\tif (ether_addr_equal_unaligned(adapter->mac_addr, addr->sa_data) &&\n\t    ether_addr_equal_unaligned(netdev->dev_addr, addr->sa_data))\n\t\treturn 0;\n\n\tif (test_bit(__QLCNIC_DEV_UP, &adapter->state)) {\n\t\tnetif_device_detach(netdev);\n\t\tqlcnic_napi_disable(adapter);\n\t}\n\n\tqlcnic_delete_adapter_mac(adapter);\n\tmemcpy(adapter->mac_addr, addr->sa_data, netdev->addr_len);\n\teth_hw_addr_set(netdev, addr->sa_data);\n\tqlcnic_set_multi(adapter->netdev);\n\n\tif (test_bit(__QLCNIC_DEV_UP, &adapter->state)) {\n\t\tnetif_device_attach(netdev);\n\t\tqlcnic_napi_enable(adapter);\n\t}\n\treturn 0;\n}\n\nstatic int qlcnic_fdb_del(struct ndmsg *ndm, struct nlattr *tb[],\n\t\t\tstruct net_device *netdev,\n\t\t\tconst unsigned char *addr, u16 vid,\n\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct qlcnic_adapter *adapter = netdev_priv(netdev);\n\tint err = -EOPNOTSUPP;\n\n\tif (!adapter->fdb_mac_learn)\n\t\treturn ndo_dflt_fdb_del(ndm, tb, netdev, addr, vid);\n\n\tif ((adapter->flags & QLCNIC_ESWITCH_ENABLED) ||\n\t    qlcnic_sriov_check(adapter)) {\n\t\tif (is_unicast_ether_addr(addr)) {\n\t\t\terr = dev_uc_del(netdev, addr);\n\t\t\tif (!err)\n\t\t\t\terr = qlcnic_nic_del_mac(adapter, addr);\n\t\t} else if (is_multicast_ether_addr(addr)) {\n\t\t\terr = dev_mc_del(netdev, addr);\n\t\t} else {\n\t\t\terr =  -EINVAL;\n\t\t}\n\t}\n\treturn err;\n}\n\nstatic int qlcnic_fdb_add(struct ndmsg *ndm, struct nlattr *tb[],\n\t\t\tstruct net_device *netdev,\n\t\t\tconst unsigned char *addr, u16 vid, u16 flags,\n\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct qlcnic_adapter *adapter = netdev_priv(netdev);\n\tint err = 0;\n\n\tif (!adapter->fdb_mac_learn)\n\t\treturn ndo_dflt_fdb_add(ndm, tb, netdev, addr, vid, flags);\n\n\tif (!(adapter->flags & QLCNIC_ESWITCH_ENABLED) &&\n\t    !qlcnic_sriov_check(adapter)) {\n\t\tpr_info(\"%s: FDB e-switch is not enabled\\n\", __func__);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (ether_addr_equal(addr, adapter->mac_addr))\n\t\treturn err;\n\n\tif (is_unicast_ether_addr(addr)) {\n\t\tif (netdev_uc_count(netdev) < adapter->ahw->max_uc_count)\n\t\t\terr = dev_uc_add_excl(netdev, addr);\n\t\telse\n\t\t\terr = -ENOMEM;\n\t} else if (is_multicast_ether_addr(addr)) {\n\t\terr = dev_mc_add_excl(netdev, addr);\n\t} else {\n\t\terr = -EINVAL;\n\t}\n\n\treturn err;\n}\n\nstatic int qlcnic_fdb_dump(struct sk_buff *skb, struct netlink_callback *ncb,\n\t\t\tstruct net_device *netdev,\n\t\t\tstruct net_device *filter_dev, int *idx)\n{\n\tstruct qlcnic_adapter *adapter = netdev_priv(netdev);\n\tint err = 0;\n\n\tif (!adapter->fdb_mac_learn)\n\t\treturn ndo_dflt_fdb_dump(skb, ncb, netdev, filter_dev, idx);\n\n\tif ((adapter->flags & QLCNIC_ESWITCH_ENABLED) ||\n\t    qlcnic_sriov_check(adapter))\n\t\terr = ndo_dflt_fdb_dump(skb, ncb, netdev, filter_dev, idx);\n\n\treturn err;\n}\n\nstatic void qlcnic_82xx_cancel_idc_work(struct qlcnic_adapter *adapter)\n{\n\twhile (test_and_set_bit(__QLCNIC_RESETTING, &adapter->state))\n\t\tusleep_range(10000, 11000);\n\n\tif (!adapter->fw_work.work.func)\n\t\treturn;\n\n\tcancel_delayed_work_sync(&adapter->fw_work);\n}\n\nstatic int qlcnic_get_phys_port_id(struct net_device *netdev,\n\t\t\t\t   struct netdev_phys_item_id *ppid)\n{\n\tstruct qlcnic_adapter *adapter = netdev_priv(netdev);\n\tstruct qlcnic_hardware_context *ahw = adapter->ahw;\n\n\tif (!(adapter->flags & QLCNIC_HAS_PHYS_PORT_ID))\n\t\treturn -EOPNOTSUPP;\n\n\tppid->id_len = sizeof(ahw->phys_port_id);\n\tmemcpy(ppid->id, ahw->phys_port_id, ppid->id_len);\n\n\treturn 0;\n}\n\nstatic int qlcnic_udp_tunnel_sync(struct net_device *dev, unsigned int table)\n{\n\tstruct qlcnic_adapter *adapter = netdev_priv(dev);\n\tstruct udp_tunnel_info ti;\n\tint err;\n\n\tudp_tunnel_nic_get_port(dev, table, 0, &ti);\n\tif (ti.port) {\n\t\terr = qlcnic_set_vxlan_port(adapter, ntohs(ti.port));\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn qlcnic_set_vxlan_parsing(adapter, ntohs(ti.port));\n}\n\nstatic const struct udp_tunnel_nic_info qlcnic_udp_tunnels = {\n\t.sync_table\t= qlcnic_udp_tunnel_sync,\n\t.flags\t\t= UDP_TUNNEL_NIC_INFO_MAY_SLEEP,\n\t.tables\t\t= {\n\t\t{ .n_entries = 1, .tunnel_types = UDP_TUNNEL_TYPE_VXLAN, },\n\t},\n};\n\nstatic netdev_features_t qlcnic_features_check(struct sk_buff *skb,\n\t\t\t\t\t       struct net_device *dev,\n\t\t\t\t\t       netdev_features_t features)\n{\n\tfeatures = vlan_features_check(skb, features);\n\treturn vxlan_features_check(skb, features);\n}\n\nstatic const struct net_device_ops qlcnic_netdev_ops = {\n\t.ndo_open\t   = qlcnic_open,\n\t.ndo_stop\t   = qlcnic_close,\n\t.ndo_start_xmit    = qlcnic_xmit_frame,\n\t.ndo_get_stats\t   = qlcnic_get_stats,\n\t.ndo_validate_addr = eth_validate_addr,\n\t.ndo_set_rx_mode   = qlcnic_set_multi,\n\t.ndo_set_mac_address    = qlcnic_set_mac,\n\t.ndo_change_mtu\t   = qlcnic_change_mtu,\n\t.ndo_fix_features  = qlcnic_fix_features,\n\t.ndo_set_features  = qlcnic_set_features,\n\t.ndo_tx_timeout\t   = qlcnic_tx_timeout,\n\t.ndo_vlan_rx_add_vid\t= qlcnic_vlan_rx_add,\n\t.ndo_vlan_rx_kill_vid\t= qlcnic_vlan_rx_del,\n\t.ndo_fdb_add\t\t= qlcnic_fdb_add,\n\t.ndo_fdb_del\t\t= qlcnic_fdb_del,\n\t.ndo_fdb_dump\t\t= qlcnic_fdb_dump,\n\t.ndo_get_phys_port_id\t= qlcnic_get_phys_port_id,\n\t.ndo_features_check\t= qlcnic_features_check,\n#ifdef CONFIG_QLCNIC_SRIOV\n\t.ndo_set_vf_mac\t\t= qlcnic_sriov_set_vf_mac,\n\t.ndo_set_vf_rate\t= qlcnic_sriov_set_vf_tx_rate,\n\t.ndo_get_vf_config\t= qlcnic_sriov_get_vf_config,\n\t.ndo_set_vf_vlan\t= qlcnic_sriov_set_vf_vlan,\n\t.ndo_set_vf_spoofchk\t= qlcnic_sriov_set_vf_spoofchk,\n#endif\n};\n\nstatic const struct net_device_ops qlcnic_netdev_failed_ops = {\n\t.ndo_open\t   = qlcnic_open,\n};\n\nstatic struct qlcnic_nic_template qlcnic_ops = {\n\t.config_bridged_mode\t= qlcnic_config_bridged_mode,\n\t.config_led\t\t= qlcnic_82xx_config_led,\n\t.start_firmware\t\t= qlcnic_82xx_start_firmware,\n\t.request_reset\t\t= qlcnic_82xx_dev_request_reset,\n\t.cancel_idc_work\t= qlcnic_82xx_cancel_idc_work,\n\t.napi_add\t\t= qlcnic_82xx_napi_add,\n\t.napi_del\t\t= qlcnic_82xx_napi_del,\n\t.config_ipaddr\t\t= qlcnic_82xx_config_ipaddr,\n\t.shutdown\t\t= qlcnic_82xx_shutdown,\n\t.resume\t\t\t= qlcnic_82xx_resume,\n\t.clear_legacy_intr\t= qlcnic_82xx_clear_legacy_intr,\n};\n\nstruct qlcnic_nic_template qlcnic_vf_ops = {\n\t.config_bridged_mode\t= qlcnicvf_config_bridged_mode,\n\t.config_led\t\t= qlcnicvf_config_led,\n\t.start_firmware\t\t= qlcnicvf_start_firmware\n};\n\nstatic struct qlcnic_hardware_ops qlcnic_hw_ops = {\n\t.read_crb\t\t\t= qlcnic_82xx_read_crb,\n\t.write_crb\t\t\t= qlcnic_82xx_write_crb,\n\t.read_reg\t\t\t= qlcnic_82xx_hw_read_wx_2M,\n\t.write_reg\t\t\t= qlcnic_82xx_hw_write_wx_2M,\n\t.get_mac_address\t\t= qlcnic_82xx_get_mac_address,\n\t.setup_intr\t\t\t= qlcnic_82xx_setup_intr,\n\t.alloc_mbx_args\t\t\t= qlcnic_82xx_alloc_mbx_args,\n\t.mbx_cmd\t\t\t= qlcnic_82xx_issue_cmd,\n\t.get_func_no\t\t\t= qlcnic_82xx_get_func_no,\n\t.api_lock\t\t\t= qlcnic_82xx_api_lock,\n\t.api_unlock\t\t\t= qlcnic_82xx_api_unlock,\n\t.add_sysfs\t\t\t= qlcnic_82xx_add_sysfs,\n\t.remove_sysfs\t\t\t= qlcnic_82xx_remove_sysfs,\n\t.process_lb_rcv_ring_diag\t= qlcnic_82xx_process_rcv_ring_diag,\n\t.create_rx_ctx\t\t\t= qlcnic_82xx_fw_cmd_create_rx_ctx,\n\t.create_tx_ctx\t\t\t= qlcnic_82xx_fw_cmd_create_tx_ctx,\n\t.del_rx_ctx\t\t\t= qlcnic_82xx_fw_cmd_del_rx_ctx,\n\t.del_tx_ctx\t\t\t= qlcnic_82xx_fw_cmd_del_tx_ctx,\n\t.setup_link_event\t\t= qlcnic_82xx_linkevent_request,\n\t.get_nic_info\t\t\t= qlcnic_82xx_get_nic_info,\n\t.get_pci_info\t\t\t= qlcnic_82xx_get_pci_info,\n\t.set_nic_info\t\t\t= qlcnic_82xx_set_nic_info,\n\t.change_macvlan\t\t\t= qlcnic_82xx_sre_macaddr_change,\n\t.napi_enable\t\t\t= qlcnic_82xx_napi_enable,\n\t.napi_disable\t\t\t= qlcnic_82xx_napi_disable,\n\t.config_intr_coal\t\t= qlcnic_82xx_config_intr_coalesce,\n\t.config_rss\t\t\t= qlcnic_82xx_config_rss,\n\t.config_hw_lro\t\t\t= qlcnic_82xx_config_hw_lro,\n\t.config_loopback\t\t= qlcnic_82xx_set_lb_mode,\n\t.clear_loopback\t\t\t= qlcnic_82xx_clear_lb_mode,\n\t.config_promisc_mode\t\t= qlcnic_82xx_nic_set_promisc,\n\t.change_l2_filter\t\t= qlcnic_82xx_change_filter,\n\t.get_board_info\t\t\t= qlcnic_82xx_get_board_info,\n\t.set_mac_filter_count\t\t= qlcnic_82xx_set_mac_filter_count,\n\t.free_mac_list\t\t\t= qlcnic_82xx_free_mac_list,\n\t.read_phys_port_id\t\t= qlcnic_82xx_read_phys_port_id,\n\t.io_error_detected\t\t= qlcnic_82xx_io_error_detected,\n\t.io_slot_reset\t\t\t= qlcnic_82xx_io_slot_reset,\n\t.io_resume\t\t\t= qlcnic_82xx_io_resume,\n\t.get_beacon_state\t\t= qlcnic_82xx_get_beacon_state,\n\t.enable_sds_intr\t\t= qlcnic_82xx_enable_sds_intr,\n\t.disable_sds_intr\t\t= qlcnic_82xx_disable_sds_intr,\n\t.enable_tx_intr\t\t\t= qlcnic_82xx_enable_tx_intr,\n\t.disable_tx_intr\t\t= qlcnic_82xx_disable_tx_intr,\n\t.get_saved_state\t\t= qlcnic_82xx_get_saved_state,\n\t.set_saved_state\t\t= qlcnic_82xx_set_saved_state,\n\t.cache_tmpl_hdr_values\t\t= qlcnic_82xx_cache_tmpl_hdr_values,\n\t.get_cap_size\t\t\t= qlcnic_82xx_get_cap_size,\n\t.set_sys_info\t\t\t= qlcnic_82xx_set_sys_info,\n\t.store_cap_mask\t\t\t= qlcnic_82xx_store_cap_mask,\n\t.encap_rx_offload               = qlcnic_82xx_encap_rx_offload,\n\t.encap_tx_offload               = qlcnic_82xx_encap_tx_offload,\n};\n\nstatic int qlcnic_check_multi_tx_capability(struct qlcnic_adapter *adapter)\n{\n\tstruct qlcnic_hardware_context *ahw = adapter->ahw;\n\n\tif (qlcnic_82xx_check(adapter) &&\n\t    (ahw->extra_capability[0] & QLCNIC_FW_CAPABILITY_2_MULTI_TX)) {\n\t\ttest_and_set_bit(__QLCNIC_MULTI_TX_UNIQUE, &adapter->state);\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}\n\nstatic int qlcnic_max_rings(struct qlcnic_adapter *adapter, u8 ring_cnt,\n\t\t\t    int queue_type)\n{\n\tint num_rings, max_rings = QLCNIC_MAX_SDS_RINGS;\n\n\tif (queue_type == QLCNIC_RX_QUEUE)\n\t\tmax_rings = adapter->max_sds_rings;\n\telse if (queue_type == QLCNIC_TX_QUEUE)\n\t\tmax_rings = adapter->max_tx_rings;\n\n\tnum_rings = rounddown_pow_of_two(min_t(int, num_online_cpus(),\n\t\t\t\t\t      max_rings));\n\n\tif (ring_cnt > num_rings)\n\t\treturn num_rings;\n\telse\n\t\treturn ring_cnt;\n}\n\nvoid qlcnic_set_tx_ring_count(struct qlcnic_adapter *adapter, u8 tx_cnt)\n{\n\t \n\tif (adapter->max_tx_rings)\n\t\tadapter->drv_tx_rings = qlcnic_max_rings(adapter, tx_cnt,\n\t\t\t\t\t\t\t QLCNIC_TX_QUEUE);\n\telse\n\t\tadapter->drv_tx_rings = tx_cnt;\n}\n\nvoid qlcnic_set_sds_ring_count(struct qlcnic_adapter *adapter, u8 rx_cnt)\n{\n\t \n\tif (adapter->max_sds_rings)\n\t\tadapter->drv_sds_rings = qlcnic_max_rings(adapter, rx_cnt,\n\t\t\t\t\t\t\t  QLCNIC_RX_QUEUE);\n\telse\n\t\tadapter->drv_sds_rings = rx_cnt;\n}\n\nint qlcnic_setup_tss_rss_intr(struct qlcnic_adapter *adapter)\n{\n\tstruct pci_dev *pdev = adapter->pdev;\n\tint num_msix = 0, err = 0, vector;\n\n\tadapter->flags &= ~QLCNIC_TSS_RSS;\n\n\tif (adapter->drv_tss_rings > 0)\n\t\tnum_msix += adapter->drv_tss_rings;\n\telse\n\t\tnum_msix += adapter->drv_tx_rings;\n\n\tif (adapter->drv_rss_rings > 0)\n\t\tnum_msix += adapter->drv_rss_rings;\n\telse\n\t\tnum_msix += adapter->drv_sds_rings;\n\n\tif (qlcnic_83xx_check(adapter))\n\t\tnum_msix += 1;\n\n\tif (!adapter->msix_entries) {\n\t\tadapter->msix_entries = kcalloc(num_msix,\n\t\t\t\t\t\tsizeof(struct msix_entry),\n\t\t\t\t\t\tGFP_KERNEL);\n\t\tif (!adapter->msix_entries)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tfor (vector = 0; vector < num_msix; vector++)\n\t\tadapter->msix_entries[vector].entry = vector;\n\nrestore:\n\terr = pci_enable_msix_exact(pdev, adapter->msix_entries, num_msix);\n\tif (err == -ENOSPC) {\n\t\tif (!adapter->drv_tss_rings && !adapter->drv_rss_rings)\n\t\t\treturn err;\n\n\t\tnetdev_info(adapter->netdev,\n\t\t\t    \"Unable to allocate %d MSI-X vectors, Available vectors %d\\n\",\n\t\t\t    num_msix, err);\n\n\t\tnum_msix = adapter->drv_tx_rings + adapter->drv_sds_rings;\n\n\t\t \n\t\tadapter->drv_tss_rings = 0;\n\t\tadapter->drv_rss_rings = 0;\n\n\t\tif (qlcnic_83xx_check(adapter))\n\t\t\tnum_msix += 1;\n\n\t\tnetdev_info(adapter->netdev,\n\t\t\t    \"Restoring %d Tx, %d SDS rings for total %d vectors.\\n\",\n\t\t\t    adapter->drv_tx_rings, adapter->drv_sds_rings,\n\t\t\t    num_msix);\n\n\t\tgoto restore;\n\t} else if (err < 0) {\n\t\treturn err;\n\t}\n\n\tadapter->ahw->num_msix = num_msix;\n\tif (adapter->drv_tss_rings > 0)\n\t\tadapter->drv_tx_rings = adapter->drv_tss_rings;\n\n\tif (adapter->drv_rss_rings > 0)\n\t\tadapter->drv_sds_rings = adapter->drv_rss_rings;\n\n\treturn 0;\n}\n\nint qlcnic_enable_msix(struct qlcnic_adapter *adapter, u32 num_msix)\n{\n\tstruct pci_dev *pdev = adapter->pdev;\n\tint err, vector;\n\n\tif (!adapter->msix_entries) {\n\t\tadapter->msix_entries = kcalloc(num_msix,\n\t\t\t\t\t\tsizeof(struct msix_entry),\n\t\t\t\t\t\tGFP_KERNEL);\n\t\tif (!adapter->msix_entries)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tadapter->flags &= ~(QLCNIC_MSI_ENABLED | QLCNIC_MSIX_ENABLED);\n\n\tif (adapter->ahw->msix_supported) {\nenable_msix:\n\t\tfor (vector = 0; vector < num_msix; vector++)\n\t\t\tadapter->msix_entries[vector].entry = vector;\n\n\t\terr = pci_enable_msix_range(pdev,\n\t\t\t\t\t    adapter->msix_entries, 1, num_msix);\n\n\t\tif (err == num_msix) {\n\t\t\tadapter->flags |= QLCNIC_MSIX_ENABLED;\n\t\t\tadapter->ahw->num_msix = num_msix;\n\t\t\tdev_info(&pdev->dev, \"using msi-x interrupts\\n\");\n\t\t\treturn 0;\n\t\t} else if (err > 0) {\n\t\t\tpci_disable_msix(pdev);\n\n\t\t\tdev_info(&pdev->dev,\n\t\t\t\t \"Unable to allocate %d MSI-X vectors, Available vectors %d\\n\",\n\t\t\t\t num_msix, err);\n\n\t\t\tif (qlcnic_82xx_check(adapter)) {\n\t\t\t\tnum_msix = rounddown_pow_of_two(err);\n\t\t\t\tif (err < QLCNIC_82XX_MINIMUM_VECTOR)\n\t\t\t\t\treturn -ENOSPC;\n\t\t\t} else {\n\t\t\t\tnum_msix = rounddown_pow_of_two(err - 1);\n\t\t\t\tnum_msix += 1;\n\t\t\t\tif (err < QLCNIC_83XX_MINIMUM_VECTOR)\n\t\t\t\t\treturn -ENOSPC;\n\t\t\t}\n\n\t\t\tif (qlcnic_82xx_check(adapter) &&\n\t\t\t    !qlcnic_check_multi_tx(adapter)) {\n\t\t\t\tadapter->drv_sds_rings = num_msix;\n\t\t\t\tadapter->drv_tx_rings = QLCNIC_SINGLE_RING;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tadapter->drv_tx_rings = num_msix / 2;\n\t\t\t\tadapter->drv_sds_rings = adapter->drv_tx_rings;\n\t\t\t}\n\n\t\t\tif (num_msix) {\n\t\t\t\tdev_info(&pdev->dev,\n\t\t\t\t\t \"Trying to allocate %d MSI-X interrupt vectors\\n\",\n\t\t\t\t\t num_msix);\n\t\t\t\tgoto enable_msix;\n\t\t\t}\n\t\t} else {\n\t\t\tdev_info(&pdev->dev,\n\t\t\t\t \"Unable to allocate %d MSI-X vectors, err=%d\\n\",\n\t\t\t\t num_msix, err);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn -EIO;\n}\n\nstatic int qlcnic_82xx_calculate_msix_vector(struct qlcnic_adapter *adapter)\n{\n\tint num_msix;\n\n\tnum_msix = adapter->drv_sds_rings;\n\n\tif (qlcnic_check_multi_tx(adapter))\n\t\tnum_msix += adapter->drv_tx_rings;\n\telse\n\t\tnum_msix += QLCNIC_SINGLE_RING;\n\n\treturn num_msix;\n}\n\nstatic int qlcnic_enable_msi_legacy(struct qlcnic_adapter *adapter)\n{\n\tint err = 0;\n\tu32 offset, mask_reg;\n\tconst struct qlcnic_legacy_intr_set *legacy_intrp;\n\tstruct qlcnic_hardware_context *ahw = adapter->ahw;\n\tstruct pci_dev *pdev = adapter->pdev;\n\n\tif (qlcnic_use_msi && !pci_enable_msi(pdev)) {\n\t\tadapter->flags |= QLCNIC_MSI_ENABLED;\n\t\toffset = msi_tgt_status[adapter->ahw->pci_func];\n\t\tadapter->tgt_status_reg = qlcnic_get_ioaddr(adapter->ahw,\n\t\t\t\t\t\t\t    offset);\n\t\tdev_info(&pdev->dev, \"using msi interrupts\\n\");\n\t\tadapter->msix_entries[0].vector = pdev->irq;\n\t\treturn err;\n\t}\n\n\tif (qlcnic_use_msi || qlcnic_use_msi_x)\n\t\treturn -EOPNOTSUPP;\n\n\tlegacy_intrp = &legacy_intr[adapter->ahw->pci_func];\n\tadapter->ahw->int_vec_bit = legacy_intrp->int_vec_bit;\n\toffset = legacy_intrp->tgt_status_reg;\n\tadapter->tgt_status_reg = qlcnic_get_ioaddr(ahw, offset);\n\tmask_reg = legacy_intrp->tgt_mask_reg;\n\tadapter->tgt_mask_reg = qlcnic_get_ioaddr(ahw, mask_reg);\n\tadapter->isr_int_vec = qlcnic_get_ioaddr(ahw, ISR_INT_VECTOR);\n\tadapter->crb_int_state_reg = qlcnic_get_ioaddr(ahw, ISR_INT_STATE_REG);\n\tdev_info(&pdev->dev, \"using legacy interrupts\\n\");\n\tadapter->msix_entries[0].vector = pdev->irq;\n\treturn err;\n}\n\nstatic int qlcnic_82xx_setup_intr(struct qlcnic_adapter *adapter)\n{\n\tint num_msix, err = 0;\n\n\tif (adapter->flags & QLCNIC_TSS_RSS) {\n\t\terr = qlcnic_setup_tss_rss_intr(adapter);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tnum_msix = adapter->ahw->num_msix;\n\t} else {\n\t\tnum_msix = qlcnic_82xx_calculate_msix_vector(adapter);\n\n\t\terr = qlcnic_enable_msix(adapter, num_msix);\n\t\tif (err == -ENOMEM)\n\t\t\treturn err;\n\n\t\tif (!(adapter->flags & QLCNIC_MSIX_ENABLED)) {\n\t\t\tqlcnic_disable_multi_tx(adapter);\n\t\t\tadapter->drv_sds_rings = QLCNIC_SINGLE_RING;\n\n\t\t\terr = qlcnic_enable_msi_legacy(adapter);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint qlcnic_82xx_mq_intrpt(struct qlcnic_adapter *adapter, int op_type)\n{\n\tstruct qlcnic_hardware_context *ahw = adapter->ahw;\n\tint err, i;\n\n\tif (qlcnic_check_multi_tx(adapter) &&\n\t    !ahw->diag_test &&\n\t    (adapter->flags & QLCNIC_MSIX_ENABLED)) {\n\t\tahw->intr_tbl =\n\t\t\tvzalloc(array_size(sizeof(struct qlcnic_intrpt_config),\n\t\t\t\t\t   ahw->num_msix));\n\t\tif (!ahw->intr_tbl)\n\t\t\treturn -ENOMEM;\n\n\t\tfor (i = 0; i < ahw->num_msix; i++) {\n\t\t\tahw->intr_tbl[i].type = QLCNIC_INTRPT_MSIX;\n\t\t\tahw->intr_tbl[i].id = i;\n\t\t\tahw->intr_tbl[i].src = 0;\n\t\t}\n\n\t\terr = qlcnic_82xx_config_intrpt(adapter, 1);\n\t\tif (err)\n\t\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\t\"Failed to configure Interrupt for %d vector\\n\",\n\t\t\t\tahw->num_msix);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nvoid qlcnic_teardown_intr(struct qlcnic_adapter *adapter)\n{\n\tif (adapter->flags & QLCNIC_MSIX_ENABLED)\n\t\tpci_disable_msix(adapter->pdev);\n\tif (adapter->flags & QLCNIC_MSI_ENABLED)\n\t\tpci_disable_msi(adapter->pdev);\n\n\tkfree(adapter->msix_entries);\n\tadapter->msix_entries = NULL;\n\n\tif (adapter->ahw->intr_tbl) {\n\t\tvfree(adapter->ahw->intr_tbl);\n\t\tadapter->ahw->intr_tbl = NULL;\n\t}\n}\n\nstatic void qlcnic_cleanup_pci_map(struct qlcnic_hardware_context *ahw)\n{\n\tif (ahw->pci_base0 != NULL)\n\t\tiounmap(ahw->pci_base0);\n}\n\nstatic int qlcnic_get_act_pci_func(struct qlcnic_adapter *adapter)\n{\n\tstruct qlcnic_hardware_context *ahw = adapter->ahw;\n\tstruct qlcnic_pci_info *pci_info;\n\tint ret;\n\n\tif (!(adapter->flags & QLCNIC_ESWITCH_ENABLED)) {\n\t\tswitch (ahw->port_type) {\n\t\tcase QLCNIC_GBE:\n\t\t\tahw->total_nic_func = QLCNIC_NIU_MAX_GBE_PORTS;\n\t\t\tbreak;\n\t\tcase QLCNIC_XGBE:\n\t\t\tahw->total_nic_func = QLCNIC_NIU_MAX_XG_PORTS;\n\t\t\tbreak;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (ahw->op_mode == QLCNIC_MGMT_FUNC)\n\t\treturn 0;\n\n\tpci_info = kcalloc(ahw->max_vnic_func, sizeof(*pci_info), GFP_KERNEL);\n\tif (!pci_info)\n\t\treturn -ENOMEM;\n\n\tret = qlcnic_get_pci_info(adapter, pci_info);\n\tkfree(pci_info);\n\treturn ret;\n}\n\nstatic bool qlcnic_port_eswitch_cfg_capability(struct qlcnic_adapter *adapter)\n{\n\tbool ret = false;\n\n\tif (qlcnic_84xx_check(adapter)) {\n\t\tret = true;\n\t} else if (qlcnic_83xx_check(adapter)) {\n\t\tif (adapter->ahw->extra_capability[0] &\n\t\t    QLCNIC_FW_CAPABILITY_2_PER_PORT_ESWITCH_CFG)\n\t\t\tret = true;\n\t\telse\n\t\t\tret = false;\n\t}\n\n\treturn ret;\n}\n\nint qlcnic_init_pci_info(struct qlcnic_adapter *adapter)\n{\n\tstruct qlcnic_hardware_context *ahw = adapter->ahw;\n\tstruct qlcnic_pci_info *pci_info;\n\tint i, id = 0, ret = 0, j = 0;\n\tu16 act_pci_func;\n\tu8 pfn;\n\n\tpci_info = kcalloc(ahw->max_vnic_func, sizeof(*pci_info), GFP_KERNEL);\n\tif (!pci_info)\n\t\treturn -ENOMEM;\n\n\tret = qlcnic_get_pci_info(adapter, pci_info);\n\tif (ret)\n\t\tgoto err_pci_info;\n\n\tact_pci_func = ahw->total_nic_func;\n\n\tadapter->npars = kcalloc(act_pci_func,\n\t\t\t\t sizeof(struct qlcnic_npar_info),\n\t\t\t\t GFP_KERNEL);\n\tif (!adapter->npars) {\n\t\tret = -ENOMEM;\n\t\tgoto err_pci_info;\n\t}\n\n\tadapter->eswitch = kcalloc(QLCNIC_NIU_MAX_XG_PORTS,\n\t\t\t\t   sizeof(struct qlcnic_eswitch),\n\t\t\t\t   GFP_KERNEL);\n\tif (!adapter->eswitch) {\n\t\tret = -ENOMEM;\n\t\tgoto err_npars;\n\t}\n\n\tfor (i = 0; i < ahw->max_vnic_func; i++) {\n\t\tpfn = pci_info[i].id;\n\n\t\tif (pfn >= ahw->max_vnic_func) {\n\t\t\tret = -EINVAL;\n\t\t\tdev_err(&adapter->pdev->dev, \"%s: Invalid function 0x%x, max 0x%x\\n\",\n\t\t\t\t__func__, pfn, ahw->max_vnic_func);\n\t\t\tgoto err_eswitch;\n\t\t}\n\n\t\tif (!pci_info[i].active ||\n\t\t    (pci_info[i].type != QLCNIC_TYPE_NIC))\n\t\t\tcontinue;\n\n\t\tif (qlcnic_port_eswitch_cfg_capability(adapter)) {\n\t\t\tif (!qlcnic_83xx_set_port_eswitch_status(adapter, pfn,\n\t\t\t\t\t\t\t\t &id))\n\t\t\t\tadapter->npars[j].eswitch_status = true;\n\t\t\telse\n\t\t\t\tcontinue;\n\t\t} else {\n\t\t\tadapter->npars[j].eswitch_status = true;\n\t\t}\n\n\t\tadapter->npars[j].pci_func = pfn;\n\t\tadapter->npars[j].active = (u8)pci_info[i].active;\n\t\tadapter->npars[j].type = (u8)pci_info[i].type;\n\t\tadapter->npars[j].phy_port = (u8)pci_info[i].default_port;\n\t\tadapter->npars[j].min_bw = pci_info[i].tx_min_bw;\n\t\tadapter->npars[j].max_bw = pci_info[i].tx_max_bw;\n\n\t\tmemcpy(&adapter->npars[j].mac, &pci_info[i].mac, ETH_ALEN);\n\t\tj++;\n\t}\n\n\t \n\tif (!qlcnic_port_eswitch_cfg_capability(adapter)) {\n\t\tfor (i = 0; i < QLCNIC_NIU_MAX_XG_PORTS; i++)\n\t\t\tadapter->eswitch[i].flags |= QLCNIC_SWITCH_ENABLE;\n\t}\n\n\tkfree(pci_info);\n\treturn 0;\n\nerr_eswitch:\n\tkfree(adapter->eswitch);\n\tadapter->eswitch = NULL;\nerr_npars:\n\tkfree(adapter->npars);\n\tadapter->npars = NULL;\nerr_pci_info:\n\tkfree(pci_info);\n\n\treturn ret;\n}\n\nstatic int\nqlcnic_set_function_modes(struct qlcnic_adapter *adapter)\n{\n\tu8 id;\n\tint ret;\n\tu32 data = QLCNIC_MGMT_FUNC;\n\tstruct qlcnic_hardware_context *ahw = adapter->ahw;\n\n\tret = qlcnic_api_lock(adapter);\n\tif (ret)\n\t\tgoto err_lock;\n\n\tid = ahw->pci_func;\n\tdata = QLC_SHARED_REG_RD32(adapter, QLCNIC_DRV_OP_MODE);\n\tdata = (data & ~QLC_DEV_SET_DRV(0xf, id)) |\n\t       QLC_DEV_SET_DRV(QLCNIC_MGMT_FUNC, id);\n\tQLC_SHARED_REG_WR32(adapter, QLCNIC_DRV_OP_MODE, data);\n\tqlcnic_api_unlock(adapter);\nerr_lock:\n\treturn ret;\n}\n\nstatic void qlcnic_check_vf(struct qlcnic_adapter *adapter,\n\t\t\t    const struct pci_device_id *ent)\n{\n\tu32 op_mode, priv_level;\n\n\t \n\tadapter->ahw->fw_hal_version = QLC_SHARED_REG_RD32(adapter,\n\t\t\t\t\t\t\t   QLCNIC_FW_API);\n\n\t \n\tqlcnic_get_func_no(adapter);\n\n\t \n\top_mode = QLC_SHARED_REG_RD32(adapter, QLCNIC_DRV_OP_MODE);\n\tif (op_mode == QLC_DEV_DRV_DEFAULT)\n\t\tpriv_level = QLCNIC_MGMT_FUNC;\n\telse\n\t\tpriv_level = QLC_DEV_GET_DRV(op_mode, adapter->ahw->pci_func);\n\n\tif (priv_level == QLCNIC_NON_PRIV_FUNC) {\n\t\tadapter->ahw->op_mode = QLCNIC_NON_PRIV_FUNC;\n\t\tdev_info(&adapter->pdev->dev,\n\t\t\t\"HAL Version: %d Non Privileged function\\n\",\n\t\t\t adapter->ahw->fw_hal_version);\n\t\tadapter->nic_ops = &qlcnic_vf_ops;\n\t} else\n\t\tadapter->nic_ops = &qlcnic_ops;\n}\n\n#define QLCNIC_82XX_BAR0_LENGTH 0x00200000UL\n#define QLCNIC_83XX_BAR0_LENGTH 0x4000\nstatic void qlcnic_get_bar_length(u32 dev_id, ulong *bar)\n{\n\tswitch (dev_id) {\n\tcase PCI_DEVICE_ID_QLOGIC_QLE824X:\n\t\t*bar = QLCNIC_82XX_BAR0_LENGTH;\n\t\tbreak;\n\tcase PCI_DEVICE_ID_QLOGIC_QLE834X:\n\tcase PCI_DEVICE_ID_QLOGIC_QLE8830:\n\tcase PCI_DEVICE_ID_QLOGIC_QLE844X:\n\tcase PCI_DEVICE_ID_QLOGIC_VF_QLE834X:\n\tcase PCI_DEVICE_ID_QLOGIC_VF_QLE844X:\n\tcase PCI_DEVICE_ID_QLOGIC_VF_QLE8C30:\n\t\t*bar = QLCNIC_83XX_BAR0_LENGTH;\n\t\tbreak;\n\tdefault:\n\t\t*bar = 0;\n\t}\n}\n\nstatic int qlcnic_setup_pci_map(struct pci_dev *pdev,\n\t\t\t\tstruct qlcnic_hardware_context *ahw)\n{\n\tu32 offset;\n\tvoid __iomem *mem_ptr0 = NULL;\n\tunsigned long mem_len, pci_len0 = 0, bar0_len;\n\n\t \n\tmem_len = pci_resource_len(pdev, 0);\n\n\tqlcnic_get_bar_length(pdev->device, &bar0_len);\n\tif (mem_len >= bar0_len) {\n\n\t\tmem_ptr0 = pci_ioremap_bar(pdev, 0);\n\t\tif (mem_ptr0 == NULL) {\n\t\t\tdev_err(&pdev->dev, \"failed to map PCI bar 0\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tpci_len0 = mem_len;\n\t} else {\n\t\treturn -EIO;\n\t}\n\n\tdev_info(&pdev->dev, \"%dKB memory map\\n\", (int)(mem_len >> 10));\n\n\tahw->pci_base0 = mem_ptr0;\n\tahw->pci_len0 = pci_len0;\n\toffset = QLCNIC_PCIX_PS_REG(PCIX_OCM_WINDOW_REG(ahw->pci_func));\n\tqlcnic_get_ioaddr(ahw, offset);\n\n\treturn 0;\n}\n\nstatic bool qlcnic_validate_subsystem_id(struct qlcnic_adapter *adapter,\n\t\t\t\t\t int index)\n{\n\tstruct pci_dev *pdev = adapter->pdev;\n\tunsigned short subsystem_vendor;\n\tbool ret = true;\n\n\tsubsystem_vendor = pdev->subsystem_vendor;\n\n\tif (pdev->device == PCI_DEVICE_ID_QLOGIC_QLE824X ||\n\t    pdev->device == PCI_DEVICE_ID_QLOGIC_QLE834X) {\n\t\tif (qlcnic_boards[index].sub_vendor == subsystem_vendor &&\n\t\t    qlcnic_boards[index].sub_device == pdev->subsystem_device)\n\t\t\tret = true;\n\t\telse\n\t\t\tret = false;\n\t}\n\n\treturn ret;\n}\n\nstatic void qlcnic_get_board_name(struct qlcnic_adapter *adapter, char *name)\n{\n\tstruct pci_dev *pdev = adapter->pdev;\n\tint i, found = 0;\n\n\tfor (i = 0; i < NUM_SUPPORTED_BOARDS; ++i) {\n\t\tif (qlcnic_boards[i].vendor == pdev->vendor &&\n\t\t    qlcnic_boards[i].device == pdev->device &&\n\t\t    qlcnic_validate_subsystem_id(adapter, i)) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!found)\n\t\tsprintf(name, \"%pM Gigabit Ethernet\", adapter->mac_addr);\n\telse\n\t\tsprintf(name, \"%pM: %s\" , adapter->mac_addr,\n\t\t\tqlcnic_boards[i].short_name);\n}\n\nstatic void\nqlcnic_check_options(struct qlcnic_adapter *adapter)\n{\n\tint err;\n\tu32 fw_major, fw_minor, fw_build, prev_fw_version;\n\tstruct pci_dev *pdev = adapter->pdev;\n\tstruct qlcnic_hardware_context *ahw = adapter->ahw;\n\tstruct qlcnic_fw_dump *fw_dump = &ahw->fw_dump;\n\n\tprev_fw_version = adapter->fw_version;\n\n\tfw_major = QLC_SHARED_REG_RD32(adapter, QLCNIC_FW_VERSION_MAJOR);\n\tfw_minor = QLC_SHARED_REG_RD32(adapter, QLCNIC_FW_VERSION_MINOR);\n\tfw_build = QLC_SHARED_REG_RD32(adapter, QLCNIC_FW_VERSION_SUB);\n\n\tadapter->fw_version = QLCNIC_VERSION_CODE(fw_major, fw_minor, fw_build);\n\n\terr = qlcnic_get_board_info(adapter);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Error getting board config info.\\n\");\n\t\treturn;\n\t}\n\tif (ahw->op_mode != QLCNIC_NON_PRIV_FUNC) {\n\t\tif (fw_dump->tmpl_hdr == NULL ||\n\t\t\t\tadapter->fw_version > prev_fw_version) {\n\t\t\tvfree(fw_dump->tmpl_hdr);\n\t\t\tif (!qlcnic_fw_cmd_get_minidump_temp(adapter))\n\t\t\t\tdev_info(&pdev->dev,\n\t\t\t\t\t\"Supports FW dump capability\\n\");\n\t\t}\n\t}\n\n\tdev_info(&pdev->dev, \"Driver v%s, firmware v%d.%d.%d\\n\",\n\t\t QLCNIC_LINUX_VERSIONID, fw_major, fw_minor, fw_build);\n\n\tif (adapter->ahw->port_type == QLCNIC_XGBE) {\n\t\tif (adapter->flags & QLCNIC_ESWITCH_ENABLED) {\n\t\t\tadapter->num_rxd = DEFAULT_RCV_DESCRIPTORS_VF;\n\t\t\tadapter->max_rxd = MAX_RCV_DESCRIPTORS_VF;\n\t\t} else {\n\t\t\tadapter->num_rxd = DEFAULT_RCV_DESCRIPTORS_10G;\n\t\t\tadapter->max_rxd = MAX_RCV_DESCRIPTORS_10G;\n\t\t}\n\n\t\tadapter->num_jumbo_rxd = MAX_JUMBO_RCV_DESCRIPTORS_10G;\n\t\tadapter->max_jumbo_rxd = MAX_JUMBO_RCV_DESCRIPTORS_10G;\n\n\t} else if (adapter->ahw->port_type == QLCNIC_GBE) {\n\t\tadapter->num_rxd = DEFAULT_RCV_DESCRIPTORS_1G;\n\t\tadapter->num_jumbo_rxd = MAX_JUMBO_RCV_DESCRIPTORS_1G;\n\t\tadapter->max_jumbo_rxd = MAX_JUMBO_RCV_DESCRIPTORS_1G;\n\t\tadapter->max_rxd = MAX_RCV_DESCRIPTORS_1G;\n\t}\n\n\tadapter->ahw->msix_supported = !!qlcnic_use_msi_x;\n\n\tadapter->num_txd = MAX_CMD_DESCRIPTORS;\n\n\tadapter->max_rds_rings = MAX_RDS_RINGS;\n}\n\nstatic int\nqlcnic_initialize_nic(struct qlcnic_adapter *adapter)\n{\n\tstruct qlcnic_info nic_info;\n\tint err = 0;\n\n\tmemset(&nic_info, 0, sizeof(struct qlcnic_info));\n\terr = qlcnic_get_nic_info(adapter, &nic_info, adapter->ahw->pci_func);\n\tif (err)\n\t\treturn err;\n\n\tadapter->ahw->physical_port = (u8)nic_info.phys_port;\n\tadapter->ahw->switch_mode = nic_info.switch_mode;\n\tadapter->ahw->max_tx_ques = nic_info.max_tx_ques;\n\tadapter->ahw->max_rx_ques = nic_info.max_rx_ques;\n\tadapter->ahw->capabilities = nic_info.capabilities;\n\n\tif (adapter->ahw->capabilities & QLCNIC_FW_CAPABILITY_MORE_CAPS) {\n\t\tu32 temp;\n\t\ttemp = QLCRD32(adapter, CRB_FW_CAPABILITIES_2, &err);\n\t\tif (err == -EIO)\n\t\t\treturn err;\n\t\tadapter->ahw->extra_capability[0] = temp;\n\t} else {\n\t\tadapter->ahw->extra_capability[0] = 0;\n\t}\n\n\tadapter->ahw->max_mac_filters = nic_info.max_mac_filters;\n\tadapter->ahw->max_mtu = nic_info.max_mtu;\n\n\tif (adapter->ahw->capabilities & BIT_6) {\n\t\tadapter->flags |= QLCNIC_ESWITCH_ENABLED;\n\t\tadapter->ahw->nic_mode = QLCNIC_VNIC_MODE;\n\t\tadapter->max_tx_rings = QLCNIC_MAX_HW_VNIC_TX_RINGS;\n\t\tadapter->max_sds_rings = QLCNIC_MAX_VNIC_SDS_RINGS;\n\n\t\tdev_info(&adapter->pdev->dev, \"vNIC mode enabled.\\n\");\n\t} else {\n\t\tadapter->ahw->nic_mode = QLCNIC_DEFAULT_MODE;\n\t\tadapter->max_tx_rings = QLCNIC_MAX_HW_TX_RINGS;\n\t\tadapter->max_sds_rings = QLCNIC_MAX_SDS_RINGS;\n\t\tadapter->flags &= ~QLCNIC_ESWITCH_ENABLED;\n\t}\n\n\treturn err;\n}\n\nvoid qlcnic_set_vlan_config(struct qlcnic_adapter *adapter,\n\t\t\t    struct qlcnic_esw_func_cfg *esw_cfg)\n{\n\tif (esw_cfg->discard_tagged)\n\t\tadapter->flags &= ~QLCNIC_TAGGING_ENABLED;\n\telse\n\t\tadapter->flags |= QLCNIC_TAGGING_ENABLED;\n\n\tif (esw_cfg->vlan_id) {\n\t\tadapter->rx_pvid = esw_cfg->vlan_id;\n\t\tadapter->tx_pvid = esw_cfg->vlan_id;\n\t} else {\n\t\tadapter->rx_pvid = 0;\n\t\tadapter->tx_pvid = 0;\n\t}\n}\n\nstatic int\nqlcnic_vlan_rx_add(struct net_device *netdev, __be16 proto, u16 vid)\n{\n\tstruct qlcnic_adapter *adapter = netdev_priv(netdev);\n\tint err;\n\n\tif (qlcnic_sriov_vf_check(adapter)) {\n\t\terr = qlcnic_sriov_cfg_vf_guest_vlan(adapter, vid, 1);\n\t\tif (err) {\n\t\t\tnetdev_err(netdev,\n\t\t\t\t   \"Cannot add VLAN filter for VLAN id %d, err=%d\",\n\t\t\t\t   vid, err);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tset_bit(vid, adapter->vlans);\n\treturn 0;\n}\n\nstatic int\nqlcnic_vlan_rx_del(struct net_device *netdev, __be16 proto, u16 vid)\n{\n\tstruct qlcnic_adapter *adapter = netdev_priv(netdev);\n\tint err;\n\n\tif (qlcnic_sriov_vf_check(adapter)) {\n\t\terr = qlcnic_sriov_cfg_vf_guest_vlan(adapter, vid, 0);\n\t\tif (err) {\n\t\t\tnetdev_err(netdev,\n\t\t\t\t   \"Cannot delete VLAN filter for VLAN id %d, err=%d\",\n\t\t\t\t   vid, err);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tqlcnic_restore_indev_addr(netdev, NETDEV_DOWN);\n\tclear_bit(vid, adapter->vlans);\n\treturn 0;\n}\n\nvoid qlcnic_set_eswitch_port_features(struct qlcnic_adapter *adapter,\n\t\t\t\t      struct qlcnic_esw_func_cfg *esw_cfg)\n{\n\tadapter->flags &= ~(QLCNIC_MACSPOOF | QLCNIC_MAC_OVERRIDE_DISABLED |\n\t\t\t\tQLCNIC_PROMISC_DISABLED);\n\n\tif (esw_cfg->mac_anti_spoof)\n\t\tadapter->flags |= QLCNIC_MACSPOOF;\n\n\tif (!esw_cfg->mac_override)\n\t\tadapter->flags |= QLCNIC_MAC_OVERRIDE_DISABLED;\n\n\tif (!esw_cfg->promisc_mode)\n\t\tadapter->flags |= QLCNIC_PROMISC_DISABLED;\n}\n\nint qlcnic_set_eswitch_port_config(struct qlcnic_adapter *adapter)\n{\n\tstruct qlcnic_esw_func_cfg esw_cfg;\n\n\tif (!(adapter->flags & QLCNIC_ESWITCH_ENABLED))\n\t\treturn 0;\n\n\tesw_cfg.pci_func = adapter->ahw->pci_func;\n\tif (qlcnic_get_eswitch_port_config(adapter, &esw_cfg))\n\t\t\treturn -EIO;\n\tqlcnic_set_vlan_config(adapter, &esw_cfg);\n\tqlcnic_set_eswitch_port_features(adapter, &esw_cfg);\n\tqlcnic_set_netdev_features(adapter, &esw_cfg);\n\n\treturn 0;\n}\n\nvoid qlcnic_set_netdev_features(struct qlcnic_adapter *adapter,\n\t\t\t\tstruct qlcnic_esw_func_cfg *esw_cfg)\n{\n\tstruct net_device *netdev = adapter->netdev;\n\n\tif (qlcnic_83xx_check(adapter))\n\t\treturn;\n\n\tadapter->offload_flags = esw_cfg->offload_flags;\n\tadapter->flags |= QLCNIC_APP_CHANGED_FLAGS;\n\tnetdev_update_features(netdev);\n\tadapter->flags &= ~QLCNIC_APP_CHANGED_FLAGS;\n}\n\nstatic int\nqlcnic_check_eswitch_mode(struct qlcnic_adapter *adapter)\n{\n\tu32 op_mode, priv_level;\n\tint err = 0;\n\n\terr = qlcnic_initialize_nic(adapter);\n\tif (err)\n\t\treturn err;\n\n\tif (adapter->flags & QLCNIC_ADAPTER_INITIALIZED)\n\t\treturn 0;\n\n\top_mode = QLC_SHARED_REG_RD32(adapter, QLCNIC_DRV_OP_MODE);\n\tpriv_level = QLC_DEV_GET_DRV(op_mode, adapter->ahw->pci_func);\n\n\tif (op_mode == QLC_DEV_DRV_DEFAULT)\n\t\tpriv_level = QLCNIC_MGMT_FUNC;\n\telse\n\t\tpriv_level = QLC_DEV_GET_DRV(op_mode, adapter->ahw->pci_func);\n\n\tif (adapter->flags & QLCNIC_ESWITCH_ENABLED) {\n\t\tif (priv_level == QLCNIC_MGMT_FUNC) {\n\t\t\tadapter->ahw->op_mode = QLCNIC_MGMT_FUNC;\n\t\t\terr = qlcnic_init_pci_info(adapter);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\t \n\t\t\tqlcnic_set_function_modes(adapter);\n\t\t\tdev_info(&adapter->pdev->dev,\n\t\t\t\t\"HAL Version: %d, Management function\\n\",\n\t\t\t\t adapter->ahw->fw_hal_version);\n\t\t} else if (priv_level == QLCNIC_PRIV_FUNC) {\n\t\t\tadapter->ahw->op_mode = QLCNIC_PRIV_FUNC;\n\t\t\tdev_info(&adapter->pdev->dev,\n\t\t\t\t\"HAL Version: %d, Privileged function\\n\",\n\t\t\t\t adapter->ahw->fw_hal_version);\n\t\t}\n\t} else {\n\t\tadapter->ahw->nic_mode = QLCNIC_DEFAULT_MODE;\n\t}\n\n\tadapter->flags |= QLCNIC_ADAPTER_INITIALIZED;\n\n\treturn err;\n}\n\nint qlcnic_set_default_offload_settings(struct qlcnic_adapter *adapter)\n{\n\tstruct qlcnic_esw_func_cfg esw_cfg;\n\tstruct qlcnic_npar_info *npar;\n\tu8 i;\n\n\tif (adapter->need_fw_reset)\n\t\treturn 0;\n\n\tfor (i = 0; i < adapter->ahw->total_nic_func; i++) {\n\t\tif (!adapter->npars[i].eswitch_status)\n\t\t\tcontinue;\n\n\t\tmemset(&esw_cfg, 0, sizeof(struct qlcnic_esw_func_cfg));\n\t\tesw_cfg.pci_func = adapter->npars[i].pci_func;\n\t\tesw_cfg.mac_override = BIT_0;\n\t\tesw_cfg.promisc_mode = BIT_0;\n\t\tif (qlcnic_82xx_check(adapter)) {\n\t\t\tesw_cfg.offload_flags = BIT_0;\n\t\t\tif (QLCNIC_IS_TSO_CAPABLE(adapter))\n\t\t\t\tesw_cfg.offload_flags |= (BIT_1 | BIT_2);\n\t\t}\n\t\tif (qlcnic_config_switch_port(adapter, &esw_cfg))\n\t\t\treturn -EIO;\n\t\tnpar = &adapter->npars[i];\n\t\tnpar->pvid = esw_cfg.vlan_id;\n\t\tnpar->mac_override = esw_cfg.mac_override;\n\t\tnpar->mac_anti_spoof = esw_cfg.mac_anti_spoof;\n\t\tnpar->discard_tagged = esw_cfg.discard_tagged;\n\t\tnpar->promisc_mode = esw_cfg.promisc_mode;\n\t\tnpar->offload_flags = esw_cfg.offload_flags;\n\t}\n\n\treturn 0;\n}\n\n\nstatic int\nqlcnic_reset_eswitch_config(struct qlcnic_adapter *adapter,\n\t\t\tstruct qlcnic_npar_info *npar, int pci_func)\n{\n\tstruct qlcnic_esw_func_cfg esw_cfg;\n\tesw_cfg.op_mode = QLCNIC_PORT_DEFAULTS;\n\tesw_cfg.pci_func = pci_func;\n\tesw_cfg.vlan_id = npar->pvid;\n\tesw_cfg.mac_override = npar->mac_override;\n\tesw_cfg.discard_tagged = npar->discard_tagged;\n\tesw_cfg.mac_anti_spoof = npar->mac_anti_spoof;\n\tesw_cfg.offload_flags = npar->offload_flags;\n\tesw_cfg.promisc_mode = npar->promisc_mode;\n\tif (qlcnic_config_switch_port(adapter, &esw_cfg))\n\t\treturn -EIO;\n\n\tesw_cfg.op_mode = QLCNIC_ADD_VLAN;\n\tif (qlcnic_config_switch_port(adapter, &esw_cfg))\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nint qlcnic_reset_npar_config(struct qlcnic_adapter *adapter)\n{\n\tint i, err;\n\tstruct qlcnic_npar_info *npar;\n\tstruct qlcnic_info nic_info;\n\tu8 pci_func;\n\n\tif (qlcnic_82xx_check(adapter))\n\t\tif (!adapter->need_fw_reset)\n\t\t\treturn 0;\n\n\t \n\tfor (i = 0; i < adapter->ahw->total_nic_func; i++) {\n\t\tnpar = &adapter->npars[i];\n\t\tpci_func = npar->pci_func;\n\t\tif (!adapter->npars[i].eswitch_status)\n\t\t\tcontinue;\n\n\t\tmemset(&nic_info, 0, sizeof(struct qlcnic_info));\n\t\terr = qlcnic_get_nic_info(adapter, &nic_info, pci_func);\n\t\tif (err)\n\t\t\treturn err;\n\t\tnic_info.min_tx_bw = npar->min_bw;\n\t\tnic_info.max_tx_bw = npar->max_bw;\n\t\terr = qlcnic_set_nic_info(adapter, &nic_info);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (npar->enable_pm) {\n\t\t\terr = qlcnic_config_port_mirroring(adapter,\n\t\t\t\t\t\t\t   npar->dest_npar, 1,\n\t\t\t\t\t\t\t   pci_func);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\terr = qlcnic_reset_eswitch_config(adapter, npar, pci_func);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n\nstatic int qlcnic_check_npar_opertional(struct qlcnic_adapter *adapter)\n{\n\tu8 npar_opt_timeo = QLCNIC_DEV_NPAR_OPER_TIMEO;\n\tu32 npar_state;\n\n\tif (adapter->ahw->op_mode == QLCNIC_MGMT_FUNC)\n\t\treturn 0;\n\n\tnpar_state = QLC_SHARED_REG_RD32(adapter,\n\t\t\t\t\t QLCNIC_CRB_DEV_NPAR_STATE);\n\twhile (npar_state != QLCNIC_DEV_NPAR_OPER && --npar_opt_timeo) {\n\t\tmsleep(1000);\n\t\tnpar_state = QLC_SHARED_REG_RD32(adapter,\n\t\t\t\t\t\t QLCNIC_CRB_DEV_NPAR_STATE);\n\t}\n\tif (!npar_opt_timeo) {\n\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\"Waiting for NPAR state to operational timeout\\n\");\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}\n\nstatic int\nqlcnic_set_mgmt_operations(struct qlcnic_adapter *adapter)\n{\n\tint err;\n\n\tif (!(adapter->flags & QLCNIC_ESWITCH_ENABLED) ||\n\t    adapter->ahw->op_mode != QLCNIC_MGMT_FUNC)\n\t\treturn 0;\n\n\terr = qlcnic_set_default_offload_settings(adapter);\n\tif (err)\n\t\treturn err;\n\n\terr = qlcnic_reset_npar_config(adapter);\n\tif (err)\n\t\treturn err;\n\n\tqlcnic_dev_set_npar_ready(adapter);\n\n\treturn err;\n}\n\nstatic int qlcnic_82xx_start_firmware(struct qlcnic_adapter *adapter)\n{\n\tint err;\n\n\terr = qlcnic_can_start_firmware(adapter);\n\tif (err < 0)\n\t\treturn err;\n\telse if (!err)\n\t\tgoto check_fw_status;\n\n\tif (qlcnic_load_fw_file)\n\t\tqlcnic_request_firmware(adapter);\n\telse {\n\t\terr = qlcnic_check_flash_fw_ver(adapter);\n\t\tif (err)\n\t\t\tgoto err_out;\n\n\t\tadapter->ahw->fw_type = QLCNIC_FLASH_ROMIMAGE;\n\t}\n\n\terr = qlcnic_need_fw_reset(adapter);\n\tif (err == 0)\n\t\tgoto check_fw_status;\n\n\terr = qlcnic_pinit_from_rom(adapter);\n\tif (err)\n\t\tgoto err_out;\n\n\terr = qlcnic_load_firmware(adapter);\n\tif (err)\n\t\tgoto err_out;\n\n\tqlcnic_release_firmware(adapter);\n\tQLCWR32(adapter, CRB_DRIVER_VERSION, QLCNIC_DRIVER_VERSION);\n\ncheck_fw_status:\n\terr = qlcnic_check_fw_status(adapter);\n\tif (err)\n\t\tgoto err_out;\n\n\tQLC_SHARED_REG_WR32(adapter, QLCNIC_CRB_DEV_STATE, QLCNIC_DEV_READY);\n\tqlcnic_idc_debug_info(adapter, 1);\n\terr = qlcnic_check_eswitch_mode(adapter);\n\tif (err) {\n\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\"Memory allocation failed for eswitch\\n\");\n\t\tgoto err_out;\n\t}\n\terr = qlcnic_set_mgmt_operations(adapter);\n\tif (err)\n\t\tgoto err_out;\n\n\tqlcnic_check_options(adapter);\n\tadapter->need_fw_reset = 0;\n\n\tqlcnic_release_firmware(adapter);\n\treturn 0;\n\nerr_out:\n\tQLC_SHARED_REG_WR32(adapter, QLCNIC_CRB_DEV_STATE, QLCNIC_DEV_FAILED);\n\tdev_err(&adapter->pdev->dev, \"Device state set to failed\\n\");\n\n\tqlcnic_release_firmware(adapter);\n\treturn err;\n}\n\nstatic int\nqlcnic_request_irq(struct qlcnic_adapter *adapter)\n{\n\tirq_handler_t handler;\n\tstruct qlcnic_host_sds_ring *sds_ring;\n\tstruct qlcnic_host_tx_ring *tx_ring;\n\tint err, ring, num_sds_rings;\n\n\tunsigned long flags = 0;\n\tstruct net_device *netdev = adapter->netdev;\n\tstruct qlcnic_recv_context *recv_ctx = adapter->recv_ctx;\n\n\tif (adapter->ahw->diag_test == QLCNIC_INTERRUPT_TEST) {\n\t\tif (qlcnic_82xx_check(adapter))\n\t\t\thandler = qlcnic_tmp_intr;\n\t\telse\n\t\t\thandler = qlcnic_83xx_tmp_intr;\n\t\tif (!QLCNIC_IS_MSI_FAMILY(adapter))\n\t\t\tflags |= IRQF_SHARED;\n\n\t} else {\n\t\tif (adapter->flags & QLCNIC_MSIX_ENABLED)\n\t\t\thandler = qlcnic_msix_intr;\n\t\telse if (adapter->flags & QLCNIC_MSI_ENABLED)\n\t\t\thandler = qlcnic_msi_intr;\n\t\telse {\n\t\t\tflags |= IRQF_SHARED;\n\t\t\tif (qlcnic_82xx_check(adapter))\n\t\t\t\thandler = qlcnic_intr;\n\t\t\telse\n\t\t\t\thandler = qlcnic_83xx_intr;\n\t\t}\n\t}\n\tadapter->irq = netdev->irq;\n\n\tif (adapter->ahw->diag_test != QLCNIC_LOOPBACK_TEST) {\n\t\tif (qlcnic_82xx_check(adapter) ||\n\t\t    (qlcnic_83xx_check(adapter) &&\n\t\t     (adapter->flags & QLCNIC_MSIX_ENABLED))) {\n\t\t\tnum_sds_rings = adapter->drv_sds_rings;\n\t\t\tfor (ring = 0; ring < num_sds_rings; ring++) {\n\t\t\t\tsds_ring = &recv_ctx->sds_rings[ring];\n\t\t\t\tif (qlcnic_82xx_check(adapter) &&\n\t\t\t\t    !qlcnic_check_multi_tx(adapter) &&\n\t\t\t\t    (ring == (num_sds_rings - 1))) {\n\t\t\t\t\tif (!(adapter->flags &\n\t\t\t\t\t      QLCNIC_MSIX_ENABLED))\n\t\t\t\t\t\tsnprintf(sds_ring->name,\n\t\t\t\t\t\t\t sizeof(sds_ring->name),\n\t\t\t\t\t\t\t \"qlcnic\");\n\t\t\t\t\telse\n\t\t\t\t\t\tsnprintf(sds_ring->name,\n\t\t\t\t\t\t\t sizeof(sds_ring->name),\n\t\t\t\t\t\t\t \"%s-tx-0-rx-%d\",\n\t\t\t\t\t\t\t netdev->name, ring);\n\t\t\t\t} else {\n\t\t\t\t\tsnprintf(sds_ring->name,\n\t\t\t\t\t\t sizeof(sds_ring->name),\n\t\t\t\t\t\t \"%s-rx-%d\",\n\t\t\t\t\t\t netdev->name, ring);\n\t\t\t\t}\n\t\t\t\terr = request_irq(sds_ring->irq, handler, flags,\n\t\t\t\t\t\t  sds_ring->name, sds_ring);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\t\tif ((qlcnic_82xx_check(adapter) &&\n\t\t     qlcnic_check_multi_tx(adapter)) ||\n\t\t    (qlcnic_83xx_check(adapter) &&\n\t\t     (adapter->flags & QLCNIC_MSIX_ENABLED) &&\n\t\t     !(adapter->flags & QLCNIC_TX_INTR_SHARED))) {\n\t\t\thandler = qlcnic_msix_tx_intr;\n\t\t\tfor (ring = 0; ring < adapter->drv_tx_rings;\n\t\t\t     ring++) {\n\t\t\t\ttx_ring = &adapter->tx_ring[ring];\n\t\t\t\tsnprintf(tx_ring->name, sizeof(tx_ring->name),\n\t\t\t\t\t \"%s-tx-%d\", netdev->name, ring);\n\t\t\t\terr = request_irq(tx_ring->irq, handler, flags,\n\t\t\t\t\t\t  tx_ring->name, tx_ring);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void\nqlcnic_free_irq(struct qlcnic_adapter *adapter)\n{\n\tint ring;\n\tstruct qlcnic_host_sds_ring *sds_ring;\n\tstruct qlcnic_host_tx_ring *tx_ring;\n\n\tstruct qlcnic_recv_context *recv_ctx = adapter->recv_ctx;\n\n\tif (adapter->ahw->diag_test != QLCNIC_LOOPBACK_TEST) {\n\t\tif (qlcnic_82xx_check(adapter) ||\n\t\t    (qlcnic_83xx_check(adapter) &&\n\t\t     (adapter->flags & QLCNIC_MSIX_ENABLED))) {\n\t\t\tfor (ring = 0; ring < adapter->drv_sds_rings; ring++) {\n\t\t\t\tsds_ring = &recv_ctx->sds_rings[ring];\n\t\t\t\tfree_irq(sds_ring->irq, sds_ring);\n\t\t\t}\n\t\t}\n\t\tif ((qlcnic_83xx_check(adapter) &&\n\t\t     !(adapter->flags & QLCNIC_TX_INTR_SHARED)) ||\n\t\t    (qlcnic_82xx_check(adapter) &&\n\t\t     qlcnic_check_multi_tx(adapter))) {\n\t\t\tfor (ring = 0; ring < adapter->drv_tx_rings;\n\t\t\t     ring++) {\n\t\t\t\ttx_ring = &adapter->tx_ring[ring];\n\t\t\t\tif (tx_ring->irq)\n\t\t\t\t\tfree_irq(tx_ring->irq, tx_ring);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void qlcnic_get_lro_mss_capability(struct qlcnic_adapter *adapter)\n{\n\tu32 capab = 0;\n\n\tif (qlcnic_82xx_check(adapter)) {\n\t\tif (adapter->ahw->extra_capability[0] &\n\t\t    QLCNIC_FW_CAPABILITY_2_LRO_MAX_TCP_SEG)\n\t\t\tadapter->flags |= QLCNIC_FW_LRO_MSS_CAP;\n\t} else {\n\t\tcapab = adapter->ahw->capabilities;\n\t\tif (QLC_83XX_GET_FW_LRO_MSS_CAPABILITY(capab))\n\t\t\tadapter->flags |= QLCNIC_FW_LRO_MSS_CAP;\n\t}\n}\n\nstatic int qlcnic_config_def_intr_coalesce(struct qlcnic_adapter *adapter)\n{\n\tstruct qlcnic_hardware_context *ahw = adapter->ahw;\n\tint err;\n\n\t \n\tahw->coal.flag = QLCNIC_INTR_DEFAULT;\n\n\tif (qlcnic_83xx_check(adapter)) {\n\t\tahw->coal.type = QLCNIC_INTR_COAL_TYPE_RX_TX;\n\t\tahw->coal.tx_time_us = QLCNIC_DEF_INTR_COALESCE_TX_TIME_US;\n\t\tahw->coal.tx_packets = QLCNIC_DEF_INTR_COALESCE_TX_PACKETS;\n\t\tahw->coal.rx_time_us = QLCNIC_DEF_INTR_COALESCE_RX_TIME_US;\n\t\tahw->coal.rx_packets = QLCNIC_DEF_INTR_COALESCE_RX_PACKETS;\n\n\t\terr = qlcnic_83xx_set_rx_tx_intr_coal(adapter);\n\t} else {\n\t\tahw->coal.type = QLCNIC_INTR_COAL_TYPE_RX;\n\t\tahw->coal.rx_time_us = QLCNIC_DEF_INTR_COALESCE_RX_TIME_US;\n\t\tahw->coal.rx_packets = QLCNIC_DEF_INTR_COALESCE_RX_PACKETS;\n\n\t\terr = qlcnic_82xx_set_rx_coalesce(adapter);\n\t}\n\n\treturn err;\n}\n\nint __qlcnic_up(struct qlcnic_adapter *adapter, struct net_device *netdev)\n{\n\tint ring;\n\tstruct qlcnic_host_rds_ring *rds_ring;\n\n\tif (adapter->is_up != QLCNIC_ADAPTER_UP_MAGIC)\n\t\treturn -EIO;\n\n\tif (test_bit(__QLCNIC_DEV_UP, &adapter->state))\n\t\treturn 0;\n\n\tif (qlcnic_set_eswitch_port_config(adapter))\n\t\treturn -EIO;\n\n\tqlcnic_get_lro_mss_capability(adapter);\n\n\tif (qlcnic_fw_create_ctx(adapter))\n\t\treturn -EIO;\n\n\tfor (ring = 0; ring < adapter->max_rds_rings; ring++) {\n\t\trds_ring = &adapter->recv_ctx->rds_rings[ring];\n\t\tqlcnic_post_rx_buffers(adapter, rds_ring, ring);\n\t}\n\n\tqlcnic_set_multi(netdev);\n\tqlcnic_fw_cmd_set_mtu(adapter, netdev->mtu);\n\n\tadapter->ahw->linkup = 0;\n\n\tif (adapter->drv_sds_rings > 1)\n\t\tqlcnic_config_rss(adapter, 1);\n\n\tqlcnic_config_def_intr_coalesce(adapter);\n\n\tif (netdev->features & NETIF_F_LRO)\n\t\tqlcnic_config_hw_lro(adapter, QLCNIC_LRO_ENABLED);\n\n\tset_bit(__QLCNIC_DEV_UP, &adapter->state);\n\tqlcnic_napi_enable(adapter);\n\n\tqlcnic_linkevent_request(adapter, 1);\n\n\tadapter->ahw->reset_context = 0;\n\tnetif_tx_start_all_queues(netdev);\n\treturn 0;\n}\n\nint qlcnic_up(struct qlcnic_adapter *adapter, struct net_device *netdev)\n{\n\tint err = 0;\n\n\trtnl_lock();\n\tif (netif_running(netdev))\n\t\terr = __qlcnic_up(adapter, netdev);\n\trtnl_unlock();\n\n\treturn err;\n}\n\nvoid __qlcnic_down(struct qlcnic_adapter *adapter, struct net_device *netdev)\n{\n\tint ring;\n\n\tif (adapter->is_up != QLCNIC_ADAPTER_UP_MAGIC)\n\t\treturn;\n\n\tif (!test_and_clear_bit(__QLCNIC_DEV_UP, &adapter->state))\n\t\treturn;\n\n\tsmp_mb();\n\tnetif_carrier_off(netdev);\n\tadapter->ahw->linkup = 0;\n\tnetif_tx_disable(netdev);\n\n\tqlcnic_free_mac_list(adapter);\n\n\tif (adapter->fhash.fnum)\n\t\tqlcnic_delete_lb_filters(adapter);\n\n\tqlcnic_nic_set_promisc(adapter, QLCNIC_NIU_NON_PROMISC_MODE);\n\tif (qlcnic_sriov_vf_check(adapter))\n\t\tqlcnic_sriov_cleanup_async_list(&adapter->ahw->sriov->bc);\n\n\tqlcnic_napi_disable(adapter);\n\n\tqlcnic_fw_destroy_ctx(adapter);\n\tadapter->flags &= ~QLCNIC_FW_LRO_MSS_CAP;\n\n\tqlcnic_reset_rx_buffers_list(adapter);\n\n\tfor (ring = 0; ring < adapter->drv_tx_rings; ring++)\n\t\tqlcnic_release_tx_buffers(adapter, &adapter->tx_ring[ring]);\n}\n\n \n\nvoid qlcnic_down(struct qlcnic_adapter *adapter, struct net_device *netdev)\n{\n\trtnl_lock();\n\tif (netif_running(netdev))\n\t\t__qlcnic_down(adapter, netdev);\n\trtnl_unlock();\n\n}\n\nint\nqlcnic_attach(struct qlcnic_adapter *adapter)\n{\n\tstruct net_device *netdev = adapter->netdev;\n\tstruct pci_dev *pdev = adapter->pdev;\n\tint err;\n\n\tif (adapter->is_up == QLCNIC_ADAPTER_UP_MAGIC)\n\t\treturn 0;\n\n\terr = qlcnic_napi_add(adapter, netdev);\n\tif (err)\n\t\treturn err;\n\n\terr = qlcnic_alloc_sw_resources(adapter);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Error in setting sw resources\\n\");\n\t\tgoto err_out_napi_del;\n\t}\n\n\terr = qlcnic_alloc_hw_resources(adapter);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Error in setting hw resources\\n\");\n\t\tgoto err_out_free_sw;\n\t}\n\n\terr = qlcnic_request_irq(adapter);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"failed to setup interrupt\\n\");\n\t\tgoto err_out_free_hw;\n\t}\n\n\tqlcnic_create_sysfs_entries(adapter);\n\n\tif (qlcnic_encap_rx_offload(adapter))\n\t\tudp_tunnel_nic_reset_ntf(netdev);\n\n\tadapter->is_up = QLCNIC_ADAPTER_UP_MAGIC;\n\treturn 0;\n\nerr_out_free_hw:\n\tqlcnic_free_hw_resources(adapter);\nerr_out_free_sw:\n\tqlcnic_free_sw_resources(adapter);\nerr_out_napi_del:\n\tqlcnic_napi_del(adapter);\n\treturn err;\n}\n\nvoid qlcnic_detach(struct qlcnic_adapter *adapter)\n{\n\tif (adapter->is_up != QLCNIC_ADAPTER_UP_MAGIC)\n\t\treturn;\n\n\tqlcnic_remove_sysfs_entries(adapter);\n\n\tqlcnic_free_hw_resources(adapter);\n\tqlcnic_release_rx_buffers(adapter);\n\tqlcnic_free_irq(adapter);\n\tqlcnic_napi_del(adapter);\n\tqlcnic_free_sw_resources(adapter);\n\n\tadapter->is_up = 0;\n}\n\nvoid qlcnic_diag_free_res(struct net_device *netdev, int drv_sds_rings)\n{\n\tstruct qlcnic_adapter *adapter = netdev_priv(netdev);\n\tstruct qlcnic_host_sds_ring *sds_ring;\n\tint drv_tx_rings = adapter->drv_tx_rings;\n\tint ring;\n\n\tclear_bit(__QLCNIC_DEV_UP, &adapter->state);\n\tif (adapter->ahw->diag_test == QLCNIC_INTERRUPT_TEST) {\n\t\tfor (ring = 0; ring < adapter->drv_sds_rings; ring++) {\n\t\t\tsds_ring = &adapter->recv_ctx->sds_rings[ring];\n\t\t\tqlcnic_disable_sds_intr(adapter, sds_ring);\n\t\t}\n\t}\n\n\tqlcnic_fw_destroy_ctx(adapter);\n\n\tqlcnic_detach(adapter);\n\n\tadapter->ahw->diag_test = 0;\n\tadapter->drv_sds_rings = drv_sds_rings;\n\tadapter->drv_tx_rings = drv_tx_rings;\n\n\tif (qlcnic_attach(adapter))\n\t\tgoto out;\n\n\tif (netif_running(netdev))\n\t\t__qlcnic_up(adapter, netdev);\nout:\n\tnetif_device_attach(netdev);\n}\n\nstatic int qlcnic_alloc_adapter_resources(struct qlcnic_adapter *adapter)\n{\n\tstruct qlcnic_hardware_context *ahw = adapter->ahw;\n\tint err = 0;\n\n\tadapter->recv_ctx = kzalloc(sizeof(struct qlcnic_recv_context),\n\t\t\t\tGFP_KERNEL);\n\tif (!adapter->recv_ctx) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\n\tif (qlcnic_83xx_check(adapter)) {\n\t\tahw->coal.type = QLCNIC_INTR_COAL_TYPE_RX_TX;\n\t\tahw->coal.tx_time_us = QLCNIC_DEF_INTR_COALESCE_TX_TIME_US;\n\t\tahw->coal.tx_packets = QLCNIC_DEF_INTR_COALESCE_TX_PACKETS;\n\t\tahw->coal.rx_time_us = QLCNIC_DEF_INTR_COALESCE_RX_TIME_US;\n\t\tahw->coal.rx_packets = QLCNIC_DEF_INTR_COALESCE_RX_PACKETS;\n\t} else {\n\t\tahw->coal.type = QLCNIC_INTR_COAL_TYPE_RX;\n\t\tahw->coal.rx_time_us = QLCNIC_DEF_INTR_COALESCE_RX_TIME_US;\n\t\tahw->coal.rx_packets = QLCNIC_DEF_INTR_COALESCE_RX_PACKETS;\n\t}\n\n\t \n\tmemset(&adapter->stats, 0, sizeof(adapter->stats));\nerr_out:\n\treturn err;\n}\n\nstatic void qlcnic_free_adapter_resources(struct qlcnic_adapter *adapter)\n{\n\tstruct qlcnic_fw_dump *fw_dump = &adapter->ahw->fw_dump;\n\n\tkfree(adapter->recv_ctx);\n\tadapter->recv_ctx = NULL;\n\n\tif (fw_dump->tmpl_hdr) {\n\t\tvfree(fw_dump->tmpl_hdr);\n\t\tfw_dump->tmpl_hdr = NULL;\n\t}\n\n\tif (fw_dump->dma_buffer) {\n\t\tdma_free_coherent(&adapter->pdev->dev, QLC_PEX_DMA_READ_SIZE,\n\t\t\t\t  fw_dump->dma_buffer, fw_dump->phys_addr);\n\t\tfw_dump->dma_buffer = NULL;\n\t}\n\n\tkfree(adapter->ahw->reset.buff);\n\tadapter->ahw->fw_dump.tmpl_hdr = NULL;\n}\n\nint qlcnic_diag_alloc_res(struct net_device *netdev, int test)\n{\n\tstruct qlcnic_adapter *adapter = netdev_priv(netdev);\n\tstruct qlcnic_host_sds_ring *sds_ring;\n\tstruct qlcnic_host_rds_ring *rds_ring;\n\tint ring;\n\tint ret;\n\n\tnetif_device_detach(netdev);\n\n\tif (netif_running(netdev))\n\t\t__qlcnic_down(adapter, netdev);\n\n\tqlcnic_detach(adapter);\n\n\tadapter->drv_sds_rings = QLCNIC_SINGLE_RING;\n\tadapter->ahw->diag_test = test;\n\tadapter->ahw->linkup = 0;\n\n\tret = qlcnic_attach(adapter);\n\tif (ret) {\n\t\tnetif_device_attach(netdev);\n\t\treturn ret;\n\t}\n\n\tret = qlcnic_fw_create_ctx(adapter);\n\tif (ret) {\n\t\tqlcnic_detach(adapter);\n\t\tnetif_device_attach(netdev);\n\t\treturn ret;\n\t}\n\n\tfor (ring = 0; ring < adapter->max_rds_rings; ring++) {\n\t\trds_ring = &adapter->recv_ctx->rds_rings[ring];\n\t\tqlcnic_post_rx_buffers(adapter, rds_ring, ring);\n\t}\n\n\tif (adapter->ahw->diag_test == QLCNIC_INTERRUPT_TEST) {\n\t\tfor (ring = 0; ring < adapter->drv_sds_rings; ring++) {\n\t\t\tsds_ring = &adapter->recv_ctx->sds_rings[ring];\n\t\t\tqlcnic_enable_sds_intr(adapter, sds_ring);\n\t\t}\n\t}\n\n\tif (adapter->ahw->diag_test == QLCNIC_LOOPBACK_TEST) {\n\t\tadapter->ahw->loopback_state = 0;\n\t\tqlcnic_linkevent_request(adapter, 1);\n\t}\n\n\tset_bit(__QLCNIC_DEV_UP, &adapter->state);\n\n\treturn 0;\n}\n\n \nstatic int\nqlcnic_reset_hw_context(struct qlcnic_adapter *adapter)\n{\n\tstruct net_device *netdev = adapter->netdev;\n\n\tif (test_and_set_bit(__QLCNIC_RESETTING, &adapter->state))\n\t\treturn -EBUSY;\n\n\tnetif_device_detach(netdev);\n\n\tqlcnic_down(adapter, netdev);\n\n\tqlcnic_up(adapter, netdev);\n\n\tnetif_device_attach(netdev);\n\n\tclear_bit(__QLCNIC_RESETTING, &adapter->state);\n\tnetdev_info(adapter->netdev, \"%s: soft reset complete\\n\", __func__);\n\treturn 0;\n}\n\nint\nqlcnic_reset_context(struct qlcnic_adapter *adapter)\n{\n\tint err = 0;\n\tstruct net_device *netdev = adapter->netdev;\n\n\tif (test_and_set_bit(__QLCNIC_RESETTING, &adapter->state))\n\t\treturn -EBUSY;\n\n\tif (adapter->is_up == QLCNIC_ADAPTER_UP_MAGIC) {\n\n\t\tnetif_device_detach(netdev);\n\n\t\tif (netif_running(netdev))\n\t\t\t__qlcnic_down(adapter, netdev);\n\n\t\tqlcnic_detach(adapter);\n\n\t\tif (netif_running(netdev)) {\n\t\t\terr = qlcnic_attach(adapter);\n\t\t\tif (!err) {\n\t\t\t\t__qlcnic_up(adapter, netdev);\n\t\t\t\tqlcnic_restore_indev_addr(netdev, NETDEV_UP);\n\t\t\t}\n\t\t}\n\n\t\tnetif_device_attach(netdev);\n\t}\n\n\tclear_bit(__QLCNIC_RESETTING, &adapter->state);\n\treturn err;\n}\n\nstatic void qlcnic_82xx_set_mac_filter_count(struct qlcnic_adapter *adapter)\n{\n\tstruct qlcnic_hardware_context *ahw = adapter->ahw;\n\tu16 act_pci_fn = ahw->total_nic_func;\n\tu16 count;\n\n\tahw->max_mc_count = QLCNIC_MAX_MC_COUNT;\n\tif (act_pci_fn <= 2)\n\t\tcount = (QLCNIC_MAX_UC_COUNT - QLCNIC_MAX_MC_COUNT) /\n\t\t\t act_pci_fn;\n\telse\n\t\tcount = (QLCNIC_LB_MAX_FILTERS - QLCNIC_MAX_MC_COUNT) /\n\t\t\t act_pci_fn;\n\tahw->max_uc_count = count;\n}\n\nstatic int qlcnic_set_real_num_queues(struct qlcnic_adapter *adapter,\n\t\t\t\t      u8 tx_queues, u8 rx_queues)\n{\n\tstruct net_device *netdev = adapter->netdev;\n\tint err = 0;\n\n\tif (tx_queues) {\n\t\terr = netif_set_real_num_tx_queues(netdev, tx_queues);\n\t\tif (err) {\n\t\t\tnetdev_err(netdev, \"failed to set %d Tx queues\\n\",\n\t\t\t\t   tx_queues);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tif (rx_queues) {\n\t\terr = netif_set_real_num_rx_queues(netdev, rx_queues);\n\t\tif (err)\n\t\t\tnetdev_err(netdev, \"failed to set %d Rx queues\\n\",\n\t\t\t\t   rx_queues);\n\t}\n\n\treturn err;\n}\n\nint\nqlcnic_setup_netdev(struct qlcnic_adapter *adapter, struct net_device *netdev)\n{\n\tint err;\n\tstruct pci_dev *pdev = adapter->pdev;\n\n\tadapter->rx_csum = 1;\n\tadapter->ahw->mc_enabled = 0;\n\tqlcnic_set_mac_filter_count(adapter);\n\n\tnetdev->netdev_ops\t   = &qlcnic_netdev_ops;\n\tnetdev->watchdog_timeo     = QLCNIC_WATCHDOG_TIMEOUTVALUE * HZ;\n\n\tqlcnic_change_mtu(netdev, netdev->mtu);\n\n\tnetdev->ethtool_ops = (qlcnic_sriov_vf_check(adapter)) ?\n\t\t&qlcnic_sriov_vf_ethtool_ops : &qlcnic_ethtool_ops;\n\n\tnetdev->features |= (NETIF_F_SG | NETIF_F_IP_CSUM | NETIF_F_RXCSUM |\n\t\t\t     NETIF_F_IPV6_CSUM | NETIF_F_GRO |\n\t\t\t     NETIF_F_HW_VLAN_CTAG_RX | NETIF_F_HIGHDMA);\n\tnetdev->vlan_features |= (NETIF_F_SG | NETIF_F_IP_CSUM |\n\t\t\t\t  NETIF_F_IPV6_CSUM | NETIF_F_HIGHDMA);\n\n\tif (QLCNIC_IS_TSO_CAPABLE(adapter)) {\n\t\tnetdev->features |= (NETIF_F_TSO | NETIF_F_TSO6);\n\t\tnetdev->vlan_features |= (NETIF_F_TSO | NETIF_F_TSO6);\n\t}\n\n\tif (qlcnic_vlan_tx_check(adapter))\n\t\tnetdev->features |= (NETIF_F_HW_VLAN_CTAG_TX);\n\n\tif (qlcnic_sriov_vf_check(adapter))\n\t\tnetdev->features |= NETIF_F_HW_VLAN_CTAG_FILTER;\n\n\tif (adapter->ahw->capabilities & QLCNIC_FW_CAPABILITY_HW_LRO)\n\t\tnetdev->features |= NETIF_F_LRO;\n\n\tif (qlcnic_encap_tx_offload(adapter)) {\n\t\tnetdev->features |= NETIF_F_GSO_UDP_TUNNEL;\n\n\t\t \n\t\tnetdev->hw_enc_features = NETIF_F_IP_CSUM        |\n\t\t\t\t\t  NETIF_F_GSO_UDP_TUNNEL |\n\t\t\t\t\t  NETIF_F_TSO            |\n\t\t\t\t\t  NETIF_F_TSO6;\n\t}\n\n\tif (qlcnic_encap_rx_offload(adapter)) {\n\t\tnetdev->hw_enc_features |= NETIF_F_RXCSUM;\n\n\t\tnetdev->udp_tunnel_nic_info = &qlcnic_udp_tunnels;\n\t}\n\n\tnetdev->hw_features = netdev->features;\n\tnetdev->priv_flags |= IFF_UNICAST_FLT;\n\tnetdev->irq = adapter->msix_entries[0].vector;\n\n\t \n\tnetdev->min_mtu = P3P_MIN_MTU;\n\tnetdev->max_mtu = P3P_MAX_MTU;\n\n\terr = qlcnic_set_real_num_queues(adapter, adapter->drv_tx_rings,\n\t\t\t\t\t adapter->drv_sds_rings);\n\tif (err)\n\t\treturn err;\n\n\tqlcnic_dcb_init_dcbnl_ops(adapter->dcb);\n\n\terr = register_netdev(netdev);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"failed to register net device\\n\");\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nvoid qlcnic_free_tx_rings(struct qlcnic_adapter *adapter)\n{\n\tint ring;\n\tstruct qlcnic_host_tx_ring *tx_ring;\n\n\tfor (ring = 0; ring < adapter->drv_tx_rings; ring++) {\n\t\ttx_ring = &adapter->tx_ring[ring];\n\t\tif (tx_ring) {\n\t\t\tvfree(tx_ring->cmd_buf_arr);\n\t\t\ttx_ring->cmd_buf_arr = NULL;\n\t\t}\n\t}\n\tkfree(adapter->tx_ring);\n}\n\nint qlcnic_alloc_tx_rings(struct qlcnic_adapter *adapter,\n\t\t\t  struct net_device *netdev)\n{\n\tint ring, vector, index;\n\tstruct qlcnic_host_tx_ring *tx_ring;\n\tstruct qlcnic_cmd_buffer *cmd_buf_arr;\n\n\ttx_ring = kcalloc(adapter->drv_tx_rings,\n\t\t\t  sizeof(struct qlcnic_host_tx_ring), GFP_KERNEL);\n\tif (tx_ring == NULL)\n\t\treturn -ENOMEM;\n\n\tadapter->tx_ring = tx_ring;\n\n\tfor (ring = 0; ring < adapter->drv_tx_rings; ring++) {\n\t\ttx_ring = &adapter->tx_ring[ring];\n\t\ttx_ring->num_desc = adapter->num_txd;\n\t\ttx_ring->txq = netdev_get_tx_queue(netdev, ring);\n\t\tcmd_buf_arr = vzalloc(TX_BUFF_RINGSIZE(tx_ring));\n\t\tif (cmd_buf_arr == NULL) {\n\t\t\tqlcnic_free_tx_rings(adapter);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\ttx_ring->cmd_buf_arr = cmd_buf_arr;\n\t\tspin_lock_init(&tx_ring->tx_clean_lock);\n\t}\n\n\tif (qlcnic_83xx_check(adapter) ||\n\t    (qlcnic_82xx_check(adapter) && qlcnic_check_multi_tx(adapter))) {\n\t\tfor (ring = 0; ring < adapter->drv_tx_rings; ring++) {\n\t\t\ttx_ring = &adapter->tx_ring[ring];\n\t\t\ttx_ring->adapter = adapter;\n\t\t\tif (adapter->flags & QLCNIC_MSIX_ENABLED) {\n\t\t\t\tindex = adapter->drv_sds_rings + ring;\n\t\t\t\tvector = adapter->msix_entries[index].vector;\n\t\t\t\ttx_ring->irq = vector;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nvoid qlcnic_set_drv_version(struct qlcnic_adapter *adapter)\n{\n\tstruct qlcnic_hardware_context *ahw = adapter->ahw;\n\tu32 fw_cmd = 0;\n\n\tif (qlcnic_82xx_check(adapter))\n\t\tfw_cmd = QLCNIC_CMD_82XX_SET_DRV_VER;\n\telse if (qlcnic_83xx_check(adapter))\n\t\tfw_cmd = QLCNIC_CMD_83XX_SET_DRV_VER;\n\n\tif (ahw->extra_capability[0] & QLCNIC_FW_CAPABILITY_SET_DRV_VER)\n\t\tqlcnic_fw_cmd_set_drv_version(adapter, fw_cmd);\n}\n\n \nstatic void qlcnic_reset_api_lock(struct qlcnic_adapter *adapter)\n{\n\tqlcnic_api_lock(adapter);\n\tqlcnic_api_unlock(adapter);\n}\n\n\nstatic int\nqlcnic_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tstruct net_device *netdev = NULL;\n\tstruct qlcnic_adapter *adapter = NULL;\n\tstruct qlcnic_hardware_context *ahw;\n\tchar board_name[QLCNIC_MAX_BOARD_NAME_LEN + 19];  \n\tint err;\n\n\terr = pci_enable_device(pdev);\n\tif (err)\n\t\treturn err;\n\n\tif (!(pci_resource_flags(pdev, 0) & IORESOURCE_MEM)) {\n\t\terr = -ENODEV;\n\t\tgoto err_out_disable_pdev;\n\t}\n\n\terr = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(64));\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Unable to set DMA mask, aborting\\n\");\n\t\tgoto err_out_disable_pdev;\n\t}\n\n\terr = pci_request_regions(pdev, qlcnic_driver_name);\n\tif (err)\n\t\tgoto err_out_disable_pdev;\n\n\tpci_set_master(pdev);\n\n\tahw = kzalloc(sizeof(struct qlcnic_hardware_context), GFP_KERNEL);\n\tif (!ahw) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out_free_res;\n\t}\n\n\tswitch (ent->device) {\n\tcase PCI_DEVICE_ID_QLOGIC_QLE824X:\n\t\tahw->hw_ops = &qlcnic_hw_ops;\n\t\tahw->reg_tbl = (u32 *) qlcnic_reg_tbl;\n\t\tbreak;\n\tcase PCI_DEVICE_ID_QLOGIC_QLE834X:\n\tcase PCI_DEVICE_ID_QLOGIC_QLE8830:\n\tcase PCI_DEVICE_ID_QLOGIC_QLE844X:\n\t\tqlcnic_83xx_register_map(ahw);\n\t\tbreak;\n\tcase PCI_DEVICE_ID_QLOGIC_VF_QLE834X:\n\tcase PCI_DEVICE_ID_QLOGIC_VF_QLE8C30:\n\tcase PCI_DEVICE_ID_QLOGIC_VF_QLE844X:\n\t\tqlcnic_sriov_vf_register_map(ahw);\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t\tgoto err_out_free_hw_res;\n\t}\n\n\terr = qlcnic_setup_pci_map(pdev, ahw);\n\tif (err)\n\t\tgoto err_out_free_hw_res;\n\n\tnetdev = alloc_etherdev_mq(sizeof(struct qlcnic_adapter),\n\t\t\t\t   QLCNIC_MAX_TX_RINGS);\n\tif (!netdev) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out_iounmap;\n\t}\n\n\tSET_NETDEV_DEV(netdev, &pdev->dev);\n\n\tadapter = netdev_priv(netdev);\n\tadapter->netdev  = netdev;\n\tadapter->pdev    = pdev;\n\tadapter->ahw = ahw;\n\n\tadapter->qlcnic_wq = create_singlethread_workqueue(\"qlcnic\");\n\tif (adapter->qlcnic_wq == NULL) {\n\t\terr = -ENOMEM;\n\t\tdev_err(&pdev->dev, \"Failed to create workqueue\\n\");\n\t\tgoto err_out_free_netdev;\n\t}\n\n\terr = qlcnic_alloc_adapter_resources(adapter);\n\tif (err)\n\t\tgoto err_out_free_wq;\n\n\tadapter->dev_rst_time = jiffies;\n\tahw->revision_id = pdev->revision;\n\tahw->max_vnic_func = qlcnic_get_vnic_func_count(adapter);\n\tif (qlcnic_mac_learn == FDB_MAC_LEARN)\n\t\tadapter->fdb_mac_learn = true;\n\telse if (qlcnic_mac_learn == DRV_MAC_LEARN)\n\t\tadapter->drv_mac_learn = true;\n\n\trwlock_init(&adapter->ahw->crb_lock);\n\tmutex_init(&adapter->ahw->mem_lock);\n\n\tINIT_LIST_HEAD(&adapter->mac_list);\n\n\tqlcnic_register_dcb(adapter);\n\n\tif (qlcnic_82xx_check(adapter)) {\n\t\tqlcnic_check_vf(adapter, ent);\n\t\tadapter->portnum = adapter->ahw->pci_func;\n\t\tqlcnic_reset_api_lock(adapter);\n\t\terr = qlcnic_start_firmware(adapter);\n\t\tif (err) {\n\t\t\tdev_err(&pdev->dev, \"Loading fw failed.Please Reboot\\n\"\n\t\t\t\t\"\\t\\tIf reboot doesn't help, try flashing the card\\n\");\n\t\t\tgoto err_out_maintenance_mode;\n\t\t}\n\n\t\t \n\t\tif (adapter->ahw->msix_supported) {\n\t\t\tif (qlcnic_check_multi_tx_capability(adapter) == 1)\n\t\t\t\tqlcnic_set_tx_ring_count(adapter,\n\t\t\t\t\t\t\t QLCNIC_SINGLE_RING);\n\t\t\telse\n\t\t\t\tqlcnic_set_tx_ring_count(adapter,\n\t\t\t\t\t\t\t QLCNIC_DEF_TX_RINGS);\n\t\t\tqlcnic_set_sds_ring_count(adapter,\n\t\t\t\t\t\t  QLCNIC_DEF_SDS_RINGS);\n\t\t} else {\n\t\t\tqlcnic_set_tx_ring_count(adapter, QLCNIC_SINGLE_RING);\n\t\t\tqlcnic_set_sds_ring_count(adapter, QLCNIC_SINGLE_RING);\n\t\t}\n\n\t\terr = qlcnic_setup_idc_param(adapter);\n\t\tif (err)\n\t\t\tgoto err_out_free_hw;\n\n\t\tadapter->flags |= QLCNIC_NEED_FLR;\n\n\t} else if (qlcnic_83xx_check(adapter)) {\n\t\tqlcnic_83xx_check_vf(adapter, ent);\n\t\tadapter->portnum = adapter->ahw->pci_func;\n\t\terr = qlcnic_83xx_init(adapter);\n\t\tif (err) {\n\t\t\tswitch (err) {\n\t\t\tcase -ENOTRECOVERABLE:\n\t\t\t\tdev_err(&pdev->dev, \"Adapter initialization failed due to a faulty hardware\\n\");\n\t\t\t\tdev_err(&pdev->dev, \"Please replace the adapter with new one and return the faulty adapter for repair\\n\");\n\t\t\t\tgoto err_out_free_hw;\n\t\t\tcase -ENOMEM:\n\t\t\t\tdev_err(&pdev->dev, \"Adapter initialization failed. Please reboot\\n\");\n\t\t\t\tgoto err_out_free_hw;\n\t\t\tcase -EOPNOTSUPP:\n\t\t\t\tdev_err(&pdev->dev, \"Adapter initialization failed\\n\");\n\t\t\t\tgoto err_out_free_hw;\n\t\t\tdefault:\n\t\t\t\tdev_err(&pdev->dev, \"Adapter initialization failed. Driver will load in maintenance mode to recover the adapter using the application\\n\");\n\t\t\t\tgoto err_out_maintenance_mode;\n\t\t\t}\n\t\t}\n\n\t\tif (qlcnic_sriov_vf_check(adapter))\n\t\t\treturn 0;\n\t} else {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"%s: failed. Please Reboot\\n\", __func__);\n\t\terr = -ENODEV;\n\t\tgoto err_out_free_hw;\n\t}\n\n\tif (qlcnic_read_mac_addr(adapter))\n\t\tdev_warn(&pdev->dev, \"failed to read mac addr\\n\");\n\n\tqlcnic_read_phys_port_id(adapter);\n\n\tif (adapter->portnum == 0) {\n\t\tqlcnic_get_board_name(adapter, board_name);\n\n\t\tpr_info(\"%s: %s Board Chip rev 0x%x\\n\",\n\t\t\tmodule_name(THIS_MODULE),\n\t\t\tboard_name, adapter->ahw->revision_id);\n\t}\n\n\tif (qlcnic_83xx_check(adapter) && !qlcnic_use_msi_x &&\n\t    !!qlcnic_use_msi)\n\t\tdev_warn(&pdev->dev,\n\t\t\t \"Device does not support MSI interrupts\\n\");\n\n\tif (qlcnic_82xx_check(adapter)) {\n\t\terr = qlcnic_dcb_enable(adapter->dcb);\n\t\tif (err) {\n\t\t\tqlcnic_dcb_free(adapter->dcb);\n\t\t\tdev_err(&pdev->dev, \"Failed to enable DCB\\n\");\n\t\t\tgoto err_out_free_hw;\n\t\t}\n\n\t\tqlcnic_dcb_get_info(adapter->dcb);\n\t\terr = qlcnic_setup_intr(adapter);\n\n\t\tif (err) {\n\t\t\tdev_err(&pdev->dev, \"Failed to setup interrupt\\n\");\n\t\t\tgoto err_out_disable_msi;\n\t\t}\n\t}\n\n\terr = qlcnic_get_act_pci_func(adapter);\n\tif (err)\n\t\tgoto err_out_disable_mbx_intr;\n\n\tif (adapter->portnum == 0)\n\t\tqlcnic_set_drv_version(adapter);\n\n\terr = qlcnic_setup_netdev(adapter, netdev);\n\tif (err)\n\t\tgoto err_out_disable_mbx_intr;\n\n\tpci_set_drvdata(pdev, adapter);\n\n\tif (qlcnic_82xx_check(adapter))\n\t\tqlcnic_schedule_work(adapter, qlcnic_fw_poll_work,\n\t\t\t\t     FW_POLL_DELAY);\n\n\tswitch (adapter->ahw->port_type) {\n\tcase QLCNIC_GBE:\n\t\tdev_info(&adapter->pdev->dev, \"%s: GbE port initialized\\n\",\n\t\t\t\tadapter->netdev->name);\n\t\tbreak;\n\tcase QLCNIC_XGBE:\n\t\tdev_info(&adapter->pdev->dev, \"%s: XGbE port initialized\\n\",\n\t\t\t\tadapter->netdev->name);\n\t\tbreak;\n\t}\n\n\tif (adapter->drv_mac_learn)\n\t\tqlcnic_alloc_lb_filters_mem(adapter);\n\n\tqlcnic_add_sysfs(adapter);\n\tqlcnic_register_hwmon_dev(adapter);\n\treturn 0;\n\nerr_out_disable_mbx_intr:\n\tif (qlcnic_83xx_check(adapter))\n\t\tqlcnic_83xx_free_mbx_intr(adapter);\n\nerr_out_disable_msi:\n\tqlcnic_teardown_intr(adapter);\n\tqlcnic_cancel_idc_work(adapter);\n\tqlcnic_clr_all_drv_state(adapter, 0);\n\nerr_out_free_hw:\n\tqlcnic_free_adapter_resources(adapter);\n\nerr_out_free_wq:\n\tdestroy_workqueue(adapter->qlcnic_wq);\n\nerr_out_free_netdev:\n\tfree_netdev(netdev);\n\nerr_out_iounmap:\n\tqlcnic_cleanup_pci_map(ahw);\n\nerr_out_free_hw_res:\n\tkfree(ahw);\n\nerr_out_free_res:\n\tpci_release_regions(pdev);\n\nerr_out_disable_pdev:\n\tpci_disable_device(pdev);\n\treturn err;\n\nerr_out_maintenance_mode:\n\tset_bit(__QLCNIC_MAINTENANCE_MODE, &adapter->state);\n\tnetdev->netdev_ops = &qlcnic_netdev_failed_ops;\n\tnetdev->ethtool_ops = &qlcnic_ethtool_failed_ops;\n\tahw->port_type = QLCNIC_XGBE;\n\n\tif (qlcnic_83xx_check(adapter))\n\t\tadapter->tgt_status_reg = NULL;\n\telse\n\t\tahw->board_type = QLCNIC_BRDTYPE_P3P_10G_SFP_PLUS;\n\n\terr = register_netdev(netdev);\n\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Failed to register net device\\n\");\n\t\tqlcnic_clr_all_drv_state(adapter, 0);\n\t\tgoto err_out_free_hw;\n\t}\n\n\tpci_set_drvdata(pdev, adapter);\n\tqlcnic_add_sysfs(adapter);\n\n\treturn 0;\n}\n\nstatic void qlcnic_remove(struct pci_dev *pdev)\n{\n\tstruct qlcnic_adapter *adapter;\n\tstruct net_device *netdev;\n\tstruct qlcnic_hardware_context *ahw;\n\n\tadapter = pci_get_drvdata(pdev);\n\tif (adapter == NULL)\n\t\treturn;\n\n\tnetdev = adapter->netdev;\n\n\tqlcnic_cancel_idc_work(adapter);\n\tqlcnic_sriov_pf_disable(adapter);\n\tahw = adapter->ahw;\n\n\tunregister_netdev(netdev);\n\tqlcnic_sriov_cleanup(adapter);\n\n\tif (qlcnic_83xx_check(adapter)) {\n\t\tqlcnic_83xx_initialize_nic(adapter, 0);\n\t\tcancel_delayed_work_sync(&adapter->idc_aen_work);\n\t\tqlcnic_83xx_free_mbx_intr(adapter);\n\t\tqlcnic_83xx_detach_mailbox_work(adapter);\n\t\tqlcnic_83xx_free_mailbox(ahw->mailbox);\n\t\tkfree(ahw->fw_info);\n\t}\n\n\tqlcnic_dcb_free(adapter->dcb);\n\tqlcnic_detach(adapter);\n\tkfree(adapter->npars);\n\tkfree(adapter->eswitch);\n\n\tif (qlcnic_82xx_check(adapter))\n\t\tqlcnic_clr_all_drv_state(adapter, 0);\n\n\tclear_bit(__QLCNIC_RESETTING, &adapter->state);\n\n\tqlcnic_free_lb_filters_mem(adapter);\n\n\tqlcnic_teardown_intr(adapter);\n\n\tqlcnic_remove_sysfs(adapter);\n\n\tqlcnic_unregister_hwmon_dev(adapter);\n\n\tqlcnic_cleanup_pci_map(adapter->ahw);\n\n\tqlcnic_release_firmware(adapter);\n\n\tpci_release_regions(pdev);\n\tpci_disable_device(pdev);\n\n\tif (adapter->qlcnic_wq) {\n\t\tdestroy_workqueue(adapter->qlcnic_wq);\n\t\tadapter->qlcnic_wq = NULL;\n\t}\n\n\tqlcnic_free_adapter_resources(adapter);\n\tkfree(ahw);\n\tfree_netdev(netdev);\n}\n\nstatic void qlcnic_shutdown(struct pci_dev *pdev)\n{\n\tif (__qlcnic_shutdown(pdev))\n\t\treturn;\n\n\tpci_disable_device(pdev);\n}\n\nstatic int __maybe_unused qlcnic_suspend(struct device *dev_d)\n{\n\treturn __qlcnic_shutdown(to_pci_dev(dev_d));\n}\n\nstatic int __maybe_unused qlcnic_resume(struct device *dev_d)\n{\n\tstruct qlcnic_adapter *adapter = dev_get_drvdata(dev_d);\n\n\treturn  __qlcnic_resume(adapter);\n}\n\nstatic int qlcnic_open(struct net_device *netdev)\n{\n\tstruct qlcnic_adapter *adapter = netdev_priv(netdev);\n\tint err;\n\n\tif (test_bit(__QLCNIC_MAINTENANCE_MODE, &adapter->state)) {\n\t\tnetdev_err(netdev, \"%s: Device is in non-operational state\\n\",\n\t\t\t   __func__);\n\n\t\treturn -EIO;\n\t}\n\n\tnetif_carrier_off(netdev);\n\n\terr = qlcnic_attach(adapter);\n\tif (err)\n\t\treturn err;\n\n\terr = __qlcnic_up(adapter, netdev);\n\tif (err)\n\t\tqlcnic_detach(adapter);\n\n\treturn err;\n}\n\n \nstatic int qlcnic_close(struct net_device *netdev)\n{\n\tstruct qlcnic_adapter *adapter = netdev_priv(netdev);\n\n\t__qlcnic_down(adapter, netdev);\n\n\treturn 0;\n}\n\n#define QLCNIC_VF_LB_BUCKET_SIZE 1\n\nvoid qlcnic_alloc_lb_filters_mem(struct qlcnic_adapter *adapter)\n{\n\tvoid *head;\n\tint i;\n\tstruct net_device *netdev = adapter->netdev;\n\tu32 filter_size = 0;\n\tu16 act_pci_func = 0;\n\n\tif (adapter->fhash.fmax && adapter->fhash.fhead)\n\t\treturn;\n\n\tact_pci_func = adapter->ahw->total_nic_func;\n\tspin_lock_init(&adapter->mac_learn_lock);\n\tspin_lock_init(&adapter->rx_mac_learn_lock);\n\n\tif (qlcnic_sriov_vf_check(adapter)) {\n\t\tfilter_size = QLCNIC_83XX_SRIOV_VF_MAX_MAC - 1;\n\t\tadapter->fhash.fbucket_size = QLCNIC_VF_LB_BUCKET_SIZE;\n\t} else if (qlcnic_82xx_check(adapter)) {\n\t\tfilter_size = QLCNIC_LB_MAX_FILTERS;\n\t\tadapter->fhash.fbucket_size = QLCNIC_LB_BUCKET_SIZE;\n\t} else {\n\t\tfilter_size = QLC_83XX_LB_MAX_FILTERS;\n\t\tadapter->fhash.fbucket_size = QLC_83XX_LB_BUCKET_SIZE;\n\t}\n\n\thead = kcalloc(adapter->fhash.fbucket_size,\n\t\t       sizeof(struct hlist_head), GFP_ATOMIC);\n\n\tif (!head)\n\t\treturn;\n\n\tadapter->fhash.fmax = (filter_size / act_pci_func);\n\tadapter->fhash.fhead = head;\n\n\tnetdev_info(netdev, \"active nic func = %d, mac filter size=%d\\n\",\n\t\t    act_pci_func, adapter->fhash.fmax);\n\n\tfor (i = 0; i < adapter->fhash.fbucket_size; i++)\n\t\tINIT_HLIST_HEAD(&adapter->fhash.fhead[i]);\n\n\tadapter->rx_fhash.fbucket_size = adapter->fhash.fbucket_size;\n\n\thead = kcalloc(adapter->rx_fhash.fbucket_size,\n\t\t       sizeof(struct hlist_head), GFP_ATOMIC);\n\n\tif (!head)\n\t\treturn;\n\n\tadapter->rx_fhash.fmax = (filter_size / act_pci_func);\n\tadapter->rx_fhash.fhead = head;\n\n\tfor (i = 0; i < adapter->rx_fhash.fbucket_size; i++)\n\t\tINIT_HLIST_HEAD(&adapter->rx_fhash.fhead[i]);\n}\n\nstatic void qlcnic_free_lb_filters_mem(struct qlcnic_adapter *adapter)\n{\n\tif (adapter->fhash.fmax)\n\t\tkfree(adapter->fhash.fhead);\n\n\tadapter->fhash.fhead = NULL;\n\tadapter->fhash.fmax = 0;\n\n\tif (adapter->rx_fhash.fmax)\n\t\tkfree(adapter->rx_fhash.fhead);\n\n\tadapter->rx_fhash.fmax = 0;\n\tadapter->rx_fhash.fhead = NULL;\n}\n\nint qlcnic_check_temp(struct qlcnic_adapter *adapter)\n{\n\tstruct net_device *netdev = adapter->netdev;\n\tu32 temp_state, temp_val, temp = 0;\n\tint rv = 0;\n\n\tif (qlcnic_83xx_check(adapter))\n\t\ttemp = QLCRDX(adapter->ahw, QLC_83XX_ASIC_TEMP);\n\n\tif (qlcnic_82xx_check(adapter))\n\t\ttemp = QLC_SHARED_REG_RD32(adapter, QLCNIC_ASIC_TEMP);\n\n\ttemp_state = qlcnic_get_temp_state(temp);\n\ttemp_val = qlcnic_get_temp_val(temp);\n\n\tif (temp_state == QLCNIC_TEMP_PANIC) {\n\t\tdev_err(&netdev->dev,\n\t\t       \"Device temperature %d degrees C exceeds\"\n\t\t       \" maximum allowed. Hardware has been shut down.\\n\",\n\t\t       temp_val);\n\t\trv = 1;\n\t} else if (temp_state == QLCNIC_TEMP_WARN) {\n\t\tif (adapter->ahw->temp == QLCNIC_TEMP_NORMAL) {\n\t\t\tdev_err(&netdev->dev,\n\t\t\t       \"Device temperature %d degrees C \"\n\t\t\t       \"exceeds operating range.\"\n\t\t\t       \" Immediate action needed.\\n\",\n\t\t\t       temp_val);\n\t\t}\n\t} else {\n\t\tif (adapter->ahw->temp == QLCNIC_TEMP_WARN) {\n\t\t\tdev_info(&netdev->dev,\n\t\t\t       \"Device temperature is now %d degrees C\"\n\t\t\t       \" in normal range.\\n\", temp_val);\n\t\t}\n\t}\n\tadapter->ahw->temp = temp_state;\n\treturn rv;\n}\n\nstatic inline void dump_tx_ring_desc(struct qlcnic_host_tx_ring *tx_ring)\n{\n\tint i;\n\n\tfor (i = 0; i < tx_ring->num_desc; i++) {\n\t\tpr_info(\"TX Desc: %d\\n\", i);\n\t\tprint_hex_dump(KERN_INFO, \"TX: \", DUMP_PREFIX_OFFSET, 16, 1,\n\t\t\t       &tx_ring->desc_head[i],\n\t\t\t       sizeof(struct cmd_desc_type0), true);\n\t}\n}\n\nstatic void qlcnic_dump_rings(struct qlcnic_adapter *adapter)\n{\n\tstruct qlcnic_recv_context *recv_ctx = adapter->recv_ctx;\n\tstruct net_device *netdev = adapter->netdev;\n\tstruct qlcnic_host_rds_ring *rds_ring;\n\tstruct qlcnic_host_sds_ring *sds_ring;\n\tstruct qlcnic_host_tx_ring *tx_ring;\n\tint ring;\n\n\tif (!netdev || !netif_running(netdev))\n\t\treturn;\n\n\tfor (ring = 0; ring < adapter->max_rds_rings; ring++) {\n\t\trds_ring = &recv_ctx->rds_rings[ring];\n\t\tif (!rds_ring)\n\t\t\tcontinue;\n\t\tnetdev_info(netdev,\n\t\t\t    \"rds_ring=%d crb_rcv_producer=%d producer=%u num_desc=%u\\n\",\n\t\t\t     ring, readl(rds_ring->crb_rcv_producer),\n\t\t\t     rds_ring->producer, rds_ring->num_desc);\n\t}\n\n\tfor (ring = 0; ring < adapter->drv_sds_rings; ring++) {\n\t\tsds_ring = &(recv_ctx->sds_rings[ring]);\n\t\tif (!sds_ring)\n\t\t\tcontinue;\n\t\tnetdev_info(netdev,\n\t\t\t    \"sds_ring=%d crb_sts_consumer=%d consumer=%u crb_intr_mask=%d num_desc=%u\\n\",\n\t\t\t    ring, readl(sds_ring->crb_sts_consumer),\n\t\t\t    sds_ring->consumer, readl(sds_ring->crb_intr_mask),\n\t\t\t    sds_ring->num_desc);\n\t}\n\n\tfor (ring = 0; ring < adapter->drv_tx_rings; ring++) {\n\t\ttx_ring = &adapter->tx_ring[ring];\n\t\tif (!tx_ring)\n\t\t\tcontinue;\n\t\tnetdev_info(netdev, \"Tx ring=%d Context Id=0x%x\\n\",\n\t\t\t    ring, tx_ring->ctx_id);\n\t\tnetdev_info(netdev,\n\t\t\t    \"xmit_finished=%llu, xmit_called=%llu, xmit_on=%llu, xmit_off=%llu\\n\",\n\t\t\t    tx_ring->tx_stats.xmit_finished,\n\t\t\t    tx_ring->tx_stats.xmit_called,\n\t\t\t    tx_ring->tx_stats.xmit_on,\n\t\t\t    tx_ring->tx_stats.xmit_off);\n\n\t\tif (tx_ring->crb_intr_mask)\n\t\t\tnetdev_info(netdev, \"crb_intr_mask=%d\\n\",\n\t\t\t\t    readl(tx_ring->crb_intr_mask));\n\n\t\tnetdev_info(netdev,\n\t\t\t    \"hw_producer=%d, sw_producer=%d sw_consumer=%d, hw_consumer=%d\\n\",\n\t\t\t    readl(tx_ring->crb_cmd_producer),\n\t\t\t    tx_ring->producer, tx_ring->sw_consumer,\n\t\t\t    le32_to_cpu(*(tx_ring->hw_consumer)));\n\n\t\tnetdev_info(netdev, \"Total desc=%d, Available desc=%d\\n\",\n\t\t\t    tx_ring->num_desc, qlcnic_tx_avail(tx_ring));\n\n\t\tif (netif_msg_tx_err(adapter->ahw))\n\t\t\tdump_tx_ring_desc(tx_ring);\n\t}\n\n}\n\nstatic void qlcnic_tx_timeout(struct net_device *netdev, unsigned int txqueue)\n{\n\tstruct qlcnic_adapter *adapter = netdev_priv(netdev);\n\n\tif (test_bit(__QLCNIC_RESETTING, &adapter->state))\n\t\treturn;\n\n\tqlcnic_dump_rings(adapter);\n\n\tif (++adapter->tx_timeo_cnt >= QLCNIC_MAX_TX_TIMEOUTS ||\n\t    netif_msg_tx_err(adapter->ahw)) {\n\t\tnetdev_err(netdev, \"Tx timeout, reset the adapter.\\n\");\n\t\tif (qlcnic_82xx_check(adapter))\n\t\t\tadapter->need_fw_reset = 1;\n\t\telse if (qlcnic_83xx_check(adapter))\n\t\t\tqlcnic_83xx_idc_request_reset(adapter,\n\t\t\t\t\t\t      QLCNIC_FORCE_FW_DUMP_KEY);\n\t} else {\n\t\tnetdev_err(netdev, \"Tx timeout, reset adapter context.\\n\");\n\t\tadapter->ahw->reset_context = 1;\n\t}\n}\n\nstatic struct net_device_stats *qlcnic_get_stats(struct net_device *netdev)\n{\n\tstruct qlcnic_adapter *adapter = netdev_priv(netdev);\n\tstruct net_device_stats *stats = &netdev->stats;\n\n\tif (test_bit(__QLCNIC_DEV_UP, &adapter->state))\n\t\tqlcnic_update_stats(adapter);\n\n\tstats->rx_packets = adapter->stats.rx_pkts + adapter->stats.lro_pkts;\n\tstats->tx_packets = adapter->stats.xmitfinished;\n\tstats->rx_bytes = adapter->stats.rxbytes + adapter->stats.lrobytes;\n\tstats->tx_bytes = adapter->stats.txbytes;\n\tstats->rx_dropped = adapter->stats.rxdropped;\n\tstats->tx_dropped = adapter->stats.txdropped;\n\n\treturn stats;\n}\n\nstatic irqreturn_t qlcnic_82xx_clear_legacy_intr(struct qlcnic_adapter *adapter)\n{\n\tu32 status;\n\n\tstatus = readl(adapter->isr_int_vec);\n\n\tif (!(status & adapter->ahw->int_vec_bit))\n\t\treturn IRQ_NONE;\n\n\t \n\tstatus = readl(adapter->crb_int_state_reg);\n\tif (!ISR_LEGACY_INT_TRIGGERED(status))\n\t\treturn IRQ_NONE;\n\n\twritel(0xffffffff, adapter->tgt_status_reg);\n\t \n\treadl(adapter->isr_int_vec);\n\treadl(adapter->isr_int_vec);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t qlcnic_tmp_intr(int irq, void *data)\n{\n\tstruct qlcnic_host_sds_ring *sds_ring = data;\n\tstruct qlcnic_adapter *adapter = sds_ring->adapter;\n\n\tif (adapter->flags & QLCNIC_MSIX_ENABLED)\n\t\tgoto done;\n\telse if (adapter->flags & QLCNIC_MSI_ENABLED) {\n\t\twritel(0xffffffff, adapter->tgt_status_reg);\n\t\tgoto done;\n\t}\n\n\tif (qlcnic_clear_legacy_intr(adapter) == IRQ_NONE)\n\t\treturn IRQ_NONE;\n\ndone:\n\tadapter->ahw->diag_cnt++;\n\tqlcnic_enable_sds_intr(adapter, sds_ring);\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t qlcnic_intr(int irq, void *data)\n{\n\tstruct qlcnic_host_sds_ring *sds_ring = data;\n\tstruct qlcnic_adapter *adapter = sds_ring->adapter;\n\n\tif (qlcnic_clear_legacy_intr(adapter) == IRQ_NONE)\n\t\treturn IRQ_NONE;\n\n\tnapi_schedule(&sds_ring->napi);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t qlcnic_msi_intr(int irq, void *data)\n{\n\tstruct qlcnic_host_sds_ring *sds_ring = data;\n\tstruct qlcnic_adapter *adapter = sds_ring->adapter;\n\n\t \n\twritel(0xffffffff, adapter->tgt_status_reg);\n\n\tnapi_schedule(&sds_ring->napi);\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t qlcnic_msix_intr(int irq, void *data)\n{\n\tstruct qlcnic_host_sds_ring *sds_ring = data;\n\n\tnapi_schedule(&sds_ring->napi);\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t qlcnic_msix_tx_intr(int irq, void *data)\n{\n\tstruct qlcnic_host_tx_ring *tx_ring = data;\n\n\tnapi_schedule(&tx_ring->napi);\n\treturn IRQ_HANDLED;\n}\n\nstatic void\nqlcnic_idc_debug_info(struct qlcnic_adapter *adapter, u8 encoding)\n{\n\tu32 val;\n\n\tval = adapter->portnum & 0xf;\n\tval |= encoding << 7;\n\tval |= (jiffies - adapter->dev_rst_time) << 8;\n\n\tQLC_SHARED_REG_WR32(adapter, QLCNIC_CRB_DRV_SCRATCH, val);\n\tadapter->dev_rst_time = jiffies;\n}\n\nstatic int\nqlcnic_set_drv_state(struct qlcnic_adapter *adapter, u8 state)\n{\n\tu32  val;\n\n\tWARN_ON(state != QLCNIC_DEV_NEED_RESET &&\n\t\t\tstate != QLCNIC_DEV_NEED_QUISCENT);\n\n\tif (qlcnic_api_lock(adapter))\n\t\treturn -EIO;\n\n\tval = QLC_SHARED_REG_RD32(adapter, QLCNIC_CRB_DRV_STATE);\n\n\tif (state == QLCNIC_DEV_NEED_RESET)\n\t\tQLC_DEV_SET_RST_RDY(val, adapter->portnum);\n\telse if (state == QLCNIC_DEV_NEED_QUISCENT)\n\t\tQLC_DEV_SET_QSCNT_RDY(val, adapter->portnum);\n\n\tQLC_SHARED_REG_WR32(adapter, QLCNIC_CRB_DRV_STATE, val);\n\n\tqlcnic_api_unlock(adapter);\n\n\treturn 0;\n}\n\nstatic int\nqlcnic_clr_drv_state(struct qlcnic_adapter *adapter)\n{\n\tu32  val;\n\n\tif (qlcnic_api_lock(adapter))\n\t\treturn -EBUSY;\n\n\tval = QLC_SHARED_REG_RD32(adapter, QLCNIC_CRB_DRV_STATE);\n\tQLC_DEV_CLR_RST_QSCNT(val, adapter->portnum);\n\tQLC_SHARED_REG_WR32(adapter, QLCNIC_CRB_DRV_STATE, val);\n\n\tqlcnic_api_unlock(adapter);\n\n\treturn 0;\n}\n\nvoid qlcnic_clr_all_drv_state(struct qlcnic_adapter *adapter, u8 failed)\n{\n\tu32  val;\n\n\tif (qlcnic_api_lock(adapter))\n\t\tgoto err;\n\n\tval = QLC_SHARED_REG_RD32(adapter, QLCNIC_CRB_DRV_ACTIVE);\n\tQLC_DEV_CLR_REF_CNT(val, adapter->portnum);\n\tQLC_SHARED_REG_WR32(adapter, QLCNIC_CRB_DRV_ACTIVE, val);\n\n\tif (failed) {\n\t\tQLC_SHARED_REG_WR32(adapter, QLCNIC_CRB_DEV_STATE,\n\t\t\t\t    QLCNIC_DEV_FAILED);\n\t\tdev_info(&adapter->pdev->dev,\n\t\t\t\t\"Device state set to Failed. Please Reboot\\n\");\n\t} else if (!(val & 0x11111111))\n\t\tQLC_SHARED_REG_WR32(adapter, QLCNIC_CRB_DEV_STATE,\n\t\t\t\t    QLCNIC_DEV_COLD);\n\n\tval = QLC_SHARED_REG_RD32(adapter, QLCNIC_CRB_DRV_STATE);\n\tQLC_DEV_CLR_RST_QSCNT(val, adapter->portnum);\n\tQLC_SHARED_REG_WR32(adapter, QLCNIC_CRB_DRV_STATE, val);\n\n\tqlcnic_api_unlock(adapter);\nerr:\n\tadapter->fw_fail_cnt = 0;\n\tadapter->flags &= ~QLCNIC_FW_HANG;\n\tclear_bit(__QLCNIC_START_FW, &adapter->state);\n\tclear_bit(__QLCNIC_RESETTING, &adapter->state);\n}\n\n \nstatic int\nqlcnic_check_drv_state(struct qlcnic_adapter *adapter)\n{\n\tint act, state, active_mask;\n\tstruct qlcnic_hardware_context *ahw = adapter->ahw;\n\n\tstate = QLC_SHARED_REG_RD32(adapter, QLCNIC_CRB_DRV_STATE);\n\tact = QLC_SHARED_REG_RD32(adapter, QLCNIC_CRB_DRV_ACTIVE);\n\n\tif (adapter->flags & QLCNIC_FW_RESET_OWNER) {\n\t\tactive_mask = (~(1 << (ahw->pci_func * 4)));\n\t\tact = act & active_mask;\n\t}\n\n\tif (((state & 0x11111111) == (act & 0x11111111)) ||\n\t\t\t((act & 0x11111111) == ((state >> 1) & 0x11111111)))\n\t\treturn 0;\n\telse\n\t\treturn 1;\n}\n\nstatic int qlcnic_check_idc_ver(struct qlcnic_adapter *adapter)\n{\n\tu32 val = QLC_SHARED_REG_RD32(adapter, QLCNIC_CRB_DRV_IDC_VER);\n\n\tif (val != QLCNIC_DRV_IDC_VER) {\n\t\tdev_warn(&adapter->pdev->dev, \"IDC Version mismatch, driver's\"\n\t\t\t\" idc ver = %x; reqd = %x\\n\", QLCNIC_DRV_IDC_VER, val);\n\t}\n\n\treturn 0;\n}\n\nstatic int\nqlcnic_can_start_firmware(struct qlcnic_adapter *adapter)\n{\n\tu32 val, prev_state;\n\tu8 dev_init_timeo = adapter->dev_init_timeo;\n\tu8 portnum = adapter->portnum;\n\tu8 ret;\n\n\tif (test_and_clear_bit(__QLCNIC_START_FW, &adapter->state))\n\t\treturn 1;\n\n\tif (qlcnic_api_lock(adapter))\n\t\treturn -1;\n\n\tval = QLC_SHARED_REG_RD32(adapter, QLCNIC_CRB_DRV_ACTIVE);\n\tif (!(val & (1 << (portnum * 4)))) {\n\t\tQLC_DEV_SET_REF_CNT(val, portnum);\n\t\tQLC_SHARED_REG_WR32(adapter, QLCNIC_CRB_DRV_ACTIVE, val);\n\t}\n\n\tprev_state = QLC_SHARED_REG_RD32(adapter, QLCNIC_CRB_DEV_STATE);\n\tQLCDB(adapter, HW, \"Device state = %u\\n\", prev_state);\n\n\tswitch (prev_state) {\n\tcase QLCNIC_DEV_COLD:\n\t\tQLC_SHARED_REG_WR32(adapter, QLCNIC_CRB_DEV_STATE,\n\t\t\t\t    QLCNIC_DEV_INITIALIZING);\n\t\tQLC_SHARED_REG_WR32(adapter, QLCNIC_CRB_DRV_IDC_VER,\n\t\t\t\t    QLCNIC_DRV_IDC_VER);\n\t\tqlcnic_idc_debug_info(adapter, 0);\n\t\tqlcnic_api_unlock(adapter);\n\t\treturn 1;\n\n\tcase QLCNIC_DEV_READY:\n\t\tret = qlcnic_check_idc_ver(adapter);\n\t\tqlcnic_api_unlock(adapter);\n\t\treturn ret;\n\n\tcase QLCNIC_DEV_NEED_RESET:\n\t\tval = QLC_SHARED_REG_RD32(adapter, QLCNIC_CRB_DRV_STATE);\n\t\tQLC_DEV_SET_RST_RDY(val, portnum);\n\t\tQLC_SHARED_REG_WR32(adapter, QLCNIC_CRB_DRV_STATE, val);\n\t\tbreak;\n\n\tcase QLCNIC_DEV_NEED_QUISCENT:\n\t\tval = QLC_SHARED_REG_RD32(adapter, QLCNIC_CRB_DRV_STATE);\n\t\tQLC_DEV_SET_QSCNT_RDY(val, portnum);\n\t\tQLC_SHARED_REG_WR32(adapter, QLCNIC_CRB_DRV_STATE, val);\n\t\tbreak;\n\n\tcase QLCNIC_DEV_FAILED:\n\t\tdev_err(&adapter->pdev->dev, \"Device in failed state.\\n\");\n\t\tqlcnic_api_unlock(adapter);\n\t\treturn -1;\n\n\tcase QLCNIC_DEV_INITIALIZING:\n\tcase QLCNIC_DEV_QUISCENT:\n\t\tbreak;\n\t}\n\n\tqlcnic_api_unlock(adapter);\n\n\tdo {\n\t\tmsleep(1000);\n\t\tprev_state = QLC_SHARED_REG_RD32(adapter, QLCNIC_CRB_DEV_STATE);\n\t} while ((prev_state != QLCNIC_DEV_READY) && --dev_init_timeo);\n\n\tif (!dev_init_timeo) {\n\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\"Waiting for device to initialize timeout\\n\");\n\t\treturn -1;\n\t}\n\n\tif (qlcnic_api_lock(adapter))\n\t\treturn -1;\n\n\tval = QLC_SHARED_REG_RD32(adapter, QLCNIC_CRB_DRV_STATE);\n\tQLC_DEV_CLR_RST_QSCNT(val, portnum);\n\tQLC_SHARED_REG_WR32(adapter, QLCNIC_CRB_DRV_STATE, val);\n\n\tret = qlcnic_check_idc_ver(adapter);\n\tqlcnic_api_unlock(adapter);\n\n\treturn ret;\n}\n\nstatic void\nqlcnic_fwinit_work(struct work_struct *work)\n{\n\tstruct qlcnic_adapter *adapter = container_of(work,\n\t\t\tstruct qlcnic_adapter, fw_work.work);\n\tu32 dev_state = 0xf;\n\tu32 val;\n\n\tif (qlcnic_api_lock(adapter))\n\t\tgoto err_ret;\n\n\tdev_state = QLC_SHARED_REG_RD32(adapter, QLCNIC_CRB_DEV_STATE);\n\tif (dev_state == QLCNIC_DEV_QUISCENT ||\n\t    dev_state == QLCNIC_DEV_NEED_QUISCENT) {\n\t\tqlcnic_api_unlock(adapter);\n\t\tqlcnic_schedule_work(adapter, qlcnic_fwinit_work,\n\t\t\t\t\t\tFW_POLL_DELAY * 2);\n\t\treturn;\n\t}\n\n\tif (adapter->ahw->op_mode == QLCNIC_NON_PRIV_FUNC) {\n\t\tqlcnic_api_unlock(adapter);\n\t\tgoto wait_npar;\n\t}\n\n\tif (dev_state == QLCNIC_DEV_INITIALIZING ||\n\t    dev_state == QLCNIC_DEV_READY) {\n\t\tdev_info(&adapter->pdev->dev, \"Detected state change from \"\n\t\t\t\t\"DEV_NEED_RESET, skipping ack check\\n\");\n\t\tgoto skip_ack_check;\n\t}\n\n\tif (adapter->fw_wait_cnt++ > adapter->reset_ack_timeo) {\n\t\tdev_info(&adapter->pdev->dev, \"Reset:Failed to get ack %d sec\\n\",\n\t\t\t\t\tadapter->reset_ack_timeo);\n\t\tgoto skip_ack_check;\n\t}\n\n\tif (!qlcnic_check_drv_state(adapter)) {\nskip_ack_check:\n\t\tdev_state = QLC_SHARED_REG_RD32(adapter, QLCNIC_CRB_DEV_STATE);\n\n\t\tif (dev_state == QLCNIC_DEV_NEED_RESET) {\n\t\t\tQLC_SHARED_REG_WR32(adapter, QLCNIC_CRB_DEV_STATE,\n\t\t\t\t\t    QLCNIC_DEV_INITIALIZING);\n\t\t\tset_bit(__QLCNIC_START_FW, &adapter->state);\n\t\t\tQLCDB(adapter, DRV, \"Restarting fw\\n\");\n\t\t\tqlcnic_idc_debug_info(adapter, 0);\n\t\t\tval = QLC_SHARED_REG_RD32(adapter,\n\t\t\t\t\t\t  QLCNIC_CRB_DRV_STATE);\n\t\t\tQLC_DEV_SET_RST_RDY(val, adapter->portnum);\n\t\t\tQLC_SHARED_REG_WR32(adapter,\n\t\t\t\t\t    QLCNIC_CRB_DRV_STATE, val);\n\t\t}\n\n\t\tqlcnic_api_unlock(adapter);\n\n\t\trtnl_lock();\n\t\tif (qlcnic_check_fw_dump_state(adapter) &&\n\t\t    (adapter->flags & QLCNIC_FW_RESET_OWNER)) {\n\t\t\tQLCDB(adapter, DRV, \"Take FW dump\\n\");\n\t\t\tqlcnic_dump_fw(adapter);\n\t\t\tadapter->flags |= QLCNIC_FW_HANG;\n\t\t}\n\t\trtnl_unlock();\n\n\t\tadapter->flags &= ~QLCNIC_FW_RESET_OWNER;\n\t\tif (!adapter->nic_ops->start_firmware(adapter)) {\n\t\t\tqlcnic_schedule_work(adapter, qlcnic_attach_work, 0);\n\t\t\tadapter->fw_wait_cnt = 0;\n\t\t\treturn;\n\t\t}\n\t\tgoto err_ret;\n\t}\n\n\tqlcnic_api_unlock(adapter);\n\nwait_npar:\n\tdev_state = QLC_SHARED_REG_RD32(adapter, QLCNIC_CRB_DEV_STATE);\n\tQLCDB(adapter, HW, \"Func waiting: Device state=%u\\n\", dev_state);\n\n\tswitch (dev_state) {\n\tcase QLCNIC_DEV_READY:\n\t\tif (!qlcnic_start_firmware(adapter)) {\n\t\t\tqlcnic_schedule_work(adapter, qlcnic_attach_work, 0);\n\t\t\tadapter->fw_wait_cnt = 0;\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tcase QLCNIC_DEV_FAILED:\n\t\tbreak;\n\tdefault:\n\t\tqlcnic_schedule_work(adapter,\n\t\t\tqlcnic_fwinit_work, FW_POLL_DELAY);\n\t\treturn;\n\t}\n\nerr_ret:\n\tdev_err(&adapter->pdev->dev, \"Fwinit work failed state=%u \"\n\t\t\"fw_wait_cnt=%u\\n\", dev_state, adapter->fw_wait_cnt);\n\tnetif_device_attach(adapter->netdev);\n\tqlcnic_clr_all_drv_state(adapter, 0);\n}\n\nstatic void\nqlcnic_detach_work(struct work_struct *work)\n{\n\tstruct qlcnic_adapter *adapter = container_of(work,\n\t\t\tstruct qlcnic_adapter, fw_work.work);\n\tstruct net_device *netdev = adapter->netdev;\n\tu32 status;\n\n\tnetif_device_detach(netdev);\n\n\t \n\tif (adapter->dev_state == QLCNIC_DEV_NEED_QUISCENT) {\n\t\tif (netif_running(netdev))\n\t\t\t__qlcnic_down(adapter, netdev);\n\t} else\n\t\tqlcnic_down(adapter, netdev);\n\n\tstatus = QLC_SHARED_REG_RD32(adapter, QLCNIC_PEG_HALT_STATUS1);\n\n\tif (status & QLCNIC_RCODE_FATAL_ERROR) {\n\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\"Detaching the device: peg halt status1=0x%x\\n\",\n\t\t\t\t\tstatus);\n\n\t\tif (QLCNIC_FWERROR_CODE(status) == QLCNIC_FWERROR_FAN_FAILURE) {\n\t\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\"On board active cooling fan failed. \"\n\t\t\t\t\"Device has been halted.\\n\");\n\t\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\t\"Replace the adapter.\\n\");\n\t\t}\n\n\t\tgoto err_ret;\n\t}\n\n\tif (adapter->ahw->temp == QLCNIC_TEMP_PANIC) {\n\t\tdev_err(&adapter->pdev->dev, \"Detaching the device: temp=%d\\n\",\n\t\t\tadapter->ahw->temp);\n\t\tgoto err_ret;\n\t}\n\n\t \n\tif (!(adapter->flags & QLCNIC_FW_RESET_OWNER)) {\n\t\tif (qlcnic_set_drv_state(adapter, adapter->dev_state)) {\n\t\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\t\"Failed to set driver state,\"\n\t\t\t\t\t\"detaching the device.\\n\");\n\t\t\tgoto err_ret;\n\t\t}\n\t}\n\n\tadapter->fw_wait_cnt = 0;\n\n\tqlcnic_schedule_work(adapter, qlcnic_fwinit_work, FW_POLL_DELAY);\n\n\treturn;\n\nerr_ret:\n\tnetif_device_attach(netdev);\n\tqlcnic_clr_all_drv_state(adapter, 1);\n}\n\n \nstatic void\nqlcnic_set_npar_non_operational(struct qlcnic_adapter *adapter)\n{\n\tu32 state;\n\n\tstate = QLC_SHARED_REG_RD32(adapter, QLCNIC_CRB_DEV_NPAR_STATE);\n\tif (state == QLCNIC_DEV_NPAR_NON_OPER)\n\t\treturn;\n\n\tif (qlcnic_api_lock(adapter))\n\t\treturn;\n\tQLC_SHARED_REG_WR32(adapter, QLCNIC_CRB_DEV_NPAR_STATE,\n\t\t\t    QLCNIC_DEV_NPAR_NON_OPER);\n\tqlcnic_api_unlock(adapter);\n}\n\nstatic void qlcnic_82xx_dev_request_reset(struct qlcnic_adapter *adapter,\n\t\t\t\t\t  u32 key)\n{\n\tu32 state, xg_val = 0, gb_val = 0;\n\n\tqlcnic_xg_set_xg0_mask(xg_val);\n\tqlcnic_xg_set_xg1_mask(xg_val);\n\tQLCWR32(adapter, QLCNIC_NIU_XG_PAUSE_CTL, xg_val);\n\tqlcnic_gb_set_gb0_mask(gb_val);\n\tqlcnic_gb_set_gb1_mask(gb_val);\n\tqlcnic_gb_set_gb2_mask(gb_val);\n\tqlcnic_gb_set_gb3_mask(gb_val);\n\tQLCWR32(adapter, QLCNIC_NIU_GB_PAUSE_CTL, gb_val);\n\tdev_info(&adapter->pdev->dev, \"Pause control frames disabled\"\n\t\t\t\t\" on all ports\\n\");\n\tadapter->need_fw_reset = 1;\n\n\tif (qlcnic_api_lock(adapter))\n\t\treturn;\n\n\tstate = QLC_SHARED_REG_RD32(adapter, QLCNIC_CRB_DEV_STATE);\n\n\tif (test_bit(__QLCNIC_MAINTENANCE_MODE, &adapter->state)) {\n\t\tnetdev_err(adapter->netdev, \"%s: Device is in non-operational state\\n\",\n\t\t\t   __func__);\n\t\tqlcnic_api_unlock(adapter);\n\n\t\treturn;\n\t}\n\n\tif (state == QLCNIC_DEV_READY) {\n\t\tQLC_SHARED_REG_WR32(adapter, QLCNIC_CRB_DEV_STATE,\n\t\t\t\t    QLCNIC_DEV_NEED_RESET);\n\t\tadapter->flags |= QLCNIC_FW_RESET_OWNER;\n\t\tQLCDB(adapter, DRV, \"NEED_RESET state set\\n\");\n\t\tqlcnic_idc_debug_info(adapter, 0);\n\t}\n\n\tQLC_SHARED_REG_WR32(adapter, QLCNIC_CRB_DEV_NPAR_STATE,\n\t\t\t    QLCNIC_DEV_NPAR_NON_OPER);\n\tqlcnic_api_unlock(adapter);\n}\n\n \nstatic void\nqlcnic_dev_set_npar_ready(struct qlcnic_adapter *adapter)\n{\n\tif (qlcnic_api_lock(adapter))\n\t\treturn;\n\n\tQLC_SHARED_REG_WR32(adapter, QLCNIC_CRB_DEV_NPAR_STATE,\n\t\t\t    QLCNIC_DEV_NPAR_OPER);\n\tQLCDB(adapter, DRV, \"NPAR operational state set\\n\");\n\n\tqlcnic_api_unlock(adapter);\n}\n\nvoid qlcnic_schedule_work(struct qlcnic_adapter *adapter,\n\t\t\t  work_func_t func, int delay)\n{\n\tif (test_bit(__QLCNIC_AER, &adapter->state))\n\t\treturn;\n\n\tINIT_DELAYED_WORK(&adapter->fw_work, func);\n\tqueue_delayed_work(adapter->qlcnic_wq, &adapter->fw_work,\n\t\t\t   round_jiffies_relative(delay));\n}\n\nstatic void\nqlcnic_attach_work(struct work_struct *work)\n{\n\tstruct qlcnic_adapter *adapter = container_of(work,\n\t\t\t\tstruct qlcnic_adapter, fw_work.work);\n\tstruct net_device *netdev = adapter->netdev;\n\tu32 npar_state;\n\n\tif (adapter->ahw->op_mode != QLCNIC_MGMT_FUNC) {\n\t\tnpar_state = QLC_SHARED_REG_RD32(adapter,\n\t\t\t\t\t\t QLCNIC_CRB_DEV_NPAR_STATE);\n\t\tif (adapter->fw_wait_cnt++ > QLCNIC_DEV_NPAR_OPER_TIMEO)\n\t\t\tqlcnic_clr_all_drv_state(adapter, 0);\n\t\telse if (npar_state != QLCNIC_DEV_NPAR_OPER)\n\t\t\tqlcnic_schedule_work(adapter, qlcnic_attach_work,\n\t\t\t\t\t\t\tFW_POLL_DELAY);\n\t\telse\n\t\t\tgoto attach;\n\t\tQLCDB(adapter, DRV, \"Waiting for NPAR state to operational\\n\");\n\t\treturn;\n\t}\nattach:\n\tqlcnic_dcb_get_info(adapter->dcb);\n\n\tif (netif_running(netdev)) {\n\t\tif (qlcnic_up(adapter, netdev))\n\t\t\tgoto done;\n\n\t\tqlcnic_restore_indev_addr(netdev, NETDEV_UP);\n\t}\n\ndone:\n\tnetif_device_attach(netdev);\n\tadapter->fw_fail_cnt = 0;\n\tadapter->flags &= ~QLCNIC_FW_HANG;\n\tclear_bit(__QLCNIC_RESETTING, &adapter->state);\n\tif (adapter->portnum == 0)\n\t\tqlcnic_set_drv_version(adapter);\n\n\tif (!qlcnic_clr_drv_state(adapter))\n\t\tqlcnic_schedule_work(adapter, qlcnic_fw_poll_work,\n\t\t\t\t\t\t\tFW_POLL_DELAY);\n}\n\nstatic int\nqlcnic_check_health(struct qlcnic_adapter *adapter)\n{\n\tstruct qlcnic_hardware_context *ahw = adapter->ahw;\n\tstruct qlcnic_fw_dump *fw_dump = &ahw->fw_dump;\n\tu32 state = 0, heartbeat;\n\tu32 peg_status;\n\tint err = 0;\n\n\tif (qlcnic_check_temp(adapter))\n\t\tgoto detach;\n\n\tif (adapter->need_fw_reset)\n\t\tqlcnic_dev_request_reset(adapter, 0);\n\n\tstate = QLC_SHARED_REG_RD32(adapter, QLCNIC_CRB_DEV_STATE);\n\tif (state == QLCNIC_DEV_NEED_RESET) {\n\t\tqlcnic_set_npar_non_operational(adapter);\n\t\tadapter->need_fw_reset = 1;\n\t} else if (state == QLCNIC_DEV_NEED_QUISCENT)\n\t\tgoto detach;\n\n\theartbeat = QLC_SHARED_REG_RD32(adapter, QLCNIC_PEG_ALIVE_COUNTER);\n\tif (heartbeat != adapter->heartbeat) {\n\t\tadapter->heartbeat = heartbeat;\n\t\tadapter->fw_fail_cnt = 0;\n\t\tif (adapter->need_fw_reset)\n\t\t\tgoto detach;\n\n\t\tif (ahw->reset_context && qlcnic_auto_fw_reset)\n\t\t\tqlcnic_reset_hw_context(adapter);\n\n\t\treturn 0;\n\t}\n\n\tif (++adapter->fw_fail_cnt < FW_FAIL_THRESH)\n\t\treturn 0;\n\n\tadapter->flags |= QLCNIC_FW_HANG;\n\n\tqlcnic_dev_request_reset(adapter, 0);\n\n\tif (qlcnic_auto_fw_reset)\n\t\tclear_bit(__QLCNIC_FW_ATTACHED, &adapter->state);\n\n\tdev_err(&adapter->pdev->dev, \"firmware hang detected\\n\");\n\tpeg_status = QLC_SHARED_REG_RD32(adapter, QLCNIC_PEG_HALT_STATUS1);\n\tdev_err(&adapter->pdev->dev, \"Dumping hw/fw registers\\n\"\n\t\t\t\"PEG_HALT_STATUS1: 0x%x, PEG_HALT_STATUS2: 0x%x,\\n\"\n\t\t\t\"PEG_NET_0_PC: 0x%x, PEG_NET_1_PC: 0x%x,\\n\"\n\t\t\t\"PEG_NET_2_PC: 0x%x, PEG_NET_3_PC: 0x%x,\\n\"\n\t\t\t\"PEG_NET_4_PC: 0x%x\\n\",\n\t\t\tpeg_status,\n\t\t\tQLC_SHARED_REG_RD32(adapter, QLCNIC_PEG_HALT_STATUS2),\n\t\t\tQLCRD32(adapter, QLCNIC_CRB_PEG_NET_0 + 0x3c, &err),\n\t\t\tQLCRD32(adapter, QLCNIC_CRB_PEG_NET_1 + 0x3c, &err),\n\t\t\tQLCRD32(adapter, QLCNIC_CRB_PEG_NET_2 + 0x3c, &err),\n\t\t\tQLCRD32(adapter, QLCNIC_CRB_PEG_NET_3 + 0x3c, &err),\n\t\t\tQLCRD32(adapter, QLCNIC_CRB_PEG_NET_4 + 0x3c, &err));\n\tif (QLCNIC_FWERROR_CODE(peg_status) == 0x67)\n\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\"Firmware aborted with error code 0x00006700. \"\n\t\t\t\t\"Device is being reset.\\n\");\ndetach:\n\tadapter->dev_state = (state == QLCNIC_DEV_NEED_QUISCENT) ? state :\n\t\tQLCNIC_DEV_NEED_RESET;\n\n\tif (qlcnic_auto_fw_reset && !test_and_set_bit(__QLCNIC_RESETTING,\n\t\t\t\t\t\t      &adapter->state)) {\n\n\t\tqlcnic_schedule_work(adapter, qlcnic_detach_work, 0);\n\t\tQLCDB(adapter, DRV, \"fw recovery scheduled.\\n\");\n\t} else if (!qlcnic_auto_fw_reset && fw_dump->enable &&\n\t\t   adapter->flags & QLCNIC_FW_RESET_OWNER) {\n\t\tqlcnic_dump_fw(adapter);\n\t}\n\n\treturn 1;\n}\n\nvoid qlcnic_fw_poll_work(struct work_struct *work)\n{\n\tstruct qlcnic_adapter *adapter = container_of(work,\n\t\t\t\tstruct qlcnic_adapter, fw_work.work);\n\n\tif (test_bit(__QLCNIC_RESETTING, &adapter->state))\n\t\tgoto reschedule;\n\n\n\tif (qlcnic_check_health(adapter))\n\t\treturn;\n\n\tif (adapter->fhash.fnum)\n\t\tqlcnic_prune_lb_filters(adapter);\n\nreschedule:\n\tqlcnic_schedule_work(adapter, qlcnic_fw_poll_work, FW_POLL_DELAY);\n}\n\nstatic int qlcnic_is_first_func(struct pci_dev *pdev)\n{\n\tstruct pci_dev *oth_pdev;\n\tint val = pdev->devfn;\n\n\twhile (val-- > 0) {\n\t\toth_pdev = pci_get_domain_bus_and_slot(pci_domain_nr\n\t\t\t(pdev->bus), pdev->bus->number,\n\t\t\tPCI_DEVFN(PCI_SLOT(pdev->devfn), val));\n\t\tif (!oth_pdev)\n\t\t\tcontinue;\n\n\t\tif (oth_pdev->current_state != PCI_D3cold) {\n\t\t\tpci_dev_put(oth_pdev);\n\t\t\treturn 0;\n\t\t}\n\t\tpci_dev_put(oth_pdev);\n\t}\n\treturn 1;\n}\n\nstatic int qlcnic_attach_func(struct pci_dev *pdev)\n{\n\tint err, first_func;\n\tstruct qlcnic_adapter *adapter = pci_get_drvdata(pdev);\n\tstruct net_device *netdev = adapter->netdev;\n\n\tpdev->error_state = pci_channel_io_normal;\n\n\terr = pci_enable_device(pdev);\n\tif (err)\n\t\treturn err;\n\n\tpci_set_master(pdev);\n\tpci_restore_state(pdev);\n\n\tfirst_func = qlcnic_is_first_func(pdev);\n\n\tif (qlcnic_api_lock(adapter))\n\t\treturn -EINVAL;\n\n\tif (adapter->ahw->op_mode != QLCNIC_NON_PRIV_FUNC && first_func) {\n\t\tadapter->need_fw_reset = 1;\n\t\tset_bit(__QLCNIC_START_FW, &adapter->state);\n\t\tQLC_SHARED_REG_WR32(adapter, QLCNIC_CRB_DEV_STATE,\n\t\t\t\t    QLCNIC_DEV_INITIALIZING);\n\t\tQLCDB(adapter, DRV, \"Restarting fw\\n\");\n\t}\n\tqlcnic_api_unlock(adapter);\n\n\terr = qlcnic_start_firmware(adapter);\n\tif (err)\n\t\treturn err;\n\n\tqlcnic_clr_drv_state(adapter);\n\tkfree(adapter->msix_entries);\n\tadapter->msix_entries = NULL;\n\terr = qlcnic_setup_intr(adapter);\n\n\tif (err) {\n\t\tkfree(adapter->msix_entries);\n\t\tnetdev_err(netdev, \"failed to setup interrupt\\n\");\n\t\treturn err;\n\t}\n\n\tif (netif_running(netdev)) {\n\t\terr = qlcnic_attach(adapter);\n\t\tif (err) {\n\t\t\tqlcnic_clr_all_drv_state(adapter, 1);\n\t\t\tclear_bit(__QLCNIC_AER, &adapter->state);\n\t\t\tnetif_device_attach(netdev);\n\t\t\treturn err;\n\t\t}\n\n\t\terr = qlcnic_up(adapter, netdev);\n\t\tif (err)\n\t\t\tgoto done;\n\n\t\tqlcnic_restore_indev_addr(netdev, NETDEV_UP);\n\t}\n done:\n\tnetif_device_attach(netdev);\n\treturn err;\n}\n\nstatic pci_ers_result_t qlcnic_82xx_io_error_detected(struct pci_dev *pdev,\n\t\t\t\t\t\t      pci_channel_state_t state)\n{\n\tstruct qlcnic_adapter *adapter = pci_get_drvdata(pdev);\n\tstruct net_device *netdev = adapter->netdev;\n\n\tif (state == pci_channel_io_perm_failure)\n\t\treturn PCI_ERS_RESULT_DISCONNECT;\n\n\tif (state == pci_channel_io_normal)\n\t\treturn PCI_ERS_RESULT_RECOVERED;\n\n\tset_bit(__QLCNIC_AER, &adapter->state);\n\tnetif_device_detach(netdev);\n\n\tcancel_delayed_work_sync(&adapter->fw_work);\n\n\tif (netif_running(netdev))\n\t\tqlcnic_down(adapter, netdev);\n\n\tqlcnic_detach(adapter);\n\tqlcnic_teardown_intr(adapter);\n\n\tclear_bit(__QLCNIC_RESETTING, &adapter->state);\n\n\tpci_save_state(pdev);\n\tpci_disable_device(pdev);\n\n\treturn PCI_ERS_RESULT_NEED_RESET;\n}\n\nstatic pci_ers_result_t qlcnic_82xx_io_slot_reset(struct pci_dev *pdev)\n{\n\tpci_ers_result_t res;\n\n\trtnl_lock();\n\tres = qlcnic_attach_func(pdev) ? PCI_ERS_RESULT_DISCONNECT :\n\t\t\t\t\t PCI_ERS_RESULT_RECOVERED;\n\trtnl_unlock();\n\n\treturn res;\n}\n\nstatic void qlcnic_82xx_io_resume(struct pci_dev *pdev)\n{\n\tu32 state;\n\tstruct qlcnic_adapter *adapter = pci_get_drvdata(pdev);\n\n\tstate = QLC_SHARED_REG_RD32(adapter, QLCNIC_CRB_DEV_STATE);\n\tif (state == QLCNIC_DEV_READY && test_and_clear_bit(__QLCNIC_AER,\n\t\t\t\t\t\t\t    &adapter->state))\n\t\tqlcnic_schedule_work(adapter, qlcnic_fw_poll_work,\n\t\t\t\t     FW_POLL_DELAY);\n}\n\nstatic pci_ers_result_t qlcnic_io_error_detected(struct pci_dev *pdev,\n\t\t\t\t\t\t pci_channel_state_t state)\n{\n\tstruct qlcnic_adapter *adapter = pci_get_drvdata(pdev);\n\tstruct qlcnic_hardware_ops *hw_ops = adapter->ahw->hw_ops;\n\n\tif (hw_ops->io_error_detected) {\n\t\treturn hw_ops->io_error_detected(pdev, state);\n\t} else {\n\t\tdev_err(&pdev->dev, \"AER error_detected handler not registered.\\n\");\n\t\treturn PCI_ERS_RESULT_DISCONNECT;\n\t}\n}\n\nstatic pci_ers_result_t qlcnic_io_slot_reset(struct pci_dev *pdev)\n{\n\tstruct qlcnic_adapter *adapter = pci_get_drvdata(pdev);\n\tstruct qlcnic_hardware_ops *hw_ops = adapter->ahw->hw_ops;\n\n\tif (hw_ops->io_slot_reset) {\n\t\treturn hw_ops->io_slot_reset(pdev);\n\t} else {\n\t\tdev_err(&pdev->dev, \"AER slot_reset handler not registered.\\n\");\n\t\treturn PCI_ERS_RESULT_DISCONNECT;\n\t}\n}\n\nstatic void qlcnic_io_resume(struct pci_dev *pdev)\n{\n\tstruct qlcnic_adapter *adapter = pci_get_drvdata(pdev);\n\tstruct qlcnic_hardware_ops *hw_ops = adapter->ahw->hw_ops;\n\n\tif (hw_ops->io_resume)\n\t\thw_ops->io_resume(pdev);\n\telse\n\t\tdev_err(&pdev->dev, \"AER resume handler not registered.\\n\");\n}\n\n\nstatic int\nqlcnicvf_start_firmware(struct qlcnic_adapter *adapter)\n{\n\tint err;\n\n\terr = qlcnic_can_start_firmware(adapter);\n\tif (err)\n\t\treturn err;\n\n\terr = qlcnic_check_npar_opertional(adapter);\n\tif (err)\n\t\treturn err;\n\n\terr = qlcnic_initialize_nic(adapter);\n\tif (err)\n\t\treturn err;\n\n\tqlcnic_check_options(adapter);\n\n\terr = qlcnic_set_eswitch_port_config(adapter);\n\tif (err)\n\t\treturn err;\n\n\tadapter->need_fw_reset = 0;\n\n\treturn err;\n}\n\nint qlcnic_validate_rings(struct qlcnic_adapter *adapter, __u32 ring_cnt,\n\t\t\t  int queue_type)\n{\n\tstruct net_device *netdev = adapter->netdev;\n\tchar buf[8];\n\n\tif (queue_type == QLCNIC_RX_QUEUE)\n\t\tstrcpy(buf, \"SDS\");\n\telse\n\t\tstrcpy(buf, \"Tx\");\n\n\tif (!is_power_of_2(ring_cnt)) {\n\t\tnetdev_err(netdev, \"%s rings value should be a power of 2\\n\",\n\t\t\t   buf);\n\t\treturn -EINVAL;\n\t}\n\n\tif (qlcnic_82xx_check(adapter) && (queue_type == QLCNIC_TX_QUEUE) &&\n\t    !qlcnic_check_multi_tx(adapter)) {\n\t\t\tnetdev_err(netdev, \"No Multi Tx queue support\\n\");\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (ring_cnt > num_online_cpus()) {\n\t\tnetdev_err(netdev,\n\t\t\t   \"%s value[%u] should not be higher than, number of online CPUs\\n\",\n\t\t\t   buf, num_online_cpus());\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nint qlcnic_setup_rings(struct qlcnic_adapter *adapter)\n{\n\tstruct net_device *netdev = adapter->netdev;\n\tu8 tx_rings, rx_rings;\n\tint err;\n\n\tif (test_bit(__QLCNIC_RESETTING, &adapter->state))\n\t\treturn -EBUSY;\n\n\ttx_rings = adapter->drv_tss_rings;\n\trx_rings = adapter->drv_rss_rings;\n\n\tnetif_device_detach(netdev);\n\n\terr = qlcnic_set_real_num_queues(adapter, tx_rings, rx_rings);\n\tif (err)\n\t\tgoto done;\n\n\tif (netif_running(netdev))\n\t\t__qlcnic_down(adapter, netdev);\n\n\tqlcnic_detach(adapter);\n\n\tif (qlcnic_83xx_check(adapter)) {\n\t\tqlcnic_83xx_free_mbx_intr(adapter);\n\t\tqlcnic_83xx_enable_mbx_poll(adapter);\n\t}\n\n\tqlcnic_teardown_intr(adapter);\n\n\terr = qlcnic_setup_intr(adapter);\n\tif (err) {\n\t\tkfree(adapter->msix_entries);\n\t\tnetdev_err(netdev, \"failed to setup interrupt\\n\");\n\t\treturn err;\n\t}\n\n\t \n\tif ((tx_rings != adapter->drv_tx_rings) ||\n\t    (rx_rings != adapter->drv_sds_rings)) {\n\t\terr = qlcnic_set_real_num_queues(adapter,\n\t\t\t\t\t\t adapter->drv_tx_rings,\n\t\t\t\t\t\t adapter->drv_sds_rings);\n\t\tif (err)\n\t\t\tgoto done;\n\t}\n\n\tif (qlcnic_83xx_check(adapter)) {\n\t\tqlcnic_83xx_initialize_nic(adapter, 1);\n\t\terr = qlcnic_83xx_setup_mbx_intr(adapter);\n\t\tqlcnic_83xx_disable_mbx_poll(adapter);\n\t\tif (err) {\n\t\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\t\"failed to setup mbx interrupt\\n\");\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tif (netif_running(netdev)) {\n\t\terr = qlcnic_attach(adapter);\n\t\tif (err)\n\t\t\tgoto done;\n\t\terr = __qlcnic_up(adapter, netdev);\n\t\tif (err)\n\t\t\tgoto done;\n\t\tqlcnic_restore_indev_addr(netdev, NETDEV_UP);\n\t}\ndone:\n\tnetif_device_attach(netdev);\n\tclear_bit(__QLCNIC_RESETTING, &adapter->state);\n\treturn err;\n}\n\n#ifdef CONFIG_INET\n\n#define is_qlcnic_netdev(dev) (dev->netdev_ops == &qlcnic_netdev_ops)\n\nstatic void\nqlcnic_config_indev_addr(struct qlcnic_adapter *adapter,\n\t\t\tstruct net_device *dev, unsigned long event)\n{\n\tconst struct in_ifaddr *ifa;\n\tstruct in_device *indev;\n\n\tindev = in_dev_get(dev);\n\tif (!indev)\n\t\treturn;\n\n\tin_dev_for_each_ifa_rtnl(ifa, indev) {\n\t\tswitch (event) {\n\t\tcase NETDEV_UP:\n\t\t\tqlcnic_config_ipaddr(adapter,\n\t\t\t\t\tifa->ifa_address, QLCNIC_IP_UP);\n\t\t\tbreak;\n\t\tcase NETDEV_DOWN:\n\t\t\tqlcnic_config_ipaddr(adapter,\n\t\t\t\t\tifa->ifa_address, QLCNIC_IP_DOWN);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tin_dev_put(indev);\n}\n\nvoid qlcnic_restore_indev_addr(struct net_device *netdev, unsigned long event)\n{\n\tstruct qlcnic_adapter *adapter = netdev_priv(netdev);\n\tstruct net_device *dev;\n\tu16 vid;\n\n\tqlcnic_config_indev_addr(adapter, netdev, event);\n\n\trcu_read_lock();\n\tfor_each_set_bit(vid, adapter->vlans, VLAN_N_VID) {\n\t\tdev = __vlan_find_dev_deep_rcu(netdev, htons(ETH_P_8021Q), vid);\n\t\tif (!dev)\n\t\t\tcontinue;\n\t\tqlcnic_config_indev_addr(adapter, dev, event);\n\t}\n\trcu_read_unlock();\n}\n\nstatic int qlcnic_netdev_event(struct notifier_block *this,\n\t\t\t\t unsigned long event, void *ptr)\n{\n\tstruct qlcnic_adapter *adapter;\n\tstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\n\nrecheck:\n\tif (dev == NULL)\n\t\tgoto done;\n\n\tif (is_vlan_dev(dev)) {\n\t\tdev = vlan_dev_real_dev(dev);\n\t\tgoto recheck;\n\t}\n\n\tif (!is_qlcnic_netdev(dev))\n\t\tgoto done;\n\n\tadapter = netdev_priv(dev);\n\n\tif (!adapter)\n\t\tgoto done;\n\n\tif (!test_bit(__QLCNIC_DEV_UP, &adapter->state))\n\t\tgoto done;\n\n\tqlcnic_config_indev_addr(adapter, dev, event);\ndone:\n\treturn NOTIFY_DONE;\n}\n\nstatic int\nqlcnic_inetaddr_event(struct notifier_block *this,\n\t\tunsigned long event, void *ptr)\n{\n\tstruct qlcnic_adapter *adapter;\n\tstruct net_device *dev;\n\n\tstruct in_ifaddr *ifa = (struct in_ifaddr *)ptr;\n\n\tdev = ifa->ifa_dev ? ifa->ifa_dev->dev : NULL;\n\nrecheck:\n\tif (dev == NULL)\n\t\tgoto done;\n\n\tif (is_vlan_dev(dev)) {\n\t\tdev = vlan_dev_real_dev(dev);\n\t\tgoto recheck;\n\t}\n\n\tif (!is_qlcnic_netdev(dev))\n\t\tgoto done;\n\n\tadapter = netdev_priv(dev);\n\n\tif (!adapter)\n\t\tgoto done;\n\n\tif (!test_bit(__QLCNIC_DEV_UP, &adapter->state))\n\t\tgoto done;\n\n\tswitch (event) {\n\tcase NETDEV_UP:\n\t\tqlcnic_config_ipaddr(adapter, ifa->ifa_address, QLCNIC_IP_UP);\n\n\t\tbreak;\n\tcase NETDEV_DOWN:\n\t\tqlcnic_config_ipaddr(adapter, ifa->ifa_address, QLCNIC_IP_DOWN);\n\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\ndone:\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block\tqlcnic_netdev_cb = {\n\t.notifier_call = qlcnic_netdev_event,\n};\n\nstatic struct notifier_block qlcnic_inetaddr_cb = {\n\t.notifier_call = qlcnic_inetaddr_event,\n};\n#else\nvoid qlcnic_restore_indev_addr(struct net_device *dev, unsigned long event)\n{ }\n#endif\nstatic const struct pci_error_handlers qlcnic_err_handler = {\n\t.error_detected = qlcnic_io_error_detected,\n\t.slot_reset = qlcnic_io_slot_reset,\n\t.resume = qlcnic_io_resume,\n};\n\nstatic SIMPLE_DEV_PM_OPS(qlcnic_pm_ops, qlcnic_suspend, qlcnic_resume);\n\nstatic struct pci_driver qlcnic_driver = {\n\t.name = qlcnic_driver_name,\n\t.id_table = qlcnic_pci_tbl,\n\t.probe = qlcnic_probe,\n\t.remove = qlcnic_remove,\n\t.driver.pm = &qlcnic_pm_ops,\n\t.shutdown = qlcnic_shutdown,\n\t.err_handler = &qlcnic_err_handler,\n#ifdef CONFIG_QLCNIC_SRIOV\n\t.sriov_configure = qlcnic_pci_sriov_configure,\n#endif\n\n};\n\nstatic int __init qlcnic_init_module(void)\n{\n\tint ret;\n\n\tprintk(KERN_INFO \"%s\\n\", qlcnic_driver_string);\n\n#ifdef CONFIG_INET\n\tregister_netdevice_notifier(&qlcnic_netdev_cb);\n\tregister_inetaddr_notifier(&qlcnic_inetaddr_cb);\n#endif\n\n\tret = pci_register_driver(&qlcnic_driver);\n\tif (ret) {\n#ifdef CONFIG_INET\n\t\tunregister_inetaddr_notifier(&qlcnic_inetaddr_cb);\n\t\tunregister_netdevice_notifier(&qlcnic_netdev_cb);\n#endif\n\t}\n\n\treturn ret;\n}\n\nmodule_init(qlcnic_init_module);\n\nstatic void __exit qlcnic_exit_module(void)\n{\n\tpci_unregister_driver(&qlcnic_driver);\n\n#ifdef CONFIG_INET\n\tunregister_inetaddr_notifier(&qlcnic_inetaddr_cb);\n\tunregister_netdevice_notifier(&qlcnic_netdev_cb);\n#endif\n}\n\nmodule_exit(qlcnic_exit_module);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}