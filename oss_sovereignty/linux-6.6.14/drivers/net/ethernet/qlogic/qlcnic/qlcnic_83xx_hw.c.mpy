{
  "module_name": "qlcnic_83xx_hw.c",
  "hash_id": "f61ce64ac335223ab10aea79fadbd95e11ad6051e651e4fb4ca2907b0b8cbdf0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c",
  "human_readable_source": "\n \n\n#include <linux/if_vlan.h>\n#include <linux/ipv6.h>\n#include <linux/ethtool.h>\n#include <linux/interrupt.h>\n\n#include \"qlcnic.h\"\n#include \"qlcnic_sriov.h\"\n\nstatic void __qlcnic_83xx_process_aen(struct qlcnic_adapter *);\nstatic int qlcnic_83xx_clear_lb_mode(struct qlcnic_adapter *, u8);\nstatic void qlcnic_83xx_configure_mac(struct qlcnic_adapter *, u8 *, u8,\n\t\t\t\t      struct qlcnic_cmd_args *);\nstatic int qlcnic_83xx_get_port_config(struct qlcnic_adapter *);\nstatic irqreturn_t qlcnic_83xx_handle_aen(int, void *);\nstatic pci_ers_result_t qlcnic_83xx_io_error_detected(struct pci_dev *,\n\t\t\t\t\t\t      pci_channel_state_t);\nstatic int qlcnic_83xx_set_port_config(struct qlcnic_adapter *);\nstatic pci_ers_result_t qlcnic_83xx_io_slot_reset(struct pci_dev *);\nstatic void qlcnic_83xx_io_resume(struct pci_dev *);\nstatic int qlcnic_83xx_set_lb_mode(struct qlcnic_adapter *, u8);\nstatic void qlcnic_83xx_set_mac_filter_count(struct qlcnic_adapter *);\nstatic int qlcnic_83xx_resume(struct qlcnic_adapter *);\nstatic int qlcnic_83xx_shutdown(struct pci_dev *);\nstatic void qlcnic_83xx_get_beacon_state(struct qlcnic_adapter *);\n\n#define RSS_HASHTYPE_IP_TCP\t\t0x3\n#define QLC_83XX_FW_MBX_CMD\t\t0\n#define QLC_SKIP_INACTIVE_PCI_REGS\t7\n#define QLC_MAX_LEGACY_FUNC_SUPP\t8\n\n \n#define QLC_83XX_MODULE_FIBRE_10GBASE_LRM\t0x1  \n#define QLC_83XX_MODULE_FIBRE_10GBASE_LR\t0x2  \n#define QLC_83XX_MODULE_FIBRE_10GBASE_SR\t0x3  \n#define QLC_83XX_MODULE_DA_10GE_PASSIVE_CP\t0x4  \n#define QLC_83XX_MODULE_DA_10GE_ACTIVE_CP\t0x5  \n#define QLC_83XX_MODULE_DA_10GE_LEGACY_CP\t0x6  \n#define QLC_83XX_MODULE_FIBRE_1000BASE_SX\t0x7  \n#define QLC_83XX_MODULE_FIBRE_1000BASE_LX\t0x8  \n#define QLC_83XX_MODULE_FIBRE_1000BASE_CX\t0x9  \n#define QLC_83XX_MODULE_TP_1000BASE_T\t\t0xa  \n#define QLC_83XX_MODULE_DA_1GE_PASSIVE_CP\t0xb  \n#define QLC_83XX_MODULE_UNKNOWN\t\t\t0xf  \n\n \n#define QLC_83XX_10_CAPABLE\t BIT_8\n#define QLC_83XX_100_CAPABLE\t BIT_9\n#define QLC_83XX_1G_CAPABLE\t BIT_10\n#define QLC_83XX_10G_CAPABLE\t BIT_11\n#define QLC_83XX_AUTONEG_ENABLE\t BIT_15\n\nstatic const struct qlcnic_mailbox_metadata qlcnic_83xx_mbx_tbl[] = {\n\t{QLCNIC_CMD_CONFIGURE_IP_ADDR, 6, 1},\n\t{QLCNIC_CMD_CONFIG_INTRPT, 18, 34},\n\t{QLCNIC_CMD_CREATE_RX_CTX, 136, 27},\n\t{QLCNIC_CMD_DESTROY_RX_CTX, 2, 1},\n\t{QLCNIC_CMD_CREATE_TX_CTX, 54, 18},\n\t{QLCNIC_CMD_DESTROY_TX_CTX, 2, 1},\n\t{QLCNIC_CMD_CONFIGURE_MAC_LEARNING, 2, 1},\n\t{QLCNIC_CMD_INTRPT_TEST, 22, 12},\n\t{QLCNIC_CMD_SET_MTU, 3, 1},\n\t{QLCNIC_CMD_READ_PHY, 4, 2},\n\t{QLCNIC_CMD_WRITE_PHY, 5, 1},\n\t{QLCNIC_CMD_READ_HW_REG, 4, 1},\n\t{QLCNIC_CMD_GET_FLOW_CTL, 4, 2},\n\t{QLCNIC_CMD_SET_FLOW_CTL, 4, 1},\n\t{QLCNIC_CMD_READ_MAX_MTU, 4, 2},\n\t{QLCNIC_CMD_READ_MAX_LRO, 4, 2},\n\t{QLCNIC_CMD_MAC_ADDRESS, 4, 3},\n\t{QLCNIC_CMD_GET_PCI_INFO, 1, 129},\n\t{QLCNIC_CMD_GET_NIC_INFO, 2, 19},\n\t{QLCNIC_CMD_SET_NIC_INFO, 32, 1},\n\t{QLCNIC_CMD_GET_ESWITCH_CAPABILITY, 4, 3},\n\t{QLCNIC_CMD_TOGGLE_ESWITCH, 4, 1},\n\t{QLCNIC_CMD_GET_ESWITCH_STATUS, 4, 3},\n\t{QLCNIC_CMD_SET_PORTMIRRORING, 4, 1},\n\t{QLCNIC_CMD_CONFIGURE_ESWITCH, 4, 1},\n\t{QLCNIC_CMD_GET_ESWITCH_PORT_CONFIG, 4, 3},\n\t{QLCNIC_CMD_GET_ESWITCH_STATS, 5, 1},\n\t{QLCNIC_CMD_CONFIG_PORT, 4, 1},\n\t{QLCNIC_CMD_TEMP_SIZE, 1, 4},\n\t{QLCNIC_CMD_GET_TEMP_HDR, 5, 5},\n\t{QLCNIC_CMD_GET_LINK_EVENT, 2, 1},\n\t{QLCNIC_CMD_CONFIG_MAC_VLAN, 4, 3},\n\t{QLCNIC_CMD_CONFIG_INTR_COAL, 6, 1},\n\t{QLCNIC_CMD_CONFIGURE_RSS, 14, 1},\n\t{QLCNIC_CMD_CONFIGURE_LED, 2, 1},\n\t{QLCNIC_CMD_CONFIGURE_MAC_RX_MODE, 2, 1},\n\t{QLCNIC_CMD_CONFIGURE_HW_LRO, 2, 1},\n\t{QLCNIC_CMD_GET_STATISTICS, 2, 80},\n\t{QLCNIC_CMD_SET_PORT_CONFIG, 2, 1},\n\t{QLCNIC_CMD_GET_PORT_CONFIG, 2, 2},\n\t{QLCNIC_CMD_GET_LINK_STATUS, 2, 4},\n\t{QLCNIC_CMD_IDC_ACK, 5, 1},\n\t{QLCNIC_CMD_INIT_NIC_FUNC, 3, 1},\n\t{QLCNIC_CMD_STOP_NIC_FUNC, 2, 1},\n\t{QLCNIC_CMD_SET_LED_CONFIG, 5, 1},\n\t{QLCNIC_CMD_GET_LED_CONFIG, 1, 5},\n\t{QLCNIC_CMD_83XX_SET_DRV_VER, 4, 1},\n\t{QLCNIC_CMD_ADD_RCV_RINGS, 130, 26},\n\t{QLCNIC_CMD_CONFIG_VPORT, 4, 4},\n\t{QLCNIC_CMD_BC_EVENT_SETUP, 2, 1},\n\t{QLCNIC_CMD_DCB_QUERY_CAP, 1, 2},\n\t{QLCNIC_CMD_DCB_QUERY_PARAM, 1, 50},\n\t{QLCNIC_CMD_SET_INGRESS_ENCAP, 2, 1},\n\t{QLCNIC_CMD_83XX_EXTEND_ISCSI_DUMP_CAP, 4, 1},\n};\n\nconst u32 qlcnic_83xx_ext_reg_tbl[] = {\n\t0x38CC,\t\t \n\t0x38F0,\t\t \n\t0x38FC,\t\t \n\t0x3038,\t\t \n\t0x303C,\t\t \n\t0x355C,\t\t \n\t0x3560,\t\t \n\t0x3564,\t\t \n\t0x1000,\t\t \n\t0x1200,\t\t \n\t0x1204,\t\t \n\t0x3780,\t\t \n\t0x3784,\t\t \n\t0x3788,\t\t \n\t0x378C,\t\t \n\t0x3790,\t\t \n\t0x3794,\t\t \n\t0x3798,\t\t \n\t0x379C,\t\t \n\t0x37A0,\t\t \n\t0x37A4,\t\t \n\t0x37A8,\t\t \n\t0x37AC,\t\t \n\t0x37B0,\t\t \n\t0x37B4,\t\t \n\t0x37B8,\t\t \n\t0x37BC,\t\t \n\t0x37C0,\t\t \n\t0x37C4,\t\t \n\t0x37C8,\t\t \n\t0x37CC,\t\t \n\t0x37D0,\t\t \n\t0x37D4,\t\t \n\t0x37D8,\t\t \n\t0x37DC,\t\t \n\t0x37E0,\t\t \n\t0x37E4,\t\t \n\t0x37F0,\t\t \n\t0x37F4,\t\t \n\t0x3868,\t\t \n\t0x386C,\t\t \n\t0x3504,\t\t \n\t0x34A4,\t\t \n};\n\nconst u32 qlcnic_83xx_reg_tbl[] = {\n\t0x34A8,\t\t \n\t0x34AC,\t\t \n\t0x34B0,\t\t \n\t0x3500,\t\t \n\t0x3528,\t\t \n\t0x3538,\t\t \n\t0x3540,\t\t \n\t0x3544,\t\t \n\t0x3548,\t\t \n\t0x354C,\t\t \n\t0x3524,\t\t \n\t0x3550,\t\t \n\t0x3554,\t\t \n\t0x3558,\t\t \n\t0x359C,\t\t \n\t0x35FC,\t\t \n\t0x3650,\t\t \n\t0x373C,\t\t \n\t0x37B4,\t\t \n\t0x356C,\t\t \n\t0x3570,\t\t \n\t0x3850,\t\t \n\t0x3854,\t\t \n};\n\nstatic struct qlcnic_hardware_ops qlcnic_83xx_hw_ops = {\n\t.read_crb\t\t\t= qlcnic_83xx_read_crb,\n\t.write_crb\t\t\t= qlcnic_83xx_write_crb,\n\t.read_reg\t\t\t= qlcnic_83xx_rd_reg_indirect,\n\t.write_reg\t\t\t= qlcnic_83xx_wrt_reg_indirect,\n\t.get_mac_address\t\t= qlcnic_83xx_get_mac_address,\n\t.setup_intr\t\t\t= qlcnic_83xx_setup_intr,\n\t.alloc_mbx_args\t\t\t= qlcnic_83xx_alloc_mbx_args,\n\t.mbx_cmd\t\t\t= qlcnic_83xx_issue_cmd,\n\t.get_func_no\t\t\t= qlcnic_83xx_get_func_no,\n\t.api_lock\t\t\t= qlcnic_83xx_cam_lock,\n\t.api_unlock\t\t\t= qlcnic_83xx_cam_unlock,\n\t.add_sysfs\t\t\t= qlcnic_83xx_add_sysfs,\n\t.remove_sysfs\t\t\t= qlcnic_83xx_remove_sysfs,\n\t.process_lb_rcv_ring_diag\t= qlcnic_83xx_process_rcv_ring_diag,\n\t.create_rx_ctx\t\t\t= qlcnic_83xx_create_rx_ctx,\n\t.create_tx_ctx\t\t\t= qlcnic_83xx_create_tx_ctx,\n\t.del_rx_ctx\t\t\t= qlcnic_83xx_del_rx_ctx,\n\t.del_tx_ctx\t\t\t= qlcnic_83xx_del_tx_ctx,\n\t.setup_link_event\t\t= qlcnic_83xx_setup_link_event,\n\t.get_nic_info\t\t\t= qlcnic_83xx_get_nic_info,\n\t.get_pci_info\t\t\t= qlcnic_83xx_get_pci_info,\n\t.set_nic_info\t\t\t= qlcnic_83xx_set_nic_info,\n\t.change_macvlan\t\t\t= qlcnic_83xx_sre_macaddr_change,\n\t.napi_enable\t\t\t= qlcnic_83xx_napi_enable,\n\t.napi_disable\t\t\t= qlcnic_83xx_napi_disable,\n\t.config_intr_coal\t\t= qlcnic_83xx_config_intr_coal,\n\t.config_rss\t\t\t= qlcnic_83xx_config_rss,\n\t.config_hw_lro\t\t\t= qlcnic_83xx_config_hw_lro,\n\t.config_promisc_mode\t\t= qlcnic_83xx_nic_set_promisc,\n\t.change_l2_filter\t\t= qlcnic_83xx_change_l2_filter,\n\t.get_board_info\t\t\t= qlcnic_83xx_get_port_info,\n\t.set_mac_filter_count\t\t= qlcnic_83xx_set_mac_filter_count,\n\t.free_mac_list\t\t\t= qlcnic_82xx_free_mac_list,\n\t.io_error_detected\t\t= qlcnic_83xx_io_error_detected,\n\t.io_slot_reset\t\t\t= qlcnic_83xx_io_slot_reset,\n\t.io_resume\t\t\t= qlcnic_83xx_io_resume,\n\t.get_beacon_state\t\t= qlcnic_83xx_get_beacon_state,\n\t.enable_sds_intr\t\t= qlcnic_83xx_enable_sds_intr,\n\t.disable_sds_intr\t\t= qlcnic_83xx_disable_sds_intr,\n\t.enable_tx_intr\t\t\t= qlcnic_83xx_enable_tx_intr,\n\t.disable_tx_intr\t\t= qlcnic_83xx_disable_tx_intr,\n\t.get_saved_state\t\t= qlcnic_83xx_get_saved_state,\n\t.set_saved_state\t\t= qlcnic_83xx_set_saved_state,\n\t.cache_tmpl_hdr_values\t\t= qlcnic_83xx_cache_tmpl_hdr_values,\n\t.get_cap_size\t\t\t= qlcnic_83xx_get_cap_size,\n\t.set_sys_info\t\t\t= qlcnic_83xx_set_sys_info,\n\t.store_cap_mask\t\t\t= qlcnic_83xx_store_cap_mask,\n\t.encap_rx_offload\t\t= qlcnic_83xx_encap_rx_offload,\n\t.encap_tx_offload\t\t= qlcnic_83xx_encap_tx_offload,\n};\n\nstatic struct qlcnic_nic_template qlcnic_83xx_ops = {\n\t.config_bridged_mode\t= qlcnic_config_bridged_mode,\n\t.config_led\t\t= qlcnic_config_led,\n\t.request_reset          = qlcnic_83xx_idc_request_reset,\n\t.cancel_idc_work        = qlcnic_83xx_idc_exit,\n\t.napi_add\t\t= qlcnic_83xx_napi_add,\n\t.napi_del\t\t= qlcnic_83xx_napi_del,\n\t.config_ipaddr\t\t= qlcnic_83xx_config_ipaddr,\n\t.clear_legacy_intr\t= qlcnic_83xx_clear_legacy_intr,\n\t.shutdown\t\t= qlcnic_83xx_shutdown,\n\t.resume\t\t\t= qlcnic_83xx_resume,\n};\n\nvoid qlcnic_83xx_register_map(struct qlcnic_hardware_context *ahw)\n{\n\tahw->hw_ops\t\t= &qlcnic_83xx_hw_ops;\n\tahw->reg_tbl\t\t= (u32 *)qlcnic_83xx_reg_tbl;\n\tahw->ext_reg_tbl\t= (u32 *)qlcnic_83xx_ext_reg_tbl;\n}\n\nint qlcnic_83xx_get_fw_version(struct qlcnic_adapter *adapter)\n{\n\tu32 fw_major, fw_minor, fw_build;\n\tstruct pci_dev *pdev = adapter->pdev;\n\n\tfw_major = QLC_SHARED_REG_RD32(adapter, QLCNIC_FW_VERSION_MAJOR);\n\tfw_minor = QLC_SHARED_REG_RD32(adapter, QLCNIC_FW_VERSION_MINOR);\n\tfw_build = QLC_SHARED_REG_RD32(adapter, QLCNIC_FW_VERSION_SUB);\n\tadapter->fw_version = QLCNIC_VERSION_CODE(fw_major, fw_minor, fw_build);\n\n\tdev_info(&pdev->dev, \"Driver v%s, firmware version %d.%d.%d\\n\",\n\t\t QLCNIC_LINUX_VERSIONID, fw_major, fw_minor, fw_build);\n\n\treturn adapter->fw_version;\n}\n\nstatic int __qlcnic_set_win_base(struct qlcnic_adapter *adapter, u32 addr)\n{\n\tvoid __iomem *base;\n\tu32 val;\n\n\tbase = adapter->ahw->pci_base0 +\n\t       QLC_83XX_CRB_WIN_FUNC(adapter->ahw->pci_func);\n\twritel(addr, base);\n\tval = readl(base);\n\tif (val != addr)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nint qlcnic_83xx_rd_reg_indirect(struct qlcnic_adapter *adapter, ulong addr,\n\t\t\t\tint *err)\n{\n\tstruct qlcnic_hardware_context *ahw = adapter->ahw;\n\n\t*err = __qlcnic_set_win_base(adapter, (u32) addr);\n\tif (!*err) {\n\t\treturn QLCRDX(ahw, QLCNIC_WILDCARD);\n\t} else {\n\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\"%s failed, addr = 0x%lx\\n\", __func__, addr);\n\t\treturn -EIO;\n\t}\n}\n\nint qlcnic_83xx_wrt_reg_indirect(struct qlcnic_adapter *adapter, ulong addr,\n\t\t\t\t u32 data)\n{\n\tint err;\n\tstruct qlcnic_hardware_context *ahw = adapter->ahw;\n\n\terr = __qlcnic_set_win_base(adapter, (u32) addr);\n\tif (!err) {\n\t\tQLCWRX(ahw, QLCNIC_WILDCARD, data);\n\t\treturn 0;\n\t} else {\n\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\"%s failed, addr = 0x%x data = 0x%x\\n\",\n\t\t\t__func__, (int)addr, data);\n\t\treturn err;\n\t}\n}\n\nstatic void qlcnic_83xx_enable_legacy(struct qlcnic_adapter *adapter)\n{\n\tstruct qlcnic_hardware_context *ahw = adapter->ahw;\n\n\t \n\tadapter->tgt_status_reg = ahw->pci_base0 + QLC_83XX_INTX_PTR;\n\tadapter->tgt_mask_reg = ahw->pci_base0 + QLC_83XX_INTX_MASK;\n\tadapter->isr_int_vec = ahw->pci_base0 + QLC_83XX_INTX_TRGR;\n\tadapter->msix_entries[0].vector = adapter->pdev->irq;\n\tdev_info(&adapter->pdev->dev, \"using legacy interrupt\\n\");\n}\n\nstatic int qlcnic_83xx_calculate_msix_vector(struct qlcnic_adapter *adapter)\n{\n\tint num_msix;\n\n\tnum_msix = adapter->drv_sds_rings;\n\n\t \n\tnum_msix += 1;\n\n\tif (!(adapter->flags & QLCNIC_TX_INTR_SHARED))\n\t\tnum_msix += adapter->drv_tx_rings;\n\n\treturn num_msix;\n}\n\nint qlcnic_83xx_setup_intr(struct qlcnic_adapter *adapter)\n{\n\tstruct qlcnic_hardware_context *ahw = adapter->ahw;\n\tint err, i, num_msix;\n\n\tif (adapter->flags & QLCNIC_TSS_RSS) {\n\t\terr = qlcnic_setup_tss_rss_intr(adapter);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tnum_msix = ahw->num_msix;\n\t} else {\n\t\tnum_msix = qlcnic_83xx_calculate_msix_vector(adapter);\n\n\t\terr = qlcnic_enable_msix(adapter, num_msix);\n\t\tif (err == -ENOMEM)\n\t\t\treturn err;\n\n\t\tif (adapter->flags & QLCNIC_MSIX_ENABLED) {\n\t\t\tnum_msix = ahw->num_msix;\n\t\t} else {\n\t\t\tif (qlcnic_sriov_vf_check(adapter))\n\t\t\t\treturn -EINVAL;\n\t\t\tnum_msix = 1;\n\t\t\tadapter->drv_sds_rings = QLCNIC_SINGLE_RING;\n\t\t\tadapter->drv_tx_rings = QLCNIC_SINGLE_RING;\n\t\t}\n\t}\n\n\t \n\tahw->intr_tbl =\n\t\tvzalloc(array_size(num_msix,\n\t\t\t\t   sizeof(struct qlcnic_intrpt_config)));\n\tif (!ahw->intr_tbl)\n\t\treturn -ENOMEM;\n\n\tif (!(adapter->flags & QLCNIC_MSIX_ENABLED)) {\n\t\tif (adapter->ahw->pci_func >= QLC_MAX_LEGACY_FUNC_SUPP) {\n\t\t\tdev_err(&adapter->pdev->dev, \"PCI function number 8 and higher are not supported with legacy interrupt, func 0x%x\\n\",\n\t\t\t\tahw->pci_func);\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\n\t\tqlcnic_83xx_enable_legacy(adapter);\n\t}\n\n\tfor (i = 0; i < num_msix; i++) {\n\t\tif (adapter->flags & QLCNIC_MSIX_ENABLED)\n\t\t\tahw->intr_tbl[i].type = QLCNIC_INTRPT_MSIX;\n\t\telse\n\t\t\tahw->intr_tbl[i].type = QLCNIC_INTRPT_INTX;\n\t\tahw->intr_tbl[i].id = i;\n\t\tahw->intr_tbl[i].src = 0;\n\t}\n\n\treturn 0;\n}\n\nstatic inline void qlcnic_83xx_clear_legacy_intr_mask(struct qlcnic_adapter *adapter)\n{\n\twritel(0, adapter->tgt_mask_reg);\n}\n\nstatic inline void qlcnic_83xx_set_legacy_intr_mask(struct qlcnic_adapter *adapter)\n{\n\tif (adapter->tgt_mask_reg)\n\t\twritel(1, adapter->tgt_mask_reg);\n}\n\nstatic inline void qlcnic_83xx_enable_legacy_msix_mbx_intr(struct qlcnic_adapter\n\t\t\t\t\t\t    *adapter)\n{\n\tu32 mask;\n\n\t \n\tmask = QLCRDX(adapter->ahw, QLCNIC_DEF_INT_MASK);\n\twritel(0, adapter->ahw->pci_base0 + mask);\n}\n\nvoid qlcnic_83xx_disable_mbx_intr(struct qlcnic_adapter *adapter)\n{\n\tu32 mask;\n\n\tmask = QLCRDX(adapter->ahw, QLCNIC_DEF_INT_MASK);\n\twritel(1, adapter->ahw->pci_base0 + mask);\n\tQLCWRX(adapter->ahw, QLCNIC_MBX_INTR_ENBL, 0);\n}\n\nstatic inline void qlcnic_83xx_get_mbx_data(struct qlcnic_adapter *adapter,\n\t\t\t\t     struct qlcnic_cmd_args *cmd)\n{\n\tint i;\n\n\tif (cmd->op_type == QLC_83XX_MBX_POST_BC_OP)\n\t\treturn;\n\n\tfor (i = 0; i < cmd->rsp.num; i++)\n\t\tcmd->rsp.arg[i] = readl(QLCNIC_MBX_FW(adapter->ahw, i));\n}\n\nirqreturn_t qlcnic_83xx_clear_legacy_intr(struct qlcnic_adapter *adapter)\n{\n\tu32 intr_val;\n\tstruct qlcnic_hardware_context *ahw = adapter->ahw;\n\tint retries = 0;\n\n\tintr_val = readl(adapter->tgt_status_reg);\n\n\tif (!QLC_83XX_VALID_INTX_BIT31(intr_val))\n\t\treturn IRQ_NONE;\n\n\tif (QLC_83XX_INTX_FUNC(intr_val) != adapter->ahw->pci_func) {\n\t\tadapter->stats.spurious_intr++;\n\t\treturn IRQ_NONE;\n\t}\n\t \n\twmb();\n\n\t \n\twritel_relaxed(0, adapter->isr_int_vec);\n\tintr_val = readl(adapter->isr_int_vec);\n\tdo {\n\t\tintr_val = readl(adapter->tgt_status_reg);\n\t\tif (QLC_83XX_INTX_FUNC(intr_val) != ahw->pci_func)\n\t\t\tbreak;\n\t\tretries++;\n\t} while (QLC_83XX_VALID_INTX_BIT30(intr_val) &&\n\t\t (retries < QLC_83XX_LEGACY_INTX_MAX_RETRY));\n\n\treturn IRQ_HANDLED;\n}\n\nstatic inline void qlcnic_83xx_notify_mbx_response(struct qlcnic_mailbox *mbx)\n{\n\tmbx->rsp_status = QLC_83XX_MBX_RESPONSE_ARRIVED;\n\tcomplete(&mbx->completion);\n}\n\nstatic void qlcnic_83xx_poll_process_aen(struct qlcnic_adapter *adapter)\n{\n\tu32 resp, event, rsp_status = QLC_83XX_MBX_RESPONSE_ARRIVED;\n\tstruct qlcnic_mailbox *mbx = adapter->ahw->mailbox;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&mbx->aen_lock, flags);\n\tresp = QLCRDX(adapter->ahw, QLCNIC_FW_MBX_CTRL);\n\tif (!(resp & QLCNIC_SET_OWNER))\n\t\tgoto out;\n\n\tevent = readl(QLCNIC_MBX_FW(adapter->ahw, 0));\n\tif (event &  QLCNIC_MBX_ASYNC_EVENT) {\n\t\t__qlcnic_83xx_process_aen(adapter);\n\t} else {\n\t\tif (mbx->rsp_status != rsp_status)\n\t\t\tqlcnic_83xx_notify_mbx_response(mbx);\n\t}\nout:\n\tqlcnic_83xx_enable_legacy_msix_mbx_intr(adapter);\n\tspin_unlock_irqrestore(&mbx->aen_lock, flags);\n}\n\nirqreturn_t qlcnic_83xx_intr(int irq, void *data)\n{\n\tstruct qlcnic_adapter *adapter = data;\n\tstruct qlcnic_host_sds_ring *sds_ring;\n\tstruct qlcnic_hardware_context *ahw = adapter->ahw;\n\n\tif (qlcnic_83xx_clear_legacy_intr(adapter) == IRQ_NONE)\n\t\treturn IRQ_NONE;\n\n\tqlcnic_83xx_poll_process_aen(adapter);\n\n\tif (ahw->diag_test) {\n\t\tif (ahw->diag_test == QLCNIC_INTERRUPT_TEST)\n\t\t\tahw->diag_cnt++;\n\t\tqlcnic_83xx_enable_legacy_msix_mbx_intr(adapter);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tif (!test_bit(__QLCNIC_DEV_UP, &adapter->state)) {\n\t\tqlcnic_83xx_enable_legacy_msix_mbx_intr(adapter);\n\t} else {\n\t\tsds_ring = &adapter->recv_ctx->sds_rings[0];\n\t\tnapi_schedule(&sds_ring->napi);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nirqreturn_t qlcnic_83xx_tmp_intr(int irq, void *data)\n{\n\tstruct qlcnic_host_sds_ring *sds_ring = data;\n\tstruct qlcnic_adapter *adapter = sds_ring->adapter;\n\n\tif (adapter->flags & QLCNIC_MSIX_ENABLED)\n\t\tgoto done;\n\n\tif (adapter->nic_ops->clear_legacy_intr(adapter) == IRQ_NONE)\n\t\treturn IRQ_NONE;\n\ndone:\n\tadapter->ahw->diag_cnt++;\n\tqlcnic_enable_sds_intr(adapter, sds_ring);\n\n\treturn IRQ_HANDLED;\n}\n\nvoid qlcnic_83xx_free_mbx_intr(struct qlcnic_adapter *adapter)\n{\n\tu32 num_msix;\n\n\tif (!(adapter->flags & QLCNIC_MSIX_ENABLED))\n\t\tqlcnic_83xx_set_legacy_intr_mask(adapter);\n\n\tqlcnic_83xx_disable_mbx_intr(adapter);\n\n\tif (adapter->flags & QLCNIC_MSIX_ENABLED)\n\t\tnum_msix = adapter->ahw->num_msix - 1;\n\telse\n\t\tnum_msix = 0;\n\n\tmsleep(20);\n\n\tif (adapter->msix_entries) {\n\t\tsynchronize_irq(adapter->msix_entries[num_msix].vector);\n\t\tfree_irq(adapter->msix_entries[num_msix].vector, adapter);\n\t}\n}\n\nint qlcnic_83xx_setup_mbx_intr(struct qlcnic_adapter *adapter)\n{\n\tirq_handler_t handler;\n\tu32 val;\n\tint err = 0;\n\tunsigned long flags = 0;\n\n\tif (!(adapter->flags & QLCNIC_MSI_ENABLED) &&\n\t    !(adapter->flags & QLCNIC_MSIX_ENABLED))\n\t\tflags |= IRQF_SHARED;\n\n\tif (adapter->flags & QLCNIC_MSIX_ENABLED) {\n\t\thandler = qlcnic_83xx_handle_aen;\n\t\tval = adapter->msix_entries[adapter->ahw->num_msix - 1].vector;\n\t\terr = request_irq(val, handler, flags, \"qlcnic-MB\", adapter);\n\t\tif (err) {\n\t\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\t\"failed to register MBX interrupt\\n\");\n\t\t\treturn err;\n\t\t}\n\t} else {\n\t\thandler = qlcnic_83xx_intr;\n\t\tval = adapter->msix_entries[0].vector;\n\t\terr = request_irq(val, handler, flags, \"qlcnic\", adapter);\n\t\tif (err) {\n\t\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\t\"failed to register INTx interrupt\\n\");\n\t\t\treturn err;\n\t\t}\n\t\tqlcnic_83xx_clear_legacy_intr_mask(adapter);\n\t}\n\n\t \n\tqlcnic_83xx_enable_mbx_interrupt(adapter);\n\n\treturn err;\n}\n\nvoid qlcnic_83xx_get_func_no(struct qlcnic_adapter *adapter)\n{\n\tu32 val = QLCRDX(adapter->ahw, QLCNIC_INFORMANT);\n\tadapter->ahw->pci_func = (val >> 24) & 0xff;\n}\n\nint qlcnic_83xx_cam_lock(struct qlcnic_adapter *adapter)\n{\n\tvoid __iomem *addr;\n\tu32 val, limit = 0;\n\n\tstruct qlcnic_hardware_context *ahw = adapter->ahw;\n\n\taddr = ahw->pci_base0 + QLC_83XX_SEM_LOCK_FUNC(ahw->pci_func);\n\tdo {\n\t\tval = readl(addr);\n\t\tif (val) {\n\t\t\t \n\t\t\tQLC_SHARED_REG_WR32(adapter, QLCNIC_FLASH_LOCK_OWNER,\n\t\t\t\t\t    ahw->pci_func);\n\t\t\treturn 0;\n\t\t}\n\t\tusleep_range(1000, 2000);\n\t} while (++limit <= QLCNIC_PCIE_SEM_TIMEOUT);\n\n\treturn -EIO;\n}\n\nvoid qlcnic_83xx_cam_unlock(struct qlcnic_adapter *adapter)\n{\n\tvoid __iomem *addr;\n\tstruct qlcnic_hardware_context *ahw = adapter->ahw;\n\n\taddr = ahw->pci_base0 + QLC_83XX_SEM_UNLOCK_FUNC(ahw->pci_func);\n\treadl(addr);\n}\n\nvoid qlcnic_83xx_read_crb(struct qlcnic_adapter *adapter, char *buf,\n\t\t\t  loff_t offset, size_t size)\n{\n\tint ret = 0;\n\tu32 data;\n\n\tif (qlcnic_api_lock(adapter)) {\n\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\"%s: failed to acquire lock. addr offset 0x%x\\n\",\n\t\t\t__func__, (u32)offset);\n\t\treturn;\n\t}\n\n\tdata = QLCRD32(adapter, (u32) offset, &ret);\n\tqlcnic_api_unlock(adapter);\n\n\tif (ret == -EIO) {\n\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\"%s: failed. addr offset 0x%x\\n\",\n\t\t\t__func__, (u32)offset);\n\t\treturn;\n\t}\n\tmemcpy(buf, &data, size);\n}\n\nvoid qlcnic_83xx_write_crb(struct qlcnic_adapter *adapter, char *buf,\n\t\t\t   loff_t offset, size_t size)\n{\n\tu32 data;\n\n\tmemcpy(&data, buf, size);\n\tqlcnic_83xx_wrt_reg_indirect(adapter, (u32) offset, data);\n}\n\nint qlcnic_83xx_get_port_info(struct qlcnic_adapter *adapter)\n{\n\tstruct qlcnic_hardware_context *ahw = adapter->ahw;\n\tint status;\n\n\tstatus = qlcnic_83xx_get_port_config(adapter);\n\tif (status) {\n\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\"Get Port Info failed\\n\");\n\t} else {\n\n\t\tif (ahw->port_config & QLC_83XX_10G_CAPABLE) {\n\t\t\tahw->port_type = QLCNIC_XGBE;\n\t\t} else if (ahw->port_config & QLC_83XX_10_CAPABLE ||\n\t\t\t   ahw->port_config & QLC_83XX_100_CAPABLE ||\n\t\t\t   ahw->port_config & QLC_83XX_1G_CAPABLE) {\n\t\t\tahw->port_type = QLCNIC_GBE;\n\t\t} else {\n\t\t\tahw->port_type = QLCNIC_XGBE;\n\t\t}\n\n\t\tif (QLC_83XX_AUTONEG(ahw->port_config))\n\t\t\tahw->link_autoneg = AUTONEG_ENABLE;\n\n\t}\n\treturn status;\n}\n\nstatic void qlcnic_83xx_set_mac_filter_count(struct qlcnic_adapter *adapter)\n{\n\tstruct qlcnic_hardware_context *ahw = adapter->ahw;\n\tu16 act_pci_fn = ahw->total_nic_func;\n\tu16 count;\n\n\tahw->max_mc_count = QLC_83XX_MAX_MC_COUNT;\n\tif (act_pci_fn <= 2)\n\t\tcount = (QLC_83XX_MAX_UC_COUNT - QLC_83XX_MAX_MC_COUNT) /\n\t\t\t act_pci_fn;\n\telse\n\t\tcount = (QLC_83XX_LB_MAX_FILTERS - QLC_83XX_MAX_MC_COUNT) /\n\t\t\t act_pci_fn;\n\tahw->max_uc_count = count;\n}\n\nvoid qlcnic_83xx_enable_mbx_interrupt(struct qlcnic_adapter *adapter)\n{\n\tu32 val;\n\n\tif (adapter->flags & QLCNIC_MSIX_ENABLED)\n\t\tval = BIT_2 | ((adapter->ahw->num_msix - 1) << 8);\n\telse\n\t\tval = BIT_2;\n\n\tQLCWRX(adapter->ahw, QLCNIC_MBX_INTR_ENBL, val);\n\tqlcnic_83xx_enable_legacy_msix_mbx_intr(adapter);\n}\n\nvoid qlcnic_83xx_check_vf(struct qlcnic_adapter *adapter,\n\t\t\t  const struct pci_device_id *ent)\n{\n\tu32 op_mode, priv_level;\n\tstruct qlcnic_hardware_context *ahw = adapter->ahw;\n\n\tahw->fw_hal_version = 2;\n\tqlcnic_get_func_no(adapter);\n\n\tif (qlcnic_sriov_vf_check(adapter)) {\n\t\tqlcnic_sriov_vf_set_ops(adapter);\n\t\treturn;\n\t}\n\n\t \n\top_mode = QLCRDX(adapter->ahw, QLC_83XX_DRV_OP_MODE);\n\tif (op_mode == QLC_83XX_DEFAULT_OPMODE)\n\t\tpriv_level = QLCNIC_MGMT_FUNC;\n\telse\n\t\tpriv_level = QLC_83XX_GET_FUNC_PRIVILEGE(op_mode,\n\t\t\t\t\t\t\t ahw->pci_func);\n\n\tif (priv_level == QLCNIC_NON_PRIV_FUNC) {\n\t\tahw->op_mode = QLCNIC_NON_PRIV_FUNC;\n\t\tdev_info(&adapter->pdev->dev,\n\t\t\t \"HAL Version: %d Non Privileged function\\n\",\n\t\t\t ahw->fw_hal_version);\n\t\tadapter->nic_ops = &qlcnic_vf_ops;\n\t} else {\n\t\tif (pci_find_ext_capability(adapter->pdev,\n\t\t\t\t\t    PCI_EXT_CAP_ID_SRIOV))\n\t\t\tset_bit(__QLCNIC_SRIOV_CAPABLE, &adapter->state);\n\t\tadapter->nic_ops = &qlcnic_83xx_ops;\n\t}\n}\n\nstatic void qlcnic_83xx_handle_link_aen(struct qlcnic_adapter *adapter,\n\t\t\t\t\tu32 data[]);\nstatic void qlcnic_83xx_handle_idc_comp_aen(struct qlcnic_adapter *adapter,\n\t\t\t\t\t    u32 data[]);\n\nvoid qlcnic_dump_mbx(struct qlcnic_adapter *adapter,\n\t\t     struct qlcnic_cmd_args *cmd)\n{\n\tint i;\n\n\tif (cmd->op_type == QLC_83XX_MBX_POST_BC_OP)\n\t\treturn;\n\n\tdev_info(&adapter->pdev->dev,\n\t\t \"Host MBX regs(%d)\\n\", cmd->req.num);\n\tfor (i = 0; i < cmd->req.num; i++) {\n\t\tif (i && !(i % 8))\n\t\t\tpr_info(\"\\n\");\n\t\tpr_info(\"%08x \", cmd->req.arg[i]);\n\t}\n\tpr_info(\"\\n\");\n\tdev_info(&adapter->pdev->dev,\n\t\t \"FW MBX regs(%d)\\n\", cmd->rsp.num);\n\tfor (i = 0; i < cmd->rsp.num; i++) {\n\t\tif (i && !(i % 8))\n\t\t\tpr_info(\"\\n\");\n\t\tpr_info(\"%08x \", cmd->rsp.arg[i]);\n\t}\n\tpr_info(\"\\n\");\n}\n\nstatic void qlcnic_83xx_poll_for_mbx_completion(struct qlcnic_adapter *adapter,\n\t\t\t\t\t\tstruct qlcnic_cmd_args *cmd)\n{\n\tstruct qlcnic_hardware_context *ahw = adapter->ahw;\n\tint opcode = LSW(cmd->req.arg[0]);\n\tunsigned long max_loops;\n\n\tmax_loops = cmd->total_cmds * QLC_83XX_MBX_CMD_LOOP;\n\n\tfor (; max_loops; max_loops--) {\n\t\tif (atomic_read(&cmd->rsp_status) ==\n\t\t    QLC_83XX_MBX_RESPONSE_ARRIVED)\n\t\t\treturn;\n\n\t\tudelay(1);\n\t}\n\n\tdev_err(&adapter->pdev->dev,\n\t\t\"%s: Mailbox command timed out, cmd_op=0x%x, cmd_type=0x%x, pci_func=0x%x, op_mode=0x%x\\n\",\n\t\t__func__, opcode, cmd->type, ahw->pci_func, ahw->op_mode);\n\tflush_workqueue(ahw->mailbox->work_q);\n\treturn;\n}\n\nint qlcnic_83xx_issue_cmd(struct qlcnic_adapter *adapter,\n\t\t\t  struct qlcnic_cmd_args *cmd)\n{\n\tstruct qlcnic_mailbox *mbx = adapter->ahw->mailbox;\n\tstruct qlcnic_hardware_context *ahw = adapter->ahw;\n\tint cmd_type, err, opcode;\n\tunsigned long timeout;\n\n\tif (!mbx)\n\t\treturn -EIO;\n\n\topcode = LSW(cmd->req.arg[0]);\n\tcmd_type = cmd->type;\n\terr = mbx->ops->enqueue_cmd(adapter, cmd, &timeout);\n\tif (err) {\n\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\"%s: Mailbox not available, cmd_op=0x%x, cmd_context=0x%x, pci_func=0x%x, op_mode=0x%x\\n\",\n\t\t\t__func__, opcode, cmd->type, ahw->pci_func,\n\t\t\tahw->op_mode);\n\t\treturn err;\n\t}\n\n\tswitch (cmd_type) {\n\tcase QLC_83XX_MBX_CMD_WAIT:\n\t\tif (!wait_for_completion_timeout(&cmd->completion, timeout)) {\n\t\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\t\"%s: Mailbox command timed out, cmd_op=0x%x, cmd_type=0x%x, pci_func=0x%x, op_mode=0x%x\\n\",\n\t\t\t\t__func__, opcode, cmd_type, ahw->pci_func,\n\t\t\t\tahw->op_mode);\n\t\t\tflush_workqueue(mbx->work_q);\n\t\t}\n\t\tbreak;\n\tcase QLC_83XX_MBX_CMD_NO_WAIT:\n\t\treturn 0;\n\tcase QLC_83XX_MBX_CMD_BUSY_WAIT:\n\t\tqlcnic_83xx_poll_for_mbx_completion(adapter, cmd);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\"%s: Invalid mailbox command, cmd_op=0x%x, cmd_type=0x%x, pci_func=0x%x, op_mode=0x%x\\n\",\n\t\t\t__func__, opcode, cmd_type, ahw->pci_func,\n\t\t\tahw->op_mode);\n\t\tqlcnic_83xx_detach_mailbox_work(adapter);\n\t}\n\n\treturn cmd->rsp_opcode;\n}\n\nint qlcnic_83xx_alloc_mbx_args(struct qlcnic_cmd_args *mbx,\n\t\t\t       struct qlcnic_adapter *adapter, u32 type)\n{\n\tint i, size;\n\tu32 temp;\n\tconst struct qlcnic_mailbox_metadata *mbx_tbl;\n\n\tmemset(mbx, 0, sizeof(struct qlcnic_cmd_args));\n\tmbx_tbl = qlcnic_83xx_mbx_tbl;\n\tsize = ARRAY_SIZE(qlcnic_83xx_mbx_tbl);\n\tfor (i = 0; i < size; i++) {\n\t\tif (type == mbx_tbl[i].cmd) {\n\t\t\tmbx->op_type = QLC_83XX_FW_MBX_CMD;\n\t\t\tmbx->req.num = mbx_tbl[i].in_args;\n\t\t\tmbx->rsp.num = mbx_tbl[i].out_args;\n\t\t\tmbx->req.arg = kcalloc(mbx->req.num, sizeof(u32),\n\t\t\t\t\t       GFP_ATOMIC);\n\t\t\tif (!mbx->req.arg)\n\t\t\t\treturn -ENOMEM;\n\t\t\tmbx->rsp.arg = kcalloc(mbx->rsp.num, sizeof(u32),\n\t\t\t\t\t       GFP_ATOMIC);\n\t\t\tif (!mbx->rsp.arg) {\n\t\t\t\tkfree(mbx->req.arg);\n\t\t\t\tmbx->req.arg = NULL;\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\ttemp = adapter->ahw->fw_hal_version << 29;\n\t\t\tmbx->req.arg[0] = (type | (mbx->req.num << 16) | temp);\n\t\t\tmbx->cmd_op = type;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tdev_err(&adapter->pdev->dev, \"%s: Invalid mailbox command opcode 0x%x\\n\",\n\t\t__func__, type);\n\treturn -EINVAL;\n}\n\nvoid qlcnic_83xx_idc_aen_work(struct work_struct *work)\n{\n\tstruct qlcnic_adapter *adapter;\n\tstruct qlcnic_cmd_args cmd;\n\tint i, err = 0;\n\n\tadapter = container_of(work, struct qlcnic_adapter, idc_aen_work.work);\n\terr = qlcnic_alloc_mbx_args(&cmd, adapter, QLCNIC_CMD_IDC_ACK);\n\tif (err)\n\t\treturn;\n\n\tfor (i = 1; i < QLC_83XX_MBX_AEN_CNT; i++)\n\t\tcmd.req.arg[i] = adapter->ahw->mbox_aen[i];\n\n\terr = qlcnic_issue_cmd(adapter, &cmd);\n\tif (err)\n\t\tdev_info(&adapter->pdev->dev,\n\t\t\t \"%s: Mailbox IDC ACK failed.\\n\", __func__);\n\tqlcnic_free_mbx_args(&cmd);\n}\n\nstatic void qlcnic_83xx_handle_idc_comp_aen(struct qlcnic_adapter *adapter,\n\t\t\t\t\t    u32 data[])\n{\n\tdev_dbg(&adapter->pdev->dev, \"Completion AEN:0x%x.\\n\",\n\t\tQLCNIC_MBX_RSP(data[0]));\n\tclear_bit(QLC_83XX_IDC_COMP_AEN, &adapter->ahw->idc.status);\n\treturn;\n}\n\nstatic void __qlcnic_83xx_process_aen(struct qlcnic_adapter *adapter)\n{\n\tstruct qlcnic_hardware_context *ahw = adapter->ahw;\n\tu32 event[QLC_83XX_MBX_AEN_CNT];\n\tint i;\n\n\tfor (i = 0; i < QLC_83XX_MBX_AEN_CNT; i++)\n\t\tevent[i] = readl(QLCNIC_MBX_FW(ahw, i));\n\n\tswitch (QLCNIC_MBX_RSP(event[0])) {\n\n\tcase QLCNIC_MBX_LINK_EVENT:\n\t\tqlcnic_83xx_handle_link_aen(adapter, event);\n\t\tbreak;\n\tcase QLCNIC_MBX_COMP_EVENT:\n\t\tqlcnic_83xx_handle_idc_comp_aen(adapter, event);\n\t\tbreak;\n\tcase QLCNIC_MBX_REQUEST_EVENT:\n\t\tfor (i = 0; i < QLC_83XX_MBX_AEN_CNT; i++)\n\t\t\tadapter->ahw->mbox_aen[i] = QLCNIC_MBX_RSP(event[i]);\n\t\tqueue_delayed_work(adapter->qlcnic_wq,\n\t\t\t\t   &adapter->idc_aen_work, 0);\n\t\tbreak;\n\tcase QLCNIC_MBX_TIME_EXTEND_EVENT:\n\t\tahw->extend_lb_time = event[1] >> 8 & 0xf;\n\t\tbreak;\n\tcase QLCNIC_MBX_BC_EVENT:\n\t\tqlcnic_sriov_handle_bc_event(adapter, event[1]);\n\t\tbreak;\n\tcase QLCNIC_MBX_SFP_INSERT_EVENT:\n\t\tdev_info(&adapter->pdev->dev, \"SFP+ Insert AEN:0x%x.\\n\",\n\t\t\t QLCNIC_MBX_RSP(event[0]));\n\t\tbreak;\n\tcase QLCNIC_MBX_SFP_REMOVE_EVENT:\n\t\tdev_info(&adapter->pdev->dev, \"SFP Removed AEN:0x%x.\\n\",\n\t\t\t QLCNIC_MBX_RSP(event[0]));\n\t\tbreak;\n\tcase QLCNIC_MBX_DCBX_CONFIG_CHANGE_EVENT:\n\t\tqlcnic_dcb_aen_handler(adapter->dcb, (void *)&event[1]);\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(&adapter->pdev->dev, \"Unsupported AEN:0x%x.\\n\",\n\t\t\tQLCNIC_MBX_RSP(event[0]));\n\t\tbreak;\n\t}\n\n\tQLCWRX(ahw, QLCNIC_FW_MBX_CTRL, QLCNIC_CLR_OWNER);\n}\n\nstatic void qlcnic_83xx_process_aen(struct qlcnic_adapter *adapter)\n{\n\tu32 resp, event, rsp_status = QLC_83XX_MBX_RESPONSE_ARRIVED;\n\tstruct qlcnic_hardware_context *ahw = adapter->ahw;\n\tstruct qlcnic_mailbox *mbx = ahw->mailbox;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&mbx->aen_lock, flags);\n\tresp = QLCRDX(ahw, QLCNIC_FW_MBX_CTRL);\n\tif (resp & QLCNIC_SET_OWNER) {\n\t\tevent = readl(QLCNIC_MBX_FW(ahw, 0));\n\t\tif (event &  QLCNIC_MBX_ASYNC_EVENT) {\n\t\t\t__qlcnic_83xx_process_aen(adapter);\n\t\t} else {\n\t\t\tif (mbx->rsp_status != rsp_status)\n\t\t\t\tqlcnic_83xx_notify_mbx_response(mbx);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&mbx->aen_lock, flags);\n}\n\nstatic void qlcnic_83xx_mbx_poll_work(struct work_struct *work)\n{\n\tstruct qlcnic_adapter *adapter;\n\n\tadapter = container_of(work, struct qlcnic_adapter, mbx_poll_work.work);\n\n\tif (!test_bit(__QLCNIC_MBX_POLL_ENABLE, &adapter->state))\n\t\treturn;\n\n\tqlcnic_83xx_process_aen(adapter);\n\tqueue_delayed_work(adapter->qlcnic_wq, &adapter->mbx_poll_work,\n\t\t\t   (HZ / 10));\n}\n\nvoid qlcnic_83xx_enable_mbx_poll(struct qlcnic_adapter *adapter)\n{\n\tif (test_and_set_bit(__QLCNIC_MBX_POLL_ENABLE, &adapter->state))\n\t\treturn;\n\n\tINIT_DELAYED_WORK(&adapter->mbx_poll_work, qlcnic_83xx_mbx_poll_work);\n\tqueue_delayed_work(adapter->qlcnic_wq, &adapter->mbx_poll_work, 0);\n}\n\nvoid qlcnic_83xx_disable_mbx_poll(struct qlcnic_adapter *adapter)\n{\n\tif (!test_and_clear_bit(__QLCNIC_MBX_POLL_ENABLE, &adapter->state))\n\t\treturn;\n\tcancel_delayed_work_sync(&adapter->mbx_poll_work);\n}\n\nstatic int qlcnic_83xx_add_rings(struct qlcnic_adapter *adapter)\n{\n\tint index, i, err, sds_mbx_size;\n\tu32 *buf, intrpt_id, intr_mask;\n\tu16 context_id;\n\tu8 num_sds;\n\tstruct qlcnic_cmd_args cmd;\n\tstruct qlcnic_host_sds_ring *sds;\n\tstruct qlcnic_sds_mbx sds_mbx;\n\tstruct qlcnic_add_rings_mbx_out *mbx_out;\n\tstruct qlcnic_recv_context *recv_ctx = adapter->recv_ctx;\n\tstruct qlcnic_hardware_context *ahw = adapter->ahw;\n\n\tsds_mbx_size = sizeof(struct qlcnic_sds_mbx);\n\tcontext_id = recv_ctx->context_id;\n\tnum_sds = adapter->drv_sds_rings - QLCNIC_MAX_SDS_RINGS;\n\terr = ahw->hw_ops->alloc_mbx_args(&cmd, adapter,\n\t\t\t\t\tQLCNIC_CMD_ADD_RCV_RINGS);\n\tif (err) {\n\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\"Failed to alloc mbx args %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tcmd.req.arg[1] = 0 | (num_sds << 8) | (context_id << 16);\n\n\t \n\tindex = 2;\n\tfor (i = 8; i < adapter->drv_sds_rings; i++) {\n\t\tmemset(&sds_mbx, 0, sds_mbx_size);\n\t\tsds = &recv_ctx->sds_rings[i];\n\t\tsds->consumer = 0;\n\t\tmemset(sds->desc_head, 0, STATUS_DESC_RINGSIZE(sds));\n\t\tsds_mbx.phy_addr_low = LSD(sds->phys_addr);\n\t\tsds_mbx.phy_addr_high = MSD(sds->phys_addr);\n\t\tsds_mbx.sds_ring_size = sds->num_desc;\n\n\t\tif (adapter->flags & QLCNIC_MSIX_ENABLED)\n\t\t\tintrpt_id = ahw->intr_tbl[i].id;\n\t\telse\n\t\t\tintrpt_id = QLCRDX(ahw, QLCNIC_DEF_INT_ID);\n\n\t\tif (adapter->ahw->diag_test != QLCNIC_LOOPBACK_TEST)\n\t\t\tsds_mbx.intrpt_id = intrpt_id;\n\t\telse\n\t\t\tsds_mbx.intrpt_id = 0xffff;\n\t\tsds_mbx.intrpt_val = 0;\n\t\tbuf = &cmd.req.arg[index];\n\t\tmemcpy(buf, &sds_mbx, sds_mbx_size);\n\t\tindex += sds_mbx_size / sizeof(u32);\n\t}\n\n\t \n\terr = ahw->hw_ops->mbx_cmd(adapter, &cmd);\n\tif (err) {\n\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\"Failed to add rings %d\\n\", err);\n\t\tgoto out;\n\t}\n\n\tmbx_out = (struct qlcnic_add_rings_mbx_out *)&cmd.rsp.arg[1];\n\tindex = 0;\n\t \n\tfor (i = 8; i < adapter->drv_sds_rings; i++) {\n\t\tsds = &recv_ctx->sds_rings[i];\n\t\tsds->crb_sts_consumer = ahw->pci_base0 +\n\t\t\t\t\tmbx_out->host_csmr[index];\n\t\tif (adapter->flags & QLCNIC_MSIX_ENABLED)\n\t\t\tintr_mask = ahw->intr_tbl[i].src;\n\t\telse\n\t\t\tintr_mask = QLCRDX(ahw, QLCNIC_DEF_INT_MASK);\n\n\t\tsds->crb_intr_mask = ahw->pci_base0 + intr_mask;\n\t\tindex++;\n\t}\nout:\n\tqlcnic_free_mbx_args(&cmd);\n\treturn err;\n}\n\nvoid qlcnic_83xx_del_rx_ctx(struct qlcnic_adapter *adapter)\n{\n\tint err;\n\tu32 temp = 0;\n\tstruct qlcnic_cmd_args cmd;\n\tstruct qlcnic_recv_context *recv_ctx = adapter->recv_ctx;\n\n\tif (qlcnic_alloc_mbx_args(&cmd, adapter, QLCNIC_CMD_DESTROY_RX_CTX))\n\t\treturn;\n\n\tif (qlcnic_sriov_pf_check(adapter) || qlcnic_sriov_vf_check(adapter))\n\t\tcmd.req.arg[0] |= (0x3 << 29);\n\n\tif (qlcnic_sriov_pf_check(adapter))\n\t\tqlcnic_pf_set_interface_id_del_rx_ctx(adapter, &temp);\n\n\tcmd.req.arg[1] = recv_ctx->context_id | temp;\n\terr = qlcnic_issue_cmd(adapter, &cmd);\n\tif (err)\n\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\"Failed to destroy rx ctx in firmware\\n\");\n\n\trecv_ctx->state = QLCNIC_HOST_CTX_STATE_FREED;\n\tqlcnic_free_mbx_args(&cmd);\n}\n\nint qlcnic_83xx_create_rx_ctx(struct qlcnic_adapter *adapter)\n{\n\tint i, err, index, sds_mbx_size, rds_mbx_size;\n\tu8 num_sds, num_rds;\n\tu32 *buf, intrpt_id, intr_mask, cap = 0;\n\tstruct qlcnic_host_sds_ring *sds;\n\tstruct qlcnic_host_rds_ring *rds;\n\tstruct qlcnic_sds_mbx sds_mbx;\n\tstruct qlcnic_rds_mbx rds_mbx;\n\tstruct qlcnic_cmd_args cmd;\n\tstruct qlcnic_rcv_mbx_out *mbx_out;\n\tstruct qlcnic_recv_context *recv_ctx = adapter->recv_ctx;\n\tstruct qlcnic_hardware_context *ahw = adapter->ahw;\n\tnum_rds = adapter->max_rds_rings;\n\n\tif (adapter->drv_sds_rings <= QLCNIC_MAX_SDS_RINGS)\n\t\tnum_sds = adapter->drv_sds_rings;\n\telse\n\t\tnum_sds = QLCNIC_MAX_SDS_RINGS;\n\n\tsds_mbx_size = sizeof(struct qlcnic_sds_mbx);\n\trds_mbx_size = sizeof(struct qlcnic_rds_mbx);\n\tcap = QLCNIC_CAP0_LEGACY_CONTEXT;\n\n\tif (adapter->flags & QLCNIC_FW_LRO_MSS_CAP)\n\t\tcap |= QLC_83XX_FW_CAP_LRO_MSS;\n\n\t \n\terr = qlcnic_alloc_mbx_args(&cmd, adapter,\n\t\t\t\t    QLCNIC_CMD_CREATE_RX_CTX);\n\tif (err)\n\t\treturn err;\n\n\tif (qlcnic_sriov_pf_check(adapter) || qlcnic_sriov_vf_check(adapter))\n\t\tcmd.req.arg[0] |= (0x3 << 29);\n\n\tcmd.req.arg[1] = cap;\n\tcmd.req.arg[5] = 1 | (num_rds << 5) | (num_sds << 8) |\n\t\t\t (QLC_83XX_HOST_RDS_MODE_UNIQUE << 16);\n\n\tif (qlcnic_sriov_pf_check(adapter))\n\t\tqlcnic_pf_set_interface_id_create_rx_ctx(adapter,\n\t\t\t\t\t\t\t &cmd.req.arg[6]);\n\t \n\tindex = QLC_83XX_HOST_SDS_MBX_IDX;\n\tfor (i = 0; i < num_sds; i++) {\n\t\tmemset(&sds_mbx, 0, sds_mbx_size);\n\t\tsds = &recv_ctx->sds_rings[i];\n\t\tsds->consumer = 0;\n\t\tmemset(sds->desc_head, 0, STATUS_DESC_RINGSIZE(sds));\n\t\tsds_mbx.phy_addr_low = LSD(sds->phys_addr);\n\t\tsds_mbx.phy_addr_high = MSD(sds->phys_addr);\n\t\tsds_mbx.sds_ring_size = sds->num_desc;\n\t\tif (adapter->flags & QLCNIC_MSIX_ENABLED)\n\t\t\tintrpt_id = ahw->intr_tbl[i].id;\n\t\telse\n\t\t\tintrpt_id = QLCRDX(ahw, QLCNIC_DEF_INT_ID);\n\t\tif (adapter->ahw->diag_test != QLCNIC_LOOPBACK_TEST)\n\t\t\tsds_mbx.intrpt_id = intrpt_id;\n\t\telse\n\t\t\tsds_mbx.intrpt_id = 0xffff;\n\t\tsds_mbx.intrpt_val = 0;\n\t\tbuf = &cmd.req.arg[index];\n\t\tmemcpy(buf, &sds_mbx, sds_mbx_size);\n\t\tindex += sds_mbx_size / sizeof(u32);\n\t}\n\t \n\tindex = QLCNIC_HOST_RDS_MBX_IDX;\n\trds = &recv_ctx->rds_rings[0];\n\trds->producer = 0;\n\tmemset(&rds_mbx, 0, rds_mbx_size);\n\trds_mbx.phy_addr_reg_low = LSD(rds->phys_addr);\n\trds_mbx.phy_addr_reg_high = MSD(rds->phys_addr);\n\trds_mbx.reg_ring_sz = rds->dma_size;\n\trds_mbx.reg_ring_len = rds->num_desc;\n\t \n\trds = &recv_ctx->rds_rings[1];\n\trds->producer = 0;\n\trds_mbx.phy_addr_jmb_low = LSD(rds->phys_addr);\n\trds_mbx.phy_addr_jmb_high = MSD(rds->phys_addr);\n\trds_mbx.jmb_ring_sz = rds->dma_size;\n\trds_mbx.jmb_ring_len = rds->num_desc;\n\tbuf = &cmd.req.arg[index];\n\tmemcpy(buf, &rds_mbx, rds_mbx_size);\n\n\t \n\terr = ahw->hw_ops->mbx_cmd(adapter, &cmd);\n\tif (err) {\n\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\"Failed to create Rx ctx in firmware%d\\n\", err);\n\t\tgoto out;\n\t}\n\tmbx_out = (struct qlcnic_rcv_mbx_out *)&cmd.rsp.arg[1];\n\trecv_ctx->context_id = mbx_out->ctx_id;\n\trecv_ctx->state = mbx_out->state;\n\trecv_ctx->virt_port = mbx_out->vport_id;\n\tdev_info(&adapter->pdev->dev, \"Rx Context[%d] Created, state:0x%x\\n\",\n\t\t recv_ctx->context_id, recv_ctx->state);\n\t \n\t \n\trds = &recv_ctx->rds_rings[0];\n\trds->crb_rcv_producer = ahw->pci_base0 +\n\t\t\t\tmbx_out->host_prod[0].reg_buf;\n\t \n\trds = &recv_ctx->rds_rings[1];\n\trds->crb_rcv_producer = ahw->pci_base0 +\n\t\t\t\tmbx_out->host_prod[0].jmb_buf;\n\t \n\tfor (i = 0; i < num_sds; i++) {\n\t\tsds = &recv_ctx->sds_rings[i];\n\t\tsds->crb_sts_consumer = ahw->pci_base0 +\n\t\t\t\t\tmbx_out->host_csmr[i];\n\t\tif (adapter->flags & QLCNIC_MSIX_ENABLED)\n\t\t\tintr_mask = ahw->intr_tbl[i].src;\n\t\telse\n\t\t\tintr_mask = QLCRDX(ahw, QLCNIC_DEF_INT_MASK);\n\t\tsds->crb_intr_mask = ahw->pci_base0 + intr_mask;\n\t}\n\n\tif (adapter->drv_sds_rings > QLCNIC_MAX_SDS_RINGS)\n\t\terr = qlcnic_83xx_add_rings(adapter);\nout:\n\tqlcnic_free_mbx_args(&cmd);\n\treturn err;\n}\n\nvoid qlcnic_83xx_del_tx_ctx(struct qlcnic_adapter *adapter,\n\t\t\t    struct qlcnic_host_tx_ring *tx_ring)\n{\n\tstruct qlcnic_cmd_args cmd;\n\tu32 temp = 0;\n\n\tif (qlcnic_alloc_mbx_args(&cmd, adapter, QLCNIC_CMD_DESTROY_TX_CTX))\n\t\treturn;\n\n\tif (qlcnic_sriov_pf_check(adapter) || qlcnic_sriov_vf_check(adapter))\n\t\tcmd.req.arg[0] |= (0x3 << 29);\n\n\tif (qlcnic_sriov_pf_check(adapter))\n\t\tqlcnic_pf_set_interface_id_del_tx_ctx(adapter, &temp);\n\n\tcmd.req.arg[1] = tx_ring->ctx_id | temp;\n\tif (qlcnic_issue_cmd(adapter, &cmd))\n\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\"Failed to destroy tx ctx in firmware\\n\");\n\tqlcnic_free_mbx_args(&cmd);\n}\n\nint qlcnic_83xx_create_tx_ctx(struct qlcnic_adapter *adapter,\n\t\t\t      struct qlcnic_host_tx_ring *tx, int ring)\n{\n\tint err;\n\tu16 msix_id;\n\tu32 *buf, intr_mask, temp = 0;\n\tstruct qlcnic_cmd_args cmd;\n\tstruct qlcnic_tx_mbx mbx;\n\tstruct qlcnic_tx_mbx_out *mbx_out;\n\tstruct qlcnic_hardware_context *ahw = adapter->ahw;\n\tu32 msix_vector;\n\n\t \n\ttx->producer = 0;\n\ttx->sw_consumer = 0;\n\t*(tx->hw_consumer) = 0;\n\n\tmemset(&mbx, 0, sizeof(struct qlcnic_tx_mbx));\n\n\t \n\tmbx.phys_addr_low = LSD(tx->phys_addr);\n\tmbx.phys_addr_high = MSD(tx->phys_addr);\n\tmbx.cnsmr_index_low = LSD(tx->hw_cons_phys_addr);\n\tmbx.cnsmr_index_high = MSD(tx->hw_cons_phys_addr);\n\tmbx.size = tx->num_desc;\n\tif (adapter->flags & QLCNIC_MSIX_ENABLED) {\n\t\tif (!(adapter->flags & QLCNIC_TX_INTR_SHARED))\n\t\t\tmsix_vector = adapter->drv_sds_rings + ring;\n\t\telse\n\t\t\tmsix_vector = adapter->drv_sds_rings - 1;\n\t\tmsix_id = ahw->intr_tbl[msix_vector].id;\n\t} else {\n\t\tmsix_id = QLCRDX(ahw, QLCNIC_DEF_INT_ID);\n\t}\n\n\tif (adapter->ahw->diag_test != QLCNIC_LOOPBACK_TEST)\n\t\tmbx.intr_id = msix_id;\n\telse\n\t\tmbx.intr_id = 0xffff;\n\tmbx.src = 0;\n\n\terr = qlcnic_alloc_mbx_args(&cmd, adapter, QLCNIC_CMD_CREATE_TX_CTX);\n\tif (err)\n\t\treturn err;\n\n\tif (qlcnic_sriov_pf_check(adapter) || qlcnic_sriov_vf_check(adapter))\n\t\tcmd.req.arg[0] |= (0x3 << 29);\n\n\tif (qlcnic_sriov_pf_check(adapter))\n\t\tqlcnic_pf_set_interface_id_create_tx_ctx(adapter, &temp);\n\n\tcmd.req.arg[1] = QLCNIC_CAP0_LEGACY_CONTEXT;\n\tcmd.req.arg[5] = QLCNIC_SINGLE_RING | temp;\n\n\tbuf = &cmd.req.arg[6];\n\tmemcpy(buf, &mbx, sizeof(struct qlcnic_tx_mbx));\n\t \n\terr = qlcnic_issue_cmd(adapter, &cmd);\n\tif (err) {\n\t\tnetdev_err(adapter->netdev,\n\t\t\t   \"Failed to create Tx ctx in firmware 0x%x\\n\", err);\n\t\tgoto out;\n\t}\n\tmbx_out = (struct qlcnic_tx_mbx_out *)&cmd.rsp.arg[2];\n\ttx->crb_cmd_producer = ahw->pci_base0 + mbx_out->host_prod;\n\ttx->ctx_id = mbx_out->ctx_id;\n\tif ((adapter->flags & QLCNIC_MSIX_ENABLED) &&\n\t    !(adapter->flags & QLCNIC_TX_INTR_SHARED)) {\n\t\tintr_mask = ahw->intr_tbl[adapter->drv_sds_rings + ring].src;\n\t\ttx->crb_intr_mask = ahw->pci_base0 + intr_mask;\n\t}\n\tnetdev_info(adapter->netdev,\n\t\t    \"Tx Context[0x%x] Created, state:0x%x\\n\",\n\t\t    tx->ctx_id, mbx_out->state);\nout:\n\tqlcnic_free_mbx_args(&cmd);\n\treturn err;\n}\n\nstatic int qlcnic_83xx_diag_alloc_res(struct net_device *netdev, int test,\n\t\t\t\t      u8 num_sds_ring)\n{\n\tstruct qlcnic_adapter *adapter = netdev_priv(netdev);\n\tstruct qlcnic_host_sds_ring *sds_ring;\n\tstruct qlcnic_host_rds_ring *rds_ring;\n\tu16 adapter_state = adapter->is_up;\n\tu8 ring;\n\tint ret;\n\n\tnetif_device_detach(netdev);\n\n\tif (netif_running(netdev))\n\t\t__qlcnic_down(adapter, netdev);\n\n\tqlcnic_detach(adapter);\n\n\tadapter->drv_sds_rings = QLCNIC_SINGLE_RING;\n\tadapter->ahw->diag_test = test;\n\tadapter->ahw->linkup = 0;\n\n\tret = qlcnic_attach(adapter);\n\tif (ret) {\n\t\tnetif_device_attach(netdev);\n\t\treturn ret;\n\t}\n\n\tret = qlcnic_fw_create_ctx(adapter);\n\tif (ret) {\n\t\tqlcnic_detach(adapter);\n\t\tif (adapter_state == QLCNIC_ADAPTER_UP_MAGIC) {\n\t\t\tadapter->drv_sds_rings = num_sds_ring;\n\t\t\tqlcnic_attach(adapter);\n\t\t}\n\t\tnetif_device_attach(netdev);\n\t\treturn ret;\n\t}\n\n\tfor (ring = 0; ring < adapter->max_rds_rings; ring++) {\n\t\trds_ring = &adapter->recv_ctx->rds_rings[ring];\n\t\tqlcnic_post_rx_buffers(adapter, rds_ring, ring);\n\t}\n\n\tif (adapter->ahw->diag_test == QLCNIC_INTERRUPT_TEST) {\n\t\tfor (ring = 0; ring < adapter->drv_sds_rings; ring++) {\n\t\t\tsds_ring = &adapter->recv_ctx->sds_rings[ring];\n\t\t\tqlcnic_enable_sds_intr(adapter, sds_ring);\n\t\t}\n\t}\n\n\tif (adapter->ahw->diag_test == QLCNIC_LOOPBACK_TEST) {\n\t\tadapter->ahw->loopback_state = 0;\n\t\tadapter->ahw->hw_ops->setup_link_event(adapter, 1);\n\t}\n\n\tset_bit(__QLCNIC_DEV_UP, &adapter->state);\n\treturn 0;\n}\n\nstatic void qlcnic_83xx_diag_free_res(struct net_device *netdev,\n\t\t\t\t      u8 drv_sds_rings)\n{\n\tstruct qlcnic_adapter *adapter = netdev_priv(netdev);\n\tstruct qlcnic_host_sds_ring *sds_ring;\n\tint ring;\n\n\tclear_bit(__QLCNIC_DEV_UP, &adapter->state);\n\tif (adapter->ahw->diag_test == QLCNIC_INTERRUPT_TEST) {\n\t\tfor (ring = 0; ring < adapter->drv_sds_rings; ring++) {\n\t\t\tsds_ring = &adapter->recv_ctx->sds_rings[ring];\n\t\t\tif (adapter->flags & QLCNIC_MSIX_ENABLED)\n\t\t\t\tqlcnic_disable_sds_intr(adapter, sds_ring);\n\t\t}\n\t}\n\n\tqlcnic_fw_destroy_ctx(adapter);\n\tqlcnic_detach(adapter);\n\n\tadapter->ahw->diag_test = 0;\n\tadapter->drv_sds_rings = drv_sds_rings;\n\n\tif (qlcnic_attach(adapter))\n\t\tgoto out;\n\n\tif (netif_running(netdev))\n\t\t__qlcnic_up(adapter, netdev);\n\nout:\n\tnetif_device_attach(netdev);\n}\n\nstatic void qlcnic_83xx_get_beacon_state(struct qlcnic_adapter *adapter)\n{\n\tstruct qlcnic_hardware_context *ahw = adapter->ahw;\n\tstruct qlcnic_cmd_args cmd;\n\tu8 beacon_state;\n\tint err = 0;\n\n\terr = qlcnic_alloc_mbx_args(&cmd, adapter, QLCNIC_CMD_GET_LED_CONFIG);\n\tif (!err) {\n\t\terr = qlcnic_issue_cmd(adapter, &cmd);\n\t\tif (!err) {\n\t\t\tbeacon_state = cmd.rsp.arg[4];\n\t\t\tif (beacon_state == QLCNIC_BEACON_DISABLE)\n\t\t\t\tahw->beacon_state = QLC_83XX_BEACON_OFF;\n\t\t\telse if (beacon_state == QLC_83XX_ENABLE_BEACON)\n\t\t\t\tahw->beacon_state = QLC_83XX_BEACON_ON;\n\t\t}\n\t} else {\n\t\tnetdev_err(adapter->netdev, \"Get beacon state failed, err=%d\\n\",\n\t\t\t   err);\n\t}\n\n\tqlcnic_free_mbx_args(&cmd);\n\n\treturn;\n}\n\nint qlcnic_83xx_config_led(struct qlcnic_adapter *adapter, u32 state,\n\t\t\t   u32 beacon)\n{\n\tstruct qlcnic_cmd_args cmd;\n\tu32 mbx_in;\n\tint i, status = 0;\n\n\tif (state) {\n\t\t \n\t\tstatus = qlcnic_alloc_mbx_args(&cmd, adapter,\n\t\t\t\t\t       QLCNIC_CMD_GET_LED_CONFIG);\n\t\tif (status)\n\t\t\treturn status;\n\n\t\tstatus = qlcnic_issue_cmd(adapter, &cmd);\n\t\tif (status) {\n\t\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\t\"Get led config failed.\\n\");\n\t\t\tgoto mbx_err;\n\t\t} else {\n\t\t\tfor (i = 0; i < 4; i++)\n\t\t\t\tadapter->ahw->mbox_reg[i] = cmd.rsp.arg[i+1];\n\t\t}\n\t\tqlcnic_free_mbx_args(&cmd);\n\t\t \n\t\tmbx_in = (LSW(QLC_83XX_LED_CONFIG) << 16) |\n\t\t\t  LSW(QLC_83XX_LED_CONFIG);\n\t\tstatus = qlcnic_alloc_mbx_args(&cmd, adapter,\n\t\t\t\t\t       QLCNIC_CMD_SET_LED_CONFIG);\n\t\tif (status)\n\t\t\treturn status;\n\n\t\tcmd.req.arg[1] = mbx_in;\n\t\tcmd.req.arg[2] = mbx_in;\n\t\tcmd.req.arg[3] = mbx_in;\n\t\tif (beacon)\n\t\t\tcmd.req.arg[4] = QLC_83XX_ENABLE_BEACON;\n\t\tstatus = qlcnic_issue_cmd(adapter, &cmd);\n\t\tif (status) {\n\t\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\t\"Set led config failed.\\n\");\n\t\t}\nmbx_err:\n\t\tqlcnic_free_mbx_args(&cmd);\n\t\treturn status;\n\n\t} else {\n\t\t \n\t\tstatus = qlcnic_alloc_mbx_args(&cmd, adapter,\n\t\t\t\t\t       QLCNIC_CMD_SET_LED_CONFIG);\n\t\tif (status)\n\t\t\treturn status;\n\n\t\tcmd.req.arg[1] = adapter->ahw->mbox_reg[0];\n\t\tcmd.req.arg[2] = adapter->ahw->mbox_reg[1];\n\t\tcmd.req.arg[3] = adapter->ahw->mbox_reg[2];\n\t\tif (beacon)\n\t\t\tcmd.req.arg[4] = adapter->ahw->mbox_reg[3];\n\t\tstatus = qlcnic_issue_cmd(adapter, &cmd);\n\t\tif (status)\n\t\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\t\"Restoring led config failed.\\n\");\n\t\tqlcnic_free_mbx_args(&cmd);\n\t\treturn status;\n\t}\n}\n\nint  qlcnic_83xx_set_led(struct net_device *netdev,\n\t\t\t enum ethtool_phys_id_state state)\n{\n\tstruct qlcnic_adapter *adapter = netdev_priv(netdev);\n\tint err = -EIO, active = 1;\n\n\tif (adapter->ahw->op_mode == QLCNIC_NON_PRIV_FUNC) {\n\t\tnetdev_warn(netdev,\n\t\t\t    \"LED test is not supported in non-privileged mode\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tswitch (state) {\n\tcase ETHTOOL_ID_ACTIVE:\n\t\tif (test_and_set_bit(__QLCNIC_LED_ENABLE, &adapter->state))\n\t\t\treturn -EBUSY;\n\n\t\tif (test_bit(__QLCNIC_RESETTING, &adapter->state))\n\t\t\tbreak;\n\n\t\terr = qlcnic_83xx_config_led(adapter, active, 0);\n\t\tif (err)\n\t\t\tnetdev_err(netdev, \"Failed to set LED blink state\\n\");\n\t\tbreak;\n\tcase ETHTOOL_ID_INACTIVE:\n\t\tactive = 0;\n\n\t\tif (test_bit(__QLCNIC_RESETTING, &adapter->state))\n\t\t\tbreak;\n\n\t\terr = qlcnic_83xx_config_led(adapter, active, 0);\n\t\tif (err)\n\t\t\tnetdev_err(netdev, \"Failed to reset LED blink state\\n\");\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (!active || err)\n\t\tclear_bit(__QLCNIC_LED_ENABLE, &adapter->state);\n\n\treturn err;\n}\n\nvoid qlcnic_83xx_initialize_nic(struct qlcnic_adapter *adapter, int enable)\n{\n\tstruct qlcnic_cmd_args cmd;\n\tint status;\n\n\tif (qlcnic_sriov_vf_check(adapter))\n\t\treturn;\n\n\tif (enable)\n\t\tstatus = qlcnic_alloc_mbx_args(&cmd, adapter,\n\t\t\t\t\t       QLCNIC_CMD_INIT_NIC_FUNC);\n\telse\n\t\tstatus = qlcnic_alloc_mbx_args(&cmd, adapter,\n\t\t\t\t\t       QLCNIC_CMD_STOP_NIC_FUNC);\n\n\tif (status)\n\t\treturn;\n\n\tcmd.req.arg[1] = QLC_REGISTER_LB_IDC | QLC_INIT_FW_RESOURCES;\n\n\tif (adapter->dcb)\n\t\tcmd.req.arg[1] |= QLC_REGISTER_DCB_AEN;\n\n\tstatus = qlcnic_issue_cmd(adapter, &cmd);\n\tif (status)\n\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\"Failed to %s in NIC IDC function event.\\n\",\n\t\t\t(enable ? \"register\" : \"unregister\"));\n\n\tqlcnic_free_mbx_args(&cmd);\n}\n\nstatic int qlcnic_83xx_set_port_config(struct qlcnic_adapter *adapter)\n{\n\tstruct qlcnic_cmd_args cmd;\n\tint err;\n\n\terr = qlcnic_alloc_mbx_args(&cmd, adapter, QLCNIC_CMD_SET_PORT_CONFIG);\n\tif (err)\n\t\treturn err;\n\n\tcmd.req.arg[1] = adapter->ahw->port_config;\n\terr = qlcnic_issue_cmd(adapter, &cmd);\n\tif (err)\n\t\tdev_info(&adapter->pdev->dev, \"Set Port Config failed.\\n\");\n\tqlcnic_free_mbx_args(&cmd);\n\treturn err;\n}\n\nstatic int qlcnic_83xx_get_port_config(struct qlcnic_adapter *adapter)\n{\n\tstruct qlcnic_cmd_args cmd;\n\tint err;\n\n\terr = qlcnic_alloc_mbx_args(&cmd, adapter, QLCNIC_CMD_GET_PORT_CONFIG);\n\tif (err)\n\t\treturn err;\n\n\terr = qlcnic_issue_cmd(adapter, &cmd);\n\tif (err)\n\t\tdev_info(&adapter->pdev->dev, \"Get Port config failed\\n\");\n\telse\n\t\tadapter->ahw->port_config = cmd.rsp.arg[1];\n\tqlcnic_free_mbx_args(&cmd);\n\treturn err;\n}\n\nint qlcnic_83xx_setup_link_event(struct qlcnic_adapter *adapter, int enable)\n{\n\tint err;\n\tu32 temp;\n\tstruct qlcnic_cmd_args cmd;\n\n\terr = qlcnic_alloc_mbx_args(&cmd, adapter, QLCNIC_CMD_GET_LINK_EVENT);\n\tif (err)\n\t\treturn err;\n\n\ttemp = adapter->recv_ctx->context_id << 16;\n\tcmd.req.arg[1] = (enable ? 1 : 0) | BIT_8 | temp;\n\terr = qlcnic_issue_cmd(adapter, &cmd);\n\tif (err)\n\t\tdev_info(&adapter->pdev->dev,\n\t\t\t \"Setup linkevent mailbox failed\\n\");\n\tqlcnic_free_mbx_args(&cmd);\n\treturn err;\n}\n\nstatic void qlcnic_83xx_set_interface_id_promisc(struct qlcnic_adapter *adapter,\n\t\t\t\t\t\t u32 *interface_id)\n{\n\tif (qlcnic_sriov_pf_check(adapter)) {\n\t\tqlcnic_alloc_lb_filters_mem(adapter);\n\t\tqlcnic_pf_set_interface_id_promisc(adapter, interface_id);\n\t\tadapter->rx_mac_learn = true;\n\t} else {\n\t\tif (!qlcnic_sriov_vf_check(adapter))\n\t\t\t*interface_id = adapter->recv_ctx->context_id << 16;\n\t}\n}\n\nint qlcnic_83xx_nic_set_promisc(struct qlcnic_adapter *adapter, u32 mode)\n{\n\tstruct qlcnic_cmd_args *cmd = NULL;\n\tu32 temp = 0;\n\tint err;\n\n\tif (adapter->recv_ctx->state == QLCNIC_HOST_CTX_STATE_FREED)\n\t\treturn -EIO;\n\n\tcmd = kzalloc(sizeof(*cmd), GFP_ATOMIC);\n\tif (!cmd)\n\t\treturn -ENOMEM;\n\n\terr = qlcnic_alloc_mbx_args(cmd, adapter,\n\t\t\t\t    QLCNIC_CMD_CONFIGURE_MAC_RX_MODE);\n\tif (err)\n\t\tgoto out;\n\n\tcmd->type = QLC_83XX_MBX_CMD_NO_WAIT;\n\tqlcnic_83xx_set_interface_id_promisc(adapter, &temp);\n\n\tif (qlcnic_84xx_check(adapter) && qlcnic_sriov_pf_check(adapter))\n\t\tmode = VPORT_MISS_MODE_ACCEPT_ALL;\n\n\tcmd->req.arg[1] = mode | temp;\n\terr = qlcnic_issue_cmd(adapter, cmd);\n\tif (!err)\n\t\treturn err;\n\n\tqlcnic_free_mbx_args(cmd);\n\nout:\n\tkfree(cmd);\n\treturn err;\n}\n\nint qlcnic_83xx_loopback_test(struct net_device *netdev, u8 mode)\n{\n\tstruct qlcnic_adapter *adapter = netdev_priv(netdev);\n\tstruct qlcnic_hardware_context *ahw = adapter->ahw;\n\tu8 drv_sds_rings = adapter->drv_sds_rings;\n\tu8 drv_tx_rings = adapter->drv_tx_rings;\n\tint ret = 0, loop = 0;\n\n\tif (ahw->op_mode == QLCNIC_NON_PRIV_FUNC) {\n\t\tnetdev_warn(netdev,\n\t\t\t    \"Loopback test not supported in non privileged mode\\n\");\n\t\treturn -ENOTSUPP;\n\t}\n\n\tif (test_bit(__QLCNIC_RESETTING, &adapter->state)) {\n\t\tnetdev_info(netdev, \"Device is resetting\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tif (qlcnic_get_diag_lock(adapter)) {\n\t\tnetdev_info(netdev, \"Device is in diagnostics mode\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tnetdev_info(netdev, \"%s loopback test in progress\\n\",\n\t\t    mode == QLCNIC_ILB_MODE ? \"internal\" : \"external\");\n\n\tret = qlcnic_83xx_diag_alloc_res(netdev, QLCNIC_LOOPBACK_TEST,\n\t\t\t\t\t drv_sds_rings);\n\tif (ret)\n\t\tgoto fail_diag_alloc;\n\n\tret = qlcnic_83xx_set_lb_mode(adapter, mode);\n\tif (ret)\n\t\tgoto free_diag_res;\n\n\t \n\tdo {\n\t\tmsleep(QLC_83XX_LB_MSLEEP_COUNT);\n\n\t\tif (test_bit(__QLCNIC_RESETTING, &adapter->state)) {\n\t\t\tnetdev_info(netdev,\n\t\t\t\t    \"Device is resetting, free LB test resources\\n\");\n\t\t\tret = -EBUSY;\n\t\t\tgoto free_diag_res;\n\t\t}\n\t\tif (loop++ > QLC_83XX_LB_WAIT_COUNT) {\n\t\t\tnetdev_info(netdev,\n\t\t\t\t    \"Firmware didn't sent link up event to loopback request\\n\");\n\t\t\tret = -ETIMEDOUT;\n\t\t\tqlcnic_83xx_clear_lb_mode(adapter, mode);\n\t\t\tgoto free_diag_res;\n\t\t}\n\t} while ((adapter->ahw->linkup && ahw->has_link_events) != 1);\n\n\tret = qlcnic_do_lb_test(adapter, mode);\n\n\tqlcnic_83xx_clear_lb_mode(adapter, mode);\n\nfree_diag_res:\n\tqlcnic_83xx_diag_free_res(netdev, drv_sds_rings);\n\nfail_diag_alloc:\n\tadapter->drv_sds_rings = drv_sds_rings;\n\tadapter->drv_tx_rings = drv_tx_rings;\n\tqlcnic_release_diag_lock(adapter);\n\treturn ret;\n}\n\nstatic void qlcnic_extend_lb_idc_cmpltn_wait(struct qlcnic_adapter *adapter,\n\t\t\t\t\t     u32 *max_wait_count)\n{\n\tstruct qlcnic_hardware_context *ahw = adapter->ahw;\n\tint temp;\n\n\tnetdev_info(adapter->netdev, \"Received loopback IDC time extend event for 0x%x seconds\\n\",\n\t\t    ahw->extend_lb_time);\n\ttemp = ahw->extend_lb_time * 1000;\n\t*max_wait_count += temp / QLC_83XX_LB_MSLEEP_COUNT;\n\tahw->extend_lb_time = 0;\n}\n\nstatic int qlcnic_83xx_set_lb_mode(struct qlcnic_adapter *adapter, u8 mode)\n{\n\tstruct qlcnic_hardware_context *ahw = adapter->ahw;\n\tstruct net_device *netdev = adapter->netdev;\n\tu32 config, max_wait_count;\n\tint status = 0, loop = 0;\n\n\tahw->extend_lb_time = 0;\n\tmax_wait_count = QLC_83XX_LB_WAIT_COUNT;\n\tstatus = qlcnic_83xx_get_port_config(adapter);\n\tif (status)\n\t\treturn status;\n\n\tconfig = ahw->port_config;\n\n\t \n\tif ((config & QLC_83XX_CFG_LOOPBACK_HSS) ||\n\t    (config & QLC_83XX_CFG_LOOPBACK_EXT)) {\n\t\tnetdev_err(netdev,\n\t\t\t   \"Port already in Loopback mode.\\n\");\n\t\treturn -EINPROGRESS;\n\t}\n\n\tset_bit(QLC_83XX_IDC_COMP_AEN, &ahw->idc.status);\n\n\tif (mode == QLCNIC_ILB_MODE)\n\t\tahw->port_config |= QLC_83XX_CFG_LOOPBACK_HSS;\n\tif (mode == QLCNIC_ELB_MODE)\n\t\tahw->port_config |= QLC_83XX_CFG_LOOPBACK_EXT;\n\n\tstatus = qlcnic_83xx_set_port_config(adapter);\n\tif (status) {\n\t\tnetdev_err(netdev,\n\t\t\t   \"Failed to Set Loopback Mode = 0x%x.\\n\",\n\t\t\t   ahw->port_config);\n\t\tahw->port_config = config;\n\t\tclear_bit(QLC_83XX_IDC_COMP_AEN, &ahw->idc.status);\n\t\treturn status;\n\t}\n\n\t \n\tdo {\n\t\tmsleep(QLC_83XX_LB_MSLEEP_COUNT);\n\n\t\tif (test_bit(__QLCNIC_RESETTING, &adapter->state)) {\n\t\t\tnetdev_info(netdev,\n\t\t\t\t    \"Device is resetting, free LB test resources\\n\");\n\t\t\tclear_bit(QLC_83XX_IDC_COMP_AEN, &ahw->idc.status);\n\t\t\treturn -EBUSY;\n\t\t}\n\n\t\tif (ahw->extend_lb_time)\n\t\t\tqlcnic_extend_lb_idc_cmpltn_wait(adapter,\n\t\t\t\t\t\t\t &max_wait_count);\n\n\t\tif (loop++ > max_wait_count) {\n\t\t\tnetdev_err(netdev, \"%s: Did not receive loopback IDC completion AEN\\n\",\n\t\t\t\t   __func__);\n\t\t\tclear_bit(QLC_83XX_IDC_COMP_AEN, &ahw->idc.status);\n\t\t\tqlcnic_83xx_clear_lb_mode(adapter, mode);\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t} while (test_bit(QLC_83XX_IDC_COMP_AEN, &ahw->idc.status));\n\n\tqlcnic_sre_macaddr_change(adapter, adapter->mac_addr, 0,\n\t\t\t\t  QLCNIC_MAC_ADD);\n\treturn status;\n}\n\nstatic int qlcnic_83xx_clear_lb_mode(struct qlcnic_adapter *adapter, u8 mode)\n{\n\tstruct qlcnic_hardware_context *ahw = adapter->ahw;\n\tu32 config = ahw->port_config, max_wait_count;\n\tstruct net_device *netdev = adapter->netdev;\n\tint status = 0, loop = 0;\n\n\tahw->extend_lb_time = 0;\n\tmax_wait_count = QLC_83XX_LB_WAIT_COUNT;\n\tset_bit(QLC_83XX_IDC_COMP_AEN, &ahw->idc.status);\n\tif (mode == QLCNIC_ILB_MODE)\n\t\tahw->port_config &= ~QLC_83XX_CFG_LOOPBACK_HSS;\n\tif (mode == QLCNIC_ELB_MODE)\n\t\tahw->port_config &= ~QLC_83XX_CFG_LOOPBACK_EXT;\n\n\tstatus = qlcnic_83xx_set_port_config(adapter);\n\tif (status) {\n\t\tnetdev_err(netdev,\n\t\t\t   \"Failed to Clear Loopback Mode = 0x%x.\\n\",\n\t\t\t   ahw->port_config);\n\t\tahw->port_config = config;\n\t\tclear_bit(QLC_83XX_IDC_COMP_AEN, &ahw->idc.status);\n\t\treturn status;\n\t}\n\n\t \n\tdo {\n\t\tmsleep(QLC_83XX_LB_MSLEEP_COUNT);\n\n\t\tif (test_bit(__QLCNIC_RESETTING, &adapter->state)) {\n\t\t\tnetdev_info(netdev,\n\t\t\t\t    \"Device is resetting, free LB test resources\\n\");\n\t\t\tclear_bit(QLC_83XX_IDC_COMP_AEN, &ahw->idc.status);\n\t\t\treturn -EBUSY;\n\t\t}\n\n\t\tif (ahw->extend_lb_time)\n\t\t\tqlcnic_extend_lb_idc_cmpltn_wait(adapter,\n\t\t\t\t\t\t\t &max_wait_count);\n\n\t\tif (loop++ > max_wait_count) {\n\t\t\tnetdev_err(netdev, \"%s: Did not receive loopback IDC completion AEN\\n\",\n\t\t\t\t   __func__);\n\t\t\tclear_bit(QLC_83XX_IDC_COMP_AEN, &ahw->idc.status);\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t} while (test_bit(QLC_83XX_IDC_COMP_AEN, &ahw->idc.status));\n\n\tqlcnic_sre_macaddr_change(adapter, adapter->mac_addr, 0,\n\t\t\t\t  QLCNIC_MAC_DEL);\n\treturn status;\n}\n\nstatic void qlcnic_83xx_set_interface_id_ipaddr(struct qlcnic_adapter *adapter,\n\t\t\t\t\t\tu32 *interface_id)\n{\n\tif (qlcnic_sriov_pf_check(adapter)) {\n\t\tqlcnic_pf_set_interface_id_ipaddr(adapter, interface_id);\n\t} else {\n\t\tif (!qlcnic_sriov_vf_check(adapter))\n\t\t\t*interface_id = adapter->recv_ctx->context_id << 16;\n\t}\n}\n\nvoid qlcnic_83xx_config_ipaddr(struct qlcnic_adapter *adapter, __be32 ip,\n\t\t\t       int mode)\n{\n\tint err;\n\tu32 temp = 0, temp_ip;\n\tstruct qlcnic_cmd_args cmd;\n\n\terr = qlcnic_alloc_mbx_args(&cmd, adapter,\n\t\t\t\t    QLCNIC_CMD_CONFIGURE_IP_ADDR);\n\tif (err)\n\t\treturn;\n\n\tqlcnic_83xx_set_interface_id_ipaddr(adapter, &temp);\n\n\tif (mode == QLCNIC_IP_UP)\n\t\tcmd.req.arg[1] = 1 | temp;\n\telse\n\t\tcmd.req.arg[1] = 2 | temp;\n\n\t \n\n\ttemp_ip = swab32(ntohl(ip));\n\tmemcpy(&cmd.req.arg[2], &temp_ip, sizeof(u32));\n\terr = qlcnic_issue_cmd(adapter, &cmd);\n\tif (err != QLCNIC_RCODE_SUCCESS)\n\t\tdev_err(&adapter->netdev->dev,\n\t\t\t\"could not notify %s IP 0x%x request\\n\",\n\t\t\t(mode == QLCNIC_IP_UP) ? \"Add\" : \"Remove\", ip);\n\n\tqlcnic_free_mbx_args(&cmd);\n}\n\nint qlcnic_83xx_config_hw_lro(struct qlcnic_adapter *adapter, int mode)\n{\n\tint err;\n\tu32 temp, arg1;\n\tstruct qlcnic_cmd_args cmd;\n\tint lro_bit_mask;\n\n\tlro_bit_mask = (mode ? (BIT_0 | BIT_1 | BIT_2 | BIT_3) : 0);\n\n\tif (adapter->recv_ctx->state == QLCNIC_HOST_CTX_STATE_FREED)\n\t\treturn 0;\n\n\terr = qlcnic_alloc_mbx_args(&cmd, adapter, QLCNIC_CMD_CONFIGURE_HW_LRO);\n\tif (err)\n\t\treturn err;\n\n\ttemp = adapter->recv_ctx->context_id << 16;\n\targ1 = lro_bit_mask | temp;\n\tcmd.req.arg[1] = arg1;\n\n\terr = qlcnic_issue_cmd(adapter, &cmd);\n\tif (err)\n\t\tdev_info(&adapter->pdev->dev, \"LRO config failed\\n\");\n\tqlcnic_free_mbx_args(&cmd);\n\n\treturn err;\n}\n\nint qlcnic_83xx_config_rss(struct qlcnic_adapter *adapter, int enable)\n{\n\tint err;\n\tu32 word;\n\tstruct qlcnic_cmd_args cmd;\n\tconst u64 key[] = { 0xbeac01fa6a42b73bULL, 0x8030f20c77cb2da3ULL,\n\t\t\t    0xae7b30b4d0ca2bcbULL, 0x43a38fb04167253dULL,\n\t\t\t    0x255b0ec26d5a56daULL };\n\n\terr = qlcnic_alloc_mbx_args(&cmd, adapter, QLCNIC_CMD_CONFIGURE_RSS);\n\tif (err)\n\t\treturn err;\n\t \n\tword =  ((u32)(RSS_HASHTYPE_IP_TCP & 0x3) << 4) |\n\t\t((u32)(RSS_HASHTYPE_IP_TCP & 0x3) << 6) |\n\t\t((u32)(enable & 0x1) << 8) |\n\t\t((0x7ULL) << 16);\n\tcmd.req.arg[1] = (adapter->recv_ctx->context_id);\n\tcmd.req.arg[2] = word;\n\tmemcpy(&cmd.req.arg[4], key, sizeof(key));\n\n\terr = qlcnic_issue_cmd(adapter, &cmd);\n\n\tif (err)\n\t\tdev_info(&adapter->pdev->dev, \"RSS config failed\\n\");\n\tqlcnic_free_mbx_args(&cmd);\n\n\treturn err;\n\n}\n\nstatic void qlcnic_83xx_set_interface_id_macaddr(struct qlcnic_adapter *adapter,\n\t\t\t\t\t\t u32 *interface_id)\n{\n\tif (qlcnic_sriov_pf_check(adapter)) {\n\t\tqlcnic_pf_set_interface_id_macaddr(adapter, interface_id);\n\t} else {\n\t\tif (!qlcnic_sriov_vf_check(adapter))\n\t\t\t*interface_id = adapter->recv_ctx->context_id << 16;\n\t}\n}\n\nint qlcnic_83xx_sre_macaddr_change(struct qlcnic_adapter *adapter, u8 *addr,\n\t\t\t\t   u16 vlan_id, u8 op)\n{\n\tstruct qlcnic_cmd_args *cmd = NULL;\n\tstruct qlcnic_macvlan_mbx mv;\n\tu32 *buf, temp = 0;\n\tint err;\n\n\tif (adapter->recv_ctx->state == QLCNIC_HOST_CTX_STATE_FREED)\n\t\treturn -EIO;\n\n\tcmd = kzalloc(sizeof(*cmd), GFP_ATOMIC);\n\tif (!cmd)\n\t\treturn -ENOMEM;\n\n\terr = qlcnic_alloc_mbx_args(cmd, adapter, QLCNIC_CMD_CONFIG_MAC_VLAN);\n\tif (err)\n\t\tgoto out;\n\n\tcmd->type = QLC_83XX_MBX_CMD_NO_WAIT;\n\n\tif (vlan_id)\n\t\top = (op == QLCNIC_MAC_ADD || op == QLCNIC_MAC_VLAN_ADD) ?\n\t\t     QLCNIC_MAC_VLAN_ADD : QLCNIC_MAC_VLAN_DEL;\n\n\tcmd->req.arg[1] = op | (1 << 8);\n\tqlcnic_83xx_set_interface_id_macaddr(adapter, &temp);\n\tcmd->req.arg[1] |= temp;\n\tmv.vlan = vlan_id;\n\tmv.mac_addr0 = addr[0];\n\tmv.mac_addr1 = addr[1];\n\tmv.mac_addr2 = addr[2];\n\tmv.mac_addr3 = addr[3];\n\tmv.mac_addr4 = addr[4];\n\tmv.mac_addr5 = addr[5];\n\tbuf = &cmd->req.arg[2];\n\tmemcpy(buf, &mv, sizeof(struct qlcnic_macvlan_mbx));\n\terr = qlcnic_issue_cmd(adapter, cmd);\n\tif (!err)\n\t\treturn err;\n\n\tqlcnic_free_mbx_args(cmd);\nout:\n\tkfree(cmd);\n\treturn err;\n}\n\nvoid qlcnic_83xx_change_l2_filter(struct qlcnic_adapter *adapter, u64 *addr,\n\t\t\t\t  u16 vlan_id,\n\t\t\t\t  struct qlcnic_host_tx_ring *tx_ring)\n{\n\tu8 mac[ETH_ALEN];\n\tmemcpy(&mac, addr, ETH_ALEN);\n\tqlcnic_83xx_sre_macaddr_change(adapter, mac, vlan_id, QLCNIC_MAC_ADD);\n}\n\nstatic void qlcnic_83xx_configure_mac(struct qlcnic_adapter *adapter, u8 *mac,\n\t\t\t\t      u8 type, struct qlcnic_cmd_args *cmd)\n{\n\tswitch (type) {\n\tcase QLCNIC_SET_STATION_MAC:\n\tcase QLCNIC_SET_FAC_DEF_MAC:\n\t\tmemcpy(&cmd->req.arg[2], mac, sizeof(u32));\n\t\tmemcpy(&cmd->req.arg[3], &mac[4], sizeof(u16));\n\t\tbreak;\n\t}\n\tcmd->req.arg[1] = type;\n}\n\nint qlcnic_83xx_get_mac_address(struct qlcnic_adapter *adapter, u8 *mac,\n\t\t\t\tu8 function)\n{\n\tint err, i;\n\tstruct qlcnic_cmd_args cmd;\n\tu32 mac_low, mac_high;\n\n\terr = qlcnic_alloc_mbx_args(&cmd, adapter, QLCNIC_CMD_MAC_ADDRESS);\n\tif (err)\n\t\treturn err;\n\n\tqlcnic_83xx_configure_mac(adapter, mac, QLCNIC_GET_CURRENT_MAC, &cmd);\n\terr = qlcnic_issue_cmd(adapter, &cmd);\n\n\tif (err == QLCNIC_RCODE_SUCCESS) {\n\t\tmac_low = cmd.rsp.arg[1];\n\t\tmac_high = cmd.rsp.arg[2];\n\n\t\tfor (i = 0; i < 2; i++)\n\t\t\tmac[i] = (u8) (mac_high >> ((1 - i) * 8));\n\t\tfor (i = 2; i < 6; i++)\n\t\t\tmac[i] = (u8) (mac_low >> ((5 - i) * 8));\n\t} else {\n\t\tdev_err(&adapter->pdev->dev, \"Failed to get mac address%d\\n\",\n\t\t\terr);\n\t\terr = -EIO;\n\t}\n\tqlcnic_free_mbx_args(&cmd);\n\treturn err;\n}\n\nstatic int qlcnic_83xx_set_rx_intr_coal(struct qlcnic_adapter *adapter)\n{\n\tstruct qlcnic_nic_intr_coalesce *coal = &adapter->ahw->coal;\n\tstruct qlcnic_cmd_args cmd;\n\tu16 temp;\n\tint err;\n\n\terr = qlcnic_alloc_mbx_args(&cmd, adapter, QLCNIC_CMD_CONFIG_INTR_COAL);\n\tif (err)\n\t\treturn err;\n\n\ttemp = adapter->recv_ctx->context_id;\n\tcmd.req.arg[1] = QLCNIC_INTR_COAL_TYPE_RX | temp << 16;\n\ttemp = coal->rx_time_us;\n\tcmd.req.arg[2] = coal->rx_packets | temp << 16;\n\tcmd.req.arg[3] = coal->flag;\n\n\terr = qlcnic_issue_cmd(adapter, &cmd);\n\tif (err != QLCNIC_RCODE_SUCCESS)\n\t\tnetdev_err(adapter->netdev,\n\t\t\t   \"failed to set interrupt coalescing parameters\\n\");\n\n\tqlcnic_free_mbx_args(&cmd);\n\n\treturn err;\n}\n\nstatic int qlcnic_83xx_set_tx_intr_coal(struct qlcnic_adapter *adapter)\n{\n\tstruct qlcnic_nic_intr_coalesce *coal = &adapter->ahw->coal;\n\tstruct qlcnic_cmd_args cmd;\n\tu16 temp;\n\tint err;\n\n\terr = qlcnic_alloc_mbx_args(&cmd, adapter, QLCNIC_CMD_CONFIG_INTR_COAL);\n\tif (err)\n\t\treturn err;\n\n\ttemp = adapter->tx_ring->ctx_id;\n\tcmd.req.arg[1] = QLCNIC_INTR_COAL_TYPE_TX | temp << 16;\n\ttemp = coal->tx_time_us;\n\tcmd.req.arg[2] = coal->tx_packets | temp << 16;\n\tcmd.req.arg[3] = coal->flag;\n\n\terr = qlcnic_issue_cmd(adapter, &cmd);\n\tif (err != QLCNIC_RCODE_SUCCESS)\n\t\tnetdev_err(adapter->netdev,\n\t\t\t   \"failed to set interrupt coalescing  parameters\\n\");\n\n\tqlcnic_free_mbx_args(&cmd);\n\n\treturn err;\n}\n\nint qlcnic_83xx_set_rx_tx_intr_coal(struct qlcnic_adapter *adapter)\n{\n\tint err = 0;\n\n\terr = qlcnic_83xx_set_rx_intr_coal(adapter);\n\tif (err)\n\t\tnetdev_err(adapter->netdev,\n\t\t\t   \"failed to set Rx coalescing parameters\\n\");\n\n\terr = qlcnic_83xx_set_tx_intr_coal(adapter);\n\tif (err)\n\t\tnetdev_err(adapter->netdev,\n\t\t\t   \"failed to set Tx coalescing parameters\\n\");\n\n\treturn err;\n}\n\nint qlcnic_83xx_config_intr_coal(struct qlcnic_adapter *adapter,\n\t\t\t\t struct ethtool_coalesce *ethcoal)\n{\n\tstruct qlcnic_nic_intr_coalesce *coal = &adapter->ahw->coal;\n\tu32 rx_coalesce_usecs, rx_max_frames;\n\tu32 tx_coalesce_usecs, tx_max_frames;\n\tint err;\n\n\tif (adapter->recv_ctx->state == QLCNIC_HOST_CTX_STATE_FREED)\n\t\treturn -EIO;\n\n\ttx_coalesce_usecs = ethcoal->tx_coalesce_usecs;\n\ttx_max_frames = ethcoal->tx_max_coalesced_frames;\n\trx_coalesce_usecs = ethcoal->rx_coalesce_usecs;\n\trx_max_frames = ethcoal->rx_max_coalesced_frames;\n\tcoal->flag = QLCNIC_INTR_DEFAULT;\n\n\tif ((coal->rx_time_us == rx_coalesce_usecs) &&\n\t    (coal->rx_packets == rx_max_frames)) {\n\t\tcoal->type = QLCNIC_INTR_COAL_TYPE_TX;\n\t\tcoal->tx_time_us = tx_coalesce_usecs;\n\t\tcoal->tx_packets = tx_max_frames;\n\t} else if ((coal->tx_time_us == tx_coalesce_usecs) &&\n\t\t   (coal->tx_packets == tx_max_frames)) {\n\t\tcoal->type = QLCNIC_INTR_COAL_TYPE_RX;\n\t\tcoal->rx_time_us = rx_coalesce_usecs;\n\t\tcoal->rx_packets = rx_max_frames;\n\t} else {\n\t\tcoal->type = QLCNIC_INTR_COAL_TYPE_RX_TX;\n\t\tcoal->rx_time_us = rx_coalesce_usecs;\n\t\tcoal->rx_packets = rx_max_frames;\n\t\tcoal->tx_time_us = tx_coalesce_usecs;\n\t\tcoal->tx_packets = tx_max_frames;\n\t}\n\n\tswitch (coal->type) {\n\tcase QLCNIC_INTR_COAL_TYPE_RX:\n\t\terr = qlcnic_83xx_set_rx_intr_coal(adapter);\n\t\tbreak;\n\tcase QLCNIC_INTR_COAL_TYPE_TX:\n\t\terr = qlcnic_83xx_set_tx_intr_coal(adapter);\n\t\tbreak;\n\tcase QLCNIC_INTR_COAL_TYPE_RX_TX:\n\t\terr = qlcnic_83xx_set_rx_tx_intr_coal(adapter);\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t\tnetdev_err(adapter->netdev,\n\t\t\t   \"Invalid Interrupt coalescing type\\n\");\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nstatic void qlcnic_83xx_handle_link_aen(struct qlcnic_adapter *adapter,\n\t\t\t\t\tu32 data[])\n{\n\tstruct qlcnic_hardware_context *ahw = adapter->ahw;\n\tu8 link_status, duplex;\n\t \n\tlink_status = LSB(data[3]) & 1;\n\tif (link_status) {\n\t\tahw->link_speed = MSW(data[2]);\n\t\tduplex = LSB(MSW(data[3]));\n\t\tif (duplex)\n\t\t\tahw->link_duplex = DUPLEX_FULL;\n\t\telse\n\t\t\tahw->link_duplex = DUPLEX_HALF;\n\t} else {\n\t\tahw->link_speed = SPEED_UNKNOWN;\n\t\tahw->link_duplex = DUPLEX_UNKNOWN;\n\t}\n\n\tahw->link_autoneg = MSB(MSW(data[3]));\n\tahw->module_type = MSB(LSW(data[3]));\n\tahw->has_link_events = 1;\n\tahw->lb_mode = data[4] & QLCNIC_LB_MODE_MASK;\n\tqlcnic_advert_link_change(adapter, link_status);\n}\n\nstatic irqreturn_t qlcnic_83xx_handle_aen(int irq, void *data)\n{\n\tu32 mask, resp, event, rsp_status = QLC_83XX_MBX_RESPONSE_ARRIVED;\n\tstruct qlcnic_adapter *adapter = data;\n\tstruct qlcnic_mailbox *mbx;\n\tunsigned long flags;\n\n\tmbx = adapter->ahw->mailbox;\n\tspin_lock_irqsave(&mbx->aen_lock, flags);\n\tresp = QLCRDX(adapter->ahw, QLCNIC_FW_MBX_CTRL);\n\tif (!(resp & QLCNIC_SET_OWNER))\n\t\tgoto out;\n\n\tevent = readl(QLCNIC_MBX_FW(adapter->ahw, 0));\n\tif (event &  QLCNIC_MBX_ASYNC_EVENT) {\n\t\t__qlcnic_83xx_process_aen(adapter);\n\t} else {\n\t\tif (mbx->rsp_status != rsp_status)\n\t\t\tqlcnic_83xx_notify_mbx_response(mbx);\n\t\telse\n\t\t\tadapter->stats.mbx_spurious_intr++;\n\t}\n\nout:\n\tmask = QLCRDX(adapter->ahw, QLCNIC_DEF_INT_MASK);\n\twritel(0, adapter->ahw->pci_base0 + mask);\n\tspin_unlock_irqrestore(&mbx->aen_lock, flags);\n\treturn IRQ_HANDLED;\n}\n\nint qlcnic_83xx_set_nic_info(struct qlcnic_adapter *adapter,\n\t\t\t     struct qlcnic_info *nic)\n{\n\tint i, err = -EIO;\n\tstruct qlcnic_cmd_args cmd;\n\n\tif (adapter->ahw->op_mode != QLCNIC_MGMT_FUNC) {\n\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\"%s: Error, invoked by non management func\\n\",\n\t\t\t__func__);\n\t\treturn err;\n\t}\n\n\terr = qlcnic_alloc_mbx_args(&cmd, adapter, QLCNIC_CMD_SET_NIC_INFO);\n\tif (err)\n\t\treturn err;\n\n\tcmd.req.arg[1] = (nic->pci_func << 16);\n\tcmd.req.arg[2] = 0x1 << 16;\n\tcmd.req.arg[3] = nic->phys_port | (nic->switch_mode << 16);\n\tcmd.req.arg[4] = nic->capabilities;\n\tcmd.req.arg[5] = (nic->max_mac_filters & 0xFF) | ((nic->max_mtu) << 16);\n\tcmd.req.arg[6] = (nic->max_tx_ques) | ((nic->max_rx_ques) << 16);\n\tcmd.req.arg[7] = (nic->min_tx_bw) | ((nic->max_tx_bw) << 16);\n\tfor (i = 8; i < 32; i++)\n\t\tcmd.req.arg[i] = 0;\n\n\terr = qlcnic_issue_cmd(adapter, &cmd);\n\n\tif (err != QLCNIC_RCODE_SUCCESS) {\n\t\tdev_err(&adapter->pdev->dev, \"Failed to set nic info%d\\n\",\n\t\t\terr);\n\t\terr = -EIO;\n\t}\n\n\tqlcnic_free_mbx_args(&cmd);\n\n\treturn err;\n}\n\nint qlcnic_83xx_get_nic_info(struct qlcnic_adapter *adapter,\n\t\t\t     struct qlcnic_info *npar_info, u8 func_id)\n{\n\tint err;\n\tu32 temp;\n\tu8 op = 0;\n\tstruct qlcnic_cmd_args cmd;\n\tstruct qlcnic_hardware_context *ahw = adapter->ahw;\n\n\terr = qlcnic_alloc_mbx_args(&cmd, adapter, QLCNIC_CMD_GET_NIC_INFO);\n\tif (err)\n\t\treturn err;\n\n\tif (func_id != ahw->pci_func) {\n\t\ttemp = func_id << 16;\n\t\tcmd.req.arg[1] = op | BIT_31 | temp;\n\t} else {\n\t\tcmd.req.arg[1] = ahw->pci_func << 16;\n\t}\n\terr = qlcnic_issue_cmd(adapter, &cmd);\n\tif (err) {\n\t\tdev_info(&adapter->pdev->dev,\n\t\t\t \"Failed to get nic info %d\\n\", err);\n\t\tgoto out;\n\t}\n\n\tnpar_info->op_type = cmd.rsp.arg[1];\n\tnpar_info->pci_func = cmd.rsp.arg[2] & 0xFFFF;\n\tnpar_info->op_mode = (cmd.rsp.arg[2] & 0xFFFF0000) >> 16;\n\tnpar_info->phys_port = cmd.rsp.arg[3] & 0xFFFF;\n\tnpar_info->switch_mode = (cmd.rsp.arg[3] & 0xFFFF0000) >> 16;\n\tnpar_info->capabilities = cmd.rsp.arg[4];\n\tnpar_info->max_mac_filters = cmd.rsp.arg[5] & 0xFF;\n\tnpar_info->max_mtu = (cmd.rsp.arg[5] & 0xFFFF0000) >> 16;\n\tnpar_info->max_tx_ques = cmd.rsp.arg[6] & 0xFFFF;\n\tnpar_info->max_rx_ques = (cmd.rsp.arg[6] & 0xFFFF0000) >> 16;\n\tnpar_info->min_tx_bw = cmd.rsp.arg[7] & 0xFFFF;\n\tnpar_info->max_tx_bw = (cmd.rsp.arg[7] & 0xFFFF0000) >> 16;\n\tif (cmd.rsp.arg[8] & 0x1)\n\t\tnpar_info->max_bw_reg_offset = (cmd.rsp.arg[8] & 0x7FFE) >> 1;\n\tif (cmd.rsp.arg[8] & 0x10000) {\n\t\ttemp = (cmd.rsp.arg[8] & 0x7FFE0000) >> 17;\n\t\tnpar_info->max_linkspeed_reg_offset = temp;\n\t}\n\n\tmemcpy(ahw->extra_capability, &cmd.rsp.arg[16],\n\t       sizeof(ahw->extra_capability));\n\nout:\n\tqlcnic_free_mbx_args(&cmd);\n\treturn err;\n}\n\nint qlcnic_get_pci_func_type(struct qlcnic_adapter *adapter, u16 type,\n\t\t\t     u16 *nic, u16 *fcoe, u16 *iscsi)\n{\n\tstruct device *dev = &adapter->pdev->dev;\n\tint err = 0;\n\n\tswitch (type) {\n\tcase QLCNIC_TYPE_NIC:\n\t\t(*nic)++;\n\t\tbreak;\n\tcase QLCNIC_TYPE_FCOE:\n\t\t(*fcoe)++;\n\t\tbreak;\n\tcase QLCNIC_TYPE_ISCSI:\n\t\t(*iscsi)++;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"%s: Unknown PCI type[%x]\\n\",\n\t\t\t__func__, type);\n\t\terr = -EIO;\n\t}\n\n\treturn err;\n}\n\nint qlcnic_83xx_get_pci_info(struct qlcnic_adapter *adapter,\n\t\t\t     struct qlcnic_pci_info *pci_info)\n{\n\tstruct qlcnic_hardware_context *ahw = adapter->ahw;\n\tstruct device *dev = &adapter->pdev->dev;\n\tu16 nic = 0, fcoe = 0, iscsi = 0;\n\tstruct qlcnic_cmd_args cmd;\n\tint i, err = 0, j = 0;\n\tu32 temp;\n\n\terr = qlcnic_alloc_mbx_args(&cmd, adapter, QLCNIC_CMD_GET_PCI_INFO);\n\tif (err)\n\t\treturn err;\n\n\terr = qlcnic_issue_cmd(adapter, &cmd);\n\n\tahw->total_nic_func = 0;\n\tif (err == QLCNIC_RCODE_SUCCESS) {\n\t\tahw->max_pci_func = cmd.rsp.arg[1] & 0xFF;\n\t\tfor (i = 2, j = 0; j < ahw->max_vnic_func; j++, pci_info++) {\n\t\t\tpci_info->id = cmd.rsp.arg[i] & 0xFFFF;\n\t\t\tpci_info->active = (cmd.rsp.arg[i] & 0xFFFF0000) >> 16;\n\t\t\ti++;\n\t\t\tif (!pci_info->active) {\n\t\t\t\ti += QLC_SKIP_INACTIVE_PCI_REGS;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tpci_info->type = cmd.rsp.arg[i] & 0xFFFF;\n\t\t\terr = qlcnic_get_pci_func_type(adapter, pci_info->type,\n\t\t\t\t\t\t       &nic, &fcoe, &iscsi);\n\t\t\ttemp = (cmd.rsp.arg[i] & 0xFFFF0000) >> 16;\n\t\t\tpci_info->default_port = temp;\n\t\t\ti++;\n\t\t\tpci_info->tx_min_bw = cmd.rsp.arg[i] & 0xFFFF;\n\t\t\ttemp = (cmd.rsp.arg[i] & 0xFFFF0000) >> 16;\n\t\t\tpci_info->tx_max_bw = temp;\n\t\t\ti = i + 2;\n\t\t\tmemcpy(pci_info->mac, &cmd.rsp.arg[i], ETH_ALEN - 2);\n\t\t\ti++;\n\t\t\tmemcpy(pci_info->mac + sizeof(u32), &cmd.rsp.arg[i], 2);\n\t\t\ti = i + 3;\n\t\t}\n\t} else {\n\t\tdev_err(dev, \"Failed to get PCI Info, error = %d\\n\", err);\n\t\terr = -EIO;\n\t}\n\n\tahw->total_nic_func = nic;\n\tahw->total_pci_func = nic + fcoe + iscsi;\n\tif (ahw->total_nic_func == 0 || ahw->total_pci_func == 0) {\n\t\tdev_err(dev, \"%s: Invalid function count: total nic func[%x], total pci func[%x]\\n\",\n\t\t\t__func__, ahw->total_nic_func, ahw->total_pci_func);\n\t\terr = -EIO;\n\t}\n\tqlcnic_free_mbx_args(&cmd);\n\n\treturn err;\n}\n\nint qlcnic_83xx_config_intrpt(struct qlcnic_adapter *adapter, bool op_type)\n{\n\tint i, index, err;\n\tu8 max_ints;\n\tu32 val, temp, type;\n\tstruct qlcnic_cmd_args cmd;\n\n\tmax_ints = adapter->ahw->num_msix - 1;\n\terr = qlcnic_alloc_mbx_args(&cmd, adapter, QLCNIC_CMD_CONFIG_INTRPT);\n\tif (err)\n\t\treturn err;\n\n\tcmd.req.arg[1] = max_ints;\n\n\tif (qlcnic_sriov_vf_check(adapter))\n\t\tcmd.req.arg[1] |= (adapter->ahw->pci_func << 8) | BIT_16;\n\n\tfor (i = 0, index = 2; i < max_ints; i++) {\n\t\ttype = op_type ? QLCNIC_INTRPT_ADD : QLCNIC_INTRPT_DEL;\n\t\tval = type | (adapter->ahw->intr_tbl[i].type << 4);\n\t\tif (adapter->ahw->intr_tbl[i].type == QLCNIC_INTRPT_MSIX)\n\t\t\tval |= (adapter->ahw->intr_tbl[i].id << 16);\n\t\tcmd.req.arg[index++] = val;\n\t}\n\terr = qlcnic_issue_cmd(adapter, &cmd);\n\tif (err) {\n\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\"Failed to configure interrupts 0x%x\\n\", err);\n\t\tgoto out;\n\t}\n\n\tmax_ints = cmd.rsp.arg[1];\n\tfor (i = 0, index = 2; i < max_ints; i++, index += 2) {\n\t\tval = cmd.rsp.arg[index];\n\t\tif (LSB(val)) {\n\t\t\tdev_info(&adapter->pdev->dev,\n\t\t\t\t \"Can't configure interrupt %d\\n\",\n\t\t\t\t adapter->ahw->intr_tbl[i].id);\n\t\t\tcontinue;\n\t\t}\n\t\tif (op_type) {\n\t\t\tadapter->ahw->intr_tbl[i].id = MSW(val);\n\t\t\tadapter->ahw->intr_tbl[i].enabled = 1;\n\t\t\ttemp = cmd.rsp.arg[index + 1];\n\t\t\tadapter->ahw->intr_tbl[i].src = temp;\n\t\t} else {\n\t\t\tadapter->ahw->intr_tbl[i].id = i;\n\t\t\tadapter->ahw->intr_tbl[i].enabled = 0;\n\t\t\tadapter->ahw->intr_tbl[i].src = 0;\n\t\t}\n\t}\nout:\n\tqlcnic_free_mbx_args(&cmd);\n\treturn err;\n}\n\nint qlcnic_83xx_lock_flash(struct qlcnic_adapter *adapter)\n{\n\tint id, timeout = 0;\n\tu32 status = 0;\n\n\twhile (status == 0) {\n\t\tstatus = QLC_SHARED_REG_RD32(adapter, QLCNIC_FLASH_LOCK);\n\t\tif (status)\n\t\t\tbreak;\n\n\t\tif (++timeout >= QLC_83XX_FLASH_LOCK_TIMEOUT) {\n\t\t\tid = QLC_SHARED_REG_RD32(adapter,\n\t\t\t\t\t\t QLCNIC_FLASH_LOCK_OWNER);\n\t\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\t\"%s: failed, lock held by %d\\n\", __func__, id);\n\t\t\treturn -EIO;\n\t\t}\n\t\tusleep_range(1000, 2000);\n\t}\n\n\tQLC_SHARED_REG_WR32(adapter, QLCNIC_FLASH_LOCK_OWNER, adapter->portnum);\n\treturn 0;\n}\n\nvoid qlcnic_83xx_unlock_flash(struct qlcnic_adapter *adapter)\n{\n\tQLC_SHARED_REG_RD32(adapter, QLCNIC_FLASH_UNLOCK);\n\tQLC_SHARED_REG_WR32(adapter, QLCNIC_FLASH_LOCK_OWNER, 0xFF);\n}\n\nint qlcnic_83xx_lockless_flash_read32(struct qlcnic_adapter *adapter,\n\t\t\t\t      u32 flash_addr, u8 *p_data,\n\t\t\t\t      int count)\n{\n\tu32 word, range, flash_offset, addr = flash_addr, ret;\n\tulong indirect_add, direct_window;\n\tint i, err = 0;\n\n\tflash_offset = addr & (QLCNIC_FLASH_SECTOR_SIZE - 1);\n\tif (addr & 0x3) {\n\t\tdev_err(&adapter->pdev->dev, \"Illegal addr = 0x%x\\n\", addr);\n\t\treturn -EIO;\n\t}\n\n\tqlcnic_83xx_wrt_reg_indirect(adapter, QLC_83XX_FLASH_DIRECT_WINDOW,\n\t\t\t\t     (addr & 0xFFFF0000));\n\n\trange = flash_offset + (count * sizeof(u32));\n\t \n\tif (range > (QLCNIC_FLASH_SECTOR_SIZE - 1)) {\n\n\t\t \n\t\tfor (i = 0; i < count; i++) {\n\t\t\tindirect_add = QLC_83XX_FLASH_DIRECT_DATA(addr);\n\t\t\tret = QLCRD32(adapter, indirect_add, &err);\n\t\t\tif (err == -EIO)\n\t\t\t\treturn err;\n\n\t\t\tword = ret;\n\t\t\t*(u32 *)p_data  = word;\n\t\t\tp_data = p_data + 4;\n\t\t\taddr = addr + 4;\n\t\t\tflash_offset = flash_offset + 4;\n\n\t\t\tif (flash_offset > (QLCNIC_FLASH_SECTOR_SIZE - 1)) {\n\t\t\t\tdirect_window = QLC_83XX_FLASH_DIRECT_WINDOW;\n\t\t\t\t \n\t\t\t\tqlcnic_83xx_wrt_reg_indirect(adapter,\n\t\t\t\t\t\t\t     direct_window,\n\t\t\t\t\t\t\t     (addr));\n\t\t\t\tflash_offset = 0;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t \n\t\tfor (i = 0; i < count; i++) {\n\t\t\tindirect_add = QLC_83XX_FLASH_DIRECT_DATA(addr);\n\t\t\tret = QLCRD32(adapter, indirect_add, &err);\n\t\t\tif (err == -EIO)\n\t\t\t\treturn err;\n\n\t\t\tword = ret;\n\t\t\t*(u32 *)p_data  = word;\n\t\t\tp_data = p_data + 4;\n\t\t\taddr = addr + 4;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int qlcnic_83xx_poll_flash_status_reg(struct qlcnic_adapter *adapter)\n{\n\tu32 status;\n\tint retries = QLC_83XX_FLASH_READ_RETRY_COUNT;\n\tint err = 0;\n\n\tdo {\n\t\tstatus = QLCRD32(adapter, QLC_83XX_FLASH_STATUS, &err);\n\t\tif (err == -EIO)\n\t\t\treturn err;\n\n\t\tif ((status & QLC_83XX_FLASH_STATUS_READY) ==\n\t\t    QLC_83XX_FLASH_STATUS_READY)\n\t\t\tbreak;\n\n\t\tusleep_range(1000, 1100);\n\t} while (--retries);\n\n\tif (!retries)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nint qlcnic_83xx_enable_flash_write(struct qlcnic_adapter *adapter)\n{\n\tint ret;\n\tu32 cmd;\n\tcmd = adapter->ahw->fdt.write_statusreg_cmd;\n\tqlcnic_83xx_wrt_reg_indirect(adapter, QLC_83XX_FLASH_ADDR,\n\t\t\t\t     (QLC_83XX_FLASH_FDT_WRITE_DEF_SIG | cmd));\n\tqlcnic_83xx_wrt_reg_indirect(adapter, QLC_83XX_FLASH_WRDATA,\n\t\t\t\t     adapter->ahw->fdt.write_enable_bits);\n\tqlcnic_83xx_wrt_reg_indirect(adapter, QLC_83XX_FLASH_CONTROL,\n\t\t\t\t     QLC_83XX_FLASH_SECOND_ERASE_MS_VAL);\n\tret = qlcnic_83xx_poll_flash_status_reg(adapter);\n\tif (ret)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nint qlcnic_83xx_disable_flash_write(struct qlcnic_adapter *adapter)\n{\n\tint ret;\n\n\tqlcnic_83xx_wrt_reg_indirect(adapter, QLC_83XX_FLASH_ADDR,\n\t\t\t\t     (QLC_83XX_FLASH_FDT_WRITE_DEF_SIG |\n\t\t\t\t     adapter->ahw->fdt.write_statusreg_cmd));\n\tqlcnic_83xx_wrt_reg_indirect(adapter, QLC_83XX_FLASH_WRDATA,\n\t\t\t\t     adapter->ahw->fdt.write_disable_bits);\n\tqlcnic_83xx_wrt_reg_indirect(adapter, QLC_83XX_FLASH_CONTROL,\n\t\t\t\t     QLC_83XX_FLASH_SECOND_ERASE_MS_VAL);\n\tret = qlcnic_83xx_poll_flash_status_reg(adapter);\n\tif (ret)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nint qlcnic_83xx_read_flash_mfg_id(struct qlcnic_adapter *adapter)\n{\n\tint ret, err = 0;\n\tu32 mfg_id;\n\n\tif (qlcnic_83xx_lock_flash(adapter))\n\t\treturn -EIO;\n\n\tqlcnic_83xx_wrt_reg_indirect(adapter, QLC_83XX_FLASH_ADDR,\n\t\t\t\t     QLC_83XX_FLASH_FDT_READ_MFG_ID_VAL);\n\tqlcnic_83xx_wrt_reg_indirect(adapter, QLC_83XX_FLASH_CONTROL,\n\t\t\t\t     QLC_83XX_FLASH_READ_CTRL);\n\tret = qlcnic_83xx_poll_flash_status_reg(adapter);\n\tif (ret) {\n\t\tqlcnic_83xx_unlock_flash(adapter);\n\t\treturn -EIO;\n\t}\n\n\tmfg_id = QLCRD32(adapter, QLC_83XX_FLASH_RDDATA, &err);\n\tif (err == -EIO) {\n\t\tqlcnic_83xx_unlock_flash(adapter);\n\t\treturn err;\n\t}\n\n\tadapter->flash_mfg_id = (mfg_id & 0xFF);\n\tqlcnic_83xx_unlock_flash(adapter);\n\n\treturn 0;\n}\n\nint qlcnic_83xx_read_flash_descriptor_table(struct qlcnic_adapter *adapter)\n{\n\tint count, fdt_size, ret = 0;\n\n\tfdt_size = sizeof(struct qlcnic_fdt);\n\tcount = fdt_size / sizeof(u32);\n\n\tif (qlcnic_83xx_lock_flash(adapter))\n\t\treturn -EIO;\n\n\tmemset(&adapter->ahw->fdt, 0, fdt_size);\n\tret = qlcnic_83xx_lockless_flash_read32(adapter, QLCNIC_FDT_LOCATION,\n\t\t\t\t\t\t(u8 *)&adapter->ahw->fdt,\n\t\t\t\t\t\tcount);\n\tqlcnic_swap32_buffer((u32 *)&adapter->ahw->fdt, count);\n\tqlcnic_83xx_unlock_flash(adapter);\n\treturn ret;\n}\n\nint qlcnic_83xx_erase_flash_sector(struct qlcnic_adapter *adapter,\n\t\t\t\t   u32 sector_start_addr)\n{\n\tu32 reversed_addr, addr1, addr2, cmd;\n\tint ret = -EIO;\n\n\tif (qlcnic_83xx_lock_flash(adapter) != 0)\n\t\treturn -EIO;\n\n\tif (adapter->ahw->fdt.mfg_id == adapter->flash_mfg_id) {\n\t\tret = qlcnic_83xx_enable_flash_write(adapter);\n\t\tif (ret) {\n\t\t\tqlcnic_83xx_unlock_flash(adapter);\n\t\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\t\"%s failed at %d\\n\",\n\t\t\t\t__func__, __LINE__);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = qlcnic_83xx_poll_flash_status_reg(adapter);\n\tif (ret) {\n\t\tqlcnic_83xx_unlock_flash(adapter);\n\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\"%s: failed at %d\\n\", __func__, __LINE__);\n\t\treturn -EIO;\n\t}\n\n\taddr1 = (sector_start_addr & 0xFF) << 16;\n\taddr2 = (sector_start_addr & 0xFF0000) >> 16;\n\treversed_addr = addr1 | addr2 | (sector_start_addr & 0xFF00);\n\n\tqlcnic_83xx_wrt_reg_indirect(adapter, QLC_83XX_FLASH_WRDATA,\n\t\t\t\t     reversed_addr);\n\tcmd = QLC_83XX_FLASH_FDT_ERASE_DEF_SIG | adapter->ahw->fdt.erase_cmd;\n\tif (adapter->ahw->fdt.mfg_id == adapter->flash_mfg_id)\n\t\tqlcnic_83xx_wrt_reg_indirect(adapter, QLC_83XX_FLASH_ADDR, cmd);\n\telse\n\t\tqlcnic_83xx_wrt_reg_indirect(adapter, QLC_83XX_FLASH_ADDR,\n\t\t\t\t\t     QLC_83XX_FLASH_OEM_ERASE_SIG);\n\tqlcnic_83xx_wrt_reg_indirect(adapter, QLC_83XX_FLASH_CONTROL,\n\t\t\t\t     QLC_83XX_FLASH_LAST_ERASE_MS_VAL);\n\n\tret = qlcnic_83xx_poll_flash_status_reg(adapter);\n\tif (ret) {\n\t\tqlcnic_83xx_unlock_flash(adapter);\n\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\"%s: failed at %d\\n\", __func__, __LINE__);\n\t\treturn -EIO;\n\t}\n\n\tif (adapter->ahw->fdt.mfg_id == adapter->flash_mfg_id) {\n\t\tret = qlcnic_83xx_disable_flash_write(adapter);\n\t\tif (ret) {\n\t\t\tqlcnic_83xx_unlock_flash(adapter);\n\t\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\t\"%s: failed at %d\\n\", __func__, __LINE__);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tqlcnic_83xx_unlock_flash(adapter);\n\n\treturn 0;\n}\n\nint qlcnic_83xx_flash_write32(struct qlcnic_adapter *adapter, u32 addr,\n\t\t\t      u32 *p_data)\n{\n\tint ret = -EIO;\n\tu32 addr1 = 0x00800000 | (addr >> 2);\n\n\tqlcnic_83xx_wrt_reg_indirect(adapter, QLC_83XX_FLASH_ADDR, addr1);\n\tqlcnic_83xx_wrt_reg_indirect(adapter, QLC_83XX_FLASH_WRDATA, *p_data);\n\tqlcnic_83xx_wrt_reg_indirect(adapter, QLC_83XX_FLASH_CONTROL,\n\t\t\t\t     QLC_83XX_FLASH_LAST_ERASE_MS_VAL);\n\tret = qlcnic_83xx_poll_flash_status_reg(adapter);\n\tif (ret) {\n\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\"%s: failed at %d\\n\", __func__, __LINE__);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nint qlcnic_83xx_flash_bulk_write(struct qlcnic_adapter *adapter, u32 addr,\n\t\t\t\t u32 *p_data, int count)\n{\n\tu32 temp;\n\tint ret = -EIO, err = 0;\n\n\tif ((count < QLC_83XX_FLASH_WRITE_MIN) ||\n\t    (count > QLC_83XX_FLASH_WRITE_MAX)) {\n\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\"%s: Invalid word count\\n\", __func__);\n\t\treturn -EIO;\n\t}\n\n\ttemp = QLCRD32(adapter, QLC_83XX_FLASH_SPI_CONTROL, &err);\n\tif (err == -EIO)\n\t\treturn err;\n\n\tqlcnic_83xx_wrt_reg_indirect(adapter, QLC_83XX_FLASH_SPI_CONTROL,\n\t\t\t\t     (temp | QLC_83XX_FLASH_SPI_CTRL));\n\tqlcnic_83xx_wrt_reg_indirect(adapter, QLC_83XX_FLASH_ADDR,\n\t\t\t\t     QLC_83XX_FLASH_ADDR_TEMP_VAL);\n\n\t \n\tqlcnic_83xx_wrt_reg_indirect(adapter, QLC_83XX_FLASH_WRDATA, *p_data++);\n\tqlcnic_83xx_wrt_reg_indirect(adapter, QLC_83XX_FLASH_CONTROL,\n\t\t\t\t     QLC_83XX_FLASH_FIRST_MS_PATTERN);\n\tret = qlcnic_83xx_poll_flash_status_reg(adapter);\n\tif (ret) {\n\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\"%s: failed at %d\\n\", __func__, __LINE__);\n\t\treturn -EIO;\n\t}\n\n\tcount--;\n\tqlcnic_83xx_wrt_reg_indirect(adapter, QLC_83XX_FLASH_ADDR,\n\t\t\t\t     QLC_83XX_FLASH_ADDR_SECOND_TEMP_VAL);\n\t \n\twhile (count != 1) {\n\t\tqlcnic_83xx_wrt_reg_indirect(adapter, QLC_83XX_FLASH_WRDATA,\n\t\t\t\t\t     *p_data++);\n\t\tqlcnic_83xx_wrt_reg_indirect(adapter, QLC_83XX_FLASH_CONTROL,\n\t\t\t\t\t     QLC_83XX_FLASH_SECOND_MS_PATTERN);\n\t\tret = qlcnic_83xx_poll_flash_status_reg(adapter);\n\t\tif (ret) {\n\t\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\t\"%s: failed at %d\\n\", __func__, __LINE__);\n\t\t\treturn -EIO;\n\t\t}\n\t\tcount--;\n\t}\n\n\tqlcnic_83xx_wrt_reg_indirect(adapter, QLC_83XX_FLASH_ADDR,\n\t\t\t\t     QLC_83XX_FLASH_ADDR_TEMP_VAL |\n\t\t\t\t     (addr >> 2));\n\t \n\tqlcnic_83xx_wrt_reg_indirect(adapter, QLC_83XX_FLASH_WRDATA, *p_data++);\n\tqlcnic_83xx_wrt_reg_indirect(adapter, QLC_83XX_FLASH_CONTROL,\n\t\t\t\t     QLC_83XX_FLASH_LAST_MS_PATTERN);\n\tret = qlcnic_83xx_poll_flash_status_reg(adapter);\n\tif (ret) {\n\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\"%s: failed at %d\\n\", __func__, __LINE__);\n\t\treturn -EIO;\n\t}\n\n\tret = QLCRD32(adapter, QLC_83XX_FLASH_SPI_STATUS, &err);\n\tif (err == -EIO)\n\t\treturn err;\n\n\tif ((ret & QLC_83XX_FLASH_SPI_CTRL) == QLC_83XX_FLASH_SPI_CTRL) {\n\t\tdev_err(&adapter->pdev->dev, \"%s: failed at %d\\n\",\n\t\t\t__func__, __LINE__);\n\t\t \n\t\ttemp = QLCRD32(adapter, QLC_83XX_FLASH_SPI_CONTROL, &err);\n\t\tif (err == -EIO)\n\t\t\treturn err;\n\n\t\tqlcnic_83xx_wrt_reg_indirect(adapter,\n\t\t\t\t\t     QLC_83XX_FLASH_SPI_CONTROL,\n\t\t\t\t\t     (temp | QLC_83XX_FLASH_SPI_CTRL));\n\t}\n\n\treturn 0;\n}\n\nstatic void qlcnic_83xx_recover_driver_lock(struct qlcnic_adapter *adapter)\n{\n\tu32 val, id;\n\n\tval = QLCRDX(adapter->ahw, QLC_83XX_RECOVER_DRV_LOCK);\n\n\t \n\tif ((val & QLC_83XX_DRV_LOCK_RECOVERY_STATUS_MASK) == 0) {\n\t\tval = val & ~0x3F;\n\t\tval = val | ((adapter->portnum << 2) |\n\t\t\t     QLC_83XX_NEED_DRV_LOCK_RECOVERY);\n\t\tQLCWRX(adapter->ahw, QLC_83XX_RECOVER_DRV_LOCK, val);\n\t\tdev_info(&adapter->pdev->dev,\n\t\t\t \"%s: lock recovery initiated\\n\", __func__);\n\t\tmdelay(QLC_83XX_DRV_LOCK_RECOVERY_DELAY);\n\t\tval = QLCRDX(adapter->ahw, QLC_83XX_RECOVER_DRV_LOCK);\n\t\tid = ((val >> 2) & 0xF);\n\t\tif (id == adapter->portnum) {\n\t\t\tval = val & ~QLC_83XX_DRV_LOCK_RECOVERY_STATUS_MASK;\n\t\t\tval = val | QLC_83XX_DRV_LOCK_RECOVERY_IN_PROGRESS;\n\t\t\tQLCWRX(adapter->ahw, QLC_83XX_RECOVER_DRV_LOCK, val);\n\t\t\t \n\t\t\tQLCRDX(adapter->ahw, QLC_83XX_DRV_UNLOCK);\n\t\t\t \n\t\t\tval = val & ~0x3F;\n\t\t\tQLCWRX(adapter->ahw, QLC_83XX_RECOVER_DRV_LOCK, val);\n\t\t\tdev_info(&adapter->pdev->dev,\n\t\t\t\t \"%s: lock recovery completed\\n\", __func__);\n\t\t} else {\n\t\t\tdev_info(&adapter->pdev->dev,\n\t\t\t\t \"%s: func %d to resume lock recovery process\\n\",\n\t\t\t\t __func__, id);\n\t\t}\n\t} else {\n\t\tdev_info(&adapter->pdev->dev,\n\t\t\t \"%s: lock recovery initiated by other functions\\n\",\n\t\t\t __func__);\n\t}\n}\n\nint qlcnic_83xx_lock_driver(struct qlcnic_adapter *adapter)\n{\n\tu32 lock_alive_counter, val, id, i = 0, status = 0, temp = 0;\n\tint max_attempt = 0;\n\n\twhile (status == 0) {\n\t\tstatus = QLCRDX(adapter->ahw, QLC_83XX_DRV_LOCK);\n\t\tif (status)\n\t\t\tbreak;\n\n\t\tmdelay(QLC_83XX_DRV_LOCK_WAIT_DELAY);\n\t\ti++;\n\n\t\tif (i == 1)\n\t\t\ttemp = QLCRDX(adapter->ahw, QLC_83XX_DRV_LOCK_ID);\n\n\t\tif (i == QLC_83XX_DRV_LOCK_WAIT_COUNTER) {\n\t\t\tval = QLCRDX(adapter->ahw, QLC_83XX_DRV_LOCK_ID);\n\t\t\tif (val == temp) {\n\t\t\t\tid = val & 0xFF;\n\t\t\t\tdev_info(&adapter->pdev->dev,\n\t\t\t\t\t \"%s: lock to be recovered from %d\\n\",\n\t\t\t\t\t __func__, id);\n\t\t\t\tqlcnic_83xx_recover_driver_lock(adapter);\n\t\t\t\ti = 0;\n\t\t\t\tmax_attempt++;\n\t\t\t} else {\n\t\t\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\t\t\"%s: failed to get lock\\n\", __func__);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (max_attempt == QLC_83XX_MAX_DRV_LOCK_RECOVERY_ATTEMPT) {\n\t\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\t\"%s: failed to get lock\\n\", __func__);\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\tval = QLCRDX(adapter->ahw, QLC_83XX_DRV_LOCK_ID);\n\tlock_alive_counter = val >> 8;\n\tlock_alive_counter++;\n\tval = lock_alive_counter << 8 | adapter->portnum;\n\tQLCWRX(adapter->ahw, QLC_83XX_DRV_LOCK_ID, val);\n\n\treturn 0;\n}\n\nvoid qlcnic_83xx_unlock_driver(struct qlcnic_adapter *adapter)\n{\n\tu32 val, lock_alive_counter, id;\n\n\tval = QLCRDX(adapter->ahw, QLC_83XX_DRV_LOCK_ID);\n\tid = val & 0xFF;\n\tlock_alive_counter = val >> 8;\n\n\tif (id != adapter->portnum)\n\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\"%s:Warning func %d is unlocking lock owned by %d\\n\",\n\t\t\t__func__, adapter->portnum, id);\n\n\tval = (lock_alive_counter << 8) | 0xFF;\n\tQLCWRX(adapter->ahw, QLC_83XX_DRV_LOCK_ID, val);\n\tQLCRDX(adapter->ahw, QLC_83XX_DRV_UNLOCK);\n}\n\nint qlcnic_ms_mem_write128(struct qlcnic_adapter *adapter, u64 addr,\n\t\t\t\tu32 *data, u32 count)\n{\n\tint i, j, ret = 0;\n\tu32 temp;\n\n\t \n\tif (addr & 0xF)\n\t\treturn -EIO;\n\n\tmutex_lock(&adapter->ahw->mem_lock);\n\tqlcnic_ind_wr(adapter, QLCNIC_MS_ADDR_HI, 0);\n\n\tfor (i = 0; i < count; i++, addr += 16) {\n\t\tif (!((ADDR_IN_RANGE(addr, QLCNIC_ADDR_QDR_NET,\n\t\t\t\t     QLCNIC_ADDR_QDR_NET_MAX)) ||\n\t\t      (ADDR_IN_RANGE(addr, QLCNIC_ADDR_DDR_NET,\n\t\t\t\t     QLCNIC_ADDR_DDR_NET_MAX)))) {\n\t\t\tmutex_unlock(&adapter->ahw->mem_lock);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tqlcnic_ind_wr(adapter, QLCNIC_MS_ADDR_LO, addr);\n\t\tqlcnic_ind_wr(adapter, QLCNIC_MS_WRTDATA_LO, *data++);\n\t\tqlcnic_ind_wr(adapter, QLCNIC_MS_WRTDATA_HI, *data++);\n\t\tqlcnic_ind_wr(adapter, QLCNIC_MS_WRTDATA_ULO, *data++);\n\t\tqlcnic_ind_wr(adapter, QLCNIC_MS_WRTDATA_UHI, *data++);\n\t\tqlcnic_ind_wr(adapter, QLCNIC_MS_CTRL, QLCNIC_TA_WRITE_ENABLE);\n\t\tqlcnic_ind_wr(adapter, QLCNIC_MS_CTRL, QLCNIC_TA_WRITE_START);\n\n\t\tfor (j = 0; j < MAX_CTL_CHECK; j++) {\n\t\t\ttemp = qlcnic_ind_rd(adapter, QLCNIC_MS_CTRL);\n\n\t\t\tif ((temp & TA_CTL_BUSY) == 0)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (j >= MAX_CTL_CHECK) {\n\t\t\tprintk_ratelimited(KERN_WARNING\n\t\t\t\t\t   \"MS memory write failed\\n\");\n\t\t\tmutex_unlock(&adapter->ahw->mem_lock);\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\tmutex_unlock(&adapter->ahw->mem_lock);\n\n\treturn ret;\n}\n\nint qlcnic_83xx_flash_read32(struct qlcnic_adapter *adapter, u32 flash_addr,\n\t\t\t     u8 *p_data, int count)\n{\n\tu32 word, addr = flash_addr, ret;\n\tulong  indirect_addr;\n\tint i, err = 0;\n\n\tif (qlcnic_83xx_lock_flash(adapter) != 0)\n\t\treturn -EIO;\n\n\tif (addr & 0x3) {\n\t\tdev_err(&adapter->pdev->dev, \"Illegal addr = 0x%x\\n\", addr);\n\t\tqlcnic_83xx_unlock_flash(adapter);\n\t\treturn -EIO;\n\t}\n\n\tfor (i = 0; i < count; i++) {\n\t\tif (qlcnic_83xx_wrt_reg_indirect(adapter,\n\t\t\t\t\t\t QLC_83XX_FLASH_DIRECT_WINDOW,\n\t\t\t\t\t\t (addr))) {\n\t\t\tqlcnic_83xx_unlock_flash(adapter);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tindirect_addr = QLC_83XX_FLASH_DIRECT_DATA(addr);\n\t\tret = QLCRD32(adapter, indirect_addr, &err);\n\t\tif (err == -EIO) {\n\t\t\tqlcnic_83xx_unlock_flash(adapter);\n\t\t\treturn err;\n\t\t}\n\n\t\tword = ret;\n\t\t*(u32 *)p_data  = word;\n\t\tp_data = p_data + 4;\n\t\taddr = addr + 4;\n\t}\n\n\tqlcnic_83xx_unlock_flash(adapter);\n\n\treturn 0;\n}\n\nvoid qlcnic_83xx_get_port_type(struct qlcnic_adapter *adapter)\n{\n\tstruct qlcnic_hardware_context *ahw = adapter->ahw;\n\tstruct qlcnic_cmd_args cmd;\n\tu32 config;\n\tint err;\n\n\terr = qlcnic_alloc_mbx_args(&cmd, adapter, QLCNIC_CMD_GET_LINK_STATUS);\n\tif (err)\n\t\treturn;\n\n\terr = qlcnic_issue_cmd(adapter, &cmd);\n\tif (err) {\n\t\tdev_info(&adapter->pdev->dev,\n\t\t\t \"Get Link Status Command failed: 0x%x\\n\", err);\n\t\tgoto out;\n\t} else {\n\t\tconfig = cmd.rsp.arg[3];\n\n\t\tswitch (QLC_83XX_SFP_MODULE_TYPE(config)) {\n\t\tcase QLC_83XX_MODULE_FIBRE_1000BASE_SX:\n\t\tcase QLC_83XX_MODULE_FIBRE_1000BASE_LX:\n\t\tcase QLC_83XX_MODULE_FIBRE_1000BASE_CX:\n\t\tcase QLC_83XX_MODULE_TP_1000BASE_T:\n\t\t\tahw->port_type = QLCNIC_GBE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tahw->port_type = QLCNIC_XGBE;\n\t\t}\n\t}\nout:\n\tqlcnic_free_mbx_args(&cmd);\n}\n\nint qlcnic_83xx_test_link(struct qlcnic_adapter *adapter)\n{\n\tu8 pci_func;\n\tint err;\n\tu32 config = 0, state;\n\tstruct qlcnic_cmd_args cmd;\n\tstruct qlcnic_hardware_context *ahw = adapter->ahw;\n\n\tif (qlcnic_sriov_vf_check(adapter))\n\t\tpci_func = adapter->portnum;\n\telse\n\t\tpci_func = ahw->pci_func;\n\n\tstate = readl(ahw->pci_base0 + QLC_83XX_LINK_STATE(pci_func));\n\tif (!QLC_83xx_FUNC_VAL(state, pci_func)) {\n\t\tdev_info(&adapter->pdev->dev, \"link state down\\n\");\n\t\treturn config;\n\t}\n\n\terr = qlcnic_alloc_mbx_args(&cmd, adapter, QLCNIC_CMD_GET_LINK_STATUS);\n\tif (err)\n\t\treturn err;\n\n\terr = qlcnic_issue_cmd(adapter, &cmd);\n\tif (err) {\n\t\tdev_info(&adapter->pdev->dev,\n\t\t\t \"Get Link Status Command failed: 0x%x\\n\", err);\n\t\tgoto out;\n\t} else {\n\t\tconfig = cmd.rsp.arg[1];\n\t\tswitch (QLC_83XX_CURRENT_LINK_SPEED(config)) {\n\t\tcase QLC_83XX_10M_LINK:\n\t\t\tahw->link_speed = SPEED_10;\n\t\t\tbreak;\n\t\tcase QLC_83XX_100M_LINK:\n\t\t\tahw->link_speed = SPEED_100;\n\t\t\tbreak;\n\t\tcase QLC_83XX_1G_LINK:\n\t\t\tahw->link_speed = SPEED_1000;\n\t\t\tbreak;\n\t\tcase QLC_83XX_10G_LINK:\n\t\t\tahw->link_speed = SPEED_10000;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tahw->link_speed = 0;\n\t\t\tbreak;\n\t\t}\n\t\tconfig = cmd.rsp.arg[3];\n\t\tswitch (QLC_83XX_SFP_MODULE_TYPE(config)) {\n\t\tcase QLC_83XX_MODULE_FIBRE_10GBASE_LRM:\n\t\tcase QLC_83XX_MODULE_FIBRE_10GBASE_LR:\n\t\tcase QLC_83XX_MODULE_FIBRE_10GBASE_SR:\n\t\t\tahw->supported_type = PORT_FIBRE;\n\t\t\tahw->port_type = QLCNIC_XGBE;\n\t\t\tbreak;\n\t\tcase QLC_83XX_MODULE_FIBRE_1000BASE_SX:\n\t\tcase QLC_83XX_MODULE_FIBRE_1000BASE_LX:\n\t\tcase QLC_83XX_MODULE_FIBRE_1000BASE_CX:\n\t\t\tahw->supported_type = PORT_FIBRE;\n\t\t\tahw->port_type = QLCNIC_GBE;\n\t\t\tbreak;\n\t\tcase QLC_83XX_MODULE_TP_1000BASE_T:\n\t\t\tahw->supported_type = PORT_TP;\n\t\t\tahw->port_type = QLCNIC_GBE;\n\t\t\tbreak;\n\t\tcase QLC_83XX_MODULE_DA_10GE_PASSIVE_CP:\n\t\tcase QLC_83XX_MODULE_DA_10GE_ACTIVE_CP:\n\t\tcase QLC_83XX_MODULE_DA_10GE_LEGACY_CP:\n\t\tcase QLC_83XX_MODULE_DA_1GE_PASSIVE_CP:\n\t\t\tahw->supported_type = PORT_DA;\n\t\t\tahw->port_type = QLCNIC_XGBE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tahw->supported_type = PORT_OTHER;\n\t\t\tahw->port_type = QLCNIC_XGBE;\n\t\t}\n\t\tif (config & 1)\n\t\t\terr = 1;\n\t}\nout:\n\tqlcnic_free_mbx_args(&cmd);\n\treturn config;\n}\n\nint qlcnic_83xx_get_link_ksettings(struct qlcnic_adapter *adapter,\n\t\t\t\t   struct ethtool_link_ksettings *ecmd)\n{\n\tstruct qlcnic_hardware_context *ahw = adapter->ahw;\n\tu32 config = 0;\n\tint status = 0;\n\tu32 supported, advertising;\n\n\tif (!test_bit(__QLCNIC_MAINTENANCE_MODE, &adapter->state)) {\n\t\t \n\t\tstatus = qlcnic_83xx_get_port_info(adapter);\n\t\t \n\t\tconfig = qlcnic_83xx_test_link(adapter);\n\t\tahw->module_type = QLC_83XX_SFP_MODULE_TYPE(config);\n\t}\n\n\t \n\tahw->board_type = QLCNIC_BRDTYPE_83XX_10G;\n\n\tif (netif_running(adapter->netdev) && ahw->has_link_events) {\n\t\tecmd->base.speed = ahw->link_speed;\n\t\tecmd->base.duplex = ahw->link_duplex;\n\t\tecmd->base.autoneg = ahw->link_autoneg;\n\t} else {\n\t\tecmd->base.speed = SPEED_UNKNOWN;\n\t\tecmd->base.duplex = DUPLEX_UNKNOWN;\n\t\tecmd->base.autoneg = AUTONEG_DISABLE;\n\t}\n\n\tsupported = (SUPPORTED_10baseT_Full |\n\t\t\t   SUPPORTED_100baseT_Full |\n\t\t\t   SUPPORTED_1000baseT_Full |\n\t\t\t   SUPPORTED_10000baseT_Full |\n\t\t\t   SUPPORTED_Autoneg);\n\n\tethtool_convert_link_mode_to_legacy_u32(&advertising,\n\t\t\t\t\t\tecmd->link_modes.advertising);\n\n\tif (ecmd->base.autoneg == AUTONEG_ENABLE) {\n\t\tif (ahw->port_config & QLC_83XX_10_CAPABLE)\n\t\t\tadvertising |= SUPPORTED_10baseT_Full;\n\t\tif (ahw->port_config & QLC_83XX_100_CAPABLE)\n\t\t\tadvertising |= SUPPORTED_100baseT_Full;\n\t\tif (ahw->port_config & QLC_83XX_1G_CAPABLE)\n\t\t\tadvertising |= SUPPORTED_1000baseT_Full;\n\t\tif (ahw->port_config & QLC_83XX_10G_CAPABLE)\n\t\t\tadvertising |= SUPPORTED_10000baseT_Full;\n\t\tif (ahw->port_config & QLC_83XX_AUTONEG_ENABLE)\n\t\t\tadvertising |= ADVERTISED_Autoneg;\n\t} else {\n\t\tswitch (ahw->link_speed) {\n\t\tcase SPEED_10:\n\t\t\tadvertising = SUPPORTED_10baseT_Full;\n\t\t\tbreak;\n\t\tcase SPEED_100:\n\t\t\tadvertising = SUPPORTED_100baseT_Full;\n\t\t\tbreak;\n\t\tcase SPEED_1000:\n\t\t\tadvertising = SUPPORTED_1000baseT_Full;\n\t\t\tbreak;\n\t\tcase SPEED_10000:\n\t\t\tadvertising = SUPPORTED_10000baseT_Full;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t}\n\n\tswitch (ahw->supported_type) {\n\tcase PORT_FIBRE:\n\t\tsupported |= SUPPORTED_FIBRE;\n\t\tadvertising |= ADVERTISED_FIBRE;\n\t\tecmd->base.port = PORT_FIBRE;\n\t\tbreak;\n\tcase PORT_TP:\n\t\tsupported |= SUPPORTED_TP;\n\t\tadvertising |= ADVERTISED_TP;\n\t\tecmd->base.port = PORT_TP;\n\t\tbreak;\n\tcase PORT_DA:\n\t\tsupported |= SUPPORTED_FIBRE;\n\t\tadvertising |= ADVERTISED_FIBRE;\n\t\tecmd->base.port = PORT_DA;\n\t\tbreak;\n\tdefault:\n\t\tsupported |= SUPPORTED_FIBRE;\n\t\tadvertising |= ADVERTISED_FIBRE;\n\t\tecmd->base.port = PORT_OTHER;\n\t\tbreak;\n\t}\n\tecmd->base.phy_address = ahw->physical_port;\n\n\tethtool_convert_legacy_u32_to_link_mode(ecmd->link_modes.supported,\n\t\t\t\t\t\tsupported);\n\tethtool_convert_legacy_u32_to_link_mode(ecmd->link_modes.advertising,\n\t\t\t\t\t\tadvertising);\n\n\treturn status;\n}\n\nint qlcnic_83xx_set_link_ksettings(struct qlcnic_adapter *adapter,\n\t\t\t\t   const struct ethtool_link_ksettings *ecmd)\n{\n\tstruct qlcnic_hardware_context *ahw = adapter->ahw;\n\tu32 config = adapter->ahw->port_config;\n\tint status = 0;\n\n\t \n\tif (ecmd->base.duplex == DUPLEX_HALF) {\n\t\tnetdev_info(adapter->netdev,\n\t\t\t    \"Half duplex mode not supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (ecmd->base.autoneg) {\n\t\tahw->port_config |= QLC_83XX_AUTONEG_ENABLE;\n\t\tahw->port_config |= (QLC_83XX_100_CAPABLE |\n\t\t\t\t     QLC_83XX_1G_CAPABLE |\n\t\t\t\t     QLC_83XX_10G_CAPABLE);\n\t} else {  \n\t\tahw->port_config &= ~QLC_83XX_AUTONEG_ENABLE;\n\t\tswitch (ecmd->base.speed) {\n\t\tcase SPEED_10:\n\t\t\tahw->port_config &= ~(QLC_83XX_100_CAPABLE |\n\t\t\t\t\t      QLC_83XX_1G_CAPABLE |\n\t\t\t\t\t      QLC_83XX_10G_CAPABLE);\n\t\t\tahw->port_config |= QLC_83XX_10_CAPABLE;\n\t\t\tbreak;\n\t\tcase SPEED_100:\n\t\t\tahw->port_config &= ~(QLC_83XX_10_CAPABLE |\n\t\t\t\t\t      QLC_83XX_1G_CAPABLE |\n\t\t\t\t\t      QLC_83XX_10G_CAPABLE);\n\t\t\tahw->port_config |= QLC_83XX_100_CAPABLE;\n\t\t\tbreak;\n\t\tcase SPEED_1000:\n\t\t\tahw->port_config &= ~(QLC_83XX_10_CAPABLE |\n\t\t\t\t\t      QLC_83XX_100_CAPABLE |\n\t\t\t\t\t      QLC_83XX_10G_CAPABLE);\n\t\t\tahw->port_config |= QLC_83XX_1G_CAPABLE;\n\t\t\tbreak;\n\t\tcase SPEED_10000:\n\t\t\tahw->port_config &= ~(QLC_83XX_10_CAPABLE |\n\t\t\t\t\t      QLC_83XX_100_CAPABLE |\n\t\t\t\t\t      QLC_83XX_1G_CAPABLE);\n\t\t\tahw->port_config |= QLC_83XX_10G_CAPABLE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tstatus = qlcnic_83xx_set_port_config(adapter);\n\tif (status) {\n\t\tnetdev_info(adapter->netdev,\n\t\t\t    \"Failed to Set Link Speed and autoneg.\\n\");\n\t\tahw->port_config = config;\n\t}\n\n\treturn status;\n}\n\nstatic inline u64 *qlcnic_83xx_copy_stats(struct qlcnic_cmd_args *cmd,\n\t\t\t\t\t  u64 *data, int index)\n{\n\tu32 low, hi;\n\tu64 val;\n\n\tlow = cmd->rsp.arg[index];\n\thi = cmd->rsp.arg[index + 1];\n\tval = (((u64) low) | (((u64) hi) << 32));\n\t*data++ = val;\n\treturn data;\n}\n\nstatic u64 *qlcnic_83xx_fill_stats(struct qlcnic_adapter *adapter,\n\t\t\t\t   struct qlcnic_cmd_args *cmd, u64 *data,\n\t\t\t\t   int type, int *ret)\n{\n\tint err, k, total_regs;\n\n\t*ret = 0;\n\terr = qlcnic_issue_cmd(adapter, cmd);\n\tif (err != QLCNIC_RCODE_SUCCESS) {\n\t\tdev_info(&adapter->pdev->dev,\n\t\t\t \"Error in get statistics mailbox command\\n\");\n\t\t*ret = -EIO;\n\t\treturn data;\n\t}\n\ttotal_regs = cmd->rsp.num;\n\tswitch (type) {\n\tcase QLC_83XX_STAT_MAC:\n\t\t \n\t\tfor (k = 2; k < 28; k += 2)\n\t\t\tdata = qlcnic_83xx_copy_stats(cmd, data, k);\n\t\t \n\t\t \n\t\tfor (k += 6; k < 60; k += 2)\n\t\t\tdata = qlcnic_83xx_copy_stats(cmd, data, k);\n\t\t \n\t\t \n\t\tfor (k += 6; k < 80; k += 2)\n\t\t\tdata = qlcnic_83xx_copy_stats(cmd, data, k);\n\t\t \n\t\tfor (; k < total_regs; k += 2)\n\t\t\tdata = qlcnic_83xx_copy_stats(cmd, data, k);\n\t\tbreak;\n\tcase QLC_83XX_STAT_RX:\n\t\tfor (k = 2; k < 8; k += 2)\n\t\t\tdata = qlcnic_83xx_copy_stats(cmd, data, k);\n\t\t \n\t\tfor (k += 2; k < 24; k += 2)\n\t\t\tdata = qlcnic_83xx_copy_stats(cmd, data, k);\n\t\t \n\t\tfor (k += 2; k < total_regs; k += 2)\n\t\t\tdata = qlcnic_83xx_copy_stats(cmd, data, k);\n\t\tbreak;\n\tcase QLC_83XX_STAT_TX:\n\t\tfor (k = 2; k < 10; k += 2)\n\t\t\tdata = qlcnic_83xx_copy_stats(cmd, data, k);\n\t\t \n\t\tfor (k += 2; k < total_regs; k += 2)\n\t\t\tdata = qlcnic_83xx_copy_stats(cmd, data, k);\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(&adapter->pdev->dev, \"Unknown get statistics mode\\n\");\n\t\t*ret = -EIO;\n\t}\n\treturn data;\n}\n\nvoid qlcnic_83xx_get_stats(struct qlcnic_adapter *adapter, u64 *data)\n{\n\tstruct qlcnic_cmd_args cmd;\n\tstruct net_device *netdev = adapter->netdev;\n\tint ret = 0;\n\n\tret = qlcnic_alloc_mbx_args(&cmd, adapter, QLCNIC_CMD_GET_STATISTICS);\n\tif (ret)\n\t\treturn;\n\t \n\tcmd.req.arg[1] = BIT_1 | (adapter->tx_ring->ctx_id << 16);\n\tcmd.rsp.num = QLC_83XX_TX_STAT_REGS;\n\tdata = qlcnic_83xx_fill_stats(adapter, &cmd, data,\n\t\t\t\t      QLC_83XX_STAT_TX, &ret);\n\tif (ret) {\n\t\tnetdev_err(netdev, \"Error getting Tx stats\\n\");\n\t\tgoto out;\n\t}\n\t \n\tcmd.req.arg[1] = BIT_2 | (adapter->portnum << 16);\n\tcmd.rsp.num = QLC_83XX_MAC_STAT_REGS;\n\tmemset(cmd.rsp.arg, 0, sizeof(u32) * cmd.rsp.num);\n\tdata = qlcnic_83xx_fill_stats(adapter, &cmd, data,\n\t\t\t\t      QLC_83XX_STAT_MAC, &ret);\n\tif (ret) {\n\t\tnetdev_err(netdev, \"Error getting MAC stats\\n\");\n\t\tgoto out;\n\t}\n\t \n\tcmd.req.arg[1] = adapter->recv_ctx->context_id << 16;\n\tcmd.rsp.num = QLC_83XX_RX_STAT_REGS;\n\tmemset(cmd.rsp.arg, 0, sizeof(u32) * cmd.rsp.num);\n\tdata = qlcnic_83xx_fill_stats(adapter, &cmd, data,\n\t\t\t\t      QLC_83XX_STAT_RX, &ret);\n\tif (ret)\n\t\tnetdev_err(netdev, \"Error getting Rx stats\\n\");\nout:\n\tqlcnic_free_mbx_args(&cmd);\n}\n\n#define QLCNIC_83XX_ADD_PORT0\t\tBIT_0\n#define QLCNIC_83XX_ADD_PORT1\t\tBIT_1\n#define QLCNIC_83XX_EXTENDED_MEM_SIZE\t13  \nint qlcnic_83xx_extend_md_capab(struct qlcnic_adapter *adapter)\n{\n\tstruct qlcnic_cmd_args cmd;\n\tint err;\n\n\terr = qlcnic_alloc_mbx_args(&cmd, adapter,\n\t\t\t\t    QLCNIC_CMD_83XX_EXTEND_ISCSI_DUMP_CAP);\n\tif (err)\n\t\treturn err;\n\n\tcmd.req.arg[1] = (QLCNIC_83XX_ADD_PORT0 | QLCNIC_83XX_ADD_PORT1);\n\tcmd.req.arg[2] = QLCNIC_83XX_EXTENDED_MEM_SIZE;\n\tcmd.req.arg[3] = QLCNIC_83XX_EXTENDED_MEM_SIZE;\n\n\terr = qlcnic_issue_cmd(adapter, &cmd);\n\tif (err)\n\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\"failed to issue extend iSCSI minidump capability\\n\");\n\n\treturn err;\n}\n\nint qlcnic_83xx_reg_test(struct qlcnic_adapter *adapter)\n{\n\tu32 major, minor, sub;\n\n\tmajor = QLC_SHARED_REG_RD32(adapter, QLCNIC_FW_VERSION_MAJOR);\n\tminor = QLC_SHARED_REG_RD32(adapter, QLCNIC_FW_VERSION_MINOR);\n\tsub = QLC_SHARED_REG_RD32(adapter, QLCNIC_FW_VERSION_SUB);\n\n\tif (adapter->fw_version != QLCNIC_VERSION_CODE(major, minor, sub)) {\n\t\tdev_info(&adapter->pdev->dev, \"%s: Reg test failed\\n\",\n\t\t\t __func__);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\ninline int qlcnic_83xx_get_regs_len(struct qlcnic_adapter *adapter)\n{\n\treturn (ARRAY_SIZE(qlcnic_83xx_ext_reg_tbl) *\n\t\tsizeof(*adapter->ahw->ext_reg_tbl)) +\n\t\t(ARRAY_SIZE(qlcnic_83xx_reg_tbl) *\n\t\tsizeof(*adapter->ahw->reg_tbl));\n}\n\nint qlcnic_83xx_get_registers(struct qlcnic_adapter *adapter, u32 *regs_buff)\n{\n\tint i, j = 0;\n\n\tfor (i = QLCNIC_DEV_INFO_SIZE + 1;\n\t     j < ARRAY_SIZE(qlcnic_83xx_reg_tbl); i++, j++)\n\t\tregs_buff[i] = QLC_SHARED_REG_RD32(adapter, j);\n\n\tfor (j = 0; j < ARRAY_SIZE(qlcnic_83xx_ext_reg_tbl); j++)\n\t\tregs_buff[i++] = QLCRDX(adapter->ahw, j);\n\treturn i;\n}\n\nint qlcnic_83xx_interrupt_test(struct net_device *netdev)\n{\n\tstruct qlcnic_adapter *adapter = netdev_priv(netdev);\n\tstruct qlcnic_hardware_context *ahw = adapter->ahw;\n\tstruct qlcnic_cmd_args cmd;\n\tu8 val, drv_sds_rings = adapter->drv_sds_rings;\n\tu8 drv_tx_rings = adapter->drv_tx_rings;\n\tu32 data;\n\tu16 intrpt_id, id;\n\tint ret;\n\n\tif (test_bit(__QLCNIC_RESETTING, &adapter->state)) {\n\t\tnetdev_info(netdev, \"Device is resetting\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tif (qlcnic_get_diag_lock(adapter)) {\n\t\tnetdev_info(netdev, \"Device in diagnostics mode\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tret = qlcnic_83xx_diag_alloc_res(netdev, QLCNIC_INTERRUPT_TEST,\n\t\t\t\t\t drv_sds_rings);\n\tif (ret)\n\t\tgoto fail_diag_irq;\n\n\tahw->diag_cnt = 0;\n\tret = qlcnic_alloc_mbx_args(&cmd, adapter, QLCNIC_CMD_INTRPT_TEST);\n\tif (ret)\n\t\tgoto fail_mbx_args;\n\n\tif (adapter->flags & QLCNIC_MSIX_ENABLED)\n\t\tintrpt_id = ahw->intr_tbl[0].id;\n\telse\n\t\tintrpt_id = QLCRDX(ahw, QLCNIC_DEF_INT_ID);\n\n\tcmd.req.arg[1] = 1;\n\tcmd.req.arg[2] = intrpt_id;\n\tcmd.req.arg[3] = BIT_0;\n\n\tret = qlcnic_issue_cmd(adapter, &cmd);\n\tdata = cmd.rsp.arg[2];\n\tid = LSW(data);\n\tval = LSB(MSW(data));\n\tif (id != intrpt_id)\n\t\tdev_info(&adapter->pdev->dev,\n\t\t\t \"Interrupt generated: 0x%x, requested:0x%x\\n\",\n\t\t\t id, intrpt_id);\n\tif (val)\n\t\tdev_err(&adapter->pdev->dev,\n\t\t\t \"Interrupt test error: 0x%x\\n\", val);\n\tif (ret)\n\t\tgoto done;\n\n\tmsleep(20);\n\tret = !ahw->diag_cnt;\n\ndone:\n\tqlcnic_free_mbx_args(&cmd);\n\nfail_mbx_args:\n\tqlcnic_83xx_diag_free_res(netdev, drv_sds_rings);\n\nfail_diag_irq:\n\tadapter->drv_sds_rings = drv_sds_rings;\n\tadapter->drv_tx_rings = drv_tx_rings;\n\tqlcnic_release_diag_lock(adapter);\n\treturn ret;\n}\n\nvoid qlcnic_83xx_get_pauseparam(struct qlcnic_adapter *adapter,\n\t\t\t\tstruct ethtool_pauseparam *pause)\n{\n\tstruct qlcnic_hardware_context *ahw = adapter->ahw;\n\tint status = 0;\n\tu32 config;\n\n\tstatus = qlcnic_83xx_get_port_config(adapter);\n\tif (status) {\n\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\"%s: Get Pause Config failed\\n\", __func__);\n\t\treturn;\n\t}\n\tconfig = ahw->port_config;\n\tif (config & QLC_83XX_CFG_STD_PAUSE) {\n\t\tswitch (MSW(config)) {\n\t\tcase QLC_83XX_TX_PAUSE:\n\t\t\tpause->tx_pause = 1;\n\t\t\tbreak;\n\t\tcase QLC_83XX_RX_PAUSE:\n\t\t\tpause->rx_pause = 1;\n\t\t\tbreak;\n\t\tcase QLC_83XX_TX_RX_PAUSE:\n\t\tdefault:\n\t\t\t \n\t\t\tpause->tx_pause = 1;\n\t\t\tpause->rx_pause = 1;\n\t\t}\n\t}\n\n\tif (QLC_83XX_AUTONEG(config))\n\t\tpause->autoneg = 1;\n}\n\nint qlcnic_83xx_set_pauseparam(struct qlcnic_adapter *adapter,\n\t\t\t       struct ethtool_pauseparam *pause)\n{\n\tstruct qlcnic_hardware_context *ahw = adapter->ahw;\n\tint status = 0;\n\tu32 config;\n\n\tstatus = qlcnic_83xx_get_port_config(adapter);\n\tif (status) {\n\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\"%s: Get Pause Config failed.\\n\", __func__);\n\t\treturn status;\n\t}\n\tconfig = ahw->port_config;\n\n\tif (ahw->port_type == QLCNIC_GBE) {\n\t\tif (pause->autoneg)\n\t\t\tahw->port_config |= QLC_83XX_ENABLE_AUTONEG;\n\t\tif (!pause->autoneg)\n\t\t\tahw->port_config &= ~QLC_83XX_ENABLE_AUTONEG;\n\t} else if ((ahw->port_type == QLCNIC_XGBE) && (pause->autoneg)) {\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (!(config & QLC_83XX_CFG_STD_PAUSE))\n\t\tahw->port_config |= QLC_83XX_CFG_STD_PAUSE;\n\n\tif (pause->rx_pause && pause->tx_pause) {\n\t\tahw->port_config |= QLC_83XX_CFG_STD_TX_RX_PAUSE;\n\t} else if (pause->rx_pause && !pause->tx_pause) {\n\t\tahw->port_config &= ~QLC_83XX_CFG_STD_TX_PAUSE;\n\t\tahw->port_config |= QLC_83XX_CFG_STD_RX_PAUSE;\n\t} else if (pause->tx_pause && !pause->rx_pause) {\n\t\tahw->port_config &= ~QLC_83XX_CFG_STD_RX_PAUSE;\n\t\tahw->port_config |= QLC_83XX_CFG_STD_TX_PAUSE;\n\t} else if (!pause->rx_pause && !pause->tx_pause) {\n\t\tahw->port_config &= ~(QLC_83XX_CFG_STD_TX_RX_PAUSE |\n\t\t\t\t      QLC_83XX_CFG_STD_PAUSE);\n\t}\n\tstatus = qlcnic_83xx_set_port_config(adapter);\n\tif (status) {\n\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\"%s: Set Pause Config failed.\\n\", __func__);\n\t\tahw->port_config = config;\n\t}\n\treturn status;\n}\n\nstatic int qlcnic_83xx_read_flash_status_reg(struct qlcnic_adapter *adapter)\n{\n\tint ret, err = 0;\n\tu32 temp;\n\n\tqlcnic_83xx_wrt_reg_indirect(adapter, QLC_83XX_FLASH_ADDR,\n\t\t\t\t     QLC_83XX_FLASH_OEM_READ_SIG);\n\tqlcnic_83xx_wrt_reg_indirect(adapter, QLC_83XX_FLASH_CONTROL,\n\t\t\t\t     QLC_83XX_FLASH_READ_CTRL);\n\tret = qlcnic_83xx_poll_flash_status_reg(adapter);\n\tif (ret)\n\t\treturn -EIO;\n\n\ttemp = QLCRD32(adapter, QLC_83XX_FLASH_RDDATA, &err);\n\tif (err == -EIO)\n\t\treturn err;\n\n\treturn temp & 0xFF;\n}\n\nint qlcnic_83xx_flash_test(struct qlcnic_adapter *adapter)\n{\n\tint status;\n\n\tstatus = qlcnic_83xx_read_flash_status_reg(adapter);\n\tif (status == -EIO) {\n\t\tdev_info(&adapter->pdev->dev, \"%s: EEPROM test failed.\\n\",\n\t\t\t __func__);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int qlcnic_83xx_shutdown(struct pci_dev *pdev)\n{\n\tstruct qlcnic_adapter *adapter = pci_get_drvdata(pdev);\n\tstruct net_device *netdev = adapter->netdev;\n\n\tnetif_device_detach(netdev);\n\tqlcnic_cancel_idc_work(adapter);\n\n\tif (netif_running(netdev))\n\t\tqlcnic_down(adapter, netdev);\n\n\tqlcnic_83xx_disable_mbx_intr(adapter);\n\tcancel_delayed_work_sync(&adapter->idc_aen_work);\n\n\treturn pci_save_state(pdev);\n}\n\nstatic int qlcnic_83xx_resume(struct qlcnic_adapter *adapter)\n{\n\tstruct qlcnic_hardware_context *ahw = adapter->ahw;\n\tstruct qlc_83xx_idc *idc = &ahw->idc;\n\tint err = 0;\n\n\terr = qlcnic_83xx_idc_init(adapter);\n\tif (err)\n\t\treturn err;\n\n\tif (ahw->nic_mode == QLCNIC_VNIC_MODE) {\n\t\tif (ahw->op_mode == QLCNIC_MGMT_FUNC) {\n\t\t\tqlcnic_83xx_set_vnic_opmode(adapter);\n\t\t} else {\n\t\t\terr = qlcnic_83xx_check_vnic_state(adapter);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\terr = qlcnic_83xx_idc_reattach_driver(adapter);\n\tif (err)\n\t\treturn err;\n\n\tqlcnic_schedule_work(adapter, qlcnic_83xx_idc_poll_dev_state,\n\t\t\t     idc->delay);\n\treturn err;\n}\n\nvoid qlcnic_83xx_reinit_mbx_work(struct qlcnic_mailbox *mbx)\n{\n\treinit_completion(&mbx->completion);\n\tset_bit(QLC_83XX_MBX_READY, &mbx->status);\n}\n\nvoid qlcnic_83xx_free_mailbox(struct qlcnic_mailbox *mbx)\n{\n\tif (!mbx)\n\t\treturn;\n\n\tdestroy_workqueue(mbx->work_q);\n\tkfree(mbx);\n}\n\nstatic inline void\nqlcnic_83xx_notify_cmd_completion(struct qlcnic_adapter *adapter,\n\t\t\t\t  struct qlcnic_cmd_args *cmd)\n{\n\tatomic_set(&cmd->rsp_status, QLC_83XX_MBX_RESPONSE_ARRIVED);\n\n\tif (cmd->type == QLC_83XX_MBX_CMD_NO_WAIT) {\n\t\tqlcnic_free_mbx_args(cmd);\n\t\tkfree(cmd);\n\t\treturn;\n\t}\n\tcomplete(&cmd->completion);\n}\n\nstatic void qlcnic_83xx_flush_mbx_queue(struct qlcnic_adapter *adapter)\n{\n\tstruct qlcnic_mailbox *mbx = adapter->ahw->mailbox;\n\tstruct list_head *head = &mbx->cmd_q;\n\tstruct qlcnic_cmd_args *cmd = NULL;\n\n\tspin_lock_bh(&mbx->queue_lock);\n\n\twhile (!list_empty(head)) {\n\t\tcmd = list_entry(head->next, struct qlcnic_cmd_args, list);\n\t\tdev_info(&adapter->pdev->dev, \"%s: Mailbox command 0x%x\\n\",\n\t\t\t __func__, cmd->cmd_op);\n\t\tlist_del(&cmd->list);\n\t\tmbx->num_cmds--;\n\t\tqlcnic_83xx_notify_cmd_completion(adapter, cmd);\n\t}\n\n\tspin_unlock_bh(&mbx->queue_lock);\n}\n\nstatic int qlcnic_83xx_check_mbx_status(struct qlcnic_adapter *adapter)\n{\n\tstruct qlcnic_hardware_context *ahw = adapter->ahw;\n\tstruct qlcnic_mailbox *mbx = ahw->mailbox;\n\tu32 host_mbx_ctrl;\n\n\tif (!test_bit(QLC_83XX_MBX_READY, &mbx->status))\n\t\treturn -EBUSY;\n\n\thost_mbx_ctrl = QLCRDX(ahw, QLCNIC_HOST_MBX_CTRL);\n\tif (host_mbx_ctrl) {\n\t\tclear_bit(QLC_83XX_MBX_READY, &mbx->status);\n\t\tahw->idc.collect_dump = 1;\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic inline void qlcnic_83xx_signal_mbx_cmd(struct qlcnic_adapter *adapter,\n\t\t\t\t\t      u8 issue_cmd)\n{\n\tif (issue_cmd)\n\t\tQLCWRX(adapter->ahw, QLCNIC_HOST_MBX_CTRL, QLCNIC_SET_OWNER);\n\telse\n\t\tQLCWRX(adapter->ahw, QLCNIC_FW_MBX_CTRL, QLCNIC_CLR_OWNER);\n}\n\nstatic void qlcnic_83xx_dequeue_mbx_cmd(struct qlcnic_adapter *adapter,\n\t\t\t\t\tstruct qlcnic_cmd_args *cmd)\n{\n\tstruct qlcnic_mailbox *mbx = adapter->ahw->mailbox;\n\n\tspin_lock_bh(&mbx->queue_lock);\n\n\tlist_del(&cmd->list);\n\tmbx->num_cmds--;\n\n\tspin_unlock_bh(&mbx->queue_lock);\n\n\tqlcnic_83xx_notify_cmd_completion(adapter, cmd);\n}\n\nstatic void qlcnic_83xx_encode_mbx_cmd(struct qlcnic_adapter *adapter,\n\t\t\t\t       struct qlcnic_cmd_args *cmd)\n{\n\tu32 mbx_cmd, fw_hal_version, hdr_size, total_size, tmp;\n\tstruct qlcnic_hardware_context *ahw = adapter->ahw;\n\tint i, j;\n\n\tif (cmd->op_type != QLC_83XX_MBX_POST_BC_OP) {\n\t\tmbx_cmd = cmd->req.arg[0];\n\t\twritel(mbx_cmd, QLCNIC_MBX_HOST(ahw, 0));\n\t\tfor (i = 1; i < cmd->req.num; i++)\n\t\t\twritel(cmd->req.arg[i], QLCNIC_MBX_HOST(ahw, i));\n\t} else {\n\t\tfw_hal_version = ahw->fw_hal_version;\n\t\thdr_size = sizeof(struct qlcnic_bc_hdr) / sizeof(u32);\n\t\ttotal_size = cmd->pay_size + hdr_size;\n\t\ttmp = QLCNIC_CMD_BC_EVENT_SETUP | total_size << 16;\n\t\tmbx_cmd = tmp | fw_hal_version << 29;\n\t\twritel(mbx_cmd, QLCNIC_MBX_HOST(ahw, 0));\n\n\t\t \n\t\tmbx_cmd = 0x1 | 1 << 4;\n\n\t\tif (qlcnic_sriov_pf_check(adapter))\n\t\t\tmbx_cmd |= cmd->func_num << 5;\n\n\t\twritel(mbx_cmd, QLCNIC_MBX_HOST(ahw, 1));\n\n\t\tfor (i = 2, j = 0; j < hdr_size; i++, j++)\n\t\t\twritel(*(cmd->hdr++), QLCNIC_MBX_HOST(ahw, i));\n\t\tfor (j = 0; j < cmd->pay_size; j++, i++)\n\t\t\twritel(*(cmd->pay++), QLCNIC_MBX_HOST(ahw, i));\n\t}\n}\n\nvoid qlcnic_83xx_detach_mailbox_work(struct qlcnic_adapter *adapter)\n{\n\tstruct qlcnic_mailbox *mbx = adapter->ahw->mailbox;\n\n\tif (!mbx)\n\t\treturn;\n\n\tclear_bit(QLC_83XX_MBX_READY, &mbx->status);\n\tcomplete(&mbx->completion);\n\tcancel_work_sync(&mbx->work);\n\tflush_workqueue(mbx->work_q);\n\tqlcnic_83xx_flush_mbx_queue(adapter);\n}\n\nstatic int qlcnic_83xx_enqueue_mbx_cmd(struct qlcnic_adapter *adapter,\n\t\t\t\t       struct qlcnic_cmd_args *cmd,\n\t\t\t\t       unsigned long *timeout)\n{\n\tstruct qlcnic_mailbox *mbx = adapter->ahw->mailbox;\n\n\tif (test_bit(QLC_83XX_MBX_READY, &mbx->status)) {\n\t\tatomic_set(&cmd->rsp_status, QLC_83XX_MBX_RESPONSE_WAIT);\n\t\tinit_completion(&cmd->completion);\n\t\tcmd->rsp_opcode = QLC_83XX_MBX_RESPONSE_UNKNOWN;\n\n\t\tspin_lock_bh(&mbx->queue_lock);\n\n\t\tlist_add_tail(&cmd->list, &mbx->cmd_q);\n\t\tmbx->num_cmds++;\n\t\tcmd->total_cmds = mbx->num_cmds;\n\t\t*timeout = cmd->total_cmds * QLC_83XX_MBX_TIMEOUT;\n\t\tqueue_work(mbx->work_q, &mbx->work);\n\n\t\tspin_unlock_bh(&mbx->queue_lock);\n\n\t\treturn 0;\n\t}\n\n\treturn -EBUSY;\n}\n\nstatic int qlcnic_83xx_check_mac_rcode(struct qlcnic_adapter *adapter,\n\t\t\t\t       struct qlcnic_cmd_args *cmd)\n{\n\tu8 mac_cmd_rcode;\n\tu32 fw_data;\n\n\tif (cmd->cmd_op == QLCNIC_CMD_CONFIG_MAC_VLAN) {\n\t\tfw_data = readl(QLCNIC_MBX_FW(adapter->ahw, 2));\n\t\tmac_cmd_rcode = (u8)fw_data;\n\t\tif (mac_cmd_rcode == QLC_83XX_NO_NIC_RESOURCE ||\n\t\t    mac_cmd_rcode == QLC_83XX_MAC_PRESENT ||\n\t\t    mac_cmd_rcode == QLC_83XX_MAC_ABSENT) {\n\t\t\tcmd->rsp_opcode = QLCNIC_RCODE_SUCCESS;\n\t\t\treturn QLCNIC_RCODE_SUCCESS;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic void qlcnic_83xx_decode_mbx_rsp(struct qlcnic_adapter *adapter,\n\t\t\t\t       struct qlcnic_cmd_args *cmd)\n{\n\tstruct qlcnic_hardware_context *ahw = adapter->ahw;\n\tstruct device *dev = &adapter->pdev->dev;\n\tu8 mbx_err_code;\n\tu32 fw_data;\n\n\tfw_data = readl(QLCNIC_MBX_FW(ahw, 0));\n\tmbx_err_code = QLCNIC_MBX_STATUS(fw_data);\n\tqlcnic_83xx_get_mbx_data(adapter, cmd);\n\n\tswitch (mbx_err_code) {\n\tcase QLCNIC_MBX_RSP_OK:\n\tcase QLCNIC_MBX_PORT_RSP_OK:\n\t\tcmd->rsp_opcode = QLCNIC_RCODE_SUCCESS;\n\t\tbreak;\n\tdefault:\n\t\tif (!qlcnic_83xx_check_mac_rcode(adapter, cmd))\n\t\t\tbreak;\n\n\t\tdev_err(dev, \"%s: Mailbox command failed, opcode=0x%x, cmd_type=0x%x, func=0x%x, op_mode=0x%x, error=0x%x\\n\",\n\t\t\t__func__, cmd->cmd_op, cmd->type, ahw->pci_func,\n\t\t\tahw->op_mode, mbx_err_code);\n\t\tcmd->rsp_opcode = QLC_83XX_MBX_RESPONSE_FAILED;\n\t\tqlcnic_dump_mbx(adapter, cmd);\n\t}\n\n\treturn;\n}\n\nstatic inline void qlcnic_dump_mailbox_registers(struct qlcnic_adapter *adapter)\n{\n\tstruct qlcnic_hardware_context *ahw = adapter->ahw;\n\tu32 offset;\n\n\toffset = QLCRDX(ahw, QLCNIC_DEF_INT_MASK);\n\tdev_info(&adapter->pdev->dev, \"Mbx interrupt mask=0x%x, Mbx interrupt enable=0x%x, Host mbx control=0x%x, Fw mbx control=0x%x\",\n\t\t readl(ahw->pci_base0 + offset),\n\t\t QLCRDX(ahw, QLCNIC_MBX_INTR_ENBL),\n\t\t QLCRDX(ahw, QLCNIC_HOST_MBX_CTRL),\n\t\t QLCRDX(ahw, QLCNIC_FW_MBX_CTRL));\n}\n\nstatic void qlcnic_83xx_mailbox_worker(struct work_struct *work)\n{\n\tstruct qlcnic_mailbox *mbx = container_of(work, struct qlcnic_mailbox,\n\t\t\t\t\t\t  work);\n\tstruct qlcnic_adapter *adapter = mbx->adapter;\n\tconst struct qlcnic_mbx_ops *mbx_ops = mbx->ops;\n\tstruct device *dev = &adapter->pdev->dev;\n\tstruct list_head *head = &mbx->cmd_q;\n\tstruct qlcnic_hardware_context *ahw;\n\tstruct qlcnic_cmd_args *cmd = NULL;\n\tunsigned long flags;\n\n\tahw = adapter->ahw;\n\n\twhile (true) {\n\t\tif (qlcnic_83xx_check_mbx_status(adapter)) {\n\t\t\tqlcnic_83xx_flush_mbx_queue(adapter);\n\t\t\treturn;\n\t\t}\n\n\t\tspin_lock_irqsave(&mbx->aen_lock, flags);\n\t\tmbx->rsp_status = QLC_83XX_MBX_RESPONSE_WAIT;\n\t\tspin_unlock_irqrestore(&mbx->aen_lock, flags);\n\n\t\tspin_lock_bh(&mbx->queue_lock);\n\n\t\tif (list_empty(head)) {\n\t\t\tspin_unlock_bh(&mbx->queue_lock);\n\t\t\treturn;\n\t\t}\n\t\tcmd = list_entry(head->next, struct qlcnic_cmd_args, list);\n\n\t\tspin_unlock_bh(&mbx->queue_lock);\n\n\t\tmbx_ops->encode_cmd(adapter, cmd);\n\t\tmbx_ops->nofity_fw(adapter, QLC_83XX_MBX_REQUEST);\n\n\t\tif (wait_for_completion_timeout(&mbx->completion,\n\t\t\t\t\t\tQLC_83XX_MBX_TIMEOUT)) {\n\t\t\tmbx_ops->decode_resp(adapter, cmd);\n\t\t\tmbx_ops->nofity_fw(adapter, QLC_83XX_MBX_COMPLETION);\n\t\t} else {\n\t\t\tdev_err(dev, \"%s: Mailbox command timeout, opcode=0x%x, cmd_type=0x%x, func=0x%x, op_mode=0x%x\\n\",\n\t\t\t\t__func__, cmd->cmd_op, cmd->type, ahw->pci_func,\n\t\t\t\tahw->op_mode);\n\t\t\tclear_bit(QLC_83XX_MBX_READY, &mbx->status);\n\t\t\tqlcnic_dump_mailbox_registers(adapter);\n\t\t\tqlcnic_83xx_get_mbx_data(adapter, cmd);\n\t\t\tqlcnic_dump_mbx(adapter, cmd);\n\t\t\tqlcnic_83xx_idc_request_reset(adapter,\n\t\t\t\t\t\t      QLCNIC_FORCE_FW_DUMP_KEY);\n\t\t\tcmd->rsp_opcode = QLCNIC_RCODE_TIMEOUT;\n\t\t}\n\t\tmbx_ops->dequeue_cmd(adapter, cmd);\n\t}\n}\n\nstatic const struct qlcnic_mbx_ops qlcnic_83xx_mbx_ops = {\n\t.enqueue_cmd    = qlcnic_83xx_enqueue_mbx_cmd,\n\t.dequeue_cmd    = qlcnic_83xx_dequeue_mbx_cmd,\n\t.decode_resp    = qlcnic_83xx_decode_mbx_rsp,\n\t.encode_cmd     = qlcnic_83xx_encode_mbx_cmd,\n\t.nofity_fw      = qlcnic_83xx_signal_mbx_cmd,\n};\n\nint qlcnic_83xx_init_mailbox_work(struct qlcnic_adapter *adapter)\n{\n\tstruct qlcnic_hardware_context *ahw = adapter->ahw;\n\tstruct qlcnic_mailbox *mbx;\n\n\tahw->mailbox = kzalloc(sizeof(*mbx), GFP_KERNEL);\n\tif (!ahw->mailbox)\n\t\treturn -ENOMEM;\n\n\tmbx = ahw->mailbox;\n\tmbx->ops = &qlcnic_83xx_mbx_ops;\n\tmbx->adapter = adapter;\n\n\tspin_lock_init(&mbx->queue_lock);\n\tspin_lock_init(&mbx->aen_lock);\n\tINIT_LIST_HEAD(&mbx->cmd_q);\n\tinit_completion(&mbx->completion);\n\n\tmbx->work_q = create_singlethread_workqueue(\"qlcnic_mailbox\");\n\tif (mbx->work_q == NULL) {\n\t\tkfree(mbx);\n\t\treturn -ENOMEM;\n\t}\n\n\tINIT_WORK(&mbx->work, qlcnic_83xx_mailbox_worker);\n\tset_bit(QLC_83XX_MBX_READY, &mbx->status);\n\treturn 0;\n}\n\nstatic pci_ers_result_t qlcnic_83xx_io_error_detected(struct pci_dev *pdev,\n\t\t\t\t\t\t      pci_channel_state_t state)\n{\n\tstruct qlcnic_adapter *adapter = pci_get_drvdata(pdev);\n\n\tif (state == pci_channel_io_perm_failure)\n\t\treturn PCI_ERS_RESULT_DISCONNECT;\n\n\tif (state == pci_channel_io_normal)\n\t\treturn PCI_ERS_RESULT_RECOVERED;\n\n\tset_bit(__QLCNIC_AER, &adapter->state);\n\tset_bit(__QLCNIC_RESETTING, &adapter->state);\n\n\tqlcnic_83xx_aer_stop_poll_work(adapter);\n\n\tpci_save_state(pdev);\n\tpci_disable_device(pdev);\n\n\treturn PCI_ERS_RESULT_NEED_RESET;\n}\n\nstatic pci_ers_result_t qlcnic_83xx_io_slot_reset(struct pci_dev *pdev)\n{\n\tstruct qlcnic_adapter *adapter = pci_get_drvdata(pdev);\n\tint err = 0;\n\n\tpdev->error_state = pci_channel_io_normal;\n\terr = pci_enable_device(pdev);\n\tif (err)\n\t\tgoto disconnect;\n\n\tpci_set_power_state(pdev, PCI_D0);\n\tpci_set_master(pdev);\n\tpci_restore_state(pdev);\n\n\terr = qlcnic_83xx_aer_reset(adapter);\n\tif (err == 0)\n\t\treturn PCI_ERS_RESULT_RECOVERED;\ndisconnect:\n\tclear_bit(__QLCNIC_AER, &adapter->state);\n\tclear_bit(__QLCNIC_RESETTING, &adapter->state);\n\treturn PCI_ERS_RESULT_DISCONNECT;\n}\n\nstatic void qlcnic_83xx_io_resume(struct pci_dev *pdev)\n{\n\tstruct qlcnic_adapter *adapter = pci_get_drvdata(pdev);\n\n\tif (test_and_clear_bit(__QLCNIC_AER, &adapter->state))\n\t\tqlcnic_83xx_aer_start_poll_work(adapter);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}