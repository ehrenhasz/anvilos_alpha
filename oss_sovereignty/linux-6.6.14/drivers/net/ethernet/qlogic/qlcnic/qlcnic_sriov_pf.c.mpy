{
  "module_name": "qlcnic_sriov_pf.c",
  "hash_id": "61756f237d2c6e301410b9f0bc76ca2a86a64f2832f124252f7b6290de6fba1e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/qlogic/qlcnic/qlcnic_sriov_pf.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n\n#include \"qlcnic_sriov.h\"\n#include \"qlcnic.h\"\n\n#define QLCNIC_SRIOV_VF_MAX_MAC 7\n#define QLC_VF_MIN_TX_RATE\t100\n#define QLC_VF_MAX_TX_RATE\t9999\n#define QLC_MAC_OPCODE_MASK\t0x7\n#define QLC_VF_FLOOD_BIT\tBIT_16\n#define QLC_FLOOD_MODE\t\t0x5\n#define QLC_SRIOV_ALLOW_VLAN0\tBIT_19\n#define QLC_INTR_COAL_TYPE_MASK\t0x7\n\nstatic int qlcnic_sriov_pf_get_vport_handle(struct qlcnic_adapter *, u8);\n\nstruct qlcnic_sriov_cmd_handler {\n\tint (*fn) (struct qlcnic_bc_trans *, struct qlcnic_cmd_args *);\n};\n\nstruct qlcnic_sriov_fw_cmd_handler {\n\tu32 cmd;\n\tint (*fn) (struct qlcnic_bc_trans *, struct qlcnic_cmd_args *);\n};\n\nstatic int qlcnic_sriov_pf_set_vport_info(struct qlcnic_adapter *adapter,\n\t\t\t\t\t  struct qlcnic_info *npar_info,\n\t\t\t\t\t  u16 vport_id)\n{\n\tstruct qlcnic_cmd_args cmd;\n\tint err;\n\n\tif (qlcnic_alloc_mbx_args(&cmd, adapter, QLCNIC_CMD_SET_NIC_INFO))\n\t\treturn -ENOMEM;\n\n\tcmd.req.arg[1] = (vport_id << 16) | 0x1;\n\tcmd.req.arg[2] = npar_info->bit_offsets;\n\tcmd.req.arg[2] |= npar_info->min_tx_bw << 16;\n\tcmd.req.arg[3] = npar_info->max_tx_bw | (npar_info->max_tx_ques << 16);\n\tcmd.req.arg[4] = npar_info->max_tx_mac_filters;\n\tcmd.req.arg[4] |= npar_info->max_rx_mcast_mac_filters << 16;\n\tcmd.req.arg[5] = npar_info->max_rx_ucast_mac_filters |\n\t\t\t (npar_info->max_rx_ip_addr << 16);\n\tcmd.req.arg[6] = npar_info->max_rx_lro_flow |\n\t\t\t (npar_info->max_rx_status_rings << 16);\n\tcmd.req.arg[7] = npar_info->max_rx_buf_rings |\n\t\t\t (npar_info->max_rx_ques << 16);\n\tcmd.req.arg[8] = npar_info->max_tx_vlan_keys;\n\tcmd.req.arg[8] |= npar_info->max_local_ipv6_addrs << 16;\n\tcmd.req.arg[9] = npar_info->max_remote_ipv6_addrs;\n\n\terr = qlcnic_issue_cmd(adapter, &cmd);\n\tif (err)\n\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\"Failed to set vport info, err=%d\\n\", err);\n\n\tqlcnic_free_mbx_args(&cmd);\n\treturn err;\n}\n\nstatic int qlcnic_sriov_pf_cal_res_limit(struct qlcnic_adapter *adapter,\n\t\t\t\t\t struct qlcnic_info *info, u16 func)\n{\n\tstruct qlcnic_sriov *sriov = adapter->ahw->sriov;\n\tstruct qlcnic_resources *res = &sriov->ff_max;\n\tu16 num_macs = sriov->num_allowed_vlans + 1;\n\tint ret = -EIO, vpid, id;\n\tstruct qlcnic_vport *vp;\n\tu32 num_vfs, max, temp;\n\n\tvpid = qlcnic_sriov_pf_get_vport_handle(adapter, func);\n\tif (vpid < 0)\n\t\treturn -EINVAL;\n\n\tnum_vfs = sriov->num_vfs;\n\tmax = num_vfs + 1;\n\tinfo->bit_offsets = 0xffff;\n\tinfo->max_tx_ques = res->num_tx_queues / max;\n\n\tif (qlcnic_83xx_pf_check(adapter))\n\t\tnum_macs = QLCNIC_83XX_SRIOV_VF_MAX_MAC;\n\n\tinfo->max_rx_mcast_mac_filters = res->num_rx_mcast_mac_filters;\n\n\tif (adapter->ahw->pci_func == func) {\n\t\tinfo->min_tx_bw = 0;\n\t\tinfo->max_tx_bw = MAX_BW;\n\n\t\ttemp = res->num_rx_ucast_mac_filters - num_macs * num_vfs;\n\t\tinfo->max_rx_ucast_mac_filters = temp;\n\t\ttemp = res->num_tx_mac_filters - num_macs * num_vfs;\n\t\tinfo->max_tx_mac_filters = temp;\n\t\ttemp = num_macs * num_vfs * QLCNIC_SRIOV_VF_MAX_MAC;\n\t\ttemp = res->num_rx_mcast_mac_filters - temp;\n\t\tinfo->max_rx_mcast_mac_filters = temp;\n\n\t\tinfo->max_tx_ques = res->num_tx_queues - sriov->num_vfs;\n\t} else {\n\t\tid = qlcnic_sriov_func_to_index(adapter, func);\n\t\tif (id < 0)\n\t\t\treturn id;\n\t\tvp = sriov->vf_info[id].vp;\n\t\tinfo->min_tx_bw = vp->min_tx_bw;\n\t\tinfo->max_tx_bw = vp->max_tx_bw;\n\n\t\tinfo->max_rx_ucast_mac_filters = num_macs;\n\t\tinfo->max_tx_mac_filters = num_macs;\n\t\ttemp = num_macs * QLCNIC_SRIOV_VF_MAX_MAC;\n\t\tinfo->max_rx_mcast_mac_filters = temp;\n\n\t\tinfo->max_tx_ques = QLCNIC_SINGLE_RING;\n\t}\n\n\tinfo->max_rx_ip_addr = res->num_destip / max;\n\tinfo->max_rx_status_rings = res->num_rx_status_rings / max;\n\tinfo->max_rx_buf_rings = res->num_rx_buf_rings / max;\n\tinfo->max_rx_ques = res->num_rx_queues / max;\n\tinfo->max_rx_lro_flow = res->num_lro_flows_supported / max;\n\tinfo->max_tx_vlan_keys = res->num_txvlan_keys;\n\tinfo->max_local_ipv6_addrs = res->max_local_ipv6_addrs;\n\tinfo->max_remote_ipv6_addrs = res->max_remote_ipv6_addrs;\n\n\tret = qlcnic_sriov_pf_set_vport_info(adapter, info, vpid);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic void qlcnic_sriov_pf_set_ff_max_res(struct qlcnic_adapter *adapter,\n\t\t\t\t\t   struct qlcnic_info *info)\n{\n\tstruct qlcnic_resources *ff_max = &adapter->ahw->sriov->ff_max;\n\n\tff_max->num_tx_mac_filters = info->max_tx_mac_filters;\n\tff_max->num_rx_ucast_mac_filters = info->max_rx_ucast_mac_filters;\n\tff_max->num_rx_mcast_mac_filters = info->max_rx_mcast_mac_filters;\n\tff_max->num_txvlan_keys = info->max_tx_vlan_keys;\n\tff_max->num_rx_queues = info->max_rx_ques;\n\tff_max->num_tx_queues = info->max_tx_ques;\n\tff_max->num_lro_flows_supported = info->max_rx_lro_flow;\n\tff_max->num_destip = info->max_rx_ip_addr;\n\tff_max->num_rx_buf_rings = info->max_rx_buf_rings;\n\tff_max->num_rx_status_rings = info->max_rx_status_rings;\n\tff_max->max_remote_ipv6_addrs = info->max_remote_ipv6_addrs;\n\tff_max->max_local_ipv6_addrs = info->max_local_ipv6_addrs;\n}\n\nstatic void qlcnic_sriov_set_vf_max_vlan(struct qlcnic_adapter *adapter,\n\t\t\t\t\t struct qlcnic_info *npar_info)\n{\n\tstruct qlcnic_sriov *sriov = adapter->ahw->sriov;\n\tint temp, total_fn;\n\n\ttemp = npar_info->max_rx_mcast_mac_filters;\n\ttotal_fn = sriov->num_vfs + 1;\n\n\ttemp = temp / (QLCNIC_SRIOV_VF_MAX_MAC * total_fn);\n\tsriov->num_allowed_vlans = temp - 1;\n\n\tif (qlcnic_83xx_pf_check(adapter))\n\t\tsriov->num_allowed_vlans = 1;\n\n\tnetdev_info(adapter->netdev, \"Max Guest VLANs supported per VF = %d\\n\",\n\t\t    sriov->num_allowed_vlans);\n}\n\nstatic int qlcnic_sriov_get_pf_info(struct qlcnic_adapter *adapter,\n\t\t\t\t    struct qlcnic_info *npar_info)\n{\n\tint err;\n\tstruct qlcnic_cmd_args cmd;\n\n\tif (qlcnic_alloc_mbx_args(&cmd, adapter, QLCNIC_CMD_GET_NIC_INFO))\n\t\treturn -ENOMEM;\n\n\tcmd.req.arg[1] = 0x2;\n\terr = qlcnic_issue_cmd(adapter, &cmd);\n\tif (err) {\n\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\"Failed to get PF info, err=%d\\n\", err);\n\t\tgoto out;\n\t}\n\n\tnpar_info->total_pf = cmd.rsp.arg[2] & 0xff;\n\tnpar_info->total_rss_engines = (cmd.rsp.arg[2] >> 8) & 0xff;\n\tnpar_info->max_vports = MSW(cmd.rsp.arg[2]);\n\tnpar_info->max_tx_ques =  LSW(cmd.rsp.arg[3]);\n\tnpar_info->max_tx_mac_filters = MSW(cmd.rsp.arg[3]);\n\tnpar_info->max_rx_mcast_mac_filters = LSW(cmd.rsp.arg[4]);\n\tnpar_info->max_rx_ucast_mac_filters = MSW(cmd.rsp.arg[4]);\n\tnpar_info->max_rx_ip_addr = LSW(cmd.rsp.arg[5]);\n\tnpar_info->max_rx_lro_flow = MSW(cmd.rsp.arg[5]);\n\tnpar_info->max_rx_status_rings = LSW(cmd.rsp.arg[6]);\n\tnpar_info->max_rx_buf_rings = MSW(cmd.rsp.arg[6]);\n\tnpar_info->max_rx_ques = LSW(cmd.rsp.arg[7]);\n\tnpar_info->max_tx_vlan_keys = MSW(cmd.rsp.arg[7]);\n\tnpar_info->max_local_ipv6_addrs = LSW(cmd.rsp.arg[8]);\n\tnpar_info->max_remote_ipv6_addrs = MSW(cmd.rsp.arg[8]);\n\n\tqlcnic_sriov_set_vf_max_vlan(adapter, npar_info);\n\tqlcnic_sriov_pf_set_ff_max_res(adapter, npar_info);\n\tdev_info(&adapter->pdev->dev,\n\t\t \"\\n\\ttotal_pf: %d,\\n\"\n\t\t \"\\n\\ttotal_rss_engines: %d max_vports: %d max_tx_ques %d,\\n\"\n\t\t \"\\tmax_tx_mac_filters: %d max_rx_mcast_mac_filters: %d,\\n\"\n\t\t \"\\tmax_rx_ucast_mac_filters: 0x%x, max_rx_ip_addr: %d,\\n\"\n\t\t \"\\tmax_rx_lro_flow: %d max_rx_status_rings: %d,\\n\"\n\t\t \"\\tmax_rx_buf_rings: %d, max_rx_ques: %d, max_tx_vlan_keys %d\\n\"\n\t\t \"\\tmax_local_ipv6_addrs: %d, max_remote_ipv6_addrs: %d\\n\",\n\t\t npar_info->total_pf, npar_info->total_rss_engines,\n\t\t npar_info->max_vports, npar_info->max_tx_ques,\n\t\t npar_info->max_tx_mac_filters,\n\t\t npar_info->max_rx_mcast_mac_filters,\n\t\t npar_info->max_rx_ucast_mac_filters, npar_info->max_rx_ip_addr,\n\t\t npar_info->max_rx_lro_flow, npar_info->max_rx_status_rings,\n\t\t npar_info->max_rx_buf_rings, npar_info->max_rx_ques,\n\t\t npar_info->max_tx_vlan_keys, npar_info->max_local_ipv6_addrs,\n\t\t npar_info->max_remote_ipv6_addrs);\n\nout:\n\tqlcnic_free_mbx_args(&cmd);\n\treturn err;\n}\n\nstatic void qlcnic_sriov_pf_reset_vport_handle(struct qlcnic_adapter *adapter,\n\t\t\t\t\t       u8 func)\n{\n\tstruct qlcnic_sriov  *sriov = adapter->ahw->sriov;\n\tstruct qlcnic_vport *vp;\n\tint index;\n\n\tif (adapter->ahw->pci_func == func) {\n\t\tsriov->vp_handle = 0;\n\t} else {\n\t\tindex = qlcnic_sriov_func_to_index(adapter, func);\n\t\tif (index < 0)\n\t\t\treturn;\n\t\tvp = sriov->vf_info[index].vp;\n\t\tvp->handle = 0;\n\t}\n}\n\nstatic void qlcnic_sriov_pf_set_vport_handle(struct qlcnic_adapter *adapter,\n\t\t\t\t\t     u16 vport_handle, u8 func)\n{\n\tstruct qlcnic_sriov  *sriov = adapter->ahw->sriov;\n\tstruct qlcnic_vport *vp;\n\tint index;\n\n\tif (adapter->ahw->pci_func == func) {\n\t\tsriov->vp_handle = vport_handle;\n\t} else {\n\t\tindex = qlcnic_sriov_func_to_index(adapter, func);\n\t\tif (index < 0)\n\t\t\treturn;\n\t\tvp = sriov->vf_info[index].vp;\n\t\tvp->handle = vport_handle;\n\t}\n}\n\nstatic int qlcnic_sriov_pf_get_vport_handle(struct qlcnic_adapter *adapter,\n\t\t\t\t\t    u8 func)\n{\n\tstruct qlcnic_sriov  *sriov = adapter->ahw->sriov;\n\tstruct qlcnic_vf_info *vf_info;\n\tint index;\n\n\tif (adapter->ahw->pci_func == func) {\n\t\treturn sriov->vp_handle;\n\t} else {\n\t\tindex = qlcnic_sriov_func_to_index(adapter, func);\n\t\tif (index >= 0) {\n\t\t\tvf_info = &sriov->vf_info[index];\n\t\t\treturn vf_info->vp->handle;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int qlcnic_sriov_pf_config_vport(struct qlcnic_adapter *adapter,\n\t\t\t\t\tu8 flag, u16 func)\n{\n\tstruct qlcnic_cmd_args cmd;\n\tint ret;\n\tint vpid;\n\n\tif (qlcnic_alloc_mbx_args(&cmd, adapter, QLCNIC_CMD_CONFIG_VPORT))\n\t\treturn -ENOMEM;\n\n\tif (flag) {\n\t\tcmd.req.arg[3] = func << 8;\n\t} else {\n\t\tvpid = qlcnic_sriov_pf_get_vport_handle(adapter, func);\n\t\tif (vpid < 0) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tcmd.req.arg[3] = ((vpid & 0xffff) << 8) | 1;\n\t}\n\n\tret = qlcnic_issue_cmd(adapter, &cmd);\n\tif (ret) {\n\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\"Failed %s vport, err %d for func 0x%x\\n\",\n\t\t\t(flag ? \"enable\" : \"disable\"), ret, func);\n\t\tgoto out;\n\t}\n\n\tif (flag) {\n\t\tvpid = cmd.rsp.arg[2] & 0xffff;\n\t\tqlcnic_sriov_pf_set_vport_handle(adapter, vpid, func);\n\t} else {\n\t\tqlcnic_sriov_pf_reset_vport_handle(adapter, func);\n\t}\n\nout:\n\tqlcnic_free_mbx_args(&cmd);\n\treturn ret;\n}\n\nstatic int qlcnic_sriov_pf_cfg_vlan_filtering(struct qlcnic_adapter *adapter,\n\t\t\t\t\t      u8 enable)\n{\n\tstruct qlcnic_cmd_args cmd;\n\tint err;\n\n\terr = qlcnic_alloc_mbx_args(&cmd, adapter, QLCNIC_CMD_SET_NIC_INFO);\n\tif (err)\n\t\treturn err;\n\n\tcmd.req.arg[1] = 0x4;\n\tif (enable) {\n\t\tadapter->flags |= QLCNIC_VLAN_FILTERING;\n\t\tcmd.req.arg[1] |= BIT_16;\n\t\tif (qlcnic_84xx_check(adapter))\n\t\t\tcmd.req.arg[1] |= QLC_SRIOV_ALLOW_VLAN0;\n\t} else {\n\t\tadapter->flags &= ~QLCNIC_VLAN_FILTERING;\n\t}\n\n\terr = qlcnic_issue_cmd(adapter, &cmd);\n\tif (err)\n\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\"Failed to configure VLAN filtering, err=%d\\n\", err);\n\n\tqlcnic_free_mbx_args(&cmd);\n\treturn err;\n}\n\n \nstatic int qlcnic_sriov_pf_cfg_flood(struct qlcnic_adapter *adapter)\n{\n\tstruct qlcnic_cmd_args cmd;\n\tint err;\n\n\terr = qlcnic_alloc_mbx_args(&cmd, adapter, QLCNIC_CMD_SET_NIC_INFO);\n\tif (err)\n\t\treturn err;\n\n\tcmd.req.arg[1] = QLC_FLOOD_MODE | QLC_VF_FLOOD_BIT;\n\n\terr = qlcnic_issue_cmd(adapter, &cmd);\n\tif (err)\n\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\"Failed to configure VF Flood bit on PF, err=%d\\n\",\n\t\t\terr);\n\n\tqlcnic_free_mbx_args(&cmd);\n\treturn err;\n}\n\nstatic int qlcnic_sriov_pf_cfg_eswitch(struct qlcnic_adapter *adapter,\n\t\t\t\t       u8 func, u8 enable)\n{\n\tstruct qlcnic_cmd_args cmd;\n\tint err = -EIO;\n\n\tif (qlcnic_alloc_mbx_args(&cmd, adapter, QLCNIC_CMD_TOGGLE_ESWITCH))\n\t\treturn -ENOMEM;\n\n\tcmd.req.arg[0] |= (3 << 29);\n\tcmd.req.arg[1] = ((func & 0xf) << 2) | BIT_6 | BIT_1;\n\tif (enable)\n\t\tcmd.req.arg[1] |= BIT_0;\n\n\terr = qlcnic_issue_cmd(adapter, &cmd);\n\n\tif (err != QLCNIC_RCODE_SUCCESS) {\n\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\"Failed to enable sriov eswitch%d\\n\", err);\n\t\terr = -EIO;\n\t}\n\n\tqlcnic_free_mbx_args(&cmd);\n\treturn err;\n}\n\nstatic void qlcnic_sriov_pf_del_flr_queue(struct qlcnic_adapter *adapter)\n{\n\tstruct qlcnic_sriov *sriov = adapter->ahw->sriov;\n\tstruct qlcnic_back_channel *bc = &sriov->bc;\n\tint i;\n\n\tfor (i = 0; i < sriov->num_vfs; i++)\n\t\tcancel_work_sync(&sriov->vf_info[i].flr_work);\n\n\tdestroy_workqueue(bc->bc_flr_wq);\n}\n\nstatic int qlcnic_sriov_pf_create_flr_queue(struct qlcnic_adapter *adapter)\n{\n\tstruct qlcnic_back_channel *bc = &adapter->ahw->sriov->bc;\n\tstruct workqueue_struct *wq;\n\n\twq = create_singlethread_workqueue(\"qlcnic-flr\");\n\tif (wq == NULL) {\n\t\tdev_err(&adapter->pdev->dev, \"Cannot create FLR workqueue\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tbc->bc_flr_wq =  wq;\n\treturn 0;\n}\n\nvoid qlcnic_sriov_pf_cleanup(struct qlcnic_adapter *adapter)\n{\n\tu8 func = adapter->ahw->pci_func;\n\n\tif (!qlcnic_sriov_enable_check(adapter))\n\t\treturn;\n\n\tqlcnic_sriov_pf_del_flr_queue(adapter);\n\tqlcnic_sriov_cfg_bc_intr(adapter, 0);\n\tqlcnic_sriov_pf_config_vport(adapter, 0, func);\n\tqlcnic_sriov_pf_cfg_eswitch(adapter, func, 0);\n\tqlcnic_sriov_pf_cfg_vlan_filtering(adapter, 0);\n\t__qlcnic_sriov_cleanup(adapter);\n\tadapter->ahw->op_mode = QLCNIC_MGMT_FUNC;\n\tclear_bit(__QLCNIC_SRIOV_ENABLE, &adapter->state);\n}\n\nvoid qlcnic_sriov_pf_disable(struct qlcnic_adapter *adapter)\n{\n\tif (!qlcnic_sriov_pf_check(adapter))\n\t\treturn;\n\n\tif (!qlcnic_sriov_enable_check(adapter))\n\t\treturn;\n\n\tpci_disable_sriov(adapter->pdev);\n\tnetdev_info(adapter->netdev,\n\t\t    \"SR-IOV is disabled successfully on port %d\\n\",\n\t\t    adapter->portnum);\n}\n\nstatic int qlcnic_pci_sriov_disable(struct qlcnic_adapter *adapter)\n{\n\tstruct net_device *netdev = adapter->netdev;\n\n\tif (pci_vfs_assigned(adapter->pdev)) {\n\t\tnetdev_err(adapter->netdev,\n\t\t\t   \"SR-IOV VFs belonging to port %d are assigned to VMs. SR-IOV can not be disabled on this port\\n\",\n\t\t\t   adapter->portnum);\n\t\tnetdev_info(adapter->netdev,\n\t\t\t    \"Please detach SR-IOV VFs belonging to port %d from VMs, and then try to disable SR-IOV on this port\\n\",\n\t\t\t    adapter->portnum);\n\t\treturn -EPERM;\n\t}\n\n\tqlcnic_sriov_pf_disable(adapter);\n\n\trtnl_lock();\n\tif (netif_running(netdev))\n\t\t__qlcnic_down(adapter, netdev);\n\n\tqlcnic_sriov_free_vlans(adapter);\n\n\tqlcnic_sriov_pf_cleanup(adapter);\n\n\t \n\tif (qlcnic_83xx_configure_opmode(adapter)) {\n\t\trtnl_unlock();\n\t\treturn -EIO;\n\t}\n\n\tif (netif_running(netdev))\n\t\t__qlcnic_up(adapter, netdev);\n\n\trtnl_unlock();\n\treturn 0;\n}\n\nstatic int qlcnic_sriov_pf_init(struct qlcnic_adapter *adapter)\n{\n\tstruct qlcnic_hardware_context *ahw = adapter->ahw;\n\tstruct qlcnic_info nic_info, pf_info, vp_info;\n\tint err;\n\tu8 func = ahw->pci_func;\n\n\tif (!qlcnic_sriov_enable_check(adapter))\n\t\treturn 0;\n\n\terr = qlcnic_sriov_pf_cfg_vlan_filtering(adapter, 1);\n\tif (err)\n\t\treturn err;\n\n\tif (qlcnic_84xx_check(adapter)) {\n\t\terr = qlcnic_sriov_pf_cfg_flood(adapter);\n\t\tif (err)\n\t\t\tgoto disable_vlan_filtering;\n\t}\n\n\terr = qlcnic_sriov_pf_cfg_eswitch(adapter, func, 1);\n\tif (err)\n\t\tgoto disable_vlan_filtering;\n\n\terr = qlcnic_sriov_pf_config_vport(adapter, 1, func);\n\tif (err)\n\t\tgoto disable_eswitch;\n\n\terr = qlcnic_sriov_get_pf_info(adapter, &pf_info);\n\tif (err)\n\t\tgoto delete_vport;\n\n\terr = qlcnic_get_nic_info(adapter, &nic_info, func);\n\tif (err)\n\t\tgoto delete_vport;\n\n\terr = qlcnic_sriov_pf_cal_res_limit(adapter, &vp_info, func);\n\tif (err)\n\t\tgoto delete_vport;\n\n\terr = qlcnic_sriov_cfg_bc_intr(adapter, 1);\n\tif (err)\n\t\tgoto delete_vport;\n\n\tahw->physical_port = (u8) nic_info.phys_port;\n\tahw->switch_mode = nic_info.switch_mode;\n\tahw->max_mtu = nic_info.max_mtu;\n\tahw->capabilities = nic_info.capabilities;\n\tahw->nic_mode = QLC_83XX_SRIOV_MODE;\n\treturn err;\n\ndelete_vport:\n\tqlcnic_sriov_pf_config_vport(adapter, 0, func);\n\ndisable_eswitch:\n\tqlcnic_sriov_pf_cfg_eswitch(adapter, func, 0);\n\ndisable_vlan_filtering:\n\tqlcnic_sriov_pf_cfg_vlan_filtering(adapter, 0);\n\n\treturn err;\n}\n\nstatic int qlcnic_sriov_pf_enable(struct qlcnic_adapter *adapter, int num_vfs)\n{\n\tint err;\n\n\tif (!qlcnic_sriov_enable_check(adapter))\n\t\treturn 0;\n\n\terr = pci_enable_sriov(adapter->pdev, num_vfs);\n\tif (err)\n\t\tqlcnic_sriov_pf_cleanup(adapter);\n\n\treturn err;\n}\n\nstatic int __qlcnic_pci_sriov_enable(struct qlcnic_adapter *adapter,\n\t\t\t\t     int num_vfs)\n{\n\tint err = 0;\n\n\tset_bit(__QLCNIC_SRIOV_ENABLE, &adapter->state);\n\tadapter->ahw->op_mode = QLCNIC_SRIOV_PF_FUNC;\n\n\terr = qlcnic_sriov_init(adapter, num_vfs);\n\tif (err)\n\t\tgoto clear_op_mode;\n\n\terr = qlcnic_sriov_pf_create_flr_queue(adapter);\n\tif (err)\n\t\tgoto sriov_cleanup;\n\n\terr = qlcnic_sriov_pf_init(adapter);\n\tif (err)\n\t\tgoto del_flr_queue;\n\n\terr = qlcnic_sriov_alloc_vlans(adapter);\n\tif (err)\n\t\tgoto del_flr_queue;\n\n\treturn err;\n\ndel_flr_queue:\n\tqlcnic_sriov_pf_del_flr_queue(adapter);\n\nsriov_cleanup:\n\t__qlcnic_sriov_cleanup(adapter);\n\nclear_op_mode:\n\tclear_bit(__QLCNIC_SRIOV_ENABLE, &adapter->state);\n\tadapter->ahw->op_mode = QLCNIC_MGMT_FUNC;\n\treturn err;\n}\n\nstatic int qlcnic_pci_sriov_enable(struct qlcnic_adapter *adapter, int num_vfs)\n{\n\tstruct net_device *netdev = adapter->netdev;\n\tint err;\n\n\tif (!(adapter->flags & QLCNIC_MSIX_ENABLED)) {\n\t\tnetdev_err(netdev,\n\t\t\t   \"SR-IOV cannot be enabled, when legacy interrupts are enabled\\n\");\n\t\treturn -EIO;\n\t}\n\n\trtnl_lock();\n\tif (netif_running(netdev))\n\t\t__qlcnic_down(adapter, netdev);\n\n\terr = __qlcnic_pci_sriov_enable(adapter, num_vfs);\n\tif (err)\n\t\tgoto error;\n\n\tif (netif_running(netdev))\n\t\t__qlcnic_up(adapter, netdev);\n\n\trtnl_unlock();\n\terr = qlcnic_sriov_pf_enable(adapter, num_vfs);\n\tif (!err) {\n\t\tnetdev_info(netdev,\n\t\t\t    \"SR-IOV is enabled successfully on port %d\\n\",\n\t\t\t    adapter->portnum);\n\t\t \n\t\treturn num_vfs;\n\t}\n\n\trtnl_lock();\n\tif (netif_running(netdev))\n\t\t__qlcnic_down(adapter, netdev);\n\nerror:\n\tif (!qlcnic_83xx_configure_opmode(adapter)) {\n\t\tif (netif_running(netdev))\n\t\t\t__qlcnic_up(adapter, netdev);\n\t}\n\n\trtnl_unlock();\n\tnetdev_info(netdev, \"Failed to enable SR-IOV on port %d\\n\",\n\t\t    adapter->portnum);\n\n\treturn err;\n}\n\nint qlcnic_pci_sriov_configure(struct pci_dev *dev, int num_vfs)\n{\n\tstruct qlcnic_adapter *adapter = pci_get_drvdata(dev);\n\tint err;\n\n\tif (test_and_set_bit(__QLCNIC_RESETTING, &adapter->state))\n\t\treturn -EBUSY;\n\n\tif (num_vfs == 0)\n\t\terr = qlcnic_pci_sriov_disable(adapter);\n\telse\n\t\terr = qlcnic_pci_sriov_enable(adapter, num_vfs);\n\n\tclear_bit(__QLCNIC_RESETTING, &adapter->state);\n\treturn err;\n}\n\nstatic int qlcnic_sriov_set_vf_acl(struct qlcnic_adapter *adapter, u8 func)\n{\n\tstruct qlcnic_cmd_args cmd;\n\tstruct qlcnic_vport *vp;\n\tint err, id;\n\tu8 *mac;\n\n\tid = qlcnic_sriov_func_to_index(adapter, func);\n\tif (id < 0)\n\t\treturn id;\n\n\tvp = adapter->ahw->sriov->vf_info[id].vp;\n\terr = qlcnic_alloc_mbx_args(&cmd, adapter, QLCNIC_CMD_SET_NIC_INFO);\n\tif (err)\n\t\treturn err;\n\n\tcmd.req.arg[1] = 0x3 | func << 16;\n\tif (vp->spoofchk == true) {\n\t\tmac = vp->mac;\n\t\tcmd.req.arg[2] |= BIT_1 | BIT_3 | BIT_8;\n\t\tcmd.req.arg[4] = mac[5] | mac[4] << 8 | mac[3] << 16 |\n\t\t\t\t mac[2] << 24;\n\t\tcmd.req.arg[5] = mac[1] | mac[0] << 8;\n\t}\n\n\tif (vp->vlan_mode == QLC_PVID_MODE) {\n\t\tcmd.req.arg[2] |= BIT_6;\n\t\tcmd.req.arg[3] |= vp->pvid << 8;\n\t}\n\n\terr = qlcnic_issue_cmd(adapter, &cmd);\n\tif (err)\n\t\tdev_err(&adapter->pdev->dev, \"Failed to set ACL, err=%d\\n\",\n\t\t\terr);\n\n\tqlcnic_free_mbx_args(&cmd);\n\treturn err;\n}\n\nstatic int qlcnic_sriov_set_vf_vport_info(struct qlcnic_adapter *adapter,\n\t\t\t\t\t  u16 func)\n{\n\tstruct qlcnic_info defvp_info;\n\tint err;\n\n\terr = qlcnic_sriov_pf_cal_res_limit(adapter, &defvp_info, func);\n\tif (err)\n\t\treturn -EIO;\n\n\terr = qlcnic_sriov_set_vf_acl(adapter, func);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic int qlcnic_sriov_pf_channel_cfg_cmd(struct qlcnic_bc_trans *trans,\n\t\t\t\t\t   struct qlcnic_cmd_args *cmd)\n{\n\tstruct qlcnic_vf_info *vf = trans->vf;\n\tstruct qlcnic_vport *vp = vf->vp;\n\tstruct qlcnic_adapter *adapter;\n\tstruct qlcnic_sriov *sriov;\n\tu16 func = vf->pci_func;\n\tsize_t size;\n\tint err;\n\n\tadapter = vf->adapter;\n\tsriov = adapter->ahw->sriov;\n\n\tif (trans->req_hdr->cmd_op == QLCNIC_BC_CMD_CHANNEL_INIT) {\n\t\terr = qlcnic_sriov_pf_config_vport(adapter, 1, func);\n\t\tif (!err) {\n\t\t\terr = qlcnic_sriov_set_vf_vport_info(adapter, func);\n\t\t\tif (err)\n\t\t\t\tqlcnic_sriov_pf_config_vport(adapter, 0, func);\n\t\t}\n\t} else {\n\t\tif (vp->vlan_mode == QLC_GUEST_VLAN_MODE) {\n\t\t\tsize = sizeof(*vf->sriov_vlans);\n\t\t\tsize = size * sriov->num_allowed_vlans;\n\t\t\tmemset(vf->sriov_vlans, 0, size);\n\t\t}\n\n\t\terr = qlcnic_sriov_pf_config_vport(adapter, 0, func);\n\t}\n\n\tif (err)\n\t\tgoto err_out;\n\n\tcmd->rsp.arg[0] |= (1 << 25);\n\n\tif (trans->req_hdr->cmd_op == QLCNIC_BC_CMD_CHANNEL_INIT)\n\t\tset_bit(QLC_BC_VF_STATE, &vf->state);\n\telse\n\t\tclear_bit(QLC_BC_VF_STATE, &vf->state);\n\n\treturn err;\n\nerr_out:\n\tcmd->rsp.arg[0] |= (2 << 25);\n\treturn err;\n}\n\nstatic int qlcnic_sriov_cfg_vf_def_mac(struct qlcnic_adapter *adapter,\n\t\t\t\t       struct qlcnic_vf_info *vf,\n\t\t\t\t       u16 vlan, u8 op)\n{\n\tstruct qlcnic_cmd_args *cmd;\n\tstruct qlcnic_macvlan_mbx mv;\n\tstruct qlcnic_vport *vp;\n\tu8 *addr;\n\tint err;\n\tu32 *buf;\n\tint vpid;\n\n\tvp = vf->vp;\n\n\tcmd = kzalloc(sizeof(*cmd), GFP_ATOMIC);\n\tif (!cmd)\n\t\treturn -ENOMEM;\n\n\terr = qlcnic_alloc_mbx_args(cmd, adapter, QLCNIC_CMD_CONFIG_MAC_VLAN);\n\tif (err)\n\t\tgoto free_cmd;\n\n\tcmd->type = QLC_83XX_MBX_CMD_NO_WAIT;\n\tvpid = qlcnic_sriov_pf_get_vport_handle(adapter, vf->pci_func);\n\tif (vpid < 0) {\n\t\terr = -EINVAL;\n\t\tgoto free_args;\n\t}\n\n\tif (vlan)\n\t\top = ((op == QLCNIC_MAC_ADD || op == QLCNIC_MAC_VLAN_ADD) ?\n\t\t      QLCNIC_MAC_VLAN_ADD : QLCNIC_MAC_VLAN_DEL);\n\n\tcmd->req.arg[1] = op | (1 << 8) | (3 << 6);\n\tcmd->req.arg[1] |= ((vpid & 0xffff) << 16) | BIT_31;\n\n\taddr = vp->mac;\n\tmv.vlan = vlan;\n\tmv.mac_addr0 = addr[0];\n\tmv.mac_addr1 = addr[1];\n\tmv.mac_addr2 = addr[2];\n\tmv.mac_addr3 = addr[3];\n\tmv.mac_addr4 = addr[4];\n\tmv.mac_addr5 = addr[5];\n\tbuf = &cmd->req.arg[2];\n\tmemcpy(buf, &mv, sizeof(struct qlcnic_macvlan_mbx));\n\n\terr = qlcnic_issue_cmd(adapter, cmd);\n\n\tif (!err)\n\t\treturn err;\n\nfree_args:\n\tqlcnic_free_mbx_args(cmd);\nfree_cmd:\n\tkfree(cmd);\n\treturn err;\n}\n\nstatic int qlcnic_sriov_validate_create_rx_ctx(struct qlcnic_cmd_args *cmd)\n{\n\tif ((cmd->req.arg[0] >> 29) != 0x3)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic void qlcnic_83xx_cfg_default_mac_vlan(struct qlcnic_adapter *adapter,\n\t\t\t\t\t     struct qlcnic_vf_info *vf,\n\t\t\t\t\t     int opcode)\n{\n\tstruct qlcnic_sriov *sriov;\n\tu16 vlan;\n\tint i;\n\n\tsriov = adapter->ahw->sriov;\n\n\tspin_lock_bh(&vf->vlan_list_lock);\n\tif (vf->num_vlan) {\n\t\tfor (i = 0; i < sriov->num_allowed_vlans; i++) {\n\t\t\tvlan = vf->sriov_vlans[i];\n\t\t\tif (vlan)\n\t\t\t\tqlcnic_sriov_cfg_vf_def_mac(adapter, vf, vlan,\n\t\t\t\t\t\t\t    opcode);\n\t\t}\n\t}\n\tspin_unlock_bh(&vf->vlan_list_lock);\n\n\tif (vf->vp->vlan_mode != QLC_PVID_MODE) {\n\t\tif (qlcnic_83xx_pf_check(adapter) &&\n\t\t    qlcnic_sriov_check_any_vlan(vf))\n\t\t\treturn;\n\t\tqlcnic_sriov_cfg_vf_def_mac(adapter, vf, 0, opcode);\n\t}\n}\n\nstatic int qlcnic_sriov_pf_create_rx_ctx_cmd(struct qlcnic_bc_trans *tran,\n\t\t\t\t\t     struct qlcnic_cmd_args *cmd)\n{\n\tstruct qlcnic_vf_info *vf = tran->vf;\n\tstruct qlcnic_adapter *adapter = vf->adapter;\n\tstruct qlcnic_rcv_mbx_out *mbx_out;\n\tint err;\n\n\terr = qlcnic_sriov_validate_create_rx_ctx(cmd);\n\tif (err) {\n\t\tcmd->rsp.arg[0] |= (0x6 << 25);\n\t\treturn err;\n\t}\n\n\tcmd->req.arg[6] = vf->vp->handle;\n\terr = qlcnic_issue_cmd(adapter, cmd);\n\n\tif (!err) {\n\t\tmbx_out = (struct qlcnic_rcv_mbx_out *)&cmd->rsp.arg[1];\n\t\tvf->rx_ctx_id = mbx_out->ctx_id;\n\t\tqlcnic_83xx_cfg_default_mac_vlan(adapter, vf, QLCNIC_MAC_ADD);\n\t} else {\n\t\tvf->rx_ctx_id = 0;\n\t}\n\n\treturn err;\n}\n\nstatic int qlcnic_sriov_pf_mac_address_cmd(struct qlcnic_bc_trans *trans,\n\t\t\t\t\t   struct qlcnic_cmd_args *cmd)\n{\n\tstruct qlcnic_vf_info *vf = trans->vf;\n\tu8 type, *mac;\n\n\ttype = cmd->req.arg[1];\n\tswitch (type) {\n\tcase QLCNIC_SET_STATION_MAC:\n\tcase QLCNIC_SET_FAC_DEF_MAC:\n\t\tcmd->rsp.arg[0] = (2 << 25);\n\t\tbreak;\n\tcase QLCNIC_GET_CURRENT_MAC:\n\t\tcmd->rsp.arg[0] = (1 << 25);\n\t\tmac = vf->vp->mac;\n\t\tcmd->rsp.arg[2] = mac[1] | ((mac[0] << 8) & 0xff00);\n\t\tcmd->rsp.arg[1] = mac[5] | ((mac[4] << 8) & 0xff00) |\n\t\t\t\t  ((mac[3]) << 16 & 0xff0000) |\n\t\t\t\t  ((mac[2]) << 24 & 0xff000000);\n\t}\n\n\treturn 0;\n}\n\nstatic int qlcnic_sriov_validate_create_tx_ctx(struct qlcnic_cmd_args *cmd)\n{\n\tif ((cmd->req.arg[0] >> 29) != 0x3)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int qlcnic_sriov_pf_create_tx_ctx_cmd(struct qlcnic_bc_trans *trans,\n\t\t\t\t\t     struct qlcnic_cmd_args *cmd)\n{\n\tstruct qlcnic_vf_info *vf = trans->vf;\n\tstruct qlcnic_adapter *adapter = vf->adapter;\n\tstruct qlcnic_tx_mbx_out *mbx_out;\n\tint err;\n\n\terr = qlcnic_sriov_validate_create_tx_ctx(cmd);\n\tif (err) {\n\t\tcmd->rsp.arg[0] |= (0x6 << 25);\n\t\treturn err;\n\t}\n\n\tcmd->req.arg[5] |= vf->vp->handle << 16;\n\terr = qlcnic_issue_cmd(adapter, cmd);\n\tif (!err) {\n\t\tmbx_out = (struct qlcnic_tx_mbx_out *)&cmd->rsp.arg[2];\n\t\tvf->tx_ctx_id = mbx_out->ctx_id;\n\t} else {\n\t\tvf->tx_ctx_id = 0;\n\t}\n\n\treturn err;\n}\n\nstatic int qlcnic_sriov_validate_del_rx_ctx(struct qlcnic_vf_info *vf,\n\t\t\t\t\t    struct qlcnic_cmd_args *cmd)\n{\n\tif ((cmd->req.arg[0] >> 29) != 0x3)\n\t\treturn -EINVAL;\n\n\tif ((cmd->req.arg[1] & 0xffff) != vf->rx_ctx_id)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int qlcnic_sriov_pf_del_rx_ctx_cmd(struct qlcnic_bc_trans *trans,\n\t\t\t\t\t  struct qlcnic_cmd_args *cmd)\n{\n\tstruct qlcnic_vf_info *vf = trans->vf;\n\tstruct qlcnic_adapter *adapter = vf->adapter;\n\tint err;\n\n\terr = qlcnic_sriov_validate_del_rx_ctx(vf, cmd);\n\tif (err) {\n\t\tcmd->rsp.arg[0] |= (0x6 << 25);\n\t\treturn err;\n\t}\n\n\tqlcnic_83xx_cfg_default_mac_vlan(adapter, vf, QLCNIC_MAC_DEL);\n\tcmd->req.arg[1] |= vf->vp->handle << 16;\n\terr = qlcnic_issue_cmd(adapter, cmd);\n\n\tif (!err)\n\t\tvf->rx_ctx_id = 0;\n\n\treturn err;\n}\n\nstatic int qlcnic_sriov_validate_del_tx_ctx(struct qlcnic_vf_info *vf,\n\t\t\t\t\t    struct qlcnic_cmd_args *cmd)\n{\n\tif ((cmd->req.arg[0] >> 29) != 0x3)\n\t\treturn -EINVAL;\n\n\tif ((cmd->req.arg[1] & 0xffff) != vf->tx_ctx_id)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int qlcnic_sriov_pf_del_tx_ctx_cmd(struct qlcnic_bc_trans *trans,\n\t\t\t\t\t  struct qlcnic_cmd_args *cmd)\n{\n\tstruct qlcnic_vf_info *vf = trans->vf;\n\tstruct qlcnic_adapter *adapter = vf->adapter;\n\tint err;\n\n\terr = qlcnic_sriov_validate_del_tx_ctx(vf, cmd);\n\tif (err) {\n\t\tcmd->rsp.arg[0] |= (0x6 << 25);\n\t\treturn err;\n\t}\n\n\tcmd->req.arg[1] |= vf->vp->handle << 16;\n\terr = qlcnic_issue_cmd(adapter, cmd);\n\n\tif (!err)\n\t\tvf->tx_ctx_id = 0;\n\n\treturn err;\n}\n\nstatic int qlcnic_sriov_validate_cfg_lro(struct qlcnic_vf_info *vf,\n\t\t\t\t\t struct qlcnic_cmd_args *cmd)\n{\n\tif ((cmd->req.arg[1] >> 16) != vf->rx_ctx_id)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int qlcnic_sriov_pf_cfg_lro_cmd(struct qlcnic_bc_trans *trans,\n\t\t\t\t       struct qlcnic_cmd_args *cmd)\n{\n\tstruct qlcnic_vf_info *vf = trans->vf;\n\tstruct qlcnic_adapter *adapter = vf->adapter;\n\tint err;\n\n\terr = qlcnic_sriov_validate_cfg_lro(vf, cmd);\n\tif (err) {\n\t\tcmd->rsp.arg[0] |= (0x6 << 25);\n\t\treturn err;\n\t}\n\n\terr = qlcnic_issue_cmd(adapter, cmd);\n\treturn err;\n}\n\nstatic int qlcnic_sriov_pf_cfg_ip_cmd(struct qlcnic_bc_trans *trans,\n\t\t\t\t      struct qlcnic_cmd_args *cmd)\n{\n\tstruct qlcnic_vf_info *vf = trans->vf;\n\tstruct qlcnic_adapter *adapter = vf->adapter;\n\tint err;\n\n\tcmd->req.arg[1] |= vf->vp->handle << 16;\n\tcmd->req.arg[1] |= BIT_31;\n\n\terr = qlcnic_issue_cmd(adapter, cmd);\n\treturn err;\n}\n\nstatic int qlcnic_sriov_validate_cfg_intrpt(struct qlcnic_vf_info *vf,\n\t\t\t\t\t    struct qlcnic_cmd_args *cmd)\n{\n\tif (((cmd->req.arg[1] >> 8) & 0xff) != vf->pci_func)\n\t\treturn -EINVAL;\n\n\tif (!(cmd->req.arg[1] & BIT_16))\n\t\treturn -EINVAL;\n\n\tif ((cmd->req.arg[1] & 0xff) != 0x1)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int qlcnic_sriov_pf_cfg_intrpt_cmd(struct qlcnic_bc_trans *trans,\n\t\t\t\t\t  struct qlcnic_cmd_args *cmd)\n{\n\tstruct qlcnic_vf_info *vf = trans->vf;\n\tstruct qlcnic_adapter *adapter = vf->adapter;\n\tint err;\n\n\terr = qlcnic_sriov_validate_cfg_intrpt(vf, cmd);\n\tif (err)\n\t\tcmd->rsp.arg[0] |= (0x6 << 25);\n\telse\n\t\terr = qlcnic_issue_cmd(adapter, cmd);\n\n\treturn err;\n}\n\nstatic int qlcnic_sriov_validate_mtu(struct qlcnic_adapter *adapter,\n\t\t\t\t     struct qlcnic_vf_info *vf,\n\t\t\t\t     struct qlcnic_cmd_args *cmd)\n{\n\tif (cmd->req.arg[1] != vf->rx_ctx_id)\n\t\treturn -EINVAL;\n\n\tif (cmd->req.arg[2] > adapter->ahw->max_mtu)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int qlcnic_sriov_pf_set_mtu_cmd(struct qlcnic_bc_trans *trans,\n\t\t\t\t       struct qlcnic_cmd_args *cmd)\n{\n\tstruct qlcnic_vf_info *vf = trans->vf;\n\tstruct qlcnic_adapter *adapter = vf->adapter;\n\tint err;\n\n\terr = qlcnic_sriov_validate_mtu(adapter, vf, cmd);\n\tif (err)\n\t\tcmd->rsp.arg[0] |= (0x6 << 25);\n\telse\n\t\terr = qlcnic_issue_cmd(adapter, cmd);\n\n\treturn err;\n}\n\nstatic int qlcnic_sriov_validate_get_nic_info(struct qlcnic_vf_info *vf,\n\t\t\t\t\t      struct qlcnic_cmd_args *cmd)\n{\n\tif (cmd->req.arg[1] & BIT_31) {\n\t\tif (((cmd->req.arg[1] >> 16) & 0x7fff) != vf->pci_func)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tcmd->req.arg[1] |= vf->vp->handle << 16;\n\t}\n\n\treturn 0;\n}\n\nstatic int qlcnic_sriov_pf_get_nic_info_cmd(struct qlcnic_bc_trans *trans,\n\t\t\t\t\t    struct qlcnic_cmd_args *cmd)\n{\n\tstruct qlcnic_vf_info *vf = trans->vf;\n\tstruct qlcnic_adapter *adapter = vf->adapter;\n\tint err;\n\n\terr = qlcnic_sriov_validate_get_nic_info(vf, cmd);\n\tif (err) {\n\t\tcmd->rsp.arg[0] |= (0x6 << 25);\n\t\treturn err;\n\t}\n\n\terr = qlcnic_issue_cmd(adapter, cmd);\n\treturn err;\n}\n\nstatic int qlcnic_sriov_validate_cfg_rss(struct qlcnic_vf_info *vf,\n\t\t\t\t\t struct qlcnic_cmd_args *cmd)\n{\n\tif (cmd->req.arg[1] != vf->rx_ctx_id)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int qlcnic_sriov_pf_cfg_rss_cmd(struct qlcnic_bc_trans *trans,\n\t\t\t\t       struct qlcnic_cmd_args *cmd)\n{\n\tstruct qlcnic_vf_info *vf = trans->vf;\n\tstruct qlcnic_adapter *adapter = vf->adapter;\n\tint err;\n\n\terr = qlcnic_sriov_validate_cfg_rss(vf, cmd);\n\tif (err)\n\t\tcmd->rsp.arg[0] |= (0x6 << 25);\n\telse\n\t\terr = qlcnic_issue_cmd(adapter, cmd);\n\n\treturn err;\n}\n\nstatic int qlcnic_sriov_validate_cfg_intrcoal(struct qlcnic_adapter *adapter,\n\t\t\t\t\t      struct qlcnic_vf_info *vf,\n\t\t\t\t\t      struct qlcnic_cmd_args *cmd)\n{\n\tstruct qlcnic_nic_intr_coalesce *coal = &adapter->ahw->coal;\n\tu16 ctx_id, pkts, time;\n\tint err = -EINVAL;\n\tu8 type;\n\n\ttype = cmd->req.arg[1] & QLC_INTR_COAL_TYPE_MASK;\n\tctx_id = cmd->req.arg[1] >> 16;\n\tpkts = cmd->req.arg[2] & 0xffff;\n\ttime = cmd->req.arg[2] >> 16;\n\n\tswitch (type) {\n\tcase QLCNIC_INTR_COAL_TYPE_RX:\n\t\tif (ctx_id != vf->rx_ctx_id || pkts > coal->rx_packets ||\n\t\t    time < coal->rx_time_us)\n\t\t\tgoto err_label;\n\t\tbreak;\n\tcase QLCNIC_INTR_COAL_TYPE_TX:\n\t\tif (ctx_id != vf->tx_ctx_id || pkts > coal->tx_packets ||\n\t\t    time < coal->tx_time_us)\n\t\t\tgoto err_label;\n\t\tbreak;\n\tdefault:\n\t\tnetdev_err(adapter->netdev, \"Invalid coalescing type 0x%x received\\n\",\n\t\t\t   type);\n\t\treturn err;\n\t}\n\n\treturn 0;\n\nerr_label:\n\tnetdev_err(adapter->netdev, \"Expected: rx_ctx_id 0x%x rx_packets 0x%x rx_time_us 0x%x tx_ctx_id 0x%x tx_packets 0x%x tx_time_us 0x%x\\n\",\n\t\t   vf->rx_ctx_id, coal->rx_packets, coal->rx_time_us,\n\t\t   vf->tx_ctx_id, coal->tx_packets, coal->tx_time_us);\n\tnetdev_err(adapter->netdev, \"Received: ctx_id 0x%x packets 0x%x time_us 0x%x type 0x%x\\n\",\n\t\t   ctx_id, pkts, time, type);\n\n\treturn err;\n}\n\nstatic int qlcnic_sriov_pf_cfg_intrcoal_cmd(struct qlcnic_bc_trans *tran,\n\t\t\t\t\t    struct qlcnic_cmd_args *cmd)\n{\n\tstruct qlcnic_vf_info *vf = tran->vf;\n\tstruct qlcnic_adapter *adapter = vf->adapter;\n\tint err;\n\n\terr = qlcnic_sriov_validate_cfg_intrcoal(adapter, vf, cmd);\n\tif (err) {\n\t\tcmd->rsp.arg[0] |= (0x6 << 25);\n\t\treturn err;\n\t}\n\n\terr = qlcnic_issue_cmd(adapter, cmd);\n\treturn err;\n}\n\nstatic int qlcnic_sriov_validate_cfg_macvlan(struct qlcnic_adapter *adapter,\n\t\t\t\t\t     struct qlcnic_vf_info *vf,\n\t\t\t\t\t     struct qlcnic_cmd_args *cmd)\n{\n\tstruct qlcnic_vport *vp = vf->vp;\n\tu8 op, new_op;\n\n\tif (!(cmd->req.arg[1] & BIT_8))\n\t\treturn -EINVAL;\n\n\tcmd->req.arg[1] |= (vf->vp->handle << 16);\n\tcmd->req.arg[1] |= BIT_31;\n\n\tif (vp->vlan_mode == QLC_PVID_MODE) {\n\t\top = cmd->req.arg[1] & 0x7;\n\t\tcmd->req.arg[1] &= ~0x7;\n\t\tnew_op = (op == QLCNIC_MAC_ADD || op == QLCNIC_MAC_VLAN_ADD) ?\n\t\t\t QLCNIC_MAC_VLAN_ADD : QLCNIC_MAC_VLAN_DEL;\n\t\tcmd->req.arg[3] |= vp->pvid << 16;\n\t\tcmd->req.arg[1] |= new_op;\n\t}\n\n\treturn 0;\n}\n\nstatic int qlcnic_sriov_pf_cfg_macvlan_cmd(struct qlcnic_bc_trans *trans,\n\t\t\t\t\t   struct qlcnic_cmd_args *cmd)\n{\n\tstruct qlcnic_vf_info *vf = trans->vf;\n\tstruct qlcnic_adapter *adapter = vf->adapter;\n\tint err;\n\n\terr = qlcnic_sriov_validate_cfg_macvlan(adapter, vf, cmd);\n\tif (err) {\n\t\tcmd->rsp.arg[0] |= (0x6 << 25);\n\t\treturn err;\n\t}\n\n\terr = qlcnic_issue_cmd(adapter, cmd);\n\treturn err;\n}\n\nstatic int qlcnic_sriov_validate_linkevent(struct qlcnic_vf_info *vf,\n\t\t\t\t\t   struct qlcnic_cmd_args *cmd)\n{\n\tif ((cmd->req.arg[1] >> 16) != vf->rx_ctx_id)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int qlcnic_sriov_pf_linkevent_cmd(struct qlcnic_bc_trans *trans,\n\t\t\t\t\t struct qlcnic_cmd_args *cmd)\n{\n\tstruct qlcnic_vf_info *vf = trans->vf;\n\tstruct qlcnic_adapter *adapter = vf->adapter;\n\tint err;\n\n\terr = qlcnic_sriov_validate_linkevent(vf, cmd);\n\tif (err) {\n\t\tcmd->rsp.arg[0] |= (0x6 << 25);\n\t\treturn err;\n\t}\n\n\terr = qlcnic_issue_cmd(adapter, cmd);\n\treturn err;\n}\n\nstatic int qlcnic_sriov_pf_cfg_promisc_cmd(struct qlcnic_bc_trans *trans,\n\t\t\t\t\t   struct qlcnic_cmd_args *cmd)\n{\n\tstruct qlcnic_vf_info *vf = trans->vf;\n\tstruct qlcnic_adapter *adapter = vf->adapter;\n\tint err;\n\n\tcmd->req.arg[1] |= vf->vp->handle << 16;\n\tcmd->req.arg[1] |= BIT_31;\n\terr = qlcnic_issue_cmd(adapter, cmd);\n\treturn err;\n}\n\nstatic int qlcnic_sriov_pf_get_acl_cmd(struct qlcnic_bc_trans *trans,\n\t\t\t\t       struct qlcnic_cmd_args *cmd)\n{\n\tstruct qlcnic_vf_info *vf = trans->vf;\n\tstruct qlcnic_vport *vp = vf->vp;\n\tu8 mode = vp->vlan_mode;\n\tstruct qlcnic_adapter *adapter;\n\tstruct qlcnic_sriov *sriov;\n\n\tadapter = vf->adapter;\n\tsriov = adapter->ahw->sriov;\n\n\tcmd->rsp.arg[0] |= 1 << 25;\n\n\t \n\tif (qlcnic_84xx_check(adapter) && mode == QLC_PVID_MODE)\n\t\treturn 0;\n\n\tswitch (mode) {\n\tcase QLC_GUEST_VLAN_MODE:\n\t\tcmd->rsp.arg[1] = mode | 1 << 8;\n\t\tcmd->rsp.arg[2] = sriov->num_allowed_vlans << 16;\n\t\tbreak;\n\tcase QLC_PVID_MODE:\n\t\tcmd->rsp.arg[1] = mode | 1 << 8 | vp->pvid << 16;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int qlcnic_sriov_pf_del_guest_vlan(struct qlcnic_adapter *adapter,\n\t\t\t\t\t  struct qlcnic_vf_info *vf,\n\t\t\t\t\t  struct qlcnic_cmd_args *cmd)\n{\n\tstruct qlcnic_sriov *sriov = adapter->ahw->sriov;\n\tu16 vlan;\n\n\tif (!qlcnic_sriov_check_any_vlan(vf))\n\t\treturn -EINVAL;\n\n\tvlan = cmd->req.arg[1] >> 16;\n\tif (!vf->rx_ctx_id) {\n\t\tqlcnic_sriov_del_vlan_id(sriov, vf, vlan);\n\t\treturn 0;\n\t}\n\n\tqlcnic_sriov_cfg_vf_def_mac(adapter, vf, vlan, QLCNIC_MAC_DEL);\n\tqlcnic_sriov_del_vlan_id(sriov, vf, vlan);\n\n\tif (qlcnic_83xx_pf_check(adapter))\n\t\tqlcnic_sriov_cfg_vf_def_mac(adapter, vf,\n\t\t\t\t\t    0, QLCNIC_MAC_ADD);\n\treturn 0;\n}\n\nstatic int qlcnic_sriov_pf_add_guest_vlan(struct qlcnic_adapter *adapter,\n\t\t\t\t\t  struct qlcnic_vf_info *vf,\n\t\t\t\t\t  struct qlcnic_cmd_args *cmd)\n{\n\tstruct qlcnic_sriov *sriov = adapter->ahw->sriov;\n\tint err = -EIO;\n\tu16 vlan;\n\n\tif (qlcnic_83xx_pf_check(adapter) && qlcnic_sriov_check_any_vlan(vf))\n\t\treturn err;\n\n\tvlan = cmd->req.arg[1] >> 16;\n\n\tif (!vf->rx_ctx_id) {\n\t\tqlcnic_sriov_add_vlan_id(sriov, vf, vlan);\n\t\treturn 0;\n\t}\n\n\tif (qlcnic_83xx_pf_check(adapter)) {\n\t\terr = qlcnic_sriov_cfg_vf_def_mac(adapter, vf, 0,\n\t\t\t\t\t\t  QLCNIC_MAC_DEL);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\terr = qlcnic_sriov_cfg_vf_def_mac(adapter, vf, vlan, QLCNIC_MAC_ADD);\n\n\tif (err) {\n\t\tif (qlcnic_83xx_pf_check(adapter))\n\t\t\tqlcnic_sriov_cfg_vf_def_mac(adapter, vf, 0,\n\t\t\t\t\t\t    QLCNIC_MAC_ADD);\n\t\treturn err;\n\t}\n\n\tqlcnic_sriov_add_vlan_id(sriov, vf, vlan);\n\treturn err;\n}\n\nstatic int qlcnic_sriov_pf_cfg_guest_vlan_cmd(struct qlcnic_bc_trans *tran,\n\t\t\t\t\t      struct qlcnic_cmd_args *cmd)\n{\n\tstruct qlcnic_vf_info  *vf = tran->vf;\n\tstruct qlcnic_adapter *adapter =  vf->adapter;\n\tstruct qlcnic_vport *vp = vf->vp;\n\tint err = -EIO;\n\tu8 op;\n\n\tif (vp->vlan_mode != QLC_GUEST_VLAN_MODE) {\n\t\tcmd->rsp.arg[0] |= 2 << 25;\n\t\treturn err;\n\t}\n\n\top = cmd->req.arg[1] & 0xf;\n\n\tif (op)\n\t\terr = qlcnic_sriov_pf_add_guest_vlan(adapter, vf, cmd);\n\telse\n\t\terr = qlcnic_sriov_pf_del_guest_vlan(adapter, vf, cmd);\n\n\tcmd->rsp.arg[0] |= err ? 2 << 25 : 1 << 25;\n\treturn err;\n}\n\nstatic const int qlcnic_pf_passthru_supp_cmds[] = {\n\tQLCNIC_CMD_GET_STATISTICS,\n\tQLCNIC_CMD_GET_PORT_CONFIG,\n\tQLCNIC_CMD_GET_LINK_STATUS,\n\tQLCNIC_CMD_INIT_NIC_FUNC,\n\tQLCNIC_CMD_STOP_NIC_FUNC,\n};\n\nstatic const struct qlcnic_sriov_cmd_handler qlcnic_pf_bc_cmd_hdlr[] = {\n\t[QLCNIC_BC_CMD_CHANNEL_INIT] = {&qlcnic_sriov_pf_channel_cfg_cmd},\n\t[QLCNIC_BC_CMD_CHANNEL_TERM] = {&qlcnic_sriov_pf_channel_cfg_cmd},\n\t[QLCNIC_BC_CMD_GET_ACL]\t= {&qlcnic_sriov_pf_get_acl_cmd},\n\t[QLCNIC_BC_CMD_CFG_GUEST_VLAN]\t= {&qlcnic_sriov_pf_cfg_guest_vlan_cmd},\n};\n\nstatic const struct qlcnic_sriov_fw_cmd_handler qlcnic_pf_fw_cmd_hdlr[] = {\n\t{QLCNIC_CMD_CREATE_RX_CTX, qlcnic_sriov_pf_create_rx_ctx_cmd},\n\t{QLCNIC_CMD_CREATE_TX_CTX, qlcnic_sriov_pf_create_tx_ctx_cmd},\n\t{QLCNIC_CMD_MAC_ADDRESS, qlcnic_sriov_pf_mac_address_cmd},\n\t{QLCNIC_CMD_DESTROY_RX_CTX, qlcnic_sriov_pf_del_rx_ctx_cmd},\n\t{QLCNIC_CMD_DESTROY_TX_CTX, qlcnic_sriov_pf_del_tx_ctx_cmd},\n\t{QLCNIC_CMD_CONFIGURE_HW_LRO, qlcnic_sriov_pf_cfg_lro_cmd},\n\t{QLCNIC_CMD_CONFIGURE_IP_ADDR, qlcnic_sriov_pf_cfg_ip_cmd},\n\t{QLCNIC_CMD_CONFIG_INTRPT, qlcnic_sriov_pf_cfg_intrpt_cmd},\n\t{QLCNIC_CMD_SET_MTU, qlcnic_sriov_pf_set_mtu_cmd},\n\t{QLCNIC_CMD_GET_NIC_INFO, qlcnic_sriov_pf_get_nic_info_cmd},\n\t{QLCNIC_CMD_CONFIGURE_RSS, qlcnic_sriov_pf_cfg_rss_cmd},\n\t{QLCNIC_CMD_CONFIG_INTR_COAL, qlcnic_sriov_pf_cfg_intrcoal_cmd},\n\t{QLCNIC_CMD_CONFIG_MAC_VLAN, qlcnic_sriov_pf_cfg_macvlan_cmd},\n\t{QLCNIC_CMD_GET_LINK_EVENT, qlcnic_sriov_pf_linkevent_cmd},\n\t{QLCNIC_CMD_CONFIGURE_MAC_RX_MODE, qlcnic_sriov_pf_cfg_promisc_cmd},\n};\n\nvoid qlcnic_sriov_pf_process_bc_cmd(struct qlcnic_adapter *adapter,\n\t\t\t\t    struct qlcnic_bc_trans *trans,\n\t\t\t\t    struct qlcnic_cmd_args *cmd)\n{\n\tu8 size, cmd_op;\n\n\tcmd_op = trans->req_hdr->cmd_op;\n\n\tif (trans->req_hdr->op_type == QLC_BC_CMD) {\n\t\tsize = ARRAY_SIZE(qlcnic_pf_bc_cmd_hdlr);\n\t\tif (cmd_op < size) {\n\t\t\tqlcnic_pf_bc_cmd_hdlr[cmd_op].fn(trans, cmd);\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tint i;\n\t\tsize = ARRAY_SIZE(qlcnic_pf_fw_cmd_hdlr);\n\t\tfor (i = 0; i < size; i++) {\n\t\t\tif (cmd_op == qlcnic_pf_fw_cmd_hdlr[i].cmd) {\n\t\t\t\tqlcnic_pf_fw_cmd_hdlr[i].fn(trans, cmd);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tsize = ARRAY_SIZE(qlcnic_pf_passthru_supp_cmds);\n\t\tfor (i = 0; i < size; i++) {\n\t\t\tif (cmd_op == qlcnic_pf_passthru_supp_cmds[i]) {\n\t\t\t\tqlcnic_issue_cmd(adapter, cmd);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tcmd->rsp.arg[0] |= (0x9 << 25);\n}\n\nvoid qlcnic_pf_set_interface_id_create_rx_ctx(struct qlcnic_adapter *adapter,\n\t\t\t\t\t     u32 *int_id)\n{\n\tu16 vpid;\n\n\tvpid = qlcnic_sriov_pf_get_vport_handle(adapter,\n\t\t\t\t\t\tadapter->ahw->pci_func);\n\t*int_id |= vpid;\n}\n\nvoid qlcnic_pf_set_interface_id_del_rx_ctx(struct qlcnic_adapter *adapter,\n\t\t\t\t\t   u32 *int_id)\n{\n\tu16 vpid;\n\n\tvpid = qlcnic_sriov_pf_get_vport_handle(adapter,\n\t\t\t\t\t\tadapter->ahw->pci_func);\n\t*int_id |= vpid << 16;\n}\n\nvoid qlcnic_pf_set_interface_id_create_tx_ctx(struct qlcnic_adapter *adapter,\n\t\t\t\t\t      u32 *int_id)\n{\n\tint vpid;\n\n\tvpid = qlcnic_sriov_pf_get_vport_handle(adapter,\n\t\t\t\t\t\tadapter->ahw->pci_func);\n\t*int_id |= vpid << 16;\n}\n\nvoid qlcnic_pf_set_interface_id_del_tx_ctx(struct qlcnic_adapter *adapter,\n\t\t\t\t\t   u32 *int_id)\n{\n\tu16 vpid;\n\n\tvpid = qlcnic_sriov_pf_get_vport_handle(adapter,\n\t\t\t\t\t\tadapter->ahw->pci_func);\n\t*int_id |= vpid << 16;\n}\n\nvoid qlcnic_pf_set_interface_id_promisc(struct qlcnic_adapter *adapter,\n\t\t\t\t\tu32 *int_id)\n{\n\tu16 vpid;\n\n\tvpid = qlcnic_sriov_pf_get_vport_handle(adapter,\n\t\t\t\t\t\tadapter->ahw->pci_func);\n\t*int_id |= (vpid << 16) | BIT_31;\n}\n\nvoid qlcnic_pf_set_interface_id_ipaddr(struct qlcnic_adapter *adapter,\n\t\t\t\t       u32 *int_id)\n{\n\tu16 vpid;\n\n\tvpid = qlcnic_sriov_pf_get_vport_handle(adapter,\n\t\t\t\t\t\tadapter->ahw->pci_func);\n\t*int_id |= (vpid << 16) | BIT_31;\n}\n\nvoid qlcnic_pf_set_interface_id_macaddr(struct qlcnic_adapter *adapter,\n\t\t\t\t\tu32 *int_id)\n{\n\tu16 vpid;\n\n\tvpid = qlcnic_sriov_pf_get_vport_handle(adapter,\n\t\t\t\t\t\tadapter->ahw->pci_func);\n\t*int_id |= (vpid << 16) | BIT_31;\n}\n\nstatic void qlcnic_sriov_del_rx_ctx(struct qlcnic_adapter *adapter,\n\t\t\t\t    struct qlcnic_vf_info *vf)\n{\n\tstruct qlcnic_cmd_args cmd;\n\tint vpid;\n\n\tif (!vf->rx_ctx_id)\n\t\treturn;\n\n\tif (qlcnic_alloc_mbx_args(&cmd, adapter, QLCNIC_CMD_DESTROY_RX_CTX))\n\t\treturn;\n\n\tvpid = qlcnic_sriov_pf_get_vport_handle(adapter, vf->pci_func);\n\tif (vpid >= 0) {\n\t\tcmd.req.arg[1] = vf->rx_ctx_id | (vpid & 0xffff) << 16;\n\t\tif (qlcnic_issue_cmd(adapter, &cmd))\n\t\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\t\"Failed to delete Tx ctx in firmware for func 0x%x\\n\",\n\t\t\t\tvf->pci_func);\n\t\telse\n\t\t\tvf->rx_ctx_id = 0;\n\t}\n\n\tqlcnic_free_mbx_args(&cmd);\n}\n\nstatic void qlcnic_sriov_del_tx_ctx(struct qlcnic_adapter *adapter,\n\t\t\t\t    struct qlcnic_vf_info *vf)\n{\n\tstruct qlcnic_cmd_args cmd;\n\tint vpid;\n\n\tif (!vf->tx_ctx_id)\n\t\treturn;\n\n\tif (qlcnic_alloc_mbx_args(&cmd, adapter, QLCNIC_CMD_DESTROY_TX_CTX))\n\t\treturn;\n\n\tvpid = qlcnic_sriov_pf_get_vport_handle(adapter, vf->pci_func);\n\tif (vpid >= 0) {\n\t\tcmd.req.arg[1] |= vf->tx_ctx_id | (vpid & 0xffff) << 16;\n\t\tif (qlcnic_issue_cmd(adapter, &cmd))\n\t\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\t\"Failed to delete Tx ctx in firmware for func 0x%x\\n\",\n\t\t\t\tvf->pci_func);\n\t\telse\n\t\t\tvf->tx_ctx_id = 0;\n\t}\n\n\tqlcnic_free_mbx_args(&cmd);\n}\n\nstatic int qlcnic_sriov_add_act_list_irqsave(struct qlcnic_sriov *sriov,\n\t\t\t\t\t     struct qlcnic_vf_info *vf,\n\t\t\t\t\t     struct qlcnic_bc_trans *trans)\n{\n\tstruct qlcnic_trans_list *t_list = &vf->rcv_act;\n\tunsigned long flag;\n\n\tspin_lock_irqsave(&t_list->lock, flag);\n\n\t__qlcnic_sriov_add_act_list(sriov, vf, trans);\n\n\tspin_unlock_irqrestore(&t_list->lock, flag);\n\treturn 0;\n}\n\nstatic void __qlcnic_sriov_process_flr(struct qlcnic_vf_info *vf)\n{\n\tstruct qlcnic_adapter *adapter = vf->adapter;\n\n\tqlcnic_sriov_cleanup_list(&vf->rcv_pend);\n\tcancel_work_sync(&vf->trans_work);\n\tqlcnic_sriov_cleanup_list(&vf->rcv_act);\n\n\tif (test_bit(QLC_BC_VF_SOFT_FLR, &vf->state)) {\n\t\tqlcnic_sriov_del_tx_ctx(adapter, vf);\n\t\tqlcnic_sriov_del_rx_ctx(adapter, vf);\n\t}\n\n\tqlcnic_sriov_pf_config_vport(adapter, 0, vf->pci_func);\n\n\tclear_bit(QLC_BC_VF_FLR, &vf->state);\n\tif (test_bit(QLC_BC_VF_SOFT_FLR, &vf->state)) {\n\t\tqlcnic_sriov_add_act_list_irqsave(adapter->ahw->sriov, vf,\n\t\t\t\t\t\t  vf->flr_trans);\n\t\tclear_bit(QLC_BC_VF_SOFT_FLR, &vf->state);\n\t\tvf->flr_trans = NULL;\n\t}\n}\n\nstatic void qlcnic_sriov_pf_process_flr(struct work_struct *work)\n{\n\tstruct qlcnic_vf_info *vf;\n\n\tvf = container_of(work, struct qlcnic_vf_info, flr_work);\n\t__qlcnic_sriov_process_flr(vf);\n\treturn;\n}\n\nstatic void qlcnic_sriov_schedule_flr(struct qlcnic_sriov *sriov,\n\t\t\t\t      struct qlcnic_vf_info *vf,\n\t\t\t\t      work_func_t func)\n{\n\tif (test_bit(__QLCNIC_RESETTING, &vf->adapter->state))\n\t\treturn;\n\n\tINIT_WORK(&vf->flr_work, func);\n\tqueue_work(sriov->bc.bc_flr_wq, &vf->flr_work);\n}\n\nstatic void qlcnic_sriov_handle_soft_flr(struct qlcnic_adapter *adapter,\n\t\t\t\t\t struct qlcnic_bc_trans *trans,\n\t\t\t\t\t struct qlcnic_vf_info *vf)\n{\n\tstruct qlcnic_sriov *sriov = adapter->ahw->sriov;\n\n\tset_bit(QLC_BC_VF_FLR, &vf->state);\n\tclear_bit(QLC_BC_VF_STATE, &vf->state);\n\tset_bit(QLC_BC_VF_SOFT_FLR, &vf->state);\n\tvf->flr_trans = trans;\n\tqlcnic_sriov_schedule_flr(sriov, vf, qlcnic_sriov_pf_process_flr);\n\tnetdev_info(adapter->netdev, \"Software FLR for PCI func %d\\n\",\n\t\t    vf->pci_func);\n}\n\nbool qlcnic_sriov_soft_flr_check(struct qlcnic_adapter *adapter,\n\t\t\t\t struct qlcnic_bc_trans *trans,\n\t\t\t\t struct qlcnic_vf_info *vf)\n{\n\tstruct qlcnic_bc_hdr *hdr = trans->req_hdr;\n\n\tif ((hdr->cmd_op == QLCNIC_BC_CMD_CHANNEL_INIT) &&\n\t    (hdr->op_type == QLC_BC_CMD) &&\n\t     test_bit(QLC_BC_VF_STATE, &vf->state)) {\n\t\tqlcnic_sriov_handle_soft_flr(adapter, trans, vf);\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nvoid qlcnic_sriov_pf_handle_flr(struct qlcnic_sriov *sriov,\n\t\t\t\tstruct qlcnic_vf_info *vf)\n{\n\tstruct net_device *dev = vf->adapter->netdev;\n\tstruct qlcnic_vport *vp = vf->vp;\n\n\tif (!test_and_clear_bit(QLC_BC_VF_STATE, &vf->state)) {\n\t\tclear_bit(QLC_BC_VF_FLR, &vf->state);\n\t\treturn;\n\t}\n\n\tif (test_and_set_bit(QLC_BC_VF_FLR, &vf->state)) {\n\t\tnetdev_info(dev, \"FLR for PCI func %d in progress\\n\",\n\t\t\t    vf->pci_func);\n\t\treturn;\n\t}\n\n\tif (vp->vlan_mode == QLC_GUEST_VLAN_MODE)\n\t\tmemset(vf->sriov_vlans, 0,\n\t\t       sizeof(*vf->sriov_vlans) * sriov->num_allowed_vlans);\n\n\tqlcnic_sriov_schedule_flr(sriov, vf, qlcnic_sriov_pf_process_flr);\n\tnetdev_info(dev, \"FLR received for PCI func %d\\n\", vf->pci_func);\n}\n\nvoid qlcnic_sriov_pf_reset(struct qlcnic_adapter *adapter)\n{\n\tstruct qlcnic_hardware_context *ahw = adapter->ahw;\n\tstruct qlcnic_sriov *sriov = ahw->sriov;\n\tstruct qlcnic_vf_info *vf;\n\tu16 num_vfs = sriov->num_vfs;\n\tint i;\n\n\tfor (i = 0; i < num_vfs; i++) {\n\t\tvf = &sriov->vf_info[i];\n\t\tvf->rx_ctx_id = 0;\n\t\tvf->tx_ctx_id = 0;\n\t\tcancel_work_sync(&vf->flr_work);\n\t\t__qlcnic_sriov_process_flr(vf);\n\t\tclear_bit(QLC_BC_VF_STATE, &vf->state);\n\t}\n\n\tqlcnic_sriov_pf_reset_vport_handle(adapter, ahw->pci_func);\n\tQLCWRX(ahw, QLCNIC_MBX_INTR_ENBL, (ahw->num_msix - 1) << 8);\n}\n\nint qlcnic_sriov_pf_reinit(struct qlcnic_adapter *adapter)\n{\n\tstruct qlcnic_hardware_context *ahw = adapter->ahw;\n\tint err;\n\n\tif (!qlcnic_sriov_enable_check(adapter))\n\t\treturn 0;\n\n\tahw->op_mode = QLCNIC_SRIOV_PF_FUNC;\n\n\terr = qlcnic_sriov_pf_init(adapter);\n\tif (err)\n\t\treturn err;\n\n\tdev_info(&adapter->pdev->dev, \"%s: op_mode %d\\n\",\n\t\t __func__, ahw->op_mode);\n\treturn err;\n}\n\nint qlcnic_sriov_set_vf_mac(struct net_device *netdev, int vf, u8 *mac)\n{\n\tstruct qlcnic_adapter *adapter = netdev_priv(netdev);\n\tstruct qlcnic_sriov *sriov = adapter->ahw->sriov;\n\tint i, num_vfs;\n\tstruct qlcnic_vf_info *vf_info;\n\tu8 *curr_mac;\n\n\tif (!qlcnic_sriov_pf_check(adapter))\n\t\treturn -EOPNOTSUPP;\n\n\tnum_vfs = sriov->num_vfs;\n\n\tif (!is_valid_ether_addr(mac) || vf >= num_vfs)\n\t\treturn -EINVAL;\n\n\tif (ether_addr_equal(adapter->mac_addr, mac)) {\n\t\tnetdev_err(netdev, \"MAC address is already in use by the PF\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < num_vfs; i++) {\n\t\tvf_info = &sriov->vf_info[i];\n\t\tif (ether_addr_equal(vf_info->vp->mac, mac)) {\n\t\t\tnetdev_err(netdev,\n\t\t\t\t   \"MAC address is already in use by VF %d\\n\",\n\t\t\t\t   i);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tvf_info = &sriov->vf_info[vf];\n\tcurr_mac = vf_info->vp->mac;\n\n\tif (test_bit(QLC_BC_VF_STATE, &vf_info->state)) {\n\t\tnetdev_err(netdev,\n\t\t\t   \"MAC address change failed for VF %d, as VF driver is loaded. Please unload VF driver and retry the operation\\n\",\n\t\t\t   vf);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tmemcpy(curr_mac, mac, netdev->addr_len);\n\tnetdev_info(netdev, \"MAC Address %pM  is configured for VF %d\\n\",\n\t\t    mac, vf);\n\treturn 0;\n}\n\nint qlcnic_sriov_set_vf_tx_rate(struct net_device *netdev, int vf,\n\t\t\t\tint min_tx_rate, int max_tx_rate)\n{\n\tstruct qlcnic_adapter *adapter = netdev_priv(netdev);\n\tstruct qlcnic_sriov *sriov = adapter->ahw->sriov;\n\tstruct qlcnic_vf_info *vf_info;\n\tstruct qlcnic_info nic_info;\n\tstruct qlcnic_vport *vp;\n\tu16 vpid;\n\n\tif (!qlcnic_sriov_pf_check(adapter))\n\t\treturn -EOPNOTSUPP;\n\n\tif (vf >= sriov->num_vfs)\n\t\treturn -EINVAL;\n\n\tvf_info = &sriov->vf_info[vf];\n\tvp = vf_info->vp;\n\tvpid = vp->handle;\n\n\tif (!min_tx_rate)\n\t\tmin_tx_rate = QLC_VF_MIN_TX_RATE;\n\n\tif (max_tx_rate && max_tx_rate >= 10000) {\n\t\tnetdev_err(netdev,\n\t\t\t   \"Invalid max Tx rate, allowed range is [%d - %d]\",\n\t\t\t   min_tx_rate, QLC_VF_MAX_TX_RATE);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!max_tx_rate)\n\t\tmax_tx_rate = 10000;\n\n\tif (min_tx_rate && min_tx_rate < QLC_VF_MIN_TX_RATE) {\n\t\tnetdev_err(netdev,\n\t\t\t   \"Invalid min Tx rate, allowed range is [%d - %d]\",\n\t\t\t   QLC_VF_MIN_TX_RATE, max_tx_rate);\n\t\treturn -EINVAL;\n\t}\n\n\tif (test_bit(QLC_BC_VF_STATE, &vf_info->state)) {\n\t\tif (qlcnic_sriov_get_vf_vport_info(adapter, &nic_info, vpid))\n\t\t\treturn -EIO;\n\n\t\tnic_info.max_tx_bw = max_tx_rate / 100;\n\t\tnic_info.min_tx_bw = min_tx_rate / 100;\n\t\tnic_info.bit_offsets = BIT_0;\n\n\t\tif (qlcnic_sriov_pf_set_vport_info(adapter, &nic_info, vpid))\n\t\t\treturn -EIO;\n\t}\n\n\tvp->max_tx_bw = max_tx_rate / 100;\n\tnetdev_info(netdev,\n\t\t    \"Setting Max Tx rate %d (Mbps), %d %% of PF bandwidth, for VF %d\\n\",\n\t\t    max_tx_rate, vp->max_tx_bw, vf);\n\tvp->min_tx_bw = min_tx_rate / 100;\n\tnetdev_info(netdev,\n\t\t    \"Setting Min Tx rate %d (Mbps), %d %% of PF bandwidth, for VF %d\\n\",\n\t\t    min_tx_rate, vp->min_tx_bw, vf);\n\treturn 0;\n}\n\nint qlcnic_sriov_set_vf_vlan(struct net_device *netdev, int vf,\n\t\t\t     u16 vlan, u8 qos, __be16 vlan_proto)\n{\n\tstruct qlcnic_adapter *adapter = netdev_priv(netdev);\n\tstruct qlcnic_sriov *sriov = adapter->ahw->sriov;\n\tstruct qlcnic_vf_info *vf_info;\n\tstruct qlcnic_vport *vp;\n\n\tif (!qlcnic_sriov_pf_check(adapter))\n\t\treturn -EOPNOTSUPP;\n\n\tif (vf >= sriov->num_vfs || qos > 7)\n\t\treturn -EINVAL;\n\n\tif (vlan_proto != htons(ETH_P_8021Q))\n\t\treturn -EPROTONOSUPPORT;\n\n\tif (vlan > MAX_VLAN_ID) {\n\t\tnetdev_err(netdev,\n\t\t\t   \"Invalid VLAN ID, allowed range is [0 - %d]\\n\",\n\t\t\t   MAX_VLAN_ID);\n\t\treturn -EINVAL;\n\t}\n\n\tvf_info = &sriov->vf_info[vf];\n\tvp = vf_info->vp;\n\tif (test_bit(QLC_BC_VF_STATE, &vf_info->state)) {\n\t\tnetdev_err(netdev,\n\t\t\t   \"VLAN change failed for VF %d, as VF driver is loaded. Please unload VF driver and retry the operation\\n\",\n\t\t\t   vf);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tmemset(vf_info->sriov_vlans, 0,\n\t       sizeof(*vf_info->sriov_vlans) * sriov->num_allowed_vlans);\n\n\tswitch (vlan) {\n\tcase 4095:\n\t\tvp->vlan_mode = QLC_GUEST_VLAN_MODE;\n\t\tbreak;\n\tcase 0:\n\t\tvp->vlan_mode = QLC_NO_VLAN_MODE;\n\t\tvp->qos = 0;\n\t\tbreak;\n\tdefault:\n\t\tvp->vlan_mode = QLC_PVID_MODE;\n\t\tqlcnic_sriov_add_vlan_id(sriov, vf_info, vlan);\n\t\tvp->qos = qos;\n\t\tvp->pvid = vlan;\n\t}\n\n\tnetdev_info(netdev, \"Setting VLAN %d, QoS %d, for VF %d\\n\",\n\t\t    vlan, qos, vf);\n\treturn 0;\n}\n\nstatic __u32 qlcnic_sriov_get_vf_vlan(struct qlcnic_adapter *adapter,\n\t\t\t\t      struct qlcnic_vport *vp, int vf)\n{\n\t__u32 vlan = 0;\n\n\tswitch (vp->vlan_mode) {\n\tcase QLC_PVID_MODE:\n\t\tvlan = vp->pvid;\n\t\tbreak;\n\tcase QLC_GUEST_VLAN_MODE:\n\t\tvlan = MAX_VLAN_ID;\n\t\tbreak;\n\tcase QLC_NO_VLAN_MODE:\n\t\tvlan = 0;\n\t\tbreak;\n\tdefault:\n\t\tnetdev_info(adapter->netdev, \"Invalid VLAN mode = %d for VF %d\\n\",\n\t\t\t    vp->vlan_mode, vf);\n\t}\n\n\treturn vlan;\n}\n\nint qlcnic_sriov_get_vf_config(struct net_device *netdev,\n\t\t\t       int vf, struct ifla_vf_info *ivi)\n{\n\tstruct qlcnic_adapter *adapter = netdev_priv(netdev);\n\tstruct qlcnic_sriov *sriov = adapter->ahw->sriov;\n\tstruct qlcnic_vport *vp;\n\n\tif (!qlcnic_sriov_pf_check(adapter))\n\t\treturn -EOPNOTSUPP;\n\n\tif (vf >= sriov->num_vfs)\n\t\treturn -EINVAL;\n\n\tvp = sriov->vf_info[vf].vp;\n\tmemcpy(&ivi->mac, vp->mac, ETH_ALEN);\n\tivi->vlan = qlcnic_sriov_get_vf_vlan(adapter, vp, vf);\n\tivi->qos = vp->qos;\n\tivi->spoofchk = vp->spoofchk;\n\tif (vp->max_tx_bw == MAX_BW)\n\t\tivi->max_tx_rate = 0;\n\telse\n\t\tivi->max_tx_rate = vp->max_tx_bw * 100;\n\tif (vp->min_tx_bw == MIN_BW)\n\t\tivi->min_tx_rate = 0;\n\telse\n\t\tivi->min_tx_rate = vp->min_tx_bw * 100;\n\n\tivi->vf = vf;\n\treturn 0;\n}\n\nint qlcnic_sriov_set_vf_spoofchk(struct net_device *netdev, int vf, bool chk)\n{\n\tstruct qlcnic_adapter *adapter = netdev_priv(netdev);\n\tstruct qlcnic_sriov *sriov = adapter->ahw->sriov;\n\tstruct qlcnic_vf_info *vf_info;\n\tstruct qlcnic_vport *vp;\n\n\tif (!qlcnic_sriov_pf_check(adapter))\n\t\treturn -EOPNOTSUPP;\n\n\tif (vf >= sriov->num_vfs)\n\t\treturn -EINVAL;\n\n\tvf_info = &sriov->vf_info[vf];\n\tvp = vf_info->vp;\n\tif (test_bit(QLC_BC_VF_STATE, &vf_info->state)) {\n\t\tnetdev_err(netdev,\n\t\t\t   \"Spoof check change failed for VF %d, as VF driver is loaded. Please unload VF driver and retry the operation\\n\",\n\t\t\t   vf);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tvp->spoofchk = chk;\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}