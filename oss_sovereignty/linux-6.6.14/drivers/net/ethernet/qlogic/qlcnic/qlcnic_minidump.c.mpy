{
  "module_name": "qlcnic_minidump.c",
  "hash_id": "4833a2f37a7b992e4a32a5f958a17e4403158e623d27784d61555536a67321c7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/qlogic/qlcnic/qlcnic_minidump.c",
  "human_readable_source": "\n \n\n#include <net/ip.h>\n\n#include \"qlcnic.h\"\n#include \"qlcnic_hdr.h\"\n#include \"qlcnic_83xx_hw.h\"\n#include \"qlcnic_hw.h\"\n\n#define QLC_83XX_MINIDUMP_FLASH\t\t0x520000\n#define QLC_83XX_OCM_INDEX\t\t\t3\n#define QLC_83XX_PCI_INDEX\t\t\t0\n#define QLC_83XX_DMA_ENGINE_INDEX\t\t8\n\nstatic const u32 qlcnic_ms_read_data[] = {\n\t0x410000A8, 0x410000AC, 0x410000B8, 0x410000BC\n};\n\n#define QLCNIC_DUMP_WCRB\tBIT_0\n#define QLCNIC_DUMP_RWCRB\tBIT_1\n#define QLCNIC_DUMP_ANDCRB\tBIT_2\n#define QLCNIC_DUMP_ORCRB\tBIT_3\n#define QLCNIC_DUMP_POLLCRB\tBIT_4\n#define QLCNIC_DUMP_RD_SAVE\tBIT_5\n#define QLCNIC_DUMP_WRT_SAVED\tBIT_6\n#define QLCNIC_DUMP_MOD_SAVE_ST\tBIT_7\n#define QLCNIC_DUMP_SKIP\tBIT_7\n\n#define QLCNIC_DUMP_MASK_MAX\t0xff\n\nstruct qlcnic_pex_dma_descriptor {\n\tu32\tread_data_size;\n\tu32\tdma_desc_cmd;\n\tu32\tsrc_addr_low;\n\tu32\tsrc_addr_high;\n\tu32\tdma_bus_addr_low;\n\tu32\tdma_bus_addr_high;\n\tu32\trsvd[6];\n} __packed;\n\nstruct qlcnic_common_entry_hdr {\n\tu32     type;\n\tu32     offset;\n\tu32     cap_size;\n#if defined(__LITTLE_ENDIAN)\n\tu8      mask;\n\tu8      rsvd[2];\n\tu8      flags;\n#else\n\tu8      flags;\n\tu8      rsvd[2];\n\tu8      mask;\n#endif\n} __packed;\n\nstruct __crb {\n\tu32\taddr;\n#if defined(__LITTLE_ENDIAN)\n\tu8\tstride;\n\tu8\trsvd1[3];\n#else\n\tu8\trsvd1[3];\n\tu8\tstride;\n#endif\n\tu32\tdata_size;\n\tu32\tno_ops;\n\tu32\trsvd2[4];\n} __packed;\n\nstruct __ctrl {\n\tu32\taddr;\n#if defined(__LITTLE_ENDIAN)\n\tu8\tstride;\n\tu8\tindex_a;\n\tu16\ttimeout;\n#else\n\tu16\ttimeout;\n\tu8\tindex_a;\n\tu8\tstride;\n#endif\n\tu32\tdata_size;\n\tu32\tno_ops;\n#if defined(__LITTLE_ENDIAN)\n\tu8\topcode;\n\tu8\tindex_v;\n\tu8\tshl_val;\n\tu8\tshr_val;\n#else\n\tu8\tshr_val;\n\tu8\tshl_val;\n\tu8\tindex_v;\n\tu8\topcode;\n#endif\n\tu32\tval1;\n\tu32\tval2;\n\tu32\tval3;\n} __packed;\n\nstruct __cache {\n\tu32\taddr;\n#if defined(__LITTLE_ENDIAN)\n\tu16\tstride;\n\tu16\tinit_tag_val;\n#else\n\tu16\tinit_tag_val;\n\tu16\tstride;\n#endif\n\tu32\tsize;\n\tu32\tno_ops;\n\tu32\tctrl_addr;\n\tu32\tctrl_val;\n\tu32\tread_addr;\n#if defined(__LITTLE_ENDIAN)\n\tu8\tread_addr_stride;\n\tu8\tread_addr_num;\n\tu8\trsvd1[2];\n#else\n\tu8\trsvd1[2];\n\tu8\tread_addr_num;\n\tu8\tread_addr_stride;\n#endif\n} __packed;\n\nstruct __ocm {\n\tu8\trsvd[8];\n\tu32\tsize;\n\tu32\tno_ops;\n\tu8\trsvd1[8];\n\tu32\tread_addr;\n\tu32\tread_addr_stride;\n} __packed;\n\nstruct __mem {\n\tu32\tdesc_card_addr;\n\tu32\tdma_desc_cmd;\n\tu32\tstart_dma_cmd;\n\tu32\trsvd[3];\n\tu32\taddr;\n\tu32\tsize;\n} __packed;\n\nstruct __mux {\n\tu32\taddr;\n\tu8\trsvd[4];\n\tu32\tsize;\n\tu32\tno_ops;\n\tu32\tval;\n\tu32\tval_stride;\n\tu32\tread_addr;\n\tu8\trsvd2[4];\n} __packed;\n\nstruct __queue {\n\tu32\tsel_addr;\n#if defined(__LITTLE_ENDIAN)\n\tu16\tstride;\n\tu8\trsvd[2];\n#else\n\tu8\trsvd[2];\n\tu16\tstride;\n#endif\n\tu32\tsize;\n\tu32\tno_ops;\n\tu8\trsvd2[8];\n\tu32\tread_addr;\n#if defined(__LITTLE_ENDIAN)\n\tu8\tread_addr_stride;\n\tu8\tread_addr_cnt;\n\tu8\trsvd3[2];\n#else\n\tu8\trsvd3[2];\n\tu8\tread_addr_cnt;\n\tu8\tread_addr_stride;\n#endif\n} __packed;\n\nstruct __pollrd {\n\tu32\tsel_addr;\n\tu32\tread_addr;\n\tu32\tsel_val;\n#if defined(__LITTLE_ENDIAN)\n\tu16\tsel_val_stride;\n\tu16\tno_ops;\n#else\n\tu16\tno_ops;\n\tu16\tsel_val_stride;\n#endif\n\tu32\tpoll_wait;\n\tu32\tpoll_mask;\n\tu32\tdata_size;\n\tu8\trsvd[4];\n} __packed;\n\nstruct __mux2 {\n\tu32\tsel_addr1;\n\tu32\tsel_addr2;\n\tu32\tsel_val1;\n\tu32\tsel_val2;\n\tu32\tno_ops;\n\tu32\tsel_val_mask;\n\tu32\tread_addr;\n#if defined(__LITTLE_ENDIAN)\n\tu8\tsel_val_stride;\n\tu8\tdata_size;\n\tu8\trsvd[2];\n#else\n\tu8\trsvd[2];\n\tu8\tdata_size;\n\tu8\tsel_val_stride;\n#endif\n} __packed;\n\nstruct __pollrdmwr {\n\tu32\taddr1;\n\tu32\taddr2;\n\tu32\tval1;\n\tu32\tval2;\n\tu32\tpoll_wait;\n\tu32\tpoll_mask;\n\tu32\tmod_mask;\n\tu32\tdata_size;\n} __packed;\n\nstruct qlcnic_dump_entry {\n\tstruct qlcnic_common_entry_hdr hdr;\n\tunion {\n\t\tstruct __crb\t\tcrb;\n\t\tstruct __cache\t\tcache;\n\t\tstruct __ocm\t\tocm;\n\t\tstruct __mem\t\tmem;\n\t\tstruct __mux\t\tmux;\n\t\tstruct __queue\t\tque;\n\t\tstruct __ctrl\t\tctrl;\n\t\tstruct __pollrdmwr\tpollrdmwr;\n\t\tstruct __mux2\t\tmux2;\n\t\tstruct __pollrd\t\tpollrd;\n\t} region;\n} __packed;\n\nenum qlcnic_minidump_opcode {\n\tQLCNIC_DUMP_NOP\t\t= 0,\n\tQLCNIC_DUMP_READ_CRB\t= 1,\n\tQLCNIC_DUMP_READ_MUX\t= 2,\n\tQLCNIC_DUMP_QUEUE\t= 3,\n\tQLCNIC_DUMP_BRD_CONFIG\t= 4,\n\tQLCNIC_DUMP_READ_OCM\t= 6,\n\tQLCNIC_DUMP_PEG_REG\t= 7,\n\tQLCNIC_DUMP_L1_DTAG\t= 8,\n\tQLCNIC_DUMP_L1_ITAG\t= 9,\n\tQLCNIC_DUMP_L1_DATA\t= 11,\n\tQLCNIC_DUMP_L1_INST\t= 12,\n\tQLCNIC_DUMP_L2_DTAG\t= 21,\n\tQLCNIC_DUMP_L2_ITAG\t= 22,\n\tQLCNIC_DUMP_L2_DATA\t= 23,\n\tQLCNIC_DUMP_L2_INST\t= 24,\n\tQLCNIC_DUMP_POLL_RD\t= 35,\n\tQLCNIC_READ_MUX2\t= 36,\n\tQLCNIC_READ_POLLRDMWR\t= 37,\n\tQLCNIC_DUMP_READ_ROM\t= 71,\n\tQLCNIC_DUMP_READ_MEM\t= 72,\n\tQLCNIC_DUMP_READ_CTRL\t= 98,\n\tQLCNIC_DUMP_TLHDR\t= 99,\n\tQLCNIC_DUMP_RDEND\t= 255\n};\n\ninline u32 qlcnic_82xx_get_saved_state(void *t_hdr, u32 index)\n{\n\tstruct qlcnic_82xx_dump_template_hdr *hdr = t_hdr;\n\n\treturn hdr->saved_state[index];\n}\n\ninline void qlcnic_82xx_set_saved_state(void *t_hdr, u32 index,\n\t\t\t\t\tu32 value)\n{\n\tstruct qlcnic_82xx_dump_template_hdr *hdr = t_hdr;\n\n\thdr->saved_state[index] = value;\n}\n\nvoid qlcnic_82xx_cache_tmpl_hdr_values(struct qlcnic_fw_dump *fw_dump)\n{\n\tstruct qlcnic_82xx_dump_template_hdr *hdr;\n\n\thdr = fw_dump->tmpl_hdr;\n\tfw_dump->tmpl_hdr_size = hdr->size;\n\tfw_dump->version = hdr->version;\n\tfw_dump->num_entries = hdr->num_entries;\n\tfw_dump->offset = hdr->offset;\n\n\thdr->drv_cap_mask = hdr->cap_mask;\n\tfw_dump->cap_mask = hdr->cap_mask;\n\n\tfw_dump->use_pex_dma = (hdr->capabilities & BIT_0) ? true : false;\n}\n\ninline u32 qlcnic_82xx_get_cap_size(void *t_hdr, int index)\n{\n\tstruct qlcnic_82xx_dump_template_hdr *hdr = t_hdr;\n\n\treturn hdr->cap_sizes[index];\n}\n\nvoid qlcnic_82xx_set_sys_info(void *t_hdr, int idx, u32 value)\n{\n\tstruct qlcnic_82xx_dump_template_hdr *hdr = t_hdr;\n\n\thdr->sys_info[idx] = value;\n}\n\nvoid qlcnic_82xx_store_cap_mask(void *tmpl_hdr, u32 mask)\n{\n\tstruct qlcnic_82xx_dump_template_hdr *hdr = tmpl_hdr;\n\n\thdr->drv_cap_mask = mask;\n}\n\ninline u32 qlcnic_83xx_get_saved_state(void *t_hdr, u32 index)\n{\n\tstruct qlcnic_83xx_dump_template_hdr *hdr = t_hdr;\n\n\treturn hdr->saved_state[index];\n}\n\ninline void qlcnic_83xx_set_saved_state(void *t_hdr, u32 index,\n\t\t\t\t\tu32 value)\n{\n\tstruct qlcnic_83xx_dump_template_hdr *hdr = t_hdr;\n\n\thdr->saved_state[index] = value;\n}\n\n#define QLCNIC_TEMPLATE_VERSION (0x20001)\n\nvoid qlcnic_83xx_cache_tmpl_hdr_values(struct qlcnic_fw_dump *fw_dump)\n{\n\tstruct qlcnic_83xx_dump_template_hdr *hdr;\n\n\thdr = fw_dump->tmpl_hdr;\n\tfw_dump->tmpl_hdr_size = hdr->size;\n\tfw_dump->version = hdr->version;\n\tfw_dump->num_entries = hdr->num_entries;\n\tfw_dump->offset = hdr->offset;\n\n\thdr->drv_cap_mask = hdr->cap_mask;\n\tfw_dump->cap_mask = hdr->cap_mask;\n\n\tfw_dump->use_pex_dma = (fw_dump->version & 0xfffff) >=\n\t\t\t       QLCNIC_TEMPLATE_VERSION;\n}\n\ninline u32 qlcnic_83xx_get_cap_size(void *t_hdr, int index)\n{\n\tstruct qlcnic_83xx_dump_template_hdr *hdr = t_hdr;\n\n\treturn hdr->cap_sizes[index];\n}\n\nvoid qlcnic_83xx_set_sys_info(void *t_hdr, int idx, u32 value)\n{\n\tstruct qlcnic_83xx_dump_template_hdr *hdr = t_hdr;\n\n\thdr->sys_info[idx] = value;\n}\n\nvoid qlcnic_83xx_store_cap_mask(void *tmpl_hdr, u32 mask)\n{\n\tstruct qlcnic_83xx_dump_template_hdr *hdr;\n\n\thdr = tmpl_hdr;\n\thdr->drv_cap_mask = mask;\n}\n\nstruct qlcnic_dump_operations {\n\tenum qlcnic_minidump_opcode opcode;\n\tu32 (*handler)(struct qlcnic_adapter *, struct qlcnic_dump_entry *,\n\t\t       __le32 *);\n};\n\nstatic u32 qlcnic_dump_crb(struct qlcnic_adapter *adapter,\n\t\t\t   struct qlcnic_dump_entry *entry, __le32 *buffer)\n{\n\tint i;\n\tu32 addr, data;\n\tstruct __crb *crb = &entry->region.crb;\n\n\taddr = crb->addr;\n\n\tfor (i = 0; i < crb->no_ops; i++) {\n\t\tdata = qlcnic_ind_rd(adapter, addr);\n\t\t*buffer++ = cpu_to_le32(addr);\n\t\t*buffer++ = cpu_to_le32(data);\n\t\taddr += crb->stride;\n\t}\n\treturn crb->no_ops * 2 * sizeof(u32);\n}\n\nstatic u32 qlcnic_dump_ctrl(struct qlcnic_adapter *adapter,\n\t\t\t    struct qlcnic_dump_entry *entry, __le32 *buffer)\n{\n\tvoid *hdr = adapter->ahw->fw_dump.tmpl_hdr;\n\tstruct __ctrl *ctr = &entry->region.ctrl;\n\tint i, k, timeout = 0;\n\tu32 addr, data, temp;\n\tu8 no_ops;\n\n\taddr = ctr->addr;\n\tno_ops = ctr->no_ops;\n\n\tfor (i = 0; i < no_ops; i++) {\n\t\tk = 0;\n\t\tfor (k = 0; k < 8; k++) {\n\t\t\tif (!(ctr->opcode & (1 << k)))\n\t\t\t\tcontinue;\n\t\t\tswitch (1 << k) {\n\t\t\tcase QLCNIC_DUMP_WCRB:\n\t\t\t\tqlcnic_ind_wr(adapter, addr, ctr->val1);\n\t\t\t\tbreak;\n\t\t\tcase QLCNIC_DUMP_RWCRB:\n\t\t\t\tdata = qlcnic_ind_rd(adapter, addr);\n\t\t\t\tqlcnic_ind_wr(adapter, addr, data);\n\t\t\t\tbreak;\n\t\t\tcase QLCNIC_DUMP_ANDCRB:\n\t\t\t\tdata = qlcnic_ind_rd(adapter, addr);\n\t\t\t\tqlcnic_ind_wr(adapter, addr,\n\t\t\t\t\t      (data & ctr->val2));\n\t\t\t\tbreak;\n\t\t\tcase QLCNIC_DUMP_ORCRB:\n\t\t\t\tdata = qlcnic_ind_rd(adapter, addr);\n\t\t\t\tqlcnic_ind_wr(adapter, addr,\n\t\t\t\t\t      (data | ctr->val3));\n\t\t\t\tbreak;\n\t\t\tcase QLCNIC_DUMP_POLLCRB:\n\t\t\t\twhile (timeout <= ctr->timeout) {\n\t\t\t\t\tdata = qlcnic_ind_rd(adapter, addr);\n\t\t\t\t\tif ((data & ctr->val2) == ctr->val1)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tusleep_range(1000, 2000);\n\t\t\t\t\ttimeout++;\n\t\t\t\t}\n\t\t\t\tif (timeout > ctr->timeout) {\n\t\t\t\t\tdev_info(&adapter->pdev->dev,\n\t\t\t\t\t\"Timed out, aborting poll CRB\\n\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase QLCNIC_DUMP_RD_SAVE:\n\t\t\t\ttemp = ctr->index_a;\n\t\t\t\tif (temp)\n\t\t\t\t\taddr = qlcnic_get_saved_state(adapter,\n\t\t\t\t\t\t\t\t      hdr,\n\t\t\t\t\t\t\t\t      temp);\n\t\t\t\tdata = qlcnic_ind_rd(adapter, addr);\n\t\t\t\tqlcnic_set_saved_state(adapter, hdr,\n\t\t\t\t\t\t       ctr->index_v, data);\n\t\t\t\tbreak;\n\t\t\tcase QLCNIC_DUMP_WRT_SAVED:\n\t\t\t\ttemp = ctr->index_v;\n\t\t\t\tif (temp)\n\t\t\t\t\tdata = qlcnic_get_saved_state(adapter,\n\t\t\t\t\t\t\t\t      hdr,\n\t\t\t\t\t\t\t\t      temp);\n\t\t\t\telse\n\t\t\t\t\tdata = ctr->val1;\n\n\t\t\t\ttemp = ctr->index_a;\n\t\t\t\tif (temp)\n\t\t\t\t\taddr = qlcnic_get_saved_state(adapter,\n\t\t\t\t\t\t\t\t      hdr,\n\t\t\t\t\t\t\t\t      temp);\n\t\t\t\tqlcnic_ind_wr(adapter, addr, data);\n\t\t\t\tbreak;\n\t\t\tcase QLCNIC_DUMP_MOD_SAVE_ST:\n\t\t\t\tdata = qlcnic_get_saved_state(adapter, hdr,\n\t\t\t\t\t\t\t      ctr->index_v);\n\t\t\t\tdata <<= ctr->shl_val;\n\t\t\t\tdata >>= ctr->shr_val;\n\t\t\t\tif (ctr->val2)\n\t\t\t\t\tdata &= ctr->val2;\n\t\t\t\tdata |= ctr->val3;\n\t\t\t\tdata += ctr->val1;\n\t\t\t\tqlcnic_set_saved_state(adapter, hdr,\n\t\t\t\t\t\t       ctr->index_v, data);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tdev_info(&adapter->pdev->dev,\n\t\t\t\t\t \"Unknown opcode\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\taddr += ctr->stride;\n\t}\n\treturn 0;\n}\n\nstatic u32 qlcnic_dump_mux(struct qlcnic_adapter *adapter,\n\t\t\t   struct qlcnic_dump_entry *entry, __le32 *buffer)\n{\n\tint loop;\n\tu32 val, data = 0;\n\tstruct __mux *mux = &entry->region.mux;\n\n\tval = mux->val;\n\tfor (loop = 0; loop < mux->no_ops; loop++) {\n\t\tqlcnic_ind_wr(adapter, mux->addr, val);\n\t\tdata = qlcnic_ind_rd(adapter, mux->read_addr);\n\t\t*buffer++ = cpu_to_le32(val);\n\t\t*buffer++ = cpu_to_le32(data);\n\t\tval += mux->val_stride;\n\t}\n\treturn 2 * mux->no_ops * sizeof(u32);\n}\n\nstatic u32 qlcnic_dump_que(struct qlcnic_adapter *adapter,\n\t\t\t   struct qlcnic_dump_entry *entry, __le32 *buffer)\n{\n\tint i, loop;\n\tu32 cnt, addr, data, que_id = 0;\n\tstruct __queue *que = &entry->region.que;\n\n\taddr = que->read_addr;\n\tcnt = que->read_addr_cnt;\n\n\tfor (loop = 0; loop < que->no_ops; loop++) {\n\t\tqlcnic_ind_wr(adapter, que->sel_addr, que_id);\n\t\taddr = que->read_addr;\n\t\tfor (i = 0; i < cnt; i++) {\n\t\t\tdata = qlcnic_ind_rd(adapter, addr);\n\t\t\t*buffer++ = cpu_to_le32(data);\n\t\t\taddr += que->read_addr_stride;\n\t\t}\n\t\tque_id += que->stride;\n\t}\n\treturn que->no_ops * cnt * sizeof(u32);\n}\n\nstatic u32 qlcnic_dump_ocm(struct qlcnic_adapter *adapter,\n\t\t\t   struct qlcnic_dump_entry *entry, __le32 *buffer)\n{\n\tint i;\n\tu32 data;\n\tvoid __iomem *addr;\n\tstruct __ocm *ocm = &entry->region.ocm;\n\n\taddr = adapter->ahw->pci_base0 + ocm->read_addr;\n\tfor (i = 0; i < ocm->no_ops; i++) {\n\t\tdata = readl(addr);\n\t\t*buffer++ = cpu_to_le32(data);\n\t\taddr += ocm->read_addr_stride;\n\t}\n\treturn ocm->no_ops * sizeof(u32);\n}\n\nstatic u32 qlcnic_read_rom(struct qlcnic_adapter *adapter,\n\t\t\t   struct qlcnic_dump_entry *entry, __le32 *buffer)\n{\n\tint i, count = 0;\n\tu32 fl_addr, size, val, lck_val, addr;\n\tstruct __mem *rom = &entry->region.mem;\n\n\tfl_addr = rom->addr;\n\tsize = rom->size / 4;\nlock_try:\n\tlck_val = QLC_SHARED_REG_RD32(adapter, QLCNIC_FLASH_LOCK);\n\tif (!lck_val && count < MAX_CTL_CHECK) {\n\t\tusleep_range(10000, 11000);\n\t\tcount++;\n\t\tgoto lock_try;\n\t}\n\tQLC_SHARED_REG_WR32(adapter, QLCNIC_FLASH_LOCK_OWNER,\n\t\t\t    adapter->ahw->pci_func);\n\tfor (i = 0; i < size; i++) {\n\t\taddr = fl_addr & 0xFFFF0000;\n\t\tqlcnic_ind_wr(adapter, FLASH_ROM_WINDOW, addr);\n\t\taddr = LSW(fl_addr) + FLASH_ROM_DATA;\n\t\tval = qlcnic_ind_rd(adapter, addr);\n\t\tfl_addr += 4;\n\t\t*buffer++ = cpu_to_le32(val);\n\t}\n\tQLC_SHARED_REG_RD32(adapter, QLCNIC_FLASH_UNLOCK);\n\treturn rom->size;\n}\n\nstatic u32 qlcnic_dump_l1_cache(struct qlcnic_adapter *adapter,\n\t\t\t\tstruct qlcnic_dump_entry *entry, __le32 *buffer)\n{\n\tint i;\n\tu32 cnt, val, data, addr;\n\tstruct __cache *l1 = &entry->region.cache;\n\n\tval = l1->init_tag_val;\n\n\tfor (i = 0; i < l1->no_ops; i++) {\n\t\tqlcnic_ind_wr(adapter, l1->addr, val);\n\t\tqlcnic_ind_wr(adapter, l1->ctrl_addr, LSW(l1->ctrl_val));\n\t\taddr = l1->read_addr;\n\t\tcnt = l1->read_addr_num;\n\t\twhile (cnt) {\n\t\t\tdata = qlcnic_ind_rd(adapter, addr);\n\t\t\t*buffer++ = cpu_to_le32(data);\n\t\t\taddr += l1->read_addr_stride;\n\t\t\tcnt--;\n\t\t}\n\t\tval += l1->stride;\n\t}\n\treturn l1->no_ops * l1->read_addr_num * sizeof(u32);\n}\n\nstatic u32 qlcnic_dump_l2_cache(struct qlcnic_adapter *adapter,\n\t\t\t\tstruct qlcnic_dump_entry *entry, __le32 *buffer)\n{\n\tint i;\n\tu32 cnt, val, data, addr;\n\tu8 poll_mask, poll_to, time_out = 0;\n\tstruct __cache *l2 = &entry->region.cache;\n\n\tval = l2->init_tag_val;\n\tpoll_mask = LSB(MSW(l2->ctrl_val));\n\tpoll_to = MSB(MSW(l2->ctrl_val));\n\n\tfor (i = 0; i < l2->no_ops; i++) {\n\t\tqlcnic_ind_wr(adapter, l2->addr, val);\n\t\tif (LSW(l2->ctrl_val))\n\t\t\tqlcnic_ind_wr(adapter, l2->ctrl_addr,\n\t\t\t\t      LSW(l2->ctrl_val));\n\t\tif (!poll_mask)\n\t\t\tgoto skip_poll;\n\t\tdo {\n\t\t\tdata = qlcnic_ind_rd(adapter, l2->ctrl_addr);\n\t\t\tif (!(data & poll_mask))\n\t\t\t\tbreak;\n\t\t\tusleep_range(1000, 2000);\n\t\t\ttime_out++;\n\t\t} while (time_out <= poll_to);\n\n\t\tif (time_out > poll_to) {\n\t\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\t\"Timeout exceeded in %s, aborting dump\\n\",\n\t\t\t\t__func__);\n\t\t\treturn -EINVAL;\n\t\t}\nskip_poll:\n\t\taddr = l2->read_addr;\n\t\tcnt = l2->read_addr_num;\n\t\twhile (cnt) {\n\t\t\tdata = qlcnic_ind_rd(adapter, addr);\n\t\t\t*buffer++ = cpu_to_le32(data);\n\t\t\taddr += l2->read_addr_stride;\n\t\t\tcnt--;\n\t\t}\n\t\tval += l2->stride;\n\t}\n\treturn l2->no_ops * l2->read_addr_num * sizeof(u32);\n}\n\nstatic u32 qlcnic_read_memory_test_agent(struct qlcnic_adapter *adapter,\n\t\t\t\t\t struct __mem *mem, __le32 *buffer,\n\t\t\t\t\t int *ret)\n{\n\tu32 addr, data, test;\n\tint i, reg_read;\n\n\treg_read = mem->size;\n\taddr = mem->addr;\n\t \n\tif ((addr & 0xf) || (reg_read%16)) {\n\t\tdev_info(&adapter->pdev->dev,\n\t\t\t \"Unaligned memory addr:0x%x size:0x%x\\n\",\n\t\t\t addr, reg_read);\n\t\t*ret = -EINVAL;\n\t\treturn 0;\n\t}\n\n\tmutex_lock(&adapter->ahw->mem_lock);\n\n\twhile (reg_read != 0) {\n\t\tqlcnic_ind_wr(adapter, QLCNIC_MS_ADDR_LO, addr);\n\t\tqlcnic_ind_wr(adapter, QLCNIC_MS_ADDR_HI, 0);\n\t\tqlcnic_ind_wr(adapter, QLCNIC_MS_CTRL, QLCNIC_TA_START_ENABLE);\n\n\t\tfor (i = 0; i < MAX_CTL_CHECK; i++) {\n\t\t\ttest = qlcnic_ind_rd(adapter, QLCNIC_MS_CTRL);\n\t\t\tif (!(test & TA_CTL_BUSY))\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i == MAX_CTL_CHECK) {\n\t\t\tif (printk_ratelimit()) {\n\t\t\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\t\t\"failed to read through agent\\n\");\n\t\t\t\t*ret = -EIO;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tdata = qlcnic_ind_rd(adapter, qlcnic_ms_read_data[i]);\n\t\t\t*buffer++ = cpu_to_le32(data);\n\t\t}\n\t\taddr += 16;\n\t\treg_read -= 16;\n\t\tret += 16;\n\t\tcond_resched();\n\t}\nout:\n\tmutex_unlock(&adapter->ahw->mem_lock);\n\treturn mem->size;\n}\n\n \n#define QLC_DMA_REG_BASE_ADDR(dma_no)\t(0x77320000 + (dma_no * 0x10000))\n\n \n#define QLC_DMA_CMD_BUFF_ADDR_LOW\t0\n#define QLC_DMA_CMD_BUFF_ADDR_HI\t4\n#define QLC_DMA_CMD_STATUS_CTRL\t\t8\n\nstatic int qlcnic_start_pex_dma(struct qlcnic_adapter *adapter,\n\t\t\t\tstruct __mem *mem)\n{\n\tstruct device *dev = &adapter->pdev->dev;\n\tu32 dma_no, dma_base_addr, temp_addr;\n\tint i, ret, dma_sts;\n\tvoid *tmpl_hdr;\n\n\ttmpl_hdr = adapter->ahw->fw_dump.tmpl_hdr;\n\tdma_no = qlcnic_get_saved_state(adapter, tmpl_hdr,\n\t\t\t\t\tQLC_83XX_DMA_ENGINE_INDEX);\n\tdma_base_addr = QLC_DMA_REG_BASE_ADDR(dma_no);\n\n\ttemp_addr = dma_base_addr + QLC_DMA_CMD_BUFF_ADDR_LOW;\n\tret = qlcnic_ind_wr(adapter, temp_addr, mem->desc_card_addr);\n\tif (ret)\n\t\treturn ret;\n\n\ttemp_addr = dma_base_addr + QLC_DMA_CMD_BUFF_ADDR_HI;\n\tret = qlcnic_ind_wr(adapter, temp_addr, 0);\n\tif (ret)\n\t\treturn ret;\n\n\ttemp_addr = dma_base_addr + QLC_DMA_CMD_STATUS_CTRL;\n\tret = qlcnic_ind_wr(adapter, temp_addr, mem->start_dma_cmd);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\ttemp_addr = dma_base_addr + QLC_DMA_CMD_STATUS_CTRL;\n\tfor (i = 0; i < 400; i++) {\n\t\tdma_sts = qlcnic_ind_rd(adapter, temp_addr);\n\n\t\tif (dma_sts & BIT_1)\n\t\t\tusleep_range(250, 500);\n\t\telse\n\t\t\tbreak;\n\t}\n\n\tif (i >= 400) {\n\t\tdev_info(dev, \"PEX DMA operation timed out\");\n\t\tret = -EIO;\n\t}\n\n\treturn ret;\n}\n\nstatic u32 qlcnic_read_memory_pexdma(struct qlcnic_adapter *adapter,\n\t\t\t\t     struct __mem *mem,\n\t\t\t\t     __le32 *buffer, int *ret)\n{\n\tstruct qlcnic_fw_dump *fw_dump = &adapter->ahw->fw_dump;\n\tu32 temp, dma_base_addr, size = 0, read_size = 0;\n\tstruct qlcnic_pex_dma_descriptor *dma_descr;\n\tstruct device *dev = &adapter->pdev->dev;\n\tdma_addr_t dma_phys_addr;\n\tvoid *dma_buffer;\n\tvoid *tmpl_hdr;\n\n\ttmpl_hdr = fw_dump->tmpl_hdr;\n\n\t \n\ttemp = qlcnic_get_saved_state(adapter, tmpl_hdr,\n\t\t\t\t      QLC_83XX_DMA_ENGINE_INDEX);\n\tdma_base_addr = QLC_DMA_REG_BASE_ADDR(temp);\n\ttemp = qlcnic_ind_rd(adapter,\n\t\t\t     dma_base_addr + QLC_DMA_CMD_STATUS_CTRL);\n\n\tif (!(temp & BIT_31)) {\n\t\tdev_info(dev, \"%s: DMA engine is not available\\n\", __func__);\n\t\t*ret = -EIO;\n\t\treturn 0;\n\t}\n\n\t \n\tdma_descr = kzalloc(sizeof(struct qlcnic_pex_dma_descriptor),\n\t\t\t    GFP_KERNEL);\n\tif (!dma_descr) {\n\t\t*ret = -ENOMEM;\n\t\treturn 0;\n\t}\n\n\t \n\tdma_phys_addr = fw_dump->phys_addr;\n\tdma_buffer = fw_dump->dma_buffer;\n\ttemp = 0;\n\ttemp = mem->dma_desc_cmd & 0xff0f;\n\ttemp |= (adapter->ahw->pci_func & 0xf) << 4;\n\tdma_descr->dma_desc_cmd = (temp << 16) & 0xffff0000;\n\tdma_descr->dma_bus_addr_low = LSD(dma_phys_addr);\n\tdma_descr->dma_bus_addr_high = MSD(dma_phys_addr);\n\tdma_descr->src_addr_high = 0;\n\n\t \n\twhile (read_size < mem->size) {\n\t\tif (mem->size - read_size >= QLC_PEX_DMA_READ_SIZE)\n\t\t\tsize = QLC_PEX_DMA_READ_SIZE;\n\t\telse\n\t\t\tsize = mem->size - read_size;\n\n\t\tdma_descr->src_addr_low = mem->addr + read_size;\n\t\tdma_descr->read_data_size = size;\n\n\t\t \n\t\ttemp = sizeof(struct qlcnic_pex_dma_descriptor) / 16;\n\t\t*ret = qlcnic_ms_mem_write128(adapter, mem->desc_card_addr,\n\t\t\t\t\t      (u32 *)dma_descr, temp);\n\t\tif (*ret) {\n\t\t\tdev_info(dev, \"Failed to write DMA descriptor to MS memory at address 0x%x\\n\",\n\t\t\t\t mem->desc_card_addr);\n\t\t\tgoto free_dma_descr;\n\t\t}\n\n\t\t*ret = qlcnic_start_pex_dma(adapter, mem);\n\t\tif (*ret) {\n\t\t\tdev_info(dev, \"Failed to start PEX DMA operation\\n\");\n\t\t\tgoto free_dma_descr;\n\t\t}\n\n\t\tmemcpy(buffer, dma_buffer, size);\n\t\tbuffer += size / 4;\n\t\tread_size += size;\n\t}\n\nfree_dma_descr:\n\tkfree(dma_descr);\n\n\treturn read_size;\n}\n\nstatic u32 qlcnic_read_memory(struct qlcnic_adapter *adapter,\n\t\t\t      struct qlcnic_dump_entry *entry, __le32 *buffer)\n{\n\tstruct qlcnic_fw_dump *fw_dump = &adapter->ahw->fw_dump;\n\tstruct device *dev = &adapter->pdev->dev;\n\tstruct __mem *mem = &entry->region.mem;\n\tu32 data_size;\n\tint ret = 0;\n\n\tif (fw_dump->use_pex_dma) {\n\t\tdata_size = qlcnic_read_memory_pexdma(adapter, mem, buffer,\n\t\t\t\t\t\t      &ret);\n\t\tif (ret)\n\t\t\tdev_info(dev,\n\t\t\t\t \"Failed to read memory dump using PEX DMA: mask[0x%x]\\n\",\n\t\t\t\t entry->hdr.mask);\n\t\telse\n\t\t\treturn data_size;\n\t}\n\n\tdata_size = qlcnic_read_memory_test_agent(adapter, mem, buffer, &ret);\n\tif (ret) {\n\t\tdev_info(dev,\n\t\t\t \"Failed to read memory dump using test agent method: mask[0x%x]\\n\",\n\t\t\t entry->hdr.mask);\n\t\treturn 0;\n\t} else {\n\t\treturn data_size;\n\t}\n}\n\nstatic u32 qlcnic_dump_nop(struct qlcnic_adapter *adapter,\n\t\t\t   struct qlcnic_dump_entry *entry, __le32 *buffer)\n{\n\tentry->hdr.flags |= QLCNIC_DUMP_SKIP;\n\treturn 0;\n}\n\nstatic int qlcnic_valid_dump_entry(struct device *dev,\n\t\t\t\t   struct qlcnic_dump_entry *entry, u32 size)\n{\n\tint ret = 1;\n\tif (size != entry->hdr.cap_size) {\n\t\tdev_err(dev,\n\t\t\t\"Invalid entry, Type:%d\\tMask:%d\\tSize:%dCap_size:%d\\n\",\n\t\t\tentry->hdr.type, entry->hdr.mask, size,\n\t\t\tentry->hdr.cap_size);\n\t\tret = 0;\n\t}\n\treturn ret;\n}\n\nstatic u32 qlcnic_read_pollrdmwr(struct qlcnic_adapter *adapter,\n\t\t\t\t struct qlcnic_dump_entry *entry,\n\t\t\t\t __le32 *buffer)\n{\n\tstruct __pollrdmwr *poll = &entry->region.pollrdmwr;\n\tu32 data, wait_count, poll_wait, temp;\n\n\tpoll_wait = poll->poll_wait;\n\n\tqlcnic_ind_wr(adapter, poll->addr1, poll->val1);\n\twait_count = 0;\n\n\twhile (wait_count < poll_wait) {\n\t\tdata = qlcnic_ind_rd(adapter, poll->addr1);\n\t\tif ((data & poll->poll_mask) != 0)\n\t\t\tbreak;\n\t\twait_count++;\n\t}\n\n\tif (wait_count == poll_wait) {\n\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\"Timeout exceeded in %s, aborting dump\\n\",\n\t\t\t__func__);\n\t\treturn 0;\n\t}\n\n\tdata = qlcnic_ind_rd(adapter, poll->addr2) & poll->mod_mask;\n\tqlcnic_ind_wr(adapter, poll->addr2, data);\n\tqlcnic_ind_wr(adapter, poll->addr1, poll->val2);\n\twait_count = 0;\n\n\twhile (wait_count < poll_wait) {\n\t\ttemp = qlcnic_ind_rd(adapter, poll->addr1);\n\t\tif ((temp & poll->poll_mask) != 0)\n\t\t\tbreak;\n\t\twait_count++;\n\t}\n\n\t*buffer++ = cpu_to_le32(poll->addr2);\n\t*buffer++ = cpu_to_le32(data);\n\n\treturn 2 * sizeof(u32);\n\n}\n\nstatic u32 qlcnic_read_pollrd(struct qlcnic_adapter *adapter,\n\t\t\t      struct qlcnic_dump_entry *entry, __le32 *buffer)\n{\n\tstruct __pollrd *pollrd = &entry->region.pollrd;\n\tu32 data, wait_count, poll_wait, sel_val;\n\tint i;\n\n\tpoll_wait = pollrd->poll_wait;\n\tsel_val = pollrd->sel_val;\n\n\tfor (i = 0; i < pollrd->no_ops; i++) {\n\t\tqlcnic_ind_wr(adapter, pollrd->sel_addr, sel_val);\n\t\twait_count = 0;\n\t\twhile (wait_count < poll_wait) {\n\t\t\tdata = qlcnic_ind_rd(adapter, pollrd->sel_addr);\n\t\t\tif ((data & pollrd->poll_mask) != 0)\n\t\t\t\tbreak;\n\t\t\twait_count++;\n\t\t}\n\n\t\tif (wait_count == poll_wait) {\n\t\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\t\"Timeout exceeded in %s, aborting dump\\n\",\n\t\t\t\t__func__);\n\t\t\treturn 0;\n\t\t}\n\n\t\tdata = qlcnic_ind_rd(adapter, pollrd->read_addr);\n\t\t*buffer++ = cpu_to_le32(sel_val);\n\t\t*buffer++ = cpu_to_le32(data);\n\t\tsel_val += pollrd->sel_val_stride;\n\t}\n\treturn pollrd->no_ops * (2 * sizeof(u32));\n}\n\nstatic u32 qlcnic_read_mux2(struct qlcnic_adapter *adapter,\n\t\t\t    struct qlcnic_dump_entry *entry, __le32 *buffer)\n{\n\tstruct __mux2 *mux2 = &entry->region.mux2;\n\tu32 data;\n\tu32 t_sel_val, sel_val1, sel_val2;\n\tint i;\n\n\tsel_val1 = mux2->sel_val1;\n\tsel_val2 = mux2->sel_val2;\n\n\tfor (i = 0; i < mux2->no_ops; i++) {\n\t\tqlcnic_ind_wr(adapter, mux2->sel_addr1, sel_val1);\n\t\tt_sel_val = sel_val1 & mux2->sel_val_mask;\n\t\tqlcnic_ind_wr(adapter, mux2->sel_addr2, t_sel_val);\n\t\tdata = qlcnic_ind_rd(adapter, mux2->read_addr);\n\t\t*buffer++ = cpu_to_le32(t_sel_val);\n\t\t*buffer++ = cpu_to_le32(data);\n\t\tqlcnic_ind_wr(adapter, mux2->sel_addr1, sel_val2);\n\t\tt_sel_val = sel_val2 & mux2->sel_val_mask;\n\t\tqlcnic_ind_wr(adapter, mux2->sel_addr2, t_sel_val);\n\t\tdata = qlcnic_ind_rd(adapter, mux2->read_addr);\n\t\t*buffer++ = cpu_to_le32(t_sel_val);\n\t\t*buffer++ = cpu_to_le32(data);\n\t\tsel_val1 += mux2->sel_val_stride;\n\t\tsel_val2 += mux2->sel_val_stride;\n\t}\n\n\treturn mux2->no_ops * (4 * sizeof(u32));\n}\n\nstatic u32 qlcnic_83xx_dump_rom(struct qlcnic_adapter *adapter,\n\t\t\t\tstruct qlcnic_dump_entry *entry, __le32 *buffer)\n{\n\tu32 fl_addr, size;\n\tstruct __mem *rom = &entry->region.mem;\n\n\tfl_addr = rom->addr;\n\tsize = rom->size / 4;\n\n\tif (!qlcnic_83xx_lockless_flash_read32(adapter, fl_addr,\n\t\t\t\t\t       (u8 *)buffer, size))\n\t\treturn rom->size;\n\n\treturn 0;\n}\n\nstatic const struct qlcnic_dump_operations qlcnic_fw_dump_ops[] = {\n\t{QLCNIC_DUMP_NOP, qlcnic_dump_nop},\n\t{QLCNIC_DUMP_READ_CRB, qlcnic_dump_crb},\n\t{QLCNIC_DUMP_READ_MUX, qlcnic_dump_mux},\n\t{QLCNIC_DUMP_QUEUE, qlcnic_dump_que},\n\t{QLCNIC_DUMP_BRD_CONFIG, qlcnic_read_rom},\n\t{QLCNIC_DUMP_READ_OCM, qlcnic_dump_ocm},\n\t{QLCNIC_DUMP_PEG_REG, qlcnic_dump_ctrl},\n\t{QLCNIC_DUMP_L1_DTAG, qlcnic_dump_l1_cache},\n\t{QLCNIC_DUMP_L1_ITAG, qlcnic_dump_l1_cache},\n\t{QLCNIC_DUMP_L1_DATA, qlcnic_dump_l1_cache},\n\t{QLCNIC_DUMP_L1_INST, qlcnic_dump_l1_cache},\n\t{QLCNIC_DUMP_L2_DTAG, qlcnic_dump_l2_cache},\n\t{QLCNIC_DUMP_L2_ITAG, qlcnic_dump_l2_cache},\n\t{QLCNIC_DUMP_L2_DATA, qlcnic_dump_l2_cache},\n\t{QLCNIC_DUMP_L2_INST, qlcnic_dump_l2_cache},\n\t{QLCNIC_DUMP_READ_ROM, qlcnic_read_rom},\n\t{QLCNIC_DUMP_READ_MEM, qlcnic_read_memory},\n\t{QLCNIC_DUMP_READ_CTRL, qlcnic_dump_ctrl},\n\t{QLCNIC_DUMP_TLHDR, qlcnic_dump_nop},\n\t{QLCNIC_DUMP_RDEND, qlcnic_dump_nop},\n};\n\nstatic const struct qlcnic_dump_operations qlcnic_83xx_fw_dump_ops[] = {\n\t{QLCNIC_DUMP_NOP, qlcnic_dump_nop},\n\t{QLCNIC_DUMP_READ_CRB, qlcnic_dump_crb},\n\t{QLCNIC_DUMP_READ_MUX, qlcnic_dump_mux},\n\t{QLCNIC_DUMP_QUEUE, qlcnic_dump_que},\n\t{QLCNIC_DUMP_BRD_CONFIG, qlcnic_83xx_dump_rom},\n\t{QLCNIC_DUMP_READ_OCM, qlcnic_dump_ocm},\n\t{QLCNIC_DUMP_PEG_REG, qlcnic_dump_ctrl},\n\t{QLCNIC_DUMP_L1_DTAG, qlcnic_dump_l1_cache},\n\t{QLCNIC_DUMP_L1_ITAG, qlcnic_dump_l1_cache},\n\t{QLCNIC_DUMP_L1_DATA, qlcnic_dump_l1_cache},\n\t{QLCNIC_DUMP_L1_INST, qlcnic_dump_l1_cache},\n\t{QLCNIC_DUMP_L2_DTAG, qlcnic_dump_l2_cache},\n\t{QLCNIC_DUMP_L2_ITAG, qlcnic_dump_l2_cache},\n\t{QLCNIC_DUMP_L2_DATA, qlcnic_dump_l2_cache},\n\t{QLCNIC_DUMP_L2_INST, qlcnic_dump_l2_cache},\n\t{QLCNIC_DUMP_POLL_RD, qlcnic_read_pollrd},\n\t{QLCNIC_READ_MUX2, qlcnic_read_mux2},\n\t{QLCNIC_READ_POLLRDMWR, qlcnic_read_pollrdmwr},\n\t{QLCNIC_DUMP_READ_ROM, qlcnic_83xx_dump_rom},\n\t{QLCNIC_DUMP_READ_MEM, qlcnic_read_memory},\n\t{QLCNIC_DUMP_READ_CTRL, qlcnic_dump_ctrl},\n\t{QLCNIC_DUMP_TLHDR, qlcnic_dump_nop},\n\t{QLCNIC_DUMP_RDEND, qlcnic_dump_nop},\n};\n\nstatic uint32_t qlcnic_temp_checksum(uint32_t *temp_buffer, u32 temp_size)\n{\n\tuint64_t sum = 0;\n\tint count = temp_size / sizeof(uint32_t);\n\twhile (count-- > 0)\n\t\tsum += *temp_buffer++;\n\twhile (sum >> 32)\n\t\tsum = (sum & 0xFFFFFFFF) + (sum >> 32);\n\treturn ~sum;\n}\n\nstatic int qlcnic_fw_flash_get_minidump_temp(struct qlcnic_adapter *adapter,\n\t\t\t\t\t     u8 *buffer, u32 size)\n{\n\tint ret = 0;\n\n\tif (qlcnic_82xx_check(adapter))\n\t\treturn -EIO;\n\n\tif (qlcnic_83xx_lock_flash(adapter))\n\t\treturn -EIO;\n\n\tret = qlcnic_83xx_lockless_flash_read32(adapter,\n\t\t\t\t\t\tQLC_83XX_MINIDUMP_FLASH,\n\t\t\t\t\t\tbuffer, size / sizeof(u32));\n\n\tqlcnic_83xx_unlock_flash(adapter);\n\n\treturn ret;\n}\n\nstatic int\nqlcnic_fw_flash_get_minidump_temp_size(struct qlcnic_adapter *adapter,\n\t\t\t\t       struct qlcnic_cmd_args *cmd)\n{\n\tstruct qlcnic_83xx_dump_template_hdr tmp_hdr;\n\tu32 size = sizeof(tmp_hdr) / sizeof(u32);\n\tint ret = 0;\n\n\tif (qlcnic_82xx_check(adapter))\n\t\treturn -EIO;\n\n\tif (qlcnic_83xx_lock_flash(adapter))\n\t\treturn -EIO;\n\n\tret = qlcnic_83xx_lockless_flash_read32(adapter,\n\t\t\t\t\t\tQLC_83XX_MINIDUMP_FLASH,\n\t\t\t\t\t\t(u8 *)&tmp_hdr, size);\n\n\tqlcnic_83xx_unlock_flash(adapter);\n\n\tcmd->rsp.arg[2] = tmp_hdr.size;\n\tcmd->rsp.arg[3] = tmp_hdr.version;\n\n\treturn ret;\n}\n\nstatic int qlcnic_fw_get_minidump_temp_size(struct qlcnic_adapter *adapter,\n\t\t\t\t\t    u32 *version, u32 *temp_size,\n\t\t\t\t\t    u8 *use_flash_temp)\n{\n\tint err = 0;\n\tstruct qlcnic_cmd_args cmd;\n\n\tif (qlcnic_alloc_mbx_args(&cmd, adapter, QLCNIC_CMD_TEMP_SIZE))\n\t\treturn -ENOMEM;\n\n\terr = qlcnic_issue_cmd(adapter, &cmd);\n\tif (err != QLCNIC_RCODE_SUCCESS) {\n\t\tif (qlcnic_fw_flash_get_minidump_temp_size(adapter, &cmd)) {\n\t\t\tqlcnic_free_mbx_args(&cmd);\n\t\t\treturn -EIO;\n\t\t}\n\t\t*use_flash_temp = 1;\n\t}\n\n\t*temp_size = cmd.rsp.arg[2];\n\t*version = cmd.rsp.arg[3];\n\tqlcnic_free_mbx_args(&cmd);\n\n\tif (!(*temp_size))\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic int __qlcnic_fw_cmd_get_minidump_temp(struct qlcnic_adapter *adapter,\n\t\t\t\t\t     u32 *buffer, u32 temp_size)\n{\n\tint err = 0, i;\n\tvoid *tmp_addr;\n\t__le32 *tmp_buf;\n\tstruct qlcnic_cmd_args cmd;\n\tdma_addr_t tmp_addr_t = 0;\n\n\ttmp_addr = dma_alloc_coherent(&adapter->pdev->dev, temp_size,\n\t\t\t\t      &tmp_addr_t, GFP_KERNEL);\n\tif (!tmp_addr)\n\t\treturn -ENOMEM;\n\n\tif (qlcnic_alloc_mbx_args(&cmd, adapter, QLCNIC_CMD_GET_TEMP_HDR)) {\n\t\terr = -ENOMEM;\n\t\tgoto free_mem;\n\t}\n\n\tcmd.req.arg[1] = LSD(tmp_addr_t);\n\tcmd.req.arg[2] = MSD(tmp_addr_t);\n\tcmd.req.arg[3] = temp_size;\n\terr = qlcnic_issue_cmd(adapter, &cmd);\n\n\ttmp_buf = tmp_addr;\n\tif (err == QLCNIC_RCODE_SUCCESS) {\n\t\tfor (i = 0; i < temp_size / sizeof(u32); i++)\n\t\t\t*buffer++ = __le32_to_cpu(*tmp_buf++);\n\t}\n\n\tqlcnic_free_mbx_args(&cmd);\n\nfree_mem:\n\tdma_free_coherent(&adapter->pdev->dev, temp_size, tmp_addr, tmp_addr_t);\n\n\treturn err;\n}\n\nint qlcnic_fw_cmd_get_minidump_temp(struct qlcnic_adapter *adapter)\n{\n\tstruct qlcnic_hardware_context *ahw;\n\tstruct qlcnic_fw_dump *fw_dump;\n\tu32 version, csum, *tmp_buf;\n\tu8 use_flash_temp = 0;\n\tu32 temp_size = 0;\n\tvoid *temp_buffer;\n\tint err;\n\n\tahw = adapter->ahw;\n\tfw_dump = &ahw->fw_dump;\n\terr = qlcnic_fw_get_minidump_temp_size(adapter, &version, &temp_size,\n\t\t\t\t\t       &use_flash_temp);\n\tif (err) {\n\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\"Can't get template size %d\\n\", err);\n\t\treturn -EIO;\n\t}\n\n\tfw_dump->tmpl_hdr = vzalloc(temp_size);\n\tif (!fw_dump->tmpl_hdr)\n\t\treturn -ENOMEM;\n\n\ttmp_buf = (u32 *)fw_dump->tmpl_hdr;\n\tif (use_flash_temp)\n\t\tgoto flash_temp;\n\n\terr = __qlcnic_fw_cmd_get_minidump_temp(adapter, tmp_buf, temp_size);\n\n\tif (err) {\nflash_temp:\n\t\terr = qlcnic_fw_flash_get_minidump_temp(adapter, (u8 *)tmp_buf,\n\t\t\t\t\t\t\ttemp_size);\n\n\t\tif (err) {\n\t\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\t\"Failed to get minidump template header %d\\n\",\n\t\t\t\terr);\n\t\t\tvfree(fw_dump->tmpl_hdr);\n\t\t\tfw_dump->tmpl_hdr = NULL;\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\tcsum = qlcnic_temp_checksum((uint32_t *)tmp_buf, temp_size);\n\n\tif (csum) {\n\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\"Template header checksum validation failed\\n\");\n\t\tvfree(fw_dump->tmpl_hdr);\n\t\tfw_dump->tmpl_hdr = NULL;\n\t\treturn -EIO;\n\t}\n\n\tqlcnic_cache_tmpl_hdr_values(adapter, fw_dump);\n\n\tif (fw_dump->use_pex_dma) {\n\t\tfw_dump->dma_buffer = NULL;\n\t\ttemp_buffer = dma_alloc_coherent(&adapter->pdev->dev,\n\t\t\t\t\t\t QLC_PEX_DMA_READ_SIZE,\n\t\t\t\t\t\t &fw_dump->phys_addr,\n\t\t\t\t\t\t GFP_KERNEL);\n\t\tif (!temp_buffer)\n\t\t\tfw_dump->use_pex_dma = false;\n\t\telse\n\t\t\tfw_dump->dma_buffer = temp_buffer;\n\t}\n\n\n\tdev_info(&adapter->pdev->dev,\n\t\t \"Default minidump capture mask 0x%x\\n\",\n\t\t fw_dump->cap_mask);\n\n\tqlcnic_enable_fw_dump_state(adapter);\n\n\treturn 0;\n}\n\nint qlcnic_dump_fw(struct qlcnic_adapter *adapter)\n{\n\tstruct qlcnic_fw_dump *fw_dump = &adapter->ahw->fw_dump;\n\tconst struct qlcnic_dump_operations *fw_dump_ops;\n\tstruct qlcnic_83xx_dump_template_hdr *hdr_83xx;\n\tu32 entry_offset, dump, no_entries, buf_offset = 0;\n\tint i, k, ops_cnt, ops_index, dump_size = 0;\n\tstruct device *dev = &adapter->pdev->dev;\n\tstruct qlcnic_hardware_context *ahw;\n\tstruct qlcnic_dump_entry *entry;\n\tvoid *tmpl_hdr;\n\tu32 ocm_window;\n\t__le32 *buffer;\n\tchar mesg[64];\n\tchar *msg[] = {mesg, NULL};\n\n\tahw = adapter->ahw;\n\ttmpl_hdr = fw_dump->tmpl_hdr;\n\n\t \n\tif (!tmpl_hdr)\n\t\treturn -EIO;\n\n\tif (!qlcnic_check_fw_dump_state(adapter)) {\n\t\tdev_info(&adapter->pdev->dev, \"Dump not enabled\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (fw_dump->clr) {\n\t\tdev_info(&adapter->pdev->dev,\n\t\t\t \"Previous dump not cleared, not capturing dump\\n\");\n\t\treturn -EIO;\n\t}\n\n\tnetif_info(adapter->ahw, drv, adapter->netdev, \"Take FW dump\\n\");\n\t \n\tfor (i = 2, k = 1; (i & QLCNIC_DUMP_MASK_MAX); i <<= 1, k++)\n\t\tif (i & fw_dump->cap_mask)\n\t\t\tdump_size += qlcnic_get_cap_size(adapter, tmpl_hdr, k);\n\n\tif (!dump_size)\n\t\treturn -EIO;\n\n\tfw_dump->data = vzalloc(dump_size);\n\tif (!fw_dump->data)\n\t\treturn -ENOMEM;\n\n\tbuffer = fw_dump->data;\n\tfw_dump->size = dump_size;\n\tno_entries = fw_dump->num_entries;\n\tentry_offset = fw_dump->offset;\n\tqlcnic_set_sys_info(adapter, tmpl_hdr, 0, QLCNIC_DRIVER_VERSION);\n\tqlcnic_set_sys_info(adapter, tmpl_hdr, 1, adapter->fw_version);\n\n\tif (qlcnic_82xx_check(adapter)) {\n\t\tops_cnt = ARRAY_SIZE(qlcnic_fw_dump_ops);\n\t\tfw_dump_ops = qlcnic_fw_dump_ops;\n\t} else {\n\t\thdr_83xx = tmpl_hdr;\n\t\tops_cnt = ARRAY_SIZE(qlcnic_83xx_fw_dump_ops);\n\t\tfw_dump_ops = qlcnic_83xx_fw_dump_ops;\n\t\tocm_window = hdr_83xx->ocm_wnd_reg[ahw->pci_func];\n\t\thdr_83xx->saved_state[QLC_83XX_OCM_INDEX] = ocm_window;\n\t\thdr_83xx->saved_state[QLC_83XX_PCI_INDEX] = ahw->pci_func;\n\t}\n\n\tfor (i = 0; i < no_entries; i++) {\n\t\tentry = tmpl_hdr + entry_offset;\n\t\tif (!(entry->hdr.mask & fw_dump->cap_mask)) {\n\t\t\tentry->hdr.flags |= QLCNIC_DUMP_SKIP;\n\t\t\tentry_offset += entry->hdr.offset;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tops_index = 0;\n\t\twhile (ops_index < ops_cnt) {\n\t\t\tif (entry->hdr.type == fw_dump_ops[ops_index].opcode)\n\t\t\t\tbreak;\n\t\t\tops_index++;\n\t\t}\n\n\t\tif (ops_index == ops_cnt) {\n\t\t\tdev_info(dev, \"Skipping unknown entry opcode %d\\n\",\n\t\t\t\t entry->hdr.type);\n\t\t\tentry->hdr.flags |= QLCNIC_DUMP_SKIP;\n\t\t\tentry_offset += entry->hdr.offset;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tdump = fw_dump_ops[ops_index].handler(adapter, entry, buffer);\n\t\tif (!qlcnic_valid_dump_entry(dev, entry, dump)) {\n\t\t\tentry->hdr.flags |= QLCNIC_DUMP_SKIP;\n\t\t\tentry_offset += entry->hdr.offset;\n\t\t\tcontinue;\n\t\t}\n\n\t\tbuf_offset += entry->hdr.cap_size;\n\t\tentry_offset += entry->hdr.offset;\n\t\tbuffer = fw_dump->data + buf_offset;\n\t\tcond_resched();\n\t}\n\n\tfw_dump->clr = 1;\n\tsnprintf(mesg, sizeof(mesg), \"FW_DUMP=%s\", adapter->netdev->name);\n\tnetdev_info(adapter->netdev,\n\t\t    \"Dump data %d bytes captured, dump data address = %p, template header size %d bytes, template address = %p\\n\",\n\t\t    fw_dump->size, fw_dump->data, fw_dump->tmpl_hdr_size,\n\t\t    fw_dump->tmpl_hdr);\n\t \n\tkobject_uevent_env(&dev->kobj, KOBJ_CHANGE, msg);\n\n\treturn 0;\n}\n\nstatic inline bool\nqlcnic_83xx_md_check_extended_dump_capability(struct qlcnic_adapter *adapter)\n{\n\t \n\treturn ((adapter->pdev->device == PCI_DEVICE_ID_QLOGIC_QLE8830) &&\n\t\t(adapter->ahw->extra_capability[0] &\n\t\t QLCNIC_FW_CAPABILITY_2_EXT_ISCSI_DUMP));\n}\n\nvoid qlcnic_83xx_get_minidump_template(struct qlcnic_adapter *adapter)\n{\n\tu32 prev_version, current_version;\n\tstruct qlcnic_hardware_context *ahw = adapter->ahw;\n\tstruct qlcnic_fw_dump *fw_dump = &ahw->fw_dump;\n\tstruct pci_dev *pdev = adapter->pdev;\n\tbool extended = false;\n\tint ret;\n\n\tprev_version = adapter->fw_version;\n\tcurrent_version = qlcnic_83xx_get_fw_version(adapter);\n\n\tif (fw_dump->tmpl_hdr == NULL || current_version > prev_version) {\n\t\tvfree(fw_dump->tmpl_hdr);\n\t\tfw_dump->tmpl_hdr = NULL;\n\n\t\tif (qlcnic_83xx_md_check_extended_dump_capability(adapter))\n\t\t\textended = !qlcnic_83xx_extend_md_capab(adapter);\n\n\t\tret = qlcnic_fw_cmd_get_minidump_temp(adapter);\n\t\tif (ret)\n\t\t\treturn;\n\n\t\tdev_info(&pdev->dev, \"Supports FW dump capability\\n\");\n\n\t\t \n\t\tif (extended) {\n\t\t\tstruct qlcnic_83xx_dump_template_hdr *hdr;\n\n\t\t\thdr = fw_dump->tmpl_hdr;\n\t\t\tif (!hdr)\n\t\t\t\treturn;\n\t\t\thdr->drv_cap_mask = 0x1f;\n\t\t\tfw_dump->cap_mask = 0x1f;\n\t\t\tdev_info(&pdev->dev,\n\t\t\t\t \"Extended iSCSI dump capability and updated capture mask to 0x1f\\n\");\n\t\t}\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}