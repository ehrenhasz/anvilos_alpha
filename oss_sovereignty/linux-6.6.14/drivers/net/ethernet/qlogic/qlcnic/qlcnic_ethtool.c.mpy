{
  "module_name": "qlcnic_ethtool.c",
  "hash_id": "d00d0a36aef3a169ff295b8403b3daef0eada30e3f043548abae9e0f8758e1af",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/qlogic/qlcnic/qlcnic_ethtool.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/delay.h>\n#include <linux/pci.h>\n#include <linux/io.h>\n#include <linux/netdevice.h>\n#include <linux/ethtool.h>\n\n#include \"qlcnic.h\"\n\nstruct qlcnic_stats {\n\tchar stat_string[ETH_GSTRING_LEN];\n\tint sizeof_stat;\n\tint stat_offset;\n};\n\n#define QLC_SIZEOF(m) sizeof_field(struct qlcnic_adapter, m)\n#define QLC_OFF(m) offsetof(struct qlcnic_adapter, m)\nstatic const u32 qlcnic_fw_dump_level[] = {\n\t0x3, 0x7, 0xf, 0x1f, 0x3f, 0x7f, 0xff\n};\n\nstatic const struct qlcnic_stats qlcnic_gstrings_stats[] = {\n\t{\"xmit_on\", QLC_SIZEOF(stats.xmit_on), QLC_OFF(stats.xmit_on)},\n\t{\"xmit_off\", QLC_SIZEOF(stats.xmit_off), QLC_OFF(stats.xmit_off)},\n\t{\"xmit_called\", QLC_SIZEOF(stats.xmitcalled),\n\t QLC_OFF(stats.xmitcalled)},\n\t{\"xmit_finished\", QLC_SIZEOF(stats.xmitfinished),\n\t QLC_OFF(stats.xmitfinished)},\n\t{\"tx dma map error\", QLC_SIZEOF(stats.tx_dma_map_error),\n\t QLC_OFF(stats.tx_dma_map_error)},\n\t{\"tx_bytes\", QLC_SIZEOF(stats.txbytes), QLC_OFF(stats.txbytes)},\n\t{\"tx_dropped\", QLC_SIZEOF(stats.txdropped), QLC_OFF(stats.txdropped)},\n\t{\"rx dma map error\", QLC_SIZEOF(stats.rx_dma_map_error),\n\t QLC_OFF(stats.rx_dma_map_error)},\n\t{\"rx_pkts\", QLC_SIZEOF(stats.rx_pkts), QLC_OFF(stats.rx_pkts)},\n\t{\"rx_bytes\", QLC_SIZEOF(stats.rxbytes), QLC_OFF(stats.rxbytes)},\n\t{\"rx_dropped\", QLC_SIZEOF(stats.rxdropped), QLC_OFF(stats.rxdropped)},\n\t{\"null rxbuf\", QLC_SIZEOF(stats.null_rxbuf), QLC_OFF(stats.null_rxbuf)},\n\t{\"csummed\", QLC_SIZEOF(stats.csummed), QLC_OFF(stats.csummed)},\n\t{\"lro_pkts\", QLC_SIZEOF(stats.lro_pkts), QLC_OFF(stats.lro_pkts)},\n\t{\"lrobytes\", QLC_SIZEOF(stats.lrobytes), QLC_OFF(stats.lrobytes)},\n\t{\"lso_frames\", QLC_SIZEOF(stats.lso_frames), QLC_OFF(stats.lso_frames)},\n\t{\"encap_lso_frames\", QLC_SIZEOF(stats.encap_lso_frames),\n\t QLC_OFF(stats.encap_lso_frames)},\n\t{\"encap_tx_csummed\", QLC_SIZEOF(stats.encap_tx_csummed),\n\t QLC_OFF(stats.encap_tx_csummed)},\n\t{\"encap_rx_csummed\", QLC_SIZEOF(stats.encap_rx_csummed),\n\t QLC_OFF(stats.encap_rx_csummed)},\n\t{\"skb_alloc_failure\", QLC_SIZEOF(stats.skb_alloc_failure),\n\t QLC_OFF(stats.skb_alloc_failure)},\n\t{\"mac_filter_limit_overrun\", QLC_SIZEOF(stats.mac_filter_limit_overrun),\n\t QLC_OFF(stats.mac_filter_limit_overrun)},\n\t{\"spurious intr\", QLC_SIZEOF(stats.spurious_intr),\n\t QLC_OFF(stats.spurious_intr)},\n\t{\"mbx spurious intr\", QLC_SIZEOF(stats.mbx_spurious_intr),\n\t QLC_OFF(stats.mbx_spurious_intr)},\n};\n\nstatic const char qlcnic_device_gstrings_stats[][ETH_GSTRING_LEN] = {\n\t\"tx unicast frames\",\n\t\"tx multicast frames\",\n\t\"tx broadcast frames\",\n\t\"tx dropped frames\",\n\t\"tx errors\",\n\t\"tx local frames\",\n\t\"tx numbytes\",\n\t\"rx unicast frames\",\n\t\"rx multicast frames\",\n\t\"rx broadcast frames\",\n\t\"rx dropped frames\",\n\t\"rx errors\",\n\t\"rx local frames\",\n\t\"rx numbytes\",\n};\n\nstatic const char qlcnic_83xx_tx_stats_strings[][ETH_GSTRING_LEN] = {\n\t\"ctx_tx_bytes\",\n\t\"ctx_tx_pkts\",\n\t\"ctx_tx_errors\",\n\t\"ctx_tx_dropped_pkts\",\n\t\"ctx_tx_num_buffers\",\n};\n\nstatic const char qlcnic_83xx_mac_stats_strings[][ETH_GSTRING_LEN] = {\n\t\"mac_tx_frames\",\n\t\"mac_tx_bytes\",\n\t\"mac_tx_mcast_pkts\",\n\t\"mac_tx_bcast_pkts\",\n\t\"mac_tx_pause_cnt\",\n\t\"mac_tx_ctrl_pkt\",\n\t\"mac_tx_lt_64b_pkts\",\n\t\"mac_tx_lt_127b_pkts\",\n\t\"mac_tx_lt_255b_pkts\",\n\t\"mac_tx_lt_511b_pkts\",\n\t\"mac_tx_lt_1023b_pkts\",\n\t\"mac_tx_lt_1518b_pkts\",\n\t\"mac_tx_gt_1518b_pkts\",\n\t\"mac_rx_frames\",\n\t\"mac_rx_bytes\",\n\t\"mac_rx_mcast_pkts\",\n\t\"mac_rx_bcast_pkts\",\n\t\"mac_rx_pause_cnt\",\n\t\"mac_rx_ctrl_pkt\",\n\t\"mac_rx_lt_64b_pkts\",\n\t\"mac_rx_lt_127b_pkts\",\n\t\"mac_rx_lt_255b_pkts\",\n\t\"mac_rx_lt_511b_pkts\",\n\t\"mac_rx_lt_1023b_pkts\",\n\t\"mac_rx_lt_1518b_pkts\",\n\t\"mac_rx_gt_1518b_pkts\",\n\t\"mac_rx_length_error\",\n\t\"mac_rx_length_small\",\n\t\"mac_rx_length_large\",\n\t\"mac_rx_jabber\",\n\t\"mac_rx_dropped\",\n\t\"mac_crc_error\",\n\t\"mac_align_error\",\n\t\"eswitch_frames\",\n\t\"eswitch_bytes\",\n\t\"eswitch_multicast_frames\",\n\t\"eswitch_broadcast_frames\",\n\t\"eswitch_unicast_frames\",\n\t\"eswitch_error_free_frames\",\n\t\"eswitch_error_free_bytes\",\n};\n\n#define QLCNIC_STATS_LEN\tARRAY_SIZE(qlcnic_gstrings_stats)\n\nstatic const char qlcnic_tx_queue_stats_strings[][ETH_GSTRING_LEN] = {\n\t\"xmit_on\",\n\t\"xmit_off\",\n\t\"xmit_called\",\n\t\"xmit_finished\",\n\t\"tx_bytes\",\n};\n\n#define QLCNIC_TX_STATS_LEN\tARRAY_SIZE(qlcnic_tx_queue_stats_strings)\n\nstatic const char qlcnic_83xx_rx_stats_strings[][ETH_GSTRING_LEN] = {\n\t\"ctx_rx_bytes\",\n\t\"ctx_rx_pkts\",\n\t\"ctx_lro_pkt_cnt\",\n\t\"ctx_ip_csum_error\",\n\t\"ctx_rx_pkts_wo_ctx\",\n\t\"ctx_rx_pkts_drop_wo_sds_on_card\",\n\t\"ctx_rx_pkts_drop_wo_sds_on_host\",\n\t\"ctx_rx_osized_pkts\",\n\t\"ctx_rx_pkts_dropped_wo_rds\",\n\t\"ctx_rx_unexpected_mcast_pkts\",\n\t\"ctx_invalid_mac_address\",\n\t\"ctx_rx_rds_ring_prim_attempted\",\n\t\"ctx_rx_rds_ring_prim_success\",\n\t\"ctx_num_lro_flows_added\",\n\t\"ctx_num_lro_flows_removed\",\n\t\"ctx_num_lro_flows_active\",\n\t\"ctx_pkts_dropped_unknown\",\n};\n\nstatic const char qlcnic_gstrings_test[][ETH_GSTRING_LEN] = {\n\t\"Register_Test_on_offline\",\n\t\"Link_Test_on_offline\",\n\t\"Interrupt_Test_offline\",\n\t\"Internal_Loopback_offline\",\n\t\"External_Loopback_offline\",\n\t\"EEPROM_Test_offline\"\n};\n\n#define QLCNIC_TEST_LEN\tARRAY_SIZE(qlcnic_gstrings_test)\n\nstatic inline int qlcnic_82xx_statistics(struct qlcnic_adapter *adapter)\n{\n\treturn ARRAY_SIZE(qlcnic_gstrings_stats) +\n\t       ARRAY_SIZE(qlcnic_83xx_mac_stats_strings) +\n\t       QLCNIC_TX_STATS_LEN * adapter->drv_tx_rings;\n}\n\nstatic inline int qlcnic_83xx_statistics(struct qlcnic_adapter *adapter)\n{\n\treturn ARRAY_SIZE(qlcnic_gstrings_stats) +\n\t       ARRAY_SIZE(qlcnic_83xx_tx_stats_strings) +\n\t       ARRAY_SIZE(qlcnic_83xx_mac_stats_strings) +\n\t       ARRAY_SIZE(qlcnic_83xx_rx_stats_strings) +\n\t       QLCNIC_TX_STATS_LEN * adapter->drv_tx_rings;\n}\n\nstatic int qlcnic_dev_statistics_len(struct qlcnic_adapter *adapter)\n{\n\tint len = -1;\n\n\tif (qlcnic_82xx_check(adapter)) {\n\t\tlen = qlcnic_82xx_statistics(adapter);\n\t\tif (adapter->flags & QLCNIC_ESWITCH_ENABLED)\n\t\t\tlen += ARRAY_SIZE(qlcnic_device_gstrings_stats);\n\t} else if (qlcnic_83xx_check(adapter)) {\n\t\tlen = qlcnic_83xx_statistics(adapter);\n\t}\n\n\treturn len;\n}\n\n#define\tQLCNIC_TX_INTR_NOT_CONFIGURED\t0X78563412\n\n#define QLCNIC_MAX_EEPROM_LEN   1024\n\nstatic const u32 diag_registers[] = {\n\tQLCNIC_CMDPEG_STATE,\n\tQLCNIC_RCVPEG_STATE,\n\tQLCNIC_FW_CAPABILITIES,\n\tQLCNIC_CRB_DRV_ACTIVE,\n\tQLCNIC_CRB_DEV_STATE,\n\tQLCNIC_CRB_DRV_STATE,\n\tQLCNIC_CRB_DRV_SCRATCH,\n\tQLCNIC_CRB_DEV_PARTITION_INFO,\n\tQLCNIC_CRB_DRV_IDC_VER,\n\tQLCNIC_PEG_ALIVE_COUNTER,\n\tQLCNIC_PEG_HALT_STATUS1,\n\tQLCNIC_PEG_HALT_STATUS2,\n\t-1\n};\n\n\nstatic const u32 ext_diag_registers[] = {\n\tCRB_XG_STATE_P3P,\n\tISR_INT_STATE_REG,\n\tQLCNIC_CRB_PEG_NET_0+0x3c,\n\tQLCNIC_CRB_PEG_NET_1+0x3c,\n\tQLCNIC_CRB_PEG_NET_2+0x3c,\n\tQLCNIC_CRB_PEG_NET_4+0x3c,\n\t-1\n};\n\n#define QLCNIC_MGMT_API_VERSION\t3\n#define QLCNIC_ETHTOOL_REGS_VER\t4\n\nstatic inline int qlcnic_get_ring_regs_len(struct qlcnic_adapter *adapter)\n{\n\tint ring_regs_cnt = (adapter->drv_tx_rings * 5) +\n\t\t\t    (adapter->max_rds_rings * 2) +\n\t\t\t    (adapter->drv_sds_rings * 3) + 5;\n\treturn ring_regs_cnt * sizeof(u32);\n}\n\nstatic int qlcnic_get_regs_len(struct net_device *dev)\n{\n\tstruct qlcnic_adapter *adapter = netdev_priv(dev);\n\tu32 len;\n\n\tif (qlcnic_83xx_check(adapter))\n\t\tlen = qlcnic_83xx_get_regs_len(adapter);\n\telse\n\t\tlen = sizeof(ext_diag_registers) + sizeof(diag_registers);\n\n\tlen += ((QLCNIC_DEV_INFO_SIZE + 2) * sizeof(u32));\n\tlen += qlcnic_get_ring_regs_len(adapter);\n\treturn len;\n}\n\nstatic int qlcnic_get_eeprom_len(struct net_device *dev)\n{\n\treturn QLCNIC_FLASH_TOTAL_SIZE;\n}\n\nstatic void\nqlcnic_get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *drvinfo)\n{\n\tstruct qlcnic_adapter *adapter = netdev_priv(dev);\n\tu32 fw_major, fw_minor, fw_build;\n\tfw_major = QLC_SHARED_REG_RD32(adapter, QLCNIC_FW_VERSION_MAJOR);\n\tfw_minor = QLC_SHARED_REG_RD32(adapter, QLCNIC_FW_VERSION_MINOR);\n\tfw_build = QLC_SHARED_REG_RD32(adapter, QLCNIC_FW_VERSION_SUB);\n\tsnprintf(drvinfo->fw_version, sizeof(drvinfo->fw_version),\n\t\t\"%d.%d.%d\", fw_major, fw_minor, fw_build);\n\n\tstrscpy(drvinfo->bus_info, pci_name(adapter->pdev),\n\t\tsizeof(drvinfo->bus_info));\n\tstrscpy(drvinfo->driver, qlcnic_driver_name, sizeof(drvinfo->driver));\n\tstrscpy(drvinfo->version, QLCNIC_LINUX_VERSIONID,\n\t\tsizeof(drvinfo->version));\n}\n\nstatic int qlcnic_82xx_get_link_ksettings(struct qlcnic_adapter *adapter,\n\t\t\t\t\t  struct ethtool_link_ksettings *ecmd)\n{\n\tstruct qlcnic_hardware_context *ahw = adapter->ahw;\n\tu32 speed, reg;\n\tint check_sfp_module = 0, err = 0;\n\tu16 pcifn = ahw->pci_func;\n\tu32 supported, advertising;\n\n\t \n\tif (adapter->ahw->port_type == QLCNIC_GBE) {\n\t\tsupported = (SUPPORTED_10baseT_Half |\n\t\t\t\t   SUPPORTED_10baseT_Full |\n\t\t\t\t   SUPPORTED_100baseT_Half |\n\t\t\t\t   SUPPORTED_100baseT_Full |\n\t\t\t\t   SUPPORTED_1000baseT_Half |\n\t\t\t\t   SUPPORTED_1000baseT_Full);\n\n\t\tadvertising = (ADVERTISED_100baseT_Half |\n\t\t\t\t     ADVERTISED_100baseT_Full |\n\t\t\t\t     ADVERTISED_1000baseT_Half |\n\t\t\t\t     ADVERTISED_1000baseT_Full);\n\n\t\tecmd->base.speed = adapter->ahw->link_speed;\n\t\tecmd->base.duplex = adapter->ahw->link_duplex;\n\t\tecmd->base.autoneg = adapter->ahw->link_autoneg;\n\n\t} else if (adapter->ahw->port_type == QLCNIC_XGBE) {\n\t\tu32 val = 0;\n\t\tval = QLCRD32(adapter, QLCNIC_PORT_MODE_ADDR, &err);\n\n\t\tif (val == QLCNIC_PORT_MODE_802_3_AP) {\n\t\t\tsupported = SUPPORTED_1000baseT_Full;\n\t\t\tadvertising = ADVERTISED_1000baseT_Full;\n\t\t} else {\n\t\t\tsupported = SUPPORTED_10000baseT_Full;\n\t\t\tadvertising = ADVERTISED_10000baseT_Full;\n\t\t}\n\n\t\tif (netif_running(adapter->netdev) && ahw->has_link_events) {\n\t\t\tif (ahw->linkup) {\n\t\t\t\treg = QLCRD32(adapter,\n\t\t\t\t\t      P3P_LINK_SPEED_REG(pcifn), &err);\n\t\t\t\tspeed = P3P_LINK_SPEED_VAL(pcifn, reg);\n\t\t\t\tahw->link_speed = speed * P3P_LINK_SPEED_MHZ;\n\t\t\t}\n\n\t\t\tecmd->base.speed = ahw->link_speed;\n\t\t\tecmd->base.autoneg = ahw->link_autoneg;\n\t\t\tecmd->base.duplex = ahw->link_duplex;\n\t\t\tgoto skip;\n\t\t}\n\n\t\tecmd->base.speed = SPEED_UNKNOWN;\n\t\tecmd->base.duplex = DUPLEX_UNKNOWN;\n\t\tecmd->base.autoneg = AUTONEG_DISABLE;\n\t} else\n\t\treturn -EIO;\n\nskip:\n\tecmd->base.phy_address = adapter->ahw->physical_port;\n\n\tswitch (adapter->ahw->board_type) {\n\tcase QLCNIC_BRDTYPE_P3P_REF_QG:\n\tcase QLCNIC_BRDTYPE_P3P_4_GB:\n\tcase QLCNIC_BRDTYPE_P3P_4_GB_MM:\n\t\tsupported |= SUPPORTED_Autoneg;\n\t\tadvertising |= ADVERTISED_Autoneg;\n\t\tfallthrough;\n\tcase QLCNIC_BRDTYPE_P3P_10G_CX4:\n\tcase QLCNIC_BRDTYPE_P3P_10G_CX4_LP:\n\tcase QLCNIC_BRDTYPE_P3P_10000_BASE_T:\n\t\tsupported |= SUPPORTED_TP;\n\t\tadvertising |= ADVERTISED_TP;\n\t\tecmd->base.port = PORT_TP;\n\t\tecmd->base.autoneg =  adapter->ahw->link_autoneg;\n\t\tbreak;\n\tcase QLCNIC_BRDTYPE_P3P_IMEZ:\n\tcase QLCNIC_BRDTYPE_P3P_XG_LOM:\n\tcase QLCNIC_BRDTYPE_P3P_HMEZ:\n\t\tsupported |= SUPPORTED_MII;\n\t\tadvertising |= ADVERTISED_MII;\n\t\tecmd->base.port = PORT_MII;\n\t\tecmd->base.autoneg = AUTONEG_DISABLE;\n\t\tbreak;\n\tcase QLCNIC_BRDTYPE_P3P_10G_SFP_PLUS:\n\tcase QLCNIC_BRDTYPE_P3P_10G_SFP_CT:\n\tcase QLCNIC_BRDTYPE_P3P_10G_SFP_QT:\n\t\tadvertising |= ADVERTISED_TP;\n\t\tsupported |= SUPPORTED_TP;\n\t\tcheck_sfp_module = netif_running(adapter->netdev) &&\n\t\t\t\t   ahw->has_link_events;\n\t\tfallthrough;\n\tcase QLCNIC_BRDTYPE_P3P_10G_XFP:\n\t\tsupported |= SUPPORTED_FIBRE;\n\t\tadvertising |= ADVERTISED_FIBRE;\n\t\tecmd->base.port = PORT_FIBRE;\n\t\tecmd->base.autoneg = AUTONEG_DISABLE;\n\t\tbreak;\n\tcase QLCNIC_BRDTYPE_P3P_10G_TP:\n\t\tif (adapter->ahw->port_type == QLCNIC_XGBE) {\n\t\t\tecmd->base.autoneg = AUTONEG_DISABLE;\n\t\t\tsupported |= (SUPPORTED_FIBRE | SUPPORTED_TP);\n\t\t\tadvertising |=\n\t\t\t\t(ADVERTISED_FIBRE | ADVERTISED_TP);\n\t\t\tecmd->base.port = PORT_FIBRE;\n\t\t\tcheck_sfp_module = netif_running(adapter->netdev) &&\n\t\t\t\t\t   ahw->has_link_events;\n\t\t} else {\n\t\t\tecmd->base.autoneg = AUTONEG_ENABLE;\n\t\t\tsupported |= (SUPPORTED_TP | SUPPORTED_Autoneg);\n\t\t\tadvertising |=\n\t\t\t\t(ADVERTISED_TP | ADVERTISED_Autoneg);\n\t\t\tecmd->base.port = PORT_TP;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&adapter->pdev->dev, \"Unsupported board model %d\\n\",\n\t\t\tadapter->ahw->board_type);\n\t\treturn -EIO;\n\t}\n\n\tif (check_sfp_module) {\n\t\tswitch (adapter->ahw->module_type) {\n\t\tcase LINKEVENT_MODULE_OPTICAL_UNKNOWN:\n\t\tcase LINKEVENT_MODULE_OPTICAL_SRLR:\n\t\tcase LINKEVENT_MODULE_OPTICAL_LRM:\n\t\tcase LINKEVENT_MODULE_OPTICAL_SFP_1G:\n\t\t\tecmd->base.port = PORT_FIBRE;\n\t\t\tbreak;\n\t\tcase LINKEVENT_MODULE_TWINAX_UNSUPPORTED_CABLE:\n\t\tcase LINKEVENT_MODULE_TWINAX_UNSUPPORTED_CABLELEN:\n\t\tcase LINKEVENT_MODULE_TWINAX:\n\t\t\tecmd->base.port = PORT_TP;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tecmd->base.port = PORT_OTHER;\n\t\t}\n\t}\n\n\tethtool_convert_legacy_u32_to_link_mode(ecmd->link_modes.supported,\n\t\t\t\t\t\tsupported);\n\tethtool_convert_legacy_u32_to_link_mode(ecmd->link_modes.advertising,\n\t\t\t\t\t\tadvertising);\n\n\treturn 0;\n}\n\nstatic int qlcnic_get_link_ksettings(struct net_device *dev,\n\t\t\t\t     struct ethtool_link_ksettings *ecmd)\n{\n\tstruct qlcnic_adapter *adapter = netdev_priv(dev);\n\n\tif (qlcnic_82xx_check(adapter))\n\t\treturn qlcnic_82xx_get_link_ksettings(adapter, ecmd);\n\telse if (qlcnic_83xx_check(adapter))\n\t\treturn qlcnic_83xx_get_link_ksettings(adapter, ecmd);\n\n\treturn -EIO;\n}\n\n\nstatic int qlcnic_set_port_config(struct qlcnic_adapter *adapter,\n\t\t\t\t  const struct ethtool_link_ksettings *ecmd)\n{\n\tu32 ret = 0, config = 0;\n\t \n\tif (ecmd->base.duplex)\n\t\tconfig |= 0x1;\n\n\tif (ecmd->base.autoneg)\n\t\tconfig |= 0x2;\n\n\tswitch (ecmd->base.speed) {\n\tcase SPEED_10:\n\t\tconfig |= (0 << 8);\n\t\tbreak;\n\tcase SPEED_100:\n\t\tconfig |= (1 << 8);\n\t\tbreak;\n\tcase SPEED_1000:\n\t\tconfig |= (10 << 8);\n\t\tbreak;\n\tdefault:\n\t\treturn -EIO;\n\t}\n\n\tret = qlcnic_fw_cmd_set_port(adapter, config);\n\n\tif (ret == QLCNIC_RCODE_NOT_SUPPORTED)\n\t\treturn -EOPNOTSUPP;\n\telse if (ret)\n\t\treturn -EIO;\n\treturn ret;\n}\n\nstatic int qlcnic_set_link_ksettings(struct net_device *dev,\n\t\t\t\t     const struct ethtool_link_ksettings *ecmd)\n{\n\tu32 ret = 0;\n\tstruct qlcnic_adapter *adapter = netdev_priv(dev);\n\n\tif (qlcnic_83xx_check(adapter))\n\t\tqlcnic_83xx_get_port_type(adapter);\n\n\tif (adapter->ahw->port_type != QLCNIC_GBE)\n\t\treturn -EOPNOTSUPP;\n\n\tif (qlcnic_83xx_check(adapter))\n\t\tret = qlcnic_83xx_set_link_ksettings(adapter, ecmd);\n\telse\n\t\tret = qlcnic_set_port_config(adapter, ecmd);\n\n\tif (!ret)\n\t\treturn ret;\n\n\tadapter->ahw->link_speed = ecmd->base.speed;\n\tadapter->ahw->link_duplex = ecmd->base.duplex;\n\tadapter->ahw->link_autoneg = ecmd->base.autoneg;\n\n\tif (!netif_running(dev))\n\t\treturn 0;\n\n\tdev->netdev_ops->ndo_stop(dev);\n\treturn dev->netdev_ops->ndo_open(dev);\n}\n\nstatic int qlcnic_82xx_get_registers(struct qlcnic_adapter *adapter,\n\t\t\t\t     u32 *regs_buff)\n{\n\tint i, j = 0, err = 0;\n\n\tfor (i = QLCNIC_DEV_INFO_SIZE + 1; diag_registers[j] != -1; j++, i++)\n\t\tregs_buff[i] = QLC_SHARED_REG_RD32(adapter, diag_registers[j]);\n\tj = 0;\n\twhile (ext_diag_registers[j] != -1)\n\t\tregs_buff[i++] = QLCRD32(adapter, ext_diag_registers[j++],\n\t\t\t\t\t &err);\n\treturn i;\n}\n\nstatic void\nqlcnic_get_regs(struct net_device *dev, struct ethtool_regs *regs, void *p)\n{\n\tstruct qlcnic_adapter *adapter = netdev_priv(dev);\n\tstruct qlcnic_recv_context *recv_ctx = adapter->recv_ctx;\n\tstruct qlcnic_host_sds_ring *sds_ring;\n\tstruct qlcnic_host_rds_ring *rds_rings;\n\tstruct qlcnic_host_tx_ring *tx_ring;\n\tu32 *regs_buff = p;\n\tint ring, i = 0;\n\n\tmemset(p, 0, qlcnic_get_regs_len(dev));\n\n\tregs->version = (QLCNIC_ETHTOOL_REGS_VER << 24) |\n\t\t(adapter->ahw->revision_id << 16) | (adapter->pdev)->device;\n\n\tregs_buff[0] = (0xcafe0000 | (QLCNIC_DEV_INFO_SIZE & 0xffff));\n\tregs_buff[1] = QLCNIC_MGMT_API_VERSION;\n\n\tif (adapter->ahw->capabilities & QLC_83XX_ESWITCH_CAPABILITY)\n\t\tregs_buff[2] = adapter->ahw->max_vnic_func;\n\n\tif (qlcnic_82xx_check(adapter))\n\t\ti = qlcnic_82xx_get_registers(adapter, regs_buff);\n\telse\n\t\ti = qlcnic_83xx_get_registers(adapter, regs_buff);\n\n\tif (!test_bit(__QLCNIC_DEV_UP, &adapter->state))\n\t\treturn;\n\n\t \n\tregs_buff[i++] = 0xFFEFCDAB;\n\n\tregs_buff[i++] = adapter->drv_tx_rings;  \n\tfor (ring = 0; ring < adapter->drv_tx_rings; ring++) {\n\t\ttx_ring = &adapter->tx_ring[ring];\n\t\tregs_buff[i++] = le32_to_cpu(*(tx_ring->hw_consumer));\n\t\tregs_buff[i++] = tx_ring->sw_consumer;\n\t\tregs_buff[i++] = readl(tx_ring->crb_cmd_producer);\n\t\tregs_buff[i++] = tx_ring->producer;\n\t\tif (tx_ring->crb_intr_mask)\n\t\t\tregs_buff[i++] = readl(tx_ring->crb_intr_mask);\n\t\telse\n\t\t\tregs_buff[i++] = QLCNIC_TX_INTR_NOT_CONFIGURED;\n\t}\n\n\tregs_buff[i++] = adapter->max_rds_rings;  \n\tfor (ring = 0; ring < adapter->max_rds_rings; ring++) {\n\t\trds_rings = &recv_ctx->rds_rings[ring];\n\t\tregs_buff[i++] = readl(rds_rings->crb_rcv_producer);\n\t\tregs_buff[i++] = rds_rings->producer;\n\t}\n\n\tregs_buff[i++] = adapter->drv_sds_rings;  \n\tfor (ring = 0; ring < adapter->drv_sds_rings; ring++) {\n\t\tsds_ring = &(recv_ctx->sds_rings[ring]);\n\t\tregs_buff[i++] = readl(sds_ring->crb_sts_consumer);\n\t\tregs_buff[i++] = sds_ring->consumer;\n\t\tregs_buff[i++] = readl(sds_ring->crb_intr_mask);\n\t}\n}\n\nstatic u32 qlcnic_test_link(struct net_device *dev)\n{\n\tstruct qlcnic_adapter *adapter = netdev_priv(dev);\n\tint err = 0;\n\tu32 val;\n\n\tif (qlcnic_83xx_check(adapter)) {\n\t\tval = qlcnic_83xx_test_link(adapter);\n\t\treturn (val & 1) ? 0 : 1;\n\t}\n\tval = QLCRD32(adapter, CRB_XG_STATE_P3P, &err);\n\tif (err == -EIO)\n\t\treturn err;\n\tval = XG_LINK_STATE_P3P(adapter->ahw->pci_func, val);\n\treturn (val == XG_LINK_UP_P3P) ? 0 : 1;\n}\n\nstatic int\nqlcnic_get_eeprom(struct net_device *dev, struct ethtool_eeprom *eeprom,\n\t\t      u8 *bytes)\n{\n\tstruct qlcnic_adapter *adapter = netdev_priv(dev);\n\tint offset;\n\tint ret = -1;\n\n\tif (qlcnic_83xx_check(adapter))\n\t\treturn 0;\n\tif (eeprom->len == 0)\n\t\treturn -EINVAL;\n\n\teeprom->magic = (adapter->pdev)->vendor |\n\t\t\t((adapter->pdev)->device << 16);\n\toffset = eeprom->offset;\n\n\tif (qlcnic_82xx_check(adapter))\n\t\tret = qlcnic_rom_fast_read_words(adapter, offset, bytes,\n\t\t\t\t\t\t eeprom->len);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic void\nqlcnic_get_ringparam(struct net_device *dev,\n\t\t     struct ethtool_ringparam *ring,\n\t\t     struct kernel_ethtool_ringparam *kernel_ring,\n\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct qlcnic_adapter *adapter = netdev_priv(dev);\n\n\tring->rx_pending = adapter->num_rxd;\n\tring->rx_jumbo_pending = adapter->num_jumbo_rxd;\n\tring->tx_pending = adapter->num_txd;\n\n\tring->rx_max_pending = adapter->max_rxd;\n\tring->rx_jumbo_max_pending = adapter->max_jumbo_rxd;\n\tring->tx_max_pending = MAX_CMD_DESCRIPTORS;\n}\n\nstatic u32\nqlcnic_validate_ringparam(u32 val, u32 min, u32 max, char *r_name)\n{\n\tu32 num_desc;\n\tnum_desc = max(val, min);\n\tnum_desc = min(num_desc, max);\n\tnum_desc = roundup_pow_of_two(num_desc);\n\n\tif (val != num_desc) {\n\t\tprintk(KERN_INFO \"%s: setting %s ring size %d instead of %d\\n\",\n\t\t       qlcnic_driver_name, r_name, num_desc, val);\n\t}\n\n\treturn num_desc;\n}\n\nstatic int\nqlcnic_set_ringparam(struct net_device *dev,\n\t\t     struct ethtool_ringparam *ring,\n\t\t     struct kernel_ethtool_ringparam *kernel_ring,\n\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct qlcnic_adapter *adapter = netdev_priv(dev);\n\tu16 num_rxd, num_jumbo_rxd, num_txd;\n\n\tif (ring->rx_mini_pending)\n\t\treturn -EOPNOTSUPP;\n\n\tnum_rxd = qlcnic_validate_ringparam(ring->rx_pending,\n\t\t\tMIN_RCV_DESCRIPTORS, adapter->max_rxd, \"rx\");\n\n\tnum_jumbo_rxd = qlcnic_validate_ringparam(ring->rx_jumbo_pending,\n\t\t\tMIN_JUMBO_DESCRIPTORS, adapter->max_jumbo_rxd,\n\t\t\t\t\t\t\"rx jumbo\");\n\n\tnum_txd = qlcnic_validate_ringparam(ring->tx_pending,\n\t\t\tMIN_CMD_DESCRIPTORS, MAX_CMD_DESCRIPTORS, \"tx\");\n\n\tif (num_rxd == adapter->num_rxd && num_txd == adapter->num_txd &&\n\t\t\tnum_jumbo_rxd == adapter->num_jumbo_rxd)\n\t\treturn 0;\n\n\tadapter->num_rxd = num_rxd;\n\tadapter->num_jumbo_rxd = num_jumbo_rxd;\n\tadapter->num_txd = num_txd;\n\n\treturn qlcnic_reset_context(adapter);\n}\n\nstatic int qlcnic_validate_ring_count(struct qlcnic_adapter *adapter,\n\t\t\t\t      u8 rx_ring, u8 tx_ring)\n{\n\tif (rx_ring == 0 || tx_ring == 0)\n\t\treturn -EINVAL;\n\n\tif (rx_ring != 0) {\n\t\tif (rx_ring > adapter->max_sds_rings) {\n\t\t\tnetdev_err(adapter->netdev,\n\t\t\t\t   \"Invalid ring count, SDS ring count %d should not be greater than max %d driver sds rings.\\n\",\n\t\t\t\t   rx_ring, adapter->max_sds_rings);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (tx_ring != 0) {\n\t\tif (tx_ring > adapter->max_tx_rings) {\n\t\t\tnetdev_err(adapter->netdev,\n\t\t\t\t   \"Invalid ring count, Tx ring count %d should not be greater than max %d driver Tx rings.\\n\",\n\t\t\t\t   tx_ring, adapter->max_tx_rings);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void qlcnic_get_channels(struct net_device *dev,\n\t\tstruct ethtool_channels *channel)\n{\n\tstruct qlcnic_adapter *adapter = netdev_priv(dev);\n\n\tchannel->max_rx = adapter->max_sds_rings;\n\tchannel->max_tx = adapter->max_tx_rings;\n\tchannel->rx_count = adapter->drv_sds_rings;\n\tchannel->tx_count = adapter->drv_tx_rings;\n}\n\nstatic int qlcnic_set_channels(struct net_device *dev,\n\t\t\t       struct ethtool_channels *channel)\n{\n\tstruct qlcnic_adapter *adapter = netdev_priv(dev);\n\tint err;\n\n\tif (!(adapter->flags & QLCNIC_MSIX_ENABLED)) {\n\t\tnetdev_err(dev, \"No RSS/TSS support in non MSI-X mode\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (channel->other_count || channel->combined_count)\n\t\treturn -EINVAL;\n\n\terr = qlcnic_validate_ring_count(adapter, channel->rx_count,\n\t\t\t\t\t channel->tx_count);\n\tif (err)\n\t\treturn err;\n\n\tif (adapter->drv_sds_rings != channel->rx_count) {\n\t\terr = qlcnic_validate_rings(adapter, channel->rx_count,\n\t\t\t\t\t    QLCNIC_RX_QUEUE);\n\t\tif (err) {\n\t\t\tnetdev_err(dev, \"Unable to configure %u SDS rings\\n\",\n\t\t\t\t   channel->rx_count);\n\t\t\treturn err;\n\t\t}\n\t\tadapter->drv_rss_rings = channel->rx_count;\n\t}\n\n\tif (adapter->drv_tx_rings != channel->tx_count) {\n\t\terr = qlcnic_validate_rings(adapter, channel->tx_count,\n\t\t\t\t\t    QLCNIC_TX_QUEUE);\n\t\tif (err) {\n\t\t\tnetdev_err(dev, \"Unable to configure %u Tx rings\\n\",\n\t\t\t\t   channel->tx_count);\n\t\t\treturn err;\n\t\t}\n\t\tadapter->drv_tss_rings = channel->tx_count;\n\t}\n\n\tadapter->flags |= QLCNIC_TSS_RSS;\n\n\terr = qlcnic_setup_rings(adapter);\n\tnetdev_info(dev, \"Allocated %d SDS rings and %d Tx rings\\n\",\n\t\t    adapter->drv_sds_rings, adapter->drv_tx_rings);\n\n\treturn err;\n}\n\nstatic void\nqlcnic_get_pauseparam(struct net_device *netdev,\n\t\t\t  struct ethtool_pauseparam *pause)\n{\n\tstruct qlcnic_adapter *adapter = netdev_priv(netdev);\n\tint port = adapter->ahw->physical_port;\n\tint err = 0;\n\t__u32 val;\n\n\tif (qlcnic_83xx_check(adapter)) {\n\t\tqlcnic_83xx_get_pauseparam(adapter, pause);\n\t\treturn;\n\t}\n\tif (adapter->ahw->port_type == QLCNIC_GBE) {\n\t\tif ((port < 0) || (port > QLCNIC_NIU_MAX_GBE_PORTS))\n\t\t\treturn;\n\t\t \n\t\tval = QLCRD32(adapter, QLCNIC_NIU_GB_MAC_CONFIG_0(port), &err);\n\t\tif (err == -EIO)\n\t\t\treturn;\n\t\tpause->rx_pause = qlcnic_gb_get_rx_flowctl(val);\n\t\tval = QLCRD32(adapter, QLCNIC_NIU_GB_PAUSE_CTL, &err);\n\t\tif (err == -EIO)\n\t\t\treturn;\n\t\tswitch (port) {\n\t\tcase 0:\n\t\t\tpause->tx_pause = !(qlcnic_gb_get_gb0_mask(val));\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tpause->tx_pause = !(qlcnic_gb_get_gb1_mask(val));\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tpause->tx_pause = !(qlcnic_gb_get_gb2_mask(val));\n\t\t\tbreak;\n\t\tcase 3:\n\t\tdefault:\n\t\t\tpause->tx_pause = !(qlcnic_gb_get_gb3_mask(val));\n\t\t\tbreak;\n\t\t}\n\t} else if (adapter->ahw->port_type == QLCNIC_XGBE) {\n\t\tif ((port < 0) || (port > QLCNIC_NIU_MAX_XG_PORTS))\n\t\t\treturn;\n\t\tpause->rx_pause = 1;\n\t\tval = QLCRD32(adapter, QLCNIC_NIU_XG_PAUSE_CTL, &err);\n\t\tif (err == -EIO)\n\t\t\treturn;\n\t\tif (port == 0)\n\t\t\tpause->tx_pause = !(qlcnic_xg_get_xg0_mask(val));\n\t\telse\n\t\t\tpause->tx_pause = !(qlcnic_xg_get_xg1_mask(val));\n\t} else {\n\t\tdev_err(&netdev->dev, \"Unknown board type: %x\\n\",\n\t\t\t\t\tadapter->ahw->port_type);\n\t}\n}\n\nstatic int\nqlcnic_set_pauseparam(struct net_device *netdev,\n\t\t\t  struct ethtool_pauseparam *pause)\n{\n\tstruct qlcnic_adapter *adapter = netdev_priv(netdev);\n\tint port = adapter->ahw->physical_port;\n\tint err = 0;\n\t__u32 val;\n\n\tif (qlcnic_83xx_check(adapter))\n\t\treturn qlcnic_83xx_set_pauseparam(adapter, pause);\n\n\t \n\tif (adapter->ahw->port_type == QLCNIC_GBE) {\n\t\tif ((port < 0) || (port > QLCNIC_NIU_MAX_GBE_PORTS))\n\t\t\treturn -EIO;\n\t\t \n\t\tval = QLCRD32(adapter, QLCNIC_NIU_GB_MAC_CONFIG_0(port), &err);\n\t\tif (err == -EIO)\n\t\t\treturn err;\n\n\t\tif (pause->rx_pause)\n\t\t\tqlcnic_gb_rx_flowctl(val);\n\t\telse\n\t\t\tqlcnic_gb_unset_rx_flowctl(val);\n\n\t\tQLCWR32(adapter, QLCNIC_NIU_GB_MAC_CONFIG_0(port),\n\t\t\t\tval);\n\t\tQLCWR32(adapter, QLCNIC_NIU_GB_MAC_CONFIG_0(port), val);\n\t\t \n\t\tval = QLCRD32(adapter, QLCNIC_NIU_GB_PAUSE_CTL, &err);\n\t\tif (err == -EIO)\n\t\t\treturn err;\n\t\tswitch (port) {\n\t\tcase 0:\n\t\t\tif (pause->tx_pause)\n\t\t\t\tqlcnic_gb_unset_gb0_mask(val);\n\t\t\telse\n\t\t\t\tqlcnic_gb_set_gb0_mask(val);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif (pause->tx_pause)\n\t\t\t\tqlcnic_gb_unset_gb1_mask(val);\n\t\t\telse\n\t\t\t\tqlcnic_gb_set_gb1_mask(val);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tif (pause->tx_pause)\n\t\t\t\tqlcnic_gb_unset_gb2_mask(val);\n\t\t\telse\n\t\t\t\tqlcnic_gb_set_gb2_mask(val);\n\t\t\tbreak;\n\t\tcase 3:\n\t\tdefault:\n\t\t\tif (pause->tx_pause)\n\t\t\t\tqlcnic_gb_unset_gb3_mask(val);\n\t\t\telse\n\t\t\t\tqlcnic_gb_set_gb3_mask(val);\n\t\t\tbreak;\n\t\t}\n\t\tQLCWR32(adapter, QLCNIC_NIU_GB_PAUSE_CTL, val);\n\t} else if (adapter->ahw->port_type == QLCNIC_XGBE) {\n\t\tif (!pause->rx_pause || pause->autoneg)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tif ((port < 0) || (port > QLCNIC_NIU_MAX_XG_PORTS))\n\t\t\treturn -EIO;\n\n\t\tval = QLCRD32(adapter, QLCNIC_NIU_XG_PAUSE_CTL, &err);\n\t\tif (err == -EIO)\n\t\t\treturn err;\n\t\tif (port == 0) {\n\t\t\tif (pause->tx_pause)\n\t\t\t\tqlcnic_xg_unset_xg0_mask(val);\n\t\t\telse\n\t\t\t\tqlcnic_xg_set_xg0_mask(val);\n\t\t} else {\n\t\t\tif (pause->tx_pause)\n\t\t\t\tqlcnic_xg_unset_xg1_mask(val);\n\t\t\telse\n\t\t\t\tqlcnic_xg_set_xg1_mask(val);\n\t\t}\n\t\tQLCWR32(adapter, QLCNIC_NIU_XG_PAUSE_CTL, val);\n\t} else {\n\t\tdev_err(&netdev->dev, \"Unknown board type: %x\\n\",\n\t\t\t\tadapter->ahw->port_type);\n\t}\n\treturn 0;\n}\n\nstatic int qlcnic_reg_test(struct net_device *dev)\n{\n\tstruct qlcnic_adapter *adapter = netdev_priv(dev);\n\tu32 data_read;\n\tint err = 0;\n\n\tif (qlcnic_83xx_check(adapter))\n\t\treturn qlcnic_83xx_reg_test(adapter);\n\n\tdata_read = QLCRD32(adapter, QLCNIC_PCIX_PH_REG(0), &err);\n\tif (err == -EIO)\n\t\treturn err;\n\tif ((data_read & 0xffff) != adapter->pdev->vendor)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic int qlcnic_eeprom_test(struct net_device *dev)\n{\n\tstruct qlcnic_adapter *adapter = netdev_priv(dev);\n\n\tif (qlcnic_82xx_check(adapter))\n\t\treturn 0;\n\n\treturn qlcnic_83xx_flash_test(adapter);\n}\n\nstatic int qlcnic_get_sset_count(struct net_device *dev, int sset)\n{\n\n\tstruct qlcnic_adapter *adapter = netdev_priv(dev);\n\tswitch (sset) {\n\tcase ETH_SS_TEST:\n\t\treturn QLCNIC_TEST_LEN;\n\tcase ETH_SS_STATS:\n\t\treturn qlcnic_dev_statistics_len(adapter);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int qlcnic_irq_test(struct net_device *netdev)\n{\n\tstruct qlcnic_adapter *adapter = netdev_priv(netdev);\n\tstruct qlcnic_hardware_context *ahw = adapter->ahw;\n\tstruct qlcnic_cmd_args cmd;\n\tint ret, drv_sds_rings = adapter->drv_sds_rings;\n\tint drv_tx_rings = adapter->drv_tx_rings;\n\n\tif (qlcnic_83xx_check(adapter))\n\t\treturn qlcnic_83xx_interrupt_test(netdev);\n\n\tif (test_and_set_bit(__QLCNIC_RESETTING, &adapter->state))\n\t\treturn -EIO;\n\n\tret = qlcnic_diag_alloc_res(netdev, QLCNIC_INTERRUPT_TEST);\n\tif (ret)\n\t\tgoto clear_diag_irq;\n\n\tahw->diag_cnt = 0;\n\tret = qlcnic_alloc_mbx_args(&cmd, adapter, QLCNIC_CMD_INTRPT_TEST);\n\tif (ret)\n\t\tgoto free_diag_res;\n\n\tcmd.req.arg[1] = ahw->pci_func;\n\tret = qlcnic_issue_cmd(adapter, &cmd);\n\tif (ret)\n\t\tgoto done;\n\n\tusleep_range(1000, 12000);\n\tret = !ahw->diag_cnt;\n\ndone:\n\tqlcnic_free_mbx_args(&cmd);\n\nfree_diag_res:\n\tqlcnic_diag_free_res(netdev, drv_sds_rings);\n\nclear_diag_irq:\n\tadapter->drv_sds_rings = drv_sds_rings;\n\tadapter->drv_tx_rings = drv_tx_rings;\n\tclear_bit(__QLCNIC_RESETTING, &adapter->state);\n\n\treturn ret;\n}\n\n#define QLCNIC_ILB_PKT_SIZE\t\t64\n#define QLCNIC_NUM_ILB_PKT\t\t16\n#define QLCNIC_ILB_MAX_RCV_LOOP\t\t10\n#define QLCNIC_LB_PKT_POLL_DELAY_MSEC\t1\n#define QLCNIC_LB_PKT_POLL_COUNT\t20\n\nstatic void qlcnic_create_loopback_buff(unsigned char *data, u8 mac[])\n{\n\tstatic const unsigned char random_data[] = {0xa8, 0x06, 0x45, 0x00};\n\n\tmemset(data, 0x4e, QLCNIC_ILB_PKT_SIZE);\n\n\tmemcpy(data, mac, ETH_ALEN);\n\tmemcpy(data + ETH_ALEN, mac, ETH_ALEN);\n\n\tmemcpy(data + 2 * ETH_ALEN, random_data, sizeof(random_data));\n}\n\nint qlcnic_check_loopback_buff(unsigned char *data, u8 mac[])\n{\n\tunsigned char buff[QLCNIC_ILB_PKT_SIZE];\n\tqlcnic_create_loopback_buff(buff, mac);\n\treturn memcmp(data, buff, QLCNIC_ILB_PKT_SIZE);\n}\n\nint qlcnic_do_lb_test(struct qlcnic_adapter *adapter, u8 mode)\n{\n\tstruct qlcnic_recv_context *recv_ctx = adapter->recv_ctx;\n\tstruct qlcnic_host_sds_ring *sds_ring = &recv_ctx->sds_rings[0];\n\tstruct sk_buff *skb;\n\tint i, loop, cnt = 0;\n\n\tfor (i = 0; i < QLCNIC_NUM_ILB_PKT; i++) {\n\t\tskb = netdev_alloc_skb(adapter->netdev, QLCNIC_ILB_PKT_SIZE);\n\t\tif (!skb)\n\t\t\tgoto error;\n\t\tqlcnic_create_loopback_buff(skb->data, adapter->mac_addr);\n\t\tskb_put(skb, QLCNIC_ILB_PKT_SIZE);\n\t\tadapter->ahw->diag_cnt = 0;\n\t\tqlcnic_xmit_frame(skb, adapter->netdev);\n\t\tloop = 0;\n\n\t\tdo {\n\t\t\tmsleep(QLCNIC_LB_PKT_POLL_DELAY_MSEC);\n\t\t\tqlcnic_process_rcv_ring_diag(sds_ring);\n\t\t\tif (loop++ > QLCNIC_LB_PKT_POLL_COUNT)\n\t\t\t\tbreak;\n\t\t} while (!adapter->ahw->diag_cnt);\n\n\t\tdev_kfree_skb_any(skb);\n\n\t\tif (!adapter->ahw->diag_cnt)\n\t\t\tdev_warn(&adapter->pdev->dev,\n\t\t\t\t \"LB Test: packet #%d was not received\\n\",\n\t\t\t\t i + 1);\n\t\telse\n\t\t\tcnt++;\n\t}\n\tif (cnt != i) {\nerror:\n\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\"LB Test: failed, TX[%d], RX[%d]\\n\", i, cnt);\n\t\tif (mode != QLCNIC_ILB_MODE)\n\t\t\tdev_warn(&adapter->pdev->dev,\n\t\t\t\t \"WARNING: Please check loopback cable\\n\");\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int qlcnic_loopback_test(struct net_device *netdev, u8 mode)\n{\n\tstruct qlcnic_adapter *adapter = netdev_priv(netdev);\n\tint drv_tx_rings = adapter->drv_tx_rings;\n\tint drv_sds_rings = adapter->drv_sds_rings;\n\tstruct qlcnic_host_sds_ring *sds_ring;\n\tstruct qlcnic_hardware_context *ahw = adapter->ahw;\n\tint loop = 0;\n\tint ret;\n\n\tif (qlcnic_83xx_check(adapter))\n\t\treturn qlcnic_83xx_loopback_test(netdev, mode);\n\n\tif (!(ahw->capabilities & QLCNIC_FW_CAPABILITY_MULTI_LOOPBACK)) {\n\t\tdev_info(&adapter->pdev->dev,\n\t\t\t \"Firmware do not support loopback test\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tdev_warn(&adapter->pdev->dev, \"%s loopback test in progress\\n\",\n\t\t mode == QLCNIC_ILB_MODE ? \"internal\" : \"external\");\n\tif (ahw->op_mode == QLCNIC_NON_PRIV_FUNC) {\n\t\tdev_warn(&adapter->pdev->dev,\n\t\t\t \"Loopback test not supported in nonprivileged mode\\n\");\n\t\treturn 0;\n\t}\n\n\tif (test_and_set_bit(__QLCNIC_RESETTING, &adapter->state))\n\t\treturn -EBUSY;\n\n\tret = qlcnic_diag_alloc_res(netdev, QLCNIC_LOOPBACK_TEST);\n\tif (ret)\n\t\tgoto clear_it;\n\n\tsds_ring = &adapter->recv_ctx->sds_rings[0];\n\tret = qlcnic_set_lb_mode(adapter, mode);\n\tif (ret)\n\t\tgoto free_res;\n\n\tahw->diag_cnt = 0;\n\tdo {\n\t\tmsleep(500);\n\t\tqlcnic_process_rcv_ring_diag(sds_ring);\n\t\tif (loop++ > QLCNIC_ILB_MAX_RCV_LOOP) {\n\t\t\tnetdev_info(netdev,\n\t\t\t\t    \"Firmware didn't sent link up event to loopback request\\n\");\n\t\t\tret = -ETIMEDOUT;\n\t\t\tgoto free_res;\n\t\t} else if (adapter->ahw->diag_cnt) {\n\t\t\tret = adapter->ahw->diag_cnt;\n\t\t\tgoto free_res;\n\t\t}\n\t} while (!QLCNIC_IS_LB_CONFIGURED(ahw->loopback_state));\n\n\tret = qlcnic_do_lb_test(adapter, mode);\n\n\tqlcnic_clear_lb_mode(adapter, mode);\n\n free_res:\n\tqlcnic_diag_free_res(netdev, drv_sds_rings);\n\n clear_it:\n\tadapter->drv_sds_rings = drv_sds_rings;\n\tadapter->drv_tx_rings = drv_tx_rings;\n\tclear_bit(__QLCNIC_RESETTING, &adapter->state);\n\treturn ret;\n}\n\nstatic void\nqlcnic_diag_test(struct net_device *dev, struct ethtool_test *eth_test,\n\t\t     u64 *data)\n{\n\tmemset(data, 0, sizeof(u64) * QLCNIC_TEST_LEN);\n\n\tdata[0] = qlcnic_reg_test(dev);\n\tif (data[0])\n\t\teth_test->flags |= ETH_TEST_FL_FAILED;\n\n\tdata[1] = (u64) qlcnic_test_link(dev);\n\tif (data[1])\n\t\teth_test->flags |= ETH_TEST_FL_FAILED;\n\n\tif (eth_test->flags & ETH_TEST_FL_OFFLINE) {\n\t\tdata[2] = qlcnic_irq_test(dev);\n\t\tif (data[2])\n\t\t\teth_test->flags |= ETH_TEST_FL_FAILED;\n\n\t\tdata[3] = qlcnic_loopback_test(dev, QLCNIC_ILB_MODE);\n\t\tif (data[3])\n\t\t\teth_test->flags |= ETH_TEST_FL_FAILED;\n\n\t\tif (eth_test->flags & ETH_TEST_FL_EXTERNAL_LB) {\n\t\t\tdata[4] = qlcnic_loopback_test(dev, QLCNIC_ELB_MODE);\n\t\t\tif (data[4])\n\t\t\t\teth_test->flags |= ETH_TEST_FL_FAILED;\n\t\t\teth_test->flags |= ETH_TEST_FL_EXTERNAL_LB_DONE;\n\t\t}\n\n\t\tdata[5] = qlcnic_eeprom_test(dev);\n\t\tif (data[5])\n\t\t\teth_test->flags |= ETH_TEST_FL_FAILED;\n\t}\n}\n\nstatic void\nqlcnic_get_strings(struct net_device *dev, u32 stringset, u8 *data)\n{\n\tstruct qlcnic_adapter *adapter = netdev_priv(dev);\n\tint index, i, num_stats;\n\n\tswitch (stringset) {\n\tcase ETH_SS_TEST:\n\t\tmemcpy(data, *qlcnic_gstrings_test,\n\t\t       QLCNIC_TEST_LEN * ETH_GSTRING_LEN);\n\t\tbreak;\n\tcase ETH_SS_STATS:\n\t\tnum_stats = ARRAY_SIZE(qlcnic_tx_queue_stats_strings);\n\t\tfor (i = 0; i < adapter->drv_tx_rings; i++) {\n\t\t\tfor (index = 0; index < num_stats; index++) {\n\t\t\t\tsprintf(data, \"tx_queue_%d %s\", i,\n\t\t\t\t\tqlcnic_tx_queue_stats_strings[index]);\n\t\t\t\tdata += ETH_GSTRING_LEN;\n\t\t\t}\n\t\t}\n\n\t\tfor (index = 0; index < QLCNIC_STATS_LEN; index++) {\n\t\t\tmemcpy(data + index * ETH_GSTRING_LEN,\n\t\t\t       qlcnic_gstrings_stats[index].stat_string,\n\t\t\t       ETH_GSTRING_LEN);\n\t\t}\n\n\t\tif (qlcnic_83xx_check(adapter)) {\n\t\t\tnum_stats = ARRAY_SIZE(qlcnic_83xx_tx_stats_strings);\n\t\t\tfor (i = 0; i < num_stats; i++, index++)\n\t\t\t\tmemcpy(data + index * ETH_GSTRING_LEN,\n\t\t\t\t       qlcnic_83xx_tx_stats_strings[i],\n\t\t\t\t       ETH_GSTRING_LEN);\n\t\t\tnum_stats = ARRAY_SIZE(qlcnic_83xx_mac_stats_strings);\n\t\t\tfor (i = 0; i < num_stats; i++, index++)\n\t\t\t\tmemcpy(data + index * ETH_GSTRING_LEN,\n\t\t\t\t       qlcnic_83xx_mac_stats_strings[i],\n\t\t\t\t       ETH_GSTRING_LEN);\n\t\t\tnum_stats = ARRAY_SIZE(qlcnic_83xx_rx_stats_strings);\n\t\t\tfor (i = 0; i < num_stats; i++, index++)\n\t\t\t\tmemcpy(data + index * ETH_GSTRING_LEN,\n\t\t\t\t       qlcnic_83xx_rx_stats_strings[i],\n\t\t\t\t       ETH_GSTRING_LEN);\n\t\t\treturn;\n\t\t} else {\n\t\t\tnum_stats = ARRAY_SIZE(qlcnic_83xx_mac_stats_strings);\n\t\t\tfor (i = 0; i < num_stats; i++, index++)\n\t\t\t\tmemcpy(data + index * ETH_GSTRING_LEN,\n\t\t\t\t       qlcnic_83xx_mac_stats_strings[i],\n\t\t\t\t       ETH_GSTRING_LEN);\n\t\t}\n\t\tif (!(adapter->flags & QLCNIC_ESWITCH_ENABLED))\n\t\t\treturn;\n\t\tnum_stats = ARRAY_SIZE(qlcnic_device_gstrings_stats);\n\t\tfor (i = 0; i < num_stats; index++, i++) {\n\t\t\tmemcpy(data + index * ETH_GSTRING_LEN,\n\t\t\t       qlcnic_device_gstrings_stats[i],\n\t\t\t       ETH_GSTRING_LEN);\n\t\t}\n\t}\n}\n\nstatic u64 *qlcnic_fill_stats(u64 *data, void *stats, int type)\n{\n\tif (type == QLCNIC_MAC_STATS) {\n\t\tstruct qlcnic_mac_statistics *mac_stats =\n\t\t\t\t\t(struct qlcnic_mac_statistics *)stats;\n\t\t*data++ = QLCNIC_FILL_STATS(mac_stats->mac_tx_frames);\n\t\t*data++ = QLCNIC_FILL_STATS(mac_stats->mac_tx_bytes);\n\t\t*data++ = QLCNIC_FILL_STATS(mac_stats->mac_tx_mcast_pkts);\n\t\t*data++ = QLCNIC_FILL_STATS(mac_stats->mac_tx_bcast_pkts);\n\t\t*data++ = QLCNIC_FILL_STATS(mac_stats->mac_tx_pause_cnt);\n\t\t*data++ = QLCNIC_FILL_STATS(mac_stats->mac_tx_ctrl_pkt);\n\t\t*data++ = QLCNIC_FILL_STATS(mac_stats->mac_tx_lt_64b_pkts);\n\t\t*data++ = QLCNIC_FILL_STATS(mac_stats->mac_tx_lt_127b_pkts);\n\t\t*data++ = QLCNIC_FILL_STATS(mac_stats->mac_tx_lt_255b_pkts);\n\t\t*data++ = QLCNIC_FILL_STATS(mac_stats->mac_tx_lt_511b_pkts);\n\t\t*data++ = QLCNIC_FILL_STATS(mac_stats->mac_tx_lt_1023b_pkts);\n\t\t*data++ = QLCNIC_FILL_STATS(mac_stats->mac_tx_lt_1518b_pkts);\n\t\t*data++ = QLCNIC_FILL_STATS(mac_stats->mac_tx_gt_1518b_pkts);\n\t\t*data++ = QLCNIC_FILL_STATS(mac_stats->mac_rx_frames);\n\t\t*data++ = QLCNIC_FILL_STATS(mac_stats->mac_rx_bytes);\n\t\t*data++ = QLCNIC_FILL_STATS(mac_stats->mac_rx_mcast_pkts);\n\t\t*data++ = QLCNIC_FILL_STATS(mac_stats->mac_rx_bcast_pkts);\n\t\t*data++ = QLCNIC_FILL_STATS(mac_stats->mac_rx_pause_cnt);\n\t\t*data++ = QLCNIC_FILL_STATS(mac_stats->mac_rx_ctrl_pkt);\n\t\t*data++ = QLCNIC_FILL_STATS(mac_stats->mac_rx_lt_64b_pkts);\n\t\t*data++ = QLCNIC_FILL_STATS(mac_stats->mac_rx_lt_127b_pkts);\n\t\t*data++ = QLCNIC_FILL_STATS(mac_stats->mac_rx_lt_255b_pkts);\n\t\t*data++ = QLCNIC_FILL_STATS(mac_stats->mac_rx_lt_511b_pkts);\n\t\t*data++ = QLCNIC_FILL_STATS(mac_stats->mac_rx_lt_1023b_pkts);\n\t\t*data++ = QLCNIC_FILL_STATS(mac_stats->mac_rx_lt_1518b_pkts);\n\t\t*data++ = QLCNIC_FILL_STATS(mac_stats->mac_rx_gt_1518b_pkts);\n\t\t*data++ = QLCNIC_FILL_STATS(mac_stats->mac_rx_length_error);\n\t\t*data++ = QLCNIC_FILL_STATS(mac_stats->mac_rx_length_small);\n\t\t*data++ = QLCNIC_FILL_STATS(mac_stats->mac_rx_length_large);\n\t\t*data++ = QLCNIC_FILL_STATS(mac_stats->mac_rx_jabber);\n\t\t*data++ = QLCNIC_FILL_STATS(mac_stats->mac_rx_dropped);\n\t\t*data++ = QLCNIC_FILL_STATS(mac_stats->mac_rx_crc_error);\n\t\t*data++ = QLCNIC_FILL_STATS(mac_stats->mac_align_error);\n\t} else if (type == QLCNIC_ESW_STATS) {\n\t\tstruct __qlcnic_esw_statistics *esw_stats =\n\t\t\t\t(struct __qlcnic_esw_statistics *)stats;\n\t\t*data++ = QLCNIC_FILL_STATS(esw_stats->unicast_frames);\n\t\t*data++ = QLCNIC_FILL_STATS(esw_stats->multicast_frames);\n\t\t*data++ = QLCNIC_FILL_STATS(esw_stats->broadcast_frames);\n\t\t*data++ = QLCNIC_FILL_STATS(esw_stats->dropped_frames);\n\t\t*data++ = QLCNIC_FILL_STATS(esw_stats->errors);\n\t\t*data++ = QLCNIC_FILL_STATS(esw_stats->local_frames);\n\t\t*data++ = QLCNIC_FILL_STATS(esw_stats->numbytes);\n\t}\n\treturn data;\n}\n\nvoid qlcnic_update_stats(struct qlcnic_adapter *adapter)\n{\n\tstruct qlcnic_tx_queue_stats tx_stats;\n\tstruct qlcnic_host_tx_ring *tx_ring;\n\tint ring;\n\n\tmemset(&tx_stats, 0, sizeof(tx_stats));\n\tfor (ring = 0; ring < adapter->drv_tx_rings; ring++) {\n\t\ttx_ring = &adapter->tx_ring[ring];\n\t\ttx_stats.xmit_on += tx_ring->tx_stats.xmit_on;\n\t\ttx_stats.xmit_off += tx_ring->tx_stats.xmit_off;\n\t\ttx_stats.xmit_called += tx_ring->tx_stats.xmit_called;\n\t\ttx_stats.xmit_finished += tx_ring->tx_stats.xmit_finished;\n\t\ttx_stats.tx_bytes += tx_ring->tx_stats.tx_bytes;\n\t}\n\n\tadapter->stats.xmit_on = tx_stats.xmit_on;\n\tadapter->stats.xmit_off = tx_stats.xmit_off;\n\tadapter->stats.xmitcalled = tx_stats.xmit_called;\n\tadapter->stats.xmitfinished = tx_stats.xmit_finished;\n\tadapter->stats.txbytes = tx_stats.tx_bytes;\n}\n\nstatic u64 *qlcnic_fill_tx_queue_stats(u64 *data, void *stats)\n{\n\tstruct qlcnic_host_tx_ring *tx_ring;\n\n\ttx_ring = (struct qlcnic_host_tx_ring *)stats;\n\n\t*data++ = QLCNIC_FILL_STATS(tx_ring->tx_stats.xmit_on);\n\t*data++ = QLCNIC_FILL_STATS(tx_ring->tx_stats.xmit_off);\n\t*data++ = QLCNIC_FILL_STATS(tx_ring->tx_stats.xmit_called);\n\t*data++ = QLCNIC_FILL_STATS(tx_ring->tx_stats.xmit_finished);\n\t*data++ = QLCNIC_FILL_STATS(tx_ring->tx_stats.tx_bytes);\n\n\treturn data;\n}\n\nstatic void qlcnic_get_ethtool_stats(struct net_device *dev,\n\t\t\t\t     struct ethtool_stats *stats, u64 *data)\n{\n\tstruct qlcnic_adapter *adapter = netdev_priv(dev);\n\tstruct qlcnic_host_tx_ring *tx_ring;\n\tstruct qlcnic_esw_statistics port_stats;\n\tstruct qlcnic_mac_statistics mac_stats;\n\tint index, ret, length, size, ring;\n\tchar *p;\n\n\tmemset(data, 0, stats->n_stats * sizeof(u64));\n\n\tfor (ring = 0; ring < adapter->drv_tx_rings; ring++) {\n\t\tif (adapter->is_up == QLCNIC_ADAPTER_UP_MAGIC) {\n\t\t\ttx_ring = &adapter->tx_ring[ring];\n\t\t\tdata = qlcnic_fill_tx_queue_stats(data, tx_ring);\n\t\t\tqlcnic_update_stats(adapter);\n\t\t} else {\n\t\t\tdata += QLCNIC_TX_STATS_LEN;\n\t\t}\n\t}\n\n\tlength = QLCNIC_STATS_LEN;\n\tfor (index = 0; index < length; index++) {\n\t\tp = (char *)adapter + qlcnic_gstrings_stats[index].stat_offset;\n\t\tsize = qlcnic_gstrings_stats[index].sizeof_stat;\n\t\t*data++ = (size == sizeof(u64)) ? (*(u64 *)p) : ((*(u32 *)p));\n\t}\n\n\tif (qlcnic_83xx_check(adapter)) {\n\t\tif (adapter->ahw->linkup)\n\t\t\tqlcnic_83xx_get_stats(adapter, data);\n\t\treturn;\n\t} else {\n\t\t \n\t\tmemset(&mac_stats, 0, sizeof(struct qlcnic_mac_statistics));\n\t\tqlcnic_get_mac_stats(adapter, &mac_stats);\n\t\tdata = qlcnic_fill_stats(data, &mac_stats, QLCNIC_MAC_STATS);\n\t}\n\n\tif (!(adapter->flags & QLCNIC_ESWITCH_ENABLED))\n\t\treturn;\n\n\tmemset(&port_stats, 0, sizeof(struct qlcnic_esw_statistics));\n\tret = qlcnic_get_port_stats(adapter, adapter->ahw->pci_func,\n\t\t\tQLCNIC_QUERY_RX_COUNTER, &port_stats.rx);\n\tif (ret)\n\t\treturn;\n\n\tdata = qlcnic_fill_stats(data, &port_stats.rx, QLCNIC_ESW_STATS);\n\tret = qlcnic_get_port_stats(adapter, adapter->ahw->pci_func,\n\t\t\tQLCNIC_QUERY_TX_COUNTER, &port_stats.tx);\n\tif (ret)\n\t\treturn;\n\n\tqlcnic_fill_stats(data, &port_stats.tx, QLCNIC_ESW_STATS);\n}\n\nstatic int qlcnic_set_led(struct net_device *dev,\n\t\t\t  enum ethtool_phys_id_state state)\n{\n\tstruct qlcnic_adapter *adapter = netdev_priv(dev);\n\tint drv_sds_rings = adapter->drv_sds_rings;\n\tint err = -EIO, active = 1;\n\n\tif (qlcnic_83xx_check(adapter))\n\t\treturn qlcnic_83xx_set_led(dev, state);\n\n\tif (adapter->ahw->op_mode == QLCNIC_NON_PRIV_FUNC) {\n\t\tnetdev_warn(dev, \"LED test not supported for non \"\n\t\t\t\t\"privilege function\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tswitch (state) {\n\tcase ETHTOOL_ID_ACTIVE:\n\t\tif (test_and_set_bit(__QLCNIC_LED_ENABLE, &adapter->state))\n\t\t\treturn -EBUSY;\n\n\t\tif (test_bit(__QLCNIC_RESETTING, &adapter->state))\n\t\t\tbreak;\n\n\t\tif (!test_bit(__QLCNIC_DEV_UP, &adapter->state)) {\n\t\t\tif (qlcnic_diag_alloc_res(dev, QLCNIC_LED_TEST))\n\t\t\t\tbreak;\n\t\t\tset_bit(__QLCNIC_DIAG_RES_ALLOC, &adapter->state);\n\t\t}\n\n\t\tif (adapter->nic_ops->config_led(adapter, 1, 0xf) == 0) {\n\t\t\terr = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\"Failed to set LED blink state.\\n\");\n\t\tbreak;\n\n\tcase ETHTOOL_ID_INACTIVE:\n\t\tactive = 0;\n\n\t\tif (test_bit(__QLCNIC_RESETTING, &adapter->state))\n\t\t\tbreak;\n\n\t\tif (!test_bit(__QLCNIC_DEV_UP, &adapter->state)) {\n\t\t\tif (qlcnic_diag_alloc_res(dev, QLCNIC_LED_TEST))\n\t\t\t\tbreak;\n\t\t\tset_bit(__QLCNIC_DIAG_RES_ALLOC, &adapter->state);\n\t\t}\n\n\t\tif (adapter->nic_ops->config_led(adapter, 0, 0xf))\n\t\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\t\"Failed to reset LED blink state.\\n\");\n\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (test_and_clear_bit(__QLCNIC_DIAG_RES_ALLOC, &adapter->state))\n\t\tqlcnic_diag_free_res(dev, drv_sds_rings);\n\n\tif (!active || err)\n\t\tclear_bit(__QLCNIC_LED_ENABLE, &adapter->state);\n\n\treturn err;\n}\n\nstatic void\nqlcnic_get_wol(struct net_device *dev, struct ethtool_wolinfo *wol)\n{\n\tstruct qlcnic_adapter *adapter = netdev_priv(dev);\n\tu32 wol_cfg;\n\tint err = 0;\n\n\tif (qlcnic_83xx_check(adapter))\n\t\treturn;\n\twol->supported = 0;\n\twol->wolopts = 0;\n\n\twol_cfg = QLCRD32(adapter, QLCNIC_WOL_CONFIG_NV, &err);\n\tif (err == -EIO)\n\t\treturn;\n\tif (wol_cfg & (1UL << adapter->portnum))\n\t\twol->supported |= WAKE_MAGIC;\n\n\twol_cfg = QLCRD32(adapter, QLCNIC_WOL_CONFIG, &err);\n\tif (wol_cfg & (1UL << adapter->portnum))\n\t\twol->wolopts |= WAKE_MAGIC;\n}\n\nstatic int\nqlcnic_set_wol(struct net_device *dev, struct ethtool_wolinfo *wol)\n{\n\tstruct qlcnic_adapter *adapter = netdev_priv(dev);\n\tu32 wol_cfg;\n\tint err = 0;\n\n\tif (qlcnic_83xx_check(adapter))\n\t\treturn -EOPNOTSUPP;\n\tif (wol->wolopts & ~WAKE_MAGIC)\n\t\treturn -EINVAL;\n\n\twol_cfg = QLCRD32(adapter, QLCNIC_WOL_CONFIG_NV, &err);\n\tif (err == -EIO)\n\t\treturn err;\n\tif (!(wol_cfg & (1 << adapter->portnum)))\n\t\treturn -EOPNOTSUPP;\n\n\twol_cfg = QLCRD32(adapter, QLCNIC_WOL_CONFIG, &err);\n\tif (err == -EIO)\n\t\treturn err;\n\tif (wol->wolopts & WAKE_MAGIC)\n\t\twol_cfg |= 1UL << adapter->portnum;\n\telse\n\t\twol_cfg &= ~(1UL << adapter->portnum);\n\n\tQLCWR32(adapter, QLCNIC_WOL_CONFIG, wol_cfg);\n\n\treturn 0;\n}\n\n \nstatic int qlcnic_set_intr_coalesce(struct net_device *netdev,\n\t\t\t\t    struct ethtool_coalesce *ethcoal,\n\t\t\t\t    struct kernel_ethtool_coalesce *kernel_coal,\n\t\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct qlcnic_adapter *adapter = netdev_priv(netdev);\n\tint err;\n\n\tif (!test_bit(__QLCNIC_DEV_UP, &adapter->state))\n\t\treturn -EINVAL;\n\n\t \n\tif (ethcoal->rx_coalesce_usecs > 0xffff ||\n\t    ethcoal->rx_max_coalesced_frames > 0xffff ||\n\t    ethcoal->tx_coalesce_usecs > 0xffff ||\n\t    ethcoal->tx_max_coalesced_frames > 0xffff)\n\t\treturn -EINVAL;\n\n\terr = qlcnic_config_intr_coalesce(adapter, ethcoal);\n\n\treturn err;\n}\n\nstatic int qlcnic_get_intr_coalesce(struct net_device *netdev,\n\t\t\t\t    struct ethtool_coalesce *ethcoal,\n\t\t\t\t    struct kernel_ethtool_coalesce *kernel_coal,\n\t\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct qlcnic_adapter *adapter = netdev_priv(netdev);\n\n\tif (adapter->is_up != QLCNIC_ADAPTER_UP_MAGIC)\n\t\treturn -EINVAL;\n\n\tethcoal->rx_coalesce_usecs = adapter->ahw->coal.rx_time_us;\n\tethcoal->rx_max_coalesced_frames = adapter->ahw->coal.rx_packets;\n\tethcoal->tx_coalesce_usecs = adapter->ahw->coal.tx_time_us;\n\tethcoal->tx_max_coalesced_frames = adapter->ahw->coal.tx_packets;\n\n\treturn 0;\n}\n\nstatic u32 qlcnic_get_msglevel(struct net_device *netdev)\n{\n\tstruct qlcnic_adapter *adapter = netdev_priv(netdev);\n\n\treturn adapter->ahw->msg_enable;\n}\n\nstatic void qlcnic_set_msglevel(struct net_device *netdev, u32 msglvl)\n{\n\tstruct qlcnic_adapter *adapter = netdev_priv(netdev);\n\n\tadapter->ahw->msg_enable = msglvl;\n}\n\nint qlcnic_enable_fw_dump_state(struct qlcnic_adapter *adapter)\n{\n\tstruct qlcnic_fw_dump *fw_dump = &adapter->ahw->fw_dump;\n\tu32 val;\n\n\tif (qlcnic_84xx_check(adapter)) {\n\t\tif (qlcnic_83xx_lock_driver(adapter))\n\t\t\treturn -EBUSY;\n\n\t\tval = QLCRDX(adapter->ahw, QLC_83XX_IDC_CTRL);\n\t\tval &= ~QLC_83XX_IDC_DISABLE_FW_DUMP;\n\t\tQLCWRX(adapter->ahw, QLC_83XX_IDC_CTRL, val);\n\n\t\tqlcnic_83xx_unlock_driver(adapter);\n\t} else {\n\t\tfw_dump->enable = true;\n\t}\n\n\tdev_info(&adapter->pdev->dev, \"FW dump enabled\\n\");\n\n\treturn 0;\n}\n\nstatic int qlcnic_disable_fw_dump_state(struct qlcnic_adapter *adapter)\n{\n\tstruct qlcnic_fw_dump *fw_dump = &adapter->ahw->fw_dump;\n\tu32 val;\n\n\tif (qlcnic_84xx_check(adapter)) {\n\t\tif (qlcnic_83xx_lock_driver(adapter))\n\t\t\treturn -EBUSY;\n\n\t\tval = QLCRDX(adapter->ahw, QLC_83XX_IDC_CTRL);\n\t\tval |= QLC_83XX_IDC_DISABLE_FW_DUMP;\n\t\tQLCWRX(adapter->ahw, QLC_83XX_IDC_CTRL, val);\n\n\t\tqlcnic_83xx_unlock_driver(adapter);\n\t} else {\n\t\tfw_dump->enable = false;\n\t}\n\n\tdev_info(&adapter->pdev->dev, \"FW dump disabled\\n\");\n\n\treturn 0;\n}\n\nbool qlcnic_check_fw_dump_state(struct qlcnic_adapter *adapter)\n{\n\tstruct qlcnic_fw_dump *fw_dump = &adapter->ahw->fw_dump;\n\tbool state;\n\tu32 val;\n\n\tif (qlcnic_84xx_check(adapter)) {\n\t\tval = QLCRDX(adapter->ahw, QLC_83XX_IDC_CTRL);\n\t\tstate = (val & QLC_83XX_IDC_DISABLE_FW_DUMP) ? false : true;\n\t} else {\n\t\tstate = fw_dump->enable;\n\t}\n\n\treturn state;\n}\n\nstatic int\nqlcnic_get_dump_flag(struct net_device *netdev, struct ethtool_dump *dump)\n{\n\tstruct qlcnic_adapter *adapter = netdev_priv(netdev);\n\tstruct qlcnic_fw_dump *fw_dump = &adapter->ahw->fw_dump;\n\n\tif (!fw_dump->tmpl_hdr) {\n\t\tnetdev_err(adapter->netdev, \"FW Dump not supported\\n\");\n\t\treturn -ENOTSUPP;\n\t}\n\n\tif (fw_dump->clr)\n\t\tdump->len = fw_dump->tmpl_hdr_size + fw_dump->size;\n\telse\n\t\tdump->len = 0;\n\n\tif (!qlcnic_check_fw_dump_state(adapter))\n\t\tdump->flag = ETH_FW_DUMP_DISABLE;\n\telse\n\t\tdump->flag = fw_dump->cap_mask;\n\n\tdump->version = adapter->fw_version;\n\treturn 0;\n}\n\nstatic int\nqlcnic_get_dump_data(struct net_device *netdev, struct ethtool_dump *dump,\n\t\t\tvoid *buffer)\n{\n\tint i, copy_sz;\n\tu32 *hdr_ptr;\n\t__le32 *data;\n\tstruct qlcnic_adapter *adapter = netdev_priv(netdev);\n\tstruct qlcnic_fw_dump *fw_dump = &adapter->ahw->fw_dump;\n\n\tif (!fw_dump->tmpl_hdr) {\n\t\tnetdev_err(netdev, \"FW Dump not supported\\n\");\n\t\treturn -ENOTSUPP;\n\t}\n\n\tif (!fw_dump->clr) {\n\t\tnetdev_info(netdev, \"Dump not available\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tcopy_sz = fw_dump->tmpl_hdr_size;\n\thdr_ptr = (u32 *)fw_dump->tmpl_hdr;\n\tdata = buffer;\n\tfor (i = 0; i < copy_sz/sizeof(u32); i++)\n\t\t*data++ = cpu_to_le32(*hdr_ptr++);\n\n\t \n\tmemcpy(buffer + copy_sz, fw_dump->data, fw_dump->size);\n\tdump->len = copy_sz + fw_dump->size;\n\tdump->flag = fw_dump->cap_mask;\n\n\t \n\tvfree(fw_dump->data);\n\tfw_dump->data = NULL;\n\tfw_dump->clr = 0;\n\tnetdev_info(netdev, \"extracted the FW dump Successfully\\n\");\n\treturn 0;\n}\n\nstatic int qlcnic_set_dump_mask(struct qlcnic_adapter *adapter, u32 mask)\n{\n\tstruct qlcnic_fw_dump *fw_dump = &adapter->ahw->fw_dump;\n\tstruct net_device *netdev = adapter->netdev;\n\n\tif (!qlcnic_check_fw_dump_state(adapter)) {\n\t\tnetdev_info(netdev,\n\t\t\t    \"Can not change driver mask to 0x%x. FW dump not enabled\\n\",\n\t\t\t    mask);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tfw_dump->cap_mask = mask;\n\n\t \n\tqlcnic_store_cap_mask(adapter, fw_dump->tmpl_hdr, mask);\n\n\tnetdev_info(netdev, \"Driver mask changed to: 0x%x\\n\", mask);\n\treturn 0;\n}\n\nstatic int\nqlcnic_set_dump(struct net_device *netdev, struct ethtool_dump *val)\n{\n\tstruct qlcnic_adapter *adapter = netdev_priv(netdev);\n\tstruct qlcnic_fw_dump *fw_dump = &adapter->ahw->fw_dump;\n\tbool valid_mask = false;\n\tint i, ret = 0;\n\n\tswitch (val->flag) {\n\tcase QLCNIC_FORCE_FW_DUMP_KEY:\n\t\tif (!fw_dump->tmpl_hdr) {\n\t\t\tnetdev_err(netdev, \"FW dump not supported\\n\");\n\t\t\tret = -EOPNOTSUPP;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!qlcnic_check_fw_dump_state(adapter)) {\n\t\t\tnetdev_info(netdev, \"FW dump not enabled\\n\");\n\t\t\tret = -EOPNOTSUPP;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (fw_dump->clr) {\n\t\t\tnetdev_info(netdev,\n\t\t\t\t    \"Previous dump not cleared, not forcing dump\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tnetdev_info(netdev, \"Forcing a FW dump\\n\");\n\t\tqlcnic_dev_request_reset(adapter, val->flag);\n\t\tbreak;\n\tcase QLCNIC_DISABLE_FW_DUMP:\n\t\tif (!fw_dump->tmpl_hdr) {\n\t\t\tnetdev_err(netdev, \"FW dump not supported\\n\");\n\t\t\tret = -EOPNOTSUPP;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = qlcnic_disable_fw_dump_state(adapter);\n\t\tbreak;\n\n\tcase QLCNIC_ENABLE_FW_DUMP:\n\t\tif (!fw_dump->tmpl_hdr) {\n\t\t\tnetdev_err(netdev, \"FW dump not supported\\n\");\n\t\t\tret = -EOPNOTSUPP;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = qlcnic_enable_fw_dump_state(adapter);\n\t\tbreak;\n\n\tcase QLCNIC_FORCE_FW_RESET:\n\t\tnetdev_info(netdev, \"Forcing a FW reset\\n\");\n\t\tqlcnic_dev_request_reset(adapter, val->flag);\n\t\tadapter->flags &= ~QLCNIC_FW_RESET_OWNER;\n\t\tbreak;\n\n\tcase QLCNIC_SET_QUIESCENT:\n\tcase QLCNIC_RESET_QUIESCENT:\n\t\tif (test_bit(__QLCNIC_MAINTENANCE_MODE, &adapter->state))\n\t\t\tnetdev_info(netdev, \"Device is in non-operational state\\n\");\n\t\tbreak;\n\n\tdefault:\n\t\tif (!fw_dump->tmpl_hdr) {\n\t\t\tnetdev_err(netdev, \"FW dump not supported\\n\");\n\t\t\tret = -EOPNOTSUPP;\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (i = 0; i < ARRAY_SIZE(qlcnic_fw_dump_level); i++) {\n\t\t\tif (val->flag == qlcnic_fw_dump_level[i]) {\n\t\t\t\tvalid_mask = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (valid_mask) {\n\t\t\tret = qlcnic_set_dump_mask(adapter, val->flag);\n\t\t} else {\n\t\t\tnetdev_info(netdev, \"Invalid dump level: 0x%x\\n\",\n\t\t\t\t    val->flag);\n\t\t\tret = -EINVAL;\n\t\t}\n\t}\n\treturn ret;\n}\n\nconst struct ethtool_ops qlcnic_ethtool_ops = {\n\t.supported_coalesce_params = ETHTOOL_COALESCE_USECS |\n\t\t\t\t     ETHTOOL_COALESCE_MAX_FRAMES,\n\t.get_drvinfo = qlcnic_get_drvinfo,\n\t.get_regs_len = qlcnic_get_regs_len,\n\t.get_regs = qlcnic_get_regs,\n\t.get_link = ethtool_op_get_link,\n\t.get_eeprom_len = qlcnic_get_eeprom_len,\n\t.get_eeprom = qlcnic_get_eeprom,\n\t.get_ringparam = qlcnic_get_ringparam,\n\t.set_ringparam = qlcnic_set_ringparam,\n\t.get_channels = qlcnic_get_channels,\n\t.set_channels = qlcnic_set_channels,\n\t.get_pauseparam = qlcnic_get_pauseparam,\n\t.set_pauseparam = qlcnic_set_pauseparam,\n\t.get_wol = qlcnic_get_wol,\n\t.set_wol = qlcnic_set_wol,\n\t.self_test = qlcnic_diag_test,\n\t.get_strings = qlcnic_get_strings,\n\t.get_ethtool_stats = qlcnic_get_ethtool_stats,\n\t.get_sset_count = qlcnic_get_sset_count,\n\t.get_coalesce = qlcnic_get_intr_coalesce,\n\t.set_coalesce = qlcnic_set_intr_coalesce,\n\t.set_phys_id = qlcnic_set_led,\n\t.set_msglevel = qlcnic_set_msglevel,\n\t.get_msglevel = qlcnic_get_msglevel,\n\t.get_dump_flag = qlcnic_get_dump_flag,\n\t.get_dump_data = qlcnic_get_dump_data,\n\t.set_dump = qlcnic_set_dump,\n\t.get_link_ksettings = qlcnic_get_link_ksettings,\n\t.set_link_ksettings = qlcnic_set_link_ksettings,\n};\n\nconst struct ethtool_ops qlcnic_sriov_vf_ethtool_ops = {\n\t.supported_coalesce_params = ETHTOOL_COALESCE_USECS |\n\t\t\t\t     ETHTOOL_COALESCE_MAX_FRAMES,\n\t.get_drvinfo\t\t= qlcnic_get_drvinfo,\n\t.get_regs_len\t\t= qlcnic_get_regs_len,\n\t.get_regs\t\t= qlcnic_get_regs,\n\t.get_link\t\t= ethtool_op_get_link,\n\t.get_eeprom_len\t\t= qlcnic_get_eeprom_len,\n\t.get_eeprom\t\t= qlcnic_get_eeprom,\n\t.get_ringparam\t\t= qlcnic_get_ringparam,\n\t.set_ringparam\t\t= qlcnic_set_ringparam,\n\t.get_channels\t\t= qlcnic_get_channels,\n\t.get_pauseparam\t\t= qlcnic_get_pauseparam,\n\t.get_wol\t\t= qlcnic_get_wol,\n\t.get_strings\t\t= qlcnic_get_strings,\n\t.get_ethtool_stats\t= qlcnic_get_ethtool_stats,\n\t.get_sset_count\t\t= qlcnic_get_sset_count,\n\t.get_coalesce\t\t= qlcnic_get_intr_coalesce,\n\t.set_coalesce\t\t= qlcnic_set_intr_coalesce,\n\t.set_msglevel\t\t= qlcnic_set_msglevel,\n\t.get_msglevel\t\t= qlcnic_get_msglevel,\n\t.get_link_ksettings\t= qlcnic_get_link_ksettings,\n};\n\nconst struct ethtool_ops qlcnic_ethtool_failed_ops = {\n\t.get_drvinfo\t\t= qlcnic_get_drvinfo,\n\t.set_msglevel\t\t= qlcnic_set_msglevel,\n\t.get_msglevel\t\t= qlcnic_get_msglevel,\n\t.set_dump\t\t= qlcnic_set_dump,\n\t.get_link_ksettings\t= qlcnic_get_link_ksettings,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}