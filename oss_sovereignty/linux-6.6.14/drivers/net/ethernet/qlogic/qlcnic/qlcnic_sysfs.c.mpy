{
  "module_name": "qlcnic_sysfs.c",
  "hash_id": "248ea64fe6a5660f0c5614d124c27bb5c7af00990996e70ae7cea88432da411f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/qlogic/qlcnic/qlcnic_sysfs.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/swab.h>\n#include <linux/dma-mapping.h>\n#include <net/ip.h>\n#include <linux/ipv6.h>\n#include <linux/inetdevice.h>\n#include <linux/sysfs.h>\n#include <linux/log2.h>\n#ifdef CONFIG_QLCNIC_HWMON\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#endif\n\n#include \"qlcnic.h\"\n#include \"qlcnic_hw.h\"\n\nint qlcnicvf_config_bridged_mode(struct qlcnic_adapter *adapter, u32 enable)\n{\n\treturn -EOPNOTSUPP;\n}\n\nint qlcnicvf_config_led(struct qlcnic_adapter *adapter, u32 state, u32 rate)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic ssize_t qlcnic_store_bridged_mode(struct device *dev,\n\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t const char *buf, size_t len)\n{\n\tstruct qlcnic_adapter *adapter = dev_get_drvdata(dev);\n\tunsigned long new;\n\tint ret = -EINVAL;\n\n\tif (!(adapter->ahw->capabilities & QLCNIC_FW_CAPABILITY_BDG))\n\t\tgoto err_out;\n\n\tif (!test_bit(__QLCNIC_DEV_UP, &adapter->state))\n\t\tgoto err_out;\n\n\tif (kstrtoul(buf, 2, &new))\n\t\tgoto err_out;\n\n\tif (!qlcnic_config_bridged_mode(adapter, !!new))\n\t\tret = len;\n\nerr_out:\n\treturn ret;\n}\n\nstatic ssize_t qlcnic_show_bridged_mode(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tstruct qlcnic_adapter *adapter = dev_get_drvdata(dev);\n\tint bridged_mode = 0;\n\n\tif (adapter->ahw->capabilities & QLCNIC_FW_CAPABILITY_BDG)\n\t\tbridged_mode = !!(adapter->flags & QLCNIC_BRIDGE_ENABLED);\n\n\treturn sprintf(buf, \"%d\\n\", bridged_mode);\n}\n\nstatic ssize_t qlcnic_store_diag_mode(struct device *dev,\n\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t      const char *buf, size_t len)\n{\n\tstruct qlcnic_adapter *adapter = dev_get_drvdata(dev);\n\tunsigned long new;\n\n\tif (kstrtoul(buf, 2, &new))\n\t\treturn -EINVAL;\n\n\tif (!!new != !!(adapter->flags & QLCNIC_DIAG_ENABLED))\n\t\tadapter->flags ^= QLCNIC_DIAG_ENABLED;\n\n\treturn len;\n}\n\nstatic ssize_t qlcnic_show_diag_mode(struct device *dev,\n\t\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct qlcnic_adapter *adapter = dev_get_drvdata(dev);\n\treturn sprintf(buf, \"%d\\n\", !!(adapter->flags & QLCNIC_DIAG_ENABLED));\n}\n\nstatic int qlcnic_validate_beacon(struct qlcnic_adapter *adapter, u16 beacon,\n\t\t\t\t  u8 *state, u8 *rate)\n{\n\t*rate = LSB(beacon);\n\t*state = MSB(beacon);\n\n\tQLCDB(adapter, DRV, \"rate %x state %x\\n\", *rate, *state);\n\n\tif (!*state) {\n\t\t*rate = __QLCNIC_MAX_LED_RATE;\n\t\treturn 0;\n\t} else if (*state > __QLCNIC_MAX_LED_STATE) {\n\t\treturn -EINVAL;\n\t}\n\n\tif ((!*rate) || (*rate > __QLCNIC_MAX_LED_RATE))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int qlcnic_83xx_store_beacon(struct qlcnic_adapter *adapter,\n\t\t\t\t    const char *buf, size_t len)\n{\n\tstruct qlcnic_hardware_context *ahw = adapter->ahw;\n\tunsigned long h_beacon;\n\tint err;\n\n\tif (test_bit(__QLCNIC_RESETTING, &adapter->state))\n\t\treturn -EIO;\n\n\tif (kstrtoul(buf, 2, &h_beacon))\n\t\treturn -EINVAL;\n\n\tqlcnic_get_beacon_state(adapter);\n\n\tif (ahw->beacon_state == h_beacon)\n\t\treturn len;\n\n\trtnl_lock();\n\tif (!ahw->beacon_state) {\n\t\tif (test_and_set_bit(__QLCNIC_LED_ENABLE, &adapter->state)) {\n\t\t\trtnl_unlock();\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\n\tif (h_beacon)\n\t\terr = qlcnic_83xx_config_led(adapter, 1, h_beacon);\n\telse\n\t\terr = qlcnic_83xx_config_led(adapter, 0, !h_beacon);\n\tif (!err)\n\t\tahw->beacon_state = h_beacon;\n\n\tif (!ahw->beacon_state)\n\t\tclear_bit(__QLCNIC_LED_ENABLE, &adapter->state);\n\n\trtnl_unlock();\n\treturn len;\n}\n\nstatic int qlcnic_82xx_store_beacon(struct qlcnic_adapter *adapter,\n\t\t\t\t    const char *buf, size_t len)\n{\n\tstruct qlcnic_hardware_context *ahw = adapter->ahw;\n\tint err, drv_sds_rings = adapter->drv_sds_rings;\n\tu16 beacon;\n\tu8 b_state, b_rate;\n\n\tif (len != sizeof(u16))\n\t\treturn -EINVAL;\n\n\tmemcpy(&beacon, buf, sizeof(u16));\n\terr = qlcnic_validate_beacon(adapter, beacon, &b_state, &b_rate);\n\tif (err)\n\t\treturn err;\n\n\tqlcnic_get_beacon_state(adapter);\n\n\tif (ahw->beacon_state == b_state)\n\t\treturn len;\n\n\trtnl_lock();\n\tif (!ahw->beacon_state) {\n\t\tif (test_and_set_bit(__QLCNIC_LED_ENABLE, &adapter->state)) {\n\t\t\trtnl_unlock();\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\n\tif (test_bit(__QLCNIC_RESETTING, &adapter->state)) {\n\t\terr = -EIO;\n\t\tgoto out;\n\t}\n\n\tif (!test_bit(__QLCNIC_DEV_UP, &adapter->state)) {\n\t\terr = qlcnic_diag_alloc_res(adapter->netdev, QLCNIC_LED_TEST);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tset_bit(__QLCNIC_DIAG_RES_ALLOC, &adapter->state);\n\t}\n\n\terr = qlcnic_config_led(adapter, b_state, b_rate);\n\tif (!err) {\n\t\terr = len;\n\t\tahw->beacon_state = b_state;\n\t}\n\n\tif (test_and_clear_bit(__QLCNIC_DIAG_RES_ALLOC, &adapter->state))\n\t\tqlcnic_diag_free_res(adapter->netdev, drv_sds_rings);\n\nout:\n\tif (!ahw->beacon_state)\n\t\tclear_bit(__QLCNIC_LED_ENABLE, &adapter->state);\n\trtnl_unlock();\n\n\treturn err;\n}\n\nstatic ssize_t qlcnic_store_beacon(struct device *dev,\n\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t   const char *buf, size_t len)\n{\n\tstruct qlcnic_adapter *adapter = dev_get_drvdata(dev);\n\tint err = 0;\n\n\tif (adapter->ahw->op_mode == QLCNIC_NON_PRIV_FUNC) {\n\t\tdev_warn(dev,\n\t\t\t \"LED test not supported in non privileged mode\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (qlcnic_82xx_check(adapter))\n\t\terr = qlcnic_82xx_store_beacon(adapter, buf, len);\n\telse if (qlcnic_83xx_check(adapter))\n\t\terr = qlcnic_83xx_store_beacon(adapter, buf, len);\n\telse\n\t\treturn -EIO;\n\n\treturn err;\n}\n\nstatic ssize_t qlcnic_show_beacon(struct device *dev,\n\t\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tstruct qlcnic_adapter *adapter = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%d\\n\", adapter->ahw->beacon_state);\n}\n\nstatic int qlcnic_sysfs_validate_crb(struct qlcnic_adapter *adapter,\n\t\t\t\t     loff_t offset, size_t size)\n{\n\tsize_t crb_size = 4;\n\n\tif (!(adapter->flags & QLCNIC_DIAG_ENABLED))\n\t\treturn -EIO;\n\n\tif (offset < QLCNIC_PCI_CRBSPACE) {\n\t\tif (ADDR_IN_RANGE(offset, QLCNIC_PCI_CAMQM,\n\t\t\t\t  QLCNIC_PCI_CAMQM_END))\n\t\t\tcrb_size = 8;\n\t\telse\n\t\t\treturn -EINVAL;\n\t}\n\n\tif ((size != crb_size) || (offset & (crb_size-1)))\n\t\treturn  -EINVAL;\n\n\treturn 0;\n}\n\nstatic ssize_t qlcnic_sysfs_read_crb(struct file *filp, struct kobject *kobj,\n\t\t\t\t     struct bin_attribute *attr, char *buf,\n\t\t\t\t     loff_t offset, size_t size)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct qlcnic_adapter *adapter = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = qlcnic_sysfs_validate_crb(adapter, offset, size);\n\tif (ret != 0)\n\t\treturn ret;\n\tqlcnic_read_crb(adapter, buf, offset, size);\n\tqlcnic_swap32_buffer((u32 *)buf, size / sizeof(u32));\n\n\treturn size;\n}\n\nstatic ssize_t qlcnic_sysfs_write_crb(struct file *filp, struct kobject *kobj,\n\t\t\t\t      struct bin_attribute *attr, char *buf,\n\t\t\t\t      loff_t offset, size_t size)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct qlcnic_adapter *adapter = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = qlcnic_sysfs_validate_crb(adapter, offset, size);\n\tif (ret != 0)\n\t\treturn ret;\n\n\tqlcnic_swap32_buffer((u32 *)buf, size / sizeof(u32));\n\tqlcnic_write_crb(adapter, buf, offset, size);\n\treturn size;\n}\n\nstatic int qlcnic_sysfs_validate_mem(struct qlcnic_adapter *adapter,\n\t\t\t\t     loff_t offset, size_t size)\n{\n\tif (!(adapter->flags & QLCNIC_DIAG_ENABLED))\n\t\treturn -EIO;\n\n\tif ((size != 8) || (offset & 0x7))\n\t\treturn  -EIO;\n\n\treturn 0;\n}\n\nstatic ssize_t qlcnic_sysfs_read_mem(struct file *filp, struct kobject *kobj,\n\t\t\t\t     struct bin_attribute *attr, char *buf,\n\t\t\t\t     loff_t offset, size_t size)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct qlcnic_adapter *adapter = dev_get_drvdata(dev);\n\tu64 data;\n\tint ret;\n\n\tret = qlcnic_sysfs_validate_mem(adapter, offset, size);\n\tif (ret != 0)\n\t\treturn ret;\n\n\tif (qlcnic_pci_mem_read_2M(adapter, offset, &data))\n\t\treturn -EIO;\n\n\tmemcpy(buf, &data, size);\n\tqlcnic_swap32_buffer((u32 *)buf, size / sizeof(u32));\n\n\treturn size;\n}\n\nstatic ssize_t qlcnic_sysfs_write_mem(struct file *filp, struct kobject *kobj,\n\t\t\t\t      struct bin_attribute *attr, char *buf,\n\t\t\t\t      loff_t offset, size_t size)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct qlcnic_adapter *adapter = dev_get_drvdata(dev);\n\tu64 data;\n\tint ret;\n\n\tret = qlcnic_sysfs_validate_mem(adapter, offset, size);\n\tif (ret != 0)\n\t\treturn ret;\n\n\tqlcnic_swap32_buffer((u32 *)buf, size / sizeof(u32));\n\tmemcpy(&data, buf, size);\n\n\tif (qlcnic_pci_mem_write_2M(adapter, offset, data))\n\t\treturn -EIO;\n\n\treturn size;\n}\n\nint qlcnic_is_valid_nic_func(struct qlcnic_adapter *adapter, u8 pci_func)\n{\n\tint i;\n\n\tfor (i = 0; i < adapter->ahw->total_nic_func; i++) {\n\t\tif (adapter->npars[i].pci_func == pci_func)\n\t\t\treturn i;\n\t}\n\n\tdev_err(&adapter->pdev->dev, \"%s: Invalid nic function\\n\", __func__);\n\treturn -EINVAL;\n}\n\nstatic int validate_pm_config(struct qlcnic_adapter *adapter,\n\t\t\t      struct qlcnic_pm_func_cfg *pm_cfg, int count)\n{\n\tu8 src_pci_func, s_esw_id, d_esw_id;\n\tu8 dest_pci_func;\n\tint i, src_index, dest_index;\n\n\tfor (i = 0; i < count; i++) {\n\t\tsrc_pci_func = pm_cfg[i].pci_func;\n\t\tdest_pci_func = pm_cfg[i].dest_npar;\n\t\tsrc_index = qlcnic_is_valid_nic_func(adapter, src_pci_func);\n\t\tif (src_index < 0)\n\t\t\treturn -EINVAL;\n\n\t\tdest_index = qlcnic_is_valid_nic_func(adapter, dest_pci_func);\n\t\tif (dest_index < 0)\n\t\t\treturn -EINVAL;\n\n\t\ts_esw_id = adapter->npars[src_index].phy_port;\n\t\td_esw_id = adapter->npars[dest_index].phy_port;\n\n\t\tif (s_esw_id != d_esw_id)\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic ssize_t qlcnic_sysfs_write_pm_config(struct file *filp,\n\t\t\t\t\t    struct kobject *kobj,\n\t\t\t\t\t    struct bin_attribute *attr,\n\t\t\t\t\t    char *buf, loff_t offset,\n\t\t\t\t\t    size_t size)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct qlcnic_adapter *adapter = dev_get_drvdata(dev);\n\tstruct qlcnic_pm_func_cfg *pm_cfg;\n\tu32 id, action, pci_func;\n\tint count, rem, i, ret, index;\n\n\tcount\t= size / sizeof(struct qlcnic_pm_func_cfg);\n\trem\t= size % sizeof(struct qlcnic_pm_func_cfg);\n\tif (rem)\n\t\treturn -EINVAL;\n\n\tqlcnic_swap32_buffer((u32 *)buf, size / sizeof(u32));\n\tpm_cfg = (struct qlcnic_pm_func_cfg *)buf;\n\tret = validate_pm_config(adapter, pm_cfg, count);\n\n\tif (ret)\n\t\treturn ret;\n\tfor (i = 0; i < count; i++) {\n\t\tpci_func = pm_cfg[i].pci_func;\n\t\taction = !!pm_cfg[i].action;\n\t\tindex = qlcnic_is_valid_nic_func(adapter, pci_func);\n\t\tif (index < 0)\n\t\t\treturn -EINVAL;\n\n\t\tid = adapter->npars[index].phy_port;\n\t\tret = qlcnic_config_port_mirroring(adapter, id,\n\t\t\t\t\t\t   action, pci_func);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < count; i++) {\n\t\tpci_func = pm_cfg[i].pci_func;\n\t\tindex = qlcnic_is_valid_nic_func(adapter, pci_func);\n\t\tif (index < 0)\n\t\t\treturn -EINVAL;\n\t\tid = adapter->npars[index].phy_port;\n\t\tadapter->npars[index].enable_pm = !!pm_cfg[i].action;\n\t\tadapter->npars[index].dest_npar = id;\n\t}\n\n\treturn size;\n}\n\nstatic ssize_t qlcnic_sysfs_read_pm_config(struct file *filp,\n\t\t\t\t\t   struct kobject *kobj,\n\t\t\t\t\t   struct bin_attribute *attr,\n\t\t\t\t\t   char *buf, loff_t offset,\n\t\t\t\t\t   size_t size)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct qlcnic_adapter *adapter = dev_get_drvdata(dev);\n\tstruct qlcnic_pm_func_cfg *pm_cfg;\n\tu8 pci_func;\n\tu32 count;\n\tint i;\n\n\tmemset(buf, 0, size);\n\tpm_cfg = (struct qlcnic_pm_func_cfg *)buf;\n\tcount = size / sizeof(struct qlcnic_pm_func_cfg);\n\tfor (i = 0; i < adapter->ahw->total_nic_func; i++) {\n\t\tpci_func = adapter->npars[i].pci_func;\n\t\tif (pci_func >= count) {\n\t\t\tdev_dbg(dev, \"%s: Total nic functions[%d], App sent function count[%d]\\n\",\n\t\t\t\t__func__, adapter->ahw->total_nic_func, count);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!adapter->npars[i].eswitch_status)\n\t\t\tcontinue;\n\n\t\tpm_cfg[pci_func].action = adapter->npars[i].enable_pm;\n\t\tpm_cfg[pci_func].dest_npar = 0;\n\t\tpm_cfg[pci_func].pci_func = i;\n\t}\n\tqlcnic_swap32_buffer((u32 *)buf, size / sizeof(u32));\n\treturn size;\n}\n\nstatic int validate_esw_config(struct qlcnic_adapter *adapter,\n\t\t\t       struct qlcnic_esw_func_cfg *esw_cfg, int count)\n{\n\tstruct qlcnic_hardware_context *ahw = adapter->ahw;\n\tint i, ret;\n\tu32 op_mode;\n\tu8 pci_func;\n\n\tif (qlcnic_82xx_check(adapter))\n\t\top_mode = readl(ahw->pci_base0 + QLCNIC_DRV_OP_MODE);\n\telse\n\t\top_mode = QLCRDX(ahw, QLC_83XX_DRV_OP_MODE);\n\n\tfor (i = 0; i < count; i++) {\n\t\tpci_func = esw_cfg[i].pci_func;\n\t\tif (pci_func >= ahw->max_vnic_func)\n\t\t\treturn -EINVAL;\n\n\t\tif (adapter->ahw->op_mode == QLCNIC_MGMT_FUNC)\n\t\t\tif (qlcnic_is_valid_nic_func(adapter, pci_func) < 0)\n\t\t\t\treturn -EINVAL;\n\n\t\tswitch (esw_cfg[i].op_mode) {\n\t\tcase QLCNIC_PORT_DEFAULTS:\n\t\t\tif (qlcnic_82xx_check(adapter)) {\n\t\t\t\tret = QLC_DEV_GET_DRV(op_mode, pci_func);\n\t\t\t} else {\n\t\t\t\tret = QLC_83XX_GET_FUNC_PRIVILEGE(op_mode,\n\t\t\t\t\t\t\t\t  pci_func);\n\t\t\t\tesw_cfg[i].offload_flags = 0;\n\t\t\t}\n\n\t\t\tif (ret != QLCNIC_NON_PRIV_FUNC) {\n\t\t\t\tif (esw_cfg[i].mac_anti_spoof != 0)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tif (esw_cfg[i].mac_override != 1)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tif (esw_cfg[i].promisc_mode != 1)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase QLCNIC_ADD_VLAN:\n\t\t\tif (!IS_VALID_VLAN(esw_cfg[i].vlan_id))\n\t\t\t\treturn -EINVAL;\n\t\t\tif (!esw_cfg[i].op_type)\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase QLCNIC_DEL_VLAN:\n\t\t\tif (!esw_cfg[i].op_type)\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic ssize_t qlcnic_sysfs_write_esw_config(struct file *file,\n\t\t\t\t\t     struct kobject *kobj,\n\t\t\t\t\t     struct bin_attribute *attr,\n\t\t\t\t\t     char *buf, loff_t offset,\n\t\t\t\t\t     size_t size)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct qlcnic_adapter *adapter = dev_get_drvdata(dev);\n\tstruct qlcnic_esw_func_cfg *esw_cfg;\n\tstruct qlcnic_npar_info *npar;\n\tint count, rem, i, ret;\n\tint index;\n\tu8 op_mode = 0, pci_func;\n\n\tcount\t= size / sizeof(struct qlcnic_esw_func_cfg);\n\trem\t= size % sizeof(struct qlcnic_esw_func_cfg);\n\tif (rem)\n\t\treturn -EINVAL;\n\n\tqlcnic_swap32_buffer((u32 *)buf, size / sizeof(u32));\n\tesw_cfg = (struct qlcnic_esw_func_cfg *)buf;\n\tret = validate_esw_config(adapter, esw_cfg, count);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < count; i++) {\n\t\tif (adapter->ahw->op_mode == QLCNIC_MGMT_FUNC)\n\t\t\tif (qlcnic_config_switch_port(adapter, &esw_cfg[i]))\n\t\t\t\treturn -EINVAL;\n\n\t\tif (adapter->ahw->pci_func != esw_cfg[i].pci_func)\n\t\t\tcontinue;\n\n\t\top_mode = esw_cfg[i].op_mode;\n\t\tqlcnic_get_eswitch_port_config(adapter, &esw_cfg[i]);\n\t\tesw_cfg[i].op_mode = op_mode;\n\t\tesw_cfg[i].pci_func = adapter->ahw->pci_func;\n\n\t\tswitch (esw_cfg[i].op_mode) {\n\t\tcase QLCNIC_PORT_DEFAULTS:\n\t\t\tqlcnic_set_eswitch_port_features(adapter, &esw_cfg[i]);\n\t\t\trtnl_lock();\n\t\t\tqlcnic_set_netdev_features(adapter, &esw_cfg[i]);\n\t\t\trtnl_unlock();\n\t\t\tbreak;\n\t\tcase QLCNIC_ADD_VLAN:\n\t\t\tqlcnic_set_vlan_config(adapter, &esw_cfg[i]);\n\t\t\tbreak;\n\t\tcase QLCNIC_DEL_VLAN:\n\t\t\tesw_cfg[i].vlan_id = 0;\n\t\t\tqlcnic_set_vlan_config(adapter, &esw_cfg[i]);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (adapter->ahw->op_mode != QLCNIC_MGMT_FUNC)\n\t\tgoto out;\n\n\tfor (i = 0; i < count; i++) {\n\t\tpci_func = esw_cfg[i].pci_func;\n\t\tindex = qlcnic_is_valid_nic_func(adapter, pci_func);\n\t\tif (index < 0)\n\t\t\treturn -EINVAL;\n\t\tnpar = &adapter->npars[index];\n\t\tswitch (esw_cfg[i].op_mode) {\n\t\tcase QLCNIC_PORT_DEFAULTS:\n\t\t\tnpar->promisc_mode = esw_cfg[i].promisc_mode;\n\t\t\tnpar->mac_override = esw_cfg[i].mac_override;\n\t\t\tnpar->offload_flags = esw_cfg[i].offload_flags;\n\t\t\tnpar->mac_anti_spoof = esw_cfg[i].mac_anti_spoof;\n\t\t\tnpar->discard_tagged = esw_cfg[i].discard_tagged;\n\t\t\tbreak;\n\t\tcase QLCNIC_ADD_VLAN:\n\t\t\tnpar->pvid = esw_cfg[i].vlan_id;\n\t\t\tbreak;\n\t\tcase QLCNIC_DEL_VLAN:\n\t\t\tnpar->pvid = 0;\n\t\t\tbreak;\n\t\t}\n\t}\nout:\n\treturn size;\n}\n\nstatic ssize_t qlcnic_sysfs_read_esw_config(struct file *file,\n\t\t\t\t\t    struct kobject *kobj,\n\t\t\t\t\t    struct bin_attribute *attr,\n\t\t\t\t\t    char *buf, loff_t offset,\n\t\t\t\t\t    size_t size)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct qlcnic_adapter *adapter = dev_get_drvdata(dev);\n\tstruct qlcnic_esw_func_cfg *esw_cfg;\n\tu8 pci_func;\n\tu32 count;\n\tint i;\n\n\tmemset(buf, 0, size);\n\tesw_cfg = (struct qlcnic_esw_func_cfg *)buf;\n\tcount = size / sizeof(struct qlcnic_esw_func_cfg);\n\tfor (i = 0; i < adapter->ahw->total_nic_func; i++) {\n\t\tpci_func = adapter->npars[i].pci_func;\n\t\tif (pci_func >= count) {\n\t\t\tdev_dbg(dev, \"%s: Total nic functions[%d], App sent function count[%d]\\n\",\n\t\t\t\t__func__, adapter->ahw->total_nic_func, count);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!adapter->npars[i].eswitch_status)\n\t\t\tcontinue;\n\n\t\tesw_cfg[pci_func].pci_func = pci_func;\n\t\tif (qlcnic_get_eswitch_port_config(adapter, &esw_cfg[pci_func]))\n\t\t\treturn -EINVAL;\n\t}\n\tqlcnic_swap32_buffer((u32 *)buf, size / sizeof(u32));\n\treturn size;\n}\n\nstatic int validate_npar_config(struct qlcnic_adapter *adapter,\n\t\t\t\tstruct qlcnic_npar_func_cfg *np_cfg,\n\t\t\t\tint count)\n{\n\tu8 pci_func, i;\n\n\tfor (i = 0; i < count; i++) {\n\t\tpci_func = np_cfg[i].pci_func;\n\t\tif (qlcnic_is_valid_nic_func(adapter, pci_func) < 0)\n\t\t\treturn -EINVAL;\n\n\t\tif (!IS_VALID_BW(np_cfg[i].min_bw) ||\n\t\t    !IS_VALID_BW(np_cfg[i].max_bw))\n\t\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic ssize_t qlcnic_sysfs_write_npar_config(struct file *file,\n\t\t\t\t\t      struct kobject *kobj,\n\t\t\t\t\t      struct bin_attribute *attr,\n\t\t\t\t\t      char *buf, loff_t offset,\n\t\t\t\t\t      size_t size)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct qlcnic_adapter *adapter = dev_get_drvdata(dev);\n\tstruct qlcnic_info nic_info;\n\tstruct qlcnic_npar_func_cfg *np_cfg;\n\tint i, count, rem, ret, index;\n\tu8 pci_func;\n\n\tcount\t= size / sizeof(struct qlcnic_npar_func_cfg);\n\trem\t= size % sizeof(struct qlcnic_npar_func_cfg);\n\tif (rem)\n\t\treturn -EINVAL;\n\n\tqlcnic_swap32_buffer((u32 *)buf, size / sizeof(u32));\n\tnp_cfg = (struct qlcnic_npar_func_cfg *)buf;\n\tret = validate_npar_config(adapter, np_cfg, count);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < count; i++) {\n\t\tpci_func = np_cfg[i].pci_func;\n\n\t\tmemset(&nic_info, 0, sizeof(struct qlcnic_info));\n\t\tret = qlcnic_get_nic_info(adapter, &nic_info, pci_func);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tnic_info.pci_func = pci_func;\n\t\tnic_info.min_tx_bw = np_cfg[i].min_bw;\n\t\tnic_info.max_tx_bw = np_cfg[i].max_bw;\n\t\tret = qlcnic_set_nic_info(adapter, &nic_info);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tindex = qlcnic_is_valid_nic_func(adapter, pci_func);\n\t\tif (index < 0)\n\t\t\treturn -EINVAL;\n\t\tadapter->npars[index].min_bw = nic_info.min_tx_bw;\n\t\tadapter->npars[index].max_bw = nic_info.max_tx_bw;\n\t}\n\n\treturn size;\n}\n\nstatic ssize_t qlcnic_sysfs_read_npar_config(struct file *file,\n\t\t\t\t\t     struct kobject *kobj,\n\t\t\t\t\t     struct bin_attribute *attr,\n\t\t\t\t\t     char *buf, loff_t offset,\n\t\t\t\t\t     size_t size)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct qlcnic_adapter *adapter = dev_get_drvdata(dev);\n\tstruct qlcnic_npar_func_cfg *np_cfg;\n\tstruct qlcnic_info nic_info;\n\tu8 pci_func;\n\tint i, ret;\n\tu32 count;\n\n\tmemset(&nic_info, 0, sizeof(struct qlcnic_info));\n\tmemset(buf, 0, size);\n\tnp_cfg = (struct qlcnic_npar_func_cfg *)buf;\n\n\tcount = size / sizeof(struct qlcnic_npar_func_cfg);\n\tfor (i = 0; i < adapter->ahw->total_nic_func; i++) {\n\t\tif (adapter->npars[i].pci_func >= count) {\n\t\t\tdev_dbg(dev, \"%s: Total nic functions[%d], App sent function count[%d]\\n\",\n\t\t\t\t__func__, adapter->ahw->total_nic_func, count);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!adapter->npars[i].eswitch_status)\n\t\t\tcontinue;\n\t\tpci_func = adapter->npars[i].pci_func;\n\t\tif (qlcnic_is_valid_nic_func(adapter, pci_func) < 0)\n\t\t\tcontinue;\n\t\tret = qlcnic_get_nic_info(adapter, &nic_info, pci_func);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tnp_cfg[pci_func].pci_func = pci_func;\n\t\tnp_cfg[pci_func].op_mode = (u8)nic_info.op_mode;\n\t\tnp_cfg[pci_func].port_num = nic_info.phys_port;\n\t\tnp_cfg[pci_func].fw_capab = nic_info.capabilities;\n\t\tnp_cfg[pci_func].min_bw = nic_info.min_tx_bw;\n\t\tnp_cfg[pci_func].max_bw = nic_info.max_tx_bw;\n\t\tnp_cfg[pci_func].max_tx_queues = nic_info.max_tx_ques;\n\t\tnp_cfg[pci_func].max_rx_queues = nic_info.max_rx_ques;\n\t}\n\tqlcnic_swap32_buffer((u32 *)buf, size / sizeof(u32));\n\treturn size;\n}\n\nstatic ssize_t qlcnic_sysfs_get_port_stats(struct file *file,\n\t\t\t\t\t   struct kobject *kobj,\n\t\t\t\t\t   struct bin_attribute *attr,\n\t\t\t\t\t   char *buf, loff_t offset,\n\t\t\t\t\t   size_t size)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct qlcnic_adapter *adapter = dev_get_drvdata(dev);\n\tstruct qlcnic_esw_statistics port_stats;\n\tint ret;\n\n\tif (qlcnic_83xx_check(adapter))\n\t\treturn -EOPNOTSUPP;\n\n\tif (size != sizeof(struct qlcnic_esw_statistics))\n\t\treturn -EINVAL;\n\n\tif (offset >= adapter->ahw->max_vnic_func)\n\t\treturn -EINVAL;\n\n\tmemset(&port_stats, 0, size);\n\tret = qlcnic_get_port_stats(adapter, offset, QLCNIC_QUERY_RX_COUNTER,\n\t\t\t\t    &port_stats.rx);\n\tif (ret)\n\t\treturn ret;\n\n\tret = qlcnic_get_port_stats(adapter, offset, QLCNIC_QUERY_TX_COUNTER,\n\t\t\t\t    &port_stats.tx);\n\tif (ret)\n\t\treturn ret;\n\n\tmemcpy(buf, &port_stats, size);\n\treturn size;\n}\n\nstatic ssize_t qlcnic_sysfs_get_esw_stats(struct file *file,\n\t\t\t\t\t  struct kobject *kobj,\n\t\t\t\t\t  struct bin_attribute *attr,\n\t\t\t\t\t  char *buf, loff_t offset,\n\t\t\t\t\t  size_t size)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct qlcnic_adapter *adapter = dev_get_drvdata(dev);\n\tstruct qlcnic_esw_statistics esw_stats;\n\tint ret;\n\n\tif (qlcnic_83xx_check(adapter))\n\t\treturn -EOPNOTSUPP;\n\n\tif (size != sizeof(struct qlcnic_esw_statistics))\n\t\treturn -EINVAL;\n\n\tif (offset >= QLCNIC_NIU_MAX_XG_PORTS)\n\t\treturn -EINVAL;\n\n\tmemset(&esw_stats, 0, size);\n\tret = qlcnic_get_eswitch_stats(adapter, offset, QLCNIC_QUERY_RX_COUNTER,\n\t\t\t\t       &esw_stats.rx);\n\tif (ret)\n\t\treturn ret;\n\n\tret = qlcnic_get_eswitch_stats(adapter, offset, QLCNIC_QUERY_TX_COUNTER,\n\t\t\t\t       &esw_stats.tx);\n\tif (ret)\n\t\treturn ret;\n\n\tmemcpy(buf, &esw_stats, size);\n\treturn size;\n}\n\nstatic ssize_t qlcnic_sysfs_clear_esw_stats(struct file *file,\n\t\t\t\t\t    struct kobject *kobj,\n\t\t\t\t\t    struct bin_attribute *attr,\n\t\t\t\t\t    char *buf, loff_t offset,\n\t\t\t\t\t    size_t size)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct qlcnic_adapter *adapter = dev_get_drvdata(dev);\n\tint ret;\n\n\tif (qlcnic_83xx_check(adapter))\n\t\treturn -EOPNOTSUPP;\n\n\tif (offset >= QLCNIC_NIU_MAX_XG_PORTS)\n\t\treturn -EINVAL;\n\n\tret = qlcnic_clear_esw_stats(adapter, QLCNIC_STATS_ESWITCH, offset,\n\t\t\t\t     QLCNIC_QUERY_RX_COUNTER);\n\tif (ret)\n\t\treturn ret;\n\n\tret = qlcnic_clear_esw_stats(adapter, QLCNIC_STATS_ESWITCH, offset,\n\t\t\t\t     QLCNIC_QUERY_TX_COUNTER);\n\tif (ret)\n\t\treturn ret;\n\n\treturn size;\n}\n\nstatic ssize_t qlcnic_sysfs_clear_port_stats(struct file *file,\n\t\t\t\t\t     struct kobject *kobj,\n\t\t\t\t\t     struct bin_attribute *attr,\n\t\t\t\t\t     char *buf, loff_t offset,\n\t\t\t\t\t     size_t size)\n{\n\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct qlcnic_adapter *adapter = dev_get_drvdata(dev);\n\tint ret;\n\n\tif (qlcnic_83xx_check(adapter))\n\t\treturn -EOPNOTSUPP;\n\n\tif (offset >= adapter->ahw->max_vnic_func)\n\t\treturn -EINVAL;\n\n\tret = qlcnic_clear_esw_stats(adapter, QLCNIC_STATS_PORT, offset,\n\t\t\t\t     QLCNIC_QUERY_RX_COUNTER);\n\tif (ret)\n\t\treturn ret;\n\n\tret = qlcnic_clear_esw_stats(adapter, QLCNIC_STATS_PORT, offset,\n\t\t\t\t     QLCNIC_QUERY_TX_COUNTER);\n\tif (ret)\n\t\treturn ret;\n\n\treturn size;\n}\n\nstatic ssize_t qlcnic_sysfs_read_pci_config(struct file *file,\n\t\t\t\t\t    struct kobject *kobj,\n\t\t\t\t\t    struct bin_attribute *attr,\n\t\t\t\t\t    char *buf, loff_t offset,\n\t\t\t\t\t    size_t size)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct qlcnic_adapter *adapter = dev_get_drvdata(dev);\n\tstruct qlcnic_pci_func_cfg *pci_cfg;\n\tstruct qlcnic_pci_info *pci_info;\n\tint i, ret;\n\tu32 count;\n\n\tpci_info = kcalloc(size, sizeof(*pci_info), GFP_KERNEL);\n\tif (!pci_info)\n\t\treturn -ENOMEM;\n\n\tret = qlcnic_get_pci_info(adapter, pci_info);\n\tif (ret) {\n\t\tkfree(pci_info);\n\t\treturn ret;\n\t}\n\n\tpci_cfg = (struct qlcnic_pci_func_cfg *)buf;\n\tcount = size / sizeof(struct qlcnic_pci_func_cfg);\n\tqlcnic_swap32_buffer((u32 *)pci_info, size / sizeof(u32));\n\tfor (i = 0; i < count; i++) {\n\t\tpci_cfg[i].pci_func = pci_info[i].id;\n\t\tpci_cfg[i].func_type = pci_info[i].type;\n\t\tpci_cfg[i].func_state = 0;\n\t\tpci_cfg[i].port_num = pci_info[i].default_port;\n\t\tpci_cfg[i].min_bw = pci_info[i].tx_min_bw;\n\t\tpci_cfg[i].max_bw = pci_info[i].tx_max_bw;\n\t\tmemcpy(&pci_cfg[i].def_mac_addr, &pci_info[i].mac, ETH_ALEN);\n\t}\n\n\tkfree(pci_info);\n\treturn size;\n}\n\nstatic ssize_t qlcnic_83xx_sysfs_flash_read_handler(struct file *filp,\n\t\t\t\t\t\t    struct kobject *kobj,\n\t\t\t\t\t\t    struct bin_attribute *attr,\n\t\t\t\t\t\t    char *buf, loff_t offset,\n\t\t\t\t\t\t    size_t size)\n{\n\tunsigned char *p_read_buf;\n\tint  ret, count;\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct qlcnic_adapter *adapter = dev_get_drvdata(dev);\n\n\tif (!size)\n\t\treturn -EINVAL;\n\n\tcount = size / sizeof(u32);\n\n\tif (size % sizeof(u32))\n\t\tcount++;\n\n\tp_read_buf = kcalloc(size, sizeof(unsigned char), GFP_KERNEL);\n\tif (!p_read_buf)\n\t\treturn -ENOMEM;\n\tif (qlcnic_83xx_lock_flash(adapter) != 0) {\n\t\tkfree(p_read_buf);\n\t\treturn -EIO;\n\t}\n\n\tret = qlcnic_83xx_lockless_flash_read32(adapter, offset, p_read_buf,\n\t\t\t\t\t\tcount);\n\n\tif (ret) {\n\t\tqlcnic_83xx_unlock_flash(adapter);\n\t\tkfree(p_read_buf);\n\t\treturn ret;\n\t}\n\n\tqlcnic_83xx_unlock_flash(adapter);\n\tqlcnic_swap32_buffer((u32 *)p_read_buf, count);\n\tmemcpy(buf, p_read_buf, size);\n\tkfree(p_read_buf);\n\n\treturn size;\n}\n\nstatic int qlcnic_83xx_sysfs_flash_bulk_write(struct qlcnic_adapter *adapter,\n\t\t\t\t\t      char *buf, loff_t offset,\n\t\t\t\t\t      size_t size)\n{\n\tint  i, ret, count;\n\tunsigned char *p_cache, *p_src;\n\n\tp_cache = kcalloc(size, sizeof(unsigned char), GFP_KERNEL);\n\tif (!p_cache)\n\t\treturn -ENOMEM;\n\n\tcount = size / sizeof(u32);\n\tqlcnic_swap32_buffer((u32 *)buf, count);\n\tmemcpy(p_cache, buf, size);\n\tp_src = p_cache;\n\n\tif (qlcnic_83xx_lock_flash(adapter) != 0) {\n\t\tkfree(p_cache);\n\t\treturn -EIO;\n\t}\n\n\tif (adapter->ahw->fdt.mfg_id == adapter->flash_mfg_id) {\n\t\tret = qlcnic_83xx_enable_flash_write(adapter);\n\t\tif (ret) {\n\t\t\tkfree(p_cache);\n\t\t\tqlcnic_83xx_unlock_flash(adapter);\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\tfor (i = 0; i < count / QLC_83XX_FLASH_WRITE_MAX; i++) {\n\t\tret = qlcnic_83xx_flash_bulk_write(adapter, offset,\n\t\t\t\t\t\t   (u32 *)p_src,\n\t\t\t\t\t\t   QLC_83XX_FLASH_WRITE_MAX);\n\n\t\tif (ret) {\n\t\t\tif (adapter->ahw->fdt.mfg_id == adapter->flash_mfg_id) {\n\t\t\t\tret = qlcnic_83xx_disable_flash_write(adapter);\n\t\t\t\tif (ret) {\n\t\t\t\t\tkfree(p_cache);\n\t\t\t\t\tqlcnic_83xx_unlock_flash(adapter);\n\t\t\t\t\treturn -EIO;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tkfree(p_cache);\n\t\t\tqlcnic_83xx_unlock_flash(adapter);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tp_src = p_src + sizeof(u32)*QLC_83XX_FLASH_WRITE_MAX;\n\t\toffset = offset + sizeof(u32)*QLC_83XX_FLASH_WRITE_MAX;\n\t}\n\n\tif (adapter->ahw->fdt.mfg_id == adapter->flash_mfg_id) {\n\t\tret = qlcnic_83xx_disable_flash_write(adapter);\n\t\tif (ret) {\n\t\t\tkfree(p_cache);\n\t\t\tqlcnic_83xx_unlock_flash(adapter);\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\tkfree(p_cache);\n\tqlcnic_83xx_unlock_flash(adapter);\n\n\treturn 0;\n}\n\nstatic int qlcnic_83xx_sysfs_flash_write(struct qlcnic_adapter *adapter,\n\t\t\t\t\t char *buf, loff_t offset, size_t size)\n{\n\tint  i, ret, count;\n\tunsigned char *p_cache, *p_src;\n\n\tp_cache = kcalloc(size, sizeof(unsigned char), GFP_KERNEL);\n\tif (!p_cache)\n\t\treturn -ENOMEM;\n\n\tqlcnic_swap32_buffer((u32 *)buf, size / sizeof(u32));\n\tmemcpy(p_cache, buf, size);\n\tp_src = p_cache;\n\tcount = size / sizeof(u32);\n\n\tif (qlcnic_83xx_lock_flash(adapter) != 0) {\n\t\tkfree(p_cache);\n\t\treturn -EIO;\n\t}\n\n\tif (adapter->ahw->fdt.mfg_id == adapter->flash_mfg_id) {\n\t\tret = qlcnic_83xx_enable_flash_write(adapter);\n\t\tif (ret) {\n\t\t\tkfree(p_cache);\n\t\t\tqlcnic_83xx_unlock_flash(adapter);\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\tfor (i = 0; i < count; i++) {\n\t\tret = qlcnic_83xx_flash_write32(adapter, offset, (u32 *)p_src);\n\t\tif (ret) {\n\t\t\tif (adapter->ahw->fdt.mfg_id == adapter->flash_mfg_id) {\n\t\t\t\tret = qlcnic_83xx_disable_flash_write(adapter);\n\t\t\t\tif (ret) {\n\t\t\t\t\tkfree(p_cache);\n\t\t\t\t\tqlcnic_83xx_unlock_flash(adapter);\n\t\t\t\t\treturn -EIO;\n\t\t\t\t}\n\t\t\t}\n\t\t\tkfree(p_cache);\n\t\t\tqlcnic_83xx_unlock_flash(adapter);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tp_src = p_src + sizeof(u32);\n\t\toffset = offset + sizeof(u32);\n\t}\n\n\tif (adapter->ahw->fdt.mfg_id == adapter->flash_mfg_id) {\n\t\tret = qlcnic_83xx_disable_flash_write(adapter);\n\t\tif (ret) {\n\t\t\tkfree(p_cache);\n\t\t\tqlcnic_83xx_unlock_flash(adapter);\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\tkfree(p_cache);\n\tqlcnic_83xx_unlock_flash(adapter);\n\n\treturn 0;\n}\n\nstatic ssize_t qlcnic_83xx_sysfs_flash_write_handler(struct file *filp,\n\t\t\t\t\t\t     struct kobject *kobj,\n\t\t\t\t\t\t     struct bin_attribute *attr,\n\t\t\t\t\t\t     char *buf, loff_t offset,\n\t\t\t\t\t\t     size_t size)\n{\n\tint  ret;\n\tstatic int flash_mode;\n\tunsigned long data;\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct qlcnic_adapter *adapter = dev_get_drvdata(dev);\n\n\tret = kstrtoul(buf, 16, &data);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (data) {\n\tcase QLC_83XX_FLASH_SECTOR_ERASE_CMD:\n\t\tflash_mode = QLC_83XX_ERASE_MODE;\n\t\tret = qlcnic_83xx_erase_flash_sector(adapter, offset);\n\t\tif (ret) {\n\t\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\t\"%s failed at %d\\n\", __func__, __LINE__);\n\t\t\treturn -EIO;\n\t\t}\n\t\tbreak;\n\n\tcase QLC_83XX_FLASH_BULK_WRITE_CMD:\n\t\tflash_mode = QLC_83XX_BULK_WRITE_MODE;\n\t\tbreak;\n\n\tcase QLC_83XX_FLASH_WRITE_CMD:\n\t\tflash_mode = QLC_83XX_WRITE_MODE;\n\t\tbreak;\n\tdefault:\n\t\tif (flash_mode == QLC_83XX_BULK_WRITE_MODE) {\n\t\t\tret = qlcnic_83xx_sysfs_flash_bulk_write(adapter, buf,\n\t\t\t\t\t\t\t\t offset, size);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\t\t\"%s failed at %d\\n\",\n\t\t\t\t\t__func__, __LINE__);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t}\n\n\t\tif (flash_mode == QLC_83XX_WRITE_MODE) {\n\t\t\tret = qlcnic_83xx_sysfs_flash_write(adapter, buf,\n\t\t\t\t\t\t\t    offset, size);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\t\t\"%s failed at %d\\n\", __func__,\n\t\t\t\t\t__LINE__);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn size;\n}\n\nstatic const struct device_attribute dev_attr_bridged_mode = {\n\t.attr = { .name = \"bridged_mode\", .mode = 0644 },\n\t.show = qlcnic_show_bridged_mode,\n\t.store = qlcnic_store_bridged_mode,\n};\n\nstatic const struct device_attribute dev_attr_diag_mode = {\n\t.attr = { .name = \"diag_mode\", .mode = 0644 },\n\t.show = qlcnic_show_diag_mode,\n\t.store = qlcnic_store_diag_mode,\n};\n\nstatic const struct device_attribute dev_attr_beacon = {\n\t.attr = { .name = \"beacon\", .mode = 0644 },\n\t.show = qlcnic_show_beacon,\n\t.store = qlcnic_store_beacon,\n};\n\nstatic const struct bin_attribute bin_attr_crb = {\n\t.attr = { .name = \"crb\", .mode = 0644 },\n\t.size = 0,\n\t.read = qlcnic_sysfs_read_crb,\n\t.write = qlcnic_sysfs_write_crb,\n};\n\nstatic const struct bin_attribute bin_attr_mem = {\n\t.attr = { .name = \"mem\", .mode = 0644 },\n\t.size = 0,\n\t.read = qlcnic_sysfs_read_mem,\n\t.write = qlcnic_sysfs_write_mem,\n};\n\nstatic const struct bin_attribute bin_attr_npar_config = {\n\t.attr = { .name = \"npar_config\", .mode = 0644 },\n\t.size = 0,\n\t.read = qlcnic_sysfs_read_npar_config,\n\t.write = qlcnic_sysfs_write_npar_config,\n};\n\nstatic const struct bin_attribute bin_attr_pci_config = {\n\t.attr = { .name = \"pci_config\", .mode = 0644 },\n\t.size = 0,\n\t.read = qlcnic_sysfs_read_pci_config,\n\t.write = NULL,\n};\n\nstatic const struct bin_attribute bin_attr_port_stats = {\n\t.attr = { .name = \"port_stats\", .mode = 0644 },\n\t.size = 0,\n\t.read = qlcnic_sysfs_get_port_stats,\n\t.write = qlcnic_sysfs_clear_port_stats,\n};\n\nstatic const struct bin_attribute bin_attr_esw_stats = {\n\t.attr = { .name = \"esw_stats\", .mode = 0644 },\n\t.size = 0,\n\t.read = qlcnic_sysfs_get_esw_stats,\n\t.write = qlcnic_sysfs_clear_esw_stats,\n};\n\nstatic const struct bin_attribute bin_attr_esw_config = {\n\t.attr = { .name = \"esw_config\", .mode = 0644 },\n\t.size = 0,\n\t.read = qlcnic_sysfs_read_esw_config,\n\t.write = qlcnic_sysfs_write_esw_config,\n};\n\nstatic const struct bin_attribute bin_attr_pm_config = {\n\t.attr = { .name = \"pm_config\", .mode = 0644 },\n\t.size = 0,\n\t.read = qlcnic_sysfs_read_pm_config,\n\t.write = qlcnic_sysfs_write_pm_config,\n};\n\nstatic const struct bin_attribute bin_attr_flash = {\n\t.attr = { .name = \"flash\", .mode = 0644 },\n\t.size = 0,\n\t.read = qlcnic_83xx_sysfs_flash_read_handler,\n\t.write = qlcnic_83xx_sysfs_flash_write_handler,\n};\n\n#ifdef CONFIG_QLCNIC_HWMON\n\nstatic ssize_t qlcnic_hwmon_show_temp(struct device *dev,\n\t\t\t\t      struct device_attribute *dev_attr,\n\t\t\t\t      char *buf)\n{\n\tstruct qlcnic_adapter *adapter = dev_get_drvdata(dev);\n\tunsigned int temperature = 0, value = 0;\n\n\tif (qlcnic_83xx_check(adapter))\n\t\tvalue = QLCRDX(adapter->ahw, QLC_83XX_ASIC_TEMP);\n\telse if (qlcnic_82xx_check(adapter))\n\t\tvalue = QLC_SHARED_REG_RD32(adapter, QLCNIC_ASIC_TEMP);\n\n\ttemperature = qlcnic_get_temp_val(value);\n\t \n\ttemperature *= 1000;\n\treturn sprintf(buf, \"%u\\n\", temperature);\n}\n\n \nstatic SENSOR_DEVICE_ATTR(temp1_input, 0444,\n\t\t\t  qlcnic_hwmon_show_temp, NULL, 1);\n\nstatic struct attribute *qlcnic_hwmon_attrs[] = {\n\t&sensor_dev_attr_temp1_input.dev_attr.attr,\n\tNULL\n};\n\nATTRIBUTE_GROUPS(qlcnic_hwmon);\n\nvoid qlcnic_register_hwmon_dev(struct qlcnic_adapter *adapter)\n{\n\tstruct device *dev = &adapter->pdev->dev;\n\tstruct device *hwmon_dev;\n\n\t \n\tif (qlcnic_sriov_vf_check(adapter)) {\n\t\tadapter->ahw->hwmon_dev = NULL;\n\t\treturn;\n\t}\n\thwmon_dev = hwmon_device_register_with_groups(dev, qlcnic_driver_name,\n\t\t\t\t\t\t      adapter,\n\t\t\t\t\t\t      qlcnic_hwmon_groups);\n\tif (IS_ERR(hwmon_dev)) {\n\t\tdev_err(dev, \"Cannot register with hwmon, err=%ld\\n\",\n\t\t\tPTR_ERR(hwmon_dev));\n\t\thwmon_dev = NULL;\n\t}\n\tadapter->ahw->hwmon_dev = hwmon_dev;\n}\n\nvoid qlcnic_unregister_hwmon_dev(struct qlcnic_adapter *adapter)\n{\n\tstruct device *hwmon_dev = adapter->ahw->hwmon_dev;\n\tif (hwmon_dev) {\n\t\thwmon_device_unregister(hwmon_dev);\n\t\tadapter->ahw->hwmon_dev = NULL;\n\t}\n}\n#endif\n\nvoid qlcnic_create_sysfs_entries(struct qlcnic_adapter *adapter)\n{\n\tstruct device *dev = &adapter->pdev->dev;\n\n\tif (adapter->ahw->capabilities & QLCNIC_FW_CAPABILITY_BDG)\n\t\tif (device_create_file(dev, &dev_attr_bridged_mode))\n\t\t\tdev_warn(dev,\n\t\t\t\t \"failed to create bridged_mode sysfs entry\\n\");\n}\n\nvoid qlcnic_remove_sysfs_entries(struct qlcnic_adapter *adapter)\n{\n\tstruct device *dev = &adapter->pdev->dev;\n\n\tif (adapter->ahw->capabilities & QLCNIC_FW_CAPABILITY_BDG)\n\t\tdevice_remove_file(dev, &dev_attr_bridged_mode);\n}\n\nstatic void qlcnic_create_diag_entries(struct qlcnic_adapter *adapter)\n{\n\tstruct device *dev = &adapter->pdev->dev;\n\n\tif (device_create_bin_file(dev, &bin_attr_port_stats))\n\t\tdev_info(dev, \"failed to create port stats sysfs entry\");\n\n\tif (adapter->ahw->op_mode == QLCNIC_NON_PRIV_FUNC)\n\t\treturn;\n\tif (device_create_file(dev, &dev_attr_diag_mode))\n\t\tdev_info(dev, \"failed to create diag_mode sysfs entry\\n\");\n\tif (device_create_bin_file(dev, &bin_attr_crb))\n\t\tdev_info(dev, \"failed to create crb sysfs entry\\n\");\n\tif (device_create_bin_file(dev, &bin_attr_mem))\n\t\tdev_info(dev, \"failed to create mem sysfs entry\\n\");\n\n\tif (test_bit(__QLCNIC_MAINTENANCE_MODE, &adapter->state))\n\t\treturn;\n\n\tif (device_create_bin_file(dev, &bin_attr_pci_config))\n\t\tdev_info(dev, \"failed to create pci config sysfs entry\");\n\n\tif (device_create_file(dev, &dev_attr_beacon))\n\t\tdev_info(dev, \"failed to create beacon sysfs entry\");\n\n\tif (!(adapter->flags & QLCNIC_ESWITCH_ENABLED))\n\t\treturn;\n\tif (device_create_bin_file(dev, &bin_attr_esw_config))\n\t\tdev_info(dev, \"failed to create esw config sysfs entry\");\n\tif (adapter->ahw->op_mode != QLCNIC_MGMT_FUNC)\n\t\treturn;\n\tif (device_create_bin_file(dev, &bin_attr_npar_config))\n\t\tdev_info(dev, \"failed to create npar config sysfs entry\");\n\tif (device_create_bin_file(dev, &bin_attr_pm_config))\n\t\tdev_info(dev, \"failed to create pm config sysfs entry\");\n\tif (device_create_bin_file(dev, &bin_attr_esw_stats))\n\t\tdev_info(dev, \"failed to create eswitch stats sysfs entry\");\n}\n\nstatic void qlcnic_remove_diag_entries(struct qlcnic_adapter *adapter)\n{\n\tstruct device *dev = &adapter->pdev->dev;\n\n\tdevice_remove_bin_file(dev, &bin_attr_port_stats);\n\n\tif (adapter->ahw->op_mode == QLCNIC_NON_PRIV_FUNC)\n\t\treturn;\n\tdevice_remove_file(dev, &dev_attr_diag_mode);\n\tdevice_remove_bin_file(dev, &bin_attr_crb);\n\tdevice_remove_bin_file(dev, &bin_attr_mem);\n\n\tif (test_bit(__QLCNIC_MAINTENANCE_MODE, &adapter->state))\n\t\treturn;\n\n\tdevice_remove_bin_file(dev, &bin_attr_pci_config);\n\tdevice_remove_file(dev, &dev_attr_beacon);\n\tif (!(adapter->flags & QLCNIC_ESWITCH_ENABLED))\n\t\treturn;\n\tdevice_remove_bin_file(dev, &bin_attr_esw_config);\n\tif (adapter->ahw->op_mode != QLCNIC_MGMT_FUNC)\n\t\treturn;\n\tdevice_remove_bin_file(dev, &bin_attr_npar_config);\n\tdevice_remove_bin_file(dev, &bin_attr_pm_config);\n\tdevice_remove_bin_file(dev, &bin_attr_esw_stats);\n}\n\nvoid qlcnic_82xx_add_sysfs(struct qlcnic_adapter *adapter)\n{\n\tqlcnic_create_diag_entries(adapter);\n}\n\nvoid qlcnic_82xx_remove_sysfs(struct qlcnic_adapter *adapter)\n{\n\tqlcnic_remove_diag_entries(adapter);\n}\n\nvoid qlcnic_83xx_add_sysfs(struct qlcnic_adapter *adapter)\n{\n\tstruct device *dev = &adapter->pdev->dev;\n\n\tqlcnic_create_diag_entries(adapter);\n\n\tif (sysfs_create_bin_file(&dev->kobj, &bin_attr_flash))\n\t\tdev_info(dev, \"failed to create flash sysfs entry\\n\");\n}\n\nvoid qlcnic_83xx_remove_sysfs(struct qlcnic_adapter *adapter)\n{\n\tstruct device *dev = &adapter->pdev->dev;\n\n\tqlcnic_remove_diag_entries(adapter);\n\tsysfs_remove_bin_file(&dev->kobj, &bin_attr_flash);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}