{
  "module_name": "qlcnic_ctx.c",
  "hash_id": "54625258d63fcb9d3f949f3232c538c09d969f2b415d10798a09894229daf717",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/qlogic/qlcnic/qlcnic_ctx.c",
  "human_readable_source": "\n \n\n#include \"qlcnic.h\"\n\nstatic const struct qlcnic_mailbox_metadata qlcnic_mbx_tbl[] = {\n\t{QLCNIC_CMD_CREATE_RX_CTX, 4, 1},\n\t{QLCNIC_CMD_DESTROY_RX_CTX, 2, 1},\n\t{QLCNIC_CMD_CREATE_TX_CTX, 4, 1},\n\t{QLCNIC_CMD_DESTROY_TX_CTX, 3, 1},\n\t{QLCNIC_CMD_INTRPT_TEST, 4, 1},\n\t{QLCNIC_CMD_SET_MTU, 4, 1},\n\t{QLCNIC_CMD_READ_PHY, 4, 2},\n\t{QLCNIC_CMD_WRITE_PHY, 5, 1},\n\t{QLCNIC_CMD_READ_HW_REG, 4, 1},\n\t{QLCNIC_CMD_GET_FLOW_CTL, 4, 2},\n\t{QLCNIC_CMD_SET_FLOW_CTL, 4, 1},\n\t{QLCNIC_CMD_READ_MAX_MTU, 4, 2},\n\t{QLCNIC_CMD_READ_MAX_LRO, 4, 2},\n\t{QLCNIC_CMD_MAC_ADDRESS, 4, 3},\n\t{QLCNIC_CMD_GET_PCI_INFO, 4, 1},\n\t{QLCNIC_CMD_GET_NIC_INFO, 4, 1},\n\t{QLCNIC_CMD_SET_NIC_INFO, 4, 1},\n\t{QLCNIC_CMD_GET_ESWITCH_CAPABILITY, 4, 3},\n\t{QLCNIC_CMD_TOGGLE_ESWITCH, 4, 1},\n\t{QLCNIC_CMD_GET_ESWITCH_STATUS, 4, 3},\n\t{QLCNIC_CMD_SET_PORTMIRRORING, 4, 1},\n\t{QLCNIC_CMD_CONFIGURE_ESWITCH, 4, 1},\n\t{QLCNIC_CMD_GET_MAC_STATS, 4, 1},\n\t{QLCNIC_CMD_GET_ESWITCH_PORT_CONFIG, 4, 3},\n\t{QLCNIC_CMD_GET_ESWITCH_STATS, 4, 1},\n\t{QLCNIC_CMD_CONFIG_PORT, 4, 1},\n\t{QLCNIC_CMD_TEMP_SIZE, 4, 4},\n\t{QLCNIC_CMD_GET_TEMP_HDR, 4, 1},\n\t{QLCNIC_CMD_82XX_SET_DRV_VER, 4, 1},\n\t{QLCNIC_CMD_GET_LED_STATUS, 4, 2},\n\t{QLCNIC_CMD_MQ_TX_CONFIG_INTR, 2, 3},\n\t{QLCNIC_CMD_DCB_QUERY_CAP, 1, 2},\n\t{QLCNIC_CMD_DCB_QUERY_PARAM, 4, 1},\n};\n\nstatic inline u32 qlcnic_get_cmd_signature(struct qlcnic_hardware_context *ahw)\n{\n\treturn (ahw->pci_func & 0xff) | ((ahw->fw_hal_version & 0xff) << 8) |\n\t       (0xcafe << 16);\n}\n\n \nint qlcnic_82xx_alloc_mbx_args(struct qlcnic_cmd_args *mbx,\n\t\t\t       struct qlcnic_adapter *adapter, u32 type)\n{\n\tint i, size;\n\tconst struct qlcnic_mailbox_metadata *mbx_tbl;\n\n\tmbx_tbl = qlcnic_mbx_tbl;\n\tsize = ARRAY_SIZE(qlcnic_mbx_tbl);\n\tfor (i = 0; i < size; i++) {\n\t\tif (type == mbx_tbl[i].cmd) {\n\t\t\tmbx->req.num = mbx_tbl[i].in_args;\n\t\t\tmbx->rsp.num = mbx_tbl[i].out_args;\n\t\t\tmbx->req.arg = kcalloc(mbx->req.num,\n\t\t\t\t\t       sizeof(u32), GFP_ATOMIC);\n\t\t\tif (!mbx->req.arg)\n\t\t\t\treturn -ENOMEM;\n\t\t\tmbx->rsp.arg = kcalloc(mbx->rsp.num,\n\t\t\t\t\t       sizeof(u32), GFP_ATOMIC);\n\t\t\tif (!mbx->rsp.arg) {\n\t\t\t\tkfree(mbx->req.arg);\n\t\t\t\tmbx->req.arg = NULL;\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tmbx->req.arg[0] = type;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nvoid qlcnic_free_mbx_args(struct qlcnic_cmd_args *cmd)\n{\n\tkfree(cmd->req.arg);\n\tcmd->req.arg = NULL;\n\tkfree(cmd->rsp.arg);\n\tcmd->rsp.arg = NULL;\n}\n\nstatic u32\nqlcnic_poll_rsp(struct qlcnic_adapter *adapter)\n{\n\tu32 rsp;\n\tint timeout = 0, err = 0;\n\n\tdo {\n\t\t \n\t\tmdelay(1);\n\n\t\tif (++timeout > QLCNIC_OS_CRB_RETRY_COUNT)\n\t\t\treturn QLCNIC_CDRP_RSP_TIMEOUT;\n\n\t\trsp = QLCRD32(adapter, QLCNIC_CDRP_CRB_OFFSET, &err);\n\t} while (!QLCNIC_CDRP_IS_RSP(rsp));\n\n\treturn rsp;\n}\n\nint qlcnic_82xx_issue_cmd(struct qlcnic_adapter *adapter,\n\t\t\t  struct qlcnic_cmd_args *cmd)\n{\n\tint i, err = 0;\n\tu32 rsp;\n\tu32 signature;\n\tstruct pci_dev *pdev = adapter->pdev;\n\tstruct qlcnic_hardware_context *ahw = adapter->ahw;\n\tconst char *fmt;\n\n\tsignature = qlcnic_get_cmd_signature(ahw);\n\n\t \n\tif (qlcnic_api_lock(adapter)) {\n\t\tcmd->rsp.arg[0] = QLCNIC_RCODE_TIMEOUT;\n\t\treturn cmd->rsp.arg[0];\n\t}\n\n\tQLCWR32(adapter, QLCNIC_SIGN_CRB_OFFSET, signature);\n\tfor (i = 1; i < cmd->req.num; i++)\n\t\tQLCWR32(adapter, QLCNIC_CDRP_ARG(i), cmd->req.arg[i]);\n\tQLCWR32(adapter, QLCNIC_CDRP_CRB_OFFSET,\n\t\tQLCNIC_CDRP_FORM_CMD(cmd->req.arg[0]));\n\trsp = qlcnic_poll_rsp(adapter);\n\n\tif (rsp == QLCNIC_CDRP_RSP_TIMEOUT) {\n\t\tdev_err(&pdev->dev, \"command timeout, response = 0x%x\\n\", rsp);\n\t\tcmd->rsp.arg[0] = QLCNIC_RCODE_TIMEOUT;\n\t} else if (rsp == QLCNIC_CDRP_RSP_FAIL) {\n\t\tcmd->rsp.arg[0] = QLCRD32(adapter, QLCNIC_CDRP_ARG(1), &err);\n\t\tswitch (cmd->rsp.arg[0]) {\n\t\tcase QLCNIC_RCODE_INVALID_ARGS:\n\t\t\tfmt = \"CDRP invalid args: [%d]\\n\";\n\t\t\tbreak;\n\t\tcase QLCNIC_RCODE_NOT_SUPPORTED:\n\t\tcase QLCNIC_RCODE_NOT_IMPL:\n\t\t\tfmt = \"CDRP command not supported: [%d]\\n\";\n\t\t\tbreak;\n\t\tcase QLCNIC_RCODE_NOT_PERMITTED:\n\t\t\tfmt = \"CDRP requested action not permitted: [%d]\\n\";\n\t\t\tbreak;\n\t\tcase QLCNIC_RCODE_INVALID:\n\t\t\tfmt = \"CDRP invalid or unknown cmd received: [%d]\\n\";\n\t\t\tbreak;\n\t\tcase QLCNIC_RCODE_TIMEOUT:\n\t\t\tfmt = \"CDRP command timeout: [%d]\\n\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfmt = \"CDRP command failed: [%d]\\n\";\n\t\t\tbreak;\n\t\t}\n\t\tdev_err(&pdev->dev, fmt, cmd->rsp.arg[0]);\n\t\tqlcnic_dump_mbx(adapter, cmd);\n\t} else if (rsp == QLCNIC_CDRP_RSP_OK)\n\t\tcmd->rsp.arg[0] = QLCNIC_RCODE_SUCCESS;\n\n\tfor (i = 1; i < cmd->rsp.num; i++)\n\t\tcmd->rsp.arg[i] = QLCRD32(adapter, QLCNIC_CDRP_ARG(i), &err);\n\n\t \n\tqlcnic_api_unlock(adapter);\n\treturn cmd->rsp.arg[0];\n}\n\nint qlcnic_fw_cmd_set_drv_version(struct qlcnic_adapter *adapter, u32 fw_cmd)\n{\n\tstruct qlcnic_cmd_args cmd;\n\tu32 arg1, arg2, arg3;\n\tchar drv_string[12];\n\tint err = 0;\n\n\tmemset(drv_string, 0, sizeof(drv_string));\n\tsnprintf(drv_string, sizeof(drv_string), \"%d\"\".\"\"%d\"\".\"\"%d\",\n\t\t _QLCNIC_LINUX_MAJOR, _QLCNIC_LINUX_MINOR,\n\t\t _QLCNIC_LINUX_SUBVERSION);\n\n\terr = qlcnic_alloc_mbx_args(&cmd, adapter, fw_cmd);\n\tif (err)\n\t\treturn err;\n\n\tmemcpy(&arg1, drv_string, sizeof(u32));\n\tmemcpy(&arg2, drv_string + 4, sizeof(u32));\n\tmemcpy(&arg3, drv_string + 8, sizeof(u32));\n\n\tcmd.req.arg[1] = arg1;\n\tcmd.req.arg[2] = arg2;\n\tcmd.req.arg[3] = arg3;\n\n\terr = qlcnic_issue_cmd(adapter, &cmd);\n\tif (err) {\n\t\tdev_info(&adapter->pdev->dev,\n\t\t\t \"Failed to set driver version in firmware\\n\");\n\t\terr = -EIO;\n\t}\n\tqlcnic_free_mbx_args(&cmd);\n\treturn err;\n}\n\nint\nqlcnic_fw_cmd_set_mtu(struct qlcnic_adapter *adapter, int mtu)\n{\n\tint err = 0;\n\tstruct qlcnic_cmd_args cmd;\n\tstruct qlcnic_recv_context *recv_ctx = adapter->recv_ctx;\n\n\tif (recv_ctx->state != QLCNIC_HOST_CTX_STATE_ACTIVE)\n\t\treturn err;\n\terr = qlcnic_alloc_mbx_args(&cmd, adapter, QLCNIC_CMD_SET_MTU);\n\tif (err)\n\t\treturn err;\n\n\tcmd.req.arg[1] = recv_ctx->context_id;\n\tcmd.req.arg[2] = mtu;\n\n\terr = qlcnic_issue_cmd(adapter, &cmd);\n\tif (err) {\n\t\tdev_err(&adapter->pdev->dev, \"Failed to set mtu\\n\");\n\t\terr = -EIO;\n\t}\n\tqlcnic_free_mbx_args(&cmd);\n\treturn err;\n}\n\nint qlcnic_82xx_fw_cmd_create_rx_ctx(struct qlcnic_adapter *adapter)\n{\n\tstruct qlcnic_recv_context *recv_ctx = adapter->recv_ctx;\n\tstruct qlcnic_hardware_context *ahw = adapter->ahw;\n\tdma_addr_t hostrq_phys_addr, cardrsp_phys_addr;\n\tstruct net_device *netdev = adapter->netdev;\n\tu32 temp_intr_crb_mode, temp_rds_crb_mode;\n\tstruct qlcnic_cardrsp_rds_ring *prsp_rds;\n\tstruct qlcnic_cardrsp_sds_ring *prsp_sds;\n\tstruct qlcnic_hostrq_rds_ring *prq_rds;\n\tstruct qlcnic_hostrq_sds_ring *prq_sds;\n\tstruct qlcnic_host_rds_ring *rds_ring;\n\tstruct qlcnic_host_sds_ring *sds_ring;\n\tstruct qlcnic_cardrsp_rx_ctx *prsp;\n\tstruct qlcnic_hostrq_rx_ctx *prq;\n\tu8 i, nrds_rings, nsds_rings;\n\tstruct qlcnic_cmd_args cmd;\n\tsize_t rq_size, rsp_size;\n\tu32 cap, reg, val, reg2;\n\tu64 phys_addr;\n\tu16 temp_u16;\n\tvoid *addr;\n\tint err;\n\n\tnrds_rings = adapter->max_rds_rings;\n\tnsds_rings = adapter->drv_sds_rings;\n\n\trq_size = SIZEOF_HOSTRQ_RX(struct qlcnic_hostrq_rx_ctx, nrds_rings,\n\t\t\t\t   nsds_rings);\n\trsp_size = SIZEOF_CARDRSP_RX(struct qlcnic_cardrsp_rx_ctx, nrds_rings,\n\t\t\t\t     nsds_rings);\n\n\taddr = dma_alloc_coherent(&adapter->pdev->dev, rq_size,\n\t\t\t\t  &hostrq_phys_addr, GFP_KERNEL);\n\tif (addr == NULL)\n\t\treturn -ENOMEM;\n\tprq = addr;\n\n\taddr = dma_alloc_coherent(&adapter->pdev->dev, rsp_size,\n\t\t\t&cardrsp_phys_addr, GFP_KERNEL);\n\tif (addr == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto out_free_rq;\n\t}\n\tprsp = addr;\n\n\tprq->host_rsp_dma_addr = cpu_to_le64(cardrsp_phys_addr);\n\n\tcap = (QLCNIC_CAP0_LEGACY_CONTEXT | QLCNIC_CAP0_LEGACY_MN\n\t\t\t\t\t\t| QLCNIC_CAP0_VALIDOFF);\n\tcap |= (QLCNIC_CAP0_JUMBO_CONTIGUOUS | QLCNIC_CAP0_LRO_CONTIGUOUS);\n\n\tif (qlcnic_check_multi_tx(adapter) &&\n\t    !adapter->ahw->diag_test) {\n\t\tcap |= QLCNIC_CAP0_TX_MULTI;\n\t} else {\n\t\ttemp_u16 = offsetof(struct qlcnic_hostrq_rx_ctx, msix_handler);\n\t\tprq->valid_field_offset = cpu_to_le16(temp_u16);\n\t\tprq->txrx_sds_binding = nsds_rings - 1;\n\t\ttemp_intr_crb_mode = QLCNIC_HOST_INT_CRB_MODE_SHARED;\n\t\tprq->host_int_crb_mode = cpu_to_le32(temp_intr_crb_mode);\n\t\ttemp_rds_crb_mode = QLCNIC_HOST_RDS_CRB_MODE_UNIQUE;\n\t\tprq->host_rds_crb_mode = cpu_to_le32(temp_rds_crb_mode);\n\t}\n\n\tprq->capabilities[0] = cpu_to_le32(cap);\n\n\tprq->num_rds_rings = cpu_to_le16(nrds_rings);\n\tprq->num_sds_rings = cpu_to_le16(nsds_rings);\n\tprq->rds_ring_offset = 0;\n\n\tval = le32_to_cpu(prq->rds_ring_offset) +\n\t\t(sizeof(struct qlcnic_hostrq_rds_ring) * nrds_rings);\n\tprq->sds_ring_offset = cpu_to_le32(val);\n\n\tprq_rds = (struct qlcnic_hostrq_rds_ring *)(prq->data +\n\t\t\tle32_to_cpu(prq->rds_ring_offset));\n\n\tfor (i = 0; i < nrds_rings; i++) {\n\t\trds_ring = &recv_ctx->rds_rings[i];\n\t\trds_ring->producer = 0;\n\t\tprq_rds[i].host_phys_addr = cpu_to_le64(rds_ring->phys_addr);\n\t\tprq_rds[i].ring_size = cpu_to_le32(rds_ring->num_desc);\n\t\tprq_rds[i].ring_kind = cpu_to_le32(i);\n\t\tprq_rds[i].buff_size = cpu_to_le64(rds_ring->dma_size);\n\t}\n\n\tprq_sds = (struct qlcnic_hostrq_sds_ring *)(prq->data +\n\t\t\tle32_to_cpu(prq->sds_ring_offset));\n\n\tfor (i = 0; i < nsds_rings; i++) {\n\t\tsds_ring = &recv_ctx->sds_rings[i];\n\t\tsds_ring->consumer = 0;\n\t\tmemset(sds_ring->desc_head, 0, STATUS_DESC_RINGSIZE(sds_ring));\n\t\tprq_sds[i].host_phys_addr = cpu_to_le64(sds_ring->phys_addr);\n\t\tprq_sds[i].ring_size = cpu_to_le32(sds_ring->num_desc);\n\t\tif (qlcnic_check_multi_tx(adapter) &&\n\t\t    !adapter->ahw->diag_test)\n\t\t\tprq_sds[i].msi_index = cpu_to_le16(ahw->intr_tbl[i].id);\n\t\telse\n\t\t\tprq_sds[i].msi_index = cpu_to_le16(i);\n\t}\n\n\tphys_addr = hostrq_phys_addr;\n\terr = qlcnic_alloc_mbx_args(&cmd, adapter, QLCNIC_CMD_CREATE_RX_CTX);\n\tif (err)\n\t\tgoto out_free_rsp;\n\n\tcmd.req.arg[1] = MSD(phys_addr);\n\tcmd.req.arg[2] = LSD(phys_addr);\n\tcmd.req.arg[3] = rq_size;\n\terr = qlcnic_issue_cmd(adapter, &cmd);\n\tif (err) {\n\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\"Failed to create rx ctx in firmware%d\\n\", err);\n\t\tgoto out_free_rsp;\n\t}\n\n\tprsp_rds = ((struct qlcnic_cardrsp_rds_ring *)\n\t\t\t &prsp->data[le32_to_cpu(prsp->rds_ring_offset)]);\n\n\tfor (i = 0; i < le16_to_cpu(prsp->num_rds_rings); i++) {\n\t\trds_ring = &recv_ctx->rds_rings[i];\n\t\treg = le32_to_cpu(prsp_rds[i].host_producer_crb);\n\t\trds_ring->crb_rcv_producer = ahw->pci_base0 + reg;\n\t}\n\n\tprsp_sds = ((struct qlcnic_cardrsp_sds_ring *)\n\t\t\t&prsp->data[le32_to_cpu(prsp->sds_ring_offset)]);\n\n\tfor (i = 0; i < le16_to_cpu(prsp->num_sds_rings); i++) {\n\t\tsds_ring = &recv_ctx->sds_rings[i];\n\t\treg = le32_to_cpu(prsp_sds[i].host_consumer_crb);\n\t\tif (qlcnic_check_multi_tx(adapter) && !adapter->ahw->diag_test)\n\t\t\treg2 = ahw->intr_tbl[i].src;\n\t\telse\n\t\t\treg2 = le32_to_cpu(prsp_sds[i].interrupt_crb);\n\n\t\tsds_ring->crb_intr_mask = ahw->pci_base0 + reg2;\n\t\tsds_ring->crb_sts_consumer = ahw->pci_base0 + reg;\n\t}\n\n\trecv_ctx->state = le32_to_cpu(prsp->host_ctx_state);\n\trecv_ctx->context_id = le16_to_cpu(prsp->context_id);\n\trecv_ctx->virt_port = prsp->virt_port;\n\n\tnetdev_info(netdev, \"Rx Context[%d] Created, state 0x%x\\n\",\n\t\t    recv_ctx->context_id, recv_ctx->state);\n\tqlcnic_free_mbx_args(&cmd);\n\nout_free_rsp:\n\tdma_free_coherent(&adapter->pdev->dev, rsp_size, prsp,\n\t\t\t  cardrsp_phys_addr);\nout_free_rq:\n\tdma_free_coherent(&adapter->pdev->dev, rq_size, prq, hostrq_phys_addr);\n\n\treturn err;\n}\n\nvoid qlcnic_82xx_fw_cmd_del_rx_ctx(struct qlcnic_adapter *adapter)\n{\n\tint err;\n\tstruct qlcnic_cmd_args cmd;\n\tstruct qlcnic_recv_context *recv_ctx = adapter->recv_ctx;\n\n\terr = qlcnic_alloc_mbx_args(&cmd, adapter, QLCNIC_CMD_DESTROY_RX_CTX);\n\tif (err)\n\t\treturn;\n\n\tcmd.req.arg[1] = recv_ctx->context_id;\n\terr = qlcnic_issue_cmd(adapter, &cmd);\n\tif (err)\n\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\"Failed to destroy rx ctx in firmware\\n\");\n\n\trecv_ctx->state = QLCNIC_HOST_CTX_STATE_FREED;\n\tqlcnic_free_mbx_args(&cmd);\n}\n\nint qlcnic_82xx_fw_cmd_create_tx_ctx(struct qlcnic_adapter *adapter,\n\t\t\t\t     struct qlcnic_host_tx_ring *tx_ring,\n\t\t\t\t     int ring)\n{\n\tstruct qlcnic_hardware_context *ahw = adapter->ahw;\n\tstruct net_device *netdev = adapter->netdev;\n\tstruct qlcnic_hostrq_tx_ctx\t*prq;\n\tstruct qlcnic_hostrq_cds_ring\t*prq_cds;\n\tstruct qlcnic_cardrsp_tx_ctx\t*prsp;\n\tstruct qlcnic_cmd_args cmd;\n\tu32 temp, intr_mask, temp_int_crb_mode;\n\tdma_addr_t rq_phys_addr, rsp_phys_addr;\n\tint temp_nsds_rings, index, err;\n\tvoid *rq_addr, *rsp_addr;\n\tsize_t rq_size, rsp_size;\n\tu64 phys_addr;\n\tu16 msix_id;\n\n\t \n\ttx_ring->producer = 0;\n\ttx_ring->sw_consumer = 0;\n\t*(tx_ring->hw_consumer) = 0;\n\n\trq_size = SIZEOF_HOSTRQ_TX(struct qlcnic_hostrq_tx_ctx);\n\trq_addr = dma_alloc_coherent(&adapter->pdev->dev, rq_size,\n\t\t\t\t     &rq_phys_addr, GFP_KERNEL);\n\tif (!rq_addr)\n\t\treturn -ENOMEM;\n\n\trsp_size = SIZEOF_CARDRSP_TX(struct qlcnic_cardrsp_tx_ctx);\n\trsp_addr = dma_alloc_coherent(&adapter->pdev->dev, rsp_size,\n\t\t\t\t      &rsp_phys_addr, GFP_KERNEL);\n\tif (!rsp_addr) {\n\t\terr = -ENOMEM;\n\t\tgoto out_free_rq;\n\t}\n\n\tprq = rq_addr;\n\tprsp = rsp_addr;\n\n\tprq->host_rsp_dma_addr = cpu_to_le64(rsp_phys_addr);\n\n\ttemp = (QLCNIC_CAP0_LEGACY_CONTEXT | QLCNIC_CAP0_LEGACY_MN |\n\t\tQLCNIC_CAP0_LSO);\n\tif (qlcnic_check_multi_tx(adapter) && !adapter->ahw->diag_test)\n\t\ttemp |= QLCNIC_CAP0_TX_MULTI;\n\n\tprq->capabilities[0] = cpu_to_le32(temp);\n\n\tif (qlcnic_check_multi_tx(adapter) &&\n\t    !adapter->ahw->diag_test) {\n\t\ttemp_nsds_rings = adapter->drv_sds_rings;\n\t\tindex = temp_nsds_rings + ring;\n\t\tmsix_id = ahw->intr_tbl[index].id;\n\t\tprq->msi_index = cpu_to_le16(msix_id);\n\t} else {\n\t\ttemp_int_crb_mode = QLCNIC_HOST_INT_CRB_MODE_SHARED;\n\t\tprq->host_int_crb_mode = cpu_to_le32(temp_int_crb_mode);\n\t\tprq->msi_index = 0;\n\t}\n\n\tprq->interrupt_ctl = 0;\n\tprq->cmd_cons_dma_addr = cpu_to_le64(tx_ring->hw_cons_phys_addr);\n\n\tprq_cds = &prq->cds_ring;\n\n\tprq_cds->host_phys_addr = cpu_to_le64(tx_ring->phys_addr);\n\tprq_cds->ring_size = cpu_to_le32(tx_ring->num_desc);\n\n\tphys_addr = rq_phys_addr;\n\n\terr = qlcnic_alloc_mbx_args(&cmd, adapter, QLCNIC_CMD_CREATE_TX_CTX);\n\tif (err)\n\t\tgoto out_free_rsp;\n\n\tcmd.req.arg[1] = MSD(phys_addr);\n\tcmd.req.arg[2] = LSD(phys_addr);\n\tcmd.req.arg[3] = rq_size;\n\terr = qlcnic_issue_cmd(adapter, &cmd);\n\n\tif (err == QLCNIC_RCODE_SUCCESS) {\n\t\ttx_ring->state = le32_to_cpu(prsp->host_ctx_state);\n\t\ttemp = le32_to_cpu(prsp->cds_ring.host_producer_crb);\n\t\ttx_ring->crb_cmd_producer = adapter->ahw->pci_base0 + temp;\n\t\ttx_ring->ctx_id = le16_to_cpu(prsp->context_id);\n\t\tif (qlcnic_check_multi_tx(adapter) &&\n\t\t    !adapter->ahw->diag_test &&\n\t\t    (adapter->flags & QLCNIC_MSIX_ENABLED)) {\n\t\t\tindex = adapter->drv_sds_rings + ring;\n\t\t\tintr_mask = ahw->intr_tbl[index].src;\n\t\t\ttx_ring->crb_intr_mask = ahw->pci_base0 + intr_mask;\n\t\t}\n\n\t\tnetdev_info(netdev, \"Tx Context[0x%x] Created, state 0x%x\\n\",\n\t\t\t    tx_ring->ctx_id, tx_ring->state);\n\t} else {\n\t\tnetdev_err(netdev, \"Failed to create tx ctx in firmware%d\\n\",\n\t\t\t   err);\n\t\terr = -EIO;\n\t}\n\tqlcnic_free_mbx_args(&cmd);\n\nout_free_rsp:\n\tdma_free_coherent(&adapter->pdev->dev, rsp_size, rsp_addr,\n\t\t\t  rsp_phys_addr);\nout_free_rq:\n\tdma_free_coherent(&adapter->pdev->dev, rq_size, rq_addr, rq_phys_addr);\n\n\treturn err;\n}\n\nvoid qlcnic_82xx_fw_cmd_del_tx_ctx(struct qlcnic_adapter *adapter,\n\t\t\t\t   struct qlcnic_host_tx_ring *tx_ring)\n{\n\tstruct qlcnic_cmd_args cmd;\n\tint ret;\n\n\tret = qlcnic_alloc_mbx_args(&cmd, adapter, QLCNIC_CMD_DESTROY_TX_CTX);\n\tif (ret)\n\t\treturn;\n\n\tcmd.req.arg[1] = tx_ring->ctx_id;\n\tif (qlcnic_issue_cmd(adapter, &cmd))\n\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\"Failed to destroy tx ctx in firmware\\n\");\n\tqlcnic_free_mbx_args(&cmd);\n}\n\nint\nqlcnic_fw_cmd_set_port(struct qlcnic_adapter *adapter, u32 config)\n{\n\tint err;\n\tstruct qlcnic_cmd_args cmd;\n\n\terr = qlcnic_alloc_mbx_args(&cmd, adapter, QLCNIC_CMD_CONFIG_PORT);\n\tif (err)\n\t\treturn err;\n\n\tcmd.req.arg[1] = config;\n\terr = qlcnic_issue_cmd(adapter, &cmd);\n\tqlcnic_free_mbx_args(&cmd);\n\treturn err;\n}\n\nint qlcnic_alloc_hw_resources(struct qlcnic_adapter *adapter)\n{\n\tvoid *addr;\n\tint err, ring;\n\tstruct qlcnic_recv_context *recv_ctx;\n\tstruct qlcnic_host_rds_ring *rds_ring;\n\tstruct qlcnic_host_sds_ring *sds_ring;\n\tstruct qlcnic_host_tx_ring *tx_ring;\n\t__le32 *ptr;\n\n\tstruct pci_dev *pdev = adapter->pdev;\n\n\trecv_ctx = adapter->recv_ctx;\n\n\tfor (ring = 0; ring < adapter->drv_tx_rings; ring++) {\n\t\ttx_ring = &adapter->tx_ring[ring];\n\t\tptr = (__le32 *)dma_alloc_coherent(&pdev->dev, sizeof(u32),\n\t\t\t\t\t\t   &tx_ring->hw_cons_phys_addr,\n\t\t\t\t\t\t   GFP_KERNEL);\n\t\tif (ptr == NULL) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_out_free;\n\t\t}\n\n\t\ttx_ring->hw_consumer = ptr;\n\t\t \n\t\taddr = dma_alloc_coherent(&pdev->dev, TX_DESC_RINGSIZE(tx_ring),\n\t\t\t\t\t  &tx_ring->phys_addr,\n\t\t\t\t\t  GFP_KERNEL);\n\t\tif (addr == NULL) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_out_free;\n\t\t}\n\n\t\ttx_ring->desc_head = addr;\n\t}\n\n\tfor (ring = 0; ring < adapter->max_rds_rings; ring++) {\n\t\trds_ring = &recv_ctx->rds_rings[ring];\n\t\taddr = dma_alloc_coherent(&adapter->pdev->dev,\n\t\t\t\t\t  RCV_DESC_RINGSIZE(rds_ring),\n\t\t\t\t\t  &rds_ring->phys_addr, GFP_KERNEL);\n\t\tif (addr == NULL) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_out_free;\n\t\t}\n\t\trds_ring->desc_head = addr;\n\n\t}\n\n\tfor (ring = 0; ring < adapter->drv_sds_rings; ring++) {\n\t\tsds_ring = &recv_ctx->sds_rings[ring];\n\n\t\taddr = dma_alloc_coherent(&adapter->pdev->dev,\n\t\t\t\t\t  STATUS_DESC_RINGSIZE(sds_ring),\n\t\t\t\t\t  &sds_ring->phys_addr, GFP_KERNEL);\n\t\tif (addr == NULL) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_out_free;\n\t\t}\n\t\tsds_ring->desc_head = addr;\n\t}\n\n\treturn 0;\n\nerr_out_free:\n\tqlcnic_free_hw_resources(adapter);\n\treturn err;\n}\n\nint qlcnic_fw_create_ctx(struct qlcnic_adapter *dev)\n{\n\tint i, err, ring;\n\n\tif (dev->flags & QLCNIC_NEED_FLR) {\n\t\terr = pci_reset_function(dev->pdev);\n\t\tif (err) {\n\t\t\tdev_err(&dev->pdev->dev,\n\t\t\t\t\"Adapter reset failed (%d). Please reboot\\n\",\n\t\t\t\terr);\n\t\t\treturn err;\n\t\t}\n\t\tdev->flags &= ~QLCNIC_NEED_FLR;\n\t}\n\n\tif (qlcnic_83xx_check(dev) && (dev->flags & QLCNIC_MSIX_ENABLED)) {\n\t\tif (dev->ahw->diag_test != QLCNIC_LOOPBACK_TEST) {\n\t\t\terr = qlcnic_83xx_config_intrpt(dev, 1);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\tif (qlcnic_82xx_check(dev) && (dev->flags & QLCNIC_MSIX_ENABLED) &&\n\t    qlcnic_check_multi_tx(dev) && !dev->ahw->diag_test) {\n\t\terr = qlcnic_82xx_mq_intrpt(dev, 1);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\terr = qlcnic_fw_cmd_create_rx_ctx(dev);\n\tif (err)\n\t\tgoto err_out;\n\n\tfor (ring = 0; ring < dev->drv_tx_rings; ring++) {\n\t\terr = qlcnic_fw_cmd_create_tx_ctx(dev,\n\t\t\t\t\t\t  &dev->tx_ring[ring],\n\t\t\t\t\t\t  ring);\n\t\tif (err) {\n\t\t\tqlcnic_fw_cmd_del_rx_ctx(dev);\n\t\t\tif (ring == 0)\n\t\t\t\tgoto err_out;\n\n\t\t\tfor (i = 0; i < ring; i++)\n\t\t\t\tqlcnic_fw_cmd_del_tx_ctx(dev, &dev->tx_ring[i]);\n\n\t\t\tgoto err_out;\n\t\t}\n\t}\n\n\tset_bit(__QLCNIC_FW_ATTACHED, &dev->state);\n\n\treturn 0;\n\nerr_out:\n\tif (qlcnic_82xx_check(dev) && (dev->flags & QLCNIC_MSIX_ENABLED) &&\n\t    qlcnic_check_multi_tx(dev) && !dev->ahw->diag_test)\n\t\t\tqlcnic_82xx_config_intrpt(dev, 0);\n\n\tif (qlcnic_83xx_check(dev) && (dev->flags & QLCNIC_MSIX_ENABLED)) {\n\t\tif (dev->ahw->diag_test != QLCNIC_LOOPBACK_TEST)\n\t\t\tqlcnic_83xx_config_intrpt(dev, 0);\n\t}\n\n\treturn err;\n}\n\nvoid qlcnic_fw_destroy_ctx(struct qlcnic_adapter *adapter)\n{\n\tint ring;\n\n\tif (test_and_clear_bit(__QLCNIC_FW_ATTACHED, &adapter->state)) {\n\t\tqlcnic_fw_cmd_del_rx_ctx(adapter);\n\t\tfor (ring = 0; ring < adapter->drv_tx_rings; ring++)\n\t\t\tqlcnic_fw_cmd_del_tx_ctx(adapter,\n\t\t\t\t\t\t &adapter->tx_ring[ring]);\n\n\t\tif (qlcnic_82xx_check(adapter) &&\n\t\t    (adapter->flags & QLCNIC_MSIX_ENABLED) &&\n\t\t    qlcnic_check_multi_tx(adapter) &&\n\t\t    !adapter->ahw->diag_test)\n\t\t\t\tqlcnic_82xx_config_intrpt(adapter, 0);\n\n\t\tif (qlcnic_83xx_check(adapter) &&\n\t\t    (adapter->flags & QLCNIC_MSIX_ENABLED)) {\n\t\t\tif (adapter->ahw->diag_test != QLCNIC_LOOPBACK_TEST)\n\t\t\t\tqlcnic_83xx_config_intrpt(adapter, 0);\n\t\t}\n\t\t \n\t\tmdelay(20);\n\t}\n}\n\nvoid qlcnic_free_hw_resources(struct qlcnic_adapter *adapter)\n{\n\tstruct qlcnic_recv_context *recv_ctx;\n\tstruct qlcnic_host_rds_ring *rds_ring;\n\tstruct qlcnic_host_sds_ring *sds_ring;\n\tstruct qlcnic_host_tx_ring *tx_ring;\n\tint ring;\n\n\trecv_ctx = adapter->recv_ctx;\n\n\tfor (ring = 0; ring < adapter->drv_tx_rings; ring++) {\n\t\ttx_ring = &adapter->tx_ring[ring];\n\t\tif (tx_ring->hw_consumer != NULL) {\n\t\t\tdma_free_coherent(&adapter->pdev->dev, sizeof(u32),\n\t\t\t\t\t  tx_ring->hw_consumer,\n\t\t\t\t\t  tx_ring->hw_cons_phys_addr);\n\n\t\t\ttx_ring->hw_consumer = NULL;\n\t\t}\n\n\t\tif (tx_ring->desc_head != NULL) {\n\t\t\tdma_free_coherent(&adapter->pdev->dev,\n\t\t\t\t\t  TX_DESC_RINGSIZE(tx_ring),\n\t\t\t\t\t  tx_ring->desc_head,\n\t\t\t\t\t  tx_ring->phys_addr);\n\t\t\ttx_ring->desc_head = NULL;\n\t\t}\n\t}\n\n\tfor (ring = 0; ring < adapter->max_rds_rings; ring++) {\n\t\trds_ring = &recv_ctx->rds_rings[ring];\n\n\t\tif (rds_ring->desc_head != NULL) {\n\t\t\tdma_free_coherent(&adapter->pdev->dev,\n\t\t\t\t\tRCV_DESC_RINGSIZE(rds_ring),\n\t\t\t\t\trds_ring->desc_head,\n\t\t\t\t\trds_ring->phys_addr);\n\t\t\trds_ring->desc_head = NULL;\n\t\t}\n\t}\n\n\tfor (ring = 0; ring < adapter->drv_sds_rings; ring++) {\n\t\tsds_ring = &recv_ctx->sds_rings[ring];\n\n\t\tif (sds_ring->desc_head != NULL) {\n\t\t\tdma_free_coherent(&adapter->pdev->dev,\n\t\t\t\tSTATUS_DESC_RINGSIZE(sds_ring),\n\t\t\t\tsds_ring->desc_head,\n\t\t\t\tsds_ring->phys_addr);\n\t\t\tsds_ring->desc_head = NULL;\n\t\t}\n\t}\n}\n\nint qlcnic_82xx_config_intrpt(struct qlcnic_adapter *adapter, u8 op_type)\n{\n\tstruct qlcnic_hardware_context *ahw = adapter->ahw;\n\tstruct net_device *netdev = adapter->netdev;\n\tstruct qlcnic_cmd_args cmd;\n\tu32 type, val;\n\tint i, err = 0;\n\n\tfor (i = 0; i < ahw->num_msix; i++) {\n\t\terr = qlcnic_alloc_mbx_args(&cmd, adapter,\n\t\t\t\t\t    QLCNIC_CMD_MQ_TX_CONFIG_INTR);\n\t\tif (err)\n\t\t\treturn err;\n\t\ttype = op_type ? QLCNIC_INTRPT_ADD : QLCNIC_INTRPT_DEL;\n\t\tval = type | (ahw->intr_tbl[i].type << 4);\n\t\tif (ahw->intr_tbl[i].type == QLCNIC_INTRPT_MSIX)\n\t\t\tval |= (ahw->intr_tbl[i].id << 16);\n\t\tcmd.req.arg[1] = val;\n\t\terr = qlcnic_issue_cmd(adapter, &cmd);\n\t\tif (err) {\n\t\t\tnetdev_err(netdev, \"Failed to %s interrupts %d\\n\",\n\t\t\t\t   op_type == QLCNIC_INTRPT_ADD ? \"Add\" :\n\t\t\t\t   \"Delete\", err);\n\t\t\tqlcnic_free_mbx_args(&cmd);\n\t\t\treturn err;\n\t\t}\n\t\tval = cmd.rsp.arg[1];\n\t\tif (LSB(val)) {\n\t\t\tnetdev_info(netdev,\n\t\t\t\t    \"failed to configure interrupt for %d\\n\",\n\t\t\t\t    ahw->intr_tbl[i].id);\n\t\t\tcontinue;\n\t\t}\n\t\tif (op_type) {\n\t\t\tahw->intr_tbl[i].id = MSW(val);\n\t\t\tahw->intr_tbl[i].enabled = 1;\n\t\t\tahw->intr_tbl[i].src = cmd.rsp.arg[2];\n\t\t} else {\n\t\t\tahw->intr_tbl[i].id = i;\n\t\t\tahw->intr_tbl[i].enabled = 0;\n\t\t\tahw->intr_tbl[i].src = 0;\n\t\t}\n\t\tqlcnic_free_mbx_args(&cmd);\n\t}\n\n\treturn err;\n}\n\nint qlcnic_82xx_get_mac_address(struct qlcnic_adapter *adapter, u8 *mac,\n\t\t\t\tu8 function)\n{\n\tint err, i;\n\tstruct qlcnic_cmd_args cmd;\n\tu32 mac_low, mac_high;\n\n\terr = qlcnic_alloc_mbx_args(&cmd, adapter, QLCNIC_CMD_MAC_ADDRESS);\n\tif (err)\n\t\treturn err;\n\n\tcmd.req.arg[1] = function | BIT_8;\n\terr = qlcnic_issue_cmd(adapter, &cmd);\n\n\tif (err == QLCNIC_RCODE_SUCCESS) {\n\t\tmac_low = cmd.rsp.arg[1];\n\t\tmac_high = cmd.rsp.arg[2];\n\n\t\tfor (i = 0; i < 2; i++)\n\t\t\tmac[i] = (u8) (mac_high >> ((1 - i) * 8));\n\t\tfor (i = 2; i < 6; i++)\n\t\t\tmac[i] = (u8) (mac_low >> ((5 - i) * 8));\n\t} else {\n\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\"Failed to get mac address%d\\n\", err);\n\t\terr = -EIO;\n\t}\n\tqlcnic_free_mbx_args(&cmd);\n\treturn err;\n}\n\n \nint qlcnic_82xx_get_nic_info(struct qlcnic_adapter *adapter,\n\t\t\t     struct qlcnic_info *npar_info, u8 func_id)\n{\n\tint\terr;\n\tdma_addr_t nic_dma_t;\n\tconst struct qlcnic_info_le *nic_info;\n\tvoid *nic_info_addr;\n\tstruct qlcnic_cmd_args cmd;\n\tsize_t  nic_size = sizeof(struct qlcnic_info_le);\n\n\tnic_info_addr = dma_alloc_coherent(&adapter->pdev->dev, nic_size,\n\t\t\t\t\t   &nic_dma_t, GFP_KERNEL);\n\tif (!nic_info_addr)\n\t\treturn -ENOMEM;\n\n\tnic_info = nic_info_addr;\n\n\terr = qlcnic_alloc_mbx_args(&cmd, adapter, QLCNIC_CMD_GET_NIC_INFO);\n\tif (err)\n\t\tgoto out_free_dma;\n\n\tcmd.req.arg[1] = MSD(nic_dma_t);\n\tcmd.req.arg[2] = LSD(nic_dma_t);\n\tcmd.req.arg[3] = (func_id << 16 | nic_size);\n\terr = qlcnic_issue_cmd(adapter, &cmd);\n\tif (err != QLCNIC_RCODE_SUCCESS) {\n\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\"Failed to get nic info%d\\n\", err);\n\t\terr = -EIO;\n\t} else {\n\t\tnpar_info->pci_func = le16_to_cpu(nic_info->pci_func);\n\t\tnpar_info->op_mode = le16_to_cpu(nic_info->op_mode);\n\t\tnpar_info->min_tx_bw = le16_to_cpu(nic_info->min_tx_bw);\n\t\tnpar_info->max_tx_bw = le16_to_cpu(nic_info->max_tx_bw);\n\t\tnpar_info->phys_port = le16_to_cpu(nic_info->phys_port);\n\t\tnpar_info->switch_mode = le16_to_cpu(nic_info->switch_mode);\n\t\tnpar_info->max_tx_ques = le16_to_cpu(nic_info->max_tx_ques);\n\t\tnpar_info->max_rx_ques = le16_to_cpu(nic_info->max_rx_ques);\n\t\tnpar_info->capabilities = le32_to_cpu(nic_info->capabilities);\n\t\tnpar_info->max_mtu = le16_to_cpu(nic_info->max_mtu);\n\t}\n\n\tqlcnic_free_mbx_args(&cmd);\nout_free_dma:\n\tdma_free_coherent(&adapter->pdev->dev, nic_size, nic_info_addr,\n\t\t\t  nic_dma_t);\n\n\treturn err;\n}\n\n \nint qlcnic_82xx_set_nic_info(struct qlcnic_adapter *adapter,\n\t\t\t     struct qlcnic_info *nic)\n{\n\tint err = -EIO;\n\tdma_addr_t nic_dma_t;\n\tvoid *nic_info_addr;\n\tstruct qlcnic_cmd_args cmd;\n\tstruct qlcnic_info_le *nic_info;\n\tsize_t nic_size = sizeof(struct qlcnic_info_le);\n\n\tif (adapter->ahw->op_mode != QLCNIC_MGMT_FUNC)\n\t\treturn err;\n\n\tnic_info_addr = dma_alloc_coherent(&adapter->pdev->dev, nic_size,\n\t\t\t\t\t   &nic_dma_t, GFP_KERNEL);\n\tif (!nic_info_addr)\n\t\treturn -ENOMEM;\n\n\tnic_info = nic_info_addr;\n\n\tnic_info->pci_func = cpu_to_le16(nic->pci_func);\n\tnic_info->op_mode = cpu_to_le16(nic->op_mode);\n\tnic_info->phys_port = cpu_to_le16(nic->phys_port);\n\tnic_info->switch_mode = cpu_to_le16(nic->switch_mode);\n\tnic_info->capabilities = cpu_to_le32(nic->capabilities);\n\tnic_info->max_mac_filters = nic->max_mac_filters;\n\tnic_info->max_tx_ques = cpu_to_le16(nic->max_tx_ques);\n\tnic_info->max_rx_ques = cpu_to_le16(nic->max_rx_ques);\n\tnic_info->min_tx_bw = cpu_to_le16(nic->min_tx_bw);\n\tnic_info->max_tx_bw = cpu_to_le16(nic->max_tx_bw);\n\n\terr = qlcnic_alloc_mbx_args(&cmd, adapter, QLCNIC_CMD_SET_NIC_INFO);\n\tif (err)\n\t\tgoto out_free_dma;\n\n\tcmd.req.arg[1] = MSD(nic_dma_t);\n\tcmd.req.arg[2] = LSD(nic_dma_t);\n\tcmd.req.arg[3] = ((nic->pci_func << 16) | nic_size);\n\terr = qlcnic_issue_cmd(adapter, &cmd);\n\n\tif (err != QLCNIC_RCODE_SUCCESS) {\n\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\"Failed to set nic info%d\\n\", err);\n\t\terr = -EIO;\n\t}\n\n\tqlcnic_free_mbx_args(&cmd);\nout_free_dma:\n\tdma_free_coherent(&adapter->pdev->dev, nic_size, nic_info_addr,\n\t\t\t  nic_dma_t);\n\n\treturn err;\n}\n\n \nint qlcnic_82xx_get_pci_info(struct qlcnic_adapter *adapter,\n\t\t\t     struct qlcnic_pci_info *pci_info)\n{\n\tstruct qlcnic_hardware_context *ahw = adapter->ahw;\n\tsize_t npar_size = sizeof(struct qlcnic_pci_info_le);\n\tsize_t pci_size = npar_size * ahw->max_vnic_func;\n\tu16 nic = 0, fcoe = 0, iscsi = 0;\n\tstruct qlcnic_pci_info_le *npar;\n\tstruct qlcnic_cmd_args cmd;\n\tdma_addr_t pci_info_dma_t;\n\tvoid *pci_info_addr;\n\tint err = 0, i;\n\n\tpci_info_addr = dma_alloc_coherent(&adapter->pdev->dev, pci_size,\n\t\t\t\t\t   &pci_info_dma_t, GFP_KERNEL);\n\tif (!pci_info_addr)\n\t\treturn -ENOMEM;\n\n\tnpar = pci_info_addr;\n\terr = qlcnic_alloc_mbx_args(&cmd, adapter, QLCNIC_CMD_GET_PCI_INFO);\n\tif (err)\n\t\tgoto out_free_dma;\n\n\tcmd.req.arg[1] = MSD(pci_info_dma_t);\n\tcmd.req.arg[2] = LSD(pci_info_dma_t);\n\tcmd.req.arg[3] = pci_size;\n\terr = qlcnic_issue_cmd(adapter, &cmd);\n\n\tahw->total_nic_func = 0;\n\tif (err == QLCNIC_RCODE_SUCCESS) {\n\t\tfor (i = 0; i < ahw->max_vnic_func; i++, npar++, pci_info++) {\n\t\t\tpci_info->id = le16_to_cpu(npar->id);\n\t\t\tpci_info->active = le16_to_cpu(npar->active);\n\t\t\tif (!pci_info->active)\n\t\t\t\tcontinue;\n\t\t\tpci_info->type = le16_to_cpu(npar->type);\n\t\t\terr = qlcnic_get_pci_func_type(adapter, pci_info->type,\n\t\t\t\t\t\t       &nic, &fcoe, &iscsi);\n\t\t\tpci_info->default_port =\n\t\t\t\tle16_to_cpu(npar->default_port);\n\t\t\tpci_info->tx_min_bw =\n\t\t\t\tle16_to_cpu(npar->tx_min_bw);\n\t\t\tpci_info->tx_max_bw =\n\t\t\t\tle16_to_cpu(npar->tx_max_bw);\n\t\t\tmemcpy(pci_info->mac, npar->mac, ETH_ALEN);\n\t\t}\n\t} else {\n\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\"Failed to get PCI Info%d\\n\", err);\n\t\terr = -EIO;\n\t}\n\n\tahw->total_nic_func = nic;\n\tahw->total_pci_func = nic + fcoe + iscsi;\n\tif (ahw->total_nic_func == 0 || ahw->total_pci_func == 0) {\n\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\"%s: Invalid function count: total nic func[%x], total pci func[%x]\\n\",\n\t\t\t__func__, ahw->total_nic_func, ahw->total_pci_func);\n\t\terr = -EIO;\n\t}\n\tqlcnic_free_mbx_args(&cmd);\nout_free_dma:\n\tdma_free_coherent(&adapter->pdev->dev, pci_size, pci_info_addr,\n\t\tpci_info_dma_t);\n\n\treturn err;\n}\n\n \nint qlcnic_config_port_mirroring(struct qlcnic_adapter *adapter, u8 id,\n\t\t\t\t u8 enable_mirroring, u8 pci_func)\n{\n\tstruct device *dev = &adapter->pdev->dev;\n\tstruct qlcnic_cmd_args cmd;\n\tint err = -EIO;\n\tu32 arg1;\n\n\tif (adapter->ahw->op_mode != QLCNIC_MGMT_FUNC ||\n\t    !(adapter->eswitch[id].flags & QLCNIC_SWITCH_ENABLE)) {\n\t\tdev_err(&adapter->pdev->dev, \"%s: Not a management function\\n\",\n\t\t\t__func__);\n\t\treturn err;\n\t}\n\n\targ1 = id | (enable_mirroring ? BIT_4 : 0);\n\targ1 |= pci_func << 8;\n\n\terr = qlcnic_alloc_mbx_args(&cmd, adapter,\n\t\t\t\t    QLCNIC_CMD_SET_PORTMIRRORING);\n\tif (err)\n\t\treturn err;\n\n\tcmd.req.arg[1] = arg1;\n\terr = qlcnic_issue_cmd(adapter, &cmd);\n\n\tif (err != QLCNIC_RCODE_SUCCESS)\n\t\tdev_err(dev, \"Failed to configure port mirroring for vNIC function %d on eSwitch %d\\n\",\n\t\t\tpci_func, id);\n\telse\n\t\tdev_info(dev, \"Configured port mirroring for vNIC function %d on eSwitch %d\\n\",\n\t\t\t pci_func, id);\n\tqlcnic_free_mbx_args(&cmd);\n\n\treturn err;\n}\n\nint qlcnic_get_port_stats(struct qlcnic_adapter *adapter, const u8 func,\n\t\tconst u8 rx_tx, struct __qlcnic_esw_statistics *esw_stats) {\n\n\tsize_t stats_size = sizeof(struct qlcnic_esw_stats_le);\n\tstruct qlcnic_esw_stats_le *stats;\n\tdma_addr_t stats_dma_t;\n\tvoid *stats_addr;\n\tu32 arg1;\n\tstruct qlcnic_cmd_args cmd;\n\tint err;\n\n\tif (esw_stats == NULL)\n\t\treturn -ENOMEM;\n\n\tif ((adapter->ahw->op_mode != QLCNIC_MGMT_FUNC) &&\n\t    (func != adapter->ahw->pci_func)) {\n\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\"Not privilege to query stats for func=%d\", func);\n\t\treturn -EIO;\n\t}\n\n\tstats_addr = dma_alloc_coherent(&adapter->pdev->dev, stats_size,\n\t\t\t\t\t&stats_dma_t, GFP_KERNEL);\n\tif (!stats_addr)\n\t\treturn -ENOMEM;\n\n\targ1 = func | QLCNIC_STATS_VERSION << 8 | QLCNIC_STATS_PORT << 12;\n\targ1 |= rx_tx << 15 | stats_size << 16;\n\n\terr = qlcnic_alloc_mbx_args(&cmd, adapter,\n\t\t\t\t    QLCNIC_CMD_GET_ESWITCH_STATS);\n\tif (err)\n\t\tgoto out_free_dma;\n\n\tcmd.req.arg[1] = arg1;\n\tcmd.req.arg[2] = MSD(stats_dma_t);\n\tcmd.req.arg[3] = LSD(stats_dma_t);\n\terr = qlcnic_issue_cmd(adapter, &cmd);\n\n\tif (!err) {\n\t\tstats = stats_addr;\n\t\tesw_stats->context_id = le16_to_cpu(stats->context_id);\n\t\tesw_stats->version = le16_to_cpu(stats->version);\n\t\tesw_stats->size = le16_to_cpu(stats->size);\n\t\tesw_stats->multicast_frames =\n\t\t\t\tle64_to_cpu(stats->multicast_frames);\n\t\tesw_stats->broadcast_frames =\n\t\t\t\tle64_to_cpu(stats->broadcast_frames);\n\t\tesw_stats->unicast_frames = le64_to_cpu(stats->unicast_frames);\n\t\tesw_stats->dropped_frames = le64_to_cpu(stats->dropped_frames);\n\t\tesw_stats->local_frames = le64_to_cpu(stats->local_frames);\n\t\tesw_stats->errors = le64_to_cpu(stats->errors);\n\t\tesw_stats->numbytes = le64_to_cpu(stats->numbytes);\n\t}\n\n\tqlcnic_free_mbx_args(&cmd);\nout_free_dma:\n\tdma_free_coherent(&adapter->pdev->dev, stats_size, stats_addr,\n\t\t\t  stats_dma_t);\n\n\treturn err;\n}\n\n \nint qlcnic_get_mac_stats(struct qlcnic_adapter *adapter,\n\t\tstruct qlcnic_mac_statistics *mac_stats)\n{\n\tstruct qlcnic_mac_statistics_le *stats;\n\tstruct qlcnic_cmd_args cmd;\n\tsize_t stats_size = sizeof(struct qlcnic_mac_statistics_le);\n\tdma_addr_t stats_dma_t;\n\tvoid *stats_addr;\n\tint err;\n\n\tif (mac_stats == NULL)\n\t\treturn -ENOMEM;\n\n\tstats_addr = dma_alloc_coherent(&adapter->pdev->dev, stats_size,\n\t\t\t\t\t&stats_dma_t, GFP_KERNEL);\n\tif (!stats_addr)\n\t\treturn -ENOMEM;\n\n\terr = qlcnic_alloc_mbx_args(&cmd, adapter, QLCNIC_CMD_GET_MAC_STATS);\n\tif (err)\n\t\tgoto out_free_dma;\n\n\tcmd.req.arg[1] = stats_size << 16;\n\tcmd.req.arg[2] = MSD(stats_dma_t);\n\tcmd.req.arg[3] = LSD(stats_dma_t);\n\terr = qlcnic_issue_cmd(adapter, &cmd);\n\tif (!err) {\n\t\tstats = stats_addr;\n\t\tmac_stats->mac_tx_frames = le64_to_cpu(stats->mac_tx_frames);\n\t\tmac_stats->mac_tx_bytes = le64_to_cpu(stats->mac_tx_bytes);\n\t\tmac_stats->mac_tx_mcast_pkts =\n\t\t\t\t\tle64_to_cpu(stats->mac_tx_mcast_pkts);\n\t\tmac_stats->mac_tx_bcast_pkts =\n\t\t\t\t\tle64_to_cpu(stats->mac_tx_bcast_pkts);\n\t\tmac_stats->mac_rx_frames = le64_to_cpu(stats->mac_rx_frames);\n\t\tmac_stats->mac_rx_bytes = le64_to_cpu(stats->mac_rx_bytes);\n\t\tmac_stats->mac_rx_mcast_pkts =\n\t\t\t\t\tle64_to_cpu(stats->mac_rx_mcast_pkts);\n\t\tmac_stats->mac_rx_length_error =\n\t\t\t\tle64_to_cpu(stats->mac_rx_length_error);\n\t\tmac_stats->mac_rx_length_small =\n\t\t\t\tle64_to_cpu(stats->mac_rx_length_small);\n\t\tmac_stats->mac_rx_length_large =\n\t\t\t\tle64_to_cpu(stats->mac_rx_length_large);\n\t\tmac_stats->mac_rx_jabber = le64_to_cpu(stats->mac_rx_jabber);\n\t\tmac_stats->mac_rx_dropped = le64_to_cpu(stats->mac_rx_dropped);\n\t\tmac_stats->mac_rx_crc_error = le64_to_cpu(stats->mac_rx_crc_error);\n\t} else {\n\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\"%s: Get mac stats failed, err=%d.\\n\", __func__, err);\n\t}\n\n\tqlcnic_free_mbx_args(&cmd);\n\nout_free_dma:\n\tdma_free_coherent(&adapter->pdev->dev, stats_size, stats_addr,\n\t\t\t  stats_dma_t);\n\n\treturn err;\n}\n\nint qlcnic_get_eswitch_stats(struct qlcnic_adapter *adapter, const u8 eswitch,\n\t\tconst u8 rx_tx, struct __qlcnic_esw_statistics *esw_stats) {\n\n\tstruct __qlcnic_esw_statistics port_stats;\n\tu8 i;\n\tint ret = -EIO;\n\n\tif (esw_stats == NULL)\n\t\treturn -ENOMEM;\n\tif (adapter->ahw->op_mode != QLCNIC_MGMT_FUNC)\n\t\treturn -EIO;\n\tif (adapter->npars == NULL)\n\t\treturn -EIO;\n\n\tmemset(esw_stats, 0, sizeof(u64));\n\tesw_stats->unicast_frames = QLCNIC_STATS_NOT_AVAIL;\n\tesw_stats->multicast_frames = QLCNIC_STATS_NOT_AVAIL;\n\tesw_stats->broadcast_frames = QLCNIC_STATS_NOT_AVAIL;\n\tesw_stats->dropped_frames = QLCNIC_STATS_NOT_AVAIL;\n\tesw_stats->errors = QLCNIC_STATS_NOT_AVAIL;\n\tesw_stats->local_frames = QLCNIC_STATS_NOT_AVAIL;\n\tesw_stats->numbytes = QLCNIC_STATS_NOT_AVAIL;\n\tesw_stats->context_id = eswitch;\n\n\tfor (i = 0; i < adapter->ahw->total_nic_func; i++) {\n\t\tif (adapter->npars[i].phy_port != eswitch)\n\t\t\tcontinue;\n\n\t\tmemset(&port_stats, 0, sizeof(struct __qlcnic_esw_statistics));\n\t\tif (qlcnic_get_port_stats(adapter, adapter->npars[i].pci_func,\n\t\t\t\t\t  rx_tx, &port_stats))\n\t\t\tcontinue;\n\n\t\tesw_stats->size = port_stats.size;\n\t\tesw_stats->version = port_stats.version;\n\t\tQLCNIC_ADD_ESW_STATS(esw_stats->unicast_frames,\n\t\t\t\t\t\tport_stats.unicast_frames);\n\t\tQLCNIC_ADD_ESW_STATS(esw_stats->multicast_frames,\n\t\t\t\t\t\tport_stats.multicast_frames);\n\t\tQLCNIC_ADD_ESW_STATS(esw_stats->broadcast_frames,\n\t\t\t\t\t\tport_stats.broadcast_frames);\n\t\tQLCNIC_ADD_ESW_STATS(esw_stats->dropped_frames,\n\t\t\t\t\t\tport_stats.dropped_frames);\n\t\tQLCNIC_ADD_ESW_STATS(esw_stats->errors,\n\t\t\t\t\t\tport_stats.errors);\n\t\tQLCNIC_ADD_ESW_STATS(esw_stats->local_frames,\n\t\t\t\t\t\tport_stats.local_frames);\n\t\tQLCNIC_ADD_ESW_STATS(esw_stats->numbytes,\n\t\t\t\t\t\tport_stats.numbytes);\n\t\tret = 0;\n\t}\n\treturn ret;\n}\n\nint qlcnic_clear_esw_stats(struct qlcnic_adapter *adapter, const u8 func_esw,\n\t\tconst u8 port, const u8 rx_tx)\n{\n\tstruct qlcnic_hardware_context *ahw = adapter->ahw;\n\tstruct qlcnic_cmd_args cmd;\n\tint err;\n\tu32 arg1;\n\n\tif (ahw->op_mode != QLCNIC_MGMT_FUNC)\n\t\treturn -EIO;\n\n\tif (func_esw == QLCNIC_STATS_PORT) {\n\t\tif (port >= ahw->max_vnic_func)\n\t\t\tgoto err_ret;\n\t} else if (func_esw == QLCNIC_STATS_ESWITCH) {\n\t\tif (port >= QLCNIC_NIU_MAX_XG_PORTS)\n\t\t\tgoto err_ret;\n\t} else {\n\t\tgoto err_ret;\n\t}\n\n\tif (rx_tx > QLCNIC_QUERY_TX_COUNTER)\n\t\tgoto err_ret;\n\n\targ1 = port | QLCNIC_STATS_VERSION << 8 | func_esw << 12;\n\targ1 |= BIT_14 | rx_tx << 15;\n\n\terr = qlcnic_alloc_mbx_args(&cmd, adapter,\n\t\t\t\t    QLCNIC_CMD_GET_ESWITCH_STATS);\n\tif (err)\n\t\treturn err;\n\n\tcmd.req.arg[1] = arg1;\n\terr = qlcnic_issue_cmd(adapter, &cmd);\n\tqlcnic_free_mbx_args(&cmd);\n\treturn err;\n\nerr_ret:\n\tdev_err(&adapter->pdev->dev,\n\t\t\"Invalid args func_esw %d port %d rx_ctx %d\\n\",\n\t\tfunc_esw, port, rx_tx);\n\treturn -EIO;\n}\n\nstatic int __qlcnic_get_eswitch_port_config(struct qlcnic_adapter *adapter,\n\t\t\t\t\t    u32 *arg1, u32 *arg2)\n{\n\tstruct device *dev = &adapter->pdev->dev;\n\tstruct qlcnic_cmd_args cmd;\n\tu8 pci_func = *arg1 >> 8;\n\tint err;\n\n\terr = qlcnic_alloc_mbx_args(&cmd, adapter,\n\t\t\t\t    QLCNIC_CMD_GET_ESWITCH_PORT_CONFIG);\n\tif (err)\n\t\treturn err;\n\n\tcmd.req.arg[1] = *arg1;\n\terr = qlcnic_issue_cmd(adapter, &cmd);\n\t*arg1 = cmd.rsp.arg[1];\n\t*arg2 = cmd.rsp.arg[2];\n\tqlcnic_free_mbx_args(&cmd);\n\n\tif (err == QLCNIC_RCODE_SUCCESS)\n\t\tdev_info(dev, \"Get eSwitch port config for vNIC function %d\\n\",\n\t\t\t pci_func);\n\telse\n\t\tdev_err(dev, \"Failed to get eswitch port config for vNIC function %d\\n\",\n\t\t\tpci_func);\n\treturn err;\n}\n \nint qlcnic_config_switch_port(struct qlcnic_adapter *adapter,\n\t\tstruct qlcnic_esw_func_cfg *esw_cfg)\n{\n\tstruct device *dev = &adapter->pdev->dev;\n\tstruct qlcnic_cmd_args cmd;\n\tint err = -EIO, index;\n\tu32 arg1, arg2 = 0;\n\tu8 pci_func;\n\n\tif (adapter->ahw->op_mode != QLCNIC_MGMT_FUNC) {\n\t\tdev_err(&adapter->pdev->dev, \"%s: Not a management function\\n\",\n\t\t\t__func__);\n\t\treturn err;\n\t}\n\n\tpci_func = esw_cfg->pci_func;\n\tindex = qlcnic_is_valid_nic_func(adapter, pci_func);\n\tif (index < 0)\n\t\treturn err;\n\targ1 = (adapter->npars[index].phy_port & BIT_0);\n\targ1 |= (pci_func << 8);\n\n\tif (__qlcnic_get_eswitch_port_config(adapter, &arg1, &arg2))\n\t\treturn err;\n\targ1 &= ~(0x0ff << 8);\n\targ1 |= (pci_func << 8);\n\targ1 &= ~(BIT_2 | BIT_3);\n\tswitch (esw_cfg->op_mode) {\n\tcase QLCNIC_PORT_DEFAULTS:\n\t\targ1 |= (BIT_4 | BIT_6 | BIT_7);\n\t\targ2 |= (BIT_0 | BIT_1);\n\t\tif (adapter->ahw->capabilities & QLCNIC_FW_CAPABILITY_TSO)\n\t\t\targ2 |= (BIT_2 | BIT_3);\n\t\tif (!(esw_cfg->discard_tagged))\n\t\t\targ1 &= ~BIT_4;\n\t\tif (!(esw_cfg->promisc_mode))\n\t\t\targ1 &= ~BIT_6;\n\t\tif (!(esw_cfg->mac_override))\n\t\t\targ1 &= ~BIT_7;\n\t\tif (!(esw_cfg->mac_anti_spoof))\n\t\t\targ2 &= ~BIT_0;\n\t\tif (!(esw_cfg->offload_flags & BIT_0))\n\t\t\targ2 &= ~(BIT_1 | BIT_2 | BIT_3);\n\t\tif (!(esw_cfg->offload_flags & BIT_1))\n\t\t\targ2 &= ~BIT_2;\n\t\tif (!(esw_cfg->offload_flags & BIT_2))\n\t\t\targ2 &= ~BIT_3;\n\t\tbreak;\n\tcase QLCNIC_ADD_VLAN:\n\t\t\targ1 &= ~(0x0ffff << 16);\n\t\t\targ1 |= (BIT_2 | BIT_5);\n\t\t\targ1 |= (esw_cfg->vlan_id << 16);\n\t\t\tbreak;\n\tcase QLCNIC_DEL_VLAN:\n\t\t\targ1 |= (BIT_3 | BIT_5);\n\t\t\targ1 &= ~(0x0ffff << 16);\n\t\t\tbreak;\n\tdefault:\n\t\tdev_err(&adapter->pdev->dev, \"%s: Invalid opmode 0x%x\\n\",\n\t\t\t__func__, esw_cfg->op_mode);\n\t\treturn err;\n\t}\n\n\terr = qlcnic_alloc_mbx_args(&cmd, adapter,\n\t\t\t\t    QLCNIC_CMD_CONFIGURE_ESWITCH);\n\tif (err)\n\t\treturn err;\n\n\tcmd.req.arg[1] = arg1;\n\tcmd.req.arg[2] = arg2;\n\terr = qlcnic_issue_cmd(adapter, &cmd);\n\tqlcnic_free_mbx_args(&cmd);\n\n\tif (err != QLCNIC_RCODE_SUCCESS)\n\t\tdev_err(dev, \"Failed to configure eswitch for vNIC function %d\\n\",\n\t\t\tpci_func);\n\telse\n\t\tdev_info(dev, \"Configured eSwitch for vNIC function %d\\n\",\n\t\t\t pci_func);\n\n\treturn err;\n}\n\nint\nqlcnic_get_eswitch_port_config(struct qlcnic_adapter *adapter,\n\t\t\tstruct qlcnic_esw_func_cfg *esw_cfg)\n{\n\tu32 arg1, arg2;\n\tint index;\n\tu8 phy_port;\n\n\tif (adapter->ahw->op_mode == QLCNIC_MGMT_FUNC) {\n\t\tindex = qlcnic_is_valid_nic_func(adapter, esw_cfg->pci_func);\n\t\tif (index < 0)\n\t\t\treturn -EIO;\n\t\tphy_port = adapter->npars[index].phy_port;\n\t} else {\n\t\tphy_port = adapter->ahw->physical_port;\n\t}\n\targ1 = phy_port;\n\targ1 |= (esw_cfg->pci_func << 8);\n\tif (__qlcnic_get_eswitch_port_config(adapter, &arg1, &arg2))\n\t\treturn -EIO;\n\n\tesw_cfg->discard_tagged = !!(arg1 & BIT_4);\n\tesw_cfg->host_vlan_tag = !!(arg1 & BIT_5);\n\tesw_cfg->promisc_mode = !!(arg1 & BIT_6);\n\tesw_cfg->mac_override = !!(arg1 & BIT_7);\n\tesw_cfg->vlan_id = LSW(arg1 >> 16);\n\tesw_cfg->mac_anti_spoof = (arg2 & 0x1);\n\tesw_cfg->offload_flags = ((arg2 >> 1) & 0x7);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}