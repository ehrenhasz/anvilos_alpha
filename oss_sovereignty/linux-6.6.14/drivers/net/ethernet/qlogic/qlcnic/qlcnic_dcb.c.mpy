{
  "module_name": "qlcnic_dcb.c",
  "hash_id": "bbe837159040bad63714e388ff3101260d48644d2145c903929549ca839e0ddf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/qlogic/qlcnic/qlcnic_dcb.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include \"qlcnic.h\"\n\n#define QLC_DCB_NUM_PARAM\t\t3\n#define QLC_DCB_LOCAL_IDX\t\t0\n#define QLC_DCB_OPER_IDX\t\t1\n#define QLC_DCB_PEER_IDX\t\t2\n\n#define QLC_DCB_GET_MAP(V)\t\t(1 << V)\n\n#define QLC_DCB_FW_VER\t\t\t0x2\n#define QLC_DCB_MAX_TC\t\t\t0x8\n#define QLC_DCB_MAX_APP\t\t\t0x8\n#define QLC_DCB_MAX_PRIO\t\tQLC_DCB_MAX_TC\n#define QLC_DCB_MAX_PG\t\t\tQLC_DCB_MAX_TC\n\n#define QLC_DCB_TSA_SUPPORT(V)\t\t(V & 0x1)\n#define QLC_DCB_ETS_SUPPORT(V)\t\t((V >> 1) & 0x1)\n#define QLC_DCB_VERSION_SUPPORT(V)\t((V >> 2) & 0xf)\n#define QLC_DCB_MAX_NUM_TC(V)\t\t((V >> 20) & 0xf)\n#define QLC_DCB_MAX_NUM_ETS_TC(V)\t((V >> 24) & 0xf)\n#define QLC_DCB_MAX_NUM_PFC_TC(V)\t((V >> 28) & 0xf)\n#define QLC_DCB_GET_TC_PRIO(X, P)\t((X >> (P * 3)) & 0x7)\n#define QLC_DCB_GET_PGID_PRIO(X, P)\t((X >> (P * 8)) & 0xff)\n#define QLC_DCB_GET_BWPER_PG(X, P)\t((X >> (P * 8)) & 0xff)\n#define QLC_DCB_GET_TSA_PG(X, P)\t((X >> (P * 8)) & 0xff)\n#define QLC_DCB_GET_PFC_PRIO(X, P)\t(((X >> 24) >> P) & 0x1)\n#define QLC_DCB_GET_PROTO_ID_APP(X)\t((X >> 8) & 0xffff)\n#define QLC_DCB_GET_SELECTOR_APP(X)\t(X & 0xff)\n\n#define QLC_DCB_LOCAL_PARAM_FWID\t0x3\n#define QLC_DCB_OPER_PARAM_FWID\t\t0x1\n#define QLC_DCB_PEER_PARAM_FWID\t\t0x2\n\n#define QLC_83XX_DCB_GET_NUMAPP(X)\t((X >> 2) & 0xf)\n#define QLC_83XX_DCB_TSA_VALID(X)\t(X & 0x1)\n#define QLC_83XX_DCB_PFC_VALID(X)\t((X >> 1) & 0x1)\n#define QLC_83XX_DCB_GET_PRIOMAP_APP(X)\t(X >> 24)\n\n#define QLC_82XX_DCB_GET_NUMAPP(X)\t((X >> 12) & 0xf)\n#define QLC_82XX_DCB_TSA_VALID(X)\t((X >> 4) & 0x1)\n#define QLC_82XX_DCB_PFC_VALID(X)\t((X >> 5) & 0x1)\n#define QLC_82XX_DCB_GET_PRIOVAL_APP(X)\t((X >> 24) & 0x7)\n#define QLC_82XX_DCB_GET_PRIOMAP_APP(X)\t(1 << X)\n#define QLC_82XX_DCB_PRIO_TC_MAP\t(0x76543210)\n\nstatic const struct dcbnl_rtnl_ops qlcnic_dcbnl_ops;\n\nstatic void qlcnic_dcb_aen_work(struct work_struct *);\nstatic void qlcnic_dcb_data_cee_param_map(struct qlcnic_adapter *);\n\nstatic inline void __qlcnic_init_dcbnl_ops(struct qlcnic_dcb *);\nstatic void __qlcnic_dcb_free(struct qlcnic_dcb *);\nstatic int __qlcnic_dcb_attach(struct qlcnic_dcb *);\nstatic int __qlcnic_dcb_query_hw_capability(struct qlcnic_dcb *, char *);\nstatic void __qlcnic_dcb_get_info(struct qlcnic_dcb *);\n\nstatic int qlcnic_82xx_dcb_get_hw_capability(struct qlcnic_dcb *);\nstatic int qlcnic_82xx_dcb_query_cee_param(struct qlcnic_dcb *, char *, u8);\nstatic int qlcnic_82xx_dcb_get_cee_cfg(struct qlcnic_dcb *);\nstatic void qlcnic_82xx_dcb_aen_handler(struct qlcnic_dcb *, void *);\n\nstatic int qlcnic_83xx_dcb_get_hw_capability(struct qlcnic_dcb *);\nstatic int qlcnic_83xx_dcb_query_cee_param(struct qlcnic_dcb *, char *, u8);\nstatic int qlcnic_83xx_dcb_get_cee_cfg(struct qlcnic_dcb *);\nstatic void qlcnic_83xx_dcb_aen_handler(struct qlcnic_dcb *, void *);\n\nstruct qlcnic_dcb_capability {\n\tbool\ttsa_capability;\n\tbool\tets_capability;\n\tu8\tmax_num_tc;\n\tu8\tmax_ets_tc;\n\tu8\tmax_pfc_tc;\n\tu8\tdcb_capability;\n};\n\nstruct qlcnic_dcb_param {\n\tu32 hdr_prio_pfc_map[2];\n\tu32 prio_pg_map[2];\n\tu32 pg_bw_map[2];\n\tu32 pg_tsa_map[2];\n\tu32 app[QLC_DCB_MAX_APP];\n};\n\nstruct qlcnic_dcb_mbx_params {\n\t \n\tstruct qlcnic_dcb_param type[3];\n\tu32 prio_tc_map;\n};\n\nstruct qlcnic_82xx_dcb_param_mbx_le {\n\t__le32 hdr_prio_pfc_map[2];\n\t__le32 prio_pg_map[2];\n\t__le32 pg_bw_map[2];\n\t__le32 pg_tsa_map[2];\n\t__le32 app[QLC_DCB_MAX_APP];\n};\n\nenum qlcnic_dcb_selector {\n\tQLC_SELECTOR_DEF = 0x0,\n\tQLC_SELECTOR_ETHER,\n\tQLC_SELECTOR_TCP,\n\tQLC_SELECTOR_UDP,\n};\n\nenum qlcnic_dcb_prio_type {\n\tQLC_PRIO_NONE = 0,\n\tQLC_PRIO_GROUP,\n\tQLC_PRIO_LINK,\n};\n\nenum qlcnic_dcb_pfc_type {\n\tQLC_PFC_DISABLED = 0,\n\tQLC_PFC_FULL,\n\tQLC_PFC_TX,\n\tQLC_PFC_RX\n};\n\nstruct qlcnic_dcb_prio_cfg {\n\tbool valid;\n\tenum qlcnic_dcb_pfc_type pfc_type;\n};\n\nstruct qlcnic_dcb_pg_cfg {\n\tbool valid;\n\tu8 total_bw_percent;\t\t \n\tu8 prio_count;\n\tu8 tsa_type;\n};\n\nstruct qlcnic_dcb_tc_cfg {\n\tbool valid;\n\tstruct qlcnic_dcb_prio_cfg prio_cfg[QLC_DCB_MAX_PRIO];\n\tenum qlcnic_dcb_prio_type prio_type;\t \n\tu8 link_percent;\t\t\t \n\tu8 bwg_percent;\t\t\t\t \n\tu8 up_tc_map;\n\tu8 pgid;\n};\n\nstruct qlcnic_dcb_app {\n\tbool valid;\n\tenum qlcnic_dcb_selector selector;\n\tu16 protocol;\n\tu8 priority;\n};\n\nstruct qlcnic_dcb_cee {\n\tstruct qlcnic_dcb_tc_cfg tc_cfg[QLC_DCB_MAX_TC];\n\tstruct qlcnic_dcb_pg_cfg pg_cfg[QLC_DCB_MAX_PG];\n\tstruct qlcnic_dcb_app app[QLC_DCB_MAX_APP];\n\tbool tc_param_valid;\n\tbool pfc_mode_enable;\n};\n\nstruct qlcnic_dcb_cfg {\n\t \n\tstruct qlcnic_dcb_cee type[QLC_DCB_NUM_PARAM];\n\tstruct qlcnic_dcb_capability capability;\n\tu32 version;\n};\n\nstatic const struct qlcnic_dcb_ops qlcnic_83xx_dcb_ops = {\n\t.init_dcbnl_ops\t\t= __qlcnic_init_dcbnl_ops,\n\t.free\t\t\t= __qlcnic_dcb_free,\n\t.attach\t\t\t= __qlcnic_dcb_attach,\n\t.query_hw_capability\t= __qlcnic_dcb_query_hw_capability,\n\t.get_info\t\t= __qlcnic_dcb_get_info,\n\n\t.get_hw_capability\t= qlcnic_83xx_dcb_get_hw_capability,\n\t.query_cee_param\t= qlcnic_83xx_dcb_query_cee_param,\n\t.get_cee_cfg\t\t= qlcnic_83xx_dcb_get_cee_cfg,\n\t.aen_handler\t\t= qlcnic_83xx_dcb_aen_handler,\n};\n\nstatic const struct qlcnic_dcb_ops qlcnic_82xx_dcb_ops = {\n\t.init_dcbnl_ops\t\t= __qlcnic_init_dcbnl_ops,\n\t.free\t\t\t= __qlcnic_dcb_free,\n\t.attach\t\t\t= __qlcnic_dcb_attach,\n\t.query_hw_capability\t= __qlcnic_dcb_query_hw_capability,\n\t.get_info\t\t= __qlcnic_dcb_get_info,\n\n\t.get_hw_capability\t= qlcnic_82xx_dcb_get_hw_capability,\n\t.query_cee_param\t= qlcnic_82xx_dcb_query_cee_param,\n\t.get_cee_cfg\t\t= qlcnic_82xx_dcb_get_cee_cfg,\n\t.aen_handler\t\t= qlcnic_82xx_dcb_aen_handler,\n};\n\nstatic u8 qlcnic_dcb_get_num_app(struct qlcnic_adapter *adapter, u32 val)\n{\n\tif (qlcnic_82xx_check(adapter))\n\t\treturn QLC_82XX_DCB_GET_NUMAPP(val);\n\telse\n\t\treturn QLC_83XX_DCB_GET_NUMAPP(val);\n}\n\nstatic inline u8 qlcnic_dcb_pfc_hdr_valid(struct qlcnic_adapter *adapter,\n\t\t\t\t\t  u32 val)\n{\n\tif (qlcnic_82xx_check(adapter))\n\t\treturn QLC_82XX_DCB_PFC_VALID(val);\n\telse\n\t\treturn QLC_83XX_DCB_PFC_VALID(val);\n}\n\nstatic inline u8 qlcnic_dcb_tsa_hdr_valid(struct qlcnic_adapter *adapter,\n\t\t\t\t\t  u32 val)\n{\n\tif (qlcnic_82xx_check(adapter))\n\t\treturn QLC_82XX_DCB_TSA_VALID(val);\n\telse\n\t\treturn QLC_83XX_DCB_TSA_VALID(val);\n}\n\nstatic inline u8 qlcnic_dcb_get_prio_map_app(struct qlcnic_adapter *adapter,\n\t\t\t\t\t     u32 val)\n{\n\tif (qlcnic_82xx_check(adapter))\n\t\treturn QLC_82XX_DCB_GET_PRIOMAP_APP(val);\n\telse\n\t\treturn QLC_83XX_DCB_GET_PRIOMAP_APP(val);\n}\n\nstatic int qlcnic_dcb_prio_count(u8 up_tc_map)\n{\n\tint j;\n\n\tfor (j = 0; j < QLC_DCB_MAX_TC; j++)\n\t\tif (up_tc_map & QLC_DCB_GET_MAP(j))\n\t\t\tbreak;\n\n\treturn j;\n}\n\nstatic inline void __qlcnic_init_dcbnl_ops(struct qlcnic_dcb *dcb)\n{\n\tif (test_bit(QLCNIC_DCB_STATE, &dcb->state))\n\t\tdcb->adapter->netdev->dcbnl_ops = &qlcnic_dcbnl_ops;\n}\n\nstatic void qlcnic_set_dcb_ops(struct qlcnic_adapter *adapter)\n{\n\tif (qlcnic_82xx_check(adapter))\n\t\tadapter->dcb->ops = &qlcnic_82xx_dcb_ops;\n\telse if (qlcnic_83xx_check(adapter))\n\t\tadapter->dcb->ops = &qlcnic_83xx_dcb_ops;\n}\n\nint qlcnic_register_dcb(struct qlcnic_adapter *adapter)\n{\n\tstruct qlcnic_dcb *dcb;\n\n\tif (qlcnic_sriov_vf_check(adapter))\n\t\treturn 0;\n\n\tdcb = kzalloc(sizeof(struct qlcnic_dcb), GFP_ATOMIC);\n\tif (!dcb)\n\t\treturn -ENOMEM;\n\n\tadapter->dcb = dcb;\n\tdcb->adapter = adapter;\n\tqlcnic_set_dcb_ops(adapter);\n\tdcb->state = 0;\n\n\treturn 0;\n}\n\nstatic void __qlcnic_dcb_free(struct qlcnic_dcb *dcb)\n{\n\tstruct qlcnic_adapter *adapter;\n\n\tif (!dcb)\n\t\treturn;\n\n\tadapter = dcb->adapter;\n\n\twhile (test_bit(QLCNIC_DCB_AEN_MODE, &dcb->state))\n\t\tusleep_range(10000, 11000);\n\n\tcancel_delayed_work_sync(&dcb->aen_work);\n\n\tif (dcb->wq) {\n\t\tdestroy_workqueue(dcb->wq);\n\t\tdcb->wq = NULL;\n\t}\n\n\tkfree(dcb->cfg);\n\tdcb->cfg = NULL;\n\tkfree(dcb->param);\n\tdcb->param = NULL;\n\tkfree(dcb);\n\tadapter->dcb = NULL;\n}\n\nstatic void __qlcnic_dcb_get_info(struct qlcnic_dcb *dcb)\n{\n\tqlcnic_dcb_get_hw_capability(dcb);\n\tqlcnic_dcb_get_cee_cfg(dcb);\n}\n\nstatic int __qlcnic_dcb_attach(struct qlcnic_dcb *dcb)\n{\n\tint err = 0;\n\n\tINIT_DELAYED_WORK(&dcb->aen_work, qlcnic_dcb_aen_work);\n\n\tdcb->wq = create_singlethread_workqueue(\"qlcnic-dcb\");\n\tif (!dcb->wq) {\n\t\tdev_err(&dcb->adapter->pdev->dev,\n\t\t\t\"DCB workqueue allocation failed. DCB will be disabled\\n\");\n\t\treturn -1;\n\t}\n\n\tdcb->cfg = kzalloc(sizeof(struct qlcnic_dcb_cfg), GFP_ATOMIC);\n\tif (!dcb->cfg) {\n\t\terr = -ENOMEM;\n\t\tgoto out_free_wq;\n\t}\n\n\tdcb->param = kzalloc(sizeof(struct qlcnic_dcb_mbx_params), GFP_ATOMIC);\n\tif (!dcb->param) {\n\t\terr = -ENOMEM;\n\t\tgoto out_free_cfg;\n\t}\n\n\treturn 0;\nout_free_cfg:\n\tkfree(dcb->cfg);\n\tdcb->cfg = NULL;\n\nout_free_wq:\n\tdestroy_workqueue(dcb->wq);\n\tdcb->wq = NULL;\n\n\treturn err;\n}\n\nstatic int __qlcnic_dcb_query_hw_capability(struct qlcnic_dcb *dcb, char *buf)\n{\n\tstruct qlcnic_adapter *adapter = dcb->adapter;\n\tstruct qlcnic_cmd_args cmd;\n\tu32 mbx_out;\n\tint err;\n\n\terr = qlcnic_alloc_mbx_args(&cmd, adapter, QLCNIC_CMD_DCB_QUERY_CAP);\n\tif (err)\n\t\treturn err;\n\n\terr = qlcnic_issue_cmd(adapter, &cmd);\n\tif (err) {\n\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\"Failed to query DCBX capability, err %d\\n\", err);\n\t} else {\n\t\tmbx_out = cmd.rsp.arg[1];\n\t\tif (buf)\n\t\t\tmemcpy(buf, &mbx_out, sizeof(u32));\n\t}\n\n\tqlcnic_free_mbx_args(&cmd);\n\n\treturn err;\n}\n\nstatic int __qlcnic_dcb_get_capability(struct qlcnic_dcb *dcb, u32 *val)\n{\n\tstruct qlcnic_dcb_capability *cap = &dcb->cfg->capability;\n\tu32 mbx_out;\n\tint err;\n\n\tmemset(cap, 0, sizeof(struct qlcnic_dcb_capability));\n\n\terr = qlcnic_dcb_query_hw_capability(dcb, (char *)val);\n\tif (err)\n\t\treturn err;\n\n\tmbx_out = *val;\n\tif (QLC_DCB_TSA_SUPPORT(mbx_out))\n\t\tcap->tsa_capability = true;\n\n\tif (QLC_DCB_ETS_SUPPORT(mbx_out))\n\t\tcap->ets_capability = true;\n\n\tcap->max_num_tc = QLC_DCB_MAX_NUM_TC(mbx_out);\n\tcap->max_ets_tc = QLC_DCB_MAX_NUM_ETS_TC(mbx_out);\n\tcap->max_pfc_tc = QLC_DCB_MAX_NUM_PFC_TC(mbx_out);\n\n\tif (cap->max_num_tc > QLC_DCB_MAX_TC ||\n\t    cap->max_ets_tc > cap->max_num_tc ||\n\t    cap->max_pfc_tc > cap->max_num_tc) {\n\t\tdev_err(&dcb->adapter->pdev->dev, \"Invalid DCB configuration\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn err;\n}\n\nstatic int qlcnic_82xx_dcb_get_hw_capability(struct qlcnic_dcb *dcb)\n{\n\tstruct qlcnic_dcb_cfg *cfg = dcb->cfg;\n\tstruct qlcnic_dcb_capability *cap;\n\tu32 mbx_out;\n\tint err;\n\n\terr = __qlcnic_dcb_get_capability(dcb, &mbx_out);\n\tif (err)\n\t\treturn err;\n\n\tcap = &cfg->capability;\n\tcap->dcb_capability = DCB_CAP_DCBX_VER_CEE | DCB_CAP_DCBX_LLD_MANAGED;\n\n\tif (cap->dcb_capability && cap->tsa_capability && cap->ets_capability)\n\t\tset_bit(QLCNIC_DCB_STATE, &dcb->state);\n\n\treturn err;\n}\n\nstatic int qlcnic_82xx_dcb_query_cee_param(struct qlcnic_dcb *dcb,\n\t\t\t\t\t   char *buf, u8 type)\n{\n\tu16 size = sizeof(struct qlcnic_82xx_dcb_param_mbx_le);\n\tstruct qlcnic_adapter *adapter = dcb->adapter;\n\tstruct qlcnic_82xx_dcb_param_mbx_le *prsp_le;\n\tstruct device *dev = &adapter->pdev->dev;\n\tdma_addr_t cardrsp_phys_addr;\n\tstruct qlcnic_dcb_param rsp;\n\tstruct qlcnic_cmd_args cmd;\n\tu64 phys_addr;\n\tvoid *addr;\n\tint err, i;\n\n\tswitch (type) {\n\tcase QLC_DCB_LOCAL_PARAM_FWID:\n\tcase QLC_DCB_OPER_PARAM_FWID:\n\tcase QLC_DCB_PEER_PARAM_FWID:\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"Invalid parameter type %d\\n\", type);\n\t\treturn -EINVAL;\n\t}\n\n\taddr = dma_alloc_coherent(dev, size, &cardrsp_phys_addr, GFP_KERNEL);\n\tif (addr == NULL)\n\t\treturn -ENOMEM;\n\n\tprsp_le = addr;\n\n\terr = qlcnic_alloc_mbx_args(&cmd, adapter, QLCNIC_CMD_DCB_QUERY_PARAM);\n\tif (err)\n\t\tgoto out_free_rsp;\n\n\tphys_addr = cardrsp_phys_addr;\n\tcmd.req.arg[1] = size | (type << 16);\n\tcmd.req.arg[2] = MSD(phys_addr);\n\tcmd.req.arg[3] = LSD(phys_addr);\n\n\terr = qlcnic_issue_cmd(adapter, &cmd);\n\tif (err) {\n\t\tdev_err(dev, \"Failed to query DCBX parameter, err %d\\n\", err);\n\t\tgoto out;\n\t}\n\n\tmemset(&rsp, 0, sizeof(struct qlcnic_dcb_param));\n\trsp.hdr_prio_pfc_map[0] = le32_to_cpu(prsp_le->hdr_prio_pfc_map[0]);\n\trsp.hdr_prio_pfc_map[1] = le32_to_cpu(prsp_le->hdr_prio_pfc_map[1]);\n\trsp.prio_pg_map[0] = le32_to_cpu(prsp_le->prio_pg_map[0]);\n\trsp.prio_pg_map[1] = le32_to_cpu(prsp_le->prio_pg_map[1]);\n\trsp.pg_bw_map[0] = le32_to_cpu(prsp_le->pg_bw_map[0]);\n\trsp.pg_bw_map[1] = le32_to_cpu(prsp_le->pg_bw_map[1]);\n\trsp.pg_tsa_map[0] = le32_to_cpu(prsp_le->pg_tsa_map[0]);\n\trsp.pg_tsa_map[1] = le32_to_cpu(prsp_le->pg_tsa_map[1]);\n\n\tfor (i = 0; i < QLC_DCB_MAX_APP; i++)\n\t\trsp.app[i] = le32_to_cpu(prsp_le->app[i]);\n\n\tif (buf)\n\t\tmemcpy(buf, &rsp, size);\nout:\n\tqlcnic_free_mbx_args(&cmd);\n\nout_free_rsp:\n\tdma_free_coherent(dev, size, addr, cardrsp_phys_addr);\n\n\treturn err;\n}\n\nstatic int qlcnic_82xx_dcb_get_cee_cfg(struct qlcnic_dcb *dcb)\n{\n\tstruct qlcnic_dcb_mbx_params *mbx;\n\tint err;\n\n\tmbx = dcb->param;\n\tif (!mbx)\n\t\treturn 0;\n\n\terr = qlcnic_dcb_query_cee_param(dcb, (char *)&mbx->type[0],\n\t\t\t\t\t QLC_DCB_LOCAL_PARAM_FWID);\n\tif (err)\n\t\treturn err;\n\n\terr = qlcnic_dcb_query_cee_param(dcb, (char *)&mbx->type[1],\n\t\t\t\t\t QLC_DCB_OPER_PARAM_FWID);\n\tif (err)\n\t\treturn err;\n\n\terr = qlcnic_dcb_query_cee_param(dcb, (char *)&mbx->type[2],\n\t\t\t\t\t QLC_DCB_PEER_PARAM_FWID);\n\tif (err)\n\t\treturn err;\n\n\tmbx->prio_tc_map = QLC_82XX_DCB_PRIO_TC_MAP;\n\n\tqlcnic_dcb_data_cee_param_map(dcb->adapter);\n\n\treturn err;\n}\n\nstatic void qlcnic_dcb_aen_work(struct work_struct *work)\n{\n\tstruct qlcnic_dcb *dcb;\n\n\tdcb = container_of(work, struct qlcnic_dcb, aen_work.work);\n\n\tqlcnic_dcb_get_cee_cfg(dcb);\n\tclear_bit(QLCNIC_DCB_AEN_MODE, &dcb->state);\n}\n\nstatic void qlcnic_82xx_dcb_aen_handler(struct qlcnic_dcb *dcb, void *data)\n{\n\tif (test_and_set_bit(QLCNIC_DCB_AEN_MODE, &dcb->state))\n\t\treturn;\n\n\tqueue_delayed_work(dcb->wq, &dcb->aen_work, 0);\n}\n\nstatic int qlcnic_83xx_dcb_get_hw_capability(struct qlcnic_dcb *dcb)\n{\n\tstruct qlcnic_dcb_capability *cap = &dcb->cfg->capability;\n\tu32 mbx_out;\n\tint err;\n\n\terr = __qlcnic_dcb_get_capability(dcb, &mbx_out);\n\tif (err)\n\t\treturn err;\n\n\tif (mbx_out & BIT_2)\n\t\tcap->dcb_capability = DCB_CAP_DCBX_VER_CEE;\n\tif (mbx_out & BIT_3)\n\t\tcap->dcb_capability |= DCB_CAP_DCBX_VER_IEEE;\n\tif (cap->dcb_capability)\n\t\tcap->dcb_capability |= DCB_CAP_DCBX_LLD_MANAGED;\n\n\tif (cap->dcb_capability && cap->tsa_capability && cap->ets_capability)\n\t\tset_bit(QLCNIC_DCB_STATE, &dcb->state);\n\n\treturn err;\n}\n\nstatic int qlcnic_83xx_dcb_query_cee_param(struct qlcnic_dcb *dcb,\n\t\t\t\t\t   char *buf, u8 idx)\n{\n\tstruct qlcnic_adapter *adapter = dcb->adapter;\n\tstruct qlcnic_dcb_mbx_params mbx_out;\n\tint err, i, j, k, max_app, size;\n\tstruct qlcnic_dcb_param *each;\n\tstruct qlcnic_cmd_args cmd;\n\tu32 val;\n\tchar *p;\n\n\tsize = 0;\n\tmemset(&mbx_out, 0, sizeof(struct qlcnic_dcb_mbx_params));\n\tmemset(buf, 0, sizeof(struct qlcnic_dcb_mbx_params));\n\n\terr = qlcnic_alloc_mbx_args(&cmd, adapter, QLCNIC_CMD_DCB_QUERY_PARAM);\n\tif (err)\n\t\treturn err;\n\n\tcmd.req.arg[0] |= QLC_DCB_FW_VER << 29;\n\terr = qlcnic_issue_cmd(adapter, &cmd);\n\tif (err) {\n\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\"Failed to query DCBX param, err %d\\n\", err);\n\t\tgoto out;\n\t}\n\n\tmbx_out.prio_tc_map = cmd.rsp.arg[1];\n\tp = memcpy(buf, &mbx_out, sizeof(u32));\n\tk = 2;\n\tp += sizeof(u32);\n\n\tfor (j = 0; j < QLC_DCB_NUM_PARAM; j++) {\n\t\teach = &mbx_out.type[j];\n\n\t\teach->hdr_prio_pfc_map[0] = cmd.rsp.arg[k++];\n\t\teach->hdr_prio_pfc_map[1] = cmd.rsp.arg[k++];\n\t\teach->prio_pg_map[0] = cmd.rsp.arg[k++];\n\t\teach->prio_pg_map[1] = cmd.rsp.arg[k++];\n\t\teach->pg_bw_map[0] = cmd.rsp.arg[k++];\n\t\teach->pg_bw_map[1] = cmd.rsp.arg[k++];\n\t\teach->pg_tsa_map[0] = cmd.rsp.arg[k++];\n\t\teach->pg_tsa_map[1] = cmd.rsp.arg[k++];\n\t\tval = each->hdr_prio_pfc_map[0];\n\n\t\tmax_app = qlcnic_dcb_get_num_app(adapter, val);\n\t\tfor (i = 0; i < max_app; i++)\n\t\t\teach->app[i] = cmd.rsp.arg[i + k];\n\n\t\tsize = 16 * sizeof(u32);\n\t\tmemcpy(p, &each->hdr_prio_pfc_map[0], size);\n\t\tp += size;\n\t\tif (j == 0)\n\t\t\tk = 18;\n\t\telse\n\t\t\tk = 34;\n\t}\nout:\n\tqlcnic_free_mbx_args(&cmd);\n\n\treturn err;\n}\n\nstatic int qlcnic_83xx_dcb_get_cee_cfg(struct qlcnic_dcb *dcb)\n{\n\tint err;\n\n\terr = qlcnic_dcb_query_cee_param(dcb, (char *)dcb->param, 0);\n\tif (err)\n\t\treturn err;\n\n\tqlcnic_dcb_data_cee_param_map(dcb->adapter);\n\n\treturn err;\n}\n\nstatic void qlcnic_83xx_dcb_aen_handler(struct qlcnic_dcb *dcb, void *data)\n{\n\tu32 *val = data;\n\n\tif (test_and_set_bit(QLCNIC_DCB_AEN_MODE, &dcb->state))\n\t\treturn;\n\n\tif (*val & BIT_8)\n\t\tset_bit(QLCNIC_DCB_STATE, &dcb->state);\n\telse\n\t\tclear_bit(QLCNIC_DCB_STATE, &dcb->state);\n\n\tqueue_delayed_work(dcb->wq, &dcb->aen_work, 0);\n}\n\nstatic void qlcnic_dcb_fill_cee_tc_params(struct qlcnic_dcb_mbx_params *mbx,\n\t\t\t\t\t  struct qlcnic_dcb_param *each,\n\t\t\t\t\t  struct qlcnic_dcb_cee *type)\n{\n\tstruct qlcnic_dcb_tc_cfg *tc_cfg;\n\tu8 i, tc, pgid;\n\n\tfor (i = 0; i < QLC_DCB_MAX_PRIO; i++) {\n\t\ttc = QLC_DCB_GET_TC_PRIO(mbx->prio_tc_map, i);\n\t\ttc_cfg = &type->tc_cfg[tc];\n\t\ttc_cfg->valid = true;\n\t\ttc_cfg->up_tc_map |= QLC_DCB_GET_MAP(i);\n\n\t\tif (QLC_DCB_GET_PFC_PRIO(each->hdr_prio_pfc_map[1], i) &&\n\t\t    type->pfc_mode_enable) {\n\t\t\ttc_cfg->prio_cfg[i].valid = true;\n\t\t\ttc_cfg->prio_cfg[i].pfc_type = QLC_PFC_FULL;\n\t\t}\n\n\t\tif (i < 4)\n\t\t\tpgid = QLC_DCB_GET_PGID_PRIO(each->prio_pg_map[0], i);\n\t\telse\n\t\t\tpgid = QLC_DCB_GET_PGID_PRIO(each->prio_pg_map[1], i);\n\n\t\ttc_cfg->pgid = pgid;\n\n\t\ttc_cfg->prio_type = QLC_PRIO_LINK;\n\t\ttype->pg_cfg[tc_cfg->pgid].prio_count++;\n\t}\n}\n\nstatic void qlcnic_dcb_fill_cee_pg_params(struct qlcnic_dcb_param *each,\n\t\t\t\t\t  struct qlcnic_dcb_cee *type)\n{\n\tstruct qlcnic_dcb_pg_cfg *pg_cfg;\n\tu8 i, tsa, bw_per;\n\n\tfor (i = 0; i < QLC_DCB_MAX_PG; i++) {\n\t\tpg_cfg = &type->pg_cfg[i];\n\t\tpg_cfg->valid = true;\n\n\t\tif (i < 4) {\n\t\t\tbw_per = QLC_DCB_GET_BWPER_PG(each->pg_bw_map[0], i);\n\t\t\ttsa = QLC_DCB_GET_TSA_PG(each->pg_tsa_map[0], i);\n\t\t} else {\n\t\t\tbw_per = QLC_DCB_GET_BWPER_PG(each->pg_bw_map[1], i);\n\t\t\ttsa = QLC_DCB_GET_TSA_PG(each->pg_tsa_map[1], i);\n\t\t}\n\n\t\tpg_cfg->total_bw_percent = bw_per;\n\t\tpg_cfg->tsa_type = tsa;\n\t}\n}\n\nstatic void\nqlcnic_dcb_fill_cee_app_params(struct qlcnic_adapter *adapter, u8 idx,\n\t\t\t       struct qlcnic_dcb_param *each,\n\t\t\t       struct qlcnic_dcb_cee *type)\n{\n\tstruct qlcnic_dcb_app *app;\n\tu8 i, num_app, map, cnt;\n\tstruct dcb_app new_app;\n\n\tnum_app = qlcnic_dcb_get_num_app(adapter, each->hdr_prio_pfc_map[0]);\n\tfor (i = 0; i < num_app; i++) {\n\t\tapp = &type->app[i];\n\t\tapp->valid = true;\n\n\t\t \n\t\tapp->selector = QLC_DCB_GET_SELECTOR_APP(each->app[i]) - 1;\n\t\tnew_app.selector = app->selector;\n\t\tapp->protocol = QLC_DCB_GET_PROTO_ID_APP(each->app[i]);\n\t\tnew_app.protocol = app->protocol;\n\t\tmap = qlcnic_dcb_get_prio_map_app(adapter, each->app[i]);\n\t\tcnt = qlcnic_dcb_prio_count(map);\n\n\t\tif (cnt >= QLC_DCB_MAX_TC)\n\t\t\tcnt = 0;\n\n\t\tapp->priority = cnt;\n\t\tnew_app.priority = cnt;\n\n\t\tif (idx == QLC_DCB_OPER_IDX && adapter->netdev->dcbnl_ops)\n\t\t\tdcb_setapp(adapter->netdev, &new_app);\n\t}\n}\n\nstatic void qlcnic_dcb_map_cee_params(struct qlcnic_adapter *adapter, u8 idx)\n{\n\tstruct qlcnic_dcb_mbx_params *mbx = adapter->dcb->param;\n\tstruct qlcnic_dcb_param *each = &mbx->type[idx];\n\tstruct qlcnic_dcb_cfg *cfg = adapter->dcb->cfg;\n\tstruct qlcnic_dcb_cee *type = &cfg->type[idx];\n\n\ttype->tc_param_valid = false;\n\ttype->pfc_mode_enable = false;\n\tmemset(type->tc_cfg, 0,\n\t       sizeof(struct qlcnic_dcb_tc_cfg) * QLC_DCB_MAX_TC);\n\tmemset(type->pg_cfg, 0,\n\t       sizeof(struct qlcnic_dcb_pg_cfg) * QLC_DCB_MAX_TC);\n\n\tif (qlcnic_dcb_pfc_hdr_valid(adapter, each->hdr_prio_pfc_map[0]) &&\n\t    cfg->capability.max_pfc_tc)\n\t\ttype->pfc_mode_enable = true;\n\n\tif (qlcnic_dcb_tsa_hdr_valid(adapter, each->hdr_prio_pfc_map[0]) &&\n\t    cfg->capability.max_ets_tc)\n\t\ttype->tc_param_valid = true;\n\n\tqlcnic_dcb_fill_cee_tc_params(mbx, each, type);\n\tqlcnic_dcb_fill_cee_pg_params(each, type);\n\tqlcnic_dcb_fill_cee_app_params(adapter, idx, each, type);\n}\n\nstatic void qlcnic_dcb_data_cee_param_map(struct qlcnic_adapter *adapter)\n{\n\tint i;\n\n\tfor (i = 0; i < QLC_DCB_NUM_PARAM; i++)\n\t\tqlcnic_dcb_map_cee_params(adapter, i);\n\n\tdcbnl_cee_notify(adapter->netdev, RTM_GETDCB, DCB_CMD_CEE_GET, 0, 0);\n}\n\nstatic u8 qlcnic_dcb_get_state(struct net_device *netdev)\n{\n\tstruct qlcnic_adapter *adapter = netdev_priv(netdev);\n\n\treturn test_bit(QLCNIC_DCB_STATE, &adapter->dcb->state);\n}\n\nstatic void qlcnic_dcb_get_perm_hw_addr(struct net_device *netdev, u8 *addr)\n{\n\tmemcpy(addr, netdev->perm_addr, netdev->addr_len);\n}\n\nstatic void\nqlcnic_dcb_get_pg_tc_cfg_tx(struct net_device *netdev, int tc, u8 *prio,\n\t\t\t    u8 *pgid, u8 *bw_per, u8 *up_tc_map)\n{\n\tstruct qlcnic_adapter *adapter = netdev_priv(netdev);\n\tstruct qlcnic_dcb_tc_cfg *tc_cfg, *temp;\n\tstruct qlcnic_dcb_cee *type;\n\tu8 i, cnt, pg;\n\n\ttype = &adapter->dcb->cfg->type[QLC_DCB_OPER_IDX];\n\t*prio = *pgid = *bw_per = *up_tc_map = 0;\n\n\tif (!test_bit(QLCNIC_DCB_STATE, &adapter->dcb->state) ||\n\t    !type->tc_param_valid)\n\t\treturn;\n\n\tif (tc < 0 || (tc >= QLC_DCB_MAX_TC))\n\t\treturn;\n\n\ttc_cfg = &type->tc_cfg[tc];\n\tif (!tc_cfg->valid)\n\t\treturn;\n\n\t*pgid = tc_cfg->pgid;\n\t*prio = tc_cfg->prio_type;\n\t*up_tc_map = tc_cfg->up_tc_map;\n\tpg = *pgid;\n\n\tfor (i = 0, cnt = 0; i < QLC_DCB_MAX_TC; i++) {\n\t\ttemp = &type->tc_cfg[i];\n\t\tif (temp->valid && (pg == temp->pgid))\n\t\t\tcnt++;\n\t}\n\n\ttc_cfg->bwg_percent = (100 / cnt);\n\t*bw_per = tc_cfg->bwg_percent;\n}\n\nstatic void qlcnic_dcb_get_pg_bwg_cfg_tx(struct net_device *netdev, int pgid,\n\t\t\t\t\t u8 *bw_pct)\n{\n\tstruct qlcnic_adapter *adapter = netdev_priv(netdev);\n\tstruct qlcnic_dcb_pg_cfg *pgcfg;\n\tstruct qlcnic_dcb_cee *type;\n\n\t*bw_pct = 0;\n\ttype = &adapter->dcb->cfg->type[QLC_DCB_OPER_IDX];\n\n\tif (!test_bit(QLCNIC_DCB_STATE, &adapter->dcb->state) ||\n\t    !type->tc_param_valid)\n\t\treturn;\n\n\tif (pgid < 0 || pgid >= QLC_DCB_MAX_PG)\n\t\treturn;\n\n\tpgcfg = &type->pg_cfg[pgid];\n\tif (!pgcfg->valid)\n\t\treturn;\n\n\t*bw_pct = pgcfg->total_bw_percent;\n}\n\nstatic void qlcnic_dcb_get_pfc_cfg(struct net_device *netdev, int prio,\n\t\t\t\t   u8 *setting)\n{\n\tstruct qlcnic_adapter *adapter = netdev_priv(netdev);\n\tstruct qlcnic_dcb_tc_cfg *tc_cfg;\n\tu8 val = QLC_DCB_GET_MAP(prio);\n\tstruct qlcnic_dcb_cee *type;\n\tu8 i;\n\n\t*setting = 0;\n\ttype = &adapter->dcb->cfg->type[QLC_DCB_OPER_IDX];\n\n\tif (!test_bit(QLCNIC_DCB_STATE, &adapter->dcb->state) ||\n\t    !type->pfc_mode_enable)\n\t\treturn;\n\n\tfor (i = 0; i < QLC_DCB_MAX_TC; i++) {\n\t\ttc_cfg = &type->tc_cfg[i];\n\t\tif (!tc_cfg->valid)\n\t\t\tcontinue;\n\n\t\tif ((val & tc_cfg->up_tc_map) && (tc_cfg->prio_cfg[prio].valid))\n\t\t\t*setting = tc_cfg->prio_cfg[prio].pfc_type;\n\t}\n}\n\nstatic u8 qlcnic_dcb_get_capability(struct net_device *netdev, int capid,\n\t\t\t\t    u8 *cap)\n{\n\tstruct qlcnic_adapter *adapter = netdev_priv(netdev);\n\n\tif (!test_bit(QLCNIC_DCB_STATE, &adapter->dcb->state))\n\t\treturn 1;\n\n\tswitch (capid) {\n\tcase DCB_CAP_ATTR_PG:\n\tcase DCB_CAP_ATTR_UP2TC:\n\tcase DCB_CAP_ATTR_PFC:\n\tcase DCB_CAP_ATTR_GSP:\n\t\t*cap = true;\n\t\tbreak;\n\tcase DCB_CAP_ATTR_PG_TCS:\n\tcase DCB_CAP_ATTR_PFC_TCS:\n\t\t*cap = 0x80;\t \n\t\tbreak;\n\tcase DCB_CAP_ATTR_DCBX:\n\t\t*cap = adapter->dcb->cfg->capability.dcb_capability;\n\t\tbreak;\n\tdefault:\n\t\t*cap = false;\n\t}\n\n\treturn 0;\n}\n\nstatic int qlcnic_dcb_get_num_tcs(struct net_device *netdev, int attr, u8 *num)\n{\n\tstruct qlcnic_adapter *adapter = netdev_priv(netdev);\n\tstruct qlcnic_dcb_cfg *cfg = adapter->dcb->cfg;\n\n\tif (!test_bit(QLCNIC_DCB_STATE, &adapter->dcb->state))\n\t\treturn -EINVAL;\n\n\tswitch (attr) {\n\tcase DCB_NUMTCS_ATTR_PG:\n\t\t*num = cfg->capability.max_ets_tc;\n\t\treturn 0;\n\tcase DCB_NUMTCS_ATTR_PFC:\n\t\t*num = cfg->capability.max_pfc_tc;\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int qlcnic_dcb_get_app(struct net_device *netdev, u8 idtype, u16 id)\n{\n\tstruct qlcnic_adapter *adapter = netdev_priv(netdev);\n\tstruct dcb_app app = {\n\t\t\t\t.selector = idtype,\n\t\t\t\t.protocol = id,\n\t\t\t     };\n\n\tif (!test_bit(QLCNIC_DCB_STATE, &adapter->dcb->state))\n\t\treturn -EINVAL;\n\n\treturn dcb_getapp(netdev, &app);\n}\n\nstatic u8 qlcnic_dcb_get_pfc_state(struct net_device *netdev)\n{\n\tstruct qlcnic_adapter *adapter = netdev_priv(netdev);\n\tstruct qlcnic_dcb *dcb = adapter->dcb;\n\n\tif (!test_bit(QLCNIC_DCB_STATE, &dcb->state))\n\t\treturn 0;\n\n\treturn dcb->cfg->type[QLC_DCB_OPER_IDX].pfc_mode_enable;\n}\n\nstatic u8 qlcnic_dcb_get_dcbx(struct net_device *netdev)\n{\n\tstruct qlcnic_adapter *adapter = netdev_priv(netdev);\n\tstruct qlcnic_dcb_cfg *cfg = adapter->dcb->cfg;\n\n\tif (!test_bit(QLCNIC_DCB_STATE, &adapter->dcb->state))\n\t\treturn 0;\n\n\treturn cfg->capability.dcb_capability;\n}\n\nstatic u8 qlcnic_dcb_get_feat_cfg(struct net_device *netdev, int fid, u8 *flag)\n{\n\tstruct qlcnic_adapter *adapter = netdev_priv(netdev);\n\tstruct qlcnic_dcb_cee *type;\n\n\tif (!test_bit(QLCNIC_DCB_STATE, &adapter->dcb->state))\n\t\treturn 1;\n\n\ttype = &adapter->dcb->cfg->type[QLC_DCB_OPER_IDX];\n\t*flag = 0;\n\n\tswitch (fid) {\n\tcase DCB_FEATCFG_ATTR_PG:\n\t\tif (type->tc_param_valid)\n\t\t\t*flag |= DCB_FEATCFG_ENABLE;\n\t\telse\n\t\t\t*flag |= DCB_FEATCFG_ERROR;\n\t\tbreak;\n\tcase DCB_FEATCFG_ATTR_PFC:\n\t\tif (type->pfc_mode_enable) {\n\t\t\tif (type->tc_cfg[0].prio_cfg[0].pfc_type)\n\t\t\t\t*flag |= DCB_FEATCFG_ENABLE;\n\t\t} else {\n\t\t\t*flag |= DCB_FEATCFG_ERROR;\n\t\t}\n\t\tbreak;\n\tcase DCB_FEATCFG_ATTR_APP:\n\t\t*flag |= DCB_FEATCFG_ENABLE;\n\t\tbreak;\n\tdefault:\n\t\tnetdev_err(netdev, \"Invalid Feature ID %d\\n\", fid);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic inline void\nqlcnic_dcb_get_pg_tc_cfg_rx(struct net_device *netdev, int prio, u8 *prio_type,\n\t\t\t    u8 *pgid, u8 *bw_pct, u8 *up_map)\n{\n\t*prio_type = *pgid = *bw_pct = *up_map = 0;\n}\n\nstatic inline void\nqlcnic_dcb_get_pg_bwg_cfg_rx(struct net_device *netdev, int pgid, u8 *bw_pct)\n{\n\t*bw_pct = 0;\n}\n\nstatic int qlcnic_dcb_peer_app_info(struct net_device *netdev,\n\t\t\t\t    struct dcb_peer_app_info *info,\n\t\t\t\t    u16 *app_count)\n{\n\tstruct qlcnic_adapter *adapter = netdev_priv(netdev);\n\tstruct qlcnic_dcb_cee *peer;\n\tint i;\n\n\tmemset(info, 0, sizeof(*info));\n\t*app_count = 0;\n\n\tif (!test_bit(QLCNIC_DCB_STATE, &adapter->dcb->state))\n\t\treturn 0;\n\n\tpeer = &adapter->dcb->cfg->type[QLC_DCB_PEER_IDX];\n\n\tfor (i = 0; i < QLC_DCB_MAX_APP; i++) {\n\t\tif (peer->app[i].valid)\n\t\t\t(*app_count)++;\n\t}\n\n\treturn 0;\n}\n\nstatic int qlcnic_dcb_peer_app_table(struct net_device *netdev,\n\t\t\t\t     struct dcb_app *table)\n{\n\tstruct qlcnic_adapter *adapter = netdev_priv(netdev);\n\tstruct qlcnic_dcb_cee *peer;\n\tstruct qlcnic_dcb_app *app;\n\tint i, j;\n\n\tif (!test_bit(QLCNIC_DCB_STATE, &adapter->dcb->state))\n\t\treturn 0;\n\n\tpeer = &adapter->dcb->cfg->type[QLC_DCB_PEER_IDX];\n\n\tfor (i = 0, j = 0; i < QLC_DCB_MAX_APP; i++) {\n\t\tapp = &peer->app[i];\n\t\tif (!app->valid)\n\t\t\tcontinue;\n\n\t\ttable[j].selector = app->selector;\n\t\ttable[j].priority = app->priority;\n\t\ttable[j++].protocol = app->protocol;\n\t}\n\n\treturn 0;\n}\n\nstatic int qlcnic_dcb_cee_peer_get_pg(struct net_device *netdev,\n\t\t\t\t      struct cee_pg *pg)\n{\n\tstruct qlcnic_adapter *adapter = netdev_priv(netdev);\n\tstruct qlcnic_dcb_cee *peer;\n\tu8 i, j, k, map;\n\n\tif (!test_bit(QLCNIC_DCB_STATE, &adapter->dcb->state))\n\t\treturn 0;\n\n\tpeer = &adapter->dcb->cfg->type[QLC_DCB_PEER_IDX];\n\n\tfor (i = 0, j = 0; i < QLC_DCB_MAX_PG; i++) {\n\t\tif (!peer->pg_cfg[i].valid)\n\t\t\tcontinue;\n\n\t\tpg->pg_bw[j] = peer->pg_cfg[i].total_bw_percent;\n\n\t\tfor (k = 0; k < QLC_DCB_MAX_TC; k++) {\n\t\t\tif (peer->tc_cfg[i].valid &&\n\t\t\t    (peer->tc_cfg[i].pgid == i)) {\n\t\t\t\tmap = peer->tc_cfg[i].up_tc_map;\n\t\t\t\tpg->prio_pg[j++] = map;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int qlcnic_dcb_cee_peer_get_pfc(struct net_device *netdev,\n\t\t\t\t       struct cee_pfc *pfc)\n{\n\tstruct qlcnic_adapter *adapter = netdev_priv(netdev);\n\tstruct qlcnic_dcb_cfg *cfg = adapter->dcb->cfg;\n\tstruct qlcnic_dcb_tc_cfg *tc;\n\tstruct qlcnic_dcb_cee *peer;\n\tu8 i, setting, prio;\n\n\tpfc->pfc_en = 0;\n\n\tif (!test_bit(QLCNIC_DCB_STATE, &adapter->dcb->state))\n\t\treturn 0;\n\n\tpeer = &cfg->type[QLC_DCB_PEER_IDX];\n\n\tfor (i = 0; i < QLC_DCB_MAX_TC; i++) {\n\t\ttc = &peer->tc_cfg[i];\n\t\tprio = qlcnic_dcb_prio_count(tc->up_tc_map);\n\n\t\tsetting = 0;\n\t\tqlcnic_dcb_get_pfc_cfg(netdev, prio, &setting);\n\t\tif (setting)\n\t\t\tpfc->pfc_en |= QLC_DCB_GET_MAP(i);\n\t}\n\n\tpfc->tcs_supported = cfg->capability.max_pfc_tc;\n\n\treturn 0;\n}\n\nstatic const struct dcbnl_rtnl_ops qlcnic_dcbnl_ops = {\n\t.getstate\t\t= qlcnic_dcb_get_state,\n\t.getpermhwaddr\t\t= qlcnic_dcb_get_perm_hw_addr,\n\t.getpgtccfgtx\t\t= qlcnic_dcb_get_pg_tc_cfg_tx,\n\t.getpgbwgcfgtx\t\t= qlcnic_dcb_get_pg_bwg_cfg_tx,\n\t.getpfccfg\t\t= qlcnic_dcb_get_pfc_cfg,\n\t.getcap\t\t\t= qlcnic_dcb_get_capability,\n\t.getnumtcs\t\t= qlcnic_dcb_get_num_tcs,\n\t.getapp\t\t\t= qlcnic_dcb_get_app,\n\t.getpfcstate\t\t= qlcnic_dcb_get_pfc_state,\n\t.getdcbx\t\t= qlcnic_dcb_get_dcbx,\n\t.getfeatcfg\t\t= qlcnic_dcb_get_feat_cfg,\n\n\t.getpgtccfgrx\t\t= qlcnic_dcb_get_pg_tc_cfg_rx,\n\t.getpgbwgcfgrx\t\t= qlcnic_dcb_get_pg_bwg_cfg_rx,\n\n\t.peer_getappinfo\t= qlcnic_dcb_peer_app_info,\n\t.peer_getapptable\t= qlcnic_dcb_peer_app_table,\n\t.cee_peer_getpg\t\t= qlcnic_dcb_cee_peer_get_pg,\n\t.cee_peer_getpfc\t= qlcnic_dcb_cee_peer_get_pfc,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}