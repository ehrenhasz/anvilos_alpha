{
  "module_name": "qed_iscsi.c",
  "hash_id": "83a498b5ae34bf60cf470f5794bf5c38321e6f3411619f0a0d1dd51db6631708",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/qlogic/qed/qed_iscsi.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <asm/byteorder.h>\n#include <asm/param.h>\n#include <linux/delay.h>\n#include <linux/dma-mapping.h>\n#include <linux/etherdevice.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/log2.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/string.h>\n#include <linux/workqueue.h>\n#include <linux/errno.h>\n#include <linux/list.h>\n#include <linux/spinlock.h>\n#include <linux/qed/qed_iscsi_if.h>\n#include \"qed.h\"\n#include \"qed_cxt.h\"\n#include \"qed_dev_api.h\"\n#include \"qed_hsi.h\"\n#include \"qed_hw.h\"\n#include \"qed_int.h\"\n#include \"qed_iro_hsi.h\"\n#include \"qed_iscsi.h\"\n#include \"qed_ll2.h\"\n#include \"qed_mcp.h\"\n#include \"qed_sp.h\"\n#include \"qed_sriov.h\"\n#include \"qed_reg_addr.h\"\n\nstruct qed_iscsi_conn {\n\tstruct list_head list_entry;\n\tbool free_on_delete;\n\n\tu16 conn_id;\n\tu32 icid;\n\tu32 fw_cid;\n\n\tu8 layer_code;\n\tu8 offl_flags;\n\tu8 connect_mode;\n\tu32 initial_ack;\n\tdma_addr_t sq_pbl_addr;\n\tstruct qed_chain r2tq;\n\tstruct qed_chain xhq;\n\tstruct qed_chain uhq;\n\n\tstruct tcp_upload_params *tcp_upload_params_virt_addr;\n\tdma_addr_t tcp_upload_params_phys_addr;\n\tstruct scsi_terminate_extra_params *queue_cnts_virt_addr;\n\tdma_addr_t queue_cnts_phys_addr;\n\tdma_addr_t syn_phy_addr;\n\n\tu16 syn_ip_payload_length;\n\tu8 local_mac[6];\n\tu8 remote_mac[6];\n\tu16 vlan_id;\n\tu16 tcp_flags;\n\tu8 ip_version;\n\tu32 remote_ip[4];\n\tu32 local_ip[4];\n\tu8 ka_max_probe_cnt;\n\tu8 dup_ack_theshold;\n\tu32 rcv_next;\n\tu32 snd_una;\n\tu32 snd_next;\n\tu32 snd_max;\n\tu32 snd_wnd;\n\tu32 rcv_wnd;\n\tu32 snd_wl1;\n\tu32 cwnd;\n\tu32 ss_thresh;\n\tu16 srtt;\n\tu16 rtt_var;\n\tu32 ts_recent;\n\tu32 ts_recent_age;\n\tu32 total_rt;\n\tu32 ka_timeout_delta;\n\tu32 rt_timeout_delta;\n\tu8 dup_ack_cnt;\n\tu8 snd_wnd_probe_cnt;\n\tu8 ka_probe_cnt;\n\tu8 rt_cnt;\n\tu32 flow_label;\n\tu32 ka_timeout;\n\tu32 ka_interval;\n\tu32 max_rt_time;\n\tu32 initial_rcv_wnd;\n\tu8 ttl;\n\tu8 tos_or_tc;\n\tu16 remote_port;\n\tu16 local_port;\n\tu16 mss;\n\tu8 snd_wnd_scale;\n\tu8 rcv_wnd_scale;\n\tu16 da_timeout_value;\n\tu8 ack_frequency;\n\n\tu8 update_flag;\n\tu8 default_cq;\n\tu32 max_seq_size;\n\tu32 max_recv_pdu_length;\n\tu32 max_send_pdu_length;\n\tu32 first_seq_length;\n\tu32 exp_stat_sn;\n\tu32 stat_sn;\n\tu16 physical_q0;\n\tu16 physical_q1;\n\tu8 abortive_dsconnect;\n};\n\nstatic int qed_iscsi_async_event(struct qed_hwfn *p_hwfn, u8 fw_event_code,\n\t\t\t\t __le16 echo, union event_ring_data *data,\n\t\t\t\t u8 fw_return_code)\n{\n\tif (p_hwfn->p_iscsi_info->event_cb) {\n\t\tstruct qed_iscsi_info *p_iscsi = p_hwfn->p_iscsi_info;\n\n\t\treturn p_iscsi->event_cb(p_iscsi->event_context,\n\t\t\t\t\t fw_event_code, data);\n\t} else {\n\t\tDP_NOTICE(p_hwfn, \"iSCSI async completion is not set\\n\");\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int\nqed_sp_iscsi_func_start(struct qed_hwfn *p_hwfn,\n\t\t\tenum spq_mode comp_mode,\n\t\t\tstruct qed_spq_comp_cb *p_comp_addr,\n\t\t\tvoid *event_context, iscsi_event_cb_t async_event_cb)\n{\n\tstruct iscsi_init_ramrod_params *p_ramrod = NULL;\n\tstruct scsi_init_func_queues *p_queue = NULL;\n\tstruct qed_iscsi_pf_params *p_params = NULL;\n\tstruct iscsi_spe_func_init *p_init = NULL;\n\tstruct qed_spq_entry *p_ent = NULL;\n\tstruct qed_sp_init_data init_data;\n\tint rc = 0;\n\tu32 dval;\n\tu16 val;\n\tu8 i;\n\n\t \n\tmemset(&init_data, 0, sizeof(init_data));\n\tinit_data.cid = qed_spq_get_cid(p_hwfn);\n\tinit_data.opaque_fid = p_hwfn->hw_info.opaque_fid;\n\tinit_data.comp_mode = comp_mode;\n\tinit_data.p_comp_data = p_comp_addr;\n\n\trc = qed_sp_init_request(p_hwfn, &p_ent,\n\t\t\t\t ISCSI_RAMROD_CMD_ID_INIT_FUNC,\n\t\t\t\t PROTOCOLID_TCP_ULP, &init_data);\n\tif (rc)\n\t\treturn rc;\n\n\tp_ramrod = &p_ent->ramrod.iscsi_init;\n\tp_init = &p_ramrod->iscsi_init_spe;\n\tp_params = &p_hwfn->pf_params.iscsi_pf_params;\n\tp_queue = &p_init->q_params;\n\n\t \n\tif (p_params->num_queues > p_hwfn->hw_info.feat_num[QED_ISCSI_CQ]) {\n\t\tDP_ERR(p_hwfn,\n\t\t       \"Cannot satisfy CQ amount. Queues requested %d, CQs available %d. Aborting function start\\n\",\n\t\t       p_params->num_queues,\n\t\t       p_hwfn->hw_info.feat_num[QED_ISCSI_CQ]);\n\t\tqed_sp_destroy_request(p_hwfn, p_ent);\n\t\treturn -EINVAL;\n\t}\n\n\tval = p_params->half_way_close_timeout;\n\tp_init->half_way_close_timeout = cpu_to_le16(val);\n\tp_init->num_sq_pages_in_ring = p_params->num_sq_pages_in_ring;\n\tp_init->num_r2tq_pages_in_ring = p_params->num_r2tq_pages_in_ring;\n\tp_init->num_uhq_pages_in_ring = p_params->num_uhq_pages_in_ring;\n\tp_init->ll2_rx_queue_id =\n\t    p_hwfn->hw_info.resc_start[QED_LL2_RAM_QUEUE] +\n\t    p_params->ll2_ooo_queue_id;\n\n\tp_init->func_params.log_page_size = p_params->log_page_size;\n\tval = p_params->num_tasks;\n\tp_init->func_params.num_tasks = cpu_to_le16(val);\n\tp_init->debug_mode.flags = p_params->debug_mode;\n\n\tDMA_REGPAIR_LE(p_queue->glbl_q_params_addr,\n\t\t       p_params->glbl_q_params_addr);\n\n\tval = p_params->cq_num_entries;\n\tp_queue->cq_num_entries = cpu_to_le16(val);\n\tval = p_params->cmdq_num_entries;\n\tp_queue->cmdq_num_entries = cpu_to_le16(val);\n\tp_queue->num_queues = p_params->num_queues;\n\tdval = (u8)p_hwfn->hw_info.resc_start[QED_CMDQS_CQS];\n\tp_queue->queue_relative_offset = (u8)dval;\n\tp_queue->cq_sb_pi = p_params->gl_rq_pi;\n\tp_queue->cmdq_sb_pi = p_params->gl_cmd_pi;\n\n\tfor (i = 0; i < p_params->num_queues; i++) {\n\t\tval = qed_get_igu_sb_id(p_hwfn, i);\n\t\tp_queue->cq_cmdq_sb_num_arr[i] = cpu_to_le16(val);\n\t}\n\n\tp_queue->bdq_resource_id = (u8)RESC_START(p_hwfn, QED_BDQ);\n\n\tDMA_REGPAIR_LE(p_queue->bdq_pbl_base_address[BDQ_ID_RQ],\n\t\t       p_params->bdq_pbl_base_addr[BDQ_ID_RQ]);\n\tp_queue->bdq_pbl_num_entries[BDQ_ID_RQ] =\n\t    p_params->bdq_pbl_num_entries[BDQ_ID_RQ];\n\tval = p_params->bdq_xoff_threshold[BDQ_ID_RQ];\n\tp_queue->bdq_xoff_threshold[BDQ_ID_RQ] = cpu_to_le16(val);\n\tval = p_params->bdq_xon_threshold[BDQ_ID_RQ];\n\tp_queue->bdq_xon_threshold[BDQ_ID_RQ] = cpu_to_le16(val);\n\n\tDMA_REGPAIR_LE(p_queue->bdq_pbl_base_address[BDQ_ID_IMM_DATA],\n\t\t       p_params->bdq_pbl_base_addr[BDQ_ID_IMM_DATA]);\n\tp_queue->bdq_pbl_num_entries[BDQ_ID_IMM_DATA] =\n\t    p_params->bdq_pbl_num_entries[BDQ_ID_IMM_DATA];\n\tval = p_params->bdq_xoff_threshold[BDQ_ID_IMM_DATA];\n\tp_queue->bdq_xoff_threshold[BDQ_ID_IMM_DATA] = cpu_to_le16(val);\n\tval = p_params->bdq_xon_threshold[BDQ_ID_IMM_DATA];\n\tp_queue->bdq_xon_threshold[BDQ_ID_IMM_DATA] = cpu_to_le16(val);\n\tval = p_params->rq_buffer_size;\n\tp_queue->rq_buffer_size = cpu_to_le16(val);\n\tif (p_params->is_target) {\n\t\tSET_FIELD(p_queue->q_validity,\n\t\t\t  SCSI_INIT_FUNC_QUEUES_RQ_VALID, 1);\n\t\tif (p_queue->bdq_pbl_num_entries[BDQ_ID_IMM_DATA])\n\t\t\tSET_FIELD(p_queue->q_validity,\n\t\t\t\t  SCSI_INIT_FUNC_QUEUES_IMM_DATA_VALID, 1);\n\t\tSET_FIELD(p_queue->q_validity,\n\t\t\t  SCSI_INIT_FUNC_QUEUES_CMD_VALID, 1);\n\t} else {\n\t\tSET_FIELD(p_queue->q_validity,\n\t\t\t  SCSI_INIT_FUNC_QUEUES_RQ_VALID, 1);\n\t}\n\tp_ramrod->tcp_init.two_msl_timer = cpu_to_le32(p_params->two_msl_timer);\n\tval = p_params->tx_sws_timer;\n\tp_ramrod->tcp_init.tx_sws_timer = cpu_to_le16(val);\n\tp_ramrod->tcp_init.max_fin_rt = p_params->max_fin_rt;\n\n\tp_hwfn->p_iscsi_info->event_context = event_context;\n\tp_hwfn->p_iscsi_info->event_cb = async_event_cb;\n\n\tqed_spq_register_async_cb(p_hwfn, PROTOCOLID_TCP_ULP,\n\t\t\t\t  qed_iscsi_async_event);\n\n\treturn qed_spq_post(p_hwfn, p_ent, NULL);\n}\n\nstatic int qed_sp_iscsi_conn_offload(struct qed_hwfn *p_hwfn,\n\t\t\t\t     struct qed_iscsi_conn *p_conn,\n\t\t\t\t     enum spq_mode comp_mode,\n\t\t\t\t     struct qed_spq_comp_cb *p_comp_addr)\n{\n\tstruct iscsi_spe_conn_offload *p_ramrod = NULL;\n\tstruct tcp_offload_params_opt2 *p_tcp2 = NULL;\n\tstruct tcp_offload_params *p_tcp = NULL;\n\tstruct qed_spq_entry *p_ent = NULL;\n\tstruct qed_sp_init_data init_data;\n\tdma_addr_t r2tq_pbl_addr;\n\tdma_addr_t xhq_pbl_addr;\n\tdma_addr_t uhq_pbl_addr;\n\tu16 physical_q;\n\t__le16 tmp;\n\tint rc = 0;\n\tu32 dval;\n\tu16 wval;\n\tu16 *p;\n\tu8 i;\n\n\t \n\tmemset(&init_data, 0, sizeof(init_data));\n\tinit_data.cid = p_conn->icid;\n\tinit_data.opaque_fid = p_hwfn->hw_info.opaque_fid;\n\tinit_data.comp_mode = comp_mode;\n\tinit_data.p_comp_data = p_comp_addr;\n\n\trc = qed_sp_init_request(p_hwfn, &p_ent,\n\t\t\t\t ISCSI_RAMROD_CMD_ID_OFFLOAD_CONN,\n\t\t\t\t PROTOCOLID_TCP_ULP, &init_data);\n\tif (rc)\n\t\treturn rc;\n\n\tp_ramrod = &p_ent->ramrod.iscsi_conn_offload;\n\n\t \n\tphysical_q = qed_get_cm_pq_idx(p_hwfn, PQ_FLAGS_OFLD);\n\tp_conn->physical_q0 = physical_q;\n\tp_ramrod->iscsi.physical_q0 = cpu_to_le16(physical_q);\n\n\t \n\tphysical_q = qed_get_cm_pq_idx(p_hwfn, PQ_FLAGS_ACK);\n\tp_conn->physical_q1 = physical_q;\n\tp_ramrod->iscsi.physical_q1 = cpu_to_le16(physical_q);\n\n\tp_ramrod->conn_id = cpu_to_le16(p_conn->conn_id);\n\n\tDMA_REGPAIR_LE(p_ramrod->iscsi.sq_pbl_addr, p_conn->sq_pbl_addr);\n\n\tr2tq_pbl_addr = qed_chain_get_pbl_phys(&p_conn->r2tq);\n\tDMA_REGPAIR_LE(p_ramrod->iscsi.r2tq_pbl_addr, r2tq_pbl_addr);\n\n\txhq_pbl_addr = qed_chain_get_pbl_phys(&p_conn->xhq);\n\tDMA_REGPAIR_LE(p_ramrod->iscsi.xhq_pbl_addr, xhq_pbl_addr);\n\n\tuhq_pbl_addr = qed_chain_get_pbl_phys(&p_conn->uhq);\n\tDMA_REGPAIR_LE(p_ramrod->iscsi.uhq_pbl_addr, uhq_pbl_addr);\n\n\tp_ramrod->iscsi.initial_ack = cpu_to_le32(p_conn->initial_ack);\n\tp_ramrod->iscsi.flags = p_conn->offl_flags;\n\tp_ramrod->iscsi.default_cq = p_conn->default_cq;\n\tp_ramrod->iscsi.stat_sn = cpu_to_le32(p_conn->stat_sn);\n\n\tif (!GET_FIELD(p_ramrod->iscsi.flags,\n\t\t       ISCSI_CONN_OFFLOAD_PARAMS_TCP_ON_CHIP_1B)) {\n\t\tp_tcp = &p_ramrod->tcp;\n\n\t\tp = (u16 *)p_conn->local_mac;\n\t\ttmp = cpu_to_le16(get_unaligned_be16(p));\n\t\tp_tcp->local_mac_addr_hi = tmp;\n\t\ttmp = cpu_to_le16(get_unaligned_be16(p + 1));\n\t\tp_tcp->local_mac_addr_mid = tmp;\n\t\ttmp = cpu_to_le16(get_unaligned_be16(p + 2));\n\t\tp_tcp->local_mac_addr_lo = tmp;\n\n\t\tp = (u16 *)p_conn->remote_mac;\n\t\ttmp = cpu_to_le16(get_unaligned_be16(p));\n\t\tp_tcp->remote_mac_addr_hi = tmp;\n\t\ttmp = cpu_to_le16(get_unaligned_be16(p + 1));\n\t\tp_tcp->remote_mac_addr_mid = tmp;\n\t\ttmp = cpu_to_le16(get_unaligned_be16(p + 2));\n\t\tp_tcp->remote_mac_addr_lo = tmp;\n\n\t\tp_tcp->vlan_id = cpu_to_le16(p_conn->vlan_id);\n\n\t\tp_tcp->flags = cpu_to_le16(p_conn->tcp_flags);\n\t\tp_tcp->ip_version = p_conn->ip_version;\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tdval = p_conn->remote_ip[i];\n\t\t\tp_tcp->remote_ip[i] = cpu_to_le32(dval);\n\t\t\tdval = p_conn->local_ip[i];\n\t\t\tp_tcp->local_ip[i] = cpu_to_le32(dval);\n\t\t}\n\t\tp_tcp->ka_max_probe_cnt = p_conn->ka_max_probe_cnt;\n\t\tp_tcp->dup_ack_theshold = p_conn->dup_ack_theshold;\n\n\t\tp_tcp->rcv_next = cpu_to_le32(p_conn->rcv_next);\n\t\tp_tcp->snd_una = cpu_to_le32(p_conn->snd_una);\n\t\tp_tcp->snd_next = cpu_to_le32(p_conn->snd_next);\n\t\tp_tcp->snd_max = cpu_to_le32(p_conn->snd_max);\n\t\tp_tcp->snd_wnd = cpu_to_le32(p_conn->snd_wnd);\n\t\tp_tcp->rcv_wnd = cpu_to_le32(p_conn->rcv_wnd);\n\t\tp_tcp->snd_wl1 = cpu_to_le32(p_conn->snd_wl1);\n\t\tp_tcp->cwnd = cpu_to_le32(p_conn->cwnd);\n\t\tp_tcp->ss_thresh = cpu_to_le32(p_conn->ss_thresh);\n\t\tp_tcp->srtt = cpu_to_le16(p_conn->srtt);\n\t\tp_tcp->rtt_var = cpu_to_le16(p_conn->rtt_var);\n\t\tp_tcp->ts_recent = cpu_to_le32(p_conn->ts_recent);\n\t\tp_tcp->ts_recent_age = cpu_to_le32(p_conn->ts_recent_age);\n\t\tp_tcp->total_rt = cpu_to_le32(p_conn->total_rt);\n\t\tdval = p_conn->ka_timeout_delta;\n\t\tp_tcp->ka_timeout_delta = cpu_to_le32(dval);\n\t\tdval = p_conn->rt_timeout_delta;\n\t\tp_tcp->rt_timeout_delta = cpu_to_le32(dval);\n\t\tp_tcp->dup_ack_cnt = p_conn->dup_ack_cnt;\n\t\tp_tcp->snd_wnd_probe_cnt = p_conn->snd_wnd_probe_cnt;\n\t\tp_tcp->ka_probe_cnt = p_conn->ka_probe_cnt;\n\t\tp_tcp->rt_cnt = p_conn->rt_cnt;\n\t\tp_tcp->flow_label = cpu_to_le32(p_conn->flow_label);\n\t\tp_tcp->ka_timeout = cpu_to_le32(p_conn->ka_timeout);\n\t\tp_tcp->ka_interval = cpu_to_le32(p_conn->ka_interval);\n\t\tp_tcp->max_rt_time = cpu_to_le32(p_conn->max_rt_time);\n\t\tdval = p_conn->initial_rcv_wnd;\n\t\tp_tcp->initial_rcv_wnd = cpu_to_le32(dval);\n\t\tp_tcp->ttl = p_conn->ttl;\n\t\tp_tcp->tos_or_tc = p_conn->tos_or_tc;\n\t\tp_tcp->remote_port = cpu_to_le16(p_conn->remote_port);\n\t\tp_tcp->local_port = cpu_to_le16(p_conn->local_port);\n\t\tp_tcp->mss = cpu_to_le16(p_conn->mss);\n\t\tp_tcp->snd_wnd_scale = p_conn->snd_wnd_scale;\n\t\tp_tcp->rcv_wnd_scale = p_conn->rcv_wnd_scale;\n\t\twval = p_conn->da_timeout_value;\n\t\tp_tcp->da_timeout_value = cpu_to_le16(wval);\n\t\tp_tcp->ack_frequency = p_conn->ack_frequency;\n\t\tp_tcp->connect_mode = p_conn->connect_mode;\n\t} else {\n\t\tp_tcp2 =\n\t\t    &((struct iscsi_spe_conn_offload_option2 *)p_ramrod)->tcp;\n\n\t\tp = (u16 *)p_conn->local_mac;\n\t\ttmp = cpu_to_le16(get_unaligned_be16(p));\n\t\tp_tcp2->local_mac_addr_hi = tmp;\n\t\ttmp = cpu_to_le16(get_unaligned_be16(p + 1));\n\t\tp_tcp2->local_mac_addr_mid = tmp;\n\t\ttmp = cpu_to_le16(get_unaligned_be16(p + 2));\n\t\tp_tcp2->local_mac_addr_lo = tmp;\n\n\t\tp = (u16 *)p_conn->remote_mac;\n\t\ttmp = cpu_to_le16(get_unaligned_be16(p));\n\t\tp_tcp2->remote_mac_addr_hi = tmp;\n\t\ttmp = cpu_to_le16(get_unaligned_be16(p + 1));\n\t\tp_tcp2->remote_mac_addr_mid = tmp;\n\t\ttmp = cpu_to_le16(get_unaligned_be16(p + 2));\n\t\tp_tcp2->remote_mac_addr_lo = tmp;\n\n\t\tp_tcp2->vlan_id = cpu_to_le16(p_conn->vlan_id);\n\t\tp_tcp2->flags = cpu_to_le16(p_conn->tcp_flags);\n\n\t\tp_tcp2->ip_version = p_conn->ip_version;\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tdval = p_conn->remote_ip[i];\n\t\t\tp_tcp2->remote_ip[i] = cpu_to_le32(dval);\n\t\t\tdval = p_conn->local_ip[i];\n\t\t\tp_tcp2->local_ip[i] = cpu_to_le32(dval);\n\t\t}\n\n\t\tp_tcp2->flow_label = cpu_to_le32(p_conn->flow_label);\n\t\tp_tcp2->ttl = p_conn->ttl;\n\t\tp_tcp2->tos_or_tc = p_conn->tos_or_tc;\n\t\tp_tcp2->remote_port = cpu_to_le16(p_conn->remote_port);\n\t\tp_tcp2->local_port = cpu_to_le16(p_conn->local_port);\n\t\tp_tcp2->mss = cpu_to_le16(p_conn->mss);\n\t\tp_tcp2->rcv_wnd_scale = p_conn->rcv_wnd_scale;\n\t\tp_tcp2->connect_mode = p_conn->connect_mode;\n\t\twval = p_conn->syn_ip_payload_length;\n\t\tp_tcp2->syn_ip_payload_length = cpu_to_le16(wval);\n\t\tp_tcp2->syn_phy_addr_lo = DMA_LO_LE(p_conn->syn_phy_addr);\n\t\tp_tcp2->syn_phy_addr_hi = DMA_HI_LE(p_conn->syn_phy_addr);\n\t\tp_tcp2->cwnd = cpu_to_le32(p_conn->cwnd);\n\t\tp_tcp2->ka_max_probe_cnt = p_conn->ka_probe_cnt;\n\t\tp_tcp2->ka_timeout = cpu_to_le32(p_conn->ka_timeout);\n\t\tp_tcp2->max_rt_time = cpu_to_le32(p_conn->max_rt_time);\n\t\tp_tcp2->ka_interval = cpu_to_le32(p_conn->ka_interval);\n\t}\n\n\treturn qed_spq_post(p_hwfn, p_ent, NULL);\n}\n\nstatic int qed_sp_iscsi_conn_update(struct qed_hwfn *p_hwfn,\n\t\t\t\t    struct qed_iscsi_conn *p_conn,\n\t\t\t\t    enum spq_mode comp_mode,\n\t\t\t\t    struct qed_spq_comp_cb *p_comp_addr)\n{\n\tstruct iscsi_conn_update_ramrod_params *p_ramrod = NULL;\n\tstruct qed_spq_entry *p_ent = NULL;\n\tstruct qed_sp_init_data init_data;\n\tint rc;\n\tu32 dval;\n\n\t \n\tmemset(&init_data, 0, sizeof(init_data));\n\tinit_data.cid = p_conn->icid;\n\tinit_data.opaque_fid = p_hwfn->hw_info.opaque_fid;\n\tinit_data.comp_mode = comp_mode;\n\tinit_data.p_comp_data = p_comp_addr;\n\n\trc = qed_sp_init_request(p_hwfn, &p_ent,\n\t\t\t\t ISCSI_RAMROD_CMD_ID_UPDATE_CONN,\n\t\t\t\t PROTOCOLID_TCP_ULP, &init_data);\n\tif (rc)\n\t\treturn rc;\n\n\tp_ramrod = &p_ent->ramrod.iscsi_conn_update;\n\n\tp_ramrod->conn_id = cpu_to_le16(p_conn->conn_id);\n\tp_ramrod->flags = p_conn->update_flag;\n\tp_ramrod->max_seq_size = cpu_to_le32(p_conn->max_seq_size);\n\tdval = p_conn->max_recv_pdu_length;\n\tp_ramrod->max_recv_pdu_length = cpu_to_le32(dval);\n\tdval = p_conn->max_send_pdu_length;\n\tp_ramrod->max_send_pdu_length = cpu_to_le32(dval);\n\tdval = p_conn->first_seq_length;\n\tp_ramrod->first_seq_length = cpu_to_le32(dval);\n\tp_ramrod->exp_stat_sn = cpu_to_le32(p_conn->exp_stat_sn);\n\n\treturn qed_spq_post(p_hwfn, p_ent, NULL);\n}\n\nstatic int\nqed_sp_iscsi_mac_update(struct qed_hwfn *p_hwfn,\n\t\t\tstruct qed_iscsi_conn *p_conn,\n\t\t\tenum spq_mode comp_mode,\n\t\t\tstruct qed_spq_comp_cb *p_comp_addr)\n{\n\tstruct iscsi_spe_conn_mac_update *p_ramrod = NULL;\n\tstruct qed_spq_entry *p_ent = NULL;\n\tstruct qed_sp_init_data init_data;\n\tint rc = -EINVAL;\n\tu8 ucval;\n\n\t \n\tmemset(&init_data, 0, sizeof(init_data));\n\tinit_data.cid = p_conn->icid;\n\tinit_data.opaque_fid = p_hwfn->hw_info.opaque_fid;\n\tinit_data.comp_mode = comp_mode;\n\tinit_data.p_comp_data = p_comp_addr;\n\n\trc = qed_sp_init_request(p_hwfn, &p_ent,\n\t\t\t\t ISCSI_RAMROD_CMD_ID_MAC_UPDATE,\n\t\t\t\t PROTOCOLID_TCP_ULP, &init_data);\n\tif (rc)\n\t\treturn rc;\n\n\tp_ramrod = &p_ent->ramrod.iscsi_conn_mac_update;\n\n\tp_ramrod->conn_id = cpu_to_le16(p_conn->conn_id);\n\tucval = p_conn->remote_mac[1];\n\t((u8 *)(&p_ramrod->remote_mac_addr_hi))[0] = ucval;\n\tucval = p_conn->remote_mac[0];\n\t((u8 *)(&p_ramrod->remote_mac_addr_hi))[1] = ucval;\n\tucval = p_conn->remote_mac[3];\n\t((u8 *)(&p_ramrod->remote_mac_addr_mid))[0] = ucval;\n\tucval = p_conn->remote_mac[2];\n\t((u8 *)(&p_ramrod->remote_mac_addr_mid))[1] = ucval;\n\tucval = p_conn->remote_mac[5];\n\t((u8 *)(&p_ramrod->remote_mac_addr_lo))[0] = ucval;\n\tucval = p_conn->remote_mac[4];\n\t((u8 *)(&p_ramrod->remote_mac_addr_lo))[1] = ucval;\n\n\treturn qed_spq_post(p_hwfn, p_ent, NULL);\n}\n\nstatic int qed_sp_iscsi_conn_terminate(struct qed_hwfn *p_hwfn,\n\t\t\t\t       struct qed_iscsi_conn *p_conn,\n\t\t\t\t       enum spq_mode comp_mode,\n\t\t\t\t       struct qed_spq_comp_cb *p_comp_addr)\n{\n\tstruct iscsi_spe_conn_termination *p_ramrod = NULL;\n\tstruct qed_spq_entry *p_ent = NULL;\n\tstruct qed_sp_init_data init_data;\n\tint rc = -EINVAL;\n\n\t \n\tmemset(&init_data, 0, sizeof(init_data));\n\tinit_data.cid = p_conn->icid;\n\tinit_data.opaque_fid = p_hwfn->hw_info.opaque_fid;\n\tinit_data.comp_mode = comp_mode;\n\tinit_data.p_comp_data = p_comp_addr;\n\n\trc = qed_sp_init_request(p_hwfn, &p_ent,\n\t\t\t\t ISCSI_RAMROD_CMD_ID_TERMINATION_CONN,\n\t\t\t\t PROTOCOLID_TCP_ULP, &init_data);\n\tif (rc)\n\t\treturn rc;\n\n\tp_ramrod = &p_ent->ramrod.iscsi_conn_terminate;\n\n\tp_ramrod->conn_id = cpu_to_le16(p_conn->conn_id);\n\tp_ramrod->abortive = p_conn->abortive_dsconnect;\n\n\tDMA_REGPAIR_LE(p_ramrod->query_params_addr,\n\t\t       p_conn->tcp_upload_params_phys_addr);\n\tDMA_REGPAIR_LE(p_ramrod->queue_cnts_addr, p_conn->queue_cnts_phys_addr);\n\n\treturn qed_spq_post(p_hwfn, p_ent, NULL);\n}\n\nstatic int qed_sp_iscsi_conn_clear_sq(struct qed_hwfn *p_hwfn,\n\t\t\t\t      struct qed_iscsi_conn *p_conn,\n\t\t\t\t      enum spq_mode comp_mode,\n\t\t\t\t      struct qed_spq_comp_cb *p_comp_addr)\n{\n\tstruct qed_spq_entry *p_ent = NULL;\n\tstruct qed_sp_init_data init_data;\n\tint rc = -EINVAL;\n\n\t \n\tmemset(&init_data, 0, sizeof(init_data));\n\tinit_data.cid = p_conn->icid;\n\tinit_data.opaque_fid = p_hwfn->hw_info.opaque_fid;\n\tinit_data.comp_mode = comp_mode;\n\tinit_data.p_comp_data = p_comp_addr;\n\n\trc = qed_sp_init_request(p_hwfn, &p_ent,\n\t\t\t\t ISCSI_RAMROD_CMD_ID_CLEAR_SQ,\n\t\t\t\t PROTOCOLID_TCP_ULP, &init_data);\n\tif (rc)\n\t\treturn rc;\n\n\treturn qed_spq_post(p_hwfn, p_ent, NULL);\n}\n\nstatic int qed_sp_iscsi_func_stop(struct qed_hwfn *p_hwfn,\n\t\t\t\t  enum spq_mode comp_mode,\n\t\t\t\t  struct qed_spq_comp_cb *p_comp_addr)\n{\n\tstruct qed_spq_entry *p_ent = NULL;\n\tstruct qed_sp_init_data init_data;\n\tint rc = 0;\n\n\t \n\tmemset(&init_data, 0, sizeof(init_data));\n\tinit_data.cid = qed_spq_get_cid(p_hwfn);\n\tinit_data.opaque_fid = p_hwfn->hw_info.opaque_fid;\n\tinit_data.comp_mode = comp_mode;\n\tinit_data.p_comp_data = p_comp_addr;\n\n\trc = qed_sp_init_request(p_hwfn, &p_ent,\n\t\t\t\t ISCSI_RAMROD_CMD_ID_DESTROY_FUNC,\n\t\t\t\t PROTOCOLID_TCP_ULP, &init_data);\n\tif (rc)\n\t\treturn rc;\n\n\trc = qed_spq_post(p_hwfn, p_ent, NULL);\n\n\tqed_spq_unregister_async_cb(p_hwfn, PROTOCOLID_TCP_ULP);\n\treturn rc;\n}\n\nstatic void __iomem *qed_iscsi_get_db_addr(struct qed_hwfn *p_hwfn, u32 cid)\n{\n\treturn (u8 __iomem *)p_hwfn->doorbells +\n\t\t\t     qed_db_addr(cid, DQ_DEMS_LEGACY);\n}\n\nstatic void __iomem *qed_iscsi_get_primary_bdq_prod(struct qed_hwfn *p_hwfn,\n\t\t\t\t\t\t    u8 bdq_id)\n{\n\tif (RESC_NUM(p_hwfn, QED_BDQ)) {\n\t\treturn (u8 __iomem *)p_hwfn->regview +\n\t\t    GET_GTT_BDQ_REG_ADDR(GTT_BAR0_MAP_REG_MSDM_RAM,\n\t\t\t\t\t MSTORM_SCSI_BDQ_EXT_PROD,\n\t\t\t\t\t RESC_START(p_hwfn, QED_BDQ), bdq_id);\n\t} else {\n\t\tDP_NOTICE(p_hwfn, \"BDQ is not allocated!\\n\");\n\t\treturn NULL;\n\t}\n}\n\nstatic void __iomem *qed_iscsi_get_secondary_bdq_prod(struct qed_hwfn *p_hwfn,\n\t\t\t\t\t\t      u8 bdq_id)\n{\n\tif (RESC_NUM(p_hwfn, QED_BDQ)) {\n\t\treturn (u8 __iomem *)p_hwfn->regview +\n\t\t    GET_GTT_BDQ_REG_ADDR(GTT_BAR0_MAP_REG_TSDM_RAM,\n\t\t\t\t\t TSTORM_SCSI_BDQ_EXT_PROD,\n\t\t\t\t\t RESC_START(p_hwfn, QED_BDQ), bdq_id);\n\t} else {\n\t\tDP_NOTICE(p_hwfn, \"BDQ is not allocated!\\n\");\n\t\treturn NULL;\n\t}\n}\n\nstatic int qed_iscsi_setup_connection(struct qed_iscsi_conn *p_conn)\n{\n\tif (!p_conn->queue_cnts_virt_addr)\n\t\tgoto nomem;\n\tmemset(p_conn->queue_cnts_virt_addr, 0,\n\t       sizeof(*p_conn->queue_cnts_virt_addr));\n\n\tif (!p_conn->tcp_upload_params_virt_addr)\n\t\tgoto nomem;\n\tmemset(p_conn->tcp_upload_params_virt_addr, 0,\n\t       sizeof(*p_conn->tcp_upload_params_virt_addr));\n\n\tif (!p_conn->r2tq.p_virt_addr)\n\t\tgoto nomem;\n\tqed_chain_pbl_zero_mem(&p_conn->r2tq);\n\n\tif (!p_conn->uhq.p_virt_addr)\n\t\tgoto nomem;\n\tqed_chain_pbl_zero_mem(&p_conn->uhq);\n\n\tif (!p_conn->xhq.p_virt_addr)\n\t\tgoto nomem;\n\tqed_chain_pbl_zero_mem(&p_conn->xhq);\n\n\treturn 0;\nnomem:\n\treturn -ENOMEM;\n}\n\nstatic int qed_iscsi_allocate_connection(struct qed_hwfn *p_hwfn,\n\t\t\t\t\t struct qed_iscsi_conn **p_out_conn)\n{\n\tstruct scsi_terminate_extra_params *p_q_cnts = NULL;\n\tstruct qed_iscsi_pf_params *p_params = NULL;\n\tstruct qed_chain_init_params params = {\n\t\t.mode\t\t= QED_CHAIN_MODE_PBL,\n\t\t.intended_use\t= QED_CHAIN_USE_TO_CONSUME_PRODUCE,\n\t\t.cnt_type\t= QED_CHAIN_CNT_TYPE_U16,\n\t};\n\tstruct tcp_upload_params *p_tcp = NULL;\n\tstruct qed_iscsi_conn *p_conn = NULL;\n\tint rc = 0;\n\n\t \n\tspin_lock_bh(&p_hwfn->p_iscsi_info->lock);\n\tif (!list_empty(&p_hwfn->p_iscsi_info->free_list))\n\t\tp_conn = list_first_entry(&p_hwfn->p_iscsi_info->free_list,\n\t\t\t\t\t  struct qed_iscsi_conn, list_entry);\n\tif (p_conn) {\n\t\tlist_del(&p_conn->list_entry);\n\t\tspin_unlock_bh(&p_hwfn->p_iscsi_info->lock);\n\t\t*p_out_conn = p_conn;\n\t\treturn 0;\n\t}\n\tspin_unlock_bh(&p_hwfn->p_iscsi_info->lock);\n\n\t \n\tp_params = &p_hwfn->pf_params.iscsi_pf_params;\n\n\tp_conn = kzalloc(sizeof(*p_conn), GFP_KERNEL);\n\tif (!p_conn)\n\t\treturn -ENOMEM;\n\n\tp_q_cnts = dma_alloc_coherent(&p_hwfn->cdev->pdev->dev,\n\t\t\t\t      sizeof(*p_q_cnts),\n\t\t\t\t      &p_conn->queue_cnts_phys_addr,\n\t\t\t\t      GFP_KERNEL);\n\tif (!p_q_cnts)\n\t\tgoto nomem_queue_cnts_param;\n\tp_conn->queue_cnts_virt_addr = p_q_cnts;\n\n\tp_tcp = dma_alloc_coherent(&p_hwfn->cdev->pdev->dev,\n\t\t\t\t   sizeof(*p_tcp),\n\t\t\t\t   &p_conn->tcp_upload_params_phys_addr,\n\t\t\t\t   GFP_KERNEL);\n\tif (!p_tcp)\n\t\tgoto nomem_upload_param;\n\tp_conn->tcp_upload_params_virt_addr = p_tcp;\n\n\tparams.num_elems = p_params->num_r2tq_pages_in_ring *\n\t\t\t   QED_CHAIN_PAGE_SIZE / sizeof(struct iscsi_wqe);\n\tparams.elem_size = sizeof(struct iscsi_wqe);\n\n\trc = qed_chain_alloc(p_hwfn->cdev, &p_conn->r2tq, &params);\n\tif (rc)\n\t\tgoto nomem_r2tq;\n\n\tparams.num_elems = p_params->num_uhq_pages_in_ring *\n\t\t\t   QED_CHAIN_PAGE_SIZE / sizeof(struct iscsi_uhqe);\n\tparams.elem_size = sizeof(struct iscsi_uhqe);\n\n\trc = qed_chain_alloc(p_hwfn->cdev, &p_conn->uhq, &params);\n\tif (rc)\n\t\tgoto nomem_uhq;\n\n\tparams.elem_size = sizeof(struct iscsi_xhqe);\n\n\trc = qed_chain_alloc(p_hwfn->cdev, &p_conn->xhq, &params);\n\tif (rc)\n\t\tgoto nomem;\n\n\tp_conn->free_on_delete = true;\n\t*p_out_conn = p_conn;\n\treturn 0;\n\nnomem:\n\tqed_chain_free(p_hwfn->cdev, &p_conn->uhq);\nnomem_uhq:\n\tqed_chain_free(p_hwfn->cdev, &p_conn->r2tq);\nnomem_r2tq:\n\tdma_free_coherent(&p_hwfn->cdev->pdev->dev,\n\t\t\t  sizeof(struct tcp_upload_params),\n\t\t\t  p_conn->tcp_upload_params_virt_addr,\n\t\t\t  p_conn->tcp_upload_params_phys_addr);\nnomem_upload_param:\n\tdma_free_coherent(&p_hwfn->cdev->pdev->dev,\n\t\t\t  sizeof(struct scsi_terminate_extra_params),\n\t\t\t  p_conn->queue_cnts_virt_addr,\n\t\t\t  p_conn->queue_cnts_phys_addr);\nnomem_queue_cnts_param:\n\tkfree(p_conn);\n\n\treturn -ENOMEM;\n}\n\nstatic int qed_iscsi_acquire_connection(struct qed_hwfn *p_hwfn,\n\t\t\t\t\tstruct qed_iscsi_conn *p_in_conn,\n\t\t\t\t\tstruct qed_iscsi_conn **p_out_conn)\n{\n\tstruct qed_iscsi_conn *p_conn = NULL;\n\tint rc = 0;\n\tu32 icid;\n\n\tspin_lock_bh(&p_hwfn->p_iscsi_info->lock);\n\trc = qed_cxt_acquire_cid(p_hwfn, PROTOCOLID_TCP_ULP, &icid);\n\tspin_unlock_bh(&p_hwfn->p_iscsi_info->lock);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tif (p_in_conn)\n\t\tp_conn = p_in_conn;\n\telse\n\t\trc = qed_iscsi_allocate_connection(p_hwfn, &p_conn);\n\n\tif (!rc)\n\t\trc = qed_iscsi_setup_connection(p_conn);\n\n\tif (rc) {\n\t\tspin_lock_bh(&p_hwfn->p_iscsi_info->lock);\n\t\tqed_cxt_release_cid(p_hwfn, icid);\n\t\tspin_unlock_bh(&p_hwfn->p_iscsi_info->lock);\n\t\treturn rc;\n\t}\n\n\tp_conn->icid = icid;\n\tp_conn->conn_id = (u16)icid;\n\tp_conn->fw_cid = (p_hwfn->hw_info.opaque_fid << 16) | icid;\n\n\t*p_out_conn = p_conn;\n\n\treturn rc;\n}\n\nstatic void qed_iscsi_release_connection(struct qed_hwfn *p_hwfn,\n\t\t\t\t\t struct qed_iscsi_conn *p_conn)\n{\n\tspin_lock_bh(&p_hwfn->p_iscsi_info->lock);\n\tlist_add_tail(&p_conn->list_entry, &p_hwfn->p_iscsi_info->free_list);\n\tqed_cxt_release_cid(p_hwfn, p_conn->icid);\n\tspin_unlock_bh(&p_hwfn->p_iscsi_info->lock);\n}\n\nstatic void qed_iscsi_free_connection(struct qed_hwfn *p_hwfn,\n\t\t\t\t      struct qed_iscsi_conn *p_conn)\n{\n\tqed_chain_free(p_hwfn->cdev, &p_conn->xhq);\n\tqed_chain_free(p_hwfn->cdev, &p_conn->uhq);\n\tqed_chain_free(p_hwfn->cdev, &p_conn->r2tq);\n\tdma_free_coherent(&p_hwfn->cdev->pdev->dev,\n\t\t\t  sizeof(struct tcp_upload_params),\n\t\t\t  p_conn->tcp_upload_params_virt_addr,\n\t\t\t  p_conn->tcp_upload_params_phys_addr);\n\tdma_free_coherent(&p_hwfn->cdev->pdev->dev,\n\t\t\t  sizeof(struct scsi_terminate_extra_params),\n\t\t\t  p_conn->queue_cnts_virt_addr,\n\t\t\t  p_conn->queue_cnts_phys_addr);\n\tkfree(p_conn);\n}\n\nint qed_iscsi_alloc(struct qed_hwfn *p_hwfn)\n{\n\tstruct qed_iscsi_info *p_iscsi_info;\n\n\tp_iscsi_info = kzalloc(sizeof(*p_iscsi_info), GFP_KERNEL);\n\tif (!p_iscsi_info)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&p_iscsi_info->free_list);\n\n\tp_hwfn->p_iscsi_info = p_iscsi_info;\n\treturn 0;\n}\n\nvoid qed_iscsi_setup(struct qed_hwfn *p_hwfn)\n{\n\tspin_lock_init(&p_hwfn->p_iscsi_info->lock);\n}\n\nvoid qed_iscsi_free(struct qed_hwfn *p_hwfn)\n{\n\tstruct qed_iscsi_conn *p_conn = NULL;\n\n\tif (!p_hwfn->p_iscsi_info)\n\t\treturn;\n\n\twhile (!list_empty(&p_hwfn->p_iscsi_info->free_list)) {\n\t\tp_conn = list_first_entry(&p_hwfn->p_iscsi_info->free_list,\n\t\t\t\t\t  struct qed_iscsi_conn, list_entry);\n\t\tif (p_conn) {\n\t\t\tlist_del(&p_conn->list_entry);\n\t\t\tqed_iscsi_free_connection(p_hwfn, p_conn);\n\t\t}\n\t}\n\n\tkfree(p_hwfn->p_iscsi_info);\n\tp_hwfn->p_iscsi_info = NULL;\n}\n\nstatic void _qed_iscsi_get_tstats(struct qed_hwfn *p_hwfn,\n\t\t\t\t  struct qed_ptt *p_ptt,\n\t\t\t\t  struct qed_iscsi_stats *p_stats)\n{\n\tstruct tstorm_iscsi_stats_drv tstats;\n\tu32 tstats_addr;\n\n\tmemset(&tstats, 0, sizeof(tstats));\n\ttstats_addr = BAR0_MAP_REG_TSDM_RAM +\n\t\t      TSTORM_ISCSI_RX_STATS_OFFSET(p_hwfn->rel_pf_id);\n\tqed_memcpy_from(p_hwfn, p_ptt, &tstats, tstats_addr, sizeof(tstats));\n\n\tp_stats->iscsi_rx_bytes_cnt =\n\t    HILO_64_REGPAIR(tstats.iscsi_rx_bytes_cnt);\n\tp_stats->iscsi_rx_packet_cnt =\n\t    HILO_64_REGPAIR(tstats.iscsi_rx_packet_cnt);\n\tp_stats->iscsi_rx_new_ooo_isle_events_cnt =\n\t    HILO_64_REGPAIR(tstats.iscsi_rx_new_ooo_isle_events_cnt);\n\tp_stats->iscsi_cmdq_threshold_cnt =\n\t    le32_to_cpu(tstats.iscsi_cmdq_threshold_cnt);\n\tp_stats->iscsi_rq_threshold_cnt =\n\t    le32_to_cpu(tstats.iscsi_rq_threshold_cnt);\n\tp_stats->iscsi_immq_threshold_cnt =\n\t    le32_to_cpu(tstats.iscsi_immq_threshold_cnt);\n}\n\nstatic void _qed_iscsi_get_mstats(struct qed_hwfn *p_hwfn,\n\t\t\t\t  struct qed_ptt *p_ptt,\n\t\t\t\t  struct qed_iscsi_stats *p_stats)\n{\n\tstruct mstorm_iscsi_stats_drv mstats;\n\tu32 mstats_addr;\n\n\tmemset(&mstats, 0, sizeof(mstats));\n\tmstats_addr = BAR0_MAP_REG_MSDM_RAM +\n\t\t      MSTORM_ISCSI_RX_STATS_OFFSET(p_hwfn->rel_pf_id);\n\tqed_memcpy_from(p_hwfn, p_ptt, &mstats, mstats_addr, sizeof(mstats));\n\n\tp_stats->iscsi_rx_dropped_pdus_task_not_valid =\n\t    HILO_64_REGPAIR(mstats.iscsi_rx_dropped_pdus_task_not_valid);\n}\n\nstatic void _qed_iscsi_get_ustats(struct qed_hwfn *p_hwfn,\n\t\t\t\t  struct qed_ptt *p_ptt,\n\t\t\t\t  struct qed_iscsi_stats *p_stats)\n{\n\tstruct ustorm_iscsi_stats_drv ustats;\n\tu32 ustats_addr;\n\n\tmemset(&ustats, 0, sizeof(ustats));\n\tustats_addr = BAR0_MAP_REG_USDM_RAM +\n\t\t      USTORM_ISCSI_RX_STATS_OFFSET(p_hwfn->rel_pf_id);\n\tqed_memcpy_from(p_hwfn, p_ptt, &ustats, ustats_addr, sizeof(ustats));\n\n\tp_stats->iscsi_rx_data_pdu_cnt =\n\t    HILO_64_REGPAIR(ustats.iscsi_rx_data_pdu_cnt);\n\tp_stats->iscsi_rx_r2t_pdu_cnt =\n\t    HILO_64_REGPAIR(ustats.iscsi_rx_r2t_pdu_cnt);\n\tp_stats->iscsi_rx_total_pdu_cnt =\n\t    HILO_64_REGPAIR(ustats.iscsi_rx_total_pdu_cnt);\n}\n\nstatic void _qed_iscsi_get_xstats(struct qed_hwfn *p_hwfn,\n\t\t\t\t  struct qed_ptt *p_ptt,\n\t\t\t\t  struct qed_iscsi_stats *p_stats)\n{\n\tstruct xstorm_iscsi_stats_drv xstats;\n\tu32 xstats_addr;\n\n\tmemset(&xstats, 0, sizeof(xstats));\n\txstats_addr = BAR0_MAP_REG_XSDM_RAM +\n\t\t      XSTORM_ISCSI_TX_STATS_OFFSET(p_hwfn->rel_pf_id);\n\tqed_memcpy_from(p_hwfn, p_ptt, &xstats, xstats_addr, sizeof(xstats));\n\n\tp_stats->iscsi_tx_go_to_slow_start_event_cnt =\n\t    HILO_64_REGPAIR(xstats.iscsi_tx_go_to_slow_start_event_cnt);\n\tp_stats->iscsi_tx_fast_retransmit_event_cnt =\n\t    HILO_64_REGPAIR(xstats.iscsi_tx_fast_retransmit_event_cnt);\n}\n\nstatic void _qed_iscsi_get_ystats(struct qed_hwfn *p_hwfn,\n\t\t\t\t  struct qed_ptt *p_ptt,\n\t\t\t\t  struct qed_iscsi_stats *p_stats)\n{\n\tstruct ystorm_iscsi_stats_drv ystats;\n\tu32 ystats_addr;\n\n\tmemset(&ystats, 0, sizeof(ystats));\n\tystats_addr = BAR0_MAP_REG_YSDM_RAM +\n\t\t      YSTORM_ISCSI_TX_STATS_OFFSET(p_hwfn->rel_pf_id);\n\tqed_memcpy_from(p_hwfn, p_ptt, &ystats, ystats_addr, sizeof(ystats));\n\n\tp_stats->iscsi_tx_data_pdu_cnt =\n\t    HILO_64_REGPAIR(ystats.iscsi_tx_data_pdu_cnt);\n\tp_stats->iscsi_tx_r2t_pdu_cnt =\n\t    HILO_64_REGPAIR(ystats.iscsi_tx_r2t_pdu_cnt);\n\tp_stats->iscsi_tx_total_pdu_cnt =\n\t    HILO_64_REGPAIR(ystats.iscsi_tx_total_pdu_cnt);\n}\n\nstatic void _qed_iscsi_get_pstats(struct qed_hwfn *p_hwfn,\n\t\t\t\t  struct qed_ptt *p_ptt,\n\t\t\t\t  struct qed_iscsi_stats *p_stats)\n{\n\tstruct pstorm_iscsi_stats_drv pstats;\n\tu32 pstats_addr;\n\n\tmemset(&pstats, 0, sizeof(pstats));\n\tpstats_addr = BAR0_MAP_REG_PSDM_RAM +\n\t\t      PSTORM_ISCSI_TX_STATS_OFFSET(p_hwfn->rel_pf_id);\n\tqed_memcpy_from(p_hwfn, p_ptt, &pstats, pstats_addr, sizeof(pstats));\n\n\tp_stats->iscsi_tx_bytes_cnt =\n\t    HILO_64_REGPAIR(pstats.iscsi_tx_bytes_cnt);\n\tp_stats->iscsi_tx_packet_cnt =\n\t    HILO_64_REGPAIR(pstats.iscsi_tx_packet_cnt);\n}\n\nstatic int qed_iscsi_get_stats(struct qed_hwfn *p_hwfn,\n\t\t\t       struct qed_iscsi_stats *stats,\n\t\t\t       bool is_atomic)\n{\n\tstruct qed_ptt *p_ptt;\n\n\tmemset(stats, 0, sizeof(*stats));\n\n\tp_ptt = qed_ptt_acquire_context(p_hwfn, is_atomic);\n\tif (!p_ptt) {\n\t\tDP_ERR(p_hwfn, \"Failed to acquire ptt\\n\");\n\t\treturn -EAGAIN;\n\t}\n\n\t_qed_iscsi_get_tstats(p_hwfn, p_ptt, stats);\n\t_qed_iscsi_get_mstats(p_hwfn, p_ptt, stats);\n\t_qed_iscsi_get_ustats(p_hwfn, p_ptt, stats);\n\n\t_qed_iscsi_get_xstats(p_hwfn, p_ptt, stats);\n\t_qed_iscsi_get_ystats(p_hwfn, p_ptt, stats);\n\t_qed_iscsi_get_pstats(p_hwfn, p_ptt, stats);\n\n\tqed_ptt_release(p_hwfn, p_ptt);\n\n\treturn 0;\n}\n\nstruct qed_hash_iscsi_con {\n\tstruct hlist_node node;\n\tstruct qed_iscsi_conn *con;\n};\n\nstatic int qed_fill_iscsi_dev_info(struct qed_dev *cdev,\n\t\t\t\t   struct qed_dev_iscsi_info *info)\n{\n\tstruct qed_hwfn *hwfn = QED_AFFIN_HWFN(cdev);\n\n\tint rc;\n\n\tmemset(info, 0, sizeof(*info));\n\trc = qed_fill_dev_info(cdev, &info->common);\n\n\tinfo->primary_dbq_rq_addr =\n\t    qed_iscsi_get_primary_bdq_prod(hwfn, BDQ_ID_RQ);\n\tinfo->secondary_bdq_rq_addr =\n\t    qed_iscsi_get_secondary_bdq_prod(hwfn, BDQ_ID_RQ);\n\n\tinfo->num_cqs = FEAT_NUM(hwfn, QED_ISCSI_CQ);\n\n\treturn rc;\n}\n\nstatic void qed_register_iscsi_ops(struct qed_dev *cdev,\n\t\t\t\t   struct qed_iscsi_cb_ops *ops, void *cookie)\n{\n\tcdev->protocol_ops.iscsi = ops;\n\tcdev->ops_cookie = cookie;\n}\n\nstatic struct qed_hash_iscsi_con *qed_iscsi_get_hash(struct qed_dev *cdev,\n\t\t\t\t\t\t     u32 handle)\n{\n\tstruct qed_hash_iscsi_con *hash_con = NULL;\n\n\tif (!(cdev->flags & QED_FLAG_STORAGE_STARTED))\n\t\treturn NULL;\n\n\thash_for_each_possible(cdev->connections, hash_con, node, handle) {\n\t\tif (hash_con->con->icid == handle)\n\t\t\tbreak;\n\t}\n\n\tif (!hash_con || (hash_con->con->icid != handle))\n\t\treturn NULL;\n\n\treturn hash_con;\n}\n\nstatic int qed_iscsi_stop(struct qed_dev *cdev)\n{\n\tint rc;\n\n\tif (!(cdev->flags & QED_FLAG_STORAGE_STARTED)) {\n\t\tDP_NOTICE(cdev, \"iscsi already stopped\\n\");\n\t\treturn 0;\n\t}\n\n\tif (!hash_empty(cdev->connections)) {\n\t\tDP_NOTICE(cdev,\n\t\t\t  \"Can't stop iscsi - not all connections were returned\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\trc = qed_sp_iscsi_func_stop(QED_AFFIN_HWFN(cdev), QED_SPQ_MODE_EBLOCK,\n\t\t\t\t    NULL);\n\tcdev->flags &= ~QED_FLAG_STORAGE_STARTED;\n\n\treturn rc;\n}\n\nstatic int qed_iscsi_start(struct qed_dev *cdev,\n\t\t\t   struct qed_iscsi_tid *tasks,\n\t\t\t   void *event_context,\n\t\t\t   iscsi_event_cb_t async_event_cb)\n{\n\tint rc;\n\tstruct qed_tid_mem *tid_info;\n\n\tif (cdev->flags & QED_FLAG_STORAGE_STARTED) {\n\t\tDP_NOTICE(cdev, \"iscsi already started;\\n\");\n\t\treturn 0;\n\t}\n\n\trc = qed_sp_iscsi_func_start(QED_AFFIN_HWFN(cdev), QED_SPQ_MODE_EBLOCK,\n\t\t\t\t     NULL, event_context, async_event_cb);\n\tif (rc) {\n\t\tDP_NOTICE(cdev, \"Failed to start iscsi\\n\");\n\t\treturn rc;\n\t}\n\n\tcdev->flags |= QED_FLAG_STORAGE_STARTED;\n\thash_init(cdev->connections);\n\n\tif (!tasks)\n\t\treturn 0;\n\n\ttid_info = kzalloc(sizeof(*tid_info), GFP_KERNEL);\n\n\tif (!tid_info) {\n\t\tqed_iscsi_stop(cdev);\n\t\treturn -ENOMEM;\n\t}\n\n\trc = qed_cxt_get_tid_mem_info(QED_AFFIN_HWFN(cdev), tid_info);\n\tif (rc) {\n\t\tDP_NOTICE(cdev, \"Failed to gather task information\\n\");\n\t\tqed_iscsi_stop(cdev);\n\t\tkfree(tid_info);\n\t\treturn rc;\n\t}\n\n\t \n\ttasks->size = tid_info->tid_size;\n\ttasks->num_tids_per_block = tid_info->num_tids_per_block;\n\tmemcpy(tasks->blocks, tid_info->blocks,\n\t       MAX_TID_BLOCKS_ISCSI * sizeof(u8 *));\n\n\tkfree(tid_info);\n\n\treturn 0;\n}\n\nstatic int qed_iscsi_acquire_conn(struct qed_dev *cdev,\n\t\t\t\t  u32 *handle,\n\t\t\t\t  u32 *fw_cid, void __iomem **p_doorbell)\n{\n\tstruct qed_hash_iscsi_con *hash_con;\n\tint rc;\n\n\t \n\thash_con = kzalloc(sizeof(*hash_con), GFP_ATOMIC);\n\tif (!hash_con)\n\t\treturn -ENOMEM;\n\n\t \n\trc = qed_iscsi_acquire_connection(QED_AFFIN_HWFN(cdev), NULL,\n\t\t\t\t\t  &hash_con->con);\n\tif (rc) {\n\t\tDP_NOTICE(cdev, \"Failed to acquire Connection\\n\");\n\t\tkfree(hash_con);\n\t\treturn rc;\n\t}\n\n\t \n\t*handle = hash_con->con->icid;\n\t*fw_cid = hash_con->con->fw_cid;\n\thash_add(cdev->connections, &hash_con->node, *handle);\n\n\tif (p_doorbell)\n\t\t*p_doorbell = qed_iscsi_get_db_addr(QED_AFFIN_HWFN(cdev),\n\t\t\t\t\t\t    *handle);\n\n\treturn 0;\n}\n\nstatic int qed_iscsi_release_conn(struct qed_dev *cdev, u32 handle)\n{\n\tstruct qed_hash_iscsi_con *hash_con;\n\n\thash_con = qed_iscsi_get_hash(cdev, handle);\n\tif (!hash_con) {\n\t\tDP_NOTICE(cdev, \"Failed to find connection for handle %d\\n\",\n\t\t\t  handle);\n\t\treturn -EINVAL;\n\t}\n\n\thlist_del(&hash_con->node);\n\tqed_iscsi_release_connection(QED_AFFIN_HWFN(cdev), hash_con->con);\n\tkfree(hash_con);\n\n\treturn 0;\n}\n\nstatic int qed_iscsi_offload_conn(struct qed_dev *cdev,\n\t\t\t\t  u32 handle,\n\t\t\t\t  struct qed_iscsi_params_offload *conn_info)\n{\n\tstruct qed_hash_iscsi_con *hash_con;\n\tstruct qed_iscsi_conn *con;\n\n\thash_con = qed_iscsi_get_hash(cdev, handle);\n\tif (!hash_con) {\n\t\tDP_NOTICE(cdev, \"Failed to find connection for handle %d\\n\",\n\t\t\t  handle);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tcon = hash_con->con;\n\n\tether_addr_copy(con->local_mac, conn_info->src.mac);\n\tether_addr_copy(con->remote_mac, conn_info->dst.mac);\n\tmemcpy(con->local_ip, conn_info->src.ip, sizeof(con->local_ip));\n\tmemcpy(con->remote_ip, conn_info->dst.ip, sizeof(con->remote_ip));\n\tcon->local_port = conn_info->src.port;\n\tcon->remote_port = conn_info->dst.port;\n\n\tcon->layer_code = conn_info->layer_code;\n\tcon->sq_pbl_addr = conn_info->sq_pbl_addr;\n\tcon->initial_ack = conn_info->initial_ack;\n\tcon->vlan_id = conn_info->vlan_id;\n\tcon->tcp_flags = conn_info->tcp_flags;\n\tcon->ip_version = conn_info->ip_version;\n\tcon->default_cq = conn_info->default_cq;\n\tcon->ka_max_probe_cnt = conn_info->ka_max_probe_cnt;\n\tcon->dup_ack_theshold = conn_info->dup_ack_theshold;\n\tcon->rcv_next = conn_info->rcv_next;\n\tcon->snd_una = conn_info->snd_una;\n\tcon->snd_next = conn_info->snd_next;\n\tcon->snd_max = conn_info->snd_max;\n\tcon->snd_wnd = conn_info->snd_wnd;\n\tcon->rcv_wnd = conn_info->rcv_wnd;\n\tcon->snd_wl1 = conn_info->snd_wl1;\n\tcon->cwnd = conn_info->cwnd;\n\tcon->ss_thresh = conn_info->ss_thresh;\n\tcon->srtt = conn_info->srtt;\n\tcon->rtt_var = conn_info->rtt_var;\n\tcon->ts_recent = conn_info->ts_recent;\n\tcon->ts_recent_age = conn_info->ts_recent_age;\n\tcon->total_rt = conn_info->total_rt;\n\tcon->ka_timeout_delta = conn_info->ka_timeout_delta;\n\tcon->rt_timeout_delta = conn_info->rt_timeout_delta;\n\tcon->dup_ack_cnt = conn_info->dup_ack_cnt;\n\tcon->snd_wnd_probe_cnt = conn_info->snd_wnd_probe_cnt;\n\tcon->ka_probe_cnt = conn_info->ka_probe_cnt;\n\tcon->rt_cnt = conn_info->rt_cnt;\n\tcon->flow_label = conn_info->flow_label;\n\tcon->ka_timeout = conn_info->ka_timeout;\n\tcon->ka_interval = conn_info->ka_interval;\n\tcon->max_rt_time = conn_info->max_rt_time;\n\tcon->initial_rcv_wnd = conn_info->initial_rcv_wnd;\n\tcon->ttl = conn_info->ttl;\n\tcon->tos_or_tc = conn_info->tos_or_tc;\n\tcon->remote_port = conn_info->remote_port;\n\tcon->local_port = conn_info->local_port;\n\tcon->mss = conn_info->mss;\n\tcon->snd_wnd_scale = conn_info->snd_wnd_scale;\n\tcon->rcv_wnd_scale = conn_info->rcv_wnd_scale;\n\tcon->da_timeout_value = conn_info->da_timeout_value;\n\tcon->ack_frequency = conn_info->ack_frequency;\n\n\t \n\tcon->offl_flags = 0x1;\n\n\treturn qed_sp_iscsi_conn_offload(QED_AFFIN_HWFN(cdev), con,\n\t\t\t\t\t QED_SPQ_MODE_EBLOCK, NULL);\n}\n\nstatic int qed_iscsi_update_conn(struct qed_dev *cdev,\n\t\t\t\t u32 handle,\n\t\t\t\t struct qed_iscsi_params_update *conn_info)\n{\n\tstruct qed_hash_iscsi_con *hash_con;\n\tstruct qed_iscsi_conn *con;\n\n\thash_con = qed_iscsi_get_hash(cdev, handle);\n\tif (!hash_con) {\n\t\tDP_NOTICE(cdev, \"Failed to find connection for handle %d\\n\",\n\t\t\t  handle);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tcon = hash_con->con;\n\tcon->update_flag = conn_info->update_flag;\n\tcon->max_seq_size = conn_info->max_seq_size;\n\tcon->max_recv_pdu_length = conn_info->max_recv_pdu_length;\n\tcon->max_send_pdu_length = conn_info->max_send_pdu_length;\n\tcon->first_seq_length = conn_info->first_seq_length;\n\tcon->exp_stat_sn = conn_info->exp_stat_sn;\n\n\treturn qed_sp_iscsi_conn_update(QED_AFFIN_HWFN(cdev), con,\n\t\t\t\t\tQED_SPQ_MODE_EBLOCK, NULL);\n}\n\nstatic int qed_iscsi_clear_conn_sq(struct qed_dev *cdev, u32 handle)\n{\n\tstruct qed_hash_iscsi_con *hash_con;\n\n\thash_con = qed_iscsi_get_hash(cdev, handle);\n\tif (!hash_con) {\n\t\tDP_NOTICE(cdev, \"Failed to find connection for handle %d\\n\",\n\t\t\t  handle);\n\t\treturn -EINVAL;\n\t}\n\n\treturn qed_sp_iscsi_conn_clear_sq(QED_AFFIN_HWFN(cdev), hash_con->con,\n\t\t\t\t\t  QED_SPQ_MODE_EBLOCK, NULL);\n}\n\nstatic int qed_iscsi_destroy_conn(struct qed_dev *cdev,\n\t\t\t\t  u32 handle, u8 abrt_conn)\n{\n\tstruct qed_hash_iscsi_con *hash_con;\n\n\thash_con = qed_iscsi_get_hash(cdev, handle);\n\tif (!hash_con) {\n\t\tDP_NOTICE(cdev, \"Failed to find connection for handle %d\\n\",\n\t\t\t  handle);\n\t\treturn -EINVAL;\n\t}\n\n\thash_con->con->abortive_dsconnect = abrt_conn;\n\n\treturn qed_sp_iscsi_conn_terminate(QED_AFFIN_HWFN(cdev), hash_con->con,\n\t\t\t\t\t   QED_SPQ_MODE_EBLOCK, NULL);\n}\n\nstatic int qed_iscsi_stats_context(struct qed_dev *cdev,\n\t\t\t\t   struct qed_iscsi_stats *stats,\n\t\t\t\t   bool is_atomic)\n{\n\treturn qed_iscsi_get_stats(QED_AFFIN_HWFN(cdev), stats, is_atomic);\n}\n\nstatic int qed_iscsi_stats(struct qed_dev *cdev, struct qed_iscsi_stats *stats)\n{\n\treturn qed_iscsi_stats_context(cdev, stats, false);\n}\n\nstatic int qed_iscsi_change_mac(struct qed_dev *cdev,\n\t\t\t\tu32 handle, const u8 *mac)\n{\n\tstruct qed_hash_iscsi_con *hash_con;\n\n\thash_con = qed_iscsi_get_hash(cdev, handle);\n\tif (!hash_con) {\n\t\tDP_NOTICE(cdev, \"Failed to find connection for handle %d\\n\",\n\t\t\t  handle);\n\t\treturn -EINVAL;\n\t}\n\n\treturn qed_sp_iscsi_mac_update(QED_AFFIN_HWFN(cdev), hash_con->con,\n\t\t\t\t       QED_SPQ_MODE_EBLOCK, NULL);\n}\n\nvoid qed_get_protocol_stats_iscsi(struct qed_dev *cdev,\n\t\t\t\t  struct qed_mcp_iscsi_stats *stats,\n\t\t\t\t  bool is_atomic)\n{\n\tstruct qed_iscsi_stats proto_stats;\n\n\t \n\tmemset(&proto_stats, 0, sizeof(proto_stats));\n\tif (qed_iscsi_stats_context(cdev, &proto_stats, is_atomic)) {\n\t\tDP_VERBOSE(cdev, QED_MSG_STORAGE,\n\t\t\t   \"Failed to collect ISCSI statistics\\n\");\n\t\treturn;\n\t}\n\n\t \n\tstats->rx_pdus = proto_stats.iscsi_rx_total_pdu_cnt;\n\tstats->tx_pdus = proto_stats.iscsi_tx_total_pdu_cnt;\n\tstats->rx_bytes = proto_stats.iscsi_rx_bytes_cnt;\n\tstats->tx_bytes = proto_stats.iscsi_tx_bytes_cnt;\n}\n\nstatic const struct qed_iscsi_ops qed_iscsi_ops_pass = {\n\t.common = &qed_common_ops_pass,\n\t.ll2 = &qed_ll2_ops_pass,\n\t.fill_dev_info = &qed_fill_iscsi_dev_info,\n\t.register_ops = &qed_register_iscsi_ops,\n\t.start = &qed_iscsi_start,\n\t.stop = &qed_iscsi_stop,\n\t.acquire_conn = &qed_iscsi_acquire_conn,\n\t.release_conn = &qed_iscsi_release_conn,\n\t.offload_conn = &qed_iscsi_offload_conn,\n\t.update_conn = &qed_iscsi_update_conn,\n\t.destroy_conn = &qed_iscsi_destroy_conn,\n\t.clear_sq = &qed_iscsi_clear_conn_sq,\n\t.get_stats = &qed_iscsi_stats,\n\t.change_mac = &qed_iscsi_change_mac,\n};\n\nconst struct qed_iscsi_ops *qed_get_iscsi_ops(void)\n{\n\treturn &qed_iscsi_ops_pass;\n}\nEXPORT_SYMBOL(qed_get_iscsi_ops);\n\nvoid qed_put_iscsi_ops(void)\n{\n}\nEXPORT_SYMBOL(qed_put_iscsi_ops);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}