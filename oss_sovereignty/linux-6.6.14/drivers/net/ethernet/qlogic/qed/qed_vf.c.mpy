{
  "module_name": "qed_vf.c",
  "hash_id": "eb246f5723e606ffaaba6144c0b8a901e965cc55cc77e39d751fc7fd0f8ff2da",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/qlogic/qed/qed_vf.c",
  "human_readable_source": "\n \n\n#include <linux/crc32.h>\n#include <linux/etherdevice.h>\n#include \"qed.h\"\n#include \"qed_sriov.h\"\n#include \"qed_vf.h\"\n\nstatic void *qed_vf_pf_prep(struct qed_hwfn *p_hwfn, u16 type, u16 length)\n{\n\tstruct qed_vf_iov *p_iov = p_hwfn->vf_iov_info;\n\tvoid *p_tlv;\n\n\t \n\tmutex_lock(&(p_iov->mutex));\n\n\tDP_VERBOSE(p_hwfn,\n\t\t   QED_MSG_IOV,\n\t\t   \"preparing to send 0x%04x tlv over vf pf channel\\n\",\n\t\t   type);\n\n\t \n\tp_iov->offset = (u8 *)p_iov->vf2pf_request;\n\n\t \n\tmemset(p_iov->vf2pf_request, 0, sizeof(union vfpf_tlvs));\n\tmemset(p_iov->pf2vf_reply, 0, sizeof(union pfvf_tlvs));\n\n\t \n\tp_tlv = qed_add_tlv(p_hwfn, &p_iov->offset, type, length);\n\n\t \n\t((struct vfpf_first_tlv *)p_tlv)->reply_address =\n\t    (u64)p_iov->pf2vf_reply_phys;\n\n\treturn p_tlv;\n}\n\nstatic void qed_vf_pf_req_end(struct qed_hwfn *p_hwfn, int req_status)\n{\n\tunion pfvf_tlvs *resp = p_hwfn->vf_iov_info->pf2vf_reply;\n\n\tDP_VERBOSE(p_hwfn, QED_MSG_IOV,\n\t\t   \"VF request status = 0x%x, PF reply status = 0x%x\\n\",\n\t\t   req_status, resp->default_resp.hdr.status);\n\n\tmutex_unlock(&(p_hwfn->vf_iov_info->mutex));\n}\n\n#define QED_VF_CHANNEL_USLEEP_ITERATIONS\t90\n#define QED_VF_CHANNEL_USLEEP_DELAY\t\t100\n#define QED_VF_CHANNEL_MSLEEP_ITERATIONS\t10\n#define QED_VF_CHANNEL_MSLEEP_DELAY\t\t25\n\nstatic int qed_send_msg2pf(struct qed_hwfn *p_hwfn, u8 *done)\n{\n\tunion vfpf_tlvs *p_req = p_hwfn->vf_iov_info->vf2pf_request;\n\tstruct ustorm_trigger_vf_zone trigger;\n\tstruct ustorm_vf_zone *zone_data;\n\tint iter, rc = 0;\n\n\tzone_data = (struct ustorm_vf_zone *)PXP_VF_BAR0_START_USDM_ZONE_B;\n\n\t \n\tqed_dp_tlv_list(p_hwfn, p_req);\n\n\t \n\tmemset(&trigger, 0, sizeof(struct ustorm_trigger_vf_zone));\n\ttrigger.vf_pf_msg_valid = 1;\n\n\tDP_VERBOSE(p_hwfn,\n\t\t   QED_MSG_IOV,\n\t\t   \"VF -> PF [%02x] message: [%08x, %08x] --> %p, %08x --> %p\\n\",\n\t\t   GET_FIELD(p_hwfn->hw_info.concrete_fid,\n\t\t\t     PXP_CONCRETE_FID_PFID),\n\t\t   upper_32_bits(p_hwfn->vf_iov_info->vf2pf_request_phys),\n\t\t   lower_32_bits(p_hwfn->vf_iov_info->vf2pf_request_phys),\n\t\t   &zone_data->non_trigger.vf_pf_msg_addr,\n\t\t   *((u32 *)&trigger), &zone_data->trigger);\n\n\tREG_WR(p_hwfn,\n\t       (uintptr_t)&zone_data->non_trigger.vf_pf_msg_addr.lo,\n\t       lower_32_bits(p_hwfn->vf_iov_info->vf2pf_request_phys));\n\n\tREG_WR(p_hwfn,\n\t       (uintptr_t)&zone_data->non_trigger.vf_pf_msg_addr.hi,\n\t       upper_32_bits(p_hwfn->vf_iov_info->vf2pf_request_phys));\n\n\t \n\twmb();\n\n\tREG_WR(p_hwfn, (uintptr_t)&zone_data->trigger, *((u32 *)&trigger));\n\n\t \n\n\titer = QED_VF_CHANNEL_USLEEP_ITERATIONS;\n\twhile (!*done && iter--) {\n\t\tudelay(QED_VF_CHANNEL_USLEEP_DELAY);\n\t\tdma_rmb();\n\t}\n\n\titer = QED_VF_CHANNEL_MSLEEP_ITERATIONS;\n\twhile (!*done && iter--) {\n\t\tmsleep(QED_VF_CHANNEL_MSLEEP_DELAY);\n\t\tdma_rmb();\n\t}\n\n\tif (!*done) {\n\t\tDP_NOTICE(p_hwfn,\n\t\t\t  \"VF <-- PF Timeout [Type %d]\\n\",\n\t\t\t  p_req->first_tlv.tl.type);\n\t\trc = -EBUSY;\n\t} else {\n\t\tif ((*done != PFVF_STATUS_SUCCESS) &&\n\t\t    (*done != PFVF_STATUS_NO_RESOURCE))\n\t\t\tDP_NOTICE(p_hwfn,\n\t\t\t\t  \"PF response: %d [Type %d]\\n\",\n\t\t\t\t  *done, p_req->first_tlv.tl.type);\n\t\telse\n\t\t\tDP_VERBOSE(p_hwfn, QED_MSG_IOV,\n\t\t\t\t   \"PF response: %d [Type %d]\\n\",\n\t\t\t\t   *done, p_req->first_tlv.tl.type);\n\t}\n\n\treturn rc;\n}\n\nstatic void qed_vf_pf_add_qid(struct qed_hwfn *p_hwfn,\n\t\t\t      struct qed_queue_cid *p_cid)\n{\n\tstruct qed_vf_iov *p_iov = p_hwfn->vf_iov_info;\n\tstruct vfpf_qid_tlv *p_qid_tlv;\n\n\t \n\tif (!(p_iov->acquire_resp.pfdev_info.capabilities &\n\t      PFVF_ACQUIRE_CAP_QUEUE_QIDS))\n\t\treturn;\n\n\tp_qid_tlv = qed_add_tlv(p_hwfn, &p_iov->offset,\n\t\t\t\tCHANNEL_TLV_QID, sizeof(*p_qid_tlv));\n\tp_qid_tlv->qid = p_cid->qid_usage_idx;\n}\n\nstatic int _qed_vf_pf_release(struct qed_hwfn *p_hwfn, bool b_final)\n{\n\tstruct qed_vf_iov *p_iov = p_hwfn->vf_iov_info;\n\tstruct pfvf_def_resp_tlv *resp;\n\tstruct vfpf_first_tlv *req;\n\tu32 size;\n\tint rc;\n\n\t \n\treq = qed_vf_pf_prep(p_hwfn, CHANNEL_TLV_RELEASE, sizeof(*req));\n\n\t \n\tqed_add_tlv(p_hwfn, &p_iov->offset,\n\t\t    CHANNEL_TLV_LIST_END, sizeof(struct channel_list_end_tlv));\n\n\tresp = &p_iov->pf2vf_reply->default_resp;\n\trc = qed_send_msg2pf(p_hwfn, &resp->hdr.status);\n\n\tif (!rc && resp->hdr.status != PFVF_STATUS_SUCCESS)\n\t\trc = -EAGAIN;\n\n\tqed_vf_pf_req_end(p_hwfn, rc);\n\tif (!b_final)\n\t\treturn rc;\n\n\tp_hwfn->b_int_enabled = 0;\n\n\tif (p_iov->vf2pf_request)\n\t\tdma_free_coherent(&p_hwfn->cdev->pdev->dev,\n\t\t\t\t  sizeof(union vfpf_tlvs),\n\t\t\t\t  p_iov->vf2pf_request,\n\t\t\t\t  p_iov->vf2pf_request_phys);\n\tif (p_iov->pf2vf_reply)\n\t\tdma_free_coherent(&p_hwfn->cdev->pdev->dev,\n\t\t\t\t  sizeof(union pfvf_tlvs),\n\t\t\t\t  p_iov->pf2vf_reply, p_iov->pf2vf_reply_phys);\n\n\tif (p_iov->bulletin.p_virt) {\n\t\tsize = sizeof(struct qed_bulletin_content);\n\t\tdma_free_coherent(&p_hwfn->cdev->pdev->dev,\n\t\t\t\t  size,\n\t\t\t\t  p_iov->bulletin.p_virt, p_iov->bulletin.phys);\n\t}\n\n\tkfree(p_hwfn->vf_iov_info);\n\tp_hwfn->vf_iov_info = NULL;\n\n\treturn rc;\n}\n\nint qed_vf_pf_release(struct qed_hwfn *p_hwfn)\n{\n\treturn _qed_vf_pf_release(p_hwfn, true);\n}\n\n#define VF_ACQUIRE_THRESH 3\nstatic void qed_vf_pf_acquire_reduce_resc(struct qed_hwfn *p_hwfn,\n\t\t\t\t\t  struct vf_pf_resc_request *p_req,\n\t\t\t\t\t  struct pf_vf_resc *p_resp)\n{\n\tDP_VERBOSE(p_hwfn,\n\t\t   QED_MSG_IOV,\n\t\t   \"PF unwilling to fulfill resource request: rxq [%02x/%02x] txq [%02x/%02x] sbs [%02x/%02x] mac [%02x/%02x] vlan [%02x/%02x] mc [%02x/%02x] cids [%02x/%02x]. Try PF recommended amount\\n\",\n\t\t   p_req->num_rxqs,\n\t\t   p_resp->num_rxqs,\n\t\t   p_req->num_rxqs,\n\t\t   p_resp->num_txqs,\n\t\t   p_req->num_sbs,\n\t\t   p_resp->num_sbs,\n\t\t   p_req->num_mac_filters,\n\t\t   p_resp->num_mac_filters,\n\t\t   p_req->num_vlan_filters,\n\t\t   p_resp->num_vlan_filters,\n\t\t   p_req->num_mc_filters,\n\t\t   p_resp->num_mc_filters, p_req->num_cids, p_resp->num_cids);\n\n\t \n\tp_req->num_txqs = p_resp->num_txqs;\n\tp_req->num_rxqs = p_resp->num_rxqs;\n\tp_req->num_sbs = p_resp->num_sbs;\n\tp_req->num_mac_filters = p_resp->num_mac_filters;\n\tp_req->num_vlan_filters = p_resp->num_vlan_filters;\n\tp_req->num_mc_filters = p_resp->num_mc_filters;\n\tp_req->num_cids = p_resp->num_cids;\n}\n\nstatic int qed_vf_pf_acquire(struct qed_hwfn *p_hwfn)\n{\n\tstruct qed_vf_iov *p_iov = p_hwfn->vf_iov_info;\n\tstruct pfvf_acquire_resp_tlv *resp = &p_iov->pf2vf_reply->acquire_resp;\n\tstruct pf_vf_pfdev_info *pfdev_info = &resp->pfdev_info;\n\tstruct vf_pf_resc_request *p_resc;\n\tu8 retry_cnt = VF_ACQUIRE_THRESH;\n\tbool resources_acquired = false;\n\tstruct vfpf_acquire_tlv *req;\n\tint rc = 0, attempts = 0;\n\n\t \n\treq = qed_vf_pf_prep(p_hwfn, CHANNEL_TLV_ACQUIRE, sizeof(*req));\n\tp_resc = &req->resc_request;\n\n\t \n\treq->vfdev_info.opaque_fid = p_hwfn->hw_info.opaque_fid;\n\n\tp_resc->num_rxqs = QED_MAX_VF_CHAINS_PER_PF;\n\tp_resc->num_txqs = QED_MAX_VF_CHAINS_PER_PF;\n\tp_resc->num_sbs = QED_MAX_VF_CHAINS_PER_PF;\n\tp_resc->num_mac_filters = QED_ETH_VF_NUM_MAC_FILTERS;\n\tp_resc->num_vlan_filters = QED_ETH_VF_NUM_VLAN_FILTERS;\n\tp_resc->num_cids = QED_ETH_VF_DEFAULT_NUM_CIDS;\n\n\treq->vfdev_info.os_type = VFPF_ACQUIRE_OS_LINUX;\n\treq->vfdev_info.fw_major = FW_MAJOR_VERSION;\n\treq->vfdev_info.fw_minor = FW_MINOR_VERSION;\n\treq->vfdev_info.fw_revision = FW_REVISION_VERSION;\n\treq->vfdev_info.fw_engineering = FW_ENGINEERING_VERSION;\n\treq->vfdev_info.eth_fp_hsi_major = ETH_HSI_VER_MAJOR;\n\treq->vfdev_info.eth_fp_hsi_minor = ETH_HSI_VER_MINOR;\n\n\t \n\treq->vfdev_info.capabilities |= VFPF_ACQUIRE_CAP_100G;\n\n\t \n\tif (p_iov->b_doorbell_bar) {\n\t\treq->vfdev_info.capabilities |= VFPF_ACQUIRE_CAP_PHYSICAL_BAR |\n\t\t\t\t\t\tVFPF_ACQUIRE_CAP_QUEUE_QIDS;\n\t\tp_resc->num_cids = QED_ETH_VF_MAX_NUM_CIDS;\n\t}\n\n\t \n\treq->bulletin_addr = p_iov->bulletin.phys;\n\treq->bulletin_size = p_iov->bulletin.size;\n\n\t \n\tqed_add_tlv(p_hwfn, &p_iov->offset,\n\t\t    CHANNEL_TLV_LIST_END, sizeof(struct channel_list_end_tlv));\n\n\twhile (!resources_acquired) {\n\t\tDP_VERBOSE(p_hwfn,\n\t\t\t   QED_MSG_IOV, \"attempting to acquire resources\\n\");\n\n\t\t \n\t\tmemset(p_iov->pf2vf_reply, 0, sizeof(union pfvf_tlvs));\n\n\t\t \n\t\trc = qed_send_msg2pf(p_hwfn, &resp->hdr.status);\n\n\t\t \n\t\tif (retry_cnt && rc == -EBUSY) {\n\t\t\tDP_VERBOSE(p_hwfn, QED_MSG_IOV,\n\t\t\t\t   \"VF retrying to acquire due to VPC timeout\\n\");\n\t\t\tretry_cnt--;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (rc)\n\t\t\tgoto exit;\n\n\t\t \n\t\tmemcpy(&p_iov->acquire_resp, resp, sizeof(p_iov->acquire_resp));\n\n\t\tattempts++;\n\n\t\tif (resp->hdr.status == PFVF_STATUS_SUCCESS) {\n\t\t\t \n\t\t\tif (!(resp->pfdev_info.capabilities &\n\t\t\t      PFVF_ACQUIRE_CAP_POST_FW_OVERRIDE)) {\n\t\t\t\t \n\t\t\t\treq->vfdev_info.capabilities |=\n\t\t\t\t    VFPF_ACQUIRE_CAP_PRE_FP_HSI;\n\t\t\t}\n\t\t\tDP_VERBOSE(p_hwfn, QED_MSG_IOV, \"resources acquired\\n\");\n\t\t\tresources_acquired = true;\n\t\t} else if (resp->hdr.status == PFVF_STATUS_NO_RESOURCE &&\n\t\t\t   attempts < VF_ACQUIRE_THRESH) {\n\t\t\tqed_vf_pf_acquire_reduce_resc(p_hwfn, p_resc,\n\t\t\t\t\t\t      &resp->resc);\n\t\t} else if (resp->hdr.status == PFVF_STATUS_NOT_SUPPORTED) {\n\t\t\tif (pfdev_info->major_fp_hsi &&\n\t\t\t    (pfdev_info->major_fp_hsi != ETH_HSI_VER_MAJOR)) {\n\t\t\t\tDP_NOTICE(p_hwfn,\n\t\t\t\t\t  \"PF uses an incompatible fastpath HSI %02x.%02x [VF requires %02x.%02x]. Please change to a VF driver using %02x.xx.\\n\",\n\t\t\t\t\t  pfdev_info->major_fp_hsi,\n\t\t\t\t\t  pfdev_info->minor_fp_hsi,\n\t\t\t\t\t  ETH_HSI_VER_MAJOR,\n\t\t\t\t\t  ETH_HSI_VER_MINOR,\n\t\t\t\t\t  pfdev_info->major_fp_hsi);\n\t\t\t\trc = -EINVAL;\n\t\t\t\tgoto exit;\n\t\t\t}\n\n\t\t\tif (!pfdev_info->major_fp_hsi) {\n\t\t\t\tif (req->vfdev_info.capabilities &\n\t\t\t\t    VFPF_ACQUIRE_CAP_PRE_FP_HSI) {\n\t\t\t\t\tDP_NOTICE(p_hwfn,\n\t\t\t\t\t\t  \"PF uses very old drivers. Please change to a VF driver using no later than 8.8.x.x.\\n\");\n\t\t\t\t\trc = -EINVAL;\n\t\t\t\t\tgoto exit;\n\t\t\t\t} else {\n\t\t\t\t\tDP_INFO(p_hwfn,\n\t\t\t\t\t\t\"PF is old - try re-acquire to see if it supports FW-version override\\n\");\n\t\t\t\t\treq->vfdev_info.capabilities |=\n\t\t\t\t\t    VFPF_ACQUIRE_CAP_PRE_FP_HSI;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t \n\t\t\tDP_NOTICE(p_hwfn, \"PF rejected acquisition by VF\\n\");\n\t\t\trc = -EINVAL;\n\t\t\tgoto exit;\n\t\t} else {\n\t\t\tDP_ERR(p_hwfn,\n\t\t\t       \"PF returned error %d to VF acquisition request\\n\",\n\t\t\t       resp->hdr.status);\n\t\t\trc = -EAGAIN;\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\t \n\tif (req->vfdev_info.capabilities & VFPF_ACQUIRE_CAP_PRE_FP_HSI)\n\t\tp_iov->b_pre_fp_hsi = true;\n\n\t \n\tif (!(resp->pfdev_info.capabilities & PFVF_ACQUIRE_CAP_QUEUE_QIDS))\n\t\tresp->resc.num_cids = resp->resc.num_rxqs + resp->resc.num_txqs;\n\n\t \n\tp_iov->bulletin.size = resp->bulletin_size;\n\n\t \n\tp_hwfn->cdev->type = resp->pfdev_info.dev_type;\n\tp_hwfn->cdev->chip_rev = resp->pfdev_info.chip_rev;\n\n\tp_hwfn->cdev->chip_num = pfdev_info->chip_num & 0xffff;\n\n\t \n\tif (IS_LEAD_HWFN(p_hwfn)) {\n\t\tif (resp->pfdev_info.capabilities & PFVF_ACQUIRE_CAP_100G) {\n\t\t\tDP_NOTICE(p_hwfn, \"100g VF\\n\");\n\t\t\tp_hwfn->cdev->num_hwfns = 2;\n\t\t}\n\t}\n\n\tif (!p_iov->b_pre_fp_hsi &&\n\t    (resp->pfdev_info.minor_fp_hsi < ETH_HSI_VER_MINOR)) {\n\t\tDP_INFO(p_hwfn,\n\t\t\t\"PF is using older fastpath HSI; %02x.%02x is configured\\n\",\n\t\t\tETH_HSI_VER_MAJOR, resp->pfdev_info.minor_fp_hsi);\n\t}\n\nexit:\n\tqed_vf_pf_req_end(p_hwfn, rc);\n\n\treturn rc;\n}\n\nu32 qed_vf_hw_bar_size(struct qed_hwfn *p_hwfn, enum BAR_ID bar_id)\n{\n\tu32 bar_size;\n\n\t \n\tif (bar_id == BAR_ID_0)\n\t\treturn 1 << 17;\n\n\t \n\tbar_size = p_hwfn->vf_iov_info->acquire_resp.pfdev_info.bar_size;\n\tif (bar_size)\n\t\treturn 1 << bar_size;\n\treturn 0;\n}\n\nint qed_vf_hw_prepare(struct qed_hwfn *p_hwfn)\n{\n\tstruct qed_hwfn *p_lead = QED_LEADING_HWFN(p_hwfn->cdev);\n\tstruct qed_vf_iov *p_iov;\n\tu32 reg;\n\tint rc;\n\n\t \n\tif (IS_LEAD_HWFN(p_hwfn))\n\t\tp_hwfn->cdev->num_hwfns = 1;\n\n\treg = PXP_VF_BAR0_ME_OPAQUE_ADDRESS;\n\tp_hwfn->hw_info.opaque_fid = (u16)REG_RD(p_hwfn, reg);\n\n\treg = PXP_VF_BAR0_ME_CONCRETE_ADDRESS;\n\tp_hwfn->hw_info.concrete_fid = REG_RD(p_hwfn, reg);\n\n\t \n\tp_iov = kzalloc(sizeof(*p_iov), GFP_KERNEL);\n\tif (!p_iov)\n\t\treturn -ENOMEM;\n\n\t \n\tif (!p_hwfn->doorbells) {\n\t\tp_hwfn->doorbells = (u8 __iomem *)p_hwfn->regview +\n\t\t\t\t\t\t  PXP_VF_BAR0_START_DQ;\n\t} else if (p_hwfn == p_lead) {\n\t\t \n\t\tp_iov->b_doorbell_bar = true;\n\t} else {\n\t\t \n\t\tif (p_lead->vf_iov_info->b_doorbell_bar)\n\t\t\tp_iov->b_doorbell_bar = true;\n\t\telse\n\t\t\tp_hwfn->doorbells = (u8 __iomem *)\n\t\t\t    p_hwfn->regview + PXP_VF_BAR0_START_DQ;\n\t}\n\n\t \n\tp_iov->vf2pf_request = dma_alloc_coherent(&p_hwfn->cdev->pdev->dev,\n\t\t\t\t\t\t  sizeof(union vfpf_tlvs),\n\t\t\t\t\t\t  &p_iov->vf2pf_request_phys,\n\t\t\t\t\t\t  GFP_KERNEL);\n\tif (!p_iov->vf2pf_request)\n\t\tgoto free_p_iov;\n\n\tp_iov->pf2vf_reply = dma_alloc_coherent(&p_hwfn->cdev->pdev->dev,\n\t\t\t\t\t\tsizeof(union pfvf_tlvs),\n\t\t\t\t\t\t&p_iov->pf2vf_reply_phys,\n\t\t\t\t\t\tGFP_KERNEL);\n\tif (!p_iov->pf2vf_reply)\n\t\tgoto free_vf2pf_request;\n\n\tDP_VERBOSE(p_hwfn,\n\t\t   QED_MSG_IOV,\n\t\t   \"VF's Request mailbox [%p virt 0x%llx phys], Response mailbox [%p virt 0x%llx phys]\\n\",\n\t\t   p_iov->vf2pf_request,\n\t\t   (u64)p_iov->vf2pf_request_phys,\n\t\t   p_iov->pf2vf_reply, (u64)p_iov->pf2vf_reply_phys);\n\n\t \n\tp_iov->bulletin.size = sizeof(struct qed_bulletin_content);\n\tp_iov->bulletin.p_virt = dma_alloc_coherent(&p_hwfn->cdev->pdev->dev,\n\t\t\t\t\t\t    p_iov->bulletin.size,\n\t\t\t\t\t\t    &p_iov->bulletin.phys,\n\t\t\t\t\t\t    GFP_KERNEL);\n\tif (!p_iov->bulletin.p_virt)\n\t\tgoto free_pf2vf_reply;\n\n\tDP_VERBOSE(p_hwfn, QED_MSG_IOV,\n\t\t   \"VF's bulletin Board [%p virt 0x%llx phys 0x%08x bytes]\\n\",\n\t\t   p_iov->bulletin.p_virt,\n\t\t   (u64)p_iov->bulletin.phys, p_iov->bulletin.size);\n\n\tmutex_init(&p_iov->mutex);\n\n\tp_hwfn->vf_iov_info = p_iov;\n\n\tp_hwfn->hw_info.personality = QED_PCI_ETH;\n\n\trc = qed_vf_pf_acquire(p_hwfn);\n\n\t \n\tif (!rc && p_iov->b_doorbell_bar &&\n\t    !qed_vf_hw_bar_size(p_hwfn, BAR_ID_1) &&\n\t    (p_hwfn->cdev->num_hwfns > 1)) {\n\t\trc = _qed_vf_pf_release(p_hwfn, false);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\tp_iov->b_doorbell_bar = false;\n\t\tp_hwfn->doorbells = (u8 __iomem *)p_hwfn->regview +\n\t\t\t\t\t\t  PXP_VF_BAR0_START_DQ;\n\t\trc = qed_vf_pf_acquire(p_hwfn);\n\t}\n\n\tDP_VERBOSE(p_hwfn, QED_MSG_IOV,\n\t\t   \"Regview [%p], Doorbell [%p], Device-doorbell [%p]\\n\",\n\t\t   p_hwfn->regview, p_hwfn->doorbells, p_hwfn->cdev->doorbells);\n\n\treturn rc;\n\nfree_pf2vf_reply:\n\tdma_free_coherent(&p_hwfn->cdev->pdev->dev,\n\t\t\t  sizeof(union pfvf_tlvs),\n\t\t\t  p_iov->pf2vf_reply, p_iov->pf2vf_reply_phys);\nfree_vf2pf_request:\n\tdma_free_coherent(&p_hwfn->cdev->pdev->dev,\n\t\t\t  sizeof(union vfpf_tlvs),\n\t\t\t  p_iov->vf2pf_request, p_iov->vf2pf_request_phys);\nfree_p_iov:\n\tkfree(p_iov);\n\n\treturn -ENOMEM;\n}\n\n#define TSTORM_QZONE_START   PXP_VF_BAR0_START_SDM_ZONE_A\n#define MSTORM_QZONE_START(dev)   (TSTORM_QZONE_START +\t\\\n\t\t\t\t   (TSTORM_QZONE_SIZE * NUM_OF_L2_QUEUES(dev)))\n\nstatic void\n__qed_vf_prep_tunn_req_tlv(struct vfpf_update_tunn_param_tlv *p_req,\n\t\t\t   struct qed_tunn_update_type *p_src,\n\t\t\t   enum qed_tunn_mode mask, u8 *p_cls)\n{\n\tif (p_src->b_update_mode) {\n\t\tp_req->tun_mode_update_mask |= BIT(mask);\n\n\t\tif (p_src->b_mode_enabled)\n\t\t\tp_req->tunn_mode |= BIT(mask);\n\t}\n\n\t*p_cls = p_src->tun_cls;\n}\n\nstatic void\nqed_vf_prep_tunn_req_tlv(struct vfpf_update_tunn_param_tlv *p_req,\n\t\t\t struct qed_tunn_update_type *p_src,\n\t\t\t enum qed_tunn_mode mask,\n\t\t\t u8 *p_cls, struct qed_tunn_update_udp_port *p_port,\n\t\t\t u8 *p_update_port, u16 *p_udp_port)\n{\n\tif (p_port->b_update_port) {\n\t\t*p_update_port = 1;\n\t\t*p_udp_port = p_port->port;\n\t}\n\n\t__qed_vf_prep_tunn_req_tlv(p_req, p_src, mask, p_cls);\n}\n\nvoid qed_vf_set_vf_start_tunn_update_param(struct qed_tunnel_info *p_tun)\n{\n\tif (p_tun->vxlan.b_mode_enabled)\n\t\tp_tun->vxlan.b_update_mode = true;\n\tif (p_tun->l2_geneve.b_mode_enabled)\n\t\tp_tun->l2_geneve.b_update_mode = true;\n\tif (p_tun->ip_geneve.b_mode_enabled)\n\t\tp_tun->ip_geneve.b_update_mode = true;\n\tif (p_tun->l2_gre.b_mode_enabled)\n\t\tp_tun->l2_gre.b_update_mode = true;\n\tif (p_tun->ip_gre.b_mode_enabled)\n\t\tp_tun->ip_gre.b_update_mode = true;\n\n\tp_tun->b_update_rx_cls = true;\n\tp_tun->b_update_tx_cls = true;\n}\n\nstatic void\n__qed_vf_update_tunn_param(struct qed_tunn_update_type *p_tun,\n\t\t\t   u16 feature_mask, u8 tunn_mode,\n\t\t\t   u8 tunn_cls, enum qed_tunn_mode val)\n{\n\tif (feature_mask & BIT(val)) {\n\t\tp_tun->b_mode_enabled = tunn_mode;\n\t\tp_tun->tun_cls = tunn_cls;\n\t} else {\n\t\tp_tun->b_mode_enabled = false;\n\t}\n}\n\nstatic void qed_vf_update_tunn_param(struct qed_hwfn *p_hwfn,\n\t\t\t\t     struct qed_tunnel_info *p_tun,\n\t\t\t\t     struct pfvf_update_tunn_param_tlv *p_resp)\n{\n\t \n\tu16 feat_mask = p_resp->tunn_feature_mask;\n\n\t__qed_vf_update_tunn_param(&p_tun->vxlan, feat_mask,\n\t\t\t\t   p_resp->vxlan_mode, p_resp->vxlan_clss,\n\t\t\t\t   QED_MODE_VXLAN_TUNN);\n\t__qed_vf_update_tunn_param(&p_tun->l2_geneve, feat_mask,\n\t\t\t\t   p_resp->l2geneve_mode,\n\t\t\t\t   p_resp->l2geneve_clss,\n\t\t\t\t   QED_MODE_L2GENEVE_TUNN);\n\t__qed_vf_update_tunn_param(&p_tun->ip_geneve, feat_mask,\n\t\t\t\t   p_resp->ipgeneve_mode,\n\t\t\t\t   p_resp->ipgeneve_clss,\n\t\t\t\t   QED_MODE_IPGENEVE_TUNN);\n\t__qed_vf_update_tunn_param(&p_tun->l2_gre, feat_mask,\n\t\t\t\t   p_resp->l2gre_mode, p_resp->l2gre_clss,\n\t\t\t\t   QED_MODE_L2GRE_TUNN);\n\t__qed_vf_update_tunn_param(&p_tun->ip_gre, feat_mask,\n\t\t\t\t   p_resp->ipgre_mode, p_resp->ipgre_clss,\n\t\t\t\t   QED_MODE_IPGRE_TUNN);\n\tp_tun->geneve_port.port = p_resp->geneve_udp_port;\n\tp_tun->vxlan_port.port = p_resp->vxlan_udp_port;\n\n\tDP_VERBOSE(p_hwfn, QED_MSG_IOV,\n\t\t   \"tunn mode: vxlan=0x%x, l2geneve=0x%x, ipgeneve=0x%x, l2gre=0x%x, ipgre=0x%x\",\n\t\t   p_tun->vxlan.b_mode_enabled, p_tun->l2_geneve.b_mode_enabled,\n\t\t   p_tun->ip_geneve.b_mode_enabled,\n\t\t   p_tun->l2_gre.b_mode_enabled, p_tun->ip_gre.b_mode_enabled);\n}\n\nint qed_vf_pf_tunnel_param_update(struct qed_hwfn *p_hwfn,\n\t\t\t\t  struct qed_tunnel_info *p_src)\n{\n\tstruct qed_tunnel_info *p_tun = &p_hwfn->cdev->tunnel;\n\tstruct qed_vf_iov *p_iov = p_hwfn->vf_iov_info;\n\tstruct pfvf_update_tunn_param_tlv *p_resp;\n\tstruct vfpf_update_tunn_param_tlv *p_req;\n\tint rc;\n\n\tp_req = qed_vf_pf_prep(p_hwfn, CHANNEL_TLV_UPDATE_TUNN_PARAM,\n\t\t\t       sizeof(*p_req));\n\n\tif (p_src->b_update_rx_cls && p_src->b_update_tx_cls)\n\t\tp_req->update_tun_cls = 1;\n\n\tqed_vf_prep_tunn_req_tlv(p_req, &p_src->vxlan, QED_MODE_VXLAN_TUNN,\n\t\t\t\t &p_req->vxlan_clss, &p_src->vxlan_port,\n\t\t\t\t &p_req->update_vxlan_port,\n\t\t\t\t &p_req->vxlan_port);\n\tqed_vf_prep_tunn_req_tlv(p_req, &p_src->l2_geneve,\n\t\t\t\t QED_MODE_L2GENEVE_TUNN,\n\t\t\t\t &p_req->l2geneve_clss, &p_src->geneve_port,\n\t\t\t\t &p_req->update_geneve_port,\n\t\t\t\t &p_req->geneve_port);\n\t__qed_vf_prep_tunn_req_tlv(p_req, &p_src->ip_geneve,\n\t\t\t\t   QED_MODE_IPGENEVE_TUNN,\n\t\t\t\t   &p_req->ipgeneve_clss);\n\t__qed_vf_prep_tunn_req_tlv(p_req, &p_src->l2_gre,\n\t\t\t\t   QED_MODE_L2GRE_TUNN, &p_req->l2gre_clss);\n\t__qed_vf_prep_tunn_req_tlv(p_req, &p_src->ip_gre,\n\t\t\t\t   QED_MODE_IPGRE_TUNN, &p_req->ipgre_clss);\n\n\t \n\tqed_add_tlv(p_hwfn, &p_iov->offset,\n\t\t    CHANNEL_TLV_LIST_END,\n\t\t    sizeof(struct channel_list_end_tlv));\n\n\tp_resp = &p_iov->pf2vf_reply->tunn_param_resp;\n\trc = qed_send_msg2pf(p_hwfn, &p_resp->hdr.status);\n\n\tif (rc)\n\t\tgoto exit;\n\n\tif (p_resp->hdr.status != PFVF_STATUS_SUCCESS) {\n\t\tDP_VERBOSE(p_hwfn, QED_MSG_IOV,\n\t\t\t   \"Failed to update tunnel parameters\\n\");\n\t\trc = -EINVAL;\n\t}\n\n\tqed_vf_update_tunn_param(p_hwfn, p_tun, p_resp);\nexit:\n\tqed_vf_pf_req_end(p_hwfn, rc);\n\treturn rc;\n}\n\nint\nqed_vf_pf_rxq_start(struct qed_hwfn *p_hwfn,\n\t\t    struct qed_queue_cid *p_cid,\n\t\t    u16 bd_max_bytes,\n\t\t    dma_addr_t bd_chain_phys_addr,\n\t\t    dma_addr_t cqe_pbl_addr,\n\t\t    u16 cqe_pbl_size, void __iomem **pp_prod)\n{\n\tstruct qed_vf_iov *p_iov = p_hwfn->vf_iov_info;\n\tstruct pfvf_start_queue_resp_tlv *resp;\n\tstruct vfpf_start_rxq_tlv *req;\n\tu8 rx_qid = p_cid->rel.queue_id;\n\tint rc;\n\n\t \n\treq = qed_vf_pf_prep(p_hwfn, CHANNEL_TLV_START_RXQ, sizeof(*req));\n\n\treq->rx_qid = rx_qid;\n\treq->cqe_pbl_addr = cqe_pbl_addr;\n\treq->cqe_pbl_size = cqe_pbl_size;\n\treq->rxq_addr = bd_chain_phys_addr;\n\treq->hw_sb = p_cid->sb_igu_id;\n\treq->sb_index = p_cid->sb_idx;\n\treq->bd_max_bytes = bd_max_bytes;\n\treq->stat_id = -1;\n\n\t \n\tif (p_iov->b_pre_fp_hsi) {\n\t\tu8 hw_qid = p_iov->acquire_resp.resc.hw_qid[rx_qid];\n\t\tu32 init_prod_val = 0;\n\n\t\t*pp_prod = (u8 __iomem *)\n\t\t    p_hwfn->regview +\n\t\t    MSTORM_QZONE_START(p_hwfn->cdev) +\n\t\t    hw_qid * MSTORM_QZONE_SIZE;\n\n\t\t \n\t\t__internal_ram_wr(p_hwfn, *pp_prod, sizeof(u32),\n\t\t\t\t  (u32 *)(&init_prod_val));\n\t}\n\n\tqed_vf_pf_add_qid(p_hwfn, p_cid);\n\n\t \n\tqed_add_tlv(p_hwfn, &p_iov->offset,\n\t\t    CHANNEL_TLV_LIST_END, sizeof(struct channel_list_end_tlv));\n\n\tresp = &p_iov->pf2vf_reply->queue_start;\n\trc = qed_send_msg2pf(p_hwfn, &resp->hdr.status);\n\tif (rc)\n\t\tgoto exit;\n\n\tif (resp->hdr.status != PFVF_STATUS_SUCCESS) {\n\t\trc = -EINVAL;\n\t\tgoto exit;\n\t}\n\n\t \n\tif (!p_iov->b_pre_fp_hsi) {\n\t\tu32 init_prod_val = 0;\n\n\t\t*pp_prod = (u8 __iomem *)p_hwfn->regview + resp->offset;\n\t\tDP_VERBOSE(p_hwfn, QED_MSG_IOV,\n\t\t\t   \"Rxq[0x%02x]: producer at %p [offset 0x%08x]\\n\",\n\t\t\t   rx_qid, *pp_prod, resp->offset);\n\n\t\t \n\t\t__internal_ram_wr(p_hwfn, *pp_prod, sizeof(u32),\n\t\t\t\t  (u32 *)&init_prod_val);\n\t}\nexit:\n\tqed_vf_pf_req_end(p_hwfn, rc);\n\n\treturn rc;\n}\n\nint qed_vf_pf_rxq_stop(struct qed_hwfn *p_hwfn,\n\t\t       struct qed_queue_cid *p_cid, bool cqe_completion)\n{\n\tstruct qed_vf_iov *p_iov = p_hwfn->vf_iov_info;\n\tstruct vfpf_stop_rxqs_tlv *req;\n\tstruct pfvf_def_resp_tlv *resp;\n\tint rc;\n\n\t \n\treq = qed_vf_pf_prep(p_hwfn, CHANNEL_TLV_STOP_RXQS, sizeof(*req));\n\n\treq->rx_qid = p_cid->rel.queue_id;\n\treq->num_rxqs = 1;\n\treq->cqe_completion = cqe_completion;\n\n\tqed_vf_pf_add_qid(p_hwfn, p_cid);\n\n\t \n\tqed_add_tlv(p_hwfn, &p_iov->offset,\n\t\t    CHANNEL_TLV_LIST_END, sizeof(struct channel_list_end_tlv));\n\n\tresp = &p_iov->pf2vf_reply->default_resp;\n\trc = qed_send_msg2pf(p_hwfn, &resp->hdr.status);\n\tif (rc)\n\t\tgoto exit;\n\n\tif (resp->hdr.status != PFVF_STATUS_SUCCESS) {\n\t\trc = -EINVAL;\n\t\tgoto exit;\n\t}\n\nexit:\n\tqed_vf_pf_req_end(p_hwfn, rc);\n\n\treturn rc;\n}\n\nint\nqed_vf_pf_txq_start(struct qed_hwfn *p_hwfn,\n\t\t    struct qed_queue_cid *p_cid,\n\t\t    dma_addr_t pbl_addr,\n\t\t    u16 pbl_size, void __iomem **pp_doorbell)\n{\n\tstruct qed_vf_iov *p_iov = p_hwfn->vf_iov_info;\n\tstruct pfvf_start_queue_resp_tlv *resp;\n\tstruct vfpf_start_txq_tlv *req;\n\tu16 qid = p_cid->rel.queue_id;\n\tint rc;\n\n\t \n\treq = qed_vf_pf_prep(p_hwfn, CHANNEL_TLV_START_TXQ, sizeof(*req));\n\n\treq->tx_qid = qid;\n\n\t \n\treq->pbl_addr = pbl_addr;\n\treq->pbl_size = pbl_size;\n\treq->hw_sb = p_cid->sb_igu_id;\n\treq->sb_index = p_cid->sb_idx;\n\n\tqed_vf_pf_add_qid(p_hwfn, p_cid);\n\n\t \n\tqed_add_tlv(p_hwfn, &p_iov->offset,\n\t\t    CHANNEL_TLV_LIST_END, sizeof(struct channel_list_end_tlv));\n\n\tresp = &p_iov->pf2vf_reply->queue_start;\n\trc = qed_send_msg2pf(p_hwfn, &resp->hdr.status);\n\tif (rc)\n\t\tgoto exit;\n\n\tif (resp->hdr.status != PFVF_STATUS_SUCCESS) {\n\t\trc = -EINVAL;\n\t\tgoto exit;\n\t}\n\n\t \n\tif (!p_iov->b_pre_fp_hsi) {\n\t\t*pp_doorbell = (u8 __iomem *)p_hwfn->doorbells + resp->offset;\n\t} else {\n\t\tu8 cid = p_iov->acquire_resp.resc.cid[qid];\n\n\t\t*pp_doorbell = (u8 __iomem *)p_hwfn->doorbells +\n\t\t\t\t\t     qed_db_addr_vf(cid,\n\t\t\t\t\t\t\t    DQ_DEMS_LEGACY);\n\t}\n\n\tDP_VERBOSE(p_hwfn, QED_MSG_IOV,\n\t\t   \"Txq[0x%02x.%02x]: doorbell at %p [offset 0x%08x]\\n\",\n\t\t   qid, p_cid->qid_usage_idx, *pp_doorbell, resp->offset);\nexit:\n\tqed_vf_pf_req_end(p_hwfn, rc);\n\n\treturn rc;\n}\n\nint qed_vf_pf_txq_stop(struct qed_hwfn *p_hwfn, struct qed_queue_cid *p_cid)\n{\n\tstruct qed_vf_iov *p_iov = p_hwfn->vf_iov_info;\n\tstruct vfpf_stop_txqs_tlv *req;\n\tstruct pfvf_def_resp_tlv *resp;\n\tint rc;\n\n\t \n\treq = qed_vf_pf_prep(p_hwfn, CHANNEL_TLV_STOP_TXQS, sizeof(*req));\n\n\treq->tx_qid = p_cid->rel.queue_id;\n\treq->num_txqs = 1;\n\n\tqed_vf_pf_add_qid(p_hwfn, p_cid);\n\n\t \n\tqed_add_tlv(p_hwfn, &p_iov->offset,\n\t\t    CHANNEL_TLV_LIST_END, sizeof(struct channel_list_end_tlv));\n\n\tresp = &p_iov->pf2vf_reply->default_resp;\n\trc = qed_send_msg2pf(p_hwfn, &resp->hdr.status);\n\tif (rc)\n\t\tgoto exit;\n\n\tif (resp->hdr.status != PFVF_STATUS_SUCCESS) {\n\t\trc = -EINVAL;\n\t\tgoto exit;\n\t}\n\nexit:\n\tqed_vf_pf_req_end(p_hwfn, rc);\n\n\treturn rc;\n}\n\nint qed_vf_pf_vport_start(struct qed_hwfn *p_hwfn,\n\t\t\t  u8 vport_id,\n\t\t\t  u16 mtu,\n\t\t\t  u8 inner_vlan_removal,\n\t\t\t  enum qed_tpa_mode tpa_mode,\n\t\t\t  u8 max_buffers_per_cqe, u8 only_untagged)\n{\n\tstruct qed_vf_iov *p_iov = p_hwfn->vf_iov_info;\n\tstruct vfpf_vport_start_tlv *req;\n\tstruct pfvf_def_resp_tlv *resp;\n\tint rc, i;\n\n\t \n\treq = qed_vf_pf_prep(p_hwfn, CHANNEL_TLV_VPORT_START, sizeof(*req));\n\n\treq->mtu = mtu;\n\treq->vport_id = vport_id;\n\treq->inner_vlan_removal = inner_vlan_removal;\n\treq->tpa_mode = tpa_mode;\n\treq->max_buffers_per_cqe = max_buffers_per_cqe;\n\treq->only_untagged = only_untagged;\n\n\t \n\tfor (i = 0; i < p_hwfn->vf_iov_info->acquire_resp.resc.num_sbs; i++) {\n\t\tstruct qed_sb_info *p_sb = p_hwfn->vf_iov_info->sbs_info[i];\n\n\t\tif (p_sb)\n\t\t\treq->sb_addr[i] = p_sb->sb_phys;\n\t}\n\n\t \n\tqed_add_tlv(p_hwfn, &p_iov->offset,\n\t\t    CHANNEL_TLV_LIST_END, sizeof(struct channel_list_end_tlv));\n\n\tresp = &p_iov->pf2vf_reply->default_resp;\n\trc = qed_send_msg2pf(p_hwfn, &resp->hdr.status);\n\tif (rc)\n\t\tgoto exit;\n\n\tif (resp->hdr.status != PFVF_STATUS_SUCCESS) {\n\t\trc = -EINVAL;\n\t\tgoto exit;\n\t}\n\nexit:\n\tqed_vf_pf_req_end(p_hwfn, rc);\n\n\treturn rc;\n}\n\nint qed_vf_pf_vport_stop(struct qed_hwfn *p_hwfn)\n{\n\tstruct qed_vf_iov *p_iov = p_hwfn->vf_iov_info;\n\tstruct pfvf_def_resp_tlv *resp = &p_iov->pf2vf_reply->default_resp;\n\tint rc;\n\n\t \n\tqed_vf_pf_prep(p_hwfn, CHANNEL_TLV_VPORT_TEARDOWN,\n\t\t       sizeof(struct vfpf_first_tlv));\n\n\t \n\tqed_add_tlv(p_hwfn, &p_iov->offset,\n\t\t    CHANNEL_TLV_LIST_END, sizeof(struct channel_list_end_tlv));\n\n\trc = qed_send_msg2pf(p_hwfn, &resp->hdr.status);\n\tif (rc)\n\t\tgoto exit;\n\n\tif (resp->hdr.status != PFVF_STATUS_SUCCESS) {\n\t\trc = -EINVAL;\n\t\tgoto exit;\n\t}\n\nexit:\n\tqed_vf_pf_req_end(p_hwfn, rc);\n\n\treturn rc;\n}\n\nstatic bool\nqed_vf_handle_vp_update_is_needed(struct qed_hwfn *p_hwfn,\n\t\t\t\t  struct qed_sp_vport_update_params *p_data,\n\t\t\t\t  u16 tlv)\n{\n\tswitch (tlv) {\n\tcase CHANNEL_TLV_VPORT_UPDATE_ACTIVATE:\n\t\treturn !!(p_data->update_vport_active_rx_flg ||\n\t\t\t  p_data->update_vport_active_tx_flg);\n\tcase CHANNEL_TLV_VPORT_UPDATE_TX_SWITCH:\n\t\treturn !!p_data->update_tx_switching_flg;\n\tcase CHANNEL_TLV_VPORT_UPDATE_VLAN_STRIP:\n\t\treturn !!p_data->update_inner_vlan_removal_flg;\n\tcase CHANNEL_TLV_VPORT_UPDATE_ACCEPT_ANY_VLAN:\n\t\treturn !!p_data->update_accept_any_vlan_flg;\n\tcase CHANNEL_TLV_VPORT_UPDATE_MCAST:\n\t\treturn !!p_data->update_approx_mcast_flg;\n\tcase CHANNEL_TLV_VPORT_UPDATE_ACCEPT_PARAM:\n\t\treturn !!(p_data->accept_flags.update_rx_mode_config ||\n\t\t\t  p_data->accept_flags.update_tx_mode_config);\n\tcase CHANNEL_TLV_VPORT_UPDATE_RSS:\n\t\treturn !!p_data->rss_params;\n\tcase CHANNEL_TLV_VPORT_UPDATE_SGE_TPA:\n\t\treturn !!p_data->sge_tpa_params;\n\tdefault:\n\t\tDP_INFO(p_hwfn, \"Unexpected vport-update TLV[%d]\\n\",\n\t\t\ttlv);\n\t\treturn false;\n\t}\n}\n\nstatic void\nqed_vf_handle_vp_update_tlvs_resp(struct qed_hwfn *p_hwfn,\n\t\t\t\t  struct qed_sp_vport_update_params *p_data)\n{\n\tstruct qed_vf_iov *p_iov = p_hwfn->vf_iov_info;\n\tstruct pfvf_def_resp_tlv *p_resp;\n\tu16 tlv;\n\n\tfor (tlv = CHANNEL_TLV_VPORT_UPDATE_ACTIVATE;\n\t     tlv < CHANNEL_TLV_VPORT_UPDATE_MAX; tlv++) {\n\t\tif (!qed_vf_handle_vp_update_is_needed(p_hwfn, p_data, tlv))\n\t\t\tcontinue;\n\n\t\tp_resp = (struct pfvf_def_resp_tlv *)\n\t\t\t qed_iov_search_list_tlvs(p_hwfn, p_iov->pf2vf_reply,\n\t\t\t\t\t\t  tlv);\n\t\tif (p_resp && p_resp->hdr.status)\n\t\t\tDP_VERBOSE(p_hwfn, QED_MSG_IOV,\n\t\t\t\t   \"TLV[%d] Configuration %s\\n\",\n\t\t\t\t   tlv,\n\t\t\t\t   (p_resp && p_resp->hdr.status) ? \"succeeded\"\n\t\t\t\t\t\t\t\t  : \"failed\");\n\t}\n}\n\nint qed_vf_pf_vport_update(struct qed_hwfn *p_hwfn,\n\t\t\t   struct qed_sp_vport_update_params *p_params)\n{\n\tstruct qed_vf_iov *p_iov = p_hwfn->vf_iov_info;\n\tstruct vfpf_vport_update_tlv *req;\n\tstruct pfvf_def_resp_tlv *resp;\n\tu8 update_rx, update_tx;\n\tu16 size, tlv;\n\tint rc;\n\n\tresp = &p_iov->pf2vf_reply->default_resp;\n\n\tupdate_rx = p_params->update_vport_active_rx_flg;\n\tupdate_tx = p_params->update_vport_active_tx_flg;\n\n\t \n\tqed_vf_pf_prep(p_hwfn, CHANNEL_TLV_VPORT_UPDATE, sizeof(*req));\n\n\t \n\tif (update_rx || update_tx) {\n\t\tstruct vfpf_vport_update_activate_tlv *p_act_tlv;\n\n\t\tsize = sizeof(struct vfpf_vport_update_activate_tlv);\n\t\tp_act_tlv = qed_add_tlv(p_hwfn, &p_iov->offset,\n\t\t\t\t\tCHANNEL_TLV_VPORT_UPDATE_ACTIVATE,\n\t\t\t\t\tsize);\n\n\t\tif (update_rx) {\n\t\t\tp_act_tlv->update_rx = update_rx;\n\t\t\tp_act_tlv->active_rx = p_params->vport_active_rx_flg;\n\t\t}\n\n\t\tif (update_tx) {\n\t\t\tp_act_tlv->update_tx = update_tx;\n\t\t\tp_act_tlv->active_tx = p_params->vport_active_tx_flg;\n\t\t}\n\t}\n\n\tif (p_params->update_tx_switching_flg) {\n\t\tstruct vfpf_vport_update_tx_switch_tlv *p_tx_switch_tlv;\n\n\t\tsize = sizeof(struct vfpf_vport_update_tx_switch_tlv);\n\t\ttlv = CHANNEL_TLV_VPORT_UPDATE_TX_SWITCH;\n\t\tp_tx_switch_tlv = qed_add_tlv(p_hwfn, &p_iov->offset,\n\t\t\t\t\t      tlv, size);\n\n\t\tp_tx_switch_tlv->tx_switching = p_params->tx_switching_flg;\n\t}\n\n\tif (p_params->update_approx_mcast_flg) {\n\t\tstruct vfpf_vport_update_mcast_bin_tlv *p_mcast_tlv;\n\n\t\tsize = sizeof(struct vfpf_vport_update_mcast_bin_tlv);\n\t\tp_mcast_tlv = qed_add_tlv(p_hwfn, &p_iov->offset,\n\t\t\t\t\t  CHANNEL_TLV_VPORT_UPDATE_MCAST, size);\n\n\t\tmemcpy(p_mcast_tlv->bins, p_params->bins,\n\t\t       sizeof(u32) * ETH_MULTICAST_MAC_BINS_IN_REGS);\n\t}\n\n\tupdate_rx = p_params->accept_flags.update_rx_mode_config;\n\tupdate_tx = p_params->accept_flags.update_tx_mode_config;\n\n\tif (update_rx || update_tx) {\n\t\tstruct vfpf_vport_update_accept_param_tlv *p_accept_tlv;\n\n\t\ttlv = CHANNEL_TLV_VPORT_UPDATE_ACCEPT_PARAM;\n\t\tsize = sizeof(struct vfpf_vport_update_accept_param_tlv);\n\t\tp_accept_tlv = qed_add_tlv(p_hwfn, &p_iov->offset, tlv, size);\n\n\t\tif (update_rx) {\n\t\t\tp_accept_tlv->update_rx_mode = update_rx;\n\t\t\tp_accept_tlv->rx_accept_filter =\n\t\t\t    p_params->accept_flags.rx_accept_filter;\n\t\t}\n\n\t\tif (update_tx) {\n\t\t\tp_accept_tlv->update_tx_mode = update_tx;\n\t\t\tp_accept_tlv->tx_accept_filter =\n\t\t\t    p_params->accept_flags.tx_accept_filter;\n\t\t}\n\t}\n\n\tif (p_params->rss_params) {\n\t\tstruct qed_rss_params *rss_params = p_params->rss_params;\n\t\tstruct vfpf_vport_update_rss_tlv *p_rss_tlv;\n\t\tint i, table_size;\n\n\t\tsize = sizeof(struct vfpf_vport_update_rss_tlv);\n\t\tp_rss_tlv = qed_add_tlv(p_hwfn,\n\t\t\t\t\t&p_iov->offset,\n\t\t\t\t\tCHANNEL_TLV_VPORT_UPDATE_RSS, size);\n\n\t\tif (rss_params->update_rss_config)\n\t\t\tp_rss_tlv->update_rss_flags |=\n\t\t\t    VFPF_UPDATE_RSS_CONFIG_FLAG;\n\t\tif (rss_params->update_rss_capabilities)\n\t\t\tp_rss_tlv->update_rss_flags |=\n\t\t\t    VFPF_UPDATE_RSS_CAPS_FLAG;\n\t\tif (rss_params->update_rss_ind_table)\n\t\t\tp_rss_tlv->update_rss_flags |=\n\t\t\t    VFPF_UPDATE_RSS_IND_TABLE_FLAG;\n\t\tif (rss_params->update_rss_key)\n\t\t\tp_rss_tlv->update_rss_flags |= VFPF_UPDATE_RSS_KEY_FLAG;\n\n\t\tp_rss_tlv->rss_enable = rss_params->rss_enable;\n\t\tp_rss_tlv->rss_caps = rss_params->rss_caps;\n\t\tp_rss_tlv->rss_table_size_log = rss_params->rss_table_size_log;\n\n\t\ttable_size = min_t(int, T_ETH_INDIRECTION_TABLE_SIZE,\n\t\t\t\t   1 << p_rss_tlv->rss_table_size_log);\n\t\tfor (i = 0; i < table_size; i++) {\n\t\t\tstruct qed_queue_cid *p_queue;\n\n\t\t\tp_queue = rss_params->rss_ind_table[i];\n\t\t\tp_rss_tlv->rss_ind_table[i] = p_queue->rel.queue_id;\n\t\t}\n\t\tmemcpy(p_rss_tlv->rss_key, rss_params->rss_key,\n\t\t       sizeof(rss_params->rss_key));\n\t}\n\n\tif (p_params->update_accept_any_vlan_flg) {\n\t\tstruct vfpf_vport_update_accept_any_vlan_tlv *p_any_vlan_tlv;\n\n\t\tsize = sizeof(struct vfpf_vport_update_accept_any_vlan_tlv);\n\t\ttlv = CHANNEL_TLV_VPORT_UPDATE_ACCEPT_ANY_VLAN;\n\t\tp_any_vlan_tlv = qed_add_tlv(p_hwfn, &p_iov->offset, tlv, size);\n\n\t\tp_any_vlan_tlv->accept_any_vlan = p_params->accept_any_vlan;\n\t\tp_any_vlan_tlv->update_accept_any_vlan_flg =\n\t\t    p_params->update_accept_any_vlan_flg;\n\t}\n\n\t \n\tqed_add_tlv(p_hwfn, &p_iov->offset,\n\t\t    CHANNEL_TLV_LIST_END, sizeof(struct channel_list_end_tlv));\n\n\trc = qed_send_msg2pf(p_hwfn, &resp->hdr.status);\n\tif (rc)\n\t\tgoto exit;\n\n\tif (resp->hdr.status != PFVF_STATUS_SUCCESS) {\n\t\trc = -EINVAL;\n\t\tgoto exit;\n\t}\n\n\tqed_vf_handle_vp_update_tlvs_resp(p_hwfn, p_params);\n\nexit:\n\tqed_vf_pf_req_end(p_hwfn, rc);\n\n\treturn rc;\n}\n\nint qed_vf_pf_reset(struct qed_hwfn *p_hwfn)\n{\n\tstruct qed_vf_iov *p_iov = p_hwfn->vf_iov_info;\n\tstruct pfvf_def_resp_tlv *resp;\n\tstruct vfpf_first_tlv *req;\n\tint rc;\n\n\t \n\treq = qed_vf_pf_prep(p_hwfn, CHANNEL_TLV_CLOSE, sizeof(*req));\n\n\t \n\tqed_add_tlv(p_hwfn, &p_iov->offset,\n\t\t    CHANNEL_TLV_LIST_END, sizeof(struct channel_list_end_tlv));\n\n\tresp = &p_iov->pf2vf_reply->default_resp;\n\trc = qed_send_msg2pf(p_hwfn, &resp->hdr.status);\n\tif (rc)\n\t\tgoto exit;\n\n\tif (resp->hdr.status != PFVF_STATUS_SUCCESS) {\n\t\trc = -EAGAIN;\n\t\tgoto exit;\n\t}\n\n\tp_hwfn->b_int_enabled = 0;\n\nexit:\n\tqed_vf_pf_req_end(p_hwfn, rc);\n\n\treturn rc;\n}\n\nvoid qed_vf_pf_filter_mcast(struct qed_hwfn *p_hwfn,\n\t\t\t    struct qed_filter_mcast *p_filter_cmd)\n{\n\tstruct qed_sp_vport_update_params sp_params;\n\tint i;\n\n\tmemset(&sp_params, 0, sizeof(sp_params));\n\tsp_params.update_approx_mcast_flg = 1;\n\n\tif (p_filter_cmd->opcode == QED_FILTER_ADD) {\n\t\tfor (i = 0; i < p_filter_cmd->num_mc_addrs; i++) {\n\t\t\tu32 bit;\n\n\t\t\tbit = qed_mcast_bin_from_mac(p_filter_cmd->mac[i]);\n\t\t\tsp_params.bins[bit / 32] |= 1 << (bit % 32);\n\t\t}\n\t}\n\n\tqed_vf_pf_vport_update(p_hwfn, &sp_params);\n}\n\nint qed_vf_pf_filter_ucast(struct qed_hwfn *p_hwfn,\n\t\t\t   struct qed_filter_ucast *p_ucast)\n{\n\tstruct qed_vf_iov *p_iov = p_hwfn->vf_iov_info;\n\tstruct vfpf_ucast_filter_tlv *req;\n\tstruct pfvf_def_resp_tlv *resp;\n\tint rc;\n\n\t \n\treq = qed_vf_pf_prep(p_hwfn, CHANNEL_TLV_UCAST_FILTER, sizeof(*req));\n\treq->opcode = (u8)p_ucast->opcode;\n\treq->type = (u8)p_ucast->type;\n\tmemcpy(req->mac, p_ucast->mac, ETH_ALEN);\n\treq->vlan = p_ucast->vlan;\n\n\t \n\tqed_add_tlv(p_hwfn, &p_iov->offset,\n\t\t    CHANNEL_TLV_LIST_END, sizeof(struct channel_list_end_tlv));\n\n\tresp = &p_iov->pf2vf_reply->default_resp;\n\trc = qed_send_msg2pf(p_hwfn, &resp->hdr.status);\n\tif (rc)\n\t\tgoto exit;\n\n\tif (resp->hdr.status != PFVF_STATUS_SUCCESS) {\n\t\trc = -EAGAIN;\n\t\tgoto exit;\n\t}\n\nexit:\n\tqed_vf_pf_req_end(p_hwfn, rc);\n\n\treturn rc;\n}\n\nint qed_vf_pf_int_cleanup(struct qed_hwfn *p_hwfn)\n{\n\tstruct qed_vf_iov *p_iov = p_hwfn->vf_iov_info;\n\tstruct pfvf_def_resp_tlv *resp = &p_iov->pf2vf_reply->default_resp;\n\tint rc;\n\n\t \n\tqed_vf_pf_prep(p_hwfn, CHANNEL_TLV_INT_CLEANUP,\n\t\t       sizeof(struct vfpf_first_tlv));\n\n\t \n\tqed_add_tlv(p_hwfn, &p_iov->offset,\n\t\t    CHANNEL_TLV_LIST_END, sizeof(struct channel_list_end_tlv));\n\n\trc = qed_send_msg2pf(p_hwfn, &resp->hdr.status);\n\tif (rc)\n\t\tgoto exit;\n\n\tif (resp->hdr.status != PFVF_STATUS_SUCCESS) {\n\t\trc = -EINVAL;\n\t\tgoto exit;\n\t}\n\nexit:\n\tqed_vf_pf_req_end(p_hwfn, rc);\n\n\treturn rc;\n}\n\nint qed_vf_pf_get_coalesce(struct qed_hwfn *p_hwfn,\n\t\t\t   u16 *p_coal, struct qed_queue_cid *p_cid)\n{\n\tstruct qed_vf_iov *p_iov = p_hwfn->vf_iov_info;\n\tstruct pfvf_read_coal_resp_tlv *resp;\n\tstruct vfpf_read_coal_req_tlv *req;\n\tint rc;\n\n\t \n\treq = qed_vf_pf_prep(p_hwfn, CHANNEL_TLV_COALESCE_READ, sizeof(*req));\n\treq->qid = p_cid->rel.queue_id;\n\treq->is_rx = p_cid->b_is_rx ? 1 : 0;\n\n\tqed_add_tlv(p_hwfn, &p_iov->offset, CHANNEL_TLV_LIST_END,\n\t\t    sizeof(struct channel_list_end_tlv));\n\tresp = &p_iov->pf2vf_reply->read_coal_resp;\n\n\trc = qed_send_msg2pf(p_hwfn, &resp->hdr.status);\n\tif (rc)\n\t\tgoto exit;\n\n\tif (resp->hdr.status != PFVF_STATUS_SUCCESS)\n\t\tgoto exit;\n\n\t*p_coal = resp->coal;\nexit:\n\tqed_vf_pf_req_end(p_hwfn, rc);\n\n\treturn rc;\n}\n\nint\nqed_vf_pf_bulletin_update_mac(struct qed_hwfn *p_hwfn,\n\t\t\t      const u8 *p_mac)\n{\n\tstruct qed_vf_iov *p_iov = p_hwfn->vf_iov_info;\n\tstruct vfpf_bulletin_update_mac_tlv *p_req;\n\tstruct pfvf_def_resp_tlv *p_resp;\n\tint rc;\n\n\tif (!p_mac)\n\t\treturn -EINVAL;\n\n\t \n\tp_req = qed_vf_pf_prep(p_hwfn, CHANNEL_TLV_BULLETIN_UPDATE_MAC,\n\t\t\t       sizeof(*p_req));\n\tether_addr_copy(p_req->mac, p_mac);\n\tDP_VERBOSE(p_hwfn, QED_MSG_IOV,\n\t\t   \"Requesting bulletin update for MAC[%pM]\\n\", p_mac);\n\n\t \n\tqed_add_tlv(p_hwfn, &p_iov->offset, CHANNEL_TLV_LIST_END,\n\t\t    sizeof(struct channel_list_end_tlv));\n\n\tp_resp = &p_iov->pf2vf_reply->default_resp;\n\trc = qed_send_msg2pf(p_hwfn, &p_resp->hdr.status);\n\tqed_vf_pf_req_end(p_hwfn, rc);\n\treturn rc;\n}\n\nint\nqed_vf_pf_set_coalesce(struct qed_hwfn *p_hwfn,\n\t\t       u16 rx_coal, u16 tx_coal, struct qed_queue_cid *p_cid)\n{\n\tstruct qed_vf_iov *p_iov = p_hwfn->vf_iov_info;\n\tstruct vfpf_update_coalesce *req;\n\tstruct pfvf_def_resp_tlv *resp;\n\tint rc;\n\n\t \n\treq = qed_vf_pf_prep(p_hwfn, CHANNEL_TLV_COALESCE_UPDATE, sizeof(*req));\n\n\treq->rx_coal = rx_coal;\n\treq->tx_coal = tx_coal;\n\treq->qid = p_cid->rel.queue_id;\n\n\tDP_VERBOSE(p_hwfn,\n\t\t   QED_MSG_IOV,\n\t\t   \"Setting coalesce rx_coal = %d, tx_coal = %d at queue = %d\\n\",\n\t\t   rx_coal, tx_coal, req->qid);\n\n\t \n\tqed_add_tlv(p_hwfn, &p_iov->offset, CHANNEL_TLV_LIST_END,\n\t\t    sizeof(struct channel_list_end_tlv));\n\n\tresp = &p_iov->pf2vf_reply->default_resp;\n\trc = qed_send_msg2pf(p_hwfn, &resp->hdr.status);\n\tif (rc)\n\t\tgoto exit;\n\n\tif (resp->hdr.status != PFVF_STATUS_SUCCESS)\n\t\tgoto exit;\n\n\tif (rx_coal)\n\t\tp_hwfn->cdev->rx_coalesce_usecs = rx_coal;\n\n\tif (tx_coal)\n\t\tp_hwfn->cdev->tx_coalesce_usecs = tx_coal;\n\nexit:\n\tqed_vf_pf_req_end(p_hwfn, rc);\n\treturn rc;\n}\n\nu16 qed_vf_get_igu_sb_id(struct qed_hwfn *p_hwfn, u16 sb_id)\n{\n\tstruct qed_vf_iov *p_iov = p_hwfn->vf_iov_info;\n\n\tif (!p_iov) {\n\t\tDP_NOTICE(p_hwfn, \"vf_sriov_info isn't initialized\\n\");\n\t\treturn 0;\n\t}\n\n\treturn p_iov->acquire_resp.resc.hw_sbs[sb_id].hw_sb_id;\n}\n\nvoid qed_vf_set_sb_info(struct qed_hwfn *p_hwfn,\n\t\t\tu16 sb_id, struct qed_sb_info *p_sb)\n{\n\tstruct qed_vf_iov *p_iov = p_hwfn->vf_iov_info;\n\n\tif (!p_iov) {\n\t\tDP_NOTICE(p_hwfn, \"vf_sriov_info isn't initialized\\n\");\n\t\treturn;\n\t}\n\n\tif (sb_id >= PFVF_MAX_SBS_PER_VF) {\n\t\tDP_NOTICE(p_hwfn, \"Can't configure SB %04x\\n\", sb_id);\n\t\treturn;\n\t}\n\n\tp_iov->sbs_info[sb_id] = p_sb;\n}\n\nint qed_vf_read_bulletin(struct qed_hwfn *p_hwfn, u8 *p_change)\n{\n\tstruct qed_vf_iov *p_iov = p_hwfn->vf_iov_info;\n\tstruct qed_bulletin_content shadow;\n\tu32 crc, crc_size;\n\n\tcrc_size = sizeof(p_iov->bulletin.p_virt->crc);\n\t*p_change = 0;\n\n\t \n\tmemcpy(&shadow, p_iov->bulletin.p_virt, p_iov->bulletin.size);\n\n\t \n\tif (shadow.version == p_iov->bulletin_shadow.version)\n\t\treturn 0;\n\n\t \n\tcrc = crc32(0, (u8 *)&shadow + crc_size,\n\t\t    p_iov->bulletin.size - crc_size);\n\tif (crc != shadow.crc)\n\t\treturn -EAGAIN;\n\n\t \n\tmemcpy(&p_iov->bulletin_shadow, &shadow, p_iov->bulletin.size);\n\n\tDP_VERBOSE(p_hwfn, QED_MSG_IOV,\n\t\t   \"Read a bulletin update %08x\\n\", shadow.version);\n\n\t*p_change = 1;\n\n\treturn 0;\n}\n\nvoid __qed_vf_get_link_params(struct qed_hwfn *p_hwfn,\n\t\t\t      struct qed_mcp_link_params *p_params,\n\t\t\t      struct qed_bulletin_content *p_bulletin)\n{\n\tmemset(p_params, 0, sizeof(*p_params));\n\n\tp_params->speed.autoneg = p_bulletin->req_autoneg;\n\tp_params->speed.advertised_speeds = p_bulletin->req_adv_speed;\n\tp_params->speed.forced_speed = p_bulletin->req_forced_speed;\n\tp_params->pause.autoneg = p_bulletin->req_autoneg_pause;\n\tp_params->pause.forced_rx = p_bulletin->req_forced_rx;\n\tp_params->pause.forced_tx = p_bulletin->req_forced_tx;\n\tp_params->loopback_mode = p_bulletin->req_loopback;\n}\n\nvoid qed_vf_get_link_params(struct qed_hwfn *p_hwfn,\n\t\t\t    struct qed_mcp_link_params *params)\n{\n\t__qed_vf_get_link_params(p_hwfn, params,\n\t\t\t\t &(p_hwfn->vf_iov_info->bulletin_shadow));\n}\n\nvoid __qed_vf_get_link_state(struct qed_hwfn *p_hwfn,\n\t\t\t     struct qed_mcp_link_state *p_link,\n\t\t\t     struct qed_bulletin_content *p_bulletin)\n{\n\tmemset(p_link, 0, sizeof(*p_link));\n\n\tp_link->link_up = p_bulletin->link_up;\n\tp_link->speed = p_bulletin->speed;\n\tp_link->full_duplex = p_bulletin->full_duplex;\n\tp_link->an = p_bulletin->autoneg;\n\tp_link->an_complete = p_bulletin->autoneg_complete;\n\tp_link->parallel_detection = p_bulletin->parallel_detection;\n\tp_link->pfc_enabled = p_bulletin->pfc_enabled;\n\tp_link->partner_adv_speed = p_bulletin->partner_adv_speed;\n\tp_link->partner_tx_flow_ctrl_en = p_bulletin->partner_tx_flow_ctrl_en;\n\tp_link->partner_rx_flow_ctrl_en = p_bulletin->partner_rx_flow_ctrl_en;\n\tp_link->partner_adv_pause = p_bulletin->partner_adv_pause;\n\tp_link->sfp_tx_fault = p_bulletin->sfp_tx_fault;\n}\n\nvoid qed_vf_get_link_state(struct qed_hwfn *p_hwfn,\n\t\t\t   struct qed_mcp_link_state *link)\n{\n\t__qed_vf_get_link_state(p_hwfn, link,\n\t\t\t\t&(p_hwfn->vf_iov_info->bulletin_shadow));\n}\n\nvoid __qed_vf_get_link_caps(struct qed_hwfn *p_hwfn,\n\t\t\t    struct qed_mcp_link_capabilities *p_link_caps,\n\t\t\t    struct qed_bulletin_content *p_bulletin)\n{\n\tmemset(p_link_caps, 0, sizeof(*p_link_caps));\n\tp_link_caps->speed_capabilities = p_bulletin->capability_speed;\n}\n\nvoid qed_vf_get_link_caps(struct qed_hwfn *p_hwfn,\n\t\t\t  struct qed_mcp_link_capabilities *p_link_caps)\n{\n\t__qed_vf_get_link_caps(p_hwfn, p_link_caps,\n\t\t\t       &(p_hwfn->vf_iov_info->bulletin_shadow));\n}\n\nvoid qed_vf_get_num_rxqs(struct qed_hwfn *p_hwfn, u8 *num_rxqs)\n{\n\t*num_rxqs = p_hwfn->vf_iov_info->acquire_resp.resc.num_rxqs;\n}\n\nvoid qed_vf_get_num_txqs(struct qed_hwfn *p_hwfn, u8 *num_txqs)\n{\n\t*num_txqs = p_hwfn->vf_iov_info->acquire_resp.resc.num_txqs;\n}\n\nvoid qed_vf_get_num_cids(struct qed_hwfn *p_hwfn, u8 *num_cids)\n{\n\t*num_cids = p_hwfn->vf_iov_info->acquire_resp.resc.num_cids;\n}\n\nvoid qed_vf_get_port_mac(struct qed_hwfn *p_hwfn, u8 *port_mac)\n{\n\tmemcpy(port_mac,\n\t       p_hwfn->vf_iov_info->acquire_resp.pfdev_info.port_mac, ETH_ALEN);\n}\n\nvoid qed_vf_get_num_vlan_filters(struct qed_hwfn *p_hwfn, u8 *num_vlan_filters)\n{\n\tstruct qed_vf_iov *p_vf;\n\n\tp_vf = p_hwfn->vf_iov_info;\n\t*num_vlan_filters = p_vf->acquire_resp.resc.num_vlan_filters;\n}\n\nvoid qed_vf_get_num_mac_filters(struct qed_hwfn *p_hwfn, u8 *num_mac_filters)\n{\n\tstruct qed_vf_iov *p_vf = p_hwfn->vf_iov_info;\n\n\t*num_mac_filters = p_vf->acquire_resp.resc.num_mac_filters;\n}\n\nbool qed_vf_check_mac(struct qed_hwfn *p_hwfn, u8 *mac)\n{\n\tstruct qed_bulletin_content *bulletin;\n\n\tbulletin = &p_hwfn->vf_iov_info->bulletin_shadow;\n\tif (!(bulletin->valid_bitmap & (1 << MAC_ADDR_FORCED)))\n\t\treturn true;\n\n\t \n\tif (ether_addr_equal(bulletin->mac, mac))\n\t\treturn false;\n\n\treturn false;\n}\n\nstatic bool qed_vf_bulletin_get_forced_mac(struct qed_hwfn *hwfn,\n\t\t\t\t\t   u8 *dst_mac, u8 *p_is_forced)\n{\n\tstruct qed_bulletin_content *bulletin;\n\n\tbulletin = &hwfn->vf_iov_info->bulletin_shadow;\n\n\tif (bulletin->valid_bitmap & (1 << MAC_ADDR_FORCED)) {\n\t\tif (p_is_forced)\n\t\t\t*p_is_forced = 1;\n\t} else if (bulletin->valid_bitmap & (1 << VFPF_BULLETIN_MAC_ADDR)) {\n\t\tif (p_is_forced)\n\t\t\t*p_is_forced = 0;\n\t} else {\n\t\treturn false;\n\t}\n\n\tether_addr_copy(dst_mac, bulletin->mac);\n\n\treturn true;\n}\n\nstatic void\nqed_vf_bulletin_get_udp_ports(struct qed_hwfn *p_hwfn,\n\t\t\t      u16 *p_vxlan_port, u16 *p_geneve_port)\n{\n\tstruct qed_bulletin_content *p_bulletin;\n\n\tp_bulletin = &p_hwfn->vf_iov_info->bulletin_shadow;\n\n\t*p_vxlan_port = p_bulletin->vxlan_udp_port;\n\t*p_geneve_port = p_bulletin->geneve_udp_port;\n}\n\nvoid qed_vf_get_fw_version(struct qed_hwfn *p_hwfn,\n\t\t\t   u16 *fw_major, u16 *fw_minor,\n\t\t\t   u16 *fw_rev, u16 *fw_eng)\n{\n\tstruct pf_vf_pfdev_info *info;\n\n\tinfo = &p_hwfn->vf_iov_info->acquire_resp.pfdev_info;\n\n\t*fw_major = info->fw_major;\n\t*fw_minor = info->fw_minor;\n\t*fw_rev = info->fw_rev;\n\t*fw_eng = info->fw_eng;\n}\n\nstatic void qed_handle_bulletin_change(struct qed_hwfn *hwfn)\n{\n\tstruct qed_eth_cb_ops *ops = hwfn->cdev->protocol_ops.eth;\n\tu8 mac[ETH_ALEN], is_mac_exist, is_mac_forced;\n\tvoid *cookie = hwfn->cdev->ops_cookie;\n\tu16 vxlan_port, geneve_port;\n\n\tqed_vf_bulletin_get_udp_ports(hwfn, &vxlan_port, &geneve_port);\n\tis_mac_exist = qed_vf_bulletin_get_forced_mac(hwfn, mac,\n\t\t\t\t\t\t      &is_mac_forced);\n\tif (is_mac_exist && cookie)\n\t\tops->force_mac(cookie, mac, !!is_mac_forced);\n\n\tops->ports_update(cookie, vxlan_port, geneve_port);\n\n\t \n\tqed_link_update(hwfn, NULL);\n}\n\nvoid qed_iov_vf_task(struct work_struct *work)\n{\n\tstruct qed_hwfn *hwfn = container_of(work, struct qed_hwfn,\n\t\t\t\t\t     iov_task.work);\n\tu8 change = 0;\n\n\tif (test_and_clear_bit(QED_IOV_WQ_STOP_WQ_FLAG, &hwfn->iov_task_flags))\n\t\treturn;\n\n\t \n\tqed_vf_read_bulletin(hwfn, &change);\n\tif (test_and_clear_bit(QED_IOV_WQ_VF_FORCE_LINK_QUERY_FLAG,\n\t\t\t       &hwfn->iov_task_flags))\n\t\tchange = 1;\n\tif (change)\n\t\tqed_handle_bulletin_change(hwfn);\n\n\t \n\tqueue_delayed_work(hwfn->iov_wq, &hwfn->iov_task, HZ);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}