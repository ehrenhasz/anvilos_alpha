{
  "module_name": "qed_init_ops.c",
  "hash_id": "b795e801f32ca251682571f49ee35e3f105dcd1353678a0df841def7642d83fc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/qlogic/qed/qed_init_ops.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/io.h>\n#include <linux/delay.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include \"qed.h\"\n#include \"qed_hsi.h\"\n#include \"qed_hw.h\"\n#include \"qed_init_ops.h\"\n#include \"qed_iro_hsi.h\"\n#include \"qed_reg_addr.h\"\n#include \"qed_sriov.h\"\n\n#define QED_INIT_MAX_POLL_COUNT 100\n#define QED_INIT_POLL_PERIOD_US 500\n\nstatic u32 pxp_global_win[] = {\n\t0,\n\t0,\n\t0x1c02,  \n\t0x1c80,  \n\t0x1d00,  \n\t0x1d01,  \n\t0x1d02,  \n\t0x1d80,  \n\t0x1d81,  \n\t0x1d82,  \n\t0x1e00,  \n\t0x1e01,  \n\t0x1e80,  \n\t0x1f00,  \n\t0x1c08,  \n\t0,\n\t0,\n\t0,\n\t0,\n};\n\n \nstatic const u32 iro_arr[] = {\n\t0x00000000, 0x00000000, 0x00080000,\n\t0x00004478, 0x00000008, 0x00080000,\n\t0x00003288, 0x00000088, 0x00880000,\n\t0x000058a8, 0x00000020, 0x00200000,\n\t0x00003188, 0x00000008, 0x00080000,\n\t0x00000b00, 0x00000008, 0x00040000,\n\t0x00000a80, 0x00000008, 0x00040000,\n\t0x00000000, 0x00000008, 0x00020000,\n\t0x00000080, 0x00000008, 0x00040000,\n\t0x00000084, 0x00000008, 0x00020000,\n\t0x00005798, 0x00000004, 0x00040000,\n\t0x00004e50, 0x00000000, 0x00780000,\n\t0x00003e40, 0x00000000, 0x00780000,\n\t0x00004500, 0x00000000, 0x00780000,\n\t0x00003210, 0x00000000, 0x00780000,\n\t0x00003b50, 0x00000000, 0x00780000,\n\t0x00007f58, 0x00000000, 0x00780000,\n\t0x00005fd8, 0x00000000, 0x00080000,\n\t0x00007100, 0x00000000, 0x00080000,\n\t0x0000af20, 0x00000000, 0x00080000,\n\t0x00004398, 0x00000000, 0x00080000,\n\t0x0000a5a0, 0x00000000, 0x00080000,\n\t0x0000bde8, 0x00000000, 0x00080000,\n\t0x00000020, 0x00000004, 0x00040000,\n\t0x00005688, 0x00000010, 0x00100000,\n\t0x0000c210, 0x00000030, 0x00300000,\n\t0x0000b108, 0x00000038, 0x00380000,\n\t0x00003d20, 0x00000080, 0x00400000,\n\t0x0000bf60, 0x00000000, 0x00040000,\n\t0x00004560, 0x00040080, 0x00040000,\n\t0x000001f8, 0x00000004, 0x00040000,\n\t0x00003d60, 0x00000080, 0x00200000,\n\t0x00008960, 0x00000040, 0x00300000,\n\t0x0000e840, 0x00000060, 0x00600000,\n\t0x00004698, 0x00000080, 0x00380000,\n\t0x000107b8, 0x000000c0, 0x00c00000,\n\t0x000001f8, 0x00000002, 0x00020000,\n\t0x0000a260, 0x00000000, 0x01080000,\n\t0x0000a368, 0x00000008, 0x00080000,\n\t0x000001c0, 0x00000008, 0x00080000,\n\t0x000001f8, 0x00000008, 0x00080000,\n\t0x00000ac0, 0x00000008, 0x00080000,\n\t0x00002578, 0x00000008, 0x00080000,\n\t0x000024f8, 0x00000008, 0x00080000,\n\t0x00000280, 0x00000008, 0x00080000,\n\t0x00000680, 0x00080018, 0x00080000,\n\t0x00000b78, 0x00080018, 0x00020000,\n\t0x0000c600, 0x00000058, 0x003c0000,\n\t0x00012038, 0x00000020, 0x00100000,\n\t0x00011b00, 0x00000048, 0x00180000,\n\t0x00009650, 0x00000050, 0x00200000,\n\t0x00008b10, 0x00000040, 0x00280000,\n\t0x000116c0, 0x00000018, 0x00100000,\n\t0x0000c808, 0x00000048, 0x00380000,\n\t0x00011790, 0x00000020, 0x00200000,\n\t0x000046d0, 0x00000080, 0x00100000,\n\t0x00003618, 0x00000010, 0x00100000,\n\t0x0000a9e8, 0x00000008, 0x00010000,\n\t0x000097a0, 0x00000008, 0x00010000,\n\t0x00011a10, 0x00000008, 0x00010000,\n\t0x0000e9f8, 0x00000008, 0x00010000,\n\t0x00012648, 0x00000008, 0x00010000,\n\t0x000121c8, 0x00000008, 0x00010000,\n\t0x0000af08, 0x00000030, 0x00100000,\n\t0x0000d748, 0x00000028, 0x00280000,\n\t0x00009e68, 0x00000018, 0x00180000,\n\t0x00009fe8, 0x00000008, 0x00080000,\n\t0x00013ea8, 0x00000008, 0x00080000,\n\t0x00012f18, 0x00000018, 0x00180000,\n\t0x0000dfe8, 0x00500288, 0x00100000,\n\t0x000131a0, 0x00000138, 0x00280000,\n};\n\nvoid qed_init_iro_array(struct qed_dev *cdev)\n{\n\tcdev->iro_arr = iro_arr + E4_IRO_ARR_OFFSET;\n}\n\nvoid qed_init_store_rt_reg(struct qed_hwfn *p_hwfn, u32 rt_offset, u32 val)\n{\n\tif (rt_offset >= RUNTIME_ARRAY_SIZE) {\n\t\tDP_ERR(p_hwfn,\n\t\t       \"Avoid storing %u in rt_data at index %u!\\n\",\n\t\t       val, rt_offset);\n\t\treturn;\n\t}\n\n\tp_hwfn->rt_data.init_val[rt_offset] = val;\n\tp_hwfn->rt_data.b_valid[rt_offset] = true;\n}\n\nvoid qed_init_store_rt_agg(struct qed_hwfn *p_hwfn,\n\t\t\t   u32 rt_offset, u32 *p_val, size_t size)\n{\n\tsize_t i;\n\n\tif ((rt_offset + size - 1) >= RUNTIME_ARRAY_SIZE) {\n\t\tDP_ERR(p_hwfn,\n\t\t       \"Avoid storing values in rt_data at indices %u-%u!\\n\",\n\t\t       rt_offset,\n\t\t       (u32)(rt_offset + size - 1));\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < size / sizeof(u32); i++) {\n\t\tp_hwfn->rt_data.init_val[rt_offset + i] = p_val[i];\n\t\tp_hwfn->rt_data.b_valid[rt_offset + i]\t= true;\n\t}\n}\n\nstatic int qed_init_rt(struct qed_hwfn\t*p_hwfn,\n\t\t       struct qed_ptt *p_ptt,\n\t\t       u32 addr, u16 rt_offset, u16 size, bool b_must_dmae)\n{\n\tu32 *p_init_val = &p_hwfn->rt_data.init_val[rt_offset];\n\tbool *p_valid = &p_hwfn->rt_data.b_valid[rt_offset];\n\tu16 i, j, segment;\n\tint rc = 0;\n\n\t \n\tfor (i = 0; i < size; i++) {\n\t\tif (!p_valid[i])\n\t\t\tcontinue;\n\n\t\t \n\t\tif (!b_must_dmae) {\n\t\t\tqed_wr(p_hwfn, p_ptt, addr + (i << 2), p_init_val[i]);\n\t\t\tp_valid[i] = false;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tfor (segment = 1; i + segment < size; segment++)\n\t\t\tif (!p_valid[i + segment])\n\t\t\t\tbreak;\n\n\t\trc = qed_dmae_host2grc(p_hwfn, p_ptt,\n\t\t\t\t       (uintptr_t)(p_init_val + i),\n\t\t\t\t       addr + (i << 2), segment, NULL);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\t \n\t\tfor (j = i; j < (u32)(i + segment); j++)\n\t\t\tp_valid[j] = false;\n\n\t\t \n\t\ti += segment;\n\t}\n\n\treturn rc;\n}\n\nint qed_init_alloc(struct qed_hwfn *p_hwfn)\n{\n\tstruct qed_rt_data *rt_data = &p_hwfn->rt_data;\n\n\tif (IS_VF(p_hwfn->cdev))\n\t\treturn 0;\n\n\trt_data->b_valid = kcalloc(RUNTIME_ARRAY_SIZE, sizeof(bool),\n\t\t\t\t   GFP_KERNEL);\n\tif (!rt_data->b_valid)\n\t\treturn -ENOMEM;\n\n\trt_data->init_val = kcalloc(RUNTIME_ARRAY_SIZE, sizeof(u32),\n\t\t\t\t    GFP_KERNEL);\n\tif (!rt_data->init_val) {\n\t\tkfree(rt_data->b_valid);\n\t\trt_data->b_valid = NULL;\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nvoid qed_init_free(struct qed_hwfn *p_hwfn)\n{\n\tkfree(p_hwfn->rt_data.init_val);\n\tp_hwfn->rt_data.init_val = NULL;\n\tkfree(p_hwfn->rt_data.b_valid);\n\tp_hwfn->rt_data.b_valid = NULL;\n}\n\nstatic int qed_init_array_dmae(struct qed_hwfn *p_hwfn,\n\t\t\t       struct qed_ptt *p_ptt,\n\t\t\t       u32 addr,\n\t\t\t       u32 dmae_data_offset,\n\t\t\t       u32 size,\n\t\t\t       const u32 *buf,\n\t\t\t       bool b_must_dmae,\n\t\t\t       bool b_can_dmae)\n{\n\tint rc = 0;\n\n\t \n\tif (!b_can_dmae || (!b_must_dmae && (size < 16))) {\n\t\tconst u32 *data = buf + dmae_data_offset;\n\t\tu32 i;\n\n\t\tfor (i = 0; i < size; i++)\n\t\t\tqed_wr(p_hwfn, p_ptt, addr + (i << 2), data[i]);\n\t} else {\n\t\trc = qed_dmae_host2grc(p_hwfn, p_ptt,\n\t\t\t\t       (uintptr_t)(buf + dmae_data_offset),\n\t\t\t\t       addr, size, NULL);\n\t}\n\n\treturn rc;\n}\n\nstatic int qed_init_fill_dmae(struct qed_hwfn *p_hwfn,\n\t\t\t      struct qed_ptt *p_ptt,\n\t\t\t      u32 addr, u32 fill_count)\n{\n\tstatic u32 zero_buffer[DMAE_MAX_RW_SIZE];\n\tstruct qed_dmae_params params = {};\n\n\tmemset(zero_buffer, 0, sizeof(u32) * DMAE_MAX_RW_SIZE);\n\n\t \n\tSET_FIELD(params.flags, QED_DMAE_PARAMS_RW_REPL_SRC, 0x1);\n\treturn qed_dmae_host2grc(p_hwfn, p_ptt,\n\t\t\t\t (uintptr_t)(&zero_buffer[0]),\n\t\t\t\t addr, fill_count, &params);\n}\n\nstatic void qed_init_fill(struct qed_hwfn *p_hwfn,\n\t\t\t  struct qed_ptt *p_ptt,\n\t\t\t  u32 addr, u32 fill, u32 fill_count)\n{\n\tu32 i;\n\n\tfor (i = 0; i < fill_count; i++, addr += sizeof(u32))\n\t\tqed_wr(p_hwfn, p_ptt, addr, fill);\n}\n\nstatic int qed_init_cmd_array(struct qed_hwfn *p_hwfn,\n\t\t\t      struct qed_ptt *p_ptt,\n\t\t\t      struct init_write_op *cmd,\n\t\t\t      bool b_must_dmae, bool b_can_dmae)\n{\n\tu32 dmae_array_offset = le32_to_cpu(cmd->args.array_offset);\n\tu32 data = le32_to_cpu(cmd->data);\n\tu32 addr = GET_FIELD(data, INIT_WRITE_OP_ADDRESS) << 2;\n\n\tu32 offset, output_len, input_len, max_size;\n\tstruct qed_dev *cdev = p_hwfn->cdev;\n\tunion init_array_hdr *hdr;\n\tconst u32 *array_data;\n\tint rc = 0;\n\tu32 size;\n\n\tarray_data = cdev->fw_data->arr_data;\n\n\thdr = (union init_array_hdr *)(array_data + dmae_array_offset);\n\tdata = le32_to_cpu(hdr->raw.data);\n\tswitch (GET_FIELD(data, INIT_ARRAY_RAW_HDR_TYPE)) {\n\tcase INIT_ARR_ZIPPED:\n\t\toffset = dmae_array_offset + 1;\n\t\tinput_len = GET_FIELD(data,\n\t\t\t\t      INIT_ARRAY_ZIPPED_HDR_ZIPPED_SIZE);\n\t\tmax_size = MAX_ZIPPED_SIZE * 4;\n\t\tmemset(p_hwfn->unzip_buf, 0, max_size);\n\n\t\toutput_len = qed_unzip_data(p_hwfn, input_len,\n\t\t\t\t\t    (u8 *)&array_data[offset],\n\t\t\t\t\t    max_size, (u8 *)p_hwfn->unzip_buf);\n\t\tif (output_len) {\n\t\t\trc = qed_init_array_dmae(p_hwfn, p_ptt, addr, 0,\n\t\t\t\t\t\t output_len,\n\t\t\t\t\t\t p_hwfn->unzip_buf,\n\t\t\t\t\t\t b_must_dmae, b_can_dmae);\n\t\t} else {\n\t\t\tDP_NOTICE(p_hwfn, \"Failed to unzip dmae data\\n\");\n\t\t\trc = -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase INIT_ARR_PATTERN:\n\t{\n\t\tu32 repeats = GET_FIELD(data,\n\t\t\t\t\tINIT_ARRAY_PATTERN_HDR_REPETITIONS);\n\t\tu32 i;\n\n\t\tsize = GET_FIELD(data, INIT_ARRAY_PATTERN_HDR_PATTERN_SIZE);\n\n\t\tfor (i = 0; i < repeats; i++, addr += size << 2) {\n\t\t\trc = qed_init_array_dmae(p_hwfn, p_ptt, addr,\n\t\t\t\t\t\t dmae_array_offset + 1,\n\t\t\t\t\t\t size, array_data,\n\t\t\t\t\t\t b_must_dmae, b_can_dmae);\n\t\t\tif (rc)\n\t\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\tcase INIT_ARR_STANDARD:\n\t\tsize = GET_FIELD(data, INIT_ARRAY_STANDARD_HDR_SIZE);\n\t\trc = qed_init_array_dmae(p_hwfn, p_ptt, addr,\n\t\t\t\t\t dmae_array_offset + 1,\n\t\t\t\t\t size, array_data,\n\t\t\t\t\t b_must_dmae, b_can_dmae);\n\t\tbreak;\n\t}\n\n\treturn rc;\n}\n\n \nstatic int qed_init_cmd_wr(struct qed_hwfn *p_hwfn,\n\t\t\t   struct qed_ptt *p_ptt,\n\t\t\t   struct init_write_op *p_cmd, bool b_can_dmae)\n{\n\tu32 data = le32_to_cpu(p_cmd->data);\n\tbool b_must_dmae = GET_FIELD(data, INIT_WRITE_OP_WIDE_BUS);\n\tu32 addr = GET_FIELD(data, INIT_WRITE_OP_ADDRESS) << 2;\n\tunion init_write_args *arg = &p_cmd->args;\n\tint rc = 0;\n\n\t \n\tif (b_must_dmae && !b_can_dmae) {\n\t\tDP_NOTICE(p_hwfn,\n\t\t\t  \"Need to write to %08x for Wide-bus but DMAE isn't allowed\\n\",\n\t\t\t  addr);\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (GET_FIELD(data, INIT_WRITE_OP_SOURCE)) {\n\tcase INIT_SRC_INLINE:\n\t\tdata = le32_to_cpu(p_cmd->args.inline_val);\n\t\tqed_wr(p_hwfn, p_ptt, addr, data);\n\t\tbreak;\n\tcase INIT_SRC_ZEROS:\n\t\tdata = le32_to_cpu(p_cmd->args.zeros_count);\n\t\tif (b_must_dmae || (b_can_dmae && (data >= 64)))\n\t\t\trc = qed_init_fill_dmae(p_hwfn, p_ptt, addr, data);\n\t\telse\n\t\t\tqed_init_fill(p_hwfn, p_ptt, addr, 0, data);\n\t\tbreak;\n\tcase INIT_SRC_ARRAY:\n\t\trc = qed_init_cmd_array(p_hwfn, p_ptt, p_cmd,\n\t\t\t\t\tb_must_dmae, b_can_dmae);\n\t\tbreak;\n\tcase INIT_SRC_RUNTIME:\n\t\tqed_init_rt(p_hwfn, p_ptt, addr,\n\t\t\t    le16_to_cpu(arg->runtime.offset),\n\t\t\t    le16_to_cpu(arg->runtime.size),\n\t\t\t    b_must_dmae);\n\t\tbreak;\n\t}\n\n\treturn rc;\n}\n\nstatic inline bool comp_eq(u32 val, u32 expected_val)\n{\n\treturn val == expected_val;\n}\n\nstatic inline bool comp_and(u32 val, u32 expected_val)\n{\n\treturn (val & expected_val) == expected_val;\n}\n\nstatic inline bool comp_or(u32 val, u32 expected_val)\n{\n\treturn (val | expected_val) > 0;\n}\n\n \nstatic void qed_init_cmd_rd(struct qed_hwfn *p_hwfn,\n\t\t\t    struct qed_ptt *p_ptt, struct init_read_op *cmd)\n{\n\tbool (*comp_check)(u32 val, u32 expected_val);\n\tu32 delay = QED_INIT_POLL_PERIOD_US, val;\n\tu32 data, addr, poll;\n\tint i;\n\n\tdata = le32_to_cpu(cmd->op_data);\n\taddr = GET_FIELD(data, INIT_READ_OP_ADDRESS) << 2;\n\tpoll = GET_FIELD(data, INIT_READ_OP_POLL_TYPE);\n\n\tval = qed_rd(p_hwfn, p_ptt, addr);\n\n\tif (poll == INIT_POLL_NONE)\n\t\treturn;\n\n\tswitch (poll) {\n\tcase INIT_POLL_EQ:\n\t\tcomp_check = comp_eq;\n\t\tbreak;\n\tcase INIT_POLL_OR:\n\t\tcomp_check = comp_or;\n\t\tbreak;\n\tcase INIT_POLL_AND:\n\t\tcomp_check = comp_and;\n\t\tbreak;\n\tdefault:\n\t\tDP_ERR(p_hwfn, \"Invalid poll comparison type %08x\\n\",\n\t\t       cmd->op_data);\n\t\treturn;\n\t}\n\n\tdata = le32_to_cpu(cmd->expected_val);\n\tfor (i = 0;\n\t     i < QED_INIT_MAX_POLL_COUNT && !comp_check(val, data);\n\t     i++) {\n\t\tudelay(delay);\n\t\tval = qed_rd(p_hwfn, p_ptt, addr);\n\t}\n\n\tif (i == QED_INIT_MAX_POLL_COUNT) {\n\t\tDP_ERR(p_hwfn,\n\t\t       \"Timeout when polling reg: 0x%08x [ Waiting-for: %08x Got: %08x (comparison %08x)]\\n\",\n\t\t       addr, le32_to_cpu(cmd->expected_val),\n\t\t       val, le32_to_cpu(cmd->op_data));\n\t}\n}\n\n \nstatic int qed_init_cmd_cb(struct qed_hwfn *p_hwfn,\n\t\t\t   struct qed_ptt *p_ptt,\n\t\t\t   struct init_callback_op *p_cmd)\n{\n\tint rc;\n\n\tswitch (p_cmd->callback_id) {\n\tcase DMAE_READY_CB:\n\t\trc = qed_dmae_sanity(p_hwfn, p_ptt, \"engine_phase\");\n\t\tbreak;\n\tdefault:\n\t\tDP_NOTICE(p_hwfn, \"Unexpected init op callback ID %d\\n\",\n\t\t\t  p_cmd->callback_id);\n\t\treturn -EINVAL;\n\t}\n\n\treturn rc;\n}\n\nstatic u8 qed_init_cmd_mode_match(struct qed_hwfn *p_hwfn,\n\t\t\t\t  u16 *p_offset, int modes)\n{\n\tstruct qed_dev *cdev = p_hwfn->cdev;\n\tconst u8 *modes_tree_buf;\n\tu8 arg1, arg2, tree_val;\n\n\tmodes_tree_buf = cdev->fw_data->modes_tree_buf;\n\ttree_val = modes_tree_buf[(*p_offset)++];\n\tswitch (tree_val) {\n\tcase INIT_MODE_OP_NOT:\n\t\treturn qed_init_cmd_mode_match(p_hwfn, p_offset, modes) ^ 1;\n\tcase INIT_MODE_OP_OR:\n\t\targ1 = qed_init_cmd_mode_match(p_hwfn, p_offset, modes);\n\t\targ2 = qed_init_cmd_mode_match(p_hwfn, p_offset, modes);\n\t\treturn arg1 | arg2;\n\tcase INIT_MODE_OP_AND:\n\t\targ1 = qed_init_cmd_mode_match(p_hwfn, p_offset, modes);\n\t\targ2 = qed_init_cmd_mode_match(p_hwfn, p_offset, modes);\n\t\treturn arg1 & arg2;\n\tdefault:\n\t\ttree_val -= MAX_INIT_MODE_OPS;\n\t\treturn (modes & BIT(tree_val)) ? 1 : 0;\n\t}\n}\n\nstatic u32 qed_init_cmd_mode(struct qed_hwfn *p_hwfn,\n\t\t\t     struct init_if_mode_op *p_cmd, int modes)\n{\n\tu16 offset = le16_to_cpu(p_cmd->modes_buf_offset);\n\n\tif (qed_init_cmd_mode_match(p_hwfn, &offset, modes))\n\t\treturn 0;\n\telse\n\t\treturn GET_FIELD(le32_to_cpu(p_cmd->op_data),\n\t\t\t\t INIT_IF_MODE_OP_CMD_OFFSET);\n}\n\nstatic u32 qed_init_cmd_phase(struct init_if_phase_op *p_cmd,\n\t\t\t      u32 phase, u32 phase_id)\n{\n\tu32 data = le32_to_cpu(p_cmd->phase_data);\n\tu32 op_data = le32_to_cpu(p_cmd->op_data);\n\n\tif (!(GET_FIELD(data, INIT_IF_PHASE_OP_PHASE) == phase &&\n\t      (GET_FIELD(data, INIT_IF_PHASE_OP_PHASE_ID) == ANY_PHASE_ID ||\n\t       GET_FIELD(data, INIT_IF_PHASE_OP_PHASE_ID) == phase_id)))\n\t\treturn GET_FIELD(op_data, INIT_IF_PHASE_OP_CMD_OFFSET);\n\telse\n\t\treturn 0;\n}\n\nint qed_init_run(struct qed_hwfn *p_hwfn,\n\t\t struct qed_ptt *p_ptt, int phase, int phase_id, int modes)\n{\n\tbool b_dmae = (phase != PHASE_ENGINE);\n\tstruct qed_dev *cdev = p_hwfn->cdev;\n\tu32 cmd_num, num_init_ops;\n\tunion init_op *init_ops;\n\tint rc = 0;\n\n\tnum_init_ops = cdev->fw_data->init_ops_size;\n\tinit_ops = cdev->fw_data->init_ops;\n\n\tp_hwfn->unzip_buf = kzalloc(MAX_ZIPPED_SIZE * 4, GFP_ATOMIC);\n\tif (!p_hwfn->unzip_buf)\n\t\treturn -ENOMEM;\n\n\tfor (cmd_num = 0; cmd_num < num_init_ops; cmd_num++) {\n\t\tunion init_op *cmd = &init_ops[cmd_num];\n\t\tu32 data = le32_to_cpu(cmd->raw.op_data);\n\n\t\tswitch (GET_FIELD(data, INIT_CALLBACK_OP_OP)) {\n\t\tcase INIT_OP_WRITE:\n\t\t\trc = qed_init_cmd_wr(p_hwfn, p_ptt, &cmd->write,\n\t\t\t\t\t     b_dmae);\n\t\t\tbreak;\n\t\tcase INIT_OP_READ:\n\t\t\tqed_init_cmd_rd(p_hwfn, p_ptt, &cmd->read);\n\t\t\tbreak;\n\t\tcase INIT_OP_IF_MODE:\n\t\t\tcmd_num += qed_init_cmd_mode(p_hwfn, &cmd->if_mode,\n\t\t\t\t\t\t     modes);\n\t\t\tbreak;\n\t\tcase INIT_OP_IF_PHASE:\n\t\t\tcmd_num += qed_init_cmd_phase(&cmd->if_phase,\n\t\t\t\t\t\t      phase, phase_id);\n\t\t\tbreak;\n\t\tcase INIT_OP_DELAY:\n\t\t\t \n\t\t\tudelay(le32_to_cpu(cmd->delay.delay));\n\t\t\tbreak;\n\n\t\tcase INIT_OP_CALLBACK:\n\t\t\trc = qed_init_cmd_cb(p_hwfn, p_ptt, &cmd->callback);\n\t\t\tif (phase == PHASE_ENGINE &&\n\t\t\t    cmd->callback.callback_id == DMAE_READY_CB)\n\t\t\t\tb_dmae = true;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (rc)\n\t\t\tbreak;\n\t}\n\n\tkfree(p_hwfn->unzip_buf);\n\tp_hwfn->unzip_buf = NULL;\n\treturn rc;\n}\n\nvoid qed_gtt_init(struct qed_hwfn *p_hwfn)\n{\n\tu32 gtt_base;\n\tu32 i;\n\n\t \n\tgtt_base = PXP_PF_WINDOW_ADMIN_START + PXP_PF_WINDOW_ADMIN_GLOBAL_START;\n\n\tfor (i = 0; i < ARRAY_SIZE(pxp_global_win); i++)\n\t\tif (pxp_global_win[i])\n\t\t\tREG_WR(p_hwfn, gtt_base + i * PXP_GLOBAL_ENTRY_SIZE,\n\t\t\t       pxp_global_win[i]);\n}\n\nint qed_init_fw_data(struct qed_dev *cdev, const u8 *data)\n{\n\tstruct qed_fw_data *fw = cdev->fw_data;\n\tstruct bin_buffer_hdr *buf_hdr;\n\tu32 offset, len;\n\n\tif (!data) {\n\t\tDP_NOTICE(cdev, \"Invalid fw data\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tbuf_hdr = (struct bin_buffer_hdr *)data;\n\n\toffset = buf_hdr[BIN_BUF_INIT_FW_VER_INFO].offset;\n\tfw->fw_ver_info = (struct fw_ver_info *)(data + offset);\n\n\toffset = buf_hdr[BIN_BUF_INIT_CMD].offset;\n\tfw->init_ops = (union init_op *)(data + offset);\n\n\toffset = buf_hdr[BIN_BUF_INIT_VAL].offset;\n\tfw->arr_data = (u32 *)(data + offset);\n\n\toffset = buf_hdr[BIN_BUF_INIT_MODE_TREE].offset;\n\tfw->modes_tree_buf = (u8 *)(data + offset);\n\tlen = buf_hdr[BIN_BUF_INIT_CMD].length;\n\tfw->init_ops_size = len / sizeof(struct init_raw_op);\n\n\toffset = buf_hdr[BIN_BUF_INIT_OVERLAYS].offset;\n\tfw->fw_overlays = (u32 *)(data + offset);\n\tlen = buf_hdr[BIN_BUF_INIT_OVERLAYS].length;\n\tfw->fw_overlays_len = len;\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}