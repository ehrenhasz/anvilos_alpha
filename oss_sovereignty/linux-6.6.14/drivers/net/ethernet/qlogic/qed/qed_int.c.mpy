{
  "module_name": "qed_int.c",
  "hash_id": "28fece2992c733086b51796b2b4b0a2059b70936fef7f17e3ef3a748cc4b979b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/qlogic/qed/qed_int.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <asm/byteorder.h>\n#include <linux/io.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/dma-mapping.h>\n#include <linux/errno.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/pci.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include \"qed.h\"\n#include \"qed_hsi.h\"\n#include \"qed_hw.h\"\n#include \"qed_init_ops.h\"\n#include \"qed_int.h\"\n#include \"qed_mcp.h\"\n#include \"qed_reg_addr.h\"\n#include \"qed_sp.h\"\n#include \"qed_sriov.h\"\n#include \"qed_vf.h\"\n\nstruct qed_pi_info {\n\tqed_int_comp_cb_t\tcomp_cb;\n\tvoid\t\t\t*cookie;\n};\n\nstruct qed_sb_sp_info {\n\tstruct qed_sb_info sb_info;\n\n\t \n\tstruct qed_pi_info pi_info_arr[PIS_PER_SB];\n};\n\nenum qed_attention_type {\n\tQED_ATTN_TYPE_ATTN,\n\tQED_ATTN_TYPE_PARITY,\n};\n\n#define SB_ATTN_ALIGNED_SIZE(p_hwfn) \\\n\tALIGNED_TYPE_SIZE(struct atten_status_block, p_hwfn)\n\nstruct aeu_invert_reg_bit {\n\tchar bit_name[30];\n\n#define ATTENTION_PARITY                (1 << 0)\n\n#define ATTENTION_LENGTH_MASK           (0x00000ff0)\n#define ATTENTION_LENGTH_SHIFT          (4)\n#define ATTENTION_LENGTH(flags)         (((flags) & ATTENTION_LENGTH_MASK) >> \\\n\t\t\t\t\t ATTENTION_LENGTH_SHIFT)\n#define ATTENTION_SINGLE                BIT(ATTENTION_LENGTH_SHIFT)\n#define ATTENTION_PAR                   (ATTENTION_SINGLE | ATTENTION_PARITY)\n#define ATTENTION_PAR_INT               ((2 << ATTENTION_LENGTH_SHIFT) | \\\n\t\t\t\t\t ATTENTION_PARITY)\n\n \n#define ATTENTION_OFFSET_MASK           (0x000ff000)\n#define ATTENTION_OFFSET_SHIFT          (12)\n\n#define ATTENTION_BB_MASK               (0x00700000)\n#define ATTENTION_BB_SHIFT              (20)\n#define ATTENTION_BB(value)             (value << ATTENTION_BB_SHIFT)\n#define ATTENTION_BB_DIFFERENT          BIT(23)\n\n#define ATTENTION_CLEAR_ENABLE          BIT(28)\n\tunsigned int flags;\n\n\t \n\tint (*cb)(struct qed_hwfn *p_hwfn);\n\n\tenum block_id block_index;\n};\n\nstruct aeu_invert_reg {\n\tstruct aeu_invert_reg_bit bits[32];\n};\n\n#define MAX_ATTN_GRPS           (8)\n#define NUM_ATTN_REGS           (9)\n\n \nstatic int qed_mcp_attn_cb(struct qed_hwfn *p_hwfn)\n{\n\tu32 tmp = qed_rd(p_hwfn, p_hwfn->p_dpc_ptt, MCP_REG_CPU_STATE);\n\n\t \n\tDP_INFO(p_hwfn->cdev, \"MCP_REG_CPU_STATE: %08x - Masking...\\n\",\n\t\ttmp);\n\tqed_wr(p_hwfn, p_hwfn->p_dpc_ptt, MCP_REG_CPU_EVENT_MASK,\n\t       0xffffffff);\n\n\treturn 0;\n}\n\n#define QED_PSWHST_ATTENTION_INCORRECT_ACCESS\t\t(0x1)\n#define ATTENTION_INCORRECT_ACCESS_WR_MASK\t\t(0x1)\n#define ATTENTION_INCORRECT_ACCESS_WR_SHIFT\t\t(0)\n#define ATTENTION_INCORRECT_ACCESS_CLIENT_MASK\t\t(0xf)\n#define ATTENTION_INCORRECT_ACCESS_CLIENT_SHIFT\t\t(1)\n#define ATTENTION_INCORRECT_ACCESS_VF_VALID_MASK\t(0x1)\n#define ATTENTION_INCORRECT_ACCESS_VF_VALID_SHIFT\t(5)\n#define ATTENTION_INCORRECT_ACCESS_VF_ID_MASK\t\t(0xff)\n#define ATTENTION_INCORRECT_ACCESS_VF_ID_SHIFT\t\t(6)\n#define ATTENTION_INCORRECT_ACCESS_PF_ID_MASK\t\t(0xf)\n#define ATTENTION_INCORRECT_ACCESS_PF_ID_SHIFT\t\t(14)\n#define ATTENTION_INCORRECT_ACCESS_BYTE_EN_MASK\t\t(0xff)\n#define ATTENTION_INCORRECT_ACCESS_BYTE_EN_SHIFT\t(18)\nstatic int qed_pswhst_attn_cb(struct qed_hwfn *p_hwfn)\n{\n\tu32 tmp = qed_rd(p_hwfn, p_hwfn->p_dpc_ptt,\n\t\t\t PSWHST_REG_INCORRECT_ACCESS_VALID);\n\n\tif (tmp & QED_PSWHST_ATTENTION_INCORRECT_ACCESS) {\n\t\tu32 addr, data, length;\n\n\t\taddr = qed_rd(p_hwfn, p_hwfn->p_dpc_ptt,\n\t\t\t      PSWHST_REG_INCORRECT_ACCESS_ADDRESS);\n\t\tdata = qed_rd(p_hwfn, p_hwfn->p_dpc_ptt,\n\t\t\t      PSWHST_REG_INCORRECT_ACCESS_DATA);\n\t\tlength = qed_rd(p_hwfn, p_hwfn->p_dpc_ptt,\n\t\t\t\tPSWHST_REG_INCORRECT_ACCESS_LENGTH);\n\n\t\tDP_INFO(p_hwfn->cdev,\n\t\t\t\"Incorrect access to %08x of length %08x - PF [%02x] VF [%04x] [valid %02x] client [%02x] write [%02x] Byte-Enable [%04x] [%08x]\\n\",\n\t\t\taddr, length,\n\t\t\t(u8) GET_FIELD(data, ATTENTION_INCORRECT_ACCESS_PF_ID),\n\t\t\t(u8) GET_FIELD(data, ATTENTION_INCORRECT_ACCESS_VF_ID),\n\t\t\t(u8) GET_FIELD(data,\n\t\t\t\t       ATTENTION_INCORRECT_ACCESS_VF_VALID),\n\t\t\t(u8) GET_FIELD(data,\n\t\t\t\t       ATTENTION_INCORRECT_ACCESS_CLIENT),\n\t\t\t(u8) GET_FIELD(data, ATTENTION_INCORRECT_ACCESS_WR),\n\t\t\t(u8) GET_FIELD(data,\n\t\t\t\t       ATTENTION_INCORRECT_ACCESS_BYTE_EN),\n\t\t\tdata);\n\t}\n\n\treturn 0;\n}\n\n#define QED_GRC_ATTENTION_VALID_BIT\t(1 << 0)\n#define QED_GRC_ATTENTION_ADDRESS_MASK\t(0x7fffff)\n#define QED_GRC_ATTENTION_ADDRESS_SHIFT\t(0)\n#define QED_GRC_ATTENTION_RDWR_BIT\t(1 << 23)\n#define QED_GRC_ATTENTION_MASTER_MASK\t(0xf)\n#define QED_GRC_ATTENTION_MASTER_SHIFT\t(24)\n#define QED_GRC_ATTENTION_PF_MASK\t(0xf)\n#define QED_GRC_ATTENTION_PF_SHIFT\t(0)\n#define QED_GRC_ATTENTION_VF_MASK\t(0xff)\n#define QED_GRC_ATTENTION_VF_SHIFT\t(4)\n#define QED_GRC_ATTENTION_PRIV_MASK\t(0x3)\n#define QED_GRC_ATTENTION_PRIV_SHIFT\t(14)\n#define QED_GRC_ATTENTION_PRIV_VF\t(0)\nstatic const char *attn_master_to_str(u8 master)\n{\n\tswitch (master) {\n\tcase 1: return \"PXP\";\n\tcase 2: return \"MCP\";\n\tcase 3: return \"MSDM\";\n\tcase 4: return \"PSDM\";\n\tcase 5: return \"YSDM\";\n\tcase 6: return \"USDM\";\n\tcase 7: return \"TSDM\";\n\tcase 8: return \"XSDM\";\n\tcase 9: return \"DBU\";\n\tcase 10: return \"DMAE\";\n\tdefault:\n\t\treturn \"Unknown\";\n\t}\n}\n\nstatic int qed_grc_attn_cb(struct qed_hwfn *p_hwfn)\n{\n\tu32 tmp, tmp2;\n\n\t \n\ttmp = qed_rd(p_hwfn, p_hwfn->p_dpc_ptt,\n\t\t     GRC_REG_TIMEOUT_ATTN_ACCESS_VALID);\n\tif (!(tmp & QED_GRC_ATTENTION_VALID_BIT))\n\t\tgoto out;\n\n\t \n\ttmp = qed_rd(p_hwfn, p_hwfn->p_dpc_ptt,\n\t\t     GRC_REG_TIMEOUT_ATTN_ACCESS_DATA_0);\n\ttmp2 = qed_rd(p_hwfn, p_hwfn->p_dpc_ptt,\n\t\t      GRC_REG_TIMEOUT_ATTN_ACCESS_DATA_1);\n\n\tDP_INFO(p_hwfn->cdev,\n\t\t\"GRC timeout [%08x:%08x] - %s Address [%08x] [Master %s] [PF: %02x %s %02x]\\n\",\n\t\ttmp2, tmp,\n\t\t(tmp & QED_GRC_ATTENTION_RDWR_BIT) ? \"Write to\" : \"Read from\",\n\t\tGET_FIELD(tmp, QED_GRC_ATTENTION_ADDRESS) << 2,\n\t\tattn_master_to_str(GET_FIELD(tmp, QED_GRC_ATTENTION_MASTER)),\n\t\tGET_FIELD(tmp2, QED_GRC_ATTENTION_PF),\n\t\t(GET_FIELD(tmp2, QED_GRC_ATTENTION_PRIV) ==\n\t\t QED_GRC_ATTENTION_PRIV_VF) ? \"VF\" : \"(Irrelevant)\",\n\t\tGET_FIELD(tmp2, QED_GRC_ATTENTION_VF));\n\nout:\n\t \n\tqed_wr(p_hwfn, p_hwfn->p_dpc_ptt,\n\t       GRC_REG_TIMEOUT_ATTN_ACCESS_VALID, 0);\n\treturn 0;\n}\n\n#define PGLUE_ATTENTION_VALID\t\t\t(1 << 29)\n#define PGLUE_ATTENTION_RD_VALID\t\t(1 << 26)\n#define PGLUE_ATTENTION_DETAILS_PFID_MASK\t(0xf)\n#define PGLUE_ATTENTION_DETAILS_PFID_SHIFT\t(20)\n#define PGLUE_ATTENTION_DETAILS_VF_VALID_MASK\t(0x1)\n#define PGLUE_ATTENTION_DETAILS_VF_VALID_SHIFT\t(19)\n#define PGLUE_ATTENTION_DETAILS_VFID_MASK\t(0xff)\n#define PGLUE_ATTENTION_DETAILS_VFID_SHIFT\t(24)\n#define PGLUE_ATTENTION_DETAILS2_WAS_ERR_MASK\t(0x1)\n#define PGLUE_ATTENTION_DETAILS2_WAS_ERR_SHIFT\t(21)\n#define PGLUE_ATTENTION_DETAILS2_BME_MASK\t(0x1)\n#define PGLUE_ATTENTION_DETAILS2_BME_SHIFT\t(22)\n#define PGLUE_ATTENTION_DETAILS2_FID_EN_MASK\t(0x1)\n#define PGLUE_ATTENTION_DETAILS2_FID_EN_SHIFT\t(23)\n#define PGLUE_ATTENTION_ICPL_VALID\t\t(1 << 23)\n#define PGLUE_ATTENTION_ZLR_VALID\t\t(1 << 25)\n#define PGLUE_ATTENTION_ILT_VALID\t\t(1 << 23)\n\nint qed_pglueb_rbc_attn_handler(struct qed_hwfn *p_hwfn, struct qed_ptt *p_ptt,\n\t\t\t\tbool hw_init)\n{\n\tchar msg[256];\n\tu32 tmp;\n\n\ttmp = qed_rd(p_hwfn, p_ptt, PGLUE_B_REG_TX_ERR_WR_DETAILS2);\n\tif (tmp & PGLUE_ATTENTION_VALID) {\n\t\tu32 addr_lo, addr_hi, details;\n\n\t\taddr_lo = qed_rd(p_hwfn, p_ptt,\n\t\t\t\t PGLUE_B_REG_TX_ERR_WR_ADD_31_0);\n\t\taddr_hi = qed_rd(p_hwfn, p_ptt,\n\t\t\t\t PGLUE_B_REG_TX_ERR_WR_ADD_63_32);\n\t\tdetails = qed_rd(p_hwfn, p_ptt,\n\t\t\t\t PGLUE_B_REG_TX_ERR_WR_DETAILS);\n\n\t\tsnprintf(msg, sizeof(msg),\n\t\t\t \"Illegal write by chip to [%08x:%08x] blocked.\\n\"\n\t\t\t \"Details: %08x [PFID %02x, VFID %02x, VF_VALID %02x]\\n\"\n\t\t\t \"Details2 %08x [Was_error %02x BME deassert %02x FID_enable deassert %02x]\",\n\t\t\t addr_hi, addr_lo, details,\n\t\t\t (u8)GET_FIELD(details, PGLUE_ATTENTION_DETAILS_PFID),\n\t\t\t (u8)GET_FIELD(details, PGLUE_ATTENTION_DETAILS_VFID),\n\t\t\t !!GET_FIELD(details, PGLUE_ATTENTION_DETAILS_VF_VALID),\n\t\t\t tmp,\n\t\t\t !!GET_FIELD(tmp, PGLUE_ATTENTION_DETAILS2_WAS_ERR),\n\t\t\t !!GET_FIELD(tmp, PGLUE_ATTENTION_DETAILS2_BME),\n\t\t\t !!GET_FIELD(tmp, PGLUE_ATTENTION_DETAILS2_FID_EN));\n\n\t\tif (hw_init)\n\t\t\tDP_VERBOSE(p_hwfn, NETIF_MSG_INTR, \"%s\\n\", msg);\n\t\telse\n\t\t\tDP_NOTICE(p_hwfn, \"%s\\n\", msg);\n\t}\n\n\ttmp = qed_rd(p_hwfn, p_ptt, PGLUE_B_REG_TX_ERR_RD_DETAILS2);\n\tif (tmp & PGLUE_ATTENTION_RD_VALID) {\n\t\tu32 addr_lo, addr_hi, details;\n\n\t\taddr_lo = qed_rd(p_hwfn, p_ptt,\n\t\t\t\t PGLUE_B_REG_TX_ERR_RD_ADD_31_0);\n\t\taddr_hi = qed_rd(p_hwfn, p_ptt,\n\t\t\t\t PGLUE_B_REG_TX_ERR_RD_ADD_63_32);\n\t\tdetails = qed_rd(p_hwfn, p_ptt,\n\t\t\t\t PGLUE_B_REG_TX_ERR_RD_DETAILS);\n\n\t\tDP_NOTICE(p_hwfn,\n\t\t\t  \"Illegal read by chip from [%08x:%08x] blocked.\\n\"\n\t\t\t  \"Details: %08x [PFID %02x, VFID %02x, VF_VALID %02x]\\n\"\n\t\t\t  \"Details2 %08x [Was_error %02x BME deassert %02x FID_enable deassert %02x]\\n\",\n\t\t\t  addr_hi, addr_lo, details,\n\t\t\t  (u8)GET_FIELD(details, PGLUE_ATTENTION_DETAILS_PFID),\n\t\t\t  (u8)GET_FIELD(details, PGLUE_ATTENTION_DETAILS_VFID),\n\t\t\t  GET_FIELD(details,\n\t\t\t\t    PGLUE_ATTENTION_DETAILS_VF_VALID) ? 1 : 0,\n\t\t\t  tmp,\n\t\t\t  GET_FIELD(tmp,\n\t\t\t\t    PGLUE_ATTENTION_DETAILS2_WAS_ERR) ? 1 : 0,\n\t\t\t  GET_FIELD(tmp,\n\t\t\t\t    PGLUE_ATTENTION_DETAILS2_BME) ? 1 : 0,\n\t\t\t  GET_FIELD(tmp,\n\t\t\t\t    PGLUE_ATTENTION_DETAILS2_FID_EN) ? 1 : 0);\n\t}\n\n\ttmp = qed_rd(p_hwfn, p_ptt, PGLUE_B_REG_TX_ERR_WR_DETAILS_ICPL);\n\tif (tmp & PGLUE_ATTENTION_ICPL_VALID) {\n\t\tsnprintf(msg, sizeof(msg), \"ICPL error - %08x\", tmp);\n\n\t\tif (hw_init)\n\t\t\tDP_VERBOSE(p_hwfn, NETIF_MSG_INTR, \"%s\\n\", msg);\n\t\telse\n\t\t\tDP_NOTICE(p_hwfn, \"%s\\n\", msg);\n\t}\n\n\ttmp = qed_rd(p_hwfn, p_ptt, PGLUE_B_REG_MASTER_ZLR_ERR_DETAILS);\n\tif (tmp & PGLUE_ATTENTION_ZLR_VALID) {\n\t\tu32 addr_hi, addr_lo;\n\n\t\taddr_lo = qed_rd(p_hwfn, p_ptt,\n\t\t\t\t PGLUE_B_REG_MASTER_ZLR_ERR_ADD_31_0);\n\t\taddr_hi = qed_rd(p_hwfn, p_ptt,\n\t\t\t\t PGLUE_B_REG_MASTER_ZLR_ERR_ADD_63_32);\n\n\t\tDP_NOTICE(p_hwfn, \"ZLR error - %08x [Address %08x:%08x]\\n\",\n\t\t\t  tmp, addr_hi, addr_lo);\n\t}\n\n\ttmp = qed_rd(p_hwfn, p_ptt, PGLUE_B_REG_VF_ILT_ERR_DETAILS2);\n\tif (tmp & PGLUE_ATTENTION_ILT_VALID) {\n\t\tu32 addr_hi, addr_lo, details;\n\n\t\taddr_lo = qed_rd(p_hwfn, p_ptt,\n\t\t\t\t PGLUE_B_REG_VF_ILT_ERR_ADD_31_0);\n\t\taddr_hi = qed_rd(p_hwfn, p_ptt,\n\t\t\t\t PGLUE_B_REG_VF_ILT_ERR_ADD_63_32);\n\t\tdetails = qed_rd(p_hwfn, p_ptt,\n\t\t\t\t PGLUE_B_REG_VF_ILT_ERR_DETAILS);\n\n\t\tDP_NOTICE(p_hwfn,\n\t\t\t  \"ILT error - Details %08x Details2 %08x [Address %08x:%08x]\\n\",\n\t\t\t  details, tmp, addr_hi, addr_lo);\n\t}\n\n\t \n\tqed_wr(p_hwfn, p_ptt, PGLUE_B_REG_LATCHED_ERRORS_CLR, BIT(2));\n\n\treturn 0;\n}\n\nstatic int qed_pglueb_rbc_attn_cb(struct qed_hwfn *p_hwfn)\n{\n\treturn qed_pglueb_rbc_attn_handler(p_hwfn, p_hwfn->p_dpc_ptt, false);\n}\n\nstatic int qed_fw_assertion(struct qed_hwfn *p_hwfn)\n{\n\tqed_hw_err_notify(p_hwfn, p_hwfn->p_dpc_ptt, QED_HW_ERR_FW_ASSERT,\n\t\t\t  \"FW assertion!\\n\");\n\n\t \n\tqed_wr(p_hwfn, p_hwfn->p_dpc_ptt, MISC_REG_AEU_GENERAL_ATTN_32, 0);\n\n\treturn -EINVAL;\n}\n\nstatic int qed_general_attention_35(struct qed_hwfn *p_hwfn)\n{\n\tDP_INFO(p_hwfn, \"General attention 35!\\n\");\n\n\treturn 0;\n}\n\n#define QED_DORQ_ATTENTION_REASON_MASK  (0xfffff)\n#define QED_DORQ_ATTENTION_OPAQUE_MASK  (0xffff)\n#define QED_DORQ_ATTENTION_OPAQUE_SHIFT (0x0)\n#define QED_DORQ_ATTENTION_SIZE_MASK            (0x7f)\n#define QED_DORQ_ATTENTION_SIZE_SHIFT           (16)\n\n#define QED_DB_REC_COUNT                        1000\n#define QED_DB_REC_INTERVAL                     100\n\nstatic int qed_db_rec_flush_queue(struct qed_hwfn *p_hwfn,\n\t\t\t\t  struct qed_ptt *p_ptt)\n{\n\tu32 count = QED_DB_REC_COUNT;\n\tu32 usage = 1;\n\n\t \n\tqed_wr(p_hwfn, p_ptt, DORQ_REG_DPM_FORCE_ABORT, 0x1);\n\n\t \n\twhile (count-- && usage) {\n\t\tusage = qed_rd(p_hwfn, p_ptt, DORQ_REG_PF_USAGE_CNT);\n\t\tudelay(QED_DB_REC_INTERVAL);\n\t}\n\n\t \n\tif (usage) {\n\t\tDP_NOTICE(p_hwfn->cdev,\n\t\t\t  \"DB recovery: doorbell usage failed to zero after %d usec. usage was %x\\n\",\n\t\t\t  QED_DB_REC_INTERVAL * QED_DB_REC_COUNT, usage);\n\t\treturn -EBUSY;\n\t}\n\n\treturn 0;\n}\n\nint qed_db_rec_handler(struct qed_hwfn *p_hwfn, struct qed_ptt *p_ptt)\n{\n\tu32 attn_ovfl, cur_ovfl;\n\tint rc;\n\n\tattn_ovfl = test_and_clear_bit(QED_OVERFLOW_BIT,\n\t\t\t\t       &p_hwfn->db_recovery_info.overflow);\n\tcur_ovfl = qed_rd(p_hwfn, p_ptt, DORQ_REG_PF_OVFL_STICKY);\n\tif (!cur_ovfl && !attn_ovfl)\n\t\treturn 0;\n\n\tDP_NOTICE(p_hwfn, \"PF Overflow sticky: attn %u current %u\\n\",\n\t\t  attn_ovfl, cur_ovfl);\n\n\tif (cur_ovfl && !p_hwfn->db_bar_no_edpm) {\n\t\trc = qed_db_rec_flush_queue(p_hwfn, p_ptt);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\t \n\tqed_wr(p_hwfn, p_ptt, DORQ_REG_PF_OVFL_STICKY, 0x0);\n\n\t \n\tqed_db_recovery_execute(p_hwfn);\n\n\treturn 0;\n}\n\nstatic void qed_dorq_attn_overflow(struct qed_hwfn *p_hwfn)\n{\n\tstruct qed_ptt *p_ptt = p_hwfn->p_dpc_ptt;\n\tu32 overflow;\n\tint rc;\n\n\toverflow = qed_rd(p_hwfn, p_ptt, DORQ_REG_PF_OVFL_STICKY);\n\tif (!overflow)\n\t\tgoto out;\n\n\t \n\tset_bit(QED_OVERFLOW_BIT, &p_hwfn->db_recovery_info.overflow);\n\n\tif (!p_hwfn->db_bar_no_edpm) {\n\t\trc = qed_db_rec_flush_queue(p_hwfn, p_ptt);\n\t\tif (rc)\n\t\t\tgoto out;\n\t}\n\n\tqed_wr(p_hwfn, p_ptt, DORQ_REG_PF_OVFL_STICKY, 0x0);\nout:\n\t \n\tqed_periodic_db_rec_start(p_hwfn);\n}\n\nstatic int qed_dorq_attn_int_sts(struct qed_hwfn *p_hwfn)\n{\n\tu32 int_sts, first_drop_reason, details, address, all_drops_reason;\n\tstruct qed_ptt *p_ptt = p_hwfn->p_dpc_ptt;\n\n\tint_sts = qed_rd(p_hwfn, p_ptt, DORQ_REG_INT_STS);\n\tif (int_sts == 0xdeadbeaf) {\n\t\tDP_NOTICE(p_hwfn->cdev,\n\t\t\t  \"DORQ is being reset, skipping int_sts handler\\n\");\n\n\t\treturn 0;\n\t}\n\n\t \n\tif (!(int_sts & ~DORQ_REG_INT_STS_DORQ_FIFO_AFULL))\n\t\treturn 0;\n\n\tDP_NOTICE(p_hwfn->cdev, \"DORQ attention. int_sts was %x\\n\", int_sts);\n\n\t \n\tif (int_sts & (DORQ_REG_INT_STS_DB_DROP |\n\t\t       DORQ_REG_INT_STS_DORQ_FIFO_OVFL_ERR)) {\n\t\t \n\t\tfirst_drop_reason = qed_rd(p_hwfn, p_ptt,\n\t\t\t\t\t   DORQ_REG_DB_DROP_REASON) &\n\t\t    QED_DORQ_ATTENTION_REASON_MASK;\n\t\tdetails = qed_rd(p_hwfn, p_ptt, DORQ_REG_DB_DROP_DETAILS);\n\t\taddress = qed_rd(p_hwfn, p_ptt,\n\t\t\t\t DORQ_REG_DB_DROP_DETAILS_ADDRESS);\n\t\tall_drops_reason = qed_rd(p_hwfn, p_ptt,\n\t\t\t\t\t  DORQ_REG_DB_DROP_DETAILS_REASON);\n\n\t\t \n\t\tDP_NOTICE(p_hwfn->cdev,\n\t\t\t  \"Doorbell drop occurred\\n\"\n\t\t\t  \"Address\\t\\t0x%08x\\t(second BAR address)\\n\"\n\t\t\t  \"FID\\t\\t0x%04x\\t\\t(Opaque FID)\\n\"\n\t\t\t  \"Size\\t\\t0x%04x\\t\\t(in bytes)\\n\"\n\t\t\t  \"1st drop reason\\t0x%08x\\t(details on first drop since last handling)\\n\"\n\t\t\t  \"Sticky reasons\\t0x%08x\\t(all drop reasons since last handling)\\n\",\n\t\t\t  address,\n\t\t\t  GET_FIELD(details, QED_DORQ_ATTENTION_OPAQUE),\n\t\t\t  GET_FIELD(details, QED_DORQ_ATTENTION_SIZE) * 4,\n\t\t\t  first_drop_reason, all_drops_reason);\n\n\t\t \n\t\tqed_wr(p_hwfn, p_ptt, DORQ_REG_DB_DROP_DETAILS_REL, 0);\n\n\t\t \n\t\tqed_wr(p_hwfn,\n\t\t       p_ptt,\n\t\t       DORQ_REG_INT_STS_WR,\n\t\t       DORQ_REG_INT_STS_DB_DROP |\n\t\t       DORQ_REG_INT_STS_DORQ_FIFO_OVFL_ERR);\n\n\t\t \n\t\tif ((int_sts & ~(DORQ_REG_INT_STS_DB_DROP |\n\t\t\t\t DORQ_REG_INT_STS_DORQ_FIFO_OVFL_ERR |\n\t\t\t\t DORQ_REG_INT_STS_DORQ_FIFO_AFULL)) == 0)\n\t\t\treturn 0;\n\t}\n\n\t \n\tDP_INFO(p_hwfn, \"DORQ fatal attention\\n\");\n\n\treturn -EINVAL;\n}\n\nstatic int qed_dorq_attn_cb(struct qed_hwfn *p_hwfn)\n{\n\tif (p_hwfn->cdev->recov_in_prog)\n\t\treturn 0;\n\n\tp_hwfn->db_recovery_info.dorq_attn = true;\n\tqed_dorq_attn_overflow(p_hwfn);\n\n\treturn qed_dorq_attn_int_sts(p_hwfn);\n}\n\nstatic void qed_dorq_attn_handler(struct qed_hwfn *p_hwfn)\n{\n\tif (p_hwfn->db_recovery_info.dorq_attn)\n\t\tgoto out;\n\n\t \n\tqed_dorq_attn_cb(p_hwfn);\nout:\n\tp_hwfn->db_recovery_info.dorq_attn = false;\n}\n\n \nenum aeu_invert_reg_special_type {\n\tAEU_INVERT_REG_SPECIAL_CNIG_0,\n\tAEU_INVERT_REG_SPECIAL_CNIG_1,\n\tAEU_INVERT_REG_SPECIAL_CNIG_2,\n\tAEU_INVERT_REG_SPECIAL_CNIG_3,\n\tAEU_INVERT_REG_SPECIAL_MAX,\n};\n\nstatic struct aeu_invert_reg_bit\naeu_descs_special[AEU_INVERT_REG_SPECIAL_MAX] = {\n\t{\"CNIG port 0\", ATTENTION_SINGLE, NULL, BLOCK_CNIG},\n\t{\"CNIG port 1\", ATTENTION_SINGLE, NULL, BLOCK_CNIG},\n\t{\"CNIG port 2\", ATTENTION_SINGLE, NULL, BLOCK_CNIG},\n\t{\"CNIG port 3\", ATTENTION_SINGLE, NULL, BLOCK_CNIG},\n};\n\n \nstatic struct aeu_invert_reg aeu_descs[NUM_ATTN_REGS] = {\n\t{\n\t\t{        \n\t\t\t{\"GPIO0 function%d\",\n\t\t\t (32 << ATTENTION_LENGTH_SHIFT), NULL, MAX_BLOCK_ID},\n\t\t}\n\t},\n\n\t{\n\t\t{        \n\t\t\t{\"PGLUE config_space\", ATTENTION_SINGLE,\n\t\t\t NULL, MAX_BLOCK_ID},\n\t\t\t{\"PGLUE misc_flr\", ATTENTION_SINGLE,\n\t\t\t NULL, MAX_BLOCK_ID},\n\t\t\t{\"PGLUE B RBC\", ATTENTION_PAR_INT,\n\t\t\t qed_pglueb_rbc_attn_cb, BLOCK_PGLUE_B},\n\t\t\t{\"PGLUE misc_mctp\", ATTENTION_SINGLE,\n\t\t\t NULL, MAX_BLOCK_ID},\n\t\t\t{\"Flash event\", ATTENTION_SINGLE, NULL, MAX_BLOCK_ID},\n\t\t\t{\"SMB event\", ATTENTION_SINGLE,\tNULL, MAX_BLOCK_ID},\n\t\t\t{\"Main Power\", ATTENTION_SINGLE, NULL, MAX_BLOCK_ID},\n\t\t\t{\"SW timers #%d\", (8 << ATTENTION_LENGTH_SHIFT) |\n\t\t\t\t\t  (1 << ATTENTION_OFFSET_SHIFT),\n\t\t\t NULL, MAX_BLOCK_ID},\n\t\t\t{\"PCIE glue/PXP VPD %d\",\n\t\t\t (16 << ATTENTION_LENGTH_SHIFT), NULL, BLOCK_PGLCS},\n\t\t}\n\t},\n\n\t{\n\t\t{        \n\t\t\t{\"General Attention %d\",\n\t\t\t (32 << ATTENTION_LENGTH_SHIFT), NULL, MAX_BLOCK_ID},\n\t\t}\n\t},\n\n\t{\n\t\t{        \n\t\t\t{\"General Attention 32\", ATTENTION_SINGLE |\n\t\t\t ATTENTION_CLEAR_ENABLE, qed_fw_assertion,\n\t\t\t MAX_BLOCK_ID},\n\t\t\t{\"General Attention %d\",\n\t\t\t (2 << ATTENTION_LENGTH_SHIFT) |\n\t\t\t (33 << ATTENTION_OFFSET_SHIFT), NULL, MAX_BLOCK_ID},\n\t\t\t{\"General Attention 35\", ATTENTION_SINGLE |\n\t\t\t ATTENTION_CLEAR_ENABLE, qed_general_attention_35,\n\t\t\t MAX_BLOCK_ID},\n\t\t\t{\"NWS Parity\",\n\t\t\t ATTENTION_PAR | ATTENTION_BB_DIFFERENT |\n\t\t\t ATTENTION_BB(AEU_INVERT_REG_SPECIAL_CNIG_0),\n\t\t\t NULL, BLOCK_NWS},\n\t\t\t{\"NWS Interrupt\",\n\t\t\t ATTENTION_SINGLE | ATTENTION_BB_DIFFERENT |\n\t\t\t ATTENTION_BB(AEU_INVERT_REG_SPECIAL_CNIG_1),\n\t\t\t NULL, BLOCK_NWS},\n\t\t\t{\"NWM Parity\",\n\t\t\t ATTENTION_PAR | ATTENTION_BB_DIFFERENT |\n\t\t\t ATTENTION_BB(AEU_INVERT_REG_SPECIAL_CNIG_2),\n\t\t\t NULL, BLOCK_NWM},\n\t\t\t{\"NWM Interrupt\",\n\t\t\t ATTENTION_SINGLE | ATTENTION_BB_DIFFERENT |\n\t\t\t ATTENTION_BB(AEU_INVERT_REG_SPECIAL_CNIG_3),\n\t\t\t NULL, BLOCK_NWM},\n\t\t\t{\"MCP CPU\", ATTENTION_SINGLE,\n\t\t\t qed_mcp_attn_cb, MAX_BLOCK_ID},\n\t\t\t{\"MCP Watchdog timer\", ATTENTION_SINGLE,\n\t\t\t NULL, MAX_BLOCK_ID},\n\t\t\t{\"MCP M2P\", ATTENTION_SINGLE, NULL, MAX_BLOCK_ID},\n\t\t\t{\"AVS stop status ready\", ATTENTION_SINGLE,\n\t\t\t NULL, MAX_BLOCK_ID},\n\t\t\t{\"MSTAT\", ATTENTION_PAR_INT, NULL, MAX_BLOCK_ID},\n\t\t\t{\"MSTAT per-path\", ATTENTION_PAR_INT,\n\t\t\t NULL, MAX_BLOCK_ID},\n\t\t\t{\"Reserved %d\", (6 << ATTENTION_LENGTH_SHIFT),\n\t\t\t NULL, MAX_BLOCK_ID},\n\t\t\t{\"NIG\", ATTENTION_PAR_INT, NULL, BLOCK_NIG},\n\t\t\t{\"BMB/OPTE/MCP\", ATTENTION_PAR_INT, NULL, BLOCK_BMB},\n\t\t\t{\"BTB\",\tATTENTION_PAR_INT, NULL, BLOCK_BTB},\n\t\t\t{\"BRB\",\tATTENTION_PAR_INT, NULL, BLOCK_BRB},\n\t\t\t{\"PRS\",\tATTENTION_PAR_INT, NULL, BLOCK_PRS},\n\t\t}\n\t},\n\n\t{\n\t\t{        \n\t\t\t{\"SRC\", ATTENTION_PAR_INT, NULL, BLOCK_SRC},\n\t\t\t{\"PB Client1\", ATTENTION_PAR_INT, NULL, BLOCK_PBF_PB1},\n\t\t\t{\"PB Client2\", ATTENTION_PAR_INT, NULL, BLOCK_PBF_PB2},\n\t\t\t{\"RPB\", ATTENTION_PAR_INT, NULL, BLOCK_RPB},\n\t\t\t{\"PBF\", ATTENTION_PAR_INT, NULL, BLOCK_PBF},\n\t\t\t{\"QM\", ATTENTION_PAR_INT, NULL, BLOCK_QM},\n\t\t\t{\"TM\", ATTENTION_PAR_INT, NULL, BLOCK_TM},\n\t\t\t{\"MCM\",  ATTENTION_PAR_INT, NULL, BLOCK_MCM},\n\t\t\t{\"MSDM\", ATTENTION_PAR_INT, NULL, BLOCK_MSDM},\n\t\t\t{\"MSEM\", ATTENTION_PAR_INT, NULL, BLOCK_MSEM},\n\t\t\t{\"PCM\", ATTENTION_PAR_INT, NULL, BLOCK_PCM},\n\t\t\t{\"PSDM\", ATTENTION_PAR_INT, NULL, BLOCK_PSDM},\n\t\t\t{\"PSEM\", ATTENTION_PAR_INT, NULL, BLOCK_PSEM},\n\t\t\t{\"TCM\", ATTENTION_PAR_INT, NULL, BLOCK_TCM},\n\t\t\t{\"TSDM\", ATTENTION_PAR_INT, NULL, BLOCK_TSDM},\n\t\t\t{\"TSEM\", ATTENTION_PAR_INT, NULL, BLOCK_TSEM},\n\t\t}\n\t},\n\n\t{\n\t\t{        \n\t\t\t{\"UCM\", ATTENTION_PAR_INT, NULL, BLOCK_UCM},\n\t\t\t{\"USDM\", ATTENTION_PAR_INT, NULL, BLOCK_USDM},\n\t\t\t{\"USEM\", ATTENTION_PAR_INT, NULL, BLOCK_USEM},\n\t\t\t{\"XCM\",\tATTENTION_PAR_INT, NULL, BLOCK_XCM},\n\t\t\t{\"XSDM\", ATTENTION_PAR_INT, NULL, BLOCK_XSDM},\n\t\t\t{\"XSEM\", ATTENTION_PAR_INT, NULL, BLOCK_XSEM},\n\t\t\t{\"YCM\",\tATTENTION_PAR_INT, NULL, BLOCK_YCM},\n\t\t\t{\"YSDM\", ATTENTION_PAR_INT, NULL, BLOCK_YSDM},\n\t\t\t{\"YSEM\", ATTENTION_PAR_INT, NULL, BLOCK_YSEM},\n\t\t\t{\"XYLD\", ATTENTION_PAR_INT, NULL, BLOCK_XYLD},\n\t\t\t{\"TMLD\", ATTENTION_PAR_INT, NULL, BLOCK_TMLD},\n\t\t\t{\"MYLD\", ATTENTION_PAR_INT, NULL, BLOCK_MULD},\n\t\t\t{\"YULD\", ATTENTION_PAR_INT, NULL, BLOCK_YULD},\n\t\t\t{\"DORQ\", ATTENTION_PAR_INT,\n\t\t\t qed_dorq_attn_cb, BLOCK_DORQ},\n\t\t\t{\"DBG\", ATTENTION_PAR_INT, NULL, BLOCK_DBG},\n\t\t\t{\"IPC\",\tATTENTION_PAR_INT, NULL, BLOCK_IPC},\n\t\t}\n\t},\n\n\t{\n\t\t{        \n\t\t\t{\"CCFC\", ATTENTION_PAR_INT, NULL, BLOCK_CCFC},\n\t\t\t{\"CDU\", ATTENTION_PAR_INT, NULL, BLOCK_CDU},\n\t\t\t{\"DMAE\", ATTENTION_PAR_INT, NULL, BLOCK_DMAE},\n\t\t\t{\"IGU\", ATTENTION_PAR_INT, NULL, BLOCK_IGU},\n\t\t\t{\"ATC\", ATTENTION_PAR_INT, NULL, MAX_BLOCK_ID},\n\t\t\t{\"CAU\", ATTENTION_PAR_INT, NULL, BLOCK_CAU},\n\t\t\t{\"PTU\", ATTENTION_PAR_INT, NULL, BLOCK_PTU},\n\t\t\t{\"PRM\", ATTENTION_PAR_INT, NULL, BLOCK_PRM},\n\t\t\t{\"TCFC\", ATTENTION_PAR_INT, NULL, BLOCK_TCFC},\n\t\t\t{\"RDIF\", ATTENTION_PAR_INT, NULL, BLOCK_RDIF},\n\t\t\t{\"TDIF\", ATTENTION_PAR_INT, NULL, BLOCK_TDIF},\n\t\t\t{\"RSS\", ATTENTION_PAR_INT, NULL, BLOCK_RSS},\n\t\t\t{\"MISC\", ATTENTION_PAR_INT, NULL, BLOCK_MISC},\n\t\t\t{\"MISCS\", ATTENTION_PAR_INT, NULL, BLOCK_MISCS},\n\t\t\t{\"PCIE\", ATTENTION_PAR, NULL, BLOCK_PCIE},\n\t\t\t{\"Vaux PCI core\", ATTENTION_SINGLE, NULL, BLOCK_PGLCS},\n\t\t\t{\"PSWRQ\", ATTENTION_PAR_INT, NULL, BLOCK_PSWRQ},\n\t\t}\n\t},\n\n\t{\n\t\t{        \n\t\t\t{\"PSWRQ (pci_clk)\", ATTENTION_PAR_INT,\n\t\t\t NULL, BLOCK_PSWRQ2},\n\t\t\t{\"PSWWR\", ATTENTION_PAR_INT, NULL, BLOCK_PSWWR},\n\t\t\t{\"PSWWR (pci_clk)\", ATTENTION_PAR_INT,\n\t\t\t NULL, BLOCK_PSWWR2},\n\t\t\t{\"PSWRD\", ATTENTION_PAR_INT, NULL, BLOCK_PSWRD},\n\t\t\t{\"PSWRD (pci_clk)\", ATTENTION_PAR_INT,\n\t\t\t NULL, BLOCK_PSWRD2},\n\t\t\t{\"PSWHST\", ATTENTION_PAR_INT,\n\t\t\t qed_pswhst_attn_cb, BLOCK_PSWHST},\n\t\t\t{\"PSWHST (pci_clk)\", ATTENTION_PAR_INT,\n\t\t\t NULL, BLOCK_PSWHST2},\n\t\t\t{\"GRC\",\tATTENTION_PAR_INT,\n\t\t\t qed_grc_attn_cb, BLOCK_GRC},\n\t\t\t{\"CPMU\", ATTENTION_PAR_INT, NULL, BLOCK_CPMU},\n\t\t\t{\"NCSI\", ATTENTION_PAR_INT, NULL, BLOCK_NCSI},\n\t\t\t{\"MSEM PRAM\", ATTENTION_PAR, NULL, MAX_BLOCK_ID},\n\t\t\t{\"PSEM PRAM\", ATTENTION_PAR, NULL, MAX_BLOCK_ID},\n\t\t\t{\"TSEM PRAM\", ATTENTION_PAR, NULL, MAX_BLOCK_ID},\n\t\t\t{\"USEM PRAM\", ATTENTION_PAR, NULL, MAX_BLOCK_ID},\n\t\t\t{\"XSEM PRAM\", ATTENTION_PAR, NULL, MAX_BLOCK_ID},\n\t\t\t{\"YSEM PRAM\", ATTENTION_PAR, NULL, MAX_BLOCK_ID},\n\t\t\t{\"pxp_misc_mps\", ATTENTION_PAR, NULL, BLOCK_PGLCS},\n\t\t\t{\"PCIE glue/PXP Exp. ROM\", ATTENTION_SINGLE,\n\t\t\t NULL, BLOCK_PGLCS},\n\t\t\t{\"PERST_B assertion\", ATTENTION_SINGLE,\n\t\t\t NULL, MAX_BLOCK_ID},\n\t\t\t{\"PERST_B deassertion\", ATTENTION_SINGLE,\n\t\t\t NULL, MAX_BLOCK_ID},\n\t\t\t{\"Reserved %d\", (2 << ATTENTION_LENGTH_SHIFT),\n\t\t\t NULL, MAX_BLOCK_ID},\n\t\t}\n\t},\n\n\t{\n\t\t{        \n\t\t\t{\"MCP Latched memory\", ATTENTION_PAR,\n\t\t\t NULL, MAX_BLOCK_ID},\n\t\t\t{\"MCP Latched scratchpad cache\", ATTENTION_SINGLE,\n\t\t\t NULL, MAX_BLOCK_ID},\n\t\t\t{\"MCP Latched ump_tx\", ATTENTION_PAR,\n\t\t\t NULL, MAX_BLOCK_ID},\n\t\t\t{\"MCP Latched scratchpad\", ATTENTION_PAR,\n\t\t\t NULL, MAX_BLOCK_ID},\n\t\t\t{\"Reserved %d\", (28 << ATTENTION_LENGTH_SHIFT),\n\t\t\t NULL, MAX_BLOCK_ID},\n\t\t}\n\t},\n};\n\nstatic struct aeu_invert_reg_bit *\nqed_int_aeu_translate(struct qed_hwfn *p_hwfn,\n\t\t      struct aeu_invert_reg_bit *p_bit)\n{\n\tif (!QED_IS_BB(p_hwfn->cdev))\n\t\treturn p_bit;\n\n\tif (!(p_bit->flags & ATTENTION_BB_DIFFERENT))\n\t\treturn p_bit;\n\n\treturn &aeu_descs_special[(p_bit->flags & ATTENTION_BB_MASK) >>\n\t\t\t\t  ATTENTION_BB_SHIFT];\n}\n\nstatic bool qed_int_is_parity_flag(struct qed_hwfn *p_hwfn,\n\t\t\t\t   struct aeu_invert_reg_bit *p_bit)\n{\n\treturn !!(qed_int_aeu_translate(p_hwfn, p_bit)->flags &\n\t\t   ATTENTION_PARITY);\n}\n\n#define ATTN_STATE_BITS         (0xfff)\n#define ATTN_BITS_MASKABLE      (0x3ff)\nstruct qed_sb_attn_info {\n\t \n\tstruct atten_status_block       *sb_attn;\n\tdma_addr_t\t\t\tsb_phys;\n\n\t \n\tu16\t\t\t\tindex;\n\n\t \n\tu32\t\t\t\tparity_mask[NUM_ATTN_REGS];\n\n\t \n\tstruct aeu_invert_reg\t\t*p_aeu_desc;\n\n\t \n\tu16\t\t\t\tknown_attn;\n\n\t \n\tu32\t\t\t\tmfw_attn_addr;\n};\n\nstatic inline u16 qed_attn_update_idx(struct qed_hwfn *p_hwfn,\n\t\t\t\t      struct qed_sb_attn_info *p_sb_desc)\n{\n\tu16 rc = 0, index;\n\n\tindex = le16_to_cpu(p_sb_desc->sb_attn->sb_index);\n\tif (p_sb_desc->index != index) {\n\t\tp_sb_desc->index\t= index;\n\t\trc\t\t      = QED_SB_ATT_IDX;\n\t}\n\n\treturn rc;\n}\n\n \nstatic int qed_int_assertion(struct qed_hwfn *p_hwfn, u16 asserted_bits)\n{\n\tstruct qed_sb_attn_info *sb_attn_sw = p_hwfn->p_sb_attn;\n\tu32 igu_mask;\n\n\t \n\tigu_mask = qed_rd(p_hwfn, p_hwfn->p_dpc_ptt, IGU_REG_ATTENTION_ENABLE);\n\tDP_VERBOSE(p_hwfn, NETIF_MSG_INTR, \"IGU mask: 0x%08x --> 0x%08x\\n\",\n\t\t   igu_mask, igu_mask & ~(asserted_bits & ATTN_BITS_MASKABLE));\n\tigu_mask &= ~(asserted_bits & ATTN_BITS_MASKABLE);\n\tqed_wr(p_hwfn, p_hwfn->p_dpc_ptt, IGU_REG_ATTENTION_ENABLE, igu_mask);\n\n\tDP_VERBOSE(p_hwfn, NETIF_MSG_INTR,\n\t\t   \"inner known ATTN state: 0x%04x --> 0x%04x\\n\",\n\t\t   sb_attn_sw->known_attn,\n\t\t   sb_attn_sw->known_attn | asserted_bits);\n\tsb_attn_sw->known_attn |= asserted_bits;\n\n\t \n\tif (asserted_bits & 0x100) {\n\t\tqed_mcp_handle_events(p_hwfn, p_hwfn->p_dpc_ptt);\n\t\t \n\t\tqed_wr(p_hwfn, p_hwfn->p_dpc_ptt,\n\t\t       sb_attn_sw->mfw_attn_addr, 0);\n\t}\n\n\tDIRECT_REG_WR((u8 __iomem *)p_hwfn->regview +\n\t\t      GTT_BAR0_MAP_REG_IGU_CMD +\n\t\t      ((IGU_CMD_ATTN_BIT_SET_UPPER -\n\t\t\tIGU_CMD_INT_ACK_BASE) << 3),\n\t\t      (u32)asserted_bits);\n\n\tDP_VERBOSE(p_hwfn, NETIF_MSG_INTR, \"set cmd IGU: 0x%04x\\n\",\n\t\t   asserted_bits);\n\n\treturn 0;\n}\n\nstatic void qed_int_attn_print(struct qed_hwfn *p_hwfn,\n\t\t\t       enum block_id id,\n\t\t\t       enum dbg_attn_type type, bool b_clear)\n{\n\tstruct dbg_attn_block_result attn_results;\n\tenum dbg_status status;\n\n\tmemset(&attn_results, 0, sizeof(attn_results));\n\n\tstatus = qed_dbg_read_attn(p_hwfn, p_hwfn->p_dpc_ptt, id, type,\n\t\t\t\t   b_clear, &attn_results);\n\tif (status != DBG_STATUS_OK)\n\t\tDP_NOTICE(p_hwfn,\n\t\t\t  \"Failed to parse attention information [status: %s]\\n\",\n\t\t\t  qed_dbg_get_status_str(status));\n\telse\n\t\tqed_dbg_parse_attn(p_hwfn, &attn_results);\n}\n\n \nstatic int\nqed_int_deassertion_aeu_bit(struct qed_hwfn *p_hwfn,\n\t\t\t    struct aeu_invert_reg_bit *p_aeu,\n\t\t\t    u32 aeu_en_reg,\n\t\t\t    const char *p_bit_name, u32 bitmask)\n{\n\tbool b_fatal = false;\n\tint rc = -EINVAL;\n\tu32 val;\n\n\tDP_INFO(p_hwfn, \"Deasserted attention `%s'[%08x]\\n\",\n\t\tp_bit_name, bitmask);\n\n\t \n\tif (p_aeu->cb) {\n\t\tDP_INFO(p_hwfn, \"`%s (attention)': Calling Callback function\\n\",\n\t\t\tp_bit_name);\n\t\trc = p_aeu->cb(p_hwfn);\n\t}\n\n\tif (rc)\n\t\tb_fatal = true;\n\n\t \n\tif (p_aeu->block_index != MAX_BLOCK_ID)\n\t\tqed_int_attn_print(p_hwfn, p_aeu->block_index,\n\t\t\t\t   ATTN_TYPE_INTERRUPT, !b_fatal);\n\n\t \n\tif (b_fatal)\n\t\tqed_hw_err_notify(p_hwfn, p_hwfn->p_dpc_ptt, QED_HW_ERR_HW_ATTN,\n\t\t\t\t  \"`%s': Fatal attention\\n\",\n\t\t\t\t  p_bit_name);\n\telse  \n\t\tgoto out;\n\n\t \n\tval = qed_rd(p_hwfn, p_hwfn->p_dpc_ptt, aeu_en_reg);\n\tqed_wr(p_hwfn, p_hwfn->p_dpc_ptt, aeu_en_reg, (val & ~bitmask));\n\tDP_INFO(p_hwfn, \"`%s' - Disabled future attentions\\n\",\n\t\tp_bit_name);\n\n\t \n\tval = qed_rd(p_hwfn, p_hwfn->p_dpc_ptt,\n\t\t     MISC_REG_AEU_ENABLE4_IGU_OUT_0);\n\tval |= MISC_REG_AEU_ENABLE4_IGU_OUT_0_GENERAL_ATTN32;\n\tqed_wr(p_hwfn, p_hwfn->p_dpc_ptt,\n\t       MISC_REG_AEU_ENABLE4_IGU_OUT_0, val);\n\nout:\n\treturn rc;\n}\n\n \nstatic void qed_int_deassertion_parity(struct qed_hwfn *p_hwfn,\n\t\t\t\t       struct aeu_invert_reg_bit *p_aeu,\n\t\t\t\t       u32 aeu_en_reg, u8 bit_index)\n{\n\tu32 block_id = p_aeu->block_index, mask, val;\n\n\tDP_NOTICE(p_hwfn->cdev,\n\t\t  \"%s parity attention is set [address 0x%08x, bit %d]\\n\",\n\t\t  p_aeu->bit_name, aeu_en_reg, bit_index);\n\n\tif (block_id != MAX_BLOCK_ID) {\n\t\tqed_int_attn_print(p_hwfn, block_id, ATTN_TYPE_PARITY, false);\n\n\t\t \n\t\tif (block_id == BLOCK_BTB) {\n\t\t\tqed_int_attn_print(p_hwfn, BLOCK_OPTE,\n\t\t\t\t\t   ATTN_TYPE_PARITY, false);\n\t\t\tqed_int_attn_print(p_hwfn, BLOCK_MCP,\n\t\t\t\t\t   ATTN_TYPE_PARITY, false);\n\t\t}\n\t}\n\n\t \n\tmask = ~BIT(bit_index);\n\tval = qed_rd(p_hwfn, p_hwfn->p_dpc_ptt, aeu_en_reg);\n\tqed_wr(p_hwfn, p_hwfn->p_dpc_ptt, aeu_en_reg, val & mask);\n\tDP_INFO(p_hwfn, \"`%s' - Disabled future parity errors\\n\",\n\t\tp_aeu->bit_name);\n}\n\n \nstatic int qed_int_deassertion(struct qed_hwfn  *p_hwfn,\n\t\t\t       u16 deasserted_bits)\n{\n\tstruct qed_sb_attn_info *sb_attn_sw = p_hwfn->p_sb_attn;\n\tu32 aeu_inv_arr[NUM_ATTN_REGS], aeu_mask, aeu_en, en;\n\tu8 i, j, k, bit_idx;\n\tint rc = 0;\n\n\t \n\tfor (i = 0; i < NUM_ATTN_REGS; i++) {\n\t\taeu_inv_arr[i] = qed_rd(p_hwfn, p_hwfn->p_dpc_ptt,\n\t\t\t\t\tMISC_REG_AEU_AFTER_INVERT_1_IGU +\n\t\t\t\t\ti * 0x4);\n\t\tDP_VERBOSE(p_hwfn, NETIF_MSG_INTR,\n\t\t\t   \"Deasserted bits [%d]: %08x\\n\",\n\t\t\t   i, aeu_inv_arr[i]);\n\t}\n\n\t \n\tfor (i = 0; i < NUM_ATTN_REGS; i++) {\n\t\tstruct aeu_invert_reg *p_aeu = &sb_attn_sw->p_aeu_desc[i];\n\t\tu32 parities;\n\n\t\taeu_en = MISC_REG_AEU_ENABLE1_IGU_OUT_0 + i * sizeof(u32);\n\t\ten = qed_rd(p_hwfn, p_hwfn->p_dpc_ptt, aeu_en);\n\n\t\t \n\t\tparities = sb_attn_sw->parity_mask[i] & aeu_inv_arr[i] & en;\n\t\tif (!parities)\n\t\t\tcontinue;\n\n\t\tfor (j = 0, bit_idx = 0; bit_idx < 32 && j < 32; j++) {\n\t\t\tstruct aeu_invert_reg_bit *p_bit = &p_aeu->bits[j];\n\n\t\t\tif (qed_int_is_parity_flag(p_hwfn, p_bit) &&\n\t\t\t    !!(parities & BIT(bit_idx)))\n\t\t\t\tqed_int_deassertion_parity(p_hwfn, p_bit,\n\t\t\t\t\t\t\t   aeu_en, bit_idx);\n\n\t\t\tbit_idx += ATTENTION_LENGTH(p_bit->flags);\n\t\t}\n\t}\n\n\t \n\tfor (k = 0; k < MAX_ATTN_GRPS; k++) {\n\t\tstruct aeu_invert_reg_bit *p_aeu;\n\n\t\t \n\t\tif (!(deasserted_bits & (1 << k)))\n\t\t\tcontinue;\n\n\t\tfor (i = 0; i < NUM_ATTN_REGS; i++) {\n\t\t\tu32 bits;\n\n\t\t\taeu_en = MISC_REG_AEU_ENABLE1_IGU_OUT_0 +\n\t\t\t\t i * sizeof(u32) +\n\t\t\t\t k * sizeof(u32) * NUM_ATTN_REGS;\n\n\t\t\ten = qed_rd(p_hwfn, p_hwfn->p_dpc_ptt, aeu_en);\n\t\t\tbits = aeu_inv_arr[i] & en;\n\n\t\t\t \n\t\t\tif (!bits)\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tfor (j = 0, bit_idx = 0; bit_idx < 32 && j < 32; j++) {\n\t\t\t\tlong unsigned int bitmask;\n\t\t\t\tu8 bit, bit_len;\n\n\t\t\t\tp_aeu = &sb_attn_sw->p_aeu_desc[i].bits[j];\n\t\t\t\tp_aeu = qed_int_aeu_translate(p_hwfn, p_aeu);\n\n\t\t\t\tbit = bit_idx;\n\t\t\t\tbit_len = ATTENTION_LENGTH(p_aeu->flags);\n\t\t\t\tif (qed_int_is_parity_flag(p_hwfn, p_aeu)) {\n\t\t\t\t\t \n\t\t\t\t\tbit++;\n\t\t\t\t\tbit_len--;\n\t\t\t\t}\n\n\t\t\t\tbitmask = bits & (((1 << bit_len) - 1) << bit);\n\t\t\t\tbitmask >>= bit;\n\n\t\t\t\tif (bitmask) {\n\t\t\t\t\tu32 flags = p_aeu->flags;\n\t\t\t\t\tchar bit_name[30];\n\t\t\t\t\tu8 num;\n\n\t\t\t\t\tnum = (u8)find_first_bit(&bitmask,\n\t\t\t\t\t\t\t\t bit_len);\n\n\t\t\t\t\t \n\t\t\t\t\tif (ATTENTION_LENGTH(flags) > 2 ||\n\t\t\t\t\t    ((flags & ATTENTION_PAR_INT) &&\n\t\t\t\t\t     ATTENTION_LENGTH(flags) > 1))\n\t\t\t\t\t\tsnprintf(bit_name, 30,\n\t\t\t\t\t\t\t p_aeu->bit_name, num);\n\t\t\t\t\telse\n\t\t\t\t\t\tstrscpy(bit_name,\n\t\t\t\t\t\t\tp_aeu->bit_name, 30);\n\n\t\t\t\t\t \n\t\t\t\t\tbitmask <<= bit;\n\n\t\t\t\t\t \n\t\t\t\t\tqed_int_deassertion_aeu_bit(p_hwfn,\n\t\t\t\t\t\t\t\t    p_aeu,\n\t\t\t\t\t\t\t\t    aeu_en,\n\t\t\t\t\t\t\t\t    bit_name,\n\t\t\t\t\t\t\t\t    bitmask);\n\t\t\t\t}\n\n\t\t\t\tbit_idx += ATTENTION_LENGTH(p_aeu->flags);\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tqed_dorq_attn_handler(p_hwfn);\n\n\t \n\tDIRECT_REG_WR((u8 __iomem *)p_hwfn->regview +\n\t\t\t\t    GTT_BAR0_MAP_REG_IGU_CMD +\n\t\t\t\t    ((IGU_CMD_ATTN_BIT_CLR_UPPER -\n\t\t\t\t      IGU_CMD_INT_ACK_BASE) << 3),\n\t\t\t\t    ~((u32)deasserted_bits));\n\n\t \n\taeu_mask = qed_rd(p_hwfn, p_hwfn->p_dpc_ptt, IGU_REG_ATTENTION_ENABLE);\n\taeu_mask |= (deasserted_bits & ATTN_BITS_MASKABLE);\n\tqed_wr(p_hwfn, p_hwfn->p_dpc_ptt, IGU_REG_ATTENTION_ENABLE, aeu_mask);\n\n\t \n\tsb_attn_sw->known_attn &= ~deasserted_bits;\n\n\treturn rc;\n}\n\nstatic int qed_int_attentions(struct qed_hwfn *p_hwfn)\n{\n\tstruct qed_sb_attn_info *p_sb_attn_sw = p_hwfn->p_sb_attn;\n\tstruct atten_status_block *p_sb_attn = p_sb_attn_sw->sb_attn;\n\tu32 attn_bits = 0, attn_acks = 0;\n\tu16 asserted_bits, deasserted_bits;\n\t__le16 index;\n\tint rc = 0;\n\n\t \n\tdo {\n\t\tindex = p_sb_attn->sb_index;\n\t\t \n\t\tdma_rmb();\n\t\tattn_bits = le32_to_cpu(p_sb_attn->atten_bits);\n\t\tattn_acks = le32_to_cpu(p_sb_attn->atten_ack);\n\t} while (index != p_sb_attn->sb_index);\n\tp_sb_attn->sb_index = index;\n\n\t \n\tasserted_bits = (attn_bits & ~attn_acks & ATTN_STATE_BITS) &\n\t\t~p_sb_attn_sw->known_attn;\n\tdeasserted_bits = (~attn_bits & attn_acks & ATTN_STATE_BITS) &\n\t\tp_sb_attn_sw->known_attn;\n\n\tif ((asserted_bits & ~0x100) || (deasserted_bits & ~0x100)) {\n\t\tDP_INFO(p_hwfn,\n\t\t\t\"Attention: Index: 0x%04x, Bits: 0x%08x, Acks: 0x%08x, asserted: 0x%04x, De-asserted 0x%04x [Prev. known: 0x%04x]\\n\",\n\t\t\tindex, attn_bits, attn_acks, asserted_bits,\n\t\t\tdeasserted_bits, p_sb_attn_sw->known_attn);\n\t} else if (asserted_bits == 0x100) {\n\t\tDP_VERBOSE(p_hwfn, NETIF_MSG_INTR,\n\t\t\t   \"MFW indication via attention\\n\");\n\t} else {\n\t\tDP_VERBOSE(p_hwfn, NETIF_MSG_INTR,\n\t\t\t   \"MFW indication [deassertion]\\n\");\n\t}\n\n\tif (asserted_bits) {\n\t\trc = qed_int_assertion(p_hwfn, asserted_bits);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\tif (deasserted_bits)\n\t\trc = qed_int_deassertion(p_hwfn, deasserted_bits);\n\n\treturn rc;\n}\n\nstatic void qed_sb_ack_attn(struct qed_hwfn *p_hwfn,\n\t\t\t    void __iomem *igu_addr, u32 ack_cons)\n{\n\tu32 igu_ack;\n\n\tigu_ack = ((ack_cons << IGU_PROD_CONS_UPDATE_SB_INDEX_SHIFT) |\n\t\t   (1 << IGU_PROD_CONS_UPDATE_UPDATE_FLAG_SHIFT) |\n\t\t   (IGU_INT_NOP << IGU_PROD_CONS_UPDATE_ENABLE_INT_SHIFT) |\n\t\t   (IGU_SEG_ACCESS_ATTN <<\n\t\t    IGU_PROD_CONS_UPDATE_SEGMENT_ACCESS_SHIFT));\n\n\tDIRECT_REG_WR(igu_addr, igu_ack);\n\n\t \n\tbarrier();\n}\n\nvoid qed_int_sp_dpc(struct tasklet_struct *t)\n{\n\tstruct qed_hwfn *p_hwfn = from_tasklet(p_hwfn, t, sp_dpc);\n\tstruct qed_pi_info *pi_info = NULL;\n\tstruct qed_sb_attn_info *sb_attn;\n\tstruct qed_sb_info *sb_info;\n\tint arr_size;\n\tu16 rc = 0;\n\n\tif (!p_hwfn->p_sp_sb) {\n\t\tDP_ERR(p_hwfn->cdev, \"DPC called - no p_sp_sb\\n\");\n\t\treturn;\n\t}\n\n\tsb_info = &p_hwfn->p_sp_sb->sb_info;\n\tarr_size = ARRAY_SIZE(p_hwfn->p_sp_sb->pi_info_arr);\n\tif (!sb_info) {\n\t\tDP_ERR(p_hwfn->cdev,\n\t\t       \"Status block is NULL - cannot ack interrupts\\n\");\n\t\treturn;\n\t}\n\n\tif (!p_hwfn->p_sb_attn) {\n\t\tDP_ERR(p_hwfn->cdev, \"DPC called - no p_sb_attn\");\n\t\treturn;\n\t}\n\tsb_attn = p_hwfn->p_sb_attn;\n\n\tDP_VERBOSE(p_hwfn, NETIF_MSG_INTR, \"DPC Called! (hwfn %p %d)\\n\",\n\t\t   p_hwfn, p_hwfn->my_id);\n\n\t \n\tqed_sb_ack(sb_info, IGU_INT_DISABLE, 0);\n\n\t \n\tif (!sb_info->sb_virt) {\n\t\tDP_ERR(p_hwfn->cdev,\n\t\t       \"Interrupt Status block is NULL - cannot check for new interrupts!\\n\");\n\t} else {\n\t\tu32 tmp_index = sb_info->sb_ack;\n\n\t\trc = qed_sb_update_sb_idx(sb_info);\n\t\tDP_VERBOSE(p_hwfn->cdev, NETIF_MSG_INTR,\n\t\t\t   \"Interrupt indices: 0x%08x --> 0x%08x\\n\",\n\t\t\t   tmp_index, sb_info->sb_ack);\n\t}\n\n\tif (!sb_attn || !sb_attn->sb_attn) {\n\t\tDP_ERR(p_hwfn->cdev,\n\t\t       \"Attentions Status block is NULL - cannot check for new attentions!\\n\");\n\t} else {\n\t\tu16 tmp_index = sb_attn->index;\n\n\t\trc |= qed_attn_update_idx(p_hwfn, sb_attn);\n\t\tDP_VERBOSE(p_hwfn->cdev, NETIF_MSG_INTR,\n\t\t\t   \"Attention indices: 0x%08x --> 0x%08x\\n\",\n\t\t\t   tmp_index, sb_attn->index);\n\t}\n\n\t \n\tif (!(rc & QED_SB_EVENT_MASK)) {\n\t\tqed_sb_ack(sb_info, IGU_INT_ENABLE, 1);\n\t\treturn;\n\t}\n\n\t \n\tif (!p_hwfn->p_dpc_ptt) {\n\t\tDP_NOTICE(p_hwfn->cdev, \"Failed to allocate PTT\\n\");\n\t\tqed_sb_ack(sb_info, IGU_INT_ENABLE, 1);\n\t\treturn;\n\t}\n\n\tif (rc & QED_SB_ATT_IDX)\n\t\tqed_int_attentions(p_hwfn);\n\n\tif (rc & QED_SB_IDX) {\n\t\tint pi;\n\n\t\t \n\t\tfor (pi = 0; pi < arr_size; pi++) {\n\t\t\tpi_info = &p_hwfn->p_sp_sb->pi_info_arr[pi];\n\t\t\tif (pi_info->comp_cb)\n\t\t\t\tpi_info->comp_cb(p_hwfn, pi_info->cookie);\n\t\t}\n\t}\n\n\tif (sb_attn && (rc & QED_SB_ATT_IDX))\n\t\t \n\t\tqed_sb_ack_attn(p_hwfn, sb_info->igu_addr, sb_attn->index);\n\n\tqed_sb_ack(sb_info, IGU_INT_ENABLE, 1);\n}\n\nstatic void qed_int_sb_attn_free(struct qed_hwfn *p_hwfn)\n{\n\tstruct qed_sb_attn_info *p_sb = p_hwfn->p_sb_attn;\n\n\tif (!p_sb)\n\t\treturn;\n\n\tif (p_sb->sb_attn)\n\t\tdma_free_coherent(&p_hwfn->cdev->pdev->dev,\n\t\t\t\t  SB_ATTN_ALIGNED_SIZE(p_hwfn),\n\t\t\t\t  p_sb->sb_attn, p_sb->sb_phys);\n\tkfree(p_sb);\n\tp_hwfn->p_sb_attn = NULL;\n}\n\nstatic void qed_int_sb_attn_setup(struct qed_hwfn *p_hwfn,\n\t\t\t\t  struct qed_ptt *p_ptt)\n{\n\tstruct qed_sb_attn_info *sb_info = p_hwfn->p_sb_attn;\n\n\tmemset(sb_info->sb_attn, 0, sizeof(*sb_info->sb_attn));\n\n\tsb_info->index = 0;\n\tsb_info->known_attn = 0;\n\n\t \n\tqed_wr(p_hwfn, p_ptt, IGU_REG_ATTN_MSG_ADDR_L,\n\t       lower_32_bits(p_hwfn->p_sb_attn->sb_phys));\n\tqed_wr(p_hwfn, p_ptt, IGU_REG_ATTN_MSG_ADDR_H,\n\t       upper_32_bits(p_hwfn->p_sb_attn->sb_phys));\n}\n\nstatic void qed_int_sb_attn_init(struct qed_hwfn *p_hwfn,\n\t\t\t\t struct qed_ptt *p_ptt,\n\t\t\t\t void *sb_virt_addr, dma_addr_t sb_phy_addr)\n{\n\tstruct qed_sb_attn_info *sb_info = p_hwfn->p_sb_attn;\n\tint i, j, k;\n\n\tsb_info->sb_attn = sb_virt_addr;\n\tsb_info->sb_phys = sb_phy_addr;\n\n\t \n\tsb_info->p_aeu_desc = aeu_descs;\n\n\t \n\tmemset(sb_info->parity_mask, 0, sizeof(u32) * NUM_ATTN_REGS);\n\tfor (i = 0; i < NUM_ATTN_REGS; i++) {\n\t\t \n\t\tfor (j = 0, k = 0; k < 32 && j < 32; j++) {\n\t\t\tstruct aeu_invert_reg_bit *p_aeu;\n\n\t\t\tp_aeu = &aeu_descs[i].bits[j];\n\t\t\tif (qed_int_is_parity_flag(p_hwfn, p_aeu))\n\t\t\t\tsb_info->parity_mask[i] |= 1 << k;\n\n\t\t\tk += ATTENTION_LENGTH(p_aeu->flags);\n\t\t}\n\t\tDP_VERBOSE(p_hwfn, NETIF_MSG_INTR,\n\t\t\t   \"Attn Mask [Reg %d]: 0x%08x\\n\",\n\t\t\t   i, sb_info->parity_mask[i]);\n\t}\n\n\t \n\tsb_info->mfw_attn_addr = (p_hwfn->rel_pf_id << 3) +\n\t\t\t\t MISC_REG_AEU_GENERAL_ATTN_0;\n\n\tqed_int_sb_attn_setup(p_hwfn, p_ptt);\n}\n\nstatic int qed_int_sb_attn_alloc(struct qed_hwfn *p_hwfn,\n\t\t\t\t struct qed_ptt *p_ptt)\n{\n\tstruct qed_dev *cdev = p_hwfn->cdev;\n\tstruct qed_sb_attn_info *p_sb;\n\tdma_addr_t p_phys = 0;\n\tvoid *p_virt;\n\n\t \n\tp_sb = kmalloc(sizeof(*p_sb), GFP_KERNEL);\n\tif (!p_sb)\n\t\treturn -ENOMEM;\n\n\t \n\tp_virt = dma_alloc_coherent(&cdev->pdev->dev,\n\t\t\t\t    SB_ATTN_ALIGNED_SIZE(p_hwfn),\n\t\t\t\t    &p_phys, GFP_KERNEL);\n\n\tif (!p_virt) {\n\t\tkfree(p_sb);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tp_hwfn->p_sb_attn = p_sb;\n\tqed_int_sb_attn_init(p_hwfn, p_ptt, p_virt, p_phys);\n\n\treturn 0;\n}\n\n \n#define QED_CAU_DEF_RX_USECS 24\n#define QED_CAU_DEF_TX_USECS 48\n\nvoid qed_init_cau_sb_entry(struct qed_hwfn *p_hwfn,\n\t\t\t   struct cau_sb_entry *p_sb_entry,\n\t\t\t   u8 pf_id, u16 vf_number, u8 vf_valid)\n{\n\tstruct qed_dev *cdev = p_hwfn->cdev;\n\tu32 cau_state, params = 0, data = 0;\n\tu8 timer_res;\n\n\tmemset(p_sb_entry, 0, sizeof(*p_sb_entry));\n\n\tSET_FIELD(params, CAU_SB_ENTRY_PF_NUMBER, pf_id);\n\tSET_FIELD(params, CAU_SB_ENTRY_VF_NUMBER, vf_number);\n\tSET_FIELD(params, CAU_SB_ENTRY_VF_VALID, vf_valid);\n\tSET_FIELD(params, CAU_SB_ENTRY_SB_TIMESET0, 0x7F);\n\tSET_FIELD(params, CAU_SB_ENTRY_SB_TIMESET1, 0x7F);\n\n\tcau_state = CAU_HC_DISABLE_STATE;\n\n\tif (cdev->int_coalescing_mode == QED_COAL_MODE_ENABLE) {\n\t\tcau_state = CAU_HC_ENABLE_STATE;\n\t\tif (!cdev->rx_coalesce_usecs)\n\t\t\tcdev->rx_coalesce_usecs = QED_CAU_DEF_RX_USECS;\n\t\tif (!cdev->tx_coalesce_usecs)\n\t\t\tcdev->tx_coalesce_usecs = QED_CAU_DEF_TX_USECS;\n\t}\n\n\t \n\tif (cdev->rx_coalesce_usecs <= 0x7F)\n\t\ttimer_res = 0;\n\telse if (cdev->rx_coalesce_usecs <= 0xFF)\n\t\ttimer_res = 1;\n\telse\n\t\ttimer_res = 2;\n\n\tSET_FIELD(params, CAU_SB_ENTRY_TIMER_RES0, timer_res);\n\n\tif (cdev->tx_coalesce_usecs <= 0x7F)\n\t\ttimer_res = 0;\n\telse if (cdev->tx_coalesce_usecs <= 0xFF)\n\t\ttimer_res = 1;\n\telse\n\t\ttimer_res = 2;\n\n\tSET_FIELD(params, CAU_SB_ENTRY_TIMER_RES1, timer_res);\n\tp_sb_entry->params = cpu_to_le32(params);\n\n\tSET_FIELD(data, CAU_SB_ENTRY_STATE0, cau_state);\n\tSET_FIELD(data, CAU_SB_ENTRY_STATE1, cau_state);\n\tp_sb_entry->data = cpu_to_le32(data);\n}\n\nstatic void qed_int_cau_conf_pi(struct qed_hwfn *p_hwfn,\n\t\t\t\tstruct qed_ptt *p_ptt,\n\t\t\t\tu16 igu_sb_id,\n\t\t\t\tu32 pi_index,\n\t\t\t\tenum qed_coalescing_fsm coalescing_fsm,\n\t\t\t\tu8 timeset)\n{\n\tu32 sb_offset, pi_offset;\n\tu32 prod = 0;\n\n\tif (IS_VF(p_hwfn->cdev))\n\t\treturn;\n\n\tSET_FIELD(prod, CAU_PI_ENTRY_PI_TIMESET, timeset);\n\tif (coalescing_fsm == QED_COAL_RX_STATE_MACHINE)\n\t\tSET_FIELD(prod, CAU_PI_ENTRY_FSM_SEL, 0);\n\telse\n\t\tSET_FIELD(prod, CAU_PI_ENTRY_FSM_SEL, 1);\n\n\tsb_offset = igu_sb_id * PIS_PER_SB;\n\tpi_offset = sb_offset + pi_index;\n\n\tif (p_hwfn->hw_init_done)\n\t\tqed_wr(p_hwfn, p_ptt,\n\t\t       CAU_REG_PI_MEMORY + pi_offset * sizeof(u32), prod);\n\telse\n\t\tSTORE_RT_REG(p_hwfn, CAU_REG_PI_MEMORY_RT_OFFSET + pi_offset,\n\t\t\t     prod);\n}\n\nvoid qed_int_cau_conf_sb(struct qed_hwfn *p_hwfn,\n\t\t\t struct qed_ptt *p_ptt,\n\t\t\t dma_addr_t sb_phys,\n\t\t\t u16 igu_sb_id, u16 vf_number, u8 vf_valid)\n{\n\tstruct cau_sb_entry sb_entry;\n\n\tqed_init_cau_sb_entry(p_hwfn, &sb_entry, p_hwfn->rel_pf_id,\n\t\t\t      vf_number, vf_valid);\n\n\tif (p_hwfn->hw_init_done) {\n\t\t \n\t\tu64 phys_addr = (u64)sb_phys;\n\n\t\tqed_dmae_host2grc(p_hwfn, p_ptt, (u64)(uintptr_t)&phys_addr,\n\t\t\t\t  CAU_REG_SB_ADDR_MEMORY +\n\t\t\t\t  igu_sb_id * sizeof(u64), 2, NULL);\n\t\tqed_dmae_host2grc(p_hwfn, p_ptt, (u64)(uintptr_t)&sb_entry,\n\t\t\t\t  CAU_REG_SB_VAR_MEMORY +\n\t\t\t\t  igu_sb_id * sizeof(u64), 2, NULL);\n\t} else {\n\t\t \n\t\tSTORE_RT_REG_AGG(p_hwfn,\n\t\t\t\t CAU_REG_SB_ADDR_MEMORY_RT_OFFSET +\n\t\t\t\t igu_sb_id * 2,\n\t\t\t\t sb_phys);\n\n\t\tSTORE_RT_REG_AGG(p_hwfn,\n\t\t\t\t CAU_REG_SB_VAR_MEMORY_RT_OFFSET +\n\t\t\t\t igu_sb_id * 2,\n\t\t\t\t sb_entry);\n\t}\n\n\t \n\tif (p_hwfn->cdev->int_coalescing_mode == QED_COAL_MODE_ENABLE) {\n\t\tu8 num_tc = p_hwfn->hw_info.num_hw_tc;\n\t\tu8 timeset, timer_res;\n\t\tu8 i;\n\n\t\t \n\t\tif (p_hwfn->cdev->rx_coalesce_usecs <= 0x7F)\n\t\t\ttimer_res = 0;\n\t\telse if (p_hwfn->cdev->rx_coalesce_usecs <= 0xFF)\n\t\t\ttimer_res = 1;\n\t\telse\n\t\t\ttimer_res = 2;\n\t\ttimeset = (u8)(p_hwfn->cdev->rx_coalesce_usecs >> timer_res);\n\t\tqed_int_cau_conf_pi(p_hwfn, p_ptt, igu_sb_id, RX_PI,\n\t\t\t\t    QED_COAL_RX_STATE_MACHINE, timeset);\n\n\t\tif (p_hwfn->cdev->tx_coalesce_usecs <= 0x7F)\n\t\t\ttimer_res = 0;\n\t\telse if (p_hwfn->cdev->tx_coalesce_usecs <= 0xFF)\n\t\t\ttimer_res = 1;\n\t\telse\n\t\t\ttimer_res = 2;\n\t\ttimeset = (u8)(p_hwfn->cdev->tx_coalesce_usecs >> timer_res);\n\t\tfor (i = 0; i < num_tc; i++) {\n\t\t\tqed_int_cau_conf_pi(p_hwfn, p_ptt,\n\t\t\t\t\t    igu_sb_id, TX_PI(i),\n\t\t\t\t\t    QED_COAL_TX_STATE_MACHINE,\n\t\t\t\t\t    timeset);\n\t\t}\n\t}\n}\n\nvoid qed_int_sb_setup(struct qed_hwfn *p_hwfn,\n\t\t      struct qed_ptt *p_ptt, struct qed_sb_info *sb_info)\n{\n\t \n\tsb_info->sb_ack = 0;\n\tmemset(sb_info->sb_virt, 0, sizeof(*sb_info->sb_virt));\n\n\tif (IS_PF(p_hwfn->cdev))\n\t\tqed_int_cau_conf_sb(p_hwfn, p_ptt, sb_info->sb_phys,\n\t\t\t\t    sb_info->igu_sb_id, 0, 0);\n}\n\nstruct qed_igu_block *qed_get_igu_free_sb(struct qed_hwfn *p_hwfn, bool b_is_pf)\n{\n\tstruct qed_igu_block *p_block;\n\tu16 igu_id;\n\n\tfor (igu_id = 0; igu_id < QED_MAPPING_MEMORY_SIZE(p_hwfn->cdev);\n\t     igu_id++) {\n\t\tp_block = &p_hwfn->hw_info.p_igu_info->entry[igu_id];\n\n\t\tif (!(p_block->status & QED_IGU_STATUS_VALID) ||\n\t\t    !(p_block->status & QED_IGU_STATUS_FREE))\n\t\t\tcontinue;\n\n\t\tif (!!(p_block->status & QED_IGU_STATUS_PF) == b_is_pf)\n\t\t\treturn p_block;\n\t}\n\n\treturn NULL;\n}\n\nstatic u16 qed_get_pf_igu_sb_id(struct qed_hwfn *p_hwfn, u16 vector_id)\n{\n\tstruct qed_igu_block *p_block;\n\tu16 igu_id;\n\n\tfor (igu_id = 0; igu_id < QED_MAPPING_MEMORY_SIZE(p_hwfn->cdev);\n\t     igu_id++) {\n\t\tp_block = &p_hwfn->hw_info.p_igu_info->entry[igu_id];\n\n\t\tif (!(p_block->status & QED_IGU_STATUS_VALID) ||\n\t\t    !p_block->is_pf ||\n\t\t    p_block->vector_number != vector_id)\n\t\t\tcontinue;\n\n\t\treturn igu_id;\n\t}\n\n\treturn QED_SB_INVALID_IDX;\n}\n\nu16 qed_get_igu_sb_id(struct qed_hwfn *p_hwfn, u16 sb_id)\n{\n\tu16 igu_sb_id;\n\n\t \n\tif (sb_id == QED_SP_SB_ID)\n\t\tigu_sb_id = p_hwfn->hw_info.p_igu_info->igu_dsb_id;\n\telse if (IS_PF(p_hwfn->cdev))\n\t\tigu_sb_id = qed_get_pf_igu_sb_id(p_hwfn, sb_id + 1);\n\telse\n\t\tigu_sb_id = qed_vf_get_igu_sb_id(p_hwfn, sb_id);\n\n\tif (sb_id == QED_SP_SB_ID)\n\t\tDP_VERBOSE(p_hwfn, NETIF_MSG_INTR,\n\t\t\t   \"Slowpath SB index in IGU is 0x%04x\\n\", igu_sb_id);\n\telse\n\t\tDP_VERBOSE(p_hwfn, NETIF_MSG_INTR,\n\t\t\t   \"SB [%04x] <--> IGU SB [%04x]\\n\", sb_id, igu_sb_id);\n\n\treturn igu_sb_id;\n}\n\nint qed_int_sb_init(struct qed_hwfn *p_hwfn,\n\t\t    struct qed_ptt *p_ptt,\n\t\t    struct qed_sb_info *sb_info,\n\t\t    void *sb_virt_addr, dma_addr_t sb_phy_addr, u16 sb_id)\n{\n\tsb_info->sb_virt = sb_virt_addr;\n\tsb_info->sb_phys = sb_phy_addr;\n\n\tsb_info->igu_sb_id = qed_get_igu_sb_id(p_hwfn, sb_id);\n\n\tif (sb_id != QED_SP_SB_ID) {\n\t\tif (IS_PF(p_hwfn->cdev)) {\n\t\t\tstruct qed_igu_info *p_info;\n\t\t\tstruct qed_igu_block *p_block;\n\n\t\t\tp_info = p_hwfn->hw_info.p_igu_info;\n\t\t\tp_block = &p_info->entry[sb_info->igu_sb_id];\n\n\t\t\tp_block->sb_info = sb_info;\n\t\t\tp_block->status &= ~QED_IGU_STATUS_FREE;\n\t\t\tp_info->usage.free_cnt--;\n\t\t} else {\n\t\t\tqed_vf_set_sb_info(p_hwfn, sb_id, sb_info);\n\t\t}\n\t}\n\n\tsb_info->cdev = p_hwfn->cdev;\n\n\t \n\tif (IS_PF(p_hwfn->cdev)) {\n\t\tsb_info->igu_addr = (u8 __iomem *)p_hwfn->regview +\n\t\t\t\t\t\t  GTT_BAR0_MAP_REG_IGU_CMD +\n\t\t\t\t\t\t  (sb_info->igu_sb_id << 3);\n\t} else {\n\t\tsb_info->igu_addr = (u8 __iomem *)p_hwfn->regview +\n\t\t\t\t\t\t  PXP_VF_BAR0_START_IGU +\n\t\t\t\t\t\t  ((IGU_CMD_INT_ACK_BASE +\n\t\t\t\t\t\t    sb_info->igu_sb_id) << 3);\n\t}\n\n\tsb_info->flags |= QED_SB_INFO_INIT;\n\n\tqed_int_sb_setup(p_hwfn, p_ptt, sb_info);\n\n\treturn 0;\n}\n\nint qed_int_sb_release(struct qed_hwfn *p_hwfn,\n\t\t       struct qed_sb_info *sb_info, u16 sb_id)\n{\n\tstruct qed_igu_block *p_block;\n\tstruct qed_igu_info *p_info;\n\n\tif (!sb_info)\n\t\treturn 0;\n\n\t \n\tsb_info->sb_ack = 0;\n\tmemset(sb_info->sb_virt, 0, sizeof(*sb_info->sb_virt));\n\n\tif (IS_VF(p_hwfn->cdev)) {\n\t\tqed_vf_set_sb_info(p_hwfn, sb_id, NULL);\n\t\treturn 0;\n\t}\n\n\tp_info = p_hwfn->hw_info.p_igu_info;\n\tp_block = &p_info->entry[sb_info->igu_sb_id];\n\n\t \n\tif (!p_block->vector_number) {\n\t\tDP_ERR(p_hwfn, \"Do Not free sp sb using this function\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tp_block->sb_info = NULL;\n\tp_block->status |= QED_IGU_STATUS_FREE;\n\tp_info->usage.free_cnt++;\n\n\treturn 0;\n}\n\nstatic void qed_int_sp_sb_free(struct qed_hwfn *p_hwfn)\n{\n\tstruct qed_sb_sp_info *p_sb = p_hwfn->p_sp_sb;\n\n\tif (!p_sb)\n\t\treturn;\n\n\tif (p_sb->sb_info.sb_virt)\n\t\tdma_free_coherent(&p_hwfn->cdev->pdev->dev,\n\t\t\t\t  SB_ALIGNED_SIZE(p_hwfn),\n\t\t\t\t  p_sb->sb_info.sb_virt,\n\t\t\t\t  p_sb->sb_info.sb_phys);\n\tkfree(p_sb);\n\tp_hwfn->p_sp_sb = NULL;\n}\n\nstatic int qed_int_sp_sb_alloc(struct qed_hwfn *p_hwfn, struct qed_ptt *p_ptt)\n{\n\tstruct qed_sb_sp_info *p_sb;\n\tdma_addr_t p_phys = 0;\n\tvoid *p_virt;\n\n\t \n\tp_sb = kmalloc(sizeof(*p_sb), GFP_KERNEL);\n\tif (!p_sb)\n\t\treturn -ENOMEM;\n\n\t \n\tp_virt = dma_alloc_coherent(&p_hwfn->cdev->pdev->dev,\n\t\t\t\t    SB_ALIGNED_SIZE(p_hwfn),\n\t\t\t\t    &p_phys, GFP_KERNEL);\n\tif (!p_virt) {\n\t\tkfree(p_sb);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tp_hwfn->p_sp_sb = p_sb;\n\tqed_int_sb_init(p_hwfn, p_ptt, &p_sb->sb_info, p_virt,\n\t\t\tp_phys, QED_SP_SB_ID);\n\n\tmemset(p_sb->pi_info_arr, 0, sizeof(p_sb->pi_info_arr));\n\n\treturn 0;\n}\n\nint qed_int_register_cb(struct qed_hwfn *p_hwfn,\n\t\t\tqed_int_comp_cb_t comp_cb,\n\t\t\tvoid *cookie, u8 *sb_idx, __le16 **p_fw_cons)\n{\n\tstruct qed_sb_sp_info *p_sp_sb = p_hwfn->p_sp_sb;\n\tint rc = -ENOMEM;\n\tu8 pi;\n\n\t \n\tfor (pi = 0; pi < ARRAY_SIZE(p_sp_sb->pi_info_arr); pi++) {\n\t\tif (p_sp_sb->pi_info_arr[pi].comp_cb)\n\t\t\tcontinue;\n\n\t\tp_sp_sb->pi_info_arr[pi].comp_cb = comp_cb;\n\t\tp_sp_sb->pi_info_arr[pi].cookie = cookie;\n\t\t*sb_idx = pi;\n\t\t*p_fw_cons = &p_sp_sb->sb_info.sb_virt->pi_array[pi];\n\t\trc = 0;\n\t\tbreak;\n\t}\n\n\treturn rc;\n}\n\nint qed_int_unregister_cb(struct qed_hwfn *p_hwfn, u8 pi)\n{\n\tstruct qed_sb_sp_info *p_sp_sb = p_hwfn->p_sp_sb;\n\n\tif (p_sp_sb->pi_info_arr[pi].comp_cb == NULL)\n\t\treturn -ENOMEM;\n\n\tp_sp_sb->pi_info_arr[pi].comp_cb = NULL;\n\tp_sp_sb->pi_info_arr[pi].cookie = NULL;\n\n\treturn 0;\n}\n\nu16 qed_int_get_sp_sb_id(struct qed_hwfn *p_hwfn)\n{\n\treturn p_hwfn->p_sp_sb->sb_info.igu_sb_id;\n}\n\nvoid qed_int_igu_enable_int(struct qed_hwfn *p_hwfn,\n\t\t\t    struct qed_ptt *p_ptt, enum qed_int_mode int_mode)\n{\n\tu32 igu_pf_conf = IGU_PF_CONF_FUNC_EN | IGU_PF_CONF_ATTN_BIT_EN;\n\n\tp_hwfn->cdev->int_mode = int_mode;\n\tswitch (p_hwfn->cdev->int_mode) {\n\tcase QED_INT_MODE_INTA:\n\t\tigu_pf_conf |= IGU_PF_CONF_INT_LINE_EN;\n\t\tigu_pf_conf |= IGU_PF_CONF_SINGLE_ISR_EN;\n\t\tbreak;\n\n\tcase QED_INT_MODE_MSI:\n\t\tigu_pf_conf |= IGU_PF_CONF_MSI_MSIX_EN;\n\t\tigu_pf_conf |= IGU_PF_CONF_SINGLE_ISR_EN;\n\t\tbreak;\n\n\tcase QED_INT_MODE_MSIX:\n\t\tigu_pf_conf |= IGU_PF_CONF_MSI_MSIX_EN;\n\t\tbreak;\n\tcase QED_INT_MODE_POLL:\n\t\tbreak;\n\t}\n\n\tqed_wr(p_hwfn, p_ptt, IGU_REG_PF_CONFIGURATION, igu_pf_conf);\n}\n\nstatic void qed_int_igu_enable_attn(struct qed_hwfn *p_hwfn,\n\t\t\t\t    struct qed_ptt *p_ptt)\n{\n\n\t \n\tqed_wr(p_hwfn, p_ptt, IGU_REG_ATTENTION_ENABLE, 0);\n\tqed_wr(p_hwfn, p_ptt, IGU_REG_LEADING_EDGE_LATCH, 0xfff);\n\tqed_wr(p_hwfn, p_ptt, IGU_REG_TRAILING_EDGE_LATCH, 0xfff);\n\tqed_wr(p_hwfn, p_ptt, IGU_REG_ATTENTION_ENABLE, 0xfff);\n\n\t \n\tqed_wr(p_hwfn, p_ptt, MISC_REG_AEU_MASK_ATTN_IGU, 0xff);\n}\n\nint\nqed_int_igu_enable(struct qed_hwfn *p_hwfn,\n\t\t   struct qed_ptt *p_ptt, enum qed_int_mode int_mode)\n{\n\tint rc = 0;\n\n\tqed_int_igu_enable_attn(p_hwfn, p_ptt);\n\n\tif ((int_mode != QED_INT_MODE_INTA) || IS_LEAD_HWFN(p_hwfn)) {\n\t\trc = qed_slowpath_irq_req(p_hwfn);\n\t\tif (rc) {\n\t\t\tDP_NOTICE(p_hwfn, \"Slowpath IRQ request failed\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tp_hwfn->b_int_requested = true;\n\t}\n\t \n\tqed_int_igu_enable_int(p_hwfn, p_ptt, int_mode);\n\tp_hwfn->b_int_enabled = 1;\n\n\treturn rc;\n}\n\nvoid qed_int_igu_disable_int(struct qed_hwfn *p_hwfn, struct qed_ptt *p_ptt)\n{\n\tp_hwfn->b_int_enabled = 0;\n\n\tif (IS_VF(p_hwfn->cdev))\n\t\treturn;\n\n\tqed_wr(p_hwfn, p_ptt, IGU_REG_PF_CONFIGURATION, 0);\n}\n\n#define IGU_CLEANUP_SLEEP_LENGTH                (1000)\nstatic void qed_int_igu_cleanup_sb(struct qed_hwfn *p_hwfn,\n\t\t\t\t   struct qed_ptt *p_ptt,\n\t\t\t\t   u16 igu_sb_id,\n\t\t\t\t   bool cleanup_set, u16 opaque_fid)\n{\n\tu32 cmd_ctrl = 0, val = 0, sb_bit = 0, sb_bit_addr = 0, data = 0;\n\tu32 pxp_addr = IGU_CMD_INT_ACK_BASE + igu_sb_id;\n\tu32 sleep_cnt = IGU_CLEANUP_SLEEP_LENGTH;\n\n\t \n\tSET_FIELD(data, IGU_CLEANUP_CLEANUP_SET, cleanup_set ? 1 : 0);\n\tSET_FIELD(data, IGU_CLEANUP_CLEANUP_TYPE, 0);\n\tSET_FIELD(data, IGU_CLEANUP_COMMAND_TYPE, IGU_COMMAND_TYPE_SET);\n\n\t \n\tSET_FIELD(cmd_ctrl, IGU_CTRL_REG_PXP_ADDR, pxp_addr);\n\tSET_FIELD(cmd_ctrl, IGU_CTRL_REG_FID, opaque_fid);\n\tSET_FIELD(cmd_ctrl, IGU_CTRL_REG_TYPE, IGU_CTRL_CMD_TYPE_WR);\n\n\tqed_wr(p_hwfn, p_ptt, IGU_REG_COMMAND_REG_32LSB_DATA, data);\n\n\tbarrier();\n\n\tqed_wr(p_hwfn, p_ptt, IGU_REG_COMMAND_REG_CTRL, cmd_ctrl);\n\n\t \n\tsb_bit = 1 << (igu_sb_id % 32);\n\tsb_bit_addr = igu_sb_id / 32 * sizeof(u32);\n\n\tsb_bit_addr += IGU_REG_CLEANUP_STATUS_0;\n\n\t \n\tdo {\n\t\tval = qed_rd(p_hwfn, p_ptt, sb_bit_addr);\n\n\t\tif ((val & sb_bit) == (cleanup_set ? sb_bit : 0))\n\t\t\tbreak;\n\n\t\tusleep_range(5000, 10000);\n\t} while (--sleep_cnt);\n\n\tif (!sleep_cnt)\n\t\tDP_NOTICE(p_hwfn,\n\t\t\t  \"Timeout waiting for clear status 0x%08x [for sb %d]\\n\",\n\t\t\t  val, igu_sb_id);\n}\n\nvoid qed_int_igu_init_pure_rt_single(struct qed_hwfn *p_hwfn,\n\t\t\t\t     struct qed_ptt *p_ptt,\n\t\t\t\t     u16 igu_sb_id, u16 opaque, bool b_set)\n{\n\tstruct qed_igu_block *p_block;\n\tint pi, i;\n\n\tp_block = &p_hwfn->hw_info.p_igu_info->entry[igu_sb_id];\n\tDP_VERBOSE(p_hwfn, NETIF_MSG_INTR,\n\t\t   \"Cleaning SB [%04x]: func_id= %d is_pf = %d vector_num = 0x%0x\\n\",\n\t\t   igu_sb_id,\n\t\t   p_block->function_id,\n\t\t   p_block->is_pf, p_block->vector_number);\n\n\t \n\tif (b_set)\n\t\tqed_int_igu_cleanup_sb(p_hwfn, p_ptt, igu_sb_id, 1, opaque);\n\n\t \n\tqed_int_igu_cleanup_sb(p_hwfn, p_ptt, igu_sb_id, 0, opaque);\n\n\t \n\tfor (i = 0; i < IGU_CLEANUP_SLEEP_LENGTH; i++) {\n\t\tu32 val;\n\n\t\tval = qed_rd(p_hwfn, p_ptt,\n\t\t\t     IGU_REG_WRITE_DONE_PENDING +\n\t\t\t     ((igu_sb_id / 32) * 4));\n\t\tif (val & BIT((igu_sb_id % 32)))\n\t\t\tusleep_range(10, 20);\n\t\telse\n\t\t\tbreak;\n\t}\n\tif (i == IGU_CLEANUP_SLEEP_LENGTH)\n\t\tDP_NOTICE(p_hwfn,\n\t\t\t  \"Failed SB[0x%08x] still appearing in WRITE_DONE_PENDING\\n\",\n\t\t\t  igu_sb_id);\n\n\t \n\tfor (pi = 0; pi < 12; pi++)\n\t\tqed_wr(p_hwfn, p_ptt,\n\t\t       CAU_REG_PI_MEMORY + (igu_sb_id * 12 + pi) * 4, 0);\n}\n\nvoid qed_int_igu_init_pure_rt(struct qed_hwfn *p_hwfn,\n\t\t\t      struct qed_ptt *p_ptt,\n\t\t\t      bool b_set, bool b_slowpath)\n{\n\tstruct qed_igu_info *p_info = p_hwfn->hw_info.p_igu_info;\n\tstruct qed_igu_block *p_block;\n\tu16 igu_sb_id = 0;\n\tu32 val = 0;\n\n\tval = qed_rd(p_hwfn, p_ptt, IGU_REG_BLOCK_CONFIGURATION);\n\tval |= IGU_REG_BLOCK_CONFIGURATION_VF_CLEANUP_EN;\n\tval &= ~IGU_REG_BLOCK_CONFIGURATION_PXP_TPH_INTERFACE_EN;\n\tqed_wr(p_hwfn, p_ptt, IGU_REG_BLOCK_CONFIGURATION, val);\n\n\tfor (igu_sb_id = 0;\n\t     igu_sb_id < QED_MAPPING_MEMORY_SIZE(p_hwfn->cdev); igu_sb_id++) {\n\t\tp_block = &p_info->entry[igu_sb_id];\n\n\t\tif (!(p_block->status & QED_IGU_STATUS_VALID) ||\n\t\t    !p_block->is_pf ||\n\t\t    (p_block->status & QED_IGU_STATUS_DSB))\n\t\t\tcontinue;\n\n\t\tqed_int_igu_init_pure_rt_single(p_hwfn, p_ptt, igu_sb_id,\n\t\t\t\t\t\tp_hwfn->hw_info.opaque_fid,\n\t\t\t\t\t\tb_set);\n\t}\n\n\tif (b_slowpath)\n\t\tqed_int_igu_init_pure_rt_single(p_hwfn, p_ptt,\n\t\t\t\t\t\tp_info->igu_dsb_id,\n\t\t\t\t\t\tp_hwfn->hw_info.opaque_fid,\n\t\t\t\t\t\tb_set);\n}\n\nint qed_int_igu_reset_cam(struct qed_hwfn *p_hwfn, struct qed_ptt *p_ptt)\n{\n\tstruct qed_igu_info *p_info = p_hwfn->hw_info.p_igu_info;\n\tstruct qed_igu_block *p_block;\n\tint pf_sbs, vf_sbs;\n\tu16 igu_sb_id;\n\tu32 val, rval;\n\n\tif (!RESC_NUM(p_hwfn, QED_SB)) {\n\t\tp_info->b_allow_pf_vf_change = false;\n\t} else {\n\t\t \n\t\tp_info->b_allow_pf_vf_change = true;\n\n\t\tif (p_info->usage.cnt != RESC_NUM(p_hwfn, QED_SB) - 1) {\n\t\t\tDP_INFO(p_hwfn,\n\t\t\t\t\"MFW notifies of 0x%04x PF SBs; IGU indicates of only 0x%04x\\n\",\n\t\t\t\tRESC_NUM(p_hwfn, QED_SB) - 1,\n\t\t\t\tp_info->usage.cnt);\n\t\t\tp_info->usage.cnt = RESC_NUM(p_hwfn, QED_SB) - 1;\n\t\t}\n\n\t\tif (IS_PF_SRIOV(p_hwfn)) {\n\t\t\tu16 vfs = p_hwfn->cdev->p_iov_info->total_vfs;\n\n\t\t\tif (vfs != p_info->usage.iov_cnt)\n\t\t\t\tDP_VERBOSE(p_hwfn,\n\t\t\t\t\t   NETIF_MSG_INTR,\n\t\t\t\t\t   \"0x%04x VF SBs in IGU CAM != PCI configuration 0x%04x\\n\",\n\t\t\t\t\t   p_info->usage.iov_cnt, vfs);\n\n\t\t\t \n\t\t\tif (vfs > p_info->usage.free_cnt +\n\t\t\t    p_info->usage.free_cnt_iov - p_info->usage.cnt) {\n\t\t\t\tDP_NOTICE(p_hwfn,\n\t\t\t\t\t  \"Not enough SBs for VFs - 0x%04x SBs, from which %04x PFs and %04x are required\\n\",\n\t\t\t\t\t  p_info->usage.free_cnt +\n\t\t\t\t\t  p_info->usage.free_cnt_iov,\n\t\t\t\t\t  p_info->usage.cnt, vfs);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\t \n\t\t\tp_info->usage.iov_cnt = vfs;\n\t\t}\n\t}\n\n\t \n\tp_info->usage.free_cnt = p_info->usage.cnt;\n\tp_info->usage.free_cnt_iov = p_info->usage.iov_cnt;\n\tp_info->usage.orig = p_info->usage.cnt;\n\tp_info->usage.iov_orig = p_info->usage.iov_cnt;\n\n\t \n\tpf_sbs = p_info->usage.cnt;\n\tvf_sbs = p_info->usage.iov_cnt;\n\n\tfor (igu_sb_id = p_info->igu_dsb_id;\n\t     igu_sb_id < QED_MAPPING_MEMORY_SIZE(p_hwfn->cdev); igu_sb_id++) {\n\t\tp_block = &p_info->entry[igu_sb_id];\n\t\tval = 0;\n\n\t\tif (!(p_block->status & QED_IGU_STATUS_VALID))\n\t\t\tcontinue;\n\n\t\tif (p_block->status & QED_IGU_STATUS_DSB) {\n\t\t\tp_block->function_id = p_hwfn->rel_pf_id;\n\t\t\tp_block->is_pf = 1;\n\t\t\tp_block->vector_number = 0;\n\t\t\tp_block->status = QED_IGU_STATUS_VALID |\n\t\t\t\t\t  QED_IGU_STATUS_PF |\n\t\t\t\t\t  QED_IGU_STATUS_DSB;\n\t\t} else if (pf_sbs) {\n\t\t\tpf_sbs--;\n\t\t\tp_block->function_id = p_hwfn->rel_pf_id;\n\t\t\tp_block->is_pf = 1;\n\t\t\tp_block->vector_number = p_info->usage.cnt - pf_sbs;\n\t\t\tp_block->status = QED_IGU_STATUS_VALID |\n\t\t\t\t\t  QED_IGU_STATUS_PF |\n\t\t\t\t\t  QED_IGU_STATUS_FREE;\n\t\t} else if (vf_sbs) {\n\t\t\tp_block->function_id =\n\t\t\t    p_hwfn->cdev->p_iov_info->first_vf_in_pf +\n\t\t\t    p_info->usage.iov_cnt - vf_sbs;\n\t\t\tp_block->is_pf = 0;\n\t\t\tp_block->vector_number = 0;\n\t\t\tp_block->status = QED_IGU_STATUS_VALID |\n\t\t\t\t\t  QED_IGU_STATUS_FREE;\n\t\t\tvf_sbs--;\n\t\t} else {\n\t\t\tp_block->function_id = 0;\n\t\t\tp_block->is_pf = 0;\n\t\t\tp_block->vector_number = 0;\n\t\t}\n\n\t\tSET_FIELD(val, IGU_MAPPING_LINE_FUNCTION_NUMBER,\n\t\t\t  p_block->function_id);\n\t\tSET_FIELD(val, IGU_MAPPING_LINE_PF_VALID, p_block->is_pf);\n\t\tSET_FIELD(val, IGU_MAPPING_LINE_VECTOR_NUMBER,\n\t\t\t  p_block->vector_number);\n\n\t\t \n\t\tSET_FIELD(val, IGU_MAPPING_LINE_VALID, p_block->is_pf);\n\n\t\trval = qed_rd(p_hwfn, p_ptt,\n\t\t\t      IGU_REG_MAPPING_MEMORY + sizeof(u32) * igu_sb_id);\n\n\t\tif (rval != val) {\n\t\t\tqed_wr(p_hwfn, p_ptt,\n\t\t\t       IGU_REG_MAPPING_MEMORY +\n\t\t\t       sizeof(u32) * igu_sb_id, val);\n\n\t\t\tDP_VERBOSE(p_hwfn,\n\t\t\t\t   NETIF_MSG_INTR,\n\t\t\t\t   \"IGU reset: [SB 0x%04x] func_id = %d is_pf = %d vector_num = 0x%x [%08x -> %08x]\\n\",\n\t\t\t\t   igu_sb_id,\n\t\t\t\t   p_block->function_id,\n\t\t\t\t   p_block->is_pf,\n\t\t\t\t   p_block->vector_number, rval, val);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void qed_int_igu_read_cam_block(struct qed_hwfn *p_hwfn,\n\t\t\t\t       struct qed_ptt *p_ptt, u16 igu_sb_id)\n{\n\tu32 val = qed_rd(p_hwfn, p_ptt,\n\t\t\t IGU_REG_MAPPING_MEMORY + sizeof(u32) * igu_sb_id);\n\tstruct qed_igu_block *p_block;\n\n\tp_block = &p_hwfn->hw_info.p_igu_info->entry[igu_sb_id];\n\n\t \n\tp_block->function_id = GET_FIELD(val, IGU_MAPPING_LINE_FUNCTION_NUMBER);\n\tp_block->is_pf = GET_FIELD(val, IGU_MAPPING_LINE_PF_VALID);\n\tp_block->vector_number = GET_FIELD(val, IGU_MAPPING_LINE_VECTOR_NUMBER);\n\tp_block->igu_sb_id = igu_sb_id;\n}\n\nint qed_int_igu_read_cam(struct qed_hwfn *p_hwfn, struct qed_ptt *p_ptt)\n{\n\tstruct qed_igu_info *p_igu_info;\n\tstruct qed_igu_block *p_block;\n\tu32 min_vf = 0, max_vf = 0;\n\tu16 igu_sb_id;\n\n\tp_hwfn->hw_info.p_igu_info = kzalloc(sizeof(*p_igu_info), GFP_KERNEL);\n\tif (!p_hwfn->hw_info.p_igu_info)\n\t\treturn -ENOMEM;\n\n\tp_igu_info = p_hwfn->hw_info.p_igu_info;\n\n\t \n\tp_igu_info->igu_dsb_id = QED_SB_INVALID_IDX;\n\n\t \n\tif (p_hwfn->cdev->p_iov_info) {\n\t\tstruct qed_hw_sriov_info *p_iov = p_hwfn->cdev->p_iov_info;\n\n\t\tmin_vf\t= p_iov->first_vf_in_pf;\n\t\tmax_vf\t= p_iov->first_vf_in_pf + p_iov->total_vfs;\n\t}\n\n\tfor (igu_sb_id = 0;\n\t     igu_sb_id < QED_MAPPING_MEMORY_SIZE(p_hwfn->cdev); igu_sb_id++) {\n\t\t \n\t\tqed_int_igu_read_cam_block(p_hwfn, p_ptt, igu_sb_id);\n\t\tp_block = &p_igu_info->entry[igu_sb_id];\n\n\t\tif ((p_block->is_pf) &&\n\t\t    (p_block->function_id == p_hwfn->rel_pf_id)) {\n\t\t\tp_block->status = QED_IGU_STATUS_PF |\n\t\t\t\t\t  QED_IGU_STATUS_VALID |\n\t\t\t\t\t  QED_IGU_STATUS_FREE;\n\n\t\t\tif (p_igu_info->igu_dsb_id != QED_SB_INVALID_IDX)\n\t\t\t\tp_igu_info->usage.cnt++;\n\t\t} else if (!(p_block->is_pf) &&\n\t\t\t   (p_block->function_id >= min_vf) &&\n\t\t\t   (p_block->function_id < max_vf)) {\n\t\t\t \n\t\t\tp_block->status = QED_IGU_STATUS_VALID |\n\t\t\t\t\t  QED_IGU_STATUS_FREE;\n\n\t\t\tif (p_igu_info->igu_dsb_id != QED_SB_INVALID_IDX)\n\t\t\t\tp_igu_info->usage.iov_cnt++;\n\t\t}\n\n\t\t \n\t\tif ((p_block->status & QED_IGU_STATUS_VALID) &&\n\t\t    (p_igu_info->igu_dsb_id == QED_SB_INVALID_IDX)) {\n\t\t\tp_igu_info->igu_dsb_id = igu_sb_id;\n\t\t\tp_block->status |= QED_IGU_STATUS_DSB;\n\t\t}\n\n\t\t \n\t\tif ((p_block->status & QED_IGU_STATUS_VALID) ||\n\t\t    (p_hwfn->abs_pf_id == 0)) {\n\t\t\tDP_VERBOSE(p_hwfn, NETIF_MSG_INTR,\n\t\t\t\t   \"IGU_BLOCK: [SB 0x%04x] func_id = %d is_pf = %d vector_num = 0x%x\\n\",\n\t\t\t\t   igu_sb_id, p_block->function_id,\n\t\t\t\t   p_block->is_pf, p_block->vector_number);\n\t\t}\n\t}\n\n\tif (p_igu_info->igu_dsb_id == QED_SB_INVALID_IDX) {\n\t\tDP_NOTICE(p_hwfn,\n\t\t\t  \"IGU CAM returned invalid values igu_dsb_id=0x%x\\n\",\n\t\t\t  p_igu_info->igu_dsb_id);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tp_igu_info->usage.free_cnt = p_igu_info->usage.cnt;\n\tp_igu_info->usage.free_cnt_iov = p_igu_info->usage.iov_cnt;\n\n\tDP_VERBOSE(p_hwfn, NETIF_MSG_INTR,\n\t\t   \"igu_dsb_id=0x%x, num Free SBs - PF: %04x VF: %04x [might change after resource allocation]\\n\",\n\t\t   p_igu_info->igu_dsb_id,\n\t\t   p_igu_info->usage.cnt, p_igu_info->usage.iov_cnt);\n\n\treturn 0;\n}\n\n \nvoid qed_int_igu_init_rt(struct qed_hwfn *p_hwfn)\n{\n\tu32 igu_pf_conf = IGU_PF_CONF_FUNC_EN;\n\n\tSTORE_RT_REG(p_hwfn, IGU_REG_PF_CONFIGURATION_RT_OFFSET, igu_pf_conf);\n}\n\nu64 qed_int_igu_read_sisr_reg(struct qed_hwfn *p_hwfn)\n{\n\tu32 lsb_igu_cmd_addr = IGU_REG_SISR_MDPC_WMASK_LSB_UPPER -\n\t\t\t       IGU_CMD_INT_ACK_BASE;\n\tu32 msb_igu_cmd_addr = IGU_REG_SISR_MDPC_WMASK_MSB_UPPER -\n\t\t\t       IGU_CMD_INT_ACK_BASE;\n\tu32 intr_status_hi = 0, intr_status_lo = 0;\n\tu64 intr_status = 0;\n\n\tintr_status_lo = REG_RD(p_hwfn,\n\t\t\t\tGTT_BAR0_MAP_REG_IGU_CMD +\n\t\t\t\tlsb_igu_cmd_addr * 8);\n\tintr_status_hi = REG_RD(p_hwfn,\n\t\t\t\tGTT_BAR0_MAP_REG_IGU_CMD +\n\t\t\t\tmsb_igu_cmd_addr * 8);\n\tintr_status = ((u64)intr_status_hi << 32) + (u64)intr_status_lo;\n\n\treturn intr_status;\n}\n\nstatic void qed_int_sp_dpc_setup(struct qed_hwfn *p_hwfn)\n{\n\ttasklet_setup(&p_hwfn->sp_dpc, qed_int_sp_dpc);\n\tp_hwfn->b_sp_dpc_enabled = true;\n}\n\nint qed_int_alloc(struct qed_hwfn *p_hwfn, struct qed_ptt *p_ptt)\n{\n\tint rc = 0;\n\n\trc = qed_int_sp_sb_alloc(p_hwfn, p_ptt);\n\tif (rc)\n\t\treturn rc;\n\n\trc = qed_int_sb_attn_alloc(p_hwfn, p_ptt);\n\n\treturn rc;\n}\n\nvoid qed_int_free(struct qed_hwfn *p_hwfn)\n{\n\tqed_int_sp_sb_free(p_hwfn);\n\tqed_int_sb_attn_free(p_hwfn);\n}\n\nvoid qed_int_setup(struct qed_hwfn *p_hwfn, struct qed_ptt *p_ptt)\n{\n\tqed_int_sb_setup(p_hwfn, p_ptt, &p_hwfn->p_sp_sb->sb_info);\n\tqed_int_sb_attn_setup(p_hwfn, p_ptt);\n\tqed_int_sp_dpc_setup(p_hwfn);\n}\n\nvoid qed_int_get_num_sbs(struct qed_hwfn\t*p_hwfn,\n\t\t\t struct qed_sb_cnt_info *p_sb_cnt_info)\n{\n\tstruct qed_igu_info *info = p_hwfn->hw_info.p_igu_info;\n\n\tif (!info || !p_sb_cnt_info)\n\t\treturn;\n\n\tmemcpy(p_sb_cnt_info, &info->usage, sizeof(*p_sb_cnt_info));\n}\n\nvoid qed_int_disable_post_isr_release(struct qed_dev *cdev)\n{\n\tint i;\n\n\tfor_each_hwfn(cdev, i)\n\t\tcdev->hwfns[i].b_int_requested = false;\n}\n\nvoid qed_int_attn_clr_enable(struct qed_dev *cdev, bool clr_enable)\n{\n\tcdev->attn_clr_en = clr_enable;\n}\n\nint qed_int_set_timer_res(struct qed_hwfn *p_hwfn, struct qed_ptt *p_ptt,\n\t\t\t  u8 timer_res, u16 sb_id, bool tx)\n{\n\tstruct cau_sb_entry sb_entry;\n\tu32 params;\n\tint rc;\n\n\tif (!p_hwfn->hw_init_done) {\n\t\tDP_ERR(p_hwfn, \"hardware not initialized yet\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\trc = qed_dmae_grc2host(p_hwfn, p_ptt, CAU_REG_SB_VAR_MEMORY +\n\t\t\t       sb_id * sizeof(u64),\n\t\t\t       (u64)(uintptr_t)&sb_entry, 2, NULL);\n\tif (rc) {\n\t\tDP_ERR(p_hwfn, \"dmae_grc2host failed %d\\n\", rc);\n\t\treturn rc;\n\t}\n\n\tparams = le32_to_cpu(sb_entry.params);\n\n\tif (tx)\n\t\tSET_FIELD(params, CAU_SB_ENTRY_TIMER_RES1, timer_res);\n\telse\n\t\tSET_FIELD(params, CAU_SB_ENTRY_TIMER_RES0, timer_res);\n\n\tsb_entry.params = cpu_to_le32(params);\n\n\trc = qed_dmae_host2grc(p_hwfn, p_ptt,\n\t\t\t       (u64)(uintptr_t)&sb_entry,\n\t\t\t       CAU_REG_SB_VAR_MEMORY +\n\t\t\t       sb_id * sizeof(u64), 2, NULL);\n\tif (rc) {\n\t\tDP_ERR(p_hwfn, \"dmae_host2grc failed %d\\n\", rc);\n\t\treturn rc;\n\t}\n\n\treturn rc;\n}\n\nint qed_int_get_sb_dbg(struct qed_hwfn *p_hwfn, struct qed_ptt *p_ptt,\n\t\t       struct qed_sb_info *p_sb, struct qed_sb_info_dbg *p_info)\n{\n\tu16 sbid = p_sb->igu_sb_id;\n\tu32 i;\n\n\tif (IS_VF(p_hwfn->cdev))\n\t\treturn -EINVAL;\n\n\tif (sbid >= NUM_OF_SBS(p_hwfn->cdev))\n\t\treturn -EINVAL;\n\n\tp_info->igu_prod = qed_rd(p_hwfn, p_ptt, IGU_REG_PRODUCER_MEMORY + sbid * 4);\n\tp_info->igu_cons = qed_rd(p_hwfn, p_ptt, IGU_REG_CONSUMER_MEM + sbid * 4);\n\n\tfor (i = 0; i < PIS_PER_SB; i++)\n\t\tp_info->pi[i] = (u16)qed_rd(p_hwfn, p_ptt,\n\t\t\t\t\t    CAU_REG_PI_MEMORY + sbid * 4 * PIS_PER_SB + i * 4);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}