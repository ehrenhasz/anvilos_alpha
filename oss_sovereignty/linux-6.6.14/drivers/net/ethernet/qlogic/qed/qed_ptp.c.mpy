{
  "module_name": "qed_ptp.c",
  "hash_id": "ea9f023e9a1c9eb061dd99098c72ceb123d6de615f4672441cd5401907432562",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/qlogic/qed/qed_ptp.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include \"qed.h\"\n#include \"qed_dev_api.h\"\n#include \"qed_hw.h\"\n#include \"qed_l2.h\"\n#include \"qed_mcp.h\"\n#include \"qed_ptp.h\"\n#include \"qed_reg_addr.h\"\n\n \n#define QED_DRIFT_CNTR_TIME_QUANTA_SHIFT\t0\n \n#define QED_DRIFT_CNTR_ADJUSTMENT_SHIFT\t\t28\n \n#define QED_DRIFT_CNTR_DIRECTION_SHIFT\t\t31\n#define QED_TIMESTAMP_MASK\t\t\tBIT(16)\n \n#define QED_PTP_UCAST_PARAM_MASK              0x70F\n\nstatic enum qed_resc_lock qed_ptcdev_to_resc(struct qed_hwfn *p_hwfn)\n{\n\tswitch (MFW_PORT(p_hwfn)) {\n\tcase 0:\n\t\treturn QED_RESC_LOCK_PTP_PORT0;\n\tcase 1:\n\t\treturn QED_RESC_LOCK_PTP_PORT1;\n\tcase 2:\n\t\treturn QED_RESC_LOCK_PTP_PORT2;\n\tcase 3:\n\t\treturn QED_RESC_LOCK_PTP_PORT3;\n\tdefault:\n\t\treturn QED_RESC_LOCK_RESC_INVALID;\n\t}\n}\n\nstatic int qed_ptp_res_lock(struct qed_hwfn *p_hwfn, struct qed_ptt *p_ptt)\n{\n\tstruct qed_resc_lock_params params;\n\tenum qed_resc_lock resource;\n\tint rc;\n\n\tresource = qed_ptcdev_to_resc(p_hwfn);\n\tif (resource == QED_RESC_LOCK_RESC_INVALID)\n\t\treturn -EINVAL;\n\n\tqed_mcp_resc_lock_default_init(&params, NULL, resource, true);\n\n\trc = qed_mcp_resc_lock(p_hwfn, p_ptt, &params);\n\tif (rc && rc != -EINVAL) {\n\t\treturn rc;\n\t} else if (rc == -EINVAL) {\n\t\t \n\t\tif (p_hwfn->abs_pf_id < p_hwfn->cdev->num_ports_in_engine)\n\t\t\treturn 0;\n\n\t\tDP_INFO(p_hwfn, \"PF doesn't have lock ownership\\n\");\n\t\treturn -EBUSY;\n\t} else if (!params.b_granted) {\n\t\tDP_INFO(p_hwfn, \"Failed to acquire ptp resource lock\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\treturn 0;\n}\n\nstatic int qed_ptp_res_unlock(struct qed_hwfn *p_hwfn, struct qed_ptt *p_ptt)\n{\n\tstruct qed_resc_unlock_params params;\n\tenum qed_resc_lock resource;\n\tint rc;\n\n\tresource = qed_ptcdev_to_resc(p_hwfn);\n\tif (resource == QED_RESC_LOCK_RESC_INVALID)\n\t\treturn -EINVAL;\n\n\tqed_mcp_resc_lock_default_init(NULL, &params, resource, true);\n\n\trc = qed_mcp_resc_unlock(p_hwfn, p_ptt, &params);\n\tif (rc == -EINVAL) {\n\t\t \n\t\tif (p_hwfn->abs_pf_id < p_hwfn->cdev->num_ports_in_engine) {\n\t\t\trc = 0;\n\t\t} else {\n\t\t\tDP_INFO(p_hwfn, \"PF doesn't have lock ownership\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else if (rc) {\n\t\tDP_INFO(p_hwfn, \"Failed to release the ptp resource lock\\n\");\n\t}\n\n\treturn rc;\n}\n\n \nstatic int qed_ptp_hw_read_rx_ts(struct qed_dev *cdev, u64 *timestamp)\n{\n\tstruct qed_hwfn *p_hwfn = QED_LEADING_HWFN(cdev);\n\tstruct qed_ptt *p_ptt = p_hwfn->p_ptp_ptt;\n\tu32 val;\n\n\t*timestamp = 0;\n\tval = qed_rd(p_hwfn, p_ptt, NIG_REG_LLH_PTP_HOST_BUF_SEQID);\n\tif (!(val & QED_TIMESTAMP_MASK)) {\n\t\tDP_INFO(p_hwfn, \"Invalid Rx timestamp, buf_seqid = %d\\n\", val);\n\t\treturn -EINVAL;\n\t}\n\n\tval = qed_rd(p_hwfn, p_ptt, NIG_REG_LLH_PTP_HOST_BUF_TS_LSB);\n\t*timestamp = qed_rd(p_hwfn, p_ptt, NIG_REG_LLH_PTP_HOST_BUF_TS_MSB);\n\t*timestamp <<= 32;\n\t*timestamp |= val;\n\n\t \n\tqed_wr(p_hwfn, p_ptt, NIG_REG_LLH_PTP_HOST_BUF_SEQID,\n\t       QED_TIMESTAMP_MASK);\n\n\treturn 0;\n}\n\n \nstatic int qed_ptp_hw_read_tx_ts(struct qed_dev *cdev, u64 *timestamp)\n{\n\tstruct qed_hwfn *p_hwfn = QED_LEADING_HWFN(cdev);\n\tstruct qed_ptt *p_ptt = p_hwfn->p_ptp_ptt;\n\tu32 val;\n\n\t*timestamp = 0;\n\tval = qed_rd(p_hwfn, p_ptt, NIG_REG_TX_LLH_PTP_BUF_SEQID);\n\tif (!(val & QED_TIMESTAMP_MASK)) {\n\t\tDP_VERBOSE(p_hwfn, QED_MSG_DEBUG,\n\t\t\t   \"Invalid Tx timestamp, buf_seqid = %08x\\n\", val);\n\t\treturn -EINVAL;\n\t}\n\n\tval = qed_rd(p_hwfn, p_ptt, NIG_REG_TX_LLH_PTP_BUF_TS_LSB);\n\t*timestamp = qed_rd(p_hwfn, p_ptt, NIG_REG_TX_LLH_PTP_BUF_TS_MSB);\n\t*timestamp <<= 32;\n\t*timestamp |= val;\n\n\t \n\tqed_wr(p_hwfn, p_ptt, NIG_REG_TX_LLH_PTP_BUF_SEQID, QED_TIMESTAMP_MASK);\n\n\treturn 0;\n}\n\n \nstatic int qed_ptp_hw_read_cc(struct qed_dev *cdev, u64 *phc_cycles)\n{\n\tstruct qed_hwfn *p_hwfn = QED_LEADING_HWFN(cdev);\n\tstruct qed_ptt *p_ptt = p_hwfn->p_ptp_ptt;\n\tu32 temp = 0;\n\n\ttemp = qed_rd(p_hwfn, p_ptt, NIG_REG_TSGEN_SYNC_TIME_LSB);\n\t*phc_cycles = qed_rd(p_hwfn, p_ptt, NIG_REG_TSGEN_SYNC_TIME_MSB);\n\t*phc_cycles <<= 32;\n\t*phc_cycles |= temp;\n\n\treturn 0;\n}\n\n \nstatic int qed_ptp_hw_cfg_filters(struct qed_dev *cdev,\n\t\t\t\t  enum qed_ptp_filter_type rx_type,\n\t\t\t\t  enum qed_ptp_hwtstamp_tx_type tx_type)\n{\n\tstruct qed_hwfn *p_hwfn = QED_LEADING_HWFN(cdev);\n\tstruct qed_ptt *p_ptt = p_hwfn->p_ptp_ptt;\n\tu32 rule_mask, enable_cfg = 0x0;\n\n\tswitch (rx_type) {\n\tcase QED_PTP_FILTER_NONE:\n\t\tenable_cfg = 0x0;\n\t\trule_mask = 0x3FFF;\n\t\tbreak;\n\tcase QED_PTP_FILTER_ALL:\n\t\tenable_cfg = 0x7;\n\t\trule_mask = 0x3CAA;\n\t\tbreak;\n\tcase QED_PTP_FILTER_V1_L4_EVENT:\n\t\tenable_cfg = 0x3;\n\t\trule_mask = 0x3FFA;\n\t\tbreak;\n\tcase QED_PTP_FILTER_V1_L4_GEN:\n\t\tenable_cfg = 0x3;\n\t\trule_mask = 0x3FFE;\n\t\tbreak;\n\tcase QED_PTP_FILTER_V2_L4_EVENT:\n\t\tenable_cfg = 0x5;\n\t\trule_mask = 0x3FAA;\n\t\tbreak;\n\tcase QED_PTP_FILTER_V2_L4_GEN:\n\t\tenable_cfg = 0x5;\n\t\trule_mask = 0x3FEE;\n\t\tbreak;\n\tcase QED_PTP_FILTER_V2_L2_EVENT:\n\t\tenable_cfg = 0x5;\n\t\trule_mask = 0x3CFF;\n\t\tbreak;\n\tcase QED_PTP_FILTER_V2_L2_GEN:\n\t\tenable_cfg = 0x5;\n\t\trule_mask = 0x3EFF;\n\t\tbreak;\n\tcase QED_PTP_FILTER_V2_EVENT:\n\t\tenable_cfg = 0x5;\n\t\trule_mask = 0x3CAA;\n\t\tbreak;\n\tcase QED_PTP_FILTER_V2_GEN:\n\t\tenable_cfg = 0x5;\n\t\trule_mask = 0x3EEE;\n\t\tbreak;\n\tdefault:\n\t\tDP_INFO(p_hwfn, \"Invalid PTP filter type %d\\n\", rx_type);\n\t\treturn -EINVAL;\n\t}\n\n\tqed_wr(p_hwfn, p_ptt, NIG_REG_LLH_PTP_PARAM_MASK,\n\t       QED_PTP_UCAST_PARAM_MASK);\n\tqed_wr(p_hwfn, p_ptt, NIG_REG_LLH_PTP_RULE_MASK, rule_mask);\n\tqed_wr(p_hwfn, p_ptt, NIG_REG_RX_PTP_EN, enable_cfg);\n\n\tif (tx_type == QED_PTP_HWTSTAMP_TX_OFF) {\n\t\tqed_wr(p_hwfn, p_ptt, NIG_REG_TX_PTP_EN, 0x0);\n\t\tqed_wr(p_hwfn, p_ptt, NIG_REG_TX_LLH_PTP_PARAM_MASK, 0x7FF);\n\t\tqed_wr(p_hwfn, p_ptt, NIG_REG_TX_LLH_PTP_RULE_MASK, 0x3FFF);\n\t} else {\n\t\tqed_wr(p_hwfn, p_ptt, NIG_REG_TX_PTP_EN, enable_cfg);\n\t\tqed_wr(p_hwfn, p_ptt, NIG_REG_TX_LLH_PTP_PARAM_MASK,\n\t\t       QED_PTP_UCAST_PARAM_MASK);\n\t\tqed_wr(p_hwfn, p_ptt, NIG_REG_TX_LLH_PTP_RULE_MASK, rule_mask);\n\t}\n\n\t \n\tqed_wr(p_hwfn, p_ptt, NIG_REG_LLH_PTP_HOST_BUF_SEQID,\n\t       QED_TIMESTAMP_MASK);\n\n\treturn 0;\n}\n\n \nstatic int qed_ptp_hw_adjfreq(struct qed_dev *cdev, s32 ppb)\n{\n\ts64 best_val = 0, val, best_period = 0, period, approx_dev, dif, dif2;\n\tstruct qed_hwfn *p_hwfn = QED_LEADING_HWFN(cdev);\n\tstruct qed_ptt *p_ptt = p_hwfn->p_ptp_ptt;\n\tu32 drift_ctr_cfg = 0, drift_state;\n\tint drift_dir = 1;\n\n\tif (ppb < 0) {\n\t\tppb = -ppb;\n\t\tdrift_dir = 0;\n\t}\n\n\tif (ppb > 1) {\n\t\ts64 best_dif = ppb, best_approx_dev = 1;\n\n\t\t \n\t\tfor (val = 7; val > 0; val--) {\n\t\t\tperiod = div_s64(val * 1000000000, ppb);\n\t\t\tperiod -= 8;\n\t\t\tperiod >>= 4;\n\t\t\tif (period < 1)\n\t\t\t\tperiod = 1;\n\t\t\tif (period > 0xFFFFFFE)\n\t\t\t\tperiod = 0xFFFFFFE;\n\n\t\t\t \n\t\t\tapprox_dev = period * 16 + 8;\n\t\t\tdif = ppb * approx_dev - val * 1000000000;\n\t\t\tdif2 = dif + 16 * ppb;\n\n\t\t\tif (dif < 0)\n\t\t\t\tdif = -dif;\n\t\t\tif (dif2 < 0)\n\t\t\t\tdif2 = -dif2;\n\n\t\t\t \n\t\t\tif (dif * (approx_dev + 16) > dif2 * approx_dev) {\n\t\t\t\tperiod++;\n\t\t\t\tapprox_dev += 16;\n\t\t\t\tdif = dif2;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (best_dif * approx_dev > dif * best_approx_dev) {\n\t\t\t\tbest_dif = dif;\n\t\t\t\tbest_val = val;\n\t\t\t\tbest_period = period;\n\t\t\t\tbest_approx_dev = approx_dev;\n\t\t\t}\n\t\t}\n\t} else if (ppb == 1) {\n\t\t \n\t\tbest_val = 4;\n\t\tbest_period = 0xee6b27f;\n\t} else {\n\t\tbest_val = 0;\n\t\tbest_period = 0xFFFFFFF;\n\t}\n\n\tdrift_ctr_cfg = (best_period << QED_DRIFT_CNTR_TIME_QUANTA_SHIFT) |\n\t\t\t(((int)best_val) << QED_DRIFT_CNTR_ADJUSTMENT_SHIFT) |\n\t\t\t(((int)drift_dir) << QED_DRIFT_CNTR_DIRECTION_SHIFT);\n\n\tqed_wr(p_hwfn, p_ptt, NIG_REG_TSGEN_RST_DRIFT_CNTR, 0x1);\n\n\tdrift_state = qed_rd(p_hwfn, p_ptt, NIG_REG_TSGEN_RST_DRIFT_CNTR);\n\tif (drift_state & 1) {\n\t\tqed_wr(p_hwfn, p_ptt, NIG_REG_TSGEN_DRIFT_CNTR_CONF,\n\t\t       drift_ctr_cfg);\n\t} else {\n\t\tDP_INFO(p_hwfn, \"Drift counter is not reset\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tqed_wr(p_hwfn, p_ptt, NIG_REG_TSGEN_RST_DRIFT_CNTR, 0x0);\n\n\treturn 0;\n}\n\nstatic int qed_ptp_hw_enable(struct qed_dev *cdev)\n{\n\tstruct qed_hwfn *p_hwfn = QED_LEADING_HWFN(cdev);\n\tstruct qed_ptt *p_ptt;\n\tint rc;\n\n\tp_ptt = qed_ptt_acquire(p_hwfn);\n\tif (!p_ptt) {\n\t\tDP_NOTICE(p_hwfn, \"Failed to acquire PTT for PTP\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tp_hwfn->p_ptp_ptt = p_ptt;\n\n\trc = qed_ptp_res_lock(p_hwfn, p_ptt);\n\tif (rc) {\n\t\tDP_INFO(p_hwfn,\n\t\t\t\"Couldn't acquire the resource lock, skip ptp enable for this PF\\n\");\n\t\tqed_ptt_release(p_hwfn, p_ptt);\n\t\tp_hwfn->p_ptp_ptt = NULL;\n\t\treturn rc;\n\t}\n\n\t \n\tqed_wr(p_hwfn, p_ptt, NIG_REG_LLH_PTP_PARAM_MASK, 0x7FF);\n\tqed_wr(p_hwfn, p_ptt, NIG_REG_LLH_PTP_RULE_MASK, 0x3FFF);\n\tqed_wr(p_hwfn, p_ptt, NIG_REG_TX_LLH_PTP_PARAM_MASK, 0x7FF);\n\tqed_wr(p_hwfn, p_ptt, NIG_REG_TX_LLH_PTP_RULE_MASK, 0x3FFF);\n\n\tqed_wr(p_hwfn, p_ptt, NIG_REG_TX_PTP_EN, 7);\n\tqed_wr(p_hwfn, p_ptt, NIG_REG_RX_PTP_EN, 7);\n\n\tqed_wr(p_hwfn, p_ptt, NIG_REG_TS_OUTPUT_ENABLE_PDA, 0x1);\n\n\t \n\tif (QED_IS_BB_B0(p_hwfn->cdev))\n\t\tqed_wr(p_hwfn, p_ptt, NIG_REG_TIMESYNC_GEN_REG_BB, 2);\n\tif (QED_IS_AH(p_hwfn->cdev))\n\t\tqed_wr(p_hwfn, p_ptt, NIG_REG_TSGEN_FREECNT_UPDATE_K2, 2);\n\n\tqed_wr(p_hwfn, p_ptt, NIG_REG_TSGEN_FREE_CNT_VALUE_LSB, 0);\n\tqed_wr(p_hwfn, p_ptt, NIG_REG_TSGEN_FREE_CNT_VALUE_MSB, 0);\n\t \n\tif (QED_IS_BB_B0(p_hwfn->cdev))\n\t\tqed_wr(p_hwfn, p_ptt, NIG_REG_TIMESYNC_GEN_REG_BB, 4);\n\tif (QED_IS_AH(p_hwfn->cdev)) {\n\t\tqed_wr(p_hwfn, p_ptt, NIG_REG_TSGEN_FREECNT_UPDATE_K2, 4);\n\t\tqed_wr(p_hwfn, p_ptt, NIG_REG_PTP_LATCH_OSTS_PKT_TIME, 1);\n\t}\n\n\t \n\tqed_wr(p_hwfn, p_ptt, NIG_REG_TSGEN_DRIFT_CNTR_CONF, 0x0);\n\tqed_wr(p_hwfn, p_ptt, NIG_REG_TSGEN_RST_DRIFT_CNTR, 0x0);\n\n\t \n\tqed_wr(p_hwfn, p_ptt, NIG_REG_LLH_PTP_HOST_BUF_SEQID,\n\t       QED_TIMESTAMP_MASK);\n\tqed_wr(p_hwfn, p_ptt, NIG_REG_TX_LLH_PTP_BUF_SEQID, QED_TIMESTAMP_MASK);\n\n\treturn 0;\n}\n\nstatic int qed_ptp_hw_disable(struct qed_dev *cdev)\n{\n\tstruct qed_hwfn *p_hwfn = QED_LEADING_HWFN(cdev);\n\tstruct qed_ptt *p_ptt = p_hwfn->p_ptp_ptt;\n\n\tqed_ptp_res_unlock(p_hwfn, p_ptt);\n\n\t \n\tqed_wr(p_hwfn, p_ptt, NIG_REG_LLH_PTP_PARAM_MASK, 0x7FF);\n\tqed_wr(p_hwfn, p_ptt, NIG_REG_LLH_PTP_RULE_MASK, 0x3FFF);\n\n\tqed_wr(p_hwfn, p_ptt, NIG_REG_TX_LLH_PTP_PARAM_MASK, 0x7FF);\n\tqed_wr(p_hwfn, p_ptt, NIG_REG_TX_LLH_PTP_RULE_MASK, 0x3FFF);\n\n\t \n\tqed_wr(p_hwfn, p_ptt, NIG_REG_RX_PTP_EN, 0x0);\n\tqed_wr(p_hwfn, p_ptt, NIG_REG_TX_PTP_EN, 0x0);\n\n\tqed_ptt_release(p_hwfn, p_ptt);\n\tp_hwfn->p_ptp_ptt = NULL;\n\n\treturn 0;\n}\n\nconst struct qed_eth_ptp_ops qed_ptp_ops_pass = {\n\t.cfg_filters = qed_ptp_hw_cfg_filters,\n\t.read_rx_ts = qed_ptp_hw_read_rx_ts,\n\t.read_tx_ts = qed_ptp_hw_read_tx_ts,\n\t.read_cc = qed_ptp_hw_read_cc,\n\t.adjfreq = qed_ptp_hw_adjfreq,\n\t.disable = qed_ptp_hw_disable,\n\t.enable = qed_ptp_hw_enable,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}