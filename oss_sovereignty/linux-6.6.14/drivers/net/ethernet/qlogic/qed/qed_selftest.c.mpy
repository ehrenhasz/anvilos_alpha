{
  "module_name": "qed_selftest.c",
  "hash_id": "ab7109a8dbeae6f9f21803d927f7c64f38578eecf35d87896a1a3e091ad2aadf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/qlogic/qed/qed_selftest.c",
  "human_readable_source": "\n \n\n#include <linux/crc32.h>\n#include \"qed.h\"\n#include \"qed_dev_api.h\"\n#include \"qed_mcp.h\"\n#include \"qed_sp.h\"\n#include \"qed_selftest.h\"\n\nint qed_selftest_memory(struct qed_dev *cdev)\n{\n\tint rc = 0, i;\n\n\tfor_each_hwfn(cdev, i) {\n\t\trc = qed_sp_heartbeat_ramrod(&cdev->hwfns[i]);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\treturn rc;\n}\n\nint qed_selftest_interrupt(struct qed_dev *cdev)\n{\n\tint rc = 0, i;\n\n\tfor_each_hwfn(cdev, i) {\n\t\trc = qed_sp_heartbeat_ramrod(&cdev->hwfns[i]);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\treturn rc;\n}\n\nint qed_selftest_register(struct qed_dev *cdev)\n{\n\tstruct qed_hwfn *p_hwfn;\n\tstruct qed_ptt *p_ptt;\n\tint rc = 0, i;\n\n\t \n\tfor_each_hwfn(cdev, i) {\n\t\tp_hwfn = &cdev->hwfns[i];\n\t\tp_ptt = qed_ptt_acquire(p_hwfn);\n\t\tif (!p_ptt) {\n\t\t\tDP_ERR(p_hwfn, \"failed to acquire ptt\\n\");\n\t\t\treturn -EBUSY;\n\t\t}\n\t\trc = qed_mcp_bist_register_test(p_hwfn, p_ptt);\n\t\tqed_ptt_release(p_hwfn, p_ptt);\n\t\tif (rc)\n\t\t\tbreak;\n\t}\n\n\treturn rc;\n}\n\nint qed_selftest_clock(struct qed_dev *cdev)\n{\n\tstruct qed_hwfn *p_hwfn;\n\tstruct qed_ptt *p_ptt;\n\tint rc = 0, i;\n\n\t \n\tfor_each_hwfn(cdev, i) {\n\t\tp_hwfn = &cdev->hwfns[i];\n\t\tp_ptt = qed_ptt_acquire(p_hwfn);\n\t\tif (!p_ptt) {\n\t\t\tDP_ERR(p_hwfn, \"failed to acquire ptt\\n\");\n\t\t\treturn -EBUSY;\n\t\t}\n\t\trc = qed_mcp_bist_clock_test(p_hwfn, p_ptt);\n\t\tqed_ptt_release(p_hwfn, p_ptt);\n\t\tif (rc)\n\t\t\tbreak;\n\t}\n\n\treturn rc;\n}\n\nint qed_selftest_nvram(struct qed_dev *cdev)\n{\n\tstruct qed_hwfn *p_hwfn = QED_LEADING_HWFN(cdev);\n\tstruct qed_ptt *p_ptt = qed_ptt_acquire(p_hwfn);\n\tu32 num_images, i, j, nvm_crc, calc_crc;\n\tstruct bist_nvm_image_att image_att;\n\tu8 *buf = NULL;\n\t__be32 val;\n\tint rc;\n\n\tif (!p_ptt) {\n\t\tDP_ERR(p_hwfn, \"failed to acquire ptt\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\t \n\trc = qed_mcp_bist_nvm_get_num_images(p_hwfn, p_ptt, &num_images);\n\tif (rc || !num_images) {\n\t\tDP_ERR(p_hwfn, \"Failed getting number of images\\n\");\n\t\trc = -EINVAL;\n\t\tgoto err0;\n\t}\n\n\t \n\tfor (i = 0; i < num_images; i++) {\n\t\t \n\t\trc = qed_mcp_bist_nvm_get_image_att(p_hwfn, p_ptt,\n\t\t\t\t\t\t    &image_att, i);\n\t\tif (rc) {\n\t\t\tDP_ERR(p_hwfn,\n\t\t\t       \"Failed getting image index %d attributes\\n\",\n\t\t\t       i);\n\t\t\tgoto err0;\n\t\t}\n\n\t\t \n\t\tif (image_att.image_type == NVM_TYPE_MDUMP)\n\t\t\tcontinue;\n\n\t\tDP_VERBOSE(p_hwfn, QED_MSG_SP, \"image index %d, size %x\\n\",\n\t\t\t   i, image_att.len);\n\n\t\t \n\t\tbuf = kzalloc(image_att.len, GFP_KERNEL);\n\t\tif (!buf) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto err0;\n\t\t}\n\n\t\t \n\t\trc = qed_mcp_nvm_read(p_hwfn->cdev, image_att.nvm_start_addr,\n\t\t\t\t      buf, image_att.len);\n\t\tif (rc) {\n\t\t\tDP_ERR(p_hwfn,\n\t\t\t       \"Failed reading image index %d from nvm.\\n\", i);\n\t\t\tgoto err1;\n\t\t}\n\n\t\t \n\t\tfor (j = 0; j < image_att.len - 4; j += 4) {\n\t\t\tval = cpu_to_be32(*(u32 *)&buf[j]);\n\t\t\t*(u32 *)&buf[j] = (__force u32)val;\n\t\t}\n\n\t\t \n\t\tnvm_crc = *(u32 *)(buf + image_att.len - 4);\n\t\tcalc_crc = crc32(0xffffffff, buf, image_att.len - 4);\n\t\tcalc_crc = (__force u32)~cpu_to_be32(calc_crc);\n\t\tDP_VERBOSE(p_hwfn, QED_MSG_SP,\n\t\t\t   \"nvm crc 0x%x, calc_crc 0x%x\\n\", nvm_crc, calc_crc);\n\n\t\tif (calc_crc != nvm_crc) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto err1;\n\t\t}\n\n\t\t \n\t\tkfree(buf);\n\t\tbuf = NULL;\n\t}\n\n\tqed_ptt_release(p_hwfn, p_ptt);\n\treturn 0;\n\nerr1:\n\tkfree(buf);\nerr0:\n\tqed_ptt_release(p_hwfn, p_ptt);\n\treturn rc;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}