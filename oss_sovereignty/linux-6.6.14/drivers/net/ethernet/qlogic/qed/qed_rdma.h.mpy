{
  "module_name": "qed_rdma.h",
  "hash_id": "6d14bb713bba575f07e5a24c6391dd2fa4fd95f772db42335ae0b440af483463",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/qlogic/qed/qed_rdma.h",
  "human_readable_source": " \n \n\n#ifndef _QED_RDMA_H\n#define _QED_RDMA_H\n#include <linux/types.h>\n#include <linux/bitops.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/qed/qed_if.h>\n#include <linux/qed/qed_rdma_if.h>\n#include \"qed.h\"\n#include \"qed_dev_api.h\"\n#include \"qed_hsi.h\"\n#include \"qed_iwarp.h\"\n#include \"qed_roce.h\"\n\n#define QED_RDMA_MAX_P_KEY                  (1)\n#define QED_RDMA_MAX_WQE                    (0x7FFF)\n#define QED_RDMA_MAX_SRQ_WQE_ELEM           (0x7FFF)\n#define QED_RDMA_PAGE_SIZE_CAPS             (0xFFFFF000)\n#define QED_RDMA_ACK_DELAY                  (15)\n#define QED_RDMA_MAX_MR_SIZE                (0x10000000000ULL)\n#define QED_RDMA_MAX_CQS                    (RDMA_MAX_CQS)\n#define QED_RDMA_MAX_MRS                    (RDMA_MAX_TIDS)\n \n#define QED_RDMA_MAX_SRQ_ELEM_PER_WQE\t    (RDMA_MAX_SGE_PER_RQ_WQE + 1)\n#define QED_RDMA_MAX_SGE_PER_SRQ_WQE        (RDMA_MAX_SGE_PER_RQ_WQE)\n#define QED_RDMA_SRQ_WQE_ELEM_SIZE          (16)\n#define QED_RDMA_MAX_SRQS                   (32 * 1024)\n\n#define QED_RDMA_MAX_CQE_32_BIT             (0x7FFFFFFF - 1)\n#define QED_RDMA_MAX_CQE_16_BIT             (0x7FFF - 1)\n\n \n#define QED_RDMA_MAX_XRCDS      (roundup_pow_of_two(RDMA_MAX_XRC_SRQS))\n\nenum qed_rdma_toggle_bit {\n\tQED_RDMA_TOGGLE_BIT_CLEAR = 0,\n\tQED_RDMA_TOGGLE_BIT_SET = 1\n};\n\n#define QED_RDMA_MAX_BMAP_NAME\t(10)\nstruct qed_bmap {\n\tunsigned long *bitmap;\n\tu32 max_count;\n\tchar name[QED_RDMA_MAX_BMAP_NAME];\n};\n\nstruct qed_rdma_info {\n\t \n\tspinlock_t lock;\n\n\tstruct qed_bmap cq_map;\n\tstruct qed_bmap pd_map;\n\tstruct qed_bmap xrcd_map;\n\tstruct qed_bmap tid_map;\n\tstruct qed_bmap qp_map;\n\tstruct qed_bmap srq_map;\n\tstruct qed_bmap xrc_srq_map;\n\tstruct qed_bmap cid_map;\n\tstruct qed_bmap tcp_cid_map;\n\tstruct qed_bmap real_cid_map;\n\tstruct qed_bmap dpi_map;\n\tstruct qed_bmap toggle_bits;\n\tstruct qed_rdma_events events;\n\tstruct qed_rdma_device *dev;\n\tstruct qed_rdma_port *port;\n\tu32 last_tid;\n\tu8 num_cnqs;\n\tu32 num_qps;\n\tu32 num_mrs;\n\tu32 num_srqs;\n\tu16 srq_id_offset;\n\tu16 queue_zone_base;\n\tu16 max_queue_zones;\n\tenum protocol_type proto;\n\tstruct qed_iwarp_info iwarp;\n\tu8 active:1;\n};\n\nstruct qed_rdma_qp {\n\tstruct regpair qp_handle;\n\tstruct regpair qp_handle_async;\n\tu32 qpid;\n\tu16 icid;\n\tenum qed_roce_qp_state cur_state;\n\tenum qed_rdma_qp_type qp_type;\n\tenum qed_iwarp_qp_state iwarp_state;\n\tbool use_srq;\n\tbool signal_all;\n\tbool fmr_and_reserved_lkey;\n\n\tbool incoming_rdma_read_en;\n\tbool incoming_rdma_write_en;\n\tbool incoming_atomic_en;\n\tbool e2e_flow_control_en;\n\n\tu16 pd;\n\tu16 pkey;\n\tu32 dest_qp;\n\tu16 mtu;\n\tu16 srq_id;\n\tu8 traffic_class_tos;\n\tu8 hop_limit_ttl;\n\tu16 dpi;\n\tu32 flow_label;\n\tbool lb_indication;\n\tu16 vlan_id;\n\tu32 ack_timeout;\n\tu8 retry_cnt;\n\tu8 rnr_retry_cnt;\n\tu8 min_rnr_nak_timer;\n\tbool sqd_async;\n\tunion qed_gid sgid;\n\tunion qed_gid dgid;\n\tenum roce_mode roce_mode;\n\tu16 udp_src_port;\n\tu8 stats_queue;\n\n\t \n\tu8 max_rd_atomic_req;\n\tu32 sq_psn;\n\tu16 sq_cq_id;\n\tu16 sq_num_pages;\n\tdma_addr_t sq_pbl_ptr;\n\tvoid *orq;\n\tdma_addr_t orq_phys_addr;\n\tu8 orq_num_pages;\n\tbool req_offloaded;\n\tbool has_req;\n\n\t \n\tu8 max_rd_atomic_resp;\n\tu32 rq_psn;\n\tu16 rq_cq_id;\n\tu16 rq_num_pages;\n\tu16 xrcd_id;\n\tdma_addr_t rq_pbl_ptr;\n\tvoid *irq;\n\tdma_addr_t irq_phys_addr;\n\tu8 irq_num_pages;\n\tbool resp_offloaded;\n\tu32 cq_prod;\n\tbool has_resp;\n\n\tu8 remote_mac_addr[6];\n\tu8 local_mac_addr[6];\n\n\tvoid *shared_queue;\n\tdma_addr_t shared_queue_phys_addr;\n\tstruct qed_iwarp_ep *ep;\n\tu8 edpm_mode;\n};\n\nstatic inline bool qed_rdma_is_xrc_qp(struct qed_rdma_qp *qp)\n{\n\tif (qp->qp_type == QED_RDMA_QP_TYPE_XRC_TGT ||\n\t    qp->qp_type == QED_RDMA_QP_TYPE_XRC_INI)\n\t\treturn true;\n\n\treturn false;\n}\n\n#if IS_ENABLED(CONFIG_QED_RDMA)\nvoid qed_rdma_dpm_bar(struct qed_hwfn *p_hwfn, struct qed_ptt *p_ptt);\nvoid qed_rdma_dpm_conf(struct qed_hwfn *p_hwfn, struct qed_ptt *p_ptt);\nint qed_rdma_info_alloc(struct qed_hwfn *p_hwfn);\nvoid qed_rdma_info_free(struct qed_hwfn *p_hwfn);\n#else\nstatic inline void qed_rdma_dpm_conf(struct qed_hwfn *p_hwfn,\n\t\t\t\t     struct qed_ptt *p_ptt) {}\nstatic inline void qed_rdma_dpm_bar(struct qed_hwfn *p_hwfn,\n\t\t\t\t    struct qed_ptt *p_ptt) {}\nstatic inline int qed_rdma_info_alloc(struct qed_hwfn *p_hwfn)\n\t\t\t\t      {return -EINVAL; }\nstatic inline void qed_rdma_info_free(struct qed_hwfn *p_hwfn) {}\n#endif\n\nint\nqed_rdma_bmap_alloc(struct qed_hwfn *p_hwfn,\n\t\t    struct qed_bmap *bmap, u32 max_count, char *name);\n\nvoid\nqed_rdma_bmap_free(struct qed_hwfn *p_hwfn, struct qed_bmap *bmap, bool check);\n\nint\nqed_rdma_bmap_alloc_id(struct qed_hwfn *p_hwfn,\n\t\t       struct qed_bmap *bmap, u32 *id_num);\n\nvoid\nqed_bmap_set_id(struct qed_hwfn *p_hwfn, struct qed_bmap *bmap, u32 id_num);\n\nvoid\nqed_bmap_release_id(struct qed_hwfn *p_hwfn, struct qed_bmap *bmap, u32 id_num);\n\nint\nqed_bmap_test_id(struct qed_hwfn *p_hwfn, struct qed_bmap *bmap, u32 id_num);\n\nvoid qed_rdma_set_fw_mac(__le16 *p_fw_mac, const u8 *p_qed_mac);\n\nbool qed_rdma_allocated_qps(struct qed_hwfn *p_hwfn);\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}