{
  "module_name": "qed_sriov.h",
  "hash_id": "a7773c428c5057dd53ae5bdf134e289b1a135a9b5947fb0f1904db9b6b6a2194",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/qlogic/qed/qed_sriov.h",
  "human_readable_source": " \n \n\n#ifndef _QED_SRIOV_H\n#define _QED_SRIOV_H\n#include <linux/types.h>\n#include \"qed_vf.h\"\n\n#define QED_ETH_VF_NUM_MAC_FILTERS 1\n#define QED_ETH_VF_NUM_VLAN_FILTERS 2\n#define QED_VF_ARRAY_LENGTH (3)\n\n#ifdef CONFIG_QED_SRIOV\n#define IS_VF(cdev)             ((cdev)->b_is_vf)\n#define IS_PF(cdev)             (!((cdev)->b_is_vf))\n#define IS_PF_SRIOV(p_hwfn)     (!!((p_hwfn)->cdev->p_iov_info))\n#else\n#define IS_VF(cdev)             (0)\n#define IS_PF(cdev)             (1)\n#define IS_PF_SRIOV(p_hwfn)     (0)\n#endif\n#define IS_PF_SRIOV_ALLOC(p_hwfn)       (!!((p_hwfn)->pf_iov_info))\n\n#define QED_MAX_VF_CHAINS_PER_PF 16\n\n#define QED_ETH_MAX_VF_NUM_VLAN_FILTERS\t\\\n\t(MAX_NUM_VFS * QED_ETH_VF_NUM_VLAN_FILTERS)\n\nenum qed_iov_vport_update_flag {\n\tQED_IOV_VP_UPDATE_ACTIVATE,\n\tQED_IOV_VP_UPDATE_VLAN_STRIP,\n\tQED_IOV_VP_UPDATE_TX_SWITCH,\n\tQED_IOV_VP_UPDATE_MCAST,\n\tQED_IOV_VP_UPDATE_ACCEPT_PARAM,\n\tQED_IOV_VP_UPDATE_RSS,\n\tQED_IOV_VP_UPDATE_ACCEPT_ANY_VLAN,\n\tQED_IOV_VP_UPDATE_SGE_TPA,\n\tQED_IOV_VP_UPDATE_MAX,\n};\n\nstruct qed_public_vf_info {\n\t \n\tu8 forced_mac[ETH_ALEN];\n\tu16 forced_vlan;\n\tu8 mac[ETH_ALEN];\n\n\t \n\tint link_state;\n\n\t \n\tint tx_rate;\n\n\t \n\tbool is_trusted_configured;\n\tbool is_trusted_request;\n\tu8 rx_accept_mode;\n\tu8 tx_accept_mode;\n\tbool accept_any_vlan;\n};\n\nstruct qed_iov_vf_init_params {\n\tu16 rel_vf_id;\n\n\t \n\n\tu16 num_queues;\n\n\t \n\tu16 req_rx_queue[QED_MAX_VF_CHAINS_PER_PF];\n\tu16 req_tx_queue[QED_MAX_VF_CHAINS_PER_PF];\n};\n\n \nstruct qed_hw_sriov_info {\n\tint pos;\t\t \n\tint nres;\t\t \n\tu32 cap;\t\t \n\tu16 ctrl;\t\t \n\tu16 total_vfs;\t\t \n\tu16 num_vfs;\t\t \n\tu16 initial_vfs;\t \n\tu16 nr_virtfn;\t\t \n\tu16 offset;\t\t \n\tu16 stride;\t\t \n\tu16 vf_device_id;\t \n\tu32 pgsz;\t\t \n\tu8 link;\t\t \n\n\tu32 first_vf_in_pf;\n};\n\n \nstruct qed_iov_vf_mbx {\n\tunion vfpf_tlvs *req_virt;\n\tdma_addr_t req_phys;\n\tunion pfvf_tlvs *reply_virt;\n\tdma_addr_t reply_phys;\n\n\t \n\tdma_addr_t pending_req;\n\n\t \n\tbool b_pending_msg;\n\n\tu8 *offset;\n\n\t \n\tstruct vfpf_first_tlv first_tlv;\n};\n\n#define QED_IOV_LEGACY_QID_RX (0)\n#define QED_IOV_LEGACY_QID_TX (1)\n#define QED_IOV_QID_INVALID (0xFE)\n\nstruct qed_vf_queue_cid {\n\tbool b_is_tx;\n\tstruct qed_queue_cid *p_cid;\n};\n\n \nstruct qed_vf_queue {\n\tu16 fw_rx_qid;\n\tu16 fw_tx_qid;\n\n\tstruct qed_vf_queue_cid cids[MAX_QUEUES_PER_QZONE];\n};\n\nenum vf_state {\n\tVF_FREE = 0,\t\t \n\tVF_ACQUIRED,\t\t \n\tVF_ENABLED,\t\t \n\tVF_RESET,\t\t \n\tVF_STOPPED\t\t \n};\n\nstruct qed_vf_vlan_shadow {\n\tbool used;\n\tu16 vid;\n};\n\nstruct qed_vf_shadow_config {\n\t \n\tstruct qed_vf_vlan_shadow vlans[QED_ETH_VF_NUM_VLAN_FILTERS + 1];\n\n\t \n\tu8 macs[QED_ETH_VF_NUM_MAC_FILTERS][ETH_ALEN];\n\tu8 inner_vlan_removal;\n};\n\n \nstruct qed_vf_info {\n\tstruct qed_iov_vf_mbx vf_mbx;\n\tenum vf_state state;\n\tbool b_init;\n\tbool b_malicious;\n\tu8 to_disable;\n\n\tstruct qed_bulletin bulletin;\n\tdma_addr_t vf_bulletin;\n\n\t \n\tstruct vfpf_acquire_tlv acquire;\n\n\tu32 concrete_fid;\n\tu16 opaque_fid;\n\tu16 mtu;\n\n\tu8 vport_id;\n\tu8 relative_vf_id;\n\tu8 abs_vf_id;\n#define QED_VF_ABS_ID(p_hwfn, p_vf)\t(QED_PATH_ID(p_hwfn) ?\t\t      \\\n\t\t\t\t\t (p_vf)->abs_vf_id + MAX_NUM_VFS_BB : \\\n\t\t\t\t\t (p_vf)->abs_vf_id)\n\n\tu8 vport_instance;\n\tu8 num_rxqs;\n\tu8 num_txqs;\n\n\tu16 rx_coal;\n\tu16 tx_coal;\n\n\tu8 num_sbs;\n\n\tu8 num_mac_filters;\n\tu8 num_vlan_filters;\n\n\tstruct qed_vf_queue vf_queues[QED_MAX_VF_CHAINS_PER_PF];\n\tu16 igu_sbs[QED_MAX_VF_CHAINS_PER_PF];\n\tu8 num_active_rxqs;\n\tstruct qed_public_vf_info p_vf_info;\n\tbool spoof_chk;\n\tbool req_spoofchk_val;\n\n\t \n\tstruct qed_vf_shadow_config shadow_config;\n\n\t \n\tu64 configured_features;\n#define QED_IOV_CONFIGURED_FEATURES_MASK        ((1 << MAC_ADDR_FORCED) | \\\n\t\t\t\t\t\t (1 << VLAN_ADDR_FORCED))\n};\n\n \nstruct qed_pf_iov {\n\tstruct qed_vf_info vfs_array[MAX_NUM_VFS];\n\tu64 pending_flr[QED_VF_ARRAY_LENGTH];\n\n\t \n\tvoid *mbx_msg_virt_addr;\n\tdma_addr_t mbx_msg_phys_addr;\n\tu32 mbx_msg_size;\n\tvoid *mbx_reply_virt_addr;\n\tdma_addr_t mbx_reply_phys_addr;\n\tu32 mbx_reply_size;\n\tvoid *p_bulletins;\n\tdma_addr_t bulletins_phys;\n\tu32 bulletins_size;\n};\n\nenum qed_iov_wq_flag {\n\tQED_IOV_WQ_MSG_FLAG,\n\tQED_IOV_WQ_SET_UNICAST_FILTER_FLAG,\n\tQED_IOV_WQ_BULLETIN_UPDATE_FLAG,\n\tQED_IOV_WQ_STOP_WQ_FLAG,\n\tQED_IOV_WQ_FLR_FLAG,\n\tQED_IOV_WQ_TRUST_FLAG,\n\tQED_IOV_WQ_VF_FORCE_LINK_QUERY_FLAG,\n};\n\nextern const struct qed_iov_hv_ops qed_iov_ops_pass;\n\n#ifdef CONFIG_QED_SRIOV\n \nbool qed_iov_is_valid_vfid(struct qed_hwfn *p_hwfn,\n\t\t\t   int rel_vf_id,\n\t\t\t   bool b_enabled_only, bool b_non_malicious);\n\n \nu16 qed_iov_get_next_active_vf(struct qed_hwfn *p_hwfn, u16 rel_vf_id);\n\nvoid qed_iov_bulletin_set_udp_ports(struct qed_hwfn *p_hwfn,\n\t\t\t\t    int vfid, u16 vxlan_port, u16 geneve_port);\n\n \nint qed_iov_hw_info(struct qed_hwfn *p_hwfn);\n\n \nvoid *qed_add_tlv(struct qed_hwfn *p_hwfn, u8 **offset, u16 type, u16 length);\n\n \nvoid qed_dp_tlv_list(struct qed_hwfn *p_hwfn, void *tlvs_list);\n\n \nvoid qed_sriov_vfpf_malicious(struct qed_hwfn *p_hwfn,\n\t\t\t      struct fw_err_data *p_data);\n\n \nint qed_sriov_eqe_event(struct qed_hwfn *p_hwfn, u8 opcode, __le16 echo,\n\t\t\tunion event_ring_data *data, u8  fw_return_code);\n\n \nint qed_iov_alloc(struct qed_hwfn *p_hwfn);\n\n \nvoid qed_iov_setup(struct qed_hwfn *p_hwfn);\n\n \nvoid qed_iov_free(struct qed_hwfn *p_hwfn);\n\n \nvoid qed_iov_free_hw_info(struct qed_dev *cdev);\n\n \nbool qed_iov_mark_vf_flr(struct qed_hwfn *p_hwfn, u32 *disabled_vfs);\n\n \nvoid *qed_iov_search_list_tlvs(struct qed_hwfn *p_hwfn,\n\t\t\t       void *p_tlvs_list, u16 req_type);\n\nvoid qed_iov_wq_stop(struct qed_dev *cdev, bool schedule_first);\nint qed_iov_wq_start(struct qed_dev *cdev);\n\nvoid qed_schedule_iov(struct qed_hwfn *hwfn, enum qed_iov_wq_flag flag);\nvoid qed_vf_start_iov_wq(struct qed_dev *cdev);\nint qed_sriov_disable(struct qed_dev *cdev, bool pci_enabled);\nvoid qed_inform_vf_link_state(struct qed_hwfn *hwfn);\n#else\nstatic inline bool\nqed_iov_is_valid_vfid(struct qed_hwfn *p_hwfn,\n\t\t      int rel_vf_id, bool b_enabled_only, bool b_non_malicious)\n{\n\treturn false;\n}\n\nstatic inline u16 qed_iov_get_next_active_vf(struct qed_hwfn *p_hwfn,\n\t\t\t\t\t     u16 rel_vf_id)\n{\n\treturn MAX_NUM_VFS;\n}\n\nstatic inline void\nqed_iov_bulletin_set_udp_ports(struct qed_hwfn *p_hwfn, int vfid,\n\t\t\t       u16 vxlan_port, u16 geneve_port)\n{\n}\n\nstatic inline int qed_iov_hw_info(struct qed_hwfn *p_hwfn)\n{\n\treturn 0;\n}\n\nstatic inline int qed_iov_alloc(struct qed_hwfn *p_hwfn)\n{\n\treturn 0;\n}\n\nstatic inline void qed_iov_setup(struct qed_hwfn *p_hwfn)\n{\n}\n\nstatic inline void qed_iov_free(struct qed_hwfn *p_hwfn)\n{\n}\n\nstatic inline void qed_iov_free_hw_info(struct qed_dev *cdev)\n{\n}\n\nstatic inline bool qed_iov_mark_vf_flr(struct qed_hwfn *p_hwfn,\n\t\t\t\t       u32 *disabled_vfs)\n{\n\treturn false;\n}\n\nstatic inline void qed_iov_wq_stop(struct qed_dev *cdev, bool schedule_first)\n{\n}\n\nstatic inline int qed_iov_wq_start(struct qed_dev *cdev)\n{\n\treturn 0;\n}\n\nstatic inline void qed_schedule_iov(struct qed_hwfn *hwfn,\n\t\t\t\t    enum qed_iov_wq_flag flag)\n{\n}\n\nstatic inline void qed_vf_start_iov_wq(struct qed_dev *cdev)\n{\n}\n\nstatic inline int qed_sriov_disable(struct qed_dev *cdev, bool pci_enabled)\n{\n\treturn 0;\n}\n\nstatic inline void qed_inform_vf_link_state(struct qed_hwfn *hwfn)\n{\n}\n\nstatic inline void qed_sriov_vfpf_malicious(struct qed_hwfn *p_hwfn,\n\t\t\t\t\t    struct fw_err_data *p_data)\n{\n}\n\nstatic inline int qed_sriov_eqe_event(struct qed_hwfn *p_hwfn, u8 opcode,\n\t\t\t\t      __le16 echo, union event_ring_data *data,\n\t\t\t\t      u8  fw_return_code)\n{\n\treturn 0;\n}\n#endif\n\n#define qed_for_each_vf(_p_hwfn, _i)\t\t\t  \\\n\tfor (_i = qed_iov_get_next_active_vf(_p_hwfn, 0); \\\n\t     _i < MAX_NUM_VFS;\t\t\t\t  \\\n\t     _i = qed_iov_get_next_active_vf(_p_hwfn, _i + 1))\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}