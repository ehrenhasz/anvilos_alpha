{
  "module_name": "qed_iwarp.h",
  "hash_id": "76bd75b517134ee55d9e496803747afe5c043e8ee16e2c195012d5fb851c97c5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/qlogic/qed/qed_iwarp.h",
  "human_readable_source": " \n \n\n#ifndef _QED_IWARP_H\n#define _QED_IWARP_H\n\nenum qed_iwarp_qp_state {\n\tQED_IWARP_QP_STATE_IDLE,\n\tQED_IWARP_QP_STATE_RTS,\n\tQED_IWARP_QP_STATE_TERMINATE,\n\tQED_IWARP_QP_STATE_CLOSING,\n\tQED_IWARP_QP_STATE_ERROR,\n};\n\nenum qed_iwarp_qp_state qed_roce2iwarp_state(enum qed_roce_qp_state state);\n\n#define QED_IWARP_PREALLOC_CNT  (256)\n\n#define QED_IWARP_LL2_SYN_TX_SIZE       (128)\n#define QED_IWARP_LL2_SYN_RX_SIZE       (256)\n\n#define QED_IWARP_LL2_OOO_DEF_TX_SIZE   (256)\n#define QED_IWARP_MAX_OOO\t\t(16)\n#define QED_IWARP_LL2_OOO_MAX_RX_SIZE   (16384)\n\n#define QED_IWARP_HANDLE_INVAL\t\t(0xff)\n\nstruct qed_iwarp_ll2_buff {\n\tstruct qed_iwarp_ll2_buff *piggy_buf;\n\tvoid *data;\n\tdma_addr_t data_phys_addr;\n\tu32 buff_size;\n};\n\nstruct qed_iwarp_ll2_mpa_buf {\n\tstruct list_head list_entry;\n\tstruct qed_iwarp_ll2_buff *ll2_buf;\n\tstruct unaligned_opaque_data data;\n\tu16 tcp_payload_len;\n\tu8 placement_offset;\n};\n\n \n#define QED_IWARP_INVALID_INCOMPLETE_BYTES 0xffff\n\nstruct qed_iwarp_fpdu {\n\tstruct qed_iwarp_ll2_buff *mpa_buf;\n\tvoid *mpa_frag_virt;\n\tdma_addr_t mpa_frag;\n\tdma_addr_t pkt_hdr;\n\tu16 mpa_frag_len;\n\tu16 fpdu_length;\n\tu16 incomplete_bytes;\n\tu8 pkt_hdr_size;\n};\n\nstruct qed_iwarp_info {\n\tstruct list_head listen_list;\t \n\tstruct list_head ep_list;\t \n\tstruct list_head ep_free_list;\t \n\tstruct list_head mpa_buf_list;\t \n\tstruct list_head mpa_buf_pending_list;\n\tspinlock_t iw_lock;\t \n\tspinlock_t qp_lock;\t \n\tu32 rcv_wnd_scale;\n\tu16 rcv_wnd_size;\n\tu16 max_mtu;\n\tu8 mac_addr[ETH_ALEN];\n\tu8 crc_needed;\n\tu8 tcp_flags;\n\tu8 ll2_syn_handle;\n\tu8 ll2_ooo_handle;\n\tu8 ll2_mpa_handle;\n\tu8 peer2peer;\n\tenum mpa_negotiation_mode mpa_rev;\n\tenum mpa_rtr_type rtr_type;\n\tstruct qed_iwarp_fpdu *partial_fpdus;\n\tstruct qed_iwarp_ll2_mpa_buf *mpa_bufs;\n\tu8 *mpa_intermediate_buf;\n\tu16 max_num_partial_fpdus;\n};\n\nenum qed_iwarp_ep_state {\n\tQED_IWARP_EP_INIT,\n\tQED_IWARP_EP_MPA_REQ_RCVD,\n\tQED_IWARP_EP_MPA_OFFLOADED,\n\tQED_IWARP_EP_ESTABLISHED,\n\tQED_IWARP_EP_CLOSED\n};\n\nunion async_output {\n\tstruct iwarp_eqe_data_mpa_async_completion mpa_response;\n\tstruct iwarp_eqe_data_tcp_async_completion mpa_request;\n};\n\n#define QED_MAX_PRIV_DATA_LEN (512)\nstruct qed_iwarp_ep_memory {\n\tu8 in_pdata[QED_MAX_PRIV_DATA_LEN];\n\tu8 out_pdata[QED_MAX_PRIV_DATA_LEN];\n\tunion async_output async_output;\n};\n\n \nstruct qed_iwarp_ep {\n\tstruct list_head list_entry;\n\tstruct qed_rdma_qp *qp;\n\tstruct qed_iwarp_ep_memory *ep_buffer_virt;\n\tdma_addr_t ep_buffer_phys;\n\tenum qed_iwarp_ep_state state;\n\tint sig;\n\tstruct qed_iwarp_cm_info cm_info;\n\tenum tcp_connect_mode connect_mode;\n\tenum mpa_rtr_type rtr_type;\n\tenum mpa_negotiation_mode mpa_rev;\n\tu32 tcp_cid;\n\tu32 cid;\n\tu16 mss;\n\tu8 remote_mac_addr[6];\n\tu8 local_mac_addr[6];\n\tbool mpa_reply_processed;\n\n\t \n\tu16 syn_ip_payload_length;\n\tstruct qed_iwarp_ll2_buff *syn;\n\tdma_addr_t syn_phy_addr;\n\n\t \n\tiwarp_event_handler event_cb;\n\tvoid *cb_context;\n};\n\nstruct qed_iwarp_listener {\n\tstruct list_head list_entry;\n\n\t \n\tiwarp_event_handler event_cb;\n\tvoid *cb_context;\n\tu32 max_backlog;\n\tu32 ip_addr[4];\n\tu16 port;\n\tu16 vlan;\n\tu8 ip_version;\n};\n\nint qed_iwarp_alloc(struct qed_hwfn *p_hwfn);\n\nint qed_iwarp_setup(struct qed_hwfn *p_hwfn,\n\t\t    struct qed_rdma_start_in_params *params);\n\nvoid qed_iwarp_init_fw_ramrod(struct qed_hwfn *p_hwfn,\n\t\t\t      struct iwarp_init_func_ramrod_data *p_ramrod);\n\nint qed_iwarp_stop(struct qed_hwfn *p_hwfn);\n\nvoid qed_iwarp_resc_free(struct qed_hwfn *p_hwfn);\n\nvoid qed_iwarp_init_devinfo(struct qed_hwfn *p_hwfn);\n\nvoid qed_iwarp_init_hw(struct qed_hwfn *p_hwfn, struct qed_ptt *p_ptt);\n\nint qed_iwarp_create_qp(struct qed_hwfn *p_hwfn,\n\t\t\tstruct qed_rdma_qp *qp,\n\t\t\tstruct qed_rdma_create_qp_out_params *out_params);\n\nint qed_iwarp_modify_qp(struct qed_hwfn *p_hwfn, struct qed_rdma_qp *qp,\n\t\t\tenum qed_iwarp_qp_state new_state, bool internal);\n\nint qed_iwarp_destroy_qp(struct qed_hwfn *p_hwfn, struct qed_rdma_qp *qp);\n\nint qed_iwarp_fw_destroy(struct qed_hwfn *p_hwfn, struct qed_rdma_qp *qp);\n\nvoid qed_iwarp_query_qp(struct qed_rdma_qp *qp,\n\t\t\tstruct qed_rdma_query_qp_out_params *out_params);\n\nint\nqed_iwarp_connect(void *rdma_cxt,\n\t\t  struct qed_iwarp_connect_in *iparams,\n\t\t  struct qed_iwarp_connect_out *oparams);\n\nint\nqed_iwarp_create_listen(void *rdma_cxt,\n\t\t\tstruct qed_iwarp_listen_in *iparams,\n\t\t\tstruct qed_iwarp_listen_out *oparams);\n\nint qed_iwarp_accept(void *rdma_cxt, struct qed_iwarp_accept_in *iparams);\n\nint qed_iwarp_reject(void *rdma_cxt, struct qed_iwarp_reject_in *iparams);\nint qed_iwarp_destroy_listen(void *rdma_cxt, void *handle);\n\nint qed_iwarp_send_rtr(void *rdma_cxt, struct qed_iwarp_send_rtr_in *iparams);\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}