{
  "module_name": "qed_devlink.c",
  "hash_id": "62d0d9fe9772bd470f636376210f6ba465b86d0d880f454775b75d616e568dd3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/qlogic/qed/qed_devlink.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/qed/qed_if.h>\n#include <linux/vmalloc.h>\n#include \"qed.h\"\n#include \"qed_devlink.h\"\n\nenum qed_devlink_param_id {\n\tQED_DEVLINK_PARAM_ID_BASE = DEVLINK_PARAM_GENERIC_ID_MAX,\n\tQED_DEVLINK_PARAM_ID_IWARP_CMT,\n};\n\nstruct qed_fw_fatal_ctx {\n\tenum qed_hw_err_type err_type;\n};\n\nint qed_report_fatal_error(struct devlink *devlink, enum qed_hw_err_type err_type)\n{\n\tstruct qed_devlink *qdl = devlink_priv(devlink);\n\tstruct qed_fw_fatal_ctx fw_fatal_ctx = {\n\t\t.err_type = err_type,\n\t};\n\n\tif (qdl->fw_reporter)\n\t\tdevlink_health_report(qdl->fw_reporter,\n\t\t\t\t      \"Fatal error occurred\", &fw_fatal_ctx);\n\n\treturn 0;\n}\n\nstatic int\nqed_fw_fatal_reporter_dump(struct devlink_health_reporter *reporter,\n\t\t\t   struct devlink_fmsg *fmsg, void *priv_ctx,\n\t\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct qed_devlink *qdl = devlink_health_reporter_priv(reporter);\n\tstruct qed_fw_fatal_ctx *fw_fatal_ctx = priv_ctx;\n\tstruct qed_dev *cdev = qdl->cdev;\n\tu32 dbg_data_buf_size;\n\tu8 *p_dbg_data_buf;\n\tint err;\n\n\t \n\tcdev->print_dbg_data = fw_fatal_ctx ? true : false;\n\n\tdbg_data_buf_size = qed_dbg_all_data_size(cdev);\n\tp_dbg_data_buf = vzalloc(dbg_data_buf_size);\n\tif (!p_dbg_data_buf) {\n\t\tDP_NOTICE(cdev,\n\t\t\t  \"Failed to allocate memory for a debug data buffer\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\terr = qed_dbg_all_data(cdev, p_dbg_data_buf);\n\tif (err) {\n\t\tDP_NOTICE(cdev, \"Failed to obtain debug data\\n\");\n\t\tvfree(p_dbg_data_buf);\n\t\treturn err;\n\t}\n\n\terr = devlink_fmsg_binary_pair_put(fmsg, \"dump_data\",\n\t\t\t\t\t   p_dbg_data_buf, dbg_data_buf_size);\n\n\tvfree(p_dbg_data_buf);\n\n\treturn err;\n}\n\nstatic int\nqed_fw_fatal_reporter_recover(struct devlink_health_reporter *reporter,\n\t\t\t      void *priv_ctx,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct qed_devlink *qdl = devlink_health_reporter_priv(reporter);\n\tstruct qed_dev *cdev = qdl->cdev;\n\n\tqed_recovery_process(cdev);\n\n\treturn 0;\n}\n\nstatic const struct devlink_health_reporter_ops qed_fw_fatal_reporter_ops = {\n\t\t.name = \"fw_fatal\",\n\t\t.recover = qed_fw_fatal_reporter_recover,\n\t\t.dump = qed_fw_fatal_reporter_dump,\n};\n\n#define QED_REPORTER_FW_GRACEFUL_PERIOD 0\n\nvoid qed_fw_reporters_create(struct devlink *devlink)\n{\n\tstruct qed_devlink *dl = devlink_priv(devlink);\n\n\tdl->fw_reporter = devlink_health_reporter_create(devlink, &qed_fw_fatal_reporter_ops,\n\t\t\t\t\t\t\t QED_REPORTER_FW_GRACEFUL_PERIOD, dl);\n\tif (IS_ERR(dl->fw_reporter)) {\n\t\tDP_NOTICE(dl->cdev, \"Failed to create fw reporter, err = %ld\\n\",\n\t\t\t  PTR_ERR(dl->fw_reporter));\n\t\tdl->fw_reporter = NULL;\n\t}\n}\n\nvoid qed_fw_reporters_destroy(struct devlink *devlink)\n{\n\tstruct qed_devlink *dl = devlink_priv(devlink);\n\tstruct devlink_health_reporter *rep;\n\n\trep = dl->fw_reporter;\n\n\tif (!IS_ERR_OR_NULL(rep))\n\t\tdevlink_health_reporter_destroy(rep);\n}\n\nstatic int qed_dl_param_get(struct devlink *dl, u32 id,\n\t\t\t    struct devlink_param_gset_ctx *ctx)\n{\n\tstruct qed_devlink *qed_dl = devlink_priv(dl);\n\tstruct qed_dev *cdev;\n\n\tcdev = qed_dl->cdev;\n\tctx->val.vbool = cdev->iwarp_cmt;\n\n\treturn 0;\n}\n\nstatic int qed_dl_param_set(struct devlink *dl, u32 id,\n\t\t\t    struct devlink_param_gset_ctx *ctx)\n{\n\tstruct qed_devlink *qed_dl = devlink_priv(dl);\n\tstruct qed_dev *cdev;\n\n\tcdev = qed_dl->cdev;\n\tcdev->iwarp_cmt = ctx->val.vbool;\n\n\treturn 0;\n}\n\nstatic const struct devlink_param qed_devlink_params[] = {\n\tDEVLINK_PARAM_DRIVER(QED_DEVLINK_PARAM_ID_IWARP_CMT,\n\t\t\t     \"iwarp_cmt\", DEVLINK_PARAM_TYPE_BOOL,\n\t\t\t     BIT(DEVLINK_PARAM_CMODE_RUNTIME),\n\t\t\t     qed_dl_param_get, qed_dl_param_set, NULL),\n};\n\nstatic int qed_devlink_info_get(struct devlink *devlink,\n\t\t\t\tstruct devlink_info_req *req,\n\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct qed_devlink *qed_dl = devlink_priv(devlink);\n\tstruct qed_dev *cdev = qed_dl->cdev;\n\tstruct qed_dev_info *dev_info;\n\tchar buf[100];\n\tint err;\n\n\tdev_info = &cdev->common_dev_info;\n\n\tmemcpy(buf, cdev->hwfns[0].hw_info.part_num, sizeof(cdev->hwfns[0].hw_info.part_num));\n\tbuf[sizeof(cdev->hwfns[0].hw_info.part_num)] = 0;\n\n\tif (buf[0]) {\n\t\terr = devlink_info_board_serial_number_put(req, buf);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tsnprintf(buf, sizeof(buf), \"%d.%d.%d.%d\",\n\t\t GET_MFW_FIELD(dev_info->mfw_rev, QED_MFW_VERSION_3),\n\t\t GET_MFW_FIELD(dev_info->mfw_rev, QED_MFW_VERSION_2),\n\t\t GET_MFW_FIELD(dev_info->mfw_rev, QED_MFW_VERSION_1),\n\t\t GET_MFW_FIELD(dev_info->mfw_rev, QED_MFW_VERSION_0));\n\n\terr = devlink_info_version_stored_put(req,\n\t\t\t\t\t      DEVLINK_INFO_VERSION_GENERIC_FW_MGMT, buf);\n\tif (err)\n\t\treturn err;\n\n\tsnprintf(buf, sizeof(buf), \"%d.%d.%d.%d\",\n\t\t dev_info->fw_major,\n\t\t dev_info->fw_minor,\n\t\t dev_info->fw_rev,\n\t\t dev_info->fw_eng);\n\n\treturn devlink_info_version_running_put(req,\n\t\t\t\t\t\tDEVLINK_INFO_VERSION_GENERIC_FW_APP, buf);\n}\n\nstatic const struct devlink_ops qed_dl_ops = {\n\t.info_get = qed_devlink_info_get,\n};\n\nstruct devlink *qed_devlink_register(struct qed_dev *cdev)\n{\n\tstruct qed_devlink *qdevlink;\n\tstruct devlink *dl;\n\tint rc;\n\n\tdl = devlink_alloc(&qed_dl_ops, sizeof(struct qed_devlink),\n\t\t\t   &cdev->pdev->dev);\n\tif (!dl)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tqdevlink = devlink_priv(dl);\n\tqdevlink->cdev = cdev;\n\n\trc = devlink_params_register(dl, qed_devlink_params,\n\t\t\t\t     ARRAY_SIZE(qed_devlink_params));\n\tif (rc)\n\t\tgoto err_unregister;\n\n\tcdev->iwarp_cmt = false;\n\n\tqed_fw_reporters_create(dl);\n\tdevlink_register(dl);\n\treturn dl;\n\nerr_unregister:\n\tdevlink_free(dl);\n\n\treturn ERR_PTR(rc);\n}\n\nvoid qed_devlink_unregister(struct devlink *devlink)\n{\n\tif (!devlink)\n\t\treturn;\n\n\tdevlink_unregister(devlink);\n\tqed_fw_reporters_destroy(devlink);\n\n\tdevlink_params_unregister(devlink, qed_devlink_params,\n\t\t\t\t  ARRAY_SIZE(qed_devlink_params));\n\n\tdevlink_free(devlink);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}