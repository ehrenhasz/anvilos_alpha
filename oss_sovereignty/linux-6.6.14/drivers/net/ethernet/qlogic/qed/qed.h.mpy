{
  "module_name": "qed.h",
  "hash_id": "5a9a3ba55d00f8f0a336f652f5e842d2d8b67060abea1dfd244c750987e359c5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/qlogic/qed/qed.h",
  "human_readable_source": " \n \n\n#ifndef _QED_H\n#define _QED_H\n\n#include <linux/types.h>\n#include <linux/io.h>\n#include <linux/delay.h>\n#include <linux/firmware.h>\n#include <linux/interrupt.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/pci.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/workqueue.h>\n#include <linux/zlib.h>\n#include <linux/hashtable.h>\n#include <linux/qed/qed_if.h>\n#include \"qed_debug.h\"\n#include \"qed_hsi.h\"\n#include \"qed_dbg_hsi.h\"\n#include \"qed_mfw_hsi.h\"\n\nextern const struct qed_common_ops qed_common_ops_pass;\n\n#define STORM_FW_VERSION\t\t\t\t       \\\n\t((FW_MAJOR_VERSION << 24) | (FW_MINOR_VERSION << 16) | \\\n\t (FW_REVISION_VERSION << 8) | FW_ENGINEERING_VERSION)\n\n#define MAX_HWFNS_PER_DEVICE    (4)\n#define NAME_SIZE 16\n#define VER_SIZE 16\n\n#define QED_WFQ_UNIT\t100\n\n#define QED_WID_SIZE            (1024)\n#define QED_MIN_WIDS\t\t(4)\n#define QED_PF_DEMS_SIZE        (4)\n\n#define QED_LLH_DONT_CARE 0\n\n \nenum qed_coalescing_mode {\n\tQED_COAL_MODE_DISABLE,\n\tQED_COAL_MODE_ENABLE\n};\n\nenum qed_nvm_cmd {\n\tQED_PUT_FILE_BEGIN = DRV_MSG_CODE_NVM_PUT_FILE_BEGIN,\n\tQED_PUT_FILE_DATA = DRV_MSG_CODE_NVM_PUT_FILE_DATA,\n\tQED_NVM_WRITE_NVRAM = DRV_MSG_CODE_NVM_WRITE_NVRAM,\n\tQED_GET_MCP_NVM_RESP = 0xFFFFFF00\n};\n\nstruct qed_eth_cb_ops;\nstruct qed_dev_info;\nunion qed_mcp_protocol_stats;\nenum qed_mcp_protocol_type;\nenum qed_mfw_tlv_type;\nunion qed_mfw_tlv_data;\n\n \n#define QED_MFW_GET_FIELD(name, field) \\\n\t(((name) & (field ## _MASK)) >> (field ## _SHIFT))\n\n#define QED_MFW_SET_FIELD(name, field, value)\t\t\t\t       \\\n\tdo {\t\t\t\t\t\t\t\t       \\\n\t\t(name)\t&= ~(field ## _MASK);\t       \\\n\t\t(name)\t|= (((value) << (field ## _SHIFT)) & (field ## _MASK));\\\n\t} while (0)\n\nstatic inline u32 qed_db_addr(u32 cid, u32 DEMS)\n{\n\tu32 db_addr = FIELD_VALUE(DB_LEGACY_ADDR_DEMS, DEMS) |\n\t\t      (cid * QED_PF_DEMS_SIZE);\n\n\treturn db_addr;\n}\n\nstatic inline u32 qed_db_addr_vf(u32 cid, u32 DEMS)\n{\n\tu32 db_addr = FIELD_VALUE(DB_LEGACY_ADDR_DEMS, DEMS) |\n\t\t      FIELD_VALUE(DB_LEGACY_ADDR_ICID, cid);\n\n\treturn db_addr;\n}\n\n#define ALIGNED_TYPE_SIZE(type_name, p_hwfn)\t\t\t\t     \\\n\t((sizeof(type_name) + (u32)(1 << ((p_hwfn)->cdev->cache_shift)) - 1) & \\\n\t ~((1 << (p_hwfn->cdev->cache_shift)) - 1))\n\n#define for_each_hwfn(cdev, i)  for (i = 0; i < (cdev)->num_hwfns; i++)\n\n#define D_TRINE(val, cond1, cond2, true1, true2, def) \\\n\t((val) == (cond1) ? true1 :\t\t      \\\n\t ((val) == (cond2) ? true2 : def))\n\n \nstruct qed_ptt_pool;\nstruct qed_spq;\nstruct qed_sb_info;\nstruct qed_sb_attn_info;\nstruct qed_cxt_mngr;\nstruct qed_sb_sp_info;\nstruct qed_ll2_info;\nstruct qed_mcp_info;\nstruct qed_llh_info;\n\nstruct qed_rt_data {\n\tu32\t*init_val;\n\tbool\t*b_valid;\n};\n\nenum qed_tunn_mode {\n\tQED_MODE_L2GENEVE_TUNN,\n\tQED_MODE_IPGENEVE_TUNN,\n\tQED_MODE_L2GRE_TUNN,\n\tQED_MODE_IPGRE_TUNN,\n\tQED_MODE_VXLAN_TUNN,\n};\n\nenum qed_tunn_clss {\n\tQED_TUNN_CLSS_MAC_VLAN,\n\tQED_TUNN_CLSS_MAC_VNI,\n\tQED_TUNN_CLSS_INNER_MAC_VLAN,\n\tQED_TUNN_CLSS_INNER_MAC_VNI,\n\tQED_TUNN_CLSS_MAC_VLAN_DUAL_STAGE,\n\tMAX_QED_TUNN_CLSS,\n};\n\nstruct qed_tunn_update_type {\n\tbool b_update_mode;\n\tbool b_mode_enabled;\n\tenum qed_tunn_clss tun_cls;\n};\n\nstruct qed_tunn_update_udp_port {\n\tbool b_update_port;\n\tu16 port;\n};\n\nstruct qed_tunnel_info {\n\tstruct qed_tunn_update_type vxlan;\n\tstruct qed_tunn_update_type l2_geneve;\n\tstruct qed_tunn_update_type ip_geneve;\n\tstruct qed_tunn_update_type l2_gre;\n\tstruct qed_tunn_update_type ip_gre;\n\n\tstruct qed_tunn_update_udp_port vxlan_port;\n\tstruct qed_tunn_update_udp_port geneve_port;\n\n\tbool b_update_rx_cls;\n\tbool b_update_tx_cls;\n};\n\nstruct qed_tunn_start_params {\n\tunsigned long\ttunn_mode;\n\tu16\t\tvxlan_udp_port;\n\tu16\t\tgeneve_udp_port;\n\tu8\t\tupdate_vxlan_udp_port;\n\tu8\t\tupdate_geneve_udp_port;\n\tu8\t\ttunn_clss_vxlan;\n\tu8\t\ttunn_clss_l2geneve;\n\tu8\t\ttunn_clss_ipgeneve;\n\tu8\t\ttunn_clss_l2gre;\n\tu8\t\ttunn_clss_ipgre;\n};\n\nstruct qed_tunn_update_params {\n\tunsigned long\ttunn_mode_update_mask;\n\tunsigned long\ttunn_mode;\n\tu16\t\tvxlan_udp_port;\n\tu16\t\tgeneve_udp_port;\n\tu8\t\tupdate_rx_pf_clss;\n\tu8\t\tupdate_tx_pf_clss;\n\tu8\t\tupdate_vxlan_udp_port;\n\tu8\t\tupdate_geneve_udp_port;\n\tu8\t\ttunn_clss_vxlan;\n\tu8\t\ttunn_clss_l2geneve;\n\tu8\t\ttunn_clss_ipgeneve;\n\tu8\t\ttunn_clss_l2gre;\n\tu8\t\ttunn_clss_ipgre;\n};\n\n \nenum qed_pci_personality {\n\tQED_PCI_ETH,\n\tQED_PCI_FCOE,\n\tQED_PCI_ISCSI,\n\tQED_PCI_NVMETCP,\n\tQED_PCI_ETH_ROCE,\n\tQED_PCI_ETH_IWARP,\n\tQED_PCI_ETH_RDMA,\n\tQED_PCI_DEFAULT,  \n};\n\n \nstruct qed_qm_iids {\n\tu32 cids;\n\tu32 vf_cids;\n\tu32 tids;\n};\n\n \nenum qed_resources {\n\tQED_SB,\n\tQED_L2_QUEUE,\n\tQED_VPORT,\n\tQED_RSS_ENG,\n\tQED_PQ,\n\tQED_RL,\n\tQED_MAC,\n\tQED_VLAN,\n\tQED_RDMA_CNQ_RAM,\n\tQED_ILT,\n\tQED_LL2_RAM_QUEUE,\n\tQED_LL2_CTX_QUEUE,\n\tQED_CMDQS_CQS,\n\tQED_RDMA_STATS_QUEUE,\n\tQED_BDQ,\n\tQED_MAX_RESC,\n};\n\nenum QED_FEATURE {\n\tQED_PF_L2_QUE,\n\tQED_VF,\n\tQED_RDMA_CNQ,\n\tQED_NVMETCP_CQ,\n\tQED_ISCSI_CQ,\n\tQED_FCOE_CQ,\n\tQED_VF_L2_QUE,\n\tQED_MAX_FEATURES,\n};\n\nenum qed_dev_cap {\n\tQED_DEV_CAP_ETH,\n\tQED_DEV_CAP_FCOE,\n\tQED_DEV_CAP_ISCSI,\n\tQED_DEV_CAP_ROCE,\n\tQED_DEV_CAP_IWARP,\n};\n\nenum qed_wol_support {\n\tQED_WOL_SUPPORT_NONE,\n\tQED_WOL_SUPPORT_PME,\n};\n\nenum qed_db_rec_exec {\n\tDB_REC_DRY_RUN,\n\tDB_REC_REAL_DEAL,\n\tDB_REC_ONCE,\n};\n\nstruct qed_hw_info {\n\t \n\tenum qed_pci_personality\tpersonality;\n#define QED_IS_RDMA_PERSONALITY(dev)\t\t\t\t\t\\\n\t((dev)->hw_info.personality == QED_PCI_ETH_ROCE ||\t\t\\\n\t (dev)->hw_info.personality == QED_PCI_ETH_IWARP ||\t\t\\\n\t (dev)->hw_info.personality == QED_PCI_ETH_RDMA)\n#define QED_IS_ROCE_PERSONALITY(dev)\t\t\t\t\t\\\n\t((dev)->hw_info.personality == QED_PCI_ETH_ROCE ||\t\t\\\n\t (dev)->hw_info.personality == QED_PCI_ETH_RDMA)\n#define QED_IS_IWARP_PERSONALITY(dev)\t\t\t\t\t\\\n\t((dev)->hw_info.personality == QED_PCI_ETH_IWARP ||\t\t\\\n\t (dev)->hw_info.personality == QED_PCI_ETH_RDMA)\n#define QED_IS_L2_PERSONALITY(dev)\t\t\t\t\t\\\n\t((dev)->hw_info.personality == QED_PCI_ETH ||\t\t\t\\\n\t QED_IS_RDMA_PERSONALITY(dev))\n#define QED_IS_FCOE_PERSONALITY(dev)\t\t\t\t\t\\\n\t((dev)->hw_info.personality == QED_PCI_FCOE)\n#define QED_IS_ISCSI_PERSONALITY(dev)\t\t\t\t\t\\\n\t((dev)->hw_info.personality == QED_PCI_ISCSI)\n#define QED_IS_NVMETCP_PERSONALITY(dev)\t\t\t\t\t\\\n\t((dev)->hw_info.personality == QED_PCI_NVMETCP)\n\n\t \n\tu32\t\t\t\tresc_start[QED_MAX_RESC];\n\tu32\t\t\t\tresc_num[QED_MAX_RESC];\n#define RESC_START(_p_hwfn, resc)\t((_p_hwfn)->hw_info.resc_start[resc])\n#define RESC_NUM(_p_hwfn, resc)\t\t((_p_hwfn)->hw_info.resc_num[resc])\n#define RESC_END(_p_hwfn, resc)\t\t(RESC_START(_p_hwfn, resc) +\t\\\n\t\t\t\t\t RESC_NUM(_p_hwfn, resc))\n\n\tu32\t\t\t\tfeat_num[QED_MAX_FEATURES];\n#define FEAT_NUM(_p_hwfn, resc)\t\t((_p_hwfn)->hw_info.feat_num[resc])\n\n\t \n\tu8\t\t\t\tnum_hw_tc;\n\n\t \n\tu8\t\t\t\tnum_active_tc;\n\n\tu8\t\t\t\toffload_tc;\n\tbool\t\t\t\toffload_tc_set;\n\n\tbool\t\t\t\tmulti_tc_roce_en;\n#define IS_QED_MULTI_TC_ROCE(p_hwfn)\t((p_hwfn)->hw_info.multi_tc_roce_en)\n\n\tu32\t\t\t\tconcrete_fid;\n\tu16\t\t\t\topaque_fid;\n\tu16\t\t\t\tovlan;\n\tu32\t\t\t\tpart_num[4];\n\n\tunsigned char\t\t\thw_mac_addr[ETH_ALEN];\n\tu64\t\t\t\tnode_wwn;\n\tu64\t\t\t\tport_wwn;\n\n\tu16\t\t\t\tnum_fcoe_conns;\n\n\tstruct qed_igu_info\t\t*p_igu_info;\n\n\tu32\t\t\t\thw_mode;\n\tunsigned long\t\t\tdevice_capabilities;\n\tu16\t\t\t\tmtu;\n\n\tenum qed_wol_support\t\tb_wol_support;\n};\n\n \n#define DMAE_MAX_RW_SIZE        0x2000\n\nstruct qed_dmae_info {\n\t \n\tstruct mutex\tmutex;\n\n\tu8\t\tchannel;\n\n\tdma_addr_t\tcompletion_word_phys_addr;\n\n\t \n\tu32\t\t*p_completion_word;\n\n\tdma_addr_t\tintermediate_buffer_phys_addr;\n\n\t \n\tu32\t\t*p_intermediate_buffer;\n\n\tdma_addr_t\tdmae_cmd_phys_addr;\n\tstruct dmae_cmd *p_dmae_cmd;\n};\n\nstruct qed_wfq_data {\n\t \n\tu32\tmin_speed;\n\tbool\tconfigured;\n};\n\nstruct qed_qm_info {\n\tstruct init_qm_pq_params\t*qm_pq_params;\n\tstruct init_qm_vport_params\t*qm_vport_params;\n\tstruct init_qm_port_params\t*qm_port_params;\n\tu16\t\t\t\tstart_pq;\n\tu8\t\t\t\tstart_vport;\n\tu16\t\t\t\t pure_lb_pq;\n\tu16\t\t\t\tfirst_ofld_pq;\n\tu16\t\t\t\tfirst_llt_pq;\n\tu16\t\t\t\tpure_ack_pq;\n\tu16\t\t\t\tooo_pq;\n\tu16\t\t\t\tfirst_vf_pq;\n\tu16\t\t\t\tfirst_mcos_pq;\n\tu16\t\t\t\tfirst_rl_pq;\n\tu16\t\t\t\tnum_pqs;\n\tu16\t\t\t\tnum_vf_pqs;\n\tu8\t\t\t\tnum_vports;\n\tu8\t\t\t\tmax_phys_tcs_per_port;\n\tu8\t\t\t\tooo_tc;\n\tbool\t\t\t\tpf_rl_en;\n\tbool\t\t\t\tpf_wfq_en;\n\tbool\t\t\t\tvport_rl_en;\n\tbool\t\t\t\tvport_wfq_en;\n\tu8\t\t\t\tpf_wfq;\n\tu32\t\t\t\tpf_rl;\n\tstruct qed_wfq_data\t\t*wfq_data;\n\tu8 num_pf_rls;\n};\n\n#define QED_OVERFLOW_BIT\t1\n\nstruct qed_db_recovery_info {\n\tstruct list_head list;\n\n\t \n\tspinlock_t lock;\n\tbool dorq_attn;\n\tu32 db_recovery_counter;\n\tunsigned long overflow;\n};\n\nstruct storm_stats {\n\tu32     address;\n\tu32     len;\n};\n\nstruct qed_storm_stats {\n\tstruct storm_stats mstats;\n\tstruct storm_stats pstats;\n\tstruct storm_stats tstats;\n\tstruct storm_stats ustats;\n};\n\nstruct qed_fw_data {\n\tstruct fw_ver_info\t*fw_ver_info;\n\tconst u8\t\t*modes_tree_buf;\n\tunion init_op\t\t*init_ops;\n\tconst u32\t\t*arr_data;\n\tconst u32\t\t*fw_overlays;\n\tu32\t\t\tfw_overlays_len;\n\tu32\t\t\tinit_ops_size;\n};\n\nenum qed_mf_mode_bit {\n\t \n\tQED_MF_OVLAN_CLSS,\n\n\t \n\tQED_MF_LLH_MAC_CLSS,\n\n\t \n\tQED_MF_LLH_PROTO_CLSS,\n\n\t \n\tQED_MF_NEED_DEF_PF,\n\n\t \n\tQED_MF_LL2_NON_UNICAST,\n\n\t \n\tQED_MF_INTER_PF_SWITCH,\n\n\t \n\tQED_MF_UFP_SPECIFIC,\n\n\t \n\tQED_MF_DISABLE_ARFS,\n\n\t \n\tQED_MF_8021Q_TAGGING,\n\n\t \n\tQED_MF_8021AD_TAGGING,\n\n\t \n\tQED_MF_DSCP_TO_TC_MAP,\n\n\t \n\tQED_MF_DONT_ADD_VLAN0_TAG,\n};\n\nenum qed_ufp_mode {\n\tQED_UFP_MODE_ETS,\n\tQED_UFP_MODE_VNIC_BW,\n\tQED_UFP_MODE_UNKNOWN\n};\n\nenum qed_ufp_pri_type {\n\tQED_UFP_PRI_OS,\n\tQED_UFP_PRI_VNIC,\n\tQED_UFP_PRI_UNKNOWN\n};\n\nstruct qed_ufp_info {\n\tenum qed_ufp_pri_type pri_type;\n\tenum qed_ufp_mode mode;\n\tu8 tc;\n};\n\nenum BAR_ID {\n\tBAR_ID_0,\t\t \n\tBAR_ID_1\t\t \n};\n\nstruct qed_nvm_image_info {\n\tu32 num_images;\n\tstruct bist_nvm_image_att *image_att;\n\tbool valid;\n};\n\nenum qed_hsi_def_type {\n\tQED_HSI_DEF_MAX_NUM_VFS,\n\tQED_HSI_DEF_MAX_NUM_L2_QUEUES,\n\tQED_HSI_DEF_MAX_NUM_PORTS,\n\tQED_HSI_DEF_MAX_SB_PER_PATH,\n\tQED_HSI_DEF_MAX_NUM_PFS,\n\tQED_HSI_DEF_MAX_NUM_VPORTS,\n\tQED_HSI_DEF_NUM_ETH_RSS_ENGINE,\n\tQED_HSI_DEF_MAX_QM_TX_QUEUES,\n\tQED_HSI_DEF_NUM_PXP_ILT_RECORDS,\n\tQED_HSI_DEF_NUM_RDMA_STATISTIC_COUNTERS,\n\tQED_HSI_DEF_MAX_QM_GLOBAL_RLS,\n\tQED_HSI_DEF_MAX_PBF_CMD_LINES,\n\tQED_HSI_DEF_MAX_BTB_BLOCKS,\n\tQED_NUM_HSI_DEFS\n};\n\nstruct qed_simd_fp_handler {\n\tvoid\t*token;\n\tvoid\t(*func)(void *cookie);\n};\n\nenum qed_slowpath_wq_flag {\n\tQED_SLOWPATH_MFW_TLV_REQ,\n\tQED_SLOWPATH_PERIODIC_DB_REC,\n};\n\nstruct qed_hwfn {\n\tstruct qed_dev\t\t\t*cdev;\n\tu8\t\t\t\tmy_id;           \n#define IS_LEAD_HWFN(edev)              (!((edev)->my_id))\n\tu8\t\t\t\trel_pf_id;       \n\tu8\t\t\t\tabs_pf_id;\n#define QED_PATH_ID(_p_hwfn) \\\n\t(QED_IS_K2((_p_hwfn)->cdev) ? 0 : ((_p_hwfn)->abs_pf_id & 1))\n\tu8\t\t\t\tport_id;\n\tbool\t\t\t\tb_active;\n\n\tu32\t\t\t\tdp_module;\n\tu8\t\t\t\tdp_level;\n\tchar\t\t\t\tname[NAME_SIZE];\n\n\tbool\t\t\t\thw_init_done;\n\n\tu8\t\t\t\tnum_funcs_on_engine;\n\tu8 enabled_func_idx;\n\n\t \n\tvoid __iomem\t\t\t*regview;\n\tvoid __iomem\t\t\t*doorbells;\n\tu64\t\t\t\tdb_phys_addr;\n\tunsigned long\t\t\tdb_size;\n\n\t \n\tstruct qed_ptt_pool\t\t*p_ptt_pool;\n\n\t \n\tstruct qed_hw_info\t\thw_info;\n\n\t \n\tstruct qed_rt_data\t\trt_data;\n\n\t \n\tstruct qed_spq\t\t\t*p_spq;\n\n\t \n\tstruct qed_eq\t\t\t*p_eq;\n\n\t \n\tstruct qed_consq\t\t*p_consq;\n\n\t \n\tstruct tasklet_struct\t\tsp_dpc;\n\tbool\t\t\t\tb_sp_dpc_enabled;\n\n\tstruct qed_ptt\t\t\t*p_main_ptt;\n\tstruct qed_ptt\t\t\t*p_dpc_ptt;\n\n\t \n\tstruct qed_ptt *p_ptp_ptt;\n\n\tstruct qed_sb_sp_info\t\t*p_sp_sb;\n\tstruct qed_sb_attn_info\t\t*p_sb_attn;\n\n\t \n\tbool\t\t\t\tusing_ll2;\n\tstruct qed_ll2_info\t\t*p_ll2_info;\n\tstruct qed_ooo_info\t\t*p_ooo_info;\n\tstruct qed_rdma_info\t\t*p_rdma_info;\n\tstruct qed_iscsi_info\t\t*p_iscsi_info;\n\tstruct qed_nvmetcp_info\t\t*p_nvmetcp_info;\n\tstruct qed_fcoe_info\t\t*p_fcoe_info;\n\tstruct qed_pf_params\t\tpf_params;\n\n\tbool b_rdma_enabled_in_prs;\n\tu32 rdma_prs_search_reg;\n\n\tstruct qed_cxt_mngr\t\t*p_cxt_mngr;\n\n\t \n\tbool\t\t\t\tb_int_enabled;\n\tbool\t\t\t\tb_int_requested;\n\n\t \n\tbool\t\t\t\tb_drv_link_init;\n\n\tstruct qed_vf_iov\t\t*vf_iov_info;\n\tstruct qed_pf_iov\t\t*pf_iov_info;\n\tstruct qed_mcp_info\t\t*mcp_info;\n\n\tstruct qed_dcbx_info\t\t*p_dcbx_info;\n\n\tstruct qed_ufp_info\t\tufp_info;\n\n\tstruct qed_dmae_info\t\tdmae_info;\n\n\t \n\tstruct qed_qm_info\t\tqm_info;\n\tstruct qed_storm_stats\t\tstorm_stats;\n\n\t \n\tvoid\t\t\t\t*unzip_buf;\n\n\tstruct dbg_tools_data\t\tdbg_info;\n\tvoid\t\t\t\t*dbg_user_info;\n\tstruct virt_mem_desc\t\tdbg_arrays[MAX_BIN_DBG_BUFFER_TYPE];\n\n\t \n\tu16\t\t\t\twid_count;\n\tu32\t\t\t\tdpi_size;\n\tu32\t\t\t\tdpi_count;\n\n\t \n\tu32 dpi_start_offset;\n\n\t \n\tu8 dcbx_no_edpm;\n\tu8 db_bar_no_edpm;\n\n\t \n\tstruct qed_l2_info *p_l2_info;\n\n\t \n\tstruct qed_db_recovery_info db_recovery_info;\n\n\t \n\tstruct qed_nvm_image_info nvm_info;\n\n\tstruct phys_mem_desc *fw_overlay_mem;\n\tstruct qed_ptt *p_arfs_ptt;\n\n\tstruct qed_simd_fp_handler\tsimd_proto_handler[64];\n\n#ifdef CONFIG_QED_SRIOV\n\tstruct workqueue_struct *iov_wq;\n\tstruct delayed_work iov_task;\n\tunsigned long iov_task_flags;\n#endif\n\tstruct z_stream_s *stream;\n\tbool slowpath_wq_active;\n\tstruct workqueue_struct *slowpath_wq;\n\tstruct delayed_work slowpath_task;\n\tunsigned long slowpath_task_flags;\n\tu32 periodic_db_rec_count;\n};\n\nstruct pci_params {\n\tint\t\tpm_cap;\n\n\tunsigned long\tmem_start;\n\tunsigned long\tmem_end;\n\tunsigned int\tirq;\n\tu8\t\tpf_num;\n};\n\nstruct qed_int_param {\n\tu32\tint_mode;\n\tu8\tnum_vectors;\n\tu8\tmin_msix_cnt;  \n};\n\nstruct qed_int_params {\n\tstruct qed_int_param\tin;\n\tstruct qed_int_param\tout;\n\tstruct msix_entry\t*msix_table;\n\tbool\t\t\tfp_initialized;\n\tu8\t\t\tfp_msix_base;\n\tu8\t\t\tfp_msix_cnt;\n\tu8\t\t\trdma_msix_base;\n\tu8\t\t\trdma_msix_cnt;\n};\n\nstruct qed_dbg_feature {\n\tstruct dentry *dentry;\n\tu8 *dump_buf;\n\tu32 buf_size;\n\tu32 dumped_dwords;\n};\n\nstruct qed_dev {\n\tu32\t\t\t\tdp_module;\n\tu8\t\t\t\tdp_level;\n\tchar\t\t\t\tname[NAME_SIZE];\n\n\tenum qed_dev_type\t\ttype;\n\t \n#define QED_IS_BB(dev)\t\t\t((dev)->type == QED_DEV_TYPE_BB)\n#define QED_IS_BB_B0(dev)\t\t(QED_IS_BB(dev) && CHIP_REV_IS_B0(dev))\n#define QED_IS_AH(dev)\t\t\t((dev)->type == QED_DEV_TYPE_AH)\n#define QED_IS_K2(dev)\t\t\tQED_IS_AH(dev)\n\n\tu16\t\t\t\tvendor_id;\n\n\tu16\t\t\t\tdevice_id;\n#define QED_DEV_ID_MASK\t\t\t0xff00\n#define QED_DEV_ID_MASK_BB\t\t0x1600\n#define QED_DEV_ID_MASK_AH\t\t0x8000\n\n\tu16\t\t\t\tchip_num;\n#define CHIP_NUM_MASK\t\t\t0xffff\n#define CHIP_NUM_SHIFT\t\t\t16\n\n\tu16\t\t\t\tchip_rev;\n#define CHIP_REV_MASK\t\t\t0xf\n#define CHIP_REV_SHIFT\t\t\t12\n#define CHIP_REV_IS_B0(_cdev)\t\t((_cdev)->chip_rev == 1)\n\n\tu16\t\t\t\tchip_metal;\n#define CHIP_METAL_MASK\t\t\t0xff\n#define CHIP_METAL_SHIFT\t\t4\n\n\tu16\t\t\t\tchip_bond_id;\n#define CHIP_BOND_ID_MASK\t\t0xf\n#define CHIP_BOND_ID_SHIFT\t\t0\n\n\tu8\t\t\t\tnum_engines;\n\tu8\t\t\t\tnum_ports;\n\tu8\t\t\t\tnum_ports_in_engine;\n\tu8\t\t\t\tnum_funcs_in_port;\n\n\tu8\t\t\t\tpath_id;\n\n\tunsigned long\t\t\tmf_bits;\n\n\tint\t\t\t\tpcie_width;\n\tint\t\t\t\tpcie_speed;\n\n\t \n\tu8\t\t\t\tmcp_rev;\n\tu8\t\t\t\tboot_mode;\n\n\t \n\tu8 wol_config;\n\tu8 wol_mac[ETH_ALEN];\n\n\tu32\t\t\t\tint_mode;\n\tenum qed_coalescing_mode\tint_coalescing_mode;\n\tu16\t\t\t\trx_coalesce_usecs;\n\tu16\t\t\t\ttx_coalesce_usecs;\n\n\t \n\tvoid __iomem\t\t\t*regview;\n\tvoid __iomem\t\t\t*doorbells;\n\tu64\t\t\t\tdb_phys_addr;\n\tunsigned long\t\t\tdb_size;\n\n\t \n\tu8\t\t\t\tcache_shift;\n\n\t \n\tconst u32 *iro_arr;\n#define IRO ((const struct iro *)p_hwfn->cdev->iro_arr)\n\n\t \n\tu8\t\t\t\tnum_hwfns;\n\tstruct qed_hwfn\t\t\thwfns[MAX_HWFNS_PER_DEVICE];\n\n\t \n\tu8\t\t\t\tl2_affin_hint;\n\tu8\t\t\t\tfir_affin;\n\tu8\t\t\t\tiwarp_affin;\n\n\t \n\tstruct qed_hw_sriov_info *p_iov_info;\n#define IS_QED_SRIOV(cdev)              (!!(cdev)->p_iov_info)\n\tstruct qed_tunnel_info\t\ttunnel;\n\tbool\t\t\t\tb_is_vf;\n\tu32\t\t\t\tdrv_type;\n\tstruct qed_eth_stats\t\t*reset_stats;\n\tstruct qed_fw_data\t\t*fw_data;\n\n\tu32\t\t\t\tmcp_nvm_resp;\n\n\t \n\tbool recov_in_prog;\n\n\t \n\tbool attn_clr_en;\n\n\t \n\tu8 ppfid_bitmap;\n\tstruct qed_llh_info *p_llh_info;\n\n\t \n\tstruct qed_dev_info\t\tcommon_dev_info;\n\tstruct  qede_dev\t\t*edev;\n\tstruct  pci_dev\t\t\t*pdev;\n\tu32 flags;\n#define QED_FLAG_STORAGE_STARTED\t(BIT(0))\n\tint\t\t\t\tmsg_enable;\n\n\tstruct pci_params\t\tpci_params;\n\n\tstruct qed_int_params\t\tint_params;\n\n\tu8\t\t\t\tprotocol;\n#define IS_QED_ETH_IF(cdev)     ((cdev)->protocol == QED_PROTOCOL_ETH)\n#define IS_QED_FCOE_IF(cdev)    ((cdev)->protocol == QED_PROTOCOL_FCOE)\n\n\t \n\tunion {\n\t\tstruct qed_common_cb_ops\t*common;\n\t\tstruct qed_eth_cb_ops\t\t*eth;\n\t\tstruct qed_fcoe_cb_ops\t\t*fcoe;\n\t\tstruct qed_iscsi_cb_ops\t\t*iscsi;\n\t\tstruct qed_nvmetcp_cb_ops\t*nvmetcp;\n\t} protocol_ops;\n\tvoid\t\t\t\t*ops_cookie;\n\n#ifdef CONFIG_QED_LL2\n\tstruct qed_cb_ll2_info\t\t*ll2;\n\tu8\t\t\t\tll2_mac_address[ETH_ALEN];\n#endif\n\tstruct qed_dbg_feature dbg_features[DBG_FEATURE_NUM];\n\tu8 engine_for_debug;\n\tbool disable_ilt_dump;\n\tbool\t\t\t\tdbg_bin_dump;\n\n\tDECLARE_HASHTABLE(connections, 10);\n\tconst struct firmware\t\t*firmware;\n\n\tbool print_dbg_data;\n\n\tu32 rdma_max_sge;\n\tu32 rdma_max_inline;\n\tu32 rdma_max_srq_sge;\n\tu16 tunn_feature_mask;\n\n\tbool\t\t\t\tiwarp_cmt;\n};\n\nu32 qed_get_hsi_def_val(struct qed_dev *cdev, enum qed_hsi_def_type type);\n\n#define NUM_OF_VFS(dev)\t\\\n\tqed_get_hsi_def_val(dev, QED_HSI_DEF_MAX_NUM_VFS)\n#define NUM_OF_L2_QUEUES(dev) \\\n\tqed_get_hsi_def_val(dev, QED_HSI_DEF_MAX_NUM_L2_QUEUES)\n#define NUM_OF_PORTS(dev) \\\n\tqed_get_hsi_def_val(dev, QED_HSI_DEF_MAX_NUM_PORTS)\n#define NUM_OF_SBS(dev)\t\\\n\tqed_get_hsi_def_val(dev, QED_HSI_DEF_MAX_SB_PER_PATH)\n#define NUM_OF_ENG_PFS(dev) \\\n\tqed_get_hsi_def_val(dev, QED_HSI_DEF_MAX_NUM_PFS)\n#define NUM_OF_VPORTS(dev) \\\n\tqed_get_hsi_def_val(dev, QED_HSI_DEF_MAX_NUM_VPORTS)\n#define NUM_OF_RSS_ENGINES(dev)\t\\\n\tqed_get_hsi_def_val(dev, QED_HSI_DEF_NUM_ETH_RSS_ENGINE)\n#define NUM_OF_QM_TX_QUEUES(dev) \\\n\tqed_get_hsi_def_val(dev, QED_HSI_DEF_MAX_QM_TX_QUEUES)\n#define NUM_OF_PXP_ILT_RECORDS(dev) \\\n\tqed_get_hsi_def_val(dev, QED_HSI_DEF_NUM_PXP_ILT_RECORDS)\n#define NUM_OF_RDMA_STATISTIC_COUNTERS(dev) \\\n\tqed_get_hsi_def_val(dev, QED_HSI_DEF_NUM_RDMA_STATISTIC_COUNTERS)\n#define NUM_OF_QM_GLOBAL_RLS(dev) \\\n\tqed_get_hsi_def_val(dev, QED_HSI_DEF_MAX_QM_GLOBAL_RLS)\n#define NUM_OF_PBF_CMD_LINES(dev) \\\n\tqed_get_hsi_def_val(dev, QED_HSI_DEF_MAX_PBF_CMD_LINES)\n#define NUM_OF_BTB_BLOCKS(dev) \\\n\tqed_get_hsi_def_val(dev, QED_HSI_DEF_MAX_BTB_BLOCKS)\n\n \nstatic inline u8 qed_concrete_to_sw_fid(struct qed_dev *cdev,\n\t\t\t\t\tu32 concrete_fid)\n{\n\tu8 vfid = GET_FIELD(concrete_fid, PXP_CONCRETE_FID_VFID);\n\tu8 pfid = GET_FIELD(concrete_fid, PXP_CONCRETE_FID_PFID);\n\tu8 vf_valid = GET_FIELD(concrete_fid,\n\t\t\t\tPXP_CONCRETE_FID_VFVALID);\n\tu8 sw_fid;\n\n\tif (vf_valid)\n\t\tsw_fid = vfid + MAX_NUM_PFS;\n\telse\n\t\tsw_fid = pfid;\n\n\treturn sw_fid;\n}\n\n#define PKT_LB_TC\t9\n\nint qed_configure_vport_wfq(struct qed_dev *cdev, u16 vp_id, u32 rate);\nvoid qed_configure_vp_wfq_on_link_change(struct qed_dev *cdev,\n\t\t\t\t\t struct qed_ptt *p_ptt,\n\t\t\t\t\t u32 min_pf_rate);\n\nvoid qed_clean_wfq_db(struct qed_hwfn *p_hwfn, struct qed_ptt *p_ptt);\nvoid qed_set_fw_mac_addr(__le16 *fw_msb,\n\t\t\t __le16 *fw_mid, __le16 *fw_lsb, u8 *mac);\n\n#define QED_LEADING_HWFN(dev)   (&(dev)->hwfns[0])\n#define QED_IS_CMT(dev)\t\t((dev)->num_hwfns > 1)\n \n#define QED_FIR_AFFIN_HWFN(dev)\t\t(&(dev)->hwfns[dev->fir_affin])\n#define QED_IWARP_AFFIN_HWFN(dev)       (&(dev)->hwfns[dev->iwarp_affin])\n#define QED_AFFIN_HWFN(dev)\t\t\t\t   \\\n\t(QED_IS_IWARP_PERSONALITY(QED_LEADING_HWFN(dev)) ? \\\n\t QED_IWARP_AFFIN_HWFN(dev) : QED_FIR_AFFIN_HWFN(dev))\n#define QED_AFFIN_HWFN_IDX(dev) (IS_LEAD_HWFN(QED_AFFIN_HWFN(dev)) ? 0 : 1)\n\n \n#define PQ_FLAGS_RLS    (BIT(0))\n#define PQ_FLAGS_MCOS   (BIT(1))\n#define PQ_FLAGS_LB     (BIT(2))\n#define PQ_FLAGS_OOO    (BIT(3))\n#define PQ_FLAGS_ACK    (BIT(4))\n#define PQ_FLAGS_OFLD   (BIT(5))\n#define PQ_FLAGS_VFS    (BIT(6))\n#define PQ_FLAGS_LLT    (BIT(7))\n#define PQ_FLAGS_MTC    (BIT(8))\n\n \nu16 qed_get_cm_pq_idx(struct qed_hwfn *p_hwfn, u32 pq_flags);\nu16 qed_get_cm_pq_idx_mcos(struct qed_hwfn *p_hwfn, u8 tc);\nu16 qed_get_cm_pq_idx_vf(struct qed_hwfn *p_hwfn, u16 vf);\nu16 qed_get_cm_pq_idx_ofld_mtc(struct qed_hwfn *p_hwfn, u8 tc);\nu16 qed_get_cm_pq_idx_llt_mtc(struct qed_hwfn *p_hwfn, u8 tc);\n\n \nvoid qed_db_recovery_dp(struct qed_hwfn *p_hwfn);\nvoid qed_db_recovery_execute(struct qed_hwfn *p_hwfn);\nbool qed_edpm_enabled(struct qed_hwfn *p_hwfn);\n\n#define GET_GTT_REG_ADDR(__base, __offset, __idx) \\\n\t((__base) + __offset ## _GTT_OFFSET((__idx)))\n\n#define GET_GTT_BDQ_REG_ADDR(__base, __offset, __idx, __bdq_idx) \\\n\t((__base) + __offset ## _GTT_OFFSET((__idx), (__bdq_idx)))\n\n \n#define DP_NAME(cdev) ((cdev)->name)\n\n#define REG_ADDR(cdev, offset)          ((void __iomem *)((u8 __iomem *)\\\n\t\t\t\t\t\t((cdev)->regview) + \\\n\t\t\t\t\t\t\t (offset)))\n\n#define REG_RD(cdev, offset)            readl(REG_ADDR(cdev, offset))\n#define REG_WR(cdev, offset, val)       writel((u32)val, REG_ADDR(cdev, offset))\n#define REG_WR16(cdev, offset, val)     writew((u16)val, REG_ADDR(cdev, offset))\n\n#define DOORBELL(cdev, db_addr, val)\t\t\t \\\n\twritel((u32)val, (void __iomem *)((u8 __iomem *)\\\n\t\t\t\t\t  ((cdev)->doorbells) + (db_addr)))\n\n#define MFW_PORT(_p_hwfn)       ((_p_hwfn)->abs_pf_id %\t\t\t  \\\n\t\t\t\t  qed_device_num_ports((_p_hwfn)->cdev))\nint qed_device_num_ports(struct qed_dev *cdev);\n\n \nint qed_fill_dev_info(struct qed_dev *cdev,\n\t\t      struct qed_dev_info *dev_info);\nvoid qed_link_update(struct qed_hwfn *hwfn, struct qed_ptt *ptt);\nvoid qed_bw_update(struct qed_hwfn *hwfn, struct qed_ptt *ptt);\nu32 qed_unzip_data(struct qed_hwfn *p_hwfn,\n\t\t   u32 input_len, u8 *input_buf,\n\t\t   u32 max_size, u8 *unzip_buf);\nint qed_recovery_process(struct qed_dev *cdev);\nvoid qed_schedule_recovery_handler(struct qed_hwfn *p_hwfn);\nvoid qed_hw_error_occurred(struct qed_hwfn *p_hwfn,\n\t\t\t   enum qed_hw_err_type err_type);\nvoid qed_get_protocol_stats(struct qed_dev *cdev,\n\t\t\t    enum qed_mcp_protocol_type type,\n\t\t\t    union qed_mcp_protocol_stats *stats);\nint qed_slowpath_irq_req(struct qed_hwfn *hwfn);\nvoid qed_slowpath_irq_sync(struct qed_hwfn *p_hwfn);\nint qed_mfw_tlv_req(struct qed_hwfn *hwfn);\n\nint qed_mfw_fill_tlv_data(struct qed_hwfn *hwfn,\n\t\t\t  enum qed_mfw_tlv_type type,\n\t\t\t  union qed_mfw_tlv_data *tlv_data);\n\nvoid qed_hw_info_set_offload_tc(struct qed_hw_info *p_info, u8 tc);\n\nvoid qed_periodic_db_rec_start(struct qed_hwfn *p_hwfn);\n\nint qed_llh_add_src_tcp_port_filter(struct qed_dev *cdev, u16 src_port);\nint qed_llh_add_dst_tcp_port_filter(struct qed_dev *cdev, u16 dest_port);\nvoid qed_llh_remove_src_tcp_port_filter(struct qed_dev *cdev, u16 src_port);\nvoid qed_llh_remove_dst_tcp_port_filter(struct qed_dev *cdev, u16 src_port);\nvoid qed_llh_clear_all_filters(struct qed_dev *cdev);\nunsigned long qed_get_epoch_time(void);\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}