{
  "module_name": "qed_ll2.c",
  "hash_id": "8dc59bf02366e6535bde65f3c94135677b4459c20f6e29ab98c8eed7506fb546",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/qlogic/qed/qed_ll2.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <asm/byteorder.h>\n#include <linux/dma-mapping.h>\n#include <linux/if_vlan.h>\n#include <linux/kernel.h>\n#include <linux/pci.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/workqueue.h>\n#include <net/ipv6.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/errno.h>\n#include <linux/etherdevice.h>\n#include <linux/io.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/qed/qed_ll2_if.h>\n#include \"qed.h\"\n#include \"qed_cxt.h\"\n#include \"qed_dev_api.h\"\n#include \"qed_hsi.h\"\n#include \"qed_iro_hsi.h\"\n#include \"qed_hw.h\"\n#include \"qed_int.h\"\n#include \"qed_ll2.h\"\n#include \"qed_mcp.h\"\n#include \"qed_ooo.h\"\n#include \"qed_reg_addr.h\"\n#include \"qed_sp.h\"\n#include \"qed_rdma.h\"\n\n#define QED_LL2_RX_REGISTERED(ll2)\t((ll2)->rx_queue.b_cb_registered)\n#define QED_LL2_TX_REGISTERED(ll2)\t((ll2)->tx_queue.b_cb_registered)\n\n#define QED_LL2_TX_SIZE (256)\n#define QED_LL2_RX_SIZE (4096)\n\n#define QED_LL2_INVALID_STATS_ID        0xff\n\nstruct qed_cb_ll2_info {\n\tint rx_cnt;\n\tu32 rx_size;\n\tu8 handle;\n\n\t \n\tspinlock_t lock;\n\tstruct list_head list;\n\n\tconst struct qed_ll2_cb_ops *cbs;\n\tvoid *cb_cookie;\n};\n\nstruct qed_ll2_buffer {\n\tstruct list_head list;\n\tvoid *data;\n\tdma_addr_t phys_addr;\n};\n\nstatic u8 qed_ll2_handle_to_stats_id(struct qed_hwfn *p_hwfn,\n\t\t\t\t     u8 ll2_queue_type, u8 qid)\n{\n\tu8 stats_id;\n\n\t \n\tif (ll2_queue_type == QED_LL2_RX_TYPE_LEGACY)\n\t\tstats_id = qid;\n\telse\n\t\tstats_id = MAX_NUM_LL2_RX_RAM_QUEUES + p_hwfn->abs_pf_id;\n\n\tif (stats_id < MAX_NUM_LL2_TX_STATS_COUNTERS)\n\t\treturn stats_id;\n\telse\n\t\treturn QED_LL2_INVALID_STATS_ID;\n}\n\nstatic void qed_ll2b_complete_tx_packet(void *cxt,\n\t\t\t\t\tu8 connection_handle,\n\t\t\t\t\tvoid *cookie,\n\t\t\t\t\tdma_addr_t first_frag_addr,\n\t\t\t\t\tbool b_last_fragment,\n\t\t\t\t\tbool b_last_packet)\n{\n\tstruct qed_hwfn *p_hwfn = cxt;\n\tstruct qed_dev *cdev = p_hwfn->cdev;\n\tstruct sk_buff *skb = cookie;\n\n\t \n\tdma_unmap_single(&p_hwfn->cdev->pdev->dev, first_frag_addr,\n\t\t\t skb_headlen(skb), DMA_TO_DEVICE);\n\n\tif (cdev->ll2->cbs && cdev->ll2->cbs->tx_cb)\n\t\tcdev->ll2->cbs->tx_cb(cdev->ll2->cb_cookie, skb,\n\t\t\t\t      b_last_fragment);\n\n\tdev_kfree_skb_any(skb);\n}\n\nstatic int qed_ll2_alloc_buffer(struct qed_dev *cdev,\n\t\t\t\tu8 **data, dma_addr_t *phys_addr)\n{\n\tsize_t size = cdev->ll2->rx_size + NET_SKB_PAD +\n\t\t      SKB_DATA_ALIGN(sizeof(struct skb_shared_info));\n\n\t*data = kmalloc(size, GFP_ATOMIC);\n\tif (!(*data)) {\n\t\tDP_INFO(cdev, \"Failed to allocate LL2 buffer data\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t*phys_addr = dma_map_single(&cdev->pdev->dev,\n\t\t\t\t    ((*data) + NET_SKB_PAD),\n\t\t\t\t    cdev->ll2->rx_size, DMA_FROM_DEVICE);\n\tif (dma_mapping_error(&cdev->pdev->dev, *phys_addr)) {\n\t\tDP_INFO(cdev, \"Failed to map LL2 buffer data\\n\");\n\t\tkfree((*data));\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic int qed_ll2_dealloc_buffer(struct qed_dev *cdev,\n\t\t\t\t  struct qed_ll2_buffer *buffer)\n{\n\tspin_lock_bh(&cdev->ll2->lock);\n\n\tdma_unmap_single(&cdev->pdev->dev, buffer->phys_addr,\n\t\t\t cdev->ll2->rx_size, DMA_FROM_DEVICE);\n\tkfree(buffer->data);\n\tlist_del(&buffer->list);\n\n\tcdev->ll2->rx_cnt--;\n\tif (!cdev->ll2->rx_cnt)\n\t\tDP_INFO(cdev, \"All LL2 entries were removed\\n\");\n\n\tspin_unlock_bh(&cdev->ll2->lock);\n\n\treturn 0;\n}\n\nstatic void qed_ll2_kill_buffers(struct qed_dev *cdev)\n{\n\tstruct qed_ll2_buffer *buffer, *tmp_buffer;\n\n\tlist_for_each_entry_safe(buffer, tmp_buffer, &cdev->ll2->list, list)\n\t\tqed_ll2_dealloc_buffer(cdev, buffer);\n}\n\nstatic void qed_ll2b_complete_rx_packet(void *cxt,\n\t\t\t\t\tstruct qed_ll2_comp_rx_data *data)\n{\n\tstruct qed_hwfn *p_hwfn = cxt;\n\tstruct qed_ll2_buffer *buffer = data->cookie;\n\tstruct qed_dev *cdev = p_hwfn->cdev;\n\tdma_addr_t new_phys_addr;\n\tstruct sk_buff *skb;\n\tbool reuse = false;\n\tint rc = -EINVAL;\n\tu8 *new_data;\n\n\tDP_VERBOSE(p_hwfn,\n\t\t   (NETIF_MSG_RX_STATUS | QED_MSG_STORAGE | NETIF_MSG_PKTDATA),\n\t\t   \"Got an LL2 Rx completion: [Buffer at phys 0x%llx, offset 0x%02x] Length 0x%04x Parse_flags 0x%04x vlan 0x%04x Opaque data [0x%08x:0x%08x]\\n\",\n\t\t   (u64)data->rx_buf_addr,\n\t\t   data->u.placement_offset,\n\t\t   data->length.packet_length,\n\t\t   data->parse_flags,\n\t\t   data->vlan, data->opaque_data_0, data->opaque_data_1);\n\n\tif ((cdev->dp_module & NETIF_MSG_PKTDATA) && buffer->data) {\n\t\tprint_hex_dump(KERN_INFO, \"\",\n\t\t\t       DUMP_PREFIX_OFFSET, 16, 1,\n\t\t\t       buffer->data, data->length.packet_length, false);\n\t}\n\n\t \n\tif (data->length.packet_length < ETH_HLEN)\n\t\treuse = true;\n\n\t \n\tif (!reuse)\n\t\trc = qed_ll2_alloc_buffer(p_hwfn->cdev, &new_data,\n\t\t\t\t\t  &new_phys_addr);\n\n\t \n\tif (rc)\n\t\tgoto out_post;\n\tdma_unmap_single(&cdev->pdev->dev, buffer->phys_addr,\n\t\t\t cdev->ll2->rx_size, DMA_FROM_DEVICE);\n\n\tskb = slab_build_skb(buffer->data);\n\tif (!skb) {\n\t\tDP_INFO(cdev, \"Failed to build SKB\\n\");\n\t\tkfree(buffer->data);\n\t\tgoto out_post1;\n\t}\n\n\tdata->u.placement_offset += NET_SKB_PAD;\n\tskb_reserve(skb, data->u.placement_offset);\n\tskb_put(skb, data->length.packet_length);\n\tskb_checksum_none_assert(skb);\n\n\t \n\tskb_reset_mac_header(skb);\n\tskb->protocol = eth_hdr(skb)->h_proto;\n\n\t \n\tif (cdev->ll2->cbs && cdev->ll2->cbs->rx_cb) {\n\t\tif (data->vlan)\n\t\t\t__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q),\n\t\t\t\t\t       data->vlan);\n\t\tcdev->ll2->cbs->rx_cb(cdev->ll2->cb_cookie, skb,\n\t\t\t\t      data->opaque_data_0,\n\t\t\t\t      data->opaque_data_1);\n\t} else {\n\t\tDP_VERBOSE(p_hwfn, (NETIF_MSG_RX_STATUS | NETIF_MSG_PKTDATA |\n\t\t\t\t    QED_MSG_LL2 | QED_MSG_STORAGE),\n\t\t\t   \"Dropping the packet\\n\");\n\t\tkfree(buffer->data);\n\t}\n\nout_post1:\n\t \n\tbuffer->data = new_data;\n\tbuffer->phys_addr = new_phys_addr;\n\nout_post:\n\trc = qed_ll2_post_rx_buffer(p_hwfn, cdev->ll2->handle,\n\t\t\t\t    buffer->phys_addr, 0, buffer, 1);\n\tif (rc)\n\t\tqed_ll2_dealloc_buffer(cdev, buffer);\n}\n\nstatic struct qed_ll2_info *__qed_ll2_handle_sanity(struct qed_hwfn *p_hwfn,\n\t\t\t\t\t\t    u8 connection_handle,\n\t\t\t\t\t\t    bool b_lock,\n\t\t\t\t\t\t    bool b_only_active)\n{\n\tstruct qed_ll2_info *p_ll2_conn, *p_ret = NULL;\n\n\tif (connection_handle >= QED_MAX_NUM_OF_LL2_CONNECTIONS)\n\t\treturn NULL;\n\n\tif (!p_hwfn->p_ll2_info)\n\t\treturn NULL;\n\n\tp_ll2_conn = &p_hwfn->p_ll2_info[connection_handle];\n\n\tif (b_only_active) {\n\t\tif (b_lock)\n\t\t\tmutex_lock(&p_ll2_conn->mutex);\n\t\tif (p_ll2_conn->b_active)\n\t\t\tp_ret = p_ll2_conn;\n\t\tif (b_lock)\n\t\t\tmutex_unlock(&p_ll2_conn->mutex);\n\t} else {\n\t\tp_ret = p_ll2_conn;\n\t}\n\n\treturn p_ret;\n}\n\nstatic struct qed_ll2_info *qed_ll2_handle_sanity(struct qed_hwfn *p_hwfn,\n\t\t\t\t\t\t  u8 connection_handle)\n{\n\treturn __qed_ll2_handle_sanity(p_hwfn, connection_handle, false, true);\n}\n\nstatic struct qed_ll2_info *qed_ll2_handle_sanity_lock(struct qed_hwfn *p_hwfn,\n\t\t\t\t\t\t       u8 connection_handle)\n{\n\treturn __qed_ll2_handle_sanity(p_hwfn, connection_handle, true, true);\n}\n\nstatic struct qed_ll2_info *qed_ll2_handle_sanity_inactive(struct qed_hwfn\n\t\t\t\t\t\t\t   *p_hwfn,\n\t\t\t\t\t\t\t   u8 connection_handle)\n{\n\treturn __qed_ll2_handle_sanity(p_hwfn, connection_handle, false, false);\n}\n\nstatic void qed_ll2_txq_flush(struct qed_hwfn *p_hwfn, u8 connection_handle)\n{\n\tbool b_last_packet = false, b_last_frag = false;\n\tstruct qed_ll2_tx_packet *p_pkt = NULL;\n\tstruct qed_ll2_info *p_ll2_conn;\n\tstruct qed_ll2_tx_queue *p_tx;\n\tunsigned long flags = 0;\n\tdma_addr_t tx_frag;\n\n\tp_ll2_conn = qed_ll2_handle_sanity_inactive(p_hwfn, connection_handle);\n\tif (!p_ll2_conn)\n\t\treturn;\n\n\tp_tx = &p_ll2_conn->tx_queue;\n\n\tspin_lock_irqsave(&p_tx->lock, flags);\n\twhile (!list_empty(&p_tx->active_descq)) {\n\t\tp_pkt = list_first_entry(&p_tx->active_descq,\n\t\t\t\t\t struct qed_ll2_tx_packet, list_entry);\n\t\tif (!p_pkt)\n\t\t\tbreak;\n\n\t\tlist_del(&p_pkt->list_entry);\n\t\tb_last_packet = list_empty(&p_tx->active_descq);\n\t\tlist_add_tail(&p_pkt->list_entry, &p_tx->free_descq);\n\t\tspin_unlock_irqrestore(&p_tx->lock, flags);\n\t\tif (p_ll2_conn->input.conn_type == QED_LL2_TYPE_OOO) {\n\t\t\tstruct qed_ooo_buffer *p_buffer;\n\n\t\t\tp_buffer = (struct qed_ooo_buffer *)p_pkt->cookie;\n\t\t\tqed_ooo_put_free_buffer(p_hwfn, p_hwfn->p_ooo_info,\n\t\t\t\t\t\tp_buffer);\n\t\t} else {\n\t\t\tp_tx->cur_completing_packet = *p_pkt;\n\t\t\tp_tx->cur_completing_bd_idx = 1;\n\t\t\tb_last_frag =\n\t\t\t\tp_tx->cur_completing_bd_idx == p_pkt->bd_used;\n\t\t\ttx_frag = p_pkt->bds_set[0].tx_frag;\n\t\t\tp_ll2_conn->cbs.tx_release_cb(p_ll2_conn->cbs.cookie,\n\t\t\t\t\t\t      p_ll2_conn->my_id,\n\t\t\t\t\t\t      p_pkt->cookie,\n\t\t\t\t\t\t      tx_frag,\n\t\t\t\t\t\t      b_last_frag,\n\t\t\t\t\t\t      b_last_packet);\n\t\t}\n\t\tspin_lock_irqsave(&p_tx->lock, flags);\n\t}\n\tspin_unlock_irqrestore(&p_tx->lock, flags);\n}\n\nstatic int qed_ll2_txq_completion(struct qed_hwfn *p_hwfn, void *p_cookie)\n{\n\tstruct qed_ll2_info *p_ll2_conn = p_cookie;\n\tstruct qed_ll2_tx_queue *p_tx = &p_ll2_conn->tx_queue;\n\tu16 new_idx = 0, num_bds = 0, num_bds_in_packet = 0;\n\tstruct qed_ll2_tx_packet *p_pkt;\n\tbool b_last_frag = false;\n\tunsigned long flags;\n\tint rc = -EINVAL;\n\n\tif (!p_ll2_conn)\n\t\treturn rc;\n\n\tspin_lock_irqsave(&p_tx->lock, flags);\n\tif (p_tx->b_completing_packet) {\n\t\trc = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tnew_idx = le16_to_cpu(*p_tx->p_fw_cons);\n\tnum_bds = ((s16)new_idx - (s16)p_tx->bds_idx);\n\twhile (num_bds) {\n\t\tif (list_empty(&p_tx->active_descq))\n\t\t\tgoto out;\n\n\t\tp_pkt = list_first_entry(&p_tx->active_descq,\n\t\t\t\t\t struct qed_ll2_tx_packet, list_entry);\n\t\tif (!p_pkt)\n\t\t\tgoto out;\n\n\t\tp_tx->b_completing_packet = true;\n\t\tp_tx->cur_completing_packet = *p_pkt;\n\t\tnum_bds_in_packet = p_pkt->bd_used;\n\t\tlist_del(&p_pkt->list_entry);\n\n\t\tif (unlikely(num_bds < num_bds_in_packet)) {\n\t\t\tDP_NOTICE(p_hwfn,\n\t\t\t\t  \"Rest of BDs does not cover whole packet\\n\");\n\t\t\tgoto out;\n\t\t}\n\n\t\tnum_bds -= num_bds_in_packet;\n\t\tp_tx->bds_idx += num_bds_in_packet;\n\t\twhile (num_bds_in_packet--)\n\t\t\tqed_chain_consume(&p_tx->txq_chain);\n\n\t\tp_tx->cur_completing_bd_idx = 1;\n\t\tb_last_frag = p_tx->cur_completing_bd_idx == p_pkt->bd_used;\n\t\tlist_add_tail(&p_pkt->list_entry, &p_tx->free_descq);\n\n\t\tspin_unlock_irqrestore(&p_tx->lock, flags);\n\n\t\tp_ll2_conn->cbs.tx_comp_cb(p_ll2_conn->cbs.cookie,\n\t\t\t\t\t   p_ll2_conn->my_id,\n\t\t\t\t\t   p_pkt->cookie,\n\t\t\t\t\t   p_pkt->bds_set[0].tx_frag,\n\t\t\t\t\t   b_last_frag, !num_bds);\n\n\t\tspin_lock_irqsave(&p_tx->lock, flags);\n\t}\n\n\tp_tx->b_completing_packet = false;\n\trc = 0;\nout:\n\tspin_unlock_irqrestore(&p_tx->lock, flags);\n\treturn rc;\n}\n\nstatic void qed_ll2_rxq_parse_gsi(struct qed_hwfn *p_hwfn,\n\t\t\t\t  union core_rx_cqe_union *p_cqe,\n\t\t\t\t  struct qed_ll2_comp_rx_data *data)\n{\n\tdata->parse_flags = le16_to_cpu(p_cqe->rx_cqe_gsi.parse_flags.flags);\n\tdata->length.data_length = le16_to_cpu(p_cqe->rx_cqe_gsi.data_length);\n\tdata->vlan = le16_to_cpu(p_cqe->rx_cqe_gsi.vlan);\n\tdata->opaque_data_0 = le32_to_cpu(p_cqe->rx_cqe_gsi.src_mac_addrhi);\n\tdata->opaque_data_1 = le16_to_cpu(p_cqe->rx_cqe_gsi.src_mac_addrlo);\n\tdata->u.data_length_error = p_cqe->rx_cqe_gsi.data_length_error;\n\tdata->qp_id = le16_to_cpu(p_cqe->rx_cqe_gsi.qp_id);\n\n\tdata->src_qp = le32_to_cpu(p_cqe->rx_cqe_gsi.src_qp);\n}\n\nstatic void qed_ll2_rxq_parse_reg(struct qed_hwfn *p_hwfn,\n\t\t\t\t  union core_rx_cqe_union *p_cqe,\n\t\t\t\t  struct qed_ll2_comp_rx_data *data)\n{\n\tdata->parse_flags = le16_to_cpu(p_cqe->rx_cqe_fp.parse_flags.flags);\n\tdata->err_flags = le16_to_cpu(p_cqe->rx_cqe_fp.err_flags.flags);\n\tdata->length.packet_length =\n\t    le16_to_cpu(p_cqe->rx_cqe_fp.packet_length);\n\tdata->vlan = le16_to_cpu(p_cqe->rx_cqe_fp.vlan);\n\tdata->opaque_data_0 = le32_to_cpu(p_cqe->rx_cqe_fp.opaque_data.data[0]);\n\tdata->opaque_data_1 = le32_to_cpu(p_cqe->rx_cqe_fp.opaque_data.data[1]);\n\tdata->u.placement_offset = p_cqe->rx_cqe_fp.placement_offset;\n}\n\nstatic int\nqed_ll2_handle_slowpath(struct qed_hwfn *p_hwfn,\n\t\t\tstruct qed_ll2_info *p_ll2_conn,\n\t\t\tunion core_rx_cqe_union *p_cqe,\n\t\t\tunsigned long *p_lock_flags)\n{\n\tstruct qed_ll2_rx_queue *p_rx = &p_ll2_conn->rx_queue;\n\tstruct core_rx_slow_path_cqe *sp_cqe;\n\n\tsp_cqe = &p_cqe->rx_cqe_sp;\n\tif (sp_cqe->ramrod_cmd_id != CORE_RAMROD_RX_QUEUE_FLUSH) {\n\t\tDP_NOTICE(p_hwfn,\n\t\t\t  \"LL2 - unexpected Rx CQE slowpath ramrod_cmd_id:%d\\n\",\n\t\t\t  sp_cqe->ramrod_cmd_id);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!p_ll2_conn->cbs.slowpath_cb) {\n\t\tDP_NOTICE(p_hwfn,\n\t\t\t  \"LL2 - received RX_QUEUE_FLUSH but no callback was provided\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tspin_unlock_irqrestore(&p_rx->lock, *p_lock_flags);\n\n\tp_ll2_conn->cbs.slowpath_cb(p_ll2_conn->cbs.cookie,\n\t\t\t\t    p_ll2_conn->my_id,\n\t\t\t\t    le32_to_cpu(sp_cqe->opaque_data.data[0]),\n\t\t\t\t    le32_to_cpu(sp_cqe->opaque_data.data[1]));\n\n\tspin_lock_irqsave(&p_rx->lock, *p_lock_flags);\n\n\treturn 0;\n}\n\nstatic int\nqed_ll2_rxq_handle_completion(struct qed_hwfn *p_hwfn,\n\t\t\t      struct qed_ll2_info *p_ll2_conn,\n\t\t\t      union core_rx_cqe_union *p_cqe,\n\t\t\t      unsigned long *p_lock_flags, bool b_last_cqe)\n{\n\tstruct qed_ll2_rx_queue *p_rx = &p_ll2_conn->rx_queue;\n\tstruct qed_ll2_rx_packet *p_pkt = NULL;\n\tstruct qed_ll2_comp_rx_data data;\n\n\tif (!list_empty(&p_rx->active_descq))\n\t\tp_pkt = list_first_entry(&p_rx->active_descq,\n\t\t\t\t\t struct qed_ll2_rx_packet, list_entry);\n\tif (unlikely(!p_pkt)) {\n\t\tDP_NOTICE(p_hwfn,\n\t\t\t  \"[%d] LL2 Rx completion but active_descq is empty\\n\",\n\t\t\t  p_ll2_conn->input.conn_type);\n\n\t\treturn -EIO;\n\t}\n\tlist_del(&p_pkt->list_entry);\n\n\tif (p_cqe->rx_cqe_sp.type == CORE_RX_CQE_TYPE_REGULAR)\n\t\tqed_ll2_rxq_parse_reg(p_hwfn, p_cqe, &data);\n\telse\n\t\tqed_ll2_rxq_parse_gsi(p_hwfn, p_cqe, &data);\n\tif (unlikely(qed_chain_consume(&p_rx->rxq_chain) != p_pkt->rxq_bd))\n\t\tDP_NOTICE(p_hwfn,\n\t\t\t  \"Mismatch between active_descq and the LL2 Rx chain\\n\");\n\n\tlist_add_tail(&p_pkt->list_entry, &p_rx->free_descq);\n\n\tdata.connection_handle = p_ll2_conn->my_id;\n\tdata.cookie = p_pkt->cookie;\n\tdata.rx_buf_addr = p_pkt->rx_buf_addr;\n\tdata.b_last_packet = b_last_cqe;\n\n\tspin_unlock_irqrestore(&p_rx->lock, *p_lock_flags);\n\tp_ll2_conn->cbs.rx_comp_cb(p_ll2_conn->cbs.cookie, &data);\n\n\tspin_lock_irqsave(&p_rx->lock, *p_lock_flags);\n\n\treturn 0;\n}\n\nstatic int qed_ll2_rxq_completion(struct qed_hwfn *p_hwfn, void *cookie)\n{\n\tstruct qed_ll2_info *p_ll2_conn = (struct qed_ll2_info *)cookie;\n\tstruct qed_ll2_rx_queue *p_rx = &p_ll2_conn->rx_queue;\n\tunion core_rx_cqe_union *cqe = NULL;\n\tu16 cq_new_idx = 0, cq_old_idx = 0;\n\tunsigned long flags = 0;\n\tint rc = 0;\n\n\tif (!p_ll2_conn)\n\t\treturn rc;\n\n\tspin_lock_irqsave(&p_rx->lock, flags);\n\n\tif (!QED_LL2_RX_REGISTERED(p_ll2_conn)) {\n\t\tspin_unlock_irqrestore(&p_rx->lock, flags);\n\t\treturn 0;\n\t}\n\n\tcq_new_idx = le16_to_cpu(*p_rx->p_fw_cons);\n\tcq_old_idx = qed_chain_get_cons_idx(&p_rx->rcq_chain);\n\n\twhile (cq_new_idx != cq_old_idx) {\n\t\tbool b_last_cqe = (cq_new_idx == cq_old_idx);\n\n\t\tcqe =\n\t\t    (union core_rx_cqe_union *)\n\t\t    qed_chain_consume(&p_rx->rcq_chain);\n\t\tcq_old_idx = qed_chain_get_cons_idx(&p_rx->rcq_chain);\n\n\t\tDP_VERBOSE(p_hwfn,\n\t\t\t   QED_MSG_LL2,\n\t\t\t   \"LL2 [sw. cons %04x, fw. at %04x] - Got Packet of type %02x\\n\",\n\t\t\t   cq_old_idx, cq_new_idx, cqe->rx_cqe_sp.type);\n\n\t\tswitch (cqe->rx_cqe_sp.type) {\n\t\tcase CORE_RX_CQE_TYPE_SLOW_PATH:\n\t\t\trc = qed_ll2_handle_slowpath(p_hwfn, p_ll2_conn,\n\t\t\t\t\t\t     cqe, &flags);\n\t\t\tbreak;\n\t\tcase CORE_RX_CQE_TYPE_GSI_OFFLOAD:\n\t\tcase CORE_RX_CQE_TYPE_REGULAR:\n\t\t\trc = qed_ll2_rxq_handle_completion(p_hwfn, p_ll2_conn,\n\t\t\t\t\t\t\t   cqe, &flags,\n\t\t\t\t\t\t\t   b_last_cqe);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\trc = -EIO;\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&p_rx->lock, flags);\n\treturn rc;\n}\n\nstatic void qed_ll2_rxq_flush(struct qed_hwfn *p_hwfn, u8 connection_handle)\n{\n\tstruct qed_ll2_info *p_ll2_conn = NULL;\n\tstruct qed_ll2_rx_packet *p_pkt = NULL;\n\tstruct qed_ll2_rx_queue *p_rx;\n\tunsigned long flags = 0;\n\n\tp_ll2_conn = qed_ll2_handle_sanity_inactive(p_hwfn, connection_handle);\n\tif (!p_ll2_conn)\n\t\treturn;\n\n\tp_rx = &p_ll2_conn->rx_queue;\n\n\tspin_lock_irqsave(&p_rx->lock, flags);\n\twhile (!list_empty(&p_rx->active_descq)) {\n\t\tp_pkt = list_first_entry(&p_rx->active_descq,\n\t\t\t\t\t struct qed_ll2_rx_packet, list_entry);\n\t\tif (!p_pkt)\n\t\t\tbreak;\n\t\tlist_move_tail(&p_pkt->list_entry, &p_rx->free_descq);\n\t\tspin_unlock_irqrestore(&p_rx->lock, flags);\n\n\t\tif (p_ll2_conn->input.conn_type == QED_LL2_TYPE_OOO) {\n\t\t\tstruct qed_ooo_buffer *p_buffer;\n\n\t\t\tp_buffer = (struct qed_ooo_buffer *)p_pkt->cookie;\n\t\t\tqed_ooo_put_free_buffer(p_hwfn, p_hwfn->p_ooo_info,\n\t\t\t\t\t\tp_buffer);\n\t\t} else {\n\t\t\tdma_addr_t rx_buf_addr = p_pkt->rx_buf_addr;\n\t\t\tvoid *cookie = p_pkt->cookie;\n\t\t\tbool b_last;\n\n\t\t\tb_last = list_empty(&p_rx->active_descq);\n\t\t\tp_ll2_conn->cbs.rx_release_cb(p_ll2_conn->cbs.cookie,\n\t\t\t\t\t\t      p_ll2_conn->my_id,\n\t\t\t\t\t\t      cookie,\n\t\t\t\t\t\t      rx_buf_addr, b_last);\n\t\t}\n\t\tspin_lock_irqsave(&p_rx->lock, flags);\n\t}\n\tspin_unlock_irqrestore(&p_rx->lock, flags);\n}\n\nstatic bool\nqed_ll2_lb_rxq_handler_slowpath(struct qed_hwfn *p_hwfn,\n\t\t\t\tstruct core_rx_slow_path_cqe *p_cqe)\n{\n\tstruct ooo_opaque *ooo_opq;\n\tu32 cid;\n\n\tif (p_cqe->ramrod_cmd_id != CORE_RAMROD_RX_QUEUE_FLUSH)\n\t\treturn false;\n\n\tooo_opq = (struct ooo_opaque *)&p_cqe->opaque_data;\n\tif (ooo_opq->ooo_opcode != TCP_EVENT_DELETE_ISLES)\n\t\treturn false;\n\n\t \n\tcid = le32_to_cpu(ooo_opq->cid);\n\tqed_ooo_release_connection_isles(p_hwfn, p_hwfn->p_ooo_info, cid);\n\n\treturn true;\n}\n\nstatic int qed_ll2_lb_rxq_handler(struct qed_hwfn *p_hwfn,\n\t\t\t\t  struct qed_ll2_info *p_ll2_conn)\n{\n\tstruct qed_ll2_rx_queue *p_rx = &p_ll2_conn->rx_queue;\n\tu16 packet_length = 0, parse_flags = 0, vlan = 0;\n\tstruct qed_ll2_rx_packet *p_pkt = NULL;\n\tunion core_rx_cqe_union *cqe = NULL;\n\tu16 cq_new_idx = 0, cq_old_idx = 0;\n\tstruct qed_ooo_buffer *p_buffer;\n\tstruct ooo_opaque *ooo_opq;\n\tu8 placement_offset = 0;\n\tu8 cqe_type;\n\tu32 cid;\n\n\tcq_new_idx = le16_to_cpu(*p_rx->p_fw_cons);\n\tcq_old_idx = qed_chain_get_cons_idx(&p_rx->rcq_chain);\n\tif (cq_new_idx == cq_old_idx)\n\t\treturn 0;\n\n\twhile (cq_new_idx != cq_old_idx) {\n\t\tstruct core_rx_fast_path_cqe *p_cqe_fp;\n\n\t\tcqe = qed_chain_consume(&p_rx->rcq_chain);\n\t\tcq_old_idx = qed_chain_get_cons_idx(&p_rx->rcq_chain);\n\t\tcqe_type = cqe->rx_cqe_sp.type;\n\n\t\tif (cqe_type == CORE_RX_CQE_TYPE_SLOW_PATH)\n\t\t\tif (qed_ll2_lb_rxq_handler_slowpath(p_hwfn,\n\t\t\t\t\t\t\t    &cqe->rx_cqe_sp))\n\t\t\t\tcontinue;\n\n\t\tif (unlikely(cqe_type != CORE_RX_CQE_TYPE_REGULAR)) {\n\t\t\tDP_NOTICE(p_hwfn,\n\t\t\t\t  \"Got a non-regular LB LL2 completion [type 0x%02x]\\n\",\n\t\t\t\t  cqe_type);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tp_cqe_fp = &cqe->rx_cqe_fp;\n\n\t\tplacement_offset = p_cqe_fp->placement_offset;\n\t\tparse_flags = le16_to_cpu(p_cqe_fp->parse_flags.flags);\n\t\tpacket_length = le16_to_cpu(p_cqe_fp->packet_length);\n\t\tvlan = le16_to_cpu(p_cqe_fp->vlan);\n\t\tooo_opq = (struct ooo_opaque *)&p_cqe_fp->opaque_data;\n\t\tqed_ooo_save_history_entry(p_hwfn, p_hwfn->p_ooo_info, ooo_opq);\n\t\tcid = le32_to_cpu(ooo_opq->cid);\n\n\t\t \n\t\tif (ooo_opq->drop_size)\n\t\t\tqed_ooo_delete_isles(p_hwfn, p_hwfn->p_ooo_info, cid,\n\t\t\t\t\t     ooo_opq->drop_isle,\n\t\t\t\t\t     ooo_opq->drop_size);\n\n\t\tif (ooo_opq->ooo_opcode == TCP_EVENT_NOP)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (unlikely(list_empty(&p_rx->active_descq))) {\n\t\t\tDP_NOTICE(p_hwfn,\n\t\t\t\t  \"LL2 OOO RX chain has no submitted buffers\\n\"\n\t\t\t\t  );\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tp_pkt = list_first_entry(&p_rx->active_descq,\n\t\t\t\t\t struct qed_ll2_rx_packet, list_entry);\n\n\t\tif (likely(ooo_opq->ooo_opcode == TCP_EVENT_ADD_NEW_ISLE ||\n\t\t\t   ooo_opq->ooo_opcode == TCP_EVENT_ADD_ISLE_RIGHT ||\n\t\t\t   ooo_opq->ooo_opcode == TCP_EVENT_ADD_ISLE_LEFT ||\n\t\t\t   ooo_opq->ooo_opcode == TCP_EVENT_ADD_PEN ||\n\t\t\t   ooo_opq->ooo_opcode == TCP_EVENT_JOIN)) {\n\t\t\tif (unlikely(!p_pkt)) {\n\t\t\t\tDP_NOTICE(p_hwfn,\n\t\t\t\t\t  \"LL2 OOO RX packet is not valid\\n\");\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t\tlist_del(&p_pkt->list_entry);\n\t\t\tp_buffer = (struct qed_ooo_buffer *)p_pkt->cookie;\n\t\t\tp_buffer->packet_length = packet_length;\n\t\t\tp_buffer->parse_flags = parse_flags;\n\t\t\tp_buffer->vlan = vlan;\n\t\t\tp_buffer->placement_offset = placement_offset;\n\t\t\tqed_chain_consume(&p_rx->rxq_chain);\n\t\t\tlist_add_tail(&p_pkt->list_entry, &p_rx->free_descq);\n\n\t\t\tswitch (ooo_opq->ooo_opcode) {\n\t\t\tcase TCP_EVENT_ADD_NEW_ISLE:\n\t\t\t\tqed_ooo_add_new_isle(p_hwfn,\n\t\t\t\t\t\t     p_hwfn->p_ooo_info,\n\t\t\t\t\t\t     cid,\n\t\t\t\t\t\t     ooo_opq->ooo_isle,\n\t\t\t\t\t\t     p_buffer);\n\t\t\t\tbreak;\n\t\t\tcase TCP_EVENT_ADD_ISLE_RIGHT:\n\t\t\t\tqed_ooo_add_new_buffer(p_hwfn,\n\t\t\t\t\t\t       p_hwfn->p_ooo_info,\n\t\t\t\t\t\t       cid,\n\t\t\t\t\t\t       ooo_opq->ooo_isle,\n\t\t\t\t\t\t       p_buffer,\n\t\t\t\t\t\t       QED_OOO_RIGHT_BUF);\n\t\t\t\tbreak;\n\t\t\tcase TCP_EVENT_ADD_ISLE_LEFT:\n\t\t\t\tqed_ooo_add_new_buffer(p_hwfn,\n\t\t\t\t\t\t       p_hwfn->p_ooo_info,\n\t\t\t\t\t\t       cid,\n\t\t\t\t\t\t       ooo_opq->ooo_isle,\n\t\t\t\t\t\t       p_buffer,\n\t\t\t\t\t\t       QED_OOO_LEFT_BUF);\n\t\t\t\tbreak;\n\t\t\tcase TCP_EVENT_JOIN:\n\t\t\t\tqed_ooo_add_new_buffer(p_hwfn,\n\t\t\t\t\t\t       p_hwfn->p_ooo_info,\n\t\t\t\t\t\t       cid,\n\t\t\t\t\t\t       ooo_opq->ooo_isle + 1,\n\t\t\t\t\t\t       p_buffer,\n\t\t\t\t\t\t       QED_OOO_LEFT_BUF);\n\t\t\t\tqed_ooo_join_isles(p_hwfn,\n\t\t\t\t\t\t   p_hwfn->p_ooo_info,\n\t\t\t\t\t\t   cid, ooo_opq->ooo_isle);\n\t\t\t\tbreak;\n\t\t\tcase TCP_EVENT_ADD_PEN:\n\t\t\t\tqed_ooo_put_ready_buffer(p_hwfn,\n\t\t\t\t\t\t\t p_hwfn->p_ooo_info,\n\t\t\t\t\t\t\t p_buffer, true);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tDP_NOTICE(p_hwfn,\n\t\t\t\t  \"Unexpected event (%d) TX OOO completion\\n\",\n\t\t\t\t  ooo_opq->ooo_opcode);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void\nqed_ooo_submit_tx_buffers(struct qed_hwfn *p_hwfn,\n\t\t\t  struct qed_ll2_info *p_ll2_conn)\n{\n\tstruct qed_ll2_tx_pkt_info tx_pkt;\n\tstruct qed_ooo_buffer *p_buffer;\n\tu16 l4_hdr_offset_w;\n\tdma_addr_t first_frag;\n\tu8 bd_flags;\n\tint rc;\n\n\t \n\twhile ((p_buffer = qed_ooo_get_ready_buffer(p_hwfn,\n\t\t\t\t\t\t    p_hwfn->p_ooo_info))) {\n\t\tl4_hdr_offset_w = 0;\n\t\tbd_flags = 0;\n\n\t\tfirst_frag = p_buffer->rx_buffer_phys_addr +\n\t\t\t     p_buffer->placement_offset;\n\t\tSET_FIELD(bd_flags, CORE_TX_BD_DATA_FORCE_VLAN_MODE, 1);\n\t\tSET_FIELD(bd_flags, CORE_TX_BD_DATA_L4_PROTOCOL, 1);\n\n\t\tmemset(&tx_pkt, 0, sizeof(tx_pkt));\n\t\ttx_pkt.num_of_bds = 1;\n\t\ttx_pkt.vlan = p_buffer->vlan;\n\t\ttx_pkt.bd_flags = bd_flags;\n\t\ttx_pkt.l4_hdr_offset_w = l4_hdr_offset_w;\n\t\tswitch (p_ll2_conn->tx_dest) {\n\t\tcase CORE_TX_DEST_NW:\n\t\t\ttx_pkt.tx_dest = QED_LL2_TX_DEST_NW;\n\t\t\tbreak;\n\t\tcase CORE_TX_DEST_LB:\n\t\t\ttx_pkt.tx_dest = QED_LL2_TX_DEST_LB;\n\t\t\tbreak;\n\t\tcase CORE_TX_DEST_DROP:\n\t\tdefault:\n\t\t\ttx_pkt.tx_dest = QED_LL2_TX_DEST_DROP;\n\t\t\tbreak;\n\t\t}\n\t\ttx_pkt.first_frag = first_frag;\n\t\ttx_pkt.first_frag_len = p_buffer->packet_length;\n\t\ttx_pkt.cookie = p_buffer;\n\n\t\trc = qed_ll2_prepare_tx_packet(p_hwfn, p_ll2_conn->my_id,\n\t\t\t\t\t       &tx_pkt, true);\n\t\tif (rc) {\n\t\t\tqed_ooo_put_ready_buffer(p_hwfn, p_hwfn->p_ooo_info,\n\t\t\t\t\t\t p_buffer, false);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void\nqed_ooo_submit_rx_buffers(struct qed_hwfn *p_hwfn,\n\t\t\t  struct qed_ll2_info *p_ll2_conn)\n{\n\tstruct qed_ooo_buffer *p_buffer;\n\tint rc;\n\n\twhile ((p_buffer = qed_ooo_get_free_buffer(p_hwfn,\n\t\t\t\t\t\t   p_hwfn->p_ooo_info))) {\n\t\trc = qed_ll2_post_rx_buffer(p_hwfn,\n\t\t\t\t\t    p_ll2_conn->my_id,\n\t\t\t\t\t    p_buffer->rx_buffer_phys_addr,\n\t\t\t\t\t    0, p_buffer, true);\n\t\tif (rc) {\n\t\t\tqed_ooo_put_free_buffer(p_hwfn,\n\t\t\t\t\t\tp_hwfn->p_ooo_info, p_buffer);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic int qed_ll2_lb_rxq_completion(struct qed_hwfn *p_hwfn, void *p_cookie)\n{\n\tstruct qed_ll2_info *p_ll2_conn = (struct qed_ll2_info *)p_cookie;\n\tint rc;\n\n\tif (!p_ll2_conn)\n\t\treturn 0;\n\n\tif (!QED_LL2_RX_REGISTERED(p_ll2_conn))\n\t\treturn 0;\n\n\trc = qed_ll2_lb_rxq_handler(p_hwfn, p_ll2_conn);\n\tif (rc)\n\t\treturn rc;\n\n\tqed_ooo_submit_rx_buffers(p_hwfn, p_ll2_conn);\n\tqed_ooo_submit_tx_buffers(p_hwfn, p_ll2_conn);\n\n\treturn 0;\n}\n\nstatic int qed_ll2_lb_txq_completion(struct qed_hwfn *p_hwfn, void *p_cookie)\n{\n\tstruct qed_ll2_info *p_ll2_conn = (struct qed_ll2_info *)p_cookie;\n\tstruct qed_ll2_tx_queue *p_tx = &p_ll2_conn->tx_queue;\n\tstruct qed_ll2_tx_packet *p_pkt = NULL;\n\tstruct qed_ooo_buffer *p_buffer;\n\tbool b_dont_submit_rx = false;\n\tu16 new_idx = 0, num_bds = 0;\n\tint rc;\n\n\tif (unlikely(!p_ll2_conn))\n\t\treturn 0;\n\n\tif (unlikely(!QED_LL2_TX_REGISTERED(p_ll2_conn)))\n\t\treturn 0;\n\n\tnew_idx = le16_to_cpu(*p_tx->p_fw_cons);\n\tnum_bds = ((s16)new_idx - (s16)p_tx->bds_idx);\n\n\tif (unlikely(!num_bds))\n\t\treturn 0;\n\n\twhile (num_bds) {\n\t\tif (list_empty(&p_tx->active_descq))\n\t\t\treturn -EINVAL;\n\n\t\tp_pkt = list_first_entry(&p_tx->active_descq,\n\t\t\t\t\t struct qed_ll2_tx_packet, list_entry);\n\t\tif (unlikely(!p_pkt))\n\t\t\treturn -EINVAL;\n\n\t\tif (unlikely(p_pkt->bd_used != 1)) {\n\t\t\tDP_NOTICE(p_hwfn,\n\t\t\t\t  \"Unexpectedly many BDs(%d) in TX OOO completion\\n\",\n\t\t\t\t  p_pkt->bd_used);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tlist_del(&p_pkt->list_entry);\n\n\t\tnum_bds--;\n\t\tp_tx->bds_idx++;\n\t\tqed_chain_consume(&p_tx->txq_chain);\n\n\t\tp_buffer = (struct qed_ooo_buffer *)p_pkt->cookie;\n\t\tlist_add_tail(&p_pkt->list_entry, &p_tx->free_descq);\n\n\t\tif (b_dont_submit_rx) {\n\t\t\tqed_ooo_put_free_buffer(p_hwfn, p_hwfn->p_ooo_info,\n\t\t\t\t\t\tp_buffer);\n\t\t\tcontinue;\n\t\t}\n\n\t\trc = qed_ll2_post_rx_buffer(p_hwfn, p_ll2_conn->my_id,\n\t\t\t\t\t    p_buffer->rx_buffer_phys_addr, 0,\n\t\t\t\t\t    p_buffer, true);\n\t\tif (rc != 0) {\n\t\t\tqed_ooo_put_free_buffer(p_hwfn,\n\t\t\t\t\t\tp_hwfn->p_ooo_info, p_buffer);\n\t\t\tb_dont_submit_rx = true;\n\t\t}\n\t}\n\n\tqed_ooo_submit_tx_buffers(p_hwfn, p_ll2_conn);\n\n\treturn 0;\n}\n\nstatic void qed_ll2_stop_ooo(struct qed_hwfn *p_hwfn)\n{\n\tu8 *handle = &p_hwfn->pf_params.iscsi_pf_params.ll2_ooo_queue_id;\n\n\tDP_VERBOSE(p_hwfn, (QED_MSG_STORAGE | QED_MSG_LL2),\n\t\t   \"Stopping LL2 OOO queue [%02x]\\n\", *handle);\n\n\tqed_ll2_terminate_connection(p_hwfn, *handle);\n\tqed_ll2_release_connection(p_hwfn, *handle);\n\t*handle = QED_LL2_UNUSED_HANDLE;\n}\n\nstatic int qed_sp_ll2_rx_queue_start(struct qed_hwfn *p_hwfn,\n\t\t\t\t     struct qed_ll2_info *p_ll2_conn,\n\t\t\t\t     u8 action_on_error)\n{\n\tenum qed_ll2_conn_type conn_type = p_ll2_conn->input.conn_type;\n\tstruct qed_ll2_rx_queue *p_rx = &p_ll2_conn->rx_queue;\n\tstruct core_rx_start_ramrod_data *p_ramrod = NULL;\n\tstruct qed_spq_entry *p_ent = NULL;\n\tstruct qed_sp_init_data init_data;\n\tu16 cqe_pbl_size;\n\tint rc = 0;\n\n\t \n\tmemset(&init_data, 0, sizeof(init_data));\n\tinit_data.cid = p_ll2_conn->cid;\n\tinit_data.opaque_fid = p_hwfn->hw_info.opaque_fid;\n\tinit_data.comp_mode = QED_SPQ_MODE_EBLOCK;\n\n\trc = qed_sp_init_request(p_hwfn, &p_ent,\n\t\t\t\t CORE_RAMROD_RX_QUEUE_START,\n\t\t\t\t PROTOCOLID_CORE, &init_data);\n\tif (rc)\n\t\treturn rc;\n\n\tp_ramrod = &p_ent->ramrod.core_rx_queue_start;\n\tmemset(p_ramrod, 0, sizeof(*p_ramrod));\n\tp_ramrod->sb_id = cpu_to_le16(qed_int_get_sp_sb_id(p_hwfn));\n\tp_ramrod->sb_index = p_rx->rx_sb_index;\n\tp_ramrod->complete_event_flg = 1;\n\n\tp_ramrod->mtu = cpu_to_le16(p_ll2_conn->input.mtu);\n\tDMA_REGPAIR_LE(p_ramrod->bd_base, p_rx->rxq_chain.p_phys_addr);\n\tcqe_pbl_size = (u16)qed_chain_get_page_cnt(&p_rx->rcq_chain);\n\tp_ramrod->num_of_pbl_pages = cpu_to_le16(cqe_pbl_size);\n\tDMA_REGPAIR_LE(p_ramrod->cqe_pbl_addr,\n\t\t       qed_chain_get_pbl_phys(&p_rx->rcq_chain));\n\n\tp_ramrod->drop_ttl0_flg = p_ll2_conn->input.rx_drop_ttl0_flg;\n\tp_ramrod->inner_vlan_stripping_en =\n\t\tp_ll2_conn->input.rx_vlan_removal_en;\n\n\tif (test_bit(QED_MF_UFP_SPECIFIC, &p_hwfn->cdev->mf_bits) &&\n\t    p_ll2_conn->input.conn_type == QED_LL2_TYPE_FCOE)\n\t\tp_ramrod->report_outer_vlan = 1;\n\tp_ramrod->queue_id = p_ll2_conn->queue_id;\n\tp_ramrod->main_func_queue = p_ll2_conn->main_func_queue ? 1 : 0;\n\n\tif (test_bit(QED_MF_LL2_NON_UNICAST, &p_hwfn->cdev->mf_bits) &&\n\t    p_ramrod->main_func_queue && conn_type != QED_LL2_TYPE_ROCE &&\n\t    conn_type != QED_LL2_TYPE_IWARP &&\n\t\t(!QED_IS_NVMETCP_PERSONALITY(p_hwfn))) {\n\t\tp_ramrod->mf_si_bcast_accept_all = 1;\n\t\tp_ramrod->mf_si_mcast_accept_all = 1;\n\t} else {\n\t\tp_ramrod->mf_si_bcast_accept_all = 0;\n\t\tp_ramrod->mf_si_mcast_accept_all = 0;\n\t}\n\n\tp_ramrod->action_on_error.error_type = action_on_error;\n\tp_ramrod->gsi_offload_flag = p_ll2_conn->input.gsi_enable;\n\tp_ramrod->zero_prod_flg = 1;\n\n\treturn qed_spq_post(p_hwfn, p_ent, NULL);\n}\n\nstatic int qed_sp_ll2_tx_queue_start(struct qed_hwfn *p_hwfn,\n\t\t\t\t     struct qed_ll2_info *p_ll2_conn)\n{\n\tenum qed_ll2_conn_type conn_type = p_ll2_conn->input.conn_type;\n\tstruct qed_ll2_tx_queue *p_tx = &p_ll2_conn->tx_queue;\n\tstruct core_tx_start_ramrod_data *p_ramrod = NULL;\n\tstruct qed_spq_entry *p_ent = NULL;\n\tstruct qed_sp_init_data init_data;\n\tu16 pq_id = 0, pbl_size;\n\tint rc = -EINVAL;\n\n\tif (!QED_LL2_TX_REGISTERED(p_ll2_conn))\n\t\treturn 0;\n\n\tif (likely(p_ll2_conn->input.conn_type == QED_LL2_TYPE_OOO))\n\t\tp_ll2_conn->tx_stats_en = 0;\n\telse\n\t\tp_ll2_conn->tx_stats_en = 1;\n\n\t \n\tmemset(&init_data, 0, sizeof(init_data));\n\tinit_data.cid = p_ll2_conn->cid;\n\tinit_data.opaque_fid = p_hwfn->hw_info.opaque_fid;\n\tinit_data.comp_mode = QED_SPQ_MODE_EBLOCK;\n\n\trc = qed_sp_init_request(p_hwfn, &p_ent,\n\t\t\t\t CORE_RAMROD_TX_QUEUE_START,\n\t\t\t\t PROTOCOLID_CORE, &init_data);\n\tif (rc)\n\t\treturn rc;\n\n\tp_ramrod = &p_ent->ramrod.core_tx_queue_start;\n\n\tp_ramrod->sb_id = cpu_to_le16(qed_int_get_sp_sb_id(p_hwfn));\n\tp_ramrod->sb_index = p_tx->tx_sb_index;\n\tp_ramrod->mtu = cpu_to_le16(p_ll2_conn->input.mtu);\n\tp_ramrod->stats_en = p_ll2_conn->tx_stats_en;\n\tp_ramrod->stats_id = p_ll2_conn->tx_stats_id;\n\n\tDMA_REGPAIR_LE(p_ramrod->pbl_base_addr,\n\t\t       qed_chain_get_pbl_phys(&p_tx->txq_chain));\n\tpbl_size = qed_chain_get_page_cnt(&p_tx->txq_chain);\n\tp_ramrod->pbl_size = cpu_to_le16(pbl_size);\n\n\tswitch (p_ll2_conn->input.tx_tc) {\n\tcase PURE_LB_TC:\n\t\tpq_id = qed_get_cm_pq_idx(p_hwfn, PQ_FLAGS_LB);\n\t\tbreak;\n\tcase PKT_LB_TC:\n\t\tpq_id = qed_get_cm_pq_idx(p_hwfn, PQ_FLAGS_OOO);\n\t\tbreak;\n\tdefault:\n\t\tpq_id = qed_get_cm_pq_idx(p_hwfn, PQ_FLAGS_OFLD);\n\t\tbreak;\n\t}\n\n\tp_ramrod->qm_pq_id = cpu_to_le16(pq_id);\n\n\tswitch (conn_type) {\n\tcase QED_LL2_TYPE_FCOE:\n\t\tp_ramrod->conn_type = PROTOCOLID_FCOE;\n\t\tbreak;\n\tcase QED_LL2_TYPE_TCP_ULP:\n\t\tp_ramrod->conn_type = PROTOCOLID_TCP_ULP;\n\t\tbreak;\n\tcase QED_LL2_TYPE_ROCE:\n\t\tp_ramrod->conn_type = PROTOCOLID_ROCE;\n\t\tbreak;\n\tcase QED_LL2_TYPE_IWARP:\n\t\tp_ramrod->conn_type = PROTOCOLID_IWARP;\n\t\tbreak;\n\tcase QED_LL2_TYPE_OOO:\n\t\tif (p_hwfn->hw_info.personality == QED_PCI_ISCSI ||\n\t\t    p_hwfn->hw_info.personality == QED_PCI_NVMETCP)\n\t\t\tp_ramrod->conn_type = PROTOCOLID_TCP_ULP;\n\t\telse\n\t\t\tp_ramrod->conn_type = PROTOCOLID_IWARP;\n\t\tbreak;\n\tdefault:\n\t\tp_ramrod->conn_type = PROTOCOLID_ETH;\n\t\tDP_NOTICE(p_hwfn, \"Unknown connection type: %d\\n\", conn_type);\n\t}\n\n\tp_ramrod->gsi_offload_flag = p_ll2_conn->input.gsi_enable;\n\n\trc = qed_spq_post(p_hwfn, p_ent, NULL);\n\tif (rc)\n\t\treturn rc;\n\n\trc = qed_db_recovery_add(p_hwfn->cdev, p_tx->doorbell_addr,\n\t\t\t\t &p_tx->db_msg, DB_REC_WIDTH_32B,\n\t\t\t\t DB_REC_KERNEL);\n\treturn rc;\n}\n\nstatic int qed_sp_ll2_rx_queue_stop(struct qed_hwfn *p_hwfn,\n\t\t\t\t    struct qed_ll2_info *p_ll2_conn)\n{\n\tstruct core_rx_stop_ramrod_data *p_ramrod = NULL;\n\tstruct qed_spq_entry *p_ent = NULL;\n\tstruct qed_sp_init_data init_data;\n\tint rc = -EINVAL;\n\n\t \n\tmemset(&init_data, 0, sizeof(init_data));\n\tinit_data.cid = p_ll2_conn->cid;\n\tinit_data.opaque_fid = p_hwfn->hw_info.opaque_fid;\n\tinit_data.comp_mode = QED_SPQ_MODE_EBLOCK;\n\n\trc = qed_sp_init_request(p_hwfn, &p_ent,\n\t\t\t\t CORE_RAMROD_RX_QUEUE_STOP,\n\t\t\t\t PROTOCOLID_CORE, &init_data);\n\tif (rc)\n\t\treturn rc;\n\n\tp_ramrod = &p_ent->ramrod.core_rx_queue_stop;\n\n\tp_ramrod->complete_event_flg = 1;\n\tp_ramrod->queue_id = p_ll2_conn->queue_id;\n\n\treturn qed_spq_post(p_hwfn, p_ent, NULL);\n}\n\nstatic int qed_sp_ll2_tx_queue_stop(struct qed_hwfn *p_hwfn,\n\t\t\t\t    struct qed_ll2_info *p_ll2_conn)\n{\n\tstruct qed_ll2_tx_queue *p_tx = &p_ll2_conn->tx_queue;\n\tstruct qed_spq_entry *p_ent = NULL;\n\tstruct qed_sp_init_data init_data;\n\tint rc = -EINVAL;\n\n\tqed_db_recovery_del(p_hwfn->cdev, p_tx->doorbell_addr, &p_tx->db_msg);\n\n\t \n\tmemset(&init_data, 0, sizeof(init_data));\n\tinit_data.cid = p_ll2_conn->cid;\n\tinit_data.opaque_fid = p_hwfn->hw_info.opaque_fid;\n\tinit_data.comp_mode = QED_SPQ_MODE_EBLOCK;\n\n\trc = qed_sp_init_request(p_hwfn, &p_ent,\n\t\t\t\t CORE_RAMROD_TX_QUEUE_STOP,\n\t\t\t\t PROTOCOLID_CORE, &init_data);\n\tif (rc)\n\t\treturn rc;\n\n\treturn qed_spq_post(p_hwfn, p_ent, NULL);\n}\n\nstatic int\nqed_ll2_acquire_connection_rx(struct qed_hwfn *p_hwfn,\n\t\t\t      struct qed_ll2_info *p_ll2_info)\n{\n\tstruct qed_chain_init_params params = {\n\t\t.intended_use\t= QED_CHAIN_USE_TO_CONSUME_PRODUCE,\n\t\t.cnt_type\t= QED_CHAIN_CNT_TYPE_U16,\n\t\t.num_elems\t= p_ll2_info->input.rx_num_desc,\n\t};\n\tstruct qed_dev *cdev = p_hwfn->cdev;\n\tstruct qed_ll2_rx_packet *p_descq;\n\tu32 capacity;\n\tint rc = 0;\n\n\tif (!p_ll2_info->input.rx_num_desc)\n\t\tgoto out;\n\n\tparams.mode = QED_CHAIN_MODE_NEXT_PTR;\n\tparams.elem_size = sizeof(struct core_rx_bd);\n\n\trc = qed_chain_alloc(cdev, &p_ll2_info->rx_queue.rxq_chain, &params);\n\tif (rc) {\n\t\tDP_NOTICE(p_hwfn, \"Failed to allocate ll2 rxq chain\\n\");\n\t\tgoto out;\n\t}\n\n\tcapacity = qed_chain_get_capacity(&p_ll2_info->rx_queue.rxq_chain);\n\tp_descq = kcalloc(capacity, sizeof(struct qed_ll2_rx_packet),\n\t\t\t  GFP_KERNEL);\n\tif (!p_descq) {\n\t\trc = -ENOMEM;\n\t\tDP_NOTICE(p_hwfn, \"Failed to allocate ll2 Rx desc\\n\");\n\t\tgoto out;\n\t}\n\tp_ll2_info->rx_queue.descq_array = p_descq;\n\n\tparams.mode = QED_CHAIN_MODE_PBL;\n\tparams.elem_size = sizeof(struct core_rx_fast_path_cqe);\n\n\trc = qed_chain_alloc(cdev, &p_ll2_info->rx_queue.rcq_chain, &params);\n\tif (rc) {\n\t\tDP_NOTICE(p_hwfn, \"Failed to allocate ll2 rcq chain\\n\");\n\t\tgoto out;\n\t}\n\n\tDP_VERBOSE(p_hwfn, QED_MSG_LL2,\n\t\t   \"Allocated LL2 Rxq [Type %08x] with 0x%08x buffers\\n\",\n\t\t   p_ll2_info->input.conn_type, p_ll2_info->input.rx_num_desc);\n\nout:\n\treturn rc;\n}\n\nstatic int qed_ll2_acquire_connection_tx(struct qed_hwfn *p_hwfn,\n\t\t\t\t\t struct qed_ll2_info *p_ll2_info)\n{\n\tstruct qed_chain_init_params params = {\n\t\t.mode\t\t= QED_CHAIN_MODE_PBL,\n\t\t.intended_use\t= QED_CHAIN_USE_TO_CONSUME_PRODUCE,\n\t\t.cnt_type\t= QED_CHAIN_CNT_TYPE_U16,\n\t\t.num_elems\t= p_ll2_info->input.tx_num_desc,\n\t\t.elem_size\t= sizeof(struct core_tx_bd),\n\t};\n\tstruct qed_ll2_tx_packet *p_descq;\n\tsize_t desc_size;\n\tu32 capacity;\n\tint rc = 0;\n\n\tif (!p_ll2_info->input.tx_num_desc)\n\t\tgoto out;\n\n\trc = qed_chain_alloc(p_hwfn->cdev, &p_ll2_info->tx_queue.txq_chain,\n\t\t\t     &params);\n\tif (rc)\n\t\tgoto out;\n\n\tcapacity = qed_chain_get_capacity(&p_ll2_info->tx_queue.txq_chain);\n\t \n\tdesc_size = struct_size(p_descq, bds_set,\n\t\t\t\tp_ll2_info->input.tx_max_bds_per_packet);\n\n\tp_descq = kcalloc(capacity, desc_size, GFP_KERNEL);\n\tif (!p_descq) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\tp_ll2_info->tx_queue.descq_mem = p_descq;\n\n\tDP_VERBOSE(p_hwfn, QED_MSG_LL2,\n\t\t   \"Allocated LL2 Txq [Type %08x] with 0x%08x buffers\\n\",\n\t\t   p_ll2_info->input.conn_type, p_ll2_info->input.tx_num_desc);\n\nout:\n\tif (rc)\n\t\tDP_NOTICE(p_hwfn,\n\t\t\t  \"Can't allocate memory for Tx LL2 with 0x%08x buffers\\n\",\n\t\t\t  p_ll2_info->input.tx_num_desc);\n\treturn rc;\n}\n\nstatic int\nqed_ll2_acquire_connection_ooo(struct qed_hwfn *p_hwfn,\n\t\t\t       struct qed_ll2_info *p_ll2_info, u16 mtu)\n{\n\tstruct qed_ooo_buffer *p_buf = NULL;\n\tvoid *p_virt;\n\tu16 buf_idx;\n\tint rc = 0;\n\n\tif (p_ll2_info->input.conn_type != QED_LL2_TYPE_OOO)\n\t\treturn rc;\n\n\t \n\tif (!p_ll2_info->input.rx_num_ooo_buffers) {\n\t\tu16 num_desc = p_ll2_info->input.rx_num_desc;\n\n\t\tif (!num_desc)\n\t\t\treturn -EINVAL;\n\t\tp_ll2_info->input.rx_num_ooo_buffers = num_desc * 2;\n\t}\n\n\tfor (buf_idx = 0; buf_idx < p_ll2_info->input.rx_num_ooo_buffers;\n\t     buf_idx++) {\n\t\tp_buf = kzalloc(sizeof(*p_buf), GFP_KERNEL);\n\t\tif (!p_buf) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tp_buf->rx_buffer_size = mtu + 26 + ETH_CACHE_LINE_SIZE;\n\t\tp_buf->rx_buffer_size = (p_buf->rx_buffer_size +\n\t\t\t\t\t ETH_CACHE_LINE_SIZE - 1) &\n\t\t\t\t\t~(ETH_CACHE_LINE_SIZE - 1);\n\t\tp_virt = dma_alloc_coherent(&p_hwfn->cdev->pdev->dev,\n\t\t\t\t\t    p_buf->rx_buffer_size,\n\t\t\t\t\t    &p_buf->rx_buffer_phys_addr,\n\t\t\t\t\t    GFP_KERNEL);\n\t\tif (!p_virt) {\n\t\t\tkfree(p_buf);\n\t\t\trc = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tp_buf->rx_buffer_virt_addr = p_virt;\n\t\tqed_ooo_put_free_buffer(p_hwfn, p_hwfn->p_ooo_info, p_buf);\n\t}\n\n\tDP_VERBOSE(p_hwfn, QED_MSG_LL2,\n\t\t   \"Allocated [%04x] LL2 OOO buffers [each of size 0x%08x]\\n\",\n\t\t   p_ll2_info->input.rx_num_ooo_buffers, p_buf->rx_buffer_size);\n\nout:\n\treturn rc;\n}\n\nstatic int\nqed_ll2_set_cbs(struct qed_ll2_info *p_ll2_info, const struct qed_ll2_cbs *cbs)\n{\n\tif (!cbs || (!cbs->rx_comp_cb ||\n\t\t     !cbs->rx_release_cb ||\n\t\t     !cbs->tx_comp_cb || !cbs->tx_release_cb || !cbs->cookie))\n\t\treturn -EINVAL;\n\n\tp_ll2_info->cbs.rx_comp_cb = cbs->rx_comp_cb;\n\tp_ll2_info->cbs.rx_release_cb = cbs->rx_release_cb;\n\tp_ll2_info->cbs.tx_comp_cb = cbs->tx_comp_cb;\n\tp_ll2_info->cbs.tx_release_cb = cbs->tx_release_cb;\n\tp_ll2_info->cbs.slowpath_cb = cbs->slowpath_cb;\n\tp_ll2_info->cbs.cookie = cbs->cookie;\n\n\treturn 0;\n}\n\nstatic void _qed_ll2_calc_allowed_conns(struct qed_hwfn *p_hwfn,\n\t\t\t\t\tstruct qed_ll2_acquire_data *data,\n\t\t\t\t\tu8 *start_idx, u8 *last_idx)\n{\n\t \n\tif (data->input.rx_conn_type == QED_LL2_RX_TYPE_LEGACY) {\n\t\t*start_idx = QED_LL2_LEGACY_CONN_BASE_PF;\n\t\t*last_idx = *start_idx +\n\t\t\tQED_MAX_NUM_OF_LEGACY_LL2_CONNS_PF;\n\t} else {\n\t\t \n\t\t*start_idx = QED_LL2_CTX_CONN_BASE_PF;\n\t\t*last_idx = *start_idx +\n\t\t\tQED_MAX_NUM_OF_CTX_LL2_CONNS_PF;\n\t}\n}\n\nstatic enum core_error_handle\nqed_ll2_get_error_choice(enum qed_ll2_error_handle err)\n{\n\tswitch (err) {\n\tcase QED_LL2_DROP_PACKET:\n\t\treturn LL2_DROP_PACKET;\n\tcase QED_LL2_DO_NOTHING:\n\t\treturn LL2_DO_NOTHING;\n\tcase QED_LL2_ASSERT:\n\t\treturn LL2_ASSERT;\n\tdefault:\n\t\treturn LL2_DO_NOTHING;\n\t}\n}\n\nint qed_ll2_acquire_connection(void *cxt, struct qed_ll2_acquire_data *data)\n{\n\tstruct qed_hwfn *p_hwfn = cxt;\n\tqed_int_comp_cb_t comp_rx_cb, comp_tx_cb;\n\tstruct qed_ll2_info *p_ll2_info = NULL;\n\tu8 i, first_idx, last_idx, *p_tx_max;\n\tint rc;\n\n\tif (!data->p_connection_handle || !p_hwfn->p_ll2_info)\n\t\treturn -EINVAL;\n\n\t_qed_ll2_calc_allowed_conns(p_hwfn, data, &first_idx, &last_idx);\n\n\t \n\tfor (i = first_idx; i < last_idx; i++) {\n\t\tmutex_lock(&p_hwfn->p_ll2_info[i].mutex);\n\t\tif (p_hwfn->p_ll2_info[i].b_active) {\n\t\t\tmutex_unlock(&p_hwfn->p_ll2_info[i].mutex);\n\t\t\tcontinue;\n\t\t}\n\n\t\tp_hwfn->p_ll2_info[i].b_active = true;\n\t\tp_ll2_info = &p_hwfn->p_ll2_info[i];\n\t\tmutex_unlock(&p_hwfn->p_ll2_info[i].mutex);\n\t\tbreak;\n\t}\n\tif (!p_ll2_info)\n\t\treturn -EBUSY;\n\n\tmemcpy(&p_ll2_info->input, &data->input, sizeof(p_ll2_info->input));\n\n\tswitch (data->input.tx_dest) {\n\tcase QED_LL2_TX_DEST_NW:\n\t\tp_ll2_info->tx_dest = CORE_TX_DEST_NW;\n\t\tbreak;\n\tcase QED_LL2_TX_DEST_LB:\n\t\tp_ll2_info->tx_dest = CORE_TX_DEST_LB;\n\t\tbreak;\n\tcase QED_LL2_TX_DEST_DROP:\n\t\tp_ll2_info->tx_dest = CORE_TX_DEST_DROP;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (data->input.conn_type == QED_LL2_TYPE_OOO ||\n\t    data->input.secondary_queue)\n\t\tp_ll2_info->main_func_queue = false;\n\telse\n\t\tp_ll2_info->main_func_queue = true;\n\n\t \n\tp_tx_max = &p_ll2_info->input.tx_max_bds_per_packet;\n\tif (*p_tx_max == 0)\n\t\t*p_tx_max = CORE_LL2_TX_MAX_BDS_PER_PACKET;\n\telse\n\t\t*p_tx_max = min_t(u8, *p_tx_max,\n\t\t\t\t  CORE_LL2_TX_MAX_BDS_PER_PACKET);\n\n\trc = qed_ll2_set_cbs(p_ll2_info, data->cbs);\n\tif (rc) {\n\t\tDP_NOTICE(p_hwfn, \"Invalid callback functions\\n\");\n\t\tgoto q_allocate_fail;\n\t}\n\n\trc = qed_ll2_acquire_connection_rx(p_hwfn, p_ll2_info);\n\tif (rc)\n\t\tgoto q_allocate_fail;\n\n\trc = qed_ll2_acquire_connection_tx(p_hwfn, p_ll2_info);\n\tif (rc)\n\t\tgoto q_allocate_fail;\n\n\trc = qed_ll2_acquire_connection_ooo(p_hwfn, p_ll2_info,\n\t\t\t\t\t    data->input.mtu);\n\tif (rc)\n\t\tgoto q_allocate_fail;\n\n\t \n\tif (data->input.conn_type == QED_LL2_TYPE_OOO) {\n\t\tcomp_rx_cb = qed_ll2_lb_rxq_completion;\n\t\tcomp_tx_cb = qed_ll2_lb_txq_completion;\n\t} else {\n\t\tcomp_rx_cb = qed_ll2_rxq_completion;\n\t\tcomp_tx_cb = qed_ll2_txq_completion;\n\t}\n\n\tif (data->input.rx_num_desc) {\n\t\tqed_int_register_cb(p_hwfn, comp_rx_cb,\n\t\t\t\t    &p_hwfn->p_ll2_info[i],\n\t\t\t\t    &p_ll2_info->rx_queue.rx_sb_index,\n\t\t\t\t    &p_ll2_info->rx_queue.p_fw_cons);\n\t\tp_ll2_info->rx_queue.b_cb_registered = true;\n\t}\n\n\tif (data->input.tx_num_desc) {\n\t\tqed_int_register_cb(p_hwfn,\n\t\t\t\t    comp_tx_cb,\n\t\t\t\t    &p_hwfn->p_ll2_info[i],\n\t\t\t\t    &p_ll2_info->tx_queue.tx_sb_index,\n\t\t\t\t    &p_ll2_info->tx_queue.p_fw_cons);\n\t\tp_ll2_info->tx_queue.b_cb_registered = true;\n\t}\n\n\t*data->p_connection_handle = i;\n\treturn rc;\n\nq_allocate_fail:\n\tqed_ll2_release_connection(p_hwfn, i);\n\treturn -ENOMEM;\n}\n\nstatic int qed_ll2_establish_connection_rx(struct qed_hwfn *p_hwfn,\n\t\t\t\t\t   struct qed_ll2_info *p_ll2_conn)\n{\n\tenum qed_ll2_error_handle error_input;\n\tenum core_error_handle error_mode;\n\tu8 action_on_error = 0;\n\tint rc;\n\n\tif (!QED_LL2_RX_REGISTERED(p_ll2_conn))\n\t\treturn 0;\n\n\tDIRECT_REG_WR(p_ll2_conn->rx_queue.set_prod_addr, 0x0);\n\terror_input = p_ll2_conn->input.ai_err_packet_too_big;\n\terror_mode = qed_ll2_get_error_choice(error_input);\n\tSET_FIELD(action_on_error,\n\t\t  CORE_RX_ACTION_ON_ERROR_PACKET_TOO_BIG, error_mode);\n\terror_input = p_ll2_conn->input.ai_err_no_buf;\n\terror_mode = qed_ll2_get_error_choice(error_input);\n\tSET_FIELD(action_on_error, CORE_RX_ACTION_ON_ERROR_NO_BUFF, error_mode);\n\n\trc = qed_sp_ll2_rx_queue_start(p_hwfn, p_ll2_conn, action_on_error);\n\tif (rc)\n\t\treturn rc;\n\n\tif (p_ll2_conn->rx_queue.ctx_based) {\n\t\trc = qed_db_recovery_add(p_hwfn->cdev,\n\t\t\t\t\t p_ll2_conn->rx_queue.set_prod_addr,\n\t\t\t\t\t &p_ll2_conn->rx_queue.db_data,\n\t\t\t\t\t DB_REC_WIDTH_64B, DB_REC_KERNEL);\n\t}\n\n\treturn rc;\n}\n\nstatic void\nqed_ll2_establish_connection_ooo(struct qed_hwfn *p_hwfn,\n\t\t\t\t struct qed_ll2_info *p_ll2_conn)\n{\n\tif (p_ll2_conn->input.conn_type != QED_LL2_TYPE_OOO)\n\t\treturn;\n\n\tqed_ooo_release_all_isles(p_hwfn, p_hwfn->p_ooo_info);\n\tqed_ooo_submit_rx_buffers(p_hwfn, p_ll2_conn);\n}\n\nstatic inline u8 qed_ll2_handle_to_queue_id(struct qed_hwfn *p_hwfn,\n\t\t\t\t\t    u8 handle,\n\t\t\t\t\t    u8 ll2_queue_type)\n{\n\tu8 qid;\n\n\tif (ll2_queue_type == QED_LL2_RX_TYPE_LEGACY)\n\t\treturn p_hwfn->hw_info.resc_start[QED_LL2_RAM_QUEUE] + handle;\n\n\t \n\tqid = p_hwfn->hw_info.resc_start[QED_LL2_CTX_QUEUE] +\n\t      MAX_NUM_LL2_RX_RAM_QUEUES;\n\n\t \n\tqid += (handle - QED_MAX_NUM_OF_LEGACY_LL2_CONNS_PF);\n\n\treturn qid;\n}\n\nint qed_ll2_establish_connection(void *cxt, u8 connection_handle)\n{\n\tstruct core_conn_context *p_cxt;\n\tstruct qed_ll2_tx_packet *p_pkt;\n\tstruct qed_ll2_info *p_ll2_conn;\n\tstruct qed_hwfn *p_hwfn = cxt;\n\tstruct qed_ll2_rx_queue *p_rx;\n\tstruct qed_ll2_tx_queue *p_tx;\n\tstruct qed_cxt_info cxt_info;\n\tstruct qed_ptt *p_ptt;\n\tint rc = -EINVAL;\n\tu32 i, capacity;\n\tsize_t desc_size;\n\tu8 qid, stats_id;\n\n\tp_ptt = qed_ptt_acquire(p_hwfn);\n\tif (!p_ptt)\n\t\treturn -EAGAIN;\n\n\tp_ll2_conn = qed_ll2_handle_sanity_lock(p_hwfn, connection_handle);\n\tif (!p_ll2_conn) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tp_rx = &p_ll2_conn->rx_queue;\n\tp_tx = &p_ll2_conn->tx_queue;\n\n\tqed_chain_reset(&p_rx->rxq_chain);\n\tqed_chain_reset(&p_rx->rcq_chain);\n\tINIT_LIST_HEAD(&p_rx->active_descq);\n\tINIT_LIST_HEAD(&p_rx->free_descq);\n\tINIT_LIST_HEAD(&p_rx->posting_descq);\n\tspin_lock_init(&p_rx->lock);\n\tcapacity = qed_chain_get_capacity(&p_rx->rxq_chain);\n\tfor (i = 0; i < capacity; i++)\n\t\tlist_add_tail(&p_rx->descq_array[i].list_entry,\n\t\t\t      &p_rx->free_descq);\n\t*p_rx->p_fw_cons = 0;\n\n\tqed_chain_reset(&p_tx->txq_chain);\n\tINIT_LIST_HEAD(&p_tx->active_descq);\n\tINIT_LIST_HEAD(&p_tx->free_descq);\n\tINIT_LIST_HEAD(&p_tx->sending_descq);\n\tspin_lock_init(&p_tx->lock);\n\tcapacity = qed_chain_get_capacity(&p_tx->txq_chain);\n\t \n\tdesc_size = struct_size(p_pkt, bds_set,\n\t\t\t\tp_ll2_conn->input.tx_max_bds_per_packet);\n\n\tfor (i = 0; i < capacity; i++) {\n\t\tp_pkt = p_tx->descq_mem + desc_size * i;\n\t\tlist_add_tail(&p_pkt->list_entry, &p_tx->free_descq);\n\t}\n\tp_tx->cur_completing_bd_idx = 0;\n\tp_tx->bds_idx = 0;\n\tp_tx->b_completing_packet = false;\n\tp_tx->cur_send_packet = NULL;\n\tp_tx->cur_send_frag_num = 0;\n\tp_tx->cur_completing_frag_num = 0;\n\t*p_tx->p_fw_cons = 0;\n\n\trc = qed_cxt_acquire_cid(p_hwfn, PROTOCOLID_CORE, &p_ll2_conn->cid);\n\tif (rc)\n\t\tgoto out;\n\tcxt_info.iid = p_ll2_conn->cid;\n\trc = qed_cxt_get_cid_info(p_hwfn, &cxt_info);\n\tif (rc) {\n\t\tDP_NOTICE(p_hwfn, \"Cannot find context info for cid=%d\\n\",\n\t\t\t  p_ll2_conn->cid);\n\t\tgoto out;\n\t}\n\n\tp_cxt = cxt_info.p_cxt;\n\n\tmemset(p_cxt, 0, sizeof(*p_cxt));\n\n\tqid = qed_ll2_handle_to_queue_id(p_hwfn, connection_handle,\n\t\t\t\t\t p_ll2_conn->input.rx_conn_type);\n\tstats_id = qed_ll2_handle_to_stats_id(p_hwfn,\n\t\t\t\t\t      p_ll2_conn->input.rx_conn_type,\n\t\t\t\t\t      qid);\n\tp_ll2_conn->queue_id = qid;\n\tp_ll2_conn->tx_stats_id = stats_id;\n\n\t \n\tif (p_ll2_conn->tx_stats_id == QED_LL2_INVALID_STATS_ID) {\n\t\tp_ll2_conn->tx_stats_en = 0;\n\t\tDP_VERBOSE(p_hwfn,\n\t\t\t   QED_MSG_LL2,\n\t\t\t   \"Disabling stats for queue %d - not enough counters\\n\",\n\t\t\t   qid);\n\t}\n\n\tDP_VERBOSE(p_hwfn,\n\t\t   QED_MSG_LL2,\n\t\t   \"Establishing ll2 queue. PF %d ctx_based=%d abs qid=%d stats_id=%d\\n\",\n\t\t   p_hwfn->rel_pf_id,\n\t\t   p_ll2_conn->input.rx_conn_type, qid, stats_id);\n\n\tif (p_ll2_conn->input.rx_conn_type == QED_LL2_RX_TYPE_LEGACY) {\n\t\tp_rx->set_prod_addr =\n\t\t    (u8 __iomem *)p_hwfn->regview +\n\t\t    GET_GTT_REG_ADDR(GTT_BAR0_MAP_REG_TSDM_RAM,\n\t\t\t\t     TSTORM_LL2_RX_PRODS, qid);\n\t} else {\n\t\t \n\t\tp_rx->ctx_based = 1;\n\n\t\tp_rx->set_prod_addr = p_hwfn->doorbells +\n\t\t\tp_hwfn->dpi_start_offset +\n\t\t\tDB_ADDR_SHIFT(DQ_PWM_OFFSET_TCM_LL2_PROD_UPDATE);\n\n\t\t \n\t\tp_rx->db_data.icid = cpu_to_le16((u16)p_ll2_conn->cid);\n\t\tSET_FIELD(p_rx->db_data.params,\n\t\t\t  CORE_PWM_PROD_UPDATE_DATA_AGG_CMD, DB_AGG_CMD_SET);\n\t\tSET_FIELD(p_rx->db_data.params,\n\t\t\t  CORE_PWM_PROD_UPDATE_DATA_RESERVED1, 0);\n\t}\n\n\tp_tx->doorbell_addr = (u8 __iomem *)p_hwfn->doorbells +\n\t\t\t\t\t    qed_db_addr(p_ll2_conn->cid,\n\t\t\t\t\t\t\tDQ_DEMS_LEGACY);\n\t \n\tSET_FIELD(p_tx->db_msg.params, CORE_DB_DATA_DEST, DB_DEST_XCM);\n\tSET_FIELD(p_tx->db_msg.params, CORE_DB_DATA_AGG_CMD, DB_AGG_CMD_SET);\n\tSET_FIELD(p_tx->db_msg.params, CORE_DB_DATA_AGG_VAL_SEL,\n\t\t  DQ_XCM_CORE_TX_BD_PROD_CMD);\n\tp_tx->db_msg.agg_flags = DQ_XCM_CORE_DQ_CF_CMD;\n\n\trc = qed_ll2_establish_connection_rx(p_hwfn, p_ll2_conn);\n\tif (rc)\n\t\tgoto out;\n\n\trc = qed_sp_ll2_tx_queue_start(p_hwfn, p_ll2_conn);\n\tif (rc)\n\t\tgoto out;\n\n\tif (!QED_IS_RDMA_PERSONALITY(p_hwfn) &&\n\t    !QED_IS_NVMETCP_PERSONALITY(p_hwfn))\n\t\tqed_wr(p_hwfn, p_ptt, PRS_REG_USE_LIGHT_L2, 1);\n\n\tqed_ll2_establish_connection_ooo(p_hwfn, p_ll2_conn);\n\n\tif (p_ll2_conn->input.conn_type == QED_LL2_TYPE_FCOE) {\n\t\tif (!test_bit(QED_MF_UFP_SPECIFIC, &p_hwfn->cdev->mf_bits))\n\t\t\tqed_llh_add_protocol_filter(p_hwfn->cdev, 0,\n\t\t\t\t\t\t    QED_LLH_FILTER_ETHERTYPE,\n\t\t\t\t\t\t    ETH_P_FCOE, 0);\n\t\tqed_llh_add_protocol_filter(p_hwfn->cdev, 0,\n\t\t\t\t\t    QED_LLH_FILTER_ETHERTYPE,\n\t\t\t\t\t    ETH_P_FIP, 0);\n\t}\n\nout:\n\tqed_ptt_release(p_hwfn, p_ptt);\n\treturn rc;\n}\n\nstatic void qed_ll2_post_rx_buffer_notify_fw(struct qed_hwfn *p_hwfn,\n\t\t\t\t\t     struct qed_ll2_rx_queue *p_rx,\n\t\t\t\t\t     struct qed_ll2_rx_packet *p_curp)\n{\n\tstruct qed_ll2_rx_packet *p_posting_packet = NULL;\n\tstruct core_ll2_rx_prod rx_prod = { 0, 0 };\n\tbool b_notify_fw = false;\n\tu16 bd_prod, cq_prod;\n\n\t \n\twhile (!list_empty(&p_rx->posting_descq)) {\n\t\tp_posting_packet = list_first_entry(&p_rx->posting_descq,\n\t\t\t\t\t\t    struct qed_ll2_rx_packet,\n\t\t\t\t\t\t    list_entry);\n\t\tlist_move_tail(&p_posting_packet->list_entry,\n\t\t\t       &p_rx->active_descq);\n\t\tb_notify_fw = true;\n\t}\n\n\t \n\tif (p_curp) {\n\t\tlist_add_tail(&p_curp->list_entry, &p_rx->active_descq);\n\t\tb_notify_fw = true;\n\t}\n\n\tif (!b_notify_fw)\n\t\treturn;\n\n\tbd_prod = qed_chain_get_prod_idx(&p_rx->rxq_chain);\n\tcq_prod = qed_chain_get_prod_idx(&p_rx->rcq_chain);\n\tif (p_rx->ctx_based) {\n\t\t \n\t\tp_rx->db_data.prod.bd_prod = cpu_to_le16(bd_prod);\n\t\tp_rx->db_data.prod.cqe_prod = cpu_to_le16(cq_prod);\n\t\t \n\t\tdma_wmb();\n\t\tDIRECT_REG_WR64(p_rx->set_prod_addr,\n\t\t\t\t*((u64 *)&p_rx->db_data));\n\t} else {\n\t\trx_prod.bd_prod = cpu_to_le16(bd_prod);\n\t\trx_prod.cqe_prod = cpu_to_le16(cq_prod);\n\n\t\t \n\t\tdma_wmb();\n\n\t\tDIRECT_REG_WR(p_rx->set_prod_addr, *((u32 *)&rx_prod));\n\t}\n}\n\nint qed_ll2_post_rx_buffer(void *cxt,\n\t\t\t   u8 connection_handle,\n\t\t\t   dma_addr_t addr,\n\t\t\t   u16 buf_len, void *cookie, u8 notify_fw)\n{\n\tstruct qed_hwfn *p_hwfn = cxt;\n\tstruct core_rx_bd_with_buff_len *p_curb = NULL;\n\tstruct qed_ll2_rx_packet *p_curp = NULL;\n\tstruct qed_ll2_info *p_ll2_conn;\n\tstruct qed_ll2_rx_queue *p_rx;\n\tunsigned long flags;\n\tvoid *p_data;\n\tint rc = 0;\n\n\tp_ll2_conn = qed_ll2_handle_sanity(p_hwfn, connection_handle);\n\tif (!p_ll2_conn)\n\t\treturn -EINVAL;\n\tp_rx = &p_ll2_conn->rx_queue;\n\tif (!p_rx->set_prod_addr)\n\t\treturn -EIO;\n\n\tspin_lock_irqsave(&p_rx->lock, flags);\n\tif (!list_empty(&p_rx->free_descq))\n\t\tp_curp = list_first_entry(&p_rx->free_descq,\n\t\t\t\t\t  struct qed_ll2_rx_packet, list_entry);\n\tif (p_curp) {\n\t\tif (qed_chain_get_elem_left(&p_rx->rxq_chain) &&\n\t\t    qed_chain_get_elem_left(&p_rx->rcq_chain)) {\n\t\t\tp_data = qed_chain_produce(&p_rx->rxq_chain);\n\t\t\tp_curb = (struct core_rx_bd_with_buff_len *)p_data;\n\t\t\tqed_chain_produce(&p_rx->rcq_chain);\n\t\t}\n\t}\n\n\t \n\tif (!p_curp || !p_curb) {\n\t\trc = -EBUSY;\n\t\tp_curp = NULL;\n\t\tgoto out_notify;\n\t}\n\n\t \n\tDMA_REGPAIR_LE(p_curb->addr, addr);\n\tp_curb->buff_length = cpu_to_le16(buf_len);\n\tp_curp->rx_buf_addr = addr;\n\tp_curp->cookie = cookie;\n\tp_curp->rxq_bd = p_curb;\n\tp_curp->buf_length = buf_len;\n\tlist_del(&p_curp->list_entry);\n\n\t \n\tif (!notify_fw) {\n\t\tlist_add_tail(&p_curp->list_entry, &p_rx->posting_descq);\n\t\tgoto out;\n\t}\n\nout_notify:\n\tqed_ll2_post_rx_buffer_notify_fw(p_hwfn, p_rx, p_curp);\nout:\n\tspin_unlock_irqrestore(&p_rx->lock, flags);\n\treturn rc;\n}\n\nstatic void qed_ll2_prepare_tx_packet_set(struct qed_hwfn *p_hwfn,\n\t\t\t\t\t  struct qed_ll2_tx_queue *p_tx,\n\t\t\t\t\t  struct qed_ll2_tx_packet *p_curp,\n\t\t\t\t\t  struct qed_ll2_tx_pkt_info *pkt,\n\t\t\t\t\t  u8 notify_fw)\n{\n\tlist_del(&p_curp->list_entry);\n\tp_curp->cookie = pkt->cookie;\n\tp_curp->bd_used = pkt->num_of_bds;\n\tp_curp->notify_fw = notify_fw;\n\tp_tx->cur_send_packet = p_curp;\n\tp_tx->cur_send_frag_num = 0;\n\n\tp_curp->bds_set[p_tx->cur_send_frag_num].tx_frag = pkt->first_frag;\n\tp_curp->bds_set[p_tx->cur_send_frag_num].frag_len = pkt->first_frag_len;\n\tp_tx->cur_send_frag_num++;\n}\n\nstatic void\nqed_ll2_prepare_tx_packet_set_bd(struct qed_hwfn *p_hwfn,\n\t\t\t\t struct qed_ll2_info *p_ll2,\n\t\t\t\t struct qed_ll2_tx_packet *p_curp,\n\t\t\t\t struct qed_ll2_tx_pkt_info *pkt)\n{\n\tstruct qed_chain *p_tx_chain = &p_ll2->tx_queue.txq_chain;\n\tu16 prod_idx = qed_chain_get_prod_idx(p_tx_chain);\n\tstruct core_tx_bd *start_bd = NULL;\n\tenum core_roce_flavor_type roce_flavor;\n\tenum core_tx_dest tx_dest;\n\tu16 bd_data = 0, frag_idx;\n\tu16 bitfield1;\n\n\troce_flavor = (pkt->qed_roce_flavor == QED_LL2_ROCE) ? CORE_ROCE\n\t\t\t\t\t\t\t     : CORE_RROCE;\n\n\tswitch (pkt->tx_dest) {\n\tcase QED_LL2_TX_DEST_NW:\n\t\ttx_dest = CORE_TX_DEST_NW;\n\t\tbreak;\n\tcase QED_LL2_TX_DEST_LB:\n\t\ttx_dest = CORE_TX_DEST_LB;\n\t\tbreak;\n\tcase QED_LL2_TX_DEST_DROP:\n\t\ttx_dest = CORE_TX_DEST_DROP;\n\t\tbreak;\n\tdefault:\n\t\ttx_dest = CORE_TX_DEST_LB;\n\t\tbreak;\n\t}\n\n\tstart_bd = (struct core_tx_bd *)qed_chain_produce(p_tx_chain);\n\tif (likely(QED_IS_IWARP_PERSONALITY(p_hwfn) &&\n\t\t   p_ll2->input.conn_type == QED_LL2_TYPE_OOO)) {\n\t\tstart_bd->nw_vlan_or_lb_echo =\n\t\t    cpu_to_le16(IWARP_LL2_IN_ORDER_TX_QUEUE);\n\t} else {\n\t\tstart_bd->nw_vlan_or_lb_echo = cpu_to_le16(pkt->vlan);\n\t\tif (test_bit(QED_MF_UFP_SPECIFIC, &p_hwfn->cdev->mf_bits) &&\n\t\t    p_ll2->input.conn_type == QED_LL2_TYPE_FCOE)\n\t\t\tpkt->remove_stag = true;\n\t}\n\n\tbitfield1 = le16_to_cpu(start_bd->bitfield1);\n\tSET_FIELD(bitfield1, CORE_TX_BD_L4_HDR_OFFSET_W, pkt->l4_hdr_offset_w);\n\tSET_FIELD(bitfield1, CORE_TX_BD_TX_DST, tx_dest);\n\tstart_bd->bitfield1 = cpu_to_le16(bitfield1);\n\n\tbd_data |= pkt->bd_flags;\n\tSET_FIELD(bd_data, CORE_TX_BD_DATA_START_BD, 0x1);\n\tSET_FIELD(bd_data, CORE_TX_BD_DATA_NBDS, pkt->num_of_bds);\n\tSET_FIELD(bd_data, CORE_TX_BD_DATA_ROCE_FLAV, roce_flavor);\n\tSET_FIELD(bd_data, CORE_TX_BD_DATA_IP_CSUM, !!(pkt->enable_ip_cksum));\n\tSET_FIELD(bd_data, CORE_TX_BD_DATA_L4_CSUM, !!(pkt->enable_l4_cksum));\n\tSET_FIELD(bd_data, CORE_TX_BD_DATA_IP_LEN, !!(pkt->calc_ip_len));\n\tSET_FIELD(bd_data, CORE_TX_BD_DATA_DISABLE_STAG_INSERTION,\n\t\t  !!(pkt->remove_stag));\n\n\tstart_bd->bd_data.as_bitfield = cpu_to_le16(bd_data);\n\tDMA_REGPAIR_LE(start_bd->addr, pkt->first_frag);\n\tstart_bd->nbytes = cpu_to_le16(pkt->first_frag_len);\n\n\tDP_VERBOSE(p_hwfn,\n\t\t   (NETIF_MSG_TX_QUEUED | QED_MSG_LL2),\n\t\t   \"LL2 [q 0x%02x cid 0x%08x type 0x%08x] Tx Producer at [0x%04x] - set with a %04x bytes %02x BDs buffer at %08x:%08x\\n\",\n\t\t   p_ll2->queue_id,\n\t\t   p_ll2->cid,\n\t\t   p_ll2->input.conn_type,\n\t\t   prod_idx,\n\t\t   pkt->first_frag_len,\n\t\t   pkt->num_of_bds,\n\t\t   le32_to_cpu(start_bd->addr.hi),\n\t\t   le32_to_cpu(start_bd->addr.lo));\n\n\tif (p_ll2->tx_queue.cur_send_frag_num == pkt->num_of_bds)\n\t\treturn;\n\n\t \n\tfor (frag_idx = p_ll2->tx_queue.cur_send_frag_num;\n\t     frag_idx < pkt->num_of_bds; frag_idx++) {\n\t\tstruct core_tx_bd **p_bd = &p_curp->bds_set[frag_idx].txq_bd;\n\n\t\t*p_bd = (struct core_tx_bd *)qed_chain_produce(p_tx_chain);\n\t\t(*p_bd)->bd_data.as_bitfield = 0;\n\t\t(*p_bd)->bitfield1 = 0;\n\t\tp_curp->bds_set[frag_idx].tx_frag = 0;\n\t\tp_curp->bds_set[frag_idx].frag_len = 0;\n\t}\n}\n\n \nstatic void qed_ll2_tx_packet_notify(struct qed_hwfn *p_hwfn,\n\t\t\t\t     struct qed_ll2_info *p_ll2_conn)\n{\n\tbool b_notify = p_ll2_conn->tx_queue.cur_send_packet->notify_fw;\n\tstruct qed_ll2_tx_queue *p_tx = &p_ll2_conn->tx_queue;\n\tstruct qed_ll2_tx_packet *p_pkt = NULL;\n\tu16 bd_prod;\n\n\t \n\tif (p_ll2_conn->tx_queue.cur_send_frag_num !=\n\t    p_ll2_conn->tx_queue.cur_send_packet->bd_used)\n\t\treturn;\n\n\t \n\tlist_add_tail(&p_ll2_conn->tx_queue.cur_send_packet->list_entry,\n\t\t      &p_ll2_conn->tx_queue.sending_descq);\n\tp_ll2_conn->tx_queue.cur_send_packet = NULL;\n\tp_ll2_conn->tx_queue.cur_send_frag_num = 0;\n\n\t \n\tif (!b_notify)\n\t\treturn;\n\n\tbd_prod = qed_chain_get_prod_idx(&p_ll2_conn->tx_queue.txq_chain);\n\n\twhile (!list_empty(&p_tx->sending_descq)) {\n\t\tp_pkt = list_first_entry(&p_tx->sending_descq,\n\t\t\t\t\t struct qed_ll2_tx_packet, list_entry);\n\t\tif (!p_pkt)\n\t\t\tbreak;\n\n\t\tlist_move_tail(&p_pkt->list_entry, &p_tx->active_descq);\n\t}\n\n\tp_tx->db_msg.spq_prod = cpu_to_le16(bd_prod);\n\n\t \n\twmb();\n\n\tDIRECT_REG_WR(p_tx->doorbell_addr, *((u32 *)&p_tx->db_msg));\n\n\tDP_VERBOSE(p_hwfn,\n\t\t   (NETIF_MSG_TX_QUEUED | QED_MSG_LL2),\n\t\t   \"LL2 [q 0x%02x cid 0x%08x type 0x%08x] Doorbelled [producer 0x%04x]\\n\",\n\t\t   p_ll2_conn->queue_id,\n\t\t   p_ll2_conn->cid,\n\t\t   p_ll2_conn->input.conn_type, p_tx->db_msg.spq_prod);\n}\n\nint qed_ll2_prepare_tx_packet(void *cxt,\n\t\t\t      u8 connection_handle,\n\t\t\t      struct qed_ll2_tx_pkt_info *pkt,\n\t\t\t      bool notify_fw)\n{\n\tstruct qed_hwfn *p_hwfn = cxt;\n\tstruct qed_ll2_tx_packet *p_curp = NULL;\n\tstruct qed_ll2_info *p_ll2_conn = NULL;\n\tstruct qed_ll2_tx_queue *p_tx;\n\tstruct qed_chain *p_tx_chain;\n\tunsigned long flags;\n\tint rc = 0;\n\n\tp_ll2_conn = qed_ll2_handle_sanity(p_hwfn, connection_handle);\n\tif (unlikely(!p_ll2_conn))\n\t\treturn -EINVAL;\n\tp_tx = &p_ll2_conn->tx_queue;\n\tp_tx_chain = &p_tx->txq_chain;\n\n\tif (unlikely(pkt->num_of_bds > p_ll2_conn->input.tx_max_bds_per_packet))\n\t\treturn -EIO;\n\n\tspin_lock_irqsave(&p_tx->lock, flags);\n\tif (unlikely(p_tx->cur_send_packet)) {\n\t\trc = -EEXIST;\n\t\tgoto out;\n\t}\n\n\t \n\tif (unlikely(!list_empty(&p_tx->free_descq)))\n\t\tp_curp = list_first_entry(&p_tx->free_descq,\n\t\t\t\t\t  struct qed_ll2_tx_packet, list_entry);\n\tif (unlikely(p_curp &&\n\t\t     qed_chain_get_elem_left(p_tx_chain) < pkt->num_of_bds))\n\t\tp_curp = NULL;\n\n\tif (unlikely(!p_curp)) {\n\t\trc = -EBUSY;\n\t\tgoto out;\n\t}\n\n\t \n\tqed_ll2_prepare_tx_packet_set(p_hwfn, p_tx, p_curp, pkt, notify_fw);\n\n\tqed_ll2_prepare_tx_packet_set_bd(p_hwfn, p_ll2_conn, p_curp, pkt);\n\n\tqed_ll2_tx_packet_notify(p_hwfn, p_ll2_conn);\n\nout:\n\tspin_unlock_irqrestore(&p_tx->lock, flags);\n\treturn rc;\n}\n\nint qed_ll2_set_fragment_of_tx_packet(void *cxt,\n\t\t\t\t      u8 connection_handle,\n\t\t\t\t      dma_addr_t addr, u16 nbytes)\n{\n\tstruct qed_ll2_tx_packet *p_cur_send_packet = NULL;\n\tstruct qed_hwfn *p_hwfn = cxt;\n\tstruct qed_ll2_info *p_ll2_conn = NULL;\n\tu16 cur_send_frag_num = 0;\n\tstruct core_tx_bd *p_bd;\n\tunsigned long flags;\n\n\tp_ll2_conn = qed_ll2_handle_sanity(p_hwfn, connection_handle);\n\tif (unlikely(!p_ll2_conn))\n\t\treturn -EINVAL;\n\n\tif (unlikely(!p_ll2_conn->tx_queue.cur_send_packet))\n\t\treturn -EINVAL;\n\n\tp_cur_send_packet = p_ll2_conn->tx_queue.cur_send_packet;\n\tcur_send_frag_num = p_ll2_conn->tx_queue.cur_send_frag_num;\n\n\tif (unlikely(cur_send_frag_num >= p_cur_send_packet->bd_used))\n\t\treturn -EINVAL;\n\n\t \n\tp_bd = p_cur_send_packet->bds_set[cur_send_frag_num].txq_bd;\n\tDMA_REGPAIR_LE(p_bd->addr, addr);\n\tp_bd->nbytes = cpu_to_le16(nbytes);\n\tp_cur_send_packet->bds_set[cur_send_frag_num].tx_frag = addr;\n\tp_cur_send_packet->bds_set[cur_send_frag_num].frag_len = nbytes;\n\n\tp_ll2_conn->tx_queue.cur_send_frag_num++;\n\n\tspin_lock_irqsave(&p_ll2_conn->tx_queue.lock, flags);\n\tqed_ll2_tx_packet_notify(p_hwfn, p_ll2_conn);\n\tspin_unlock_irqrestore(&p_ll2_conn->tx_queue.lock, flags);\n\n\treturn 0;\n}\n\nint qed_ll2_terminate_connection(void *cxt, u8 connection_handle)\n{\n\tstruct qed_hwfn *p_hwfn = cxt;\n\tstruct qed_ll2_info *p_ll2_conn = NULL;\n\tint rc = -EINVAL;\n\tstruct qed_ptt *p_ptt;\n\n\tp_ptt = qed_ptt_acquire(p_hwfn);\n\tif (!p_ptt)\n\t\treturn -EAGAIN;\n\n\tp_ll2_conn = qed_ll2_handle_sanity_lock(p_hwfn, connection_handle);\n\tif (!p_ll2_conn) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t \n\tif (QED_LL2_TX_REGISTERED(p_ll2_conn)) {\n\t\tp_ll2_conn->tx_queue.b_cb_registered = false;\n\t\tsmp_wmb();  \n\t\trc = qed_sp_ll2_tx_queue_stop(p_hwfn, p_ll2_conn);\n\t\tif (rc)\n\t\t\tgoto out;\n\n\t\tqed_ll2_txq_flush(p_hwfn, connection_handle);\n\t\tqed_int_unregister_cb(p_hwfn, p_ll2_conn->tx_queue.tx_sb_index);\n\t}\n\n\tif (QED_LL2_RX_REGISTERED(p_ll2_conn)) {\n\t\tp_ll2_conn->rx_queue.b_cb_registered = false;\n\t\tsmp_wmb();  \n\n\t\tif (p_ll2_conn->rx_queue.ctx_based)\n\t\t\tqed_db_recovery_del(p_hwfn->cdev,\n\t\t\t\t\t    p_ll2_conn->rx_queue.set_prod_addr,\n\t\t\t\t\t    &p_ll2_conn->rx_queue.db_data);\n\n\t\trc = qed_sp_ll2_rx_queue_stop(p_hwfn, p_ll2_conn);\n\t\tif (rc)\n\t\t\tgoto out;\n\n\t\tqed_ll2_rxq_flush(p_hwfn, connection_handle);\n\t\tqed_int_unregister_cb(p_hwfn, p_ll2_conn->rx_queue.rx_sb_index);\n\t}\n\n\tif (p_ll2_conn->input.conn_type == QED_LL2_TYPE_OOO)\n\t\tqed_ooo_release_all_isles(p_hwfn, p_hwfn->p_ooo_info);\n\n\tif (p_ll2_conn->input.conn_type == QED_LL2_TYPE_FCOE) {\n\t\tif (!test_bit(QED_MF_UFP_SPECIFIC, &p_hwfn->cdev->mf_bits))\n\t\t\tqed_llh_remove_protocol_filter(p_hwfn->cdev, 0,\n\t\t\t\t\t\t       QED_LLH_FILTER_ETHERTYPE,\n\t\t\t\t\t\t       ETH_P_FCOE, 0);\n\t\tqed_llh_remove_protocol_filter(p_hwfn->cdev, 0,\n\t\t\t\t\t       QED_LLH_FILTER_ETHERTYPE,\n\t\t\t\t\t       ETH_P_FIP, 0);\n\t}\n\nout:\n\tqed_ptt_release(p_hwfn, p_ptt);\n\treturn rc;\n}\n\nstatic void qed_ll2_release_connection_ooo(struct qed_hwfn *p_hwfn,\n\t\t\t\t\t   struct qed_ll2_info *p_ll2_conn)\n{\n\tstruct qed_ooo_buffer *p_buffer;\n\n\tif (p_ll2_conn->input.conn_type != QED_LL2_TYPE_OOO)\n\t\treturn;\n\n\tqed_ooo_release_all_isles(p_hwfn, p_hwfn->p_ooo_info);\n\twhile ((p_buffer = qed_ooo_get_free_buffer(p_hwfn,\n\t\t\t\t\t\t   p_hwfn->p_ooo_info))) {\n\t\tdma_free_coherent(&p_hwfn->cdev->pdev->dev,\n\t\t\t\t  p_buffer->rx_buffer_size,\n\t\t\t\t  p_buffer->rx_buffer_virt_addr,\n\t\t\t\t  p_buffer->rx_buffer_phys_addr);\n\t\tkfree(p_buffer);\n\t}\n}\n\nvoid qed_ll2_release_connection(void *cxt, u8 connection_handle)\n{\n\tstruct qed_hwfn *p_hwfn = cxt;\n\tstruct qed_ll2_info *p_ll2_conn = NULL;\n\n\tp_ll2_conn = qed_ll2_handle_sanity(p_hwfn, connection_handle);\n\tif (!p_ll2_conn)\n\t\treturn;\n\n\tkfree(p_ll2_conn->tx_queue.descq_mem);\n\tqed_chain_free(p_hwfn->cdev, &p_ll2_conn->tx_queue.txq_chain);\n\n\tkfree(p_ll2_conn->rx_queue.descq_array);\n\tqed_chain_free(p_hwfn->cdev, &p_ll2_conn->rx_queue.rxq_chain);\n\tqed_chain_free(p_hwfn->cdev, &p_ll2_conn->rx_queue.rcq_chain);\n\n\tqed_cxt_release_cid(p_hwfn, p_ll2_conn->cid);\n\n\tqed_ll2_release_connection_ooo(p_hwfn, p_ll2_conn);\n\n\tmutex_lock(&p_ll2_conn->mutex);\n\tp_ll2_conn->b_active = false;\n\tmutex_unlock(&p_ll2_conn->mutex);\n}\n\nint qed_ll2_alloc(struct qed_hwfn *p_hwfn)\n{\n\tstruct qed_ll2_info *p_ll2_connections;\n\tu8 i;\n\n\t \n\tp_ll2_connections = kcalloc(QED_MAX_NUM_OF_LL2_CONNECTIONS,\n\t\t\t\t    sizeof(struct qed_ll2_info), GFP_KERNEL);\n\tif (!p_ll2_connections) {\n\t\tDP_NOTICE(p_hwfn, \"Failed to allocate `struct qed_ll2'\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tfor (i = 0; i < QED_MAX_NUM_OF_LL2_CONNECTIONS; i++)\n\t\tp_ll2_connections[i].my_id = i;\n\n\tp_hwfn->p_ll2_info = p_ll2_connections;\n\treturn 0;\n}\n\nvoid qed_ll2_setup(struct qed_hwfn *p_hwfn)\n{\n\tint i;\n\n\tfor (i = 0; i < QED_MAX_NUM_OF_LL2_CONNECTIONS; i++)\n\t\tmutex_init(&p_hwfn->p_ll2_info[i].mutex);\n}\n\nvoid qed_ll2_free(struct qed_hwfn *p_hwfn)\n{\n\tif (!p_hwfn->p_ll2_info)\n\t\treturn;\n\n\tkfree(p_hwfn->p_ll2_info);\n\tp_hwfn->p_ll2_info = NULL;\n}\n\nstatic void _qed_ll2_get_port_stats(struct qed_hwfn *p_hwfn,\n\t\t\t\t    struct qed_ptt *p_ptt,\n\t\t\t\t    struct qed_ll2_stats *p_stats)\n{\n\tstruct core_ll2_port_stats port_stats;\n\n\tmemset(&port_stats, 0, sizeof(port_stats));\n\tqed_memcpy_from(p_hwfn, p_ptt, &port_stats,\n\t\t\tBAR0_MAP_REG_TSDM_RAM +\n\t\t\tTSTORM_LL2_PORT_STAT_OFFSET(MFW_PORT(p_hwfn)),\n\t\t\tsizeof(port_stats));\n\n\tp_stats->gsi_invalid_hdr += HILO_64_REGPAIR(port_stats.gsi_invalid_hdr);\n\tp_stats->gsi_invalid_pkt_length +=\n\t    HILO_64_REGPAIR(port_stats.gsi_invalid_pkt_length);\n\tp_stats->gsi_unsupported_pkt_typ +=\n\t    HILO_64_REGPAIR(port_stats.gsi_unsupported_pkt_typ);\n\tp_stats->gsi_crcchksm_error +=\n\t    HILO_64_REGPAIR(port_stats.gsi_crcchksm_error);\n}\n\nstatic void _qed_ll2_get_tstats(struct qed_hwfn *p_hwfn,\n\t\t\t\tstruct qed_ptt *p_ptt,\n\t\t\t\tstruct qed_ll2_info *p_ll2_conn,\n\t\t\t\tstruct qed_ll2_stats *p_stats)\n{\n\tstruct core_ll2_tstorm_per_queue_stat tstats;\n\tu8 qid = p_ll2_conn->queue_id;\n\tu32 tstats_addr;\n\n\tmemset(&tstats, 0, sizeof(tstats));\n\ttstats_addr = BAR0_MAP_REG_TSDM_RAM +\n\t\t      CORE_LL2_TSTORM_PER_QUEUE_STAT_OFFSET(qid);\n\tqed_memcpy_from(p_hwfn, p_ptt, &tstats, tstats_addr, sizeof(tstats));\n\n\tp_stats->packet_too_big_discard +=\n\t\t\tHILO_64_REGPAIR(tstats.packet_too_big_discard);\n\tp_stats->no_buff_discard += HILO_64_REGPAIR(tstats.no_buff_discard);\n}\n\nstatic void _qed_ll2_get_ustats(struct qed_hwfn *p_hwfn,\n\t\t\t\tstruct qed_ptt *p_ptt,\n\t\t\t\tstruct qed_ll2_info *p_ll2_conn,\n\t\t\t\tstruct qed_ll2_stats *p_stats)\n{\n\tstruct core_ll2_ustorm_per_queue_stat ustats;\n\tu8 qid = p_ll2_conn->queue_id;\n\tu32 ustats_addr;\n\n\tmemset(&ustats, 0, sizeof(ustats));\n\tustats_addr = BAR0_MAP_REG_USDM_RAM +\n\t\t      CORE_LL2_USTORM_PER_QUEUE_STAT_OFFSET(qid);\n\tqed_memcpy_from(p_hwfn, p_ptt, &ustats, ustats_addr, sizeof(ustats));\n\n\tp_stats->rcv_ucast_bytes += HILO_64_REGPAIR(ustats.rcv_ucast_bytes);\n\tp_stats->rcv_mcast_bytes += HILO_64_REGPAIR(ustats.rcv_mcast_bytes);\n\tp_stats->rcv_bcast_bytes += HILO_64_REGPAIR(ustats.rcv_bcast_bytes);\n\tp_stats->rcv_ucast_pkts += HILO_64_REGPAIR(ustats.rcv_ucast_pkts);\n\tp_stats->rcv_mcast_pkts += HILO_64_REGPAIR(ustats.rcv_mcast_pkts);\n\tp_stats->rcv_bcast_pkts += HILO_64_REGPAIR(ustats.rcv_bcast_pkts);\n}\n\nstatic void _qed_ll2_get_pstats(struct qed_hwfn *p_hwfn,\n\t\t\t\tstruct qed_ptt *p_ptt,\n\t\t\t\tstruct qed_ll2_info *p_ll2_conn,\n\t\t\t\tstruct qed_ll2_stats *p_stats)\n{\n\tstruct core_ll2_pstorm_per_queue_stat pstats;\n\tu8 stats_id = p_ll2_conn->tx_stats_id;\n\tu32 pstats_addr;\n\n\tmemset(&pstats, 0, sizeof(pstats));\n\tpstats_addr = BAR0_MAP_REG_PSDM_RAM +\n\t\t      CORE_LL2_PSTORM_PER_QUEUE_STAT_OFFSET(stats_id);\n\tqed_memcpy_from(p_hwfn, p_ptt, &pstats, pstats_addr, sizeof(pstats));\n\n\tp_stats->sent_ucast_bytes += HILO_64_REGPAIR(pstats.sent_ucast_bytes);\n\tp_stats->sent_mcast_bytes += HILO_64_REGPAIR(pstats.sent_mcast_bytes);\n\tp_stats->sent_bcast_bytes += HILO_64_REGPAIR(pstats.sent_bcast_bytes);\n\tp_stats->sent_ucast_pkts += HILO_64_REGPAIR(pstats.sent_ucast_pkts);\n\tp_stats->sent_mcast_pkts += HILO_64_REGPAIR(pstats.sent_mcast_pkts);\n\tp_stats->sent_bcast_pkts += HILO_64_REGPAIR(pstats.sent_bcast_pkts);\n}\n\nstatic int __qed_ll2_get_stats(void *cxt, u8 connection_handle,\n\t\t\t       struct qed_ll2_stats *p_stats)\n{\n\tstruct qed_hwfn *p_hwfn = cxt;\n\tstruct qed_ll2_info *p_ll2_conn = NULL;\n\tstruct qed_ptt *p_ptt;\n\n\tif ((connection_handle >= QED_MAX_NUM_OF_LL2_CONNECTIONS) ||\n\t    !p_hwfn->p_ll2_info)\n\t\treturn -EINVAL;\n\n\tp_ll2_conn = &p_hwfn->p_ll2_info[connection_handle];\n\n\tp_ptt = qed_ptt_acquire(p_hwfn);\n\tif (!p_ptt) {\n\t\tDP_ERR(p_hwfn, \"Failed to acquire ptt\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (p_ll2_conn->input.gsi_enable)\n\t\t_qed_ll2_get_port_stats(p_hwfn, p_ptt, p_stats);\n\n\t_qed_ll2_get_tstats(p_hwfn, p_ptt, p_ll2_conn, p_stats);\n\n\t_qed_ll2_get_ustats(p_hwfn, p_ptt, p_ll2_conn, p_stats);\n\n\tif (p_ll2_conn->tx_stats_en)\n\t\t_qed_ll2_get_pstats(p_hwfn, p_ptt, p_ll2_conn, p_stats);\n\n\tqed_ptt_release(p_hwfn, p_ptt);\n\n\treturn 0;\n}\n\nint qed_ll2_get_stats(void *cxt,\n\t\t      u8 connection_handle, struct qed_ll2_stats *p_stats)\n{\n\tmemset(p_stats, 0, sizeof(*p_stats));\n\treturn __qed_ll2_get_stats(cxt, connection_handle, p_stats);\n}\n\nstatic void qed_ll2b_release_rx_packet(void *cxt,\n\t\t\t\t       u8 connection_handle,\n\t\t\t\t       void *cookie,\n\t\t\t\t       dma_addr_t rx_buf_addr,\n\t\t\t\t       bool b_last_packet)\n{\n\tstruct qed_hwfn *p_hwfn = cxt;\n\n\tqed_ll2_dealloc_buffer(p_hwfn->cdev, cookie);\n}\n\nstatic void qed_ll2_register_cb_ops(struct qed_dev *cdev,\n\t\t\t\t    const struct qed_ll2_cb_ops *ops,\n\t\t\t\t    void *cookie)\n{\n\tcdev->ll2->cbs = ops;\n\tcdev->ll2->cb_cookie = cookie;\n}\n\nstatic struct qed_ll2_cbs ll2_cbs = {\n\t.rx_comp_cb = &qed_ll2b_complete_rx_packet,\n\t.rx_release_cb = &qed_ll2b_release_rx_packet,\n\t.tx_comp_cb = &qed_ll2b_complete_tx_packet,\n\t.tx_release_cb = &qed_ll2b_complete_tx_packet,\n};\n\nstatic void qed_ll2_set_conn_data(struct qed_hwfn *p_hwfn,\n\t\t\t\t  struct qed_ll2_acquire_data *data,\n\t\t\t\t  struct qed_ll2_params *params,\n\t\t\t\t  enum qed_ll2_conn_type conn_type,\n\t\t\t\t  u8 *handle, bool lb)\n{\n\tmemset(data, 0, sizeof(*data));\n\n\tdata->input.conn_type = conn_type;\n\tdata->input.mtu = params->mtu;\n\tdata->input.rx_num_desc = QED_LL2_RX_SIZE;\n\tdata->input.rx_drop_ttl0_flg = params->drop_ttl0_packets;\n\tdata->input.rx_vlan_removal_en = params->rx_vlan_stripping;\n\tdata->input.tx_num_desc = QED_LL2_TX_SIZE;\n\tdata->p_connection_handle = handle;\n\tdata->cbs = &ll2_cbs;\n\tll2_cbs.cookie = p_hwfn;\n\n\tif (lb) {\n\t\tdata->input.tx_tc = PKT_LB_TC;\n\t\tdata->input.tx_dest = QED_LL2_TX_DEST_LB;\n\t} else {\n\t\tdata->input.tx_tc = 0;\n\t\tdata->input.tx_dest = QED_LL2_TX_DEST_NW;\n\t}\n}\n\nstatic int qed_ll2_start_ooo(struct qed_hwfn *p_hwfn,\n\t\t\t     struct qed_ll2_params *params)\n{\n\tu8 *handle = &p_hwfn->pf_params.iscsi_pf_params.ll2_ooo_queue_id;\n\tstruct qed_ll2_acquire_data data;\n\tint rc;\n\n\tqed_ll2_set_conn_data(p_hwfn, &data, params,\n\t\t\t      QED_LL2_TYPE_OOO, handle, true);\n\n\trc = qed_ll2_acquire_connection(p_hwfn, &data);\n\tif (rc) {\n\t\tDP_INFO(p_hwfn, \"Failed to acquire LL2 OOO connection\\n\");\n\t\tgoto out;\n\t}\n\n\trc = qed_ll2_establish_connection(p_hwfn, *handle);\n\tif (rc) {\n\t\tDP_INFO(p_hwfn, \"Failed to establish LL2 OOO connection\\n\");\n\t\tgoto fail;\n\t}\n\n\treturn 0;\n\nfail:\n\tqed_ll2_release_connection(p_hwfn, *handle);\nout:\n\t*handle = QED_LL2_UNUSED_HANDLE;\n\treturn rc;\n}\n\nstatic bool qed_ll2_is_storage_eng1(struct qed_dev *cdev)\n{\n\treturn (QED_IS_FCOE_PERSONALITY(QED_LEADING_HWFN(cdev)) ||\n\t\tQED_IS_ISCSI_PERSONALITY(QED_LEADING_HWFN(cdev)) ||\n\t\tQED_IS_NVMETCP_PERSONALITY(QED_LEADING_HWFN(cdev))) &&\n\t\t(QED_AFFIN_HWFN(cdev) != QED_LEADING_HWFN(cdev));\n}\n\nstatic int __qed_ll2_stop(struct qed_hwfn *p_hwfn)\n{\n\tstruct qed_dev *cdev = p_hwfn->cdev;\n\tint rc;\n\n\trc = qed_ll2_terminate_connection(p_hwfn, cdev->ll2->handle);\n\tif (rc)\n\t\tDP_INFO(cdev, \"Failed to terminate LL2 connection\\n\");\n\n\tqed_ll2_release_connection(p_hwfn, cdev->ll2->handle);\n\n\treturn rc;\n}\n\nstatic int qed_ll2_stop(struct qed_dev *cdev)\n{\n\tbool b_is_storage_eng1 = qed_ll2_is_storage_eng1(cdev);\n\tstruct qed_hwfn *p_hwfn = QED_AFFIN_HWFN(cdev);\n\tint rc = 0, rc2 = 0;\n\n\tif (cdev->ll2->handle == QED_LL2_UNUSED_HANDLE)\n\t\treturn 0;\n\tif (!QED_IS_NVMETCP_PERSONALITY(p_hwfn))\n\t\tqed_llh_remove_mac_filter(cdev, 0, cdev->ll2_mac_address);\n\n\tqed_llh_remove_mac_filter(cdev, 0, cdev->ll2_mac_address);\n\teth_zero_addr(cdev->ll2_mac_address);\n\n\tif (QED_IS_ISCSI_PERSONALITY(p_hwfn) || QED_IS_NVMETCP_PERSONALITY(p_hwfn))\n\t\tqed_ll2_stop_ooo(p_hwfn);\n\n\t \n\tif (b_is_storage_eng1) {\n\t\trc2 = __qed_ll2_stop(QED_LEADING_HWFN(cdev));\n\t\tif (rc2)\n\t\t\tDP_NOTICE(QED_LEADING_HWFN(cdev),\n\t\t\t\t  \"Failed to stop LL2 on engine 0\\n\");\n\t}\n\n\trc = __qed_ll2_stop(p_hwfn);\n\tif (rc)\n\t\tDP_NOTICE(p_hwfn, \"Failed to stop LL2\\n\");\n\n\tqed_ll2_kill_buffers(cdev);\n\n\tcdev->ll2->handle = QED_LL2_UNUSED_HANDLE;\n\n\treturn rc | rc2;\n}\n\nstatic int __qed_ll2_start(struct qed_hwfn *p_hwfn,\n\t\t\t   struct qed_ll2_params *params)\n{\n\tstruct qed_ll2_buffer *buffer, *tmp_buffer;\n\tstruct qed_dev *cdev = p_hwfn->cdev;\n\tenum qed_ll2_conn_type conn_type;\n\tstruct qed_ll2_acquire_data data;\n\tint rc, rx_cnt;\n\n\tswitch (p_hwfn->hw_info.personality) {\n\tcase QED_PCI_FCOE:\n\t\tconn_type = QED_LL2_TYPE_FCOE;\n\t\tbreak;\n\tcase QED_PCI_ISCSI:\n\tcase QED_PCI_NVMETCP:\n\t\tconn_type = QED_LL2_TYPE_TCP_ULP;\n\t\tbreak;\n\tcase QED_PCI_ETH_ROCE:\n\t\tconn_type = QED_LL2_TYPE_ROCE;\n\t\tbreak;\n\tdefault:\n\n\t\tconn_type = QED_LL2_TYPE_TEST;\n\t}\n\n\tqed_ll2_set_conn_data(p_hwfn, &data, params, conn_type,\n\t\t\t      &cdev->ll2->handle, false);\n\n\trc = qed_ll2_acquire_connection(p_hwfn, &data);\n\tif (rc) {\n\t\tDP_INFO(p_hwfn, \"Failed to acquire LL2 connection\\n\");\n\t\treturn rc;\n\t}\n\n\trc = qed_ll2_establish_connection(p_hwfn, cdev->ll2->handle);\n\tif (rc) {\n\t\tDP_INFO(p_hwfn, \"Failed to establish LL2 connection\\n\");\n\t\tgoto release_conn;\n\t}\n\n\t \n\tspin_lock_bh(&cdev->ll2->lock);\n\trx_cnt = cdev->ll2->rx_cnt;\n\tlist_for_each_entry_safe(buffer, tmp_buffer, &cdev->ll2->list, list) {\n\t\trc = qed_ll2_post_rx_buffer(p_hwfn,\n\t\t\t\t\t    cdev->ll2->handle,\n\t\t\t\t\t    buffer->phys_addr, 0, buffer, 1);\n\t\tif (rc) {\n\t\t\tDP_INFO(p_hwfn,\n\t\t\t\t\"Failed to post an Rx buffer; Deleting it\\n\");\n\t\t\tdma_unmap_single(&cdev->pdev->dev, buffer->phys_addr,\n\t\t\t\t\t cdev->ll2->rx_size, DMA_FROM_DEVICE);\n\t\t\tkfree(buffer->data);\n\t\t\tlist_del(&buffer->list);\n\t\t\tkfree(buffer);\n\t\t} else {\n\t\t\trx_cnt++;\n\t\t}\n\t}\n\tspin_unlock_bh(&cdev->ll2->lock);\n\n\tif (rx_cnt == cdev->ll2->rx_cnt) {\n\t\tDP_NOTICE(p_hwfn, \"Failed passing even a single Rx buffer\\n\");\n\t\tgoto terminate_conn;\n\t}\n\tcdev->ll2->rx_cnt = rx_cnt;\n\n\treturn 0;\n\nterminate_conn:\n\tqed_ll2_terminate_connection(p_hwfn, cdev->ll2->handle);\nrelease_conn:\n\tqed_ll2_release_connection(p_hwfn, cdev->ll2->handle);\n\treturn rc;\n}\n\nstatic int qed_ll2_start(struct qed_dev *cdev, struct qed_ll2_params *params)\n{\n\tbool b_is_storage_eng1 = qed_ll2_is_storage_eng1(cdev);\n\tstruct qed_hwfn *p_hwfn = QED_AFFIN_HWFN(cdev);\n\tstruct qed_ll2_buffer *buffer;\n\tint rx_num_desc, i, rc;\n\n\tif (!is_valid_ether_addr(params->ll2_mac_address)) {\n\t\tDP_NOTICE(cdev, \"Invalid Ethernet address\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tWARN_ON(!cdev->ll2->cbs);\n\n\t \n\tINIT_LIST_HEAD(&cdev->ll2->list);\n\tspin_lock_init(&cdev->ll2->lock);\n\n\tcdev->ll2->rx_size = PRM_DMA_PAD_BYTES_NUM + ETH_HLEN +\n\t\t\t     L1_CACHE_BYTES + params->mtu;\n\n\t \n\trx_num_desc = QED_LL2_RX_SIZE * (b_is_storage_eng1 ? 2 : 1);\n\tDP_INFO(cdev, \"Allocating %d LL2 buffers of size %08x bytes\\n\",\n\t\trx_num_desc, cdev->ll2->rx_size);\n\tfor (i = 0; i < rx_num_desc; i++) {\n\t\tbuffer = kzalloc(sizeof(*buffer), GFP_KERNEL);\n\t\tif (!buffer) {\n\t\t\tDP_INFO(cdev, \"Failed to allocate LL2 buffers\\n\");\n\t\t\trc = -ENOMEM;\n\t\t\tgoto err0;\n\t\t}\n\n\t\trc = qed_ll2_alloc_buffer(cdev, (u8 **)&buffer->data,\n\t\t\t\t\t  &buffer->phys_addr);\n\t\tif (rc) {\n\t\t\tkfree(buffer);\n\t\t\tgoto err0;\n\t\t}\n\n\t\tlist_add_tail(&buffer->list, &cdev->ll2->list);\n\t}\n\n\trc = __qed_ll2_start(p_hwfn, params);\n\tif (rc) {\n\t\tDP_NOTICE(cdev, \"Failed to start LL2\\n\");\n\t\tgoto err0;\n\t}\n\n\t \n\tif (b_is_storage_eng1) {\n\t\trc = __qed_ll2_start(QED_LEADING_HWFN(cdev), params);\n\t\tif (rc) {\n\t\t\tDP_NOTICE(QED_LEADING_HWFN(cdev),\n\t\t\t\t  \"Failed to start LL2 on engine 0\\n\");\n\t\t\tgoto err1;\n\t\t}\n\t}\n\n\tif (QED_IS_ISCSI_PERSONALITY(p_hwfn) || QED_IS_NVMETCP_PERSONALITY(p_hwfn)) {\n\t\tDP_VERBOSE(cdev, QED_MSG_STORAGE, \"Starting OOO LL2 queue\\n\");\n\t\trc = qed_ll2_start_ooo(p_hwfn, params);\n\t\tif (rc) {\n\t\t\tDP_NOTICE(cdev, \"Failed to start OOO LL2\\n\");\n\t\t\tgoto err2;\n\t\t}\n\t}\n\n\tif (!QED_IS_NVMETCP_PERSONALITY(p_hwfn)) {\n\t\trc = qed_llh_add_mac_filter(cdev, 0, params->ll2_mac_address);\n\t\tif (rc) {\n\t\t\tDP_NOTICE(cdev, \"Failed to add an LLH filter\\n\");\n\t\t\tgoto err3;\n\t\t}\n\t}\n\n\tether_addr_copy(cdev->ll2_mac_address, params->ll2_mac_address);\n\n\treturn 0;\n\nerr3:\n\tif (QED_IS_ISCSI_PERSONALITY(p_hwfn) || QED_IS_NVMETCP_PERSONALITY(p_hwfn))\n\t\tqed_ll2_stop_ooo(p_hwfn);\nerr2:\n\tif (b_is_storage_eng1)\n\t\t__qed_ll2_stop(QED_LEADING_HWFN(cdev));\nerr1:\n\t__qed_ll2_stop(p_hwfn);\nerr0:\n\tqed_ll2_kill_buffers(cdev);\n\tcdev->ll2->handle = QED_LL2_UNUSED_HANDLE;\n\treturn rc;\n}\n\nstatic int qed_ll2_start_xmit(struct qed_dev *cdev, struct sk_buff *skb,\n\t\t\t      unsigned long xmit_flags)\n{\n\tstruct qed_hwfn *p_hwfn = QED_AFFIN_HWFN(cdev);\n\tstruct qed_ll2_tx_pkt_info pkt;\n\tconst skb_frag_t *frag;\n\tu8 flags = 0, nr_frags;\n\tint rc = -EINVAL, i;\n\tdma_addr_t mapping;\n\tu16 vlan = 0;\n\n\tif (unlikely(skb->ip_summed != CHECKSUM_NONE)) {\n\t\tDP_INFO(cdev, \"Cannot transmit a checksummed packet\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tnr_frags = skb_shinfo(skb)->nr_frags;\n\n\tif (unlikely(1 + nr_frags > CORE_LL2_TX_MAX_BDS_PER_PACKET)) {\n\t\tDP_ERR(cdev, \"Cannot transmit a packet with %d fragments\\n\",\n\t\t       1 + nr_frags);\n\t\treturn -EINVAL;\n\t}\n\n\tmapping = dma_map_single(&cdev->pdev->dev, skb->data,\n\t\t\t\t skb->len, DMA_TO_DEVICE);\n\tif (unlikely(dma_mapping_error(&cdev->pdev->dev, mapping))) {\n\t\tDP_NOTICE(cdev, \"SKB mapping failed\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (!((vlan_get_protocol(skb) == htons(ETH_P_IPV6)) &&\n\t      ipv6_hdr(skb)->nexthdr == NEXTHDR_IPV6))\n\t\tflags |= BIT(CORE_TX_BD_DATA_IP_CSUM_SHIFT);\n\n\tif (skb_vlan_tag_present(skb)) {\n\t\tvlan = skb_vlan_tag_get(skb);\n\t\tflags |= BIT(CORE_TX_BD_DATA_VLAN_INSERTION_SHIFT);\n\t}\n\n\tmemset(&pkt, 0, sizeof(pkt));\n\tpkt.num_of_bds = 1 + nr_frags;\n\tpkt.vlan = vlan;\n\tpkt.bd_flags = flags;\n\tpkt.tx_dest = QED_LL2_TX_DEST_NW;\n\tpkt.first_frag = mapping;\n\tpkt.first_frag_len = skb->len;\n\tpkt.cookie = skb;\n\tif (test_bit(QED_MF_UFP_SPECIFIC, &cdev->mf_bits) &&\n\t    test_bit(QED_LL2_XMIT_FLAGS_FIP_DISCOVERY, &xmit_flags))\n\t\tpkt.remove_stag = true;\n\n\t \n\trc = qed_ll2_prepare_tx_packet(p_hwfn, cdev->ll2->handle,\n\t\t\t\t       &pkt, 1);\n\tif (unlikely(rc))\n\t\tgoto err;\n\n\tfor (i = 0; i < nr_frags; i++) {\n\t\tfrag = &skb_shinfo(skb)->frags[i];\n\n\t\tmapping = skb_frag_dma_map(&cdev->pdev->dev, frag, 0,\n\t\t\t\t\t   skb_frag_size(frag), DMA_TO_DEVICE);\n\n\t\tif (unlikely(dma_mapping_error(&cdev->pdev->dev, mapping))) {\n\t\t\tDP_NOTICE(cdev,\n\t\t\t\t  \"Unable to map frag - dropping packet\\n\");\n\t\t\trc = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\n\t\trc = qed_ll2_set_fragment_of_tx_packet(p_hwfn,\n\t\t\t\t\t\t       cdev->ll2->handle,\n\t\t\t\t\t\t       mapping,\n\t\t\t\t\t\t       skb_frag_size(frag));\n\n\t\t \n\t\tif (unlikely(rc))\n\t\t\tgoto err2;\n\t}\n\n\treturn 0;\n\nerr:\n\tdma_unmap_single(&cdev->pdev->dev, mapping, skb->len, DMA_TO_DEVICE);\nerr2:\n\treturn rc;\n}\n\nstatic int qed_ll2_stats(struct qed_dev *cdev, struct qed_ll2_stats *stats)\n{\n\tbool b_is_storage_eng1 = qed_ll2_is_storage_eng1(cdev);\n\tstruct qed_hwfn *p_hwfn = QED_AFFIN_HWFN(cdev);\n\tint rc;\n\n\tif (!cdev->ll2)\n\t\treturn -EINVAL;\n\n\trc = qed_ll2_get_stats(p_hwfn, cdev->ll2->handle, stats);\n\tif (rc) {\n\t\tDP_NOTICE(p_hwfn, \"Failed to get LL2 stats\\n\");\n\t\treturn rc;\n\t}\n\n\t \n\tif (b_is_storage_eng1) {\n\t\trc = __qed_ll2_get_stats(QED_LEADING_HWFN(cdev),\n\t\t\t\t\t cdev->ll2->handle, stats);\n\t\tif (rc) {\n\t\t\tDP_NOTICE(QED_LEADING_HWFN(cdev),\n\t\t\t\t  \"Failed to get LL2 stats on engine 0\\n\");\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nconst struct qed_ll2_ops qed_ll2_ops_pass = {\n\t.start = &qed_ll2_start,\n\t.stop = &qed_ll2_stop,\n\t.start_xmit = &qed_ll2_start_xmit,\n\t.register_cb_ops = &qed_ll2_register_cb_ops,\n\t.get_stats = &qed_ll2_stats,\n};\n\nint qed_ll2_alloc_if(struct qed_dev *cdev)\n{\n\tcdev->ll2 = kzalloc(sizeof(*cdev->ll2), GFP_KERNEL);\n\treturn cdev->ll2 ? 0 : -ENOMEM;\n}\n\nvoid qed_ll2_dealloc_if(struct qed_dev *cdev)\n{\n\tkfree(cdev->ll2);\n\tcdev->ll2 = NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}