{
  "module_name": "qed_hw.c",
  "hash_id": "9560d3a1f8dccb36f6a77718bf3e2077814b7320023a4bb5018222c9ca02f04c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/qlogic/qed/qed_hw.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/io.h>\n#include <linux/delay.h>\n#include <linux/dma-mapping.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/pci.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/qed/qed_chain.h>\n#include \"qed.h\"\n#include \"qed_hsi.h\"\n#include \"qed_hw.h\"\n#include \"qed_reg_addr.h\"\n#include \"qed_sriov.h\"\n\n#define QED_BAR_ACQUIRE_TIMEOUT_USLEEP_CNT\t1000\n#define QED_BAR_ACQUIRE_TIMEOUT_USLEEP\t\t1000\n#define QED_BAR_ACQUIRE_TIMEOUT_UDELAY_CNT\t100000\n#define QED_BAR_ACQUIRE_TIMEOUT_UDELAY\t\t10\n\n \n#define QED_BAR_INVALID_OFFSET          (cpu_to_le32(-1))\n\nstruct qed_ptt {\n\tstruct list_head\tlist_entry;\n\tunsigned int\t\tidx;\n\tstruct pxp_ptt_entry\tpxp;\n\tu8\t\t\thwfn_id;\n};\n\nstruct qed_ptt_pool {\n\tstruct list_head\tfree_list;\n\tspinlock_t\t\tlock;  \n\tstruct qed_ptt\t\tptts[PXP_EXTERNAL_BAR_PF_WINDOW_NUM];\n};\n\nint qed_ptt_pool_alloc(struct qed_hwfn *p_hwfn)\n{\n\tstruct qed_ptt_pool *p_pool = kmalloc(sizeof(*p_pool), GFP_KERNEL);\n\tint i;\n\n\tif (!p_pool)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&p_pool->free_list);\n\tfor (i = 0; i < PXP_EXTERNAL_BAR_PF_WINDOW_NUM; i++) {\n\t\tp_pool->ptts[i].idx = i;\n\t\tp_pool->ptts[i].pxp.offset = QED_BAR_INVALID_OFFSET;\n\t\tp_pool->ptts[i].pxp.pretend.control = 0;\n\t\tp_pool->ptts[i].hwfn_id = p_hwfn->my_id;\n\t\tif (i >= RESERVED_PTT_MAX)\n\t\t\tlist_add(&p_pool->ptts[i].list_entry,\n\t\t\t\t &p_pool->free_list);\n\t}\n\n\tp_hwfn->p_ptt_pool = p_pool;\n\tspin_lock_init(&p_pool->lock);\n\n\treturn 0;\n}\n\nvoid qed_ptt_invalidate(struct qed_hwfn *p_hwfn)\n{\n\tstruct qed_ptt *p_ptt;\n\tint i;\n\n\tfor (i = 0; i < PXP_EXTERNAL_BAR_PF_WINDOW_NUM; i++) {\n\t\tp_ptt = &p_hwfn->p_ptt_pool->ptts[i];\n\t\tp_ptt->pxp.offset = QED_BAR_INVALID_OFFSET;\n\t}\n}\n\nvoid qed_ptt_pool_free(struct qed_hwfn *p_hwfn)\n{\n\tkfree(p_hwfn->p_ptt_pool);\n\tp_hwfn->p_ptt_pool = NULL;\n}\n\nstruct qed_ptt *qed_ptt_acquire(struct qed_hwfn *p_hwfn)\n{\n\treturn qed_ptt_acquire_context(p_hwfn, false);\n}\n\nstruct qed_ptt *qed_ptt_acquire_context(struct qed_hwfn *p_hwfn, bool is_atomic)\n{\n\tstruct qed_ptt *p_ptt;\n\tunsigned int i, count;\n\n\tif (is_atomic)\n\t\tcount = QED_BAR_ACQUIRE_TIMEOUT_UDELAY_CNT;\n\telse\n\t\tcount = QED_BAR_ACQUIRE_TIMEOUT_USLEEP_CNT;\n\n\t \n\tfor (i = 0; i < count; i++) {\n\t\tspin_lock_bh(&p_hwfn->p_ptt_pool->lock);\n\n\t\tif (!list_empty(&p_hwfn->p_ptt_pool->free_list)) {\n\t\t\tp_ptt = list_first_entry(&p_hwfn->p_ptt_pool->free_list,\n\t\t\t\t\t\t struct qed_ptt, list_entry);\n\t\t\tlist_del(&p_ptt->list_entry);\n\n\t\t\tspin_unlock_bh(&p_hwfn->p_ptt_pool->lock);\n\n\t\t\tDP_VERBOSE(p_hwfn, NETIF_MSG_HW,\n\t\t\t\t   \"allocated ptt %d\\n\", p_ptt->idx);\n\t\t\treturn p_ptt;\n\t\t}\n\n\t\tspin_unlock_bh(&p_hwfn->p_ptt_pool->lock);\n\n\t\tif (is_atomic)\n\t\t\tudelay(QED_BAR_ACQUIRE_TIMEOUT_UDELAY);\n\t\telse\n\t\t\tusleep_range(QED_BAR_ACQUIRE_TIMEOUT_USLEEP,\n\t\t\t\t     QED_BAR_ACQUIRE_TIMEOUT_USLEEP * 2);\n\t}\n\n\tDP_NOTICE(p_hwfn, \"PTT acquire timeout - failed to allocate PTT\\n\");\n\treturn NULL;\n}\n\nvoid qed_ptt_release(struct qed_hwfn *p_hwfn, struct qed_ptt *p_ptt)\n{\n\tspin_lock_bh(&p_hwfn->p_ptt_pool->lock);\n\tlist_add(&p_ptt->list_entry, &p_hwfn->p_ptt_pool->free_list);\n\tspin_unlock_bh(&p_hwfn->p_ptt_pool->lock);\n}\n\nu32 qed_ptt_get_hw_addr(struct qed_hwfn *p_hwfn, struct qed_ptt *p_ptt)\n{\n\t \n\treturn le32_to_cpu(p_ptt->pxp.offset) << 2;\n}\n\nstatic u32 qed_ptt_config_addr(struct qed_ptt *p_ptt)\n{\n\treturn PXP_PF_WINDOW_ADMIN_PER_PF_START +\n\t       p_ptt->idx * sizeof(struct pxp_ptt_entry);\n}\n\nu32 qed_ptt_get_bar_addr(struct qed_ptt *p_ptt)\n{\n\treturn PXP_EXTERNAL_BAR_PF_WINDOW_START +\n\t       p_ptt->idx * PXP_EXTERNAL_BAR_PF_WINDOW_SINGLE_SIZE;\n}\n\nvoid qed_ptt_set_win(struct qed_hwfn *p_hwfn,\n\t\t     struct qed_ptt *p_ptt, u32 new_hw_addr)\n{\n\tu32 prev_hw_addr;\n\n\tprev_hw_addr = qed_ptt_get_hw_addr(p_hwfn, p_ptt);\n\n\tif (new_hw_addr == prev_hw_addr)\n\t\treturn;\n\n\t \n\tDP_VERBOSE(p_hwfn, NETIF_MSG_HW,\n\t\t   \"Updating PTT entry %d to offset 0x%x\\n\",\n\t\t   p_ptt->idx, new_hw_addr);\n\n\t \n\tp_ptt->pxp.offset = cpu_to_le32(new_hw_addr >> 2);\n\n\tREG_WR(p_hwfn,\n\t       qed_ptt_config_addr(p_ptt) +\n\t       offsetof(struct pxp_ptt_entry, offset),\n\t       le32_to_cpu(p_ptt->pxp.offset));\n}\n\nstatic u32 qed_set_ptt(struct qed_hwfn *p_hwfn,\n\t\t       struct qed_ptt *p_ptt, u32 hw_addr)\n{\n\tu32 win_hw_addr = qed_ptt_get_hw_addr(p_hwfn, p_ptt);\n\tu32 offset;\n\n\toffset = hw_addr - win_hw_addr;\n\n\tif (p_ptt->hwfn_id != p_hwfn->my_id)\n\t\tDP_NOTICE(p_hwfn,\n\t\t\t  \"ptt[%d] of hwfn[%02x] is used by hwfn[%02x]!\\n\",\n\t\t\t  p_ptt->idx, p_ptt->hwfn_id, p_hwfn->my_id);\n\n\t \n\tif (hw_addr < win_hw_addr ||\n\t    offset >= PXP_EXTERNAL_BAR_PF_WINDOW_SINGLE_SIZE) {\n\t\tqed_ptt_set_win(p_hwfn, p_ptt, hw_addr);\n\t\toffset = 0;\n\t}\n\n\treturn qed_ptt_get_bar_addr(p_ptt) + offset;\n}\n\nstruct qed_ptt *qed_get_reserved_ptt(struct qed_hwfn *p_hwfn,\n\t\t\t\t     enum reserved_ptts ptt_idx)\n{\n\tif (ptt_idx >= RESERVED_PTT_MAX) {\n\t\tDP_NOTICE(p_hwfn,\n\t\t\t  \"Requested PTT %d is out of range\\n\", ptt_idx);\n\t\treturn NULL;\n\t}\n\n\treturn &p_hwfn->p_ptt_pool->ptts[ptt_idx];\n}\n\nvoid qed_wr(struct qed_hwfn *p_hwfn,\n\t    struct qed_ptt *p_ptt,\n\t    u32 hw_addr, u32 val)\n{\n\tu32 bar_addr = qed_set_ptt(p_hwfn, p_ptt, hw_addr);\n\n\tREG_WR(p_hwfn, bar_addr, val);\n\tDP_VERBOSE(p_hwfn, NETIF_MSG_HW,\n\t\t   \"bar_addr 0x%x, hw_addr 0x%x, val 0x%x\\n\",\n\t\t   bar_addr, hw_addr, val);\n}\n\nu32 qed_rd(struct qed_hwfn *p_hwfn,\n\t   struct qed_ptt *p_ptt,\n\t   u32 hw_addr)\n{\n\tu32 bar_addr = qed_set_ptt(p_hwfn, p_ptt, hw_addr);\n\tu32 val = REG_RD(p_hwfn, bar_addr);\n\n\tDP_VERBOSE(p_hwfn, NETIF_MSG_HW,\n\t\t   \"bar_addr 0x%x, hw_addr 0x%x, val 0x%x\\n\",\n\t\t   bar_addr, hw_addr, val);\n\n\treturn val;\n}\n\nstatic void qed_memcpy_hw(struct qed_hwfn *p_hwfn,\n\t\t\t  struct qed_ptt *p_ptt,\n\t\t\t  void *addr, u32 hw_addr, size_t n, bool to_device)\n{\n\tu32 dw_count, *host_addr, hw_offset;\n\tsize_t quota, done = 0;\n\tu32 __iomem *reg_addr;\n\n\twhile (done < n) {\n\t\tquota = min_t(size_t, n - done,\n\t\t\t      PXP_EXTERNAL_BAR_PF_WINDOW_SINGLE_SIZE);\n\n\t\tif (IS_PF(p_hwfn->cdev)) {\n\t\t\tqed_ptt_set_win(p_hwfn, p_ptt, hw_addr + done);\n\t\t\thw_offset = qed_ptt_get_bar_addr(p_ptt);\n\t\t} else {\n\t\t\thw_offset = hw_addr + done;\n\t\t}\n\n\t\tdw_count = quota / 4;\n\t\thost_addr = (u32 *)((u8 *)addr + done);\n\t\treg_addr = (u32 __iomem *)REG_ADDR(p_hwfn, hw_offset);\n\t\tif (to_device)\n\t\t\twhile (dw_count--)\n\t\t\t\tDIRECT_REG_WR(reg_addr++, *host_addr++);\n\t\telse\n\t\t\twhile (dw_count--)\n\t\t\t\t*host_addr++ = DIRECT_REG_RD(reg_addr++);\n\n\t\tdone += quota;\n\t}\n}\n\nvoid qed_memcpy_from(struct qed_hwfn *p_hwfn,\n\t\t     struct qed_ptt *p_ptt, void *dest, u32 hw_addr, size_t n)\n{\n\tDP_VERBOSE(p_hwfn, NETIF_MSG_HW,\n\t\t   \"hw_addr 0x%x, dest %p hw_addr 0x%x, size %lu\\n\",\n\t\t   hw_addr, dest, hw_addr, (unsigned long)n);\n\n\tqed_memcpy_hw(p_hwfn, p_ptt, dest, hw_addr, n, false);\n}\n\nvoid qed_memcpy_to(struct qed_hwfn *p_hwfn,\n\t\t   struct qed_ptt *p_ptt, u32 hw_addr, void *src, size_t n)\n{\n\tDP_VERBOSE(p_hwfn, NETIF_MSG_HW,\n\t\t   \"hw_addr 0x%x, hw_addr 0x%x, src %p size %lu\\n\",\n\t\t   hw_addr, hw_addr, src, (unsigned long)n);\n\n\tqed_memcpy_hw(p_hwfn, p_ptt, src, hw_addr, n, true);\n}\n\nvoid qed_fid_pretend(struct qed_hwfn *p_hwfn, struct qed_ptt *p_ptt, u16 fid)\n{\n\tu16 control = 0;\n\n\tSET_FIELD(control, PXP_PRETEND_CMD_IS_CONCRETE, 1);\n\tSET_FIELD(control, PXP_PRETEND_CMD_PRETEND_FUNCTION, 1);\n\n\t \n\tSET_FIELD(control, PXP_PRETEND_CMD_PORT, 0);\n\tSET_FIELD(control, PXP_PRETEND_CMD_USE_PORT, 0);\n\tSET_FIELD(control, PXP_PRETEND_CMD_PRETEND_PORT, 1);\n\n\tif (!GET_FIELD(fid, PXP_CONCRETE_FID_VFVALID))\n\t\tfid = GET_FIELD(fid, PXP_CONCRETE_FID_PFID);\n\n\tp_ptt->pxp.pretend.control = cpu_to_le16(control);\n\tp_ptt->pxp.pretend.fid.concrete_fid.fid = cpu_to_le16(fid);\n\n\tREG_WR(p_hwfn,\n\t       qed_ptt_config_addr(p_ptt) +\n\t       offsetof(struct pxp_ptt_entry, pretend),\n\t       *(u32 *)&p_ptt->pxp.pretend);\n}\n\nvoid qed_port_pretend(struct qed_hwfn *p_hwfn,\n\t\t      struct qed_ptt *p_ptt, u8 port_id)\n{\n\tu16 control = 0;\n\n\tSET_FIELD(control, PXP_PRETEND_CMD_PORT, port_id);\n\tSET_FIELD(control, PXP_PRETEND_CMD_USE_PORT, 1);\n\tSET_FIELD(control, PXP_PRETEND_CMD_PRETEND_PORT, 1);\n\n\tp_ptt->pxp.pretend.control = cpu_to_le16(control);\n\n\tREG_WR(p_hwfn,\n\t       qed_ptt_config_addr(p_ptt) +\n\t       offsetof(struct pxp_ptt_entry, pretend),\n\t       *(u32 *)&p_ptt->pxp.pretend);\n}\n\nvoid qed_port_unpretend(struct qed_hwfn *p_hwfn, struct qed_ptt *p_ptt)\n{\n\tu16 control = 0;\n\n\tSET_FIELD(control, PXP_PRETEND_CMD_PORT, 0);\n\tSET_FIELD(control, PXP_PRETEND_CMD_USE_PORT, 0);\n\tSET_FIELD(control, PXP_PRETEND_CMD_PRETEND_PORT, 1);\n\n\tp_ptt->pxp.pretend.control = cpu_to_le16(control);\n\n\tREG_WR(p_hwfn,\n\t       qed_ptt_config_addr(p_ptt) +\n\t       offsetof(struct pxp_ptt_entry, pretend),\n\t       *(u32 *)&p_ptt->pxp.pretend);\n}\n\nvoid qed_port_fid_pretend(struct qed_hwfn *p_hwfn,\n\t\t\t  struct qed_ptt *p_ptt, u8 port_id, u16 fid)\n{\n\tu16 control = 0;\n\n\tSET_FIELD(control, PXP_PRETEND_CMD_PORT, port_id);\n\tSET_FIELD(control, PXP_PRETEND_CMD_USE_PORT, 1);\n\tSET_FIELD(control, PXP_PRETEND_CMD_PRETEND_PORT, 1);\n\tSET_FIELD(control, PXP_PRETEND_CMD_IS_CONCRETE, 1);\n\tSET_FIELD(control, PXP_PRETEND_CMD_PRETEND_FUNCTION, 1);\n\tif (!GET_FIELD(fid, PXP_CONCRETE_FID_VFVALID))\n\t\tfid = GET_FIELD(fid, PXP_CONCRETE_FID_PFID);\n\tp_ptt->pxp.pretend.control = cpu_to_le16(control);\n\tp_ptt->pxp.pretend.fid.concrete_fid.fid = cpu_to_le16(fid);\n\tREG_WR(p_hwfn,\n\t       qed_ptt_config_addr(p_ptt) +\n\t       offsetof(struct pxp_ptt_entry, pretend),\n\t       *(u32 *)&p_ptt->pxp.pretend);\n}\n\nu32 qed_vfid_to_concrete(struct qed_hwfn *p_hwfn, u8 vfid)\n{\n\tu32 concrete_fid = 0;\n\n\tSET_FIELD(concrete_fid, PXP_CONCRETE_FID_PFID, p_hwfn->rel_pf_id);\n\tSET_FIELD(concrete_fid, PXP_CONCRETE_FID_VFID, vfid);\n\tSET_FIELD(concrete_fid, PXP_CONCRETE_FID_VFVALID, 1);\n\n\treturn concrete_fid;\n}\n\n \n#define QED_DMAE_FLAGS_IS_SET(params, flag) \\\n\t((params) != NULL && GET_FIELD((params)->flags, QED_DMAE_PARAMS_##flag))\n\nstatic void qed_dmae_opcode(struct qed_hwfn *p_hwfn,\n\t\t\t    const u8 is_src_type_grc,\n\t\t\t    const u8 is_dst_type_grc,\n\t\t\t    struct qed_dmae_params *p_params)\n{\n\tu8 src_pfid, dst_pfid, port_id;\n\tu16 opcode_b = 0;\n\tu32 opcode = 0;\n\n\t \n\tSET_FIELD(opcode, DMAE_CMD_SRC,\n\t\t  (is_src_type_grc ? dmae_cmd_src_grc : dmae_cmd_src_pcie));\n\tsrc_pfid = QED_DMAE_FLAGS_IS_SET(p_params, SRC_PF_VALID) ?\n\t    p_params->src_pfid : p_hwfn->rel_pf_id;\n\tSET_FIELD(opcode, DMAE_CMD_SRC_PF_ID, src_pfid);\n\n\t \n\tSET_FIELD(opcode, DMAE_CMD_DST,\n\t\t  (is_dst_type_grc ? dmae_cmd_dst_grc : dmae_cmd_dst_pcie));\n\tdst_pfid = QED_DMAE_FLAGS_IS_SET(p_params, DST_PF_VALID) ?\n\t    p_params->dst_pfid : p_hwfn->rel_pf_id;\n\tSET_FIELD(opcode, DMAE_CMD_DST_PF_ID, dst_pfid);\n\n\n\t \n\tSET_FIELD(opcode, DMAE_CMD_COMP_WORD_EN, 1);\n\tSET_FIELD(opcode, DMAE_CMD_SRC_ADDR_RESET, 1);\n\n\tif (QED_DMAE_FLAGS_IS_SET(p_params, COMPLETION_DST))\n\t\tSET_FIELD(opcode, DMAE_CMD_COMP_FUNC, 1);\n\n\t \n\tSET_FIELD(opcode, DMAE_CMD_ENDIANITY_MODE, DMAE_CMD_ENDIANITY);\n\n\tport_id = (QED_DMAE_FLAGS_IS_SET(p_params, PORT_VALID)) ?\n\t    p_params->port_id : p_hwfn->port_id;\n\tSET_FIELD(opcode, DMAE_CMD_PORT_ID, port_id);\n\n\t \n\tSET_FIELD(opcode, DMAE_CMD_SRC_ADDR_RESET, 1);\n\n\t \n\tSET_FIELD(opcode, DMAE_CMD_DST_ADDR_RESET, 1);\n\n\t \n\tif (QED_DMAE_FLAGS_IS_SET(p_params, SRC_VF_VALID)) {\n\t\tSET_FIELD(opcode, DMAE_CMD_SRC_VF_ID_VALID, 1);\n\t\tSET_FIELD(opcode_b, DMAE_CMD_SRC_VF_ID, p_params->src_vfid);\n\t} else {\n\t\tSET_FIELD(opcode_b, DMAE_CMD_SRC_VF_ID, 0xFF);\n\t}\n\tif (QED_DMAE_FLAGS_IS_SET(p_params, DST_VF_VALID)) {\n\t\tSET_FIELD(opcode, DMAE_CMD_DST_VF_ID_VALID, 1);\n\t\tSET_FIELD(opcode_b, DMAE_CMD_DST_VF_ID, p_params->dst_vfid);\n\t} else {\n\t\tSET_FIELD(opcode_b, DMAE_CMD_DST_VF_ID, 0xFF);\n\t}\n\n\tp_hwfn->dmae_info.p_dmae_cmd->opcode = cpu_to_le32(opcode);\n\tp_hwfn->dmae_info.p_dmae_cmd->opcode_b = cpu_to_le16(opcode_b);\n}\n\nu32 qed_dmae_idx_to_go_cmd(u8 idx)\n{\n\t \n\treturn DMAE_REG_GO_C0 + (idx << 2);\n}\n\nstatic int qed_dmae_post_command(struct qed_hwfn *p_hwfn,\n\t\t\t\t struct qed_ptt *p_ptt)\n{\n\tstruct dmae_cmd *p_command = p_hwfn->dmae_info.p_dmae_cmd;\n\tu8 idx_cmd = p_hwfn->dmae_info.channel, i;\n\tint qed_status = 0;\n\n\t \n\tif ((((!p_command->dst_addr_lo) && (!p_command->dst_addr_hi)) ||\n\t     ((!p_command->src_addr_lo) && (!p_command->src_addr_hi)))) {\n\t\tDP_NOTICE(p_hwfn,\n\t\t\t  \"source or destination address 0 idx_cmd=%d\\n\"\n\t\t\t  \"opcode = [0x%08x,0x%04x] len=0x%x src=0x%x:%x dst=0x%x:%x\\n\",\n\t\t\t  idx_cmd,\n\t\t\t  le32_to_cpu(p_command->opcode),\n\t\t\t  le16_to_cpu(p_command->opcode_b),\n\t\t\t  le16_to_cpu(p_command->length_dw),\n\t\t\t  le32_to_cpu(p_command->src_addr_hi),\n\t\t\t  le32_to_cpu(p_command->src_addr_lo),\n\t\t\t  le32_to_cpu(p_command->dst_addr_hi),\n\t\t\t  le32_to_cpu(p_command->dst_addr_lo));\n\n\t\treturn -EINVAL;\n\t}\n\n\tDP_VERBOSE(p_hwfn,\n\t\t   NETIF_MSG_HW,\n\t\t   \"Posting DMAE command [idx %d]: opcode = [0x%08x,0x%04x] len=0x%x src=0x%x:%x dst=0x%x:%x\\n\",\n\t\t   idx_cmd,\n\t\t   le32_to_cpu(p_command->opcode),\n\t\t   le16_to_cpu(p_command->opcode_b),\n\t\t   le16_to_cpu(p_command->length_dw),\n\t\t   le32_to_cpu(p_command->src_addr_hi),\n\t\t   le32_to_cpu(p_command->src_addr_lo),\n\t\t   le32_to_cpu(p_command->dst_addr_hi),\n\t\t   le32_to_cpu(p_command->dst_addr_lo));\n\n\t \n\tfor (i = 0; i < DMAE_CMD_SIZE; i++) {\n\t\tu32 data = (i < DMAE_CMD_SIZE_TO_FILL) ?\n\t\t\t   *(((u32 *)p_command) + i) : 0;\n\n\t\tqed_wr(p_hwfn, p_ptt,\n\t\t       DMAE_REG_CMD_MEM +\n\t\t       (idx_cmd * DMAE_CMD_SIZE * sizeof(u32)) +\n\t\t       (i * sizeof(u32)), data);\n\t}\n\n\tqed_wr(p_hwfn, p_ptt, qed_dmae_idx_to_go_cmd(idx_cmd), DMAE_GO_VALUE);\n\n\treturn qed_status;\n}\n\nint qed_dmae_info_alloc(struct qed_hwfn *p_hwfn)\n{\n\tdma_addr_t *p_addr = &p_hwfn->dmae_info.completion_word_phys_addr;\n\tstruct dmae_cmd **p_cmd = &p_hwfn->dmae_info.p_dmae_cmd;\n\tu32 **p_buff = &p_hwfn->dmae_info.p_intermediate_buffer;\n\tu32 **p_comp = &p_hwfn->dmae_info.p_completion_word;\n\n\t*p_comp = dma_alloc_coherent(&p_hwfn->cdev->pdev->dev,\n\t\t\t\t     sizeof(u32), p_addr, GFP_KERNEL);\n\tif (!*p_comp)\n\t\tgoto err;\n\n\tp_addr = &p_hwfn->dmae_info.dmae_cmd_phys_addr;\n\t*p_cmd = dma_alloc_coherent(&p_hwfn->cdev->pdev->dev,\n\t\t\t\t    sizeof(struct dmae_cmd),\n\t\t\t\t    p_addr, GFP_KERNEL);\n\tif (!*p_cmd)\n\t\tgoto err;\n\n\tp_addr = &p_hwfn->dmae_info.intermediate_buffer_phys_addr;\n\t*p_buff = dma_alloc_coherent(&p_hwfn->cdev->pdev->dev,\n\t\t\t\t     sizeof(u32) * DMAE_MAX_RW_SIZE,\n\t\t\t\t     p_addr, GFP_KERNEL);\n\tif (!*p_buff)\n\t\tgoto err;\n\n\tp_hwfn->dmae_info.channel = p_hwfn->rel_pf_id;\n\n\treturn 0;\nerr:\n\tqed_dmae_info_free(p_hwfn);\n\treturn -ENOMEM;\n}\n\nvoid qed_dmae_info_free(struct qed_hwfn *p_hwfn)\n{\n\tdma_addr_t p_phys;\n\n\t \n\tmutex_lock(&p_hwfn->dmae_info.mutex);\n\n\tif (p_hwfn->dmae_info.p_completion_word) {\n\t\tp_phys = p_hwfn->dmae_info.completion_word_phys_addr;\n\t\tdma_free_coherent(&p_hwfn->cdev->pdev->dev,\n\t\t\t\t  sizeof(u32),\n\t\t\t\t  p_hwfn->dmae_info.p_completion_word, p_phys);\n\t\tp_hwfn->dmae_info.p_completion_word = NULL;\n\t}\n\n\tif (p_hwfn->dmae_info.p_dmae_cmd) {\n\t\tp_phys = p_hwfn->dmae_info.dmae_cmd_phys_addr;\n\t\tdma_free_coherent(&p_hwfn->cdev->pdev->dev,\n\t\t\t\t  sizeof(struct dmae_cmd),\n\t\t\t\t  p_hwfn->dmae_info.p_dmae_cmd, p_phys);\n\t\tp_hwfn->dmae_info.p_dmae_cmd = NULL;\n\t}\n\n\tif (p_hwfn->dmae_info.p_intermediate_buffer) {\n\t\tp_phys = p_hwfn->dmae_info.intermediate_buffer_phys_addr;\n\t\tdma_free_coherent(&p_hwfn->cdev->pdev->dev,\n\t\t\t\t  sizeof(u32) * DMAE_MAX_RW_SIZE,\n\t\t\t\t  p_hwfn->dmae_info.p_intermediate_buffer,\n\t\t\t\t  p_phys);\n\t\tp_hwfn->dmae_info.p_intermediate_buffer = NULL;\n\t}\n\n\tmutex_unlock(&p_hwfn->dmae_info.mutex);\n}\n\nstatic int qed_dmae_operation_wait(struct qed_hwfn *p_hwfn)\n{\n\tu32 wait_cnt_limit = 10000, wait_cnt = 0;\n\tint qed_status = 0;\n\n\tbarrier();\n\twhile (*p_hwfn->dmae_info.p_completion_word != DMAE_COMPLETION_VAL) {\n\t\tudelay(DMAE_MIN_WAIT_TIME);\n\t\tif (++wait_cnt > wait_cnt_limit) {\n\t\t\tDP_NOTICE(p_hwfn->cdev,\n\t\t\t\t  \"Timed-out waiting for operation to complete. Completion word is 0x%08x expected 0x%08x.\\n\",\n\t\t\t\t  *p_hwfn->dmae_info.p_completion_word,\n\t\t\t\t DMAE_COMPLETION_VAL);\n\t\t\tqed_status = -EBUSY;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tbarrier();\n\t}\n\n\tif (qed_status == 0)\n\t\t*p_hwfn->dmae_info.p_completion_word = 0;\n\n\treturn qed_status;\n}\n\nstatic int qed_dmae_execute_sub_operation(struct qed_hwfn *p_hwfn,\n\t\t\t\t\t  struct qed_ptt *p_ptt,\n\t\t\t\t\t  u64 src_addr,\n\t\t\t\t\t  u64 dst_addr,\n\t\t\t\t\t  u8 src_type,\n\t\t\t\t\t  u8 dst_type,\n\t\t\t\t\t  u32 length_dw)\n{\n\tdma_addr_t phys = p_hwfn->dmae_info.intermediate_buffer_phys_addr;\n\tstruct dmae_cmd *cmd = p_hwfn->dmae_info.p_dmae_cmd;\n\tint qed_status = 0;\n\n\tswitch (src_type) {\n\tcase QED_DMAE_ADDRESS_GRC:\n\tcase QED_DMAE_ADDRESS_HOST_PHYS:\n\t\tcmd->src_addr_hi = cpu_to_le32(upper_32_bits(src_addr));\n\t\tcmd->src_addr_lo = cpu_to_le32(lower_32_bits(src_addr));\n\t\tbreak;\n\t \n\tcase QED_DMAE_ADDRESS_HOST_VIRT:\n\t\tcmd->src_addr_hi = cpu_to_le32(upper_32_bits(phys));\n\t\tcmd->src_addr_lo = cpu_to_le32(lower_32_bits(phys));\n\t\tmemcpy(&p_hwfn->dmae_info.p_intermediate_buffer[0],\n\t\t       (void *)(uintptr_t)src_addr,\n\t\t       length_dw * sizeof(u32));\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (dst_type) {\n\tcase QED_DMAE_ADDRESS_GRC:\n\tcase QED_DMAE_ADDRESS_HOST_PHYS:\n\t\tcmd->dst_addr_hi = cpu_to_le32(upper_32_bits(dst_addr));\n\t\tcmd->dst_addr_lo = cpu_to_le32(lower_32_bits(dst_addr));\n\t\tbreak;\n\t \n\tcase QED_DMAE_ADDRESS_HOST_VIRT:\n\t\tcmd->dst_addr_hi = cpu_to_le32(upper_32_bits(phys));\n\t\tcmd->dst_addr_lo = cpu_to_le32(lower_32_bits(phys));\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tcmd->length_dw = cpu_to_le16((u16)length_dw);\n\n\tqed_dmae_post_command(p_hwfn, p_ptt);\n\n\tqed_status = qed_dmae_operation_wait(p_hwfn);\n\n\tif (qed_status) {\n\t\tDP_NOTICE(p_hwfn,\n\t\t\t  \"qed_dmae_host2grc: Wait Failed. source_addr 0x%llx, grc_addr 0x%llx, size_in_dwords 0x%x\\n\",\n\t\t\t  src_addr, dst_addr, length_dw);\n\t\treturn qed_status;\n\t}\n\n\tif (dst_type == QED_DMAE_ADDRESS_HOST_VIRT)\n\t\tmemcpy((void *)(uintptr_t)(dst_addr),\n\t\t       &p_hwfn->dmae_info.p_intermediate_buffer[0],\n\t\t       length_dw * sizeof(u32));\n\n\treturn 0;\n}\n\nstatic int qed_dmae_execute_command(struct qed_hwfn *p_hwfn,\n\t\t\t\t    struct qed_ptt *p_ptt,\n\t\t\t\t    u64 src_addr, u64 dst_addr,\n\t\t\t\t    u8 src_type, u8 dst_type,\n\t\t\t\t    u32 size_in_dwords,\n\t\t\t\t    struct qed_dmae_params *p_params)\n{\n\tdma_addr_t phys = p_hwfn->dmae_info.completion_word_phys_addr;\n\tu16 length_cur = 0, i = 0, cnt_split = 0, length_mod = 0;\n\tstruct dmae_cmd *cmd = p_hwfn->dmae_info.p_dmae_cmd;\n\tu64 src_addr_split = 0, dst_addr_split = 0;\n\tu16 length_limit = DMAE_MAX_RW_SIZE;\n\tint qed_status = 0;\n\tu32 offset = 0;\n\n\tif (p_hwfn->cdev->recov_in_prog) {\n\t\tDP_VERBOSE(p_hwfn,\n\t\t\t   NETIF_MSG_HW,\n\t\t\t   \"Recovery is in progress. Avoid DMAE transaction [{src: addr 0x%llx, type %d}, {dst: addr 0x%llx, type %d}, size %d].\\n\",\n\t\t\t   src_addr, src_type, dst_addr, dst_type,\n\t\t\t   size_in_dwords);\n\n\t\t \n\t\treturn 0;\n\t}\n\n\tqed_dmae_opcode(p_hwfn,\n\t\t\t(src_type == QED_DMAE_ADDRESS_GRC),\n\t\t\t(dst_type == QED_DMAE_ADDRESS_GRC),\n\t\t\tp_params);\n\n\tcmd->comp_addr_lo = cpu_to_le32(lower_32_bits(phys));\n\tcmd->comp_addr_hi = cpu_to_le32(upper_32_bits(phys));\n\tcmd->comp_val = cpu_to_le32(DMAE_COMPLETION_VAL);\n\n\t \n\tcnt_split = size_in_dwords / length_limit;\n\tlength_mod = size_in_dwords % length_limit;\n\n\tsrc_addr_split = src_addr;\n\tdst_addr_split = dst_addr;\n\n\tfor (i = 0; i <= cnt_split; i++) {\n\t\toffset = length_limit * i;\n\n\t\tif (!QED_DMAE_FLAGS_IS_SET(p_params, RW_REPL_SRC)) {\n\t\t\tif (src_type == QED_DMAE_ADDRESS_GRC)\n\t\t\t\tsrc_addr_split = src_addr + offset;\n\t\t\telse\n\t\t\t\tsrc_addr_split = src_addr + (offset * 4);\n\t\t}\n\n\t\tif (dst_type == QED_DMAE_ADDRESS_GRC)\n\t\t\tdst_addr_split = dst_addr + offset;\n\t\telse\n\t\t\tdst_addr_split = dst_addr + (offset * 4);\n\n\t\tlength_cur = (cnt_split == i) ? length_mod : length_limit;\n\n\t\t \n\t\tif (!length_cur)\n\t\t\tcontinue;\n\n\t\tqed_status = qed_dmae_execute_sub_operation(p_hwfn,\n\t\t\t\t\t\t\t    p_ptt,\n\t\t\t\t\t\t\t    src_addr_split,\n\t\t\t\t\t\t\t    dst_addr_split,\n\t\t\t\t\t\t\t    src_type,\n\t\t\t\t\t\t\t    dst_type,\n\t\t\t\t\t\t\t    length_cur);\n\t\tif (qed_status) {\n\t\t\tqed_hw_err_notify(p_hwfn, p_ptt, QED_HW_ERR_DMAE_FAIL,\n\t\t\t\t\t  \"qed_dmae_execute_sub_operation Failed with error 0x%x. source_addr 0x%llx, destination addr 0x%llx, size_in_dwords 0x%x\\n\",\n\t\t\t\t\t  qed_status, src_addr,\n\t\t\t\t\t  dst_addr, length_cur);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn qed_status;\n}\n\nint qed_dmae_host2grc(struct qed_hwfn *p_hwfn,\n\t\t      struct qed_ptt *p_ptt,\n\t\t      u64 source_addr, u32 grc_addr, u32 size_in_dwords,\n\t\t      struct qed_dmae_params *p_params)\n{\n\tu32 grc_addr_in_dw = grc_addr / sizeof(u32);\n\tint rc;\n\n\n\tmutex_lock(&p_hwfn->dmae_info.mutex);\n\n\trc = qed_dmae_execute_command(p_hwfn, p_ptt, source_addr,\n\t\t\t\t      grc_addr_in_dw,\n\t\t\t\t      QED_DMAE_ADDRESS_HOST_VIRT,\n\t\t\t\t      QED_DMAE_ADDRESS_GRC,\n\t\t\t\t      size_in_dwords, p_params);\n\n\tmutex_unlock(&p_hwfn->dmae_info.mutex);\n\n\treturn rc;\n}\n\nint qed_dmae_grc2host(struct qed_hwfn *p_hwfn,\n\t\t      struct qed_ptt *p_ptt,\n\t\t      u32 grc_addr,\n\t\t      dma_addr_t dest_addr, u32 size_in_dwords,\n\t\t      struct qed_dmae_params *p_params)\n{\n\tu32 grc_addr_in_dw = grc_addr / sizeof(u32);\n\tint rc;\n\n\n\tmutex_lock(&p_hwfn->dmae_info.mutex);\n\n\trc = qed_dmae_execute_command(p_hwfn, p_ptt, grc_addr_in_dw,\n\t\t\t\t      dest_addr, QED_DMAE_ADDRESS_GRC,\n\t\t\t\t      QED_DMAE_ADDRESS_HOST_VIRT,\n\t\t\t\t      size_in_dwords, p_params);\n\n\tmutex_unlock(&p_hwfn->dmae_info.mutex);\n\n\treturn rc;\n}\n\nint qed_dmae_host2host(struct qed_hwfn *p_hwfn,\n\t\t       struct qed_ptt *p_ptt,\n\t\t       dma_addr_t source_addr,\n\t\t       dma_addr_t dest_addr,\n\t\t       u32 size_in_dwords, struct qed_dmae_params *p_params)\n{\n\tint rc;\n\n\tmutex_lock(&(p_hwfn->dmae_info.mutex));\n\n\trc = qed_dmae_execute_command(p_hwfn, p_ptt, source_addr,\n\t\t\t\t      dest_addr,\n\t\t\t\t      QED_DMAE_ADDRESS_HOST_PHYS,\n\t\t\t\t      QED_DMAE_ADDRESS_HOST_PHYS,\n\t\t\t\t      size_in_dwords, p_params);\n\n\tmutex_unlock(&(p_hwfn->dmae_info.mutex));\n\n\treturn rc;\n}\n\nvoid qed_hw_err_notify(struct qed_hwfn *p_hwfn, struct qed_ptt *p_ptt,\n\t\t       enum qed_hw_err_type err_type, const char *fmt, ...)\n{\n\tchar buf[QED_HW_ERR_MAX_STR_SIZE];\n\tva_list vl;\n\tint len;\n\n\tif (fmt) {\n\t\tva_start(vl, fmt);\n\t\tlen = vsnprintf(buf, QED_HW_ERR_MAX_STR_SIZE, fmt, vl);\n\t\tva_end(vl);\n\n\t\tif (len > QED_HW_ERR_MAX_STR_SIZE - 1)\n\t\t\tlen = QED_HW_ERR_MAX_STR_SIZE - 1;\n\n\t\tDP_NOTICE(p_hwfn, \"%s\", buf);\n\t}\n\n\t \n\tif (p_hwfn->cdev->recov_in_prog &&\n\t    err_type != QED_HW_ERR_FAN_FAIL) {\n\t\tDP_VERBOSE(p_hwfn,\n\t\t\t   NETIF_MSG_DRV,\n\t\t\t   \"Recovery is in progress. Avoid notifying about HW error %d.\\n\",\n\t\t\t   err_type);\n\t\treturn;\n\t}\n\n\tqed_hw_error_occurred(p_hwfn, err_type);\n\n\tif (fmt)\n\t\tqed_mcp_send_raw_debug_data(p_hwfn, p_ptt, buf, len);\n}\n\nint qed_dmae_sanity(struct qed_hwfn *p_hwfn,\n\t\t    struct qed_ptt *p_ptt, const char *phase)\n{\n\tu32 size = PAGE_SIZE / 2, val;\n\tint rc = 0;\n\tdma_addr_t p_phys;\n\tvoid *p_virt;\n\tu32 *p_tmp;\n\n\tp_virt = dma_alloc_coherent(&p_hwfn->cdev->pdev->dev,\n\t\t\t\t    2 * size, &p_phys, GFP_KERNEL);\n\tif (!p_virt) {\n\t\tDP_NOTICE(p_hwfn,\n\t\t\t  \"DMAE sanity [%s]: failed to allocate memory\\n\",\n\t\t\t  phase);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tfor (p_tmp = (u32 *)p_virt;\n\t     p_tmp < (u32 *)((u8 *)p_virt + size); p_tmp++) {\n\t\t \n\t\tval = (u32)(uintptr_t)p_tmp;\n\t\t*p_tmp = val;\n\t}\n\n\t \n\tmemset((u8 *)p_virt + size, 0, size);\n\n\tDP_VERBOSE(p_hwfn,\n\t\t   QED_MSG_SP,\n\t\t   \"DMAE sanity [%s]: src_addr={phys 0x%llx, virt %p}, dst_addr={phys 0x%llx, virt %p}, size 0x%x\\n\",\n\t\t   phase,\n\t\t   (u64)p_phys,\n\t\t   p_virt, (u64)(p_phys + size), (u8 *)p_virt + size, size);\n\n\trc = qed_dmae_host2host(p_hwfn, p_ptt, p_phys, p_phys + size,\n\t\t\t\tsize / 4, NULL);\n\tif (rc) {\n\t\tDP_NOTICE(p_hwfn,\n\t\t\t  \"DMAE sanity [%s]: qed_dmae_host2host() failed. rc = %d.\\n\",\n\t\t\t  phase, rc);\n\t\tgoto out;\n\t}\n\n\t \n\tfor (p_tmp = (u32 *)((u8 *)p_virt + size);\n\t     p_tmp < (u32 *)((u8 *)p_virt + (2 * size)); p_tmp++) {\n\t\t \n\t\tval = (u32)(uintptr_t)p_tmp - size;\n\n\t\tif (*p_tmp != val) {\n\t\t\tDP_NOTICE(p_hwfn,\n\t\t\t\t  \"DMAE sanity [%s]: addr={phys 0x%llx, virt %p}, read_val 0x%08x, expected_val 0x%08x\\n\",\n\t\t\t\t  phase,\n\t\t\t\t  (u64)p_phys + ((u8 *)p_tmp - (u8 *)p_virt),\n\t\t\t\t  p_tmp, *p_tmp, val);\n\t\t\trc = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tdma_free_coherent(&p_hwfn->cdev->pdev->dev, 2 * size, p_virt, p_phys);\n\treturn rc;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}