{
  "module_name": "qed_nvmetcp_fw_funcs.c",
  "hash_id": "1a8076b37d5e6612605e5adba4ae581dc85decd9c6016039d141caf28043f3e7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/qlogic/qed/qed_nvmetcp_fw_funcs.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/types.h>\n#include <asm/byteorder.h>\n#include <linux/qed/common_hsi.h>\n#include <linux/qed/storage_common.h>\n#include <linux/qed/nvmetcp_common.h>\n#include <linux/qed/qed_nvmetcp_if.h>\n#include \"qed_nvmetcp_fw_funcs.h\"\n\n#define NVMETCP_NUM_SGES_IN_CACHE 0x4\n\nbool nvmetcp_is_slow_sgl(u16 num_sges, bool small_mid_sge)\n{\n\treturn (num_sges > SCSI_NUM_SGES_SLOW_SGL_THR && small_mid_sge);\n}\n\nvoid init_scsi_sgl_context(struct scsi_sgl_params *ctx_sgl_params,\n\t\t\t   struct scsi_cached_sges *ctx_data_desc,\n\t\t\t   struct storage_sgl_task_params *sgl_params)\n{\n\tu8 num_sges_to_init = (u8)(sgl_params->num_sges > NVMETCP_NUM_SGES_IN_CACHE ?\n\t\t\t\t   NVMETCP_NUM_SGES_IN_CACHE : sgl_params->num_sges);\n\tu8 sge_index;\n\n\t \n\tctx_sgl_params->sgl_addr.lo = cpu_to_le32(sgl_params->sgl_phys_addr.lo);\n\tctx_sgl_params->sgl_addr.hi = cpu_to_le32(sgl_params->sgl_phys_addr.hi);\n\tctx_sgl_params->sgl_total_length = cpu_to_le32(sgl_params->total_buffer_size);\n\tctx_sgl_params->sgl_num_sges = cpu_to_le16(sgl_params->num_sges);\n\n\tfor (sge_index = 0; sge_index < num_sges_to_init; sge_index++) {\n\t\tctx_data_desc->sge[sge_index].sge_addr.lo =\n\t\t\tcpu_to_le32(sgl_params->sgl[sge_index].sge_addr.lo);\n\t\tctx_data_desc->sge[sge_index].sge_addr.hi =\n\t\t\tcpu_to_le32(sgl_params->sgl[sge_index].sge_addr.hi);\n\t\tctx_data_desc->sge[sge_index].sge_len =\n\t\t\tcpu_to_le32(sgl_params->sgl[sge_index].sge_len);\n\t}\n}\n\nstatic inline u32 calc_rw_task_size(struct nvmetcp_task_params *task_params,\n\t\t\t\t    enum nvmetcp_task_type task_type)\n{\n\tu32 io_size;\n\n\tif (task_type == NVMETCP_TASK_TYPE_HOST_WRITE)\n\t\tio_size = task_params->tx_io_size;\n\telse\n\t\tio_size = task_params->rx_io_size;\n\n\tif (unlikely(!io_size))\n\t\treturn 0;\n\n\treturn io_size;\n}\n\nstatic inline void init_sqe(struct nvmetcp_task_params *task_params,\n\t\t\t    struct storage_sgl_task_params *sgl_task_params,\n\t\t\t    enum nvmetcp_task_type task_type)\n{\n\tif (!task_params->sqe)\n\t\treturn;\n\n\tmemset(task_params->sqe, 0, sizeof(*task_params->sqe));\n\ttask_params->sqe->task_id = cpu_to_le16(task_params->itid);\n\n\tswitch (task_type) {\n\tcase NVMETCP_TASK_TYPE_HOST_WRITE: {\n\t\tu32 buf_size = 0;\n\t\tu32 num_sges = 0;\n\n\t\tSET_FIELD(task_params->sqe->contlen_cdbsize,\n\t\t\t  NVMETCP_WQE_CDB_SIZE_OR_NVMETCP_CMD, 1);\n\t\tSET_FIELD(task_params->sqe->flags, NVMETCP_WQE_WQE_TYPE,\n\t\t\t  NVMETCP_WQE_TYPE_NORMAL);\n\t\tif (task_params->tx_io_size) {\n\t\t\tif (task_params->send_write_incapsule)\n\t\t\t\tbuf_size = calc_rw_task_size(task_params, task_type);\n\n\t\t\tif (nvmetcp_is_slow_sgl(sgl_task_params->num_sges,\n\t\t\t\t\t\tsgl_task_params->small_mid_sge))\n\t\t\t\tnum_sges = NVMETCP_WQE_NUM_SGES_SLOWIO;\n\t\t\telse\n\t\t\t\tnum_sges = min((u16)sgl_task_params->num_sges,\n\t\t\t\t\t       (u16)SCSI_NUM_SGES_SLOW_SGL_THR);\n\t\t}\n\t\tSET_FIELD(task_params->sqe->flags, NVMETCP_WQE_NUM_SGES, num_sges);\n\t\tSET_FIELD(task_params->sqe->contlen_cdbsize, NVMETCP_WQE_CONT_LEN, buf_size);\n\t} break;\n\n\tcase NVMETCP_TASK_TYPE_HOST_READ: {\n\t\tSET_FIELD(task_params->sqe->flags, NVMETCP_WQE_WQE_TYPE,\n\t\t\t  NVMETCP_WQE_TYPE_NORMAL);\n\t\tSET_FIELD(task_params->sqe->contlen_cdbsize,\n\t\t\t  NVMETCP_WQE_CDB_SIZE_OR_NVMETCP_CMD, 1);\n\t} break;\n\n\tcase NVMETCP_TASK_TYPE_INIT_CONN_REQUEST: {\n\t\tSET_FIELD(task_params->sqe->flags, NVMETCP_WQE_WQE_TYPE,\n\t\t\t  NVMETCP_WQE_TYPE_MIDDLE_PATH);\n\n\t\tif (task_params->tx_io_size) {\n\t\t\tSET_FIELD(task_params->sqe->contlen_cdbsize, NVMETCP_WQE_CONT_LEN,\n\t\t\t\t  task_params->tx_io_size);\n\t\t\tSET_FIELD(task_params->sqe->flags, NVMETCP_WQE_NUM_SGES,\n\t\t\t\t  min((u16)sgl_task_params->num_sges,\n\t\t\t\t      (u16)SCSI_NUM_SGES_SLOW_SGL_THR));\n\t\t}\n\t} break;\n\n\tcase NVMETCP_TASK_TYPE_CLEANUP:\n\t\tSET_FIELD(task_params->sqe->flags, NVMETCP_WQE_WQE_TYPE,\n\t\t\t  NVMETCP_WQE_TYPE_TASK_CLEANUP);\n\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n \nstatic inline void\ninit_nvmetcp_task_params(struct e5_nvmetcp_task_context *context,\n\t\t\t struct nvmetcp_task_params *task_params,\n\t\t\t enum nvmetcp_task_type task_type)\n{\n\tcontext->ystorm_st_context.state.cccid = task_params->host_cccid;\n\tSET_FIELD(context->ustorm_st_context.error_flags, USTORM_NVMETCP_TASK_ST_CTX_NVME_TCP, 1);\n\tcontext->ustorm_st_context.nvme_tcp_opaque_lo = cpu_to_le32(task_params->opq.lo);\n\tcontext->ustorm_st_context.nvme_tcp_opaque_hi = cpu_to_le32(task_params->opq.hi);\n}\n\n \nstatic inline void\ninit_default_nvmetcp_task(struct nvmetcp_task_params *task_params,\n\t\t\t  void *pdu_header, void *nvme_cmd,\n\t\t\t  enum nvmetcp_task_type task_type)\n{\n\tstruct e5_nvmetcp_task_context *context = task_params->context;\n\tconst u8 val_byte = context->mstorm_ag_context.cdu_validation;\n\tu8 dw_index;\n\n\tmemset(context, 0, sizeof(*context));\n\tinit_nvmetcp_task_params(context, task_params,\n\t\t\t\t (enum nvmetcp_task_type)task_type);\n\n\t \n\tif (task_type == NVMETCP_TASK_TYPE_HOST_WRITE ||\n\t    task_type == NVMETCP_TASK_TYPE_HOST_READ) {\n\t\tfor (dw_index = 0;\n\t\t     dw_index < QED_NVMETCP_CMN_HDR_SIZE / sizeof(u32);\n\t\t     dw_index++)\n\t\t\tcontext->ystorm_st_context.pdu_hdr.task_hdr.reg[dw_index] =\n\t\t\t\tcpu_to_le32(__swab32(((u32 *)pdu_header)[dw_index]));\n\n\t\tfor (dw_index = QED_NVMETCP_CMN_HDR_SIZE / sizeof(u32);\n\t\t     dw_index < QED_NVMETCP_CMD_HDR_SIZE / sizeof(u32);\n\t\t     dw_index++)\n\t\t\tcontext->ystorm_st_context.pdu_hdr.task_hdr.reg[dw_index] =\n\t\t\t\tcpu_to_le32(__swab32(((u32 *)nvme_cmd)[dw_index - 2]));\n\t} else {\n\t\tfor (dw_index = 0;\n\t\t     dw_index < QED_NVMETCP_NON_IO_HDR_SIZE / sizeof(u32);\n\t\t     dw_index++)\n\t\t\tcontext->ystorm_st_context.pdu_hdr.task_hdr.reg[dw_index] =\n\t\t\t\tcpu_to_le32(__swab32(((u32 *)pdu_header)[dw_index]));\n\t}\n\n\t \n\tcontext->mstorm_ag_context.cdu_validation = val_byte;\n\tcontext->mstorm_st_context.task_type = (u8)(task_type);\n\tcontext->mstorm_ag_context.task_cid = cpu_to_le16(task_params->conn_icid);\n\n\t \n\tSET_FIELD(context->ustorm_ag_context.flags1, E5_USTORM_NVMETCP_TASK_AG_CTX_R2T2RECV, 1);\n\tcontext->ustorm_st_context.task_type = (u8)(task_type);\n\tcontext->ustorm_st_context.cq_rss_number = task_params->cq_rss_number;\n\tcontext->ustorm_ag_context.icid = cpu_to_le16(task_params->conn_icid);\n}\n\n \nstatic inline void\ninit_ustorm_task_contexts(struct ustorm_nvmetcp_task_st_ctx *ustorm_st_context,\n\t\t\t  struct e5_ustorm_nvmetcp_task_ag_ctx *ustorm_ag_context,\n\t\t\t  u32 remaining_recv_len,\n\t\t\t  u32 expected_data_transfer_len, u8 num_sges,\n\t\t\t  bool tx_dif_conn_err_en)\n{\n\t \n\tustorm_st_context->rem_rcv_len = cpu_to_le32(remaining_recv_len);\n\tustorm_ag_context->exp_data_acked = cpu_to_le32(expected_data_transfer_len);\n\tustorm_st_context->exp_data_transfer_len = cpu_to_le32(expected_data_transfer_len);\n\tSET_FIELD(ustorm_st_context->reg1_map, REG1_NUM_SGES, num_sges);\n\tSET_FIELD(ustorm_ag_context->flags2, E5_USTORM_NVMETCP_TASK_AG_CTX_DIF_ERROR_CF_EN,\n\t\t  tx_dif_conn_err_en ? 1 : 0);\n}\n\n \nstatic inline void\nset_local_completion_context(struct e5_nvmetcp_task_context *context)\n{\n\tSET_FIELD(context->ystorm_st_context.state.flags,\n\t\t  YSTORM_NVMETCP_TASK_STATE_LOCAL_COMP, 1);\n\tSET_FIELD(context->ustorm_st_context.flags,\n\t\t  USTORM_NVMETCP_TASK_ST_CTX_LOCAL_COMP, 1);\n}\n\n \nstatic inline void\ninit_rw_nvmetcp_task(struct nvmetcp_task_params *task_params,\n\t\t     enum nvmetcp_task_type task_type,\n\t\t     void *pdu_header, void *nvme_cmd,\n\t\t     struct storage_sgl_task_params *sgl_task_params)\n{\n\tstruct e5_nvmetcp_task_context *context = task_params->context;\n\tu32 task_size = calc_rw_task_size(task_params, task_type);\n\tbool slow_io = false;\n\tu8 num_sges = 0;\n\n\tinit_default_nvmetcp_task(task_params, pdu_header, nvme_cmd, task_type);\n\n\t \n\tif (task_params->tx_io_size) {\n\t\t \n\t\tinit_scsi_sgl_context(&context->ystorm_st_context.state.sgl_params,\n\t\t\t\t      &context->ystorm_st_context.state.data_desc,\n\t\t\t\t      sgl_task_params);\n\t\tslow_io = nvmetcp_is_slow_sgl(sgl_task_params->num_sges,\n\t\t\t\t\t      sgl_task_params->small_mid_sge);\n\t\tnum_sges =\n\t\t\t(u8)(!slow_io ? min((u32)sgl_task_params->num_sges,\n\t\t\t\t\t    (u32)SCSI_NUM_SGES_SLOW_SGL_THR) :\n\t\t\t\t\t    NVMETCP_WQE_NUM_SGES_SLOWIO);\n\t\tif (slow_io) {\n\t\t\tSET_FIELD(context->ystorm_st_context.state.flags,\n\t\t\t\t  YSTORM_NVMETCP_TASK_STATE_SLOW_IO, 1);\n\t\t}\n\t} else if (task_params->rx_io_size) {\n\t\t \n\t\tinit_scsi_sgl_context(&context->mstorm_st_context.sgl_params,\n\t\t\t\t      &context->mstorm_st_context.data_desc,\n\t\t\t\t      sgl_task_params);\n\t\tnum_sges =\n\t\t\t(u8)(!nvmetcp_is_slow_sgl(sgl_task_params->num_sges,\n\t\t\t\t\t\t  sgl_task_params->small_mid_sge) ?\n\t\t\t\t\t\t  min((u32)sgl_task_params->num_sges,\n\t\t\t\t\t\t      (u32)SCSI_NUM_SGES_SLOW_SGL_THR) :\n\t\t\t\t\t\t      NVMETCP_WQE_NUM_SGES_SLOWIO);\n\t\tcontext->mstorm_st_context.rem_task_size = cpu_to_le32(task_size);\n\t}\n\n\t \n\tinit_ustorm_task_contexts(&context->ustorm_st_context,\n\t\t\t\t  &context->ustorm_ag_context,\n\t\t\t\t   \n\t\t\t\t  task_size,\n\t\t\t\t   \n\t\t\t\t  task_size,\n\t\t\t\t   \n\t\t\t\t  num_sges,\n\t\t\t\t  false);\n\n\t \n\tif (task_type == NVMETCP_TASK_TYPE_HOST_WRITE) {\n\t\tif (task_params->send_write_incapsule)\n\t\t\tcontext->ustorm_ag_context.exp_data_acked = task_size;\n\t\telse\n\t\t\tcontext->ustorm_ag_context.exp_data_acked = 0;\n\t} else if (task_type == NVMETCP_TASK_TYPE_HOST_READ) {\n\t\tcontext->ustorm_ag_context.exp_data_acked = 0;\n\t}\n\n\tcontext->ustorm_ag_context.exp_cont_len = 0;\n\tinit_sqe(task_params, sgl_task_params, task_type);\n}\n\nstatic void\ninit_common_initiator_read_task(struct nvmetcp_task_params *task_params,\n\t\t\t\tstruct nvme_tcp_cmd_pdu *cmd_pdu_header,\n\t\t\t\tstruct nvme_command *nvme_cmd,\n\t\t\t\tstruct storage_sgl_task_params *sgl_task_params)\n{\n\tinit_rw_nvmetcp_task(task_params, NVMETCP_TASK_TYPE_HOST_READ,\n\t\t\t     cmd_pdu_header, nvme_cmd, sgl_task_params);\n}\n\nvoid init_nvmetcp_host_read_task(struct nvmetcp_task_params *task_params,\n\t\t\t\t struct nvme_tcp_cmd_pdu *cmd_pdu_header,\n\t\t\t\t struct nvme_command *nvme_cmd,\n\t\t\t\t struct storage_sgl_task_params *sgl_task_params)\n{\n\tinit_common_initiator_read_task(task_params, (void *)cmd_pdu_header,\n\t\t\t\t\t(void *)nvme_cmd, sgl_task_params);\n}\n\nstatic void\ninit_common_initiator_write_task(struct nvmetcp_task_params *task_params,\n\t\t\t\t struct nvme_tcp_cmd_pdu *cmd_pdu_header,\n\t\t\t\t struct nvme_command *nvme_cmd,\n\t\t\t\t struct storage_sgl_task_params *sgl_task_params)\n{\n\tinit_rw_nvmetcp_task(task_params, NVMETCP_TASK_TYPE_HOST_WRITE,\n\t\t\t     cmd_pdu_header, nvme_cmd, sgl_task_params);\n}\n\nvoid init_nvmetcp_host_write_task(struct nvmetcp_task_params *task_params,\n\t\t\t\t  struct nvme_tcp_cmd_pdu *cmd_pdu_header,\n\t\t\t\t  struct nvme_command *nvme_cmd,\n\t\t\t\t  struct storage_sgl_task_params *sgl_task_params)\n{\n\tinit_common_initiator_write_task(task_params, (void *)cmd_pdu_header,\n\t\t\t\t\t (void *)nvme_cmd, sgl_task_params);\n}\n\nstatic void\ninit_common_login_request_task(struct nvmetcp_task_params *task_params,\n\t\t\t       void *login_req_pdu_header,\n\t\t\t       struct storage_sgl_task_params *tx_sgl_task_params,\n\t\t\t       struct storage_sgl_task_params *rx_sgl_task_params)\n{\n\tstruct e5_nvmetcp_task_context *context = task_params->context;\n\n\tinit_default_nvmetcp_task(task_params, (void *)login_req_pdu_header, NULL,\n\t\t\t\t  NVMETCP_TASK_TYPE_INIT_CONN_REQUEST);\n\n\t \n\tinit_ustorm_task_contexts(&context->ustorm_st_context,\n\t\t\t\t  &context->ustorm_ag_context,\n\n\t\t\t\t   \n\t\t\t\t  task_params->rx_io_size ?\n\t\t\t\t  rx_sgl_task_params->total_buffer_size : 0,\n\n\t\t\t\t   \n\t\t\t\t  task_params->tx_io_size ?\n\t\t\t\t  tx_sgl_task_params->total_buffer_size : 0,\n\t\t\t\t  0,  \n\t\t\t\t  0);  \n\n\t \n\tif (task_params->tx_io_size)\n\t\tinit_scsi_sgl_context(&context->ystorm_st_context.state.sgl_params,\n\t\t\t\t      &context->ystorm_st_context.state.data_desc,\n\t\t\t\t      tx_sgl_task_params);\n\tif (task_params->rx_io_size)\n\t\tinit_scsi_sgl_context(&context->mstorm_st_context.sgl_params,\n\t\t\t\t      &context->mstorm_st_context.data_desc,\n\t\t\t\t      rx_sgl_task_params);\n\n\tcontext->mstorm_st_context.rem_task_size =\n\t\tcpu_to_le32(task_params->rx_io_size ?\n\t\t\t\t rx_sgl_task_params->total_buffer_size : 0);\n\tinit_sqe(task_params, tx_sgl_task_params, NVMETCP_TASK_TYPE_INIT_CONN_REQUEST);\n}\n\n \nvoid init_nvmetcp_init_conn_req_task(struct nvmetcp_task_params *task_params,\n\t\t\t\t     struct nvme_tcp_icreq_pdu *init_conn_req_pdu_hdr,\n\t\t\t\t     struct storage_sgl_task_params *tx_sgl_task_params,\n\t\t\t\t     struct storage_sgl_task_params *rx_sgl_task_params)\n{\n\tinit_common_login_request_task(task_params, init_conn_req_pdu_hdr,\n\t\t\t\t       tx_sgl_task_params, rx_sgl_task_params);\n}\n\nvoid init_cleanup_task_nvmetcp(struct nvmetcp_task_params *task_params)\n{\n\tinit_sqe(task_params, NULL, NVMETCP_TASK_TYPE_CLEANUP);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}