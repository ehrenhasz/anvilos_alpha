{
  "module_name": "qed_dcbx.c",
  "hash_id": "c539624264c0b70bc1b174064861d98ad3e2c67d2bd31a2829f53b1dcba4285f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/qlogic/qed/qed_dcbx.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <asm/byteorder.h>\n#include <linux/bitops.h>\n#include <linux/dcbnl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include \"qed.h\"\n#include \"qed_cxt.h\"\n#include \"qed_dcbx.h\"\n#include \"qed_hsi.h\"\n#include \"qed_sp.h\"\n#include \"qed_sriov.h\"\n#include \"qed_rdma.h\"\n#ifdef CONFIG_DCB\n#include <linux/qed/qed_eth_if.h>\n#endif\n\n#define QED_DCBX_MAX_MIB_READ_TRY       (100)\n#define QED_ETH_TYPE_DEFAULT            (0)\n#define QED_ETH_TYPE_ROCE               (0x8915)\n#define QED_UDP_PORT_TYPE_ROCE_V2       (0x12B7)\n#define QED_ETH_TYPE_FCOE               (0x8906)\n#define QED_TCP_PORT_ISCSI              (0xCBC)\n\n#define QED_DCBX_INVALID_PRIORITY       0xFF\n\n \n#define QED_DCBX_PRIO2TC(prio_tc_tbl, prio) \\\n\t((u32)(prio_tc_tbl >> ((7 - prio) * 4)) & 0x7)\n\nstatic const struct qed_dcbx_app_metadata qed_dcbx_app_update[] = {\n\t{DCBX_PROTOCOL_ISCSI, \"ISCSI\", QED_PCI_ISCSI},\n\t{DCBX_PROTOCOL_FCOE, \"FCOE\", QED_PCI_FCOE},\n\t{DCBX_PROTOCOL_ROCE, \"ROCE\", QED_PCI_ETH_ROCE},\n\t{DCBX_PROTOCOL_ROCE_V2, \"ROCE_V2\", QED_PCI_ETH_ROCE},\n\t{DCBX_PROTOCOL_ETH, \"ETH\", QED_PCI_ETH},\n};\n\nstatic bool qed_dcbx_app_ethtype(u32 app_info_bitmap)\n{\n\treturn !!(QED_MFW_GET_FIELD(app_info_bitmap, DCBX_APP_SF) ==\n\t\t  DCBX_APP_SF_ETHTYPE);\n}\n\nstatic bool qed_dcbx_ieee_app_ethtype(u32 app_info_bitmap)\n{\n\tu8 mfw_val = QED_MFW_GET_FIELD(app_info_bitmap, DCBX_APP_SF_IEEE);\n\n\t \n\tif (mfw_val == DCBX_APP_SF_IEEE_RESERVED)\n\t\treturn qed_dcbx_app_ethtype(app_info_bitmap);\n\n\treturn !!(mfw_val == DCBX_APP_SF_IEEE_ETHTYPE);\n}\n\nstatic bool qed_dcbx_app_port(u32 app_info_bitmap)\n{\n\treturn !!(QED_MFW_GET_FIELD(app_info_bitmap, DCBX_APP_SF) ==\n\t\t  DCBX_APP_SF_PORT);\n}\n\nstatic bool qed_dcbx_ieee_app_port(u32 app_info_bitmap, u8 type)\n{\n\tu8 mfw_val = QED_MFW_GET_FIELD(app_info_bitmap, DCBX_APP_SF_IEEE);\n\n\t \n\tif (mfw_val == DCBX_APP_SF_IEEE_RESERVED)\n\t\treturn qed_dcbx_app_port(app_info_bitmap);\n\n\treturn !!(mfw_val == type || mfw_val == DCBX_APP_SF_IEEE_TCP_UDP_PORT);\n}\n\nstatic bool qed_dcbx_default_tlv(u32 app_info_bitmap, u16 proto_id, bool ieee)\n{\n\tbool ethtype;\n\n\tif (ieee)\n\t\tethtype = qed_dcbx_ieee_app_ethtype(app_info_bitmap);\n\telse\n\t\tethtype = qed_dcbx_app_ethtype(app_info_bitmap);\n\n\treturn !!(ethtype && (proto_id == QED_ETH_TYPE_DEFAULT));\n}\n\nstatic bool qed_dcbx_iscsi_tlv(u32 app_info_bitmap, u16 proto_id, bool ieee)\n{\n\tbool port;\n\n\tif (ieee)\n\t\tport = qed_dcbx_ieee_app_port(app_info_bitmap,\n\t\t\t\t\t      DCBX_APP_SF_IEEE_TCP_PORT);\n\telse\n\t\tport = qed_dcbx_app_port(app_info_bitmap);\n\n\treturn !!(port && (proto_id == QED_TCP_PORT_ISCSI));\n}\n\nstatic bool qed_dcbx_fcoe_tlv(u32 app_info_bitmap, u16 proto_id, bool ieee)\n{\n\tbool ethtype;\n\n\tif (ieee)\n\t\tethtype = qed_dcbx_ieee_app_ethtype(app_info_bitmap);\n\telse\n\t\tethtype = qed_dcbx_app_ethtype(app_info_bitmap);\n\n\treturn !!(ethtype && (proto_id == QED_ETH_TYPE_FCOE));\n}\n\nstatic bool qed_dcbx_roce_tlv(u32 app_info_bitmap, u16 proto_id, bool ieee)\n{\n\tbool ethtype;\n\n\tif (ieee)\n\t\tethtype = qed_dcbx_ieee_app_ethtype(app_info_bitmap);\n\telse\n\t\tethtype = qed_dcbx_app_ethtype(app_info_bitmap);\n\n\treturn !!(ethtype && (proto_id == QED_ETH_TYPE_ROCE));\n}\n\nstatic bool qed_dcbx_roce_v2_tlv(u32 app_info_bitmap, u16 proto_id, bool ieee)\n{\n\tbool port;\n\n\tif (ieee)\n\t\tport = qed_dcbx_ieee_app_port(app_info_bitmap,\n\t\t\t\t\t      DCBX_APP_SF_IEEE_UDP_PORT);\n\telse\n\t\tport = qed_dcbx_app_port(app_info_bitmap);\n\n\treturn !!(port && (proto_id == QED_UDP_PORT_TYPE_ROCE_V2));\n}\n\nstatic void\nqed_dcbx_dp_protocol(struct qed_hwfn *p_hwfn, struct qed_dcbx_results *p_data)\n{\n\tenum dcbx_protocol_type id;\n\tint i;\n\n\tDP_VERBOSE(p_hwfn, QED_MSG_DCB, \"DCBX negotiated: %d\\n\",\n\t\t   p_data->dcbx_enabled);\n\n\tfor (i = 0; i < ARRAY_SIZE(qed_dcbx_app_update); i++) {\n\t\tid = qed_dcbx_app_update[i].id;\n\n\t\tDP_VERBOSE(p_hwfn, QED_MSG_DCB,\n\t\t\t   \"%s info: update %d, enable %d, prio %d, tc %d, num_tc %d\\n\",\n\t\t\t   qed_dcbx_app_update[i].name, p_data->arr[id].update,\n\t\t\t   p_data->arr[id].enable, p_data->arr[id].priority,\n\t\t\t   p_data->arr[id].tc, p_hwfn->hw_info.num_active_tc);\n\t}\n}\n\nstatic void\nqed_dcbx_set_params(struct qed_dcbx_results *p_data,\n\t\t    struct qed_hwfn *p_hwfn, struct qed_ptt *p_ptt,\n\t\t    bool app_tlv, bool enable, u8 prio, u8 tc,\n\t\t    enum dcbx_protocol_type type,\n\t\t    enum qed_pci_personality personality)\n{\n\t \n\tp_data->arr[type].enable = enable;\n\tp_data->arr[type].priority = prio;\n\tp_data->arr[type].tc = tc;\n\tif (enable)\n\t\tp_data->arr[type].update = UPDATE_DCB;\n\telse\n\t\tp_data->arr[type].update = DONT_UPDATE_DCB_DSCP;\n\n\tif (test_bit(QED_MF_DONT_ADD_VLAN0_TAG, &p_hwfn->cdev->mf_bits))\n\t\tp_data->arr[type].dont_add_vlan0 = true;\n\n\t \n\tif (app_tlv && p_hwfn->hw_info.personality == personality)\n\t\tqed_hw_info_set_offload_tc(&p_hwfn->hw_info, tc);\n\n\t \n\tif (test_bit(QED_MF_UFP_SPECIFIC, &p_hwfn->cdev->mf_bits) &&\n\t    type == DCBX_PROTOCOL_ROCE) {\n\t\tqed_wr(p_hwfn, p_ptt, DORQ_REG_TAG1_OVRD_MODE, 1);\n\t\tqed_wr(p_hwfn, p_ptt, DORQ_REG_PF_PCP_BB_K2, prio << 1);\n\t}\n}\n\n \nstatic void\nqed_dcbx_update_app_info(struct qed_dcbx_results *p_data,\n\t\t\t struct qed_hwfn *p_hwfn, struct qed_ptt *p_ptt,\n\t\t\t bool app_tlv, bool enable, u8 prio, u8 tc,\n\t\t\t enum dcbx_protocol_type type)\n{\n\tenum qed_pci_personality personality;\n\tenum dcbx_protocol_type id;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(qed_dcbx_app_update); i++) {\n\t\tid = qed_dcbx_app_update[i].id;\n\n\t\tif (type != id)\n\t\t\tcontinue;\n\n\t\tpersonality = qed_dcbx_app_update[i].personality;\n\n\t\tqed_dcbx_set_params(p_data, p_hwfn, p_ptt, app_tlv, enable,\n\t\t\t\t    prio, tc, type, personality);\n\t}\n}\n\nstatic bool\nqed_dcbx_get_app_protocol_type(struct qed_hwfn *p_hwfn,\n\t\t\t       u32 app_prio_bitmap,\n\t\t\t       u16 id, enum dcbx_protocol_type *type, bool ieee)\n{\n\tif (qed_dcbx_fcoe_tlv(app_prio_bitmap, id, ieee)) {\n\t\t*type = DCBX_PROTOCOL_FCOE;\n\t} else if (qed_dcbx_roce_tlv(app_prio_bitmap, id, ieee)) {\n\t\t*type = DCBX_PROTOCOL_ROCE;\n\t} else if (qed_dcbx_iscsi_tlv(app_prio_bitmap, id, ieee)) {\n\t\t*type = DCBX_PROTOCOL_ISCSI;\n\t} else if (qed_dcbx_default_tlv(app_prio_bitmap, id, ieee)) {\n\t\t*type = DCBX_PROTOCOL_ETH;\n\t} else if (qed_dcbx_roce_v2_tlv(app_prio_bitmap, id, ieee)) {\n\t\t*type = DCBX_PROTOCOL_ROCE_V2;\n\t} else {\n\t\t*type = DCBX_MAX_PROTOCOL_TYPE;\n\t\tDP_VERBOSE(p_hwfn, QED_MSG_DCB,\n\t\t\t   \"No action required, App TLV entry = 0x%x\\n\",\n\t\t\t   app_prio_bitmap);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n \nstatic int\nqed_dcbx_process_tlv(struct qed_hwfn *p_hwfn, struct qed_ptt *p_ptt,\n\t\t     struct qed_dcbx_results *p_data,\n\t\t     struct dcbx_app_priority_entry *p_tbl,\n\t\t     u32 pri_tc_tbl, int count, u8 dcbx_version)\n{\n\tenum dcbx_protocol_type type;\n\tbool enable, ieee, eth_tlv;\n\tu8 tc, priority_map;\n\tu16 protocol_id;\n\tint priority;\n\tint i;\n\n\tDP_VERBOSE(p_hwfn, QED_MSG_DCB, \"Num APP entries = %d\\n\", count);\n\n\tieee = (dcbx_version == DCBX_CONFIG_VERSION_IEEE);\n\teth_tlv = false;\n\t \n\tfor (i = 0; i < count; i++) {\n\t\tprotocol_id = QED_MFW_GET_FIELD(p_tbl[i].entry,\n\t\t\t\t\t\tDCBX_APP_PROTOCOL_ID);\n\t\tpriority_map = QED_MFW_GET_FIELD(p_tbl[i].entry,\n\t\t\t\t\t\t DCBX_APP_PRI_MAP);\n\t\tpriority = ffs(priority_map) - 1;\n\t\tif (priority < 0) {\n\t\t\tDP_ERR(p_hwfn, \"Invalid priority\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\ttc = QED_DCBX_PRIO2TC(pri_tc_tbl, priority);\n\t\tif (qed_dcbx_get_app_protocol_type(p_hwfn, p_tbl[i].entry,\n\t\t\t\t\t\t   protocol_id, &type, ieee)) {\n\t\t\t \n\t\t\tif (type == DCBX_PROTOCOL_ETH) {\n\t\t\t\tenable = false;\n\t\t\t\teth_tlv = true;\n\t\t\t} else {\n\t\t\t\tenable = true;\n\t\t\t}\n\n\t\t\tqed_dcbx_update_app_info(p_data, p_hwfn, p_ptt, true,\n\t\t\t\t\t\t enable, priority, tc, type);\n\t\t}\n\t}\n\n\t \n\tif (test_bit(QED_MF_UFP_SPECIFIC, &p_hwfn->cdev->mf_bits) && !eth_tlv)\n\t\tp_data->arr[DCBX_PROTOCOL_ETH].tc = p_hwfn->ufp_info.tc;\n\n\t \n\ttc = p_data->arr[DCBX_PROTOCOL_ETH].tc;\n\tpriority = p_data->arr[DCBX_PROTOCOL_ETH].priority;\n\tfor (type = 0; type < DCBX_MAX_PROTOCOL_TYPE; type++) {\n\t\tif (p_data->arr[type].update)\n\t\t\tcontinue;\n\n\t\tenable = (type == DCBX_PROTOCOL_ETH) ? false : !!dcbx_version;\n\t\tqed_dcbx_update_app_info(p_data, p_hwfn, p_ptt, false, enable,\n\t\t\t\t\t priority, tc, type);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int\nqed_dcbx_process_mib_info(struct qed_hwfn *p_hwfn, struct qed_ptt *p_ptt)\n{\n\tstruct dcbx_app_priority_feature *p_app;\n\tstruct dcbx_app_priority_entry *p_tbl;\n\tstruct qed_dcbx_results data = { 0 };\n\tstruct dcbx_ets_feature *p_ets;\n\tstruct qed_hw_info *p_info;\n\tu32 pri_tc_tbl, flags;\n\tu8 dcbx_version;\n\tint num_entries;\n\tint rc = 0;\n\n\tflags = p_hwfn->p_dcbx_info->operational.flags;\n\tdcbx_version = QED_MFW_GET_FIELD(flags, DCBX_CONFIG_VERSION);\n\n\tp_app = &p_hwfn->p_dcbx_info->operational.features.app;\n\tp_tbl = p_app->app_pri_tbl;\n\n\tp_ets = &p_hwfn->p_dcbx_info->operational.features.ets;\n\tpri_tc_tbl = p_ets->pri_tc_tbl[0];\n\n\tp_info = &p_hwfn->hw_info;\n\tnum_entries = QED_MFW_GET_FIELD(p_app->flags, DCBX_APP_NUM_ENTRIES);\n\n\trc = qed_dcbx_process_tlv(p_hwfn, p_ptt, &data, p_tbl, pri_tc_tbl,\n\t\t\t\t  num_entries, dcbx_version);\n\tif (rc)\n\t\treturn rc;\n\n\tp_info->num_active_tc = QED_MFW_GET_FIELD(p_ets->flags,\n\t\t\t\t\t\t  DCBX_ETS_MAX_TCS);\n\tp_hwfn->qm_info.ooo_tc = QED_MFW_GET_FIELD(p_ets->flags, DCBX_OOO_TC);\n\tdata.pf_id = p_hwfn->rel_pf_id;\n\tdata.dcbx_enabled = !!dcbx_version;\n\n\tqed_dcbx_dp_protocol(p_hwfn, &data);\n\n\tmemcpy(&p_hwfn->p_dcbx_info->results, &data,\n\t       sizeof(struct qed_dcbx_results));\n\n\treturn 0;\n}\n\nstatic int\nqed_dcbx_copy_mib(struct qed_hwfn *p_hwfn,\n\t\t  struct qed_ptt *p_ptt,\n\t\t  struct qed_dcbx_mib_meta_data *p_data,\n\t\t  enum qed_mib_read_type type)\n{\n\tu32 prefix_seq_num, suffix_seq_num;\n\tint read_count = 0;\n\tint rc = 0;\n\n\t \n\tdo {\n\t\tif (type == QED_DCBX_REMOTE_LLDP_MIB) {\n\t\t\tqed_memcpy_from(p_hwfn, p_ptt, p_data->lldp_remote,\n\t\t\t\t\tp_data->addr, p_data->size);\n\t\t\tprefix_seq_num = p_data->lldp_remote->prefix_seq_num;\n\t\t\tsuffix_seq_num = p_data->lldp_remote->suffix_seq_num;\n\t\t} else {\n\t\t\tqed_memcpy_from(p_hwfn, p_ptt, p_data->mib,\n\t\t\t\t\tp_data->addr, p_data->size);\n\t\t\tprefix_seq_num = p_data->mib->prefix_seq_num;\n\t\t\tsuffix_seq_num = p_data->mib->suffix_seq_num;\n\t\t}\n\t\tread_count++;\n\n\t\tDP_VERBOSE(p_hwfn,\n\t\t\t   QED_MSG_DCB,\n\t\t\t   \"mib type = %d, try count = %d prefix seq num  = %d suffix seq num = %d\\n\",\n\t\t\t   type, read_count, prefix_seq_num, suffix_seq_num);\n\t} while ((prefix_seq_num != suffix_seq_num) &&\n\t\t (read_count < QED_DCBX_MAX_MIB_READ_TRY));\n\n\tif (read_count >= QED_DCBX_MAX_MIB_READ_TRY) {\n\t\tDP_ERR(p_hwfn,\n\t\t       \"MIB read err, mib type = %d, try count = %d prefix seq num = %d suffix seq num = %d\\n\",\n\t\t       type, read_count, prefix_seq_num, suffix_seq_num);\n\t\trc = -EIO;\n\t}\n\n\treturn rc;\n}\n\nstatic void\nqed_dcbx_get_priority_info(struct qed_hwfn *p_hwfn,\n\t\t\t   struct qed_dcbx_app_prio *p_prio,\n\t\t\t   struct qed_dcbx_results *p_results)\n{\n\tu8 val;\n\n\tp_prio->roce = QED_DCBX_INVALID_PRIORITY;\n\tp_prio->roce_v2 = QED_DCBX_INVALID_PRIORITY;\n\tp_prio->iscsi = QED_DCBX_INVALID_PRIORITY;\n\tp_prio->fcoe = QED_DCBX_INVALID_PRIORITY;\n\n\tif (p_results->arr[DCBX_PROTOCOL_ROCE].update &&\n\t    p_results->arr[DCBX_PROTOCOL_ROCE].enable)\n\t\tp_prio->roce = p_results->arr[DCBX_PROTOCOL_ROCE].priority;\n\n\tif (p_results->arr[DCBX_PROTOCOL_ROCE_V2].update &&\n\t    p_results->arr[DCBX_PROTOCOL_ROCE_V2].enable) {\n\t\tval = p_results->arr[DCBX_PROTOCOL_ROCE_V2].priority;\n\t\tp_prio->roce_v2 = val;\n\t}\n\n\tif (p_results->arr[DCBX_PROTOCOL_ISCSI].update &&\n\t    p_results->arr[DCBX_PROTOCOL_ISCSI].enable)\n\t\tp_prio->iscsi = p_results->arr[DCBX_PROTOCOL_ISCSI].priority;\n\n\tif (p_results->arr[DCBX_PROTOCOL_FCOE].update &&\n\t    p_results->arr[DCBX_PROTOCOL_FCOE].enable)\n\t\tp_prio->fcoe = p_results->arr[DCBX_PROTOCOL_FCOE].priority;\n\n\tif (p_results->arr[DCBX_PROTOCOL_ETH].update &&\n\t    p_results->arr[DCBX_PROTOCOL_ETH].enable)\n\t\tp_prio->eth = p_results->arr[DCBX_PROTOCOL_ETH].priority;\n\n\tDP_VERBOSE(p_hwfn, QED_MSG_DCB,\n\t\t   \"Priorities: iscsi %d, roce %d, roce v2 %d, fcoe %d, eth %d\\n\",\n\t\t   p_prio->iscsi, p_prio->roce, p_prio->roce_v2, p_prio->fcoe,\n\t\t   p_prio->eth);\n}\n\nstatic void\nqed_dcbx_get_app_data(struct qed_hwfn *p_hwfn,\n\t\t      struct dcbx_app_priority_feature *p_app,\n\t\t      struct dcbx_app_priority_entry *p_tbl,\n\t\t      struct qed_dcbx_params *p_params, bool ieee)\n{\n\tstruct qed_app_entry *entry;\n\tu8 pri_map;\n\tint i;\n\n\tp_params->app_willing = QED_MFW_GET_FIELD(p_app->flags,\n\t\t\t\t\t\t  DCBX_APP_WILLING);\n\tp_params->app_valid = QED_MFW_GET_FIELD(p_app->flags, DCBX_APP_ENABLED);\n\tp_params->app_error = QED_MFW_GET_FIELD(p_app->flags, DCBX_APP_ERROR);\n\tp_params->num_app_entries = QED_MFW_GET_FIELD(p_app->flags,\n\t\t\t\t\t\t      DCBX_APP_NUM_ENTRIES);\n\tfor (i = 0; i < DCBX_MAX_APP_PROTOCOL; i++) {\n\t\tentry = &p_params->app_entry[i];\n\t\tif (ieee) {\n\t\t\tu8 sf_ieee;\n\t\t\tu32 val;\n\n\t\t\tsf_ieee = QED_MFW_GET_FIELD(p_tbl[i].entry,\n\t\t\t\t\t\t    DCBX_APP_SF_IEEE);\n\t\t\tswitch (sf_ieee) {\n\t\t\tcase DCBX_APP_SF_IEEE_RESERVED:\n\t\t\t\t \n\t\t\t\tval = QED_MFW_GET_FIELD(p_tbl[i].entry,\n\t\t\t\t\t\t\tDCBX_APP_SF);\n\t\t\t\tentry->sf_ieee = val ?\n\t\t\t\t    QED_DCBX_SF_IEEE_TCP_UDP_PORT :\n\t\t\t\t    QED_DCBX_SF_IEEE_ETHTYPE;\n\t\t\t\tbreak;\n\t\t\tcase DCBX_APP_SF_IEEE_ETHTYPE:\n\t\t\t\tentry->sf_ieee = QED_DCBX_SF_IEEE_ETHTYPE;\n\t\t\t\tbreak;\n\t\t\tcase DCBX_APP_SF_IEEE_TCP_PORT:\n\t\t\t\tentry->sf_ieee = QED_DCBX_SF_IEEE_TCP_PORT;\n\t\t\t\tbreak;\n\t\t\tcase DCBX_APP_SF_IEEE_UDP_PORT:\n\t\t\t\tentry->sf_ieee = QED_DCBX_SF_IEEE_UDP_PORT;\n\t\t\t\tbreak;\n\t\t\tcase DCBX_APP_SF_IEEE_TCP_UDP_PORT:\n\t\t\t\tentry->sf_ieee = QED_DCBX_SF_IEEE_TCP_UDP_PORT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tentry->ethtype = !(QED_MFW_GET_FIELD(p_tbl[i].entry,\n\t\t\t\t\t\t\t     DCBX_APP_SF));\n\t\t}\n\n\t\tpri_map = QED_MFW_GET_FIELD(p_tbl[i].entry, DCBX_APP_PRI_MAP);\n\t\tentry->prio = ffs(pri_map) - 1;\n\t\tentry->proto_id = QED_MFW_GET_FIELD(p_tbl[i].entry,\n\t\t\t\t\t\t    DCBX_APP_PROTOCOL_ID);\n\t\tqed_dcbx_get_app_protocol_type(p_hwfn, p_tbl[i].entry,\n\t\t\t\t\t       entry->proto_id,\n\t\t\t\t\t       &entry->proto_type, ieee);\n\t}\n\n\tDP_VERBOSE(p_hwfn, QED_MSG_DCB,\n\t\t   \"APP params: willing %d, valid %d error = %d\\n\",\n\t\t   p_params->app_willing, p_params->app_valid,\n\t\t   p_params->app_error);\n}\n\nstatic void\nqed_dcbx_get_pfc_data(struct qed_hwfn *p_hwfn,\n\t\t      u32 pfc, struct qed_dcbx_params *p_params)\n{\n\tu8 pfc_map;\n\n\tp_params->pfc.willing = QED_MFW_GET_FIELD(pfc, DCBX_PFC_WILLING);\n\tp_params->pfc.max_tc = QED_MFW_GET_FIELD(pfc, DCBX_PFC_CAPS);\n\tp_params->pfc.enabled = QED_MFW_GET_FIELD(pfc, DCBX_PFC_ENABLED);\n\tpfc_map = QED_MFW_GET_FIELD(pfc, DCBX_PFC_PRI_EN_BITMAP);\n\tp_params->pfc.prio[0] = !!(pfc_map & DCBX_PFC_PRI_EN_BITMAP_PRI_0);\n\tp_params->pfc.prio[1] = !!(pfc_map & DCBX_PFC_PRI_EN_BITMAP_PRI_1);\n\tp_params->pfc.prio[2] = !!(pfc_map & DCBX_PFC_PRI_EN_BITMAP_PRI_2);\n\tp_params->pfc.prio[3] = !!(pfc_map & DCBX_PFC_PRI_EN_BITMAP_PRI_3);\n\tp_params->pfc.prio[4] = !!(pfc_map & DCBX_PFC_PRI_EN_BITMAP_PRI_4);\n\tp_params->pfc.prio[5] = !!(pfc_map & DCBX_PFC_PRI_EN_BITMAP_PRI_5);\n\tp_params->pfc.prio[6] = !!(pfc_map & DCBX_PFC_PRI_EN_BITMAP_PRI_6);\n\tp_params->pfc.prio[7] = !!(pfc_map & DCBX_PFC_PRI_EN_BITMAP_PRI_7);\n\n\tDP_VERBOSE(p_hwfn, QED_MSG_DCB,\n\t\t   \"PFC params: willing %d, pfc_bitmap %u max_tc = %u enabled = %d\\n\",\n\t\t   p_params->pfc.willing, pfc_map, p_params->pfc.max_tc,\n\t\t   p_params->pfc.enabled);\n}\n\nstatic void\nqed_dcbx_get_ets_data(struct qed_hwfn *p_hwfn,\n\t\t      struct dcbx_ets_feature *p_ets,\n\t\t      struct qed_dcbx_params *p_params)\n{\n\t__be32 bw_map[2], tsa_map[2];\n\tu32 pri_map;\n\tint i;\n\n\tp_params->ets_willing = QED_MFW_GET_FIELD(p_ets->flags,\n\t\t\t\t\t\t  DCBX_ETS_WILLING);\n\tp_params->ets_enabled = QED_MFW_GET_FIELD(p_ets->flags,\n\t\t\t\t\t\t  DCBX_ETS_ENABLED);\n\tp_params->ets_cbs = QED_MFW_GET_FIELD(p_ets->flags, DCBX_ETS_CBS);\n\tp_params->max_ets_tc = QED_MFW_GET_FIELD(p_ets->flags,\n\t\t\t\t\t\t DCBX_ETS_MAX_TCS);\n\tDP_VERBOSE(p_hwfn, QED_MSG_DCB,\n\t\t   \"ETS params: willing %d, enabled = %d ets_cbs %d pri_tc_tbl_0 %x max_ets_tc %d\\n\",\n\t\t   p_params->ets_willing, p_params->ets_enabled,\n\t\t   p_params->ets_cbs, p_ets->pri_tc_tbl[0],\n\t\t   p_params->max_ets_tc);\n\n\tif (p_params->ets_enabled && !p_params->max_ets_tc) {\n\t\tp_params->max_ets_tc = QED_MAX_PFC_PRIORITIES;\n\t\tDP_VERBOSE(p_hwfn, QED_MSG_DCB,\n\t\t\t   \"ETS params: max_ets_tc is forced to %d\\n\",\n\t\tp_params->max_ets_tc);\n\t}\n\n\t \n\tcpu_to_be32_array(bw_map, p_ets->tc_bw_tbl, 2);\n\tcpu_to_be32_array(tsa_map, p_ets->tc_tsa_tbl, 2);\n\tpri_map = p_ets->pri_tc_tbl[0];\n\n\tfor (i = 0; i < QED_MAX_PFC_PRIORITIES; i++) {\n\t\tp_params->ets_tc_bw_tbl[i] = ((u8 *)bw_map)[i];\n\t\tp_params->ets_tc_tsa_tbl[i] = ((u8 *)tsa_map)[i];\n\t\tp_params->ets_pri_tc_tbl[i] = QED_DCBX_PRIO2TC(pri_map, i);\n\t\tDP_VERBOSE(p_hwfn, QED_MSG_DCB,\n\t\t\t   \"elem %d  bw_tbl %x tsa_tbl %x\\n\",\n\t\t\t   i, p_params->ets_tc_bw_tbl[i],\n\t\t\t   p_params->ets_tc_tsa_tbl[i]);\n\t}\n}\n\nstatic void\nqed_dcbx_get_common_params(struct qed_hwfn *p_hwfn,\n\t\t\t   struct dcbx_app_priority_feature *p_app,\n\t\t\t   struct dcbx_app_priority_entry *p_tbl,\n\t\t\t   struct dcbx_ets_feature *p_ets,\n\t\t\t   u32 pfc, struct qed_dcbx_params *p_params, bool ieee)\n{\n\tqed_dcbx_get_app_data(p_hwfn, p_app, p_tbl, p_params, ieee);\n\tqed_dcbx_get_ets_data(p_hwfn, p_ets, p_params);\n\tqed_dcbx_get_pfc_data(p_hwfn, pfc, p_params);\n}\n\nstatic void\nqed_dcbx_get_local_params(struct qed_hwfn *p_hwfn, struct qed_dcbx_get *params)\n{\n\tstruct dcbx_features *p_feat;\n\n\tp_feat = &p_hwfn->p_dcbx_info->local_admin.features;\n\tqed_dcbx_get_common_params(p_hwfn, &p_feat->app,\n\t\t\t\t   p_feat->app.app_pri_tbl, &p_feat->ets,\n\t\t\t\t   p_feat->pfc, &params->local.params, false);\n\tparams->local.valid = true;\n}\n\nstatic void\nqed_dcbx_get_remote_params(struct qed_hwfn *p_hwfn, struct qed_dcbx_get *params)\n{\n\tstruct dcbx_features *p_feat;\n\n\tp_feat = &p_hwfn->p_dcbx_info->remote.features;\n\tqed_dcbx_get_common_params(p_hwfn, &p_feat->app,\n\t\t\t\t   p_feat->app.app_pri_tbl, &p_feat->ets,\n\t\t\t\t   p_feat->pfc, &params->remote.params, false);\n\tparams->remote.valid = true;\n}\n\nstatic void\nqed_dcbx_get_operational_params(struct qed_hwfn *p_hwfn,\n\t\t\t\tstruct qed_dcbx_get *params)\n{\n\tstruct qed_dcbx_operational_params *p_operational;\n\tstruct qed_dcbx_results *p_results;\n\tstruct dcbx_features *p_feat;\n\tbool enabled, err;\n\tu32 flags;\n\tbool val;\n\n\tflags = p_hwfn->p_dcbx_info->operational.flags;\n\n\t \n\tp_operational = &params->operational;\n\tenabled = !!(QED_MFW_GET_FIELD(flags, DCBX_CONFIG_VERSION) !=\n\t\t     DCBX_CONFIG_VERSION_DISABLED);\n\tif (!enabled) {\n\t\tp_operational->enabled = enabled;\n\t\tp_operational->valid = false;\n\t\tDP_VERBOSE(p_hwfn, QED_MSG_DCB, \"Dcbx is disabled\\n\");\n\t\treturn;\n\t}\n\n\tp_feat = &p_hwfn->p_dcbx_info->operational.features;\n\tp_results = &p_hwfn->p_dcbx_info->results;\n\n\tval = !!(QED_MFW_GET_FIELD(flags, DCBX_CONFIG_VERSION) ==\n\t\t DCBX_CONFIG_VERSION_IEEE);\n\tp_operational->ieee = val;\n\tval = !!(QED_MFW_GET_FIELD(flags, DCBX_CONFIG_VERSION) ==\n\t\t DCBX_CONFIG_VERSION_CEE);\n\tp_operational->cee = val;\n\n\tval = !!(QED_MFW_GET_FIELD(flags, DCBX_CONFIG_VERSION) ==\n\t\t DCBX_CONFIG_VERSION_STATIC);\n\tp_operational->local = val;\n\n\tDP_VERBOSE(p_hwfn, QED_MSG_DCB,\n\t\t   \"Version support: ieee %d, cee %d, static %d\\n\",\n\t\t   p_operational->ieee, p_operational->cee,\n\t\t   p_operational->local);\n\n\tqed_dcbx_get_common_params(p_hwfn, &p_feat->app,\n\t\t\t\t   p_feat->app.app_pri_tbl, &p_feat->ets,\n\t\t\t\t   p_feat->pfc, &params->operational.params,\n\t\t\t\t   p_operational->ieee);\n\tqed_dcbx_get_priority_info(p_hwfn, &p_operational->app_prio, p_results);\n\terr = QED_MFW_GET_FIELD(p_feat->app.flags, DCBX_APP_ERROR);\n\tp_operational->err = err;\n\tp_operational->enabled = enabled;\n\tp_operational->valid = true;\n}\n\nstatic void\nqed_dcbx_get_local_lldp_params(struct qed_hwfn *p_hwfn,\n\t\t\t       struct qed_dcbx_get *params)\n{\n\tstruct lldp_config_params_s *p_local;\n\n\tp_local = &p_hwfn->p_dcbx_info->lldp_local[LLDP_NEAREST_BRIDGE];\n\n\tmemcpy(params->lldp_local.local_chassis_id, p_local->local_chassis_id,\n\t       sizeof(p_local->local_chassis_id));\n\tmemcpy(params->lldp_local.local_port_id, p_local->local_port_id,\n\t       sizeof(p_local->local_port_id));\n}\n\nstatic void\nqed_dcbx_get_remote_lldp_params(struct qed_hwfn *p_hwfn,\n\t\t\t\tstruct qed_dcbx_get *params)\n{\n\tstruct lldp_status_params_s *p_remote;\n\n\tp_remote = &p_hwfn->p_dcbx_info->lldp_remote[LLDP_NEAREST_BRIDGE];\n\n\tmemcpy(params->lldp_remote.peer_chassis_id, p_remote->peer_chassis_id,\n\t       sizeof(p_remote->peer_chassis_id));\n\tmemcpy(params->lldp_remote.peer_port_id, p_remote->peer_port_id,\n\t       sizeof(p_remote->peer_port_id));\n}\n\nstatic int\nqed_dcbx_get_params(struct qed_hwfn *p_hwfn, struct qed_dcbx_get *p_params,\n\t\t    enum qed_mib_read_type type)\n{\n\tswitch (type) {\n\tcase QED_DCBX_REMOTE_MIB:\n\t\tqed_dcbx_get_remote_params(p_hwfn, p_params);\n\t\tbreak;\n\tcase QED_DCBX_LOCAL_MIB:\n\t\tqed_dcbx_get_local_params(p_hwfn, p_params);\n\t\tbreak;\n\tcase QED_DCBX_OPERATIONAL_MIB:\n\t\tqed_dcbx_get_operational_params(p_hwfn, p_params);\n\t\tbreak;\n\tcase QED_DCBX_REMOTE_LLDP_MIB:\n\t\tqed_dcbx_get_remote_lldp_params(p_hwfn, p_params);\n\t\tbreak;\n\tcase QED_DCBX_LOCAL_LLDP_MIB:\n\t\tqed_dcbx_get_local_lldp_params(p_hwfn, p_params);\n\t\tbreak;\n\tdefault:\n\t\tDP_ERR(p_hwfn, \"MIB read err, unknown mib type %d\\n\", type);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nqed_dcbx_read_local_lldp_mib(struct qed_hwfn *p_hwfn, struct qed_ptt *p_ptt)\n{\n\tstruct qed_dcbx_mib_meta_data data;\n\n\tmemset(&data, 0, sizeof(data));\n\tdata.addr = p_hwfn->mcp_info->port_addr + offsetof(struct public_port,\n\t\t\t\t\t\t\t   lldp_config_params);\n\tdata.lldp_local = p_hwfn->p_dcbx_info->lldp_local;\n\tdata.size = sizeof(struct lldp_config_params_s);\n\tqed_memcpy_from(p_hwfn, p_ptt, data.lldp_local, data.addr, data.size);\n\n\treturn 0;\n}\n\nstatic int\nqed_dcbx_read_remote_lldp_mib(struct qed_hwfn *p_hwfn,\n\t\t\t      struct qed_ptt *p_ptt,\n\t\t\t      enum qed_mib_read_type type)\n{\n\tstruct qed_dcbx_mib_meta_data data;\n\tint rc = 0;\n\n\tmemset(&data, 0, sizeof(data));\n\tdata.addr = p_hwfn->mcp_info->port_addr + offsetof(struct public_port,\n\t\t\t\t\t\t\t   lldp_status_params);\n\tdata.lldp_remote = p_hwfn->p_dcbx_info->lldp_remote;\n\tdata.size = sizeof(struct lldp_status_params_s);\n\trc = qed_dcbx_copy_mib(p_hwfn, p_ptt, &data, type);\n\n\treturn rc;\n}\n\nstatic int\nqed_dcbx_read_operational_mib(struct qed_hwfn *p_hwfn,\n\t\t\t      struct qed_ptt *p_ptt,\n\t\t\t      enum qed_mib_read_type type)\n{\n\tstruct qed_dcbx_mib_meta_data data;\n\tint rc = 0;\n\n\tmemset(&data, 0, sizeof(data));\n\tdata.addr = p_hwfn->mcp_info->port_addr +\n\t\t    offsetof(struct public_port, operational_dcbx_mib);\n\tdata.mib = &p_hwfn->p_dcbx_info->operational;\n\tdata.size = sizeof(struct dcbx_mib);\n\trc = qed_dcbx_copy_mib(p_hwfn, p_ptt, &data, type);\n\n\treturn rc;\n}\n\nstatic int\nqed_dcbx_read_remote_mib(struct qed_hwfn *p_hwfn,\n\t\t\t struct qed_ptt *p_ptt, enum qed_mib_read_type type)\n{\n\tstruct qed_dcbx_mib_meta_data data;\n\tint rc = 0;\n\n\tmemset(&data, 0, sizeof(data));\n\tdata.addr = p_hwfn->mcp_info->port_addr +\n\t\t    offsetof(struct public_port, remote_dcbx_mib);\n\tdata.mib = &p_hwfn->p_dcbx_info->remote;\n\tdata.size = sizeof(struct dcbx_mib);\n\trc = qed_dcbx_copy_mib(p_hwfn, p_ptt, &data, type);\n\n\treturn rc;\n}\n\nstatic int\nqed_dcbx_read_local_mib(struct qed_hwfn *p_hwfn, struct qed_ptt *p_ptt)\n{\n\tstruct qed_dcbx_mib_meta_data data;\n\n\tmemset(&data, 0, sizeof(data));\n\tdata.addr = p_hwfn->mcp_info->port_addr +\n\t\t    offsetof(struct public_port, local_admin_dcbx_mib);\n\tdata.local_admin = &p_hwfn->p_dcbx_info->local_admin;\n\tdata.size = sizeof(struct dcbx_local_params);\n\tqed_memcpy_from(p_hwfn, p_ptt, data.local_admin, data.addr, data.size);\n\n\treturn 0;\n}\n\nstatic int qed_dcbx_read_mib(struct qed_hwfn *p_hwfn,\n\t\t\t     struct qed_ptt *p_ptt, enum qed_mib_read_type type)\n{\n\tint rc = -EINVAL;\n\n\tswitch (type) {\n\tcase QED_DCBX_OPERATIONAL_MIB:\n\t\trc = qed_dcbx_read_operational_mib(p_hwfn, p_ptt, type);\n\t\tbreak;\n\tcase QED_DCBX_REMOTE_MIB:\n\t\trc = qed_dcbx_read_remote_mib(p_hwfn, p_ptt, type);\n\t\tbreak;\n\tcase QED_DCBX_LOCAL_MIB:\n\t\trc = qed_dcbx_read_local_mib(p_hwfn, p_ptt);\n\t\tbreak;\n\tcase QED_DCBX_REMOTE_LLDP_MIB:\n\t\trc = qed_dcbx_read_remote_lldp_mib(p_hwfn, p_ptt, type);\n\t\tbreak;\n\tcase QED_DCBX_LOCAL_LLDP_MIB:\n\t\trc = qed_dcbx_read_local_lldp_mib(p_hwfn, p_ptt);\n\t\tbreak;\n\tdefault:\n\t\tDP_ERR(p_hwfn, \"MIB read err, unknown mib type %d\\n\", type);\n\t}\n\n\treturn rc;\n}\n\nstatic void qed_dcbx_aen(struct qed_hwfn *hwfn, u32 mib_type)\n{\n\tstruct qed_common_cb_ops *op = hwfn->cdev->protocol_ops.common;\n\tvoid *cookie = hwfn->cdev->ops_cookie;\n\n\tif (cookie && op->dcbx_aen)\n\t\top->dcbx_aen(cookie, &hwfn->p_dcbx_info->get, mib_type);\n}\n\n \nint\nqed_dcbx_mib_update_event(struct qed_hwfn *p_hwfn,\n\t\t\t  struct qed_ptt *p_ptt, enum qed_mib_read_type type)\n{\n\tint rc = 0;\n\n\trc = qed_dcbx_read_mib(p_hwfn, p_ptt, type);\n\tif (rc)\n\t\treturn rc;\n\n\tif (type == QED_DCBX_OPERATIONAL_MIB) {\n\t\trc = qed_dcbx_process_mib_info(p_hwfn, p_ptt);\n\t\tif (!rc) {\n\t\t\t \n\t\t\tqed_qm_reconf(p_hwfn, p_ptt);\n\n\t\t\t \n\t\t\tqed_sp_pf_update(p_hwfn);\n\n\t\t\t \n\t\t\tif (p_hwfn->hw_info.personality ==\n\t\t\t    QED_PCI_ETH_ROCE)\n\t\t\t\tqed_roce_dpm_dcbx(p_hwfn, p_ptt);\n\t\t}\n\t}\n\n\tqed_dcbx_get_params(p_hwfn, &p_hwfn->p_dcbx_info->get, type);\n\n\tif (type == QED_DCBX_OPERATIONAL_MIB) {\n\t\tstruct qed_dcbx_results *p_data;\n\t\tu16 val;\n\n\t\t \n\t\tp_data = &p_hwfn->p_dcbx_info->results;\n\t\tval = (0x1 << p_data->arr[DCBX_PROTOCOL_ROCE].tc) |\n\t\t      (0x1 << p_data->arr[DCBX_PROTOCOL_ROCE_V2].tc);\n\t\tval <<= NIG_REG_TX_EDPM_CTRL_TX_EDPM_TC_EN_SHIFT;\n\t\tval |= NIG_REG_TX_EDPM_CTRL_TX_EDPM_EN;\n\t\tqed_wr(p_hwfn, p_ptt, NIG_REG_TX_EDPM_CTRL, val);\n\t}\n\n\tqed_dcbx_aen(p_hwfn, type);\n\n\treturn rc;\n}\n\nint qed_dcbx_info_alloc(struct qed_hwfn *p_hwfn)\n{\n\tp_hwfn->p_dcbx_info = kzalloc(sizeof(*p_hwfn->p_dcbx_info), GFP_KERNEL);\n\tif (!p_hwfn->p_dcbx_info)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nvoid qed_dcbx_info_free(struct qed_hwfn *p_hwfn)\n{\n\tkfree(p_hwfn->p_dcbx_info);\n\tp_hwfn->p_dcbx_info = NULL;\n}\n\nstatic void qed_dcbx_update_protocol_data(struct protocol_dcb_data *p_data,\n\t\t\t\t\t  struct qed_dcbx_results *p_src,\n\t\t\t\t\t  enum dcbx_protocol_type type)\n{\n\tp_data->dcb_enable_flag = p_src->arr[type].enable;\n\tp_data->dcb_priority = p_src->arr[type].priority;\n\tp_data->dcb_tc = p_src->arr[type].tc;\n\tp_data->dcb_dont_add_vlan0 = p_src->arr[type].dont_add_vlan0;\n}\n\n \nvoid qed_dcbx_set_pf_update_params(struct qed_dcbx_results *p_src,\n\t\t\t\t   struct pf_update_ramrod_data *p_dest)\n{\n\tstruct protocol_dcb_data *p_dcb_data;\n\tu8 update_flag;\n\n\tupdate_flag = p_src->arr[DCBX_PROTOCOL_FCOE].update;\n\tp_dest->update_fcoe_dcb_data_mode = update_flag;\n\n\tupdate_flag = p_src->arr[DCBX_PROTOCOL_ROCE].update;\n\tp_dest->update_roce_dcb_data_mode = update_flag;\n\n\tupdate_flag = p_src->arr[DCBX_PROTOCOL_ROCE_V2].update;\n\tp_dest->update_rroce_dcb_data_mode = update_flag;\n\n\tupdate_flag = p_src->arr[DCBX_PROTOCOL_ISCSI].update;\n\tp_dest->update_iscsi_dcb_data_mode = update_flag;\n\tupdate_flag = p_src->arr[DCBX_PROTOCOL_ETH].update;\n\tp_dest->update_eth_dcb_data_mode = update_flag;\n\n\tp_dcb_data = &p_dest->fcoe_dcb_data;\n\tqed_dcbx_update_protocol_data(p_dcb_data, p_src, DCBX_PROTOCOL_FCOE);\n\tp_dcb_data = &p_dest->roce_dcb_data;\n\tqed_dcbx_update_protocol_data(p_dcb_data, p_src, DCBX_PROTOCOL_ROCE);\n\tp_dcb_data = &p_dest->rroce_dcb_data;\n\tqed_dcbx_update_protocol_data(p_dcb_data, p_src, DCBX_PROTOCOL_ROCE_V2);\n\tp_dcb_data = &p_dest->iscsi_dcb_data;\n\tqed_dcbx_update_protocol_data(p_dcb_data, p_src, DCBX_PROTOCOL_ISCSI);\n\tp_dcb_data = &p_dest->eth_dcb_data;\n\tqed_dcbx_update_protocol_data(p_dcb_data, p_src, DCBX_PROTOCOL_ETH);\n}\n\nu8 qed_dcbx_get_priority_tc(struct qed_hwfn *p_hwfn, u8 pri)\n{\n\tstruct qed_dcbx_get *dcbx_info = &p_hwfn->p_dcbx_info->get;\n\n\tif (pri >= QED_MAX_PFC_PRIORITIES) {\n\t\tDP_ERR(p_hwfn, \"Invalid priority %d\\n\", pri);\n\t\treturn QED_DCBX_DEFAULT_TC;\n\t}\n\n\tif (!dcbx_info->operational.valid) {\n\t\tDP_VERBOSE(p_hwfn, QED_MSG_DCB,\n\t\t\t   \"Dcbx parameters not available\\n\");\n\t\treturn QED_DCBX_DEFAULT_TC;\n\t}\n\n\treturn dcbx_info->operational.params.ets_pri_tc_tbl[pri];\n}\n\n#ifdef CONFIG_DCB\nstatic int qed_dcbx_query_params(struct qed_hwfn *p_hwfn,\n\t\t\t\t struct qed_dcbx_get *p_get,\n\t\t\t\t enum qed_mib_read_type type)\n{\n\tstruct qed_ptt *p_ptt;\n\tint rc;\n\n\tif (IS_VF(p_hwfn->cdev))\n\t\treturn -EINVAL;\n\n\tp_ptt = qed_ptt_acquire(p_hwfn);\n\tif (!p_ptt)\n\t\treturn -EBUSY;\n\n\trc = qed_dcbx_read_mib(p_hwfn, p_ptt, type);\n\tif (rc)\n\t\tgoto out;\n\n\trc = qed_dcbx_get_params(p_hwfn, p_get, type);\n\nout:\n\tqed_ptt_release(p_hwfn, p_ptt);\n\treturn rc;\n}\n\nstatic void\nqed_dcbx_set_pfc_data(struct qed_hwfn *p_hwfn,\n\t\t      u32 *pfc, struct qed_dcbx_params *p_params)\n{\n\tu8 pfc_map = 0;\n\tint i;\n\n\t*pfc &= ~DCBX_PFC_ERROR_MASK;\n\n\tif (p_params->pfc.willing)\n\t\t*pfc |= DCBX_PFC_WILLING_MASK;\n\telse\n\t\t*pfc &= ~DCBX_PFC_WILLING_MASK;\n\n\tif (p_params->pfc.enabled)\n\t\t*pfc |= DCBX_PFC_ENABLED_MASK;\n\telse\n\t\t*pfc &= ~DCBX_PFC_ENABLED_MASK;\n\n\t*pfc &= ~DCBX_PFC_CAPS_MASK;\n\t*pfc |= (u32)p_params->pfc.max_tc << DCBX_PFC_CAPS_SHIFT;\n\n\tfor (i = 0; i < QED_MAX_PFC_PRIORITIES; i++)\n\t\tif (p_params->pfc.prio[i])\n\t\t\tpfc_map |= BIT(i);\n\n\t*pfc &= ~DCBX_PFC_PRI_EN_BITMAP_MASK;\n\t*pfc |= (pfc_map << DCBX_PFC_PRI_EN_BITMAP_SHIFT);\n\n\tDP_VERBOSE(p_hwfn, QED_MSG_DCB, \"pfc = 0x%x\\n\", *pfc);\n}\n\nstatic void\nqed_dcbx_set_ets_data(struct qed_hwfn *p_hwfn,\n\t\t      struct dcbx_ets_feature *p_ets,\n\t\t      struct qed_dcbx_params *p_params)\n{\n\t__be32 bw_map[2], tsa_map[2];\n\tu32 val;\n\tint i;\n\n\tif (p_params->ets_willing)\n\t\tp_ets->flags |= DCBX_ETS_WILLING_MASK;\n\telse\n\t\tp_ets->flags &= ~DCBX_ETS_WILLING_MASK;\n\n\tif (p_params->ets_cbs)\n\t\tp_ets->flags |= DCBX_ETS_CBS_MASK;\n\telse\n\t\tp_ets->flags &= ~DCBX_ETS_CBS_MASK;\n\n\tif (p_params->ets_enabled)\n\t\tp_ets->flags |= DCBX_ETS_ENABLED_MASK;\n\telse\n\t\tp_ets->flags &= ~DCBX_ETS_ENABLED_MASK;\n\n\tp_ets->flags &= ~DCBX_ETS_MAX_TCS_MASK;\n\tp_ets->flags |= (u32)p_params->max_ets_tc << DCBX_ETS_MAX_TCS_SHIFT;\n\n\tp_ets->pri_tc_tbl[0] = 0;\n\n\tfor (i = 0; i < QED_MAX_PFC_PRIORITIES; i++) {\n\t\t((u8 *)bw_map)[i] = p_params->ets_tc_bw_tbl[i];\n\t\t((u8 *)tsa_map)[i] = p_params->ets_tc_tsa_tbl[i];\n\n\t\t \n\t\tval = (((u32)p_params->ets_pri_tc_tbl[i]) << ((7 - i) * 4));\n\t\tp_ets->pri_tc_tbl[0] |= val;\n\t}\n\n\tbe32_to_cpu_array(p_ets->tc_bw_tbl, bw_map, 2);\n\tbe32_to_cpu_array(p_ets->tc_tsa_tbl, tsa_map, 2);\n}\n\nstatic void\nqed_dcbx_set_app_data(struct qed_hwfn *p_hwfn,\n\t\t      struct dcbx_app_priority_feature *p_app,\n\t\t      struct qed_dcbx_params *p_params, bool ieee)\n{\n\tu32 *entry;\n\tint i;\n\n\tif (p_params->app_willing)\n\t\tp_app->flags |= DCBX_APP_WILLING_MASK;\n\telse\n\t\tp_app->flags &= ~DCBX_APP_WILLING_MASK;\n\n\tif (p_params->app_valid)\n\t\tp_app->flags |= DCBX_APP_ENABLED_MASK;\n\telse\n\t\tp_app->flags &= ~DCBX_APP_ENABLED_MASK;\n\n\tp_app->flags &= ~DCBX_APP_NUM_ENTRIES_MASK;\n\tp_app->flags |= (u32)p_params->num_app_entries <<\n\t    DCBX_APP_NUM_ENTRIES_SHIFT;\n\n\tfor (i = 0; i < DCBX_MAX_APP_PROTOCOL; i++) {\n\t\tentry = &p_app->app_pri_tbl[i].entry;\n\t\t*entry = 0;\n\t\tif (ieee) {\n\t\t\t*entry &= ~(DCBX_APP_SF_IEEE_MASK | DCBX_APP_SF_MASK);\n\t\t\tswitch (p_params->app_entry[i].sf_ieee) {\n\t\t\tcase QED_DCBX_SF_IEEE_ETHTYPE:\n\t\t\t\t*entry |= ((u32)DCBX_APP_SF_IEEE_ETHTYPE <<\n\t\t\t\t\t   DCBX_APP_SF_IEEE_SHIFT);\n\t\t\t\t*entry |= ((u32)DCBX_APP_SF_ETHTYPE <<\n\t\t\t\t\t   DCBX_APP_SF_SHIFT);\n\t\t\t\tbreak;\n\t\t\tcase QED_DCBX_SF_IEEE_TCP_PORT:\n\t\t\t\t*entry |= ((u32)DCBX_APP_SF_IEEE_TCP_PORT <<\n\t\t\t\t\t   DCBX_APP_SF_IEEE_SHIFT);\n\t\t\t\t*entry |= ((u32)DCBX_APP_SF_PORT <<\n\t\t\t\t\t   DCBX_APP_SF_SHIFT);\n\t\t\t\tbreak;\n\t\t\tcase QED_DCBX_SF_IEEE_UDP_PORT:\n\t\t\t\t*entry |= ((u32)DCBX_APP_SF_IEEE_UDP_PORT <<\n\t\t\t\t\t   DCBX_APP_SF_IEEE_SHIFT);\n\t\t\t\t*entry |= ((u32)DCBX_APP_SF_PORT <<\n\t\t\t\t\t   DCBX_APP_SF_SHIFT);\n\t\t\t\tbreak;\n\t\t\tcase QED_DCBX_SF_IEEE_TCP_UDP_PORT:\n\t\t\t\t*entry |= ((u32)DCBX_APP_SF_IEEE_TCP_UDP_PORT <<\n\t\t\t\t\t   DCBX_APP_SF_IEEE_SHIFT);\n\t\t\t\t*entry |= ((u32)DCBX_APP_SF_PORT <<\n\t\t\t\t\t   DCBX_APP_SF_SHIFT);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\t*entry &= ~DCBX_APP_SF_MASK;\n\t\t\tif (p_params->app_entry[i].ethtype)\n\t\t\t\t*entry |= ((u32)DCBX_APP_SF_ETHTYPE <<\n\t\t\t\t\t   DCBX_APP_SF_SHIFT);\n\t\t\telse\n\t\t\t\t*entry |= ((u32)DCBX_APP_SF_PORT <<\n\t\t\t\t\t   DCBX_APP_SF_SHIFT);\n\t\t}\n\n\t\t*entry &= ~DCBX_APP_PROTOCOL_ID_MASK;\n\t\t*entry |= ((u32)p_params->app_entry[i].proto_id <<\n\t\t\t   DCBX_APP_PROTOCOL_ID_SHIFT);\n\t\t*entry &= ~DCBX_APP_PRI_MAP_MASK;\n\t\t*entry |= ((u32)(p_params->app_entry[i].prio) <<\n\t\t\t   DCBX_APP_PRI_MAP_SHIFT);\n\t}\n}\n\nstatic void\nqed_dcbx_set_local_params(struct qed_hwfn *p_hwfn,\n\t\t\t  struct dcbx_local_params *local_admin,\n\t\t\t  struct qed_dcbx_set *params)\n{\n\tbool ieee = false;\n\n\tlocal_admin->flags = 0;\n\tmemcpy(&local_admin->features,\n\t       &p_hwfn->p_dcbx_info->operational.features,\n\t       sizeof(local_admin->features));\n\n\tif (params->enabled) {\n\t\tlocal_admin->config = params->ver_num;\n\t\tieee = !!(params->ver_num & DCBX_CONFIG_VERSION_IEEE);\n\t} else {\n\t\tlocal_admin->config = DCBX_CONFIG_VERSION_DISABLED;\n\t}\n\n\tDP_VERBOSE(p_hwfn, QED_MSG_DCB, \"Dcbx version = %d\\n\",\n\t\t   local_admin->config);\n\n\tif (params->override_flags & QED_DCBX_OVERRIDE_PFC_CFG)\n\t\tqed_dcbx_set_pfc_data(p_hwfn, &local_admin->features.pfc,\n\t\t\t\t      &params->config.params);\n\n\tif (params->override_flags & QED_DCBX_OVERRIDE_ETS_CFG)\n\t\tqed_dcbx_set_ets_data(p_hwfn, &local_admin->features.ets,\n\t\t\t\t      &params->config.params);\n\n\tif (params->override_flags & QED_DCBX_OVERRIDE_APP_CFG)\n\t\tqed_dcbx_set_app_data(p_hwfn, &local_admin->features.app,\n\t\t\t\t      &params->config.params, ieee);\n}\n\nint qed_dcbx_config_params(struct qed_hwfn *p_hwfn, struct qed_ptt *p_ptt,\n\t\t\t   struct qed_dcbx_set *params, bool hw_commit)\n{\n\tstruct dcbx_local_params local_admin;\n\tstruct qed_dcbx_mib_meta_data data;\n\tu32 resp = 0, param = 0;\n\tint rc = 0;\n\n\tif (!hw_commit) {\n\t\tmemcpy(&p_hwfn->p_dcbx_info->set, params,\n\t\t       sizeof(struct qed_dcbx_set));\n\t\treturn 0;\n\t}\n\n\t \n\tmemset(&p_hwfn->p_dcbx_info->set, 0, sizeof(p_hwfn->p_dcbx_info->set));\n\n\tmemset(&local_admin, 0, sizeof(local_admin));\n\tqed_dcbx_set_local_params(p_hwfn, &local_admin, params);\n\n\tdata.addr = p_hwfn->mcp_info->port_addr +\n\t    offsetof(struct public_port, local_admin_dcbx_mib);\n\tdata.local_admin = &local_admin;\n\tdata.size = sizeof(struct dcbx_local_params);\n\tqed_memcpy_to(p_hwfn, p_ptt, data.addr, data.local_admin, data.size);\n\n\trc = qed_mcp_cmd(p_hwfn, p_ptt, DRV_MSG_CODE_SET_DCBX,\n\t\t\t 1 << DRV_MB_PARAM_LLDP_SEND_SHIFT, &resp, &param);\n\tif (rc)\n\t\tDP_NOTICE(p_hwfn, \"Failed to send DCBX update request\\n\");\n\n\treturn rc;\n}\n\nint qed_dcbx_get_config_params(struct qed_hwfn *p_hwfn,\n\t\t\t       struct qed_dcbx_set *params)\n{\n\tstruct qed_dcbx_get *dcbx_info;\n\tint rc;\n\n\tif (p_hwfn->p_dcbx_info->set.config.valid) {\n\t\tmemcpy(params, &p_hwfn->p_dcbx_info->set,\n\t\t       sizeof(struct qed_dcbx_set));\n\t\treturn 0;\n\t}\n\n\tdcbx_info = kzalloc(sizeof(*dcbx_info), GFP_KERNEL);\n\tif (!dcbx_info)\n\t\treturn -ENOMEM;\n\n\trc = qed_dcbx_query_params(p_hwfn, dcbx_info, QED_DCBX_OPERATIONAL_MIB);\n\tif (rc) {\n\t\tkfree(dcbx_info);\n\t\treturn rc;\n\t}\n\n\tp_hwfn->p_dcbx_info->set.override_flags = 0;\n\tp_hwfn->p_dcbx_info->set.ver_num = DCBX_CONFIG_VERSION_DISABLED;\n\tif (dcbx_info->operational.cee)\n\t\tp_hwfn->p_dcbx_info->set.ver_num |= DCBX_CONFIG_VERSION_CEE;\n\tif (dcbx_info->operational.ieee)\n\t\tp_hwfn->p_dcbx_info->set.ver_num |= DCBX_CONFIG_VERSION_IEEE;\n\tif (dcbx_info->operational.local)\n\t\tp_hwfn->p_dcbx_info->set.ver_num |= DCBX_CONFIG_VERSION_STATIC;\n\n\tp_hwfn->p_dcbx_info->set.enabled = dcbx_info->operational.enabled;\n\tBUILD_BUG_ON(sizeof(dcbx_info->operational.params) !=\n\t\t     sizeof(p_hwfn->p_dcbx_info->set.config.params));\n\tmemcpy(&p_hwfn->p_dcbx_info->set.config.params,\n\t       &dcbx_info->operational.params,\n\t       sizeof(p_hwfn->p_dcbx_info->set.config.params));\n\tp_hwfn->p_dcbx_info->set.config.valid = true;\n\n\tmemcpy(params, &p_hwfn->p_dcbx_info->set, sizeof(struct qed_dcbx_set));\n\n\tkfree(dcbx_info);\n\n\treturn 0;\n}\n\nstatic struct qed_dcbx_get *qed_dcbnl_get_dcbx(struct qed_hwfn *hwfn,\n\t\t\t\t\t       enum qed_mib_read_type type)\n{\n\tstruct qed_dcbx_get *dcbx_info;\n\n\tdcbx_info = kzalloc(sizeof(*dcbx_info), GFP_ATOMIC);\n\tif (!dcbx_info)\n\t\treturn NULL;\n\n\tif (qed_dcbx_query_params(hwfn, dcbx_info, type)) {\n\t\tkfree(dcbx_info);\n\t\treturn NULL;\n\t}\n\n\tif ((type == QED_DCBX_OPERATIONAL_MIB) &&\n\t    !dcbx_info->operational.enabled) {\n\t\tDP_INFO(hwfn, \"DCBX is not enabled/operational\\n\");\n\t\tkfree(dcbx_info);\n\t\treturn NULL;\n\t}\n\n\treturn dcbx_info;\n}\n\nstatic u8 qed_dcbnl_getstate(struct qed_dev *cdev)\n{\n\tstruct qed_hwfn *hwfn = QED_LEADING_HWFN(cdev);\n\tstruct qed_dcbx_get *dcbx_info;\n\tbool enabled;\n\n\tdcbx_info = qed_dcbnl_get_dcbx(hwfn, QED_DCBX_OPERATIONAL_MIB);\n\tif (!dcbx_info)\n\t\treturn 0;\n\n\tenabled = dcbx_info->operational.enabled;\n\tDP_VERBOSE(hwfn, QED_MSG_DCB, \"DCB state = %d\\n\", enabled);\n\tkfree(dcbx_info);\n\n\treturn enabled;\n}\n\nstatic u8 qed_dcbnl_setstate(struct qed_dev *cdev, u8 state)\n{\n\tstruct qed_hwfn *hwfn = QED_LEADING_HWFN(cdev);\n\tstruct qed_dcbx_set dcbx_set;\n\tstruct qed_ptt *ptt;\n\tint rc;\n\n\tDP_VERBOSE(hwfn, QED_MSG_DCB, \"DCB state = %d\\n\", state);\n\n\tmemset(&dcbx_set, 0, sizeof(dcbx_set));\n\trc = qed_dcbx_get_config_params(hwfn, &dcbx_set);\n\tif (rc)\n\t\treturn 1;\n\n\tdcbx_set.enabled = !!state;\n\n\tptt = qed_ptt_acquire(hwfn);\n\tif (!ptt)\n\t\treturn 1;\n\n\trc = qed_dcbx_config_params(hwfn, ptt, &dcbx_set, 0);\n\n\tqed_ptt_release(hwfn, ptt);\n\n\treturn rc ? 1 : 0;\n}\n\nstatic void qed_dcbnl_getpgtccfgtx(struct qed_dev *cdev, int tc, u8 *prio_type,\n\t\t\t\t   u8 *pgid, u8 *bw_pct, u8 *up_map)\n{\n\tstruct qed_hwfn *hwfn = QED_LEADING_HWFN(cdev);\n\tstruct qed_dcbx_get *dcbx_info;\n\n\tDP_VERBOSE(hwfn, QED_MSG_DCB, \"tc = %d\\n\", tc);\n\t*prio_type = *pgid = *bw_pct = *up_map = 0;\n\tif (tc < 0 || tc >= QED_MAX_PFC_PRIORITIES) {\n\t\tDP_INFO(hwfn, \"Invalid tc %d\\n\", tc);\n\t\treturn;\n\t}\n\n\tdcbx_info = qed_dcbnl_get_dcbx(hwfn, QED_DCBX_OPERATIONAL_MIB);\n\tif (!dcbx_info)\n\t\treturn;\n\n\t*pgid = dcbx_info->operational.params.ets_pri_tc_tbl[tc];\n\tkfree(dcbx_info);\n}\n\nstatic void qed_dcbnl_getpgbwgcfgtx(struct qed_dev *cdev, int pgid, u8 *bw_pct)\n{\n\tstruct qed_hwfn *hwfn = QED_LEADING_HWFN(cdev);\n\tstruct qed_dcbx_get *dcbx_info;\n\n\t*bw_pct = 0;\n\tDP_VERBOSE(hwfn, QED_MSG_DCB, \"pgid = %d\\n\", pgid);\n\tif (pgid < 0 || pgid >= QED_MAX_PFC_PRIORITIES) {\n\t\tDP_INFO(hwfn, \"Invalid pgid %d\\n\", pgid);\n\t\treturn;\n\t}\n\n\tdcbx_info = qed_dcbnl_get_dcbx(hwfn, QED_DCBX_OPERATIONAL_MIB);\n\tif (!dcbx_info)\n\t\treturn;\n\n\t*bw_pct = dcbx_info->operational.params.ets_tc_bw_tbl[pgid];\n\tDP_VERBOSE(hwfn, QED_MSG_DCB, \"bw_pct = %d\\n\", *bw_pct);\n\tkfree(dcbx_info);\n}\n\nstatic void qed_dcbnl_getpgtccfgrx(struct qed_dev *cdev, int tc, u8 *prio,\n\t\t\t\t   u8 *bwg_id, u8 *bw_pct, u8 *up_map)\n{\n\tDP_INFO(QED_LEADING_HWFN(cdev), \"Rx ETS is not supported\\n\");\n\t*prio = *bwg_id = *bw_pct = *up_map = 0;\n}\n\nstatic void qed_dcbnl_getpgbwgcfgrx(struct qed_dev *cdev,\n\t\t\t\t    int bwg_id, u8 *bw_pct)\n{\n\tDP_INFO(QED_LEADING_HWFN(cdev), \"Rx ETS is not supported\\n\");\n\t*bw_pct = 0;\n}\n\nstatic void qed_dcbnl_getpfccfg(struct qed_dev *cdev,\n\t\t\t\tint priority, u8 *setting)\n{\n\tstruct qed_hwfn *hwfn = QED_LEADING_HWFN(cdev);\n\tstruct qed_dcbx_get *dcbx_info;\n\n\tDP_VERBOSE(hwfn, QED_MSG_DCB, \"priority = %d\\n\", priority);\n\tif (priority < 0 || priority >= QED_MAX_PFC_PRIORITIES) {\n\t\tDP_INFO(hwfn, \"Invalid priority %d\\n\", priority);\n\t\treturn;\n\t}\n\n\tdcbx_info = qed_dcbnl_get_dcbx(hwfn, QED_DCBX_OPERATIONAL_MIB);\n\tif (!dcbx_info)\n\t\treturn;\n\n\t*setting = dcbx_info->operational.params.pfc.prio[priority];\n\tDP_VERBOSE(hwfn, QED_MSG_DCB, \"setting = %d\\n\", *setting);\n\tkfree(dcbx_info);\n}\n\nstatic void qed_dcbnl_setpfccfg(struct qed_dev *cdev, int priority, u8 setting)\n{\n\tstruct qed_hwfn *hwfn = QED_LEADING_HWFN(cdev);\n\tstruct qed_dcbx_set dcbx_set;\n\tstruct qed_ptt *ptt;\n\tint rc;\n\n\tDP_VERBOSE(hwfn, QED_MSG_DCB, \"priority = %d setting = %d\\n\",\n\t\t   priority, setting);\n\tif (priority < 0 || priority >= QED_MAX_PFC_PRIORITIES) {\n\t\tDP_INFO(hwfn, \"Invalid priority %d\\n\", priority);\n\t\treturn;\n\t}\n\n\tmemset(&dcbx_set, 0, sizeof(dcbx_set));\n\trc = qed_dcbx_get_config_params(hwfn, &dcbx_set);\n\tif (rc)\n\t\treturn;\n\n\tdcbx_set.override_flags |= QED_DCBX_OVERRIDE_PFC_CFG;\n\tdcbx_set.config.params.pfc.prio[priority] = !!setting;\n\n\tptt = qed_ptt_acquire(hwfn);\n\tif (!ptt)\n\t\treturn;\n\n\trc = qed_dcbx_config_params(hwfn, ptt, &dcbx_set, 0);\n\n\tqed_ptt_release(hwfn, ptt);\n}\n\nstatic u8 qed_dcbnl_getcap(struct qed_dev *cdev, int capid, u8 *cap)\n{\n\tstruct qed_hwfn *hwfn = QED_LEADING_HWFN(cdev);\n\tstruct qed_dcbx_get *dcbx_info;\n\tint rc = 0;\n\n\tDP_VERBOSE(hwfn, QED_MSG_DCB, \"capid = %d\\n\", capid);\n\tdcbx_info = qed_dcbnl_get_dcbx(hwfn, QED_DCBX_OPERATIONAL_MIB);\n\tif (!dcbx_info)\n\t\treturn 1;\n\n\tswitch (capid) {\n\tcase DCB_CAP_ATTR_PG:\n\tcase DCB_CAP_ATTR_PFC:\n\tcase DCB_CAP_ATTR_UP2TC:\n\tcase DCB_CAP_ATTR_GSP:\n\t\t*cap = true;\n\t\tbreak;\n\tcase DCB_CAP_ATTR_PG_TCS:\n\tcase DCB_CAP_ATTR_PFC_TCS:\n\t\t*cap = 0x80;\n\t\tbreak;\n\tcase DCB_CAP_ATTR_DCBX:\n\t\t*cap = (DCB_CAP_DCBX_VER_CEE | DCB_CAP_DCBX_VER_IEEE |\n\t\t\tDCB_CAP_DCBX_STATIC);\n\t\tbreak;\n\tdefault:\n\t\t*cap = false;\n\t\trc = 1;\n\t}\n\n\tDP_VERBOSE(hwfn, QED_MSG_DCB, \"id = %d caps = %d\\n\", capid, *cap);\n\tkfree(dcbx_info);\n\n\treturn rc;\n}\n\nstatic int qed_dcbnl_getnumtcs(struct qed_dev *cdev, int tcid, u8 *num)\n{\n\tstruct qed_hwfn *hwfn = QED_LEADING_HWFN(cdev);\n\tstruct qed_dcbx_get *dcbx_info;\n\tint rc = 0;\n\n\tDP_VERBOSE(hwfn, QED_MSG_DCB, \"tcid = %d\\n\", tcid);\n\tdcbx_info = qed_dcbnl_get_dcbx(hwfn, QED_DCBX_OPERATIONAL_MIB);\n\tif (!dcbx_info)\n\t\treturn -EINVAL;\n\n\tswitch (tcid) {\n\tcase DCB_NUMTCS_ATTR_PG:\n\t\t*num = dcbx_info->operational.params.max_ets_tc;\n\t\tbreak;\n\tcase DCB_NUMTCS_ATTR_PFC:\n\t\t*num = dcbx_info->operational.params.pfc.max_tc;\n\t\tbreak;\n\tdefault:\n\t\trc = -EINVAL;\n\t}\n\n\tkfree(dcbx_info);\n\tDP_VERBOSE(hwfn, QED_MSG_DCB, \"numtcs = %d\\n\", *num);\n\n\treturn rc;\n}\n\nstatic u8 qed_dcbnl_getpfcstate(struct qed_dev *cdev)\n{\n\tstruct qed_hwfn *hwfn = QED_LEADING_HWFN(cdev);\n\tstruct qed_dcbx_get *dcbx_info;\n\tbool enabled;\n\n\tdcbx_info = qed_dcbnl_get_dcbx(hwfn, QED_DCBX_OPERATIONAL_MIB);\n\tif (!dcbx_info)\n\t\treturn 0;\n\n\tenabled = dcbx_info->operational.params.pfc.enabled;\n\tDP_VERBOSE(hwfn, QED_MSG_DCB, \"pfc state = %d\\n\", enabled);\n\tkfree(dcbx_info);\n\n\treturn enabled;\n}\n\nstatic u8 qed_dcbnl_getdcbx(struct qed_dev *cdev)\n{\n\tstruct qed_hwfn *hwfn = QED_LEADING_HWFN(cdev);\n\tstruct qed_dcbx_get *dcbx_info;\n\tu8 mode = 0;\n\n\tdcbx_info = qed_dcbnl_get_dcbx(hwfn, QED_DCBX_OPERATIONAL_MIB);\n\tif (!dcbx_info)\n\t\treturn 0;\n\n\tif (dcbx_info->operational.ieee)\n\t\tmode |= DCB_CAP_DCBX_VER_IEEE;\n\tif (dcbx_info->operational.cee)\n\t\tmode |= DCB_CAP_DCBX_VER_CEE;\n\tif (dcbx_info->operational.local)\n\t\tmode |= DCB_CAP_DCBX_STATIC;\n\n\tDP_VERBOSE(hwfn, QED_MSG_DCB, \"dcb mode = %d\\n\", mode);\n\tkfree(dcbx_info);\n\n\treturn mode;\n}\n\nstatic void qed_dcbnl_setpgtccfgtx(struct qed_dev *cdev,\n\t\t\t\t   int tc,\n\t\t\t\t   u8 pri_type, u8 pgid, u8 bw_pct, u8 up_map)\n{\n\tstruct qed_hwfn *hwfn = QED_LEADING_HWFN(cdev);\n\tstruct qed_dcbx_set dcbx_set;\n\tstruct qed_ptt *ptt;\n\tint rc;\n\n\tDP_VERBOSE(hwfn, QED_MSG_DCB,\n\t\t   \"tc = %d pri_type = %d pgid = %d bw_pct = %d up_map = %d\\n\",\n\t\t   tc, pri_type, pgid, bw_pct, up_map);\n\n\tif (tc < 0 || tc >= QED_MAX_PFC_PRIORITIES) {\n\t\tDP_INFO(hwfn, \"Invalid tc %d\\n\", tc);\n\t\treturn;\n\t}\n\n\tmemset(&dcbx_set, 0, sizeof(dcbx_set));\n\trc = qed_dcbx_get_config_params(hwfn, &dcbx_set);\n\tif (rc)\n\t\treturn;\n\n\tdcbx_set.override_flags |= QED_DCBX_OVERRIDE_ETS_CFG;\n\tdcbx_set.config.params.ets_pri_tc_tbl[tc] = pgid;\n\n\tptt = qed_ptt_acquire(hwfn);\n\tif (!ptt)\n\t\treturn;\n\n\trc = qed_dcbx_config_params(hwfn, ptt, &dcbx_set, 0);\n\n\tqed_ptt_release(hwfn, ptt);\n}\n\nstatic void qed_dcbnl_setpgtccfgrx(struct qed_dev *cdev, int prio,\n\t\t\t\t   u8 pri_type, u8 pgid, u8 bw_pct, u8 up_map)\n{\n\tDP_INFO(QED_LEADING_HWFN(cdev), \"Rx ETS is not supported\\n\");\n}\n\nstatic void qed_dcbnl_setpgbwgcfgtx(struct qed_dev *cdev, int pgid, u8 bw_pct)\n{\n\tstruct qed_hwfn *hwfn = QED_LEADING_HWFN(cdev);\n\tstruct qed_dcbx_set dcbx_set;\n\tstruct qed_ptt *ptt;\n\tint rc;\n\n\tDP_VERBOSE(hwfn, QED_MSG_DCB, \"pgid = %d bw_pct = %d\\n\", pgid, bw_pct);\n\tif (pgid < 0 || pgid >= QED_MAX_PFC_PRIORITIES) {\n\t\tDP_INFO(hwfn, \"Invalid pgid %d\\n\", pgid);\n\t\treturn;\n\t}\n\n\tmemset(&dcbx_set, 0, sizeof(dcbx_set));\n\trc = qed_dcbx_get_config_params(hwfn, &dcbx_set);\n\tif (rc)\n\t\treturn;\n\n\tdcbx_set.override_flags |= QED_DCBX_OVERRIDE_ETS_CFG;\n\tdcbx_set.config.params.ets_tc_bw_tbl[pgid] = bw_pct;\n\n\tptt = qed_ptt_acquire(hwfn);\n\tif (!ptt)\n\t\treturn;\n\n\trc = qed_dcbx_config_params(hwfn, ptt, &dcbx_set, 0);\n\n\tqed_ptt_release(hwfn, ptt);\n}\n\nstatic void qed_dcbnl_setpgbwgcfgrx(struct qed_dev *cdev, int pgid, u8 bw_pct)\n{\n\tDP_INFO(QED_LEADING_HWFN(cdev), \"Rx ETS is not supported\\n\");\n}\n\nstatic u8 qed_dcbnl_setall(struct qed_dev *cdev)\n{\n\tstruct qed_hwfn *hwfn = QED_LEADING_HWFN(cdev);\n\tstruct qed_dcbx_set dcbx_set;\n\tstruct qed_ptt *ptt;\n\tint rc;\n\n\tmemset(&dcbx_set, 0, sizeof(dcbx_set));\n\trc = qed_dcbx_get_config_params(hwfn, &dcbx_set);\n\tif (rc)\n\t\treturn 1;\n\n\tptt = qed_ptt_acquire(hwfn);\n\tif (!ptt)\n\t\treturn 1;\n\n\trc = qed_dcbx_config_params(hwfn, ptt, &dcbx_set, 1);\n\n\tqed_ptt_release(hwfn, ptt);\n\n\treturn rc;\n}\n\nstatic int qed_dcbnl_setnumtcs(struct qed_dev *cdev, int tcid, u8 num)\n{\n\tstruct qed_hwfn *hwfn = QED_LEADING_HWFN(cdev);\n\tstruct qed_dcbx_set dcbx_set;\n\tstruct qed_ptt *ptt;\n\tint rc;\n\n\tDP_VERBOSE(hwfn, QED_MSG_DCB, \"tcid = %d num = %d\\n\", tcid, num);\n\tmemset(&dcbx_set, 0, sizeof(dcbx_set));\n\trc = qed_dcbx_get_config_params(hwfn, &dcbx_set);\n\tif (rc)\n\t\treturn 1;\n\n\tswitch (tcid) {\n\tcase DCB_NUMTCS_ATTR_PG:\n\t\tdcbx_set.override_flags |= QED_DCBX_OVERRIDE_ETS_CFG;\n\t\tdcbx_set.config.params.max_ets_tc = num;\n\t\tbreak;\n\tcase DCB_NUMTCS_ATTR_PFC:\n\t\tdcbx_set.override_flags |= QED_DCBX_OVERRIDE_PFC_CFG;\n\t\tdcbx_set.config.params.pfc.max_tc = num;\n\t\tbreak;\n\tdefault:\n\t\tDP_INFO(hwfn, \"Invalid tcid %d\\n\", tcid);\n\t\treturn -EINVAL;\n\t}\n\n\tptt = qed_ptt_acquire(hwfn);\n\tif (!ptt)\n\t\treturn -EINVAL;\n\n\trc = qed_dcbx_config_params(hwfn, ptt, &dcbx_set, 0);\n\n\tqed_ptt_release(hwfn, ptt);\n\n\treturn 0;\n}\n\nstatic void qed_dcbnl_setpfcstate(struct qed_dev *cdev, u8 state)\n{\n\tstruct qed_hwfn *hwfn = QED_LEADING_HWFN(cdev);\n\tstruct qed_dcbx_set dcbx_set;\n\tstruct qed_ptt *ptt;\n\tint rc;\n\n\tDP_VERBOSE(hwfn, QED_MSG_DCB, \"new state = %d\\n\", state);\n\n\tmemset(&dcbx_set, 0, sizeof(dcbx_set));\n\trc = qed_dcbx_get_config_params(hwfn, &dcbx_set);\n\tif (rc)\n\t\treturn;\n\n\tdcbx_set.override_flags |= QED_DCBX_OVERRIDE_PFC_CFG;\n\tdcbx_set.config.params.pfc.enabled = !!state;\n\n\tptt = qed_ptt_acquire(hwfn);\n\tif (!ptt)\n\t\treturn;\n\n\trc = qed_dcbx_config_params(hwfn, ptt, &dcbx_set, 0);\n\n\tqed_ptt_release(hwfn, ptt);\n}\n\nstatic int qed_dcbnl_getapp(struct qed_dev *cdev, u8 idtype, u16 idval)\n{\n\tstruct qed_hwfn *hwfn = QED_LEADING_HWFN(cdev);\n\tstruct qed_dcbx_get *dcbx_info;\n\tstruct qed_app_entry *entry;\n\tbool ethtype;\n\tu8 prio = 0;\n\tint i;\n\n\tdcbx_info = qed_dcbnl_get_dcbx(hwfn, QED_DCBX_OPERATIONAL_MIB);\n\tif (!dcbx_info)\n\t\treturn -EINVAL;\n\n\tethtype = !!(idtype == DCB_APP_IDTYPE_ETHTYPE);\n\tfor (i = 0; i < QED_DCBX_MAX_APP_PROTOCOL; i++) {\n\t\tentry = &dcbx_info->operational.params.app_entry[i];\n\t\tif ((entry->ethtype == ethtype) && (entry->proto_id == idval)) {\n\t\t\tprio = entry->prio;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i == QED_DCBX_MAX_APP_PROTOCOL) {\n\t\tDP_ERR(cdev, \"App entry (%d, %d) not found\\n\", idtype, idval);\n\t\tkfree(dcbx_info);\n\t\treturn -EINVAL;\n\t}\n\n\tkfree(dcbx_info);\n\n\treturn prio;\n}\n\nstatic int qed_dcbnl_setapp(struct qed_dev *cdev,\n\t\t\t    u8 idtype, u16 idval, u8 pri_map)\n{\n\tstruct qed_hwfn *hwfn = QED_LEADING_HWFN(cdev);\n\tstruct qed_dcbx_set dcbx_set;\n\tstruct qed_app_entry *entry;\n\tstruct qed_ptt *ptt;\n\tbool ethtype;\n\tint rc, i;\n\n\tmemset(&dcbx_set, 0, sizeof(dcbx_set));\n\trc = qed_dcbx_get_config_params(hwfn, &dcbx_set);\n\tif (rc)\n\t\treturn -EINVAL;\n\n\tethtype = !!(idtype == DCB_APP_IDTYPE_ETHTYPE);\n\tfor (i = 0; i < QED_DCBX_MAX_APP_PROTOCOL; i++) {\n\t\tentry = &dcbx_set.config.params.app_entry[i];\n\t\tif ((entry->ethtype == ethtype) && (entry->proto_id == idval))\n\t\t\tbreak;\n\t\t \n\t\tif (!entry->proto_id) {\n\t\t\tdcbx_set.config.params.num_app_entries++;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i == QED_DCBX_MAX_APP_PROTOCOL) {\n\t\tDP_ERR(cdev, \"App table is full\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tdcbx_set.override_flags |= QED_DCBX_OVERRIDE_APP_CFG;\n\tdcbx_set.config.params.app_entry[i].ethtype = ethtype;\n\tdcbx_set.config.params.app_entry[i].proto_id = idval;\n\tdcbx_set.config.params.app_entry[i].prio = pri_map;\n\n\tptt = qed_ptt_acquire(hwfn);\n\tif (!ptt)\n\t\treturn -EBUSY;\n\n\trc = qed_dcbx_config_params(hwfn, ptt, &dcbx_set, 0);\n\n\tqed_ptt_release(hwfn, ptt);\n\n\treturn rc;\n}\n\nstatic u8 qed_dcbnl_setdcbx(struct qed_dev *cdev, u8 mode)\n{\n\tstruct qed_hwfn *hwfn = QED_LEADING_HWFN(cdev);\n\tstruct qed_dcbx_set dcbx_set;\n\tstruct qed_ptt *ptt;\n\tint rc;\n\n\tDP_VERBOSE(hwfn, QED_MSG_DCB, \"new mode = %x\\n\", mode);\n\n\tif (!(mode & DCB_CAP_DCBX_VER_IEEE) &&\n\t    !(mode & DCB_CAP_DCBX_VER_CEE) && !(mode & DCB_CAP_DCBX_STATIC)) {\n\t\tDP_INFO(hwfn, \"Allowed modes are cee, ieee or static\\n\");\n\t\treturn 1;\n\t}\n\n\tmemset(&dcbx_set, 0, sizeof(dcbx_set));\n\trc = qed_dcbx_get_config_params(hwfn, &dcbx_set);\n\tif (rc)\n\t\treturn 1;\n\n\tdcbx_set.ver_num = 0;\n\tif (mode & DCB_CAP_DCBX_VER_CEE) {\n\t\tdcbx_set.ver_num |= DCBX_CONFIG_VERSION_CEE;\n\t\tdcbx_set.enabled = true;\n\t}\n\n\tif (mode & DCB_CAP_DCBX_VER_IEEE) {\n\t\tdcbx_set.ver_num |= DCBX_CONFIG_VERSION_IEEE;\n\t\tdcbx_set.enabled = true;\n\t}\n\n\tif (mode & DCB_CAP_DCBX_STATIC) {\n\t\tdcbx_set.ver_num |= DCBX_CONFIG_VERSION_STATIC;\n\t\tdcbx_set.enabled = true;\n\t}\n\n\tptt = qed_ptt_acquire(hwfn);\n\tif (!ptt)\n\t\treturn 1;\n\n\trc = qed_dcbx_config_params(hwfn, ptt, &dcbx_set, 0);\n\n\tqed_ptt_release(hwfn, ptt);\n\n\treturn rc;\n}\n\nstatic u8 qed_dcbnl_getfeatcfg(struct qed_dev *cdev, int featid, u8 *flags)\n{\n\tstruct qed_hwfn *hwfn = QED_LEADING_HWFN(cdev);\n\tstruct qed_dcbx_get *dcbx_info;\n\n\tDP_VERBOSE(hwfn, QED_MSG_DCB, \"Feature id  = %d\\n\", featid);\n\tdcbx_info = qed_dcbnl_get_dcbx(hwfn, QED_DCBX_OPERATIONAL_MIB);\n\tif (!dcbx_info)\n\t\treturn 1;\n\n\t*flags = 0;\n\tswitch (featid) {\n\tcase DCB_FEATCFG_ATTR_PG:\n\t\tif (dcbx_info->operational.params.ets_enabled)\n\t\t\t*flags = DCB_FEATCFG_ENABLE;\n\t\telse\n\t\t\t*flags = DCB_FEATCFG_ERROR;\n\t\tbreak;\n\tcase DCB_FEATCFG_ATTR_PFC:\n\t\tif (dcbx_info->operational.params.pfc.enabled)\n\t\t\t*flags = DCB_FEATCFG_ENABLE;\n\t\telse\n\t\t\t*flags = DCB_FEATCFG_ERROR;\n\t\tbreak;\n\tcase DCB_FEATCFG_ATTR_APP:\n\t\tif (dcbx_info->operational.params.app_valid)\n\t\t\t*flags = DCB_FEATCFG_ENABLE;\n\t\telse\n\t\t\t*flags = DCB_FEATCFG_ERROR;\n\t\tbreak;\n\tdefault:\n\t\tDP_INFO(hwfn, \"Invalid feature-ID %d\\n\", featid);\n\t\tkfree(dcbx_info);\n\t\treturn 1;\n\t}\n\n\tDP_VERBOSE(hwfn, QED_MSG_DCB, \"flags = %d\\n\", *flags);\n\tkfree(dcbx_info);\n\n\treturn 0;\n}\n\nstatic u8 qed_dcbnl_setfeatcfg(struct qed_dev *cdev, int featid, u8 flags)\n{\n\tstruct qed_hwfn *hwfn = QED_LEADING_HWFN(cdev);\n\tstruct qed_dcbx_set dcbx_set;\n\tbool enabled, willing;\n\tstruct qed_ptt *ptt;\n\tint rc;\n\n\tDP_VERBOSE(hwfn, QED_MSG_DCB, \"featid = %d flags = %d\\n\",\n\t\t   featid, flags);\n\tmemset(&dcbx_set, 0, sizeof(dcbx_set));\n\trc = qed_dcbx_get_config_params(hwfn, &dcbx_set);\n\tif (rc)\n\t\treturn 1;\n\n\tenabled = !!(flags & DCB_FEATCFG_ENABLE);\n\twilling = !!(flags & DCB_FEATCFG_WILLING);\n\tswitch (featid) {\n\tcase DCB_FEATCFG_ATTR_PG:\n\t\tdcbx_set.override_flags |= QED_DCBX_OVERRIDE_ETS_CFG;\n\t\tdcbx_set.config.params.ets_enabled = enabled;\n\t\tdcbx_set.config.params.ets_willing = willing;\n\t\tbreak;\n\tcase DCB_FEATCFG_ATTR_PFC:\n\t\tdcbx_set.override_flags |= QED_DCBX_OVERRIDE_PFC_CFG;\n\t\tdcbx_set.config.params.pfc.enabled = enabled;\n\t\tdcbx_set.config.params.pfc.willing = willing;\n\t\tbreak;\n\tcase DCB_FEATCFG_ATTR_APP:\n\t\tdcbx_set.override_flags |= QED_DCBX_OVERRIDE_APP_CFG;\n\t\tdcbx_set.config.params.app_willing = willing;\n\t\tbreak;\n\tdefault:\n\t\tDP_INFO(hwfn, \"Invalid feature-ID %d\\n\", featid);\n\t\treturn 1;\n\t}\n\n\tptt = qed_ptt_acquire(hwfn);\n\tif (!ptt)\n\t\treturn 1;\n\n\trc = qed_dcbx_config_params(hwfn, ptt, &dcbx_set, 0);\n\n\tqed_ptt_release(hwfn, ptt);\n\n\treturn 0;\n}\n\nstatic int qed_dcbnl_peer_getappinfo(struct qed_dev *cdev,\n\t\t\t\t     struct dcb_peer_app_info *info,\n\t\t\t\t     u16 *app_count)\n{\n\tstruct qed_hwfn *hwfn = QED_LEADING_HWFN(cdev);\n\tstruct qed_dcbx_get *dcbx_info;\n\n\tdcbx_info = qed_dcbnl_get_dcbx(hwfn, QED_DCBX_REMOTE_MIB);\n\tif (!dcbx_info)\n\t\treturn -EINVAL;\n\n\tinfo->willing = dcbx_info->remote.params.app_willing;\n\tinfo->error = dcbx_info->remote.params.app_error;\n\t*app_count = dcbx_info->remote.params.num_app_entries;\n\tkfree(dcbx_info);\n\n\treturn 0;\n}\n\nstatic int qed_dcbnl_peer_getapptable(struct qed_dev *cdev,\n\t\t\t\t      struct dcb_app *table)\n{\n\tstruct qed_hwfn *hwfn = QED_LEADING_HWFN(cdev);\n\tstruct qed_dcbx_get *dcbx_info;\n\tint i;\n\n\tdcbx_info = qed_dcbnl_get_dcbx(hwfn, QED_DCBX_REMOTE_MIB);\n\tif (!dcbx_info)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < dcbx_info->remote.params.num_app_entries; i++) {\n\t\tif (dcbx_info->remote.params.app_entry[i].ethtype)\n\t\t\ttable[i].selector = DCB_APP_IDTYPE_ETHTYPE;\n\t\telse\n\t\t\ttable[i].selector = DCB_APP_IDTYPE_PORTNUM;\n\t\ttable[i].priority = dcbx_info->remote.params.app_entry[i].prio;\n\t\ttable[i].protocol =\n\t\t    dcbx_info->remote.params.app_entry[i].proto_id;\n\t}\n\n\tkfree(dcbx_info);\n\n\treturn 0;\n}\n\nstatic int qed_dcbnl_cee_peer_getpfc(struct qed_dev *cdev, struct cee_pfc *pfc)\n{\n\tstruct qed_hwfn *hwfn = QED_LEADING_HWFN(cdev);\n\tstruct qed_dcbx_get *dcbx_info;\n\tint i;\n\n\tdcbx_info = qed_dcbnl_get_dcbx(hwfn, QED_DCBX_REMOTE_MIB);\n\tif (!dcbx_info)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < QED_MAX_PFC_PRIORITIES; i++)\n\t\tif (dcbx_info->remote.params.pfc.prio[i])\n\t\t\tpfc->pfc_en |= BIT(i);\n\n\tpfc->tcs_supported = dcbx_info->remote.params.pfc.max_tc;\n\tDP_VERBOSE(hwfn, QED_MSG_DCB, \"pfc state = %d tcs_supported = %d\\n\",\n\t\t   pfc->pfc_en, pfc->tcs_supported);\n\tkfree(dcbx_info);\n\n\treturn 0;\n}\n\nstatic int qed_dcbnl_cee_peer_getpg(struct qed_dev *cdev, struct cee_pg *pg)\n{\n\tstruct qed_hwfn *hwfn = QED_LEADING_HWFN(cdev);\n\tstruct qed_dcbx_get *dcbx_info;\n\tint i;\n\n\tdcbx_info = qed_dcbnl_get_dcbx(hwfn, QED_DCBX_REMOTE_MIB);\n\tif (!dcbx_info)\n\t\treturn -EINVAL;\n\n\tpg->willing = dcbx_info->remote.params.ets_willing;\n\tfor (i = 0; i < QED_MAX_PFC_PRIORITIES; i++) {\n\t\tpg->pg_bw[i] = dcbx_info->remote.params.ets_tc_bw_tbl[i];\n\t\tpg->prio_pg[i] = dcbx_info->remote.params.ets_pri_tc_tbl[i];\n\t}\n\n\tDP_VERBOSE(hwfn, QED_MSG_DCB, \"willing = %d\", pg->willing);\n\tkfree(dcbx_info);\n\n\treturn 0;\n}\n\nstatic int qed_dcbnl_get_ieee_pfc(struct qed_dev *cdev,\n\t\t\t\t  struct ieee_pfc *pfc, bool remote)\n{\n\tstruct qed_hwfn *hwfn = QED_LEADING_HWFN(cdev);\n\tstruct qed_dcbx_params *params;\n\tstruct qed_dcbx_get *dcbx_info;\n\tint rc, i;\n\n\tdcbx_info = qed_dcbnl_get_dcbx(hwfn, QED_DCBX_OPERATIONAL_MIB);\n\tif (!dcbx_info)\n\t\treturn -EINVAL;\n\n\tif (!dcbx_info->operational.ieee) {\n\t\tDP_INFO(hwfn, \"DCBX is not enabled/operational in IEEE mode\\n\");\n\t\tkfree(dcbx_info);\n\t\treturn -EINVAL;\n\t}\n\n\tif (remote) {\n\t\tmemset(dcbx_info, 0, sizeof(*dcbx_info));\n\t\trc = qed_dcbx_query_params(hwfn, dcbx_info,\n\t\t\t\t\t   QED_DCBX_REMOTE_MIB);\n\t\tif (rc) {\n\t\t\tkfree(dcbx_info);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tparams = &dcbx_info->remote.params;\n\t} else {\n\t\tparams = &dcbx_info->operational.params;\n\t}\n\n\tpfc->pfc_cap = params->pfc.max_tc;\n\tpfc->pfc_en = 0;\n\tfor (i = 0; i < QED_MAX_PFC_PRIORITIES; i++)\n\t\tif (params->pfc.prio[i])\n\t\t\tpfc->pfc_en |= BIT(i);\n\n\tkfree(dcbx_info);\n\n\treturn 0;\n}\n\nstatic int qed_dcbnl_ieee_getpfc(struct qed_dev *cdev, struct ieee_pfc *pfc)\n{\n\treturn qed_dcbnl_get_ieee_pfc(cdev, pfc, false);\n}\n\nstatic int qed_dcbnl_ieee_setpfc(struct qed_dev *cdev, struct ieee_pfc *pfc)\n{\n\tstruct qed_hwfn *hwfn = QED_LEADING_HWFN(cdev);\n\tstruct qed_dcbx_get *dcbx_info;\n\tstruct qed_dcbx_set dcbx_set;\n\tstruct qed_ptt *ptt;\n\tint rc, i;\n\n\tdcbx_info = qed_dcbnl_get_dcbx(hwfn, QED_DCBX_OPERATIONAL_MIB);\n\tif (!dcbx_info)\n\t\treturn -EINVAL;\n\n\tif (!dcbx_info->operational.ieee) {\n\t\tDP_INFO(hwfn, \"DCBX is not enabled/operational in IEEE mode\\n\");\n\t\tkfree(dcbx_info);\n\t\treturn -EINVAL;\n\t}\n\n\tkfree(dcbx_info);\n\n\tmemset(&dcbx_set, 0, sizeof(dcbx_set));\n\trc = qed_dcbx_get_config_params(hwfn, &dcbx_set);\n\tif (rc)\n\t\treturn -EINVAL;\n\n\tdcbx_set.override_flags |= QED_DCBX_OVERRIDE_PFC_CFG;\n\tfor (i = 0; i < QED_MAX_PFC_PRIORITIES; i++)\n\t\tdcbx_set.config.params.pfc.prio[i] = !!(pfc->pfc_en & BIT(i));\n\n\tdcbx_set.config.params.pfc.max_tc = pfc->pfc_cap;\n\n\tptt = qed_ptt_acquire(hwfn);\n\tif (!ptt)\n\t\treturn -EINVAL;\n\n\trc = qed_dcbx_config_params(hwfn, ptt, &dcbx_set, 0);\n\n\tqed_ptt_release(hwfn, ptt);\n\n\treturn rc;\n}\n\nstatic int qed_dcbnl_get_ieee_ets(struct qed_dev *cdev,\n\t\t\t\t  struct ieee_ets *ets, bool remote)\n{\n\tstruct qed_hwfn *hwfn = QED_LEADING_HWFN(cdev);\n\tstruct qed_dcbx_get *dcbx_info;\n\tstruct qed_dcbx_params *params;\n\tint rc;\n\n\tdcbx_info = qed_dcbnl_get_dcbx(hwfn, QED_DCBX_OPERATIONAL_MIB);\n\tif (!dcbx_info)\n\t\treturn -EINVAL;\n\n\tif (!dcbx_info->operational.ieee) {\n\t\tDP_INFO(hwfn, \"DCBX is not enabled/operational in IEEE mode\\n\");\n\t\tkfree(dcbx_info);\n\t\treturn -EINVAL;\n\t}\n\n\tif (remote) {\n\t\tmemset(dcbx_info, 0, sizeof(*dcbx_info));\n\t\trc = qed_dcbx_query_params(hwfn, dcbx_info,\n\t\t\t\t\t   QED_DCBX_REMOTE_MIB);\n\t\tif (rc) {\n\t\t\tkfree(dcbx_info);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tparams = &dcbx_info->remote.params;\n\t} else {\n\t\tparams = &dcbx_info->operational.params;\n\t}\n\n\tets->ets_cap = params->max_ets_tc;\n\tets->willing = params->ets_willing;\n\tets->cbs = params->ets_cbs;\n\tmemcpy(ets->tc_tx_bw, params->ets_tc_bw_tbl, sizeof(ets->tc_tx_bw));\n\tmemcpy(ets->tc_tsa, params->ets_tc_tsa_tbl, sizeof(ets->tc_tsa));\n\tmemcpy(ets->prio_tc, params->ets_pri_tc_tbl, sizeof(ets->prio_tc));\n\tkfree(dcbx_info);\n\n\treturn 0;\n}\n\nstatic int qed_dcbnl_ieee_getets(struct qed_dev *cdev, struct ieee_ets *ets)\n{\n\treturn qed_dcbnl_get_ieee_ets(cdev, ets, false);\n}\n\nstatic int qed_dcbnl_ieee_setets(struct qed_dev *cdev, struct ieee_ets *ets)\n{\n\tstruct qed_hwfn *hwfn = QED_LEADING_HWFN(cdev);\n\tstruct qed_dcbx_get *dcbx_info;\n\tstruct qed_dcbx_set dcbx_set;\n\tstruct qed_ptt *ptt;\n\tint rc;\n\n\tdcbx_info = qed_dcbnl_get_dcbx(hwfn, QED_DCBX_OPERATIONAL_MIB);\n\tif (!dcbx_info)\n\t\treturn -EINVAL;\n\n\tif (!dcbx_info->operational.ieee) {\n\t\tDP_INFO(hwfn, \"DCBX is not enabled/operational in IEEE mode\\n\");\n\t\tkfree(dcbx_info);\n\t\treturn -EINVAL;\n\t}\n\n\tkfree(dcbx_info);\n\n\tmemset(&dcbx_set, 0, sizeof(dcbx_set));\n\trc = qed_dcbx_get_config_params(hwfn, &dcbx_set);\n\tif (rc)\n\t\treturn -EINVAL;\n\n\tdcbx_set.override_flags |= QED_DCBX_OVERRIDE_ETS_CFG;\n\tdcbx_set.config.params.max_ets_tc = ets->ets_cap;\n\tdcbx_set.config.params.ets_willing = ets->willing;\n\tdcbx_set.config.params.ets_cbs = ets->cbs;\n\tmemcpy(dcbx_set.config.params.ets_tc_bw_tbl, ets->tc_tx_bw,\n\t       sizeof(ets->tc_tx_bw));\n\tmemcpy(dcbx_set.config.params.ets_tc_tsa_tbl, ets->tc_tsa,\n\t       sizeof(ets->tc_tsa));\n\tmemcpy(dcbx_set.config.params.ets_pri_tc_tbl, ets->prio_tc,\n\t       sizeof(ets->prio_tc));\n\n\tptt = qed_ptt_acquire(hwfn);\n\tif (!ptt)\n\t\treturn -EINVAL;\n\n\trc = qed_dcbx_config_params(hwfn, ptt, &dcbx_set, 0);\n\n\tqed_ptt_release(hwfn, ptt);\n\n\treturn rc;\n}\n\nstatic int\nqed_dcbnl_ieee_peer_getets(struct qed_dev *cdev, struct ieee_ets *ets)\n{\n\treturn qed_dcbnl_get_ieee_ets(cdev, ets, true);\n}\n\nstatic int\nqed_dcbnl_ieee_peer_getpfc(struct qed_dev *cdev, struct ieee_pfc *pfc)\n{\n\treturn qed_dcbnl_get_ieee_pfc(cdev, pfc, true);\n}\n\nstatic int qed_get_sf_ieee_value(u8 selector, u8 *sf_ieee)\n{\n\tswitch (selector) {\n\tcase IEEE_8021QAZ_APP_SEL_ETHERTYPE:\n\t\t*sf_ieee = QED_DCBX_SF_IEEE_ETHTYPE;\n\t\tbreak;\n\tcase IEEE_8021QAZ_APP_SEL_STREAM:\n\t\t*sf_ieee = QED_DCBX_SF_IEEE_TCP_PORT;\n\t\tbreak;\n\tcase IEEE_8021QAZ_APP_SEL_DGRAM:\n\t\t*sf_ieee = QED_DCBX_SF_IEEE_UDP_PORT;\n\t\tbreak;\n\tcase IEEE_8021QAZ_APP_SEL_ANY:\n\t\t*sf_ieee = QED_DCBX_SF_IEEE_TCP_UDP_PORT;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int qed_dcbnl_ieee_getapp(struct qed_dev *cdev, struct dcb_app *app)\n{\n\tstruct qed_hwfn *hwfn = QED_LEADING_HWFN(cdev);\n\tstruct qed_dcbx_get *dcbx_info;\n\tstruct qed_app_entry *entry;\n\tu8 prio = 0;\n\tu8 sf_ieee;\n\tint i;\n\n\tDP_VERBOSE(hwfn, QED_MSG_DCB, \"selector = %d protocol = %d\\n\",\n\t\t   app->selector, app->protocol);\n\n\tif (qed_get_sf_ieee_value(app->selector, &sf_ieee)) {\n\t\tDP_INFO(cdev, \"Invalid selector field value %d\\n\",\n\t\t\tapp->selector);\n\t\treturn -EINVAL;\n\t}\n\n\tdcbx_info = qed_dcbnl_get_dcbx(hwfn, QED_DCBX_OPERATIONAL_MIB);\n\tif (!dcbx_info)\n\t\treturn -EINVAL;\n\n\tif (!dcbx_info->operational.ieee) {\n\t\tDP_INFO(hwfn, \"DCBX is not enabled/operational in IEEE mode\\n\");\n\t\tkfree(dcbx_info);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < QED_DCBX_MAX_APP_PROTOCOL; i++) {\n\t\tentry = &dcbx_info->operational.params.app_entry[i];\n\t\tif ((entry->sf_ieee == sf_ieee) &&\n\t\t    (entry->proto_id == app->protocol)) {\n\t\t\tprio = entry->prio;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i == QED_DCBX_MAX_APP_PROTOCOL) {\n\t\tDP_ERR(cdev, \"App entry (%d, %d) not found\\n\", app->selector,\n\t\t       app->protocol);\n\t\tkfree(dcbx_info);\n\t\treturn -EINVAL;\n\t}\n\n\tapp->priority = ffs(prio) - 1;\n\n\tkfree(dcbx_info);\n\n\treturn 0;\n}\n\nstatic int qed_dcbnl_ieee_setapp(struct qed_dev *cdev, struct dcb_app *app)\n{\n\tstruct qed_hwfn *hwfn = QED_LEADING_HWFN(cdev);\n\tstruct qed_dcbx_get *dcbx_info;\n\tstruct qed_dcbx_set dcbx_set;\n\tstruct qed_app_entry *entry;\n\tstruct qed_ptt *ptt;\n\tu8 sf_ieee;\n\tint rc, i;\n\n\tDP_VERBOSE(hwfn, QED_MSG_DCB, \"selector = %d protocol = %d pri = %d\\n\",\n\t\t   app->selector, app->protocol, app->priority);\n\tif (app->priority >= QED_MAX_PFC_PRIORITIES) {\n\t\tDP_INFO(hwfn, \"Invalid priority %d\\n\", app->priority);\n\t\treturn -EINVAL;\n\t}\n\n\tif (qed_get_sf_ieee_value(app->selector, &sf_ieee)) {\n\t\tDP_INFO(cdev, \"Invalid selector field value %d\\n\",\n\t\t\tapp->selector);\n\t\treturn -EINVAL;\n\t}\n\n\tdcbx_info = qed_dcbnl_get_dcbx(hwfn, QED_DCBX_OPERATIONAL_MIB);\n\tif (!dcbx_info)\n\t\treturn -EINVAL;\n\n\tif (!dcbx_info->operational.ieee) {\n\t\tDP_INFO(hwfn, \"DCBX is not enabled/operational in IEEE mode\\n\");\n\t\tkfree(dcbx_info);\n\t\treturn -EINVAL;\n\t}\n\n\tkfree(dcbx_info);\n\n\tmemset(&dcbx_set, 0, sizeof(dcbx_set));\n\trc = qed_dcbx_get_config_params(hwfn, &dcbx_set);\n\tif (rc)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < QED_DCBX_MAX_APP_PROTOCOL; i++) {\n\t\tentry = &dcbx_set.config.params.app_entry[i];\n\t\tif ((entry->sf_ieee == sf_ieee) &&\n\t\t    (entry->proto_id == app->protocol))\n\t\t\tbreak;\n\t\t \n\t\tif (!entry->proto_id) {\n\t\t\tdcbx_set.config.params.num_app_entries++;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i == QED_DCBX_MAX_APP_PROTOCOL) {\n\t\tDP_ERR(cdev, \"App table is full\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tdcbx_set.override_flags |= QED_DCBX_OVERRIDE_APP_CFG;\n\tdcbx_set.config.params.app_entry[i].sf_ieee = sf_ieee;\n\tdcbx_set.config.params.app_entry[i].proto_id = app->protocol;\n\tdcbx_set.config.params.app_entry[i].prio = BIT(app->priority);\n\n\tptt = qed_ptt_acquire(hwfn);\n\tif (!ptt)\n\t\treturn -EBUSY;\n\n\trc = qed_dcbx_config_params(hwfn, ptt, &dcbx_set, 0);\n\n\tqed_ptt_release(hwfn, ptt);\n\n\treturn rc;\n}\n\nconst struct qed_eth_dcbnl_ops qed_dcbnl_ops_pass = {\n\t.getstate = qed_dcbnl_getstate,\n\t.setstate = qed_dcbnl_setstate,\n\t.getpgtccfgtx = qed_dcbnl_getpgtccfgtx,\n\t.getpgbwgcfgtx = qed_dcbnl_getpgbwgcfgtx,\n\t.getpgtccfgrx = qed_dcbnl_getpgtccfgrx,\n\t.getpgbwgcfgrx = qed_dcbnl_getpgbwgcfgrx,\n\t.getpfccfg = qed_dcbnl_getpfccfg,\n\t.setpfccfg = qed_dcbnl_setpfccfg,\n\t.getcap = qed_dcbnl_getcap,\n\t.getnumtcs = qed_dcbnl_getnumtcs,\n\t.getpfcstate = qed_dcbnl_getpfcstate,\n\t.getdcbx = qed_dcbnl_getdcbx,\n\t.setpgtccfgtx = qed_dcbnl_setpgtccfgtx,\n\t.setpgtccfgrx = qed_dcbnl_setpgtccfgrx,\n\t.setpgbwgcfgtx = qed_dcbnl_setpgbwgcfgtx,\n\t.setpgbwgcfgrx = qed_dcbnl_setpgbwgcfgrx,\n\t.setall = qed_dcbnl_setall,\n\t.setnumtcs = qed_dcbnl_setnumtcs,\n\t.setpfcstate = qed_dcbnl_setpfcstate,\n\t.setapp = qed_dcbnl_setapp,\n\t.setdcbx = qed_dcbnl_setdcbx,\n\t.setfeatcfg = qed_dcbnl_setfeatcfg,\n\t.getfeatcfg = qed_dcbnl_getfeatcfg,\n\t.getapp = qed_dcbnl_getapp,\n\t.peer_getappinfo = qed_dcbnl_peer_getappinfo,\n\t.peer_getapptable = qed_dcbnl_peer_getapptable,\n\t.cee_peer_getpfc = qed_dcbnl_cee_peer_getpfc,\n\t.cee_peer_getpg = qed_dcbnl_cee_peer_getpg,\n\t.ieee_getpfc = qed_dcbnl_ieee_getpfc,\n\t.ieee_setpfc = qed_dcbnl_ieee_setpfc,\n\t.ieee_getets = qed_dcbnl_ieee_getets,\n\t.ieee_setets = qed_dcbnl_ieee_setets,\n\t.ieee_peer_getpfc = qed_dcbnl_ieee_peer_getpfc,\n\t.ieee_peer_getets = qed_dcbnl_ieee_peer_getets,\n\t.ieee_getapp = qed_dcbnl_ieee_getapp,\n\t.ieee_setapp = qed_dcbnl_ieee_setapp,\n};\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}