{
  "module_name": "qed_debug.c",
  "hash_id": "6499ce484b546e4646f9060679f3382ed952d5f2ef1fbe3e1947274fbe5f2395",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/qlogic/qed/qed_debug.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include \"qed.h\"\n#include \"qed_cxt.h\"\n#include \"qed_hsi.h\"\n#include \"qed_dbg_hsi.h\"\n#include \"qed_hw.h\"\n#include \"qed_mcp.h\"\n#include \"qed_reg_addr.h\"\n\n \nenum mem_groups {\n\tMEM_GROUP_PXP_MEM,\n\tMEM_GROUP_DMAE_MEM,\n\tMEM_GROUP_CM_MEM,\n\tMEM_GROUP_QM_MEM,\n\tMEM_GROUP_DORQ_MEM,\n\tMEM_GROUP_BRB_RAM,\n\tMEM_GROUP_BRB_MEM,\n\tMEM_GROUP_PRS_MEM,\n\tMEM_GROUP_SDM_MEM,\n\tMEM_GROUP_PBUF,\n\tMEM_GROUP_IOR,\n\tMEM_GROUP_RAM,\n\tMEM_GROUP_BTB_RAM,\n\tMEM_GROUP_RDIF_CTX,\n\tMEM_GROUP_TDIF_CTX,\n\tMEM_GROUP_CFC_MEM,\n\tMEM_GROUP_CONN_CFC_MEM,\n\tMEM_GROUP_CAU_PI,\n\tMEM_GROUP_CAU_MEM,\n\tMEM_GROUP_CAU_MEM_EXT,\n\tMEM_GROUP_PXP_ILT,\n\tMEM_GROUP_MULD_MEM,\n\tMEM_GROUP_BTB_MEM,\n\tMEM_GROUP_IGU_MEM,\n\tMEM_GROUP_IGU_MSIX,\n\tMEM_GROUP_CAU_SB,\n\tMEM_GROUP_BMB_RAM,\n\tMEM_GROUP_BMB_MEM,\n\tMEM_GROUP_TM_MEM,\n\tMEM_GROUP_TASK_CFC_MEM,\n\tMEM_GROUPS_NUM\n};\n\n \nstatic const char * const s_mem_group_names[] = {\n\t\"PXP_MEM\",\n\t\"DMAE_MEM\",\n\t\"CM_MEM\",\n\t\"QM_MEM\",\n\t\"DORQ_MEM\",\n\t\"BRB_RAM\",\n\t\"BRB_MEM\",\n\t\"PRS_MEM\",\n\t\"SDM_MEM\",\n\t\"PBUF\",\n\t\"IOR\",\n\t\"RAM\",\n\t\"BTB_RAM\",\n\t\"RDIF_CTX\",\n\t\"TDIF_CTX\",\n\t\"CFC_MEM\",\n\t\"CONN_CFC_MEM\",\n\t\"CAU_PI\",\n\t\"CAU_MEM\",\n\t\"CAU_MEM_EXT\",\n\t\"PXP_ILT\",\n\t\"MULD_MEM\",\n\t\"BTB_MEM\",\n\t\"IGU_MEM\",\n\t\"IGU_MSIX\",\n\t\"CAU_SB\",\n\t\"BMB_RAM\",\n\t\"BMB_MEM\",\n\t\"TM_MEM\",\n\t\"TASK_CFC_MEM\",\n};\n\n \n\nstatic u32 cond5(const u32 *r, const u32 *imm)\n{\n\treturn ((r[0] & imm[0]) != imm[1]) && ((r[1] & imm[2]) != imm[3]);\n}\n\nstatic u32 cond7(const u32 *r, const u32 *imm)\n{\n\treturn ((r[0] >> imm[0]) & imm[1]) != imm[2];\n}\n\nstatic u32 cond6(const u32 *r, const u32 *imm)\n{\n\treturn (r[0] & imm[0]) != imm[1];\n}\n\nstatic u32 cond9(const u32 *r, const u32 *imm)\n{\n\treturn ((r[0] & imm[0]) >> imm[1]) !=\n\t    (((r[0] & imm[2]) >> imm[3]) | ((r[1] & imm[4]) << imm[5]));\n}\n\nstatic u32 cond10(const u32 *r, const u32 *imm)\n{\n\treturn ((r[0] & imm[0]) >> imm[1]) != (r[0] & imm[2]);\n}\n\nstatic u32 cond4(const u32 *r, const u32 *imm)\n{\n\treturn (r[0] & ~imm[0]) != imm[1];\n}\n\nstatic u32 cond0(const u32 *r, const u32 *imm)\n{\n\treturn (r[0] & ~r[1]) != imm[0];\n}\n\nstatic u32 cond14(const u32 *r, const u32 *imm)\n{\n\treturn (r[0] | imm[0]) != imm[1];\n}\n\nstatic u32 cond1(const u32 *r, const u32 *imm)\n{\n\treturn r[0] != imm[0];\n}\n\nstatic u32 cond11(const u32 *r, const u32 *imm)\n{\n\treturn r[0] != r[1] && r[2] == imm[0];\n}\n\nstatic u32 cond12(const u32 *r, const u32 *imm)\n{\n\treturn r[0] != r[1] && r[2] > imm[0];\n}\n\nstatic u32 cond3(const u32 *r, const u32 *imm)\n{\n\treturn r[0] != r[1];\n}\n\nstatic u32 cond13(const u32 *r, const u32 *imm)\n{\n\treturn r[0] & imm[0];\n}\n\nstatic u32 cond8(const u32 *r, const u32 *imm)\n{\n\treturn r[0] < (r[1] - imm[0]);\n}\n\nstatic u32 cond2(const u32 *r, const u32 *imm)\n{\n\treturn r[0] > imm[0];\n}\n\n \nstatic u32(*cond_arr[]) (const u32 *r, const u32 *imm) = {\n\tcond0,\n\tcond1,\n\tcond2,\n\tcond3,\n\tcond4,\n\tcond5,\n\tcond6,\n\tcond7,\n\tcond8,\n\tcond9,\n\tcond10,\n\tcond11,\n\tcond12,\n\tcond13,\n\tcond14,\n};\n\n#define NUM_PHYS_BLOCKS 84\n\n#define NUM_DBG_RESET_REGS 8\n\n \n\nenum hw_types {\n\tHW_TYPE_ASIC,\n\tPLATFORM_RESERVED,\n\tPLATFORM_RESERVED2,\n\tPLATFORM_RESERVED3,\n\tPLATFORM_RESERVED4,\n\tMAX_HW_TYPES\n};\n\n \nenum cm_ctx_types {\n\tCM_CTX_CONN_AG,\n\tCM_CTX_CONN_ST,\n\tCM_CTX_TASK_AG,\n\tCM_CTX_TASK_ST,\n\tNUM_CM_CTX_TYPES\n};\n\n \nenum dbg_bus_frame_modes {\n\tDBG_BUS_FRAME_MODE_4ST = 0,\t \n\tDBG_BUS_FRAME_MODE_2ST_2HW = 1,\t \n\tDBG_BUS_FRAME_MODE_1ST_3HW = 2,\t \n\tDBG_BUS_FRAME_MODE_4HW = 3,\t \n\tDBG_BUS_FRAME_MODE_8HW = 4,\t \n\tDBG_BUS_NUM_FRAME_MODES\n};\n\n \nenum dbg_bus_semi_frame_modes {\n\tDBG_BUS_SEMI_FRAME_MODE_4FAST = 0,\t \n\tDBG_BUS_SEMI_FRAME_MODE_2FAST_2SLOW = 1,  \n\tDBG_BUS_SEMI_FRAME_MODE_1FAST_3SLOW = 2,  \n\tDBG_BUS_SEMI_FRAME_MODE_4SLOW = 3,\t \n\tDBG_BUS_SEMI_NUM_FRAME_MODES\n};\n\n \nenum dbg_bus_filter_types {\n\tDBG_BUS_FILTER_TYPE_OFF,\t \n\tDBG_BUS_FILTER_TYPE_PRE,\t \n\tDBG_BUS_FILTER_TYPE_POST,\t \n\tDBG_BUS_FILTER_TYPE_ON\t \n};\n\n \nenum dbg_bus_pre_trigger_types {\n\tDBG_BUS_PRE_TRIGGER_FROM_ZERO,\t \n\tDBG_BUS_PRE_TRIGGER_NUM_CHUNKS,\t \n\tDBG_BUS_PRE_TRIGGER_DROP\t \n};\n\n \nenum dbg_bus_post_trigger_types {\n\tDBG_BUS_POST_TRIGGER_RECORD,\t \n\tDBG_BUS_POST_TRIGGER_DROP\t \n};\n\n \nenum dbg_bus_other_engine_modes {\n\tDBG_BUS_OTHER_ENGINE_MODE_NONE,\n\tDBG_BUS_OTHER_ENGINE_MODE_DOUBLE_BW_TX,\n\tDBG_BUS_OTHER_ENGINE_MODE_DOUBLE_BW_RX,\n\tDBG_BUS_OTHER_ENGINE_MODE_CROSS_ENGINE_TX,\n\tDBG_BUS_OTHER_ENGINE_MODE_CROSS_ENGINE_RX\n};\n\n \nstruct framing_mode_defs {\n\tu8 id;\n\tu8 blocks_dword_mask;\n\tu8 storms_dword_mask;\n\tu8 semi_framing_mode_id;\n\tu8 full_buf_thr;\n};\n\n \nstruct chip_defs {\n\tconst char *name;\n\tu8 dwords_per_cycle;\n\tu8 num_framing_modes;\n\tu32 num_ilt_pages;\n\tstruct framing_mode_defs *framing_modes;\n};\n\n \nstruct hw_type_defs {\n\tconst char *name;\n\tu32 delay_factor;\n\tu32 dmae_thresh;\n\tu32 log_thresh;\n};\n\n \nstruct rbc_reset_defs {\n\tu32 reset_reg_addr;\n\tu32 reset_val[MAX_CHIP_IDS];\n};\n\n \nstruct storm_defs {\n\tchar letter;\n\tenum block_id sem_block_id;\n\tenum dbg_bus_clients dbg_client_id[MAX_CHIP_IDS];\n\tbool has_vfc;\n\tu32 sem_fast_mem_addr;\n\tu32 sem_frame_mode_addr;\n\tu32 sem_slow_enable_addr;\n\tu32 sem_slow_mode_addr;\n\tu32 sem_slow_mode1_conf_addr;\n\tu32 sem_sync_dbg_empty_addr;\n\tu32 sem_gpre_vect_addr;\n\tu32 cm_ctx_wr_addr;\n\tu32 cm_ctx_rd_addr[NUM_CM_CTX_TYPES];\n\tu32 cm_ctx_lid_sizes[MAX_CHIP_IDS][NUM_CM_CTX_TYPES];\n};\n\n \nstruct dbg_bus_constraint_op_defs {\n\tu8 hw_op_val;\n\tbool is_cyclic;\n};\n\n \nstruct storm_mode_defs {\n\tconst char *name;\n\tbool is_fast_dbg;\n\tu8 id_in_hw;\n\tu32 src_disable_reg_addr;\n\tu32 src_enable_val;\n\tbool exists[MAX_CHIP_IDS];\n};\n\nstruct grc_param_defs {\n\tu32 default_val[MAX_CHIP_IDS];\n\tu32 min;\n\tu32 max;\n\tbool is_preset;\n\tbool is_persistent;\n\tu32 exclude_all_preset_val;\n\tu32 crash_preset_val[MAX_CHIP_IDS];\n};\n\n \nstruct rss_mem_defs {\n\tconst char *mem_name;\n\tconst char *type_name;\n\tu32 addr;\n\tu32 entry_width;\n\tu32 num_entries[MAX_CHIP_IDS];\n};\n\nstruct vfc_ram_defs {\n\tconst char *mem_name;\n\tconst char *type_name;\n\tu32 base_row;\n\tu32 num_rows;\n};\n\nstruct big_ram_defs {\n\tconst char *instance_name;\n\tenum mem_groups mem_group_id;\n\tenum mem_groups ram_mem_group_id;\n\tenum dbg_grc_params grc_param;\n\tu32 addr_reg_addr;\n\tu32 data_reg_addr;\n\tu32 is_256b_reg_addr;\n\tu32 is_256b_bit_offset[MAX_CHIP_IDS];\n\tu32 ram_size[MAX_CHIP_IDS];  \n};\n\nstruct phy_defs {\n\tconst char *phy_name;\n\n\t \n\tu32 base_addr;\n\n\t \n\tu32 tbus_addr_lo_addr;\n\n\t \n\tu32 tbus_addr_hi_addr;\n\n\t \n\tu32 tbus_data_lo_addr;\n\n\t \n\tu32 tbus_data_hi_addr;\n};\n\n \nstruct split_type_defs {\n\tconst char *name;\n};\n\n \n\n#define BYTES_IN_DWORD\t\t\tsizeof(u32)\n \n#define CEIL_DWORDS(size)\t\tDIV_ROUND_UP(size, 32)\n#define FIELD_BIT_OFFSET(type, field)\ttype ## _ ## field ## _ ## OFFSET\n#define FIELD_BIT_SIZE(type, field)\ttype ## _ ## field ## _ ## SIZE\n#define FIELD_DWORD_OFFSET(type, field) \\\n\t ((int)(FIELD_BIT_OFFSET(type, field) / 32))\n#define FIELD_DWORD_SHIFT(type, field)\t(FIELD_BIT_OFFSET(type, field) % 32)\n#define FIELD_BIT_MASK(type, field) \\\n\t(((1 << FIELD_BIT_SIZE(type, field)) - 1) << \\\n\t FIELD_DWORD_SHIFT(type, field))\n\n#define SET_VAR_FIELD(var, type, field, val) \\\n\tdo { \\\n\t\tvar[FIELD_DWORD_OFFSET(type, field)] &=\t\\\n\t\t(~FIELD_BIT_MASK(type, field));\t\\\n\t\tvar[FIELD_DWORD_OFFSET(type, field)] |= \\\n\t\t(val) << FIELD_DWORD_SHIFT(type, field); \\\n\t} while (0)\n\n#define ARR_REG_WR(dev, ptt, addr, arr, arr_size) \\\n\tdo { \\\n\t\tfor (i = 0; i < (arr_size); i++) \\\n\t\t\tqed_wr(dev, ptt, addr,\t(arr)[i]); \\\n\t} while (0)\n\n#define DWORDS_TO_BYTES(dwords)\t\t((dwords) * BYTES_IN_DWORD)\n#define BYTES_TO_DWORDS(bytes)\t\t((bytes) / BYTES_IN_DWORD)\n\n \n#define NUM_EXTRA_DBG_LINES(block) \\\n\t(GET_FIELD((block)->flags, DBG_BLOCK_CHIP_HAS_LATENCY_EVENTS) ? 2 : 1)\n#define NUM_DBG_LINES(block) \\\n\t((block)->num_of_dbg_bus_lines + NUM_EXTRA_DBG_LINES(block))\n\n#define USE_DMAE\t\t\ttrue\n#define PROTECT_WIDE_BUS\t\ttrue\n\n#define RAM_LINES_TO_DWORDS(lines)\t((lines) * 2)\n#define RAM_LINES_TO_BYTES(lines) \\\n\tDWORDS_TO_BYTES(RAM_LINES_TO_DWORDS(lines))\n\n#define REG_DUMP_LEN_SHIFT\t\t24\n#define MEM_DUMP_ENTRY_SIZE_DWORDS \\\n\tBYTES_TO_DWORDS(sizeof(struct dbg_dump_mem))\n\n#define IDLE_CHK_RULE_SIZE_DWORDS \\\n\tBYTES_TO_DWORDS(sizeof(struct dbg_idle_chk_rule))\n\n#define IDLE_CHK_RESULT_HDR_DWORDS \\\n\tBYTES_TO_DWORDS(sizeof(struct dbg_idle_chk_result_hdr))\n\n#define IDLE_CHK_RESULT_REG_HDR_DWORDS \\\n\tBYTES_TO_DWORDS(sizeof(struct dbg_idle_chk_result_reg_hdr))\n\n#define PAGE_MEM_DESC_SIZE_DWORDS \\\n\tBYTES_TO_DWORDS(sizeof(struct phys_mem_desc))\n\n#define IDLE_CHK_MAX_ENTRIES_SIZE\t32\n\n \n#define VFC_CAM_CMD_STRUCT_SIZE\t\t64\n#define VFC_CAM_CMD_ROW_OFFSET\t\t48\n#define VFC_CAM_CMD_ROW_SIZE\t\t9\n#define VFC_CAM_ADDR_STRUCT_SIZE\t16\n#define VFC_CAM_ADDR_OP_OFFSET\t\t0\n#define VFC_CAM_ADDR_OP_SIZE\t\t4\n#define VFC_CAM_RESP_STRUCT_SIZE\t256\n#define VFC_RAM_ADDR_STRUCT_SIZE\t16\n#define VFC_RAM_ADDR_OP_OFFSET\t\t0\n#define VFC_RAM_ADDR_OP_SIZE\t\t2\n#define VFC_RAM_ADDR_ROW_OFFSET\t\t2\n#define VFC_RAM_ADDR_ROW_SIZE\t\t10\n#define VFC_RAM_RESP_STRUCT_SIZE\t256\n\n#define VFC_CAM_CMD_DWORDS\t\tCEIL_DWORDS(VFC_CAM_CMD_STRUCT_SIZE)\n#define VFC_CAM_ADDR_DWORDS\t\tCEIL_DWORDS(VFC_CAM_ADDR_STRUCT_SIZE)\n#define VFC_CAM_RESP_DWORDS\t\tCEIL_DWORDS(VFC_CAM_RESP_STRUCT_SIZE)\n#define VFC_RAM_CMD_DWORDS\t\tVFC_CAM_CMD_DWORDS\n#define VFC_RAM_ADDR_DWORDS\t\tCEIL_DWORDS(VFC_RAM_ADDR_STRUCT_SIZE)\n#define VFC_RAM_RESP_DWORDS\t\tCEIL_DWORDS(VFC_RAM_RESP_STRUCT_SIZE)\n\n#define NUM_VFC_RAM_TYPES\t\t4\n\n#define VFC_CAM_NUM_ROWS\t\t512\n\n#define VFC_OPCODE_CAM_RD\t\t14\n#define VFC_OPCODE_RAM_RD\t\t0\n\n#define NUM_RSS_MEM_TYPES\t\t5\n\n#define NUM_BIG_RAM_TYPES\t\t3\n#define BIG_RAM_NAME_LEN\t\t3\n\n#define NUM_PHY_TBUS_ADDRESSES\t\t2048\n#define PHY_DUMP_SIZE_DWORDS\t\t(NUM_PHY_TBUS_ADDRESSES / 2)\n\n#define RESET_REG_UNRESET_OFFSET\t4\n\n#define STALL_DELAY_MS\t\t\t500\n\n#define STATIC_DEBUG_LINE_DWORDS\t9\n\n#define NUM_COMMON_GLOBAL_PARAMS\t10\n\n#define MAX_RECURSION_DEPTH\t\t10\n\n#define FW_IMG_KUKU                     0\n#define FW_IMG_MAIN\t\t\t1\n#define FW_IMG_L2B                      2\n\n#define REG_FIFO_ELEMENT_DWORDS\t\t2\n#define REG_FIFO_DEPTH_ELEMENTS\t\t32\n#define REG_FIFO_DEPTH_DWORDS \\\n\t(REG_FIFO_ELEMENT_DWORDS * REG_FIFO_DEPTH_ELEMENTS)\n\n#define IGU_FIFO_ELEMENT_DWORDS\t\t4\n#define IGU_FIFO_DEPTH_ELEMENTS\t\t64\n#define IGU_FIFO_DEPTH_DWORDS \\\n\t(IGU_FIFO_ELEMENT_DWORDS * IGU_FIFO_DEPTH_ELEMENTS)\n\n#define PROTECTION_OVERRIDE_ELEMENT_DWORDS\t2\n#define PROTECTION_OVERRIDE_DEPTH_ELEMENTS\t20\n#define PROTECTION_OVERRIDE_DEPTH_DWORDS \\\n\t(PROTECTION_OVERRIDE_DEPTH_ELEMENTS * \\\n\t PROTECTION_OVERRIDE_ELEMENT_DWORDS)\n\n#define MCP_SPAD_TRACE_OFFSIZE_ADDR \\\n\t(MCP_REG_SCRATCH + \\\n\t offsetof(struct static_init, sections[SPAD_SECTION_TRACE]))\n\n#define MAX_SW_PLTAFORM_STR_SIZE\t64\n\n#define EMPTY_FW_VERSION_STR\t\t\"???_???_???_???\"\n#define EMPTY_FW_IMAGE_STR\t\t\"???????????????\"\n\n \n\n \nstatic struct framing_mode_defs s_framing_mode_defs[4] = {\n\t{DBG_BUS_FRAME_MODE_4ST, 0x0, 0xf,\n\t DBG_BUS_SEMI_FRAME_MODE_4FAST,\n\t 10},\n\t{DBG_BUS_FRAME_MODE_4HW, 0xf, 0x0, DBG_BUS_SEMI_FRAME_MODE_4SLOW,\n\t 10},\n\t{DBG_BUS_FRAME_MODE_2ST_2HW, 0x3, 0xc,\n\t DBG_BUS_SEMI_FRAME_MODE_2FAST_2SLOW, 10},\n\t{DBG_BUS_FRAME_MODE_1ST_3HW, 0x7, 0x8,\n\t DBG_BUS_SEMI_FRAME_MODE_1FAST_3SLOW, 10}\n};\n\n \nstatic struct chip_defs s_chip_defs[MAX_CHIP_IDS] = {\n\t{\"bb\", 4, DBG_BUS_NUM_FRAME_MODES, PSWRQ2_REG_ILT_MEMORY_SIZE_BB / 2,\n\t s_framing_mode_defs},\n\t{\"ah\", 4, DBG_BUS_NUM_FRAME_MODES, PSWRQ2_REG_ILT_MEMORY_SIZE_K2 / 2,\n\t s_framing_mode_defs}\n};\n\n \nstatic struct storm_defs s_storm_defs[] = {\n\t \n\t{'T', BLOCK_TSEM,\n\t\t{DBG_BUS_CLIENT_RBCT, DBG_BUS_CLIENT_RBCT},\n\t\ttrue,\n\t\tTSEM_REG_FAST_MEMORY,\n\t\tTSEM_REG_DBG_FRAME_MODE, TSEM_REG_SLOW_DBG_ACTIVE,\n\t\tTSEM_REG_SLOW_DBG_MODE, TSEM_REG_DBG_MODE1_CFG,\n\t\tTSEM_REG_SYNC_DBG_EMPTY, TSEM_REG_DBG_GPRE_VECT,\n\t\tTCM_REG_CTX_RBC_ACCS,\n\t\t{TCM_REG_AGG_CON_CTX, TCM_REG_SM_CON_CTX, TCM_REG_AGG_TASK_CTX,\n\t\t TCM_REG_SM_TASK_CTX},\n\t\t{{4, 16, 2, 4}, {4, 16, 2, 4}}  \n\t},\n\n\t \n\t{'M', BLOCK_MSEM,\n\t\t{DBG_BUS_CLIENT_RBCT, DBG_BUS_CLIENT_RBCM},\n\t\tfalse,\n\t\tMSEM_REG_FAST_MEMORY,\n\t\tMSEM_REG_DBG_FRAME_MODE,\n\t\tMSEM_REG_SLOW_DBG_ACTIVE,\n\t\tMSEM_REG_SLOW_DBG_MODE,\n\t\tMSEM_REG_DBG_MODE1_CFG,\n\t\tMSEM_REG_SYNC_DBG_EMPTY,\n\t\tMSEM_REG_DBG_GPRE_VECT,\n\t\tMCM_REG_CTX_RBC_ACCS,\n\t\t{MCM_REG_AGG_CON_CTX, MCM_REG_SM_CON_CTX, MCM_REG_AGG_TASK_CTX,\n\t\t MCM_REG_SM_TASK_CTX },\n\t\t{{1, 10, 2, 7}, {1, 10, 2, 7}}  \n\t},\n\n\t \n\t{'U', BLOCK_USEM,\n\t\t{DBG_BUS_CLIENT_RBCU, DBG_BUS_CLIENT_RBCU},\n\t\tfalse,\n\t\tUSEM_REG_FAST_MEMORY,\n\t\tUSEM_REG_DBG_FRAME_MODE,\n\t\tUSEM_REG_SLOW_DBG_ACTIVE,\n\t\tUSEM_REG_SLOW_DBG_MODE,\n\t\tUSEM_REG_DBG_MODE1_CFG,\n\t\tUSEM_REG_SYNC_DBG_EMPTY,\n\t\tUSEM_REG_DBG_GPRE_VECT,\n\t\tUCM_REG_CTX_RBC_ACCS,\n\t\t{UCM_REG_AGG_CON_CTX, UCM_REG_SM_CON_CTX, UCM_REG_AGG_TASK_CTX,\n\t\t UCM_REG_SM_TASK_CTX},\n\t\t{{2, 13, 3, 3}, {2, 13, 3, 3}}  \n\t},\n\n\t \n\t{'X', BLOCK_XSEM,\n\t\t{DBG_BUS_CLIENT_RBCX, DBG_BUS_CLIENT_RBCX},\n\t\tfalse,\n\t\tXSEM_REG_FAST_MEMORY,\n\t\tXSEM_REG_DBG_FRAME_MODE,\n\t\tXSEM_REG_SLOW_DBG_ACTIVE,\n\t\tXSEM_REG_SLOW_DBG_MODE,\n\t\tXSEM_REG_DBG_MODE1_CFG,\n\t\tXSEM_REG_SYNC_DBG_EMPTY,\n\t\tXSEM_REG_DBG_GPRE_VECT,\n\t\tXCM_REG_CTX_RBC_ACCS,\n\t\t{XCM_REG_AGG_CON_CTX, XCM_REG_SM_CON_CTX, 0, 0},\n\t\t{{9, 15, 0, 0}, {9, 15,\t0, 0}}  \n\t},\n\n\t \n\t{'Y', BLOCK_YSEM,\n\t\t{DBG_BUS_CLIENT_RBCX, DBG_BUS_CLIENT_RBCY},\n\t\tfalse,\n\t\tYSEM_REG_FAST_MEMORY,\n\t\tYSEM_REG_DBG_FRAME_MODE,\n\t\tYSEM_REG_SLOW_DBG_ACTIVE,\n\t\tYSEM_REG_SLOW_DBG_MODE,\n\t\tYSEM_REG_DBG_MODE1_CFG,\n\t\tYSEM_REG_SYNC_DBG_EMPTY,\n\t\tYSEM_REG_DBG_GPRE_VECT,\n\t\tYCM_REG_CTX_RBC_ACCS,\n\t\t{YCM_REG_AGG_CON_CTX, YCM_REG_SM_CON_CTX, YCM_REG_AGG_TASK_CTX,\n\t\t YCM_REG_SM_TASK_CTX},\n\t\t{{2, 3, 2, 12}, {2, 3, 2, 12}}  \n\t},\n\n\t \n\t{'P', BLOCK_PSEM,\n\t\t{DBG_BUS_CLIENT_RBCS, DBG_BUS_CLIENT_RBCS},\n\t\ttrue,\n\t\tPSEM_REG_FAST_MEMORY,\n\t\tPSEM_REG_DBG_FRAME_MODE,\n\t\tPSEM_REG_SLOW_DBG_ACTIVE,\n\t\tPSEM_REG_SLOW_DBG_MODE,\n\t\tPSEM_REG_DBG_MODE1_CFG,\n\t\tPSEM_REG_SYNC_DBG_EMPTY,\n\t\tPSEM_REG_DBG_GPRE_VECT,\n\t\tPCM_REG_CTX_RBC_ACCS,\n\t\t{0, PCM_REG_SM_CON_CTX, 0, 0},\n\t\t{{0, 10, 0, 0}, {0, 10, 0, 0}}  \n\t},\n};\n\nstatic struct hw_type_defs s_hw_type_defs[] = {\n\t \n\t{\"asic\", 1, 256, 32768},\n\t{\"reserved\", 0, 0, 0},\n\t{\"reserved2\", 0, 0, 0},\n\t{\"reserved3\", 0, 0, 0},\n\t{\"reserved4\", 0, 0, 0}\n};\n\nstatic struct grc_param_defs s_grc_param_defs[] = {\n\t \n\t{{1, 1}, 0, 1, false, false, 1, {1, 1}},\n\n\t \n\t{{1, 1}, 0, 1, false, false, 1, {1, 1}},\n\n\t \n\t{{1, 1}, 0, 1, false, false, 1, {1, 1}},\n\n\t \n\t{{1, 1}, 0, 1, false, false, 1, {1, 1}},\n\n\t \n\t{{1, 1}, 0, 1, false, false, 1, {1, 1}},\n\n\t \n\t{{1, 1}, 0, 1, false, false, 1, {1, 1}},\n\n\t \n\t{{1, 1}, 0, 1, false, false, 0, {1, 1}},\n\n\t \n\t{{1, 1}, 0, 1, false, false, 0, {1, 1}},\n\n\t \n\t{{1, 1}, 0, 1, false, false, 0, {1, 1}},\n\n\t \n\t{{0, 0}, 0, 1, false, false, 0, {1, 1}},\n\n\t \n\t{{0, 0}, 0, 1, false, false, 0, {1, 1}},\n\n\t \n\t{{1, 1}, 0, 1, false, false, 0, {1, 1}},\n\n\t \n\t{{1, 1}, 0, 1, false, false, 0, {1, 1}},\n\n\t \n\t{{1, 1}, 0, 1, false, false, 0, {1, 1}},\n\n\t \n\t{{1, 1}, 0, 1, false, false, 0, {1, 1}},\n\n\t \n\t{{1, 1}, 0, 1, false, false, 0, {1, 1}},\n\n\t \n\t{{1, 1}, 0, 1, false, false, 0, {1, 1}},\n\n\t \n\t{{1, 1}, 0, 1, false, false, 0, {1, 1}},\n\n\t \n\t{{1, 1}, 0, 1, false, false, 0, {1, 1}},\n\n\t \n\t{{1, 1}, 0, 1, false, false, 0, {1, 1}},\n\n\t \n\t{{0, 0}, 0, 1, false, false, 0, {1, 1}},\n\n\t \n\t{{0, 0}, 0, 1, false, false, 0, {1, 1}},\n\n\t \n\t{{0, 0}, 0, 1, false, false, 0, {0, 0}},\n\n\t \n\t{{0, 0}, 0, 1, false, false, 0, {0, 0}},\n\n\t \n\t{{1, 1}, 0, 1, false, false, 0, {1, 1}},\n\n\t \n\t{{1, 1}, 0, 1, false, false, 0, {1, 1}},\n\n\t \n\t{{1, 1}, 0, 1, false, false, 0, {1, 1}},\n\n\t \n\t{{1, 1}, 0, 1, false, false, 0, {1, 1}},\n\n\t \n\t{{1, 1}, 0, 1, false, false, 0, {1, 1}},\n\n\t \n\t{{1, 1}, 0, 1, false, false, 0, {1, 1}},\n\n\t \n\t{{1, 1}, 0, 1, false, false, 0, {1, 1}},\n\n\t \n\t{{0, 0}, 0, 1, false, false, 0, {0, 0}},\n\n\t \n\t{{0, 0}, 0, 1, false, false, 0, {0, 0}},\n\n\t \n\t{{0, 0}, 1, 0xffffffff, false, true, 0, {0, 0}},\n\n\t \n\t{{0, 0}, 0, 1, true, false, 0, {0, 0}},\n\n\t \n\t{{0, 0}, 0, 1, true, false, 0, {0, 0}},\n\n\t \n\t{{0, 0}, 0, 1, false, false, 0, {0, 0}},\n\n\t \n\t{{1, 1}, 0, 1, false, false, 0, {1, 1}},\n\n\t \n\t{{0, 0}, 0, 1, false, false, 0, {0, 0}},\n\n\t \n\t{{0, 0}, 0, 1, false, false, 0, {0, 0}},\n\n\t \n\t{{0, 0}, 0, 1, false, false, 0, {0, 0}},\n\n\t \n\t{{0, 0}, 0, 1, false, false, 0, {0, 0}},\n\n\t \n\t{{0, 1}, 0, 1, false, false, 0, {0, 1}},\n\n\t \n\t{{1, 1}, 0, 1, false, false, 0, {0, 0}},\n\n\t \n\t{{1, 1}, 0, 1, false, false, 0, {0, 0}},\n\n\t \n\t{{0, 0}, 0, 1, false, false, 0, {1, 1}}\n};\n\nstatic struct rss_mem_defs s_rss_mem_defs[] = {\n\t{\"rss_mem_cid\", \"rss_cid\", 0, 32,\n\t {256, 320}},\n\n\t{\"rss_mem_key_msb\", \"rss_key\", 1024, 256,\n\t {128, 208}},\n\n\t{\"rss_mem_key_lsb\", \"rss_key\", 2048, 64,\n\t {128, 208}},\n\n\t{\"rss_mem_info\", \"rss_info\", 3072, 16,\n\t {128, 208}},\n\n\t{\"rss_mem_ind\", \"rss_ind\", 4096, 16,\n\t {16384, 26624}}\n};\n\nstatic struct vfc_ram_defs s_vfc_ram_defs[] = {\n\t{\"vfc_ram_tt1\", \"vfc_ram\", 0, 512},\n\t{\"vfc_ram_mtt2\", \"vfc_ram\", 512, 128},\n\t{\"vfc_ram_stt2\", \"vfc_ram\", 640, 32},\n\t{\"vfc_ram_ro_vect\", \"vfc_ram\", 672, 32}\n};\n\nstatic struct big_ram_defs s_big_ram_defs[] = {\n\t{\"BRB\", MEM_GROUP_BRB_MEM, MEM_GROUP_BRB_RAM, DBG_GRC_PARAM_DUMP_BRB,\n\t BRB_REG_BIG_RAM_ADDRESS, BRB_REG_BIG_RAM_DATA,\n\t MISC_REG_BLOCK_256B_EN, {0, 0},\n\t {153600, 180224}},\n\n\t{\"BTB\", MEM_GROUP_BTB_MEM, MEM_GROUP_BTB_RAM, DBG_GRC_PARAM_DUMP_BTB,\n\t BTB_REG_BIG_RAM_ADDRESS, BTB_REG_BIG_RAM_DATA,\n\t MISC_REG_BLOCK_256B_EN, {0, 1},\n\t {92160, 117760}},\n\n\t{\"BMB\", MEM_GROUP_BMB_MEM, MEM_GROUP_BMB_RAM, DBG_GRC_PARAM_DUMP_BMB,\n\t BMB_REG_BIG_RAM_ADDRESS, BMB_REG_BIG_RAM_DATA,\n\t MISCS_REG_BLOCK_256B_EN, {0, 0},\n\t {36864, 36864}}\n};\n\nstatic struct rbc_reset_defs s_rbc_reset_defs[] = {\n\t{MISCS_REG_RESET_PL_HV,\n\t {0x0, 0x400}},\n\t{MISC_REG_RESET_PL_PDA_VMAIN_1,\n\t {0x4404040, 0x4404040}},\n\t{MISC_REG_RESET_PL_PDA_VMAIN_2,\n\t {0x7, 0x7c00007}},\n\t{MISC_REG_RESET_PL_PDA_VAUX,\n\t {0x2, 0x2}},\n};\n\nstatic struct phy_defs s_phy_defs[] = {\n\t{\"nw_phy\", NWS_REG_NWS_CMU_K2,\n\t PHY_NW_IP_REG_PHY0_TOP_TBUS_ADDR_7_0_K2,\n\t PHY_NW_IP_REG_PHY0_TOP_TBUS_ADDR_15_8_K2,\n\t PHY_NW_IP_REG_PHY0_TOP_TBUS_DATA_7_0_K2,\n\t PHY_NW_IP_REG_PHY0_TOP_TBUS_DATA_11_8_K2},\n\t{\"sgmii_phy\", MS_REG_MS_CMU_K2,\n\t PHY_SGMII_IP_REG_AHB_CMU_CSR_0_X132_K2,\n\t PHY_SGMII_IP_REG_AHB_CMU_CSR_0_X133_K2,\n\t PHY_SGMII_IP_REG_AHB_CMU_CSR_0_X130_K2,\n\t PHY_SGMII_IP_REG_AHB_CMU_CSR_0_X131_K2},\n\t{\"pcie_phy0\", PHY_PCIE_REG_PHY0_K2,\n\t PHY_PCIE_IP_REG_AHB_CMU_CSR_0_X132_K2,\n\t PHY_PCIE_IP_REG_AHB_CMU_CSR_0_X133_K2,\n\t PHY_PCIE_IP_REG_AHB_CMU_CSR_0_X130_K2,\n\t PHY_PCIE_IP_REG_AHB_CMU_CSR_0_X131_K2},\n\t{\"pcie_phy1\", PHY_PCIE_REG_PHY1_K2,\n\t PHY_PCIE_IP_REG_AHB_CMU_CSR_0_X132_K2,\n\t PHY_PCIE_IP_REG_AHB_CMU_CSR_0_X133_K2,\n\t PHY_PCIE_IP_REG_AHB_CMU_CSR_0_X130_K2,\n\t PHY_PCIE_IP_REG_AHB_CMU_CSR_0_X131_K2},\n};\n\nstatic struct split_type_defs s_split_type_defs[] = {\n\t \n\t{\"eng\"},\n\n\t \n\t{\"port\"},\n\n\t \n\t{\"pf\"},\n\n\t \n\t{\"port\"},\n\n\t \n\t{\"vf\"}\n};\n\n \n\n \nstatic u32 s_app_ver;\n\n \n\nstatic void qed_static_asserts(void)\n{\n}\n\n \nstatic u32 qed_read_unaligned_dword(u8 *buf)\n{\n\tu32 dword;\n\n\tmemcpy((u8 *)&dword, buf, sizeof(dword));\n\treturn dword;\n}\n\n \nstatic void qed_grc_set_param(struct qed_hwfn *p_hwfn,\n\t\t\t      enum dbg_grc_params grc_param, u32 val)\n{\n\tstruct dbg_tools_data *dev_data = &p_hwfn->dbg_info;\n\n\tdev_data->grc.param_val[grc_param] = val;\n}\n\n \nstatic u32 qed_grc_get_param(struct qed_hwfn *p_hwfn,\n\t\t\t     enum dbg_grc_params grc_param)\n{\n\tstruct dbg_tools_data *dev_data = &p_hwfn->dbg_info;\n\n\treturn dev_data->grc.param_val[grc_param];\n}\n\n \nstatic void qed_dbg_grc_init_params(struct qed_hwfn *p_hwfn)\n{\n\tstruct dbg_tools_data *dev_data = &p_hwfn->dbg_info;\n\n\tif (!dev_data->grc.params_initialized) {\n\t\tqed_dbg_grc_set_params_default(p_hwfn);\n\t\tdev_data->grc.params_initialized = 1;\n\t}\n}\n\n \nstatic void qed_set_dbg_bin_buf(struct qed_hwfn *p_hwfn,\n\t\t\t\tenum bin_dbg_buffer_type buf_type,\n\t\t\t\tconst u32 *ptr, u32 size)\n{\n\tstruct virt_mem_desc *buf = &p_hwfn->dbg_arrays[buf_type];\n\n\tbuf->ptr = (void *)ptr;\n\tbuf->size = size;\n}\n\n \nstatic enum dbg_status qed_dbg_dev_init(struct qed_hwfn *p_hwfn)\n{\n\tstruct dbg_tools_data *dev_data = &p_hwfn->dbg_info;\n\tu8 num_pfs = 0, max_pfs_per_port = 0;\n\n\tif (dev_data->initialized)\n\t\treturn DBG_STATUS_OK;\n\n\tif (!s_app_ver)\n\t\treturn DBG_STATUS_APP_VERSION_NOT_SET;\n\n\t \n\tif (QED_IS_K2(p_hwfn->cdev)) {\n\t\tdev_data->chip_id = CHIP_K2;\n\t\tdev_data->mode_enable[MODE_K2] = 1;\n\t\tdev_data->num_vfs = MAX_NUM_VFS_K2;\n\t\tnum_pfs = MAX_NUM_PFS_K2;\n\t\tmax_pfs_per_port = MAX_NUM_PFS_K2 / 2;\n\t} else if (QED_IS_BB_B0(p_hwfn->cdev)) {\n\t\tdev_data->chip_id = CHIP_BB;\n\t\tdev_data->mode_enable[MODE_BB] = 1;\n\t\tdev_data->num_vfs = MAX_NUM_VFS_BB;\n\t\tnum_pfs = MAX_NUM_PFS_BB;\n\t\tmax_pfs_per_port = MAX_NUM_PFS_BB;\n\t} else {\n\t\treturn DBG_STATUS_UNKNOWN_CHIP;\n\t}\n\n\t \n\tdev_data->hw_type = HW_TYPE_ASIC;\n\tdev_data->mode_enable[MODE_ASIC] = 1;\n\n\t \n\tswitch (p_hwfn->cdev->num_ports_in_engine) {\n\tcase 1:\n\t\tdev_data->mode_enable[MODE_PORTS_PER_ENG_1] = 1;\n\t\tbreak;\n\tcase 2:\n\t\tdev_data->mode_enable[MODE_PORTS_PER_ENG_2] = 1;\n\t\tbreak;\n\tcase 4:\n\t\tdev_data->mode_enable[MODE_PORTS_PER_ENG_4] = 1;\n\t\tbreak;\n\t}\n\n\t \n\tif (QED_IS_CMT(p_hwfn->cdev))\n\t\tdev_data->mode_enable[MODE_100G] = 1;\n\n\t \n\tif (dev_data->mode_enable[MODE_PORTS_PER_ENG_1] ||\n\t    dev_data->mode_enable[MODE_100G])\n\t\tdev_data->num_ports = 1;\n\telse if (dev_data->mode_enable[MODE_PORTS_PER_ENG_2])\n\t\tdev_data->num_ports = 2;\n\telse if (dev_data->mode_enable[MODE_PORTS_PER_ENG_4])\n\t\tdev_data->num_ports = 4;\n\n\t \n\tdev_data->num_pfs_per_port = min_t(u32,\n\t\t\t\t\t   num_pfs / dev_data->num_ports,\n\t\t\t\t\t   max_pfs_per_port);\n\n\t \n\tqed_dbg_grc_init_params(p_hwfn);\n\n\tdev_data->use_dmae = true;\n\tdev_data->initialized = 1;\n\n\treturn DBG_STATUS_OK;\n}\n\nstatic const struct dbg_block *get_dbg_block(struct qed_hwfn *p_hwfn,\n\t\t\t\t\t     enum block_id block_id)\n{\n\tconst struct dbg_block *dbg_block;\n\n\tdbg_block = p_hwfn->dbg_arrays[BIN_BUF_DBG_BLOCKS].ptr;\n\treturn dbg_block + block_id;\n}\n\nstatic const struct dbg_block_chip *qed_get_dbg_block_per_chip(struct qed_hwfn\n\t\t\t\t\t\t\t       *p_hwfn,\n\t\t\t\t\t\t\t       enum block_id\n\t\t\t\t\t\t\t       block_id)\n{\n\tstruct dbg_tools_data *dev_data = &p_hwfn->dbg_info;\n\n\treturn (const struct dbg_block_chip *)\n\t    p_hwfn->dbg_arrays[BIN_BUF_DBG_BLOCKS_CHIP_DATA].ptr +\n\t    block_id * MAX_CHIP_IDS + dev_data->chip_id;\n}\n\nstatic const struct dbg_reset_reg *qed_get_dbg_reset_reg(struct qed_hwfn\n\t\t\t\t\t\t\t *p_hwfn,\n\t\t\t\t\t\t\t u8 reset_reg_id)\n{\n\tstruct dbg_tools_data *dev_data = &p_hwfn->dbg_info;\n\n\treturn (const struct dbg_reset_reg *)\n\t    p_hwfn->dbg_arrays[BIN_BUF_DBG_RESET_REGS].ptr +\n\t    reset_reg_id * MAX_CHIP_IDS + dev_data->chip_id;\n}\n\n \nstatic void qed_read_storm_fw_info(struct qed_hwfn *p_hwfn,\n\t\t\t\t   struct qed_ptt *p_ptt,\n\t\t\t\t   u8 storm_id, struct fw_info *fw_info)\n{\n\tstruct storm_defs *storm = &s_storm_defs[storm_id];\n\tstruct fw_info_location fw_info_location;\n\tu32 addr, i, size, *dest;\n\n\tmemset(&fw_info_location, 0, sizeof(fw_info_location));\n\tmemset(fw_info, 0, sizeof(*fw_info));\n\n\t \n\taddr = storm->sem_fast_mem_addr + SEM_FAST_REG_INT_RAM +\n\t    DWORDS_TO_BYTES(SEM_FAST_REG_INT_RAM_SIZE) -\n\t    sizeof(fw_info_location);\n\n\tdest = (u32 *)&fw_info_location;\n\tsize = BYTES_TO_DWORDS(sizeof(fw_info_location));\n\n\tfor (i = 0; i < size; i++, addr += BYTES_IN_DWORD)\n\t\tdest[i] = qed_rd(p_hwfn, p_ptt, addr);\n\n\t \n\tsize = le32_to_cpu(fw_info_location.size);\n\tif (!size || size > sizeof(*fw_info))\n\t\treturn;\n\n\taddr = le32_to_cpu(fw_info_location.grc_addr);\n\tdest = (u32 *)fw_info;\n\tsize = BYTES_TO_DWORDS(size);\n\n\tfor (i = 0; i < size; i++, addr += BYTES_IN_DWORD)\n\t\tdest[i] = qed_rd(p_hwfn, p_ptt, addr);\n}\n\n \nstatic u32 qed_dump_str(char *dump_buf, bool dump, const char *str)\n{\n\tif (dump)\n\t\tstrcpy(dump_buf, str);\n\n\treturn (u32)strlen(str) + 1;\n}\n\n \nstatic u32 qed_dump_align(char *dump_buf, bool dump, u32 byte_offset)\n{\n\tu8 offset_in_dword, align_size;\n\n\toffset_in_dword = (u8)(byte_offset & 0x3);\n\talign_size = offset_in_dword ? BYTES_IN_DWORD - offset_in_dword : 0;\n\n\tif (dump && align_size)\n\t\tmemset(dump_buf, 0, align_size);\n\n\treturn align_size;\n}\n\n \nstatic u32 qed_dump_str_param(u32 *dump_buf,\n\t\t\t      bool dump,\n\t\t\t      const char *param_name, const char *param_val)\n{\n\tchar *char_buf = (char *)dump_buf;\n\tu32 offset = 0;\n\n\t \n\toffset += qed_dump_str(char_buf + offset, dump, param_name);\n\n\t \n\tif (dump)\n\t\t*(char_buf + offset) = 1;\n\toffset++;\n\n\t \n\toffset += qed_dump_str(char_buf + offset, dump, param_val);\n\n\t \n\toffset += qed_dump_align(char_buf + offset, dump, offset);\n\n\treturn BYTES_TO_DWORDS(offset);\n}\n\n \nstatic u32 qed_dump_num_param(u32 *dump_buf,\n\t\t\t      bool dump, const char *param_name, u32 param_val)\n{\n\tchar *char_buf = (char *)dump_buf;\n\tu32 offset = 0;\n\n\t \n\toffset += qed_dump_str(char_buf + offset, dump, param_name);\n\n\t \n\tif (dump)\n\t\t*(char_buf + offset) = 0;\n\toffset++;\n\n\t \n\toffset += qed_dump_align(char_buf + offset, dump, offset);\n\n\t \n\toffset = BYTES_TO_DWORDS(offset);\n\tif (dump)\n\t\t*(dump_buf + offset) = param_val;\n\toffset++;\n\n\treturn offset;\n}\n\n \nstatic u32 qed_dump_fw_ver_param(struct qed_hwfn *p_hwfn,\n\t\t\t\t struct qed_ptt *p_ptt,\n\t\t\t\t u32 *dump_buf, bool dump)\n{\n\tchar fw_ver_str[16] = EMPTY_FW_VERSION_STR;\n\tchar fw_img_str[16] = EMPTY_FW_IMAGE_STR;\n\tstruct fw_info fw_info = { {0}, {0} };\n\tu32 offset = 0;\n\n\tif (dump && !qed_grc_get_param(p_hwfn, DBG_GRC_PARAM_NO_FW_VER)) {\n\t\t \n\t\tqed_read_fw_info(p_hwfn, p_ptt, &fw_info);\n\n\t\t \n\t\tif (snprintf(fw_ver_str, sizeof(fw_ver_str),\n\t\t\t     \"%d_%d_%d_%d\", fw_info.ver.num.major,\n\t\t\t     fw_info.ver.num.minor, fw_info.ver.num.rev,\n\t\t\t     fw_info.ver.num.eng) < 0)\n\t\t\tDP_NOTICE(p_hwfn,\n\t\t\t\t  \"Unexpected debug error: invalid FW version string\\n\");\n\t\tswitch (fw_info.ver.image_id) {\n\t\tcase FW_IMG_KUKU:\n\t\t\tstrcpy(fw_img_str, \"kuku\");\n\t\t\tbreak;\n\t\tcase FW_IMG_MAIN:\n\t\t\tstrcpy(fw_img_str, \"main\");\n\t\t\tbreak;\n\t\tcase FW_IMG_L2B:\n\t\t\tstrcpy(fw_img_str, \"l2b\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstrcpy(fw_img_str, \"unknown\");\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\toffset += qed_dump_str_param(dump_buf + offset,\n\t\t\t\t     dump, \"fw-version\", fw_ver_str);\n\toffset += qed_dump_str_param(dump_buf + offset,\n\t\t\t\t     dump, \"fw-image\", fw_img_str);\n\toffset += qed_dump_num_param(dump_buf + offset, dump, \"fw-timestamp\",\n\t\t\t\t     le32_to_cpu(fw_info.ver.timestamp));\n\n\treturn offset;\n}\n\n \nstatic u32 qed_dump_mfw_ver_param(struct qed_hwfn *p_hwfn,\n\t\t\t\t  struct qed_ptt *p_ptt,\n\t\t\t\t  u32 *dump_buf, bool dump)\n{\n\tchar mfw_ver_str[16] = EMPTY_FW_VERSION_STR;\n\n\tif (dump &&\n\t    !qed_grc_get_param(p_hwfn, DBG_GRC_PARAM_NO_FW_VER)) {\n\t\tu32 global_section_offsize, global_section_addr, mfw_ver;\n\t\tu32 public_data_addr, global_section_offsize_addr;\n\n\t\t \n\t\tpublic_data_addr = qed_rd(p_hwfn,\n\t\t\t\t\t  p_ptt,\n\t\t\t\t\t  MISC_REG_SHARED_MEM_ADDR) |\n\t\t\t\t   MCP_REG_SCRATCH;\n\n\t\t \n\t\tglobal_section_offsize_addr = public_data_addr +\n\t\t\t\t\t      offsetof(struct mcp_public_data,\n\t\t\t\t\t\t       sections) +\n\t\t\t\t\t      sizeof(offsize_t) * PUBLIC_GLOBAL;\n\t\tglobal_section_offsize = qed_rd(p_hwfn, p_ptt,\n\t\t\t\t\t\tglobal_section_offsize_addr);\n\t\tglobal_section_addr =\n\t\t\tMCP_REG_SCRATCH +\n\t\t\t(global_section_offsize & OFFSIZE_OFFSET_MASK) * 4;\n\n\t\t \n\t\tmfw_ver = qed_rd(p_hwfn, p_ptt,\n\t\t\t\t global_section_addr +\n\t\t\t\t offsetof(struct public_global, mfw_ver));\n\n\t\t \n\t\tif (snprintf(mfw_ver_str, sizeof(mfw_ver_str), \"%d_%d_%d_%d\",\n\t\t\t     (u8)(mfw_ver >> 24), (u8)(mfw_ver >> 16),\n\t\t\t     (u8)(mfw_ver >> 8), (u8)mfw_ver) < 0)\n\t\t\tDP_NOTICE(p_hwfn,\n\t\t\t\t  \"Unexpected debug error: invalid MFW version string\\n\");\n\t}\n\n\treturn qed_dump_str_param(dump_buf, dump, \"mfw-version\", mfw_ver_str);\n}\n\n \nstatic u32 qed_dump_chip_revision_param(struct qed_hwfn *p_hwfn,\n\t\t\t\t\tstruct qed_ptt *p_ptt,\n\t\t\t\t\tu32 *dump_buf, bool dump)\n{\n\tstruct dbg_tools_data *dev_data = &p_hwfn->dbg_info;\n\tchar param_str[3] = \"??\";\n\n\tif (dev_data->hw_type == HW_TYPE_ASIC) {\n\t\tu32 chip_rev, chip_metal;\n\n\t\tchip_rev = qed_rd(p_hwfn, p_ptt, MISCS_REG_CHIP_REV);\n\t\tchip_metal = qed_rd(p_hwfn, p_ptt, MISCS_REG_CHIP_METAL);\n\n\t\tparam_str[0] = 'a' + (u8)chip_rev;\n\t\tparam_str[1] = '0' + (u8)chip_metal;\n\t}\n\n\treturn qed_dump_str_param(dump_buf, dump, \"chip-revision\", param_str);\n}\n\n \nstatic u32 qed_dump_section_hdr(u32 *dump_buf,\n\t\t\t\tbool dump, const char *name, u32 num_params)\n{\n\treturn qed_dump_num_param(dump_buf, dump, name, num_params);\n}\n\n \nstatic u32 qed_dump_common_global_params(struct qed_hwfn *p_hwfn,\n\t\t\t\t\t struct qed_ptt *p_ptt,\n\t\t\t\t\t u32 *dump_buf,\n\t\t\t\t\t bool dump,\n\t\t\t\t\t u8 num_specific_global_params)\n{\n\tstruct dbg_tools_data *dev_data = &p_hwfn->dbg_info;\n\tu32 offset = 0;\n\tu8 num_params;\n\n\t \n\tnum_params = NUM_COMMON_GLOBAL_PARAMS + num_specific_global_params +\n\t\t(dev_data->chip_id == CHIP_BB ? 1 : 0);\n\toffset += qed_dump_section_hdr(dump_buf + offset,\n\t\t\t\t       dump, \"global_params\", num_params);\n\n\t \n\toffset += qed_dump_fw_ver_param(p_hwfn, p_ptt, dump_buf + offset, dump);\n\toffset += qed_dump_mfw_ver_param(p_hwfn,\n\t\t\t\t\t p_ptt, dump_buf + offset, dump);\n\toffset += qed_dump_chip_revision_param(p_hwfn,\n\t\t\t\t\t       p_ptt, dump_buf + offset, dump);\n\toffset += qed_dump_num_param(dump_buf + offset,\n\t\t\t\t     dump, \"tools-version\", TOOLS_VERSION);\n\toffset += qed_dump_str_param(dump_buf + offset,\n\t\t\t\t     dump,\n\t\t\t\t     \"chip\",\n\t\t\t\t     s_chip_defs[dev_data->chip_id].name);\n\toffset += qed_dump_str_param(dump_buf + offset,\n\t\t\t\t     dump,\n\t\t\t\t     \"platform\",\n\t\t\t\t     s_hw_type_defs[dev_data->hw_type].name);\n\toffset += qed_dump_num_param(dump_buf + offset,\n\t\t\t\t     dump, \"pci-func\", p_hwfn->abs_pf_id);\n\toffset += qed_dump_num_param(dump_buf + offset,\n\t\t\t\t     dump, \"epoch\", qed_get_epoch_time());\n\tif (dev_data->chip_id == CHIP_BB)\n\t\toffset += qed_dump_num_param(dump_buf + offset,\n\t\t\t\t\t     dump, \"path\", QED_PATH_ID(p_hwfn));\n\n\treturn offset;\n}\n\n \nstatic u32 qed_dump_last_section(u32 *dump_buf, u32 offset, bool dump)\n{\n\tu32 start_offset = offset;\n\n\t \n\toffset += qed_dump_section_hdr(dump_buf + offset, dump, \"last\", 0);\n\n\t \n\tif (dump)\n\t\t*(dump_buf + offset) = ~crc32(0xffffffff,\n\t\t\t\t\t      (u8 *)dump_buf,\n\t\t\t\t\t      DWORDS_TO_BYTES(offset));\n\n\toffset++;\n\n\treturn offset - start_offset;\n}\n\n \nstatic void qed_update_blocks_reset_state(struct qed_hwfn *p_hwfn,\n\t\t\t\t\t  struct qed_ptt *p_ptt)\n{\n\tstruct dbg_tools_data *dev_data = &p_hwfn->dbg_info;\n\tu32 reg_val[NUM_DBG_RESET_REGS] = { 0 };\n\tu8 rst_reg_id;\n\tu32 blk_id;\n\n\t \n\tfor (rst_reg_id = 0; rst_reg_id < NUM_DBG_RESET_REGS; rst_reg_id++) {\n\t\tconst struct dbg_reset_reg *rst_reg;\n\t\tbool rst_reg_removed;\n\t\tu32 rst_reg_addr;\n\n\t\trst_reg = qed_get_dbg_reset_reg(p_hwfn, rst_reg_id);\n\t\trst_reg_removed = GET_FIELD(rst_reg->data,\n\t\t\t\t\t    DBG_RESET_REG_IS_REMOVED);\n\t\trst_reg_addr = DWORDS_TO_BYTES(GET_FIELD(rst_reg->data,\n\t\t\t\t\t\t\t DBG_RESET_REG_ADDR));\n\n\t\tif (!rst_reg_removed)\n\t\t\treg_val[rst_reg_id] = qed_rd(p_hwfn, p_ptt,\n\t\t\t\t\t\t     rst_reg_addr);\n\t}\n\n\t \n\tfor (blk_id = 0; blk_id < NUM_PHYS_BLOCKS; blk_id++) {\n\t\tconst struct dbg_block_chip *blk;\n\t\tbool has_rst_reg;\n\t\tbool is_removed;\n\n\t\tblk = qed_get_dbg_block_per_chip(p_hwfn, (enum block_id)blk_id);\n\t\tis_removed = GET_FIELD(blk->flags, DBG_BLOCK_CHIP_IS_REMOVED);\n\t\thas_rst_reg = GET_FIELD(blk->flags,\n\t\t\t\t\tDBG_BLOCK_CHIP_HAS_RESET_REG);\n\n\t\tif (!is_removed && has_rst_reg)\n\t\t\tdev_data->block_in_reset[blk_id] =\n\t\t\t    !(reg_val[blk->reset_reg_id] &\n\t\t\t      BIT(blk->reset_reg_bit_offset));\n\t}\n}\n\n \nstatic bool qed_is_mode_match_rec(struct qed_hwfn *p_hwfn,\n\t\t\t\t  u16 *modes_buf_offset, u8 rec_depth)\n{\n\tstruct dbg_tools_data *dev_data = &p_hwfn->dbg_info;\n\tu8 *dbg_array;\n\tbool arg1, arg2;\n\tu8 tree_val;\n\n\tif (rec_depth > MAX_RECURSION_DEPTH) {\n\t\tDP_NOTICE(p_hwfn,\n\t\t\t  \"Unexpected error: is_mode_match_rec exceeded the max recursion depth. This is probably due to a corrupt init/debug buffer.\\n\");\n\t\treturn false;\n\t}\n\n\t \n\tdbg_array = p_hwfn->dbg_arrays[BIN_BUF_DBG_MODE_TREE].ptr;\n\ttree_val = dbg_array[(*modes_buf_offset)++];\n\n\tswitch (tree_val) {\n\tcase INIT_MODE_OP_NOT:\n\t\treturn !qed_is_mode_match_rec(p_hwfn,\n\t\t\t\t\t      modes_buf_offset, rec_depth + 1);\n\tcase INIT_MODE_OP_OR:\n\tcase INIT_MODE_OP_AND:\n\t\targ1 = qed_is_mode_match_rec(p_hwfn,\n\t\t\t\t\t     modes_buf_offset, rec_depth + 1);\n\t\targ2 = qed_is_mode_match_rec(p_hwfn,\n\t\t\t\t\t     modes_buf_offset, rec_depth + 1);\n\t\treturn (tree_val == INIT_MODE_OP_OR) ? (arg1 ||\n\t\t\t\t\t\t\targ2) : (arg1 && arg2);\n\tdefault:\n\t\treturn dev_data->mode_enable[tree_val - MAX_INIT_MODE_OPS] > 0;\n\t}\n}\n\n \nstatic bool qed_is_mode_match(struct qed_hwfn *p_hwfn, u16 *modes_buf_offset)\n{\n\treturn qed_is_mode_match_rec(p_hwfn, modes_buf_offset, 0);\n}\n\n \nstatic void qed_bus_enable_dbg_block(struct qed_hwfn *p_hwfn,\n\t\t\t\t     struct qed_ptt *p_ptt, bool enable)\n{\n\tqed_wr(p_hwfn, p_ptt, DBG_REG_DBG_BLOCK_ON, enable ? 1 : 0);\n}\n\n \nstatic void qed_bus_reset_dbg_block(struct qed_hwfn *p_hwfn,\n\t\t\t\t    struct qed_ptt *p_ptt)\n{\n\tu32 reset_reg_addr, old_reset_reg_val, new_reset_reg_val;\n\tconst struct dbg_reset_reg *reset_reg;\n\tconst struct dbg_block_chip *block;\n\n\tblock = qed_get_dbg_block_per_chip(p_hwfn, BLOCK_DBG);\n\treset_reg = qed_get_dbg_reset_reg(p_hwfn, block->reset_reg_id);\n\treset_reg_addr =\n\t    DWORDS_TO_BYTES(GET_FIELD(reset_reg->data, DBG_RESET_REG_ADDR));\n\n\told_reset_reg_val = qed_rd(p_hwfn, p_ptt, reset_reg_addr);\n\tnew_reset_reg_val =\n\t    old_reset_reg_val & ~BIT(block->reset_reg_bit_offset);\n\n\tqed_wr(p_hwfn, p_ptt, reset_reg_addr, new_reset_reg_val);\n\tqed_wr(p_hwfn, p_ptt, reset_reg_addr, old_reset_reg_val);\n}\n\n \nstatic void qed_bus_enable_clients(struct qed_hwfn *p_hwfn,\n\t\t\t\t   struct qed_ptt *p_ptt, u32 client_mask)\n{\n\tqed_wr(p_hwfn, p_ptt, DBG_REG_CLIENT_ENABLE, client_mask);\n}\n\nstatic void qed_bus_config_dbg_line(struct qed_hwfn *p_hwfn,\n\t\t\t\t    struct qed_ptt *p_ptt,\n\t\t\t\t    enum block_id block_id,\n\t\t\t\t    u8 line_id,\n\t\t\t\t    u8 enable_mask,\n\t\t\t\t    u8 right_shift,\n\t\t\t\t    u8 force_valid_mask, u8 force_frame_mask)\n{\n\tconst struct dbg_block_chip *block =\n\t\tqed_get_dbg_block_per_chip(p_hwfn, block_id);\n\n\tqed_wr(p_hwfn, p_ptt, DWORDS_TO_BYTES(block->dbg_select_reg_addr),\n\t       line_id);\n\tqed_wr(p_hwfn, p_ptt, DWORDS_TO_BYTES(block->dbg_dword_enable_reg_addr),\n\t       enable_mask);\n\tqed_wr(p_hwfn, p_ptt, DWORDS_TO_BYTES(block->dbg_shift_reg_addr),\n\t       right_shift);\n\tqed_wr(p_hwfn, p_ptt, DWORDS_TO_BYTES(block->dbg_force_valid_reg_addr),\n\t       force_valid_mask);\n\tqed_wr(p_hwfn, p_ptt, DWORDS_TO_BYTES(block->dbg_force_frame_reg_addr),\n\t       force_frame_mask);\n}\n\n \nstatic void qed_bus_disable_blocks(struct qed_hwfn *p_hwfn,\n\t\t\t\t   struct qed_ptt *p_ptt)\n{\n\tstruct dbg_tools_data *dev_data = &p_hwfn->dbg_info;\n\tu32 block_id;\n\n\t \n\tfor (block_id = 0; block_id < MAX_BLOCK_ID; block_id++) {\n\t\tconst struct dbg_block_chip *block_per_chip =\n\t\t    qed_get_dbg_block_per_chip(p_hwfn,\n\t\t\t\t\t       (enum block_id)block_id);\n\n\t\tif (GET_FIELD(block_per_chip->flags,\n\t\t\t      DBG_BLOCK_CHIP_IS_REMOVED) ||\n\t\t    dev_data->block_in_reset[block_id])\n\t\t\tcontinue;\n\n\t\t \n\t\tif (GET_FIELD(block_per_chip->flags,\n\t\t\t      DBG_BLOCK_CHIP_HAS_DBG_BUS)) {\n\t\t\tu32 dbg_en_addr =\n\t\t\t\tblock_per_chip->dbg_dword_enable_reg_addr;\n\t\t\tu16 modes_buf_offset =\n\t\t\t    GET_FIELD(block_per_chip->dbg_bus_mode.data,\n\t\t\t\t      DBG_MODE_HDR_MODES_BUF_OFFSET);\n\t\t\tbool eval_mode =\n\t\t\t    GET_FIELD(block_per_chip->dbg_bus_mode.data,\n\t\t\t\t      DBG_MODE_HDR_EVAL_MODE) > 0;\n\n\t\t\tif (!eval_mode ||\n\t\t\t    qed_is_mode_match(p_hwfn, &modes_buf_offset))\n\t\t\t\tqed_wr(p_hwfn, p_ptt,\n\t\t\t\t       DWORDS_TO_BYTES(dbg_en_addr),\n\t\t\t\t       0);\n\t\t}\n\t}\n}\n\n \nstatic bool qed_grc_is_included(struct qed_hwfn *p_hwfn,\n\t\t\t\tenum dbg_grc_params grc_param)\n{\n\treturn qed_grc_get_param(p_hwfn, grc_param) > 0;\n}\n\n \nstatic enum dbg_storms qed_get_id_from_letter(char storm_letter)\n{\n\tu8 storm_id;\n\n\tfor (storm_id = 0; storm_id < MAX_DBG_STORMS; storm_id++)\n\t\tif (s_storm_defs[storm_id].letter == storm_letter)\n\t\t\treturn (enum dbg_storms)storm_id;\n\n\treturn MAX_DBG_STORMS;\n}\n\n \nstatic bool qed_grc_is_storm_included(struct qed_hwfn *p_hwfn,\n\t\t\t\t      enum dbg_storms storm)\n{\n\treturn qed_grc_get_param(p_hwfn, (enum dbg_grc_params)storm) > 0;\n}\n\n \nstatic bool qed_grc_is_mem_included(struct qed_hwfn *p_hwfn,\n\t\t\t\t    enum block_id block_id, u8 mem_group_id)\n{\n\tconst struct dbg_block *block;\n\tu8 i;\n\n\tblock = get_dbg_block(p_hwfn, block_id);\n\n\t \n\tif (block->associated_storm_letter) {\n\t\tenum dbg_storms associated_storm_id =\n\t\t    qed_get_id_from_letter(block->associated_storm_letter);\n\n\t\tif (associated_storm_id == MAX_DBG_STORMS ||\n\t\t    !qed_grc_is_storm_included(p_hwfn, associated_storm_id))\n\t\t\treturn false;\n\t}\n\n\tfor (i = 0; i < NUM_BIG_RAM_TYPES; i++) {\n\t\tstruct big_ram_defs *big_ram = &s_big_ram_defs[i];\n\n\t\tif (mem_group_id == big_ram->mem_group_id ||\n\t\t    mem_group_id == big_ram->ram_mem_group_id)\n\t\t\treturn qed_grc_is_included(p_hwfn, big_ram->grc_param);\n\t}\n\n\tswitch (mem_group_id) {\n\tcase MEM_GROUP_PXP_ILT:\n\tcase MEM_GROUP_PXP_MEM:\n\t\treturn qed_grc_is_included(p_hwfn, DBG_GRC_PARAM_DUMP_PXP);\n\tcase MEM_GROUP_RAM:\n\t\treturn qed_grc_is_included(p_hwfn, DBG_GRC_PARAM_DUMP_RAM);\n\tcase MEM_GROUP_PBUF:\n\t\treturn qed_grc_is_included(p_hwfn, DBG_GRC_PARAM_DUMP_PBUF);\n\tcase MEM_GROUP_CAU_MEM:\n\tcase MEM_GROUP_CAU_SB:\n\tcase MEM_GROUP_CAU_PI:\n\t\treturn qed_grc_is_included(p_hwfn, DBG_GRC_PARAM_DUMP_CAU);\n\tcase MEM_GROUP_CAU_MEM_EXT:\n\t\treturn qed_grc_is_included(p_hwfn, DBG_GRC_PARAM_DUMP_CAU_EXT);\n\tcase MEM_GROUP_QM_MEM:\n\t\treturn qed_grc_is_included(p_hwfn, DBG_GRC_PARAM_DUMP_QM);\n\tcase MEM_GROUP_CFC_MEM:\n\tcase MEM_GROUP_CONN_CFC_MEM:\n\tcase MEM_GROUP_TASK_CFC_MEM:\n\t\treturn qed_grc_is_included(p_hwfn, DBG_GRC_PARAM_DUMP_CFC) ||\n\t\t       qed_grc_is_included(p_hwfn, DBG_GRC_PARAM_DUMP_CM_CTX);\n\tcase MEM_GROUP_DORQ_MEM:\n\t\treturn qed_grc_is_included(p_hwfn, DBG_GRC_PARAM_DUMP_DORQ);\n\tcase MEM_GROUP_IGU_MEM:\n\tcase MEM_GROUP_IGU_MSIX:\n\t\treturn qed_grc_is_included(p_hwfn, DBG_GRC_PARAM_DUMP_IGU);\n\tcase MEM_GROUP_MULD_MEM:\n\t\treturn qed_grc_is_included(p_hwfn, DBG_GRC_PARAM_DUMP_MULD);\n\tcase MEM_GROUP_PRS_MEM:\n\t\treturn qed_grc_is_included(p_hwfn, DBG_GRC_PARAM_DUMP_PRS);\n\tcase MEM_GROUP_DMAE_MEM:\n\t\treturn qed_grc_is_included(p_hwfn, DBG_GRC_PARAM_DUMP_DMAE);\n\tcase MEM_GROUP_TM_MEM:\n\t\treturn qed_grc_is_included(p_hwfn, DBG_GRC_PARAM_DUMP_TM);\n\tcase MEM_GROUP_SDM_MEM:\n\t\treturn qed_grc_is_included(p_hwfn, DBG_GRC_PARAM_DUMP_SDM);\n\tcase MEM_GROUP_TDIF_CTX:\n\tcase MEM_GROUP_RDIF_CTX:\n\t\treturn qed_grc_is_included(p_hwfn, DBG_GRC_PARAM_DUMP_DIF);\n\tcase MEM_GROUP_CM_MEM:\n\t\treturn qed_grc_is_included(p_hwfn, DBG_GRC_PARAM_DUMP_CM);\n\tcase MEM_GROUP_IOR:\n\t\treturn qed_grc_is_included(p_hwfn, DBG_GRC_PARAM_DUMP_IOR);\n\tdefault:\n\t\treturn true;\n\t}\n}\n\n \nstatic void qed_grc_stall_storms(struct qed_hwfn *p_hwfn,\n\t\t\t\t struct qed_ptt *p_ptt, bool stall)\n{\n\tu32 reg_addr;\n\tu8 storm_id;\n\n\tfor (storm_id = 0; storm_id < MAX_DBG_STORMS; storm_id++) {\n\t\tif (!qed_grc_is_storm_included(p_hwfn,\n\t\t\t\t\t       (enum dbg_storms)storm_id))\n\t\t\tcontinue;\n\n\t\treg_addr = s_storm_defs[storm_id].sem_fast_mem_addr +\n\t\t    SEM_FAST_REG_STALL_0;\n\t\tqed_wr(p_hwfn, p_ptt, reg_addr, stall ? 1 : 0);\n\t}\n\n\tmsleep(STALL_DELAY_MS);\n}\n\n \nstatic void qed_grc_unreset_blocks(struct qed_hwfn *p_hwfn,\n\t\t\t\t   struct qed_ptt *p_ptt, bool rbc_only)\n{\n\tstruct dbg_tools_data *dev_data = &p_hwfn->dbg_info;\n\tu8 chip_id = dev_data->chip_id;\n\tu32 i;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(s_rbc_reset_defs); i++)\n\t\tif (s_rbc_reset_defs[i].reset_val[dev_data->chip_id])\n\t\t\tqed_wr(p_hwfn,\n\t\t\t       p_ptt,\n\t\t\t       s_rbc_reset_defs[i].reset_reg_addr +\n\t\t\t       RESET_REG_UNRESET_OFFSET,\n\t\t\t       s_rbc_reset_defs[i].reset_val[chip_id]);\n\n\tif (!rbc_only) {\n\t\tu32 reg_val[NUM_DBG_RESET_REGS] = { 0 };\n\t\tu8 reset_reg_id;\n\t\tu32 block_id;\n\n\t\t \n\t\tfor (block_id = 0; block_id < NUM_PHYS_BLOCKS; block_id++) {\n\t\t\tbool is_removed, has_reset_reg, unreset_before_dump;\n\t\t\tconst struct dbg_block_chip *block;\n\n\t\t\tblock = qed_get_dbg_block_per_chip(p_hwfn,\n\t\t\t\t\t\t\t   (enum block_id)\n\t\t\t\t\t\t\t   block_id);\n\t\t\tis_removed =\n\t\t\t    GET_FIELD(block->flags, DBG_BLOCK_CHIP_IS_REMOVED);\n\t\t\thas_reset_reg =\n\t\t\t    GET_FIELD(block->flags,\n\t\t\t\t      DBG_BLOCK_CHIP_HAS_RESET_REG);\n\t\t\tunreset_before_dump =\n\t\t\t    GET_FIELD(block->flags,\n\t\t\t\t      DBG_BLOCK_CHIP_UNRESET_BEFORE_DUMP);\n\n\t\t\tif (!is_removed && has_reset_reg && unreset_before_dump)\n\t\t\t\treg_val[block->reset_reg_id] |=\n\t\t\t\t    BIT(block->reset_reg_bit_offset);\n\t\t}\n\n\t\t \n\t\tfor (reset_reg_id = 0; reset_reg_id < NUM_DBG_RESET_REGS;\n\t\t     reset_reg_id++) {\n\t\t\tconst struct dbg_reset_reg *reset_reg;\n\t\t\tu32 reset_reg_addr;\n\n\t\t\treset_reg = qed_get_dbg_reset_reg(p_hwfn, reset_reg_id);\n\n\t\t\tif (GET_FIELD\n\t\t\t    (reset_reg->data, DBG_RESET_REG_IS_REMOVED))\n\t\t\t\tcontinue;\n\n\t\t\tif (reg_val[reset_reg_id]) {\n\t\t\t\treset_reg_addr =\n\t\t\t\t    GET_FIELD(reset_reg->data,\n\t\t\t\t\t      DBG_RESET_REG_ADDR);\n\t\t\t\tqed_wr(p_hwfn,\n\t\t\t\t       p_ptt,\n\t\t\t\t       DWORDS_TO_BYTES(reset_reg_addr) +\n\t\t\t\t       RESET_REG_UNRESET_OFFSET,\n\t\t\t\t       reg_val[reset_reg_id]);\n\t\t\t}\n\t\t}\n\t}\n}\n\n \nstatic const struct dbg_attn_block_type_data *\nqed_get_block_attn_data(struct qed_hwfn *p_hwfn,\n\t\t\tenum block_id block_id, enum dbg_attn_type attn_type)\n{\n\tconst struct dbg_attn_block *base_attn_block_arr =\n\t    (const struct dbg_attn_block *)\n\t    p_hwfn->dbg_arrays[BIN_BUF_DBG_ATTN_BLOCKS].ptr;\n\n\treturn &base_attn_block_arr[block_id].per_type_data[attn_type];\n}\n\n \nstatic const struct dbg_attn_reg *\nqed_get_block_attn_regs(struct qed_hwfn *p_hwfn,\n\t\t\tenum block_id block_id, enum dbg_attn_type attn_type,\n\t\t\tu8 *num_attn_regs)\n{\n\tconst struct dbg_attn_block_type_data *block_type_data =\n\t    qed_get_block_attn_data(p_hwfn, block_id, attn_type);\n\n\t*num_attn_regs = block_type_data->num_regs;\n\n\treturn (const struct dbg_attn_reg *)\n\t\tp_hwfn->dbg_arrays[BIN_BUF_DBG_ATTN_REGS].ptr +\n\t\tblock_type_data->regs_offset;\n}\n\n \nstatic void qed_grc_clear_all_prty(struct qed_hwfn *p_hwfn,\n\t\t\t\t   struct qed_ptt *p_ptt)\n{\n\tstruct dbg_tools_data *dev_data = &p_hwfn->dbg_info;\n\tconst struct dbg_attn_reg *attn_reg_arr;\n\tu32 block_id, sts_clr_address;\n\tu8 reg_idx, num_attn_regs;\n\n\tfor (block_id = 0; block_id < NUM_PHYS_BLOCKS; block_id++) {\n\t\tif (dev_data->block_in_reset[block_id])\n\t\t\tcontinue;\n\n\t\tattn_reg_arr = qed_get_block_attn_regs(p_hwfn,\n\t\t\t\t\t\t       (enum block_id)block_id,\n\t\t\t\t\t\t       ATTN_TYPE_PARITY,\n\t\t\t\t\t\t       &num_attn_regs);\n\n\t\tfor (reg_idx = 0; reg_idx < num_attn_regs; reg_idx++) {\n\t\t\tconst struct dbg_attn_reg *reg_data =\n\t\t\t\t&attn_reg_arr[reg_idx];\n\t\t\tu16 modes_buf_offset;\n\t\t\tbool eval_mode;\n\n\t\t\t \n\t\t\teval_mode = GET_FIELD(reg_data->mode.data,\n\t\t\t\t\t      DBG_MODE_HDR_EVAL_MODE) > 0;\n\t\t\tmodes_buf_offset =\n\t\t\t\tGET_FIELD(reg_data->mode.data,\n\t\t\t\t\t  DBG_MODE_HDR_MODES_BUF_OFFSET);\n\n\t\t\tsts_clr_address = reg_data->sts_clr_address;\n\t\t\t \n\t\t\tif (!eval_mode ||\n\t\t\t    qed_is_mode_match(p_hwfn, &modes_buf_offset))\n\t\t\t\tqed_rd(p_hwfn, p_ptt,\n\t\t\t\t       DWORDS_TO_BYTES(sts_clr_address));\n\t\t}\n\t}\n}\n\n \nstatic enum dbg_status qed_find_nvram_image(struct qed_hwfn *p_hwfn,\n\t\t\t\t\t    struct qed_ptt *p_ptt,\n\t\t\t\t\t    u32 image_type,\n\t\t\t\t\t    u32 *nvram_offset_bytes,\n\t\t\t\t\t    u32 *nvram_size_bytes,\n\t\t\t\t\t    bool b_can_sleep)\n{\n\tu32 ret_mcp_resp, ret_mcp_param, ret_txn_size;\n\tstruct mcp_file_att file_att;\n\tint nvm_result;\n\n\t \n\tnvm_result = qed_mcp_nvm_rd_cmd(p_hwfn,\n\t\t\t\t\tp_ptt,\n\t\t\t\t\tDRV_MSG_CODE_NVM_GET_FILE_ATT,\n\t\t\t\t\timage_type,\n\t\t\t\t\t&ret_mcp_resp,\n\t\t\t\t\t&ret_mcp_param,\n\t\t\t\t\t&ret_txn_size,\n\t\t\t\t\t(u32 *)&file_att,\n\t\t\t\t\tb_can_sleep);\n\n\t \n\tif (nvm_result || (ret_mcp_resp & FW_MSG_CODE_MASK) !=\n\t    FW_MSG_CODE_NVM_OK)\n\t\treturn DBG_STATUS_NVRAM_GET_IMAGE_FAILED;\n\n\t \n\t*nvram_offset_bytes = file_att.nvm_start_addr;\n\t*nvram_size_bytes = file_att.len;\n\n\tDP_VERBOSE(p_hwfn,\n\t\t   QED_MSG_DEBUG,\n\t\t   \"find_nvram_image: found NVRAM image of type %d in NVRAM offset %d bytes with size %d bytes\\n\",\n\t\t   image_type, *nvram_offset_bytes, *nvram_size_bytes);\n\n\t \n\tif (*nvram_size_bytes & 0x3)\n\t\treturn DBG_STATUS_NON_ALIGNED_NVRAM_IMAGE;\n\n\treturn DBG_STATUS_OK;\n}\n\n \nstatic enum dbg_status qed_nvram_read(struct qed_hwfn *p_hwfn,\n\t\t\t\t      struct qed_ptt *p_ptt,\n\t\t\t\t      u32 nvram_offset_bytes,\n\t\t\t\t      u32 nvram_size_bytes,\n\t\t\t\t      u32 *ret_buf,\n\t\t\t\t      bool b_can_sleep)\n{\n\tu32 ret_mcp_resp, ret_mcp_param, ret_read_size, bytes_to_copy;\n\ts32 bytes_left = nvram_size_bytes;\n\tu32 read_offset = 0, param = 0;\n\n\tDP_VERBOSE(p_hwfn,\n\t\t   QED_MSG_DEBUG,\n\t\t   \"nvram_read: reading image of size %d bytes from NVRAM\\n\",\n\t\t   nvram_size_bytes);\n\n\tdo {\n\t\tbytes_to_copy =\n\t\t    (bytes_left >\n\t\t     MCP_DRV_NVM_BUF_LEN) ? MCP_DRV_NVM_BUF_LEN : bytes_left;\n\n\t\t \n\t\tSET_MFW_FIELD(param,\n\t\t\t      DRV_MB_PARAM_NVM_OFFSET,\n\t\t\t      nvram_offset_bytes + read_offset);\n\t\tSET_MFW_FIELD(param, DRV_MB_PARAM_NVM_LEN, bytes_to_copy);\n\t\tif (qed_mcp_nvm_rd_cmd(p_hwfn, p_ptt,\n\t\t\t\t       DRV_MSG_CODE_NVM_READ_NVRAM, param,\n\t\t\t\t       &ret_mcp_resp,\n\t\t\t\t       &ret_mcp_param, &ret_read_size,\n\t\t\t\t       (u32 *)((u8 *)ret_buf + read_offset),\n\t\t\t\t       b_can_sleep))\n\t\t\treturn DBG_STATUS_NVRAM_READ_FAILED;\n\n\t\t \n\t\tif ((ret_mcp_resp & FW_MSG_CODE_MASK) != FW_MSG_CODE_NVM_OK)\n\t\t\treturn DBG_STATUS_NVRAM_READ_FAILED;\n\n\t\t \n\t\tread_offset += ret_read_size;\n\t\tbytes_left -= ret_read_size;\n\t} while (bytes_left > 0);\n\n\treturn DBG_STATUS_OK;\n}\n\n \nstatic u32 qed_grc_dump_regs_hdr(u32 *dump_buf,\n\t\t\t\t bool dump,\n\t\t\t\t u32 num_reg_entries,\n\t\t\t\t enum init_split_types split_type,\n\t\t\t\t u8 split_id, const char *reg_type_name)\n{\n\tu8 num_params = 2 +\n\t    (split_type != SPLIT_TYPE_NONE ? 1 : 0) + (reg_type_name ? 1 : 0);\n\tu32 offset = 0;\n\n\toffset += qed_dump_section_hdr(dump_buf + offset,\n\t\t\t\t       dump, \"grc_regs\", num_params);\n\toffset += qed_dump_num_param(dump_buf + offset,\n\t\t\t\t     dump, \"count\", num_reg_entries);\n\toffset += qed_dump_str_param(dump_buf + offset,\n\t\t\t\t     dump, \"split\",\n\t\t\t\t     s_split_type_defs[split_type].name);\n\tif (split_type != SPLIT_TYPE_NONE)\n\t\toffset += qed_dump_num_param(dump_buf + offset,\n\t\t\t\t\t     dump, \"id\", split_id);\n\tif (reg_type_name)\n\t\toffset += qed_dump_str_param(dump_buf + offset,\n\t\t\t\t\t     dump, \"type\", reg_type_name);\n\n\treturn offset;\n}\n\n \nvoid qed_read_regs(struct qed_hwfn *p_hwfn,\n\t\t   struct qed_ptt *p_ptt, u32 *buf, u32 addr, u32 len)\n{\n\tu32 i;\n\n\tfor (i = 0; i < len; i++)\n\t\tbuf[i] = qed_rd(p_hwfn, p_ptt, DWORDS_TO_BYTES(addr + i));\n}\n\n \nstatic u32 qed_grc_dump_addr_range(struct qed_hwfn *p_hwfn,\n\t\t\t\t   struct qed_ptt *p_ptt,\n\t\t\t\t   u32 *dump_buf,\n\t\t\t\t   bool dump, u32 addr, u32 len, bool wide_bus,\n\t\t\t\t   enum init_split_types split_type,\n\t\t\t\t   u8 split_id)\n{\n\tstruct dbg_tools_data *dev_data = &p_hwfn->dbg_info;\n\tu8 port_id = 0, pf_id = 0, vf_id = 0;\n\tbool read_using_dmae = false;\n\tu32 thresh;\n\tu16 fid;\n\n\tif (!dump)\n\t\treturn len;\n\n\tswitch (split_type) {\n\tcase SPLIT_TYPE_PORT:\n\t\tport_id = split_id;\n\t\tbreak;\n\tcase SPLIT_TYPE_PF:\n\t\tpf_id = split_id;\n\t\tbreak;\n\tcase SPLIT_TYPE_PORT_PF:\n\t\tport_id = split_id / dev_data->num_pfs_per_port;\n\t\tpf_id = port_id + dev_data->num_ports *\n\t\t    (split_id % dev_data->num_pfs_per_port);\n\t\tbreak;\n\tcase SPLIT_TYPE_VF:\n\t\tvf_id = split_id;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tif (dev_data->use_dmae && split_type != SPLIT_TYPE_VF &&\n\t    (len >= s_hw_type_defs[dev_data->hw_type].dmae_thresh ||\n\t     (PROTECT_WIDE_BUS && wide_bus))) {\n\t\tstruct qed_dmae_params dmae_params;\n\n\t\t \n\t\tmemset(&dmae_params, 0, sizeof(dmae_params));\n\t\tSET_FIELD(dmae_params.flags, QED_DMAE_PARAMS_COMPLETION_DST, 1);\n\t\tswitch (split_type) {\n\t\tcase SPLIT_TYPE_PORT:\n\t\t\tSET_FIELD(dmae_params.flags, QED_DMAE_PARAMS_PORT_VALID,\n\t\t\t\t  1);\n\t\t\tdmae_params.port_id = port_id;\n\t\t\tbreak;\n\t\tcase SPLIT_TYPE_PF:\n\t\t\tSET_FIELD(dmae_params.flags,\n\t\t\t\t  QED_DMAE_PARAMS_SRC_PF_VALID, 1);\n\t\t\tdmae_params.src_pfid = pf_id;\n\t\t\tbreak;\n\t\tcase SPLIT_TYPE_PORT_PF:\n\t\t\tSET_FIELD(dmae_params.flags, QED_DMAE_PARAMS_PORT_VALID,\n\t\t\t\t  1);\n\t\t\tSET_FIELD(dmae_params.flags,\n\t\t\t\t  QED_DMAE_PARAMS_SRC_PF_VALID, 1);\n\t\t\tdmae_params.port_id = port_id;\n\t\t\tdmae_params.src_pfid = pf_id;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tread_using_dmae = !qed_dmae_grc2host(p_hwfn,\n\t\t\t\t\t\t     p_ptt,\n\t\t\t\t\t\t     DWORDS_TO_BYTES(addr),\n\t\t\t\t\t\t     (u64)(uintptr_t)(dump_buf),\n\t\t\t\t\t\t     len, &dmae_params);\n\t\tif (!read_using_dmae) {\n\t\t\tdev_data->use_dmae = 0;\n\t\t\tDP_VERBOSE(p_hwfn,\n\t\t\t\t   QED_MSG_DEBUG,\n\t\t\t\t   \"Failed reading from chip using DMAE, using GRC instead\\n\");\n\t\t}\n\t}\n\n\tif (read_using_dmae)\n\t\tgoto print_log;\n\n\t \n\n\t \n\tif (split_type != dev_data->pretend.split_type ||\n\t    split_id != dev_data->pretend.split_id) {\n\t\tswitch (split_type) {\n\t\tcase SPLIT_TYPE_PORT:\n\t\t\tqed_port_pretend(p_hwfn, p_ptt, port_id);\n\t\t\tbreak;\n\t\tcase SPLIT_TYPE_PF:\n\t\t\tfid = FIELD_VALUE(PXP_PRETEND_CONCRETE_FID_PFID,\n\t\t\t\t\t  pf_id);\n\t\t\tqed_fid_pretend(p_hwfn, p_ptt, fid);\n\t\t\tbreak;\n\t\tcase SPLIT_TYPE_PORT_PF:\n\t\t\tfid = FIELD_VALUE(PXP_PRETEND_CONCRETE_FID_PFID,\n\t\t\t\t\t  pf_id);\n\t\t\tqed_port_fid_pretend(p_hwfn, p_ptt, port_id, fid);\n\t\t\tbreak;\n\t\tcase SPLIT_TYPE_VF:\n\t\t\tfid = FIELD_VALUE(PXP_PRETEND_CONCRETE_FID_VFVALID, 1)\n\t\t\t      | FIELD_VALUE(PXP_PRETEND_CONCRETE_FID_VFID,\n\t\t\t\t\t  vf_id);\n\t\t\tqed_fid_pretend(p_hwfn, p_ptt, fid);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tdev_data->pretend.split_type = (u8)split_type;\n\t\tdev_data->pretend.split_id = split_id;\n\t}\n\n\t \n\tqed_read_regs(p_hwfn, p_ptt, dump_buf, addr, len);\n\nprint_log:\n\t \n\tdev_data->num_regs_read += len;\n\tthresh = s_hw_type_defs[dev_data->hw_type].log_thresh;\n\tif ((dev_data->num_regs_read / thresh) >\n\t    ((dev_data->num_regs_read - len) / thresh))\n\t\tDP_VERBOSE(p_hwfn,\n\t\t\t   QED_MSG_DEBUG,\n\t\t\t   \"Dumped %d registers...\\n\", dev_data->num_regs_read);\n\n\treturn len;\n}\n\n \nstatic u32 qed_grc_dump_reg_entry_hdr(u32 *dump_buf,\n\t\t\t\t      bool dump, u32 addr, u32 len)\n{\n\tif (dump)\n\t\t*dump_buf = addr | (len << REG_DUMP_LEN_SHIFT);\n\n\treturn 1;\n}\n\n \nstatic u32 qed_grc_dump_reg_entry(struct qed_hwfn *p_hwfn,\n\t\t\t\t  struct qed_ptt *p_ptt,\n\t\t\t\t  u32 *dump_buf,\n\t\t\t\t  bool dump, u32 addr, u32 len, bool wide_bus,\n\t\t\t\t  enum init_split_types split_type, u8 split_id)\n{\n\tu32 offset = 0;\n\n\toffset += qed_grc_dump_reg_entry_hdr(dump_buf, dump, addr, len);\n\toffset += qed_grc_dump_addr_range(p_hwfn,\n\t\t\t\t\t  p_ptt,\n\t\t\t\t\t  dump_buf + offset,\n\t\t\t\t\t  dump, addr, len, wide_bus,\n\t\t\t\t\t  split_type, split_id);\n\n\treturn offset;\n}\n\n \nstatic u32 qed_grc_dump_reg_entry_skip(struct qed_hwfn *p_hwfn,\n\t\t\t\t       struct qed_ptt *p_ptt,\n\t\t\t\t       u32 *dump_buf,\n\t\t\t\t       bool dump,\n\t\t\t\t       u32 addr,\n\t\t\t\t       u32 total_len,\n\t\t\t\t       u32 read_len, u32 skip_len)\n{\n\tu32 offset = 0, reg_offset = 0;\n\n\toffset += qed_grc_dump_reg_entry_hdr(dump_buf, dump, addr, total_len);\n\n\tif (!dump)\n\t\treturn offset + total_len;\n\n\twhile (reg_offset < total_len) {\n\t\tu32 curr_len = min_t(u32, read_len, total_len - reg_offset);\n\n\t\toffset += qed_grc_dump_addr_range(p_hwfn,\n\t\t\t\t\t\t  p_ptt,\n\t\t\t\t\t\t  dump_buf + offset,\n\t\t\t\t\t\t  dump,  addr, curr_len, false,\n\t\t\t\t\t\t  SPLIT_TYPE_NONE, 0);\n\t\treg_offset += curr_len;\n\t\taddr += curr_len;\n\n\t\tif (reg_offset < total_len) {\n\t\t\tcurr_len = min_t(u32, skip_len, total_len - skip_len);\n\t\t\tmemset(dump_buf + offset, 0, DWORDS_TO_BYTES(curr_len));\n\t\t\toffset += curr_len;\n\t\t\treg_offset += curr_len;\n\t\t\taddr += curr_len;\n\t\t}\n\t}\n\n\treturn offset;\n}\n\n \nstatic u32 qed_grc_dump_regs_entries(struct qed_hwfn *p_hwfn,\n\t\t\t\t     struct qed_ptt *p_ptt,\n\t\t\t\t     struct virt_mem_desc input_regs_arr,\n\t\t\t\t     u32 *dump_buf,\n\t\t\t\t     bool dump,\n\t\t\t\t     enum init_split_types split_type,\n\t\t\t\t     u8 split_id,\n\t\t\t\t     bool block_enable[MAX_BLOCK_ID],\n\t\t\t\t     u32 *num_dumped_reg_entries)\n{\n\tu32 i, offset = 0, input_offset = 0;\n\tbool mode_match = true;\n\n\t*num_dumped_reg_entries = 0;\n\n\twhile (input_offset < BYTES_TO_DWORDS(input_regs_arr.size)) {\n\t\tconst struct dbg_dump_cond_hdr *cond_hdr =\n\t\t    (const struct dbg_dump_cond_hdr *)\n\t\t    input_regs_arr.ptr + input_offset++;\n\t\tu16 modes_buf_offset;\n\t\tbool eval_mode;\n\n\t\t \n\t\teval_mode = GET_FIELD(cond_hdr->mode.data,\n\t\t\t\t      DBG_MODE_HDR_EVAL_MODE) > 0;\n\t\tif (eval_mode) {\n\t\t\tmodes_buf_offset =\n\t\t\t\tGET_FIELD(cond_hdr->mode.data,\n\t\t\t\t\t  DBG_MODE_HDR_MODES_BUF_OFFSET);\n\t\t\tmode_match = qed_is_mode_match(p_hwfn,\n\t\t\t\t\t\t       &modes_buf_offset);\n\t\t}\n\n\t\tif (!mode_match || !block_enable[cond_hdr->block_id]) {\n\t\t\tinput_offset += cond_hdr->data_size;\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (i = 0; i < cond_hdr->data_size; i++, input_offset++) {\n\t\t\tconst struct dbg_dump_reg *reg =\n\t\t\t    (const struct dbg_dump_reg *)\n\t\t\t    input_regs_arr.ptr + input_offset;\n\t\t\tu32 addr, len;\n\t\t\tbool wide_bus;\n\n\t\t\taddr = GET_FIELD(reg->data, DBG_DUMP_REG_ADDRESS);\n\t\t\tlen = GET_FIELD(reg->data, DBG_DUMP_REG_LENGTH);\n\t\t\twide_bus = GET_FIELD(reg->data, DBG_DUMP_REG_WIDE_BUS);\n\t\t\toffset += qed_grc_dump_reg_entry(p_hwfn,\n\t\t\t\t\t\t\t p_ptt,\n\t\t\t\t\t\t\t dump_buf + offset,\n\t\t\t\t\t\t\t dump,\n\t\t\t\t\t\t\t addr,\n\t\t\t\t\t\t\t len,\n\t\t\t\t\t\t\t wide_bus,\n\t\t\t\t\t\t\t split_type, split_id);\n\t\t\t(*num_dumped_reg_entries)++;\n\t\t}\n\t}\n\n\treturn offset;\n}\n\n \nstatic u32 qed_grc_dump_split_data(struct qed_hwfn *p_hwfn,\n\t\t\t\t   struct qed_ptt *p_ptt,\n\t\t\t\t   struct virt_mem_desc input_regs_arr,\n\t\t\t\t   u32 *dump_buf,\n\t\t\t\t   bool dump,\n\t\t\t\t   bool block_enable[MAX_BLOCK_ID],\n\t\t\t\t   enum init_split_types split_type,\n\t\t\t\t   u8 split_id, const char *reg_type_name)\n{\n\tstruct dbg_tools_data *dev_data = &p_hwfn->dbg_info;\n\tenum init_split_types hdr_split_type = split_type;\n\tu32 num_dumped_reg_entries, offset;\n\tu8 hdr_split_id = split_id;\n\n\t \n\tif (split_type == SPLIT_TYPE_PORT_PF) {\n\t\thdr_split_type = SPLIT_TYPE_PORT;\n\t\thdr_split_id = split_id / dev_data->num_pfs_per_port;\n\t}\n\n\t \n\toffset = qed_grc_dump_regs_hdr(dump_buf,\n\t\t\t\t       false,\n\t\t\t\t       0,\n\t\t\t\t       hdr_split_type,\n\t\t\t\t       hdr_split_id, reg_type_name);\n\n\t \n\toffset += qed_grc_dump_regs_entries(p_hwfn,\n\t\t\t\t\t    p_ptt,\n\t\t\t\t\t    input_regs_arr,\n\t\t\t\t\t    dump_buf + offset,\n\t\t\t\t\t    dump,\n\t\t\t\t\t    split_type,\n\t\t\t\t\t    split_id,\n\t\t\t\t\t    block_enable,\n\t\t\t\t\t    &num_dumped_reg_entries);\n\n\t \n\tif (dump && num_dumped_reg_entries > 0)\n\t\tqed_grc_dump_regs_hdr(dump_buf,\n\t\t\t\t      dump,\n\t\t\t\t      num_dumped_reg_entries,\n\t\t\t\t      hdr_split_type,\n\t\t\t\t      hdr_split_id, reg_type_name);\n\n\treturn num_dumped_reg_entries > 0 ? offset : 0;\n}\n\n \nstatic u32 qed_grc_dump_registers(struct qed_hwfn *p_hwfn,\n\t\t\t\t  struct qed_ptt *p_ptt,\n\t\t\t\t  u32 *dump_buf,\n\t\t\t\t  bool dump,\n\t\t\t\t  bool block_enable[MAX_BLOCK_ID],\n\t\t\t\t  const char *reg_type_name)\n{\n\tstruct virt_mem_desc *dbg_buf =\n\t    &p_hwfn->dbg_arrays[BIN_BUF_DBG_DUMP_REG];\n\tstruct dbg_tools_data *dev_data = &p_hwfn->dbg_info;\n\tu32 offset = 0, input_offset = 0;\n\n\twhile (input_offset < BYTES_TO_DWORDS(dbg_buf->size)) {\n\t\tconst struct dbg_dump_split_hdr *split_hdr;\n\t\tstruct virt_mem_desc curr_input_regs_arr;\n\t\tenum init_split_types split_type;\n\t\tu16 split_count = 0;\n\t\tu32 split_data_size;\n\t\tu8 split_id;\n\n\t\tsplit_hdr =\n\t\t    (const struct dbg_dump_split_hdr *)\n\t\t    dbg_buf->ptr + input_offset++;\n\t\tsplit_type =\n\t\t    GET_FIELD(split_hdr->hdr,\n\t\t\t      DBG_DUMP_SPLIT_HDR_SPLIT_TYPE_ID);\n\t\tsplit_data_size = GET_FIELD(split_hdr->hdr,\n\t\t\t\t\t    DBG_DUMP_SPLIT_HDR_DATA_SIZE);\n\t\tcurr_input_regs_arr.ptr =\n\t\t    (u32 *)p_hwfn->dbg_arrays[BIN_BUF_DBG_DUMP_REG].ptr +\n\t\t    input_offset;\n\t\tcurr_input_regs_arr.size = DWORDS_TO_BYTES(split_data_size);\n\n\t\tswitch (split_type) {\n\t\tcase SPLIT_TYPE_NONE:\n\t\t\tsplit_count = 1;\n\t\t\tbreak;\n\t\tcase SPLIT_TYPE_PORT:\n\t\t\tsplit_count = dev_data->num_ports;\n\t\t\tbreak;\n\t\tcase SPLIT_TYPE_PF:\n\t\tcase SPLIT_TYPE_PORT_PF:\n\t\t\tsplit_count = dev_data->num_ports *\n\t\t\t    dev_data->num_pfs_per_port;\n\t\t\tbreak;\n\t\tcase SPLIT_TYPE_VF:\n\t\t\tsplit_count = dev_data->num_vfs;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\n\t\tfor (split_id = 0; split_id < split_count; split_id++)\n\t\t\toffset += qed_grc_dump_split_data(p_hwfn, p_ptt,\n\t\t\t\t\t\t\t  curr_input_regs_arr,\n\t\t\t\t\t\t\t  dump_buf + offset,\n\t\t\t\t\t\t\t  dump, block_enable,\n\t\t\t\t\t\t\t  split_type,\n\t\t\t\t\t\t\t  split_id,\n\t\t\t\t\t\t\t  reg_type_name);\n\n\t\tinput_offset += split_data_size;\n\t}\n\n\t \n\tif (dump) {\n\t\tqed_fid_pretend(p_hwfn, p_ptt,\n\t\t\t\tFIELD_VALUE(PXP_PRETEND_CONCRETE_FID_PFID,\n\t\t\t\t\t    p_hwfn->rel_pf_id));\n\t\tdev_data->pretend.split_type = SPLIT_TYPE_NONE;\n\t\tdev_data->pretend.split_id = 0;\n\t}\n\n\treturn offset;\n}\n\n \nstatic u32 qed_grc_dump_reset_regs(struct qed_hwfn *p_hwfn,\n\t\t\t\t   struct qed_ptt *p_ptt,\n\t\t\t\t   u32 *dump_buf, bool dump)\n{\n\tu32 offset = 0, num_regs = 0;\n\tu8 reset_reg_id;\n\n\t \n\toffset += qed_grc_dump_regs_hdr(dump_buf,\n\t\t\t\t\tfalse,\n\t\t\t\t\t0, SPLIT_TYPE_NONE, 0, \"RESET_REGS\");\n\n\t \n\tfor (reset_reg_id = 0; reset_reg_id < NUM_DBG_RESET_REGS;\n\t     reset_reg_id++) {\n\t\tconst struct dbg_reset_reg *reset_reg;\n\t\tu32 reset_reg_addr;\n\n\t\treset_reg = qed_get_dbg_reset_reg(p_hwfn, reset_reg_id);\n\n\t\tif (GET_FIELD(reset_reg->data, DBG_RESET_REG_IS_REMOVED))\n\t\t\tcontinue;\n\n\t\treset_reg_addr = GET_FIELD(reset_reg->data, DBG_RESET_REG_ADDR);\n\t\toffset += qed_grc_dump_reg_entry(p_hwfn,\n\t\t\t\t\t\t p_ptt,\n\t\t\t\t\t\t dump_buf + offset,\n\t\t\t\t\t\t dump,\n\t\t\t\t\t\t reset_reg_addr,\n\t\t\t\t\t\t 1, false, SPLIT_TYPE_NONE, 0);\n\t\tnum_regs++;\n\t}\n\n\t \n\tif (dump)\n\t\tqed_grc_dump_regs_hdr(dump_buf,\n\t\t\t\t      true, num_regs, SPLIT_TYPE_NONE,\n\t\t\t\t      0, \"RESET_REGS\");\n\n\treturn offset;\n}\n\n \nstatic u32 qed_grc_dump_modified_regs(struct qed_hwfn *p_hwfn,\n\t\t\t\t      struct qed_ptt *p_ptt,\n\t\t\t\t      u32 *dump_buf, bool dump)\n{\n\tstruct dbg_tools_data *dev_data = &p_hwfn->dbg_info;\n\tu32 block_id, offset = 0, stall_regs_offset;\n\tconst struct dbg_attn_reg *attn_reg_arr;\n\tu8 storm_id, reg_idx, num_attn_regs;\n\tu32 num_reg_entries = 0;\n\n\t \n\toffset += qed_grc_dump_regs_hdr(dump_buf,\n\t\t\t\t\tfalse,\n\t\t\t\t\t0, SPLIT_TYPE_NONE, 0, \"ATTN_REGS\");\n\n\t \n\tfor (block_id = 0; block_id < NUM_PHYS_BLOCKS; block_id++) {\n\t\tif (dev_data->block_in_reset[block_id] && dump)\n\t\t\tcontinue;\n\n\t\tattn_reg_arr = qed_get_block_attn_regs(p_hwfn,\n\t\t\t\t\t\t       (enum block_id)block_id,\n\t\t\t\t\t\t       ATTN_TYPE_PARITY,\n\t\t\t\t\t\t       &num_attn_regs);\n\n\t\tfor (reg_idx = 0; reg_idx < num_attn_regs; reg_idx++) {\n\t\t\tconst struct dbg_attn_reg *reg_data =\n\t\t\t\t&attn_reg_arr[reg_idx];\n\t\t\tu16 modes_buf_offset;\n\t\t\tbool eval_mode;\n\t\t\tu32 addr;\n\n\t\t\t \n\t\t\teval_mode = GET_FIELD(reg_data->mode.data,\n\t\t\t\t\t      DBG_MODE_HDR_EVAL_MODE) > 0;\n\t\t\tmodes_buf_offset =\n\t\t\t\tGET_FIELD(reg_data->mode.data,\n\t\t\t\t\t  DBG_MODE_HDR_MODES_BUF_OFFSET);\n\t\t\tif (eval_mode &&\n\t\t\t    !qed_is_mode_match(p_hwfn, &modes_buf_offset))\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\taddr = reg_data->mask_address;\n\t\t\toffset += qed_grc_dump_reg_entry(p_hwfn,\n\t\t\t\t\t\t\t p_ptt,\n\t\t\t\t\t\t\t dump_buf + offset,\n\t\t\t\t\t\t\t dump,\n\t\t\t\t\t\t\t addr,\n\t\t\t\t\t\t\t 1, false,\n\t\t\t\t\t\t\t SPLIT_TYPE_NONE, 0);\n\t\t\taddr = GET_FIELD(reg_data->data,\n\t\t\t\t\t DBG_ATTN_REG_STS_ADDRESS);\n\t\t\toffset += qed_grc_dump_reg_entry(p_hwfn,\n\t\t\t\t\t\t\t p_ptt,\n\t\t\t\t\t\t\t dump_buf + offset,\n\t\t\t\t\t\t\t dump,\n\t\t\t\t\t\t\t addr,\n\t\t\t\t\t\t\t 1, false,\n\t\t\t\t\t\t\t SPLIT_TYPE_NONE, 0);\n\t\t\tnum_reg_entries += 2;\n\t\t}\n\t}\n\n\t \n\tif (dump)\n\t\tqed_grc_dump_regs_hdr(dump_buf,\n\t\t\t\t      true,\n\t\t\t\t      num_reg_entries,\n\t\t\t\t      SPLIT_TYPE_NONE, 0, \"ATTN_REGS\");\n\n\t \n\tstall_regs_offset = offset;\n\toffset += qed_grc_dump_regs_hdr(dump_buf,\n\t\t\t\t\tfalse, 0, SPLIT_TYPE_NONE, 0, \"REGS\");\n\n\t \n\tfor (storm_id = 0, num_reg_entries = 0; storm_id < MAX_DBG_STORMS;\n\t     storm_id++) {\n\t\tstruct storm_defs *storm = &s_storm_defs[storm_id];\n\t\tu32 addr;\n\n\t\tif (dev_data->block_in_reset[storm->sem_block_id] && dump)\n\t\t\tcontinue;\n\n\t\taddr =\n\t\t    BYTES_TO_DWORDS(storm->sem_fast_mem_addr +\n\t\t\t\t    SEM_FAST_REG_STALLED);\n\t\toffset += qed_grc_dump_reg_entry(p_hwfn,\n\t\t\t\t\t\t p_ptt,\n\t\t\t\t\t\t dump_buf + offset,\n\t\t\t\t\t\t dump,\n\t\t\t\t\t\t addr,\n\t\t\t\t\t\t 1,\n\t\t\t\t\t\t false, SPLIT_TYPE_NONE, 0);\n\t\tnum_reg_entries++;\n\t}\n\n\t \n\tif (dump)\n\t\tqed_grc_dump_regs_hdr(dump_buf + stall_regs_offset,\n\t\t\t\t      true,\n\t\t\t\t      num_reg_entries,\n\t\t\t\t      SPLIT_TYPE_NONE, 0, \"REGS\");\n\n\treturn offset;\n}\n\n \nstatic u32 qed_grc_dump_special_regs(struct qed_hwfn *p_hwfn,\n\t\t\t\t     struct qed_ptt *p_ptt,\n\t\t\t\t     u32 *dump_buf, bool dump)\n{\n\tu32 offset = 0, addr;\n\n\toffset += qed_grc_dump_regs_hdr(dump_buf,\n\t\t\t\t\tdump, 2, SPLIT_TYPE_NONE, 0, \"REGS\");\n\n\t \n\taddr = BYTES_TO_DWORDS(RDIF_REG_DEBUG_ERROR_INFO);\n\toffset += qed_grc_dump_reg_entry_skip(p_hwfn,\n\t\t\t\t\t      p_ptt,\n\t\t\t\t\t      dump_buf + offset,\n\t\t\t\t\t      dump,\n\t\t\t\t\t      addr,\n\t\t\t\t\t      RDIF_REG_DEBUG_ERROR_INFO_SIZE,\n\t\t\t\t\t      7,\n\t\t\t\t\t      1);\n\taddr = BYTES_TO_DWORDS(TDIF_REG_DEBUG_ERROR_INFO);\n\toffset +=\n\t    qed_grc_dump_reg_entry_skip(p_hwfn,\n\t\t\t\t\tp_ptt,\n\t\t\t\t\tdump_buf + offset,\n\t\t\t\t\tdump,\n\t\t\t\t\taddr,\n\t\t\t\t\tTDIF_REG_DEBUG_ERROR_INFO_SIZE,\n\t\t\t\t\t7,\n\t\t\t\t\t1);\n\n\treturn offset;\n}\n\n \nstatic u32 qed_grc_dump_mem_hdr(struct qed_hwfn *p_hwfn,\n\t\t\t\tu32 *dump_buf,\n\t\t\t\tbool dump,\n\t\t\t\tconst char *name,\n\t\t\t\tu32 addr,\n\t\t\t\tu32 len,\n\t\t\t\tu32 bit_width,\n\t\t\t\tbool packed,\n\t\t\t\tconst char *mem_group, char storm_letter)\n{\n\tu8 num_params = 3;\n\tu32 offset = 0;\n\tchar buf[64];\n\n\tif (!len)\n\t\tDP_NOTICE(p_hwfn,\n\t\t\t  \"Unexpected GRC Dump error: dumped memory size must be non-zero\\n\");\n\n\tif (bit_width)\n\t\tnum_params++;\n\tif (packed)\n\t\tnum_params++;\n\n\t \n\toffset += qed_dump_section_hdr(dump_buf + offset,\n\t\t\t\t       dump, \"grc_mem\", num_params);\n\n\tif (name) {\n\t\t \n\t\tif (storm_letter) {\n\t\t\tstrcpy(buf, \"?STORM_\");\n\t\t\tbuf[0] = storm_letter;\n\t\t\tstrcpy(buf + strlen(buf), name);\n\t\t} else {\n\t\t\tstrcpy(buf, name);\n\t\t}\n\n\t\toffset += qed_dump_str_param(dump_buf + offset,\n\t\t\t\t\t     dump, \"name\", buf);\n\t} else {\n\t\t \n\t\tu32 addr_in_bytes = DWORDS_TO_BYTES(addr);\n\n\t\toffset += qed_dump_num_param(dump_buf + offset,\n\t\t\t\t\t     dump, \"addr\", addr_in_bytes);\n\t}\n\n\t \n\toffset += qed_dump_num_param(dump_buf + offset, dump, \"len\", len);\n\n\t \n\tif (bit_width)\n\t\toffset += qed_dump_num_param(dump_buf + offset,\n\t\t\t\t\t     dump, \"width\", bit_width);\n\n\t \n\tif (packed)\n\t\toffset += qed_dump_num_param(dump_buf + offset,\n\t\t\t\t\t     dump, \"packed\", 1);\n\n\t \n\tif (storm_letter) {\n\t\tstrcpy(buf, \"?STORM_\");\n\t\tbuf[0] = storm_letter;\n\t\tstrcpy(buf + strlen(buf), mem_group);\n\t} else {\n\t\tstrcpy(buf, mem_group);\n\t}\n\n\toffset += qed_dump_str_param(dump_buf + offset, dump, \"type\", buf);\n\n\treturn offset;\n}\n\n \nstatic u32 qed_grc_dump_mem(struct qed_hwfn *p_hwfn,\n\t\t\t    struct qed_ptt *p_ptt,\n\t\t\t    u32 *dump_buf,\n\t\t\t    bool dump,\n\t\t\t    const char *name,\n\t\t\t    u32 addr,\n\t\t\t    u32 len,\n\t\t\t    bool wide_bus,\n\t\t\t    u32 bit_width,\n\t\t\t    bool packed,\n\t\t\t    const char *mem_group, char storm_letter)\n{\n\tu32 offset = 0;\n\n\toffset += qed_grc_dump_mem_hdr(p_hwfn,\n\t\t\t\t       dump_buf + offset,\n\t\t\t\t       dump,\n\t\t\t\t       name,\n\t\t\t\t       addr,\n\t\t\t\t       len,\n\t\t\t\t       bit_width,\n\t\t\t\t       packed, mem_group, storm_letter);\n\toffset += qed_grc_dump_addr_range(p_hwfn,\n\t\t\t\t\t  p_ptt,\n\t\t\t\t\t  dump_buf + offset,\n\t\t\t\t\t  dump, addr, len, wide_bus,\n\t\t\t\t\t  SPLIT_TYPE_NONE, 0);\n\n\treturn offset;\n}\n\n \nstatic u32 qed_grc_dump_mem_entries(struct qed_hwfn *p_hwfn,\n\t\t\t\t    struct qed_ptt *p_ptt,\n\t\t\t\t    struct virt_mem_desc input_mems_arr,\n\t\t\t\t    u32 *dump_buf, bool dump)\n{\n\tu32 i, offset = 0, input_offset = 0;\n\tbool mode_match = true;\n\n\twhile (input_offset < BYTES_TO_DWORDS(input_mems_arr.size)) {\n\t\tconst struct dbg_dump_cond_hdr *cond_hdr;\n\t\tu16 modes_buf_offset;\n\t\tu32 num_entries;\n\t\tbool eval_mode;\n\n\t\tcond_hdr =\n\t\t    (const struct dbg_dump_cond_hdr *)input_mems_arr.ptr +\n\t\t    input_offset++;\n\t\tnum_entries = cond_hdr->data_size / MEM_DUMP_ENTRY_SIZE_DWORDS;\n\n\t\t \n\t\teval_mode = GET_FIELD(cond_hdr->mode.data,\n\t\t\t\t      DBG_MODE_HDR_EVAL_MODE) > 0;\n\t\tif (eval_mode) {\n\t\t\tmodes_buf_offset =\n\t\t\t\tGET_FIELD(cond_hdr->mode.data,\n\t\t\t\t\t  DBG_MODE_HDR_MODES_BUF_OFFSET);\n\t\t\tmode_match = qed_is_mode_match(p_hwfn,\n\t\t\t\t\t\t       &modes_buf_offset);\n\t\t}\n\n\t\tif (!mode_match) {\n\t\t\tinput_offset += cond_hdr->data_size;\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (i = 0; i < num_entries;\n\t\t     i++, input_offset += MEM_DUMP_ENTRY_SIZE_DWORDS) {\n\t\t\tconst struct dbg_dump_mem *mem =\n\t\t\t    (const struct dbg_dump_mem *)((u32 *)\n\t\t\t\t\t\t\t  input_mems_arr.ptr\n\t\t\t\t\t\t\t  + input_offset);\n\t\t\tconst struct dbg_block *block;\n\t\t\tchar storm_letter = 0;\n\t\t\tu32 mem_addr, mem_len;\n\t\t\tbool mem_wide_bus;\n\t\t\tu8 mem_group_id;\n\n\t\t\tmem_group_id = GET_FIELD(mem->dword0,\n\t\t\t\t\t\t DBG_DUMP_MEM_MEM_GROUP_ID);\n\t\t\tif (mem_group_id >= MEM_GROUPS_NUM) {\n\t\t\t\tDP_NOTICE(p_hwfn, \"Invalid mem_group_id\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tif (!qed_grc_is_mem_included(p_hwfn,\n\t\t\t\t\t\t     (enum block_id)\n\t\t\t\t\t\t     cond_hdr->block_id,\n\t\t\t\t\t\t     mem_group_id))\n\t\t\t\tcontinue;\n\n\t\t\tmem_addr = GET_FIELD(mem->dword0, DBG_DUMP_MEM_ADDRESS);\n\t\t\tmem_len = GET_FIELD(mem->dword1, DBG_DUMP_MEM_LENGTH);\n\t\t\tmem_wide_bus = GET_FIELD(mem->dword1,\n\t\t\t\t\t\t DBG_DUMP_MEM_WIDE_BUS);\n\n\t\t\tblock = get_dbg_block(p_hwfn,\n\t\t\t\t\t      cond_hdr->block_id);\n\n\t\t\t \n\t\t\tif (block->associated_storm_letter)\n\t\t\t\tstorm_letter = block->associated_storm_letter;\n\n\t\t\t \n\t\t\toffset += qed_grc_dump_mem(p_hwfn,\n\t\t\t\t\t\tp_ptt,\n\t\t\t\t\t\tdump_buf + offset,\n\t\t\t\t\t\tdump,\n\t\t\t\t\t\tNULL,\n\t\t\t\t\t\tmem_addr,\n\t\t\t\t\t\tmem_len,\n\t\t\t\t\t\tmem_wide_bus,\n\t\t\t\t\t\t0,\n\t\t\t\t\t\tfalse,\n\t\t\t\t\t\ts_mem_group_names[mem_group_id],\n\t\t\t\t\t\tstorm_letter);\n\t\t}\n\t}\n\n\treturn offset;\n}\n\n \nstatic u32 qed_grc_dump_memories(struct qed_hwfn *p_hwfn,\n\t\t\t\t struct qed_ptt *p_ptt,\n\t\t\t\t u32 *dump_buf, bool dump)\n{\n\tstruct virt_mem_desc *dbg_buf =\n\t    &p_hwfn->dbg_arrays[BIN_BUF_DBG_DUMP_MEM];\n\tu32 offset = 0, input_offset = 0;\n\n\twhile (input_offset < BYTES_TO_DWORDS(dbg_buf->size)) {\n\t\tconst struct dbg_dump_split_hdr *split_hdr;\n\t\tstruct virt_mem_desc curr_input_mems_arr;\n\t\tenum init_split_types split_type;\n\t\tu32 split_data_size;\n\n\t\tsplit_hdr =\n\t\t    (const struct dbg_dump_split_hdr *)dbg_buf->ptr +\n\t\t    input_offset++;\n\t\tsplit_type = GET_FIELD(split_hdr->hdr,\n\t\t\t\t       DBG_DUMP_SPLIT_HDR_SPLIT_TYPE_ID);\n\t\tsplit_data_size = GET_FIELD(split_hdr->hdr,\n\t\t\t\t\t    DBG_DUMP_SPLIT_HDR_DATA_SIZE);\n\t\tcurr_input_mems_arr.ptr = (u32 *)dbg_buf->ptr + input_offset;\n\t\tcurr_input_mems_arr.size = DWORDS_TO_BYTES(split_data_size);\n\n\t\tif (split_type == SPLIT_TYPE_NONE)\n\t\t\toffset += qed_grc_dump_mem_entries(p_hwfn,\n\t\t\t\t\t\t\t   p_ptt,\n\t\t\t\t\t\t\t   curr_input_mems_arr,\n\t\t\t\t\t\t\t   dump_buf + offset,\n\t\t\t\t\t\t\t   dump);\n\t\telse\n\t\t\tDP_NOTICE(p_hwfn,\n\t\t\t\t  \"Dumping split memories is currently not supported\\n\");\n\n\t\tinput_offset += split_data_size;\n\t}\n\n\treturn offset;\n}\n\n \nstatic u32 qed_grc_dump_ctx_data(struct qed_hwfn *p_hwfn,\n\t\t\t\t struct qed_ptt *p_ptt,\n\t\t\t\t u32 *dump_buf,\n\t\t\t\t bool dump,\n\t\t\t\t const char *name,\n\t\t\t\t u32 num_lids,\n\t\t\t\t enum cm_ctx_types ctx_type, u8 storm_id)\n{\n\tstruct dbg_tools_data *dev_data = &p_hwfn->dbg_info;\n\tstruct storm_defs *storm = &s_storm_defs[storm_id];\n\tu32 i, lid, lid_size, total_size;\n\tu32 rd_reg_addr, offset = 0;\n\n\t \n\tlid_size = storm->cm_ctx_lid_sizes[dev_data->chip_id][ctx_type] * 4;\n\n\tif (!lid_size)\n\t\treturn 0;\n\n\ttotal_size = num_lids * lid_size;\n\n\toffset += qed_grc_dump_mem_hdr(p_hwfn,\n\t\t\t\t       dump_buf + offset,\n\t\t\t\t       dump,\n\t\t\t\t       name,\n\t\t\t\t       0,\n\t\t\t\t       total_size,\n\t\t\t\t       lid_size * 32,\n\t\t\t\t       false, name, storm->letter);\n\n\tif (!dump)\n\t\treturn offset + total_size;\n\n\trd_reg_addr = BYTES_TO_DWORDS(storm->cm_ctx_rd_addr[ctx_type]);\n\n\t \n\tfor (lid = 0; lid < num_lids; lid++) {\n\t\tfor (i = 0; i < lid_size; i++) {\n\t\t\tqed_wr(p_hwfn,\n\t\t\t       p_ptt, storm->cm_ctx_wr_addr, (i << 9) | lid);\n\t\t\toffset += qed_grc_dump_addr_range(p_hwfn,\n\t\t\t\t\t\t\t  p_ptt,\n\t\t\t\t\t\t\t  dump_buf + offset,\n\t\t\t\t\t\t\t  dump,\n\t\t\t\t\t\t\t  rd_reg_addr,\n\t\t\t\t\t\t\t  1,\n\t\t\t\t\t\t\t  false,\n\t\t\t\t\t\t\t  SPLIT_TYPE_NONE, 0);\n\t\t}\n\t}\n\n\treturn offset;\n}\n\n \nstatic u32 qed_grc_dump_ctx(struct qed_hwfn *p_hwfn,\n\t\t\t    struct qed_ptt *p_ptt, u32 *dump_buf, bool dump)\n{\n\tu32 offset = 0;\n\tu8 storm_id;\n\n\tfor (storm_id = 0; storm_id < MAX_DBG_STORMS; storm_id++) {\n\t\tif (!qed_grc_is_storm_included(p_hwfn,\n\t\t\t\t\t       (enum dbg_storms)storm_id))\n\t\t\tcontinue;\n\n\t\t \n\t\toffset += qed_grc_dump_ctx_data(p_hwfn,\n\t\t\t\t\t\tp_ptt,\n\t\t\t\t\t\tdump_buf + offset,\n\t\t\t\t\t\tdump,\n\t\t\t\t\t\t\"CONN_AG_CTX\",\n\t\t\t\t\t\tNUM_OF_LCIDS,\n\t\t\t\t\t\tCM_CTX_CONN_AG, storm_id);\n\n\t\t \n\t\toffset += qed_grc_dump_ctx_data(p_hwfn,\n\t\t\t\t\t\tp_ptt,\n\t\t\t\t\t\tdump_buf + offset,\n\t\t\t\t\t\tdump,\n\t\t\t\t\t\t\"CONN_ST_CTX\",\n\t\t\t\t\t\tNUM_OF_LCIDS,\n\t\t\t\t\t\tCM_CTX_CONN_ST, storm_id);\n\n\t\t \n\t\toffset += qed_grc_dump_ctx_data(p_hwfn,\n\t\t\t\t\t\tp_ptt,\n\t\t\t\t\t\tdump_buf + offset,\n\t\t\t\t\t\tdump,\n\t\t\t\t\t\t\"TASK_AG_CTX\",\n\t\t\t\t\t\tNUM_OF_LTIDS,\n\t\t\t\t\t\tCM_CTX_TASK_AG, storm_id);\n\n\t\t \n\t\toffset += qed_grc_dump_ctx_data(p_hwfn,\n\t\t\t\t\t\tp_ptt,\n\t\t\t\t\t\tdump_buf + offset,\n\t\t\t\t\t\tdump,\n\t\t\t\t\t\t\"TASK_ST_CTX\",\n\t\t\t\t\t\tNUM_OF_LTIDS,\n\t\t\t\t\t\tCM_CTX_TASK_ST, storm_id);\n\t}\n\n\treturn offset;\n}\n\n#define VFC_STATUS_RESP_READY_BIT\t0\n#define VFC_STATUS_BUSY_BIT\t\t1\n#define VFC_STATUS_SENDING_CMD_BIT\t2\n\n#define VFC_POLLING_DELAY_MS\t1\n#define VFC_POLLING_COUNT\t\t20\n\n \nstatic u32 qed_grc_dump_read_from_vfc(struct qed_hwfn *p_hwfn,\n\t\t\t\t      struct qed_ptt *p_ptt,\n\t\t\t\t      struct storm_defs *storm,\n\t\t\t\t      u32 *cmd_data,\n\t\t\t\t      u32 cmd_size,\n\t\t\t\t      u32 *addr_data,\n\t\t\t\t      u32 addr_size,\n\t\t\t\t      u32 resp_size, u32 *dump_buf)\n{\n\tstruct dbg_tools_data *dev_data = &p_hwfn->dbg_info;\n\tu32 vfc_status, polling_ms, polling_count = 0, i;\n\tu32 reg_addr, sem_base;\n\tbool is_ready = false;\n\n\tsem_base = storm->sem_fast_mem_addr;\n\tpolling_ms = VFC_POLLING_DELAY_MS *\n\t    s_hw_type_defs[dev_data->hw_type].delay_factor;\n\n\t \n\tARR_REG_WR(p_hwfn,\n\t\t   p_ptt,\n\t\t   sem_base + SEM_FAST_REG_VFC_DATA_WR,\n\t\t   cmd_data, cmd_size);\n\n\t \n\tARR_REG_WR(p_hwfn,\n\t\t   p_ptt,\n\t\t   sem_base + SEM_FAST_REG_VFC_ADDR,\n\t\t   addr_data, addr_size);\n\n\t \n\tfor (i = 0; i < resp_size; i++) {\n\t\t \n\t\tdo {\n\t\t\treg_addr = sem_base + SEM_FAST_REG_VFC_STATUS;\n\t\t\tqed_grc_dump_addr_range(p_hwfn,\n\t\t\t\t\t\tp_ptt,\n\t\t\t\t\t\t&vfc_status,\n\t\t\t\t\t\ttrue,\n\t\t\t\t\t\tBYTES_TO_DWORDS(reg_addr),\n\t\t\t\t\t\t1,\n\t\t\t\t\t\tfalse, SPLIT_TYPE_NONE, 0);\n\t\t\tis_ready = vfc_status & BIT(VFC_STATUS_RESP_READY_BIT);\n\n\t\t\tif (!is_ready) {\n\t\t\t\tif (polling_count++ == VFC_POLLING_COUNT)\n\t\t\t\t\treturn 0;\n\n\t\t\t\tmsleep(polling_ms);\n\t\t\t}\n\t\t} while (!is_ready);\n\n\t\treg_addr = sem_base + SEM_FAST_REG_VFC_DATA_RD;\n\t\tqed_grc_dump_addr_range(p_hwfn,\n\t\t\t\t\tp_ptt,\n\t\t\t\t\tdump_buf + i,\n\t\t\t\t\ttrue,\n\t\t\t\t\tBYTES_TO_DWORDS(reg_addr),\n\t\t\t\t\t1, false, SPLIT_TYPE_NONE, 0);\n\t}\n\n\treturn resp_size;\n}\n\n \nstatic u32 qed_grc_dump_vfc_cam(struct qed_hwfn *p_hwfn,\n\t\t\t\tstruct qed_ptt *p_ptt,\n\t\t\t\tu32 *dump_buf, bool dump, u8 storm_id)\n{\n\tu32 total_size = VFC_CAM_NUM_ROWS * VFC_CAM_RESP_DWORDS;\n\tstruct storm_defs *storm = &s_storm_defs[storm_id];\n\tu32 cam_addr[VFC_CAM_ADDR_DWORDS] = { 0 };\n\tu32 cam_cmd[VFC_CAM_CMD_DWORDS] = { 0 };\n\tu32 row, offset = 0;\n\n\toffset += qed_grc_dump_mem_hdr(p_hwfn,\n\t\t\t\t       dump_buf + offset,\n\t\t\t\t       dump,\n\t\t\t\t       \"vfc_cam\",\n\t\t\t\t       0,\n\t\t\t\t       total_size,\n\t\t\t\t       256,\n\t\t\t\t       false, \"vfc_cam\", storm->letter);\n\n\tif (!dump)\n\t\treturn offset + total_size;\n\n\t \n\tSET_VAR_FIELD(cam_addr, VFC_CAM_ADDR, OP, VFC_OPCODE_CAM_RD);\n\n\t \n\tfor (row = 0; row < VFC_CAM_NUM_ROWS; row++) {\n\t\tSET_VAR_FIELD(cam_cmd, VFC_CAM_CMD, ROW, row);\n\t\toffset += qed_grc_dump_read_from_vfc(p_hwfn,\n\t\t\t\t\t\t     p_ptt,\n\t\t\t\t\t\t     storm,\n\t\t\t\t\t\t     cam_cmd,\n\t\t\t\t\t\t     VFC_CAM_CMD_DWORDS,\n\t\t\t\t\t\t     cam_addr,\n\t\t\t\t\t\t     VFC_CAM_ADDR_DWORDS,\n\t\t\t\t\t\t     VFC_CAM_RESP_DWORDS,\n\t\t\t\t\t\t     dump_buf + offset);\n\t}\n\n\treturn offset;\n}\n\n \nstatic u32 qed_grc_dump_vfc_ram(struct qed_hwfn *p_hwfn,\n\t\t\t\tstruct qed_ptt *p_ptt,\n\t\t\t\tu32 *dump_buf,\n\t\t\t\tbool dump,\n\t\t\t\tu8 storm_id, struct vfc_ram_defs *ram_defs)\n{\n\tu32 total_size = ram_defs->num_rows * VFC_RAM_RESP_DWORDS;\n\tstruct storm_defs *storm = &s_storm_defs[storm_id];\n\tu32 ram_addr[VFC_RAM_ADDR_DWORDS] = { 0 };\n\tu32 ram_cmd[VFC_RAM_CMD_DWORDS] = { 0 };\n\tu32 row, offset = 0;\n\n\toffset += qed_grc_dump_mem_hdr(p_hwfn,\n\t\t\t\t       dump_buf + offset,\n\t\t\t\t       dump,\n\t\t\t\t       ram_defs->mem_name,\n\t\t\t\t       0,\n\t\t\t\t       total_size,\n\t\t\t\t       256,\n\t\t\t\t       false,\n\t\t\t\t       ram_defs->type_name,\n\t\t\t\t       storm->letter);\n\n\tif (!dump)\n\t\treturn offset + total_size;\n\n\t \n\tSET_VAR_FIELD(ram_addr, VFC_RAM_ADDR, OP, VFC_OPCODE_RAM_RD);\n\n\t \n\tfor (row = ram_defs->base_row;\n\t     row < ram_defs->base_row + ram_defs->num_rows; row++) {\n\t\tSET_VAR_FIELD(ram_addr, VFC_RAM_ADDR, ROW, row);\n\t\toffset += qed_grc_dump_read_from_vfc(p_hwfn,\n\t\t\t\t\t\t     p_ptt,\n\t\t\t\t\t\t     storm,\n\t\t\t\t\t\t     ram_cmd,\n\t\t\t\t\t\t     VFC_RAM_CMD_DWORDS,\n\t\t\t\t\t\t     ram_addr,\n\t\t\t\t\t\t     VFC_RAM_ADDR_DWORDS,\n\t\t\t\t\t\t     VFC_RAM_RESP_DWORDS,\n\t\t\t\t\t\t     dump_buf + offset);\n\t}\n\n\treturn offset;\n}\n\n \nstatic u32 qed_grc_dump_vfc(struct qed_hwfn *p_hwfn,\n\t\t\t    struct qed_ptt *p_ptt, u32 *dump_buf, bool dump)\n{\n\tu8 storm_id, i;\n\tu32 offset = 0;\n\n\tfor (storm_id = 0; storm_id < MAX_DBG_STORMS; storm_id++) {\n\t\tif (!qed_grc_is_storm_included(p_hwfn,\n\t\t\t\t\t       (enum dbg_storms)storm_id) ||\n\t\t    !s_storm_defs[storm_id].has_vfc)\n\t\t\tcontinue;\n\n\t\t \n\t\toffset += qed_grc_dump_vfc_cam(p_hwfn,\n\t\t\t\t\t       p_ptt,\n\t\t\t\t\t       dump_buf + offset,\n\t\t\t\t\t       dump, storm_id);\n\n\t\t \n\t\tfor (i = 0; i < NUM_VFC_RAM_TYPES; i++)\n\t\t\toffset += qed_grc_dump_vfc_ram(p_hwfn,\n\t\t\t\t\t\t       p_ptt,\n\t\t\t\t\t\t       dump_buf + offset,\n\t\t\t\t\t\t       dump,\n\t\t\t\t\t\t       storm_id,\n\t\t\t\t\t\t       &s_vfc_ram_defs[i]);\n\t}\n\n\treturn offset;\n}\n\n \nstatic u32 qed_grc_dump_rss(struct qed_hwfn *p_hwfn,\n\t\t\t    struct qed_ptt *p_ptt, u32 *dump_buf, bool dump)\n{\n\tstruct dbg_tools_data *dev_data = &p_hwfn->dbg_info;\n\tu32 offset = 0;\n\tu8 rss_mem_id;\n\n\tfor (rss_mem_id = 0; rss_mem_id < NUM_RSS_MEM_TYPES; rss_mem_id++) {\n\t\tu32 rss_addr, num_entries, total_dwords;\n\t\tstruct rss_mem_defs *rss_defs;\n\t\tu32 addr, num_dwords_to_read;\n\t\tbool packed;\n\n\t\trss_defs = &s_rss_mem_defs[rss_mem_id];\n\t\trss_addr = rss_defs->addr;\n\t\tnum_entries = rss_defs->num_entries[dev_data->chip_id];\n\t\ttotal_dwords = (num_entries * rss_defs->entry_width) / 32;\n\t\tpacked = (rss_defs->entry_width == 16);\n\n\t\toffset += qed_grc_dump_mem_hdr(p_hwfn,\n\t\t\t\t\t       dump_buf + offset,\n\t\t\t\t\t       dump,\n\t\t\t\t\t       rss_defs->mem_name,\n\t\t\t\t\t       0,\n\t\t\t\t\t       total_dwords,\n\t\t\t\t\t       rss_defs->entry_width,\n\t\t\t\t\t       packed,\n\t\t\t\t\t       rss_defs->type_name, 0);\n\n\t\t \n\t\tif (!dump) {\n\t\t\toffset += total_dwords;\n\t\t\tcontinue;\n\t\t}\n\n\t\taddr = BYTES_TO_DWORDS(RSS_REG_RSS_RAM_DATA);\n\t\twhile (total_dwords) {\n\t\t\tnum_dwords_to_read = min_t(u32,\n\t\t\t\t\t\t   RSS_REG_RSS_RAM_DATA_SIZE,\n\t\t\t\t\t\t   total_dwords);\n\t\t\tqed_wr(p_hwfn, p_ptt, RSS_REG_RSS_RAM_ADDR, rss_addr);\n\t\t\toffset += qed_grc_dump_addr_range(p_hwfn,\n\t\t\t\t\t\t\t  p_ptt,\n\t\t\t\t\t\t\t  dump_buf + offset,\n\t\t\t\t\t\t\t  dump,\n\t\t\t\t\t\t\t  addr,\n\t\t\t\t\t\t\t  num_dwords_to_read,\n\t\t\t\t\t\t\t  false,\n\t\t\t\t\t\t\t  SPLIT_TYPE_NONE, 0);\n\t\t\ttotal_dwords -= num_dwords_to_read;\n\t\t\trss_addr++;\n\t\t}\n\t}\n\n\treturn offset;\n}\n\n \nstatic u32 qed_grc_dump_big_ram(struct qed_hwfn *p_hwfn,\n\t\t\t\tstruct qed_ptt *p_ptt,\n\t\t\t\tu32 *dump_buf, bool dump, u8 big_ram_id)\n{\n\tstruct dbg_tools_data *dev_data = &p_hwfn->dbg_info;\n\tu32 block_size, ram_size, offset = 0, reg_val, i;\n\tchar mem_name[12] = \"???_BIG_RAM\";\n\tchar type_name[8] = \"???_RAM\";\n\tstruct big_ram_defs *big_ram;\n\n\tbig_ram = &s_big_ram_defs[big_ram_id];\n\tram_size = big_ram->ram_size[dev_data->chip_id];\n\n\treg_val = qed_rd(p_hwfn, p_ptt, big_ram->is_256b_reg_addr);\n\tblock_size = reg_val &\n\t\t     BIT(big_ram->is_256b_bit_offset[dev_data->chip_id]) ? 256\n\t\t\t\t\t\t\t\t\t : 128;\n\n\tstrncpy(type_name, big_ram->instance_name, BIG_RAM_NAME_LEN);\n\tstrncpy(mem_name, big_ram->instance_name, BIG_RAM_NAME_LEN);\n\n\t \n\toffset += qed_grc_dump_mem_hdr(p_hwfn,\n\t\t\t\t       dump_buf + offset,\n\t\t\t\t       dump,\n\t\t\t\t       mem_name,\n\t\t\t\t       0,\n\t\t\t\t       ram_size,\n\t\t\t\t       block_size * 8,\n\t\t\t\t       false, type_name, 0);\n\n\t \n\tif (!dump)\n\t\treturn offset + ram_size;\n\n\t \n\tfor (i = 0; i < DIV_ROUND_UP(ram_size, BRB_REG_BIG_RAM_DATA_SIZE);\n\t     i++) {\n\t\tu32 addr, len;\n\n\t\tqed_wr(p_hwfn, p_ptt, big_ram->addr_reg_addr, i);\n\t\taddr = BYTES_TO_DWORDS(big_ram->data_reg_addr);\n\t\tlen = BRB_REG_BIG_RAM_DATA_SIZE;\n\t\toffset += qed_grc_dump_addr_range(p_hwfn,\n\t\t\t\t\t\t  p_ptt,\n\t\t\t\t\t\t  dump_buf + offset,\n\t\t\t\t\t\t  dump,\n\t\t\t\t\t\t  addr,\n\t\t\t\t\t\t  len,\n\t\t\t\t\t\t  false, SPLIT_TYPE_NONE, 0);\n\t}\n\n\treturn offset;\n}\n\n \nstatic u32 qed_grc_dump_mcp(struct qed_hwfn *p_hwfn,\n\t\t\t    struct qed_ptt *p_ptt, u32 *dump_buf, bool dump)\n{\n\tbool block_enable[MAX_BLOCK_ID] = { 0 };\n\tu32 offset = 0, addr;\n\tbool halted = false;\n\n\t \n\tif (dump && !qed_grc_get_param(p_hwfn, DBG_GRC_PARAM_NO_MCP)) {\n\t\thalted = !qed_mcp_halt(p_hwfn, p_ptt);\n\t\tif (!halted)\n\t\t\tDP_NOTICE(p_hwfn, \"MCP halt failed!\\n\");\n\t}\n\n\t \n\toffset += qed_grc_dump_mem(p_hwfn,\n\t\t\t\t   p_ptt,\n\t\t\t\t   dump_buf + offset,\n\t\t\t\t   dump,\n\t\t\t\t   NULL,\n\t\t\t\t   BYTES_TO_DWORDS(MCP_REG_SCRATCH),\n\t\t\t\t   MCP_REG_SCRATCH_SIZE,\n\t\t\t\t   false, 0, false, \"MCP\", 0);\n\n\t \n\toffset += qed_grc_dump_mem(p_hwfn,\n\t\t\t\t   p_ptt,\n\t\t\t\t   dump_buf + offset,\n\t\t\t\t   dump,\n\t\t\t\t   NULL,\n\t\t\t\t   BYTES_TO_DWORDS(MCP_REG_CPU_REG_FILE),\n\t\t\t\t   MCP_REG_CPU_REG_FILE_SIZE,\n\t\t\t\t   false, 0, false, \"MCP\", 0);\n\n\t \n\tblock_enable[BLOCK_MCP] = true;\n\toffset += qed_grc_dump_registers(p_hwfn,\n\t\t\t\t\t p_ptt,\n\t\t\t\t\t dump_buf + offset,\n\t\t\t\t\t dump, block_enable, \"MCP\");\n\n\t \n\toffset += qed_grc_dump_regs_hdr(dump_buf + offset,\n\t\t\t\t\tdump, 1, SPLIT_TYPE_NONE, 0,\n\t\t\t\t\t\"MCP\");\n\taddr = BYTES_TO_DWORDS(MISC_REG_SHARED_MEM_ADDR);\n\toffset += qed_grc_dump_reg_entry(p_hwfn,\n\t\t\t\t\t p_ptt,\n\t\t\t\t\t dump_buf + offset,\n\t\t\t\t\t dump,\n\t\t\t\t\t addr,\n\t\t\t\t\t 1,\n\t\t\t\t\t false, SPLIT_TYPE_NONE, 0);\n\n\t \n\tif (halted && qed_mcp_resume(p_hwfn, p_ptt))\n\t\tDP_NOTICE(p_hwfn, \"Failed to resume MCP after halt!\\n\");\n\n\treturn offset;\n}\n\n \nstatic u32 qed_grc_dump_phy(struct qed_hwfn *p_hwfn,\n\t\t\t    struct qed_ptt *p_ptt, u32 *dump_buf, bool dump)\n{\n\tu32 offset = 0, tbus_lo_offset, tbus_hi_offset;\n\tchar mem_name[32];\n\tu8 phy_id;\n\n\tfor (phy_id = 0; phy_id < ARRAY_SIZE(s_phy_defs); phy_id++) {\n\t\tu32 addr_lo_addr, addr_hi_addr, data_lo_addr, data_hi_addr;\n\t\tstruct phy_defs *phy_defs;\n\t\tu8 *bytes_buf;\n\n\t\tphy_defs = &s_phy_defs[phy_id];\n\t\taddr_lo_addr = phy_defs->base_addr +\n\t\t\t       phy_defs->tbus_addr_lo_addr;\n\t\taddr_hi_addr = phy_defs->base_addr +\n\t\t\t       phy_defs->tbus_addr_hi_addr;\n\t\tdata_lo_addr = phy_defs->base_addr +\n\t\t\t       phy_defs->tbus_data_lo_addr;\n\t\tdata_hi_addr = phy_defs->base_addr +\n\t\t\t       phy_defs->tbus_data_hi_addr;\n\n\t\tif (snprintf(mem_name, sizeof(mem_name), \"tbus_%s\",\n\t\t\t     phy_defs->phy_name) < 0)\n\t\t\tDP_NOTICE(p_hwfn,\n\t\t\t\t  \"Unexpected debug error: invalid PHY memory name\\n\");\n\n\t\toffset += qed_grc_dump_mem_hdr(p_hwfn,\n\t\t\t\t\t       dump_buf + offset,\n\t\t\t\t\t       dump,\n\t\t\t\t\t       mem_name,\n\t\t\t\t\t       0,\n\t\t\t\t\t       PHY_DUMP_SIZE_DWORDS,\n\t\t\t\t\t       16, true, mem_name, 0);\n\n\t\tif (!dump) {\n\t\t\toffset += PHY_DUMP_SIZE_DWORDS;\n\t\t\tcontinue;\n\t\t}\n\n\t\tbytes_buf = (u8 *)(dump_buf + offset);\n\t\tfor (tbus_hi_offset = 0;\n\t\t     tbus_hi_offset < (NUM_PHY_TBUS_ADDRESSES >> 8);\n\t\t     tbus_hi_offset++) {\n\t\t\tqed_wr(p_hwfn, p_ptt, addr_hi_addr, tbus_hi_offset);\n\t\t\tfor (tbus_lo_offset = 0; tbus_lo_offset < 256;\n\t\t\t     tbus_lo_offset++) {\n\t\t\t\tqed_wr(p_hwfn,\n\t\t\t\t       p_ptt, addr_lo_addr, tbus_lo_offset);\n\t\t\t\t*(bytes_buf++) = (u8)qed_rd(p_hwfn,\n\t\t\t\t\t\t\t    p_ptt,\n\t\t\t\t\t\t\t    data_lo_addr);\n\t\t\t\t*(bytes_buf++) = (u8)qed_rd(p_hwfn,\n\t\t\t\t\t\t\t    p_ptt,\n\t\t\t\t\t\t\t    data_hi_addr);\n\t\t\t}\n\t\t}\n\n\t\toffset += PHY_DUMP_SIZE_DWORDS;\n\t}\n\n\treturn offset;\n}\n\n \nstatic u32 qed_grc_dump_mcp_hw_dump(struct qed_hwfn *p_hwfn,\n\t\t\t\t    struct qed_ptt *p_ptt,\n\t\t\t\t    u32 *dump_buf, bool dump)\n{\n\tu32 hw_dump_offset_bytes = 0, hw_dump_size_bytes = 0;\n\tu32 hw_dump_size_dwords = 0, offset = 0;\n\tenum dbg_status status;\n\n\t \n\tstatus = qed_find_nvram_image(p_hwfn,\n\t\t\t\t      p_ptt,\n\t\t\t\t      NVM_TYPE_HW_DUMP_OUT,\n\t\t\t\t      &hw_dump_offset_bytes,\n\t\t\t\t      &hw_dump_size_bytes,\n\t\t\t\t      false);\n\tif (status != DBG_STATUS_OK)\n\t\treturn 0;\n\n\thw_dump_size_dwords = BYTES_TO_DWORDS(hw_dump_size_bytes);\n\n\t \n\toffset += qed_dump_section_hdr(dump_buf + offset,\n\t\t\t\t       dump, \"mcp_hw_dump\", 1);\n\toffset += qed_dump_num_param(dump_buf + offset,\n\t\t\t\t     dump, \"size\", hw_dump_size_dwords);\n\n\t \n\tif (dump && hw_dump_size_dwords) {\n\t\tstatus = qed_nvram_read(p_hwfn,\n\t\t\t\t\tp_ptt,\n\t\t\t\t\thw_dump_offset_bytes,\n\t\t\t\t\thw_dump_size_bytes,\n\t\t\t\t\tdump_buf + offset,\n\t\t\t\t\tfalse);\n\t\tif (status != DBG_STATUS_OK) {\n\t\t\tDP_NOTICE(p_hwfn,\n\t\t\t\t  \"Failed to read MCP HW Dump image from NVRAM\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\toffset += hw_dump_size_dwords;\n\n\treturn offset;\n}\n\n \nstatic u32 qed_grc_dump_static_debug(struct qed_hwfn *p_hwfn,\n\t\t\t\t     struct qed_ptt *p_ptt,\n\t\t\t\t     u32 *dump_buf, bool dump)\n{\n\tstruct dbg_tools_data *dev_data = &p_hwfn->dbg_info;\n\tu32 block_id, line_id, offset = 0, addr, len;\n\n\t \n\tif (dump && qed_rd(p_hwfn, p_ptt, DBG_REG_DBG_BLOCK_ON))\n\t\treturn 0;\n\n\tif (dump) {\n\t\t \n\t\tqed_bus_disable_blocks(p_hwfn, p_ptt);\n\n\t\tqed_bus_reset_dbg_block(p_hwfn, p_ptt);\n\t\tqed_wr(p_hwfn,\n\t\t       p_ptt, DBG_REG_FRAMING_MODE, DBG_BUS_FRAME_MODE_8HW);\n\t\tqed_wr(p_hwfn,\n\t\t       p_ptt, DBG_REG_DEBUG_TARGET, DBG_BUS_TARGET_ID_INT_BUF);\n\t\tqed_wr(p_hwfn, p_ptt, DBG_REG_FULL_MODE, 1);\n\t\tqed_bus_enable_dbg_block(p_hwfn, p_ptt, true);\n\t}\n\n\t \n\tfor (block_id = 0; block_id < MAX_BLOCK_ID; block_id++) {\n\t\tconst struct dbg_block_chip *block_per_chip;\n\t\tconst struct dbg_block *block;\n\t\tbool is_removed, has_dbg_bus;\n\t\tu16 modes_buf_offset;\n\t\tu32 block_dwords;\n\n\t\tblock_per_chip =\n\t\t    qed_get_dbg_block_per_chip(p_hwfn, (enum block_id)block_id);\n\t\tis_removed = GET_FIELD(block_per_chip->flags,\n\t\t\t\t       DBG_BLOCK_CHIP_IS_REMOVED);\n\t\thas_dbg_bus = GET_FIELD(block_per_chip->flags,\n\t\t\t\t\tDBG_BLOCK_CHIP_HAS_DBG_BUS);\n\n\t\tif (!is_removed && has_dbg_bus &&\n\t\t    GET_FIELD(block_per_chip->dbg_bus_mode.data,\n\t\t\t      DBG_MODE_HDR_EVAL_MODE) > 0) {\n\t\t\tmodes_buf_offset =\n\t\t\t    GET_FIELD(block_per_chip->dbg_bus_mode.data,\n\t\t\t\t      DBG_MODE_HDR_MODES_BUF_OFFSET);\n\t\t\tif (!qed_is_mode_match(p_hwfn, &modes_buf_offset))\n\t\t\t\thas_dbg_bus = false;\n\t\t}\n\n\t\tif (is_removed || !has_dbg_bus)\n\t\t\tcontinue;\n\n\t\tblock_dwords = NUM_DBG_LINES(block_per_chip) *\n\t\t\t       STATIC_DEBUG_LINE_DWORDS;\n\n\t\t \n\t\tblock = get_dbg_block(p_hwfn, (enum block_id)block_id);\n\t\toffset += qed_grc_dump_mem_hdr(p_hwfn,\n\t\t\t\t\t       dump_buf + offset,\n\t\t\t\t\t       dump,\n\t\t\t\t\t       block->name,\n\t\t\t\t\t       0,\n\t\t\t\t\t       block_dwords,\n\t\t\t\t\t       32, false, \"STATIC\", 0);\n\n\t\tif (!dump) {\n\t\t\toffset += block_dwords;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (dev_data->block_in_reset[block_id]) {\n\t\t\tmemset(dump_buf + offset, 0,\n\t\t\t       DWORDS_TO_BYTES(block_dwords));\n\t\t\toffset += block_dwords;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tqed_bus_enable_clients(p_hwfn,\n\t\t\t\t       p_ptt,\n\t\t\t\t       BIT(block_per_chip->dbg_client_id));\n\n\t\taddr = BYTES_TO_DWORDS(DBG_REG_CALENDAR_OUT_DATA);\n\t\tlen = STATIC_DEBUG_LINE_DWORDS;\n\t\tfor (line_id = 0; line_id < (u32)NUM_DBG_LINES(block_per_chip);\n\t\t     line_id++) {\n\t\t\t \n\t\t\tqed_bus_config_dbg_line(p_hwfn,\n\t\t\t\t\t\tp_ptt,\n\t\t\t\t\t\t(enum block_id)block_id,\n\t\t\t\t\t\t(u8)line_id, 0xf, 0, 0, 0);\n\n\t\t\t \n\t\t\toffset += qed_grc_dump_addr_range(p_hwfn,\n\t\t\t\t\t\t\t  p_ptt,\n\t\t\t\t\t\t\t  dump_buf + offset,\n\t\t\t\t\t\t\t  dump,\n\t\t\t\t\t\t\t  addr,\n\t\t\t\t\t\t\t  len,\n\t\t\t\t\t\t\t  true, SPLIT_TYPE_NONE,\n\t\t\t\t\t\t\t  0);\n\t\t}\n\n\t\t \n\t\tqed_bus_enable_clients(p_hwfn, p_ptt, 0);\n\t\tqed_bus_config_dbg_line(p_hwfn, p_ptt,\n\t\t\t\t\t(enum block_id)block_id, 0, 0, 0, 0, 0);\n\t}\n\n\tif (dump) {\n\t\tqed_bus_enable_dbg_block(p_hwfn, p_ptt, false);\n\t\tqed_bus_enable_clients(p_hwfn, p_ptt, 0);\n\t}\n\n\treturn offset;\n}\n\n \nstatic enum dbg_status qed_grc_dump(struct qed_hwfn *p_hwfn,\n\t\t\t\t    struct qed_ptt *p_ptt,\n\t\t\t\t    u32 *dump_buf,\n\t\t\t\t    bool dump, u32 *num_dumped_dwords)\n{\n\tstruct dbg_tools_data *dev_data = &p_hwfn->dbg_info;\n\tbool parities_masked = false;\n\tu32 dwords_read, offset = 0;\n\tu8 i;\n\n\t*num_dumped_dwords = 0;\n\tdev_data->num_regs_read = 0;\n\n\t \n\tif (dump)\n\t\tqed_update_blocks_reset_state(p_hwfn, p_ptt);\n\n\t \n\toffset += qed_dump_common_global_params(p_hwfn,\n\t\t\t\t\t\tp_ptt,\n\t\t\t\t\t\tdump_buf + offset, dump, 4);\n\toffset += qed_dump_str_param(dump_buf + offset,\n\t\t\t\t     dump, \"dump-type\", \"grc-dump\");\n\toffset += qed_dump_num_param(dump_buf + offset,\n\t\t\t\t     dump,\n\t\t\t\t     \"num-lcids\",\n\t\t\t\t     NUM_OF_LCIDS);\n\toffset += qed_dump_num_param(dump_buf + offset,\n\t\t\t\t     dump,\n\t\t\t\t     \"num-ltids\",\n\t\t\t\t     NUM_OF_LTIDS);\n\toffset += qed_dump_num_param(dump_buf + offset,\n\t\t\t\t     dump, \"num-ports\", dev_data->num_ports);\n\n\t \n\tif (qed_grc_is_included(p_hwfn, DBG_GRC_PARAM_DUMP_REGS))\n\t\toffset += qed_grc_dump_reset_regs(p_hwfn,\n\t\t\t\t\t\t  p_ptt,\n\t\t\t\t\t\t  dump_buf + offset, dump);\n\n\t \n\tif (dump) {\n\t\tqed_grc_unreset_blocks(p_hwfn, p_ptt, false);\n\t\tqed_update_blocks_reset_state(p_hwfn, p_ptt);\n\t}\n\n\t \n\tif (dump &&\n\t    !qed_grc_get_param(p_hwfn, DBG_GRC_PARAM_NO_MCP)) {\n\t\tparities_masked = !qed_mcp_mask_parities(p_hwfn, p_ptt, 1);\n\t\tif (!parities_masked) {\n\t\t\tDP_NOTICE(p_hwfn,\n\t\t\t\t  \"Failed to mask parities using MFW\\n\");\n\t\t\tif (qed_grc_get_param\n\t\t\t    (p_hwfn, DBG_GRC_PARAM_PARITY_SAFE))\n\t\t\t\treturn DBG_STATUS_MCP_COULD_NOT_MASK_PRTY;\n\t\t}\n\t}\n\n\t \n\tif (qed_grc_is_included(p_hwfn, DBG_GRC_PARAM_DUMP_REGS))\n\t\toffset += qed_grc_dump_modified_regs(p_hwfn,\n\t\t\t\t\t\t     p_ptt,\n\t\t\t\t\t\t     dump_buf + offset, dump);\n\n\t \n\tif (dump &&\n\t    (qed_grc_is_included(p_hwfn,\n\t\t\t\t DBG_GRC_PARAM_DUMP_IOR) ||\n\t     qed_grc_is_included(p_hwfn, DBG_GRC_PARAM_DUMP_VFC)))\n\t\tqed_grc_stall_storms(p_hwfn, p_ptt, true);\n\n\t \n\tif (qed_grc_is_included(p_hwfn, DBG_GRC_PARAM_DUMP_REGS)) {\n\t\tbool block_enable[MAX_BLOCK_ID];\n\n\t\t \n\t\tfor (i = 0; i < MAX_BLOCK_ID; i++)\n\t\t\tblock_enable[i] = true;\n\t\tblock_enable[BLOCK_MCP] = false;\n\t\toffset += qed_grc_dump_registers(p_hwfn,\n\t\t\t\t\t\t p_ptt,\n\t\t\t\t\t\t dump_buf +\n\t\t\t\t\t\t offset,\n\t\t\t\t\t\t dump,\n\t\t\t\t\t\t block_enable, NULL);\n\n\t\t \n\t\toffset += qed_grc_dump_special_regs(p_hwfn,\n\t\t\t\t\t\t    p_ptt,\n\t\t\t\t\t\t    dump_buf + offset, dump);\n\t}\n\n\t \n\toffset += qed_grc_dump_memories(p_hwfn, p_ptt, dump_buf + offset, dump);\n\n\t \n\tif (qed_grc_is_included(p_hwfn, DBG_GRC_PARAM_DUMP_MCP))\n\t\toffset += qed_grc_dump_mcp(p_hwfn,\n\t\t\t\t\t   p_ptt, dump_buf + offset, dump);\n\n\t \n\tif (qed_grc_is_included(p_hwfn, DBG_GRC_PARAM_DUMP_CM_CTX))\n\t\toffset += qed_grc_dump_ctx(p_hwfn,\n\t\t\t\t\t   p_ptt, dump_buf + offset, dump);\n\n\t \n\tif (qed_grc_is_included(p_hwfn, DBG_GRC_PARAM_DUMP_RSS))\n\t\toffset += qed_grc_dump_rss(p_hwfn,\n\t\t\t\t\t   p_ptt, dump_buf + offset, dump);\n\n\t \n\tfor (i = 0; i < NUM_BIG_RAM_TYPES; i++)\n\t\tif (qed_grc_is_included(p_hwfn, s_big_ram_defs[i].grc_param))\n\t\t\toffset += qed_grc_dump_big_ram(p_hwfn,\n\t\t\t\t\t\t       p_ptt,\n\t\t\t\t\t\t       dump_buf + offset,\n\t\t\t\t\t\t       dump, i);\n\n\t \n\tif (qed_grc_is_included(p_hwfn, DBG_GRC_PARAM_DUMP_VFC)) {\n\t\tdwords_read = qed_grc_dump_vfc(p_hwfn,\n\t\t\t\t\t       p_ptt, dump_buf + offset, dump);\n\t\toffset += dwords_read;\n\t\tif (!dwords_read)\n\t\t\treturn DBG_STATUS_VFC_READ_ERROR;\n\t}\n\n\t \n\tif (qed_grc_is_included(p_hwfn,\n\t\t\t\tDBG_GRC_PARAM_DUMP_PHY) && dev_data->chip_id ==\n\t    CHIP_K2 && dev_data->hw_type == HW_TYPE_ASIC)\n\t\toffset += qed_grc_dump_phy(p_hwfn,\n\t\t\t\t\t   p_ptt, dump_buf + offset, dump);\n\n\t \n\tif (qed_grc_is_included(p_hwfn, DBG_GRC_PARAM_DUMP_MCP_HW_DUMP) &&\n\t    !qed_grc_get_param(p_hwfn, DBG_GRC_PARAM_NO_MCP) && 1)\n\t\toffset += qed_grc_dump_mcp_hw_dump(p_hwfn,\n\t\t\t\t\t\t   p_ptt,\n\t\t\t\t\t\t   dump_buf + offset, dump);\n\n\t \n\tif (qed_grc_is_included(p_hwfn,\n\t\t\t\tDBG_GRC_PARAM_DUMP_STATIC) &&\n\t    (!dump || dev_data->bus.state == DBG_BUS_STATE_IDLE))\n\t\toffset += qed_grc_dump_static_debug(p_hwfn,\n\t\t\t\t\t\t    p_ptt,\n\t\t\t\t\t\t    dump_buf + offset, dump);\n\n\t \n\toffset += qed_dump_last_section(dump_buf, offset, dump);\n\n\tif (dump) {\n\t\t \n\t\tif (qed_grc_get_param(p_hwfn, DBG_GRC_PARAM_UNSTALL))\n\t\t\tqed_grc_stall_storms(p_hwfn, p_ptt, false);\n\n\t\t \n\t\tqed_grc_clear_all_prty(p_hwfn, p_ptt);\n\n\t\t \n\t\tif (parities_masked)\n\t\t\tqed_mcp_mask_parities(p_hwfn, p_ptt, 0);\n\t}\n\n\t*num_dumped_dwords = offset;\n\n\treturn DBG_STATUS_OK;\n}\n\n \nstatic u32 qed_idle_chk_dump_failure(struct qed_hwfn *p_hwfn,\n\t\t\t\t     struct qed_ptt *p_ptt,\n\t\t\t\t     u32 *dump_buf,\n\t\t\t\t     bool dump,\n\t\t\t\t     u16 rule_id,\n\t\t\t\t     const struct dbg_idle_chk_rule *rule,\n\t\t\t\t     u16 fail_entry_id, u32 *cond_reg_values)\n{\n\tstruct dbg_tools_data *dev_data = &p_hwfn->dbg_info;\n\tconst struct dbg_idle_chk_cond_reg *cond_regs;\n\tconst struct dbg_idle_chk_info_reg *info_regs;\n\tu32 i, next_reg_offset = 0, offset = 0;\n\tstruct dbg_idle_chk_result_hdr *hdr;\n\tconst union dbg_idle_chk_reg *regs;\n\tu8 reg_id;\n\n\thdr = (struct dbg_idle_chk_result_hdr *)dump_buf;\n\tregs = (const union dbg_idle_chk_reg *)\n\t\tp_hwfn->dbg_arrays[BIN_BUF_DBG_IDLE_CHK_REGS].ptr +\n\t\trule->reg_offset;\n\tcond_regs = &regs[0].cond_reg;\n\tinfo_regs = &regs[rule->num_cond_regs].info_reg;\n\n\t \n\tif (dump) {\n\t\tmemset(hdr, 0, sizeof(*hdr));\n\t\thdr->rule_id = rule_id;\n\t\thdr->mem_entry_id = fail_entry_id;\n\t\thdr->severity = rule->severity;\n\t\thdr->num_dumped_cond_regs = rule->num_cond_regs;\n\t}\n\n\toffset += IDLE_CHK_RESULT_HDR_DWORDS;\n\n\t \n\tfor (reg_id = 0; reg_id < rule->num_cond_regs; reg_id++) {\n\t\tconst struct dbg_idle_chk_cond_reg *reg = &cond_regs[reg_id];\n\t\tstruct dbg_idle_chk_result_reg_hdr *reg_hdr;\n\n\t\treg_hdr =\n\t\t    (struct dbg_idle_chk_result_reg_hdr *)(dump_buf + offset);\n\n\t\t \n\t\tif (!dump) {\n\t\t\toffset += IDLE_CHK_RESULT_REG_HDR_DWORDS +\n\t\t\t    reg->entry_size;\n\t\t\tcontinue;\n\t\t}\n\n\t\toffset += IDLE_CHK_RESULT_REG_HDR_DWORDS;\n\t\tmemset(reg_hdr, 0, sizeof(*reg_hdr));\n\t\treg_hdr->start_entry = reg->start_entry;\n\t\treg_hdr->size = reg->entry_size;\n\t\tSET_FIELD(reg_hdr->data,\n\t\t\t  DBG_IDLE_CHK_RESULT_REG_HDR_IS_MEM,\n\t\t\t  reg->num_entries > 1 || reg->start_entry > 0 ? 1 : 0);\n\t\tSET_FIELD(reg_hdr->data,\n\t\t\t  DBG_IDLE_CHK_RESULT_REG_HDR_REG_ID, reg_id);\n\n\t\t \n\t\tfor (i = 0; i < reg_hdr->size; i++, next_reg_offset++, offset++)\n\t\t\tdump_buf[offset] = cond_reg_values[next_reg_offset];\n\t}\n\n\t \n\tfor (reg_id = 0; reg_id < rule->num_info_regs; reg_id++) {\n\t\tconst struct dbg_idle_chk_info_reg *reg = &info_regs[reg_id];\n\t\tu32 block_id;\n\n\t\t \n\t\tif (!dump) {\n\t\t\toffset += IDLE_CHK_RESULT_REG_HDR_DWORDS + reg->size;\n\t\t\tcontinue;\n\t\t}\n\n\t\tblock_id = GET_FIELD(reg->data, DBG_IDLE_CHK_INFO_REG_BLOCK_ID);\n\t\tif (block_id >= MAX_BLOCK_ID) {\n\t\t\tDP_NOTICE(p_hwfn, \"Invalid block_id\\n\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (!dev_data->block_in_reset[block_id]) {\n\t\t\tstruct dbg_idle_chk_result_reg_hdr *reg_hdr;\n\t\t\tbool wide_bus, eval_mode, mode_match = true;\n\t\t\tu16 modes_buf_offset;\n\t\t\tu32 addr;\n\n\t\t\treg_hdr = (struct dbg_idle_chk_result_reg_hdr *)\n\t\t\t\t  (dump_buf + offset);\n\n\t\t\t \n\t\t\teval_mode = GET_FIELD(reg->mode.data,\n\t\t\t\t\t      DBG_MODE_HDR_EVAL_MODE) > 0;\n\t\t\tif (eval_mode) {\n\t\t\t\tmodes_buf_offset =\n\t\t\t\t    GET_FIELD(reg->mode.data,\n\t\t\t\t\t      DBG_MODE_HDR_MODES_BUF_OFFSET);\n\t\t\t\tmode_match =\n\t\t\t\t\tqed_is_mode_match(p_hwfn,\n\t\t\t\t\t\t\t  &modes_buf_offset);\n\t\t\t}\n\n\t\t\tif (!mode_match)\n\t\t\t\tcontinue;\n\n\t\t\taddr = GET_FIELD(reg->data,\n\t\t\t\t\t DBG_IDLE_CHK_INFO_REG_ADDRESS);\n\t\t\twide_bus = GET_FIELD(reg->data,\n\t\t\t\t\t     DBG_IDLE_CHK_INFO_REG_WIDE_BUS);\n\n\t\t\t \n\t\t\toffset += IDLE_CHK_RESULT_REG_HDR_DWORDS;\n\t\t\thdr->num_dumped_info_regs++;\n\t\t\tmemset(reg_hdr, 0, sizeof(*reg_hdr));\n\t\t\treg_hdr->size = reg->size;\n\t\t\tSET_FIELD(reg_hdr->data,\n\t\t\t\t  DBG_IDLE_CHK_RESULT_REG_HDR_REG_ID,\n\t\t\t\t  rule->num_cond_regs + reg_id);\n\n\t\t\t \n\t\t\toffset += qed_grc_dump_addr_range(p_hwfn,\n\t\t\t\t\t\t\t  p_ptt,\n\t\t\t\t\t\t\t  dump_buf + offset,\n\t\t\t\t\t\t\t  dump,\n\t\t\t\t\t\t\t  addr,\n\t\t\t\t\t\t\t  reg->size, wide_bus,\n\t\t\t\t\t\t\t  SPLIT_TYPE_NONE, 0);\n\t\t}\n\t}\n\n\treturn offset;\n}\n\n \nstatic u32\nqed_idle_chk_dump_rule_entries(struct qed_hwfn *p_hwfn, struct qed_ptt *p_ptt,\n\t\t\t       u32 *dump_buf, bool dump,\n\t\t\t       const struct dbg_idle_chk_rule *input_rules,\n\t\t\t       u32 num_input_rules, u32 *num_failing_rules)\n{\n\tstruct dbg_tools_data *dev_data = &p_hwfn->dbg_info;\n\tu32 cond_reg_values[IDLE_CHK_MAX_ENTRIES_SIZE];\n\tu32 i, offset = 0;\n\tu16 entry_id;\n\tu8 reg_id;\n\n\t*num_failing_rules = 0;\n\n\tfor (i = 0; i < num_input_rules; i++) {\n\t\tconst struct dbg_idle_chk_cond_reg *cond_regs;\n\t\tconst struct dbg_idle_chk_rule *rule;\n\t\tconst union dbg_idle_chk_reg *regs;\n\t\tu16 num_reg_entries = 1;\n\t\tbool check_rule = true;\n\t\tconst u32 *imm_values;\n\n\t\trule = &input_rules[i];\n\t\tregs = (const union dbg_idle_chk_reg *)\n\t\t\tp_hwfn->dbg_arrays[BIN_BUF_DBG_IDLE_CHK_REGS].ptr +\n\t\t\trule->reg_offset;\n\t\tcond_regs = &regs[0].cond_reg;\n\t\timm_values =\n\t\t    (u32 *)p_hwfn->dbg_arrays[BIN_BUF_DBG_IDLE_CHK_IMMS].ptr +\n\t\t    rule->imm_offset;\n\n\t\t \n\t\tfor (reg_id = 0; reg_id < rule->num_cond_regs && check_rule;\n\t\t     reg_id++) {\n\t\t\tu32 block_id =\n\t\t\t\tGET_FIELD(cond_regs[reg_id].data,\n\t\t\t\t\t  DBG_IDLE_CHK_COND_REG_BLOCK_ID);\n\n\t\t\tif (block_id >= MAX_BLOCK_ID) {\n\t\t\t\tDP_NOTICE(p_hwfn, \"Invalid block_id\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tcheck_rule = !dev_data->block_in_reset[block_id];\n\t\t\tif (cond_regs[reg_id].num_entries > num_reg_entries)\n\t\t\t\tnum_reg_entries = cond_regs[reg_id].num_entries;\n\t\t}\n\n\t\tif (!check_rule && dump)\n\t\t\tcontinue;\n\n\t\tif (!dump) {\n\t\t\tu32 entry_dump_size =\n\t\t\t\tqed_idle_chk_dump_failure(p_hwfn,\n\t\t\t\t\t\t\t  p_ptt,\n\t\t\t\t\t\t\t  dump_buf + offset,\n\t\t\t\t\t\t\t  false,\n\t\t\t\t\t\t\t  rule->rule_id,\n\t\t\t\t\t\t\t  rule,\n\t\t\t\t\t\t\t  0,\n\t\t\t\t\t\t\t  NULL);\n\n\t\t\toffset += num_reg_entries * entry_dump_size;\n\t\t\t(*num_failing_rules) += num_reg_entries;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tfor (entry_id = 0; entry_id < num_reg_entries; entry_id++) {\n\t\t\tu32 next_reg_offset = 0;\n\n\t\t\t \n\t\t\tfor (reg_id = 0; reg_id < rule->num_cond_regs;\n\t\t\t     reg_id++) {\n\t\t\t\tconst struct dbg_idle_chk_cond_reg *reg =\n\t\t\t\t\t&cond_regs[reg_id];\n\t\t\t\tu32 padded_entry_size, addr;\n\t\t\t\tbool wide_bus;\n\n\t\t\t\t \n\t\t\t\taddr = GET_FIELD(reg->data,\n\t\t\t\t\t\t DBG_IDLE_CHK_COND_REG_ADDRESS);\n\t\t\t\twide_bus =\n\t\t\t\t    GET_FIELD(reg->data,\n\t\t\t\t\t      DBG_IDLE_CHK_COND_REG_WIDE_BUS);\n\t\t\t\tif (reg->num_entries > 1 ||\n\t\t\t\t    reg->start_entry > 0) {\n\t\t\t\t\tpadded_entry_size =\n\t\t\t\t\t   reg->entry_size > 1 ?\n\t\t\t\t\t   roundup_pow_of_two(reg->entry_size) :\n\t\t\t\t\t   1;\n\t\t\t\t\taddr += (reg->start_entry + entry_id) *\n\t\t\t\t\t\tpadded_entry_size;\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tif (next_reg_offset + reg->entry_size >=\n\t\t\t\t    IDLE_CHK_MAX_ENTRIES_SIZE) {\n\t\t\t\t\tDP_NOTICE(p_hwfn,\n\t\t\t\t\t\t  \"idle check registers entry is too large\\n\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\t\t\tnext_reg_offset +=\n\t\t\t\t    qed_grc_dump_addr_range(p_hwfn, p_ptt,\n\t\t\t\t\t\t\t    cond_reg_values +\n\t\t\t\t\t\t\t    next_reg_offset,\n\t\t\t\t\t\t\t    dump, addr,\n\t\t\t\t\t\t\t    reg->entry_size,\n\t\t\t\t\t\t\t    wide_bus,\n\t\t\t\t\t\t\t    SPLIT_TYPE_NONE, 0);\n\t\t\t}\n\n\t\t\t \n\t\t\tif ((*cond_arr[rule->cond_id]) (cond_reg_values,\n\t\t\t\t\t\t\timm_values)) {\n\t\t\t\toffset += qed_idle_chk_dump_failure(p_hwfn,\n\t\t\t\t\t\t\tp_ptt,\n\t\t\t\t\t\t\tdump_buf + offset,\n\t\t\t\t\t\t\tdump,\n\t\t\t\t\t\t\trule->rule_id,\n\t\t\t\t\t\t\trule,\n\t\t\t\t\t\t\tentry_id,\n\t\t\t\t\t\t\tcond_reg_values);\n\t\t\t\t(*num_failing_rules)++;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn offset;\n}\n\n \nstatic u32 qed_idle_chk_dump(struct qed_hwfn *p_hwfn,\n\t\t\t     struct qed_ptt *p_ptt, u32 *dump_buf, bool dump)\n{\n\tstruct virt_mem_desc *dbg_buf =\n\t    &p_hwfn->dbg_arrays[BIN_BUF_DBG_IDLE_CHK_RULES];\n\tu32 num_failing_rules_offset, offset = 0,\n\t    input_offset = 0, num_failing_rules = 0;\n\n\t \n\toffset += qed_dump_common_global_params(p_hwfn,\n\t\t\t\t\t\tp_ptt,\n\t\t\t\t\t\tdump_buf + offset, dump, 1);\n\toffset += qed_dump_str_param(dump_buf + offset,\n\t\t\t\t     dump, \"dump-type\", \"idle-chk\");\n\n\t \n\toffset += qed_dump_section_hdr(dump_buf + offset, dump, \"idle_chk\", 1);\n\tnum_failing_rules_offset = offset;\n\toffset += qed_dump_num_param(dump_buf + offset, dump, \"num_rules\", 0);\n\n\twhile (input_offset < BYTES_TO_DWORDS(dbg_buf->size)) {\n\t\tconst struct dbg_idle_chk_cond_hdr *cond_hdr =\n\t\t    (const struct dbg_idle_chk_cond_hdr *)dbg_buf->ptr +\n\t\t    input_offset++;\n\t\tbool eval_mode, mode_match = true;\n\t\tu32 curr_failing_rules;\n\t\tu16 modes_buf_offset;\n\n\t\t \n\t\teval_mode = GET_FIELD(cond_hdr->mode.data,\n\t\t\t\t      DBG_MODE_HDR_EVAL_MODE) > 0;\n\t\tif (eval_mode) {\n\t\t\tmodes_buf_offset =\n\t\t\t\tGET_FIELD(cond_hdr->mode.data,\n\t\t\t\t\t  DBG_MODE_HDR_MODES_BUF_OFFSET);\n\t\t\tmode_match = qed_is_mode_match(p_hwfn,\n\t\t\t\t\t\t       &modes_buf_offset);\n\t\t}\n\n\t\tif (mode_match) {\n\t\t\tconst struct dbg_idle_chk_rule *rule =\n\t\t\t    (const struct dbg_idle_chk_rule *)((u32 *)\n\t\t\t\t\t\t\t       dbg_buf->ptr\n\t\t\t\t\t\t\t       + input_offset);\n\t\t\tu32 num_input_rules =\n\t\t\t\tcond_hdr->data_size / IDLE_CHK_RULE_SIZE_DWORDS;\n\t\t\toffset +=\n\t\t\t    qed_idle_chk_dump_rule_entries(p_hwfn,\n\t\t\t\t\t\t\t   p_ptt,\n\t\t\t\t\t\t\t   dump_buf +\n\t\t\t\t\t\t\t   offset,\n\t\t\t\t\t\t\t   dump,\n\t\t\t\t\t\t\t   rule,\n\t\t\t\t\t\t\t   num_input_rules,\n\t\t\t\t\t\t\t   &curr_failing_rules);\n\t\t\tnum_failing_rules += curr_failing_rules;\n\t\t}\n\n\t\tinput_offset += cond_hdr->data_size;\n\t}\n\n\t \n\tif (dump)\n\t\tqed_dump_num_param(dump_buf + num_failing_rules_offset,\n\t\t\t\t   dump, \"num_rules\", num_failing_rules);\n\n\t \n\toffset += qed_dump_last_section(dump_buf, offset, dump);\n\n\treturn offset;\n}\n\n \nstatic enum dbg_status qed_mcp_trace_get_data_info(struct qed_hwfn *p_hwfn,\n\t\t\t\t\t\t   struct qed_ptt *p_ptt,\n\t\t\t\t\t\t   u32 *trace_data_grc_addr,\n\t\t\t\t\t\t   u32 *trace_data_size)\n{\n\tu32 spad_trace_offsize, signature;\n\n\t \n\tspad_trace_offsize = qed_rd(p_hwfn, p_ptt, MCP_SPAD_TRACE_OFFSIZE_ADDR);\n\n\t \n\t*trace_data_grc_addr =\n\t\tMCP_REG_SCRATCH + SECTION_OFFSET(spad_trace_offsize);\n\n\t \n\tsignature = qed_rd(p_hwfn, p_ptt,\n\t\t\t   *trace_data_grc_addr +\n\t\t\t   offsetof(struct mcp_trace, signature));\n\n\tif (signature != MFW_TRACE_SIGNATURE)\n\t\treturn DBG_STATUS_INVALID_TRACE_SIGNATURE;\n\n\t \n\t*trace_data_size = qed_rd(p_hwfn,\n\t\t\t\t  p_ptt,\n\t\t\t\t  *trace_data_grc_addr +\n\t\t\t\t  offsetof(struct mcp_trace, size));\n\n\treturn DBG_STATUS_OK;\n}\n\n \nstatic enum dbg_status qed_mcp_trace_get_meta_info(struct qed_hwfn *p_hwfn,\n\t\t\t\t\t\t   struct qed_ptt *p_ptt,\n\t\t\t\t\t\t   u32 trace_data_size_bytes,\n\t\t\t\t\t\t   u32 *running_bundle_id,\n\t\t\t\t\t\t   u32 *trace_meta_offset,\n\t\t\t\t\t\t   u32 *trace_meta_size)\n{\n\tu32 spad_trace_offsize, nvram_image_type, running_mfw_addr;\n\n\t \n\tspad_trace_offsize = qed_rd(p_hwfn, p_ptt, MCP_SPAD_TRACE_OFFSIZE_ADDR);\n\n\t \n\trunning_mfw_addr =\n\t\tMCP_REG_SCRATCH + SECTION_OFFSET(spad_trace_offsize) +\n\t\tQED_SECTION_SIZE(spad_trace_offsize) + trace_data_size_bytes;\n\t*running_bundle_id = qed_rd(p_hwfn, p_ptt, running_mfw_addr);\n\tif (*running_bundle_id > 1)\n\t\treturn DBG_STATUS_INVALID_NVRAM_BUNDLE;\n\n\t \n\tnvram_image_type =\n\t    (*running_bundle_id ==\n\t     DIR_ID_1) ? NVM_TYPE_MFW_TRACE1 : NVM_TYPE_MFW_TRACE2;\n\treturn qed_find_nvram_image(p_hwfn,\n\t\t\t\t    p_ptt,\n\t\t\t\t    nvram_image_type,\n\t\t\t\t    trace_meta_offset,\n\t\t\t\t    trace_meta_size,\n\t\t\t\t    true);\n}\n\n \nstatic enum dbg_status qed_mcp_trace_read_meta(struct qed_hwfn *p_hwfn,\n\t\t\t\t\t       struct qed_ptt *p_ptt,\n\t\t\t\t\t       u32 nvram_offset_in_bytes,\n\t\t\t\t\t       u32 size_in_bytes, u32 *buf)\n{\n\tu8 modules_num, module_len, i, *byte_buf = (u8 *)buf;\n\tenum dbg_status status;\n\tu32 signature;\n\n\t \n\tstatus = qed_nvram_read(p_hwfn,\n\t\t\t\tp_ptt,\n\t\t\t\tnvram_offset_in_bytes,\n\t\t\t\tsize_in_bytes,\n\t\t\t\tbuf,\n\t\t\t\ttrue);\n\tif (status != DBG_STATUS_OK)\n\t\treturn status;\n\n\t \n\tsignature = qed_read_unaligned_dword(byte_buf);\n\tbyte_buf += sizeof(signature);\n\tif (signature != NVM_MAGIC_VALUE)\n\t\treturn DBG_STATUS_INVALID_TRACE_SIGNATURE;\n\n\t \n\tmodules_num = *(byte_buf++);\n\n\t \n\tfor (i = 0; i < modules_num; i++) {\n\t\tmodule_len = *(byte_buf++);\n\t\tbyte_buf += module_len;\n\t}\n\n\t \n\tsignature = qed_read_unaligned_dword(byte_buf);\n\tbyte_buf += sizeof(signature);\n\tif (signature != NVM_MAGIC_VALUE)\n\t\treturn DBG_STATUS_INVALID_TRACE_SIGNATURE;\n\n\treturn DBG_STATUS_OK;\n}\n\n \nstatic enum dbg_status qed_mcp_trace_dump(struct qed_hwfn *p_hwfn,\n\t\t\t\t\t  struct qed_ptt *p_ptt,\n\t\t\t\t\t  u32 *dump_buf,\n\t\t\t\t\t  bool dump, u32 *num_dumped_dwords)\n{\n\tu32 trace_data_grc_addr, trace_data_size_bytes, trace_data_size_dwords;\n\tu32 trace_meta_size_dwords = 0, running_bundle_id, offset = 0;\n\tu32 trace_meta_offset_bytes = 0, trace_meta_size_bytes = 0;\n\tenum dbg_status status;\n\tint halted = 0;\n\tbool use_mfw;\n\n\t*num_dumped_dwords = 0;\n\n\tuse_mfw = !qed_grc_get_param(p_hwfn, DBG_GRC_PARAM_NO_MCP);\n\n\t \n\tstatus = qed_mcp_trace_get_data_info(p_hwfn,\n\t\t\t\t\t     p_ptt,\n\t\t\t\t\t     &trace_data_grc_addr,\n\t\t\t\t\t     &trace_data_size_bytes);\n\tif (status != DBG_STATUS_OK)\n\t\treturn status;\n\n\t \n\toffset += qed_dump_common_global_params(p_hwfn,\n\t\t\t\t\t\tp_ptt,\n\t\t\t\t\t\tdump_buf + offset, dump, 1);\n\toffset += qed_dump_str_param(dump_buf + offset,\n\t\t\t\t     dump, \"dump-type\", \"mcp-trace\");\n\n\t \n\tif (dump && use_mfw) {\n\t\thalted = !qed_mcp_halt(p_hwfn, p_ptt);\n\t\tif (!halted)\n\t\t\tDP_NOTICE(p_hwfn, \"MCP halt failed!\\n\");\n\t}\n\n\t \n\ttrace_data_size_dwords =\n\t    DIV_ROUND_UP(trace_data_size_bytes + sizeof(struct mcp_trace),\n\t\t\t BYTES_IN_DWORD);\n\n\t \n\toffset += qed_dump_section_hdr(dump_buf + offset,\n\t\t\t\t       dump, \"mcp_trace_data\", 1);\n\toffset += qed_dump_num_param(dump_buf + offset,\n\t\t\t\t     dump, \"size\", trace_data_size_dwords);\n\n\t \n\toffset += qed_grc_dump_addr_range(p_hwfn,\n\t\t\t\t\t  p_ptt,\n\t\t\t\t\t  dump_buf + offset,\n\t\t\t\t\t  dump,\n\t\t\t\t\t  BYTES_TO_DWORDS(trace_data_grc_addr),\n\t\t\t\t\t  trace_data_size_dwords, false,\n\t\t\t\t\t  SPLIT_TYPE_NONE, 0);\n\n\t \n\tif (halted && qed_mcp_resume(p_hwfn, p_ptt))\n\t\tDP_NOTICE(p_hwfn, \"Failed to resume MCP after halt!\\n\");\n\n\t \n\toffset += qed_dump_section_hdr(dump_buf + offset,\n\t\t\t\t       dump, \"mcp_trace_meta\", 1);\n\n\t \n\ttrace_meta_size_bytes =\n\t\tqed_grc_get_param(p_hwfn, DBG_GRC_PARAM_MCP_TRACE_META_SIZE);\n\tif ((!trace_meta_size_bytes || dump) && use_mfw)\n\t\tstatus = qed_mcp_trace_get_meta_info(p_hwfn,\n\t\t\t\t\t\t     p_ptt,\n\t\t\t\t\t\t     trace_data_size_bytes,\n\t\t\t\t\t\t     &running_bundle_id,\n\t\t\t\t\t\t     &trace_meta_offset_bytes,\n\t\t\t\t\t\t     &trace_meta_size_bytes);\n\tif (status == DBG_STATUS_OK)\n\t\ttrace_meta_size_dwords = BYTES_TO_DWORDS(trace_meta_size_bytes);\n\n\t \n\toffset += qed_dump_num_param(dump_buf + offset,\n\t\t\t\t     dump, \"size\", trace_meta_size_dwords);\n\n\t \n\tif (dump && trace_meta_size_dwords)\n\t\tstatus = qed_mcp_trace_read_meta(p_hwfn,\n\t\t\t\t\t\t p_ptt,\n\t\t\t\t\t\t trace_meta_offset_bytes,\n\t\t\t\t\t\t trace_meta_size_bytes,\n\t\t\t\t\t\t dump_buf + offset);\n\tif (status == DBG_STATUS_OK)\n\t\toffset += trace_meta_size_dwords;\n\n\t \n\toffset += qed_dump_last_section(dump_buf, offset, dump);\n\n\t*num_dumped_dwords = offset;\n\n\t \n\treturn use_mfw ? status : DBG_STATUS_NVRAM_GET_IMAGE_FAILED;\n}\n\n \nstatic enum dbg_status qed_reg_fifo_dump(struct qed_hwfn *p_hwfn,\n\t\t\t\t\t struct qed_ptt *p_ptt,\n\t\t\t\t\t u32 *dump_buf,\n\t\t\t\t\t bool dump, u32 *num_dumped_dwords)\n{\n\tu32 dwords_read, size_param_offset, offset = 0, addr, len;\n\tbool fifo_has_data;\n\n\t*num_dumped_dwords = 0;\n\n\t \n\toffset += qed_dump_common_global_params(p_hwfn,\n\t\t\t\t\t\tp_ptt,\n\t\t\t\t\t\tdump_buf + offset, dump, 1);\n\toffset += qed_dump_str_param(dump_buf + offset,\n\t\t\t\t     dump, \"dump-type\", \"reg-fifo\");\n\n\t \n\toffset += qed_dump_section_hdr(dump_buf + offset,\n\t\t\t\t       dump, \"reg_fifo_data\", 1);\n\tsize_param_offset = offset;\n\toffset += qed_dump_num_param(dump_buf + offset, dump, \"size\", 0);\n\n\tif (!dump) {\n\t\t \n\t\toffset += REG_FIFO_DEPTH_DWORDS;\n\t\tgoto out;\n\t}\n\n\tfifo_has_data = qed_rd(p_hwfn, p_ptt,\n\t\t\t       GRC_REG_TRACE_FIFO_VALID_DATA) > 0;\n\n\t \n\taddr = BYTES_TO_DWORDS(GRC_REG_TRACE_FIFO);\n\tlen = REG_FIFO_ELEMENT_DWORDS;\n\tfor (dwords_read = 0;\n\t     fifo_has_data && dwords_read < REG_FIFO_DEPTH_DWORDS;\n\t     dwords_read += REG_FIFO_ELEMENT_DWORDS) {\n\t\toffset += qed_grc_dump_addr_range(p_hwfn,\n\t\t\t\t\t\t  p_ptt,\n\t\t\t\t\t\t  dump_buf + offset,\n\t\t\t\t\t\t  true,\n\t\t\t\t\t\t  addr,\n\t\t\t\t\t\t  len,\n\t\t\t\t\t\t  true, SPLIT_TYPE_NONE,\n\t\t\t\t\t\t  0);\n\t\tfifo_has_data = qed_rd(p_hwfn, p_ptt,\n\t\t\t\t       GRC_REG_TRACE_FIFO_VALID_DATA) > 0;\n\t}\n\n\tqed_dump_num_param(dump_buf + size_param_offset, dump, \"size\",\n\t\t\t   dwords_read);\nout:\n\t \n\toffset += qed_dump_last_section(dump_buf, offset, dump);\n\n\t*num_dumped_dwords = offset;\n\n\treturn DBG_STATUS_OK;\n}\n\n \nstatic enum dbg_status qed_igu_fifo_dump(struct qed_hwfn *p_hwfn,\n\t\t\t\t\t struct qed_ptt *p_ptt,\n\t\t\t\t\t u32 *dump_buf,\n\t\t\t\t\t bool dump, u32 *num_dumped_dwords)\n{\n\tu32 dwords_read, size_param_offset, offset = 0, addr, len;\n\tbool fifo_has_data;\n\n\t*num_dumped_dwords = 0;\n\n\t \n\toffset += qed_dump_common_global_params(p_hwfn,\n\t\t\t\t\t\tp_ptt,\n\t\t\t\t\t\tdump_buf + offset, dump, 1);\n\toffset += qed_dump_str_param(dump_buf + offset,\n\t\t\t\t     dump, \"dump-type\", \"igu-fifo\");\n\n\t \n\toffset += qed_dump_section_hdr(dump_buf + offset,\n\t\t\t\t       dump, \"igu_fifo_data\", 1);\n\tsize_param_offset = offset;\n\toffset += qed_dump_num_param(dump_buf + offset, dump, \"size\", 0);\n\n\tif (!dump) {\n\t\t \n\t\toffset += IGU_FIFO_DEPTH_DWORDS;\n\t\tgoto out;\n\t}\n\n\tfifo_has_data = qed_rd(p_hwfn, p_ptt,\n\t\t\t       IGU_REG_ERROR_HANDLING_DATA_VALID) > 0;\n\n\t \n\taddr = BYTES_TO_DWORDS(IGU_REG_ERROR_HANDLING_MEMORY);\n\tlen = IGU_FIFO_ELEMENT_DWORDS;\n\tfor (dwords_read = 0;\n\t     fifo_has_data && dwords_read < IGU_FIFO_DEPTH_DWORDS;\n\t     dwords_read += IGU_FIFO_ELEMENT_DWORDS) {\n\t\toffset += qed_grc_dump_addr_range(p_hwfn,\n\t\t\t\t\t\t  p_ptt,\n\t\t\t\t\t\t  dump_buf + offset,\n\t\t\t\t\t\t  true,\n\t\t\t\t\t\t  addr,\n\t\t\t\t\t\t  len,\n\t\t\t\t\t\t  true, SPLIT_TYPE_NONE,\n\t\t\t\t\t\t  0);\n\t\tfifo_has_data = qed_rd(p_hwfn, p_ptt,\n\t\t\t\t       IGU_REG_ERROR_HANDLING_DATA_VALID) > 0;\n\t}\n\n\tqed_dump_num_param(dump_buf + size_param_offset, dump, \"size\",\n\t\t\t   dwords_read);\nout:\n\t \n\toffset += qed_dump_last_section(dump_buf, offset, dump);\n\n\t*num_dumped_dwords = offset;\n\n\treturn DBG_STATUS_OK;\n}\n\n \nstatic enum dbg_status qed_protection_override_dump(struct qed_hwfn *p_hwfn,\n\t\t\t\t\t\t    struct qed_ptt *p_ptt,\n\t\t\t\t\t\t    u32 *dump_buf,\n\t\t\t\t\t\t    bool dump,\n\t\t\t\t\t\t    u32 *num_dumped_dwords)\n{\n\tu32 size_param_offset, override_window_dwords, offset = 0, addr;\n\n\t*num_dumped_dwords = 0;\n\n\t \n\toffset += qed_dump_common_global_params(p_hwfn,\n\t\t\t\t\t\tp_ptt,\n\t\t\t\t\t\tdump_buf + offset, dump, 1);\n\toffset += qed_dump_str_param(dump_buf + offset,\n\t\t\t\t     dump, \"dump-type\", \"protection-override\");\n\n\t \n\toffset += qed_dump_section_hdr(dump_buf + offset,\n\t\t\t\t       dump, \"protection_override_data\", 1);\n\tsize_param_offset = offset;\n\toffset += qed_dump_num_param(dump_buf + offset, dump, \"size\", 0);\n\n\tif (!dump) {\n\t\toffset += PROTECTION_OVERRIDE_DEPTH_DWORDS;\n\t\tgoto out;\n\t}\n\n\t \n\toverride_window_dwords =\n\t\tqed_rd(p_hwfn, p_ptt, GRC_REG_NUMBER_VALID_OVERRIDE_WINDOW) *\n\t\tPROTECTION_OVERRIDE_ELEMENT_DWORDS;\n\tif (override_window_dwords) {\n\t\taddr = BYTES_TO_DWORDS(GRC_REG_PROTECTION_OVERRIDE_WINDOW);\n\t\toffset += qed_grc_dump_addr_range(p_hwfn,\n\t\t\t\t\t\t  p_ptt,\n\t\t\t\t\t\t  dump_buf + offset,\n\t\t\t\t\t\t  true,\n\t\t\t\t\t\t  addr,\n\t\t\t\t\t\t  override_window_dwords,\n\t\t\t\t\t\t  true, SPLIT_TYPE_NONE, 0);\n\t\tqed_dump_num_param(dump_buf + size_param_offset, dump, \"size\",\n\t\t\t\t   override_window_dwords);\n\t}\nout:\n\t \n\toffset += qed_dump_last_section(dump_buf, offset, dump);\n\n\t*num_dumped_dwords = offset;\n\n\treturn DBG_STATUS_OK;\n}\n\n \nstatic u32 qed_fw_asserts_dump(struct qed_hwfn *p_hwfn,\n\t\t\t       struct qed_ptt *p_ptt, u32 *dump_buf, bool dump)\n{\n\tstruct dbg_tools_data *dev_data = &p_hwfn->dbg_info;\n\tstruct fw_asserts_ram_section *asserts;\n\tchar storm_letter_str[2] = \"?\";\n\tstruct fw_info fw_info;\n\tu32 offset = 0;\n\tu8 storm_id;\n\n\t \n\toffset += qed_dump_common_global_params(p_hwfn,\n\t\t\t\t\t\tp_ptt,\n\t\t\t\t\t\tdump_buf + offset, dump, 1);\n\toffset += qed_dump_str_param(dump_buf + offset,\n\t\t\t\t     dump, \"dump-type\", \"fw-asserts\");\n\n\t \n\tfor (storm_id = 0; storm_id < MAX_DBG_STORMS; storm_id++) {\n\t\tu32 fw_asserts_section_addr, next_list_idx_addr, next_list_idx;\n\t\tstruct storm_defs *storm = &s_storm_defs[storm_id];\n\t\tu32 last_list_idx, addr;\n\n\t\tif (dev_data->block_in_reset[storm->sem_block_id])\n\t\t\tcontinue;\n\n\t\t \n\t\tqed_read_storm_fw_info(p_hwfn, p_ptt, storm_id, &fw_info);\n\n\t\tasserts = &fw_info.fw_asserts_section;\n\n\t\t \n\t\tstorm_letter_str[0] = storm->letter;\n\t\toffset += qed_dump_section_hdr(dump_buf + offset,\n\t\t\t\t\t       dump, \"fw_asserts\", 2);\n\t\toffset += qed_dump_str_param(dump_buf + offset,\n\t\t\t\t\t     dump, \"storm\", storm_letter_str);\n\t\toffset += qed_dump_num_param(dump_buf + offset,\n\t\t\t\t\t     dump,\n\t\t\t\t\t     \"size\",\n\t\t\t\t\t     asserts->list_element_dword_size);\n\n\t\t \n\t\tif (!dump) {\n\t\t\toffset += asserts->list_element_dword_size;\n\t\t\tcontinue;\n\t\t}\n\n\t\taddr = le16_to_cpu(asserts->section_ram_line_offset);\n\t\tfw_asserts_section_addr = storm->sem_fast_mem_addr +\n\t\t\t\t\t  SEM_FAST_REG_INT_RAM +\n\t\t\t\t\t  RAM_LINES_TO_BYTES(addr);\n\n\t\tnext_list_idx_addr = fw_asserts_section_addr +\n\t\t\tDWORDS_TO_BYTES(asserts->list_next_index_dword_offset);\n\t\tnext_list_idx = qed_rd(p_hwfn, p_ptt, next_list_idx_addr);\n\t\tlast_list_idx = (next_list_idx > 0 ?\n\t\t\t\t next_list_idx :\n\t\t\t\t asserts->list_num_elements) - 1;\n\t\taddr = BYTES_TO_DWORDS(fw_asserts_section_addr) +\n\t\t       asserts->list_dword_offset +\n\t\t       last_list_idx * asserts->list_element_dword_size;\n\t\toffset +=\n\t\t    qed_grc_dump_addr_range(p_hwfn, p_ptt,\n\t\t\t\t\t    dump_buf + offset,\n\t\t\t\t\t    dump, addr,\n\t\t\t\t\t    asserts->list_element_dword_size,\n\t\t\t\t\t\t  false, SPLIT_TYPE_NONE, 0);\n\t}\n\n\t \n\toffset += qed_dump_last_section(dump_buf, offset, dump);\n\n\treturn offset;\n}\n\n \nstatic u32 qed_ilt_dump_pages_range(u32 *dump_buf, u32 *given_offset,\n\t\t\t\t    bool *dump, u32 start_page_id,\n\t\t\t\t    u32 num_pages,\n\t\t\t\t    struct phys_mem_desc *ilt_pages,\n\t\t\t\t    bool dump_page_ids, u32 buf_size_in_dwords,\n\t\t\t\t    u32 *given_actual_dump_size_in_dwords)\n{\n\tu32 actual_dump_size_in_dwords = *given_actual_dump_size_in_dwords;\n\tu32 page_id, end_page_id, offset = *given_offset;\n\tstruct phys_mem_desc *mem_desc = NULL;\n\tbool continue_dump = *dump;\n\tu32 partial_page_size = 0;\n\n\tif (num_pages == 0)\n\t\treturn offset;\n\n\tend_page_id = start_page_id + num_pages - 1;\n\n\tfor (page_id = start_page_id; page_id <= end_page_id; page_id++) {\n\t\tmem_desc = &ilt_pages[page_id];\n\t\tif (!ilt_pages[page_id].virt_addr)\n\t\t\tcontinue;\n\n\t\tif (dump_page_ids) {\n\t\t\t \n\t\t\tif ((continue_dump) &&\n\t\t\t    (offset + 1 > buf_size_in_dwords)) {\n\t\t\t\tcontinue_dump = false;\n\t\t\t\tactual_dump_size_in_dwords = offset;\n\t\t\t}\n\t\t\tif (continue_dump)\n\t\t\t\t*(dump_buf + offset) = page_id;\n\t\t\toffset++;\n\t\t} else {\n\t\t\t \n\t\t\tif ((continue_dump) &&\n\t\t\t    (offset + BYTES_TO_DWORDS(mem_desc->size) >\n\t\t\t     buf_size_in_dwords)) {\n\t\t\t\tif (offset + BYTES_TO_DWORDS(mem_desc->size) >\n\t\t\t\t    buf_size_in_dwords) {\n\t\t\t\t\tpartial_page_size =\n\t\t\t\t\t    buf_size_in_dwords - offset;\n\t\t\t\t\tmemcpy(dump_buf + offset,\n\t\t\t\t\t       mem_desc->virt_addr,\n\t\t\t\t\t       partial_page_size);\n\t\t\t\t\tcontinue_dump = false;\n\t\t\t\t\tactual_dump_size_in_dwords =\n\t\t\t\t\t    offset + partial_page_size;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (continue_dump)\n\t\t\t\tmemcpy(dump_buf + offset,\n\t\t\t\t       mem_desc->virt_addr, mem_desc->size);\n\t\t\toffset += BYTES_TO_DWORDS(mem_desc->size);\n\t\t}\n\t}\n\n\t*dump = continue_dump;\n\t*given_offset = offset;\n\t*given_actual_dump_size_in_dwords = actual_dump_size_in_dwords;\n\n\treturn offset;\n}\n\n \nstatic u32 qed_ilt_dump_pages_section(struct qed_hwfn *p_hwfn,\n\t\t\t\t      u32 *dump_buf,\n\t\t\t\t      u32 *given_offset,\n\t\t\t\t      bool *dump,\n\t\t\t\t      u32 valid_conn_pf_pages,\n\t\t\t\t      u32 valid_conn_vf_pages,\n\t\t\t\t      struct phys_mem_desc *ilt_pages,\n\t\t\t\t      bool dump_page_ids,\n\t\t\t\t      u32 buf_size_in_dwords,\n\t\t\t\t      u32 *given_actual_dump_size_in_dwords)\n{\n\tstruct qed_ilt_client_cfg *clients = p_hwfn->p_cxt_mngr->clients;\n\tu32 pf_start_line, start_page_id, offset = *given_offset;\n\tu32 cdut_pf_init_pages, cdut_vf_init_pages;\n\tu32 cdut_pf_work_pages, cdut_vf_work_pages;\n\tu32 base_data_offset, size_param_offset;\n\tu32 src_pages;\n\tu32 section_header_and_param_size;\n\tu32 cdut_pf_pages, cdut_vf_pages;\n\tu32 actual_dump_size_in_dwords;\n\tbool continue_dump = *dump;\n\tbool update_size = *dump;\n\tconst char *section_name;\n\tu32 i;\n\n\tactual_dump_size_in_dwords = *given_actual_dump_size_in_dwords;\n\tsection_name = dump_page_ids ? \"ilt_page_ids\" : \"ilt_page_mem\";\n\tcdut_pf_init_pages = qed_get_cdut_num_pf_init_pages(p_hwfn);\n\tcdut_vf_init_pages = qed_get_cdut_num_vf_init_pages(p_hwfn);\n\tcdut_pf_work_pages = qed_get_cdut_num_pf_work_pages(p_hwfn);\n\tcdut_vf_work_pages = qed_get_cdut_num_vf_work_pages(p_hwfn);\n\tcdut_pf_pages = cdut_pf_init_pages + cdut_pf_work_pages;\n\tcdut_vf_pages = cdut_vf_init_pages + cdut_vf_work_pages;\n\tpf_start_line = p_hwfn->p_cxt_mngr->pf_start_line;\n\tsection_header_and_param_size = qed_dump_section_hdr(NULL,\n\t\t\t\t\t\t\t     false,\n\t\t\t\t\t\t\t     section_name,\n\t\t\t\t\t\t\t     1) +\n\tqed_dump_num_param(NULL, false, \"size\", 0);\n\n\tif ((continue_dump) &&\n\t    (offset + section_header_and_param_size > buf_size_in_dwords)) {\n\t\tcontinue_dump = false;\n\t\tupdate_size = false;\n\t\tactual_dump_size_in_dwords = offset;\n\t}\n\n\toffset += qed_dump_section_hdr(dump_buf + offset,\n\t\t\t\t       continue_dump, section_name, 1);\n\n\t \n\tsize_param_offset = offset;\n\toffset += qed_dump_num_param(dump_buf + offset,\n\t\t\t\t     continue_dump, \"size\", 0);\n\tbase_data_offset = offset;\n\n\t \n\tif (qed_grc_get_param(p_hwfn, DBG_GRC_PARAM_DUMP_ILT_CDUC)) {\n\t\t \n\t\tstart_page_id = clients[ILT_CLI_CDUC].first.val - pf_start_line;\n\t\tqed_ilt_dump_pages_range(dump_buf, &offset, &continue_dump,\n\t\t\t\t\t start_page_id, valid_conn_pf_pages,\n\t\t\t\t\t ilt_pages, dump_page_ids,\n\t\t\t\t\t buf_size_in_dwords,\n\t\t\t\t\t &actual_dump_size_in_dwords);\n\n\t\t \n\t\tstart_page_id += clients[ILT_CLI_CDUC].pf_total_lines;\n\t\tfor (i = 0; i < p_hwfn->p_cxt_mngr->vf_count;\n\t\t     i++, start_page_id += clients[ILT_CLI_CDUC].vf_total_lines)\n\t\t\tqed_ilt_dump_pages_range(dump_buf, &offset,\n\t\t\t\t\t\t &continue_dump, start_page_id,\n\t\t\t\t\t\t valid_conn_vf_pages,\n\t\t\t\t\t\t ilt_pages, dump_page_ids,\n\t\t\t\t\t\t buf_size_in_dwords,\n\t\t\t\t\t\t &actual_dump_size_in_dwords);\n\t}\n\n\t \n\tif (qed_grc_get_param(p_hwfn, DBG_GRC_PARAM_DUMP_ILT_CDUT)) {\n\t\t \n\t\tstart_page_id = clients[ILT_CLI_CDUT].first.val +\n\t\t    cdut_pf_init_pages - pf_start_line;\n\t\tqed_ilt_dump_pages_range(dump_buf, &offset, &continue_dump,\n\t\t\t\t\t start_page_id, cdut_pf_work_pages,\n\t\t\t\t\t ilt_pages, dump_page_ids,\n\t\t\t\t\t buf_size_in_dwords,\n\t\t\t\t\t &actual_dump_size_in_dwords);\n\n\t\t \n\t\tstart_page_id = clients[ILT_CLI_CDUT].first.val +\n\t\t    cdut_pf_pages + cdut_vf_init_pages - pf_start_line;\n\t\tfor (i = 0; i < p_hwfn->p_cxt_mngr->vf_count;\n\t\t     i++, start_page_id += cdut_vf_pages)\n\t\t\tqed_ilt_dump_pages_range(dump_buf, &offset,\n\t\t\t\t\t\t &continue_dump, start_page_id,\n\t\t\t\t\t\t cdut_vf_work_pages, ilt_pages,\n\t\t\t\t\t\t dump_page_ids,\n\t\t\t\t\t\t buf_size_in_dwords,\n\t\t\t\t\t\t &actual_dump_size_in_dwords);\n\t}\n\n\t \n\tif (clients[ILT_CLI_SRC].active) {\n\t\tstart_page_id = clients[ILT_CLI_SRC].first.val - pf_start_line;\n\t\tsrc_pages = clients[ILT_CLI_SRC].last.val -\n\t\t    clients[ILT_CLI_SRC].first.val + 1;\n\t\tqed_ilt_dump_pages_range(dump_buf, &offset, &continue_dump,\n\t\t\t\t\t start_page_id, src_pages, ilt_pages,\n\t\t\t\t\t dump_page_ids, buf_size_in_dwords,\n\t\t\t\t\t &actual_dump_size_in_dwords);\n\t}\n\n\t \n\tif (update_size) {\n\t\tu32 section_size = (*dump == continue_dump) ?\n\t\t    offset - base_data_offset :\n\t\t    actual_dump_size_in_dwords - base_data_offset;\n\t\tif (section_size > 0)\n\t\t\tqed_dump_num_param(dump_buf + size_param_offset,\n\t\t\t\t\t   *dump, \"size\", section_size);\n\t\telse if ((section_size == 0) && (*dump != continue_dump))\n\t\t\tactual_dump_size_in_dwords -=\n\t\t\t    section_header_and_param_size;\n\t}\n\n\t*dump = continue_dump;\n\t*given_offset = offset;\n\t*given_actual_dump_size_in_dwords = actual_dump_size_in_dwords;\n\n\treturn offset;\n}\n\n \nstatic u32\nqed_ilt_dump_dump_common_global_params(struct qed_hwfn *p_hwfn,\n\t\t\t\t       struct qed_ptt *p_ptt,\n\t\t\t\t       u32 *dump_buf,\n\t\t\t\t       bool dump,\n\t\t\t\t       u32 cduc_page_size,\n\t\t\t\t       u32 conn_ctx_size,\n\t\t\t\t       u32 cdut_page_size,\n\t\t\t\t       u32 *full_dump_size_param_offset,\n\t\t\t\t       u32 *actual_dump_size_param_offset)\n{\n\tstruct qed_ilt_client_cfg *clients = p_hwfn->p_cxt_mngr->clients;\n\tu32 offset = 0;\n\n\toffset += qed_dump_common_global_params(p_hwfn, p_ptt,\n\t\t\t\t\t\tdump_buf + offset,\n\t\t\t\t\t\tdump, 30);\n\toffset += qed_dump_str_param(dump_buf + offset,\n\t\t\t\t     dump,\n\t\t\t\t     \"dump-type\", \"ilt-dump\");\n\toffset += qed_dump_num_param(dump_buf + offset,\n\t\t\t\t     dump,\n\t\t\t\t     \"cduc-page-size\",\n\t\t\t\t     cduc_page_size);\n\toffset += qed_dump_num_param(dump_buf + offset,\n\t\t\t\t     dump,\n\t\t\t\t     \"cduc-first-page-id\",\n\t\t\t\t     clients[ILT_CLI_CDUC].first.val);\n\toffset += qed_dump_num_param(dump_buf + offset,\n\t\t\t\t     dump,\n\t\t\t\t     \"cduc-last-page-id\",\n\t\t\t\t     clients[ILT_CLI_CDUC].last.val);\n\toffset += qed_dump_num_param(dump_buf + offset,\n\t\t\t\t     dump,\n\t\t\t\t     \"cduc-num-pf-pages\",\n\t\t\t\t     clients[ILT_CLI_CDUC].pf_total_lines);\n\toffset += qed_dump_num_param(dump_buf + offset,\n\t\t\t\t     dump,\n\t\t\t\t     \"cduc-num-vf-pages\",\n\t\t\t\t     clients[ILT_CLI_CDUC].vf_total_lines);\n\toffset += qed_dump_num_param(dump_buf + offset,\n\t\t\t\t     dump,\n\t\t\t\t     \"max-conn-ctx-size\",\n\t\t\t\t     conn_ctx_size);\n\toffset += qed_dump_num_param(dump_buf + offset,\n\t\t\t\t     dump,\n\t\t\t\t     \"cdut-page-size\",\n\t\t\t\t     cdut_page_size);\n\toffset += qed_dump_num_param(dump_buf + offset,\n\t\t\t\t     dump,\n\t\t\t\t     \"cdut-first-page-id\",\n\t\t\t\t     clients[ILT_CLI_CDUT].first.val);\n\toffset += qed_dump_num_param(dump_buf + offset,\n\t\t\t\t     dump,\n\t\t\t\t     \"cdut-last-page-id\",\n\t\t\t\t     clients[ILT_CLI_CDUT].last.val);\n\toffset += qed_dump_num_param(dump_buf + offset,\n\t\t\t\t     dump,\n\t\t\t\t     \"cdut-num-pf-init-pages\",\n\t\t\t\t     qed_get_cdut_num_pf_init_pages(p_hwfn));\n\toffset += qed_dump_num_param(dump_buf + offset,\n\t\t\t\t     dump,\n\t\t\t\t     \"cdut-num-vf-init-pages\",\n\t\t\t\t     qed_get_cdut_num_vf_init_pages(p_hwfn));\n\toffset += qed_dump_num_param(dump_buf + offset,\n\t\t\t\t     dump,\n\t\t\t\t     \"cdut-num-pf-work-pages\",\n\t\t\t\t     qed_get_cdut_num_pf_work_pages(p_hwfn));\n\toffset += qed_dump_num_param(dump_buf + offset,\n\t\t\t\t     dump,\n\t\t\t\t     \"cdut-num-vf-work-pages\",\n\t\t\t\t     qed_get_cdut_num_vf_work_pages(p_hwfn));\n\toffset += qed_dump_num_param(dump_buf + offset,\n\t\t\t\t     dump,\n\t\t\t\t     \"max-task-ctx-size\",\n\t\t\t\t     p_hwfn->p_cxt_mngr->task_ctx_size);\n\toffset += qed_dump_num_param(dump_buf + offset,\n\t\t\t\t     dump,\n\t\t\t\t     \"first-vf-id-in-pf\",\n\t\t\t\t     p_hwfn->p_cxt_mngr->first_vf_in_pf);\n\toffset += qed_dump_num_param(dump_buf + offset,\n\t\t\t\t     dump,\n\t\t\t\t     \"num-vfs-in-pf\",\n\t\t\t\t     p_hwfn->p_cxt_mngr->vf_count);\n\toffset += qed_dump_num_param(dump_buf + offset,\n\t\t\t\t     dump,\n\t\t\t\t     \"ptr-size-bytes\",\n\t\t\t\t     sizeof(void *));\n\toffset += qed_dump_num_param(dump_buf + offset,\n\t\t\t\t     dump,\n\t\t\t\t     \"pf-start-line\",\n\t\t\t\t     p_hwfn->p_cxt_mngr->pf_start_line);\n\toffset += qed_dump_num_param(dump_buf + offset,\n\t\t\t\t     dump,\n\t\t\t\t     \"page-mem-desc-size-dwords\",\n\t\t\t\t     PAGE_MEM_DESC_SIZE_DWORDS);\n\toffset += qed_dump_num_param(dump_buf + offset,\n\t\t\t\t     dump,\n\t\t\t\t     \"ilt-shadow-size\",\n\t\t\t\t     p_hwfn->p_cxt_mngr->ilt_shadow_size);\n\n\t*full_dump_size_param_offset = offset;\n\n\toffset += qed_dump_num_param(dump_buf + offset,\n\t\t\t\t     dump, \"dump-size-full\", 0);\n\n\t*actual_dump_size_param_offset = offset;\n\n\toffset += qed_dump_num_param(dump_buf + offset,\n\t\t\t\t     dump,\n\t\t\t\t     \"dump-size-actual\", 0);\n\toffset += qed_dump_num_param(dump_buf + offset,\n\t\t\t\t     dump,\n\t\t\t\t     \"iscsi_task_pages\",\n\t\t\t\t     p_hwfn->p_cxt_mngr->iscsi_task_pages);\n\toffset += qed_dump_num_param(dump_buf + offset,\n\t\t\t\t     dump,\n\t\t\t\t     \"fcoe_task_pages\",\n\t\t\t\t     p_hwfn->p_cxt_mngr->fcoe_task_pages);\n\toffset += qed_dump_num_param(dump_buf + offset,\n\t\t\t\t     dump,\n\t\t\t\t     \"roce_task_pages\",\n\t\t\t\t     p_hwfn->p_cxt_mngr->roce_task_pages);\n\toffset += qed_dump_num_param(dump_buf + offset,\n\t\t\t\t     dump,\n\t\t\t\t     \"eth_task_pages\",\n\t\t\t\t     p_hwfn->p_cxt_mngr->eth_task_pages);\n\toffset += qed_dump_num_param(dump_buf + offset,\n\t\t\t\t      dump,\n\t\t\t\t      \"src-first-page-id\",\n\t\t\t\t      clients[ILT_CLI_SRC].first.val);\n\toffset += qed_dump_num_param(dump_buf + offset,\n\t\t\t\t     dump,\n\t\t\t\t     \"src-last-page-id\",\n\t\t\t\t     clients[ILT_CLI_SRC].last.val);\n\toffset += qed_dump_num_param(dump_buf + offset,\n\t\t\t\t     dump,\n\t\t\t\t     \"src-is-active\",\n\t\t\t\t     clients[ILT_CLI_SRC].active);\n\n\t \n\n\treturn offset;\n}\n\n \nstatic u32 qed_ilt_dump_dump_num_pf_cids(struct qed_hwfn *p_hwfn,\n\t\t\t\t\t u32 *dump_buf,\n\t\t\t\t\t bool dump, u32 *valid_conn_pf_cids)\n{\n\tu32 num_pf_cids = 0;\n\tu32 offset = 0;\n\tu8 conn_type;\n\n\toffset += qed_dump_section_hdr(dump_buf + offset,\n\t\t\t\t       dump, \"num_pf_cids_per_conn_type\", 1);\n\toffset += qed_dump_num_param(dump_buf + offset,\n\t\t\t\t     dump, \"size\", NUM_OF_CONNECTION_TYPES);\n\tfor (conn_type = 0, *valid_conn_pf_cids = 0;\n\t     conn_type < NUM_OF_CONNECTION_TYPES; conn_type++, offset++) {\n\t\tnum_pf_cids = p_hwfn->p_cxt_mngr->conn_cfg[conn_type].cid_count;\n\t\tif (dump)\n\t\t\t*(dump_buf + offset) = num_pf_cids;\n\t\t*valid_conn_pf_cids += num_pf_cids;\n\t}\n\n\treturn offset;\n}\n\n \nstatic u32 qed_ilt_dump_dump_num_vf_cids(struct qed_hwfn *p_hwfn,\n\t\t\t\t\t u32 *dump_buf,\n\t\t\t\t\t bool dump, u32 *valid_conn_vf_cids)\n{\n\tu32 num_vf_cids = 0;\n\tu32 offset = 0;\n\tu8 conn_type;\n\n\toffset += qed_dump_section_hdr(dump_buf + offset, dump,\n\t\t\t\t       \"num_vf_cids_per_conn_type\", 1);\n\toffset += qed_dump_num_param(dump_buf + offset,\n\t\t\t\t     dump, \"size\", NUM_OF_CONNECTION_TYPES);\n\tfor (conn_type = 0, *valid_conn_vf_cids = 0;\n\t     conn_type < NUM_OF_CONNECTION_TYPES; conn_type++, offset++) {\n\t\tnum_vf_cids =\n\t\t    p_hwfn->p_cxt_mngr->conn_cfg[conn_type].cids_per_vf;\n\t\tif (dump)\n\t\t\t*(dump_buf + offset) = num_vf_cids;\n\t\t*valid_conn_vf_cids += num_vf_cids;\n\t}\n\n\treturn offset;\n}\n\n \nstatic u32 qed_ilt_dump(struct qed_hwfn *p_hwfn,\n\t\t\tstruct qed_ptt *p_ptt,\n\t\t\tu32 *dump_buf, u32 buf_size_in_dwords, bool dump)\n{\n#if ((!defined VMWARE) && (!defined UEFI))\n\tstruct qed_ilt_client_cfg *clients = p_hwfn->p_cxt_mngr->clients;\n#endif\n\tu32 valid_conn_vf_cids = 0,\n\t    valid_conn_vf_pages, offset = 0, real_dumped_size = 0;\n\tu32 valid_conn_pf_cids = 0, valid_conn_pf_pages, num_pages;\n\tu32 num_cids_per_page, conn_ctx_size;\n\tu32 cduc_page_size, cdut_page_size;\n\tu32 actual_dump_size_in_dwords = 0;\n\tstruct phys_mem_desc *ilt_pages;\n\tu32 actul_dump_off = 0;\n\tu32 last_section_size;\n\tu32 full_dump_off = 0;\n\tu32 section_size = 0;\n\tbool continue_dump;\n\tu32 page_id;\n\n\tlast_section_size = qed_dump_last_section(NULL, 0, false);\n\tcduc_page_size = 1 <<\n\t    (clients[ILT_CLI_CDUC].p_size.val + PXP_ILT_PAGE_SIZE_NUM_BITS_MIN);\n\tcdut_page_size = 1 <<\n\t    (clients[ILT_CLI_CDUT].p_size.val + PXP_ILT_PAGE_SIZE_NUM_BITS_MIN);\n\tconn_ctx_size = p_hwfn->p_cxt_mngr->conn_ctx_size;\n\tnum_cids_per_page = (int)(cduc_page_size / conn_ctx_size);\n\tilt_pages = p_hwfn->p_cxt_mngr->ilt_shadow;\n\tcontinue_dump = dump;\n\n\t \n\tif (dump) {\n\t\tif (buf_size_in_dwords >= last_section_size) {\n\t\t\tbuf_size_in_dwords -= last_section_size;\n\t\t} else {\n\t\t\tcontinue_dump = false;\n\t\t\tactual_dump_size_in_dwords = offset;\n\t\t}\n\t}\n\n\t \n\n\t \n\tif (continue_dump) {\n\t\tsection_size =\n\t\t\tqed_ilt_dump_dump_common_global_params(p_hwfn,\n\t\t\t\t\t\t\t       p_ptt,\n\t\t\t\t\t\t\t       NULL,\n\t\t\t\t\t\t\t       false,\n\t\t\t\t\t\t\t       cduc_page_size,\n\t\t\t\t\t\t\t       conn_ctx_size,\n\t\t\t\t\t\t\t       cdut_page_size,\n\t\t\t\t\t\t\t       &full_dump_off,\n\t\t\t\t\t\t\t       &actul_dump_off);\n\t\tif (offset + section_size > buf_size_in_dwords) {\n\t\t\tcontinue_dump = false;\n\t\t\tactual_dump_size_in_dwords = offset;\n\t\t}\n\t}\n\n\toffset += qed_ilt_dump_dump_common_global_params(p_hwfn,\n\t\t\t\t\t\t\t p_ptt,\n\t\t\t\t\t\t\t dump_buf + offset,\n\t\t\t\t\t\t\t continue_dump,\n\t\t\t\t\t\t\t cduc_page_size,\n\t\t\t\t\t\t\t conn_ctx_size,\n\t\t\t\t\t\t\t cdut_page_size,\n\t\t\t\t\t\t\t &full_dump_off,\n\t\t\t\t\t\t\t &actul_dump_off);\n\n\t \n\tif (continue_dump) {\n\t\tsection_size =\n\t\t\tqed_ilt_dump_dump_num_pf_cids(p_hwfn,\n\t\t\t\t\t\t      NULL,\n\t\t\t\t\t\t      false,\n\t\t\t\t\t\t      &valid_conn_pf_cids);\n\t\tif (offset + section_size > buf_size_in_dwords) {\n\t\t\tcontinue_dump = false;\n\t\t\tactual_dump_size_in_dwords = offset;\n\t\t}\n\t}\n\n\toffset += qed_ilt_dump_dump_num_pf_cids(p_hwfn,\n\t\t\t\t\t\tdump_buf + offset,\n\t\t\t\t\t\tcontinue_dump,\n\t\t\t\t\t\t&valid_conn_pf_cids);\n\n\t \n\tif (continue_dump) {\n\t\tsection_size =\n\t\t\tqed_ilt_dump_dump_num_vf_cids(p_hwfn,\n\t\t\t\t\t\t      NULL,\n\t\t\t\t\t\t      false,\n\t\t\t\t\t\t      &valid_conn_vf_cids);\n\t\tif (offset + section_size > buf_size_in_dwords) {\n\t\t\tcontinue_dump = false;\n\t\t\tactual_dump_size_in_dwords = offset;\n\t\t}\n\t}\n\n\toffset += qed_ilt_dump_dump_num_vf_cids(p_hwfn,\n\t\t\t\t\t\tdump_buf + offset,\n\t\t\t\t\t\tcontinue_dump,\n\t\t\t\t\t\t&valid_conn_vf_cids);\n\n\t \n\tnum_pages = p_hwfn->p_cxt_mngr->ilt_shadow_size;\n\n\t \n\tif (continue_dump) {\n\t\tsection_size = qed_dump_section_hdr(NULL,\n\t\t\t\t\t\t    false,\n\t\t\t\t\t\t    \"ilt_page_desc\",\n\t\t\t\t\t\t    1) +\n\t\t    qed_dump_num_param(NULL,\n\t\t\t\t       false,\n\t\t\t\t       \"size\",\n\t\t\t\t       num_pages * PAGE_MEM_DESC_SIZE_DWORDS);\n\t\tif (offset + section_size > buf_size_in_dwords) {\n\t\t\tcontinue_dump = false;\n\t\t\tactual_dump_size_in_dwords = offset;\n\t\t}\n\t}\n\n\toffset += qed_dump_section_hdr(dump_buf + offset,\n\t\t\t\t       continue_dump, \"ilt_page_desc\", 1);\n\toffset += qed_dump_num_param(dump_buf + offset,\n\t\t\t\t     continue_dump,\n\t\t\t\t     \"size\",\n\t\t\t\t     num_pages * PAGE_MEM_DESC_SIZE_DWORDS);\n\n\t \n\tif (continue_dump) {\n\t\tfor (page_id = 0; page_id < num_pages;\n\t\t     page_id++, offset += PAGE_MEM_DESC_SIZE_DWORDS) {\n\t\t\tif (continue_dump &&\n\t\t\t    (offset + PAGE_MEM_DESC_SIZE_DWORDS <=\n\t\t\t     buf_size_in_dwords)) {\n\t\t\t\tmemcpy(dump_buf + offset,\n\t\t\t\t       &ilt_pages[page_id],\n\t\t\t\t       DWORDS_TO_BYTES\n\t\t\t\t       (PAGE_MEM_DESC_SIZE_DWORDS));\n\t\t\t} else {\n\t\t\t\tif (continue_dump) {\n\t\t\t\t\tcontinue_dump = false;\n\t\t\t\t\tactual_dump_size_in_dwords = offset;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\toffset += num_pages * PAGE_MEM_DESC_SIZE_DWORDS;\n\t}\n\n\tvalid_conn_pf_pages = DIV_ROUND_UP(valid_conn_pf_cids,\n\t\t\t\t\t   num_cids_per_page);\n\tvalid_conn_vf_pages = DIV_ROUND_UP(valid_conn_vf_cids,\n\t\t\t\t\t   num_cids_per_page);\n\n\t \n\tqed_ilt_dump_pages_section(p_hwfn, dump_buf, &offset, &continue_dump,\n\t\t\t\t   valid_conn_pf_pages, valid_conn_vf_pages,\n\t\t\t\t   ilt_pages, true, buf_size_in_dwords,\n\t\t\t\t   &actual_dump_size_in_dwords);\n\n\t \n\tqed_ilt_dump_pages_section(p_hwfn, dump_buf, &offset, &continue_dump,\n\t\t\t\t   valid_conn_pf_pages, valid_conn_vf_pages,\n\t\t\t\t   ilt_pages, false, buf_size_in_dwords,\n\t\t\t\t   &actual_dump_size_in_dwords);\n\n\treal_dumped_size =\n\t    (continue_dump == dump) ? offset : actual_dump_size_in_dwords;\n\tqed_dump_num_param(dump_buf + full_dump_off, dump,\n\t\t\t   \"full-dump-size\", offset + last_section_size);\n\tqed_dump_num_param(dump_buf + actul_dump_off,\n\t\t\t   dump,\n\t\t\t   \"actual-dump-size\",\n\t\t\t   real_dumped_size + last_section_size);\n\n\t \n\treal_dumped_size += qed_dump_last_section(dump_buf,\n\t\t\t\t\t\t  real_dumped_size, dump);\n\n\treturn real_dumped_size;\n}\n\n \n\nenum dbg_status qed_dbg_set_bin_ptr(struct qed_hwfn *p_hwfn,\n\t\t\t\t    const u8 * const bin_ptr)\n{\n\tstruct bin_buffer_hdr *buf_hdrs = (struct bin_buffer_hdr *)bin_ptr;\n\tu8 buf_id;\n\n\t \n\tfor (buf_id = 0; buf_id < MAX_BIN_DBG_BUFFER_TYPE; buf_id++)\n\t\tqed_set_dbg_bin_buf(p_hwfn,\n\t\t\t\t    buf_id,\n\t\t\t\t    (u32 *)(bin_ptr + buf_hdrs[buf_id].offset),\n\t\t\t\t    buf_hdrs[buf_id].length);\n\n\treturn DBG_STATUS_OK;\n}\n\nstatic enum dbg_status qed_dbg_set_app_ver(u32 ver)\n{\n\tif (ver < TOOLS_VERSION)\n\t\treturn DBG_STATUS_UNSUPPORTED_APP_VERSION;\n\n\ts_app_ver = ver;\n\n\treturn DBG_STATUS_OK;\n}\n\nbool qed_read_fw_info(struct qed_hwfn *p_hwfn,\n\t\t      struct qed_ptt *p_ptt, struct fw_info *fw_info)\n{\n\tstruct dbg_tools_data *dev_data = &p_hwfn->dbg_info;\n\tu8 storm_id;\n\n\tfor (storm_id = 0; storm_id < MAX_DBG_STORMS; storm_id++) {\n\t\tstruct storm_defs *storm = &s_storm_defs[storm_id];\n\n\t\t \n\t\tif (dev_data->block_in_reset[storm->sem_block_id])\n\t\t\tcontinue;\n\n\t\t \n\t\tqed_read_storm_fw_info(p_hwfn, p_ptt, storm_id, fw_info);\n\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nenum dbg_status qed_dbg_grc_config(struct qed_hwfn *p_hwfn,\n\t\t\t\t   enum dbg_grc_params grc_param, u32 val)\n{\n\tstruct dbg_tools_data *dev_data = &p_hwfn->dbg_info;\n\tenum dbg_status status;\n\tint i;\n\n\tDP_VERBOSE(p_hwfn,\n\t\t   QED_MSG_DEBUG,\n\t\t   \"dbg_grc_config: paramId = %d, val = %d\\n\", grc_param, val);\n\n\tstatus = qed_dbg_dev_init(p_hwfn);\n\tif (status != DBG_STATUS_OK)\n\t\treturn status;\n\n\t \n\tqed_dbg_grc_init_params(p_hwfn);\n\n\tif (grc_param >= MAX_DBG_GRC_PARAMS)\n\t\treturn DBG_STATUS_INVALID_ARGS;\n\tif (val < s_grc_param_defs[grc_param].min ||\n\t    val > s_grc_param_defs[grc_param].max)\n\t\treturn DBG_STATUS_INVALID_ARGS;\n\n\tif (s_grc_param_defs[grc_param].is_preset) {\n\t\t \n\n\t\t \n\t\tif (!val)\n\t\t\treturn DBG_STATUS_INVALID_ARGS;\n\n\t\t \n\t\tfor (i = 0; i < MAX_DBG_GRC_PARAMS; i++) {\n\t\t\tstruct grc_param_defs *defs = &s_grc_param_defs[i];\n\t\t\tu32 preset_val;\n\t\t\t \n\t\t\tif (defs->is_persistent)\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tif (grc_param == DBG_GRC_PARAM_EXCLUDE_ALL)\n\t\t\t\tpreset_val =\n\t\t\t\t    defs->exclude_all_preset_val;\n\t\t\telse if (grc_param == DBG_GRC_PARAM_CRASH)\n\t\t\t\tpreset_val =\n\t\t\t\t    defs->crash_preset_val[dev_data->chip_id];\n\t\t\telse\n\t\t\t\treturn DBG_STATUS_INVALID_ARGS;\n\n\t\t\tqed_grc_set_param(p_hwfn, i, preset_val);\n\t\t}\n\t} else {\n\t\t \n\t\tqed_grc_set_param(p_hwfn, grc_param, val);\n\t}\n\n\treturn DBG_STATUS_OK;\n}\n\n \nvoid qed_dbg_grc_set_params_default(struct qed_hwfn *p_hwfn)\n{\n\tstruct dbg_tools_data *dev_data = &p_hwfn->dbg_info;\n\tu32 i;\n\n\tfor (i = 0; i < MAX_DBG_GRC_PARAMS; i++)\n\t\tif (!s_grc_param_defs[i].is_persistent)\n\t\t\tdev_data->grc.param_val[i] =\n\t\t\t    s_grc_param_defs[i].default_val[dev_data->chip_id];\n}\n\nenum dbg_status qed_dbg_grc_get_dump_buf_size(struct qed_hwfn *p_hwfn,\n\t\t\t\t\t      struct qed_ptt *p_ptt,\n\t\t\t\t\t      u32 *buf_size)\n{\n\tenum dbg_status status = qed_dbg_dev_init(p_hwfn);\n\n\t*buf_size = 0;\n\n\tif (status != DBG_STATUS_OK)\n\t\treturn status;\n\n\tif (!p_hwfn->dbg_arrays[BIN_BUF_DBG_MODE_TREE].ptr ||\n\t    !p_hwfn->dbg_arrays[BIN_BUF_DBG_DUMP_REG].ptr ||\n\t    !p_hwfn->dbg_arrays[BIN_BUF_DBG_DUMP_MEM].ptr ||\n\t    !p_hwfn->dbg_arrays[BIN_BUF_DBG_ATTN_BLOCKS].ptr ||\n\t    !p_hwfn->dbg_arrays[BIN_BUF_DBG_ATTN_REGS].ptr)\n\t\treturn DBG_STATUS_DBG_ARRAY_NOT_SET;\n\n\treturn qed_grc_dump(p_hwfn, p_ptt, NULL, false, buf_size);\n}\n\nenum dbg_status qed_dbg_grc_dump(struct qed_hwfn *p_hwfn,\n\t\t\t\t struct qed_ptt *p_ptt,\n\t\t\t\t u32 *dump_buf,\n\t\t\t\t u32 buf_size_in_dwords,\n\t\t\t\t u32 *num_dumped_dwords)\n{\n\tu32 needed_buf_size_in_dwords;\n\tenum dbg_status status;\n\n\t*num_dumped_dwords = 0;\n\n\tstatus = qed_dbg_grc_get_dump_buf_size(p_hwfn,\n\t\t\t\t\t       p_ptt,\n\t\t\t\t\t       &needed_buf_size_in_dwords);\n\tif (status != DBG_STATUS_OK)\n\t\treturn status;\n\n\tif (buf_size_in_dwords < needed_buf_size_in_dwords)\n\t\treturn DBG_STATUS_DUMP_BUF_TOO_SMALL;\n\n\t \n\tqed_static_asserts();\n\n\t \n\tstatus = qed_grc_dump(p_hwfn, p_ptt, dump_buf, true, num_dumped_dwords);\n\n\t \n\tqed_dbg_grc_set_params_default(p_hwfn);\n\n\treturn status;\n}\n\nenum dbg_status qed_dbg_idle_chk_get_dump_buf_size(struct qed_hwfn *p_hwfn,\n\t\t\t\t\t\t   struct qed_ptt *p_ptt,\n\t\t\t\t\t\t   u32 *buf_size)\n{\n\tstruct dbg_tools_data *dev_data = &p_hwfn->dbg_info;\n\tstruct idle_chk_data *idle_chk = &dev_data->idle_chk;\n\tenum dbg_status status;\n\n\t*buf_size = 0;\n\n\tstatus = qed_dbg_dev_init(p_hwfn);\n\tif (status != DBG_STATUS_OK)\n\t\treturn status;\n\n\tif (!p_hwfn->dbg_arrays[BIN_BUF_DBG_MODE_TREE].ptr ||\n\t    !p_hwfn->dbg_arrays[BIN_BUF_DBG_IDLE_CHK_REGS].ptr ||\n\t    !p_hwfn->dbg_arrays[BIN_BUF_DBG_IDLE_CHK_IMMS].ptr ||\n\t    !p_hwfn->dbg_arrays[BIN_BUF_DBG_IDLE_CHK_RULES].ptr)\n\t\treturn DBG_STATUS_DBG_ARRAY_NOT_SET;\n\n\tif (!idle_chk->buf_size_set) {\n\t\tidle_chk->buf_size = qed_idle_chk_dump(p_hwfn,\n\t\t\t\t\t\t       p_ptt, NULL, false);\n\t\tidle_chk->buf_size_set = true;\n\t}\n\n\t*buf_size = idle_chk->buf_size;\n\n\treturn DBG_STATUS_OK;\n}\n\nenum dbg_status qed_dbg_idle_chk_dump(struct qed_hwfn *p_hwfn,\n\t\t\t\t      struct qed_ptt *p_ptt,\n\t\t\t\t      u32 *dump_buf,\n\t\t\t\t      u32 buf_size_in_dwords,\n\t\t\t\t      u32 *num_dumped_dwords)\n{\n\tu32 needed_buf_size_in_dwords;\n\tenum dbg_status status;\n\n\t*num_dumped_dwords = 0;\n\n\tstatus = qed_dbg_idle_chk_get_dump_buf_size(p_hwfn,\n\t\t\t\t\t\t    p_ptt,\n\t\t\t\t\t\t    &needed_buf_size_in_dwords);\n\tif (status != DBG_STATUS_OK)\n\t\treturn status;\n\n\tif (buf_size_in_dwords < needed_buf_size_in_dwords)\n\t\treturn DBG_STATUS_DUMP_BUF_TOO_SMALL;\n\n\t \n\tqed_grc_unreset_blocks(p_hwfn, p_ptt, true);\n\tqed_update_blocks_reset_state(p_hwfn, p_ptt);\n\n\t \n\t*num_dumped_dwords = qed_idle_chk_dump(p_hwfn, p_ptt, dump_buf, true);\n\n\t \n\tqed_dbg_grc_set_params_default(p_hwfn);\n\n\treturn DBG_STATUS_OK;\n}\n\nenum dbg_status qed_dbg_mcp_trace_get_dump_buf_size(struct qed_hwfn *p_hwfn,\n\t\t\t\t\t\t    struct qed_ptt *p_ptt,\n\t\t\t\t\t\t    u32 *buf_size)\n{\n\tenum dbg_status status = qed_dbg_dev_init(p_hwfn);\n\n\t*buf_size = 0;\n\n\tif (status != DBG_STATUS_OK)\n\t\treturn status;\n\n\treturn qed_mcp_trace_dump(p_hwfn, p_ptt, NULL, false, buf_size);\n}\n\nenum dbg_status qed_dbg_mcp_trace_dump(struct qed_hwfn *p_hwfn,\n\t\t\t\t       struct qed_ptt *p_ptt,\n\t\t\t\t       u32 *dump_buf,\n\t\t\t\t       u32 buf_size_in_dwords,\n\t\t\t\t       u32 *num_dumped_dwords)\n{\n\tu32 needed_buf_size_in_dwords;\n\tenum dbg_status status;\n\n\tstatus =\n\t\tqed_dbg_mcp_trace_get_dump_buf_size(p_hwfn,\n\t\t\t\t\t\t    p_ptt,\n\t\t\t\t\t\t    &needed_buf_size_in_dwords);\n\tif (status != DBG_STATUS_OK && status !=\n\t    DBG_STATUS_NVRAM_GET_IMAGE_FAILED)\n\t\treturn status;\n\n\tif (buf_size_in_dwords < needed_buf_size_in_dwords)\n\t\treturn DBG_STATUS_DUMP_BUF_TOO_SMALL;\n\n\t \n\tqed_update_blocks_reset_state(p_hwfn, p_ptt);\n\n\t \n\tstatus = qed_mcp_trace_dump(p_hwfn,\n\t\t\t\t    p_ptt, dump_buf, true, num_dumped_dwords);\n\n\t \n\tqed_dbg_grc_set_params_default(p_hwfn);\n\n\treturn status;\n}\n\nenum dbg_status qed_dbg_reg_fifo_get_dump_buf_size(struct qed_hwfn *p_hwfn,\n\t\t\t\t\t\t   struct qed_ptt *p_ptt,\n\t\t\t\t\t\t   u32 *buf_size)\n{\n\tenum dbg_status status = qed_dbg_dev_init(p_hwfn);\n\n\t*buf_size = 0;\n\n\tif (status != DBG_STATUS_OK)\n\t\treturn status;\n\n\treturn qed_reg_fifo_dump(p_hwfn, p_ptt, NULL, false, buf_size);\n}\n\nenum dbg_status qed_dbg_reg_fifo_dump(struct qed_hwfn *p_hwfn,\n\t\t\t\t      struct qed_ptt *p_ptt,\n\t\t\t\t      u32 *dump_buf,\n\t\t\t\t      u32 buf_size_in_dwords,\n\t\t\t\t      u32 *num_dumped_dwords)\n{\n\tu32 needed_buf_size_in_dwords;\n\tenum dbg_status status;\n\n\t*num_dumped_dwords = 0;\n\n\tstatus = qed_dbg_reg_fifo_get_dump_buf_size(p_hwfn,\n\t\t\t\t\t\t    p_ptt,\n\t\t\t\t\t\t    &needed_buf_size_in_dwords);\n\tif (status != DBG_STATUS_OK)\n\t\treturn status;\n\n\tif (buf_size_in_dwords < needed_buf_size_in_dwords)\n\t\treturn DBG_STATUS_DUMP_BUF_TOO_SMALL;\n\n\t \n\tqed_update_blocks_reset_state(p_hwfn, p_ptt);\n\n\tstatus = qed_reg_fifo_dump(p_hwfn,\n\t\t\t\t   p_ptt, dump_buf, true, num_dumped_dwords);\n\n\t \n\tqed_dbg_grc_set_params_default(p_hwfn);\n\n\treturn status;\n}\n\nenum dbg_status qed_dbg_igu_fifo_get_dump_buf_size(struct qed_hwfn *p_hwfn,\n\t\t\t\t\t\t   struct qed_ptt *p_ptt,\n\t\t\t\t\t\t   u32 *buf_size)\n{\n\tenum dbg_status status = qed_dbg_dev_init(p_hwfn);\n\n\t*buf_size = 0;\n\n\tif (status != DBG_STATUS_OK)\n\t\treturn status;\n\n\treturn qed_igu_fifo_dump(p_hwfn, p_ptt, NULL, false, buf_size);\n}\n\nenum dbg_status qed_dbg_igu_fifo_dump(struct qed_hwfn *p_hwfn,\n\t\t\t\t      struct qed_ptt *p_ptt,\n\t\t\t\t      u32 *dump_buf,\n\t\t\t\t      u32 buf_size_in_dwords,\n\t\t\t\t      u32 *num_dumped_dwords)\n{\n\tu32 needed_buf_size_in_dwords;\n\tenum dbg_status status;\n\n\t*num_dumped_dwords = 0;\n\n\tstatus = qed_dbg_igu_fifo_get_dump_buf_size(p_hwfn,\n\t\t\t\t\t\t    p_ptt,\n\t\t\t\t\t\t    &needed_buf_size_in_dwords);\n\tif (status != DBG_STATUS_OK)\n\t\treturn status;\n\n\tif (buf_size_in_dwords < needed_buf_size_in_dwords)\n\t\treturn DBG_STATUS_DUMP_BUF_TOO_SMALL;\n\n\t \n\tqed_update_blocks_reset_state(p_hwfn, p_ptt);\n\n\tstatus = qed_igu_fifo_dump(p_hwfn,\n\t\t\t\t   p_ptt, dump_buf, true, num_dumped_dwords);\n\t \n\tqed_dbg_grc_set_params_default(p_hwfn);\n\n\treturn status;\n}\n\nenum dbg_status\nqed_dbg_protection_override_get_dump_buf_size(struct qed_hwfn *p_hwfn,\n\t\t\t\t\t      struct qed_ptt *p_ptt,\n\t\t\t\t\t      u32 *buf_size)\n{\n\tenum dbg_status status = qed_dbg_dev_init(p_hwfn);\n\n\t*buf_size = 0;\n\n\tif (status != DBG_STATUS_OK)\n\t\treturn status;\n\n\treturn qed_protection_override_dump(p_hwfn,\n\t\t\t\t\t    p_ptt, NULL, false, buf_size);\n}\n\nenum dbg_status qed_dbg_protection_override_dump(struct qed_hwfn *p_hwfn,\n\t\t\t\t\t\t struct qed_ptt *p_ptt,\n\t\t\t\t\t\t u32 *dump_buf,\n\t\t\t\t\t\t u32 buf_size_in_dwords,\n\t\t\t\t\t\t u32 *num_dumped_dwords)\n{\n\tu32 needed_buf_size_in_dwords, *p_size = &needed_buf_size_in_dwords;\n\tenum dbg_status status;\n\n\t*num_dumped_dwords = 0;\n\n\tstatus =\n\t\tqed_dbg_protection_override_get_dump_buf_size(p_hwfn,\n\t\t\t\t\t\t\t      p_ptt,\n\t\t\t\t\t\t\t      p_size);\n\tif (status != DBG_STATUS_OK)\n\t\treturn status;\n\n\tif (buf_size_in_dwords < needed_buf_size_in_dwords)\n\t\treturn DBG_STATUS_DUMP_BUF_TOO_SMALL;\n\n\t \n\tqed_update_blocks_reset_state(p_hwfn, p_ptt);\n\n\tstatus = qed_protection_override_dump(p_hwfn,\n\t\t\t\t\t      p_ptt,\n\t\t\t\t\t      dump_buf,\n\t\t\t\t\t      true, num_dumped_dwords);\n\n\t \n\tqed_dbg_grc_set_params_default(p_hwfn);\n\n\treturn status;\n}\n\nenum dbg_status qed_dbg_fw_asserts_get_dump_buf_size(struct qed_hwfn *p_hwfn,\n\t\t\t\t\t\t     struct qed_ptt *p_ptt,\n\t\t\t\t\t\t     u32 *buf_size)\n{\n\tenum dbg_status status = qed_dbg_dev_init(p_hwfn);\n\n\t*buf_size = 0;\n\n\tif (status != DBG_STATUS_OK)\n\t\treturn status;\n\n\t \n\tqed_update_blocks_reset_state(p_hwfn, p_ptt);\n\n\t*buf_size = qed_fw_asserts_dump(p_hwfn, p_ptt, NULL, false);\n\n\treturn DBG_STATUS_OK;\n}\n\nenum dbg_status qed_dbg_fw_asserts_dump(struct qed_hwfn *p_hwfn,\n\t\t\t\t\tstruct qed_ptt *p_ptt,\n\t\t\t\t\tu32 *dump_buf,\n\t\t\t\t\tu32 buf_size_in_dwords,\n\t\t\t\t\tu32 *num_dumped_dwords)\n{\n\tu32 needed_buf_size_in_dwords, *p_size = &needed_buf_size_in_dwords;\n\tenum dbg_status status;\n\n\t*num_dumped_dwords = 0;\n\n\tstatus =\n\t\tqed_dbg_fw_asserts_get_dump_buf_size(p_hwfn,\n\t\t\t\t\t\t     p_ptt,\n\t\t\t\t\t\t     p_size);\n\tif (status != DBG_STATUS_OK)\n\t\treturn status;\n\n\tif (buf_size_in_dwords < needed_buf_size_in_dwords)\n\t\treturn DBG_STATUS_DUMP_BUF_TOO_SMALL;\n\n\t*num_dumped_dwords = qed_fw_asserts_dump(p_hwfn, p_ptt, dump_buf, true);\n\n\t \n\tqed_dbg_grc_set_params_default(p_hwfn);\n\n\treturn DBG_STATUS_OK;\n}\n\nstatic enum dbg_status qed_dbg_ilt_get_dump_buf_size(struct qed_hwfn *p_hwfn,\n\t\t\t\t\t\t     struct qed_ptt *p_ptt,\n\t\t\t\t\t\t     u32 *buf_size)\n{\n\tenum dbg_status status = qed_dbg_dev_init(p_hwfn);\n\n\t*buf_size = 0;\n\n\tif (status != DBG_STATUS_OK)\n\t\treturn status;\n\n\t*buf_size = qed_ilt_dump(p_hwfn, p_ptt, NULL, 0, false);\n\n\treturn DBG_STATUS_OK;\n}\n\nstatic enum dbg_status qed_dbg_ilt_dump(struct qed_hwfn *p_hwfn,\n\t\t\t\t\tstruct qed_ptt *p_ptt,\n\t\t\t\t\tu32 *dump_buf,\n\t\t\t\t\tu32 buf_size_in_dwords,\n\t\t\t\t\tu32 *num_dumped_dwords)\n{\n\t*num_dumped_dwords = qed_ilt_dump(p_hwfn,\n\t\t\t\t\t  p_ptt,\n\t\t\t\t\t  dump_buf, buf_size_in_dwords, true);\n\n\t \n\tqed_dbg_grc_set_params_default(p_hwfn);\n\n\treturn DBG_STATUS_OK;\n}\n\nenum dbg_status qed_dbg_read_attn(struct qed_hwfn *p_hwfn,\n\t\t\t\t  struct qed_ptt *p_ptt,\n\t\t\t\t  enum block_id block_id,\n\t\t\t\t  enum dbg_attn_type attn_type,\n\t\t\t\t  bool clear_status,\n\t\t\t\t  struct dbg_attn_block_result *results)\n{\n\tenum dbg_status status = qed_dbg_dev_init(p_hwfn);\n\tu8 reg_idx, num_attn_regs, num_result_regs = 0;\n\tconst struct dbg_attn_reg *attn_reg_arr;\n\n\tif (status != DBG_STATUS_OK)\n\t\treturn status;\n\n\tif (!p_hwfn->dbg_arrays[BIN_BUF_DBG_MODE_TREE].ptr ||\n\t    !p_hwfn->dbg_arrays[BIN_BUF_DBG_ATTN_BLOCKS].ptr ||\n\t    !p_hwfn->dbg_arrays[BIN_BUF_DBG_ATTN_REGS].ptr)\n\t\treturn DBG_STATUS_DBG_ARRAY_NOT_SET;\n\n\tattn_reg_arr = qed_get_block_attn_regs(p_hwfn,\n\t\t\t\t\t       block_id,\n\t\t\t\t\t       attn_type, &num_attn_regs);\n\n\tfor (reg_idx = 0; reg_idx < num_attn_regs; reg_idx++) {\n\t\tconst struct dbg_attn_reg *reg_data = &attn_reg_arr[reg_idx];\n\t\tstruct dbg_attn_reg_result *reg_result;\n\t\tu32 sts_addr, sts_val;\n\t\tu16 modes_buf_offset;\n\t\tbool eval_mode;\n\n\t\t \n\t\teval_mode = GET_FIELD(reg_data->mode.data,\n\t\t\t\t      DBG_MODE_HDR_EVAL_MODE) > 0;\n\t\tmodes_buf_offset = GET_FIELD(reg_data->mode.data,\n\t\t\t\t\t     DBG_MODE_HDR_MODES_BUF_OFFSET);\n\t\tif (eval_mode && !qed_is_mode_match(p_hwfn, &modes_buf_offset))\n\t\t\tcontinue;\n\n\t\t \n\t\tsts_addr = DWORDS_TO_BYTES(clear_status ?\n\t\t\t\t\t   reg_data->sts_clr_address :\n\t\t\t\t\t   GET_FIELD(reg_data->data,\n\t\t\t\t\t\t     DBG_ATTN_REG_STS_ADDRESS));\n\t\tsts_val = qed_rd(p_hwfn, p_ptt, sts_addr);\n\t\tif (!sts_val)\n\t\t\tcontinue;\n\n\t\t \n\t\treg_result = &results->reg_results[num_result_regs];\n\t\tSET_FIELD(reg_result->data,\n\t\t\t  DBG_ATTN_REG_RESULT_STS_ADDRESS, sts_addr);\n\t\tSET_FIELD(reg_result->data,\n\t\t\t  DBG_ATTN_REG_RESULT_NUM_REG_ATTN,\n\t\t\t  GET_FIELD(reg_data->data, DBG_ATTN_REG_NUM_REG_ATTN));\n\t\treg_result->block_attn_offset = reg_data->block_attn_offset;\n\t\treg_result->sts_val = sts_val;\n\t\treg_result->mask_val = qed_rd(p_hwfn,\n\t\t\t\t\t      p_ptt,\n\t\t\t\t\t      DWORDS_TO_BYTES\n\t\t\t\t\t      (reg_data->mask_address));\n\t\tnum_result_regs++;\n\t}\n\n\tresults->block_id = (u8)block_id;\n\tresults->names_offset =\n\t    qed_get_block_attn_data(p_hwfn, block_id, attn_type)->names_offset;\n\tSET_FIELD(results->data, DBG_ATTN_BLOCK_RESULT_ATTN_TYPE, attn_type);\n\tSET_FIELD(results->data,\n\t\t  DBG_ATTN_BLOCK_RESULT_NUM_REGS, num_result_regs);\n\n\treturn DBG_STATUS_OK;\n}\n\n \n\n \nstruct reg_fifo_element {\n\tu64 data;\n#define REG_FIFO_ELEMENT_ADDRESS_SHIFT\t\t0\n#define REG_FIFO_ELEMENT_ADDRESS_MASK\t\t0x7fffff\n#define REG_FIFO_ELEMENT_ACCESS_SHIFT\t\t23\n#define REG_FIFO_ELEMENT_ACCESS_MASK\t\t0x1\n#define REG_FIFO_ELEMENT_PF_SHIFT\t\t24\n#define REG_FIFO_ELEMENT_PF_MASK\t\t0xf\n#define REG_FIFO_ELEMENT_VF_SHIFT\t\t28\n#define REG_FIFO_ELEMENT_VF_MASK\t\t0xff\n#define REG_FIFO_ELEMENT_PORT_SHIFT\t\t36\n#define REG_FIFO_ELEMENT_PORT_MASK\t\t0x3\n#define REG_FIFO_ELEMENT_PRIVILEGE_SHIFT\t38\n#define REG_FIFO_ELEMENT_PRIVILEGE_MASK\t\t0x3\n#define REG_FIFO_ELEMENT_PROTECTION_SHIFT\t40\n#define REG_FIFO_ELEMENT_PROTECTION_MASK\t0x7\n#define REG_FIFO_ELEMENT_MASTER_SHIFT\t\t43\n#define REG_FIFO_ELEMENT_MASTER_MASK\t\t0xf\n#define REG_FIFO_ELEMENT_ERROR_SHIFT\t\t47\n#define REG_FIFO_ELEMENT_ERROR_MASK\t\t0x1f\n};\n\n \nstruct reg_fifo_err {\n\tu32 err_code;\n\tconst char *err_msg;\n};\n\n \nstruct igu_fifo_element {\n\tu32 dword0;\n#define IGU_FIFO_ELEMENT_DWORD0_FID_SHIFT\t\t0\n#define IGU_FIFO_ELEMENT_DWORD0_FID_MASK\t\t0xff\n#define IGU_FIFO_ELEMENT_DWORD0_IS_PF_SHIFT\t\t8\n#define IGU_FIFO_ELEMENT_DWORD0_IS_PF_MASK\t\t0x1\n#define IGU_FIFO_ELEMENT_DWORD0_SOURCE_SHIFT\t\t9\n#define IGU_FIFO_ELEMENT_DWORD0_SOURCE_MASK\t\t0xf\n#define IGU_FIFO_ELEMENT_DWORD0_ERR_TYPE_SHIFT\t\t13\n#define IGU_FIFO_ELEMENT_DWORD0_ERR_TYPE_MASK\t\t0xf\n#define IGU_FIFO_ELEMENT_DWORD0_CMD_ADDR_SHIFT\t\t17\n#define IGU_FIFO_ELEMENT_DWORD0_CMD_ADDR_MASK\t\t0x7fff\n\tu32 dword1;\n\tu32 dword2;\n#define IGU_FIFO_ELEMENT_DWORD12_IS_WR_CMD_SHIFT\t0\n#define IGU_FIFO_ELEMENT_DWORD12_IS_WR_CMD_MASK\t\t0x1\n#define IGU_FIFO_ELEMENT_DWORD12_WR_DATA_SHIFT\t\t1\n#define IGU_FIFO_ELEMENT_DWORD12_WR_DATA_MASK\t\t0xffffffff\n\tu32 reserved;\n};\n\nstruct igu_fifo_wr_data {\n\tu32 data;\n#define IGU_FIFO_WR_DATA_PROD_CONS_SHIFT\t\t0\n#define IGU_FIFO_WR_DATA_PROD_CONS_MASK\t\t\t0xffffff\n#define IGU_FIFO_WR_DATA_UPDATE_FLAG_SHIFT\t\t24\n#define IGU_FIFO_WR_DATA_UPDATE_FLAG_MASK\t\t0x1\n#define IGU_FIFO_WR_DATA_EN_DIS_INT_FOR_SB_SHIFT\t25\n#define IGU_FIFO_WR_DATA_EN_DIS_INT_FOR_SB_MASK\t\t0x3\n#define IGU_FIFO_WR_DATA_SEGMENT_SHIFT\t\t\t27\n#define IGU_FIFO_WR_DATA_SEGMENT_MASK\t\t\t0x1\n#define IGU_FIFO_WR_DATA_TIMER_MASK_SHIFT\t\t28\n#define IGU_FIFO_WR_DATA_TIMER_MASK_MASK\t\t0x1\n#define IGU_FIFO_WR_DATA_CMD_TYPE_SHIFT\t\t\t31\n#define IGU_FIFO_WR_DATA_CMD_TYPE_MASK\t\t\t0x1\n};\n\nstruct igu_fifo_cleanup_wr_data {\n\tu32 data;\n#define IGU_FIFO_CLEANUP_WR_DATA_RESERVED_SHIFT\t\t0\n#define IGU_FIFO_CLEANUP_WR_DATA_RESERVED_MASK\t\t0x7ffffff\n#define IGU_FIFO_CLEANUP_WR_DATA_CLEANUP_VAL_SHIFT\t27\n#define IGU_FIFO_CLEANUP_WR_DATA_CLEANUP_VAL_MASK\t0x1\n#define IGU_FIFO_CLEANUP_WR_DATA_CLEANUP_TYPE_SHIFT\t28\n#define IGU_FIFO_CLEANUP_WR_DATA_CLEANUP_TYPE_MASK\t0x7\n#define IGU_FIFO_CLEANUP_WR_DATA_CMD_TYPE_SHIFT\t\t31\n#define IGU_FIFO_CLEANUP_WR_DATA_CMD_TYPE_MASK\t\t0x1\n};\n\n \nstruct protection_override_element {\n\tu64 data;\n#define PROTECTION_OVERRIDE_ELEMENT_ADDRESS_SHIFT\t\t0\n#define PROTECTION_OVERRIDE_ELEMENT_ADDRESS_MASK\t\t0x7fffff\n#define PROTECTION_OVERRIDE_ELEMENT_WINDOW_SIZE_SHIFT\t\t23\n#define PROTECTION_OVERRIDE_ELEMENT_WINDOW_SIZE_MASK\t\t0xffffff\n#define PROTECTION_OVERRIDE_ELEMENT_READ_SHIFT\t\t\t47\n#define PROTECTION_OVERRIDE_ELEMENT_READ_MASK\t\t\t0x1\n#define PROTECTION_OVERRIDE_ELEMENT_WRITE_SHIFT\t\t\t48\n#define PROTECTION_OVERRIDE_ELEMENT_WRITE_MASK\t\t\t0x1\n#define PROTECTION_OVERRIDE_ELEMENT_READ_PROTECTION_SHIFT\t49\n#define PROTECTION_OVERRIDE_ELEMENT_READ_PROTECTION_MASK\t0x7\n#define PROTECTION_OVERRIDE_ELEMENT_WRITE_PROTECTION_SHIFT\t52\n#define PROTECTION_OVERRIDE_ELEMENT_WRITE_PROTECTION_MASK\t0x7\n};\n\nenum igu_fifo_sources {\n\tIGU_SRC_PXP0,\n\tIGU_SRC_PXP1,\n\tIGU_SRC_PXP2,\n\tIGU_SRC_PXP3,\n\tIGU_SRC_PXP4,\n\tIGU_SRC_PXP5,\n\tIGU_SRC_PXP6,\n\tIGU_SRC_PXP7,\n\tIGU_SRC_CAU,\n\tIGU_SRC_ATTN,\n\tIGU_SRC_GRC\n};\n\nenum igu_fifo_addr_types {\n\tIGU_ADDR_TYPE_MSIX_MEM,\n\tIGU_ADDR_TYPE_WRITE_PBA,\n\tIGU_ADDR_TYPE_WRITE_INT_ACK,\n\tIGU_ADDR_TYPE_WRITE_ATTN_BITS,\n\tIGU_ADDR_TYPE_READ_INT,\n\tIGU_ADDR_TYPE_WRITE_PROD_UPDATE,\n\tIGU_ADDR_TYPE_RESERVED\n};\n\nstruct igu_fifo_addr_data {\n\tu16 start_addr;\n\tu16 end_addr;\n\tchar *desc;\n\tchar *vf_desc;\n\tenum igu_fifo_addr_types type;\n};\n\n \n\n#define MAX_MSG_LEN\t\t\t\t1024\n\n#define MCP_TRACE_MAX_MODULE_LEN\t\t8\n#define MCP_TRACE_FORMAT_MAX_PARAMS\t\t3\n#define MCP_TRACE_FORMAT_PARAM_WIDTH \\\n\t(MCP_TRACE_FORMAT_P2_SIZE_OFFSET - MCP_TRACE_FORMAT_P1_SIZE_OFFSET)\n\n#define REG_FIFO_ELEMENT_ADDR_FACTOR\t\t4\n#define REG_FIFO_ELEMENT_IS_PF_VF_VAL\t\t127\n\n#define PROTECTION_OVERRIDE_ELEMENT_ADDR_FACTOR\t4\n\n \n\n \nstatic const char * const s_status_str[] = {\n\t \n\t\"Operation completed successfully\",\n\n\t \n\t\"Debug application version wasn't set\",\n\n\t \n\t\"Unsupported debug application version\",\n\n\t \n\t\"The debug block wasn't reset since the last recording\",\n\n\t \n\t\"Invalid arguments\",\n\n\t \n\t\"The debug output was already set\",\n\n\t \n\t\"Invalid PCI buffer size\",\n\n\t \n\t\"PCI buffer allocation failed\",\n\n\t \n\t\"A PCI buffer wasn't allocated\",\n\n\t \n\t\"The filter/trigger constraint dword offsets are not enabled for recording\",\n\t \n\t\"No matching framing mode\",\n\n\t \n\t\"Error reading from VFC\",\n\n\t \n\t\"The Storm was already enabled\",\n\n\t \n\t\"The specified Storm wasn't enabled\",\n\n\t \n\t\"The block was already enabled\",\n\n\t \n\t\"The specified block wasn't enabled\",\n\n\t \n\t\"No input was enabled for recording\",\n\n\t \n\t\"Filters and triggers are not allowed in E4 256-bit mode\",\n\n\t \n\t\"The filter was already enabled\",\n\n\t \n\t\"The trigger was already enabled\",\n\n\t \n\t\"The trigger wasn't enabled\",\n\n\t \n\t\"A constraint can be added only after a filter was enabled or a trigger state was added\",\n\n\t \n\t\"Cannot add more than 3 trigger states\",\n\n\t \n\t\"Cannot add more than 4 constraints per filter or trigger state\",\n\n\t \n\t\"The recording wasn't started\",\n\n\t \n\t\"A trigger was configured, but it didn't trigger\",\n\n\t \n\t\"No data was recorded\",\n\n\t \n\t\"Dump buffer is too small\",\n\n\t \n\t\"Dumped data is not aligned to chunks\",\n\n\t \n\t\"Unknown chip\",\n\n\t \n\t\"Failed allocating virtual memory\",\n\n\t \n\t\"The input block is in reset\",\n\n\t \n\t\"Invalid MCP trace signature found in NVRAM\",\n\n\t \n\t\"Invalid bundle ID found in NVRAM\",\n\n\t \n\t\"Failed getting NVRAM image\",\n\n\t \n\t\"NVRAM image is not dword-aligned\",\n\n\t \n\t\"Failed reading from NVRAM\",\n\n\t \n\t\"Idle check parsing failed\",\n\n\t \n\t\"MCP Trace data is corrupt\",\n\n\t \n\t\"Dump doesn't contain meta data - it must be provided in image file\",\n\n\t \n\t\"Failed to halt MCP\",\n\n\t \n\t\"Failed to resume MCP after halt\",\n\n\t \n\t\"\",\n\n\t \n\t\"Failed to empty SEMI sync FIFO\",\n\n\t \n\t\"IGU FIFO data is corrupt\",\n\n\t \n\t\"MCP failed to mask parities\",\n\n\t \n\t\"FW Asserts parsing failed\",\n\n\t \n\t\"GRC FIFO data is corrupt\",\n\n\t \n\t\"Protection Override data is corrupt\",\n\n\t \n\t\"Debug arrays were not set (when using binary files, dbg_set_bin_ptr must be called)\",\n\n\t \n\t\"\",\n\n\t \n\t\"Non-matching debug lines - in E4, all lines must be of the same type (either 128b or 256b)\",\n\n\t \n\t\"Insufficient HW IDs. Try to record less Storms/blocks\",\n\n\t \n\t\"The debug bus is in use\",\n\n\t \n\t\"The storm debug mode is not supported in the current chip\",\n\n\t \n\t\"Other engine is supported only in BB\",\n\n\t \n\t\"The configured filter mode requires a single Storm/block input\",\n\n\t \n\t\"The configured filter mode requires that all the constraints of a single trigger state will be defined on a single Storm/block input\",\n\n\t \n\t\"When triggering on Storm data, the Storm to trigger on must be specified\",\n\n\t \n\t\"Failed to request MDUMP2 Offsize\",\n\n\t \n\t\"Expected CRC (part of the MDUMP2 data) is different than the calculated CRC over that data\",\n\n\t \n\t\"Invalid Signature found at start of MDUMP2\",\n\n\t \n\t\"Invalid Log Size of MDUMP2\",\n\n\t \n\t\"Invalid Log Header of MDUMP2\",\n\n\t \n\t\"Invalid Log Data of MDUMP2\",\n\n\t \n\t\"Could not extract number of ports from regval buf of MDUMP2\",\n\n\t \n\t\"Could not extract MFW (link) status from regval buf of MDUMP2\",\n\n\t \n\t\"Could not display linkdump of MDUMP2\",\n\n\t \n\t\"Could not read PHY CFG of MDUMP2\",\n\n\t \n\t\"Could not read PLL Mode of MDUMP2\",\n\n\t \n\t\"Could not read TSCF/TSCE Lane Regs of MDUMP2\",\n\n\t \n\t\"Could not allocate MDUMP2 reg-val internal buffer\"\n};\n\n \nstatic const char * const s_idle_chk_severity_str[] = {\n\t\"Error\",\n\t\"Error if no traffic\",\n\t\"Warning\"\n};\n\n \nstatic const char * const s_mcp_trace_level_str[] = {\n\t\"ERROR\",\n\t\"TRACE\",\n\t\"DEBUG\"\n};\n\n \nstatic const char * const s_access_strs[] = {\n\t\"read\",\n\t\"write\"\n};\n\n \nstatic const char * const s_privilege_strs[] = {\n\t\"VF\",\n\t\"PDA\",\n\t\"HV\",\n\t\"UA\"\n};\n\n \nstatic const char * const s_protection_strs[] = {\n\t\"(default)\",\n\t\"(default)\",\n\t\"(default)\",\n\t\"(default)\",\n\t\"override VF\",\n\t\"override PDA\",\n\t\"override HV\",\n\t\"override UA\"\n};\n\n \nstatic const char * const s_master_strs[] = {\n\t\"???\",\n\t\"pxp\",\n\t\"mcp\",\n\t\"msdm\",\n\t\"psdm\",\n\t\"ysdm\",\n\t\"usdm\",\n\t\"tsdm\",\n\t\"xsdm\",\n\t\"dbu\",\n\t\"dmae\",\n\t\"jdap\",\n\t\"???\",\n\t\"???\",\n\t\"???\",\n\t\"???\"\n};\n\n \nstatic struct reg_fifo_err s_reg_fifo_errors[] = {\n\t{1, \"grc timeout\"},\n\t{2, \"address doesn't belong to any block\"},\n\t{4, \"reserved address in block or write to read-only address\"},\n\t{8, \"privilege/protection mismatch\"},\n\t{16, \"path isolation error\"},\n\t{17, \"RSL error\"}\n};\n\n \nstatic const char * const s_igu_fifo_source_strs[] = {\n\t\"TSTORM\",\n\t\"MSTORM\",\n\t\"USTORM\",\n\t\"XSTORM\",\n\t\"YSTORM\",\n\t\"PSTORM\",\n\t\"PCIE\",\n\t\"NIG_QM_PBF\",\n\t\"CAU\",\n\t\"ATTN\",\n\t\"GRC\",\n};\n\n \nstatic const char * const s_igu_fifo_error_strs[] = {\n\t\"no error\",\n\t\"length error\",\n\t\"function disabled\",\n\t\"VF sent command to attention address\",\n\t\"host sent prod update command\",\n\t\"read of during interrupt register while in MIMD mode\",\n\t\"access to PXP BAR reserved address\",\n\t\"producer update command to attention index\",\n\t\"unknown error\",\n\t\"SB index not valid\",\n\t\"SB relative index and FID not found\",\n\t\"FID not match\",\n\t\"command with error flag asserted (PCI error or CAU discard)\",\n\t\"VF sent cleanup and RF cleanup is disabled\",\n\t\"cleanup command on type bigger than 4\"\n};\n\n \nstatic const struct igu_fifo_addr_data s_igu_fifo_addr_data[] = {\n\t{0x0, 0x101, \"MSI-X Memory\", NULL,\n\t IGU_ADDR_TYPE_MSIX_MEM},\n\t{0x102, 0x1ff, \"reserved\", NULL,\n\t IGU_ADDR_TYPE_RESERVED},\n\t{0x200, 0x200, \"Write PBA[0:63]\", NULL,\n\t IGU_ADDR_TYPE_WRITE_PBA},\n\t{0x201, 0x201, \"Write PBA[64:127]\", \"reserved\",\n\t IGU_ADDR_TYPE_WRITE_PBA},\n\t{0x202, 0x202, \"Write PBA[128]\", \"reserved\",\n\t IGU_ADDR_TYPE_WRITE_PBA},\n\t{0x203, 0x3ff, \"reserved\", NULL,\n\t IGU_ADDR_TYPE_RESERVED},\n\t{0x400, 0x5ef, \"Write interrupt acknowledgment\", NULL,\n\t IGU_ADDR_TYPE_WRITE_INT_ACK},\n\t{0x5f0, 0x5f0, \"Attention bits update\", NULL,\n\t IGU_ADDR_TYPE_WRITE_ATTN_BITS},\n\t{0x5f1, 0x5f1, \"Attention bits set\", NULL,\n\t IGU_ADDR_TYPE_WRITE_ATTN_BITS},\n\t{0x5f2, 0x5f2, \"Attention bits clear\", NULL,\n\t IGU_ADDR_TYPE_WRITE_ATTN_BITS},\n\t{0x5f3, 0x5f3, \"Read interrupt 0:63 with mask\", NULL,\n\t IGU_ADDR_TYPE_READ_INT},\n\t{0x5f4, 0x5f4, \"Read interrupt 0:31 with mask\", NULL,\n\t IGU_ADDR_TYPE_READ_INT},\n\t{0x5f5, 0x5f5, \"Read interrupt 32:63 with mask\", NULL,\n\t IGU_ADDR_TYPE_READ_INT},\n\t{0x5f6, 0x5f6, \"Read interrupt 0:63 without mask\", NULL,\n\t IGU_ADDR_TYPE_READ_INT},\n\t{0x5f7, 0x5ff, \"reserved\", NULL,\n\t IGU_ADDR_TYPE_RESERVED},\n\t{0x600, 0x7ff, \"Producer update\", NULL,\n\t IGU_ADDR_TYPE_WRITE_PROD_UPDATE}\n};\n\n \n\n \nstatic char s_temp_buf[MAX_MSG_LEN];\n\n \n\nstatic void qed_user_static_asserts(void)\n{\n}\n\nstatic u32 qed_cyclic_add(u32 a, u32 b, u32 size)\n{\n\treturn (a + b) % size;\n}\n\nstatic u32 qed_cyclic_sub(u32 a, u32 b, u32 size)\n{\n\treturn (size + a - b) % size;\n}\n\n \nstatic u32 qed_read_from_cyclic_buf(void *buf,\n\t\t\t\t    u32 *offset,\n\t\t\t\t    u32 buf_size, u8 num_bytes_to_read)\n{\n\tu8 i, *val_ptr, *bytes_buf = (u8 *)buf;\n\tu32 val = 0;\n\n\tval_ptr = (u8 *)&val;\n\n\t \n\tfor (i = 0; i < num_bytes_to_read; i++) {\n\t\tval_ptr[i] = bytes_buf[*offset];\n\t\t*offset = qed_cyclic_add(*offset, 1, buf_size);\n\t}\n\n\treturn val;\n}\n\n \nstatic u8 qed_read_byte_from_buf(void *buf, u32 *offset)\n{\n\treturn ((u8 *)buf)[(*offset)++];\n}\n\n \nstatic u32 qed_read_dword_from_buf(void *buf, u32 *offset)\n{\n\tu32 dword_val = *(u32 *)&((u8 *)buf)[*offset];\n\n\t*offset += 4;\n\n\treturn dword_val;\n}\n\n \nstatic void qed_read_str_from_buf(void *buf, u32 *offset, u32 size, char *dest)\n{\n\tconst char *source_str = &((const char *)buf)[*offset];\n\n\tstrncpy(dest, source_str, size);\n\tdest[size - 1] = '\\0';\n\t*offset += size;\n}\n\n \nstatic char *qed_get_buf_ptr(void *buf, u32 offset)\n{\n\treturn buf ? (char *)buf + offset : s_temp_buf;\n}\n\n \nstatic u32 qed_read_param(u32 *dump_buf,\n\t\t\t  const char **param_name,\n\t\t\t  const char **param_str_val, u32 *param_num_val)\n{\n\tchar *char_buf = (char *)dump_buf;\n\tsize_t offset = 0;\n\n\t \n\t*param_name = char_buf;\n\toffset += strlen(*param_name) + 1;\n\n\t \n\tif (*(char_buf + offset++)) {\n\t\t \n\t\t*param_str_val = char_buf + offset;\n\t\t*param_num_val = 0;\n\t\toffset += strlen(*param_str_val) + 1;\n\t\tif (offset & 0x3)\n\t\t\toffset += (4 - (offset & 0x3));\n\t} else {\n\t\t \n\t\t*param_str_val = NULL;\n\t\tif (offset & 0x3)\n\t\t\toffset += (4 - (offset & 0x3));\n\t\t*param_num_val = *(u32 *)(char_buf + offset);\n\t\toffset += 4;\n\t}\n\n\treturn (u32)offset / 4;\n}\n\n \nstatic u32 qed_read_section_hdr(u32 *dump_buf,\n\t\t\t\tconst char **section_name,\n\t\t\t\tu32 *num_section_params)\n{\n\tconst char *param_str_val;\n\n\treturn qed_read_param(dump_buf,\n\t\t\t      section_name, &param_str_val, num_section_params);\n}\n\n \nstatic u32 qed_print_section_params(u32 *dump_buf,\n\t\t\t\t    u32 num_section_params,\n\t\t\t\t    char *results_buf, u32 *num_chars_printed)\n{\n\tu32 i, dump_offset = 0, results_offset = 0;\n\n\tfor (i = 0; i < num_section_params; i++) {\n\t\tconst char *param_name, *param_str_val;\n\t\tu32 param_num_val = 0;\n\n\t\tdump_offset += qed_read_param(dump_buf + dump_offset,\n\t\t\t\t\t      &param_name,\n\t\t\t\t\t      &param_str_val, &param_num_val);\n\n\t\tif (param_str_val)\n\t\t\tresults_offset +=\n\t\t\t\tsprintf(qed_get_buf_ptr(results_buf,\n\t\t\t\t\t\t\tresults_offset),\n\t\t\t\t\t\"%s: %s\\n\", param_name, param_str_val);\n\t\telse if (strcmp(param_name, \"fw-timestamp\"))\n\t\t\tresults_offset +=\n\t\t\t\tsprintf(qed_get_buf_ptr(results_buf,\n\t\t\t\t\t\t\tresults_offset),\n\t\t\t\t\t\"%s: %d\\n\", param_name, param_num_val);\n\t}\n\n\tresults_offset += sprintf(qed_get_buf_ptr(results_buf, results_offset),\n\t\t\t\t  \"\\n\");\n\n\t*num_chars_printed = results_offset;\n\n\treturn dump_offset;\n}\n\n \nstatic const char *qed_dbg_get_block_name(struct qed_hwfn *p_hwfn,\n\t\t\t\t\t  enum block_id block_id)\n{\n\tconst struct dbg_block_user *block =\n\t    (const struct dbg_block_user *)\n\t    p_hwfn->dbg_arrays[BIN_BUF_DBG_BLOCKS_USER_DATA].ptr + block_id;\n\n\treturn (const char *)block->name;\n}\n\nstatic struct dbg_tools_user_data *qed_dbg_get_user_data(struct qed_hwfn\n\t\t\t\t\t\t\t *p_hwfn)\n{\n\treturn (struct dbg_tools_user_data *)p_hwfn->dbg_user_info;\n}\n\n \nstatic u32 qed_parse_idle_chk_dump_rules(struct qed_hwfn *p_hwfn,\n\t\t\t\t\t u32 *dump_buf,\n\t\t\t\t\t u32 *dump_buf_end,\n\t\t\t\t\t u32 num_rules,\n\t\t\t\t\t bool print_fw_idle_chk,\n\t\t\t\t\t char *results_buf,\n\t\t\t\t\t u32 *num_errors, u32 *num_warnings)\n{\n\t \n\tu32 results_offset = 0;\n\n\tu32 rule_idx;\n\tu16 i, j;\n\n\t*num_errors = 0;\n\t*num_warnings = 0;\n\n\t \n\tfor (rule_idx = 0; rule_idx < num_rules && dump_buf < dump_buf_end;\n\t     rule_idx++) {\n\t\tconst struct dbg_idle_chk_rule_parsing_data *rule_parsing_data;\n\t\tstruct dbg_idle_chk_result_hdr *hdr;\n\t\tconst char *parsing_str, *lsi_msg;\n\t\tu32 parsing_str_offset;\n\t\tbool has_fw_msg;\n\t\tu8 curr_reg_id;\n\n\t\thdr = (struct dbg_idle_chk_result_hdr *)dump_buf;\n\t\trule_parsing_data =\n\t\t    (const struct dbg_idle_chk_rule_parsing_data *)\n\t\t    p_hwfn->dbg_arrays[BIN_BUF_DBG_IDLE_CHK_PARSING_DATA].ptr +\n\t\t    hdr->rule_id;\n\t\tparsing_str_offset =\n\t\t    GET_FIELD(rule_parsing_data->data,\n\t\t\t      DBG_IDLE_CHK_RULE_PARSING_DATA_STR_OFFSET);\n\t\thas_fw_msg =\n\t\t    GET_FIELD(rule_parsing_data->data,\n\t\t\t      DBG_IDLE_CHK_RULE_PARSING_DATA_HAS_FW_MSG) > 0;\n\t\tparsing_str = (const char *)\n\t\t    p_hwfn->dbg_arrays[BIN_BUF_DBG_PARSING_STRINGS].ptr +\n\t\t    parsing_str_offset;\n\t\tlsi_msg = parsing_str;\n\t\tcurr_reg_id = 0;\n\n\t\tif (hdr->severity >= MAX_DBG_IDLE_CHK_SEVERITY_TYPES)\n\t\t\treturn 0;\n\n\t\t \n\t\tdump_buf += BYTES_TO_DWORDS(sizeof(*hdr));\n\n\t\t \n\t\tif (hdr->severity == IDLE_CHK_SEVERITY_ERROR ||\n\t\t    hdr->severity == IDLE_CHK_SEVERITY_ERROR_NO_TRAFFIC)\n\t\t\t(*num_errors)++;\n\t\telse\n\t\t\t(*num_warnings)++;\n\n\t\t \n\t\tresults_offset +=\n\t\t    sprintf(qed_get_buf_ptr(results_buf,\n\t\t\t\t\t    results_offset), \"%s: \",\n\t\t\t    s_idle_chk_severity_str[hdr->severity]);\n\n\t\t \n\t\tif (has_fw_msg)\n\t\t\tparsing_str += strlen(parsing_str) + 1;\n\t\tresults_offset +=\n\t\t    sprintf(qed_get_buf_ptr(results_buf,\n\t\t\t\t\t    results_offset), \"%s.\",\n\t\t\t    has_fw_msg &&\n\t\t\t    print_fw_idle_chk ? parsing_str : lsi_msg);\n\t\tparsing_str += strlen(parsing_str) + 1;\n\n\t\t \n\t\tresults_offset +=\n\t\t    sprintf(qed_get_buf_ptr(results_buf,\n\t\t\t\t\t    results_offset), \" Registers:\");\n\t\tfor (i = 0;\n\t\t     i < hdr->num_dumped_cond_regs + hdr->num_dumped_info_regs;\n\t\t     i++) {\n\t\t\tstruct dbg_idle_chk_result_reg_hdr *reg_hdr;\n\t\t\tbool is_mem;\n\t\t\tu8 reg_id;\n\n\t\t\treg_hdr =\n\t\t\t\t(struct dbg_idle_chk_result_reg_hdr *)dump_buf;\n\t\t\tis_mem = GET_FIELD(reg_hdr->data,\n\t\t\t\t\t   DBG_IDLE_CHK_RESULT_REG_HDR_IS_MEM);\n\t\t\treg_id = GET_FIELD(reg_hdr->data,\n\t\t\t\t\t   DBG_IDLE_CHK_RESULT_REG_HDR_REG_ID);\n\n\t\t\t \n\t\t\tdump_buf += BYTES_TO_DWORDS(sizeof(*reg_hdr));\n\n\t\t\t \n\t\t\tfor (; reg_id > curr_reg_id; curr_reg_id++)\n\t\t\t\tparsing_str += strlen(parsing_str) + 1;\n\n\t\t\tresults_offset +=\n\t\t\t    sprintf(qed_get_buf_ptr(results_buf,\n\t\t\t\t\t\t    results_offset), \" %s\",\n\t\t\t\t    parsing_str);\n\t\t\tif (i < hdr->num_dumped_cond_regs && is_mem)\n\t\t\t\tresults_offset +=\n\t\t\t\t    sprintf(qed_get_buf_ptr(results_buf,\n\t\t\t\t\t\t\t    results_offset),\n\t\t\t\t\t    \"[%d]\", hdr->mem_entry_id +\n\t\t\t\t\t    reg_hdr->start_entry);\n\t\t\tresults_offset +=\n\t\t\t    sprintf(qed_get_buf_ptr(results_buf,\n\t\t\t\t\t\t    results_offset), \"=\");\n\t\t\tfor (j = 0; j < reg_hdr->size; j++, dump_buf++) {\n\t\t\t\tresults_offset +=\n\t\t\t\t    sprintf(qed_get_buf_ptr(results_buf,\n\t\t\t\t\t\t\t    results_offset),\n\t\t\t\t\t    \"0x%x\", *dump_buf);\n\t\t\t\tif (j < reg_hdr->size - 1)\n\t\t\t\t\tresults_offset +=\n\t\t\t\t\t    sprintf(qed_get_buf_ptr\n\t\t\t\t\t\t    (results_buf,\n\t\t\t\t\t\t     results_offset), \",\");\n\t\t\t}\n\t\t}\n\n\t\tresults_offset +=\n\t\t    sprintf(qed_get_buf_ptr(results_buf, results_offset), \"\\n\");\n\t}\n\n\t \n\tif (dump_buf > dump_buf_end)\n\t\treturn 0;\n\n\treturn results_offset;\n}\n\n \nstatic enum dbg_status qed_parse_idle_chk_dump(struct qed_hwfn *p_hwfn,\n\t\t\t\t\t       u32 *dump_buf,\n\t\t\t\t\t       u32 num_dumped_dwords,\n\t\t\t\t\t       char *results_buf,\n\t\t\t\t\t       u32 *parsed_results_bytes,\n\t\t\t\t\t       u32 *num_errors,\n\t\t\t\t\t       u32 *num_warnings)\n{\n\tu32 num_section_params = 0, num_rules, num_rules_not_dumped;\n\tconst char *section_name, *param_name, *param_str_val;\n\tu32 *dump_buf_end = dump_buf + num_dumped_dwords;\n\n\t \n\tu32 results_offset = 0;\n\n\t*parsed_results_bytes = 0;\n\t*num_errors = 0;\n\t*num_warnings = 0;\n\n\tif (!p_hwfn->dbg_arrays[BIN_BUF_DBG_PARSING_STRINGS].ptr ||\n\t    !p_hwfn->dbg_arrays[BIN_BUF_DBG_IDLE_CHK_PARSING_DATA].ptr)\n\t\treturn DBG_STATUS_DBG_ARRAY_NOT_SET;\n\n\t \n\tdump_buf += qed_read_section_hdr(dump_buf,\n\t\t\t\t\t &section_name, &num_section_params);\n\tif (strcmp(section_name, \"global_params\"))\n\t\treturn DBG_STATUS_IDLE_CHK_PARSE_FAILED;\n\n\t \n\tdump_buf += qed_print_section_params(dump_buf,\n\t\t\t\t\t     num_section_params,\n\t\t\t\t\t     results_buf, &results_offset);\n\n\t \n\n\tdump_buf += qed_read_section_hdr(dump_buf,\n\t\t\t\t\t &section_name, &num_section_params);\n\tif (strcmp(section_name, \"idle_chk\") ||\n\t    (num_section_params != 2 && num_section_params != 1))\n\t\treturn DBG_STATUS_IDLE_CHK_PARSE_FAILED;\n\tdump_buf += qed_read_param(dump_buf,\n\t\t\t\t   &param_name, &param_str_val, &num_rules);\n\tif (strcmp(param_name, \"num_rules\"))\n\t\treturn DBG_STATUS_IDLE_CHK_PARSE_FAILED;\n\tif (num_section_params > 1) {\n\t\tdump_buf += qed_read_param(dump_buf,\n\t\t\t\t\t   &param_name,\n\t\t\t\t\t   &param_str_val,\n\t\t\t\t\t   &num_rules_not_dumped);\n\t\tif (strcmp(param_name, \"num_rules_not_dumped\"))\n\t\t\treturn DBG_STATUS_IDLE_CHK_PARSE_FAILED;\n\t} else {\n\t\tnum_rules_not_dumped = 0;\n\t}\n\n\tif (num_rules) {\n\t\tu32 rules_print_size;\n\n\t\t \n\t\tresults_offset +=\n\t\t    sprintf(qed_get_buf_ptr(results_buf,\n\t\t\t\t\t    results_offset),\n\t\t\t    \"FW_IDLE_CHECK:\\n\");\n\t\trules_print_size =\n\t\t\tqed_parse_idle_chk_dump_rules(p_hwfn,\n\t\t\t\t\t\t      dump_buf,\n\t\t\t\t\t\t      dump_buf_end,\n\t\t\t\t\t\t      num_rules,\n\t\t\t\t\t\t      true,\n\t\t\t\t\t\t      results_buf ?\n\t\t\t\t\t\t      results_buf +\n\t\t\t\t\t\t      results_offset :\n\t\t\t\t\t\t      NULL,\n\t\t\t\t\t\t      num_errors,\n\t\t\t\t\t\t      num_warnings);\n\t\tresults_offset += rules_print_size;\n\t\tif (!rules_print_size)\n\t\t\treturn DBG_STATUS_IDLE_CHK_PARSE_FAILED;\n\n\t\t \n\t\tresults_offset +=\n\t\t    sprintf(qed_get_buf_ptr(results_buf,\n\t\t\t\t\t    results_offset),\n\t\t\t    \"\\nLSI_IDLE_CHECK:\\n\");\n\t\trules_print_size =\n\t\t\tqed_parse_idle_chk_dump_rules(p_hwfn,\n\t\t\t\t\t\t      dump_buf,\n\t\t\t\t\t\t      dump_buf_end,\n\t\t\t\t\t\t      num_rules,\n\t\t\t\t\t\t      false,\n\t\t\t\t\t\t      results_buf ?\n\t\t\t\t\t\t      results_buf +\n\t\t\t\t\t\t      results_offset :\n\t\t\t\t\t\t      NULL,\n\t\t\t\t\t\t      num_errors,\n\t\t\t\t\t\t      num_warnings);\n\t\tresults_offset += rules_print_size;\n\t\tif (!rules_print_size)\n\t\t\treturn DBG_STATUS_IDLE_CHK_PARSE_FAILED;\n\t}\n\n\t \n\tif (*num_errors)\n\t\tresults_offset +=\n\t\t    sprintf(qed_get_buf_ptr(results_buf,\n\t\t\t\t\t    results_offset),\n\t\t\t    \"\\nIdle Check failed!!! (with %d errors and %d warnings)\\n\",\n\t\t\t    *num_errors, *num_warnings);\n\telse if (*num_warnings)\n\t\tresults_offset +=\n\t\t    sprintf(qed_get_buf_ptr(results_buf,\n\t\t\t\t\t    results_offset),\n\t\t\t    \"\\nIdle Check completed successfully (with %d warnings)\\n\",\n\t\t\t    *num_warnings);\n\telse\n\t\tresults_offset +=\n\t\t    sprintf(qed_get_buf_ptr(results_buf,\n\t\t\t\t\t    results_offset),\n\t\t\t    \"\\nIdle Check completed successfully\\n\");\n\n\tif (num_rules_not_dumped)\n\t\tresults_offset +=\n\t\t    sprintf(qed_get_buf_ptr(results_buf,\n\t\t\t\t\t    results_offset),\n\t\t\t    \"\\nIdle Check Partially dumped : num_rules_not_dumped = %d\\n\",\n\t\t\t    num_rules_not_dumped);\n\n\t \n\t*parsed_results_bytes = results_offset + 1;\n\n\treturn DBG_STATUS_OK;\n}\n\n \nstatic enum dbg_status\nqed_mcp_trace_alloc_meta_data(struct qed_hwfn *p_hwfn,\n\t\t\t      const u32 *meta_buf)\n{\n\tstruct dbg_tools_user_data *dev_user_data;\n\tu32 offset = 0, signature, i;\n\tstruct mcp_trace_meta *meta;\n\tu8 *meta_buf_bytes;\n\n\tdev_user_data = qed_dbg_get_user_data(p_hwfn);\n\tmeta = &dev_user_data->mcp_trace_meta;\n\tmeta_buf_bytes = (u8 *)meta_buf;\n\n\t \n\tif (meta->is_allocated)\n\t\tqed_mcp_trace_free_meta_data(p_hwfn);\n\n\tmemset(meta, 0, sizeof(*meta));\n\n\t \n\tsignature = qed_read_dword_from_buf(meta_buf_bytes, &offset);\n\tif (signature != NVM_MAGIC_VALUE)\n\t\treturn DBG_STATUS_INVALID_TRACE_SIGNATURE;\n\n\t \n\tmeta->modules_num = qed_read_byte_from_buf(meta_buf_bytes, &offset);\n\tmeta->modules = kcalloc(meta->modules_num, sizeof(char *),\n\t\t\t\tGFP_KERNEL);\n\tif (!meta->modules)\n\t\treturn DBG_STATUS_VIRT_MEM_ALLOC_FAILED;\n\n\t \n\tfor (i = 0; i < meta->modules_num; i++) {\n\t\tu8 module_len = qed_read_byte_from_buf(meta_buf_bytes, &offset);\n\n\t\t*(meta->modules + i) = kzalloc(module_len, GFP_KERNEL);\n\t\tif (!(*(meta->modules + i))) {\n\t\t\t \n\t\t\tmeta->modules_num = i ? i - 1 : 0;\n\t\t\treturn DBG_STATUS_VIRT_MEM_ALLOC_FAILED;\n\t\t}\n\n\t\tqed_read_str_from_buf(meta_buf_bytes, &offset, module_len,\n\t\t\t\t      *(meta->modules + i));\n\t\tif (module_len > MCP_TRACE_MAX_MODULE_LEN)\n\t\t\t(*(meta->modules + i))[MCP_TRACE_MAX_MODULE_LEN] = '\\0';\n\t}\n\n\t \n\tsignature = qed_read_dword_from_buf(meta_buf_bytes, &offset);\n\tif (signature != NVM_MAGIC_VALUE)\n\t\treturn DBG_STATUS_INVALID_TRACE_SIGNATURE;\n\n\t \n\tmeta->formats_num = qed_read_dword_from_buf(meta_buf_bytes, &offset);\n\tmeta->formats = kcalloc(meta->formats_num,\n\t\t\t\tsizeof(struct mcp_trace_format),\n\t\t\t\tGFP_KERNEL);\n\tif (!meta->formats)\n\t\treturn DBG_STATUS_VIRT_MEM_ALLOC_FAILED;\n\n\t \n\tfor (i = 0; i < meta->formats_num; i++) {\n\t\tstruct mcp_trace_format *format_ptr = &meta->formats[i];\n\t\tu8 format_len;\n\n\t\tformat_ptr->data = qed_read_dword_from_buf(meta_buf_bytes,\n\t\t\t\t\t\t\t   &offset);\n\t\tformat_len = GET_MFW_FIELD(format_ptr->data,\n\t\t\t\t\t   MCP_TRACE_FORMAT_LEN);\n\t\tformat_ptr->format_str = kzalloc(format_len, GFP_KERNEL);\n\t\tif (!format_ptr->format_str) {\n\t\t\t \n\t\t\tmeta->formats_num = i ? i - 1 : 0;\n\t\t\treturn DBG_STATUS_VIRT_MEM_ALLOC_FAILED;\n\t\t}\n\n\t\tqed_read_str_from_buf(meta_buf_bytes,\n\t\t\t\t      &offset,\n\t\t\t\t      format_len, format_ptr->format_str);\n\t}\n\n\tmeta->is_allocated = true;\n\treturn DBG_STATUS_OK;\n}\n\n \nstatic enum dbg_status qed_parse_mcp_trace_buf(struct qed_hwfn *p_hwfn,\n\t\t\t\t\t       u8 *trace_buf,\n\t\t\t\t\t       u32 trace_buf_size,\n\t\t\t\t\t       u32 data_offset,\n\t\t\t\t\t       u32 data_size,\n\t\t\t\t\t       char *parsed_buf,\n\t\t\t\t\t       u32 *parsed_results_bytes)\n{\n\tstruct dbg_tools_user_data *dev_user_data;\n\tstruct mcp_trace_meta *meta;\n\tu32 param_mask, param_shift;\n\tenum dbg_status status;\n\n\tdev_user_data = qed_dbg_get_user_data(p_hwfn);\n\tmeta = &dev_user_data->mcp_trace_meta;\n\t*parsed_results_bytes = 0;\n\n\tif (!meta->is_allocated)\n\t\treturn DBG_STATUS_MCP_TRACE_BAD_DATA;\n\n\tstatus = DBG_STATUS_OK;\n\n\twhile (data_size) {\n\t\tstruct mcp_trace_format *format_ptr;\n\t\tu8 format_level, format_module;\n\t\tu32 params[3] = { 0, 0, 0 };\n\t\tu32 header, format_idx, i;\n\n\t\tif (data_size < MFW_TRACE_ENTRY_SIZE)\n\t\t\treturn DBG_STATUS_MCP_TRACE_BAD_DATA;\n\n\t\theader = qed_read_from_cyclic_buf(trace_buf,\n\t\t\t\t\t\t  &data_offset,\n\t\t\t\t\t\t  trace_buf_size,\n\t\t\t\t\t\t  MFW_TRACE_ENTRY_SIZE);\n\t\tdata_size -= MFW_TRACE_ENTRY_SIZE;\n\t\tformat_idx = header & MFW_TRACE_EVENTID_MASK;\n\n\t\t \n\t\tif (format_idx >= meta->formats_num) {\n\t\t\tu8 format_size = (u8)GET_MFW_FIELD(header,\n\t\t\t\t\t\t\t   MFW_TRACE_PRM_SIZE);\n\n\t\t\tif (data_size < format_size)\n\t\t\t\treturn DBG_STATUS_MCP_TRACE_BAD_DATA;\n\n\t\t\tdata_offset = qed_cyclic_add(data_offset,\n\t\t\t\t\t\t     format_size,\n\t\t\t\t\t\t     trace_buf_size);\n\t\t\tdata_size -= format_size;\n\t\t\tcontinue;\n\t\t}\n\n\t\tformat_ptr = &meta->formats[format_idx];\n\n\t\tfor (i = 0,\n\t\t     param_mask = MCP_TRACE_FORMAT_P1_SIZE_MASK, param_shift =\n\t\t     MCP_TRACE_FORMAT_P1_SIZE_OFFSET;\n\t\t     i < MCP_TRACE_FORMAT_MAX_PARAMS;\n\t\t     i++, param_mask <<= MCP_TRACE_FORMAT_PARAM_WIDTH,\n\t\t     param_shift += MCP_TRACE_FORMAT_PARAM_WIDTH) {\n\t\t\t \n\t\t\tu8 param_size = (u8)((format_ptr->data & param_mask) >>\n\t\t\t\t\t     param_shift);\n\n\t\t\t \n\t\t\tif (!param_size)\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\tif (param_size == 3)\n\t\t\t\tparam_size = 4;\n\n\t\t\tif (data_size < param_size)\n\t\t\t\treturn DBG_STATUS_MCP_TRACE_BAD_DATA;\n\n\t\t\tparams[i] = qed_read_from_cyclic_buf(trace_buf,\n\t\t\t\t\t\t\t     &data_offset,\n\t\t\t\t\t\t\t     trace_buf_size,\n\t\t\t\t\t\t\t     param_size);\n\t\t\tdata_size -= param_size;\n\t\t}\n\n\t\tformat_level = (u8)GET_MFW_FIELD(format_ptr->data,\n\t\t\t\t\t\t MCP_TRACE_FORMAT_LEVEL);\n\t\tformat_module = (u8)GET_MFW_FIELD(format_ptr->data,\n\t\t\t\t\t\t  MCP_TRACE_FORMAT_MODULE);\n\t\tif (format_level >= ARRAY_SIZE(s_mcp_trace_level_str))\n\t\t\treturn DBG_STATUS_MCP_TRACE_BAD_DATA;\n\n\t\t \n\t\t*parsed_results_bytes +=\n\t\t\tsprintf(qed_get_buf_ptr(parsed_buf,\n\t\t\t\t\t\t*parsed_results_bytes),\n\t\t\t\t\"%s %-8s: \",\n\t\t\t\ts_mcp_trace_level_str[format_level],\n\t\t\t\tmeta->modules[format_module]);\n\t\t*parsed_results_bytes +=\n\t\t    sprintf(qed_get_buf_ptr(parsed_buf, *parsed_results_bytes),\n\t\t\t    format_ptr->format_str,\n\t\t\t    params[0], params[1], params[2]);\n\t}\n\n\t \n\t(*parsed_results_bytes)++;\n\n\treturn status;\n}\n\n \nstatic enum dbg_status qed_parse_mcp_trace_dump(struct qed_hwfn *p_hwfn,\n\t\t\t\t\t\tu32 *dump_buf,\n\t\t\t\t\t\tchar *results_buf,\n\t\t\t\t\t\tu32 *parsed_results_bytes,\n\t\t\t\t\t\tbool free_meta_data)\n{\n\tconst char *section_name, *param_name, *param_str_val;\n\tu32 data_size, trace_data_dwords, trace_meta_dwords;\n\tu32 offset, results_offset, results_buf_bytes;\n\tu32 param_num_val, num_section_params;\n\tstruct mcp_trace *trace;\n\tenum dbg_status status;\n\tconst u32 *meta_buf;\n\tu8 *trace_buf;\n\n\t*parsed_results_bytes = 0;\n\n\t \n\tdump_buf += qed_read_section_hdr(dump_buf,\n\t\t\t\t\t &section_name, &num_section_params);\n\tif (strcmp(section_name, \"global_params\"))\n\t\treturn DBG_STATUS_MCP_TRACE_BAD_DATA;\n\n\t \n\tdump_buf += qed_print_section_params(dump_buf,\n\t\t\t\t\t     num_section_params,\n\t\t\t\t\t     results_buf, &results_offset);\n\n\t \n\tdump_buf += qed_read_section_hdr(dump_buf,\n\t\t\t\t\t &section_name, &num_section_params);\n\tif (strcmp(section_name, \"mcp_trace_data\") || num_section_params != 1)\n\t\treturn DBG_STATUS_MCP_TRACE_BAD_DATA;\n\tdump_buf += qed_read_param(dump_buf,\n\t\t\t\t   &param_name, &param_str_val, &param_num_val);\n\tif (strcmp(param_name, \"size\"))\n\t\treturn DBG_STATUS_MCP_TRACE_BAD_DATA;\n\ttrace_data_dwords = param_num_val;\n\n\t \n\ttrace = (struct mcp_trace *)dump_buf;\n\tif (trace->signature != MFW_TRACE_SIGNATURE || !trace->size)\n\t\treturn DBG_STATUS_MCP_TRACE_BAD_DATA;\n\n\ttrace_buf = (u8 *)dump_buf + sizeof(*trace);\n\toffset = trace->trace_oldest;\n\tdata_size = qed_cyclic_sub(trace->trace_prod, offset, trace->size);\n\tdump_buf += trace_data_dwords;\n\n\t \n\tdump_buf += qed_read_section_hdr(dump_buf,\n\t\t\t\t\t &section_name, &num_section_params);\n\tif (strcmp(section_name, \"mcp_trace_meta\"))\n\t\treturn DBG_STATUS_MCP_TRACE_BAD_DATA;\n\tdump_buf += qed_read_param(dump_buf,\n\t\t\t\t   &param_name, &param_str_val, &param_num_val);\n\tif (strcmp(param_name, \"size\"))\n\t\treturn DBG_STATUS_MCP_TRACE_BAD_DATA;\n\ttrace_meta_dwords = param_num_val;\n\n\t \n\tif (!trace_meta_dwords) {\n\t\t \n\t\tstruct dbg_tools_user_data *dev_user_data =\n\t\t\tqed_dbg_get_user_data(p_hwfn);\n\n\t\tif (!dev_user_data->mcp_trace_user_meta_buf)\n\t\t\treturn DBG_STATUS_MCP_TRACE_NO_META;\n\n\t\tmeta_buf = dev_user_data->mcp_trace_user_meta_buf;\n\t} else {\n\t\t \n\t\tmeta_buf = dump_buf;\n\t}\n\n\t \n\tstatus = qed_mcp_trace_alloc_meta_data(p_hwfn, meta_buf);\n\tif (status != DBG_STATUS_OK)\n\t\treturn status;\n\n\tstatus = qed_parse_mcp_trace_buf(p_hwfn,\n\t\t\t\t\t trace_buf,\n\t\t\t\t\t trace->size,\n\t\t\t\t\t offset,\n\t\t\t\t\t data_size,\n\t\t\t\t\t results_buf ?\n\t\t\t\t\t results_buf + results_offset :\n\t\t\t\t\t NULL,\n\t\t\t\t\t &results_buf_bytes);\n\tif (status != DBG_STATUS_OK)\n\t\treturn status;\n\n\tif (free_meta_data)\n\t\tqed_mcp_trace_free_meta_data(p_hwfn);\n\n\t*parsed_results_bytes = results_offset + results_buf_bytes;\n\n\treturn DBG_STATUS_OK;\n}\n\n \nstatic enum dbg_status qed_parse_reg_fifo_dump(u32 *dump_buf,\n\t\t\t\t\t       char *results_buf,\n\t\t\t\t\t       u32 *parsed_results_bytes)\n{\n\tconst char *section_name, *param_name, *param_str_val;\n\tu32 param_num_val, num_section_params, num_elements;\n\tstruct reg_fifo_element *elements;\n\tu8 i, j, err_code, vf_val;\n\tu32 results_offset = 0;\n\tchar vf_str[4];\n\n\t \n\tdump_buf += qed_read_section_hdr(dump_buf,\n\t\t\t\t\t &section_name, &num_section_params);\n\tif (strcmp(section_name, \"global_params\"))\n\t\treturn DBG_STATUS_REG_FIFO_BAD_DATA;\n\n\t \n\tdump_buf += qed_print_section_params(dump_buf,\n\t\t\t\t\t     num_section_params,\n\t\t\t\t\t     results_buf, &results_offset);\n\n\t \n\tdump_buf += qed_read_section_hdr(dump_buf,\n\t\t\t\t\t &section_name, &num_section_params);\n\tif (strcmp(section_name, \"reg_fifo_data\"))\n\t\treturn DBG_STATUS_REG_FIFO_BAD_DATA;\n\tdump_buf += qed_read_param(dump_buf,\n\t\t\t\t   &param_name, &param_str_val, &param_num_val);\n\tif (strcmp(param_name, \"size\"))\n\t\treturn DBG_STATUS_REG_FIFO_BAD_DATA;\n\tif (param_num_val % REG_FIFO_ELEMENT_DWORDS)\n\t\treturn DBG_STATUS_REG_FIFO_BAD_DATA;\n\tnum_elements = param_num_val / REG_FIFO_ELEMENT_DWORDS;\n\telements = (struct reg_fifo_element *)dump_buf;\n\n\t \n\tfor (i = 0; i < num_elements; i++) {\n\t\tconst char *err_msg = NULL;\n\n\t\t \n\t\tvf_val = GET_FIELD(elements[i].data, REG_FIFO_ELEMENT_VF);\n\t\tif (vf_val == REG_FIFO_ELEMENT_IS_PF_VF_VAL)\n\t\t\tsprintf(vf_str, \"%s\", \"N/A\");\n\t\telse\n\t\t\tsprintf(vf_str, \"%d\", vf_val);\n\n\t\t \n\t\terr_code = GET_FIELD(elements[i].data, REG_FIFO_ELEMENT_ERROR);\n\t\tfor (j = 0; j < ARRAY_SIZE(s_reg_fifo_errors) && !err_msg; j++)\n\t\t\tif (err_code == s_reg_fifo_errors[j].err_code)\n\t\t\t\terr_msg = s_reg_fifo_errors[j].err_msg;\n\n\t\t \n\t\tresults_offset +=\n\t\t    sprintf(qed_get_buf_ptr(results_buf,\n\t\t\t\t\t    results_offset),\n\t\t\t    \"raw: 0x%016llx, address: 0x%07x, access: %-5s, pf: %2d, vf: %s, port: %d, privilege: %-3s, protection: %-12s, master: %-4s, error: %s\\n\",\n\t\t\t    elements[i].data,\n\t\t\t    (u32)GET_FIELD(elements[i].data,\n\t\t\t\t\t   REG_FIFO_ELEMENT_ADDRESS) *\n\t\t\t    REG_FIFO_ELEMENT_ADDR_FACTOR,\n\t\t\t    s_access_strs[GET_FIELD(elements[i].data,\n\t\t\t\t\t\t    REG_FIFO_ELEMENT_ACCESS)],\n\t\t\t    (u32)GET_FIELD(elements[i].data,\n\t\t\t\t\t   REG_FIFO_ELEMENT_PF),\n\t\t\t    vf_str,\n\t\t\t    (u32)GET_FIELD(elements[i].data,\n\t\t\t\t\t   REG_FIFO_ELEMENT_PORT),\n\t\t\t    s_privilege_strs[GET_FIELD(elements[i].data,\n\t\t\t\t\t\tREG_FIFO_ELEMENT_PRIVILEGE)],\n\t\t\t    s_protection_strs[GET_FIELD(elements[i].data,\n\t\t\t\t\t\tREG_FIFO_ELEMENT_PROTECTION)],\n\t\t\t    s_master_strs[GET_FIELD(elements[i].data,\n\t\t\t\t\t\t    REG_FIFO_ELEMENT_MASTER)],\n\t\t\t    err_msg ? err_msg : \"unknown error code\");\n\t}\n\n\tresults_offset += sprintf(qed_get_buf_ptr(results_buf,\n\t\t\t\t\t\t  results_offset),\n\t\t\t\t  \"fifo contained %d elements\", num_elements);\n\n\t \n\t*parsed_results_bytes = results_offset + 1;\n\n\treturn DBG_STATUS_OK;\n}\n\nstatic enum dbg_status qed_parse_igu_fifo_element(struct igu_fifo_element\n\t\t\t\t\t\t  *element, char\n\t\t\t\t\t\t  *results_buf,\n\t\t\t\t\t\t  u32 *results_offset)\n{\n\tconst struct igu_fifo_addr_data *found_addr = NULL;\n\tu8 source, err_type, i, is_cleanup;\n\tchar parsed_addr_data[32];\n\tchar parsed_wr_data[256];\n\tu32 wr_data, prod_cons;\n\tbool is_wr_cmd, is_pf;\n\tu16 cmd_addr;\n\tu64 dword12;\n\n\t \n\tdword12 = ((u64)element->dword2 << 32) | element->dword1;\n\tis_wr_cmd = GET_FIELD(dword12, IGU_FIFO_ELEMENT_DWORD12_IS_WR_CMD);\n\tis_pf = GET_FIELD(element->dword0, IGU_FIFO_ELEMENT_DWORD0_IS_PF);\n\tcmd_addr = GET_FIELD(element->dword0, IGU_FIFO_ELEMENT_DWORD0_CMD_ADDR);\n\tsource = GET_FIELD(element->dword0, IGU_FIFO_ELEMENT_DWORD0_SOURCE);\n\terr_type = GET_FIELD(element->dword0, IGU_FIFO_ELEMENT_DWORD0_ERR_TYPE);\n\n\tif (source >= ARRAY_SIZE(s_igu_fifo_source_strs))\n\t\treturn DBG_STATUS_IGU_FIFO_BAD_DATA;\n\tif (err_type >= ARRAY_SIZE(s_igu_fifo_error_strs))\n\t\treturn DBG_STATUS_IGU_FIFO_BAD_DATA;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(s_igu_fifo_addr_data) && !found_addr; i++) {\n\t\tconst struct igu_fifo_addr_data *curr_addr =\n\t\t\t&s_igu_fifo_addr_data[i];\n\n\t\tif (cmd_addr >= curr_addr->start_addr && cmd_addr <=\n\t\t    curr_addr->end_addr)\n\t\t\tfound_addr = curr_addr;\n\t}\n\n\tif (!found_addr)\n\t\treturn DBG_STATUS_IGU_FIFO_BAD_DATA;\n\n\t \n\tswitch (found_addr->type) {\n\tcase IGU_ADDR_TYPE_MSIX_MEM:\n\t\tsprintf(parsed_addr_data, \" vector_num = 0x%x\", cmd_addr / 2);\n\t\tbreak;\n\tcase IGU_ADDR_TYPE_WRITE_INT_ACK:\n\tcase IGU_ADDR_TYPE_WRITE_PROD_UPDATE:\n\t\tsprintf(parsed_addr_data,\n\t\t\t\" SB = 0x%x\", cmd_addr - found_addr->start_addr);\n\t\tbreak;\n\tdefault:\n\t\tparsed_addr_data[0] = '\\0';\n\t}\n\n\tif (!is_wr_cmd) {\n\t\tparsed_wr_data[0] = '\\0';\n\t\tgoto out;\n\t}\n\n\t \n\twr_data = GET_FIELD(dword12, IGU_FIFO_ELEMENT_DWORD12_WR_DATA);\n\tprod_cons = GET_FIELD(wr_data, IGU_FIFO_WR_DATA_PROD_CONS);\n\tis_cleanup = GET_FIELD(wr_data, IGU_FIFO_WR_DATA_CMD_TYPE);\n\n\tif (source == IGU_SRC_ATTN) {\n\t\tsprintf(parsed_wr_data, \"prod: 0x%x, \", prod_cons);\n\t} else {\n\t\tif (is_cleanup) {\n\t\t\tu8 cleanup_val, cleanup_type;\n\n\t\t\tcleanup_val =\n\t\t\t\tGET_FIELD(wr_data,\n\t\t\t\t\t  IGU_FIFO_CLEANUP_WR_DATA_CLEANUP_VAL);\n\t\t\tcleanup_type =\n\t\t\t    GET_FIELD(wr_data,\n\t\t\t\t      IGU_FIFO_CLEANUP_WR_DATA_CLEANUP_TYPE);\n\n\t\t\tsprintf(parsed_wr_data,\n\t\t\t\t\"cmd_type: cleanup, cleanup_val: %s, cleanup_type : %d, \",\n\t\t\t\tcleanup_val ? \"set\" : \"clear\",\n\t\t\t\tcleanup_type);\n\t\t} else {\n\t\t\tu8 update_flag, en_dis_int_for_sb, segment;\n\t\t\tu8 timer_mask;\n\n\t\t\tupdate_flag = GET_FIELD(wr_data,\n\t\t\t\t\t\tIGU_FIFO_WR_DATA_UPDATE_FLAG);\n\t\t\ten_dis_int_for_sb =\n\t\t\t\tGET_FIELD(wr_data,\n\t\t\t\t\t  IGU_FIFO_WR_DATA_EN_DIS_INT_FOR_SB);\n\t\t\tsegment = GET_FIELD(wr_data,\n\t\t\t\t\t    IGU_FIFO_WR_DATA_SEGMENT);\n\t\t\ttimer_mask = GET_FIELD(wr_data,\n\t\t\t\t\t       IGU_FIFO_WR_DATA_TIMER_MASK);\n\n\t\t\tsprintf(parsed_wr_data,\n\t\t\t\t\"cmd_type: prod/cons update, prod/cons: 0x%x, update_flag: %s, en_dis_int_for_sb : %s, segment : %s, timer_mask = %d, \",\n\t\t\t\tprod_cons,\n\t\t\t\tupdate_flag ? \"update\" : \"nop\",\n\t\t\t\ten_dis_int_for_sb ?\n\t\t\t\t(en_dis_int_for_sb == 1 ? \"disable\" : \"nop\") :\n\t\t\t\t\"enable\",\n\t\t\t\tsegment ? \"attn\" : \"regular\",\n\t\t\t\ttimer_mask);\n\t\t}\n\t}\nout:\n\t \n\t*results_offset += sprintf(qed_get_buf_ptr(results_buf,\n\t\t\t\t\t\t   *results_offset),\n\t\t\t\t   \"raw: 0x%01x%08x%08x, %s: %d, source : %s, type : %s, cmd_addr : 0x%x(%s%s), %serror: %s\\n\",\n\t\t\t\t   element->dword2, element->dword1,\n\t\t\t\t   element->dword0,\n\t\t\t\t   is_pf ? \"pf\" : \"vf\",\n\t\t\t\t   GET_FIELD(element->dword0,\n\t\t\t\t\t     IGU_FIFO_ELEMENT_DWORD0_FID),\n\t\t\t\t   s_igu_fifo_source_strs[source],\n\t\t\t\t   is_wr_cmd ? \"wr\" : \"rd\",\n\t\t\t\t   cmd_addr,\n\t\t\t\t   (!is_pf && found_addr->vf_desc)\n\t\t\t\t   ? found_addr->vf_desc\n\t\t\t\t   : found_addr->desc,\n\t\t\t\t   parsed_addr_data,\n\t\t\t\t   parsed_wr_data,\n\t\t\t\t   s_igu_fifo_error_strs[err_type]);\n\n\treturn DBG_STATUS_OK;\n}\n\n \nstatic enum dbg_status qed_parse_igu_fifo_dump(u32 *dump_buf,\n\t\t\t\t\t       char *results_buf,\n\t\t\t\t\t       u32 *parsed_results_bytes)\n{\n\tconst char *section_name, *param_name, *param_str_val;\n\tu32 param_num_val, num_section_params, num_elements;\n\tstruct igu_fifo_element *elements;\n\tenum dbg_status status;\n\tu32 results_offset = 0;\n\tu8 i;\n\n\t \n\tdump_buf += qed_read_section_hdr(dump_buf,\n\t\t\t\t\t &section_name, &num_section_params);\n\tif (strcmp(section_name, \"global_params\"))\n\t\treturn DBG_STATUS_IGU_FIFO_BAD_DATA;\n\n\t \n\tdump_buf += qed_print_section_params(dump_buf,\n\t\t\t\t\t     num_section_params,\n\t\t\t\t\t     results_buf, &results_offset);\n\n\t \n\tdump_buf += qed_read_section_hdr(dump_buf,\n\t\t\t\t\t &section_name, &num_section_params);\n\tif (strcmp(section_name, \"igu_fifo_data\"))\n\t\treturn DBG_STATUS_IGU_FIFO_BAD_DATA;\n\tdump_buf += qed_read_param(dump_buf,\n\t\t\t\t   &param_name, &param_str_val, &param_num_val);\n\tif (strcmp(param_name, \"size\"))\n\t\treturn DBG_STATUS_IGU_FIFO_BAD_DATA;\n\tif (param_num_val % IGU_FIFO_ELEMENT_DWORDS)\n\t\treturn DBG_STATUS_IGU_FIFO_BAD_DATA;\n\tnum_elements = param_num_val / IGU_FIFO_ELEMENT_DWORDS;\n\telements = (struct igu_fifo_element *)dump_buf;\n\n\t \n\tfor (i = 0; i < num_elements; i++) {\n\t\tstatus = qed_parse_igu_fifo_element(&elements[i],\n\t\t\t\t\t\t    results_buf,\n\t\t\t\t\t\t    &results_offset);\n\t\tif (status != DBG_STATUS_OK)\n\t\t\treturn status;\n\t}\n\n\tresults_offset += sprintf(qed_get_buf_ptr(results_buf,\n\t\t\t\t\t\t  results_offset),\n\t\t\t\t  \"fifo contained %d elements\", num_elements);\n\n\t \n\t*parsed_results_bytes = results_offset + 1;\n\n\treturn DBG_STATUS_OK;\n}\n\nstatic enum dbg_status\nqed_parse_protection_override_dump(u32 *dump_buf,\n\t\t\t\t   char *results_buf,\n\t\t\t\t   u32 *parsed_results_bytes)\n{\n\tconst char *section_name, *param_name, *param_str_val;\n\tu32 param_num_val, num_section_params, num_elements;\n\tstruct protection_override_element *elements;\n\tu32 results_offset = 0;\n\tu8 i;\n\n\t \n\tdump_buf += qed_read_section_hdr(dump_buf,\n\t\t\t\t\t &section_name, &num_section_params);\n\tif (strcmp(section_name, \"global_params\"))\n\t\treturn DBG_STATUS_PROTECTION_OVERRIDE_BAD_DATA;\n\n\t \n\tdump_buf += qed_print_section_params(dump_buf,\n\t\t\t\t\t     num_section_params,\n\t\t\t\t\t     results_buf, &results_offset);\n\n\t \n\tdump_buf += qed_read_section_hdr(dump_buf,\n\t\t\t\t\t &section_name, &num_section_params);\n\tif (strcmp(section_name, \"protection_override_data\"))\n\t\treturn DBG_STATUS_PROTECTION_OVERRIDE_BAD_DATA;\n\tdump_buf += qed_read_param(dump_buf,\n\t\t\t\t   &param_name, &param_str_val, &param_num_val);\n\tif (strcmp(param_name, \"size\"))\n\t\treturn DBG_STATUS_PROTECTION_OVERRIDE_BAD_DATA;\n\tif (param_num_val % PROTECTION_OVERRIDE_ELEMENT_DWORDS)\n\t\treturn DBG_STATUS_PROTECTION_OVERRIDE_BAD_DATA;\n\tnum_elements = param_num_val / PROTECTION_OVERRIDE_ELEMENT_DWORDS;\n\telements = (struct protection_override_element *)dump_buf;\n\n\t \n\tfor (i = 0; i < num_elements; i++) {\n\t\tu32 address = GET_FIELD(elements[i].data,\n\t\t\t\t\tPROTECTION_OVERRIDE_ELEMENT_ADDRESS) *\n\t\t\t      PROTECTION_OVERRIDE_ELEMENT_ADDR_FACTOR;\n\n\t\tresults_offset +=\n\t\t    sprintf(qed_get_buf_ptr(results_buf,\n\t\t\t\t\t    results_offset),\n\t\t\t    \"window %2d, address: 0x%07x, size: %7d regs, read: %d, write: %d, read protection: %-12s, write protection: %-12s\\n\",\n\t\t\t    i, address,\n\t\t\t    (u32)GET_FIELD(elements[i].data,\n\t\t\t\t      PROTECTION_OVERRIDE_ELEMENT_WINDOW_SIZE),\n\t\t\t    (u32)GET_FIELD(elements[i].data,\n\t\t\t\t      PROTECTION_OVERRIDE_ELEMENT_READ),\n\t\t\t    (u32)GET_FIELD(elements[i].data,\n\t\t\t\t      PROTECTION_OVERRIDE_ELEMENT_WRITE),\n\t\t\t    s_protection_strs[GET_FIELD(elements[i].data,\n\t\t\t\tPROTECTION_OVERRIDE_ELEMENT_READ_PROTECTION)],\n\t\t\t    s_protection_strs[GET_FIELD(elements[i].data,\n\t\t\t\tPROTECTION_OVERRIDE_ELEMENT_WRITE_PROTECTION)]);\n\t}\n\n\tresults_offset += sprintf(qed_get_buf_ptr(results_buf,\n\t\t\t\t\t\t  results_offset),\n\t\t\t\t  \"protection override contained %d elements\",\n\t\t\t\t  num_elements);\n\n\t \n\t*parsed_results_bytes = results_offset + 1;\n\n\treturn DBG_STATUS_OK;\n}\n\n \nstatic enum dbg_status qed_parse_fw_asserts_dump(u32 *dump_buf,\n\t\t\t\t\t\t char *results_buf,\n\t\t\t\t\t\t u32 *parsed_results_bytes)\n{\n\tu32 num_section_params, param_num_val, i, results_offset = 0;\n\tconst char *param_name, *param_str_val, *section_name;\n\tbool last_section_found = false;\n\n\t*parsed_results_bytes = 0;\n\n\t \n\tdump_buf += qed_read_section_hdr(dump_buf,\n\t\t\t\t\t &section_name, &num_section_params);\n\tif (strcmp(section_name, \"global_params\"))\n\t\treturn DBG_STATUS_FW_ASSERTS_PARSE_FAILED;\n\n\t \n\tdump_buf += qed_print_section_params(dump_buf,\n\t\t\t\t\t     num_section_params,\n\t\t\t\t\t     results_buf, &results_offset);\n\n\twhile (!last_section_found) {\n\t\tdump_buf += qed_read_section_hdr(dump_buf,\n\t\t\t\t\t\t &section_name,\n\t\t\t\t\t\t &num_section_params);\n\t\tif (!strcmp(section_name, \"fw_asserts\")) {\n\t\t\t \n\t\t\tconst char *storm_letter = NULL;\n\t\t\tu32 storm_dump_size = 0;\n\n\t\t\tfor (i = 0; i < num_section_params; i++) {\n\t\t\t\tdump_buf += qed_read_param(dump_buf,\n\t\t\t\t\t\t\t   &param_name,\n\t\t\t\t\t\t\t   &param_str_val,\n\t\t\t\t\t\t\t   &param_num_val);\n\t\t\t\tif (!strcmp(param_name, \"storm\"))\n\t\t\t\t\tstorm_letter = param_str_val;\n\t\t\t\telse if (!strcmp(param_name, \"size\"))\n\t\t\t\t\tstorm_dump_size = param_num_val;\n\t\t\t\telse\n\t\t\t\t\treturn\n\t\t\t\t\t    DBG_STATUS_FW_ASSERTS_PARSE_FAILED;\n\t\t\t}\n\n\t\t\tif (!storm_letter || !storm_dump_size)\n\t\t\t\treturn DBG_STATUS_FW_ASSERTS_PARSE_FAILED;\n\n\t\t\t \n\t\t\tresults_offset +=\n\t\t\t    sprintf(qed_get_buf_ptr(results_buf,\n\t\t\t\t\t\t    results_offset),\n\t\t\t\t    \"\\n%sSTORM_ASSERT: size=%d\\n\",\n\t\t\t\t    storm_letter, storm_dump_size);\n\t\t\tfor (i = 0; i < storm_dump_size; i++, dump_buf++)\n\t\t\t\tresults_offset +=\n\t\t\t\t    sprintf(qed_get_buf_ptr(results_buf,\n\t\t\t\t\t\t\t    results_offset),\n\t\t\t\t\t    \"%08x\\n\", *dump_buf);\n\t\t} else if (!strcmp(section_name, \"last\")) {\n\t\t\tlast_section_found = true;\n\t\t} else {\n\t\t\treturn DBG_STATUS_FW_ASSERTS_PARSE_FAILED;\n\t\t}\n\t}\n\n\t \n\t*parsed_results_bytes = results_offset + 1;\n\n\treturn DBG_STATUS_OK;\n}\n\n \n\nenum dbg_status qed_dbg_user_set_bin_ptr(struct qed_hwfn *p_hwfn,\n\t\t\t\t\t const u8 * const bin_ptr)\n{\n\tstruct bin_buffer_hdr *buf_hdrs = (struct bin_buffer_hdr *)bin_ptr;\n\tu8 buf_id;\n\n\t \n\tfor (buf_id = 0; buf_id < MAX_BIN_DBG_BUFFER_TYPE; buf_id++)\n\t\tqed_set_dbg_bin_buf(p_hwfn,\n\t\t\t\t    (enum bin_dbg_buffer_type)buf_id,\n\t\t\t\t    (u32 *)(bin_ptr + buf_hdrs[buf_id].offset),\n\t\t\t\t    buf_hdrs[buf_id].length);\n\n\treturn DBG_STATUS_OK;\n}\n\nenum dbg_status qed_dbg_alloc_user_data(struct qed_hwfn *p_hwfn,\n\t\t\t\t\tvoid **user_data_ptr)\n{\n\t*user_data_ptr = kzalloc(sizeof(struct dbg_tools_user_data),\n\t\t\t\t GFP_KERNEL);\n\tif (!(*user_data_ptr))\n\t\treturn DBG_STATUS_VIRT_MEM_ALLOC_FAILED;\n\n\treturn DBG_STATUS_OK;\n}\n\nconst char *qed_dbg_get_status_str(enum dbg_status status)\n{\n\treturn (status <\n\t\tMAX_DBG_STATUS) ? s_status_str[status] : \"Invalid debug status\";\n}\n\nenum dbg_status qed_get_idle_chk_results_buf_size(struct qed_hwfn *p_hwfn,\n\t\t\t\t\t\t  u32 *dump_buf,\n\t\t\t\t\t\t  u32 num_dumped_dwords,\n\t\t\t\t\t\t  u32 *results_buf_size)\n{\n\tu32 num_errors, num_warnings;\n\n\treturn qed_parse_idle_chk_dump(p_hwfn,\n\t\t\t\t       dump_buf,\n\t\t\t\t       num_dumped_dwords,\n\t\t\t\t       NULL,\n\t\t\t\t       results_buf_size,\n\t\t\t\t       &num_errors, &num_warnings);\n}\n\nenum dbg_status qed_print_idle_chk_results(struct qed_hwfn *p_hwfn,\n\t\t\t\t\t   u32 *dump_buf,\n\t\t\t\t\t   u32 num_dumped_dwords,\n\t\t\t\t\t   char *results_buf,\n\t\t\t\t\t   u32 *num_errors,\n\t\t\t\t\t   u32 *num_warnings)\n{\n\tu32 parsed_buf_size;\n\n\treturn qed_parse_idle_chk_dump(p_hwfn,\n\t\t\t\t       dump_buf,\n\t\t\t\t       num_dumped_dwords,\n\t\t\t\t       results_buf,\n\t\t\t\t       &parsed_buf_size,\n\t\t\t\t       num_errors, num_warnings);\n}\n\nvoid qed_dbg_mcp_trace_set_meta_data(struct qed_hwfn *p_hwfn,\n\t\t\t\t     const u32 *meta_buf)\n{\n\tstruct dbg_tools_user_data *dev_user_data =\n\t\tqed_dbg_get_user_data(p_hwfn);\n\n\tdev_user_data->mcp_trace_user_meta_buf = meta_buf;\n}\n\nenum dbg_status qed_get_mcp_trace_results_buf_size(struct qed_hwfn *p_hwfn,\n\t\t\t\t\t\t   u32 *dump_buf,\n\t\t\t\t\t\t   u32 num_dumped_dwords,\n\t\t\t\t\t\t   u32 *results_buf_size)\n{\n\treturn qed_parse_mcp_trace_dump(p_hwfn,\n\t\t\t\t\tdump_buf, NULL, results_buf_size, true);\n}\n\nenum dbg_status qed_print_mcp_trace_results(struct qed_hwfn *p_hwfn,\n\t\t\t\t\t    u32 *dump_buf,\n\t\t\t\t\t    u32 num_dumped_dwords,\n\t\t\t\t\t    char *results_buf)\n{\n\tu32 parsed_buf_size;\n\n\t \n\tqed_user_static_asserts();\n\n\treturn qed_parse_mcp_trace_dump(p_hwfn,\n\t\t\t\t\tdump_buf,\n\t\t\t\t\tresults_buf, &parsed_buf_size, true);\n}\n\nenum dbg_status qed_print_mcp_trace_results_cont(struct qed_hwfn *p_hwfn,\n\t\t\t\t\t\t u32 *dump_buf,\n\t\t\t\t\t\t char *results_buf)\n{\n\tu32 parsed_buf_size;\n\n\treturn qed_parse_mcp_trace_dump(p_hwfn, dump_buf, results_buf,\n\t\t\t\t\t&parsed_buf_size, false);\n}\n\nenum dbg_status qed_print_mcp_trace_line(struct qed_hwfn *p_hwfn,\n\t\t\t\t\t u8 *dump_buf,\n\t\t\t\t\t u32 num_dumped_bytes,\n\t\t\t\t\t char *results_buf)\n{\n\tu32 parsed_results_bytes;\n\n\treturn qed_parse_mcp_trace_buf(p_hwfn,\n\t\t\t\t       dump_buf,\n\t\t\t\t       num_dumped_bytes,\n\t\t\t\t       0,\n\t\t\t\t       num_dumped_bytes,\n\t\t\t\t       results_buf, &parsed_results_bytes);\n}\n\n \nvoid qed_mcp_trace_free_meta_data(struct qed_hwfn *p_hwfn)\n{\n\tstruct dbg_tools_user_data *dev_user_data;\n\tstruct mcp_trace_meta *meta;\n\tu32 i;\n\n\tdev_user_data = qed_dbg_get_user_data(p_hwfn);\n\tmeta = &dev_user_data->mcp_trace_meta;\n\tif (!meta->is_allocated)\n\t\treturn;\n\n\t \n\tif (meta->modules) {\n\t\tfor (i = 0; i < meta->modules_num; i++)\n\t\t\tkfree(meta->modules[i]);\n\t\tkfree(meta->modules);\n\t}\n\n\t \n\tif (meta->formats) {\n\t\tfor (i = 0; i < meta->formats_num; i++)\n\t\t\tkfree(meta->formats[i].format_str);\n\t\tkfree(meta->formats);\n\t}\n\n\tmeta->is_allocated = false;\n}\n\nenum dbg_status qed_get_reg_fifo_results_buf_size(struct qed_hwfn *p_hwfn,\n\t\t\t\t\t\t  u32 *dump_buf,\n\t\t\t\t\t\t  u32 num_dumped_dwords,\n\t\t\t\t\t\t  u32 *results_buf_size)\n{\n\treturn qed_parse_reg_fifo_dump(dump_buf, NULL, results_buf_size);\n}\n\nenum dbg_status qed_print_reg_fifo_results(struct qed_hwfn *p_hwfn,\n\t\t\t\t\t   u32 *dump_buf,\n\t\t\t\t\t   u32 num_dumped_dwords,\n\t\t\t\t\t   char *results_buf)\n{\n\tu32 parsed_buf_size;\n\n\treturn qed_parse_reg_fifo_dump(dump_buf, results_buf, &parsed_buf_size);\n}\n\nenum dbg_status qed_get_igu_fifo_results_buf_size(struct qed_hwfn *p_hwfn,\n\t\t\t\t\t\t  u32 *dump_buf,\n\t\t\t\t\t\t  u32 num_dumped_dwords,\n\t\t\t\t\t\t  u32 *results_buf_size)\n{\n\treturn qed_parse_igu_fifo_dump(dump_buf, NULL, results_buf_size);\n}\n\nenum dbg_status qed_print_igu_fifo_results(struct qed_hwfn *p_hwfn,\n\t\t\t\t\t   u32 *dump_buf,\n\t\t\t\t\t   u32 num_dumped_dwords,\n\t\t\t\t\t   char *results_buf)\n{\n\tu32 parsed_buf_size;\n\n\treturn qed_parse_igu_fifo_dump(dump_buf, results_buf, &parsed_buf_size);\n}\n\nenum dbg_status\nqed_get_protection_override_results_buf_size(struct qed_hwfn *p_hwfn,\n\t\t\t\t\t     u32 *dump_buf,\n\t\t\t\t\t     u32 num_dumped_dwords,\n\t\t\t\t\t     u32 *results_buf_size)\n{\n\treturn qed_parse_protection_override_dump(dump_buf,\n\t\t\t\t\t\t  NULL, results_buf_size);\n}\n\nenum dbg_status qed_print_protection_override_results(struct qed_hwfn *p_hwfn,\n\t\t\t\t\t\t      u32 *dump_buf,\n\t\t\t\t\t\t      u32 num_dumped_dwords,\n\t\t\t\t\t\t      char *results_buf)\n{\n\tu32 parsed_buf_size;\n\n\treturn qed_parse_protection_override_dump(dump_buf,\n\t\t\t\t\t\t  results_buf,\n\t\t\t\t\t\t  &parsed_buf_size);\n}\n\nenum dbg_status qed_get_fw_asserts_results_buf_size(struct qed_hwfn *p_hwfn,\n\t\t\t\t\t\t    u32 *dump_buf,\n\t\t\t\t\t\t    u32 num_dumped_dwords,\n\t\t\t\t\t\t    u32 *results_buf_size)\n{\n\treturn qed_parse_fw_asserts_dump(dump_buf, NULL, results_buf_size);\n}\n\nenum dbg_status qed_print_fw_asserts_results(struct qed_hwfn *p_hwfn,\n\t\t\t\t\t     u32 *dump_buf,\n\t\t\t\t\t     u32 num_dumped_dwords,\n\t\t\t\t\t     char *results_buf)\n{\n\tu32 parsed_buf_size;\n\n\treturn qed_parse_fw_asserts_dump(dump_buf,\n\t\t\t\t\t results_buf, &parsed_buf_size);\n}\n\nenum dbg_status qed_dbg_parse_attn(struct qed_hwfn *p_hwfn,\n\t\t\t\t   struct dbg_attn_block_result *results)\n{\n\tconst u32 *block_attn_name_offsets;\n\tconst char *attn_name_base;\n\tconst char *block_name;\n\tenum dbg_attn_type attn_type;\n\tu8 num_regs, i, j;\n\n\tnum_regs = GET_FIELD(results->data, DBG_ATTN_BLOCK_RESULT_NUM_REGS);\n\tattn_type = GET_FIELD(results->data, DBG_ATTN_BLOCK_RESULT_ATTN_TYPE);\n\tblock_name = qed_dbg_get_block_name(p_hwfn, results->block_id);\n\tif (!block_name)\n\t\treturn DBG_STATUS_INVALID_ARGS;\n\n\tif (!p_hwfn->dbg_arrays[BIN_BUF_DBG_ATTN_INDEXES].ptr ||\n\t    !p_hwfn->dbg_arrays[BIN_BUF_DBG_ATTN_NAME_OFFSETS].ptr ||\n\t    !p_hwfn->dbg_arrays[BIN_BUF_DBG_PARSING_STRINGS].ptr)\n\t\treturn DBG_STATUS_DBG_ARRAY_NOT_SET;\n\n\tblock_attn_name_offsets =\n\t    (u32 *)p_hwfn->dbg_arrays[BIN_BUF_DBG_ATTN_NAME_OFFSETS].ptr +\n\t    results->names_offset;\n\n\tattn_name_base = p_hwfn->dbg_arrays[BIN_BUF_DBG_PARSING_STRINGS].ptr;\n\n\t \n\tfor (i = 0; i < num_regs; i++) {\n\t\tstruct dbg_attn_bit_mapping *bit_mapping;\n\t\tstruct dbg_attn_reg_result *reg_result;\n\t\tu8 num_reg_attn, bit_idx = 0;\n\n\t\treg_result = &results->reg_results[i];\n\t\tnum_reg_attn = GET_FIELD(reg_result->data,\n\t\t\t\t\t DBG_ATTN_REG_RESULT_NUM_REG_ATTN);\n\t\tbit_mapping = (struct dbg_attn_bit_mapping *)\n\t\t    p_hwfn->dbg_arrays[BIN_BUF_DBG_ATTN_INDEXES].ptr +\n\t\t    reg_result->block_attn_offset;\n\n\t\t \n\t\tfor (j = 0; j < num_reg_attn; j++) {\n\t\t\tu16 attn_idx_val = GET_FIELD(bit_mapping[j].data,\n\t\t\t\t\t\t     DBG_ATTN_BIT_MAPPING_VAL);\n\t\t\tconst char *attn_name, *attn_type_str, *masked_str;\n\t\t\tu32 attn_name_offset;\n\t\t\tu32 sts_addr;\n\n\t\t\t \n\t\t\tif (GET_FIELD(bit_mapping[j].data,\n\t\t\t\t      DBG_ATTN_BIT_MAPPING_IS_UNUSED_BIT_CNT)) {\n\t\t\t\tbit_idx += (u8)attn_idx_val;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (reg_result->sts_val & BIT(bit_idx)) {\n\t\t\t\t \n\t\t\t\tattn_name_offset =\n\t\t\t\t\tblock_attn_name_offsets[attn_idx_val];\n\t\t\t\tattn_name = attn_name_base + attn_name_offset;\n\t\t\t\tattn_type_str =\n\t\t\t\t\t(attn_type ==\n\t\t\t\t\t ATTN_TYPE_INTERRUPT ? \"Interrupt\" :\n\t\t\t\t\t \"Parity\");\n\t\t\t\tmasked_str = reg_result->mask_val &\n\t\t\t\t\t     BIT(bit_idx) ?\n\t\t\t\t\t     \" [masked]\" : \"\";\n\t\t\t\tsts_addr =\n\t\t\t\tGET_FIELD(reg_result->data,\n\t\t\t\t\t  DBG_ATTN_REG_RESULT_STS_ADDRESS);\n\t\t\t\tDP_NOTICE(p_hwfn,\n\t\t\t\t\t  \"%s (%s) : %s [address 0x%08x, bit %d]%s\\n\",\n\t\t\t\t\t  block_name, attn_type_str, attn_name,\n\t\t\t\t\t  sts_addr * 4, bit_idx, masked_str);\n\t\t\t}\n\n\t\t\tbit_idx++;\n\t\t}\n\t}\n\n\treturn DBG_STATUS_OK;\n}\n\n \nstatic enum dbg_status\nqed_print_idle_chk_results_wrapper(struct qed_hwfn *p_hwfn,\n\t\t\t\t   u32 *dump_buf,\n\t\t\t\t   u32 num_dumped_dwords,\n\t\t\t\t   char *results_buf)\n{\n\tu32 num_errors, num_warnnings;\n\n\treturn qed_print_idle_chk_results(p_hwfn, dump_buf, num_dumped_dwords,\n\t\t\t\t\t  results_buf, &num_errors,\n\t\t\t\t\t  &num_warnnings);\n}\n\nstatic DEFINE_MUTEX(qed_dbg_lock);\n\n#define MAX_PHY_RESULT_BUFFER 9000\n\n \n\n#define GRC_NUM_STR_FUNCS 2\n#define IDLE_CHK_NUM_STR_FUNCS 1\n#define MCP_TRACE_NUM_STR_FUNCS 1\n#define REG_FIFO_NUM_STR_FUNCS 1\n#define IGU_FIFO_NUM_STR_FUNCS 1\n#define PROTECTION_OVERRIDE_NUM_STR_FUNCS 1\n#define FW_ASSERTS_NUM_STR_FUNCS 1\n#define ILT_NUM_STR_FUNCS 1\n#define PHY_NUM_STR_FUNCS 20\n\n \nstatic struct {\n\tchar *name;\n\tu32 num_funcs;\n\tenum dbg_status (*get_size)(struct qed_hwfn *p_hwfn,\n\t\t\t\t    struct qed_ptt *p_ptt, u32 *size);\n\tenum dbg_status (*perform_dump)(struct qed_hwfn *p_hwfn,\n\t\t\t\t\tstruct qed_ptt *p_ptt, u32 *dump_buf,\n\t\t\t\t\tu32 buf_size, u32 *dumped_dwords);\n\tenum dbg_status (*print_results)(struct qed_hwfn *p_hwfn,\n\t\t\t\t\t u32 *dump_buf, u32 num_dumped_dwords,\n\t\t\t\t\t char *results_buf);\n\tenum dbg_status (*results_buf_size)(struct qed_hwfn *p_hwfn,\n\t\t\t\t\t    u32 *dump_buf,\n\t\t\t\t\t    u32 num_dumped_dwords,\n\t\t\t\t\t    u32 *results_buf_size);\n\tconst struct qed_func_lookup *hsi_func_lookup;\n} qed_features_lookup[] = {\n\t{\n\t\"grc\", GRC_NUM_STR_FUNCS, qed_dbg_grc_get_dump_buf_size,\n\t\t    qed_dbg_grc_dump, NULL, NULL, NULL}, {\n\t\"idle_chk\", IDLE_CHK_NUM_STR_FUNCS,\n\t\t    qed_dbg_idle_chk_get_dump_buf_size,\n\t\t    qed_dbg_idle_chk_dump,\n\t\t    qed_print_idle_chk_results_wrapper,\n\t\t    qed_get_idle_chk_results_buf_size,\n\t\t    NULL}, {\n\t\"mcp_trace\", MCP_TRACE_NUM_STR_FUNCS,\n\t\t    qed_dbg_mcp_trace_get_dump_buf_size,\n\t\t    qed_dbg_mcp_trace_dump, qed_print_mcp_trace_results,\n\t\t    qed_get_mcp_trace_results_buf_size,\n\t\t    NULL}, {\n\t\"reg_fifo\", REG_FIFO_NUM_STR_FUNCS,\n\t\t    qed_dbg_reg_fifo_get_dump_buf_size,\n\t\t    qed_dbg_reg_fifo_dump, qed_print_reg_fifo_results,\n\t\t    qed_get_reg_fifo_results_buf_size,\n\t\t    NULL}, {\n\t\"igu_fifo\", IGU_FIFO_NUM_STR_FUNCS,\n\t\t    qed_dbg_igu_fifo_get_dump_buf_size,\n\t\t    qed_dbg_igu_fifo_dump, qed_print_igu_fifo_results,\n\t\t    qed_get_igu_fifo_results_buf_size,\n\t\t    NULL}, {\n\t\"protection_override\", PROTECTION_OVERRIDE_NUM_STR_FUNCS,\n\t\t    qed_dbg_protection_override_get_dump_buf_size,\n\t\t    qed_dbg_protection_override_dump,\n\t\t    qed_print_protection_override_results,\n\t\t    qed_get_protection_override_results_buf_size,\n\t\t    NULL}, {\n\t\"fw_asserts\", FW_ASSERTS_NUM_STR_FUNCS,\n\t\t    qed_dbg_fw_asserts_get_dump_buf_size,\n\t\t    qed_dbg_fw_asserts_dump,\n\t\t    qed_print_fw_asserts_results,\n\t\t    qed_get_fw_asserts_results_buf_size,\n\t\t    NULL}, {\n\t\"ilt\", ILT_NUM_STR_FUNCS, qed_dbg_ilt_get_dump_buf_size,\n\t\t    qed_dbg_ilt_dump, NULL, NULL, NULL},};\n\nstatic void qed_dbg_print_feature(u8 *p_text_buf, u32 text_size)\n{\n\tu32 i, precision = 80;\n\n\tif (!p_text_buf)\n\t\treturn;\n\n\tpr_notice(\"\\n%.*s\", precision, p_text_buf);\n\tfor (i = precision; i < text_size; i += precision)\n\t\tpr_cont(\"%.*s\", precision, p_text_buf + i);\n\tpr_cont(\"\\n\");\n}\n\n#define QED_RESULTS_BUF_MIN_SIZE 16\n \nstatic enum dbg_status format_feature(struct qed_hwfn *p_hwfn,\n\t\t\t\t      enum qed_dbg_features feature_idx)\n{\n\tstruct qed_dbg_feature *feature =\n\t    &p_hwfn->cdev->dbg_features[feature_idx];\n\tu32 txt_size_bytes, null_char_pos, i;\n\tu32 *dbuf, dwords;\n\tenum dbg_status rc;\n\tchar *text_buf;\n\n\t \n\tif (!qed_features_lookup[feature_idx].results_buf_size)\n\t\treturn DBG_STATUS_OK;\n\n\tdbuf = (u32 *)feature->dump_buf;\n\tdwords = feature->dumped_dwords;\n\n\t \n\trc = qed_features_lookup[feature_idx].results_buf_size(p_hwfn,\n\t\t\t\t\t\t\t       dbuf,\n\t\t\t\t\t\t\t       dwords,\n\t\t\t\t\t\t\t       &txt_size_bytes);\n\tif (rc != DBG_STATUS_OK)\n\t\treturn rc;\n\n\t \n\tnull_char_pos = txt_size_bytes - 1;\n\ttxt_size_bytes = (txt_size_bytes + 3) & ~0x3;\n\n\tif (txt_size_bytes < QED_RESULTS_BUF_MIN_SIZE) {\n\t\tDP_NOTICE(p_hwfn->cdev,\n\t\t\t  \"formatted size of feature was too small %d. Aborting\\n\",\n\t\t\t  txt_size_bytes);\n\t\treturn DBG_STATUS_INVALID_ARGS;\n\t}\n\n\t \n\ttext_buf = vzalloc(txt_size_bytes);\n\tif (!text_buf) {\n\t\tDP_NOTICE(p_hwfn->cdev,\n\t\t\t  \"failed to allocate text buffer. Aborting\\n\");\n\t\treturn DBG_STATUS_VIRT_MEM_ALLOC_FAILED;\n\t}\n\n\t \n\trc = qed_features_lookup[feature_idx].print_results(p_hwfn,\n\t\t\t\t\t\t\t    dbuf,\n\t\t\t\t\t\t\t    dwords,\n\t\t\t\t\t\t\t    text_buf);\n\tif (rc != DBG_STATUS_OK) {\n\t\tvfree(text_buf);\n\t\treturn rc;\n\t}\n\n\t \n\tfor (i = null_char_pos; i < txt_size_bytes; i++)\n\t\ttext_buf[i] = '\\n';\n\n\t \n\tif (p_hwfn->cdev->print_dbg_data)\n\t\tqed_dbg_print_feature(text_buf, txt_size_bytes);\n\n\t \n\tif (p_hwfn->cdev->dbg_bin_dump) {\n\t\tvfree(text_buf);\n\t\treturn rc;\n\t}\n\n\t \n\tvfree(feature->dump_buf);\n\tfeature->dump_buf = text_buf;\n\tfeature->buf_size = txt_size_bytes;\n\tfeature->dumped_dwords = txt_size_bytes / 4;\n\n\treturn rc;\n}\n\n#define MAX_DBG_FEATURE_SIZE_DWORDS\t0x3FFFFFFF\n\n \nstatic enum dbg_status qed_dbg_dump(struct qed_hwfn *p_hwfn,\n\t\t\t\t    struct qed_ptt *p_ptt,\n\t\t\t\t    enum qed_dbg_features feature_idx)\n{\n\tstruct qed_dbg_feature *feature =\n\t    &p_hwfn->cdev->dbg_features[feature_idx];\n\tu32 buf_size_dwords, *dbuf, *dwords;\n\tenum dbg_status rc;\n\n\tDP_NOTICE(p_hwfn->cdev, \"Collecting a debug feature [\\\"%s\\\"]\\n\",\n\t\t  qed_features_lookup[feature_idx].name);\n\n\t \n\tif (feature->dump_buf) {\n\t\tvfree(feature->dump_buf);\n\t\tfeature->dump_buf = NULL;\n\t}\n\n\t \n\trc = qed_features_lookup[feature_idx].get_size(p_hwfn, p_ptt,\n\t\t\t\t\t\t       &buf_size_dwords);\n\tif (rc != DBG_STATUS_OK && rc != DBG_STATUS_NVRAM_GET_IMAGE_FAILED)\n\t\treturn rc;\n\n\tif (buf_size_dwords > MAX_DBG_FEATURE_SIZE_DWORDS) {\n\t\tfeature->buf_size = 0;\n\t\tDP_NOTICE(p_hwfn->cdev,\n\t\t\t  \"Debug feature [\\\"%s\\\"] size (0x%x dwords) exceeds maximum size (0x%x dwords)\\n\",\n\t\t\t  qed_features_lookup[feature_idx].name,\n\t\t\t  buf_size_dwords, MAX_DBG_FEATURE_SIZE_DWORDS);\n\n\t\treturn DBG_STATUS_OK;\n\t}\n\n\tfeature->buf_size = buf_size_dwords * sizeof(u32);\n\tfeature->dump_buf = vmalloc(feature->buf_size);\n\tif (!feature->dump_buf)\n\t\treturn DBG_STATUS_VIRT_MEM_ALLOC_FAILED;\n\n\tdbuf = (u32 *)feature->dump_buf;\n\tdwords = &feature->dumped_dwords;\n\trc = qed_features_lookup[feature_idx].perform_dump(p_hwfn, p_ptt,\n\t\t\t\t\t\t\t   dbuf,\n\t\t\t\t\t\t\t   feature->buf_size /\n\t\t\t\t\t\t\t   sizeof(u32),\n\t\t\t\t\t\t\t   dwords);\n\n\t \n\tif (rc == DBG_STATUS_NVRAM_GET_IMAGE_FAILED)\n\t\treturn DBG_STATUS_OK;\n\n\tif (rc != DBG_STATUS_OK)\n\t\treturn rc;\n\n\t \n\trc = format_feature(p_hwfn, feature_idx);\n\treturn rc;\n}\n\nint qed_dbg_grc(struct qed_dev *cdev, void *buffer, u32 *num_dumped_bytes)\n{\n\treturn qed_dbg_feature(cdev, buffer, DBG_FEATURE_GRC, num_dumped_bytes);\n}\n\nint qed_dbg_grc_size(struct qed_dev *cdev)\n{\n\treturn qed_dbg_feature_size(cdev, DBG_FEATURE_GRC);\n}\n\nint qed_dbg_idle_chk(struct qed_dev *cdev, void *buffer, u32 *num_dumped_bytes)\n{\n\treturn qed_dbg_feature(cdev, buffer, DBG_FEATURE_IDLE_CHK,\n\t\t\t       num_dumped_bytes);\n}\n\nint qed_dbg_idle_chk_size(struct qed_dev *cdev)\n{\n\treturn qed_dbg_feature_size(cdev, DBG_FEATURE_IDLE_CHK);\n}\n\nint qed_dbg_reg_fifo(struct qed_dev *cdev, void *buffer, u32 *num_dumped_bytes)\n{\n\treturn qed_dbg_feature(cdev, buffer, DBG_FEATURE_REG_FIFO,\n\t\t\t       num_dumped_bytes);\n}\n\nint qed_dbg_reg_fifo_size(struct qed_dev *cdev)\n{\n\treturn qed_dbg_feature_size(cdev, DBG_FEATURE_REG_FIFO);\n}\n\nint qed_dbg_igu_fifo(struct qed_dev *cdev, void *buffer, u32 *num_dumped_bytes)\n{\n\treturn qed_dbg_feature(cdev, buffer, DBG_FEATURE_IGU_FIFO,\n\t\t\t       num_dumped_bytes);\n}\n\nint qed_dbg_igu_fifo_size(struct qed_dev *cdev)\n{\n\treturn qed_dbg_feature_size(cdev, DBG_FEATURE_IGU_FIFO);\n}\n\nstatic int qed_dbg_nvm_image_length(struct qed_hwfn *p_hwfn,\n\t\t\t\t    enum qed_nvm_images image_id, u32 *length)\n{\n\tstruct qed_nvm_image_att image_att;\n\tint rc;\n\n\t*length = 0;\n\trc = qed_mcp_get_nvm_image_att(p_hwfn, image_id, &image_att);\n\tif (rc)\n\t\treturn rc;\n\n\t*length = image_att.length;\n\n\treturn rc;\n}\n\nstatic int qed_dbg_nvm_image(struct qed_dev *cdev, void *buffer,\n\t\t\t     u32 *num_dumped_bytes,\n\t\t\t     enum qed_nvm_images image_id)\n{\n\tstruct qed_hwfn *p_hwfn =\n\t\t&cdev->hwfns[cdev->engine_for_debug];\n\tu32 len_rounded;\n\tint rc;\n\n\t*num_dumped_bytes = 0;\n\trc = qed_dbg_nvm_image_length(p_hwfn, image_id, &len_rounded);\n\tif (rc)\n\t\treturn rc;\n\n\tDP_NOTICE(p_hwfn->cdev,\n\t\t  \"Collecting a debug feature [\\\"nvram image %d\\\"]\\n\",\n\t\t  image_id);\n\n\tlen_rounded = roundup(len_rounded, sizeof(u32));\n\trc = qed_mcp_get_nvm_image(p_hwfn, image_id, buffer, len_rounded);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tif (image_id != QED_NVM_IMAGE_NVM_META)\n\t\tcpu_to_be32_array((__force __be32 *)buffer,\n\t\t\t\t  (const u32 *)buffer,\n\t\t\t\t  len_rounded / sizeof(u32));\n\n\t*num_dumped_bytes = len_rounded;\n\n\treturn rc;\n}\n\nint qed_dbg_protection_override(struct qed_dev *cdev, void *buffer,\n\t\t\t\tu32 *num_dumped_bytes)\n{\n\treturn qed_dbg_feature(cdev, buffer, DBG_FEATURE_PROTECTION_OVERRIDE,\n\t\t\t       num_dumped_bytes);\n}\n\nint qed_dbg_protection_override_size(struct qed_dev *cdev)\n{\n\treturn qed_dbg_feature_size(cdev, DBG_FEATURE_PROTECTION_OVERRIDE);\n}\n\nint qed_dbg_fw_asserts(struct qed_dev *cdev, void *buffer,\n\t\t       u32 *num_dumped_bytes)\n{\n\treturn qed_dbg_feature(cdev, buffer, DBG_FEATURE_FW_ASSERTS,\n\t\t\t       num_dumped_bytes);\n}\n\nint qed_dbg_fw_asserts_size(struct qed_dev *cdev)\n{\n\treturn qed_dbg_feature_size(cdev, DBG_FEATURE_FW_ASSERTS);\n}\n\nint qed_dbg_ilt(struct qed_dev *cdev, void *buffer, u32 *num_dumped_bytes)\n{\n\treturn qed_dbg_feature(cdev, buffer, DBG_FEATURE_ILT, num_dumped_bytes);\n}\n\nint qed_dbg_ilt_size(struct qed_dev *cdev)\n{\n\treturn qed_dbg_feature_size(cdev, DBG_FEATURE_ILT);\n}\n\nint qed_dbg_mcp_trace(struct qed_dev *cdev, void *buffer,\n\t\t      u32 *num_dumped_bytes)\n{\n\treturn qed_dbg_feature(cdev, buffer, DBG_FEATURE_MCP_TRACE,\n\t\t\t       num_dumped_bytes);\n}\n\nint qed_dbg_mcp_trace_size(struct qed_dev *cdev)\n{\n\treturn qed_dbg_feature_size(cdev, DBG_FEATURE_MCP_TRACE);\n}\n\n \n#define REGDUMP_HEADER_SIZE\t\t\tsizeof(u32)\n#define REGDUMP_HEADER_SIZE_SHIFT\t\t0\n#define REGDUMP_HEADER_SIZE_MASK\t\t0xffffff\n#define REGDUMP_HEADER_FEATURE_SHIFT\t\t24\n#define REGDUMP_HEADER_FEATURE_MASK\t\t0x1f\n#define REGDUMP_HEADER_BIN_DUMP_SHIFT\t\t29\n#define REGDUMP_HEADER_BIN_DUMP_MASK\t\t0x1\n#define REGDUMP_HEADER_OMIT_ENGINE_SHIFT\t30\n#define REGDUMP_HEADER_OMIT_ENGINE_MASK\t\t0x1\n#define REGDUMP_HEADER_ENGINE_SHIFT\t\t31\n#define REGDUMP_HEADER_ENGINE_MASK\t\t0x1\n#define REGDUMP_MAX_SIZE\t\t\t0x1000000\n#define ILT_DUMP_MAX_SIZE\t\t\t(1024 * 1024 * 15)\n\nenum debug_print_features {\n\tOLD_MODE = 0,\n\tIDLE_CHK = 1,\n\tGRC_DUMP = 2,\n\tMCP_TRACE = 3,\n\tREG_FIFO = 4,\n\tPROTECTION_OVERRIDE = 5,\n\tIGU_FIFO = 6,\n\tPHY = 7,\n\tFW_ASSERTS = 8,\n\tNVM_CFG1 = 9,\n\tDEFAULT_CFG = 10,\n\tNVM_META = 11,\n\tMDUMP = 12,\n\tILT_DUMP = 13,\n};\n\nstatic u32 qed_calc_regdump_header(struct qed_dev *cdev,\n\t\t\t\t   enum debug_print_features feature,\n\t\t\t\t   int engine, u32 feature_size,\n\t\t\t\t   u8 omit_engine, u8 dbg_bin_dump)\n{\n\tu32 res = 0;\n\n\tSET_FIELD(res, REGDUMP_HEADER_SIZE, feature_size);\n\tif (res != feature_size)\n\t\tDP_NOTICE(cdev,\n\t\t\t  \"Feature %d is too large (size 0x%x) and will corrupt the dump\\n\",\n\t\t\t  feature, feature_size);\n\n\tSET_FIELD(res, REGDUMP_HEADER_FEATURE, feature);\n\tSET_FIELD(res, REGDUMP_HEADER_BIN_DUMP, dbg_bin_dump);\n\tSET_FIELD(res, REGDUMP_HEADER_OMIT_ENGINE, omit_engine);\n\tSET_FIELD(res, REGDUMP_HEADER_ENGINE, engine);\n\n\treturn res;\n}\n\nint qed_dbg_all_data(struct qed_dev *cdev, void *buffer)\n{\n\tu8 cur_engine, omit_engine = 0, org_engine;\n\tstruct qed_hwfn *p_hwfn = &cdev->hwfns[cdev->engine_for_debug];\n\tstruct dbg_tools_data *dev_data = &p_hwfn->dbg_info;\n\tint grc_params[MAX_DBG_GRC_PARAMS], rc, i;\n\tu32 offset = 0, feature_size;\n\n\tfor (i = 0; i < MAX_DBG_GRC_PARAMS; i++)\n\t\tgrc_params[i] = dev_data->grc.param_val[i];\n\n\tif (!QED_IS_CMT(cdev))\n\t\tomit_engine = 1;\n\n\tcdev->dbg_bin_dump = 1;\n\tmutex_lock(&qed_dbg_lock);\n\n\torg_engine = qed_get_debug_engine(cdev);\n\tfor (cur_engine = 0; cur_engine < cdev->num_hwfns; cur_engine++) {\n\t\t \n\t\tDP_VERBOSE(cdev, QED_MSG_DEBUG,\n\t\t\t   \"obtaining idle_chk and grcdump for current engine\\n\");\n\t\tqed_set_debug_engine(cdev, cur_engine);\n\n\t\t \n\t\trc = qed_dbg_idle_chk(cdev, (u8 *)buffer + offset +\n\t\t\t\t      REGDUMP_HEADER_SIZE, &feature_size);\n\t\tif (!rc) {\n\t\t\t*(u32 *)((u8 *)buffer + offset) =\n\t\t\t    qed_calc_regdump_header(cdev, IDLE_CHK,\n\t\t\t\t\t\t    cur_engine,\n\t\t\t\t\t\t    feature_size,\n\t\t\t\t\t\t    omit_engine,\n\t\t\t\t\t\t    cdev->dbg_bin_dump);\n\t\t\toffset += (feature_size + REGDUMP_HEADER_SIZE);\n\t\t} else {\n\t\t\tDP_ERR(cdev, \"qed_dbg_idle_chk failed. rc = %d\\n\", rc);\n\t\t}\n\n\t\t \n\t\trc = qed_dbg_idle_chk(cdev, (u8 *)buffer + offset +\n\t\t\t\t      REGDUMP_HEADER_SIZE, &feature_size);\n\t\tif (!rc) {\n\t\t\t*(u32 *)((u8 *)buffer + offset) =\n\t\t\t    qed_calc_regdump_header(cdev, IDLE_CHK,\n\t\t\t\t\t\t    cur_engine,\n\t\t\t\t\t\t    feature_size,\n\t\t\t\t\t\t    omit_engine,\n\t\t\t\t\t\t    cdev->dbg_bin_dump);\n\t\t\toffset += (feature_size + REGDUMP_HEADER_SIZE);\n\t\t} else {\n\t\t\tDP_ERR(cdev, \"qed_dbg_idle_chk failed. rc = %d\\n\", rc);\n\t\t}\n\n\t\t \n\t\trc = qed_dbg_reg_fifo(cdev, (u8 *)buffer + offset +\n\t\t\t\t      REGDUMP_HEADER_SIZE, &feature_size);\n\t\tif (!rc) {\n\t\t\t*(u32 *)((u8 *)buffer + offset) =\n\t\t\t    qed_calc_regdump_header(cdev, REG_FIFO,\n\t\t\t\t\t\t    cur_engine,\n\t\t\t\t\t\t    feature_size,\n\t\t\t\t\t\t    omit_engine,\n\t\t\t\t\t\t    cdev->dbg_bin_dump);\n\t\t\toffset += (feature_size + REGDUMP_HEADER_SIZE);\n\t\t} else {\n\t\t\tDP_ERR(cdev, \"qed_dbg_reg_fifo failed. rc = %d\\n\", rc);\n\t\t}\n\n\t\t \n\t\trc = qed_dbg_igu_fifo(cdev, (u8 *)buffer + offset +\n\t\t\t\t      REGDUMP_HEADER_SIZE, &feature_size);\n\t\tif (!rc) {\n\t\t\t*(u32 *)((u8 *)buffer + offset) =\n\t\t\t    qed_calc_regdump_header(cdev, IGU_FIFO,\n\t\t\t\t\t\t    cur_engine,\n\t\t\t\t\t\t    feature_size,\n\t\t\t\t\t\t    omit_engine,\n\t\t\t\t\t\t    cdev->dbg_bin_dump);\n\t\t\toffset += (feature_size + REGDUMP_HEADER_SIZE);\n\t\t} else {\n\t\t\tDP_ERR(cdev, \"qed_dbg_igu_fifo failed. rc = %d\", rc);\n\t\t}\n\n\t\t \n\t\trc = qed_dbg_protection_override(cdev, (u8 *)buffer + offset +\n\t\t\t\t\t\t REGDUMP_HEADER_SIZE,\n\t\t\t\t\t\t &feature_size);\n\t\tif (!rc) {\n\t\t\t*(u32 *)((u8 *)buffer + offset) =\n\t\t\t    qed_calc_regdump_header(cdev,\n\t\t\t\t\t\t    PROTECTION_OVERRIDE,\n\t\t\t\t\t\t    cur_engine,\n\t\t\t\t\t\t    feature_size,\n\t\t\t\t\t\t    omit_engine,\n\t\t\t\t\t\t    cdev->dbg_bin_dump);\n\t\t\toffset += (feature_size + REGDUMP_HEADER_SIZE);\n\t\t} else {\n\t\t\tDP_ERR(cdev,\n\t\t\t       \"qed_dbg_protection_override failed. rc = %d\\n\",\n\t\t\t       rc);\n\t\t}\n\n\t\t \n\t\trc = qed_dbg_fw_asserts(cdev, (u8 *)buffer + offset +\n\t\t\t\t\tREGDUMP_HEADER_SIZE, &feature_size);\n\t\tif (!rc) {\n\t\t\t*(u32 *)((u8 *)buffer + offset) =\n\t\t\t    qed_calc_regdump_header(cdev, FW_ASSERTS,\n\t\t\t\t\t\t    cur_engine,\n\t\t\t\t\t\t    feature_size,\n\t\t\t\t\t\t    omit_engine,\n\t\t\t\t\t\t    cdev->dbg_bin_dump);\n\t\t\toffset += (feature_size + REGDUMP_HEADER_SIZE);\n\t\t} else {\n\t\t\tDP_ERR(cdev, \"qed_dbg_fw_asserts failed. rc = %d\\n\",\n\t\t\t       rc);\n\t\t}\n\n\t\tfeature_size = qed_dbg_ilt_size(cdev);\n\t\tif (!cdev->disable_ilt_dump && feature_size <\n\t\t    ILT_DUMP_MAX_SIZE) {\n\t\t\trc = qed_dbg_ilt(cdev, (u8 *)buffer + offset +\n\t\t\t\t\t REGDUMP_HEADER_SIZE, &feature_size);\n\t\t\tif (!rc) {\n\t\t\t\t*(u32 *)((u8 *)buffer + offset) =\n\t\t\t\t    qed_calc_regdump_header(cdev, ILT_DUMP,\n\t\t\t\t\t\t\t    cur_engine,\n\t\t\t\t\t\t\t    feature_size,\n\t\t\t\t\t\t\t    omit_engine,\n\t\t\t\t\t\t\t    cdev->dbg_bin_dump);\n\t\t\t\toffset += (feature_size + REGDUMP_HEADER_SIZE);\n\t\t\t} else {\n\t\t\t\tDP_ERR(cdev, \"qed_dbg_ilt failed. rc = %d\\n\",\n\t\t\t\t       rc);\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tfor (i = 0; i < MAX_DBG_GRC_PARAMS; i++)\n\t\t\tdev_data->grc.param_val[i] = grc_params[i];\n\n\t\trc = qed_dbg_grc(cdev, (u8 *)buffer + offset +\n\t\t\t\t REGDUMP_HEADER_SIZE, &feature_size);\n\t\tif (!rc) {\n\t\t\t*(u32 *)((u8 *)buffer + offset) =\n\t\t\t    qed_calc_regdump_header(cdev, GRC_DUMP,\n\t\t\t\t\t\t    cur_engine,\n\t\t\t\t\t\t    feature_size,\n\t\t\t\t\t\t    omit_engine,\n\t\t\t\t\t\t    cdev->dbg_bin_dump);\n\t\t\toffset += (feature_size + REGDUMP_HEADER_SIZE);\n\t\t} else {\n\t\t\tDP_ERR(cdev, \"qed_dbg_grc failed. rc = %d\", rc);\n\t\t}\n\t}\n\n\tqed_set_debug_engine(cdev, org_engine);\n\n\t \n\trc = qed_dbg_mcp_trace(cdev, (u8 *)buffer + offset +\n\t\t\t       REGDUMP_HEADER_SIZE, &feature_size);\n\tif (!rc) {\n\t\t*(u32 *)((u8 *)buffer + offset) =\n\t\t    qed_calc_regdump_header(cdev, MCP_TRACE, cur_engine,\n\t\t\t\t\t    feature_size, omit_engine,\n\t\t\t\t\t    cdev->dbg_bin_dump);\n\t\toffset += (feature_size + REGDUMP_HEADER_SIZE);\n\t} else {\n\t\tDP_ERR(cdev, \"qed_dbg_mcp_trace failed. rc = %d\\n\", rc);\n\t}\n\n\t \n\trc = qed_dbg_nvm_image(cdev,\n\t\t\t       (u8 *)buffer + offset +\n\t\t\t       REGDUMP_HEADER_SIZE, &feature_size,\n\t\t\t       QED_NVM_IMAGE_NVM_CFG1);\n\tif (!rc) {\n\t\t*(u32 *)((u8 *)buffer + offset) =\n\t\t    qed_calc_regdump_header(cdev, NVM_CFG1, cur_engine,\n\t\t\t\t\t    feature_size, omit_engine,\n\t\t\t\t\t    cdev->dbg_bin_dump);\n\t\toffset += (feature_size + REGDUMP_HEADER_SIZE);\n\t} else if (rc != -ENOENT) {\n\t\tDP_ERR(cdev,\n\t\t       \"qed_dbg_nvm_image failed for image  %d (%s), rc = %d\\n\",\n\t\t       QED_NVM_IMAGE_NVM_CFG1, \"QED_NVM_IMAGE_NVM_CFG1\",\n\t\t       rc);\n\t}\n\n\t\t \n\trc = qed_dbg_nvm_image(cdev,\n\t\t\t       (u8 *)buffer + offset +\n\t\t\t       REGDUMP_HEADER_SIZE, &feature_size,\n\t\t\t       QED_NVM_IMAGE_DEFAULT_CFG);\n\tif (!rc) {\n\t\t*(u32 *)((u8 *)buffer + offset) =\n\t\t    qed_calc_regdump_header(cdev, DEFAULT_CFG,\n\t\t\t\t\t    cur_engine, feature_size,\n\t\t\t\t\t    omit_engine,\n\t\t\t\t\t    cdev->dbg_bin_dump);\n\t\toffset += (feature_size + REGDUMP_HEADER_SIZE);\n\t} else if (rc != -ENOENT) {\n\t\tDP_ERR(cdev,\n\t\t       \"qed_dbg_nvm_image failed for image %d (%s), rc = %d\\n\",\n\t\t       QED_NVM_IMAGE_DEFAULT_CFG,\n\t\t       \"QED_NVM_IMAGE_DEFAULT_CFG\", rc);\n\t}\n\n\t \n\trc = qed_dbg_nvm_image(cdev,\n\t\t\t       (u8 *)buffer + offset +\n\t\t\t       REGDUMP_HEADER_SIZE, &feature_size,\n\t\t\t       QED_NVM_IMAGE_NVM_META);\n\tif (!rc) {\n\t\t*(u32 *)((u8 *)buffer + offset) =\n\t\t    qed_calc_regdump_header(cdev, NVM_META, cur_engine,\n\t\t\t\t\t    feature_size, omit_engine,\n\t\t\t\t\t    cdev->dbg_bin_dump);\n\t\toffset += (feature_size + REGDUMP_HEADER_SIZE);\n\t} else if (rc != -ENOENT) {\n\t\tDP_ERR(cdev,\n\t\t       \"qed_dbg_nvm_image failed for image %d (%s), rc = %d\\n\",\n\t\t       QED_NVM_IMAGE_NVM_META, \"QED_NVM_IMAGE_NVM_META\",\n\t\t       rc);\n\t}\n\n\t \n\trc = qed_dbg_nvm_image(cdev, (u8 *)buffer + offset +\n\t\t\t       REGDUMP_HEADER_SIZE, &feature_size,\n\t\t\t       QED_NVM_IMAGE_MDUMP);\n\tif (!rc) {\n\t\t*(u32 *)((u8 *)buffer + offset) =\n\t\t    qed_calc_regdump_header(cdev, MDUMP, cur_engine,\n\t\t\t\t\t    feature_size, omit_engine,\n\t\t\t\t\t    cdev->dbg_bin_dump);\n\t\toffset += (feature_size + REGDUMP_HEADER_SIZE);\n\t} else if (rc != -ENOENT) {\n\t\tDP_ERR(cdev,\n\t\t       \"qed_dbg_nvm_image failed for image %d (%s), rc = %d\\n\",\n\t\t       QED_NVM_IMAGE_MDUMP, \"QED_NVM_IMAGE_MDUMP\", rc);\n\t}\n\n\tmutex_unlock(&qed_dbg_lock);\n\tcdev->dbg_bin_dump = 0;\n\n\treturn 0;\n}\n\nint qed_dbg_all_data_size(struct qed_dev *cdev)\n{\n\tu32 regs_len = 0, image_len = 0, ilt_len = 0, total_ilt_len = 0;\n\tstruct qed_hwfn *p_hwfn = &cdev->hwfns[cdev->engine_for_debug];\n\tu8 cur_engine, org_engine;\n\n\tcdev->disable_ilt_dump = false;\n\torg_engine = qed_get_debug_engine(cdev);\n\tfor (cur_engine = 0; cur_engine < cdev->num_hwfns; cur_engine++) {\n\t\t \n\t\tDP_VERBOSE(cdev, QED_MSG_DEBUG,\n\t\t\t   \"calculating idle_chk and grcdump register length for current engine\\n\");\n\t\tqed_set_debug_engine(cdev, cur_engine);\n\t\tregs_len += REGDUMP_HEADER_SIZE + qed_dbg_idle_chk_size(cdev) +\n\t\t    REGDUMP_HEADER_SIZE + qed_dbg_idle_chk_size(cdev) +\n\t\t    REGDUMP_HEADER_SIZE + qed_dbg_grc_size(cdev) +\n\t\t    REGDUMP_HEADER_SIZE + qed_dbg_reg_fifo_size(cdev) +\n\t\t    REGDUMP_HEADER_SIZE + qed_dbg_igu_fifo_size(cdev) +\n\t\t    REGDUMP_HEADER_SIZE +\n\t\t    qed_dbg_protection_override_size(cdev) +\n\t\t    REGDUMP_HEADER_SIZE + qed_dbg_fw_asserts_size(cdev);\n\t\tilt_len = REGDUMP_HEADER_SIZE + qed_dbg_ilt_size(cdev);\n\t\tif (ilt_len < ILT_DUMP_MAX_SIZE) {\n\t\t\ttotal_ilt_len += ilt_len;\n\t\t\tregs_len += ilt_len;\n\t\t}\n\t}\n\n\tqed_set_debug_engine(cdev, org_engine);\n\n\t \n\tregs_len += REGDUMP_HEADER_SIZE + qed_dbg_mcp_trace_size(cdev) +\n\t    REGDUMP_HEADER_SIZE + qed_dbg_phy_size(cdev);\n\tqed_dbg_nvm_image_length(p_hwfn, QED_NVM_IMAGE_NVM_CFG1, &image_len);\n\tif (image_len)\n\t\tregs_len += REGDUMP_HEADER_SIZE + image_len;\n\tqed_dbg_nvm_image_length(p_hwfn, QED_NVM_IMAGE_DEFAULT_CFG, &image_len);\n\tif (image_len)\n\t\tregs_len += REGDUMP_HEADER_SIZE + image_len;\n\tqed_dbg_nvm_image_length(p_hwfn, QED_NVM_IMAGE_NVM_META, &image_len);\n\tif (image_len)\n\t\tregs_len += REGDUMP_HEADER_SIZE + image_len;\n\tqed_dbg_nvm_image_length(p_hwfn, QED_NVM_IMAGE_MDUMP, &image_len);\n\tif (image_len)\n\t\tregs_len += REGDUMP_HEADER_SIZE + image_len;\n\n\tif (regs_len > REGDUMP_MAX_SIZE) {\n\t\tDP_VERBOSE(cdev, QED_MSG_DEBUG,\n\t\t\t   \"Dump exceeds max size 0x%x, disable ILT dump\\n\",\n\t\t\t   REGDUMP_MAX_SIZE);\n\t\tcdev->disable_ilt_dump = true;\n\t\tregs_len -= total_ilt_len;\n\t}\n\n\treturn regs_len;\n}\n\nint qed_dbg_feature(struct qed_dev *cdev, void *buffer,\n\t\t    enum qed_dbg_features feature, u32 *num_dumped_bytes)\n{\n\tstruct qed_dbg_feature *qed_feature = &cdev->dbg_features[feature];\n\tstruct qed_hwfn *p_hwfn = &cdev->hwfns[cdev->engine_for_debug];\n\tenum dbg_status dbg_rc;\n\tstruct qed_ptt *p_ptt;\n\tint rc = 0;\n\n\t \n\tp_ptt = qed_ptt_acquire(p_hwfn);\n\tif (!p_ptt)\n\t\treturn -EINVAL;\n\n\t \n\tdbg_rc = qed_dbg_dump(p_hwfn, p_ptt, feature);\n\tif (dbg_rc != DBG_STATUS_OK) {\n\t\tDP_VERBOSE(cdev, QED_MSG_DEBUG, \"%s\\n\",\n\t\t\t   qed_dbg_get_status_str(dbg_rc));\n\t\t*num_dumped_bytes = 0;\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tDP_VERBOSE(cdev, QED_MSG_DEBUG,\n\t\t   \"copying debugfs feature to external buffer\\n\");\n\tmemcpy(buffer, qed_feature->dump_buf, qed_feature->buf_size);\n\t*num_dumped_bytes = cdev->dbg_features[feature].dumped_dwords *\n\t\t\t    4;\n\nout:\n\tqed_ptt_release(p_hwfn, p_ptt);\n\treturn rc;\n}\n\nint qed_dbg_feature_size(struct qed_dev *cdev, enum qed_dbg_features feature)\n{\n\tstruct qed_dbg_feature *qed_feature = &cdev->dbg_features[feature];\n\tstruct qed_hwfn *p_hwfn = &cdev->hwfns[cdev->engine_for_debug];\n\tstruct qed_ptt *p_ptt = qed_ptt_acquire(p_hwfn);\n\tu32 buf_size_dwords;\n\tenum dbg_status rc;\n\n\tif (!p_ptt)\n\t\treturn -EINVAL;\n\n\trc = qed_features_lookup[feature].get_size(p_hwfn, p_ptt,\n\t\t\t\t\t\t   &buf_size_dwords);\n\tif (rc != DBG_STATUS_OK)\n\t\tbuf_size_dwords = 0;\n\n\t \n\tif (buf_size_dwords > MAX_DBG_FEATURE_SIZE_DWORDS)\n\t\tbuf_size_dwords = 0;\n\n\tqed_ptt_release(p_hwfn, p_ptt);\n\tqed_feature->buf_size = buf_size_dwords * sizeof(u32);\n\treturn qed_feature->buf_size;\n}\n\nint qed_dbg_phy_size(struct qed_dev *cdev)\n{\n\t \n\treturn MAX_PHY_RESULT_BUFFER * (1 + qed_device_num_ports(cdev));\n}\n\nu8 qed_get_debug_engine(struct qed_dev *cdev)\n{\n\treturn cdev->engine_for_debug;\n}\n\nvoid qed_set_debug_engine(struct qed_dev *cdev, int engine_number)\n{\n\tDP_VERBOSE(cdev, QED_MSG_DEBUG, \"set debug engine to %d\\n\",\n\t\t   engine_number);\n\tcdev->engine_for_debug = engine_number;\n}\n\nvoid qed_dbg_pf_init(struct qed_dev *cdev)\n{\n\tconst u8 *dbg_values = NULL;\n\tint i;\n\n\t \n\tqed_dbg_set_app_ver(TOOLS_VERSION);\n\n\t \n\tdbg_values = cdev->firmware->data + *(u32 *)cdev->firmware->data;\n\n\tfor_each_hwfn(cdev, i) {\n\t\tqed_dbg_set_bin_ptr(&cdev->hwfns[i], dbg_values);\n\t\tqed_dbg_user_set_bin_ptr(&cdev->hwfns[i], dbg_values);\n\t}\n\n\t \n\tcdev->engine_for_debug = 0;\n}\n\nvoid qed_dbg_pf_exit(struct qed_dev *cdev)\n{\n\tstruct qed_dbg_feature *feature = NULL;\n\tenum qed_dbg_features feature_idx;\n\n\t \n\tfor (feature_idx = 0; feature_idx < DBG_FEATURE_NUM; feature_idx++) {\n\t\tfeature = &cdev->dbg_features[feature_idx];\n\t\tif (feature->dump_buf) {\n\t\t\tvfree(feature->dump_buf);\n\t\t\tfeature->dump_buf = NULL;\n\t\t}\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}