{
  "module_name": "qed_iwarp.c",
  "hash_id": "45272f588376f0bc61847ff00cc28f04f8297ed94f24fe231d5a4dfdafc02b30",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/qlogic/qed/qed_iwarp.c",
  "human_readable_source": "\n \n\n#include <linux/if_ether.h>\n#include <linux/if_vlan.h>\n#include <linux/ip.h>\n#include <linux/ipv6.h>\n#include <linux/spinlock.h>\n#include <linux/tcp.h>\n#include \"qed_cxt.h\"\n#include \"qed_hw.h\"\n#include \"qed_ll2.h\"\n#include \"qed_rdma.h\"\n#include \"qed_reg_addr.h\"\n#include \"qed_sp.h\"\n#include \"qed_ooo.h\"\n\n#define QED_IWARP_ORD_DEFAULT\t\t32\n#define QED_IWARP_IRD_DEFAULT\t\t32\n#define QED_IWARP_MAX_FW_MSS\t\t4120\n\n#define QED_EP_SIG 0xecabcdef\n\nstruct mpa_v2_hdr {\n\t__be16 ird;\n\t__be16 ord;\n};\n\n#define MPA_V2_PEER2PEER_MODEL  0x8000\n#define MPA_V2_SEND_RTR         0x4000\t \n#define MPA_V2_READ_RTR         0x4000\t \n#define MPA_V2_WRITE_RTR        0x8000\n#define MPA_V2_IRD_ORD_MASK     0x3FFF\n\n#define MPA_REV2(_mpa_rev) ((_mpa_rev) == MPA_NEGOTIATION_TYPE_ENHANCED)\n\n#define QED_IWARP_INVALID_TCP_CID\t0xffffffff\n\n#define QED_IWARP_RCV_WND_SIZE_DEF_BB_2P (200 * 1024)\n#define QED_IWARP_RCV_WND_SIZE_DEF_BB_4P (100 * 1024)\n#define QED_IWARP_RCV_WND_SIZE_DEF_AH_2P (150 * 1024)\n#define QED_IWARP_RCV_WND_SIZE_DEF_AH_4P (90 * 1024)\n\n#define QED_IWARP_RCV_WND_SIZE_MIN\t(0xffff)\n#define TIMESTAMP_HEADER_SIZE\t\t(12)\n#define QED_IWARP_MAX_FIN_RT_DEFAULT\t(2)\n\n#define QED_IWARP_TS_EN\t\t\tBIT(0)\n#define QED_IWARP_DA_EN\t\t\tBIT(1)\n#define QED_IWARP_PARAM_CRC_NEEDED\t(1)\n#define QED_IWARP_PARAM_P2P\t\t(1)\n\n#define QED_IWARP_DEF_MAX_RT_TIME\t(0)\n#define QED_IWARP_DEF_CWND_FACTOR\t(4)\n#define QED_IWARP_DEF_KA_MAX_PROBE_CNT\t(5)\n#define QED_IWARP_DEF_KA_TIMEOUT\t(1200000)\t \n#define QED_IWARP_DEF_KA_INTERVAL\t(1000)\t\t \n\nstatic int qed_iwarp_async_event(struct qed_hwfn *p_hwfn, u8 fw_event_code,\n\t\t\t\t __le16 echo, union event_ring_data *data,\n\t\t\t\t u8 fw_return_code);\n\n \nvoid qed_iwarp_init_devinfo(struct qed_hwfn *p_hwfn)\n{\n\tstruct qed_rdma_device *dev = p_hwfn->p_rdma_info->dev;\n\n\tdev->max_inline = IWARP_REQ_MAX_INLINE_DATA_SIZE;\n\tdev->max_qp = min_t(u32,\n\t\t\t    IWARP_MAX_QPS,\n\t\t\t    p_hwfn->p_rdma_info->num_qps) -\n\t\t      QED_IWARP_PREALLOC_CNT;\n\n\tdev->max_cq = dev->max_qp;\n\n\tdev->max_qp_resp_rd_atomic_resc = QED_IWARP_IRD_DEFAULT;\n\tdev->max_qp_req_rd_atomic_resc = QED_IWARP_ORD_DEFAULT;\n}\n\nvoid qed_iwarp_init_hw(struct qed_hwfn *p_hwfn, struct qed_ptt *p_ptt)\n{\n\tp_hwfn->rdma_prs_search_reg = PRS_REG_SEARCH_TCP;\n\tqed_wr(p_hwfn, p_ptt, p_hwfn->rdma_prs_search_reg, 1);\n\tp_hwfn->b_rdma_enabled_in_prs = true;\n}\n\n \nstatic void qed_iwarp_cid_cleaned(struct qed_hwfn *p_hwfn, u32 cid)\n{\n\tcid -= qed_cxt_get_proto_cid_start(p_hwfn, p_hwfn->p_rdma_info->proto);\n\n\tspin_lock_bh(&p_hwfn->p_rdma_info->lock);\n\n\tif (cid < QED_IWARP_PREALLOC_CNT)\n\t\tqed_bmap_release_id(p_hwfn, &p_hwfn->p_rdma_info->tcp_cid_map,\n\t\t\t\t    cid);\n\telse\n\t\tqed_bmap_release_id(p_hwfn, &p_hwfn->p_rdma_info->cid_map, cid);\n\n\tspin_unlock_bh(&p_hwfn->p_rdma_info->lock);\n}\n\nvoid\nqed_iwarp_init_fw_ramrod(struct qed_hwfn *p_hwfn,\n\t\t\t struct iwarp_init_func_ramrod_data *p_ramrod)\n{\n\tp_ramrod->iwarp.ll2_ooo_q_index =\n\t    RESC_START(p_hwfn, QED_LL2_RAM_QUEUE) +\n\t    p_hwfn->p_rdma_info->iwarp.ll2_ooo_handle;\n\n\tp_ramrod->tcp.tx_sws_timer = cpu_to_le16(QED_TX_SWS_TIMER_DFLT);\n\tp_ramrod->tcp.two_msl_timer = cpu_to_le32(QED_TWO_MSL_TIMER_DFLT);\n\tp_ramrod->tcp.max_fin_rt = QED_IWARP_MAX_FIN_RT_DEFAULT;\n\n\treturn;\n}\n\nstatic int qed_iwarp_alloc_cid(struct qed_hwfn *p_hwfn, u32 *cid)\n{\n\tint rc;\n\n\tspin_lock_bh(&p_hwfn->p_rdma_info->lock);\n\trc = qed_rdma_bmap_alloc_id(p_hwfn, &p_hwfn->p_rdma_info->cid_map, cid);\n\tspin_unlock_bh(&p_hwfn->p_rdma_info->lock);\n\tif (rc) {\n\t\tDP_NOTICE(p_hwfn, \"Failed in allocating iwarp cid\\n\");\n\t\treturn rc;\n\t}\n\t*cid += qed_cxt_get_proto_cid_start(p_hwfn, p_hwfn->p_rdma_info->proto);\n\n\trc = qed_cxt_dynamic_ilt_alloc(p_hwfn, QED_ELEM_CXT, *cid);\n\tif (rc)\n\t\tqed_iwarp_cid_cleaned(p_hwfn, *cid);\n\n\treturn rc;\n}\n\nstatic void qed_iwarp_set_tcp_cid(struct qed_hwfn *p_hwfn, u32 cid)\n{\n\tcid -= qed_cxt_get_proto_cid_start(p_hwfn, p_hwfn->p_rdma_info->proto);\n\n\tspin_lock_bh(&p_hwfn->p_rdma_info->lock);\n\tqed_bmap_set_id(p_hwfn, &p_hwfn->p_rdma_info->tcp_cid_map, cid);\n\tspin_unlock_bh(&p_hwfn->p_rdma_info->lock);\n}\n\n \nstatic int qed_iwarp_alloc_tcp_cid(struct qed_hwfn *p_hwfn, u32 *cid)\n{\n\tint rc;\n\n\tspin_lock_bh(&p_hwfn->p_rdma_info->lock);\n\n\trc = qed_rdma_bmap_alloc_id(p_hwfn,\n\t\t\t\t    &p_hwfn->p_rdma_info->tcp_cid_map, cid);\n\n\tspin_unlock_bh(&p_hwfn->p_rdma_info->lock);\n\n\tif (rc) {\n\t\tDP_VERBOSE(p_hwfn, QED_MSG_RDMA,\n\t\t\t   \"can't allocate iwarp tcp cid max-count=%d\\n\",\n\t\t\t   p_hwfn->p_rdma_info->tcp_cid_map.max_count);\n\n\t\t*cid = QED_IWARP_INVALID_TCP_CID;\n\t\treturn rc;\n\t}\n\n\t*cid += qed_cxt_get_proto_cid_start(p_hwfn,\n\t\t\t\t\t    p_hwfn->p_rdma_info->proto);\n\treturn 0;\n}\n\nint qed_iwarp_create_qp(struct qed_hwfn *p_hwfn,\n\t\t\tstruct qed_rdma_qp *qp,\n\t\t\tstruct qed_rdma_create_qp_out_params *out_params)\n{\n\tstruct iwarp_create_qp_ramrod_data *p_ramrod;\n\tstruct qed_sp_init_data init_data;\n\tstruct qed_spq_entry *p_ent;\n\tu16 physical_queue;\n\tu32 cid;\n\tint rc;\n\n\tqp->shared_queue = dma_alloc_coherent(&p_hwfn->cdev->pdev->dev,\n\t\t\t\t\t      IWARP_SHARED_QUEUE_PAGE_SIZE,\n\t\t\t\t\t      &qp->shared_queue_phys_addr,\n\t\t\t\t\t      GFP_KERNEL);\n\tif (!qp->shared_queue)\n\t\treturn -ENOMEM;\n\n\tout_params->sq_pbl_virt = (u8 *)qp->shared_queue +\n\t    IWARP_SHARED_QUEUE_PAGE_SQ_PBL_OFFSET;\n\tout_params->sq_pbl_phys = qp->shared_queue_phys_addr +\n\t    IWARP_SHARED_QUEUE_PAGE_SQ_PBL_OFFSET;\n\tout_params->rq_pbl_virt = (u8 *)qp->shared_queue +\n\t    IWARP_SHARED_QUEUE_PAGE_RQ_PBL_OFFSET;\n\tout_params->rq_pbl_phys = qp->shared_queue_phys_addr +\n\t    IWARP_SHARED_QUEUE_PAGE_RQ_PBL_OFFSET;\n\n\trc = qed_iwarp_alloc_cid(p_hwfn, &cid);\n\tif (rc)\n\t\tgoto err1;\n\n\tqp->icid = (u16)cid;\n\n\tmemset(&init_data, 0, sizeof(init_data));\n\tinit_data.opaque_fid = p_hwfn->hw_info.opaque_fid;\n\tinit_data.cid = qp->icid;\n\tinit_data.comp_mode = QED_SPQ_MODE_EBLOCK;\n\n\trc = qed_sp_init_request(p_hwfn, &p_ent,\n\t\t\t\t IWARP_RAMROD_CMD_ID_CREATE_QP,\n\t\t\t\t PROTOCOLID_IWARP, &init_data);\n\tif (rc)\n\t\tgoto err2;\n\n\tp_ramrod = &p_ent->ramrod.iwarp_create_qp;\n\n\tSET_FIELD(p_ramrod->flags,\n\t\t  IWARP_CREATE_QP_RAMROD_DATA_FMR_AND_RESERVED_EN,\n\t\t  qp->fmr_and_reserved_lkey);\n\n\tSET_FIELD(p_ramrod->flags,\n\t\t  IWARP_CREATE_QP_RAMROD_DATA_SIGNALED_COMP, qp->signal_all);\n\n\tSET_FIELD(p_ramrod->flags,\n\t\t  IWARP_CREATE_QP_RAMROD_DATA_RDMA_RD_EN,\n\t\t  qp->incoming_rdma_read_en);\n\n\tSET_FIELD(p_ramrod->flags,\n\t\t  IWARP_CREATE_QP_RAMROD_DATA_RDMA_WR_EN,\n\t\t  qp->incoming_rdma_write_en);\n\n\tSET_FIELD(p_ramrod->flags,\n\t\t  IWARP_CREATE_QP_RAMROD_DATA_ATOMIC_EN,\n\t\t  qp->incoming_atomic_en);\n\n\tSET_FIELD(p_ramrod->flags,\n\t\t  IWARP_CREATE_QP_RAMROD_DATA_SRQ_FLG, qp->use_srq);\n\n\tp_ramrod->pd = cpu_to_le16(qp->pd);\n\tp_ramrod->sq_num_pages = cpu_to_le16(qp->sq_num_pages);\n\tp_ramrod->rq_num_pages = cpu_to_le16(qp->rq_num_pages);\n\n\tp_ramrod->srq_id.srq_idx = cpu_to_le16(qp->srq_id);\n\tp_ramrod->srq_id.opaque_fid = cpu_to_le16(p_hwfn->hw_info.opaque_fid);\n\tp_ramrod->qp_handle_for_cqe.hi = qp->qp_handle.hi;\n\tp_ramrod->qp_handle_for_cqe.lo = qp->qp_handle.lo;\n\n\tp_ramrod->cq_cid_for_sq =\n\t    cpu_to_le32((p_hwfn->hw_info.opaque_fid << 16) | qp->sq_cq_id);\n\tp_ramrod->cq_cid_for_rq =\n\t    cpu_to_le32((p_hwfn->hw_info.opaque_fid << 16) | qp->rq_cq_id);\n\n\tp_ramrod->dpi = cpu_to_le16(qp->dpi);\n\n\tphysical_queue = qed_get_cm_pq_idx(p_hwfn, PQ_FLAGS_OFLD);\n\tp_ramrod->physical_q0 = cpu_to_le16(physical_queue);\n\tphysical_queue = qed_get_cm_pq_idx(p_hwfn, PQ_FLAGS_ACK);\n\tp_ramrod->physical_q1 = cpu_to_le16(physical_queue);\n\n\trc = qed_spq_post(p_hwfn, p_ent, NULL);\n\tif (rc)\n\t\tgoto err2;\n\n\treturn rc;\n\nerr2:\n\tqed_iwarp_cid_cleaned(p_hwfn, cid);\nerr1:\n\tdma_free_coherent(&p_hwfn->cdev->pdev->dev,\n\t\t\t  IWARP_SHARED_QUEUE_PAGE_SIZE,\n\t\t\t  qp->shared_queue, qp->shared_queue_phys_addr);\n\n\treturn rc;\n}\n\nstatic int qed_iwarp_modify_fw(struct qed_hwfn *p_hwfn, struct qed_rdma_qp *qp)\n{\n\tstruct iwarp_modify_qp_ramrod_data *p_ramrod;\n\tstruct qed_sp_init_data init_data;\n\tstruct qed_spq_entry *p_ent;\n\tu16 flags, trans_to_state;\n\tint rc;\n\n\t \n\tmemset(&init_data, 0, sizeof(init_data));\n\tinit_data.cid = qp->icid;\n\tinit_data.opaque_fid = p_hwfn->hw_info.opaque_fid;\n\tinit_data.comp_mode = QED_SPQ_MODE_EBLOCK;\n\n\trc = qed_sp_init_request(p_hwfn, &p_ent,\n\t\t\t\t IWARP_RAMROD_CMD_ID_MODIFY_QP,\n\t\t\t\t p_hwfn->p_rdma_info->proto, &init_data);\n\tif (rc)\n\t\treturn rc;\n\n\tp_ramrod = &p_ent->ramrod.iwarp_modify_qp;\n\n\tflags = le16_to_cpu(p_ramrod->flags);\n\tSET_FIELD(flags, IWARP_MODIFY_QP_RAMROD_DATA_STATE_TRANS_EN, 0x1);\n\tp_ramrod->flags = cpu_to_le16(flags);\n\n\tif (qp->iwarp_state == QED_IWARP_QP_STATE_CLOSING)\n\t\ttrans_to_state = IWARP_MODIFY_QP_STATE_CLOSING;\n\telse\n\t\ttrans_to_state = IWARP_MODIFY_QP_STATE_ERROR;\n\n\tp_ramrod->transition_to_state = cpu_to_le16(trans_to_state);\n\n\trc = qed_spq_post(p_hwfn, p_ent, NULL);\n\n\tDP_VERBOSE(p_hwfn, QED_MSG_RDMA, \"QP(0x%x)rc=%d\\n\", qp->icid, rc);\n\n\treturn rc;\n}\n\nenum qed_iwarp_qp_state qed_roce2iwarp_state(enum qed_roce_qp_state state)\n{\n\tswitch (state) {\n\tcase QED_ROCE_QP_STATE_RESET:\n\tcase QED_ROCE_QP_STATE_INIT:\n\tcase QED_ROCE_QP_STATE_RTR:\n\t\treturn QED_IWARP_QP_STATE_IDLE;\n\tcase QED_ROCE_QP_STATE_RTS:\n\t\treturn QED_IWARP_QP_STATE_RTS;\n\tcase QED_ROCE_QP_STATE_SQD:\n\t\treturn QED_IWARP_QP_STATE_CLOSING;\n\tcase QED_ROCE_QP_STATE_ERR:\n\t\treturn QED_IWARP_QP_STATE_ERROR;\n\tcase QED_ROCE_QP_STATE_SQE:\n\t\treturn QED_IWARP_QP_STATE_TERMINATE;\n\tdefault:\n\t\treturn QED_IWARP_QP_STATE_ERROR;\n\t}\n}\n\nstatic enum qed_roce_qp_state\nqed_iwarp2roce_state(enum qed_iwarp_qp_state state)\n{\n\tswitch (state) {\n\tcase QED_IWARP_QP_STATE_IDLE:\n\t\treturn QED_ROCE_QP_STATE_INIT;\n\tcase QED_IWARP_QP_STATE_RTS:\n\t\treturn QED_ROCE_QP_STATE_RTS;\n\tcase QED_IWARP_QP_STATE_TERMINATE:\n\t\treturn QED_ROCE_QP_STATE_SQE;\n\tcase QED_IWARP_QP_STATE_CLOSING:\n\t\treturn QED_ROCE_QP_STATE_SQD;\n\tcase QED_IWARP_QP_STATE_ERROR:\n\t\treturn QED_ROCE_QP_STATE_ERR;\n\tdefault:\n\t\treturn QED_ROCE_QP_STATE_ERR;\n\t}\n}\n\nstatic const char * const iwarp_state_names[] = {\n\t\"IDLE\",\n\t\"RTS\",\n\t\"TERMINATE\",\n\t\"CLOSING\",\n\t\"ERROR\",\n};\n\nint\nqed_iwarp_modify_qp(struct qed_hwfn *p_hwfn,\n\t\t    struct qed_rdma_qp *qp,\n\t\t    enum qed_iwarp_qp_state new_state, bool internal)\n{\n\tenum qed_iwarp_qp_state prev_iw_state;\n\tbool modify_fw = false;\n\tint rc = 0;\n\n\t \n\tspin_lock_bh(&p_hwfn->p_rdma_info->iwarp.qp_lock);\n\tprev_iw_state = qp->iwarp_state;\n\n\tif (prev_iw_state == new_state) {\n\t\tspin_unlock_bh(&p_hwfn->p_rdma_info->iwarp.qp_lock);\n\t\treturn 0;\n\t}\n\n\tswitch (prev_iw_state) {\n\tcase QED_IWARP_QP_STATE_IDLE:\n\t\tswitch (new_state) {\n\t\tcase QED_IWARP_QP_STATE_RTS:\n\t\t\tqp->iwarp_state = QED_IWARP_QP_STATE_RTS;\n\t\t\tbreak;\n\t\tcase QED_IWARP_QP_STATE_ERROR:\n\t\t\tqp->iwarp_state = QED_IWARP_QP_STATE_ERROR;\n\t\t\tif (!internal)\n\t\t\t\tmodify_fw = true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase QED_IWARP_QP_STATE_RTS:\n\t\tswitch (new_state) {\n\t\tcase QED_IWARP_QP_STATE_CLOSING:\n\t\t\tif (!internal)\n\t\t\t\tmodify_fw = true;\n\n\t\t\tqp->iwarp_state = QED_IWARP_QP_STATE_CLOSING;\n\t\t\tbreak;\n\t\tcase QED_IWARP_QP_STATE_ERROR:\n\t\t\tif (!internal)\n\t\t\t\tmodify_fw = true;\n\t\t\tqp->iwarp_state = QED_IWARP_QP_STATE_ERROR;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase QED_IWARP_QP_STATE_ERROR:\n\t\tswitch (new_state) {\n\t\tcase QED_IWARP_QP_STATE_IDLE:\n\n\t\t\tqp->iwarp_state = new_state;\n\t\t\tbreak;\n\t\tcase QED_IWARP_QP_STATE_CLOSING:\n\t\t\t \n\t\t\tbreak;\n\t\tdefault:\n\t\t\trc = -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase QED_IWARP_QP_STATE_TERMINATE:\n\tcase QED_IWARP_QP_STATE_CLOSING:\n\t\tqp->iwarp_state = new_state;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tDP_VERBOSE(p_hwfn, QED_MSG_RDMA, \"QP(0x%x) %s --> %s%s\\n\",\n\t\t   qp->icid,\n\t\t   iwarp_state_names[prev_iw_state],\n\t\t   iwarp_state_names[qp->iwarp_state],\n\t\t   internal ? \"internal\" : \"\");\n\n\tspin_unlock_bh(&p_hwfn->p_rdma_info->iwarp.qp_lock);\n\n\tif (modify_fw)\n\t\trc = qed_iwarp_modify_fw(p_hwfn, qp);\n\n\treturn rc;\n}\n\nint qed_iwarp_fw_destroy(struct qed_hwfn *p_hwfn, struct qed_rdma_qp *qp)\n{\n\tstruct qed_sp_init_data init_data;\n\tstruct qed_spq_entry *p_ent;\n\tint rc;\n\n\t \n\tmemset(&init_data, 0, sizeof(init_data));\n\tinit_data.cid = qp->icid;\n\tinit_data.opaque_fid = p_hwfn->hw_info.opaque_fid;\n\tinit_data.comp_mode = QED_SPQ_MODE_EBLOCK;\n\n\trc = qed_sp_init_request(p_hwfn, &p_ent,\n\t\t\t\t IWARP_RAMROD_CMD_ID_DESTROY_QP,\n\t\t\t\t p_hwfn->p_rdma_info->proto, &init_data);\n\tif (rc)\n\t\treturn rc;\n\n\trc = qed_spq_post(p_hwfn, p_ent, NULL);\n\n\tDP_VERBOSE(p_hwfn, QED_MSG_RDMA, \"QP(0x%x) rc = %d\\n\", qp->icid, rc);\n\n\treturn rc;\n}\n\nstatic void qed_iwarp_destroy_ep(struct qed_hwfn *p_hwfn,\n\t\t\t\t struct qed_iwarp_ep *ep,\n\t\t\t\t bool remove_from_active_list)\n{\n\tdma_free_coherent(&p_hwfn->cdev->pdev->dev,\n\t\t\t  sizeof(*ep->ep_buffer_virt),\n\t\t\t  ep->ep_buffer_virt, ep->ep_buffer_phys);\n\n\tif (remove_from_active_list) {\n\t\tspin_lock_bh(&p_hwfn->p_rdma_info->iwarp.iw_lock);\n\t\tlist_del(&ep->list_entry);\n\t\tspin_unlock_bh(&p_hwfn->p_rdma_info->iwarp.iw_lock);\n\t}\n\n\tif (ep->qp)\n\t\tep->qp->ep = NULL;\n\n\tkfree(ep);\n}\n\nint qed_iwarp_destroy_qp(struct qed_hwfn *p_hwfn, struct qed_rdma_qp *qp)\n{\n\tstruct qed_iwarp_ep *ep = qp->ep;\n\tint wait_count = 0;\n\tint rc = 0;\n\n\tif (qp->iwarp_state != QED_IWARP_QP_STATE_ERROR) {\n\t\trc = qed_iwarp_modify_qp(p_hwfn, qp,\n\t\t\t\t\t QED_IWARP_QP_STATE_ERROR, false);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\t \n\tif (ep) {\n\t\twhile (READ_ONCE(ep->state) != QED_IWARP_EP_CLOSED &&\n\t\t       wait_count++ < 200)\n\t\t\tmsleep(100);\n\n\t\tif (ep->state != QED_IWARP_EP_CLOSED)\n\t\t\tDP_NOTICE(p_hwfn, \"ep state close timeout state=%x\\n\",\n\t\t\t\t  ep->state);\n\n\t\tqed_iwarp_destroy_ep(p_hwfn, ep, false);\n\t}\n\n\trc = qed_iwarp_fw_destroy(p_hwfn, qp);\n\n\tif (qp->shared_queue)\n\t\tdma_free_coherent(&p_hwfn->cdev->pdev->dev,\n\t\t\t\t  IWARP_SHARED_QUEUE_PAGE_SIZE,\n\t\t\t\t  qp->shared_queue, qp->shared_queue_phys_addr);\n\n\treturn rc;\n}\n\nstatic int\nqed_iwarp_create_ep(struct qed_hwfn *p_hwfn, struct qed_iwarp_ep **ep_out)\n{\n\tstruct qed_iwarp_ep *ep;\n\tint rc;\n\n\tep = kzalloc(sizeof(*ep), GFP_KERNEL);\n\tif (!ep)\n\t\treturn -ENOMEM;\n\n\tep->state = QED_IWARP_EP_INIT;\n\n\tep->ep_buffer_virt = dma_alloc_coherent(&p_hwfn->cdev->pdev->dev,\n\t\t\t\t\t\tsizeof(*ep->ep_buffer_virt),\n\t\t\t\t\t\t&ep->ep_buffer_phys,\n\t\t\t\t\t\tGFP_KERNEL);\n\tif (!ep->ep_buffer_virt) {\n\t\trc = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tep->sig = QED_EP_SIG;\n\n\t*ep_out = ep;\n\n\treturn 0;\n\nerr:\n\tkfree(ep);\n\treturn rc;\n}\n\nstatic void\nqed_iwarp_print_tcp_ramrod(struct qed_hwfn *p_hwfn,\n\t\t\t   struct iwarp_tcp_offload_ramrod_data *p_tcp_ramrod)\n{\n\tDP_VERBOSE(p_hwfn, QED_MSG_RDMA, \"local_mac=%x %x %x, remote_mac=%x %x %x\\n\",\n\t\t   p_tcp_ramrod->tcp.local_mac_addr_lo,\n\t\t   p_tcp_ramrod->tcp.local_mac_addr_mid,\n\t\t   p_tcp_ramrod->tcp.local_mac_addr_hi,\n\t\t   p_tcp_ramrod->tcp.remote_mac_addr_lo,\n\t\t   p_tcp_ramrod->tcp.remote_mac_addr_mid,\n\t\t   p_tcp_ramrod->tcp.remote_mac_addr_hi);\n\n\tif (p_tcp_ramrod->tcp.ip_version == TCP_IPV4) {\n\t\tDP_VERBOSE(p_hwfn, QED_MSG_RDMA,\n\t\t\t   \"local_ip=%pI4h:%x, remote_ip=%pI4h:%x, vlan=%x\\n\",\n\t\t\t   p_tcp_ramrod->tcp.local_ip,\n\t\t\t   p_tcp_ramrod->tcp.local_port,\n\t\t\t   p_tcp_ramrod->tcp.remote_ip,\n\t\t\t   p_tcp_ramrod->tcp.remote_port,\n\t\t\t   p_tcp_ramrod->tcp.vlan_id);\n\t} else {\n\t\tDP_VERBOSE(p_hwfn, QED_MSG_RDMA,\n\t\t\t   \"local_ip=%pI6:%x, remote_ip=%pI6:%x, vlan=%x\\n\",\n\t\t\t   p_tcp_ramrod->tcp.local_ip,\n\t\t\t   p_tcp_ramrod->tcp.local_port,\n\t\t\t   p_tcp_ramrod->tcp.remote_ip,\n\t\t\t   p_tcp_ramrod->tcp.remote_port,\n\t\t\t   p_tcp_ramrod->tcp.vlan_id);\n\t}\n\n\tDP_VERBOSE(p_hwfn, QED_MSG_RDMA,\n\t\t   \"flow_label=%x, ttl=%x, tos_or_tc=%x, mss=%x, rcv_wnd_scale=%x, connect_mode=%x, flags=%x\\n\",\n\t\t   p_tcp_ramrod->tcp.flow_label,\n\t\t   p_tcp_ramrod->tcp.ttl,\n\t\t   p_tcp_ramrod->tcp.tos_or_tc,\n\t\t   p_tcp_ramrod->tcp.mss,\n\t\t   p_tcp_ramrod->tcp.rcv_wnd_scale,\n\t\t   p_tcp_ramrod->tcp.connect_mode,\n\t\t   p_tcp_ramrod->tcp.flags);\n\n\tDP_VERBOSE(p_hwfn, QED_MSG_RDMA, \"syn_ip_payload_length=%x, lo=%x, hi=%x\\n\",\n\t\t   p_tcp_ramrod->tcp.syn_ip_payload_length,\n\t\t   p_tcp_ramrod->tcp.syn_phy_addr_lo,\n\t\t   p_tcp_ramrod->tcp.syn_phy_addr_hi);\n}\n\nstatic int\nqed_iwarp_tcp_offload(struct qed_hwfn *p_hwfn, struct qed_iwarp_ep *ep)\n{\n\tstruct qed_iwarp_info *iwarp_info = &p_hwfn->p_rdma_info->iwarp;\n\tstruct iwarp_tcp_offload_ramrod_data *p_tcp_ramrod;\n\tstruct tcp_offload_params_opt2 *tcp;\n\tstruct qed_sp_init_data init_data;\n\tstruct qed_spq_entry *p_ent;\n\tdma_addr_t async_output_phys;\n\tdma_addr_t in_pdata_phys;\n\tu16 physical_q;\n\tu16 flags = 0;\n\tu8 tcp_flags;\n\tint rc;\n\tint i;\n\n\tmemset(&init_data, 0, sizeof(init_data));\n\tinit_data.cid = ep->tcp_cid;\n\tinit_data.opaque_fid = p_hwfn->hw_info.opaque_fid;\n\tif (ep->connect_mode == TCP_CONNECT_PASSIVE)\n\t\tinit_data.comp_mode = QED_SPQ_MODE_CB;\n\telse\n\t\tinit_data.comp_mode = QED_SPQ_MODE_EBLOCK;\n\n\trc = qed_sp_init_request(p_hwfn, &p_ent,\n\t\t\t\t IWARP_RAMROD_CMD_ID_TCP_OFFLOAD,\n\t\t\t\t PROTOCOLID_IWARP, &init_data);\n\tif (rc)\n\t\treturn rc;\n\n\tp_tcp_ramrod = &p_ent->ramrod.iwarp_tcp_offload;\n\n\tin_pdata_phys = ep->ep_buffer_phys +\n\t\t\toffsetof(struct qed_iwarp_ep_memory, in_pdata);\n\tDMA_REGPAIR_LE(p_tcp_ramrod->iwarp.incoming_ulp_buffer.addr,\n\t\t       in_pdata_phys);\n\n\tp_tcp_ramrod->iwarp.incoming_ulp_buffer.len =\n\t    cpu_to_le16(sizeof(ep->ep_buffer_virt->in_pdata));\n\n\tasync_output_phys = ep->ep_buffer_phys +\n\t\t\t    offsetof(struct qed_iwarp_ep_memory, async_output);\n\tDMA_REGPAIR_LE(p_tcp_ramrod->iwarp.async_eqe_output_buf,\n\t\t       async_output_phys);\n\n\tp_tcp_ramrod->iwarp.handle_for_async.hi = cpu_to_le32(PTR_HI(ep));\n\tp_tcp_ramrod->iwarp.handle_for_async.lo = cpu_to_le32(PTR_LO(ep));\n\n\tphysical_q = qed_get_cm_pq_idx(p_hwfn, PQ_FLAGS_OFLD);\n\tp_tcp_ramrod->iwarp.physical_q0 = cpu_to_le16(physical_q);\n\tphysical_q = qed_get_cm_pq_idx(p_hwfn, PQ_FLAGS_ACK);\n\tp_tcp_ramrod->iwarp.physical_q1 = cpu_to_le16(physical_q);\n\tp_tcp_ramrod->iwarp.mpa_mode = iwarp_info->mpa_rev;\n\n\ttcp = &p_tcp_ramrod->tcp;\n\tqed_set_fw_mac_addr(&tcp->remote_mac_addr_hi,\n\t\t\t    &tcp->remote_mac_addr_mid,\n\t\t\t    &tcp->remote_mac_addr_lo, ep->remote_mac_addr);\n\tqed_set_fw_mac_addr(&tcp->local_mac_addr_hi, &tcp->local_mac_addr_mid,\n\t\t\t    &tcp->local_mac_addr_lo, ep->local_mac_addr);\n\n\ttcp->vlan_id = cpu_to_le16(ep->cm_info.vlan);\n\n\ttcp_flags = p_hwfn->p_rdma_info->iwarp.tcp_flags;\n\n\tSET_FIELD(flags, TCP_OFFLOAD_PARAMS_OPT2_TS_EN,\n\t\t  !!(tcp_flags & QED_IWARP_TS_EN));\n\n\tSET_FIELD(flags, TCP_OFFLOAD_PARAMS_OPT2_DA_EN,\n\t\t  !!(tcp_flags & QED_IWARP_DA_EN));\n\n\ttcp->flags = cpu_to_le16(flags);\n\ttcp->ip_version = ep->cm_info.ip_version;\n\n\tfor (i = 0; i < 4; i++) {\n\t\ttcp->remote_ip[i] = cpu_to_le32(ep->cm_info.remote_ip[i]);\n\t\ttcp->local_ip[i] = cpu_to_le32(ep->cm_info.local_ip[i]);\n\t}\n\n\ttcp->remote_port = cpu_to_le16(ep->cm_info.remote_port);\n\ttcp->local_port = cpu_to_le16(ep->cm_info.local_port);\n\ttcp->mss = cpu_to_le16(ep->mss);\n\ttcp->flow_label = 0;\n\ttcp->ttl = 0x40;\n\ttcp->tos_or_tc = 0;\n\n\ttcp->max_rt_time = QED_IWARP_DEF_MAX_RT_TIME;\n\ttcp->cwnd = cpu_to_le32(QED_IWARP_DEF_CWND_FACTOR * ep->mss);\n\ttcp->ka_max_probe_cnt = QED_IWARP_DEF_KA_MAX_PROBE_CNT;\n\ttcp->ka_timeout = cpu_to_le32(QED_IWARP_DEF_KA_TIMEOUT);\n\ttcp->ka_interval = cpu_to_le32(QED_IWARP_DEF_KA_INTERVAL);\n\n\ttcp->rcv_wnd_scale = (u8)p_hwfn->p_rdma_info->iwarp.rcv_wnd_scale;\n\ttcp->connect_mode = ep->connect_mode;\n\n\tif (ep->connect_mode == TCP_CONNECT_PASSIVE) {\n\t\ttcp->syn_ip_payload_length =\n\t\t\tcpu_to_le16(ep->syn_ip_payload_length);\n\t\ttcp->syn_phy_addr_hi = DMA_HI_LE(ep->syn_phy_addr);\n\t\ttcp->syn_phy_addr_lo = DMA_LO_LE(ep->syn_phy_addr);\n\t}\n\n\tqed_iwarp_print_tcp_ramrod(p_hwfn, p_tcp_ramrod);\n\n\trc = qed_spq_post(p_hwfn, p_ent, NULL);\n\n\tDP_VERBOSE(p_hwfn, QED_MSG_RDMA,\n\t\t   \"EP(0x%x) Offload completed rc=%d\\n\", ep->tcp_cid, rc);\n\n\treturn rc;\n}\n\nstatic void\nqed_iwarp_mpa_received(struct qed_hwfn *p_hwfn, struct qed_iwarp_ep *ep)\n{\n\tstruct qed_iwarp_info *iwarp_info = &p_hwfn->p_rdma_info->iwarp;\n\tstruct qed_iwarp_cm_event_params params;\n\tstruct mpa_v2_hdr *mpa_v2;\n\tunion async_output *async_data;\n\tu16 mpa_ord, mpa_ird;\n\tu8 mpa_hdr_size = 0;\n\tu16 ulp_data_len;\n\tu8 mpa_rev;\n\n\tasync_data = &ep->ep_buffer_virt->async_output;\n\n\tmpa_rev = async_data->mpa_request.mpa_handshake_mode;\n\tDP_VERBOSE(p_hwfn, QED_MSG_RDMA,\n\t\t   \"private_data_len=%x handshake_mode=%x private_data=(%x)\\n\",\n\t\t   async_data->mpa_request.ulp_data_len,\n\t\t   mpa_rev, *((u32 *)(ep->ep_buffer_virt->in_pdata)));\n\n\tif (mpa_rev == MPA_NEGOTIATION_TYPE_ENHANCED) {\n\t\t \n\t\tmpa_v2 = (struct mpa_v2_hdr *)ep->ep_buffer_virt->in_pdata;\n\t\tmpa_hdr_size = sizeof(*mpa_v2);\n\n\t\tmpa_ord = ntohs(mpa_v2->ord);\n\t\tmpa_ird = ntohs(mpa_v2->ird);\n\n\t\t \n\t\tep->cm_info.ord = (u8)min_t(u16,\n\t\t\t\t\t    (mpa_ord & MPA_V2_IRD_ORD_MASK),\n\t\t\t\t\t    QED_IWARP_ORD_DEFAULT);\n\n\t\tep->cm_info.ird = (u8)min_t(u16,\n\t\t\t\t\t    (mpa_ird & MPA_V2_IRD_ORD_MASK),\n\t\t\t\t\t    QED_IWARP_IRD_DEFAULT);\n\n\t\t \n\t\tep->rtr_type = MPA_RTR_TYPE_NONE;\n\t\tif (mpa_ird & MPA_V2_PEER2PEER_MODEL) {\n\t\t\tif (mpa_ord & MPA_V2_WRITE_RTR)\n\t\t\t\tep->rtr_type |= MPA_RTR_TYPE_ZERO_WRITE;\n\n\t\t\tif (mpa_ord & MPA_V2_READ_RTR)\n\t\t\t\tep->rtr_type |= MPA_RTR_TYPE_ZERO_READ;\n\n\t\t\tif (mpa_ird & MPA_V2_SEND_RTR)\n\t\t\t\tep->rtr_type |= MPA_RTR_TYPE_ZERO_SEND;\n\n\t\t\tep->rtr_type &= iwarp_info->rtr_type;\n\n\t\t\t \n\t\t\tif (ep->rtr_type == MPA_RTR_TYPE_NONE)\n\t\t\t\tep->rtr_type = iwarp_info->rtr_type;\n\t\t}\n\n\t\tep->mpa_rev = MPA_NEGOTIATION_TYPE_ENHANCED;\n\t} else {\n\t\tep->cm_info.ord = QED_IWARP_ORD_DEFAULT;\n\t\tep->cm_info.ird = QED_IWARP_IRD_DEFAULT;\n\t\tep->mpa_rev = MPA_NEGOTIATION_TYPE_BASIC;\n\t}\n\n\tDP_VERBOSE(p_hwfn, QED_MSG_RDMA,\n\t\t   \"MPA_NEGOTIATE (v%d): ORD: 0x%x IRD: 0x%x rtr:0x%x ulp_data_len = %x mpa_hdr_size = %x\\n\",\n\t\t   mpa_rev, ep->cm_info.ord, ep->cm_info.ird, ep->rtr_type,\n\t\t   async_data->mpa_request.ulp_data_len, mpa_hdr_size);\n\n\t \n\tep->cm_info.private_data = ep->ep_buffer_virt->in_pdata + mpa_hdr_size;\n\n\tulp_data_len = le16_to_cpu(async_data->mpa_request.ulp_data_len);\n\tep->cm_info.private_data_len = ulp_data_len - mpa_hdr_size;\n\n\tparams.event = QED_IWARP_EVENT_MPA_REQUEST;\n\tparams.cm_info = &ep->cm_info;\n\tparams.ep_context = ep;\n\tparams.status = 0;\n\n\tep->state = QED_IWARP_EP_MPA_REQ_RCVD;\n\tep->event_cb(ep->cb_context, &params);\n}\n\nstatic int\nqed_iwarp_mpa_offload(struct qed_hwfn *p_hwfn, struct qed_iwarp_ep *ep)\n{\n\tstruct iwarp_mpa_offload_ramrod_data *p_mpa_ramrod;\n\tstruct mpa_outgoing_params *common;\n\tstruct qed_iwarp_info *iwarp_info;\n\tstruct qed_sp_init_data init_data;\n\tdma_addr_t async_output_phys;\n\tstruct qed_spq_entry *p_ent;\n\tdma_addr_t out_pdata_phys;\n\tdma_addr_t in_pdata_phys;\n\tstruct qed_rdma_qp *qp;\n\tbool reject;\n\tu32 val;\n\tint rc;\n\n\tif (!ep)\n\t\treturn -EINVAL;\n\n\tqp = ep->qp;\n\treject = !qp;\n\n\tmemset(&init_data, 0, sizeof(init_data));\n\tinit_data.cid = reject ? ep->tcp_cid : qp->icid;\n\tinit_data.opaque_fid = p_hwfn->hw_info.opaque_fid;\n\n\tif (ep->connect_mode == TCP_CONNECT_ACTIVE)\n\t\tinit_data.comp_mode = QED_SPQ_MODE_CB;\n\telse\n\t\tinit_data.comp_mode = QED_SPQ_MODE_EBLOCK;\n\n\trc = qed_sp_init_request(p_hwfn, &p_ent,\n\t\t\t\t IWARP_RAMROD_CMD_ID_MPA_OFFLOAD,\n\t\t\t\t PROTOCOLID_IWARP, &init_data);\n\tif (rc)\n\t\treturn rc;\n\n\tp_mpa_ramrod = &p_ent->ramrod.iwarp_mpa_offload;\n\tcommon = &p_mpa_ramrod->common;\n\n\tout_pdata_phys = ep->ep_buffer_phys +\n\t\t\t offsetof(struct qed_iwarp_ep_memory, out_pdata);\n\tDMA_REGPAIR_LE(common->outgoing_ulp_buffer.addr, out_pdata_phys);\n\n\tval = ep->cm_info.private_data_len;\n\tcommon->outgoing_ulp_buffer.len = cpu_to_le16(val);\n\tcommon->crc_needed = p_hwfn->p_rdma_info->iwarp.crc_needed;\n\n\tcommon->out_rq.ord = cpu_to_le32(ep->cm_info.ord);\n\tcommon->out_rq.ird = cpu_to_le32(ep->cm_info.ird);\n\n\tval = p_hwfn->hw_info.opaque_fid << 16 | ep->tcp_cid;\n\tp_mpa_ramrod->tcp_cid = cpu_to_le32(val);\n\n\tin_pdata_phys = ep->ep_buffer_phys +\n\t\t\toffsetof(struct qed_iwarp_ep_memory, in_pdata);\n\tp_mpa_ramrod->tcp_connect_side = ep->connect_mode;\n\tDMA_REGPAIR_LE(p_mpa_ramrod->incoming_ulp_buffer.addr,\n\t\t       in_pdata_phys);\n\tp_mpa_ramrod->incoming_ulp_buffer.len =\n\t    cpu_to_le16(sizeof(ep->ep_buffer_virt->in_pdata));\n\tasync_output_phys = ep->ep_buffer_phys +\n\t\t\t    offsetof(struct qed_iwarp_ep_memory, async_output);\n\tDMA_REGPAIR_LE(p_mpa_ramrod->async_eqe_output_buf,\n\t\t       async_output_phys);\n\tp_mpa_ramrod->handle_for_async.hi = cpu_to_le32(PTR_HI(ep));\n\tp_mpa_ramrod->handle_for_async.lo = cpu_to_le32(PTR_LO(ep));\n\n\tif (!reject) {\n\t\tDMA_REGPAIR_LE(p_mpa_ramrod->shared_queue_addr,\n\t\t\t       qp->shared_queue_phys_addr);\n\t\tp_mpa_ramrod->stats_counter_id =\n\t\t    RESC_START(p_hwfn, QED_RDMA_STATS_QUEUE) + qp->stats_queue;\n\t} else {\n\t\tcommon->reject = 1;\n\t}\n\n\tiwarp_info = &p_hwfn->p_rdma_info->iwarp;\n\tp_mpa_ramrod->rcv_wnd = cpu_to_le16(iwarp_info->rcv_wnd_size);\n\tp_mpa_ramrod->mode = ep->mpa_rev;\n\tSET_FIELD(p_mpa_ramrod->rtr_pref,\n\t\t  IWARP_MPA_OFFLOAD_RAMROD_DATA_RTR_SUPPORTED, ep->rtr_type);\n\n\tep->state = QED_IWARP_EP_MPA_OFFLOADED;\n\trc = qed_spq_post(p_hwfn, p_ent, NULL);\n\tif (!reject)\n\t\tep->cid = qp->icid;\t \n\n\tDP_VERBOSE(p_hwfn,\n\t\t   QED_MSG_RDMA,\n\t\t   \"QP(0x%x) EP(0x%x) MPA Offload rc = %d IRD=0x%x ORD=0x%x rtr_type=%d mpa_rev=%d reject=%d\\n\",\n\t\t   reject ? 0xffff : qp->icid,\n\t\t   ep->tcp_cid,\n\t\t   rc,\n\t\t   ep->cm_info.ird,\n\t\t   ep->cm_info.ord, ep->rtr_type, ep->mpa_rev, reject);\n\treturn rc;\n}\n\nstatic void\nqed_iwarp_return_ep(struct qed_hwfn *p_hwfn, struct qed_iwarp_ep *ep)\n{\n\tep->state = QED_IWARP_EP_INIT;\n\tif (ep->qp)\n\t\tep->qp->ep = NULL;\n\tep->qp = NULL;\n\tmemset(&ep->cm_info, 0, sizeof(ep->cm_info));\n\n\tif (ep->tcp_cid == QED_IWARP_INVALID_TCP_CID) {\n\t\t \n\t\tqed_iwarp_alloc_tcp_cid(p_hwfn, &ep->tcp_cid);\n\t}\n\tspin_lock_bh(&p_hwfn->p_rdma_info->iwarp.iw_lock);\n\n\tlist_move_tail(&ep->list_entry,\n\t\t       &p_hwfn->p_rdma_info->iwarp.ep_free_list);\n\n\tspin_unlock_bh(&p_hwfn->p_rdma_info->iwarp.iw_lock);\n}\n\nstatic void\nqed_iwarp_parse_private_data(struct qed_hwfn *p_hwfn, struct qed_iwarp_ep *ep)\n{\n\tstruct mpa_v2_hdr *mpa_v2_params;\n\tunion async_output *async_data;\n\tu16 mpa_ird, mpa_ord;\n\tu8 mpa_data_size = 0;\n\tu16 ulp_data_len;\n\n\tif (MPA_REV2(p_hwfn->p_rdma_info->iwarp.mpa_rev)) {\n\t\tmpa_v2_params =\n\t\t\t(struct mpa_v2_hdr *)(ep->ep_buffer_virt->in_pdata);\n\t\tmpa_data_size = sizeof(*mpa_v2_params);\n\t\tmpa_ird = ntohs(mpa_v2_params->ird);\n\t\tmpa_ord = ntohs(mpa_v2_params->ord);\n\n\t\tep->cm_info.ird = (u8)(mpa_ord & MPA_V2_IRD_ORD_MASK);\n\t\tep->cm_info.ord = (u8)(mpa_ird & MPA_V2_IRD_ORD_MASK);\n\t}\n\n\tasync_data = &ep->ep_buffer_virt->async_output;\n\tep->cm_info.private_data = ep->ep_buffer_virt->in_pdata + mpa_data_size;\n\n\tulp_data_len = le16_to_cpu(async_data->mpa_response.ulp_data_len);\n\tep->cm_info.private_data_len = ulp_data_len - mpa_data_size;\n}\n\nstatic void\nqed_iwarp_mpa_reply_arrived(struct qed_hwfn *p_hwfn, struct qed_iwarp_ep *ep)\n{\n\tstruct qed_iwarp_cm_event_params params;\n\n\tif (ep->connect_mode == TCP_CONNECT_PASSIVE) {\n\t\tDP_NOTICE(p_hwfn,\n\t\t\t  \"MPA reply event not expected on passive side!\\n\");\n\t\treturn;\n\t}\n\n\tparams.event = QED_IWARP_EVENT_ACTIVE_MPA_REPLY;\n\n\tqed_iwarp_parse_private_data(p_hwfn, ep);\n\n\tDP_VERBOSE(p_hwfn, QED_MSG_RDMA,\n\t\t   \"MPA_NEGOTIATE (v%d): ORD: 0x%x IRD: 0x%x\\n\",\n\t\t   ep->mpa_rev, ep->cm_info.ord, ep->cm_info.ird);\n\n\tparams.cm_info = &ep->cm_info;\n\tparams.ep_context = ep;\n\tparams.status = 0;\n\n\tep->mpa_reply_processed = true;\n\n\tep->event_cb(ep->cb_context, &params);\n}\n\n#define QED_IWARP_CONNECT_MODE_STRING(ep) \\\n\t((ep)->connect_mode == TCP_CONNECT_PASSIVE) ? \"Passive\" : \"Active\"\n\n \nstatic void\nqed_iwarp_mpa_complete(struct qed_hwfn *p_hwfn,\n\t\t       struct qed_iwarp_ep *ep, u8 fw_return_code)\n{\n\tstruct qed_iwarp_cm_event_params params;\n\n\tif (ep->connect_mode == TCP_CONNECT_ACTIVE)\n\t\tparams.event = QED_IWARP_EVENT_ACTIVE_COMPLETE;\n\telse\n\t\tparams.event = QED_IWARP_EVENT_PASSIVE_COMPLETE;\n\n\tif (ep->connect_mode == TCP_CONNECT_ACTIVE && !ep->mpa_reply_processed)\n\t\tqed_iwarp_parse_private_data(p_hwfn, ep);\n\n\tDP_VERBOSE(p_hwfn, QED_MSG_RDMA,\n\t\t   \"MPA_NEGOTIATE (v%d): ORD: 0x%x IRD: 0x%x\\n\",\n\t\t   ep->mpa_rev, ep->cm_info.ord, ep->cm_info.ird);\n\n\tparams.cm_info = &ep->cm_info;\n\n\tparams.ep_context = ep;\n\n\tswitch (fw_return_code) {\n\tcase RDMA_RETURN_OK:\n\t\tep->qp->max_rd_atomic_req = ep->cm_info.ord;\n\t\tep->qp->max_rd_atomic_resp = ep->cm_info.ird;\n\t\tqed_iwarp_modify_qp(p_hwfn, ep->qp, QED_IWARP_QP_STATE_RTS, 1);\n\t\tep->state = QED_IWARP_EP_ESTABLISHED;\n\t\tparams.status = 0;\n\t\tbreak;\n\tcase IWARP_CONN_ERROR_MPA_TIMEOUT:\n\t\tDP_NOTICE(p_hwfn, \"%s(0x%x) MPA timeout\\n\",\n\t\t\t  QED_IWARP_CONNECT_MODE_STRING(ep), ep->cid);\n\t\tparams.status = -EBUSY;\n\t\tbreak;\n\tcase IWARP_CONN_ERROR_MPA_ERROR_REJECT:\n\t\tDP_NOTICE(p_hwfn, \"%s(0x%x) MPA Reject\\n\",\n\t\t\t  QED_IWARP_CONNECT_MODE_STRING(ep), ep->cid);\n\t\tparams.status = -ECONNREFUSED;\n\t\tbreak;\n\tcase IWARP_CONN_ERROR_MPA_RST:\n\t\tDP_NOTICE(p_hwfn, \"%s(0x%x) MPA reset(tcp cid: 0x%x)\\n\",\n\t\t\t  QED_IWARP_CONNECT_MODE_STRING(ep), ep->cid,\n\t\t\t  ep->tcp_cid);\n\t\tparams.status = -ECONNRESET;\n\t\tbreak;\n\tcase IWARP_CONN_ERROR_MPA_FIN:\n\t\tDP_NOTICE(p_hwfn, \"%s(0x%x) MPA received FIN\\n\",\n\t\t\t  QED_IWARP_CONNECT_MODE_STRING(ep), ep->cid);\n\t\tparams.status = -ECONNREFUSED;\n\t\tbreak;\n\tcase IWARP_CONN_ERROR_MPA_INSUF_IRD:\n\t\tDP_NOTICE(p_hwfn, \"%s(0x%x) MPA insufficient ird\\n\",\n\t\t\t  QED_IWARP_CONNECT_MODE_STRING(ep), ep->cid);\n\t\tparams.status = -ECONNREFUSED;\n\t\tbreak;\n\tcase IWARP_CONN_ERROR_MPA_RTR_MISMATCH:\n\t\tDP_NOTICE(p_hwfn, \"%s(0x%x) MPA RTR MISMATCH\\n\",\n\t\t\t  QED_IWARP_CONNECT_MODE_STRING(ep), ep->cid);\n\t\tparams.status = -ECONNREFUSED;\n\t\tbreak;\n\tcase IWARP_CONN_ERROR_MPA_INVALID_PACKET:\n\t\tDP_NOTICE(p_hwfn, \"%s(0x%x) MPA Invalid Packet\\n\",\n\t\t\t  QED_IWARP_CONNECT_MODE_STRING(ep), ep->cid);\n\t\tparams.status = -ECONNREFUSED;\n\t\tbreak;\n\tcase IWARP_CONN_ERROR_MPA_LOCAL_ERROR:\n\t\tDP_NOTICE(p_hwfn, \"%s(0x%x) MPA Local Error\\n\",\n\t\t\t  QED_IWARP_CONNECT_MODE_STRING(ep), ep->cid);\n\t\tparams.status = -ECONNREFUSED;\n\t\tbreak;\n\tcase IWARP_CONN_ERROR_MPA_TERMINATE:\n\t\tDP_NOTICE(p_hwfn, \"%s(0x%x) MPA TERMINATE\\n\",\n\t\t\t  QED_IWARP_CONNECT_MODE_STRING(ep), ep->cid);\n\t\tparams.status = -ECONNREFUSED;\n\t\tbreak;\n\tdefault:\n\t\tparams.status = -ECONNRESET;\n\t\tbreak;\n\t}\n\n\tif (fw_return_code != RDMA_RETURN_OK)\n\t\t \n\t\tsmp_store_release(&ep->state, QED_IWARP_EP_CLOSED);\n\n\tep->event_cb(ep->cb_context, &params);\n\n\t \n\tif (fw_return_code != RDMA_RETURN_OK) {\n\t\tep->tcp_cid = QED_IWARP_INVALID_TCP_CID;\n\t\tif ((ep->connect_mode == TCP_CONNECT_PASSIVE) &&\n\t\t    (!ep->qp)) {\t \n\t\t\tqed_iwarp_return_ep(p_hwfn, ep);\n\t\t} else {\n\t\t\tspin_lock_bh(&p_hwfn->p_rdma_info->iwarp.iw_lock);\n\t\t\tlist_del(&ep->list_entry);\n\t\t\tspin_unlock_bh(&p_hwfn->p_rdma_info->iwarp.iw_lock);\n\t\t}\n\t}\n}\n\nstatic void\nqed_iwarp_mpa_v2_set_private(struct qed_hwfn *p_hwfn,\n\t\t\t     struct qed_iwarp_ep *ep, u8 *mpa_data_size)\n{\n\tstruct mpa_v2_hdr *mpa_v2_params;\n\tu16 mpa_ird, mpa_ord;\n\n\t*mpa_data_size = 0;\n\tif (MPA_REV2(ep->mpa_rev)) {\n\t\tmpa_v2_params =\n\t\t    (struct mpa_v2_hdr *)ep->ep_buffer_virt->out_pdata;\n\t\t*mpa_data_size = sizeof(*mpa_v2_params);\n\n\t\tmpa_ird = (u16)ep->cm_info.ird;\n\t\tmpa_ord = (u16)ep->cm_info.ord;\n\n\t\tif (ep->rtr_type != MPA_RTR_TYPE_NONE) {\n\t\t\tmpa_ird |= MPA_V2_PEER2PEER_MODEL;\n\n\t\t\tif (ep->rtr_type & MPA_RTR_TYPE_ZERO_SEND)\n\t\t\t\tmpa_ird |= MPA_V2_SEND_RTR;\n\n\t\t\tif (ep->rtr_type & MPA_RTR_TYPE_ZERO_WRITE)\n\t\t\t\tmpa_ord |= MPA_V2_WRITE_RTR;\n\n\t\t\tif (ep->rtr_type & MPA_RTR_TYPE_ZERO_READ)\n\t\t\t\tmpa_ord |= MPA_V2_READ_RTR;\n\t\t}\n\n\t\tmpa_v2_params->ird = htons(mpa_ird);\n\t\tmpa_v2_params->ord = htons(mpa_ord);\n\n\t\tDP_VERBOSE(p_hwfn,\n\t\t\t   QED_MSG_RDMA,\n\t\t\t   \"MPA_NEGOTIATE Header: [%x ord:%x ird] %x ord:%x ird:%x peer2peer:%x rtr_send:%x rtr_write:%x rtr_read:%x\\n\",\n\t\t\t   mpa_v2_params->ird,\n\t\t\t   mpa_v2_params->ord,\n\t\t\t   *((u32 *)mpa_v2_params),\n\t\t\t   mpa_ord & MPA_V2_IRD_ORD_MASK,\n\t\t\t   mpa_ird & MPA_V2_IRD_ORD_MASK,\n\t\t\t   !!(mpa_ird & MPA_V2_PEER2PEER_MODEL),\n\t\t\t   !!(mpa_ird & MPA_V2_SEND_RTR),\n\t\t\t   !!(mpa_ord & MPA_V2_WRITE_RTR),\n\t\t\t   !!(mpa_ord & MPA_V2_READ_RTR));\n\t}\n}\n\nint qed_iwarp_connect(void *rdma_cxt,\n\t\t      struct qed_iwarp_connect_in *iparams,\n\t\t      struct qed_iwarp_connect_out *oparams)\n{\n\tstruct qed_hwfn *p_hwfn = rdma_cxt;\n\tstruct qed_iwarp_info *iwarp_info;\n\tstruct qed_iwarp_ep *ep;\n\tu8 mpa_data_size = 0;\n\tu32 cid;\n\tint rc;\n\n\tif ((iparams->cm_info.ord > QED_IWARP_ORD_DEFAULT) ||\n\t    (iparams->cm_info.ird > QED_IWARP_IRD_DEFAULT)) {\n\t\tDP_NOTICE(p_hwfn,\n\t\t\t  \"QP(0x%x) ERROR: Invalid ord(0x%x)/ird(0x%x)\\n\",\n\t\t\t  iparams->qp->icid, iparams->cm_info.ord,\n\t\t\t  iparams->cm_info.ird);\n\n\t\treturn -EINVAL;\n\t}\n\n\tiwarp_info = &p_hwfn->p_rdma_info->iwarp;\n\n\t \n\trc = qed_iwarp_alloc_cid(p_hwfn, &cid);\n\tif (rc)\n\t\treturn rc;\n\n\trc = qed_iwarp_create_ep(p_hwfn, &ep);\n\tif (rc)\n\t\tgoto err;\n\n\tep->tcp_cid = cid;\n\n\tspin_lock_bh(&p_hwfn->p_rdma_info->iwarp.iw_lock);\n\tlist_add_tail(&ep->list_entry, &p_hwfn->p_rdma_info->iwarp.ep_list);\n\tspin_unlock_bh(&p_hwfn->p_rdma_info->iwarp.iw_lock);\n\n\tep->qp = iparams->qp;\n\tep->qp->ep = ep;\n\tether_addr_copy(ep->remote_mac_addr, iparams->remote_mac_addr);\n\tether_addr_copy(ep->local_mac_addr, iparams->local_mac_addr);\n\tmemcpy(&ep->cm_info, &iparams->cm_info, sizeof(ep->cm_info));\n\n\tep->cm_info.ord = iparams->cm_info.ord;\n\tep->cm_info.ird = iparams->cm_info.ird;\n\n\tep->rtr_type = iwarp_info->rtr_type;\n\tif (!iwarp_info->peer2peer)\n\t\tep->rtr_type = MPA_RTR_TYPE_NONE;\n\n\tif ((ep->rtr_type & MPA_RTR_TYPE_ZERO_READ) && (ep->cm_info.ord == 0))\n\t\tep->cm_info.ord = 1;\n\n\tep->mpa_rev = iwarp_info->mpa_rev;\n\n\tqed_iwarp_mpa_v2_set_private(p_hwfn, ep, &mpa_data_size);\n\n\tep->cm_info.private_data = ep->ep_buffer_virt->out_pdata;\n\tep->cm_info.private_data_len = iparams->cm_info.private_data_len +\n\t\t\t\t       mpa_data_size;\n\n\tmemcpy((u8 *)ep->ep_buffer_virt->out_pdata + mpa_data_size,\n\t       iparams->cm_info.private_data,\n\t       iparams->cm_info.private_data_len);\n\n\tep->mss = iparams->mss;\n\tep->mss = min_t(u16, QED_IWARP_MAX_FW_MSS, ep->mss);\n\n\tep->event_cb = iparams->event_cb;\n\tep->cb_context = iparams->cb_context;\n\tep->connect_mode = TCP_CONNECT_ACTIVE;\n\n\toparams->ep_context = ep;\n\n\trc = qed_iwarp_tcp_offload(p_hwfn, ep);\n\n\tDP_VERBOSE(p_hwfn, QED_MSG_RDMA, \"QP(0x%x) EP(0x%x) rc = %d\\n\",\n\t\t   iparams->qp->icid, ep->tcp_cid, rc);\n\n\tif (rc) {\n\t\tqed_iwarp_destroy_ep(p_hwfn, ep, true);\n\t\tgoto err;\n\t}\n\n\treturn rc;\nerr:\n\tqed_iwarp_cid_cleaned(p_hwfn, cid);\n\n\treturn rc;\n}\n\nstatic struct qed_iwarp_ep *qed_iwarp_get_free_ep(struct qed_hwfn *p_hwfn)\n{\n\tstruct qed_iwarp_ep *ep = NULL;\n\tint rc;\n\n\tspin_lock_bh(&p_hwfn->p_rdma_info->iwarp.iw_lock);\n\n\tif (list_empty(&p_hwfn->p_rdma_info->iwarp.ep_free_list)) {\n\t\tDP_ERR(p_hwfn, \"Ep list is empty\\n\");\n\t\tgoto out;\n\t}\n\n\tep = list_first_entry(&p_hwfn->p_rdma_info->iwarp.ep_free_list,\n\t\t\t      struct qed_iwarp_ep, list_entry);\n\n\t \n\tif (ep->tcp_cid == QED_IWARP_INVALID_TCP_CID) {\n\t\trc = qed_iwarp_alloc_tcp_cid(p_hwfn, &ep->tcp_cid);\n\n\t\t \n\t\tif (rc) {\n\t\t\tep->tcp_cid = QED_IWARP_INVALID_TCP_CID;\n\t\t\tep = NULL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tlist_del(&ep->list_entry);\n\nout:\n\tspin_unlock_bh(&p_hwfn->p_rdma_info->iwarp.iw_lock);\n\treturn ep;\n}\n\n#define QED_IWARP_MAX_CID_CLEAN_TIME  100\n#define QED_IWARP_MAX_NO_PROGRESS_CNT 5\n\n \nstatic int\nqed_iwarp_wait_cid_map_cleared(struct qed_hwfn *p_hwfn, struct qed_bmap *bmap)\n{\n\tint prev_weight = 0;\n\tint wait_count = 0;\n\tint weight = 0;\n\n\tweight = bitmap_weight(bmap->bitmap, bmap->max_count);\n\tprev_weight = weight;\n\n\twhile (weight) {\n\t\t \n\t\tif (p_hwfn->cdev->recov_in_prog)\n\t\t\treturn 0;\n\n\t\tmsleep(QED_IWARP_MAX_CID_CLEAN_TIME);\n\n\t\tweight = bitmap_weight(bmap->bitmap, bmap->max_count);\n\n\t\tif (prev_weight == weight) {\n\t\t\twait_count++;\n\t\t} else {\n\t\t\tprev_weight = weight;\n\t\t\twait_count = 0;\n\t\t}\n\n\t\tif (wait_count > QED_IWARP_MAX_NO_PROGRESS_CNT) {\n\t\t\tDP_NOTICE(p_hwfn,\n\t\t\t\t  \"%s bitmap wait timed out (%d cids pending)\\n\",\n\t\t\t\t  bmap->name, weight);\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int qed_iwarp_wait_for_all_cids(struct qed_hwfn *p_hwfn)\n{\n\tint rc;\n\tint i;\n\n\trc = qed_iwarp_wait_cid_map_cleared(p_hwfn,\n\t\t\t\t\t    &p_hwfn->p_rdma_info->tcp_cid_map);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tfor (i = 0; i < QED_IWARP_PREALLOC_CNT; i++)\n\t\tqed_bmap_release_id(p_hwfn, &p_hwfn->p_rdma_info->cid_map, i);\n\n\t \n\treturn qed_iwarp_wait_cid_map_cleared(p_hwfn,\n\t\t\t\t\t      &p_hwfn->p_rdma_info->cid_map);\n}\n\nstatic void qed_iwarp_free_prealloc_ep(struct qed_hwfn *p_hwfn)\n{\n\tstruct qed_iwarp_ep *ep;\n\n\twhile (!list_empty(&p_hwfn->p_rdma_info->iwarp.ep_free_list)) {\n\t\tspin_lock_bh(&p_hwfn->p_rdma_info->iwarp.iw_lock);\n\n\t\tep = list_first_entry(&p_hwfn->p_rdma_info->iwarp.ep_free_list,\n\t\t\t\t      struct qed_iwarp_ep, list_entry);\n\n\t\tif (!ep) {\n\t\t\tspin_unlock_bh(&p_hwfn->p_rdma_info->iwarp.iw_lock);\n\t\t\tbreak;\n\t\t}\n\t\tlist_del(&ep->list_entry);\n\n\t\tspin_unlock_bh(&p_hwfn->p_rdma_info->iwarp.iw_lock);\n\n\t\tif (ep->tcp_cid != QED_IWARP_INVALID_TCP_CID)\n\t\t\tqed_iwarp_cid_cleaned(p_hwfn, ep->tcp_cid);\n\n\t\tqed_iwarp_destroy_ep(p_hwfn, ep, false);\n\t}\n}\n\nstatic int qed_iwarp_prealloc_ep(struct qed_hwfn *p_hwfn, bool init)\n{\n\tstruct qed_iwarp_ep *ep;\n\tint rc = 0;\n\tint count;\n\tu32 cid;\n\tint i;\n\n\tcount = init ? QED_IWARP_PREALLOC_CNT : 1;\n\tfor (i = 0; i < count; i++) {\n\t\trc = qed_iwarp_create_ep(p_hwfn, &ep);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\t \n\t\tif (init) {\n\t\t\trc = qed_iwarp_alloc_cid(p_hwfn, &cid);\n\t\t\tif (rc)\n\t\t\t\tgoto err;\n\t\t\tqed_iwarp_set_tcp_cid(p_hwfn, cid);\n\t\t} else {\n\t\t\t \n\t\t\tqed_iwarp_alloc_tcp_cid(p_hwfn, &cid);\n\t\t}\n\n\t\tep->tcp_cid = cid;\n\n\t\tspin_lock_bh(&p_hwfn->p_rdma_info->iwarp.iw_lock);\n\t\tlist_add_tail(&ep->list_entry,\n\t\t\t      &p_hwfn->p_rdma_info->iwarp.ep_free_list);\n\t\tspin_unlock_bh(&p_hwfn->p_rdma_info->iwarp.iw_lock);\n\t}\n\n\treturn rc;\n\nerr:\n\tqed_iwarp_destroy_ep(p_hwfn, ep, false);\n\n\treturn rc;\n}\n\nint qed_iwarp_alloc(struct qed_hwfn *p_hwfn)\n{\n\tint rc;\n\n\t \n\trc = qed_rdma_bmap_alloc(p_hwfn, &p_hwfn->p_rdma_info->tcp_cid_map,\n\t\t\t\t QED_IWARP_PREALLOC_CNT, \"TCP_CID\");\n\tif (rc) {\n\t\tDP_VERBOSE(p_hwfn, QED_MSG_RDMA,\n\t\t\t   \"Failed to allocate tcp cid, rc = %d\\n\", rc);\n\t\treturn rc;\n\t}\n\n\tINIT_LIST_HEAD(&p_hwfn->p_rdma_info->iwarp.ep_free_list);\n\tspin_lock_init(&p_hwfn->p_rdma_info->iwarp.iw_lock);\n\n\trc = qed_iwarp_prealloc_ep(p_hwfn, true);\n\tif (rc)\n\t\treturn rc;\n\n\treturn qed_ooo_alloc(p_hwfn);\n}\n\nvoid qed_iwarp_resc_free(struct qed_hwfn *p_hwfn)\n{\n\tstruct qed_iwarp_info *iwarp_info = &p_hwfn->p_rdma_info->iwarp;\n\n\tqed_ooo_free(p_hwfn);\n\tqed_rdma_bmap_free(p_hwfn, &p_hwfn->p_rdma_info->tcp_cid_map, 1);\n\tkfree(iwarp_info->mpa_bufs);\n\tkfree(iwarp_info->partial_fpdus);\n\tkfree(iwarp_info->mpa_intermediate_buf);\n}\n\nint qed_iwarp_accept(void *rdma_cxt, struct qed_iwarp_accept_in *iparams)\n{\n\tstruct qed_hwfn *p_hwfn = rdma_cxt;\n\tstruct qed_iwarp_ep *ep;\n\tu8 mpa_data_size = 0;\n\tint rc;\n\n\tep = iparams->ep_context;\n\tif (!ep) {\n\t\tDP_ERR(p_hwfn, \"Ep Context receive in accept is NULL\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tDP_VERBOSE(p_hwfn, QED_MSG_RDMA, \"QP(0x%x) EP(0x%x)\\n\",\n\t\t   iparams->qp->icid, ep->tcp_cid);\n\n\tif ((iparams->ord > QED_IWARP_ORD_DEFAULT) ||\n\t    (iparams->ird > QED_IWARP_IRD_DEFAULT)) {\n\t\tDP_VERBOSE(p_hwfn,\n\t\t\t   QED_MSG_RDMA,\n\t\t\t   \"QP(0x%x) EP(0x%x) ERROR: Invalid ord(0x%x)/ird(0x%x)\\n\",\n\t\t\t   iparams->qp->icid,\n\t\t\t   ep->tcp_cid, iparams->ord, iparams->ord);\n\t\treturn -EINVAL;\n\t}\n\n\tqed_iwarp_prealloc_ep(p_hwfn, false);\n\n\tep->cb_context = iparams->cb_context;\n\tep->qp = iparams->qp;\n\tep->qp->ep = ep;\n\n\tif (ep->mpa_rev == MPA_NEGOTIATION_TYPE_ENHANCED) {\n\t\t \n\t\tif (iparams->ord > ep->cm_info.ird)\n\t\t\tiparams->ord = ep->cm_info.ird;\n\n\t\tif ((ep->rtr_type & MPA_RTR_TYPE_ZERO_READ) &&\n\t\t    (iparams->ird == 0))\n\t\t\tiparams->ird = 1;\n\t}\n\n\t \n\tep->cm_info.ord = iparams->ord;\n\tep->cm_info.ird = iparams->ird;\n\n\tqed_iwarp_mpa_v2_set_private(p_hwfn, ep, &mpa_data_size);\n\n\tep->cm_info.private_data = ep->ep_buffer_virt->out_pdata;\n\tep->cm_info.private_data_len = iparams->private_data_len +\n\t\t\t\t       mpa_data_size;\n\n\tmemcpy((u8 *)ep->ep_buffer_virt->out_pdata + mpa_data_size,\n\t       iparams->private_data, iparams->private_data_len);\n\n\trc = qed_iwarp_mpa_offload(p_hwfn, ep);\n\tif (rc)\n\t\tqed_iwarp_modify_qp(p_hwfn,\n\t\t\t\t    iparams->qp, QED_IWARP_QP_STATE_ERROR, 1);\n\n\treturn rc;\n}\n\nint qed_iwarp_reject(void *rdma_cxt, struct qed_iwarp_reject_in *iparams)\n{\n\tstruct qed_hwfn *p_hwfn = rdma_cxt;\n\tstruct qed_iwarp_ep *ep;\n\tu8 mpa_data_size = 0;\n\n\tep = iparams->ep_context;\n\tif (!ep) {\n\t\tDP_ERR(p_hwfn, \"Ep Context receive in reject is NULL\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tDP_VERBOSE(p_hwfn, QED_MSG_RDMA, \"EP(0x%x)\\n\", ep->tcp_cid);\n\n\tep->cb_context = iparams->cb_context;\n\tep->qp = NULL;\n\n\tqed_iwarp_mpa_v2_set_private(p_hwfn, ep, &mpa_data_size);\n\n\tep->cm_info.private_data = ep->ep_buffer_virt->out_pdata;\n\tep->cm_info.private_data_len = iparams->private_data_len +\n\t\t\t\t       mpa_data_size;\n\n\tmemcpy((u8 *)ep->ep_buffer_virt->out_pdata + mpa_data_size,\n\t       iparams->private_data, iparams->private_data_len);\n\n\treturn qed_iwarp_mpa_offload(p_hwfn, ep);\n}\n\nstatic void\nqed_iwarp_print_cm_info(struct qed_hwfn *p_hwfn,\n\t\t\tstruct qed_iwarp_cm_info *cm_info)\n{\n\tDP_VERBOSE(p_hwfn, QED_MSG_RDMA, \"ip_version = %d\\n\",\n\t\t   cm_info->ip_version);\n\n\tif (cm_info->ip_version == QED_TCP_IPV4)\n\t\tDP_VERBOSE(p_hwfn, QED_MSG_RDMA,\n\t\t\t   \"remote_ip %pI4h:%x, local_ip %pI4h:%x vlan=%x\\n\",\n\t\t\t   cm_info->remote_ip, cm_info->remote_port,\n\t\t\t   cm_info->local_ip, cm_info->local_port,\n\t\t\t   cm_info->vlan);\n\telse\n\t\tDP_VERBOSE(p_hwfn, QED_MSG_RDMA,\n\t\t\t   \"remote_ip %pI6:%x, local_ip %pI6:%x vlan=%x\\n\",\n\t\t\t   cm_info->remote_ip, cm_info->remote_port,\n\t\t\t   cm_info->local_ip, cm_info->local_port,\n\t\t\t   cm_info->vlan);\n\n\tDP_VERBOSE(p_hwfn, QED_MSG_RDMA,\n\t\t   \"private_data_len = %x ord = %d, ird = %d\\n\",\n\t\t   cm_info->private_data_len, cm_info->ord, cm_info->ird);\n}\n\nstatic int\nqed_iwarp_ll2_post_rx(struct qed_hwfn *p_hwfn,\n\t\t      struct qed_iwarp_ll2_buff *buf, u8 handle)\n{\n\tint rc;\n\n\trc = qed_ll2_post_rx_buffer(p_hwfn, handle, buf->data_phys_addr,\n\t\t\t\t    (u16)buf->buff_size, buf, 1);\n\tif (rc) {\n\t\tDP_NOTICE(p_hwfn,\n\t\t\t  \"Failed to repost rx buffer to ll2 rc = %d, handle=%d\\n\",\n\t\t\t  rc, handle);\n\t\tdma_free_coherent(&p_hwfn->cdev->pdev->dev, buf->buff_size,\n\t\t\t\t  buf->data, buf->data_phys_addr);\n\t\tkfree(buf);\n\t}\n\n\treturn rc;\n}\n\nstatic bool\nqed_iwarp_ep_exists(struct qed_hwfn *p_hwfn, struct qed_iwarp_cm_info *cm_info)\n{\n\tstruct qed_iwarp_ep *ep = NULL;\n\tbool found = false;\n\n\tlist_for_each_entry(ep,\n\t\t\t    &p_hwfn->p_rdma_info->iwarp.ep_list,\n\t\t\t    list_entry) {\n\t\tif ((ep->cm_info.local_port == cm_info->local_port) &&\n\t\t    (ep->cm_info.remote_port == cm_info->remote_port) &&\n\t\t    (ep->cm_info.vlan == cm_info->vlan) &&\n\t\t    !memcmp(&ep->cm_info.local_ip, cm_info->local_ip,\n\t\t\t    sizeof(cm_info->local_ip)) &&\n\t\t    !memcmp(&ep->cm_info.remote_ip, cm_info->remote_ip,\n\t\t\t    sizeof(cm_info->remote_ip))) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (found) {\n\t\tDP_NOTICE(p_hwfn,\n\t\t\t  \"SYN received on active connection - dropping\\n\");\n\t\tqed_iwarp_print_cm_info(p_hwfn, cm_info);\n\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic struct qed_iwarp_listener *\nqed_iwarp_get_listener(struct qed_hwfn *p_hwfn,\n\t\t       struct qed_iwarp_cm_info *cm_info)\n{\n\tstruct qed_iwarp_listener *listener = NULL;\n\tstatic const u32 ip_zero[4] = { 0, 0, 0, 0 };\n\tbool found = false;\n\n\tlist_for_each_entry(listener,\n\t\t\t    &p_hwfn->p_rdma_info->iwarp.listen_list,\n\t\t\t    list_entry) {\n\t\tif (listener->port == cm_info->local_port) {\n\t\t\tif (!memcmp(listener->ip_addr,\n\t\t\t\t    ip_zero, sizeof(ip_zero))) {\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!memcmp(listener->ip_addr,\n\t\t\t\t    cm_info->local_ip,\n\t\t\t\t    sizeof(cm_info->local_ip)) &&\n\t\t\t    (listener->vlan == cm_info->vlan)) {\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (found) {\n\t\tDP_VERBOSE(p_hwfn, QED_MSG_RDMA, \"listener found = %p\\n\",\n\t\t\t   listener);\n\t\treturn listener;\n\t}\n\n\tDP_VERBOSE(p_hwfn, QED_MSG_RDMA, \"listener not found\\n\");\n\treturn NULL;\n}\n\nstatic int\nqed_iwarp_parse_rx_pkt(struct qed_hwfn *p_hwfn,\n\t\t       struct qed_iwarp_cm_info *cm_info,\n\t\t       void *buf,\n\t\t       u8 *remote_mac_addr,\n\t\t       u8 *local_mac_addr,\n\t\t       int *payload_len, int *tcp_start_offset)\n{\n\tstruct vlan_ethhdr *vethh;\n\tbool vlan_valid = false;\n\tstruct ipv6hdr *ip6h;\n\tstruct ethhdr *ethh;\n\tstruct tcphdr *tcph;\n\tstruct iphdr *iph;\n\tint eth_hlen;\n\tint ip_hlen;\n\tint eth_type;\n\tint i;\n\n\tethh = buf;\n\teth_type = ntohs(ethh->h_proto);\n\tif (eth_type == ETH_P_8021Q) {\n\t\tvlan_valid = true;\n\t\tvethh = (struct vlan_ethhdr *)ethh;\n\t\tcm_info->vlan = ntohs(vethh->h_vlan_TCI) & VLAN_VID_MASK;\n\t\teth_type = ntohs(vethh->h_vlan_encapsulated_proto);\n\t}\n\n\teth_hlen = ETH_HLEN + (vlan_valid ? sizeof(u32) : 0);\n\n\tif (!ether_addr_equal(ethh->h_dest,\n\t\t\t      p_hwfn->p_rdma_info->iwarp.mac_addr)) {\n\t\tDP_VERBOSE(p_hwfn,\n\t\t\t   QED_MSG_RDMA,\n\t\t\t   \"Got unexpected mac %pM instead of %pM\\n\",\n\t\t\t   ethh->h_dest, p_hwfn->p_rdma_info->iwarp.mac_addr);\n\t\treturn -EINVAL;\n\t}\n\n\tether_addr_copy(remote_mac_addr, ethh->h_source);\n\tether_addr_copy(local_mac_addr, ethh->h_dest);\n\n\tDP_VERBOSE(p_hwfn, QED_MSG_RDMA, \"eth_type =%d source mac: %pM\\n\",\n\t\t   eth_type, ethh->h_source);\n\n\tDP_VERBOSE(p_hwfn, QED_MSG_RDMA, \"eth_hlen=%d destination mac: %pM\\n\",\n\t\t   eth_hlen, ethh->h_dest);\n\n\tiph = (struct iphdr *)((u8 *)(ethh) + eth_hlen);\n\n\tif (eth_type == ETH_P_IP) {\n\t\tif (iph->protocol != IPPROTO_TCP) {\n\t\t\tDP_NOTICE(p_hwfn,\n\t\t\t\t  \"Unexpected ip protocol on ll2 %x\\n\",\n\t\t\t\t  iph->protocol);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tcm_info->local_ip[0] = ntohl(iph->daddr);\n\t\tcm_info->remote_ip[0] = ntohl(iph->saddr);\n\t\tcm_info->ip_version = QED_TCP_IPV4;\n\n\t\tip_hlen = (iph->ihl) * sizeof(u32);\n\t\t*payload_len = ntohs(iph->tot_len) - ip_hlen;\n\t} else if (eth_type == ETH_P_IPV6) {\n\t\tip6h = (struct ipv6hdr *)iph;\n\n\t\tif (ip6h->nexthdr != IPPROTO_TCP) {\n\t\t\tDP_NOTICE(p_hwfn,\n\t\t\t\t  \"Unexpected ip protocol on ll2 %x\\n\",\n\t\t\t\t  iph->protocol);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tcm_info->local_ip[i] =\n\t\t\t    ntohl(ip6h->daddr.in6_u.u6_addr32[i]);\n\t\t\tcm_info->remote_ip[i] =\n\t\t\t    ntohl(ip6h->saddr.in6_u.u6_addr32[i]);\n\t\t}\n\t\tcm_info->ip_version = QED_TCP_IPV6;\n\n\t\tip_hlen = sizeof(*ip6h);\n\t\t*payload_len = ntohs(ip6h->payload_len);\n\t} else {\n\t\tDP_NOTICE(p_hwfn, \"Unexpected ethertype on ll2 %x\\n\", eth_type);\n\t\treturn -EINVAL;\n\t}\n\n\ttcph = (struct tcphdr *)((u8 *)iph + ip_hlen);\n\n\tif (!tcph->syn) {\n\t\tDP_NOTICE(p_hwfn,\n\t\t\t  \"Only SYN type packet expected on this ll2 conn, iph->ihl=%d source=%d dest=%d\\n\",\n\t\t\t  iph->ihl, tcph->source, tcph->dest);\n\t\treturn -EINVAL;\n\t}\n\n\tcm_info->local_port = ntohs(tcph->dest);\n\tcm_info->remote_port = ntohs(tcph->source);\n\n\tqed_iwarp_print_cm_info(p_hwfn, cm_info);\n\n\t*tcp_start_offset = eth_hlen + ip_hlen;\n\n\treturn 0;\n}\n\nstatic struct qed_iwarp_fpdu *qed_iwarp_get_curr_fpdu(struct qed_hwfn *p_hwfn,\n\t\t\t\t\t\t      u16 cid)\n{\n\tstruct qed_iwarp_info *iwarp_info = &p_hwfn->p_rdma_info->iwarp;\n\tstruct qed_iwarp_fpdu *partial_fpdu;\n\tu32 idx;\n\n\tidx = cid - qed_cxt_get_proto_cid_start(p_hwfn, PROTOCOLID_IWARP);\n\tif (idx >= iwarp_info->max_num_partial_fpdus) {\n\t\tDP_ERR(p_hwfn, \"Invalid cid %x max_num_partial_fpdus=%x\\n\", cid,\n\t\t       iwarp_info->max_num_partial_fpdus);\n\t\treturn NULL;\n\t}\n\n\tpartial_fpdu = &iwarp_info->partial_fpdus[idx];\n\n\treturn partial_fpdu;\n}\n\nenum qed_iwarp_mpa_pkt_type {\n\tQED_IWARP_MPA_PKT_PACKED,\n\tQED_IWARP_MPA_PKT_PARTIAL,\n\tQED_IWARP_MPA_PKT_UNALIGNED\n};\n\n#define QED_IWARP_INVALID_FPDU_LENGTH 0xffff\n#define QED_IWARP_MPA_FPDU_LENGTH_SIZE (2)\n#define QED_IWARP_MPA_CRC32_DIGEST_SIZE (4)\n\n \n#define QED_IWARP_PDU_DATA_LEN_WITH_PAD(data_len) ALIGN(data_len, 4)\n#define QED_IWARP_FPDU_LEN_WITH_PAD(_mpa_len)\t\t\t\t   \\\n\t(QED_IWARP_PDU_DATA_LEN_WITH_PAD((_mpa_len) +\t\t\t   \\\n\t\t\t\t\t QED_IWARP_MPA_FPDU_LENGTH_SIZE) + \\\n\t\t\t\t\t QED_IWARP_MPA_CRC32_DIGEST_SIZE)\n\n \n#define QED_IWARP_MAX_BDS_PER_FPDU 3\n\nstatic const char * const pkt_type_str[] = {\n\t\"QED_IWARP_MPA_PKT_PACKED\",\n\t\"QED_IWARP_MPA_PKT_PARTIAL\",\n\t\"QED_IWARP_MPA_PKT_UNALIGNED\"\n};\n\nstatic int\nqed_iwarp_recycle_pkt(struct qed_hwfn *p_hwfn,\n\t\t      struct qed_iwarp_fpdu *fpdu,\n\t\t      struct qed_iwarp_ll2_buff *buf);\n\nstatic enum qed_iwarp_mpa_pkt_type\nqed_iwarp_mpa_classify(struct qed_hwfn *p_hwfn,\n\t\t       struct qed_iwarp_fpdu *fpdu,\n\t\t       u16 tcp_payload_len, u8 *mpa_data)\n{\n\tenum qed_iwarp_mpa_pkt_type pkt_type;\n\tu16 mpa_len;\n\n\tif (fpdu->incomplete_bytes) {\n\t\tpkt_type = QED_IWARP_MPA_PKT_UNALIGNED;\n\t\tgoto out;\n\t}\n\n\t \n\tif (tcp_payload_len == 1) {\n\t\tfpdu->fpdu_length = *mpa_data << BITS_PER_BYTE;\n\t\tpkt_type = QED_IWARP_MPA_PKT_PARTIAL;\n\t\tgoto out;\n\t}\n\n\tmpa_len = ntohs(*(__force __be16 *)mpa_data);\n\tfpdu->fpdu_length = QED_IWARP_FPDU_LEN_WITH_PAD(mpa_len);\n\n\tif (fpdu->fpdu_length <= tcp_payload_len)\n\t\tpkt_type = QED_IWARP_MPA_PKT_PACKED;\n\telse\n\t\tpkt_type = QED_IWARP_MPA_PKT_PARTIAL;\n\nout:\n\tDP_VERBOSE(p_hwfn, QED_MSG_RDMA,\n\t\t   \"MPA_ALIGN: %s: fpdu_length=0x%x tcp_payload_len:0x%x\\n\",\n\t\t   pkt_type_str[pkt_type], fpdu->fpdu_length, tcp_payload_len);\n\n\treturn pkt_type;\n}\n\nstatic void\nqed_iwarp_init_fpdu(struct qed_iwarp_ll2_buff *buf,\n\t\t    struct qed_iwarp_fpdu *fpdu,\n\t\t    struct unaligned_opaque_data *pkt_data,\n\t\t    u16 tcp_payload_size, u8 placement_offset)\n{\n\tu16 first_mpa_offset = le16_to_cpu(pkt_data->first_mpa_offset);\n\n\tfpdu->mpa_buf = buf;\n\tfpdu->pkt_hdr = buf->data_phys_addr + placement_offset;\n\tfpdu->pkt_hdr_size = pkt_data->tcp_payload_offset;\n\tfpdu->mpa_frag = buf->data_phys_addr + first_mpa_offset;\n\tfpdu->mpa_frag_virt = (u8 *)(buf->data) + first_mpa_offset;\n\n\tif (tcp_payload_size == 1)\n\t\tfpdu->incomplete_bytes = QED_IWARP_INVALID_FPDU_LENGTH;\n\telse if (tcp_payload_size < fpdu->fpdu_length)\n\t\tfpdu->incomplete_bytes = fpdu->fpdu_length - tcp_payload_size;\n\telse\n\t\tfpdu->incomplete_bytes = 0;\t \n\n\tfpdu->mpa_frag_len = fpdu->fpdu_length - fpdu->incomplete_bytes;\n}\n\nstatic int\nqed_iwarp_cp_pkt(struct qed_hwfn *p_hwfn,\n\t\t struct qed_iwarp_fpdu *fpdu,\n\t\t struct unaligned_opaque_data *pkt_data,\n\t\t struct qed_iwarp_ll2_buff *buf, u16 tcp_payload_size)\n{\n\tu16 first_mpa_offset = le16_to_cpu(pkt_data->first_mpa_offset);\n\tu8 *tmp_buf = p_hwfn->p_rdma_info->iwarp.mpa_intermediate_buf;\n\tint rc;\n\n\t \n\tif ((fpdu->mpa_frag_len + tcp_payload_size) > (u16)buf->buff_size) {\n\t\tDP_ERR(p_hwfn,\n\t\t       \"MPA ALIGN: Unexpected: buffer is not large enough for split fpdu buff_size = %d mpa_frag_len = %d, tcp_payload_size = %d, incomplete_bytes = %d\\n\",\n\t\t       buf->buff_size, fpdu->mpa_frag_len,\n\t\t       tcp_payload_size, fpdu->incomplete_bytes);\n\t\treturn -EINVAL;\n\t}\n\n\tDP_VERBOSE(p_hwfn, QED_MSG_RDMA,\n\t\t   \"MPA ALIGN Copying fpdu: [%p, %d] [%p, %d]\\n\",\n\t\t   fpdu->mpa_frag_virt, fpdu->mpa_frag_len,\n\t\t   (u8 *)(buf->data) + first_mpa_offset, tcp_payload_size);\n\n\tmemcpy(tmp_buf, fpdu->mpa_frag_virt, fpdu->mpa_frag_len);\n\tmemcpy(tmp_buf + fpdu->mpa_frag_len,\n\t       (u8 *)(buf->data) + first_mpa_offset, tcp_payload_size);\n\n\trc = qed_iwarp_recycle_pkt(p_hwfn, fpdu, fpdu->mpa_buf);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tmemcpy((u8 *)(buf->data), tmp_buf,\n\t       fpdu->mpa_frag_len + tcp_payload_size);\n\n\tfpdu->mpa_buf = buf;\n\t \n\t \n\tfpdu->mpa_frag = buf->data_phys_addr;\n\tfpdu->mpa_frag_virt = buf->data;\n\tfpdu->mpa_frag_len += tcp_payload_size;\n\n\tfpdu->incomplete_bytes -= tcp_payload_size;\n\n\tDP_VERBOSE(p_hwfn,\n\t\t   QED_MSG_RDMA,\n\t\t   \"MPA ALIGN: split fpdu buff_size = %d mpa_frag_len = %d, tcp_payload_size = %d, incomplete_bytes = %d\\n\",\n\t\t   buf->buff_size, fpdu->mpa_frag_len, tcp_payload_size,\n\t\t   fpdu->incomplete_bytes);\n\n\treturn 0;\n}\n\nstatic void\nqed_iwarp_update_fpdu_length(struct qed_hwfn *p_hwfn,\n\t\t\t     struct qed_iwarp_fpdu *fpdu, u8 *mpa_data)\n{\n\tu16 mpa_len;\n\n\t \n\tif (fpdu->incomplete_bytes == QED_IWARP_INVALID_FPDU_LENGTH) {\n\t\t \n\t\tmpa_len = fpdu->fpdu_length | *mpa_data;\n\t\tfpdu->fpdu_length = QED_IWARP_FPDU_LEN_WITH_PAD(mpa_len);\n\t\t \n\t\tfpdu->mpa_frag_len = 1;\n\t\tfpdu->incomplete_bytes = fpdu->fpdu_length - 1;\n\t\tDP_VERBOSE(p_hwfn,\n\t\t\t   QED_MSG_RDMA,\n\t\t\t   \"MPA_ALIGN: Partial header mpa_len=%x fpdu_length=%x incomplete_bytes=%x\\n\",\n\t\t\t   mpa_len, fpdu->fpdu_length, fpdu->incomplete_bytes);\n\t}\n}\n\n#define QED_IWARP_IS_RIGHT_EDGE(_curr_pkt) \\\n\t(GET_FIELD((_curr_pkt)->flags,\t   \\\n\t\t   UNALIGNED_OPAQUE_DATA_PKT_REACHED_WIN_RIGHT_EDGE))\n\n \nstatic int\nqed_iwarp_recycle_pkt(struct qed_hwfn *p_hwfn,\n\t\t      struct qed_iwarp_fpdu *fpdu,\n\t\t      struct qed_iwarp_ll2_buff *buf)\n{\n\tstruct qed_ll2_tx_pkt_info tx_pkt;\n\tu8 ll2_handle;\n\tint rc;\n\n\tmemset(&tx_pkt, 0, sizeof(tx_pkt));\n\ttx_pkt.num_of_bds = 1;\n\ttx_pkt.tx_dest = QED_LL2_TX_DEST_DROP;\n\ttx_pkt.l4_hdr_offset_w = fpdu->pkt_hdr_size >> 2;\n\ttx_pkt.first_frag = fpdu->pkt_hdr;\n\ttx_pkt.first_frag_len = fpdu->pkt_hdr_size;\n\tbuf->piggy_buf = NULL;\n\ttx_pkt.cookie = buf;\n\n\tll2_handle = p_hwfn->p_rdma_info->iwarp.ll2_mpa_handle;\n\n\trc = qed_ll2_prepare_tx_packet(p_hwfn, ll2_handle, &tx_pkt, true);\n\tif (rc)\n\t\tDP_VERBOSE(p_hwfn, QED_MSG_RDMA,\n\t\t\t   \"Can't drop packet rc=%d\\n\", rc);\n\n\tDP_VERBOSE(p_hwfn,\n\t\t   QED_MSG_RDMA,\n\t\t   \"MPA_ALIGN: send drop tx packet [%lx, 0x%x], buf=%p, rc=%d\\n\",\n\t\t   (unsigned long int)tx_pkt.first_frag,\n\t\t   tx_pkt.first_frag_len, buf, rc);\n\n\treturn rc;\n}\n\nstatic int\nqed_iwarp_win_right_edge(struct qed_hwfn *p_hwfn, struct qed_iwarp_fpdu *fpdu)\n{\n\tstruct qed_ll2_tx_pkt_info tx_pkt;\n\tu8 ll2_handle;\n\tint rc;\n\n\tmemset(&tx_pkt, 0, sizeof(tx_pkt));\n\ttx_pkt.num_of_bds = 1;\n\ttx_pkt.tx_dest = QED_LL2_TX_DEST_LB;\n\ttx_pkt.l4_hdr_offset_w = fpdu->pkt_hdr_size >> 2;\n\n\ttx_pkt.first_frag = fpdu->pkt_hdr;\n\ttx_pkt.first_frag_len = fpdu->pkt_hdr_size;\n\ttx_pkt.enable_ip_cksum = true;\n\ttx_pkt.enable_l4_cksum = true;\n\ttx_pkt.calc_ip_len = true;\n\t \n\ttx_pkt.vlan = IWARP_LL2_ALIGNED_RIGHT_TRIMMED_TX_QUEUE;\n\n\tll2_handle = p_hwfn->p_rdma_info->iwarp.ll2_mpa_handle;\n\n\trc = qed_ll2_prepare_tx_packet(p_hwfn, ll2_handle, &tx_pkt, true);\n\tif (rc)\n\t\tDP_VERBOSE(p_hwfn, QED_MSG_RDMA,\n\t\t\t   \"Can't send right edge rc=%d\\n\", rc);\n\tDP_VERBOSE(p_hwfn,\n\t\t   QED_MSG_RDMA,\n\t\t   \"MPA_ALIGN: Sent right edge FPDU num_bds=%d [%lx, 0x%x], rc=%d\\n\",\n\t\t   tx_pkt.num_of_bds,\n\t\t   (unsigned long int)tx_pkt.first_frag,\n\t\t   tx_pkt.first_frag_len, rc);\n\n\treturn rc;\n}\n\nstatic int\nqed_iwarp_send_fpdu(struct qed_hwfn *p_hwfn,\n\t\t    struct qed_iwarp_fpdu *fpdu,\n\t\t    struct unaligned_opaque_data *curr_pkt,\n\t\t    struct qed_iwarp_ll2_buff *buf,\n\t\t    u16 tcp_payload_size, enum qed_iwarp_mpa_pkt_type pkt_type)\n{\n\tstruct qed_ll2_tx_pkt_info tx_pkt;\n\tu16 first_mpa_offset;\n\tu8 ll2_handle;\n\tint rc;\n\n\tmemset(&tx_pkt, 0, sizeof(tx_pkt));\n\n\t \n\ttx_pkt.num_of_bds = (pkt_type == QED_IWARP_MPA_PKT_UNALIGNED) ? 3 : 2;\n\ttx_pkt.tx_dest = QED_LL2_TX_DEST_LB;\n\ttx_pkt.l4_hdr_offset_w = fpdu->pkt_hdr_size >> 2;  \n\n\t \n\tif (pkt_type == QED_IWARP_MPA_PKT_UNALIGNED ||\n\t    tcp_payload_size <= fpdu->fpdu_length)\n\t\ttx_pkt.cookie = fpdu->mpa_buf;\n\n\ttx_pkt.first_frag = fpdu->pkt_hdr;\n\ttx_pkt.first_frag_len = fpdu->pkt_hdr_size;\n\ttx_pkt.enable_ip_cksum = true;\n\ttx_pkt.enable_l4_cksum = true;\n\ttx_pkt.calc_ip_len = true;\n\t \n\ttx_pkt.vlan = IWARP_LL2_ALIGNED_TX_QUEUE;\n\n\t \n\tif (tcp_payload_size == fpdu->incomplete_bytes)\n\t\tfpdu->mpa_buf->piggy_buf = buf;\n\n\tll2_handle = p_hwfn->p_rdma_info->iwarp.ll2_mpa_handle;\n\n\t \n\trc = qed_ll2_prepare_tx_packet(p_hwfn, ll2_handle, &tx_pkt, true);\n\tif (rc)\n\t\tgoto out;\n\n\t \n\trc = qed_ll2_set_fragment_of_tx_packet(p_hwfn, ll2_handle,\n\t\t\t\t\t       fpdu->mpa_frag,\n\t\t\t\t\t       fpdu->mpa_frag_len);\n\tif (rc)\n\t\tgoto out;\n\n\tif (!fpdu->incomplete_bytes)\n\t\tgoto out;\n\n\tfirst_mpa_offset = le16_to_cpu(curr_pkt->first_mpa_offset);\n\n\t \n\trc = qed_ll2_set_fragment_of_tx_packet(p_hwfn,\n\t\t\t\t\t       ll2_handle,\n\t\t\t\t\t       buf->data_phys_addr +\n\t\t\t\t\t       first_mpa_offset,\n\t\t\t\t\t       fpdu->incomplete_bytes);\nout:\n\tDP_VERBOSE(p_hwfn,\n\t\t   QED_MSG_RDMA,\n\t\t   \"MPA_ALIGN: Sent FPDU num_bds=%d first_frag_len=%x, mpa_frag_len=0x%x, incomplete_bytes:0x%x rc=%d\\n\",\n\t\t   tx_pkt.num_of_bds,\n\t\t   tx_pkt.first_frag_len,\n\t\t   fpdu->mpa_frag_len,\n\t\t   fpdu->incomplete_bytes, rc);\n\n\treturn rc;\n}\n\nstatic void\nqed_iwarp_mpa_get_data(struct qed_hwfn *p_hwfn,\n\t\t       struct unaligned_opaque_data *curr_pkt,\n\t\t       u32 opaque_data0, u32 opaque_data1)\n{\n\tu64 opaque_data;\n\n\topaque_data = HILO_64(cpu_to_le32(opaque_data1),\n\t\t\t      cpu_to_le32(opaque_data0));\n\t*curr_pkt = *((struct unaligned_opaque_data *)&opaque_data);\n\n\tle16_add_cpu(&curr_pkt->first_mpa_offset,\n\t\t     curr_pkt->tcp_payload_offset);\n}\n\n \nstatic int\nqed_iwarp_process_mpa_pkt(struct qed_hwfn *p_hwfn,\n\t\t\t  struct qed_iwarp_ll2_mpa_buf *mpa_buf)\n{\n\tstruct unaligned_opaque_data *curr_pkt = &mpa_buf->data;\n\tstruct qed_iwarp_ll2_buff *buf = mpa_buf->ll2_buf;\n\tenum qed_iwarp_mpa_pkt_type pkt_type;\n\tstruct qed_iwarp_fpdu *fpdu;\n\tu16 cid, first_mpa_offset;\n\tint rc = -EINVAL;\n\tu8 *mpa_data;\n\n\tcid = le32_to_cpu(curr_pkt->cid);\n\n\tfpdu = qed_iwarp_get_curr_fpdu(p_hwfn, (u16)cid);\n\tif (!fpdu) {  \n\t\tDP_ERR(p_hwfn, \"Invalid cid, drop and post back to rx cid=%x\\n\",\n\t\t       cid);\n\t\tgoto err;\n\t}\n\n\tdo {\n\t\tfirst_mpa_offset = le16_to_cpu(curr_pkt->first_mpa_offset);\n\t\tmpa_data = ((u8 *)(buf->data) + first_mpa_offset);\n\n\t\tpkt_type = qed_iwarp_mpa_classify(p_hwfn, fpdu,\n\t\t\t\t\t\t  mpa_buf->tcp_payload_len,\n\t\t\t\t\t\t  mpa_data);\n\n\t\tswitch (pkt_type) {\n\t\tcase QED_IWARP_MPA_PKT_PARTIAL:\n\t\t\tqed_iwarp_init_fpdu(buf, fpdu,\n\t\t\t\t\t    curr_pkt,\n\t\t\t\t\t    mpa_buf->tcp_payload_len,\n\t\t\t\t\t    mpa_buf->placement_offset);\n\n\t\t\tif (!QED_IWARP_IS_RIGHT_EDGE(curr_pkt)) {\n\t\t\t\tmpa_buf->tcp_payload_len = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\trc = qed_iwarp_win_right_edge(p_hwfn, fpdu);\n\n\t\t\tif (rc) {\n\t\t\t\tDP_VERBOSE(p_hwfn, QED_MSG_RDMA,\n\t\t\t\t\t   \"Can't send FPDU:reset rc=%d\\n\", rc);\n\t\t\t\tmemset(fpdu, 0, sizeof(*fpdu));\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tmpa_buf->tcp_payload_len = 0;\n\t\t\tbreak;\n\t\tcase QED_IWARP_MPA_PKT_PACKED:\n\t\t\tqed_iwarp_init_fpdu(buf, fpdu,\n\t\t\t\t\t    curr_pkt,\n\t\t\t\t\t    mpa_buf->tcp_payload_len,\n\t\t\t\t\t    mpa_buf->placement_offset);\n\n\t\t\trc = qed_iwarp_send_fpdu(p_hwfn, fpdu, curr_pkt, buf,\n\t\t\t\t\t\t mpa_buf->tcp_payload_len,\n\t\t\t\t\t\t pkt_type);\n\t\t\tif (rc) {\n\t\t\t\tDP_VERBOSE(p_hwfn, QED_MSG_RDMA,\n\t\t\t\t\t   \"Can't send FPDU:reset rc=%d\\n\", rc);\n\t\t\t\tmemset(fpdu, 0, sizeof(*fpdu));\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tmpa_buf->tcp_payload_len -= fpdu->fpdu_length;\n\t\t\tle16_add_cpu(&curr_pkt->first_mpa_offset,\n\t\t\t\t     fpdu->fpdu_length);\n\t\t\tbreak;\n\t\tcase QED_IWARP_MPA_PKT_UNALIGNED:\n\t\t\tqed_iwarp_update_fpdu_length(p_hwfn, fpdu, mpa_data);\n\t\t\tif (mpa_buf->tcp_payload_len < fpdu->incomplete_bytes) {\n\t\t\t\t \n\t\t\t\tif (QED_IWARP_IS_RIGHT_EDGE(curr_pkt)) {\n\t\t\t\t\trc = qed_iwarp_win_right_edge(p_hwfn,\n\t\t\t\t\t\t\t\t      fpdu);\n\t\t\t\t\t \n\t\t\t\t\tif (rc)\n\t\t\t\t\t\treturn rc;\n\t\t\t\t}\n\n\t\t\t\trc = qed_iwarp_cp_pkt(p_hwfn, fpdu, curr_pkt,\n\t\t\t\t\t\t      buf,\n\t\t\t\t\t\t      mpa_buf->tcp_payload_len);\n\t\t\t\tif (rc)  \n\t\t\t\t\treturn rc;\n\n\t\t\t\tmpa_buf->tcp_payload_len = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\trc = qed_iwarp_send_fpdu(p_hwfn, fpdu, curr_pkt, buf,\n\t\t\t\t\t\t mpa_buf->tcp_payload_len,\n\t\t\t\t\t\t pkt_type);\n\t\t\tif (rc) {\n\t\t\t\tDP_VERBOSE(p_hwfn, QED_MSG_RDMA,\n\t\t\t\t\t   \"Can't send FPDU:delay rc=%d\\n\", rc);\n\t\t\t\t \n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tmpa_buf->tcp_payload_len -= fpdu->incomplete_bytes;\n\t\t\tle16_add_cpu(&curr_pkt->first_mpa_offset,\n\t\t\t\t     fpdu->incomplete_bytes);\n\n\t\t\t \n\t\t\tfpdu->incomplete_bytes = 0;\n\t\t\tbreak;\n\t\t}\n\t} while (mpa_buf->tcp_payload_len && !rc);\n\n\treturn rc;\n\nerr:\n\tqed_iwarp_ll2_post_rx(p_hwfn,\n\t\t\t      buf,\n\t\t\t      p_hwfn->p_rdma_info->iwarp.ll2_mpa_handle);\n\treturn rc;\n}\n\nstatic void qed_iwarp_process_pending_pkts(struct qed_hwfn *p_hwfn)\n{\n\tstruct qed_iwarp_info *iwarp_info = &p_hwfn->p_rdma_info->iwarp;\n\tstruct qed_iwarp_ll2_mpa_buf *mpa_buf = NULL;\n\tint rc;\n\n\twhile (!list_empty(&iwarp_info->mpa_buf_pending_list)) {\n\t\tmpa_buf = list_first_entry(&iwarp_info->mpa_buf_pending_list,\n\t\t\t\t\t   struct qed_iwarp_ll2_mpa_buf,\n\t\t\t\t\t   list_entry);\n\n\t\trc = qed_iwarp_process_mpa_pkt(p_hwfn, mpa_buf);\n\n\t\t \n\t\tif (rc == -EBUSY)\n\t\t\tbreak;\n\n\t\tlist_move_tail(&mpa_buf->list_entry,\n\t\t\t       &iwarp_info->mpa_buf_list);\n\n\t\tif (rc) {\t \n\t\t\tDP_NOTICE(p_hwfn, \"process pkts failed rc=%d\\n\", rc);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void\nqed_iwarp_ll2_comp_mpa_pkt(void *cxt, struct qed_ll2_comp_rx_data *data)\n{\n\tstruct qed_iwarp_ll2_mpa_buf *mpa_buf;\n\tstruct qed_iwarp_info *iwarp_info;\n\tstruct qed_hwfn *p_hwfn = cxt;\n\tu16 first_mpa_offset;\n\n\tiwarp_info = &p_hwfn->p_rdma_info->iwarp;\n\tmpa_buf = list_first_entry(&iwarp_info->mpa_buf_list,\n\t\t\t\t   struct qed_iwarp_ll2_mpa_buf, list_entry);\n\tif (!mpa_buf) {\n\t\tDP_ERR(p_hwfn, \"No free mpa buf\\n\");\n\t\tgoto err;\n\t}\n\n\tlist_del(&mpa_buf->list_entry);\n\tqed_iwarp_mpa_get_data(p_hwfn, &mpa_buf->data,\n\t\t\t       data->opaque_data_0, data->opaque_data_1);\n\n\tfirst_mpa_offset = le16_to_cpu(mpa_buf->data.first_mpa_offset);\n\n\tDP_VERBOSE(p_hwfn,\n\t\t   QED_MSG_RDMA,\n\t\t   \"LL2 MPA CompRx payload_len:0x%x\\tfirst_mpa_offset:0x%x\\ttcp_payload_offset:0x%x\\tflags:0x%x\\tcid:0x%x\\n\",\n\t\t   data->length.packet_length, first_mpa_offset,\n\t\t   mpa_buf->data.tcp_payload_offset, mpa_buf->data.flags,\n\t\t   mpa_buf->data.cid);\n\n\tmpa_buf->ll2_buf = data->cookie;\n\tmpa_buf->tcp_payload_len = data->length.packet_length -\n\t\t\t\t   first_mpa_offset;\n\n\tfirst_mpa_offset += data->u.placement_offset;\n\tmpa_buf->data.first_mpa_offset = cpu_to_le16(first_mpa_offset);\n\tmpa_buf->placement_offset = data->u.placement_offset;\n\n\tlist_add_tail(&mpa_buf->list_entry, &iwarp_info->mpa_buf_pending_list);\n\n\tqed_iwarp_process_pending_pkts(p_hwfn);\n\treturn;\nerr:\n\tqed_iwarp_ll2_post_rx(p_hwfn, data->cookie,\n\t\t\t      iwarp_info->ll2_mpa_handle);\n}\n\nstatic void\nqed_iwarp_ll2_comp_syn_pkt(void *cxt, struct qed_ll2_comp_rx_data *data)\n{\n\tstruct qed_iwarp_ll2_buff *buf = data->cookie;\n\tstruct qed_iwarp_listener *listener;\n\tstruct qed_ll2_tx_pkt_info tx_pkt;\n\tstruct qed_iwarp_cm_info cm_info;\n\tstruct qed_hwfn *p_hwfn = cxt;\n\tu8 remote_mac_addr[ETH_ALEN];\n\tu8 local_mac_addr[ETH_ALEN];\n\tstruct qed_iwarp_ep *ep;\n\tint tcp_start_offset;\n\tu8 ll2_syn_handle;\n\tint payload_len;\n\tu32 hdr_size;\n\tint rc;\n\n\tmemset(&cm_info, 0, sizeof(cm_info));\n\tll2_syn_handle = p_hwfn->p_rdma_info->iwarp.ll2_syn_handle;\n\n\t \n\tif (data->err_flags) {\n\t\tDP_NOTICE(p_hwfn, \"Error received on SYN packet: 0x%x\\n\",\n\t\t\t  data->err_flags);\n\t\tgoto err;\n\t}\n\n\tif (GET_FIELD(data->parse_flags,\n\t\t      PARSING_AND_ERR_FLAGS_L4CHKSMWASCALCULATED) &&\n\t    GET_FIELD(data->parse_flags, PARSING_AND_ERR_FLAGS_L4CHKSMERROR)) {\n\t\tDP_NOTICE(p_hwfn, \"Syn packet received with checksum error\\n\");\n\t\tgoto err;\n\t}\n\n\trc = qed_iwarp_parse_rx_pkt(p_hwfn, &cm_info, (u8 *)(buf->data) +\n\t\t\t\t    data->u.placement_offset, remote_mac_addr,\n\t\t\t\t    local_mac_addr, &payload_len,\n\t\t\t\t    &tcp_start_offset);\n\tif (rc)\n\t\tgoto err;\n\n\t \n\tlistener = qed_iwarp_get_listener(p_hwfn, &cm_info);\n\tif (!listener) {\n\t\tDP_VERBOSE(p_hwfn,\n\t\t\t   QED_MSG_RDMA,\n\t\t\t   \"SYN received on tuple not listened on parse_flags=%d packet len=%d\\n\",\n\t\t\t   data->parse_flags, data->length.packet_length);\n\n\t\tmemset(&tx_pkt, 0, sizeof(tx_pkt));\n\t\ttx_pkt.num_of_bds = 1;\n\t\ttx_pkt.l4_hdr_offset_w = (data->length.packet_length) >> 2;\n\t\ttx_pkt.tx_dest = QED_LL2_TX_DEST_LB;\n\t\ttx_pkt.first_frag = buf->data_phys_addr +\n\t\t\t\t    data->u.placement_offset;\n\t\ttx_pkt.first_frag_len = data->length.packet_length;\n\t\ttx_pkt.cookie = buf;\n\n\t\trc = qed_ll2_prepare_tx_packet(p_hwfn, ll2_syn_handle,\n\t\t\t\t\t       &tx_pkt, true);\n\n\t\tif (rc) {\n\t\t\tDP_NOTICE(p_hwfn,\n\t\t\t\t  \"Can't post SYN back to chip rc=%d\\n\", rc);\n\t\t\tgoto err;\n\t\t}\n\t\treturn;\n\t}\n\n\tDP_VERBOSE(p_hwfn, QED_MSG_RDMA, \"Received syn on listening port\\n\");\n\t \n\tif (qed_iwarp_ep_exists(p_hwfn, &cm_info))\n\t\tgoto err;\n\n\tep = qed_iwarp_get_free_ep(p_hwfn);\n\tif (!ep)\n\t\tgoto err;\n\n\tspin_lock_bh(&p_hwfn->p_rdma_info->iwarp.iw_lock);\n\tlist_add_tail(&ep->list_entry, &p_hwfn->p_rdma_info->iwarp.ep_list);\n\tspin_unlock_bh(&p_hwfn->p_rdma_info->iwarp.iw_lock);\n\n\tether_addr_copy(ep->remote_mac_addr, remote_mac_addr);\n\tether_addr_copy(ep->local_mac_addr, local_mac_addr);\n\n\tmemcpy(&ep->cm_info, &cm_info, sizeof(ep->cm_info));\n\n\thdr_size = ((cm_info.ip_version == QED_TCP_IPV4) ? 40 : 60);\n\tep->mss = p_hwfn->p_rdma_info->iwarp.max_mtu - hdr_size;\n\tep->mss = min_t(u16, QED_IWARP_MAX_FW_MSS, ep->mss);\n\n\tep->event_cb = listener->event_cb;\n\tep->cb_context = listener->cb_context;\n\tep->connect_mode = TCP_CONNECT_PASSIVE;\n\n\tep->syn = buf;\n\tep->syn_ip_payload_length = (u16)payload_len;\n\tep->syn_phy_addr = buf->data_phys_addr + data->u.placement_offset +\n\t\t\t   tcp_start_offset;\n\n\trc = qed_iwarp_tcp_offload(p_hwfn, ep);\n\tif (rc) {\n\t\tqed_iwarp_return_ep(p_hwfn, ep);\n\t\tgoto err;\n\t}\n\n\treturn;\nerr:\n\tqed_iwarp_ll2_post_rx(p_hwfn, buf, ll2_syn_handle);\n}\n\nstatic void qed_iwarp_ll2_rel_rx_pkt(void *cxt, u8 connection_handle,\n\t\t\t\t     void *cookie, dma_addr_t rx_buf_addr,\n\t\t\t\t     bool b_last_packet)\n{\n\tstruct qed_iwarp_ll2_buff *buffer = cookie;\n\tstruct qed_hwfn *p_hwfn = cxt;\n\n\tdma_free_coherent(&p_hwfn->cdev->pdev->dev, buffer->buff_size,\n\t\t\t  buffer->data, buffer->data_phys_addr);\n\tkfree(buffer);\n}\n\nstatic void qed_iwarp_ll2_comp_tx_pkt(void *cxt, u8 connection_handle,\n\t\t\t\t      void *cookie, dma_addr_t first_frag_addr,\n\t\t\t\t      bool b_last_fragment, bool b_last_packet)\n{\n\tstruct qed_iwarp_ll2_buff *buffer = cookie;\n\tstruct qed_iwarp_ll2_buff *piggy;\n\tstruct qed_hwfn *p_hwfn = cxt;\n\n\tif (!buffer)\t\t \n\t\treturn;\n\n\t \n\tpiggy = buffer->piggy_buf;\n\tif (piggy) {\n\t\tbuffer->piggy_buf = NULL;\n\t\tqed_iwarp_ll2_post_rx(p_hwfn, piggy, connection_handle);\n\t}\n\n\tqed_iwarp_ll2_post_rx(p_hwfn, buffer, connection_handle);\n\n\tif (connection_handle == p_hwfn->p_rdma_info->iwarp.ll2_mpa_handle)\n\t\tqed_iwarp_process_pending_pkts(p_hwfn);\n\n\treturn;\n}\n\nstatic void qed_iwarp_ll2_rel_tx_pkt(void *cxt, u8 connection_handle,\n\t\t\t\t     void *cookie, dma_addr_t first_frag_addr,\n\t\t\t\t     bool b_last_fragment, bool b_last_packet)\n{\n\tstruct qed_iwarp_ll2_buff *buffer = cookie;\n\tstruct qed_hwfn *p_hwfn = cxt;\n\n\tif (!buffer)\n\t\treturn;\n\n\tif (buffer->piggy_buf) {\n\t\tdma_free_coherent(&p_hwfn->cdev->pdev->dev,\n\t\t\t\t  buffer->piggy_buf->buff_size,\n\t\t\t\t  buffer->piggy_buf->data,\n\t\t\t\t  buffer->piggy_buf->data_phys_addr);\n\n\t\tkfree(buffer->piggy_buf);\n\t}\n\n\tdma_free_coherent(&p_hwfn->cdev->pdev->dev, buffer->buff_size,\n\t\t\t  buffer->data, buffer->data_phys_addr);\n\n\tkfree(buffer);\n}\n\n \nstatic void\nqed_iwarp_ll2_slowpath(void *cxt,\n\t\t       u8 connection_handle,\n\t\t       u32 opaque_data_0, u32 opaque_data_1)\n{\n\tstruct unaligned_opaque_data unalign_data;\n\tstruct qed_hwfn *p_hwfn = cxt;\n\tstruct qed_iwarp_fpdu *fpdu;\n\tu32 cid;\n\n\tqed_iwarp_mpa_get_data(p_hwfn, &unalign_data,\n\t\t\t       opaque_data_0, opaque_data_1);\n\n\tcid = le32_to_cpu(unalign_data.cid);\n\n\tDP_VERBOSE(p_hwfn, QED_MSG_RDMA, \"(0x%x) Flush fpdu\\n\", cid);\n\n\tfpdu = qed_iwarp_get_curr_fpdu(p_hwfn, (u16)cid);\n\tif (fpdu)\n\t\tmemset(fpdu, 0, sizeof(*fpdu));\n}\n\nstatic int qed_iwarp_ll2_stop(struct qed_hwfn *p_hwfn)\n{\n\tstruct qed_iwarp_info *iwarp_info = &p_hwfn->p_rdma_info->iwarp;\n\tint rc = 0;\n\n\tif (iwarp_info->ll2_syn_handle != QED_IWARP_HANDLE_INVAL) {\n\t\trc = qed_ll2_terminate_connection(p_hwfn,\n\t\t\t\t\t\t  iwarp_info->ll2_syn_handle);\n\t\tif (rc)\n\t\t\tDP_INFO(p_hwfn, \"Failed to terminate syn connection\\n\");\n\n\t\tqed_ll2_release_connection(p_hwfn, iwarp_info->ll2_syn_handle);\n\t\tiwarp_info->ll2_syn_handle = QED_IWARP_HANDLE_INVAL;\n\t}\n\n\tif (iwarp_info->ll2_ooo_handle != QED_IWARP_HANDLE_INVAL) {\n\t\trc = qed_ll2_terminate_connection(p_hwfn,\n\t\t\t\t\t\t  iwarp_info->ll2_ooo_handle);\n\t\tif (rc)\n\t\t\tDP_INFO(p_hwfn, \"Failed to terminate ooo connection\\n\");\n\n\t\tqed_ll2_release_connection(p_hwfn, iwarp_info->ll2_ooo_handle);\n\t\tiwarp_info->ll2_ooo_handle = QED_IWARP_HANDLE_INVAL;\n\t}\n\n\tif (iwarp_info->ll2_mpa_handle != QED_IWARP_HANDLE_INVAL) {\n\t\trc = qed_ll2_terminate_connection(p_hwfn,\n\t\t\t\t\t\t  iwarp_info->ll2_mpa_handle);\n\t\tif (rc)\n\t\t\tDP_INFO(p_hwfn, \"Failed to terminate mpa connection\\n\");\n\n\t\tqed_ll2_release_connection(p_hwfn, iwarp_info->ll2_mpa_handle);\n\t\tiwarp_info->ll2_mpa_handle = QED_IWARP_HANDLE_INVAL;\n\t}\n\n\tqed_llh_remove_mac_filter(p_hwfn->cdev, 0,\n\t\t\t\t  p_hwfn->p_rdma_info->iwarp.mac_addr);\n\n\treturn rc;\n}\n\nstatic int\nqed_iwarp_ll2_alloc_buffers(struct qed_hwfn *p_hwfn,\n\t\t\t    int num_rx_bufs, int buff_size, u8 ll2_handle)\n{\n\tstruct qed_iwarp_ll2_buff *buffer;\n\tint rc = 0;\n\tint i;\n\n\tfor (i = 0; i < num_rx_bufs; i++) {\n\t\tbuffer = kzalloc(sizeof(*buffer), GFP_KERNEL);\n\t\tif (!buffer) {\n\t\t\trc = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\tbuffer->data = dma_alloc_coherent(&p_hwfn->cdev->pdev->dev,\n\t\t\t\t\t\t  buff_size,\n\t\t\t\t\t\t  &buffer->data_phys_addr,\n\t\t\t\t\t\t  GFP_KERNEL);\n\t\tif (!buffer->data) {\n\t\t\tkfree(buffer);\n\t\t\trc = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\tbuffer->buff_size = buff_size;\n\t\trc = qed_iwarp_ll2_post_rx(p_hwfn, buffer, ll2_handle);\n\t\tif (rc)\n\t\t\t \n\t\t\tbreak;\n\t}\n\treturn rc;\n}\n\n#define QED_IWARP_MAX_BUF_SIZE(mtu)\t\t\t\t     \\\n\tALIGN((mtu) + ETH_HLEN + 2 * VLAN_HLEN + 2 + ETH_CACHE_LINE_SIZE, \\\n\t\tETH_CACHE_LINE_SIZE)\n\nstatic int\nqed_iwarp_ll2_start(struct qed_hwfn *p_hwfn,\n\t\t    struct qed_rdma_start_in_params *params,\n\t\t    u32 rcv_wnd_size)\n{\n\tstruct qed_iwarp_info *iwarp_info;\n\tstruct qed_ll2_acquire_data data;\n\tstruct qed_ll2_cbs cbs;\n\tu32 buff_size;\n\tu16 n_ooo_bufs;\n\tint rc = 0;\n\tint i;\n\n\tiwarp_info = &p_hwfn->p_rdma_info->iwarp;\n\tiwarp_info->ll2_syn_handle = QED_IWARP_HANDLE_INVAL;\n\tiwarp_info->ll2_ooo_handle = QED_IWARP_HANDLE_INVAL;\n\tiwarp_info->ll2_mpa_handle = QED_IWARP_HANDLE_INVAL;\n\n\tiwarp_info->max_mtu = params->max_mtu;\n\n\tether_addr_copy(p_hwfn->p_rdma_info->iwarp.mac_addr, params->mac_addr);\n\n\trc = qed_llh_add_mac_filter(p_hwfn->cdev, 0, params->mac_addr);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tcbs.rx_comp_cb = qed_iwarp_ll2_comp_syn_pkt;\n\tcbs.rx_release_cb = qed_iwarp_ll2_rel_rx_pkt;\n\tcbs.tx_comp_cb = qed_iwarp_ll2_comp_tx_pkt;\n\tcbs.tx_release_cb = qed_iwarp_ll2_rel_tx_pkt;\n\tcbs.slowpath_cb = NULL;\n\tcbs.cookie = p_hwfn;\n\n\tmemset(&data, 0, sizeof(data));\n\tdata.input.conn_type = QED_LL2_TYPE_IWARP;\n\t \n\tdata.input.rx_conn_type = QED_LL2_RX_TYPE_CTX;\n\tdata.input.mtu = params->max_mtu;\n\tdata.input.rx_num_desc = QED_IWARP_LL2_SYN_RX_SIZE;\n\tdata.input.tx_num_desc = QED_IWARP_LL2_SYN_TX_SIZE;\n\tdata.input.tx_max_bds_per_packet = 1;\t \n\tdata.input.tx_tc = PKT_LB_TC;\n\tdata.input.tx_dest = QED_LL2_TX_DEST_LB;\n\tdata.p_connection_handle = &iwarp_info->ll2_syn_handle;\n\tdata.cbs = &cbs;\n\n\trc = qed_ll2_acquire_connection(p_hwfn, &data);\n\tif (rc) {\n\t\tDP_NOTICE(p_hwfn, \"Failed to acquire LL2 connection\\n\");\n\t\tqed_llh_remove_mac_filter(p_hwfn->cdev, 0, params->mac_addr);\n\t\treturn rc;\n\t}\n\n\trc = qed_ll2_establish_connection(p_hwfn, iwarp_info->ll2_syn_handle);\n\tif (rc) {\n\t\tDP_NOTICE(p_hwfn, \"Failed to establish LL2 connection\\n\");\n\t\tgoto err;\n\t}\n\n\tbuff_size = QED_IWARP_MAX_BUF_SIZE(params->max_mtu);\n\trc = qed_iwarp_ll2_alloc_buffers(p_hwfn,\n\t\t\t\t\t QED_IWARP_LL2_SYN_RX_SIZE,\n\t\t\t\t\t buff_size,\n\t\t\t\t\t iwarp_info->ll2_syn_handle);\n\tif (rc)\n\t\tgoto err;\n\n\t \n\tdata.input.conn_type = QED_LL2_TYPE_OOO;\n\t \n\tdata.input.rx_conn_type = QED_LL2_RX_TYPE_LEGACY;\n\tdata.input.mtu = params->max_mtu;\n\n\tn_ooo_bufs = (QED_IWARP_MAX_OOO * rcv_wnd_size) /\n\t\t     iwarp_info->max_mtu;\n\tn_ooo_bufs = min_t(u32, n_ooo_bufs, QED_IWARP_LL2_OOO_MAX_RX_SIZE);\n\n\tdata.input.rx_num_desc = n_ooo_bufs;\n\tdata.input.rx_num_ooo_buffers = n_ooo_bufs;\n\n\tdata.input.tx_max_bds_per_packet = 1;\t \n\tdata.input.tx_num_desc = QED_IWARP_LL2_OOO_DEF_TX_SIZE;\n\tdata.p_connection_handle = &iwarp_info->ll2_ooo_handle;\n\n\trc = qed_ll2_acquire_connection(p_hwfn, &data);\n\tif (rc)\n\t\tgoto err;\n\n\trc = qed_ll2_establish_connection(p_hwfn, iwarp_info->ll2_ooo_handle);\n\tif (rc)\n\t\tgoto err;\n\n\t \n\tcbs.rx_comp_cb = qed_iwarp_ll2_comp_mpa_pkt;\n\tcbs.slowpath_cb = qed_iwarp_ll2_slowpath;\n\n\tmemset(&data, 0, sizeof(data));\n\tdata.input.conn_type = QED_LL2_TYPE_IWARP;\n\tdata.input.mtu = params->max_mtu;\n\t \n\tdata.input.rx_num_desc = n_ooo_bufs * 2;\n\tdata.input.tx_num_desc = data.input.rx_num_desc;\n\tdata.input.tx_max_bds_per_packet = QED_IWARP_MAX_BDS_PER_FPDU;\n\tdata.input.tx_tc = PKT_LB_TC;\n\tdata.input.tx_dest = QED_LL2_TX_DEST_LB;\n\tdata.p_connection_handle = &iwarp_info->ll2_mpa_handle;\n\tdata.input.secondary_queue = true;\n\tdata.cbs = &cbs;\n\n\trc = qed_ll2_acquire_connection(p_hwfn, &data);\n\tif (rc)\n\t\tgoto err;\n\n\trc = qed_ll2_establish_connection(p_hwfn, iwarp_info->ll2_mpa_handle);\n\tif (rc)\n\t\tgoto err;\n\n\trc = qed_iwarp_ll2_alloc_buffers(p_hwfn,\n\t\t\t\t\t data.input.rx_num_desc,\n\t\t\t\t\t buff_size,\n\t\t\t\t\t iwarp_info->ll2_mpa_handle);\n\tif (rc)\n\t\tgoto err;\n\n\tiwarp_info->partial_fpdus = kcalloc((u16)p_hwfn->p_rdma_info->num_qps,\n\t\t\t\t\t    sizeof(*iwarp_info->partial_fpdus),\n\t\t\t\t\t    GFP_KERNEL);\n\tif (!iwarp_info->partial_fpdus) {\n\t\trc = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tiwarp_info->max_num_partial_fpdus = (u16)p_hwfn->p_rdma_info->num_qps;\n\n\tiwarp_info->mpa_intermediate_buf = kzalloc(buff_size, GFP_KERNEL);\n\tif (!iwarp_info->mpa_intermediate_buf) {\n\t\trc = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\t \n\tiwarp_info->mpa_bufs = kcalloc(data.input.rx_num_desc,\n\t\t\t\t       sizeof(*iwarp_info->mpa_bufs),\n\t\t\t\t       GFP_KERNEL);\n\tif (!iwarp_info->mpa_bufs) {\n\t\trc = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tINIT_LIST_HEAD(&iwarp_info->mpa_buf_pending_list);\n\tINIT_LIST_HEAD(&iwarp_info->mpa_buf_list);\n\tfor (i = 0; i < data.input.rx_num_desc; i++)\n\t\tlist_add_tail(&iwarp_info->mpa_bufs[i].list_entry,\n\t\t\t      &iwarp_info->mpa_buf_list);\n\treturn rc;\nerr:\n\tqed_iwarp_ll2_stop(p_hwfn);\n\n\treturn rc;\n}\n\nstatic struct {\n\tu32 two_ports;\n\tu32 four_ports;\n} qed_iwarp_rcv_wnd_size[MAX_CHIP_IDS] = {\n\t{QED_IWARP_RCV_WND_SIZE_DEF_BB_2P, QED_IWARP_RCV_WND_SIZE_DEF_BB_4P},\n\t{QED_IWARP_RCV_WND_SIZE_DEF_AH_2P, QED_IWARP_RCV_WND_SIZE_DEF_AH_4P}\n};\n\nint qed_iwarp_setup(struct qed_hwfn *p_hwfn,\n\t\t    struct qed_rdma_start_in_params *params)\n{\n\tstruct qed_dev *cdev = p_hwfn->cdev;\n\tstruct qed_iwarp_info *iwarp_info;\n\tenum chip_ids chip_id;\n\tu32 rcv_wnd_size;\n\n\tiwarp_info = &p_hwfn->p_rdma_info->iwarp;\n\n\tiwarp_info->tcp_flags = QED_IWARP_TS_EN;\n\n\tchip_id = QED_IS_BB(cdev) ? CHIP_BB : CHIP_K2;\n\trcv_wnd_size = (qed_device_num_ports(cdev) == 4) ?\n\t\tqed_iwarp_rcv_wnd_size[chip_id].four_ports :\n\t\tqed_iwarp_rcv_wnd_size[chip_id].two_ports;\n\n\t \n\tiwarp_info->rcv_wnd_scale = ilog2(rcv_wnd_size) -\n\t    ilog2(QED_IWARP_RCV_WND_SIZE_MIN);\n\tiwarp_info->rcv_wnd_size = rcv_wnd_size >> iwarp_info->rcv_wnd_scale;\n\tiwarp_info->crc_needed = QED_IWARP_PARAM_CRC_NEEDED;\n\tiwarp_info->mpa_rev = MPA_NEGOTIATION_TYPE_ENHANCED;\n\n\tiwarp_info->peer2peer = QED_IWARP_PARAM_P2P;\n\n\tiwarp_info->rtr_type =  MPA_RTR_TYPE_ZERO_SEND |\n\t\t\t\tMPA_RTR_TYPE_ZERO_WRITE |\n\t\t\t\tMPA_RTR_TYPE_ZERO_READ;\n\n\tspin_lock_init(&p_hwfn->p_rdma_info->iwarp.qp_lock);\n\tINIT_LIST_HEAD(&p_hwfn->p_rdma_info->iwarp.ep_list);\n\tINIT_LIST_HEAD(&p_hwfn->p_rdma_info->iwarp.listen_list);\n\n\tqed_spq_register_async_cb(p_hwfn, PROTOCOLID_IWARP,\n\t\t\t\t  qed_iwarp_async_event);\n\tqed_ooo_setup(p_hwfn);\n\n\treturn qed_iwarp_ll2_start(p_hwfn, params, rcv_wnd_size);\n}\n\nint qed_iwarp_stop(struct qed_hwfn *p_hwfn)\n{\n\tint rc;\n\n\tqed_iwarp_free_prealloc_ep(p_hwfn);\n\trc = qed_iwarp_wait_for_all_cids(p_hwfn);\n\tif (rc)\n\t\treturn rc;\n\n\treturn qed_iwarp_ll2_stop(p_hwfn);\n}\n\nstatic void qed_iwarp_qp_in_error(struct qed_hwfn *p_hwfn,\n\t\t\t\t  struct qed_iwarp_ep *ep,\n\t\t\t\t  u8 fw_return_code)\n{\n\tstruct qed_iwarp_cm_event_params params;\n\n\tqed_iwarp_modify_qp(p_hwfn, ep->qp, QED_IWARP_QP_STATE_ERROR, true);\n\n\tparams.event = QED_IWARP_EVENT_CLOSE;\n\tparams.ep_context = ep;\n\tparams.cm_info = &ep->cm_info;\n\tparams.status = (fw_return_code == IWARP_QP_IN_ERROR_GOOD_CLOSE) ?\n\t\t\t 0 : -ECONNRESET;\n\n\t \n\tsmp_store_release(&ep->state, QED_IWARP_EP_CLOSED);\n\n\tspin_lock_bh(&p_hwfn->p_rdma_info->iwarp.iw_lock);\n\tlist_del(&ep->list_entry);\n\tspin_unlock_bh(&p_hwfn->p_rdma_info->iwarp.iw_lock);\n\n\tep->event_cb(ep->cb_context, &params);\n}\n\nstatic void qed_iwarp_exception_received(struct qed_hwfn *p_hwfn,\n\t\t\t\t\t struct qed_iwarp_ep *ep,\n\t\t\t\t\t int fw_ret_code)\n{\n\tstruct qed_iwarp_cm_event_params params;\n\tbool event_cb = false;\n\n\tDP_VERBOSE(p_hwfn, QED_MSG_RDMA, \"EP(0x%x) fw_ret_code=%d\\n\",\n\t\t   ep->cid, fw_ret_code);\n\n\tswitch (fw_ret_code) {\n\tcase IWARP_EXCEPTION_DETECTED_LLP_CLOSED:\n\t\tparams.status = 0;\n\t\tparams.event = QED_IWARP_EVENT_DISCONNECT;\n\t\tevent_cb = true;\n\t\tbreak;\n\tcase IWARP_EXCEPTION_DETECTED_LLP_RESET:\n\t\tparams.status = -ECONNRESET;\n\t\tparams.event = QED_IWARP_EVENT_DISCONNECT;\n\t\tevent_cb = true;\n\t\tbreak;\n\tcase IWARP_EXCEPTION_DETECTED_RQ_EMPTY:\n\t\tparams.event = QED_IWARP_EVENT_RQ_EMPTY;\n\t\tevent_cb = true;\n\t\tbreak;\n\tcase IWARP_EXCEPTION_DETECTED_IRQ_FULL:\n\t\tparams.event = QED_IWARP_EVENT_IRQ_FULL;\n\t\tevent_cb = true;\n\t\tbreak;\n\tcase IWARP_EXCEPTION_DETECTED_LLP_TIMEOUT:\n\t\tparams.event = QED_IWARP_EVENT_LLP_TIMEOUT;\n\t\tevent_cb = true;\n\t\tbreak;\n\tcase IWARP_EXCEPTION_DETECTED_REMOTE_PROTECTION_ERROR:\n\t\tparams.event = QED_IWARP_EVENT_REMOTE_PROTECTION_ERROR;\n\t\tevent_cb = true;\n\t\tbreak;\n\tcase IWARP_EXCEPTION_DETECTED_CQ_OVERFLOW:\n\t\tparams.event = QED_IWARP_EVENT_CQ_OVERFLOW;\n\t\tevent_cb = true;\n\t\tbreak;\n\tcase IWARP_EXCEPTION_DETECTED_LOCAL_CATASTROPHIC:\n\t\tparams.event = QED_IWARP_EVENT_QP_CATASTROPHIC;\n\t\tevent_cb = true;\n\t\tbreak;\n\tcase IWARP_EXCEPTION_DETECTED_LOCAL_ACCESS_ERROR:\n\t\tparams.event = QED_IWARP_EVENT_LOCAL_ACCESS_ERROR;\n\t\tevent_cb = true;\n\t\tbreak;\n\tcase IWARP_EXCEPTION_DETECTED_REMOTE_OPERATION_ERROR:\n\t\tparams.event = QED_IWARP_EVENT_REMOTE_OPERATION_ERROR;\n\t\tevent_cb = true;\n\t\tbreak;\n\tcase IWARP_EXCEPTION_DETECTED_TERMINATE_RECEIVED:\n\t\tparams.event = QED_IWARP_EVENT_TERMINATE_RECEIVED;\n\t\tevent_cb = true;\n\t\tbreak;\n\tdefault:\n\t\tDP_VERBOSE(p_hwfn, QED_MSG_RDMA,\n\t\t\t   \"Unhandled exception received...fw_ret_code=%d\\n\",\n\t\t\t   fw_ret_code);\n\t\tbreak;\n\t}\n\n\tif (event_cb) {\n\t\tparams.ep_context = ep;\n\t\tparams.cm_info = &ep->cm_info;\n\t\tep->event_cb(ep->cb_context, &params);\n\t}\n}\n\nstatic void\nqed_iwarp_tcp_connect_unsuccessful(struct qed_hwfn *p_hwfn,\n\t\t\t\t   struct qed_iwarp_ep *ep, u8 fw_return_code)\n{\n\tstruct qed_iwarp_cm_event_params params;\n\n\tmemset(&params, 0, sizeof(params));\n\tparams.event = QED_IWARP_EVENT_ACTIVE_COMPLETE;\n\tparams.ep_context = ep;\n\tparams.cm_info = &ep->cm_info;\n\t \n\tsmp_store_release(&ep->state, QED_IWARP_EP_CLOSED);\n\n\tswitch (fw_return_code) {\n\tcase IWARP_CONN_ERROR_TCP_CONNECT_INVALID_PACKET:\n\t\tDP_VERBOSE(p_hwfn, QED_MSG_RDMA,\n\t\t\t   \"%s(0x%x) TCP connect got invalid packet\\n\",\n\t\t\t   QED_IWARP_CONNECT_MODE_STRING(ep), ep->tcp_cid);\n\t\tparams.status = -ECONNRESET;\n\t\tbreak;\n\tcase IWARP_CONN_ERROR_TCP_CONNECTION_RST:\n\t\tDP_VERBOSE(p_hwfn, QED_MSG_RDMA,\n\t\t\t   \"%s(0x%x) TCP Connection Reset\\n\",\n\t\t\t   QED_IWARP_CONNECT_MODE_STRING(ep), ep->tcp_cid);\n\t\tparams.status = -ECONNRESET;\n\t\tbreak;\n\tcase IWARP_CONN_ERROR_TCP_CONNECT_TIMEOUT:\n\t\tDP_NOTICE(p_hwfn, \"%s(0x%x) TCP timeout\\n\",\n\t\t\t  QED_IWARP_CONNECT_MODE_STRING(ep), ep->tcp_cid);\n\t\tparams.status = -EBUSY;\n\t\tbreak;\n\tcase IWARP_CONN_ERROR_MPA_NOT_SUPPORTED_VER:\n\t\tDP_NOTICE(p_hwfn, \"%s(0x%x) MPA not supported VER\\n\",\n\t\t\t  QED_IWARP_CONNECT_MODE_STRING(ep), ep->tcp_cid);\n\t\tparams.status = -ECONNREFUSED;\n\t\tbreak;\n\tcase IWARP_CONN_ERROR_MPA_INVALID_PACKET:\n\t\tDP_NOTICE(p_hwfn, \"%s(0x%x) MPA Invalid Packet\\n\",\n\t\t\t  QED_IWARP_CONNECT_MODE_STRING(ep), ep->tcp_cid);\n\t\tparams.status = -ECONNRESET;\n\t\tbreak;\n\tdefault:\n\t\tDP_ERR(p_hwfn,\n\t\t       \"%s(0x%x) Unexpected return code tcp connect: %d\\n\",\n\t\t       QED_IWARP_CONNECT_MODE_STRING(ep),\n\t\t       ep->tcp_cid, fw_return_code);\n\t\tparams.status = -ECONNRESET;\n\t\tbreak;\n\t}\n\n\tif (ep->connect_mode == TCP_CONNECT_PASSIVE) {\n\t\tep->tcp_cid = QED_IWARP_INVALID_TCP_CID;\n\t\tqed_iwarp_return_ep(p_hwfn, ep);\n\t} else {\n\t\tep->event_cb(ep->cb_context, &params);\n\t\tspin_lock_bh(&p_hwfn->p_rdma_info->iwarp.iw_lock);\n\t\tlist_del(&ep->list_entry);\n\t\tspin_unlock_bh(&p_hwfn->p_rdma_info->iwarp.iw_lock);\n\t}\n}\n\nstatic void\nqed_iwarp_connect_complete(struct qed_hwfn *p_hwfn,\n\t\t\t   struct qed_iwarp_ep *ep, u8 fw_return_code)\n{\n\tu8 ll2_syn_handle = p_hwfn->p_rdma_info->iwarp.ll2_syn_handle;\n\n\tif (ep->connect_mode == TCP_CONNECT_PASSIVE) {\n\t\t \n\t\tqed_iwarp_ll2_post_rx(p_hwfn, ep->syn, ll2_syn_handle);\n\n\t\tep->syn = NULL;\n\n\t\t \n\t\tif (fw_return_code == RDMA_RETURN_OK)\n\t\t\tqed_iwarp_mpa_received(p_hwfn, ep);\n\t\telse\n\t\t\tqed_iwarp_tcp_connect_unsuccessful(p_hwfn, ep,\n\t\t\t\t\t\t\t   fw_return_code);\n\t} else {\n\t\tif (fw_return_code == RDMA_RETURN_OK)\n\t\t\tqed_iwarp_mpa_offload(p_hwfn, ep);\n\t\telse\n\t\t\tqed_iwarp_tcp_connect_unsuccessful(p_hwfn, ep,\n\t\t\t\t\t\t\t   fw_return_code);\n\t}\n}\n\nstatic inline bool\nqed_iwarp_check_ep_ok(struct qed_hwfn *p_hwfn, struct qed_iwarp_ep *ep)\n{\n\tif (!ep || (ep->sig != QED_EP_SIG)) {\n\t\tDP_ERR(p_hwfn, \"ERROR ON ASYNC ep=%p\\n\", ep);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic int qed_iwarp_async_event(struct qed_hwfn *p_hwfn, u8 fw_event_code,\n\t\t\t\t __le16 echo, union event_ring_data *data,\n\t\t\t\t u8 fw_return_code)\n{\n\tstruct qed_rdma_events events = p_hwfn->p_rdma_info->events;\n\tstruct regpair *fw_handle = &data->rdma_data.async_handle;\n\tstruct qed_iwarp_ep *ep = NULL;\n\tu16 srq_offset;\n\tu16 srq_id;\n\tu16 cid;\n\n\tep = (struct qed_iwarp_ep *)(uintptr_t)HILO_64(fw_handle->hi,\n\t\t\t\t\t\t       fw_handle->lo);\n\n\tswitch (fw_event_code) {\n\tcase IWARP_EVENT_TYPE_ASYNC_CONNECT_COMPLETE:\n\t\t \n\t\tif (!qed_iwarp_check_ep_ok(p_hwfn, ep))\n\t\t\treturn -EINVAL;\n\t\tDP_VERBOSE(p_hwfn,\n\t\t\t   QED_MSG_RDMA,\n\t\t\t   \"EP(0x%x) IWARP_EVENT_TYPE_ASYNC_CONNECT_COMPLETE fw_ret_code=%d\\n\",\n\t\t\t   ep->tcp_cid, fw_return_code);\n\t\tqed_iwarp_connect_complete(p_hwfn, ep, fw_return_code);\n\t\tbreak;\n\tcase IWARP_EVENT_TYPE_ASYNC_EXCEPTION_DETECTED:\n\t\tif (!qed_iwarp_check_ep_ok(p_hwfn, ep))\n\t\t\treturn -EINVAL;\n\t\tDP_VERBOSE(p_hwfn,\n\t\t\t   QED_MSG_RDMA,\n\t\t\t   \"QP(0x%x) IWARP_EVENT_TYPE_ASYNC_EXCEPTION_DETECTED fw_ret_code=%d\\n\",\n\t\t\t   ep->cid, fw_return_code);\n\t\tqed_iwarp_exception_received(p_hwfn, ep, fw_return_code);\n\t\tbreak;\n\tcase IWARP_EVENT_TYPE_ASYNC_QP_IN_ERROR_STATE:\n\t\t \n\t\tif (!qed_iwarp_check_ep_ok(p_hwfn, ep))\n\t\t\treturn -EINVAL;\n\t\tDP_VERBOSE(p_hwfn,\n\t\t\t   QED_MSG_RDMA,\n\t\t\t   \"QP(0x%x) IWARP_EVENT_TYPE_ASYNC_QP_IN_ERROR_STATE fw_ret_code=%d\\n\",\n\t\t\t   ep->cid, fw_return_code);\n\t\tqed_iwarp_qp_in_error(p_hwfn, ep, fw_return_code);\n\t\tbreak;\n\tcase IWARP_EVENT_TYPE_ASYNC_ENHANCED_MPA_REPLY_ARRIVED:\n\t\t \n\t\tif (!qed_iwarp_check_ep_ok(p_hwfn, ep))\n\t\t\treturn -EINVAL;\n\t\tDP_VERBOSE(p_hwfn,\n\t\t\t   QED_MSG_RDMA,\n\t\t\t   \"QP(0x%x) IWARP_EVENT_TYPE_ASYNC_MPA_HANDSHAKE_MPA_REPLY_ARRIVED fw_ret_code=%d\\n\",\n\t\t\t   ep->cid, fw_return_code);\n\t\tqed_iwarp_mpa_reply_arrived(p_hwfn, ep);\n\t\tbreak;\n\tcase IWARP_EVENT_TYPE_ASYNC_MPA_HANDSHAKE_COMPLETE:\n\t\tif (!qed_iwarp_check_ep_ok(p_hwfn, ep))\n\t\t\treturn -EINVAL;\n\t\tDP_VERBOSE(p_hwfn,\n\t\t\t   QED_MSG_RDMA,\n\t\t\t   \"QP(0x%x) IWARP_EVENT_TYPE_ASYNC_MPA_HANDSHAKE_COMPLETE fw_ret_code=%d\\n\",\n\t\t\t   ep->cid, fw_return_code);\n\t\tqed_iwarp_mpa_complete(p_hwfn, ep, fw_return_code);\n\t\tbreak;\n\tcase IWARP_EVENT_TYPE_ASYNC_CID_CLEANED:\n\t\tcid = (u16)le32_to_cpu(fw_handle->lo);\n\t\tDP_VERBOSE(p_hwfn, QED_MSG_RDMA,\n\t\t\t   \"(0x%x)IWARP_EVENT_TYPE_ASYNC_CID_CLEANED\\n\", cid);\n\t\tqed_iwarp_cid_cleaned(p_hwfn, cid);\n\n\t\tbreak;\n\tcase IWARP_EVENT_TYPE_ASYNC_SRQ_EMPTY:\n\t\tDP_NOTICE(p_hwfn, \"IWARP_EVENT_TYPE_ASYNC_SRQ_EMPTY\\n\");\n\t\tsrq_offset = p_hwfn->p_rdma_info->srq_id_offset;\n\t\t \n\t\tsrq_id = ((u16)le32_to_cpu(fw_handle->lo)) - srq_offset;\n\t\tevents.affiliated_event(events.context,\n\t\t\t\t\tQED_IWARP_EVENT_SRQ_EMPTY,\n\t\t\t\t\t&srq_id);\n\t\tbreak;\n\tcase IWARP_EVENT_TYPE_ASYNC_SRQ_LIMIT:\n\t\tDP_NOTICE(p_hwfn, \"IWARP_EVENT_TYPE_ASYNC_SRQ_LIMIT\\n\");\n\t\tsrq_offset = p_hwfn->p_rdma_info->srq_id_offset;\n\t\t \n\t\tsrq_id = ((u16)le32_to_cpu(fw_handle->lo)) - srq_offset;\n\t\tevents.affiliated_event(events.context,\n\t\t\t\t\tQED_IWARP_EVENT_SRQ_LIMIT,\n\t\t\t\t\t&srq_id);\n\t\tbreak;\n\tcase IWARP_EVENT_TYPE_ASYNC_CQ_OVERFLOW:\n\t\tDP_NOTICE(p_hwfn, \"IWARP_EVENT_TYPE_ASYNC_CQ_OVERFLOW\\n\");\n\n\t\tp_hwfn->p_rdma_info->events.affiliated_event(\n\t\t\tp_hwfn->p_rdma_info->events.context,\n\t\t\tQED_IWARP_EVENT_CQ_OVERFLOW,\n\t\t\t(void *)fw_handle);\n\t\tbreak;\n\tdefault:\n\t\tDP_ERR(p_hwfn, \"Received unexpected async iwarp event %d\\n\",\n\t\t       fw_event_code);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nint\nqed_iwarp_create_listen(void *rdma_cxt,\n\t\t\tstruct qed_iwarp_listen_in *iparams,\n\t\t\tstruct qed_iwarp_listen_out *oparams)\n{\n\tstruct qed_hwfn *p_hwfn = rdma_cxt;\n\tstruct qed_iwarp_listener *listener;\n\n\tlistener = kzalloc(sizeof(*listener), GFP_KERNEL);\n\tif (!listener)\n\t\treturn -ENOMEM;\n\n\tlistener->ip_version = iparams->ip_version;\n\tmemcpy(listener->ip_addr, iparams->ip_addr, sizeof(listener->ip_addr));\n\tlistener->port = iparams->port;\n\tlistener->vlan = iparams->vlan;\n\n\tlistener->event_cb = iparams->event_cb;\n\tlistener->cb_context = iparams->cb_context;\n\tlistener->max_backlog = iparams->max_backlog;\n\toparams->handle = listener;\n\n\tspin_lock_bh(&p_hwfn->p_rdma_info->iwarp.iw_lock);\n\tlist_add_tail(&listener->list_entry,\n\t\t      &p_hwfn->p_rdma_info->iwarp.listen_list);\n\tspin_unlock_bh(&p_hwfn->p_rdma_info->iwarp.iw_lock);\n\n\tDP_VERBOSE(p_hwfn,\n\t\t   QED_MSG_RDMA,\n\t\t   \"callback=%p handle=%p ip=%x:%x:%x:%x port=0x%x vlan=0x%x\\n\",\n\t\t   listener->event_cb,\n\t\t   listener,\n\t\t   listener->ip_addr[0],\n\t\t   listener->ip_addr[1],\n\t\t   listener->ip_addr[2],\n\t\t   listener->ip_addr[3], listener->port, listener->vlan);\n\n\treturn 0;\n}\n\nint qed_iwarp_destroy_listen(void *rdma_cxt, void *handle)\n{\n\tstruct qed_iwarp_listener *listener = handle;\n\tstruct qed_hwfn *p_hwfn = rdma_cxt;\n\n\tDP_VERBOSE(p_hwfn, QED_MSG_RDMA, \"handle=%p\\n\", handle);\n\n\tspin_lock_bh(&p_hwfn->p_rdma_info->iwarp.iw_lock);\n\tlist_del(&listener->list_entry);\n\tspin_unlock_bh(&p_hwfn->p_rdma_info->iwarp.iw_lock);\n\n\tkfree(listener);\n\n\treturn 0;\n}\n\nint qed_iwarp_send_rtr(void *rdma_cxt, struct qed_iwarp_send_rtr_in *iparams)\n{\n\tstruct qed_hwfn *p_hwfn = rdma_cxt;\n\tstruct qed_sp_init_data init_data;\n\tstruct qed_spq_entry *p_ent;\n\tstruct qed_iwarp_ep *ep;\n\tstruct qed_rdma_qp *qp;\n\tint rc;\n\n\tep = iparams->ep_context;\n\tif (!ep) {\n\t\tDP_ERR(p_hwfn, \"Ep Context receive in send_rtr is NULL\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tqp = ep->qp;\n\n\tDP_VERBOSE(p_hwfn, QED_MSG_RDMA, \"QP(0x%x) EP(0x%x)\\n\",\n\t\t   qp->icid, ep->tcp_cid);\n\n\tmemset(&init_data, 0, sizeof(init_data));\n\tinit_data.cid = qp->icid;\n\tinit_data.opaque_fid = p_hwfn->hw_info.opaque_fid;\n\tinit_data.comp_mode = QED_SPQ_MODE_CB;\n\n\trc = qed_sp_init_request(p_hwfn, &p_ent,\n\t\t\t\t IWARP_RAMROD_CMD_ID_MPA_OFFLOAD_SEND_RTR,\n\t\t\t\t PROTOCOLID_IWARP, &init_data);\n\n\tif (rc)\n\t\treturn rc;\n\n\trc = qed_spq_post(p_hwfn, p_ent, NULL);\n\n\tDP_VERBOSE(p_hwfn, QED_MSG_RDMA, \"rc = 0x%x\\n\", rc);\n\n\treturn rc;\n}\n\nvoid\nqed_iwarp_query_qp(struct qed_rdma_qp *qp,\n\t\t   struct qed_rdma_query_qp_out_params *out_params)\n{\n\tout_params->state = qed_iwarp2roce_state(qp->iwarp_state);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}