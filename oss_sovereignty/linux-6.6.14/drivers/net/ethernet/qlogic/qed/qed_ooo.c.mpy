{
  "module_name": "qed_ooo.c",
  "hash_id": "957e6888eef65144829bc718e1bb3082a2e2eefd1df42885a7dbe55de3855fe7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/qlogic/qed/qed_ooo.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/dma-mapping.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/pci.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include \"qed.h\"\n#include \"qed_iscsi.h\"\n#include \"qed_ll2.h\"\n#include \"qed_ooo.h\"\n#include \"qed_cxt.h\"\n#include \"qed_nvmetcp.h\"\nstatic struct qed_ooo_archipelago\n*qed_ooo_seek_archipelago(struct qed_hwfn *p_hwfn,\n\t\t\t  struct qed_ooo_info\n\t\t\t  *p_ooo_info,\n\t\t\t  u32 cid)\n{\n\tu32 idx = (cid & 0xffff) - p_ooo_info->cid_base;\n\tstruct qed_ooo_archipelago *p_archipelago;\n\n\tif (unlikely(idx >= p_ooo_info->max_num_archipelagos))\n\t\treturn NULL;\n\n\tp_archipelago = &p_ooo_info->p_archipelagos_mem[idx];\n\n\tif (unlikely(list_empty(&p_archipelago->isles_list)))\n\t\treturn NULL;\n\n\treturn p_archipelago;\n}\n\nstatic struct qed_ooo_isle *qed_ooo_seek_isle(struct qed_hwfn *p_hwfn,\n\t\t\t\t\t      struct qed_ooo_info *p_ooo_info,\n\t\t\t\t\t      u32 cid, u8 isle)\n{\n\tstruct qed_ooo_archipelago *p_archipelago = NULL;\n\tstruct qed_ooo_isle *p_isle = NULL;\n\tu8 the_num_of_isle = 1;\n\n\tp_archipelago = qed_ooo_seek_archipelago(p_hwfn, p_ooo_info, cid);\n\tif (unlikely(!p_archipelago)) {\n\t\tDP_NOTICE(p_hwfn,\n\t\t\t  \"Connection %d is not found in OOO list\\n\", cid);\n\t\treturn NULL;\n\t}\n\n\tlist_for_each_entry(p_isle, &p_archipelago->isles_list, list_entry) {\n\t\tif (the_num_of_isle == isle)\n\t\t\treturn p_isle;\n\t\tthe_num_of_isle++;\n\t}\n\n\treturn NULL;\n}\n\nvoid qed_ooo_save_history_entry(struct qed_hwfn *p_hwfn,\n\t\t\t\tstruct qed_ooo_info *p_ooo_info,\n\t\t\t\tstruct ooo_opaque *p_cqe)\n{\n\tstruct qed_ooo_history *p_history = &p_ooo_info->ooo_history;\n\n\tif (p_history->head_idx == p_history->num_of_cqes)\n\t\tp_history->head_idx = 0;\n\tp_history->p_cqes[p_history->head_idx] = *p_cqe;\n\tp_history->head_idx++;\n}\n\nint qed_ooo_alloc(struct qed_hwfn *p_hwfn)\n{\n\tu16 max_num_archipelagos = 0, cid_base;\n\tstruct qed_ooo_info *p_ooo_info;\n\tenum protocol_type proto;\n\tu16 max_num_isles = 0;\n\tu32 i;\n\n\tswitch (p_hwfn->hw_info.personality) {\n\tcase QED_PCI_ISCSI:\n\tcase QED_PCI_NVMETCP:\n\t\tproto = PROTOCOLID_TCP_ULP;\n\t\tbreak;\n\tcase QED_PCI_ETH_RDMA:\n\tcase QED_PCI_ETH_IWARP:\n\t\tproto = PROTOCOLID_IWARP;\n\t\tbreak;\n\tdefault:\n\t\tDP_NOTICE(p_hwfn,\n\t\t\t  \"Failed to allocate qed_ooo_info: unknown personality\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmax_num_archipelagos = (u16)qed_cxt_get_proto_cid_count(p_hwfn, proto,\n\t\t\t\t\t\t\t\tNULL);\n\tmax_num_isles = QED_MAX_NUM_ISLES + max_num_archipelagos;\n\tcid_base = (u16)qed_cxt_get_proto_cid_start(p_hwfn, proto);\n\n\tif (!max_num_archipelagos) {\n\t\tDP_NOTICE(p_hwfn,\n\t\t\t  \"Failed to allocate qed_ooo_info: unknown amount of connections\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tp_ooo_info = kzalloc(sizeof(*p_ooo_info), GFP_KERNEL);\n\tif (!p_ooo_info)\n\t\treturn -ENOMEM;\n\n\tp_ooo_info->cid_base = cid_base;\n\tp_ooo_info->max_num_archipelagos = max_num_archipelagos;\n\n\tINIT_LIST_HEAD(&p_ooo_info->free_buffers_list);\n\tINIT_LIST_HEAD(&p_ooo_info->ready_buffers_list);\n\tINIT_LIST_HEAD(&p_ooo_info->free_isles_list);\n\n\tp_ooo_info->p_isles_mem = kcalloc(max_num_isles,\n\t\t\t\t\t  sizeof(struct qed_ooo_isle),\n\t\t\t\t\t  GFP_KERNEL);\n\tif (!p_ooo_info->p_isles_mem)\n\t\tgoto no_isles_mem;\n\n\tfor (i = 0; i < max_num_isles; i++) {\n\t\tINIT_LIST_HEAD(&p_ooo_info->p_isles_mem[i].buffers_list);\n\t\tlist_add_tail(&p_ooo_info->p_isles_mem[i].list_entry,\n\t\t\t      &p_ooo_info->free_isles_list);\n\t}\n\n\tp_ooo_info->p_archipelagos_mem =\n\t\t\t\tkcalloc(max_num_archipelagos,\n\t\t\t\t\tsizeof(struct qed_ooo_archipelago),\n\t\t\t\t\tGFP_KERNEL);\n\tif (!p_ooo_info->p_archipelagos_mem)\n\t\tgoto no_archipelagos_mem;\n\n\tfor (i = 0; i < max_num_archipelagos; i++)\n\t\tINIT_LIST_HEAD(&p_ooo_info->p_archipelagos_mem[i].isles_list);\n\n\tp_ooo_info->ooo_history.p_cqes =\n\t\t\t\tkcalloc(QED_MAX_NUM_OOO_HISTORY_ENTRIES,\n\t\t\t\t\tsizeof(struct ooo_opaque),\n\t\t\t\t\tGFP_KERNEL);\n\tif (!p_ooo_info->ooo_history.p_cqes)\n\t\tgoto no_history_mem;\n\n\tp_ooo_info->ooo_history.num_of_cqes = QED_MAX_NUM_OOO_HISTORY_ENTRIES;\n\n\tp_hwfn->p_ooo_info = p_ooo_info;\n\treturn 0;\n\nno_history_mem:\n\tkfree(p_ooo_info->p_archipelagos_mem);\nno_archipelagos_mem:\n\tkfree(p_ooo_info->p_isles_mem);\nno_isles_mem:\n\tkfree(p_ooo_info);\n\treturn -ENOMEM;\n}\n\nvoid qed_ooo_release_connection_isles(struct qed_hwfn *p_hwfn,\n\t\t\t\t      struct qed_ooo_info *p_ooo_info, u32 cid)\n{\n\tstruct qed_ooo_archipelago *p_archipelago;\n\tstruct qed_ooo_buffer *p_buffer;\n\tstruct qed_ooo_isle *p_isle;\n\n\tp_archipelago = qed_ooo_seek_archipelago(p_hwfn, p_ooo_info, cid);\n\tif (!p_archipelago)\n\t\treturn;\n\n\twhile (!list_empty(&p_archipelago->isles_list)) {\n\t\tp_isle = list_first_entry(&p_archipelago->isles_list,\n\t\t\t\t\t  struct qed_ooo_isle, list_entry);\n\n\t\tlist_del(&p_isle->list_entry);\n\n\t\twhile (!list_empty(&p_isle->buffers_list)) {\n\t\t\tp_buffer = list_first_entry(&p_isle->buffers_list,\n\t\t\t\t\t\t    struct qed_ooo_buffer,\n\t\t\t\t\t\t    list_entry);\n\n\t\t\tif (!p_buffer)\n\t\t\t\tbreak;\n\n\t\t\tlist_move_tail(&p_buffer->list_entry,\n\t\t\t\t       &p_ooo_info->free_buffers_list);\n\t\t}\n\t\tlist_add_tail(&p_isle->list_entry,\n\t\t\t      &p_ooo_info->free_isles_list);\n\t}\n}\n\nvoid qed_ooo_release_all_isles(struct qed_hwfn *p_hwfn,\n\t\t\t       struct qed_ooo_info *p_ooo_info)\n{\n\tstruct qed_ooo_archipelago *p_archipelago;\n\tstruct qed_ooo_buffer *p_buffer;\n\tstruct qed_ooo_isle *p_isle;\n\tu32 i;\n\n\tfor (i = 0; i < p_ooo_info->max_num_archipelagos; i++) {\n\t\tp_archipelago = &(p_ooo_info->p_archipelagos_mem[i]);\n\n\t\twhile (!list_empty(&p_archipelago->isles_list)) {\n\t\t\tp_isle = list_first_entry(&p_archipelago->isles_list,\n\t\t\t\t\t\t  struct qed_ooo_isle,\n\t\t\t\t\t\t  list_entry);\n\n\t\t\tlist_del(&p_isle->list_entry);\n\n\t\t\twhile (!list_empty(&p_isle->buffers_list)) {\n\t\t\t\tp_buffer =\n\t\t\t\t    list_first_entry(&p_isle->buffers_list,\n\t\t\t\t\t\t     struct qed_ooo_buffer,\n\t\t\t\t\t\t     list_entry);\n\n\t\t\t\tif (!p_buffer)\n\t\t\t\t\tbreak;\n\n\t\t\t\tlist_move_tail(&p_buffer->list_entry,\n\t\t\t\t\t       &p_ooo_info->free_buffers_list);\n\t\t\t}\n\t\t\tlist_add_tail(&p_isle->list_entry,\n\t\t\t\t      &p_ooo_info->free_isles_list);\n\t\t}\n\t}\n\tif (!list_empty(&p_ooo_info->ready_buffers_list))\n\t\tlist_splice_tail_init(&p_ooo_info->ready_buffers_list,\n\t\t\t\t      &p_ooo_info->free_buffers_list);\n}\n\nvoid qed_ooo_setup(struct qed_hwfn *p_hwfn)\n{\n\tqed_ooo_release_all_isles(p_hwfn, p_hwfn->p_ooo_info);\n\tmemset(p_hwfn->p_ooo_info->ooo_history.p_cqes, 0,\n\t       p_hwfn->p_ooo_info->ooo_history.num_of_cqes *\n\t       sizeof(struct ooo_opaque));\n\tp_hwfn->p_ooo_info->ooo_history.head_idx = 0;\n}\n\nvoid qed_ooo_free(struct qed_hwfn *p_hwfn)\n{\n\tstruct qed_ooo_info *p_ooo_info  = p_hwfn->p_ooo_info;\n\tstruct qed_ooo_buffer *p_buffer;\n\n\tif (!p_ooo_info)\n\t\treturn;\n\n\tqed_ooo_release_all_isles(p_hwfn, p_ooo_info);\n\twhile (!list_empty(&p_ooo_info->free_buffers_list)) {\n\t\tp_buffer = list_first_entry(&p_ooo_info->free_buffers_list,\n\t\t\t\t\t    struct qed_ooo_buffer, list_entry);\n\n\t\tif (!p_buffer)\n\t\t\tbreak;\n\n\t\tlist_del(&p_buffer->list_entry);\n\t\tdma_free_coherent(&p_hwfn->cdev->pdev->dev,\n\t\t\t\t  p_buffer->rx_buffer_size,\n\t\t\t\t  p_buffer->rx_buffer_virt_addr,\n\t\t\t\t  p_buffer->rx_buffer_phys_addr);\n\t\tkfree(p_buffer);\n\t}\n\n\tkfree(p_ooo_info->p_isles_mem);\n\tkfree(p_ooo_info->p_archipelagos_mem);\n\tkfree(p_ooo_info->ooo_history.p_cqes);\n\tkfree(p_ooo_info);\n\tp_hwfn->p_ooo_info = NULL;\n}\n\nvoid qed_ooo_put_free_buffer(struct qed_hwfn *p_hwfn,\n\t\t\t     struct qed_ooo_info *p_ooo_info,\n\t\t\t     struct qed_ooo_buffer *p_buffer)\n{\n\tlist_add_tail(&p_buffer->list_entry, &p_ooo_info->free_buffers_list);\n}\n\nstruct qed_ooo_buffer *qed_ooo_get_free_buffer(struct qed_hwfn *p_hwfn,\n\t\t\t\t\t       struct qed_ooo_info *p_ooo_info)\n{\n\tstruct qed_ooo_buffer *p_buffer = NULL;\n\n\tif (!list_empty(&p_ooo_info->free_buffers_list)) {\n\t\tp_buffer = list_first_entry(&p_ooo_info->free_buffers_list,\n\t\t\t\t\t    struct qed_ooo_buffer, list_entry);\n\n\t\tlist_del(&p_buffer->list_entry);\n\t}\n\n\treturn p_buffer;\n}\n\nvoid qed_ooo_put_ready_buffer(struct qed_hwfn *p_hwfn,\n\t\t\t      struct qed_ooo_info *p_ooo_info,\n\t\t\t      struct qed_ooo_buffer *p_buffer, u8 on_tail)\n{\n\tif (on_tail)\n\t\tlist_add_tail(&p_buffer->list_entry,\n\t\t\t      &p_ooo_info->ready_buffers_list);\n\telse\n\t\tlist_add(&p_buffer->list_entry,\n\t\t\t &p_ooo_info->ready_buffers_list);\n}\n\nstruct qed_ooo_buffer *qed_ooo_get_ready_buffer(struct qed_hwfn *p_hwfn,\n\t\t\t\t\t\tstruct qed_ooo_info *p_ooo_info)\n{\n\tstruct qed_ooo_buffer *p_buffer = NULL;\n\n\tif (!list_empty(&p_ooo_info->ready_buffers_list)) {\n\t\tp_buffer = list_first_entry(&p_ooo_info->ready_buffers_list,\n\t\t\t\t\t    struct qed_ooo_buffer, list_entry);\n\n\t\tlist_del(&p_buffer->list_entry);\n\t}\n\n\treturn p_buffer;\n}\n\nvoid qed_ooo_delete_isles(struct qed_hwfn *p_hwfn,\n\t\t\t  struct qed_ooo_info *p_ooo_info,\n\t\t\t  u32 cid, u8 drop_isle, u8 drop_size)\n{\n\tstruct qed_ooo_isle *p_isle = NULL;\n\tu8 isle_idx;\n\n\tfor (isle_idx = 0; isle_idx < drop_size; isle_idx++) {\n\t\tp_isle = qed_ooo_seek_isle(p_hwfn, p_ooo_info, cid, drop_isle);\n\t\tif (!p_isle) {\n\t\t\tDP_NOTICE(p_hwfn,\n\t\t\t\t  \"Isle %d is not found(cid %d)\\n\",\n\t\t\t\t  drop_isle, cid);\n\t\t\treturn;\n\t\t}\n\t\tif (list_empty(&p_isle->buffers_list))\n\t\t\tDP_NOTICE(p_hwfn,\n\t\t\t\t  \"Isle %d is empty(cid %d)\\n\", drop_isle, cid);\n\t\telse\n\t\t\tlist_splice_tail_init(&p_isle->buffers_list,\n\t\t\t\t\t      &p_ooo_info->free_buffers_list);\n\n\t\tlist_del(&p_isle->list_entry);\n\t\tp_ooo_info->cur_isles_number--;\n\t\tlist_add(&p_isle->list_entry, &p_ooo_info->free_isles_list);\n\t}\n}\n\nvoid qed_ooo_add_new_isle(struct qed_hwfn *p_hwfn,\n\t\t\t  struct qed_ooo_info *p_ooo_info,\n\t\t\t  u32 cid, u8 ooo_isle,\n\t\t\t  struct qed_ooo_buffer *p_buffer)\n{\n\tstruct qed_ooo_archipelago *p_archipelago = NULL;\n\tstruct qed_ooo_isle *p_prev_isle = NULL;\n\tstruct qed_ooo_isle *p_isle = NULL;\n\n\tif (ooo_isle > 1) {\n\t\tp_prev_isle = qed_ooo_seek_isle(p_hwfn,\n\t\t\t\t\t\tp_ooo_info, cid, ooo_isle - 1);\n\t\tif (unlikely(!p_prev_isle)) {\n\t\t\tDP_NOTICE(p_hwfn,\n\t\t\t\t  \"Isle %d is not found(cid %d)\\n\",\n\t\t\t\t  ooo_isle - 1, cid);\n\t\t\treturn;\n\t\t}\n\t}\n\tp_archipelago = qed_ooo_seek_archipelago(p_hwfn, p_ooo_info, cid);\n\tif (unlikely(!p_archipelago && ooo_isle != 1)) {\n\t\tDP_NOTICE(p_hwfn,\n\t\t\t  \"Connection %d is not found in OOO list\\n\", cid);\n\t\treturn;\n\t}\n\n\tif (!list_empty(&p_ooo_info->free_isles_list)) {\n\t\tp_isle = list_first_entry(&p_ooo_info->free_isles_list,\n\t\t\t\t\t  struct qed_ooo_isle, list_entry);\n\n\t\tlist_del(&p_isle->list_entry);\n\t\tif (unlikely(!list_empty(&p_isle->buffers_list))) {\n\t\t\tDP_NOTICE(p_hwfn, \"Free isle is not empty\\n\");\n\t\t\tINIT_LIST_HEAD(&p_isle->buffers_list);\n\t\t}\n\t} else {\n\t\tDP_NOTICE(p_hwfn, \"No more free isles\\n\");\n\t\treturn;\n\t}\n\n\tif (!p_archipelago) {\n\t\tu32 idx = (cid & 0xffff) - p_ooo_info->cid_base;\n\n\t\tp_archipelago = &p_ooo_info->p_archipelagos_mem[idx];\n\t}\n\n\tlist_add(&p_buffer->list_entry, &p_isle->buffers_list);\n\tp_ooo_info->cur_isles_number++;\n\tp_ooo_info->gen_isles_number++;\n\n\tif (p_ooo_info->cur_isles_number > p_ooo_info->max_isles_number)\n\t\tp_ooo_info->max_isles_number = p_ooo_info->cur_isles_number;\n\n\tif (!p_prev_isle)\n\t\tlist_add(&p_isle->list_entry, &p_archipelago->isles_list);\n\telse\n\t\tlist_add(&p_isle->list_entry, &p_prev_isle->list_entry);\n}\n\nvoid qed_ooo_add_new_buffer(struct qed_hwfn *p_hwfn,\n\t\t\t    struct qed_ooo_info *p_ooo_info,\n\t\t\t    u32 cid,\n\t\t\t    u8 ooo_isle,\n\t\t\t    struct qed_ooo_buffer *p_buffer, u8 buffer_side)\n{\n\tstruct qed_ooo_isle *p_isle = NULL;\n\n\tp_isle = qed_ooo_seek_isle(p_hwfn, p_ooo_info, cid, ooo_isle);\n\tif (unlikely(!p_isle)) {\n\t\tDP_NOTICE(p_hwfn,\n\t\t\t  \"Isle %d is not found(cid %d)\\n\", ooo_isle, cid);\n\t\treturn;\n\t}\n\n\tif (unlikely(buffer_side == QED_OOO_LEFT_BUF))\n\t\tlist_add(&p_buffer->list_entry, &p_isle->buffers_list);\n\telse\n\t\tlist_add_tail(&p_buffer->list_entry, &p_isle->buffers_list);\n}\n\nvoid qed_ooo_join_isles(struct qed_hwfn *p_hwfn,\n\t\t\tstruct qed_ooo_info *p_ooo_info, u32 cid, u8 left_isle)\n{\n\tstruct qed_ooo_isle *p_right_isle = NULL;\n\tstruct qed_ooo_isle *p_left_isle = NULL;\n\n\tp_right_isle = qed_ooo_seek_isle(p_hwfn, p_ooo_info, cid,\n\t\t\t\t\t left_isle + 1);\n\tif (unlikely(!p_right_isle)) {\n\t\tDP_NOTICE(p_hwfn,\n\t\t\t  \"Right isle %d is not found(cid %d)\\n\",\n\t\t\t  left_isle + 1, cid);\n\t\treturn;\n\t}\n\n\tlist_del(&p_right_isle->list_entry);\n\tp_ooo_info->cur_isles_number--;\n\tif (left_isle) {\n\t\tp_left_isle = qed_ooo_seek_isle(p_hwfn, p_ooo_info, cid,\n\t\t\t\t\t\tleft_isle);\n\t\tif (unlikely(!p_left_isle)) {\n\t\t\tDP_NOTICE(p_hwfn,\n\t\t\t\t  \"Left isle %d is not found(cid %d)\\n\",\n\t\t\t\t  left_isle, cid);\n\t\t\treturn;\n\t\t}\n\t\tlist_splice_tail_init(&p_right_isle->buffers_list,\n\t\t\t\t      &p_left_isle->buffers_list);\n\t} else {\n\t\tlist_splice_tail_init(&p_right_isle->buffers_list,\n\t\t\t\t      &p_ooo_info->ready_buffers_list);\n\t}\n\tlist_add_tail(&p_right_isle->list_entry, &p_ooo_info->free_isles_list);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}