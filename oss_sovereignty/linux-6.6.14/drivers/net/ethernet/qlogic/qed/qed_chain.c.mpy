{
  "module_name": "qed_chain.c",
  "hash_id": "d8e3a2e592bf6cf5c2e6a6fdc4a66daf44af6ee05cf04ae085cb20254bbd8902",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/qlogic/qed/qed_chain.c",
  "human_readable_source": "\n \n\n#include <linux/dma-mapping.h>\n#include <linux/qed/qed_chain.h>\n#include <linux/vmalloc.h>\n\n#include \"qed_dev_api.h\"\n\nstatic void qed_chain_init(struct qed_chain *chain,\n\t\t\t   const struct qed_chain_init_params *params,\n\t\t\t   u32 page_cnt)\n{\n\tmemset(chain, 0, sizeof(*chain));\n\n\tchain->elem_size = params->elem_size;\n\tchain->intended_use = params->intended_use;\n\tchain->mode = params->mode;\n\tchain->cnt_type = params->cnt_type;\n\n\tchain->elem_per_page = ELEMS_PER_PAGE(params->elem_size,\n\t\t\t\t\t      params->page_size);\n\tchain->usable_per_page = USABLE_ELEMS_PER_PAGE(params->elem_size,\n\t\t\t\t\t\t       params->page_size,\n\t\t\t\t\t\t       params->mode);\n\tchain->elem_unusable = UNUSABLE_ELEMS_PER_PAGE(params->elem_size,\n\t\t\t\t\t\t       params->mode);\n\n\tchain->elem_per_page_mask = chain->elem_per_page - 1;\n\tchain->next_page_mask = chain->usable_per_page &\n\t\t\t\tchain->elem_per_page_mask;\n\n\tchain->page_size = params->page_size;\n\tchain->page_cnt = page_cnt;\n\tchain->capacity = chain->usable_per_page * page_cnt;\n\tchain->size = chain->elem_per_page * page_cnt;\n\n\tif (params->ext_pbl_virt) {\n\t\tchain->pbl_sp.table_virt = params->ext_pbl_virt;\n\t\tchain->pbl_sp.table_phys = params->ext_pbl_phys;\n\n\t\tchain->b_external_pbl = true;\n\t}\n}\n\nstatic void qed_chain_init_next_ptr_elem(const struct qed_chain *chain,\n\t\t\t\t\t void *virt_curr, void *virt_next,\n\t\t\t\t\t dma_addr_t phys_next)\n{\n\tstruct qed_chain_next *next;\n\tu32 size;\n\n\tsize = chain->elem_size * chain->usable_per_page;\n\tnext = virt_curr + size;\n\n\tDMA_REGPAIR_LE(next->next_phys, phys_next);\n\tnext->next_virt = virt_next;\n}\n\nstatic void qed_chain_init_mem(struct qed_chain *chain, void *virt_addr,\n\t\t\t       dma_addr_t phys_addr)\n{\n\tchain->p_virt_addr = virt_addr;\n\tchain->p_phys_addr = phys_addr;\n}\n\nstatic void qed_chain_free_next_ptr(struct qed_dev *cdev,\n\t\t\t\t    struct qed_chain *chain)\n{\n\tstruct device *dev = &cdev->pdev->dev;\n\tstruct qed_chain_next *next;\n\tdma_addr_t phys, phys_next;\n\tvoid *virt, *virt_next;\n\tu32 size, i;\n\n\tsize = chain->elem_size * chain->usable_per_page;\n\tvirt = chain->p_virt_addr;\n\tphys = chain->p_phys_addr;\n\n\tfor (i = 0; i < chain->page_cnt; i++) {\n\t\tif (!virt)\n\t\t\tbreak;\n\n\t\tnext = virt + size;\n\t\tvirt_next = next->next_virt;\n\t\tphys_next = HILO_DMA_REGPAIR(next->next_phys);\n\n\t\tdma_free_coherent(dev, chain->page_size, virt, phys);\n\n\t\tvirt = virt_next;\n\t\tphys = phys_next;\n\t}\n}\n\nstatic void qed_chain_free_single(struct qed_dev *cdev,\n\t\t\t\t  struct qed_chain *chain)\n{\n\tif (!chain->p_virt_addr)\n\t\treturn;\n\n\tdma_free_coherent(&cdev->pdev->dev, chain->page_size,\n\t\t\t  chain->p_virt_addr, chain->p_phys_addr);\n}\n\nstatic void qed_chain_free_pbl(struct qed_dev *cdev, struct qed_chain *chain)\n{\n\tstruct device *dev = &cdev->pdev->dev;\n\tstruct addr_tbl_entry *entry;\n\tu32 i;\n\n\tif (!chain->pbl.pp_addr_tbl)\n\t\treturn;\n\n\tfor (i = 0; i < chain->page_cnt; i++) {\n\t\tentry = chain->pbl.pp_addr_tbl + i;\n\t\tif (!entry->virt_addr)\n\t\t\tbreak;\n\n\t\tdma_free_coherent(dev, chain->page_size, entry->virt_addr,\n\t\t\t\t  entry->dma_map);\n\t}\n\n\tif (!chain->b_external_pbl)\n\t\tdma_free_coherent(dev, chain->pbl_sp.table_size,\n\t\t\t\t  chain->pbl_sp.table_virt,\n\t\t\t\t  chain->pbl_sp.table_phys);\n\n\tvfree(chain->pbl.pp_addr_tbl);\n\tchain->pbl.pp_addr_tbl = NULL;\n}\n\n \nvoid qed_chain_free(struct qed_dev *cdev, struct qed_chain *chain)\n{\n\tswitch (chain->mode) {\n\tcase QED_CHAIN_MODE_NEXT_PTR:\n\t\tqed_chain_free_next_ptr(cdev, chain);\n\t\tbreak;\n\tcase QED_CHAIN_MODE_SINGLE:\n\t\tqed_chain_free_single(cdev, chain);\n\t\tbreak;\n\tcase QED_CHAIN_MODE_PBL:\n\t\tqed_chain_free_pbl(cdev, chain);\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tqed_chain_init_mem(chain, NULL, 0);\n}\n\nstatic int\nqed_chain_alloc_sanity_check(struct qed_dev *cdev,\n\t\t\t     const struct qed_chain_init_params *params,\n\t\t\t     u32 page_cnt)\n{\n\tu64 chain_size;\n\n\tchain_size = ELEMS_PER_PAGE(params->elem_size, params->page_size);\n\tchain_size *= page_cnt;\n\n\tif (!chain_size)\n\t\treturn -EINVAL;\n\n\t \n\tswitch (params->cnt_type) {\n\tcase QED_CHAIN_CNT_TYPE_U16:\n\t\tif (chain_size > U16_MAX + 1)\n\t\t\tbreak;\n\n\t\treturn 0;\n\tcase QED_CHAIN_CNT_TYPE_U32:\n\t\tif (chain_size > U32_MAX)\n\t\t\tbreak;\n\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tDP_NOTICE(cdev,\n\t\t  \"The actual chain size (0x%llx) is larger than the maximal possible value\\n\",\n\t\t  chain_size);\n\n\treturn -EINVAL;\n}\n\nstatic int qed_chain_alloc_next_ptr(struct qed_dev *cdev,\n\t\t\t\t    struct qed_chain *chain)\n{\n\tstruct device *dev = &cdev->pdev->dev;\n\tvoid *virt, *virt_prev = NULL;\n\tdma_addr_t phys;\n\tu32 i;\n\n\tfor (i = 0; i < chain->page_cnt; i++) {\n\t\tvirt = dma_alloc_coherent(dev, chain->page_size, &phys,\n\t\t\t\t\t  GFP_KERNEL);\n\t\tif (!virt)\n\t\t\treturn -ENOMEM;\n\n\t\tif (i == 0) {\n\t\t\tqed_chain_init_mem(chain, virt, phys);\n\t\t\tqed_chain_reset(chain);\n\t\t} else {\n\t\t\tqed_chain_init_next_ptr_elem(chain, virt_prev, virt,\n\t\t\t\t\t\t     phys);\n\t\t}\n\n\t\tvirt_prev = virt;\n\t}\n\n\t \n\tqed_chain_init_next_ptr_elem(chain, virt_prev, chain->p_virt_addr,\n\t\t\t\t     chain->p_phys_addr);\n\n\treturn 0;\n}\n\nstatic int qed_chain_alloc_single(struct qed_dev *cdev,\n\t\t\t\t  struct qed_chain *chain)\n{\n\tdma_addr_t phys;\n\tvoid *virt;\n\n\tvirt = dma_alloc_coherent(&cdev->pdev->dev, chain->page_size,\n\t\t\t\t  &phys, GFP_KERNEL);\n\tif (!virt)\n\t\treturn -ENOMEM;\n\n\tqed_chain_init_mem(chain, virt, phys);\n\tqed_chain_reset(chain);\n\n\treturn 0;\n}\n\nstatic int qed_chain_alloc_pbl(struct qed_dev *cdev, struct qed_chain *chain)\n{\n\tstruct device *dev = &cdev->pdev->dev;\n\tstruct addr_tbl_entry *addr_tbl;\n\tdma_addr_t phys, pbl_phys;\n\t__le64 *pbl_virt;\n\tu32 page_cnt, i;\n\tsize_t size;\n\tvoid *virt;\n\n\tpage_cnt = chain->page_cnt;\n\n\tsize = array_size(page_cnt, sizeof(*addr_tbl));\n\tif (unlikely(size == SIZE_MAX))\n\t\treturn -EOVERFLOW;\n\n\taddr_tbl = vzalloc(size);\n\tif (!addr_tbl)\n\t\treturn -ENOMEM;\n\n\tchain->pbl.pp_addr_tbl = addr_tbl;\n\n\tif (chain->b_external_pbl) {\n\t\tpbl_virt = chain->pbl_sp.table_virt;\n\t\tgoto alloc_pages;\n\t}\n\n\tsize = array_size(page_cnt, sizeof(*pbl_virt));\n\tif (unlikely(size == SIZE_MAX))\n\t\treturn -EOVERFLOW;\n\n\tpbl_virt = dma_alloc_coherent(dev, size, &pbl_phys, GFP_KERNEL);\n\tif (!pbl_virt)\n\t\treturn -ENOMEM;\n\n\tchain->pbl_sp.table_virt = pbl_virt;\n\tchain->pbl_sp.table_phys = pbl_phys;\n\tchain->pbl_sp.table_size = size;\n\nalloc_pages:\n\tfor (i = 0; i < page_cnt; i++) {\n\t\tvirt = dma_alloc_coherent(dev, chain->page_size, &phys,\n\t\t\t\t\t  GFP_KERNEL);\n\t\tif (!virt)\n\t\t\treturn -ENOMEM;\n\n\t\tif (i == 0) {\n\t\t\tqed_chain_init_mem(chain, virt, phys);\n\t\t\tqed_chain_reset(chain);\n\t\t}\n\n\t\t \n\t\tpbl_virt[i] = cpu_to_le64(phys);\n\n\t\t \n\t\taddr_tbl[i].virt_addr = virt;\n\t\taddr_tbl[i].dma_map = phys;\n\t}\n\n\treturn 0;\n}\n\n \nint qed_chain_alloc(struct qed_dev *cdev, struct qed_chain *chain,\n\t\t    struct qed_chain_init_params *params)\n{\n\tu32 page_cnt;\n\tint rc;\n\n\tif (!params->page_size)\n\t\tparams->page_size = QED_CHAIN_PAGE_SIZE;\n\n\tif (params->mode == QED_CHAIN_MODE_SINGLE)\n\t\tpage_cnt = 1;\n\telse\n\t\tpage_cnt = QED_CHAIN_PAGE_CNT(params->num_elems,\n\t\t\t\t\t      params->elem_size,\n\t\t\t\t\t      params->page_size,\n\t\t\t\t\t      params->mode);\n\n\trc = qed_chain_alloc_sanity_check(cdev, params, page_cnt);\n\tif (rc) {\n\t\tDP_NOTICE(cdev,\n\t\t\t  \"Cannot allocate a chain with the given arguments:\\n\");\n\t\tDP_NOTICE(cdev,\n\t\t\t  \"[use_mode %d, mode %d, cnt_type %d, num_elems %d, elem_size %zu, page_size %u]\\n\",\n\t\t\t  params->intended_use, params->mode, params->cnt_type,\n\t\t\t  params->num_elems, params->elem_size,\n\t\t\t  params->page_size);\n\t\treturn rc;\n\t}\n\n\tqed_chain_init(chain, params, page_cnt);\n\n\tswitch (params->mode) {\n\tcase QED_CHAIN_MODE_NEXT_PTR:\n\t\trc = qed_chain_alloc_next_ptr(cdev, chain);\n\t\tbreak;\n\tcase QED_CHAIN_MODE_SINGLE:\n\t\trc = qed_chain_alloc_single(cdev, chain);\n\t\tbreak;\n\tcase QED_CHAIN_MODE_PBL:\n\t\trc = qed_chain_alloc_pbl(cdev, chain);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (!rc)\n\t\treturn 0;\n\n\tqed_chain_free(cdev, chain);\n\n\treturn rc;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}