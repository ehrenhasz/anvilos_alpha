{
  "module_name": "qed_cxt.c",
  "hash_id": "169e37cb6959ead3298a1cbd573d1c49ebdd24e481ddeff6d267e88d6bc5f1ac",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/qlogic/qed/qed_cxt.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/bitops.h>\n#include <linux/dma-mapping.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/log2.h>\n#include <linux/pci.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include \"qed.h\"\n#include \"qed_cxt.h\"\n#include \"qed_dev_api.h\"\n#include \"qed_hsi.h\"\n#include \"qed_hw.h\"\n#include \"qed_init_ops.h\"\n#include \"qed_rdma.h\"\n#include \"qed_reg_addr.h\"\n#include \"qed_sriov.h\"\n\n \n#define QM_PQ_ELEMENT_SIZE\t4  \n\n \n#define DQ_RANGE_SHIFT\t\t4\n#define DQ_RANGE_ALIGN\t\tBIT(DQ_RANGE_SHIFT)\n\n \n#define SRC_MIN_NUM_ELEMS 256\n\n \n#define TM_SHIFT        7\n#define TM_ALIGN        BIT(TM_SHIFT)\n#define TM_ELEM_SIZE    4\n\n#define ILT_DEFAULT_HW_P_SIZE\t4\n\n#define ILT_PAGE_IN_BYTES(hw_p_size)\t(1U << ((hw_p_size) + 12))\n#define ILT_CFG_REG(cli, reg)\tPSWRQ2_REG_ ## cli ## _ ## reg ## _RT_OFFSET\n\n \n#define ILT_ENTRY_PHY_ADDR_MASK\t\t(~0ULL >> 12)\n#define ILT_ENTRY_PHY_ADDR_SHIFT\t0\n#define ILT_ENTRY_VALID_MASK\t\t0x1ULL\n#define ILT_ENTRY_VALID_SHIFT\t\t52\n#define ILT_ENTRY_IN_REGS\t\t2\n#define ILT_REG_SIZE_IN_BYTES\t\t4\n\n \nunion conn_context {\n\tstruct core_conn_context core_ctx;\n\tstruct eth_conn_context eth_ctx;\n\tstruct iscsi_conn_context iscsi_ctx;\n\tstruct fcoe_conn_context fcoe_ctx;\n\tstruct roce_conn_context roce_ctx;\n};\n\n \nunion type0_task_context {\n\tstruct iscsi_task_context iscsi_ctx;\n\tstruct fcoe_task_context fcoe_ctx;\n};\n\n \nunion type1_task_context {\n\tstruct rdma_task_context roce_ctx;\n};\n\nstruct src_ent {\n\t__u8\t\t\t\topaque[56];\n\t__be64\t\t\t\tnext;\n};\n\n#define CDUT_SEG_ALIGNMET\t\t3  \n#define CDUT_SEG_ALIGNMET_IN_BYTES\tBIT(CDUT_SEG_ALIGNMET + 12)\n\n#define CONN_CXT_SIZE(p_hwfn) \\\n\tALIGNED_TYPE_SIZE(union conn_context, p_hwfn)\n\n#define SRQ_CXT_SIZE (sizeof(struct rdma_srq_context))\n#define XRC_SRQ_CXT_SIZE (sizeof(struct rdma_xrc_srq_context))\n\n#define TYPE0_TASK_CXT_SIZE(p_hwfn) \\\n\tALIGNED_TYPE_SIZE(union type0_task_context, p_hwfn)\n\n \n#define TYPE1_TASK_CXT_SIZE(p_hwfn) sizeof(union type1_task_context)\n\nstatic bool src_proto(enum protocol_type type)\n{\n\treturn type == PROTOCOLID_TCP_ULP ||\n\t       type == PROTOCOLID_FCOE ||\n\t       type == PROTOCOLID_IWARP;\n}\n\nstatic bool tm_cid_proto(enum protocol_type type)\n{\n\treturn type == PROTOCOLID_TCP_ULP ||\n\t       type == PROTOCOLID_FCOE ||\n\t       type == PROTOCOLID_ROCE ||\n\t       type == PROTOCOLID_IWARP;\n}\n\nstatic bool tm_tid_proto(enum protocol_type type)\n{\n\treturn type == PROTOCOLID_FCOE;\n}\n\n \nstruct qed_cdu_iids {\n\tu32 pf_cids;\n\tu32 per_vf_cids;\n};\n\nstatic void qed_cxt_cdu_iids(struct qed_cxt_mngr *p_mngr,\n\t\t\t     struct qed_cdu_iids *iids)\n{\n\tu32 type;\n\n\tfor (type = 0; type < MAX_CONN_TYPES; type++) {\n\t\tiids->pf_cids += p_mngr->conn_cfg[type].cid_count;\n\t\tiids->per_vf_cids += p_mngr->conn_cfg[type].cids_per_vf;\n\t}\n}\n\n \nstruct qed_src_iids {\n\tu32 pf_cids;\n\tu32 per_vf_cids;\n};\n\nstatic void qed_cxt_src_iids(struct qed_cxt_mngr *p_mngr,\n\t\t\t     struct qed_src_iids *iids)\n{\n\tu32 i;\n\n\tfor (i = 0; i < MAX_CONN_TYPES; i++) {\n\t\tif (!src_proto(i))\n\t\t\tcontinue;\n\n\t\tiids->pf_cids += p_mngr->conn_cfg[i].cid_count;\n\t\tiids->per_vf_cids += p_mngr->conn_cfg[i].cids_per_vf;\n\t}\n\n\t \n\tiids->pf_cids += p_mngr->arfs_count;\n}\n\n \nstruct qed_tm_iids {\n\tu32 pf_cids;\n\tu32 pf_tids[NUM_TASK_PF_SEGMENTS];\t \n\tu32 pf_tids_total;\n\tu32 per_vf_cids;\n\tu32 per_vf_tids;\n};\n\nstatic void qed_cxt_tm_iids(struct qed_hwfn *p_hwfn,\n\t\t\t    struct qed_cxt_mngr *p_mngr,\n\t\t\t    struct qed_tm_iids *iids)\n{\n\tbool tm_vf_required = false;\n\tbool tm_required = false;\n\tint i, j;\n\n\t \n\tfor (i = MAX_CONN_TYPES - 1; i >= 0; i--) {\n\t\tstruct qed_conn_type_cfg *p_cfg = &p_mngr->conn_cfg[i];\n\n\t\tif (tm_cid_proto(i) || tm_required) {\n\t\t\tif (p_cfg->cid_count)\n\t\t\t\ttm_required = true;\n\n\t\t\tiids->pf_cids += p_cfg->cid_count;\n\t\t}\n\n\t\tif (tm_cid_proto(i) || tm_vf_required) {\n\t\t\tif (p_cfg->cids_per_vf)\n\t\t\t\ttm_vf_required = true;\n\n\t\t\tiids->per_vf_cids += p_cfg->cids_per_vf;\n\t\t}\n\n\t\tif (tm_tid_proto(i)) {\n\t\t\tstruct qed_tid_seg *segs = p_cfg->tid_seg;\n\n\t\t\t \n\t\t\tfor (j = 0; j < NUM_TASK_PF_SEGMENTS; j++)\n\t\t\t\tiids->pf_tids[j] += segs[j].count;\n\n\t\t\t \n\t\t\tiids->per_vf_tids += segs[NUM_TASK_PF_SEGMENTS].count;\n\t\t}\n\t}\n\n\tiids->pf_cids = roundup(iids->pf_cids, TM_ALIGN);\n\tiids->per_vf_cids = roundup(iids->per_vf_cids, TM_ALIGN);\n\tiids->per_vf_tids = roundup(iids->per_vf_tids, TM_ALIGN);\n\n\tfor (iids->pf_tids_total = 0, j = 0; j < NUM_TASK_PF_SEGMENTS; j++) {\n\t\tiids->pf_tids[j] = roundup(iids->pf_tids[j], TM_ALIGN);\n\t\tiids->pf_tids_total += iids->pf_tids[j];\n\t}\n}\n\nstatic void qed_cxt_qm_iids(struct qed_hwfn *p_hwfn,\n\t\t\t    struct qed_qm_iids *iids)\n{\n\tstruct qed_cxt_mngr *p_mngr = p_hwfn->p_cxt_mngr;\n\tstruct qed_tid_seg *segs;\n\tu32 vf_cids = 0, type, j;\n\tu32 vf_tids = 0;\n\n\tfor (type = 0; type < MAX_CONN_TYPES; type++) {\n\t\tiids->cids += p_mngr->conn_cfg[type].cid_count;\n\t\tvf_cids += p_mngr->conn_cfg[type].cids_per_vf;\n\n\t\tsegs = p_mngr->conn_cfg[type].tid_seg;\n\t\t \n\t\tfor (j = 0; j < NUM_TASK_PF_SEGMENTS; j++)\n\t\t\tiids->tids += segs[j].count;\n\n\t\t \n\t\tvf_tids += segs[NUM_TASK_PF_SEGMENTS].count;\n\t}\n\n\tiids->vf_cids = vf_cids;\n\tiids->tids += vf_tids * p_mngr->vf_count;\n\n\tDP_VERBOSE(p_hwfn, QED_MSG_ILT,\n\t\t   \"iids: CIDS %08x vf_cids %08x tids %08x vf_tids %08x\\n\",\n\t\t   iids->cids, iids->vf_cids, iids->tids, vf_tids);\n}\n\nstatic struct qed_tid_seg *qed_cxt_tid_seg_info(struct qed_hwfn *p_hwfn,\n\t\t\t\t\t\tu32 seg)\n{\n\tstruct qed_cxt_mngr *p_cfg = p_hwfn->p_cxt_mngr;\n\tu32 i;\n\n\t \n\tfor (i = 0; i < MAX_CONN_TYPES; i++)\n\t\tif (p_cfg->conn_cfg[i].tid_seg[seg].count)\n\t\t\treturn &p_cfg->conn_cfg[i].tid_seg[seg];\n\treturn NULL;\n}\n\nstatic void qed_cxt_set_srq_count(struct qed_hwfn *p_hwfn,\n\t\t\t\t  u32 num_srqs, u32 num_xrc_srqs)\n{\n\tstruct qed_cxt_mngr *p_mgr = p_hwfn->p_cxt_mngr;\n\n\tp_mgr->srq_count = num_srqs;\n\tp_mgr->xrc_srq_count = num_xrc_srqs;\n}\n\nu32 qed_cxt_get_ilt_page_size(struct qed_hwfn *p_hwfn,\n\t\t\t      enum ilt_clients ilt_client)\n{\n\tstruct qed_cxt_mngr *p_mngr = p_hwfn->p_cxt_mngr;\n\tstruct qed_ilt_client_cfg *p_cli = &p_mngr->clients[ilt_client];\n\n\treturn ILT_PAGE_IN_BYTES(p_cli->p_size.val);\n}\n\nstatic u32 qed_cxt_xrc_srqs_per_page(struct qed_hwfn *p_hwfn)\n{\n\tu32 page_size;\n\n\tpage_size = qed_cxt_get_ilt_page_size(p_hwfn, ILT_CLI_TSDM);\n\treturn page_size / XRC_SRQ_CXT_SIZE;\n}\n\nu32 qed_cxt_get_total_srq_count(struct qed_hwfn *p_hwfn)\n{\n\tstruct qed_cxt_mngr *p_mgr = p_hwfn->p_cxt_mngr;\n\tu32 total_srqs;\n\n\ttotal_srqs = p_mgr->srq_count + p_mgr->xrc_srq_count;\n\n\treturn total_srqs;\n}\n\n \nstatic void qed_cxt_set_proto_cid_count(struct qed_hwfn *p_hwfn,\n\t\t\t\t\tenum protocol_type type,\n\t\t\t\t\tu32 cid_count, u32 vf_cid_cnt)\n{\n\tstruct qed_cxt_mngr *p_mgr = p_hwfn->p_cxt_mngr;\n\tstruct qed_conn_type_cfg *p_conn = &p_mgr->conn_cfg[type];\n\n\tp_conn->cid_count = roundup(cid_count, DQ_RANGE_ALIGN);\n\tp_conn->cids_per_vf = roundup(vf_cid_cnt, DQ_RANGE_ALIGN);\n\n\tif (type == PROTOCOLID_ROCE) {\n\t\tu32 page_sz = p_mgr->clients[ILT_CLI_CDUC].p_size.val;\n\t\tu32 cxt_size = CONN_CXT_SIZE(p_hwfn);\n\t\tu32 elems_per_page = ILT_PAGE_IN_BYTES(page_sz) / cxt_size;\n\t\tu32 align = elems_per_page * DQ_RANGE_ALIGN;\n\n\t\tp_conn->cid_count = roundup(p_conn->cid_count, align);\n\t}\n}\n\nu32 qed_cxt_get_proto_cid_count(struct qed_hwfn *p_hwfn,\n\t\t\t\tenum protocol_type type, u32 *vf_cid)\n{\n\tif (vf_cid)\n\t\t*vf_cid = p_hwfn->p_cxt_mngr->conn_cfg[type].cids_per_vf;\n\n\treturn p_hwfn->p_cxt_mngr->conn_cfg[type].cid_count;\n}\n\nu32 qed_cxt_get_proto_cid_start(struct qed_hwfn *p_hwfn,\n\t\t\t\tenum protocol_type type)\n{\n\treturn p_hwfn->p_cxt_mngr->acquired[type].start_cid;\n}\n\nu32 qed_cxt_get_proto_tid_count(struct qed_hwfn *p_hwfn,\n\t\t\t\tenum protocol_type type)\n{\n\tu32 cnt = 0;\n\tint i;\n\n\tfor (i = 0; i < TASK_SEGMENTS; i++)\n\t\tcnt += p_hwfn->p_cxt_mngr->conn_cfg[type].tid_seg[i].count;\n\n\treturn cnt;\n}\n\nstatic void qed_cxt_set_proto_tid_count(struct qed_hwfn *p_hwfn,\n\t\t\t\t\tenum protocol_type proto,\n\t\t\t\t\tu8 seg,\n\t\t\t\t\tu8 seg_type, u32 count, bool has_fl)\n{\n\tstruct qed_cxt_mngr *p_mngr = p_hwfn->p_cxt_mngr;\n\tstruct qed_tid_seg *p_seg = &p_mngr->conn_cfg[proto].tid_seg[seg];\n\n\tp_seg->count = count;\n\tp_seg->has_fl_mem = has_fl;\n\tp_seg->type = seg_type;\n}\n\nstatic void qed_ilt_cli_blk_fill(struct qed_ilt_client_cfg *p_cli,\n\t\t\t\t struct qed_ilt_cli_blk *p_blk,\n\t\t\t\t u32 start_line, u32 total_size, u32 elem_size)\n{\n\tu32 ilt_size = ILT_PAGE_IN_BYTES(p_cli->p_size.val);\n\n\t \n\tif (p_blk->total_size)\n\t\treturn;\n\n\tp_blk->total_size = total_size;\n\tp_blk->real_size_in_page = 0;\n\tif (elem_size)\n\t\tp_blk->real_size_in_page = (ilt_size / elem_size) * elem_size;\n\tp_blk->start_line = start_line;\n}\n\nstatic void qed_ilt_cli_adv_line(struct qed_hwfn *p_hwfn,\n\t\t\t\t struct qed_ilt_client_cfg *p_cli,\n\t\t\t\t struct qed_ilt_cli_blk *p_blk,\n\t\t\t\t u32 *p_line, enum ilt_clients client_id)\n{\n\tif (!p_blk->total_size)\n\t\treturn;\n\n\tif (!p_cli->active)\n\t\tp_cli->first.val = *p_line;\n\n\tp_cli->active = true;\n\t*p_line += DIV_ROUND_UP(p_blk->total_size, p_blk->real_size_in_page);\n\tp_cli->last.val = *p_line - 1;\n\n\tDP_VERBOSE(p_hwfn, QED_MSG_ILT,\n\t\t   \"ILT[Client %d] - Lines: [%08x - %08x]. Block - Size %08x [Real %08x] Start line %d\\n\",\n\t\t   client_id, p_cli->first.val,\n\t\t   p_cli->last.val, p_blk->total_size,\n\t\t   p_blk->real_size_in_page, p_blk->start_line);\n}\n\nstatic u32 qed_ilt_get_dynamic_line_cnt(struct qed_hwfn *p_hwfn,\n\t\t\t\t\tenum ilt_clients ilt_client)\n{\n\tu32 cid_count = p_hwfn->p_cxt_mngr->conn_cfg[PROTOCOLID_ROCE].cid_count;\n\tstruct qed_ilt_client_cfg *p_cli;\n\tu32 lines_to_skip = 0;\n\tu32 cxts_per_p;\n\n\tif (ilt_client == ILT_CLI_CDUC) {\n\t\tp_cli = &p_hwfn->p_cxt_mngr->clients[ILT_CLI_CDUC];\n\n\t\tcxts_per_p = ILT_PAGE_IN_BYTES(p_cli->p_size.val) /\n\t\t    (u32) CONN_CXT_SIZE(p_hwfn);\n\n\t\tlines_to_skip = cid_count / cxts_per_p;\n\t}\n\n\treturn lines_to_skip;\n}\n\nstatic struct qed_ilt_client_cfg *qed_cxt_set_cli(struct qed_ilt_client_cfg\n\t\t\t\t\t\t  *p_cli)\n{\n\tp_cli->active = false;\n\tp_cli->first.val = 0;\n\tp_cli->last.val = 0;\n\treturn p_cli;\n}\n\nstatic struct qed_ilt_cli_blk *qed_cxt_set_blk(struct qed_ilt_cli_blk *p_blk)\n{\n\tp_blk->total_size = 0;\n\treturn p_blk;\n}\n\nstatic void qed_cxt_ilt_blk_reset(struct qed_hwfn *p_hwfn)\n{\n\tstruct qed_ilt_client_cfg *clients = p_hwfn->p_cxt_mngr->clients;\n\tu32 cli_idx, blk_idx;\n\n\tfor (cli_idx = 0; cli_idx < MAX_ILT_CLIENTS; cli_idx++) {\n\t\tfor (blk_idx = 0; blk_idx < ILT_CLI_PF_BLOCKS; blk_idx++)\n\t\t\tclients[cli_idx].pf_blks[blk_idx].total_size = 0;\n\n\t\tfor (blk_idx = 0; blk_idx < ILT_CLI_VF_BLOCKS; blk_idx++)\n\t\t\tclients[cli_idx].vf_blks[blk_idx].total_size = 0;\n\t}\n}\n\nint qed_cxt_cfg_ilt_compute(struct qed_hwfn *p_hwfn, u32 *line_count)\n{\n\tstruct qed_cxt_mngr *p_mngr = p_hwfn->p_cxt_mngr;\n\tu32 curr_line, total, i, task_size, line;\n\tstruct qed_ilt_client_cfg *p_cli;\n\tstruct qed_ilt_cli_blk *p_blk;\n\tstruct qed_cdu_iids cdu_iids;\n\tstruct qed_src_iids src_iids;\n\tstruct qed_qm_iids qm_iids;\n\tstruct qed_tm_iids tm_iids;\n\tstruct qed_tid_seg *p_seg;\n\n\tmemset(&qm_iids, 0, sizeof(qm_iids));\n\tmemset(&cdu_iids, 0, sizeof(cdu_iids));\n\tmemset(&src_iids, 0, sizeof(src_iids));\n\tmemset(&tm_iids, 0, sizeof(tm_iids));\n\n\tp_mngr->pf_start_line = RESC_START(p_hwfn, QED_ILT);\n\n\t \n\tqed_cxt_ilt_blk_reset(p_hwfn);\n\n\tDP_VERBOSE(p_hwfn, QED_MSG_ILT,\n\t\t   \"hwfn [%d] - Set context manager starting line to be 0x%08x\\n\",\n\t\t   p_hwfn->my_id, p_hwfn->p_cxt_mngr->pf_start_line);\n\n\t \n\tp_cli = qed_cxt_set_cli(&p_mngr->clients[ILT_CLI_CDUC]);\n\n\tcurr_line = p_mngr->pf_start_line;\n\n\t \n\tp_cli->pf_total_lines = 0;\n\n\t \n\tqed_cxt_cdu_iids(p_mngr, &cdu_iids);\n\n\tp_blk = qed_cxt_set_blk(&p_cli->pf_blks[CDUC_BLK]);\n\n\ttotal = cdu_iids.pf_cids * CONN_CXT_SIZE(p_hwfn);\n\n\tqed_ilt_cli_blk_fill(p_cli, p_blk, curr_line,\n\t\t\t     total, CONN_CXT_SIZE(p_hwfn));\n\n\tqed_ilt_cli_adv_line(p_hwfn, p_cli, p_blk, &curr_line, ILT_CLI_CDUC);\n\tp_cli->pf_total_lines = curr_line - p_blk->start_line;\n\n\tp_blk->dynamic_line_cnt = qed_ilt_get_dynamic_line_cnt(p_hwfn,\n\t\t\t\t\t\t\t       ILT_CLI_CDUC);\n\n\t \n\tp_blk = qed_cxt_set_blk(&p_cli->vf_blks[CDUC_BLK]);\n\ttotal = cdu_iids.per_vf_cids * CONN_CXT_SIZE(p_hwfn);\n\n\tqed_ilt_cli_blk_fill(p_cli, p_blk, curr_line,\n\t\t\t     total, CONN_CXT_SIZE(p_hwfn));\n\n\tqed_ilt_cli_adv_line(p_hwfn, p_cli, p_blk, &curr_line, ILT_CLI_CDUC);\n\tp_cli->vf_total_lines = curr_line - p_blk->start_line;\n\n\tfor (i = 1; i < p_mngr->vf_count; i++)\n\t\tqed_ilt_cli_adv_line(p_hwfn, p_cli, p_blk, &curr_line,\n\t\t\t\t     ILT_CLI_CDUC);\n\n\t \n\tp_cli = qed_cxt_set_cli(&p_mngr->clients[ILT_CLI_CDUT]);\n\tp_cli->first.val = curr_line;\n\n\t \n\tfor (i = 0; i < NUM_TASK_PF_SEGMENTS; i++) {\n\t\tp_seg = qed_cxt_tid_seg_info(p_hwfn, i);\n\t\tif (!p_seg || p_seg->count == 0)\n\t\t\tcontinue;\n\n\t\tp_blk = qed_cxt_set_blk(&p_cli->pf_blks[CDUT_SEG_BLK(i)]);\n\t\ttotal = p_seg->count * p_mngr->task_type_size[p_seg->type];\n\t\tqed_ilt_cli_blk_fill(p_cli, p_blk, curr_line, total,\n\t\t\t\t     p_mngr->task_type_size[p_seg->type]);\n\n\t\tqed_ilt_cli_adv_line(p_hwfn, p_cli, p_blk, &curr_line,\n\t\t\t\t     ILT_CLI_CDUT);\n\t}\n\n\t \n\tfor (i = 0; i < NUM_TASK_PF_SEGMENTS; i++) {\n\t\tp_seg = qed_cxt_tid_seg_info(p_hwfn, i);\n\t\tif (!p_seg || p_seg->count == 0)\n\t\t\tcontinue;\n\n\t\tp_blk =\n\t\t    qed_cxt_set_blk(&p_cli->pf_blks[CDUT_FL_SEG_BLK(i, PF)]);\n\n\t\tif (!p_seg->has_fl_mem) {\n\t\t\t \n\t\t\tline = p_cli->pf_blks[CDUT_SEG_BLK(i)].start_line;\n\n\t\t\tqed_ilt_cli_blk_fill(p_cli, p_blk, line, 0, 0);\n\t\t\tcontinue;\n\t\t}\n\t\ttotal = p_seg->count * p_mngr->task_type_size[p_seg->type];\n\n\t\tqed_ilt_cli_blk_fill(p_cli, p_blk,\n\t\t\t\t     curr_line, total,\n\t\t\t\t     p_mngr->task_type_size[p_seg->type]);\n\n\t\tqed_ilt_cli_adv_line(p_hwfn, p_cli, p_blk, &curr_line,\n\t\t\t\t     ILT_CLI_CDUT);\n\t}\n\tp_cli->pf_total_lines = curr_line - p_cli->pf_blks[0].start_line;\n\n\t \n\tp_seg = qed_cxt_tid_seg_info(p_hwfn, TASK_SEGMENT_VF);\n\tif (p_seg && p_seg->count) {\n\t\t \n\n\t\t \n\t\ttotal = p_seg->count * p_mngr->task_type_size[p_seg->type];\n\n\t\tp_blk = qed_cxt_set_blk(&p_cli->vf_blks[CDUT_SEG_BLK(0)]);\n\t\tqed_ilt_cli_blk_fill(p_cli, p_blk,\n\t\t\t\t     curr_line, total,\n\t\t\t\t     p_mngr->task_type_size[p_seg->type]);\n\n\t\tqed_ilt_cli_adv_line(p_hwfn, p_cli, p_blk, &curr_line,\n\t\t\t\t     ILT_CLI_CDUT);\n\n\t\t \n\t\tp_blk =\n\t\t    qed_cxt_set_blk(&p_cli->vf_blks[CDUT_FL_SEG_BLK(0, VF)]);\n\t\tif (!p_seg->has_fl_mem) {\n\t\t\t \n\t\t\tline = p_cli->vf_blks[CDUT_SEG_BLK(0)].start_line;\n\t\t\tqed_ilt_cli_blk_fill(p_cli, p_blk, line, 0, 0);\n\t\t} else {\n\t\t\ttask_size = p_mngr->task_type_size[p_seg->type];\n\t\t\tqed_ilt_cli_blk_fill(p_cli, p_blk,\n\t\t\t\t\t     curr_line, total, task_size);\n\t\t\tqed_ilt_cli_adv_line(p_hwfn, p_cli, p_blk, &curr_line,\n\t\t\t\t\t     ILT_CLI_CDUT);\n\t\t}\n\t\tp_cli->vf_total_lines = curr_line -\n\t\t    p_cli->vf_blks[0].start_line;\n\n\t\t \n\t\tfor (i = 1; i < p_mngr->vf_count; i++) {\n\t\t\tp_blk = &p_cli->vf_blks[CDUT_SEG_BLK(0)];\n\t\t\tqed_ilt_cli_adv_line(p_hwfn, p_cli, p_blk, &curr_line,\n\t\t\t\t\t     ILT_CLI_CDUT);\n\n\t\t\tp_blk = &p_cli->vf_blks[CDUT_FL_SEG_BLK(0, VF)];\n\t\t\tqed_ilt_cli_adv_line(p_hwfn, p_cli, p_blk, &curr_line,\n\t\t\t\t\t     ILT_CLI_CDUT);\n\t\t}\n\t}\n\n\t \n\tp_cli = qed_cxt_set_cli(&p_mngr->clients[ILT_CLI_QM]);\n\tp_blk = qed_cxt_set_blk(&p_cli->pf_blks[0]);\n\n\tqed_cxt_qm_iids(p_hwfn, &qm_iids);\n\ttotal = qed_qm_pf_mem_size(qm_iids.cids,\n\t\t\t\t   qm_iids.vf_cids, qm_iids.tids,\n\t\t\t\t   p_hwfn->qm_info.num_pqs,\n\t\t\t\t   p_hwfn->qm_info.num_vf_pqs);\n\n\tDP_VERBOSE(p_hwfn,\n\t\t   QED_MSG_ILT,\n\t\t   \"QM ILT Info, (cids=%d, vf_cids=%d, tids=%d, num_pqs=%d, num_vf_pqs=%d, memory_size=%d)\\n\",\n\t\t   qm_iids.cids,\n\t\t   qm_iids.vf_cids,\n\t\t   qm_iids.tids,\n\t\t   p_hwfn->qm_info.num_pqs, p_hwfn->qm_info.num_vf_pqs, total);\n\n\tqed_ilt_cli_blk_fill(p_cli, p_blk,\n\t\t\t     curr_line, total * 0x1000,\n\t\t\t     QM_PQ_ELEMENT_SIZE);\n\n\tqed_ilt_cli_adv_line(p_hwfn, p_cli, p_blk, &curr_line, ILT_CLI_QM);\n\tp_cli->pf_total_lines = curr_line - p_blk->start_line;\n\n\t \n\tp_cli = qed_cxt_set_cli(&p_mngr->clients[ILT_CLI_SRC]);\n\tqed_cxt_src_iids(p_mngr, &src_iids);\n\n\t \n\ttotal = src_iids.pf_cids + src_iids.per_vf_cids * p_mngr->vf_count;\n\tif (total) {\n\t\tu32 local_max = max_t(u32, total,\n\t\t\t\t      SRC_MIN_NUM_ELEMS);\n\n\t\ttotal = roundup_pow_of_two(local_max);\n\n\t\tp_blk = qed_cxt_set_blk(&p_cli->pf_blks[0]);\n\t\tqed_ilt_cli_blk_fill(p_cli, p_blk, curr_line,\n\t\t\t\t     total * sizeof(struct src_ent),\n\t\t\t\t     sizeof(struct src_ent));\n\n\t\tqed_ilt_cli_adv_line(p_hwfn, p_cli, p_blk, &curr_line,\n\t\t\t\t     ILT_CLI_SRC);\n\t\tp_cli->pf_total_lines = curr_line - p_blk->start_line;\n\t}\n\n\t \n\tp_cli = qed_cxt_set_cli(&p_mngr->clients[ILT_CLI_TM]);\n\tqed_cxt_tm_iids(p_hwfn, p_mngr, &tm_iids);\n\ttotal = tm_iids.pf_cids + tm_iids.pf_tids_total;\n\tif (total) {\n\t\tp_blk = qed_cxt_set_blk(&p_cli->pf_blks[0]);\n\t\tqed_ilt_cli_blk_fill(p_cli, p_blk, curr_line,\n\t\t\t\t     total * TM_ELEM_SIZE, TM_ELEM_SIZE);\n\n\t\tqed_ilt_cli_adv_line(p_hwfn, p_cli, p_blk, &curr_line,\n\t\t\t\t     ILT_CLI_TM);\n\t\tp_cli->pf_total_lines = curr_line - p_blk->start_line;\n\t}\n\n\t \n\ttotal = tm_iids.per_vf_cids + tm_iids.per_vf_tids;\n\tif (total) {\n\t\tp_blk = qed_cxt_set_blk(&p_cli->vf_blks[0]);\n\t\tqed_ilt_cli_blk_fill(p_cli, p_blk, curr_line,\n\t\t\t\t     total * TM_ELEM_SIZE, TM_ELEM_SIZE);\n\n\t\tqed_ilt_cli_adv_line(p_hwfn, p_cli, p_blk, &curr_line,\n\t\t\t\t     ILT_CLI_TM);\n\n\t\tp_cli->vf_total_lines = curr_line - p_blk->start_line;\n\t\tfor (i = 1; i < p_mngr->vf_count; i++)\n\t\t\tqed_ilt_cli_adv_line(p_hwfn, p_cli, p_blk, &curr_line,\n\t\t\t\t\t     ILT_CLI_TM);\n\t}\n\n\t \n\ttotal = qed_cxt_get_total_srq_count(p_hwfn);\n\n\tif (total) {\n\t\tp_cli = qed_cxt_set_cli(&p_mngr->clients[ILT_CLI_TSDM]);\n\t\tp_blk = qed_cxt_set_blk(&p_cli->pf_blks[SRQ_BLK]);\n\t\tqed_ilt_cli_blk_fill(p_cli, p_blk, curr_line,\n\t\t\t\t     total * SRQ_CXT_SIZE, SRQ_CXT_SIZE);\n\n\t\tqed_ilt_cli_adv_line(p_hwfn, p_cli, p_blk, &curr_line,\n\t\t\t\t     ILT_CLI_TSDM);\n\t\tp_cli->pf_total_lines = curr_line - p_blk->start_line;\n\t}\n\n\t*line_count = curr_line - p_hwfn->p_cxt_mngr->pf_start_line;\n\n\tif (curr_line - p_hwfn->p_cxt_mngr->pf_start_line >\n\t    RESC_NUM(p_hwfn, QED_ILT))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nu32 qed_cxt_cfg_ilt_compute_excess(struct qed_hwfn *p_hwfn, u32 used_lines)\n{\n\tstruct qed_ilt_client_cfg *p_cli;\n\tu32 excess_lines, available_lines;\n\tstruct qed_cxt_mngr *p_mngr;\n\tu32 ilt_page_size, elem_size;\n\tstruct qed_tid_seg *p_seg;\n\tint i;\n\n\tavailable_lines = RESC_NUM(p_hwfn, QED_ILT);\n\texcess_lines = used_lines - available_lines;\n\n\tif (!excess_lines)\n\t\treturn 0;\n\n\tif (!QED_IS_RDMA_PERSONALITY(p_hwfn))\n\t\treturn 0;\n\n\tp_mngr = p_hwfn->p_cxt_mngr;\n\tp_cli = &p_mngr->clients[ILT_CLI_CDUT];\n\tilt_page_size = ILT_PAGE_IN_BYTES(p_cli->p_size.val);\n\n\tfor (i = 0; i < NUM_TASK_PF_SEGMENTS; i++) {\n\t\tp_seg = qed_cxt_tid_seg_info(p_hwfn, i);\n\t\tif (!p_seg || p_seg->count == 0)\n\t\t\tcontinue;\n\n\t\telem_size = p_mngr->task_type_size[p_seg->type];\n\t\tif (!elem_size)\n\t\t\tcontinue;\n\n\t\treturn (ilt_page_size / elem_size) * excess_lines;\n\t}\n\n\tDP_NOTICE(p_hwfn, \"failed computing excess ILT lines\\n\");\n\treturn 0;\n}\n\nstatic void qed_cxt_src_t2_free(struct qed_hwfn *p_hwfn)\n{\n\tstruct qed_src_t2 *p_t2 = &p_hwfn->p_cxt_mngr->src_t2;\n\tu32 i;\n\n\tif (!p_t2 || !p_t2->dma_mem)\n\t\treturn;\n\n\tfor (i = 0; i < p_t2->num_pages; i++)\n\t\tif (p_t2->dma_mem[i].virt_addr)\n\t\t\tdma_free_coherent(&p_hwfn->cdev->pdev->dev,\n\t\t\t\t\t  p_t2->dma_mem[i].size,\n\t\t\t\t\t  p_t2->dma_mem[i].virt_addr,\n\t\t\t\t\t  p_t2->dma_mem[i].phys_addr);\n\n\tkfree(p_t2->dma_mem);\n\tp_t2->dma_mem = NULL;\n}\n\nstatic int\nqed_cxt_t2_alloc_pages(struct qed_hwfn *p_hwfn,\n\t\t       struct qed_src_t2 *p_t2, u32 total_size, u32 page_size)\n{\n\tvoid **p_virt;\n\tu32 size, i;\n\n\tif (!p_t2 || !p_t2->dma_mem)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < p_t2->num_pages; i++) {\n\t\tsize = min_t(u32, total_size, page_size);\n\t\tp_virt = &p_t2->dma_mem[i].virt_addr;\n\n\t\t*p_virt = dma_alloc_coherent(&p_hwfn->cdev->pdev->dev,\n\t\t\t\t\t     size,\n\t\t\t\t\t     &p_t2->dma_mem[i].phys_addr,\n\t\t\t\t\t     GFP_KERNEL);\n\t\tif (!p_t2->dma_mem[i].virt_addr)\n\t\t\treturn -ENOMEM;\n\n\t\tmemset(*p_virt, 0, size);\n\t\tp_t2->dma_mem[i].size = size;\n\t\ttotal_size -= size;\n\t}\n\n\treturn 0;\n}\n\nstatic int qed_cxt_src_t2_alloc(struct qed_hwfn *p_hwfn)\n{\n\tstruct qed_cxt_mngr *p_mngr = p_hwfn->p_cxt_mngr;\n\tu32 conn_num, total_size, ent_per_page, psz, i;\n\tstruct phys_mem_desc *p_t2_last_page;\n\tstruct qed_ilt_client_cfg *p_src;\n\tstruct qed_src_iids src_iids;\n\tstruct qed_src_t2 *p_t2;\n\tint rc;\n\n\tmemset(&src_iids, 0, sizeof(src_iids));\n\n\t \n\tp_src = &p_hwfn->p_cxt_mngr->clients[ILT_CLI_SRC];\n\tif (!p_src->active)\n\t\treturn 0;\n\n\tqed_cxt_src_iids(p_mngr, &src_iids);\n\tconn_num = src_iids.pf_cids + src_iids.per_vf_cids * p_mngr->vf_count;\n\ttotal_size = conn_num * sizeof(struct src_ent);\n\n\t \n\tpsz = ILT_PAGE_IN_BYTES(p_src->p_size.val);\n\tp_t2 = &p_mngr->src_t2;\n\tp_t2->num_pages = DIV_ROUND_UP(total_size, psz);\n\n\t \n\tp_t2->dma_mem = kcalloc(p_t2->num_pages, sizeof(struct phys_mem_desc),\n\t\t\t\tGFP_KERNEL);\n\tif (!p_t2->dma_mem) {\n\t\tDP_NOTICE(p_hwfn, \"Failed to allocate t2 table\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto t2_fail;\n\t}\n\n\trc = qed_cxt_t2_alloc_pages(p_hwfn, p_t2, total_size, psz);\n\tif (rc)\n\t\tgoto t2_fail;\n\n\t \n\n\t \n\tent_per_page = psz / sizeof(struct src_ent);\n\n\tp_t2->first_free = (u64)p_t2->dma_mem[0].phys_addr;\n\n\tp_t2_last_page = &p_t2->dma_mem[(conn_num - 1) / ent_per_page];\n\tp_t2->last_free = (u64)p_t2_last_page->phys_addr +\n\t    ((conn_num - 1) & (ent_per_page - 1)) * sizeof(struct src_ent);\n\n\tfor (i = 0; i < p_t2->num_pages; i++) {\n\t\tu32 ent_num = min_t(u32,\n\t\t\t\t    ent_per_page,\n\t\t\t\t    conn_num);\n\t\tstruct src_ent *entries = p_t2->dma_mem[i].virt_addr;\n\t\tu64 p_ent_phys = (u64)p_t2->dma_mem[i].phys_addr, val;\n\t\tu32 j;\n\n\t\tfor (j = 0; j < ent_num - 1; j++) {\n\t\t\tval = p_ent_phys + (j + 1) * sizeof(struct src_ent);\n\t\t\tentries[j].next = cpu_to_be64(val);\n\t\t}\n\n\t\tif (i < p_t2->num_pages - 1)\n\t\t\tval = (u64)p_t2->dma_mem[i + 1].phys_addr;\n\t\telse\n\t\t\tval = 0;\n\t\tentries[j].next = cpu_to_be64(val);\n\n\t\tconn_num -= ent_num;\n\t}\n\n\treturn 0;\n\nt2_fail:\n\tqed_cxt_src_t2_free(p_hwfn);\n\treturn rc;\n}\n\n#define for_each_ilt_valid_client(pos, clients)\t\\\n\tfor (pos = 0; pos < MAX_ILT_CLIENTS; pos++)\t\\\n\t\tif (!clients[pos].active) {\t\\\n\t\t\tcontinue;\t\t\\\n\t\t} else\t\t\t\t\\\n\n \nstatic u32 qed_cxt_ilt_shadow_size(struct qed_ilt_client_cfg *ilt_clients)\n{\n\tu32 size = 0;\n\tu32 i;\n\n\tfor_each_ilt_valid_client(i, ilt_clients)\n\t    size += (ilt_clients[i].last.val - ilt_clients[i].first.val + 1);\n\n\treturn size;\n}\n\nstatic void qed_ilt_shadow_free(struct qed_hwfn *p_hwfn)\n{\n\tstruct qed_ilt_client_cfg *p_cli = p_hwfn->p_cxt_mngr->clients;\n\tstruct qed_cxt_mngr *p_mngr = p_hwfn->p_cxt_mngr;\n\tu32 ilt_size, i;\n\n\tilt_size = qed_cxt_ilt_shadow_size(p_cli);\n\n\tfor (i = 0; p_mngr->ilt_shadow && i < ilt_size; i++) {\n\t\tstruct phys_mem_desc *p_dma = &p_mngr->ilt_shadow[i];\n\n\t\tif (p_dma->virt_addr)\n\t\t\tdma_free_coherent(&p_hwfn->cdev->pdev->dev,\n\t\t\t\t\t  p_dma->size, p_dma->virt_addr,\n\t\t\t\t\t  p_dma->phys_addr);\n\t\tp_dma->virt_addr = NULL;\n\t}\n\tkfree(p_mngr->ilt_shadow);\n\tp_mngr->ilt_shadow = NULL;\n}\n\nstatic int qed_ilt_blk_alloc(struct qed_hwfn *p_hwfn,\n\t\t\t     struct qed_ilt_cli_blk *p_blk,\n\t\t\t     enum ilt_clients ilt_client,\n\t\t\t     u32 start_line_offset)\n{\n\tstruct phys_mem_desc *ilt_shadow = p_hwfn->p_cxt_mngr->ilt_shadow;\n\tu32 lines, line, sz_left, lines_to_skip = 0;\n\n\t \n\tif (QED_IS_RDMA_PERSONALITY(p_hwfn) &&\n\t    ((ilt_client == ILT_CLI_CDUT) || ilt_client == ILT_CLI_TSDM))\n\t\treturn 0;\n\n\tlines_to_skip = p_blk->dynamic_line_cnt;\n\n\tif (!p_blk->total_size)\n\t\treturn 0;\n\n\tsz_left = p_blk->total_size;\n\tlines = DIV_ROUND_UP(sz_left, p_blk->real_size_in_page) - lines_to_skip;\n\tline = p_blk->start_line + start_line_offset -\n\t    p_hwfn->p_cxt_mngr->pf_start_line + lines_to_skip;\n\n\tfor (; lines; lines--) {\n\t\tdma_addr_t p_phys;\n\t\tvoid *p_virt;\n\t\tu32 size;\n\n\t\tsize = min_t(u32, sz_left, p_blk->real_size_in_page);\n\t\tp_virt = dma_alloc_coherent(&p_hwfn->cdev->pdev->dev, size,\n\t\t\t\t\t    &p_phys, GFP_KERNEL);\n\t\tif (!p_virt)\n\t\t\treturn -ENOMEM;\n\n\t\tilt_shadow[line].phys_addr = p_phys;\n\t\tilt_shadow[line].virt_addr = p_virt;\n\t\tilt_shadow[line].size = size;\n\n\t\tDP_VERBOSE(p_hwfn, QED_MSG_ILT,\n\t\t\t   \"ILT shadow: Line [%d] Physical 0x%llx Virtual %p Size %d\\n\",\n\t\t\t    line, (u64)p_phys, p_virt, size);\n\n\t\tsz_left -= size;\n\t\tline++;\n\t}\n\n\treturn 0;\n}\n\nstatic int qed_ilt_shadow_alloc(struct qed_hwfn *p_hwfn)\n{\n\tstruct qed_cxt_mngr *p_mngr = p_hwfn->p_cxt_mngr;\n\tstruct qed_ilt_client_cfg *clients = p_mngr->clients;\n\tstruct qed_ilt_cli_blk *p_blk;\n\tu32 size, i, j, k;\n\tint rc;\n\n\tsize = qed_cxt_ilt_shadow_size(clients);\n\tp_mngr->ilt_shadow = kcalloc(size, sizeof(struct phys_mem_desc),\n\t\t\t\t     GFP_KERNEL);\n\tif (!p_mngr->ilt_shadow) {\n\t\trc = -ENOMEM;\n\t\tgoto ilt_shadow_fail;\n\t}\n\n\tDP_VERBOSE(p_hwfn, QED_MSG_ILT,\n\t\t   \"Allocated 0x%x bytes for ilt shadow\\n\",\n\t\t   (u32)(size * sizeof(struct phys_mem_desc)));\n\n\tfor_each_ilt_valid_client(i, clients) {\n\t\tfor (j = 0; j < ILT_CLI_PF_BLOCKS; j++) {\n\t\t\tp_blk = &clients[i].pf_blks[j];\n\t\t\trc = qed_ilt_blk_alloc(p_hwfn, p_blk, i, 0);\n\t\t\tif (rc)\n\t\t\t\tgoto ilt_shadow_fail;\n\t\t}\n\t\tfor (k = 0; k < p_mngr->vf_count; k++) {\n\t\t\tfor (j = 0; j < ILT_CLI_VF_BLOCKS; j++) {\n\t\t\t\tu32 lines = clients[i].vf_total_lines * k;\n\n\t\t\t\tp_blk = &clients[i].vf_blks[j];\n\t\t\t\trc = qed_ilt_blk_alloc(p_hwfn, p_blk, i, lines);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto ilt_shadow_fail;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n\nilt_shadow_fail:\n\tqed_ilt_shadow_free(p_hwfn);\n\treturn rc;\n}\n\nstatic void qed_cid_map_free(struct qed_hwfn *p_hwfn)\n{\n\tstruct qed_cxt_mngr *p_mngr = p_hwfn->p_cxt_mngr;\n\tu32 type, vf;\n\n\tfor (type = 0; type < MAX_CONN_TYPES; type++) {\n\t\tbitmap_free(p_mngr->acquired[type].cid_map);\n\t\tp_mngr->acquired[type].max_count = 0;\n\t\tp_mngr->acquired[type].start_cid = 0;\n\n\t\tfor (vf = 0; vf < MAX_NUM_VFS; vf++) {\n\t\t\tbitmap_free(p_mngr->acquired_vf[type][vf].cid_map);\n\t\t\tp_mngr->acquired_vf[type][vf].max_count = 0;\n\t\t\tp_mngr->acquired_vf[type][vf].start_cid = 0;\n\t\t}\n\t}\n}\n\nstatic int\nqed_cid_map_alloc_single(struct qed_hwfn *p_hwfn,\n\t\t\t u32 type,\n\t\t\t u32 cid_start,\n\t\t\t u32 cid_count, struct qed_cid_acquired_map *p_map)\n{\n\tif (!cid_count)\n\t\treturn 0;\n\n\tp_map->cid_map = bitmap_zalloc(cid_count, GFP_KERNEL);\n\tif (!p_map->cid_map)\n\t\treturn -ENOMEM;\n\n\tp_map->max_count = cid_count;\n\tp_map->start_cid = cid_start;\n\n\tDP_VERBOSE(p_hwfn, QED_MSG_CXT,\n\t\t   \"Type %08x start: %08x count %08x\\n\",\n\t\t   type, p_map->start_cid, p_map->max_count);\n\n\treturn 0;\n}\n\nstatic int qed_cid_map_alloc(struct qed_hwfn *p_hwfn)\n{\n\tstruct qed_cxt_mngr *p_mngr = p_hwfn->p_cxt_mngr;\n\tu32 start_cid = 0, vf_start_cid = 0;\n\tu32 type, vf;\n\n\tfor (type = 0; type < MAX_CONN_TYPES; type++) {\n\t\tstruct qed_conn_type_cfg *p_cfg = &p_mngr->conn_cfg[type];\n\t\tstruct qed_cid_acquired_map *p_map;\n\n\t\t \n\t\tp_map = &p_mngr->acquired[type];\n\t\tif (qed_cid_map_alloc_single(p_hwfn, type, start_cid,\n\t\t\t\t\t     p_cfg->cid_count, p_map))\n\t\t\tgoto cid_map_fail;\n\n\t\t \n\t\tfor (vf = 0; vf < MAX_NUM_VFS; vf++) {\n\t\t\tp_map = &p_mngr->acquired_vf[type][vf];\n\t\t\tif (qed_cid_map_alloc_single(p_hwfn, type,\n\t\t\t\t\t\t     vf_start_cid,\n\t\t\t\t\t\t     p_cfg->cids_per_vf, p_map))\n\t\t\t\tgoto cid_map_fail;\n\t\t}\n\n\t\tstart_cid += p_cfg->cid_count;\n\t\tvf_start_cid += p_cfg->cids_per_vf;\n\t}\n\n\treturn 0;\n\ncid_map_fail:\n\tqed_cid_map_free(p_hwfn);\n\treturn -ENOMEM;\n}\n\nint qed_cxt_mngr_alloc(struct qed_hwfn *p_hwfn)\n{\n\tstruct qed_ilt_client_cfg *clients;\n\tstruct qed_cxt_mngr *p_mngr;\n\tu32 i;\n\n\tp_mngr = kzalloc(sizeof(*p_mngr), GFP_KERNEL);\n\tif (!p_mngr)\n\t\treturn -ENOMEM;\n\n\t \n\tclients = p_mngr->clients;\n\tclients[ILT_CLI_CDUC].first.reg = ILT_CFG_REG(CDUC, FIRST_ILT);\n\tclients[ILT_CLI_CDUC].last.reg = ILT_CFG_REG(CDUC, LAST_ILT);\n\tclients[ILT_CLI_CDUC].p_size.reg = ILT_CFG_REG(CDUC, P_SIZE);\n\n\tclients[ILT_CLI_QM].first.reg = ILT_CFG_REG(QM, FIRST_ILT);\n\tclients[ILT_CLI_QM].last.reg = ILT_CFG_REG(QM, LAST_ILT);\n\tclients[ILT_CLI_QM].p_size.reg = ILT_CFG_REG(QM, P_SIZE);\n\n\tclients[ILT_CLI_TM].first.reg = ILT_CFG_REG(TM, FIRST_ILT);\n\tclients[ILT_CLI_TM].last.reg = ILT_CFG_REG(TM, LAST_ILT);\n\tclients[ILT_CLI_TM].p_size.reg = ILT_CFG_REG(TM, P_SIZE);\n\n\tclients[ILT_CLI_SRC].first.reg = ILT_CFG_REG(SRC, FIRST_ILT);\n\tclients[ILT_CLI_SRC].last.reg = ILT_CFG_REG(SRC, LAST_ILT);\n\tclients[ILT_CLI_SRC].p_size.reg = ILT_CFG_REG(SRC, P_SIZE);\n\n\tclients[ILT_CLI_CDUT].first.reg = ILT_CFG_REG(CDUT, FIRST_ILT);\n\tclients[ILT_CLI_CDUT].last.reg = ILT_CFG_REG(CDUT, LAST_ILT);\n\tclients[ILT_CLI_CDUT].p_size.reg = ILT_CFG_REG(CDUT, P_SIZE);\n\n\tclients[ILT_CLI_TSDM].first.reg = ILT_CFG_REG(TSDM, FIRST_ILT);\n\tclients[ILT_CLI_TSDM].last.reg = ILT_CFG_REG(TSDM, LAST_ILT);\n\tclients[ILT_CLI_TSDM].p_size.reg = ILT_CFG_REG(TSDM, P_SIZE);\n\t \n\tfor (i = 0; i < MAX_ILT_CLIENTS; i++)\n\t\tp_mngr->clients[i].p_size.val = ILT_DEFAULT_HW_P_SIZE;\n\n\tp_mngr->conn_ctx_size = CONN_CXT_SIZE(p_hwfn);\n\n\t \n\tp_mngr->task_type_size[0] = TYPE0_TASK_CXT_SIZE(p_hwfn);\n\tp_mngr->task_type_size[1] = TYPE1_TASK_CXT_SIZE(p_hwfn);\n\n\tif (p_hwfn->cdev->p_iov_info) {\n\t\tp_mngr->vf_count = p_hwfn->cdev->p_iov_info->total_vfs;\n\t\tp_mngr->first_vf_in_pf =\n\t\t\tp_hwfn->cdev->p_iov_info->first_vf_in_pf;\n\t}\n\t \n\tmutex_init(&p_mngr->mutex);\n\n\t \n\tp_hwfn->p_cxt_mngr = p_mngr;\n\n\treturn 0;\n}\n\nint qed_cxt_tables_alloc(struct qed_hwfn *p_hwfn)\n{\n\tint rc;\n\n\t \n\trc = qed_ilt_shadow_alloc(p_hwfn);\n\tif (rc)\n\t\tgoto tables_alloc_fail;\n\n\t \n\trc = qed_cxt_src_t2_alloc(p_hwfn);\n\tif (rc)\n\t\tgoto tables_alloc_fail;\n\n\t \n\trc = qed_cid_map_alloc(p_hwfn);\n\tif (rc)\n\t\tgoto tables_alloc_fail;\n\n\treturn 0;\n\ntables_alloc_fail:\n\tqed_cxt_mngr_free(p_hwfn);\n\treturn rc;\n}\n\nvoid qed_cxt_mngr_free(struct qed_hwfn *p_hwfn)\n{\n\tif (!p_hwfn->p_cxt_mngr)\n\t\treturn;\n\n\tqed_cid_map_free(p_hwfn);\n\tqed_cxt_src_t2_free(p_hwfn);\n\tqed_ilt_shadow_free(p_hwfn);\n\tkfree(p_hwfn->p_cxt_mngr);\n\n\tp_hwfn->p_cxt_mngr = NULL;\n}\n\nvoid qed_cxt_mngr_setup(struct qed_hwfn *p_hwfn)\n{\n\tstruct qed_cxt_mngr *p_mngr = p_hwfn->p_cxt_mngr;\n\tstruct qed_cid_acquired_map *p_map;\n\tstruct qed_conn_type_cfg *p_cfg;\n\tint type;\n\n\t \n\tfor (type = 0; type < MAX_CONN_TYPES; type++) {\n\t\tu32 vf;\n\n\t\tp_cfg = &p_mngr->conn_cfg[type];\n\t\tif (p_cfg->cid_count) {\n\t\t\tp_map = &p_mngr->acquired[type];\n\t\t\tbitmap_zero(p_map->cid_map, p_map->max_count);\n\t\t}\n\n\t\tif (!p_cfg->cids_per_vf)\n\t\t\tcontinue;\n\n\t\tfor (vf = 0; vf < MAX_NUM_VFS; vf++) {\n\t\t\tp_map = &p_mngr->acquired_vf[type][vf];\n\t\t\tbitmap_zero(p_map->cid_map, p_map->max_count);\n\t\t}\n\t}\n}\n\n \n#define CDUC_CXT_SIZE_SHIFT \\\n\tCDU_REG_CID_ADDR_PARAMS_CONTEXT_SIZE_SHIFT\n\n#define CDUC_CXT_SIZE_MASK \\\n\t(CDU_REG_CID_ADDR_PARAMS_CONTEXT_SIZE >> CDUC_CXT_SIZE_SHIFT)\n\n#define CDUC_BLOCK_WASTE_SHIFT \\\n\tCDU_REG_CID_ADDR_PARAMS_BLOCK_WASTE_SHIFT\n\n#define CDUC_BLOCK_WASTE_MASK \\\n\t(CDU_REG_CID_ADDR_PARAMS_BLOCK_WASTE >> CDUC_BLOCK_WASTE_SHIFT)\n\n#define CDUC_NCIB_SHIFT\t\\\n\tCDU_REG_CID_ADDR_PARAMS_NCIB_SHIFT\n\n#define CDUC_NCIB_MASK \\\n\t(CDU_REG_CID_ADDR_PARAMS_NCIB >> CDUC_NCIB_SHIFT)\n\n#define CDUT_TYPE0_CXT_SIZE_SHIFT \\\n\tCDU_REG_SEGMENT0_PARAMS_T0_TID_SIZE_SHIFT\n\n#define CDUT_TYPE0_CXT_SIZE_MASK\t\t\\\n\t(CDU_REG_SEGMENT0_PARAMS_T0_TID_SIZE >>\t\\\n\t CDUT_TYPE0_CXT_SIZE_SHIFT)\n\n#define CDUT_TYPE0_BLOCK_WASTE_SHIFT \\\n\tCDU_REG_SEGMENT0_PARAMS_T0_TID_BLOCK_WASTE_SHIFT\n\n#define CDUT_TYPE0_BLOCK_WASTE_MASK\t\t       \\\n\t(CDU_REG_SEGMENT0_PARAMS_T0_TID_BLOCK_WASTE >> \\\n\t CDUT_TYPE0_BLOCK_WASTE_SHIFT)\n\n#define CDUT_TYPE0_NCIB_SHIFT \\\n\tCDU_REG_SEGMENT0_PARAMS_T0_NUM_TIDS_IN_BLOCK_SHIFT\n\n#define CDUT_TYPE0_NCIB_MASK\t\t\t\t \\\n\t(CDU_REG_SEGMENT0_PARAMS_T0_NUM_TIDS_IN_BLOCK >> \\\n\t CDUT_TYPE0_NCIB_SHIFT)\n\n#define CDUT_TYPE1_CXT_SIZE_SHIFT \\\n\tCDU_REG_SEGMENT1_PARAMS_T1_TID_SIZE_SHIFT\n\n#define CDUT_TYPE1_CXT_SIZE_MASK\t\t\\\n\t(CDU_REG_SEGMENT1_PARAMS_T1_TID_SIZE >>\t\\\n\t CDUT_TYPE1_CXT_SIZE_SHIFT)\n\n#define CDUT_TYPE1_BLOCK_WASTE_SHIFT \\\n\tCDU_REG_SEGMENT1_PARAMS_T1_TID_BLOCK_WASTE_SHIFT\n\n#define CDUT_TYPE1_BLOCK_WASTE_MASK\t\t       \\\n\t(CDU_REG_SEGMENT1_PARAMS_T1_TID_BLOCK_WASTE >> \\\n\t CDUT_TYPE1_BLOCK_WASTE_SHIFT)\n\n#define CDUT_TYPE1_NCIB_SHIFT \\\n\tCDU_REG_SEGMENT1_PARAMS_T1_NUM_TIDS_IN_BLOCK_SHIFT\n\n#define CDUT_TYPE1_NCIB_MASK\t\t\t\t \\\n\t(CDU_REG_SEGMENT1_PARAMS_T1_NUM_TIDS_IN_BLOCK >> \\\n\t CDUT_TYPE1_NCIB_SHIFT)\n\nstatic void qed_cdu_init_common(struct qed_hwfn *p_hwfn)\n{\n\tu32 page_sz, elems_per_page, block_waste, cxt_size, cdu_params = 0;\n\n\t \n\tpage_sz = p_hwfn->p_cxt_mngr->clients[ILT_CLI_CDUC].p_size.val;\n\tcxt_size = CONN_CXT_SIZE(p_hwfn);\n\telems_per_page = ILT_PAGE_IN_BYTES(page_sz) / cxt_size;\n\tblock_waste = ILT_PAGE_IN_BYTES(page_sz) - elems_per_page * cxt_size;\n\n\tSET_FIELD(cdu_params, CDUC_CXT_SIZE, cxt_size);\n\tSET_FIELD(cdu_params, CDUC_BLOCK_WASTE, block_waste);\n\tSET_FIELD(cdu_params, CDUC_NCIB, elems_per_page);\n\tSTORE_RT_REG(p_hwfn, CDU_REG_CID_ADDR_PARAMS_RT_OFFSET, cdu_params);\n\n\t \n\tpage_sz = p_hwfn->p_cxt_mngr->clients[ILT_CLI_CDUT].p_size.val;\n\tcxt_size = p_hwfn->p_cxt_mngr->task_type_size[0];\n\telems_per_page = ILT_PAGE_IN_BYTES(page_sz) / cxt_size;\n\tblock_waste = ILT_PAGE_IN_BYTES(page_sz) - elems_per_page * cxt_size;\n\n\t \n\tcdu_params = 0;\n\tSET_FIELD(cdu_params, CDUT_TYPE0_CXT_SIZE, (cxt_size >> 3));\n\tSET_FIELD(cdu_params, CDUT_TYPE0_BLOCK_WASTE, (block_waste >> 3));\n\tSET_FIELD(cdu_params, CDUT_TYPE0_NCIB, elems_per_page);\n\tSTORE_RT_REG(p_hwfn, CDU_REG_SEGMENT0_PARAMS_RT_OFFSET, cdu_params);\n\n\t \n\tcxt_size = p_hwfn->p_cxt_mngr->task_type_size[1];\n\telems_per_page = ILT_PAGE_IN_BYTES(page_sz) / cxt_size;\n\tblock_waste = ILT_PAGE_IN_BYTES(page_sz) - elems_per_page * cxt_size;\n\n\t \n\tcdu_params = 0;\n\tSET_FIELD(cdu_params, CDUT_TYPE1_CXT_SIZE, (cxt_size >> 3));\n\tSET_FIELD(cdu_params, CDUT_TYPE1_BLOCK_WASTE, (block_waste >> 3));\n\tSET_FIELD(cdu_params, CDUT_TYPE1_NCIB, elems_per_page);\n\tSTORE_RT_REG(p_hwfn, CDU_REG_SEGMENT1_PARAMS_RT_OFFSET, cdu_params);\n}\n\n \n#define CDU_SEG_REG_TYPE_SHIFT          CDU_SEG_TYPE_OFFSET_REG_TYPE_SHIFT\n#define CDU_SEG_REG_TYPE_MASK           0x1\n#define CDU_SEG_REG_OFFSET_SHIFT        0\n#define CDU_SEG_REG_OFFSET_MASK         CDU_SEG_TYPE_OFFSET_REG_OFFSET_MASK\n\nstatic void qed_cdu_init_pf(struct qed_hwfn *p_hwfn)\n{\n\tstruct qed_ilt_client_cfg *p_cli;\n\tstruct qed_tid_seg *p_seg;\n\tu32 cdu_seg_params, offset;\n\tint i;\n\n\tstatic const u32 rt_type_offset_arr[] = {\n\t\tCDU_REG_PF_SEG0_TYPE_OFFSET_RT_OFFSET,\n\t\tCDU_REG_PF_SEG1_TYPE_OFFSET_RT_OFFSET,\n\t\tCDU_REG_PF_SEG2_TYPE_OFFSET_RT_OFFSET,\n\t\tCDU_REG_PF_SEG3_TYPE_OFFSET_RT_OFFSET\n\t};\n\n\tstatic const u32 rt_type_offset_fl_arr[] = {\n\t\tCDU_REG_PF_FL_SEG0_TYPE_OFFSET_RT_OFFSET,\n\t\tCDU_REG_PF_FL_SEG1_TYPE_OFFSET_RT_OFFSET,\n\t\tCDU_REG_PF_FL_SEG2_TYPE_OFFSET_RT_OFFSET,\n\t\tCDU_REG_PF_FL_SEG3_TYPE_OFFSET_RT_OFFSET\n\t};\n\n\tp_cli = &p_hwfn->p_cxt_mngr->clients[ILT_CLI_CDUT];\n\n\t \n\tfor (i = 0; i < NUM_TASK_PF_SEGMENTS; i++) {\n\t\t \n\t\tp_seg = qed_cxt_tid_seg_info(p_hwfn, i);\n\t\tif (!p_seg)\n\t\t\tcontinue;\n\n\t\t \n\t\toffset = (ILT_PAGE_IN_BYTES(p_cli->p_size.val) *\n\t\t\t  (p_cli->pf_blks[CDUT_SEG_BLK(i)].start_line -\n\t\t\t   p_cli->first.val)) / CDUT_SEG_ALIGNMET_IN_BYTES;\n\n\t\tcdu_seg_params = 0;\n\t\tSET_FIELD(cdu_seg_params, CDU_SEG_REG_TYPE, p_seg->type);\n\t\tSET_FIELD(cdu_seg_params, CDU_SEG_REG_OFFSET, offset);\n\t\tSTORE_RT_REG(p_hwfn, rt_type_offset_arr[i], cdu_seg_params);\n\n\t\toffset = (ILT_PAGE_IN_BYTES(p_cli->p_size.val) *\n\t\t\t  (p_cli->pf_blks[CDUT_FL_SEG_BLK(i, PF)].start_line -\n\t\t\t   p_cli->first.val)) / CDUT_SEG_ALIGNMET_IN_BYTES;\n\n\t\tcdu_seg_params = 0;\n\t\tSET_FIELD(cdu_seg_params, CDU_SEG_REG_TYPE, p_seg->type);\n\t\tSET_FIELD(cdu_seg_params, CDU_SEG_REG_OFFSET, offset);\n\t\tSTORE_RT_REG(p_hwfn, rt_type_offset_fl_arr[i], cdu_seg_params);\n\t}\n}\n\nvoid qed_qm_init_pf(struct qed_hwfn *p_hwfn,\n\t\t    struct qed_ptt *p_ptt, bool is_pf_loading)\n{\n\tstruct qed_qm_info *qm_info = &p_hwfn->qm_info;\n\tstruct qed_qm_pf_rt_init_params params;\n\tstruct qed_qm_iids iids;\n\n\tmemset(&iids, 0, sizeof(iids));\n\tqed_cxt_qm_iids(p_hwfn, &iids);\n\n\tmemset(&params, 0, sizeof(params));\n\tparams.port_id = p_hwfn->port_id;\n\tparams.pf_id = p_hwfn->rel_pf_id;\n\tparams.max_phys_tcs_per_port = qm_info->max_phys_tcs_per_port;\n\tparams.is_pf_loading = is_pf_loading;\n\tparams.num_pf_cids = iids.cids;\n\tparams.num_vf_cids = iids.vf_cids;\n\tparams.num_tids = iids.tids;\n\tparams.start_pq = qm_info->start_pq;\n\tparams.num_pf_pqs = qm_info->num_pqs - qm_info->num_vf_pqs;\n\tparams.num_vf_pqs = qm_info->num_vf_pqs;\n\tparams.start_vport = qm_info->start_vport;\n\tparams.num_vports = qm_info->num_vports;\n\tparams.pf_wfq = qm_info->pf_wfq;\n\tparams.pf_rl = qm_info->pf_rl;\n\tparams.pq_params = qm_info->qm_pq_params;\n\tparams.vport_params = qm_info->qm_vport_params;\n\n\tqed_qm_pf_rt_init(p_hwfn, p_ptt, &params);\n}\n\n \nstatic void qed_cm_init_pf(struct qed_hwfn *p_hwfn)\n{\n\t \n\tSTORE_RT_REG(p_hwfn, XCM_REG_CON_PHY_Q3_RT_OFFSET,\n\t\t     qed_get_cm_pq_idx(p_hwfn, PQ_FLAGS_LB));\n}\n\n \nstatic void qed_dq_init_pf(struct qed_hwfn *p_hwfn)\n{\n\tstruct qed_cxt_mngr *p_mngr = p_hwfn->p_cxt_mngr;\n\tu32 dq_pf_max_cid = 0, dq_vf_max_cid = 0;\n\n\tdq_pf_max_cid += (p_mngr->conn_cfg[0].cid_count >> DQ_RANGE_SHIFT);\n\tSTORE_RT_REG(p_hwfn, DORQ_REG_PF_MAX_ICID_0_RT_OFFSET, dq_pf_max_cid);\n\n\tdq_vf_max_cid += (p_mngr->conn_cfg[0].cids_per_vf >> DQ_RANGE_SHIFT);\n\tSTORE_RT_REG(p_hwfn, DORQ_REG_VF_MAX_ICID_0_RT_OFFSET, dq_vf_max_cid);\n\n\tdq_pf_max_cid += (p_mngr->conn_cfg[1].cid_count >> DQ_RANGE_SHIFT);\n\tSTORE_RT_REG(p_hwfn, DORQ_REG_PF_MAX_ICID_1_RT_OFFSET, dq_pf_max_cid);\n\n\tdq_vf_max_cid += (p_mngr->conn_cfg[1].cids_per_vf >> DQ_RANGE_SHIFT);\n\tSTORE_RT_REG(p_hwfn, DORQ_REG_VF_MAX_ICID_1_RT_OFFSET, dq_vf_max_cid);\n\n\tdq_pf_max_cid += (p_mngr->conn_cfg[2].cid_count >> DQ_RANGE_SHIFT);\n\tSTORE_RT_REG(p_hwfn, DORQ_REG_PF_MAX_ICID_2_RT_OFFSET, dq_pf_max_cid);\n\n\tdq_vf_max_cid += (p_mngr->conn_cfg[2].cids_per_vf >> DQ_RANGE_SHIFT);\n\tSTORE_RT_REG(p_hwfn, DORQ_REG_VF_MAX_ICID_2_RT_OFFSET, dq_vf_max_cid);\n\n\tdq_pf_max_cid += (p_mngr->conn_cfg[3].cid_count >> DQ_RANGE_SHIFT);\n\tSTORE_RT_REG(p_hwfn, DORQ_REG_PF_MAX_ICID_3_RT_OFFSET, dq_pf_max_cid);\n\n\tdq_vf_max_cid += (p_mngr->conn_cfg[3].cids_per_vf >> DQ_RANGE_SHIFT);\n\tSTORE_RT_REG(p_hwfn, DORQ_REG_VF_MAX_ICID_3_RT_OFFSET, dq_vf_max_cid);\n\n\tdq_pf_max_cid += (p_mngr->conn_cfg[4].cid_count >> DQ_RANGE_SHIFT);\n\tSTORE_RT_REG(p_hwfn, DORQ_REG_PF_MAX_ICID_4_RT_OFFSET, dq_pf_max_cid);\n\n\tdq_vf_max_cid += (p_mngr->conn_cfg[4].cids_per_vf >> DQ_RANGE_SHIFT);\n\tSTORE_RT_REG(p_hwfn, DORQ_REG_VF_MAX_ICID_4_RT_OFFSET, dq_vf_max_cid);\n\n\tdq_pf_max_cid += (p_mngr->conn_cfg[5].cid_count >> DQ_RANGE_SHIFT);\n\tSTORE_RT_REG(p_hwfn, DORQ_REG_PF_MAX_ICID_5_RT_OFFSET, dq_pf_max_cid);\n\n\tdq_vf_max_cid += (p_mngr->conn_cfg[5].cids_per_vf >> DQ_RANGE_SHIFT);\n\tSTORE_RT_REG(p_hwfn, DORQ_REG_VF_MAX_ICID_5_RT_OFFSET, dq_vf_max_cid);\n\n\t \n\tSTORE_RT_REG(p_hwfn, DORQ_REG_PF_MAX_ICID_6_RT_OFFSET, dq_pf_max_cid);\n\tSTORE_RT_REG(p_hwfn, DORQ_REG_VF_MAX_ICID_6_RT_OFFSET, dq_vf_max_cid);\n\n\tSTORE_RT_REG(p_hwfn, DORQ_REG_PF_MAX_ICID_7_RT_OFFSET, dq_pf_max_cid);\n\tSTORE_RT_REG(p_hwfn, DORQ_REG_VF_MAX_ICID_7_RT_OFFSET, dq_vf_max_cid);\n}\n\nstatic void qed_ilt_bounds_init(struct qed_hwfn *p_hwfn)\n{\n\tstruct qed_ilt_client_cfg *ilt_clients;\n\tint i;\n\n\tilt_clients = p_hwfn->p_cxt_mngr->clients;\n\tfor_each_ilt_valid_client(i, ilt_clients) {\n\t\tSTORE_RT_REG(p_hwfn,\n\t\t\t     ilt_clients[i].first.reg,\n\t\t\t     ilt_clients[i].first.val);\n\t\tSTORE_RT_REG(p_hwfn,\n\t\t\t     ilt_clients[i].last.reg, ilt_clients[i].last.val);\n\t\tSTORE_RT_REG(p_hwfn,\n\t\t\t     ilt_clients[i].p_size.reg,\n\t\t\t     ilt_clients[i].p_size.val);\n\t}\n}\n\nstatic void qed_ilt_vf_bounds_init(struct qed_hwfn *p_hwfn)\n{\n\tstruct qed_ilt_client_cfg *p_cli;\n\tu32 blk_factor;\n\n\t \n\tif (p_hwfn->cdev->p_iov_info) {\n\t\tstruct qed_hw_sriov_info *p_iov = p_hwfn->cdev->p_iov_info;\n\n\t\tSTORE_RT_REG(p_hwfn,\n\t\t\t     PSWRQ2_REG_VF_BASE_RT_OFFSET,\n\t\t\t     p_iov->first_vf_in_pf);\n\t\tSTORE_RT_REG(p_hwfn,\n\t\t\t     PSWRQ2_REG_VF_LAST_ILT_RT_OFFSET,\n\t\t\t     p_iov->first_vf_in_pf + p_iov->total_vfs);\n\t}\n\n\tp_cli = &p_hwfn->p_cxt_mngr->clients[ILT_CLI_CDUC];\n\tblk_factor = ilog2(ILT_PAGE_IN_BYTES(p_cli->p_size.val) >> 10);\n\tif (p_cli->active) {\n\t\tSTORE_RT_REG(p_hwfn,\n\t\t\t     PSWRQ2_REG_CDUC_BLOCKS_FACTOR_RT_OFFSET,\n\t\t\t     blk_factor);\n\t\tSTORE_RT_REG(p_hwfn,\n\t\t\t     PSWRQ2_REG_CDUC_NUMBER_OF_PF_BLOCKS_RT_OFFSET,\n\t\t\t     p_cli->pf_total_lines);\n\t\tSTORE_RT_REG(p_hwfn,\n\t\t\t     PSWRQ2_REG_CDUC_VF_BLOCKS_RT_OFFSET,\n\t\t\t     p_cli->vf_total_lines);\n\t}\n\n\tp_cli = &p_hwfn->p_cxt_mngr->clients[ILT_CLI_CDUT];\n\tblk_factor = ilog2(ILT_PAGE_IN_BYTES(p_cli->p_size.val) >> 10);\n\tif (p_cli->active) {\n\t\tSTORE_RT_REG(p_hwfn,\n\t\t\t     PSWRQ2_REG_CDUT_BLOCKS_FACTOR_RT_OFFSET,\n\t\t\t     blk_factor);\n\t\tSTORE_RT_REG(p_hwfn,\n\t\t\t     PSWRQ2_REG_CDUT_NUMBER_OF_PF_BLOCKS_RT_OFFSET,\n\t\t\t     p_cli->pf_total_lines);\n\t\tSTORE_RT_REG(p_hwfn,\n\t\t\t     PSWRQ2_REG_CDUT_VF_BLOCKS_RT_OFFSET,\n\t\t\t     p_cli->vf_total_lines);\n\t}\n\n\tp_cli = &p_hwfn->p_cxt_mngr->clients[ILT_CLI_TM];\n\tblk_factor = ilog2(ILT_PAGE_IN_BYTES(p_cli->p_size.val) >> 10);\n\tif (p_cli->active) {\n\t\tSTORE_RT_REG(p_hwfn,\n\t\t\t     PSWRQ2_REG_TM_BLOCKS_FACTOR_RT_OFFSET, blk_factor);\n\t\tSTORE_RT_REG(p_hwfn,\n\t\t\t     PSWRQ2_REG_TM_NUMBER_OF_PF_BLOCKS_RT_OFFSET,\n\t\t\t     p_cli->pf_total_lines);\n\t\tSTORE_RT_REG(p_hwfn,\n\t\t\t     PSWRQ2_REG_TM_VF_BLOCKS_RT_OFFSET,\n\t\t\t     p_cli->vf_total_lines);\n\t}\n}\n\n \nstatic void qed_ilt_init_pf(struct qed_hwfn *p_hwfn)\n{\n\tstruct qed_ilt_client_cfg *clients;\n\tstruct qed_cxt_mngr *p_mngr;\n\tstruct phys_mem_desc *p_shdw;\n\tu32 line, rt_offst, i;\n\n\tqed_ilt_bounds_init(p_hwfn);\n\tqed_ilt_vf_bounds_init(p_hwfn);\n\n\tp_mngr = p_hwfn->p_cxt_mngr;\n\tp_shdw = p_mngr->ilt_shadow;\n\tclients = p_hwfn->p_cxt_mngr->clients;\n\n\tfor_each_ilt_valid_client(i, clients) {\n\t\t \n\t\tline = clients[i].first.val - p_mngr->pf_start_line;\n\t\trt_offst = PSWRQ2_REG_ILT_MEMORY_RT_OFFSET +\n\t\t\t   clients[i].first.val * ILT_ENTRY_IN_REGS;\n\n\t\tfor (; line <= clients[i].last.val - p_mngr->pf_start_line;\n\t\t     line++, rt_offst += ILT_ENTRY_IN_REGS) {\n\t\t\tu64 ilt_hw_entry = 0;\n\n\t\t\t \n\t\t\tif (p_shdw[line].virt_addr) {\n\t\t\t\tSET_FIELD(ilt_hw_entry, ILT_ENTRY_VALID, 1ULL);\n\t\t\t\tSET_FIELD(ilt_hw_entry, ILT_ENTRY_PHY_ADDR,\n\t\t\t\t\t  (p_shdw[line].phys_addr >> 12));\n\n\t\t\t\tDP_VERBOSE(p_hwfn, QED_MSG_ILT,\n\t\t\t\t\t   \"Setting RT[0x%08x] from ILT[0x%08x] [Client is %d] to Physical addr: 0x%llx\\n\",\n\t\t\t\t\t   rt_offst, line, i,\n\t\t\t\t\t   (u64)(p_shdw[line].phys_addr >> 12));\n\t\t\t}\n\n\t\t\tSTORE_RT_REG_AGG(p_hwfn, rt_offst, ilt_hw_entry);\n\t\t}\n\t}\n}\n\n \nstatic void qed_src_init_pf(struct qed_hwfn *p_hwfn)\n{\n\tstruct qed_cxt_mngr *p_mngr = p_hwfn->p_cxt_mngr;\n\tu32 rounded_conn_num, conn_num, conn_max;\n\tstruct qed_src_iids src_iids;\n\n\tmemset(&src_iids, 0, sizeof(src_iids));\n\tqed_cxt_src_iids(p_mngr, &src_iids);\n\tconn_num = src_iids.pf_cids + src_iids.per_vf_cids * p_mngr->vf_count;\n\tif (!conn_num)\n\t\treturn;\n\n\tconn_max = max_t(u32, conn_num, SRC_MIN_NUM_ELEMS);\n\trounded_conn_num = roundup_pow_of_two(conn_max);\n\n\tSTORE_RT_REG(p_hwfn, SRC_REG_COUNTFREE_RT_OFFSET, conn_num);\n\tSTORE_RT_REG(p_hwfn, SRC_REG_NUMBER_HASH_BITS_RT_OFFSET,\n\t\t     ilog2(rounded_conn_num));\n\n\tSTORE_RT_REG_AGG(p_hwfn, SRC_REG_FIRSTFREE_RT_OFFSET,\n\t\t\t p_hwfn->p_cxt_mngr->src_t2.first_free);\n\tSTORE_RT_REG_AGG(p_hwfn, SRC_REG_LASTFREE_RT_OFFSET,\n\t\t\t p_hwfn->p_cxt_mngr->src_t2.last_free);\n}\n\n \n#define TM_CFG_NUM_IDS_SHIFT            0\n#define TM_CFG_NUM_IDS_MASK             0xFFFFULL\n#define TM_CFG_PRE_SCAN_OFFSET_SHIFT    16\n#define TM_CFG_PRE_SCAN_OFFSET_MASK     0x1FFULL\n#define TM_CFG_PARENT_PF_SHIFT          25\n#define TM_CFG_PARENT_PF_MASK           0x7ULL\n\n#define TM_CFG_CID_PRE_SCAN_ROWS_SHIFT  30\n#define TM_CFG_CID_PRE_SCAN_ROWS_MASK   0x1FFULL\n\n#define TM_CFG_TID_OFFSET_SHIFT         30\n#define TM_CFG_TID_OFFSET_MASK          0x7FFFFULL\n#define TM_CFG_TID_PRE_SCAN_ROWS_SHIFT  49\n#define TM_CFG_TID_PRE_SCAN_ROWS_MASK   0x1FFULL\n\nstatic void qed_tm_init_pf(struct qed_hwfn *p_hwfn)\n{\n\tstruct qed_cxt_mngr *p_mngr = p_hwfn->p_cxt_mngr;\n\tu32 active_seg_mask = 0, tm_offset, rt_reg;\n\tstruct qed_tm_iids tm_iids;\n\tu64 cfg_word;\n\tu8 i;\n\n\tmemset(&tm_iids, 0, sizeof(tm_iids));\n\tqed_cxt_tm_iids(p_hwfn, p_mngr, &tm_iids);\n\n\t \n\n\t \n\tfor (i = 0; i < p_mngr->vf_count; i++) {\n\t\tcfg_word = 0;\n\t\tSET_FIELD(cfg_word, TM_CFG_NUM_IDS, tm_iids.per_vf_cids);\n\t\tSET_FIELD(cfg_word, TM_CFG_PRE_SCAN_OFFSET, 0);\n\t\tSET_FIELD(cfg_word, TM_CFG_PARENT_PF, p_hwfn->rel_pf_id);\n\t\tSET_FIELD(cfg_word, TM_CFG_CID_PRE_SCAN_ROWS, 0);\n\t\trt_reg = TM_REG_CONFIG_CONN_MEM_RT_OFFSET +\n\t\t    (sizeof(cfg_word) / sizeof(u32)) *\n\t\t    (p_hwfn->cdev->p_iov_info->first_vf_in_pf + i);\n\t\tSTORE_RT_REG_AGG(p_hwfn, rt_reg, cfg_word);\n\t}\n\n\tcfg_word = 0;\n\tSET_FIELD(cfg_word, TM_CFG_NUM_IDS, tm_iids.pf_cids);\n\tSET_FIELD(cfg_word, TM_CFG_PRE_SCAN_OFFSET, 0);\n\tSET_FIELD(cfg_word, TM_CFG_PARENT_PF, 0);\t \n\tSET_FIELD(cfg_word, TM_CFG_CID_PRE_SCAN_ROWS, 0);\t \n\n\trt_reg = TM_REG_CONFIG_CONN_MEM_RT_OFFSET +\n\t    (sizeof(cfg_word) / sizeof(u32)) *\n\t    (NUM_OF_VFS(p_hwfn->cdev) + p_hwfn->rel_pf_id);\n\tSTORE_RT_REG_AGG(p_hwfn, rt_reg, cfg_word);\n\n\t \n\tSTORE_RT_REG(p_hwfn, TM_REG_PF_ENABLE_CONN_RT_OFFSET,\n\t\t     tm_iids.pf_cids ? 0x1 : 0x0);\n\n\t \n\n\ttm_offset = tm_iids.per_vf_cids;\n\n\t \n\tfor (i = 0; i < p_mngr->vf_count; i++) {\n\t\tcfg_word = 0;\n\t\tSET_FIELD(cfg_word, TM_CFG_NUM_IDS, tm_iids.per_vf_tids);\n\t\tSET_FIELD(cfg_word, TM_CFG_PRE_SCAN_OFFSET, 0);\n\t\tSET_FIELD(cfg_word, TM_CFG_PARENT_PF, p_hwfn->rel_pf_id);\n\t\tSET_FIELD(cfg_word, TM_CFG_TID_OFFSET, tm_offset);\n\t\tSET_FIELD(cfg_word, TM_CFG_TID_PRE_SCAN_ROWS, (u64) 0);\n\n\t\trt_reg = TM_REG_CONFIG_TASK_MEM_RT_OFFSET +\n\t\t    (sizeof(cfg_word) / sizeof(u32)) *\n\t\t    (p_hwfn->cdev->p_iov_info->first_vf_in_pf + i);\n\n\t\tSTORE_RT_REG_AGG(p_hwfn, rt_reg, cfg_word);\n\t}\n\n\ttm_offset = tm_iids.pf_cids;\n\tfor (i = 0; i < NUM_TASK_PF_SEGMENTS; i++) {\n\t\tcfg_word = 0;\n\t\tSET_FIELD(cfg_word, TM_CFG_NUM_IDS, tm_iids.pf_tids[i]);\n\t\tSET_FIELD(cfg_word, TM_CFG_PRE_SCAN_OFFSET, 0);\n\t\tSET_FIELD(cfg_word, TM_CFG_PARENT_PF, 0);\n\t\tSET_FIELD(cfg_word, TM_CFG_TID_OFFSET, tm_offset);\n\t\tSET_FIELD(cfg_word, TM_CFG_TID_PRE_SCAN_ROWS, (u64) 0);\n\n\t\trt_reg = TM_REG_CONFIG_TASK_MEM_RT_OFFSET +\n\t\t    (sizeof(cfg_word) / sizeof(u32)) *\n\t\t    (NUM_OF_VFS(p_hwfn->cdev) +\n\t\t     p_hwfn->rel_pf_id * NUM_TASK_PF_SEGMENTS + i);\n\n\t\tSTORE_RT_REG_AGG(p_hwfn, rt_reg, cfg_word);\n\t\tactive_seg_mask |= (tm_iids.pf_tids[i] ? BIT(i) : 0);\n\n\t\ttm_offset += tm_iids.pf_tids[i];\n\t}\n\n\tif (QED_IS_RDMA_PERSONALITY(p_hwfn))\n\t\tactive_seg_mask = 0;\n\n\tSTORE_RT_REG(p_hwfn, TM_REG_PF_ENABLE_TASK_RT_OFFSET, active_seg_mask);\n\n\t \n}\n\nstatic void qed_prs_init_common(struct qed_hwfn *p_hwfn)\n{\n\tif ((p_hwfn->hw_info.personality == QED_PCI_FCOE) &&\n\t    p_hwfn->pf_params.fcoe_pf_params.is_target)\n\t\tSTORE_RT_REG(p_hwfn,\n\t\t\t     PRS_REG_SEARCH_RESP_INITIATOR_TYPE_RT_OFFSET, 0);\n}\n\nstatic void qed_prs_init_pf(struct qed_hwfn *p_hwfn)\n{\n\tstruct qed_cxt_mngr *p_mngr = p_hwfn->p_cxt_mngr;\n\tstruct qed_conn_type_cfg *p_fcoe;\n\tstruct qed_tid_seg *p_tid;\n\n\tp_fcoe = &p_mngr->conn_cfg[PROTOCOLID_FCOE];\n\n\t \n\tif (!p_fcoe->cid_count)\n\t\treturn;\n\n\tp_tid = &p_fcoe->tid_seg[QED_CXT_FCOE_TID_SEG];\n\tif (p_hwfn->pf_params.fcoe_pf_params.is_target) {\n\t\tSTORE_RT_REG_AGG(p_hwfn,\n\t\t\t\t PRS_REG_TASK_ID_MAX_TARGET_PF_RT_OFFSET,\n\t\t\t\t p_tid->count);\n\t} else {\n\t\tSTORE_RT_REG_AGG(p_hwfn,\n\t\t\t\t PRS_REG_TASK_ID_MAX_INITIATOR_PF_RT_OFFSET,\n\t\t\t\t p_tid->count);\n\t}\n}\n\nvoid qed_cxt_hw_init_common(struct qed_hwfn *p_hwfn)\n{\n\tqed_cdu_init_common(p_hwfn);\n\tqed_prs_init_common(p_hwfn);\n}\n\nvoid qed_cxt_hw_init_pf(struct qed_hwfn *p_hwfn, struct qed_ptt *p_ptt)\n{\n\tqed_qm_init_pf(p_hwfn, p_ptt, true);\n\tqed_cm_init_pf(p_hwfn);\n\tqed_dq_init_pf(p_hwfn);\n\tqed_cdu_init_pf(p_hwfn);\n\tqed_ilt_init_pf(p_hwfn);\n\tqed_src_init_pf(p_hwfn);\n\tqed_tm_init_pf(p_hwfn);\n\tqed_prs_init_pf(p_hwfn);\n}\n\nint _qed_cxt_acquire_cid(struct qed_hwfn *p_hwfn,\n\t\t\t enum protocol_type type, u32 *p_cid, u8 vfid)\n{\n\tstruct qed_cxt_mngr *p_mngr = p_hwfn->p_cxt_mngr;\n\tstruct qed_cid_acquired_map *p_map;\n\tu32 rel_cid;\n\n\tif (type >= MAX_CONN_TYPES) {\n\t\tDP_NOTICE(p_hwfn, \"Invalid protocol type %d\", type);\n\t\treturn -EINVAL;\n\t}\n\n\tif (vfid >= MAX_NUM_VFS && vfid != QED_CXT_PF_CID) {\n\t\tDP_NOTICE(p_hwfn, \"VF [%02x] is out of range\\n\", vfid);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (vfid == QED_CXT_PF_CID)\n\t\tp_map = &p_mngr->acquired[type];\n\telse\n\t\tp_map = &p_mngr->acquired_vf[type][vfid];\n\n\tif (!p_map->cid_map) {\n\t\tDP_NOTICE(p_hwfn, \"Invalid protocol type %d\", type);\n\t\treturn -EINVAL;\n\t}\n\n\trel_cid = find_first_zero_bit(p_map->cid_map, p_map->max_count);\n\n\tif (rel_cid >= p_map->max_count) {\n\t\tDP_NOTICE(p_hwfn, \"no CID available for protocol %d\\n\", type);\n\t\treturn -EINVAL;\n\t}\n\n\t__set_bit(rel_cid, p_map->cid_map);\n\n\t*p_cid = rel_cid + p_map->start_cid;\n\n\tDP_VERBOSE(p_hwfn, QED_MSG_CXT,\n\t\t   \"Acquired cid 0x%08x [rel. %08x] vfid %02x type %d\\n\",\n\t\t   *p_cid, rel_cid, vfid, type);\n\n\treturn 0;\n}\n\nint qed_cxt_acquire_cid(struct qed_hwfn *p_hwfn,\n\t\t\tenum protocol_type type, u32 *p_cid)\n{\n\treturn _qed_cxt_acquire_cid(p_hwfn, type, p_cid, QED_CXT_PF_CID);\n}\n\nstatic bool qed_cxt_test_cid_acquired(struct qed_hwfn *p_hwfn,\n\t\t\t\t      u32 cid,\n\t\t\t\t      u8 vfid,\n\t\t\t\t      enum protocol_type *p_type,\n\t\t\t\t      struct qed_cid_acquired_map **pp_map)\n{\n\tstruct qed_cxt_mngr *p_mngr = p_hwfn->p_cxt_mngr;\n\tu32 rel_cid;\n\n\t \n\tfor (*p_type = 0; *p_type < MAX_CONN_TYPES; (*p_type)++) {\n\t\tif (vfid == QED_CXT_PF_CID)\n\t\t\t*pp_map = &p_mngr->acquired[*p_type];\n\t\telse\n\t\t\t*pp_map = &p_mngr->acquired_vf[*p_type][vfid];\n\n\t\tif (!((*pp_map)->cid_map))\n\t\t\tcontinue;\n\t\tif (cid >= (*pp_map)->start_cid &&\n\t\t    cid < (*pp_map)->start_cid + (*pp_map)->max_count)\n\t\t\tbreak;\n\t}\n\n\tif (*p_type == MAX_CONN_TYPES) {\n\t\tDP_NOTICE(p_hwfn, \"Invalid CID %d vfid %02x\", cid, vfid);\n\t\tgoto fail;\n\t}\n\n\trel_cid = cid - (*pp_map)->start_cid;\n\tif (!test_bit(rel_cid, (*pp_map)->cid_map)) {\n\t\tDP_NOTICE(p_hwfn, \"CID %d [vifd %02x] not acquired\",\n\t\t\t  cid, vfid);\n\t\tgoto fail;\n\t}\n\n\treturn true;\nfail:\n\t*p_type = MAX_CONN_TYPES;\n\t*pp_map = NULL;\n\treturn false;\n}\n\nvoid _qed_cxt_release_cid(struct qed_hwfn *p_hwfn, u32 cid, u8 vfid)\n{\n\tstruct qed_cid_acquired_map *p_map = NULL;\n\tenum protocol_type type;\n\tbool b_acquired;\n\tu32 rel_cid;\n\n\tif (vfid != QED_CXT_PF_CID && vfid > MAX_NUM_VFS) {\n\t\tDP_NOTICE(p_hwfn,\n\t\t\t  \"Trying to return incorrect CID belonging to VF %02x\\n\",\n\t\t\t  vfid);\n\t\treturn;\n\t}\n\n\t \n\tb_acquired = qed_cxt_test_cid_acquired(p_hwfn, cid, vfid,\n\t\t\t\t\t       &type, &p_map);\n\n\tif (!b_acquired)\n\t\treturn;\n\n\trel_cid = cid - p_map->start_cid;\n\tclear_bit(rel_cid, p_map->cid_map);\n\n\tDP_VERBOSE(p_hwfn, QED_MSG_CXT,\n\t\t   \"Released CID 0x%08x [rel. %08x] vfid %02x type %d\\n\",\n\t\t   cid, rel_cid, vfid, type);\n}\n\nvoid qed_cxt_release_cid(struct qed_hwfn *p_hwfn, u32 cid)\n{\n\t_qed_cxt_release_cid(p_hwfn, cid, QED_CXT_PF_CID);\n}\n\nint qed_cxt_get_cid_info(struct qed_hwfn *p_hwfn, struct qed_cxt_info *p_info)\n{\n\tstruct qed_cxt_mngr *p_mngr = p_hwfn->p_cxt_mngr;\n\tstruct qed_cid_acquired_map *p_map = NULL;\n\tu32 conn_cxt_size, hw_p_size, cxts_per_p, line;\n\tenum protocol_type type;\n\tbool b_acquired;\n\n\t \n\tb_acquired = qed_cxt_test_cid_acquired(p_hwfn, p_info->iid,\n\t\t\t\t\t       QED_CXT_PF_CID, &type, &p_map);\n\n\tif (!b_acquired)\n\t\treturn -EINVAL;\n\n\t \n\tp_info->type = type;\n\n\t \n\thw_p_size = p_hwfn->p_cxt_mngr->clients[ILT_CLI_CDUC].p_size.val;\n\n\tconn_cxt_size = CONN_CXT_SIZE(p_hwfn);\n\tcxts_per_p = ILT_PAGE_IN_BYTES(hw_p_size) / conn_cxt_size;\n\tline = p_info->iid / cxts_per_p;\n\n\t \n\tif (!p_mngr->ilt_shadow[line].virt_addr)\n\t\treturn -EINVAL;\n\n\tp_info->p_cxt = p_mngr->ilt_shadow[line].virt_addr +\n\t\t\tp_info->iid % cxts_per_p * conn_cxt_size;\n\n\tDP_VERBOSE(p_hwfn, (QED_MSG_ILT | QED_MSG_CXT),\n\t\t   \"Accessing ILT shadow[%d]: CXT pointer is at %p (for iid %d)\\n\",\n\t\t   p_info->iid / cxts_per_p, p_info->p_cxt, p_info->iid);\n\n\treturn 0;\n}\n\nstatic void qed_rdma_set_pf_params(struct qed_hwfn *p_hwfn,\n\t\t\t\t   struct qed_rdma_pf_params *p_params,\n\t\t\t\t   u32 num_tasks)\n{\n\tu32 num_cons, num_qps;\n\tenum protocol_type proto;\n\n\tif (p_hwfn->mcp_info->func_info.protocol == QED_PCI_ETH_RDMA) {\n\t\tDP_VERBOSE(p_hwfn, QED_MSG_SP,\n\t\t\t   \"Current day drivers don't support RoCE & iWARP simultaneously on the same PF. Default to RoCE-only\\n\");\n\t\tp_hwfn->hw_info.personality = QED_PCI_ETH_ROCE;\n\t}\n\n\tswitch (p_hwfn->hw_info.personality) {\n\tcase QED_PCI_ETH_IWARP:\n\t\t \n\t\tnum_cons = min_t(u32, IWARP_MAX_QPS, p_params->num_qps);\n\t\tproto = PROTOCOLID_IWARP;\n\t\tbreak;\n\tcase QED_PCI_ETH_ROCE:\n\t\tnum_qps = min_t(u32, ROCE_MAX_QPS, p_params->num_qps);\n\t\tnum_cons = num_qps * 2;\t \n\t\tproto = PROTOCOLID_ROCE;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tif (num_cons && num_tasks) {\n\t\tu32 num_srqs, num_xrc_srqs;\n\n\t\tqed_cxt_set_proto_cid_count(p_hwfn, proto, num_cons, 0);\n\n\t\t \n\t\tqed_cxt_set_proto_tid_count(p_hwfn, PROTOCOLID_ROCE,\n\t\t\t\t\t    QED_CXT_ROCE_TID_SEG, 1,\n\t\t\t\t\t    num_tasks, false);\n\n\t\tnum_srqs = min_t(u32, QED_RDMA_MAX_SRQS, p_params->num_srqs);\n\n\t\t \n\t\tnum_xrc_srqs = qed_cxt_xrc_srqs_per_page(p_hwfn);\n\n\t\tqed_cxt_set_srq_count(p_hwfn, num_srqs, num_xrc_srqs);\n\t} else {\n\t\tDP_INFO(p_hwfn->cdev,\n\t\t\t\"RDMA personality used without setting params!\\n\");\n\t}\n}\n\nint qed_cxt_set_pf_params(struct qed_hwfn *p_hwfn, u32 rdma_tasks)\n{\n\t \n\tu32 core_cids = 1;  \n\n\tif (p_hwfn->using_ll2)\n\t\tcore_cids += 4;\n\tqed_cxt_set_proto_cid_count(p_hwfn, PROTOCOLID_CORE, core_cids, 0);\n\n\tswitch (p_hwfn->hw_info.personality) {\n\tcase QED_PCI_ETH_RDMA:\n\tcase QED_PCI_ETH_IWARP:\n\tcase QED_PCI_ETH_ROCE:\n\t{\n\t\t\tqed_rdma_set_pf_params(p_hwfn,\n\t\t\t\t\t       &p_hwfn->\n\t\t\t\t\t       pf_params.rdma_pf_params,\n\t\t\t\t\t       rdma_tasks);\n\t\t \n\t}\n\t\tfallthrough;\n\tcase QED_PCI_ETH:\n\t{\n\t\tstruct qed_eth_pf_params *p_params =\n\t\t    &p_hwfn->pf_params.eth_pf_params;\n\n\t\tif (!p_params->num_vf_cons)\n\t\t\tp_params->num_vf_cons =\n\t\t\t    ETH_PF_PARAMS_VF_CONS_DEFAULT;\n\t\tqed_cxt_set_proto_cid_count(p_hwfn, PROTOCOLID_ETH,\n\t\t\t\t\t    p_params->num_cons,\n\t\t\t\t\t    p_params->num_vf_cons);\n\t\tp_hwfn->p_cxt_mngr->arfs_count = p_params->num_arfs_filters;\n\t\tbreak;\n\t}\n\tcase QED_PCI_FCOE:\n\t{\n\t\tstruct qed_fcoe_pf_params *p_params;\n\n\t\tp_params = &p_hwfn->pf_params.fcoe_pf_params;\n\n\t\tif (p_params->num_cons && p_params->num_tasks) {\n\t\t\tqed_cxt_set_proto_cid_count(p_hwfn,\n\t\t\t\t\t\t    PROTOCOLID_FCOE,\n\t\t\t\t\t\t    p_params->num_cons,\n\t\t\t\t\t\t    0);\n\t\t\tqed_cxt_set_proto_tid_count(p_hwfn, PROTOCOLID_FCOE,\n\t\t\t\t\t\t    QED_CXT_FCOE_TID_SEG, 0,\n\t\t\t\t\t\t    p_params->num_tasks, true);\n\t\t} else {\n\t\t\tDP_INFO(p_hwfn->cdev,\n\t\t\t\t\"Fcoe personality used without setting params!\\n\");\n\t\t}\n\t\tbreak;\n\t}\n\tcase QED_PCI_ISCSI:\n\t{\n\t\tstruct qed_iscsi_pf_params *p_params;\n\n\t\tp_params = &p_hwfn->pf_params.iscsi_pf_params;\n\n\t\tif (p_params->num_cons && p_params->num_tasks) {\n\t\t\tqed_cxt_set_proto_cid_count(p_hwfn,\n\t\t\t\t\t\t    PROTOCOLID_TCP_ULP,\n\t\t\t\t\t\t    p_params->num_cons,\n\t\t\t\t\t\t    0);\n\t\t\tqed_cxt_set_proto_tid_count(p_hwfn,\n\t\t\t\t\t\t    PROTOCOLID_TCP_ULP,\n\t\t\t\t\t\t    QED_CXT_TCP_ULP_TID_SEG,\n\t\t\t\t\t\t    0,\n\t\t\t\t\t\t    p_params->num_tasks,\n\t\t\t\t\t\t    true);\n\t\t} else {\n\t\t\tDP_INFO(p_hwfn->cdev,\n\t\t\t\t\"Iscsi personality used without setting params!\\n\");\n\t\t}\n\t\tbreak;\n\t}\n\tcase QED_PCI_NVMETCP:\n\t{\n\t\tstruct qed_nvmetcp_pf_params *p_params;\n\n\t\tp_params = &p_hwfn->pf_params.nvmetcp_pf_params;\n\n\t\tif (p_params->num_cons && p_params->num_tasks) {\n\t\t\tqed_cxt_set_proto_cid_count(p_hwfn,\n\t\t\t\t\t\t    PROTOCOLID_TCP_ULP,\n\t\t\t\t\t\t    p_params->num_cons,\n\t\t\t\t\t\t    0);\n\t\t\tqed_cxt_set_proto_tid_count(p_hwfn,\n\t\t\t\t\t\t    PROTOCOLID_TCP_ULP,\n\t\t\t\t\t\t    QED_CXT_TCP_ULP_TID_SEG,\n\t\t\t\t\t\t    0,\n\t\t\t\t\t\t    p_params->num_tasks,\n\t\t\t\t\t\t    true);\n\t\t} else {\n\t\t\tDP_INFO(p_hwfn->cdev,\n\t\t\t\t\"NvmeTCP personality used without setting params!\\n\");\n\t\t}\n\t\tbreak;\n\t}\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nint qed_cxt_get_tid_mem_info(struct qed_hwfn *p_hwfn,\n\t\t\t     struct qed_tid_mem *p_info)\n{\n\tstruct qed_cxt_mngr *p_mngr = p_hwfn->p_cxt_mngr;\n\tu32 proto, seg, total_lines, i, shadow_line;\n\tstruct qed_ilt_client_cfg *p_cli;\n\tstruct qed_ilt_cli_blk *p_fl_seg;\n\tstruct qed_tid_seg *p_seg_info;\n\n\t \n\tswitch (p_hwfn->hw_info.personality) {\n\tcase QED_PCI_FCOE:\n\t\tproto = PROTOCOLID_FCOE;\n\t\tseg = QED_CXT_FCOE_TID_SEG;\n\t\tbreak;\n\tcase QED_PCI_ISCSI:\n\tcase QED_PCI_NVMETCP:\n\t\tproto = PROTOCOLID_TCP_ULP;\n\t\tseg = QED_CXT_TCP_ULP_TID_SEG;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tp_cli = &p_mngr->clients[ILT_CLI_CDUT];\n\tif (!p_cli->active)\n\t\treturn -EINVAL;\n\n\tp_seg_info = &p_mngr->conn_cfg[proto].tid_seg[seg];\n\tif (!p_seg_info->has_fl_mem)\n\t\treturn -EINVAL;\n\n\tp_fl_seg = &p_cli->pf_blks[CDUT_FL_SEG_BLK(seg, PF)];\n\ttotal_lines = DIV_ROUND_UP(p_fl_seg->total_size,\n\t\t\t\t   p_fl_seg->real_size_in_page);\n\n\tfor (i = 0; i < total_lines; i++) {\n\t\tshadow_line = i + p_fl_seg->start_line -\n\t\t    p_hwfn->p_cxt_mngr->pf_start_line;\n\t\tp_info->blocks[i] = p_mngr->ilt_shadow[shadow_line].virt_addr;\n\t}\n\tp_info->waste = ILT_PAGE_IN_BYTES(p_cli->p_size.val) -\n\t    p_fl_seg->real_size_in_page;\n\tp_info->tid_size = p_mngr->task_type_size[p_seg_info->type];\n\tp_info->num_tids_per_block = p_fl_seg->real_size_in_page /\n\t    p_info->tid_size;\n\n\treturn 0;\n}\n\n \nint\nqed_cxt_dynamic_ilt_alloc(struct qed_hwfn *p_hwfn,\n\t\t\t  enum qed_cxt_elem_type elem_type, u32 iid)\n{\n\tu32 reg_offset, shadow_line, elem_size, hw_p_size, elems_per_p, line;\n\tstruct tdif_task_context *tdif_context;\n\tstruct qed_ilt_client_cfg *p_cli;\n\tstruct qed_ilt_cli_blk *p_blk;\n\tstruct qed_ptt *p_ptt;\n\tdma_addr_t p_phys;\n\tu64 ilt_hw_entry;\n\tvoid *p_virt;\n\tu32 flags1;\n\tint rc = 0;\n\n\tswitch (elem_type) {\n\tcase QED_ELEM_CXT:\n\t\tp_cli = &p_hwfn->p_cxt_mngr->clients[ILT_CLI_CDUC];\n\t\telem_size = CONN_CXT_SIZE(p_hwfn);\n\t\tp_blk = &p_cli->pf_blks[CDUC_BLK];\n\t\tbreak;\n\tcase QED_ELEM_SRQ:\n\t\t \n\t\tiid += p_hwfn->p_cxt_mngr->xrc_srq_count;\n\t\tp_cli = &p_hwfn->p_cxt_mngr->clients[ILT_CLI_TSDM];\n\t\telem_size = SRQ_CXT_SIZE;\n\t\tp_blk = &p_cli->pf_blks[SRQ_BLK];\n\t\tbreak;\n\tcase QED_ELEM_XRC_SRQ:\n\t\tp_cli = &p_hwfn->p_cxt_mngr->clients[ILT_CLI_TSDM];\n\t\telem_size = XRC_SRQ_CXT_SIZE;\n\t\tp_blk = &p_cli->pf_blks[SRQ_BLK];\n\t\tbreak;\n\tcase QED_ELEM_TASK:\n\t\tp_cli = &p_hwfn->p_cxt_mngr->clients[ILT_CLI_CDUT];\n\t\telem_size = TYPE1_TASK_CXT_SIZE(p_hwfn);\n\t\tp_blk = &p_cli->pf_blks[CDUT_SEG_BLK(QED_CXT_ROCE_TID_SEG)];\n\t\tbreak;\n\tdefault:\n\t\tDP_NOTICE(p_hwfn, \"-EOPNOTSUPP elem type = %d\", elem_type);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t \n\thw_p_size = p_cli->p_size.val;\n\telems_per_p = ILT_PAGE_IN_BYTES(hw_p_size) / elem_size;\n\tline = p_blk->start_line + (iid / elems_per_p);\n\tshadow_line = line - p_hwfn->p_cxt_mngr->pf_start_line;\n\n\t \n\n\tmutex_lock(&p_hwfn->p_cxt_mngr->mutex);\n\n\tif (p_hwfn->p_cxt_mngr->ilt_shadow[shadow_line].virt_addr)\n\t\tgoto out0;\n\n\tp_ptt = qed_ptt_acquire(p_hwfn);\n\tif (!p_ptt) {\n\t\tDP_NOTICE(p_hwfn,\n\t\t\t  \"QED_TIME_OUT on ptt acquire - dynamic allocation\");\n\t\trc = -EBUSY;\n\t\tgoto out0;\n\t}\n\n\tp_virt = dma_alloc_coherent(&p_hwfn->cdev->pdev->dev,\n\t\t\t\t    p_blk->real_size_in_page, &p_phys,\n\t\t\t\t    GFP_KERNEL);\n\tif (!p_virt) {\n\t\trc = -ENOMEM;\n\t\tgoto out1;\n\t}\n\n\t \n\tif (elem_type == QED_ELEM_TASK) {\n\t\tu32 elem_i;\n\t\tu8 *elem_start = (u8 *)p_virt;\n\t\tunion type1_task_context *elem;\n\n\t\tfor (elem_i = 0; elem_i < elems_per_p; elem_i++) {\n\t\t\telem = (union type1_task_context *)elem_start;\n\t\t\ttdif_context = &elem->roce_ctx.tdif_context;\n\n\t\t\tflags1 = le32_to_cpu(tdif_context->flags1);\n\t\t\tSET_FIELD(flags1, TDIF_TASK_CONTEXT_REF_TAG_MASK, 0xf);\n\t\t\ttdif_context->flags1 = cpu_to_le32(flags1);\n\n\t\t\telem_start += TYPE1_TASK_CXT_SIZE(p_hwfn);\n\t\t}\n\t}\n\n\tp_hwfn->p_cxt_mngr->ilt_shadow[shadow_line].virt_addr = p_virt;\n\tp_hwfn->p_cxt_mngr->ilt_shadow[shadow_line].phys_addr = p_phys;\n\tp_hwfn->p_cxt_mngr->ilt_shadow[shadow_line].size =\n\t    p_blk->real_size_in_page;\n\n\t \n\treg_offset = PSWRQ2_REG_ILT_MEMORY +\n\t    (line * ILT_REG_SIZE_IN_BYTES * ILT_ENTRY_IN_REGS);\n\n\tilt_hw_entry = 0;\n\tSET_FIELD(ilt_hw_entry, ILT_ENTRY_VALID, 1ULL);\n\tSET_FIELD(ilt_hw_entry, ILT_ENTRY_PHY_ADDR,\n\t\t  (p_hwfn->p_cxt_mngr->ilt_shadow[shadow_line].phys_addr\n\t\t   >> 12));\n\n\t \n\tqed_dmae_host2grc(p_hwfn, p_ptt, (u64) (uintptr_t)&ilt_hw_entry,\n\t\t\t  reg_offset, sizeof(ilt_hw_entry) / sizeof(u32),\n\t\t\t  NULL);\n\n\tif (elem_type == QED_ELEM_CXT) {\n\t\tu32 last_cid_allocated = (1 + (iid / elems_per_p)) *\n\t\t    elems_per_p;\n\n\t\t \n\t\tqed_wr(p_hwfn, p_ptt, PRS_REG_ROCE_DEST_QP_MAX_PF,\n\t\t       last_cid_allocated - 1);\n\n\t\tif (!p_hwfn->b_rdma_enabled_in_prs) {\n\t\t\t \n\t\t\tqed_wr(p_hwfn, p_ptt, p_hwfn->rdma_prs_search_reg, 1);\n\t\t\tp_hwfn->b_rdma_enabled_in_prs = true;\n\t\t}\n\t}\n\nout1:\n\tqed_ptt_release(p_hwfn, p_ptt);\nout0:\n\tmutex_unlock(&p_hwfn->p_cxt_mngr->mutex);\n\n\treturn rc;\n}\n\n \nstatic int\nqed_cxt_free_ilt_range(struct qed_hwfn *p_hwfn,\n\t\t       enum qed_cxt_elem_type elem_type,\n\t\t       u32 start_iid, u32 count)\n{\n\tu32 start_line, end_line, shadow_start_line, shadow_end_line;\n\tu32 reg_offset, elem_size, hw_p_size, elems_per_p;\n\tstruct qed_ilt_client_cfg *p_cli;\n\tstruct qed_ilt_cli_blk *p_blk;\n\tu32 end_iid = start_iid + count;\n\tstruct qed_ptt *p_ptt;\n\tu64 ilt_hw_entry = 0;\n\tu32 i;\n\n\tswitch (elem_type) {\n\tcase QED_ELEM_CXT:\n\t\tp_cli = &p_hwfn->p_cxt_mngr->clients[ILT_CLI_CDUC];\n\t\telem_size = CONN_CXT_SIZE(p_hwfn);\n\t\tp_blk = &p_cli->pf_blks[CDUC_BLK];\n\t\tbreak;\n\tcase QED_ELEM_SRQ:\n\t\tp_cli = &p_hwfn->p_cxt_mngr->clients[ILT_CLI_TSDM];\n\t\telem_size = SRQ_CXT_SIZE;\n\t\tp_blk = &p_cli->pf_blks[SRQ_BLK];\n\t\tbreak;\n\tcase QED_ELEM_XRC_SRQ:\n\t\tp_cli = &p_hwfn->p_cxt_mngr->clients[ILT_CLI_TSDM];\n\t\telem_size = XRC_SRQ_CXT_SIZE;\n\t\tp_blk = &p_cli->pf_blks[SRQ_BLK];\n\t\tbreak;\n\tcase QED_ELEM_TASK:\n\t\tp_cli = &p_hwfn->p_cxt_mngr->clients[ILT_CLI_CDUT];\n\t\telem_size = TYPE1_TASK_CXT_SIZE(p_hwfn);\n\t\tp_blk = &p_cli->pf_blks[CDUT_SEG_BLK(QED_CXT_ROCE_TID_SEG)];\n\t\tbreak;\n\tdefault:\n\t\tDP_NOTICE(p_hwfn, \"-EINVALID elem type = %d\", elem_type);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\thw_p_size = p_cli->p_size.val;\n\telems_per_p = ILT_PAGE_IN_BYTES(hw_p_size) / elem_size;\n\tstart_line = p_blk->start_line + (start_iid / elems_per_p);\n\tend_line = p_blk->start_line + (end_iid / elems_per_p);\n\tif (((end_iid + 1) / elems_per_p) != (end_iid / elems_per_p))\n\t\tend_line--;\n\n\tshadow_start_line = start_line - p_hwfn->p_cxt_mngr->pf_start_line;\n\tshadow_end_line = end_line - p_hwfn->p_cxt_mngr->pf_start_line;\n\n\tp_ptt = qed_ptt_acquire(p_hwfn);\n\tif (!p_ptt) {\n\t\tDP_NOTICE(p_hwfn,\n\t\t\t  \"QED_TIME_OUT on ptt acquire - dynamic allocation\");\n\t\treturn -EBUSY;\n\t}\n\n\tfor (i = shadow_start_line; i < shadow_end_line; i++) {\n\t\tif (!p_hwfn->p_cxt_mngr->ilt_shadow[i].virt_addr)\n\t\t\tcontinue;\n\n\t\tdma_free_coherent(&p_hwfn->cdev->pdev->dev,\n\t\t\t\t  p_hwfn->p_cxt_mngr->ilt_shadow[i].size,\n\t\t\t\t  p_hwfn->p_cxt_mngr->ilt_shadow[i].virt_addr,\n\t\t\t\t  p_hwfn->p_cxt_mngr->ilt_shadow[i].phys_addr);\n\n\t\tp_hwfn->p_cxt_mngr->ilt_shadow[i].virt_addr = NULL;\n\t\tp_hwfn->p_cxt_mngr->ilt_shadow[i].phys_addr = 0;\n\t\tp_hwfn->p_cxt_mngr->ilt_shadow[i].size = 0;\n\n\t\t \n\t\treg_offset = PSWRQ2_REG_ILT_MEMORY +\n\t\t    ((start_line++) * ILT_REG_SIZE_IN_BYTES *\n\t\t     ILT_ENTRY_IN_REGS);\n\n\t\t \n\t\tqed_dmae_host2grc(p_hwfn, p_ptt,\n\t\t\t\t  (u64) (uintptr_t) &ilt_hw_entry,\n\t\t\t\t  reg_offset,\n\t\t\t\t  sizeof(ilt_hw_entry) / sizeof(u32),\n\t\t\t\t  NULL);\n\t}\n\n\tqed_ptt_release(p_hwfn, p_ptt);\n\n\treturn 0;\n}\n\nint qed_cxt_free_proto_ilt(struct qed_hwfn *p_hwfn, enum protocol_type proto)\n{\n\tint rc;\n\tu32 cid;\n\n\t \n\trc = qed_cxt_free_ilt_range(p_hwfn, QED_ELEM_CXT,\n\t\t\t\t    qed_cxt_get_proto_cid_start(p_hwfn,\n\t\t\t\t\t\t\t\tproto),\n\t\t\t\t    qed_cxt_get_proto_cid_count(p_hwfn,\n\t\t\t\t\t\t\t\tproto, &cid));\n\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tproto = PROTOCOLID_ROCE;\n\trc = qed_cxt_free_ilt_range(p_hwfn, QED_ELEM_TASK, 0,\n\t\t\t\t    qed_cxt_get_proto_tid_count(p_hwfn, proto));\n\tif (rc)\n\t\treturn rc;\n\n\t \n\trc = qed_cxt_free_ilt_range(p_hwfn, QED_ELEM_XRC_SRQ, 0,\n\t\t\t\t    p_hwfn->p_cxt_mngr->xrc_srq_count);\n\n\trc = qed_cxt_free_ilt_range(p_hwfn, QED_ELEM_SRQ,\n\t\t\t\t    p_hwfn->p_cxt_mngr->xrc_srq_count,\n\t\t\t\t    p_hwfn->p_cxt_mngr->srq_count);\n\n\treturn rc;\n}\n\nint qed_cxt_get_task_ctx(struct qed_hwfn *p_hwfn,\n\t\t\t u32 tid, u8 ctx_type, void **pp_task_ctx)\n{\n\tstruct qed_cxt_mngr *p_mngr = p_hwfn->p_cxt_mngr;\n\tstruct qed_ilt_client_cfg *p_cli;\n\tstruct qed_tid_seg *p_seg_info;\n\tstruct qed_ilt_cli_blk *p_seg;\n\tu32 num_tids_per_block;\n\tu32 tid_size, ilt_idx;\n\tu32 total_lines;\n\tu32 proto, seg;\n\n\t \n\tswitch (p_hwfn->hw_info.personality) {\n\tcase QED_PCI_FCOE:\n\t\tproto = PROTOCOLID_FCOE;\n\t\tseg = QED_CXT_FCOE_TID_SEG;\n\t\tbreak;\n\tcase QED_PCI_ISCSI:\n\tcase QED_PCI_NVMETCP:\n\t\tproto = PROTOCOLID_TCP_ULP;\n\t\tseg = QED_CXT_TCP_ULP_TID_SEG;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tp_cli = &p_mngr->clients[ILT_CLI_CDUT];\n\tif (!p_cli->active)\n\t\treturn -EINVAL;\n\n\tp_seg_info = &p_mngr->conn_cfg[proto].tid_seg[seg];\n\n\tif (ctx_type == QED_CTX_WORKING_MEM) {\n\t\tp_seg = &p_cli->pf_blks[CDUT_SEG_BLK(seg)];\n\t} else if (ctx_type == QED_CTX_FL_MEM) {\n\t\tif (!p_seg_info->has_fl_mem)\n\t\t\treturn -EINVAL;\n\t\tp_seg = &p_cli->pf_blks[CDUT_FL_SEG_BLK(seg, PF)];\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\ttotal_lines = DIV_ROUND_UP(p_seg->total_size, p_seg->real_size_in_page);\n\ttid_size = p_mngr->task_type_size[p_seg_info->type];\n\tnum_tids_per_block = p_seg->real_size_in_page / tid_size;\n\n\tif (total_lines < tid / num_tids_per_block)\n\t\treturn -EINVAL;\n\n\tilt_idx = tid / num_tids_per_block + p_seg->start_line -\n\t\t  p_mngr->pf_start_line;\n\t*pp_task_ctx = (u8 *)p_mngr->ilt_shadow[ilt_idx].virt_addr +\n\t\t       (tid % num_tids_per_block) * tid_size;\n\n\treturn 0;\n}\n\nstatic u16 qed_blk_calculate_pages(struct qed_ilt_cli_blk *p_blk)\n{\n\tif (p_blk->real_size_in_page == 0)\n\t\treturn 0;\n\n\treturn DIV_ROUND_UP(p_blk->total_size, p_blk->real_size_in_page);\n}\n\nu16 qed_get_cdut_num_pf_init_pages(struct qed_hwfn *p_hwfn)\n{\n\tstruct qed_ilt_client_cfg *p_cli;\n\tstruct qed_ilt_cli_blk *p_blk;\n\tu16 i, pages = 0;\n\n\tp_cli = &p_hwfn->p_cxt_mngr->clients[ILT_CLI_CDUT];\n\tfor (i = 0; i < NUM_TASK_PF_SEGMENTS; i++) {\n\t\tp_blk = &p_cli->pf_blks[CDUT_FL_SEG_BLK(i, PF)];\n\t\tpages += qed_blk_calculate_pages(p_blk);\n\t}\n\n\treturn pages;\n}\n\nu16 qed_get_cdut_num_vf_init_pages(struct qed_hwfn *p_hwfn)\n{\n\tstruct qed_ilt_client_cfg *p_cli;\n\tstruct qed_ilt_cli_blk *p_blk;\n\tu16 i, pages = 0;\n\n\tp_cli = &p_hwfn->p_cxt_mngr->clients[ILT_CLI_CDUT];\n\tfor (i = 0; i < NUM_TASK_VF_SEGMENTS; i++) {\n\t\tp_blk = &p_cli->vf_blks[CDUT_FL_SEG_BLK(i, VF)];\n\t\tpages += qed_blk_calculate_pages(p_blk);\n\t}\n\n\treturn pages;\n}\n\nu16 qed_get_cdut_num_pf_work_pages(struct qed_hwfn *p_hwfn)\n{\n\tstruct qed_ilt_client_cfg *p_cli;\n\tstruct qed_ilt_cli_blk *p_blk;\n\tu16 i, pages = 0;\n\n\tp_cli = &p_hwfn->p_cxt_mngr->clients[ILT_CLI_CDUT];\n\tfor (i = 0; i < NUM_TASK_PF_SEGMENTS; i++) {\n\t\tp_blk = &p_cli->pf_blks[CDUT_SEG_BLK(i)];\n\t\tpages += qed_blk_calculate_pages(p_blk);\n\t}\n\n\treturn pages;\n}\n\nu16 qed_get_cdut_num_vf_work_pages(struct qed_hwfn *p_hwfn)\n{\n\tstruct qed_ilt_client_cfg *p_cli;\n\tstruct qed_ilt_cli_blk *p_blk;\n\tu16 pages = 0, i;\n\n\tp_cli = &p_hwfn->p_cxt_mngr->clients[ILT_CLI_CDUT];\n\tfor (i = 0; i < NUM_TASK_VF_SEGMENTS; i++) {\n\t\tp_blk = &p_cli->vf_blks[CDUT_SEG_BLK(i)];\n\t\tpages += qed_blk_calculate_pages(p_blk);\n\t}\n\n\treturn pages;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}