{
  "module_name": "qed_fcoe.c",
  "hash_id": "06b1d3a2cac630d65bd4ce0e18bc189ddceb5032064251095f0fed953c1ec318",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/qlogic/qed/qed_fcoe.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <asm/byteorder.h>\n#include <asm/param.h>\n#include <linux/delay.h>\n#include <linux/dma-mapping.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/log2.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/string.h>\n#include <linux/workqueue.h>\n#include <linux/errno.h>\n#include <linux/list.h>\n#include <linux/spinlock.h>\n#define __PREVENT_DUMP_MEM_ARR__\n#define __PREVENT_PXP_GLOBAL_WIN__\n#include \"qed.h\"\n#include \"qed_cxt.h\"\n#include \"qed_dev_api.h\"\n#include \"qed_fcoe.h\"\n#include \"qed_hsi.h\"\n#include \"qed_hw.h\"\n#include \"qed_int.h\"\n#include \"qed_iro_hsi.h\"\n#include \"qed_ll2.h\"\n#include \"qed_mcp.h\"\n#include \"qed_reg_addr.h\"\n#include \"qed_sp.h\"\n#include \"qed_sriov.h\"\n#include <linux/qed/qed_fcoe_if.h>\n\nstruct qed_fcoe_conn {\n\tstruct list_head list_entry;\n\tbool free_on_delete;\n\n\tu16 conn_id;\n\tu32 icid;\n\tu32 fw_cid;\n\tu8 layer_code;\n\n\tdma_addr_t sq_pbl_addr;\n\tdma_addr_t sq_curr_page_addr;\n\tdma_addr_t sq_next_page_addr;\n\tdma_addr_t xferq_pbl_addr;\n\tvoid *xferq_pbl_addr_virt_addr;\n\tdma_addr_t xferq_addr[4];\n\tvoid *xferq_addr_virt_addr[4];\n\tdma_addr_t confq_pbl_addr;\n\tvoid *confq_pbl_addr_virt_addr;\n\tdma_addr_t confq_addr[2];\n\tvoid *confq_addr_virt_addr[2];\n\n\tdma_addr_t terminate_params;\n\n\tu16 dst_mac_addr_lo;\n\tu16 dst_mac_addr_mid;\n\tu16 dst_mac_addr_hi;\n\tu16 src_mac_addr_lo;\n\tu16 src_mac_addr_mid;\n\tu16 src_mac_addr_hi;\n\n\tu16 tx_max_fc_pay_len;\n\tu16 e_d_tov_timer_val;\n\tu16 rec_tov_timer_val;\n\tu16 rx_max_fc_pay_len;\n\tu16 vlan_tag;\n\tu16 physical_q0;\n\n\tstruct fc_addr_nw s_id;\n\tu8 max_conc_seqs_c3;\n\tstruct fc_addr_nw d_id;\n\tu8 flags;\n\tu8 def_q_idx;\n};\n\nstatic int\nqed_sp_fcoe_func_start(struct qed_hwfn *p_hwfn,\n\t\t       enum spq_mode comp_mode,\n\t\t       struct qed_spq_comp_cb *p_comp_addr)\n{\n\tstruct qed_fcoe_pf_params *fcoe_pf_params = NULL;\n\tstruct fcoe_init_ramrod_params *p_ramrod = NULL;\n\tstruct fcoe_init_func_ramrod_data *p_data;\n\tstruct fcoe_conn_context *p_cxt = NULL;\n\tstruct qed_spq_entry *p_ent = NULL;\n\tstruct qed_sp_init_data init_data;\n\tstruct qed_cxt_info cxt_info;\n\tu32 dummy_cid;\n\tint rc = 0;\n\t__le16 tmp;\n\tu8 i;\n\n\t \n\tmemset(&init_data, 0, sizeof(init_data));\n\tinit_data.cid = qed_spq_get_cid(p_hwfn);\n\tinit_data.opaque_fid = p_hwfn->hw_info.opaque_fid;\n\tinit_data.comp_mode = comp_mode;\n\tinit_data.p_comp_data = p_comp_addr;\n\n\trc = qed_sp_init_request(p_hwfn, &p_ent,\n\t\t\t\t FCOE_RAMROD_CMD_ID_INIT_FUNC,\n\t\t\t\t PROTOCOLID_FCOE, &init_data);\n\tif (rc)\n\t\treturn rc;\n\n\tp_ramrod = &p_ent->ramrod.fcoe_init;\n\tp_data = &p_ramrod->init_ramrod_data;\n\tfcoe_pf_params = &p_hwfn->pf_params.fcoe_pf_params;\n\n\t \n\tif (fcoe_pf_params->num_cqs > p_hwfn->hw_info.feat_num[QED_FCOE_CQ]) {\n\t\tDP_ERR(p_hwfn,\n\t\t       \"Cannot satisfy CQ amount. CQs requested %d, CQs available %d. Aborting function start\\n\",\n\t\t       fcoe_pf_params->num_cqs,\n\t\t       p_hwfn->hw_info.feat_num[QED_FCOE_CQ]);\n\t\trc = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tp_data->mtu = cpu_to_le16(fcoe_pf_params->mtu);\n\ttmp = cpu_to_le16(fcoe_pf_params->sq_num_pbl_pages);\n\tp_data->sq_num_pages_in_pbl = tmp;\n\n\trc = qed_cxt_acquire_cid(p_hwfn, PROTOCOLID_FCOE, &dummy_cid);\n\tif (rc)\n\t\tgoto err;\n\n\tcxt_info.iid = dummy_cid;\n\trc = qed_cxt_get_cid_info(p_hwfn, &cxt_info);\n\tif (rc) {\n\t\tDP_NOTICE(p_hwfn, \"Cannot find context info for dummy cid=%d\\n\",\n\t\t\t  dummy_cid);\n\t\tgoto err;\n\t}\n\tp_cxt = cxt_info.p_cxt;\n\tmemset(p_cxt, 0, sizeof(*p_cxt));\n\n\tSET_FIELD(p_cxt->tstorm_ag_context.flags3,\n\t\t  TSTORM_FCOE_CONN_AG_CTX_DUMMY_TIMER_CF_EN, 1);\n\n\tfcoe_pf_params->dummy_icid = (u16)dummy_cid;\n\n\ttmp = cpu_to_le16(fcoe_pf_params->num_tasks);\n\tp_data->func_params.num_tasks = tmp;\n\tp_data->func_params.log_page_size = fcoe_pf_params->log_page_size;\n\tp_data->func_params.debug_mode = fcoe_pf_params->debug_mode;\n\n\tDMA_REGPAIR_LE(p_data->q_params.glbl_q_params_addr,\n\t\t       fcoe_pf_params->glbl_q_params_addr);\n\n\ttmp = cpu_to_le16(fcoe_pf_params->cq_num_entries);\n\tp_data->q_params.cq_num_entries = tmp;\n\n\ttmp = cpu_to_le16(fcoe_pf_params->cmdq_num_entries);\n\tp_data->q_params.cmdq_num_entries = tmp;\n\n\tp_data->q_params.num_queues = fcoe_pf_params->num_cqs;\n\n\ttmp = (__force __le16)p_hwfn->hw_info.resc_start[QED_CMDQS_CQS];\n\tp_data->q_params.queue_relative_offset = (__force u8)tmp;\n\n\tfor (i = 0; i < fcoe_pf_params->num_cqs; i++) {\n\t\ttmp = cpu_to_le16(qed_get_igu_sb_id(p_hwfn, i));\n\t\tp_data->q_params.cq_cmdq_sb_num_arr[i] = tmp;\n\t}\n\n\tp_data->q_params.cq_sb_pi = fcoe_pf_params->gl_rq_pi;\n\tp_data->q_params.cmdq_sb_pi = fcoe_pf_params->gl_cmd_pi;\n\n\tp_data->q_params.bdq_resource_id = (u8)RESC_START(p_hwfn, QED_BDQ);\n\n\tDMA_REGPAIR_LE(p_data->q_params.bdq_pbl_base_address[BDQ_ID_RQ],\n\t\t       fcoe_pf_params->bdq_pbl_base_addr[BDQ_ID_RQ]);\n\tp_data->q_params.bdq_pbl_num_entries[BDQ_ID_RQ] =\n\t    fcoe_pf_params->bdq_pbl_num_entries[BDQ_ID_RQ];\n\ttmp = cpu_to_le16(fcoe_pf_params->bdq_xoff_threshold[BDQ_ID_RQ]);\n\tp_data->q_params.bdq_xoff_threshold[BDQ_ID_RQ] = tmp;\n\ttmp = cpu_to_le16(fcoe_pf_params->bdq_xon_threshold[BDQ_ID_RQ]);\n\tp_data->q_params.bdq_xon_threshold[BDQ_ID_RQ] = tmp;\n\n\tDMA_REGPAIR_LE(p_data->q_params.bdq_pbl_base_address[BDQ_ID_IMM_DATA],\n\t\t       fcoe_pf_params->bdq_pbl_base_addr[BDQ_ID_IMM_DATA]);\n\tp_data->q_params.bdq_pbl_num_entries[BDQ_ID_IMM_DATA] =\n\t    fcoe_pf_params->bdq_pbl_num_entries[BDQ_ID_IMM_DATA];\n\ttmp = cpu_to_le16(fcoe_pf_params->bdq_xoff_threshold[BDQ_ID_IMM_DATA]);\n\tp_data->q_params.bdq_xoff_threshold[BDQ_ID_IMM_DATA] = tmp;\n\ttmp = cpu_to_le16(fcoe_pf_params->bdq_xon_threshold[BDQ_ID_IMM_DATA]);\n\tp_data->q_params.bdq_xon_threshold[BDQ_ID_IMM_DATA] = tmp;\n\ttmp = cpu_to_le16(fcoe_pf_params->rq_buffer_size);\n\tp_data->q_params.rq_buffer_size = tmp;\n\n\tif (fcoe_pf_params->is_target) {\n\t\tSET_FIELD(p_data->q_params.q_validity,\n\t\t\t  SCSI_INIT_FUNC_QUEUES_RQ_VALID, 1);\n\t\tif (p_data->q_params.bdq_pbl_num_entries[BDQ_ID_IMM_DATA])\n\t\t\tSET_FIELD(p_data->q_params.q_validity,\n\t\t\t\t  SCSI_INIT_FUNC_QUEUES_IMM_DATA_VALID, 1);\n\t\tSET_FIELD(p_data->q_params.q_validity,\n\t\t\t  SCSI_INIT_FUNC_QUEUES_CMD_VALID, 1);\n\t} else {\n\t\tSET_FIELD(p_data->q_params.q_validity,\n\t\t\t  SCSI_INIT_FUNC_QUEUES_RQ_VALID, 1);\n\t}\n\n\trc = qed_spq_post(p_hwfn, p_ent, NULL);\n\n\treturn rc;\n\nerr:\n\tqed_sp_destroy_request(p_hwfn, p_ent);\n\treturn rc;\n}\n\nstatic int\nqed_sp_fcoe_conn_offload(struct qed_hwfn *p_hwfn,\n\t\t\t struct qed_fcoe_conn *p_conn,\n\t\t\t enum spq_mode comp_mode,\n\t\t\t struct qed_spq_comp_cb *p_comp_addr)\n{\n\tstruct fcoe_conn_offload_ramrod_params *p_ramrod = NULL;\n\tstruct fcoe_conn_offload_ramrod_data *p_data;\n\tstruct qed_spq_entry *p_ent = NULL;\n\tstruct qed_sp_init_data init_data;\n\tu16 physical_q0;\n\t__le16 tmp;\n\tint rc;\n\n\t \n\tmemset(&init_data, 0, sizeof(init_data));\n\tinit_data.cid = p_conn->icid;\n\tinit_data.opaque_fid = p_hwfn->hw_info.opaque_fid;\n\tinit_data.comp_mode = comp_mode;\n\tinit_data.p_comp_data = p_comp_addr;\n\n\trc = qed_sp_init_request(p_hwfn, &p_ent,\n\t\t\t\t FCOE_RAMROD_CMD_ID_OFFLOAD_CONN,\n\t\t\t\t PROTOCOLID_FCOE, &init_data);\n\tif (rc)\n\t\treturn rc;\n\n\tp_ramrod = &p_ent->ramrod.fcoe_conn_ofld;\n\tp_data = &p_ramrod->offload_ramrod_data;\n\n\t \n\tphysical_q0 = qed_get_cm_pq_idx(p_hwfn, PQ_FLAGS_OFLD);\n\tp_conn->physical_q0 = physical_q0;\n\tp_data->physical_q0 = cpu_to_le16(physical_q0);\n\n\tp_data->conn_id = cpu_to_le16(p_conn->conn_id);\n\tDMA_REGPAIR_LE(p_data->sq_pbl_addr, p_conn->sq_pbl_addr);\n\tDMA_REGPAIR_LE(p_data->sq_curr_page_addr, p_conn->sq_curr_page_addr);\n\tDMA_REGPAIR_LE(p_data->sq_next_page_addr, p_conn->sq_next_page_addr);\n\tDMA_REGPAIR_LE(p_data->xferq_pbl_addr, p_conn->xferq_pbl_addr);\n\tDMA_REGPAIR_LE(p_data->xferq_curr_page_addr, p_conn->xferq_addr[0]);\n\tDMA_REGPAIR_LE(p_data->xferq_next_page_addr, p_conn->xferq_addr[1]);\n\n\tDMA_REGPAIR_LE(p_data->respq_pbl_addr, p_conn->confq_pbl_addr);\n\tDMA_REGPAIR_LE(p_data->respq_curr_page_addr, p_conn->confq_addr[0]);\n\tDMA_REGPAIR_LE(p_data->respq_next_page_addr, p_conn->confq_addr[1]);\n\n\tp_data->dst_mac_addr_lo = cpu_to_le16(p_conn->dst_mac_addr_lo);\n\tp_data->dst_mac_addr_mid = cpu_to_le16(p_conn->dst_mac_addr_mid);\n\tp_data->dst_mac_addr_hi = cpu_to_le16(p_conn->dst_mac_addr_hi);\n\tp_data->src_mac_addr_lo = cpu_to_le16(p_conn->src_mac_addr_lo);\n\tp_data->src_mac_addr_mid = cpu_to_le16(p_conn->src_mac_addr_mid);\n\tp_data->src_mac_addr_hi = cpu_to_le16(p_conn->src_mac_addr_hi);\n\n\ttmp = cpu_to_le16(p_conn->tx_max_fc_pay_len);\n\tp_data->tx_max_fc_pay_len = tmp;\n\ttmp = cpu_to_le16(p_conn->e_d_tov_timer_val);\n\tp_data->e_d_tov_timer_val = tmp;\n\ttmp = cpu_to_le16(p_conn->rec_tov_timer_val);\n\tp_data->rec_rr_tov_timer_val = tmp;\n\ttmp = cpu_to_le16(p_conn->rx_max_fc_pay_len);\n\tp_data->rx_max_fc_pay_len = tmp;\n\n\tp_data->vlan_tag = cpu_to_le16(p_conn->vlan_tag);\n\tp_data->s_id.addr_hi = p_conn->s_id.addr_hi;\n\tp_data->s_id.addr_mid = p_conn->s_id.addr_mid;\n\tp_data->s_id.addr_lo = p_conn->s_id.addr_lo;\n\tp_data->max_conc_seqs_c3 = p_conn->max_conc_seqs_c3;\n\tp_data->d_id.addr_hi = p_conn->d_id.addr_hi;\n\tp_data->d_id.addr_mid = p_conn->d_id.addr_mid;\n\tp_data->d_id.addr_lo = p_conn->d_id.addr_lo;\n\tp_data->flags = p_conn->flags;\n\tif (test_bit(QED_MF_UFP_SPECIFIC, &p_hwfn->cdev->mf_bits))\n\t\tSET_FIELD(p_data->flags,\n\t\t\t  FCOE_CONN_OFFLOAD_RAMROD_DATA_B_SINGLE_VLAN, 1);\n\tp_data->def_q_idx = p_conn->def_q_idx;\n\n\treturn qed_spq_post(p_hwfn, p_ent, NULL);\n}\n\nstatic int\nqed_sp_fcoe_conn_destroy(struct qed_hwfn *p_hwfn,\n\t\t\t struct qed_fcoe_conn *p_conn,\n\t\t\t enum spq_mode comp_mode,\n\t\t\t struct qed_spq_comp_cb *p_comp_addr)\n{\n\tstruct fcoe_conn_terminate_ramrod_params *p_ramrod = NULL;\n\tstruct qed_spq_entry *p_ent = NULL;\n\tstruct qed_sp_init_data init_data;\n\tint rc = 0;\n\n\t \n\tmemset(&init_data, 0, sizeof(init_data));\n\tinit_data.cid = p_conn->icid;\n\tinit_data.opaque_fid = p_hwfn->hw_info.opaque_fid;\n\tinit_data.comp_mode = comp_mode;\n\tinit_data.p_comp_data = p_comp_addr;\n\n\trc = qed_sp_init_request(p_hwfn, &p_ent,\n\t\t\t\t FCOE_RAMROD_CMD_ID_TERMINATE_CONN,\n\t\t\t\t PROTOCOLID_FCOE, &init_data);\n\tif (rc)\n\t\treturn rc;\n\n\tp_ramrod = &p_ent->ramrod.fcoe_conn_terminate;\n\tDMA_REGPAIR_LE(p_ramrod->terminate_ramrod_data.terminate_params_addr,\n\t\t       p_conn->terminate_params);\n\n\treturn qed_spq_post(p_hwfn, p_ent, NULL);\n}\n\nstatic int\nqed_sp_fcoe_func_stop(struct qed_hwfn *p_hwfn,\n\t\t      struct qed_ptt *p_ptt,\n\t\t      enum spq_mode comp_mode,\n\t\t      struct qed_spq_comp_cb *p_comp_addr)\n{\n\tstruct qed_spq_entry *p_ent = NULL;\n\tstruct qed_sp_init_data init_data;\n\tu32 active_segs = 0;\n\tint rc = 0;\n\n\t \n\tmemset(&init_data, 0, sizeof(init_data));\n\tinit_data.cid = p_hwfn->pf_params.fcoe_pf_params.dummy_icid;\n\tinit_data.opaque_fid = p_hwfn->hw_info.opaque_fid;\n\tinit_data.comp_mode = comp_mode;\n\tinit_data.p_comp_data = p_comp_addr;\n\n\trc = qed_sp_init_request(p_hwfn, &p_ent,\n\t\t\t\t FCOE_RAMROD_CMD_ID_DESTROY_FUNC,\n\t\t\t\t PROTOCOLID_FCOE, &init_data);\n\tif (rc)\n\t\treturn rc;\n\n\tactive_segs = qed_rd(p_hwfn, p_ptt, TM_REG_PF_ENABLE_TASK);\n\tactive_segs &= ~BIT(QED_CXT_FCOE_TID_SEG);\n\tqed_wr(p_hwfn, p_ptt, TM_REG_PF_ENABLE_TASK, active_segs);\n\n\treturn qed_spq_post(p_hwfn, p_ent, NULL);\n}\n\nstatic int\nqed_fcoe_allocate_connection(struct qed_hwfn *p_hwfn,\n\t\t\t     struct qed_fcoe_conn **p_out_conn)\n{\n\tstruct qed_fcoe_conn *p_conn = NULL;\n\tvoid *p_addr;\n\tu32 i;\n\n\tspin_lock_bh(&p_hwfn->p_fcoe_info->lock);\n\tif (!list_empty(&p_hwfn->p_fcoe_info->free_list))\n\t\tp_conn =\n\t\t    list_first_entry(&p_hwfn->p_fcoe_info->free_list,\n\t\t\t\t     struct qed_fcoe_conn, list_entry);\n\tif (p_conn) {\n\t\tlist_del(&p_conn->list_entry);\n\t\tspin_unlock_bh(&p_hwfn->p_fcoe_info->lock);\n\t\t*p_out_conn = p_conn;\n\t\treturn 0;\n\t}\n\tspin_unlock_bh(&p_hwfn->p_fcoe_info->lock);\n\n\tp_conn = kzalloc(sizeof(*p_conn), GFP_KERNEL);\n\tif (!p_conn)\n\t\treturn -ENOMEM;\n\n\tp_addr = dma_alloc_coherent(&p_hwfn->cdev->pdev->dev,\n\t\t\t\t    QED_CHAIN_PAGE_SIZE,\n\t\t\t\t    &p_conn->xferq_pbl_addr, GFP_KERNEL);\n\tif (!p_addr)\n\t\tgoto nomem_pbl_xferq;\n\tp_conn->xferq_pbl_addr_virt_addr = p_addr;\n\n\tfor (i = 0; i < ARRAY_SIZE(p_conn->xferq_addr); i++) {\n\t\tp_addr = dma_alloc_coherent(&p_hwfn->cdev->pdev->dev,\n\t\t\t\t\t    QED_CHAIN_PAGE_SIZE,\n\t\t\t\t\t    &p_conn->xferq_addr[i], GFP_KERNEL);\n\t\tif (!p_addr)\n\t\t\tgoto nomem_xferq;\n\t\tp_conn->xferq_addr_virt_addr[i] = p_addr;\n\n\t\tp_addr = p_conn->xferq_pbl_addr_virt_addr;\n\t\t((dma_addr_t *)p_addr)[i] = p_conn->xferq_addr[i];\n\t}\n\n\tp_addr = dma_alloc_coherent(&p_hwfn->cdev->pdev->dev,\n\t\t\t\t    QED_CHAIN_PAGE_SIZE,\n\t\t\t\t    &p_conn->confq_pbl_addr, GFP_KERNEL);\n\tif (!p_addr)\n\t\tgoto nomem_xferq;\n\tp_conn->confq_pbl_addr_virt_addr = p_addr;\n\n\tfor (i = 0; i < ARRAY_SIZE(p_conn->confq_addr); i++) {\n\t\tp_addr = dma_alloc_coherent(&p_hwfn->cdev->pdev->dev,\n\t\t\t\t\t    QED_CHAIN_PAGE_SIZE,\n\t\t\t\t\t    &p_conn->confq_addr[i], GFP_KERNEL);\n\t\tif (!p_addr)\n\t\t\tgoto nomem_confq;\n\t\tp_conn->confq_addr_virt_addr[i] = p_addr;\n\n\t\tp_addr = p_conn->confq_pbl_addr_virt_addr;\n\t\t((dma_addr_t *)p_addr)[i] = p_conn->confq_addr[i];\n\t}\n\n\tp_conn->free_on_delete = true;\n\t*p_out_conn = p_conn;\n\treturn 0;\n\nnomem_confq:\n\tdma_free_coherent(&p_hwfn->cdev->pdev->dev,\n\t\t\t  QED_CHAIN_PAGE_SIZE,\n\t\t\t  p_conn->confq_pbl_addr_virt_addr,\n\t\t\t  p_conn->confq_pbl_addr);\n\tfor (i = 0; i < ARRAY_SIZE(p_conn->confq_addr); i++)\n\t\tif (p_conn->confq_addr_virt_addr[i])\n\t\t\tdma_free_coherent(&p_hwfn->cdev->pdev->dev,\n\t\t\t\t\t  QED_CHAIN_PAGE_SIZE,\n\t\t\t\t\t  p_conn->confq_addr_virt_addr[i],\n\t\t\t\t\t  p_conn->confq_addr[i]);\nnomem_xferq:\n\tdma_free_coherent(&p_hwfn->cdev->pdev->dev,\n\t\t\t  QED_CHAIN_PAGE_SIZE,\n\t\t\t  p_conn->xferq_pbl_addr_virt_addr,\n\t\t\t  p_conn->xferq_pbl_addr);\n\tfor (i = 0; i < ARRAY_SIZE(p_conn->xferq_addr); i++)\n\t\tif (p_conn->xferq_addr_virt_addr[i])\n\t\t\tdma_free_coherent(&p_hwfn->cdev->pdev->dev,\n\t\t\t\t\t  QED_CHAIN_PAGE_SIZE,\n\t\t\t\t\t  p_conn->xferq_addr_virt_addr[i],\n\t\t\t\t\t  p_conn->xferq_addr[i]);\nnomem_pbl_xferq:\n\tkfree(p_conn);\n\treturn -ENOMEM;\n}\n\nstatic void qed_fcoe_free_connection(struct qed_hwfn *p_hwfn,\n\t\t\t\t     struct qed_fcoe_conn *p_conn)\n{\n\tu32 i;\n\n\tif (!p_conn)\n\t\treturn;\n\n\tif (p_conn->confq_pbl_addr_virt_addr)\n\t\tdma_free_coherent(&p_hwfn->cdev->pdev->dev,\n\t\t\t\t  QED_CHAIN_PAGE_SIZE,\n\t\t\t\t  p_conn->confq_pbl_addr_virt_addr,\n\t\t\t\t  p_conn->confq_pbl_addr);\n\n\tfor (i = 0; i < ARRAY_SIZE(p_conn->confq_addr); i++) {\n\t\tif (!p_conn->confq_addr_virt_addr[i])\n\t\t\tcontinue;\n\t\tdma_free_coherent(&p_hwfn->cdev->pdev->dev,\n\t\t\t\t  QED_CHAIN_PAGE_SIZE,\n\t\t\t\t  p_conn->confq_addr_virt_addr[i],\n\t\t\t\t  p_conn->confq_addr[i]);\n\t}\n\n\tif (p_conn->xferq_pbl_addr_virt_addr)\n\t\tdma_free_coherent(&p_hwfn->cdev->pdev->dev,\n\t\t\t\t  QED_CHAIN_PAGE_SIZE,\n\t\t\t\t  p_conn->xferq_pbl_addr_virt_addr,\n\t\t\t\t  p_conn->xferq_pbl_addr);\n\n\tfor (i = 0; i < ARRAY_SIZE(p_conn->xferq_addr); i++) {\n\t\tif (!p_conn->xferq_addr_virt_addr[i])\n\t\t\tcontinue;\n\t\tdma_free_coherent(&p_hwfn->cdev->pdev->dev,\n\t\t\t\t  QED_CHAIN_PAGE_SIZE,\n\t\t\t\t  p_conn->xferq_addr_virt_addr[i],\n\t\t\t\t  p_conn->xferq_addr[i]);\n\t}\n\tkfree(p_conn);\n}\n\nstatic void __iomem *qed_fcoe_get_db_addr(struct qed_hwfn *p_hwfn, u32 cid)\n{\n\treturn (u8 __iomem *)p_hwfn->doorbells +\n\t       qed_db_addr(cid, DQ_DEMS_LEGACY);\n}\n\nstatic void __iomem *qed_fcoe_get_primary_bdq_prod(struct qed_hwfn *p_hwfn,\n\t\t\t\t\t\t   u8 bdq_id)\n{\n\tif (RESC_NUM(p_hwfn, QED_BDQ)) {\n\t\treturn (u8 __iomem *)p_hwfn->regview +\n\t\t    GET_GTT_BDQ_REG_ADDR(GTT_BAR0_MAP_REG_MSDM_RAM,\n\t\t\t\t\t MSTORM_SCSI_BDQ_EXT_PROD,\n\t\t\t\t\t RESC_START(p_hwfn, QED_BDQ), bdq_id);\n\t} else {\n\t\tDP_NOTICE(p_hwfn, \"BDQ is not allocated!\\n\");\n\t\treturn NULL;\n\t}\n}\n\nstatic void __iomem *qed_fcoe_get_secondary_bdq_prod(struct qed_hwfn *p_hwfn,\n\t\t\t\t\t\t     u8 bdq_id)\n{\n\tif (RESC_NUM(p_hwfn, QED_BDQ)) {\n\t\treturn (u8 __iomem *)p_hwfn->regview +\n\t\t    GET_GTT_BDQ_REG_ADDR(GTT_BAR0_MAP_REG_TSDM_RAM,\n\t\t\t\t\t TSTORM_SCSI_BDQ_EXT_PROD,\n\t\t\t\t\t RESC_START(p_hwfn, QED_BDQ), bdq_id);\n\t} else {\n\t\tDP_NOTICE(p_hwfn, \"BDQ is not allocated!\\n\");\n\t\treturn NULL;\n\t}\n}\n\nint qed_fcoe_alloc(struct qed_hwfn *p_hwfn)\n{\n\tstruct qed_fcoe_info *p_fcoe_info;\n\n\t \n\tp_fcoe_info = kzalloc(sizeof(*p_fcoe_info), GFP_KERNEL);\n\tif (!p_fcoe_info) {\n\t\tDP_NOTICE(p_hwfn, \"Failed to allocate qed_fcoe_info'\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tINIT_LIST_HEAD(&p_fcoe_info->free_list);\n\n\tp_hwfn->p_fcoe_info = p_fcoe_info;\n\treturn 0;\n}\n\nvoid qed_fcoe_setup(struct qed_hwfn *p_hwfn)\n{\n\tstruct fcoe_task_context *p_task_ctx = NULL;\n\tu32 i, lc;\n\tint rc;\n\n\tspin_lock_init(&p_hwfn->p_fcoe_info->lock);\n\tfor (i = 0; i < p_hwfn->pf_params.fcoe_pf_params.num_tasks; i++) {\n\t\trc = qed_cxt_get_task_ctx(p_hwfn, i,\n\t\t\t\t\t  QED_CTX_WORKING_MEM,\n\t\t\t\t\t  (void **)&p_task_ctx);\n\t\tif (rc)\n\t\t\tcontinue;\n\n\t\tmemset(p_task_ctx, 0, sizeof(struct fcoe_task_context));\n\n\t\tlc = 0;\n\t\tSET_FIELD(lc, TIMERS_CONTEXT_VALIDLC0, 1);\n\t\tp_task_ctx->timer_context.logical_client_0 = cpu_to_le32(lc);\n\n\t\tlc = 0;\n\t\tSET_FIELD(lc, TIMERS_CONTEXT_VALIDLC1, 1);\n\t\tp_task_ctx->timer_context.logical_client_1 = cpu_to_le32(lc);\n\n\t\tSET_FIELD(p_task_ctx->tstorm_ag_context.flags0,\n\t\t\t  TSTORM_FCOE_TASK_AG_CTX_CONNECTION_TYPE, 1);\n\t}\n}\n\nvoid qed_fcoe_free(struct qed_hwfn *p_hwfn)\n{\n\tstruct qed_fcoe_conn *p_conn = NULL;\n\n\tif (!p_hwfn->p_fcoe_info)\n\t\treturn;\n\n\twhile (!list_empty(&p_hwfn->p_fcoe_info->free_list)) {\n\t\tp_conn = list_first_entry(&p_hwfn->p_fcoe_info->free_list,\n\t\t\t\t\t  struct qed_fcoe_conn, list_entry);\n\t\tif (!p_conn)\n\t\t\tbreak;\n\t\tlist_del(&p_conn->list_entry);\n\t\tqed_fcoe_free_connection(p_hwfn, p_conn);\n\t}\n\n\tkfree(p_hwfn->p_fcoe_info);\n\tp_hwfn->p_fcoe_info = NULL;\n}\n\nstatic int\nqed_fcoe_acquire_connection(struct qed_hwfn *p_hwfn,\n\t\t\t    struct qed_fcoe_conn *p_in_conn,\n\t\t\t    struct qed_fcoe_conn **p_out_conn)\n{\n\tstruct qed_fcoe_conn *p_conn = NULL;\n\tint rc = 0;\n\tu32 icid;\n\n\tspin_lock_bh(&p_hwfn->p_fcoe_info->lock);\n\trc = qed_cxt_acquire_cid(p_hwfn, PROTOCOLID_FCOE, &icid);\n\tspin_unlock_bh(&p_hwfn->p_fcoe_info->lock);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tif (p_in_conn) {\n\t\tp_conn = p_in_conn;\n\t} else {\n\t\trc = qed_fcoe_allocate_connection(p_hwfn, &p_conn);\n\t\tif (rc) {\n\t\t\tspin_lock_bh(&p_hwfn->p_fcoe_info->lock);\n\t\t\tqed_cxt_release_cid(p_hwfn, icid);\n\t\t\tspin_unlock_bh(&p_hwfn->p_fcoe_info->lock);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\tp_conn->icid = icid;\n\tp_conn->fw_cid = (p_hwfn->hw_info.opaque_fid << 16) | icid;\n\t*p_out_conn = p_conn;\n\n\treturn rc;\n}\n\nstatic void qed_fcoe_release_connection(struct qed_hwfn *p_hwfn,\n\t\t\t\t\tstruct qed_fcoe_conn *p_conn)\n{\n\tspin_lock_bh(&p_hwfn->p_fcoe_info->lock);\n\tlist_add_tail(&p_conn->list_entry, &p_hwfn->p_fcoe_info->free_list);\n\tqed_cxt_release_cid(p_hwfn, p_conn->icid);\n\tspin_unlock_bh(&p_hwfn->p_fcoe_info->lock);\n}\n\nstatic void _qed_fcoe_get_tstats(struct qed_hwfn *p_hwfn,\n\t\t\t\t struct qed_ptt *p_ptt,\n\t\t\t\t struct qed_fcoe_stats *p_stats)\n{\n\tstruct fcoe_rx_stat tstats;\n\tu32 tstats_addr;\n\n\tmemset(&tstats, 0, sizeof(tstats));\n\ttstats_addr = BAR0_MAP_REG_TSDM_RAM +\n\t    TSTORM_FCOE_RX_STATS_OFFSET(p_hwfn->rel_pf_id);\n\tqed_memcpy_from(p_hwfn, p_ptt, &tstats, tstats_addr, sizeof(tstats));\n\n\tp_stats->fcoe_rx_byte_cnt = HILO_64_REGPAIR(tstats.fcoe_rx_byte_cnt);\n\tp_stats->fcoe_rx_data_pkt_cnt =\n\t    HILO_64_REGPAIR(tstats.fcoe_rx_data_pkt_cnt);\n\tp_stats->fcoe_rx_xfer_pkt_cnt =\n\t    HILO_64_REGPAIR(tstats.fcoe_rx_xfer_pkt_cnt);\n\tp_stats->fcoe_rx_other_pkt_cnt =\n\t    HILO_64_REGPAIR(tstats.fcoe_rx_other_pkt_cnt);\n\n\tp_stats->fcoe_silent_drop_pkt_cmdq_full_cnt =\n\t    le32_to_cpu(tstats.fcoe_silent_drop_pkt_cmdq_full_cnt);\n\tp_stats->fcoe_silent_drop_pkt_rq_full_cnt =\n\t    le32_to_cpu(tstats.fcoe_silent_drop_pkt_rq_full_cnt);\n\tp_stats->fcoe_silent_drop_pkt_crc_error_cnt =\n\t    le32_to_cpu(tstats.fcoe_silent_drop_pkt_crc_error_cnt);\n\tp_stats->fcoe_silent_drop_pkt_task_invalid_cnt =\n\t    le32_to_cpu(tstats.fcoe_silent_drop_pkt_task_invalid_cnt);\n\tp_stats->fcoe_silent_drop_total_pkt_cnt =\n\t    le32_to_cpu(tstats.fcoe_silent_drop_total_pkt_cnt);\n}\n\nstatic void _qed_fcoe_get_pstats(struct qed_hwfn *p_hwfn,\n\t\t\t\t struct qed_ptt *p_ptt,\n\t\t\t\t struct qed_fcoe_stats *p_stats)\n{\n\tstruct fcoe_tx_stat pstats;\n\tu32 pstats_addr;\n\n\tmemset(&pstats, 0, sizeof(pstats));\n\tpstats_addr = BAR0_MAP_REG_PSDM_RAM +\n\t    PSTORM_FCOE_TX_STATS_OFFSET(p_hwfn->rel_pf_id);\n\tqed_memcpy_from(p_hwfn, p_ptt, &pstats, pstats_addr, sizeof(pstats));\n\n\tp_stats->fcoe_tx_byte_cnt = HILO_64_REGPAIR(pstats.fcoe_tx_byte_cnt);\n\tp_stats->fcoe_tx_data_pkt_cnt =\n\t    HILO_64_REGPAIR(pstats.fcoe_tx_data_pkt_cnt);\n\tp_stats->fcoe_tx_xfer_pkt_cnt =\n\t    HILO_64_REGPAIR(pstats.fcoe_tx_xfer_pkt_cnt);\n\tp_stats->fcoe_tx_other_pkt_cnt =\n\t    HILO_64_REGPAIR(pstats.fcoe_tx_other_pkt_cnt);\n}\n\nstatic int qed_fcoe_get_stats(struct qed_hwfn *p_hwfn,\n\t\t\t      struct qed_fcoe_stats *p_stats,\n\t\t\t      bool is_atomic)\n{\n\tstruct qed_ptt *p_ptt;\n\n\tmemset(p_stats, 0, sizeof(*p_stats));\n\n\tp_ptt = qed_ptt_acquire_context(p_hwfn, is_atomic);\n\n\tif (!p_ptt) {\n\t\tDP_ERR(p_hwfn, \"Failed to acquire ptt\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t_qed_fcoe_get_tstats(p_hwfn, p_ptt, p_stats);\n\t_qed_fcoe_get_pstats(p_hwfn, p_ptt, p_stats);\n\n\tqed_ptt_release(p_hwfn, p_ptt);\n\n\treturn 0;\n}\n\nstruct qed_hash_fcoe_con {\n\tstruct hlist_node node;\n\tstruct qed_fcoe_conn *con;\n};\n\nstatic int qed_fill_fcoe_dev_info(struct qed_dev *cdev,\n\t\t\t\t  struct qed_dev_fcoe_info *info)\n{\n\tstruct qed_hwfn *hwfn = QED_AFFIN_HWFN(cdev);\n\tint rc;\n\n\tmemset(info, 0, sizeof(*info));\n\trc = qed_fill_dev_info(cdev, &info->common);\n\n\tinfo->primary_dbq_rq_addr =\n\t    qed_fcoe_get_primary_bdq_prod(hwfn, BDQ_ID_RQ);\n\tinfo->secondary_bdq_rq_addr =\n\t    qed_fcoe_get_secondary_bdq_prod(hwfn, BDQ_ID_RQ);\n\n\tinfo->wwpn = hwfn->mcp_info->func_info.wwn_port;\n\tinfo->wwnn = hwfn->mcp_info->func_info.wwn_node;\n\n\tinfo->num_cqs = FEAT_NUM(hwfn, QED_FCOE_CQ);\n\n\treturn rc;\n}\n\nstatic void qed_register_fcoe_ops(struct qed_dev *cdev,\n\t\t\t\t  struct qed_fcoe_cb_ops *ops, void *cookie)\n{\n\tcdev->protocol_ops.fcoe = ops;\n\tcdev->ops_cookie = cookie;\n}\n\nstatic struct qed_hash_fcoe_con *qed_fcoe_get_hash(struct qed_dev *cdev,\n\t\t\t\t\t\t   u32 handle)\n{\n\tstruct qed_hash_fcoe_con *hash_con = NULL;\n\n\tif (!(cdev->flags & QED_FLAG_STORAGE_STARTED))\n\t\treturn NULL;\n\n\thash_for_each_possible(cdev->connections, hash_con, node, handle) {\n\t\tif (hash_con->con->icid == handle)\n\t\t\tbreak;\n\t}\n\n\tif (!hash_con || (hash_con->con->icid != handle))\n\t\treturn NULL;\n\n\treturn hash_con;\n}\n\nstatic int qed_fcoe_stop(struct qed_dev *cdev)\n{\n\tstruct qed_ptt *p_ptt;\n\tint rc;\n\n\tif (!(cdev->flags & QED_FLAG_STORAGE_STARTED)) {\n\t\tDP_NOTICE(cdev, \"fcoe already stopped\\n\");\n\t\treturn 0;\n\t}\n\n\tif (!hash_empty(cdev->connections)) {\n\t\tDP_NOTICE(cdev,\n\t\t\t  \"Can't stop fcoe - not all connections were returned\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tp_ptt = qed_ptt_acquire(QED_AFFIN_HWFN(cdev));\n\tif (!p_ptt)\n\t\treturn -EAGAIN;\n\n\t \n\trc = qed_sp_fcoe_func_stop(QED_AFFIN_HWFN(cdev), p_ptt,\n\t\t\t\t   QED_SPQ_MODE_EBLOCK, NULL);\n\tcdev->flags &= ~QED_FLAG_STORAGE_STARTED;\n\tqed_ptt_release(QED_AFFIN_HWFN(cdev), p_ptt);\n\n\treturn rc;\n}\n\nstatic int qed_fcoe_start(struct qed_dev *cdev, struct qed_fcoe_tid *tasks)\n{\n\tint rc;\n\n\tif (cdev->flags & QED_FLAG_STORAGE_STARTED) {\n\t\tDP_NOTICE(cdev, \"fcoe already started;\\n\");\n\t\treturn 0;\n\t}\n\n\trc = qed_sp_fcoe_func_start(QED_AFFIN_HWFN(cdev), QED_SPQ_MODE_EBLOCK,\n\t\t\t\t    NULL);\n\tif (rc) {\n\t\tDP_NOTICE(cdev, \"Failed to start fcoe\\n\");\n\t\treturn rc;\n\t}\n\n\tcdev->flags |= QED_FLAG_STORAGE_STARTED;\n\thash_init(cdev->connections);\n\n\tif (tasks) {\n\t\tstruct qed_tid_mem *tid_info = kzalloc(sizeof(*tid_info),\n\t\t\t\t\t\t       GFP_ATOMIC);\n\n\t\tif (!tid_info) {\n\t\t\tDP_NOTICE(cdev,\n\t\t\t\t  \"Failed to allocate tasks information\\n\");\n\t\t\tqed_fcoe_stop(cdev);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\trc = qed_cxt_get_tid_mem_info(QED_AFFIN_HWFN(cdev), tid_info);\n\t\tif (rc) {\n\t\t\tDP_NOTICE(cdev, \"Failed to gather task information\\n\");\n\t\t\tqed_fcoe_stop(cdev);\n\t\t\tkfree(tid_info);\n\t\t\treturn rc;\n\t\t}\n\n\t\t \n\t\ttasks->size = tid_info->tid_size;\n\t\ttasks->num_tids_per_block = tid_info->num_tids_per_block;\n\t\tmemcpy(tasks->blocks, tid_info->blocks,\n\t\t       MAX_TID_BLOCKS_FCOE * sizeof(u8 *));\n\n\t\tkfree(tid_info);\n\t}\n\n\treturn 0;\n}\n\nstatic int qed_fcoe_acquire_conn(struct qed_dev *cdev,\n\t\t\t\t u32 *handle,\n\t\t\t\t u32 *fw_cid, void __iomem **p_doorbell)\n{\n\tstruct qed_hash_fcoe_con *hash_con;\n\tint rc;\n\n\t \n\thash_con = kzalloc(sizeof(*hash_con), GFP_KERNEL);\n\tif (!hash_con) {\n\t\tDP_NOTICE(cdev, \"Failed to allocate hashed connection\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\trc = qed_fcoe_acquire_connection(QED_AFFIN_HWFN(cdev), NULL,\n\t\t\t\t\t &hash_con->con);\n\tif (rc) {\n\t\tDP_NOTICE(cdev, \"Failed to acquire Connection\\n\");\n\t\tkfree(hash_con);\n\t\treturn rc;\n\t}\n\n\t \n\t*handle = hash_con->con->icid;\n\t*fw_cid = hash_con->con->fw_cid;\n\thash_add(cdev->connections, &hash_con->node, *handle);\n\n\tif (p_doorbell)\n\t\t*p_doorbell = qed_fcoe_get_db_addr(QED_AFFIN_HWFN(cdev),\n\t\t\t\t\t\t   *handle);\n\n\treturn 0;\n}\n\nstatic int qed_fcoe_release_conn(struct qed_dev *cdev, u32 handle)\n{\n\tstruct qed_hash_fcoe_con *hash_con;\n\n\thash_con = qed_fcoe_get_hash(cdev, handle);\n\tif (!hash_con) {\n\t\tDP_NOTICE(cdev, \"Failed to find connection for handle %d\\n\",\n\t\t\t  handle);\n\t\treturn -EINVAL;\n\t}\n\n\thlist_del(&hash_con->node);\n\tqed_fcoe_release_connection(QED_AFFIN_HWFN(cdev), hash_con->con);\n\tkfree(hash_con);\n\n\treturn 0;\n}\n\nstatic int qed_fcoe_offload_conn(struct qed_dev *cdev,\n\t\t\t\t u32 handle,\n\t\t\t\t struct qed_fcoe_params_offload *conn_info)\n{\n\tstruct qed_hash_fcoe_con *hash_con;\n\tstruct qed_fcoe_conn *con;\n\n\thash_con = qed_fcoe_get_hash(cdev, handle);\n\tif (!hash_con) {\n\t\tDP_NOTICE(cdev, \"Failed to find connection for handle %d\\n\",\n\t\t\t  handle);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tcon = hash_con->con;\n\n\tcon->sq_pbl_addr = conn_info->sq_pbl_addr;\n\tcon->sq_curr_page_addr = conn_info->sq_curr_page_addr;\n\tcon->sq_next_page_addr = conn_info->sq_next_page_addr;\n\tcon->tx_max_fc_pay_len = conn_info->tx_max_fc_pay_len;\n\tcon->e_d_tov_timer_val = conn_info->e_d_tov_timer_val;\n\tcon->rec_tov_timer_val = conn_info->rec_tov_timer_val;\n\tcon->rx_max_fc_pay_len = conn_info->rx_max_fc_pay_len;\n\tcon->vlan_tag = conn_info->vlan_tag;\n\tcon->max_conc_seqs_c3 = conn_info->max_conc_seqs_c3;\n\tcon->flags = conn_info->flags;\n\tcon->def_q_idx = conn_info->def_q_idx;\n\n\tcon->src_mac_addr_hi = (conn_info->src_mac[5] << 8) |\n\t    conn_info->src_mac[4];\n\tcon->src_mac_addr_mid = (conn_info->src_mac[3] << 8) |\n\t    conn_info->src_mac[2];\n\tcon->src_mac_addr_lo = (conn_info->src_mac[1] << 8) |\n\t    conn_info->src_mac[0];\n\tcon->dst_mac_addr_hi = (conn_info->dst_mac[5] << 8) |\n\t    conn_info->dst_mac[4];\n\tcon->dst_mac_addr_mid = (conn_info->dst_mac[3] << 8) |\n\t    conn_info->dst_mac[2];\n\tcon->dst_mac_addr_lo = (conn_info->dst_mac[1] << 8) |\n\t    conn_info->dst_mac[0];\n\n\tcon->s_id.addr_hi = conn_info->s_id.addr_hi;\n\tcon->s_id.addr_mid = conn_info->s_id.addr_mid;\n\tcon->s_id.addr_lo = conn_info->s_id.addr_lo;\n\tcon->d_id.addr_hi = conn_info->d_id.addr_hi;\n\tcon->d_id.addr_mid = conn_info->d_id.addr_mid;\n\tcon->d_id.addr_lo = conn_info->d_id.addr_lo;\n\n\treturn qed_sp_fcoe_conn_offload(QED_AFFIN_HWFN(cdev), con,\n\t\t\t\t\tQED_SPQ_MODE_EBLOCK, NULL);\n}\n\nstatic int qed_fcoe_destroy_conn(struct qed_dev *cdev,\n\t\t\t\t u32 handle, dma_addr_t terminate_params)\n{\n\tstruct qed_hash_fcoe_con *hash_con;\n\tstruct qed_fcoe_conn *con;\n\n\thash_con = qed_fcoe_get_hash(cdev, handle);\n\tif (!hash_con) {\n\t\tDP_NOTICE(cdev, \"Failed to find connection for handle %d\\n\",\n\t\t\t  handle);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tcon = hash_con->con;\n\tcon->terminate_params = terminate_params;\n\n\treturn qed_sp_fcoe_conn_destroy(QED_AFFIN_HWFN(cdev), con,\n\t\t\t\t\tQED_SPQ_MODE_EBLOCK, NULL);\n}\n\nstatic int qed_fcoe_stats_context(struct qed_dev *cdev,\n\t\t\t\t  struct qed_fcoe_stats *stats,\n\t\t\t\t  bool is_atomic)\n{\n\treturn qed_fcoe_get_stats(QED_AFFIN_HWFN(cdev), stats, is_atomic);\n}\n\nstatic int qed_fcoe_stats(struct qed_dev *cdev, struct qed_fcoe_stats *stats)\n{\n\treturn qed_fcoe_stats_context(cdev, stats, false);\n}\n\nvoid qed_get_protocol_stats_fcoe(struct qed_dev *cdev,\n\t\t\t\t struct qed_mcp_fcoe_stats *stats,\n\t\t\t\t bool is_atomic)\n{\n\tstruct qed_fcoe_stats proto_stats;\n\n\t \n\tmemset(&proto_stats, 0, sizeof(proto_stats));\n\tif (qed_fcoe_stats_context(cdev, &proto_stats, is_atomic)) {\n\t\tDP_VERBOSE(cdev, QED_MSG_STORAGE,\n\t\t\t   \"Failed to collect FCoE statistics\\n\");\n\t\treturn;\n\t}\n\n\t \n\tstats->rx_pkts = proto_stats.fcoe_rx_data_pkt_cnt +\n\t\t\t proto_stats.fcoe_rx_xfer_pkt_cnt +\n\t\t\t proto_stats.fcoe_rx_other_pkt_cnt;\n\tstats->tx_pkts = proto_stats.fcoe_tx_data_pkt_cnt +\n\t\t\t proto_stats.fcoe_tx_xfer_pkt_cnt +\n\t\t\t proto_stats.fcoe_tx_other_pkt_cnt;\n\tstats->fcs_err = proto_stats.fcoe_silent_drop_pkt_crc_error_cnt;\n\n\t \n\tif (cdev->protocol_ops.fcoe && cdev->ops_cookie) {\n\t\tstruct qed_fcoe_cb_ops *ops = cdev->protocol_ops.fcoe;\n\t\tvoid *cookie = cdev->ops_cookie;\n\n\t\tif (ops->get_login_failures)\n\t\t\tstats->login_failure = ops->get_login_failures(cookie);\n\t}\n}\n\nstatic const struct qed_fcoe_ops qed_fcoe_ops_pass = {\n\t.common = &qed_common_ops_pass,\n\t.ll2 = &qed_ll2_ops_pass,\n\t.fill_dev_info = &qed_fill_fcoe_dev_info,\n\t.start = &qed_fcoe_start,\n\t.stop = &qed_fcoe_stop,\n\t.register_ops = &qed_register_fcoe_ops,\n\t.acquire_conn = &qed_fcoe_acquire_conn,\n\t.release_conn = &qed_fcoe_release_conn,\n\t.offload_conn = &qed_fcoe_offload_conn,\n\t.destroy_conn = &qed_fcoe_destroy_conn,\n\t.get_stats = &qed_fcoe_stats,\n};\n\nconst struct qed_fcoe_ops *qed_get_fcoe_ops(void)\n{\n\treturn &qed_fcoe_ops_pass;\n}\nEXPORT_SYMBOL(qed_get_fcoe_ops);\n\nvoid qed_put_fcoe_ops(void)\n{\n}\nEXPORT_SYMBOL(qed_put_fcoe_ops);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}