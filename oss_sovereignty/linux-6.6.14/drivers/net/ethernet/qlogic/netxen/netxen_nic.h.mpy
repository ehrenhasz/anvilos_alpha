{
  "module_name": "netxen_nic.h",
  "hash_id": "7f118a4e24e447eca8f92dc36a99069d580c992d450e0ddf08acfcc90147f0fd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/qlogic/netxen/netxen_nic.h",
  "human_readable_source": " \n \n\n#ifndef _NETXEN_NIC_H_\n#define _NETXEN_NIC_H_\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/ioport.h>\n#include <linux/pci.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/ip.h>\n#include <linux/in.h>\n#include <linux/tcp.h>\n#include <linux/skbuff.h>\n#include <linux/firmware.h>\n\n#include <linux/ethtool.h>\n#include <linux/mii.h>\n#include <linux/timer.h>\n\n#include <linux/vmalloc.h>\n\n#include <asm/io.h>\n#include <asm/byteorder.h>\n\n#include \"netxen_nic_hdr.h\"\n#include \"netxen_nic_hw.h\"\n\n#define _NETXEN_NIC_LINUX_MAJOR 4\n#define _NETXEN_NIC_LINUX_MINOR 0\n#define _NETXEN_NIC_LINUX_SUBVERSION 82\n#define NETXEN_NIC_LINUX_VERSIONID  \"4.0.82\"\n\n#define NETXEN_VERSION_CODE(a, b, c)\t(((a) << 24) + ((b) << 16) + (c))\n#define _major(v)\t(((v) >> 24) & 0xff)\n#define _minor(v)\t(((v) >> 16) & 0xff)\n#define _build(v)\t((v) & 0xffff)\n\n \n#define NETXEN_DECODE_VERSION(v) \\\n\tNETXEN_VERSION_CODE(((v) & 0xff), (((v) >> 8) & 0xff), ((v) >> 16))\n\n#define NETXEN_NUM_FLASH_SECTORS (64)\n#define NETXEN_FLASH_SECTOR_SIZE (64 * 1024)\n#define NETXEN_FLASH_TOTAL_SIZE  (NETXEN_NUM_FLASH_SECTORS \\\n\t\t\t\t\t* NETXEN_FLASH_SECTOR_SIZE)\n\n#define RCV_DESC_RINGSIZE(rds_ring)\t\\\n\t(sizeof(struct rcv_desc) * (rds_ring)->num_desc)\n#define RCV_BUFF_RINGSIZE(rds_ring)\t\\\n\t(sizeof(struct netxen_rx_buffer) * rds_ring->num_desc)\n#define STATUS_DESC_RINGSIZE(sds_ring)\t\\\n\t(sizeof(struct status_desc) * (sds_ring)->num_desc)\n#define TX_BUFF_RINGSIZE(tx_ring)\t\\\n\t(sizeof(struct netxen_cmd_buffer) * tx_ring->num_desc)\n#define TX_DESC_RINGSIZE(tx_ring)\t\\\n\t(sizeof(struct cmd_desc_type0) * tx_ring->num_desc)\n\n#define find_diff_among(a,b,range) ((a)<(b)?((b)-(a)):((b)+(range)-(a)))\n\n#define NETXEN_RCV_PRODUCER_OFFSET\t0\n#define NETXEN_RCV_PEG_DB_ID\t\t2\n#define NETXEN_HOST_DUMMY_DMA_SIZE 1024\n#define FLASH_SUCCESS 0\n\n#define ADDR_IN_WINDOW1(off)\t\\\n\t((off > NETXEN_CRB_PCIX_HOST2) && (off < NETXEN_CRB_MAX)) ? 1 : 0\n\n#define ADDR_IN_RANGE(addr, low, high)\t\\\n\t(((addr) < (high)) && ((addr) >= (low)))\n\n \n#define NETXEN_CRB_NORMAL(reg)\t\\\n\t((reg) - NETXEN_CRB_PCIX_HOST2 + NETXEN_CRB_PCIX_HOST)\n\n#define NETXEN_CRB_NORMALIZE(adapter, reg) \\\n\tpci_base_offset(adapter, NETXEN_CRB_NORMAL(reg))\n\n#define DB_NORMALIZE(adapter, off) \\\n\t(adapter->ahw.db_base + (off))\n\n#define NX_P2_C0\t\t0x24\n#define NX_P2_C1\t\t0x25\n#define NX_P3_A0\t\t0x30\n#define NX_P3_A2\t\t0x30\n#define NX_P3_B0\t\t0x40\n#define NX_P3_B1\t\t0x41\n#define NX_P3_B2\t\t0x42\n#define NX_P3P_A0\t\t0x50\n\n#define NX_IS_REVISION_P2(REVISION)     (REVISION <= NX_P2_C1)\n#define NX_IS_REVISION_P3(REVISION)     (REVISION >= NX_P3_A0)\n#define NX_IS_REVISION_P3P(REVISION)     (REVISION >= NX_P3P_A0)\n\n#define FIRST_PAGE_GROUP_START\t0\n#define FIRST_PAGE_GROUP_END\t0x100000\n\n#define SECOND_PAGE_GROUP_START\t0x6000000\n#define SECOND_PAGE_GROUP_END\t0x68BC000\n\n#define THIRD_PAGE_GROUP_START\t0x70E4000\n#define THIRD_PAGE_GROUP_END\t0x8000000\n\n#define FIRST_PAGE_GROUP_SIZE  FIRST_PAGE_GROUP_END - FIRST_PAGE_GROUP_START\n#define SECOND_PAGE_GROUP_SIZE SECOND_PAGE_GROUP_END - SECOND_PAGE_GROUP_START\n#define THIRD_PAGE_GROUP_SIZE  THIRD_PAGE_GROUP_END - THIRD_PAGE_GROUP_START\n\n#define P2_MAX_MTU                     (8000)\n#define P3_MAX_MTU                     (9600)\n#define NX_ETHERMTU                    1500\n#define NX_MAX_ETHERHDR                32  \n\n#define NX_P2_RX_BUF_MAX_LEN           1760\n#define NX_P3_RX_BUF_MAX_LEN           (NX_MAX_ETHERHDR + NX_ETHERMTU)\n#define NX_P2_RX_JUMBO_BUF_MAX_LEN     (NX_MAX_ETHERHDR + P2_MAX_MTU)\n#define NX_P3_RX_JUMBO_BUF_MAX_LEN     (NX_MAX_ETHERHDR + P3_MAX_MTU)\n#define NX_CT_DEFAULT_RX_BUF_LEN\t2048\n#define NX_LRO_BUFFER_EXTRA\t\t2048\n\n#define NX_RX_LRO_BUFFER_LENGTH\t\t(8060)\n\n \n#define MAX_RING_CTX 1\n\n \n#define TX_ETHER_PKT\t0x01\n#define TX_TCP_PKT\t0x02\n#define TX_UDP_PKT\t0x03\n#define TX_IP_PKT\t0x04\n#define TX_TCP_LSO\t0x05\n#define TX_TCP_LSO6\t0x06\n#define TX_IPSEC\t0x07\n#define TX_IPSEC_CMD\t0x0a\n#define TX_TCPV6_PKT\t0x0b\n#define TX_UDPV6_PKT\t0x0c\n\n \n#define NETXEN_CONTROL_OP\t0x10\n#define PEGNET_REQUEST\t\t0x11\n\n#define\tMAX_NUM_CARDS\t\t4\n\n#define NETXEN_MAX_FRAGS_PER_TX\t14\n#define MAX_TSO_HEADER_DESC\t2\n#define MGMT_CMD_DESC_RESV\t4\n#define TX_STOP_THRESH\t\t((MAX_SKB_FRAGS >> 2) + MAX_TSO_HEADER_DESC \\\n\t\t\t\t\t\t\t+ MGMT_CMD_DESC_RESV)\n#define NX_MAX_TX_TIMEOUTS\t2\n\n \n#define PHAN_INITIALIZE_START\t\t0xff00\n#define PHAN_INITIALIZE_FAILED\t\t0xffff\n#define PHAN_INITIALIZE_COMPLETE\t0xff01\n\n \n#define PHAN_INITIALIZE_ACK\t0xf00f\n\n#define NUM_RCV_DESC_RINGS\t3\n#define NUM_STS_DESC_RINGS\t4\n\n#define RCV_RING_NORMAL\t0\n#define RCV_RING_JUMBO\t1\n#define RCV_RING_LRO\t2\n\n#define MIN_CMD_DESCRIPTORS\t\t64\n#define MIN_RCV_DESCRIPTORS\t\t64\n#define MIN_JUMBO_DESCRIPTORS\t\t32\n\n#define MAX_CMD_DESCRIPTORS\t\t1024\n#define MAX_RCV_DESCRIPTORS_1G\t\t4096\n#define MAX_RCV_DESCRIPTORS_10G\t\t8192\n#define MAX_JUMBO_RCV_DESCRIPTORS_1G\t512\n#define MAX_JUMBO_RCV_DESCRIPTORS_10G\t1024\n#define MAX_LRO_RCV_DESCRIPTORS\t\t8\n\n#define DEFAULT_RCV_DESCRIPTORS_1G\t2048\n#define DEFAULT_RCV_DESCRIPTORS_10G\t4096\n\n#define NETXEN_CTX_SIGNATURE\t0xdee0\n#define NETXEN_CTX_SIGNATURE_V2\t0x0002dee0\n#define NETXEN_CTX_RESET\t0xbad0\n#define NETXEN_CTX_D3_RESET\t0xacc0\n#define NETXEN_RCV_PRODUCER(ringid)\t(ringid)\n\n#define PHAN_PEG_RCV_INITIALIZED\t0xff01\n#define PHAN_PEG_RCV_START_INITIALIZE\t0xff00\n\n#define get_next_index(index, length)\t\\\n\t(((index) + 1) & ((length) - 1))\n\n#define get_index_range(index,length,count)\t\\\n\t(((index) + (count)) & ((length) - 1))\n\n#define MPORT_SINGLE_FUNCTION_MODE 0x1111\n#define MPORT_MULTI_FUNCTION_MODE 0x2222\n\n#define NX_MAX_PCI_FUNC\t\t8\n\n \n\ntypedef u32 netxen_ctx_msg;\n\n#define netxen_set_msg_peg_id(config_word, val)\t\\\n\t((config_word) &= ~3, (config_word) |= val & 3)\n#define netxen_set_msg_privid(config_word)\t\\\n\t((config_word) |= 1 << 2)\n#define netxen_set_msg_count(config_word, val)\t\\\n\t((config_word) &= ~(0x7fff<<3), (config_word) |= (val & 0x7fff) << 3)\n#define netxen_set_msg_ctxid(config_word, val)\t\\\n\t((config_word) &= ~(0x3ff<<18), (config_word) |= (val & 0x3ff) << 18)\n#define netxen_set_msg_opcode(config_word, val)\t\\\n\t((config_word) &= ~(0xf<<28), (config_word) |= (val & 0xf) << 28)\n\nstruct netxen_rcv_ring {\n\t__le64 addr;\n\t__le32 size;\n\t__le32 rsrvd;\n};\n\nstruct netxen_sts_ring {\n\t__le64 addr;\n\t__le32 size;\n\t__le16 msi_index;\n\t__le16 rsvd;\n} ;\n\nstruct netxen_ring_ctx {\n\n\t \n\t__le64 cmd_consumer_offset;\n\t__le64 cmd_ring_addr;\n\t__le32 cmd_ring_size;\n\t__le32 rsrvd;\n\n\t \n\tstruct netxen_rcv_ring rcv_rings[NUM_RCV_DESC_RINGS];\n\n\t__le64 sts_ring_addr;\n\t__le32 sts_ring_size;\n\n\t__le32 ctx_id;\n\n\t__le64 rsrvd_2[3];\n\t__le32 sts_ring_count;\n\t__le32 rsrvd_3;\n\tstruct netxen_sts_ring sts_rings[NUM_STS_DESC_RINGS];\n\n} __attribute__ ((aligned(64)));\n\n \n\n \n\n#define FLAGS_CHECKSUM_ENABLED\t0x01\n#define FLAGS_LSO_ENABLED\t0x02\n#define FLAGS_IPSEC_SA_ADD\t0x04\n#define FLAGS_IPSEC_SA_DELETE\t0x08\n#define FLAGS_VLAN_TAGGED\t0x10\n#define FLAGS_VLAN_OOB\t\t0x40\n\n#define netxen_set_tx_vlan_tci(cmd_desc, v)\t\\\n\t(cmd_desc)->vlan_TCI = cpu_to_le16(v);\n\n#define netxen_set_cmd_desc_port(cmd_desc, var)\t\\\n\t((cmd_desc)->port_ctxid |= ((var) & 0x0F))\n#define netxen_set_cmd_desc_ctxid(cmd_desc, var)\t\\\n\t((cmd_desc)->port_ctxid |= ((var) << 4 & 0xF0))\n\n#define netxen_set_tx_port(_desc, _port) \\\n\t(_desc)->port_ctxid = ((_port) & 0xf) | (((_port) << 4) & 0xf0)\n\n#define netxen_set_tx_flags_opcode(_desc, _flags, _opcode) \\\n\t(_desc)->flags_opcode = \\\n\tcpu_to_le16(((_flags) & 0x7f) | (((_opcode) & 0x3f) << 7))\n\n#define netxen_set_tx_frags_len(_desc, _frags, _len) \\\n\t(_desc)->nfrags__length = \\\n\tcpu_to_le32(((_frags) & 0xff) | (((_len) & 0xffffff) << 8))\n\nstruct cmd_desc_type0 {\n\tu8 tcp_hdr_offset;\t \n\tu8 ip_hdr_offset;\t \n\t__le16 flags_opcode;\t \n\t__le32 nfrags__length;\t \n\n\t__le64 addr_buffer2;\n\n\t__le16 reference_handle;\n\t__le16 mss;\n\tu8 port_ctxid;\t\t \n\tu8 total_hdr_length;\t \n\t__le16 conn_id;\t\t \n\n\t__le64 addr_buffer3;\n\t__le64 addr_buffer1;\n\n\t__le16 buffer_length[4];\n\n\t__le64 addr_buffer4;\n\n\t__le32 reserved2;\n\t__le16 reserved;\n\t__le16 vlan_TCI;\n\n} __attribute__ ((aligned(64)));\n\n \nstruct rcv_desc {\n\t__le16 reference_handle;\n\t__le16 reserved;\n\t__le32 buffer_length;\t \n\t__le64 addr_buffer;\n};\n\n \n#define NETXEN_NIC_SYN_OFFLOAD  0x03\n#define NETXEN_NIC_RXPKT_DESC  0x04\n#define NETXEN_OLD_RXPKT_DESC  0x3f\n#define NETXEN_NIC_RESPONSE_DESC 0x05\n#define NETXEN_NIC_LRO_DESC  \t0x12\n\n \n#define STATUS_NEED_CKSUM\t(1)\n#define STATUS_CKSUM_OK\t\t(2)\n\n \n#define STATUS_OWNER_HOST\t(0x1ULL << 56)\n#define STATUS_OWNER_PHANTOM\t(0x2ULL << 56)\n\n \n#define netxen_get_sts_port(sts_data)\t\\\n\t((sts_data) & 0x0F)\n#define netxen_get_sts_status(sts_data)\t\\\n\t(((sts_data) >> 4) & 0x0F)\n#define netxen_get_sts_type(sts_data)\t\\\n\t(((sts_data) >> 8) & 0x0F)\n#define netxen_get_sts_totallength(sts_data)\t\\\n\t(((sts_data) >> 12) & 0xFFFF)\n#define netxen_get_sts_refhandle(sts_data)\t\\\n\t(((sts_data) >> 28) & 0xFFFF)\n#define netxen_get_sts_prot(sts_data)\t\\\n\t(((sts_data) >> 44) & 0x0F)\n#define netxen_get_sts_pkt_offset(sts_data)\t\\\n\t(((sts_data) >> 48) & 0x1F)\n#define netxen_get_sts_desc_cnt(sts_data)\t\\\n\t(((sts_data) >> 53) & 0x7)\n#define netxen_get_sts_opcode(sts_data)\t\\\n\t(((sts_data) >> 58) & 0x03F)\n\n#define netxen_get_lro_sts_refhandle(sts_data) \t\\\n\t((sts_data) & 0x0FFFF)\n#define netxen_get_lro_sts_length(sts_data)\t\\\n\t(((sts_data) >> 16) & 0x0FFFF)\n#define netxen_get_lro_sts_l2_hdr_offset(sts_data)\t\\\n\t(((sts_data) >> 32) & 0x0FF)\n#define netxen_get_lro_sts_l4_hdr_offset(sts_data)\t\\\n\t(((sts_data) >> 40) & 0x0FF)\n#define netxen_get_lro_sts_timestamp(sts_data)\t\\\n\t(((sts_data) >> 48) & 0x1)\n#define netxen_get_lro_sts_type(sts_data)\t\\\n\t(((sts_data) >> 49) & 0x7)\n#define netxen_get_lro_sts_push_flag(sts_data)\t\t\\\n\t(((sts_data) >> 52) & 0x1)\n#define netxen_get_lro_sts_seq_number(sts_data)\t\t\\\n\t((sts_data) & 0x0FFFFFFFF)\n#define netxen_get_lro_sts_mss(sts_data1)\t\t\\\n\t((sts_data1 >> 32) & 0x0FFFF)\n\n\nstruct status_desc {\n\t__le64 status_desc_data[2];\n} __attribute__ ((aligned(16)));\n\n \n#define NX_UNI_DIR_SECT_PRODUCT_TBL\t0x0\n#define NX_UNI_DIR_SECT_BOOTLD\t\t0x6\n#define NX_UNI_DIR_SECT_FW\t\t0x7\n\n \n#define NX_UNI_CHIP_REV_OFF\t\t10\n#define NX_UNI_FLAGS_OFF\t\t11\n#define NX_UNI_BIOS_VERSION_OFF \t12\n#define NX_UNI_BOOTLD_IDX_OFF\t\t27\n#define NX_UNI_FIRMWARE_IDX_OFF \t29\n\nstruct uni_table_desc{\n\tuint32_t\tfindex;\n\tuint32_t\tnum_entries;\n\tuint32_t\tentry_size;\n\tuint32_t\treserved[5];\n};\n\nstruct uni_data_desc{\n\tuint32_t\tfindex;\n\tuint32_t\tsize;\n\tuint32_t\treserved[5];\n};\n\n \n\n \n#define\tNETXEN_BDINFO_VERSION 1\n\n \n#define\tNETXEN_BDINFO_MAGIC 0x12345678\n\n \n#define NETXEN_MAX_PORTS 4\n\n#define NETXEN_BRDTYPE_P1_BD\t\t0x0000\n#define NETXEN_BRDTYPE_P1_SB\t\t0x0001\n#define NETXEN_BRDTYPE_P1_SMAX\t\t0x0002\n#define NETXEN_BRDTYPE_P1_SOCK\t\t0x0003\n\n#define NETXEN_BRDTYPE_P2_SOCK_31\t0x0008\n#define NETXEN_BRDTYPE_P2_SOCK_35\t0x0009\n#define NETXEN_BRDTYPE_P2_SB35_4G\t0x000a\n#define NETXEN_BRDTYPE_P2_SB31_10G\t0x000b\n#define NETXEN_BRDTYPE_P2_SB31_2G\t0x000c\n\n#define NETXEN_BRDTYPE_P2_SB31_10G_IMEZ\t\t0x000d\n#define NETXEN_BRDTYPE_P2_SB31_10G_HMEZ\t\t0x000e\n#define NETXEN_BRDTYPE_P2_SB31_10G_CX4\t\t0x000f\n\n#define NETXEN_BRDTYPE_P3_REF_QG\t0x0021\n#define NETXEN_BRDTYPE_P3_HMEZ\t\t0x0022\n#define NETXEN_BRDTYPE_P3_10G_CX4_LP\t0x0023\n#define NETXEN_BRDTYPE_P3_4_GB\t\t0x0024\n#define NETXEN_BRDTYPE_P3_IMEZ\t\t0x0025\n#define NETXEN_BRDTYPE_P3_10G_SFP_PLUS\t0x0026\n#define NETXEN_BRDTYPE_P3_10000_BASE_T\t0x0027\n#define NETXEN_BRDTYPE_P3_XG_LOM\t0x0028\n#define NETXEN_BRDTYPE_P3_4_GB_MM\t0x0029\n#define NETXEN_BRDTYPE_P3_10G_SFP_CT\t0x002a\n#define NETXEN_BRDTYPE_P3_10G_SFP_QT\t0x002b\n#define NETXEN_BRDTYPE_P3_10G_CX4\t0x0031\n#define NETXEN_BRDTYPE_P3_10G_XFP\t0x0032\n#define NETXEN_BRDTYPE_P3_10G_TP\t0x0080\n\n \n#define NETXEN_CRBINIT_START\t0\t \n#define NETXEN_BRDCFG_START\t0x4000\t \n#define NETXEN_INITCODE_START\t0x6000\t \n#define NETXEN_BOOTLD_START\t0x10000\t \n#define NETXEN_IMAGE_START\t0x43000\t \n#define NETXEN_SECONDARY_START\t0x200000\t \n#define NETXEN_PXE_START\t0x3E0000\t \n#define NETXEN_USER_START\t0x3E8000\t \n#define NETXEN_FIXED_START\t0x3F0000\t \n#define NETXEN_USER_START_OLD\tNETXEN_PXE_START  \n\n#define NX_OLD_MAC_ADDR_OFFSET\t(NETXEN_USER_START)\n#define NX_FW_VERSION_OFFSET\t(NETXEN_USER_START+0x408)\n#define NX_FW_SIZE_OFFSET\t(NETXEN_USER_START+0x40c)\n#define NX_FW_MAC_ADDR_OFFSET\t(NETXEN_USER_START+0x418)\n#define NX_FW_SERIAL_NUM_OFFSET\t(NETXEN_USER_START+0x81c)\n#define NX_BIOS_VERSION_OFFSET\t(NETXEN_USER_START+0x83c)\n\n#define NX_HDR_VERSION_OFFSET\t(NETXEN_BRDCFG_START)\n#define NX_BRDTYPE_OFFSET\t(NETXEN_BRDCFG_START+0x8)\n#define NX_FW_MAGIC_OFFSET\t(NETXEN_BRDCFG_START+0x128)\n\n#define NX_FW_MIN_SIZE\t\t(0x3fffff)\n#define NX_P2_MN_ROMIMAGE\t0\n#define NX_P3_CT_ROMIMAGE\t1\n#define NX_P3_MN_ROMIMAGE\t2\n#define NX_UNIFIED_ROMIMAGE\t3\n#define NX_FLASH_ROMIMAGE\t4\n#define NX_UNKNOWN_ROMIMAGE\t0xff\n\n#define NX_P2_MN_ROMIMAGE_NAME\t\t\"nxromimg.bin\"\n#define NX_P3_CT_ROMIMAGE_NAME\t\t\"nx3fwct.bin\"\n#define NX_P3_MN_ROMIMAGE_NAME\t\t\"nx3fwmn.bin\"\n#define NX_UNIFIED_ROMIMAGE_NAME\t\"phanfw.bin\"\n#define NX_FLASH_ROMIMAGE_NAME\t\t\"flash\"\n\nextern char netxen_nic_driver_name[];\n\n \n#define MAX_STATUS_HANDLE\t(64)\n\n \nstruct netxen_skb_frag {\n\tu64 dma;\n\tu64 length;\n};\n\nstruct netxen_recv_crb {\n\tu32 crb_rcv_producer[NUM_RCV_DESC_RINGS];\n\tu32 crb_sts_consumer[NUM_STS_DESC_RINGS];\n\tu32 sw_int_mask[NUM_STS_DESC_RINGS];\n};\n\n \n#define\tNETXEN_BUFFER_FREE\t0\n#define\tNETXEN_BUFFER_BUSY\t1\n\n \nstruct netxen_cmd_buffer {\n\tstruct sk_buff *skb;\n\tstruct netxen_skb_frag frag_array[MAX_SKB_FRAGS + 1];\n\tu32 frag_count;\n};\n\n \nstruct netxen_rx_buffer {\n\tstruct list_head list;\n\tstruct sk_buff *skb;\n\tu64 dma;\n\tu16 ref_handle;\n\tu16 state;\n};\n\n \n#define\tNETXEN_NIC_GBE\t0x01\n#define\tNETXEN_NIC_XGBE\t0x02\n\n \nstruct netxen_hardware_context {\n\tvoid __iomem *pci_base0;\n\tvoid __iomem *pci_base1;\n\tvoid __iomem *pci_base2;\n\tvoid __iomem *db_base;\n\tvoid __iomem *ocm_win_crb;\n\n\tunsigned long db_len;\n\tunsigned long pci_len0;\n\n\tu32 ocm_win;\n\tu32 crb_win;\n\n\trwlock_t crb_lock;\n\tspinlock_t mem_lock;\n\n\tu8 cut_through;\n\tu8 revision_id;\n\tu8 pci_func;\n\tu8 linkup;\n\tu16 port_type;\n\tu16 board_type;\n};\n\n#define MINIMUM_ETHERNET_FRAME_SIZE\t64\t \n#define ETHERNET_FCS_SIZE\t\t4\n\nstruct netxen_adapter_stats {\n\tu64  xmitcalled;\n\tu64  xmitfinished;\n\tu64  rxdropped;\n\tu64  txdropped;\n\tu64  csummed;\n\tu64  rx_pkts;\n\tu64  lro_pkts;\n\tu64  rxbytes;\n\tu64  txbytes;\n};\n\n \nstruct nx_host_rds_ring {\n\tu32 producer;\n\tu32 num_desc;\n\tu32 dma_size;\n\tu32 skb_size;\n\tu32 flags;\n\tvoid __iomem *crb_rcv_producer;\n\tstruct rcv_desc *desc_head;\n\tstruct netxen_rx_buffer *rx_buf_arr;\n\tstruct list_head free_list;\n\tspinlock_t lock;\n\tdma_addr_t phys_addr;\n};\n\nstruct nx_host_sds_ring {\n\tu32 consumer;\n\tu32 num_desc;\n\tvoid __iomem *crb_sts_consumer;\n\tvoid __iomem *crb_intr_mask;\n\n\tstruct status_desc *desc_head;\n\tstruct netxen_adapter *adapter;\n\tstruct napi_struct napi;\n\tstruct list_head free_list[NUM_RCV_DESC_RINGS];\n\n\tint irq;\n\n\tdma_addr_t phys_addr;\n\tchar name[IFNAMSIZ+4];\n};\n\nstruct nx_host_tx_ring {\n\tu32 producer;\n\t__le32 *hw_consumer;\n\tu32 sw_consumer;\n\tvoid __iomem *crb_cmd_producer;\n\tvoid __iomem *crb_cmd_consumer;\n\tu32 num_desc;\n\n\tstruct netdev_queue *txq;\n\n\tstruct netxen_cmd_buffer *cmd_buf_arr;\n\tstruct cmd_desc_type0 *desc_head;\n\tdma_addr_t phys_addr;\n};\n\n \nstruct netxen_recv_context {\n\tu32 state;\n\tu16 context_id;\n\tu16 virt_port;\n\n\tstruct nx_host_rds_ring *rds_rings;\n\tstruct nx_host_sds_ring *sds_rings;\n\n\tstruct netxen_ring_ctx *hwctx;\n\tdma_addr_t phys_addr;\n};\n\nstruct _cdrp_cmd {\n\tu32 cmd;\n\tu32 arg1;\n\tu32 arg2;\n\tu32 arg3;\n};\n\nstruct netxen_cmd_args {\n\tstruct _cdrp_cmd req;\n\tstruct _cdrp_cmd rsp;\n};\n\n \n\n#define NX_OS_CRB_RETRY_COUNT\t4000\n#define NX_CDRP_SIGNATURE_MAKE(pcifn, version) \\\n\t(((pcifn) & 0xff) | (((version) & 0xff) << 8) | (0xcafe << 16))\n\n#define NX_CDRP_CLEAR\t\t0x00000000\n#define NX_CDRP_CMD_BIT\t\t0x80000000\n\n \n#define NX_CDRP_FORM_RSP(rsp)\t(rsp)\n#define NX_CDRP_IS_RSP(rsp)\t(((rsp) & NX_CDRP_CMD_BIT) == 0)\n\n#define NX_CDRP_RSP_OK\t\t0x00000001\n#define NX_CDRP_RSP_FAIL\t0x00000002\n#define NX_CDRP_RSP_TIMEOUT\t0x00000003\n\n \n#define NX_CDRP_FORM_CMD(cmd)\t(NX_CDRP_CMD_BIT | (cmd))\n#define NX_CDRP_IS_CMD(cmd)\t(((cmd) & NX_CDRP_CMD_BIT) != 0)\n\n#define NX_CDRP_CMD_SUBMIT_CAPABILITIES     0x00000001\n#define NX_CDRP_CMD_READ_MAX_RDS_PER_CTX    0x00000002\n#define NX_CDRP_CMD_READ_MAX_SDS_PER_CTX    0x00000003\n#define NX_CDRP_CMD_READ_MAX_RULES_PER_CTX  0x00000004\n#define NX_CDRP_CMD_READ_MAX_RX_CTX         0x00000005\n#define NX_CDRP_CMD_READ_MAX_TX_CTX         0x00000006\n#define NX_CDRP_CMD_CREATE_RX_CTX           0x00000007\n#define NX_CDRP_CMD_DESTROY_RX_CTX          0x00000008\n#define NX_CDRP_CMD_CREATE_TX_CTX           0x00000009\n#define NX_CDRP_CMD_DESTROY_TX_CTX          0x0000000a\n#define NX_CDRP_CMD_SETUP_STATISTICS        0x0000000e\n#define NX_CDRP_CMD_GET_STATISTICS          0x0000000f\n#define NX_CDRP_CMD_DELETE_STATISTICS       0x00000010\n#define NX_CDRP_CMD_SET_MTU                 0x00000012\n#define NX_CDRP_CMD_READ_PHY\t\t\t0x00000013\n#define NX_CDRP_CMD_WRITE_PHY\t\t\t0x00000014\n#define NX_CDRP_CMD_READ_HW_REG\t\t\t0x00000015\n#define NX_CDRP_CMD_GET_FLOW_CTL\t\t0x00000016\n#define NX_CDRP_CMD_SET_FLOW_CTL\t\t0x00000017\n#define NX_CDRP_CMD_READ_MAX_MTU\t\t0x00000018\n#define NX_CDRP_CMD_READ_MAX_LRO\t\t0x00000019\n#define NX_CDRP_CMD_CONFIGURE_TOE\t\t0x0000001a\n#define NX_CDRP_CMD_FUNC_ATTRIB\t\t\t0x0000001b\n#define NX_CDRP_CMD_READ_PEXQ_PARAMETERS\t0x0000001c\n#define NX_CDRP_CMD_GET_LIC_CAPABILITIES\t0x0000001d\n#define NX_CDRP_CMD_READ_MAX_LRO_PER_BOARD\t0x0000001e\n#define NX_CDRP_CMD_CONFIG_GBE_PORT\t\t0x0000001f\n#define NX_CDRP_CMD_MAX\t\t\t\t0x00000020\n\n#define NX_RCODE_SUCCESS\t\t0\n#define NX_RCODE_NO_HOST_MEM\t\t1\n#define NX_RCODE_NO_HOST_RESOURCE\t2\n#define NX_RCODE_NO_CARD_CRB\t\t3\n#define NX_RCODE_NO_CARD_MEM\t\t4\n#define NX_RCODE_NO_CARD_RESOURCE\t5\n#define NX_RCODE_INVALID_ARGS\t\t6\n#define NX_RCODE_INVALID_ACTION\t\t7\n#define NX_RCODE_INVALID_STATE\t\t8\n#define NX_RCODE_NOT_SUPPORTED\t\t9\n#define NX_RCODE_NOT_PERMITTED\t\t10\n#define NX_RCODE_NOT_READY\t\t11\n#define NX_RCODE_DOES_NOT_EXIST\t\t12\n#define NX_RCODE_ALREADY_EXISTS\t\t13\n#define NX_RCODE_BAD_SIGNATURE\t\t14\n#define NX_RCODE_CMD_NOT_IMPL\t\t15\n#define NX_RCODE_CMD_INVALID\t\t16\n#define NX_RCODE_TIMEOUT\t\t17\n#define NX_RCODE_CMD_FAILED\t\t18\n#define NX_RCODE_MAX_EXCEEDED\t\t19\n#define NX_RCODE_MAX\t\t\t20\n\n#define NX_DESTROY_CTX_RESET\t\t0\n#define NX_DESTROY_CTX_D3_RESET\t\t1\n#define NX_DESTROY_CTX_MAX\t\t2\n\n \n#define NX_CAP_BIT(class, bit)\t\t(1 << bit)\n#define NX_CAP0_LEGACY_CONTEXT\t\tNX_CAP_BIT(0, 0)\n#define NX_CAP0_MULTI_CONTEXT\t\tNX_CAP_BIT(0, 1)\n#define NX_CAP0_LEGACY_MN\t\tNX_CAP_BIT(0, 2)\n#define NX_CAP0_LEGACY_MS\t\tNX_CAP_BIT(0, 3)\n#define NX_CAP0_CUT_THROUGH\t\tNX_CAP_BIT(0, 4)\n#define NX_CAP0_LRO\t\t\tNX_CAP_BIT(0, 5)\n#define NX_CAP0_LSO\t\t\tNX_CAP_BIT(0, 6)\n#define NX_CAP0_JUMBO_CONTIGUOUS\tNX_CAP_BIT(0, 7)\n#define NX_CAP0_LRO_CONTIGUOUS\t\tNX_CAP_BIT(0, 8)\n#define NX_CAP0_HW_LRO\t\t\tNX_CAP_BIT(0, 10)\n#define NX_CAP0_HW_LRO_MSS\t\tNX_CAP_BIT(0, 21)\n\n \n#define NX_HOST_CTX_STATE_FREED\t\t0\n#define NX_HOST_CTX_STATE_ALLOCATED\t1\n#define NX_HOST_CTX_STATE_ACTIVE\t2\n#define NX_HOST_CTX_STATE_DISABLED\t3\n#define NX_HOST_CTX_STATE_QUIESCED\t4\n#define NX_HOST_CTX_STATE_MAX\t\t5\n\n \n\ntypedef struct {\n\t__le64 host_phys_addr;\t \n\t__le32 ring_size;\t\t \n\t__le16 msi_index;\n\t__le16 rsvd;\t\t \n} nx_hostrq_sds_ring_t;\n\ntypedef struct {\n\t__le64 host_phys_addr;\t \n\t__le64 buff_size;\t\t \n\t__le32 ring_size;\t\t \n\t__le32 ring_kind;\t\t \n} nx_hostrq_rds_ring_t;\n\ntypedef struct {\n\t__le64 host_rsp_dma_addr;\t \n\t__le32 capabilities[4];\t \n\t__le32 host_int_crb_mode;\t \n\t__le32 host_rds_crb_mode;\t \n\t \n\t__le32 rds_ring_offset;\t \n\t__le32 sds_ring_offset;\t \n\t__le16 num_rds_rings;\t \n\t__le16 num_sds_rings;\t \n\t__le16 rsvd1;\t\t \n\t__le16 rsvd2;\t\t \n\tu8  reserved[128]; \t \n\t \n\tchar data[0];\n} nx_hostrq_rx_ctx_t;\n\ntypedef struct {\n\t__le32 host_producer_crb;\t \n\t__le32 rsvd1;\t\t \n} nx_cardrsp_rds_ring_t;\n\ntypedef struct {\n\t__le32 host_consumer_crb;\t \n\t__le32 interrupt_crb;\t \n} nx_cardrsp_sds_ring_t;\n\ntypedef struct {\n\t \n\t__le32 rds_ring_offset;\t \n\t__le32 sds_ring_offset;\t \n\t__le32 host_ctx_state;\t \n\t__le32 num_fn_per_port;\t \n\t__le16 num_rds_rings;\t \n\t__le16 num_sds_rings;\t \n\t__le16 context_id;\t\t \n\tu8  phys_port;\t\t \n\tu8  virt_port;\t\t \n\tu8  reserved[128];\t \n\t \n\tchar data[];\n} nx_cardrsp_rx_ctx_t;\n\n#define SIZEOF_HOSTRQ_RX(HOSTRQ_RX, rds_rings, sds_rings)\t\\\n\t(sizeof(HOSTRQ_RX) + \t\t\t\t\t\\\n\t(rds_rings)*(sizeof(nx_hostrq_rds_ring_t)) +\t\t\\\n\t(sds_rings)*(sizeof(nx_hostrq_sds_ring_t)))\n\n#define SIZEOF_CARDRSP_RX(CARDRSP_RX, rds_rings, sds_rings) \t\\\n\t(sizeof(CARDRSP_RX) + \t\t\t\t\t\\\n\t(rds_rings)*(sizeof(nx_cardrsp_rds_ring_t)) + \t\t\\\n\t(sds_rings)*(sizeof(nx_cardrsp_sds_ring_t)))\n\n \n\ntypedef struct {\n\t__le64 host_phys_addr;\t \n\t__le32 ring_size;\t\t \n\t__le32 rsvd;\t\t \n} nx_hostrq_cds_ring_t;\n\ntypedef struct {\n\t__le64 host_rsp_dma_addr;\t \n\t__le64 cmd_cons_dma_addr;\t \n\t__le64 dummy_dma_addr;\t \n\t__le32 capabilities[4];\t \n\t__le32 host_int_crb_mode;\t \n\t__le32 rsvd1;\t\t \n\t__le16 rsvd2;\t\t \n\t__le16 interrupt_ctl;\n\t__le16 msi_index;\n\t__le16 rsvd3;\t\t \n\tnx_hostrq_cds_ring_t cds_ring;\t \n\tu8  reserved[128];\t \n} nx_hostrq_tx_ctx_t;\n\ntypedef struct {\n\t__le32 host_producer_crb;\t \n\t__le32 interrupt_crb;\t \n} nx_cardrsp_cds_ring_t;\n\ntypedef struct {\n\t__le32 host_ctx_state;\t \n\t__le16 context_id;\t\t \n\tu8  phys_port;\t\t \n\tu8  virt_port;\t\t \n\tnx_cardrsp_cds_ring_t cds_ring;\t \n\tu8  reserved[128];\t \n} nx_cardrsp_tx_ctx_t;\n\n#define SIZEOF_HOSTRQ_TX(HOSTRQ_TX)\t(sizeof(HOSTRQ_TX))\n#define SIZEOF_CARDRSP_TX(CARDRSP_TX)\t(sizeof(CARDRSP_TX))\n\n \n\n#define NX_HOST_RDS_CRB_MODE_UNIQUE\t0\n#define NX_HOST_RDS_CRB_MODE_SHARED\t1\n#define NX_HOST_RDS_CRB_MODE_CUSTOM\t2\n#define NX_HOST_RDS_CRB_MODE_MAX\t3\n\n#define NX_HOST_INT_CRB_MODE_UNIQUE\t0\n#define NX_HOST_INT_CRB_MODE_SHARED\t1\n#define NX_HOST_INT_CRB_MODE_NORX\t2\n#define NX_HOST_INT_CRB_MODE_NOTX\t3\n#define NX_HOST_INT_CRB_MODE_NORXTX\t4\n\n\n \n\n#define MC_COUNT_P2\t16\n#define MC_COUNT_P3\t38\n\n#define NETXEN_MAC_NOOP\t0\n#define NETXEN_MAC_ADD\t1\n#define NETXEN_MAC_DEL\t2\n\ntypedef struct nx_mac_list_s {\n\tstruct list_head list;\n\tuint8_t mac_addr[ETH_ALEN+2];\n} nx_mac_list_t;\n\nstruct nx_ip_list {\n\tstruct list_head list;\n\t__be32 ip_addr;\n\tbool master;\n};\n\n \n#define NETXEN_DEFAULT_INTR_COALESCE_RX_TIME_US\t3\n#define NETXEN_DEFAULT_INTR_COALESCE_RX_PACKETS\t256\n#define NETXEN_DEFAULT_INTR_COALESCE_TX_PACKETS\t64\n#define NETXEN_DEFAULT_INTR_COALESCE_TX_TIME_US\t4\n\n#define NETXEN_NIC_INTR_DEFAULT\t\t\t0x04\n\ntypedef union {\n\tstruct {\n\t\tuint16_t\trx_packets;\n\t\tuint16_t\trx_time_us;\n\t\tuint16_t\ttx_packets;\n\t\tuint16_t\ttx_time_us;\n\t} data;\n\tuint64_t\t\tword;\n} nx_nic_intr_coalesce_data_t;\n\ntypedef struct {\n\tuint16_t\t\t\tstats_time_us;\n\tuint16_t\t\t\trate_sample_time;\n\tuint16_t\t\t\tflags;\n\tuint16_t\t\t\trsvd_1;\n\tuint32_t\t\t\tlow_threshold;\n\tuint32_t\t\t\thigh_threshold;\n\tnx_nic_intr_coalesce_data_t\tnormal;\n\tnx_nic_intr_coalesce_data_t\tlow;\n\tnx_nic_intr_coalesce_data_t\thigh;\n\tnx_nic_intr_coalesce_data_t\tirq;\n} nx_nic_intr_coalesce_t;\n\n#define NX_HOST_REQUEST\t\t0x13\n#define NX_NIC_REQUEST\t\t0x14\n\n#define NX_MAC_EVENT\t\t0x1\n\n#define NX_IP_UP\t\t2\n#define NX_IP_DOWN\t\t3\n\n \n#define NX_NIC_H2C_OPCODE_START\t\t\t\t0\n#define NX_NIC_H2C_OPCODE_CONFIG_RSS\t\t\t1\n#define NX_NIC_H2C_OPCODE_CONFIG_RSS_TBL\t\t2\n#define NX_NIC_H2C_OPCODE_CONFIG_INTR_COALESCE\t\t3\n#define NX_NIC_H2C_OPCODE_CONFIG_LED\t\t\t4\n#define NX_NIC_H2C_OPCODE_CONFIG_PROMISCUOUS\t\t5\n#define NX_NIC_H2C_OPCODE_CONFIG_L2_MAC\t\t\t6\n#define NX_NIC_H2C_OPCODE_LRO_REQUEST\t\t\t7\n#define NX_NIC_H2C_OPCODE_GET_SNMP_STATS\t\t8\n#define NX_NIC_H2C_OPCODE_PROXY_START_REQUEST\t\t9\n#define NX_NIC_H2C_OPCODE_PROXY_STOP_REQUEST\t\t10\n#define NX_NIC_H2C_OPCODE_PROXY_SET_MTU\t\t\t11\n#define NX_NIC_H2C_OPCODE_PROXY_SET_VPORT_MISS_MODE\t12\n#define NX_NIC_H2C_OPCODE_GET_FINGER_PRINT_REQUEST\t13\n#define NX_NIC_H2C_OPCODE_INSTALL_LICENSE_REQUEST\t14\n#define NX_NIC_H2C_OPCODE_GET_LICENSE_CAPABILITY_REQUEST\t15\n#define NX_NIC_H2C_OPCODE_GET_NET_STATS\t\t\t16\n#define NX_NIC_H2C_OPCODE_PROXY_UPDATE_P2V\t\t17\n#define NX_NIC_H2C_OPCODE_CONFIG_IPADDR\t\t\t18\n#define NX_NIC_H2C_OPCODE_CONFIG_LOOPBACK\t\t19\n#define NX_NIC_H2C_OPCODE_PROXY_STOP_DONE\t\t20\n#define NX_NIC_H2C_OPCODE_GET_LINKEVENT\t\t\t21\n#define NX_NIC_C2C_OPCODE\t\t\t\t22\n#define NX_NIC_H2C_OPCODE_CONFIG_BRIDGING               23\n#define NX_NIC_H2C_OPCODE_CONFIG_HW_LRO\t\t\t24\n#define NX_NIC_H2C_OPCODE_LAST\t\t\t\t25\n\n \n\n#define NX_NIC_C2H_OPCODE_START\t\t\t\t128\n#define NX_NIC_C2H_OPCODE_CONFIG_RSS_RESPONSE\t\t129\n#define NX_NIC_C2H_OPCODE_CONFIG_RSS_TBL_RESPONSE\t130\n#define NX_NIC_C2H_OPCODE_CONFIG_MAC_RESPONSE\t\t131\n#define NX_NIC_C2H_OPCODE_CONFIG_PROMISCUOUS_RESPONSE\t132\n#define NX_NIC_C2H_OPCODE_CONFIG_L2_MAC_RESPONSE\t133\n#define NX_NIC_C2H_OPCODE_LRO_DELETE_RESPONSE\t\t134\n#define NX_NIC_C2H_OPCODE_LRO_ADD_FAILURE_RESPONSE\t135\n#define NX_NIC_C2H_OPCODE_GET_SNMP_STATS\t\t136\n#define NX_NIC_C2H_OPCODE_GET_FINGER_PRINT_REPLY\t137\n#define NX_NIC_C2H_OPCODE_INSTALL_LICENSE_REPLY\t\t138\n#define NX_NIC_C2H_OPCODE_GET_LICENSE_CAPABILITIES_REPLY 139\n#define NX_NIC_C2H_OPCODE_GET_NET_STATS_RESPONSE\t140\n#define NX_NIC_C2H_OPCODE_GET_LINKEVENT_RESPONSE\t141\n#define NX_NIC_C2H_OPCODE_LAST\t\t\t\t142\n\n#define VPORT_MISS_MODE_DROP\t\t0  \n#define VPORT_MISS_MODE_ACCEPT_ALL\t1  \n#define VPORT_MISS_MODE_ACCEPT_MULTI\t2  \n\n#define NX_NIC_LRO_REQUEST_FIRST\t\t0\n#define NX_NIC_LRO_REQUEST_ADD_FLOW\t\t1\n#define NX_NIC_LRO_REQUEST_DELETE_FLOW\t\t2\n#define NX_NIC_LRO_REQUEST_TIMER\t\t3\n#define NX_NIC_LRO_REQUEST_CLEANUP\t\t4\n#define NX_NIC_LRO_REQUEST_ADD_FLOW_SCHEDULED\t5\n#define NX_TOE_LRO_REQUEST_ADD_FLOW\t\t6\n#define NX_TOE_LRO_REQUEST_ADD_FLOW_RESPONSE\t7\n#define NX_TOE_LRO_REQUEST_DELETE_FLOW\t\t8\n#define NX_TOE_LRO_REQUEST_DELETE_FLOW_RESPONSE\t9\n#define NX_TOE_LRO_REQUEST_TIMER\t\t10\n#define NX_NIC_LRO_REQUEST_LAST\t\t\t11\n\n#define NX_FW_CAPABILITY_LINK_NOTIFICATION\t(1 << 5)\n#define NX_FW_CAPABILITY_SWITCHING\t\t(1 << 6)\n#define NX_FW_CAPABILITY_PEXQ\t\t\t(1 << 7)\n#define NX_FW_CAPABILITY_BDG\t\t\t(1 << 8)\n#define NX_FW_CAPABILITY_FVLANTX\t\t(1 << 9)\n#define NX_FW_CAPABILITY_HW_LRO\t\t\t(1 << 10)\n#define NX_FW_CAPABILITY_GBE_LINK_CFG\t\t(1 << 11)\n#define NX_FW_CAPABILITY_MORE_CAPS\t\t(1 << 31)\n#define NX_FW_CAPABILITY_2_LRO_MAX_TCP_SEG\t(1 << 2)\n\n \n#define LINKEVENT_MODULE_NOT_PRESENT\t\t\t1\n#define LINKEVENT_MODULE_OPTICAL_UNKNOWN\t\t2\n#define LINKEVENT_MODULE_OPTICAL_SRLR\t\t\t3\n#define LINKEVENT_MODULE_OPTICAL_LRM\t\t\t4\n#define LINKEVENT_MODULE_OPTICAL_SFP_1G\t\t\t5\n#define LINKEVENT_MODULE_TWINAX_UNSUPPORTED_CABLE\t6\n#define LINKEVENT_MODULE_TWINAX_UNSUPPORTED_CABLELEN\t7\n#define LINKEVENT_MODULE_TWINAX\t\t\t\t8\n\n#define LINKSPEED_10GBPS\t10000\n#define LINKSPEED_1GBPS\t\t1000\n#define LINKSPEED_100MBPS\t100\n#define LINKSPEED_10MBPS\t10\n\n#define LINKSPEED_ENCODED_10MBPS\t0\n#define LINKSPEED_ENCODED_100MBPS\t1\n#define LINKSPEED_ENCODED_1GBPS\t\t2\n\n#define LINKEVENT_AUTONEG_DISABLED\t0\n#define LINKEVENT_AUTONEG_ENABLED\t1\n\n#define LINKEVENT_HALF_DUPLEX\t\t0\n#define LINKEVENT_FULL_DUPLEX\t\t1\n\n#define LINKEVENT_LINKSPEED_MBPS\t0\n#define LINKEVENT_LINKSPEED_ENCODED\t1\n\n#define AUTO_FW_RESET_ENABLED\t0xEF10AF12\n#define AUTO_FW_RESET_DISABLED\t0xDCBAAF12\n\n \n#define netxen_get_nic_msgtype(msg_hdr)\t\\\n\t((msg_hdr >> 58) & 0x3F)\n#define netxen_get_nic_msg_compid(msg_hdr)\t\\\n\t((msg_hdr >> 40) & 0xFF)\n#define netxen_get_nic_msg_opcode(msg_hdr)\t\\\n\t((msg_hdr >> 32) & 0xFF)\n#define netxen_get_nic_msg_errcode(msg_hdr)\t\\\n\t((msg_hdr >> 16) & 0xFFFF)\n\ntypedef struct {\n\tunion {\n\t\tstruct {\n\t\t\tu64 hdr;\n\t\t\tu64 body[7];\n\t\t};\n\t\tu64 words[8];\n\t};\n} nx_fw_msg_t;\n\ntypedef struct {\n\t__le64 qhdr;\n\t__le64 req_hdr;\n\t__le64 words[6];\n} nx_nic_req_t;\n\ntypedef struct {\n\tu8 op;\n\tu8 tag;\n\tu8 mac_addr[6];\n} nx_mac_req_t;\n\n#define MAX_PENDING_DESC_BLOCK_SIZE\t64\n\n#define NETXEN_NIC_MSI_ENABLED\t\t0x02\n#define NETXEN_NIC_MSIX_ENABLED\t\t0x04\n#define NETXEN_NIC_LRO_ENABLED\t\t0x08\n#define NETXEN_NIC_LRO_DISABLED\t\t0x00\n#define NETXEN_NIC_BRIDGE_ENABLED       0X10\n#define NETXEN_NIC_DIAG_ENABLED\t\t0x20\n#define NETXEN_FW_RESET_OWNER           0x40\n#define NETXEN_FW_MSS_CAP\t        0x80\n#define NETXEN_IS_MSI_FAMILY(adapter) \\\n\t((adapter)->flags & (NETXEN_NIC_MSI_ENABLED | NETXEN_NIC_MSIX_ENABLED))\n\n#define MSIX_ENTRIES_PER_ADAPTER\tNUM_STS_DESC_RINGS\n#define NETXEN_MSIX_TBL_SPACE\t\t8192\n#define NETXEN_PCI_REG_MSIX_TBL\t\t0x44\n\n#define NETXEN_DB_MAPSIZE_BYTES    \t0x1000\n\n#define NETXEN_ADAPTER_UP_MAGIC 777\n#define NETXEN_NIC_PEG_TUNE 0\n\n#define __NX_FW_ATTACHED\t\t0\n#define __NX_DEV_UP\t\t\t1\n#define __NX_RESETTING\t\t\t2\n\n \n#define NX_MD_SUPPORT_MAJOR\t\t4\n#define NX_MD_SUPPORT_MINOR\t\t0\n#define NX_MD_SUPPORT_SUBVERSION\t579\n\n#define LSW(x)  ((uint16_t)(x))\n#define LSD(x)  ((uint32_t)((uint64_t)(x)))\n#define MSD(x)  ((uint32_t)((((uint64_t)(x)) >> 16) >> 16))\n\n \n#define\tNX_DUMP_MASK_MIN\t0x03\n#define\tNX_DUMP_MASK_DEF\t0x1f\n#define\tNX_DUMP_MASK_MAX\t0xff\n\n \n#define NX_CDRP_CMD_TEMP_SIZE           0x0000002f\n#define NX_CDRP_CMD_GET_TEMP_HDR        0x00000030\n\n\n#define NX_DUMP_STATE_ARRAY_LEN\t\t16\n#define NX_DUMP_CAP_SIZE_ARRAY_LEN\t8\n\n \n#define NX_FORCE_FW_DUMP_KEY\t\t0xdeadfeed\n#define NX_ENABLE_FW_DUMP               0xaddfeed\n#define NX_DISABLE_FW_DUMP              0xbadfeed\n#define NX_FORCE_FW_RESET               0xdeaddead\n\n\n \n#define NX_FW_DUMP_REG1         0x00130060\n#define NX_FW_DUMP_REG2         0x001e0000\n#define NX_FLASH_SEM2_LK        0x0013C010\n#define NX_FLASH_SEM2_ULK       0x0013C014\n#define NX_FLASH_LOCK_ID        0x001B2100\n#define FLASH_ROM_WINDOW        0x42110030\n#define FLASH_ROM_DATA          0x42150000\n\n \n#define NX_RD_DUMP_REG(addr, bar0, data) do {                   \\\n\twritel((addr & 0xFFFF0000), (void __iomem *) (bar0 +            \\\n\t\tNX_FW_DUMP_REG1));                                      \\\n\treadl((void __iomem *) (bar0 + NX_FW_DUMP_REG1));               \\\n\t*data = readl((void __iomem *) (bar0 + NX_FW_DUMP_REG2 +        \\\n\t\tLSW(addr)));                                            \\\n} while (0)\n\n#define NX_WR_DUMP_REG(addr, bar0, data) do {                   \\\n\twritel((addr & 0xFFFF0000), (void __iomem *) (bar0 +            \\\n\t\tNX_FW_DUMP_REG1));                                      \\\n\treadl((void __iomem *) (bar0 + NX_FW_DUMP_REG1));                \\\n\twritel(data, (void __iomem *) (bar0 + NX_FW_DUMP_REG2 + LSW(addr)));\\\n\treadl((void __iomem *) (bar0 + NX_FW_DUMP_REG2 + LSW(addr)));  \\\n} while (0)\n\n\n \n\n#define RDNOP\t0\n#define RDCRB\t1\n#define RDMUX\t2\n#define QUEUE\t3\n#define BOARD\t4\n#define RDSRE\t5\n#define RDOCM\t6\n#define PREGS\t7\n#define L1DTG\t8\n#define L1ITG\t9\n#define CACHE\t10\n\n#define L1DAT\t11\n#define L1INS\t12\n#define RDSTK\t13\n#define RDCON\t14\n\n#define L2DTG\t21\n#define L2ITG\t22\n#define L2DAT\t23\n#define L2INS\t24\n#define RDOC3\t25\n\n#define MEMBK\t32\n\n#define RDROM\t71\n#define RDMEM\t72\n#define RDMN\t73\n\n#define INFOR\t81\n#define CNTRL\t98\n\n#define TLHDR\t99\n#define RDEND\t255\n\n#define PRIMQ\t103\n#define SQG2Q\t104\n#define SQG3Q\t105\n\n \n#define NX_DUMP_WCRB\t\t0x01\n#define NX_DUMP_RWCRB\t\t0x02\n#define NX_DUMP_ANDCRB\t\t0x04\n#define NX_DUMP_ORCRB\t\t0x08\n#define NX_DUMP_POLLCRB\t\t0x10\n#define NX_DUMP_RD_SAVE\t\t0x20\n#define NX_DUMP_WRT_SAVED\t0x40\n#define NX_DUMP_MOD_SAVE_ST\t0x80\n\n \n#define NX_DUMP_SKIP\t\t0x80\t \n#define NX_DUMP_SIZE_ERR 0x40\t \n\n#define NX_PCI_READ_32(ADDR)\t\t\treadl((ADDR))\n#define NX_PCI_WRITE_32(DATA, ADDR)\twritel(DATA, (ADDR))\n\n\n\nstruct netxen_minidump {\n\tu32 pos;\t\t\t \n\tu8  fw_supports_md;\t\t \n\tu8  has_valid_dump;\t\t \n\tu8  md_capture_mask;\t\t \n\tu8  md_enabled;\t\t\t \n\tu32 md_dump_size;\t\t \n\tu32 md_capture_size;\t\t \n\tu32 md_template_size;\t\t \n\tu32 md_template_ver;\t\t \n\tu64 md_timestamp;\t\t \n\tvoid *md_template;\t\t \n\tvoid *md_capture_buff;\t\t \n};\n\n\n\nstruct netxen_minidump_template_hdr {\n\tu32 entry_type;\n\tu32 first_entry_offset;\n\tu32 size_of_template;\n\tu32 capture_mask;\n\tu32 num_of_entries;\n\tu32 version;\n\tu32 driver_timestamp;\n\tu32 checksum;\n\tu32 driver_capture_mask;\n\tu32 driver_info_word2;\n\tu32 driver_info_word3;\n\tu32 driver_info_word4;\n\tu32 saved_state_array[NX_DUMP_STATE_ARRAY_LEN];\n\tu32 capture_size_array[NX_DUMP_CAP_SIZE_ARRAY_LEN];\n\tu32 rsvd[];\n};\n\n \n \n\nstruct netxen_common_entry_hdr {\n\tu32 entry_type;\n\tu32 entry_size;\n\tu32 entry_capture_size;\n\tunion {\n\t\tstruct {\n\t\t\tu8 entry_capture_mask;\n\t\t\tu8 entry_code;\n\t\t\tu8 driver_code;\n\t\t\tu8 driver_flags;\n\t\t};\n\t\tu32 entry_ctrl_word;\n\t};\n};\n\n\n \nstruct netxen_minidump_entry {\n\tstruct netxen_common_entry_hdr hdr;\n\tu32 entry_data00;\n\tu32 entry_data01;\n\tu32 entry_data02;\n\tu32 entry_data03;\n\tu32 entry_data04;\n\tu32 entry_data05;\n\tu32 entry_data06;\n\tu32 entry_data07;\n};\n\n \nstruct netxen_minidump_entry_rdrom {\n\tstruct netxen_common_entry_hdr h;\n\tunion {\n\t\tstruct {\n\t\t\tu32 select_addr_reg;\n\t\t};\n\t\tu32 rsvd_0;\n\t};\n\tunion {\n\t\tstruct {\n\t\t\tu8 addr_stride;\n\t\t\tu8 addr_cnt;\n\t\t\tu16 data_size;\n\t\t};\n\t\tu32 rsvd_1;\n\t};\n\tunion {\n\t\tstruct {\n\t\t\tu32 op_count;\n\t\t};\n\t\tu32 rsvd_2;\n\t};\n\tunion {\n\t\tstruct {\n\t\t\tu32 read_addr_reg;\n\t\t};\n\t\tu32 rsvd_3;\n\t};\n\tunion {\n\t\tstruct {\n\t\t\tu32 write_mask;\n\t\t};\n\t\tu32 rsvd_4;\n\t};\n\tunion {\n\t\tstruct {\n\t\t\tu32 read_mask;\n\t\t};\n\t\tu32 rsvd_5;\n\t};\n\tu32 read_addr;\n\tu32 read_data_size;\n};\n\n\n \nstruct netxen_minidump_entry_crb {\n\tstruct netxen_common_entry_hdr h;\n\tu32 addr;\n\tunion {\n\t\tstruct {\n\t\t\tu8 addr_stride;\n\t\t\tu8 state_index_a;\n\t\t\tu16 poll_timeout;\n\t\t\t};\n\t\tu32 addr_cntrl;\n\t};\n\tu32 data_size;\n\tu32 op_count;\n\tunion {\n\t\tstruct {\n\t\t\tu8 opcode;\n\t\t\tu8 state_index_v;\n\t\t\tu8 shl;\n\t\t\tu8 shr;\n\t\t\t};\n\t\tu32 control_value;\n\t};\n\tu32 value_1;\n\tu32 value_2;\n\tu32 value_3;\n};\n\n \nstruct netxen_minidump_entry_rdmem {\n\tstruct netxen_common_entry_hdr h;\n\tunion {\n\t\tstruct {\n\t\t\tu32 select_addr_reg;\n\t\t};\n\t\tu32 rsvd_0;\n\t};\n\tunion {\n\t\tstruct {\n\t\t\tu8 addr_stride;\n\t\t\tu8 addr_cnt;\n\t\t\tu16 data_size;\n\t\t};\n\t\tu32 rsvd_1;\n\t};\n\tunion {\n\t\tstruct {\n\t\t\tu32 op_count;\n\t\t};\n\t\tu32 rsvd_2;\n\t};\n\tunion {\n\t\tstruct {\n\t\t\tu32 read_addr_reg;\n\t\t};\n\t\tu32 rsvd_3;\n\t};\n\tunion {\n\t\tstruct {\n\t\t\tu32 cntrl_addr_reg;\n\t\t};\n\t\tu32 rsvd_4;\n\t};\n\tunion {\n\t\tstruct {\n\t\t\tu8 wr_byte0;\n\t\t\tu8 wr_byte1;\n\t\t\tu8 poll_mask;\n\t\t\tu8 poll_cnt;\n\t\t};\n\t\tu32 rsvd_5;\n\t};\n\tu32 read_addr;\n\tu32 read_data_size;\n};\n\n \nstruct netxen_minidump_entry_cache {\n\tstruct netxen_common_entry_hdr h;\n\tu32 tag_reg_addr;\n\tunion {\n\t\tstruct {\n\t\t\tu16 tag_value_stride;\n\t\t\tu16 init_tag_value;\n\t\t};\n\t\tu32 select_addr_cntrl;\n\t};\n\tu32 data_size;\n\tu32 op_count;\n\tu32 control_addr;\n\tunion {\n\t\tstruct {\n\t\t\tu16 write_value;\n\t\t\tu8 poll_mask;\n\t\t\tu8 poll_wait;\n\t\t};\n\t\tu32 control_value;\n\t};\n\tu32 read_addr;\n\tunion {\n\t\tstruct {\n\t\t\tu8 read_addr_stride;\n\t\t\tu8 read_addr_cnt;\n\t\t\tu16 rsvd_1;\n\t\t};\n\t\tu32 read_addr_cntrl;\n\t};\n};\n\n \nstruct netxen_minidump_entry_rdocm {\n\tstruct netxen_common_entry_hdr h;\n\tu32 rsvd_0;\n\tunion {\n\t\tstruct {\n\t\t\tu32 rsvd_1;\n\t\t};\n\t\tu32 select_addr_cntrl;\n\t};\n\tu32 data_size;\n\tu32 op_count;\n\tu32 rsvd_2;\n\tu32 rsvd_3;\n\tu32 read_addr;\n\tunion {\n\t\tstruct {\n\t\t\tu32 read_addr_stride;\n\t\t};\n\t\tu32 read_addr_cntrl;\n\t};\n};\n\n \nstruct netxen_minidump_entry_mux {\n\tstruct netxen_common_entry_hdr h;\n\tu32 select_addr;\n\tunion {\n\t\tstruct {\n\t\t\tu32 rsvd_0;\n\t\t};\n\t\tu32 select_addr_cntrl;\n\t};\n\tu32 data_size;\n\tu32 op_count;\n\tu32 select_value;\n\tu32 select_value_stride;\n\tu32 read_addr;\n\tu32 rsvd_1;\n};\n\n \nstruct netxen_minidump_entry_queue {\n\tstruct netxen_common_entry_hdr h;\n\tu32 select_addr;\n\tunion {\n\t\tstruct {\n\t\t\tu16 queue_id_stride;\n\t\t\tu16 rsvd_0;\n\t\t};\n\t\tu32 select_addr_cntrl;\n\t};\n\tu32 data_size;\n\tu32 op_count;\n\tu32 rsvd_1;\n\tu32 rsvd_2;\n\tu32 read_addr;\n\tunion {\n\t\tstruct {\n\t\t\tu8 read_addr_stride;\n\t\t\tu8 read_addr_cnt;\n\t\t\tu16 rsvd_3;\n\t\t};\n\t\tu32 read_addr_cntrl;\n\t};\n};\n\nstruct netxen_dummy_dma {\n\tvoid *addr;\n\tdma_addr_t phys_addr;\n};\n\nstruct netxen_adapter {\n\tstruct netxen_hardware_context ahw;\n\n\tstruct net_device *netdev;\n\tstruct pci_dev *pdev;\n\tstruct list_head mac_list;\n\tstruct list_head ip_list;\n\n\tspinlock_t tx_clean_lock;\n\n\tu16 num_txd;\n\tu16 num_rxd;\n\tu16 num_jumbo_rxd;\n\tu16 num_lro_rxd;\n\n\tu8 max_rds_rings;\n\tu8 max_sds_rings;\n\tu8 driver_mismatch;\n\tu8 msix_supported;\n\tu8 __pad;\n\tu8 pci_using_dac;\n\tu8 portnum;\n\tu8 physical_port;\n\n\tu8 mc_enabled;\n\tu8 max_mc_count;\n\tu8 rss_supported;\n\tu8 link_changed;\n\tu8 fw_wait_cnt;\n\tu8 fw_fail_cnt;\n\tu8 tx_timeo_cnt;\n\tu8 need_fw_reset;\n\n\tu8 has_link_events;\n\tu8 fw_type;\n\tu16 tx_context_id;\n\tu16 mtu;\n\tu16 is_up;\n\n\tu16 link_speed;\n\tu16 link_duplex;\n\tu16 link_autoneg;\n\tu16 module_type;\n\n\tu32 capabilities;\n\tu32 flags;\n\tu32 irq;\n\tu32 temp;\n\n\tu32 int_vec_bit;\n\tu32 heartbit;\n\n\tu8 mac_addr[ETH_ALEN];\n\n\tstruct netxen_adapter_stats stats;\n\n\tstruct netxen_recv_context recv_ctx;\n\tstruct nx_host_tx_ring *tx_ring;\n\n\tint (*macaddr_set) (struct netxen_adapter *, u8 *);\n\tint (*set_mtu) (struct netxen_adapter *, int);\n\tint (*set_promisc) (struct netxen_adapter *, u32);\n\tvoid (*set_multi) (struct net_device *);\n\tint (*phy_read) (struct netxen_adapter *, u32 reg, u32 *);\n\tint (*phy_write) (struct netxen_adapter *, u32 reg, u32 val);\n\tint (*init_port) (struct netxen_adapter *, int);\n\tint (*stop_port) (struct netxen_adapter *);\n\n\tu32 (*crb_read)(struct netxen_adapter *, ulong);\n\tint (*crb_write)(struct netxen_adapter *, ulong, u32);\n\n\tint (*pci_mem_read)(struct netxen_adapter *, u64, u64 *);\n\tint (*pci_mem_write)(struct netxen_adapter *, u64, u64);\n\n\tint (*pci_set_window)(struct netxen_adapter *, u64, u32 *);\n\n\tu32 (*io_read)(struct netxen_adapter *, void __iomem *);\n\tvoid (*io_write)(struct netxen_adapter *, void __iomem *, u32);\n\n\tvoid __iomem\t*tgt_mask_reg;\n\tvoid __iomem\t*pci_int_reg;\n\tvoid __iomem\t*tgt_status_reg;\n\tvoid __iomem\t*crb_int_state_reg;\n\tvoid __iomem\t*isr_int_vec;\n\n\tstruct msix_entry msix_entries[MSIX_ENTRIES_PER_ADAPTER];\n\n\tstruct netxen_dummy_dma dummy_dma;\n\n\tstruct delayed_work fw_work;\n\n\tstruct work_struct  tx_timeout_task;\n\n\tnx_nic_intr_coalesce_t coal;\n\n\tunsigned long state;\n\t__le32 file_prd_off;\t \n\tu32 fw_version;\n\tconst struct firmware *fw;\n\tstruct netxen_minidump mdump;    \n\tint fw_mdump_rdy;\t \n};\n\nint nx_fw_cmd_query_phy(struct netxen_adapter *adapter, u32 reg, u32 *val);\nint nx_fw_cmd_set_phy(struct netxen_adapter *adapter, u32 reg, u32 val);\n\n#define NXRD32(adapter, off) \\\n\t(adapter->crb_read(adapter, off))\n#define NXWR32(adapter, off, val) \\\n\t(adapter->crb_write(adapter, off, val))\n#define NXRDIO(adapter, addr) \\\n\t(adapter->io_read(adapter, addr))\n#define NXWRIO(adapter, addr, val) \\\n\t(adapter->io_write(adapter, addr, val))\n\nint netxen_pcie_sem_lock(struct netxen_adapter *, int, u32);\nvoid netxen_pcie_sem_unlock(struct netxen_adapter *, int);\n\n#define netxen_rom_lock(a)\t\\\n\tnetxen_pcie_sem_lock((a), 2, NETXEN_ROM_LOCK_ID)\n#define netxen_rom_unlock(a)\t\\\n\tnetxen_pcie_sem_unlock((a), 2)\n#define netxen_phy_lock(a)\t\\\n\tnetxen_pcie_sem_lock((a), 3, NETXEN_PHY_LOCK_ID)\n#define netxen_phy_unlock(a)\t\\\n\tnetxen_pcie_sem_unlock((a), 3)\n#define netxen_api_lock(a)\t\\\n\tnetxen_pcie_sem_lock((a), 5, 0)\n#define netxen_api_unlock(a)\t\\\n\tnetxen_pcie_sem_unlock((a), 5)\n#define netxen_sw_lock(a)\t\\\n\tnetxen_pcie_sem_lock((a), 6, 0)\n#define netxen_sw_unlock(a)\t\\\n\tnetxen_pcie_sem_unlock((a), 6)\n#define crb_win_lock(a)\t\\\n\tnetxen_pcie_sem_lock((a), 7, NETXEN_CRB_WIN_LOCK_ID)\n#define crb_win_unlock(a)\t\\\n\tnetxen_pcie_sem_unlock((a), 7)\n\nint netxen_nic_get_board_info(struct netxen_adapter *adapter);\nint netxen_nic_wol_supported(struct netxen_adapter *adapter);\n\n \nint netxen_init_dummy_dma(struct netxen_adapter *adapter);\nvoid netxen_free_dummy_dma(struct netxen_adapter *adapter);\n\nint netxen_check_flash_fw_compatibility(struct netxen_adapter *adapter);\nint netxen_phantom_init(struct netxen_adapter *adapter, int pegtune_val);\nint netxen_load_firmware(struct netxen_adapter *adapter);\nint netxen_need_fw_reset(struct netxen_adapter *adapter);\nvoid netxen_request_firmware(struct netxen_adapter *adapter);\nvoid netxen_release_firmware(struct netxen_adapter *adapter);\nint netxen_pinit_from_rom(struct netxen_adapter *adapter);\n\nint netxen_rom_fast_read(struct netxen_adapter *adapter, int addr, int *valp);\nint netxen_rom_fast_read_words(struct netxen_adapter *adapter, int addr,\n\t\t\t\tu8 *bytes, size_t size);\nint netxen_rom_fast_write_words(struct netxen_adapter *adapter, int addr,\n\t\t\t\tu8 *bytes, size_t size);\nint netxen_flash_unlock(struct netxen_adapter *adapter);\nint netxen_backup_crbinit(struct netxen_adapter *adapter);\nint netxen_flash_erase_secondary(struct netxen_adapter *adapter);\nint netxen_flash_erase_primary(struct netxen_adapter *adapter);\nvoid netxen_halt_pegs(struct netxen_adapter *adapter);\n\nint netxen_rom_se(struct netxen_adapter *adapter, int addr);\n\nint netxen_alloc_sw_resources(struct netxen_adapter *adapter);\nvoid netxen_free_sw_resources(struct netxen_adapter *adapter);\n\nvoid netxen_setup_hwops(struct netxen_adapter *adapter);\nvoid __iomem *netxen_get_ioaddr(struct netxen_adapter *, u32);\n\nint netxen_alloc_hw_resources(struct netxen_adapter *adapter);\nvoid netxen_free_hw_resources(struct netxen_adapter *adapter);\n\nvoid netxen_release_rx_buffers(struct netxen_adapter *adapter);\nvoid netxen_release_tx_buffers(struct netxen_adapter *adapter);\n\nint netxen_init_firmware(struct netxen_adapter *adapter);\nvoid netxen_nic_clear_stats(struct netxen_adapter *adapter);\nvoid netxen_watchdog_task(struct work_struct *work);\nvoid netxen_post_rx_buffers(struct netxen_adapter *adapter, u32 ringid,\n\t\tstruct nx_host_rds_ring *rds_ring);\nint netxen_process_cmd_ring(struct netxen_adapter *adapter);\nint netxen_process_rcv_ring(struct nx_host_sds_ring *sds_ring, int max);\n\nvoid netxen_p3_free_mac_list(struct netxen_adapter *adapter);\nint netxen_config_intr_coalesce(struct netxen_adapter *adapter);\nint netxen_config_rss(struct netxen_adapter *adapter, int enable);\nint netxen_config_ipaddr(struct netxen_adapter *adapter, __be32 ip, int cmd);\nint netxen_linkevent_request(struct netxen_adapter *adapter, int enable);\nvoid netxen_advert_link_change(struct netxen_adapter *adapter, int linkup);\nvoid netxen_pci_camqm_read_2M(struct netxen_adapter *, u64, u64 *);\nvoid netxen_pci_camqm_write_2M(struct netxen_adapter *, u64, u64);\n\nint nx_fw_cmd_set_gbe_port(struct netxen_adapter *adapter,\n\t\t\t\tu32 speed, u32 duplex, u32 autoneg);\nint nx_fw_cmd_set_mtu(struct netxen_adapter *adapter, int mtu);\nint netxen_nic_change_mtu(struct net_device *netdev, int new_mtu);\nint netxen_config_hw_lro(struct netxen_adapter *adapter, int enable);\nint netxen_config_bridged_mode(struct netxen_adapter *adapter, int enable);\nint netxen_send_lro_cleanup(struct netxen_adapter *adapter);\nint netxen_setup_minidump(struct netxen_adapter *adapter);\nvoid netxen_dump_fw(struct netxen_adapter *adapter);\nvoid netxen_nic_update_cmd_producer(struct netxen_adapter *adapter,\n\t\tstruct nx_host_tx_ring *tx_ring);\n\n \nint netxen_nic_reset_context(struct netxen_adapter *);\n\nint nx_dev_request_reset(struct netxen_adapter *adapter);\n\n \n\n#define NETXEN_MAX_SHORT_NAME 32\nstruct netxen_brdinfo {\n\tint brdtype;\t \n\tlong ports;\t\t \n\tchar short_name[NETXEN_MAX_SHORT_NAME];\n};\n\nstruct netxen_dimm_cfg {\n\tu8 presence;\n\tu8 mem_type;\n\tu8 dimm_type;\n\tu32 size;\n};\n\nstatic const struct netxen_brdinfo netxen_boards[] = {\n\t{NETXEN_BRDTYPE_P2_SB31_10G_CX4, 1, \"XGb CX4\"},\n\t{NETXEN_BRDTYPE_P2_SB31_10G_HMEZ, 1, \"XGb HMEZ\"},\n\t{NETXEN_BRDTYPE_P2_SB31_10G_IMEZ, 2, \"XGb IMEZ\"},\n\t{NETXEN_BRDTYPE_P2_SB31_10G, 1, \"XGb XFP\"},\n\t{NETXEN_BRDTYPE_P2_SB35_4G, 4, \"Quad Gb\"},\n\t{NETXEN_BRDTYPE_P2_SB31_2G, 2, \"Dual Gb\"},\n\t{NETXEN_BRDTYPE_P3_REF_QG,  4, \"Reference Quad Gig \"},\n\t{NETXEN_BRDTYPE_P3_HMEZ,    2, \"Dual XGb HMEZ\"},\n\t{NETXEN_BRDTYPE_P3_10G_CX4_LP,   2, \"Dual XGb CX4 LP\"},\n\t{NETXEN_BRDTYPE_P3_4_GB,    4, \"Quad Gig LP\"},\n\t{NETXEN_BRDTYPE_P3_IMEZ,    2, \"Dual XGb IMEZ\"},\n\t{NETXEN_BRDTYPE_P3_10G_SFP_PLUS, 2, \"Dual XGb SFP+ LP\"},\n\t{NETXEN_BRDTYPE_P3_10000_BASE_T, 1, \"XGB 10G BaseT LP\"},\n\t{NETXEN_BRDTYPE_P3_XG_LOM,  2, \"Dual XGb LOM\"},\n\t{NETXEN_BRDTYPE_P3_4_GB_MM, 4, \"NX3031 Gigabit Ethernet\"},\n\t{NETXEN_BRDTYPE_P3_10G_SFP_CT, 2, \"NX3031 10 Gigabit Ethernet\"},\n\t{NETXEN_BRDTYPE_P3_10G_SFP_QT, 2, \"Quanta Dual XGb SFP+\"},\n\t{NETXEN_BRDTYPE_P3_10G_CX4, 2, \"Reference Dual CX4 Option\"},\n\t{NETXEN_BRDTYPE_P3_10G_XFP, 1, \"Reference Single XFP Option\"}\n};\n\n#define NUM_SUPPORTED_BOARDS ARRAY_SIZE(netxen_boards)\n\nstatic inline int netxen_nic_get_brd_name_by_type(u32 type, char *name)\n{\n\tint i, found = 0;\n\tfor (i = 0; i < NUM_SUPPORTED_BOARDS; ++i) {\n\t\tif (netxen_boards[i].brdtype == type) {\n\t\t\tstrcpy(name, netxen_boards[i].short_name);\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!found) {\n\t\tstrcpy(name, \"Unknown\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic inline u32 netxen_tx_avail(struct nx_host_tx_ring *tx_ring)\n{\n\tsmp_mb();\n\treturn find_diff_among(tx_ring->producer,\n\t\t\ttx_ring->sw_consumer, tx_ring->num_desc);\n\n}\n\nint netxen_get_flash_mac_addr(struct netxen_adapter *adapter, u64 *mac);\nint netxen_p3_get_mac_addr(struct netxen_adapter *adapter, u64 *mac);\nvoid netxen_change_ringparam(struct netxen_adapter *adapter);\n\nextern const struct ethtool_ops netxen_nic_ethtool_ops;\n\n#endif\t\t\t\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}