{
  "module_name": "netxen_nic_hw.c",
  "hash_id": "4ee0d9ca911b015b5dfea8c1aaec7fbe698cc96a741b404f5b815feb7f1a7157",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/qlogic/netxen/netxen_nic_hw.c",
  "human_readable_source": "\n \n\n#include <linux/io-64-nonatomic-lo-hi.h>\n#include <linux/slab.h>\n#include \"netxen_nic.h\"\n#include \"netxen_nic_hw.h\"\n\n#include <net/ip.h>\n\n#define MASK(n) ((1ULL<<(n))-1)\n#define MN_WIN(addr) (((addr & 0x1fc0000) >> 1) | ((addr >> 25) & 0x3ff))\n#define OCM_WIN(addr) (((addr & 0x1ff0000) >> 1) | ((addr >> 25) & 0x3ff))\n#define MS_WIN(addr) (addr & 0x0ffc0000)\n\n#define GET_MEM_OFFS_2M(addr) (addr & MASK(18))\n\n#define CRB_BLK(off)\t((off >> 20) & 0x3f)\n#define CRB_SUBBLK(off)\t((off >> 16) & 0xf)\n#define CRB_WINDOW_2M\t(0x130060)\n#define CRB_HI(off)\t((crb_hub_agt[CRB_BLK(off)] << 20) | ((off) & 0xf0000))\n#define CRB_INDIRECT_2M\t(0x1e0000UL)\n\nstatic void netxen_nic_io_write_128M(struct netxen_adapter *adapter,\n\t\tvoid __iomem *addr, u32 data);\nstatic u32 netxen_nic_io_read_128M(struct netxen_adapter *adapter,\n\t\tvoid __iomem *addr);\n\n#define PCI_OFFSET_FIRST_RANGE(adapter, off)    \\\n\t((adapter)->ahw.pci_base0 + (off))\n#define PCI_OFFSET_SECOND_RANGE(adapter, off)   \\\n\t((adapter)->ahw.pci_base1 + (off) - SECOND_PAGE_GROUP_START)\n#define PCI_OFFSET_THIRD_RANGE(adapter, off)    \\\n\t((adapter)->ahw.pci_base2 + (off) - THIRD_PAGE_GROUP_START)\n\nstatic void __iomem *pci_base_offset(struct netxen_adapter *adapter,\n\t\t\t\t\t    unsigned long off)\n{\n\tif (ADDR_IN_RANGE(off, FIRST_PAGE_GROUP_START, FIRST_PAGE_GROUP_END))\n\t\treturn PCI_OFFSET_FIRST_RANGE(adapter, off);\n\n\tif (ADDR_IN_RANGE(off, SECOND_PAGE_GROUP_START, SECOND_PAGE_GROUP_END))\n\t\treturn PCI_OFFSET_SECOND_RANGE(adapter, off);\n\n\tif (ADDR_IN_RANGE(off, THIRD_PAGE_GROUP_START, THIRD_PAGE_GROUP_END))\n\t\treturn PCI_OFFSET_THIRD_RANGE(adapter, off);\n\n\treturn NULL;\n}\n\nstatic crb_128M_2M_block_map_t\ncrb_128M_2M_map[64] __cacheline_aligned_in_smp = {\n    {{{0, 0,         0,         0} } },\t\t \n    {{{1, 0x0100000, 0x0102000, 0x120000},\t \n\t  {1, 0x0110000, 0x0120000, 0x130000},\n\t  {1, 0x0120000, 0x0122000, 0x124000},\n\t  {1, 0x0130000, 0x0132000, 0x126000},\n\t  {1, 0x0140000, 0x0142000, 0x128000},\n\t  {1, 0x0150000, 0x0152000, 0x12a000},\n\t  {1, 0x0160000, 0x0170000, 0x110000},\n\t  {1, 0x0170000, 0x0172000, 0x12e000},\n\t  {0, 0x0000000, 0x0000000, 0x000000},\n\t  {0, 0x0000000, 0x0000000, 0x000000},\n\t  {0, 0x0000000, 0x0000000, 0x000000},\n\t  {0, 0x0000000, 0x0000000, 0x000000},\n\t  {0, 0x0000000, 0x0000000, 0x000000},\n\t  {0, 0x0000000, 0x0000000, 0x000000},\n\t  {1, 0x01e0000, 0x01e0800, 0x122000},\n\t  {0, 0x0000000, 0x0000000, 0x000000} } },\n\t{{{1, 0x0200000, 0x0210000, 0x180000} } }, \n    {{{0, 0,         0,         0} } },\t     \n    {{{1, 0x0400000, 0x0401000, 0x169000} } }, \n    {{{1, 0x0500000, 0x0510000, 0x140000} } }, \n    {{{1, 0x0600000, 0x0610000, 0x1c0000} } }, \n    {{{1, 0x0700000, 0x0704000, 0x1b8000} } }, \n    {{{1, 0x0800000, 0x0802000, 0x170000},   \n      {0, 0x0000000, 0x0000000, 0x000000},\n      {0, 0x0000000, 0x0000000, 0x000000},\n      {0, 0x0000000, 0x0000000, 0x000000},\n      {0, 0x0000000, 0x0000000, 0x000000},\n      {0, 0x0000000, 0x0000000, 0x000000},\n      {0, 0x0000000, 0x0000000, 0x000000},\n      {0, 0x0000000, 0x0000000, 0x000000},\n      {0, 0x0000000, 0x0000000, 0x000000},\n      {0, 0x0000000, 0x0000000, 0x000000},\n      {0, 0x0000000, 0x0000000, 0x000000},\n      {0, 0x0000000, 0x0000000, 0x000000},\n      {0, 0x0000000, 0x0000000, 0x000000},\n      {0, 0x0000000, 0x0000000, 0x000000},\n      {0, 0x0000000, 0x0000000, 0x000000},\n      {1, 0x08f0000, 0x08f2000, 0x172000} } },\n    {{{1, 0x0900000, 0x0902000, 0x174000},\t \n      {0, 0x0000000, 0x0000000, 0x000000},\n      {0, 0x0000000, 0x0000000, 0x000000},\n      {0, 0x0000000, 0x0000000, 0x000000},\n      {0, 0x0000000, 0x0000000, 0x000000},\n      {0, 0x0000000, 0x0000000, 0x000000},\n      {0, 0x0000000, 0x0000000, 0x000000},\n      {0, 0x0000000, 0x0000000, 0x000000},\n      {0, 0x0000000, 0x0000000, 0x000000},\n      {0, 0x0000000, 0x0000000, 0x000000},\n      {0, 0x0000000, 0x0000000, 0x000000},\n      {0, 0x0000000, 0x0000000, 0x000000},\n      {0, 0x0000000, 0x0000000, 0x000000},\n      {0, 0x0000000, 0x0000000, 0x000000},\n      {0, 0x0000000, 0x0000000, 0x000000},\n      {1, 0x09f0000, 0x09f2000, 0x176000} } },\n    {{{0, 0x0a00000, 0x0a02000, 0x178000},\t \n      {0, 0x0000000, 0x0000000, 0x000000},\n      {0, 0x0000000, 0x0000000, 0x000000},\n      {0, 0x0000000, 0x0000000, 0x000000},\n      {0, 0x0000000, 0x0000000, 0x000000},\n      {0, 0x0000000, 0x0000000, 0x000000},\n      {0, 0x0000000, 0x0000000, 0x000000},\n      {0, 0x0000000, 0x0000000, 0x000000},\n      {0, 0x0000000, 0x0000000, 0x000000},\n      {0, 0x0000000, 0x0000000, 0x000000},\n      {0, 0x0000000, 0x0000000, 0x000000},\n      {0, 0x0000000, 0x0000000, 0x000000},\n      {0, 0x0000000, 0x0000000, 0x000000},\n      {0, 0x0000000, 0x0000000, 0x000000},\n      {0, 0x0000000, 0x0000000, 0x000000},\n      {1, 0x0af0000, 0x0af2000, 0x17a000} } },\n    {{{0, 0x0b00000, 0x0b02000, 0x17c000},\t \n      {0, 0x0000000, 0x0000000, 0x000000},\n      {0, 0x0000000, 0x0000000, 0x000000},\n      {0, 0x0000000, 0x0000000, 0x000000},\n      {0, 0x0000000, 0x0000000, 0x000000},\n      {0, 0x0000000, 0x0000000, 0x000000},\n      {0, 0x0000000, 0x0000000, 0x000000},\n      {0, 0x0000000, 0x0000000, 0x000000},\n      {0, 0x0000000, 0x0000000, 0x000000},\n      {0, 0x0000000, 0x0000000, 0x000000},\n      {0, 0x0000000, 0x0000000, 0x000000},\n      {0, 0x0000000, 0x0000000, 0x000000},\n      {0, 0x0000000, 0x0000000, 0x000000},\n      {0, 0x0000000, 0x0000000, 0x000000},\n      {0, 0x0000000, 0x0000000, 0x000000},\n      {1, 0x0bf0000, 0x0bf2000, 0x17e000} } },\n\t{{{1, 0x0c00000, 0x0c04000, 0x1d4000} } }, \n\t{{{1, 0x0d00000, 0x0d04000, 0x1a4000} } }, \n\t{{{1, 0x0e00000, 0x0e04000, 0x1a0000} } }, \n\t{{{1, 0x0f00000, 0x0f01000, 0x164000} } }, \n\t{{{0, 0x1000000, 0x1004000, 0x1a8000} } }, \n\t{{{1, 0x1100000, 0x1101000, 0x160000} } }, \n\t{{{1, 0x1200000, 0x1201000, 0x161000} } }, \n\t{{{1, 0x1300000, 0x1301000, 0x162000} } }, \n\t{{{1, 0x1400000, 0x1401000, 0x163000} } }, \n\t{{{1, 0x1500000, 0x1501000, 0x165000} } }, \n\t{{{1, 0x1600000, 0x1601000, 0x166000} } }, \n\t{{{0, 0,         0,         0} } },\t \n\t{{{0, 0,         0,         0} } },\t \n\t{{{0, 0,         0,         0} } },\t \n\t{{{0, 0,         0,         0} } },\t \n\t{{{0, 0,         0,         0} } },\t \n\t{{{0, 0,         0,         0} } },\t \n\t{{{1, 0x1d00000, 0x1d10000, 0x190000} } }, \n    {{{1, 0x1e00000, 0x1e01000, 0x16a000} } }, \n    {{{1, 0x1f00000, 0x1f10000, 0x150000} } }, \n\t{{{0} } },\t\t\t\t \n\t{{{1, 0x2100000, 0x2102000, 0x120000},\t \n\t  {1, 0x2110000, 0x2120000, 0x130000},\n\t  {1, 0x2120000, 0x2122000, 0x124000},\n\t  {1, 0x2130000, 0x2132000, 0x126000},\n\t  {1, 0x2140000, 0x2142000, 0x128000},\n\t  {1, 0x2150000, 0x2152000, 0x12a000},\n\t  {1, 0x2160000, 0x2170000, 0x110000},\n\t  {1, 0x2170000, 0x2172000, 0x12e000},\n\t  {0, 0x0000000, 0x0000000, 0x000000},\n\t  {0, 0x0000000, 0x0000000, 0x000000},\n\t  {0, 0x0000000, 0x0000000, 0x000000},\n\t  {0, 0x0000000, 0x0000000, 0x000000},\n\t  {0, 0x0000000, 0x0000000, 0x000000},\n\t  {0, 0x0000000, 0x0000000, 0x000000},\n\t  {0, 0x0000000, 0x0000000, 0x000000},\n\t  {0, 0x0000000, 0x0000000, 0x000000} } },\n\t{{{1, 0x2200000, 0x2204000, 0x1b0000} } }, \n\t{{{0} } },\t\t\t\t \n\t{{{0} } },\t\t\t\t \n\t{{{0} } },\t\t\t\t \n\t{{{0} } },\t\t\t\t \n\t{{{0} } },\t\t\t\t \n\t{{{1, 0x2800000, 0x2804000, 0x1a4000} } }, \n\t{{{1, 0x2900000, 0x2901000, 0x16b000} } }, \n\t{{{1, 0x2a00000, 0x2a00400, 0x1ac400} } }, \n\t{{{1, 0x2b00000, 0x2b00400, 0x1ac800} } }, \n\t{{{1, 0x2c00000, 0x2c00400, 0x1acc00} } }, \n\t{{{1, 0x2d00000, 0x2d00400, 0x1ad000} } }, \n\t{{{1, 0x2e00000, 0x2e00400, 0x1ad400} } }, \n\t{{{1, 0x2f00000, 0x2f00400, 0x1ad800} } }, \n\t{{{1, 0x3000000, 0x3000400, 0x1adc00} } }, \n\t{{{0, 0x3100000, 0x3104000, 0x1a8000} } }, \n\t{{{1, 0x3200000, 0x3204000, 0x1d4000} } }, \n\t{{{1, 0x3300000, 0x3304000, 0x1a0000} } }, \n\t{{{0} } },\t\t\t\t \n\t{{{1, 0x3500000, 0x3500400, 0x1ac000} } }, \n\t{{{1, 0x3600000, 0x3600400, 0x1ae000} } }, \n\t{{{1, 0x3700000, 0x3700400, 0x1ae400} } }, \n\t{{{1, 0x3800000, 0x3804000, 0x1d0000} } }, \n\t{{{1, 0x3900000, 0x3904000, 0x1b4000} } }, \n\t{{{1, 0x3a00000, 0x3a04000, 0x1d8000} } }, \n\t{{{0} } },\t\t\t\t \n\t{{{0} } },\t\t\t\t \n\t{{{1, 0x3d00000, 0x3d04000, 0x1d8000} } }, \n\t{{{1, 0x3e00000, 0x3e01000, 0x167000} } }, \n\t{{{1, 0x3f00000, 0x3f01000, 0x168000} } }\t \n};\n\n \nstatic unsigned crb_hub_agt[64] =\n{\n\t0,\n\tNETXEN_HW_CRB_HUB_AGT_ADR_PS,\n\tNETXEN_HW_CRB_HUB_AGT_ADR_MN,\n\tNETXEN_HW_CRB_HUB_AGT_ADR_MS,\n\t0,\n\tNETXEN_HW_CRB_HUB_AGT_ADR_SRE,\n\tNETXEN_HW_CRB_HUB_AGT_ADR_NIU,\n\tNETXEN_HW_CRB_HUB_AGT_ADR_QMN,\n\tNETXEN_HW_CRB_HUB_AGT_ADR_SQN0,\n\tNETXEN_HW_CRB_HUB_AGT_ADR_SQN1,\n\tNETXEN_HW_CRB_HUB_AGT_ADR_SQN2,\n\tNETXEN_HW_CRB_HUB_AGT_ADR_SQN3,\n\tNETXEN_HW_CRB_HUB_AGT_ADR_I2Q,\n\tNETXEN_HW_CRB_HUB_AGT_ADR_TIMR,\n\tNETXEN_HW_CRB_HUB_AGT_ADR_ROMUSB,\n\tNETXEN_HW_CRB_HUB_AGT_ADR_PGN4,\n\tNETXEN_HW_CRB_HUB_AGT_ADR_XDMA,\n\tNETXEN_HW_CRB_HUB_AGT_ADR_PGN0,\n\tNETXEN_HW_CRB_HUB_AGT_ADR_PGN1,\n\tNETXEN_HW_CRB_HUB_AGT_ADR_PGN2,\n\tNETXEN_HW_CRB_HUB_AGT_ADR_PGN3,\n\tNETXEN_HW_CRB_HUB_AGT_ADR_PGND,\n\tNETXEN_HW_CRB_HUB_AGT_ADR_PGNI,\n\tNETXEN_HW_CRB_HUB_AGT_ADR_PGS0,\n\tNETXEN_HW_CRB_HUB_AGT_ADR_PGS1,\n\tNETXEN_HW_CRB_HUB_AGT_ADR_PGS2,\n\tNETXEN_HW_CRB_HUB_AGT_ADR_PGS3,\n\t0,\n\tNETXEN_HW_CRB_HUB_AGT_ADR_PGSI,\n\tNETXEN_HW_CRB_HUB_AGT_ADR_SN,\n\t0,\n\tNETXEN_HW_CRB_HUB_AGT_ADR_EG,\n\t0,\n\tNETXEN_HW_CRB_HUB_AGT_ADR_PS,\n\tNETXEN_HW_CRB_HUB_AGT_ADR_CAM,\n\t0,\n\t0,\n\t0,\n\t0,\n\t0,\n\tNETXEN_HW_CRB_HUB_AGT_ADR_TIMR,\n\t0,\n\tNETXEN_HW_CRB_HUB_AGT_ADR_RPMX1,\n\tNETXEN_HW_CRB_HUB_AGT_ADR_RPMX2,\n\tNETXEN_HW_CRB_HUB_AGT_ADR_RPMX3,\n\tNETXEN_HW_CRB_HUB_AGT_ADR_RPMX4,\n\tNETXEN_HW_CRB_HUB_AGT_ADR_RPMX5,\n\tNETXEN_HW_CRB_HUB_AGT_ADR_RPMX6,\n\tNETXEN_HW_CRB_HUB_AGT_ADR_RPMX7,\n\tNETXEN_HW_CRB_HUB_AGT_ADR_XDMA,\n\tNETXEN_HW_CRB_HUB_AGT_ADR_I2Q,\n\tNETXEN_HW_CRB_HUB_AGT_ADR_ROMUSB,\n\t0,\n\tNETXEN_HW_CRB_HUB_AGT_ADR_RPMX0,\n\tNETXEN_HW_CRB_HUB_AGT_ADR_RPMX8,\n\tNETXEN_HW_CRB_HUB_AGT_ADR_RPMX9,\n\tNETXEN_HW_CRB_HUB_AGT_ADR_OCM0,\n\t0,\n\tNETXEN_HW_CRB_HUB_AGT_ADR_SMB,\n\tNETXEN_HW_CRB_HUB_AGT_ADR_I2C0,\n\tNETXEN_HW_CRB_HUB_AGT_ADR_I2C1,\n\t0,\n\tNETXEN_HW_CRB_HUB_AGT_ADR_PGNC,\n\t0,\n};\n\n \n\n#define NETXEN_WINDOW_ONE \t0x2000000  \n\n#define NETXEN_PCIE_SEM_TIMEOUT\t10000\n\nstatic int netxen_nic_set_mtu_xgb(struct netxen_adapter *adapter, int new_mtu);\n\nint\nnetxen_pcie_sem_lock(struct netxen_adapter *adapter, int sem, u32 id_reg)\n{\n\tint done = 0, timeout = 0;\n\n\twhile (!done) {\n\t\tdone = NXRD32(adapter, NETXEN_PCIE_REG(PCIE_SEM_LOCK(sem)));\n\t\tif (done == 1)\n\t\t\tbreak;\n\t\tif (++timeout >= NETXEN_PCIE_SEM_TIMEOUT)\n\t\t\treturn -EIO;\n\t\tmsleep(1);\n\t}\n\n\tif (id_reg)\n\t\tNXWR32(adapter, id_reg, adapter->portnum);\n\n\treturn 0;\n}\n\nvoid\nnetxen_pcie_sem_unlock(struct netxen_adapter *adapter, int sem)\n{\n\tNXRD32(adapter, NETXEN_PCIE_REG(PCIE_SEM_UNLOCK(sem)));\n}\n\nstatic int netxen_niu_xg_init_port(struct netxen_adapter *adapter, int port)\n{\n\tif (NX_IS_REVISION_P2(adapter->ahw.revision_id)) {\n\t\tNXWR32(adapter, NETXEN_NIU_XGE_CONFIG_1+(0x10000*port), 0x1447);\n\t\tNXWR32(adapter, NETXEN_NIU_XGE_CONFIG_0+(0x10000*port), 0x5);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int netxen_niu_disable_xg_port(struct netxen_adapter *adapter)\n{\n\t__u32 mac_cfg;\n\tu32 port = adapter->physical_port;\n\n\tif (NX_IS_REVISION_P3(adapter->ahw.revision_id))\n\t\treturn 0;\n\n\tif (port >= NETXEN_NIU_MAX_XG_PORTS)\n\t\treturn -EINVAL;\n\n\tmac_cfg = 0;\n\tif (NXWR32(adapter,\n\t\t\tNETXEN_NIU_XGE_CONFIG_0 + (0x10000 * port), mac_cfg))\n\t\treturn -EIO;\n\treturn 0;\n}\n\n#define NETXEN_UNICAST_ADDR(port, index) \\\n\t(NETXEN_UNICAST_ADDR_BASE+(port*32)+(index*8))\n#define NETXEN_MCAST_ADDR(port, index) \\\n\t(NETXEN_MULTICAST_ADDR_BASE+(port*0x80)+(index*8))\n#define MAC_HI(addr) \\\n\t((addr[2] << 16) | (addr[1] << 8) | (addr[0]))\n#define MAC_LO(addr) \\\n\t((addr[5] << 16) | (addr[4] << 8) | (addr[3]))\n\nstatic int netxen_p2_nic_set_promisc(struct netxen_adapter *adapter, u32 mode)\n{\n\tu32 mac_cfg;\n\tu32 cnt = 0;\n\t__u32 reg = 0x0200;\n\tu32 port = adapter->physical_port;\n\tu16 board_type = adapter->ahw.board_type;\n\n\tif (port >= NETXEN_NIU_MAX_XG_PORTS)\n\t\treturn -EINVAL;\n\n\tmac_cfg = NXRD32(adapter, NETXEN_NIU_XGE_CONFIG_0 + (0x10000 * port));\n\tmac_cfg &= ~0x4;\n\tNXWR32(adapter, NETXEN_NIU_XGE_CONFIG_0 + (0x10000 * port), mac_cfg);\n\n\tif ((board_type == NETXEN_BRDTYPE_P2_SB31_10G_IMEZ) ||\n\t\t\t(board_type == NETXEN_BRDTYPE_P2_SB31_10G_HMEZ))\n\t\treg = (0x20 << port);\n\n\tNXWR32(adapter, NETXEN_NIU_FRAME_COUNT_SELECT, reg);\n\n\tmdelay(10);\n\n\twhile (NXRD32(adapter, NETXEN_NIU_FRAME_COUNT) && ++cnt < 20)\n\t\tmdelay(10);\n\n\tif (cnt < 20) {\n\n\t\treg = NXRD32(adapter,\n\t\t\tNETXEN_NIU_XGE_CONFIG_1 + (0x10000 * port));\n\n\t\tif (mode == NETXEN_NIU_PROMISC_MODE)\n\t\t\treg = (reg | 0x2000UL);\n\t\telse\n\t\t\treg = (reg & ~0x2000UL);\n\n\t\tif (mode == NETXEN_NIU_ALLMULTI_MODE)\n\t\t\treg = (reg | 0x1000UL);\n\t\telse\n\t\t\treg = (reg & ~0x1000UL);\n\n\t\tNXWR32(adapter,\n\t\t\tNETXEN_NIU_XGE_CONFIG_1 + (0x10000 * port), reg);\n\t}\n\n\tmac_cfg |= 0x4;\n\tNXWR32(adapter, NETXEN_NIU_XGE_CONFIG_0 + (0x10000 * port), mac_cfg);\n\n\treturn 0;\n}\n\nstatic int netxen_p2_nic_set_mac_addr(struct netxen_adapter *adapter, u8 *addr)\n{\n\tu32 mac_hi, mac_lo;\n\tu32 reg_hi, reg_lo;\n\n\tu8 phy = adapter->physical_port;\n\n\tif (phy >= NETXEN_NIU_MAX_XG_PORTS)\n\t\treturn -EINVAL;\n\n\tmac_lo = ((u32)addr[0] << 16) | ((u32)addr[1] << 24);\n\tmac_hi = addr[2] | ((u32)addr[3] << 8) |\n\t\t((u32)addr[4] << 16) | ((u32)addr[5] << 24);\n\n\treg_lo = NETXEN_NIU_XGE_STATION_ADDR_0_1 + (0x10000 * phy);\n\treg_hi = NETXEN_NIU_XGE_STATION_ADDR_0_HI + (0x10000 * phy);\n\n\t \n\tif (NXWR32(adapter, reg_lo, mac_lo) || NXWR32(adapter, reg_hi, mac_hi))\n\t\treturn -EIO;\n\tif (NXWR32(adapter, reg_lo, mac_lo) || NXWR32(adapter, reg_hi, mac_hi))\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic int\nnetxen_nic_enable_mcast_filter(struct netxen_adapter *adapter)\n{\n\tu32\tval = 0;\n\tu16 port = adapter->physical_port;\n\tu8 *addr = adapter->mac_addr;\n\n\tif (adapter->mc_enabled)\n\t\treturn 0;\n\n\tval = NXRD32(adapter, NETXEN_MAC_ADDR_CNTL_REG);\n\tval |= (1UL << (28+port));\n\tNXWR32(adapter, NETXEN_MAC_ADDR_CNTL_REG, val);\n\n\t \n\tval = 0xffffff;\n\tNXWR32(adapter, NETXEN_UNICAST_ADDR(port, 0), val);\n\tNXWR32(adapter, NETXEN_UNICAST_ADDR(port, 0)+4, val);\n\n\t \n\tval = MAC_HI(addr);\n\tNXWR32(adapter, NETXEN_UNICAST_ADDR(port, 1), val);\n\tval = MAC_LO(addr);\n\tNXWR32(adapter, NETXEN_UNICAST_ADDR(port, 1)+4, val);\n\n\tadapter->mc_enabled = 1;\n\treturn 0;\n}\n\nstatic int\nnetxen_nic_disable_mcast_filter(struct netxen_adapter *adapter)\n{\n\tu32\tval = 0;\n\tu16 port = adapter->physical_port;\n\tu8 *addr = adapter->mac_addr;\n\n\tif (!adapter->mc_enabled)\n\t\treturn 0;\n\n\tval = NXRD32(adapter, NETXEN_MAC_ADDR_CNTL_REG);\n\tval &= ~(1UL << (28+port));\n\tNXWR32(adapter, NETXEN_MAC_ADDR_CNTL_REG, val);\n\n\tval = MAC_HI(addr);\n\tNXWR32(adapter, NETXEN_UNICAST_ADDR(port, 0), val);\n\tval = MAC_LO(addr);\n\tNXWR32(adapter, NETXEN_UNICAST_ADDR(port, 0)+4, val);\n\n\tNXWR32(adapter, NETXEN_UNICAST_ADDR(port, 1), 0);\n\tNXWR32(adapter, NETXEN_UNICAST_ADDR(port, 1)+4, 0);\n\n\tadapter->mc_enabled = 0;\n\treturn 0;\n}\n\nstatic int\nnetxen_nic_set_mcast_addr(struct netxen_adapter *adapter,\n\t\tint index, u8 *addr)\n{\n\tu32 hi = 0, lo = 0;\n\tu16 port = adapter->physical_port;\n\n\tlo = MAC_LO(addr);\n\thi = MAC_HI(addr);\n\n\tNXWR32(adapter, NETXEN_MCAST_ADDR(port, index), hi);\n\tNXWR32(adapter, NETXEN_MCAST_ADDR(port, index)+4, lo);\n\n\treturn 0;\n}\n\nstatic void netxen_p2_nic_set_multi(struct net_device *netdev)\n{\n\tstruct netxen_adapter *adapter = netdev_priv(netdev);\n\tstruct netdev_hw_addr *ha;\n\tu8 null_addr[ETH_ALEN];\n\tint i;\n\n\teth_zero_addr(null_addr);\n\n\tif (netdev->flags & IFF_PROMISC) {\n\n\t\tadapter->set_promisc(adapter,\n\t\t\t\tNETXEN_NIU_PROMISC_MODE);\n\n\t\t \n\t\tnetxen_nic_disable_mcast_filter(adapter);\n\n\t\treturn;\n\t}\n\n\tif (netdev_mc_empty(netdev)) {\n\t\tadapter->set_promisc(adapter,\n\t\t\t\tNETXEN_NIU_NON_PROMISC_MODE);\n\t\tnetxen_nic_disable_mcast_filter(adapter);\n\t\treturn;\n\t}\n\n\tadapter->set_promisc(adapter, NETXEN_NIU_ALLMULTI_MODE);\n\tif (netdev->flags & IFF_ALLMULTI ||\n\t\t\tnetdev_mc_count(netdev) > adapter->max_mc_count) {\n\t\tnetxen_nic_disable_mcast_filter(adapter);\n\t\treturn;\n\t}\n\n\tnetxen_nic_enable_mcast_filter(adapter);\n\n\ti = 0;\n\tnetdev_for_each_mc_addr(ha, netdev)\n\t\tnetxen_nic_set_mcast_addr(adapter, i++, ha->addr);\n\n\t \n\twhile (i < adapter->max_mc_count)\n\t\tnetxen_nic_set_mcast_addr(adapter, i++, null_addr);\n}\n\nstatic int\nnetxen_send_cmd_descs(struct netxen_adapter *adapter,\n\t\tstruct cmd_desc_type0 *cmd_desc_arr, int nr_desc)\n{\n\tu32 i, producer;\n\tstruct netxen_cmd_buffer *pbuf;\n\tstruct nx_host_tx_ring *tx_ring;\n\n\ti = 0;\n\n\tif (adapter->is_up != NETXEN_ADAPTER_UP_MAGIC)\n\t\treturn -EIO;\n\n\ttx_ring = adapter->tx_ring;\n\t__netif_tx_lock_bh(tx_ring->txq);\n\n\tproducer = tx_ring->producer;\n\n\tif (nr_desc >= netxen_tx_avail(tx_ring)) {\n\t\tnetif_tx_stop_queue(tx_ring->txq);\n\t\tsmp_mb();\n\t\tif (netxen_tx_avail(tx_ring) > nr_desc) {\n\t\t\tif (netxen_tx_avail(tx_ring) > TX_STOP_THRESH)\n\t\t\t\tnetif_tx_wake_queue(tx_ring->txq);\n\t\t} else {\n\t\t\t__netif_tx_unlock_bh(tx_ring->txq);\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\n\tdo {\n\t\tpbuf = &tx_ring->cmd_buf_arr[producer];\n\t\tpbuf->skb = NULL;\n\t\tpbuf->frag_count = 0;\n\n\t\tmemcpy(&tx_ring->desc_head[producer],\n\t\t\t&cmd_desc_arr[i], sizeof(struct cmd_desc_type0));\n\n\t\tproducer = get_next_index(producer, tx_ring->num_desc);\n\t\ti++;\n\n\t} while (i != nr_desc);\n\n\ttx_ring->producer = producer;\n\n\tnetxen_nic_update_cmd_producer(adapter, tx_ring);\n\n\t__netif_tx_unlock_bh(tx_ring->txq);\n\n\treturn 0;\n}\n\nstatic int\nnx_p3_sre_macaddr_change(struct netxen_adapter *adapter, u8 *addr, unsigned op)\n{\n\tnx_nic_req_t req;\n\tnx_mac_req_t *mac_req;\n\tu64 word;\n\n\tmemset(&req, 0, sizeof(nx_nic_req_t));\n\treq.qhdr = cpu_to_le64(NX_NIC_REQUEST << 23);\n\n\tword = NX_MAC_EVENT | ((u64)adapter->portnum << 16);\n\treq.req_hdr = cpu_to_le64(word);\n\n\tmac_req = (nx_mac_req_t *)&req.words[0];\n\tmac_req->op = op;\n\tmemcpy(mac_req->mac_addr, addr, ETH_ALEN);\n\n\treturn netxen_send_cmd_descs(adapter, (struct cmd_desc_type0 *)&req, 1);\n}\n\nstatic int nx_p3_nic_add_mac(struct netxen_adapter *adapter,\n\t\tconst u8 *addr, struct list_head *del_list)\n{\n\tstruct list_head *head;\n\tnx_mac_list_t *cur;\n\n\t \n\tlist_for_each(head, del_list) {\n\t\tcur = list_entry(head, nx_mac_list_t, list);\n\n\t\tif (ether_addr_equal(addr, cur->mac_addr)) {\n\t\t\tlist_move_tail(head, &adapter->mac_list);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tcur = kzalloc(sizeof(nx_mac_list_t), GFP_ATOMIC);\n\tif (cur == NULL)\n\t\treturn -ENOMEM;\n\n\tmemcpy(cur->mac_addr, addr, ETH_ALEN);\n\tlist_add_tail(&cur->list, &adapter->mac_list);\n\treturn nx_p3_sre_macaddr_change(adapter,\n\t\t\t\tcur->mac_addr, NETXEN_MAC_ADD);\n}\n\nstatic void netxen_p3_nic_set_multi(struct net_device *netdev)\n{\n\tstruct netxen_adapter *adapter = netdev_priv(netdev);\n\tstruct netdev_hw_addr *ha;\n\tstatic const u8 bcast_addr[ETH_ALEN] = {\n\t\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff\n\t};\n\tu32 mode = VPORT_MISS_MODE_DROP;\n\tLIST_HEAD(del_list);\n\tstruct list_head *head;\n\tnx_mac_list_t *cur;\n\n\tif (adapter->is_up != NETXEN_ADAPTER_UP_MAGIC)\n\t\treturn;\n\n\tlist_splice_tail_init(&adapter->mac_list, &del_list);\n\n\tnx_p3_nic_add_mac(adapter, adapter->mac_addr, &del_list);\n\tnx_p3_nic_add_mac(adapter, bcast_addr, &del_list);\n\n\tif (netdev->flags & IFF_PROMISC) {\n\t\tmode = VPORT_MISS_MODE_ACCEPT_ALL;\n\t\tgoto send_fw_cmd;\n\t}\n\n\tif ((netdev->flags & IFF_ALLMULTI) ||\n\t\t\t(netdev_mc_count(netdev) > adapter->max_mc_count)) {\n\t\tmode = VPORT_MISS_MODE_ACCEPT_MULTI;\n\t\tgoto send_fw_cmd;\n\t}\n\n\tif (!netdev_mc_empty(netdev)) {\n\t\tnetdev_for_each_mc_addr(ha, netdev)\n\t\t\tnx_p3_nic_add_mac(adapter, ha->addr, &del_list);\n\t}\n\nsend_fw_cmd:\n\tadapter->set_promisc(adapter, mode);\n\thead = &del_list;\n\twhile (!list_empty(head)) {\n\t\tcur = list_entry(head->next, nx_mac_list_t, list);\n\n\t\tnx_p3_sre_macaddr_change(adapter,\n\t\t\t\tcur->mac_addr, NETXEN_MAC_DEL);\n\t\tlist_del(&cur->list);\n\t\tkfree(cur);\n\t}\n}\n\nstatic int netxen_p3_nic_set_promisc(struct netxen_adapter *adapter, u32 mode)\n{\n\tnx_nic_req_t req;\n\tu64 word;\n\n\tmemset(&req, 0, sizeof(nx_nic_req_t));\n\n\treq.qhdr = cpu_to_le64(NX_HOST_REQUEST << 23);\n\n\tword = NX_NIC_H2C_OPCODE_PROXY_SET_VPORT_MISS_MODE |\n\t\t\t((u64)adapter->portnum << 16);\n\treq.req_hdr = cpu_to_le64(word);\n\n\treq.words[0] = cpu_to_le64(mode);\n\n\treturn netxen_send_cmd_descs(adapter,\n\t\t\t\t(struct cmd_desc_type0 *)&req, 1);\n}\n\nvoid netxen_p3_free_mac_list(struct netxen_adapter *adapter)\n{\n\tnx_mac_list_t *cur;\n\tstruct list_head *head = &adapter->mac_list;\n\n\twhile (!list_empty(head)) {\n\t\tcur = list_entry(head->next, nx_mac_list_t, list);\n\t\tnx_p3_sre_macaddr_change(adapter,\n\t\t\t\tcur->mac_addr, NETXEN_MAC_DEL);\n\t\tlist_del(&cur->list);\n\t\tkfree(cur);\n\t}\n}\n\nstatic int netxen_p3_nic_set_mac_addr(struct netxen_adapter *adapter, u8 *addr)\n{\n\t \n\tnetxen_p3_nic_set_multi(adapter->netdev);\n\treturn 0;\n}\n\n#define\tNETXEN_CONFIG_INTR_COALESCE\t3\n\n \nint netxen_config_intr_coalesce(struct netxen_adapter *adapter)\n{\n\tnx_nic_req_t req;\n\tu64 word[6];\n\tint rv, i;\n\n\tmemset(&req, 0, sizeof(nx_nic_req_t));\n\tmemset(word, 0, sizeof(word));\n\n\treq.qhdr = cpu_to_le64(NX_HOST_REQUEST << 23);\n\n\tword[0] = NETXEN_CONFIG_INTR_COALESCE | ((u64)adapter->portnum << 16);\n\treq.req_hdr = cpu_to_le64(word[0]);\n\n\tmemcpy(&word[0], &adapter->coal, sizeof(adapter->coal));\n\tfor (i = 0; i < 6; i++)\n\t\treq.words[i] = cpu_to_le64(word[i]);\n\n\trv = netxen_send_cmd_descs(adapter, (struct cmd_desc_type0 *)&req, 1);\n\tif (rv != 0) {\n\t\tprintk(KERN_ERR \"ERROR. Could not send \"\n\t\t\t\"interrupt coalescing parameters\\n\");\n\t}\n\n\treturn rv;\n}\n\nint netxen_config_hw_lro(struct netxen_adapter *adapter, int enable)\n{\n\tnx_nic_req_t req;\n\tu64 word;\n\tint rv = 0;\n\n\tif (!test_bit(__NX_FW_ATTACHED, &adapter->state))\n\t\treturn 0;\n\n\tmemset(&req, 0, sizeof(nx_nic_req_t));\n\n\treq.qhdr = cpu_to_le64(NX_HOST_REQUEST << 23);\n\n\tword = NX_NIC_H2C_OPCODE_CONFIG_HW_LRO | ((u64)adapter->portnum << 16);\n\treq.req_hdr = cpu_to_le64(word);\n\n\treq.words[0] = cpu_to_le64(enable);\n\n\trv = netxen_send_cmd_descs(adapter, (struct cmd_desc_type0 *)&req, 1);\n\tif (rv != 0) {\n\t\tprintk(KERN_ERR \"ERROR. Could not send \"\n\t\t\t\"configure hw lro request\\n\");\n\t}\n\n\treturn rv;\n}\n\nint netxen_config_bridged_mode(struct netxen_adapter *adapter, int enable)\n{\n\tnx_nic_req_t req;\n\tu64 word;\n\tint rv = 0;\n\n\tif (!!(adapter->flags & NETXEN_NIC_BRIDGE_ENABLED) == enable)\n\t\treturn rv;\n\n\tmemset(&req, 0, sizeof(nx_nic_req_t));\n\n\treq.qhdr = cpu_to_le64(NX_HOST_REQUEST << 23);\n\n\tword = NX_NIC_H2C_OPCODE_CONFIG_BRIDGING |\n\t\t((u64)adapter->portnum << 16);\n\treq.req_hdr = cpu_to_le64(word);\n\n\treq.words[0] = cpu_to_le64(enable);\n\n\trv = netxen_send_cmd_descs(adapter, (struct cmd_desc_type0 *)&req, 1);\n\tif (rv != 0) {\n\t\tprintk(KERN_ERR \"ERROR. Could not send \"\n\t\t\t\t\"configure bridge mode request\\n\");\n\t}\n\n\tadapter->flags ^= NETXEN_NIC_BRIDGE_ENABLED;\n\n\treturn rv;\n}\n\n\n#define RSS_HASHTYPE_IP_TCP\t0x3\n\nint netxen_config_rss(struct netxen_adapter *adapter, int enable)\n{\n\tnx_nic_req_t req;\n\tu64 word;\n\tint i, rv;\n\n\tstatic const u64 key[] = {\n\t\t0xbeac01fa6a42b73bULL, 0x8030f20c77cb2da3ULL,\n\t\t0xae7b30b4d0ca2bcbULL, 0x43a38fb04167253dULL,\n\t\t0x255b0ec26d5a56daULL\n\t};\n\n\n\tmemset(&req, 0, sizeof(nx_nic_req_t));\n\treq.qhdr = cpu_to_le64(NX_HOST_REQUEST << 23);\n\n\tword = NX_NIC_H2C_OPCODE_CONFIG_RSS | ((u64)adapter->portnum << 16);\n\treq.req_hdr = cpu_to_le64(word);\n\n\t \n\tword =  ((u64)(RSS_HASHTYPE_IP_TCP & 0x3) << 4) |\n\t\t((u64)(RSS_HASHTYPE_IP_TCP & 0x3) << 6) |\n\t\t((u64)(enable & 0x1) << 8) |\n\t\t((0x7ULL) << 48);\n\treq.words[0] = cpu_to_le64(word);\n\tfor (i = 0; i < ARRAY_SIZE(key); i++)\n\t\treq.words[i+1] = cpu_to_le64(key[i]);\n\n\n\trv = netxen_send_cmd_descs(adapter, (struct cmd_desc_type0 *)&req, 1);\n\tif (rv != 0) {\n\t\tprintk(KERN_ERR \"%s: could not configure RSS\\n\",\n\t\t\t\tadapter->netdev->name);\n\t}\n\n\treturn rv;\n}\n\nint netxen_config_ipaddr(struct netxen_adapter *adapter, __be32 ip, int cmd)\n{\n\tnx_nic_req_t req;\n\tu64 word;\n\tint rv;\n\n\tmemset(&req, 0, sizeof(nx_nic_req_t));\n\treq.qhdr = cpu_to_le64(NX_HOST_REQUEST << 23);\n\n\tword = NX_NIC_H2C_OPCODE_CONFIG_IPADDR | ((u64)adapter->portnum << 16);\n\treq.req_hdr = cpu_to_le64(word);\n\n\treq.words[0] = cpu_to_le64(cmd);\n\tmemcpy(&req.words[1], &ip, sizeof(u32));\n\n\trv = netxen_send_cmd_descs(adapter, (struct cmd_desc_type0 *)&req, 1);\n\tif (rv != 0) {\n\t\tprintk(KERN_ERR \"%s: could not notify %s IP 0x%x request\\n\",\n\t\t\t\tadapter->netdev->name,\n\t\t\t\t(cmd == NX_IP_UP) ? \"Add\" : \"Remove\", ip);\n\t}\n\treturn rv;\n}\n\nint netxen_linkevent_request(struct netxen_adapter *adapter, int enable)\n{\n\tnx_nic_req_t req;\n\tu64 word;\n\tint rv;\n\n\tmemset(&req, 0, sizeof(nx_nic_req_t));\n\treq.qhdr = cpu_to_le64(NX_HOST_REQUEST << 23);\n\n\tword = NX_NIC_H2C_OPCODE_GET_LINKEVENT | ((u64)adapter->portnum << 16);\n\treq.req_hdr = cpu_to_le64(word);\n\treq.words[0] = cpu_to_le64(enable | (enable << 8));\n\n\trv = netxen_send_cmd_descs(adapter, (struct cmd_desc_type0 *)&req, 1);\n\tif (rv != 0) {\n\t\tprintk(KERN_ERR \"%s: could not configure link notification\\n\",\n\t\t\t\tadapter->netdev->name);\n\t}\n\n\treturn rv;\n}\n\nint netxen_send_lro_cleanup(struct netxen_adapter *adapter)\n{\n\tnx_nic_req_t req;\n\tu64 word;\n\tint rv;\n\n\tif (!test_bit(__NX_FW_ATTACHED, &adapter->state))\n\t\treturn 0;\n\n\tmemset(&req, 0, sizeof(nx_nic_req_t));\n\treq.qhdr = cpu_to_le64(NX_HOST_REQUEST << 23);\n\n\tword = NX_NIC_H2C_OPCODE_LRO_REQUEST |\n\t\t((u64)adapter->portnum << 16) |\n\t\t((u64)NX_NIC_LRO_REQUEST_CLEANUP << 56) ;\n\n\treq.req_hdr = cpu_to_le64(word);\n\n\trv = netxen_send_cmd_descs(adapter, (struct cmd_desc_type0 *)&req, 1);\n\tif (rv != 0) {\n\t\tprintk(KERN_ERR \"%s: could not cleanup lro flows\\n\",\n\t\t\t\tadapter->netdev->name);\n\t}\n\treturn rv;\n}\n\n \n\n#define MTU_FUDGE_FACTOR\t100\n\nint netxen_nic_change_mtu(struct net_device *netdev, int mtu)\n{\n\tstruct netxen_adapter *adapter = netdev_priv(netdev);\n\tint rc = 0;\n\n\tif (adapter->set_mtu)\n\t\trc = adapter->set_mtu(adapter, mtu);\n\n\tif (!rc)\n\t\tnetdev->mtu = mtu;\n\n\treturn rc;\n}\n\nstatic int netxen_get_flash_block(struct netxen_adapter *adapter, int base,\n\t\t\t\t  int size, __le32 * buf)\n{\n\tint i, v, addr;\n\t__le32 *ptr32;\n\tint ret;\n\n\taddr = base;\n\tptr32 = buf;\n\tfor (i = 0; i < size / sizeof(u32); i++) {\n\t\tret = netxen_rom_fast_read(adapter, addr, &v);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t*ptr32 = cpu_to_le32(v);\n\t\tptr32++;\n\t\taddr += sizeof(u32);\n\t}\n\tif ((char *)buf + size > (char *)ptr32) {\n\t\t__le32 local;\n\t\tret = netxen_rom_fast_read(adapter, addr, &v);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tlocal = cpu_to_le32(v);\n\t\tmemcpy(ptr32, &local, (char *)buf + size - (char *)ptr32);\n\t}\n\n\treturn 0;\n}\n\nint netxen_get_flash_mac_addr(struct netxen_adapter *adapter, u64 *mac)\n{\n\t__le32 *pmac = (__le32 *) mac;\n\tu32 offset;\n\n\toffset = NX_FW_MAC_ADDR_OFFSET + (adapter->portnum * sizeof(u64));\n\n\tif (netxen_get_flash_block(adapter, offset, sizeof(u64), pmac) == -1)\n\t\treturn -1;\n\n\tif (*mac == ~0ULL) {\n\n\t\toffset = NX_OLD_MAC_ADDR_OFFSET +\n\t\t\t(adapter->portnum * sizeof(u64));\n\n\t\tif (netxen_get_flash_block(adapter,\n\t\t\t\t\toffset, sizeof(u64), pmac) == -1)\n\t\t\treturn -1;\n\n\t\tif (*mac == ~0ULL)\n\t\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nint netxen_p3_get_mac_addr(struct netxen_adapter *adapter, u64 *mac)\n{\n\tuint32_t crbaddr, mac_hi, mac_lo;\n\tint pci_func = adapter->ahw.pci_func;\n\n\tcrbaddr = CRB_MAC_BLOCK_START +\n\t\t(4 * ((pci_func/2) * 3)) + (4 * (pci_func & 1));\n\n\tmac_lo = NXRD32(adapter, crbaddr);\n\tmac_hi = NXRD32(adapter, crbaddr+4);\n\n\tif (pci_func & 1)\n\t\t*mac = le64_to_cpu((mac_lo >> 16) | ((u64)mac_hi << 16));\n\telse\n\t\t*mac = le64_to_cpu((u64)mac_lo | ((u64)mac_hi << 32));\n\n\treturn 0;\n}\n\n \nstatic void\nnetxen_nic_pci_set_crbwindow_128M(struct netxen_adapter *adapter,\n\t\tu32 window)\n{\n\tvoid __iomem *offset;\n\tint count = 10;\n\tu8 func = adapter->ahw.pci_func;\n\n\tif (adapter->ahw.crb_win == window)\n\t\treturn;\n\n\toffset = PCI_OFFSET_SECOND_RANGE(adapter,\n\t\t\tNETXEN_PCIX_PH_REG(PCIE_CRB_WINDOW_REG(func)));\n\n\twritel(window, offset);\n\tdo {\n\t\tif (window == readl(offset))\n\t\t\tbreak;\n\n\t\tif (printk_ratelimit())\n\t\t\tdev_warn(&adapter->pdev->dev,\n\t\t\t\t\t\"failed to set CRB window to %d\\n\",\n\t\t\t\t\t(window == NETXEN_WINDOW_ONE));\n\t\tudelay(1);\n\n\t} while (--count > 0);\n\n\tif (count > 0)\n\t\tadapter->ahw.crb_win = window;\n}\n\n \nstatic int\nnetxen_nic_pci_get_crb_addr_2M(struct netxen_adapter *adapter,\n\t\tulong off, void __iomem **addr)\n{\n\tcrb_128M_2M_sub_block_map_t *m;\n\n\n\tif ((off >= NETXEN_CRB_MAX) || (off < NETXEN_PCI_CRBSPACE))\n\t\treturn -EINVAL;\n\n\toff -= NETXEN_PCI_CRBSPACE;\n\n\t \n\tm = &crb_128M_2M_map[CRB_BLK(off)].sub_block[CRB_SUBBLK(off)];\n\n\tif (m->valid && (m->start_128M <= off) && (m->end_128M > off)) {\n\t\t*addr = adapter->ahw.pci_base0 + m->start_2M +\n\t\t\t(off - m->start_128M);\n\t\treturn 0;\n\t}\n\n\t \n\t*addr = adapter->ahw.pci_base0 + CRB_INDIRECT_2M +\n\t\t(off & MASK(16));\n\treturn 1;\n}\n\n \nstatic void\nnetxen_nic_pci_set_crbwindow_2M(struct netxen_adapter *adapter, ulong off)\n{\n\tu32 window;\n\tvoid __iomem *addr = adapter->ahw.pci_base0 + CRB_WINDOW_2M;\n\n\toff -= NETXEN_PCI_CRBSPACE;\n\n\twindow = CRB_HI(off);\n\n\twritel(window, addr);\n\tif (readl(addr) != window) {\n\t\tif (printk_ratelimit())\n\t\t\tdev_warn(&adapter->pdev->dev,\n\t\t\t\t\"failed to set CRB window to %d off 0x%lx\\n\",\n\t\t\t\twindow, off);\n\t}\n}\n\nstatic void __iomem *\nnetxen_nic_map_indirect_address_128M(struct netxen_adapter *adapter,\n\t\tulong win_off, void __iomem **mem_ptr)\n{\n\tulong off = win_off;\n\tvoid __iomem *addr;\n\tresource_size_t mem_base;\n\n\tif (ADDR_IN_WINDOW1(win_off))\n\t\toff = NETXEN_CRB_NORMAL(win_off);\n\n\taddr = pci_base_offset(adapter, off);\n\tif (addr)\n\t\treturn addr;\n\n\tif (adapter->ahw.pci_len0 == 0)\n\t\toff -= NETXEN_PCI_CRBSPACE;\n\n\tmem_base = pci_resource_start(adapter->pdev, 0);\n\t*mem_ptr = ioremap(mem_base + (off & PAGE_MASK), PAGE_SIZE);\n\tif (*mem_ptr)\n\t\taddr = *mem_ptr + (off & (PAGE_SIZE - 1));\n\n\treturn addr;\n}\n\nstatic int\nnetxen_nic_hw_write_wx_128M(struct netxen_adapter *adapter, ulong off, u32 data)\n{\n\tunsigned long flags;\n\tvoid __iomem *addr, *mem_ptr = NULL;\n\n\taddr = netxen_nic_map_indirect_address_128M(adapter, off, &mem_ptr);\n\tif (!addr)\n\t\treturn -EIO;\n\n\tif (ADDR_IN_WINDOW1(off)) {  \n\t\tnetxen_nic_io_write_128M(adapter, addr, data);\n\t} else {         \n\t\twrite_lock_irqsave(&adapter->ahw.crb_lock, flags);\n\t\tnetxen_nic_pci_set_crbwindow_128M(adapter, 0);\n\t\twritel(data, addr);\n\t\tnetxen_nic_pci_set_crbwindow_128M(adapter,\n\t\t\t\tNETXEN_WINDOW_ONE);\n\t\twrite_unlock_irqrestore(&adapter->ahw.crb_lock, flags);\n\t}\n\n\tif (mem_ptr)\n\t\tiounmap(mem_ptr);\n\n\treturn 0;\n}\n\nstatic u32\nnetxen_nic_hw_read_wx_128M(struct netxen_adapter *adapter, ulong off)\n{\n\tunsigned long flags;\n\tvoid __iomem *addr, *mem_ptr = NULL;\n\tu32 data;\n\n\taddr = netxen_nic_map_indirect_address_128M(adapter, off, &mem_ptr);\n\tif (!addr)\n\t\treturn -EIO;\n\n\tif (ADDR_IN_WINDOW1(off)) {  \n\t\tdata = netxen_nic_io_read_128M(adapter, addr);\n\t} else {         \n\t\twrite_lock_irqsave(&adapter->ahw.crb_lock, flags);\n\t\tnetxen_nic_pci_set_crbwindow_128M(adapter, 0);\n\t\tdata = readl(addr);\n\t\tnetxen_nic_pci_set_crbwindow_128M(adapter,\n\t\t\t\tNETXEN_WINDOW_ONE);\n\t\twrite_unlock_irqrestore(&adapter->ahw.crb_lock, flags);\n\t}\n\n\tif (mem_ptr)\n\t\tiounmap(mem_ptr);\n\n\treturn data;\n}\n\nstatic int\nnetxen_nic_hw_write_wx_2M(struct netxen_adapter *adapter, ulong off, u32 data)\n{\n\tunsigned long flags;\n\tint rv;\n\tvoid __iomem *addr = NULL;\n\n\trv = netxen_nic_pci_get_crb_addr_2M(adapter, off, &addr);\n\n\tif (rv == 0) {\n\t\twritel(data, addr);\n\t\treturn 0;\n\t}\n\n\tif (rv > 0) {\n\t\t \n\t\twrite_lock_irqsave(&adapter->ahw.crb_lock, flags);\n\t\tcrb_win_lock(adapter);\n\t\tnetxen_nic_pci_set_crbwindow_2M(adapter, off);\n\t\twritel(data, addr);\n\t\tcrb_win_unlock(adapter);\n\t\twrite_unlock_irqrestore(&adapter->ahw.crb_lock, flags);\n\t\treturn 0;\n\t}\n\n\tdev_err(&adapter->pdev->dev,\n\t\t\t\"%s: invalid offset: 0x%016lx\\n\", __func__, off);\n\tdump_stack();\n\treturn -EIO;\n}\n\nstatic u32\nnetxen_nic_hw_read_wx_2M(struct netxen_adapter *adapter, ulong off)\n{\n\tunsigned long flags;\n\tint rv;\n\tu32 data;\n\tvoid __iomem *addr = NULL;\n\n\trv = netxen_nic_pci_get_crb_addr_2M(adapter, off, &addr);\n\n\tif (rv == 0)\n\t\treturn readl(addr);\n\n\tif (rv > 0) {\n\t\t \n\t\twrite_lock_irqsave(&adapter->ahw.crb_lock, flags);\n\t\tcrb_win_lock(adapter);\n\t\tnetxen_nic_pci_set_crbwindow_2M(adapter, off);\n\t\tdata = readl(addr);\n\t\tcrb_win_unlock(adapter);\n\t\twrite_unlock_irqrestore(&adapter->ahw.crb_lock, flags);\n\t\treturn data;\n\t}\n\n\tdev_err(&adapter->pdev->dev,\n\t\t\t\"%s: invalid offset: 0x%016lx\\n\", __func__, off);\n\tdump_stack();\n\treturn -1;\n}\n\n \nstatic void netxen_nic_io_write_128M(struct netxen_adapter *adapter,\n\t\tvoid __iomem *addr, u32 data)\n{\n\tread_lock(&adapter->ahw.crb_lock);\n\twritel(data, addr);\n\tread_unlock(&adapter->ahw.crb_lock);\n}\n\nstatic u32 netxen_nic_io_read_128M(struct netxen_adapter *adapter,\n\t\tvoid __iomem *addr)\n{\n\tu32 val;\n\n\tread_lock(&adapter->ahw.crb_lock);\n\tval = readl(addr);\n\tread_unlock(&adapter->ahw.crb_lock);\n\n\treturn val;\n}\n\nstatic void netxen_nic_io_write_2M(struct netxen_adapter *adapter,\n\t\tvoid __iomem *addr, u32 data)\n{\n\twritel(data, addr);\n}\n\nstatic u32 netxen_nic_io_read_2M(struct netxen_adapter *adapter,\n\t\tvoid __iomem *addr)\n{\n\treturn readl(addr);\n}\n\nvoid __iomem *\nnetxen_get_ioaddr(struct netxen_adapter *adapter, u32 offset)\n{\n\tvoid __iomem *addr = NULL;\n\n\tif (NX_IS_REVISION_P2(adapter->ahw.revision_id)) {\n\t\tif ((offset < NETXEN_CRB_PCIX_HOST2) &&\n\t\t\t\t(offset > NETXEN_CRB_PCIX_HOST))\n\t\t\taddr = PCI_OFFSET_SECOND_RANGE(adapter, offset);\n\t\telse\n\t\t\taddr = NETXEN_CRB_NORMALIZE(adapter, offset);\n\t} else {\n\t\tWARN_ON(netxen_nic_pci_get_crb_addr_2M(adapter,\n\t\t\t\t\toffset, &addr));\n\t}\n\n\treturn addr;\n}\n\nstatic int\nnetxen_nic_pci_set_window_128M(struct netxen_adapter *adapter,\n\t\tu64 addr, u32 *start)\n{\n\tif (ADDR_IN_RANGE(addr, NETXEN_ADDR_OCM0, NETXEN_ADDR_OCM0_MAX)) {\n\t\t*start = (addr - NETXEN_ADDR_OCM0  + NETXEN_PCI_OCM0);\n\t\treturn 0;\n\t} else if (ADDR_IN_RANGE(addr,\n\t\t\t\tNETXEN_ADDR_OCM1, NETXEN_ADDR_OCM1_MAX)) {\n\t\t*start = (addr - NETXEN_ADDR_OCM1 + NETXEN_PCI_OCM1);\n\t\treturn 0;\n\t}\n\n\treturn -EIO;\n}\n\nstatic int\nnetxen_nic_pci_set_window_2M(struct netxen_adapter *adapter,\n\t\tu64 addr, u32 *start)\n{\n\tu32 window;\n\n\twindow = OCM_WIN(addr);\n\n\twritel(window, adapter->ahw.ocm_win_crb);\n\t \n\treadl(adapter->ahw.ocm_win_crb);\n\n\tadapter->ahw.ocm_win = window;\n\t*start = NETXEN_PCI_OCM0_2M + GET_MEM_OFFS_2M(addr);\n\treturn 0;\n}\n\nstatic int\nnetxen_nic_pci_mem_access_direct(struct netxen_adapter *adapter, u64 off,\n\t\tu64 *data, int op)\n{\n\tvoid __iomem *addr, *mem_ptr = NULL;\n\tresource_size_t mem_base;\n\tint ret;\n\tu32 start;\n\n\tspin_lock(&adapter->ahw.mem_lock);\n\n\tret = adapter->pci_set_window(adapter, off, &start);\n\tif (ret != 0)\n\t\tgoto unlock;\n\n\tif (NX_IS_REVISION_P3(adapter->ahw.revision_id)) {\n\t\taddr = adapter->ahw.pci_base0 + start;\n\t} else {\n\t\taddr = pci_base_offset(adapter, start);\n\t\tif (addr)\n\t\t\tgoto noremap;\n\n\t\tmem_base = pci_resource_start(adapter->pdev, 0) +\n\t\t\t\t\t(start & PAGE_MASK);\n\t\tmem_ptr = ioremap(mem_base, PAGE_SIZE);\n\t\tif (mem_ptr == NULL) {\n\t\t\tret = -EIO;\n\t\t\tgoto unlock;\n\t\t}\n\n\t\taddr = mem_ptr + (start & (PAGE_SIZE-1));\n\t}\nnoremap:\n\tif (op == 0)\t \n\t\t*data = readq(addr);\n\telse\t\t \n\t\twriteq(*data, addr);\n\nunlock:\n\tspin_unlock(&adapter->ahw.mem_lock);\n\n\tif (mem_ptr)\n\t\tiounmap(mem_ptr);\n\treturn ret;\n}\n\nvoid\nnetxen_pci_camqm_read_2M(struct netxen_adapter *adapter, u64 off, u64 *data)\n{\n\tvoid __iomem *addr = adapter->ahw.pci_base0 +\n\t\tNETXEN_PCI_CAMQM_2M_BASE + (off - NETXEN_PCI_CAMQM);\n\n\tspin_lock(&adapter->ahw.mem_lock);\n\t*data = readq(addr);\n\tspin_unlock(&adapter->ahw.mem_lock);\n}\n\nvoid\nnetxen_pci_camqm_write_2M(struct netxen_adapter *adapter, u64 off, u64 data)\n{\n\tvoid __iomem *addr = adapter->ahw.pci_base0 +\n\t\tNETXEN_PCI_CAMQM_2M_BASE + (off - NETXEN_PCI_CAMQM);\n\n\tspin_lock(&adapter->ahw.mem_lock);\n\twriteq(data, addr);\n\tspin_unlock(&adapter->ahw.mem_lock);\n}\n\n#define MAX_CTL_CHECK   1000\n\nstatic int\nnetxen_nic_pci_mem_write_128M(struct netxen_adapter *adapter,\n\t\tu64 off, u64 data)\n{\n\tint j, ret;\n\tu32 temp, off_lo, off_hi, addr_hi, data_hi, data_lo;\n\tvoid __iomem *mem_crb;\n\n\t \n\tif (off & 7)\n\t\treturn -EIO;\n\n\t \n\tif (ADDR_IN_RANGE(off, NETXEN_ADDR_QDR_NET,\n\t\t\t\tNETXEN_ADDR_QDR_NET_MAX_P2)) {\n\t\tmem_crb = pci_base_offset(adapter,\n\t\t\t\tNETXEN_CRB_QDR_NET+SIU_TEST_AGT_BASE);\n\t\taddr_hi = SIU_TEST_AGT_ADDR_HI;\n\t\tdata_lo = SIU_TEST_AGT_WRDATA_LO;\n\t\tdata_hi = SIU_TEST_AGT_WRDATA_HI;\n\t\toff_lo = off & SIU_TEST_AGT_ADDR_MASK;\n\t\toff_hi = SIU_TEST_AGT_UPPER_ADDR(off);\n\t\tgoto correct;\n\t}\n\n\tif (ADDR_IN_RANGE(off, NETXEN_ADDR_DDR_NET, NETXEN_ADDR_DDR_NET_MAX)) {\n\t\tmem_crb = pci_base_offset(adapter,\n\t\t\t\tNETXEN_CRB_DDR_NET+MIU_TEST_AGT_BASE);\n\t\taddr_hi = MIU_TEST_AGT_ADDR_HI;\n\t\tdata_lo = MIU_TEST_AGT_WRDATA_LO;\n\t\tdata_hi = MIU_TEST_AGT_WRDATA_HI;\n\t\toff_lo = off & MIU_TEST_AGT_ADDR_MASK;\n\t\toff_hi = 0;\n\t\tgoto correct;\n\t}\n\n\tif (ADDR_IN_RANGE(off, NETXEN_ADDR_OCM0, NETXEN_ADDR_OCM0_MAX) ||\n\t\tADDR_IN_RANGE(off, NETXEN_ADDR_OCM1, NETXEN_ADDR_OCM1_MAX)) {\n\t\tif (adapter->ahw.pci_len0 != 0) {\n\t\t\treturn netxen_nic_pci_mem_access_direct(adapter,\n\t\t\t\t\toff, &data, 1);\n\t\t}\n\t}\n\n\treturn -EIO;\n\ncorrect:\n\tspin_lock(&adapter->ahw.mem_lock);\n\tnetxen_nic_pci_set_crbwindow_128M(adapter, 0);\n\n\twritel(off_lo, (mem_crb + MIU_TEST_AGT_ADDR_LO));\n\twritel(off_hi, (mem_crb + addr_hi));\n\twritel(data & 0xffffffff, (mem_crb + data_lo));\n\twritel((data >> 32) & 0xffffffff, (mem_crb + data_hi));\n\twritel((TA_CTL_ENABLE | TA_CTL_WRITE), (mem_crb + TEST_AGT_CTRL));\n\twritel((TA_CTL_START | TA_CTL_ENABLE | TA_CTL_WRITE),\n\t\t\t(mem_crb + TEST_AGT_CTRL));\n\n\tfor (j = 0; j < MAX_CTL_CHECK; j++) {\n\t\ttemp = readl((mem_crb + TEST_AGT_CTRL));\n\t\tif ((temp & TA_CTL_BUSY) == 0)\n\t\t\tbreak;\n\t}\n\n\tif (j >= MAX_CTL_CHECK) {\n\t\tif (printk_ratelimit())\n\t\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\t\t\"failed to write through agent\\n\");\n\t\tret = -EIO;\n\t} else\n\t\tret = 0;\n\n\tnetxen_nic_pci_set_crbwindow_128M(adapter, NETXEN_WINDOW_ONE);\n\tspin_unlock(&adapter->ahw.mem_lock);\n\treturn ret;\n}\n\nstatic int\nnetxen_nic_pci_mem_read_128M(struct netxen_adapter *adapter,\n\t\tu64 off, u64 *data)\n{\n\tint j, ret;\n\tu32 temp, off_lo, off_hi, addr_hi, data_hi, data_lo;\n\tu64 val;\n\tvoid __iomem *mem_crb;\n\n\t \n\tif (off & 7)\n\t\treturn -EIO;\n\n\t \n\tif (ADDR_IN_RANGE(off, NETXEN_ADDR_QDR_NET,\n\t\t\t\tNETXEN_ADDR_QDR_NET_MAX_P2)) {\n\t\tmem_crb = pci_base_offset(adapter,\n\t\t\t\tNETXEN_CRB_QDR_NET+SIU_TEST_AGT_BASE);\n\t\taddr_hi = SIU_TEST_AGT_ADDR_HI;\n\t\tdata_lo = SIU_TEST_AGT_RDDATA_LO;\n\t\tdata_hi = SIU_TEST_AGT_RDDATA_HI;\n\t\toff_lo = off & SIU_TEST_AGT_ADDR_MASK;\n\t\toff_hi = SIU_TEST_AGT_UPPER_ADDR(off);\n\t\tgoto correct;\n\t}\n\n\tif (ADDR_IN_RANGE(off, NETXEN_ADDR_DDR_NET, NETXEN_ADDR_DDR_NET_MAX)) {\n\t\tmem_crb = pci_base_offset(adapter,\n\t\t\t\tNETXEN_CRB_DDR_NET+MIU_TEST_AGT_BASE);\n\t\taddr_hi = MIU_TEST_AGT_ADDR_HI;\n\t\tdata_lo = MIU_TEST_AGT_RDDATA_LO;\n\t\tdata_hi = MIU_TEST_AGT_RDDATA_HI;\n\t\toff_lo = off & MIU_TEST_AGT_ADDR_MASK;\n\t\toff_hi = 0;\n\t\tgoto correct;\n\t}\n\n\tif (ADDR_IN_RANGE(off, NETXEN_ADDR_OCM0, NETXEN_ADDR_OCM0_MAX) ||\n\t\tADDR_IN_RANGE(off, NETXEN_ADDR_OCM1, NETXEN_ADDR_OCM1_MAX)) {\n\t\tif (adapter->ahw.pci_len0 != 0) {\n\t\t\treturn netxen_nic_pci_mem_access_direct(adapter,\n\t\t\t\t\toff, data, 0);\n\t\t}\n\t}\n\n\treturn -EIO;\n\ncorrect:\n\tspin_lock(&adapter->ahw.mem_lock);\n\tnetxen_nic_pci_set_crbwindow_128M(adapter, 0);\n\n\twritel(off_lo, (mem_crb + MIU_TEST_AGT_ADDR_LO));\n\twritel(off_hi, (mem_crb + addr_hi));\n\twritel(TA_CTL_ENABLE, (mem_crb + TEST_AGT_CTRL));\n\twritel((TA_CTL_START|TA_CTL_ENABLE), (mem_crb + TEST_AGT_CTRL));\n\n\tfor (j = 0; j < MAX_CTL_CHECK; j++) {\n\t\ttemp = readl(mem_crb + TEST_AGT_CTRL);\n\t\tif ((temp & TA_CTL_BUSY) == 0)\n\t\t\tbreak;\n\t}\n\n\tif (j >= MAX_CTL_CHECK) {\n\t\tif (printk_ratelimit())\n\t\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\t\t\"failed to read through agent\\n\");\n\t\tret = -EIO;\n\t} else {\n\n\t\ttemp = readl(mem_crb + data_hi);\n\t\tval = ((u64)temp << 32);\n\t\tval |= readl(mem_crb + data_lo);\n\t\t*data = val;\n\t\tret = 0;\n\t}\n\n\tnetxen_nic_pci_set_crbwindow_128M(adapter, NETXEN_WINDOW_ONE);\n\tspin_unlock(&adapter->ahw.mem_lock);\n\n\treturn ret;\n}\n\nstatic int\nnetxen_nic_pci_mem_write_2M(struct netxen_adapter *adapter,\n\t\tu64 off, u64 data)\n{\n\tint j, ret;\n\tu32 temp, off8;\n\tvoid __iomem *mem_crb;\n\n\t \n\tif (off & 7)\n\t\treturn -EIO;\n\n\t \n\tif (ADDR_IN_RANGE(off, NETXEN_ADDR_QDR_NET,\n\t\t\t\tNETXEN_ADDR_QDR_NET_MAX_P3)) {\n\t\tmem_crb = netxen_get_ioaddr(adapter,\n\t\t\t\tNETXEN_CRB_QDR_NET+MIU_TEST_AGT_BASE);\n\t\tgoto correct;\n\t}\n\n\tif (ADDR_IN_RANGE(off, NETXEN_ADDR_DDR_NET, NETXEN_ADDR_DDR_NET_MAX)) {\n\t\tmem_crb = netxen_get_ioaddr(adapter,\n\t\t\t\tNETXEN_CRB_DDR_NET+MIU_TEST_AGT_BASE);\n\t\tgoto correct;\n\t}\n\n\tif (ADDR_IN_RANGE(off, NETXEN_ADDR_OCM0, NETXEN_ADDR_OCM0_MAX))\n\t\treturn netxen_nic_pci_mem_access_direct(adapter, off, &data, 1);\n\n\treturn -EIO;\n\ncorrect:\n\toff8 = off & 0xfffffff8;\n\n\tspin_lock(&adapter->ahw.mem_lock);\n\n\twritel(off8, (mem_crb + MIU_TEST_AGT_ADDR_LO));\n\twritel(0, (mem_crb + MIU_TEST_AGT_ADDR_HI));\n\n\twritel(data & 0xffffffff,\n\t\t\tmem_crb + MIU_TEST_AGT_WRDATA_LO);\n\twritel((data >> 32) & 0xffffffff,\n\t\t\tmem_crb + MIU_TEST_AGT_WRDATA_HI);\n\n\twritel((TA_CTL_ENABLE | TA_CTL_WRITE), (mem_crb + TEST_AGT_CTRL));\n\twritel((TA_CTL_START | TA_CTL_ENABLE | TA_CTL_WRITE),\n\t\t\t(mem_crb + TEST_AGT_CTRL));\n\n\tfor (j = 0; j < MAX_CTL_CHECK; j++) {\n\t\ttemp = readl(mem_crb + TEST_AGT_CTRL);\n\t\tif ((temp & TA_CTL_BUSY) == 0)\n\t\t\tbreak;\n\t}\n\n\tif (j >= MAX_CTL_CHECK) {\n\t\tif (printk_ratelimit())\n\t\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\t\t\"failed to write through agent\\n\");\n\t\tret = -EIO;\n\t} else\n\t\tret = 0;\n\n\tspin_unlock(&adapter->ahw.mem_lock);\n\n\treturn ret;\n}\n\nstatic int\nnetxen_nic_pci_mem_read_2M(struct netxen_adapter *adapter,\n\t\tu64 off, u64 *data)\n{\n\tint j, ret;\n\tu32 temp, off8;\n\tu64 val;\n\tvoid __iomem *mem_crb;\n\n\t \n\tif (off & 7)\n\t\treturn -EIO;\n\n\t \n\tif (ADDR_IN_RANGE(off, NETXEN_ADDR_QDR_NET,\n\t\t\t\tNETXEN_ADDR_QDR_NET_MAX_P3)) {\n\t\tmem_crb = netxen_get_ioaddr(adapter,\n\t\t\t\tNETXEN_CRB_QDR_NET+MIU_TEST_AGT_BASE);\n\t\tgoto correct;\n\t}\n\n\tif (ADDR_IN_RANGE(off, NETXEN_ADDR_DDR_NET, NETXEN_ADDR_DDR_NET_MAX)) {\n\t\tmem_crb = netxen_get_ioaddr(adapter,\n\t\t\t\tNETXEN_CRB_DDR_NET+MIU_TEST_AGT_BASE);\n\t\tgoto correct;\n\t}\n\n\tif (ADDR_IN_RANGE(off, NETXEN_ADDR_OCM0, NETXEN_ADDR_OCM0_MAX)) {\n\t\treturn netxen_nic_pci_mem_access_direct(adapter,\n\t\t\t\toff, data, 0);\n\t}\n\n\treturn -EIO;\n\ncorrect:\n\toff8 = off & 0xfffffff8;\n\n\tspin_lock(&adapter->ahw.mem_lock);\n\n\twritel(off8, (mem_crb + MIU_TEST_AGT_ADDR_LO));\n\twritel(0, (mem_crb + MIU_TEST_AGT_ADDR_HI));\n\twritel(TA_CTL_ENABLE, (mem_crb + TEST_AGT_CTRL));\n\twritel((TA_CTL_START | TA_CTL_ENABLE), (mem_crb + TEST_AGT_CTRL));\n\n\tfor (j = 0; j < MAX_CTL_CHECK; j++) {\n\t\ttemp = readl(mem_crb + TEST_AGT_CTRL);\n\t\tif ((temp & TA_CTL_BUSY) == 0)\n\t\t\tbreak;\n\t}\n\n\tif (j >= MAX_CTL_CHECK) {\n\t\tif (printk_ratelimit())\n\t\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\t\t\"failed to read through agent\\n\");\n\t\tret = -EIO;\n\t} else {\n\t\tval = (u64)(readl(mem_crb + MIU_TEST_AGT_RDDATA_HI)) << 32;\n\t\tval |= readl(mem_crb + MIU_TEST_AGT_RDDATA_LO);\n\t\t*data = val;\n\t\tret = 0;\n\t}\n\n\tspin_unlock(&adapter->ahw.mem_lock);\n\n\treturn ret;\n}\n\nvoid\nnetxen_setup_hwops(struct netxen_adapter *adapter)\n{\n\tadapter->init_port = netxen_niu_xg_init_port;\n\tadapter->stop_port = netxen_niu_disable_xg_port;\n\n\tif (NX_IS_REVISION_P2(adapter->ahw.revision_id)) {\n\t\tadapter->crb_read = netxen_nic_hw_read_wx_128M,\n\t\tadapter->crb_write = netxen_nic_hw_write_wx_128M,\n\t\tadapter->pci_set_window = netxen_nic_pci_set_window_128M,\n\t\tadapter->pci_mem_read = netxen_nic_pci_mem_read_128M,\n\t\tadapter->pci_mem_write = netxen_nic_pci_mem_write_128M,\n\t\tadapter->io_read = netxen_nic_io_read_128M,\n\t\tadapter->io_write = netxen_nic_io_write_128M,\n\n\t\tadapter->macaddr_set = netxen_p2_nic_set_mac_addr;\n\t\tadapter->set_multi = netxen_p2_nic_set_multi;\n\t\tadapter->set_mtu = netxen_nic_set_mtu_xgb;\n\t\tadapter->set_promisc = netxen_p2_nic_set_promisc;\n\n\t} else {\n\t\tadapter->crb_read = netxen_nic_hw_read_wx_2M,\n\t\tadapter->crb_write = netxen_nic_hw_write_wx_2M,\n\t\tadapter->pci_set_window = netxen_nic_pci_set_window_2M,\n\t\tadapter->pci_mem_read = netxen_nic_pci_mem_read_2M,\n\t\tadapter->pci_mem_write = netxen_nic_pci_mem_write_2M,\n\t\tadapter->io_read = netxen_nic_io_read_2M,\n\t\tadapter->io_write = netxen_nic_io_write_2M,\n\n\t\tadapter->set_mtu = nx_fw_cmd_set_mtu;\n\t\tadapter->set_promisc = netxen_p3_nic_set_promisc;\n\t\tadapter->macaddr_set = netxen_p3_nic_set_mac_addr;\n\t\tadapter->set_multi = netxen_p3_nic_set_multi;\n\n\t\tadapter->phy_read = nx_fw_cmd_query_phy;\n\t\tadapter->phy_write = nx_fw_cmd_set_phy;\n\t}\n}\n\nint netxen_nic_get_board_info(struct netxen_adapter *adapter)\n{\n\tint offset, board_type, magic;\n\tstruct pci_dev *pdev = adapter->pdev;\n\n\toffset = NX_FW_MAGIC_OFFSET;\n\tif (netxen_rom_fast_read(adapter, offset, &magic))\n\t\treturn -EIO;\n\n\tif (magic != NETXEN_BDINFO_MAGIC) {\n\t\tdev_err(&pdev->dev, \"invalid board config, magic=%08x\\n\",\n\t\t\tmagic);\n\t\treturn -EIO;\n\t}\n\n\toffset = NX_BRDTYPE_OFFSET;\n\tif (netxen_rom_fast_read(adapter, offset, &board_type))\n\t\treturn -EIO;\n\n\tif (board_type == NETXEN_BRDTYPE_P3_4_GB_MM) {\n\t\tu32 gpio = NXRD32(adapter, NETXEN_ROMUSB_GLB_PAD_GPIO_I);\n\t\tif ((gpio & 0x8000) == 0)\n\t\t\tboard_type = NETXEN_BRDTYPE_P3_10G_TP;\n\t}\n\n\tadapter->ahw.board_type = board_type;\n\n\tswitch (board_type) {\n\tcase NETXEN_BRDTYPE_P2_SB35_4G:\n\t\tadapter->ahw.port_type = NETXEN_NIC_GBE;\n\t\tbreak;\n\tcase NETXEN_BRDTYPE_P2_SB31_10G:\n\tcase NETXEN_BRDTYPE_P2_SB31_10G_IMEZ:\n\tcase NETXEN_BRDTYPE_P2_SB31_10G_HMEZ:\n\tcase NETXEN_BRDTYPE_P2_SB31_10G_CX4:\n\tcase NETXEN_BRDTYPE_P3_HMEZ:\n\tcase NETXEN_BRDTYPE_P3_XG_LOM:\n\tcase NETXEN_BRDTYPE_P3_10G_CX4:\n\tcase NETXEN_BRDTYPE_P3_10G_CX4_LP:\n\tcase NETXEN_BRDTYPE_P3_IMEZ:\n\tcase NETXEN_BRDTYPE_P3_10G_SFP_PLUS:\n\tcase NETXEN_BRDTYPE_P3_10G_SFP_CT:\n\tcase NETXEN_BRDTYPE_P3_10G_SFP_QT:\n\tcase NETXEN_BRDTYPE_P3_10G_XFP:\n\tcase NETXEN_BRDTYPE_P3_10000_BASE_T:\n\t\tadapter->ahw.port_type = NETXEN_NIC_XGBE;\n\t\tbreak;\n\tcase NETXEN_BRDTYPE_P1_BD:\n\tcase NETXEN_BRDTYPE_P1_SB:\n\tcase NETXEN_BRDTYPE_P1_SMAX:\n\tcase NETXEN_BRDTYPE_P1_SOCK:\n\tcase NETXEN_BRDTYPE_P3_REF_QG:\n\tcase NETXEN_BRDTYPE_P3_4_GB:\n\tcase NETXEN_BRDTYPE_P3_4_GB_MM:\n\t\tadapter->ahw.port_type = NETXEN_NIC_GBE;\n\t\tbreak;\n\tcase NETXEN_BRDTYPE_P3_10G_TP:\n\t\tadapter->ahw.port_type = (adapter->portnum < 2) ?\n\t\t\tNETXEN_NIC_XGBE : NETXEN_NIC_GBE;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&pdev->dev, \"unknown board type %x\\n\", board_type);\n\t\tadapter->ahw.port_type = NETXEN_NIC_XGBE;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int netxen_nic_set_mtu_xgb(struct netxen_adapter *adapter, int new_mtu)\n{\n\tnew_mtu += MTU_FUDGE_FACTOR;\n\tif (adapter->physical_port == 0)\n\t\tNXWR32(adapter, NETXEN_NIU_XGE_MAX_FRAME_SIZE, new_mtu);\n\telse\n\t\tNXWR32(adapter, NETXEN_NIU_XG1_MAX_FRAME_SIZE, new_mtu);\n\treturn 0;\n}\n\nvoid netxen_nic_set_link_parameters(struct netxen_adapter *adapter)\n{\n\t__u32 status;\n\t__u32 autoneg;\n\t__u32 port_mode;\n\n\tif (!netif_carrier_ok(adapter->netdev)) {\n\t\tadapter->link_speed   = 0;\n\t\tadapter->link_duplex  = -1;\n\t\tadapter->link_autoneg = AUTONEG_ENABLE;\n\t\treturn;\n\t}\n\n\tif (adapter->ahw.port_type == NETXEN_NIC_GBE) {\n\t\tport_mode = NXRD32(adapter, NETXEN_PORT_MODE_ADDR);\n\t\tif (port_mode == NETXEN_PORT_MODE_802_3_AP) {\n\t\t\tadapter->link_speed   = SPEED_1000;\n\t\t\tadapter->link_duplex  = DUPLEX_FULL;\n\t\t\tadapter->link_autoneg = AUTONEG_DISABLE;\n\t\t\treturn;\n\t\t}\n\n\t\tif (adapter->phy_read &&\n\t\t    adapter->phy_read(adapter,\n\t\t\t\t      NETXEN_NIU_GB_MII_MGMT_ADDR_PHY_STATUS,\n\t\t\t\t      &status) == 0) {\n\t\t\tif (netxen_get_phy_link(status)) {\n\t\t\t\tswitch (netxen_get_phy_speed(status)) {\n\t\t\t\tcase 0:\n\t\t\t\t\tadapter->link_speed = SPEED_10;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tadapter->link_speed = SPEED_100;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tadapter->link_speed = SPEED_1000;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tadapter->link_speed = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tswitch (netxen_get_phy_duplex(status)) {\n\t\t\t\tcase 0:\n\t\t\t\t\tadapter->link_duplex = DUPLEX_HALF;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tadapter->link_duplex = DUPLEX_FULL;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tadapter->link_duplex = -1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (adapter->phy_read &&\n\t\t\t\t    adapter->phy_read(adapter,\n\t\t\t\t\t\t      NETXEN_NIU_GB_MII_MGMT_ADDR_AUTONEG,\n\t\t\t\t\t\t      &autoneg) == 0)\n\t\t\t\t\tadapter->link_autoneg = autoneg;\n\t\t\t} else\n\t\t\t\tgoto link_down;\n\t\t} else {\n\t\t      link_down:\n\t\t\tadapter->link_speed = 0;\n\t\t\tadapter->link_duplex = -1;\n\t\t}\n\t}\n}\n\nint\nnetxen_nic_wol_supported(struct netxen_adapter *adapter)\n{\n\tu32 wol_cfg;\n\n\tif (NX_IS_REVISION_P2(adapter->ahw.revision_id))\n\t\treturn 0;\n\n\twol_cfg = NXRD32(adapter, NETXEN_WOL_CONFIG_NV);\n\tif (wol_cfg & (1UL << adapter->portnum)) {\n\t\twol_cfg = NXRD32(adapter, NETXEN_WOL_CONFIG);\n\t\tif (wol_cfg & (1 << adapter->portnum))\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic u32 netxen_md_cntrl(struct netxen_adapter *adapter,\n\t\t\tstruct netxen_minidump_template_hdr *template_hdr,\n\t\t\tstruct netxen_minidump_entry_crb *crtEntry)\n{\n\tint loop_cnt, i, rv = 0, timeout_flag;\n\tu32 op_count, stride;\n\tu32 opcode, read_value, addr;\n\tunsigned long timeout, timeout_jiffies;\n\taddr = crtEntry->addr;\n\top_count = crtEntry->op_count;\n\tstride = crtEntry->addr_stride;\n\n\tfor (loop_cnt = 0; loop_cnt < op_count; loop_cnt++) {\n\t\tfor (i = 0; i < sizeof(crtEntry->opcode) * 8; i++) {\n\t\t\topcode = (crtEntry->opcode & (0x1 << i));\n\t\t\tif (opcode) {\n\t\t\t\tswitch (opcode) {\n\t\t\t\tcase NX_DUMP_WCRB:\n\t\t\t\t\tNX_WR_DUMP_REG(addr,\n\t\t\t\t\t\tadapter->ahw.pci_base0,\n\t\t\t\t\t\t\tcrtEntry->value_1);\n\t\t\t\t\tbreak;\n\t\t\t\tcase NX_DUMP_RWCRB:\n\t\t\t\t\tNX_RD_DUMP_REG(addr,\n\t\t\t\t\t\tadapter->ahw.pci_base0,\n\t\t\t\t\t\t\t\t&read_value);\n\t\t\t\t\tNX_WR_DUMP_REG(addr,\n\t\t\t\t\t\tadapter->ahw.pci_base0,\n\t\t\t\t\t\t\t\tread_value);\n\t\t\t\t\tbreak;\n\t\t\t\tcase NX_DUMP_ANDCRB:\n\t\t\t\t\tNX_RD_DUMP_REG(addr,\n\t\t\t\t\t\tadapter->ahw.pci_base0,\n\t\t\t\t\t\t\t\t&read_value);\n\t\t\t\t\tread_value &= crtEntry->value_2;\n\t\t\t\t\tNX_WR_DUMP_REG(addr,\n\t\t\t\t\t\tadapter->ahw.pci_base0,\n\t\t\t\t\t\t\t\tread_value);\n\t\t\t\t\tbreak;\n\t\t\t\tcase NX_DUMP_ORCRB:\n\t\t\t\t\tNX_RD_DUMP_REG(addr,\n\t\t\t\t\t\tadapter->ahw.pci_base0,\n\t\t\t\t\t\t\t\t&read_value);\n\t\t\t\t\tread_value |= crtEntry->value_3;\n\t\t\t\t\tNX_WR_DUMP_REG(addr,\n\t\t\t\t\t\tadapter->ahw.pci_base0,\n\t\t\t\t\t\t\t\tread_value);\n\t\t\t\t\tbreak;\n\t\t\t\tcase NX_DUMP_POLLCRB:\n\t\t\t\t\ttimeout = crtEntry->poll_timeout;\n\t\t\t\t\tNX_RD_DUMP_REG(addr,\n\t\t\t\t\t\tadapter->ahw.pci_base0,\n\t\t\t\t\t\t\t\t&read_value);\n\t\t\t\t\ttimeout_jiffies =\n\t\t\t\t\tmsecs_to_jiffies(timeout) + jiffies;\n\t\t\t\t\tfor (timeout_flag = 0;\n\t\t\t\t\t\t!timeout_flag\n\t\t\t\t\t&& ((read_value & crtEntry->value_2)\n\t\t\t\t\t!= crtEntry->value_1);) {\n\t\t\t\t\t\tif (time_after(jiffies,\n\t\t\t\t\t\t\ttimeout_jiffies))\n\t\t\t\t\t\t\ttimeout_flag = 1;\n\t\t\t\t\tNX_RD_DUMP_REG(addr,\n\t\t\t\t\t\t\tadapter->ahw.pci_base0,\n\t\t\t\t\t\t\t\t&read_value);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (timeout_flag) {\n\t\t\t\t\t\tdev_err(&adapter->pdev->dev, \"%s : \"\n\t\t\t\t\t\t\t\"Timeout in poll_crb control operation.\\n\"\n\t\t\t\t\t\t\t\t, __func__);\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase NX_DUMP_RD_SAVE:\n\t\t\t\t\t \n\t\t\t\t\tif (crtEntry->state_index_a)\n\t\t\t\t\t\taddr =\n\t\t\t\t\t\ttemplate_hdr->saved_state_array\n\t\t\t\t\t\t[crtEntry->state_index_a];\n\t\t\t\t\tNX_RD_DUMP_REG(addr,\n\t\t\t\t\t\tadapter->ahw.pci_base0,\n\t\t\t\t\t\t\t\t&read_value);\n\t\t\t\t\ttemplate_hdr->saved_state_array\n\t\t\t\t\t[crtEntry->state_index_v]\n\t\t\t\t\t\t= read_value;\n\t\t\t\t\tbreak;\n\t\t\t\tcase NX_DUMP_WRT_SAVED:\n\t\t\t\t\t \n\t\t\t\t\tif (crtEntry->state_index_v)\n\t\t\t\t\t\tread_value =\n\t\t\t\t\t\ttemplate_hdr->saved_state_array\n\t\t\t\t\t\t[crtEntry->state_index_v];\n\t\t\t\t\telse\n\t\t\t\t\t\tread_value = crtEntry->value_1;\n\n\t\t\t\t\t \n\t\t\t\t\tif (crtEntry->state_index_a)\n\t\t\t\t\t\taddr =\n\t\t\t\t\t\ttemplate_hdr->saved_state_array\n\t\t\t\t\t\t[crtEntry->state_index_a];\n\n\t\t\t\t\tNX_WR_DUMP_REG(addr,\n\t\t\t\t\t\tadapter->ahw.pci_base0,\n\t\t\t\t\t\t\t\tread_value);\n\t\t\t\t\tbreak;\n\t\t\t\tcase NX_DUMP_MOD_SAVE_ST:\n\t\t\t\t\tread_value =\n\t\t\t\t\ttemplate_hdr->saved_state_array\n\t\t\t\t\t\t[crtEntry->state_index_v];\n\t\t\t\t\tread_value <<= crtEntry->shl;\n\t\t\t\t\tread_value >>= crtEntry->shr;\n\t\t\t\t\tif (crtEntry->value_2)\n\t\t\t\t\t\tread_value &=\n\t\t\t\t\t\tcrtEntry->value_2;\n\t\t\t\t\tread_value |= crtEntry->value_3;\n\t\t\t\t\tread_value += crtEntry->value_1;\n\t\t\t\t\t \n\t\t\t\t\ttemplate_hdr->saved_state_array\n\t\t\t\t\t\t[crtEntry->state_index_v]\n\t\t\t\t\t\t\t= read_value;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\trv = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\taddr = addr + stride;\n\t}\n\treturn rv;\n}\n\n \nstatic u32\nnetxen_md_rdmem(struct netxen_adapter *adapter,\n\t\tstruct netxen_minidump_entry_rdmem\n\t\t\t*memEntry, u64 *data_buff)\n{\n\tu64 addr, value = 0;\n\tint i = 0, loop_cnt;\n\n\taddr = (u64)memEntry->read_addr;\n\tloop_cnt = memEntry->read_data_size;     \n\tloop_cnt /= sizeof(value);\n\n\tfor (i = 0; i < loop_cnt; i++) {\n\t\tif (netxen_nic_pci_mem_read_2M(adapter, addr, &value))\n\t\t\tgoto out;\n\t\t*data_buff++ = value;\n\t\taddr += sizeof(value);\n\t}\nout:\n\treturn i * sizeof(value);\n}\n\n \nstatic u32 netxen_md_rd_crb(struct netxen_adapter *adapter,\n\t\t\tstruct netxen_minidump_entry_crb\n\t\t\t\t*crbEntry, u32 *data_buff)\n{\n\tint loop_cnt;\n\tu32 op_count, addr, stride, value;\n\n\taddr = crbEntry->addr;\n\top_count = crbEntry->op_count;\n\tstride = crbEntry->addr_stride;\n\n\tfor (loop_cnt = 0; loop_cnt < op_count; loop_cnt++) {\n\t\tNX_RD_DUMP_REG(addr, adapter->ahw.pci_base0, &value);\n\t\t*data_buff++ = addr;\n\t\t*data_buff++ = value;\n\t\taddr = addr + stride;\n\t}\n\treturn loop_cnt * (2 * sizeof(u32));\n}\n\n \nstatic u32\nnetxen_md_rdrom(struct netxen_adapter *adapter,\n\t\t\tstruct netxen_minidump_entry_rdrom\n\t\t\t\t*romEntry, __le32 *data_buff)\n{\n\tint i, count = 0;\n\tu32 size, lck_val;\n\tu32 val;\n\tu32 fl_addr, waddr, raddr;\n\tfl_addr = romEntry->read_addr;\n\tsize = romEntry->read_data_size/4;\nlock_try:\n\tlck_val = readl((void __iomem *)(adapter->ahw.pci_base0 +\n\t\t\t\t\t\t\tNX_FLASH_SEM2_LK));\n\tif (!lck_val && count < MAX_CTL_CHECK) {\n\t\tmsleep(20);\n\t\tcount++;\n\t\tgoto lock_try;\n\t}\n\twritel(adapter->ahw.pci_func, (void __iomem *)(adapter->ahw.pci_base0 +\n\t\t\t\t\t\t\tNX_FLASH_LOCK_ID));\n\tfor (i = 0; i < size; i++) {\n\t\twaddr = fl_addr & 0xFFFF0000;\n\t\tNX_WR_DUMP_REG(FLASH_ROM_WINDOW, adapter->ahw.pci_base0, waddr);\n\t\traddr = FLASH_ROM_DATA + (fl_addr & 0x0000FFFF);\n\t\tNX_RD_DUMP_REG(raddr, adapter->ahw.pci_base0, &val);\n\t\t*data_buff++ = cpu_to_le32(val);\n\t\tfl_addr += sizeof(val);\n\t}\n\treadl((void __iomem *)(adapter->ahw.pci_base0 + NX_FLASH_SEM2_ULK));\n\treturn romEntry->read_data_size;\n}\n\n \nstatic u32\nnetxen_md_L2Cache(struct netxen_adapter *adapter,\n\t\t\t\tstruct netxen_minidump_entry_cache\n\t\t\t\t\t*cacheEntry, u32 *data_buff)\n{\n\tint loop_cnt, i, k, timeout_flag = 0;\n\tu32 addr, read_addr, read_value, cntrl_addr, tag_reg_addr;\n\tu32 tag_value, read_cnt;\n\tu8 cntl_value_w, cntl_value_r;\n\tunsigned long timeout, timeout_jiffies;\n\n\tloop_cnt = cacheEntry->op_count;\n\tread_addr = cacheEntry->read_addr;\n\tcntrl_addr = cacheEntry->control_addr;\n\tcntl_value_w = (u32) cacheEntry->write_value;\n\ttag_reg_addr = cacheEntry->tag_reg_addr;\n\ttag_value = cacheEntry->init_tag_value;\n\tread_cnt = cacheEntry->read_addr_cnt;\n\n\tfor (i = 0; i < loop_cnt; i++) {\n\t\tNX_WR_DUMP_REG(tag_reg_addr, adapter->ahw.pci_base0, tag_value);\n\t\tif (cntl_value_w)\n\t\t\tNX_WR_DUMP_REG(cntrl_addr, adapter->ahw.pci_base0,\n\t\t\t\t\t(u32)cntl_value_w);\n\t\tif (cacheEntry->poll_mask) {\n\t\t\ttimeout = cacheEntry->poll_wait;\n\t\t\tNX_RD_DUMP_REG(cntrl_addr, adapter->ahw.pci_base0,\n\t\t\t\t\t\t\t&cntl_value_r);\n\t\t\ttimeout_jiffies = msecs_to_jiffies(timeout) + jiffies;\n\t\t\tfor (timeout_flag = 0; !timeout_flag &&\n\t\t\t((cntl_value_r & cacheEntry->poll_mask) != 0);) {\n\t\t\t\tif (time_after(jiffies, timeout_jiffies))\n\t\t\t\t\ttimeout_flag = 1;\n\t\t\t\tNX_RD_DUMP_REG(cntrl_addr,\n\t\t\t\t\tadapter->ahw.pci_base0,\n\t\t\t\t\t\t\t&cntl_value_r);\n\t\t\t}\n\t\t\tif (timeout_flag) {\n\t\t\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\t\t\t\"Timeout in processing L2 Tag poll.\\n\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\taddr = read_addr;\n\t\tfor (k = 0; k < read_cnt; k++) {\n\t\t\tNX_RD_DUMP_REG(addr, adapter->ahw.pci_base0,\n\t\t\t\t\t&read_value);\n\t\t\t*data_buff++ = read_value;\n\t\t\taddr += cacheEntry->read_addr_stride;\n\t\t}\n\t\ttag_value += cacheEntry->tag_value_stride;\n\t}\n\treturn read_cnt * loop_cnt * sizeof(read_value);\n}\n\n\n \nstatic u32 netxen_md_L1Cache(struct netxen_adapter *adapter,\n\t\t\t\tstruct netxen_minidump_entry_cache\n\t\t\t\t\t*cacheEntry, u32 *data_buff)\n{\n\tint i, k, loop_cnt;\n\tu32 addr, read_addr, read_value, cntrl_addr, tag_reg_addr;\n\tu32 tag_value, read_cnt;\n\tu8 cntl_value_w;\n\n\tloop_cnt = cacheEntry->op_count;\n\tread_addr = cacheEntry->read_addr;\n\tcntrl_addr = cacheEntry->control_addr;\n\tcntl_value_w = (u32) cacheEntry->write_value;\n\ttag_reg_addr = cacheEntry->tag_reg_addr;\n\ttag_value = cacheEntry->init_tag_value;\n\tread_cnt = cacheEntry->read_addr_cnt;\n\n\tfor (i = 0; i < loop_cnt; i++) {\n\t\tNX_WR_DUMP_REG(tag_reg_addr, adapter->ahw.pci_base0, tag_value);\n\t\tNX_WR_DUMP_REG(cntrl_addr, adapter->ahw.pci_base0,\n\t\t\t\t\t\t(u32) cntl_value_w);\n\t\taddr = read_addr;\n\t\tfor (k = 0; k < read_cnt; k++) {\n\t\t\tNX_RD_DUMP_REG(addr,\n\t\t\t\tadapter->ahw.pci_base0,\n\t\t\t\t\t\t&read_value);\n\t\t\t*data_buff++ = read_value;\n\t\t\taddr += cacheEntry->read_addr_stride;\n\t\t}\n\t\ttag_value += cacheEntry->tag_value_stride;\n\t}\n\treturn read_cnt * loop_cnt * sizeof(read_value);\n}\n\n \nstatic u32\nnetxen_md_rdocm(struct netxen_adapter *adapter,\n\t\t\t\tstruct netxen_minidump_entry_rdocm\n\t\t\t\t\t*ocmEntry, u32 *data_buff)\n{\n\tint i, loop_cnt;\n\tu32 value;\n\tvoid __iomem *addr;\n\taddr = (ocmEntry->read_addr + adapter->ahw.pci_base0);\n\tloop_cnt = ocmEntry->op_count;\n\n\tfor (i = 0; i < loop_cnt; i++) {\n\t\tvalue = readl(addr);\n\t\t*data_buff++ = value;\n\t\taddr += ocmEntry->read_addr_stride;\n\t}\n\treturn i * sizeof(u32);\n}\n\n \nstatic u32\nnetxen_md_rdmux(struct netxen_adapter *adapter, struct netxen_minidump_entry_mux\n\t\t\t\t\t*muxEntry, u32 *data_buff)\n{\n\tint loop_cnt = 0;\n\tu32 read_addr, read_value, select_addr, sel_value;\n\n\tread_addr = muxEntry->read_addr;\n\tsel_value = muxEntry->select_value;\n\tselect_addr = muxEntry->select_addr;\n\n\tfor (loop_cnt = 0; loop_cnt < muxEntry->op_count; loop_cnt++) {\n\t\tNX_WR_DUMP_REG(select_addr, adapter->ahw.pci_base0, sel_value);\n\t\tNX_RD_DUMP_REG(read_addr, adapter->ahw.pci_base0, &read_value);\n\t\t*data_buff++ = sel_value;\n\t\t*data_buff++ = read_value;\n\t\tsel_value += muxEntry->select_value_stride;\n\t}\n\treturn loop_cnt * (2 * sizeof(u32));\n}\n\n \nstatic u32\nnetxen_md_rdqueue(struct netxen_adapter *adapter,\n\t\t\t\tstruct netxen_minidump_entry_queue\n\t\t\t\t\t*queueEntry, u32 *data_buff)\n{\n\tint loop_cnt, k;\n\tu32 queue_id, read_addr, read_value, read_stride, select_addr, read_cnt;\n\n\tread_cnt = queueEntry->read_addr_cnt;\n\tread_stride = queueEntry->read_addr_stride;\n\tselect_addr = queueEntry->select_addr;\n\n\tfor (loop_cnt = 0, queue_id = 0; loop_cnt < queueEntry->op_count;\n\t\t\t\t loop_cnt++) {\n\t\tNX_WR_DUMP_REG(select_addr, adapter->ahw.pci_base0, queue_id);\n\t\tread_addr = queueEntry->read_addr;\n\t\tfor (k = 0; k < read_cnt; k++) {\n\t\t\tNX_RD_DUMP_REG(read_addr, adapter->ahw.pci_base0,\n\t\t\t\t\t\t\t&read_value);\n\t\t\t*data_buff++ = read_value;\n\t\t\tread_addr += read_stride;\n\t\t}\n\t\tqueue_id += queueEntry->queue_id_stride;\n\t}\n\treturn loop_cnt * (read_cnt * sizeof(read_value));\n}\n\n\n \n\nstatic int netxen_md_entry_err_chk(struct netxen_adapter *adapter,\n\t\t\t\tstruct netxen_minidump_entry *entry, int esize)\n{\n\tif (esize < 0) {\n\t\tentry->hdr.driver_flags |= NX_DUMP_SKIP;\n\t\treturn esize;\n\t}\n\tif (esize != entry->hdr.entry_capture_size) {\n\t\tentry->hdr.entry_capture_size = esize;\n\t\tentry->hdr.driver_flags |= NX_DUMP_SIZE_ERR;\n\t\tdev_info(&adapter->pdev->dev,\n\t\t\t\"Invalidate dump, Type:%d\\tMask:%d\\tSize:%dCap_size:%d\\n\",\n\t\t\tentry->hdr.entry_type, entry->hdr.entry_capture_mask,\n\t\t\tesize, entry->hdr.entry_capture_size);\n\t\tdev_info(&adapter->pdev->dev, \"Aborting further dump capture\\n\");\n\t}\n\treturn 0;\n}\n\nstatic int netxen_parse_md_template(struct netxen_adapter *adapter)\n{\n\tint num_of_entries, buff_level, e_cnt, esize;\n\tint rv = 0, sane_start = 0, sane_end = 0;\n\tchar *dbuff;\n\tvoid *template_buff = adapter->mdump.md_template;\n\tchar *dump_buff = adapter->mdump.md_capture_buff;\n\tint capture_mask = adapter->mdump.md_capture_mask;\n\tstruct netxen_minidump_template_hdr *template_hdr;\n\tstruct netxen_minidump_entry *entry;\n\n\tif ((capture_mask & 0x3) != 0x3) {\n\t\tdev_err(&adapter->pdev->dev, \"Capture mask %02x below minimum needed \"\n\t\t\t\"for valid firmware dump\\n\", capture_mask);\n\t\treturn -EINVAL;\n\t}\n\ttemplate_hdr = (struct netxen_minidump_template_hdr *) template_buff;\n\tnum_of_entries = template_hdr->num_of_entries;\n\tentry = (struct netxen_minidump_entry *) ((char *) template_buff +\n\t\t\t\ttemplate_hdr->first_entry_offset);\n\tmemcpy(dump_buff, template_buff, adapter->mdump.md_template_size);\n\tdump_buff = dump_buff + adapter->mdump.md_template_size;\n\n\tif (template_hdr->entry_type == TLHDR)\n\t\tsane_start = 1;\n\n\tfor (e_cnt = 0, buff_level = 0; e_cnt < num_of_entries; e_cnt++) {\n\t\tif (!(entry->hdr.entry_capture_mask & capture_mask)) {\n\t\t\tentry->hdr.driver_flags |= NX_DUMP_SKIP;\n\t\t\tentry = (struct netxen_minidump_entry *)\n\t\t\t\t((char *) entry + entry->hdr.entry_size);\n\t\t\tcontinue;\n\t\t}\n\t\tswitch (entry->hdr.entry_type) {\n\t\tcase RDNOP:\n\t\t\tentry->hdr.driver_flags |= NX_DUMP_SKIP;\n\t\t\tbreak;\n\t\tcase RDEND:\n\t\t\tentry->hdr.driver_flags |= NX_DUMP_SKIP;\n\t\t\tsane_end += 1;\n\t\t\tbreak;\n\t\tcase CNTRL:\n\t\t\trv = netxen_md_cntrl(adapter,\n\t\t\t\ttemplate_hdr, (void *)entry);\n\t\t\tif (rv)\n\t\t\t\tentry->hdr.driver_flags |= NX_DUMP_SKIP;\n\t\t\tbreak;\n\t\tcase RDCRB:\n\t\t\tdbuff = dump_buff + buff_level;\n\t\t\tesize = netxen_md_rd_crb(adapter,\n\t\t\t\t\t(void *) entry, (void *) dbuff);\n\t\t\trv = netxen_md_entry_err_chk\n\t\t\t\t(adapter, entry, esize);\n\t\t\tif (rv < 0)\n\t\t\t\tbreak;\n\t\t\tbuff_level += esize;\n\t\t\tbreak;\n\t\tcase RDMN:\n\t\tcase RDMEM:\n\t\t\tdbuff = dump_buff + buff_level;\n\t\t\tesize = netxen_md_rdmem(adapter,\n\t\t\t\t(void *) entry, (void *) dbuff);\n\t\t\trv = netxen_md_entry_err_chk\n\t\t\t\t(adapter, entry, esize);\n\t\t\tif (rv < 0)\n\t\t\t\tbreak;\n\t\t\tbuff_level += esize;\n\t\t\tbreak;\n\t\tcase BOARD:\n\t\tcase RDROM:\n\t\t\tdbuff = dump_buff + buff_level;\n\t\t\tesize = netxen_md_rdrom(adapter,\n\t\t\t\t(void *) entry, (void *) dbuff);\n\t\t\trv = netxen_md_entry_err_chk\n\t\t\t\t(adapter, entry, esize);\n\t\t\tif (rv < 0)\n\t\t\t\tbreak;\n\t\t\tbuff_level += esize;\n\t\t\tbreak;\n\t\tcase L2ITG:\n\t\tcase L2DTG:\n\t\tcase L2DAT:\n\t\tcase L2INS:\n\t\t\tdbuff = dump_buff + buff_level;\n\t\t\tesize = netxen_md_L2Cache(adapter,\n\t\t\t\t(void *) entry, (void *) dbuff);\n\t\t\trv = netxen_md_entry_err_chk\n\t\t\t\t(adapter, entry, esize);\n\t\t\tif (rv < 0)\n\t\t\t\tbreak;\n\t\t\tbuff_level += esize;\n\t\t\tbreak;\n\t\tcase L1DAT:\n\t\tcase L1INS:\n\t\t\tdbuff = dump_buff + buff_level;\n\t\t\tesize = netxen_md_L1Cache(adapter,\n\t\t\t\t(void *) entry, (void *) dbuff);\n\t\t\trv = netxen_md_entry_err_chk\n\t\t\t\t(adapter, entry, esize);\n\t\t\tif (rv < 0)\n\t\t\t\tbreak;\n\t\t\tbuff_level += esize;\n\t\t\tbreak;\n\t\tcase RDOCM:\n\t\t\tdbuff = dump_buff + buff_level;\n\t\t\tesize = netxen_md_rdocm(adapter,\n\t\t\t\t(void *) entry, (void *) dbuff);\n\t\t\trv = netxen_md_entry_err_chk\n\t\t\t\t(adapter, entry, esize);\n\t\t\tif (rv < 0)\n\t\t\t\tbreak;\n\t\t\tbuff_level += esize;\n\t\t\tbreak;\n\t\tcase RDMUX:\n\t\t\tdbuff = dump_buff + buff_level;\n\t\t\tesize = netxen_md_rdmux(adapter,\n\t\t\t\t(void *) entry, (void *) dbuff);\n\t\t\trv = netxen_md_entry_err_chk\n\t\t\t\t(adapter, entry, esize);\n\t\t\tif (rv < 0)\n\t\t\t\tbreak;\n\t\t\tbuff_level += esize;\n\t\t\tbreak;\n\t\tcase QUEUE:\n\t\t\tdbuff = dump_buff + buff_level;\n\t\t\tesize = netxen_md_rdqueue(adapter,\n\t\t\t\t(void *) entry, (void *) dbuff);\n\t\t\trv = netxen_md_entry_err_chk\n\t\t\t\t(adapter, entry, esize);\n\t\t\tif (rv  < 0)\n\t\t\t\tbreak;\n\t\t\tbuff_level += esize;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tentry->hdr.driver_flags |= NX_DUMP_SKIP;\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tentry = (struct netxen_minidump_entry *)\n\t\t\t((char *) entry + entry->hdr.entry_size);\n\t}\n\tif (!sane_start || sane_end > 1) {\n\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\t\"Firmware minidump template configuration error.\\n\");\n\t}\n\treturn 0;\n}\n\nstatic int\nnetxen_collect_minidump(struct netxen_adapter *adapter)\n{\n\tint ret = 0;\n\tstruct netxen_minidump_template_hdr *hdr;\n\thdr = (struct netxen_minidump_template_hdr *)\n\t\t\t\tadapter->mdump.md_template;\n\thdr->driver_capture_mask = adapter->mdump.md_capture_mask;\n\thdr->driver_timestamp = ktime_get_seconds();\n\thdr->driver_info_word2 = adapter->fw_version;\n\thdr->driver_info_word3 = NXRD32(adapter, CRB_DRIVER_VERSION);\n\tret = netxen_parse_md_template(adapter);\n\tif (ret)\n\t\treturn ret;\n\n\treturn ret;\n}\n\n\nvoid\nnetxen_dump_fw(struct netxen_adapter *adapter)\n{\n\tstruct netxen_minidump_template_hdr *hdr;\n\tint i, k, data_size = 0;\n\tu32 capture_mask;\n\thdr = (struct netxen_minidump_template_hdr *)\n\t\t\t\tadapter->mdump.md_template;\n\tcapture_mask = adapter->mdump.md_capture_mask;\n\n\tfor (i = 0x2, k = 1; (i & NX_DUMP_MASK_MAX); i <<= 1, k++) {\n\t\tif (i & capture_mask)\n\t\t\tdata_size += hdr->capture_size_array[k];\n\t}\n\tif (!data_size) {\n\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\t\"Invalid cap sizes for capture_mask=0x%x\\n\",\n\t\t\tadapter->mdump.md_capture_mask);\n\t\treturn;\n\t}\n\tadapter->mdump.md_capture_size = data_size;\n\tadapter->mdump.md_dump_size = adapter->mdump.md_template_size +\n\t\t\t\t\tadapter->mdump.md_capture_size;\n\tif (!adapter->mdump.md_capture_buff) {\n\t\tadapter->mdump.md_capture_buff =\n\t\t\t\tvzalloc(adapter->mdump.md_dump_size);\n\t\tif (!adapter->mdump.md_capture_buff)\n\t\t\treturn;\n\n\t\tif (netxen_collect_minidump(adapter)) {\n\t\t\tadapter->mdump.has_valid_dump = 0;\n\t\t\tadapter->mdump.md_dump_size = 0;\n\t\t\tvfree(adapter->mdump.md_capture_buff);\n\t\t\tadapter->mdump.md_capture_buff = NULL;\n\t\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\t\"Error in collecting firmware minidump.\\n\");\n\t\t} else {\n\t\t\tadapter->mdump.md_timestamp = jiffies;\n\t\t\tadapter->mdump.has_valid_dump = 1;\n\t\t\tadapter->fw_mdump_rdy = 1;\n\t\t\tdev_info(&adapter->pdev->dev, \"%s Successfully \"\n\t\t\t\t\"collected fw dump.\\n\", adapter->netdev->name);\n\t\t}\n\n\t} else {\n\t\tdev_info(&adapter->pdev->dev,\n\t\t\t\t\t\"Cannot overwrite previously collected \"\n\t\t\t\t\t\t\t\"firmware minidump.\\n\");\n\t\tadapter->fw_mdump_rdy = 1;\n\t\treturn;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}