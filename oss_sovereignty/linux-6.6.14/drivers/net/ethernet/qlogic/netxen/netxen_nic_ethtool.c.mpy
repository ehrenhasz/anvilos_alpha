{
  "module_name": "netxen_nic_ethtool.c",
  "hash_id": "e33c9e12d27ebac9a86a54ae268e0928b49585758aa83360d0824601e78fa9e7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/qlogic/netxen/netxen_nic_ethtool.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/delay.h>\n#include <linux/pci.h>\n#include <asm/io.h>\n#include <linux/netdevice.h>\n#include <linux/ethtool.h>\n\n#include \"netxen_nic.h\"\n#include \"netxen_nic_hw.h\"\n\nstruct netxen_nic_stats {\n\tchar stat_string[ETH_GSTRING_LEN];\n\tint sizeof_stat;\n\tint stat_offset;\n};\n\n#define NETXEN_NIC_STAT(m) sizeof(((struct netxen_adapter *)0)->m), \\\n\t\t\toffsetof(struct netxen_adapter, m)\n\n#define NETXEN_NIC_PORT_WINDOW 0x10000\n#define NETXEN_NIC_INVALID_DATA 0xDEADBEEF\n\nstatic const struct netxen_nic_stats netxen_nic_gstrings_stats[] = {\n\t{\"xmit_called\", NETXEN_NIC_STAT(stats.xmitcalled)},\n\t{\"xmit_finished\", NETXEN_NIC_STAT(stats.xmitfinished)},\n\t{\"rx_dropped\", NETXEN_NIC_STAT(stats.rxdropped)},\n\t{\"tx_dropped\", NETXEN_NIC_STAT(stats.txdropped)},\n\t{\"csummed\", NETXEN_NIC_STAT(stats.csummed)},\n\t{\"rx_pkts\", NETXEN_NIC_STAT(stats.rx_pkts)},\n\t{\"lro_pkts\", NETXEN_NIC_STAT(stats.lro_pkts)},\n\t{\"rx_bytes\", NETXEN_NIC_STAT(stats.rxbytes)},\n\t{\"tx_bytes\", NETXEN_NIC_STAT(stats.txbytes)},\n};\n\n#define NETXEN_NIC_STATS_LEN\tARRAY_SIZE(netxen_nic_gstrings_stats)\n\nstatic const char netxen_nic_gstrings_test[][ETH_GSTRING_LEN] = {\n\t\"Register_Test_on_offline\",\n\t\"Link_Test_on_offline\"\n};\n\n#define NETXEN_NIC_TEST_LEN\tARRAY_SIZE(netxen_nic_gstrings_test)\n\n#define NETXEN_NIC_REGS_COUNT 30\n#define NETXEN_NIC_REGS_LEN (NETXEN_NIC_REGS_COUNT * sizeof(__le32))\n#define NETXEN_MAX_EEPROM_LEN   1024\n\nstatic int netxen_nic_get_eeprom_len(struct net_device *dev)\n{\n\treturn NETXEN_FLASH_TOTAL_SIZE;\n}\n\nstatic void\nnetxen_nic_get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *drvinfo)\n{\n\tstruct netxen_adapter *adapter = netdev_priv(dev);\n\tu32 fw_major = 0;\n\tu32 fw_minor = 0;\n\tu32 fw_build = 0;\n\n\tstrscpy(drvinfo->driver, netxen_nic_driver_name,\n\t\tsizeof(drvinfo->driver));\n\tstrscpy(drvinfo->version, NETXEN_NIC_LINUX_VERSIONID,\n\t\tsizeof(drvinfo->version));\n\tfw_major = NXRD32(adapter, NETXEN_FW_VERSION_MAJOR);\n\tfw_minor = NXRD32(adapter, NETXEN_FW_VERSION_MINOR);\n\tfw_build = NXRD32(adapter, NETXEN_FW_VERSION_SUB);\n\tsnprintf(drvinfo->fw_version, sizeof(drvinfo->fw_version),\n\t\t\"%d.%d.%d\", fw_major, fw_minor, fw_build);\n\n\tstrscpy(drvinfo->bus_info, pci_name(adapter->pdev),\n\t\tsizeof(drvinfo->bus_info));\n}\n\nstatic int\nnetxen_nic_get_link_ksettings(struct net_device *dev,\n\t\t\t      struct ethtool_link_ksettings *cmd)\n{\n\tstruct netxen_adapter *adapter = netdev_priv(dev);\n\tint check_sfp_module = 0;\n\tu32 supported, advertising;\n\n\t \n\tif (adapter->ahw.port_type == NETXEN_NIC_GBE) {\n\t\tsupported = (SUPPORTED_10baseT_Half |\n\t\t\t\t   SUPPORTED_10baseT_Full |\n\t\t\t\t   SUPPORTED_100baseT_Half |\n\t\t\t\t   SUPPORTED_100baseT_Full |\n\t\t\t\t   SUPPORTED_1000baseT_Half |\n\t\t\t\t   SUPPORTED_1000baseT_Full);\n\n\t\tadvertising = (ADVERTISED_100baseT_Half |\n\t\t\t\t     ADVERTISED_100baseT_Full |\n\t\t\t\t     ADVERTISED_1000baseT_Half |\n\t\t\t\t     ADVERTISED_1000baseT_Full);\n\n\t\tcmd->base.port = PORT_TP;\n\n\t\tcmd->base.speed = adapter->link_speed;\n\t\tcmd->base.duplex = adapter->link_duplex;\n\t\tcmd->base.autoneg = adapter->link_autoneg;\n\n\t} else if (adapter->ahw.port_type == NETXEN_NIC_XGBE) {\n\t\tu32 val;\n\n\t\tval = NXRD32(adapter, NETXEN_PORT_MODE_ADDR);\n\t\tif (val == NETXEN_PORT_MODE_802_3_AP) {\n\t\t\tsupported = SUPPORTED_1000baseT_Full;\n\t\t\tadvertising = ADVERTISED_1000baseT_Full;\n\t\t} else {\n\t\t\tsupported = SUPPORTED_10000baseT_Full;\n\t\t\tadvertising = ADVERTISED_10000baseT_Full;\n\t\t}\n\n\t\tif (netif_running(dev) && adapter->has_link_events) {\n\t\t\tcmd->base.speed = adapter->link_speed;\n\t\t\tcmd->base.autoneg = adapter->link_autoneg;\n\t\t\tcmd->base.duplex = adapter->link_duplex;\n\t\t\tgoto skip;\n\t\t}\n\n\t\tcmd->base.port = PORT_TP;\n\n\t\tif (NX_IS_REVISION_P3(adapter->ahw.revision_id)) {\n\t\t\tu16 pcifn = adapter->ahw.pci_func;\n\n\t\t\tval = NXRD32(adapter, P3_LINK_SPEED_REG(pcifn));\n\t\t\tcmd->base.speed = P3_LINK_SPEED_MHZ *\n\t\t\t\tP3_LINK_SPEED_VAL(pcifn, val);\n\t\t} else\n\t\t\tcmd->base.speed = SPEED_10000;\n\n\t\tcmd->base.duplex = DUPLEX_FULL;\n\t\tcmd->base.autoneg = AUTONEG_DISABLE;\n\t} else\n\t\treturn -EIO;\n\nskip:\n\tcmd->base.phy_address = adapter->physical_port;\n\n\tswitch (adapter->ahw.board_type) {\n\tcase NETXEN_BRDTYPE_P2_SB35_4G:\n\tcase NETXEN_BRDTYPE_P2_SB31_2G:\n\tcase NETXEN_BRDTYPE_P3_REF_QG:\n\tcase NETXEN_BRDTYPE_P3_4_GB:\n\tcase NETXEN_BRDTYPE_P3_4_GB_MM:\n\t\tsupported |= SUPPORTED_Autoneg;\n\t\tadvertising |= ADVERTISED_Autoneg;\n\t\tfallthrough;\n\tcase NETXEN_BRDTYPE_P2_SB31_10G_CX4:\n\tcase NETXEN_BRDTYPE_P3_10G_CX4:\n\tcase NETXEN_BRDTYPE_P3_10G_CX4_LP:\n\tcase NETXEN_BRDTYPE_P3_10000_BASE_T:\n\t\tsupported |= SUPPORTED_TP;\n\t\tadvertising |= ADVERTISED_TP;\n\t\tcmd->base.port = PORT_TP;\n\t\tcmd->base.autoneg = (adapter->ahw.board_type ==\n\t\t\t\t NETXEN_BRDTYPE_P2_SB31_10G_CX4) ?\n\t\t    (AUTONEG_DISABLE) : (adapter->link_autoneg);\n\t\tbreak;\n\tcase NETXEN_BRDTYPE_P2_SB31_10G_HMEZ:\n\tcase NETXEN_BRDTYPE_P2_SB31_10G_IMEZ:\n\tcase NETXEN_BRDTYPE_P3_IMEZ:\n\tcase NETXEN_BRDTYPE_P3_XG_LOM:\n\tcase NETXEN_BRDTYPE_P3_HMEZ:\n\t\tsupported |= SUPPORTED_MII;\n\t\tadvertising |= ADVERTISED_MII;\n\t\tcmd->base.port = PORT_MII;\n\t\tcmd->base.autoneg = AUTONEG_DISABLE;\n\t\tbreak;\n\tcase NETXEN_BRDTYPE_P3_10G_SFP_PLUS:\n\tcase NETXEN_BRDTYPE_P3_10G_SFP_CT:\n\tcase NETXEN_BRDTYPE_P3_10G_SFP_QT:\n\t\tadvertising |= ADVERTISED_TP;\n\t\tsupported |= SUPPORTED_TP;\n\t\tcheck_sfp_module = netif_running(dev) &&\n\t\t\tadapter->has_link_events;\n\t\tfallthrough;\n\tcase NETXEN_BRDTYPE_P2_SB31_10G:\n\tcase NETXEN_BRDTYPE_P3_10G_XFP:\n\t\tsupported |= SUPPORTED_FIBRE;\n\t\tadvertising |= ADVERTISED_FIBRE;\n\t\tcmd->base.port = PORT_FIBRE;\n\t\tcmd->base.autoneg = AUTONEG_DISABLE;\n\t\tbreak;\n\tcase NETXEN_BRDTYPE_P3_10G_TP:\n\t\tif (adapter->ahw.port_type == NETXEN_NIC_XGBE) {\n\t\t\tcmd->base.autoneg = AUTONEG_DISABLE;\n\t\t\tsupported |= (SUPPORTED_FIBRE | SUPPORTED_TP);\n\t\t\tadvertising |=\n\t\t\t\t(ADVERTISED_FIBRE | ADVERTISED_TP);\n\t\t\tcmd->base.port = PORT_FIBRE;\n\t\t\tcheck_sfp_module = netif_running(dev) &&\n\t\t\t\tadapter->has_link_events;\n\t\t} else {\n\t\t\tsupported |= (SUPPORTED_TP | SUPPORTED_Autoneg);\n\t\t\tadvertising |=\n\t\t\t\t(ADVERTISED_TP | ADVERTISED_Autoneg);\n\t\t\tcmd->base.port = PORT_TP;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_ERR \"netxen-nic: Unsupported board model %d\\n\",\n\t\t\t\tadapter->ahw.board_type);\n\t\treturn -EIO;\n\t}\n\n\tif (check_sfp_module) {\n\t\tswitch (adapter->module_type) {\n\t\tcase LINKEVENT_MODULE_OPTICAL_UNKNOWN:\n\t\tcase LINKEVENT_MODULE_OPTICAL_SRLR:\n\t\tcase LINKEVENT_MODULE_OPTICAL_LRM:\n\t\tcase LINKEVENT_MODULE_OPTICAL_SFP_1G:\n\t\t\tcmd->base.port = PORT_FIBRE;\n\t\t\tbreak;\n\t\tcase LINKEVENT_MODULE_TWINAX_UNSUPPORTED_CABLE:\n\t\tcase LINKEVENT_MODULE_TWINAX_UNSUPPORTED_CABLELEN:\n\t\tcase LINKEVENT_MODULE_TWINAX:\n\t\t\tcmd->base.port = PORT_TP;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcmd->base.port = -1;\n\t\t}\n\t}\n\n\tif (!netif_running(dev) || !adapter->ahw.linkup) {\n\t\tcmd->base.duplex = DUPLEX_UNKNOWN;\n\t\tcmd->base.speed = SPEED_UNKNOWN;\n\t}\n\n\tethtool_convert_legacy_u32_to_link_mode(cmd->link_modes.supported,\n\t\t\t\t\t\tsupported);\n\tethtool_convert_legacy_u32_to_link_mode(cmd->link_modes.advertising,\n\t\t\t\t\t\tadvertising);\n\n\treturn 0;\n}\n\nstatic int\nnetxen_nic_set_link_ksettings(struct net_device *dev,\n\t\t\t      const struct ethtool_link_ksettings *cmd)\n{\n\tstruct netxen_adapter *adapter = netdev_priv(dev);\n\tu32 speed = cmd->base.speed;\n\tint ret;\n\n\tif (adapter->ahw.port_type != NETXEN_NIC_GBE)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!(adapter->capabilities & NX_FW_CAPABILITY_GBE_LINK_CFG))\n\t\treturn -EOPNOTSUPP;\n\n\tret = nx_fw_cmd_set_gbe_port(adapter, speed, cmd->base.duplex,\n\t\t\t\t     cmd->base.autoneg);\n\tif (ret == NX_RCODE_NOT_SUPPORTED)\n\t\treturn -EOPNOTSUPP;\n\telse if (ret)\n\t\treturn -EIO;\n\n\tadapter->link_speed = speed;\n\tadapter->link_duplex = cmd->base.duplex;\n\tadapter->link_autoneg = cmd->base.autoneg;\n\n\tif (!netif_running(dev))\n\t\treturn 0;\n\n\tdev->netdev_ops->ndo_stop(dev);\n\treturn dev->netdev_ops->ndo_open(dev);\n}\n\nstatic int netxen_nic_get_regs_len(struct net_device *dev)\n{\n\treturn NETXEN_NIC_REGS_LEN;\n}\n\nstatic void\nnetxen_nic_get_regs(struct net_device *dev, struct ethtool_regs *regs, void *p)\n{\n\tstruct netxen_adapter *adapter = netdev_priv(dev);\n\tstruct netxen_recv_context *recv_ctx = &adapter->recv_ctx;\n\tstruct nx_host_sds_ring *sds_ring;\n\tu32 *regs_buff = p;\n\tint ring, i = 0;\n\tint port = adapter->physical_port;\n\n\tmemset(p, 0, NETXEN_NIC_REGS_LEN);\n\n\tregs->version = (1 << 24) | (adapter->ahw.revision_id << 16) |\n\t    (adapter->pdev)->device;\n\n\tif (adapter->is_up != NETXEN_ADAPTER_UP_MAGIC)\n\t\treturn;\n\n\tregs_buff[i++] = NXRD32(adapter, CRB_CMDPEG_STATE);\n\tregs_buff[i++] = NXRD32(adapter, CRB_RCVPEG_STATE);\n\tregs_buff[i++] = NXRD32(adapter, CRB_FW_CAPABILITIES_1);\n\tregs_buff[i++] = NXRDIO(adapter, adapter->crb_int_state_reg);\n\tregs_buff[i++] = NXRD32(adapter, NX_CRB_DEV_REF_COUNT);\n\tregs_buff[i++] = NXRD32(adapter, NX_CRB_DEV_STATE);\n\tregs_buff[i++] = NXRD32(adapter, NETXEN_PEG_ALIVE_COUNTER);\n\tregs_buff[i++] = NXRD32(adapter, NETXEN_PEG_HALT_STATUS1);\n\tregs_buff[i++] = NXRD32(adapter, NETXEN_PEG_HALT_STATUS2);\n\n\tregs_buff[i++] = NXRD32(adapter, NETXEN_CRB_PEG_NET_0+0x3c);\n\tregs_buff[i++] = NXRD32(adapter, NETXEN_CRB_PEG_NET_1+0x3c);\n\tregs_buff[i++] = NXRD32(adapter, NETXEN_CRB_PEG_NET_2+0x3c);\n\tregs_buff[i++] = NXRD32(adapter, NETXEN_CRB_PEG_NET_3+0x3c);\n\n\tif (NX_IS_REVISION_P3(adapter->ahw.revision_id)) {\n\n\t\tregs_buff[i++] = NXRD32(adapter, NETXEN_CRB_PEG_NET_4+0x3c);\n\t\ti += 2;\n\n\t\tregs_buff[i++] = NXRD32(adapter, CRB_XG_STATE_P3);\n\t\tregs_buff[i++] = le32_to_cpu(*(adapter->tx_ring->hw_consumer));\n\n\t} else {\n\t\ti++;\n\n\t\tregs_buff[i++] = NXRD32(adapter,\n\t\t\t\t\tNETXEN_NIU_XGE_CONFIG_0+(0x10000*port));\n\t\tregs_buff[i++] = NXRD32(adapter,\n\t\t\t\t\tNETXEN_NIU_XGE_CONFIG_1+(0x10000*port));\n\n\t\tregs_buff[i++] = NXRD32(adapter, CRB_XG_STATE);\n\t\tregs_buff[i++] = NXRDIO(adapter,\n\t\t\t\t adapter->tx_ring->crb_cmd_consumer);\n\t}\n\n\tregs_buff[i++] = NXRDIO(adapter, adapter->tx_ring->crb_cmd_producer);\n\n\tregs_buff[i++] = NXRDIO(adapter,\n\t\t\t recv_ctx->rds_rings[0].crb_rcv_producer);\n\tregs_buff[i++] = NXRDIO(adapter,\n\t\t\t recv_ctx->rds_rings[1].crb_rcv_producer);\n\n\tregs_buff[i++] = adapter->max_sds_rings;\n\n\tfor (ring = 0; ring < adapter->max_sds_rings; ring++) {\n\t\tsds_ring = &(recv_ctx->sds_rings[ring]);\n\t\tregs_buff[i++] = NXRDIO(adapter,\n\t\t\t\t\tsds_ring->crb_sts_consumer);\n\t}\n}\n\nstatic u32 netxen_nic_test_link(struct net_device *dev)\n{\n\tstruct netxen_adapter *adapter = netdev_priv(dev);\n\tu32 val, port;\n\n\tport = adapter->physical_port;\n\tif (NX_IS_REVISION_P3(adapter->ahw.revision_id)) {\n\t\tval = NXRD32(adapter, CRB_XG_STATE_P3);\n\t\tval = XG_LINK_STATE_P3(adapter->ahw.pci_func, val);\n\t\treturn (val == XG_LINK_UP_P3) ? 0 : 1;\n\t} else {\n\t\tval = NXRD32(adapter, CRB_XG_STATE);\n\t\tval = (val >> port*8) & 0xff;\n\t\treturn (val == XG_LINK_UP) ? 0 : 1;\n\t}\n}\n\nstatic int\nnetxen_nic_get_eeprom(struct net_device *dev, struct ethtool_eeprom *eeprom,\n\t\t      u8 *bytes)\n{\n\tstruct netxen_adapter *adapter = netdev_priv(dev);\n\tint offset;\n\tint ret;\n\n\tif (eeprom->len == 0)\n\t\treturn -EINVAL;\n\n\teeprom->magic = (adapter->pdev)->vendor |\n\t\t\t((adapter->pdev)->device << 16);\n\toffset = eeprom->offset;\n\n\tret = netxen_rom_fast_read_words(adapter, offset, bytes,\n\t\t\t\t\t\teeprom->len);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic void\nnetxen_nic_get_ringparam(struct net_device *dev,\n\t\t\t struct ethtool_ringparam *ring,\n\t\t\t struct kernel_ethtool_ringparam *kernel_ring,\n\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct netxen_adapter *adapter = netdev_priv(dev);\n\n\tring->rx_pending = adapter->num_rxd;\n\tring->rx_jumbo_pending = adapter->num_jumbo_rxd;\n\tring->rx_jumbo_pending += adapter->num_lro_rxd;\n\tring->tx_pending = adapter->num_txd;\n\n\tif (adapter->ahw.port_type == NETXEN_NIC_GBE) {\n\t\tring->rx_max_pending = MAX_RCV_DESCRIPTORS_1G;\n\t\tring->rx_jumbo_max_pending = MAX_JUMBO_RCV_DESCRIPTORS_1G;\n\t} else {\n\t\tring->rx_max_pending = MAX_RCV_DESCRIPTORS_10G;\n\t\tring->rx_jumbo_max_pending = MAX_JUMBO_RCV_DESCRIPTORS_10G;\n\t}\n\n\tring->tx_max_pending = MAX_CMD_DESCRIPTORS;\n}\n\nstatic u32\nnetxen_validate_ringparam(u32 val, u32 min, u32 max, char *r_name)\n{\n\tu32 num_desc;\n\tnum_desc = max(val, min);\n\tnum_desc = min(num_desc, max);\n\tnum_desc = roundup_pow_of_two(num_desc);\n\n\tif (val != num_desc) {\n\t\tprintk(KERN_INFO \"%s: setting %s ring size %d instead of %d\\n\",\n\t\t       netxen_nic_driver_name, r_name, num_desc, val);\n\t}\n\n\treturn num_desc;\n}\n\nstatic int\nnetxen_nic_set_ringparam(struct net_device *dev,\n\t\t\t struct ethtool_ringparam *ring,\n\t\t\t struct kernel_ethtool_ringparam *kernel_ring,\n\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct netxen_adapter *adapter = netdev_priv(dev);\n\tu16 max_rcv_desc = MAX_RCV_DESCRIPTORS_10G;\n\tu16 max_jumbo_desc = MAX_JUMBO_RCV_DESCRIPTORS_10G;\n\tu16 num_rxd, num_jumbo_rxd, num_txd;\n\n\tif (NX_IS_REVISION_P2(adapter->ahw.revision_id))\n\t\treturn -EOPNOTSUPP;\n\n\tif (ring->rx_mini_pending)\n\t\treturn -EOPNOTSUPP;\n\n\tif (adapter->ahw.port_type == NETXEN_NIC_GBE) {\n\t\tmax_rcv_desc = MAX_RCV_DESCRIPTORS_1G;\n\t\tmax_jumbo_desc = MAX_JUMBO_RCV_DESCRIPTORS_10G;\n\t}\n\n\tnum_rxd = netxen_validate_ringparam(ring->rx_pending,\n\t\t\tMIN_RCV_DESCRIPTORS, max_rcv_desc, \"rx\");\n\n\tnum_jumbo_rxd = netxen_validate_ringparam(ring->rx_jumbo_pending,\n\t\t\tMIN_JUMBO_DESCRIPTORS, max_jumbo_desc, \"rx jumbo\");\n\n\tnum_txd = netxen_validate_ringparam(ring->tx_pending,\n\t\t\tMIN_CMD_DESCRIPTORS, MAX_CMD_DESCRIPTORS, \"tx\");\n\n\tif (num_rxd == adapter->num_rxd && num_txd == adapter->num_txd &&\n\t\t\tnum_jumbo_rxd == adapter->num_jumbo_rxd)\n\t\treturn 0;\n\n\tadapter->num_rxd = num_rxd;\n\tadapter->num_jumbo_rxd = num_jumbo_rxd;\n\tadapter->num_txd = num_txd;\n\n\treturn netxen_nic_reset_context(adapter);\n}\n\nstatic void\nnetxen_nic_get_pauseparam(struct net_device *dev,\n\t\t\t  struct ethtool_pauseparam *pause)\n{\n\tstruct netxen_adapter *adapter = netdev_priv(dev);\n\t__u32 val;\n\tint port = adapter->physical_port;\n\n\tpause->autoneg = 0;\n\n\tif (adapter->ahw.port_type == NETXEN_NIC_GBE) {\n\t\tif ((port < 0) || (port >= NETXEN_NIU_MAX_GBE_PORTS))\n\t\t\treturn;\n\t\t \n\t\tval = NXRD32(adapter, NETXEN_NIU_GB_MAC_CONFIG_0(port));\n\t\tpause->rx_pause = netxen_gb_get_rx_flowctl(val);\n\t\tval = NXRD32(adapter, NETXEN_NIU_GB_PAUSE_CTL);\n\t\tswitch (port) {\n\t\tcase 0:\n\t\t\tpause->tx_pause = !(netxen_gb_get_gb0_mask(val));\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tpause->tx_pause = !(netxen_gb_get_gb1_mask(val));\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tpause->tx_pause = !(netxen_gb_get_gb2_mask(val));\n\t\t\tbreak;\n\t\tcase 3:\n\t\tdefault:\n\t\t\tpause->tx_pause = !(netxen_gb_get_gb3_mask(val));\n\t\t\tbreak;\n\t\t}\n\t} else if (adapter->ahw.port_type == NETXEN_NIC_XGBE) {\n\t\tif ((port < 0) || (port >= NETXEN_NIU_MAX_XG_PORTS))\n\t\t\treturn;\n\t\tpause->rx_pause = 1;\n\t\tval = NXRD32(adapter, NETXEN_NIU_XG_PAUSE_CTL);\n\t\tif (port == 0)\n\t\t\tpause->tx_pause = !(netxen_xg_get_xg0_mask(val));\n\t\telse\n\t\t\tpause->tx_pause = !(netxen_xg_get_xg1_mask(val));\n\t} else {\n\t\tprintk(KERN_ERR\"%s: Unknown board type: %x\\n\",\n\t\t\t\tnetxen_nic_driver_name, adapter->ahw.port_type);\n\t}\n}\n\nstatic int\nnetxen_nic_set_pauseparam(struct net_device *dev,\n\t\t\t  struct ethtool_pauseparam *pause)\n{\n\tstruct netxen_adapter *adapter = netdev_priv(dev);\n\t__u32 val;\n\tint port = adapter->physical_port;\n\n\t \n\tif (pause->autoneg)\n\t\treturn -EINVAL;\n\n\t \n\tif (adapter->ahw.port_type == NETXEN_NIC_GBE) {\n\t\tif ((port < 0) || (port >= NETXEN_NIU_MAX_GBE_PORTS))\n\t\t\treturn -EIO;\n\t\t \n\t\tval = NXRD32(adapter, NETXEN_NIU_GB_MAC_CONFIG_0(port));\n\n\t\tif (pause->rx_pause)\n\t\t\tnetxen_gb_rx_flowctl(val);\n\t\telse\n\t\t\tnetxen_gb_unset_rx_flowctl(val);\n\n\t\tNXWR32(adapter, NETXEN_NIU_GB_MAC_CONFIG_0(port),\n\t\t\t\tval);\n\t\t \n\t\tval = NXRD32(adapter, NETXEN_NIU_GB_PAUSE_CTL);\n\t\tswitch (port) {\n\t\tcase 0:\n\t\t\tif (pause->tx_pause)\n\t\t\t\tnetxen_gb_unset_gb0_mask(val);\n\t\t\telse\n\t\t\t\tnetxen_gb_set_gb0_mask(val);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif (pause->tx_pause)\n\t\t\t\tnetxen_gb_unset_gb1_mask(val);\n\t\t\telse\n\t\t\t\tnetxen_gb_set_gb1_mask(val);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tif (pause->tx_pause)\n\t\t\t\tnetxen_gb_unset_gb2_mask(val);\n\t\t\telse\n\t\t\t\tnetxen_gb_set_gb2_mask(val);\n\t\t\tbreak;\n\t\tcase 3:\n\t\tdefault:\n\t\t\tif (pause->tx_pause)\n\t\t\t\tnetxen_gb_unset_gb3_mask(val);\n\t\t\telse\n\t\t\t\tnetxen_gb_set_gb3_mask(val);\n\t\t\tbreak;\n\t\t}\n\t\tNXWR32(adapter, NETXEN_NIU_GB_PAUSE_CTL, val);\n\t} else if (adapter->ahw.port_type == NETXEN_NIC_XGBE) {\n\t\tif ((port < 0) || (port >= NETXEN_NIU_MAX_XG_PORTS))\n\t\t\treturn -EIO;\n\t\tval = NXRD32(adapter, NETXEN_NIU_XG_PAUSE_CTL);\n\t\tif (port == 0) {\n\t\t\tif (pause->tx_pause)\n\t\t\t\tnetxen_xg_unset_xg0_mask(val);\n\t\t\telse\n\t\t\t\tnetxen_xg_set_xg0_mask(val);\n\t\t} else {\n\t\t\tif (pause->tx_pause)\n\t\t\t\tnetxen_xg_unset_xg1_mask(val);\n\t\t\telse\n\t\t\t\tnetxen_xg_set_xg1_mask(val);\n\t\t}\n\t\tNXWR32(adapter, NETXEN_NIU_XG_PAUSE_CTL, val);\n\t} else {\n\t\tprintk(KERN_ERR \"%s: Unknown board type: %x\\n\",\n\t\t\t\tnetxen_nic_driver_name,\n\t\t\t\tadapter->ahw.port_type);\n\t}\n\treturn 0;\n}\n\nstatic int netxen_nic_reg_test(struct net_device *dev)\n{\n\tstruct netxen_adapter *adapter = netdev_priv(dev);\n\tu32 data_read, data_written;\n\n\tdata_read = NXRD32(adapter, NETXEN_PCIX_PH_REG(0));\n\tif ((data_read & 0xffff) != adapter->pdev->vendor)\n\t\treturn 1;\n\n\tif (NX_IS_REVISION_P3(adapter->ahw.revision_id))\n\t\treturn 0;\n\n\tdata_written = (u32)0xa5a5a5a5;\n\n\tNXWR32(adapter, CRB_SCRATCHPAD_TEST, data_written);\n\tdata_read = NXRD32(adapter, CRB_SCRATCHPAD_TEST);\n\tif (data_written != data_read)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic int netxen_get_sset_count(struct net_device *dev, int sset)\n{\n\tswitch (sset) {\n\tcase ETH_SS_TEST:\n\t\treturn NETXEN_NIC_TEST_LEN;\n\tcase ETH_SS_STATS:\n\t\treturn NETXEN_NIC_STATS_LEN;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic void\nnetxen_nic_diag_test(struct net_device *dev, struct ethtool_test *eth_test,\n\t\t     u64 *data)\n{\n\tmemset(data, 0, sizeof(uint64_t) * NETXEN_NIC_TEST_LEN);\n\tif ((data[0] = netxen_nic_reg_test(dev)))\n\t\teth_test->flags |= ETH_TEST_FL_FAILED;\n\t \n\tif ((data[1] = (u64) netxen_nic_test_link(dev)))\n\t\teth_test->flags |= ETH_TEST_FL_FAILED;\n}\n\nstatic void\nnetxen_nic_get_strings(struct net_device *dev, u32 stringset, u8 *data)\n{\n\tint index;\n\n\tswitch (stringset) {\n\tcase ETH_SS_TEST:\n\t\tmemcpy(data, *netxen_nic_gstrings_test,\n\t\t       NETXEN_NIC_TEST_LEN * ETH_GSTRING_LEN);\n\t\tbreak;\n\tcase ETH_SS_STATS:\n\t\tfor (index = 0; index < NETXEN_NIC_STATS_LEN; index++) {\n\t\t\tmemcpy(data + index * ETH_GSTRING_LEN,\n\t\t\t       netxen_nic_gstrings_stats[index].stat_string,\n\t\t\t       ETH_GSTRING_LEN);\n\t\t}\n\t\tbreak;\n\t}\n}\n\nstatic void\nnetxen_nic_get_ethtool_stats(struct net_device *dev,\n\t\t\t     struct ethtool_stats *stats, u64 *data)\n{\n\tstruct netxen_adapter *adapter = netdev_priv(dev);\n\tint index;\n\n\tfor (index = 0; index < NETXEN_NIC_STATS_LEN; index++) {\n\t\tchar *p =\n\t\t    (char *)adapter +\n\t\t    netxen_nic_gstrings_stats[index].stat_offset;\n\t\tdata[index] =\n\t\t    (netxen_nic_gstrings_stats[index].sizeof_stat ==\n\t\t     sizeof(u64)) ? *(u64 *) p : *(u32 *) p;\n\t}\n}\n\nstatic void\nnetxen_nic_get_wol(struct net_device *dev, struct ethtool_wolinfo *wol)\n{\n\tstruct netxen_adapter *adapter = netdev_priv(dev);\n\tu32 wol_cfg = 0;\n\n\twol->supported = 0;\n\twol->wolopts = 0;\n\n\tif (NX_IS_REVISION_P2(adapter->ahw.revision_id))\n\t\treturn;\n\n\twol_cfg = NXRD32(adapter, NETXEN_WOL_CONFIG_NV);\n\tif (wol_cfg & (1UL << adapter->portnum))\n\t\twol->supported |= WAKE_MAGIC;\n\n\twol_cfg = NXRD32(adapter, NETXEN_WOL_CONFIG);\n\tif (wol_cfg & (1UL << adapter->portnum))\n\t\twol->wolopts |= WAKE_MAGIC;\n}\n\nstatic int\nnetxen_nic_set_wol(struct net_device *dev, struct ethtool_wolinfo *wol)\n{\n\tstruct netxen_adapter *adapter = netdev_priv(dev);\n\tu32 wol_cfg = 0;\n\n\tif (NX_IS_REVISION_P2(adapter->ahw.revision_id))\n\t\treturn -EOPNOTSUPP;\n\n\tif (wol->wolopts & ~WAKE_MAGIC)\n\t\treturn -EOPNOTSUPP;\n\n\twol_cfg = NXRD32(adapter, NETXEN_WOL_CONFIG_NV);\n\tif (!(wol_cfg & (1 << adapter->portnum)))\n\t\treturn -EOPNOTSUPP;\n\n\twol_cfg = NXRD32(adapter, NETXEN_WOL_CONFIG);\n\tif (wol->wolopts & WAKE_MAGIC)\n\t\twol_cfg |= 1UL << adapter->portnum;\n\telse\n\t\twol_cfg &= ~(1UL << adapter->portnum);\n\tNXWR32(adapter, NETXEN_WOL_CONFIG, wol_cfg);\n\n\treturn 0;\n}\n\n \nstatic int netxen_set_intr_coalesce(struct net_device *netdev,\n\t\t\t\t    struct ethtool_coalesce *ethcoal,\n\t\t\t\t    struct kernel_ethtool_coalesce *kernel_coal,\n\t\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct netxen_adapter *adapter = netdev_priv(netdev);\n\n\tif (!NX_IS_REVISION_P3(adapter->ahw.revision_id))\n\t\treturn -EINVAL;\n\n\tif (adapter->is_up != NETXEN_ADAPTER_UP_MAGIC)\n\t\treturn -EINVAL;\n\n\t \n\tif (ethcoal->rx_coalesce_usecs > 0xffff ||\n\t\tethcoal->rx_max_coalesced_frames > 0xffff ||\n\t\tethcoal->tx_coalesce_usecs > 0xffff ||\n\t\tethcoal->tx_max_coalesced_frames > 0xffff)\n\t\treturn -EINVAL;\n\n\tif (!ethcoal->rx_coalesce_usecs ||\n\t\t!ethcoal->rx_max_coalesced_frames) {\n\t\tadapter->coal.flags = NETXEN_NIC_INTR_DEFAULT;\n\t\tadapter->coal.normal.data.rx_time_us =\n\t\t\tNETXEN_DEFAULT_INTR_COALESCE_RX_TIME_US;\n\t\tadapter->coal.normal.data.rx_packets =\n\t\t\tNETXEN_DEFAULT_INTR_COALESCE_RX_PACKETS;\n\t} else {\n\t\tadapter->coal.flags = 0;\n\t\tadapter->coal.normal.data.rx_time_us =\n\t\tethcoal->rx_coalesce_usecs;\n\t\tadapter->coal.normal.data.rx_packets =\n\t\tethcoal->rx_max_coalesced_frames;\n\t}\n\tadapter->coal.normal.data.tx_time_us = ethcoal->tx_coalesce_usecs;\n\tadapter->coal.normal.data.tx_packets =\n\tethcoal->tx_max_coalesced_frames;\n\n\tnetxen_config_intr_coalesce(adapter);\n\n\treturn 0;\n}\n\nstatic int netxen_get_intr_coalesce(struct net_device *netdev,\n\t\t\t\t    struct ethtool_coalesce *ethcoal,\n\t\t\t\t    struct kernel_ethtool_coalesce *kernel_coal,\n\t\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct netxen_adapter *adapter = netdev_priv(netdev);\n\n\tif (!NX_IS_REVISION_P3(adapter->ahw.revision_id))\n\t\treturn -EINVAL;\n\n\tif (adapter->is_up != NETXEN_ADAPTER_UP_MAGIC)\n\t\treturn -EINVAL;\n\n\tethcoal->rx_coalesce_usecs = adapter->coal.normal.data.rx_time_us;\n\tethcoal->tx_coalesce_usecs = adapter->coal.normal.data.tx_time_us;\n\tethcoal->rx_max_coalesced_frames =\n\t\tadapter->coal.normal.data.rx_packets;\n\tethcoal->tx_max_coalesced_frames =\n\t\tadapter->coal.normal.data.tx_packets;\n\n\treturn 0;\n}\n\nstatic int\nnetxen_get_dump_flag(struct net_device *netdev, struct ethtool_dump *dump)\n{\n\tstruct netxen_adapter *adapter = netdev_priv(netdev);\n\tstruct netxen_minidump *mdump = &adapter->mdump;\n\tif (adapter->fw_mdump_rdy)\n\t\tdump->len = mdump->md_dump_size;\n\telse\n\t\tdump->len = 0;\n\n\tif (!mdump->md_enabled)\n\t\tdump->flag = ETH_FW_DUMP_DISABLE;\n\telse\n\t\tdump->flag = mdump->md_capture_mask;\n\n\tdump->version = adapter->fw_version;\n\treturn 0;\n}\n\n \nstatic const u32 FW_DUMP_LEVELS[] = { 0x3, 0x7, 0xf, 0x1f, 0x3f, 0x7f, 0xff };\n\nstatic int\nnetxen_set_dump(struct net_device *netdev, struct ethtool_dump *val)\n{\n\tint i;\n\tstruct netxen_adapter *adapter = netdev_priv(netdev);\n\tstruct netxen_minidump *mdump = &adapter->mdump;\n\n\tswitch (val->flag) {\n\tcase NX_FORCE_FW_DUMP_KEY:\n\t\tif (!mdump->md_enabled) {\n\t\t\tnetdev_info(netdev, \"FW dump not enabled\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tif (adapter->fw_mdump_rdy) {\n\t\t\tnetdev_info(netdev, \"Previous dump not cleared, not forcing dump\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tnetdev_info(netdev, \"Forcing a fw dump\\n\");\n\t\tnx_dev_request_reset(adapter);\n\t\tbreak;\n\tcase NX_DISABLE_FW_DUMP:\n\t\tif (mdump->md_enabled) {\n\t\t\tnetdev_info(netdev, \"Disabling FW Dump\\n\");\n\t\t\tmdump->md_enabled = 0;\n\t\t}\n\t\tbreak;\n\tcase NX_ENABLE_FW_DUMP:\n\t\tif (!mdump->md_enabled) {\n\t\t\tnetdev_info(netdev, \"Enabling FW dump\\n\");\n\t\t\tmdump->md_enabled = 1;\n\t\t}\n\t\tbreak;\n\tcase NX_FORCE_FW_RESET:\n\t\tnetdev_info(netdev, \"Forcing FW reset\\n\");\n\t\tnx_dev_request_reset(adapter);\n\t\tadapter->flags &= ~NETXEN_FW_RESET_OWNER;\n\t\tbreak;\n\tdefault:\n\t\tfor (i = 0; i < ARRAY_SIZE(FW_DUMP_LEVELS); i++) {\n\t\t\tif (val->flag == FW_DUMP_LEVELS[i]) {\n\t\t\t\tmdump->md_capture_mask = val->flag;\n\t\t\t\tnetdev_info(netdev,\n\t\t\t\t\t\"Driver mask changed to: 0x%x\\n\",\n\t\t\t\t\tmdump->md_capture_mask);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tnetdev_info(netdev,\n\t\t\t\"Invalid dump level: 0x%x\\n\", val->flag);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nnetxen_get_dump_data(struct net_device *netdev, struct ethtool_dump *dump,\n\t\t\tvoid *buffer)\n{\n\tint i, copy_sz;\n\tu32 *hdr_ptr, *data;\n\tstruct netxen_adapter *adapter = netdev_priv(netdev);\n\tstruct netxen_minidump *mdump = &adapter->mdump;\n\n\n\tif (!adapter->fw_mdump_rdy) {\n\t\tnetdev_info(netdev, \"Dump not available\\n\");\n\t\treturn -EINVAL;\n\t}\n\t \n\tcopy_sz = mdump->md_template_size;\n\thdr_ptr = (u32 *) mdump->md_template;\n\tdata = buffer;\n\tfor (i = 0; i < copy_sz/sizeof(u32); i++)\n\t\t*data++ = cpu_to_le32(*hdr_ptr++);\n\n\t \n\tmemcpy(buffer + copy_sz,\n\t\tmdump->md_capture_buff + mdump->md_template_size,\n\t\t\tmdump->md_capture_size);\n\tdump->len = copy_sz + mdump->md_capture_size;\n\tdump->flag = mdump->md_capture_mask;\n\n\t \n\tvfree(mdump->md_capture_buff);\n\tmdump->md_capture_buff = NULL;\n\tadapter->fw_mdump_rdy = 0;\n\tnetdev_info(netdev, \"extracted the fw dump Successfully\\n\");\n\treturn 0;\n}\n\nconst struct ethtool_ops netxen_nic_ethtool_ops = {\n\t.supported_coalesce_params = ETHTOOL_COALESCE_USECS |\n\t\t\t\t     ETHTOOL_COALESCE_MAX_FRAMES,\n\t.get_drvinfo = netxen_nic_get_drvinfo,\n\t.get_regs_len = netxen_nic_get_regs_len,\n\t.get_regs = netxen_nic_get_regs,\n\t.get_link = ethtool_op_get_link,\n\t.get_eeprom_len = netxen_nic_get_eeprom_len,\n\t.get_eeprom = netxen_nic_get_eeprom,\n\t.get_ringparam = netxen_nic_get_ringparam,\n\t.set_ringparam = netxen_nic_set_ringparam,\n\t.get_pauseparam = netxen_nic_get_pauseparam,\n\t.set_pauseparam = netxen_nic_set_pauseparam,\n\t.get_wol = netxen_nic_get_wol,\n\t.set_wol = netxen_nic_set_wol,\n\t.self_test = netxen_nic_diag_test,\n\t.get_strings = netxen_nic_get_strings,\n\t.get_ethtool_stats = netxen_nic_get_ethtool_stats,\n\t.get_sset_count = netxen_get_sset_count,\n\t.get_coalesce = netxen_get_intr_coalesce,\n\t.set_coalesce = netxen_set_intr_coalesce,\n\t.get_dump_flag = netxen_get_dump_flag,\n\t.get_dump_data = netxen_get_dump_data,\n\t.set_dump = netxen_set_dump,\n\t.get_link_ksettings = netxen_nic_get_link_ksettings,\n\t.set_link_ksettings = netxen_nic_set_link_ksettings,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}