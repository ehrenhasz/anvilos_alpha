{
  "module_name": "netxen_nic_ctx.c",
  "hash_id": "bddfd58f6de91cdc1e73686e22ab522fd6a5d1ce01e2bb3323eb5c9f00b639b3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/qlogic/netxen/netxen_nic_ctx.c",
  "human_readable_source": "\n \n\n#include \"netxen_nic_hw.h\"\n#include \"netxen_nic.h\"\n\n#define NXHAL_VERSION\t1\n\nstatic u32\nnetxen_poll_rsp(struct netxen_adapter *adapter)\n{\n\tu32 rsp = NX_CDRP_RSP_OK;\n\tint\ttimeout = 0;\n\n\tdo {\n\t\t \n\t\tmsleep(1);\n\n\t\tif (++timeout > NX_OS_CRB_RETRY_COUNT)\n\t\t\treturn NX_CDRP_RSP_TIMEOUT;\n\n\t\trsp = NXRD32(adapter, NX_CDRP_CRB_OFFSET);\n\t} while (!NX_CDRP_IS_RSP(rsp));\n\n\treturn rsp;\n}\n\nstatic u32\nnetxen_issue_cmd(struct netxen_adapter *adapter, struct netxen_cmd_args *cmd)\n{\n\tu32 rsp;\n\tu32 signature = 0;\n\tu32 rcode = NX_RCODE_SUCCESS;\n\n\tsignature = NX_CDRP_SIGNATURE_MAKE(adapter->ahw.pci_func,\n\t\t\t\t\t\tNXHAL_VERSION);\n\t \n\tif (netxen_api_lock(adapter))\n\t\treturn NX_RCODE_TIMEOUT;\n\n\tNXWR32(adapter, NX_SIGN_CRB_OFFSET, signature);\n\n\tNXWR32(adapter, NX_ARG1_CRB_OFFSET, cmd->req.arg1);\n\n\tNXWR32(adapter, NX_ARG2_CRB_OFFSET, cmd->req.arg2);\n\n\tNXWR32(adapter, NX_ARG3_CRB_OFFSET, cmd->req.arg3);\n\n\tNXWR32(adapter, NX_CDRP_CRB_OFFSET, NX_CDRP_FORM_CMD(cmd->req.cmd));\n\n\trsp = netxen_poll_rsp(adapter);\n\n\tif (rsp == NX_CDRP_RSP_TIMEOUT) {\n\t\tprintk(KERN_ERR \"%s: card response timeout.\\n\",\n\t\t\t\tnetxen_nic_driver_name);\n\n\t\trcode = NX_RCODE_TIMEOUT;\n\t} else if (rsp == NX_CDRP_RSP_FAIL) {\n\t\trcode = NXRD32(adapter, NX_ARG1_CRB_OFFSET);\n\n\t\tprintk(KERN_ERR \"%s: failed card response code:0x%x\\n\",\n\t\t\t\tnetxen_nic_driver_name, rcode);\n\t} else if (rsp == NX_CDRP_RSP_OK) {\n\t\tcmd->rsp.cmd = NX_RCODE_SUCCESS;\n\t\tif (cmd->rsp.arg2)\n\t\t\tcmd->rsp.arg2 = NXRD32(adapter, NX_ARG2_CRB_OFFSET);\n\t\tif (cmd->rsp.arg3)\n\t\t\tcmd->rsp.arg3 = NXRD32(adapter, NX_ARG3_CRB_OFFSET);\n\t}\n\n\tif (cmd->rsp.arg1)\n\t\tcmd->rsp.arg1 = NXRD32(adapter, NX_ARG1_CRB_OFFSET);\n\t \n\tnetxen_api_unlock(adapter);\n\n\treturn rcode;\n}\n\nstatic int\nnetxen_get_minidump_template_size(struct netxen_adapter *adapter)\n{\n\tstruct netxen_cmd_args cmd;\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.req.cmd = NX_CDRP_CMD_TEMP_SIZE;\n\tmemset(&cmd.rsp, 1, sizeof(struct _cdrp_cmd));\n\tnetxen_issue_cmd(adapter, &cmd);\n\tif (cmd.rsp.cmd != NX_RCODE_SUCCESS) {\n\t\tdev_info(&adapter->pdev->dev,\n\t\t\t\"Can't get template size %d\\n\", cmd.rsp.cmd);\n\t\treturn -EIO;\n\t}\n\tadapter->mdump.md_template_size = cmd.rsp.arg2;\n\tadapter->mdump.md_template_ver = cmd.rsp.arg3;\n\treturn 0;\n}\n\nstatic int\nnetxen_get_minidump_template(struct netxen_adapter *adapter)\n{\n\tdma_addr_t md_template_addr;\n\tvoid *addr;\n\tu32 size;\n\tstruct netxen_cmd_args cmd;\n\tsize = adapter->mdump.md_template_size;\n\n\tif (size == 0) {\n\t\tdev_err(&adapter->pdev->dev, \"Can not capture Minidump \"\n\t\t\t\"template. Invalid template size.\\n\");\n\t\treturn NX_RCODE_INVALID_ARGS;\n\t}\n\n\taddr = dma_alloc_coherent(&adapter->pdev->dev, size,\n\t\t\t\t  &md_template_addr, GFP_KERNEL);\n\tif (!addr) {\n\t\tdev_err(&adapter->pdev->dev, \"Unable to allocate dmable memory for template.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\tmemset(&cmd.rsp, 1, sizeof(struct _cdrp_cmd));\n\tcmd.req.cmd = NX_CDRP_CMD_GET_TEMP_HDR;\n\tcmd.req.arg1 = LSD(md_template_addr);\n\tcmd.req.arg2 = MSD(md_template_addr);\n\tcmd.req.arg3 |= size;\n\tnetxen_issue_cmd(adapter, &cmd);\n\n\tif ((cmd.rsp.cmd == NX_RCODE_SUCCESS) && (size == cmd.rsp.arg2)) {\n\t\tmemcpy(adapter->mdump.md_template, addr, size);\n\t} else {\n\t\tdev_err(&adapter->pdev->dev, \"Failed to get minidump template, err_code : %d, requested_size : %d, actual_size : %d\\n\",\n\t\t\tcmd.rsp.cmd, size, cmd.rsp.arg2);\n\t}\n\tdma_free_coherent(&adapter->pdev->dev, size, addr, md_template_addr);\n\treturn 0;\n}\n\nstatic u32\nnetxen_check_template_checksum(struct netxen_adapter *adapter)\n{\n\tu64 sum =  0 ;\n\tu32 *buff = adapter->mdump.md_template;\n\tint count =  adapter->mdump.md_template_size/sizeof(uint32_t) ;\n\n\twhile (count-- > 0)\n\t\tsum += *buff++ ;\n\twhile (sum >> 32)\n\t\tsum = (sum & 0xFFFFFFFF) +  (sum >> 32) ;\n\n\treturn ~sum;\n}\n\nint\nnetxen_setup_minidump(struct netxen_adapter *adapter)\n{\n\tint err = 0, i;\n\tu32 *template, *tmp_buf;\n\terr = netxen_get_minidump_template_size(adapter);\n\tif (err) {\n\t\tadapter->mdump.fw_supports_md = 0;\n\t\tif ((err == NX_RCODE_CMD_INVALID) ||\n\t\t\t(err == NX_RCODE_CMD_NOT_IMPL)) {\n\t\t\tdev_info(&adapter->pdev->dev,\n\t\t\t\t\"Flashed firmware version does not support minidump, minimum version required is [ %u.%u.%u ]\\n\",\n\t\t\t\tNX_MD_SUPPORT_MAJOR, NX_MD_SUPPORT_MINOR,\n\t\t\t\tNX_MD_SUPPORT_SUBVERSION);\n\t\t}\n\t\treturn err;\n\t}\n\n\tif (!adapter->mdump.md_template_size) {\n\t\tdev_err(&adapter->pdev->dev, \"Error : Invalid template size \"\n\t\t\",should be non-zero.\\n\");\n\t\treturn -EIO;\n\t}\n\tadapter->mdump.md_template =\n\t\tkmalloc(adapter->mdump.md_template_size, GFP_KERNEL);\n\n\tif (!adapter->mdump.md_template)\n\t\treturn -ENOMEM;\n\n\terr = netxen_get_minidump_template(adapter);\n\tif (err) {\n\t\tif (err == NX_RCODE_CMD_NOT_IMPL)\n\t\t\tadapter->mdump.fw_supports_md = 0;\n\t\tgoto free_template;\n\t}\n\n\tif (netxen_check_template_checksum(adapter)) {\n\t\tdev_err(&adapter->pdev->dev, \"Minidump template checksum Error\\n\");\n\t\terr = -EIO;\n\t\tgoto free_template;\n\t}\n\n\tadapter->mdump.md_capture_mask = NX_DUMP_MASK_DEF;\n\ttmp_buf = (u32 *) adapter->mdump.md_template;\n\ttemplate = (u32 *) adapter->mdump.md_template;\n\tfor (i = 0; i < adapter->mdump.md_template_size/sizeof(u32); i++)\n\t\t*template++ = __le32_to_cpu(*tmp_buf++);\n\tadapter->mdump.md_capture_buff = NULL;\n\tadapter->mdump.fw_supports_md = 1;\n\tadapter->mdump.md_enabled = 0;\n\n\treturn err;\n\nfree_template:\n\tkfree(adapter->mdump.md_template);\n\tadapter->mdump.md_template = NULL;\n\treturn err;\n}\n\n\nint\nnx_fw_cmd_set_mtu(struct netxen_adapter *adapter, int mtu)\n{\n\tu32 rcode = NX_RCODE_SUCCESS;\n\tstruct netxen_recv_context *recv_ctx = &adapter->recv_ctx;\n\tstruct netxen_cmd_args cmd;\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.req.cmd = NX_CDRP_CMD_SET_MTU;\n\tcmd.req.arg1 = recv_ctx->context_id;\n\tcmd.req.arg2 = mtu;\n\tcmd.req.arg3 = 0;\n\n\tif (recv_ctx->state == NX_HOST_CTX_STATE_ACTIVE)\n\t\trcode = netxen_issue_cmd(adapter, &cmd);\n\n\tif (rcode != NX_RCODE_SUCCESS)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nint\nnx_fw_cmd_set_gbe_port(struct netxen_adapter *adapter,\n\t\t\tu32 speed, u32 duplex, u32 autoneg)\n{\n\tstruct netxen_cmd_args cmd;\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.req.cmd = NX_CDRP_CMD_CONFIG_GBE_PORT;\n\tcmd.req.arg1 = speed;\n\tcmd.req.arg2 = duplex;\n\tcmd.req.arg3 = autoneg;\n\treturn netxen_issue_cmd(adapter, &cmd);\n}\n\nstatic int\nnx_fw_cmd_create_rx_ctx(struct netxen_adapter *adapter)\n{\n\tvoid *addr;\n\tnx_hostrq_rx_ctx_t *prq;\n\tnx_cardrsp_rx_ctx_t *prsp;\n\tnx_hostrq_rds_ring_t *prq_rds;\n\tnx_hostrq_sds_ring_t *prq_sds;\n\tnx_cardrsp_rds_ring_t *prsp_rds;\n\tnx_cardrsp_sds_ring_t *prsp_sds;\n\tstruct nx_host_rds_ring *rds_ring;\n\tstruct nx_host_sds_ring *sds_ring;\n\tstruct netxen_cmd_args cmd;\n\n\tdma_addr_t hostrq_phys_addr, cardrsp_phys_addr;\n\tu64 phys_addr;\n\n\tint i, nrds_rings, nsds_rings;\n\tsize_t rq_size, rsp_size;\n\tu32 cap, reg, val;\n\n\tint err;\n\n\tstruct netxen_recv_context *recv_ctx = &adapter->recv_ctx;\n\n\tnrds_rings = adapter->max_rds_rings;\n\tnsds_rings = adapter->max_sds_rings;\n\n\trq_size =\n\t\tSIZEOF_HOSTRQ_RX(nx_hostrq_rx_ctx_t, nrds_rings, nsds_rings);\n\trsp_size =\n\t\tSIZEOF_CARDRSP_RX(nx_cardrsp_rx_ctx_t, nrds_rings, nsds_rings);\n\n\taddr = dma_alloc_coherent(&adapter->pdev->dev, rq_size,\n\t\t\t\t  &hostrq_phys_addr, GFP_KERNEL);\n\tif (addr == NULL)\n\t\treturn -ENOMEM;\n\tprq = addr;\n\n\taddr = dma_alloc_coherent(&adapter->pdev->dev, rsp_size,\n\t\t\t\t  &cardrsp_phys_addr, GFP_KERNEL);\n\tif (addr == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto out_free_rq;\n\t}\n\tprsp = addr;\n\n\tprq->host_rsp_dma_addr = cpu_to_le64(cardrsp_phys_addr);\n\n\tcap = (NX_CAP0_LEGACY_CONTEXT | NX_CAP0_LEGACY_MN);\n\tcap |= (NX_CAP0_JUMBO_CONTIGUOUS | NX_CAP0_LRO_CONTIGUOUS);\n\n\tif (adapter->flags & NETXEN_FW_MSS_CAP)\n\t\tcap |= NX_CAP0_HW_LRO_MSS;\n\n\tprq->capabilities[0] = cpu_to_le32(cap);\n\tprq->host_int_crb_mode =\n\t\tcpu_to_le32(NX_HOST_INT_CRB_MODE_SHARED);\n\tprq->host_rds_crb_mode =\n\t\tcpu_to_le32(NX_HOST_RDS_CRB_MODE_UNIQUE);\n\n\tprq->num_rds_rings = cpu_to_le16(nrds_rings);\n\tprq->num_sds_rings = cpu_to_le16(nsds_rings);\n\tprq->rds_ring_offset = cpu_to_le32(0);\n\n\tval = le32_to_cpu(prq->rds_ring_offset) +\n\t\t(sizeof(nx_hostrq_rds_ring_t) * nrds_rings);\n\tprq->sds_ring_offset = cpu_to_le32(val);\n\n\tprq_rds = (nx_hostrq_rds_ring_t *)(prq->data +\n\t\t\tle32_to_cpu(prq->rds_ring_offset));\n\n\tfor (i = 0; i < nrds_rings; i++) {\n\n\t\trds_ring = &recv_ctx->rds_rings[i];\n\n\t\tprq_rds[i].host_phys_addr = cpu_to_le64(rds_ring->phys_addr);\n\t\tprq_rds[i].ring_size = cpu_to_le32(rds_ring->num_desc);\n\t\tprq_rds[i].ring_kind = cpu_to_le32(i);\n\t\tprq_rds[i].buff_size = cpu_to_le64(rds_ring->dma_size);\n\t}\n\n\tprq_sds = (nx_hostrq_sds_ring_t *)(prq->data +\n\t\t\tle32_to_cpu(prq->sds_ring_offset));\n\n\tfor (i = 0; i < nsds_rings; i++) {\n\n\t\tsds_ring = &recv_ctx->sds_rings[i];\n\n\t\tprq_sds[i].host_phys_addr = cpu_to_le64(sds_ring->phys_addr);\n\t\tprq_sds[i].ring_size = cpu_to_le32(sds_ring->num_desc);\n\t\tprq_sds[i].msi_index = cpu_to_le16(i);\n\t}\n\n\tphys_addr = hostrq_phys_addr;\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.req.arg1 = (u32)(phys_addr >> 32);\n\tcmd.req.arg2 = (u32)(phys_addr & 0xffffffff);\n\tcmd.req.arg3 = rq_size;\n\tcmd.req.cmd = NX_CDRP_CMD_CREATE_RX_CTX;\n\terr = netxen_issue_cmd(adapter, &cmd);\n\tif (err) {\n\t\tprintk(KERN_WARNING\n\t\t\t\"Failed to create rx ctx in firmware%d\\n\", err);\n\t\tgoto out_free_rsp;\n\t}\n\n\n\tprsp_rds = ((nx_cardrsp_rds_ring_t *)\n\t\t\t &prsp->data[le32_to_cpu(prsp->rds_ring_offset)]);\n\n\tfor (i = 0; i < le16_to_cpu(prsp->num_rds_rings); i++) {\n\t\trds_ring = &recv_ctx->rds_rings[i];\n\n\t\treg = le32_to_cpu(prsp_rds[i].host_producer_crb);\n\t\trds_ring->crb_rcv_producer = netxen_get_ioaddr(adapter,\n\t\t\t\tNETXEN_NIC_REG(reg - 0x200));\n\t}\n\n\tprsp_sds = ((nx_cardrsp_sds_ring_t *)\n\t\t\t&prsp->data[le32_to_cpu(prsp->sds_ring_offset)]);\n\n\tfor (i = 0; i < le16_to_cpu(prsp->num_sds_rings); i++) {\n\t\tsds_ring = &recv_ctx->sds_rings[i];\n\n\t\treg = le32_to_cpu(prsp_sds[i].host_consumer_crb);\n\t\tsds_ring->crb_sts_consumer = netxen_get_ioaddr(adapter,\n\t\t\t\tNETXEN_NIC_REG(reg - 0x200));\n\n\t\treg = le32_to_cpu(prsp_sds[i].interrupt_crb);\n\t\tsds_ring->crb_intr_mask = netxen_get_ioaddr(adapter,\n\t\t\t\tNETXEN_NIC_REG(reg - 0x200));\n\t}\n\n\trecv_ctx->state = le32_to_cpu(prsp->host_ctx_state);\n\trecv_ctx->context_id = le16_to_cpu(prsp->context_id);\n\trecv_ctx->virt_port = prsp->virt_port;\n\nout_free_rsp:\n\tdma_free_coherent(&adapter->pdev->dev, rsp_size, prsp,\n\t\t\t  cardrsp_phys_addr);\nout_free_rq:\n\tdma_free_coherent(&adapter->pdev->dev, rq_size, prq, hostrq_phys_addr);\n\treturn err;\n}\n\nstatic void\nnx_fw_cmd_destroy_rx_ctx(struct netxen_adapter *adapter)\n{\n\tstruct netxen_recv_context *recv_ctx = &adapter->recv_ctx;\n\tstruct netxen_cmd_args cmd;\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.req.arg1 = recv_ctx->context_id;\n\tcmd.req.arg2 = NX_DESTROY_CTX_RESET;\n\tcmd.req.arg3 = 0;\n\tcmd.req.cmd = NX_CDRP_CMD_DESTROY_RX_CTX;\n\n\tif (netxen_issue_cmd(adapter, &cmd)) {\n\t\tprintk(KERN_WARNING\n\t\t\t\"%s: Failed to destroy rx ctx in firmware\\n\",\n\t\t\tnetxen_nic_driver_name);\n\t}\n}\n\nstatic int\nnx_fw_cmd_create_tx_ctx(struct netxen_adapter *adapter)\n{\n\tnx_hostrq_tx_ctx_t\t*prq;\n\tnx_hostrq_cds_ring_t\t*prq_cds;\n\tnx_cardrsp_tx_ctx_t\t*prsp;\n\tvoid\t*rq_addr, *rsp_addr;\n\tsize_t\trq_size, rsp_size;\n\tu32\ttemp;\n\tint\terr = 0;\n\tu64\toffset, phys_addr;\n\tdma_addr_t\trq_phys_addr, rsp_phys_addr;\n\tstruct nx_host_tx_ring *tx_ring = adapter->tx_ring;\n\tstruct netxen_recv_context *recv_ctx = &adapter->recv_ctx;\n\tstruct netxen_cmd_args cmd;\n\n\trq_size = SIZEOF_HOSTRQ_TX(nx_hostrq_tx_ctx_t);\n\trq_addr = dma_alloc_coherent(&adapter->pdev->dev, rq_size,\n\t\t\t\t     &rq_phys_addr, GFP_KERNEL);\n\tif (!rq_addr)\n\t\treturn -ENOMEM;\n\n\trsp_size = SIZEOF_CARDRSP_TX(nx_cardrsp_tx_ctx_t);\n\trsp_addr = dma_alloc_coherent(&adapter->pdev->dev, rsp_size,\n\t\t\t\t      &rsp_phys_addr, GFP_KERNEL);\n\tif (!rsp_addr) {\n\t\terr = -ENOMEM;\n\t\tgoto out_free_rq;\n\t}\n\n\tprq = rq_addr;\n\n\tprsp = rsp_addr;\n\n\tprq->host_rsp_dma_addr = cpu_to_le64(rsp_phys_addr);\n\n\ttemp = (NX_CAP0_LEGACY_CONTEXT | NX_CAP0_LEGACY_MN | NX_CAP0_LSO);\n\tprq->capabilities[0] = cpu_to_le32(temp);\n\n\tprq->host_int_crb_mode =\n\t\tcpu_to_le32(NX_HOST_INT_CRB_MODE_SHARED);\n\n\tprq->interrupt_ctl = 0;\n\tprq->msi_index = 0;\n\n\tprq->dummy_dma_addr = cpu_to_le64(adapter->dummy_dma.phys_addr);\n\n\toffset = recv_ctx->phys_addr + sizeof(struct netxen_ring_ctx);\n\tprq->cmd_cons_dma_addr = cpu_to_le64(offset);\n\n\tprq_cds = &prq->cds_ring;\n\n\tprq_cds->host_phys_addr = cpu_to_le64(tx_ring->phys_addr);\n\tprq_cds->ring_size = cpu_to_le32(tx_ring->num_desc);\n\n\tphys_addr = rq_phys_addr;\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.req.arg1 = (u32)(phys_addr >> 32);\n\tcmd.req.arg2 = ((u32)phys_addr & 0xffffffff);\n\tcmd.req.arg3 = rq_size;\n\tcmd.req.cmd = NX_CDRP_CMD_CREATE_TX_CTX;\n\terr = netxen_issue_cmd(adapter, &cmd);\n\n\tif (err == NX_RCODE_SUCCESS) {\n\t\ttemp = le32_to_cpu(prsp->cds_ring.host_producer_crb);\n\t\ttx_ring->crb_cmd_producer = netxen_get_ioaddr(adapter,\n\t\t\t\tNETXEN_NIC_REG(temp - 0x200));\n#if 0\n\t\tadapter->tx_state =\n\t\t\tle32_to_cpu(prsp->host_ctx_state);\n#endif\n\t\tadapter->tx_context_id =\n\t\t\tle16_to_cpu(prsp->context_id);\n\t} else {\n\t\tprintk(KERN_WARNING\n\t\t\t\"Failed to create tx ctx in firmware%d\\n\", err);\n\t\terr = -EIO;\n\t}\n\n\tdma_free_coherent(&adapter->pdev->dev, rsp_size, rsp_addr,\n\t\t\t  rsp_phys_addr);\n\nout_free_rq:\n\tdma_free_coherent(&adapter->pdev->dev, rq_size, rq_addr, rq_phys_addr);\n\n\treturn err;\n}\n\nstatic void\nnx_fw_cmd_destroy_tx_ctx(struct netxen_adapter *adapter)\n{\n\tstruct netxen_cmd_args cmd;\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.req.arg1 = adapter->tx_context_id;\n\tcmd.req.arg2 = NX_DESTROY_CTX_RESET;\n\tcmd.req.arg3 = 0;\n\tcmd.req.cmd = NX_CDRP_CMD_DESTROY_TX_CTX;\n\tif (netxen_issue_cmd(adapter, &cmd)) {\n\t\tprintk(KERN_WARNING\n\t\t\t\"%s: Failed to destroy tx ctx in firmware\\n\",\n\t\t\tnetxen_nic_driver_name);\n\t}\n}\n\nint\nnx_fw_cmd_query_phy(struct netxen_adapter *adapter, u32 reg, u32 *val)\n{\n\tu32 rcode;\n\tstruct netxen_cmd_args cmd;\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.req.arg1 = reg;\n\tcmd.req.arg2 = 0;\n\tcmd.req.arg3 = 0;\n\tcmd.req.cmd = NX_CDRP_CMD_READ_PHY;\n\tcmd.rsp.arg1 = 1;\n\trcode = netxen_issue_cmd(adapter, &cmd);\n\tif (rcode != NX_RCODE_SUCCESS)\n\t\treturn -EIO;\n\n\tif (val == NULL)\n\t\treturn -EIO;\n\n\t*val = cmd.rsp.arg1;\n\treturn 0;\n}\n\nint\nnx_fw_cmd_set_phy(struct netxen_adapter *adapter, u32 reg, u32 val)\n{\n\tu32 rcode;\n\tstruct netxen_cmd_args cmd;\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.req.arg1 = reg;\n\tcmd.req.arg2 = val;\n\tcmd.req.arg3 = 0;\n\tcmd.req.cmd = NX_CDRP_CMD_WRITE_PHY;\n\trcode = netxen_issue_cmd(adapter, &cmd);\n\tif (rcode != NX_RCODE_SUCCESS)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic u64 ctx_addr_sig_regs[][3] = {\n\t{NETXEN_NIC_REG(0x188), NETXEN_NIC_REG(0x18c), NETXEN_NIC_REG(0x1c0)},\n\t{NETXEN_NIC_REG(0x190), NETXEN_NIC_REG(0x194), NETXEN_NIC_REG(0x1c4)},\n\t{NETXEN_NIC_REG(0x198), NETXEN_NIC_REG(0x19c), NETXEN_NIC_REG(0x1c8)},\n\t{NETXEN_NIC_REG(0x1a0), NETXEN_NIC_REG(0x1a4), NETXEN_NIC_REG(0x1cc)}\n};\n\n#define CRB_CTX_ADDR_REG_LO(FUNC_ID)\t(ctx_addr_sig_regs[FUNC_ID][0])\n#define CRB_CTX_ADDR_REG_HI(FUNC_ID)\t(ctx_addr_sig_regs[FUNC_ID][2])\n#define CRB_CTX_SIGNATURE_REG(FUNC_ID)\t(ctx_addr_sig_regs[FUNC_ID][1])\n\n#define lower32(x)\t((u32)((x) & 0xffffffff))\n#define upper32(x)\t((u32)(((u64)(x) >> 32) & 0xffffffff))\n\nstatic struct netxen_recv_crb recv_crb_registers[] = {\n\t \n\t{\n\t\t \n\t\t{\n\t\t\tNETXEN_NIC_REG(0x100),\n\t\t\t \n\t\t\tNETXEN_NIC_REG(0x110),\n\t\t\t \n\t\t\tNETXEN_NIC_REG(0x120)\n\t\t},\n\t\t \n\t\t{\n\t\t\tNETXEN_NIC_REG(0x138),\n\t\t\tNETXEN_NIC_REG_2(0x000),\n\t\t\tNETXEN_NIC_REG_2(0x004),\n\t\t\tNETXEN_NIC_REG_2(0x008),\n\t\t},\n\t\t \n\t\t{\n\t\t\tCRB_SW_INT_MASK_0,\n\t\t\tNETXEN_NIC_REG_2(0x044),\n\t\t\tNETXEN_NIC_REG_2(0x048),\n\t\t\tNETXEN_NIC_REG_2(0x04c),\n\t\t},\n\t},\n\t \n\t{\n\t\t \n\t\t{\n\t\t\tNETXEN_NIC_REG(0x144),\n\t\t\t \n\t\t\tNETXEN_NIC_REG(0x154),\n\t\t\t \n\t\t\tNETXEN_NIC_REG(0x164)\n\t\t},\n\t\t \n\t\t{\n\t\t\tNETXEN_NIC_REG(0x17c),\n\t\t\tNETXEN_NIC_REG_2(0x020),\n\t\t\tNETXEN_NIC_REG_2(0x024),\n\t\t\tNETXEN_NIC_REG_2(0x028),\n\t\t},\n\t\t \n\t\t{\n\t\t\tCRB_SW_INT_MASK_1,\n\t\t\tNETXEN_NIC_REG_2(0x064),\n\t\t\tNETXEN_NIC_REG_2(0x068),\n\t\t\tNETXEN_NIC_REG_2(0x06c),\n\t\t},\n\t},\n\t \n\t{\n\t\t \n\t\t{\n\t\t\tNETXEN_NIC_REG(0x1d8),\n\t\t\t \n\t\t\tNETXEN_NIC_REG(0x1f8),\n\t\t\t \n\t\t\tNETXEN_NIC_REG(0x208)\n\t\t},\n\t\t \n\t\t{\n\t\t\tNETXEN_NIC_REG(0x220),\n\t\t\tNETXEN_NIC_REG_2(0x03c),\n\t\t\tNETXEN_NIC_REG_2(0x03c),\n\t\t\tNETXEN_NIC_REG_2(0x03c),\n\t\t},\n\t\t \n\t\t{\n\t\t\tCRB_SW_INT_MASK_2,\n\t\t\tNETXEN_NIC_REG_2(0x03c),\n\t\t\tNETXEN_NIC_REG_2(0x03c),\n\t\t\tNETXEN_NIC_REG_2(0x03c),\n\t\t},\n\t},\n\t \n\t{\n\t\t \n\t\t{\n\t\t\tNETXEN_NIC_REG(0x22c),\n\t\t\t \n\t\t\tNETXEN_NIC_REG(0x23c),\n\t\t\t \n\t\t\tNETXEN_NIC_REG(0x24c)\n\t\t},\n\t\t \n\t\t{\n\t\t\tNETXEN_NIC_REG(0x264),\n\t\t\tNETXEN_NIC_REG_2(0x03c),\n\t\t\tNETXEN_NIC_REG_2(0x03c),\n\t\t\tNETXEN_NIC_REG_2(0x03c),\n\t\t},\n\t\t \n\t\t{\n\t\t\tCRB_SW_INT_MASK_3,\n\t\t\tNETXEN_NIC_REG_2(0x03c),\n\t\t\tNETXEN_NIC_REG_2(0x03c),\n\t\t\tNETXEN_NIC_REG_2(0x03c),\n\t\t},\n\t},\n};\n\nstatic int\nnetxen_init_old_ctx(struct netxen_adapter *adapter)\n{\n\tstruct netxen_recv_context *recv_ctx;\n\tstruct nx_host_rds_ring *rds_ring;\n\tstruct nx_host_sds_ring *sds_ring;\n\tstruct nx_host_tx_ring *tx_ring;\n\tint ring;\n\tint port = adapter->portnum;\n\tstruct netxen_ring_ctx *hwctx;\n\tu32 signature;\n\n\ttx_ring = adapter->tx_ring;\n\trecv_ctx = &adapter->recv_ctx;\n\thwctx = recv_ctx->hwctx;\n\n\thwctx->cmd_ring_addr = cpu_to_le64(tx_ring->phys_addr);\n\thwctx->cmd_ring_size = cpu_to_le32(tx_ring->num_desc);\n\n\n\tfor (ring = 0; ring < adapter->max_rds_rings; ring++) {\n\t\trds_ring = &recv_ctx->rds_rings[ring];\n\n\t\thwctx->rcv_rings[ring].addr =\n\t\t\tcpu_to_le64(rds_ring->phys_addr);\n\t\thwctx->rcv_rings[ring].size =\n\t\t\tcpu_to_le32(rds_ring->num_desc);\n\t}\n\n\tfor (ring = 0; ring < adapter->max_sds_rings; ring++) {\n\t\tsds_ring = &recv_ctx->sds_rings[ring];\n\n\t\tif (ring == 0) {\n\t\t\thwctx->sts_ring_addr = cpu_to_le64(sds_ring->phys_addr);\n\t\t\thwctx->sts_ring_size = cpu_to_le32(sds_ring->num_desc);\n\t\t}\n\t\thwctx->sts_rings[ring].addr = cpu_to_le64(sds_ring->phys_addr);\n\t\thwctx->sts_rings[ring].size = cpu_to_le32(sds_ring->num_desc);\n\t\thwctx->sts_rings[ring].msi_index = cpu_to_le16(ring);\n\t}\n\thwctx->sts_ring_count = cpu_to_le32(adapter->max_sds_rings);\n\n\tsignature = (adapter->max_sds_rings > 1) ?\n\t\tNETXEN_CTX_SIGNATURE_V2 : NETXEN_CTX_SIGNATURE;\n\n\tNXWR32(adapter, CRB_CTX_ADDR_REG_LO(port),\n\t\t\tlower32(recv_ctx->phys_addr));\n\tNXWR32(adapter, CRB_CTX_ADDR_REG_HI(port),\n\t\t\tupper32(recv_ctx->phys_addr));\n\tNXWR32(adapter, CRB_CTX_SIGNATURE_REG(port),\n\t\t\tsignature | port);\n\treturn 0;\n}\n\nint netxen_alloc_hw_resources(struct netxen_adapter *adapter)\n{\n\tvoid *addr;\n\tint err = 0;\n\tint ring;\n\tstruct netxen_recv_context *recv_ctx;\n\tstruct nx_host_rds_ring *rds_ring;\n\tstruct nx_host_sds_ring *sds_ring;\n\tstruct nx_host_tx_ring *tx_ring;\n\n\tstruct pci_dev *pdev = adapter->pdev;\n\tstruct net_device *netdev = adapter->netdev;\n\tint port = adapter->portnum;\n\n\trecv_ctx = &adapter->recv_ctx;\n\ttx_ring = adapter->tx_ring;\n\n\taddr = dma_alloc_coherent(&pdev->dev,\n\t\t\t\t  sizeof(struct netxen_ring_ctx) + sizeof(uint32_t),\n\t\t\t\t  &recv_ctx->phys_addr, GFP_KERNEL);\n\tif (addr == NULL) {\n\t\tdev_err(&pdev->dev, \"failed to allocate hw context\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\trecv_ctx->hwctx = addr;\n\trecv_ctx->hwctx->ctx_id = cpu_to_le32(port);\n\trecv_ctx->hwctx->cmd_consumer_offset =\n\t\tcpu_to_le64(recv_ctx->phys_addr +\n\t\t\tsizeof(struct netxen_ring_ctx));\n\ttx_ring->hw_consumer =\n\t\t(__le32 *)(((char *)addr) + sizeof(struct netxen_ring_ctx));\n\n\t \n\taddr = dma_alloc_coherent(&pdev->dev, TX_DESC_RINGSIZE(tx_ring),\n\t\t\t\t  &tx_ring->phys_addr, GFP_KERNEL);\n\n\tif (addr == NULL) {\n\t\tdev_err(&pdev->dev, \"%s: failed to allocate tx desc ring\\n\",\n\t\t\t\tnetdev->name);\n\t\terr = -ENOMEM;\n\t\tgoto err_out_free;\n\t}\n\n\ttx_ring->desc_head = addr;\n\n\tfor (ring = 0; ring < adapter->max_rds_rings; ring++) {\n\t\trds_ring = &recv_ctx->rds_rings[ring];\n\t\taddr = dma_alloc_coherent(&adapter->pdev->dev,\n\t\t\t\t\t  RCV_DESC_RINGSIZE(rds_ring),\n\t\t\t\t\t  &rds_ring->phys_addr, GFP_KERNEL);\n\t\tif (addr == NULL) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"%s: failed to allocate rds ring [%d]\\n\",\n\t\t\t\tnetdev->name, ring);\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_out_free;\n\t\t}\n\t\trds_ring->desc_head = addr;\n\n\t\tif (NX_IS_REVISION_P2(adapter->ahw.revision_id))\n\t\t\trds_ring->crb_rcv_producer =\n\t\t\t\tnetxen_get_ioaddr(adapter,\n\t\t\trecv_crb_registers[port].crb_rcv_producer[ring]);\n\t}\n\n\tfor (ring = 0; ring < adapter->max_sds_rings; ring++) {\n\t\tsds_ring = &recv_ctx->sds_rings[ring];\n\n\t\taddr = dma_alloc_coherent(&adapter->pdev->dev,\n\t\t\t\t\t  STATUS_DESC_RINGSIZE(sds_ring),\n\t\t\t\t\t  &sds_ring->phys_addr, GFP_KERNEL);\n\t\tif (addr == NULL) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"%s: failed to allocate sds ring [%d]\\n\",\n\t\t\t\tnetdev->name, ring);\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_out_free;\n\t\t}\n\t\tsds_ring->desc_head = addr;\n\n\t\tif (NX_IS_REVISION_P2(adapter->ahw.revision_id)) {\n\t\t\tsds_ring->crb_sts_consumer =\n\t\t\t\tnetxen_get_ioaddr(adapter,\n\t\t\t\trecv_crb_registers[port].crb_sts_consumer[ring]);\n\n\t\t\tsds_ring->crb_intr_mask =\n\t\t\t\tnetxen_get_ioaddr(adapter,\n\t\t\t\trecv_crb_registers[port].sw_int_mask[ring]);\n\t\t}\n\t}\n\n\n\tif (!NX_IS_REVISION_P2(adapter->ahw.revision_id)) {\n\t\tif (test_and_set_bit(__NX_FW_ATTACHED, &adapter->state))\n\t\t\tgoto done;\n\t\terr = nx_fw_cmd_create_rx_ctx(adapter);\n\t\tif (err)\n\t\t\tgoto err_out_free;\n\t\terr = nx_fw_cmd_create_tx_ctx(adapter);\n\t\tif (err)\n\t\t\tgoto err_out_free;\n\t} else {\n\t\terr = netxen_init_old_ctx(adapter);\n\t\tif (err)\n\t\t\tgoto err_out_free;\n\t}\n\ndone:\n\treturn 0;\n\nerr_out_free:\n\tnetxen_free_hw_resources(adapter);\n\treturn err;\n}\n\nvoid netxen_free_hw_resources(struct netxen_adapter *adapter)\n{\n\tstruct netxen_recv_context *recv_ctx;\n\tstruct nx_host_rds_ring *rds_ring;\n\tstruct nx_host_sds_ring *sds_ring;\n\tstruct nx_host_tx_ring *tx_ring;\n\tint ring;\n\n\tint port = adapter->portnum;\n\n\tif (!NX_IS_REVISION_P2(adapter->ahw.revision_id)) {\n\t\tif (!test_and_clear_bit(__NX_FW_ATTACHED, &adapter->state))\n\t\t\tgoto done;\n\n\t\tnx_fw_cmd_destroy_rx_ctx(adapter);\n\t\tnx_fw_cmd_destroy_tx_ctx(adapter);\n\t} else {\n\t\tnetxen_api_lock(adapter);\n\t\tNXWR32(adapter, CRB_CTX_SIGNATURE_REG(port),\n\t\t\t\tNETXEN_CTX_D3_RESET | port);\n\t\tnetxen_api_unlock(adapter);\n\t}\n\n\t \n\tmsleep(20);\n\ndone:\n\trecv_ctx = &adapter->recv_ctx;\n\n\tif (recv_ctx->hwctx != NULL) {\n\t\tdma_free_coherent(&adapter->pdev->dev,\n\t\t\t\t  sizeof(struct netxen_ring_ctx) + sizeof(uint32_t),\n\t\t\t\t  recv_ctx->hwctx, recv_ctx->phys_addr);\n\t\trecv_ctx->hwctx = NULL;\n\t}\n\n\ttx_ring = adapter->tx_ring;\n\tif (tx_ring->desc_head != NULL) {\n\t\tdma_free_coherent(&adapter->pdev->dev,\n\t\t\t\t  TX_DESC_RINGSIZE(tx_ring),\n\t\t\t\t  tx_ring->desc_head, tx_ring->phys_addr);\n\t\ttx_ring->desc_head = NULL;\n\t}\n\n\tfor (ring = 0; ring < adapter->max_rds_rings; ring++) {\n\t\trds_ring = &recv_ctx->rds_rings[ring];\n\n\t\tif (rds_ring->desc_head != NULL) {\n\t\t\tdma_free_coherent(&adapter->pdev->dev,\n\t\t\t\t\t  RCV_DESC_RINGSIZE(rds_ring),\n\t\t\t\t\t  rds_ring->desc_head,\n\t\t\t\t\t  rds_ring->phys_addr);\n\t\t\trds_ring->desc_head = NULL;\n\t\t}\n\t}\n\n\tfor (ring = 0; ring < adapter->max_sds_rings; ring++) {\n\t\tsds_ring = &recv_ctx->sds_rings[ring];\n\n\t\tif (sds_ring->desc_head != NULL) {\n\t\t\tdma_free_coherent(&adapter->pdev->dev,\n\t\t\t\t\t  STATUS_DESC_RINGSIZE(sds_ring),\n\t\t\t\t\t  sds_ring->desc_head,\n\t\t\t\t\t  sds_ring->phys_addr);\n\t\t\tsds_ring->desc_head = NULL;\n\t\t}\n\t}\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}