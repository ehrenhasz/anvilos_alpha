{
  "module_name": "netxen_nic_init.c",
  "hash_id": "67bc8eb71094aff05b5f03a08cbb7ed0d1842f691a128d06a0a16929563f22cf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/qlogic/netxen/netxen_nic_init.c",
  "human_readable_source": "\n \n\n#include <linux/netdevice.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/if_vlan.h>\n#include <net/checksum.h>\n#include \"netxen_nic.h\"\n#include \"netxen_nic_hw.h\"\n\nstruct crb_addr_pair {\n\tu32 addr;\n\tu32 data;\n};\n\n#define NETXEN_MAX_CRB_XFORM 60\nstatic unsigned int crb_addr_xform[NETXEN_MAX_CRB_XFORM];\n#define NETXEN_ADDR_ERROR (0xffffffff)\n\n#define crb_addr_transform(name) \\\n\tcrb_addr_xform[NETXEN_HW_PX_MAP_CRB_##name] = \\\n\tNETXEN_HW_CRB_HUB_AGT_ADR_##name << 20\n\n#define NETXEN_NIC_XDMA_RESET 0x8000ff\n\nstatic void\nnetxen_post_rx_buffers_nodb(struct netxen_adapter *adapter,\n\t\tstruct nx_host_rds_ring *rds_ring);\nstatic int netxen_p3_has_mn(struct netxen_adapter *adapter);\n\nstatic void crb_addr_transform_setup(void)\n{\n\tcrb_addr_transform(XDMA);\n\tcrb_addr_transform(TIMR);\n\tcrb_addr_transform(SRE);\n\tcrb_addr_transform(SQN3);\n\tcrb_addr_transform(SQN2);\n\tcrb_addr_transform(SQN1);\n\tcrb_addr_transform(SQN0);\n\tcrb_addr_transform(SQS3);\n\tcrb_addr_transform(SQS2);\n\tcrb_addr_transform(SQS1);\n\tcrb_addr_transform(SQS0);\n\tcrb_addr_transform(RPMX7);\n\tcrb_addr_transform(RPMX6);\n\tcrb_addr_transform(RPMX5);\n\tcrb_addr_transform(RPMX4);\n\tcrb_addr_transform(RPMX3);\n\tcrb_addr_transform(RPMX2);\n\tcrb_addr_transform(RPMX1);\n\tcrb_addr_transform(RPMX0);\n\tcrb_addr_transform(ROMUSB);\n\tcrb_addr_transform(SN);\n\tcrb_addr_transform(QMN);\n\tcrb_addr_transform(QMS);\n\tcrb_addr_transform(PGNI);\n\tcrb_addr_transform(PGND);\n\tcrb_addr_transform(PGN3);\n\tcrb_addr_transform(PGN2);\n\tcrb_addr_transform(PGN1);\n\tcrb_addr_transform(PGN0);\n\tcrb_addr_transform(PGSI);\n\tcrb_addr_transform(PGSD);\n\tcrb_addr_transform(PGS3);\n\tcrb_addr_transform(PGS2);\n\tcrb_addr_transform(PGS1);\n\tcrb_addr_transform(PGS0);\n\tcrb_addr_transform(PS);\n\tcrb_addr_transform(PH);\n\tcrb_addr_transform(NIU);\n\tcrb_addr_transform(I2Q);\n\tcrb_addr_transform(EG);\n\tcrb_addr_transform(MN);\n\tcrb_addr_transform(MS);\n\tcrb_addr_transform(CAS2);\n\tcrb_addr_transform(CAS1);\n\tcrb_addr_transform(CAS0);\n\tcrb_addr_transform(CAM);\n\tcrb_addr_transform(C2C1);\n\tcrb_addr_transform(C2C0);\n\tcrb_addr_transform(SMB);\n\tcrb_addr_transform(OCM0);\n\tcrb_addr_transform(I2C0);\n}\n\nvoid netxen_release_rx_buffers(struct netxen_adapter *adapter)\n{\n\tstruct netxen_recv_context *recv_ctx;\n\tstruct nx_host_rds_ring *rds_ring;\n\tstruct netxen_rx_buffer *rx_buf;\n\tint i, ring;\n\n\trecv_ctx = &adapter->recv_ctx;\n\tfor (ring = 0; ring < adapter->max_rds_rings; ring++) {\n\t\trds_ring = &recv_ctx->rds_rings[ring];\n\t\tfor (i = 0; i < rds_ring->num_desc; ++i) {\n\t\t\trx_buf = &(rds_ring->rx_buf_arr[i]);\n\t\t\tif (rx_buf->state == NETXEN_BUFFER_FREE)\n\t\t\t\tcontinue;\n\t\t\tdma_unmap_single(&adapter->pdev->dev, rx_buf->dma,\n\t\t\t\t\t rds_ring->dma_size, DMA_FROM_DEVICE);\n\t\t\tif (rx_buf->skb != NULL)\n\t\t\t\tdev_kfree_skb_any(rx_buf->skb);\n\t\t}\n\t}\n}\n\nvoid netxen_release_tx_buffers(struct netxen_adapter *adapter)\n{\n\tstruct netxen_cmd_buffer *cmd_buf;\n\tstruct netxen_skb_frag *buffrag;\n\tint i, j;\n\tstruct nx_host_tx_ring *tx_ring = adapter->tx_ring;\n\n\tspin_lock_bh(&adapter->tx_clean_lock);\n\tcmd_buf = tx_ring->cmd_buf_arr;\n\tfor (i = 0; i < tx_ring->num_desc; i++) {\n\t\tbuffrag = cmd_buf->frag_array;\n\t\tif (buffrag->dma) {\n\t\t\tdma_unmap_single(&adapter->pdev->dev, buffrag->dma,\n\t\t\t\t\t buffrag->length, DMA_TO_DEVICE);\n\t\t\tbuffrag->dma = 0ULL;\n\t\t}\n\t\tfor (j = 1; j < cmd_buf->frag_count; j++) {\n\t\t\tbuffrag++;\n\t\t\tif (buffrag->dma) {\n\t\t\t\tdma_unmap_page(&adapter->pdev->dev,\n\t\t\t\t\t       buffrag->dma, buffrag->length,\n\t\t\t\t\t       DMA_TO_DEVICE);\n\t\t\t\tbuffrag->dma = 0ULL;\n\t\t\t}\n\t\t}\n\t\tif (cmd_buf->skb) {\n\t\t\tdev_kfree_skb_any(cmd_buf->skb);\n\t\t\tcmd_buf->skb = NULL;\n\t\t}\n\t\tcmd_buf++;\n\t}\n\tspin_unlock_bh(&adapter->tx_clean_lock);\n}\n\nvoid netxen_free_sw_resources(struct netxen_adapter *adapter)\n{\n\tstruct netxen_recv_context *recv_ctx;\n\tstruct nx_host_rds_ring *rds_ring;\n\tstruct nx_host_tx_ring *tx_ring;\n\tint ring;\n\n\trecv_ctx = &adapter->recv_ctx;\n\n\tif (recv_ctx->rds_rings == NULL)\n\t\tgoto skip_rds;\n\n\tfor (ring = 0; ring < adapter->max_rds_rings; ring++) {\n\t\trds_ring = &recv_ctx->rds_rings[ring];\n\t\tvfree(rds_ring->rx_buf_arr);\n\t\trds_ring->rx_buf_arr = NULL;\n\t}\n\tkfree(recv_ctx->rds_rings);\n\nskip_rds:\n\tif (adapter->tx_ring == NULL)\n\t\treturn;\n\n\ttx_ring = adapter->tx_ring;\n\tvfree(tx_ring->cmd_buf_arr);\n\tkfree(tx_ring);\n\tadapter->tx_ring = NULL;\n}\n\nint netxen_alloc_sw_resources(struct netxen_adapter *adapter)\n{\n\tstruct netxen_recv_context *recv_ctx;\n\tstruct nx_host_rds_ring *rds_ring;\n\tstruct nx_host_sds_ring *sds_ring;\n\tstruct nx_host_tx_ring *tx_ring;\n\tstruct netxen_rx_buffer *rx_buf;\n\tint ring, i;\n\n\tstruct netxen_cmd_buffer *cmd_buf_arr;\n\tstruct net_device *netdev = adapter->netdev;\n\n\ttx_ring = kzalloc(sizeof(struct nx_host_tx_ring), GFP_KERNEL);\n\tif (tx_ring == NULL)\n\t\treturn -ENOMEM;\n\n\tadapter->tx_ring = tx_ring;\n\n\ttx_ring->num_desc = adapter->num_txd;\n\ttx_ring->txq = netdev_get_tx_queue(netdev, 0);\n\n\tcmd_buf_arr = vzalloc(TX_BUFF_RINGSIZE(tx_ring));\n\tif (cmd_buf_arr == NULL)\n\t\tgoto err_out;\n\n\ttx_ring->cmd_buf_arr = cmd_buf_arr;\n\n\trecv_ctx = &adapter->recv_ctx;\n\n\trds_ring = kcalloc(adapter->max_rds_rings,\n\t\t\t   sizeof(struct nx_host_rds_ring), GFP_KERNEL);\n\tif (rds_ring == NULL)\n\t\tgoto err_out;\n\n\trecv_ctx->rds_rings = rds_ring;\n\n\tfor (ring = 0; ring < adapter->max_rds_rings; ring++) {\n\t\trds_ring = &recv_ctx->rds_rings[ring];\n\t\tswitch (ring) {\n\t\tcase RCV_RING_NORMAL:\n\t\t\trds_ring->num_desc = adapter->num_rxd;\n\t\t\tif (adapter->ahw.cut_through) {\n\t\t\t\trds_ring->dma_size =\n\t\t\t\t\tNX_CT_DEFAULT_RX_BUF_LEN;\n\t\t\t\trds_ring->skb_size =\n\t\t\t\t\tNX_CT_DEFAULT_RX_BUF_LEN;\n\t\t\t} else {\n\t\t\t\tif (NX_IS_REVISION_P3(adapter->ahw.revision_id))\n\t\t\t\t\trds_ring->dma_size =\n\t\t\t\t\t\tNX_P3_RX_BUF_MAX_LEN;\n\t\t\t\telse\n\t\t\t\t\trds_ring->dma_size =\n\t\t\t\t\t\tNX_P2_RX_BUF_MAX_LEN;\n\t\t\t\trds_ring->skb_size =\n\t\t\t\t\trds_ring->dma_size + NET_IP_ALIGN;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase RCV_RING_JUMBO:\n\t\t\trds_ring->num_desc = adapter->num_jumbo_rxd;\n\t\t\tif (NX_IS_REVISION_P3(adapter->ahw.revision_id))\n\t\t\t\trds_ring->dma_size =\n\t\t\t\t\tNX_P3_RX_JUMBO_BUF_MAX_LEN;\n\t\t\telse\n\t\t\t\trds_ring->dma_size =\n\t\t\t\t\tNX_P2_RX_JUMBO_BUF_MAX_LEN;\n\n\t\t\tif (adapter->capabilities & NX_CAP0_HW_LRO)\n\t\t\t\trds_ring->dma_size += NX_LRO_BUFFER_EXTRA;\n\n\t\t\trds_ring->skb_size =\n\t\t\t\trds_ring->dma_size + NET_IP_ALIGN;\n\t\t\tbreak;\n\n\t\tcase RCV_RING_LRO:\n\t\t\trds_ring->num_desc = adapter->num_lro_rxd;\n\t\t\trds_ring->dma_size = NX_RX_LRO_BUFFER_LENGTH;\n\t\t\trds_ring->skb_size = rds_ring->dma_size + NET_IP_ALIGN;\n\t\t\tbreak;\n\n\t\t}\n\t\trds_ring->rx_buf_arr = vzalloc(RCV_BUFF_RINGSIZE(rds_ring));\n\t\tif (rds_ring->rx_buf_arr == NULL)\n\t\t\t \n\t\t\tgoto err_out;\n\n\t\tINIT_LIST_HEAD(&rds_ring->free_list);\n\t\t \n\t\trx_buf = rds_ring->rx_buf_arr;\n\t\tfor (i = 0; i < rds_ring->num_desc; i++) {\n\t\t\tlist_add_tail(&rx_buf->list,\n\t\t\t\t\t&rds_ring->free_list);\n\t\t\trx_buf->ref_handle = i;\n\t\t\trx_buf->state = NETXEN_BUFFER_FREE;\n\t\t\trx_buf++;\n\t\t}\n\t\tspin_lock_init(&rds_ring->lock);\n\t}\n\n\tfor (ring = 0; ring < adapter->max_sds_rings; ring++) {\n\t\tsds_ring = &recv_ctx->sds_rings[ring];\n\t\tsds_ring->irq = adapter->msix_entries[ring].vector;\n\t\tsds_ring->adapter = adapter;\n\t\tsds_ring->num_desc = adapter->num_rxd;\n\n\t\tfor (i = 0; i < NUM_RCV_DESC_RINGS; i++)\n\t\t\tINIT_LIST_HEAD(&sds_ring->free_list[i]);\n\t}\n\n\treturn 0;\n\nerr_out:\n\tnetxen_free_sw_resources(adapter);\n\treturn -ENOMEM;\n}\n\n \nstatic u32 netxen_decode_crb_addr(u32 addr)\n{\n\tint i;\n\tu32 base_addr, offset, pci_base;\n\n\tcrb_addr_transform_setup();\n\n\tpci_base = NETXEN_ADDR_ERROR;\n\tbase_addr = addr & 0xfff00000;\n\toffset = addr & 0x000fffff;\n\n\tfor (i = 0; i < NETXEN_MAX_CRB_XFORM; i++) {\n\t\tif (crb_addr_xform[i] == base_addr) {\n\t\t\tpci_base = i << 20;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (pci_base == NETXEN_ADDR_ERROR)\n\t\treturn pci_base;\n\telse\n\t\treturn pci_base + offset;\n}\n\n#define NETXEN_MAX_ROM_WAIT_USEC\t100\n\nstatic int netxen_wait_rom_done(struct netxen_adapter *adapter)\n{\n\tlong timeout = 0;\n\tlong done = 0;\n\n\tcond_resched();\n\n\twhile (done == 0) {\n\t\tdone = NXRD32(adapter, NETXEN_ROMUSB_GLB_STATUS);\n\t\tdone &= 2;\n\t\tif (++timeout >= NETXEN_MAX_ROM_WAIT_USEC) {\n\t\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\t\"Timeout reached  waiting for rom done\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tudelay(1);\n\t}\n\treturn 0;\n}\n\nstatic int do_rom_fast_read(struct netxen_adapter *adapter,\n\t\t\t    int addr, int *valp)\n{\n\tNXWR32(adapter, NETXEN_ROMUSB_ROM_ADDRESS, addr);\n\tNXWR32(adapter, NETXEN_ROMUSB_ROM_DUMMY_BYTE_CNT, 0);\n\tNXWR32(adapter, NETXEN_ROMUSB_ROM_ABYTE_CNT, 3);\n\tNXWR32(adapter, NETXEN_ROMUSB_ROM_INSTR_OPCODE, 0xb);\n\tif (netxen_wait_rom_done(adapter)) {\n\t\tprintk(\"Error waiting for rom done\\n\");\n\t\treturn -EIO;\n\t}\n\t \n\tNXWR32(adapter, NETXEN_ROMUSB_ROM_ABYTE_CNT, 0);\n\tudelay(10);\n\tNXWR32(adapter, NETXEN_ROMUSB_ROM_DUMMY_BYTE_CNT, 0);\n\n\t*valp = NXRD32(adapter, NETXEN_ROMUSB_ROM_RDATA);\n\treturn 0;\n}\n\nstatic int do_rom_fast_read_words(struct netxen_adapter *adapter, int addr,\n\t\t\t\t  u8 *bytes, size_t size)\n{\n\tint addridx;\n\tint ret = 0;\n\n\tfor (addridx = addr; addridx < (addr + size); addridx += 4) {\n\t\tint v;\n\t\tret = do_rom_fast_read(adapter, addridx, &v);\n\t\tif (ret != 0)\n\t\t\tbreak;\n\t\t*(__le32 *)bytes = cpu_to_le32(v);\n\t\tbytes += 4;\n\t}\n\n\treturn ret;\n}\n\nint\nnetxen_rom_fast_read_words(struct netxen_adapter *adapter, int addr,\n\t\t\t\tu8 *bytes, size_t size)\n{\n\tint ret;\n\n\tret = netxen_rom_lock(adapter);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = do_rom_fast_read_words(adapter, addr, bytes, size);\n\n\tnetxen_rom_unlock(adapter);\n\treturn ret;\n}\n\nint netxen_rom_fast_read(struct netxen_adapter *adapter, int addr, int *valp)\n{\n\tint ret;\n\n\tif (netxen_rom_lock(adapter) != 0)\n\t\treturn -EIO;\n\n\tret = do_rom_fast_read(adapter, addr, valp);\n\tnetxen_rom_unlock(adapter);\n\treturn ret;\n}\n\n#define NETXEN_BOARDTYPE\t\t0x4008\n#define NETXEN_BOARDNUM \t\t0x400c\n#define NETXEN_CHIPNUM\t\t\t0x4010\n\nint netxen_pinit_from_rom(struct netxen_adapter *adapter)\n{\n\tint addr, val;\n\tint i, n, init_delay = 0;\n\tstruct crb_addr_pair *buf;\n\tunsigned offset;\n\tu32 off;\n\n\t \n\tnetxen_rom_lock(adapter);\n\tNXWR32(adapter, NETXEN_ROMUSB_GLB_SW_RESET, 0xfeffffff);\n\tnetxen_rom_unlock(adapter);\n\n\tif (NX_IS_REVISION_P3(adapter->ahw.revision_id)) {\n\t\tif (netxen_rom_fast_read(adapter, 0, &n) != 0 ||\n\t\t\t(n != 0xcafecafe) ||\n\t\t\tnetxen_rom_fast_read(adapter, 4, &n) != 0) {\n\t\t\tprintk(KERN_ERR \"%s: ERROR Reading crb_init area: \"\n\t\t\t\t\t\"n: %08x\\n\", netxen_nic_driver_name, n);\n\t\t\treturn -EIO;\n\t\t}\n\t\toffset = n & 0xffffU;\n\t\tn = (n >> 16) & 0xffffU;\n\t} else {\n\t\tif (netxen_rom_fast_read(adapter, 0, &n) != 0 ||\n\t\t\t!(n & 0x80000000)) {\n\t\t\tprintk(KERN_ERR \"%s: ERROR Reading crb_init area: \"\n\t\t\t\t\t\"n: %08x\\n\", netxen_nic_driver_name, n);\n\t\t\treturn -EIO;\n\t\t}\n\t\toffset = 1;\n\t\tn &= ~0x80000000;\n\t}\n\n\tif (n >= 1024) {\n\t\tprintk(KERN_ERR \"%s:n=0x%x Error! NetXen card flash not\"\n\t\t       \" initialized.\\n\", __func__, n);\n\t\treturn -EIO;\n\t}\n\n\tbuf = kcalloc(n, sizeof(struct crb_addr_pair), GFP_KERNEL);\n\tif (buf == NULL)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < n; i++) {\n\t\tif (netxen_rom_fast_read(adapter, 8*i + 4*offset, &val) != 0 ||\n\t\tnetxen_rom_fast_read(adapter, 8*i + 4*offset + 4, &addr) != 0) {\n\t\t\tkfree(buf);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tbuf[i].addr = addr;\n\t\tbuf[i].data = val;\n\n\t}\n\n\tfor (i = 0; i < n; i++) {\n\n\t\toff = netxen_decode_crb_addr(buf[i].addr);\n\t\tif (off == NETXEN_ADDR_ERROR) {\n\t\t\tprintk(KERN_ERR\"CRB init value out of range %x\\n\",\n\t\t\t\t\tbuf[i].addr);\n\t\t\tcontinue;\n\t\t}\n\t\toff += NETXEN_PCI_CRBSPACE;\n\n\t\tif (off & 1)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (off == NETXEN_CAM_RAM(0x1fc))\n\t\t\tcontinue;\n\n\t\tif (NX_IS_REVISION_P3(adapter->ahw.revision_id)) {\n\t\t\tif (off == (NETXEN_CRB_I2C0 + 0x1c))\n\t\t\t\tcontinue;\n\t\t\t \n\t\t\tif (off == (ROMUSB_GLB + 0xbc))\n\t\t\t\tcontinue;\n\t\t\tif (off == (ROMUSB_GLB + 0xa8))\n\t\t\t\tcontinue;\n\t\t\tif (off == (ROMUSB_GLB + 0xc8))  \n\t\t\t\tcontinue;\n\t\t\tif (off == (ROMUSB_GLB + 0x24))  \n\t\t\t\tcontinue;\n\t\t\tif (off == (ROMUSB_GLB + 0x1c))  \n\t\t\t\tcontinue;\n\t\t\tif ((off & 0x0ff00000) == NETXEN_CRB_DDR_NET)\n\t\t\t\tcontinue;\n\t\t\tif (off == (NETXEN_CRB_PEG_NET_1 + 0x18) &&\n\t\t\t\t!NX_IS_REVISION_P3P(adapter->ahw.revision_id))\n\t\t\t\tbuf[i].data = 0x1020;\n\t\t\t \n\t\t\tif (off == NETXEN_PCIE_REG(PCIE_SETUP_FUNCTION))\n\t\t\t\tcontinue;\n\t\t\tif (off == NETXEN_PCIE_REG(PCIE_SETUP_FUNCTION2))\n\t\t\t\tcontinue;\n\t\t\tif ((off & 0x0ff00000) == NETXEN_CRB_SMB)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tinit_delay = 1;\n\t\t \n\t\t \n\t\tif (off == NETXEN_ROMUSB_GLB_SW_RESET) {\n\t\t\tinit_delay = 1000;\n\t\t\tif (NX_IS_REVISION_P2(adapter->ahw.revision_id)) {\n\t\t\t\t \n\t\t\t\tbuf[i].data = NETXEN_NIC_XDMA_RESET;\n\t\t\t\tbuf[i].data = 0x8000ff;\n\t\t\t}\n\t\t}\n\n\t\tNXWR32(adapter, off, buf[i].data);\n\n\t\tmsleep(init_delay);\n\t}\n\tkfree(buf);\n\n\t \n\n\t \n\tif (NX_IS_REVISION_P2(adapter->ahw.revision_id)) {\n\t\tval = NXRD32(adapter, NETXEN_ROMUSB_GLB_SW_RESET);\n\t\tNXWR32(adapter, NETXEN_ROMUSB_GLB_SW_RESET, (val & 0xffffff0f));\n\t}\n\n\t \n\tNXWR32(adapter, NETXEN_CRB_PEG_NET_D + 0xec, 0x1e);\n\t \n\tNXWR32(adapter, NETXEN_CRB_PEG_NET_D + 0x4c, 8);\n\t \n\tNXWR32(adapter, NETXEN_CRB_PEG_NET_I + 0x4c, 8);\n\n\t \n\n\t \n\tNXWR32(adapter, NETXEN_CRB_PEG_NET_0 + 0x8, 0);\n\tNXWR32(adapter, NETXEN_CRB_PEG_NET_0 + 0xc, 0);\n\t \n\tNXWR32(adapter, NETXEN_CRB_PEG_NET_1 + 0x8, 0);\n\tNXWR32(adapter, NETXEN_CRB_PEG_NET_1 + 0xc, 0);\n\t \n\tNXWR32(adapter, NETXEN_CRB_PEG_NET_2 + 0x8, 0);\n\tNXWR32(adapter, NETXEN_CRB_PEG_NET_2 + 0xc, 0);\n\t \n\tNXWR32(adapter, NETXEN_CRB_PEG_NET_3 + 0x8, 0);\n\tNXWR32(adapter, NETXEN_CRB_PEG_NET_3 + 0xc, 0);\n\treturn 0;\n}\n\nstatic struct uni_table_desc *nx_get_table_desc(const u8 *unirom, int section)\n{\n\tuint32_t i;\n\tstruct uni_table_desc *directory = (struct uni_table_desc *) &unirom[0];\n\t__le32 entries = cpu_to_le32(directory->num_entries);\n\n\tfor (i = 0; i < entries; i++) {\n\n\t\t__le32 offs = cpu_to_le32(directory->findex) +\n\t\t\t\t(i * cpu_to_le32(directory->entry_size));\n\t\t__le32 tab_type = cpu_to_le32(*((u32 *)&unirom[offs] + 8));\n\n\t\tif (tab_type == section)\n\t\t\treturn (struct uni_table_desc *) &unirom[offs];\n\t}\n\n\treturn NULL;\n}\n\n#define\tQLCNIC_FILEHEADER_SIZE\t(14 * 4)\n\nstatic int\nnetxen_nic_validate_header(struct netxen_adapter *adapter)\n{\n\tconst u8 *unirom = adapter->fw->data;\n\tstruct uni_table_desc *directory = (struct uni_table_desc *) &unirom[0];\n\tu32 fw_file_size = adapter->fw->size;\n\tu32 tab_size;\n\t__le32 entries;\n\t__le32 entry_size;\n\n\tif (fw_file_size < QLCNIC_FILEHEADER_SIZE)\n\t\treturn -EINVAL;\n\n\tentries = cpu_to_le32(directory->num_entries);\n\tentry_size = cpu_to_le32(directory->entry_size);\n\ttab_size = cpu_to_le32(directory->findex) + (entries * entry_size);\n\n\tif (fw_file_size < tab_size)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int\nnetxen_nic_validate_bootld(struct netxen_adapter *adapter)\n{\n\tstruct uni_table_desc *tab_desc;\n\tstruct uni_data_desc *descr;\n\tconst u8 *unirom = adapter->fw->data;\n\t__le32 idx = cpu_to_le32(*((int *)&unirom[adapter->file_prd_off] +\n\t\t\t\tNX_UNI_BOOTLD_IDX_OFF));\n\tu32 offs;\n\tu32 tab_size;\n\tu32 data_size;\n\n\ttab_desc = nx_get_table_desc(unirom, NX_UNI_DIR_SECT_BOOTLD);\n\n\tif (!tab_desc)\n\t\treturn -EINVAL;\n\n\ttab_size = cpu_to_le32(tab_desc->findex) +\n\t\t\t(cpu_to_le32(tab_desc->entry_size) * (idx + 1));\n\n\tif (adapter->fw->size < tab_size)\n\t\treturn -EINVAL;\n\n\toffs = cpu_to_le32(tab_desc->findex) +\n\t\t(cpu_to_le32(tab_desc->entry_size) * (idx));\n\tdescr = (struct uni_data_desc *)&unirom[offs];\n\n\tdata_size = cpu_to_le32(descr->findex) + cpu_to_le32(descr->size);\n\n\tif (adapter->fw->size < data_size)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int\nnetxen_nic_validate_fw(struct netxen_adapter *adapter)\n{\n\tstruct uni_table_desc *tab_desc;\n\tstruct uni_data_desc *descr;\n\tconst u8 *unirom = adapter->fw->data;\n\t__le32 idx = cpu_to_le32(*((int *)&unirom[adapter->file_prd_off] +\n\t\t\t\tNX_UNI_FIRMWARE_IDX_OFF));\n\tu32 offs;\n\tu32 tab_size;\n\tu32 data_size;\n\n\ttab_desc = nx_get_table_desc(unirom, NX_UNI_DIR_SECT_FW);\n\n\tif (!tab_desc)\n\t\treturn -EINVAL;\n\n\ttab_size = cpu_to_le32(tab_desc->findex) +\n\t\t\t(cpu_to_le32(tab_desc->entry_size) * (idx + 1));\n\n\tif (adapter->fw->size < tab_size)\n\t\treturn -EINVAL;\n\n\toffs = cpu_to_le32(tab_desc->findex) +\n\t\t(cpu_to_le32(tab_desc->entry_size) * (idx));\n\tdescr = (struct uni_data_desc *)&unirom[offs];\n\tdata_size = cpu_to_le32(descr->findex) + cpu_to_le32(descr->size);\n\n\tif (adapter->fw->size < data_size)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n\nstatic int\nnetxen_nic_validate_product_offs(struct netxen_adapter *adapter)\n{\n\tstruct uni_table_desc *ptab_descr;\n\tconst u8 *unirom = adapter->fw->data;\n\tint mn_present = (NX_IS_REVISION_P2(adapter->ahw.revision_id)) ?\n\t\t\t1 : netxen_p3_has_mn(adapter);\n\t__le32 entries;\n\t__le32 entry_size;\n\tu32 tab_size;\n\tu32 i;\n\n\tptab_descr = nx_get_table_desc(unirom, NX_UNI_DIR_SECT_PRODUCT_TBL);\n\tif (ptab_descr == NULL)\n\t\treturn -EINVAL;\n\n\tentries = cpu_to_le32(ptab_descr->num_entries);\n\tentry_size = cpu_to_le32(ptab_descr->entry_size);\n\ttab_size = cpu_to_le32(ptab_descr->findex) + (entries * entry_size);\n\n\tif (adapter->fw->size < tab_size)\n\t\treturn -EINVAL;\n\nnomn:\n\tfor (i = 0; i < entries; i++) {\n\n\t\t__le32 flags, file_chiprev, offs;\n\t\tu8 chiprev = adapter->ahw.revision_id;\n\t\tuint32_t flagbit;\n\n\t\toffs = cpu_to_le32(ptab_descr->findex) +\n\t\t\t\t(i * cpu_to_le32(ptab_descr->entry_size));\n\t\tflags = cpu_to_le32(*((int *)&unirom[offs] + NX_UNI_FLAGS_OFF));\n\t\tfile_chiprev = cpu_to_le32(*((int *)&unirom[offs] +\n\t\t\t\t\t\t\tNX_UNI_CHIP_REV_OFF));\n\n\t\tflagbit = mn_present ? 1 : 2;\n\n\t\tif ((chiprev == file_chiprev) &&\n\t\t\t\t\t((1ULL << flagbit) & flags)) {\n\t\t\tadapter->file_prd_off = offs;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (mn_present && NX_IS_REVISION_P3(adapter->ahw.revision_id)) {\n\t\tmn_present = 0;\n\t\tgoto nomn;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int\nnetxen_nic_validate_unified_romimage(struct netxen_adapter *adapter)\n{\n\tif (netxen_nic_validate_header(adapter)) {\n\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\t\"unified image: header validation failed\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (netxen_nic_validate_product_offs(adapter)) {\n\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\t\"unified image: product validation failed\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (netxen_nic_validate_bootld(adapter)) {\n\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\t\"unified image: bootld validation failed\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (netxen_nic_validate_fw(adapter)) {\n\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\t\"unified image: firmware validation failed\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic struct uni_data_desc *nx_get_data_desc(struct netxen_adapter *adapter,\n\t\t\tu32 section, u32 idx_offset)\n{\n\tconst u8 *unirom = adapter->fw->data;\n\tint idx = cpu_to_le32(*((int *)&unirom[adapter->file_prd_off] +\n\t\t\t\t\t\t\t\tidx_offset));\n\tstruct uni_table_desc *tab_desc;\n\t__le32 offs;\n\n\ttab_desc = nx_get_table_desc(unirom, section);\n\n\tif (tab_desc == NULL)\n\t\treturn NULL;\n\n\toffs = cpu_to_le32(tab_desc->findex) +\n\t\t\t(cpu_to_le32(tab_desc->entry_size) * idx);\n\n\treturn (struct uni_data_desc *)&unirom[offs];\n}\n\nstatic u8 *\nnx_get_bootld_offs(struct netxen_adapter *adapter)\n{\n\tu32 offs = NETXEN_BOOTLD_START;\n\n\tif (adapter->fw_type == NX_UNIFIED_ROMIMAGE)\n\t\toffs = cpu_to_le32((nx_get_data_desc(adapter,\n\t\t\t\t\tNX_UNI_DIR_SECT_BOOTLD,\n\t\t\t\t\tNX_UNI_BOOTLD_IDX_OFF))->findex);\n\n\treturn (u8 *)&adapter->fw->data[offs];\n}\n\nstatic u8 *\nnx_get_fw_offs(struct netxen_adapter *adapter)\n{\n\tu32 offs = NETXEN_IMAGE_START;\n\n\tif (adapter->fw_type == NX_UNIFIED_ROMIMAGE)\n\t\toffs = cpu_to_le32((nx_get_data_desc(adapter,\n\t\t\t\t\tNX_UNI_DIR_SECT_FW,\n\t\t\t\t\tNX_UNI_FIRMWARE_IDX_OFF))->findex);\n\n\treturn (u8 *)&adapter->fw->data[offs];\n}\n\nstatic __le32\nnx_get_fw_size(struct netxen_adapter *adapter)\n{\n\tif (adapter->fw_type == NX_UNIFIED_ROMIMAGE)\n\t\treturn cpu_to_le32((nx_get_data_desc(adapter,\n\t\t\t\t\tNX_UNI_DIR_SECT_FW,\n\t\t\t\t\tNX_UNI_FIRMWARE_IDX_OFF))->size);\n\telse\n\t\treturn cpu_to_le32(\n\t\t\t\t*(u32 *)&adapter->fw->data[NX_FW_SIZE_OFFSET]);\n}\n\nstatic __le32\nnx_get_fw_version(struct netxen_adapter *adapter)\n{\n\tstruct uni_data_desc *fw_data_desc;\n\tconst struct firmware *fw = adapter->fw;\n\t__le32 major, minor, sub;\n\tconst u8 *ver_str;\n\tint i, ret = 0;\n\n\tif (adapter->fw_type == NX_UNIFIED_ROMIMAGE) {\n\n\t\tfw_data_desc = nx_get_data_desc(adapter,\n\t\t\t\tNX_UNI_DIR_SECT_FW, NX_UNI_FIRMWARE_IDX_OFF);\n\t\tver_str = fw->data + cpu_to_le32(fw_data_desc->findex) +\n\t\t\t\tcpu_to_le32(fw_data_desc->size) - 17;\n\n\t\tfor (i = 0; i < 12; i++) {\n\t\t\tif (!strncmp(&ver_str[i], \"REV=\", 4)) {\n\t\t\t\tret = sscanf(&ver_str[i+4], \"%u.%u.%u \",\n\t\t\t\t\t\t\t&major, &minor, &sub);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (ret != 3)\n\t\t\treturn 0;\n\n\t\treturn major + (minor << 8) + (sub << 16);\n\n\t} else\n\t\treturn cpu_to_le32(*(u32 *)&fw->data[NX_FW_VERSION_OFFSET]);\n}\n\nstatic __le32\nnx_get_bios_version(struct netxen_adapter *adapter)\n{\n\tconst struct firmware *fw = adapter->fw;\n\t__le32 bios_ver, prd_off = adapter->file_prd_off;\n\n\tif (adapter->fw_type == NX_UNIFIED_ROMIMAGE) {\n\t\tbios_ver = cpu_to_le32(*((u32 *) (&fw->data[prd_off])\n\t\t\t\t\t\t+ NX_UNI_BIOS_VERSION_OFF));\n\t\treturn (bios_ver << 16) + ((bios_ver >> 8) & 0xff00) +\n\t\t\t\t\t\t\t(bios_ver >> 24);\n\t} else\n\t\treturn cpu_to_le32(*(u32 *)&fw->data[NX_BIOS_VERSION_OFFSET]);\n\n}\n\nint\nnetxen_need_fw_reset(struct netxen_adapter *adapter)\n{\n\tu32 count, old_count;\n\tu32 val, version, major, minor, build;\n\tint i, timeout;\n\tu8 fw_type;\n\n\t \n\tif (NX_IS_REVISION_P2(adapter->ahw.revision_id))\n\t\treturn 1;\n\n\tif (adapter->need_fw_reset)\n\t\treturn 1;\n\n\t \n\tif (NXRD32(adapter, CRB_CMDPEG_STATE) == PHAN_INITIALIZE_FAILED)\n\t\treturn 1;\n\n\told_count = NXRD32(adapter, NETXEN_PEG_ALIVE_COUNTER);\n\n\tfor (i = 0; i < 10; i++) {\n\n\t\ttimeout = msleep_interruptible(200);\n\t\tif (timeout) {\n\t\t\tNXWR32(adapter, CRB_CMDPEG_STATE,\n\t\t\t\t\tPHAN_INITIALIZE_FAILED);\n\t\t\treturn -EINTR;\n\t\t}\n\n\t\tcount = NXRD32(adapter, NETXEN_PEG_ALIVE_COUNTER);\n\t\tif (count != old_count)\n\t\t\tbreak;\n\t}\n\n\t \n\tif (count == old_count)\n\t\treturn 1;\n\n\t \n\tif (adapter->fw) {\n\n\t\tval = nx_get_fw_version(adapter);\n\n\t\tversion = NETXEN_DECODE_VERSION(val);\n\n\t\tmajor = NXRD32(adapter, NETXEN_FW_VERSION_MAJOR);\n\t\tminor = NXRD32(adapter, NETXEN_FW_VERSION_MINOR);\n\t\tbuild = NXRD32(adapter, NETXEN_FW_VERSION_SUB);\n\n\t\tif (version > NETXEN_VERSION_CODE(major, minor, build))\n\t\t\treturn 1;\n\n\t\tif (version == NETXEN_VERSION_CODE(major, minor, build) &&\n\t\t\tadapter->fw_type != NX_UNIFIED_ROMIMAGE) {\n\n\t\t\tval = NXRD32(adapter, NETXEN_MIU_MN_CONTROL);\n\t\t\tfw_type = (val & 0x4) ?\n\t\t\t\tNX_P3_CT_ROMIMAGE : NX_P3_MN_ROMIMAGE;\n\n\t\t\tif (adapter->fw_type != fw_type)\n\t\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n#define NETXEN_MIN_P3_FW_SUPP\tNETXEN_VERSION_CODE(4, 0, 505)\n\nint\nnetxen_check_flash_fw_compatibility(struct netxen_adapter *adapter)\n{\n\tu32 flash_fw_ver, min_fw_ver;\n\n\tif (NX_IS_REVISION_P2(adapter->ahw.revision_id))\n\t\treturn 0;\n\n\tif (netxen_rom_fast_read(adapter,\n\t\t\tNX_FW_VERSION_OFFSET, (int *)&flash_fw_ver)) {\n\t\tdev_err(&adapter->pdev->dev, \"Unable to read flash fw\"\n\t\t\t\"version\\n\");\n\t\treturn -EIO;\n\t}\n\n\tflash_fw_ver = NETXEN_DECODE_VERSION(flash_fw_ver);\n\tmin_fw_ver = NETXEN_MIN_P3_FW_SUPP;\n\tif (flash_fw_ver >= min_fw_ver)\n\t\treturn 0;\n\n\tdev_info(&adapter->pdev->dev, \"Flash fw[%d.%d.%d] is < min fw supported\"\n\t\t\"[4.0.505]. Please update firmware on flash\\n\",\n\t\t_major(flash_fw_ver), _minor(flash_fw_ver),\n\t\t_build(flash_fw_ver));\n\treturn -EINVAL;\n}\n\nstatic char *fw_name[] = {\n\tNX_P2_MN_ROMIMAGE_NAME,\n\tNX_P3_CT_ROMIMAGE_NAME,\n\tNX_P3_MN_ROMIMAGE_NAME,\n\tNX_UNIFIED_ROMIMAGE_NAME,\n\tNX_FLASH_ROMIMAGE_NAME,\n};\n\nint\nnetxen_load_firmware(struct netxen_adapter *adapter)\n{\n\tu64 *ptr64;\n\tu32 i, flashaddr, size;\n\tconst struct firmware *fw = adapter->fw;\n\tstruct pci_dev *pdev = adapter->pdev;\n\n\tdev_info(&pdev->dev, \"loading firmware from %s\\n\",\n\t\t\tfw_name[adapter->fw_type]);\n\n\tif (NX_IS_REVISION_P2(adapter->ahw.revision_id))\n\t\tNXWR32(adapter, NETXEN_ROMUSB_GLB_CAS_RST, 1);\n\n\tif (fw) {\n\t\t__le64 data;\n\n\t\tsize = (NETXEN_IMAGE_START - NETXEN_BOOTLD_START) / 8;\n\n\t\tptr64 = (u64 *)nx_get_bootld_offs(adapter);\n\t\tflashaddr = NETXEN_BOOTLD_START;\n\n\t\tfor (i = 0; i < size; i++) {\n\t\t\tdata = cpu_to_le64(ptr64[i]);\n\n\t\t\tif (adapter->pci_mem_write(adapter, flashaddr, data))\n\t\t\t\treturn -EIO;\n\n\t\t\tflashaddr += 8;\n\t\t}\n\n\t\tsize = (__force u32)nx_get_fw_size(adapter) / 8;\n\n\t\tptr64 = (u64 *)nx_get_fw_offs(adapter);\n\t\tflashaddr = NETXEN_IMAGE_START;\n\n\t\tfor (i = 0; i < size; i++) {\n\t\t\tdata = cpu_to_le64(ptr64[i]);\n\n\t\t\tif (adapter->pci_mem_write(adapter,\n\t\t\t\t\t\tflashaddr, data))\n\t\t\t\treturn -EIO;\n\n\t\t\tflashaddr += 8;\n\t\t}\n\n\t\tsize = (__force u32)nx_get_fw_size(adapter) % 8;\n\t\tif (size) {\n\t\t\tdata = cpu_to_le64(ptr64[i]);\n\n\t\t\tif (adapter->pci_mem_write(adapter,\n\t\t\t\t\t\tflashaddr, data))\n\t\t\t\treturn -EIO;\n\t\t}\n\n\t} else {\n\t\tu64 data;\n\t\tu32 hi, lo;\n\n\t\tsize = (NETXEN_IMAGE_START - NETXEN_BOOTLD_START) / 8;\n\t\tflashaddr = NETXEN_BOOTLD_START;\n\n\t\tfor (i = 0; i < size; i++) {\n\t\t\tif (netxen_rom_fast_read(adapter,\n\t\t\t\t\tflashaddr, (int *)&lo) != 0)\n\t\t\t\treturn -EIO;\n\t\t\tif (netxen_rom_fast_read(adapter,\n\t\t\t\t\tflashaddr + 4, (int *)&hi) != 0)\n\t\t\t\treturn -EIO;\n\n\t\t\t \n\t\t\tdata = (((u64)hi << 32) | lo);\n\n\t\t\tif (adapter->pci_mem_write(adapter,\n\t\t\t\t\t\tflashaddr, data))\n\t\t\t\treturn -EIO;\n\n\t\t\tflashaddr += 8;\n\t\t}\n\t}\n\tmsleep(1);\n\n\tif (NX_IS_REVISION_P3P(adapter->ahw.revision_id)) {\n\t\tNXWR32(adapter, NETXEN_CRB_PEG_NET_0 + 0x18, 0x1020);\n\t\tNXWR32(adapter, NETXEN_ROMUSB_GLB_SW_RESET, 0x80001e);\n\t} else if (NX_IS_REVISION_P3(adapter->ahw.revision_id))\n\t\tNXWR32(adapter, NETXEN_ROMUSB_GLB_SW_RESET, 0x80001d);\n\telse {\n\t\tNXWR32(adapter, NETXEN_ROMUSB_GLB_CHIP_CLK_CTRL, 0x3fff);\n\t\tNXWR32(adapter, NETXEN_ROMUSB_GLB_CAS_RST, 0);\n\t}\n\n\treturn 0;\n}\n\nstatic int\nnetxen_validate_firmware(struct netxen_adapter *adapter)\n{\n\t__le32 val;\n\t__le32 flash_fw_ver;\n\tu32 file_fw_ver, min_ver, bios;\n\tstruct pci_dev *pdev = adapter->pdev;\n\tconst struct firmware *fw = adapter->fw;\n\tu8 fw_type = adapter->fw_type;\n\tu32 crbinit_fix_fw;\n\n\tif (fw_type == NX_UNIFIED_ROMIMAGE) {\n\t\tif (netxen_nic_validate_unified_romimage(adapter))\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tval = cpu_to_le32(*(u32 *)&fw->data[NX_FW_MAGIC_OFFSET]);\n\t\tif ((__force u32)val != NETXEN_BDINFO_MAGIC)\n\t\t\treturn -EINVAL;\n\n\t\tif (fw->size < NX_FW_MIN_SIZE)\n\t\t\treturn -EINVAL;\n\t}\n\n\tval = nx_get_fw_version(adapter);\n\n\tif (NX_IS_REVISION_P3(adapter->ahw.revision_id))\n\t\tmin_ver = NETXEN_MIN_P3_FW_SUPP;\n\telse\n\t\tmin_ver = NETXEN_VERSION_CODE(3, 4, 216);\n\n\tfile_fw_ver = NETXEN_DECODE_VERSION(val);\n\n\tif ((_major(file_fw_ver) > _NETXEN_NIC_LINUX_MAJOR) ||\n\t    (file_fw_ver < min_ver)) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\t\"%s: firmware version %d.%d.%d unsupported\\n\",\n\t\tfw_name[fw_type], _major(file_fw_ver), _minor(file_fw_ver),\n\t\t _build(file_fw_ver));\n\t\treturn -EINVAL;\n\t}\n\tval = nx_get_bios_version(adapter);\n\tif (netxen_rom_fast_read(adapter, NX_BIOS_VERSION_OFFSET, (int *)&bios))\n\t\treturn -EIO;\n\tif ((__force u32)val != bios) {\n\t\tdev_err(&pdev->dev, \"%s: firmware bios is incompatible\\n\",\n\t\t\t\tfw_name[fw_type]);\n\t\treturn -EINVAL;\n\t}\n\n\tif (netxen_rom_fast_read(adapter,\n\t\t\tNX_FW_VERSION_OFFSET, (int *)&flash_fw_ver)) {\n\t\tdev_err(&pdev->dev, \"Unable to read flash fw version\\n\");\n\t\treturn -EIO;\n\t}\n\tflash_fw_ver = NETXEN_DECODE_VERSION(flash_fw_ver);\n\n\t \n\tcrbinit_fix_fw = NETXEN_VERSION_CODE(4, 0, 554);\n\tif (file_fw_ver >= crbinit_fix_fw && flash_fw_ver < crbinit_fix_fw &&\n\t    NX_IS_REVISION_P3(adapter->ahw.revision_id)) {\n\t\tdev_err(&pdev->dev, \"Incompatibility detected between driver \"\n\t\t\t\"and firmware version on flash. This configuration \"\n\t\t\t\"is not recommended. Please update the firmware on \"\n\t\t\t\"flash immediately\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (!netxen_p3_has_mn(adapter) ||\n\t    NX_IS_REVISION_P2(adapter->ahw.revision_id)) {\n\t\tif (flash_fw_ver > file_fw_ver) {\n\t\t\tdev_info(&pdev->dev, \"%s: firmware is older than flash\\n\",\n\t\t\t\tfw_name[fw_type]);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tNXWR32(adapter, NETXEN_CAM_RAM(0x1fc), NETXEN_BDINFO_MAGIC);\n\treturn 0;\n}\n\nstatic void\nnx_get_next_fwtype(struct netxen_adapter *adapter)\n{\n\tu8 fw_type;\n\n\tswitch (adapter->fw_type) {\n\tcase NX_UNKNOWN_ROMIMAGE:\n\t\tfw_type = NX_UNIFIED_ROMIMAGE;\n\t\tbreak;\n\n\tcase NX_UNIFIED_ROMIMAGE:\n\t\tif (NX_IS_REVISION_P3P(adapter->ahw.revision_id))\n\t\t\tfw_type = NX_FLASH_ROMIMAGE;\n\t\telse if (NX_IS_REVISION_P2(adapter->ahw.revision_id))\n\t\t\tfw_type = NX_P2_MN_ROMIMAGE;\n\t\telse if (netxen_p3_has_mn(adapter))\n\t\t\tfw_type = NX_P3_MN_ROMIMAGE;\n\t\telse\n\t\t\tfw_type = NX_P3_CT_ROMIMAGE;\n\t\tbreak;\n\n\tcase NX_P3_MN_ROMIMAGE:\n\t\tfw_type = NX_P3_CT_ROMIMAGE;\n\t\tbreak;\n\n\tcase NX_P2_MN_ROMIMAGE:\n\tcase NX_P3_CT_ROMIMAGE:\n\tdefault:\n\t\tfw_type = NX_FLASH_ROMIMAGE;\n\t\tbreak;\n\t}\n\n\tadapter->fw_type = fw_type;\n}\n\nstatic int\nnetxen_p3_has_mn(struct netxen_adapter *adapter)\n{\n\tu32 capability, flashed_ver;\n\tcapability = 0;\n\n\t \n\tif (NX_IS_REVISION_P2(adapter->ahw.revision_id))\n\t\treturn 1;\n\n\tnetxen_rom_fast_read(adapter,\n\t\t\tNX_FW_VERSION_OFFSET, (int *)&flashed_ver);\n\tflashed_ver = NETXEN_DECODE_VERSION(flashed_ver);\n\n\tif (flashed_ver >= NETXEN_VERSION_CODE(4, 0, 220)) {\n\n\t\tcapability = NXRD32(adapter, NX_PEG_TUNE_CAPABILITY);\n\t\tif (capability & NX_PEG_TUNE_MN_PRESENT)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nvoid netxen_request_firmware(struct netxen_adapter *adapter)\n{\n\tstruct pci_dev *pdev = adapter->pdev;\n\tint rc = 0;\n\n\tadapter->fw_type = NX_UNKNOWN_ROMIMAGE;\n\nnext:\n\tnx_get_next_fwtype(adapter);\n\n\tif (adapter->fw_type == NX_FLASH_ROMIMAGE) {\n\t\tadapter->fw = NULL;\n\t} else {\n\t\trc = request_firmware(&adapter->fw,\n\t\t\t\tfw_name[adapter->fw_type], &pdev->dev);\n\t\tif (rc != 0)\n\t\t\tgoto next;\n\n\t\trc = netxen_validate_firmware(adapter);\n\t\tif (rc != 0) {\n\t\t\trelease_firmware(adapter->fw);\n\t\t\tmsleep(1);\n\t\t\tgoto next;\n\t\t}\n\t}\n}\n\n\nvoid\nnetxen_release_firmware(struct netxen_adapter *adapter)\n{\n\trelease_firmware(adapter->fw);\n\tadapter->fw = NULL;\n}\n\nint netxen_init_dummy_dma(struct netxen_adapter *adapter)\n{\n\tu64 addr;\n\tu32 hi, lo;\n\n\tif (!NX_IS_REVISION_P2(adapter->ahw.revision_id))\n\t\treturn 0;\n\n\tadapter->dummy_dma.addr = dma_alloc_coherent(&adapter->pdev->dev,\n\t\t\t\t\t\t     NETXEN_HOST_DUMMY_DMA_SIZE,\n\t\t\t\t\t\t     &adapter->dummy_dma.phys_addr,\n\t\t\t\t\t\t     GFP_KERNEL);\n\tif (adapter->dummy_dma.addr == NULL) {\n\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\"ERROR: Could not allocate dummy DMA memory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\taddr = (uint64_t) adapter->dummy_dma.phys_addr;\n\thi = (addr >> 32) & 0xffffffff;\n\tlo = addr & 0xffffffff;\n\n\tNXWR32(adapter, CRB_HOST_DUMMY_BUF_ADDR_HI, hi);\n\tNXWR32(adapter, CRB_HOST_DUMMY_BUF_ADDR_LO, lo);\n\n\treturn 0;\n}\n\n \nvoid netxen_free_dummy_dma(struct netxen_adapter *adapter)\n{\n\tint i = 100;\n\tu32 ctrl;\n\n\tif (!NX_IS_REVISION_P2(adapter->ahw.revision_id))\n\t\treturn;\n\n\tif (!adapter->dummy_dma.addr)\n\t\treturn;\n\n\tctrl = NXRD32(adapter, NETXEN_DMA_WATCHDOG_CTRL);\n\tif ((ctrl & 0x1) != 0) {\n\t\tNXWR32(adapter, NETXEN_DMA_WATCHDOG_CTRL, (ctrl | 0x2));\n\n\t\twhile ((ctrl & 0x1) != 0) {\n\n\t\t\tmsleep(50);\n\n\t\t\tctrl = NXRD32(adapter, NETXEN_DMA_WATCHDOG_CTRL);\n\n\t\t\tif (--i == 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i) {\n\t\tdma_free_coherent(&adapter->pdev->dev,\n\t\t\t\t  NETXEN_HOST_DUMMY_DMA_SIZE,\n\t\t\t\t  adapter->dummy_dma.addr,\n\t\t\t\t  adapter->dummy_dma.phys_addr);\n\t\tadapter->dummy_dma.addr = NULL;\n\t} else\n\t\tdev_err(&adapter->pdev->dev, \"dma_watchdog_shutdown failed\\n\");\n}\n\nint netxen_phantom_init(struct netxen_adapter *adapter, int pegtune_val)\n{\n\tu32 val = 0;\n\tint retries = 60;\n\n\tif (pegtune_val)\n\t\treturn 0;\n\n\tdo {\n\t\tval = NXRD32(adapter, CRB_CMDPEG_STATE);\n\t\tswitch (val) {\n\t\tcase PHAN_INITIALIZE_COMPLETE:\n\t\tcase PHAN_INITIALIZE_ACK:\n\t\t\treturn 0;\n\t\tcase PHAN_INITIALIZE_FAILED:\n\t\t\tgoto out_err;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tmsleep(500);\n\n\t} while (--retries);\n\n\tNXWR32(adapter, CRB_CMDPEG_STATE, PHAN_INITIALIZE_FAILED);\n\nout_err:\n\tdev_warn(&adapter->pdev->dev, \"firmware init failed\\n\");\n\treturn -EIO;\n}\n\nstatic int\nnetxen_receive_peg_ready(struct netxen_adapter *adapter)\n{\n\tu32 val = 0;\n\tint retries = 2000;\n\n\tdo {\n\t\tval = NXRD32(adapter, CRB_RCVPEG_STATE);\n\n\t\tif (val == PHAN_PEG_RCV_INITIALIZED)\n\t\t\treturn 0;\n\n\t\tmsleep(10);\n\n\t} while (--retries);\n\n\tpr_err(\"Receive Peg initialization not complete, state: 0x%x.\\n\", val);\n\treturn -EIO;\n}\n\nint netxen_init_firmware(struct netxen_adapter *adapter)\n{\n\tint err;\n\n\terr = netxen_receive_peg_ready(adapter);\n\tif (err)\n\t\treturn err;\n\n\tNXWR32(adapter, CRB_NIC_CAPABILITIES_HOST, INTR_SCHEME_PERPORT);\n\tNXWR32(adapter, CRB_MPORT_MODE, MPORT_MULTI_FUNCTION_MODE);\n\tNXWR32(adapter, CRB_CMDPEG_STATE, PHAN_INITIALIZE_ACK);\n\n\tif (NX_IS_REVISION_P2(adapter->ahw.revision_id))\n\t\tNXWR32(adapter, CRB_NIC_MSI_MODE_HOST, MSI_MODE_MULTIFUNC);\n\n\treturn err;\n}\n\nstatic void\nnetxen_handle_linkevent(struct netxen_adapter *adapter, nx_fw_msg_t *msg)\n{\n\tu32 cable_OUI;\n\tu16 cable_len;\n\tu16 link_speed;\n\tu8  link_status, module, duplex, autoneg;\n\tstruct net_device *netdev = adapter->netdev;\n\n\tadapter->has_link_events = 1;\n\n\tcable_OUI = msg->body[1] & 0xffffffff;\n\tcable_len = (msg->body[1] >> 32) & 0xffff;\n\tlink_speed = (msg->body[1] >> 48) & 0xffff;\n\n\tlink_status = msg->body[2] & 0xff;\n\tduplex = (msg->body[2] >> 16) & 0xff;\n\tautoneg = (msg->body[2] >> 24) & 0xff;\n\n\tmodule = (msg->body[2] >> 8) & 0xff;\n\tif (module == LINKEVENT_MODULE_TWINAX_UNSUPPORTED_CABLE) {\n\t\tprintk(KERN_INFO \"%s: unsupported cable: OUI 0x%x, length %d\\n\",\n\t\t\t\tnetdev->name, cable_OUI, cable_len);\n\t} else if (module == LINKEVENT_MODULE_TWINAX_UNSUPPORTED_CABLELEN) {\n\t\tprintk(KERN_INFO \"%s: unsupported cable length %d\\n\",\n\t\t\t\tnetdev->name, cable_len);\n\t}\n\n\t \n\tif (duplex == LINKEVENT_FULL_DUPLEX)\n\t\tadapter->link_duplex = DUPLEX_FULL;\n\telse\n\t\tadapter->link_duplex = DUPLEX_HALF;\n\tadapter->module_type = module;\n\tadapter->link_autoneg = autoneg;\n\tadapter->link_speed = link_speed;\n\n\tnetxen_advert_link_change(adapter, link_status);\n}\n\nstatic void\nnetxen_handle_fw_message(int desc_cnt, int index,\n\t\tstruct nx_host_sds_ring *sds_ring)\n{\n\tnx_fw_msg_t msg;\n\tstruct status_desc *desc;\n\tint i = 0, opcode;\n\n\twhile (desc_cnt > 0 && i < 8) {\n\t\tdesc = &sds_ring->desc_head[index];\n\t\tmsg.words[i++] = le64_to_cpu(desc->status_desc_data[0]);\n\t\tmsg.words[i++] = le64_to_cpu(desc->status_desc_data[1]);\n\n\t\tindex = get_next_index(index, sds_ring->num_desc);\n\t\tdesc_cnt--;\n\t}\n\n\topcode = netxen_get_nic_msg_opcode(msg.body[0]);\n\tswitch (opcode) {\n\tcase NX_NIC_C2H_OPCODE_GET_LINKEVENT_RESPONSE:\n\t\tnetxen_handle_linkevent(sds_ring->adapter, &msg);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic int\nnetxen_alloc_rx_skb(struct netxen_adapter *adapter,\n\t\tstruct nx_host_rds_ring *rds_ring,\n\t\tstruct netxen_rx_buffer *buffer)\n{\n\tstruct sk_buff *skb;\n\tdma_addr_t dma;\n\tstruct pci_dev *pdev = adapter->pdev;\n\n\tbuffer->skb = netdev_alloc_skb(adapter->netdev, rds_ring->skb_size);\n\tif (!buffer->skb)\n\t\treturn 1;\n\n\tskb = buffer->skb;\n\n\tif (!adapter->ahw.cut_through)\n\t\tskb_reserve(skb, 2);\n\n\tdma = dma_map_single(&pdev->dev, skb->data, rds_ring->dma_size,\n\t\t\t     DMA_FROM_DEVICE);\n\n\tif (dma_mapping_error(&pdev->dev, dma)) {\n\t\tdev_kfree_skb_any(skb);\n\t\tbuffer->skb = NULL;\n\t\treturn 1;\n\t}\n\n\tbuffer->skb = skb;\n\tbuffer->dma = dma;\n\tbuffer->state = NETXEN_BUFFER_BUSY;\n\n\treturn 0;\n}\n\nstatic struct sk_buff *netxen_process_rxbuf(struct netxen_adapter *adapter,\n\t\tstruct nx_host_rds_ring *rds_ring, u16 index, u16 cksum)\n{\n\tstruct netxen_rx_buffer *buffer;\n\tstruct sk_buff *skb;\n\n\tbuffer = &rds_ring->rx_buf_arr[index];\n\n\tdma_unmap_single(&adapter->pdev->dev, buffer->dma, rds_ring->dma_size,\n\t\t\t DMA_FROM_DEVICE);\n\n\tskb = buffer->skb;\n\tif (!skb)\n\t\tgoto no_skb;\n\n\tif (likely((adapter->netdev->features & NETIF_F_RXCSUM)\n\t    && cksum == STATUS_CKSUM_OK)) {\n\t\tadapter->stats.csummed++;\n\t\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\t} else\n\t\tskb->ip_summed = CHECKSUM_NONE;\n\n\tbuffer->skb = NULL;\nno_skb:\n\tbuffer->state = NETXEN_BUFFER_FREE;\n\treturn skb;\n}\n\nstatic struct netxen_rx_buffer *\nnetxen_process_rcv(struct netxen_adapter *adapter,\n\t\tstruct nx_host_sds_ring *sds_ring,\n\t\tint ring, u64 sts_data0)\n{\n\tstruct net_device *netdev = adapter->netdev;\n\tstruct netxen_recv_context *recv_ctx = &adapter->recv_ctx;\n\tstruct netxen_rx_buffer *buffer;\n\tstruct sk_buff *skb;\n\tstruct nx_host_rds_ring *rds_ring;\n\tint index, length, cksum, pkt_offset;\n\n\tif (unlikely(ring >= adapter->max_rds_rings))\n\t\treturn NULL;\n\n\trds_ring = &recv_ctx->rds_rings[ring];\n\n\tindex = netxen_get_sts_refhandle(sts_data0);\n\tif (unlikely(index >= rds_ring->num_desc))\n\t\treturn NULL;\n\n\tbuffer = &rds_ring->rx_buf_arr[index];\n\n\tlength = netxen_get_sts_totallength(sts_data0);\n\tcksum  = netxen_get_sts_status(sts_data0);\n\tpkt_offset = netxen_get_sts_pkt_offset(sts_data0);\n\n\tskb = netxen_process_rxbuf(adapter, rds_ring, index, cksum);\n\tif (!skb)\n\t\treturn buffer;\n\n\tif (length > rds_ring->skb_size)\n\t\tskb_put(skb, rds_ring->skb_size);\n\telse\n\t\tskb_put(skb, length);\n\n\n\tif (pkt_offset)\n\t\tskb_pull(skb, pkt_offset);\n\n\tskb->protocol = eth_type_trans(skb, netdev);\n\n\tnapi_gro_receive(&sds_ring->napi, skb);\n\n\tadapter->stats.rx_pkts++;\n\tadapter->stats.rxbytes += length;\n\n\treturn buffer;\n}\n\n#define TCP_HDR_SIZE            20\n#define TCP_TS_OPTION_SIZE      12\n#define TCP_TS_HDR_SIZE         (TCP_HDR_SIZE + TCP_TS_OPTION_SIZE)\n\nstatic struct netxen_rx_buffer *\nnetxen_process_lro(struct netxen_adapter *adapter,\n\t\tstruct nx_host_sds_ring *sds_ring,\n\t\tint ring, u64 sts_data0, u64 sts_data1)\n{\n\tstruct net_device *netdev = adapter->netdev;\n\tstruct netxen_recv_context *recv_ctx = &adapter->recv_ctx;\n\tstruct netxen_rx_buffer *buffer;\n\tstruct sk_buff *skb;\n\tstruct nx_host_rds_ring *rds_ring;\n\tstruct iphdr *iph;\n\tstruct tcphdr *th;\n\tbool push, timestamp;\n\tint l2_hdr_offset, l4_hdr_offset;\n\tint index;\n\tu16 lro_length, length, data_offset;\n\tu32 seq_number;\n\tu8 vhdr_len = 0;\n\n\tif (unlikely(ring >= adapter->max_rds_rings))\n\t\treturn NULL;\n\n\trds_ring = &recv_ctx->rds_rings[ring];\n\n\tindex = netxen_get_lro_sts_refhandle(sts_data0);\n\tif (unlikely(index >= rds_ring->num_desc))\n\t\treturn NULL;\n\n\tbuffer = &rds_ring->rx_buf_arr[index];\n\n\ttimestamp = netxen_get_lro_sts_timestamp(sts_data0);\n\tlro_length = netxen_get_lro_sts_length(sts_data0);\n\tl2_hdr_offset = netxen_get_lro_sts_l2_hdr_offset(sts_data0);\n\tl4_hdr_offset = netxen_get_lro_sts_l4_hdr_offset(sts_data0);\n\tpush = netxen_get_lro_sts_push_flag(sts_data0);\n\tseq_number = netxen_get_lro_sts_seq_number(sts_data1);\n\n\tskb = netxen_process_rxbuf(adapter, rds_ring, index, STATUS_CKSUM_OK);\n\tif (!skb)\n\t\treturn buffer;\n\n\tif (timestamp)\n\t\tdata_offset = l4_hdr_offset + TCP_TS_HDR_SIZE;\n\telse\n\t\tdata_offset = l4_hdr_offset + TCP_HDR_SIZE;\n\n\tskb_put(skb, lro_length + data_offset);\n\n\tskb_pull(skb, l2_hdr_offset);\n\tskb->protocol = eth_type_trans(skb, netdev);\n\n\tif (skb->protocol == htons(ETH_P_8021Q))\n\t\tvhdr_len = VLAN_HLEN;\n\tiph = (struct iphdr *)(skb->data + vhdr_len);\n\tth = (struct tcphdr *)((skb->data + vhdr_len) + (iph->ihl << 2));\n\n\tlength = (iph->ihl << 2) + (th->doff << 2) + lro_length;\n\tcsum_replace2(&iph->check, iph->tot_len, htons(length));\n\tiph->tot_len = htons(length);\n\tth->psh = push;\n\tth->seq = htonl(seq_number);\n\n\tlength = skb->len;\n\n\tif (adapter->flags & NETXEN_FW_MSS_CAP)\n\t\tskb_shinfo(skb)->gso_size  =  netxen_get_lro_sts_mss(sts_data1);\n\n\tnetif_receive_skb(skb);\n\n\tadapter->stats.lro_pkts++;\n\tadapter->stats.rxbytes += length;\n\n\treturn buffer;\n}\n\n#define netxen_merge_rx_buffers(list, head) \\\n\tdo { list_splice_tail_init(list, head); } while (0);\n\nint\nnetxen_process_rcv_ring(struct nx_host_sds_ring *sds_ring, int max)\n{\n\tstruct netxen_adapter *adapter = sds_ring->adapter;\n\n\tstruct list_head *cur;\n\n\tstruct status_desc *desc;\n\tstruct netxen_rx_buffer *rxbuf;\n\n\tu32 consumer = sds_ring->consumer;\n\n\tint count = 0;\n\tu64 sts_data0, sts_data1;\n\tint opcode, ring = 0, desc_cnt;\n\n\twhile (count < max) {\n\t\tdesc = &sds_ring->desc_head[consumer];\n\t\tsts_data0 = le64_to_cpu(desc->status_desc_data[0]);\n\n\t\tif (!(sts_data0 & STATUS_OWNER_HOST))\n\t\t\tbreak;\n\n\t\tdesc_cnt = netxen_get_sts_desc_cnt(sts_data0);\n\n\t\topcode = netxen_get_sts_opcode(sts_data0);\n\n\t\tswitch (opcode) {\n\t\tcase NETXEN_NIC_RXPKT_DESC:\n\t\tcase NETXEN_OLD_RXPKT_DESC:\n\t\tcase NETXEN_NIC_SYN_OFFLOAD:\n\t\t\tring = netxen_get_sts_type(sts_data0);\n\t\t\trxbuf = netxen_process_rcv(adapter, sds_ring,\n\t\t\t\t\tring, sts_data0);\n\t\t\tbreak;\n\t\tcase NETXEN_NIC_LRO_DESC:\n\t\t\tring = netxen_get_lro_sts_type(sts_data0);\n\t\t\tsts_data1 = le64_to_cpu(desc->status_desc_data[1]);\n\t\t\trxbuf = netxen_process_lro(adapter, sds_ring,\n\t\t\t\t\tring, sts_data0, sts_data1);\n\t\t\tbreak;\n\t\tcase NETXEN_NIC_RESPONSE_DESC:\n\t\t\tnetxen_handle_fw_message(desc_cnt, consumer, sds_ring);\n\t\t\tgoto skip;\n\t\tdefault:\n\t\t\tgoto skip;\n\t\t}\n\n\t\tWARN_ON(desc_cnt > 1);\n\n\t\tif (rxbuf)\n\t\t\tlist_add_tail(&rxbuf->list, &sds_ring->free_list[ring]);\n\nskip:\n\t\tfor (; desc_cnt > 0; desc_cnt--) {\n\t\t\tdesc = &sds_ring->desc_head[consumer];\n\t\t\tdesc->status_desc_data[0] =\n\t\t\t\tcpu_to_le64(STATUS_OWNER_PHANTOM);\n\t\t\tconsumer = get_next_index(consumer, sds_ring->num_desc);\n\t\t}\n\t\tcount++;\n\t}\n\n\tfor (ring = 0; ring < adapter->max_rds_rings; ring++) {\n\t\tstruct nx_host_rds_ring *rds_ring =\n\t\t\t&adapter->recv_ctx.rds_rings[ring];\n\n\t\tif (!list_empty(&sds_ring->free_list[ring])) {\n\t\t\tlist_for_each(cur, &sds_ring->free_list[ring]) {\n\t\t\t\trxbuf = list_entry(cur,\n\t\t\t\t\t\tstruct netxen_rx_buffer, list);\n\t\t\t\tnetxen_alloc_rx_skb(adapter, rds_ring, rxbuf);\n\t\t\t}\n\t\t\tspin_lock(&rds_ring->lock);\n\t\t\tnetxen_merge_rx_buffers(&sds_ring->free_list[ring],\n\t\t\t\t\t\t&rds_ring->free_list);\n\t\t\tspin_unlock(&rds_ring->lock);\n\t\t}\n\n\t\tnetxen_post_rx_buffers_nodb(adapter, rds_ring);\n\t}\n\n\tif (count) {\n\t\tsds_ring->consumer = consumer;\n\t\tNXWRIO(adapter, sds_ring->crb_sts_consumer, consumer);\n\t}\n\n\treturn count;\n}\n\n \nint netxen_process_cmd_ring(struct netxen_adapter *adapter)\n{\n\tu32 sw_consumer, hw_consumer;\n\tint count = 0, i;\n\tstruct netxen_cmd_buffer *buffer;\n\tstruct pci_dev *pdev = adapter->pdev;\n\tstruct net_device *netdev = adapter->netdev;\n\tstruct netxen_skb_frag *frag;\n\tint done = 0;\n\tstruct nx_host_tx_ring *tx_ring = adapter->tx_ring;\n\n\tif (!spin_trylock_bh(&adapter->tx_clean_lock))\n\t\treturn 1;\n\n\tsw_consumer = tx_ring->sw_consumer;\n\thw_consumer = le32_to_cpu(*(tx_ring->hw_consumer));\n\n\twhile (sw_consumer != hw_consumer) {\n\t\tbuffer = &tx_ring->cmd_buf_arr[sw_consumer];\n\t\tif (buffer->skb) {\n\t\t\tfrag = &buffer->frag_array[0];\n\t\t\tdma_unmap_single(&pdev->dev, frag->dma, frag->length,\n\t\t\t\t\t DMA_TO_DEVICE);\n\t\t\tfrag->dma = 0ULL;\n\t\t\tfor (i = 1; i < buffer->frag_count; i++) {\n\t\t\t\tfrag++;\t \n\t\t\t\tdma_unmap_page(&pdev->dev, frag->dma,\n\t\t\t\t\t       frag->length, DMA_TO_DEVICE);\n\t\t\t\tfrag->dma = 0ULL;\n\t\t\t}\n\n\t\t\tadapter->stats.xmitfinished++;\n\t\t\tdev_kfree_skb_any(buffer->skb);\n\t\t\tbuffer->skb = NULL;\n\t\t}\n\n\t\tsw_consumer = get_next_index(sw_consumer, tx_ring->num_desc);\n\t\tif (++count >= MAX_STATUS_HANDLE)\n\t\t\tbreak;\n\t}\n\n\ttx_ring->sw_consumer = sw_consumer;\n\n\tif (count && netif_running(netdev)) {\n\t\tsmp_mb();\n\n\t\tif (netif_queue_stopped(netdev) && netif_carrier_ok(netdev))\n\t\t\tif (netxen_tx_avail(tx_ring) > TX_STOP_THRESH)\n\t\t\t\tnetif_wake_queue(netdev);\n\t\tadapter->tx_timeo_cnt = 0;\n\t}\n\t \n\thw_consumer = le32_to_cpu(*(tx_ring->hw_consumer));\n\tdone = (sw_consumer == hw_consumer);\n\tspin_unlock_bh(&adapter->tx_clean_lock);\n\n\treturn done;\n}\n\nvoid\nnetxen_post_rx_buffers(struct netxen_adapter *adapter, u32 ringid,\n\tstruct nx_host_rds_ring *rds_ring)\n{\n\tstruct rcv_desc *pdesc;\n\tstruct netxen_rx_buffer *buffer;\n\tint producer, count = 0;\n\tnetxen_ctx_msg msg = 0;\n\tstruct list_head *head;\n\n\tproducer = rds_ring->producer;\n\n\thead = &rds_ring->free_list;\n\twhile (!list_empty(head)) {\n\n\t\tbuffer = list_entry(head->next, struct netxen_rx_buffer, list);\n\n\t\tif (!buffer->skb) {\n\t\t\tif (netxen_alloc_rx_skb(adapter, rds_ring, buffer))\n\t\t\t\tbreak;\n\t\t}\n\n\t\tcount++;\n\t\tlist_del(&buffer->list);\n\n\t\t \n\t\tpdesc = &rds_ring->desc_head[producer];\n\t\tpdesc->addr_buffer = cpu_to_le64(buffer->dma);\n\t\tpdesc->reference_handle = cpu_to_le16(buffer->ref_handle);\n\t\tpdesc->buffer_length = cpu_to_le32(rds_ring->dma_size);\n\n\t\tproducer = get_next_index(producer, rds_ring->num_desc);\n\t}\n\n\tif (count) {\n\t\trds_ring->producer = producer;\n\t\tNXWRIO(adapter, rds_ring->crb_rcv_producer,\n\t\t\t\t(producer-1) & (rds_ring->num_desc-1));\n\n\t\tif (NX_IS_REVISION_P2(adapter->ahw.revision_id)) {\n\t\t\t \n\t\t\tnetxen_set_msg_peg_id(msg, NETXEN_RCV_PEG_DB_ID);\n\t\t\tnetxen_set_msg_privid(msg);\n\t\t\tnetxen_set_msg_count(msg,\n\t\t\t\t\t     ((producer - 1) &\n\t\t\t\t\t      (rds_ring->num_desc - 1)));\n\t\t\tnetxen_set_msg_ctxid(msg, adapter->portnum);\n\t\t\tnetxen_set_msg_opcode(msg, NETXEN_RCV_PRODUCER(ringid));\n\t\t\tNXWRIO(adapter, DB_NORMALIZE(adapter,\n\t\t\t\t\tNETXEN_RCV_PRODUCER_OFFSET), msg);\n\t\t}\n\t}\n}\n\nstatic void\nnetxen_post_rx_buffers_nodb(struct netxen_adapter *adapter,\n\t\tstruct nx_host_rds_ring *rds_ring)\n{\n\tstruct rcv_desc *pdesc;\n\tstruct netxen_rx_buffer *buffer;\n\tint producer, count = 0;\n\tstruct list_head *head;\n\n\tif (!spin_trylock(&rds_ring->lock))\n\t\treturn;\n\n\tproducer = rds_ring->producer;\n\n\thead = &rds_ring->free_list;\n\twhile (!list_empty(head)) {\n\n\t\tbuffer = list_entry(head->next, struct netxen_rx_buffer, list);\n\n\t\tif (!buffer->skb) {\n\t\t\tif (netxen_alloc_rx_skb(adapter, rds_ring, buffer))\n\t\t\t\tbreak;\n\t\t}\n\n\t\tcount++;\n\t\tlist_del(&buffer->list);\n\n\t\t \n\t\tpdesc = &rds_ring->desc_head[producer];\n\t\tpdesc->reference_handle = cpu_to_le16(buffer->ref_handle);\n\t\tpdesc->buffer_length = cpu_to_le32(rds_ring->dma_size);\n\t\tpdesc->addr_buffer = cpu_to_le64(buffer->dma);\n\n\t\tproducer = get_next_index(producer, rds_ring->num_desc);\n\t}\n\n\tif (count) {\n\t\trds_ring->producer = producer;\n\t\tNXWRIO(adapter, rds_ring->crb_rcv_producer,\n\t\t\t\t(producer - 1) & (rds_ring->num_desc - 1));\n\t}\n\tspin_unlock(&rds_ring->lock);\n}\n\nvoid netxen_nic_clear_stats(struct netxen_adapter *adapter)\n{\n\tmemset(&adapter->stats, 0, sizeof(adapter->stats));\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}