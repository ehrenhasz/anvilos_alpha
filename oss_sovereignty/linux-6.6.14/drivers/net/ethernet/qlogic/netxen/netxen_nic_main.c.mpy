{
  "module_name": "netxen_nic_main.c",
  "hash_id": "b689fe74998dd20803cbc3228bc870109694ac9a3029dae7286a5f71bc0cce9e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/qlogic/netxen/netxen_nic_main.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/interrupt.h>\n#include \"netxen_nic_hw.h\"\n\n#include \"netxen_nic.h\"\n\n#include <linux/dma-mapping.h>\n#include <linux/if_vlan.h>\n#include <net/ip.h>\n#include <linux/ipv6.h>\n#include <linux/inetdevice.h>\n#include <linux/sysfs.h>\n\nMODULE_DESCRIPTION(\"QLogic/NetXen (1/10) GbE Intelligent Ethernet Driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(NETXEN_NIC_LINUX_VERSIONID);\nMODULE_FIRMWARE(NX_UNIFIED_ROMIMAGE_NAME);\n\nchar netxen_nic_driver_name[] = \"netxen_nic\";\nstatic char netxen_nic_driver_string[] = \"QLogic/NetXen Network Driver v\"\n    NETXEN_NIC_LINUX_VERSIONID;\n\nstatic int port_mode = NETXEN_PORT_MODE_AUTO_NEG;\n\n \nstatic int wol_port_mode = 5;\n\nstatic int use_msi = 1;\n\nstatic int use_msi_x = 1;\n\nstatic int auto_fw_reset = AUTO_FW_RESET_ENABLED;\nmodule_param(auto_fw_reset, int, 0644);\nMODULE_PARM_DESC(auto_fw_reset,\"Auto firmware reset (0=disabled, 1=enabled\");\n\nstatic int netxen_nic_probe(struct pci_dev *pdev,\n\t\tconst struct pci_device_id *ent);\nstatic void netxen_nic_remove(struct pci_dev *pdev);\nstatic int netxen_nic_open(struct net_device *netdev);\nstatic int netxen_nic_close(struct net_device *netdev);\nstatic netdev_tx_t netxen_nic_xmit_frame(struct sk_buff *,\n\t\t\t\t\t       struct net_device *);\nstatic void netxen_tx_timeout(struct net_device *netdev, unsigned int txqueue);\nstatic void netxen_tx_timeout_task(struct work_struct *work);\nstatic void netxen_fw_poll_work(struct work_struct *work);\nstatic void netxen_schedule_work(struct netxen_adapter *adapter,\n\t\twork_func_t func, int delay);\nstatic void netxen_cancel_fw_work(struct netxen_adapter *adapter);\nstatic int netxen_nic_poll(struct napi_struct *napi, int budget);\n\nstatic void netxen_create_sysfs_entries(struct netxen_adapter *adapter);\nstatic void netxen_remove_sysfs_entries(struct netxen_adapter *adapter);\nstatic void netxen_create_diag_entries(struct netxen_adapter *adapter);\nstatic void netxen_remove_diag_entries(struct netxen_adapter *adapter);\nstatic int nx_dev_request_aer(struct netxen_adapter *adapter);\nstatic int nx_decr_dev_ref_cnt(struct netxen_adapter *adapter);\nstatic int netxen_can_start_firmware(struct netxen_adapter *adapter);\n\nstatic irqreturn_t netxen_intr(int irq, void *data);\nstatic irqreturn_t netxen_msi_intr(int irq, void *data);\nstatic irqreturn_t netxen_msix_intr(int irq, void *data);\n\nstatic void netxen_free_ip_list(struct netxen_adapter *, bool);\nstatic void netxen_restore_indev_addr(struct net_device *dev, unsigned long);\nstatic void netxen_nic_get_stats(struct net_device *dev,\n\t\t\t\t struct rtnl_link_stats64 *stats);\nstatic int netxen_nic_set_mac(struct net_device *netdev, void *p);\n\n \n#define ENTRY(device) \\\n\t{PCI_DEVICE(PCI_VENDOR_ID_NETXEN, (device)), \\\n\t.class = PCI_CLASS_NETWORK_ETHERNET << 8, .class_mask = ~0}\n\nstatic const struct pci_device_id netxen_pci_tbl[] = {\n\tENTRY(PCI_DEVICE_ID_NX2031_10GXSR),\n\tENTRY(PCI_DEVICE_ID_NX2031_10GCX4),\n\tENTRY(PCI_DEVICE_ID_NX2031_4GCU),\n\tENTRY(PCI_DEVICE_ID_NX2031_IMEZ),\n\tENTRY(PCI_DEVICE_ID_NX2031_HMEZ),\n\tENTRY(PCI_DEVICE_ID_NX2031_XG_MGMT),\n\tENTRY(PCI_DEVICE_ID_NX2031_XG_MGMT2),\n\tENTRY(PCI_DEVICE_ID_NX3031),\n\t{0,}\n};\n\nMODULE_DEVICE_TABLE(pci, netxen_pci_tbl);\n\nstatic uint32_t crb_cmd_producer[4] = {\n\tCRB_CMD_PRODUCER_OFFSET, CRB_CMD_PRODUCER_OFFSET_1,\n\tCRB_CMD_PRODUCER_OFFSET_2, CRB_CMD_PRODUCER_OFFSET_3\n};\n\nvoid\nnetxen_nic_update_cmd_producer(struct netxen_adapter *adapter,\n\t\tstruct nx_host_tx_ring *tx_ring)\n{\n\tNXWRIO(adapter, tx_ring->crb_cmd_producer, tx_ring->producer);\n}\n\nstatic uint32_t crb_cmd_consumer[4] = {\n\tCRB_CMD_CONSUMER_OFFSET, CRB_CMD_CONSUMER_OFFSET_1,\n\tCRB_CMD_CONSUMER_OFFSET_2, CRB_CMD_CONSUMER_OFFSET_3\n};\n\nstatic inline void\nnetxen_nic_update_cmd_consumer(struct netxen_adapter *adapter,\n\t\tstruct nx_host_tx_ring *tx_ring)\n{\n\tNXWRIO(adapter, tx_ring->crb_cmd_consumer, tx_ring->sw_consumer);\n}\n\nstatic uint32_t msi_tgt_status[8] = {\n\tISR_INT_TARGET_STATUS, ISR_INT_TARGET_STATUS_F1,\n\tISR_INT_TARGET_STATUS_F2, ISR_INT_TARGET_STATUS_F3,\n\tISR_INT_TARGET_STATUS_F4, ISR_INT_TARGET_STATUS_F5,\n\tISR_INT_TARGET_STATUS_F6, ISR_INT_TARGET_STATUS_F7\n};\n\nstatic struct netxen_legacy_intr_set legacy_intr[] = NX_LEGACY_INTR_CONFIG;\n\nstatic inline void netxen_nic_disable_int(struct nx_host_sds_ring *sds_ring)\n{\n\tstruct netxen_adapter *adapter = sds_ring->adapter;\n\n\tNXWRIO(adapter, sds_ring->crb_intr_mask, 0);\n}\n\nstatic inline void netxen_nic_enable_int(struct nx_host_sds_ring *sds_ring)\n{\n\tstruct netxen_adapter *adapter = sds_ring->adapter;\n\n\tNXWRIO(adapter, sds_ring->crb_intr_mask, 0x1);\n\n\tif (!NETXEN_IS_MSI_FAMILY(adapter))\n\t\tNXWRIO(adapter, adapter->tgt_mask_reg, 0xfbff);\n}\n\nstatic int\nnetxen_alloc_sds_rings(struct netxen_recv_context *recv_ctx, int count)\n{\n\tint size = sizeof(struct nx_host_sds_ring) * count;\n\n\trecv_ctx->sds_rings = kzalloc(size, GFP_KERNEL);\n\n\treturn recv_ctx->sds_rings == NULL;\n}\n\nstatic void\nnetxen_free_sds_rings(struct netxen_recv_context *recv_ctx)\n{\n\tkfree(recv_ctx->sds_rings);\n\trecv_ctx->sds_rings = NULL;\n}\n\nstatic int\nnetxen_napi_add(struct netxen_adapter *adapter, struct net_device *netdev)\n{\n\tint ring;\n\tstruct nx_host_sds_ring *sds_ring;\n\tstruct netxen_recv_context *recv_ctx = &adapter->recv_ctx;\n\n\tif (netxen_alloc_sds_rings(recv_ctx, adapter->max_sds_rings))\n\t\treturn -ENOMEM;\n\n\tfor (ring = 0; ring < adapter->max_sds_rings; ring++) {\n\t\tsds_ring = &recv_ctx->sds_rings[ring];\n\t\tnetif_napi_add(netdev, &sds_ring->napi, netxen_nic_poll);\n\t}\n\n\treturn 0;\n}\n\nstatic void\nnetxen_napi_del(struct netxen_adapter *adapter)\n{\n\tint ring;\n\tstruct nx_host_sds_ring *sds_ring;\n\tstruct netxen_recv_context *recv_ctx = &adapter->recv_ctx;\n\n\tfor (ring = 0; ring < adapter->max_sds_rings; ring++) {\n\t\tsds_ring = &recv_ctx->sds_rings[ring];\n\t\tnetif_napi_del(&sds_ring->napi);\n\t}\n\n\tnetxen_free_sds_rings(&adapter->recv_ctx);\n}\n\nstatic void\nnetxen_napi_enable(struct netxen_adapter *adapter)\n{\n\tint ring;\n\tstruct nx_host_sds_ring *sds_ring;\n\tstruct netxen_recv_context *recv_ctx = &adapter->recv_ctx;\n\n\tfor (ring = 0; ring < adapter->max_sds_rings; ring++) {\n\t\tsds_ring = &recv_ctx->sds_rings[ring];\n\t\tnapi_enable(&sds_ring->napi);\n\t\tnetxen_nic_enable_int(sds_ring);\n\t}\n}\n\nstatic void\nnetxen_napi_disable(struct netxen_adapter *adapter)\n{\n\tint ring;\n\tstruct nx_host_sds_ring *sds_ring;\n\tstruct netxen_recv_context *recv_ctx = &adapter->recv_ctx;\n\n\tfor (ring = 0; ring < adapter->max_sds_rings; ring++) {\n\t\tsds_ring = &recv_ctx->sds_rings[ring];\n\t\tnetxen_nic_disable_int(sds_ring);\n\t\tnapi_synchronize(&sds_ring->napi);\n\t\tnapi_disable(&sds_ring->napi);\n\t}\n}\n\nstatic int nx_set_dma_mask(struct netxen_adapter *adapter)\n{\n\tstruct pci_dev *pdev = adapter->pdev;\n\tuint64_t mask, cmask;\n\n\tadapter->pci_using_dac = 0;\n\n\tmask = DMA_BIT_MASK(32);\n\tcmask = DMA_BIT_MASK(32);\n\n\tif (NX_IS_REVISION_P2(adapter->ahw.revision_id)) {\n#ifndef CONFIG_IA64\n\t\tmask = DMA_BIT_MASK(35);\n#endif\n\t} else {\n\t\tmask = DMA_BIT_MASK(39);\n\t\tcmask = mask;\n\t}\n\n\tif (dma_set_mask(&pdev->dev, mask) == 0 &&\n\t    dma_set_coherent_mask(&pdev->dev, cmask) == 0) {\n\t\tadapter->pci_using_dac = 1;\n\t\treturn 0;\n\t}\n\n\treturn -EIO;\n}\n\n \nstatic int\nnx_update_dma_mask(struct netxen_adapter *adapter)\n{\n\tint change, shift, err;\n\tuint64_t mask, old_mask, old_cmask;\n\tstruct pci_dev *pdev = adapter->pdev;\n\n\tchange = 0;\n\n\tshift = NXRD32(adapter, CRB_DMA_SHIFT);\n\tif (shift > 32)\n\t\treturn 0;\n\n\tif (NX_IS_REVISION_P3(adapter->ahw.revision_id) && (shift > 9))\n\t\tchange = 1;\n\telse if ((adapter->ahw.revision_id == NX_P2_C1) && (shift <= 4))\n\t\tchange = 1;\n\n\tif (change) {\n\t\told_mask = pdev->dma_mask;\n\t\told_cmask = pdev->dev.coherent_dma_mask;\n\n\t\tmask = DMA_BIT_MASK(32+shift);\n\n\t\terr = dma_set_mask(&pdev->dev, mask);\n\t\tif (err)\n\t\t\tgoto err_out;\n\n\t\tif (NX_IS_REVISION_P3(adapter->ahw.revision_id)) {\n\n\t\t\terr = dma_set_coherent_mask(&pdev->dev, mask);\n\t\t\tif (err)\n\t\t\t\tgoto err_out;\n\t\t}\n\t\tdev_info(&pdev->dev, \"using %d-bit dma mask\\n\", 32+shift);\n\t}\n\n\treturn 0;\n\nerr_out:\n\tdma_set_mask(&pdev->dev, old_mask);\n\tdma_set_coherent_mask(&pdev->dev, old_cmask);\n\treturn err;\n}\n\nstatic int\nnetxen_check_hw_init(struct netxen_adapter *adapter, int first_boot)\n{\n\tu32 val, timeout;\n\n\tif (first_boot == 0x55555555) {\n\t\t \n\t\tNXWR32(adapter, NETXEN_CAM_RAM(0x1fc), NETXEN_BDINFO_MAGIC);\n\n\t\tif (!NX_IS_REVISION_P2(adapter->ahw.revision_id))\n\t\t\treturn 0;\n\n\t\t \n\t\tfirst_boot = NXRD32(adapter, NETXEN_PCIE_REG(0x4));\n\t\tif (!(first_boot & 0x4)) {\n\t\t\tfirst_boot |= 0x4;\n\t\t\tNXWR32(adapter, NETXEN_PCIE_REG(0x4), first_boot);\n\t\t\tNXRD32(adapter, NETXEN_PCIE_REG(0x4));\n\t\t}\n\n\t\t \n\t\tfirst_boot = NXRD32(adapter, NETXEN_ROMUSB_GLB_SW_RESET);\n\t\tif (first_boot != 0x80000f) {\n\t\t\t \n\t\t\tNXWR32(adapter, NETXEN_CAM_RAM(0x1fc), 0);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\t \n\t\tval = NXRD32(adapter, NETXEN_ROMUSB_GLB_PEGTUNE_DONE);\n\t\tNXWR32(adapter, NETXEN_ROMUSB_GLB_PEGTUNE_DONE, val | 0x1);\n\t\ttimeout = 0;\n\t\tdo {\n\t\t\tmsleep(1);\n\t\t\tval = NXRD32(adapter, NETXEN_CAM_RAM(0x1fc));\n\n\t\t\tif (++timeout > 5000)\n\t\t\t\treturn -EIO;\n\n\t\t} while (val == NETXEN_BDINFO_MAGIC);\n\t}\n\treturn 0;\n}\n\nstatic void netxen_set_port_mode(struct netxen_adapter *adapter)\n{\n\tu32 val, data;\n\n\tval = adapter->ahw.board_type;\n\tif ((val == NETXEN_BRDTYPE_P3_HMEZ) ||\n\t\t(val == NETXEN_BRDTYPE_P3_XG_LOM)) {\n\t\tif (port_mode == NETXEN_PORT_MODE_802_3_AP) {\n\t\t\tdata = NETXEN_PORT_MODE_802_3_AP;\n\t\t\tNXWR32(adapter, NETXEN_PORT_MODE_ADDR, data);\n\t\t} else if (port_mode == NETXEN_PORT_MODE_XG) {\n\t\t\tdata = NETXEN_PORT_MODE_XG;\n\t\t\tNXWR32(adapter, NETXEN_PORT_MODE_ADDR, data);\n\t\t} else if (port_mode == NETXEN_PORT_MODE_AUTO_NEG_1G) {\n\t\t\tdata = NETXEN_PORT_MODE_AUTO_NEG_1G;\n\t\t\tNXWR32(adapter, NETXEN_PORT_MODE_ADDR, data);\n\t\t} else if (port_mode == NETXEN_PORT_MODE_AUTO_NEG_XG) {\n\t\t\tdata = NETXEN_PORT_MODE_AUTO_NEG_XG;\n\t\t\tNXWR32(adapter, NETXEN_PORT_MODE_ADDR, data);\n\t\t} else {\n\t\t\tdata = NETXEN_PORT_MODE_AUTO_NEG;\n\t\t\tNXWR32(adapter, NETXEN_PORT_MODE_ADDR, data);\n\t\t}\n\n\t\tif ((wol_port_mode != NETXEN_PORT_MODE_802_3_AP) &&\n\t\t\t(wol_port_mode != NETXEN_PORT_MODE_XG) &&\n\t\t\t(wol_port_mode != NETXEN_PORT_MODE_AUTO_NEG_1G) &&\n\t\t\t(wol_port_mode != NETXEN_PORT_MODE_AUTO_NEG_XG)) {\n\t\t\twol_port_mode = NETXEN_PORT_MODE_AUTO_NEG;\n\t\t}\n\t\tNXWR32(adapter, NETXEN_WOL_PORT_MODE, wol_port_mode);\n\t}\n}\n\n#define PCI_CAP_ID_GEN  0x10\n\nstatic void netxen_pcie_strap_init(struct netxen_adapter *adapter)\n{\n\tu32 pdevfuncsave;\n\tu32 c8c9value = 0;\n\tu32 chicken = 0;\n\tu32 control = 0;\n\tint i, pos;\n\tstruct pci_dev *pdev;\n\n\tpdev = adapter->pdev;\n\n\tchicken = NXRD32(adapter, NETXEN_PCIE_REG(PCIE_CHICKEN3));\n\t \n\tchicken &= 0xFCFFFFFF;\n\t \n\tpos = pci_find_capability(pdev, PCI_CAP_ID_GEN);\n\tif (pos == 0xC0) {\n\t\tpci_read_config_dword(pdev, pos + 0x10, &control);\n\t\tif ((control & 0x000F0000) != 0x00020000) {\n\t\t\t \n\t\t\tchicken |= 0x01000000;\n\t\t}\n\t\tdev_info(&adapter->pdev->dev, \"Gen2 strapping detected\\n\");\n\t\tc8c9value = 0xF1000;\n\t} else {\n\t\t \n\t\tchicken |= 0x01000000;\n\t\tdev_info(&adapter->pdev->dev, \"Gen1 strapping detected\\n\");\n\t\tif (adapter->ahw.revision_id == NX_P3_B0)\n\t\t\tc8c9value = 0xF1020;\n\t\telse\n\t\t\tc8c9value = 0;\n\t}\n\n\tNXWR32(adapter, NETXEN_PCIE_REG(PCIE_CHICKEN3), chicken);\n\n\tif (!c8c9value)\n\t\treturn;\n\n\tpdevfuncsave = pdev->devfn;\n\tif (pdevfuncsave & 0x07)\n\t\treturn;\n\n\tfor (i = 0; i < 8; i++) {\n\t\tpci_read_config_dword(pdev, pos + 8, &control);\n\t\tpci_read_config_dword(pdev, pos + 8, &control);\n\t\tpci_write_config_dword(pdev, pos + 8, c8c9value);\n\t\tpdev->devfn++;\n\t}\n\tpdev->devfn = pdevfuncsave;\n}\n\nstatic void netxen_set_msix_bit(struct pci_dev *pdev, int enable)\n{\n\tu32 control;\n\n\tif (pdev->msix_cap) {\n\t\tpci_read_config_dword(pdev, pdev->msix_cap, &control);\n\t\tif (enable)\n\t\t\tcontrol |= PCI_MSIX_FLAGS_ENABLE;\n\t\telse\n\t\t\tcontrol = 0;\n\t\tpci_write_config_dword(pdev, pdev->msix_cap, control);\n\t}\n}\n\nstatic void netxen_init_msix_entries(struct netxen_adapter *adapter, int count)\n{\n\tint i;\n\n\tfor (i = 0; i < count; i++)\n\t\tadapter->msix_entries[i].entry = i;\n}\n\nstatic int\nnetxen_read_mac_addr(struct netxen_adapter *adapter)\n{\n\tint i;\n\tunsigned char *p;\n\tu64 mac_addr;\n\tstruct net_device *netdev = adapter->netdev;\n\tstruct pci_dev *pdev = adapter->pdev;\n\tu8 addr[ETH_ALEN];\n\n\tif (NX_IS_REVISION_P3(adapter->ahw.revision_id)) {\n\t\tif (netxen_p3_get_mac_addr(adapter, &mac_addr) != 0)\n\t\t\treturn -EIO;\n\t} else {\n\t\tif (netxen_get_flash_mac_addr(adapter, &mac_addr) != 0)\n\t\t\treturn -EIO;\n\t}\n\n\tp = (unsigned char *)&mac_addr;\n\tfor (i = 0; i < 6; i++)\n\t\taddr[i] = *(p + 5 - i);\n\teth_hw_addr_set(netdev, addr);\n\n\tmemcpy(adapter->mac_addr, netdev->dev_addr, netdev->addr_len);\n\n\t \n\n\tif (!is_valid_ether_addr(netdev->dev_addr))\n\t\tdev_warn(&pdev->dev, \"Bad MAC address %pM.\\n\", netdev->dev_addr);\n\n\treturn 0;\n}\n\nstatic int netxen_nic_set_mac(struct net_device *netdev, void *p)\n{\n\tstruct netxen_adapter *adapter = netdev_priv(netdev);\n\tstruct sockaddr *addr = p;\n\n\tif (!is_valid_ether_addr(addr->sa_data))\n\t\treturn -EADDRNOTAVAIL;\n\n\tif (netif_running(netdev)) {\n\t\tnetif_device_detach(netdev);\n\t\tnetxen_napi_disable(adapter);\n\t}\n\n\tmemcpy(adapter->mac_addr, addr->sa_data, netdev->addr_len);\n\teth_hw_addr_set(netdev, addr->sa_data);\n\tadapter->macaddr_set(adapter, addr->sa_data);\n\n\tif (netif_running(netdev)) {\n\t\tnetif_device_attach(netdev);\n\t\tnetxen_napi_enable(adapter);\n\t}\n\treturn 0;\n}\n\nstatic void netxen_set_multicast_list(struct net_device *dev)\n{\n\tstruct netxen_adapter *adapter = netdev_priv(dev);\n\n\tadapter->set_multi(dev);\n}\n\nstatic netdev_features_t netxen_fix_features(struct net_device *dev,\n\tnetdev_features_t features)\n{\n\tif (!(features & NETIF_F_RXCSUM)) {\n\t\tnetdev_info(dev, \"disabling LRO as RXCSUM is off\\n\");\n\n\t\tfeatures &= ~NETIF_F_LRO;\n\t}\n\n\treturn features;\n}\n\nstatic int netxen_set_features(struct net_device *dev,\n\tnetdev_features_t features)\n{\n\tstruct netxen_adapter *adapter = netdev_priv(dev);\n\tint hw_lro;\n\n\tif (!((dev->features ^ features) & NETIF_F_LRO))\n\t\treturn 0;\n\n\thw_lro = (features & NETIF_F_LRO) ? NETXEN_NIC_LRO_ENABLED\n\t         : NETXEN_NIC_LRO_DISABLED;\n\n\tif (netxen_config_hw_lro(adapter, hw_lro))\n\t\treturn -EIO;\n\n\tif (!(features & NETIF_F_LRO) && netxen_send_lro_cleanup(adapter))\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic const struct net_device_ops netxen_netdev_ops = {\n\t.ndo_open\t   = netxen_nic_open,\n\t.ndo_stop\t   = netxen_nic_close,\n\t.ndo_start_xmit    = netxen_nic_xmit_frame,\n\t.ndo_get_stats64   = netxen_nic_get_stats,\n\t.ndo_validate_addr = eth_validate_addr,\n\t.ndo_set_rx_mode   = netxen_set_multicast_list,\n\t.ndo_set_mac_address    = netxen_nic_set_mac,\n\t.ndo_change_mtu\t   = netxen_nic_change_mtu,\n\t.ndo_tx_timeout\t   = netxen_tx_timeout,\n\t.ndo_fix_features = netxen_fix_features,\n\t.ndo_set_features = netxen_set_features,\n};\n\nstatic inline void netxen_set_interrupt_mode(struct netxen_adapter *adapter,\n\t\t\t\t\t     u32 mode)\n{\n\tNXWR32(adapter, NETXEN_INTR_MODE_REG, mode);\n}\n\nstatic inline u32 netxen_get_interrupt_mode(struct netxen_adapter *adapter)\n{\n\treturn NXRD32(adapter, NETXEN_INTR_MODE_REG);\n}\n\nstatic void\nnetxen_initialize_interrupt_registers(struct netxen_adapter *adapter)\n{\n\tstruct netxen_legacy_intr_set *legacy_intrp;\n\tu32 tgt_status_reg, int_state_reg;\n\n\tif (adapter->ahw.revision_id >= NX_P3_B0)\n\t\tlegacy_intrp = &legacy_intr[adapter->ahw.pci_func];\n\telse\n\t\tlegacy_intrp = &legacy_intr[0];\n\n\ttgt_status_reg = legacy_intrp->tgt_status_reg;\n\tint_state_reg = ISR_INT_STATE_REG;\n\n\tadapter->int_vec_bit = legacy_intrp->int_vec_bit;\n\tadapter->tgt_status_reg = netxen_get_ioaddr(adapter, tgt_status_reg);\n\tadapter->tgt_mask_reg = netxen_get_ioaddr(adapter,\n\t\t\t\t\t\t  legacy_intrp->tgt_mask_reg);\n\tadapter->pci_int_reg = netxen_get_ioaddr(adapter,\n\t\t\t\t\t\t legacy_intrp->pci_int_reg);\n\tadapter->isr_int_vec = netxen_get_ioaddr(adapter, ISR_INT_VECTOR);\n\n\tif (adapter->ahw.revision_id >= NX_P3_B1)\n\t\tadapter->crb_int_state_reg = netxen_get_ioaddr(adapter,\n\t\t\t\t\t\t\t       int_state_reg);\n\telse\n\t\tadapter->crb_int_state_reg = netxen_get_ioaddr(adapter,\n\t\t\t\t\t\t\t       CRB_INT_VECTOR);\n}\n\nstatic int netxen_setup_msi_interrupts(struct netxen_adapter *adapter,\n\t\t\t\t       int num_msix)\n{\n\tstruct pci_dev *pdev = adapter->pdev;\n\tu32 value;\n\tint err;\n\n\tif (adapter->msix_supported) {\n\t\tnetxen_init_msix_entries(adapter, num_msix);\n\t\terr = pci_enable_msix_range(pdev, adapter->msix_entries,\n\t\t\t\t\t    num_msix, num_msix);\n\t\tif (err > 0) {\n\t\t\tadapter->flags |= NETXEN_NIC_MSIX_ENABLED;\n\t\t\tnetxen_set_msix_bit(pdev, 1);\n\n\t\t\tif (adapter->rss_supported)\n\t\t\t\tadapter->max_sds_rings = num_msix;\n\n\t\t\tdev_info(&pdev->dev, \"using msi-x interrupts\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\t \n\t}\n\n\tif (use_msi && !pci_enable_msi(pdev)) {\n\t\tvalue = msi_tgt_status[adapter->ahw.pci_func];\n\t\tadapter->flags |= NETXEN_NIC_MSI_ENABLED;\n\t\tadapter->tgt_status_reg = netxen_get_ioaddr(adapter, value);\n\t\tadapter->msix_entries[0].vector = pdev->irq;\n\t\tdev_info(&pdev->dev, \"using msi interrupts\\n\");\n\t\treturn 0;\n\t}\n\n\tdev_err(&pdev->dev, \"Failed to acquire MSI-X/MSI interrupt vector\\n\");\n\treturn -EIO;\n}\n\nstatic int netxen_setup_intr(struct netxen_adapter *adapter)\n{\n\tstruct pci_dev *pdev = adapter->pdev;\n\tint num_msix;\n\n\tif (adapter->rss_supported)\n\t\tnum_msix = (num_online_cpus() >= MSIX_ENTRIES_PER_ADAPTER) ?\n\t\t\t    MSIX_ENTRIES_PER_ADAPTER : 2;\n\telse\n\t\tnum_msix = 1;\n\n\tadapter->max_sds_rings = 1;\n\tadapter->flags &= ~(NETXEN_NIC_MSI_ENABLED | NETXEN_NIC_MSIX_ENABLED);\n\n\tnetxen_initialize_interrupt_registers(adapter);\n\tnetxen_set_msix_bit(pdev, 0);\n\n\tif (adapter->portnum == 0) {\n\t\tif (!netxen_setup_msi_interrupts(adapter, num_msix))\n\t\t\tnetxen_set_interrupt_mode(adapter, NETXEN_MSI_MODE);\n\t\telse\n\t\t\tnetxen_set_interrupt_mode(adapter, NETXEN_INTX_MODE);\n\t} else {\n\t\tif (netxen_get_interrupt_mode(adapter) == NETXEN_MSI_MODE &&\n\t\t    netxen_setup_msi_interrupts(adapter, num_msix)) {\n\t\t\tdev_err(&pdev->dev, \"Co-existence of MSI-X/MSI and INTx interrupts is not supported\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\tif (!NETXEN_IS_MSI_FAMILY(adapter)) {\n\t\tadapter->msix_entries[0].vector = pdev->irq;\n\t\tdev_info(&pdev->dev, \"using legacy interrupts\\n\");\n\t}\n\treturn 0;\n}\n\nstatic void\nnetxen_teardown_intr(struct netxen_adapter *adapter)\n{\n\tif (adapter->flags & NETXEN_NIC_MSIX_ENABLED)\n\t\tpci_disable_msix(adapter->pdev);\n\tif (adapter->flags & NETXEN_NIC_MSI_ENABLED)\n\t\tpci_disable_msi(adapter->pdev);\n}\n\nstatic void\nnetxen_cleanup_pci_map(struct netxen_adapter *adapter)\n{\n\tif (adapter->ahw.db_base != NULL)\n\t\tiounmap(adapter->ahw.db_base);\n\tif (adapter->ahw.pci_base0 != NULL)\n\t\tiounmap(adapter->ahw.pci_base0);\n\tif (adapter->ahw.pci_base1 != NULL)\n\t\tiounmap(adapter->ahw.pci_base1);\n\tif (adapter->ahw.pci_base2 != NULL)\n\t\tiounmap(adapter->ahw.pci_base2);\n}\n\nstatic int\nnetxen_setup_pci_map(struct netxen_adapter *adapter)\n{\n\tvoid __iomem *db_ptr = NULL;\n\n\tresource_size_t mem_base, db_base;\n\tunsigned long mem_len, db_len = 0;\n\n\tstruct pci_dev *pdev = adapter->pdev;\n\tint pci_func = adapter->ahw.pci_func;\n\tstruct netxen_hardware_context *ahw = &adapter->ahw;\n\n\tint err = 0;\n\n\t \n\tadapter->ahw.crb_win = -1;\n\tadapter->ahw.ocm_win = -1;\n\n\t \n\tmem_base = pci_resource_start(pdev, 0);\t \n\tmem_len = pci_resource_len(pdev, 0);\n\n\t \n\tif (mem_len == NETXEN_PCI_128MB_SIZE) {\n\n\t\tahw->pci_base0 = ioremap(mem_base, FIRST_PAGE_GROUP_SIZE);\n\t\tahw->pci_base1 = ioremap(mem_base + SECOND_PAGE_GROUP_START,\n\t\t\t\tSECOND_PAGE_GROUP_SIZE);\n\t\tahw->pci_base2 = ioremap(mem_base + THIRD_PAGE_GROUP_START,\n\t\t\t\tTHIRD_PAGE_GROUP_SIZE);\n\t\tif (ahw->pci_base0 == NULL || ahw->pci_base1 == NULL ||\n\t\t\t\t\t\tahw->pci_base2 == NULL) {\n\t\t\tdev_err(&pdev->dev, \"failed to map PCI bar 0\\n\");\n\t\t\terr = -EIO;\n\t\t\tgoto err_out;\n\t\t}\n\n\t\tahw->pci_len0 = FIRST_PAGE_GROUP_SIZE;\n\n\t} else if (mem_len == NETXEN_PCI_32MB_SIZE) {\n\n\t\tahw->pci_base1 = ioremap(mem_base, SECOND_PAGE_GROUP_SIZE);\n\t\tahw->pci_base2 = ioremap(mem_base + THIRD_PAGE_GROUP_START -\n\t\t\tSECOND_PAGE_GROUP_START, THIRD_PAGE_GROUP_SIZE);\n\t\tif (ahw->pci_base1 == NULL || ahw->pci_base2 == NULL) {\n\t\t\tdev_err(&pdev->dev, \"failed to map PCI bar 0\\n\");\n\t\t\terr = -EIO;\n\t\t\tgoto err_out;\n\t\t}\n\n\t} else if (mem_len == NETXEN_PCI_2MB_SIZE) {\n\n\t\tahw->pci_base0 = pci_ioremap_bar(pdev, 0);\n\t\tif (ahw->pci_base0 == NULL) {\n\t\t\tdev_err(&pdev->dev, \"failed to map PCI bar 0\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tahw->pci_len0 = mem_len;\n\t} else {\n\t\treturn -EIO;\n\t}\n\n\tnetxen_setup_hwops(adapter);\n\n\tdev_info(&pdev->dev, \"%dMB memory map\\n\", (int)(mem_len>>20));\n\n\tif (NX_IS_REVISION_P3P(adapter->ahw.revision_id)) {\n\t\tadapter->ahw.ocm_win_crb = netxen_get_ioaddr(adapter,\n\t\t\tNETXEN_PCIX_PS_REG(PCIX_OCM_WINDOW_REG(pci_func)));\n\n\t} else if (NX_IS_REVISION_P3(adapter->ahw.revision_id)) {\n\t\tadapter->ahw.ocm_win_crb = netxen_get_ioaddr(adapter,\n\t\t\tNETXEN_PCIX_PS_REG(PCIE_MN_WINDOW_REG(pci_func)));\n\t}\n\n\tif (NX_IS_REVISION_P3(adapter->ahw.revision_id))\n\t\tgoto skip_doorbell;\n\n\tdb_base = pci_resource_start(pdev, 4);\t \n\tdb_len = pci_resource_len(pdev, 4);\n\n\tif (db_len == 0) {\n\t\tprintk(KERN_ERR \"%s: doorbell is disabled\\n\",\n\t\t\t\tnetxen_nic_driver_name);\n\t\terr = -EIO;\n\t\tgoto err_out;\n\t}\n\n\tdb_ptr = ioremap(db_base, NETXEN_DB_MAPSIZE_BYTES);\n\tif (!db_ptr) {\n\t\tprintk(KERN_ERR \"%s: Failed to allocate doorbell map.\",\n\t\t\t\tnetxen_nic_driver_name);\n\t\terr = -EIO;\n\t\tgoto err_out;\n\t}\n\nskip_doorbell:\n\tadapter->ahw.db_base = db_ptr;\n\tadapter->ahw.db_len = db_len;\n\treturn 0;\n\nerr_out:\n\tnetxen_cleanup_pci_map(adapter);\n\treturn err;\n}\n\nstatic void\nnetxen_check_options(struct netxen_adapter *adapter)\n{\n\tu32 fw_major, fw_minor, fw_build, prev_fw_version;\n\tchar brd_name[NETXEN_MAX_SHORT_NAME];\n\tchar serial_num[32];\n\tint i, offset, val, err;\n\t__le32 *ptr32;\n\tstruct pci_dev *pdev = adapter->pdev;\n\n\tadapter->driver_mismatch = 0;\n\n\tptr32 = (__le32 *)&serial_num;\n\toffset = NX_FW_SERIAL_NUM_OFFSET;\n\tfor (i = 0; i < 8; i++) {\n\t\terr = netxen_rom_fast_read(adapter, offset, &val);\n\t\tif (err) {\n\t\t\tdev_err(&pdev->dev, \"error reading board info\\n\");\n\t\t\tadapter->driver_mismatch = 1;\n\t\t\treturn;\n\t\t}\n\t\tptr32[i] = cpu_to_le32(val);\n\t\toffset += sizeof(u32);\n\t}\n\n\tfw_major = NXRD32(adapter, NETXEN_FW_VERSION_MAJOR);\n\tfw_minor = NXRD32(adapter, NETXEN_FW_VERSION_MINOR);\n\tfw_build = NXRD32(adapter, NETXEN_FW_VERSION_SUB);\n\tprev_fw_version = adapter->fw_version;\n\tadapter->fw_version = NETXEN_VERSION_CODE(fw_major, fw_minor, fw_build);\n\n\t \n\tif (NX_IS_REVISION_P3(adapter->ahw.revision_id)) {\n\t\tif (adapter->mdump.md_template == NULL ||\n\t\t\t\tadapter->fw_version > prev_fw_version) {\n\t\t\tkfree(adapter->mdump.md_template);\n\t\t\tadapter->mdump.md_template = NULL;\n\t\t\terr = netxen_setup_minidump(adapter);\n\t\t\tif (err)\n\t\t\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\t\"Failed to setup minidump rcode = %d\\n\", err);\n\t\t}\n\t}\n\n\tif (adapter->portnum == 0) {\n\t\tif (netxen_nic_get_brd_name_by_type(adapter->ahw.board_type,\n\t\t\t\t\t\t    brd_name))\n\t\t\tstrcpy(serial_num, \"Unknown\");\n\n\t\tpr_info(\"%s: %s Board S/N %s  Chip rev 0x%x\\n\",\n\t\t\t\tmodule_name(THIS_MODULE),\n\t\t\t\tbrd_name, serial_num, adapter->ahw.revision_id);\n\t}\n\n\tif (adapter->fw_version < NETXEN_VERSION_CODE(3, 4, 216)) {\n\t\tadapter->driver_mismatch = 1;\n\t\tdev_warn(&pdev->dev, \"firmware version %d.%d.%d unsupported\\n\",\n\t\t\t\tfw_major, fw_minor, fw_build);\n\t\treturn;\n\t}\n\n\tif (NX_IS_REVISION_P3(adapter->ahw.revision_id)) {\n\t\ti = NXRD32(adapter, NETXEN_SRE_MISC);\n\t\tadapter->ahw.cut_through = (i & 0x8000) ? 1 : 0;\n\t}\n\n\tdev_info(&pdev->dev, \"Driver v%s, firmware v%d.%d.%d [%s]\\n\",\n\t\t NETXEN_NIC_LINUX_VERSIONID, fw_major, fw_minor, fw_build,\n\t\t adapter->ahw.cut_through ? \"cut-through\" : \"legacy\");\n\n\tif (adapter->fw_version >= NETXEN_VERSION_CODE(4, 0, 222))\n\t\tadapter->capabilities = NXRD32(adapter, CRB_FW_CAPABILITIES_1);\n\n\tif (adapter->ahw.port_type == NETXEN_NIC_XGBE) {\n\t\tadapter->num_rxd = DEFAULT_RCV_DESCRIPTORS_10G;\n\t\tadapter->num_jumbo_rxd = MAX_JUMBO_RCV_DESCRIPTORS_10G;\n\t} else if (adapter->ahw.port_type == NETXEN_NIC_GBE) {\n\t\tadapter->num_rxd = DEFAULT_RCV_DESCRIPTORS_1G;\n\t\tadapter->num_jumbo_rxd = MAX_JUMBO_RCV_DESCRIPTORS_1G;\n\t}\n\n\tadapter->msix_supported = 0;\n\tif (NX_IS_REVISION_P3(adapter->ahw.revision_id)) {\n\t\tadapter->msix_supported = !!use_msi_x;\n\t\tadapter->rss_supported = !!use_msi_x;\n\t} else {\n\t\tu32 flashed_ver = 0;\n\t\tnetxen_rom_fast_read(adapter,\n\t\t\t\tNX_FW_VERSION_OFFSET, (int *)&flashed_ver);\n\t\tflashed_ver = NETXEN_DECODE_VERSION(flashed_ver);\n\n\t\tif (flashed_ver >= NETXEN_VERSION_CODE(3, 4, 336)) {\n\t\t\tswitch (adapter->ahw.board_type) {\n\t\t\tcase NETXEN_BRDTYPE_P2_SB31_10G:\n\t\t\tcase NETXEN_BRDTYPE_P2_SB31_10G_CX4:\n\t\t\t\tadapter->msix_supported = !!use_msi_x;\n\t\t\t\tadapter->rss_supported = !!use_msi_x;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tadapter->num_txd = MAX_CMD_DESCRIPTORS;\n\n\tif (NX_IS_REVISION_P2(adapter->ahw.revision_id)) {\n\t\tadapter->num_lro_rxd = MAX_LRO_RCV_DESCRIPTORS;\n\t\tadapter->max_rds_rings = 3;\n\t} else {\n\t\tadapter->num_lro_rxd = 0;\n\t\tadapter->max_rds_rings = 2;\n\t}\n}\n\nstatic int\nnetxen_start_firmware(struct netxen_adapter *adapter)\n{\n\tint val, err, first_boot;\n\tstruct pci_dev *pdev = adapter->pdev;\n\n\t \n\terr = nx_set_dma_mask(adapter);\n\tif (err)\n\t\treturn err;\n\n\terr = netxen_can_start_firmware(adapter);\n\n\tif (err < 0)\n\t\treturn err;\n\n\tif (!err)\n\t\tgoto wait_init;\n\n\tfirst_boot = NXRD32(adapter, NETXEN_CAM_RAM(0x1fc));\n\n\terr = netxen_check_hw_init(adapter, first_boot);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"error in init HW init sequence\\n\");\n\t\treturn err;\n\t}\n\n\tnetxen_request_firmware(adapter);\n\n\terr = netxen_need_fw_reset(adapter);\n\tif (err < 0)\n\t\tgoto err_out;\n\tif (err == 0)\n\t\tgoto pcie_strap_init;\n\n\tif (first_boot != 0x55555555) {\n\t\tNXWR32(adapter, CRB_CMDPEG_STATE, 0);\n\t\tnetxen_pinit_from_rom(adapter);\n\t\tmsleep(1);\n\t}\n\n\tNXWR32(adapter, CRB_DMA_SHIFT, 0x55555555);\n\tNXWR32(adapter, NETXEN_PEG_HALT_STATUS1, 0);\n\tNXWR32(adapter, NETXEN_PEG_HALT_STATUS2, 0);\n\n\tif (NX_IS_REVISION_P3(adapter->ahw.revision_id))\n\t\tnetxen_set_port_mode(adapter);\n\n\terr = netxen_load_firmware(adapter);\n\tif (err)\n\t\tgoto err_out;\n\n\tnetxen_release_firmware(adapter);\n\n\tif (NX_IS_REVISION_P2(adapter->ahw.revision_id)) {\n\n\t\t \n\t\tval = 0x7654;\n\t\tif (adapter->ahw.port_type == NETXEN_NIC_XGBE)\n\t\t\tval |= 0x0f000000;\n\t\tNXWR32(adapter, NETXEN_MAC_ADDR_CNTL_REG, val);\n\n\t}\n\n\terr = netxen_init_dummy_dma(adapter);\n\tif (err)\n\t\tgoto err_out;\n\n\t \n\tval = (_NETXEN_NIC_LINUX_MAJOR << 16)\n\t\t| ((_NETXEN_NIC_LINUX_MINOR << 8))\n\t\t| (_NETXEN_NIC_LINUX_SUBVERSION);\n\tNXWR32(adapter, CRB_DRIVER_VERSION, val);\n\npcie_strap_init:\n\tif (NX_IS_REVISION_P3(adapter->ahw.revision_id))\n\t\tnetxen_pcie_strap_init(adapter);\n\nwait_init:\n\t \n\terr = netxen_phantom_init(adapter, NETXEN_NIC_PEG_TUNE);\n\tif (err) {\n\t\tnetxen_free_dummy_dma(adapter);\n\t\tgoto err_out;\n\t}\n\n\tNXWR32(adapter, NX_CRB_DEV_STATE, NX_DEV_READY);\n\n\tnx_update_dma_mask(adapter);\n\n\tnetxen_check_options(adapter);\n\n\tadapter->need_fw_reset = 0;\n\n\t \n\nerr_out:\n\tnetxen_release_firmware(adapter);\n\treturn err;\n}\n\nstatic int\nnetxen_nic_request_irq(struct netxen_adapter *adapter)\n{\n\tirq_handler_t handler;\n\tstruct nx_host_sds_ring *sds_ring;\n\tint err, ring;\n\n\tunsigned long flags = 0;\n\tstruct net_device *netdev = adapter->netdev;\n\tstruct netxen_recv_context *recv_ctx = &adapter->recv_ctx;\n\n\tif (adapter->flags & NETXEN_NIC_MSIX_ENABLED)\n\t\thandler = netxen_msix_intr;\n\telse if (adapter->flags & NETXEN_NIC_MSI_ENABLED)\n\t\thandler = netxen_msi_intr;\n\telse {\n\t\tflags |= IRQF_SHARED;\n\t\thandler = netxen_intr;\n\t}\n\tadapter->irq = netdev->irq;\n\n\tfor (ring = 0; ring < adapter->max_sds_rings; ring++) {\n\t\tsds_ring = &recv_ctx->sds_rings[ring];\n\t\tsprintf(sds_ring->name, \"%s[%d]\", netdev->name, ring);\n\t\terr = request_irq(sds_ring->irq, handler,\n\t\t\t\t  flags, sds_ring->name, sds_ring);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic void\nnetxen_nic_free_irq(struct netxen_adapter *adapter)\n{\n\tint ring;\n\tstruct nx_host_sds_ring *sds_ring;\n\n\tstruct netxen_recv_context *recv_ctx = &adapter->recv_ctx;\n\n\tfor (ring = 0; ring < adapter->max_sds_rings; ring++) {\n\t\tsds_ring = &recv_ctx->sds_rings[ring];\n\t\tfree_irq(sds_ring->irq, sds_ring);\n\t}\n}\n\nstatic void\nnetxen_nic_init_coalesce_defaults(struct netxen_adapter *adapter)\n{\n\tadapter->coal.flags = NETXEN_NIC_INTR_DEFAULT;\n\tadapter->coal.normal.data.rx_time_us =\n\t\tNETXEN_DEFAULT_INTR_COALESCE_RX_TIME_US;\n\tadapter->coal.normal.data.rx_packets =\n\t\tNETXEN_DEFAULT_INTR_COALESCE_RX_PACKETS;\n\tadapter->coal.normal.data.tx_time_us =\n\t\tNETXEN_DEFAULT_INTR_COALESCE_TX_TIME_US;\n\tadapter->coal.normal.data.tx_packets =\n\t\tNETXEN_DEFAULT_INTR_COALESCE_TX_PACKETS;\n}\n\n \nstatic int\n__netxen_nic_up(struct netxen_adapter *adapter, struct net_device *netdev)\n{\n\tint err;\n\n\tif (adapter->is_up != NETXEN_ADAPTER_UP_MAGIC)\n\t\treturn -EIO;\n\n\terr = adapter->init_port(adapter, adapter->physical_port);\n\tif (err) {\n\t\tprintk(KERN_ERR \"%s: Failed to initialize port %d\\n\",\n\t\t\t\tnetxen_nic_driver_name, adapter->portnum);\n\t\treturn err;\n\t}\n\tif (NX_IS_REVISION_P2(adapter->ahw.revision_id))\n\t\tadapter->macaddr_set(adapter, adapter->mac_addr);\n\n\tadapter->set_multi(netdev);\n\tadapter->set_mtu(adapter, netdev->mtu);\n\n\tadapter->ahw.linkup = 0;\n\n\tif (adapter->max_sds_rings > 1)\n\t\tnetxen_config_rss(adapter, 1);\n\n\tif (NX_IS_REVISION_P3(adapter->ahw.revision_id))\n\t\tnetxen_config_intr_coalesce(adapter);\n\n\tif (netdev->features & NETIF_F_LRO)\n\t\tnetxen_config_hw_lro(adapter, NETXEN_NIC_LRO_ENABLED);\n\n\tnetxen_napi_enable(adapter);\n\n\tif (adapter->capabilities & NX_FW_CAPABILITY_LINK_NOTIFICATION)\n\t\tnetxen_linkevent_request(adapter, 1);\n\telse\n\t\tnetxen_nic_set_link_parameters(adapter);\n\n\tset_bit(__NX_DEV_UP, &adapter->state);\n\treturn 0;\n}\n\n \n\nstatic inline int\nnetxen_nic_up(struct netxen_adapter *adapter, struct net_device *netdev)\n{\n\tint err = 0;\n\n\trtnl_lock();\n\tif (netif_running(netdev))\n\t\terr = __netxen_nic_up(adapter, netdev);\n\trtnl_unlock();\n\n\treturn err;\n}\n\n \nstatic void\n__netxen_nic_down(struct netxen_adapter *adapter, struct net_device *netdev)\n{\n\tif (adapter->is_up != NETXEN_ADAPTER_UP_MAGIC)\n\t\treturn;\n\n\tif (!test_and_clear_bit(__NX_DEV_UP, &adapter->state))\n\t\treturn;\n\n\tsmp_mb();\n\tnetif_carrier_off(netdev);\n\tnetif_tx_disable(netdev);\n\n\tif (adapter->capabilities & NX_FW_CAPABILITY_LINK_NOTIFICATION)\n\t\tnetxen_linkevent_request(adapter, 0);\n\n\tif (adapter->stop_port)\n\t\tadapter->stop_port(adapter);\n\n\tif (NX_IS_REVISION_P3(adapter->ahw.revision_id))\n\t\tnetxen_p3_free_mac_list(adapter);\n\n\tadapter->set_promisc(adapter, NETXEN_NIU_NON_PROMISC_MODE);\n\n\tnetxen_napi_disable(adapter);\n\n\tnetxen_release_tx_buffers(adapter);\n}\n\n \n\nstatic inline void\nnetxen_nic_down(struct netxen_adapter *adapter, struct net_device *netdev)\n{\n\trtnl_lock();\n\tif (netif_running(netdev))\n\t\t__netxen_nic_down(adapter, netdev);\n\trtnl_unlock();\n\n}\n\nstatic int\nnetxen_nic_attach(struct netxen_adapter *adapter)\n{\n\tstruct net_device *netdev = adapter->netdev;\n\tstruct pci_dev *pdev = adapter->pdev;\n\tint err, ring;\n\tstruct nx_host_rds_ring *rds_ring;\n\tstruct nx_host_tx_ring *tx_ring;\n\tu32 capab2;\n\n\tif (adapter->is_up == NETXEN_ADAPTER_UP_MAGIC)\n\t\treturn 0;\n\n\terr = netxen_init_firmware(adapter);\n\tif (err)\n\t\treturn err;\n\n\tadapter->flags &= ~NETXEN_FW_MSS_CAP;\n\tif (adapter->capabilities & NX_FW_CAPABILITY_MORE_CAPS) {\n\t\tcapab2 = NXRD32(adapter, CRB_FW_CAPABILITIES_2);\n\t\tif (capab2 & NX_FW_CAPABILITY_2_LRO_MAX_TCP_SEG)\n\t\t\tadapter->flags |= NETXEN_FW_MSS_CAP;\n\t}\n\n\terr = netxen_napi_add(adapter, netdev);\n\tif (err)\n\t\treturn err;\n\n\terr = netxen_alloc_sw_resources(adapter);\n\tif (err) {\n\t\tprintk(KERN_ERR \"%s: Error in setting sw resources\\n\",\n\t\t\t\tnetdev->name);\n\t\treturn err;\n\t}\n\n\terr = netxen_alloc_hw_resources(adapter);\n\tif (err) {\n\t\tprintk(KERN_ERR \"%s: Error in setting hw resources\\n\",\n\t\t\t\tnetdev->name);\n\t\tgoto err_out_free_sw;\n\t}\n\n\tif (NX_IS_REVISION_P2(adapter->ahw.revision_id)) {\n\t\ttx_ring = adapter->tx_ring;\n\t\ttx_ring->crb_cmd_producer = netxen_get_ioaddr(adapter,\n\t\t\t\tcrb_cmd_producer[adapter->portnum]);\n\t\ttx_ring->crb_cmd_consumer = netxen_get_ioaddr(adapter,\n\t\t\t\tcrb_cmd_consumer[adapter->portnum]);\n\n\t\ttx_ring->producer = 0;\n\t\ttx_ring->sw_consumer = 0;\n\n\t\tnetxen_nic_update_cmd_producer(adapter, tx_ring);\n\t\tnetxen_nic_update_cmd_consumer(adapter, tx_ring);\n\t}\n\n\tfor (ring = 0; ring < adapter->max_rds_rings; ring++) {\n\t\trds_ring = &adapter->recv_ctx.rds_rings[ring];\n\t\tnetxen_post_rx_buffers(adapter, ring, rds_ring);\n\t}\n\n\terr = netxen_nic_request_irq(adapter);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"%s: failed to setup interrupt\\n\",\n\t\t\t\tnetdev->name);\n\t\tgoto err_out_free_rxbuf;\n\t}\n\n\tif (NX_IS_REVISION_P3(adapter->ahw.revision_id))\n\t\tnetxen_nic_init_coalesce_defaults(adapter);\n\n\tnetxen_create_sysfs_entries(adapter);\n\n\tadapter->is_up = NETXEN_ADAPTER_UP_MAGIC;\n\treturn 0;\n\nerr_out_free_rxbuf:\n\tnetxen_release_rx_buffers(adapter);\n\tnetxen_free_hw_resources(adapter);\nerr_out_free_sw:\n\tnetxen_free_sw_resources(adapter);\n\treturn err;\n}\n\nstatic void\nnetxen_nic_detach(struct netxen_adapter *adapter)\n{\n\tif (adapter->is_up != NETXEN_ADAPTER_UP_MAGIC)\n\t\treturn;\n\n\tnetxen_remove_sysfs_entries(adapter);\n\n\tnetxen_free_hw_resources(adapter);\n\tnetxen_release_rx_buffers(adapter);\n\tnetxen_nic_free_irq(adapter);\n\tnetxen_napi_del(adapter);\n\tnetxen_free_sw_resources(adapter);\n\n\tadapter->is_up = 0;\n}\n\nint\nnetxen_nic_reset_context(struct netxen_adapter *adapter)\n{\n\tint err = 0;\n\tstruct net_device *netdev = adapter->netdev;\n\n\tif (test_and_set_bit(__NX_RESETTING, &adapter->state))\n\t\treturn -EBUSY;\n\n\tif (adapter->is_up == NETXEN_ADAPTER_UP_MAGIC) {\n\n\t\tnetif_device_detach(netdev);\n\n\t\tif (netif_running(netdev))\n\t\t\t__netxen_nic_down(adapter, netdev);\n\n\t\tnetxen_nic_detach(adapter);\n\n\t\tif (netif_running(netdev)) {\n\t\t\terr = netxen_nic_attach(adapter);\n\t\t\tif (!err)\n\t\t\t\terr = __netxen_nic_up(adapter, netdev);\n\n\t\t\tif (err)\n\t\t\t\tgoto done;\n\t\t}\n\n\t\tnetif_device_attach(netdev);\n\t}\n\ndone:\n\tclear_bit(__NX_RESETTING, &adapter->state);\n\treturn err;\n}\n\nstatic int\nnetxen_setup_netdev(struct netxen_adapter *adapter,\n\t\tstruct net_device *netdev)\n{\n\tint err = 0;\n\tstruct pci_dev *pdev = adapter->pdev;\n\n\tadapter->mc_enabled = 0;\n\tif (NX_IS_REVISION_P3(adapter->ahw.revision_id))\n\t\tadapter->max_mc_count = 38;\n\telse\n\t\tadapter->max_mc_count = 16;\n\n\tnetdev->netdev_ops\t   = &netxen_netdev_ops;\n\tnetdev->watchdog_timeo     = 5*HZ;\n\n\tnetxen_nic_change_mtu(netdev, netdev->mtu);\n\n\tnetdev->ethtool_ops = &netxen_nic_ethtool_ops;\n\n\tnetdev->hw_features = NETIF_F_SG | NETIF_F_IP_CSUM | NETIF_F_TSO |\n\t                      NETIF_F_RXCSUM;\n\n\tif (NX_IS_REVISION_P3(adapter->ahw.revision_id))\n\t\tnetdev->hw_features |= NETIF_F_IPV6_CSUM | NETIF_F_TSO6;\n\n\tnetdev->vlan_features |= netdev->hw_features;\n\n\tif (adapter->pci_using_dac) {\n\t\tnetdev->features |= NETIF_F_HIGHDMA;\n\t\tnetdev->vlan_features |= NETIF_F_HIGHDMA;\n\t}\n\n\tif (adapter->capabilities & NX_FW_CAPABILITY_FVLANTX)\n\t\tnetdev->hw_features |= NETIF_F_HW_VLAN_CTAG_TX;\n\n\tif (adapter->capabilities & NX_FW_CAPABILITY_HW_LRO)\n\t\tnetdev->hw_features |= NETIF_F_LRO;\n\n\tnetdev->features |= netdev->hw_features;\n\n\tnetdev->irq = adapter->msix_entries[0].vector;\n\n\tINIT_WORK(&adapter->tx_timeout_task, netxen_tx_timeout_task);\n\n\tif (netxen_read_mac_addr(adapter))\n\t\tdev_warn(&pdev->dev, \"failed to read mac addr\\n\");\n\n\tnetif_carrier_off(netdev);\n\n\terr = register_netdev(netdev);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"failed to register net device\\n\");\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\n#define NETXEN_ULA_ADAPTER_KEY\t\t(0xdaddad01)\n#define NETXEN_NON_ULA_ADAPTER_KEY\t(0xdaddad00)\n\nstatic void netxen_read_ula_info(struct netxen_adapter *adapter)\n{\n\tu32 temp;\n\n\t \n\tif (adapter->portnum != 0)\n\t\treturn;\n\n\ttemp = NXRD32(adapter, NETXEN_ULA_KEY);\n\tswitch (temp) {\n\tcase NETXEN_ULA_ADAPTER_KEY:\n\t\tdev_info(&adapter->pdev->dev, \"ULA adapter\");\n\t\tbreak;\n\tcase NETXEN_NON_ULA_ADAPTER_KEY:\n\t\tdev_info(&adapter->pdev->dev, \"non ULA adapter\");\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn;\n}\n\n#ifdef CONFIG_PCIEAER\nstatic void netxen_mask_aer_correctable(struct netxen_adapter *adapter)\n{\n\tstruct pci_dev *pdev = adapter->pdev;\n\tstruct pci_dev *root = pdev->bus->self;\n\tu32 aer_pos;\n\n\t \n\tif (!root)\n\t\treturn;\n\n\tif (adapter->ahw.board_type != NETXEN_BRDTYPE_P3_4_GB_MM &&\n\t\tadapter->ahw.board_type != NETXEN_BRDTYPE_P3_10G_TP)\n\t\treturn;\n\n\tif (pci_pcie_type(root) != PCI_EXP_TYPE_ROOT_PORT)\n\t\treturn;\n\n\taer_pos = pci_find_ext_capability(root, PCI_EXT_CAP_ID_ERR);\n\tif (!aer_pos)\n\t\treturn;\n\n\tpci_write_config_dword(root, aer_pos + PCI_ERR_COR_MASK, 0xffff);\n}\n#endif\n\nstatic int\nnetxen_nic_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tstruct net_device *netdev = NULL;\n\tstruct netxen_adapter *adapter = NULL;\n\tint i = 0, err;\n\tint pci_func_id = PCI_FUNC(pdev->devfn);\n\tuint8_t revision_id;\n\tu32 val;\n\n\tif (pdev->revision >= NX_P3_A0 && pdev->revision <= NX_P3_B1) {\n\t\tpr_warn(\"%s: chip revisions between 0x%x-0x%x will not be enabled\\n\",\n\t\t\tmodule_name(THIS_MODULE), NX_P3_A0, NX_P3_B1);\n\t\treturn -ENODEV;\n\t}\n\n\tif ((err = pci_enable_device(pdev)))\n\t\treturn err;\n\n\tif (!(pci_resource_flags(pdev, 0) & IORESOURCE_MEM)) {\n\t\terr = -ENODEV;\n\t\tgoto err_out_disable_pdev;\n\t}\n\n\tif ((err = pci_request_regions(pdev, netxen_nic_driver_name)))\n\t\tgoto err_out_disable_pdev;\n\n\tpci_set_master(pdev);\n\n\tnetdev = alloc_etherdev(sizeof(struct netxen_adapter));\n\tif(!netdev) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out_free_res;\n\t}\n\n\tSET_NETDEV_DEV(netdev, &pdev->dev);\n\n\tadapter = netdev_priv(netdev);\n\tadapter->netdev  = netdev;\n\tadapter->pdev    = pdev;\n\tadapter->ahw.pci_func  = pci_func_id;\n\n\trevision_id = pdev->revision;\n\tadapter->ahw.revision_id = revision_id;\n\n\trwlock_init(&adapter->ahw.crb_lock);\n\tspin_lock_init(&adapter->ahw.mem_lock);\n\n\tspin_lock_init(&adapter->tx_clean_lock);\n\tINIT_LIST_HEAD(&adapter->mac_list);\n\tINIT_LIST_HEAD(&adapter->ip_list);\n\n\terr = netxen_setup_pci_map(adapter);\n\tif (err)\n\t\tgoto err_out_free_netdev;\n\n\t \n\tadapter->portnum = pci_func_id;\n\n\terr = netxen_nic_get_board_info(adapter);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Error getting board config info.\\n\");\n\t\tgoto err_out_iounmap;\n\t}\n\n#ifdef CONFIG_PCIEAER\n\tnetxen_mask_aer_correctable(adapter);\n#endif\n\n\t \n\tswitch (adapter->ahw.board_type) {\n\tcase NETXEN_BRDTYPE_P2_SB31_10G_IMEZ:\n\tcase NETXEN_BRDTYPE_P2_SB31_10G_HMEZ:\n\t\tif (pci_func_id >= 2)\n\t\t\tadapter->portnum = pci_func_id - 2;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\terr = netxen_check_flash_fw_compatibility(adapter);\n\tif (err)\n\t\tgoto err_out_iounmap;\n\n\tif (adapter->portnum == 0) {\n\t\tval = NXRD32(adapter, NX_CRB_DEV_REF_COUNT);\n\t\tif (val != 0xffffffff && val != 0) {\n\t\t\tNXWR32(adapter, NX_CRB_DEV_REF_COUNT, 0);\n\t\t\tadapter->need_fw_reset = 1;\n\t\t}\n\t}\n\n\terr = netxen_start_firmware(adapter);\n\tif (err)\n\t\tgoto err_out_decr_ref;\n\n\t \n\tadapter->physical_port = adapter->portnum;\n\tif (NX_IS_REVISION_P2(adapter->ahw.revision_id)) {\n\t\ti = NXRD32(adapter, CRB_V2P(adapter->portnum));\n\t\tif (i != 0x55555555)\n\t\t\tadapter->physical_port = i;\n\t}\n\n\t \n\tnetdev->min_mtu = 0;\n\tif (NX_IS_REVISION_P3(adapter->ahw.revision_id))\n\t\tnetdev->max_mtu = P3_MAX_MTU;\n\telse\n\t\tnetdev->max_mtu = P2_MAX_MTU;\n\n\tnetxen_nic_clear_stats(adapter);\n\n\terr = netxen_setup_intr(adapter);\n\n\tif (err) {\n\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\"Failed to setup interrupts, error = %d\\n\", err);\n\t\tgoto err_out_disable_msi;\n\t}\n\n\tnetxen_read_ula_info(adapter);\n\n\terr = netxen_setup_netdev(adapter, netdev);\n\tif (err)\n\t\tgoto err_out_disable_msi;\n\n\tpci_set_drvdata(pdev, adapter);\n\n\tnetxen_schedule_work(adapter, netxen_fw_poll_work, FW_POLL_DELAY);\n\n\tswitch (adapter->ahw.port_type) {\n\tcase NETXEN_NIC_GBE:\n\t\tdev_info(&adapter->pdev->dev, \"%s: GbE port initialized\\n\",\n\t\t\t\tadapter->netdev->name);\n\t\tbreak;\n\tcase NETXEN_NIC_XGBE:\n\t\tdev_info(&adapter->pdev->dev, \"%s: XGbE port initialized\\n\",\n\t\t\t\tadapter->netdev->name);\n\t\tbreak;\n\t}\n\n\tnetxen_create_diag_entries(adapter);\n\n\treturn 0;\n\nerr_out_disable_msi:\n\tnetxen_teardown_intr(adapter);\n\n\tnetxen_free_dummy_dma(adapter);\n\nerr_out_decr_ref:\n\tnx_decr_dev_ref_cnt(adapter);\n\nerr_out_iounmap:\n\tnetxen_cleanup_pci_map(adapter);\n\nerr_out_free_netdev:\n\tfree_netdev(netdev);\n\nerr_out_free_res:\n\tpci_release_regions(pdev);\n\nerr_out_disable_pdev:\n\tpci_disable_device(pdev);\n\treturn err;\n}\n\nstatic\nvoid netxen_cleanup_minidump(struct netxen_adapter *adapter)\n{\n\tkfree(adapter->mdump.md_template);\n\tadapter->mdump.md_template = NULL;\n\n\tif (adapter->mdump.md_capture_buff) {\n\t\tvfree(adapter->mdump.md_capture_buff);\n\t\tadapter->mdump.md_capture_buff = NULL;\n\t}\n}\n\nstatic void netxen_nic_remove(struct pci_dev *pdev)\n{\n\tstruct netxen_adapter *adapter;\n\tstruct net_device *netdev;\n\n\tadapter = pci_get_drvdata(pdev);\n\tif (adapter == NULL)\n\t\treturn;\n\n\tnetdev = adapter->netdev;\n\n\tnetxen_cancel_fw_work(adapter);\n\n\tunregister_netdev(netdev);\n\n\tcancel_work_sync(&adapter->tx_timeout_task);\n\n\tnetxen_free_ip_list(adapter, false);\n\tnetxen_nic_detach(adapter);\n\n\tnx_decr_dev_ref_cnt(adapter);\n\n\tif (adapter->portnum == 0)\n\t\tnetxen_free_dummy_dma(adapter);\n\n\tclear_bit(__NX_RESETTING, &adapter->state);\n\n\tnetxen_teardown_intr(adapter);\n\tnetxen_set_interrupt_mode(adapter, 0);\n\tnetxen_remove_diag_entries(adapter);\n\n\tnetxen_cleanup_pci_map(adapter);\n\n\tnetxen_release_firmware(adapter);\n\n\tif (NX_IS_REVISION_P3(pdev->revision))\n\t\tnetxen_cleanup_minidump(adapter);\n\n\tpci_release_regions(pdev);\n\tpci_disable_device(pdev);\n\n\tfree_netdev(netdev);\n}\n\nstatic void netxen_nic_detach_func(struct netxen_adapter *adapter)\n{\n\tstruct net_device *netdev = adapter->netdev;\n\n\tnetif_device_detach(netdev);\n\n\tnetxen_cancel_fw_work(adapter);\n\n\tif (netif_running(netdev))\n\t\tnetxen_nic_down(adapter, netdev);\n\n\tcancel_work_sync(&adapter->tx_timeout_task);\n\n\tnetxen_nic_detach(adapter);\n\n\tif (adapter->portnum == 0)\n\t\tnetxen_free_dummy_dma(adapter);\n\n\tnx_decr_dev_ref_cnt(adapter);\n\n\tclear_bit(__NX_RESETTING, &adapter->state);\n}\n\nstatic int netxen_nic_attach_late_func(struct pci_dev *pdev)\n{\n\tstruct netxen_adapter *adapter = pci_get_drvdata(pdev);\n\tstruct net_device *netdev = adapter->netdev;\n\tint err;\n\n\tpci_set_master(pdev);\n\n\tadapter->ahw.crb_win = -1;\n\tadapter->ahw.ocm_win = -1;\n\n\terr = netxen_start_firmware(adapter);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"failed to start firmware\\n\");\n\t\treturn err;\n\t}\n\n\tif (netif_running(netdev)) {\n\t\terr = netxen_nic_attach(adapter);\n\t\tif (err)\n\t\t\tgoto err_out;\n\n\t\terr = netxen_nic_up(adapter, netdev);\n\t\tif (err)\n\t\t\tgoto err_out_detach;\n\n\t\tnetxen_restore_indev_addr(netdev, NETDEV_UP);\n\t}\n\n\tnetif_device_attach(netdev);\n\tnetxen_schedule_work(adapter, netxen_fw_poll_work, FW_POLL_DELAY);\n\treturn 0;\n\nerr_out_detach:\n\tnetxen_nic_detach(adapter);\nerr_out:\n\tnx_decr_dev_ref_cnt(adapter);\n\treturn err;\n}\n\nstatic int netxen_nic_attach_func(struct pci_dev *pdev)\n{\n\tint err;\n\n\terr = pci_enable_device(pdev);\n\tif (err)\n\t\treturn err;\n\n\tpci_set_power_state(pdev, PCI_D0);\n\tpci_restore_state(pdev);\n\n\treturn netxen_nic_attach_late_func(pdev);\n}\n\nstatic pci_ers_result_t netxen_io_error_detected(struct pci_dev *pdev,\n\t\t\t\t\t\tpci_channel_state_t state)\n{\n\tstruct netxen_adapter *adapter = pci_get_drvdata(pdev);\n\n\tif (state == pci_channel_io_perm_failure)\n\t\treturn PCI_ERS_RESULT_DISCONNECT;\n\n\tif (nx_dev_request_aer(adapter))\n\t\treturn PCI_ERS_RESULT_RECOVERED;\n\n\tnetxen_nic_detach_func(adapter);\n\n\tpci_disable_device(pdev);\n\n\treturn PCI_ERS_RESULT_NEED_RESET;\n}\n\nstatic pci_ers_result_t netxen_io_slot_reset(struct pci_dev *pdev)\n{\n\tint err = 0;\n\n\terr = netxen_nic_attach_func(pdev);\n\n\treturn err ? PCI_ERS_RESULT_DISCONNECT : PCI_ERS_RESULT_RECOVERED;\n}\n\nstatic void netxen_nic_shutdown(struct pci_dev *pdev)\n{\n\tstruct netxen_adapter *adapter = pci_get_drvdata(pdev);\n\n\tnetxen_nic_detach_func(adapter);\n\n\tif (pci_save_state(pdev))\n\t\treturn;\n\n\tif (netxen_nic_wol_supported(adapter)) {\n\t\tpci_enable_wake(pdev, PCI_D3cold, 1);\n\t\tpci_enable_wake(pdev, PCI_D3hot, 1);\n\t}\n\n\tpci_disable_device(pdev);\n}\n\nstatic int __maybe_unused\nnetxen_nic_suspend(struct device *dev_d)\n{\n\tstruct netxen_adapter *adapter = dev_get_drvdata(dev_d);\n\n\tnetxen_nic_detach_func(adapter);\n\n\tif (netxen_nic_wol_supported(adapter))\n\t\tdevice_wakeup_enable(dev_d);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused\nnetxen_nic_resume(struct device *dev_d)\n{\n\treturn netxen_nic_attach_late_func(to_pci_dev(dev_d));\n}\n\nstatic int netxen_nic_open(struct net_device *netdev)\n{\n\tstruct netxen_adapter *adapter = netdev_priv(netdev);\n\tint err = 0;\n\n\tif (adapter->driver_mismatch)\n\t\treturn -EIO;\n\n\terr = netxen_nic_attach(adapter);\n\tif (err)\n\t\treturn err;\n\n\terr = __netxen_nic_up(adapter, netdev);\n\tif (err)\n\t\tgoto err_out;\n\n\tnetif_start_queue(netdev);\n\n\treturn 0;\n\nerr_out:\n\tnetxen_nic_detach(adapter);\n\treturn err;\n}\n\n \nstatic int netxen_nic_close(struct net_device *netdev)\n{\n\tstruct netxen_adapter *adapter = netdev_priv(netdev);\n\n\t__netxen_nic_down(adapter, netdev);\n\treturn 0;\n}\n\nstatic void\nnetxen_tso_check(struct net_device *netdev,\n\t\tstruct nx_host_tx_ring *tx_ring,\n\t\tstruct cmd_desc_type0 *first_desc,\n\t\tstruct sk_buff *skb)\n{\n\tu8 opcode = TX_ETHER_PKT;\n\t__be16 protocol = skb->protocol;\n\tu16 flags = 0, vid = 0;\n\tu32 producer;\n\tint copied, offset, copy_len, hdr_len = 0, tso = 0, vlan_oob = 0;\n\tstruct cmd_desc_type0 *hwdesc;\n\tstruct vlan_ethhdr *vh;\n\n\tif (protocol == cpu_to_be16(ETH_P_8021Q)) {\n\n\t\tvh = skb_vlan_eth_hdr(skb);\n\t\tprotocol = vh->h_vlan_encapsulated_proto;\n\t\tflags = FLAGS_VLAN_TAGGED;\n\n\t} else if (skb_vlan_tag_present(skb)) {\n\t\tflags = FLAGS_VLAN_OOB;\n\t\tvid = skb_vlan_tag_get(skb);\n\t\tnetxen_set_tx_vlan_tci(first_desc, vid);\n\t\tvlan_oob = 1;\n\t}\n\n\tif ((netdev->features & (NETIF_F_TSO | NETIF_F_TSO6)) &&\n\t\t\tskb_shinfo(skb)->gso_size > 0) {\n\n\t\thdr_len = skb_tcp_all_headers(skb);\n\n\t\tfirst_desc->mss = cpu_to_le16(skb_shinfo(skb)->gso_size);\n\t\tfirst_desc->total_hdr_length = hdr_len;\n\t\tif (vlan_oob) {\n\t\t\tfirst_desc->total_hdr_length += VLAN_HLEN;\n\t\t\tfirst_desc->tcp_hdr_offset = VLAN_HLEN;\n\t\t\tfirst_desc->ip_hdr_offset = VLAN_HLEN;\n\t\t\t \n\t\t\tflags |= FLAGS_VLAN_TAGGED;\n\t\t}\n\n\t\topcode = (protocol == cpu_to_be16(ETH_P_IPV6)) ?\n\t\t\t\tTX_TCP_LSO6 : TX_TCP_LSO;\n\t\ttso = 1;\n\n\t} else if (skb->ip_summed == CHECKSUM_PARTIAL) {\n\t\tu8 l4proto;\n\n\t\tif (protocol == cpu_to_be16(ETH_P_IP)) {\n\t\t\tl4proto = ip_hdr(skb)->protocol;\n\n\t\t\tif (l4proto == IPPROTO_TCP)\n\t\t\t\topcode = TX_TCP_PKT;\n\t\t\telse if(l4proto == IPPROTO_UDP)\n\t\t\t\topcode = TX_UDP_PKT;\n\t\t} else if (protocol == cpu_to_be16(ETH_P_IPV6)) {\n\t\t\tl4proto = ipv6_hdr(skb)->nexthdr;\n\n\t\t\tif (l4proto == IPPROTO_TCP)\n\t\t\t\topcode = TX_TCPV6_PKT;\n\t\t\telse if(l4proto == IPPROTO_UDP)\n\t\t\t\topcode = TX_UDPV6_PKT;\n\t\t}\n\t}\n\n\tfirst_desc->tcp_hdr_offset += skb_transport_offset(skb);\n\tfirst_desc->ip_hdr_offset += skb_network_offset(skb);\n\tnetxen_set_tx_flags_opcode(first_desc, flags, opcode);\n\n\tif (!tso)\n\t\treturn;\n\n\t \n\tproducer = tx_ring->producer;\n\tcopied = 0;\n\toffset = 2;\n\n\tif (vlan_oob) {\n\t\t \n\n\t\thwdesc = &tx_ring->desc_head[producer];\n\t\ttx_ring->cmd_buf_arr[producer].skb = NULL;\n\n\t\tcopy_len = min((int)sizeof(struct cmd_desc_type0) - offset,\n\t\t\t\thdr_len + VLAN_HLEN);\n\n\t\tvh = (struct vlan_ethhdr *)((char *)hwdesc + 2);\n\t\tskb_copy_from_linear_data(skb, vh, 12);\n\t\tvh->h_vlan_proto = htons(ETH_P_8021Q);\n\t\tvh->h_vlan_TCI = htons(vid);\n\t\tskb_copy_from_linear_data_offset(skb, 12,\n\t\t\t\t(char *)vh + 16, copy_len - 16);\n\n\t\tcopied = copy_len - VLAN_HLEN;\n\t\toffset = 0;\n\n\t\tproducer = get_next_index(producer, tx_ring->num_desc);\n\t}\n\n\twhile (copied < hdr_len) {\n\n\t\tcopy_len = min((int)sizeof(struct cmd_desc_type0) - offset,\n\t\t\t\t(hdr_len - copied));\n\n\t\thwdesc = &tx_ring->desc_head[producer];\n\t\ttx_ring->cmd_buf_arr[producer].skb = NULL;\n\n\t\tskb_copy_from_linear_data_offset(skb, copied,\n\t\t\t\t (char *)hwdesc + offset, copy_len);\n\n\t\tcopied += copy_len;\n\t\toffset = 0;\n\n\t\tproducer = get_next_index(producer, tx_ring->num_desc);\n\t}\n\n\ttx_ring->producer = producer;\n\tbarrier();\n}\n\nstatic int\nnetxen_map_tx_skb(struct pci_dev *pdev,\n\t\tstruct sk_buff *skb, struct netxen_cmd_buffer *pbuf)\n{\n\tstruct netxen_skb_frag *nf;\n\tskb_frag_t *frag;\n\tint i, nr_frags;\n\tdma_addr_t map;\n\n\tnr_frags = skb_shinfo(skb)->nr_frags;\n\tnf = &pbuf->frag_array[0];\n\n\tmap = dma_map_single(&pdev->dev, skb->data, skb_headlen(skb),\n\t\t\t     DMA_TO_DEVICE);\n\tif (dma_mapping_error(&pdev->dev, map))\n\t\tgoto out_err;\n\n\tnf->dma = map;\n\tnf->length = skb_headlen(skb);\n\n\tfor (i = 0; i < nr_frags; i++) {\n\t\tfrag = &skb_shinfo(skb)->frags[i];\n\t\tnf = &pbuf->frag_array[i+1];\n\n\t\tmap = skb_frag_dma_map(&pdev->dev, frag, 0, skb_frag_size(frag),\n\t\t\t\t       DMA_TO_DEVICE);\n\t\tif (dma_mapping_error(&pdev->dev, map))\n\t\t\tgoto unwind;\n\n\t\tnf->dma = map;\n\t\tnf->length = skb_frag_size(frag);\n\t}\n\n\treturn 0;\n\nunwind:\n\twhile (--i >= 0) {\n\t\tnf = &pbuf->frag_array[i+1];\n\t\tdma_unmap_page(&pdev->dev, nf->dma, nf->length, DMA_TO_DEVICE);\n\t\tnf->dma = 0ULL;\n\t}\n\n\tnf = &pbuf->frag_array[0];\n\tdma_unmap_single(&pdev->dev, nf->dma, skb_headlen(skb), DMA_TO_DEVICE);\n\tnf->dma = 0ULL;\n\nout_err:\n\treturn -ENOMEM;\n}\n\nstatic inline void\nnetxen_clear_cmddesc(u64 *desc)\n{\n\tdesc[0] = 0ULL;\n\tdesc[2] = 0ULL;\n}\n\nstatic netdev_tx_t\nnetxen_nic_xmit_frame(struct sk_buff *skb, struct net_device *netdev)\n{\n\tstruct netxen_adapter *adapter = netdev_priv(netdev);\n\tstruct nx_host_tx_ring *tx_ring = adapter->tx_ring;\n\tstruct netxen_cmd_buffer *pbuf;\n\tstruct netxen_skb_frag *buffrag;\n\tstruct cmd_desc_type0 *hwdesc, *first_desc;\n\tstruct pci_dev *pdev;\n\tint i, k;\n\tint delta = 0;\n\tskb_frag_t *frag;\n\n\tu32 producer;\n\tint frag_count;\n\tu32 num_txd = tx_ring->num_desc;\n\n\tfrag_count = skb_shinfo(skb)->nr_frags + 1;\n\n\t \n\tif (!skb_is_gso(skb) && frag_count > NETXEN_MAX_FRAGS_PER_TX) {\n\n\t\tfor (i = 0; i < (frag_count - NETXEN_MAX_FRAGS_PER_TX); i++) {\n\t\t\tfrag = &skb_shinfo(skb)->frags[i];\n\t\t\tdelta += skb_frag_size(frag);\n\t\t}\n\n\t\tif (!__pskb_pull_tail(skb, delta))\n\t\t\tgoto drop_packet;\n\n\t\tfrag_count = 1 + skb_shinfo(skb)->nr_frags;\n\t}\n\n\tif (unlikely(netxen_tx_avail(tx_ring) <= TX_STOP_THRESH)) {\n\t\tnetif_stop_queue(netdev);\n\t\tsmp_mb();\n\t\tif (netxen_tx_avail(tx_ring) > TX_STOP_THRESH)\n\t\t\tnetif_start_queue(netdev);\n\t\telse\n\t\t\treturn NETDEV_TX_BUSY;\n\t}\n\n\tproducer = tx_ring->producer;\n\tpbuf = &tx_ring->cmd_buf_arr[producer];\n\n\tpdev = adapter->pdev;\n\n\tif (netxen_map_tx_skb(pdev, skb, pbuf))\n\t\tgoto drop_packet;\n\n\tpbuf->skb = skb;\n\tpbuf->frag_count = frag_count;\n\n\tfirst_desc = hwdesc = &tx_ring->desc_head[producer];\n\tnetxen_clear_cmddesc((u64 *)hwdesc);\n\n\tnetxen_set_tx_frags_len(first_desc, frag_count, skb->len);\n\tnetxen_set_tx_port(first_desc, adapter->portnum);\n\n\tfor (i = 0; i < frag_count; i++) {\n\n\t\tk = i % 4;\n\n\t\tif ((k == 0) && (i > 0)) {\n\t\t\t \n\t\t\tproducer = get_next_index(producer, num_txd);\n\t\t\thwdesc = &tx_ring->desc_head[producer];\n\t\t\tnetxen_clear_cmddesc((u64 *)hwdesc);\n\t\t\ttx_ring->cmd_buf_arr[producer].skb = NULL;\n\t\t}\n\n\t\tbuffrag = &pbuf->frag_array[i];\n\n\t\thwdesc->buffer_length[k] = cpu_to_le16(buffrag->length);\n\t\tswitch (k) {\n\t\tcase 0:\n\t\t\thwdesc->addr_buffer1 = cpu_to_le64(buffrag->dma);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\thwdesc->addr_buffer2 = cpu_to_le64(buffrag->dma);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\thwdesc->addr_buffer3 = cpu_to_le64(buffrag->dma);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\thwdesc->addr_buffer4 = cpu_to_le64(buffrag->dma);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\ttx_ring->producer = get_next_index(producer, num_txd);\n\n\tnetxen_tso_check(netdev, tx_ring, first_desc, skb);\n\n\tadapter->stats.txbytes += skb->len;\n\tadapter->stats.xmitcalled++;\n\n\tnetxen_nic_update_cmd_producer(adapter, tx_ring);\n\n\treturn NETDEV_TX_OK;\n\ndrop_packet:\n\tadapter->stats.txdropped++;\n\tdev_kfree_skb_any(skb);\n\treturn NETDEV_TX_OK;\n}\n\nstatic int netxen_nic_check_temp(struct netxen_adapter *adapter)\n{\n\tstruct net_device *netdev = adapter->netdev;\n\tuint32_t temp, temp_state, temp_val;\n\tint rv = 0;\n\n\ttemp = NXRD32(adapter, CRB_TEMP_STATE);\n\n\ttemp_state = nx_get_temp_state(temp);\n\ttemp_val = nx_get_temp_val(temp);\n\n\tif (temp_state == NX_TEMP_PANIC) {\n\t\tprintk(KERN_ALERT\n\t\t       \"%s: Device temperature %d degrees C exceeds\"\n\t\t       \" maximum allowed. Hardware has been shut down.\\n\",\n\t\t       netdev->name, temp_val);\n\t\trv = 1;\n\t} else if (temp_state == NX_TEMP_WARN) {\n\t\tif (adapter->temp == NX_TEMP_NORMAL) {\n\t\t\tprintk(KERN_ALERT\n\t\t\t       \"%s: Device temperature %d degrees C \"\n\t\t\t       \"exceeds operating range.\"\n\t\t\t       \" Immediate action needed.\\n\",\n\t\t\t       netdev->name, temp_val);\n\t\t}\n\t} else {\n\t\tif (adapter->temp == NX_TEMP_WARN) {\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"%s: Device temperature is now %d degrees C\"\n\t\t\t       \" in normal range.\\n\", netdev->name,\n\t\t\t       temp_val);\n\t\t}\n\t}\n\tadapter->temp = temp_state;\n\treturn rv;\n}\n\nvoid netxen_advert_link_change(struct netxen_adapter *adapter, int linkup)\n{\n\tstruct net_device *netdev = adapter->netdev;\n\n\tif (adapter->ahw.linkup && !linkup) {\n\t\tprintk(KERN_INFO \"%s: %s NIC Link is down\\n\",\n\t\t       netxen_nic_driver_name, netdev->name);\n\t\tadapter->ahw.linkup = 0;\n\t\tif (netif_running(netdev)) {\n\t\t\tnetif_carrier_off(netdev);\n\t\t\tnetif_stop_queue(netdev);\n\t\t}\n\t\tadapter->link_changed = !adapter->has_link_events;\n\t} else if (!adapter->ahw.linkup && linkup) {\n\t\tprintk(KERN_INFO \"%s: %s NIC Link is up\\n\",\n\t\t       netxen_nic_driver_name, netdev->name);\n\t\tadapter->ahw.linkup = 1;\n\t\tif (netif_running(netdev)) {\n\t\t\tnetif_carrier_on(netdev);\n\t\t\tnetif_wake_queue(netdev);\n\t\t}\n\t\tadapter->link_changed = !adapter->has_link_events;\n\t}\n}\n\nstatic void netxen_nic_handle_phy_intr(struct netxen_adapter *adapter)\n{\n\tu32 val, port, linkup;\n\n\tport = adapter->physical_port;\n\n\tif (NX_IS_REVISION_P3(adapter->ahw.revision_id)) {\n\t\tval = NXRD32(adapter, CRB_XG_STATE_P3);\n\t\tval = XG_LINK_STATE_P3(adapter->ahw.pci_func, val);\n\t\tlinkup = (val == XG_LINK_UP_P3);\n\t} else {\n\t\tval = NXRD32(adapter, CRB_XG_STATE);\n\t\tval = (val >> port*8) & 0xff;\n\t\tlinkup = (val == XG_LINK_UP);\n\t}\n\n\tnetxen_advert_link_change(adapter, linkup);\n}\n\nstatic void netxen_tx_timeout(struct net_device *netdev, unsigned int txqueue)\n{\n\tstruct netxen_adapter *adapter = netdev_priv(netdev);\n\n\tif (test_bit(__NX_RESETTING, &adapter->state))\n\t\treturn;\n\n\tdev_err(&netdev->dev, \"transmit timeout, resetting.\\n\");\n\tschedule_work(&adapter->tx_timeout_task);\n}\n\nstatic void netxen_tx_timeout_task(struct work_struct *work)\n{\n\tstruct netxen_adapter *adapter =\n\t\tcontainer_of(work, struct netxen_adapter, tx_timeout_task);\n\n\tif (!netif_running(adapter->netdev))\n\t\treturn;\n\n\tif (test_and_set_bit(__NX_RESETTING, &adapter->state))\n\t\treturn;\n\n\tif (++adapter->tx_timeo_cnt >= NX_MAX_TX_TIMEOUTS)\n\t\tgoto request_reset;\n\n\trtnl_lock();\n\tif (NX_IS_REVISION_P2(adapter->ahw.revision_id)) {\n\t\t \n\t\tnetxen_napi_disable(adapter);\n\n\t\tnetxen_napi_enable(adapter);\n\n\t\tnetif_wake_queue(adapter->netdev);\n\n\t\tclear_bit(__NX_RESETTING, &adapter->state);\n\t} else {\n\t\tclear_bit(__NX_RESETTING, &adapter->state);\n\t\tif (netxen_nic_reset_context(adapter)) {\n\t\t\trtnl_unlock();\n\t\t\tgoto request_reset;\n\t\t}\n\t}\n\tnetif_trans_update(adapter->netdev);\n\trtnl_unlock();\n\treturn;\n\nrequest_reset:\n\tadapter->need_fw_reset = 1;\n\tclear_bit(__NX_RESETTING, &adapter->state);\n}\n\nstatic void netxen_nic_get_stats(struct net_device *netdev,\n\t\t\t\t struct rtnl_link_stats64 *stats)\n{\n\tstruct netxen_adapter *adapter = netdev_priv(netdev);\n\n\tstats->rx_packets = adapter->stats.rx_pkts + adapter->stats.lro_pkts;\n\tstats->tx_packets = adapter->stats.xmitfinished;\n\tstats->rx_bytes = adapter->stats.rxbytes;\n\tstats->tx_bytes = adapter->stats.txbytes;\n\tstats->rx_dropped = adapter->stats.rxdropped;\n\tstats->tx_dropped = adapter->stats.txdropped;\n}\n\nstatic irqreturn_t netxen_intr(int irq, void *data)\n{\n\tstruct nx_host_sds_ring *sds_ring = data;\n\tstruct netxen_adapter *adapter = sds_ring->adapter;\n\tu32 status = 0;\n\n\tstatus = readl(adapter->isr_int_vec);\n\n\tif (!(status & adapter->int_vec_bit))\n\t\treturn IRQ_NONE;\n\n\tif (NX_IS_REVISION_P3(adapter->ahw.revision_id)) {\n\t\t \n\t\tstatus = readl(adapter->crb_int_state_reg);\n\t\tif (!ISR_LEGACY_INT_TRIGGERED(status))\n\t\t\treturn IRQ_NONE;\n\n\t} else {\n\t\tunsigned long our_int = 0;\n\n\t\tour_int = readl(adapter->crb_int_state_reg);\n\n\t\t \n\t\tif (!test_and_clear_bit((7 + adapter->portnum), &our_int))\n\t\t\treturn IRQ_NONE;\n\n\t\t \n\t\twritel((our_int & 0xffffffff), adapter->crb_int_state_reg);\n\n\t\t \n\t\tnetxen_nic_disable_int(sds_ring);\n\t}\n\n\twritel(0xffffffff, adapter->tgt_status_reg);\n\t \n\treadl(adapter->isr_int_vec);\n\treadl(adapter->isr_int_vec);\n\n\tnapi_schedule(&sds_ring->napi);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t netxen_msi_intr(int irq, void *data)\n{\n\tstruct nx_host_sds_ring *sds_ring = data;\n\tstruct netxen_adapter *adapter = sds_ring->adapter;\n\n\t \n\twritel(0xffffffff, adapter->tgt_status_reg);\n\n\tnapi_schedule(&sds_ring->napi);\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t netxen_msix_intr(int irq, void *data)\n{\n\tstruct nx_host_sds_ring *sds_ring = data;\n\n\tnapi_schedule(&sds_ring->napi);\n\treturn IRQ_HANDLED;\n}\n\nstatic int netxen_nic_poll(struct napi_struct *napi, int budget)\n{\n\tstruct nx_host_sds_ring *sds_ring =\n\t\tcontainer_of(napi, struct nx_host_sds_ring, napi);\n\n\tstruct netxen_adapter *adapter = sds_ring->adapter;\n\n\tint tx_complete;\n\tint work_done;\n\n\ttx_complete = netxen_process_cmd_ring(adapter);\n\n\twork_done = netxen_process_rcv_ring(sds_ring, budget);\n\n\tif (!tx_complete)\n\t\twork_done = budget;\n\n\tif (work_done < budget) {\n\t\tnapi_complete_done(&sds_ring->napi, work_done);\n\t\tif (test_bit(__NX_DEV_UP, &adapter->state))\n\t\t\tnetxen_nic_enable_int(sds_ring);\n\t}\n\n\treturn work_done;\n}\n\nstatic int\nnx_incr_dev_ref_cnt(struct netxen_adapter *adapter)\n{\n\tint count;\n\tif (netxen_api_lock(adapter))\n\t\treturn -EIO;\n\n\tcount = NXRD32(adapter, NX_CRB_DEV_REF_COUNT);\n\n\tNXWR32(adapter, NX_CRB_DEV_REF_COUNT, ++count);\n\n\tnetxen_api_unlock(adapter);\n\treturn count;\n}\n\nstatic int\nnx_decr_dev_ref_cnt(struct netxen_adapter *adapter)\n{\n\tint count, state;\n\tif (netxen_api_lock(adapter))\n\t\treturn -EIO;\n\n\tcount = NXRD32(adapter, NX_CRB_DEV_REF_COUNT);\n\tWARN_ON(count == 0);\n\n\tNXWR32(adapter, NX_CRB_DEV_REF_COUNT, --count);\n\tstate = NXRD32(adapter, NX_CRB_DEV_STATE);\n\n\tif (count == 0 && state != NX_DEV_FAILED)\n\t\tNXWR32(adapter, NX_CRB_DEV_STATE, NX_DEV_COLD);\n\n\tnetxen_api_unlock(adapter);\n\treturn count;\n}\n\nstatic int\nnx_dev_request_aer(struct netxen_adapter *adapter)\n{\n\tu32 state;\n\tint ret = -EINVAL;\n\n\tif (netxen_api_lock(adapter))\n\t\treturn ret;\n\n\tstate = NXRD32(adapter, NX_CRB_DEV_STATE);\n\n\tif (state == NX_DEV_NEED_AER)\n\t\tret = 0;\n\telse if (state == NX_DEV_READY) {\n\t\tNXWR32(adapter, NX_CRB_DEV_STATE, NX_DEV_NEED_AER);\n\t\tret = 0;\n\t}\n\n\tnetxen_api_unlock(adapter);\n\treturn ret;\n}\n\nint\nnx_dev_request_reset(struct netxen_adapter *adapter)\n{\n\tu32 state;\n\tint ret = -EINVAL;\n\n\tif (netxen_api_lock(adapter))\n\t\treturn ret;\n\n\tstate = NXRD32(adapter, NX_CRB_DEV_STATE);\n\n\tif (state == NX_DEV_NEED_RESET || state == NX_DEV_FAILED)\n\t\tret = 0;\n\telse if (state != NX_DEV_INITALIZING && state != NX_DEV_NEED_AER) {\n\t\tNXWR32(adapter, NX_CRB_DEV_STATE, NX_DEV_NEED_RESET);\n\t\tadapter->flags |= NETXEN_FW_RESET_OWNER;\n\t\tret = 0;\n\t}\n\n\tnetxen_api_unlock(adapter);\n\n\treturn ret;\n}\n\nstatic int\nnetxen_can_start_firmware(struct netxen_adapter *adapter)\n{\n\tint count;\n\tint can_start = 0;\n\n\tif (netxen_api_lock(adapter)) {\n\t\tnx_incr_dev_ref_cnt(adapter);\n\t\treturn -1;\n\t}\n\n\tcount = NXRD32(adapter, NX_CRB_DEV_REF_COUNT);\n\n\tif ((count < 0) || (count >= NX_MAX_PCI_FUNC))\n\t\tcount = 0;\n\n\tif (count == 0) {\n\t\tcan_start = 1;\n\t\tNXWR32(adapter, NX_CRB_DEV_STATE, NX_DEV_INITALIZING);\n\t}\n\n\tNXWR32(adapter, NX_CRB_DEV_REF_COUNT, ++count);\n\n\tnetxen_api_unlock(adapter);\n\n\treturn can_start;\n}\n\nstatic void\nnetxen_schedule_work(struct netxen_adapter *adapter,\n\t\twork_func_t func, int delay)\n{\n\tINIT_DELAYED_WORK(&adapter->fw_work, func);\n\tschedule_delayed_work(&adapter->fw_work, delay);\n}\n\nstatic void\nnetxen_cancel_fw_work(struct netxen_adapter *adapter)\n{\n\twhile (test_and_set_bit(__NX_RESETTING, &adapter->state))\n\t\tmsleep(10);\n\n\tcancel_delayed_work_sync(&adapter->fw_work);\n}\n\nstatic void\nnetxen_attach_work(struct work_struct *work)\n{\n\tstruct netxen_adapter *adapter = container_of(work,\n\t\t\t\tstruct netxen_adapter, fw_work.work);\n\tstruct net_device *netdev = adapter->netdev;\n\tint err = 0;\n\n\tif (netif_running(netdev)) {\n\t\terr = netxen_nic_attach(adapter);\n\t\tif (err)\n\t\t\tgoto done;\n\n\t\terr = netxen_nic_up(adapter, netdev);\n\t\tif (err) {\n\t\t\tnetxen_nic_detach(adapter);\n\t\t\tgoto done;\n\t\t}\n\n\t\tnetxen_restore_indev_addr(netdev, NETDEV_UP);\n\t}\n\n\tnetif_device_attach(netdev);\n\ndone:\n\tadapter->fw_fail_cnt = 0;\n\tclear_bit(__NX_RESETTING, &adapter->state);\n\tnetxen_schedule_work(adapter, netxen_fw_poll_work, FW_POLL_DELAY);\n}\n\nstatic void\nnetxen_fwinit_work(struct work_struct *work)\n{\n\tstruct netxen_adapter *adapter = container_of(work,\n\t\t\t\tstruct netxen_adapter, fw_work.work);\n\tint dev_state;\n\tint count;\n\tdev_state = NXRD32(adapter, NX_CRB_DEV_STATE);\n\tif (adapter->flags & NETXEN_FW_RESET_OWNER) {\n\t\tcount = NXRD32(adapter, NX_CRB_DEV_REF_COUNT);\n\t\tWARN_ON(count == 0);\n\t\tif (count == 1) {\n\t\t\tif (adapter->mdump.md_enabled) {\n\t\t\t\trtnl_lock();\n\t\t\t\tnetxen_dump_fw(adapter);\n\t\t\t\trtnl_unlock();\n\t\t\t}\n\t\t\tadapter->flags &= ~NETXEN_FW_RESET_OWNER;\n\t\t\tif (netxen_api_lock(adapter)) {\n\t\t\t\tclear_bit(__NX_RESETTING, &adapter->state);\n\t\t\t\tNXWR32(adapter, NX_CRB_DEV_STATE,\n\t\t\t\t\t\tNX_DEV_FAILED);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tcount = NXRD32(adapter, NX_CRB_DEV_REF_COUNT);\n\t\t\tNXWR32(adapter, NX_CRB_DEV_REF_COUNT, --count);\n\t\t\tNXWR32(adapter, NX_CRB_DEV_STATE, NX_DEV_COLD);\n\t\t\tdev_state = NX_DEV_COLD;\n\t\t\tnetxen_api_unlock(adapter);\n\t\t}\n\t}\n\n\tswitch (dev_state) {\n\tcase NX_DEV_COLD:\n\tcase NX_DEV_READY:\n\t\tif (!netxen_start_firmware(adapter)) {\n\t\t\tnetxen_schedule_work(adapter, netxen_attach_work, 0);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\n\tcase NX_DEV_NEED_RESET:\n\tcase NX_DEV_INITALIZING:\n\t\t\tnetxen_schedule_work(adapter,\n\t\t\t\t\tnetxen_fwinit_work, 2 * FW_POLL_DELAY);\n\t\t\treturn;\n\n\tcase NX_DEV_FAILED:\n\tdefault:\n\t\tnx_incr_dev_ref_cnt(adapter);\n\t\tbreak;\n\t}\n\n\tif (netxen_api_lock(adapter)) {\n\t\tclear_bit(__NX_RESETTING, &adapter->state);\n\t\treturn;\n\t}\n\tNXWR32(adapter, NX_CRB_DEV_STATE, NX_DEV_FAILED);\n\tnetxen_api_unlock(adapter);\n\tdev_err(&adapter->pdev->dev, \"%s: Device initialization Failed\\n\",\n\t\t\t\tadapter->netdev->name);\n\n\tclear_bit(__NX_RESETTING, &adapter->state);\n}\n\nstatic void\nnetxen_detach_work(struct work_struct *work)\n{\n\tstruct netxen_adapter *adapter = container_of(work,\n\t\t\t\tstruct netxen_adapter, fw_work.work);\n\tstruct net_device *netdev = adapter->netdev;\n\tint ref_cnt = 0, delay;\n\tu32 status;\n\n\tnetif_device_detach(netdev);\n\n\tnetxen_nic_down(adapter, netdev);\n\n\trtnl_lock();\n\tnetxen_nic_detach(adapter);\n\trtnl_unlock();\n\n\tstatus = NXRD32(adapter, NETXEN_PEG_HALT_STATUS1);\n\n\tif (status & NX_RCODE_FATAL_ERROR)\n\t\tgoto err_ret;\n\n\tif (adapter->temp == NX_TEMP_PANIC)\n\t\tgoto err_ret;\n\n\tif (!(adapter->flags & NETXEN_FW_RESET_OWNER))\n\t\tref_cnt = nx_decr_dev_ref_cnt(adapter);\n\n\tif (ref_cnt == -EIO)\n\t\tgoto err_ret;\n\n\tdelay = (ref_cnt == 0) ? 0 : (2 * FW_POLL_DELAY);\n\n\tadapter->fw_wait_cnt = 0;\n\tnetxen_schedule_work(adapter, netxen_fwinit_work, delay);\n\n\treturn;\n\nerr_ret:\n\tclear_bit(__NX_RESETTING, &adapter->state);\n}\n\nstatic int\nnetxen_check_health(struct netxen_adapter *adapter)\n{\n\tu32 state, heartbit;\n\tu32 peg_status;\n\tstruct net_device *netdev = adapter->netdev;\n\n\tstate = NXRD32(adapter, NX_CRB_DEV_STATE);\n\tif (state == NX_DEV_NEED_AER)\n\t\treturn 0;\n\n\tif (netxen_nic_check_temp(adapter))\n\t\tgoto detach;\n\n\tif (adapter->need_fw_reset) {\n\t\tif (nx_dev_request_reset(adapter))\n\t\t\treturn 0;\n\t\tgoto detach;\n\t}\n\n\t \n\tif (state == NX_DEV_NEED_RESET || state == NX_DEV_FAILED) {\n\t\tadapter->need_fw_reset = 1;\n\t\tif (NX_IS_REVISION_P2(adapter->ahw.revision_id))\n\t\t\tgoto detach;\n\t}\n\n\tif (NX_IS_REVISION_P2(adapter->ahw.revision_id))\n\t\treturn 0;\n\n\theartbit = NXRD32(adapter, NETXEN_PEG_ALIVE_COUNTER);\n\tif (heartbit != adapter->heartbit) {\n\t\tadapter->heartbit = heartbit;\n\t\tadapter->fw_fail_cnt = 0;\n\t\tif (adapter->need_fw_reset)\n\t\t\tgoto detach;\n\t\treturn 0;\n\t}\n\n\tif (++adapter->fw_fail_cnt < FW_FAIL_THRESH)\n\t\treturn 0;\n\n\tif (nx_dev_request_reset(adapter))\n\t\treturn 0;\n\n\tclear_bit(__NX_FW_ATTACHED, &adapter->state);\n\n\tdev_err(&netdev->dev, \"firmware hang detected\\n\");\n\tpeg_status = NXRD32(adapter, NETXEN_PEG_HALT_STATUS1);\n\tdev_err(&adapter->pdev->dev, \"Dumping hw/fw registers\\n\"\n\t\t\t\"PEG_HALT_STATUS1: 0x%x, PEG_HALT_STATUS2: 0x%x,\\n\"\n\t\t\t\"PEG_NET_0_PC: 0x%x, PEG_NET_1_PC: 0x%x,\\n\"\n\t\t\t\"PEG_NET_2_PC: 0x%x, PEG_NET_3_PC: 0x%x,\\n\"\n\t\t\t\"PEG_NET_4_PC: 0x%x\\n\",\n\t\t\tpeg_status,\n\t\t\tNXRD32(adapter, NETXEN_PEG_HALT_STATUS2),\n\t\t\tNXRD32(adapter, NETXEN_CRB_PEG_NET_0 + 0x3c),\n\t\t\tNXRD32(adapter, NETXEN_CRB_PEG_NET_1 + 0x3c),\n\t\t\tNXRD32(adapter, NETXEN_CRB_PEG_NET_2 + 0x3c),\n\t\t\tNXRD32(adapter, NETXEN_CRB_PEG_NET_3 + 0x3c),\n\t\t\tNXRD32(adapter, NETXEN_CRB_PEG_NET_4 + 0x3c));\n\tif (NX_FWERROR_PEGSTAT1(peg_status) == 0x67)\n\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\"Firmware aborted with error code 0x00006700. \"\n\t\t\t\t\"Device is being reset.\\n\");\ndetach:\n\tif ((auto_fw_reset == AUTO_FW_RESET_ENABLED) &&\n\t\t\t!test_and_set_bit(__NX_RESETTING, &adapter->state))\n\t\tnetxen_schedule_work(adapter, netxen_detach_work, 0);\n\treturn 1;\n}\n\nstatic void\nnetxen_fw_poll_work(struct work_struct *work)\n{\n\tstruct netxen_adapter *adapter = container_of(work,\n\t\t\t\tstruct netxen_adapter, fw_work.work);\n\n\tif (test_bit(__NX_RESETTING, &adapter->state))\n\t\tgoto reschedule;\n\n\tif (test_bit(__NX_DEV_UP, &adapter->state) &&\n\t    !(adapter->capabilities & NX_FW_CAPABILITY_LINK_NOTIFICATION)) {\n\t\tif (!adapter->has_link_events) {\n\n\t\t\tnetxen_nic_handle_phy_intr(adapter);\n\n\t\t\tif (adapter->link_changed)\n\t\t\t\tnetxen_nic_set_link_parameters(adapter);\n\t\t}\n\t}\n\n\tif (netxen_check_health(adapter))\n\t\treturn;\n\nreschedule:\n\tnetxen_schedule_work(adapter, netxen_fw_poll_work, FW_POLL_DELAY);\n}\n\nstatic ssize_t\nnetxen_store_bridged_mode(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t len)\n{\n\tstruct net_device *net = to_net_dev(dev);\n\tstruct netxen_adapter *adapter = netdev_priv(net);\n\tunsigned long new;\n\tint ret = -EINVAL;\n\n\tif (!(adapter->capabilities & NX_FW_CAPABILITY_BDG))\n\t\tgoto err_out;\n\n\tif (adapter->is_up != NETXEN_ADAPTER_UP_MAGIC)\n\t\tgoto err_out;\n\n\tif (kstrtoul(buf, 2, &new))\n\t\tgoto err_out;\n\n\tif (!netxen_config_bridged_mode(adapter, !!new))\n\t\tret = len;\n\nerr_out:\n\treturn ret;\n}\n\nstatic ssize_t\nnetxen_show_bridged_mode(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct net_device *net = to_net_dev(dev);\n\tstruct netxen_adapter *adapter;\n\tint bridged_mode = 0;\n\n\tadapter = netdev_priv(net);\n\n\tif (adapter->capabilities & NX_FW_CAPABILITY_BDG)\n\t\tbridged_mode = !!(adapter->flags & NETXEN_NIC_BRIDGE_ENABLED);\n\n\treturn sprintf(buf, \"%d\\n\", bridged_mode);\n}\n\nstatic const struct device_attribute dev_attr_bridged_mode = {\n\t.attr = { .name = \"bridged_mode\", .mode = 0644 },\n\t.show = netxen_show_bridged_mode,\n\t.store = netxen_store_bridged_mode,\n};\n\nstatic ssize_t\nnetxen_store_diag_mode(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t len)\n{\n\tstruct netxen_adapter *adapter = dev_get_drvdata(dev);\n\tunsigned long new;\n\n\tif (kstrtoul(buf, 2, &new))\n\t\treturn -EINVAL;\n\n\tif (!!new != !!(adapter->flags & NETXEN_NIC_DIAG_ENABLED))\n\t\tadapter->flags ^= NETXEN_NIC_DIAG_ENABLED;\n\n\treturn len;\n}\n\nstatic ssize_t\nnetxen_show_diag_mode(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct netxen_adapter *adapter = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%d\\n\",\n\t\t\t!!(adapter->flags & NETXEN_NIC_DIAG_ENABLED));\n}\n\nstatic const struct device_attribute dev_attr_diag_mode = {\n\t.attr = { .name = \"diag_mode\", .mode = 0644 },\n\t.show = netxen_show_diag_mode,\n\t.store = netxen_store_diag_mode,\n};\n\nstatic int\nnetxen_sysfs_validate_crb(struct netxen_adapter *adapter,\n\t\tloff_t offset, size_t size)\n{\n\tsize_t crb_size = 4;\n\n\tif (!(adapter->flags & NETXEN_NIC_DIAG_ENABLED))\n\t\treturn -EIO;\n\n\tif (offset < NETXEN_PCI_CRBSPACE) {\n\t\tif (NX_IS_REVISION_P2(adapter->ahw.revision_id))\n\t\t\treturn -EINVAL;\n\n\t\tif (ADDR_IN_RANGE(offset, NETXEN_PCI_CAMQM,\n\t\t\t\t\t\tNETXEN_PCI_CAMQM_2M_END))\n\t\t\tcrb_size = 8;\n\t\telse\n\t\t\treturn -EINVAL;\n\t}\n\n\tif ((size != crb_size) || (offset & (crb_size-1)))\n\t\treturn  -EINVAL;\n\n\treturn 0;\n}\n\nstatic ssize_t\nnetxen_sysfs_read_crb(struct file *filp, struct kobject *kobj,\n\t\tstruct bin_attribute *attr,\n\t\tchar *buf, loff_t offset, size_t size)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct netxen_adapter *adapter = dev_get_drvdata(dev);\n\tu32 data;\n\tu64 qmdata;\n\tint ret;\n\n\tret = netxen_sysfs_validate_crb(adapter, offset, size);\n\tif (ret != 0)\n\t\treturn ret;\n\n\tif (NX_IS_REVISION_P3(adapter->ahw.revision_id) &&\n\t\tADDR_IN_RANGE(offset, NETXEN_PCI_CAMQM,\n\t\t\t\t\tNETXEN_PCI_CAMQM_2M_END)) {\n\t\tnetxen_pci_camqm_read_2M(adapter, offset, &qmdata);\n\t\tmemcpy(buf, &qmdata, size);\n\t} else {\n\t\tdata = NXRD32(adapter, offset);\n\t\tmemcpy(buf, &data, size);\n\t}\n\n\treturn size;\n}\n\nstatic ssize_t\nnetxen_sysfs_write_crb(struct file *filp, struct kobject *kobj,\n\t\tstruct bin_attribute *attr,\n\t\tchar *buf, loff_t offset, size_t size)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct netxen_adapter *adapter = dev_get_drvdata(dev);\n\tu32 data;\n\tu64 qmdata;\n\tint ret;\n\n\tret = netxen_sysfs_validate_crb(adapter, offset, size);\n\tif (ret != 0)\n\t\treturn ret;\n\n\tif (NX_IS_REVISION_P3(adapter->ahw.revision_id) &&\n\t\tADDR_IN_RANGE(offset, NETXEN_PCI_CAMQM,\n\t\t\t\t\tNETXEN_PCI_CAMQM_2M_END)) {\n\t\tmemcpy(&qmdata, buf, size);\n\t\tnetxen_pci_camqm_write_2M(adapter, offset, qmdata);\n\t} else {\n\t\tmemcpy(&data, buf, size);\n\t\tNXWR32(adapter, offset, data);\n\t}\n\n\treturn size;\n}\n\nstatic int\nnetxen_sysfs_validate_mem(struct netxen_adapter *adapter,\n\t\tloff_t offset, size_t size)\n{\n\tif (!(adapter->flags & NETXEN_NIC_DIAG_ENABLED))\n\t\treturn -EIO;\n\n\tif ((size != 8) || (offset & 0x7))\n\t\treturn  -EIO;\n\n\treturn 0;\n}\n\nstatic ssize_t\nnetxen_sysfs_read_mem(struct file *filp, struct kobject *kobj,\n\t\tstruct bin_attribute *attr,\n\t\tchar *buf, loff_t offset, size_t size)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct netxen_adapter *adapter = dev_get_drvdata(dev);\n\tu64 data;\n\tint ret;\n\n\tret = netxen_sysfs_validate_mem(adapter, offset, size);\n\tif (ret != 0)\n\t\treturn ret;\n\n\tif (adapter->pci_mem_read(adapter, offset, &data))\n\t\treturn -EIO;\n\n\tmemcpy(buf, &data, size);\n\n\treturn size;\n}\n\nstatic ssize_t netxen_sysfs_write_mem(struct file *filp, struct kobject *kobj,\n\t\tstruct bin_attribute *attr, char *buf,\n\t\tloff_t offset, size_t size)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct netxen_adapter *adapter = dev_get_drvdata(dev);\n\tu64 data;\n\tint ret;\n\n\tret = netxen_sysfs_validate_mem(adapter, offset, size);\n\tif (ret != 0)\n\t\treturn ret;\n\n\tmemcpy(&data, buf, size);\n\n\tif (adapter->pci_mem_write(adapter, offset, data))\n\t\treturn -EIO;\n\n\treturn size;\n}\n\n\nstatic const struct bin_attribute bin_attr_crb = {\n\t.attr = { .name = \"crb\", .mode = 0644 },\n\t.size = 0,\n\t.read = netxen_sysfs_read_crb,\n\t.write = netxen_sysfs_write_crb,\n};\n\nstatic const struct bin_attribute bin_attr_mem = {\n\t.attr = { .name = \"mem\", .mode = 0644 },\n\t.size = 0,\n\t.read = netxen_sysfs_read_mem,\n\t.write = netxen_sysfs_write_mem,\n};\n\nstatic ssize_t\nnetxen_sysfs_read_dimm(struct file *filp, struct kobject *kobj,\n\t\tstruct bin_attribute *attr,\n\t\tchar *buf, loff_t offset, size_t size)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct netxen_adapter *adapter = dev_get_drvdata(dev);\n\tstruct net_device *netdev = adapter->netdev;\n\tstruct netxen_dimm_cfg dimm;\n\tu8 dw, rows, cols, banks, ranks;\n\tu32 val;\n\n\tif (size < attr->size) {\n\t\tnetdev_err(netdev, \"Invalid size\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmemset(&dimm, 0, sizeof(struct netxen_dimm_cfg));\n\tval = NXRD32(adapter, NETXEN_DIMM_CAPABILITY);\n\n\t \n\tif (val & NETXEN_DIMM_VALID_FLAG) {\n\t\tnetdev_err(netdev, \"Invalid DIMM flag\\n\");\n\t\tdimm.presence = 0xff;\n\t\tgoto out;\n\t}\n\n\trows = NETXEN_DIMM_NUMROWS(val);\n\tcols = NETXEN_DIMM_NUMCOLS(val);\n\tranks = NETXEN_DIMM_NUMRANKS(val);\n\tbanks = NETXEN_DIMM_NUMBANKS(val);\n\tdw = NETXEN_DIMM_DATAWIDTH(val);\n\n\tdimm.presence = (val & NETXEN_DIMM_PRESENT);\n\n\t \n\tif (!dimm.presence) {\n\t\tnetdev_err(netdev, \"DIMM not present\\n\");\n\t\tgoto out;\n\t}\n\n\tdimm.dimm_type = NETXEN_DIMM_TYPE(val);\n\n\tswitch (dimm.dimm_type) {\n\tcase NETXEN_DIMM_TYPE_RDIMM:\n\tcase NETXEN_DIMM_TYPE_UDIMM:\n\tcase NETXEN_DIMM_TYPE_SO_DIMM:\n\tcase NETXEN_DIMM_TYPE_Micro_DIMM:\n\tcase NETXEN_DIMM_TYPE_Mini_RDIMM:\n\tcase NETXEN_DIMM_TYPE_Mini_UDIMM:\n\t\tbreak;\n\tdefault:\n\t\tnetdev_err(netdev, \"Invalid DIMM type %x\\n\", dimm.dimm_type);\n\t\tgoto out;\n\t}\n\n\tif (val & NETXEN_DIMM_MEMTYPE_DDR2_SDRAM)\n\t\tdimm.mem_type = NETXEN_DIMM_MEM_DDR2_SDRAM;\n\telse\n\t\tdimm.mem_type = NETXEN_DIMM_MEMTYPE(val);\n\n\tif (val & NETXEN_DIMM_SIZE) {\n\t\tdimm.size = NETXEN_DIMM_STD_MEM_SIZE;\n\t\tgoto out;\n\t}\n\n\tif (!rows) {\n\t\tnetdev_err(netdev, \"Invalid no of rows %x\\n\", rows);\n\t\tgoto out;\n\t}\n\n\tif (!cols) {\n\t\tnetdev_err(netdev, \"Invalid no of columns %x\\n\", cols);\n\t\tgoto out;\n\t}\n\n\tif (!banks) {\n\t\tnetdev_err(netdev, \"Invalid no of banks %x\\n\", banks);\n\t\tgoto out;\n\t}\n\n\tranks += 1;\n\n\tswitch (dw) {\n\tcase 0x0:\n\t\tdw = 32;\n\t\tbreak;\n\tcase 0x1:\n\t\tdw = 33;\n\t\tbreak;\n\tcase 0x2:\n\t\tdw = 36;\n\t\tbreak;\n\tcase 0x3:\n\t\tdw = 64;\n\t\tbreak;\n\tcase 0x4:\n\t\tdw = 72;\n\t\tbreak;\n\tcase 0x5:\n\t\tdw = 80;\n\t\tbreak;\n\tcase 0x6:\n\t\tdw = 128;\n\t\tbreak;\n\tcase 0x7:\n\t\tdw = 144;\n\t\tbreak;\n\tdefault:\n\t\tnetdev_err(netdev, \"Invalid data-width %x\\n\", dw);\n\t\tgoto out;\n\t}\n\n\tdimm.size = ((1 << rows) * (1 << cols) * dw * banks * ranks) / 8;\n\t \n\tdimm.size = (dimm.size) / 0x100000;\nout:\n\tmemcpy(buf, &dimm, sizeof(struct netxen_dimm_cfg));\n\treturn sizeof(struct netxen_dimm_cfg);\n\n}\n\nstatic const struct bin_attribute bin_attr_dimm = {\n\t.attr = { .name = \"dimm\", .mode = 0644 },\n\t.size = sizeof(struct netxen_dimm_cfg),\n\t.read = netxen_sysfs_read_dimm,\n};\n\n\nstatic void\nnetxen_create_sysfs_entries(struct netxen_adapter *adapter)\n{\n\tstruct device *dev = &adapter->pdev->dev;\n\n\tif (adapter->capabilities & NX_FW_CAPABILITY_BDG) {\n\t\t \n\t\tif (device_create_file(dev, &dev_attr_bridged_mode)) {\n\t\t\tdev_warn(dev,\n\t\t\t\t\"failed to create bridged_mode sysfs entry\\n\");\n\t\t}\n\t}\n}\n\nstatic void\nnetxen_remove_sysfs_entries(struct netxen_adapter *adapter)\n{\n\tstruct device *dev = &adapter->pdev->dev;\n\n\tif (adapter->capabilities & NX_FW_CAPABILITY_BDG)\n\t\tdevice_remove_file(dev, &dev_attr_bridged_mode);\n}\n\nstatic void\nnetxen_create_diag_entries(struct netxen_adapter *adapter)\n{\n\tstruct pci_dev *pdev = adapter->pdev;\n\tstruct device *dev;\n\n\tdev = &pdev->dev;\n\tif (device_create_file(dev, &dev_attr_diag_mode))\n\t\tdev_info(dev, \"failed to create diag_mode sysfs entry\\n\");\n\tif (device_create_bin_file(dev, &bin_attr_crb))\n\t\tdev_info(dev, \"failed to create crb sysfs entry\\n\");\n\tif (device_create_bin_file(dev, &bin_attr_mem))\n\t\tdev_info(dev, \"failed to create mem sysfs entry\\n\");\n\tif (device_create_bin_file(dev, &bin_attr_dimm))\n\t\tdev_info(dev, \"failed to create dimm sysfs entry\\n\");\n}\n\n\nstatic void\nnetxen_remove_diag_entries(struct netxen_adapter *adapter)\n{\n\tstruct pci_dev *pdev = adapter->pdev;\n\tstruct device *dev = &pdev->dev;\n\n\tdevice_remove_file(dev, &dev_attr_diag_mode);\n\tdevice_remove_bin_file(dev, &bin_attr_crb);\n\tdevice_remove_bin_file(dev, &bin_attr_mem);\n\tdevice_remove_bin_file(dev, &bin_attr_dimm);\n}\n\n#ifdef CONFIG_INET\n\n#define is_netxen_netdev(dev) (dev->netdev_ops == &netxen_netdev_ops)\n\nstatic int\nnetxen_destip_supported(struct netxen_adapter *adapter)\n{\n\tif (NX_IS_REVISION_P2(adapter->ahw.revision_id))\n\t\treturn 0;\n\n\tif (adapter->ahw.cut_through)\n\t\treturn 0;\n\n\treturn 1;\n}\n\nstatic void\nnetxen_free_ip_list(struct netxen_adapter *adapter, bool master)\n{\n\tstruct nx_ip_list  *cur, *tmp_cur;\n\n\tlist_for_each_entry_safe(cur, tmp_cur, &adapter->ip_list, list) {\n\t\tif (master) {\n\t\t\tif (cur->master) {\n\t\t\t\tnetxen_config_ipaddr(adapter, cur->ip_addr,\n\t\t\t\t\t\t     NX_IP_DOWN);\n\t\t\t\tlist_del(&cur->list);\n\t\t\t\tkfree(cur);\n\t\t\t}\n\t\t} else {\n\t\t\tnetxen_config_ipaddr(adapter, cur->ip_addr, NX_IP_DOWN);\n\t\t\tlist_del(&cur->list);\n\t\t\tkfree(cur);\n\t\t}\n\t}\n}\n\nstatic bool\nnetxen_list_config_ip(struct netxen_adapter *adapter,\n\t\tstruct in_ifaddr *ifa, unsigned long event)\n{\n\tstruct net_device *dev;\n\tstruct nx_ip_list *cur, *tmp_cur;\n\tstruct list_head *head;\n\tbool ret = false;\n\n\tdev = ifa->ifa_dev ? ifa->ifa_dev->dev : NULL;\n\n\tif (dev == NULL)\n\t\tgoto out;\n\n\tswitch (event) {\n\tcase NX_IP_UP:\n\t\tlist_for_each(head, &adapter->ip_list) {\n\t\t\tcur = list_entry(head, struct nx_ip_list, list);\n\n\t\t\tif (cur->ip_addr == ifa->ifa_address)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\tcur = kzalloc(sizeof(struct nx_ip_list), GFP_ATOMIC);\n\t\tif (cur == NULL)\n\t\t\tgoto out;\n\t\tif (is_vlan_dev(dev))\n\t\t\tdev = vlan_dev_real_dev(dev);\n\t\tcur->master = !!netif_is_bond_master(dev);\n\t\tcur->ip_addr = ifa->ifa_address;\n\t\tlist_add_tail(&cur->list, &adapter->ip_list);\n\t\tnetxen_config_ipaddr(adapter, ifa->ifa_address, NX_IP_UP);\n\t\tret = true;\n\t\tbreak;\n\tcase NX_IP_DOWN:\n\t\tlist_for_each_entry_safe(cur, tmp_cur,\n\t\t\t\t\t&adapter->ip_list, list) {\n\t\t\tif (cur->ip_addr == ifa->ifa_address) {\n\t\t\t\tlist_del(&cur->list);\n\t\t\t\tkfree(cur);\n\t\t\t\tnetxen_config_ipaddr(adapter, ifa->ifa_address,\n\t\t\t\t\t\t     NX_IP_DOWN);\n\t\t\t\tret = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\nout:\n\treturn ret;\n}\n\nstatic void\nnetxen_config_indev_addr(struct netxen_adapter *adapter,\n\t\tstruct net_device *dev, unsigned long event)\n{\n\tstruct in_device *indev;\n\tstruct in_ifaddr *ifa;\n\n\tif (!netxen_destip_supported(adapter))\n\t\treturn;\n\n\tindev = in_dev_get(dev);\n\tif (!indev)\n\t\treturn;\n\n\trcu_read_lock();\n\tin_dev_for_each_ifa_rcu(ifa, indev) {\n\t\tswitch (event) {\n\t\tcase NETDEV_UP:\n\t\t\tnetxen_list_config_ip(adapter, ifa, NX_IP_UP);\n\t\t\tbreak;\n\t\tcase NETDEV_DOWN:\n\t\t\tnetxen_list_config_ip(adapter, ifa, NX_IP_DOWN);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\tin_dev_put(indev);\n}\n\nstatic void\nnetxen_restore_indev_addr(struct net_device *netdev, unsigned long event)\n\n{\n\tstruct netxen_adapter *adapter = netdev_priv(netdev);\n\tstruct nx_ip_list *pos, *tmp_pos;\n\tunsigned long ip_event;\n\n\tip_event = (event == NETDEV_UP) ? NX_IP_UP : NX_IP_DOWN;\n\tnetxen_config_indev_addr(adapter, netdev, event);\n\n\tlist_for_each_entry_safe(pos, tmp_pos, &adapter->ip_list, list) {\n\t\tnetxen_config_ipaddr(adapter, pos->ip_addr, ip_event);\n\t}\n}\n\nstatic inline bool\nnetxen_config_checkdev(struct net_device *dev)\n{\n\tstruct netxen_adapter *adapter;\n\n\tif (!is_netxen_netdev(dev))\n\t\treturn false;\n\tadapter = netdev_priv(dev);\n\tif (!adapter)\n\t\treturn false;\n\tif (!netxen_destip_supported(adapter))\n\t\treturn false;\n\tif (adapter->is_up != NETXEN_ADAPTER_UP_MAGIC)\n\t\treturn false;\n\n\treturn true;\n}\n\n \nstatic void netxen_config_master(struct net_device *dev, unsigned long event)\n{\n\tstruct net_device *master, *slave;\n\tstruct netxen_adapter *adapter = netdev_priv(dev);\n\n\trcu_read_lock();\n\tmaster = netdev_master_upper_dev_get_rcu(dev);\n\t \n\tif (master && netif_is_bond_master(master) &&\n\t    !netif_is_bond_slave(dev)) {\n\t\tnetxen_config_indev_addr(adapter, master, event);\n\t\tfor_each_netdev_rcu(&init_net, slave)\n\t\t\tif (is_vlan_dev(slave) &&\n\t\t\t    vlan_dev_real_dev(slave) == master)\n\t\t\t\tnetxen_config_indev_addr(adapter, slave, event);\n\t}\n\trcu_read_unlock();\n\t \n\tif (!master && dev->priv_flags & IFF_BONDING)\n\t\tnetxen_free_ip_list(adapter, true);\n}\n\nstatic int netxen_netdev_event(struct notifier_block *this,\n\t\t\t\t unsigned long event, void *ptr)\n{\n\tstruct netxen_adapter *adapter;\n\tstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\n\tstruct net_device *orig_dev = dev;\n\tstruct net_device *slave;\n\nrecheck:\n\tif (dev == NULL)\n\t\tgoto done;\n\n\tif (is_vlan_dev(dev)) {\n\t\tdev = vlan_dev_real_dev(dev);\n\t\tgoto recheck;\n\t}\n\tif (event == NETDEV_UP || event == NETDEV_DOWN) {\n\t\t \n\t\tif (netif_is_bond_master(dev)) {\n\t\t\trcu_read_lock();\n\t\t\tfor_each_netdev_in_bond_rcu(dev, slave) {\n\t\t\t\tif (!netxen_config_checkdev(slave))\n\t\t\t\t\tcontinue;\n\t\t\t\tadapter = netdev_priv(slave);\n\t\t\t\tnetxen_config_indev_addr(adapter,\n\t\t\t\t\t\t\t orig_dev, event);\n\t\t\t}\n\t\t\trcu_read_unlock();\n\t\t} else {\n\t\t\tif (!netxen_config_checkdev(dev))\n\t\t\t\tgoto done;\n\t\t\tadapter = netdev_priv(dev);\n\t\t\t \n\t\t\tif (orig_dev == dev)\n\t\t\t\tnetxen_config_master(dev, event);\n\t\t\tnetxen_config_indev_addr(adapter, orig_dev, event);\n\t\t}\n\t}\ndone:\n\treturn NOTIFY_DONE;\n}\n\nstatic int\nnetxen_inetaddr_event(struct notifier_block *this,\n\t\tunsigned long event, void *ptr)\n{\n\tstruct netxen_adapter *adapter;\n\tstruct net_device *dev, *slave;\n\tstruct in_ifaddr *ifa = (struct in_ifaddr *)ptr;\n\tunsigned long ip_event;\n\n\tdev = ifa->ifa_dev ? ifa->ifa_dev->dev : NULL;\n\tip_event = (event == NETDEV_UP) ? NX_IP_UP : NX_IP_DOWN;\nrecheck:\n\tif (dev == NULL)\n\t\tgoto done;\n\n\tif (is_vlan_dev(dev)) {\n\t\tdev = vlan_dev_real_dev(dev);\n\t\tgoto recheck;\n\t}\n\tif (event == NETDEV_UP || event == NETDEV_DOWN) {\n\t\t \n\t\tif (netif_is_bond_master(dev)) {\n\t\t\trcu_read_lock();\n\t\t\tfor_each_netdev_in_bond_rcu(dev, slave) {\n\t\t\t\tif (!netxen_config_checkdev(slave))\n\t\t\t\t\tcontinue;\n\t\t\t\tadapter = netdev_priv(slave);\n\t\t\t\tnetxen_list_config_ip(adapter, ifa, ip_event);\n\t\t\t}\n\t\t\trcu_read_unlock();\n\t\t} else {\n\t\t\tif (!netxen_config_checkdev(dev))\n\t\t\t\tgoto done;\n\t\t\tadapter = netdev_priv(dev);\n\t\t\tnetxen_list_config_ip(adapter, ifa, ip_event);\n\t\t}\n\t}\ndone:\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block\tnetxen_netdev_cb = {\n\t.notifier_call = netxen_netdev_event,\n};\n\nstatic struct notifier_block netxen_inetaddr_cb = {\n\t.notifier_call = netxen_inetaddr_event,\n};\n#else\nstatic void\nnetxen_restore_indev_addr(struct net_device *dev, unsigned long event)\n{ }\nstatic void\nnetxen_free_ip_list(struct netxen_adapter *adapter, bool master)\n{ }\n#endif\n\nstatic const struct pci_error_handlers netxen_err_handler = {\n\t.error_detected = netxen_io_error_detected,\n\t.slot_reset = netxen_io_slot_reset,\n};\n\nstatic SIMPLE_DEV_PM_OPS(netxen_nic_pm_ops,\n\t\t\t netxen_nic_suspend,\n\t\t\t netxen_nic_resume);\n\nstatic struct pci_driver netxen_driver = {\n\t.name = netxen_nic_driver_name,\n\t.id_table = netxen_pci_tbl,\n\t.probe = netxen_nic_probe,\n\t.remove = netxen_nic_remove,\n\t.driver.pm = &netxen_nic_pm_ops,\n\t.shutdown = netxen_nic_shutdown,\n\t.err_handler = &netxen_err_handler\n};\n\nstatic int __init netxen_init_module(void)\n{\n\tprintk(KERN_INFO \"%s\\n\", netxen_nic_driver_string);\n\n#ifdef CONFIG_INET\n\tregister_netdevice_notifier(&netxen_netdev_cb);\n\tregister_inetaddr_notifier(&netxen_inetaddr_cb);\n#endif\n\treturn pci_register_driver(&netxen_driver);\n}\n\nmodule_init(netxen_init_module);\n\nstatic void __exit netxen_exit_module(void)\n{\n\tpci_unregister_driver(&netxen_driver);\n\n#ifdef CONFIG_INET\n\tunregister_inetaddr_notifier(&netxen_inetaddr_cb);\n\tunregister_netdevice_notifier(&netxen_netdev_cb);\n#endif\n}\n\nmodule_exit(netxen_exit_module);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}