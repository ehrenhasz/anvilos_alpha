{
  "module_name": "qede_ethtool.c",
  "hash_id": "2e353a71f83c2845ea39367d025732491797cad5a9811da42ea457a32db743b4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/qlogic/qede/qede_ethtool.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/ethtool.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/capability.h>\n#include <linux/vmalloc.h>\n#include <linux/phylink.h>\n\n#include \"qede.h\"\n#include \"qede_ptp.h\"\n\n#define QEDE_RQSTAT_OFFSET(stat_name) \\\n\t (offsetof(struct qede_rx_queue, stat_name))\n#define QEDE_RQSTAT_STRING(stat_name) (#stat_name)\n#define QEDE_RQSTAT(stat_name) \\\n\t {QEDE_RQSTAT_OFFSET(stat_name), QEDE_RQSTAT_STRING(stat_name)}\n\n#define QEDE_SELFTEST_POLL_COUNT 100\n#define QEDE_DUMP_VERSION\t0x1\n#define QEDE_DUMP_NVM_ARG_COUNT\t2\n\nstatic const struct {\n\tu64 offset;\n\tchar string[ETH_GSTRING_LEN];\n} qede_rqstats_arr[] = {\n\tQEDE_RQSTAT(rcv_pkts),\n\tQEDE_RQSTAT(rx_hw_errors),\n\tQEDE_RQSTAT(rx_alloc_errors),\n\tQEDE_RQSTAT(rx_ip_frags),\n\tQEDE_RQSTAT(xdp_no_pass),\n};\n\n#define QEDE_NUM_RQSTATS ARRAY_SIZE(qede_rqstats_arr)\n#define QEDE_TQSTAT_OFFSET(stat_name) \\\n\t(offsetof(struct qede_tx_queue, stat_name))\n#define QEDE_TQSTAT_STRING(stat_name) (#stat_name)\n#define QEDE_TQSTAT(stat_name) \\\n\t{QEDE_TQSTAT_OFFSET(stat_name), QEDE_TQSTAT_STRING(stat_name)}\n#define QEDE_NUM_TQSTATS ARRAY_SIZE(qede_tqstats_arr)\nstatic const struct {\n\tu64 offset;\n\tchar string[ETH_GSTRING_LEN];\n} qede_tqstats_arr[] = {\n\tQEDE_TQSTAT(xmit_pkts),\n\tQEDE_TQSTAT(stopped_cnt),\n\tQEDE_TQSTAT(tx_mem_alloc_err),\n};\n\n#define QEDE_STAT_OFFSET(stat_name, type, base) \\\n\t(offsetof(type, stat_name) + (base))\n#define QEDE_STAT_STRING(stat_name)\t(#stat_name)\n#define _QEDE_STAT(stat_name, type, base, attr) \\\n\t{QEDE_STAT_OFFSET(stat_name, type, base), \\\n\t QEDE_STAT_STRING(stat_name), \\\n\t attr}\n#define QEDE_STAT(stat_name) \\\n\t_QEDE_STAT(stat_name, struct qede_stats_common, 0, 0x0)\n#define QEDE_PF_STAT(stat_name) \\\n\t_QEDE_STAT(stat_name, struct qede_stats_common, 0, \\\n\t\t   BIT(QEDE_STAT_PF_ONLY))\n#define QEDE_PF_BB_STAT(stat_name) \\\n\t_QEDE_STAT(stat_name, struct qede_stats_bb, \\\n\t\t   offsetof(struct qede_stats, bb), \\\n\t\t   BIT(QEDE_STAT_PF_ONLY) | BIT(QEDE_STAT_BB_ONLY))\n#define QEDE_PF_AH_STAT(stat_name) \\\n\t_QEDE_STAT(stat_name, struct qede_stats_ah, \\\n\t\t   offsetof(struct qede_stats, ah), \\\n\t\t   BIT(QEDE_STAT_PF_ONLY) | BIT(QEDE_STAT_AH_ONLY))\nstatic const struct {\n\tu64 offset;\n\tchar string[ETH_GSTRING_LEN];\n\tunsigned long attr;\n#define QEDE_STAT_PF_ONLY\t0\n#define QEDE_STAT_BB_ONLY\t1\n#define QEDE_STAT_AH_ONLY\t2\n} qede_stats_arr[] = {\n\tQEDE_STAT(rx_ucast_bytes),\n\tQEDE_STAT(rx_mcast_bytes),\n\tQEDE_STAT(rx_bcast_bytes),\n\tQEDE_STAT(rx_ucast_pkts),\n\tQEDE_STAT(rx_mcast_pkts),\n\tQEDE_STAT(rx_bcast_pkts),\n\n\tQEDE_STAT(tx_ucast_bytes),\n\tQEDE_STAT(tx_mcast_bytes),\n\tQEDE_STAT(tx_bcast_bytes),\n\tQEDE_STAT(tx_ucast_pkts),\n\tQEDE_STAT(tx_mcast_pkts),\n\tQEDE_STAT(tx_bcast_pkts),\n\n\tQEDE_PF_STAT(rx_64_byte_packets),\n\tQEDE_PF_STAT(rx_65_to_127_byte_packets),\n\tQEDE_PF_STAT(rx_128_to_255_byte_packets),\n\tQEDE_PF_STAT(rx_256_to_511_byte_packets),\n\tQEDE_PF_STAT(rx_512_to_1023_byte_packets),\n\tQEDE_PF_STAT(rx_1024_to_1518_byte_packets),\n\tQEDE_PF_BB_STAT(rx_1519_to_1522_byte_packets),\n\tQEDE_PF_BB_STAT(rx_1519_to_2047_byte_packets),\n\tQEDE_PF_BB_STAT(rx_2048_to_4095_byte_packets),\n\tQEDE_PF_BB_STAT(rx_4096_to_9216_byte_packets),\n\tQEDE_PF_BB_STAT(rx_9217_to_16383_byte_packets),\n\tQEDE_PF_AH_STAT(rx_1519_to_max_byte_packets),\n\tQEDE_PF_STAT(tx_64_byte_packets),\n\tQEDE_PF_STAT(tx_65_to_127_byte_packets),\n\tQEDE_PF_STAT(tx_128_to_255_byte_packets),\n\tQEDE_PF_STAT(tx_256_to_511_byte_packets),\n\tQEDE_PF_STAT(tx_512_to_1023_byte_packets),\n\tQEDE_PF_STAT(tx_1024_to_1518_byte_packets),\n\tQEDE_PF_BB_STAT(tx_1519_to_2047_byte_packets),\n\tQEDE_PF_BB_STAT(tx_2048_to_4095_byte_packets),\n\tQEDE_PF_BB_STAT(tx_4096_to_9216_byte_packets),\n\tQEDE_PF_BB_STAT(tx_9217_to_16383_byte_packets),\n\tQEDE_PF_AH_STAT(tx_1519_to_max_byte_packets),\n\tQEDE_PF_STAT(rx_mac_crtl_frames),\n\tQEDE_PF_STAT(tx_mac_ctrl_frames),\n\tQEDE_PF_STAT(rx_pause_frames),\n\tQEDE_PF_STAT(tx_pause_frames),\n\tQEDE_PF_STAT(rx_pfc_frames),\n\tQEDE_PF_STAT(tx_pfc_frames),\n\n\tQEDE_PF_STAT(rx_crc_errors),\n\tQEDE_PF_STAT(rx_align_errors),\n\tQEDE_PF_STAT(rx_carrier_errors),\n\tQEDE_PF_STAT(rx_oversize_packets),\n\tQEDE_PF_STAT(rx_jabbers),\n\tQEDE_PF_STAT(rx_undersize_packets),\n\tQEDE_PF_STAT(rx_fragments),\n\tQEDE_PF_BB_STAT(tx_lpi_entry_count),\n\tQEDE_PF_BB_STAT(tx_total_collisions),\n\tQEDE_PF_STAT(brb_truncates),\n\tQEDE_PF_STAT(brb_discards),\n\tQEDE_STAT(no_buff_discards),\n\tQEDE_PF_STAT(mftag_filter_discards),\n\tQEDE_PF_STAT(mac_filter_discards),\n\tQEDE_PF_STAT(gft_filter_drop),\n\tQEDE_STAT(tx_err_drop_pkts),\n\tQEDE_STAT(ttl0_discard),\n\tQEDE_STAT(packet_too_big_discard),\n\n\tQEDE_STAT(coalesced_pkts),\n\tQEDE_STAT(coalesced_events),\n\tQEDE_STAT(coalesced_aborts_num),\n\tQEDE_STAT(non_coalesced_pkts),\n\tQEDE_STAT(coalesced_bytes),\n\n\tQEDE_STAT(link_change_count),\n\tQEDE_STAT(ptp_skip_txts),\n};\n\n#define QEDE_NUM_STATS\tARRAY_SIZE(qede_stats_arr)\n#define QEDE_STAT_IS_PF_ONLY(i) \\\n\ttest_bit(QEDE_STAT_PF_ONLY, &qede_stats_arr[i].attr)\n#define QEDE_STAT_IS_BB_ONLY(i) \\\n\ttest_bit(QEDE_STAT_BB_ONLY, &qede_stats_arr[i].attr)\n#define QEDE_STAT_IS_AH_ONLY(i) \\\n\ttest_bit(QEDE_STAT_AH_ONLY, &qede_stats_arr[i].attr)\n\nenum {\n\tQEDE_PRI_FLAG_CMT,\n\tQEDE_PRI_FLAG_SMART_AN_SUPPORT,  \n\tQEDE_PRI_FLAG_RECOVER_ON_ERROR,\n\tQEDE_PRI_FLAG_ESL_SUPPORT,  \n\tQEDE_PRI_FLAG_ESL_ACTIVE,  \n\tQEDE_PRI_FLAG_LEN,\n};\n\nstatic const char qede_private_arr[QEDE_PRI_FLAG_LEN][ETH_GSTRING_LEN] = {\n\t\"Coupled-Function\",\n\t\"SmartAN capable\",\n\t\"Recover on error\",\n\t\"ESL capable\",\n\t\"ESL active\",\n};\n\nenum qede_ethtool_tests {\n\tQEDE_ETHTOOL_INT_LOOPBACK,\n\tQEDE_ETHTOOL_INTERRUPT_TEST,\n\tQEDE_ETHTOOL_MEMORY_TEST,\n\tQEDE_ETHTOOL_REGISTER_TEST,\n\tQEDE_ETHTOOL_CLOCK_TEST,\n\tQEDE_ETHTOOL_NVRAM_TEST,\n\tQEDE_ETHTOOL_TEST_MAX\n};\n\nstatic const char qede_tests_str_arr[QEDE_ETHTOOL_TEST_MAX][ETH_GSTRING_LEN] = {\n\t\"Internal loopback (offline)\",\n\t\"Interrupt (online)\\t\",\n\t\"Memory (online)\\t\\t\",\n\t\"Register (online)\\t\",\n\t\"Clock (online)\\t\\t\",\n\t\"Nvram (online)\\t\\t\",\n};\n\n \n\nstruct qede_forced_speed_map {\n\tu32\t\tspeed;\n\t__ETHTOOL_DECLARE_LINK_MODE_MASK(caps);\n\n\tconst u32\t*cap_arr;\n\tu32\t\tarr_size;\n};\n\n#define QEDE_FORCED_SPEED_MAP(value)\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\t.speed\t\t= SPEED_##value,\t\t\t\t\\\n\t.cap_arr\t= qede_forced_speed_##value,\t\t\t\\\n\t.arr_size\t= ARRAY_SIZE(qede_forced_speed_##value),\t\\\n}\n\nstatic const u32 qede_forced_speed_1000[] __initconst = {\n\tETHTOOL_LINK_MODE_1000baseT_Full_BIT,\n\tETHTOOL_LINK_MODE_1000baseKX_Full_BIT,\n\tETHTOOL_LINK_MODE_1000baseX_Full_BIT,\n};\n\nstatic const u32 qede_forced_speed_10000[] __initconst = {\n\tETHTOOL_LINK_MODE_10000baseT_Full_BIT,\n\tETHTOOL_LINK_MODE_10000baseKR_Full_BIT,\n\tETHTOOL_LINK_MODE_10000baseKX4_Full_BIT,\n\tETHTOOL_LINK_MODE_10000baseR_FEC_BIT,\n\tETHTOOL_LINK_MODE_10000baseCR_Full_BIT,\n\tETHTOOL_LINK_MODE_10000baseSR_Full_BIT,\n\tETHTOOL_LINK_MODE_10000baseLR_Full_BIT,\n\tETHTOOL_LINK_MODE_10000baseLRM_Full_BIT,\n};\n\nstatic const u32 qede_forced_speed_20000[] __initconst = {\n\tETHTOOL_LINK_MODE_20000baseKR2_Full_BIT,\n};\n\nstatic const u32 qede_forced_speed_25000[] __initconst = {\n\tETHTOOL_LINK_MODE_25000baseKR_Full_BIT,\n\tETHTOOL_LINK_MODE_25000baseCR_Full_BIT,\n\tETHTOOL_LINK_MODE_25000baseSR_Full_BIT,\n};\n\nstatic const u32 qede_forced_speed_40000[] __initconst = {\n\tETHTOOL_LINK_MODE_40000baseLR4_Full_BIT,\n\tETHTOOL_LINK_MODE_40000baseKR4_Full_BIT,\n\tETHTOOL_LINK_MODE_40000baseCR4_Full_BIT,\n\tETHTOOL_LINK_MODE_40000baseSR4_Full_BIT,\n};\n\nstatic const u32 qede_forced_speed_50000[] __initconst = {\n\tETHTOOL_LINK_MODE_50000baseKR2_Full_BIT,\n\tETHTOOL_LINK_MODE_50000baseCR2_Full_BIT,\n\tETHTOOL_LINK_MODE_50000baseSR2_Full_BIT,\n};\n\nstatic const u32 qede_forced_speed_100000[] __initconst = {\n\tETHTOOL_LINK_MODE_100000baseKR4_Full_BIT,\n\tETHTOOL_LINK_MODE_100000baseSR4_Full_BIT,\n\tETHTOOL_LINK_MODE_100000baseCR4_Full_BIT,\n\tETHTOOL_LINK_MODE_100000baseLR4_ER4_Full_BIT,\n};\n\nstatic struct qede_forced_speed_map qede_forced_speed_maps[] __ro_after_init = {\n\tQEDE_FORCED_SPEED_MAP(1000),\n\tQEDE_FORCED_SPEED_MAP(10000),\n\tQEDE_FORCED_SPEED_MAP(20000),\n\tQEDE_FORCED_SPEED_MAP(25000),\n\tQEDE_FORCED_SPEED_MAP(40000),\n\tQEDE_FORCED_SPEED_MAP(50000),\n\tQEDE_FORCED_SPEED_MAP(100000),\n};\n\nvoid __init qede_forced_speed_maps_init(void)\n{\n\tstruct qede_forced_speed_map *map;\n\tu32 i;\n\n\tfor (i = 0; i < ARRAY_SIZE(qede_forced_speed_maps); i++) {\n\t\tmap = qede_forced_speed_maps + i;\n\n\t\tlinkmode_set_bit_array(map->cap_arr, map->arr_size, map->caps);\n\t\tmap->cap_arr = NULL;\n\t\tmap->arr_size = 0;\n\t}\n}\n\n \n\nstatic void qede_get_strings_stats_txq(struct qede_dev *edev,\n\t\t\t\t       struct qede_tx_queue *txq, u8 **buf)\n{\n\tint i;\n\n\tfor (i = 0; i < QEDE_NUM_TQSTATS; i++) {\n\t\tif (txq->is_xdp)\n\t\t\tsprintf(*buf, \"%d [XDP]: %s\",\n\t\t\t\tQEDE_TXQ_XDP_TO_IDX(edev, txq),\n\t\t\t\tqede_tqstats_arr[i].string);\n\t\telse\n\t\t\tsprintf(*buf, \"%d_%d: %s\", txq->index, txq->cos,\n\t\t\t\tqede_tqstats_arr[i].string);\n\t\t*buf += ETH_GSTRING_LEN;\n\t}\n}\n\nstatic void qede_get_strings_stats_rxq(struct qede_dev *edev,\n\t\t\t\t       struct qede_rx_queue *rxq, u8 **buf)\n{\n\tint i;\n\n\tfor (i = 0; i < QEDE_NUM_RQSTATS; i++) {\n\t\tsprintf(*buf, \"%d: %s\", rxq->rxq_id,\n\t\t\tqede_rqstats_arr[i].string);\n\t\t*buf += ETH_GSTRING_LEN;\n\t}\n}\n\nstatic bool qede_is_irrelevant_stat(struct qede_dev *edev, int stat_index)\n{\n\treturn (IS_VF(edev) && QEDE_STAT_IS_PF_ONLY(stat_index)) ||\n\t       (QEDE_IS_BB(edev) && QEDE_STAT_IS_AH_ONLY(stat_index)) ||\n\t       (QEDE_IS_AH(edev) && QEDE_STAT_IS_BB_ONLY(stat_index));\n}\n\nstatic void qede_get_strings_stats(struct qede_dev *edev, u8 *buf)\n{\n\tstruct qede_fastpath *fp;\n\tint i;\n\n\t \n\tfor (i = 0; i < QEDE_QUEUE_CNT(edev); i++) {\n\t\tfp = &edev->fp_array[i];\n\n\t\tif (fp->type & QEDE_FASTPATH_RX)\n\t\t\tqede_get_strings_stats_rxq(edev, fp->rxq, &buf);\n\n\t\tif (fp->type & QEDE_FASTPATH_XDP)\n\t\t\tqede_get_strings_stats_txq(edev, fp->xdp_tx, &buf);\n\n\t\tif (fp->type & QEDE_FASTPATH_TX) {\n\t\t\tint cos;\n\n\t\t\tfor_each_cos_in_txq(edev, cos)\n\t\t\t\tqede_get_strings_stats_txq(edev,\n\t\t\t\t\t\t\t   &fp->txq[cos], &buf);\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < QEDE_NUM_STATS; i++) {\n\t\tif (qede_is_irrelevant_stat(edev, i))\n\t\t\tcontinue;\n\t\tstrcpy(buf, qede_stats_arr[i].string);\n\t\tbuf += ETH_GSTRING_LEN;\n\t}\n}\n\nstatic void qede_get_strings(struct net_device *dev, u32 stringset, u8 *buf)\n{\n\tstruct qede_dev *edev = netdev_priv(dev);\n\n\tswitch (stringset) {\n\tcase ETH_SS_STATS:\n\t\tqede_get_strings_stats(edev, buf);\n\t\tbreak;\n\tcase ETH_SS_PRIV_FLAGS:\n\t\tmemcpy(buf, qede_private_arr,\n\t\t       ETH_GSTRING_LEN * QEDE_PRI_FLAG_LEN);\n\t\tbreak;\n\tcase ETH_SS_TEST:\n\t\tmemcpy(buf, qede_tests_str_arr,\n\t\t       ETH_GSTRING_LEN * QEDE_ETHTOOL_TEST_MAX);\n\t\tbreak;\n\tdefault:\n\t\tDP_VERBOSE(edev, QED_MSG_DEBUG,\n\t\t\t   \"Unsupported stringset 0x%08x\\n\", stringset);\n\t}\n}\n\nstatic void qede_get_ethtool_stats_txq(struct qede_tx_queue *txq, u64 **buf)\n{\n\tint i;\n\n\tfor (i = 0; i < QEDE_NUM_TQSTATS; i++) {\n\t\t**buf = *((u64 *)(((void *)txq) + qede_tqstats_arr[i].offset));\n\t\t(*buf)++;\n\t}\n}\n\nstatic void qede_get_ethtool_stats_rxq(struct qede_rx_queue *rxq, u64 **buf)\n{\n\tint i;\n\n\tfor (i = 0; i < QEDE_NUM_RQSTATS; i++) {\n\t\t**buf = *((u64 *)(((void *)rxq) + qede_rqstats_arr[i].offset));\n\t\t(*buf)++;\n\t}\n}\n\nstatic void qede_get_ethtool_stats(struct net_device *dev,\n\t\t\t\t   struct ethtool_stats *stats, u64 *buf)\n{\n\tstruct qede_dev *edev = netdev_priv(dev);\n\tstruct qede_fastpath *fp;\n\tint i;\n\n\tqede_fill_by_demand_stats(edev);\n\n\t \n\t__qede_lock(edev);\n\n\tfor (i = 0; i < QEDE_QUEUE_CNT(edev); i++) {\n\t\tfp = &edev->fp_array[i];\n\n\t\tif (fp->type & QEDE_FASTPATH_RX)\n\t\t\tqede_get_ethtool_stats_rxq(fp->rxq, &buf);\n\n\t\tif (fp->type & QEDE_FASTPATH_XDP)\n\t\t\tqede_get_ethtool_stats_txq(fp->xdp_tx, &buf);\n\n\t\tif (fp->type & QEDE_FASTPATH_TX) {\n\t\t\tint cos;\n\n\t\t\tfor_each_cos_in_txq(edev, cos)\n\t\t\t\tqede_get_ethtool_stats_txq(&fp->txq[cos], &buf);\n\t\t}\n\t}\n\n\tspin_lock(&edev->stats_lock);\n\n\tfor (i = 0; i < QEDE_NUM_STATS; i++) {\n\t\tif (qede_is_irrelevant_stat(edev, i))\n\t\t\tcontinue;\n\t\t*buf = *((u64 *)(((void *)&edev->stats) +\n\t\t\t\t qede_stats_arr[i].offset));\n\n\t\tbuf++;\n\t}\n\n\tspin_unlock(&edev->stats_lock);\n\n\t__qede_unlock(edev);\n}\n\nstatic int qede_get_sset_count(struct net_device *dev, int stringset)\n{\n\tstruct qede_dev *edev = netdev_priv(dev);\n\tint num_stats = QEDE_NUM_STATS, i;\n\n\tswitch (stringset) {\n\tcase ETH_SS_STATS:\n\t\tfor (i = 0; i < QEDE_NUM_STATS; i++)\n\t\t\tif (qede_is_irrelevant_stat(edev, i))\n\t\t\t\tnum_stats--;\n\n\t\t \n\t\tnum_stats += QEDE_TSS_COUNT(edev) * QEDE_NUM_TQSTATS *\n\t\t\t\tedev->dev_info.num_tc;\n\n\t\t \n\t\tnum_stats += QEDE_RSS_COUNT(edev) * QEDE_NUM_RQSTATS;\n\n\t\t \n\t\tif (edev->xdp_prog)\n\t\t\tnum_stats += QEDE_RSS_COUNT(edev) * QEDE_NUM_TQSTATS;\n\t\treturn num_stats;\n\n\tcase ETH_SS_PRIV_FLAGS:\n\t\treturn QEDE_PRI_FLAG_LEN;\n\tcase ETH_SS_TEST:\n\t\tif (!IS_VF(edev))\n\t\t\treturn QEDE_ETHTOOL_TEST_MAX;\n\t\telse\n\t\t\treturn 0;\n\tdefault:\n\t\tDP_VERBOSE(edev, QED_MSG_DEBUG,\n\t\t\t   \"Unsupported stringset 0x%08x\\n\", stringset);\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic u32 qede_get_priv_flags(struct net_device *dev)\n{\n\tstruct qede_dev *edev = netdev_priv(dev);\n\tbool esl_active;\n\tu32 flags = 0;\n\n\tif (edev->dev_info.common.num_hwfns > 1)\n\t\tflags |= BIT(QEDE_PRI_FLAG_CMT);\n\n\tif (edev->dev_info.common.smart_an)\n\t\tflags |= BIT(QEDE_PRI_FLAG_SMART_AN_SUPPORT);\n\n\tif (edev->err_flags & BIT(QEDE_ERR_IS_RECOVERABLE))\n\t\tflags |= BIT(QEDE_PRI_FLAG_RECOVER_ON_ERROR);\n\n\tif (edev->dev_info.common.esl)\n\t\tflags |= BIT(QEDE_PRI_FLAG_ESL_SUPPORT);\n\n\tedev->ops->common->get_esl_status(edev->cdev, &esl_active);\n\n\tif (esl_active)\n\t\tflags |= BIT(QEDE_PRI_FLAG_ESL_ACTIVE);\n\n\treturn flags;\n}\n\nstatic int qede_set_priv_flags(struct net_device *dev, u32 flags)\n{\n\tstruct qede_dev *edev = netdev_priv(dev);\n\tu32 cflags = qede_get_priv_flags(dev);\n\tu32 dflags = flags ^ cflags;\n\n\t \n\tif (dflags & ~BIT(QEDE_PRI_FLAG_RECOVER_ON_ERROR))\n\t\treturn -EINVAL;\n\n\tif (flags & BIT(QEDE_PRI_FLAG_RECOVER_ON_ERROR))\n\t\tset_bit(QEDE_ERR_IS_RECOVERABLE, &edev->err_flags);\n\telse\n\t\tclear_bit(QEDE_ERR_IS_RECOVERABLE, &edev->err_flags);\n\n\treturn 0;\n}\n\nstatic int qede_get_link_ksettings(struct net_device *dev,\n\t\t\t\t   struct ethtool_link_ksettings *cmd)\n{\n\ttypeof(cmd->link_modes) *link_modes = &cmd->link_modes;\n\tstruct ethtool_link_settings *base = &cmd->base;\n\tstruct qede_dev *edev = netdev_priv(dev);\n\tstruct qed_link_output current_link;\n\n\t__qede_lock(edev);\n\n\tmemset(&current_link, 0, sizeof(current_link));\n\tedev->ops->common->get_link(edev->cdev, &current_link);\n\n\tlinkmode_copy(link_modes->supported, current_link.supported_caps);\n\tlinkmode_copy(link_modes->advertising, current_link.advertised_caps);\n\tlinkmode_copy(link_modes->lp_advertising, current_link.lp_caps);\n\n\tif ((edev->state == QEDE_STATE_OPEN) && (current_link.link_up)) {\n\t\tbase->speed = current_link.speed;\n\t\tbase->duplex = current_link.duplex;\n\t} else {\n\t\tbase->speed = SPEED_UNKNOWN;\n\t\tbase->duplex = DUPLEX_UNKNOWN;\n\t}\n\n\t__qede_unlock(edev);\n\n\tbase->port = current_link.port;\n\tbase->autoneg = (current_link.autoneg) ? AUTONEG_ENABLE :\n\t\t\tAUTONEG_DISABLE;\n\n\treturn 0;\n}\n\nstatic int qede_set_link_ksettings(struct net_device *dev,\n\t\t\t\t   const struct ethtool_link_ksettings *cmd)\n{\n\tconst struct ethtool_link_settings *base = &cmd->base;\n\tstruct qede_dev *edev = netdev_priv(dev);\n\tconst struct qede_forced_speed_map *map;\n\tstruct qed_link_output current_link;\n\tstruct qed_link_params params;\n\tu32 i;\n\n\tif (!edev->ops || !edev->ops->common->can_link_change(edev->cdev)) {\n\t\tDP_INFO(edev, \"Link settings are not allowed to be changed\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\tmemset(&current_link, 0, sizeof(current_link));\n\tmemset(&params, 0, sizeof(params));\n\tedev->ops->common->get_link(edev->cdev, &current_link);\n\n\tparams.override_flags |= QED_LINK_OVERRIDE_SPEED_ADV_SPEEDS;\n\tparams.override_flags |= QED_LINK_OVERRIDE_SPEED_AUTONEG;\n\n\tif (base->autoneg == AUTONEG_ENABLE) {\n\t\tif (!phylink_test(current_link.supported_caps, Autoneg)) {\n\t\t\tDP_INFO(edev, \"Auto negotiation is not supported\\n\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\n\t\tparams.autoneg = true;\n\t\tparams.forced_speed = 0;\n\n\t\tlinkmode_copy(params.adv_speeds, cmd->link_modes.advertising);\n\t} else {\t\t \n\t\tparams.override_flags |= QED_LINK_OVERRIDE_SPEED_FORCED_SPEED;\n\t\tparams.autoneg = false;\n\t\tparams.forced_speed = base->speed;\n\n\t\tfor (i = 0; i < ARRAY_SIZE(qede_forced_speed_maps); i++) {\n\t\t\tmap = qede_forced_speed_maps + i;\n\n\t\t\tif (base->speed != map->speed ||\n\t\t\t    !linkmode_intersects(current_link.supported_caps,\n\t\t\t\t\t\t map->caps))\n\t\t\t\tcontinue;\n\n\t\t\tlinkmode_and(params.adv_speeds,\n\t\t\t\t     current_link.supported_caps, map->caps);\n\t\t\tgoto set_link;\n\t\t}\n\n\t\tDP_INFO(edev, \"Unsupported speed %u\\n\", base->speed);\n\t\treturn -EINVAL;\n\t}\n\nset_link:\n\tparams.link_up = true;\n\tedev->ops->common->set_link(edev->cdev, &params);\n\n\treturn 0;\n}\n\nstatic void qede_get_drvinfo(struct net_device *ndev,\n\t\t\t     struct ethtool_drvinfo *info)\n{\n\tchar mfw[ETHTOOL_FWVERS_LEN], storm[ETHTOOL_FWVERS_LEN];\n\tstruct qede_dev *edev = netdev_priv(ndev);\n\tchar mbi[ETHTOOL_FWVERS_LEN];\n\n\tstrscpy(info->driver, \"qede\", sizeof(info->driver));\n\n\tsnprintf(storm, ETHTOOL_FWVERS_LEN, \"%d.%d.%d.%d\",\n\t\t edev->dev_info.common.fw_major,\n\t\t edev->dev_info.common.fw_minor,\n\t\t edev->dev_info.common.fw_rev,\n\t\t edev->dev_info.common.fw_eng);\n\n\tsnprintf(mfw, ETHTOOL_FWVERS_LEN, \"%d.%d.%d.%d\",\n\t\t (edev->dev_info.common.mfw_rev >> 24) & 0xFF,\n\t\t (edev->dev_info.common.mfw_rev >> 16) & 0xFF,\n\t\t (edev->dev_info.common.mfw_rev >> 8) & 0xFF,\n\t\t edev->dev_info.common.mfw_rev & 0xFF);\n\n\tif ((strlen(storm) + strlen(\"[storm]\")) <\n\t    sizeof(info->version))\n\t\tsnprintf(info->version, sizeof(info->version),\n\t\t\t \"[storm %s]\", storm);\n\telse\n\t\tsnprintf(info->version, sizeof(info->version),\n\t\t\t \"%s\", storm);\n\n\tif (edev->dev_info.common.mbi_version) {\n\t\tsnprintf(mbi, ETHTOOL_FWVERS_LEN, \"%d.%d.%d\",\n\t\t\t (edev->dev_info.common.mbi_version &\n\t\t\t  QED_MBI_VERSION_2_MASK) >> QED_MBI_VERSION_2_OFFSET,\n\t\t\t (edev->dev_info.common.mbi_version &\n\t\t\t  QED_MBI_VERSION_1_MASK) >> QED_MBI_VERSION_1_OFFSET,\n\t\t\t (edev->dev_info.common.mbi_version &\n\t\t\t  QED_MBI_VERSION_0_MASK) >> QED_MBI_VERSION_0_OFFSET);\n\t\tsnprintf(info->fw_version, sizeof(info->fw_version),\n\t\t\t \"mbi %s [mfw %s]\", mbi, mfw);\n\t} else {\n\t\tsnprintf(info->fw_version, sizeof(info->fw_version),\n\t\t\t \"mfw %s\", mfw);\n\t}\n\n\tstrscpy(info->bus_info, pci_name(edev->pdev), sizeof(info->bus_info));\n}\n\nstatic void qede_get_wol(struct net_device *ndev, struct ethtool_wolinfo *wol)\n{\n\tstruct qede_dev *edev = netdev_priv(ndev);\n\n\tif (edev->dev_info.common.wol_support) {\n\t\twol->supported = WAKE_MAGIC;\n\t\twol->wolopts = edev->wol_enabled ? WAKE_MAGIC : 0;\n\t}\n}\n\nstatic int qede_set_wol(struct net_device *ndev, struct ethtool_wolinfo *wol)\n{\n\tstruct qede_dev *edev = netdev_priv(ndev);\n\tbool wol_requested;\n\tint rc;\n\n\tif (wol->wolopts & ~WAKE_MAGIC) {\n\t\tDP_INFO(edev,\n\t\t\t\"Can't support WoL options other than magic-packet\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\twol_requested = !!(wol->wolopts & WAKE_MAGIC);\n\tif (wol_requested == edev->wol_enabled)\n\t\treturn 0;\n\n\t \n\tif (!edev->dev_info.common.wol_support) {\n\t\tDP_INFO(edev, \"Device doesn't support WoL\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\trc = edev->ops->common->update_wol(edev->cdev, wol_requested);\n\tif (!rc)\n\t\tedev->wol_enabled = wol_requested;\n\n\treturn rc;\n}\n\nstatic u32 qede_get_msglevel(struct net_device *ndev)\n{\n\tstruct qede_dev *edev = netdev_priv(ndev);\n\n\treturn ((u32)edev->dp_level << QED_LOG_LEVEL_SHIFT) | edev->dp_module;\n}\n\nstatic void qede_set_msglevel(struct net_device *ndev, u32 level)\n{\n\tstruct qede_dev *edev = netdev_priv(ndev);\n\tu32 dp_module = 0;\n\tu8 dp_level = 0;\n\n\tqede_config_debug(level, &dp_module, &dp_level);\n\n\tedev->dp_level = dp_level;\n\tedev->dp_module = dp_module;\n\tedev->ops->common->update_msglvl(edev->cdev,\n\t\t\t\t\t dp_module, dp_level);\n}\n\nstatic int qede_nway_reset(struct net_device *dev)\n{\n\tstruct qede_dev *edev = netdev_priv(dev);\n\tstruct qed_link_output current_link;\n\tstruct qed_link_params link_params;\n\n\tif (!edev->ops || !edev->ops->common->can_link_change(edev->cdev)) {\n\t\tDP_INFO(edev, \"Link settings are not allowed to be changed\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (!netif_running(dev))\n\t\treturn 0;\n\n\tmemset(&current_link, 0, sizeof(current_link));\n\tedev->ops->common->get_link(edev->cdev, &current_link);\n\tif (!current_link.link_up)\n\t\treturn 0;\n\n\t \n\tmemset(&link_params, 0, sizeof(link_params));\n\tlink_params.link_up = false;\n\tedev->ops->common->set_link(edev->cdev, &link_params);\n\tlink_params.link_up = true;\n\tedev->ops->common->set_link(edev->cdev, &link_params);\n\n\treturn 0;\n}\n\nstatic u32 qede_get_link(struct net_device *dev)\n{\n\tstruct qede_dev *edev = netdev_priv(dev);\n\tstruct qed_link_output current_link;\n\n\tmemset(&current_link, 0, sizeof(current_link));\n\tedev->ops->common->get_link(edev->cdev, &current_link);\n\n\treturn current_link.link_up;\n}\n\nstatic int qede_flash_device(struct net_device *dev,\n\t\t\t     struct ethtool_flash *flash)\n{\n\tstruct qede_dev *edev = netdev_priv(dev);\n\n\treturn edev->ops->common->nvm_flash(edev->cdev, flash->data);\n}\n\nstatic int qede_get_coalesce(struct net_device *dev,\n\t\t\t     struct ethtool_coalesce *coal,\n\t\t\t     struct kernel_ethtool_coalesce *kernel_coal,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tvoid *rx_handle = NULL, *tx_handle = NULL;\n\tstruct qede_dev *edev = netdev_priv(dev);\n\tu16 rx_coal, tx_coal, i, rc = 0;\n\tstruct qede_fastpath *fp;\n\n\trx_coal = QED_DEFAULT_RX_USECS;\n\ttx_coal = QED_DEFAULT_TX_USECS;\n\n\tmemset(coal, 0, sizeof(struct ethtool_coalesce));\n\n\t__qede_lock(edev);\n\tif (edev->state == QEDE_STATE_OPEN) {\n\t\tfor_each_queue(i) {\n\t\t\tfp = &edev->fp_array[i];\n\n\t\t\tif (fp->type & QEDE_FASTPATH_RX) {\n\t\t\t\trx_handle = fp->rxq->handle;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\trc = edev->ops->get_coalesce(edev->cdev, &rx_coal, rx_handle);\n\t\tif (rc) {\n\t\t\tDP_INFO(edev, \"Read Rx coalesce error\\n\");\n\t\t\tgoto out;\n\t\t}\n\n\t\tfor_each_queue(i) {\n\t\t\tstruct qede_tx_queue *txq;\n\n\t\t\tfp = &edev->fp_array[i];\n\n\t\t\t \n\t\t\tif (fp->type & QEDE_FASTPATH_TX) {\n\t\t\t\ttxq = QEDE_FP_TC0_TXQ(fp);\n\t\t\t\ttx_handle = txq->handle;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\trc = edev->ops->get_coalesce(edev->cdev, &tx_coal, tx_handle);\n\t\tif (rc)\n\t\t\tDP_INFO(edev, \"Read Tx coalesce error\\n\");\n\t}\n\nout:\n\t__qede_unlock(edev);\n\n\tcoal->rx_coalesce_usecs = rx_coal;\n\tcoal->tx_coalesce_usecs = tx_coal;\n\tcoal->stats_block_coalesce_usecs = edev->stats_coal_usecs;\n\n\treturn rc;\n}\n\nint qede_set_coalesce(struct net_device *dev, struct ethtool_coalesce *coal,\n\t\t      struct kernel_ethtool_coalesce *kernel_coal,\n\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct qede_dev *edev = netdev_priv(dev);\n\tstruct qede_fastpath *fp;\n\tint i, rc = 0;\n\tu16 rxc, txc;\n\n\tif (edev->stats_coal_usecs != coal->stats_block_coalesce_usecs) {\n\t\tedev->stats_coal_usecs = coal->stats_block_coalesce_usecs;\n\t\tif (edev->stats_coal_usecs) {\n\t\t\tedev->stats_coal_ticks = usecs_to_jiffies(edev->stats_coal_usecs);\n\t\t\tschedule_delayed_work(&edev->periodic_task, 0);\n\n\t\t\tDP_INFO(edev, \"Configured stats coal ticks=%lu jiffies\\n\",\n\t\t\t\tedev->stats_coal_ticks);\n\t\t} else {\n\t\t\tcancel_delayed_work_sync(&edev->periodic_task);\n\t\t}\n\t}\n\n\tif (!netif_running(dev)) {\n\t\tDP_INFO(edev, \"Interface is down\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (coal->rx_coalesce_usecs > QED_COALESCE_MAX ||\n\t    coal->tx_coalesce_usecs > QED_COALESCE_MAX) {\n\t\tDP_INFO(edev,\n\t\t\t\"Can't support requested %s coalesce value [max supported value %d]\\n\",\n\t\t\tcoal->rx_coalesce_usecs > QED_COALESCE_MAX ? \"rx\" :\n\t\t\t\"tx\", QED_COALESCE_MAX);\n\t\treturn -EINVAL;\n\t}\n\n\trxc = (u16)coal->rx_coalesce_usecs;\n\ttxc = (u16)coal->tx_coalesce_usecs;\n\tfor_each_queue(i) {\n\t\tfp = &edev->fp_array[i];\n\n\t\tif (edev->fp_array[i].type & QEDE_FASTPATH_RX) {\n\t\t\trc = edev->ops->common->set_coalesce(edev->cdev,\n\t\t\t\t\t\t\t     rxc, 0,\n\t\t\t\t\t\t\t     fp->rxq->handle);\n\t\t\tif (rc) {\n\t\t\t\tDP_INFO(edev,\n\t\t\t\t\t\"Set RX coalesce error, rc = %d\\n\", rc);\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t\tedev->coal_entry[i].rxc = rxc;\n\t\t\tedev->coal_entry[i].isvalid = true;\n\t\t}\n\n\t\tif (edev->fp_array[i].type & QEDE_FASTPATH_TX) {\n\t\t\tstruct qede_tx_queue *txq;\n\n\t\t\t \n\t\t\ttxq = QEDE_FP_TC0_TXQ(fp);\n\n\t\t\trc = edev->ops->common->set_coalesce(edev->cdev,\n\t\t\t\t\t\t\t     0, txc,\n\t\t\t\t\t\t\t     txq->handle);\n\t\t\tif (rc) {\n\t\t\t\tDP_INFO(edev,\n\t\t\t\t\t\"Set TX coalesce error, rc = %d\\n\", rc);\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t\tedev->coal_entry[i].txc = txc;\n\t\t\tedev->coal_entry[i].isvalid = true;\n\t\t}\n\t}\n\n\treturn rc;\n}\n\nstatic void qede_get_ringparam(struct net_device *dev,\n\t\t\t       struct ethtool_ringparam *ering,\n\t\t\t       struct kernel_ethtool_ringparam *kernel_ering,\n\t\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct qede_dev *edev = netdev_priv(dev);\n\n\tering->rx_max_pending = NUM_RX_BDS_MAX;\n\tering->rx_pending = edev->q_num_rx_buffers;\n\tering->tx_max_pending = NUM_TX_BDS_MAX;\n\tering->tx_pending = edev->q_num_tx_buffers;\n}\n\nstatic int qede_set_ringparam(struct net_device *dev,\n\t\t\t      struct ethtool_ringparam *ering,\n\t\t\t      struct kernel_ethtool_ringparam *kernel_ering,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct qede_dev *edev = netdev_priv(dev);\n\n\tDP_VERBOSE(edev, (NETIF_MSG_IFUP | NETIF_MSG_IFDOWN),\n\t\t   \"Set ring params command parameters: rx_pending = %d, tx_pending = %d\\n\",\n\t\t   ering->rx_pending, ering->tx_pending);\n\n\t \n\tif (ering->rx_pending > NUM_RX_BDS_MAX ||\n\t    ering->rx_pending < NUM_RX_BDS_MIN ||\n\t    ering->tx_pending > NUM_TX_BDS_MAX ||\n\t    ering->tx_pending < NUM_TX_BDS_MIN) {\n\t\tDP_VERBOSE(edev, (NETIF_MSG_IFUP | NETIF_MSG_IFDOWN),\n\t\t\t   \"Can only support Rx Buffer size [0%08x,...,0x%08x] and Tx Buffer size [0x%08x,...,0x%08x]\\n\",\n\t\t\t   NUM_RX_BDS_MIN, NUM_RX_BDS_MAX,\n\t\t\t   NUM_TX_BDS_MIN, NUM_TX_BDS_MAX);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tedev->q_num_rx_buffers = ering->rx_pending;\n\tedev->q_num_tx_buffers = ering->tx_pending;\n\n\tqede_reload(edev, NULL, false);\n\n\treturn 0;\n}\n\nstatic void qede_get_pauseparam(struct net_device *dev,\n\t\t\t\tstruct ethtool_pauseparam *epause)\n{\n\tstruct qede_dev *edev = netdev_priv(dev);\n\tstruct qed_link_output current_link;\n\n\tmemset(&current_link, 0, sizeof(current_link));\n\tedev->ops->common->get_link(edev->cdev, &current_link);\n\n\tif (current_link.pause_config & QED_LINK_PAUSE_AUTONEG_ENABLE)\n\t\tepause->autoneg = true;\n\tif (current_link.pause_config & QED_LINK_PAUSE_RX_ENABLE)\n\t\tepause->rx_pause = true;\n\tif (current_link.pause_config & QED_LINK_PAUSE_TX_ENABLE)\n\t\tepause->tx_pause = true;\n\n\tDP_VERBOSE(edev, QED_MSG_DEBUG,\n\t\t   \"ethtool_pauseparam: cmd %d  autoneg %d  rx_pause %d  tx_pause %d\\n\",\n\t\t   epause->cmd, epause->autoneg, epause->rx_pause,\n\t\t   epause->tx_pause);\n}\n\nstatic int qede_set_pauseparam(struct net_device *dev,\n\t\t\t       struct ethtool_pauseparam *epause)\n{\n\tstruct qede_dev *edev = netdev_priv(dev);\n\tstruct qed_link_params params;\n\tstruct qed_link_output current_link;\n\n\tif (!edev->ops || !edev->ops->common->can_link_change(edev->cdev)) {\n\t\tDP_INFO(edev,\n\t\t\t\"Pause settings are not allowed to be changed\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tmemset(&current_link, 0, sizeof(current_link));\n\tedev->ops->common->get_link(edev->cdev, &current_link);\n\n\tmemset(&params, 0, sizeof(params));\n\tparams.override_flags |= QED_LINK_OVERRIDE_PAUSE_CONFIG;\n\n\tif (epause->autoneg) {\n\t\tif (!phylink_test(current_link.supported_caps, Autoneg)) {\n\t\t\tDP_INFO(edev, \"autoneg not supported\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tparams.pause_config |= QED_LINK_PAUSE_AUTONEG_ENABLE;\n\t}\n\n\tif (epause->rx_pause)\n\t\tparams.pause_config |= QED_LINK_PAUSE_RX_ENABLE;\n\tif (epause->tx_pause)\n\t\tparams.pause_config |= QED_LINK_PAUSE_TX_ENABLE;\n\n\tparams.link_up = true;\n\tedev->ops->common->set_link(edev->cdev, &params);\n\n\treturn 0;\n}\n\nstatic void qede_get_regs(struct net_device *ndev,\n\t\t\t  struct ethtool_regs *regs, void *buffer)\n{\n\tstruct qede_dev *edev = netdev_priv(ndev);\n\n\tregs->version = 0;\n\tmemset(buffer, 0, regs->len);\n\n\tif (edev->ops && edev->ops->common)\n\t\tedev->ops->common->dbg_all_data(edev->cdev, buffer);\n}\n\nstatic int qede_get_regs_len(struct net_device *ndev)\n{\n\tstruct qede_dev *edev = netdev_priv(ndev);\n\n\tif (edev->ops && edev->ops->common)\n\t\treturn edev->ops->common->dbg_all_data_size(edev->cdev);\n\telse\n\t\treturn -EINVAL;\n}\n\nstatic void qede_update_mtu(struct qede_dev *edev,\n\t\t\t    struct qede_reload_args *args)\n{\n\tedev->ndev->mtu = args->u.mtu;\n}\n\n \nint qede_change_mtu(struct net_device *ndev, int new_mtu)\n{\n\tstruct qede_dev *edev = netdev_priv(ndev);\n\tstruct qede_reload_args args;\n\n\tDP_VERBOSE(edev, (NETIF_MSG_IFUP | NETIF_MSG_IFDOWN),\n\t\t   \"Configuring MTU size of %d\\n\", new_mtu);\n\n\tif (new_mtu > PAGE_SIZE)\n\t\tndev->features &= ~NETIF_F_GRO_HW;\n\n\t \n\targs.u.mtu = new_mtu;\n\targs.func = &qede_update_mtu;\n\tqede_reload(edev, &args, false);\n#if IS_ENABLED(CONFIG_QED_RDMA)\n\tqede_rdma_event_change_mtu(edev);\n#endif\n\tedev->ops->common->update_mtu(edev->cdev, new_mtu);\n\n\treturn 0;\n}\n\nstatic void qede_get_channels(struct net_device *dev,\n\t\t\t      struct ethtool_channels *channels)\n{\n\tstruct qede_dev *edev = netdev_priv(dev);\n\n\tchannels->max_combined = QEDE_MAX_RSS_CNT(edev);\n\tchannels->max_rx = QEDE_MAX_RSS_CNT(edev);\n\tchannels->max_tx = QEDE_MAX_RSS_CNT(edev);\n\tchannels->combined_count = QEDE_QUEUE_CNT(edev) - edev->fp_num_tx -\n\t\t\t\t\tedev->fp_num_rx;\n\tchannels->tx_count = edev->fp_num_tx;\n\tchannels->rx_count = edev->fp_num_rx;\n}\n\nstatic int qede_set_channels(struct net_device *dev,\n\t\t\t     struct ethtool_channels *channels)\n{\n\tstruct qede_dev *edev = netdev_priv(dev);\n\tu32 count;\n\n\tDP_VERBOSE(edev, (NETIF_MSG_IFUP | NETIF_MSG_IFDOWN),\n\t\t   \"set-channels command parameters: rx = %d, tx = %d, other = %d, combined = %d\\n\",\n\t\t   channels->rx_count, channels->tx_count,\n\t\t   channels->other_count, channels->combined_count);\n\n\tcount = channels->rx_count + channels->tx_count +\n\t\t\tchannels->combined_count;\n\n\t \n\tif (channels->other_count) {\n\t\tDP_VERBOSE(edev, (NETIF_MSG_IFUP | NETIF_MSG_IFDOWN),\n\t\t\t   \"command parameters not supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!(channels->combined_count || (channels->rx_count &&\n\t\t\t\t\t   channels->tx_count))) {\n\t\tDP_VERBOSE(edev, (NETIF_MSG_IFUP | NETIF_MSG_IFDOWN),\n\t\t\t   \"need to request at least one transmit and one receive channel\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (count > QEDE_MAX_RSS_CNT(edev)) {\n\t\tDP_VERBOSE(edev, (NETIF_MSG_IFUP | NETIF_MSG_IFDOWN),\n\t\t\t   \"requested channels = %d max supported channels = %d\\n\",\n\t\t\t   count, QEDE_MAX_RSS_CNT(edev));\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif ((count == QEDE_QUEUE_CNT(edev)) &&\n\t    (channels->tx_count == edev->fp_num_tx) &&\n\t    (channels->rx_count == edev->fp_num_rx)) {\n\t\tDP_VERBOSE(edev, (NETIF_MSG_IFUP | NETIF_MSG_IFDOWN),\n\t\t\t   \"No change in active parameters\\n\");\n\t\treturn 0;\n\t}\n\n\t \n\tif ((count % edev->dev_info.common.num_hwfns) ||\n\t    (channels->tx_count % edev->dev_info.common.num_hwfns) ||\n\t    (channels->rx_count % edev->dev_info.common.num_hwfns)) {\n\t\tDP_VERBOSE(edev, (NETIF_MSG_IFUP | NETIF_MSG_IFDOWN),\n\t\t\t   \"Number of channels must be divisible by %04x\\n\",\n\t\t\t   edev->dev_info.common.num_hwfns);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tedev->req_queues = count;\n\tedev->req_num_tx = channels->tx_count;\n\tedev->req_num_rx = channels->rx_count;\n\t \n\tif ((edev->req_queues - edev->req_num_tx) != QEDE_RSS_COUNT(edev)) {\n\t\tedev->rss_params_inited &= ~QEDE_RSS_INDIR_INITED;\n\t\tmemset(edev->rss_ind_table, 0, sizeof(edev->rss_ind_table));\n\t}\n\n\tqede_reload(edev, NULL, false);\n\n\treturn 0;\n}\n\nstatic int qede_get_ts_info(struct net_device *dev,\n\t\t\t    struct ethtool_ts_info *info)\n{\n\tstruct qede_dev *edev = netdev_priv(dev);\n\n\treturn qede_ptp_get_ts_info(edev, info);\n}\n\nstatic int qede_set_phys_id(struct net_device *dev,\n\t\t\t    enum ethtool_phys_id_state state)\n{\n\tstruct qede_dev *edev = netdev_priv(dev);\n\tu8 led_state = 0;\n\n\tswitch (state) {\n\tcase ETHTOOL_ID_ACTIVE:\n\t\treturn 1;\t \n\n\tcase ETHTOOL_ID_ON:\n\t\tled_state = QED_LED_MODE_ON;\n\t\tbreak;\n\n\tcase ETHTOOL_ID_OFF:\n\t\tled_state = QED_LED_MODE_OFF;\n\t\tbreak;\n\n\tcase ETHTOOL_ID_INACTIVE:\n\t\tled_state = QED_LED_MODE_RESTORE;\n\t\tbreak;\n\t}\n\n\tedev->ops->common->set_led(edev->cdev, led_state);\n\n\treturn 0;\n}\n\nstatic int qede_get_rss_flags(struct qede_dev *edev, struct ethtool_rxnfc *info)\n{\n\tinfo->data = RXH_IP_SRC | RXH_IP_DST;\n\n\tswitch (info->flow_type) {\n\tcase TCP_V4_FLOW:\n\tcase TCP_V6_FLOW:\n\t\tinfo->data |= RXH_L4_B_0_1 | RXH_L4_B_2_3;\n\t\tbreak;\n\tcase UDP_V4_FLOW:\n\t\tif (edev->rss_caps & QED_RSS_IPV4_UDP)\n\t\t\tinfo->data |= RXH_L4_B_0_1 | RXH_L4_B_2_3;\n\t\tbreak;\n\tcase UDP_V6_FLOW:\n\t\tif (edev->rss_caps & QED_RSS_IPV6_UDP)\n\t\t\tinfo->data |= RXH_L4_B_0_1 | RXH_L4_B_2_3;\n\t\tbreak;\n\tcase IPV4_FLOW:\n\tcase IPV6_FLOW:\n\t\tbreak;\n\tdefault:\n\t\tinfo->data = 0;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int qede_get_rxnfc(struct net_device *dev, struct ethtool_rxnfc *info,\n\t\t\t  u32 *rule_locs)\n{\n\tstruct qede_dev *edev = netdev_priv(dev);\n\tint rc = 0;\n\n\tswitch (info->cmd) {\n\tcase ETHTOOL_GRXRINGS:\n\t\tinfo->data = QEDE_RSS_COUNT(edev);\n\t\tbreak;\n\tcase ETHTOOL_GRXFH:\n\t\trc = qede_get_rss_flags(edev, info);\n\t\tbreak;\n\tcase ETHTOOL_GRXCLSRLCNT:\n\t\tinfo->rule_cnt = qede_get_arfs_filter_count(edev);\n\t\tinfo->data = QEDE_RFS_MAX_FLTR;\n\t\tbreak;\n\tcase ETHTOOL_GRXCLSRULE:\n\t\trc = qede_get_cls_rule_entry(edev, info);\n\t\tbreak;\n\tcase ETHTOOL_GRXCLSRLALL:\n\t\trc = qede_get_cls_rule_all(edev, info, rule_locs);\n\t\tbreak;\n\tdefault:\n\t\tDP_ERR(edev, \"Command parameters not supported\\n\");\n\t\trc = -EOPNOTSUPP;\n\t}\n\n\treturn rc;\n}\n\nstatic int qede_set_rss_flags(struct qede_dev *edev, struct ethtool_rxnfc *info)\n{\n\tstruct qed_update_vport_params *vport_update_params;\n\tu8 set_caps = 0, clr_caps = 0;\n\tint rc = 0;\n\n\tDP_VERBOSE(edev, QED_MSG_DEBUG,\n\t\t   \"Set rss flags command parameters: flow type = %d, data = %llu\\n\",\n\t\t   info->flow_type, info->data);\n\n\tswitch (info->flow_type) {\n\tcase TCP_V4_FLOW:\n\tcase TCP_V6_FLOW:\n\t\t \n\t\tif (info->data ^ (RXH_IP_SRC | RXH_IP_DST |\n\t\t\t\t  RXH_L4_B_0_1 | RXH_L4_B_2_3)) {\n\t\t\tDP_INFO(edev, \"Command parameters not supported\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\treturn 0;\n\tcase UDP_V4_FLOW:\n\t\t \n\t\tif (info->data == (RXH_IP_SRC | RXH_IP_DST |\n\t\t\t\t   RXH_L4_B_0_1 | RXH_L4_B_2_3)) {\n\t\t\tset_caps = QED_RSS_IPV4_UDP;\n\t\t\tDP_VERBOSE(edev, QED_MSG_DEBUG,\n\t\t\t\t   \"UDP 4-tuple enabled\\n\");\n\t\t} else if (info->data == (RXH_IP_SRC | RXH_IP_DST)) {\n\t\t\tclr_caps = QED_RSS_IPV4_UDP;\n\t\t\tDP_VERBOSE(edev, QED_MSG_DEBUG,\n\t\t\t\t   \"UDP 4-tuple disabled\\n\");\n\t\t} else {\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase UDP_V6_FLOW:\n\t\t \n\t\tif (info->data == (RXH_IP_SRC | RXH_IP_DST |\n\t\t\t\t   RXH_L4_B_0_1 | RXH_L4_B_2_3)) {\n\t\t\tset_caps = QED_RSS_IPV6_UDP;\n\t\t\tDP_VERBOSE(edev, QED_MSG_DEBUG,\n\t\t\t\t   \"UDP 4-tuple enabled\\n\");\n\t\t} else if (info->data == (RXH_IP_SRC | RXH_IP_DST)) {\n\t\t\tclr_caps = QED_RSS_IPV6_UDP;\n\t\t\tDP_VERBOSE(edev, QED_MSG_DEBUG,\n\t\t\t\t   \"UDP 4-tuple disabled\\n\");\n\t\t} else {\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase IPV4_FLOW:\n\tcase IPV6_FLOW:\n\t\t \n\t\tif (info->data ^ (RXH_IP_SRC | RXH_IP_DST)) {\n\t\t\tDP_INFO(edev, \"Command parameters not supported\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\treturn 0;\n\tcase SCTP_V4_FLOW:\n\tcase AH_ESP_V4_FLOW:\n\tcase AH_V4_FLOW:\n\tcase ESP_V4_FLOW:\n\tcase SCTP_V6_FLOW:\n\tcase AH_ESP_V6_FLOW:\n\tcase AH_V6_FLOW:\n\tcase ESP_V6_FLOW:\n\tcase IP_USER_FLOW:\n\tcase ETHER_FLOW:\n\t\t \n\t\tif (info->data) {\n\t\t\tDP_INFO(edev, \"Command parameters not supported\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (edev->rss_caps == ((edev->rss_caps & ~clr_caps) | set_caps))\n\t\treturn 0;\n\n\t \n\tedev->rss_caps = ((edev->rss_caps & ~clr_caps) | set_caps);\n\tedev->rss_params_inited |= QEDE_RSS_CAPS_INITED;\n\n\t \n\t__qede_lock(edev);\n\tif (edev->state == QEDE_STATE_OPEN) {\n\t\tvport_update_params = vzalloc(sizeof(*vport_update_params));\n\t\tif (!vport_update_params) {\n\t\t\t__qede_unlock(edev);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tqede_fill_rss_params(edev, &vport_update_params->rss_params,\n\t\t\t\t     &vport_update_params->update_rss_flg);\n\t\trc = edev->ops->vport_update(edev->cdev, vport_update_params);\n\t\tvfree(vport_update_params);\n\t}\n\t__qede_unlock(edev);\n\n\treturn rc;\n}\n\nstatic int qede_set_rxnfc(struct net_device *dev, struct ethtool_rxnfc *info)\n{\n\tstruct qede_dev *edev = netdev_priv(dev);\n\tint rc;\n\n\tswitch (info->cmd) {\n\tcase ETHTOOL_SRXFH:\n\t\trc = qede_set_rss_flags(edev, info);\n\t\tbreak;\n\tcase ETHTOOL_SRXCLSRLINS:\n\t\trc = qede_add_cls_rule(edev, info);\n\t\tbreak;\n\tcase ETHTOOL_SRXCLSRLDEL:\n\t\trc = qede_delete_flow_filter(edev, info->fs.location);\n\t\tbreak;\n\tdefault:\n\t\tDP_INFO(edev, \"Command parameters not supported\\n\");\n\t\trc = -EOPNOTSUPP;\n\t}\n\n\treturn rc;\n}\n\nstatic u32 qede_get_rxfh_indir_size(struct net_device *dev)\n{\n\treturn QED_RSS_IND_TABLE_SIZE;\n}\n\nstatic u32 qede_get_rxfh_key_size(struct net_device *dev)\n{\n\tstruct qede_dev *edev = netdev_priv(dev);\n\n\treturn sizeof(edev->rss_key);\n}\n\nstatic int qede_get_rxfh(struct net_device *dev, u32 *indir, u8 *key, u8 *hfunc)\n{\n\tstruct qede_dev *edev = netdev_priv(dev);\n\tint i;\n\n\tif (hfunc)\n\t\t*hfunc = ETH_RSS_HASH_TOP;\n\n\tif (!indir)\n\t\treturn 0;\n\n\tfor (i = 0; i < QED_RSS_IND_TABLE_SIZE; i++)\n\t\tindir[i] = edev->rss_ind_table[i];\n\n\tif (key)\n\t\tmemcpy(key, edev->rss_key, qede_get_rxfh_key_size(dev));\n\n\treturn 0;\n}\n\nstatic int qede_set_rxfh(struct net_device *dev, const u32 *indir,\n\t\t\t const u8 *key, const u8 hfunc)\n{\n\tstruct qed_update_vport_params *vport_update_params;\n\tstruct qede_dev *edev = netdev_priv(dev);\n\tint i, rc = 0;\n\n\tif (edev->dev_info.common.num_hwfns > 1) {\n\t\tDP_INFO(edev,\n\t\t\t\"RSS configuration is not supported for 100G devices\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (hfunc != ETH_RSS_HASH_NO_CHANGE && hfunc != ETH_RSS_HASH_TOP)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!indir && !key)\n\t\treturn 0;\n\n\tif (indir) {\n\t\tfor (i = 0; i < QED_RSS_IND_TABLE_SIZE; i++)\n\t\t\tedev->rss_ind_table[i] = indir[i];\n\t\tedev->rss_params_inited |= QEDE_RSS_INDIR_INITED;\n\t}\n\n\tif (key) {\n\t\tmemcpy(&edev->rss_key, key, qede_get_rxfh_key_size(dev));\n\t\tedev->rss_params_inited |= QEDE_RSS_KEY_INITED;\n\t}\n\n\t__qede_lock(edev);\n\tif (edev->state == QEDE_STATE_OPEN) {\n\t\tvport_update_params = vzalloc(sizeof(*vport_update_params));\n\t\tif (!vport_update_params) {\n\t\t\t__qede_unlock(edev);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tqede_fill_rss_params(edev, &vport_update_params->rss_params,\n\t\t\t\t     &vport_update_params->update_rss_flg);\n\t\trc = edev->ops->vport_update(edev->cdev, vport_update_params);\n\t\tvfree(vport_update_params);\n\t}\n\t__qede_unlock(edev);\n\n\treturn rc;\n}\n\n \nstatic void qede_netif_start(struct qede_dev *edev)\n{\n\tint i;\n\n\tif (!netif_running(edev->ndev))\n\t\treturn;\n\n\tfor_each_queue(i) {\n\t\t \n\t\tqed_sb_ack(edev->fp_array[i].sb_info, IGU_INT_ENABLE, 1);\n\t\tnapi_enable(&edev->fp_array[i].napi);\n\t}\n}\n\n \nstatic void qede_netif_stop(struct qede_dev *edev)\n{\n\tint i;\n\n\tfor_each_queue(i) {\n\t\tnapi_disable(&edev->fp_array[i].napi);\n\t\t \n\t\tqed_sb_ack(edev->fp_array[i].sb_info, IGU_INT_DISABLE, 0);\n\t}\n}\n\nstatic int qede_selftest_transmit_traffic(struct qede_dev *edev,\n\t\t\t\t\t  struct sk_buff *skb)\n{\n\tstruct qede_tx_queue *txq = NULL;\n\tstruct eth_tx_1st_bd *first_bd;\n\tdma_addr_t mapping;\n\tint i, idx;\n\tu16 val;\n\n\tfor_each_queue(i) {\n\t\tstruct qede_fastpath *fp = &edev->fp_array[i];\n\n\t\tif (fp->type & QEDE_FASTPATH_TX) {\n\t\t\ttxq = QEDE_FP_TC0_TXQ(fp);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!txq) {\n\t\tDP_NOTICE(edev, \"Tx path is not available\\n\");\n\t\treturn -1;\n\t}\n\n\t \n\tidx = txq->sw_tx_prod;\n\ttxq->sw_tx_ring.skbs[idx].skb = skb;\n\tfirst_bd = qed_chain_produce(&txq->tx_pbl);\n\tmemset(first_bd, 0, sizeof(*first_bd));\n\tval = 1 << ETH_TX_1ST_BD_FLAGS_START_BD_SHIFT;\n\tfirst_bd->data.bd_flags.bitfields = val;\n\tval = skb->len & ETH_TX_DATA_1ST_BD_PKT_LEN_MASK;\n\tval = val << ETH_TX_DATA_1ST_BD_PKT_LEN_SHIFT;\n\tfirst_bd->data.bitfields |= cpu_to_le16(val);\n\n\t \n\tmapping = dma_map_single(&edev->pdev->dev, skb->data,\n\t\t\t\t skb_headlen(skb), DMA_TO_DEVICE);\n\tif (unlikely(dma_mapping_error(&edev->pdev->dev, mapping))) {\n\t\tDP_NOTICE(edev, \"SKB mapping failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tBD_SET_UNMAP_ADDR_LEN(first_bd, mapping, skb_headlen(skb));\n\n\t \n\tfirst_bd->data.nbds = 1;\n\ttxq->sw_tx_prod = (txq->sw_tx_prod + 1) % txq->num_tx_buffers;\n\t \n\tval = qed_chain_get_prod_idx(&txq->tx_pbl);\n\ttxq->tx_db.data.bd_prod = cpu_to_le16(val);\n\n\t \n\twmb();\n\tbarrier();\n\twritel(txq->tx_db.raw, txq->doorbell_addr);\n\n\tfor (i = 0; i < QEDE_SELFTEST_POLL_COUNT; i++) {\n\t\tif (qede_txq_has_work(txq))\n\t\t\tbreak;\n\t\tusleep_range(100, 200);\n\t}\n\n\tif (!qede_txq_has_work(txq)) {\n\t\tDP_NOTICE(edev, \"Tx completion didn't happen\\n\");\n\t\treturn -1;\n\t}\n\n\tfirst_bd = (struct eth_tx_1st_bd *)qed_chain_consume(&txq->tx_pbl);\n\tdma_unmap_single(&edev->pdev->dev, BD_UNMAP_ADDR(first_bd),\n\t\t\t BD_UNMAP_LEN(first_bd), DMA_TO_DEVICE);\n\ttxq->sw_tx_cons = (txq->sw_tx_cons + 1) % txq->num_tx_buffers;\n\ttxq->sw_tx_ring.skbs[idx].skb = NULL;\n\n\treturn 0;\n}\n\nstatic int qede_selftest_receive_traffic(struct qede_dev *edev)\n{\n\tu16 sw_rx_index, len;\n\tstruct eth_fast_path_rx_reg_cqe *fp_cqe;\n\tstruct qede_rx_queue *rxq = NULL;\n\tstruct sw_rx_data *sw_rx_data;\n\tunion eth_rx_cqe *cqe;\n\tint i, iter, rc = 0;\n\tu8 *data_ptr;\n\n\tfor_each_queue(i) {\n\t\tif (edev->fp_array[i].type & QEDE_FASTPATH_RX) {\n\t\t\trxq = edev->fp_array[i].rxq;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!rxq) {\n\t\tDP_NOTICE(edev, \"Rx path is not available\\n\");\n\t\treturn -1;\n\t}\n\n\t \n\tfor (iter = 0; iter < QEDE_SELFTEST_POLL_COUNT; iter++) {\n\t\tif (!qede_has_rx_work(rxq)) {\n\t\t\tusleep_range(100, 200);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tcqe = (union eth_rx_cqe *)qed_chain_consume(&rxq->rx_comp_ring);\n\n\t\t \n\t\tsw_rx_index = rxq->sw_rx_cons & NUM_RX_BDS_MAX;\n\t\tsw_rx_data = &rxq->sw_rx_ring[sw_rx_index];\n\t\tfp_cqe = &cqe->fast_path_regular;\n\t\tlen =  le16_to_cpu(fp_cqe->len_on_first_bd);\n\t\tdata_ptr = (u8 *)(page_address(sw_rx_data->data) +\n\t\t\t\t  fp_cqe->placement_offset +\n\t\t\t\t  sw_rx_data->page_offset +\n\t\t\t\t  rxq->rx_headroom);\n\t\tif (ether_addr_equal(data_ptr,  edev->ndev->dev_addr) &&\n\t\t    ether_addr_equal(data_ptr + ETH_ALEN,\n\t\t\t\t     edev->ndev->dev_addr)) {\n\t\t\tfor (i = ETH_HLEN; i < len; i++)\n\t\t\t\tif (data_ptr[i] != (unsigned char)(i & 0xff)) {\n\t\t\t\t\trc = -1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\tqede_recycle_rx_bd_ring(rxq, 1);\n\t\t\tqed_chain_recycle_consumed(&rxq->rx_comp_ring);\n\t\t\tbreak;\n\t\t}\n\n\t\tDP_INFO(edev, \"Not the transmitted packet\\n\");\n\t\tqede_recycle_rx_bd_ring(rxq, 1);\n\t\tqed_chain_recycle_consumed(&rxq->rx_comp_ring);\n\t}\n\n\tif (iter == QEDE_SELFTEST_POLL_COUNT) {\n\t\tDP_NOTICE(edev, \"Failed to receive the traffic\\n\");\n\t\treturn -1;\n\t}\n\n\tqede_update_rx_prod(edev, rxq);\n\n\treturn rc;\n}\n\nstatic int qede_selftest_run_loopback(struct qede_dev *edev, u32 loopback_mode)\n{\n\tstruct qed_link_params link_params;\n\tstruct sk_buff *skb = NULL;\n\tint rc = 0, i;\n\tu32 pkt_size;\n\tu8 *packet;\n\n\tif (!netif_running(edev->ndev)) {\n\t\tDP_NOTICE(edev, \"Interface is down\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tqede_netif_stop(edev);\n\n\t \n\tmemset(&link_params, 0, sizeof(link_params));\n\tlink_params.link_up = true;\n\tlink_params.override_flags = QED_LINK_OVERRIDE_LOOPBACK_MODE;\n\tlink_params.loopback_mode = loopback_mode;\n\tedev->ops->common->set_link(edev->cdev, &link_params);\n\n\t \n\tmsleep_interruptible(500);\n\n\t \n\tpkt_size = (((edev->ndev->mtu < ETH_DATA_LEN) ?\n\t\t     edev->ndev->mtu : ETH_DATA_LEN) + ETH_HLEN);\n\n\tskb = netdev_alloc_skb(edev->ndev, pkt_size);\n\tif (!skb) {\n\t\tDP_INFO(edev, \"Can't allocate skb\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto test_loopback_exit;\n\t}\n\tpacket = skb_put(skb, pkt_size);\n\tether_addr_copy(packet, edev->ndev->dev_addr);\n\tether_addr_copy(packet + ETH_ALEN, edev->ndev->dev_addr);\n\tmemset(packet + (2 * ETH_ALEN), 0x77, (ETH_HLEN - (2 * ETH_ALEN)));\n\tfor (i = ETH_HLEN; i < pkt_size; i++)\n\t\tpacket[i] = (unsigned char)(i & 0xff);\n\n\trc = qede_selftest_transmit_traffic(edev, skb);\n\tif (rc)\n\t\tgoto test_loopback_exit;\n\n\trc = qede_selftest_receive_traffic(edev);\n\tif (rc)\n\t\tgoto test_loopback_exit;\n\n\tDP_VERBOSE(edev, NETIF_MSG_RX_STATUS, \"Loopback test successful\\n\");\n\ntest_loopback_exit:\n\tdev_kfree_skb(skb);\n\n\t \n\tmemset(&link_params, 0, sizeof(link_params));\n\tlink_params.link_up = true;\n\tlink_params.override_flags = QED_LINK_OVERRIDE_LOOPBACK_MODE;\n\tlink_params.loopback_mode = QED_LINK_LOOPBACK_NONE;\n\tedev->ops->common->set_link(edev->cdev, &link_params);\n\n\t \n\tmsleep_interruptible(500);\n\n\tqede_netif_start(edev);\n\n\treturn rc;\n}\n\nstatic void qede_self_test(struct net_device *dev,\n\t\t\t   struct ethtool_test *etest, u64 *buf)\n{\n\tstruct qede_dev *edev = netdev_priv(dev);\n\n\tDP_VERBOSE(edev, QED_MSG_DEBUG,\n\t\t   \"Self-test command parameters: offline = %d, external_lb = %d\\n\",\n\t\t   (etest->flags & ETH_TEST_FL_OFFLINE),\n\t\t   (etest->flags & ETH_TEST_FL_EXTERNAL_LB) >> 2);\n\n\tmemset(buf, 0, sizeof(u64) * QEDE_ETHTOOL_TEST_MAX);\n\n\tif (etest->flags & ETH_TEST_FL_OFFLINE) {\n\t\tif (qede_selftest_run_loopback(edev,\n\t\t\t\t\t       QED_LINK_LOOPBACK_INT_PHY)) {\n\t\t\tbuf[QEDE_ETHTOOL_INT_LOOPBACK] = 1;\n\t\t\tetest->flags |= ETH_TEST_FL_FAILED;\n\t\t}\n\t}\n\n\tif (edev->ops->common->selftest->selftest_interrupt(edev->cdev)) {\n\t\tbuf[QEDE_ETHTOOL_INTERRUPT_TEST] = 1;\n\t\tetest->flags |= ETH_TEST_FL_FAILED;\n\t}\n\n\tif (edev->ops->common->selftest->selftest_memory(edev->cdev)) {\n\t\tbuf[QEDE_ETHTOOL_MEMORY_TEST] = 1;\n\t\tetest->flags |= ETH_TEST_FL_FAILED;\n\t}\n\n\tif (edev->ops->common->selftest->selftest_register(edev->cdev)) {\n\t\tbuf[QEDE_ETHTOOL_REGISTER_TEST] = 1;\n\t\tetest->flags |= ETH_TEST_FL_FAILED;\n\t}\n\n\tif (edev->ops->common->selftest->selftest_clock(edev->cdev)) {\n\t\tbuf[QEDE_ETHTOOL_CLOCK_TEST] = 1;\n\t\tetest->flags |= ETH_TEST_FL_FAILED;\n\t}\n\n\tif (edev->ops->common->selftest->selftest_nvram(edev->cdev)) {\n\t\tbuf[QEDE_ETHTOOL_NVRAM_TEST] = 1;\n\t\tetest->flags |= ETH_TEST_FL_FAILED;\n\t}\n}\n\nstatic int qede_set_tunable(struct net_device *dev,\n\t\t\t    const struct ethtool_tunable *tuna,\n\t\t\t    const void *data)\n{\n\tstruct qede_dev *edev = netdev_priv(dev);\n\tu32 val;\n\n\tswitch (tuna->id) {\n\tcase ETHTOOL_RX_COPYBREAK:\n\t\tval = *(u32 *)data;\n\t\tif (val < QEDE_MIN_PKT_LEN || val > QEDE_RX_HDR_SIZE) {\n\t\t\tDP_VERBOSE(edev, QED_MSG_DEBUG,\n\t\t\t\t   \"Invalid rx copy break value, range is [%u, %u]\",\n\t\t\t\t   QEDE_MIN_PKT_LEN, QEDE_RX_HDR_SIZE);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tedev->rx_copybreak = *(u32 *)data;\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic int qede_get_tunable(struct net_device *dev,\n\t\t\t    const struct ethtool_tunable *tuna, void *data)\n{\n\tstruct qede_dev *edev = netdev_priv(dev);\n\n\tswitch (tuna->id) {\n\tcase ETHTOOL_RX_COPYBREAK:\n\t\t*(u32 *)data = edev->rx_copybreak;\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic int qede_get_eee(struct net_device *dev, struct ethtool_eee *edata)\n{\n\tstruct qede_dev *edev = netdev_priv(dev);\n\tstruct qed_link_output current_link;\n\n\tmemset(&current_link, 0, sizeof(current_link));\n\tedev->ops->common->get_link(edev->cdev, &current_link);\n\n\tif (!current_link.eee_supported) {\n\t\tDP_INFO(edev, \"EEE is not supported\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (current_link.eee.adv_caps & QED_EEE_1G_ADV)\n\t\tedata->advertised = ADVERTISED_1000baseT_Full;\n\tif (current_link.eee.adv_caps & QED_EEE_10G_ADV)\n\t\tedata->advertised |= ADVERTISED_10000baseT_Full;\n\tif (current_link.sup_caps & QED_EEE_1G_ADV)\n\t\tedata->supported = ADVERTISED_1000baseT_Full;\n\tif (current_link.sup_caps & QED_EEE_10G_ADV)\n\t\tedata->supported |= ADVERTISED_10000baseT_Full;\n\tif (current_link.eee.lp_adv_caps & QED_EEE_1G_ADV)\n\t\tedata->lp_advertised = ADVERTISED_1000baseT_Full;\n\tif (current_link.eee.lp_adv_caps & QED_EEE_10G_ADV)\n\t\tedata->lp_advertised |= ADVERTISED_10000baseT_Full;\n\n\tedata->tx_lpi_timer = current_link.eee.tx_lpi_timer;\n\tedata->eee_enabled = current_link.eee.enable;\n\tedata->tx_lpi_enabled = current_link.eee.tx_lpi_enable;\n\tedata->eee_active = current_link.eee_active;\n\n\treturn 0;\n}\n\nstatic int qede_set_eee(struct net_device *dev, struct ethtool_eee *edata)\n{\n\tstruct qede_dev *edev = netdev_priv(dev);\n\tstruct qed_link_output current_link;\n\tstruct qed_link_params params;\n\n\tif (!edev->ops->common->can_link_change(edev->cdev)) {\n\t\tDP_INFO(edev, \"Link settings are not allowed to be changed\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tmemset(&current_link, 0, sizeof(current_link));\n\tedev->ops->common->get_link(edev->cdev, &current_link);\n\n\tif (!current_link.eee_supported) {\n\t\tDP_INFO(edev, \"EEE is not supported\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tmemset(&params, 0, sizeof(params));\n\tparams.override_flags |= QED_LINK_OVERRIDE_EEE_CONFIG;\n\n\tif (!(edata->advertised & (ADVERTISED_1000baseT_Full |\n\t\t\t\t   ADVERTISED_10000baseT_Full)) ||\n\t    ((edata->advertised & (ADVERTISED_1000baseT_Full |\n\t\t\t\t   ADVERTISED_10000baseT_Full)) !=\n\t     edata->advertised)) {\n\t\tDP_VERBOSE(edev, QED_MSG_DEBUG,\n\t\t\t   \"Invalid advertised capabilities %d\\n\",\n\t\t\t   edata->advertised);\n\t\treturn -EINVAL;\n\t}\n\n\tif (edata->advertised & ADVERTISED_1000baseT_Full)\n\t\tparams.eee.adv_caps = QED_EEE_1G_ADV;\n\tif (edata->advertised & ADVERTISED_10000baseT_Full)\n\t\tparams.eee.adv_caps |= QED_EEE_10G_ADV;\n\tparams.eee.enable = edata->eee_enabled;\n\tparams.eee.tx_lpi_enable = edata->tx_lpi_enabled;\n\tparams.eee.tx_lpi_timer = edata->tx_lpi_timer;\n\n\tparams.link_up = true;\n\tedev->ops->common->set_link(edev->cdev, &params);\n\n\treturn 0;\n}\n\nstatic u32 qede_link_to_ethtool_fec(u32 link_fec)\n{\n\tu32 eth_fec = 0;\n\n\tif (link_fec & QED_FEC_MODE_NONE)\n\t\teth_fec |= ETHTOOL_FEC_OFF;\n\tif (link_fec & QED_FEC_MODE_FIRECODE)\n\t\teth_fec |= ETHTOOL_FEC_BASER;\n\tif (link_fec & QED_FEC_MODE_RS)\n\t\teth_fec |= ETHTOOL_FEC_RS;\n\tif (link_fec & QED_FEC_MODE_AUTO)\n\t\teth_fec |= ETHTOOL_FEC_AUTO;\n\tif (link_fec & QED_FEC_MODE_UNSUPPORTED)\n\t\teth_fec |= ETHTOOL_FEC_NONE;\n\n\treturn eth_fec;\n}\n\nstatic u32 qede_ethtool_to_link_fec(u32 eth_fec)\n{\n\tu32 link_fec = 0;\n\n\tif (eth_fec & ETHTOOL_FEC_OFF)\n\t\tlink_fec |= QED_FEC_MODE_NONE;\n\tif (eth_fec & ETHTOOL_FEC_BASER)\n\t\tlink_fec |= QED_FEC_MODE_FIRECODE;\n\tif (eth_fec & ETHTOOL_FEC_RS)\n\t\tlink_fec |= QED_FEC_MODE_RS;\n\tif (eth_fec & ETHTOOL_FEC_AUTO)\n\t\tlink_fec |= QED_FEC_MODE_AUTO;\n\tif (eth_fec & ETHTOOL_FEC_NONE)\n\t\tlink_fec |= QED_FEC_MODE_UNSUPPORTED;\n\n\treturn link_fec;\n}\n\nstatic int qede_get_fecparam(struct net_device *dev,\n\t\t\t     struct ethtool_fecparam *fecparam)\n{\n\tstruct qede_dev *edev = netdev_priv(dev);\n\tstruct qed_link_output curr_link;\n\n\tmemset(&curr_link, 0, sizeof(curr_link));\n\tedev->ops->common->get_link(edev->cdev, &curr_link);\n\n\tfecparam->active_fec = qede_link_to_ethtool_fec(curr_link.active_fec);\n\tfecparam->fec = qede_link_to_ethtool_fec(curr_link.sup_fec);\n\n\treturn 0;\n}\n\nstatic int qede_set_fecparam(struct net_device *dev,\n\t\t\t     struct ethtool_fecparam *fecparam)\n{\n\tstruct qede_dev *edev = netdev_priv(dev);\n\tstruct qed_link_params params;\n\n\tif (!edev->ops || !edev->ops->common->can_link_change(edev->cdev)) {\n\t\tDP_INFO(edev, \"Link settings are not allowed to be changed\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tmemset(&params, 0, sizeof(params));\n\tparams.override_flags |= QED_LINK_OVERRIDE_FEC_CONFIG;\n\tparams.fec = qede_ethtool_to_link_fec(fecparam->fec);\n\tparams.link_up = true;\n\n\tedev->ops->common->set_link(edev->cdev, &params);\n\n\treturn 0;\n}\n\nstatic int qede_get_module_info(struct net_device *dev,\n\t\t\t\tstruct ethtool_modinfo *modinfo)\n{\n\tstruct qede_dev *edev = netdev_priv(dev);\n\tu8 buf[4];\n\tint rc;\n\n\t \n\trc = edev->ops->common->read_module_eeprom(edev->cdev, buf,\n\t\t\t\t\t\t   QED_I2C_DEV_ADDR_A0, 0, 4);\n\tif (rc) {\n\t\tDP_ERR(edev, \"Failed reading EEPROM data %d\\n\", rc);\n\t\treturn rc;\n\t}\n\n\tswitch (buf[0]) {\n\tcase 0x3:  \n\t\tmodinfo->type = ETH_MODULE_SFF_8472;\n\t\tmodinfo->eeprom_len = ETH_MODULE_SFF_8472_LEN;\n\t\tbreak;\n\tcase 0xc:  \n\tcase 0xd:  \n\t\tmodinfo->type = ETH_MODULE_SFF_8436;\n\t\tmodinfo->eeprom_len = ETH_MODULE_SFF_8436_LEN;\n\t\tbreak;\n\tcase 0x11:  \n\t\tmodinfo->type = ETH_MODULE_SFF_8636;\n\t\tmodinfo->eeprom_len = ETH_MODULE_SFF_8636_LEN;\n\t\tbreak;\n\tdefault:\n\t\tDP_ERR(edev, \"Unknown transceiver type 0x%x\\n\", buf[0]);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int qede_get_module_eeprom(struct net_device *dev,\n\t\t\t\t  struct ethtool_eeprom *ee, u8 *data)\n{\n\tstruct qede_dev *edev = netdev_priv(dev);\n\tu32 start_addr = ee->offset, size = 0;\n\tu8 *buf = data;\n\tint rc = 0;\n\n\t \n\tif (ee->offset < ETH_MODULE_SFF_8079_LEN) {\n\t\t \n\t\tif (ee->offset + ee->len > ETH_MODULE_SFF_8079_LEN)\n\t\t\tsize = ETH_MODULE_SFF_8079_LEN - ee->offset;\n\t\telse\n\t\t\tsize = ee->len;\n\n\t\trc = edev->ops->common->read_module_eeprom(edev->cdev, buf,\n\t\t\t\t\t\t\t   QED_I2C_DEV_ADDR_A0,\n\t\t\t\t\t\t\t   start_addr, size);\n\t\tif (rc) {\n\t\t\tDP_ERR(edev, \"Failed reading A0 section  %d\\n\", rc);\n\t\t\treturn rc;\n\t\t}\n\n\t\tbuf += size;\n\t\tstart_addr += size;\n\t}\n\n\t \n\tif (start_addr >= ETH_MODULE_SFF_8079_LEN &&\n\t    start_addr < ETH_MODULE_SFF_8472_LEN) {\n\t\tsize = ee->len - size;\n\t\t \n\t\tif (start_addr + size > ETH_MODULE_SFF_8472_LEN)\n\t\t\tsize = ETH_MODULE_SFF_8472_LEN - start_addr;\n\t\tstart_addr -= ETH_MODULE_SFF_8079_LEN;\n\t\trc = edev->ops->common->read_module_eeprom(edev->cdev, buf,\n\t\t\t\t\t\t\t   QED_I2C_DEV_ADDR_A2,\n\t\t\t\t\t\t\t   start_addr, size);\n\t\tif (rc) {\n\t\t\tDP_VERBOSE(edev, QED_MSG_DEBUG,\n\t\t\t\t   \"Failed reading A2 section %d\\n\", rc);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn rc;\n}\n\nstatic int qede_set_dump(struct net_device *dev, struct ethtool_dump *val)\n{\n\tstruct qede_dev *edev = netdev_priv(dev);\n\tint rc = 0;\n\n\tif (edev->dump_info.cmd == QEDE_DUMP_CMD_NONE) {\n\t\tif (val->flag > QEDE_DUMP_CMD_MAX) {\n\t\t\tDP_ERR(edev, \"Invalid command %d\\n\", val->flag);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tedev->dump_info.cmd = val->flag;\n\t\tedev->dump_info.num_args = 0;\n\t\treturn 0;\n\t}\n\n\tif (edev->dump_info.num_args == QEDE_DUMP_MAX_ARGS) {\n\t\tDP_ERR(edev, \"Arg count = %d\\n\", edev->dump_info.num_args);\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (edev->dump_info.cmd) {\n\tcase QEDE_DUMP_CMD_NVM_CFG:\n\t\tedev->dump_info.args[edev->dump_info.num_args] = val->flag;\n\t\tedev->dump_info.num_args++;\n\t\tbreak;\n\tcase QEDE_DUMP_CMD_GRCDUMP:\n\t\trc = edev->ops->common->set_grc_config(edev->cdev,\n\t\t\t\t\t\t       val->flag, 1);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn rc;\n}\n\nstatic int qede_get_dump_flag(struct net_device *dev,\n\t\t\t      struct ethtool_dump *dump)\n{\n\tstruct qede_dev *edev = netdev_priv(dev);\n\n\tif (!edev->ops || !edev->ops->common) {\n\t\tDP_ERR(edev, \"Edev ops not populated\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdump->version = QEDE_DUMP_VERSION;\n\tswitch (edev->dump_info.cmd) {\n\tcase QEDE_DUMP_CMD_NVM_CFG:\n\t\tdump->flag = QEDE_DUMP_CMD_NVM_CFG;\n\t\tdump->len = edev->ops->common->read_nvm_cfg_len(edev->cdev,\n\t\t\t\t\t\tedev->dump_info.args[0]);\n\t\tbreak;\n\tcase QEDE_DUMP_CMD_GRCDUMP:\n\t\tdump->flag = QEDE_DUMP_CMD_GRCDUMP;\n\t\tdump->len = edev->ops->common->dbg_all_data_size(edev->cdev);\n\t\tbreak;\n\tdefault:\n\t\tDP_ERR(edev, \"Invalid cmd = %d\\n\", edev->dump_info.cmd);\n\t\treturn -EINVAL;\n\t}\n\n\tDP_VERBOSE(edev, QED_MSG_DEBUG,\n\t\t   \"dump->version = 0x%x dump->flag = %d dump->len = %d\\n\",\n\t\t   dump->version, dump->flag, dump->len);\n\treturn 0;\n}\n\nstatic int qede_get_dump_data(struct net_device *dev,\n\t\t\t      struct ethtool_dump *dump, void *buf)\n{\n\tstruct qede_dev *edev = netdev_priv(dev);\n\tint rc = 0;\n\n\tif (!edev->ops || !edev->ops->common) {\n\t\tDP_ERR(edev, \"Edev ops not populated\\n\");\n\t\trc = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tswitch (edev->dump_info.cmd) {\n\tcase QEDE_DUMP_CMD_NVM_CFG:\n\t\tif (edev->dump_info.num_args != QEDE_DUMP_NVM_ARG_COUNT) {\n\t\t\tDP_ERR(edev, \"Arg count = %d required = %d\\n\",\n\t\t\t       edev->dump_info.num_args,\n\t\t\t       QEDE_DUMP_NVM_ARG_COUNT);\n\t\t\trc = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\t\trc =  edev->ops->common->read_nvm_cfg(edev->cdev, (u8 **)&buf,\n\t\t\t\t\t\t      edev->dump_info.args[0],\n\t\t\t\t\t\t      edev->dump_info.args[1]);\n\t\tbreak;\n\tcase QEDE_DUMP_CMD_GRCDUMP:\n\t\tmemset(buf, 0, dump->len);\n\t\trc = edev->ops->common->dbg_all_data(edev->cdev, buf);\n\t\tbreak;\n\tdefault:\n\t\tDP_ERR(edev, \"Invalid cmd = %d\\n\", edev->dump_info.cmd);\n\t\trc = -EINVAL;\n\t\tbreak;\n\t}\n\nerr:\n\tedev->dump_info.cmd = QEDE_DUMP_CMD_NONE;\n\tedev->dump_info.num_args = 0;\n\tmemset(edev->dump_info.args, 0, sizeof(edev->dump_info.args));\n\n\treturn rc;\n}\n\nint qede_set_per_coalesce(struct net_device *dev, u32 queue,\n\t\t\t  struct ethtool_coalesce *coal)\n{\n\tstruct qede_dev *edev = netdev_priv(dev);\n\tstruct qede_fastpath *fp;\n\tu16 rxc, txc;\n\tint rc = 0;\n\n\tif (coal->rx_coalesce_usecs > QED_COALESCE_MAX ||\n\t    coal->tx_coalesce_usecs > QED_COALESCE_MAX) {\n\t\tDP_INFO(edev,\n\t\t\t\"Can't support requested %s coalesce value [max supported value %d]\\n\",\n\t\t\tcoal->rx_coalesce_usecs > QED_COALESCE_MAX ? \"rx\"\n\t\t\t\t\t\t\t\t   : \"tx\",\n\t\t\tQED_COALESCE_MAX);\n\t\treturn -EINVAL;\n\t}\n\n\trxc = (u16)coal->rx_coalesce_usecs;\n\ttxc = (u16)coal->tx_coalesce_usecs;\n\n\t__qede_lock(edev);\n\tif (queue >= edev->num_queues) {\n\t\tDP_INFO(edev, \"Invalid queue\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (edev->state != QEDE_STATE_OPEN) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tfp = &edev->fp_array[queue];\n\n\tif (edev->fp_array[queue].type & QEDE_FASTPATH_RX) {\n\t\trc = edev->ops->common->set_coalesce(edev->cdev,\n\t\t\t\t\t\t     rxc, 0,\n\t\t\t\t\t\t     fp->rxq->handle);\n\t\tif (rc) {\n\t\t\tDP_INFO(edev,\n\t\t\t\t\"Set RX coalesce error, rc = %d\\n\", rc);\n\t\t\tgoto out;\n\t\t}\n\t\tedev->coal_entry[queue].rxc = rxc;\n\t\tedev->coal_entry[queue].isvalid = true;\n\t}\n\n\tif (edev->fp_array[queue].type & QEDE_FASTPATH_TX) {\n\t\trc = edev->ops->common->set_coalesce(edev->cdev,\n\t\t\t\t\t\t     0, txc,\n\t\t\t\t\t\t     fp->txq->handle);\n\t\tif (rc) {\n\t\t\tDP_INFO(edev,\n\t\t\t\t\"Set TX coalesce error, rc = %d\\n\", rc);\n\t\t\tgoto out;\n\t\t}\n\t\tedev->coal_entry[queue].txc = txc;\n\t\tedev->coal_entry[queue].isvalid = true;\n\t}\nout:\n\t__qede_unlock(edev);\n\n\treturn rc;\n}\n\nstatic int qede_get_per_coalesce(struct net_device *dev,\n\t\t\t\t u32 queue,\n\t\t\t\t struct ethtool_coalesce *coal)\n{\n\tvoid *rx_handle = NULL, *tx_handle = NULL;\n\tstruct qede_dev *edev = netdev_priv(dev);\n\tstruct qede_fastpath *fp;\n\tu16 rx_coal, tx_coal;\n\tint rc = 0;\n\n\trx_coal = QED_DEFAULT_RX_USECS;\n\ttx_coal = QED_DEFAULT_TX_USECS;\n\n\tmemset(coal, 0, sizeof(struct ethtool_coalesce));\n\n\t__qede_lock(edev);\n\tif (queue >= edev->num_queues) {\n\t\tDP_INFO(edev, \"Invalid queue\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (edev->state != QEDE_STATE_OPEN) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tfp = &edev->fp_array[queue];\n\n\tif (fp->type & QEDE_FASTPATH_RX)\n\t\trx_handle = fp->rxq->handle;\n\n\trc = edev->ops->get_coalesce(edev->cdev, &rx_coal,\n\t\t\t\t     rx_handle);\n\tif (rc) {\n\t\tDP_INFO(edev, \"Read Rx coalesce error\\n\");\n\t\tgoto out;\n\t}\n\n\tfp = &edev->fp_array[queue];\n\tif (fp->type & QEDE_FASTPATH_TX)\n\t\ttx_handle = fp->txq->handle;\n\n\trc = edev->ops->get_coalesce(edev->cdev, &tx_coal,\n\t\t\t\t      tx_handle);\n\tif (rc)\n\t\tDP_INFO(edev, \"Read Tx coalesce error\\n\");\n\nout:\n\t__qede_unlock(edev);\n\n\tcoal->rx_coalesce_usecs = rx_coal;\n\tcoal->tx_coalesce_usecs = tx_coal;\n\n\treturn rc;\n}\n\nstatic const struct ethtool_ops qede_ethtool_ops = {\n\t.supported_coalesce_params\t= ETHTOOL_COALESCE_USECS |\n\t\t\t\t\t  ETHTOOL_COALESCE_STATS_BLOCK_USECS,\n\t.get_link_ksettings\t\t= qede_get_link_ksettings,\n\t.set_link_ksettings\t\t= qede_set_link_ksettings,\n\t.get_drvinfo\t\t\t= qede_get_drvinfo,\n\t.get_regs_len\t\t\t= qede_get_regs_len,\n\t.get_regs\t\t\t= qede_get_regs,\n\t.get_wol\t\t\t= qede_get_wol,\n\t.set_wol\t\t\t= qede_set_wol,\n\t.get_msglevel\t\t\t= qede_get_msglevel,\n\t.set_msglevel\t\t\t= qede_set_msglevel,\n\t.nway_reset\t\t\t= qede_nway_reset,\n\t.get_link\t\t\t= qede_get_link,\n\t.get_coalesce\t\t\t= qede_get_coalesce,\n\t.set_coalesce\t\t\t= qede_set_coalesce,\n\t.get_ringparam\t\t\t= qede_get_ringparam,\n\t.set_ringparam\t\t\t= qede_set_ringparam,\n\t.get_pauseparam\t\t\t= qede_get_pauseparam,\n\t.set_pauseparam\t\t\t= qede_set_pauseparam,\n\t.get_strings\t\t\t= qede_get_strings,\n\t.set_phys_id\t\t\t= qede_set_phys_id,\n\t.get_ethtool_stats\t\t= qede_get_ethtool_stats,\n\t.get_priv_flags\t\t\t= qede_get_priv_flags,\n\t.set_priv_flags\t\t\t= qede_set_priv_flags,\n\t.get_sset_count\t\t\t= qede_get_sset_count,\n\t.get_rxnfc\t\t\t= qede_get_rxnfc,\n\t.set_rxnfc\t\t\t= qede_set_rxnfc,\n\t.get_rxfh_indir_size\t\t= qede_get_rxfh_indir_size,\n\t.get_rxfh_key_size\t\t= qede_get_rxfh_key_size,\n\t.get_rxfh\t\t\t= qede_get_rxfh,\n\t.set_rxfh\t\t\t= qede_set_rxfh,\n\t.get_ts_info\t\t\t= qede_get_ts_info,\n\t.get_channels\t\t\t= qede_get_channels,\n\t.set_channels\t\t\t= qede_set_channels,\n\t.self_test\t\t\t= qede_self_test,\n\t.get_module_info\t\t= qede_get_module_info,\n\t.get_module_eeprom\t\t= qede_get_module_eeprom,\n\t.get_eee\t\t\t= qede_get_eee,\n\t.set_eee\t\t\t= qede_set_eee,\n\t.get_fecparam\t\t\t= qede_get_fecparam,\n\t.set_fecparam\t\t\t= qede_set_fecparam,\n\t.get_tunable\t\t\t= qede_get_tunable,\n\t.set_tunable\t\t\t= qede_set_tunable,\n\t.get_per_queue_coalesce\t\t= qede_get_per_coalesce,\n\t.set_per_queue_coalesce\t\t= qede_set_per_coalesce,\n\t.flash_device\t\t\t= qede_flash_device,\n\t.get_dump_flag\t\t\t= qede_get_dump_flag,\n\t.get_dump_data\t\t\t= qede_get_dump_data,\n\t.set_dump\t\t\t= qede_set_dump,\n};\n\nstatic const struct ethtool_ops qede_vf_ethtool_ops = {\n\t.supported_coalesce_params\t= ETHTOOL_COALESCE_USECS |\n\t\t\t\t\t  ETHTOOL_COALESCE_STATS_BLOCK_USECS,\n\t.get_link_ksettings\t\t= qede_get_link_ksettings,\n\t.get_drvinfo\t\t\t= qede_get_drvinfo,\n\t.get_msglevel\t\t\t= qede_get_msglevel,\n\t.set_msglevel\t\t\t= qede_set_msglevel,\n\t.get_link\t\t\t= qede_get_link,\n\t.get_coalesce\t\t\t= qede_get_coalesce,\n\t.set_coalesce\t\t\t= qede_set_coalesce,\n\t.get_ringparam\t\t\t= qede_get_ringparam,\n\t.set_ringparam\t\t\t= qede_set_ringparam,\n\t.get_strings\t\t\t= qede_get_strings,\n\t.get_ethtool_stats\t\t= qede_get_ethtool_stats,\n\t.get_priv_flags\t\t\t= qede_get_priv_flags,\n\t.get_sset_count\t\t\t= qede_get_sset_count,\n\t.get_rxnfc\t\t\t= qede_get_rxnfc,\n\t.set_rxnfc\t\t\t= qede_set_rxnfc,\n\t.get_rxfh_indir_size\t\t= qede_get_rxfh_indir_size,\n\t.get_rxfh_key_size\t\t= qede_get_rxfh_key_size,\n\t.get_rxfh\t\t\t= qede_get_rxfh,\n\t.set_rxfh\t\t\t= qede_set_rxfh,\n\t.get_channels\t\t\t= qede_get_channels,\n\t.set_channels\t\t\t= qede_set_channels,\n\t.get_per_queue_coalesce\t\t= qede_get_per_coalesce,\n\t.set_per_queue_coalesce\t\t= qede_set_per_coalesce,\n\t.get_tunable\t\t\t= qede_get_tunable,\n\t.set_tunable\t\t\t= qede_set_tunable,\n};\n\nvoid qede_set_ethtool_ops(struct net_device *dev)\n{\n\tstruct qede_dev *edev = netdev_priv(dev);\n\n\tif (IS_VF(edev))\n\t\tdev->ethtool_ops = &qede_vf_ethtool_ops;\n\telse\n\t\tdev->ethtool_ops = &qede_ethtool_ops;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}