{
  "module_name": "qede_ptp.c",
  "hash_id": "d637722f672c70886b72ee0168c656a532e84fa3c12774d0433c0fecfaa0ea05",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/qlogic/qede/qede_ptp.c",
  "human_readable_source": "\n \n\n#include \"qede_ptp.h\"\n#define QEDE_PTP_TX_TIMEOUT (2 * HZ)\n\nstruct qede_ptp {\n\tconst struct qed_eth_ptp_ops\t*ops;\n\tstruct ptp_clock_info\t\tclock_info;\n\tstruct cyclecounter\t\tcc;\n\tstruct timecounter\t\ttc;\n\tstruct ptp_clock\t\t*clock;\n\tstruct work_struct\t\twork;\n\tunsigned long\t\t\tptp_tx_start;\n\tstruct qede_dev\t\t\t*edev;\n\tstruct sk_buff\t\t\t*tx_skb;\n\n\t \n\tspinlock_t\t\t\tlock;\n\tbool\t\t\t\thw_ts_ioctl_called;\n\tu16\t\t\t\ttx_type;\n\tu16\t\t\t\trx_filter;\n};\n\n \nstatic int qede_ptp_adjfine(struct ptp_clock_info *info, long scaled_ppm)\n{\n\tstruct qede_ptp *ptp = container_of(info, struct qede_ptp, clock_info);\n\ts32 ppb = scaled_ppm_to_ppb(scaled_ppm);\n\tstruct qede_dev *edev = ptp->edev;\n\tint rc;\n\n\t__qede_lock(edev);\n\tif (edev->state == QEDE_STATE_OPEN) {\n\t\tspin_lock_bh(&ptp->lock);\n\t\trc = ptp->ops->adjfreq(edev->cdev, ppb);\n\t\tspin_unlock_bh(&ptp->lock);\n\t} else {\n\t\tDP_ERR(edev, \"PTP adjfine called while interface is down\\n\");\n\t\trc = -EFAULT;\n\t}\n\t__qede_unlock(edev);\n\n\treturn rc;\n}\n\nstatic int qede_ptp_adjtime(struct ptp_clock_info *info, s64 delta)\n{\n\tstruct qede_dev *edev;\n\tstruct qede_ptp *ptp;\n\n\tptp = container_of(info, struct qede_ptp, clock_info);\n\tedev = ptp->edev;\n\n\tDP_VERBOSE(edev, QED_MSG_DEBUG, \"PTP adjtime called, delta = %llx\\n\",\n\t\t   delta);\n\n\tspin_lock_bh(&ptp->lock);\n\ttimecounter_adjtime(&ptp->tc, delta);\n\tspin_unlock_bh(&ptp->lock);\n\n\treturn 0;\n}\n\nstatic int qede_ptp_gettime(struct ptp_clock_info *info, struct timespec64 *ts)\n{\n\tstruct qede_dev *edev;\n\tstruct qede_ptp *ptp;\n\tu64 ns;\n\n\tptp = container_of(info, struct qede_ptp, clock_info);\n\tedev = ptp->edev;\n\n\tspin_lock_bh(&ptp->lock);\n\tns = timecounter_read(&ptp->tc);\n\tspin_unlock_bh(&ptp->lock);\n\n\tDP_VERBOSE(edev, QED_MSG_DEBUG, \"PTP gettime called, ns = %llu\\n\", ns);\n\n\t*ts = ns_to_timespec64(ns);\n\n\treturn 0;\n}\n\nstatic int qede_ptp_settime(struct ptp_clock_info *info,\n\t\t\t    const struct timespec64 *ts)\n{\n\tstruct qede_dev *edev;\n\tstruct qede_ptp *ptp;\n\tu64 ns;\n\n\tptp = container_of(info, struct qede_ptp, clock_info);\n\tedev = ptp->edev;\n\n\tns = timespec64_to_ns(ts);\n\n\tDP_VERBOSE(edev, QED_MSG_DEBUG, \"PTP settime called, ns = %llu\\n\", ns);\n\n\t \n\tspin_lock_bh(&ptp->lock);\n\ttimecounter_init(&ptp->tc, &ptp->cc, ns);\n\tspin_unlock_bh(&ptp->lock);\n\n\treturn 0;\n}\n\n \nstatic int qede_ptp_ancillary_feature_enable(struct ptp_clock_info *info,\n\t\t\t\t\t     struct ptp_clock_request *rq,\n\t\t\t\t\t     int on)\n{\n\tstruct qede_dev *edev;\n\tstruct qede_ptp *ptp;\n\n\tptp = container_of(info, struct qede_ptp, clock_info);\n\tedev = ptp->edev;\n\n\tDP_ERR(edev, \"PHC ancillary features are not supported\\n\");\n\n\treturn -ENOTSUPP;\n}\n\nstatic void qede_ptp_task(struct work_struct *work)\n{\n\tstruct skb_shared_hwtstamps shhwtstamps;\n\tstruct qede_dev *edev;\n\tstruct qede_ptp *ptp;\n\tu64 timestamp, ns;\n\tbool timedout;\n\tint rc;\n\n\tptp = container_of(work, struct qede_ptp, work);\n\tedev = ptp->edev;\n\ttimedout = time_is_before_jiffies(ptp->ptp_tx_start +\n\t\t\t\t\t  QEDE_PTP_TX_TIMEOUT);\n\n\t \n\tspin_lock_bh(&ptp->lock);\n\trc = ptp->ops->read_tx_ts(edev->cdev, &timestamp);\n\tspin_unlock_bh(&ptp->lock);\n\tif (rc) {\n\t\tif (unlikely(timedout)) {\n\t\t\tDP_INFO(edev, \"Tx timestamp is not recorded\\n\");\n\t\t\tdev_kfree_skb_any(ptp->tx_skb);\n\t\t\tptp->tx_skb = NULL;\n\t\t\tclear_bit_unlock(QEDE_FLAGS_PTP_TX_IN_PRORGESS,\n\t\t\t\t\t &edev->flags);\n\t\t\tedev->ptp_skip_txts++;\n\t\t} else {\n\t\t\t \n\t\t\tschedule_work(&ptp->work);\n\t\t}\n\t\treturn;\n\t}\n\n\tns = timecounter_cyc2time(&ptp->tc, timestamp);\n\tmemset(&shhwtstamps, 0, sizeof(shhwtstamps));\n\tshhwtstamps.hwtstamp = ns_to_ktime(ns);\n\tskb_tstamp_tx(ptp->tx_skb, &shhwtstamps);\n\tdev_kfree_skb_any(ptp->tx_skb);\n\tptp->tx_skb = NULL;\n\tclear_bit_unlock(QEDE_FLAGS_PTP_TX_IN_PRORGESS, &edev->flags);\n\n\tDP_VERBOSE(edev, QED_MSG_DEBUG,\n\t\t   \"Tx timestamp, timestamp cycles = %llu, ns = %llu\\n\",\n\t\t   timestamp, ns);\n}\n\n \nstatic u64 qede_ptp_read_cc(const struct cyclecounter *cc)\n{\n\tstruct qede_dev *edev;\n\tstruct qede_ptp *ptp;\n\tu64 phc_cycles;\n\tint rc;\n\n\tptp = container_of(cc, struct qede_ptp, cc);\n\tedev = ptp->edev;\n\trc = ptp->ops->read_cc(edev->cdev, &phc_cycles);\n\tif (rc)\n\t\tWARN_ONCE(1, \"PHC read err %d\\n\", rc);\n\n\tDP_VERBOSE(edev, QED_MSG_DEBUG, \"PHC read cycles = %llu\\n\", phc_cycles);\n\n\treturn phc_cycles;\n}\n\nstatic int qede_ptp_cfg_filters(struct qede_dev *edev)\n{\n\tenum qed_ptp_hwtstamp_tx_type tx_type = QED_PTP_HWTSTAMP_TX_ON;\n\tenum qed_ptp_filter_type rx_filter = QED_PTP_FILTER_NONE;\n\tstruct qede_ptp *ptp = edev->ptp;\n\n\tif (!ptp)\n\t\treturn -EIO;\n\n\tif (!ptp->hw_ts_ioctl_called) {\n\t\tDP_INFO(edev, \"TS IOCTL not called\\n\");\n\t\treturn 0;\n\t}\n\n\tswitch (ptp->tx_type) {\n\tcase HWTSTAMP_TX_ON:\n\t\tset_bit(QEDE_FLAGS_TX_TIMESTAMPING_EN, &edev->flags);\n\t\ttx_type = QED_PTP_HWTSTAMP_TX_ON;\n\t\tbreak;\n\n\tcase HWTSTAMP_TX_OFF:\n\t\tclear_bit(QEDE_FLAGS_TX_TIMESTAMPING_EN, &edev->flags);\n\t\ttx_type = QED_PTP_HWTSTAMP_TX_OFF;\n\t\tbreak;\n\n\tcase HWTSTAMP_TX_ONESTEP_SYNC:\n\tcase HWTSTAMP_TX_ONESTEP_P2P:\n\t\tDP_ERR(edev, \"One-step timestamping is not supported\\n\");\n\t\treturn -ERANGE;\n\t}\n\n\tspin_lock_bh(&ptp->lock);\n\tswitch (ptp->rx_filter) {\n\tcase HWTSTAMP_FILTER_NONE:\n\t\trx_filter = QED_PTP_FILTER_NONE;\n\t\tbreak;\n\tcase HWTSTAMP_FILTER_ALL:\n\tcase HWTSTAMP_FILTER_SOME:\n\tcase HWTSTAMP_FILTER_NTP_ALL:\n\t\tptp->rx_filter = HWTSTAMP_FILTER_NONE;\n\t\trx_filter = QED_PTP_FILTER_ALL;\n\t\tbreak;\n\tcase HWTSTAMP_FILTER_PTP_V1_L4_EVENT:\n\t\tptp->rx_filter = HWTSTAMP_FILTER_PTP_V1_L4_EVENT;\n\t\trx_filter = QED_PTP_FILTER_V1_L4_EVENT;\n\t\tbreak;\n\tcase HWTSTAMP_FILTER_PTP_V1_L4_SYNC:\n\tcase HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ:\n\t\tptp->rx_filter = HWTSTAMP_FILTER_PTP_V1_L4_EVENT;\n\t\t \n\t\trx_filter = QED_PTP_FILTER_V1_L4_GEN;\n\t\tbreak;\n\tcase HWTSTAMP_FILTER_PTP_V2_L4_EVENT:\n\t\tptp->rx_filter = HWTSTAMP_FILTER_PTP_V2_L4_EVENT;\n\t\trx_filter = QED_PTP_FILTER_V2_L4_EVENT;\n\t\tbreak;\n\tcase HWTSTAMP_FILTER_PTP_V2_L4_SYNC:\n\tcase HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ:\n\t\tptp->rx_filter = HWTSTAMP_FILTER_PTP_V2_L4_EVENT;\n\t\t \n\t\trx_filter = QED_PTP_FILTER_V2_L4_GEN;\n\t\tbreak;\n\tcase HWTSTAMP_FILTER_PTP_V2_L2_EVENT:\n\t\tptp->rx_filter = HWTSTAMP_FILTER_PTP_V2_L2_EVENT;\n\t\trx_filter = QED_PTP_FILTER_V2_L2_EVENT;\n\t\tbreak;\n\tcase HWTSTAMP_FILTER_PTP_V2_L2_SYNC:\n\tcase HWTSTAMP_FILTER_PTP_V2_L2_DELAY_REQ:\n\t\tptp->rx_filter = HWTSTAMP_FILTER_PTP_V2_L2_EVENT;\n\t\t \n\t\trx_filter = QED_PTP_FILTER_V2_L2_GEN;\n\t\tbreak;\n\tcase HWTSTAMP_FILTER_PTP_V2_EVENT:\n\t\tptp->rx_filter = HWTSTAMP_FILTER_PTP_V2_EVENT;\n\t\trx_filter = QED_PTP_FILTER_V2_EVENT;\n\t\tbreak;\n\tcase HWTSTAMP_FILTER_PTP_V2_SYNC:\n\tcase HWTSTAMP_FILTER_PTP_V2_DELAY_REQ:\n\t\tptp->rx_filter = HWTSTAMP_FILTER_PTP_V2_EVENT;\n\t\t \n\t\trx_filter = QED_PTP_FILTER_V2_GEN;\n\t\tbreak;\n\t}\n\n\tptp->ops->cfg_filters(edev->cdev, rx_filter, tx_type);\n\n\tspin_unlock_bh(&ptp->lock);\n\n\treturn 0;\n}\n\nint qede_ptp_hw_ts(struct qede_dev *edev, struct ifreq *ifr)\n{\n\tstruct hwtstamp_config config;\n\tstruct qede_ptp *ptp;\n\tint rc;\n\n\tptp = edev->ptp;\n\tif (!ptp)\n\t\treturn -EIO;\n\n\tif (copy_from_user(&config, ifr->ifr_data, sizeof(config)))\n\t\treturn -EFAULT;\n\n\tDP_VERBOSE(edev, QED_MSG_DEBUG,\n\t\t   \"HWTSTAMP IOCTL: Requested tx_type = %d, requested rx_filters = %d\\n\",\n\t\t   config.tx_type, config.rx_filter);\n\n\tptp->hw_ts_ioctl_called = 1;\n\tptp->tx_type = config.tx_type;\n\tptp->rx_filter = config.rx_filter;\n\n\trc = qede_ptp_cfg_filters(edev);\n\tif (rc)\n\t\treturn rc;\n\n\tconfig.rx_filter = ptp->rx_filter;\n\n\treturn copy_to_user(ifr->ifr_data, &config,\n\t\t\t    sizeof(config)) ? -EFAULT : 0;\n}\n\nint qede_ptp_get_ts_info(struct qede_dev *edev, struct ethtool_ts_info *info)\n{\n\tstruct qede_ptp *ptp = edev->ptp;\n\n\tif (!ptp) {\n\t\tinfo->so_timestamping = SOF_TIMESTAMPING_TX_SOFTWARE |\n\t\t\t\t\tSOF_TIMESTAMPING_RX_SOFTWARE |\n\t\t\t\t\tSOF_TIMESTAMPING_SOFTWARE;\n\t\tinfo->phc_index = -1;\n\n\t\treturn 0;\n\t}\n\n\tinfo->so_timestamping = SOF_TIMESTAMPING_TX_SOFTWARE |\n\t\t\t\tSOF_TIMESTAMPING_RX_SOFTWARE |\n\t\t\t\tSOF_TIMESTAMPING_SOFTWARE |\n\t\t\t\tSOF_TIMESTAMPING_TX_HARDWARE |\n\t\t\t\tSOF_TIMESTAMPING_RX_HARDWARE |\n\t\t\t\tSOF_TIMESTAMPING_RAW_HARDWARE;\n\n\tif (ptp->clock)\n\t\tinfo->phc_index = ptp_clock_index(ptp->clock);\n\telse\n\t\tinfo->phc_index = -1;\n\n\tinfo->rx_filters = BIT(HWTSTAMP_FILTER_NONE) |\n\t\t\t   BIT(HWTSTAMP_FILTER_PTP_V1_L4_EVENT) |\n\t\t\t   BIT(HWTSTAMP_FILTER_PTP_V1_L4_SYNC) |\n\t\t\t   BIT(HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ) |\n\t\t\t   BIT(HWTSTAMP_FILTER_PTP_V2_L4_EVENT) |\n\t\t\t   BIT(HWTSTAMP_FILTER_PTP_V2_L4_SYNC) |\n\t\t\t   BIT(HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ) |\n\t\t\t   BIT(HWTSTAMP_FILTER_PTP_V2_L2_EVENT) |\n\t\t\t   BIT(HWTSTAMP_FILTER_PTP_V2_L2_SYNC) |\n\t\t\t   BIT(HWTSTAMP_FILTER_PTP_V2_L2_DELAY_REQ) |\n\t\t\t   BIT(HWTSTAMP_FILTER_PTP_V2_EVENT) |\n\t\t\t   BIT(HWTSTAMP_FILTER_PTP_V2_SYNC) |\n\t\t\t   BIT(HWTSTAMP_FILTER_PTP_V2_DELAY_REQ);\n\n\tinfo->tx_types = BIT(HWTSTAMP_TX_OFF) | BIT(HWTSTAMP_TX_ON);\n\n\treturn 0;\n}\n\nvoid qede_ptp_disable(struct qede_dev *edev)\n{\n\tstruct qede_ptp *ptp;\n\n\tptp = edev->ptp;\n\tif (!ptp)\n\t\treturn;\n\n\tif (ptp->clock) {\n\t\tptp_clock_unregister(ptp->clock);\n\t\tptp->clock = NULL;\n\t}\n\n\t \n\tcancel_work_sync(&ptp->work);\n\tif (ptp->tx_skb) {\n\t\tdev_kfree_skb_any(ptp->tx_skb);\n\t\tptp->tx_skb = NULL;\n\t\tclear_bit_unlock(QEDE_FLAGS_PTP_TX_IN_PRORGESS, &edev->flags);\n\t}\n\n\t \n\tspin_lock_bh(&ptp->lock);\n\tptp->ops->disable(edev->cdev);\n\tspin_unlock_bh(&ptp->lock);\n\n\tkfree(ptp);\n\tedev->ptp = NULL;\n}\n\nstatic int qede_ptp_init(struct qede_dev *edev)\n{\n\tstruct qede_ptp *ptp;\n\tint rc;\n\n\tptp = edev->ptp;\n\tif (!ptp)\n\t\treturn -EINVAL;\n\n\tspin_lock_init(&ptp->lock);\n\n\t \n\trc = ptp->ops->enable(edev->cdev);\n\tif (rc) {\n\t\tDP_INFO(edev, \"PTP HW enable failed\\n\");\n\t\treturn rc;\n\t}\n\n\t \n\tINIT_WORK(&ptp->work, qede_ptp_task);\n\n\t \n\tmemset(&ptp->cc, 0, sizeof(ptp->cc));\n\tptp->cc.read = qede_ptp_read_cc;\n\tptp->cc.mask = CYCLECOUNTER_MASK(64);\n\tptp->cc.shift = 0;\n\tptp->cc.mult = 1;\n\n\ttimecounter_init(&ptp->tc, &ptp->cc, ktime_to_ns(ktime_get_real()));\n\n\treturn 0;\n}\n\nint qede_ptp_enable(struct qede_dev *edev)\n{\n\tstruct qede_ptp *ptp;\n\tint rc;\n\n\tptp = kzalloc(sizeof(*ptp), GFP_KERNEL);\n\tif (!ptp) {\n\t\tDP_INFO(edev, \"Failed to allocate struct for PTP\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tptp->edev = edev;\n\tptp->ops = edev->ops->ptp;\n\tif (!ptp->ops) {\n\t\tDP_INFO(edev, \"PTP enable failed\\n\");\n\t\trc = -EIO;\n\t\tgoto err1;\n\t}\n\n\tedev->ptp = ptp;\n\n\trc = qede_ptp_init(edev);\n\tif (rc)\n\t\tgoto err1;\n\n\tqede_ptp_cfg_filters(edev);\n\n\t \n\tptp->clock_info.owner = THIS_MODULE;\n\tsnprintf(ptp->clock_info.name, 16, \"%s\", edev->ndev->name);\n\tptp->clock_info.max_adj = QED_MAX_PHC_DRIFT_PPB;\n\tptp->clock_info.n_alarm = 0;\n\tptp->clock_info.n_ext_ts = 0;\n\tptp->clock_info.n_per_out = 0;\n\tptp->clock_info.pps = 0;\n\tptp->clock_info.adjfine = qede_ptp_adjfine;\n\tptp->clock_info.adjtime = qede_ptp_adjtime;\n\tptp->clock_info.gettime64 = qede_ptp_gettime;\n\tptp->clock_info.settime64 = qede_ptp_settime;\n\tptp->clock_info.enable = qede_ptp_ancillary_feature_enable;\n\n\tptp->clock = ptp_clock_register(&ptp->clock_info, &edev->pdev->dev);\n\tif (IS_ERR(ptp->clock)) {\n\t\tDP_ERR(edev, \"PTP clock registration failed\\n\");\n\t\tqede_ptp_disable(edev);\n\t\trc = -EINVAL;\n\t\tgoto err2;\n\t}\n\n\treturn 0;\n\nerr1:\n\tkfree(ptp);\nerr2:\n\tedev->ptp = NULL;\n\n\treturn rc;\n}\n\nvoid qede_ptp_tx_ts(struct qede_dev *edev, struct sk_buff *skb)\n{\n\tstruct qede_ptp *ptp;\n\n\tptp = edev->ptp;\n\tif (!ptp)\n\t\treturn;\n\n\tif (test_and_set_bit_lock(QEDE_FLAGS_PTP_TX_IN_PRORGESS,\n\t\t\t\t  &edev->flags)) {\n\t\tDP_VERBOSE(edev, QED_MSG_DEBUG, \"Timestamping in progress\\n\");\n\t\tedev->ptp_skip_txts++;\n\t\treturn;\n\t}\n\n\tif (unlikely(!test_bit(QEDE_FLAGS_TX_TIMESTAMPING_EN, &edev->flags))) {\n\t\tDP_VERBOSE(edev, QED_MSG_DEBUG,\n\t\t\t   \"Tx timestamping was not enabled, this pkt will not be timestamped\\n\");\n\t\tclear_bit_unlock(QEDE_FLAGS_PTP_TX_IN_PRORGESS, &edev->flags);\n\t\tedev->ptp_skip_txts++;\n\t} else if (unlikely(ptp->tx_skb)) {\n\t\tDP_VERBOSE(edev, QED_MSG_DEBUG,\n\t\t\t   \"Device supports a single outstanding pkt to ts, It will not be ts\\n\");\n\t\tclear_bit_unlock(QEDE_FLAGS_PTP_TX_IN_PRORGESS, &edev->flags);\n\t\tedev->ptp_skip_txts++;\n\t} else {\n\t\tskb_shinfo(skb)->tx_flags |= SKBTX_IN_PROGRESS;\n\t\t \n\t\tptp->tx_skb = skb_get(skb);\n\t\tptp->ptp_tx_start = jiffies;\n\t\tschedule_work(&ptp->work);\n\t}\n}\n\nvoid qede_ptp_rx_ts(struct qede_dev *edev, struct sk_buff *skb)\n{\n\tstruct qede_ptp *ptp;\n\tu64 timestamp, ns;\n\tint rc;\n\n\tptp = edev->ptp;\n\tif (!ptp)\n\t\treturn;\n\n\tspin_lock_bh(&ptp->lock);\n\trc = ptp->ops->read_rx_ts(edev->cdev, &timestamp);\n\tif (rc) {\n\t\tspin_unlock_bh(&ptp->lock);\n\t\tDP_INFO(edev, \"Invalid Rx timestamp\\n\");\n\t\treturn;\n\t}\n\n\tns = timecounter_cyc2time(&ptp->tc, timestamp);\n\tspin_unlock_bh(&ptp->lock);\n\tskb_hwtstamps(skb)->hwtstamp = ns_to_ktime(ns);\n\tDP_VERBOSE(edev, QED_MSG_DEBUG,\n\t\t   \"Rx timestamp, timestamp cycles = %llu, ns = %llu\\n\",\n\t\t   timestamp, ns);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}