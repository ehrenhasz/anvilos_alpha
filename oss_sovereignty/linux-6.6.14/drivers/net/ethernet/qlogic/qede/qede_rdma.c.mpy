{
  "module_name": "qede_rdma.c",
  "hash_id": "204a6400a5fbafd92a65cb97cbcc0fbbd20488cca963dbae42432e72f18db0bd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/qlogic/qede/qede_rdma.c",
  "human_readable_source": "\n \n\n#include <linux/pci.h>\n#include <linux/netdevice.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/qed/qede_rdma.h>\n#include \"qede.h\"\n\nstatic struct qedr_driver *qedr_drv;\nstatic LIST_HEAD(qedr_dev_list);\nstatic DEFINE_MUTEX(qedr_dev_list_lock);\n\nbool qede_rdma_supported(struct qede_dev *dev)\n{\n\treturn dev->dev_info.common.rdma_supported;\n}\n\nstatic void _qede_rdma_dev_add(struct qede_dev *edev)\n{\n\tif (!qedr_drv)\n\t\treturn;\n\n\t \n\tedev->rdma_info.exp_recovery = false;\n\tedev->rdma_info.qedr_dev = qedr_drv->add(edev->cdev, edev->pdev,\n\t\t\t\t\t\t edev->ndev);\n}\n\nstatic int qede_rdma_create_wq(struct qede_dev *edev)\n{\n\tINIT_LIST_HEAD(&edev->rdma_info.rdma_event_list);\n\tkref_init(&edev->rdma_info.refcnt);\n\tinit_completion(&edev->rdma_info.event_comp);\n\n\tedev->rdma_info.rdma_wq = create_singlethread_workqueue(\"rdma_wq\");\n\tif (!edev->rdma_info.rdma_wq) {\n\t\tDP_NOTICE(edev, \"qedr: Could not create workqueue\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic void qede_rdma_cleanup_event(struct qede_dev *edev)\n{\n\tstruct list_head *head = &edev->rdma_info.rdma_event_list;\n\tstruct qede_rdma_event_work *event_node;\n\n\tflush_workqueue(edev->rdma_info.rdma_wq);\n\twhile (!list_empty(head)) {\n\t\tevent_node = list_entry(head->next, struct qede_rdma_event_work,\n\t\t\t\t\tlist);\n\t\tcancel_work_sync(&event_node->work);\n\t\tlist_del(&event_node->list);\n\t\tkfree(event_node);\n\t}\n}\n\nstatic void qede_rdma_complete_event(struct kref *ref)\n{\n\tstruct qede_rdma_dev *rdma_dev =\n\t\tcontainer_of(ref, struct qede_rdma_dev, refcnt);\n\n\t \n\tcomplete(&rdma_dev->event_comp);\n}\n\nstatic void qede_rdma_destroy_wq(struct qede_dev *edev)\n{\n\t \n\tkref_put(&edev->rdma_info.refcnt, qede_rdma_complete_event);\n\twait_for_completion(&edev->rdma_info.event_comp);\n\n\tqede_rdma_cleanup_event(edev);\n\tdestroy_workqueue(edev->rdma_info.rdma_wq);\n\tedev->rdma_info.rdma_wq = NULL;\n}\n\nint qede_rdma_dev_add(struct qede_dev *edev, bool recovery)\n{\n\tint rc;\n\n\tif (!qede_rdma_supported(edev))\n\t\treturn 0;\n\n\t \n\tif (recovery)\n\t\treturn 0;\n\n\trc = qede_rdma_create_wq(edev);\n\tif (rc)\n\t\treturn rc;\n\n\tINIT_LIST_HEAD(&edev->rdma_info.entry);\n\tmutex_lock(&qedr_dev_list_lock);\n\tlist_add_tail(&edev->rdma_info.entry, &qedr_dev_list);\n\t_qede_rdma_dev_add(edev);\n\tmutex_unlock(&qedr_dev_list_lock);\n\n\treturn rc;\n}\n\nstatic void _qede_rdma_dev_remove(struct qede_dev *edev)\n{\n\tif (qedr_drv && qedr_drv->remove && edev->rdma_info.qedr_dev)\n\t\tqedr_drv->remove(edev->rdma_info.qedr_dev);\n}\n\nvoid qede_rdma_dev_remove(struct qede_dev *edev, bool recovery)\n{\n\tif (!qede_rdma_supported(edev))\n\t\treturn;\n\n\t \n\tif (!recovery) {\n\t\tqede_rdma_destroy_wq(edev);\n\t\tmutex_lock(&qedr_dev_list_lock);\n\t\tif (!edev->rdma_info.exp_recovery)\n\t\t\t_qede_rdma_dev_remove(edev);\n\t\tedev->rdma_info.qedr_dev = NULL;\n\t\tlist_del(&edev->rdma_info.entry);\n\t\tmutex_unlock(&qedr_dev_list_lock);\n\t} else {\n\t\tif (!edev->rdma_info.exp_recovery) {\n\t\t\tmutex_lock(&qedr_dev_list_lock);\n\t\t\t_qede_rdma_dev_remove(edev);\n\t\t\tmutex_unlock(&qedr_dev_list_lock);\n\t\t}\n\t\tedev->rdma_info.exp_recovery = true;\n\t}\n}\n\nstatic void _qede_rdma_dev_open(struct qede_dev *edev)\n{\n\tif (qedr_drv && edev->rdma_info.qedr_dev && qedr_drv->notify)\n\t\tqedr_drv->notify(edev->rdma_info.qedr_dev, QEDE_UP);\n}\n\nstatic void qede_rdma_dev_open(struct qede_dev *edev)\n{\n\tif (!qede_rdma_supported(edev))\n\t\treturn;\n\n\tmutex_lock(&qedr_dev_list_lock);\n\t_qede_rdma_dev_open(edev);\n\tmutex_unlock(&qedr_dev_list_lock);\n}\n\nstatic void _qede_rdma_dev_close(struct qede_dev *edev)\n{\n\tif (qedr_drv && edev->rdma_info.qedr_dev && qedr_drv->notify)\n\t\tqedr_drv->notify(edev->rdma_info.qedr_dev, QEDE_DOWN);\n}\n\nstatic void qede_rdma_dev_close(struct qede_dev *edev)\n{\n\tif (!qede_rdma_supported(edev))\n\t\treturn;\n\n\tmutex_lock(&qedr_dev_list_lock);\n\t_qede_rdma_dev_close(edev);\n\tmutex_unlock(&qedr_dev_list_lock);\n}\n\nstatic void qede_rdma_dev_shutdown(struct qede_dev *edev)\n{\n\tif (!qede_rdma_supported(edev))\n\t\treturn;\n\n\tmutex_lock(&qedr_dev_list_lock);\n\tif (qedr_drv && edev->rdma_info.qedr_dev && qedr_drv->notify)\n\t\tqedr_drv->notify(edev->rdma_info.qedr_dev, QEDE_CLOSE);\n\tmutex_unlock(&qedr_dev_list_lock);\n}\n\nint qede_rdma_register_driver(struct qedr_driver *drv)\n{\n\tstruct qede_dev *edev;\n\tu8 qedr_counter = 0;\n\n\tmutex_lock(&qedr_dev_list_lock);\n\tif (qedr_drv) {\n\t\tmutex_unlock(&qedr_dev_list_lock);\n\t\treturn -EINVAL;\n\t}\n\tqedr_drv = drv;\n\n\tlist_for_each_entry(edev, &qedr_dev_list, rdma_info.entry) {\n\t\tstruct net_device *ndev;\n\n\t\tqedr_counter++;\n\t\t_qede_rdma_dev_add(edev);\n\t\tndev = edev->ndev;\n\t\tif (netif_running(ndev) && netif_oper_up(ndev))\n\t\t\t_qede_rdma_dev_open(edev);\n\t}\n\tmutex_unlock(&qedr_dev_list_lock);\n\n\tpr_notice(\"qedr: discovered and registered %d RDMA funcs\\n\",\n\t\t  qedr_counter);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(qede_rdma_register_driver);\n\nvoid qede_rdma_unregister_driver(struct qedr_driver *drv)\n{\n\tstruct qede_dev *edev;\n\n\tmutex_lock(&qedr_dev_list_lock);\n\tlist_for_each_entry(edev, &qedr_dev_list, rdma_info.entry) {\n\t\t \n\t\tif (edev->rdma_info.qedr_dev && !edev->rdma_info.exp_recovery)\n\t\t\t_qede_rdma_dev_remove(edev);\n\t}\n\tqedr_drv = NULL;\n\tmutex_unlock(&qedr_dev_list_lock);\n}\nEXPORT_SYMBOL(qede_rdma_unregister_driver);\n\nstatic void qede_rdma_changeaddr(struct qede_dev *edev)\n{\n\tif (!qede_rdma_supported(edev))\n\t\treturn;\n\n\tif (qedr_drv && edev->rdma_info.qedr_dev && qedr_drv->notify)\n\t\tqedr_drv->notify(edev->rdma_info.qedr_dev, QEDE_CHANGE_ADDR);\n}\n\nstatic void qede_rdma_change_mtu(struct qede_dev *edev)\n{\n\tif (qede_rdma_supported(edev)) {\n\t\tif (qedr_drv && edev->rdma_info.qedr_dev && qedr_drv->notify)\n\t\t\tqedr_drv->notify(edev->rdma_info.qedr_dev,\n\t\t\t\t\t QEDE_CHANGE_MTU);\n\t}\n}\n\nstatic struct qede_rdma_event_work *\nqede_rdma_get_free_event_node(struct qede_dev *edev)\n{\n\tstruct qede_rdma_event_work *event_node = NULL;\n\tbool found = false;\n\n\tlist_for_each_entry(event_node, &edev->rdma_info.rdma_event_list,\n\t\t\t    list) {\n\t\tif (!work_pending(&event_node->work)) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!found) {\n\t\tevent_node = kzalloc(sizeof(*event_node), GFP_ATOMIC);\n\t\tif (!event_node) {\n\t\t\tDP_NOTICE(edev,\n\t\t\t\t  \"qedr: Could not allocate memory for rdma work\\n\");\n\t\t\treturn NULL;\n\t\t}\n\t\tlist_add_tail(&event_node->list,\n\t\t\t      &edev->rdma_info.rdma_event_list);\n\t}\n\n\treturn event_node;\n}\n\nstatic void qede_rdma_handle_event(struct work_struct *work)\n{\n\tstruct qede_rdma_event_work *event_node;\n\tenum qede_rdma_event event;\n\tstruct qede_dev *edev;\n\n\tevent_node = container_of(work, struct qede_rdma_event_work, work);\n\tevent = event_node->event;\n\tedev = event_node->ptr;\n\n\tswitch (event) {\n\tcase QEDE_UP:\n\t\tqede_rdma_dev_open(edev);\n\t\tbreak;\n\tcase QEDE_DOWN:\n\t\tqede_rdma_dev_close(edev);\n\t\tbreak;\n\tcase QEDE_CLOSE:\n\t\tqede_rdma_dev_shutdown(edev);\n\t\tbreak;\n\tcase QEDE_CHANGE_ADDR:\n\t\tqede_rdma_changeaddr(edev);\n\t\tbreak;\n\tcase QEDE_CHANGE_MTU:\n\t\tqede_rdma_change_mtu(edev);\n\t\tbreak;\n\tdefault:\n\t\tDP_NOTICE(edev, \"Invalid rdma event %d\", event);\n\t}\n}\n\nstatic void qede_rdma_add_event(struct qede_dev *edev,\n\t\t\t\tenum qede_rdma_event event)\n{\n\tstruct qede_rdma_event_work *event_node;\n\n\t \n\tif (edev->rdma_info.exp_recovery)\n\t\treturn;\n\n\tif (!edev->rdma_info.qedr_dev || !edev->rdma_info.rdma_wq)\n\t\treturn;\n\n\t \n\tif (!kref_get_unless_zero(&edev->rdma_info.refcnt))\n\t\treturn;  \n\n\tevent_node = qede_rdma_get_free_event_node(edev);\n\tif (!event_node)\n\t\tgoto out;\n\n\tevent_node->event = event;\n\tevent_node->ptr = edev;\n\n\tINIT_WORK(&event_node->work, qede_rdma_handle_event);\n\tqueue_work(edev->rdma_info.rdma_wq, &event_node->work);\n\nout:\n\tkref_put(&edev->rdma_info.refcnt, qede_rdma_complete_event);\n}\n\nvoid qede_rdma_dev_event_open(struct qede_dev *edev)\n{\n\tqede_rdma_add_event(edev, QEDE_UP);\n}\n\nvoid qede_rdma_dev_event_close(struct qede_dev *edev)\n{\n\tqede_rdma_add_event(edev, QEDE_DOWN);\n}\n\nvoid qede_rdma_event_changeaddr(struct qede_dev *edev)\n{\n\tqede_rdma_add_event(edev, QEDE_CHANGE_ADDR);\n}\n\nvoid qede_rdma_event_change_mtu(struct qede_dev *edev)\n{\n\tqede_rdma_add_event(edev, QEDE_CHANGE_MTU);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}