{
  "module_name": "spl2sw_int.c",
  "hash_id": "56e3ec9d734e21445b1491ebfa24e99ad3d55de90a769a6933c388af0bf92b8a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/sunplus/spl2sw_int.c",
  "human_readable_source": "\n \n\n#include <linux/platform_device.h>\n#include <linux/etherdevice.h>\n#include <linux/netdevice.h>\n#include <linux/bitfield.h>\n#include <linux/spinlock.h>\n#include <linux/of_mdio.h>\n\n#include \"spl2sw_register.h\"\n#include \"spl2sw_define.h\"\n#include \"spl2sw_int.h\"\n\nint spl2sw_rx_poll(struct napi_struct *napi, int budget)\n{\n\tstruct spl2sw_common *comm = container_of(napi, struct spl2sw_common, rx_napi);\n\tstruct spl2sw_mac_desc *desc, *h_desc;\n\tstruct net_device_stats *stats;\n\tstruct sk_buff *skb, *new_skb;\n\tstruct spl2sw_skb_info *sinfo;\n\tint budget_left = budget;\n\tunsigned long flags;\n\tu32 rx_pos, pkg_len;\n\tu32 num, rx_count;\n\ts32 queue;\n\tu32 mask;\n\tint port;\n\tu32 cmd;\n\tu32 len;\n\n\t \n\tfor (queue = 0; queue < RX_DESC_QUEUE_NUM; queue++) {\n\t\trx_pos = comm->rx_pos[queue];\n\t\trx_count = comm->rx_desc_num[queue];\n\n\t\tfor (num = 0; num < rx_count && budget_left; num++) {\n\t\t\tsinfo = comm->rx_skb_info[queue] + rx_pos;\n\t\t\tdesc = comm->rx_desc[queue] + rx_pos;\n\t\t\tcmd = desc->cmd1;\n\n\t\t\tif (cmd & RXD_OWN)\n\t\t\t\tbreak;\n\n\t\t\tport = FIELD_GET(RXD_PKT_SP, cmd);\n\t\t\tif (port < MAX_NETDEV_NUM && comm->ndev[port])\n\t\t\t\tstats = &comm->ndev[port]->stats;\n\t\t\telse\n\t\t\t\tgoto spl2sw_rx_poll_rec_err;\n\n\t\t\tpkg_len = FIELD_GET(RXD_PKT_LEN, cmd);\n\t\t\tif (unlikely((cmd & RXD_ERR_CODE) || pkg_len < ETH_ZLEN + 4)) {\n\t\t\t\tstats->rx_length_errors++;\n\t\t\t\tstats->rx_dropped++;\n\t\t\t\tgoto spl2sw_rx_poll_rec_err;\n\t\t\t}\n\n\t\t\tdma_unmap_single(&comm->pdev->dev, sinfo->mapping,\n\t\t\t\t\t comm->rx_desc_buff_size, DMA_FROM_DEVICE);\n\n\t\t\tskb = sinfo->skb;\n\t\t\tskb_put(skb, pkg_len - 4);  \n\t\t\tskb->ip_summed = CHECKSUM_NONE;\n\t\t\tskb->protocol = eth_type_trans(skb, comm->ndev[port]);\n\t\t\tlen = skb->len;\n\t\t\tnetif_receive_skb(skb);\n\n\t\t\tstats->rx_packets++;\n\t\t\tstats->rx_bytes += len;\n\n\t\t\t \n\t\t\tnew_skb = netdev_alloc_skb(NULL, comm->rx_desc_buff_size);\n\t\t\tif (unlikely(!new_skb)) {\n\t\t\t\tdesc->cmd2 = (rx_pos == comm->rx_desc_num[queue] - 1) ?\n\t\t\t\t\t     RXD_EOR : 0;\n\t\t\t\tsinfo->skb = NULL;\n\t\t\t\tsinfo->mapping = 0;\n\t\t\t\tdesc->addr1 = 0;\n\t\t\t\tgoto spl2sw_rx_poll_alloc_err;\n\t\t\t}\n\n\t\t\tsinfo->mapping = dma_map_single(&comm->pdev->dev, new_skb->data,\n\t\t\t\t\t\t\tcomm->rx_desc_buff_size,\n\t\t\t\t\t\t\tDMA_FROM_DEVICE);\n\t\t\tif (dma_mapping_error(&comm->pdev->dev, sinfo->mapping)) {\n\t\t\t\tdev_kfree_skb_irq(new_skb);\n\t\t\t\tdesc->cmd2 = (rx_pos == comm->rx_desc_num[queue] - 1) ?\n\t\t\t\t\t     RXD_EOR : 0;\n\t\t\t\tsinfo->skb = NULL;\n\t\t\t\tsinfo->mapping = 0;\n\t\t\t\tdesc->addr1 = 0;\n\t\t\t\tgoto spl2sw_rx_poll_alloc_err;\n\t\t\t}\n\n\t\t\tsinfo->skb = new_skb;\n\t\t\tdesc->addr1 = sinfo->mapping;\n\nspl2sw_rx_poll_rec_err:\n\t\t\tdesc->cmd2 = (rx_pos == comm->rx_desc_num[queue] - 1) ?\n\t\t\t\t     RXD_EOR | comm->rx_desc_buff_size :\n\t\t\t\t     comm->rx_desc_buff_size;\n\n\t\t\twmb();\t \n\t\t\tdesc->cmd1 = RXD_OWN;\n\nspl2sw_rx_poll_alloc_err:\n\t\t\t \n\t\t\trx_pos = ((rx_pos + 1) == comm->rx_desc_num[queue]) ? 0 : rx_pos + 1;\n\n\t\t\tbudget_left--;\n\n\t\t\t \n\t\t\tif (queue == 1 && !(h_desc->cmd1 & RXD_OWN))\n\t\t\t\tbreak;\n\t\t}\n\n\t\tcomm->rx_pos[queue] = rx_pos;\n\n\t\t \n\t\tif (queue == 0)\n\t\t\th_desc = comm->rx_desc[queue] + rx_pos;\n\t}\n\n\tspin_lock_irqsave(&comm->int_mask_lock, flags);\n\tmask = readl(comm->l2sw_reg_base + L2SW_SW_INT_MASK_0);\n\tmask &= ~MAC_INT_RX;\n\twritel(mask, comm->l2sw_reg_base + L2SW_SW_INT_MASK_0);\n\tspin_unlock_irqrestore(&comm->int_mask_lock, flags);\n\n\tnapi_complete(napi);\n\treturn budget - budget_left;\n}\n\nint spl2sw_tx_poll(struct napi_struct *napi, int budget)\n{\n\tstruct spl2sw_common *comm = container_of(napi, struct spl2sw_common, tx_napi);\n\tstruct spl2sw_skb_info *skbinfo;\n\tstruct net_device_stats *stats;\n\tint budget_left = budget;\n\tunsigned long flags;\n\tu32 tx_done_pos;\n\tu32 mask;\n\tu32 cmd;\n\tint i;\n\n\tspin_lock(&comm->tx_lock);\n\n\ttx_done_pos = comm->tx_done_pos;\n\twhile (((tx_done_pos != comm->tx_pos) || (comm->tx_desc_full == 1)) && budget_left) {\n\t\tcmd = comm->tx_desc[tx_done_pos].cmd1;\n\t\tif (cmd & TXD_OWN)\n\t\t\tbreak;\n\n\t\tskbinfo = &comm->tx_temp_skb_info[tx_done_pos];\n\t\tif (unlikely(!skbinfo->skb))\n\t\t\tgoto spl2sw_tx_poll_next;\n\n\t\ti = ffs(FIELD_GET(TXD_VLAN, cmd)) - 1;\n\t\tif (i < MAX_NETDEV_NUM && comm->ndev[i])\n\t\t\tstats = &comm->ndev[i]->stats;\n\t\telse\n\t\t\tgoto spl2sw_tx_poll_unmap;\n\n\t\tif (unlikely(cmd & (TXD_ERR_CODE))) {\n\t\t\tstats->tx_errors++;\n\t\t} else {\n\t\t\tstats->tx_packets++;\n\t\t\tstats->tx_bytes += skbinfo->len;\n\t\t}\n\nspl2sw_tx_poll_unmap:\n\t\tdma_unmap_single(&comm->pdev->dev, skbinfo->mapping, skbinfo->len,\n\t\t\t\t DMA_TO_DEVICE);\n\t\tskbinfo->mapping = 0;\n\t\tdev_kfree_skb_irq(skbinfo->skb);\n\t\tskbinfo->skb = NULL;\n\nspl2sw_tx_poll_next:\n\t\t \n\t\ttx_done_pos = ((tx_done_pos + 1) == TX_DESC_NUM) ? 0 : tx_done_pos + 1;\n\n\t\tif (comm->tx_desc_full == 1)\n\t\t\tcomm->tx_desc_full = 0;\n\n\t\tbudget_left--;\n\t}\n\n\tcomm->tx_done_pos = tx_done_pos;\n\tif (!comm->tx_desc_full)\n\t\tfor (i = 0; i < MAX_NETDEV_NUM; i++)\n\t\t\tif (comm->ndev[i])\n\t\t\t\tif (netif_queue_stopped(comm->ndev[i]))\n\t\t\t\t\tnetif_wake_queue(comm->ndev[i]);\n\n\tspin_unlock(&comm->tx_lock);\n\n\tspin_lock_irqsave(&comm->int_mask_lock, flags);\n\tmask = readl(comm->l2sw_reg_base + L2SW_SW_INT_MASK_0);\n\tmask &= ~MAC_INT_TX;\n\twritel(mask, comm->l2sw_reg_base + L2SW_SW_INT_MASK_0);\n\tspin_unlock_irqrestore(&comm->int_mask_lock, flags);\n\n\tnapi_complete(napi);\n\treturn budget - budget_left;\n}\n\nirqreturn_t spl2sw_ethernet_interrupt(int irq, void *dev_id)\n{\n\tstruct spl2sw_common *comm = (struct spl2sw_common *)dev_id;\n\tu32 status;\n\tu32 mask;\n\tint i;\n\n\tstatus = readl(comm->l2sw_reg_base + L2SW_SW_INT_STATUS_0);\n\tif (unlikely(!status)) {\n\t\tdev_dbg(&comm->pdev->dev, \"Interrupt status is null!\\n\");\n\t\tgoto spl2sw_ethernet_int_out;\n\t}\n\twritel(status, comm->l2sw_reg_base + L2SW_SW_INT_STATUS_0);\n\n\tif (status & MAC_INT_RX) {\n\t\t \n\t\tspin_lock(&comm->int_mask_lock);\n\t\tmask = readl(comm->l2sw_reg_base + L2SW_SW_INT_MASK_0);\n\t\tmask |= MAC_INT_RX;\n\t\twritel(mask, comm->l2sw_reg_base + L2SW_SW_INT_MASK_0);\n\t\tspin_unlock(&comm->int_mask_lock);\n\n\t\tif (unlikely(status & MAC_INT_RX_DES_ERR)) {\n\t\t\tfor (i = 0; i < MAX_NETDEV_NUM; i++)\n\t\t\t\tif (comm->ndev[i]) {\n\t\t\t\t\tcomm->ndev[i]->stats.rx_fifo_errors++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tdev_dbg(&comm->pdev->dev, \"Illegal RX Descriptor!\\n\");\n\t\t}\n\n\t\tnapi_schedule(&comm->rx_napi);\n\t}\n\n\tif (status & MAC_INT_TX) {\n\t\t \n\t\tspin_lock(&comm->int_mask_lock);\n\t\tmask = readl(comm->l2sw_reg_base + L2SW_SW_INT_MASK_0);\n\t\tmask |= MAC_INT_TX;\n\t\twritel(mask, comm->l2sw_reg_base + L2SW_SW_INT_MASK_0);\n\t\tspin_unlock(&comm->int_mask_lock);\n\n\t\tif (unlikely(status & MAC_INT_TX_DES_ERR)) {\n\t\t\tfor (i = 0; i < MAX_NETDEV_NUM; i++)\n\t\t\t\tif (comm->ndev[i]) {\n\t\t\t\t\tcomm->ndev[i]->stats.tx_fifo_errors++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tdev_dbg(&comm->pdev->dev, \"Illegal TX Descriptor Error\\n\");\n\n\t\t\tspin_lock(&comm->int_mask_lock);\n\t\t\tmask = readl(comm->l2sw_reg_base + L2SW_SW_INT_MASK_0);\n\t\t\tmask &= ~MAC_INT_TX;\n\t\t\twritel(mask, comm->l2sw_reg_base + L2SW_SW_INT_MASK_0);\n\t\t\tspin_unlock(&comm->int_mask_lock);\n\t\t} else {\n\t\t\tnapi_schedule(&comm->tx_napi);\n\t\t}\n\t}\n\nspl2sw_ethernet_int_out:\n\treturn IRQ_HANDLED;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}