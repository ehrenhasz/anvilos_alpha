{
  "module_name": "spl2sw_driver.c",
  "hash_id": "6e5871116357c5a882cf303542f9bbdb9d6a5abbf6ed870288a224af61132c0b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/sunplus/spl2sw_driver.c",
  "human_readable_source": "\n \n\n#include <linux/platform_device.h>\n#include <linux/nvmem-consumer.h>\n#include <linux/etherdevice.h>\n#include <linux/netdevice.h>\n#include <linux/spinlock.h>\n#include <linux/of_net.h>\n#include <linux/reset.h>\n#include <linux/clk.h>\n#include <linux/of.h>\n\n#include \"spl2sw_register.h\"\n#include \"spl2sw_define.h\"\n#include \"spl2sw_desc.h\"\n#include \"spl2sw_mdio.h\"\n#include \"spl2sw_phy.h\"\n#include \"spl2sw_int.h\"\n#include \"spl2sw_mac.h\"\n\n \nstatic int spl2sw_ethernet_open(struct net_device *ndev)\n{\n\tstruct spl2sw_mac *mac = netdev_priv(ndev);\n\tstruct spl2sw_common *comm = mac->comm;\n\tu32 mask;\n\n\tnetdev_dbg(ndev, \"Open port = %x\\n\", mac->lan_port);\n\n\tcomm->enable |= mac->lan_port;\n\n\tspl2sw_mac_hw_start(comm);\n\n\t \n\tmask = readl(comm->l2sw_reg_base + L2SW_SW_INT_MASK_0);\n\tmask &= ~(MAC_INT_TX | MAC_INT_RX);\n\twritel(mask, comm->l2sw_reg_base + L2SW_SW_INT_MASK_0);\n\n\tphy_start(ndev->phydev);\n\n\tnetif_start_queue(ndev);\n\n\treturn 0;\n}\n\nstatic int spl2sw_ethernet_stop(struct net_device *ndev)\n{\n\tstruct spl2sw_mac *mac = netdev_priv(ndev);\n\tstruct spl2sw_common *comm = mac->comm;\n\n\tnetif_stop_queue(ndev);\n\n\tcomm->enable &= ~mac->lan_port;\n\n\tphy_stop(ndev->phydev);\n\n\tspl2sw_mac_hw_stop(comm);\n\n\treturn 0;\n}\n\nstatic netdev_tx_t spl2sw_ethernet_start_xmit(struct sk_buff *skb,\n\t\t\t\t\t      struct net_device *ndev)\n{\n\tstruct spl2sw_mac *mac = netdev_priv(ndev);\n\tstruct spl2sw_common *comm = mac->comm;\n\tstruct spl2sw_skb_info *skbinfo;\n\tstruct spl2sw_mac_desc *txdesc;\n\tunsigned long flags;\n\tu32 mapping;\n\tu32 tx_pos;\n\tu32 cmd1;\n\tu32 cmd2;\n\n\tif (unlikely(comm->tx_desc_full == 1)) {\n\t\t \n\t\tnetdev_dbg(ndev, \"TX descriptor queue full when xmit!\\n\");\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\n\t \n\tif (unlikely(skb->len < ETH_ZLEN)) {\n\t\tif (skb_padto(skb, ETH_ZLEN))\n\t\t\treturn NETDEV_TX_OK;\n\n\t\tskb_put(skb, ETH_ZLEN - skb->len);\n\t}\n\n\tmapping = dma_map_single(&comm->pdev->dev, skb->data,\n\t\t\t\t skb->len, DMA_TO_DEVICE);\n\tif (dma_mapping_error(&comm->pdev->dev, mapping)) {\n\t\tndev->stats.tx_errors++;\n\t\tdev_kfree_skb(skb);\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\tspin_lock_irqsave(&comm->tx_lock, flags);\n\n\ttx_pos = comm->tx_pos;\n\ttxdesc = &comm->tx_desc[tx_pos];\n\tskbinfo = &comm->tx_temp_skb_info[tx_pos];\n\tskbinfo->mapping = mapping;\n\tskbinfo->len = skb->len;\n\tskbinfo->skb = skb;\n\n\t \n\tcmd1 = TXD_OWN | TXD_SOP | TXD_EOP | (mac->to_vlan << 12) |\n\t       (skb->len & TXD_PKT_LEN);\n\tcmd2 = skb->len & TXD_BUF_LEN1;\n\n\tif (tx_pos == (TX_DESC_NUM - 1))\n\t\tcmd2 |= TXD_EOR;\n\n\ttxdesc->addr1 = skbinfo->mapping;\n\ttxdesc->cmd2 = cmd2;\n\twmb();\t \n\ttxdesc->cmd1 = cmd1;\n\n\t \n\ttx_pos = ((tx_pos + 1) == TX_DESC_NUM) ? 0 : tx_pos + 1;\n\n\tif (unlikely(tx_pos == comm->tx_done_pos)) {\n\t\tnetif_stop_queue(ndev);\n\t\tcomm->tx_desc_full = 1;\n\t}\n\tcomm->tx_pos = tx_pos;\n\twmb();\t\t \n\n\t \n\twritel(MAC_TRIG_L_SOC0, comm->l2sw_reg_base + L2SW_CPU_TX_TRIG);\n\n\tspin_unlock_irqrestore(&comm->tx_lock, flags);\n\treturn NETDEV_TX_OK;\n}\n\nstatic void spl2sw_ethernet_set_rx_mode(struct net_device *ndev)\n{\n\tstruct spl2sw_mac *mac = netdev_priv(ndev);\n\n\tspl2sw_mac_rx_mode_set(mac);\n}\n\nstatic int spl2sw_ethernet_set_mac_address(struct net_device *ndev, void *addr)\n{\n\tstruct spl2sw_mac *mac = netdev_priv(ndev);\n\tint err;\n\n\terr = eth_mac_addr(ndev, addr);\n\tif (err)\n\t\treturn err;\n\n\t \n\tnetdev_dbg(ndev, \"Old Ethernet (MAC) address = %pM\\n\", mac->mac_addr);\n\tif (is_valid_ether_addr(mac->mac_addr)) {\n\t\terr = spl2sw_mac_addr_del(mac);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t \n\tether_addr_copy(mac->mac_addr, ndev->dev_addr);\n\treturn spl2sw_mac_addr_add(mac);\n}\n\nstatic void spl2sw_ethernet_tx_timeout(struct net_device *ndev, unsigned int txqueue)\n{\n\tstruct spl2sw_mac *mac = netdev_priv(ndev);\n\tstruct spl2sw_common *comm = mac->comm;\n\tunsigned long flags;\n\tint i;\n\n\tnetdev_err(ndev, \"TX timed out!\\n\");\n\tndev->stats.tx_errors++;\n\n\tspin_lock_irqsave(&comm->tx_lock, flags);\n\n\tfor (i = 0; i < MAX_NETDEV_NUM; i++)\n\t\tif (comm->ndev[i])\n\t\t\tnetif_stop_queue(comm->ndev[i]);\n\n\tspl2sw_mac_soft_reset(comm);\n\n\t \n\tfor (i = 0; i < MAX_NETDEV_NUM; i++)\n\t\tif (comm->ndev[i]) {\n\t\t\tnetif_trans_update(comm->ndev[i]);\n\t\t\tnetif_wake_queue(comm->ndev[i]);\n\t\t}\n\n\tspin_unlock_irqrestore(&comm->tx_lock, flags);\n}\n\nstatic const struct net_device_ops netdev_ops = {\n\t.ndo_open = spl2sw_ethernet_open,\n\t.ndo_stop = spl2sw_ethernet_stop,\n\t.ndo_start_xmit = spl2sw_ethernet_start_xmit,\n\t.ndo_set_rx_mode = spl2sw_ethernet_set_rx_mode,\n\t.ndo_set_mac_address = spl2sw_ethernet_set_mac_address,\n\t.ndo_do_ioctl = phy_do_ioctl,\n\t.ndo_tx_timeout = spl2sw_ethernet_tx_timeout,\n};\n\nstatic void spl2sw_check_mac_vendor_id_and_convert(u8 *mac_addr)\n{\n\t \n\tif (mac_addr[5] == 0xfc && mac_addr[4] == 0x4b && mac_addr[3] == 0xbc &&\n\t    (mac_addr[0] != 0xfc || mac_addr[1] != 0x4b || mac_addr[2] != 0xbc)) {\n\n\t\tswap(mac_addr[0], mac_addr[5]);\n\t\tswap(mac_addr[1], mac_addr[4]);\n\t\tswap(mac_addr[2], mac_addr[3]);\n\t}\n}\n\nstatic int spl2sw_nvmem_get_mac_address(struct device *dev, struct device_node *np,\n\t\t\t\t\tvoid *addrbuf)\n{\n\tstruct nvmem_cell *cell;\n\tssize_t len;\n\tu8 *mac;\n\n\t \n\tcell = of_nvmem_cell_get(np, \"mac-address\");\n\tif (IS_ERR(cell))\n\t\treturn PTR_ERR(cell);\n\n\t \n\tmac = nvmem_cell_read(cell, &len);\n\tnvmem_cell_put(cell);\n\tif (IS_ERR(mac))\n\t\treturn PTR_ERR(mac);\n\n\tif (len != ETH_ALEN) {\n\t\tkfree(mac);\n\t\tdev_info(dev, \"Invalid length of mac address in nvmem!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tspl2sw_check_mac_vendor_id_and_convert(mac);\n\n\t \n\tif (!is_valid_ether_addr(mac)) {\n\t\tdev_info(dev, \"Invalid mac address in nvmem (%pM)!\\n\", mac);\n\t\tkfree(mac);\n\t\treturn -EINVAL;\n\t}\n\n\tether_addr_copy(addrbuf, mac);\n\tkfree(mac);\n\treturn 0;\n}\n\nstatic u32 spl2sw_init_netdev(struct platform_device *pdev, u8 *mac_addr,\n\t\t\t      struct net_device **r_ndev)\n{\n\tstruct net_device *ndev;\n\tstruct spl2sw_mac *mac;\n\tint ret;\n\n\t \n\tndev = devm_alloc_etherdev(&pdev->dev, sizeof(*mac));\n\tif (!ndev) {\n\t\t*r_ndev = NULL;\n\t\treturn -ENOMEM;\n\t}\n\tSET_NETDEV_DEV(ndev, &pdev->dev);\n\tndev->netdev_ops = &netdev_ops;\n\tmac = netdev_priv(ndev);\n\tmac->ndev = ndev;\n\tether_addr_copy(mac->mac_addr, mac_addr);\n\n\teth_hw_addr_set(ndev, mac_addr);\n\tdev_info(&pdev->dev, \"Ethernet (MAC) address = %pM\\n\", mac_addr);\n\n\tret = register_netdev(ndev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Failed to register net device \\\"%s\\\"!\\n\",\n\t\t\tndev->name);\n\t\t*r_ndev = NULL;\n\t\treturn ret;\n\t}\n\tnetdev_dbg(ndev, \"Registered net device \\\"%s\\\" successfully.\\n\", ndev->name);\n\n\t*r_ndev = ndev;\n\treturn 0;\n}\n\nstatic struct device_node *spl2sw_get_eth_child_node(struct device_node *ether_np, int id)\n{\n\tstruct device_node *port_np;\n\tint port_id;\n\n\tfor_each_child_of_node(ether_np, port_np) {\n\t\t \n\t\tif (strcmp(port_np->name, \"port\"))\n\t\t\tcontinue;\n\n\t\tif (of_property_read_u32(port_np, \"reg\", &port_id) < 0)\n\t\t\tcontinue;\n\n\t\tif (port_id == id)\n\t\t\treturn port_np;\n\t}\n\n\t \n\treturn NULL;\n}\n\nstatic int spl2sw_probe(struct platform_device *pdev)\n{\n\tstruct device_node *eth_ports_np;\n\tstruct device_node *port_np;\n\tstruct spl2sw_common *comm;\n\tstruct device_node *phy_np;\n\tphy_interface_t phy_mode;\n\tstruct net_device *ndev;\n\tstruct spl2sw_mac *mac;\n\tu8 mac_addr[ETH_ALEN];\n\tint irq, i, ret;\n\n\tif (platform_get_drvdata(pdev))\n\t\treturn -ENODEV;\n\n\t \n\tcomm = devm_kzalloc(&pdev->dev, sizeof(*comm), GFP_KERNEL);\n\tif (!comm)\n\t\treturn -ENOMEM;\n\n\tcomm->pdev = pdev;\n\tplatform_set_drvdata(pdev, comm);\n\n\tspin_lock_init(&comm->tx_lock);\n\tspin_lock_init(&comm->mdio_lock);\n\tspin_lock_init(&comm->int_mask_lock);\n\n\t \n\tcomm->l2sw_reg_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(comm->l2sw_reg_base))\n\t\treturn PTR_ERR(comm->l2sw_reg_base);\n\n\t \n\tret = platform_get_irq(pdev, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\tirq = ret;\n\n\t \n\tcomm->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(comm->clk)) {\n\t\tdev_err_probe(&pdev->dev, PTR_ERR(comm->clk),\n\t\t\t      \"Failed to retrieve clock controller!\\n\");\n\t\treturn PTR_ERR(comm->clk);\n\t}\n\n\t \n\tcomm->rstc = devm_reset_control_get_exclusive(&pdev->dev, NULL);\n\tif (IS_ERR(comm->rstc)) {\n\t\tdev_err_probe(&pdev->dev, PTR_ERR(comm->rstc),\n\t\t\t      \"Failed to retrieve reset controller!\\n\");\n\t\treturn PTR_ERR(comm->rstc);\n\t}\n\n\t \n\tret = clk_prepare_enable(comm->clk);\n\tif (ret)\n\t\treturn ret;\n\tudelay(1);\n\n\t \n\treset_control_assert(comm->rstc);\n\tudelay(1);\n\treset_control_deassert(comm->rstc);\n\tusleep_range(1000, 2000);\n\n\t \n\tret = devm_request_irq(&pdev->dev, irq, spl2sw_ethernet_interrupt, 0,\n\t\t\t       dev_name(&pdev->dev), comm);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Failed to request irq #%d!\\n\", irq);\n\t\tgoto out_clk_disable;\n\t}\n\n\t \n\tret = spl2sw_descs_init(comm);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Fail to initialize mac descriptors!\\n\");\n\t\tspl2sw_descs_free(comm);\n\t\tgoto out_clk_disable;\n\t}\n\n\t \n\tspl2sw_mac_init(comm);\n\n\t \n\tret = spl2sw_mdio_init(comm);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Failed to initialize mdio bus!\\n\");\n\t\tgoto out_clk_disable;\n\t}\n\n\t \n\teth_ports_np = of_get_child_by_name(pdev->dev.of_node, \"ethernet-ports\");\n\tif (!eth_ports_np) {\n\t\tdev_err(&pdev->dev, \"No ethernet-ports child node found!\\n\");\n\t\tret = -ENODEV;\n\t\tgoto out_free_mdio;\n\t}\n\n\tfor (i = 0; i < MAX_NETDEV_NUM; i++) {\n\t\t \n\t\tport_np = spl2sw_get_eth_child_node(eth_ports_np, i);\n\t\tif (!port_np)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (of_get_phy_mode(port_np, &phy_mode)) {\n\t\t\tdev_err(&pdev->dev, \"Failed to get phy-mode property of port@%d!\\n\",\n\t\t\t\ti);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tphy_np = of_parse_phandle(port_np, \"phy-handle\", 0);\n\t\tif (!phy_np) {\n\t\t\tdev_err(&pdev->dev, \"Failed to get phy-handle property of port@%d!\\n\",\n\t\t\t\ti);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tret = spl2sw_nvmem_get_mac_address(&pdev->dev, port_np, mac_addr);\n\t\tif (ret == -EPROBE_DEFER) {\n\t\t\tgoto out_unregister_dev;\n\t\t} else if (ret) {\n\t\t\tdev_info(&pdev->dev, \"Generate a random mac address!\\n\");\n\t\t\teth_random_addr(mac_addr);\n\t\t}\n\n\t\t \n\t\tret = spl2sw_init_netdev(pdev, mac_addr, &ndev);\n\t\tif (ret)\n\t\t\tgoto out_unregister_dev;\n\n\t\tndev->irq = irq;\n\t\tcomm->ndev[i] = ndev;\n\t\tmac = netdev_priv(ndev);\n\t\tmac->phy_node = phy_np;\n\t\tmac->phy_mode = phy_mode;\n\t\tmac->comm = comm;\n\n\t\tmac->lan_port = 0x1 << i;\t \n\t\tmac->to_vlan = 0x1 << i;\t \n\t\tmac->vlan_id = i;\t\t \n\n\t\t \n\t\tret = spl2sw_mac_addr_add(mac);\n\t\tif (ret)\n\t\t\tgoto out_unregister_dev;\n\n\t\tspl2sw_mac_rx_mode_set(mac);\n\t}\n\n\t \n\tfor (i = 0; i < MAX_NETDEV_NUM; i++) {\n\t\tif (comm->ndev[i])\n\t\t\tbreak;\n\t}\n\tif (i >= MAX_NETDEV_NUM) {\n\t\tdev_err(&pdev->dev, \"No valid ethernet port!\\n\");\n\t\tret = -ENODEV;\n\t\tgoto out_free_mdio;\n\t}\n\n\t \n\tndev = comm->ndev[i];\n\n\tret = spl2sw_phy_connect(comm);\n\tif (ret) {\n\t\tnetdev_err(ndev, \"Failed to connect phy!\\n\");\n\t\tgoto out_unregister_dev;\n\t}\n\n\t \n\tnetif_napi_add(ndev, &comm->rx_napi, spl2sw_rx_poll);\n\tnapi_enable(&comm->rx_napi);\n\tnetif_napi_add_tx(ndev, &comm->tx_napi, spl2sw_tx_poll);\n\tnapi_enable(&comm->tx_napi);\n\treturn 0;\n\nout_unregister_dev:\n\tfor (i = 0; i < MAX_NETDEV_NUM; i++)\n\t\tif (comm->ndev[i])\n\t\t\tunregister_netdev(comm->ndev[i]);\n\nout_free_mdio:\n\tspl2sw_mdio_remove(comm);\n\nout_clk_disable:\n\tclk_disable_unprepare(comm->clk);\n\treturn ret;\n}\n\nstatic int spl2sw_remove(struct platform_device *pdev)\n{\n\tstruct spl2sw_common *comm;\n\tint i;\n\n\tcomm = platform_get_drvdata(pdev);\n\n\tspl2sw_phy_remove(comm);\n\n\t \n\tfor (i = 0; i < MAX_NETDEV_NUM; i++)\n\t\tif (comm->ndev[i])\n\t\t\tunregister_netdev(comm->ndev[i]);\n\n\tcomm->enable = 0;\n\tspl2sw_mac_hw_stop(comm);\n\tspl2sw_descs_free(comm);\n\n\t \n\tnapi_disable(&comm->rx_napi);\n\tnetif_napi_del(&comm->rx_napi);\n\tnapi_disable(&comm->tx_napi);\n\tnetif_napi_del(&comm->tx_napi);\n\n\tspl2sw_mdio_remove(comm);\n\n\tclk_disable_unprepare(comm->clk);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id spl2sw_of_match[] = {\n\t{.compatible = \"sunplus,sp7021-emac\"},\n\t{   }\n};\n\nMODULE_DEVICE_TABLE(of, spl2sw_of_match);\n\nstatic struct platform_driver spl2sw_driver = {\n\t.probe = spl2sw_probe,\n\t.remove = spl2sw_remove,\n\t.driver = {\n\t\t.name = \"sp7021_emac\",\n\t\t.of_match_table = spl2sw_of_match,\n\t},\n};\n\nmodule_platform_driver(spl2sw_driver);\n\nMODULE_AUTHOR(\"Wells Lu <wellslutw@gmail.com>\");\nMODULE_DESCRIPTION(\"Sunplus Dual 10M/100M Ethernet driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}