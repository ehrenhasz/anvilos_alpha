{
  "module_name": "spl2sw_mdio.c",
  "hash_id": "baab7bd5c81a42984c6f364b6e2c7fcebca8653acf87518ece20219803dc90f5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/sunplus/spl2sw_mdio.c",
  "human_readable_source": "\n \n\n#include <linux/platform_device.h>\n#include <linux/netdevice.h>\n#include <linux/bitfield.h>\n#include <linux/of_mdio.h>\n\n#include \"spl2sw_register.h\"\n#include \"spl2sw_define.h\"\n#include \"spl2sw_mdio.h\"\n\n#define SPL2SW_MDIO_READ_CMD           0x02\n#define SPL2SW_MDIO_WRITE_CMD          0x01\n\nstatic int spl2sw_mdio_access(struct spl2sw_common *comm, u8 cmd, u8 addr, u8 regnum, u16 wdata)\n{\n\tu32 reg, reg2;\n\tu32 val;\n\tint ret;\n\n\t \n\treg = readl(comm->l2sw_reg_base + L2SW_MAC_FORCE_MODE);\n\treg &= ~MAC_EXT_PHY0_ADDR;\n\treg |= FIELD_PREP(MAC_EXT_PHY0_ADDR, addr);\n\n\treg2 = FIELD_PREP(MAC_CPU_PHY_WT_DATA, wdata) | FIELD_PREP(MAC_CPU_PHY_CMD, cmd) |\n\t       FIELD_PREP(MAC_CPU_PHY_REG_ADDR, regnum) | FIELD_PREP(MAC_CPU_PHY_ADDR, addr);\n\n\t \n\tspin_lock_irq(&comm->mdio_lock);\n\twritel(reg, comm->l2sw_reg_base + L2SW_MAC_FORCE_MODE);\n\twritel(reg2, comm->l2sw_reg_base + L2SW_PHY_CNTL_REG0);\n\tspin_unlock_irq(&comm->mdio_lock);\n\n\tret = read_poll_timeout(readl, val, val & cmd, 1, 1000, true,\n\t\t\t\tcomm->l2sw_reg_base + L2SW_PHY_CNTL_REG1);\n\n\t \n\treg = readl(comm->l2sw_reg_base + L2SW_MAC_FORCE_MODE);\n\treg &= ~MAC_EXT_PHY0_ADDR;\n\treg |= FIELD_PREP(MAC_EXT_PHY0_ADDR, 31);\n\twritel(reg, comm->l2sw_reg_base + L2SW_MAC_FORCE_MODE);\n\n\tif (ret == 0)\n\t\treturn val >> 16;\n\telse\n\t\treturn ret;\n}\n\nstatic int spl2sw_mii_read(struct mii_bus *bus, int addr, int regnum)\n{\n\tstruct spl2sw_common *comm = bus->priv;\n\n\treturn spl2sw_mdio_access(comm, SPL2SW_MDIO_READ_CMD, addr, regnum, 0);\n}\n\nstatic int spl2sw_mii_write(struct mii_bus *bus, int addr, int regnum, u16 val)\n{\n\tstruct spl2sw_common *comm = bus->priv;\n\tint ret;\n\n\tret = spl2sw_mdio_access(comm, SPL2SW_MDIO_WRITE_CMD, addr, regnum, val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nu32 spl2sw_mdio_init(struct spl2sw_common *comm)\n{\n\tstruct device_node *mdio_np;\n\tstruct mii_bus *mii_bus;\n\tint ret;\n\n\t \n\tmdio_np = of_get_child_by_name(comm->pdev->dev.of_node, \"mdio\");\n\tif (!mdio_np) {\n\t\tdev_err(&comm->pdev->dev, \"No mdio child node found!\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tmii_bus = devm_mdiobus_alloc(&comm->pdev->dev);\n\tif (!mii_bus) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tmii_bus->name = \"sunplus_mii_bus\";\n\tmii_bus->parent = &comm->pdev->dev;\n\tmii_bus->priv = comm;\n\tmii_bus->read = spl2sw_mii_read;\n\tmii_bus->write = spl2sw_mii_write;\n\tsnprintf(mii_bus->id, MII_BUS_ID_SIZE, \"%s-mii\", dev_name(&comm->pdev->dev));\n\n\tret = of_mdiobus_register(mii_bus, mdio_np);\n\tif (ret) {\n\t\tdev_err(&comm->pdev->dev, \"Failed to register mdiobus!\\n\");\n\t\tgoto out;\n\t}\n\n\tcomm->mii_bus = mii_bus;\n\nout:\n\tof_node_put(mdio_np);\n\treturn ret;\n}\n\nvoid spl2sw_mdio_remove(struct spl2sw_common *comm)\n{\n\tif (comm->mii_bus) {\n\t\tmdiobus_unregister(comm->mii_bus);\n\t\tcomm->mii_bus = NULL;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}