{
  "module_name": "lib8390.c",
  "hash_id": "f6599d6d2dfdb319be7b0b51506d0c5a906db1d181152040b73567d6cbb98b7f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/8390/lib8390.c",
  "human_readable_source": "\n\n \n \n\n#include <linux/build_bug.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/jiffies.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/io.h>\n#include <asm/irq.h>\n#include <linux/delay.h>\n#include <linux/errno.h>\n#include <linux/fcntl.h>\n#include <linux/in.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/crc32.h>\n\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n\n#define NS8390_CORE\n#include \"8390.h\"\n\n#define BUG_83C690\n\n \n#define ei_reset_8390 (ei_local->reset_8390)\n#define ei_block_output (ei_local->block_output)\n#define ei_block_input (ei_local->block_input)\n#define ei_get_8390_hdr (ei_local->get_8390_hdr)\n\n \nstatic void ei_tx_intr(struct net_device *dev);\nstatic void ei_tx_err(struct net_device *dev);\nstatic void ei_receive(struct net_device *dev);\nstatic void ei_rx_overrun(struct net_device *dev);\n\n \nstatic void NS8390_trigger_send(struct net_device *dev, unsigned int length,\n\t\t\t\t\t\t\t\tint start_page);\nstatic void do_set_multicast_list(struct net_device *dev);\nstatic void __NS8390_init(struct net_device *dev, int startp);\n\nstatic unsigned version_printed;\nstatic int msg_enable;\nstatic const int default_msg_level = (NETIF_MSG_DRV | NETIF_MSG_PROBE | NETIF_MSG_RX_ERR |\n\t\t\t\t     NETIF_MSG_TX_ERR);\nmodule_param(msg_enable, int, 0444);\nMODULE_PARM_DESC(msg_enable, \"Debug message level (see linux/netdevice.h for bitmap)\");\n\n \n\n\n\n \nstatic int __ei_open(struct net_device *dev)\n{\n\tunsigned long flags;\n\tstruct ei_device *ei_local = netdev_priv(dev);\n\n\tif (dev->watchdog_timeo <= 0)\n\t\tdev->watchdog_timeo = TX_TIMEOUT;\n\n\t \n\n\tspin_lock_irqsave(&ei_local->page_lock, flags);\n\t__NS8390_init(dev, 1);\n\t \n\tnetif_start_queue(dev);\n\tspin_unlock_irqrestore(&ei_local->page_lock, flags);\n\tei_local->irqlock = 0;\n\treturn 0;\n}\n\n \nstatic int __ei_close(struct net_device *dev)\n{\n\tstruct ei_device *ei_local = netdev_priv(dev);\n\tunsigned long flags;\n\n\t \n\n\tspin_lock_irqsave(&ei_local->page_lock, flags);\n\t__NS8390_init(dev, 0);\n\tspin_unlock_irqrestore(&ei_local->page_lock, flags);\n\tnetif_stop_queue(dev);\n\treturn 0;\n}\n\n \n\nstatic void __ei_tx_timeout(struct net_device *dev, unsigned int txqueue)\n{\n\tunsigned long e8390_base = dev->base_addr;\n\tstruct ei_device *ei_local = netdev_priv(dev);\n\tint txsr, isr, tickssofar = jiffies - dev_trans_start(dev);\n\tunsigned long flags;\n\n\tdev->stats.tx_errors++;\n\n\tspin_lock_irqsave(&ei_local->page_lock, flags);\n\ttxsr = ei_inb(e8390_base+EN0_TSR);\n\tisr = ei_inb(e8390_base+EN0_ISR);\n\tspin_unlock_irqrestore(&ei_local->page_lock, flags);\n\n\tnetdev_dbg(dev, \"Tx timed out, %s TSR=%#2x, ISR=%#2x, t=%d\\n\",\n\t\t   (txsr & ENTSR_ABT) ? \"excess collisions.\" :\n\t\t   (isr) ? \"lost interrupt?\" : \"cable problem?\",\n\t\t   txsr, isr, tickssofar);\n\n\tif (!isr && !dev->stats.tx_packets) {\n\t\t \n\t\tei_local->interface_num ^= 1;    \n\t}\n\n\t \n\n\tdisable_irq_nosync_lockdep(dev->irq);\n\tspin_lock(&ei_local->page_lock);\n\n\t \n\tei_reset_8390(dev);\n\t__NS8390_init(dev, 1);\n\n\tspin_unlock(&ei_local->page_lock);\n\tenable_irq_lockdep(dev->irq);\n\tnetif_wake_queue(dev);\n}\n\n \n\nstatic netdev_tx_t __ei_start_xmit(struct sk_buff *skb,\n\t\t\t\t   struct net_device *dev)\n{\n\tunsigned long e8390_base = dev->base_addr;\n\tstruct ei_device *ei_local = netdev_priv(dev);\n\tint send_length = skb->len, output_page;\n\tunsigned long flags;\n\tchar buf[ETH_ZLEN];\n\tchar *data = skb->data;\n\n\tif (skb->len < ETH_ZLEN) {\n\t\tmemset(buf, 0, ETH_ZLEN);\t \n\t\tmemcpy(buf, data, skb->len);\n\t\tsend_length = ETH_ZLEN;\n\t\tdata = buf;\n\t}\n\n\t \n\n\tspin_lock_irqsave(&ei_local->page_lock, flags);\n\tei_outb_p(0x00, e8390_base + EN0_IMR);\n\tspin_unlock_irqrestore(&ei_local->page_lock, flags);\n\n\n\t \n\n\tdisable_irq_nosync_lockdep_irqsave(dev->irq, &flags);\n\n\tspin_lock(&ei_local->page_lock);\n\n\tei_local->irqlock = 1;\n\n\t \n\n\tif (ei_local->tx1 == 0) {\n\t\toutput_page = ei_local->tx_start_page;\n\t\tei_local->tx1 = send_length;\n\t\tif ((netif_msg_tx_queued(ei_local)) &&\n\t\t    ei_local->tx2 > 0)\n\t\t\tnetdev_dbg(dev,\n\t\t\t\t   \"idle transmitter tx2=%d, lasttx=%d, txing=%d\\n\",\n\t\t\t\t   ei_local->tx2, ei_local->lasttx, ei_local->txing);\n\t} else if (ei_local->tx2 == 0) {\n\t\toutput_page = ei_local->tx_start_page + TX_PAGES/2;\n\t\tei_local->tx2 = send_length;\n\t\tif ((netif_msg_tx_queued(ei_local)) &&\n\t\t    ei_local->tx1 > 0)\n\t\t\tnetdev_dbg(dev,\n\t\t\t\t   \"idle transmitter, tx1=%d, lasttx=%d, txing=%d\\n\",\n\t\t\t\t   ei_local->tx1, ei_local->lasttx, ei_local->txing);\n\t} else {\t\t\t \n\t\tnetif_dbg(ei_local, tx_err, dev,\n\t\t\t  \"No Tx buffers free! tx1=%d tx2=%d last=%d\\n\",\n\t\t\t  ei_local->tx1, ei_local->tx2, ei_local->lasttx);\n\t\tei_local->irqlock = 0;\n\t\tnetif_stop_queue(dev);\n\t\tei_outb_p(ENISR_ALL, e8390_base + EN0_IMR);\n\t\tspin_unlock(&ei_local->page_lock);\n\t\tenable_irq_lockdep_irqrestore(dev->irq, &flags);\n\t\tdev->stats.tx_errors++;\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\n\t \n\n\tei_block_output(dev, send_length, data, output_page);\n\n\tif (!ei_local->txing) {\n\t\tei_local->txing = 1;\n\t\tNS8390_trigger_send(dev, send_length, output_page);\n\t\tif (output_page == ei_local->tx_start_page) {\n\t\t\tei_local->tx1 = -1;\n\t\t\tei_local->lasttx = -1;\n\t\t} else {\n\t\t\tei_local->tx2 = -1;\n\t\t\tei_local->lasttx = -2;\n\t\t}\n\t} else\n\t\tei_local->txqueue++;\n\n\tif (ei_local->tx1 && ei_local->tx2)\n\t\tnetif_stop_queue(dev);\n\telse\n\t\tnetif_start_queue(dev);\n\n\t \n\tei_local->irqlock = 0;\n\tei_outb_p(ENISR_ALL, e8390_base + EN0_IMR);\n\n\tspin_unlock(&ei_local->page_lock);\n\tenable_irq_lockdep_irqrestore(dev->irq, &flags);\n\tskb_tx_timestamp(skb);\n\tdev_consume_skb_any(skb);\n\tdev->stats.tx_bytes += send_length;\n\n\treturn NETDEV_TX_OK;\n}\n\n \n\nstatic irqreturn_t __ei_interrupt(int irq, void *dev_id)\n{\n\tstruct net_device *dev = dev_id;\n\tunsigned long e8390_base = dev->base_addr;\n\tint interrupts, nr_serviced = 0;\n\tstruct ei_device *ei_local = netdev_priv(dev);\n\n\t \n\n\tspin_lock(&ei_local->page_lock);\n\n\tif (ei_local->irqlock) {\n\t\t \n\t\tnetdev_err(dev, \"Interrupted while interrupts are masked! isr=%#2x imr=%#2x\\n\",\n\t\t\t   ei_inb_p(e8390_base + EN0_ISR),\n\t\t\t   ei_inb_p(e8390_base + EN0_IMR));\n\t\tspin_unlock(&ei_local->page_lock);\n\t\treturn IRQ_NONE;\n\t}\n\n\t \n\tei_outb_p(E8390_NODMA+E8390_PAGE0, e8390_base + E8390_CMD);\n\tnetif_dbg(ei_local, intr, dev, \"interrupt(isr=%#2.2x)\\n\",\n\t\t  ei_inb_p(e8390_base + EN0_ISR));\n\n\t \n\twhile ((interrupts = ei_inb_p(e8390_base + EN0_ISR)) != 0 &&\n\t       ++nr_serviced < MAX_SERVICE) {\n\t\tif (!netif_running(dev)) {\n\t\t\tnetdev_warn(dev, \"interrupt from stopped card\\n\");\n\t\t\t \n\t\t\tei_outb_p(interrupts, e8390_base + EN0_ISR);\n\t\t\tinterrupts = 0;\n\t\t\tbreak;\n\t\t}\n\t\tif (interrupts & ENISR_OVER)\n\t\t\tei_rx_overrun(dev);\n\t\telse if (interrupts & (ENISR_RX+ENISR_RX_ERR)) {\n\t\t\t \n\t\t\tei_receive(dev);\n\t\t}\n\t\t \n\t\tif (interrupts & ENISR_TX)\n\t\t\tei_tx_intr(dev);\n\t\telse if (interrupts & ENISR_TX_ERR)\n\t\t\tei_tx_err(dev);\n\n\t\tif (interrupts & ENISR_COUNTERS) {\n\t\t\tdev->stats.rx_frame_errors += ei_inb_p(e8390_base + EN0_COUNTER0);\n\t\t\tdev->stats.rx_crc_errors   += ei_inb_p(e8390_base + EN0_COUNTER1);\n\t\t\tdev->stats.rx_missed_errors += ei_inb_p(e8390_base + EN0_COUNTER2);\n\t\t\tei_outb_p(ENISR_COUNTERS, e8390_base + EN0_ISR);  \n\t\t}\n\n\t\t \n\t\tif (interrupts & ENISR_RDC)\n\t\t\tei_outb_p(ENISR_RDC, e8390_base + EN0_ISR);\n\n\t\tei_outb_p(E8390_NODMA+E8390_PAGE0+E8390_START, e8390_base + E8390_CMD);\n\t}\n\n\tif (interrupts && (netif_msg_intr(ei_local))) {\n\t\tei_outb_p(E8390_NODMA+E8390_PAGE0+E8390_START, e8390_base + E8390_CMD);\n\t\tif (nr_serviced >= MAX_SERVICE) {\n\t\t\t \n\t\t\tif (interrupts != 0xFF)\n\t\t\t\tnetdev_warn(dev, \"Too much work at interrupt, status %#2.2x\\n\",\n\t\t\t\t\t    interrupts);\n\t\t\tei_outb_p(ENISR_ALL, e8390_base + EN0_ISR);  \n\t\t} else {\n\t\t\tnetdev_warn(dev, \"unknown interrupt %#2x\\n\", interrupts);\n\t\t\tei_outb_p(0xff, e8390_base + EN0_ISR);  \n\t\t}\n\t}\n\tspin_unlock(&ei_local->page_lock);\n\treturn IRQ_RETVAL(nr_serviced > 0);\n}\n\n#ifdef CONFIG_NET_POLL_CONTROLLER\nstatic void __ei_poll(struct net_device *dev)\n{\n\tdisable_irq(dev->irq);\n\t__ei_interrupt(dev->irq, dev);\n\tenable_irq(dev->irq);\n}\n#endif\n\n \n\nstatic void ei_tx_err(struct net_device *dev)\n{\n\tunsigned long e8390_base = dev->base_addr;\n\t \n\tstruct ei_device *ei_local __maybe_unused = netdev_priv(dev);\n\tunsigned char txsr = ei_inb_p(e8390_base+EN0_TSR);\n\tunsigned char tx_was_aborted = txsr & (ENTSR_ABT+ENTSR_FU);\n\n#ifdef VERBOSE_ERROR_DUMP\n\tnetdev_dbg(dev, \"transmitter error (%#2x):\", txsr);\n\tif (txsr & ENTSR_ABT)\n\t\tpr_cont(\" excess-collisions \");\n\tif (txsr & ENTSR_ND)\n\t\tpr_cont(\" non-deferral \");\n\tif (txsr & ENTSR_CRS)\n\t\tpr_cont(\" lost-carrier \");\n\tif (txsr & ENTSR_FU)\n\t\tpr_cont(\" FIFO-underrun \");\n\tif (txsr & ENTSR_CDH)\n\t\tpr_cont(\" lost-heartbeat \");\n\tpr_cont(\"\\n\");\n#endif\n\n\tei_outb_p(ENISR_TX_ERR, e8390_base + EN0_ISR);  \n\n\tif (tx_was_aborted)\n\t\tei_tx_intr(dev);\n\telse {\n\t\tdev->stats.tx_errors++;\n\t\tif (txsr & ENTSR_CRS)\n\t\t\tdev->stats.tx_carrier_errors++;\n\t\tif (txsr & ENTSR_CDH)\n\t\t\tdev->stats.tx_heartbeat_errors++;\n\t\tif (txsr & ENTSR_OWC)\n\t\t\tdev->stats.tx_window_errors++;\n\t}\n}\n\n \n\nstatic void ei_tx_intr(struct net_device *dev)\n{\n\tunsigned long e8390_base = dev->base_addr;\n\tstruct ei_device *ei_local = netdev_priv(dev);\n\tint status = ei_inb(e8390_base + EN0_TSR);\n\n\tei_outb_p(ENISR_TX, e8390_base + EN0_ISR);  \n\n\t \n\tei_local->txqueue--;\n\n\tif (ei_local->tx1 < 0) {\n\t\tif (ei_local->lasttx != 1 && ei_local->lasttx != -1)\n\t\t\tpr_err(\"%s: bogus last_tx_buffer %d, tx1=%d\\n\",\n\t\t\t       ei_local->name, ei_local->lasttx, ei_local->tx1);\n\t\tei_local->tx1 = 0;\n\t\tif (ei_local->tx2 > 0) {\n\t\t\tei_local->txing = 1;\n\t\t\tNS8390_trigger_send(dev, ei_local->tx2, ei_local->tx_start_page + 6);\n\t\t\tnetif_trans_update(dev);\n\t\t\tei_local->tx2 = -1;\n\t\t\tei_local->lasttx = 2;\n\t\t} else {\n\t\t\tei_local->lasttx = 20;\n\t\t\tei_local->txing = 0;\n\t\t}\n\t} else if (ei_local->tx2 < 0) {\n\t\tif (ei_local->lasttx != 2  &&  ei_local->lasttx != -2)\n\t\t\tpr_err(\"%s: bogus last_tx_buffer %d, tx2=%d\\n\",\n\t\t\t       ei_local->name, ei_local->lasttx, ei_local->tx2);\n\t\tei_local->tx2 = 0;\n\t\tif (ei_local->tx1 > 0) {\n\t\t\tei_local->txing = 1;\n\t\t\tNS8390_trigger_send(dev, ei_local->tx1, ei_local->tx_start_page);\n\t\t\tnetif_trans_update(dev);\n\t\t\tei_local->tx1 = -1;\n\t\t\tei_local->lasttx = 1;\n\t\t} else {\n\t\t\tei_local->lasttx = 10;\n\t\t\tei_local->txing = 0;\n\t\t}\n\t}  \n\n\t \n\tif (status & ENTSR_COL)\n\t\tdev->stats.collisions++;\n\tif (status & ENTSR_PTX)\n\t\tdev->stats.tx_packets++;\n\telse {\n\t\tdev->stats.tx_errors++;\n\t\tif (status & ENTSR_ABT) {\n\t\t\tdev->stats.tx_aborted_errors++;\n\t\t\tdev->stats.collisions += 16;\n\t\t}\n\t\tif (status & ENTSR_CRS)\n\t\t\tdev->stats.tx_carrier_errors++;\n\t\tif (status & ENTSR_FU)\n\t\t\tdev->stats.tx_fifo_errors++;\n\t\tif (status & ENTSR_CDH)\n\t\t\tdev->stats.tx_heartbeat_errors++;\n\t\tif (status & ENTSR_OWC)\n\t\t\tdev->stats.tx_window_errors++;\n\t}\n\tnetif_wake_queue(dev);\n}\n\n \n\nstatic void ei_receive(struct net_device *dev)\n{\n\tunsigned long e8390_base = dev->base_addr;\n\tstruct ei_device *ei_local = netdev_priv(dev);\n\tunsigned char rxing_page, this_frame, next_frame;\n\tunsigned short current_offset;\n\tint rx_pkt_count = 0;\n\tstruct e8390_pkt_hdr rx_frame;\n\tint num_rx_pages = ei_local->stop_page-ei_local->rx_start_page;\n\n\twhile (++rx_pkt_count < 10) {\n\t\tint pkt_len, pkt_stat;\n\n\t\t \n\t\tei_outb_p(E8390_NODMA+E8390_PAGE1, e8390_base + E8390_CMD);\n\t\trxing_page = ei_inb_p(e8390_base + EN1_CURPAG);\n\t\tei_outb_p(E8390_NODMA+E8390_PAGE0, e8390_base + E8390_CMD);\n\n\t\t \n\t\tthis_frame = ei_inb_p(e8390_base + EN0_BOUNDARY) + 1;\n\t\tif (this_frame >= ei_local->stop_page)\n\t\t\tthis_frame = ei_local->rx_start_page;\n\n\t\t \n\t\tif ((netif_msg_rx_status(ei_local)) &&\n\t\t    this_frame != ei_local->current_page &&\n\t\t    (this_frame != 0x0 || rxing_page != 0xFF))\n\t\t\tnetdev_err(dev,\n\t\t\t\t   \"mismatched read page pointers %2x vs %2x\\n\",\n\t\t\t\t   this_frame, ei_local->current_page);\n\n\t\tif (this_frame == rxing_page)\t \n\t\t\tbreak;\t\t\t\t \n\n\t\tcurrent_offset = this_frame << 8;\n\t\tei_get_8390_hdr(dev, &rx_frame, this_frame);\n\n\t\tpkt_len = rx_frame.count - sizeof(struct e8390_pkt_hdr);\n\t\tpkt_stat = rx_frame.status;\n\n\t\tnext_frame = this_frame + 1 + ((pkt_len+4)>>8);\n\n\t\t \n\t\tif (rx_frame.next != next_frame &&\n\t\t    rx_frame.next != next_frame + 1 &&\n\t\t    rx_frame.next != next_frame - num_rx_pages &&\n\t\t    rx_frame.next != next_frame + 1 - num_rx_pages) {\n\t\t\tei_local->current_page = rxing_page;\n\t\t\tei_outb(ei_local->current_page-1, e8390_base+EN0_BOUNDARY);\n\t\t\tdev->stats.rx_errors++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (pkt_len < 60  ||  pkt_len > 1518) {\n\t\t\tnetif_dbg(ei_local, rx_status, dev,\n\t\t\t\t  \"bogus packet size: %d, status=%#2x nxpg=%#2x\\n\",\n\t\t\t\t  rx_frame.count, rx_frame.status,\n\t\t\t\t  rx_frame.next);\n\t\t\tdev->stats.rx_errors++;\n\t\t\tdev->stats.rx_length_errors++;\n\t\t} else if ((pkt_stat & 0x0F) == ENRSR_RXOK) {\n\t\t\tstruct sk_buff *skb;\n\n\t\t\tskb = netdev_alloc_skb(dev, pkt_len + 2);\n\t\t\tif (skb == NULL) {\n\t\t\t\tnetif_err(ei_local, rx_err, dev,\n\t\t\t\t\t  \"Couldn't allocate a sk_buff of size %d\\n\",\n\t\t\t\t\t  pkt_len);\n\t\t\t\tdev->stats.rx_dropped++;\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tskb_reserve(skb, 2);\t \n\t\t\t\tskb_put(skb, pkt_len);\t \n\t\t\t\tei_block_input(dev, pkt_len, skb, current_offset + sizeof(rx_frame));\n\t\t\t\tskb->protocol = eth_type_trans(skb, dev);\n\t\t\t\tif (!skb_defer_rx_timestamp(skb))\n\t\t\t\t\tnetif_rx(skb);\n\t\t\t\tdev->stats.rx_packets++;\n\t\t\t\tdev->stats.rx_bytes += pkt_len;\n\t\t\t\tif (pkt_stat & ENRSR_PHY)\n\t\t\t\t\tdev->stats.multicast++;\n\t\t\t}\n\t\t} else {\n\t\t\tnetif_err(ei_local, rx_err, dev,\n\t\t\t\t  \"bogus packet: status=%#2x nxpg=%#2x size=%d\\n\",\n\t\t\t\t  rx_frame.status, rx_frame.next,\n\t\t\t\t  rx_frame.count);\n\t\t\tdev->stats.rx_errors++;\n\t\t\t \n\t\t\tif (pkt_stat & ENRSR_FO)\n\t\t\t\tdev->stats.rx_fifo_errors++;\n\t\t}\n\t\tnext_frame = rx_frame.next;\n\n\t\t \n\t\tif (next_frame >= ei_local->stop_page) {\n\t\t\tnetdev_notice(dev, \"next frame inconsistency, %#2x\\n\",\n\t\t\t\t      next_frame);\n\t\t\tnext_frame = ei_local->rx_start_page;\n\t\t}\n\t\tei_local->current_page = next_frame;\n\t\tei_outb_p(next_frame-1, e8390_base+EN0_BOUNDARY);\n\t}\n\n\t \n\tei_outb_p(ENISR_RX+ENISR_RX_ERR, e8390_base+EN0_ISR);\n}\n\n \n\nstatic void ei_rx_overrun(struct net_device *dev)\n{\n\tunsigned long e8390_base = dev->base_addr;\n\tunsigned char was_txing, must_resend = 0;\n\t \n\tstruct ei_device *ei_local __maybe_unused = netdev_priv(dev);\n\n\t \n\twas_txing = ei_inb_p(e8390_base+E8390_CMD) & E8390_TRANS;\n\tei_outb_p(E8390_NODMA+E8390_PAGE0+E8390_STOP, e8390_base+E8390_CMD);\n\n\tnetif_dbg(ei_local, rx_err, dev, \"Receiver overrun\\n\");\n\tdev->stats.rx_over_errors++;\n\n\t \n\n\tmdelay(10);\n\n\t \n\tei_outb_p(0x00, e8390_base+EN0_RCNTLO);\n\tei_outb_p(0x00, e8390_base+EN0_RCNTHI);\n\n\t \n\n\tif (was_txing) {\n\t\tunsigned char tx_completed = ei_inb_p(e8390_base+EN0_ISR) & (ENISR_TX+ENISR_TX_ERR);\n\t\tif (!tx_completed)\n\t\t\tmust_resend = 1;\n\t}\n\n\t \n\tei_outb_p(E8390_TXOFF, e8390_base + EN0_TXCR);\n\tei_outb_p(E8390_NODMA + E8390_PAGE0 + E8390_START, e8390_base + E8390_CMD);\n\n\t \n\tei_receive(dev);\n\tei_outb_p(ENISR_OVER, e8390_base+EN0_ISR);\n\n\t \n\tei_outb_p(E8390_TXCONFIG, e8390_base + EN0_TXCR);\n\tif (must_resend)\n\t\tei_outb_p(E8390_NODMA + E8390_PAGE0 + E8390_START + E8390_TRANS, e8390_base + E8390_CMD);\n}\n\n \n\nstatic struct net_device_stats *__ei_get_stats(struct net_device *dev)\n{\n\tunsigned long ioaddr = dev->base_addr;\n\tstruct ei_device *ei_local = netdev_priv(dev);\n\tunsigned long flags;\n\n\t \n\tif (!netif_running(dev))\n\t\treturn &dev->stats;\n\n\tspin_lock_irqsave(&ei_local->page_lock, flags);\n\t \n\tdev->stats.rx_frame_errors  += ei_inb_p(ioaddr + EN0_COUNTER0);\n\tdev->stats.rx_crc_errors    += ei_inb_p(ioaddr + EN0_COUNTER1);\n\tdev->stats.rx_missed_errors += ei_inb_p(ioaddr + EN0_COUNTER2);\n\tspin_unlock_irqrestore(&ei_local->page_lock, flags);\n\n\treturn &dev->stats;\n}\n\n \n\nstatic inline void make_mc_bits(u8 *bits, struct net_device *dev)\n{\n\tstruct netdev_hw_addr *ha;\n\n\tnetdev_for_each_mc_addr(ha, dev) {\n\t\tu32 crc = ether_crc(ETH_ALEN, ha->addr);\n\t\t \n\t\tbits[crc>>29] |= (1<<((crc>>26)&7));\n\t}\n}\n\n \n\nstatic void do_set_multicast_list(struct net_device *dev)\n{\n\tunsigned long e8390_base = dev->base_addr;\n\tint i;\n\tstruct ei_device *ei_local = netdev_priv(dev);\n\n\tif (!(dev->flags&(IFF_PROMISC|IFF_ALLMULTI))) {\n\t\tmemset(ei_local->mcfilter, 0, 8);\n\t\tif (!netdev_mc_empty(dev))\n\t\t\tmake_mc_bits(ei_local->mcfilter, dev);\n\t} else\n\t\tmemset(ei_local->mcfilter, 0xFF, 8);\t \n\n\t \n\n\tif (netif_running(dev))\n\t\tei_outb_p(E8390_RXCONFIG, e8390_base + EN0_RXCR);\n\tei_outb_p(E8390_NODMA + E8390_PAGE1, e8390_base + E8390_CMD);\n\tfor (i = 0; i < 8; i++) {\n\t\tei_outb_p(ei_local->mcfilter[i], e8390_base + EN1_MULT_SHIFT(i));\n#ifndef BUG_83C690\n\t\tif (ei_inb_p(e8390_base + EN1_MULT_SHIFT(i)) != ei_local->mcfilter[i])\n\t\t\tnetdev_err(dev, \"Multicast filter read/write mismap %d\\n\",\n\t\t\t\t   i);\n#endif\n\t}\n\tei_outb_p(E8390_NODMA + E8390_PAGE0, e8390_base + E8390_CMD);\n\n\tif (dev->flags&IFF_PROMISC)\n\t\tei_outb_p(E8390_RXCONFIG | 0x18, e8390_base + EN0_RXCR);\n\telse if (dev->flags & IFF_ALLMULTI || !netdev_mc_empty(dev))\n\t\tei_outb_p(E8390_RXCONFIG | 0x08, e8390_base + EN0_RXCR);\n\telse\n\t\tei_outb_p(E8390_RXCONFIG, e8390_base + EN0_RXCR);\n}\n\n \n\nstatic void __ei_set_multicast_list(struct net_device *dev)\n{\n\tunsigned long flags;\n\tstruct ei_device *ei_local = netdev_priv(dev);\n\n\tspin_lock_irqsave(&ei_local->page_lock, flags);\n\tdo_set_multicast_list(dev);\n\tspin_unlock_irqrestore(&ei_local->page_lock, flags);\n}\n\n \n\nstatic void ethdev_setup(struct net_device *dev)\n{\n\tstruct ei_device *ei_local = netdev_priv(dev);\n\n\tether_setup(dev);\n\n\tspin_lock_init(&ei_local->page_lock);\n\n\tei_local->msg_enable = netif_msg_init(msg_enable, default_msg_level);\n\n\tif (netif_msg_drv(ei_local) && (version_printed++ == 0))\n\t\tpr_info(\"%s\", version);\n}\n\n \nstatic struct net_device *____alloc_ei_netdev(int size)\n{\n\treturn alloc_netdev(sizeof(struct ei_device) + size, \"eth%d\",\n\t\t\t    NET_NAME_UNKNOWN, ethdev_setup);\n}\n\n\n\n\n \n \n\n \n\nstatic void __NS8390_init(struct net_device *dev, int startp)\n{\n\tunsigned long e8390_base = dev->base_addr;\n\tstruct ei_device *ei_local = netdev_priv(dev);\n\tint i;\n\tint endcfg = ei_local->word16\n\t    ? (0x48 | ENDCFG_WTS | (ei_local->bigendian ? ENDCFG_BOS : 0))\n\t    : 0x48;\n\n\tBUILD_BUG_ON(sizeof(struct e8390_pkt_hdr) != 4);\n\t \n\tei_outb_p(E8390_NODMA+E8390_PAGE0+E8390_STOP, e8390_base+E8390_CMD);  \n\tei_outb_p(endcfg, e8390_base + EN0_DCFG);\t \n\t \n\tei_outb_p(0x00,  e8390_base + EN0_RCNTLO);\n\tei_outb_p(0x00,  e8390_base + EN0_RCNTHI);\n\t \n\tei_outb_p(E8390_RXOFF, e8390_base + EN0_RXCR);  \n\tei_outb_p(E8390_TXOFF, e8390_base + EN0_TXCR);  \n\t \n\tei_outb_p(ei_local->tx_start_page, e8390_base + EN0_TPSR);\n\tei_local->tx1 = ei_local->tx2 = 0;\n\tei_outb_p(ei_local->rx_start_page, e8390_base + EN0_STARTPG);\n\tei_outb_p(ei_local->stop_page-1, e8390_base + EN0_BOUNDARY);\t \n\tei_local->current_page = ei_local->rx_start_page;\t\t \n\tei_outb_p(ei_local->stop_page, e8390_base + EN0_STOPPG);\n\t \n\tei_outb_p(0xFF, e8390_base + EN0_ISR);\n\tei_outb_p(0x00,  e8390_base + EN0_IMR);\n\n\t \n\n\tei_outb_p(E8390_NODMA + E8390_PAGE1 + E8390_STOP, e8390_base+E8390_CMD);  \n\tfor (i = 0; i < 6; i++) {\n\t\tei_outb_p(dev->dev_addr[i], e8390_base + EN1_PHYS_SHIFT(i));\n\t\tif ((netif_msg_probe(ei_local)) &&\n\t\t    ei_inb_p(e8390_base + EN1_PHYS_SHIFT(i)) != dev->dev_addr[i])\n\t\t\tnetdev_err(dev,\n\t\t\t\t   \"Hw. address read/write mismap %d\\n\", i);\n\t}\n\n\tei_outb_p(ei_local->rx_start_page, e8390_base + EN1_CURPAG);\n\tei_outb_p(E8390_NODMA+E8390_PAGE0+E8390_STOP, e8390_base+E8390_CMD);\n\n\tei_local->tx1 = ei_local->tx2 = 0;\n\tei_local->txing = 0;\n\n\tif (startp) {\n\t\tei_outb_p(0xff,  e8390_base + EN0_ISR);\n\t\tei_outb_p(ENISR_ALL,  e8390_base + EN0_IMR);\n\t\tei_outb_p(E8390_NODMA+E8390_PAGE0+E8390_START, e8390_base+E8390_CMD);\n\t\tei_outb_p(E8390_TXCONFIG, e8390_base + EN0_TXCR);  \n\t\t \n\t\tei_outb_p(E8390_RXCONFIG, e8390_base + EN0_RXCR);  \n\t\tdo_set_multicast_list(dev);\t \n\t}\n}\n\n \n\nstatic void NS8390_trigger_send(struct net_device *dev, unsigned int length,\n\t\t\t\t\t\t\t\tint start_page)\n{\n\tunsigned long e8390_base = dev->base_addr;\n\tstruct ei_device *ei_local __attribute((unused)) = netdev_priv(dev);\n\n\tei_outb_p(E8390_NODMA+E8390_PAGE0, e8390_base+E8390_CMD);\n\n\tif (ei_inb_p(e8390_base + E8390_CMD) & E8390_TRANS) {\n\t\tnetdev_warn(dev, \"trigger_send() called with the transmitter busy\\n\");\n\t\treturn;\n\t}\n\tei_outb_p(length & 0xff, e8390_base + EN0_TCNTLO);\n\tei_outb_p(length >> 8, e8390_base + EN0_TCNTHI);\n\tei_outb_p(start_page, e8390_base + EN0_TPSR);\n\tei_outb_p(E8390_NODMA+E8390_TRANS+E8390_START, e8390_base+E8390_CMD);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}