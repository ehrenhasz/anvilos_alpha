{
  "module_name": "8390.h",
  "hash_id": "4362d33771e4b996a352b349e27455fd6703bef74abf4804a0528aae4f6f6c41",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/8390/8390.h",
  "human_readable_source": " \n\n \n\n \n\n#ifndef _8390_h\n#define _8390_h\n\n#include <linux/if_ether.h>\n#include <linux/ioport.h>\n#include <linux/irqreturn.h>\n#include <linux/skbuff.h>\n\n#define TX_PAGES 12\t \n\n \nstruct e8390_pkt_hdr {\n\tunsigned char status;  \n\tunsigned char next;    \n\tunsigned short count;  \n};\n\n#ifdef CONFIG_NET_POLL_CONTROLLER\nvoid ei_poll(struct net_device *dev);\nvoid eip_poll(struct net_device *dev);\n#endif\n\n\n \nvoid NS8390_init(struct net_device *dev, int startp);\nint ei_open(struct net_device *dev);\nint ei_close(struct net_device *dev);\nirqreturn_t ei_interrupt(int irq, void *dev_id);\nvoid ei_tx_timeout(struct net_device *dev, unsigned int txqueue);\nnetdev_tx_t ei_start_xmit(struct sk_buff *skb, struct net_device *dev);\nvoid ei_set_multicast_list(struct net_device *dev);\nstruct net_device_stats *ei_get_stats(struct net_device *dev);\n\nextern const struct net_device_ops ei_netdev_ops;\n\nstruct net_device *__alloc_ei_netdev(int size);\nstatic inline struct net_device *alloc_ei_netdev(void)\n{\n\treturn __alloc_ei_netdev(0);\n}\n\n \nvoid NS8390p_init(struct net_device *dev, int startp);\nint eip_open(struct net_device *dev);\nint eip_close(struct net_device *dev);\nirqreturn_t eip_interrupt(int irq, void *dev_id);\nvoid eip_tx_timeout(struct net_device *dev, unsigned int txqueue);\nnetdev_tx_t eip_start_xmit(struct sk_buff *skb, struct net_device *dev);\nvoid eip_set_multicast_list(struct net_device *dev);\nstruct net_device_stats *eip_get_stats(struct net_device *dev);\n\nextern const struct net_device_ops eip_netdev_ops;\n\nstruct net_device *__alloc_eip_netdev(int size);\nstatic inline struct net_device *alloc_eip_netdev(void)\n{\n\treturn __alloc_eip_netdev(0);\n}\n\n \nstruct ei_device {\n\tconst char *name;\n\tvoid (*reset_8390)(struct net_device *dev);\n\tvoid (*get_8390_hdr)(struct net_device *dev,\n\t\t\t     struct e8390_pkt_hdr *hdr, int ring_page);\n\tvoid (*block_output)(struct net_device *dev, int count,\n\t\t\t     const unsigned char *buf, int start_page);\n\tvoid (*block_input)(struct net_device *dev, int count,\n\t\t\t    struct sk_buff *skb, int ring_offset);\n\tunsigned long rmem_start;\n\tunsigned long rmem_end;\n\tvoid __iomem *mem;\n\tunsigned char mcfilter[8];\n\tunsigned open:1;\n\tunsigned word16:1;\t\t \n\tunsigned bigendian:1;\t\t \n\tunsigned txing:1;\t\t \n\tunsigned irqlock:1;\t\t \n\tunsigned dmaing:1;\t\t \n\tunsigned char tx_start_page, rx_start_page, stop_page;\n\tunsigned char current_page;\t \n\tunsigned char interface_num;\t \n\tunsigned char txqueue;\t\t \n\tshort tx1, tx2;\t\t\t \n\tshort lasttx;\t\t\t \n\tunsigned char reg0;\t\t \n\tunsigned char reg5;\t\t \n\tunsigned char saved_irq;\t \n\tu32 *reg_offset;\t\t \n\tspinlock_t page_lock;\t\t \n\tunsigned long priv;\t\t \n\tu32 msg_enable;\t\t\t \n#ifdef AX88796_PLATFORM\n\tunsigned char rxcr_base;\t \n#endif\n};\n\n \n#define MAX_SERVICE 12\n\n \n#define TX_TIMEOUT (20*HZ/100)\n\n#define ei_status (*(struct ei_device *)netdev_priv(dev))\n\n \n#define E8390_TX_IRQ_MASK\t0xa\t \n#define E8390_RX_IRQ_MASK\t0x5\n\n#ifdef AX88796_PLATFORM\n#define E8390_RXCONFIG\t\t(ei_status.rxcr_base | 0x04)\n#define E8390_RXOFF\t\t(ei_status.rxcr_base | 0x20)\n#else\n \n#define E8390_RXCONFIG\t\t0x4\n \n#define E8390_RXOFF\t\t0x20\n#endif\n\n \n#define E8390_TXCONFIG\t\t0x00\n \n#define E8390_TXOFF\t\t0x02\n\n\n \n#define E8390_STOP\t0x01\t \n#define E8390_START\t0x02\t \n#define E8390_TRANS\t0x04\t \n#define E8390_RREAD\t0x08\t \n#define E8390_RWRITE\t0x10\t \n#define E8390_NODMA\t0x20\t \n#define E8390_PAGE0\t0x00\t \n#define E8390_PAGE1\t0x40\t \n#define E8390_PAGE2\t0x80\t \n\n \n\n#ifndef ei_inb\n#define ei_inb(_p)\tinb(_p)\n#define ei_outb(_v, _p)\toutb(_v, _p)\n#define ei_inb_p(_p)\tinb(_p)\n#define ei_outb_p(_v, _p) outb(_v, _p)\n#endif\n\n#ifndef EI_SHIFT\n#define EI_SHIFT(x)\t(x)\n#endif\n\n#define E8390_CMD\tEI_SHIFT(0x00)   \n \n#define EN0_CLDALO\tEI_SHIFT(0x01)\t \n#define EN0_STARTPG\tEI_SHIFT(0x01)\t \n#define EN0_CLDAHI\tEI_SHIFT(0x02)\t \n#define EN0_STOPPG\tEI_SHIFT(0x02)\t \n#define EN0_BOUNDARY\tEI_SHIFT(0x03)\t \n#define EN0_TSR\t\tEI_SHIFT(0x04)\t \n#define EN0_TPSR\tEI_SHIFT(0x04)\t \n#define EN0_NCR\t\tEI_SHIFT(0x05)\t \n#define EN0_TCNTLO\tEI_SHIFT(0x05)\t \n#define EN0_FIFO\tEI_SHIFT(0x06)\t \n#define EN0_TCNTHI\tEI_SHIFT(0x06)\t \n#define EN0_ISR\t\tEI_SHIFT(0x07)\t \n#define EN0_CRDALO\tEI_SHIFT(0x08)\t \n#define EN0_RSARLO\tEI_SHIFT(0x08)\t \n#define EN0_CRDAHI\tEI_SHIFT(0x09)\t \n#define EN0_RSARHI\tEI_SHIFT(0x09)\t \n#define EN0_RCNTLO\tEI_SHIFT(0x0a)\t \n#define EN0_RCNTHI\tEI_SHIFT(0x0b)\t \n#define EN0_RSR\t\tEI_SHIFT(0x0c)\t \n#define EN0_RXCR\tEI_SHIFT(0x0c)\t \n#define EN0_TXCR\tEI_SHIFT(0x0d)\t \n#define EN0_COUNTER0\tEI_SHIFT(0x0d)\t \n#define EN0_DCFG\tEI_SHIFT(0x0e)\t \n#define EN0_COUNTER1\tEI_SHIFT(0x0e)\t \n#define EN0_IMR\t\tEI_SHIFT(0x0f)\t \n#define EN0_COUNTER2\tEI_SHIFT(0x0f)\t \n\n \n#define ENISR_RX\t0x01\t \n#define ENISR_TX\t0x02\t \n#define ENISR_RX_ERR\t0x04\t \n#define ENISR_TX_ERR\t0x08\t \n#define ENISR_OVER\t0x10\t \n#define ENISR_COUNTERS\t0x20\t \n#define ENISR_RDC\t0x40\t \n#define ENISR_RESET\t0x80\t \n#define ENISR_ALL\t0x3f\t \n\n \n#define ENDCFG_WTS\t0x01\t \n#define ENDCFG_BOS\t0x02\t \n\n \n#define EN1_PHYS   EI_SHIFT(0x01)\t \n#define EN1_PHYS_SHIFT(i)  EI_SHIFT(i+1)  \n#define EN1_CURPAG EI_SHIFT(0x07)\t \n#define EN1_MULT   EI_SHIFT(0x08)\t \n#define EN1_MULT_SHIFT(i)  EI_SHIFT(8+i)  \n\n \n#define ENRSR_RXOK\t0x01\t \n#define ENRSR_CRC\t0x02\t \n#define ENRSR_FAE\t0x04\t \n#define ENRSR_FO\t0x08\t \n#define ENRSR_MPA\t0x10\t \n#define ENRSR_PHY\t0x20\t \n#define ENRSR_DIS\t0x40\t \n#define ENRSR_DEF\t0x80\t \n\n \n#define ENTSR_PTX 0x01\t \n#define ENTSR_ND  0x02\t \n#define ENTSR_COL 0x04\t \n#define ENTSR_ABT 0x08   \n#define ENTSR_CRS 0x10\t \n#define ENTSR_FU  0x20   \n#define ENTSR_CDH 0x40\t \n#define ENTSR_OWC 0x80   \n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}