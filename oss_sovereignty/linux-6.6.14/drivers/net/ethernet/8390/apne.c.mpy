{
  "module_name": "apne.c",
  "hash_id": "e149a9ca00c91f398010872e8daf09ddbd60b0e42f5b4ec008d6419b58e91b47",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/8390/apne.c",
  "human_readable_source": "\n \n\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/pci.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/interrupt.h>\n#include <linux/jiffies.h>\n\n#include <asm/io.h>\n#include <asm/setup.h>\n#include <asm/amigaints.h>\n#include <asm/amigahw.h>\n#include <asm/amigayle.h>\n#include <asm/amipcmcia.h>\n\n#include \"8390.h\"\n\n \n\n#define DRV_NAME \"apne\"\n\n#define NE_BASE\t (dev->base_addr)\n#define NE_CMD\t \t\t0x00\n#define NE_DATAPORT\t\t0x10             \n#define NE_RESET\t\t0x1f             \n#define NE_IO_EXTENT\t        0x20\n\n#define NE_EN0_ISR\t\t0x07\n#define NE_EN0_DCFG\t\t0x0e\n\n#define NE_EN0_RSARLO\t        0x08\n#define NE_EN0_RSARHI\t        0x09\n#define NE_EN0_RCNTLO\t        0x0a\n#define NE_EN0_RXCR\t\t0x0c\n#define NE_EN0_TXCR\t\t0x0d\n#define NE_EN0_RCNTHI\t        0x0b\n#define NE_EN0_IMR\t\t0x0f\n\n#define NE1SM_START_PG\t0x20\t \n#define NE1SM_STOP_PG \t0x40\t \n#define NESM_START_PG\t0x40\t \n#define NESM_STOP_PG\t0x80\t \n\n\nstatic int apne_probe1(struct net_device *dev, int ioaddr);\n\nstatic void apne_reset_8390(struct net_device *dev);\nstatic void apne_get_8390_hdr(struct net_device *dev, struct e8390_pkt_hdr *hdr,\n\t\t\t  int ring_page);\nstatic void apne_block_input(struct net_device *dev, int count,\n\t\t\t\t\t\t\t\tstruct sk_buff *skb, int ring_offset);\nstatic void apne_block_output(struct net_device *dev, const int count,\n\t\t\t\t\t\t\tconst unsigned char *buf, const int start_page);\nstatic irqreturn_t apne_interrupt(int irq, void *dev_id);\n\nstatic int init_pcmcia(void);\n\n \n\n#define IOBASE 0x300\n\n \n\n \n\nstatic const char version[] =\n    \"apne.c:v1.1 7/10/98 Alain Malek (Alain.Malek@cryogen.ch)\\n\";\n\nstatic int apne_owned;\t \n\nstatic u32 apne_msg_enable;\nmodule_param_named(msg_enable, apne_msg_enable, uint, 0444);\nMODULE_PARM_DESC(msg_enable, \"Debug message level (see linux/netdevice.h for bitmap)\");\n\nstatic struct net_device * __init apne_probe(void)\n{\n\tstruct net_device *dev;\n\tstruct ei_device *ei_local;\n\n#ifndef MANUAL_CONFIG\n\tchar tuple[8];\n#endif\n\tint err;\n\n\tif (!MACH_IS_AMIGA)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tif (apne_owned)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tif ( !(AMIGAHW_PRESENT(PCMCIA)) )\n\t\treturn ERR_PTR(-ENODEV);\n\n\tpr_info(\"Looking for PCMCIA ethernet card : \");\n\n\t \n\tif (!(PCMCIA_INSERTED)) {\n\t\tpr_cont(\"NO PCMCIA card inserted\\n\");\n\t\treturn ERR_PTR(-ENODEV);\n\t}\n\n\tdev = alloc_ei_netdev();\n\tif (!dev)\n\t\treturn ERR_PTR(-ENOMEM);\n\tei_local = netdev_priv(dev);\n\tei_local->msg_enable = apne_msg_enable;\n\n\t \n\tpcmcia_disable_irq();\n\n#ifndef MANUAL_CONFIG\n\tif ((pcmcia_copy_tuple(CISTPL_FUNCID, tuple, 8) < 3) ||\n\t\t(tuple[2] != CISTPL_FUNCID_NETWORK)) {\n\t\tpr_cont(\"not an ethernet card\\n\");\n\t\t \n\t\tfree_netdev(dev);\n\t\treturn ERR_PTR(-ENODEV);\n\t}\n#endif\n\n\tpr_cont(\"ethernet PCMCIA card inserted\\n\");\n\n\tif (!init_pcmcia()) {\n\t\t \n\t\tfree_netdev(dev);\n\t\treturn ERR_PTR(-ENODEV);\n\t}\n\n\tif (!request_region(IOBASE, 0x20, DRV_NAME)) {\n\t\tfree_netdev(dev);\n\t\treturn ERR_PTR(-EBUSY);\n\t}\n\n\terr = apne_probe1(dev, IOBASE);\n\tif (err) {\n\t\trelease_region(IOBASE, 0x20);\n\t\tfree_netdev(dev);\n\t\treturn ERR_PTR(err);\n\t}\n\terr = register_netdev(dev);\n\tif (!err)\n\t\treturn dev;\n\n\tpcmcia_disable_irq();\n\tfree_irq(IRQ_AMIGA_PORTS, dev);\n\tpcmcia_reset();\n\trelease_region(IOBASE, 0x20);\n\tfree_netdev(dev);\n\treturn ERR_PTR(err);\n}\n\nstatic int __init apne_probe1(struct net_device *dev, int ioaddr)\n{\n    int i;\n    unsigned char SA_prom[32];\n    int wordlength = 2;\n    const char *name = NULL;\n    int start_page, stop_page;\n#ifndef MANUAL_HWADDR0\n    int neX000, ctron;\n#endif\n    static unsigned version_printed;\n\n    if ((apne_msg_enable & NETIF_MSG_DRV) && (version_printed++ == 0))\n\t\tnetdev_info(dev, version);\n\n    netdev_info(dev, \"PCMCIA NE*000 ethercard probe\");\n\n     \n    {\tunsigned long reset_start_time = jiffies;\n\n\toutb(inb(ioaddr + NE_RESET), ioaddr + NE_RESET);\n\n\twhile ((inb(ioaddr + NE_EN0_ISR) & ENISR_RESET) == 0)\n\t\tif (time_after(jiffies, reset_start_time + 2*HZ/100)) {\n\t\t\tpr_cont(\" not found (no reset ack).\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\n\toutb(0xff, ioaddr + NE_EN0_ISR);\t\t \n    }\n\n#ifndef MANUAL_HWADDR0\n\n     \n    {\n\tstruct {unsigned long value, offset; } program_seq[] = {\n\t    {E8390_NODMA+E8390_PAGE0+E8390_STOP, NE_CMD},  \n\t    {0x48,\tNE_EN0_DCFG},\t \n\t    {0x00,\tNE_EN0_RCNTLO},\t \n\t    {0x00,\tNE_EN0_RCNTHI},\n\t    {0x00,\tNE_EN0_IMR},\t \n\t    {0xFF,\tNE_EN0_ISR},\n\t    {E8390_RXOFF, NE_EN0_RXCR},\t \n\t    {E8390_TXOFF, NE_EN0_TXCR},\t \n\t    {32,\tNE_EN0_RCNTLO},\n\t    {0x00,\tNE_EN0_RCNTHI},\n\t    {0x00,\tNE_EN0_RSARLO},\t \n\t    {0x00,\tNE_EN0_RSARHI},\n\t    {E8390_RREAD+E8390_START, NE_CMD},\n\t};\n\tfor (i = 0; i < ARRAY_SIZE(program_seq); i++) {\n\t    outb(program_seq[i].value, ioaddr + program_seq[i].offset);\n\t}\n\n    }\n    for(i = 0; i < 32  ; i+=2) {\n\tSA_prom[i] = inb(ioaddr + NE_DATAPORT);\n\tSA_prom[i+1] = inb(ioaddr + NE_DATAPORT);\n\tif (SA_prom[i] != SA_prom[i+1])\n\t    wordlength = 1;\n    }\n\n     \n\n    if (wordlength == 2)\n\tfor (i = 0; i < 16; i++)\n\t\tSA_prom[i] = SA_prom[i+i];\n\n    if (wordlength == 2) {\n\t \n\toutb(0x49, ioaddr + NE_EN0_DCFG);\n\tstart_page = NESM_START_PG;\n\tstop_page = NESM_STOP_PG;\n    } else {\n\tstart_page = NE1SM_START_PG;\n\tstop_page = NE1SM_STOP_PG;\n    }\n\n    neX000 = (SA_prom[14] == 0x57  &&  SA_prom[15] == 0x57);\n    ctron =  (SA_prom[0] == 0x00 && SA_prom[1] == 0x00 && SA_prom[2] == 0x1d);\n\n     \n    if (neX000) {\n\tname = (wordlength == 2) ? \"NE2000\" : \"NE1000\";\n    } else if (ctron) {\n\tname = (wordlength == 2) ? \"Ctron-8\" : \"Ctron-16\";\n\tstart_page = 0x01;\n\tstop_page = (wordlength == 2) ? 0x40 : 0x20;\n    } else {\n\tpr_cont(\" not found.\\n\");\n\treturn -ENXIO;\n\n    }\n\n#else\n    wordlength = 2;\n     \n    outb(0x49, ioaddr + NE_EN0_DCFG);\n    start_page = NESM_START_PG;\n    stop_page = NESM_STOP_PG;\n\n    SA_prom[0] = MANUAL_HWADDR0;\n    SA_prom[1] = MANUAL_HWADDR1;\n    SA_prom[2] = MANUAL_HWADDR2;\n    SA_prom[3] = MANUAL_HWADDR3;\n    SA_prom[4] = MANUAL_HWADDR4;\n    SA_prom[5] = MANUAL_HWADDR5;\n    name = \"NE2000\";\n#endif\n\n    dev->base_addr = ioaddr;\n    dev->irq = IRQ_AMIGA_PORTS;\n    dev->netdev_ops = &ei_netdev_ops;\n\n     \n    i = request_irq(dev->irq, apne_interrupt, IRQF_SHARED, DRV_NAME, dev);\n    if (i) return i;\n\n    eth_hw_addr_set(dev, SA_prom);\n\n    pr_cont(\" %pM\\n\", dev->dev_addr);\n\n    netdev_info(dev, \"%s found.\\n\", name);\n\n    ei_status.name = name;\n    ei_status.tx_start_page = start_page;\n    ei_status.stop_page = stop_page;\n    ei_status.word16 = (wordlength == 2);\n\n    ei_status.rx_start_page = start_page + TX_PAGES;\n\n    ei_status.reset_8390 = &apne_reset_8390;\n    ei_status.block_input = &apne_block_input;\n    ei_status.block_output = &apne_block_output;\n    ei_status.get_8390_hdr = &apne_get_8390_hdr;\n\n    NS8390_init(dev, 0);\n\n    pcmcia_ack_int(pcmcia_get_intreq());\t\t \n    pcmcia_enable_irq();\n\n    apne_owned = 1;\n\n    return 0;\n}\n\n \nstatic void\napne_reset_8390(struct net_device *dev)\n{\n    unsigned long reset_start_time = jiffies;\n    struct ei_device *ei_local = netdev_priv(dev);\n\n    init_pcmcia();\n\n    netif_dbg(ei_local, hw, dev, \"resetting the 8390 t=%ld...\\n\", jiffies);\n\n    outb(inb(NE_BASE + NE_RESET), NE_BASE + NE_RESET);\n\n    ei_status.txing = 0;\n    ei_status.dmaing = 0;\n\n     \n    while ((inb(NE_BASE+NE_EN0_ISR) & ENISR_RESET) == 0)\n\tif (time_after(jiffies, reset_start_time + 2*HZ/100)) {\n\t\tnetdev_err(dev, \"ne_reset_8390() did not complete.\\n\");\n\t\tbreak;\n\t}\n    outb(ENISR_RESET, NE_BASE + NE_EN0_ISR);\t \n}\n\n \n\nstatic void\napne_get_8390_hdr(struct net_device *dev, struct e8390_pkt_hdr *hdr, int ring_page)\n{\n\n    int nic_base = dev->base_addr;\n    int cnt;\n    char *ptrc;\n    short *ptrs;\n\n     \n    if (ei_status.dmaing) {\n\tnetdev_err(dev, \"DMAing conflict in ne_get_8390_hdr \"\n\t\t   \"[DMAstat:%d][irqlock:%d][intr:%d].\\n\",\n\t\t   ei_status.dmaing, ei_status.irqlock, dev->irq);\n\treturn;\n    }\n\n    ei_status.dmaing |= 0x01;\n    outb(E8390_NODMA+E8390_PAGE0+E8390_START, nic_base+ NE_CMD);\n    outb(ENISR_RDC, nic_base + NE_EN0_ISR);\n    outb(sizeof(struct e8390_pkt_hdr), nic_base + NE_EN0_RCNTLO);\n    outb(0, nic_base + NE_EN0_RCNTHI);\n    outb(0, nic_base + NE_EN0_RSARLO);\t\t \n    outb(ring_page, nic_base + NE_EN0_RSARHI);\n    outb(E8390_RREAD+E8390_START, nic_base + NE_CMD);\n\n    if (ei_status.word16) {\n        ptrs = (short*)hdr;\n        for(cnt = 0; cnt < (sizeof(struct e8390_pkt_hdr)>>1); cnt++)\n            *ptrs++ = inw(NE_BASE + NE_DATAPORT);\n    } else {\n        ptrc = (char*)hdr;\n        for(cnt = 0; cnt < sizeof(struct e8390_pkt_hdr); cnt++)\n            *ptrc++ = inb(NE_BASE + NE_DATAPORT);\n    }\n\n    outb(ENISR_RDC, nic_base + NE_EN0_ISR);\t \n    ei_status.dmaing &= ~0x01;\n\n    le16_to_cpus(&hdr->count);\n}\n\n \n\nstatic void\napne_block_input(struct net_device *dev, int count, struct sk_buff *skb, int ring_offset)\n{\n    int nic_base = dev->base_addr;\n    char *buf = skb->data;\n    char *ptrc;\n    short *ptrs;\n    int cnt;\n\n     \n    if (ei_status.dmaing) {\n\t\tnetdev_err(dev, \"DMAing conflict in ne_block_input \"\n\t\t\t   \"[DMAstat:%d][irqlock:%d][intr:%d].\\n\",\n\t\t\t   ei_status.dmaing, ei_status.irqlock, dev->irq);\n\treturn;\n    }\n    ei_status.dmaing |= 0x01;\n    outb(E8390_NODMA+E8390_PAGE0+E8390_START, nic_base+ NE_CMD);\n    outb(ENISR_RDC, nic_base + NE_EN0_ISR);\n    outb(count & 0xff, nic_base + NE_EN0_RCNTLO);\n    outb(count >> 8, nic_base + NE_EN0_RCNTHI);\n    outb(ring_offset & 0xff, nic_base + NE_EN0_RSARLO);\n    outb(ring_offset >> 8, nic_base + NE_EN0_RSARHI);\n    outb(E8390_RREAD+E8390_START, nic_base + NE_CMD);\n    if (ei_status.word16) {\n      ptrs = (short*)buf;\n      for (cnt = 0; cnt < (count>>1); cnt++)\n        *ptrs++ = inw(NE_BASE + NE_DATAPORT);\n      if (count & 0x01) {\n\tbuf[count-1] = inb(NE_BASE + NE_DATAPORT);\n      }\n    } else {\n      ptrc = buf;\n      for (cnt = 0; cnt < count; cnt++)\n        *ptrc++ = inb(NE_BASE + NE_DATAPORT);\n    }\n\n    outb(ENISR_RDC, nic_base + NE_EN0_ISR);\t \n    ei_status.dmaing &= ~0x01;\n}\n\nstatic void\napne_block_output(struct net_device *dev, int count,\n\t\tconst unsigned char *buf, const int start_page)\n{\n    int nic_base = NE_BASE;\n    unsigned long dma_start;\n    char *ptrc;\n    short *ptrs;\n    int cnt;\n\n     \n    if (ei_status.word16 && (count & 0x01))\n      count++;\n\n     \n    if (ei_status.dmaing) {\n\t\tnetdev_err(dev, \"DMAing conflict in ne_block_output.\"\n\t\t\t   \"[DMAstat:%d][irqlock:%d][intr:%d]\\n\",\n\t\t\t   ei_status.dmaing, ei_status.irqlock, dev->irq);\n\treturn;\n    }\n    ei_status.dmaing |= 0x01;\n     \n    outb(E8390_PAGE0+E8390_START+E8390_NODMA, nic_base + NE_CMD);\n\n    outb(ENISR_RDC, nic_base + NE_EN0_ISR);\n\n    \n    outb(count & 0xff, nic_base + NE_EN0_RCNTLO);\n    outb(count >> 8,   nic_base + NE_EN0_RCNTHI);\n    outb(0x00, nic_base + NE_EN0_RSARLO);\n    outb(start_page, nic_base + NE_EN0_RSARHI);\n\n    outb(E8390_RWRITE+E8390_START, nic_base + NE_CMD);\n    if (ei_status.word16) {\n        ptrs = (short*)buf;\n        for (cnt = 0; cnt < count>>1; cnt++)\n            outw(*ptrs++, NE_BASE+NE_DATAPORT);\n    } else {\n        ptrc = (char*)buf;\n        for (cnt = 0; cnt < count; cnt++)\n\t    outb(*ptrc++, NE_BASE + NE_DATAPORT);\n    }\n\n    dma_start = jiffies;\n\n    while ((inb(NE_BASE + NE_EN0_ISR) & ENISR_RDC) == 0)\n\tif (time_after(jiffies, dma_start + 2*HZ/100)) {\t \n\t\tnetdev_warn(dev, \"timeout waiting for Tx RDC.\\n\");\n\t\tapne_reset_8390(dev);\n\t\tNS8390_init(dev,1);\n\t\tbreak;\n\t}\n\n    outb(ENISR_RDC, nic_base + NE_EN0_ISR);\t \n    ei_status.dmaing &= ~0x01;\n}\n\nstatic irqreturn_t apne_interrupt(int irq, void *dev_id)\n{\n    unsigned char pcmcia_intreq;\n\n    if (!(gayle.inten & GAYLE_IRQ_IRQ))\n        return IRQ_NONE;\n\n    pcmcia_intreq = pcmcia_get_intreq();\n\n    if (!(pcmcia_intreq & GAYLE_IRQ_IRQ)) {\n        pcmcia_ack_int(pcmcia_intreq);\n        return IRQ_NONE;\n    }\n    if (apne_msg_enable & NETIF_MSG_INTR)\n\tpr_debug(\"pcmcia intreq = %x\\n\", pcmcia_intreq);\n    pcmcia_disable_irq();\t\t\t \n    ei_interrupt(irq, dev_id);\n    pcmcia_ack_int(pcmcia_get_intreq());\n    pcmcia_enable_irq();\n    return IRQ_HANDLED;\n}\n\nstatic struct net_device *apne_dev;\n\nstatic int __init apne_module_init(void)\n{\n\tapne_dev = apne_probe();\n\treturn PTR_ERR_OR_ZERO(apne_dev);\n}\n\nstatic void __exit apne_module_exit(void)\n{\n\tunregister_netdev(apne_dev);\n\n\tpcmcia_disable_irq();\n\n\tfree_irq(IRQ_AMIGA_PORTS, apne_dev);\n\n\tpcmcia_reset();\n\n\trelease_region(IOBASE, 0x20);\n\n\tfree_netdev(apne_dev);\n}\nmodule_init(apne_module_init);\nmodule_exit(apne_module_exit);\n\nstatic int init_pcmcia(void)\n{\n\tu_char config;\n#ifndef MANUAL_CONFIG\n\tu_char tuple[32];\n\tint offset_len;\n#endif\n\tu_long offset;\n\n\tpcmcia_reset();\n\tpcmcia_program_voltage(PCMCIA_0V);\n\tpcmcia_access_speed(PCMCIA_SPEED_250NS);\n\tpcmcia_write_enable();\n\n#ifdef MANUAL_CONFIG\n\tconfig = MANUAL_CONFIG;\n#else\n\t \n\n\tif (pcmcia_copy_tuple(CISTPL_CFTABLE_ENTRY, tuple, 32) < 3)\n\t\treturn 0;\n\n\tconfig = tuple[2] & 0x3f;\n#endif\n#ifdef MANUAL_OFFSET\n\toffset = MANUAL_OFFSET;\n#else\n\tif (pcmcia_copy_tuple(CISTPL_CONFIG, tuple, 32) < 6)\n\t\treturn 0;\n\n\toffset_len = (tuple[2] & 0x3) + 1;\n\toffset = 0;\n\twhile(offset_len--) {\n\t\toffset = (offset << 8) | tuple[4+offset_len];\n\t}\n#endif\n\n\tout_8(GAYLE_ATTRIBUTE+offset, config);\n\n\treturn 1;\n}\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}