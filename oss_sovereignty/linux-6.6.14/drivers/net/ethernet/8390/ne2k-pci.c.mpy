{
  "module_name": "ne2k-pci.c",
  "hash_id": "d38a59d84b5bd42e04ea4c8679adef5773c6d2b2c145279187d3512c87a17edb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/8390/ne2k-pci.c",
  "human_readable_source": "\n \n\n#define DRV_NAME\t\"ne2k-pci\"\n#define DRV_DESCRIPTION\t\"PCI NE2000 clone driver\"\n#define DRV_AUTHOR\t\"Donald Becker / Paul Gortmaker\"\n#define DRV_VERSION\t\"1.03\"\n#define DRV_RELDATE\t\"9/22/2003\"\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n \n\n \n#define MAX_UNITS 8\n\n \nstatic int full_duplex[MAX_UNITS];\nstatic int options[MAX_UNITS];\n\n \n \n\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/pci.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/ethtool.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n\n#include <linux/io.h>\n#include <asm/irq.h>\n#include <linux/uaccess.h>\n\n#include \"8390.h\"\n\nstatic int ne2k_msg_enable;\n\nstatic const int default_msg_level = (NETIF_MSG_DRV | NETIF_MSG_PROBE |\n\t\t\t\t      NETIF_MSG_RX_ERR | NETIF_MSG_TX_ERR);\n\n#if defined(__powerpc__)\n#define inl_le(addr)  le32_to_cpu(inl(addr))\n#define inw_le(addr)  le16_to_cpu(inw(addr))\n#endif\n\nMODULE_AUTHOR(DRV_AUTHOR);\nMODULE_DESCRIPTION(DRV_DESCRIPTION);\nMODULE_VERSION(DRV_VERSION);\nMODULE_LICENSE(\"GPL\");\n\nmodule_param_named(msg_enable, ne2k_msg_enable, int, 0444);\nmodule_param_array(options, int, NULL, 0);\nmodule_param_array(full_duplex, int, NULL, 0);\nMODULE_PARM_DESC(msg_enable, \"Debug message level (see linux/netdevice.h for bitmap)\");\nMODULE_PARM_DESC(options, \"Bit 5: full duplex\");\nMODULE_PARM_DESC(full_duplex, \"full duplex setting(s) (1)\");\n\n \n\n \n#define USE_LONGIO\n\n \n \n\n \n#define ne2k_flags reg0\n\nenum {\n\t \n\tONLY_16BIT_IO = 8, ONLY_32BIT_IO = 4,\n\t \n\tFORCE_FDX = 0x20,\n\tREALTEK_FDX = 0x40, HOLTEK_FDX = 0x80,\n\tSTOP_PG_0x60 = 0x100,\n};\n\nenum ne2k_pci_chipsets {\n\tCH_RealTek_RTL_8029 = 0,\n\tCH_Winbond_89C940,\n\tCH_Compex_RL2000,\n\tCH_KTI_ET32P2,\n\tCH_NetVin_NV5000SC,\n\tCH_Via_86C926,\n\tCH_SureCom_NE34,\n\tCH_Winbond_W89C940F,\n\tCH_Holtek_HT80232,\n\tCH_Holtek_HT80229,\n\tCH_Winbond_89C940_8c4a,\n};\n\n\nstatic struct {\n\tchar *name;\n\tint flags;\n} pci_clone_list[] = {\n\t{\"RealTek RTL-8029(AS)\", REALTEK_FDX},\n\t{\"Winbond 89C940\", 0},\n\t{\"Compex RL2000\", 0},\n\t{\"KTI ET32P2\", 0},\n\t{\"NetVin NV5000SC\", 0},\n\t{\"Via 86C926\", ONLY_16BIT_IO},\n\t{\"SureCom NE34\", 0},\n\t{\"Winbond W89C940F\", 0},\n\t{\"Holtek HT80232\", ONLY_16BIT_IO | HOLTEK_FDX},\n\t{\"Holtek HT80229\", ONLY_32BIT_IO | HOLTEK_FDX | STOP_PG_0x60 },\n\t{\"Winbond W89C940(misprogrammed)\", 0},\n\t{NULL,}\n};\n\n\nstatic const struct pci_device_id ne2k_pci_tbl[] = {\n\t{ 0x10ec, 0x8029, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CH_RealTek_RTL_8029 },\n\t{ 0x1050, 0x0940, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CH_Winbond_89C940 },\n\t{ 0x11f6, 0x1401, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CH_Compex_RL2000 },\n\t{ 0x8e2e, 0x3000, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CH_KTI_ET32P2 },\n\t{ 0x4a14, 0x5000, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CH_NetVin_NV5000SC },\n\t{ 0x1106, 0x0926, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CH_Via_86C926 },\n\t{ 0x10bd, 0x0e34, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CH_SureCom_NE34 },\n\t{ 0x1050, 0x5a5a, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CH_Winbond_W89C940F },\n\t{ 0x12c3, 0x0058, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CH_Holtek_HT80232 },\n\t{ 0x12c3, 0x5598, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CH_Holtek_HT80229 },\n\t{ 0x8c4a, 0x1980, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CH_Winbond_89C940_8c4a },\n\t{ 0, }\n};\n\nMODULE_DEVICE_TABLE(pci, ne2k_pci_tbl);\n\n\n \n\n#define NE_BASE\t (dev->base_addr)\n#define NE_CMD\t\t0x00\n#define NE_DATAPORT\t0x10\t \n#define NE_RESET\t0x1f\t \n#define NE_IO_EXTENT\t0x20\n\n#define NESM_START_PG\t0x40\t \n#define NESM_STOP_PG\t0x80\t \n\n\nstatic int ne2k_pci_open(struct net_device *dev);\nstatic int ne2k_pci_close(struct net_device *dev);\n\nstatic void ne2k_pci_reset_8390(struct net_device *dev);\nstatic void ne2k_pci_get_8390_hdr(struct net_device *dev,\n\t\t\t\t  struct e8390_pkt_hdr *hdr, int ring_page);\nstatic void ne2k_pci_block_input(struct net_device *dev, int count,\n\t\t\t\t struct sk_buff *skb, int ring_offset);\nstatic void ne2k_pci_block_output(struct net_device *dev, const int count,\n\t\t\t\t  const unsigned char *buf,\n\t\t\t\t  const int start_page);\nstatic const struct ethtool_ops ne2k_pci_ethtool_ops;\n\n\n\n \nstruct ne2k_pci_card {\n\tstruct net_device *dev;\n\tstruct pci_dev *pci_dev;\n};\n\n\n\n \n\nstatic const struct net_device_ops ne2k_netdev_ops = {\n\t.ndo_open\t\t= ne2k_pci_open,\n\t.ndo_stop\t\t= ne2k_pci_close,\n\t.ndo_start_xmit\t\t= ei_start_xmit,\n\t.ndo_tx_timeout\t\t= ei_tx_timeout,\n\t.ndo_get_stats\t\t= ei_get_stats,\n\t.ndo_set_rx_mode\t= ei_set_multicast_list,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_set_mac_address\t= eth_mac_addr,\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\t.ndo_poll_controller = ei_poll,\n#endif\n};\n\nstatic int ne2k_pci_init_one(struct pci_dev *pdev,\n\t\t\t     const struct pci_device_id *ent)\n{\n\tstruct net_device *dev;\n\tint i;\n\tunsigned char SA_prom[32];\n\tint start_page, stop_page;\n\tint irq, reg0, chip_idx = ent->driver_data;\n\tstatic unsigned int fnd_cnt;\n\tlong ioaddr;\n\tint flags = pci_clone_list[chip_idx].flags;\n\tstruct ei_device *ei_local;\n\n\tfnd_cnt++;\n\n\ti = pci_enable_device(pdev);\n\tif (i)\n\t\treturn i;\n\n\tioaddr = pci_resource_start(pdev, 0);\n\tirq = pdev->irq;\n\n\tif (!ioaddr || ((pci_resource_flags(pdev, 0) & IORESOURCE_IO) == 0)) {\n\t\tdev_err(&pdev->dev, \"no I/O resource at PCI BAR #0\\n\");\n\t\tgoto err_out;\n\t}\n\n\tif (!request_region(ioaddr, NE_IO_EXTENT, DRV_NAME)) {\n\t\tdev_err(&pdev->dev, \"I/O resource 0x%x @ 0x%lx busy\\n\",\n\t\t\tNE_IO_EXTENT, ioaddr);\n\t\tgoto err_out;\n\t}\n\n\treg0 = inb(ioaddr);\n\tif (reg0 == 0xFF)\n\t\tgoto err_out_free_res;\n\n\t \n\t{\n\t\tint regd;\n\n\t\toutb(E8390_NODMA + E8390_PAGE1 + E8390_STOP, ioaddr + E8390_CMD);\n\t\tregd = inb(ioaddr + 0x0d);\n\t\toutb(0xff, ioaddr + 0x0d);\n\t\toutb(E8390_NODMA + E8390_PAGE0, ioaddr + E8390_CMD);\n\t\t \n\t\tinb(ioaddr + EN0_COUNTER0);\n\t\tif (inb(ioaddr + EN0_COUNTER0) != 0) {\n\t\t\toutb(reg0, ioaddr);\n\t\t\t \n\t\t\toutb(regd, ioaddr + 0x0d);\n\t\t\tgoto err_out_free_res;\n\t\t}\n\t}\n\n\t \n\tdev = alloc_ei_netdev();\n\tif (!dev) {\n\t\tdev_err(&pdev->dev, \"cannot allocate ethernet device\\n\");\n\t\tgoto err_out_free_res;\n\t}\n\tdev->netdev_ops = &ne2k_netdev_ops;\n\tei_local = netdev_priv(dev);\n\tei_local->msg_enable = netif_msg_init(ne2k_msg_enable, default_msg_level);\n\n\tSET_NETDEV_DEV(dev, &pdev->dev);\n\n\t \n\t{\n\t\tunsigned long reset_start_time = jiffies;\n\n\t\toutb(inb(ioaddr + NE_RESET), ioaddr + NE_RESET);\n\n\t\t \n\t\twhile ((inb(ioaddr + EN0_ISR) & ENISR_RESET) == 0)\n\t\t\t \n\t\t\tif (jiffies - reset_start_time > 2) {\n\t\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\t\"Card failure (no reset ack).\\n\");\n\t\t\t\tgoto err_out_free_netdev;\n\t\t\t}\n\t\t \n\t\toutb(0xff, ioaddr + EN0_ISR);\n\t}\n\n\t \n\t{\n\t\tstruct {unsigned char value, offset; } program_seq[] = {\n\t\t\t \n\t\t\t{E8390_NODMA + E8390_PAGE0 + E8390_STOP, E8390_CMD},\n\t\t\t \n\t\t\t{0x49,\tEN0_DCFG},\n\t\t\t \n\t\t\t{0x00,\tEN0_RCNTLO},\n\t\t\t \n\t\t\t{0x00,\tEN0_RCNTHI},\n\t\t\t{0x00,\tEN0_IMR},\n\t\t\t{0xFF,\tEN0_ISR},\n\t\t\t \n\t\t\t{E8390_RXOFF, EN0_RXCR},\n\t\t\t \n\t\t\t{E8390_TXOFF, EN0_TXCR},\n\t\t\t{32,\tEN0_RCNTLO},\n\t\t\t{0x00,\tEN0_RCNTHI},\n\t\t\t \n\t\t\t{0x00,\tEN0_RSARLO},\n\t\t\t{0x00,\tEN0_RSARHI},\n\t\t\t{E8390_RREAD+E8390_START, E8390_CMD},\n\t\t};\n\t\tfor (i = 0; i < ARRAY_SIZE(program_seq); i++)\n\t\t\toutb(program_seq[i].value,\n\t\t\t     ioaddr + program_seq[i].offset);\n\n\t}\n\n\t \n\tif (flags & ONLY_32BIT_IO) {\n\t\tfor (i = 0; i < 4 ; i++)\n\t\t\t((u32 *)SA_prom)[i] = le32_to_cpu(inl(ioaddr + NE_DATAPORT));\n\t} else\n\t\tfor (i = 0; i < 32  ; i++)\n\t\t\tSA_prom[i] = inb(ioaddr + NE_DATAPORT);\n\n\t \n\toutb(0x49, ioaddr + EN0_DCFG);\n\tstart_page = NESM_START_PG;\n\n\tstop_page = flags & STOP_PG_0x60 ? 0x60 : NESM_STOP_PG;\n\n\t \n\tdev->irq = irq;\n\tdev->base_addr = ioaddr;\n\tpci_set_drvdata(pdev, dev);\n\n\tei_status.name = pci_clone_list[chip_idx].name;\n\tei_status.tx_start_page = start_page;\n\tei_status.stop_page = stop_page;\n\tei_status.word16 = 1;\n\tei_status.ne2k_flags = flags;\n\tif (fnd_cnt < MAX_UNITS) {\n\t\tif (full_duplex[fnd_cnt] > 0 || (options[fnd_cnt] & FORCE_FDX))\n\t\t\tei_status.ne2k_flags |= FORCE_FDX;\n\t}\n\n\tei_status.rx_start_page = start_page + TX_PAGES;\n#ifdef PACKETBUF_MEMSIZE\n\t \n\tei_status.stop_page = ei_status.tx_start_page + PACKETBUF_MEMSIZE;\n#endif\n\n\tei_status.reset_8390 = &ne2k_pci_reset_8390;\n\tei_status.block_input = &ne2k_pci_block_input;\n\tei_status.block_output = &ne2k_pci_block_output;\n\tei_status.get_8390_hdr = &ne2k_pci_get_8390_hdr;\n\tei_status.priv = (unsigned long) pdev;\n\n\tdev->ethtool_ops = &ne2k_pci_ethtool_ops;\n\tNS8390_init(dev, 0);\n\n\teth_hw_addr_set(dev, SA_prom);\n\n\ti = register_netdev(dev);\n\tif (i)\n\t\tgoto err_out_free_netdev;\n\n\tnetdev_info(dev, \"%s found at %#lx, IRQ %d, %pM.\\n\",\n\t\t    pci_clone_list[chip_idx].name, ioaddr, dev->irq,\n\t\t    dev->dev_addr);\n\n\treturn 0;\n\nerr_out_free_netdev:\n\tfree_netdev(dev);\nerr_out_free_res:\n\trelease_region(ioaddr, NE_IO_EXTENT);\nerr_out:\n\tpci_disable_device(pdev);\n\treturn -ENODEV;\n}\n\n \nstatic inline int set_realtek_fdx(struct net_device *dev)\n{\n\tlong ioaddr = dev->base_addr;\n\n\toutb(0xC0 + E8390_NODMA, ioaddr + NE_CMD);  \n\toutb(0xC0, ioaddr + 0x01);  \n\toutb(0x40, ioaddr + 0x06);  \n\toutb(0x00, ioaddr + 0x01);  \n\toutb(E8390_PAGE0 + E8390_NODMA, ioaddr + NE_CMD);  \n\treturn 0;\n}\n\nstatic inline int set_holtek_fdx(struct net_device *dev)\n{\n\tlong ioaddr = dev->base_addr;\n\n\toutb(inb(ioaddr + 0x20) | 0x80, ioaddr + 0x20);\n\treturn 0;\n}\n\nstatic int ne2k_pci_set_fdx(struct net_device *dev)\n{\n\tif (ei_status.ne2k_flags & REALTEK_FDX)\n\t\treturn set_realtek_fdx(dev);\n\telse if (ei_status.ne2k_flags & HOLTEK_FDX)\n\t\treturn set_holtek_fdx(dev);\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic int ne2k_pci_open(struct net_device *dev)\n{\n\tint ret = request_irq(dev->irq, ei_interrupt, IRQF_SHARED,\n\t\t\t      dev->name, dev);\n\n\tif (ret)\n\t\treturn ret;\n\n\tif (ei_status.ne2k_flags & FORCE_FDX)\n\t\tne2k_pci_set_fdx(dev);\n\n\tei_open(dev);\n\treturn 0;\n}\n\nstatic int ne2k_pci_close(struct net_device *dev)\n{\n\tei_close(dev);\n\tfree_irq(dev->irq, dev);\n\treturn 0;\n}\n\n \nstatic void ne2k_pci_reset_8390(struct net_device *dev)\n{\n\tunsigned long reset_start_time = jiffies;\n\tstruct ei_device *ei_local = netdev_priv(dev);\n\n\tnetif_dbg(ei_local, hw, dev, \"resetting the 8390 t=%ld...\\n\",\n\t\t  jiffies);\n\n\toutb(inb(NE_BASE + NE_RESET), NE_BASE + NE_RESET);\n\n\tei_status.txing = 0;\n\tei_status.dmaing = 0;\n\n\t \n\twhile ((inb(NE_BASE+EN0_ISR) & ENISR_RESET) == 0)\n\t\tif (jiffies - reset_start_time > 2) {\n\t\t\tnetdev_err(dev, \"%s did not complete.\\n\", __func__);\n\t\t\tbreak;\n\t\t}\n\t \n\toutb(ENISR_RESET, NE_BASE + EN0_ISR);\n}\n\n \n\nstatic void ne2k_pci_get_8390_hdr(struct net_device *dev,\n\t\t\t\t  struct e8390_pkt_hdr *hdr, int ring_page)\n{\n\n\tlong nic_base = dev->base_addr;\n\n\t \n\tif (ei_status.dmaing) {\n\t\tnetdev_err(dev, \"DMAing conflict in %s [DMAstat:%d][irqlock:%d].\\n\",\n\t\t\t   __func__, ei_status.dmaing, ei_status.irqlock);\n\t\treturn;\n\t}\n\n\tei_status.dmaing |= 0x01;\n\toutb(E8390_NODMA + E8390_PAGE0 + E8390_START, nic_base + NE_CMD);\n\toutb(sizeof(struct e8390_pkt_hdr), nic_base + EN0_RCNTLO);\n\toutb(0, nic_base + EN0_RCNTHI);\n\toutb(0, nic_base + EN0_RSARLO);\t\t \n\toutb(ring_page, nic_base + EN0_RSARHI);\n\toutb(E8390_RREAD+E8390_START, nic_base + NE_CMD);\n\n\tif (ei_status.ne2k_flags & ONLY_16BIT_IO) {\n\t\tinsw(NE_BASE + NE_DATAPORT, hdr,\n\t\t     sizeof(struct e8390_pkt_hdr) >> 1);\n\t} else {\n\t\t*(u32 *)hdr = le32_to_cpu(inl(NE_BASE + NE_DATAPORT));\n\t\tle16_to_cpus(&hdr->count);\n\t}\n\t \n\toutb(ENISR_RDC, nic_base + EN0_ISR);\n\tei_status.dmaing &= ~0x01;\n}\n\n \n\nstatic void ne2k_pci_block_input(struct net_device *dev, int count,\n\t\t\t\t struct sk_buff *skb, int ring_offset)\n{\n\tlong nic_base = dev->base_addr;\n\tchar *buf = skb->data;\n\n\t \n\tif (ei_status.dmaing) {\n\t\tnetdev_err(dev, \"DMAing conflict in %s [DMAstat:%d][irqlock:%d]\\n\",\n\t\t\t   __func__, ei_status.dmaing, ei_status.irqlock);\n\t\treturn;\n\t}\n\tei_status.dmaing |= 0x01;\n\tif (ei_status.ne2k_flags & ONLY_32BIT_IO)\n\t\tcount = (count + 3) & 0xFFFC;\n\toutb(E8390_NODMA + E8390_PAGE0 + E8390_START, nic_base + NE_CMD);\n\toutb(count & 0xff, nic_base + EN0_RCNTLO);\n\toutb(count >> 8, nic_base + EN0_RCNTHI);\n\toutb(ring_offset & 0xff, nic_base + EN0_RSARLO);\n\toutb(ring_offset >> 8, nic_base + EN0_RSARHI);\n\toutb(E8390_RREAD + E8390_START, nic_base + NE_CMD);\n\n\tif (ei_status.ne2k_flags & ONLY_16BIT_IO) {\n\t\tinsw(NE_BASE + NE_DATAPORT, buf, count >> 1);\n\t\tif (count & 0x01)\n\t\t\tbuf[count-1] = inb(NE_BASE + NE_DATAPORT);\n\t} else {\n\t\tinsl(NE_BASE + NE_DATAPORT, buf, count >> 2);\n\t\tif (count & 3) {\n\t\t\tbuf += count & ~3;\n\t\t\tif (count & 2) {\n\t\t\t\t__le16 *b = (__le16 *)buf;\n\n\t\t\t\t*b++ = cpu_to_le16(inw(NE_BASE + NE_DATAPORT));\n\t\t\t\tbuf = (char *)b;\n\t\t\t}\n\t\t\tif (count & 1)\n\t\t\t\t*buf = inb(NE_BASE + NE_DATAPORT);\n\t\t}\n\t}\n\t \n\toutb(ENISR_RDC, nic_base + EN0_ISR);\n\tei_status.dmaing &= ~0x01;\n}\n\nstatic void ne2k_pci_block_output(struct net_device *dev, int count,\n\t\tconst unsigned char *buf, const int start_page)\n{\n\tlong nic_base = NE_BASE;\n\tunsigned long dma_start;\n\n\t \n\tif (ei_status.ne2k_flags & ONLY_32BIT_IO)\n\t\tcount = (count + 3) & 0xFFFC;\n\telse\n\t\tif (count & 0x01)\n\t\t\tcount++;\n\n\t \n\tif (ei_status.dmaing) {\n\t\tnetdev_err(dev, \"DMAing conflict in %s [DMAstat:%d][irqlock:%d]\\n\",\n\t\t\t   __func__, ei_status.dmaing, ei_status.irqlock);\n\t\treturn;\n\t}\n\tei_status.dmaing |= 0x01;\n\t \n\toutb(E8390_PAGE0+E8390_START+E8390_NODMA, nic_base + NE_CMD);\n\n#ifdef NE_RW_BUGFIX\n\t \n\toutb(0x42, nic_base + EN0_RCNTLO);\n\toutb(0x00, nic_base + EN0_RCNTHI);\n\toutb(0x42, nic_base + EN0_RSARLO);\n\toutb(0x00, nic_base + EN0_RSARHI);\n\toutb(E8390_RREAD+E8390_START, nic_base + NE_CMD);\n#endif\n\toutb(ENISR_RDC, nic_base + EN0_ISR);\n\n\t \n\toutb(count & 0xff, nic_base + EN0_RCNTLO);\n\toutb(count >> 8,   nic_base + EN0_RCNTHI);\n\toutb(0x00, nic_base + EN0_RSARLO);\n\toutb(start_page, nic_base + EN0_RSARHI);\n\toutb(E8390_RWRITE+E8390_START, nic_base + NE_CMD);\n\tif (ei_status.ne2k_flags & ONLY_16BIT_IO) {\n\t\toutsw(NE_BASE + NE_DATAPORT, buf, count >> 1);\n\t} else {\n\t\toutsl(NE_BASE + NE_DATAPORT, buf, count >> 2);\n\t\tif (count & 3) {\n\t\t\tbuf += count & ~3;\n\t\t\tif (count & 2) {\n\t\t\t\t__le16 *b = (__le16 *)buf;\n\n\t\t\t\toutw(le16_to_cpu(*b++), NE_BASE + NE_DATAPORT);\n\t\t\t\tbuf = (char *)b;\n\t\t\t}\n\t\t}\n\t}\n\n\tdma_start = jiffies;\n\n\twhile ((inb(nic_base + EN0_ISR) & ENISR_RDC) == 0)\n\t\t \n\t\tif (jiffies - dma_start > 2) {\n\t\t\tnetdev_warn(dev, \"timeout waiting for Tx RDC.\\n\");\n\t\t\tne2k_pci_reset_8390(dev);\n\t\t\tNS8390_init(dev, 1);\n\t\t\tbreak;\n\t\t}\n\t \n\toutb(ENISR_RDC, nic_base + EN0_ISR);\n\tei_status.dmaing &= ~0x01;\n}\n\nstatic void ne2k_pci_get_drvinfo(struct net_device *dev,\n\t\t\t\t struct ethtool_drvinfo *info)\n{\n\tstruct ei_device *ei = netdev_priv(dev);\n\tstruct pci_dev *pci_dev = (struct pci_dev *) ei->priv;\n\n\tstrscpy(info->driver, DRV_NAME, sizeof(info->driver));\n\tstrscpy(info->version, DRV_VERSION, sizeof(info->version));\n\tstrscpy(info->bus_info, pci_name(pci_dev), sizeof(info->bus_info));\n}\n\nstatic u32 ne2k_pci_get_msglevel(struct net_device *dev)\n{\n\tstruct ei_device *ei_local = netdev_priv(dev);\n\n\treturn ei_local->msg_enable;\n}\n\nstatic void ne2k_pci_set_msglevel(struct net_device *dev, u32 v)\n{\n\tstruct ei_device *ei_local = netdev_priv(dev);\n\n\tei_local->msg_enable = v;\n}\n\nstatic const struct ethtool_ops ne2k_pci_ethtool_ops = {\n\t.get_drvinfo\t\t= ne2k_pci_get_drvinfo,\n\t.get_msglevel\t\t= ne2k_pci_get_msglevel,\n\t.set_msglevel\t\t= ne2k_pci_set_msglevel,\n};\n\nstatic void ne2k_pci_remove_one(struct pci_dev *pdev)\n{\n\tstruct net_device *dev = pci_get_drvdata(pdev);\n\n\tBUG_ON(!dev);\n\tunregister_netdev(dev);\n\trelease_region(dev->base_addr, NE_IO_EXTENT);\n\tfree_netdev(dev);\n\tpci_disable_device(pdev);\n}\n\nstatic int __maybe_unused ne2k_pci_suspend(struct device *dev_d)\n{\n\tstruct net_device *dev = dev_get_drvdata(dev_d);\n\n\tnetif_device_detach(dev);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused ne2k_pci_resume(struct device *dev_d)\n{\n\tstruct net_device *dev = dev_get_drvdata(dev_d);\n\n\tNS8390_init(dev, 1);\n\tnetif_device_attach(dev);\n\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(ne2k_pci_pm_ops, ne2k_pci_suspend, ne2k_pci_resume);\n\nstatic struct pci_driver ne2k_driver = {\n\t.name\t\t= DRV_NAME,\n\t.probe\t\t= ne2k_pci_init_one,\n\t.remove\t\t= ne2k_pci_remove_one,\n\t.id_table\t= ne2k_pci_tbl,\n\t.driver.pm\t= &ne2k_pci_pm_ops,\n};\nmodule_pci_driver(ne2k_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}