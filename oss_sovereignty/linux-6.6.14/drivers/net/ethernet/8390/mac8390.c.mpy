{
  "module_name": "mac8390.c",
  "hash_id": "7f5126a70ce3b40c85d8da4ef964724781932887ceafc63f01fa493426561101",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/8390/mac8390.c",
  "human_readable_source": "\n \n \n\n \n \n \n \n \n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/fcntl.h>\n#include <linux/interrupt.h>\n#include <linux/ptrace.h>\n#include <linux/ioport.h>\n#include <linux/nubus.h>\n#include <linux/in.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/skbuff.h>\n#include <linux/bitops.h>\n#include <linux/io.h>\n\n#include <asm/dma.h>\n#include <asm/hwtest.h>\n#include <asm/macints.h>\n\nstatic char version[] =\n\t\"v0.4 2001-05-15 David Huggins-Daines <dhd@debian.org> and others\\n\";\n\n#define EI_SHIFT(x)\t(ei_local->reg_offset[x])\n#define ei_inb(port)\tin_8(port)\n#define ei_outb(val, port)\tout_8(port, val)\n#define ei_inb_p(port)\tin_8(port)\n#define ei_outb_p(val, port)\tout_8(port, val)\n\n#include \"lib8390.c\"\n\n#define WD_START_PG\t\t\t0x00\t \n#define CABLETRON_RX_START_PG\t\t0x00     \n#define CABLETRON_RX_STOP_PG\t\t0x30     \n#define CABLETRON_TX_START_PG\t\tCABLETRON_RX_STOP_PG\n\t\t\t\t\t\t \n\n \n\n#define DAYNA_8390_BASE\t\t0x80000\n#define DAYNA_8390_MEM\t\t0x00000\n\n#define CABLETRON_8390_BASE\t0x90000\n#define CABLETRON_8390_MEM\t0x00000\n\n#define INTERLAN_8390_BASE\t0xE0000\n#define INTERLAN_8390_MEM\t0xD0000\n\nenum mac8390_type {\n\tMAC8390_NONE = -1,\n\tMAC8390_APPLE,\n\tMAC8390_ASANTE,\n\tMAC8390_FARALLON,\n\tMAC8390_CABLETRON,\n\tMAC8390_DAYNA,\n\tMAC8390_INTERLAN,\n\tMAC8390_KINETICS,\n};\n\nstatic const char *cardname[] = {\n\t\"apple\",\n\t\"asante\",\n\t\"farallon\",\n\t\"cabletron\",\n\t\"dayna\",\n\t\"interlan\",\n\t\"kinetics\",\n};\n\nstatic const int word16[] = {\n\t1,  \n\t1,  \n\t1,  \n\t1,  \n\t0,  \n\t1,  \n\t0,  \n};\n\n \nstatic const int useresources[] = {\n\t1,  \n\t1,  \n\t1,  \n\t0,  \n\t0,  \n\t0,  \n\t0,  \n};\n\nenum mac8390_access {\n\tACCESS_UNKNOWN = 0,\n\tACCESS_32,\n\tACCESS_16,\n};\n\nextern int mac8390_memtest(struct net_device *dev);\nstatic int mac8390_initdev(struct net_device *dev, struct nubus_board *board,\n\t\t\t   enum mac8390_type type);\n\nstatic int mac8390_open(struct net_device *dev);\nstatic int mac8390_close(struct net_device *dev);\nstatic void mac8390_no_reset(struct net_device *dev);\nstatic void interlan_reset(struct net_device *dev);\n\n \nstatic void sane_get_8390_hdr(struct net_device *dev,\n\t\t\t      struct e8390_pkt_hdr *hdr, int ring_page);\nstatic void sane_block_input(struct net_device *dev, int count,\n\t\t\t     struct sk_buff *skb, int ring_offset);\nstatic void sane_block_output(struct net_device *dev, int count,\n\t\t\t      const unsigned char *buf, const int start_page);\n\n \nstatic void dayna_memcpy_fromcard(struct net_device *dev, void *to,\n\t\t\t\tint from, int count);\nstatic void dayna_memcpy_tocard(struct net_device *dev, int to,\n\t\t\t      const void *from, int count);\n\n \nstatic void dayna_get_8390_hdr(struct net_device *dev,\n\t\t\t       struct e8390_pkt_hdr *hdr, int ring_page);\nstatic void dayna_block_input(struct net_device *dev, int count,\n\t\t\t      struct sk_buff *skb, int ring_offset);\nstatic void dayna_block_output(struct net_device *dev, int count,\n\t\t\t       const unsigned char *buf, int start_page);\n\n \nstatic void slow_sane_get_8390_hdr(struct net_device *dev,\n\t\t\t\t   struct e8390_pkt_hdr *hdr, int ring_page);\nstatic void slow_sane_block_input(struct net_device *dev, int count,\n\t\t\t\t  struct sk_buff *skb, int ring_offset);\nstatic void slow_sane_block_output(struct net_device *dev, int count,\n\t\t\t\t   const unsigned char *buf, int start_page);\nstatic void word_memcpy_tocard(unsigned long tp, const void *fp, int count);\nstatic void word_memcpy_fromcard(void *tp, unsigned long fp, int count);\n\nstatic enum mac8390_type mac8390_ident(struct nubus_rsrc *fres)\n{\n\tswitch (fres->dr_sw) {\n\tcase NUBUS_DRSW_3COM:\n\t\tswitch (fres->dr_hw) {\n\t\tcase NUBUS_DRHW_APPLE_SONIC_NB:\n\t\tcase NUBUS_DRHW_APPLE_SONIC_LC:\n\t\tcase NUBUS_DRHW_SONNET:\n\t\t\treturn MAC8390_NONE;\n\t\tdefault:\n\t\t\treturn MAC8390_APPLE;\n\t\t}\n\n\tcase NUBUS_DRSW_APPLE:\n\t\tswitch (fres->dr_hw) {\n\t\tcase NUBUS_DRHW_ASANTE_LC:\n\t\t\treturn MAC8390_NONE;\n\t\tcase NUBUS_DRHW_CABLETRON:\n\t\t\treturn MAC8390_CABLETRON;\n\t\tdefault:\n\t\t\treturn MAC8390_APPLE;\n\t\t}\n\n\tcase NUBUS_DRSW_ASANTE:\n\t\treturn MAC8390_ASANTE;\n\n\tcase NUBUS_DRSW_TECHWORKS:\n\tcase NUBUS_DRSW_DAYNA2:\n\tcase NUBUS_DRSW_DAYNA_LC:\n\t\tif (fres->dr_hw == NUBUS_DRHW_CABLETRON)\n\t\t\treturn MAC8390_CABLETRON;\n\t\telse\n\t\t\treturn MAC8390_APPLE;\n\n\tcase NUBUS_DRSW_FARALLON:\n\t\treturn MAC8390_FARALLON;\n\n\tcase NUBUS_DRSW_KINETICS:\n\t\tswitch (fres->dr_hw) {\n\t\tcase NUBUS_DRHW_INTERLAN:\n\t\t\treturn MAC8390_INTERLAN;\n\t\tdefault:\n\t\t\treturn MAC8390_KINETICS;\n\t\t}\n\n\tcase NUBUS_DRSW_DAYNA:\n\t\t \n\t\tif (fres->dr_hw == NUBUS_DRHW_SMC9194 ||\n\t\t    fres->dr_hw == NUBUS_DRHW_INTERLAN)\n\t\t\treturn MAC8390_NONE;\n\t\telse\n\t\t\treturn MAC8390_DAYNA;\n\t}\n\treturn MAC8390_NONE;\n}\n\nstatic enum mac8390_access mac8390_testio(unsigned long membase)\n{\n\tu32 outdata = 0xA5A0B5B0;\n\tu32 indata = 0;\n\n\t \n\tnubus_writel(outdata, membase);\n\t \n\tindata = nubus_readl(membase);\n\tif (outdata == indata)\n\t\treturn ACCESS_32;\n\n\toutdata = 0xC5C0D5D0;\n\tindata = 0;\n\n\t \n\tword_memcpy_tocard(membase, &outdata, 4);\n\t \n\tword_memcpy_fromcard(&indata, membase, 4);\n\tif (outdata == indata)\n\t\treturn ACCESS_16;\n\n\treturn ACCESS_UNKNOWN;\n}\n\nstatic int mac8390_memsize(unsigned long membase)\n{\n\tunsigned long flags;\n\tint i, j;\n\n\tlocal_irq_save(flags);\n\t \n\tfor (i = 0; i < 8; i++) {\n\t\tvolatile unsigned short *m = (unsigned short *)(membase + (i * 0x1000));\n\n\t\t \n\t\tif (hwreg_present(m) == 0)\n\t\t\tbreak;\n\n\t\t \n\t\t*m = 0xA5A0 | i;\n\t\t \n\t\tif (*m != (0xA5A0 | i))\n\t\t\tbreak;\n\n\t\t \n\t\tfor (j = 0; j < i; j++) {\n\t\t\tvolatile unsigned short *p = (unsigned short *)(membase + (j * 0x1000));\n\t\t\tif (*p != (0xA5A0 | j))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tlocal_irq_restore(flags);\n\t \n\treturn i * 0x1000;\n}\n\nstatic bool mac8390_rsrc_init(struct net_device *dev,\n\t\t\t      struct nubus_rsrc *fres,\n\t\t\t      enum mac8390_type cardtype)\n{\n\tstruct nubus_board *board = fres->board;\n\tstruct nubus_dir dir;\n\tstruct nubus_dirent ent;\n\tint offset;\n\tvolatile unsigned short *i;\n\tu8 addr[ETH_ALEN];\n\n\tdev->irq = SLOT2IRQ(board->slot);\n\t \n\tdev->base_addr = board->slot_addr | ((board->slot & 0xf) << 20);\n\n\t \n\n\tif (nubus_get_func_dir(fres, &dir) == -1) {\n\t\tdev_err(&board->dev,\n\t\t\t\"Unable to get Nubus functional directory\\n\");\n\t\treturn false;\n\t}\n\n\t \n\tif (nubus_find_rsrc(&dir, NUBUS_RESID_MAC_ADDRESS, &ent) == -1) {\n\t\tdev_info(&board->dev, \"MAC address resource not found\\n\");\n\t\treturn false;\n\t}\n\n\tnubus_get_rsrc_mem(addr, &ent, 6);\n\teth_hw_addr_set(dev, addr);\n\n\tif (useresources[cardtype] == 1) {\n\t\tnubus_rewinddir(&dir);\n\t\tif (nubus_find_rsrc(&dir, NUBUS_RESID_MINOR_BASEOS,\n\t\t\t\t    &ent) == -1) {\n\t\t\tdev_err(&board->dev,\n\t\t\t\t\"Memory offset resource not found\\n\");\n\t\t\treturn false;\n\t\t}\n\t\tnubus_get_rsrc_mem(&offset, &ent, 4);\n\t\tdev->mem_start = dev->base_addr + offset;\n\t\t \n\t\tdev->base_addr = dev->mem_start + 0x10000;\n\t\tnubus_rewinddir(&dir);\n\t\tif (nubus_find_rsrc(&dir, NUBUS_RESID_MINOR_LENGTH,\n\t\t\t\t    &ent) == -1) {\n\t\t\tdev_info(&board->dev,\n\t\t\t\t \"Memory length resource not found, probing\\n\");\n\t\t\toffset = mac8390_memsize(dev->mem_start);\n\t\t} else {\n\t\t\tnubus_get_rsrc_mem(&offset, &ent, 4);\n\t\t}\n\t\tdev->mem_end = dev->mem_start + offset;\n\t} else {\n\t\tswitch (cardtype) {\n\t\tcase MAC8390_KINETICS:\n\t\tcase MAC8390_DAYNA:  \n\t\t\tdev->base_addr = (int)(board->slot_addr +\n\t\t\t\t\t       DAYNA_8390_BASE);\n\t\t\tdev->mem_start = (int)(board->slot_addr +\n\t\t\t\t\t       DAYNA_8390_MEM);\n\t\t\tdev->mem_end = dev->mem_start +\n\t\t\t\t       mac8390_memsize(dev->mem_start);\n\t\t\tbreak;\n\t\tcase MAC8390_INTERLAN:\n\t\t\tdev->base_addr = (int)(board->slot_addr +\n\t\t\t\t\t       INTERLAN_8390_BASE);\n\t\t\tdev->mem_start = (int)(board->slot_addr +\n\t\t\t\t\t       INTERLAN_8390_MEM);\n\t\t\tdev->mem_end = dev->mem_start +\n\t\t\t\t       mac8390_memsize(dev->mem_start);\n\t\t\tbreak;\n\t\tcase MAC8390_CABLETRON:\n\t\t\tdev->base_addr = (int)(board->slot_addr +\n\t\t\t\t\t       CABLETRON_8390_BASE);\n\t\t\tdev->mem_start = (int)(board->slot_addr +\n\t\t\t\t\t       CABLETRON_8390_MEM);\n\t\t\t \n\t\t\ti = (void *)dev->base_addr;\n\t\t\t*i = 0x21;\n\t\t\tdev->mem_end = dev->mem_start +\n\t\t\t\t       mac8390_memsize(dev->mem_start);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tdev_err(&board->dev,\n\t\t\t\t\"No known base address for card type\\n\");\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nstatic int mac8390_device_probe(struct nubus_board *board)\n{\n\tstruct net_device *dev;\n\tint err = -ENODEV;\n\tstruct nubus_rsrc *fres;\n\tenum mac8390_type cardtype = MAC8390_NONE;\n\n\tdev = ____alloc_ei_netdev(0);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tSET_NETDEV_DEV(dev, &board->dev);\n\n\tfor_each_board_func_rsrc(board, fres) {\n\t\tif (fres->category != NUBUS_CAT_NETWORK ||\n\t\t    fres->type != NUBUS_TYPE_ETHERNET)\n\t\t\tcontinue;\n\n\t\tcardtype = mac8390_ident(fres);\n\t\tif (cardtype == MAC8390_NONE)\n\t\t\tcontinue;\n\n\t\tif (mac8390_rsrc_init(dev, fres, cardtype))\n\t\t\tbreak;\n\t}\n\tif (!fres)\n\t\tgoto out;\n\n\terr = mac8390_initdev(dev, board, cardtype);\n\tif (err)\n\t\tgoto out;\n\n\terr = register_netdev(dev);\n\tif (err)\n\t\tgoto out;\n\n\tnubus_set_drvdata(board, dev);\n\treturn 0;\n\nout:\n\tfree_netdev(dev);\n\treturn err;\n}\n\nstatic void mac8390_device_remove(struct nubus_board *board)\n{\n\tstruct net_device *dev = nubus_get_drvdata(board);\n\n\tunregister_netdev(dev);\n\tfree_netdev(dev);\n}\n\nstatic struct nubus_driver mac8390_driver = {\n\t.probe = mac8390_device_probe,\n\t.remove = mac8390_device_remove,\n\t.driver = {\n\t\t.name = KBUILD_MODNAME,\n\t\t.owner = THIS_MODULE,\n\t}\n};\n\nMODULE_AUTHOR(\"David Huggins-Daines <dhd@debian.org> and others\");\nMODULE_DESCRIPTION(\"Macintosh NS8390-based Nubus Ethernet driver\");\nMODULE_LICENSE(\"GPL\");\n\nstatic int __init mac8390_init(void)\n{\n\treturn nubus_driver_register(&mac8390_driver);\n}\nmodule_init(mac8390_init);\n\nstatic void __exit mac8390_exit(void)\n{\n\tnubus_driver_unregister(&mac8390_driver);\n}\nmodule_exit(mac8390_exit);\n\nstatic const struct net_device_ops mac8390_netdev_ops = {\n\t.ndo_open \t\t= mac8390_open,\n\t.ndo_stop\t\t= mac8390_close,\n\t.ndo_start_xmit\t\t= __ei_start_xmit,\n\t.ndo_tx_timeout\t\t= __ei_tx_timeout,\n\t.ndo_get_stats\t\t= __ei_get_stats,\n\t.ndo_set_rx_mode\t= __ei_set_multicast_list,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_set_mac_address \t= eth_mac_addr,\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\t.ndo_poll_controller\t= __ei_poll,\n#endif\n};\n\nstatic int mac8390_initdev(struct net_device *dev, struct nubus_board *board,\n\t\t\t   enum mac8390_type type)\n{\n\tstatic u32 fwrd4_offsets[16] = {\n\t\t0,      4,      8,      12,\n\t\t16,     20,     24,     28,\n\t\t32,     36,     40,     44,\n\t\t48,     52,     56,     60\n\t};\n\tstatic u32 back4_offsets[16] = {\n\t\t60,     56,     52,     48,\n\t\t44,     40,     36,     32,\n\t\t28,     24,     20,     16,\n\t\t12,     8,      4,      0\n\t};\n\tstatic u32 fwrd2_offsets[16] = {\n\t\t0,      2,      4,      6,\n\t\t8,     10,     12,     14,\n\t\t16,    18,     20,     22,\n\t\t24,    26,     28,     30\n\t};\n\n\tint access_bitmode = 0;\n\n\t \n\tdev->netdev_ops = &mac8390_netdev_ops;\n\n\t \n\tei_status.name = cardname[type];\n\tei_status.word16 = word16[type];\n\n\t \n\tif (type == MAC8390_CABLETRON) {\n\t\tei_status.tx_start_page = CABLETRON_TX_START_PG;\n\t\tei_status.rx_start_page = CABLETRON_RX_START_PG;\n\t\tei_status.stop_page = CABLETRON_RX_STOP_PG;\n\t\tei_status.rmem_start = dev->mem_start;\n\t\tei_status.rmem_end = dev->mem_start + CABLETRON_RX_STOP_PG*256;\n\t} else {\n\t\tei_status.tx_start_page = WD_START_PG;\n\t\tei_status.rx_start_page = WD_START_PG + TX_PAGES;\n\t\tei_status.stop_page = (dev->mem_end - dev->mem_start)/256;\n\t\tei_status.rmem_start = dev->mem_start + TX_PAGES*256;\n\t\tei_status.rmem_end = dev->mem_end;\n\t}\n\n\t \n\tswitch (type) {\n\tcase MAC8390_FARALLON:\n\tcase MAC8390_APPLE:\n\t\tswitch (mac8390_testio(dev->mem_start)) {\n\t\tcase ACCESS_UNKNOWN:\n\t\t\tdev_err(&board->dev,\n\t\t\t\t\"Don't know how to access card memory\\n\");\n\t\t\treturn -ENODEV;\n\n\t\tcase ACCESS_16:\n\t\t\t \n\t\t\tei_status.reset_8390 = mac8390_no_reset;\n\t\t\tei_status.block_input = slow_sane_block_input;\n\t\t\tei_status.block_output = slow_sane_block_output;\n\t\t\tei_status.get_8390_hdr = slow_sane_get_8390_hdr;\n\t\t\tei_status.reg_offset = back4_offsets;\n\t\t\tbreak;\n\n\t\tcase ACCESS_32:\n\t\t\t \n\t\t\tei_status.reset_8390 = mac8390_no_reset;\n\t\t\tei_status.block_input = sane_block_input;\n\t\t\tei_status.block_output = sane_block_output;\n\t\t\tei_status.get_8390_hdr = sane_get_8390_hdr;\n\t\t\tei_status.reg_offset = back4_offsets;\n\t\t\taccess_bitmode = 1;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase MAC8390_ASANTE:\n\t\t \n\t\tei_status.reset_8390 = mac8390_no_reset;\n\t\tei_status.block_input = slow_sane_block_input;\n\t\tei_status.block_output = slow_sane_block_output;\n\t\tei_status.get_8390_hdr = slow_sane_get_8390_hdr;\n\t\tei_status.reg_offset = back4_offsets;\n\t\tbreak;\n\n\tcase MAC8390_CABLETRON:\n\t\t \n\t\tei_status.reset_8390 = mac8390_no_reset;\n\t\tei_status.block_input = slow_sane_block_input;\n\t\tei_status.block_output = slow_sane_block_output;\n\t\tei_status.get_8390_hdr = slow_sane_get_8390_hdr;\n\t\tei_status.reg_offset = fwrd2_offsets;\n\t\tbreak;\n\n\tcase MAC8390_DAYNA:\n\tcase MAC8390_KINETICS:\n\t\t \n\t\t \n\t\tei_status.reset_8390 = mac8390_no_reset;\n\t\tei_status.block_input = dayna_block_input;\n\t\tei_status.block_output = dayna_block_output;\n\t\tei_status.get_8390_hdr = dayna_get_8390_hdr;\n\t\tei_status.reg_offset = fwrd4_offsets;\n\t\tbreak;\n\n\tcase MAC8390_INTERLAN:\n\t\t \n\t\tei_status.reset_8390 = interlan_reset;\n\t\tei_status.block_input = slow_sane_block_input;\n\t\tei_status.block_output = slow_sane_block_output;\n\t\tei_status.get_8390_hdr = slow_sane_get_8390_hdr;\n\t\tei_status.reg_offset = fwrd4_offsets;\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(&board->dev, \"Unsupported card type\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t__NS8390_init(dev, 0);\n\n\t \n\tdev_info(&board->dev, \"%s (type %s)\\n\", board->name, cardname[type]);\n\tdev_info(&board->dev, \"MAC %pM, IRQ %d, %d KB shared memory at %#lx, %d-bit access.\\n\",\n\t\t dev->dev_addr, dev->irq,\n\t\t (unsigned int)(dev->mem_end - dev->mem_start) >> 10,\n\t\t dev->mem_start, access_bitmode ? 32 : 16);\n\treturn 0;\n}\n\nstatic int mac8390_open(struct net_device *dev)\n{\n\tint err;\n\n\t__ei_open(dev);\n\terr = request_irq(dev->irq, __ei_interrupt, 0, \"8390 Ethernet\", dev);\n\tif (err)\n\t\tpr_err(\"%s: unable to get IRQ %d\\n\", dev->name, dev->irq);\n\treturn err;\n}\n\nstatic int mac8390_close(struct net_device *dev)\n{\n\tfree_irq(dev->irq, dev);\n\t__ei_close(dev);\n\treturn 0;\n}\n\nstatic void mac8390_no_reset(struct net_device *dev)\n{\n\tstruct ei_device *ei_local = netdev_priv(dev);\n\n\tei_status.txing = 0;\n\tnetif_info(ei_local, hw, dev, \"reset not supported\\n\");\n}\n\nstatic void interlan_reset(struct net_device *dev)\n{\n\tunsigned char *target = nubus_slot_addr(IRQ2SLOT(dev->irq));\n\tstruct ei_device *ei_local = netdev_priv(dev);\n\n\tnetif_info(ei_local, hw, dev, \"Need to reset the NS8390 t=%lu...\",\n\t\t   jiffies);\n\tei_status.txing = 0;\n\ttarget[0xC0000] = 0;\n\tif (netif_msg_hw(ei_local))\n\t\tpr_cont(\"reset complete\\n\");\n}\n\n \n \nstatic void dayna_memcpy_fromcard(struct net_device *dev, void *to, int from,\n\t\t\t\t  int count)\n{\n\tvolatile unsigned char *ptr;\n\tunsigned char *target = to;\n\tfrom <<= 1;\t \n\tptr = (unsigned char *)(dev->mem_start+from);\n\t \n\tif (from & 2) {\n\t\t*target++ = ptr[-1];\n\t\tptr += 2;\n\t\tcount--;\n\t}\n\twhile (count >= 2) {\n\t\t*(unsigned short *)target = *(unsigned short volatile *)ptr;\n\t\tptr += 4;\t\t\t \n\t\ttarget += 2;\n\t\tcount -= 2;\n\t}\n\t \n\tif (count)\n\t\t*target = *ptr;\n}\n\nstatic void dayna_memcpy_tocard(struct net_device *dev, int to,\n\t\t\t\tconst void *from, int count)\n{\n\tvolatile unsigned short *ptr;\n\tconst unsigned char *src = from;\n\tto <<= 1;\t \n\tptr = (unsigned short *)(dev->mem_start+to);\n\t \n\tif (to & 2) {\t\t \n\t\tptr[-1] = (ptr[-1]&0xFF00)|*src++;\n\t\tptr++;\n\t\tcount--;\n\t}\n\twhile (count >= 2) {\n\t\t*ptr++ = *(unsigned short *)src;\t \n\t\tptr++;\t\t\t \n\t\tsrc += 2;\n\t\tcount -= 2;\n\t}\n\t \n\tif (count) {\n\t\t \n\t\t*ptr = (*ptr & 0x00FF) | (*src << 8);\n\t}\n}\n\n \nstatic void sane_get_8390_hdr(struct net_device *dev,\n\t\t\t      struct e8390_pkt_hdr *hdr, int ring_page)\n{\n\tunsigned long hdr_start = (ring_page - WD_START_PG)<<8;\n\tmemcpy_fromio(hdr, (void __iomem *)dev->mem_start + hdr_start, 4);\n\t \n\thdr->count = swab16(hdr->count);\n}\n\nstatic void sane_block_input(struct net_device *dev, int count,\n\t\t\t     struct sk_buff *skb, int ring_offset)\n{\n\tunsigned long xfer_base = ring_offset - (WD_START_PG<<8);\n\tunsigned long xfer_start = xfer_base + dev->mem_start;\n\n\tif (xfer_start + count > ei_status.rmem_end) {\n\t\t \n\t\tint semi_count = ei_status.rmem_end - xfer_start;\n\t\tmemcpy_fromio(skb->data,\n\t\t\t      (void __iomem *)dev->mem_start + xfer_base,\n\t\t\t      semi_count);\n\t\tcount -= semi_count;\n\t\tmemcpy_fromio(skb->data + semi_count,\n\t\t\t      (void __iomem *)ei_status.rmem_start, count);\n\t} else {\n\t\tmemcpy_fromio(skb->data,\n\t\t\t      (void __iomem *)dev->mem_start + xfer_base,\n\t\t\t      count);\n\t}\n}\n\nstatic void sane_block_output(struct net_device *dev, int count,\n\t\t\t      const unsigned char *buf, int start_page)\n{\n\tlong shmem = (start_page - WD_START_PG)<<8;\n\n\tmemcpy_toio((void __iomem *)dev->mem_start + shmem, buf, count);\n}\n\n \nstatic void dayna_get_8390_hdr(struct net_device *dev,\n\t\t\t       struct e8390_pkt_hdr *hdr, int ring_page)\n{\n\tunsigned long hdr_start = (ring_page - WD_START_PG)<<8;\n\n\tdayna_memcpy_fromcard(dev, hdr, hdr_start, 4);\n\t \n\thdr->count = (hdr->count & 0xFF) << 8 | (hdr->count >> 8);\n}\n\nstatic void dayna_block_input(struct net_device *dev, int count,\n\t\t\t      struct sk_buff *skb, int ring_offset)\n{\n\tunsigned long xfer_base = ring_offset - (WD_START_PG<<8);\n\tunsigned long xfer_start = xfer_base+dev->mem_start;\n\n\t \n\n\tif (xfer_start + count > ei_status.rmem_end) {\n\t\t \n\t\tint semi_count = ei_status.rmem_end - xfer_start;\n\t\tdayna_memcpy_fromcard(dev, skb->data, xfer_base, semi_count);\n\t\tcount -= semi_count;\n\t\tdayna_memcpy_fromcard(dev, skb->data + semi_count,\n\t\t\t\t      ei_status.rmem_start - dev->mem_start,\n\t\t\t\t      count);\n\t} else {\n\t\tdayna_memcpy_fromcard(dev, skb->data, xfer_base, count);\n\t}\n}\n\nstatic void dayna_block_output(struct net_device *dev, int count,\n\t\t\t       const unsigned char *buf,\n\t\t\t       int start_page)\n{\n\tlong shmem = (start_page - WD_START_PG)<<8;\n\n\tdayna_memcpy_tocard(dev, shmem, buf, count);\n}\n\n \nstatic void slow_sane_get_8390_hdr(struct net_device *dev,\n\t\t\t\t   struct e8390_pkt_hdr *hdr,\n\t\t\t\t   int ring_page)\n{\n\tunsigned long hdr_start = (ring_page - WD_START_PG)<<8;\n\tword_memcpy_fromcard(hdr, dev->mem_start + hdr_start, 4);\n\t \n\thdr->count = (hdr->count&0xFF)<<8|(hdr->count>>8);\n}\n\nstatic void slow_sane_block_input(struct net_device *dev, int count,\n\t\t\t\t  struct sk_buff *skb, int ring_offset)\n{\n\tunsigned long xfer_base = ring_offset - (WD_START_PG<<8);\n\tunsigned long xfer_start = xfer_base+dev->mem_start;\n\n\tif (xfer_start + count > ei_status.rmem_end) {\n\t\t \n\t\tint semi_count = ei_status.rmem_end - xfer_start;\n\t\tword_memcpy_fromcard(skb->data, dev->mem_start + xfer_base,\n\t\t\t\t     semi_count);\n\t\tcount -= semi_count;\n\t\tword_memcpy_fromcard(skb->data + semi_count,\n\t\t\t\t     ei_status.rmem_start, count);\n\t} else {\n\t\tword_memcpy_fromcard(skb->data, dev->mem_start + xfer_base,\n\t\t\t\t     count);\n\t}\n}\n\nstatic void slow_sane_block_output(struct net_device *dev, int count,\n\t\t\t\t   const unsigned char *buf, int start_page)\n{\n\tlong shmem = (start_page - WD_START_PG)<<8;\n\n\tword_memcpy_tocard(dev->mem_start + shmem, buf, count);\n}\n\nstatic void word_memcpy_tocard(unsigned long tp, const void *fp, int count)\n{\n\tvolatile unsigned short *to = (void *)tp;\n\tconst unsigned short *from = fp;\n\n\tcount++;\n\tcount /= 2;\n\n\twhile (count--)\n\t\t*to++ = *from++;\n}\n\nstatic void word_memcpy_fromcard(void *tp, unsigned long fp, int count)\n{\n\tunsigned short *to = tp;\n\tconst volatile unsigned short *from = (const void *)fp;\n\n\tcount++;\n\tcount /= 2;\n\n\twhile (count--)\n\t\t*to++ = *from++;\n}\n\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}