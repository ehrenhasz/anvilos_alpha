{
  "module_name": "xsurf100.c",
  "hash_id": "e7526a9e709df6b9abcf4c2c435e2c9496de320cc9752a5ca27c5beab6587f83",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/8390/xsurf100.c",
  "human_readable_source": "\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/platform_device.h>\n#include <linux/zorro.h>\n#include <net/ax88796.h>\n#include <asm/amigaints.h>\n\n#define ZORRO_PROD_INDIVIDUAL_COMPUTERS_X_SURF100 \\\n\t\tZORRO_ID(INDIVIDUAL_COMPUTERS, 0x64, 0)\n\n#define XS100_IRQSTATUS_BASE 0x40\n#define XS100_8390_BASE 0x800\n\n \n#define XS100_8390_DATA32_BASE 0x8000\n#define XS100_8390_DATA32_SIZE 0x2000\n \n#define XS100_8390_DATA_READ32_BASE 0x0880\n#define XS100_8390_DATA_WRITE32_BASE 0x0C80\n#define XS100_8390_DATA_AREA_SIZE 0x80\n\n \n#define ax_convert_addr(_a) ((void __force __iomem *)(_a))\n\n#define ei_inb(_a) z_readb(ax_convert_addr(_a))\n#define ei_outb(_v, _a) z_writeb(_v, ax_convert_addr(_a))\n\n#define ei_inw(_a) z_readw(ax_convert_addr(_a))\n#define ei_outw(_v, _a) z_writew(_v, ax_convert_addr(_a))\n\n#define ei_inb_p(_a) ei_inb(_a)\n#define ei_outb_p(_v, _a) ei_outb(_v, _a)\n\n \n#define EI_SHIFT(x) (ei_local->reg_offset[(x)])\n\n \n#define AX88796_PLATFORM\n\n#include \"8390.h\"\n\n \n#define NE_CMD\t\tEI_SHIFT(0x00)\n#define NE_RESET\tEI_SHIFT(0x1f)\n#define NE_DATAPORT\tEI_SHIFT(0x10)\n\nstruct xsurf100_ax_plat_data {\n\tstruct ax_plat_data ax;\n\tvoid __iomem *base_regs;\n\tvoid __iomem *data_area;\n};\n\nstatic int is_xsurf100_network_irq(struct platform_device *pdev)\n{\n\tstruct xsurf100_ax_plat_data *xs100 = dev_get_platdata(&pdev->dev);\n\n\treturn (readw(xs100->base_regs + XS100_IRQSTATUS_BASE) & 0xaaaa) != 0;\n}\n\n \nstatic void z_memcpy_fromio32(void *dst, const void __iomem *src, size_t bytes)\n{\n\twhile (bytes > 32) {\n\t\tasm __volatile__\n\t\t   (\"movem.l (%0)+,%%d0-%%d7\\n\"\n\t\t    \"movem.l %%d0-%%d7,(%1)\\n\"\n\t\t    \"adda.l #32,%1\" : \"=a\"(src), \"=a\"(dst)\n\t\t    : \"0\"(src), \"1\"(dst) : \"d0\", \"d1\", \"d2\", \"d3\", \"d4\",\n\t\t\t\t\t   \"d5\", \"d6\", \"d7\", \"memory\");\n\t\tbytes -= 32;\n\t}\n\twhile (bytes) {\n\t\t*(uint32_t *)dst = z_readl(src);\n\t\tsrc += 4;\n\t\tdst += 4;\n\t\tbytes -= 4;\n\t}\n}\n\nstatic void z_memcpy_toio32(void __iomem *dst, const void *src, size_t bytes)\n{\n\twhile (bytes) {\n\t\tz_writel(*(const uint32_t *)src, dst);\n\t\tsrc += 4;\n\t\tdst += 4;\n\t\tbytes -= 4;\n\t}\n}\n\nstatic void xs100_write(struct net_device *dev, const void *src,\n\t\t\tunsigned int count)\n{\n\tstruct ei_device *ei_local = netdev_priv(dev);\n\tstruct platform_device *pdev = to_platform_device(dev->dev.parent);\n\tstruct xsurf100_ax_plat_data *xs100 = dev_get_platdata(&pdev->dev);\n\n\t \n\twhile (count > XS100_8390_DATA_AREA_SIZE) {\n\t\tz_memcpy_toio32(xs100->data_area +\n\t\t\t\tXS100_8390_DATA_WRITE32_BASE, src,\n\t\t\t\tXS100_8390_DATA_AREA_SIZE);\n\t\tsrc += XS100_8390_DATA_AREA_SIZE;\n\t\tcount -= XS100_8390_DATA_AREA_SIZE;\n\t}\n\t \n\tz_memcpy_toio32(xs100->data_area + XS100_8390_DATA_WRITE32_BASE,\n\t\t\tsrc, count & ~3);\n\tsrc += count & ~3;\n\tif (count & 2) {\n\t\tei_outw(*(uint16_t *)src, ei_local->mem + NE_DATAPORT);\n\t\tsrc += 2;\n\t}\n\tif (count & 1)\n\t\tei_outb(*(uint8_t *)src, ei_local->mem + NE_DATAPORT);\n}\n\nstatic void xs100_read(struct net_device *dev, void *dst, unsigned int count)\n{\n\tstruct ei_device *ei_local = netdev_priv(dev);\n\tstruct platform_device *pdev = to_platform_device(dev->dev.parent);\n\tstruct xsurf100_ax_plat_data *xs100 = dev_get_platdata(&pdev->dev);\n\n\t \n\twhile (count > XS100_8390_DATA_AREA_SIZE) {\n\t\tz_memcpy_fromio32(dst, xs100->data_area +\n\t\t\t\t  XS100_8390_DATA_READ32_BASE,\n\t\t\t\t  XS100_8390_DATA_AREA_SIZE);\n\t\tdst += XS100_8390_DATA_AREA_SIZE;\n\t\tcount -= XS100_8390_DATA_AREA_SIZE;\n\t}\n\t \n\tz_memcpy_fromio32(dst, xs100->data_area + XS100_8390_DATA_READ32_BASE,\n\t\t\t  count & ~3);\n\tdst += count & ~3;\n\tif (count & 2) {\n\t\t*(uint16_t *)dst = ei_inw(ei_local->mem + NE_DATAPORT);\n\t\tdst += 2;\n\t}\n\tif (count & 1)\n\t\t*(uint8_t *)dst = ei_inb(ei_local->mem + NE_DATAPORT);\n}\n\n \nstatic void xs100_block_input(struct net_device *dev, int count,\n\t\t\t      struct sk_buff *skb, int ring_offset)\n{\n\tstruct ei_device *ei_local = netdev_priv(dev);\n\tvoid __iomem *nic_base = ei_local->mem;\n\tchar *buf = skb->data;\n\n\tif (ei_local->dmaing) {\n\t\tnetdev_err(dev,\n\t\t\t   \"DMAing conflict in %s [DMAstat:%d][irqlock:%d]\\n\",\n\t\t\t   __func__,\n\t\t\t   ei_local->dmaing, ei_local->irqlock);\n\t\treturn;\n\t}\n\n\tei_local->dmaing |= 0x01;\n\n\tei_outb(E8390_NODMA + E8390_PAGE0 + E8390_START, nic_base + NE_CMD);\n\tei_outb(count & 0xff, nic_base + EN0_RCNTLO);\n\tei_outb(count >> 8, nic_base + EN0_RCNTHI);\n\tei_outb(ring_offset & 0xff, nic_base + EN0_RSARLO);\n\tei_outb(ring_offset >> 8, nic_base + EN0_RSARHI);\n\tei_outb(E8390_RREAD + E8390_START, nic_base + NE_CMD);\n\n\txs100_read(dev, buf, count);\n\n\tei_local->dmaing &= ~1;\n}\n\nstatic void xs100_block_output(struct net_device *dev, int count,\n\t\t\t       const unsigned char *buf, const int start_page)\n{\n\tstruct ei_device *ei_local = netdev_priv(dev);\n\tvoid __iomem *nic_base = ei_local->mem;\n\tunsigned long dma_start;\n\n\t \n\tif (ei_local->word16 && (count & 0x01))\n\t\tcount++;\n\n\t \n\tif (ei_local->dmaing) {\n\t\tnetdev_err(dev,\n\t\t\t   \"DMAing conflict in %s [DMAstat:%d][irqlock:%d]\\n\",\n\t\t\t   __func__,\n\t\t\t   ei_local->dmaing, ei_local->irqlock);\n\t\treturn;\n\t}\n\n\tei_local->dmaing |= 0x01;\n\t \n\tei_outb(E8390_PAGE0 + E8390_START + E8390_NODMA, nic_base + NE_CMD);\n\n\tei_outb(ENISR_RDC, nic_base + EN0_ISR);\n\n\t \n\tei_outb(count & 0xff, nic_base + EN0_RCNTLO);\n\tei_outb(count >> 8, nic_base + EN0_RCNTHI);\n\tei_outb(0x00, nic_base + EN0_RSARLO);\n\tei_outb(start_page, nic_base + EN0_RSARHI);\n\n\tei_outb(E8390_RWRITE + E8390_START, nic_base + NE_CMD);\n\n\txs100_write(dev, buf, count);\n\n\tdma_start = jiffies;\n\n\twhile ((ei_inb(nic_base + EN0_ISR) & ENISR_RDC) == 0) {\n\t\tif (jiffies - dma_start > 2 * HZ / 100) {\t \n\t\t\tnetdev_warn(dev, \"timeout waiting for Tx RDC.\\n\");\n\t\t\tei_local->reset_8390(dev);\n\t\t\tax_NS8390_reinit(dev);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tei_outb(ENISR_RDC, nic_base + EN0_ISR);\t \n\tei_local->dmaing &= ~0x01;\n}\n\nstatic int xsurf100_probe(struct zorro_dev *zdev,\n\t\t\t  const struct zorro_device_id *ent)\n{\n\tstruct platform_device *pdev;\n\tstruct xsurf100_ax_plat_data ax88796_data;\n\tstruct resource res[2] = {\n\t\tDEFINE_RES_NAMED(IRQ_AMIGA_PORTS, 1, NULL,\n\t\t\t\t IORESOURCE_IRQ | IORESOURCE_IRQ_SHAREABLE),\n\t\tDEFINE_RES_MEM(zdev->resource.start + XS100_8390_BASE,\n\t\t\t       4 * 0x20)\n\t};\n\tint reg;\n\t \n\tstatic u32 reg_offsets[32];\n\tint ret = 0;\n\n\t \n\n\tif (!request_mem_region(zdev->resource.start, 0x100, zdev->name)) {\n\t\tdev_err(&zdev->dev, \"cannot reserve X-Surf 100 control registers\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tif (!request_mem_region(zdev->resource.start +\n\t\t\t\tXS100_8390_DATA32_BASE,\n\t\t\t\tXS100_8390_DATA32_SIZE,\n\t\t\t\t\"X-Surf 100 32-bit data access\")) {\n\t\tdev_err(&zdev->dev, \"cannot reserve 32-bit area\\n\");\n\t\tret = -ENXIO;\n\t\tgoto exit_req;\n\t}\n\n\tfor (reg = 0; reg < 0x20; reg++)\n\t\treg_offsets[reg] = 4 * reg;\n\n\tmemset(&ax88796_data, 0, sizeof(ax88796_data));\n\tax88796_data.ax.flags = AXFLG_HAS_EEPROM;\n\tax88796_data.ax.wordlength = 2;\n\tax88796_data.ax.dcr_val = 0x48;\n\tax88796_data.ax.rcr_val = 0x40;\n\tax88796_data.ax.reg_offsets = reg_offsets;\n\tax88796_data.ax.check_irq = is_xsurf100_network_irq;\n\tax88796_data.base_regs = ioremap(zdev->resource.start, 0x100);\n\n\t \n\tif (!ax88796_data.base_regs) {\n\t\tdev_err(&zdev->dev, \"Cannot ioremap area %pR (registers)\\n\",\n\t\t\t&zdev->resource);\n\n\t\tret = -ENXIO;\n\t\tgoto exit_req2;\n\t}\n\n\tax88796_data.data_area = ioremap(zdev->resource.start +\n\t\t\tXS100_8390_DATA32_BASE, XS100_8390_DATA32_SIZE);\n\n\t \n\tif (!ax88796_data.data_area) {\n\t\tdev_err(&zdev->dev,\n\t\t\t\"Cannot ioremap area %pR offset %x (32-bit access)\\n\",\n\t\t\t&zdev->resource,  XS100_8390_DATA32_BASE);\n\n\t\tret = -ENXIO;\n\t\tgoto exit_mem;\n\t}\n\n\tax88796_data.ax.block_output = xs100_block_output;\n\tax88796_data.ax.block_input = xs100_block_input;\n\n\tpdev = platform_device_register_resndata(&zdev->dev, \"ax88796\",\n\t\t\t\t\t\t zdev->slotaddr, res, 2,\n\t\t\t\t\t\t &ax88796_data,\n\t\t\t\t\t\t sizeof(ax88796_data));\n\n\tif (IS_ERR(pdev)) {\n\t\tdev_err(&zdev->dev, \"cannot register platform device\\n\");\n\t\tret = -ENXIO;\n\t\tgoto exit_mem2;\n\t}\n\n\tzorro_set_drvdata(zdev, pdev);\n\n\tif (!ret)\n\t\treturn 0;\n\n exit_mem2:\n\tiounmap(ax88796_data.data_area);\n\n exit_mem:\n\tiounmap(ax88796_data.base_regs);\n\n exit_req2:\n\trelease_mem_region(zdev->resource.start + XS100_8390_DATA32_BASE,\n\t\t\t   XS100_8390_DATA32_SIZE);\n\n exit_req:\n\trelease_mem_region(zdev->resource.start, 0x100);\n\n\treturn ret;\n}\n\nstatic void xsurf100_remove(struct zorro_dev *zdev)\n{\n\tstruct platform_device *pdev = zorro_get_drvdata(zdev);\n\tstruct xsurf100_ax_plat_data *xs100 = dev_get_platdata(&pdev->dev);\n\n\tplatform_device_unregister(pdev);\n\n\tiounmap(xs100->base_regs);\n\trelease_mem_region(zdev->resource.start, 0x100);\n\tiounmap(xs100->data_area);\n\trelease_mem_region(zdev->resource.start + XS100_8390_DATA32_BASE,\n\t\t\t   XS100_8390_DATA32_SIZE);\n}\n\nstatic const struct zorro_device_id xsurf100_zorro_tbl[] = {\n\t{ ZORRO_PROD_INDIVIDUAL_COMPUTERS_X_SURF100, },\n\t{ 0 }\n};\n\nMODULE_DEVICE_TABLE(zorro, xsurf100_zorro_tbl);\n\nstatic struct zorro_driver xsurf100_driver = {\n\t.name           = \"xsurf100\",\n\t.id_table       = xsurf100_zorro_tbl,\n\t.probe          = xsurf100_probe,\n\t.remove         = xsurf100_remove,\n};\n\nmodule_driver(xsurf100_driver, zorro_register_driver, zorro_unregister_driver);\n\nMODULE_DESCRIPTION(\"X-Surf 100 driver\");\nMODULE_AUTHOR(\"Michael Karcher <kernel@mkarcher.dialup.fu-berlin.de>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}