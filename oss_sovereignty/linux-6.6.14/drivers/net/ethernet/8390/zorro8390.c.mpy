{
  "module_name": "zorro8390.c",
  "hash_id": "e2fa895b8ad70d844cfd37513b2e4c97325eabee2dce311069633e2064178baa",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/8390/zorro8390.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/zorro.h>\n#include <linux/jiffies.h>\n\n#include <asm/irq.h>\n#include <asm/amigaints.h>\n#include <asm/amigahw.h>\n\n#define EI_SHIFT(x)\t\t(ei_local->reg_offset[x])\n#define ei_inb(port)\t\tin_8(port)\n#define ei_outb(val, port)\tout_8(port, val)\n#define ei_inb_p(port)\t\tin_8(port)\n#define ei_outb_p(val, port)\tout_8(port, val)\n\nstatic const char version[] =\n\t\"8390.c:v1.10cvs 9/23/94 Donald Becker (becker@cesdis.gsfc.nasa.gov)\\n\";\n\n#include \"lib8390.c\"\n\n#define DRV_NAME\t\"zorro8390\"\n\n#define NE_BASE\t\t(dev->base_addr)\n#define NE_CMD\t\t(0x00 * 2)\n#define NE_DATAPORT\t(0x10 * 2)\t \n#define NE_RESET\t(0x1f * 2)\t \n#define NE_IO_EXTENT\t(0x20 * 2)\n\n#define NE_EN0_ISR\t(0x07 * 2)\n#define NE_EN0_DCFG\t(0x0e * 2)\n\n#define NE_EN0_RSARLO\t(0x08 * 2)\n#define NE_EN0_RSARHI\t(0x09 * 2)\n#define NE_EN0_RCNTLO\t(0x0a * 2)\n#define NE_EN0_RXCR\t(0x0c * 2)\n#define NE_EN0_TXCR\t(0x0d * 2)\n#define NE_EN0_RCNTHI\t(0x0b * 2)\n#define NE_EN0_IMR\t(0x0f * 2)\n\n#define NESM_START_PG\t0x40\t \n#define NESM_STOP_PG\t0x80\t \n\n#define WORDSWAP(a)\t((((a) >> 8) & 0xff) | ((a) << 8))\n\nstatic struct card_info {\n\tzorro_id id;\n\tconst char *name;\n\tunsigned int offset;\n} cards[] = {\n\t{ ZORRO_PROD_VILLAGE_TRONIC_ARIADNE2, \"Ariadne II\", 0x0600 },\n\t{ ZORRO_PROD_INDIVIDUAL_COMPUTERS_X_SURF, \"X-Surf\", 0x8600 },\n};\n\n \nstatic void zorro8390_reset_8390(struct net_device *dev)\n{\n\tunsigned long reset_start_time = jiffies;\n\tstruct ei_device *ei_local = netdev_priv(dev);\n\n\tnetif_dbg(ei_local, hw, dev, \"resetting - t=%ld...\\n\", jiffies);\n\n\tz_writeb(z_readb(NE_BASE + NE_RESET), NE_BASE + NE_RESET);\n\n\tei_status.txing = 0;\n\tei_status.dmaing = 0;\n\n\t \n\twhile ((z_readb(NE_BASE + NE_EN0_ISR) & ENISR_RESET) == 0)\n\t\tif (time_after(jiffies, reset_start_time + 2 * HZ / 100)) {\n\t\t\tnetdev_warn(dev, \"%s: did not complete\\n\", __func__);\n\t\t\tbreak;\n\t\t}\n\tz_writeb(ENISR_RESET, NE_BASE + NE_EN0_ISR);\t \n}\n\n \nstatic void zorro8390_get_8390_hdr(struct net_device *dev,\n\t\t\t\t   struct e8390_pkt_hdr *hdr, int ring_page)\n{\n\tint nic_base = dev->base_addr;\n\tint cnt;\n\tshort *ptrs;\n\n\t \n\tif (ei_status.dmaing) {\n\t\tnetdev_warn(dev,\n\t\t\t    \"%s: DMAing conflict [DMAstat:%d][irqlock:%d]\\n\",\n\t\t\t    __func__, ei_status.dmaing, ei_status.irqlock);\n\t\treturn;\n\t}\n\n\tei_status.dmaing |= 0x01;\n\tz_writeb(E8390_NODMA + E8390_PAGE0 + E8390_START, nic_base + NE_CMD);\n\tz_writeb(ENISR_RDC, nic_base + NE_EN0_ISR);\n\tz_writeb(sizeof(struct e8390_pkt_hdr), nic_base + NE_EN0_RCNTLO);\n\tz_writeb(0, nic_base + NE_EN0_RCNTHI);\n\tz_writeb(0, nic_base + NE_EN0_RSARLO);\t\t \n\tz_writeb(ring_page, nic_base + NE_EN0_RSARHI);\n\tz_writeb(E8390_RREAD+E8390_START, nic_base + NE_CMD);\n\n\tptrs = (short *)hdr;\n\tfor (cnt = 0; cnt < sizeof(struct e8390_pkt_hdr) >> 1; cnt++)\n\t\t*ptrs++ = z_readw(NE_BASE + NE_DATAPORT);\n\n\tz_writeb(ENISR_RDC, nic_base + NE_EN0_ISR);\t \n\n\thdr->count = WORDSWAP(hdr->count);\n\n\tei_status.dmaing &= ~0x01;\n}\n\n \nstatic void zorro8390_block_input(struct net_device *dev, int count,\n\t\t\t\t  struct sk_buff *skb, int ring_offset)\n{\n\tint nic_base = dev->base_addr;\n\tchar *buf = skb->data;\n\tshort *ptrs;\n\tint cnt;\n\n\t \n\tif (ei_status.dmaing) {\n\t\tnetdev_err(dev, \"%s: DMAing conflict [DMAstat:%d][irqlock:%d]\\n\",\n\t\t\t   __func__, ei_status.dmaing, ei_status.irqlock);\n\t\treturn;\n\t}\n\tei_status.dmaing |= 0x01;\n\tz_writeb(E8390_NODMA + E8390_PAGE0 + E8390_START, nic_base + NE_CMD);\n\tz_writeb(ENISR_RDC, nic_base + NE_EN0_ISR);\n\tz_writeb(count & 0xff, nic_base + NE_EN0_RCNTLO);\n\tz_writeb(count >> 8, nic_base + NE_EN0_RCNTHI);\n\tz_writeb(ring_offset & 0xff, nic_base + NE_EN0_RSARLO);\n\tz_writeb(ring_offset >> 8, nic_base + NE_EN0_RSARHI);\n\tz_writeb(E8390_RREAD+E8390_START, nic_base + NE_CMD);\n\tptrs = (short *)buf;\n\tfor (cnt = 0; cnt < count >> 1; cnt++)\n\t\t*ptrs++ = z_readw(NE_BASE + NE_DATAPORT);\n\tif (count & 0x01)\n\t\tbuf[count - 1] = z_readb(NE_BASE + NE_DATAPORT);\n\n\tz_writeb(ENISR_RDC, nic_base + NE_EN0_ISR);\t \n\tei_status.dmaing &= ~0x01;\n}\n\nstatic void zorro8390_block_output(struct net_device *dev, int count,\n\t\t\t\t   const unsigned char *buf,\n\t\t\t\t   const int start_page)\n{\n\tint nic_base = NE_BASE;\n\tunsigned long dma_start;\n\tshort *ptrs;\n\tint cnt;\n\n\t \n\tif (count & 0x01)\n\t\tcount++;\n\n\t \n\tif (ei_status.dmaing) {\n\t\tnetdev_err(dev, \"%s: DMAing conflict [DMAstat:%d][irqlock:%d]\\n\",\n\t\t\t   __func__, ei_status.dmaing, ei_status.irqlock);\n\t\treturn;\n\t}\n\tei_status.dmaing |= 0x01;\n\t \n\tz_writeb(E8390_PAGE0+E8390_START+E8390_NODMA, nic_base + NE_CMD);\n\n\tz_writeb(ENISR_RDC, nic_base + NE_EN0_ISR);\n\n\t \n\tz_writeb(count & 0xff, nic_base + NE_EN0_RCNTLO);\n\tz_writeb(count >> 8,   nic_base + NE_EN0_RCNTHI);\n\tz_writeb(0x00, nic_base + NE_EN0_RSARLO);\n\tz_writeb(start_page, nic_base + NE_EN0_RSARHI);\n\n\tz_writeb(E8390_RWRITE + E8390_START, nic_base + NE_CMD);\n\tptrs = (short *)buf;\n\tfor (cnt = 0; cnt < count >> 1; cnt++)\n\t\tz_writew(*ptrs++, NE_BASE + NE_DATAPORT);\n\n\tdma_start = jiffies;\n\n\twhile ((z_readb(NE_BASE + NE_EN0_ISR) & ENISR_RDC) == 0)\n\t\tif (time_after(jiffies, dma_start + 2 * HZ / 100)) {\n\t\t\t\t\t \n\t\t\tnetdev_warn(dev, \"timeout waiting for Tx RDC\\n\");\n\t\t\tzorro8390_reset_8390(dev);\n\t\t\t__NS8390_init(dev, 1);\n\t\t\tbreak;\n\t\t}\n\n\tz_writeb(ENISR_RDC, nic_base + NE_EN0_ISR);\t \n\tei_status.dmaing &= ~0x01;\n}\n\nstatic int zorro8390_open(struct net_device *dev)\n{\n\t__ei_open(dev);\n\treturn 0;\n}\n\nstatic int zorro8390_close(struct net_device *dev)\n{\n\tstruct ei_device *ei_local = netdev_priv(dev);\n\n\tnetif_dbg(ei_local, ifdown, dev, \"Shutting down ethercard\\n\");\n\t__ei_close(dev);\n\treturn 0;\n}\n\nstatic void zorro8390_remove_one(struct zorro_dev *z)\n{\n\tstruct net_device *dev = zorro_get_drvdata(z);\n\n\tunregister_netdev(dev);\n\tfree_irq(IRQ_AMIGA_PORTS, dev);\n\trelease_mem_region(ZTWO_PADDR(dev->base_addr), NE_IO_EXTENT * 2);\n\tfree_netdev(dev);\n}\n\nstatic struct zorro_device_id zorro8390_zorro_tbl[] = {\n\t{ ZORRO_PROD_VILLAGE_TRONIC_ARIADNE2, },\n\t{ ZORRO_PROD_INDIVIDUAL_COMPUTERS_X_SURF, },\n\t{ 0 }\n};\nMODULE_DEVICE_TABLE(zorro, zorro8390_zorro_tbl);\n\nstatic const struct net_device_ops zorro8390_netdev_ops = {\n\t.ndo_open\t\t= zorro8390_open,\n\t.ndo_stop\t\t= zorro8390_close,\n\t.ndo_start_xmit\t\t= __ei_start_xmit,\n\t.ndo_tx_timeout\t\t= __ei_tx_timeout,\n\t.ndo_get_stats\t\t= __ei_get_stats,\n\t.ndo_set_rx_mode\t= __ei_set_multicast_list,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_set_mac_address\t= eth_mac_addr,\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\t.ndo_poll_controller\t= __ei_poll,\n#endif\n};\n\nstatic int zorro8390_init(struct net_device *dev, unsigned long board,\n\t\t\t  const char *name, void __iomem *ioaddr)\n{\n\tint i;\n\tint err;\n\tunsigned char SA_prom[32];\n\tint start_page, stop_page;\n\tstatic u32 zorro8390_offsets[16] = {\n\t\t0x00, 0x02, 0x04, 0x06, 0x08, 0x0a, 0x0c, 0x0e,\n\t\t0x10, 0x12, 0x14, 0x16, 0x18, 0x1a, 0x1c, 0x1e,\n\t};\n\n\t \n\t{\n\t\tunsigned long reset_start_time = jiffies;\n\n\t\tz_writeb(z_readb(ioaddr + NE_RESET), ioaddr + NE_RESET);\n\n\t\twhile ((z_readb(ioaddr + NE_EN0_ISR) & ENISR_RESET) == 0)\n\t\t\tif (time_after(jiffies,\n\t\t\t\t       reset_start_time + 2 * HZ / 100)) {\n\t\t\t\tnetdev_warn(dev, \"not found (no reset ack)\\n\");\n\t\t\t\treturn -ENODEV;\n\t\t\t}\n\n\t\tz_writeb(0xff, ioaddr + NE_EN0_ISR);\t \n\t}\n\n\t \n\t{\n\t\tstatic const struct {\n\t\t\tu32 value;\n\t\t\tu32 offset;\n\t\t} program_seq[] = {\n\t\t\t{E8390_NODMA + E8390_PAGE0 + E8390_STOP, NE_CMD},\n\t\t\t\t\t\t \n\t\t\t{0x48,\tNE_EN0_DCFG},\t \n\t\t\t{0x00,\tNE_EN0_RCNTLO},\t \n\t\t\t{0x00,\tNE_EN0_RCNTHI},\n\t\t\t{0x00,\tNE_EN0_IMR},\t \n\t\t\t{0xFF,\tNE_EN0_ISR},\n\t\t\t{E8390_RXOFF, NE_EN0_RXCR},  \n\t\t\t{E8390_TXOFF, NE_EN0_TXCR},  \n\t\t\t{32,\tNE_EN0_RCNTLO},\n\t\t\t{0x00,\tNE_EN0_RCNTHI},\n\t\t\t{0x00,\tNE_EN0_RSARLO},\t \n\t\t\t{0x00,\tNE_EN0_RSARHI},\n\t\t\t{E8390_RREAD + E8390_START, NE_CMD},\n\t\t};\n\t\tfor (i = 0; i < ARRAY_SIZE(program_seq); i++)\n\t\t\tz_writeb(program_seq[i].value,\n\t\t\t\t ioaddr + program_seq[i].offset);\n\t}\n\tfor (i = 0; i < 16; i++) {\n\t\tSA_prom[i] = z_readb(ioaddr + NE_DATAPORT);\n\t\t(void)z_readb(ioaddr + NE_DATAPORT);\n\t}\n\n\t \n\tz_writeb(0x49, ioaddr + NE_EN0_DCFG);\n\tstart_page = NESM_START_PG;\n\tstop_page = NESM_STOP_PG;\n\n\tdev->base_addr = (unsigned long)ioaddr;\n\tdev->irq = IRQ_AMIGA_PORTS;\n\n\t \n\ti = request_irq(IRQ_AMIGA_PORTS, __ei_interrupt,\n\t\t\tIRQF_SHARED, DRV_NAME, dev);\n\tif (i)\n\t\treturn i;\n\n\teth_hw_addr_set(dev, SA_prom);\n\n\tpr_debug(\"Found ethernet address: %pM\\n\", dev->dev_addr);\n\n\tei_status.name = name;\n\tei_status.tx_start_page = start_page;\n\tei_status.stop_page = stop_page;\n\tei_status.word16 = 1;\n\n\tei_status.rx_start_page = start_page + TX_PAGES;\n\n\tei_status.reset_8390 = zorro8390_reset_8390;\n\tei_status.block_input = zorro8390_block_input;\n\tei_status.block_output = zorro8390_block_output;\n\tei_status.get_8390_hdr = zorro8390_get_8390_hdr;\n\tei_status.reg_offset = zorro8390_offsets;\n\n\tdev->netdev_ops = &zorro8390_netdev_ops;\n\t__NS8390_init(dev, 0);\n\n\terr = register_netdev(dev);\n\tif (err) {\n\t\tfree_irq(IRQ_AMIGA_PORTS, dev);\n\t\treturn err;\n\t}\n\n\tnetdev_info(dev, \"%s at 0x%08lx, Ethernet Address %pM\\n\",\n\t\t    name, board, dev->dev_addr);\n\n\treturn 0;\n}\n\nstatic int zorro8390_init_one(struct zorro_dev *z,\n\t\t\t      const struct zorro_device_id *ent)\n{\n\tstruct net_device *dev;\n\tunsigned long board, ioaddr;\n\tint err, i;\n\n\tfor (i = ARRAY_SIZE(cards) - 1; i >= 0; i--)\n\t\tif (z->id == cards[i].id)\n\t\t\tbreak;\n\tif (i < 0)\n\t\treturn -ENODEV;\n\n\tboard = z->resource.start;\n\tioaddr = board + cards[i].offset;\n\tdev = ____alloc_ei_netdev(0);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\tif (!request_mem_region(ioaddr, NE_IO_EXTENT * 2, DRV_NAME)) {\n\t\tfree_netdev(dev);\n\t\treturn -EBUSY;\n\t}\n\terr = zorro8390_init(dev, board, cards[i].name, ZTWO_VADDR(ioaddr));\n\tif (err) {\n\t\trelease_mem_region(ioaddr, NE_IO_EXTENT * 2);\n\t\tfree_netdev(dev);\n\t\treturn err;\n\t}\n\tzorro_set_drvdata(z, dev);\n\treturn 0;\n}\n\nstatic struct zorro_driver zorro8390_driver = {\n\t.name\t\t= \"zorro8390\",\n\t.id_table\t= zorro8390_zorro_tbl,\n\t.probe\t\t= zorro8390_init_one,\n\t.remove\t\t= zorro8390_remove_one,\n};\n\nstatic int __init zorro8390_init_module(void)\n{\n\treturn zorro_register_driver(&zorro8390_driver);\n}\n\nstatic void __exit zorro8390_cleanup_module(void)\n{\n\tzorro_unregister_driver(&zorro8390_driver);\n}\n\nmodule_init(zorro8390_init_module);\nmodule_exit(zorro8390_cleanup_module);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}