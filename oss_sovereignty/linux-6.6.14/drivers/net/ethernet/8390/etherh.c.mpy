{
  "module_name": "etherh.c",
  "hash_id": "55c5c0e8a6826812900c75c28f3388c9a7c0104d8a00541aa1894e8c35d76f94",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/8390/etherh.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/fcntl.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/in.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/ethtool.h>\n#include <linux/skbuff.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/init.h>\n#include <linux/bitops.h>\n#include <linux/jiffies.h>\n\n#include <asm/ecard.h>\n#include <asm/io.h>\n#include <asm/system_info.h>\n\n#define EI_SHIFT(x)\t(ei_local->reg_offset[x])\n\n#define ei_inb(_p)\t readb((void __iomem *)_p)\n#define ei_outb(_v,_p)\t writeb(_v,(void __iomem *)_p)\n#define ei_inb_p(_p)\t readb((void __iomem *)_p)\n#define ei_outb_p(_v,_p) writeb(_v,(void __iomem *)_p)\n\n#define DRV_NAME\t\"etherh\"\n#define DRV_VERSION\t\"1.11\"\n\nstatic char version[] =\n\t\"EtherH/EtherM Driver (c) 2002-2004 Russell King \" DRV_VERSION \"\\n\";\n\n#include \"lib8390.c\"\n\nstruct etherh_priv {\n\tvoid __iomem\t*ioc_fast;\n\tvoid __iomem\t*memc;\n\tvoid __iomem\t*dma_base;\n\tunsigned int\tid;\n\tvoid __iomem\t*ctrl_port;\n\tunsigned char\tctrl;\n\tu32\t\tsupported;\n};\n\nstruct etherh_data {\n\tunsigned long\tns8390_offset;\n\tunsigned long\tdataport_offset;\n\tunsigned long\tctrlport_offset;\n\tint\t\tctrl_ioc;\n\tconst char\tname[16];\n\tu32\t\tsupported;\n\tunsigned char\ttx_start_page;\n\tunsigned char\tstop_page;\n};\n\nMODULE_AUTHOR(\"Russell King\");\nMODULE_DESCRIPTION(\"EtherH/EtherM driver\");\nMODULE_LICENSE(\"GPL\");\n\n#define ETHERH500_DATAPORT\t0x800\t \n#define ETHERH500_NS8390\t0x000\t \n#define ETHERH500_CTRLPORT\t0x800\t \n\n#define ETHERH600_DATAPORT\t0x040\t \n#define ETHERH600_NS8390\t0x800\t \n#define ETHERH600_CTRLPORT\t0x200\t \n\n#define ETHERH_CP_IE\t\t1\n#define ETHERH_CP_IF\t\t2\n#define ETHERH_CP_HEARTBEAT\t2\n\n#define ETHERH_TX_START_PAGE\t1\n#define ETHERH_STOP_PAGE\t127\n\n \n#define ETHERM_DATAPORT\t\t0x200\t \n#define ETHERM_NS8390\t\t0x800\t \n#define ETHERM_CTRLPORT\t\t0x23c\t \n\n#define ETHERM_TX_START_PAGE\t64\n#define ETHERM_STOP_PAGE\t127\n\n \n\n#define etherh_priv(dev) \\\n ((struct etherh_priv *)(((char *)netdev_priv(dev)) + sizeof(struct ei_device)))\n\nstatic inline void etherh_set_ctrl(struct etherh_priv *eh, unsigned char mask)\n{\n\tunsigned char ctrl = eh->ctrl | mask;\n\teh->ctrl = ctrl;\n\twriteb(ctrl, eh->ctrl_port);\n}\n\nstatic inline void etherh_clr_ctrl(struct etherh_priv *eh, unsigned char mask)\n{\n\tunsigned char ctrl = eh->ctrl & ~mask;\n\teh->ctrl = ctrl;\n\twriteb(ctrl, eh->ctrl_port);\n}\n\nstatic inline unsigned int etherh_get_stat(struct etherh_priv *eh)\n{\n\treturn readb(eh->ctrl_port);\n}\n\n\n\n\nstatic void etherh_irq_enable(ecard_t *ec, int irqnr)\n{\n\tstruct etherh_priv *eh = ec->irq_data;\n\n\tetherh_set_ctrl(eh, ETHERH_CP_IE);\n}\n\nstatic void etherh_irq_disable(ecard_t *ec, int irqnr)\n{\n\tstruct etherh_priv *eh = ec->irq_data;\n\n\tetherh_clr_ctrl(eh, ETHERH_CP_IE);\n}\n\nstatic expansioncard_ops_t etherh_ops = {\n\t.irqenable\t= etherh_irq_enable,\n\t.irqdisable\t= etherh_irq_disable,\n};\n\n\n\n\nstatic void\netherh_setif(struct net_device *dev)\n{\n\tstruct ei_device *ei_local = netdev_priv(dev);\n\tunsigned long flags;\n\tvoid __iomem *addr;\n\n\tlocal_irq_save(flags);\n\n\t \n\tswitch (etherh_priv(dev)->id) {\n\tcase PROD_I3_ETHERLAN600:\n\tcase PROD_I3_ETHERLAN600A:\n\t\taddr = (void __iomem *)dev->base_addr + EN0_RCNTHI;\n\n\t\tswitch (dev->if_port) {\n\t\tcase IF_PORT_10BASE2:\n\t\t\twriteb((readb(addr) & 0xf8) | 1, addr);\n\t\t\tbreak;\n\t\tcase IF_PORT_10BASET:\n\t\t\twriteb((readb(addr) & 0xf8), addr);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase PROD_I3_ETHERLAN500:\n\t\tswitch (dev->if_port) {\n\t\tcase IF_PORT_10BASE2:\n\t\t\tetherh_clr_ctrl(etherh_priv(dev), ETHERH_CP_IF);\n\t\t\tbreak;\n\n\t\tcase IF_PORT_10BASET:\n\t\t\tetherh_set_ctrl(etherh_priv(dev), ETHERH_CP_IF);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\tlocal_irq_restore(flags);\n}\n\nstatic int\netherh_getifstat(struct net_device *dev)\n{\n\tstruct ei_device *ei_local = netdev_priv(dev);\n\tvoid __iomem *addr;\n\tint stat = 0;\n\n\tswitch (etherh_priv(dev)->id) {\n\tcase PROD_I3_ETHERLAN600:\n\tcase PROD_I3_ETHERLAN600A:\n\t\taddr = (void __iomem *)dev->base_addr + EN0_RCNTHI;\n\t\tswitch (dev->if_port) {\n\t\tcase IF_PORT_10BASE2:\n\t\t\tstat = 1;\n\t\t\tbreak;\n\t\tcase IF_PORT_10BASET:\n\t\t\tstat = readb(addr) & 4;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase PROD_I3_ETHERLAN500:\n\t\tswitch (dev->if_port) {\n\t\tcase IF_PORT_10BASE2:\n\t\t\tstat = 1;\n\t\t\tbreak;\n\t\tcase IF_PORT_10BASET:\n\t\t\tstat = etherh_get_stat(etherh_priv(dev)) & ETHERH_CP_HEARTBEAT;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tstat = 0;\n\t\tbreak;\n\t}\n\n\treturn stat != 0;\n}\n\n \nstatic int etherh_set_config(struct net_device *dev, struct ifmap *map)\n{\n\tswitch (map->port) {\n\tcase IF_PORT_10BASE2:\n\tcase IF_PORT_10BASET:\n\t\t \n\t\tdev->flags &= ~IFF_AUTOMEDIA;\n\t\tdev->if_port = map->port;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tetherh_setif(dev);\n\n\treturn 0;\n}\n\n \nstatic void\netherh_reset(struct net_device *dev)\n{\n\tstruct ei_device *ei_local = netdev_priv(dev);\n\tvoid __iomem *addr = (void __iomem *)dev->base_addr;\n\n\twriteb(E8390_NODMA+E8390_PAGE0+E8390_STOP, addr);\n\n\t \n\tif (dev->flags & IFF_AUTOMEDIA && ei_local->interface_num) {\n\t\tei_local->interface_num = 0;\n\n\t\tif (dev->if_port == IF_PORT_10BASET)\n\t\t\tdev->if_port = IF_PORT_10BASE2;\n\t\telse\n\t\t\tdev->if_port = IF_PORT_10BASET;\n\n\t\tetherh_setif(dev);\n\t}\n}\n\n \nstatic void\netherh_block_output (struct net_device *dev, int count, const unsigned char *buf, int start_page)\n{\n\tstruct ei_device *ei_local = netdev_priv(dev);\n\tunsigned long dma_start;\n\tvoid __iomem *dma_base, *addr;\n\n\tif (ei_local->dmaing) {\n\t\tnetdev_err(dev, \"DMAing conflict in etherh_block_input: \"\n\t\t\t   \" DMAstat %d irqlock %d\\n\",\n\t\t\t   ei_local->dmaing, ei_local->irqlock);\n\t\treturn;\n\t}\n\n\t \n\tif (count & 1 && ei_local->word16)\n\t\tcount++;\n\n\tei_local->dmaing = 1;\n\n\taddr = (void __iomem *)dev->base_addr;\n\tdma_base = etherh_priv(dev)->dma_base;\n\n\tcount = (count + 1) & ~1;\n\twriteb (E8390_NODMA | E8390_PAGE0 | E8390_START, addr + E8390_CMD);\n\n\twriteb (0x42, addr + EN0_RCNTLO);\n\twriteb (0x00, addr + EN0_RCNTHI);\n\twriteb (0x42, addr + EN0_RSARLO);\n\twriteb (0x00, addr + EN0_RSARHI);\n\twriteb (E8390_RREAD | E8390_START, addr + E8390_CMD);\n\n\tudelay (1);\n\n\twriteb (ENISR_RDC, addr + EN0_ISR);\n\twriteb (count, addr + EN0_RCNTLO);\n\twriteb (count >> 8, addr + EN0_RCNTHI);\n\twriteb (0, addr + EN0_RSARLO);\n\twriteb (start_page, addr + EN0_RSARHI);\n\twriteb (E8390_RWRITE | E8390_START, addr + E8390_CMD);\n\n\tif (ei_local->word16)\n\t\twritesw (dma_base, buf, count >> 1);\n\telse\n\t\twritesb (dma_base, buf, count);\n\n\tdma_start = jiffies;\n\n\twhile ((readb (addr + EN0_ISR) & ENISR_RDC) == 0)\n\t\tif (time_after(jiffies, dma_start + 2*HZ/100)) {  \n\t\t\tnetdev_warn(dev, \"timeout waiting for TX RDC\\n\");\n\t\t\tetherh_reset (dev);\n\t\t\t__NS8390_init (dev, 1);\n\t\t\tbreak;\n\t\t}\n\n\twriteb (ENISR_RDC, addr + EN0_ISR);\n\tei_local->dmaing = 0;\n}\n\n \nstatic void\netherh_block_input (struct net_device *dev, int count, struct sk_buff *skb, int ring_offset)\n{\n\tstruct ei_device *ei_local = netdev_priv(dev);\n\tunsigned char *buf;\n\tvoid __iomem *dma_base, *addr;\n\n\tif (ei_local->dmaing) {\n\t\tnetdev_err(dev, \"DMAing conflict in etherh_block_input: \"\n\t\t\t   \" DMAstat %d irqlock %d\\n\",\n\t\t\t   ei_local->dmaing, ei_local->irqlock);\n\t\treturn;\n\t}\n\n\tei_local->dmaing = 1;\n\n\taddr = (void __iomem *)dev->base_addr;\n\tdma_base = etherh_priv(dev)->dma_base;\n\n\tbuf = skb->data;\n\twriteb (E8390_NODMA | E8390_PAGE0 | E8390_START, addr + E8390_CMD);\n\twriteb (count, addr + EN0_RCNTLO);\n\twriteb (count >> 8, addr + EN0_RCNTHI);\n\twriteb (ring_offset, addr + EN0_RSARLO);\n\twriteb (ring_offset >> 8, addr + EN0_RSARHI);\n\twriteb (E8390_RREAD | E8390_START, addr + E8390_CMD);\n\n\tif (ei_local->word16) {\n\t\treadsw (dma_base, buf, count >> 1);\n\t\tif (count & 1)\n\t\t\tbuf[count - 1] = readb (dma_base);\n\t} else\n\t\treadsb (dma_base, buf, count);\n\n\twriteb (ENISR_RDC, addr + EN0_ISR);\n\tei_local->dmaing = 0;\n}\n\n \nstatic void\netherh_get_header (struct net_device *dev, struct e8390_pkt_hdr *hdr, int ring_page)\n{\n\tstruct ei_device *ei_local = netdev_priv(dev);\n\tvoid __iomem *dma_base, *addr;\n\n\tif (ei_local->dmaing) {\n\t\tnetdev_err(dev, \"DMAing conflict in etherh_get_header: \"\n\t\t\t   \" DMAstat %d irqlock %d\\n\",\n\t\t\t   ei_local->dmaing, ei_local->irqlock);\n\t\treturn;\n\t}\n\n\tei_local->dmaing = 1;\n\n\taddr = (void __iomem *)dev->base_addr;\n\tdma_base = etherh_priv(dev)->dma_base;\n\n\twriteb (E8390_NODMA | E8390_PAGE0 | E8390_START, addr + E8390_CMD);\n\twriteb (sizeof (*hdr), addr + EN0_RCNTLO);\n\twriteb (0, addr + EN0_RCNTHI);\n\twriteb (0, addr + EN0_RSARLO);\n\twriteb (ring_page, addr + EN0_RSARHI);\n\twriteb (E8390_RREAD | E8390_START, addr + E8390_CMD);\n\n\tif (ei_local->word16)\n\t\treadsw (dma_base, hdr, sizeof (*hdr) >> 1);\n\telse\n\t\treadsb (dma_base, hdr, sizeof (*hdr));\n\n\twriteb (ENISR_RDC, addr + EN0_ISR);\n\tei_local->dmaing = 0;\n}\n\n \nstatic int\netherh_open(struct net_device *dev)\n{\n\tstruct ei_device *ei_local = netdev_priv(dev);\n\n\tif (request_irq(dev->irq, __ei_interrupt, 0, dev->name, dev))\n\t\treturn -EAGAIN;\n\n\t \n\tei_local->interface_num = 0;\n\n\t \n\tif (dev->flags & IFF_AUTOMEDIA) {\n\t\tdev->if_port = IF_PORT_10BASET;\n\t\tetherh_setif(dev);\n\t\tmdelay(1);\n\t\tif (!etherh_getifstat(dev)) {\n\t\t\tdev->if_port = IF_PORT_10BASE2;\n\t\t\tetherh_setif(dev);\n\t\t}\n\t} else\n\t\tetherh_setif(dev);\n\n\tetherh_reset(dev);\n\t__ei_open(dev);\n\n\treturn 0;\n}\n\n \nstatic int\netherh_close(struct net_device *dev)\n{\n\t__ei_close (dev);\n\tfree_irq (dev->irq, dev);\n\treturn 0;\n}\n\n \nstatic int etherh_addr(char *addr, struct expansion_card *ec)\n{\n\tstruct in_chunk_dir cd;\n\tchar *s;\n\t\n\tif (!ecard_readchunk(&cd, ec, 0xf5, 0)) {\n\t\tprintk(KERN_ERR \"%s: unable to read module description string\\n\",\n\t\t       dev_name(&ec->dev));\n\t\tgoto no_addr;\n\t}\n\n\ts = strchr(cd.d.string, '(');\n\tif (s) {\n\t\tint i;\n\n\t\tfor (i = 0; i < 6; i++) {\n\t\t\taddr[i] = simple_strtoul(s + 1, &s, 0x10);\n\t\t\tif (*s != (i == 5? ')' : ':'))\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (i == 6)\n\t\t\treturn 0;\n\t}\n\n\tprintk(KERN_ERR \"%s: unable to parse MAC address: %s\\n\",\n\t       dev_name(&ec->dev), cd.d.string);\n\n no_addr:\n\treturn -ENODEV;\n}\n\n \nstatic int __init etherm_addr(char *addr)\n{\n\tunsigned int serial;\n\n\tif (system_serial_low == 0 && system_serial_high == 0)\n\t\treturn -ENODEV;\n\n\tserial = system_serial_low | system_serial_high;\n\n\taddr[0] = 0;\n\taddr[1] = 0;\n\taddr[2] = 0xa4;\n\taddr[3] = 0x10 + (serial >> 24);\n\taddr[4] = serial >> 16;\n\taddr[5] = serial >> 8;\n\treturn 0;\n}\n\nstatic void etherh_get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *info)\n{\n\tstrscpy(info->driver, DRV_NAME, sizeof(info->driver));\n\tstrscpy(info->version, DRV_VERSION, sizeof(info->version));\n\tstrscpy(info->bus_info, dev_name(dev->dev.parent),\n\t\tsizeof(info->bus_info));\n}\n\nstatic int etherh_get_link_ksettings(struct net_device *dev,\n\t\t\t\t     struct ethtool_link_ksettings *cmd)\n{\n\tethtool_convert_legacy_u32_to_link_mode(cmd->link_modes.supported,\n\t\t\t\t\t\tetherh_priv(dev)->supported);\n\tcmd->base.speed = SPEED_10;\n\tcmd->base.duplex = DUPLEX_HALF;\n\tcmd->base.port = dev->if_port == IF_PORT_10BASET ? PORT_TP : PORT_BNC;\n\tcmd->base.autoneg = (dev->flags & IFF_AUTOMEDIA ? AUTONEG_ENABLE :\n\t\t\t\t\t\t\t  AUTONEG_DISABLE);\n\treturn 0;\n}\n\nstatic int etherh_set_link_ksettings(struct net_device *dev,\n\t\t\t\t     const struct ethtool_link_ksettings *cmd)\n{\n\tswitch (cmd->base.autoneg) {\n\tcase AUTONEG_ENABLE:\n\t\tdev->flags |= IFF_AUTOMEDIA;\n\t\tbreak;\n\n\tcase AUTONEG_DISABLE:\n\t\tswitch (cmd->base.port) {\n\t\tcase PORT_TP:\n\t\t\tdev->if_port = IF_PORT_10BASET;\n\t\t\tbreak;\n\n\t\tcase PORT_BNC:\n\t\t\tdev->if_port = IF_PORT_10BASE2;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tdev->flags &= ~IFF_AUTOMEDIA;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tetherh_setif(dev);\n\n\treturn 0;\n}\n\nstatic u32 etherh_get_msglevel(struct net_device *dev)\n{\n\tstruct ei_device *ei_local = netdev_priv(dev);\n\n\treturn ei_local->msg_enable;\n}\n\nstatic void etherh_set_msglevel(struct net_device *dev, u32 v)\n{\n\tstruct ei_device *ei_local = netdev_priv(dev);\n\n\tei_local->msg_enable = v;\n}\n\nstatic const struct ethtool_ops etherh_ethtool_ops = {\n\t.get_drvinfo\t\t= etherh_get_drvinfo,\n\t.get_ts_info\t\t= ethtool_op_get_ts_info,\n\t.get_msglevel\t\t= etherh_get_msglevel,\n\t.set_msglevel\t\t= etherh_set_msglevel,\n\t.get_link_ksettings\t= etherh_get_link_ksettings,\n\t.set_link_ksettings\t= etherh_set_link_ksettings,\n};\n\nstatic const struct net_device_ops etherh_netdev_ops = {\n\t.ndo_open\t\t= etherh_open,\n\t.ndo_stop\t\t= etherh_close,\n\t.ndo_set_config\t\t= etherh_set_config,\n\t.ndo_start_xmit\t\t= __ei_start_xmit,\n\t.ndo_tx_timeout\t\t= __ei_tx_timeout,\n\t.ndo_get_stats\t\t= __ei_get_stats,\n\t.ndo_set_rx_mode\t= __ei_set_multicast_list,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_set_mac_address\t= eth_mac_addr,\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\t.ndo_poll_controller\t= __ei_poll,\n#endif\n};\n\nstatic u32 etherh_regoffsets[16];\nstatic u32 etherm_regoffsets[16];\n\nstatic int\netherh_probe(struct expansion_card *ec, const struct ecard_id *id)\n{\n\tconst struct etherh_data *data = id->data;\n\tstruct ei_device *ei_local;\n\tstruct net_device *dev;\n\tstruct etherh_priv *eh;\n\tu8 addr[ETH_ALEN];\n\tint ret;\n\n\tret = ecard_request_resources(ec);\n\tif (ret)\n\t\tgoto out;\n\n\tdev = ____alloc_ei_netdev(sizeof(struct etherh_priv));\n\tif (!dev) {\n\t\tret = -ENOMEM;\n\t\tgoto release;\n\t}\n\n\tSET_NETDEV_DEV(dev, &ec->dev);\n\n\tdev->netdev_ops\t\t= &etherh_netdev_ops;\n\tdev->irq\t\t= ec->irq;\n\tdev->ethtool_ops\t= &etherh_ethtool_ops;\n\n\tif (data->supported & SUPPORTED_Autoneg)\n\t\tdev->flags |= IFF_AUTOMEDIA;\n\tif (data->supported & SUPPORTED_TP) {\n\t\tdev->flags |= IFF_PORTSEL;\n\t\tdev->if_port = IF_PORT_10BASET;\n\t} else if (data->supported & SUPPORTED_BNC) {\n\t\tdev->flags |= IFF_PORTSEL;\n\t\tdev->if_port = IF_PORT_10BASE2;\n\t} else\n\t\tdev->if_port = IF_PORT_UNKNOWN;\n\n\teh = etherh_priv(dev);\n\teh->supported\t\t= data->supported;\n\teh->ctrl\t\t= 0;\n\teh->id\t\t\t= ec->cid.product;\n\teh->memc\t\t= ecardm_iomap(ec, ECARD_RES_MEMC, 0, PAGE_SIZE);\n\tif (!eh->memc) {\n\t\tret = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\teh->ctrl_port = eh->memc;\n\tif (data->ctrl_ioc) {\n\t\teh->ioc_fast = ecardm_iomap(ec, ECARD_RES_IOCFAST, 0, PAGE_SIZE);\n\t\tif (!eh->ioc_fast) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto free;\n\t\t}\n\t\teh->ctrl_port = eh->ioc_fast;\n\t}\n\n\tdev->base_addr = (unsigned long)eh->memc + data->ns8390_offset;\n\teh->dma_base = eh->memc + data->dataport_offset;\n\teh->ctrl_port += data->ctrlport_offset;\n\n\t \n\tif (ec->slot_no != 8) {\n\t\tecard_setirq(ec, &etherh_ops, eh);\n\t} else {\n\t\t \n\t\tetherh_set_ctrl(eh, ETHERH_CP_IE);\n\t}\n\n\tei_local = netdev_priv(dev);\n\tspin_lock_init(&ei_local->page_lock);\n\n\tif (ec->cid.product == PROD_ANT_ETHERM) {\n\t\tetherm_addr(addr);\n\t\tei_local->reg_offset = etherm_regoffsets;\n\t} else {\n\t\tetherh_addr(addr, ec);\n\t\tei_local->reg_offset = etherh_regoffsets;\n\t}\n\teth_hw_addr_set(dev, addr);\n\n\tei_local->name          = dev->name;\n\tei_local->word16        = 1;\n\tei_local->tx_start_page = data->tx_start_page;\n\tei_local->rx_start_page = ei_local->tx_start_page + TX_PAGES;\n\tei_local->stop_page     = data->stop_page;\n\tei_local->reset_8390    = etherh_reset;\n\tei_local->block_input   = etherh_block_input;\n\tei_local->block_output  = etherh_block_output;\n\tei_local->get_8390_hdr  = etherh_get_header;\n\tei_local->interface_num = 0;\n\n\tetherh_reset(dev);\n\t__NS8390_init(dev, 0);\n\n\tret = register_netdev(dev);\n\tif (ret)\n\t\tgoto free;\n\n\tnetdev_info(dev, \"%s in slot %d, %pM\\n\",\n\t\t    data->name, ec->slot_no, dev->dev_addr);\n\n\tecard_set_drvdata(ec, dev);\n\n\treturn 0;\n\n free:\n\tfree_netdev(dev);\n release:\n\tecard_release_resources(ec);\n out:\n\treturn ret;\n}\n\nstatic void etherh_remove(struct expansion_card *ec)\n{\n\tstruct net_device *dev = ecard_get_drvdata(ec);\n\n\tecard_set_drvdata(ec, NULL);\n\n\tunregister_netdev(dev);\n\n\tfree_netdev(dev);\n\n\tecard_release_resources(ec);\n}\n\nstatic struct etherh_data etherm_data = {\n\t.ns8390_offset\t\t= ETHERM_NS8390,\n\t.dataport_offset\t= ETHERM_NS8390 + ETHERM_DATAPORT,\n\t.ctrlport_offset\t= ETHERM_NS8390 + ETHERM_CTRLPORT,\n\t.name\t\t\t= \"ANT EtherM\",\n\t.supported\t\t= SUPPORTED_10baseT_Half,\n\t.tx_start_page\t\t= ETHERM_TX_START_PAGE,\n\t.stop_page\t\t= ETHERM_STOP_PAGE,\n};\n\nstatic struct etherh_data etherlan500_data = {\n\t.ns8390_offset\t\t= ETHERH500_NS8390,\n\t.dataport_offset\t= ETHERH500_NS8390 + ETHERH500_DATAPORT,\n\t.ctrlport_offset\t= ETHERH500_CTRLPORT,\n\t.ctrl_ioc\t\t= 1,\n\t.name\t\t\t= \"i3 EtherH 500\",\n\t.supported\t\t= SUPPORTED_10baseT_Half,\n\t.tx_start_page\t\t= ETHERH_TX_START_PAGE,\n\t.stop_page\t\t= ETHERH_STOP_PAGE,\n};\n\nstatic struct etherh_data etherlan600_data = {\n\t.ns8390_offset\t\t= ETHERH600_NS8390,\n\t.dataport_offset\t= ETHERH600_NS8390 + ETHERH600_DATAPORT,\n\t.ctrlport_offset\t= ETHERH600_NS8390 + ETHERH600_CTRLPORT,\n\t.name\t\t\t= \"i3 EtherH 600\",\n\t.supported\t\t= SUPPORTED_10baseT_Half | SUPPORTED_TP | SUPPORTED_BNC | SUPPORTED_Autoneg,\n\t.tx_start_page\t\t= ETHERH_TX_START_PAGE,\n\t.stop_page\t\t= ETHERH_STOP_PAGE,\n};\n\nstatic struct etherh_data etherlan600a_data = {\n\t.ns8390_offset\t\t= ETHERH600_NS8390,\n\t.dataport_offset\t= ETHERH600_NS8390 + ETHERH600_DATAPORT,\n\t.ctrlport_offset\t= ETHERH600_NS8390 + ETHERH600_CTRLPORT,\n\t.name\t\t\t= \"i3 EtherH 600A\",\n\t.supported\t\t= SUPPORTED_10baseT_Half | SUPPORTED_TP | SUPPORTED_BNC | SUPPORTED_Autoneg,\n\t.tx_start_page\t\t= ETHERH_TX_START_PAGE,\n\t.stop_page\t\t= ETHERH_STOP_PAGE,\n};\n\nstatic const struct ecard_id etherh_ids[] = {\n\t{ MANU_ANT, PROD_ANT_ETHERM,      &etherm_data       },\n\t{ MANU_I3,  PROD_I3_ETHERLAN500,  &etherlan500_data  },\n\t{ MANU_I3,  PROD_I3_ETHERLAN600,  &etherlan600_data  },\n\t{ MANU_I3,  PROD_I3_ETHERLAN600A, &etherlan600a_data },\n\t{ 0xffff,   0xffff }\n};\n\nstatic struct ecard_driver etherh_driver = {\n\t.probe\t\t= etherh_probe,\n\t.remove\t\t= etherh_remove,\n\t.id_table\t= etherh_ids,\n\t.drv = {\n\t\t.name\t= DRV_NAME,\n\t},\n};\n\nstatic int __init etherh_init(void)\n{\n\tint i;\n\n\tfor (i = 0; i < 16; i++) {\n\t\tetherh_regoffsets[i] = i << 2;\n\t\tetherm_regoffsets[i] = i << 5;\n\t}\n\n\treturn ecard_register_driver(&etherh_driver);\n}\n\nstatic void __exit etherh_exit(void)\n{\n\tecard_remove_driver(&etherh_driver);\n}\n\nmodule_init(etherh_init);\nmodule_exit(etherh_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}