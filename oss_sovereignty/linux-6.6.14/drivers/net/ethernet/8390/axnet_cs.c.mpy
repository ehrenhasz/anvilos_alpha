{
  "module_name": "axnet_cs.c",
  "hash_id": "df18e63ca026920b9677664f706f0ace972ade6501d1d0a152c1f57b94145b0a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/8390/axnet_cs.c",
  "human_readable_source": "\n\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/timer.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/crc32.h>\n#include <linux/mii.h>\n#include \"8390.h\"\n\n#include <pcmcia/cistpl.h>\n#include <pcmcia/ciscode.h>\n#include <pcmcia/ds.h>\n#include <pcmcia/cisreg.h>\n\n#include <asm/io.h>\n#include <asm/byteorder.h>\n#include <linux/uaccess.h>\n\n#define AXNET_CMD\t0x00\n#define AXNET_DATAPORT\t0x10\t \n#define AXNET_RESET\t0x1f\t \n#define AXNET_MII_EEP\t0x14\t \n#define AXNET_TEST\t0x15\t \n#define AXNET_GPIO\t0x17\t \n\n#define AXNET_START_PG\t0x40\t \n#define AXNET_STOP_PG\t0x80\t \n\n#define AXNET_RDC_TIMEOUT 0x02\t \n\n#define IS_AX88190\t0x0001\n#define IS_AX88790\t0x0002\n\n \n\n \n\nMODULE_AUTHOR(\"David Hinds <dahinds@users.sourceforge.net>\");\nMODULE_DESCRIPTION(\"Asix AX88190 PCMCIA ethernet driver\");\nMODULE_LICENSE(\"GPL\");\n\n\n \n\nstatic int axnet_config(struct pcmcia_device *link);\nstatic void axnet_release(struct pcmcia_device *link);\nstatic int axnet_open(struct net_device *dev);\nstatic int axnet_close(struct net_device *dev);\nstatic int axnet_ioctl(struct net_device *dev, struct ifreq *rq, int cmd);\nstatic netdev_tx_t axnet_start_xmit(struct sk_buff *skb,\n\t\t\t\t\t  struct net_device *dev);\nstatic struct net_device_stats *get_stats(struct net_device *dev);\nstatic void set_multicast_list(struct net_device *dev);\nstatic void axnet_tx_timeout(struct net_device *dev, unsigned int txqueue);\nstatic irqreturn_t ei_irq_wrapper(int irq, void *dev_id);\nstatic void ei_watchdog(struct timer_list *t);\nstatic void axnet_reset_8390(struct net_device *dev);\n\nstatic int mdio_read(unsigned int addr, int phy_id, int loc);\nstatic void mdio_write(unsigned int addr, int phy_id, int loc, int value);\n\nstatic void get_8390_hdr(struct net_device *,\n\t\t\t struct e8390_pkt_hdr *, int);\nstatic void block_input(struct net_device *dev, int count,\n\t\t\tstruct sk_buff *skb, int ring_offset);\nstatic void block_output(struct net_device *dev, int count,\n\t\t\t const u_char *buf, const int start_page);\n\nstatic void axnet_detach(struct pcmcia_device *p_dev);\n\nstatic void AX88190_init(struct net_device *dev, int startp);\nstatic int ax_open(struct net_device *dev);\nstatic int ax_close(struct net_device *dev);\nstatic irqreturn_t ax_interrupt(int irq, void *dev_id);\n\n \n\nstruct axnet_dev {\n\tstruct pcmcia_device\t*p_dev;\n\tcaddr_t\tbase;\n\tstruct timer_list\twatchdog;\n\tint\tstale, fast_poll;\n\tu_short\tlink_status;\n\tu_char\tduplex_flag;\n\tint\tphy_id;\n\tint\tflags;\n\tint\tactive_low;\n};\n\nstatic inline struct axnet_dev *PRIV(struct net_device *dev)\n{\n\tvoid *p = (char *)netdev_priv(dev) + sizeof(struct ei_device);\n\treturn p;\n}\n\nstatic const struct net_device_ops axnet_netdev_ops = {\n\t.ndo_open \t\t= axnet_open,\n\t.ndo_stop\t\t= axnet_close,\n\t.ndo_eth_ioctl\t\t= axnet_ioctl,\n\t.ndo_start_xmit\t\t= axnet_start_xmit,\n\t.ndo_tx_timeout\t\t= axnet_tx_timeout,\n\t.ndo_get_stats\t\t= get_stats,\n\t.ndo_set_rx_mode\t= set_multicast_list,\n\t.ndo_set_mac_address \t= eth_mac_addr,\n\t.ndo_validate_addr\t= eth_validate_addr,\n};\n\nstatic int axnet_probe(struct pcmcia_device *link)\n{\n    struct axnet_dev *info;\n    struct net_device *dev;\n    struct ei_device *ei_local;\n\n    dev_dbg(&link->dev, \"axnet_attach()\\n\");\n\n    dev = alloc_etherdev(sizeof(struct ei_device) + sizeof(struct axnet_dev));\n    if (!dev)\n\treturn -ENOMEM;\n\n    ei_local = netdev_priv(dev);\n    spin_lock_init(&ei_local->page_lock);\n\n    info = PRIV(dev);\n    info->p_dev = link;\n    link->priv = dev;\n    link->config_flags |= CONF_ENABLE_IRQ;\n\n    dev->netdev_ops = &axnet_netdev_ops;\n\n    dev->watchdog_timeo = TX_TIMEOUT;\n\n    return axnet_config(link);\n}  \n\nstatic void axnet_detach(struct pcmcia_device *link)\n{\n    struct net_device *dev = link->priv;\n\n    dev_dbg(&link->dev, \"axnet_detach(0x%p)\\n\", link);\n\n    unregister_netdev(dev);\n\n    axnet_release(link);\n\n    free_netdev(dev);\n}  \n\n \n\nstatic int get_prom(struct pcmcia_device *link)\n{\n    struct net_device *dev = link->priv;\n    unsigned int ioaddr = dev->base_addr;\n    u8 addr[ETH_ALEN];\n    int i, j;\n\n     \n    struct {\n\tu_char value, offset;\n    } program_seq[] = {\n\t{E8390_NODMA+E8390_PAGE0+E8390_STOP, E8390_CMD},  \n\t{0x01,\tEN0_DCFG},\t \n\t{0x00,\tEN0_RCNTLO},\t \n\t{0x00,\tEN0_RCNTHI},\n\t{0x00,\tEN0_IMR},\t \n\t{0xFF,\tEN0_ISR},\n\t{E8390_RXOFF|0x40, EN0_RXCR},\t \n\t{E8390_TXOFF, EN0_TXCR},\t \n\t{0x10,\tEN0_RCNTLO},\n\t{0x00,\tEN0_RCNTHI},\n\t{0x00,\tEN0_RSARLO},\t \n\t{0x04,\tEN0_RSARHI},\n\t{E8390_RREAD+E8390_START, E8390_CMD},\n    };\n\n     \n    if (link->config_base != 0x03c0)\n\treturn 0;\n\n    axnet_reset_8390(dev);\n    mdelay(10);\n\n    for (i = 0; i < ARRAY_SIZE(program_seq); i++)\n\toutb_p(program_seq[i].value, ioaddr + program_seq[i].offset);\n\n    for (i = 0; i < 6; i += 2) {\n\tj = inw(ioaddr + AXNET_DATAPORT);\n\taddr[i] = j & 0xff;\n\taddr[i+1] = j >> 8;\n    }\n    eth_hw_addr_set(dev, addr);\n\n    return 1;\n}  \n\nstatic int try_io_port(struct pcmcia_device *link)\n{\n    int j, ret;\n    link->resource[0]->flags &= ~IO_DATA_PATH_WIDTH;\n    link->resource[1]->flags &= ~IO_DATA_PATH_WIDTH;\n    if (link->resource[0]->end == 32) {\n\tlink->resource[0]->flags |= IO_DATA_PATH_WIDTH_AUTO;\n\t \n\tif (link->resource[1]->end > 0)\n\t    link->resource[1]->flags |= IO_DATA_PATH_WIDTH_8;\n    } else {\n\t \n\tlink->resource[0]->flags |= IO_DATA_PATH_WIDTH_8;\n\tlink->resource[1]->flags |= IO_DATA_PATH_WIDTH_16;\n    }\n    if (link->resource[0]->start == 0) {\n\tfor (j = 0; j < 0x400; j += 0x20) {\n\t    link->resource[0]->start = j ^ 0x300;\n\t    link->resource[1]->start = (j ^ 0x300) + 0x10;\n\t    link->io_lines = 16;\n\t    ret = pcmcia_request_io(link);\n\t    if (ret == 0)\n\t\t    return ret;\n\t}\n\treturn ret;\n    } else {\n\treturn pcmcia_request_io(link);\n    }\n}\n\nstatic int axnet_configcheck(struct pcmcia_device *p_dev, void *priv_data)\n{\n\tif (p_dev->config_index == 0)\n\t\treturn -EINVAL;\n\n\tp_dev->config_index = 0x05;\n\tif (p_dev->resource[0]->end + p_dev->resource[1]->end < 32)\n\t\treturn -ENODEV;\n\n\treturn try_io_port(p_dev);\n}\n\nstatic int axnet_config(struct pcmcia_device *link)\n{\n    struct net_device *dev = link->priv;\n    struct axnet_dev *info = PRIV(dev);\n    int i, j, j2, ret;\n\n    dev_dbg(&link->dev, \"axnet_config(0x%p)\\n\", link);\n\n     \n    link->config_regs = 0x63;\n    link->config_flags |= CONF_ENABLE_IRQ | CONF_AUTO_SET_IO;\n    ret = pcmcia_loop_config(link, axnet_configcheck, NULL);\n    if (ret != 0)\n\tgoto failed;\n\n    if (!link->irq)\n\t    goto failed;\n\n    if (resource_size(link->resource[1]) == 8)\n\tlink->config_flags |= CONF_ENABLE_SPKR;\n    \n    ret = pcmcia_enable_device(link);\n    if (ret)\n\t    goto failed;\n\n    dev->irq = link->irq;\n    dev->base_addr = link->resource[0]->start;\n\n    if (!get_prom(link)) {\n\tpr_notice(\"this is not an AX88190 card!\\n\");\n\tpr_notice(\"use pcnet_cs instead.\\n\");\n\tgoto failed;\n    }\n\n    ei_status.name = \"AX88190\";\n    ei_status.word16 = 1;\n    ei_status.tx_start_page = AXNET_START_PG;\n    ei_status.rx_start_page = AXNET_START_PG + TX_PAGES;\n    ei_status.stop_page = AXNET_STOP_PG;\n    ei_status.reset_8390 = axnet_reset_8390;\n    ei_status.get_8390_hdr = get_8390_hdr;\n    ei_status.block_input = block_input;\n    ei_status.block_output = block_output;\n\n    if (inb(dev->base_addr + AXNET_TEST) != 0)\n\tinfo->flags |= IS_AX88790;\n    else\n\tinfo->flags |= IS_AX88190;\n\n    if (info->flags & IS_AX88790)\n\toutb(0x10, dev->base_addr + AXNET_GPIO);   \n\n    info->active_low = 0;\n\n    for (i = 0; i < 32; i++) {\n\tj = mdio_read(dev->base_addr + AXNET_MII_EEP, i, 1);\n\tj2 = mdio_read(dev->base_addr + AXNET_MII_EEP, i, 2);\n\tif (j == j2) continue;\n\tif ((j != 0) && (j != 0xffff)) break;\n    }\n\n    if (i == 32) {\n\t \n\tpcmcia_write_config_byte(link, CISREG_CCSR, 0x04);\n\tfor (i = 0; i < 32; i++) {\n\t    j = mdio_read(dev->base_addr + AXNET_MII_EEP, i, 1);\n\t    j2 = mdio_read(dev->base_addr + AXNET_MII_EEP, i, 2);\n\t    if (j == j2) continue;\n\t    if ((j != 0) && (j != 0xffff)) {\n\t\tinfo->active_low = 1;\n\t\tbreak;\n\t    }\n\t}\n    }\n\n    info->phy_id = (i < 32) ? i : -1;\n    SET_NETDEV_DEV(dev, &link->dev);\n\n    if (register_netdev(dev) != 0) {\n\tpr_notice(\"register_netdev() failed\\n\");\n\tgoto failed;\n    }\n\n    netdev_info(dev, \"Asix AX88%d90: io %#3lx, irq %d, hw_addr %pM\\n\",\n\t\t((info->flags & IS_AX88790) ? 7 : 1),\n\t\tdev->base_addr, dev->irq, dev->dev_addr);\n    if (info->phy_id != -1) {\n\tnetdev_dbg(dev, \"  MII transceiver at index %d, status %x\\n\",\n\t\t   info->phy_id, j);\n    } else {\n\tnetdev_notice(dev, \"  No MII transceivers found!\\n\");\n    }\n    return 0;\n\nfailed:\n    axnet_release(link);\n    return -ENODEV;\n}  \n\nstatic void axnet_release(struct pcmcia_device *link)\n{\n\tpcmcia_disable_device(link);\n}\n\nstatic int axnet_suspend(struct pcmcia_device *link)\n{\n\tstruct net_device *dev = link->priv;\n\n\tif (link->open)\n\t\tnetif_device_detach(dev);\n\n\treturn 0;\n}\n\nstatic int axnet_resume(struct pcmcia_device *link)\n{\n\tstruct net_device *dev = link->priv;\n\tstruct axnet_dev *info = PRIV(dev);\n\n\tif (link->open) {\n\t\tif (info->active_low == 1)\n\t\t\tpcmcia_write_config_byte(link, CISREG_CCSR, 0x04);\n\n\t\taxnet_reset_8390(dev);\n\t\tAX88190_init(dev, 1);\n\t\tnetif_device_attach(dev);\n\t}\n\n\treturn 0;\n}\n\n\n \n\n#define MDIO_SHIFT_CLK\t\t0x01\n#define MDIO_DATA_WRITE0\t0x00\n#define MDIO_DATA_WRITE1\t0x08\n#define MDIO_DATA_READ\t\t0x04\n#define MDIO_MASK\t\t0x0f\n#define MDIO_ENB_IN\t\t0x02\n\nstatic void mdio_sync(unsigned int addr)\n{\n    int bits;\n    for (bits = 0; bits < 32; bits++) {\n\toutb_p(MDIO_DATA_WRITE1, addr);\n\toutb_p(MDIO_DATA_WRITE1 | MDIO_SHIFT_CLK, addr);\n    }\n}\n\nstatic int mdio_read(unsigned int addr, int phy_id, int loc)\n{\n    u_int cmd = (0xf6<<10)|(phy_id<<5)|loc;\n    int i, retval = 0;\n\n    mdio_sync(addr);\n    for (i = 14; i >= 0; i--) {\n\tint dat = (cmd&(1<<i)) ? MDIO_DATA_WRITE1 : MDIO_DATA_WRITE0;\n\toutb_p(dat, addr);\n\toutb_p(dat | MDIO_SHIFT_CLK, addr);\n    }\n    for (i = 19; i > 0; i--) {\n\toutb_p(MDIO_ENB_IN, addr);\n\tretval = (retval << 1) | ((inb_p(addr) & MDIO_DATA_READ) != 0);\n\toutb_p(MDIO_ENB_IN | MDIO_SHIFT_CLK, addr);\n    }\n    return (retval>>1) & 0xffff;\n}\n\nstatic void mdio_write(unsigned int addr, int phy_id, int loc, int value)\n{\n    u_int cmd = (0x05<<28)|(phy_id<<23)|(loc<<18)|(1<<17)|value;\n    int i;\n\n    mdio_sync(addr);\n    for (i = 31; i >= 0; i--) {\n\tint dat = (cmd&(1<<i)) ? MDIO_DATA_WRITE1 : MDIO_DATA_WRITE0;\n\toutb_p(dat, addr);\n\toutb_p(dat | MDIO_SHIFT_CLK, addr);\n    }\n    for (i = 1; i >= 0; i--) {\n\toutb_p(MDIO_ENB_IN, addr);\n\toutb_p(MDIO_ENB_IN | MDIO_SHIFT_CLK, addr);\n    }\n}\n\n \n\nstatic int axnet_open(struct net_device *dev)\n{\n    int ret;\n    struct axnet_dev *info = PRIV(dev);\n    struct pcmcia_device *link = info->p_dev;\n    unsigned int nic_base = dev->base_addr;\n    \n    dev_dbg(&link->dev, \"axnet_open('%s')\\n\", dev->name);\n\n    if (!pcmcia_dev_present(link))\n\treturn -ENODEV;\n\n    outb_p(0xFF, nic_base + EN0_ISR);  \n    ret = request_irq(dev->irq, ei_irq_wrapper, IRQF_SHARED, \"axnet_cs\", dev);\n    if (ret)\n\t    return ret;\n\n    link->open++;\n\n    info->link_status = 0x00;\n    timer_setup(&info->watchdog, ei_watchdog, 0);\n    mod_timer(&info->watchdog, jiffies + HZ);\n\n    return ax_open(dev);\n}  \n\n \n\nstatic int axnet_close(struct net_device *dev)\n{\n    struct axnet_dev *info = PRIV(dev);\n    struct pcmcia_device *link = info->p_dev;\n\n    dev_dbg(&link->dev, \"axnet_close('%s')\\n\", dev->name);\n\n    ax_close(dev);\n    free_irq(dev->irq, dev);\n    \n    link->open--;\n    netif_stop_queue(dev);\n    del_timer_sync(&info->watchdog);\n\n    return 0;\n}  \n\n \n\nstatic void axnet_reset_8390(struct net_device *dev)\n{\n    unsigned int nic_base = dev->base_addr;\n    int i;\n\n    ei_status.txing = ei_status.dmaing = 0;\n\n    outb_p(E8390_NODMA+E8390_PAGE0+E8390_STOP, nic_base + E8390_CMD);\n\n    outb(inb(nic_base + AXNET_RESET), nic_base + AXNET_RESET);\n\n    for (i = 0; i < 100; i++) {\n\tif ((inb_p(nic_base+EN0_ISR) & ENISR_RESET) != 0)\n\t    break;\n\tudelay(100);\n    }\n    outb_p(ENISR_RESET, nic_base + EN0_ISR);  \n    \n    if (i == 100)\n\tnetdev_err(dev, \"axnet_reset_8390() did not complete\\n\");\n    \n}  \n\n \n\nstatic irqreturn_t ei_irq_wrapper(int irq, void *dev_id)\n{\n    struct net_device *dev = dev_id;\n    PRIV(dev)->stale = 0;\n    return ax_interrupt(irq, dev_id);\n}\n\nstatic void ei_watchdog(struct timer_list *t)\n{\n    struct axnet_dev *info = from_timer(info, t, watchdog);\n    struct net_device *dev = info->p_dev->priv;\n    unsigned int nic_base = dev->base_addr;\n    unsigned int mii_addr = nic_base + AXNET_MII_EEP;\n    u_short link;\n\n    if (!netif_device_present(dev)) goto reschedule;\n\n     \n    if (info->stale++ && (inb_p(nic_base + EN0_ISR) & ENISR_ALL)) {\n\tif (!info->fast_poll)\n\t    netdev_info(dev, \"interrupt(s) dropped!\\n\");\n\tei_irq_wrapper(dev->irq, dev);\n\tinfo->fast_poll = HZ;\n    }\n    if (info->fast_poll) {\n\tinfo->fast_poll--;\n\tinfo->watchdog.expires = jiffies + 1;\n\tadd_timer(&info->watchdog);\n\treturn;\n    }\n\n    if (info->phy_id < 0)\n\tgoto reschedule;\n    link = mdio_read(mii_addr, info->phy_id, 1);\n    if (!link || (link == 0xffff)) {\n\tnetdev_info(dev, \"MII is missing!\\n\");\n\tinfo->phy_id = -1;\n\tgoto reschedule;\n    }\n\n    link &= 0x0004;\n    if (link != info->link_status) {\n\tu_short p = mdio_read(mii_addr, info->phy_id, 5);\n\tnetdev_info(dev, \"%s link beat\\n\", link ? \"found\" : \"lost\");\n\tif (link) {\n\t    info->duplex_flag = (p & 0x0140) ? 0x80 : 0x00;\n\t    if (p)\n\t\tnetdev_info(dev, \"autonegotiation complete: %dbaseT-%cD selected\\n\",\n\t\t\t    (p & 0x0180) ? 100 : 10, (p & 0x0140) ? 'F' : 'H');\n\t    else\n\t\tnetdev_info(dev, \"link partner did not autonegotiate\\n\");\n\t    AX88190_init(dev, 1);\n\t}\n\tinfo->link_status = link;\n    }\n\nreschedule:\n    info->watchdog.expires = jiffies + HZ;\n    add_timer(&info->watchdog);\n}\n\n \n\nstatic int axnet_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)\n{\n    struct axnet_dev *info = PRIV(dev);\n    struct mii_ioctl_data *data = if_mii(rq);\n    unsigned int mii_addr = dev->base_addr + AXNET_MII_EEP;\n    switch (cmd) {\n    case SIOCGMIIPHY:\n\tdata->phy_id = info->phy_id;\n\tfallthrough;\n    case SIOCGMIIREG:\t\t \n\tdata->val_out = mdio_read(mii_addr, data->phy_id, data->reg_num & 0x1f);\n\treturn 0;\n    case SIOCSMIIREG:\t\t \n\tmdio_write(mii_addr, data->phy_id, data->reg_num & 0x1f, data->val_in);\n\treturn 0;\n    }\n    return -EOPNOTSUPP;\n}\n\n \n\nstatic void get_8390_hdr(struct net_device *dev,\n\t\t\t struct e8390_pkt_hdr *hdr,\n\t\t\t int ring_page)\n{\n    unsigned int nic_base = dev->base_addr;\n\n    outb_p(0, nic_base + EN0_RSARLO);\t\t \n    outb_p(ring_page, nic_base + EN0_RSARHI);\n    outb_p(E8390_RREAD+E8390_START, nic_base + AXNET_CMD);\n\n    insw(nic_base + AXNET_DATAPORT, hdr,\n\t    sizeof(struct e8390_pkt_hdr)>>1);\n     \n    hdr->count = le16_to_cpu(hdr->count);\n\n}\n\n \n\nstatic void block_input(struct net_device *dev, int count,\n\t\t\tstruct sk_buff *skb, int ring_offset)\n{\n    unsigned int nic_base = dev->base_addr;\n    struct ei_device *ei_local = netdev_priv(dev);\n    char *buf = skb->data;\n\n    if ((netif_msg_rx_status(ei_local)) && (count != 4))\n\tnetdev_dbg(dev, \"[bi=%d]\\n\", count+4);\n    outb_p(ring_offset & 0xff, nic_base + EN0_RSARLO);\n    outb_p(ring_offset >> 8, nic_base + EN0_RSARHI);\n    outb_p(E8390_RREAD+E8390_START, nic_base + AXNET_CMD);\n\n    insw(nic_base + AXNET_DATAPORT,buf,count>>1);\n    if (count & 0x01) {\n\tbuf[count-1] = inb(nic_base + AXNET_DATAPORT);\n    }\n}\n\n \n\nstatic void block_output(struct net_device *dev, int count,\n\t\t\t const u_char *buf, const int start_page)\n{\n    unsigned int nic_base = dev->base_addr;\n\n    pr_debug(\"%s: [bo=%d]\\n\", dev->name, count);\n\n     \n    if (count & 0x01)\n\tcount++;\n\n    outb_p(0x00, nic_base + EN0_RSARLO);\n    outb_p(start_page, nic_base + EN0_RSARHI);\n    outb_p(E8390_RWRITE+E8390_START, nic_base + AXNET_CMD);\n    outsw(nic_base + AXNET_DATAPORT, buf, count>>1);\n}\n\nstatic const struct pcmcia_device_id axnet_ids[] = {\n\tPCMCIA_PFC_DEVICE_MANF_CARD(0, 0x016c, 0x0081),\n\tPCMCIA_DEVICE_MANF_CARD(0x018a, 0x0301),\n\tPCMCIA_DEVICE_MANF_CARD(0x01bf, 0x2328),\n\tPCMCIA_DEVICE_MANF_CARD(0x026f, 0x0301),\n\tPCMCIA_DEVICE_MANF_CARD(0x026f, 0x0303),\n\tPCMCIA_DEVICE_MANF_CARD(0x026f, 0x0309),\n\tPCMCIA_DEVICE_MANF_CARD(0x0274, 0x1106),\n\tPCMCIA_DEVICE_MANF_CARD(0x8a01, 0xc1ab),\n\tPCMCIA_DEVICE_MANF_CARD(0x021b, 0x0202), \n\tPCMCIA_DEVICE_MANF_CARD(0xffff, 0x1090),\n\tPCMCIA_DEVICE_PROD_ID12(\"AmbiCom,Inc.\", \"Fast Ethernet PC Card(AMB8110)\", 0x49b020a7, 0x119cc9fc),\n\tPCMCIA_DEVICE_PROD_ID124(\"Fast Ethernet\", \"16-bit PC Card\", \"AX88190\", 0xb4be14e3, 0x9a12eb6a, 0xab9be5ef),\n\tPCMCIA_DEVICE_PROD_ID12(\"ASIX\", \"AX88190\", 0x0959823b, 0xab9be5ef),\n\tPCMCIA_DEVICE_PROD_ID12(\"Billionton\", \"LNA-100B\", 0x552ab682, 0xbc3b87e1),\n\tPCMCIA_DEVICE_PROD_ID12(\"CHEETAH ETHERCARD\", \"EN2228\", 0x00fa7bc8, 0x00e990cc),\n\tPCMCIA_DEVICE_PROD_ID12(\"CNet\", \"CNF301\", 0xbc477dde, 0x78c5f40b),\n\tPCMCIA_DEVICE_PROD_ID12(\"corega K.K.\", \"corega FEther PCC-TXD\", 0x5261440f, 0x436768c5),\n\tPCMCIA_DEVICE_PROD_ID12(\"corega K.K.\", \"corega FEtherII PCC-TXD\", 0x5261440f, 0x730df72e),\n\tPCMCIA_DEVICE_PROD_ID12(\"corega K.K.\", \"corega FEther PCC-TXM\", 0x5261440f, 0x3abbd061),\n\tPCMCIA_DEVICE_PROD_ID12(\"Dynalink\", \"L100C16\", 0x55632fd5, 0x66bc2a90),\n\tPCMCIA_DEVICE_PROD_ID12(\"IO DATA\", \"ETXPCM\", 0x547e66dc, 0x233adac2),\n\tPCMCIA_DEVICE_PROD_ID12(\"Linksys\", \"EtherFast 10/100 PC Card (PCMPC100 V3)\", 0x0733cc81, 0x232019a8),\n\tPCMCIA_DEVICE_PROD_ID12(\"MELCO\", \"LPC3-TX\", 0x481e0094, 0xf91af609),\n\tPCMCIA_DEVICE_PROD_ID12(\"NETGEAR\", \"FA411\", 0x9aa79dc3, 0x40fad875),\n\tPCMCIA_DEVICE_PROD_ID12(\"PCMCIA\", \"100BASE\", 0x281f1c5d, 0x7c2add04),\n\tPCMCIA_DEVICE_PROD_ID12(\"PCMCIA\", \"FastEtherCard\", 0x281f1c5d, 0x7ef26116),\n\tPCMCIA_DEVICE_PROD_ID12(\"PCMCIA\", \"FEP501\", 0x281f1c5d, 0x2e272058),\n\tPCMCIA_DEVICE_PROD_ID14(\"Network Everywhere\", \"AX88190\", 0x820a67b6,  0xab9be5ef),\n\tPCMCIA_DEVICE_NULL,\n};\nMODULE_DEVICE_TABLE(pcmcia, axnet_ids);\n\nstatic struct pcmcia_driver axnet_cs_driver = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"axnet_cs\",\n\t.probe\t\t= axnet_probe,\n\t.remove\t\t= axnet_detach,\n\t.id_table       = axnet_ids,\n\t.suspend\t= axnet_suspend,\n\t.resume\t\t= axnet_resume,\n};\nmodule_pcmcia_driver(axnet_cs_driver);\n\n \n\n \n \n\n#include <linux/bitops.h>\n#include <asm/irq.h>\n#include <linux/fcntl.h>\n#include <linux/in.h>\n#include <linux/interrupt.h>\n\n#define BUG_83C690\n\n \n#define ei_reset_8390 (ei_local->reset_8390)\n#define ei_block_output (ei_local->block_output)\n#define ei_block_input (ei_local->block_input)\n#define ei_get_8390_hdr (ei_local->get_8390_hdr)\n\n \nstatic void ei_tx_intr(struct net_device *dev);\nstatic void ei_tx_err(struct net_device *dev);\nstatic void ei_receive(struct net_device *dev);\nstatic void ei_rx_overrun(struct net_device *dev);\n\n \nstatic void NS8390_trigger_send(struct net_device *dev, unsigned int length,\n\t\t\t\t\t\t\t\tint start_page);\nstatic void do_set_multicast_list(struct net_device *dev);\n\n \n \n \nstatic int ax_open(struct net_device *dev)\n{\n\tunsigned long flags;\n\tstruct ei_device *ei_local = netdev_priv(dev);\n\n\t \n      \n      \tspin_lock_irqsave(&ei_local->page_lock, flags);\n\tAX88190_init(dev, 1);\n\t \n\tnetif_start_queue(dev);\n      \tspin_unlock_irqrestore(&ei_local->page_lock, flags);\n\tei_local->irqlock = 0;\n\treturn 0;\n}\n\n#define dev_lock(dev) (((struct ei_device *)netdev_priv(dev))->page_lock)\n\n \nstatic int ax_close(struct net_device *dev)\n{\n\tunsigned long flags;\n\n\t \n\n\tspin_lock_irqsave(&dev_lock(dev), flags);\n\tAX88190_init(dev, 0);\n\tspin_unlock_irqrestore(&dev_lock(dev), flags);\n\tnetif_stop_queue(dev);\n\treturn 0;\n}\n\n \n\nstatic void axnet_tx_timeout(struct net_device *dev, unsigned int txqueue)\n{\n\tlong e8390_base = dev->base_addr;\n\tstruct ei_device *ei_local = netdev_priv(dev);\n\tint txsr, isr, tickssofar = jiffies - dev_trans_start(dev);\n\tunsigned long flags;\n\n\tdev->stats.tx_errors++;\n\n\tspin_lock_irqsave(&ei_local->page_lock, flags);\n\ttxsr = inb(e8390_base+EN0_TSR);\n\tisr = inb(e8390_base+EN0_ISR);\n\tspin_unlock_irqrestore(&ei_local->page_lock, flags);\n\n\tnetdev_dbg(dev, \"Tx timed out, %s TSR=%#2x, ISR=%#2x, t=%d.\\n\",\n\t\t   (txsr & ENTSR_ABT) ? \"excess collisions.\" :\n\t\t   (isr) ? \"lost interrupt?\" : \"cable problem?\",\n\t\t   txsr, isr, tickssofar);\n\n\tif (!isr && !dev->stats.tx_packets) \n\t{\n\t\t \n\t\tei_local->interface_num ^= 1;    \n\t}\n\n\t \n\t\t\n\tspin_lock_irqsave(&ei_local->page_lock, flags);\n\t\t\n\t \n\tei_reset_8390(dev);\n\tAX88190_init(dev, 1);\n\t\t\n\tspin_unlock_irqrestore(&ei_local->page_lock, flags);\n\tnetif_wake_queue(dev);\n}\n    \n \n \nstatic netdev_tx_t axnet_start_xmit(struct sk_buff *skb,\n\t\t\t\t\t  struct net_device *dev)\n{\n\tlong e8390_base = dev->base_addr;\n\tstruct ei_device *ei_local = netdev_priv(dev);\n\tint length, send_length, output_page;\n\tunsigned long flags;\n\tu8 packet[ETH_ZLEN];\n\t\n\tnetif_stop_queue(dev);\n\n\tlength = skb->len;\n\n\t \n\t   \n\tspin_lock_irqsave(&ei_local->page_lock, flags);\n\toutb_p(0x00, e8390_base + EN0_IMR);\n\t\n\t \n\t \n\tei_local->irqlock = 1;\n\n\tsend_length = max(length, ETH_ZLEN);\n\n\t \n\n\tif (ei_local->tx1 == 0) \n\t{\n\t\toutput_page = ei_local->tx_start_page;\n\t\tei_local->tx1 = send_length;\n\t\tif ((netif_msg_tx_queued(ei_local)) &&\n\t\t    ei_local->tx2 > 0)\n\t\t\tnetdev_dbg(dev,\n\t\t\t\t   \"idle transmitter tx2=%d, lasttx=%d, txing=%d\\n\",\n\t\t\t\t   ei_local->tx2, ei_local->lasttx,\n\t\t\t\t   ei_local->txing);\n\t}\n\telse if (ei_local->tx2 == 0) \n\t{\n\t\toutput_page = ei_local->tx_start_page + TX_PAGES/2;\n\t\tei_local->tx2 = send_length;\n\t\tif ((netif_msg_tx_queued(ei_local)) &&\n\t\t    ei_local->tx1 > 0)\n\t\t\tnetdev_dbg(dev,\n\t\t\t\t   \"idle transmitter, tx1=%d, lasttx=%d, txing=%d\\n\",\n\t\t\t\t   ei_local->tx1, ei_local->lasttx,\n\t\t\t\t   ei_local->txing);\n\t}\n\telse\n\t{\t \n\t\tnetif_dbg(ei_local, tx_err, dev,\n\t\t\t  \"No Tx buffers free! tx1=%d tx2=%d last=%d\\n\",\n\t\t\t  ei_local->tx1, ei_local->tx2,\n\t\t\t  ei_local->lasttx);\n\t\tei_local->irqlock = 0;\n\t\tnetif_stop_queue(dev);\n\t\toutb_p(ENISR_ALL, e8390_base + EN0_IMR);\n\t\tspin_unlock_irqrestore(&ei_local->page_lock, flags);\n\t\tdev->stats.tx_errors++;\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\n\t \n\n\tif (length == skb->len)\n\t\tei_block_output(dev, length, skb->data, output_page);\n\telse {\n\t\tmemset(packet, 0, ETH_ZLEN);\n\t\tskb_copy_from_linear_data(skb, packet, skb->len);\n\t\tei_block_output(dev, length, packet, output_page);\n\t}\n\t\n\tif (! ei_local->txing) \n\t{\n\t\tei_local->txing = 1;\n\t\tNS8390_trigger_send(dev, send_length, output_page);\n\t\tnetif_trans_update(dev);\n\t\tif (output_page == ei_local->tx_start_page) \n\t\t{\n\t\t\tei_local->tx1 = -1;\n\t\t\tei_local->lasttx = -1;\n\t\t}\n\t\telse \n\t\t{\n\t\t\tei_local->tx2 = -1;\n\t\t\tei_local->lasttx = -2;\n\t\t}\n\t}\n\telse ei_local->txqueue++;\n\n\tif (ei_local->tx1  &&  ei_local->tx2)\n\t\tnetif_stop_queue(dev);\n\telse\n\t\tnetif_start_queue(dev);\n\n\t \n\tei_local->irqlock = 0;\n\toutb_p(ENISR_ALL, e8390_base + EN0_IMR);\n\t\n\tspin_unlock_irqrestore(&ei_local->page_lock, flags);\n\n\tdev_kfree_skb (skb);\n\tdev->stats.tx_bytes += send_length;\n    \n\treturn NETDEV_TX_OK;\n}\n\n \n\nstatic irqreturn_t ax_interrupt(int irq, void *dev_id)\n{\n\tstruct net_device *dev = dev_id;\n\tlong e8390_base;\n\tint interrupts, nr_serviced = 0, i;\n\tstruct ei_device *ei_local;\n\tint handled = 0;\n\tunsigned long flags;\n\n\te8390_base = dev->base_addr;\n\tei_local = netdev_priv(dev);\n\n\t \n\t \n\tspin_lock_irqsave(&ei_local->page_lock, flags);\n\n\tif (ei_local->irqlock) {\n#if 1  \n\t\tconst char *msg;\n\t\t \n\t\tif (ei_local->irqlock)\n\t\t\tmsg = \"Interrupted while interrupts are masked!\";\n\t\telse\n\t\t\tmsg = \"Reentering the interrupt handler!\";\n\t\tnetdev_info(dev, \"%s, isr=%#2x imr=%#2x\\n\",\n\t\t\t    msg,\n\t\t\t    inb_p(e8390_base + EN0_ISR),\n\t\t\t    inb_p(e8390_base + EN0_IMR));\n#endif\n\t\tspin_unlock_irqrestore(&ei_local->page_lock, flags);\n\t\treturn IRQ_NONE;\n\t}\n\n\tnetif_dbg(ei_local, intr, dev, \"interrupt(isr=%#2.2x)\\n\",\n\t\t  inb_p(e8390_base + EN0_ISR));\n\n\toutb_p(0x00, e8390_base + EN0_ISR);\n\tei_local->irqlock = 1;\n   \n\t \n\twhile ((interrupts = inb_p(e8390_base + EN0_ISR)) != 0 &&\n\t       ++nr_serviced < MAX_SERVICE)\n\t{\n\t\tif (!netif_running(dev) || (interrupts == 0xff)) {\n\t\t\tnetif_warn(ei_local, intr, dev,\n\t\t\t\t   \"interrupt from stopped card\\n\");\n\t\t\toutb_p(interrupts, e8390_base + EN0_ISR);\n\t\t\tinterrupts = 0;\n\t\t\tbreak;\n\t\t}\n\t\thandled = 1;\n\n\t\t \n\t\toutb_p(interrupts, e8390_base + EN0_ISR);\n\t\tfor (i = 0; i < 10; i++) {\n\t\t\tif (!(inb(e8390_base + EN0_ISR) & interrupts))\n\t\t\t\tbreak;\n\t\t\toutb_p(0, e8390_base + EN0_ISR);\n\t\t\toutb_p(interrupts, e8390_base + EN0_ISR);\n\t\t}\n\t\tif (interrupts & ENISR_OVER) \n\t\t\tei_rx_overrun(dev);\n\t\telse if (interrupts & (ENISR_RX+ENISR_RX_ERR)) \n\t\t{\n\t\t\t \n\t\t\tei_receive(dev);\n\t\t}\n\t\t \n\t\tif (interrupts & ENISR_TX)\n\t\t\tei_tx_intr(dev);\n\t\telse if (interrupts & ENISR_TX_ERR)\n\t\t\tei_tx_err(dev);\n\n\t\tif (interrupts & ENISR_COUNTERS) \n\t\t{\n\t\t\tdev->stats.rx_frame_errors += inb_p(e8390_base + EN0_COUNTER0);\n\t\t\tdev->stats.rx_crc_errors   += inb_p(e8390_base + EN0_COUNTER1);\n\t\t\tdev->stats.rx_missed_errors+= inb_p(e8390_base + EN0_COUNTER2);\n\t\t}\n\t}\n    \n\tif (interrupts && (netif_msg_intr(ei_local)))\n\t{\n\t\thandled = 1;\n\t\tif (nr_serviced >= MAX_SERVICE) \n\t\t{\n\t\t\t \n\t\t\tif (interrupts != 0xFF)\n\t\t\t\tnetdev_warn(dev,\n\t\t\t\t\t    \"Too much work at interrupt, status %#2.2x\\n\",\n\t\t\t\t\t    interrupts);\n\t\t\toutb_p(ENISR_ALL, e8390_base + EN0_ISR);  \n\t\t} else {\n\t\t\tnetdev_warn(dev, \"unknown interrupt %#2x\\n\",\n\t\t\t\t    interrupts);\n\t\t\toutb_p(0xff, e8390_base + EN0_ISR);  \n\t\t}\n\t}\n\n\t \n\tei_local->irqlock = 0;\n\toutb_p(ENISR_ALL, e8390_base + EN0_IMR);\n\n\tspin_unlock_irqrestore(&ei_local->page_lock, flags);\n\treturn IRQ_RETVAL(handled);\n}\n\n \n\nstatic void ei_tx_err(struct net_device *dev)\n{\n\tlong e8390_base = dev->base_addr;\n\tunsigned char txsr = inb_p(e8390_base+EN0_TSR);\n\tunsigned char tx_was_aborted = txsr & (ENTSR_ABT+ENTSR_FU);\n\n#ifdef VERBOSE_ERROR_DUMP\n\tnetdev_dbg(dev, \"transmitter error (%#2x):\", txsr);\n\tif (txsr & ENTSR_ABT)\n\t\tpr_cont(\" excess-collisions\");\n\tif (txsr & ENTSR_ND)\n\t\tpr_cont(\" non-deferral\");\n\tif (txsr & ENTSR_CRS)\n\t\tpr_cont(\" lost-carrier\");\n\tif (txsr & ENTSR_FU)\n\t\tpr_cont(\" FIFO-underrun\");\n\tif (txsr & ENTSR_CDH)\n\t\tpr_cont(\" lost-heartbeat\");\n\tpr_cont(\"\\n\");\n#endif\n\n\tif (tx_was_aborted)\n\t\tei_tx_intr(dev);\n\telse \n\t{\n\t\tdev->stats.tx_errors++;\n\t\tif (txsr & ENTSR_CRS) dev->stats.tx_carrier_errors++;\n\t\tif (txsr & ENTSR_CDH) dev->stats.tx_heartbeat_errors++;\n\t\tif (txsr & ENTSR_OWC) dev->stats.tx_window_errors++;\n\t}\n}\n\n \n\nstatic void ei_tx_intr(struct net_device *dev)\n{\n\tlong e8390_base = dev->base_addr;\n\tstruct ei_device *ei_local = netdev_priv(dev);\n\tint status = inb(e8390_base + EN0_TSR);\n    \n\t \n\tei_local->txqueue--;\n\n\tif (ei_local->tx1 < 0) \n\t{\n\t\tif (ei_local->lasttx != 1 && ei_local->lasttx != -1)\n\t\t\tnetdev_err(dev, \"%s: bogus last_tx_buffer %d, tx1=%d\\n\",\n\t\t\t\t   ei_local->name, ei_local->lasttx,\n\t\t\t\t   ei_local->tx1);\n\t\tei_local->tx1 = 0;\n\t\tif (ei_local->tx2 > 0) \n\t\t{\n\t\t\tei_local->txing = 1;\n\t\t\tNS8390_trigger_send(dev, ei_local->tx2, ei_local->tx_start_page + 6);\n\t\t\tnetif_trans_update(dev);\n\t\t\tei_local->tx2 = -1;\n\t\t\tei_local->lasttx = 2;\n\t\t} else {\n\t\t\tei_local->lasttx = 20;\n\t\t\tei_local->txing = 0;\n\t\t}\n\t}\n\telse if (ei_local->tx2 < 0) \n\t{\n\t\tif (ei_local->lasttx != 2  &&  ei_local->lasttx != -2)\n\t\t\tnetdev_err(dev, \"%s: bogus last_tx_buffer %d, tx2=%d\\n\",\n\t\t\t\t   ei_local->name, ei_local->lasttx,\n\t\t\t\t   ei_local->tx2);\n\t\tei_local->tx2 = 0;\n\t\tif (ei_local->tx1 > 0) \n\t\t{\n\t\t\tei_local->txing = 1;\n\t\t\tNS8390_trigger_send(dev, ei_local->tx1, ei_local->tx_start_page);\n\t\t\tnetif_trans_update(dev);\n\t\t\tei_local->tx1 = -1;\n\t\t\tei_local->lasttx = 1;\n\t\t} else {\n\t\t\tei_local->lasttx = 10;\n\t\t\tei_local->txing = 0;\n\t\t}\n\t}\n \n \n \n\n\t \n\tif (status & ENTSR_COL)\n\t\tdev->stats.collisions++;\n\tif (status & ENTSR_PTX)\n\t\tdev->stats.tx_packets++;\n\telse \n\t{\n\t\tdev->stats.tx_errors++;\n\t\tif (status & ENTSR_ABT) \n\t\t{\n\t\t\tdev->stats.tx_aborted_errors++;\n\t\t\tdev->stats.collisions += 16;\n\t\t}\n\t\tif (status & ENTSR_CRS) \n\t\t\tdev->stats.tx_carrier_errors++;\n\t\tif (status & ENTSR_FU) \n\t\t\tdev->stats.tx_fifo_errors++;\n\t\tif (status & ENTSR_CDH)\n\t\t\tdev->stats.tx_heartbeat_errors++;\n\t\tif (status & ENTSR_OWC)\n\t\t\tdev->stats.tx_window_errors++;\n\t}\n\tnetif_wake_queue(dev);\n}\n\n \n\nstatic void ei_receive(struct net_device *dev)\n{\n\tlong e8390_base = dev->base_addr;\n\tstruct ei_device *ei_local = netdev_priv(dev);\n\tunsigned char rxing_page, this_frame, next_frame;\n\tunsigned short current_offset;\n\tint rx_pkt_count = 0;\n\tstruct e8390_pkt_hdr rx_frame;\n    \n\twhile (++rx_pkt_count < 10) \n\t{\n\t\tint pkt_len, pkt_stat;\n\t\t\n\t\t \n\t\trxing_page = inb_p(e8390_base + EN1_CURPAG -1);\n\t\t\n\t\t \n\t\tthis_frame = inb_p(e8390_base + EN0_BOUNDARY) + 1;\n\t\tif (this_frame >= ei_local->stop_page)\n\t\t\tthis_frame = ei_local->rx_start_page;\n\t\t\n\t\t \n\t\tif ((netif_msg_rx_err(ei_local)) &&\n\t\t    this_frame != ei_local->current_page &&\n\t\t    (this_frame != 0x0 || rxing_page != 0xFF))\n\t\t\tnetdev_err(dev, \"mismatched read page pointers %2x vs %2x\\n\",\n\t\t\t\t   this_frame, ei_local->current_page);\n\t\t\n\t\tif (this_frame == rxing_page)\t \n\t\t\tbreak;\t\t\t\t \n\t\t\n\t\tcurrent_offset = this_frame << 8;\n\t\tei_get_8390_hdr(dev, &rx_frame, this_frame);\n\t\t\n\t\tpkt_len = rx_frame.count - sizeof(struct e8390_pkt_hdr);\n\t\tpkt_stat = rx_frame.status;\n\t\t\n\t\tnext_frame = this_frame + 1 + ((pkt_len+4)>>8);\n\t\t\n\t\tif (pkt_len < 60  ||  pkt_len > 1518) \n\t\t{\n\t\t\tnetif_err(ei_local, rx_err, dev,\n\t\t\t\t  \"bogus packet size: %d, status=%#2x nxpg=%#2x\\n\",\n\t\t\t\t  rx_frame.count, rx_frame.status,\n\t\t\t\t  rx_frame.next);\n\t\t\tdev->stats.rx_errors++;\n\t\t\tdev->stats.rx_length_errors++;\n\t\t}\n\t\t else if ((pkt_stat & 0x0F) == ENRSR_RXOK) \n\t\t{\n\t\t\tstruct sk_buff *skb;\n\t\t\t\n\t\t\tskb = netdev_alloc_skb(dev, pkt_len + 2);\n\t\t\tif (skb == NULL) \n\t\t\t{\n\t\t\t\tnetif_err(ei_local, rx_err, dev,\n\t\t\t\t\t  \"Couldn't allocate a sk_buff of size %d\\n\",\n\t\t\t\t\t  pkt_len);\n\t\t\t\tdev->stats.rx_dropped++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tskb_reserve(skb,2);\t \n\t\t\t\tskb_put(skb, pkt_len);\t \n\t\t\t\tei_block_input(dev, pkt_len, skb, current_offset + sizeof(rx_frame));\n\t\t\t\tskb->protocol=eth_type_trans(skb,dev);\n\t\t\t\tnetif_rx(skb);\n\t\t\t\tdev->stats.rx_packets++;\n\t\t\t\tdev->stats.rx_bytes += pkt_len;\n\t\t\t\tif (pkt_stat & ENRSR_PHY)\n\t\t\t\t\tdev->stats.multicast++;\n\t\t\t}\n\t\t} \n\t\telse \n\t\t{\n\t\t\tnetif_err(ei_local, rx_err, dev,\n\t\t\t\t  \"bogus packet: status=%#2x nxpg=%#2x size=%d\\n\",\n\t\t\t\t  rx_frame.status, rx_frame.next,\n\t\t\t\t  rx_frame.count);\n\t\t\tdev->stats.rx_errors++;\n\t\t\t \n\t\t\tif (pkt_stat & ENRSR_FO)\n\t\t\t\tdev->stats.rx_fifo_errors++;\n\t\t}\n\t\tnext_frame = rx_frame.next;\n\t\t\n\t\t \n\t\tif (next_frame >= ei_local->stop_page) {\n\t\t\tnetdev_info(dev, \"next frame inconsistency, %#2x\\n\",\n\t\t\t\t    next_frame);\n\t\t\tnext_frame = ei_local->rx_start_page;\n\t\t}\n\t\tei_local->current_page = next_frame;\n\t\toutb_p(next_frame-1, e8390_base+EN0_BOUNDARY);\n\t}\n}\n\n \n\nstatic void ei_rx_overrun(struct net_device *dev)\n{\n\tstruct axnet_dev *info = PRIV(dev);\n\tlong e8390_base = dev->base_addr;\n\tunsigned char was_txing, must_resend = 0;\n\tstruct ei_device *ei_local = netdev_priv(dev);\n    \n\t \n\twas_txing = inb_p(e8390_base+E8390_CMD) & E8390_TRANS;\n\toutb_p(E8390_NODMA+E8390_PAGE0+E8390_STOP, e8390_base+E8390_CMD);\n\n\tnetif_dbg(ei_local, rx_err, dev, \"Receiver overrun\\n\");\n\tdev->stats.rx_over_errors++;\n    \n\t \n\n\tmdelay(2);\n\n\t \n\toutb_p(0x00, e8390_base+EN0_RCNTLO);\n\toutb_p(0x00, e8390_base+EN0_RCNTHI);\n\n\t \n\n\tif (was_txing)\n\t{ \n\t\tunsigned char tx_completed = inb_p(e8390_base+EN0_ISR) & (ENISR_TX+ENISR_TX_ERR);\n\t\tif (!tx_completed)\n\t\t\tmust_resend = 1;\n\t}\n\n\t \n\toutb_p(E8390_TXOFF, e8390_base + EN0_TXCR);\n\toutb_p(E8390_NODMA + E8390_PAGE0 + E8390_START, e8390_base + E8390_CMD);\n\n\t \n\tei_receive(dev);\n\n\t \n\toutb_p(E8390_TXCONFIG | info->duplex_flag, e8390_base + EN0_TXCR); \n\tif (must_resend)\n    \t\toutb_p(E8390_NODMA + E8390_PAGE0 + E8390_START + E8390_TRANS, e8390_base + E8390_CMD);\n}\n\n \n \nstatic struct net_device_stats *get_stats(struct net_device *dev)\n{\n\tlong ioaddr = dev->base_addr;\n\tstruct ei_device *ei_local = netdev_priv(dev);\n\tunsigned long flags;\n    \n\t \n\tif (!netif_running(dev))\n\t\treturn &dev->stats;\n\n\tspin_lock_irqsave(&ei_local->page_lock,flags);\n\t \n\tdev->stats.rx_frame_errors += inb_p(ioaddr + EN0_COUNTER0);\n\tdev->stats.rx_crc_errors   += inb_p(ioaddr + EN0_COUNTER1);\n\tdev->stats.rx_missed_errors+= inb_p(ioaddr + EN0_COUNTER2);\n\tspin_unlock_irqrestore(&ei_local->page_lock, flags);\n    \n\treturn &dev->stats;\n}\n\n \n \nstatic inline void make_mc_bits(u8 *bits, struct net_device *dev)\n{\n\tstruct netdev_hw_addr *ha;\n\tu32 crc;\n\n\tnetdev_for_each_mc_addr(ha, dev) {\n\t\tcrc = ether_crc(ETH_ALEN, ha->addr);\n\t\t \n\t\tbits[crc>>29] |= (1<<((crc>>26)&7));\n\t}\n}\n\n \n \nstatic void do_set_multicast_list(struct net_device *dev)\n{\n\tlong e8390_base = dev->base_addr;\n\tint i;\n\tstruct ei_device *ei_local = netdev_priv(dev);\n\n\tif (!(dev->flags&(IFF_PROMISC|IFF_ALLMULTI))) {\n\t\tmemset(ei_local->mcfilter, 0, 8);\n\t\tif (!netdev_mc_empty(dev))\n\t\t\tmake_mc_bits(ei_local->mcfilter, dev);\n\t} else {\n\t\t \n\t\tmemset(ei_local->mcfilter, 0xFF, 8);\n\t}\n\n\toutb_p(E8390_NODMA + E8390_PAGE1, e8390_base + E8390_CMD);\n\tfor(i = 0; i < 8; i++) \n\t{\n\t\toutb_p(ei_local->mcfilter[i], e8390_base + EN1_MULT_SHIFT(i));\n\t}\n\toutb_p(E8390_NODMA + E8390_PAGE0, e8390_base + E8390_CMD);\n\n\tif(dev->flags&IFF_PROMISC)\n\t\toutb_p(E8390_RXCONFIG | 0x58, e8390_base + EN0_RXCR);\n\telse if (dev->flags & IFF_ALLMULTI || !netdev_mc_empty(dev))\n\t\toutb_p(E8390_RXCONFIG | 0x48, e8390_base + EN0_RXCR);\n\telse\n\t\toutb_p(E8390_RXCONFIG | 0x40, e8390_base + EN0_RXCR);\n\n\toutb_p(E8390_NODMA+E8390_PAGE0+E8390_START, e8390_base+E8390_CMD);\n}\n\n \n\nstatic void set_multicast_list(struct net_device *dev)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dev_lock(dev), flags);\n\tdo_set_multicast_list(dev);\n\tspin_unlock_irqrestore(&dev_lock(dev), flags);\n}\t\n\n \n \n\n \n\nstatic void AX88190_init(struct net_device *dev, int startp)\n{\n\tstruct axnet_dev *info = PRIV(dev);\n\tlong e8390_base = dev->base_addr;\n\tstruct ei_device *ei_local = netdev_priv(dev);\n\tint i;\n\tint endcfg = ei_local->word16 ? (0x48 | ENDCFG_WTS) : 0x48;\n    \n\tif(sizeof(struct e8390_pkt_hdr)!=4)\n    \t\tpanic(\"8390.c: header struct mispacked\\n\");    \n\t \n\toutb_p(E8390_NODMA+E8390_PAGE0+E8390_STOP, e8390_base+E8390_CMD);  \n\toutb_p(endcfg, e8390_base + EN0_DCFG);\t \n\t \n\toutb_p(0x00,  e8390_base + EN0_RCNTLO);\n\toutb_p(0x00,  e8390_base + EN0_RCNTHI);\n\t \n\toutb_p(E8390_RXOFF|0x40, e8390_base + EN0_RXCR);  \n\toutb_p(E8390_TXOFF, e8390_base + EN0_TXCR);  \n\t \n\toutb_p(ei_local->tx_start_page, e8390_base + EN0_TPSR);\n\tei_local->tx1 = ei_local->tx2 = 0;\n\toutb_p(ei_local->rx_start_page, e8390_base + EN0_STARTPG);\n\toutb_p(ei_local->stop_page-1, e8390_base + EN0_BOUNDARY);\t \n\tei_local->current_page = ei_local->rx_start_page;\t\t \n\toutb_p(ei_local->stop_page, e8390_base + EN0_STOPPG);\n\t \n\toutb_p(0xFF, e8390_base + EN0_ISR);\n\toutb_p(0x00,  e8390_base + EN0_IMR);\n    \n\t \n\n\toutb_p(E8390_NODMA + E8390_PAGE1 + E8390_STOP, e8390_base+E8390_CMD);  \n\tfor(i = 0; i < 6; i++) \n\t{\n\t\toutb_p(dev->dev_addr[i], e8390_base + EN1_PHYS_SHIFT(i));\n\t\tif(inb_p(e8390_base + EN1_PHYS_SHIFT(i))!=dev->dev_addr[i])\n\t\t\tnetdev_err(dev, \"Hw. address read/write mismap %d\\n\", i);\n\t}\n\n\toutb_p(ei_local->rx_start_page, e8390_base + EN1_CURPAG);\n\toutb_p(E8390_NODMA+E8390_PAGE0+E8390_STOP, e8390_base+E8390_CMD);\n\n\tnetif_start_queue(dev);\n\tei_local->tx1 = ei_local->tx2 = 0;\n\tei_local->txing = 0;\n\n\tif (info->flags & IS_AX88790)\t \n\t\toutb(0x10, e8390_base + AXNET_GPIO);\n\n\tif (startp) \n\t{\n\t\toutb_p(0xff,  e8390_base + EN0_ISR);\n\t\toutb_p(ENISR_ALL,  e8390_base + EN0_IMR);\n\t\toutb_p(E8390_NODMA+E8390_PAGE0+E8390_START, e8390_base+E8390_CMD);\n\t\toutb_p(E8390_TXCONFIG | info->duplex_flag,\n\t\t       e8390_base + EN0_TXCR);  \n\t\t \n\t\toutb_p(E8390_RXCONFIG | 0x40, e8390_base + EN0_RXCR);  \n\t\tdo_set_multicast_list(dev);\t \n\t}\n}\n\n \n   \nstatic void NS8390_trigger_send(struct net_device *dev, unsigned int length,\n\t\t\t\t\t\t\t\tint start_page)\n{\n\tlong e8390_base = dev->base_addr;\n \tstruct ei_device *ei_local __attribute((unused)) = netdev_priv(dev);\n    \n\tif (inb_p(e8390_base) & E8390_TRANS) \n\t{\n\t\tnetdev_warn(dev, \"trigger_send() called with the transmitter busy\\n\");\n\t\treturn;\n\t}\n\toutb_p(length & 0xff, e8390_base + EN0_TCNTLO);\n\toutb_p(length >> 8, e8390_base + EN0_TCNTHI);\n\toutb_p(start_page, e8390_base + EN0_TPSR);\n\toutb_p(E8390_NODMA+E8390_TRANS+E8390_START, e8390_base+E8390_CMD);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}