{
  "module_name": "mcf8390.c",
  "hash_id": "7743d4507d0dd1983b80f8c0eeab6a4c3f6a28bafedcde14f3931233c46900d6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/8390/mcf8390.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/platform_device.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/jiffies.h>\n#include <linux/io.h>\n#include <asm/mcf8390.h>\n\nstatic const char version[] =\n\t\"mcf8390.c: (15-06-2012) Greg Ungerer <gerg@uclinux.org>\";\n\n#define NE_CMD\t\t0x00\n#define NE_DATAPORT\t0x10\t \n#define NE_RESET\t0x1f\t \n#define NE_EN0_ISR\t0x07\n#define NE_EN0_DCFG\t0x0e\n#define NE_EN0_RSARLO\t0x08\n#define NE_EN0_RSARHI\t0x09\n#define NE_EN0_RCNTLO\t0x0a\n#define NE_EN0_RXCR\t0x0c\n#define NE_EN0_TXCR\t0x0d\n#define NE_EN0_RCNTHI\t0x0b\n#define NE_EN0_IMR\t0x0f\n\n#define NESM_START_PG\t0x40\t \n#define NESM_STOP_PG\t0x80\t \n\n#ifdef NE2000_ODDOFFSET\n \nstatic inline u32 NE_PTR(u32 addr)\n{\n\tif (addr & 1)\n\t\treturn addr - 1 + NE2000_ODDOFFSET;\n\treturn addr;\n}\n\nstatic inline u32 NE_DATA_PTR(u32 addr)\n{\n\treturn addr;\n}\n\nvoid ei_outb(u32 val, u32 addr)\n{\n\tNE2000_BYTE *rp;\n\n\trp = (NE2000_BYTE *) NE_PTR(addr);\n\t*rp = RSWAP(val);\n}\n\n#define\tei_inb\tei_inb\nu8 ei_inb(u32 addr)\n{\n\tNE2000_BYTE *rp, val;\n\n\trp = (NE2000_BYTE *) NE_PTR(addr);\n\tval = *rp;\n\treturn (u8) (RSWAP(val) & 0xff);\n}\n\nvoid ei_insb(u32 addr, void *vbuf, int len)\n{\n\tNE2000_BYTE *rp, val;\n\tu8 *buf;\n\n\tbuf = (u8 *) vbuf;\n\trp = (NE2000_BYTE *) NE_DATA_PTR(addr);\n\tfor (; (len > 0); len--) {\n\t\tval = *rp;\n\t\t*buf++ = RSWAP(val);\n\t}\n}\n\nvoid ei_insw(u32 addr, void *vbuf, int len)\n{\n\tvolatile u16 *rp;\n\tu16 w, *buf;\n\n\tbuf = (u16 *) vbuf;\n\trp = (volatile u16 *) NE_DATA_PTR(addr);\n\tfor (; (len > 0); len--) {\n\t\tw = *rp;\n\t\t*buf++ = BSWAP(w);\n\t}\n}\n\nvoid ei_outsb(u32 addr, const void *vbuf, int len)\n{\n\tNE2000_BYTE *rp, val;\n\tu8 *buf;\n\n\tbuf = (u8 *) vbuf;\n\trp = (NE2000_BYTE *) NE_DATA_PTR(addr);\n\tfor (; (len > 0); len--) {\n\t\tval = *buf++;\n\t\t*rp = RSWAP(val);\n\t}\n}\n\nvoid ei_outsw(u32 addr, const void *vbuf, int len)\n{\n\tvolatile u16 *rp;\n\tu16 w, *buf;\n\n\tbuf = (u16 *) vbuf;\n\trp = (volatile u16 *) NE_DATA_PTR(addr);\n\tfor (; (len > 0); len--) {\n\t\tw = *buf++;\n\t\t*rp = BSWAP(w);\n\t}\n}\n\n#else  \n\n#define\tei_inb\t\tinb\n#define\tei_outb\t\toutb\n#define\tei_insb\t\tinsb\n#define\tei_insw\t\tinsw\n#define\tei_outsb\toutsb\n#define\tei_outsw\toutsw\n\n#endif  \n\n#define\tei_inb_p\tei_inb\n#define\tei_outb_p\tei_outb\n\n#include \"lib8390.c\"\n\n \nstatic void mcf8390_reset_8390(struct net_device *dev)\n{\n\tunsigned long reset_start_time = jiffies;\n\tu32 addr = dev->base_addr;\n\tstruct ei_device *ei_local = netdev_priv(dev);\n\n\tnetif_dbg(ei_local, hw, dev, \"resetting the 8390 t=%ld...\\n\", jiffies);\n\n\tei_outb(ei_inb(addr + NE_RESET), addr + NE_RESET);\n\n\tei_status.txing = 0;\n\tei_status.dmaing = 0;\n\n\t \n\twhile ((ei_inb(addr + NE_EN0_ISR) & ENISR_RESET) == 0) {\n\t\tif (time_after(jiffies, reset_start_time + 2 * HZ / 100)) {\n\t\t\tnetdev_warn(dev, \"%s: did not complete\\n\", __func__);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tei_outb(ENISR_RESET, addr + NE_EN0_ISR);\n}\n\n \nstatic void mcf8390_dmaing_err(const char *func, struct net_device *dev,\n\t\t\t       struct ei_device *ei_local)\n{\n\tnetdev_err(dev, \"%s: DMAing conflict [DMAstat:%d][irqlock:%d]\\n\",\n\t\tfunc, ei_local->dmaing, ei_local->irqlock);\n}\n\n \nstatic void mcf8390_get_8390_hdr(struct net_device *dev,\n\t\t\t\t struct e8390_pkt_hdr *hdr, int ring_page)\n{\n\tstruct ei_device *ei_local = netdev_priv(dev);\n\tu32 addr = dev->base_addr;\n\n\tif (ei_local->dmaing) {\n\t\tmcf8390_dmaing_err(__func__, dev, ei_local);\n\t\treturn;\n\t}\n\n\tei_local->dmaing |= 0x01;\n\tei_outb(E8390_NODMA + E8390_PAGE0 + E8390_START, addr + NE_CMD);\n\tei_outb(ENISR_RDC, addr + NE_EN0_ISR);\n\tei_outb(sizeof(struct e8390_pkt_hdr), addr + NE_EN0_RCNTLO);\n\tei_outb(0, addr + NE_EN0_RCNTHI);\n\tei_outb(0, addr + NE_EN0_RSARLO);\t\t \n\tei_outb(ring_page, addr + NE_EN0_RSARHI);\n\tei_outb(E8390_RREAD + E8390_START, addr + NE_CMD);\n\n\tei_insw(addr + NE_DATAPORT, hdr, sizeof(struct e8390_pkt_hdr) >> 1);\n\n\toutb(ENISR_RDC, addr + NE_EN0_ISR);\t \n\tei_local->dmaing &= ~0x01;\n\n\thdr->count = cpu_to_le16(hdr->count);\n}\n\n \nstatic void mcf8390_block_input(struct net_device *dev, int count,\n\t\t\t\tstruct sk_buff *skb, int ring_offset)\n{\n\tstruct ei_device *ei_local = netdev_priv(dev);\n\tu32 addr = dev->base_addr;\n\tchar *buf = skb->data;\n\n\tif (ei_local->dmaing) {\n\t\tmcf8390_dmaing_err(__func__, dev, ei_local);\n\t\treturn;\n\t}\n\n\tei_local->dmaing |= 0x01;\n\tei_outb(E8390_NODMA + E8390_PAGE0 + E8390_START, addr + NE_CMD);\n\tei_outb(ENISR_RDC, addr + NE_EN0_ISR);\n\tei_outb(count & 0xff, addr + NE_EN0_RCNTLO);\n\tei_outb(count >> 8, addr + NE_EN0_RCNTHI);\n\tei_outb(ring_offset & 0xff, addr + NE_EN0_RSARLO);\n\tei_outb(ring_offset >> 8, addr + NE_EN0_RSARHI);\n\tei_outb(E8390_RREAD + E8390_START, addr + NE_CMD);\n\n\tei_insw(addr + NE_DATAPORT, buf, count >> 1);\n\tif (count & 1)\n\t\tbuf[count - 1] = ei_inb(addr + NE_DATAPORT);\n\n\tei_outb(ENISR_RDC, addr + NE_EN0_ISR);\t \n\tei_local->dmaing &= ~0x01;\n}\n\nstatic void mcf8390_block_output(struct net_device *dev, int count,\n\t\t\t\t const unsigned char *buf,\n\t\t\t\t const int start_page)\n{\n\tstruct ei_device *ei_local = netdev_priv(dev);\n\tu32 addr = dev->base_addr;\n\tunsigned long dma_start;\n\n\t \n\tif (count & 0x1)\n\t\tcount++;\n\n\tif (ei_local->dmaing) {\n\t\tmcf8390_dmaing_err(__func__, dev, ei_local);\n\t\treturn;\n\t}\n\n\tei_local->dmaing |= 0x01;\n\t \n\tei_outb(E8390_PAGE0 + E8390_START + E8390_NODMA, addr + NE_CMD);\n\n\tei_outb(ENISR_RDC, addr + NE_EN0_ISR);\n\n\t \n\tei_outb(count & 0xff, addr + NE_EN0_RCNTLO);\n\tei_outb(count >> 8, addr + NE_EN0_RCNTHI);\n\tei_outb(0x00, addr + NE_EN0_RSARLO);\n\tei_outb(start_page, addr + NE_EN0_RSARHI);\n\tei_outb(E8390_RWRITE + E8390_START, addr + NE_CMD);\n\n\tei_outsw(addr + NE_DATAPORT, buf, count >> 1);\n\n\tdma_start = jiffies;\n\twhile ((ei_inb(addr + NE_EN0_ISR) & ENISR_RDC) == 0) {\n\t\tif (time_after(jiffies, dma_start + 2 * HZ / 100)) {  \n\t\t\tnetdev_warn(dev, \"timeout waiting for Tx RDC\\n\");\n\t\t\tmcf8390_reset_8390(dev);\n\t\t\t__NS8390_init(dev, 1);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tei_outb(ENISR_RDC, addr + NE_EN0_ISR);\t \n\tei_local->dmaing &= ~0x01;\n}\n\nstatic const struct net_device_ops mcf8390_netdev_ops = {\n\t.ndo_open\t\t= __ei_open,\n\t.ndo_stop\t\t= __ei_close,\n\t.ndo_start_xmit\t\t= __ei_start_xmit,\n\t.ndo_tx_timeout\t\t= __ei_tx_timeout,\n\t.ndo_get_stats\t\t= __ei_get_stats,\n\t.ndo_set_rx_mode\t= __ei_set_multicast_list,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_set_mac_address\t= eth_mac_addr,\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\t.ndo_poll_controller\t= __ei_poll,\n#endif\n};\n\nstatic int mcf8390_init(struct net_device *dev)\n{\n\tstatic u32 offsets[] = {\n\t\t0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n\t\t0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n\t};\n\tstruct ei_device *ei_local = netdev_priv(dev);\n\tunsigned char SA_prom[32];\n\tu32 addr = dev->base_addr;\n\tint start_page, stop_page;\n\tint i, ret;\n\n\tmcf8390_reset_8390(dev);\n\n\t \n\t{\n\t\tstatic const struct {\n\t\t\tu32 value;\n\t\t\tu32 offset;\n\t\t} program_seq[] = {\n\t\t\t{E8390_NODMA + E8390_PAGE0 + E8390_STOP, NE_CMD},\n\t\t\t\t\t\t \n\t\t\t{0x48,\tNE_EN0_DCFG},\t \n\t\t\t{0x00,\tNE_EN0_RCNTLO},\t \n\t\t\t{0x00,\tNE_EN0_RCNTHI},\n\t\t\t{0x00,\tNE_EN0_IMR},\t \n\t\t\t{0xFF,\tNE_EN0_ISR},\n\t\t\t{E8390_RXOFF, NE_EN0_RXCR},  \n\t\t\t{E8390_TXOFF, NE_EN0_TXCR},  \n\t\t\t{32,\tNE_EN0_RCNTLO},\n\t\t\t{0x00,\tNE_EN0_RCNTHI},\n\t\t\t{0x00,\tNE_EN0_RSARLO},\t \n\t\t\t{0x00,\tNE_EN0_RSARHI},\n\t\t\t{E8390_RREAD + E8390_START, NE_CMD},\n\t\t};\n\t\tfor (i = 0; i < ARRAY_SIZE(program_seq); i++) {\n\t\t\tei_outb(program_seq[i].value,\n\t\t\t\t addr + program_seq[i].offset);\n\t\t}\n\t}\n\n\tfor (i = 0; i < 16; i++) {\n\t\tSA_prom[i] = ei_inb(addr + NE_DATAPORT);\n\t\tei_inb(addr + NE_DATAPORT);\n\t}\n\n\t \n\tei_outb(0x49, addr + NE_EN0_DCFG);\n\tstart_page = NESM_START_PG;\n\tstop_page = NESM_STOP_PG;\n\n\t \n\tret = request_irq(dev->irq, __ei_interrupt, 0, dev->name, dev);\n\tif (ret)\n\t\treturn ret;\n\n\teth_hw_addr_set(dev, SA_prom);\n\n\tnetdev_dbg(dev, \"Found ethernet address: %pM\\n\", dev->dev_addr);\n\n\tei_local->name = \"mcf8390\";\n\tei_local->tx_start_page = start_page;\n\tei_local->stop_page = stop_page;\n\tei_local->word16 = 1;\n\tei_local->rx_start_page = start_page + TX_PAGES;\n\tei_local->reset_8390 = mcf8390_reset_8390;\n\tei_local->block_input = mcf8390_block_input;\n\tei_local->block_output = mcf8390_block_output;\n\tei_local->get_8390_hdr = mcf8390_get_8390_hdr;\n\tei_local->reg_offset = offsets;\n\n\tdev->netdev_ops = &mcf8390_netdev_ops;\n\t__NS8390_init(dev, 0);\n\tret = register_netdev(dev);\n\tif (ret) {\n\t\tfree_irq(dev->irq, dev);\n\t\treturn ret;\n\t}\n\n\tnetdev_info(dev, \"addr=0x%08x irq=%d, Ethernet Address %pM\\n\",\n\t\taddr, dev->irq, dev->dev_addr);\n\treturn 0;\n}\n\nstatic int mcf8390_probe(struct platform_device *pdev)\n{\n\tstruct net_device *dev;\n\tstruct resource *mem;\n\tresource_size_t msize;\n\tint ret, irq;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn -ENXIO;\n\n\tmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (mem == NULL) {\n\t\tdev_err(&pdev->dev, \"no memory address specified?\\n\");\n\t\treturn -ENXIO;\n\t}\n\tmsize = resource_size(mem);\n\tif (!request_mem_region(mem->start, msize, pdev->name))\n\t\treturn -EBUSY;\n\n\tdev = ____alloc_ei_netdev(0);\n\tif (dev == NULL) {\n\t\trelease_mem_region(mem->start, msize);\n\t\treturn -ENOMEM;\n\t}\n\n\tSET_NETDEV_DEV(dev, &pdev->dev);\n\tplatform_set_drvdata(pdev, dev);\n\n\tdev->irq = irq;\n\tdev->base_addr = mem->start;\n\n\tret = mcf8390_init(dev);\n\tif (ret) {\n\t\trelease_mem_region(mem->start, msize);\n\t\tfree_netdev(dev);\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic int mcf8390_remove(struct platform_device *pdev)\n{\n\tstruct net_device *dev = platform_get_drvdata(pdev);\n\tstruct resource *mem;\n\n\tunregister_netdev(dev);\n\tmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\trelease_mem_region(mem->start, resource_size(mem));\n\tfree_netdev(dev);\n\treturn 0;\n}\n\nstatic struct platform_driver mcf8390_drv = {\n\t.driver = {\n\t\t.name\t= \"mcf8390\",\n\t},\n\t.probe\t\t= mcf8390_probe,\n\t.remove\t\t= mcf8390_remove,\n};\n\nmodule_platform_driver(mcf8390_drv);\n\nMODULE_DESCRIPTION(\"MCF8390 ColdFire NS8390 driver\");\nMODULE_AUTHOR(\"Greg Ungerer <gerg@uclinux.org>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:mcf8390\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}