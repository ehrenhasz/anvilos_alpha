{
  "module_name": "wd.c",
  "hash_id": "0a8d6d1fcb16eefea078e50a3abdead8b29f9f02a3edce9448dfbb48974dcde0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/8390/wd.c",
  "human_readable_source": "\n \n \n\nstatic const char version[] =\n\t\"wd.c:v1.10 9/23/94 Donald Becker (becker@cesdis.gsfc.nasa.gov)\\n\";\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <net/Space.h>\n\n#include <asm/io.h>\n\n#include \"8390.h\"\n\n#define DRV_NAME \"wd\"\n\n \nstatic unsigned int wd_portlist[] __initdata =\n{0x300, 0x280, 0x380, 0x240, 0};\n\nstatic int wd_probe1(struct net_device *dev, int ioaddr);\n\nstatic int wd_open(struct net_device *dev);\nstatic void wd_reset_8390(struct net_device *dev);\nstatic void wd_get_8390_hdr(struct net_device *dev, struct e8390_pkt_hdr *hdr,\n\t\t\t\t\t\tint ring_page);\nstatic void wd_block_input(struct net_device *dev, int count,\n\t\t\t\t\t\t  struct sk_buff *skb, int ring_offset);\nstatic void wd_block_output(struct net_device *dev, int count,\n\t\t\t\t\t\t\tconst unsigned char *buf, int start_page);\nstatic int wd_close(struct net_device *dev);\n\nstatic u32 wd_msg_enable;\n\n#define WD_START_PG\t\t0x00\t \n#define WD03_STOP_PG\t0x20\t \n#define WD13_STOP_PG\t0x40\t \n\n#define WD_CMDREG\t\t0\t\t \n#define\t WD_RESET\t\t0x80\t \n#define\t WD_MEMENB\t\t0x40\t \n#define WD_CMDREG5\t\t5\t\t \n#define\t ISA16\t\t\t0x80\t \n#define\t NIC16\t\t\t0x40\t \n#define WD_NIC_OFFSET\t16\t\t \n#define WD_IO_EXTENT\t32\n\n\n \n\nstatic int __init do_wd_probe(struct net_device *dev)\n{\n\tint i;\n\tstruct resource *r;\n\tint base_addr = dev->base_addr;\n\tint irq = dev->irq;\n\tint mem_start = dev->mem_start;\n\tint mem_end = dev->mem_end;\n\n\tif (base_addr > 0x1ff) {\t \n\t\tr = request_region(base_addr, WD_IO_EXTENT, \"wd-probe\");\n\t\tif ( r == NULL)\n\t\t\treturn -EBUSY;\n\t\ti = wd_probe1(dev, base_addr);\n\t\tif (i != 0)\n\t\t\trelease_region(base_addr, WD_IO_EXTENT);\n\t\telse\n\t\t\tr->name = dev->name;\n\t\treturn i;\n\t}\n\telse if (base_addr != 0)\t \n\t\treturn -ENXIO;\n\n\tfor (i = 0; wd_portlist[i]; i++) {\n\t\tint ioaddr = wd_portlist[i];\n\t\tr = request_region(ioaddr, WD_IO_EXTENT, \"wd-probe\");\n\t\tif (r == NULL)\n\t\t\tcontinue;\n\t\tif (wd_probe1(dev, ioaddr) == 0) {\n\t\t\tr->name = dev->name;\n\t\t\treturn 0;\n\t\t}\n\t\trelease_region(ioaddr, WD_IO_EXTENT);\n\t\tdev->irq = irq;\n\t\tdev->mem_start = mem_start;\n\t\tdev->mem_end = mem_end;\n\t}\n\n\treturn -ENODEV;\n}\n\n#ifndef MODULE\nstruct net_device * __init wd_probe(int unit)\n{\n\tstruct net_device *dev = alloc_ei_netdev();\n\tint err;\n\n\tif (!dev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tsprintf(dev->name, \"eth%d\", unit);\n\tnetdev_boot_setup_check(dev);\n\n\terr = do_wd_probe(dev);\n\tif (err)\n\t\tgoto out;\n\treturn dev;\nout:\n\tfree_netdev(dev);\n\treturn ERR_PTR(err);\n}\n#endif\n\nstatic const struct net_device_ops wd_netdev_ops = {\n\t.ndo_open\t\t= wd_open,\n\t.ndo_stop\t\t= wd_close,\n\t.ndo_start_xmit\t\t= ei_start_xmit,\n\t.ndo_tx_timeout\t\t= ei_tx_timeout,\n\t.ndo_get_stats\t\t= ei_get_stats,\n\t.ndo_set_rx_mode\t= ei_set_multicast_list,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_set_mac_address \t= eth_mac_addr,\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\t.ndo_poll_controller \t= ei_poll,\n#endif\n};\n\nstatic int __init wd_probe1(struct net_device *dev, int ioaddr)\n{\n\tint i;\n\tint err;\n\tint checksum = 0;\n\tint ancient = 0;\t\t\t \n\tint word16 = 0;\t\t\t\t \n\tu8 addr[ETH_ALEN];\n\tconst char *model_name;\n\tstatic unsigned version_printed;\n\tstruct ei_device *ei_local = netdev_priv(dev);\n\n\tfor (i = 0; i < 8; i++)\n\t\tchecksum += inb(ioaddr + 8 + i);\n\tif (inb(ioaddr + 8) == 0xff \t \n\t\t|| inb(ioaddr + 9) == 0xff\n\t\t|| (checksum & 0xff) != 0xFF)\n\t\treturn -ENODEV;\n\n\t \n\tif ((dev->mem_start % 0x2000) || (dev->mem_end % 0x2000)) {\n\t\tnetdev_warn(dev,\n\t\t\t    \"wd.c: user supplied mem_start or mem_end not on 8kB boundary - ignored.\\n\");\n\t\tdev->mem_start = 0;\n\t\tdev->mem_end = 0;\n\t}\n\n\tif ((wd_msg_enable & NETIF_MSG_DRV) && (version_printed++ == 0))\n\t\tnetdev_info(dev, version);\n\n\tfor (i = 0; i < 6; i++)\n\t\taddr[i] = inb(ioaddr + 8 + i);\n\teth_hw_addr_set(dev, addr);\n\n\tnetdev_info(dev, \"WD80x3 at %#3x, %pM\", ioaddr, dev->dev_addr);\n\n\t \n\tif (inb(ioaddr+0) == 'P' && inb(ioaddr+1) == 'D') {\n\t\tunsigned char reg5 = inb(ioaddr+5);\n\n\t\tswitch (inb(ioaddr+2)) {\n\t\tcase 0x03: word16 = 0; model_name = \"PDI8023-8\";\tbreak;\n\t\tcase 0x05: word16 = 0; model_name = \"PDUC8023\";\tbreak;\n\t\tcase 0x0a: word16 = 1; model_name = \"PDI8023-16\"; break;\n\t\t\t \n\t\tdefault:\t word16 = 0; model_name = \"PDI8023\";\tbreak;\n\t\t}\n\t\tdev->mem_start = ((reg5 & 0x1c) + 0xc0) << 12;\n\t\tdev->irq = (reg5 & 0xe0) == 0xe0 ? 10 : (reg5 >> 5) + 1;\n\t} else {\t\t\t\t\t\t\t\t \n\t\t \n\t\t \n\t\tfor (i = 0; i < 6; i++)\n\t\t\tif (inb(ioaddr+i) != inb(ioaddr+8+i))\n\t\t\t\tbreak;\n\t\tif (i >= 6) {\n\t\t\tancient = 1;\n\t\t\tmodel_name = \"WD8003-old\";\n\t\t\tword16 = 0;\n\t\t} else {\n\t\t\tint tmp = inb(ioaddr+1);  \n\t\t\toutb( tmp ^ 0x01, ioaddr+1 );  \n\t\t\tif (((inb( ioaddr+1) & 0x01) == 0x01)  \n\t\t\t\t&& (tmp & 0x01) == 0x01\t) {\t\t\t\t \n\t\t\t\tint asic_reg5 = inb(ioaddr+WD_CMDREG5);\n\t\t\t\t \n\t\t\t\toutb( NIC16 | (asic_reg5&0x1f), ioaddr+WD_CMDREG5);\n\t\t\t\toutb(tmp, ioaddr+1);\n\t\t\t\tmodel_name = \"WD8013\";\n\t\t\t\tword16 = 1;\t\t \n\t\t\t} else {\n\t\t\t\tmodel_name = \"WD8003\";\n\t\t\t\tword16 = 0;\n\t\t\t}\n\t\t\toutb(tmp, ioaddr+1);\t\t\t \n\t\t}\n#ifndef final_version\n\t\tif ( !ancient && (inb(ioaddr+1) & 0x01) != (word16 & 0x01))\n\t\t\tpr_cont(\"\\nWD80?3: Bus width conflict, %d (probe) != %d (reg report).\",\n\t\t\t\tword16 ? 16 : 8,\n\t\t\t\t(inb(ioaddr+1) & 0x01) ? 16 : 8);\n#endif\n\t}\n\n#if defined(WD_SHMEM) && WD_SHMEM > 0x80000\n\t \n\tdev->mem_start = WD_SHMEM;\n#else\n\tif (dev->mem_start == 0) {\n\t\t \n\t\tint reg0 = inb(ioaddr);\n\t\tif (reg0 == 0xff || reg0 == 0) {\n\t\t\t \n\t\t\tdev->mem_start = 0xd0000;\n\t\t\tpr_cont(\" assigning address %#lx\", dev->mem_start);\n\t\t} else {\n\t\t\tint high_addr_bits = inb(ioaddr+WD_CMDREG5) & 0x1f;\n\t\t\t \n\t\t\tif (high_addr_bits == 0x1f || word16 == 0)\n\t\t\t\thigh_addr_bits = 0x01;\n\t\t\tdev->mem_start = ((reg0&0x3f) << 13) + (high_addr_bits << 19);\n\t\t}\n\t}\n#endif\n\n\t \n\tdev->base_addr = ioaddr+WD_NIC_OFFSET;\n\n\tif (dev->irq < 2) {\n\t\tstatic const int irqmap[] = {9, 3, 5, 7, 10, 11, 15, 4};\n\t\tint reg1 = inb(ioaddr+1);\n\t\tint reg4 = inb(ioaddr+4);\n\t\tif (ancient || reg1 == 0xff) {\t \n\t\t\tshort nic_addr = ioaddr+WD_NIC_OFFSET;\n\t\t\tunsigned long irq_mask;\n\n\t\t\t \n\t\t\toutb_p(E8390_NODMA + E8390_STOP, nic_addr);\n\t\t\toutb(0x00, nic_addr+EN0_IMR);\t \n\n\t\t\tirq_mask = probe_irq_on();\n\t\t\toutb_p(0xff, nic_addr + EN0_IMR);\t \n\t\t\toutb_p(0x00, nic_addr + EN0_RCNTLO);\n\t\t\toutb_p(0x00, nic_addr + EN0_RCNTHI);\n\t\t\toutb(E8390_RREAD+E8390_START, nic_addr);  \n\t\t\tmdelay(20);\n\t\t\tdev->irq = probe_irq_off(irq_mask);\n\n\t\t\toutb_p(0x00, nic_addr+EN0_IMR);\t \n\n\t\t\tif (wd_msg_enable & NETIF_MSG_PROBE)\n\t\t\t\tpr_cont(\" autoirq is %d\", dev->irq);\n\t\t\tif (dev->irq < 2)\n\t\t\t\tdev->irq = word16 ? 10 : 5;\n\t\t} else\n\t\t\tdev->irq = irqmap[((reg4 >> 5) & 0x03) + (reg1 & 0x04)];\n\t} else if (dev->irq == 2)\t\t \n\t\tdev->irq = 9;\n\n\t \n\ti = request_irq(dev->irq, ei_interrupt, 0, DRV_NAME, dev);\n\tif (i) {\n\t\tpr_cont(\" unable to get IRQ %d.\\n\", dev->irq);\n\t\treturn i;\n\t}\n\n\t \n\tei_status.name = model_name;\n\tei_status.word16 = word16;\n\tei_status.tx_start_page = WD_START_PG;\n\tei_status.rx_start_page = WD_START_PG + TX_PAGES;\n\n\t \n\n\t \n\tif (dev->mem_end != 0) {\n\t\tei_status.stop_page = (dev->mem_end - dev->mem_start)/256;\n\t\tei_status.priv = dev->mem_end - dev->mem_start;\n\t} else {\n\t\tei_status.stop_page = word16 ? WD13_STOP_PG : WD03_STOP_PG;\n\t\tdev->mem_end = dev->mem_start + (ei_status.stop_page - WD_START_PG)*256;\n\t\tei_status.priv = (ei_status.stop_page - WD_START_PG)*256;\n\t}\n\n\tei_status.mem = ioremap(dev->mem_start, ei_status.priv);\n\tif (!ei_status.mem) {\n\t\tfree_irq(dev->irq, dev);\n\t\treturn -ENOMEM;\n\t}\n\n\tpr_cont(\" %s, IRQ %d, shared memory at %#lx-%#lx.\\n\",\n\t\tmodel_name, dev->irq, dev->mem_start, dev->mem_end-1);\n\n\tei_status.reset_8390 = wd_reset_8390;\n\tei_status.block_input = wd_block_input;\n\tei_status.block_output = wd_block_output;\n\tei_status.get_8390_hdr = wd_get_8390_hdr;\n\n\tdev->netdev_ops = &wd_netdev_ops;\n\tNS8390_init(dev, 0);\n\tei_local->msg_enable = wd_msg_enable;\n\n#if 1\n\t \n\t \n\tif (inb(ioaddr+14) & 0x20)\n\t\toutb(inb(ioaddr+4)|0x80, ioaddr+4);\n#endif\n\n\terr = register_netdev(dev);\n\tif (err) {\n\t\tfree_irq(dev->irq, dev);\n\t\tiounmap(ei_status.mem);\n\t}\n\treturn err;\n}\n\nstatic int\nwd_open(struct net_device *dev)\n{\n  int ioaddr = dev->base_addr - WD_NIC_OFFSET;  \n\n   \n  ei_status.reg0 = ((dev->mem_start>>13) & 0x3f) | WD_MEMENB;\n  ei_status.reg5 = ((dev->mem_start>>19) & 0x1f) | NIC16;\n\n  if (ei_status.word16)\n\t  outb(ei_status.reg5, ioaddr+WD_CMDREG5);\n  outb(ei_status.reg0, ioaddr);  \n\n  return ei_open(dev);\n}\n\nstatic void\nwd_reset_8390(struct net_device *dev)\n{\n\tint wd_cmd_port = dev->base_addr - WD_NIC_OFFSET;  \n\tstruct ei_device *ei_local = netdev_priv(dev);\n\n\toutb(WD_RESET, wd_cmd_port);\n\tnetif_dbg(ei_local, hw, dev, \"resetting the WD80x3 t=%lu...\\n\",\n\t\t  jiffies);\n\tei_status.txing = 0;\n\n\t \n\toutb((((dev->mem_start>>13) & 0x3f)|WD_MEMENB), wd_cmd_port);\n\tif (ei_status.word16)\n\t\toutb(NIC16 | ((dev->mem_start>>19) & 0x1f), wd_cmd_port+WD_CMDREG5);\n\n\tnetif_dbg(ei_local, hw, dev, \"reset done\\n\");\n}\n\n \n\nstatic void\nwd_get_8390_hdr(struct net_device *dev, struct e8390_pkt_hdr *hdr, int ring_page)\n{\n\n\tint wd_cmdreg = dev->base_addr - WD_NIC_OFFSET;  \n\tvoid __iomem *hdr_start = ei_status.mem + ((ring_page - WD_START_PG)<<8);\n\n\t \n\tif (ei_status.word16)\n\t\toutb(ISA16 | ei_status.reg5, wd_cmdreg+WD_CMDREG5);\n\n#ifdef __BIG_ENDIAN\n\t \n\t \n\tmemcpy_fromio(hdr, hdr_start, sizeof(struct e8390_pkt_hdr));\n\thdr->count = le16_to_cpu(hdr->count);\n#else\n\t((unsigned int*)hdr)[0] = readl(hdr_start);\n#endif\n}\n\n \n\nstatic void\nwd_block_input(struct net_device *dev, int count, struct sk_buff *skb, int ring_offset)\n{\n\tint wd_cmdreg = dev->base_addr - WD_NIC_OFFSET;  \n\tunsigned long offset = ring_offset - (WD_START_PG<<8);\n\tvoid __iomem *xfer_start = ei_status.mem + offset;\n\n\tif (offset + count > ei_status.priv) {\n\t\t \n\t\tint semi_count = ei_status.priv - offset;\n\t\tmemcpy_fromio(skb->data, xfer_start, semi_count);\n\t\tcount -= semi_count;\n\t\tmemcpy_fromio(skb->data + semi_count, ei_status.mem + TX_PAGES * 256, count);\n\t} else {\n\t\t \n\t\tmemcpy_fromio(skb->data, xfer_start, count);\n\t}\n\n\t \n\tif (ei_status.word16)\n\t\toutb(ei_status.reg5, wd_cmdreg+WD_CMDREG5);\n}\n\nstatic void\nwd_block_output(struct net_device *dev, int count, const unsigned char *buf,\n\t\t\t\tint start_page)\n{\n\tint wd_cmdreg = dev->base_addr - WD_NIC_OFFSET;  \n\tvoid __iomem *shmem = ei_status.mem + ((start_page - WD_START_PG)<<8);\n\n\n\tif (ei_status.word16) {\n\t\t \n\t\toutb(ISA16 | ei_status.reg5, wd_cmdreg+WD_CMDREG5);\n\t\tmemcpy_toio(shmem, buf, count);\n\t\toutb(ei_status.reg5, wd_cmdreg+WD_CMDREG5);\n\t} else\n\t\tmemcpy_toio(shmem, buf, count);\n}\n\n\nstatic int\nwd_close(struct net_device *dev)\n{\n\tint wd_cmdreg = dev->base_addr - WD_NIC_OFFSET;  \n\tstruct ei_device *ei_local = netdev_priv(dev);\n\n\tnetif_dbg(ei_local, ifdown, dev, \"Shutting down ethercard.\\n\");\n\tei_close(dev);\n\n\t \n\tif (ei_status.word16)\n\t\toutb(ei_status.reg5, wd_cmdreg + WD_CMDREG5 );\n\n\t \n\toutb(ei_status.reg0 & ~WD_MEMENB, wd_cmdreg);\n\n\treturn 0;\n}\n\n\n#ifdef MODULE\n#define MAX_WD_CARDS\t4\t \nstatic struct net_device *dev_wd[MAX_WD_CARDS];\nstatic int io[MAX_WD_CARDS];\nstatic int irq[MAX_WD_CARDS];\nstatic int mem[MAX_WD_CARDS];\nstatic int mem_end[MAX_WD_CARDS];\t \n\nmodule_param_hw_array(io, int, ioport, NULL, 0);\nmodule_param_hw_array(irq, int, irq, NULL, 0);\nmodule_param_hw_array(mem, int, iomem, NULL, 0);\nmodule_param_hw_array(mem_end, int, iomem, NULL, 0);\nmodule_param_named(msg_enable, wd_msg_enable, uint, 0444);\nMODULE_PARM_DESC(io, \"I/O base address(es)\");\nMODULE_PARM_DESC(irq, \"IRQ number(s) (ignored for PureData boards)\");\nMODULE_PARM_DESC(mem, \"memory base address(es)(ignored for PureData boards)\");\nMODULE_PARM_DESC(mem_end, \"memory end address(es)\");\nMODULE_PARM_DESC(msg_enable, \"Debug message level (see linux/netdevice.h for bitmap)\");\nMODULE_DESCRIPTION(\"ISA Western Digital wd8003/wd8013 ; SMC Elite, Elite16 ethernet driver\");\nMODULE_LICENSE(\"GPL\");\n\n \n\nstatic int __init wd_init_module(void)\n{\n\tstruct net_device *dev;\n\tint this_dev, found = 0;\n\n\tfor (this_dev = 0; this_dev < MAX_WD_CARDS; this_dev++) {\n\t\tif (io[this_dev] == 0)  {\n\t\t\tif (this_dev != 0) break;  \n\t\t\tprintk(KERN_NOTICE \"wd.c: Presently autoprobing (not recommended) for a single card.\\n\");\n\t\t}\n\t\tdev = alloc_ei_netdev();\n\t\tif (!dev)\n\t\t\tbreak;\n\t\tdev->irq = irq[this_dev];\n\t\tdev->base_addr = io[this_dev];\n\t\tdev->mem_start = mem[this_dev];\n\t\tdev->mem_end = mem_end[this_dev];\n\t\tif (do_wd_probe(dev) == 0) {\n\t\t\tdev_wd[found++] = dev;\n\t\t\tcontinue;\n\t\t}\n\t\tfree_netdev(dev);\n\t\tprintk(KERN_WARNING \"wd.c: No wd80x3 card found (i/o = 0x%x).\\n\", io[this_dev]);\n\t\tbreak;\n\t}\n\tif (found)\n\t\treturn 0;\n\treturn -ENXIO;\n}\nmodule_init(wd_init_module);\n\nstatic void cleanup_card(struct net_device *dev)\n{\n\tfree_irq(dev->irq, dev);\n\trelease_region(dev->base_addr - WD_NIC_OFFSET, WD_IO_EXTENT);\n\tiounmap(ei_status.mem);\n}\n\nstatic void __exit wd_cleanup_module(void)\n{\n\tint this_dev;\n\n\tfor (this_dev = 0; this_dev < MAX_WD_CARDS; this_dev++) {\n\t\tstruct net_device *dev = dev_wd[this_dev];\n\t\tif (dev) {\n\t\t\tunregister_netdev(dev);\n\t\t\tcleanup_card(dev);\n\t\t\tfree_netdev(dev);\n\t\t}\n\t}\n}\nmodule_exit(wd_cleanup_module);\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}