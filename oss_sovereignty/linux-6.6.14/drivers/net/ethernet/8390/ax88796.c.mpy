{
  "module_name": "ax88796.c",
  "hash_id": "f9abb071fe4f83ba478adee8c94ed0fe21ab8de614895a67fac66dc8b5a32497",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/8390/ax88796.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/isapnp.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/platform_device.h>\n#include <linux/delay.h>\n#include <linux/timer.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/ethtool.h>\n#include <linux/mdio-bitbang.h>\n#include <linux/phy.h>\n#include <linux/eeprom_93cx6.h>\n#include <linux/slab.h>\n\n#include <net/ax88796.h>\n\n\n \n#define __ei_open ax_ei_open\n#define __ei_close ax_ei_close\n#define __ei_poll ax_ei_poll\n#define __ei_start_xmit ax_ei_start_xmit\n#define __ei_tx_timeout ax_ei_tx_timeout\n#define __ei_get_stats ax_ei_get_stats\n#define __ei_set_multicast_list ax_ei_set_multicast_list\n#define __ei_interrupt ax_ei_interrupt\n#define ____alloc_ei_netdev ax__alloc_ei_netdev\n#define __NS8390_init ax_NS8390_init\n\n \n#define ax_convert_addr(_a) ((void __force __iomem *)(_a))\n\n#define ei_inb(_a) readb(ax_convert_addr(_a))\n#define ei_outb(_v, _a) writeb(_v, ax_convert_addr(_a))\n\n#define ei_inb_p(_a) ei_inb(_a)\n#define ei_outb_p(_v, _a) ei_outb(_v, _a)\n\n \n#define EI_SHIFT(x) (ei_local->reg_offset[(x)])\n\n \n#define AX88796_PLATFORM\n\nstatic unsigned char version[] = \"ax88796.c: Copyright 2005,2007 Simtec Electronics\\n\";\n\n#include \"lib8390.c\"\n\n#define DRV_NAME \"ax88796\"\n#define DRV_VERSION \"1.00\"\n\n \n#define NE_CMD\t\tEI_SHIFT(0x00)\n#define NE_RESET\tEI_SHIFT(0x1f)\n#define NE_DATAPORT\tEI_SHIFT(0x10)\n\n#define NE1SM_START_PG\t0x20\t \n#define NE1SM_STOP_PG\t0x40\t \n#define NESM_START_PG\t0x40\t \n#define NESM_STOP_PG\t0x80\t \n\n#define AX_GPOC_PPDSET\tBIT(6)\n\n \n\nstruct ax_device {\n\tstruct mii_bus *mii_bus;\n\tstruct mdiobb_ctrl bb_ctrl;\n\tvoid __iomem *addr_memr;\n\tu8 reg_memr;\n\tint link;\n\tint speed;\n\tint duplex;\n\n\tvoid __iomem *map2;\n\tconst struct ax_plat_data *plat;\n\n\tunsigned char running;\n\tunsigned char resume_open;\n\tunsigned int irqflags;\n\n\tu32 reg_offsets[0x20];\n};\n\nstatic inline struct ax_device *to_ax_dev(struct net_device *dev)\n{\n\tstruct ei_device *ei_local = netdev_priv(dev);\n\treturn (struct ax_device *)(ei_local + 1);\n}\n\nvoid ax_NS8390_reinit(struct net_device *dev)\n{\n\tax_NS8390_init(dev, 1);\n}\n\nEXPORT_SYMBOL_GPL(ax_NS8390_reinit);\n\n \nstatic int ax_initial_check(struct net_device *dev)\n{\n\tstruct ei_device *ei_local = netdev_priv(dev);\n\tvoid __iomem *ioaddr = ei_local->mem;\n\tint reg0;\n\tint regd;\n\n\treg0 = ei_inb(ioaddr);\n\tif (reg0 == 0xFF)\n\t\treturn -ENODEV;\n\n\tei_outb(E8390_NODMA + E8390_PAGE1 + E8390_STOP, ioaddr + E8390_CMD);\n\tregd = ei_inb(ioaddr + 0x0d);\n\tei_outb(0xff, ioaddr + 0x0d);\n\tei_outb(E8390_NODMA + E8390_PAGE0, ioaddr + E8390_CMD);\n\tei_inb(ioaddr + EN0_COUNTER0);  \n\tif (ei_inb(ioaddr + EN0_COUNTER0) != 0) {\n\t\tei_outb(reg0, ioaddr);\n\t\tei_outb(regd, ioaddr + 0x0d);\t \n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void ax_reset_8390(struct net_device *dev)\n{\n\tstruct ei_device *ei_local = netdev_priv(dev);\n\tunsigned long reset_start_time = jiffies;\n\tvoid __iomem *addr = (void __iomem *)dev->base_addr;\n\n\tnetif_dbg(ei_local, hw, dev, \"resetting the 8390 t=%ld...\\n\", jiffies);\n\n\tei_outb(ei_inb(addr + NE_RESET), addr + NE_RESET);\n\n\tei_local->txing = 0;\n\tei_local->dmaing = 0;\n\n\t \n\twhile ((ei_inb(addr + EN0_ISR) & ENISR_RESET) == 0) {\n\t\tif (time_after(jiffies, reset_start_time + 2 * HZ / 100)) {\n\t\t\tnetdev_warn(dev, \"%s: did not complete.\\n\", __func__);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tei_outb(ENISR_RESET, addr + EN0_ISR);\t \n}\n\n \nstatic irqreturn_t ax_ei_interrupt_filtered(int irq, void *dev_id)\n{\n\tstruct net_device *dev = dev_id;\n\tstruct ax_device *ax = to_ax_dev(dev);\n\tstruct platform_device *pdev = to_platform_device(dev->dev.parent);\n\n\tif (!ax->plat->check_irq(pdev))\n\t\treturn IRQ_NONE;\n\n\treturn ax_ei_interrupt(irq, dev_id);\n}\n\nstatic void ax_get_8390_hdr(struct net_device *dev, struct e8390_pkt_hdr *hdr,\n\t\t\t    int ring_page)\n{\n\tstruct ei_device *ei_local = netdev_priv(dev);\n\tvoid __iomem *nic_base = ei_local->mem;\n\n\t \n\tif (ei_local->dmaing) {\n\t\tnetdev_err(dev, \"DMAing conflict in %s \"\n\t\t\t\"[DMAstat:%d][irqlock:%d].\\n\",\n\t\t\t__func__,\n\t\t\tei_local->dmaing, ei_local->irqlock);\n\t\treturn;\n\t}\n\n\tei_local->dmaing |= 0x01;\n\tei_outb(E8390_NODMA + E8390_PAGE0 + E8390_START, nic_base + NE_CMD);\n\tei_outb(sizeof(struct e8390_pkt_hdr), nic_base + EN0_RCNTLO);\n\tei_outb(0, nic_base + EN0_RCNTHI);\n\tei_outb(0, nic_base + EN0_RSARLO);\t\t \n\tei_outb(ring_page, nic_base + EN0_RSARHI);\n\tei_outb(E8390_RREAD+E8390_START, nic_base + NE_CMD);\n\n\tif (ei_local->word16)\n\t\tioread16_rep(nic_base + NE_DATAPORT, hdr,\n\t\t\t     sizeof(struct e8390_pkt_hdr) >> 1);\n\telse\n\t\tioread8_rep(nic_base + NE_DATAPORT, hdr,\n\t\t\t    sizeof(struct e8390_pkt_hdr));\n\n\tei_outb(ENISR_RDC, nic_base + EN0_ISR);\t \n\tei_local->dmaing &= ~0x01;\n\n\tle16_to_cpus(&hdr->count);\n}\n\n\n \nstatic void ax_block_input(struct net_device *dev, int count,\n\t\t\t   struct sk_buff *skb, int ring_offset)\n{\n\tstruct ei_device *ei_local = netdev_priv(dev);\n\tvoid __iomem *nic_base = ei_local->mem;\n\tchar *buf = skb->data;\n\n\tif (ei_local->dmaing) {\n\t\tnetdev_err(dev,\n\t\t\t\"DMAing conflict in %s \"\n\t\t\t\"[DMAstat:%d][irqlock:%d].\\n\",\n\t\t\t__func__,\n\t\t\tei_local->dmaing, ei_local->irqlock);\n\t\treturn;\n\t}\n\n\tei_local->dmaing |= 0x01;\n\n\tei_outb(E8390_NODMA+E8390_PAGE0+E8390_START, nic_base + NE_CMD);\n\tei_outb(count & 0xff, nic_base + EN0_RCNTLO);\n\tei_outb(count >> 8, nic_base + EN0_RCNTHI);\n\tei_outb(ring_offset & 0xff, nic_base + EN0_RSARLO);\n\tei_outb(ring_offset >> 8, nic_base + EN0_RSARHI);\n\tei_outb(E8390_RREAD+E8390_START, nic_base + NE_CMD);\n\n\tif (ei_local->word16) {\n\t\tioread16_rep(nic_base + NE_DATAPORT, buf, count >> 1);\n\t\tif (count & 0x01)\n\t\t\tbuf[count-1] = ei_inb(nic_base + NE_DATAPORT);\n\n\t} else {\n\t\tioread8_rep(nic_base + NE_DATAPORT, buf, count);\n\t}\n\n\tei_local->dmaing &= ~1;\n}\n\nstatic void ax_block_output(struct net_device *dev, int count,\n\t\t\t    const unsigned char *buf, const int start_page)\n{\n\tstruct ei_device *ei_local = netdev_priv(dev);\n\tvoid __iomem *nic_base = ei_local->mem;\n\tunsigned long dma_start;\n\n\t \n\tif (ei_local->word16 && (count & 0x01))\n\t\tcount++;\n\n\t \n\tif (ei_local->dmaing) {\n\t\tnetdev_err(dev, \"DMAing conflict in %s.\"\n\t\t\t\"[DMAstat:%d][irqlock:%d]\\n\",\n\t\t\t__func__,\n\t\t       ei_local->dmaing, ei_local->irqlock);\n\t\treturn;\n\t}\n\n\tei_local->dmaing |= 0x01;\n\t \n\tei_outb(E8390_PAGE0+E8390_START+E8390_NODMA, nic_base + NE_CMD);\n\n\tei_outb(ENISR_RDC, nic_base + EN0_ISR);\n\n\t \n\tei_outb(count & 0xff, nic_base + EN0_RCNTLO);\n\tei_outb(count >> 8, nic_base + EN0_RCNTHI);\n\tei_outb(0x00, nic_base + EN0_RSARLO);\n\tei_outb(start_page, nic_base + EN0_RSARHI);\n\n\tei_outb(E8390_RWRITE+E8390_START, nic_base + NE_CMD);\n\tif (ei_local->word16)\n\t\tiowrite16_rep(nic_base + NE_DATAPORT, buf, count >> 1);\n\telse\n\t\tiowrite8_rep(nic_base + NE_DATAPORT, buf, count);\n\n\tdma_start = jiffies;\n\n\twhile ((ei_inb(nic_base + EN0_ISR) & ENISR_RDC) == 0) {\n\t\tif (time_after(jiffies, dma_start + 2 * HZ / 100)) {  \n\t\t\tnetdev_warn(dev, \"timeout waiting for Tx RDC.\\n\");\n\t\t\tax_reset_8390(dev);\n\t\t\tax_NS8390_init(dev, 1);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tei_outb(ENISR_RDC, nic_base + EN0_ISR);\t \n\tei_local->dmaing &= ~0x01;\n}\n\n \n\n#define AX_MEMR\t\t\tEI_SHIFT(0x14)\n#define AX_MEMR_MDC\t\tBIT(0)\n#define AX_MEMR_MDIR\t\tBIT(1)\n#define AX_MEMR_MDI\t\tBIT(2)\n#define AX_MEMR_MDO\t\tBIT(3)\n#define AX_MEMR_EECS\t\tBIT(4)\n#define AX_MEMR_EEI\t\tBIT(5)\n#define AX_MEMR_EEO\t\tBIT(6)\n#define AX_MEMR_EECLK\t\tBIT(7)\n\nstatic void ax_handle_link_change(struct net_device *dev)\n{\n\tstruct ax_device  *ax = to_ax_dev(dev);\n\tstruct phy_device *phy_dev = dev->phydev;\n\tint status_change = 0;\n\n\tif (phy_dev->link && ((ax->speed != phy_dev->speed) ||\n\t\t\t     (ax->duplex != phy_dev->duplex))) {\n\n\t\tax->speed = phy_dev->speed;\n\t\tax->duplex = phy_dev->duplex;\n\t\tstatus_change = 1;\n\t}\n\n\tif (phy_dev->link != ax->link) {\n\t\tif (!phy_dev->link) {\n\t\t\tax->speed = 0;\n\t\t\tax->duplex = -1;\n\t\t}\n\t\tax->link = phy_dev->link;\n\n\t\tstatus_change = 1;\n\t}\n\n\tif (status_change)\n\t\tphy_print_status(phy_dev);\n}\n\nstatic int ax_mii_probe(struct net_device *dev)\n{\n\tstruct ax_device  *ax = to_ax_dev(dev);\n\tstruct phy_device *phy_dev = NULL;\n\tint ret;\n\n\t \n\tphy_dev = phy_find_first(ax->mii_bus);\n\tif (!phy_dev) {\n\t\tnetdev_err(dev, \"no PHY found\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tret = phy_connect_direct(dev, phy_dev, ax_handle_link_change,\n\t\t\t\t PHY_INTERFACE_MODE_MII);\n\tif (ret) {\n\t\tnetdev_err(dev, \"Could not attach to PHY\\n\");\n\t\treturn ret;\n\t}\n\n\tphy_set_max_speed(phy_dev, SPEED_100);\n\n\tnetdev_info(dev, \"PHY driver [%s] (mii_bus:phy_addr=%s, irq=%d)\\n\",\n\t\t    phy_dev->drv->name, phydev_name(phy_dev), phy_dev->irq);\n\n\treturn 0;\n}\n\nstatic void ax_phy_switch(struct net_device *dev, int on)\n{\n\tstruct ei_device *ei_local = netdev_priv(dev);\n\tstruct ax_device *ax = to_ax_dev(dev);\n\n\tu8 reg_gpoc =  ax->plat->gpoc_val;\n\n\tif (!!on)\n\t\treg_gpoc &= ~AX_GPOC_PPDSET;\n\telse\n\t\treg_gpoc |= AX_GPOC_PPDSET;\n\n\tei_outb(reg_gpoc, ei_local->mem + EI_SHIFT(0x17));\n}\n\nstatic void ax_bb_mdc(struct mdiobb_ctrl *ctrl, int level)\n{\n\tstruct ax_device *ax = container_of(ctrl, struct ax_device, bb_ctrl);\n\n\tif (level)\n\t\tax->reg_memr |= AX_MEMR_MDC;\n\telse\n\t\tax->reg_memr &= ~AX_MEMR_MDC;\n\n\tei_outb(ax->reg_memr, ax->addr_memr);\n}\n\nstatic void ax_bb_dir(struct mdiobb_ctrl *ctrl, int output)\n{\n\tstruct ax_device *ax = container_of(ctrl, struct ax_device, bb_ctrl);\n\n\tif (output)\n\t\tax->reg_memr &= ~AX_MEMR_MDIR;\n\telse\n\t\tax->reg_memr |= AX_MEMR_MDIR;\n\n\tei_outb(ax->reg_memr, ax->addr_memr);\n}\n\nstatic void ax_bb_set_data(struct mdiobb_ctrl *ctrl, int value)\n{\n\tstruct ax_device *ax = container_of(ctrl, struct ax_device, bb_ctrl);\n\n\tif (value)\n\t\tax->reg_memr |= AX_MEMR_MDO;\n\telse\n\t\tax->reg_memr &= ~AX_MEMR_MDO;\n\n\tei_outb(ax->reg_memr, ax->addr_memr);\n}\n\nstatic int ax_bb_get_data(struct mdiobb_ctrl *ctrl)\n{\n\tstruct ax_device *ax = container_of(ctrl, struct ax_device, bb_ctrl);\n\tint reg_memr = ei_inb(ax->addr_memr);\n\n\treturn reg_memr & AX_MEMR_MDI ? 1 : 0;\n}\n\nstatic const struct mdiobb_ops bb_ops = {\n\t.owner = THIS_MODULE,\n\t.set_mdc = ax_bb_mdc,\n\t.set_mdio_dir = ax_bb_dir,\n\t.set_mdio_data = ax_bb_set_data,\n\t.get_mdio_data = ax_bb_get_data,\n};\n\nstatic int ax_mii_init(struct net_device *dev)\n{\n\tstruct platform_device *pdev = to_platform_device(dev->dev.parent);\n\tstruct ei_device *ei_local = netdev_priv(dev);\n\tstruct ax_device *ax = to_ax_dev(dev);\n\tint err;\n\n\tax->bb_ctrl.ops = &bb_ops;\n\tax->addr_memr = ei_local->mem + AX_MEMR;\n\tax->mii_bus = alloc_mdio_bitbang(&ax->bb_ctrl);\n\tif (!ax->mii_bus) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tax->mii_bus->name = \"ax88796_mii_bus\";\n\tax->mii_bus->parent = dev->dev.parent;\n\tsnprintf(ax->mii_bus->id, MII_BUS_ID_SIZE, \"%s-%x\",\n\t\t pdev->name, pdev->id);\n\n\terr = mdiobus_register(ax->mii_bus);\n\tif (err)\n\t\tgoto out_free_mdio_bitbang;\n\n\treturn 0;\n\n out_free_mdio_bitbang:\n\tfree_mdio_bitbang(ax->mii_bus);\n out:\n\treturn err;\n}\n\nstatic int ax_open(struct net_device *dev)\n{\n\tstruct ax_device *ax = to_ax_dev(dev);\n\tint ret;\n\n\tnetdev_dbg(dev, \"open\\n\");\n\n\tret = ax_mii_init(dev);\n\tif (ret)\n\t\tgoto failed_mii;\n\n\tif (ax->plat->check_irq)\n\t\tret = request_irq(dev->irq, ax_ei_interrupt_filtered,\n\t\t\t\t  ax->irqflags, dev->name, dev);\n\telse\n\t\tret = request_irq(dev->irq, ax_ei_interrupt, ax->irqflags,\n\t\t\t\t  dev->name, dev);\n\tif (ret)\n\t\tgoto failed_request_irq;\n\n\t \n\tax_phy_switch(dev, 1);\n\n\tret = ax_mii_probe(dev);\n\tif (ret)\n\t\tgoto failed_mii_probe;\n\tphy_start(dev->phydev);\n\n\tret = ax_ei_open(dev);\n\tif (ret)\n\t\tgoto failed_ax_ei_open;\n\n\tax->running = 1;\n\n\treturn 0;\n\n failed_ax_ei_open:\n\tphy_disconnect(dev->phydev);\n failed_mii_probe:\n\tax_phy_switch(dev, 0);\n\tfree_irq(dev->irq, dev);\n failed_request_irq:\n\t \n\tmdiobus_unregister(ax->mii_bus);\n\tfree_mdio_bitbang(ax->mii_bus);\n failed_mii:\n\treturn ret;\n}\n\nstatic int ax_close(struct net_device *dev)\n{\n\tstruct ax_device *ax = to_ax_dev(dev);\n\n\tnetdev_dbg(dev, \"close\\n\");\n\n\tax->running = 0;\n\twmb();\n\n\tax_ei_close(dev);\n\n\t \n\tax_phy_switch(dev, 0);\n\tphy_disconnect(dev->phydev);\n\n\tfree_irq(dev->irq, dev);\n\n\tmdiobus_unregister(ax->mii_bus);\n\tfree_mdio_bitbang(ax->mii_bus);\n\treturn 0;\n}\n\nstatic int ax_ioctl(struct net_device *dev, struct ifreq *req, int cmd)\n{\n\tstruct phy_device *phy_dev = dev->phydev;\n\n\tif (!netif_running(dev))\n\t\treturn -EINVAL;\n\n\tif (!phy_dev)\n\t\treturn -ENODEV;\n\n\treturn phy_mii_ioctl(phy_dev, req, cmd);\n}\n\n \n\nstatic void ax_get_drvinfo(struct net_device *dev,\n\t\t\t   struct ethtool_drvinfo *info)\n{\n\tstruct platform_device *pdev = to_platform_device(dev->dev.parent);\n\n\tstrscpy(info->driver, DRV_NAME, sizeof(info->driver));\n\tstrscpy(info->version, DRV_VERSION, sizeof(info->version));\n\tstrscpy(info->bus_info, pdev->name, sizeof(info->bus_info));\n}\n\nstatic u32 ax_get_msglevel(struct net_device *dev)\n{\n\tstruct ei_device *ei_local = netdev_priv(dev);\n\n\treturn ei_local->msg_enable;\n}\n\nstatic void ax_set_msglevel(struct net_device *dev, u32 v)\n{\n\tstruct ei_device *ei_local = netdev_priv(dev);\n\n\tei_local->msg_enable = v;\n}\n\nstatic const struct ethtool_ops ax_ethtool_ops = {\n\t.get_drvinfo\t\t= ax_get_drvinfo,\n\t.get_link\t\t= ethtool_op_get_link,\n\t.get_ts_info\t\t= ethtool_op_get_ts_info,\n\t.get_msglevel\t\t= ax_get_msglevel,\n\t.set_msglevel\t\t= ax_set_msglevel,\n\t.get_link_ksettings\t= phy_ethtool_get_link_ksettings,\n\t.set_link_ksettings\t= phy_ethtool_set_link_ksettings,\n};\n\n#ifdef CONFIG_AX88796_93CX6\nstatic void ax_eeprom_register_read(struct eeprom_93cx6 *eeprom)\n{\n\tstruct ei_device *ei_local = eeprom->data;\n\tu8 reg = ei_inb(ei_local->mem + AX_MEMR);\n\n\teeprom->reg_data_in = reg & AX_MEMR_EEI;\n\teeprom->reg_data_out = reg & AX_MEMR_EEO;  \n\teeprom->reg_data_clock = reg & AX_MEMR_EECLK;\n\teeprom->reg_chip_select = reg & AX_MEMR_EECS;\n}\n\nstatic void ax_eeprom_register_write(struct eeprom_93cx6 *eeprom)\n{\n\tstruct ei_device *ei_local = eeprom->data;\n\tu8 reg = ei_inb(ei_local->mem + AX_MEMR);\n\n\treg &= ~(AX_MEMR_EEI | AX_MEMR_EECLK | AX_MEMR_EECS);\n\n\tif (eeprom->reg_data_in)\n\t\treg |= AX_MEMR_EEI;\n\tif (eeprom->reg_data_clock)\n\t\treg |= AX_MEMR_EECLK;\n\tif (eeprom->reg_chip_select)\n\t\treg |= AX_MEMR_EECS;\n\n\tei_outb(reg, ei_local->mem + AX_MEMR);\n\tudelay(10);\n}\n#endif\n\nstatic const struct net_device_ops ax_netdev_ops = {\n\t.ndo_open\t\t= ax_open,\n\t.ndo_stop\t\t= ax_close,\n\t.ndo_eth_ioctl\t\t= ax_ioctl,\n\n\t.ndo_start_xmit\t\t= ax_ei_start_xmit,\n\t.ndo_tx_timeout\t\t= ax_ei_tx_timeout,\n\t.ndo_get_stats\t\t= ax_ei_get_stats,\n\t.ndo_set_rx_mode\t= ax_ei_set_multicast_list,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_set_mac_address\t= eth_mac_addr,\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\t.ndo_poll_controller\t= ax_ei_poll,\n#endif\n};\n\n \n\nstatic void ax_initial_setup(struct net_device *dev, struct ei_device *ei_local)\n{\n\tvoid __iomem *ioaddr = ei_local->mem;\n\tstruct ax_device *ax = to_ax_dev(dev);\n\n\t \n\tei_outb(E8390_NODMA + E8390_PAGE0 + E8390_STOP, ioaddr + E8390_CMD);\n\n\t \n\tei_outb(ax->plat->dcr_val & ~1, ioaddr + EN0_DCFG);\n\tei_outb(ax->plat->gpoc_val, ioaddr + EI_SHIFT(0x17));\n}\n\n \nstatic int ax_init_dev(struct net_device *dev)\n{\n\tstruct ei_device *ei_local = netdev_priv(dev);\n\tstruct ax_device *ax = to_ax_dev(dev);\n\tvoid __iomem *ioaddr = ei_local->mem;\n\tunsigned int start_page;\n\tunsigned int stop_page;\n\tint ret;\n\tint i;\n\n\tret = ax_initial_check(dev);\n\tif (ret)\n\t\tgoto err_out;\n\n\t \n\n\tax_initial_setup(dev, ei_local);\n\n\t \n\n\tif (ax->plat->flags & AXFLG_HAS_EEPROM) {\n\t\tunsigned char SA_prom[32];\n\n\t\tei_outb(6, ioaddr + EN0_RCNTLO);\n\t\tei_outb(0, ioaddr + EN0_RCNTHI);\n\t\tei_outb(0, ioaddr + EN0_RSARLO);\n\t\tei_outb(0, ioaddr + EN0_RSARHI);\n\t\tei_outb(E8390_RREAD + E8390_START, ioaddr + NE_CMD);\n\t\tfor (i = 0; i < sizeof(SA_prom); i += 2) {\n\t\t\tSA_prom[i] = ei_inb(ioaddr + NE_DATAPORT);\n\t\t\tSA_prom[i + 1] = ei_inb(ioaddr + NE_DATAPORT);\n\t\t}\n\t\tei_outb(ENISR_RDC, ioaddr + EN0_ISR);\t \n\n\t\tif (ax->plat->wordlength == 2)\n\t\t\tfor (i = 0; i < 16; i++)\n\t\t\t\tSA_prom[i] = SA_prom[i+i];\n\n\t\teth_hw_addr_set(dev, SA_prom);\n\t}\n\n#ifdef CONFIG_AX88796_93CX6\n\tif (ax->plat->flags & AXFLG_HAS_93CX6) {\n\t\tunsigned char mac_addr[ETH_ALEN];\n\t\tstruct eeprom_93cx6 eeprom;\n\n\t\teeprom.data = ei_local;\n\t\teeprom.register_read = ax_eeprom_register_read;\n\t\teeprom.register_write = ax_eeprom_register_write;\n\t\teeprom.width = PCI_EEPROM_WIDTH_93C56;\n\n\t\teeprom_93cx6_multiread(&eeprom, 0,\n\t\t\t\t       (__le16 __force *)mac_addr,\n\t\t\t\t       sizeof(mac_addr) >> 1);\n\n\t\teth_hw_addr_set(dev, mac_addr);\n\t}\n#endif\n\tif (ax->plat->wordlength == 2) {\n\t\t \n\t\tei_outb(ax->plat->dcr_val, ei_local->mem + EN0_DCFG);\n\t\tstart_page = NESM_START_PG;\n\t\tstop_page = NESM_STOP_PG;\n\t} else {\n\t\tstart_page = NE1SM_START_PG;\n\t\tstop_page = NE1SM_STOP_PG;\n\t}\n\n\t \n\tif (ax->plat->flags & AXFLG_MAC_FROMDEV) {\n\t\tu8 addr[ETH_ALEN];\n\n\t\tei_outb(E8390_NODMA + E8390_PAGE1 + E8390_STOP,\n\t\t\tei_local->mem + E8390_CMD);  \n\t\tfor (i = 0; i < ETH_ALEN; i++)\n\t\t\taddr[i] = ei_inb(ioaddr + EN1_PHYS_SHIFT(i));\n\t\teth_hw_addr_set(dev, addr);\n\t}\n\n\tif ((ax->plat->flags & AXFLG_MAC_FROMPLATFORM) &&\n\t    ax->plat->mac_addr)\n\t\teth_hw_addr_set(dev, ax->plat->mac_addr);\n\n\tif (!is_valid_ether_addr(dev->dev_addr)) {\n\t\teth_hw_addr_random(dev);\n\t\tdev_info(&dev->dev, \"Using random MAC address: %pM\\n\",\n\t\t\t dev->dev_addr);\n\t}\n\n\tax_reset_8390(dev);\n\n\tei_local->name = \"AX88796\";\n\tei_local->tx_start_page = start_page;\n\tei_local->stop_page = stop_page;\n\tei_local->word16 = (ax->plat->wordlength == 2);\n\tei_local->rx_start_page = start_page + TX_PAGES;\n\n#ifdef PACKETBUF_MEMSIZE\n\t \n\tei_local->stop_page = ei_local->tx_start_page + PACKETBUF_MEMSIZE;\n#endif\n\n\tei_local->reset_8390 = &ax_reset_8390;\n\tif (ax->plat->block_input)\n\t\tei_local->block_input = ax->plat->block_input;\n\telse\n\t\tei_local->block_input = &ax_block_input;\n\tif (ax->plat->block_output)\n\t\tei_local->block_output = ax->plat->block_output;\n\telse\n\t\tei_local->block_output = &ax_block_output;\n\tei_local->get_8390_hdr = &ax_get_8390_hdr;\n\tei_local->priv = 0;\n\n\tdev->netdev_ops = &ax_netdev_ops;\n\tdev->ethtool_ops = &ax_ethtool_ops;\n\n\tax_NS8390_init(dev, 0);\n\n\tret = register_netdev(dev);\n\tif (ret)\n\t\tgoto err_out;\n\n\tnetdev_info(dev, \"%dbit, irq %d, %lx, MAC: %pM\\n\",\n\t\t    ei_local->word16 ? 16 : 8, dev->irq, dev->base_addr,\n\t\t    dev->dev_addr);\n\n\treturn 0;\n\n err_out:\n\treturn ret;\n}\n\nstatic int ax_remove(struct platform_device *pdev)\n{\n\tstruct net_device *dev = platform_get_drvdata(pdev);\n\tstruct ei_device *ei_local = netdev_priv(dev);\n\tstruct ax_device *ax = to_ax_dev(dev);\n\tstruct resource *mem;\n\n\tunregister_netdev(dev);\n\n\tiounmap(ei_local->mem);\n\tmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\trelease_mem_region(mem->start, resource_size(mem));\n\n\tif (ax->map2) {\n\t\tiounmap(ax->map2);\n\t\tmem = platform_get_resource(pdev, IORESOURCE_MEM, 1);\n\t\trelease_mem_region(mem->start, resource_size(mem));\n\t}\n\n\tplatform_set_drvdata(pdev, NULL);\n\tfree_netdev(dev);\n\n\treturn 0;\n}\n\n \nstatic int ax_probe(struct platform_device *pdev)\n{\n\tstruct net_device *dev;\n\tstruct ei_device *ei_local;\n\tstruct ax_device *ax;\n\tstruct resource *irq, *mem, *mem2;\n\tunsigned long mem_size, mem2_size = 0;\n\tint ret = 0;\n\n\tdev = ax__alloc_ei_netdev(sizeof(struct ax_device));\n\tif (dev == NULL)\n\t\treturn -ENOMEM;\n\n\t \n\tSET_NETDEV_DEV(dev, &pdev->dev);\n\tei_local = netdev_priv(dev);\n\tax = to_ax_dev(dev);\n\n\tax->plat = dev_get_platdata(&pdev->dev);\n\tplatform_set_drvdata(pdev, dev);\n\n\tei_local->rxcr_base = ax->plat->rcr_val;\n\n\t \n\tirq = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\n\tif (!irq) {\n\t\tdev_err(&pdev->dev, \"no IRQ specified\\n\");\n\t\tret = -ENXIO;\n\t\tgoto exit_mem;\n\t}\n\n\tdev->irq = irq->start;\n\tax->irqflags = irq->flags & IRQF_TRIGGER_MASK;\n\n\tif (irq->flags &  IORESOURCE_IRQ_SHAREABLE)\n\t\tax->irqflags |= IRQF_SHARED;\n\n\tmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!mem) {\n\t\tdev_err(&pdev->dev, \"no MEM specified\\n\");\n\t\tret = -ENXIO;\n\t\tgoto exit_mem;\n\t}\n\n\tmem_size = resource_size(mem);\n\n\t \n\tif (ax->plat->reg_offsets)\n\t\tei_local->reg_offset = ax->plat->reg_offsets;\n\telse {\n\t\tei_local->reg_offset = ax->reg_offsets;\n\t\tfor (ret = 0; ret < 0x18; ret++)\n\t\t\tax->reg_offsets[ret] = (mem_size / 0x18) * ret;\n\t}\n\n\tif (!request_mem_region(mem->start, mem_size, pdev->name)) {\n\t\tdev_err(&pdev->dev, \"cannot reserve registers\\n\");\n\t\tret = -ENXIO;\n\t\tgoto exit_mem;\n\t}\n\n\tei_local->mem = ioremap(mem->start, mem_size);\n\tdev->base_addr = (unsigned long)ei_local->mem;\n\n\tif (ei_local->mem == NULL) {\n\t\tdev_err(&pdev->dev, \"Cannot ioremap area %pR\\n\", mem);\n\n\t\tret = -ENXIO;\n\t\tgoto exit_req;\n\t}\n\n\t \n\tmem2 = platform_get_resource(pdev, IORESOURCE_MEM, 1);\n\tif (!mem2) {\n\t\tif (!ax->plat->reg_offsets) {\n\t\t\tfor (ret = 0; ret < 0x20; ret++)\n\t\t\t\tax->reg_offsets[ret] = (mem_size / 0x20) * ret;\n\t\t}\n\t} else {\n\t\tmem2_size = resource_size(mem2);\n\n\t\tif (!request_mem_region(mem2->start, mem2_size, pdev->name)) {\n\t\t\tdev_err(&pdev->dev, \"cannot reserve registers\\n\");\n\t\t\tret = -ENXIO;\n\t\t\tgoto exit_mem1;\n\t\t}\n\n\t\tax->map2 = ioremap(mem2->start, mem2_size);\n\t\tif (!ax->map2) {\n\t\t\tdev_err(&pdev->dev, \"cannot map reset register\\n\");\n\t\t\tret = -ENXIO;\n\t\t\tgoto exit_mem2;\n\t\t}\n\n\t\tei_local->reg_offset[0x1f] = ax->map2 - ei_local->mem;\n\t}\n\n\t \n\tret = ax_init_dev(dev);\n\tif (!ret)\n\t\treturn 0;\n\n\tif (!ax->map2)\n\t\tgoto exit_mem1;\n\n\tiounmap(ax->map2);\n\n exit_mem2:\n\tif (mem2)\n\t\trelease_mem_region(mem2->start, mem2_size);\n\n exit_mem1:\n\tiounmap(ei_local->mem);\n\n exit_req:\n\trelease_mem_region(mem->start, mem_size);\n\n exit_mem:\n\tplatform_set_drvdata(pdev, NULL);\n\tfree_netdev(dev);\n\n\treturn ret;\n}\n\n \n\n#ifdef CONFIG_PM\nstatic int ax_suspend(struct platform_device *dev, pm_message_t state)\n{\n\tstruct net_device *ndev = platform_get_drvdata(dev);\n\tstruct ax_device *ax = to_ax_dev(ndev);\n\n\tax->resume_open = ax->running;\n\n\tnetif_device_detach(ndev);\n\tax_close(ndev);\n\n\treturn 0;\n}\n\nstatic int ax_resume(struct platform_device *pdev)\n{\n\tstruct net_device *ndev = platform_get_drvdata(pdev);\n\tstruct ax_device *ax = to_ax_dev(ndev);\n\n\tax_initial_setup(ndev, netdev_priv(ndev));\n\tax_NS8390_init(ndev, ax->resume_open);\n\tnetif_device_attach(ndev);\n\n\tif (ax->resume_open)\n\t\tax_open(ndev);\n\n\treturn 0;\n}\n\n#else\n#define ax_suspend NULL\n#define ax_resume NULL\n#endif\n\nstatic struct platform_driver axdrv = {\n\t.driver\t= {\n\t\t.name\t\t= \"ax88796\",\n\t},\n\t.probe\t\t= ax_probe,\n\t.remove\t\t= ax_remove,\n\t.suspend\t= ax_suspend,\n\t.resume\t\t= ax_resume,\n};\n\nmodule_platform_driver(axdrv);\n\nMODULE_DESCRIPTION(\"AX88796 10/100 Ethernet platform driver\");\nMODULE_AUTHOR(\"Ben Dooks, <ben@simtec.co.uk>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:ax88796\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}