{
  "module_name": "ne.c",
  "hash_id": "d5038c0b7d4528406c47db67442e99275b72a280616031fe9cbdd41877c6e82b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/8390/ne.c",
  "human_readable_source": "\n \n \n\n \n\nstatic const char version1[] =\n\"ne.c:v1.10 9/23/94 Donald Becker (becker@scyld.com)\\n\";\nstatic const char version2[] =\n\"Last modified Nov 1, 2000 by Paul Gortmaker\\n\";\n\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/isapnp.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/jiffies.h>\n#include <linux/platform_device.h>\n#include <net/Space.h>\n\n#include <asm/io.h>\n\n#include \"8390.h\"\n\n#define DRV_NAME \"ne\"\n\n \n\n \n#define SUPPORT_NE_BAD_CLONES\n \n#define BAD 0xbad\n\n#define MAX_NE_CARDS\t4\t \nstatic struct platform_device *pdev_ne[MAX_NE_CARDS];\nstatic int io[MAX_NE_CARDS];\nstatic int irq[MAX_NE_CARDS];\nstatic int bad[MAX_NE_CARDS];\nstatic u32 ne_msg_enable;\n\n#ifdef MODULE\nmodule_param_hw_array(io, int, ioport, NULL, 0);\nmodule_param_hw_array(irq, int, irq, NULL, 0);\nmodule_param_array(bad, int, NULL, 0);\nmodule_param_named(msg_enable, ne_msg_enable, uint, 0444);\nMODULE_PARM_DESC(io, \"I/O base address(es),required\");\nMODULE_PARM_DESC(irq, \"IRQ number(s)\");\nMODULE_PARM_DESC(bad, \"Accept card(s) with bad signatures\");\nMODULE_PARM_DESC(msg_enable, \"Debug message level (see linux/netdevice.h for bitmap)\");\nMODULE_DESCRIPTION(\"NE1000/NE2000 ISA/PnP Ethernet driver\");\nMODULE_LICENSE(\"GPL\");\n#endif  \n\n \n \n\n \n \n\n \n \n\n \n#if !defined(MODULE) && defined(CONFIG_ISA)\n \n#define NEEDS_PORTLIST\n#endif\n\n \n#ifdef NEEDS_PORTLIST\nstatic unsigned int netcard_portlist[] __initdata = {\n\t0x300, 0x280, 0x320, 0x340, 0x360, 0x380, 0\n};\n#endif\n\nstatic struct isapnp_device_id isapnp_clone_list[] __initdata = {\n\t{\tISAPNP_CARD_ID('A','X','E',0x2011),\n\t\tISAPNP_VENDOR('A','X','E'), ISAPNP_FUNCTION(0x2011),\n\t\t(long) \"NetGear EA201\" },\n\t{\tISAPNP_ANY_ID, ISAPNP_ANY_ID,\n\t\tISAPNP_VENDOR('E','D','I'), ISAPNP_FUNCTION(0x0216),\n\t\t(long) \"NN NE2000\" },\n\t{\tISAPNP_ANY_ID, ISAPNP_ANY_ID,\n\t\tISAPNP_VENDOR('P','N','P'), ISAPNP_FUNCTION(0x80d6),\n\t\t(long) \"Generic PNP\" },\n\t{ }\t \n};\n\nMODULE_DEVICE_TABLE(isapnp, isapnp_clone_list);\n\n#ifdef SUPPORT_NE_BAD_CLONES\n \nstatic struct { const char *name8, *name16; unsigned char SAprefix[4];}\nbad_clone_list[] __initdata = {\n    {\"DE100\", \"DE200\", {0x00, 0xDE, 0x01,}},\n    {\"DE120\", \"DE220\", {0x00, 0x80, 0xc8,}},\n    {\"DFI1000\", \"DFI2000\", {'D', 'F', 'I',}},  \n    {\"EtherNext UTP8\", \"EtherNext UTP16\", {0x00, 0x00, 0x79}},\n    {\"NE1000\",\"NE2000-invalid\", {0x00, 0x00, 0xd8}},  \n    {\"NN1000\", \"NN2000\",  {0x08, 0x03, 0x08}},  \n    {\"4-DIM8\",\"4-DIM16\", {0x00,0x00,0x4d,}},   \n    {\"Con-Intl_8\", \"Con-Intl_16\", {0x00, 0x00, 0x24}},  \n    {\"ET-100\",\"ET-200\", {0x00, 0x45, 0x54}},  \n    {\"COMPEX\",\"COMPEX16\",{0x00,0x80,0x48}},  \n    {\"E-LAN100\", \"E-LAN200\", {0x00, 0x00, 0x5d}},  \n    {\"PCM-4823\", \"PCM-4823\", {0x00, 0xc0, 0x6c}},  \n    {\"REALTEK\", \"RTL8019\", {0x00, 0x00, 0xe8}},  \n#ifdef CONFIG_MACH_TX49XX\n    {\"RBHMA4X00-RTL8019\", \"RBHMA4X00-RTL8019\", {0x00, 0x60, 0x0a}},   \n#endif\n    {\"LCS-8834\", \"LCS-8836\", {0x04, 0x04, 0x37}},  \n    {NULL,}\n};\n#endif\n\n \n\n#define NE_BASE\t (dev->base_addr)\n#define NE_CMD\t \t0x00\n#define NE_DATAPORT\t0x10\t \n#define NE_RESET\t0x1f\t \n#define NE_IO_EXTENT\t0x20\n\n#define NE1SM_START_PG\t0x20\t \n#define NE1SM_STOP_PG \t0x40\t \n#define NESM_START_PG\t0x40\t \n#define NESM_STOP_PG\t0x80\t \n\n#if defined(CONFIG_MACH_TX49XX)\n#  define DCR_VAL 0x48\t\t \n#elif defined(CONFIG_ATARI)\t \n#  define DCR_VAL (MACH_IS_ATARI ? 0x48 : 0x49)\n#else\n#  define DCR_VAL 0x49\n#endif\n\nstatic int ne_probe1(struct net_device *dev, unsigned long ioaddr);\nstatic int ne_probe_isapnp(struct net_device *dev);\n\nstatic void ne_reset_8390(struct net_device *dev);\nstatic void ne_get_8390_hdr(struct net_device *dev, struct e8390_pkt_hdr *hdr,\n\t\t\t  int ring_page);\nstatic void ne_block_input(struct net_device *dev, int count,\n\t\t\t  struct sk_buff *skb, int ring_offset);\nstatic void ne_block_output(struct net_device *dev, const int count,\n\t\tconst unsigned char *buf, const int start_page);\n\n\n \n\nstatic int __init do_ne_probe(struct net_device *dev)\n{\n\tunsigned long base_addr = dev->base_addr;\n#ifdef NEEDS_PORTLIST\n\tint orig_irq = dev->irq;\n#endif\n\n\t \n\tif (base_addr > 0x1ff) {\t \n\t\tint ret = ne_probe1(dev, base_addr);\n\t\tif (ret)\n\t\t\tnetdev_warn(dev, \"ne.c: No NE*000 card found at \"\n\t\t\t\t    \"i/o = %#lx\\n\", base_addr);\n\t\treturn ret;\n\t}\n\telse if (base_addr != 0)\t \n\t\treturn -ENXIO;\n\n\t \n\tif (isapnp_present() && (ne_probe_isapnp(dev) == 0))\n\t\treturn 0;\n\n#ifdef NEEDS_PORTLIST\n\t \n\tfor (base_addr = 0; netcard_portlist[base_addr] != 0; base_addr++) {\n\t\tint ioaddr = netcard_portlist[base_addr];\n\t\tdev->irq = orig_irq;\n\t\tif (ne_probe1(dev, ioaddr) == 0)\n\t\t\treturn 0;\n\t}\n#endif\n\n\treturn -ENODEV;\n}\n\nstatic int __init ne_probe_isapnp(struct net_device *dev)\n{\n\tint i;\n\n\tfor (i = 0; isapnp_clone_list[i].vendor != 0; i++) {\n\t\tstruct pnp_dev *idev = NULL;\n\n\t\twhile ((idev = pnp_find_dev(NULL,\n\t\t\t\t\t    isapnp_clone_list[i].vendor,\n\t\t\t\t\t    isapnp_clone_list[i].function,\n\t\t\t\t\t    idev))) {\n\t\t\t \n\t\t\tif (pnp_device_attach(idev) < 0)\n\t\t\t\tcontinue;\n\t\t\tif (pnp_activate_dev(idev) < 0) {\n\t\t\t      \tpnp_device_detach(idev);\n\t\t\t      \tcontinue;\n\t\t\t}\n\t\t\t \n\t\t\tif (!pnp_port_valid(idev, 0) || !pnp_irq_valid(idev, 0)) {\n\t\t\t\tpnp_device_detach(idev);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t \n\t\t\tdev->base_addr = pnp_port_start(idev, 0);\n\t\t\tdev->irq = pnp_irq(idev, 0);\n\t\t\tnetdev_info(dev,\n\t\t\t\t    \"ne.c: ISAPnP reports %s at i/o %#lx, irq %d.\\n\",\n\t\t\t\t    (char *) isapnp_clone_list[i].driver_data,\n\t\t\t\t    dev->base_addr, dev->irq);\n\t\t\tif (ne_probe1(dev, dev->base_addr) != 0) {\t \n\t\t\t\tnetdev_err(dev,\n\t\t\t\t\t   \"ne.c: Probe of ISAPnP card at %#lx failed.\\n\",\n\t\t\t\t\t   dev->base_addr);\n\t\t\t\tpnp_device_detach(idev);\n\t\t\t\treturn -ENXIO;\n\t\t\t}\n\t\t\tei_status.priv = (unsigned long)idev;\n\t\t\tbreak;\n\t\t}\n\t\tif (!idev)\n\t\t\tcontinue;\n\t\treturn 0;\n\t}\n\n\treturn -ENODEV;\n}\n\nstatic int __init ne_probe1(struct net_device *dev, unsigned long ioaddr)\n{\n\tint i;\n\tunsigned char SA_prom[32];\n\tint wordlength = 2;\n\tconst char *name = NULL;\n\tint start_page, stop_page;\n\tint neX000, ctron, copam, bad_card;\n\tint reg0, ret;\n\tstatic unsigned version_printed;\n\tstruct ei_device *ei_local = netdev_priv(dev);\n\n\tif (!request_region(ioaddr, NE_IO_EXTENT, DRV_NAME))\n\t\treturn -EBUSY;\n\n\treg0 = inb_p(ioaddr);\n\tif (reg0 == 0xFF) {\n\t\tret = -ENODEV;\n\t\tgoto err_out;\n\t}\n\n\t \n\t{\n\t\tint regd;\n\t\toutb_p(E8390_NODMA+E8390_PAGE1+E8390_STOP, ioaddr + E8390_CMD);\n\t\tregd = inb_p(ioaddr + 0x0d);\n\t\toutb_p(0xff, ioaddr + 0x0d);\n\t\toutb_p(E8390_NODMA+E8390_PAGE0, ioaddr + E8390_CMD);\n\t\tinb_p(ioaddr + EN0_COUNTER0);  \n\t\tif (inb_p(ioaddr + EN0_COUNTER0) != 0) {\n\t\t\toutb_p(reg0, ioaddr);\n\t\t\toutb_p(regd, ioaddr + 0x0d);\t \n\t\t\tret = -ENODEV;\n\t\t\tgoto err_out;\n\t\t}\n\t}\n\n\tif ((ne_msg_enable & NETIF_MSG_DRV) && (version_printed++ == 0))\n\t\tnetdev_info(dev, \"%s%s\", version1, version2);\n\n\tnetdev_info(dev, \"NE*000 ethercard probe at %#3lx:\", ioaddr);\n\n\t \n\n\tbad_card = ((dev->base_addr != 0) && (dev->mem_end == BAD));\n\n\t \n\n\t{\n\t\tunsigned long reset_start_time = jiffies;\n\n\t\t \n\t\toutb(inb(ioaddr + NE_RESET), ioaddr + NE_RESET);\n\n\t\twhile ((inb_p(ioaddr + EN0_ISR) & ENISR_RESET) == 0)\n\t\tif (time_after(jiffies, reset_start_time + 2*HZ/100)) {\n\t\t\tif (bad_card) {\n\t\t\t\tpr_cont(\" (warning: no reset ack)\");\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tpr_cont(\" not found (no reset ack).\\n\");\n\t\t\t\tret = -ENODEV;\n\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t}\n\n\t\toutb_p(0xff, ioaddr + EN0_ISR);\t\t \n\t}\n\n\t \n\t{\n\t\tstruct {unsigned char value, offset; } program_seq[] =\n\t\t{\n\t\t\t{E8390_NODMA+E8390_PAGE0+E8390_STOP, E8390_CMD},  \n\t\t\t{0x48,\tEN0_DCFG},\t \n\t\t\t{0x00,\tEN0_RCNTLO},\t \n\t\t\t{0x00,\tEN0_RCNTHI},\n\t\t\t{0x00,\tEN0_IMR},\t \n\t\t\t{0xFF,\tEN0_ISR},\n\t\t\t{E8390_RXOFF, EN0_RXCR},\t \n\t\t\t{E8390_TXOFF, EN0_TXCR},\t \n\t\t\t{32,\tEN0_RCNTLO},\n\t\t\t{0x00,\tEN0_RCNTHI},\n\t\t\t{0x00,\tEN0_RSARLO},\t \n\t\t\t{0x00,\tEN0_RSARHI},\n\t\t\t{E8390_RREAD+E8390_START, E8390_CMD},\n\t\t};\n\n\t\tfor (i = 0; i < ARRAY_SIZE(program_seq); i++)\n\t\t\toutb_p(program_seq[i].value, ioaddr + program_seq[i].offset);\n\n\t}\n\tfor(i = 0; i < 32  ; i+=2) {\n\t\tSA_prom[i] = inb(ioaddr + NE_DATAPORT);\n\t\tSA_prom[i+1] = inb(ioaddr + NE_DATAPORT);\n\t\tif (SA_prom[i] != SA_prom[i+1])\n\t\t\twordlength = 1;\n\t}\n\n\tif (wordlength == 2)\n\t{\n\t\tfor (i = 0; i < 16; i++)\n\t\t\tSA_prom[i] = SA_prom[i+i];\n\t\t \n\t\toutb_p(DCR_VAL, ioaddr + EN0_DCFG);\n\t\tstart_page = NESM_START_PG;\n\n\t\t \n\t\tif ((DCR_VAL & 0x01) == 0 &&\t\t \n\t\t    inb(ioaddr + EN0_RCNTLO) == 0x50 &&\n\t\t    inb(ioaddr + EN0_RCNTHI) == 0x70)\n\t\t\tstop_page = 0x60;\n\t\telse\n\t\t\tstop_page = NESM_STOP_PG;\n\t} else {\n\t\tstart_page = NE1SM_START_PG;\n\t\tstop_page  = NE1SM_STOP_PG;\n\t}\n\n\tneX000 = (SA_prom[14] == 0x57  &&  SA_prom[15] == 0x57);\n\tctron =  (SA_prom[0] == 0x00 && SA_prom[1] == 0x00 && SA_prom[2] == 0x1d);\n\tcopam =  (SA_prom[14] == 0x49 && SA_prom[15] == 0x00);\n\n\t \n\tif (neX000 || bad_card || copam) {\n\t\tname = (wordlength == 2) ? \"NE2000\" : \"NE1000\";\n\t}\n\telse if (ctron)\n\t{\n\t\tname = (wordlength == 2) ? \"Ctron-8\" : \"Ctron-16\";\n\t\tstart_page = 0x01;\n\t\tstop_page = (wordlength == 2) ? 0x40 : 0x20;\n\t}\n\telse\n\t{\n#ifdef SUPPORT_NE_BAD_CLONES\n\t\t \n\t\tfor (i = 0; bad_clone_list[i].name8; i++)\n\t\t{\n\t\t\tif (SA_prom[0] == bad_clone_list[i].SAprefix[0] &&\n\t\t\t\tSA_prom[1] == bad_clone_list[i].SAprefix[1] &&\n\t\t\t\tSA_prom[2] == bad_clone_list[i].SAprefix[2])\n\t\t\t{\n\t\t\t\tif (wordlength == 2)\n\t\t\t\t{\n\t\t\t\t\tname = bad_clone_list[i].name16;\n\t\t\t\t} else {\n\t\t\t\t\tname = bad_clone_list[i].name8;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (bad_clone_list[i].name8 == NULL)\n\t\t{\n\t\t\tpr_cont(\" not found (invalid signature %2.2x %2.2x).\\n\",\n\t\t\t\tSA_prom[14], SA_prom[15]);\n\t\t\tret = -ENXIO;\n\t\t\tgoto err_out;\n\t\t}\n#else\n\t\tpr_cont(\" not found.\\n\");\n\t\tret = -ENXIO;\n\t\tgoto err_out;\n#endif\n\t}\n\n\tif (dev->irq < 2)\n\t{\n\t\tunsigned long cookie = probe_irq_on();\n\t\toutb_p(0x50, ioaddr + EN0_IMR);\t \n\t\toutb_p(0x00, ioaddr + EN0_RCNTLO);\n\t\toutb_p(0x00, ioaddr + EN0_RCNTHI);\n\t\toutb_p(E8390_RREAD+E8390_START, ioaddr);  \n\t\tmdelay(10);\t\t \n\t\toutb_p(0x00, ioaddr + EN0_IMR); \t\t \n\t\tdev->irq = probe_irq_off(cookie);\n\t\tif (ne_msg_enable & NETIF_MSG_PROBE)\n\t\t\tpr_cont(\" autoirq is %d\", dev->irq);\n\t} else if (dev->irq == 2)\n\t\t \n\t\tdev->irq = 9;\n\n\tif (! dev->irq) {\n\t\tpr_cont(\" failed to detect IRQ line.\\n\");\n\t\tret = -EAGAIN;\n\t\tgoto err_out;\n\t}\n\n\t \n\tret = request_irq(dev->irq, eip_interrupt, 0, name, dev);\n\tif (ret) {\n\t\tpr_cont(\" unable to get IRQ %d (errno=%d).\\n\", dev->irq, ret);\n\t\tgoto err_out;\n\t}\n\n\tdev->base_addr = ioaddr;\n\n\teth_hw_addr_set(dev, SA_prom);\n\n\tpr_cont(\"%pM\\n\", dev->dev_addr);\n\n\tei_status.name = name;\n\tei_status.tx_start_page = start_page;\n\tei_status.stop_page = stop_page;\n\n\t \n\tei_status.word16 = (wordlength == 2 && (DCR_VAL & 0x01));\n\n\tei_status.rx_start_page = start_page + TX_PAGES;\n#ifdef PACKETBUF_MEMSIZE\n\t  \n\tei_status.stop_page = ei_status.tx_start_page + PACKETBUF_MEMSIZE;\n#endif\n\n\tei_status.reset_8390 = &ne_reset_8390;\n\tei_status.block_input = &ne_block_input;\n\tei_status.block_output = &ne_block_output;\n\tei_status.get_8390_hdr = &ne_get_8390_hdr;\n\tei_status.priv = 0;\n\n\tdev->netdev_ops = &eip_netdev_ops;\n\tNS8390p_init(dev, 0);\n\n\tei_local->msg_enable = ne_msg_enable;\n\tret = register_netdev(dev);\n\tif (ret)\n\t\tgoto out_irq;\n\tnetdev_info(dev, \"%s found at %#lx, using IRQ %d.\\n\",\n\t\t    name, ioaddr, dev->irq);\n\treturn 0;\n\nout_irq:\n\tfree_irq(dev->irq, dev);\nerr_out:\n\trelease_region(ioaddr, NE_IO_EXTENT);\n\treturn ret;\n}\n\n \n\nstatic void ne_reset_8390(struct net_device *dev)\n{\n\tunsigned long reset_start_time = jiffies;\n\tstruct ei_device *ei_local = netdev_priv(dev);\n\n\tnetif_dbg(ei_local, hw, dev, \"resetting the 8390 t=%ld...\\n\", jiffies);\n\n\t \n\toutb(inb(NE_BASE + NE_RESET), NE_BASE + NE_RESET);\n\n\tei_status.txing = 0;\n\tei_status.dmaing = 0;\n\n\t \n\twhile ((inb_p(NE_BASE+EN0_ISR) & ENISR_RESET) == 0)\n\t\tif (time_after(jiffies, reset_start_time + 2*HZ/100)) {\n\t\t\tnetdev_err(dev, \"ne_reset_8390() did not complete.\\n\");\n\t\t\tbreak;\n\t\t}\n\toutb_p(ENISR_RESET, NE_BASE + EN0_ISR);\t \n}\n\n \n\nstatic void ne_get_8390_hdr(struct net_device *dev, struct e8390_pkt_hdr *hdr, int ring_page)\n{\n\tint nic_base = dev->base_addr;\n\n\t \n\n\tif (ei_status.dmaing)\n\t{\n\t\tnetdev_err(dev, \"DMAing conflict in ne_get_8390_hdr \"\n\t\t\t   \"[DMAstat:%d][irqlock:%d].\\n\",\n\t\t\t   ei_status.dmaing, ei_status.irqlock);\n\t\treturn;\n\t}\n\n\tei_status.dmaing |= 0x01;\n\toutb_p(E8390_NODMA+E8390_PAGE0+E8390_START, nic_base+ NE_CMD);\n\toutb_p(sizeof(struct e8390_pkt_hdr), nic_base + EN0_RCNTLO);\n\toutb_p(0, nic_base + EN0_RCNTHI);\n\toutb_p(0, nic_base + EN0_RSARLO);\t\t \n\toutb_p(ring_page, nic_base + EN0_RSARHI);\n\toutb_p(E8390_RREAD+E8390_START, nic_base + NE_CMD);\n\n\tif (ei_status.word16)\n\t\tinsw(NE_BASE + NE_DATAPORT, hdr, sizeof(struct e8390_pkt_hdr)>>1);\n\telse\n\t\tinsb(NE_BASE + NE_DATAPORT, hdr, sizeof(struct e8390_pkt_hdr));\n\n\toutb_p(ENISR_RDC, nic_base + EN0_ISR);\t \n\tei_status.dmaing &= ~0x01;\n\n\tle16_to_cpus(&hdr->count);\n}\n\n \n\nstatic void ne_block_input(struct net_device *dev, int count, struct sk_buff *skb, int ring_offset)\n{\n#ifdef NE_SANITY_CHECK\n\tint xfer_count = count;\n\tstruct ei_device *ei_local = netdev_priv(dev);\n#endif\n\tint nic_base = dev->base_addr;\n\tchar *buf = skb->data;\n\n\t \n\tif (ei_status.dmaing)\n\t{\n\t\tnetdev_err(dev, \"DMAing conflict in ne_block_input \"\n\t\t\t   \"[DMAstat:%d][irqlock:%d].\\n\",\n\t\t\t   ei_status.dmaing, ei_status.irqlock);\n\t\treturn;\n\t}\n\tei_status.dmaing |= 0x01;\n\toutb_p(E8390_NODMA+E8390_PAGE0+E8390_START, nic_base+ NE_CMD);\n\toutb_p(count & 0xff, nic_base + EN0_RCNTLO);\n\toutb_p(count >> 8, nic_base + EN0_RCNTHI);\n\toutb_p(ring_offset & 0xff, nic_base + EN0_RSARLO);\n\toutb_p(ring_offset >> 8, nic_base + EN0_RSARHI);\n\toutb_p(E8390_RREAD+E8390_START, nic_base + NE_CMD);\n\tif (ei_status.word16)\n\t{\n\t\tinsw(NE_BASE + NE_DATAPORT,buf,count>>1);\n\t\tif (count & 0x01)\n\t\t{\n\t\t\tbuf[count-1] = inb(NE_BASE + NE_DATAPORT);\n#ifdef NE_SANITY_CHECK\n\t\t\txfer_count++;\n#endif\n\t\t}\n\t} else {\n\t\tinsb(NE_BASE + NE_DATAPORT, buf, count);\n\t}\n\n#ifdef NE_SANITY_CHECK\n\t \n\n\tif (netif_msg_rx_status(ei_local))\n\t{\n\t\t \n\t\tint addr, tries = 20;\n\t\tdo {\n\t\t\t \n\t\t\tint high = inb_p(nic_base + EN0_RSARHI);\n\t\t\tint low = inb_p(nic_base + EN0_RSARLO);\n\t\t\taddr = (high << 8) + low;\n\t\t\tif (((ring_offset + xfer_count) & 0xff) == low)\n\t\t\t\tbreak;\n\t\t} while (--tries > 0);\n\t \tif (tries <= 0)\n\t\t\tnetdev_warn(dev, \"RX transfer address mismatch,\"\n\t\t\t\t    \"%#4.4x (expected) vs. %#4.4x (actual).\\n\",\n\t\t\t\t    ring_offset + xfer_count, addr);\n\t}\n#endif\n\toutb_p(ENISR_RDC, nic_base + EN0_ISR);\t \n\tei_status.dmaing &= ~0x01;\n}\n\nstatic void ne_block_output(struct net_device *dev, int count,\n\t\tconst unsigned char *buf, const int start_page)\n{\n\tint nic_base = NE_BASE;\n\tunsigned long dma_start;\n#ifdef NE_SANITY_CHECK\n\tint retries = 0;\n\tstruct ei_device *ei_local = netdev_priv(dev);\n#endif\n\n\t \n\n\tif (ei_status.word16 && (count & 0x01))\n\t\tcount++;\n\n\t \n\tif (ei_status.dmaing)\n\t{\n\t\tnetdev_err(dev, \"DMAing conflict in ne_block_output.\"\n\t\t\t   \"[DMAstat:%d][irqlock:%d]\\n\",\n\t\t\t   ei_status.dmaing, ei_status.irqlock);\n\t\treturn;\n\t}\n\tei_status.dmaing |= 0x01;\n\t \n\toutb_p(E8390_PAGE0+E8390_START+E8390_NODMA, nic_base + NE_CMD);\n\n#ifdef NE_SANITY_CHECK\nretry:\n#endif\n\n#ifdef NE_RW_BUGFIX\n\t \n\n\toutb_p(0x42, nic_base + EN0_RCNTLO);\n\toutb_p(0x00,   nic_base + EN0_RCNTHI);\n\toutb_p(0x42, nic_base + EN0_RSARLO);\n\toutb_p(0x00, nic_base + EN0_RSARHI);\n\toutb_p(E8390_RREAD+E8390_START, nic_base + NE_CMD);\n\t \n\tudelay(6);\n#endif\n\n\toutb_p(ENISR_RDC, nic_base + EN0_ISR);\n\n\t \n\toutb_p(count & 0xff, nic_base + EN0_RCNTLO);\n\toutb_p(count >> 8,   nic_base + EN0_RCNTHI);\n\toutb_p(0x00, nic_base + EN0_RSARLO);\n\toutb_p(start_page, nic_base + EN0_RSARHI);\n\n\toutb_p(E8390_RWRITE+E8390_START, nic_base + NE_CMD);\n\tif (ei_status.word16) {\n\t\toutsw(NE_BASE + NE_DATAPORT, buf, count>>1);\n\t} else {\n\t\toutsb(NE_BASE + NE_DATAPORT, buf, count);\n\t}\n\n\tdma_start = jiffies;\n\n#ifdef NE_SANITY_CHECK\n\t \n\n\tif (netif_msg_tx_queued(ei_local))\n\t{\n\t\t \n\t\tint addr, tries = 20;\n\t\tdo {\n\t\t\tint high = inb_p(nic_base + EN0_RSARHI);\n\t\t\tint low = inb_p(nic_base + EN0_RSARLO);\n\t\t\taddr = (high << 8) + low;\n\t\t\tif ((start_page << 8) + count == addr)\n\t\t\t\tbreak;\n\t\t} while (--tries > 0);\n\n\t\tif (tries <= 0)\n\t\t{\n\t\t\tnetdev_warn(dev, \"Tx packet transfer address mismatch,\"\n\t\t\t\t    \"%#4.4x (expected) vs. %#4.4x (actual).\\n\",\n\t\t\t\t    (start_page << 8) + count, addr);\n\t\t\tif (retries++ == 0)\n\t\t\t\tgoto retry;\n\t\t}\n\t}\n#endif\n\n\twhile ((inb_p(nic_base + EN0_ISR) & ENISR_RDC) == 0)\n\t\tif (time_after(jiffies, dma_start + 2*HZ/100)) {\t\t \n\t\t\tnetdev_warn(dev, \"timeout waiting for Tx RDC.\\n\");\n\t\t\tne_reset_8390(dev);\n\t\t\tNS8390p_init(dev, 1);\n\t\t\tbreak;\n\t\t}\n\n\toutb_p(ENISR_RDC, nic_base + EN0_ISR);\t \n\tei_status.dmaing &= ~0x01;\n}\n\nstatic int __init ne_drv_probe(struct platform_device *pdev)\n{\n\tstruct net_device *dev;\n\tint err, this_dev = pdev->id;\n\tstruct resource *res;\n\n\tdev = alloc_eip_netdev();\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\t \n\tres = platform_get_resource(pdev, IORESOURCE_IO, 0);\n\tif (res) {\n\t\tdev->base_addr = res->start;\n\t\tdev->irq = platform_get_irq(pdev, 0);\n\t} else {\n\t\tif (this_dev < 0 || this_dev >= MAX_NE_CARDS) {\n\t\t\tfree_netdev(dev);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tdev->base_addr = io[this_dev];\n\t\tdev->irq = irq[this_dev];\n\t\tdev->mem_end = bad[this_dev];\n\t}\n\tSET_NETDEV_DEV(dev, &pdev->dev);\n\terr = do_ne_probe(dev);\n\tif (err) {\n\t\tfree_netdev(dev);\n\t\treturn err;\n\t}\n\tplatform_set_drvdata(pdev, dev);\n\n\t \n\tif (!res) {\n\t\tio[this_dev] = dev->base_addr;\n\t\tirq[this_dev] = dev->irq;\n\t}\n\treturn 0;\n}\n\nstatic int ne_drv_remove(struct platform_device *pdev)\n{\n\tstruct net_device *dev = platform_get_drvdata(pdev);\n\n\tif (dev) {\n\t\tstruct pnp_dev *idev = (struct pnp_dev *)ei_status.priv;\n\t\tnetif_device_detach(dev);\n\t\tunregister_netdev(dev);\n\t\tif (idev)\n\t\t\tpnp_device_detach(idev);\n\t\t \n\t\tei_status.priv = 0;\n\t\tfree_irq(dev->irq, dev);\n\t\trelease_region(dev->base_addr, NE_IO_EXTENT);\n\t\tfree_netdev(dev);\n\t}\n\treturn 0;\n}\n\n \nstatic void ne_loop_rm_unreg(int all)\n{\n\tint this_dev;\n\tstruct platform_device *pdev;\n\tfor (this_dev = 0; this_dev < MAX_NE_CARDS; this_dev++) {\n\t\tpdev = pdev_ne[this_dev];\n\t\t \n\t\tif (pdev && (!platform_get_drvdata(pdev) || all)) {\n\t\t\tne_drv_remove(pdev);\n\t\t\tplatform_device_unregister(pdev);\n\t\t\tpdev_ne[this_dev] = NULL;\n\t\t}\n\t}\n}\n\n#ifdef CONFIG_PM\nstatic int ne_drv_suspend(struct platform_device *pdev, pm_message_t state)\n{\n\tstruct net_device *dev = platform_get_drvdata(pdev);\n\n\tif (netif_running(dev)) {\n\t\tstruct pnp_dev *idev = (struct pnp_dev *)ei_status.priv;\n\t\tnetif_device_detach(dev);\n\t\tif (idev)\n\t\t\tpnp_stop_dev(idev);\n\t}\n\treturn 0;\n}\n\nstatic int ne_drv_resume(struct platform_device *pdev)\n{\n\tstruct net_device *dev = platform_get_drvdata(pdev);\n\n\tif (netif_running(dev)) {\n\t\tstruct pnp_dev *idev = (struct pnp_dev *)ei_status.priv;\n\t\tif (idev)\n\t\t\tpnp_start_dev(idev);\n\t\tne_reset_8390(dev);\n\t\tNS8390p_init(dev, 1);\n\t\tnetif_device_attach(dev);\n\t}\n\treturn 0;\n}\n#else\n#define ne_drv_suspend NULL\n#define ne_drv_resume NULL\n#endif\n\nstatic struct platform_driver ne_driver = {\n\t.remove\t\t= ne_drv_remove,\n\t.suspend\t= ne_drv_suspend,\n\t.resume\t\t= ne_drv_resume,\n\t.driver\t\t= {\n\t\t.name\t= DRV_NAME,\n\t},\n};\n\nstatic void __init ne_add_devices(void)\n{\n\tint this_dev;\n\tstruct platform_device *pdev;\n\n\tfor (this_dev = 0; this_dev < MAX_NE_CARDS; this_dev++) {\n\t\tif (pdev_ne[this_dev])\n\t\t\tcontinue;\n\t\tpdev = platform_device_register_simple(\n\t\t\tDRV_NAME, this_dev, NULL, 0);\n\t\tif (IS_ERR(pdev))\n\t\t\tcontinue;\n\t\tpdev_ne[this_dev] = pdev;\n\t}\n}\n\nstatic int __init ne_init(void)\n{\n\tint retval;\n\n\tif (IS_MODULE(CONFIG_NE2000))\n\t\tne_add_devices();\n\n\tretval = platform_driver_probe(&ne_driver, ne_drv_probe);\n\n\tif (IS_MODULE(CONFIG_NE2000) && retval) {\n\t\tif (io[0] == 0)\n\t\t\tpr_notice(\"ne.c: You must supply \\\"io=0xNNN\\\"\"\n\t\t\t       \" value(s) for ISA cards.\\n\");\n\t\tne_loop_rm_unreg(1);\n\t\treturn retval;\n\t}\n\n\t \n\tne_loop_rm_unreg(0);\n\treturn retval;\n}\nmodule_init(ne_init);\n\n#if !defined(MODULE) && defined(CONFIG_NETDEV_LEGACY_INIT)\nstruct net_device * __init ne_probe(int unit)\n{\n\tint this_dev;\n\tstruct net_device *dev;\n\n\t \n\tthis_dev = 0;\n\twhile ((pdev_ne[this_dev] && platform_get_drvdata(pdev_ne[this_dev])) ||\n\t\tio[this_dev]) {\n\t\tif (++this_dev == MAX_NE_CARDS)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\t \n\tdev = alloc_eip_netdev();\n\tif (!dev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tsprintf(dev->name, \"eth%d\", unit);\n\tnetdev_boot_setup_check(dev);\n\n\tio[this_dev] = dev->base_addr;\n\tirq[this_dev] = dev->irq;\n\tbad[this_dev] = dev->mem_end;\n\n\tfree_netdev(dev);\n\n\tne_add_devices();\n\n\t \n\tfor (this_dev = 0; this_dev < MAX_NE_CARDS; this_dev++) {\n\t\tif (pdev_ne[this_dev]) {\n\t\t\tdev = platform_get_drvdata(pdev_ne[this_dev]);\n\t\t\tif (dev)\n\t\t\t\treturn dev;\n\t\t}\n\t}\n\n\treturn ERR_PTR(-ENODEV);\n}\n#endif\n\nstatic void __exit ne_exit(void)\n{\n\tplatform_driver_unregister(&ne_driver);\n\tne_loop_rm_unreg(1);\n}\nmodule_exit(ne_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}