{
  "module_name": "pcnet_cs.c",
  "hash_id": "9690bfa579ee099618ea6170038983e3ccc5e9b73f8659c2fffc7682352bf44b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/8390/pcnet_cs.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/timer.h>\n#include <linux/delay.h>\n#include <linux/netdevice.h>\n#include <linux/log2.h>\n#include <linux/etherdevice.h>\n#include <linux/mii.h>\n#include \"8390.h\"\n\n#include <pcmcia/cistpl.h>\n#include <pcmcia/ciscode.h>\n#include <pcmcia/ds.h>\n#include <pcmcia/cisreg.h>\n\n#include <asm/io.h>\n#include <asm/byteorder.h>\n#include <linux/uaccess.h>\n\n#define PCNET_CMD\t0x00\n#define PCNET_DATAPORT\t0x10\t \n#define PCNET_RESET\t0x1f\t \n#define PCNET_MISC\t0x18\t \n\n#define PCNET_START_PG\t0x40\t \n#define PCNET_STOP_PG\t0x80\t \n\n \n#define SOCKET_START_PG\t0x01\n#define SOCKET_STOP_PG\t0xff\n\n#define PCNET_RDC_TIMEOUT (2*HZ/100)\t \n\nstatic const char *if_names[] = { \"auto\", \"10baseT\", \"10base2\"};\n\n \n\n \n\nMODULE_AUTHOR(\"David Hinds <dahinds@users.sourceforge.net>\");\nMODULE_DESCRIPTION(\"NE2000 compatible PCMCIA ethernet driver\");\nMODULE_LICENSE(\"GPL\");\n\n#define INT_MODULE_PARM(n, v) static int n = v; module_param(n, int, 0)\n\nINT_MODULE_PARM(if_port,\t1);\t \nINT_MODULE_PARM(use_big_buf,\t1);\t \nINT_MODULE_PARM(mem_speed,\t0);\t \nINT_MODULE_PARM(delay_output,\t0);\t \nINT_MODULE_PARM(delay_time,\t4);\t \nINT_MODULE_PARM(use_shmem,\t-1);\t \nINT_MODULE_PARM(full_duplex,\t0);\t \n\n \nstatic int hw_addr[6] = { 0,   };\nmodule_param_array(hw_addr, int, NULL, 0);\n\n \n\nstatic void mii_phy_probe(struct net_device *dev);\nstatic int pcnet_config(struct pcmcia_device *link);\nstatic void pcnet_release(struct pcmcia_device *link);\nstatic int pcnet_open(struct net_device *dev);\nstatic int pcnet_close(struct net_device *dev);\nstatic int ei_ioctl(struct net_device *dev, struct ifreq *rq, int cmd);\nstatic irqreturn_t ei_irq_wrapper(int irq, void *dev_id);\nstatic void ei_watchdog(struct timer_list *t);\nstatic void pcnet_reset_8390(struct net_device *dev);\nstatic int set_config(struct net_device *dev, struct ifmap *map);\nstatic int setup_shmem_window(struct pcmcia_device *link, int start_pg,\n\t\t\t      int stop_pg, int cm_offset);\nstatic int setup_dma_config(struct pcmcia_device *link, int start_pg,\n\t\t\t    int stop_pg);\n\nstatic void pcnet_detach(struct pcmcia_device *p_dev);\n\n \n\nstruct hw_info {\n    u_int\toffset;\n    u_char\ta0, a1, a2;\n    u_int\tflags;\n};\n\n#define DELAY_OUTPUT\t0x01\n#define HAS_MISC_REG\t0x02\n#define USE_BIG_BUF\t0x04\n#define HAS_IBM_MISC\t0x08\n#define IS_DL10019\t0x10\n#define IS_DL10022\t0x20\n#define HAS_MII\t\t0x40\n#define USE_SHMEM\t0x80\t \n\n#define AM79C9XX_HOME_PHY\t0x00006B90   \n#define AM79C9XX_ETH_PHY\t0x00006B70   \n#define MII_PHYID_REV_MASK\t0xfffffff0\n#define MII_PHYID_REG1\t\t0x02\n#define MII_PHYID_REG2\t\t0x03\n\nstatic struct hw_info hw_info[] = {\n    {   0x0ff0, 0x00, 0x00, 0xe8, DELAY_OUTPUT },\n    {   0x0ff0, 0x00, 0x00, 0xf4, 0 },\n    {   0x03f4, 0x00, 0x20, 0xe5, 0 },\n    {   0x4910, 0x00, 0x00, 0x94,\n      DELAY_OUTPUT | HAS_IBM_MISC },\n    {   0x0110, 0x00, 0x40, 0xc7, 0 },\n    {   0x0ff0, 0x00, 0x20, 0xe8, 0 },\n    {   0x0110, 0x00, 0x80, 0x19, 0 },\n    {   0x0040, 0x00, 0x80, 0xc8, 0 },\n    {   0x0110, 0x00, 0x40, 0x33, 0 },\n    {   0x01c0, 0x00, 0x00, 0xb4, 0 },\n    {   0x0ff0, 0x00, 0x00, 0x48,\n      HAS_MISC_REG | HAS_IBM_MISC },\n    {   0xb8, 0x08, 0x00, 0x42, 0 },\n    {   0x01c0, 0x00, 0x40, 0x4c, 0 },\n    {   0x0ff0, 0x08, 0x00, 0x5a,\n      HAS_MISC_REG | HAS_IBM_MISC },\n    {   0x0ff0, 0x00, 0x04, 0xac,\n      HAS_MISC_REG | HAS_IBM_MISC },\n    {   0x0ff0, 0x00, 0x06, 0x29,\n      HAS_MISC_REG | HAS_IBM_MISC },\n    {   0x0374, 0x08, 0x00, 0x5a,\n      HAS_MISC_REG | HAS_IBM_MISC },\n    {   0x0374, 0x00, 0x04, 0xac,\n      HAS_MISC_REG | HAS_IBM_MISC },\n    {   0x0ff0, 0x00, 0x60, 0x87,\n      HAS_MISC_REG | HAS_IBM_MISC },\n    {   0x0374, 0x08, 0x00, 0x17,\n      HAS_MISC_REG | HAS_IBM_MISC },\n    {   0x0374, 0x00, 0xc0, 0xa8,\n      HAS_MISC_REG | HAS_IBM_MISC },\n    {   0x0374, 0x00, 0xa0, 0xb0,\n      HAS_MISC_REG | HAS_IBM_MISC },\n    {   0x0198, 0x00, 0x20, 0xe0,\n      HAS_MISC_REG | HAS_IBM_MISC },\n    {   0x0ff0, 0x00, 0xa0, 0xb0, 0 },\n    {   0x0110, 0x00, 0x40, 0xf6, 0 },\n    {   0x0ff0, 0x00, 0xc0, 0xf0,\n      HAS_MISC_REG | HAS_IBM_MISC },\n    {   0x0ff0, 0xe2, 0x0c, 0x0f,\n      HAS_MISC_REG | HAS_IBM_MISC },\n    {   0x0180, 0x00, 0xc0, 0xf0, 0 },\n    {   0x5000, 0x00, 0x00, 0xe8, 0 },\n    {   0x003a, 0x00, 0x80, 0xc6, 0 },\n    {   0x0ff0, 0x00, 0xa0, 0x0c, 0 },\n    {   0x0ff0, 0x00, 0x00, 0x65,\n      HAS_MISC_REG | HAS_IBM_MISC },\n    {   0x0ff0, 0x00, 0x80, 0x45,\n      HAS_MISC_REG | HAS_IBM_MISC },\n    {   0x07f0, 0x00, 0x20, 0xe0, 0 },\n    {   0x0110, 0x00, 0x40, 0x95, 0 },\n    {   0x0ff0, 0x00, 0x20, 0xcb, 0 },\n    {   0x4000, 0x00, 0xc0, 0x1b,\n      DELAY_OUTPUT | HAS_MISC_REG | USE_BIG_BUF },\n    {   0x01c0, 0x00, 0xc0, 0x1b, 0 },\n    {   0x0110, 0x00, 0xe0, 0x98, 0 },\n    {   0x0060, 0x00, 0x40, 0x05, 0 },\n    {   0x0ff0, 0x00, 0x00, 0x4c, 0 },\n    {   0x01c8, 0x00, 0xa0, 0x0c, 0 }\n};\n\n#define NR_INFO\t\tARRAY_SIZE(hw_info)\n\nstatic struct hw_info default_info = { 0, 0, 0, 0, 0 };\nstatic struct hw_info dl10019_info = { 0, 0, 0, 0, IS_DL10019|HAS_MII };\nstatic struct hw_info dl10022_info = { 0, 0, 0, 0, IS_DL10022|HAS_MII };\n\nstruct pcnet_dev {\n\tstruct pcmcia_device\t*p_dev;\n    u_int\t\tflags;\n    void\t\t__iomem *base;\n    struct timer_list\twatchdog;\n    int\t\t\tstale, fast_poll;\n    u_char\t\tphy_id;\n    u_char\t\teth_phy, pna_phy;\n    u_short\t\tlink_status;\n    u_long\t\tmii_reset;\n};\n\nstatic inline struct pcnet_dev *PRIV(struct net_device *dev)\n{\n\tchar *p = netdev_priv(dev);\n\treturn (struct pcnet_dev *)(p + sizeof(struct ei_device));\n}\n\nstatic const struct net_device_ops pcnet_netdev_ops = {\n\t.ndo_open\t\t= pcnet_open,\n\t.ndo_stop\t\t= pcnet_close,\n\t.ndo_set_config\t\t= set_config,\n\t.ndo_start_xmit \t= ei_start_xmit,\n\t.ndo_get_stats\t\t= ei_get_stats,\n\t.ndo_eth_ioctl\t\t= ei_ioctl,\n\t.ndo_set_rx_mode\t= ei_set_multicast_list,\n\t.ndo_tx_timeout \t= ei_tx_timeout,\n\t.ndo_set_mac_address \t= eth_mac_addr,\n\t.ndo_validate_addr\t= eth_validate_addr,\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\t.ndo_poll_controller \t= ei_poll,\n#endif\n};\n\nstatic int pcnet_probe(struct pcmcia_device *link)\n{\n    struct pcnet_dev *info;\n    struct net_device *dev;\n\n    dev_dbg(&link->dev, \"pcnet_attach()\\n\");\n\n     \n    dev = __alloc_ei_netdev(sizeof(struct pcnet_dev));\n    if (!dev) return -ENOMEM;\n    info = PRIV(dev);\n    info->p_dev = link;\n    link->priv = dev;\n\n    link->config_flags |= CONF_ENABLE_IRQ | CONF_AUTO_SET_IO;\n\n    dev->netdev_ops = &pcnet_netdev_ops;\n\n    return pcnet_config(link);\n}  \n\nstatic void pcnet_detach(struct pcmcia_device *link)\n{\n\tstruct net_device *dev = link->priv;\n\n\tdev_dbg(&link->dev, \"pcnet_detach\\n\");\n\n\tunregister_netdev(dev);\n\n\tpcnet_release(link);\n\n\tfree_netdev(dev);\n}  \n\n \n\nstatic struct hw_info *get_hwinfo(struct pcmcia_device *link)\n{\n    struct net_device *dev = link->priv;\n    u_char __iomem *base, *virt;\n    u8 addr[ETH_ALEN];\n    int i, j;\n\n     \n    link->resource[2]->flags |= WIN_DATA_WIDTH_8|WIN_MEMORY_TYPE_AM|WIN_ENABLE;\n    link->resource[2]->start = 0; link->resource[2]->end = 0;\n    i = pcmcia_request_window(link, link->resource[2], 0);\n    if (i != 0)\n\treturn NULL;\n\n    virt = ioremap(link->resource[2]->start,\n\t    resource_size(link->resource[2]));\n    if (unlikely(!virt)) {\n\t    pcmcia_release_window(link, link->resource[2]);\n\t    return NULL;\n    }\n\n    for (i = 0; i < NR_INFO; i++) {\n\tpcmcia_map_mem_page(link, link->resource[2],\n\t\thw_info[i].offset & ~(resource_size(link->resource[2])-1));\n\tbase = &virt[hw_info[i].offset & (resource_size(link->resource[2])-1)];\n\tif ((readb(base+0) == hw_info[i].a0) &&\n\t    (readb(base+2) == hw_info[i].a1) &&\n\t    (readb(base+4) == hw_info[i].a2)) {\n\t\tfor (j = 0; j < 6; j++)\n\t\t\taddr[j] = readb(base + (j<<1));\n\t\teth_hw_addr_set(dev, addr);\n\t\tbreak;\n\t}\n    }\n\n    iounmap(virt);\n    j = pcmcia_release_window(link, link->resource[2]);\n    return (i < NR_INFO) ? hw_info+i : NULL;\n}  \n\n \n\nstatic struct hw_info *get_prom(struct pcmcia_device *link)\n{\n    struct net_device *dev = link->priv;\n    unsigned int ioaddr = dev->base_addr;\n    u8 addr[ETH_ALEN];\n    u_char prom[32];\n    int i, j;\n\n     \n    struct {\n\tu_char value, offset;\n    } program_seq[] = {\n\t{E8390_NODMA+E8390_PAGE0+E8390_STOP, E8390_CMD},  \n\t{0x48,\tEN0_DCFG},\t \n\t{0x00,\tEN0_RCNTLO},\t \n\t{0x00,\tEN0_RCNTHI},\n\t{0x00,\tEN0_IMR},\t \n\t{0xFF,\tEN0_ISR},\n\t{E8390_RXOFF, EN0_RXCR},\t \n\t{E8390_TXOFF, EN0_TXCR},\t \n\t{32,\tEN0_RCNTLO},\n\t{0x00,\tEN0_RCNTHI},\n\t{0x00,\tEN0_RSARLO},\t \n\t{0x00,\tEN0_RSARHI},\n\t{E8390_RREAD+E8390_START, E8390_CMD},\n    };\n\n    pcnet_reset_8390(dev);\n    mdelay(10);\n\n    for (i = 0; i < ARRAY_SIZE(program_seq); i++)\n\toutb_p(program_seq[i].value, ioaddr + program_seq[i].offset);\n\n    for (i = 0; i < 32; i++)\n\tprom[i] = inb(ioaddr + PCNET_DATAPORT);\n    for (i = 0; i < NR_INFO; i++) {\n\tif ((prom[0] == hw_info[i].a0) &&\n\t    (prom[2] == hw_info[i].a1) &&\n\t    (prom[4] == hw_info[i].a2))\n\t    break;\n    }\n    if ((i < NR_INFO) || ((prom[28] == 0x57) && (prom[30] == 0x57))) {\n\tfor (j = 0; j < 6; j++)\n\t    addr[j] = prom[j<<1];\n\teth_hw_addr_set(dev, addr);\n\treturn (i < NR_INFO) ? hw_info+i : &default_info;\n    }\n    return NULL;\n}  \n\n \n\nstatic struct hw_info *get_dl10019(struct pcmcia_device *link)\n{\n    struct net_device *dev = link->priv;\n    u8 addr[ETH_ALEN];\n    int i;\n    u_char sum;\n\n    for (sum = 0, i = 0x14; i < 0x1c; i++)\n\tsum += inb_p(dev->base_addr + i);\n    if (sum != 0xff)\n\treturn NULL;\n    for (i = 0; i < 6; i++)\n\taddr[i] = inb_p(dev->base_addr + 0x14 + i);\n    eth_hw_addr_set(dev, addr);\n    i = inb(dev->base_addr + 0x1f);\n    return ((i == 0x91)||(i == 0x99)) ? &dl10022_info : &dl10019_info;\n}\n\n \n\nstatic struct hw_info *get_ax88190(struct pcmcia_device *link)\n{\n    struct net_device *dev = link->priv;\n    unsigned int ioaddr = dev->base_addr;\n    u8 addr[ETH_ALEN];\n    int i, j;\n\n     \n    if (link->config_base != 0x03c0)\n\treturn NULL;\n\n    outb_p(0x01, ioaddr + EN0_DCFG);\t \n    outb_p(0x00, ioaddr + EN0_RSARLO);\t \n    outb_p(0x04, ioaddr + EN0_RSARHI);\n    outb_p(E8390_RREAD+E8390_START, ioaddr + E8390_CMD);\n\n    for (i = 0; i < 6; i += 2) {\n\tj = inw(ioaddr + PCNET_DATAPORT);\n\taddr[i] = j & 0xff;\n\taddr[i+1] = j >> 8;\n    }\n    eth_hw_addr_set(dev, addr);\n    return NULL;\n}\n\n \n\nstatic struct hw_info *get_hwired(struct pcmcia_device *link)\n{\n    struct net_device *dev = link->priv;\n    u8 addr[ETH_ALEN];\n    int i;\n\n    for (i = 0; i < 6; i++)\n\tif (hw_addr[i] != 0) break;\n    if (i == 6)\n\treturn NULL;\n\n    for (i = 0; i < 6; i++)\n\taddr[i] = hw_addr[i];\n    eth_hw_addr_set(dev, addr);\n\n    return &default_info;\n}  \n\nstatic int try_io_port(struct pcmcia_device *link)\n{\n    int j, ret;\n    link->resource[0]->flags &= ~IO_DATA_PATH_WIDTH;\n    link->resource[1]->flags &= ~IO_DATA_PATH_WIDTH;\n    if (link->resource[0]->end == 32) {\n\tlink->resource[0]->flags |= IO_DATA_PATH_WIDTH_AUTO;\n\tif (link->resource[1]->end > 0) {\n\t     \n\t    link->resource[1]->flags |= IO_DATA_PATH_WIDTH_8;\n\t}\n    } else {\n\t \n\tlink->resource[0]->flags |= IO_DATA_PATH_WIDTH_8;\n\tlink->resource[1]->flags |= IO_DATA_PATH_WIDTH_16;\n    }\n    if (link->resource[0]->start == 0) {\n\tfor (j = 0; j < 0x400; j += 0x20) {\n\t    link->resource[0]->start = j ^ 0x300;\n\t    link->resource[1]->start = (j ^ 0x300) + 0x10;\n\t    link->io_lines = 16;\n\t    ret = pcmcia_request_io(link);\n\t    if (ret == 0)\n\t\t    return ret;\n\t}\n\treturn ret;\n    } else {\n\treturn pcmcia_request_io(link);\n    }\n}\n\nstatic int pcnet_confcheck(struct pcmcia_device *p_dev, void *priv_data)\n{\n\tint *priv = priv_data;\n\tint try = (*priv & 0x1);\n\n\t*priv &= (p_dev->resource[2]->end >= 0x4000) ? 0x10 : ~0x10;\n\n\tif (p_dev->config_index == 0)\n\t\treturn -EINVAL;\n\n\tif (p_dev->resource[0]->end + p_dev->resource[1]->end < 32)\n\t\treturn -EINVAL;\n\n\tif (try)\n\t\tp_dev->io_lines = 16;\n\treturn try_io_port(p_dev);\n}\n\nstatic struct hw_info *pcnet_try_config(struct pcmcia_device *link,\n\t\t\t\t\tint *has_shmem, int try)\n{\n\tstruct net_device *dev = link->priv;\n\tstruct hw_info *local_hw_info;\n\tstruct pcnet_dev *info = PRIV(dev);\n\tint priv = try;\n\tint ret;\n\n\tret = pcmcia_loop_config(link, pcnet_confcheck, &priv);\n\tif (ret) {\n\t\tdev_warn(&link->dev, \"no useable port range found\\n\");\n\t\treturn NULL;\n\t}\n\t*has_shmem = (priv & 0x10);\n\n\tif (!link->irq)\n\t\treturn NULL;\n\n\tif (resource_size(link->resource[1]) == 8)\n\t\tlink->config_flags |= CONF_ENABLE_SPKR;\n\n\tif ((link->manf_id == MANFID_IBM) &&\n\t    (link->card_id == PRODID_IBM_HOME_AND_AWAY))\n\t\tlink->config_index |= 0x10;\n\n\tret = pcmcia_enable_device(link);\n\tif (ret)\n\t\treturn NULL;\n\n\tdev->irq = link->irq;\n\tdev->base_addr = link->resource[0]->start;\n\n\tif (info->flags & HAS_MISC_REG) {\n\t\tif ((if_port == 1) || (if_port == 2))\n\t\t\tdev->if_port = if_port;\n\t\telse\n\t\t\tdev_notice(&link->dev, \"invalid if_port requested\\n\");\n\t} else\n\t\tdev->if_port = 0;\n\n\tif ((link->config_base == 0x03c0) &&\n\t    (link->manf_id == 0x149) && (link->card_id == 0xc1ab)) {\n\t\tdev_info(&link->dev,\n\t\t\t\"this is an AX88190 card - use axnet_cs instead.\\n\");\n\t\treturn NULL;\n\t}\n\n\tlocal_hw_info = get_hwinfo(link);\n\tif (!local_hw_info)\n\t\tlocal_hw_info = get_prom(link);\n\tif (!local_hw_info)\n\t\tlocal_hw_info = get_dl10019(link);\n\tif (!local_hw_info)\n\t\tlocal_hw_info = get_ax88190(link);\n\tif (!local_hw_info)\n\t\tlocal_hw_info = get_hwired(link);\n\n\treturn local_hw_info;\n}\n\nstatic int pcnet_config(struct pcmcia_device *link)\n{\n    struct net_device *dev = link->priv;\n    struct pcnet_dev *info = PRIV(dev);\n    int start_pg, stop_pg, cm_offset;\n    int has_shmem = 0;\n    struct hw_info *local_hw_info;\n\n    dev_dbg(&link->dev, \"pcnet_config\\n\");\n\n    local_hw_info = pcnet_try_config(link, &has_shmem, 0);\n    if (!local_hw_info) {\n\t     \n\t    pcmcia_disable_device(link);\n\t    local_hw_info = pcnet_try_config(link, &has_shmem, 1);\n\t    if (local_hw_info == NULL) {\n\t\t    dev_notice(&link->dev, \"unable to read hardware net\"\n\t\t\t    \" address for io base %#3lx\\n\", dev->base_addr);\n\t\t    goto failed;\n\t    }\n    }\n\n    info->flags = local_hw_info->flags;\n     \n    info->flags |= (delay_output) ? DELAY_OUTPUT : 0;\n    if ((link->manf_id == MANFID_SOCKET) &&\n\t((link->card_id == PRODID_SOCKET_LPE) ||\n\t (link->card_id == PRODID_SOCKET_LPE_CF) ||\n\t (link->card_id == PRODID_SOCKET_EIO)))\n\tinfo->flags &= ~USE_BIG_BUF;\n    if (!use_big_buf)\n\tinfo->flags &= ~USE_BIG_BUF;\n\n    if (info->flags & USE_BIG_BUF) {\n\tstart_pg = SOCKET_START_PG;\n\tstop_pg = SOCKET_STOP_PG;\n\tcm_offset = 0x10000;\n    } else {\n\tstart_pg = PCNET_START_PG;\n\tstop_pg = PCNET_STOP_PG;\n\tcm_offset = 0;\n    }\n\n     \n    if ((use_shmem == 0) || (!has_shmem && (use_shmem == -1)) ||\n\t(setup_shmem_window(link, start_pg, stop_pg, cm_offset) != 0))\n\tsetup_dma_config(link, start_pg, stop_pg);\n\n    ei_status.name = \"NE2000\";\n    ei_status.word16 = 1;\n    ei_status.reset_8390 = pcnet_reset_8390;\n\n    if (info->flags & (IS_DL10019|IS_DL10022))\n\tmii_phy_probe(dev);\n\n    SET_NETDEV_DEV(dev, &link->dev);\n\n    if (register_netdev(dev) != 0) {\n\tpr_notice(\"register_netdev() failed\\n\");\n\tgoto failed;\n    }\n\n    if (info->flags & (IS_DL10019|IS_DL10022)) {\n\tu_char id = inb(dev->base_addr + 0x1a);\n\tnetdev_info(dev, \"NE2000 (DL100%d rev %02x): \",\n\t\t    (info->flags & IS_DL10022) ? 22 : 19, id);\n\tif (info->pna_phy)\n\t    pr_cont(\"PNA, \");\n    } else {\n\tnetdev_info(dev, \"NE2000 Compatible: \");\n    }\n    pr_cont(\"io %#3lx, irq %d,\", dev->base_addr, dev->irq);\n    if (info->flags & USE_SHMEM)\n\tpr_cont(\" mem %#5lx,\", dev->mem_start);\n    if (info->flags & HAS_MISC_REG)\n\tpr_cont(\" %s xcvr,\", if_names[dev->if_port]);\n    pr_cont(\" hw_addr %pM\\n\", dev->dev_addr);\n    return 0;\n\nfailed:\n    pcnet_release(link);\n    return -ENODEV;\n}  \n\nstatic void pcnet_release(struct pcmcia_device *link)\n{\n\tstruct pcnet_dev *info = PRIV(link->priv);\n\n\tdev_dbg(&link->dev, \"pcnet_release\\n\");\n\n\tif (info->flags & USE_SHMEM)\n\t\tiounmap(info->base);\n\n\tpcmcia_disable_device(link);\n}\n\nstatic int pcnet_suspend(struct pcmcia_device *link)\n{\n\tstruct net_device *dev = link->priv;\n\n\tif (link->open)\n\t\tnetif_device_detach(dev);\n\n\treturn 0;\n}\n\nstatic int pcnet_resume(struct pcmcia_device *link)\n{\n\tstruct net_device *dev = link->priv;\n\n\tif (link->open) {\n\t\tpcnet_reset_8390(dev);\n\t\tNS8390_init(dev, 1);\n\t\tnetif_device_attach(dev);\n\t}\n\n\treturn 0;\n}\n\n\n \n\n#define DLINK_GPIO\t\t0x1c\n#define DLINK_DIAG\t\t0x1d\n#define DLINK_EEPROM\t\t0x1e\n\n#define MDIO_SHIFT_CLK\t\t0x80\n#define MDIO_DATA_OUT\t\t0x40\n#define MDIO_DIR_WRITE\t\t0x30\n#define MDIO_DATA_WRITE0\t(MDIO_DIR_WRITE)\n#define MDIO_DATA_WRITE1\t(MDIO_DIR_WRITE | MDIO_DATA_OUT)\n#define MDIO_DATA_READ\t\t0x10\n#define MDIO_MASK\t\t0x0f\n\nstatic void mdio_sync(unsigned int addr)\n{\n    int bits, mask = inb(addr) & MDIO_MASK;\n    for (bits = 0; bits < 32; bits++) {\n\toutb(mask | MDIO_DATA_WRITE1, addr);\n\toutb(mask | MDIO_DATA_WRITE1 | MDIO_SHIFT_CLK, addr);\n    }\n}\n\nstatic int mdio_read(unsigned int addr, int phy_id, int loc)\n{\n    u_int cmd = (0x06<<10)|(phy_id<<5)|loc;\n    int i, retval = 0, mask = inb(addr) & MDIO_MASK;\n\n    mdio_sync(addr);\n    for (i = 13; i >= 0; i--) {\n\tint dat = (cmd&(1<<i)) ? MDIO_DATA_WRITE1 : MDIO_DATA_WRITE0;\n\toutb(mask | dat, addr);\n\toutb(mask | dat | MDIO_SHIFT_CLK, addr);\n    }\n    for (i = 19; i > 0; i--) {\n\toutb(mask, addr);\n\tretval = (retval << 1) | ((inb(addr) & MDIO_DATA_READ) != 0);\n\toutb(mask | MDIO_SHIFT_CLK, addr);\n    }\n    return (retval>>1) & 0xffff;\n}\n\nstatic void mdio_write(unsigned int addr, int phy_id, int loc, int value)\n{\n    u_int cmd = (0x05<<28)|(phy_id<<23)|(loc<<18)|(1<<17)|value;\n    int i, mask = inb(addr) & MDIO_MASK;\n\n    mdio_sync(addr);\n    for (i = 31; i >= 0; i--) {\n\tint dat = (cmd&(1<<i)) ? MDIO_DATA_WRITE1 : MDIO_DATA_WRITE0;\n\toutb(mask | dat, addr);\n\toutb(mask | dat | MDIO_SHIFT_CLK, addr);\n    }\n    for (i = 1; i >= 0; i--) {\n\toutb(mask, addr);\n\toutb(mask | MDIO_SHIFT_CLK, addr);\n    }\n}\n\n \n\n#define EE_EEP\t\t0x40\n#define EE_ASIC\t\t0x10\n#define EE_CS\t\t0x08\n#define EE_CK\t\t0x04\n#define EE_DO\t\t0x02\n#define EE_DI\t\t0x01\n#define EE_ADOT\t\t0x01\t \n#define EE_READ_CMD\t0x06\n\n#define DL19FDUPLX\t0x0400\t \n\nstatic int read_eeprom(unsigned int ioaddr, int location)\n{\n    int i, retval = 0;\n    unsigned int ee_addr = ioaddr + DLINK_EEPROM;\n    int read_cmd = location | (EE_READ_CMD << 8);\n\n    outb(0, ee_addr);\n    outb(EE_EEP|EE_CS, ee_addr);\n\n     \n    for (i = 10; i >= 0; i--) {\n\tshort dataval = (read_cmd & (1 << i)) ? EE_DO : 0;\n\toutb_p(EE_EEP|EE_CS|dataval, ee_addr);\n\toutb_p(EE_EEP|EE_CS|dataval|EE_CK, ee_addr);\n    }\n    outb(EE_EEP|EE_CS, ee_addr);\n\n    for (i = 16; i > 0; i--) {\n\toutb_p(EE_EEP|EE_CS | EE_CK, ee_addr);\n\tretval = (retval << 1) | ((inb(ee_addr) & EE_DI) ? 1 : 0);\n\toutb_p(EE_EEP|EE_CS, ee_addr);\n    }\n\n     \n    outb(0, ee_addr);\n    return retval;\n}\n\n \n\nstatic void write_asic(unsigned int ioaddr, int location, short asic_data)\n{\n\tint i;\n\tunsigned int ee_addr = ioaddr + DLINK_EEPROM;\n\tshort dataval;\n\tint read_cmd = location | (EE_READ_CMD << 8);\n\n\tasic_data |= read_eeprom(ioaddr, location);\n\n\toutb(0, ee_addr);\n\toutb(EE_ASIC|EE_CS|EE_DI, ee_addr);\n\n\tread_cmd = read_cmd >> 1;\n\n\t \n\tfor (i = 9; i >= 0; i--) {\n\t\tdataval = (read_cmd & (1 << i)) ? EE_DO : 0;\n\t\toutb_p(EE_ASIC|EE_CS|EE_DI|dataval, ee_addr);\n\t\toutb_p(EE_ASIC|EE_CS|EE_DI|dataval|EE_CK, ee_addr);\n\t\toutb_p(EE_ASIC|EE_CS|EE_DI|dataval, ee_addr);\n\t}\n\t \n\toutb(EE_ASIC|EE_CS, ee_addr);\n\toutb(EE_ASIC|EE_CS|EE_CK, ee_addr);\n\toutb(EE_ASIC|EE_CS, ee_addr);\n\n\tfor (i = 15; i >= 0; i--) {\n\t\tdataval = (asic_data & (1 << i)) ? EE_ADOT : 0;\n\t\toutb_p(EE_ASIC|EE_CS|dataval, ee_addr);\n\t\toutb_p(EE_ASIC|EE_CS|dataval|EE_CK, ee_addr);\n\t\toutb_p(EE_ASIC|EE_CS|dataval, ee_addr);\n\t}\n\n\t \n\toutb(EE_ASIC|EE_DI, ee_addr);\n\toutb(EE_ASIC|EE_DI| EE_CK, ee_addr);\n\toutb(EE_ASIC|EE_DI, ee_addr);\n\n\toutb(0, ee_addr);\n}\n\n \n\nstatic void set_misc_reg(struct net_device *dev)\n{\n    unsigned int nic_base = dev->base_addr;\n    struct pcnet_dev *info = PRIV(dev);\n    u_char tmp;\n\n    if (info->flags & HAS_MISC_REG) {\n\ttmp = inb_p(nic_base + PCNET_MISC) & ~3;\n\tif (dev->if_port == 2)\n\t    tmp |= 1;\n\tif (info->flags & USE_BIG_BUF)\n\t    tmp |= 2;\n\tif (info->flags & HAS_IBM_MISC)\n\t    tmp |= 8;\n\toutb_p(tmp, nic_base + PCNET_MISC);\n    }\n    if (info->flags & IS_DL10022) {\n\tif (info->flags & HAS_MII) {\n\t     \n\t    mdio_write(nic_base + DLINK_GPIO, info->eth_phy, 4, 0x01e1);\n\t     \n\t    mdio_write(nic_base + DLINK_GPIO, info->eth_phy, 0, 0x0000);\n\t    mdio_write(nic_base + DLINK_GPIO, info->eth_phy, 0, 0x1200);\n\t    info->mii_reset = jiffies;\n\t} else {\n\t    outb(full_duplex ? 4 : 0, nic_base + DLINK_DIAG);\n\t}\n    } else if (info->flags & IS_DL10019) {\n\t \n\tmdio_write(nic_base + DLINK_GPIO, info->eth_phy, 4, 0x01e1);\n\t \n\tmdio_write(nic_base + DLINK_GPIO, info->eth_phy, 0, 0x0000);\n\tmdio_write(nic_base + DLINK_GPIO, info->eth_phy, 0, 0x1200);\n    }\n}\n\n \n\nstatic void mii_phy_probe(struct net_device *dev)\n{\n    struct pcnet_dev *info = PRIV(dev);\n    unsigned int mii_addr = dev->base_addr + DLINK_GPIO;\n    int i;\n    u_int tmp, phyid;\n\n    for (i = 31; i >= 0; i--) {\n\ttmp = mdio_read(mii_addr, i, 1);\n\tif ((tmp == 0) || (tmp == 0xffff))\n\t    continue;\n\ttmp = mdio_read(mii_addr, i, MII_PHYID_REG1);\n\tphyid = tmp << 16;\n\tphyid |= mdio_read(mii_addr, i, MII_PHYID_REG2);\n\tphyid &= MII_PHYID_REV_MASK;\n\tnetdev_dbg(dev, \"MII at %d is 0x%08x\\n\", i, phyid);\n\tif (phyid == AM79C9XX_HOME_PHY) {\n\t    info->pna_phy = i;\n\t} else if (phyid != AM79C9XX_ETH_PHY) {\n\t    info->eth_phy = i;\n\t}\n    }\n}\n\nstatic int pcnet_open(struct net_device *dev)\n{\n    int ret;\n    struct pcnet_dev *info = PRIV(dev);\n    struct pcmcia_device *link = info->p_dev;\n    unsigned int nic_base = dev->base_addr;\n\n    dev_dbg(&link->dev, \"pcnet_open('%s')\\n\", dev->name);\n\n    if (!pcmcia_dev_present(link))\n\treturn -ENODEV;\n\n    set_misc_reg(dev);\n\n    outb_p(0xFF, nic_base + EN0_ISR);  \n    ret = request_irq(dev->irq, ei_irq_wrapper, IRQF_SHARED, dev->name, dev);\n    if (ret)\n\t    return ret;\n\n    link->open++;\n\n    info->phy_id = info->eth_phy;\n    info->link_status = 0x00;\n    timer_setup(&info->watchdog, ei_watchdog, 0);\n    mod_timer(&info->watchdog, jiffies + HZ);\n\n    return ei_open(dev);\n}  \n\n \n\nstatic int pcnet_close(struct net_device *dev)\n{\n    struct pcnet_dev *info = PRIV(dev);\n    struct pcmcia_device *link = info->p_dev;\n\n    dev_dbg(&link->dev, \"pcnet_close('%s')\\n\", dev->name);\n\n    ei_close(dev);\n    free_irq(dev->irq, dev);\n\n    link->open--;\n    netif_stop_queue(dev);\n    del_timer_sync(&info->watchdog);\n\n    return 0;\n}  \n\n \n\nstatic void pcnet_reset_8390(struct net_device *dev)\n{\n    unsigned int nic_base = dev->base_addr;\n    int i;\n\n    ei_status.txing = ei_status.dmaing = 0;\n\n    outb_p(E8390_NODMA+E8390_PAGE0+E8390_STOP, nic_base + E8390_CMD);\n\n    outb(inb(nic_base + PCNET_RESET), nic_base + PCNET_RESET);\n\n    for (i = 0; i < 100; i++) {\n\tif ((inb_p(nic_base+EN0_ISR) & ENISR_RESET) != 0)\n\t    break;\n\tudelay(100);\n    }\n    outb_p(ENISR_RESET, nic_base + EN0_ISR);  \n\n    if (i == 100)\n\tnetdev_err(dev, \"pcnet_reset_8390() did not complete.\\n\");\n\n    set_misc_reg(dev);\n\n}  \n\n \n\nstatic int set_config(struct net_device *dev, struct ifmap *map)\n{\n    struct pcnet_dev *info = PRIV(dev);\n    if ((map->port != (u_char)(-1)) && (map->port != dev->if_port)) {\n\tif (!(info->flags & HAS_MISC_REG))\n\t    return -EOPNOTSUPP;\n\telse if ((map->port < 1) || (map->port > 2))\n\t    return -EINVAL;\n\tdev->if_port = map->port;\n\tnetdev_info(dev, \"switched to %s port\\n\", if_names[dev->if_port]);\n\tNS8390_init(dev, 1);\n    }\n    return 0;\n}\n\n \n\nstatic irqreturn_t ei_irq_wrapper(int irq, void *dev_id)\n{\n    struct net_device *dev = dev_id;\n    struct pcnet_dev *info;\n    irqreturn_t ret = ei_interrupt(irq, dev_id);\n\n    if (ret == IRQ_HANDLED) {\n\t    info = PRIV(dev);\n\t    info->stale = 0;\n    }\n    return ret;\n}\n\nstatic void ei_watchdog(struct timer_list *t)\n{\n    struct pcnet_dev *info = from_timer(info, t, watchdog);\n    struct net_device *dev = info->p_dev->priv;\n    unsigned int nic_base = dev->base_addr;\n    unsigned int mii_addr = nic_base + DLINK_GPIO;\n    u_short link;\n\n    if (!netif_device_present(dev)) goto reschedule;\n\n     \n    if (info->stale++ && (inb_p(nic_base + EN0_ISR) & ENISR_ALL)) {\n\tif (!info->fast_poll)\n\t    netdev_info(dev, \"interrupt(s) dropped!\\n\");\n\tei_irq_wrapper(dev->irq, dev);\n\tinfo->fast_poll = HZ;\n    }\n    if (info->fast_poll) {\n\tinfo->fast_poll--;\n\tinfo->watchdog.expires = jiffies + 1;\n\tadd_timer(&info->watchdog);\n\treturn;\n    }\n\n    if (!(info->flags & HAS_MII))\n\tgoto reschedule;\n\n    mdio_read(mii_addr, info->phy_id, 1);\n    link = mdio_read(mii_addr, info->phy_id, 1);\n    if (!link || (link == 0xffff)) {\n\tif (info->eth_phy) {\n\t    info->phy_id = info->eth_phy = 0;\n\t} else {\n\t    netdev_info(dev, \"MII is missing!\\n\");\n\t    info->flags &= ~HAS_MII;\n\t}\n\tgoto reschedule;\n    }\n\n    link &= 0x0004;\n    if (link != info->link_status) {\n\tu_short p = mdio_read(mii_addr, info->phy_id, 5);\n\tnetdev_info(dev, \"%s link beat\\n\", link ? \"found\" : \"lost\");\n\tif (link && (info->flags & IS_DL10022)) {\n\t     \n\t    outb((p & 0x0140) ? 4 : 0, nic_base + DLINK_DIAG);\n\t} else if (link && (info->flags & IS_DL10019)) {\n\t     \n\t    write_asic(dev->base_addr, 4, (p & 0x140) ? DL19FDUPLX : 0);\n\t}\n\tif (link) {\n\t    if (info->phy_id == info->eth_phy) {\n\t\tif (p)\n\t\t    netdev_info(dev, \"autonegotiation complete: \"\n\t\t\t\t\"%sbaseT-%cD selected\\n\",\n\t\t\t\t((p & 0x0180) ? \"100\" : \"10\"),\n\t\t\t\t((p & 0x0140) ? 'F' : 'H'));\n\t\telse\n\t\t    netdev_info(dev, \"link partner did not autonegotiate\\n\");\n\t    }\n\t    NS8390_init(dev, 1);\n\t}\n\tinfo->link_status = link;\n    }\n    if (info->pna_phy && time_after(jiffies, info->mii_reset + 6*HZ)) {\n\tlink = mdio_read(mii_addr, info->eth_phy, 1) & 0x0004;\n\tif (((info->phy_id == info->pna_phy) && link) ||\n\t    ((info->phy_id != info->pna_phy) && !link)) {\n\t     \n\t    mdio_write(mii_addr, info->phy_id, 0, 0x0400);\n\t    info->phy_id ^= info->pna_phy ^ info->eth_phy;\n\t    netdev_info(dev, \"switched to %s transceiver\\n\",\n\t\t\t(info->phy_id == info->eth_phy) ? \"ethernet\" : \"PNA\");\n\t    mdio_write(mii_addr, info->phy_id, 0,\n\t\t       (info->phy_id == info->eth_phy) ? 0x1000 : 0);\n\t    info->link_status = 0;\n\t    info->mii_reset = jiffies;\n\t}\n    }\n\nreschedule:\n    info->watchdog.expires = jiffies + HZ;\n    add_timer(&info->watchdog);\n}\n\n \n\n\nstatic int ei_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)\n{\n    struct pcnet_dev *info = PRIV(dev);\n    struct mii_ioctl_data *data = if_mii(rq);\n    unsigned int mii_addr = dev->base_addr + DLINK_GPIO;\n\n    if (!(info->flags & (IS_DL10019|IS_DL10022)))\n\treturn -EINVAL;\n\n    switch (cmd) {\n    case SIOCGMIIPHY:\n\tdata->phy_id = info->phy_id;\n\tfallthrough;\n    case SIOCGMIIREG:\t\t \n\tdata->val_out = mdio_read(mii_addr, data->phy_id, data->reg_num & 0x1f);\n\treturn 0;\n    case SIOCSMIIREG:\t\t \n\tmdio_write(mii_addr, data->phy_id, data->reg_num & 0x1f, data->val_in);\n\treturn 0;\n    }\n    return -EOPNOTSUPP;\n}\n\n \n\nstatic void dma_get_8390_hdr(struct net_device *dev,\n\t\t\t     struct e8390_pkt_hdr *hdr,\n\t\t\t     int ring_page)\n{\n    unsigned int nic_base = dev->base_addr;\n\n    if (ei_status.dmaing) {\n\tnetdev_err(dev, \"DMAing conflict in dma_block_input.\"\n\t\t   \"[DMAstat:%1x][irqlock:%1x]\\n\",\n\t\t   ei_status.dmaing, ei_status.irqlock);\n\treturn;\n    }\n\n    ei_status.dmaing |= 0x01;\n    outb_p(E8390_NODMA+E8390_PAGE0+E8390_START, nic_base + PCNET_CMD);\n    outb_p(sizeof(struct e8390_pkt_hdr), nic_base + EN0_RCNTLO);\n    outb_p(0, nic_base + EN0_RCNTHI);\n    outb_p(0, nic_base + EN0_RSARLO);\t\t \n    outb_p(ring_page, nic_base + EN0_RSARHI);\n    outb_p(E8390_RREAD+E8390_START, nic_base + PCNET_CMD);\n\n    insw(nic_base + PCNET_DATAPORT, hdr,\n\t    sizeof(struct e8390_pkt_hdr)>>1);\n     \n    hdr->count = le16_to_cpu(hdr->count);\n\n    outb_p(ENISR_RDC, nic_base + EN0_ISR);\t \n    ei_status.dmaing &= ~0x01;\n}\n\n \n\nstatic void dma_block_input(struct net_device *dev, int count,\n\t\t\t    struct sk_buff *skb, int ring_offset)\n{\n    unsigned int nic_base = dev->base_addr;\n    int xfer_count = count;\n    char *buf = skb->data;\n    struct ei_device *ei_local = netdev_priv(dev);\n\n    if ((netif_msg_rx_status(ei_local)) && (count != 4))\n\tnetdev_dbg(dev, \"[bi=%d]\\n\", count+4);\n    if (ei_status.dmaing) {\n\tnetdev_err(dev, \"DMAing conflict in dma_block_input.\"\n\t\t   \"[DMAstat:%1x][irqlock:%1x]\\n\",\n\t\t   ei_status.dmaing, ei_status.irqlock);\n\treturn;\n    }\n    ei_status.dmaing |= 0x01;\n    outb_p(E8390_NODMA+E8390_PAGE0+E8390_START, nic_base + PCNET_CMD);\n    outb_p(count & 0xff, nic_base + EN0_RCNTLO);\n    outb_p(count >> 8, nic_base + EN0_RCNTHI);\n    outb_p(ring_offset & 0xff, nic_base + EN0_RSARLO);\n    outb_p(ring_offset >> 8, nic_base + EN0_RSARHI);\n    outb_p(E8390_RREAD+E8390_START, nic_base + PCNET_CMD);\n\n    insw(nic_base + PCNET_DATAPORT,buf,count>>1);\n    if (count & 0x01) {\n\tbuf[count-1] = inb(nic_base + PCNET_DATAPORT);\n\txfer_count++;\n    }\n\n     \n#ifdef PCMCIA_DEBUG\n       \n    if (netif_msg_rx_status(ei_local)) {\n\tint addr, tries = 20;\n\tdo {\n\t     \n\t    int high = inb_p(nic_base + EN0_RSARHI);\n\t    int low = inb_p(nic_base + EN0_RSARLO);\n\t    addr = (high << 8) + low;\n\t    if (((ring_offset + xfer_count) & 0xff) == (addr & 0xff))\n\t\tbreak;\n\t} while (--tries > 0);\n\tif (tries <= 0)\n\t    netdev_notice(dev, \"RX transfer address mismatch,\"\n\t\t\t  \"%#4.4x (expected) vs. %#4.4x (actual).\\n\",\n\t\t\t  ring_offset + xfer_count, addr);\n    }\n#endif\n    outb_p(ENISR_RDC, nic_base + EN0_ISR);\t \n    ei_status.dmaing &= ~0x01;\n}  \n\n \n\nstatic void dma_block_output(struct net_device *dev, int count,\n\t\t\t     const u_char *buf, const int start_page)\n{\n    unsigned int nic_base = dev->base_addr;\n    struct pcnet_dev *info = PRIV(dev);\n#ifdef PCMCIA_DEBUG\n    int retries = 0;\n    struct ei_device *ei_local = netdev_priv(dev);\n#endif\n    u_long dma_start;\n\n#ifdef PCMCIA_DEBUG\n    netif_dbg(ei_local, tx_queued, dev, \"[bo=%d]\\n\", count);\n#endif\n\n     \n    if (count & 0x01)\n\tcount++;\n    if (ei_status.dmaing) {\n\tnetdev_err(dev, \"DMAing conflict in dma_block_output.\"\n\t\t   \"[DMAstat:%1x][irqlock:%1x]\\n\",\n\t\t   ei_status.dmaing, ei_status.irqlock);\n\treturn;\n    }\n    ei_status.dmaing |= 0x01;\n     \n    outb_p(E8390_PAGE0+E8390_START+E8390_NODMA, nic_base+PCNET_CMD);\n\n#ifdef PCMCIA_DEBUG\n  retry:\n#endif\n\n    outb_p(ENISR_RDC, nic_base + EN0_ISR);\n\n     \n    outb_p(count & 0xff, nic_base + EN0_RCNTLO);\n    outb_p(count >> 8,   nic_base + EN0_RCNTHI);\n    outb_p(0x00, nic_base + EN0_RSARLO);\n    outb_p(start_page, nic_base + EN0_RSARHI);\n\n    outb_p(E8390_RWRITE+E8390_START, nic_base + PCNET_CMD);\n    outsw(nic_base + PCNET_DATAPORT, buf, count>>1);\n\n    dma_start = jiffies;\n\n#ifdef PCMCIA_DEBUG\n     \n     \n    if (netif_msg_tx_queued(ei_local)) {\n\tint addr, tries = 20;\n\tdo {\n\t    int high = inb_p(nic_base + EN0_RSARHI);\n\t    int low = inb_p(nic_base + EN0_RSARLO);\n\t    addr = (high << 8) + low;\n\t    if ((start_page << 8) + count == addr)\n\t\tbreak;\n\t} while (--tries > 0);\n\tif (tries <= 0) {\n\t    netdev_notice(dev, \"Tx packet transfer address mismatch,\"\n\t\t\t  \"%#4.4x (expected) vs. %#4.4x (actual).\\n\",\n\t\t\t  (start_page << 8) + count, addr);\n\t    if (retries++ == 0)\n\t\tgoto retry;\n\t}\n    }\n#endif\n\n    while ((inb_p(nic_base + EN0_ISR) & ENISR_RDC) == 0)\n\tif (time_after(jiffies, dma_start + PCNET_RDC_TIMEOUT)) {\n\t\tnetdev_warn(dev, \"timeout waiting for Tx RDC.\\n\");\n\t\tpcnet_reset_8390(dev);\n\t\tNS8390_init(dev, 1);\n\t\tbreak;\n\t}\n\n    outb_p(ENISR_RDC, nic_base + EN0_ISR);\t \n    if (info->flags & DELAY_OUTPUT)\n\tudelay((long)delay_time);\n    ei_status.dmaing &= ~0x01;\n}\n\n \n\nstatic int setup_dma_config(struct pcmcia_device *link, int start_pg,\n\t\t\t    int stop_pg)\n{\n    struct net_device *dev = link->priv;\n\n    ei_status.tx_start_page = start_pg;\n    ei_status.rx_start_page = start_pg + TX_PAGES;\n    ei_status.stop_page = stop_pg;\n\n     \n    ei_status.get_8390_hdr = dma_get_8390_hdr;\n    ei_status.block_input = dma_block_input;\n    ei_status.block_output = dma_block_output;\n\n    return 0;\n}\n\n \n\nstatic void copyin(void *dest, void __iomem *src, int c)\n{\n    u_short *d = dest;\n    u_short __iomem *s = src;\n    int odd;\n\n    if (c <= 0)\n\treturn;\n    odd = (c & 1); c >>= 1;\n\n    if (c) {\n\tdo { *d++ = __raw_readw(s++); } while (--c);\n    }\n     \n    if (odd)\n\t*((u_char *)d) = readw(s) & 0xff;\n}\n\nstatic void copyout(void __iomem *dest, const void *src, int c)\n{\n    u_short __iomem *d = dest;\n    const u_short *s = src;\n    int odd;\n\n    if (c <= 0)\n\treturn;\n    odd = (c & 1); c >>= 1;\n\n    if (c) {\n\tdo { __raw_writew(*s++, d++); } while (--c);\n    }\n     \n    if (odd)\n\twritew((readw(d) & 0xff00) | *(u_char *)s, d);\n}\n\n \n\nstatic void shmem_get_8390_hdr(struct net_device *dev,\n\t\t\t       struct e8390_pkt_hdr *hdr,\n\t\t\t       int ring_page)\n{\n    void __iomem *xfer_start = ei_status.mem + (TX_PAGES<<8)\n\t\t\t\t+ (ring_page << 8)\n\t\t\t\t- (ei_status.rx_start_page << 8);\n\n    copyin(hdr, xfer_start, sizeof(struct e8390_pkt_hdr));\n     \n    hdr->count = le16_to_cpu(hdr->count);\n}\n\n \n\nstatic void shmem_block_input(struct net_device *dev, int count,\n\t\t\t      struct sk_buff *skb, int ring_offset)\n{\n    void __iomem *base = ei_status.mem;\n    unsigned long offset = (TX_PAGES<<8) + ring_offset\n\t\t\t\t- (ei_status.rx_start_page << 8);\n    char *buf = skb->data;\n\n    if (offset + count > ei_status.priv) {\n\t \n\tint semi_count = ei_status.priv - offset;\n\tcopyin(buf, base + offset, semi_count);\n\tbuf += semi_count;\n\toffset = TX_PAGES<<8;\n\tcount -= semi_count;\n    }\n    copyin(buf, base + offset, count);\n}\n\n \n\nstatic void shmem_block_output(struct net_device *dev, int count,\n\t\t\t       const u_char *buf, const int start_page)\n{\n    void __iomem *shmem = ei_status.mem + (start_page << 8);\n    shmem -= ei_status.tx_start_page << 8;\n    copyout(shmem, buf, count);\n}\n\n \n\nstatic int setup_shmem_window(struct pcmcia_device *link, int start_pg,\n\t\t\t      int stop_pg, int cm_offset)\n{\n    struct net_device *dev = link->priv;\n    struct pcnet_dev *info = PRIV(dev);\n    int i, window_size, offset, ret;\n\n    window_size = (stop_pg - start_pg) << 8;\n    if (window_size > 32 * 1024)\n\twindow_size = 32 * 1024;\n\n     \n    window_size = roundup_pow_of_two(window_size);\n\n     \n    link->resource[3]->flags |= WIN_DATA_WIDTH_16|WIN_MEMORY_TYPE_CM|WIN_ENABLE;\n    link->resource[3]->flags |= WIN_USE_WAIT;\n    link->resource[3]->start = 0; link->resource[3]->end = window_size;\n    ret = pcmcia_request_window(link, link->resource[3], mem_speed);\n    if (ret)\n\t    goto failed;\n\n    offset = (start_pg << 8) + cm_offset;\n    offset -= offset % window_size;\n    ret = pcmcia_map_mem_page(link, link->resource[3], offset);\n    if (ret)\n\t    goto failed;\n\n     \n    info->base = ioremap(link->resource[3]->start,\n\t\t\tresource_size(link->resource[3]));\n    if (unlikely(!info->base)) {\n\t    ret = -ENOMEM;\n\t    goto failed;\n    }\n\n    for (i = 0; i < (TX_PAGES<<8); i += 2)\n\t__raw_writew((i>>1), info->base+offset+i);\n    udelay(100);\n    for (i = 0; i < (TX_PAGES<<8); i += 2)\n\tif (__raw_readw(info->base+offset+i) != (i>>1)) break;\n    pcnet_reset_8390(dev);\n    if (i != (TX_PAGES<<8)) {\n\tiounmap(info->base);\n\tpcmcia_release_window(link, link->resource[3]);\n\tinfo->base = NULL;\n\tgoto failed;\n    }\n\n    ei_status.mem = info->base + offset;\n    ei_status.priv = resource_size(link->resource[3]);\n    dev->mem_start = (u_long)ei_status.mem;\n    dev->mem_end = dev->mem_start + resource_size(link->resource[3]);\n\n    ei_status.tx_start_page = start_pg;\n    ei_status.rx_start_page = start_pg + TX_PAGES;\n    ei_status.stop_page = start_pg + (\n\t    (resource_size(link->resource[3]) - offset) >> 8);\n\n     \n    ei_status.get_8390_hdr = shmem_get_8390_hdr;\n    ei_status.block_input = shmem_block_input;\n    ei_status.block_output = shmem_block_output;\n\n    info->flags |= USE_SHMEM;\n    return 0;\n\nfailed:\n    return 1;\n}\n\n \n\nstatic const struct pcmcia_device_id pcnet_ids[] = {\n\tPCMCIA_PFC_DEVICE_MANF_CARD(0, 0x0057, 0x0021),\n\tPCMCIA_PFC_DEVICE_MANF_CARD(0, 0x0104, 0x000a),\n\tPCMCIA_PFC_DEVICE_MANF_CARD(0, 0x0105, 0xea15),\n\tPCMCIA_PFC_DEVICE_MANF_CARD(0, 0x0143, 0x3341),\n\tPCMCIA_PFC_DEVICE_MANF_CARD(0, 0x0143, 0xc0ab),\n\tPCMCIA_PFC_DEVICE_MANF_CARD(0, 0x021b, 0x0101),\n\tPCMCIA_PFC_DEVICE_MANF_CARD(0, 0x08a1, 0xc0ab),\n\tPCMCIA_PFC_DEVICE_PROD_ID12(0, \"AnyCom\", \"Fast Ethernet + 56K COMBO\", 0x578ba6e7, 0xb0ac62c4),\n\tPCMCIA_PFC_DEVICE_PROD_ID12(0, \"ATKK\", \"LM33-PCM-T\", 0xba9eb7e2, 0x077c174e),\n\tPCMCIA_PFC_DEVICE_PROD_ID12(0, \"D-Link\", \"DME336T\", 0x1a424a1c, 0xb23897ff),\n\tPCMCIA_PFC_DEVICE_PROD_ID12(0, \"Grey Cell\", \"GCS3000\", 0x2a151fac, 0x48b932ae),\n\tPCMCIA_PFC_DEVICE_PROD_ID12(0, \"Linksys\", \"EtherFast 10&100 + 56K PC Card (PCMLM56)\", 0x0733cc81, 0xb3765033),\n\tPCMCIA_PFC_DEVICE_PROD_ID12(0, \"LINKSYS\", \"PCMLM336\", 0xf7cb0b07, 0x7a821b58),\n\tPCMCIA_PFC_DEVICE_PROD_ID12(0, \"MICRO RESEARCH\", \"COMBO-L/M-336\", 0xb2ced065, 0x3ced0555),\n\tPCMCIA_PFC_DEVICE_PROD_ID12(0, \"PCMCIAs\", \"ComboCard\", 0xdcfe12d3, 0xcd8906cc),\n\tPCMCIA_PFC_DEVICE_PROD_ID12(0, \"PCMCIAs\", \"LanModem\", 0xdcfe12d3, 0xc67c648f),\n\tPCMCIA_MFC_DEVICE_PROD_ID12(0, \"IBM\", \"Home and Away 28.8 PC Card       \", 0xb569a6e5, 0x5bd4ff2c),\n\tPCMCIA_MFC_DEVICE_PROD_ID12(0, \"IBM\", \"Home and Away Credit Card Adapter\", 0xb569a6e5, 0x4bdf15c3),\n\tPCMCIA_MFC_DEVICE_PROD_ID12(0, \"IBM\", \"w95 Home and Away Credit Card \", 0xb569a6e5, 0xae911c15),\n\tPCMCIA_MFC_DEVICE_PROD_ID123(0, \"APEX DATA\", \"MULTICARD\", \"ETHERNET-MODEM\", 0x11c2da09, 0x7289dc5d, 0xaad95e1f),\n\tPCMCIA_MFC_DEVICE_PROD_ID2(0, \"FAX/Modem/Ethernet Combo Card \", 0x1ed59302),\n\tPCMCIA_DEVICE_MANF_CARD(0x0057, 0x1004),\n\tPCMCIA_DEVICE_MANF_CARD(0x0104, 0x000d),\n\tPCMCIA_DEVICE_MANF_CARD(0x0104, 0x0075),\n\tPCMCIA_DEVICE_MANF_CARD(0x0104, 0x0145),\n\tPCMCIA_DEVICE_MANF_CARD(0x0149, 0x0230),\n\tPCMCIA_DEVICE_MANF_CARD(0x0149, 0x4530),\n\tPCMCIA_DEVICE_MANF_CARD(0x0149, 0xc1ab),\n\tPCMCIA_DEVICE_MANF_CARD(0x0186, 0x0110),\n\tPCMCIA_DEVICE_MANF_CARD(0x01bf, 0x8041),\n\tPCMCIA_DEVICE_MANF_CARD(0x0213, 0x2452),\n\tPCMCIA_DEVICE_MANF_CARD(0x026f, 0x0300),\n\tPCMCIA_DEVICE_MANF_CARD(0x026f, 0x0307),\n\tPCMCIA_DEVICE_MANF_CARD(0x026f, 0x030a),\n\tPCMCIA_DEVICE_MANF_CARD(0x0274, 0x1103),\n\tPCMCIA_DEVICE_MANF_CARD(0x0274, 0x1121),\n\tPCMCIA_DEVICE_MANF_CARD(0xc001, 0x0009),\n\tPCMCIA_DEVICE_PROD_ID12(\"2408LAN\", \"Ethernet\", 0x352fff7f, 0x00b2e941),\n\tPCMCIA_DEVICE_PROD_ID1234(\"Socket\", \"CF 10/100 Ethernet Card\", \"Revision B\", \"05/11/06\", 0xb38bcc2e, 0x4de88352, 0xeaca6c8d, 0x7e57c22e),\n\tPCMCIA_DEVICE_PROD_ID123(\"Cardwell\", \"PCMCIA\", \"ETHERNET\", 0x9533672e, 0x281f1c5d, 0x3ff7175b),\n\tPCMCIA_DEVICE_PROD_ID123(\"CNet  \", \"CN30BC\", \"ETHERNET\", 0x9fe55d3d, 0x85601198, 0x3ff7175b),\n\tPCMCIA_DEVICE_PROD_ID123(\"Digital\", \"Ethernet\", \"Adapter\", 0x9999ab35, 0x00b2e941, 0x4b0d829e),\n\tPCMCIA_DEVICE_PROD_ID123(\"Edimax Technology Inc.\", \"PCMCIA\", \"Ethernet Card\", 0x738a0019, 0x281f1c5d, 0x5e9d92c0),\n\tPCMCIA_DEVICE_PROD_ID123(\"EFA   \", \"EFA207\", \"ETHERNET\", 0x3d294be4, 0xeb9aab6c, 0x3ff7175b),\n\tPCMCIA_DEVICE_PROD_ID123(\"I-O DATA\", \"PCLA\", \"ETHERNET\", 0x1d55d7ec, 0xe4c64d34, 0x3ff7175b),\n\tPCMCIA_DEVICE_PROD_ID123(\"IO DATA\", \"PCLATE\", \"ETHERNET\", 0x547e66dc, 0x6b260753, 0x3ff7175b),\n\tPCMCIA_DEVICE_PROD_ID123(\"KingMax Technology Inc.\", \"EN10-T2\", \"PCMCIA Ethernet Card\", 0x932b7189, 0x699e4436, 0x6f6652e0),\n\tPCMCIA_DEVICE_PROD_ID123(\"PCMCIA\", \"PCMCIA-ETHERNET-CARD\", \"UE2216\", 0x281f1c5d, 0xd4cd2f20, 0xb87add82),\n\tPCMCIA_DEVICE_PROD_ID123(\"PCMCIA\", \"PCMCIA-ETHERNET-CARD\", \"UE2620\", 0x281f1c5d, 0xd4cd2f20, 0x7d3d83a8),\n\tPCMCIA_DEVICE_PROD_ID1(\"2412LAN\", 0x67f236ab),\n\tPCMCIA_DEVICE_PROD_ID12(\"ACCTON\", \"EN2212\", 0xdfc6b5b2, 0xcb112a11),\n\tPCMCIA_DEVICE_PROD_ID12(\"ACCTON\", \"EN2216-PCMCIA-ETHERNET\", 0xdfc6b5b2, 0x5542bfff),\n\tPCMCIA_DEVICE_PROD_ID12(\"Allied Telesis, K.K.\", \"CentreCOM LA100-PCM-T V2 100/10M LAN PC Card\", 0xbb7fbdd7, 0xcd91cc68),\n\tPCMCIA_DEVICE_PROD_ID12(\"Allied Telesis K.K.\", \"LA100-PCM V2\", 0x36634a66, 0xc6d05997),\n\tPCMCIA_DEVICE_PROD_ID12(\"Allied Telesis, K.K.\", \"CentreCOM LA-PCM_V2\", 0xbb7fBdd7, 0x28e299f8),\n\tPCMCIA_DEVICE_PROD_ID12(\"Allied Telesis K.K.\", \"LA-PCM V3\", 0x36634a66, 0x62241d96),\n\tPCMCIA_DEVICE_PROD_ID12(\"AmbiCom\", \"AMB8010\", 0x5070a7f9, 0x82f96e96),\n\tPCMCIA_DEVICE_PROD_ID12(\"AmbiCom\", \"AMB8610\", 0x5070a7f9, 0x86741224),\n\tPCMCIA_DEVICE_PROD_ID12(\"AmbiCom Inc\", \"AMB8002\", 0x93b15570, 0x75ec3efb),\n\tPCMCIA_DEVICE_PROD_ID12(\"AmbiCom Inc\", \"AMB8002T\", 0x93b15570, 0x461c5247),\n\tPCMCIA_DEVICE_PROD_ID12(\"AmbiCom Inc\", \"AMB8010\", 0x93b15570, 0x82f96e96),\n\tPCMCIA_DEVICE_PROD_ID12(\"AnyCom\", \"ECO Ethernet\", 0x578ba6e7, 0x0a9888c1),\n\tPCMCIA_DEVICE_PROD_ID12(\"AnyCom\", \"ECO Ethernet 10/100\", 0x578ba6e7, 0x939fedbd),\n\tPCMCIA_DEVICE_PROD_ID12(\"AROWANA\", \"PCMCIA Ethernet LAN Card\", 0x313adbc8, 0x08d9f190),\n\tPCMCIA_DEVICE_PROD_ID12(\"ASANTE\", \"FriendlyNet PC Card\", 0x3a7ade0f, 0x41c64504),\n\tPCMCIA_DEVICE_PROD_ID12(\"Billionton\", \"LNT-10TB\", 0x552ab682, 0xeeb1ba6a),\n\tPCMCIA_DEVICE_PROD_ID12(\"CF\", \"10Base-Ethernet\", 0x44ebf863, 0x93ae4d79),\n\tPCMCIA_DEVICE_PROD_ID12(\"CNet\", \"CN40BC Ethernet\", 0xbc477dde, 0xfba775a7),\n\tPCMCIA_DEVICE_PROD_ID12(\"COMPU-SHACK\", \"BASEline PCMCIA 10 MBit Ethernetadapter\", 0xfa2e424d, 0xe9190d8a),\n\tPCMCIA_DEVICE_PROD_ID12(\"COMPU-SHACK\", \"FASTline PCMCIA 10/100 Fast-Ethernet\", 0xfa2e424d, 0x3953d9b9),\n\tPCMCIA_DEVICE_PROD_ID12(\"CONTEC\", \"C-NET(PC)C-10L\", 0x21cab552, 0xf6f90722),\n\tPCMCIA_DEVICE_PROD_ID12(\"corega\", \"FEther PCC-TXF\", 0x0a21501a, 0xa51564a2),\n\tPCMCIA_DEVICE_PROD_ID12(\"corega\", \"Ether CF-TD\", 0x0a21501a, 0x6589340a),\n\tPCMCIA_DEVICE_PROD_ID12(\"corega K.K.\", \"corega Ether CF-TD LAN Card\", 0x5261440f, 0x8797663b),\n\tPCMCIA_DEVICE_PROD_ID12(\"corega K.K.\", \"corega EtherII PCC-T\", 0x5261440f, 0xfa9d85bd),\n\tPCMCIA_DEVICE_PROD_ID12(\"corega K.K.\", \"corega EtherII PCC-TD\", 0x5261440f, 0xc49bd73d),\n\tPCMCIA_DEVICE_PROD_ID12(\"Corega K.K.\", \"corega EtherII PCC-TD\", 0xd4fdcbd8, 0xc49bd73d),\n\tPCMCIA_DEVICE_PROD_ID12(\"corega K.K.\", \"corega Ether PCC-T\", 0x5261440f, 0x6705fcaa),\n\tPCMCIA_DEVICE_PROD_ID12(\"corega K.K.\", \"corega Ether PCC-TD\", 0x5261440f, 0x47d5ca83),\n\tPCMCIA_DEVICE_PROD_ID12(\"corega K.K.\", \"corega FastEther PCC-TX\", 0x5261440f, 0x485e85d9),\n\tPCMCIA_DEVICE_PROD_ID12(\"Corega,K.K.\", \"Ethernet LAN Card\", 0x110d26d9, 0x9fd2f0a2),\n\tPCMCIA_DEVICE_PROD_ID12(\"corega,K.K.\", \"Ethernet LAN Card\", 0x9791a90e, 0x9fd2f0a2),\n\tPCMCIA_DEVICE_PROD_ID12(\"corega K.K.\", \"(CG-LAPCCTXD)\", 0x5261440f, 0x73ec0d88),\n\tPCMCIA_DEVICE_PROD_ID12(\"CouplerlessPCMCIA\", \"100BASE\", 0xee5af0ad, 0x7c2add04),\n\tPCMCIA_DEVICE_PROD_ID12(\"CyQ've\", \"ELA-010\", 0x77008979, 0x9d8d445d),\n\tPCMCIA_DEVICE_PROD_ID12(\"CyQ've\", \"ELA-110E 10/100M LAN Card\", 0x77008979, 0xfd184814),\n\tPCMCIA_DEVICE_PROD_ID12(\"DataTrek.\", \"NetCard \", 0x5cd66d9d, 0x84697ce0),\n\tPCMCIA_DEVICE_PROD_ID12(\"Dayna Communications, Inc.\", \"CommuniCard E\", 0x0c629325, 0xb4e7dbaf),\n\tPCMCIA_DEVICE_PROD_ID12(\"Digicom\", \"Palladio LAN 10/100\", 0x697403d8, 0xe160b995),\n\tPCMCIA_DEVICE_PROD_ID12(\"Digicom\", \"Palladio LAN 10/100 Dongless\", 0x697403d8, 0xa6d3b233),\n\tPCMCIA_DEVICE_PROD_ID12(\"DIGITAL\", \"DEPCM-XX\", 0x69616cb3, 0xe600e76e),\n\tPCMCIA_DEVICE_PROD_ID12(\"D-Link\", \"DE-650\", 0x1a424a1c, 0xf28c8398),\n\tPCMCIA_DEVICE_PROD_ID12(\"D-Link\", \"DE-660\", 0x1a424a1c, 0xd9a1d05b),\n\tPCMCIA_DEVICE_PROD_ID12(\"D-Link\", \"DE-660+\", 0x1a424a1c, 0x50dcd0ec),\n\tPCMCIA_DEVICE_PROD_ID12(\"D-Link\", \"DFE-650\", 0x1a424a1c, 0x0f0073f9),\n\tPCMCIA_DEVICE_PROD_ID12(\"Dual Speed\", \"10/100 PC Card\", 0x725b842d, 0xf1efee84),\n\tPCMCIA_DEVICE_PROD_ID12(\"Dual Speed\", \"10/100 Port Attached PC Card\", 0x725b842d, 0x2db1f8e9),\n\tPCMCIA_DEVICE_PROD_ID12(\"Dynalink\", \"L10BC\", 0x55632fd5, 0xdc65f2b1),\n\tPCMCIA_DEVICE_PROD_ID12(\"DYNALINK\", \"L10BC\", 0x6a26d1cf, 0xdc65f2b1),\n\tPCMCIA_DEVICE_PROD_ID12(\"DYNALINK\", \"L10C\", 0x6a26d1cf, 0xc4f84efb),\n\tPCMCIA_DEVICE_PROD_ID12(\"E-CARD\", \"E-CARD\", 0x6701da11, 0x6701da11),\n\tPCMCIA_DEVICE_PROD_ID12(\"EIGER Labs Inc.\", \"Ethernet 10BaseT card\", 0x53c864c6, 0xedd059f6),\n\tPCMCIA_DEVICE_PROD_ID12(\"EIGER Labs Inc.\", \"Ethernet Combo card\", 0x53c864c6, 0x929c486c),\n\tPCMCIA_DEVICE_PROD_ID12(\"Ethernet\", \"Adapter\", 0x00b2e941, 0x4b0d829e),\n\tPCMCIA_DEVICE_PROD_ID12(\"Ethernet Adapter\", \"E2000 PCMCIA Ethernet\", 0x96767301, 0x71fbbc61),\n\tPCMCIA_DEVICE_PROD_ID12(\"Ethernet PCMCIA adapter\", \"EP-210\", 0x8dd86181, 0xf2b52517),\n\tPCMCIA_DEVICE_PROD_ID12(\"Fast Ethernet\", \"Adapter\", 0xb4be14e3, 0x4b0d829e),\n\tPCMCIA_DEVICE_PROD_ID12(\"Grey Cell\", \"GCS2000\", 0x2a151fac, 0xf00555cb),\n\tPCMCIA_DEVICE_PROD_ID12(\"Grey Cell\", \"GCS2220\", 0x2a151fac, 0xc1b7e327),\n\tPCMCIA_DEVICE_PROD_ID12(\"GVC\", \"NIC-2000p\", 0x76e171bd, 0x6eb1c947),\n\tPCMCIA_DEVICE_PROD_ID12(\"IBM Corp.\", \"Ethernet\", 0xe3736c88, 0x00b2e941),\n\tPCMCIA_DEVICE_PROD_ID12(\"IC-CARD\", \"IC-CARD\", 0x60cb09a6, 0x60cb09a6),\n\tPCMCIA_DEVICE_PROD_ID12(\"IC-CARD+\", \"IC-CARD+\", 0x93693494, 0x93693494),\n\tPCMCIA_DEVICE_PROD_ID12(\"IO DATA\", \"PCETTX\", 0x547e66dc, 0x6fc5459b),\n\tPCMCIA_DEVICE_PROD_ID12(\"iPort\", \"10/100 Ethernet Card\", 0x56c538d2, 0x11b0ffc0),\n\tPCMCIA_DEVICE_PROD_ID12(\"KANSAI ELECTRIC CO.,LTD\", \"KLA-PCM/T\", 0xb18dc3b4, 0xcc51a956),\n\tPCMCIA_DEVICE_PROD_ID12(\"KENTRONICS\", \"KEP-230\", 0xaf8144c9, 0x868f6616),\n\tPCMCIA_DEVICE_PROD_ID12(\"KCI\", \"PE520 PCMCIA Ethernet Adapter\", 0xa89b87d3, 0x1eb88e64),\n\tPCMCIA_DEVICE_PROD_ID12(\"KINGMAX\", \"EN10T2T\", 0x7bcb459a, 0xa5c81fa5),\n\tPCMCIA_DEVICE_PROD_ID12(\"Kingston\", \"KNE-PC2\", 0x1128e633, 0xce2a89b3),\n\tPCMCIA_DEVICE_PROD_ID12(\"Kingston Technology Corp.\", \"EtheRx PC Card Ethernet Adapter\", 0x313c7be3, 0x0afb54a2),\n\tPCMCIA_DEVICE_PROD_ID12(\"Laneed\", \"LD-10/100CD\", 0x1b7827b2, 0xcda71d1c),\n\tPCMCIA_DEVICE_PROD_ID12(\"Laneed\", \"LD-CDF\", 0x1b7827b2, 0xfec71e40),\n\tPCMCIA_DEVICE_PROD_ID12(\"Laneed\", \"LD-CDL/T\", 0x1b7827b2, 0x79fba4f7),\n\tPCMCIA_DEVICE_PROD_ID12(\"Laneed\", \"LD-CDS\", 0x1b7827b2, 0x931afaab),\n\tPCMCIA_DEVICE_PROD_ID12(\"LEMEL\", \"LM-N89TX PRO\", 0xbbefb52f, 0xd2897a97),\n\tPCMCIA_DEVICE_PROD_ID12(\"Linksys\", \"Combo PCMCIA EthernetCard (EC2T)\", 0x0733cc81, 0x32ee8c78),\n\tPCMCIA_DEVICE_PROD_ID12(\"LINKSYS\", \"E-CARD\", 0xf7cb0b07, 0x6701da11),\n\tPCMCIA_DEVICE_PROD_ID12(\"Linksys\", \"EtherFast 10/100 Integrated PC Card (PCM100)\", 0x0733cc81, 0x453c3f9d),\n\tPCMCIA_DEVICE_PROD_ID12(\"Linksys\", \"EtherFast 10/100 PC Card (PCMPC100)\", 0x0733cc81, 0x66c5a389),\n\tPCMCIA_DEVICE_PROD_ID12(\"Linksys\", \"EtherFast 10/100 PC Card (PCMPC100 V2)\", 0x0733cc81, 0x3a3b28e9),\n\tPCMCIA_DEVICE_PROD_ID12(\"Linksys\", \"HomeLink Phoneline + 10/100 Network PC Card (PCM100H1)\", 0x733cc81, 0x7a3e5c3a),\n\tPCMCIA_DEVICE_PROD_ID12(\"Logitec\", \"LPM-LN100TX\", 0x88fcdeda, 0x6d772737),\n\tPCMCIA_DEVICE_PROD_ID12(\"Logitec\", \"LPM-LN100TE\", 0x88fcdeda, 0x0e714bee),\n\tPCMCIA_DEVICE_PROD_ID12(\"Logitec\", \"LPM-LN20T\", 0x88fcdeda, 0x81090922),\n\tPCMCIA_DEVICE_PROD_ID12(\"Logitec\", \"LPM-LN10TE\", 0x88fcdeda, 0xc1e2521c),\n\tPCMCIA_DEVICE_PROD_ID12(\"LONGSHINE\", \"PCMCIA Ethernet Card\", 0xf866b0b0, 0x6f6652e0),\n\tPCMCIA_DEVICE_PROD_ID12(\"MACNICA\", \"ME1-JEIDA\", 0x20841b68, 0xaf8a3578),\n\tPCMCIA_DEVICE_PROD_ID12(\"Macsense\", \"MPC-10\", 0xd830297f, 0xd265c307),\n\tPCMCIA_DEVICE_PROD_ID12(\"Matsushita Electric Industrial Co.,LTD.\", \"CF-VEL211\", 0x44445376, 0x8ded41d4),\n\tPCMCIA_DEVICE_PROD_ID12(\"MAXTECH\", \"PCN2000\", 0x78d64bc0, 0xca0ca4b8),\n\tPCMCIA_DEVICE_PROD_ID12(\"MELCO\", \"LPC2-T\", 0x481e0094, 0xa2eb0cf3),\n\tPCMCIA_DEVICE_PROD_ID12(\"MELCO\", \"LPC2-TX\", 0x481e0094, 0x41a6916c),\n\tPCMCIA_DEVICE_PROD_ID12(\"Microcom C.E.\", \"Travel Card LAN 10/100\", 0x4b91cec7, 0xe70220d6),\n\tPCMCIA_DEVICE_PROD_ID12(\"Microdyne\", \"NE4200\", 0x2e6da59b, 0x0478e472),\n\tPCMCIA_DEVICE_PROD_ID12(\"MIDORI ELEC.\", \"LT-PCMT\", 0x648d55c1, 0xbde526c7),\n\tPCMCIA_DEVICE_PROD_ID12(\"National Semiconductor\", \"InfoMover 4100\", 0x36e1191f, 0x60c229b9),\n\tPCMCIA_DEVICE_PROD_ID12(\"National Semiconductor\", \"InfoMover NE4100\", 0x36e1191f, 0xa6617ec8),\n\tPCMCIA_DEVICE_PROD_ID12(\"NEC\", \"PC-9801N-J12\", 0x18df0ba0, 0xbc912d76),\n\tPCMCIA_DEVICE_PROD_ID12(\"NETGEAR\", \"FA410TX\", 0x9aa79dc3, 0x60e5bc0e),\n\tPCMCIA_DEVICE_PROD_ID12(\"Network Everywhere\", \"Fast Ethernet 10/100 PC Card\", 0x820a67b6, 0x31ed1a5f),\n\tPCMCIA_DEVICE_PROD_ID12(\"NextCom K.K.\", \"Next Hawk\", 0xaedaec74, 0xad050ef1),\n\tPCMCIA_DEVICE_PROD_ID12(\"PCMCIA\", \"10/100Mbps Ethernet Card\", 0x281f1c5d, 0x6e41773b),\n\tPCMCIA_DEVICE_PROD_ID12(\"PCMCIA\", \"Ethernet\", 0x281f1c5d, 0x00b2e941),\n\tPCMCIA_DEVICE_PROD_ID12(\"PCMCIA\", \"ETHERNET\", 0x281f1c5d, 0x3ff7175b),\n\tPCMCIA_DEVICE_PROD_ID12(\"PCMCIA\", \"Ethernet 10BaseT Card\", 0x281f1c5d, 0x4de2f6c8),\n\tPCMCIA_DEVICE_PROD_ID12(\"PCMCIA\", \"Ethernet Card\", 0x281f1c5d, 0x5e9d92c0),\n\tPCMCIA_DEVICE_PROD_ID12(\"PCMCIA\", \"Ethernet Combo card\", 0x281f1c5d, 0x929c486c),\n\tPCMCIA_DEVICE_PROD_ID12(\"PCMCIA\", \"ETHERNET V1.0\", 0x281f1c5d, 0x4d8817c8),\n\tPCMCIA_DEVICE_PROD_ID12(\"PCMCIA\", \"FastEthernet\", 0x281f1c5d, 0xfe871eeb),\n\tPCMCIA_DEVICE_PROD_ID12(\"PCMCIA\", \"Fast-Ethernet\", 0x281f1c5d, 0x45f1f3b4),\n\tPCMCIA_DEVICE_PROD_ID12(\"PCMCIA\", \"FAST ETHERNET CARD\", 0x281f1c5d, 0xec5dbca7),\n\tPCMCIA_DEVICE_PROD_ID12(\"PCMCIA LAN\", \"Ethernet\", 0x7500e246, 0x00b2e941),\n\tPCMCIA_DEVICE_PROD_ID12(\"PCMCIA\", \"LNT-10TN\", 0x281f1c5d, 0xe707f641),\n\tPCMCIA_DEVICE_PROD_ID12(\"PCMCIAs\", \"ComboCard\", 0xdcfe12d3, 0xcd8906cc),\n\tPCMCIA_DEVICE_PROD_ID12(\"PCMCIA\", \"UE2212\", 0x281f1c5d, 0xbf17199b),\n\tPCMCIA_DEVICE_PROD_ID12(\"PCMCIA\", \"    Ethernet NE2000 Compatible\", 0x281f1c5d, 0x42d5d7e1),\n\tPCMCIA_DEVICE_PROD_ID12(\"PRETEC\", \"Ethernet CompactLAN 10baseT 3.3V\", 0xebf91155, 0x30074c80),\n\tPCMCIA_DEVICE_PROD_ID12(\"PRETEC\", \"Ethernet CompactLAN 10BaseT 3.3V\", 0xebf91155, 0x7f5a4f50),\n\tPCMCIA_DEVICE_PROD_ID12(\"Psion Dacom\", \"Gold Card Ethernet\", 0xf5f025c2, 0x3a30e110),\n\tPCMCIA_DEVICE_PROD_ID12(\"=RELIA==\", \"Ethernet\", 0xcdd0644a, 0x00b2e941),\n\tPCMCIA_DEVICE_PROD_ID12(\"RIOS Systems Co.\", \"PC CARD3 ETHERNET\", 0x7dd33481, 0x10b41826),\n\tPCMCIA_DEVICE_PROD_ID12(\"RP\", \"1625B Ethernet NE2000 Compatible\", 0xe3e66e22, 0xb96150df),\n\tPCMCIA_DEVICE_PROD_ID12(\"RPTI\", \"EP400 Ethernet NE2000 Compatible\", 0xdc6f88fd, 0x4a7e2ae0),\n\tPCMCIA_DEVICE_PROD_ID12(\"RPTI\", \"EP401 Ethernet NE2000 Compatible\", 0xdc6f88fd, 0x4bcbd7fd),\n\tPCMCIA_DEVICE_PROD_ID12(\"RPTI LTD.\", \"EP400\", 0xc53ac515, 0x81e39388),\n\tPCMCIA_DEVICE_PROD_ID12(\"SCM\", \"Ethernet Combo card\", 0xbdc3b102, 0x929c486c),\n\tPCMCIA_DEVICE_PROD_ID12(\"Seiko Epson Corp.\", \"Ethernet\", 0x09928730, 0x00b2e941),\n\tPCMCIA_DEVICE_PROD_ID12(\"SMC\", \"EZCard-10-PCMCIA\", 0xc4f8b18b, 0xfb21d265),\n\tPCMCIA_DEVICE_PROD_ID12(\"Socket Communications Inc\", \"Socket EA PCMCIA LAN Adapter Revision D\", 0xc70a4760, 0x2ade483e),\n\tPCMCIA_DEVICE_PROD_ID12(\"Socket Communications Inc\", \"Socket EA PCMCIA LAN Adapter Revision E\", 0xc70a4760, 0x5dd978a8),\n\tPCMCIA_DEVICE_PROD_ID12(\"TDK\", \"LAK-CD031 for PCMCIA\", 0x1eae9475, 0x0ed386fa),\n\tPCMCIA_DEVICE_PROD_ID12(\"Telecom Device K.K.\", \"SuperSocket RE450T\", 0x466b05f0, 0x8b74bc4f),\n\tPCMCIA_DEVICE_PROD_ID12(\"Telecom Device K.K.\", \"SuperSocket RE550T\", 0x466b05f0, 0x33c8db2a),\n\tPCMCIA_DEVICE_PROD_ID13(\"Hypertec\",  \"EP401\", 0x8787bec7, 0xf6e4a31e),\n\tPCMCIA_DEVICE_PROD_ID13(\"KingMax Technology Inc.\", \"Ethernet Card\", 0x932b7189, 0x5e9d92c0),\n\tPCMCIA_DEVICE_PROD_ID13(\"LONGSHINE\", \"EP401\", 0xf866b0b0, 0xf6e4a31e),\n\tPCMCIA_DEVICE_PROD_ID13(\"Xircom\", \"CFE-10\", 0x2e3ee845, 0x22a49f89),\n\tPCMCIA_DEVICE_PROD_ID1(\"CyQ've 10 Base-T LAN CARD\", 0x94faf360),\n\tPCMCIA_DEVICE_PROD_ID1(\"EP-210 PCMCIA LAN CARD.\", 0x8850b4de),\n\tPCMCIA_DEVICE_PROD_ID1(\"ETHER-C16\", 0x06a8514f),\n\tPCMCIA_DEVICE_PROD_ID1(\"NE2000 Compatible\", 0x75b8ad5a),\n\tPCMCIA_DEVICE_PROD_ID2(\"EN-6200P2\", 0xa996d078),\n\t \n\t \n\tPCMCIA_PFC_DEVICE_CIS_PROD_ID12(0, \"PCMCIA\", \"EN2218-LAN/MODEM\", 0x281f1c5d, 0x570f348e, \"cis/PCMLM28.cis\"),\n\tPCMCIA_PFC_DEVICE_CIS_PROD_ID12(0, \"PCMCIA\", \"UE2218-LAN/MODEM\", 0x281f1c5d, 0x6fdcacee, \"cis/PCMLM28.cis\"),\n\tPCMCIA_PFC_DEVICE_CIS_PROD_ID12(0, \"Psion Dacom\", \"Gold Card V34 Ethernet\", 0xf5f025c2, 0x338e8155, \"cis/PCMLM28.cis\"),\n\tPCMCIA_PFC_DEVICE_CIS_PROD_ID12(0, \"Psion Dacom\", \"Gold Card V34 Ethernet GSM\", 0xf5f025c2, 0x4ae85d35, \"cis/PCMLM28.cis\"),\n\tPCMCIA_PFC_DEVICE_CIS_PROD_ID12(0, \"LINKSYS\", \"PCMLM28\", 0xf7cb0b07, 0x66881874, \"cis/PCMLM28.cis\"),\n\tPCMCIA_PFC_DEVICE_CIS_PROD_ID12(0, \"TOSHIBA\", \"Modem/LAN Card\", 0xb4585a1a, 0x53f922f8, \"cis/PCMLM28.cis\"),\n\tPCMCIA_MFC_DEVICE_CIS_PROD_ID12(0, \"DAYNA COMMUNICATIONS\", \"LAN AND MODEM MULTIFUNCTION\", 0x8fdf8f89, 0xdd5ed9e8, \"cis/DP83903.cis\"),\n\tPCMCIA_MFC_DEVICE_CIS_PROD_ID4(0, \"NSC MF LAN/Modem\", 0x58fc6056, \"cis/DP83903.cis\"),\n\tPCMCIA_MFC_DEVICE_CIS_MANF_CARD(0, 0x0175, 0x0000, \"cis/DP83903.cis\"),\n\tPCMCIA_DEVICE_CIS_PROD_ID12(\"Allied Telesis,K.K\", \"Ethernet LAN Card\", 0x2ad62f3c, 0x9fd2f0a2, \"cis/LA-PCM.cis\"),\n\tPCMCIA_DEVICE_CIS_PROD_ID12(\"KTI\", \"PE520 PLUS\", 0xad180345, 0x9d58d392, \"cis/PE520.cis\"),\n\tPCMCIA_DEVICE_CIS_PROD_ID12(\"NDC\", \"Ethernet\", 0x01c43ae1, 0x00b2e941, \"cis/NE2K.cis\"),\n\tPCMCIA_DEVICE_CIS_PROD_ID12(\"PMX   \", \"PE-200\", 0x34f3f1c8, 0x10b59f8c, \"cis/PE-200.cis\"),\n\tPCMCIA_DEVICE_CIS_PROD_ID12(\"TAMARACK\", \"Ethernet\", 0xcf434fba, 0x00b2e941, \"cis/tamarack.cis\"),\n\tPCMCIA_DEVICE_PROD_ID12(\"Ethernet\", \"CF Size PC Card\", 0x00b2e941, 0x43ac239b),\n\tPCMCIA_DEVICE_PROD_ID123(\"Fast Ethernet\", \"CF Size PC Card\", \"1.0\",\n\t\t0xb4be14e3, 0x43ac239b, 0x0877b627),\n\tPCMCIA_DEVICE_NULL\n};\nMODULE_DEVICE_TABLE(pcmcia, pcnet_ids);\nMODULE_FIRMWARE(\"cis/PCMLM28.cis\");\nMODULE_FIRMWARE(\"cis/DP83903.cis\");\nMODULE_FIRMWARE(\"cis/LA-PCM.cis\");\nMODULE_FIRMWARE(\"cis/PE520.cis\");\nMODULE_FIRMWARE(\"cis/NE2K.cis\");\nMODULE_FIRMWARE(\"cis/PE-200.cis\");\nMODULE_FIRMWARE(\"cis/tamarack.cis\");\n\nstatic struct pcmcia_driver pcnet_driver = {\n\t.name\t\t= \"pcnet_cs\",\n\t.probe\t\t= pcnet_probe,\n\t.remove\t\t= pcnet_detach,\n\t.owner\t\t= THIS_MODULE,\n\t.id_table\t= pcnet_ids,\n\t.suspend\t= pcnet_suspend,\n\t.resume\t\t= pcnet_resume,\n};\nmodule_pcmcia_driver(pcnet_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}