{
  "module_name": "smc-ultra.c",
  "hash_id": "19145713694e6960cef5fde5356b56835cdbe95f9340b2640fd4b6fd3806fa69",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/8390/smc-ultra.c",
  "human_readable_source": "\n \n \n\nstatic const char version[] =\n\t\"smc-ultra.c:v2.02 2/3/98 Donald Becker (becker@cesdis.gsfc.nasa.gov)\\n\";\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/isapnp.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <net/Space.h>\n\n#include <asm/io.h>\n#include <asm/irq.h>\n\n#include \"8390.h\"\n\n#define DRV_NAME \"smc-ultra\"\n\n \nstatic unsigned int ultra_portlist[] __initdata =\n{0x200, 0x220, 0x240, 0x280, 0x300, 0x340, 0x380, 0};\n\nstatic int ultra_probe1(struct net_device *dev, int ioaddr);\n\n#ifdef __ISAPNP__\nstatic int ultra_probe_isapnp(struct net_device *dev);\n#endif\n\nstatic int ultra_open(struct net_device *dev);\nstatic void ultra_reset_8390(struct net_device *dev);\nstatic void ultra_get_8390_hdr(struct net_device *dev, struct e8390_pkt_hdr *hdr,\n\t\t\t\t\t\tint ring_page);\nstatic void ultra_block_input(struct net_device *dev, int count,\n\t\t\t\t\t\t  struct sk_buff *skb, int ring_offset);\nstatic void ultra_block_output(struct net_device *dev, int count,\n\t\t\t\t\t\t\tconst unsigned char *buf, const int start_page);\nstatic void ultra_pio_get_hdr(struct net_device *dev, struct e8390_pkt_hdr *hdr,\n\t\t\t\t\t\tint ring_page);\nstatic void ultra_pio_input(struct net_device *dev, int count,\n\t\t\t\t\t\t  struct sk_buff *skb, int ring_offset);\nstatic void ultra_pio_output(struct net_device *dev, int count,\n\t\t\t\t\t\t\t const unsigned char *buf, const int start_page);\nstatic int ultra_close_card(struct net_device *dev);\n\n#ifdef __ISAPNP__\nstatic struct isapnp_device_id ultra_device_ids[] __initdata = {\n        {       ISAPNP_VENDOR('S','M','C'), ISAPNP_FUNCTION(0x8416),\n                ISAPNP_VENDOR('S','M','C'), ISAPNP_FUNCTION(0x8416),\n                (long) \"SMC EtherEZ (8416)\" },\n        { }\t \n};\n\nMODULE_DEVICE_TABLE(isapnp, ultra_device_ids);\n#endif\n\nstatic u32 ultra_msg_enable;\n\n#define START_PG\t\t0x00\t \n\n#define ULTRA_CMDREG\t0\t\t \n#define\t ULTRA_RESET\t0x80\t \n#define\t ULTRA_MEMENB\t0x40\t \n#define IOPD\t0x02\t\t\t \n#define IOPA\t0x07\t\t\t \n#define ULTRA_NIC_OFFSET  16\t \n#define ULTRA_IO_EXTENT 32\n#define EN0_ERWCNT\t\t0x08\t \n\n#ifdef CONFIG_NET_POLL_CONTROLLER\nstatic void ultra_poll(struct net_device *dev)\n{\n\tdisable_irq(dev->irq);\n\tei_interrupt(dev->irq, dev);\n\tenable_irq(dev->irq);\n}\n#endif\n \n\nstatic int __init do_ultra_probe(struct net_device *dev)\n{\n\tint i;\n\tint base_addr = dev->base_addr;\n\tint irq = dev->irq;\n\n\tif (base_addr > 0x1ff)\t\t \n\t\treturn ultra_probe1(dev, base_addr);\n\telse if (base_addr != 0)\t \n\t\treturn -ENXIO;\n\n#ifdef __ISAPNP__\n\t \n\tif (isapnp_present() && (ultra_probe_isapnp(dev) == 0))\n\t\treturn 0;\n#endif\n\n\tfor (i = 0; ultra_portlist[i]; i++) {\n\t\tdev->irq = irq;\n\t\tif (ultra_probe1(dev, ultra_portlist[i]) == 0)\n\t\t\treturn 0;\n\t}\n\n\treturn -ENODEV;\n}\n\n#ifndef MODULE\nstruct net_device * __init ultra_probe(int unit)\n{\n\tstruct net_device *dev = alloc_ei_netdev();\n\tint err;\n\n\tif (!dev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tsprintf(dev->name, \"eth%d\", unit);\n\tnetdev_boot_setup_check(dev);\n\n\terr = do_ultra_probe(dev);\n\tif (err)\n\t\tgoto out;\n\treturn dev;\nout:\n\tfree_netdev(dev);\n\treturn ERR_PTR(err);\n}\n#endif\n\nstatic const struct net_device_ops ultra_netdev_ops = {\n\t.ndo_open\t\t= ultra_open,\n\t.ndo_stop\t\t= ultra_close_card,\n\n\t.ndo_start_xmit\t\t= ei_start_xmit,\n\t.ndo_tx_timeout\t\t= ei_tx_timeout,\n\t.ndo_get_stats\t\t= ei_get_stats,\n\t.ndo_set_rx_mode\t= ei_set_multicast_list,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_set_mac_address \t= eth_mac_addr,\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\t.ndo_poll_controller \t= ultra_poll,\n#endif\n};\n\nstatic int __init ultra_probe1(struct net_device *dev, int ioaddr)\n{\n\tint i, retval;\n\tint checksum = 0;\n\tu8 macaddr[ETH_ALEN];\n\tconst char *model_name;\n\tunsigned char eeprom_irq = 0;\n\tstatic unsigned version_printed;\n\t \n\tunsigned char num_pages, irqreg, addr, piomode;\n\tunsigned char idreg = inb(ioaddr + 7);\n\tunsigned char reg4 = inb(ioaddr + 4) & 0x7f;\n\tstruct ei_device *ei_local = netdev_priv(dev);\n\n\tif (!request_region(ioaddr, ULTRA_IO_EXTENT, DRV_NAME))\n\t\treturn -EBUSY;\n\n\t \n\tif ((idreg & 0xF0) != 0x20 \t\t\t \n\t\t&& (idreg & 0xF0) != 0x40) {\t\t \n\t\tretval = -ENODEV;\n\t\tgoto out;\n\t}\n\n\t \n\toutb(reg4, ioaddr + 4);\n\n\tfor (i = 0; i < 8; i++)\n\t\tchecksum += inb(ioaddr + 8 + i);\n\tif ((checksum & 0xff) != 0xFF) {\n\t\tretval = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tif ((ultra_msg_enable & NETIF_MSG_DRV) && (version_printed++ == 0))\n\t\tnetdev_info(dev, version);\n\n\tmodel_name = (idreg & 0xF0) == 0x20 ? \"SMC Ultra\" : \"SMC EtherEZ\";\n\n\tfor (i = 0; i < 6; i++)\n\t\tmacaddr[i] = inb(ioaddr + 8 + i);\n\teth_hw_addr_set(dev, macaddr);\n\n\tnetdev_info(dev, \"%s at %#3x, %pM\", model_name,\n\t\t    ioaddr, dev->dev_addr);\n\n\t \n\toutb(0x80 | reg4, ioaddr + 4);\n\n\t \n\toutb(0x80 | inb(ioaddr + 0x0c), ioaddr + 0x0c);\n\tpiomode = inb(ioaddr + 0x8);\n\taddr = inb(ioaddr + 0xb);\n\tirqreg = inb(ioaddr + 0xd);\n\n\t \n\toutb(reg4, ioaddr + 4);\n\n\tif (dev->irq < 2) {\n\t\tunsigned char irqmap[] = {0, 9, 3, 5, 7, 10, 11, 15};\n\t\tint irq;\n\n\t\t \n\t\tirq = irqmap[((irqreg & 0x40) >> 4) + ((irqreg & 0x0c) >> 2)];\n\n\t\tif (irq == 0) {\n\t\t\tpr_cont(\", failed to detect IRQ line.\\n\");\n\t\t\tretval =  -EAGAIN;\n\t\t\tgoto out;\n\t\t}\n\t\tdev->irq = irq;\n\t\teeprom_irq = 1;\n\t}\n\n\t \n\tdev->base_addr = ioaddr+ULTRA_NIC_OFFSET;\n\n\t{\n\t\tstatic const int addr_tbl[4] = {\n\t\t\t0x0C0000, 0x0E0000, 0xFC0000, 0xFE0000\n\t\t};\n\t\tstatic const short num_pages_tbl[4] = {\n\t\t\t0x20, 0x40, 0x80, 0xff\n\t\t};\n\n\t\tdev->mem_start = ((addr & 0x0f) << 13) + addr_tbl[(addr >> 6) & 3] ;\n\t\tnum_pages = num_pages_tbl[(addr >> 4) & 3];\n\t}\n\n\tei_status.name = model_name;\n\tei_status.word16 = 1;\n\tei_status.tx_start_page = START_PG;\n\tei_status.rx_start_page = START_PG + TX_PAGES;\n\tei_status.stop_page = num_pages;\n\n\tei_status.mem = ioremap(dev->mem_start, (ei_status.stop_page - START_PG)*256);\n\tif (!ei_status.mem) {\n\t\tpr_cont(\", failed to ioremap.\\n\");\n\t\tretval =  -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tdev->mem_end = dev->mem_start + (ei_status.stop_page - START_PG)*256;\n\n\tif (piomode) {\n\t\tpr_cont(\", %s IRQ %d programmed-I/O mode.\\n\",\n\t\t\teeprom_irq ? \"EEPROM\" : \"assigned \", dev->irq);\n\t\tei_status.block_input = &ultra_pio_input;\n\t\tei_status.block_output = &ultra_pio_output;\n\t\tei_status.get_8390_hdr = &ultra_pio_get_hdr;\n\t} else {\n\t\tpr_cont(\", %s IRQ %d memory %#lx-%#lx.\\n\",\n\t\t\teeprom_irq ? \"\" : \"assigned \", dev->irq, dev->mem_start,\n\t\t\tdev->mem_end-1);\n\t\tei_status.block_input = &ultra_block_input;\n\t\tei_status.block_output = &ultra_block_output;\n\t\tei_status.get_8390_hdr = &ultra_get_8390_hdr;\n\t}\n\tei_status.reset_8390 = &ultra_reset_8390;\n\n\tdev->netdev_ops = &ultra_netdev_ops;\n\tNS8390_init(dev, 0);\n\tei_local->msg_enable = ultra_msg_enable;\n\n\tretval = register_netdev(dev);\n\tif (retval)\n\t\tgoto out;\n\treturn 0;\nout:\n\trelease_region(ioaddr, ULTRA_IO_EXTENT);\n\treturn retval;\n}\n\n#ifdef __ISAPNP__\nstatic int __init ultra_probe_isapnp(struct net_device *dev)\n{\n        int i;\n\n        for (i = 0; ultra_device_ids[i].vendor != 0; i++) {\n\t\tstruct pnp_dev *idev = NULL;\n\n                while ((idev = pnp_find_dev(NULL,\n                                            ultra_device_ids[i].vendor,\n                                            ultra_device_ids[i].function,\n                                            idev))) {\n                         \n                        if (pnp_device_attach(idev) < 0)\n\t\t\t\tcontinue;\n                        if (pnp_activate_dev(idev) < 0) {\n                              __again:\n\t\t\t\tpnp_device_detach(idev);\n\t\t\t\tcontinue;\n                        }\n\t\t\t \n\t\t\tif (!pnp_port_valid(idev, 0) || !pnp_irq_valid(idev, 0))\n\t\t\t\tgoto __again;\n                         \n\t\t\tdev->base_addr = pnp_port_start(idev, 0);\n\t\t\tdev->irq = pnp_irq(idev, 0);\n\t\t\tnetdev_info(dev,\n\t\t\t\t    \"smc-ultra.c: ISAPnP reports %s at i/o %#lx, irq %d.\\n\",\n\t\t\t\t    (char *) ultra_device_ids[i].driver_data,\n\t\t\t\t    dev->base_addr, dev->irq);\n                        if (ultra_probe1(dev, dev->base_addr) != 0) {       \n\t\t\t\tnetdev_err(dev,\n\t\t\t\t\t   \"smc-ultra.c: Probe of ISAPnP card at %#lx failed.\\n\",\n\t\t\t\t\t   dev->base_addr);\n\t\t\t\tpnp_device_detach(idev);\n\t\t\t\treturn -ENXIO;\n                        }\n                        ei_status.priv = (unsigned long)idev;\n                        break;\n                }\n                if (!idev)\n                        continue;\n                return 0;\n        }\n\n        return -ENODEV;\n}\n#endif\n\nstatic int\nultra_open(struct net_device *dev)\n{\n\tint retval;\n\tint ioaddr = dev->base_addr - ULTRA_NIC_OFFSET;  \n\tunsigned char irq2reg[] = {0, 0, 0x04, 0x08, 0, 0x0C, 0, 0x40,\n\t\t\t\t   0, 0x04, 0x44, 0x48, 0, 0, 0, 0x4C, };\n\n\tretval = request_irq(dev->irq, ei_interrupt, 0, dev->name, dev);\n\tif (retval)\n\t\treturn retval;\n\n\toutb(0x00, ioaddr);\t \n\toutb(0x80, ioaddr + 5);\n\t \n\toutb(inb(ioaddr + 4) | 0x80, ioaddr + 4);\n\toutb((inb(ioaddr + 13) & ~0x4C) | irq2reg[dev->irq], ioaddr + 13);\n\toutb(inb(ioaddr + 4) & 0x7f, ioaddr + 4);\n\n\tif (ei_status.block_input == &ultra_pio_input) {\n\t\toutb(0x11, ioaddr + 6);\t\t \n\t\toutb(0x01, ioaddr + 0x19);  \t \n\t} else\n\t\toutb(0x01, ioaddr + 6);\t\t \n\t \n\toutb_p(E8390_NODMA+E8390_PAGE0, dev->base_addr);\n\toutb(0xff, dev->base_addr + EN0_ERWCNT);\n\tei_open(dev);\n\treturn 0;\n}\n\nstatic void\nultra_reset_8390(struct net_device *dev)\n{\n\tint cmd_port = dev->base_addr - ULTRA_NIC_OFFSET;  \n\tstruct ei_device *ei_local = netdev_priv(dev);\n\n\toutb(ULTRA_RESET, cmd_port);\n\tnetif_dbg(ei_local, hw, dev, \"resetting Ultra, t=%ld...\\n\", jiffies);\n\tei_status.txing = 0;\n\n\toutb(0x00, cmd_port);\t \n\toutb(0x80, cmd_port + 5);\n\tif (ei_status.block_input == &ultra_pio_input)\n\t\toutb(0x11, cmd_port + 6);\t\t \n\telse\n\t\toutb(0x01, cmd_port + 6);\t\t \n\n\tnetif_dbg(ei_local, hw, dev, \"reset done\\n\");\n}\n\n \n\nstatic void\nultra_get_8390_hdr(struct net_device *dev, struct e8390_pkt_hdr *hdr, int ring_page)\n{\n\tvoid __iomem *hdr_start = ei_status.mem + ((ring_page - START_PG)<<8);\n\n\toutb(ULTRA_MEMENB, dev->base_addr - ULTRA_NIC_OFFSET);\t \n#ifdef __BIG_ENDIAN\n\t \n\t \n\tmemcpy_fromio(hdr, hdr_start, sizeof(struct e8390_pkt_hdr));\n\thdr->count = le16_to_cpu(hdr->count);\n#else\n\t((unsigned int*)hdr)[0] = readl(hdr_start);\n#endif\n\toutb(0x00, dev->base_addr - ULTRA_NIC_OFFSET);  \n}\n\n \n\nstatic void\nultra_block_input(struct net_device *dev, int count, struct sk_buff *skb, int ring_offset)\n{\n\tvoid __iomem *xfer_start = ei_status.mem + ring_offset - (START_PG<<8);\n\n\t \n\toutb(ULTRA_MEMENB, dev->base_addr - ULTRA_NIC_OFFSET);\n\n\tif (ring_offset + count > ei_status.stop_page*256) {\n\t\t \n\t\tint semi_count = ei_status.stop_page*256 - ring_offset;\n\t\tmemcpy_fromio(skb->data, xfer_start, semi_count);\n\t\tcount -= semi_count;\n\t\tmemcpy_fromio(skb->data + semi_count, ei_status.mem + TX_PAGES * 256, count);\n\t} else {\n\t\tmemcpy_fromio(skb->data, xfer_start, count);\n\t}\n\n\toutb(0x00, dev->base_addr - ULTRA_NIC_OFFSET);\t \n}\n\nstatic void\nultra_block_output(struct net_device *dev, int count, const unsigned char *buf,\n\t\t\t\tint start_page)\n{\n\tvoid __iomem *shmem = ei_status.mem + ((start_page - START_PG)<<8);\n\n\t \n\toutb(ULTRA_MEMENB, dev->base_addr - ULTRA_NIC_OFFSET);\n\n\tmemcpy_toio(shmem, buf, count);\n\n\toutb(0x00, dev->base_addr - ULTRA_NIC_OFFSET);  \n}\n\n \nstatic void ultra_pio_get_hdr(struct net_device *dev, struct e8390_pkt_hdr *hdr,\n\t\t\t\t\t\tint ring_page)\n{\n\tint ioaddr = dev->base_addr - ULTRA_NIC_OFFSET;  \n\toutb(0x00, ioaddr + IOPA);\t \n\toutb(ring_page, ioaddr + IOPA);\n\tinsw(ioaddr + IOPD, hdr, sizeof(struct e8390_pkt_hdr)>>1);\n}\n\nstatic void ultra_pio_input(struct net_device *dev, int count,\n\t\t\t\t\t\t  struct sk_buff *skb, int ring_offset)\n{\n\tint ioaddr = dev->base_addr - ULTRA_NIC_OFFSET;  \n    char *buf = skb->data;\n\n\t \n\toutb(ring_offset, ioaddr + IOPA);\t \n\toutb(ring_offset >> 8, ioaddr + IOPA);\n\t \n\tinsw(ioaddr + IOPD, buf, (count+1)>>1);\n}\nstatic void ultra_pio_output(struct net_device *dev, int count,\n\t\t\t\t\t\t\tconst unsigned char *buf, const int start_page)\n{\n\tint ioaddr = dev->base_addr - ULTRA_NIC_OFFSET;  \n\toutb(0x00, ioaddr + IOPA);\t \n\toutb(start_page, ioaddr + IOPA);\n\t \n\toutsw(ioaddr + IOPD, buf, (count+1)>>1);\n}\n\nstatic int\nultra_close_card(struct net_device *dev)\n{\n\tint ioaddr = dev->base_addr - ULTRA_NIC_OFFSET;  \n\tstruct ei_device *ei_local = netdev_priv(dev);\n\n\tnetif_stop_queue(dev);\n\n\tnetif_dbg(ei_local, ifdown, dev, \"Shutting down ethercard.\\n\");\n\n\toutb(0x00, ioaddr + 6);\t\t \n\tfree_irq(dev->irq, dev);\n\n\tNS8390_init(dev, 0);\n\n\t \n\n\treturn 0;\n}\n\n\n#ifdef MODULE\n#define MAX_ULTRA_CARDS\t4\t \nstatic struct net_device *dev_ultra[MAX_ULTRA_CARDS];\nstatic int io[MAX_ULTRA_CARDS];\nstatic int irq[MAX_ULTRA_CARDS];\n\nmodule_param_hw_array(io, int, ioport, NULL, 0);\nmodule_param_hw_array(irq, int, irq, NULL, 0);\nmodule_param_named(msg_enable, ultra_msg_enable, uint, 0444);\nMODULE_PARM_DESC(io, \"I/O base address(es)\");\nMODULE_PARM_DESC(irq, \"IRQ number(s) (assigned)\");\nMODULE_PARM_DESC(msg_enable, \"Debug message level (see linux/netdevice.h for bitmap)\");\nMODULE_DESCRIPTION(\"SMC Ultra/EtherEZ ISA/PnP Ethernet driver\");\nMODULE_LICENSE(\"GPL\");\n\n \nstatic int __init ultra_init_module(void)\n{\n\tstruct net_device *dev;\n\tint this_dev, found = 0;\n\n\tfor (this_dev = 0; this_dev < MAX_ULTRA_CARDS; this_dev++) {\n\t\tif (io[this_dev] == 0)  {\n\t\t\tif (this_dev != 0) break;  \n\t\t\tprintk(KERN_NOTICE \"smc-ultra.c: Presently autoprobing (not recommended) for a single card.\\n\");\n\t\t}\n\t\tdev = alloc_ei_netdev();\n\t\tif (!dev)\n\t\t\tbreak;\n\t\tdev->irq = irq[this_dev];\n\t\tdev->base_addr = io[this_dev];\n\t\tif (do_ultra_probe(dev) == 0) {\n\t\t\tdev_ultra[found++] = dev;\n\t\t\tcontinue;\n\t\t}\n\t\tfree_netdev(dev);\n\t\tprintk(KERN_WARNING \"smc-ultra.c: No SMC Ultra card found (i/o = 0x%x).\\n\", io[this_dev]);\n\t\tbreak;\n\t}\n\tif (found)\n\t\treturn 0;\n\treturn -ENXIO;\n}\nmodule_init(ultra_init_module);\n\nstatic void cleanup_card(struct net_device *dev)\n{\n\t \n#ifdef __ISAPNP__\n\tstruct pnp_dev *idev = (struct pnp_dev *)ei_status.priv;\n\tif (idev)\n\t\tpnp_device_detach(idev);\n#endif\n\trelease_region(dev->base_addr - ULTRA_NIC_OFFSET, ULTRA_IO_EXTENT);\n\tiounmap(ei_status.mem);\n}\n\nstatic void __exit ultra_cleanup_module(void)\n{\n\tint this_dev;\n\n\tfor (this_dev = 0; this_dev < MAX_ULTRA_CARDS; this_dev++) {\n\t\tstruct net_device *dev = dev_ultra[this_dev];\n\t\tif (dev) {\n\t\t\tunregister_netdev(dev);\n\t\t\tcleanup_card(dev);\n\t\t\tfree_netdev(dev);\n\t\t}\n\t}\n}\nmodule_exit(ultra_cleanup_module);\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}