{
  "module_name": "stnic.c",
  "hash_id": "74990d0c6178bd309ca61ce543ea95965c2a2ff02fabbe8ab6f08b226e335fb8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/8390/stnic.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n\n#include <asm/io.h>\n#include <mach-se/mach/se.h>\n#include <asm/machvec.h>\n#ifdef CONFIG_SH_STANDARD_BIOS\n#include <asm/sh_bios.h>\n#endif\n\n#include \"8390.h\"\n\n#define DRV_NAME \"stnic\"\n\n#define byte\tunsigned char\n#define half\tunsigned short\n#define word\tunsigned int\n#define vbyte\tvolatile unsigned char\n#define vhalf\tvolatile unsigned short\n#define vword\tvolatile unsigned int\n\n#define STNIC_RUN\t0x01\t \n\n#define START_PG\t0\t \n#define STOP_PG\t\t128\t \n\n \n#define STNIC_CR\tE8390_CMD\n#define PG0_RSAR0\tEN0_RSARLO\n#define PG0_RSAR1\tEN0_RSARHI\n#define PG0_RBCR0\tEN0_RCNTLO\n#define PG0_RBCR1\tEN0_RCNTHI\n\n#define CR_RRD\t\tE8390_RREAD\n#define CR_RWR\t\tE8390_RWRITE\n#define CR_PG0\t\tE8390_PAGE0\n#define CR_STA\t\tE8390_START\n#define CR_RDMA\t\tE8390_NODMA\n\n \nstatic byte stnic_eadr[6] =\n{0x00, 0xc0, 0x6e, 0x00, 0x00, 0x07};\n\nstatic struct net_device *stnic_dev;\n\nstatic void stnic_reset (struct net_device *dev);\nstatic void stnic_get_hdr (struct net_device *dev, struct e8390_pkt_hdr *hdr,\n\t\t\t   int ring_page);\nstatic void stnic_block_input (struct net_device *dev, int count,\n\t\t\t       struct sk_buff *skb , int ring_offset);\nstatic void stnic_block_output (struct net_device *dev, int count,\n\t\t\t\tconst unsigned char *buf, int start_page);\n\nstatic void stnic_init (struct net_device *dev);\n\nstatic u32 stnic_msg_enable;\n\nmodule_param_named(msg_enable, stnic_msg_enable, uint, 0444);\nMODULE_PARM_DESC(msg_enable, \"Debug message level (see linux/netdevice.h for bitmap)\");\n\n \nstatic inline void\nSTNIC_DELAY (void)\n{\n  vword trash;\n  trash = *(vword *) 0xa0000000;\n  trash = *(vword *) 0xa0000000;\n  trash = *(vword *) 0xa0000000;\n}\n\nstatic inline byte\nSTNIC_READ (int reg)\n{\n  byte val;\n\n  val = (*(vhalf *) (PA_83902 + ((reg) << 1)) >> 8) & 0xff;\n  STNIC_DELAY ();\n  return val;\n}\n\nstatic inline void\nSTNIC_WRITE (int reg, byte val)\n{\n  *(vhalf *) (PA_83902 + ((reg) << 1)) = ((half) (val) << 8);\n  STNIC_DELAY ();\n}\n\nstatic int __init stnic_probe(void)\n{\n  struct net_device *dev;\n  struct ei_device *ei_local;\n  int err;\n\n   \n  if (! MACH_SE)\n    return -ENODEV;\n\n   \n  dev = alloc_ei_netdev();\n  if (!dev)\n\treturn -ENOMEM;\n\n#ifdef CONFIG_SH_STANDARD_BIOS\n  sh_bios_get_node_addr (stnic_eadr);\n#endif\n  eth_hw_addr_set(dev, stnic_eadr);\n\n   \n  dev->base_addr = 0x1000;\n  dev->irq = IRQ_STNIC;\n  dev->netdev_ops = &ei_netdev_ops;\n\n   \n  err = request_irq (dev->irq, ei_interrupt, 0, DRV_NAME, dev);\n  if (err)  {\n\tnetdev_emerg(dev, \" unable to get IRQ %d.\\n\", dev->irq);\n\tfree_netdev(dev);\n\treturn err;\n  }\n\n  ei_status.name = dev->name;\n  ei_status.word16 = 1;\n#ifdef __LITTLE_ENDIAN__\n  ei_status.bigendian = 0;\n#else\n  ei_status.bigendian = 1;\n#endif\n  ei_status.tx_start_page = START_PG;\n  ei_status.rx_start_page = START_PG + TX_PAGES;\n  ei_status.stop_page = STOP_PG;\n\n  ei_status.reset_8390 = &stnic_reset;\n  ei_status.get_8390_hdr = &stnic_get_hdr;\n  ei_status.block_input = &stnic_block_input;\n  ei_status.block_output = &stnic_block_output;\n\n  stnic_init (dev);\n  ei_local = netdev_priv(dev);\n  ei_local->msg_enable = stnic_msg_enable;\n\n  err = register_netdev(dev);\n  if (err) {\n    free_irq(dev->irq, dev);\n    free_netdev(dev);\n    return err;\n  }\n  stnic_dev = dev;\n\n  netdev_info(dev, \"NS ST-NIC 83902A\\n\");\n\n  return 0;\n}\n\nstatic void\nstnic_reset (struct net_device *dev)\n{\n  struct ei_device *ei_local = netdev_priv(dev);\n\n  *(vhalf *) PA_83902_RST = 0;\n  udelay (5);\n  netif_warn(ei_local, hw, dev, \"8390 reset done (%ld).\\n\", jiffies);\n  *(vhalf *) PA_83902_RST = ~0;\n  udelay (5);\n}\n\nstatic void\nstnic_get_hdr (struct net_device *dev, struct e8390_pkt_hdr *hdr,\n\t       int ring_page)\n{\n  struct ei_device *ei_local = netdev_priv(dev);\n\n  half buf[2];\n\n  STNIC_WRITE (PG0_RSAR0, 0);\n  STNIC_WRITE (PG0_RSAR1, ring_page);\n  STNIC_WRITE (PG0_RBCR0, 4);\n  STNIC_WRITE (PG0_RBCR1, 0);\n  STNIC_WRITE (STNIC_CR, CR_RRD | CR_PG0 | CR_STA);\n\n  buf[0] = *(vhalf *) PA_83902_IF;\n  STNIC_DELAY ();\n  buf[1] = *(vhalf *) PA_83902_IF;\n  STNIC_DELAY ();\n  hdr->next = buf[0] >> 8;\n  hdr->status = buf[0] & 0xff;\n#ifdef __LITTLE_ENDIAN__\n  hdr->count = buf[1];\n#else\n  hdr->count = ((buf[1] >> 8) & 0xff) | (buf[1] << 8);\n#endif\n\n  netif_dbg(ei_local, probe, dev, \"ring %x status %02x next %02x count %04x.\\n\",\n\t    ring_page, hdr->status, hdr->next, hdr->count);\n\n  STNIC_WRITE (STNIC_CR, CR_RDMA | CR_PG0 | CR_STA);\n}\n\n \n\nstatic void\nstnic_block_input (struct net_device *dev, int length, struct sk_buff *skb,\n\t\t   int offset)\n{\n  char *buf = skb->data;\n  half val;\n\n  STNIC_WRITE (PG0_RSAR0, offset & 0xff);\n  STNIC_WRITE (PG0_RSAR1, offset >> 8);\n  STNIC_WRITE (PG0_RBCR0, length & 0xff);\n  STNIC_WRITE (PG0_RBCR1, length >> 8);\n  STNIC_WRITE (STNIC_CR, CR_RRD | CR_PG0 | CR_STA);\n\n  if (length & 1)\n    length++;\n\n  while (length > 0)\n    {\n      val = *(vhalf *) PA_83902_IF;\n#ifdef __LITTLE_ENDIAN__\n      *buf++ = val & 0xff;\n      *buf++ = val >> 8;\n#else\n      *buf++ = val >> 8;\n      *buf++ = val & 0xff;\n#endif\n      STNIC_DELAY ();\n      length -= sizeof (half);\n    }\n\n  STNIC_WRITE (STNIC_CR, CR_RDMA | CR_PG0 | CR_STA);\n}\n\nstatic void\nstnic_block_output (struct net_device *dev, int length,\n\t\t    const unsigned char *buf, int output_page)\n{\n  STNIC_WRITE (PG0_RBCR0, 1);\t \n  STNIC_WRITE (STNIC_CR, CR_RRD | CR_PG0 | CR_STA);\n  STNIC_DELAY ();\n\n  STNIC_WRITE (PG0_RBCR0, length & 0xff);\n  STNIC_WRITE (PG0_RBCR1, length >> 8);\n  STNIC_WRITE (PG0_RSAR0, 0);\n  STNIC_WRITE (PG0_RSAR1, output_page);\n  STNIC_WRITE (STNIC_CR, CR_RWR | CR_PG0 | CR_STA);\n\n  if (length & 1)\n    length++;\n\n  while (length > 0)\n    {\n#ifdef __LITTLE_ENDIAN__\n      *(vhalf *) PA_83902_IF = ((half) buf[1] << 8) | buf[0];\n#else\n      *(vhalf *) PA_83902_IF = ((half) buf[0] << 8) | buf[1];\n#endif\n      STNIC_DELAY ();\n      buf += sizeof (half);\n      length -= sizeof (half);\n    }\n\n  STNIC_WRITE (STNIC_CR, CR_RDMA | CR_PG0 | CR_STA);\n}\n\n \nstatic void\nstnic_init (struct net_device *dev)\n{\n  stnic_reset (dev);\n  NS8390_init (dev, 0);\n}\n\nstatic void __exit stnic_cleanup(void)\n{\n\tunregister_netdev(stnic_dev);\n\tfree_irq(stnic_dev->irq, stnic_dev);\n\tfree_netdev(stnic_dev);\n}\n\nmodule_init(stnic_probe);\nmodule_exit(stnic_cleanup);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}