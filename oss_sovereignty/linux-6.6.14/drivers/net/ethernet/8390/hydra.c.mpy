{
  "module_name": "hydra.c",
  "hash_id": "a15862a35eeee87c394d410d63d8be3ed7cc4d7c36ae3d1361dc9fd4b9d27634",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/8390/hydra.c",
  "human_readable_source": "\n\n \n \n\n \n \n\n \n \n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/ioport.h>\n#include <linux/interrupt.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/bitops.h>\n\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/amigaints.h>\n#include <asm/amigahw.h>\n#include <linux/zorro.h>\n\n#define EI_SHIFT(x)\t(ei_local->reg_offset[x])\n#define ei_inb(port)   in_8(port)\n#define ei_outb(val,port)  out_8(port,val)\n#define ei_inb_p(port)   in_8(port)\n#define ei_outb_p(val,port)  out_8(port,val)\n\nstatic const char version[] =\n    \"8390.c:v1.10cvs 9/23/94 Donald Becker (becker@cesdis.gsfc.nasa.gov)\\n\";\n\n#include \"lib8390.c\"\n\n#define NE_EN0_DCFG     (0x0e*2)\n\n#define NESM_START_PG   0x0     \n#define NESM_STOP_PG    0x40     \n\n#define HYDRA_NIC_BASE 0xffe1\n#define HYDRA_ADDRPROM 0xffc0\n#define HYDRA_VERSION \"v3.0alpha\"\n\n#define WORDSWAP(a)     ((((a)>>8)&0xff) | ((a)<<8))\n\n\nstatic int hydra_init_one(struct zorro_dev *z,\n\t\t\t\t    const struct zorro_device_id *ent);\nstatic int hydra_init(struct zorro_dev *z);\nstatic int hydra_open(struct net_device *dev);\nstatic int hydra_close(struct net_device *dev);\nstatic void hydra_reset_8390(struct net_device *dev);\nstatic void hydra_get_8390_hdr(struct net_device *dev,\n\t\t\t       struct e8390_pkt_hdr *hdr, int ring_page);\nstatic void hydra_block_input(struct net_device *dev, int count,\n\t\t\t      struct sk_buff *skb, int ring_offset);\nstatic void hydra_block_output(struct net_device *dev, int count,\n\t\t\t       const unsigned char *buf, int start_page);\nstatic void hydra_remove_one(struct zorro_dev *z);\n\nstatic struct zorro_device_id hydra_zorro_tbl[] = {\n    { ZORRO_PROD_HYDRA_SYSTEMS_AMIGANET },\n    { 0 }\n};\nMODULE_DEVICE_TABLE(zorro, hydra_zorro_tbl);\n\nstatic struct zorro_driver hydra_driver = {\n    .name\t= \"hydra\",\n    .id_table\t= hydra_zorro_tbl,\n    .probe\t= hydra_init_one,\n    .remove\t= hydra_remove_one,\n};\n\nstatic int hydra_init_one(struct zorro_dev *z,\n\t\t\t  const struct zorro_device_id *ent)\n{\n    int err;\n\n    if (!request_mem_region(z->resource.start, 0x10000, \"Hydra\"))\n\treturn -EBUSY;\n    if ((err = hydra_init(z))) {\n\trelease_mem_region(z->resource.start, 0x10000);\n\treturn -EBUSY;\n    }\n    return 0;\n}\n\nstatic const struct net_device_ops hydra_netdev_ops = {\n\t.ndo_open\t\t= hydra_open,\n\t.ndo_stop\t\t= hydra_close,\n\n\t.ndo_start_xmit\t\t= __ei_start_xmit,\n\t.ndo_tx_timeout\t\t= __ei_tx_timeout,\n\t.ndo_get_stats\t\t= __ei_get_stats,\n\t.ndo_set_rx_mode\t= __ei_set_multicast_list,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_set_mac_address\t= eth_mac_addr,\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\t.ndo_poll_controller\t= __ei_poll,\n#endif\n};\n\nstatic int hydra_init(struct zorro_dev *z)\n{\n    struct net_device *dev;\n    unsigned long board = (unsigned long)ZTWO_VADDR(z->resource.start);\n    unsigned long ioaddr = board+HYDRA_NIC_BASE;\n    const char name[] = \"NE2000\";\n    int start_page, stop_page;\n    u8 macaddr[ETH_ALEN];\n    int j;\n    int err;\n\n    static u32 hydra_offsets[16] = {\n\t0x00, 0x02, 0x04, 0x06, 0x08, 0x0a, 0x0c, 0x0e,\n\t0x10, 0x12, 0x14, 0x16, 0x18, 0x1a, 0x1c, 0x1e,\n    };\n\n    dev = ____alloc_ei_netdev(0);\n    if (!dev)\n\treturn -ENOMEM;\n\n    for (j = 0; j < ETH_ALEN; j++)\n\tmacaddr[j] = *((u8 *)(board + HYDRA_ADDRPROM + 2*j));\n    eth_hw_addr_set(dev, macaddr);\n\n     \n    z_writeb(0x4b, ioaddr + NE_EN0_DCFG);\n    start_page = NESM_START_PG;\n    stop_page = NESM_STOP_PG;\n\n    dev->base_addr = ioaddr;\n    dev->irq = IRQ_AMIGA_PORTS;\n\n     \n    if (request_irq(IRQ_AMIGA_PORTS, __ei_interrupt, IRQF_SHARED, \"Hydra Ethernet\",\n\t\t    dev)) {\n\tfree_netdev(dev);\n\treturn -EAGAIN;\n    }\n\n    ei_status.name = name;\n    ei_status.tx_start_page = start_page;\n    ei_status.stop_page = stop_page;\n    ei_status.word16 = 1;\n    ei_status.bigendian = 1;\n\n    ei_status.rx_start_page = start_page + TX_PAGES;\n\n    ei_status.reset_8390 = hydra_reset_8390;\n    ei_status.block_input = hydra_block_input;\n    ei_status.block_output = hydra_block_output;\n    ei_status.get_8390_hdr = hydra_get_8390_hdr;\n    ei_status.reg_offset = hydra_offsets;\n\n    dev->netdev_ops = &hydra_netdev_ops;\n    __NS8390_init(dev, 0);\n\n    err = register_netdev(dev);\n    if (err) {\n\tfree_irq(IRQ_AMIGA_PORTS, dev);\n\tfree_netdev(dev);\n\treturn err;\n    }\n\n    zorro_set_drvdata(z, dev);\n\n    pr_info(\"%s: Hydra at %pR, address %pM (hydra.c \" HYDRA_VERSION \")\\n\",\n\t    dev->name, &z->resource, dev->dev_addr);\n\n    return 0;\n}\n\nstatic int hydra_open(struct net_device *dev)\n{\n    __ei_open(dev);\n    return 0;\n}\n\nstatic int hydra_close(struct net_device *dev)\n{\n    struct ei_device *ei_local = netdev_priv(dev);\n\n    netif_dbg(ei_local, ifdown, dev, \"Shutting down ethercard.\\n\");\n    __ei_close(dev);\n    return 0;\n}\n\nstatic void hydra_reset_8390(struct net_device *dev)\n{\n    netdev_info(dev, \"Hydra hw reset not there\\n\");\n}\n\nstatic void hydra_get_8390_hdr(struct net_device *dev,\n\t\t\t       struct e8390_pkt_hdr *hdr, int ring_page)\n{\n    int nic_base = dev->base_addr;\n    short *ptrs;\n    unsigned long hdr_start= (nic_base-HYDRA_NIC_BASE) +\n\t\t\t     ((ring_page - NESM_START_PG)<<8);\n    ptrs = (short *)hdr;\n\n    *(ptrs++) = z_readw(hdr_start);\n    *((short *)hdr) = WORDSWAP(*((short *)hdr));\n    hdr_start += 2;\n    *(ptrs++) = z_readw(hdr_start);\n    *((short *)hdr+1) = WORDSWAP(*((short *)hdr+1));\n}\n\nstatic void hydra_block_input(struct net_device *dev, int count,\n\t\t\t      struct sk_buff *skb, int ring_offset)\n{\n    unsigned long nic_base = dev->base_addr;\n    unsigned long mem_base = nic_base - HYDRA_NIC_BASE;\n    unsigned long xfer_start = mem_base + ring_offset - (NESM_START_PG<<8);\n\n    if (count&1)\n\tcount++;\n\n    if (xfer_start+count >  mem_base + (NESM_STOP_PG<<8)) {\n\tint semi_count = (mem_base + (NESM_STOP_PG<<8)) - xfer_start;\n\n\tz_memcpy_fromio(skb->data,xfer_start,semi_count);\n\tcount -= semi_count;\n\tz_memcpy_fromio(skb->data+semi_count, mem_base, count);\n    } else\n\tz_memcpy_fromio(skb->data, xfer_start,count);\n\n}\n\nstatic void hydra_block_output(struct net_device *dev, int count,\n\t\t\t       const unsigned char *buf, int start_page)\n{\n    unsigned long nic_base = dev->base_addr;\n    unsigned long mem_base = nic_base - HYDRA_NIC_BASE;\n\n    if (count&1)\n\tcount++;\n\n    z_memcpy_toio(mem_base+((start_page - NESM_START_PG)<<8), buf, count);\n}\n\nstatic void hydra_remove_one(struct zorro_dev *z)\n{\n    struct net_device *dev = zorro_get_drvdata(z);\n\n    unregister_netdev(dev);\n    free_irq(IRQ_AMIGA_PORTS, dev);\n    release_mem_region(ZTWO_PADDR(dev->base_addr)-HYDRA_NIC_BASE, 0x10000);\n    free_netdev(dev);\n}\n\nstatic int __init hydra_init_module(void)\n{\n    return zorro_register_driver(&hydra_driver);\n}\n\nstatic void __exit hydra_cleanup_module(void)\n{\n    zorro_unregister_driver(&hydra_driver);\n}\n\nmodule_init(hydra_init_module);\nmodule_exit(hydra_cleanup_module);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}