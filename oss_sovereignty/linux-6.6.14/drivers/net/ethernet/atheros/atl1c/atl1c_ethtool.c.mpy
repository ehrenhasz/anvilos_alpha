{
  "module_name": "atl1c_ethtool.c",
  "hash_id": "9d977851342a3218883a25e70a1e8af8050e9143aae4cdf514c6d43971fc10a1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/atheros/atl1c/atl1c_ethtool.c",
  "human_readable_source": "\n \n\n#include <linux/netdevice.h>\n#include <linux/ethtool.h>\n#include <linux/slab.h>\n\n#include \"atl1c.h\"\n\nstatic int atl1c_get_link_ksettings(struct net_device *netdev,\n\t\t\t\t    struct ethtool_link_ksettings *cmd)\n{\n\tstruct atl1c_adapter *adapter = netdev_priv(netdev);\n\tstruct atl1c_hw *hw = &adapter->hw;\n\tu32 supported, advertising;\n\n\tsupported = (SUPPORTED_10baseT_Half  |\n\t\t\t   SUPPORTED_10baseT_Full  |\n\t\t\t   SUPPORTED_100baseT_Half |\n\t\t\t   SUPPORTED_100baseT_Full |\n\t\t\t   SUPPORTED_Autoneg       |\n\t\t\t   SUPPORTED_TP);\n\tif (hw->link_cap_flags & ATL1C_LINK_CAP_1000M)\n\t\tsupported |= SUPPORTED_1000baseT_Full;\n\n\tadvertising = ADVERTISED_TP;\n\n\tadvertising |= hw->autoneg_advertised;\n\n\tcmd->base.port = PORT_TP;\n\tcmd->base.phy_address = 0;\n\n\tif (adapter->link_speed != SPEED_0) {\n\t\tcmd->base.speed = adapter->link_speed;\n\t\tif (adapter->link_duplex == FULL_DUPLEX)\n\t\t\tcmd->base.duplex = DUPLEX_FULL;\n\t\telse\n\t\t\tcmd->base.duplex = DUPLEX_HALF;\n\t} else {\n\t\tcmd->base.speed = SPEED_UNKNOWN;\n\t\tcmd->base.duplex = DUPLEX_UNKNOWN;\n\t}\n\n\tcmd->base.autoneg = AUTONEG_ENABLE;\n\n\tethtool_convert_legacy_u32_to_link_mode(cmd->link_modes.supported,\n\t\t\t\t\t\tsupported);\n\tethtool_convert_legacy_u32_to_link_mode(cmd->link_modes.advertising,\n\t\t\t\t\t\tadvertising);\n\n\treturn 0;\n}\n\nstatic int atl1c_set_link_ksettings(struct net_device *netdev,\n\t\t\t\t    const struct ethtool_link_ksettings *cmd)\n{\n\tstruct atl1c_adapter *adapter = netdev_priv(netdev);\n\tstruct atl1c_hw *hw = &adapter->hw;\n\tu16  autoneg_advertised;\n\n\twhile (test_and_set_bit(__AT_RESETTING, &adapter->flags))\n\t\tmsleep(1);\n\n\tif (cmd->base.autoneg == AUTONEG_ENABLE) {\n\t\tautoneg_advertised = ADVERTISED_Autoneg;\n\t} else {\n\t\tu32 speed = cmd->base.speed;\n\t\tif (speed == SPEED_1000) {\n\t\t\tif (cmd->base.duplex != DUPLEX_FULL) {\n\t\t\t\tif (netif_msg_link(adapter))\n\t\t\t\t\tdev_warn(&adapter->pdev->dev,\n\t\t\t\t\t\t\"1000M half is invalid\\n\");\n\t\t\t\tclear_bit(__AT_RESETTING, &adapter->flags);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tautoneg_advertised = ADVERTISED_1000baseT_Full;\n\t\t} else if (speed == SPEED_100) {\n\t\t\tif (cmd->base.duplex == DUPLEX_FULL)\n\t\t\t\tautoneg_advertised = ADVERTISED_100baseT_Full;\n\t\t\telse\n\t\t\t\tautoneg_advertised = ADVERTISED_100baseT_Half;\n\t\t} else {\n\t\t\tif (cmd->base.duplex == DUPLEX_FULL)\n\t\t\t\tautoneg_advertised = ADVERTISED_10baseT_Full;\n\t\t\telse\n\t\t\t\tautoneg_advertised = ADVERTISED_10baseT_Half;\n\t\t}\n\t}\n\n\tif (hw->autoneg_advertised != autoneg_advertised) {\n\t\thw->autoneg_advertised = autoneg_advertised;\n\t\tif (atl1c_restart_autoneg(hw) != 0) {\n\t\t\tif (netif_msg_link(adapter))\n\t\t\t\tdev_warn(&adapter->pdev->dev,\n\t\t\t\t\t\"ethtool speed/duplex setting failed\\n\");\n\t\t\tclear_bit(__AT_RESETTING, &adapter->flags);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tclear_bit(__AT_RESETTING, &adapter->flags);\n\treturn 0;\n}\n\nstatic u32 atl1c_get_msglevel(struct net_device *netdev)\n{\n\tstruct atl1c_adapter *adapter = netdev_priv(netdev);\n\treturn adapter->msg_enable;\n}\n\nstatic void atl1c_set_msglevel(struct net_device *netdev, u32 data)\n{\n\tstruct atl1c_adapter *adapter = netdev_priv(netdev);\n\tadapter->msg_enable = data;\n}\n\nstatic int atl1c_get_regs_len(struct net_device *netdev)\n{\n\treturn AT_REGS_LEN;\n}\n\nstatic void atl1c_get_regs(struct net_device *netdev,\n\t\t\t   struct ethtool_regs *regs, void *p)\n{\n\tstruct atl1c_adapter *adapter = netdev_priv(netdev);\n\tstruct atl1c_hw *hw = &adapter->hw;\n\tu32 *regs_buff = p;\n\tu16 phy_data;\n\n\tmemset(p, 0, AT_REGS_LEN);\n\n\tregs->version = 1;\n\tAT_READ_REG(hw, REG_PM_CTRL, \t\t  p++);\n\tAT_READ_REG(hw, REG_MAC_HALF_DUPLX_CTRL,  p++);\n\tAT_READ_REG(hw, REG_TWSI_CTRL, \t\t  p++);\n\tAT_READ_REG(hw, REG_PCIE_DEV_MISC_CTRL,   p++);\n\tAT_READ_REG(hw, REG_MASTER_CTRL, \t  p++);\n\tAT_READ_REG(hw, REG_MANUAL_TIMER_INIT,    p++);\n\tAT_READ_REG(hw, REG_IRQ_MODRT_TIMER_INIT, p++);\n\tAT_READ_REG(hw, REG_GPHY_CTRL, \t\t  p++);\n\tAT_READ_REG(hw, REG_LINK_CTRL, \t\t  p++);\n\tAT_READ_REG(hw, REG_IDLE_STATUS, \t  p++);\n\tAT_READ_REG(hw, REG_MDIO_CTRL, \t\t  p++);\n\tAT_READ_REG(hw, REG_SERDES,\t\t  p++);\n\tAT_READ_REG(hw, REG_MAC_CTRL, \t\t  p++);\n\tAT_READ_REG(hw, REG_MAC_IPG_IFG, \t  p++);\n\tAT_READ_REG(hw, REG_MAC_STA_ADDR, \t  p++);\n\tAT_READ_REG(hw, REG_MAC_STA_ADDR+4, \t  p++);\n\tAT_READ_REG(hw, REG_RX_HASH_TABLE, \t  p++);\n\tAT_READ_REG(hw, REG_RX_HASH_TABLE+4, \t  p++);\n\tAT_READ_REG(hw, REG_RXQ_CTRL, \t\t  p++);\n\tAT_READ_REG(hw, REG_TXQ_CTRL, \t\t  p++);\n\tAT_READ_REG(hw, REG_MTU, \t\t  p++);\n\tAT_READ_REG(hw, REG_WOL_CTRL, \t\t  p++);\n\n\tatl1c_read_phy_reg(hw, MII_BMCR, &phy_data);\n\tregs_buff[AT_REGS_LEN/sizeof(u32) - 2] = (u32) phy_data;\n\tatl1c_read_phy_reg(hw, MII_BMSR, &phy_data);\n\tregs_buff[AT_REGS_LEN/sizeof(u32) - 1] = (u32) phy_data;\n}\n\nstatic int atl1c_get_eeprom_len(struct net_device *netdev)\n{\n\tstruct atl1c_adapter *adapter = netdev_priv(netdev);\n\n\tif (atl1c_check_eeprom_exist(&adapter->hw))\n\t\treturn AT_EEPROM_LEN;\n\telse\n\t\treturn 0;\n}\n\nstatic int atl1c_get_eeprom(struct net_device *netdev,\n\t\tstruct ethtool_eeprom *eeprom, u8 *bytes)\n{\n\tstruct atl1c_adapter *adapter = netdev_priv(netdev);\n\tstruct atl1c_hw *hw = &adapter->hw;\n\tu32 *eeprom_buff;\n\tint first_dword, last_dword;\n\tint ret_val = 0;\n\tint i;\n\n\tif (eeprom->len == 0)\n\t\treturn -EINVAL;\n\n\tif (!atl1c_check_eeprom_exist(hw))  \n\t\treturn -EINVAL;\n\n\teeprom->magic = adapter->pdev->vendor |\n\t\t\t(adapter->pdev->device << 16);\n\n\tfirst_dword = eeprom->offset >> 2;\n\tlast_dword = (eeprom->offset + eeprom->len - 1) >> 2;\n\n\teeprom_buff = kmalloc_array(last_dword - first_dword + 1, sizeof(u32),\n\t\t\t\t    GFP_KERNEL);\n\tif (eeprom_buff == NULL)\n\t\treturn -ENOMEM;\n\n\tfor (i = first_dword; i < last_dword; i++) {\n\t\tif (!atl1c_read_eeprom(hw, i * 4, &(eeprom_buff[i-first_dword]))) {\n\t\t\tkfree(eeprom_buff);\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\tmemcpy(bytes, (u8 *)eeprom_buff + (eeprom->offset & 3),\n\t\t\teeprom->len);\n\tkfree(eeprom_buff);\n\n\treturn ret_val;\n\treturn 0;\n}\n\nstatic void atl1c_get_drvinfo(struct net_device *netdev,\n\t\tstruct ethtool_drvinfo *drvinfo)\n{\n\tstruct atl1c_adapter *adapter = netdev_priv(netdev);\n\n\tstrscpy(drvinfo->driver,  atl1c_driver_name, sizeof(drvinfo->driver));\n\tstrscpy(drvinfo->bus_info, pci_name(adapter->pdev),\n\t\tsizeof(drvinfo->bus_info));\n}\n\nstatic void atl1c_get_wol(struct net_device *netdev,\n\t\t\t  struct ethtool_wolinfo *wol)\n{\n\tstruct atl1c_adapter *adapter = netdev_priv(netdev);\n\n\twol->supported = WAKE_MAGIC | WAKE_PHY;\n\twol->wolopts = 0;\n\n\tif (adapter->wol & AT_WUFC_EX)\n\t\twol->wolopts |= WAKE_UCAST;\n\tif (adapter->wol & AT_WUFC_MC)\n\t\twol->wolopts |= WAKE_MCAST;\n\tif (adapter->wol & AT_WUFC_BC)\n\t\twol->wolopts |= WAKE_BCAST;\n\tif (adapter->wol & AT_WUFC_MAG)\n\t\twol->wolopts |= WAKE_MAGIC;\n\tif (adapter->wol & AT_WUFC_LNKC)\n\t\twol->wolopts |= WAKE_PHY;\n}\n\nstatic int atl1c_set_wol(struct net_device *netdev, struct ethtool_wolinfo *wol)\n{\n\tstruct atl1c_adapter *adapter = netdev_priv(netdev);\n\n\tif (wol->wolopts & (WAKE_ARP | WAKE_MAGICSECURE |\n\t\t\t    WAKE_UCAST | WAKE_BCAST | WAKE_MCAST))\n\t\treturn -EOPNOTSUPP;\n\t \n\tadapter->wol = 0;\n\n\tif (wol->wolopts & WAKE_MAGIC)\n\t\tadapter->wol |= AT_WUFC_MAG;\n\tif (wol->wolopts & WAKE_PHY)\n\t\tadapter->wol |= AT_WUFC_LNKC;\n\n\tdevice_set_wakeup_enable(&adapter->pdev->dev, adapter->wol);\n\n\treturn 0;\n}\n\nstatic int atl1c_nway_reset(struct net_device *netdev)\n{\n\tstruct atl1c_adapter *adapter = netdev_priv(netdev);\n\tif (netif_running(netdev))\n\t\tatl1c_reinit_locked(adapter);\n\treturn 0;\n}\n\nstatic const struct ethtool_ops atl1c_ethtool_ops = {\n\t.get_drvinfo            = atl1c_get_drvinfo,\n\t.get_regs_len           = atl1c_get_regs_len,\n\t.get_regs               = atl1c_get_regs,\n\t.get_wol                = atl1c_get_wol,\n\t.set_wol                = atl1c_set_wol,\n\t.get_msglevel           = atl1c_get_msglevel,\n\t.set_msglevel           = atl1c_set_msglevel,\n\t.nway_reset             = atl1c_nway_reset,\n\t.get_link               = ethtool_op_get_link,\n\t.get_eeprom_len         = atl1c_get_eeprom_len,\n\t.get_eeprom             = atl1c_get_eeprom,\n\t.get_link_ksettings     = atl1c_get_link_ksettings,\n\t.set_link_ksettings     = atl1c_set_link_ksettings,\n};\n\nvoid atl1c_set_ethtool_ops(struct net_device *netdev)\n{\n\tnetdev->ethtool_ops = &atl1c_ethtool_ops;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}