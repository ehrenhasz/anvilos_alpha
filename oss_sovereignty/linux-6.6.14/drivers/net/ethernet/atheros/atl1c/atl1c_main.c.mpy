{
  "module_name": "atl1c_main.c",
  "hash_id": "3a44fdd7f3a0e3a3f374f9356aa2de370c229273f8df685d84865bfc346e0870",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/atheros/atl1c/atl1c_main.c",
  "human_readable_source": "\n \n\n#include \"atl1c.h\"\n\nchar atl1c_driver_name[] = \"atl1c\";\n\n \nstatic const struct pci_device_id atl1c_pci_tbl[] = {\n\t{PCI_DEVICE(PCI_VENDOR_ID_ATTANSIC, PCI_DEVICE_ID_ATTANSIC_L1C)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_ATTANSIC, PCI_DEVICE_ID_ATTANSIC_L2C)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_ATTANSIC, PCI_DEVICE_ID_ATHEROS_L2C_B)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_ATTANSIC, PCI_DEVICE_ID_ATHEROS_L2C_B2)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_ATTANSIC, PCI_DEVICE_ID_ATHEROS_L1D)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_ATTANSIC, PCI_DEVICE_ID_ATHEROS_L1D_2_0)},\n\t \n\t{ 0 }\n};\nMODULE_DEVICE_TABLE(pci, atl1c_pci_tbl);\n\nMODULE_AUTHOR(\"Jie Yang\");\nMODULE_AUTHOR(\"Qualcomm Atheros Inc.\");\nMODULE_DESCRIPTION(\"Qualcomm Atheros 100/1000M Ethernet Network Driver\");\nMODULE_LICENSE(\"GPL\");\n\nstruct atl1c_qregs {\n\tu16 tpd_addr_lo;\n\tu16 tpd_prod;\n\tu16 tpd_cons;\n\tu16 rfd_addr_lo;\n\tu16 rrd_addr_lo;\n\tu16 rfd_prod;\n\tu32 tx_isr;\n\tu32 rx_isr;\n};\n\nstatic struct atl1c_qregs atl1c_qregs[AT_MAX_TRANSMIT_QUEUE] = {\n\t{\n\t\tREG_TPD_PRI0_ADDR_LO, REG_TPD_PRI0_PIDX, REG_TPD_PRI0_CIDX,\n\t\tREG_RFD0_HEAD_ADDR_LO, REG_RRD0_HEAD_ADDR_LO,\n\t\tREG_MB_RFD0_PROD_IDX, ISR_TX_PKT_0, ISR_RX_PKT_0\n\t},\n\t{\n\t\tREG_TPD_PRI1_ADDR_LO, REG_TPD_PRI1_PIDX, REG_TPD_PRI1_CIDX,\n\t\tREG_RFD1_HEAD_ADDR_LO, REG_RRD1_HEAD_ADDR_LO,\n\t\tREG_MB_RFD1_PROD_IDX, ISR_TX_PKT_1, ISR_RX_PKT_1\n\t},\n\t{\n\t\tREG_TPD_PRI2_ADDR_LO, REG_TPD_PRI2_PIDX, REG_TPD_PRI2_CIDX,\n\t\tREG_RFD2_HEAD_ADDR_LO, REG_RRD2_HEAD_ADDR_LO,\n\t\tREG_MB_RFD2_PROD_IDX, ISR_TX_PKT_2, ISR_RX_PKT_2\n\t},\n\t{\n\t\tREG_TPD_PRI3_ADDR_LO, REG_TPD_PRI3_PIDX, REG_TPD_PRI3_CIDX,\n\t\tREG_RFD3_HEAD_ADDR_LO, REG_RRD3_HEAD_ADDR_LO,\n\t\tREG_MB_RFD3_PROD_IDX, ISR_TX_PKT_3, ISR_RX_PKT_3\n\t},\n};\n\nstatic int atl1c_stop_mac(struct atl1c_hw *hw);\nstatic void atl1c_disable_l0s_l1(struct atl1c_hw *hw);\nstatic void atl1c_set_aspm(struct atl1c_hw *hw, u16 link_speed);\nstatic void atl1c_start_mac(struct atl1c_adapter *adapter);\nstatic int atl1c_up(struct atl1c_adapter *adapter);\nstatic void atl1c_down(struct atl1c_adapter *adapter);\nstatic int atl1c_reset_mac(struct atl1c_hw *hw);\nstatic void atl1c_reset_dma_ring(struct atl1c_adapter *adapter);\nstatic int atl1c_configure(struct atl1c_adapter *adapter);\nstatic int atl1c_alloc_rx_buffer(struct atl1c_adapter *adapter, u32 queue,\n\t\t\t\t bool napi_mode);\n\n\nstatic const u32 atl1c_default_msg = NETIF_MSG_DRV | NETIF_MSG_PROBE |\n\tNETIF_MSG_LINK | NETIF_MSG_TIMER | NETIF_MSG_IFDOWN | NETIF_MSG_IFUP;\nstatic void atl1c_pcie_patch(struct atl1c_hw *hw)\n{\n\tu32 mst_data, data;\n\n\t \n\tAT_READ_REG(hw, REG_MASTER_CTRL, &mst_data);\n\tmst_data &= ~MASTER_CTRL_CLK_SEL_DIS;\n\tAT_WRITE_REG(hw, REG_MASTER_CTRL, mst_data);\n\n\t \n\tif (hw->nic_type == athr_l1c || hw->nic_type == athr_l2c) {\n\t\tAT_READ_REG(hw, REG_PCIE_PHYMISC, &data);\n\t\tdata |= PCIE_PHYMISC_FORCE_RCV_DET;\n\t\tAT_WRITE_REG(hw, REG_PCIE_PHYMISC, data);\n\t} else {  \n\t\tif (!(mst_data & MASTER_CTRL_WAKEN_25M))\n\t\t\tAT_WRITE_REG(hw, REG_MASTER_CTRL,\n\t\t\t\tmst_data | MASTER_CTRL_WAKEN_25M);\n\t}\n\t \n\tif (hw->nic_type == athr_l2c_b && hw->revision_id == L2CB_V10) {\n\t\tAT_READ_REG(hw, REG_PCIE_PHYMISC2, &data);\n\t\tdata = FIELD_SETX(data, PCIE_PHYMISC2_CDR_BW,\n\t\t\tL2CB1_PCIE_PHYMISC2_CDR_BW);\n\t\tdata = FIELD_SETX(data, PCIE_PHYMISC2_L0S_TH,\n\t\t\tL2CB1_PCIE_PHYMISC2_L0S_TH);\n\t\tAT_WRITE_REG(hw, REG_PCIE_PHYMISC2, data);\n\t\t \n\t\tAT_READ_REG(hw, REG_LINK_CTRL, &data);\n\t\tdata |= LINK_CTRL_EXT_SYNC;\n\t\tAT_WRITE_REG(hw, REG_LINK_CTRL, data);\n\t}\n\t \n\tif (hw->nic_type == athr_l2c_b || hw->nic_type == athr_l1d) {\n\t\tAT_READ_REG(hw, REG_PM_CTRL, &data);\n\t\tdata |= PM_CTRL_L0S_BUFSRX_EN;\n\t\tAT_WRITE_REG(hw, REG_PM_CTRL, data);\n\t\t \n\t\tAT_READ_REG(hw, REG_DMA_DBG, &data);\n\t\tAT_WRITE_REG(hw, REG_DMA_DBG, data & ~DMA_DBG_VENDOR_MSG);\n\t}\n}\n\n \n \nstatic void atl1c_reset_pcie(struct atl1c_hw *hw, u32 flag)\n{\n\tu32 data;\n\tu32 pci_cmd;\n\tstruct pci_dev *pdev = hw->adapter->pdev;\n\tint pos;\n\n\tAT_READ_REG(hw, PCI_COMMAND, &pci_cmd);\n\tpci_cmd &= ~PCI_COMMAND_INTX_DISABLE;\n\tpci_cmd |= (PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER |\n\t\tPCI_COMMAND_IO);\n\tAT_WRITE_REG(hw, PCI_COMMAND, pci_cmd);\n\n\t \n\tpci_enable_wake(pdev, PCI_D3hot, 0);\n\tpci_enable_wake(pdev, PCI_D3cold, 0);\n\t \n\tAT_READ_REG(hw, REG_WOL_CTRL, &data);\n\tAT_WRITE_REG(hw, REG_WOL_CTRL, 0);\n\n\t \n\tpos = pci_find_ext_capability(pdev, PCI_EXT_CAP_ID_ERR);\n\tif (pos) {\n\t\tpci_read_config_dword(pdev, pos + PCI_ERR_UNCOR_SEVER, &data);\n\t\tdata &= ~(PCI_ERR_UNC_DLP | PCI_ERR_UNC_FCP);\n\t\tpci_write_config_dword(pdev, pos + PCI_ERR_UNCOR_SEVER, data);\n\t}\n\t \n\tpcie_capability_write_word(pdev, PCI_EXP_DEVSTA,\n\t\t\tPCI_EXP_DEVSTA_NFED |\n\t\t\tPCI_EXP_DEVSTA_FED |\n\t\t\tPCI_EXP_DEVSTA_CED |\n\t\t\tPCI_EXP_DEVSTA_URD);\n\n\tAT_READ_REG(hw, REG_LTSSM_ID_CTRL, &data);\n\tdata &= ~LTSSM_ID_EN_WRO;\n\tAT_WRITE_REG(hw, REG_LTSSM_ID_CTRL, data);\n\n\tatl1c_pcie_patch(hw);\n\tif (flag & ATL1C_PCIE_L0S_L1_DISABLE)\n\t\tatl1c_disable_l0s_l1(hw);\n\n\tmsleep(5);\n}\n\n \nstatic inline void atl1c_irq_enable(struct atl1c_adapter *adapter)\n{\n\tif (likely(atomic_dec_and_test(&adapter->irq_sem))) {\n\t\tAT_WRITE_REG(&adapter->hw, REG_ISR, 0x7FFFFFFF);\n\t\tAT_WRITE_REG(&adapter->hw, REG_IMR, adapter->hw.intr_mask);\n\t\tAT_WRITE_FLUSH(&adapter->hw);\n\t}\n}\n\n \nstatic inline void atl1c_irq_disable(struct atl1c_adapter *adapter)\n{\n\tatomic_inc(&adapter->irq_sem);\n\tAT_WRITE_REG(&adapter->hw, REG_IMR, 0);\n\tAT_WRITE_REG(&adapter->hw, REG_ISR, ISR_DIS_INT);\n\tAT_WRITE_FLUSH(&adapter->hw);\n\tsynchronize_irq(adapter->pdev->irq);\n}\n\n \nstatic u32 atl1c_wait_until_idle(struct atl1c_hw *hw, u32 modu_ctrl)\n{\n\tint timeout;\n\tu32 data;\n\n\tfor (timeout = 0; timeout < AT_HW_MAX_IDLE_DELAY; timeout++) {\n\t\tAT_READ_REG(hw, REG_IDLE_STATUS, &data);\n\t\tif ((data & modu_ctrl) == 0)\n\t\t\treturn 0;\n\t\tmsleep(1);\n\t}\n\treturn data;\n}\n\n \nstatic void atl1c_phy_config(struct timer_list *t)\n{\n\tstruct atl1c_adapter *adapter = from_timer(adapter, t,\n\t\t\t\t\t\t   phy_config_timer);\n\tstruct atl1c_hw *hw = &adapter->hw;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&adapter->mdio_lock, flags);\n\tatl1c_restart_autoneg(hw);\n\tspin_unlock_irqrestore(&adapter->mdio_lock, flags);\n}\n\nvoid atl1c_reinit_locked(struct atl1c_adapter *adapter)\n{\n\tatl1c_down(adapter);\n\tatl1c_up(adapter);\n\tclear_bit(__AT_RESETTING, &adapter->flags);\n}\n\nstatic void atl1c_check_link_status(struct atl1c_adapter *adapter)\n{\n\tstruct atl1c_hw *hw = &adapter->hw;\n\tstruct net_device *netdev = adapter->netdev;\n\tstruct pci_dev    *pdev   = adapter->pdev;\n\tint err;\n\tunsigned long flags;\n\tu16 speed, duplex;\n\tbool link;\n\n\tspin_lock_irqsave(&adapter->mdio_lock, flags);\n\tlink = atl1c_get_link_status(hw);\n\tspin_unlock_irqrestore(&adapter->mdio_lock, flags);\n\n\tif (!link) {\n\t\t \n\t\tnetif_carrier_off(netdev);\n\t\thw->hibernate = true;\n\t\tif (atl1c_reset_mac(hw) != 0)\n\t\t\tif (netif_msg_hw(adapter))\n\t\t\t\tdev_warn(&pdev->dev, \"reset mac failed\\n\");\n\t\tatl1c_set_aspm(hw, SPEED_0);\n\t\tatl1c_post_phy_linkchg(hw, SPEED_0);\n\t\tatl1c_reset_dma_ring(adapter);\n\t\tatl1c_configure(adapter);\n\t} else {\n\t\t \n\t\thw->hibernate = false;\n\t\tspin_lock_irqsave(&adapter->mdio_lock, flags);\n\t\terr = atl1c_get_speed_and_duplex(hw, &speed, &duplex);\n\t\tspin_unlock_irqrestore(&adapter->mdio_lock, flags);\n\t\tif (unlikely(err))\n\t\t\treturn;\n\t\t \n\t\tif (adapter->link_speed != speed ||\n\t\t    adapter->link_duplex != duplex) {\n\t\t\tadapter->link_speed  = speed;\n\t\t\tadapter->link_duplex = duplex;\n\t\t\tatl1c_set_aspm(hw, speed);\n\t\t\tatl1c_post_phy_linkchg(hw, speed);\n\t\t\tatl1c_start_mac(adapter);\n\t\t\tif (netif_msg_link(adapter))\n\t\t\t\tdev_info(&pdev->dev,\n\t\t\t\t\t\"%s: %s NIC Link is Up<%d Mbps %s>\\n\",\n\t\t\t\t\tatl1c_driver_name, netdev->name,\n\t\t\t\t\tadapter->link_speed,\n\t\t\t\t\tadapter->link_duplex == FULL_DUPLEX ?\n\t\t\t\t\t\"Full Duplex\" : \"Half Duplex\");\n\t\t}\n\t\tif (!netif_carrier_ok(netdev))\n\t\t\tnetif_carrier_on(netdev);\n\t}\n}\n\nstatic void atl1c_link_chg_event(struct atl1c_adapter *adapter)\n{\n\tstruct net_device *netdev = adapter->netdev;\n\tstruct pci_dev    *pdev   = adapter->pdev;\n\tbool link;\n\n\tspin_lock(&adapter->mdio_lock);\n\tlink = atl1c_get_link_status(&adapter->hw);\n\tspin_unlock(&adapter->mdio_lock);\n\t \n\tif (!link) {\n\t\tif (netif_carrier_ok(netdev)) {\n\t\t\t \n\t\t\tnetif_carrier_off(netdev);\n\t\t\tif (netif_msg_link(adapter))\n\t\t\t\tdev_info(&pdev->dev,\n\t\t\t\t\t\"%s: %s NIC Link is Down\\n\",\n\t\t\t\t\tatl1c_driver_name, netdev->name);\n\t\t\tadapter->link_speed = SPEED_0;\n\t\t}\n\t}\n\n\tset_bit(ATL1C_WORK_EVENT_LINK_CHANGE, &adapter->work_event);\n\tschedule_work(&adapter->common_task);\n}\n\nstatic void atl1c_common_task(struct work_struct *work)\n{\n\tstruct atl1c_adapter *adapter;\n\tstruct net_device *netdev;\n\n\tadapter = container_of(work, struct atl1c_adapter, common_task);\n\tnetdev = adapter->netdev;\n\n\tif (test_bit(__AT_DOWN, &adapter->flags))\n\t\treturn;\n\n\tif (test_and_clear_bit(ATL1C_WORK_EVENT_RESET, &adapter->work_event)) {\n\t\tnetif_device_detach(netdev);\n\t\tatl1c_down(adapter);\n\t\tatl1c_up(adapter);\n\t\tnetif_device_attach(netdev);\n\t}\n\n\tif (test_and_clear_bit(ATL1C_WORK_EVENT_LINK_CHANGE,\n\t\t&adapter->work_event)) {\n\t\tatl1c_irq_disable(adapter);\n\t\tatl1c_check_link_status(adapter);\n\t\tatl1c_irq_enable(adapter);\n\t}\n}\n\n\nstatic void atl1c_del_timer(struct atl1c_adapter *adapter)\n{\n\tdel_timer_sync(&adapter->phy_config_timer);\n}\n\n\n \nstatic void atl1c_tx_timeout(struct net_device *netdev, unsigned int txqueue)\n{\n\tstruct atl1c_adapter *adapter = netdev_priv(netdev);\n\n\t \n\tset_bit(ATL1C_WORK_EVENT_RESET, &adapter->work_event);\n\tschedule_work(&adapter->common_task);\n}\n\n \nstatic void atl1c_set_multi(struct net_device *netdev)\n{\n\tstruct atl1c_adapter *adapter = netdev_priv(netdev);\n\tstruct atl1c_hw *hw = &adapter->hw;\n\tstruct netdev_hw_addr *ha;\n\tu32 mac_ctrl_data;\n\tu32 hash_value;\n\n\t \n\tAT_READ_REG(hw, REG_MAC_CTRL, &mac_ctrl_data);\n\n\tif (netdev->flags & IFF_PROMISC) {\n\t\tmac_ctrl_data |= MAC_CTRL_PROMIS_EN;\n\t} else if (netdev->flags & IFF_ALLMULTI) {\n\t\tmac_ctrl_data |= MAC_CTRL_MC_ALL_EN;\n\t\tmac_ctrl_data &= ~MAC_CTRL_PROMIS_EN;\n\t} else {\n\t\tmac_ctrl_data &= ~(MAC_CTRL_PROMIS_EN | MAC_CTRL_MC_ALL_EN);\n\t}\n\n\tAT_WRITE_REG(hw, REG_MAC_CTRL, mac_ctrl_data);\n\n\t \n\tAT_WRITE_REG(hw, REG_RX_HASH_TABLE, 0);\n\tAT_WRITE_REG_ARRAY(hw, REG_RX_HASH_TABLE, 1, 0);\n\n\t \n\tnetdev_for_each_mc_addr(ha, netdev) {\n\t\thash_value = atl1c_hash_mc_addr(hw, ha->addr);\n\t\tatl1c_hash_set(hw, hash_value);\n\t}\n}\n\nstatic void __atl1c_vlan_mode(netdev_features_t features, u32 *mac_ctrl_data)\n{\n\tif (features & NETIF_F_HW_VLAN_CTAG_RX) {\n\t\t \n\t\t*mac_ctrl_data |= MAC_CTRL_RMV_VLAN;\n\t} else {\n\t\t \n\t\t*mac_ctrl_data &= ~MAC_CTRL_RMV_VLAN;\n\t}\n}\n\nstatic void atl1c_vlan_mode(struct net_device *netdev,\n\tnetdev_features_t features)\n{\n\tstruct atl1c_adapter *adapter = netdev_priv(netdev);\n\tstruct pci_dev *pdev = adapter->pdev;\n\tu32 mac_ctrl_data = 0;\n\n\tif (netif_msg_pktdata(adapter))\n\t\tdev_dbg(&pdev->dev, \"atl1c_vlan_mode\\n\");\n\n\tatl1c_irq_disable(adapter);\n\tAT_READ_REG(&adapter->hw, REG_MAC_CTRL, &mac_ctrl_data);\n\t__atl1c_vlan_mode(features, &mac_ctrl_data);\n\tAT_WRITE_REG(&adapter->hw, REG_MAC_CTRL, mac_ctrl_data);\n\tatl1c_irq_enable(adapter);\n}\n\nstatic void atl1c_restore_vlan(struct atl1c_adapter *adapter)\n{\n\tstruct pci_dev *pdev = adapter->pdev;\n\n\tif (netif_msg_pktdata(adapter))\n\t\tdev_dbg(&pdev->dev, \"atl1c_restore_vlan\\n\");\n\tatl1c_vlan_mode(adapter->netdev, adapter->netdev->features);\n}\n\n \nstatic int atl1c_set_mac_addr(struct net_device *netdev, void *p)\n{\n\tstruct atl1c_adapter *adapter = netdev_priv(netdev);\n\tstruct sockaddr *addr = p;\n\n\tif (!is_valid_ether_addr(addr->sa_data))\n\t\treturn -EADDRNOTAVAIL;\n\n\tif (netif_running(netdev))\n\t\treturn -EBUSY;\n\n\teth_hw_addr_set(netdev, addr->sa_data);\n\tmemcpy(adapter->hw.mac_addr, addr->sa_data, netdev->addr_len);\n\n\tatl1c_hw_set_mac_addr(&adapter->hw, adapter->hw.mac_addr);\n\n\treturn 0;\n}\n\nstatic void atl1c_set_rxbufsize(struct atl1c_adapter *adapter,\n\t\t\t\tstruct net_device *dev)\n{\n\tint mtu = dev->mtu;\n\n\tadapter->rx_buffer_len = mtu > AT_RX_BUF_SIZE ?\n\t\troundup(mtu + ETH_HLEN + ETH_FCS_LEN + VLAN_HLEN, 8) : AT_RX_BUF_SIZE;\n}\n\nstatic netdev_features_t atl1c_fix_features(struct net_device *netdev,\n\tnetdev_features_t features)\n{\n\tstruct atl1c_adapter *adapter = netdev_priv(netdev);\n\tstruct atl1c_hw *hw = &adapter->hw;\n\n\t \n\tif (features & NETIF_F_HW_VLAN_CTAG_RX)\n\t\tfeatures |= NETIF_F_HW_VLAN_CTAG_TX;\n\telse\n\t\tfeatures &= ~NETIF_F_HW_VLAN_CTAG_TX;\n\n\tif (hw->nic_type != athr_mt) {\n\t\tif (netdev->mtu > MAX_TSO_FRAME_SIZE)\n\t\t\tfeatures &= ~(NETIF_F_TSO | NETIF_F_TSO6);\n\t}\n\n\treturn features;\n}\n\nstatic int atl1c_set_features(struct net_device *netdev,\n\tnetdev_features_t features)\n{\n\tnetdev_features_t changed = netdev->features ^ features;\n\n\tif (changed & NETIF_F_HW_VLAN_CTAG_RX)\n\t\tatl1c_vlan_mode(netdev, features);\n\n\treturn 0;\n}\n\nstatic void atl1c_set_max_mtu(struct net_device *netdev)\n{\n\tstruct atl1c_adapter *adapter = netdev_priv(netdev);\n\tstruct atl1c_hw *hw = &adapter->hw;\n\n\tswitch (hw->nic_type) {\n\t \n\tcase athr_l1c:\n\tcase athr_l1d:\n\tcase athr_l1d_2:\n\t\tnetdev->max_mtu = MAX_JUMBO_FRAME_SIZE -\n\t\t\t(ETH_HLEN + ETH_FCS_LEN + VLAN_HLEN);\n\t\tbreak;\n\tcase athr_mt:\n\t\tnetdev->max_mtu = 9500;\n\t\tbreak;\n\t\t \n\tdefault:\n\t\tnetdev->max_mtu = ETH_DATA_LEN;\n\t\tbreak;\n\t}\n}\n\n \nstatic int atl1c_change_mtu(struct net_device *netdev, int new_mtu)\n{\n\tstruct atl1c_adapter *adapter = netdev_priv(netdev);\n\n\t \n\tif (netif_running(netdev)) {\n\t\twhile (test_and_set_bit(__AT_RESETTING, &adapter->flags))\n\t\t\tmsleep(1);\n\t\tnetdev->mtu = new_mtu;\n\t\tadapter->hw.max_frame_size = new_mtu;\n\t\tatl1c_set_rxbufsize(adapter, netdev);\n\t\tatl1c_down(adapter);\n\t\tnetdev_update_features(netdev);\n\t\tatl1c_up(adapter);\n\t\tclear_bit(__AT_RESETTING, &adapter->flags);\n\t}\n\treturn 0;\n}\n\n \nstatic int atl1c_mdio_read(struct net_device *netdev, int phy_id, int reg_num)\n{\n\tstruct atl1c_adapter *adapter = netdev_priv(netdev);\n\tu16 result;\n\n\tatl1c_read_phy_reg(&adapter->hw, reg_num, &result);\n\treturn result;\n}\n\nstatic void atl1c_mdio_write(struct net_device *netdev, int phy_id,\n\t\t\t     int reg_num, int val)\n{\n\tstruct atl1c_adapter *adapter = netdev_priv(netdev);\n\n\tatl1c_write_phy_reg(&adapter->hw, reg_num, val);\n}\n\nstatic int atl1c_mii_ioctl(struct net_device *netdev,\n\t\t\t   struct ifreq *ifr, int cmd)\n{\n\tstruct atl1c_adapter *adapter = netdev_priv(netdev);\n\tstruct pci_dev *pdev = adapter->pdev;\n\tstruct mii_ioctl_data *data = if_mii(ifr);\n\tunsigned long flags;\n\tint retval = 0;\n\n\tif (!netif_running(netdev))\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&adapter->mdio_lock, flags);\n\tswitch (cmd) {\n\tcase SIOCGMIIPHY:\n\t\tdata->phy_id = 0;\n\t\tbreak;\n\n\tcase SIOCGMIIREG:\n\t\tif (atl1c_read_phy_reg(&adapter->hw, data->reg_num & 0x1F,\n\t\t\t\t    &data->val_out)) {\n\t\t\tretval = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\n\tcase SIOCSMIIREG:\n\t\tif (data->reg_num & ~(0x1F)) {\n\t\t\tretval = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tdev_dbg(&pdev->dev, \"<atl1c_mii_ioctl> write %x %x\",\n\t\t\t\tdata->reg_num, data->val_in);\n\t\tif (atl1c_write_phy_reg(&adapter->hw,\n\t\t\t\t     data->reg_num, data->val_in)) {\n\t\t\tretval = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tretval = -EOPNOTSUPP;\n\t\tbreak;\n\t}\nout:\n\tspin_unlock_irqrestore(&adapter->mdio_lock, flags);\n\treturn retval;\n}\n\nstatic int atl1c_ioctl(struct net_device *netdev, struct ifreq *ifr, int cmd)\n{\n\tswitch (cmd) {\n\tcase SIOCGMIIPHY:\n\tcase SIOCGMIIREG:\n\tcase SIOCSMIIREG:\n\t\treturn atl1c_mii_ioctl(netdev, ifr, cmd);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\n \nstatic int atl1c_alloc_queues(struct atl1c_adapter *adapter)\n{\n\treturn 0;\n}\n\nstatic enum atl1c_nic_type atl1c_get_mac_type(struct pci_dev *pdev,\n\t\t\t\t\t      u8 __iomem *hw_addr)\n{\n\tswitch (pdev->device) {\n\tcase PCI_DEVICE_ID_ATTANSIC_L2C:\n\t\treturn athr_l2c;\n\tcase PCI_DEVICE_ID_ATTANSIC_L1C:\n\t\treturn athr_l1c;\n\tcase PCI_DEVICE_ID_ATHEROS_L2C_B:\n\t\treturn athr_l2c_b;\n\tcase PCI_DEVICE_ID_ATHEROS_L2C_B2:\n\t\treturn athr_l2c_b2;\n\tcase PCI_DEVICE_ID_ATHEROS_L1D:\n\t\treturn athr_l1d;\n\tcase PCI_DEVICE_ID_ATHEROS_L1D_2_0:\n\t\tif (readl(hw_addr + REG_MT_MAGIC) == MT_MAGIC)\n\t\t\treturn athr_mt;\n\t\treturn athr_l1d_2;\n\tdefault:\n\t\treturn athr_l1c;\n\t}\n}\n\nstatic int atl1c_setup_mac_funcs(struct atl1c_hw *hw)\n{\n\tu32 link_ctrl_data;\n\n\tAT_READ_REG(hw, REG_LINK_CTRL, &link_ctrl_data);\n\n\thw->ctrl_flags = ATL1C_INTR_MODRT_ENABLE  |\n\t\t\t ATL1C_TXQ_MODE_ENHANCE;\n\thw->ctrl_flags |= ATL1C_ASPM_L0S_SUPPORT |\n\t\t\t  ATL1C_ASPM_L1_SUPPORT;\n\thw->ctrl_flags |= ATL1C_ASPM_CTRL_MON;\n\n\tif (hw->nic_type == athr_l1c ||\n\t    hw->nic_type == athr_l1d ||\n\t    hw->nic_type == athr_l1d_2)\n\t\thw->link_cap_flags |= ATL1C_LINK_CAP_1000M;\n\treturn 0;\n}\n\nstruct atl1c_platform_patch {\n\tu16 pci_did;\n\tu8  pci_revid;\n\tu16 subsystem_vid;\n\tu16 subsystem_did;\n\tu32 patch_flag;\n#define ATL1C_LINK_PATCH\t0x1\n};\nstatic const struct atl1c_platform_patch plats[] = {\n{0x2060, 0xC1, 0x1019, 0x8152, 0x1},\n{0x2060, 0xC1, 0x1019, 0x2060, 0x1},\n{0x2060, 0xC1, 0x1019, 0xE000, 0x1},\n{0x2062, 0xC0, 0x1019, 0x8152, 0x1},\n{0x2062, 0xC0, 0x1019, 0x2062, 0x1},\n{0x2062, 0xC0, 0x1458, 0xE000, 0x1},\n{0x2062, 0xC1, 0x1019, 0x8152, 0x1},\n{0x2062, 0xC1, 0x1019, 0x2062, 0x1},\n{0x2062, 0xC1, 0x1458, 0xE000, 0x1},\n{0x2062, 0xC1, 0x1565, 0x2802, 0x1},\n{0x2062, 0xC1, 0x1565, 0x2801, 0x1},\n{0x1073, 0xC0, 0x1019, 0x8151, 0x1},\n{0x1073, 0xC0, 0x1019, 0x1073, 0x1},\n{0x1073, 0xC0, 0x1458, 0xE000, 0x1},\n{0x1083, 0xC0, 0x1458, 0xE000, 0x1},\n{0x1083, 0xC0, 0x1019, 0x8151, 0x1},\n{0x1083, 0xC0, 0x1019, 0x1083, 0x1},\n{0x1083, 0xC0, 0x1462, 0x7680, 0x1},\n{0x1083, 0xC0, 0x1565, 0x2803, 0x1},\n{0},\n};\n\nstatic void atl1c_patch_assign(struct atl1c_hw *hw)\n{\n\tstruct pci_dev\t*pdev = hw->adapter->pdev;\n\tu32 misc_ctrl;\n\tint i = 0;\n\n\thw->msi_lnkpatch = false;\n\n\twhile (plats[i].pci_did != 0) {\n\t\tif (plats[i].pci_did == hw->device_id &&\n\t\t    plats[i].pci_revid == hw->revision_id &&\n\t\t    plats[i].subsystem_vid == hw->subsystem_vendor_id &&\n\t\t    plats[i].subsystem_did == hw->subsystem_id) {\n\t\t\tif (plats[i].patch_flag & ATL1C_LINK_PATCH)\n\t\t\t\thw->msi_lnkpatch = true;\n\t\t}\n\t\ti++;\n\t}\n\n\tif (hw->device_id == PCI_DEVICE_ID_ATHEROS_L2C_B2 &&\n\t    hw->revision_id == L2CB_V21) {\n\t\t \n\t\tpci_write_config_dword(pdev, REG_PCIE_IND_ACC_ADDR,\n\t\t\t\t       REG_PCIE_DEV_MISC_CTRL);\n\t\tpci_read_config_dword(pdev, REG_PCIE_IND_ACC_DATA, &misc_ctrl);\n\t\tmisc_ctrl &= ~0x100;\n\t\tpci_write_config_dword(pdev, REG_PCIE_IND_ACC_ADDR,\n\t\t\t\t       REG_PCIE_DEV_MISC_CTRL);\n\t\tpci_write_config_dword(pdev, REG_PCIE_IND_ACC_DATA, misc_ctrl);\n\t}\n}\n \nstatic int atl1c_sw_init(struct atl1c_adapter *adapter)\n{\n\tstruct atl1c_hw *hw   = &adapter->hw;\n\tstruct pci_dev\t*pdev = adapter->pdev;\n\tu32 revision;\n\tint i;\n\n\tadapter->wol = 0;\n\tdevice_set_wakeup_enable(&pdev->dev, false);\n\tadapter->link_speed = SPEED_0;\n\tadapter->link_duplex = FULL_DUPLEX;\n\tadapter->tpd_ring[0].count = 1024;\n\tadapter->rfd_ring[0].count = 512;\n\n\thw->vendor_id = pdev->vendor;\n\thw->device_id = pdev->device;\n\thw->subsystem_vendor_id = pdev->subsystem_vendor;\n\thw->subsystem_id = pdev->subsystem_device;\n\tpci_read_config_dword(pdev, PCI_CLASS_REVISION, &revision);\n\thw->revision_id = revision & 0xFF;\n\t \n\thw->hibernate = true;\n\thw->media_type = MEDIA_TYPE_AUTO_SENSOR;\n\tif (atl1c_setup_mac_funcs(hw) != 0) {\n\t\tdev_err(&pdev->dev, \"set mac function pointers failed\\n\");\n\t\treturn -1;\n\t}\n\tatl1c_patch_assign(hw);\n\n\thw->intr_mask = IMR_NORMAL_MASK;\n\tfor (i = 0; i < adapter->tx_queue_count; ++i)\n\t\thw->intr_mask |= atl1c_qregs[i].tx_isr;\n\tfor (i = 0; i < adapter->rx_queue_count; ++i)\n\t\thw->intr_mask |= atl1c_qregs[i].rx_isr;\n\thw->phy_configured = false;\n\thw->preamble_len = 7;\n\thw->max_frame_size = adapter->netdev->mtu;\n\thw->autoneg_advertised = ADVERTISED_Autoneg;\n\thw->indirect_tab = 0xE4E4E4E4;\n\thw->base_cpu = 0;\n\n\thw->ict = 50000;\t\t \n\thw->smb_timer = 200000;\t  \t \n\thw->rx_imt = 200;\n\thw->tx_imt = 1000;\n\n\thw->tpd_burst = 5;\n\thw->rfd_burst = 8;\n\thw->dma_order = atl1c_dma_ord_out;\n\thw->dmar_block = atl1c_dma_req_1024;\n\n\tif (atl1c_alloc_queues(adapter)) {\n\t\tdev_err(&pdev->dev, \"Unable to allocate memory for queues\\n\");\n\t\treturn -ENOMEM;\n\t}\n\t \n\tatl1c_set_rxbufsize(adapter, adapter->netdev);\n\tatomic_set(&adapter->irq_sem, 1);\n\tspin_lock_init(&adapter->mdio_lock);\n\tspin_lock_init(&adapter->hw.intr_mask_lock);\n\tset_bit(__AT_DOWN, &adapter->flags);\n\n\treturn 0;\n}\n\nstatic inline void atl1c_clean_buffer(struct pci_dev *pdev,\n\t\t\t\tstruct atl1c_buffer *buffer_info)\n{\n\tu16 pci_driection;\n\tif (buffer_info->flags & ATL1C_BUFFER_FREE)\n\t\treturn;\n\tif (buffer_info->dma) {\n\t\tif (buffer_info->flags & ATL1C_PCIMAP_FROMDEVICE)\n\t\t\tpci_driection = DMA_FROM_DEVICE;\n\t\telse\n\t\t\tpci_driection = DMA_TO_DEVICE;\n\n\t\tif (buffer_info->flags & ATL1C_PCIMAP_SINGLE)\n\t\t\tdma_unmap_single(&pdev->dev, buffer_info->dma,\n\t\t\t\t\t buffer_info->length, pci_driection);\n\t\telse if (buffer_info->flags & ATL1C_PCIMAP_PAGE)\n\t\t\tdma_unmap_page(&pdev->dev, buffer_info->dma,\n\t\t\t\t       buffer_info->length, pci_driection);\n\t}\n\tif (buffer_info->skb)\n\t\tdev_consume_skb_any(buffer_info->skb);\n\tbuffer_info->dma = 0;\n\tbuffer_info->skb = NULL;\n\tATL1C_SET_BUFFER_STATE(buffer_info, ATL1C_BUFFER_FREE);\n}\n \nstatic void atl1c_clean_tx_ring(struct atl1c_adapter *adapter,\n\t\t\t\tu32 queue)\n{\n\tstruct atl1c_tpd_ring *tpd_ring = &adapter->tpd_ring[queue];\n\tstruct atl1c_buffer *buffer_info;\n\tstruct pci_dev *pdev = adapter->pdev;\n\tu16 index, ring_count;\n\n\tring_count = tpd_ring->count;\n\tfor (index = 0; index < ring_count; index++) {\n\t\tbuffer_info = &tpd_ring->buffer_info[index];\n\t\tatl1c_clean_buffer(pdev, buffer_info);\n\t}\n\n\tnetdev_tx_reset_queue(netdev_get_tx_queue(adapter->netdev, queue));\n\n\t \n\tmemset(tpd_ring->desc, 0, sizeof(struct atl1c_tpd_desc) *\n\t\tring_count);\n\tatomic_set(&tpd_ring->next_to_clean, 0);\n\ttpd_ring->next_to_use = 0;\n}\n\n \nstatic void atl1c_clean_rx_ring(struct atl1c_adapter *adapter, u32 queue)\n{\n\tstruct atl1c_rfd_ring *rfd_ring = &adapter->rfd_ring[queue];\n\tstruct atl1c_rrd_ring *rrd_ring = &adapter->rrd_ring[queue];\n\tstruct atl1c_buffer *buffer_info;\n\tstruct pci_dev *pdev = adapter->pdev;\n\tint j;\n\n\tfor (j = 0; j < rfd_ring->count; j++) {\n\t\tbuffer_info = &rfd_ring->buffer_info[j];\n\t\tatl1c_clean_buffer(pdev, buffer_info);\n\t}\n\t \n\tmemset(rfd_ring->desc, 0, rfd_ring->size);\n\trfd_ring->next_to_clean = 0;\n\trfd_ring->next_to_use = 0;\n\trrd_ring->next_to_use = 0;\n\trrd_ring->next_to_clean = 0;\n}\n\n \nstatic void atl1c_init_ring_ptrs(struct atl1c_adapter *adapter)\n{\n\tstruct atl1c_tpd_ring *tpd_ring = adapter->tpd_ring;\n\tstruct atl1c_rfd_ring *rfd_ring = adapter->rfd_ring;\n\tstruct atl1c_rrd_ring *rrd_ring = adapter->rrd_ring;\n\tstruct atl1c_buffer *buffer_info;\n\tint i, j;\n\n\tfor (i = 0; i < adapter->tx_queue_count; i++) {\n\t\ttpd_ring[i].next_to_use = 0;\n\t\tatomic_set(&tpd_ring[i].next_to_clean, 0);\n\t\tbuffer_info = tpd_ring[i].buffer_info;\n\t\tfor (j = 0; j < tpd_ring->count; j++)\n\t\t\tATL1C_SET_BUFFER_STATE(&buffer_info[i],\n\t\t\t\t\t       ATL1C_BUFFER_FREE);\n\t}\n\tfor (i = 0; i < adapter->rx_queue_count; i++) {\n\t\trfd_ring[i].next_to_use = 0;\n\t\trfd_ring[i].next_to_clean = 0;\n\t\trrd_ring[i].next_to_use = 0;\n\t\trrd_ring[i].next_to_clean = 0;\n\t\tfor (j = 0; j < rfd_ring[i].count; j++) {\n\t\t\tbuffer_info = &rfd_ring[i].buffer_info[j];\n\t\t\tATL1C_SET_BUFFER_STATE(buffer_info, ATL1C_BUFFER_FREE);\n\t\t}\n\t}\n}\n\n \nstatic void atl1c_free_ring_resources(struct atl1c_adapter *adapter)\n{\n\tstruct pci_dev *pdev = adapter->pdev;\n\n\tdma_free_coherent(&pdev->dev, adapter->ring_header.size,\n\t\t\t  adapter->ring_header.desc, adapter->ring_header.dma);\n\tadapter->ring_header.desc = NULL;\n\n\t \n\tif (adapter->tpd_ring[0].buffer_info) {\n\t\tkfree(adapter->tpd_ring[0].buffer_info);\n\t\tadapter->tpd_ring[0].buffer_info = NULL;\n\t}\n}\n\n \nstatic int atl1c_setup_ring_resources(struct atl1c_adapter *adapter)\n{\n\tstruct pci_dev *pdev = adapter->pdev;\n\tstruct atl1c_tpd_ring *tpd_ring = adapter->tpd_ring;\n\tstruct atl1c_rfd_ring *rfd_ring = adapter->rfd_ring;\n\tstruct atl1c_rrd_ring *rrd_ring = adapter->rrd_ring;\n\tstruct atl1c_ring_header *ring_header = &adapter->ring_header;\n\tint tqc = adapter->tx_queue_count;\n\tint rqc = adapter->rx_queue_count;\n\tint size;\n\tint i;\n\tint count = 0;\n\tu32 offset = 0;\n\n\t \n\tif (tqc == 1)\n\t\ttqc = 2;\n\n\tfor (i = 1; i < tqc; i++)\n\t\ttpd_ring[i].count = tpd_ring[0].count;\n\n\tsize = sizeof(struct atl1c_buffer) * (tpd_ring->count * tqc +\n\t\t\t\t\t      rfd_ring->count * rqc);\n\ttpd_ring->buffer_info = kzalloc(size, GFP_KERNEL);\n\tif (unlikely(!tpd_ring->buffer_info))\n\t\tgoto err_nomem;\n\n\tfor (i = 0; i < tqc; i++) {\n\t\ttpd_ring[i].adapter = adapter;\n\t\ttpd_ring[i].num = i;\n\t\ttpd_ring[i].buffer_info = (tpd_ring->buffer_info + count);\n\t\tcount += tpd_ring[i].count;\n\t}\n\n\tfor (i = 0; i < rqc; i++) {\n\t\trrd_ring[i].adapter = adapter;\n\t\trrd_ring[i].num = i;\n\t\trrd_ring[i].count = rfd_ring[0].count;\n\t\trfd_ring[i].count = rfd_ring[0].count;\n\t\trfd_ring[i].buffer_info = (tpd_ring->buffer_info + count);\n\t\tcount += rfd_ring->count;\n\t}\n\n\t \n\tring_header->size =\n\t\tsizeof(struct atl1c_tpd_desc) * tpd_ring->count * tqc +\n\t\tsizeof(struct atl1c_rx_free_desc) * rfd_ring->count * rqc +\n\t\tsizeof(struct atl1c_recv_ret_status) * rfd_ring->count * rqc +\n\t\t8 * 4;\n\n\tring_header->desc = dma_alloc_coherent(&pdev->dev, ring_header->size,\n\t\t\t\t\t       &ring_header->dma, GFP_KERNEL);\n\tif (unlikely(!ring_header->desc)) {\n\t\tdev_err(&pdev->dev, \"could not get memory for DMA buffer\\n\");\n\t\tgoto err_nomem;\n\t}\n\t \n\n\ttpd_ring[0].dma = roundup(ring_header->dma, 8);\n\toffset = tpd_ring[0].dma - ring_header->dma;\n\tfor (i = 0; i < tqc; i++) {\n\t\ttpd_ring[i].dma = ring_header->dma + offset;\n\t\ttpd_ring[i].desc = (u8 *)ring_header->desc + offset;\n\t\ttpd_ring[i].size =\n\t\t\tsizeof(struct atl1c_tpd_desc) * tpd_ring[i].count;\n\t\toffset += roundup(tpd_ring[i].size, 8);\n\t}\n\tfor (i = 0; i < rqc; i++) {\n\t\t \n\t\trfd_ring[i].dma = ring_header->dma + offset;\n\t\trfd_ring[i].desc = (u8 *)ring_header->desc + offset;\n\t\trfd_ring[i].size = sizeof(struct atl1c_rx_free_desc) *\n\t\t\trfd_ring[i].count;\n\t\toffset += roundup(rfd_ring[i].size, 8);\n\n\t\t \n\t\trrd_ring[i].dma = ring_header->dma + offset;\n\t\trrd_ring[i].desc = (u8 *)ring_header->desc + offset;\n\t\trrd_ring[i].size = sizeof(struct atl1c_recv_ret_status) *\n\t\t\trrd_ring[i].count;\n\t\toffset += roundup(rrd_ring[i].size, 8);\n\t}\n\n\treturn 0;\n\nerr_nomem:\n\tkfree(tpd_ring->buffer_info);\n\treturn -ENOMEM;\n}\n\nstatic void atl1c_configure_des_ring(struct atl1c_adapter *adapter)\n{\n\tstruct atl1c_hw *hw = &adapter->hw;\n\tstruct atl1c_rfd_ring *rfd_ring = adapter->rfd_ring;\n\tstruct atl1c_rrd_ring *rrd_ring = adapter->rrd_ring;\n\tstruct atl1c_tpd_ring *tpd_ring = adapter->tpd_ring;\n\tint i;\n\tint tx_queue_count = adapter->tx_queue_count;\n\n\tif (tx_queue_count == 1)\n\t\ttx_queue_count = 2;\n\n\t \n\tAT_WRITE_REG(hw, REG_TX_BASE_ADDR_HI,\n\t\t     (u32)((tpd_ring[0].dma & AT_DMA_HI_ADDR_MASK) >> 32));\n\t \n\tfor (i = 0; i < tx_queue_count; i++) {\n\t\tAT_WRITE_REG(hw, atl1c_qregs[i].tpd_addr_lo,\n\t\t\t     (u32)(tpd_ring[i].dma & AT_DMA_LO_ADDR_MASK));\n\t}\n\tAT_WRITE_REG(hw, REG_TPD_RING_SIZE,\n\t\t\t(u32)(tpd_ring[0].count & TPD_RING_SIZE_MASK));\n\n\n\t \n\tAT_WRITE_REG(hw, REG_RX_BASE_ADDR_HI,\n\t\t     (u32)((rfd_ring->dma & AT_DMA_HI_ADDR_MASK) >> 32));\n\tfor (i = 0; i < adapter->rx_queue_count; i++) {\n\t\tAT_WRITE_REG(hw, atl1c_qregs[i].rfd_addr_lo,\n\t\t\t     (u32)(rfd_ring[i].dma & AT_DMA_LO_ADDR_MASK));\n\t}\n\n\tAT_WRITE_REG(hw, REG_RFD_RING_SIZE,\n\t\t\trfd_ring->count & RFD_RING_SIZE_MASK);\n\tAT_WRITE_REG(hw, REG_RX_BUF_SIZE,\n\t\t\tadapter->rx_buffer_len & RX_BUF_SIZE_MASK);\n\n\t \n\tfor (i = 0; i < adapter->rx_queue_count; i++) {\n\t\tAT_WRITE_REG(hw, atl1c_qregs[i].rrd_addr_lo,\n\t\t\t     (u32)(rrd_ring[i].dma & AT_DMA_LO_ADDR_MASK));\n\t}\n\tAT_WRITE_REG(hw, REG_RRD_RING_SIZE,\n\t\t\t(rrd_ring->count & RRD_RING_SIZE_MASK));\n\n\tif (hw->nic_type == athr_l2c_b) {\n\t\tAT_WRITE_REG(hw, REG_SRAM_RXF_LEN, 0x02a0L);\n\t\tAT_WRITE_REG(hw, REG_SRAM_TXF_LEN, 0x0100L);\n\t\tAT_WRITE_REG(hw, REG_SRAM_RXF_ADDR, 0x029f0000L);\n\t\tAT_WRITE_REG(hw, REG_SRAM_RFD0_INFO, 0x02bf02a0L);\n\t\tAT_WRITE_REG(hw, REG_SRAM_TXF_ADDR, 0x03bf02c0L);\n\t\tAT_WRITE_REG(hw, REG_SRAM_TRD_ADDR, 0x03df03c0L);\n\t\tAT_WRITE_REG(hw, REG_TXF_WATER_MARK, 0);\t \n\t\tAT_WRITE_REG(hw, REG_RXD_DMA_CTRL, 0);\t\t \n\t}\n\t \n\tAT_WRITE_REG(hw, REG_LOAD_PTR, 1);\n}\n\nstatic void atl1c_configure_tx(struct atl1c_adapter *adapter)\n{\n\tstruct atl1c_hw *hw = &adapter->hw;\n\tint max_pay_load;\n\tu16 tx_offload_thresh;\n\tu32 txq_ctrl_data;\n\n\ttx_offload_thresh = MAX_TSO_FRAME_SIZE;\n\tAT_WRITE_REG(hw, REG_TX_TSO_OFFLOAD_THRESH,\n\t\t(tx_offload_thresh >> 3) & TX_TSO_OFFLOAD_THRESH_MASK);\n\tmax_pay_load = pcie_get_readrq(adapter->pdev) >> 8;\n\thw->dmar_block = min_t(u32, max_pay_load, hw->dmar_block);\n\t \n\tif (hw->dmar_block < DEVICE_CTRL_MAXRRS_MIN) {\n\t\tpcie_set_readrq(adapter->pdev, 128 << DEVICE_CTRL_MAXRRS_MIN);\n\t\thw->dmar_block = DEVICE_CTRL_MAXRRS_MIN;\n\t}\n\ttxq_ctrl_data =\n\t\thw->nic_type == athr_l2c_b || hw->nic_type == athr_l2c_b2 ?\n\t\tL2CB_TXQ_CFGV : L1C_TXQ_CFGV;\n\n\tAT_WRITE_REG(hw, REG_TXQ_CTRL, txq_ctrl_data);\n}\n\nstatic void atl1c_configure_rx(struct atl1c_adapter *adapter)\n{\n\tstruct atl1c_hw *hw = &adapter->hw;\n\tu32 rxq_ctrl_data;\n\n\trxq_ctrl_data = (hw->rfd_burst & RXQ_RFD_BURST_NUM_MASK) <<\n\t\t\tRXQ_RFD_BURST_NUM_SHIFT;\n\n\tif (hw->ctrl_flags & ATL1C_RX_IPV6_CHKSUM)\n\t\trxq_ctrl_data |= IPV6_CHKSUM_CTRL_EN;\n\n\t \n\tif (hw->nic_type != athr_l1d_2 && (hw->device_id & 1) != 0)\n\t\trxq_ctrl_data = FIELD_SETX(rxq_ctrl_data, ASPM_THRUPUT_LIMIT,\n\t\t\tASPM_THRUPUT_LIMIT_100M);\n\n\tAT_WRITE_REG(hw, REG_RXQ_CTRL, rxq_ctrl_data);\n}\n\nstatic void atl1c_configure_dma(struct atl1c_adapter *adapter)\n{\n\tstruct atl1c_hw *hw = &adapter->hw;\n\tu32 dma_ctrl_data;\n\n\tdma_ctrl_data = FIELDX(DMA_CTRL_RORDER_MODE, DMA_CTRL_RORDER_MODE_OUT) |\n\t\tDMA_CTRL_RREQ_PRI_DATA |\n\t\tFIELDX(DMA_CTRL_RREQ_BLEN, hw->dmar_block) |\n\t\tFIELDX(DMA_CTRL_WDLY_CNT, DMA_CTRL_WDLY_CNT_DEF) |\n\t\tFIELDX(DMA_CTRL_RDLY_CNT, DMA_CTRL_RDLY_CNT_DEF);\n\n\tAT_WRITE_REG(hw, REG_DMA_CTRL, dma_ctrl_data);\n}\n\n \nstatic int atl1c_stop_mac(struct atl1c_hw *hw)\n{\n\tu32 data;\n\n\tAT_READ_REG(hw, REG_RXQ_CTRL, &data);\n\tdata &= ~RXQ_CTRL_EN;\n\tAT_WRITE_REG(hw, REG_RXQ_CTRL, data);\n\n\tAT_READ_REG(hw, REG_TXQ_CTRL, &data);\n\tdata &= ~TXQ_CTRL_EN;\n\tAT_WRITE_REG(hw, REG_TXQ_CTRL, data);\n\n\tatl1c_wait_until_idle(hw, IDLE_STATUS_RXQ_BUSY | IDLE_STATUS_TXQ_BUSY);\n\n\tAT_READ_REG(hw, REG_MAC_CTRL, &data);\n\tdata &= ~(MAC_CTRL_TX_EN | MAC_CTRL_RX_EN);\n\tAT_WRITE_REG(hw, REG_MAC_CTRL, data);\n\n\treturn (int)atl1c_wait_until_idle(hw,\n\t\tIDLE_STATUS_TXMAC_BUSY | IDLE_STATUS_RXMAC_BUSY);\n}\n\nstatic void atl1c_start_mac(struct atl1c_adapter *adapter)\n{\n\tstruct atl1c_hw *hw = &adapter->hw;\n\tu32 mac, txq, rxq;\n\n\thw->mac_duplex = adapter->link_duplex == FULL_DUPLEX;\n\thw->mac_speed = adapter->link_speed == SPEED_1000 ?\n\t\tatl1c_mac_speed_1000 : atl1c_mac_speed_10_100;\n\n\tAT_READ_REG(hw, REG_TXQ_CTRL, &txq);\n\tAT_READ_REG(hw, REG_RXQ_CTRL, &rxq);\n\tAT_READ_REG(hw, REG_MAC_CTRL, &mac);\n\n\ttxq |= TXQ_CTRL_EN;\n\trxq |= RXQ_CTRL_EN;\n\tmac |= MAC_CTRL_TX_EN | MAC_CTRL_TX_FLOW |\n\t       MAC_CTRL_RX_EN | MAC_CTRL_RX_FLOW |\n\t       MAC_CTRL_ADD_CRC | MAC_CTRL_PAD |\n\t       MAC_CTRL_BC_EN | MAC_CTRL_SINGLE_PAUSE_EN |\n\t       MAC_CTRL_HASH_ALG_CRC32;\n\tif (hw->mac_duplex)\n\t\tmac |= MAC_CTRL_DUPLX;\n\telse\n\t\tmac &= ~MAC_CTRL_DUPLX;\n\tmac = FIELD_SETX(mac, MAC_CTRL_SPEED, hw->mac_speed);\n\tmac = FIELD_SETX(mac, MAC_CTRL_PRMLEN, hw->preamble_len);\n\n\tAT_WRITE_REG(hw, REG_TXQ_CTRL, txq);\n\tAT_WRITE_REG(hw, REG_RXQ_CTRL, rxq);\n\tAT_WRITE_REG(hw, REG_MAC_CTRL, mac);\n}\n\n \nstatic int atl1c_reset_mac(struct atl1c_hw *hw)\n{\n\tstruct atl1c_adapter *adapter = hw->adapter;\n\tstruct pci_dev *pdev = adapter->pdev;\n\tu32 ctrl_data = 0;\n\n\tatl1c_stop_mac(hw);\n\t \n\tAT_READ_REG(hw, REG_MASTER_CTRL, &ctrl_data);\n\tctrl_data |= MASTER_CTRL_OOB_DIS;\n\tAT_WRITE_REG(hw, REG_MASTER_CTRL, ctrl_data | MASTER_CTRL_SOFT_RST);\n\n\tAT_WRITE_FLUSH(hw);\n\tmsleep(10);\n\t \n\n\tif (atl1c_wait_until_idle(hw, IDLE_STATUS_MASK)) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"MAC state machine can't be idle since\"\n\t\t\t\" disabled for 10ms second\\n\");\n\t\treturn -1;\n\t}\n\tAT_WRITE_REG(hw, REG_MASTER_CTRL, ctrl_data);\n\n\t \n\tAT_READ_REG(hw, REG_MAC_CTRL, &ctrl_data);\n\tAT_WRITE_REG(hw, REG_MAC_CTRL, ctrl_data | MAC_CTRL_SPEED_MODE_SW);\n\n\t \n\tAT_READ_REG(hw, REG_SERDES, &ctrl_data);\n\tswitch (hw->nic_type) {\n\tcase athr_l2c_b:\n\t\tctrl_data &= ~(SERDES_PHY_CLK_SLOWDOWN |\n\t\t\t\tSERDES_MAC_CLK_SLOWDOWN);\n\t\tAT_WRITE_REG(hw, REG_SERDES, ctrl_data);\n\t\tbreak;\n\tcase athr_l2c_b2:\n\tcase athr_l1d_2:\n\t\tctrl_data |= SERDES_PHY_CLK_SLOWDOWN | SERDES_MAC_CLK_SLOWDOWN;\n\t\tAT_WRITE_REG(hw, REG_SERDES, ctrl_data);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic void atl1c_disable_l0s_l1(struct atl1c_hw *hw)\n{\n\tu16 ctrl_flags = hw->ctrl_flags;\n\n\thw->ctrl_flags &= ~(ATL1C_ASPM_L0S_SUPPORT | ATL1C_ASPM_L1_SUPPORT);\n\tatl1c_set_aspm(hw, SPEED_0);\n\thw->ctrl_flags = ctrl_flags;\n}\n\n \nstatic void atl1c_set_aspm(struct atl1c_hw *hw, u16 link_speed)\n{\n\tu32 pm_ctrl_data;\n\tu32 link_l1_timer;\n\n\tAT_READ_REG(hw, REG_PM_CTRL, &pm_ctrl_data);\n\tpm_ctrl_data &= ~(PM_CTRL_ASPM_L1_EN |\n\t\t\t  PM_CTRL_ASPM_L0S_EN |\n\t\t\t  PM_CTRL_MAC_ASPM_CHK);\n\t \n\tif (hw->nic_type == athr_l2c_b2 || hw->nic_type == athr_l1d_2) {\n\t\tpm_ctrl_data &= ~PMCTRL_TXL1_AFTER_L0S;\n\t\tlink_l1_timer =\n\t\t\tlink_speed == SPEED_1000 || link_speed == SPEED_100 ?\n\t\t\tL1D_PMCTRL_L1_ENTRY_TM_16US : 1;\n\t\tpm_ctrl_data = FIELD_SETX(pm_ctrl_data,\n\t\t\tL1D_PMCTRL_L1_ENTRY_TM, link_l1_timer);\n\t} else {\n\t\tlink_l1_timer = hw->nic_type == athr_l2c_b ?\n\t\t\tL2CB1_PM_CTRL_L1_ENTRY_TM : L1C_PM_CTRL_L1_ENTRY_TM;\n\t\tif (link_speed != SPEED_1000 && link_speed != SPEED_100)\n\t\t\tlink_l1_timer = 1;\n\t\tpm_ctrl_data = FIELD_SETX(pm_ctrl_data,\n\t\t\tPM_CTRL_L1_ENTRY_TIMER, link_l1_timer);\n\t}\n\n\t \n\tif ((hw->ctrl_flags & ATL1C_ASPM_L0S_SUPPORT) && link_speed != SPEED_0)\n\t\tpm_ctrl_data |= PM_CTRL_ASPM_L0S_EN | PM_CTRL_MAC_ASPM_CHK;\n\tif (hw->ctrl_flags & ATL1C_ASPM_L1_SUPPORT)\n\t\tpm_ctrl_data |= PM_CTRL_ASPM_L1_EN | PM_CTRL_MAC_ASPM_CHK;\n\n\t \n\tif (hw->nic_type == athr_l2c_b || hw->nic_type == athr_l1d ||\n\t    hw->nic_type == athr_l2c_b2 || hw->nic_type == athr_l1d_2) {\n\t\tpm_ctrl_data = FIELD_SETX(pm_ctrl_data,\n\t\t\tPM_CTRL_PM_REQ_TIMER, PM_CTRL_PM_REQ_TO_DEF);\n\t\tpm_ctrl_data |= PM_CTRL_RCVR_WT_TIMER |\n\t\t\t\tPM_CTRL_SERDES_PD_EX_L1 |\n\t\t\t\tPM_CTRL_CLK_SWH_L1;\n\t\tpm_ctrl_data &= ~(PM_CTRL_SERDES_L1_EN |\n\t\t\t\t  PM_CTRL_SERDES_PLL_L1_EN |\n\t\t\t\t  PM_CTRL_SERDES_BUFS_RX_L1_EN |\n\t\t\t\t  PM_CTRL_SA_DLY_EN |\n\t\t\t\t  PM_CTRL_HOTRST);\n\t\t \n\t\tif (link_speed == SPEED_0 || hw->nic_type == athr_l2c_b)\n\t\t\tpm_ctrl_data &= ~PM_CTRL_ASPM_L0S_EN;\n\t} else {  \n\t\tpm_ctrl_data =\n\t\t\tFIELD_SETX(pm_ctrl_data, PM_CTRL_L1_ENTRY_TIMER, 0);\n\t\tif (link_speed != SPEED_0) {\n\t\t\tpm_ctrl_data |= PM_CTRL_SERDES_L1_EN |\n\t\t\t\t\tPM_CTRL_SERDES_PLL_L1_EN |\n\t\t\t\t\tPM_CTRL_SERDES_BUFS_RX_L1_EN;\n\t\t\tpm_ctrl_data &= ~(PM_CTRL_SERDES_PD_EX_L1 |\n\t\t\t\t\t  PM_CTRL_CLK_SWH_L1 |\n\t\t\t\t\t  PM_CTRL_ASPM_L0S_EN |\n\t\t\t\t\t  PM_CTRL_ASPM_L1_EN);\n\t\t} else {  \n\t\t\tpm_ctrl_data |= PM_CTRL_CLK_SWH_L1;\n\t\t\tpm_ctrl_data &= ~(PM_CTRL_SERDES_L1_EN |\n\t\t\t\t\t  PM_CTRL_SERDES_PLL_L1_EN |\n\t\t\t\t\t  PM_CTRL_SERDES_BUFS_RX_L1_EN |\n\t\t\t\t\t  PM_CTRL_ASPM_L0S_EN);\n\t\t}\n\t}\n\tAT_WRITE_REG(hw, REG_PM_CTRL, pm_ctrl_data);\n\n\treturn;\n}\n\n \nstatic int atl1c_configure_mac(struct atl1c_adapter *adapter)\n{\n\tstruct atl1c_hw *hw = &adapter->hw;\n\tu32 master_ctrl_data = 0;\n\tu32 intr_modrt_data;\n\tu32 data;\n\n\tAT_READ_REG(hw, REG_MASTER_CTRL, &master_ctrl_data);\n\tmaster_ctrl_data &= ~(MASTER_CTRL_TX_ITIMER_EN |\n\t\t\t      MASTER_CTRL_RX_ITIMER_EN |\n\t\t\t      MASTER_CTRL_INT_RDCLR);\n\t \n\tAT_WRITE_REG(hw, REG_ISR, 0xFFFFFFFF);\n\t \n\tAT_WRITE_REG(hw, REG_WOL_CTRL, 0);\n\t \n\n\tdata = CLK_GATING_EN_ALL;\n\tif (hw->ctrl_flags & ATL1C_CLK_GATING_EN) {\n\t\tif (hw->nic_type == athr_l2c_b)\n\t\t\tdata &= ~CLK_GATING_RXMAC_EN;\n\t} else\n\t\tdata = 0;\n\tAT_WRITE_REG(hw, REG_CLK_GATING_CTRL, data);\n\n\tAT_WRITE_REG(hw, REG_INT_RETRIG_TIMER,\n\t\thw->ict & INT_RETRIG_TIMER_MASK);\n\n\tatl1c_configure_des_ring(adapter);\n\n\tif (hw->ctrl_flags & ATL1C_INTR_MODRT_ENABLE) {\n\t\tintr_modrt_data = (hw->tx_imt & IRQ_MODRT_TIMER_MASK) <<\n\t\t\t\t\tIRQ_MODRT_TX_TIMER_SHIFT;\n\t\tintr_modrt_data |= (hw->rx_imt & IRQ_MODRT_TIMER_MASK) <<\n\t\t\t\t\tIRQ_MODRT_RX_TIMER_SHIFT;\n\t\tAT_WRITE_REG(hw, REG_IRQ_MODRT_TIMER_INIT, intr_modrt_data);\n\t\tmaster_ctrl_data |=\n\t\t\tMASTER_CTRL_TX_ITIMER_EN | MASTER_CTRL_RX_ITIMER_EN;\n\t}\n\n\tif (hw->ctrl_flags & ATL1C_INTR_CLEAR_ON_READ)\n\t\tmaster_ctrl_data |= MASTER_CTRL_INT_RDCLR;\n\n\tmaster_ctrl_data |= MASTER_CTRL_SA_TIMER_EN;\n\tAT_WRITE_REG(hw, REG_MASTER_CTRL, master_ctrl_data);\n\n\tAT_WRITE_REG(hw, REG_SMB_STAT_TIMER,\n\t\thw->smb_timer & SMB_STAT_TIMER_MASK);\n\n\t \n\tAT_WRITE_REG(hw, REG_MTU, hw->max_frame_size + ETH_HLEN +\n\t\t\tVLAN_HLEN + ETH_FCS_LEN);\n\n\tatl1c_configure_tx(adapter);\n\tatl1c_configure_rx(adapter);\n\tatl1c_configure_dma(adapter);\n\n\treturn 0;\n}\n\nstatic int atl1c_configure(struct atl1c_adapter *adapter)\n{\n\tstruct net_device *netdev = adapter->netdev;\n\tint num;\n\tint i;\n\n\tif (adapter->hw.nic_type == athr_mt) {\n\t\tu32 mode;\n\n\t\tAT_READ_REG(&adapter->hw, REG_MT_MODE, &mode);\n\t\tif (adapter->rx_queue_count == 4)\n\t\t\tmode |= MT_MODE_4Q;\n\t\telse\n\t\t\tmode &= ~MT_MODE_4Q;\n\t\tAT_WRITE_REG(&adapter->hw, REG_MT_MODE, mode);\n\t}\n\n\tatl1c_init_ring_ptrs(adapter);\n\tatl1c_set_multi(netdev);\n\tatl1c_restore_vlan(adapter);\n\n\tfor (i = 0; i < adapter->rx_queue_count; ++i) {\n\t\tnum = atl1c_alloc_rx_buffer(adapter, i, false);\n\t\tif (unlikely(num == 0))\n\t\t\treturn -ENOMEM;\n\t}\n\n\tif (atl1c_configure_mac(adapter))\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic void atl1c_update_hw_stats(struct atl1c_adapter *adapter)\n{\n\tu16 hw_reg_addr = 0;\n\tunsigned long *stats_item = NULL;\n\tu32 data;\n\n\t \n\thw_reg_addr = REG_MAC_RX_STATUS_BIN;\n\tstats_item  = &adapter->hw_stats.rx_ok;\n\twhile (hw_reg_addr <= REG_MAC_RX_STATUS_END) {\n\t\tAT_READ_REG(&adapter->hw, hw_reg_addr, &data);\n\t\t*stats_item += data;\n\t\tstats_item++;\n\t\thw_reg_addr += 4;\n\t}\n \n\thw_reg_addr = REG_MAC_TX_STATUS_BIN;\n\tstats_item  = &adapter->hw_stats.tx_ok;\n\twhile (hw_reg_addr <= REG_MAC_TX_STATUS_END) {\n\t\tAT_READ_REG(&adapter->hw, hw_reg_addr, &data);\n\t\t*stats_item += data;\n\t\tstats_item++;\n\t\thw_reg_addr += 4;\n\t}\n}\n\n \nstatic struct net_device_stats *atl1c_get_stats(struct net_device *netdev)\n{\n\tstruct atl1c_adapter *adapter = netdev_priv(netdev);\n\tstruct atl1c_hw_stats  *hw_stats = &adapter->hw_stats;\n\tstruct net_device_stats *net_stats = &netdev->stats;\n\n\tatl1c_update_hw_stats(adapter);\n\tnet_stats->rx_bytes   = hw_stats->rx_byte_cnt;\n\tnet_stats->tx_bytes   = hw_stats->tx_byte_cnt;\n\tnet_stats->multicast  = hw_stats->rx_mcast;\n\tnet_stats->collisions = hw_stats->tx_1_col +\n\t\t\t\thw_stats->tx_2_col +\n\t\t\t\thw_stats->tx_late_col +\n\t\t\t\thw_stats->tx_abort_col;\n\n\tnet_stats->rx_errors  = hw_stats->rx_frag +\n\t\t\t\thw_stats->rx_fcs_err +\n\t\t\t\thw_stats->rx_len_err +\n\t\t\t\thw_stats->rx_sz_ov +\n\t\t\t\thw_stats->rx_rrd_ov +\n\t\t\t\thw_stats->rx_align_err +\n\t\t\t\thw_stats->rx_rxf_ov;\n\n\tnet_stats->rx_fifo_errors   = hw_stats->rx_rxf_ov;\n\tnet_stats->rx_length_errors = hw_stats->rx_len_err;\n\tnet_stats->rx_crc_errors    = hw_stats->rx_fcs_err;\n\tnet_stats->rx_frame_errors  = hw_stats->rx_align_err;\n\tnet_stats->rx_dropped       = hw_stats->rx_rrd_ov;\n\n\tnet_stats->tx_errors = hw_stats->tx_late_col +\n\t\t\t       hw_stats->tx_abort_col +\n\t\t\t       hw_stats->tx_underrun +\n\t\t\t       hw_stats->tx_trunc;\n\n\tnet_stats->tx_fifo_errors    = hw_stats->tx_underrun;\n\tnet_stats->tx_aborted_errors = hw_stats->tx_abort_col;\n\tnet_stats->tx_window_errors  = hw_stats->tx_late_col;\n\n\tnet_stats->rx_packets = hw_stats->rx_ok + net_stats->rx_errors;\n\tnet_stats->tx_packets = hw_stats->tx_ok + net_stats->tx_errors;\n\n\treturn net_stats;\n}\n\nstatic inline void atl1c_clear_phy_int(struct atl1c_adapter *adapter)\n{\n\tu16 phy_data;\n\n\tspin_lock(&adapter->mdio_lock);\n\tatl1c_read_phy_reg(&adapter->hw, MII_ISR, &phy_data);\n\tspin_unlock(&adapter->mdio_lock);\n}\n\nstatic int atl1c_clean_tx(struct napi_struct *napi, int budget)\n{\n\tstruct atl1c_tpd_ring *tpd_ring =\n\t\tcontainer_of(napi, struct atl1c_tpd_ring, napi);\n\tstruct atl1c_adapter *adapter = tpd_ring->adapter;\n\tstruct netdev_queue *txq =\n\t\tnetdev_get_tx_queue(napi->dev, tpd_ring->num);\n\tstruct atl1c_buffer *buffer_info;\n\tstruct pci_dev *pdev = adapter->pdev;\n\tu16 next_to_clean = atomic_read(&tpd_ring->next_to_clean);\n\tu16 hw_next_to_clean;\n\tunsigned int total_bytes = 0, total_packets = 0;\n\tunsigned long flags;\n\n\tAT_READ_REGW(&adapter->hw, atl1c_qregs[tpd_ring->num].tpd_cons,\n\t\t     &hw_next_to_clean);\n\n\twhile (next_to_clean != hw_next_to_clean) {\n\t\tbuffer_info = &tpd_ring->buffer_info[next_to_clean];\n\t\tif (buffer_info->skb) {\n\t\t\ttotal_bytes += buffer_info->skb->len;\n\t\t\ttotal_packets++;\n\t\t}\n\t\tatl1c_clean_buffer(pdev, buffer_info);\n\t\tif (++next_to_clean == tpd_ring->count)\n\t\t\tnext_to_clean = 0;\n\t\tatomic_set(&tpd_ring->next_to_clean, next_to_clean);\n\t}\n\n\tnetdev_tx_completed_queue(txq, total_packets, total_bytes);\n\n\tif (netif_tx_queue_stopped(txq) && netif_carrier_ok(adapter->netdev))\n\t\tnetif_tx_wake_queue(txq);\n\n\tif (total_packets < budget) {\n\t\tnapi_complete_done(napi, total_packets);\n\t\tspin_lock_irqsave(&adapter->hw.intr_mask_lock, flags);\n\t\tadapter->hw.intr_mask |= atl1c_qregs[tpd_ring->num].tx_isr;\n\t\tAT_WRITE_REG(&adapter->hw, REG_IMR, adapter->hw.intr_mask);\n\t\tspin_unlock_irqrestore(&adapter->hw.intr_mask_lock, flags);\n\t\treturn total_packets;\n\t}\n\treturn budget;\n}\n\nstatic void atl1c_intr_rx_tx(struct atl1c_adapter *adapter, u32 status)\n{\n\tstruct atl1c_hw *hw = &adapter->hw;\n\tu32 intr_mask;\n\tint i;\n\n\tspin_lock(&hw->intr_mask_lock);\n\tintr_mask = hw->intr_mask;\n\tfor (i = 0; i < adapter->rx_queue_count; ++i) {\n\t\tif (!(status & atl1c_qregs[i].rx_isr))\n\t\t\tcontinue;\n\t\tif (napi_schedule_prep(&adapter->rrd_ring[i].napi)) {\n\t\t\tintr_mask &= ~atl1c_qregs[i].rx_isr;\n\t\t\t__napi_schedule(&adapter->rrd_ring[i].napi);\n\t\t}\n\t}\n\tfor (i = 0; i < adapter->tx_queue_count; ++i) {\n\t\tif (!(status & atl1c_qregs[i].tx_isr))\n\t\t\tcontinue;\n\t\tif (napi_schedule_prep(&adapter->tpd_ring[i].napi)) {\n\t\t\tintr_mask &= ~atl1c_qregs[i].tx_isr;\n\t\t\t__napi_schedule(&adapter->tpd_ring[i].napi);\n\t\t}\n\t}\n\n\tif (hw->intr_mask != intr_mask) {\n\t\thw->intr_mask = intr_mask;\n\t\tAT_WRITE_REG(hw, REG_IMR, hw->intr_mask);\n\t}\n\tspin_unlock(&hw->intr_mask_lock);\n}\n\n \nstatic irqreturn_t atl1c_intr(int irq, void *data)\n{\n\tstruct net_device *netdev  = data;\n\tstruct atl1c_adapter *adapter = netdev_priv(netdev);\n\tstruct pci_dev *pdev = adapter->pdev;\n\tstruct atl1c_hw *hw = &adapter->hw;\n\tint max_ints = AT_MAX_INT_WORK;\n\tint handled = IRQ_NONE;\n\tu32 status;\n\tu32 reg_data;\n\n\tdo {\n\t\tAT_READ_REG(hw, REG_ISR, &reg_data);\n\t\tstatus = reg_data & hw->intr_mask;\n\n\t\tif (status == 0 || (status & ISR_DIS_INT) != 0) {\n\t\t\tif (max_ints != AT_MAX_INT_WORK)\n\t\t\t\thandled = IRQ_HANDLED;\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tif (status & ISR_GPHY)\n\t\t\tatl1c_clear_phy_int(adapter);\n\t\t \n\t\tAT_WRITE_REG(hw, REG_ISR, status | ISR_DIS_INT);\n\t\tif (status & (ISR_RX_PKT | ISR_TX_PKT))\n\t\t\tatl1c_intr_rx_tx(adapter, status);\n\n\t\thandled = IRQ_HANDLED;\n\t\t \n\t\tif (status & ISR_ERROR) {\n\t\t\tif (netif_msg_hw(adapter))\n\t\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\t\"atl1c hardware error (status = 0x%x)\\n\",\n\t\t\t\t\tstatus & ISR_ERROR);\n\t\t\t \n\t\t\tset_bit(ATL1C_WORK_EVENT_RESET, &adapter->work_event);\n\t\t\tschedule_work(&adapter->common_task);\n\t\t\treturn IRQ_HANDLED;\n\t\t}\n\n\t\tif (status & ISR_OVER)\n\t\t\tif (netif_msg_intr(adapter))\n\t\t\t\tdev_warn(&pdev->dev,\n\t\t\t\t\t\"TX/RX overflow (status = 0x%x)\\n\",\n\t\t\t\t\tstatus & ISR_OVER);\n\n\t\t \n\t\tif (status & (ISR_GPHY | ISR_MANUAL)) {\n\t\t\tnetdev->stats.tx_carrier_errors++;\n\t\t\tatl1c_link_chg_event(adapter);\n\t\t\tbreak;\n\t\t}\n\n\t} while (--max_ints > 0);\n\t \n\tAT_WRITE_REG(&adapter->hw, REG_ISR, 0);\n\treturn handled;\n}\n\nstatic inline void atl1c_rx_checksum(struct atl1c_adapter *adapter,\n\t\t  struct sk_buff *skb, struct atl1c_recv_ret_status *prrs)\n{\n\tif (adapter->hw.nic_type == athr_mt) {\n\t\tif (prrs->word3 & RRS_MT_PROT_ID_TCPUDP)\n\t\t\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\t\treturn;\n\t}\n\t \n\tskb_checksum_none_assert(skb);\n}\n\nstatic int atl1c_alloc_rx_buffer(struct atl1c_adapter *adapter, u32 queue,\n\t\t\t\t bool napi_mode)\n{\n\tstruct atl1c_rfd_ring *rfd_ring = &adapter->rfd_ring[queue];\n\tstruct atl1c_rrd_ring *rrd_ring = &adapter->rrd_ring[queue];\n\tstruct pci_dev *pdev = adapter->pdev;\n\tstruct atl1c_buffer *buffer_info, *next_info;\n\tstruct sk_buff *skb;\n\tvoid *vir_addr = NULL;\n\tu16 num_alloc = 0;\n\tu16 rfd_next_to_use, next_next;\n\tstruct atl1c_rx_free_desc *rfd_desc;\n\tdma_addr_t mapping;\n\n\tnext_next = rfd_next_to_use = rfd_ring->next_to_use;\n\tif (++next_next == rfd_ring->count)\n\t\tnext_next = 0;\n\tbuffer_info = &rfd_ring->buffer_info[rfd_next_to_use];\n\tnext_info = &rfd_ring->buffer_info[next_next];\n\n\twhile (next_info->flags & ATL1C_BUFFER_FREE) {\n\t\trfd_desc = ATL1C_RFD_DESC(rfd_ring, rfd_next_to_use);\n\n\t\t \n\t\tif (likely(napi_mode))\n\t\t\tskb = napi_alloc_skb(&rrd_ring->napi, adapter->rx_buffer_len + 64);\n\t\telse\n\t\t\tskb = netdev_alloc_skb(adapter->netdev, adapter->rx_buffer_len + 64);\n\t\tif (unlikely(!skb)) {\n\t\t\tif (netif_msg_rx_err(adapter))\n\t\t\t\tdev_warn(&pdev->dev, \"alloc rx buffer failed\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif (((unsigned long)skb->data & 0xfff) == 0xfc0)\n\t\t\tskb_reserve(skb, 64);\n\n\t\t \n\t\tvir_addr = skb->data;\n\t\tATL1C_SET_BUFFER_STATE(buffer_info, ATL1C_BUFFER_BUSY);\n\t\tbuffer_info->skb = skb;\n\t\tbuffer_info->length = adapter->rx_buffer_len;\n\t\tmapping = dma_map_single(&pdev->dev, vir_addr,\n\t\t\t\t\t buffer_info->length, DMA_FROM_DEVICE);\n\t\tif (unlikely(dma_mapping_error(&pdev->dev, mapping))) {\n\t\t\tdev_kfree_skb(skb);\n\t\t\tbuffer_info->skb = NULL;\n\t\t\tbuffer_info->length = 0;\n\t\t\tATL1C_SET_BUFFER_STATE(buffer_info, ATL1C_BUFFER_FREE);\n\t\t\tnetif_warn(adapter, rx_err, adapter->netdev, \"RX dma_map_single failed\");\n\t\t\tbreak;\n\t\t}\n\t\tbuffer_info->dma = mapping;\n\t\tATL1C_SET_PCIMAP_TYPE(buffer_info, ATL1C_PCIMAP_SINGLE,\n\t\t\tATL1C_PCIMAP_FROMDEVICE);\n\t\trfd_desc->buffer_addr = cpu_to_le64(buffer_info->dma);\n\t\trfd_next_to_use = next_next;\n\t\tif (++next_next == rfd_ring->count)\n\t\t\tnext_next = 0;\n\t\tbuffer_info = &rfd_ring->buffer_info[rfd_next_to_use];\n\t\tnext_info = &rfd_ring->buffer_info[next_next];\n\t\tnum_alloc++;\n\t}\n\n\tif (num_alloc) {\n\t\t \n\t\twmb();\n\t\trfd_ring->next_to_use = rfd_next_to_use;\n\t\tAT_WRITE_REG(&adapter->hw, atl1c_qregs[queue].rfd_prod,\n\t\t\t     rfd_ring->next_to_use & MB_RFDX_PROD_IDX_MASK);\n\t}\n\n\treturn num_alloc;\n}\n\nstatic void atl1c_clean_rrd(struct atl1c_rrd_ring *rrd_ring,\n\t\t\tstruct\tatl1c_recv_ret_status *rrs, u16 num)\n{\n\tu16 i;\n\t \n\tfor (i = 0; i < num; i++, rrs = ATL1C_RRD_DESC(rrd_ring,\n\t\t\t\t\trrd_ring->next_to_clean)) {\n\t\trrs->word3 &= ~RRS_RXD_UPDATED;\n\t\tif (++rrd_ring->next_to_clean == rrd_ring->count)\n\t\t\trrd_ring->next_to_clean = 0;\n\t}\n}\n\nstatic void atl1c_clean_rfd(struct atl1c_rfd_ring *rfd_ring,\n\tstruct atl1c_recv_ret_status *rrs, u16 num)\n{\n\tu16 i;\n\tu16 rfd_index;\n\tstruct atl1c_buffer *buffer_info = rfd_ring->buffer_info;\n\n\trfd_index = (rrs->word0 >> RRS_RX_RFD_INDEX_SHIFT) &\n\t\t\tRRS_RX_RFD_INDEX_MASK;\n\tfor (i = 0; i < num; i++) {\n\t\tbuffer_info[rfd_index].skb = NULL;\n\t\tATL1C_SET_BUFFER_STATE(&buffer_info[rfd_index],\n\t\t\t\t\tATL1C_BUFFER_FREE);\n\t\tif (++rfd_index == rfd_ring->count)\n\t\t\trfd_index = 0;\n\t}\n\trfd_ring->next_to_clean = rfd_index;\n}\n\n \nstatic int atl1c_clean_rx(struct napi_struct *napi, int budget)\n{\n\tstruct atl1c_rrd_ring *rrd_ring =\n\t\tcontainer_of(napi, struct atl1c_rrd_ring, napi);\n\tstruct atl1c_adapter *adapter = rrd_ring->adapter;\n\tu16 rfd_num, rfd_index;\n\tu16 length;\n\tstruct pci_dev *pdev = adapter->pdev;\n\tstruct net_device *netdev  = adapter->netdev;\n\tstruct atl1c_rfd_ring *rfd_ring = &adapter->rfd_ring[rrd_ring->num];\n\tstruct sk_buff *skb;\n\tstruct atl1c_recv_ret_status *rrs;\n\tstruct atl1c_buffer *buffer_info;\n\tint work_done = 0;\n\tunsigned long flags;\n\n\t \n\tif (!netif_carrier_ok(adapter->netdev))\n\t\tgoto quit_polling;\n\n\twhile (1) {\n\t\tif (work_done >= budget)\n\t\t\tbreak;\n\t\trrs = ATL1C_RRD_DESC(rrd_ring, rrd_ring->next_to_clean);\n\t\tif (likely(RRS_RXD_IS_VALID(rrs->word3))) {\n\t\t\trfd_num = (rrs->word0 >> RRS_RX_RFD_CNT_SHIFT) &\n\t\t\t\tRRS_RX_RFD_CNT_MASK;\n\t\t\tif (unlikely(rfd_num != 1))\n\t\t\t\t \n\t\t\t\tif (netif_msg_rx_err(adapter))\n\t\t\t\t\tdev_warn(&pdev->dev,\n\t\t\t\t\t\t\"Multi rfd not support yet!\\n\");\n\t\t\tgoto rrs_checked;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\nrrs_checked:\n\t\tatl1c_clean_rrd(rrd_ring, rrs, rfd_num);\n\t\tif (rrs->word3 & (RRS_RX_ERR_SUM | RRS_802_3_LEN_ERR)) {\n\t\t\tatl1c_clean_rfd(rfd_ring, rrs, rfd_num);\n\t\t\tif (netif_msg_rx_err(adapter))\n\t\t\t\tdev_warn(&pdev->dev,\n\t\t\t\t\t \"wrong packet! rrs word3 is %x\\n\",\n\t\t\t\t\t rrs->word3);\n\t\t\tcontinue;\n\t\t}\n\n\t\tlength = le16_to_cpu((rrs->word3 >> RRS_PKT_SIZE_SHIFT) &\n\t\t\t\tRRS_PKT_SIZE_MASK);\n\t\t \n\t\tif (likely(rfd_num == 1)) {\n\t\t\trfd_index = (rrs->word0 >> RRS_RX_RFD_INDEX_SHIFT) &\n\t\t\t\t\tRRS_RX_RFD_INDEX_MASK;\n\t\t\tbuffer_info = &rfd_ring->buffer_info[rfd_index];\n\t\t\tdma_unmap_single(&pdev->dev, buffer_info->dma,\n\t\t\t\t\t buffer_info->length, DMA_FROM_DEVICE);\n\t\t\tskb = buffer_info->skb;\n\t\t} else {\n\t\t\t \n\t\t\tif (netif_msg_rx_err(adapter))\n\t\t\t\tdev_warn(&pdev->dev,\n\t\t\t\t\t\"Multi rfd not support yet!\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tatl1c_clean_rfd(rfd_ring, rrs, rfd_num);\n\t\tskb_put(skb, length - ETH_FCS_LEN);\n\t\tskb->protocol = eth_type_trans(skb, netdev);\n\t\tatl1c_rx_checksum(adapter, skb, rrs);\n\t\tif (rrs->word3 & RRS_VLAN_INS) {\n\t\t\tu16 vlan;\n\n\t\t\tAT_TAG_TO_VLAN(rrs->vlan_tag, vlan);\n\t\t\tvlan = le16_to_cpu(vlan);\n\t\t\t__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q), vlan);\n\t\t}\n\t\tnapi_gro_receive(napi, skb);\n\n\t\twork_done++;\n\t}\n\tif (work_done)\n\t\tatl1c_alloc_rx_buffer(adapter, rrd_ring->num, true);\n\n\tif (work_done < budget) {\nquit_polling:\n\t\tnapi_complete_done(napi, work_done);\n\t\tspin_lock_irqsave(&adapter->hw.intr_mask_lock, flags);\n\t\tadapter->hw.intr_mask |= atl1c_qregs[rrd_ring->num].rx_isr;\n\t\tAT_WRITE_REG(&adapter->hw, REG_IMR, adapter->hw.intr_mask);\n\t\tspin_unlock_irqrestore(&adapter->hw.intr_mask_lock, flags);\n\t}\n\treturn work_done;\n}\n\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\n \nstatic void atl1c_netpoll(struct net_device *netdev)\n{\n\tstruct atl1c_adapter *adapter = netdev_priv(netdev);\n\n\tdisable_irq(adapter->pdev->irq);\n\tatl1c_intr(adapter->pdev->irq, netdev);\n\tenable_irq(adapter->pdev->irq);\n}\n#endif\n\nstatic inline u16 atl1c_tpd_avail(struct atl1c_adapter *adapter, u32 queue)\n{\n\tstruct atl1c_tpd_ring *tpd_ring = &adapter->tpd_ring[queue];\n\tu16 next_to_use = 0;\n\tu16 next_to_clean = 0;\n\n\tnext_to_clean = atomic_read(&tpd_ring->next_to_clean);\n\tnext_to_use   = tpd_ring->next_to_use;\n\n\treturn (u16)(next_to_clean > next_to_use) ?\n\t\t(next_to_clean - next_to_use - 1) :\n\t\t(tpd_ring->count + next_to_clean - next_to_use - 1);\n}\n\n \nstatic struct atl1c_tpd_desc *atl1c_get_tpd(struct atl1c_adapter *adapter,\n\t\t\t\t\t    u32 queue)\n{\n\tstruct atl1c_tpd_ring *tpd_ring = &adapter->tpd_ring[queue];\n\tstruct atl1c_tpd_desc *tpd_desc;\n\tu16 next_to_use = 0;\n\n\tnext_to_use = tpd_ring->next_to_use;\n\tif (++tpd_ring->next_to_use == tpd_ring->count)\n\t\ttpd_ring->next_to_use = 0;\n\ttpd_desc = ATL1C_TPD_DESC(tpd_ring, next_to_use);\n\tmemset(tpd_desc, 0, sizeof(struct atl1c_tpd_desc));\n\treturn\ttpd_desc;\n}\n\nstatic struct atl1c_buffer *\natl1c_get_tx_buffer(struct atl1c_adapter *adapter, struct atl1c_tpd_desc *tpd)\n{\n\tstruct atl1c_tpd_ring *tpd_ring = adapter->tpd_ring;\n\n\treturn &tpd_ring->buffer_info[tpd -\n\t\t\t(struct atl1c_tpd_desc *)tpd_ring->desc];\n}\n\n \nstatic u16 atl1c_cal_tpd_req(const struct sk_buff *skb)\n{\n\tu16 tpd_req;\n\tu16 proto_hdr_len = 0;\n\n\ttpd_req = skb_shinfo(skb)->nr_frags + 1;\n\n\tif (skb_is_gso(skb)) {\n\t\tproto_hdr_len = skb_tcp_all_headers(skb);\n\t\tif (proto_hdr_len < skb_headlen(skb))\n\t\t\ttpd_req++;\n\t\tif (skb_shinfo(skb)->gso_type & SKB_GSO_TCPV6)\n\t\t\ttpd_req++;\n\t}\n\treturn tpd_req;\n}\n\nstatic int atl1c_tso_csum(struct atl1c_adapter *adapter,\n\t\t\t  struct sk_buff *skb,\n\t\t\t  struct atl1c_tpd_desc **tpd,\n\t\t\t  u32 queue)\n{\n\tstruct pci_dev *pdev = adapter->pdev;\n\tunsigned short offload_type;\n\tu8 hdr_len;\n\tu32 real_len;\n\n\tif (skb_is_gso(skb)) {\n\t\tint err;\n\n\t\terr = skb_cow_head(skb, 0);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\toffload_type = skb_shinfo(skb)->gso_type;\n\n\t\tif (offload_type & SKB_GSO_TCPV4) {\n\t\t\treal_len = (((unsigned char *)ip_hdr(skb) - skb->data)\n\t\t\t\t\t+ ntohs(ip_hdr(skb)->tot_len));\n\n\t\t\tif (real_len < skb->len) {\n\t\t\t\terr = pskb_trim(skb, real_len);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t}\n\n\t\t\thdr_len = skb_tcp_all_headers(skb);\n\t\t\tif (unlikely(skb->len == hdr_len)) {\n\t\t\t\t \n\t\t\t\tif (netif_msg_tx_queued(adapter))\n\t\t\t\t\tdev_warn(&pdev->dev,\n\t\t\t\t\t\t\"IPV4 tso with zero data??\\n\");\n\t\t\t\tgoto check_sum;\n\t\t\t} else {\n\t\t\t\tip_hdr(skb)->check = 0;\n\t\t\t\ttcp_hdr(skb)->check = ~csum_tcpudp_magic(\n\t\t\t\t\t\t\tip_hdr(skb)->saddr,\n\t\t\t\t\t\t\tip_hdr(skb)->daddr,\n\t\t\t\t\t\t\t0, IPPROTO_TCP, 0);\n\t\t\t\t(*tpd)->word1 |= 1 << TPD_IPV4_PACKET_SHIFT;\n\t\t\t}\n\t\t}\n\n\t\tif (offload_type & SKB_GSO_TCPV6) {\n\t\t\tstruct atl1c_tpd_ext_desc *etpd =\n\t\t\t\t*(struct atl1c_tpd_ext_desc **)(tpd);\n\n\t\t\tmemset(etpd, 0, sizeof(struct atl1c_tpd_ext_desc));\n\t\t\t*tpd = atl1c_get_tpd(adapter, queue);\n\t\t\tipv6_hdr(skb)->payload_len = 0;\n\t\t\t \n\t\t\thdr_len = skb_tcp_all_headers(skb);\n\t\t\tif (unlikely(skb->len == hdr_len)) {\n\t\t\t\t \n\t\t\t\tif (netif_msg_tx_queued(adapter))\n\t\t\t\t\tdev_warn(&pdev->dev,\n\t\t\t\t\t\t\"IPV6 tso with zero data??\\n\");\n\t\t\t\tgoto check_sum;\n\t\t\t} else\n\t\t\t\ttcp_v6_gso_csum_prep(skb);\n\n\t\t\tetpd->word1 |= 1 << TPD_LSO_EN_SHIFT;\n\t\t\tetpd->word1 |= 1 << TPD_LSO_VER_SHIFT;\n\t\t\tetpd->pkt_len = cpu_to_le32(skb->len);\n\t\t\t(*tpd)->word1 |= 1 << TPD_LSO_VER_SHIFT;\n\t\t}\n\n\t\t(*tpd)->word1 |= 1 << TPD_LSO_EN_SHIFT;\n\t\t(*tpd)->word1 |= (skb_transport_offset(skb) & TPD_TCPHDR_OFFSET_MASK) <<\n\t\t\t\tTPD_TCPHDR_OFFSET_SHIFT;\n\t\t(*tpd)->word1 |= (skb_shinfo(skb)->gso_size & TPD_MSS_MASK) <<\n\t\t\t\tTPD_MSS_SHIFT;\n\t\treturn 0;\n\t}\n\ncheck_sum:\n\tif (likely(skb->ip_summed == CHECKSUM_PARTIAL)) {\n\t\tu8 css, cso;\n\t\tcso = skb_checksum_start_offset(skb);\n\n\t\tif (unlikely(cso & 0x1)) {\n\t\t\tif (netif_msg_tx_err(adapter))\n\t\t\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\t\t\"payload offset should not an event number\\n\");\n\t\t\treturn -1;\n\t\t} else {\n\t\t\tcss = cso + skb->csum_offset;\n\n\t\t\t(*tpd)->word1 |= ((cso >> 1) & TPD_PLOADOFFSET_MASK) <<\n\t\t\t\t\tTPD_PLOADOFFSET_SHIFT;\n\t\t\t(*tpd)->word1 |= ((css >> 1) & TPD_CCSUM_OFFSET_MASK) <<\n\t\t\t\t\tTPD_CCSUM_OFFSET_SHIFT;\n\t\t\t(*tpd)->word1 |= 1 << TPD_CCSUM_EN_SHIFT;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void atl1c_tx_rollback(struct atl1c_adapter *adpt,\n\t\t\t      struct atl1c_tpd_desc *first_tpd,\n\t\t\t      u32 queue)\n{\n\tstruct atl1c_tpd_ring *tpd_ring = &adpt->tpd_ring[queue];\n\tstruct atl1c_buffer *buffer_info;\n\tstruct atl1c_tpd_desc *tpd;\n\tu16 first_index, index;\n\n\tfirst_index = first_tpd - (struct atl1c_tpd_desc *)tpd_ring->desc;\n\tindex = first_index;\n\twhile (index != tpd_ring->next_to_use) {\n\t\ttpd = ATL1C_TPD_DESC(tpd_ring, index);\n\t\tbuffer_info = &tpd_ring->buffer_info[index];\n\t\tatl1c_clean_buffer(adpt->pdev, buffer_info);\n\t\tmemset(tpd, 0, sizeof(struct atl1c_tpd_desc));\n\t\tif (++index == tpd_ring->count)\n\t\t\tindex = 0;\n\t}\n\ttpd_ring->next_to_use = first_index;\n}\n\nstatic int atl1c_tx_map(struct atl1c_adapter *adapter,\n\t\t\tstruct sk_buff *skb, struct atl1c_tpd_desc *tpd,\n\t\t\tu32 queue)\n{\n\tstruct atl1c_tpd_desc *use_tpd = NULL;\n\tstruct atl1c_buffer *buffer_info = NULL;\n\tu16 buf_len = skb_headlen(skb);\n\tu16 map_len = 0;\n\tu16 mapped_len = 0;\n\tu16 hdr_len = 0;\n\tu16 nr_frags;\n\tu16 f;\n\tint tso;\n\n\tnr_frags = skb_shinfo(skb)->nr_frags;\n\ttso = (tpd->word1 >> TPD_LSO_EN_SHIFT) & TPD_LSO_EN_MASK;\n\tif (tso) {\n\t\t \n\t\thdr_len = skb_tcp_all_headers(skb);\n\t\tmap_len = hdr_len;\n\t\tuse_tpd = tpd;\n\n\t\tbuffer_info = atl1c_get_tx_buffer(adapter, use_tpd);\n\t\tbuffer_info->length = map_len;\n\t\tbuffer_info->dma = dma_map_single(&adapter->pdev->dev,\n\t\t\t\t\t\t  skb->data, hdr_len,\n\t\t\t\t\t\t  DMA_TO_DEVICE);\n\t\tif (unlikely(dma_mapping_error(&adapter->pdev->dev, buffer_info->dma)))\n\t\t\tgoto err_dma;\n\t\tATL1C_SET_BUFFER_STATE(buffer_info, ATL1C_BUFFER_BUSY);\n\t\tATL1C_SET_PCIMAP_TYPE(buffer_info, ATL1C_PCIMAP_SINGLE,\n\t\t\tATL1C_PCIMAP_TODEVICE);\n\t\tmapped_len += map_len;\n\t\tuse_tpd->buffer_addr = cpu_to_le64(buffer_info->dma);\n\t\tuse_tpd->buffer_len = cpu_to_le16(buffer_info->length);\n\t}\n\n\tif (mapped_len < buf_len) {\n\t\t \n\t\tif (mapped_len == 0)\n\t\t\tuse_tpd = tpd;\n\t\telse {\n\t\t\tuse_tpd = atl1c_get_tpd(adapter, queue);\n\t\t\tmemcpy(use_tpd, tpd, sizeof(struct atl1c_tpd_desc));\n\t\t}\n\t\tbuffer_info = atl1c_get_tx_buffer(adapter, use_tpd);\n\t\tbuffer_info->length = buf_len - mapped_len;\n\t\tbuffer_info->dma =\n\t\t\tdma_map_single(&adapter->pdev->dev,\n\t\t\t\t       skb->data + mapped_len,\n\t\t\t\t       buffer_info->length, DMA_TO_DEVICE);\n\t\tif (unlikely(dma_mapping_error(&adapter->pdev->dev, buffer_info->dma)))\n\t\t\tgoto err_dma;\n\n\t\tATL1C_SET_BUFFER_STATE(buffer_info, ATL1C_BUFFER_BUSY);\n\t\tATL1C_SET_PCIMAP_TYPE(buffer_info, ATL1C_PCIMAP_SINGLE,\n\t\t\tATL1C_PCIMAP_TODEVICE);\n\t\tuse_tpd->buffer_addr = cpu_to_le64(buffer_info->dma);\n\t\tuse_tpd->buffer_len  = cpu_to_le16(buffer_info->length);\n\t}\n\n\tfor (f = 0; f < nr_frags; f++) {\n\t\tskb_frag_t *frag = &skb_shinfo(skb)->frags[f];\n\n\t\tuse_tpd = atl1c_get_tpd(adapter, queue);\n\t\tmemcpy(use_tpd, tpd, sizeof(struct atl1c_tpd_desc));\n\n\t\tbuffer_info = atl1c_get_tx_buffer(adapter, use_tpd);\n\t\tbuffer_info->length = skb_frag_size(frag);\n\t\tbuffer_info->dma = skb_frag_dma_map(&adapter->pdev->dev,\n\t\t\t\t\t\t    frag, 0,\n\t\t\t\t\t\t    buffer_info->length,\n\t\t\t\t\t\t    DMA_TO_DEVICE);\n\t\tif (dma_mapping_error(&adapter->pdev->dev, buffer_info->dma))\n\t\t\tgoto err_dma;\n\n\t\tATL1C_SET_BUFFER_STATE(buffer_info, ATL1C_BUFFER_BUSY);\n\t\tATL1C_SET_PCIMAP_TYPE(buffer_info, ATL1C_PCIMAP_PAGE,\n\t\t\tATL1C_PCIMAP_TODEVICE);\n\t\tuse_tpd->buffer_addr = cpu_to_le64(buffer_info->dma);\n\t\tuse_tpd->buffer_len  = cpu_to_le16(buffer_info->length);\n\t}\n\n\t \n\tuse_tpd->word1 |= 1 << TPD_EOP_SHIFT;\n\t \n\tbuffer_info->skb = skb;\n\n\treturn 0;\n\nerr_dma:\n\tbuffer_info->dma = 0;\n\tbuffer_info->length = 0;\n\treturn -1;\n}\n\nstatic void atl1c_tx_queue(struct atl1c_adapter *adapter, u32 queue)\n{\n\tstruct atl1c_tpd_ring *tpd_ring = &adapter->tpd_ring[queue];\n\n\tAT_WRITE_REGW(&adapter->hw, atl1c_qregs[queue].tpd_prod,\n\t\t      tpd_ring->next_to_use);\n}\n\nstatic netdev_tx_t atl1c_xmit_frame(struct sk_buff *skb,\n\t\t\t\t\t  struct net_device *netdev)\n{\n\tstruct atl1c_adapter *adapter = netdev_priv(netdev);\n\tu32 queue = skb_get_queue_mapping(skb);\n\tstruct netdev_queue *txq = netdev_get_tx_queue(netdev, queue);\n\tstruct atl1c_tpd_desc *tpd;\n\tu16 tpd_req;\n\n\tif (test_bit(__AT_DOWN, &adapter->flags)) {\n\t\tdev_kfree_skb_any(skb);\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\ttpd_req = atl1c_cal_tpd_req(skb);\n\n\tif (atl1c_tpd_avail(adapter, queue) < tpd_req) {\n\t\t \n\t\tatl1c_tx_queue(adapter, queue);\n\t\tnetif_tx_stop_queue(txq);\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\n\ttpd = atl1c_get_tpd(adapter, queue);\n\n\t \n\tif (atl1c_tso_csum(adapter, skb, &tpd, queue) != 0) {\n\t\tatl1c_tx_queue(adapter, queue);\n\t\tdev_kfree_skb_any(skb);\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\tif (unlikely(skb_vlan_tag_present(skb))) {\n\t\tu16 vlan = skb_vlan_tag_get(skb);\n\t\t__le16 tag;\n\n\t\tvlan = cpu_to_le16(vlan);\n\t\tAT_VLAN_TO_TAG(vlan, tag);\n\t\ttpd->word1 |= 1 << TPD_INS_VTAG_SHIFT;\n\t\ttpd->vlan_tag = tag;\n\t}\n\n\tif (skb_network_offset(skb) != ETH_HLEN)\n\t\ttpd->word1 |= 1 << TPD_ETH_TYPE_SHIFT;  \n\n\tif (atl1c_tx_map(adapter, skb, tpd, queue) < 0) {\n\t\tnetif_info(adapter, tx_done, adapter->netdev,\n\t\t\t   \"tx-skb dropped due to dma error\\n\");\n\t\t \n\t\tatl1c_tx_rollback(adapter, tpd, queue);\n\t\tdev_kfree_skb_any(skb);\n\t} else {\n\t\tbool more = netdev_xmit_more();\n\n\t\tif (__netdev_tx_sent_queue(txq, skb->len, more))\n\t\t\tatl1c_tx_queue(adapter, queue);\n\t}\n\n\treturn NETDEV_TX_OK;\n}\n\nstatic void atl1c_free_irq(struct atl1c_adapter *adapter)\n{\n\tstruct net_device *netdev = adapter->netdev;\n\n\tfree_irq(adapter->pdev->irq, netdev);\n\n\tif (adapter->have_msi)\n\t\tpci_disable_msi(adapter->pdev);\n}\n\nstatic int atl1c_request_irq(struct atl1c_adapter *adapter)\n{\n\tstruct pci_dev    *pdev   = adapter->pdev;\n\tstruct net_device *netdev = adapter->netdev;\n\tint flags = 0;\n\tint err = 0;\n\n\tadapter->have_msi = true;\n\terr = pci_enable_msi(adapter->pdev);\n\tif (err) {\n\t\tif (netif_msg_ifup(adapter))\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"Unable to allocate MSI interrupt Error: %d\\n\",\n\t\t\t\terr);\n\t\tadapter->have_msi = false;\n\t}\n\n\tif (!adapter->have_msi)\n\t\tflags |= IRQF_SHARED;\n\terr = request_irq(adapter->pdev->irq, atl1c_intr, flags,\n\t\t\tnetdev->name, netdev);\n\tif (err) {\n\t\tif (netif_msg_ifup(adapter))\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"Unable to allocate interrupt Error: %d\\n\",\n\t\t\t\terr);\n\t\tif (adapter->have_msi)\n\t\t\tpci_disable_msi(adapter->pdev);\n\t\treturn err;\n\t}\n\tif (netif_msg_ifup(adapter))\n\t\tdev_dbg(&pdev->dev, \"atl1c_request_irq OK\\n\");\n\treturn err;\n}\n\n\nstatic void atl1c_reset_dma_ring(struct atl1c_adapter *adapter)\n{\n\tint i;\n\t \n\tfor (i = 0; i < adapter->tx_queue_count; ++i)\n\t\tatl1c_clean_tx_ring(adapter, i);\n\tfor (i = 0; i < adapter->rx_queue_count; ++i)\n\t\tatl1c_clean_rx_ring(adapter, i);\n}\n\nstatic int atl1c_up(struct atl1c_adapter *adapter)\n{\n\tstruct net_device *netdev = adapter->netdev;\n\tint err;\n\tint i;\n\n\tnetif_carrier_off(netdev);\n\n\terr = atl1c_configure(adapter);\n\tif (unlikely(err))\n\t\tgoto err_up;\n\n\terr = atl1c_request_irq(adapter);\n\tif (unlikely(err))\n\t\tgoto err_up;\n\n\tatl1c_check_link_status(adapter);\n\tclear_bit(__AT_DOWN, &adapter->flags);\n\tfor (i = 0; i < adapter->tx_queue_count; ++i)\n\t\tnapi_enable(&adapter->tpd_ring[i].napi);\n\tfor (i = 0; i < adapter->rx_queue_count; ++i)\n\t\tnapi_enable(&adapter->rrd_ring[i].napi);\n\tatl1c_irq_enable(adapter);\n\tnetif_start_queue(netdev);\n\treturn err;\n\nerr_up:\n\tfor (i = 0; i < adapter->rx_queue_count; ++i)\n\t\tatl1c_clean_rx_ring(adapter, i);\n\treturn err;\n}\n\nstatic void atl1c_down(struct atl1c_adapter *adapter)\n{\n\tstruct net_device *netdev = adapter->netdev;\n\tint i;\n\n\tatl1c_del_timer(adapter);\n\tadapter->work_event = 0;  \n\t \n\tset_bit(__AT_DOWN, &adapter->flags);\n\tnetif_carrier_off(netdev);\n\tfor (i = 0; i < adapter->tx_queue_count; ++i)\n\t\tnapi_disable(&adapter->tpd_ring[i].napi);\n\tfor (i = 0; i < adapter->rx_queue_count; ++i)\n\t\tnapi_disable(&adapter->rrd_ring[i].napi);\n\tatl1c_irq_disable(adapter);\n\tatl1c_free_irq(adapter);\n\t \n\tatl1c_disable_l0s_l1(&adapter->hw);\n\t \n\tatl1c_reset_mac(&adapter->hw);\n\tmsleep(1);\n\n\tadapter->link_speed = SPEED_0;\n\tadapter->link_duplex = -1;\n\tatl1c_reset_dma_ring(adapter);\n}\n\n \nstatic int atl1c_open(struct net_device *netdev)\n{\n\tstruct atl1c_adapter *adapter = netdev_priv(netdev);\n\tint err;\n\n\t \n\tif (test_bit(__AT_TESTING, &adapter->flags))\n\t\treturn -EBUSY;\n\n\t \n\terr = atl1c_setup_ring_resources(adapter);\n\tif (unlikely(err))\n\t\treturn err;\n\n\terr = atl1c_up(adapter);\n\tif (unlikely(err))\n\t\tgoto err_up;\n\n\treturn 0;\n\nerr_up:\n\tatl1c_free_irq(adapter);\n\tatl1c_free_ring_resources(adapter);\n\tatl1c_reset_mac(&adapter->hw);\n\treturn err;\n}\n\n \nstatic int atl1c_close(struct net_device *netdev)\n{\n\tstruct atl1c_adapter *adapter = netdev_priv(netdev);\n\n\tWARN_ON(test_bit(__AT_RESETTING, &adapter->flags));\n\tset_bit(__AT_DOWN, &adapter->flags);\n\tcancel_work_sync(&adapter->common_task);\n\tatl1c_down(adapter);\n\tatl1c_free_ring_resources(adapter);\n\treturn 0;\n}\n\nstatic int atl1c_suspend(struct device *dev)\n{\n\tstruct net_device *netdev = dev_get_drvdata(dev);\n\tstruct atl1c_adapter *adapter = netdev_priv(netdev);\n\tstruct atl1c_hw *hw = &adapter->hw;\n\tu32 wufc = adapter->wol;\n\n\tatl1c_disable_l0s_l1(hw);\n\tif (netif_running(netdev)) {\n\t\tWARN_ON(test_bit(__AT_RESETTING, &adapter->flags));\n\t\tatl1c_down(adapter);\n\t}\n\tnetif_device_detach(netdev);\n\n\tif (wufc)\n\t\tif (atl1c_phy_to_ps_link(hw) != 0)\n\t\t\tdev_dbg(dev, \"phy power saving failed\");\n\n\tatl1c_power_saving(hw, wufc);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int atl1c_resume(struct device *dev)\n{\n\tstruct net_device *netdev = dev_get_drvdata(dev);\n\tstruct atl1c_adapter *adapter = netdev_priv(netdev);\n\n\tAT_WRITE_REG(&adapter->hw, REG_WOL_CTRL, 0);\n\tatl1c_reset_pcie(&adapter->hw, ATL1C_PCIE_L0S_L1_DISABLE);\n\n\tatl1c_phy_reset(&adapter->hw);\n\tatl1c_reset_mac(&adapter->hw);\n\tatl1c_phy_init(&adapter->hw);\n\n\tnetif_device_attach(netdev);\n\tif (netif_running(netdev))\n\t\tatl1c_up(adapter);\n\n\treturn 0;\n}\n#endif\n\nstatic void atl1c_shutdown(struct pci_dev *pdev)\n{\n\tstruct net_device *netdev = pci_get_drvdata(pdev);\n\tstruct atl1c_adapter *adapter = netdev_priv(netdev);\n\n\tatl1c_suspend(&pdev->dev);\n\tpci_wake_from_d3(pdev, adapter->wol);\n\tpci_set_power_state(pdev, PCI_D3hot);\n}\n\nstatic const struct net_device_ops atl1c_netdev_ops = {\n\t.ndo_open\t\t= atl1c_open,\n\t.ndo_stop\t\t= atl1c_close,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_start_xmit\t\t= atl1c_xmit_frame,\n\t.ndo_set_mac_address\t= atl1c_set_mac_addr,\n\t.ndo_set_rx_mode\t= atl1c_set_multi,\n\t.ndo_change_mtu\t\t= atl1c_change_mtu,\n\t.ndo_fix_features\t= atl1c_fix_features,\n\t.ndo_set_features\t= atl1c_set_features,\n\t.ndo_eth_ioctl\t\t= atl1c_ioctl,\n\t.ndo_tx_timeout\t\t= atl1c_tx_timeout,\n\t.ndo_get_stats\t\t= atl1c_get_stats,\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\t.ndo_poll_controller\t= atl1c_netpoll,\n#endif\n};\n\nstatic int atl1c_init_netdev(struct net_device *netdev, struct pci_dev *pdev)\n{\n\tSET_NETDEV_DEV(netdev, &pdev->dev);\n\tpci_set_drvdata(pdev, netdev);\n\n\tnetdev->netdev_ops = &atl1c_netdev_ops;\n\tnetdev->watchdog_timeo = AT_TX_WATCHDOG;\n\tnetdev->min_mtu = ETH_ZLEN - (ETH_HLEN + VLAN_HLEN);\n\tatl1c_set_ethtool_ops(netdev);\n\n\t \n\tnetdev->hw_features =\tNETIF_F_SG\t\t|\n\t\t\t\tNETIF_F_HW_CSUM\t\t|\n\t\t\t\tNETIF_F_HW_VLAN_CTAG_RX\t|\n\t\t\t\tNETIF_F_TSO\t\t|\n\t\t\t\tNETIF_F_TSO6;\n\tnetdev->features =\tnetdev->hw_features\t|\n\t\t\t\tNETIF_F_HW_VLAN_CTAG_TX;\n\treturn 0;\n}\n\n \nstatic int atl1c_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tstruct net_device *netdev;\n\tstruct atl1c_adapter *adapter;\n\tstatic int cards_found;\n\tu8 __iomem *hw_addr;\n\tenum atl1c_nic_type nic_type;\n\tu32 queue_count = 1;\n\tint err = 0;\n\tint i;\n\n\t \n\terr = pci_enable_device_mem(pdev);\n\tif (err)\n\t\treturn dev_err_probe(&pdev->dev, err, \"cannot enable PCI device\\n\");\n\n\t \n\terr = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(32));\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"No usable DMA configuration,aborting\\n\");\n\t\tgoto err_dma;\n\t}\n\n\terr = pci_request_regions(pdev, atl1c_driver_name);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"cannot obtain PCI resources\\n\");\n\t\tgoto err_pci_reg;\n\t}\n\n\tpci_set_master(pdev);\n\n\thw_addr = pci_ioremap_bar(pdev, 0);\n\tif (!hw_addr) {\n\t\terr = -EIO;\n\t\tdev_err(&pdev->dev, \"cannot map device registers\\n\");\n\t\tgoto err_ioremap;\n\t}\n\n\tnic_type = atl1c_get_mac_type(pdev, hw_addr);\n\tif (nic_type == athr_mt)\n\t\tqueue_count = 4;\n\n\tnetdev = alloc_etherdev_mq(sizeof(struct atl1c_adapter), queue_count);\n\tif (netdev == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto err_alloc_etherdev;\n\t}\n\n\terr = atl1c_init_netdev(netdev, pdev);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"init netdevice failed\\n\");\n\t\tgoto err_init_netdev;\n\t}\n\tadapter = netdev_priv(netdev);\n\tadapter->bd_number = cards_found;\n\tadapter->netdev = netdev;\n\tadapter->pdev = pdev;\n\tadapter->hw.adapter = adapter;\n\tadapter->hw.nic_type = nic_type;\n\tadapter->msg_enable = netif_msg_init(-1, atl1c_default_msg);\n\tadapter->hw.hw_addr = hw_addr;\n\tadapter->tx_queue_count = queue_count;\n\tadapter->rx_queue_count = queue_count;\n\n\t \n\tadapter->mii.dev = netdev;\n\tadapter->mii.mdio_read  = atl1c_mdio_read;\n\tadapter->mii.mdio_write = atl1c_mdio_write;\n\tadapter->mii.phy_id_mask = 0x1f;\n\tadapter->mii.reg_num_mask = MDIO_CTRL_REG_MASK;\n\tdev_set_threaded(netdev, true);\n\tfor (i = 0; i < adapter->rx_queue_count; ++i)\n\t\tnetif_napi_add(netdev, &adapter->rrd_ring[i].napi,\n\t\t\t       atl1c_clean_rx);\n\tfor (i = 0; i < adapter->tx_queue_count; ++i)\n\t\tnetif_napi_add_tx(netdev, &adapter->tpd_ring[i].napi,\n\t\t\t\t  atl1c_clean_tx);\n\ttimer_setup(&adapter->phy_config_timer, atl1c_phy_config, 0);\n\t \n\terr = atl1c_sw_init(adapter);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"net device private data init failed\\n\");\n\t\tgoto err_sw_init;\n\t}\n\t \n\tatl1c_set_max_mtu(netdev);\n\n\tatl1c_reset_pcie(&adapter->hw, ATL1C_PCIE_L0S_L1_DISABLE);\n\n\t \n\tatl1c_phy_reset(&adapter->hw);\n\n\terr = atl1c_reset_mac(&adapter->hw);\n\tif (err) {\n\t\terr = -EIO;\n\t\tgoto err_reset;\n\t}\n\n\t \n\terr = atl1c_phy_init(&adapter->hw);\n\tif (err) {\n\t\terr = -EIO;\n\t\tgoto err_reset;\n\t}\n\tif (atl1c_read_mac_addr(&adapter->hw)) {\n\t\t \n\t\tnetdev->addr_assign_type = NET_ADDR_RANDOM;\n\t}\n\teth_hw_addr_set(netdev, adapter->hw.mac_addr);\n\tif (netif_msg_probe(adapter))\n\t\tdev_dbg(&pdev->dev, \"mac address : %pM\\n\",\n\t\t\tadapter->hw.mac_addr);\n\n\tatl1c_hw_set_mac_addr(&adapter->hw, adapter->hw.mac_addr);\n\tINIT_WORK(&adapter->common_task, atl1c_common_task);\n\tadapter->work_event = 0;\n\terr = register_netdev(netdev);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"register netdevice failed\\n\");\n\t\tgoto err_register;\n\t}\n\n\tcards_found++;\n\treturn 0;\n\nerr_reset:\nerr_register:\nerr_sw_init:\nerr_init_netdev:\n\tfree_netdev(netdev);\nerr_alloc_etherdev:\n\tiounmap(hw_addr);\nerr_ioremap:\n\tpci_release_regions(pdev);\nerr_pci_reg:\nerr_dma:\n\tpci_disable_device(pdev);\n\treturn err;\n}\n\n \nstatic void atl1c_remove(struct pci_dev *pdev)\n{\n\tstruct net_device *netdev = pci_get_drvdata(pdev);\n\tstruct atl1c_adapter *adapter = netdev_priv(netdev);\n\n\tunregister_netdev(netdev);\n\t \n\tatl1c_hw_set_mac_addr(&adapter->hw, adapter->hw.perm_mac_addr);\n\tatl1c_phy_disable(&adapter->hw);\n\n\tiounmap(adapter->hw.hw_addr);\n\n\tpci_release_regions(pdev);\n\tpci_disable_device(pdev);\n\tfree_netdev(netdev);\n}\n\n \nstatic pci_ers_result_t atl1c_io_error_detected(struct pci_dev *pdev,\n\t\t\t\t\t\tpci_channel_state_t state)\n{\n\tstruct net_device *netdev = pci_get_drvdata(pdev);\n\tstruct atl1c_adapter *adapter = netdev_priv(netdev);\n\n\tnetif_device_detach(netdev);\n\n\tif (state == pci_channel_io_perm_failure)\n\t\treturn PCI_ERS_RESULT_DISCONNECT;\n\n\tif (netif_running(netdev))\n\t\tatl1c_down(adapter);\n\n\tpci_disable_device(pdev);\n\n\t \n\treturn PCI_ERS_RESULT_NEED_RESET;\n}\n\n \nstatic pci_ers_result_t atl1c_io_slot_reset(struct pci_dev *pdev)\n{\n\tstruct net_device *netdev = pci_get_drvdata(pdev);\n\tstruct atl1c_adapter *adapter = netdev_priv(netdev);\n\n\tif (pci_enable_device(pdev)) {\n\t\tif (netif_msg_hw(adapter))\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"Cannot re-enable PCI device after reset\\n\");\n\t\treturn PCI_ERS_RESULT_DISCONNECT;\n\t}\n\tpci_set_master(pdev);\n\n\tpci_enable_wake(pdev, PCI_D3hot, 0);\n\tpci_enable_wake(pdev, PCI_D3cold, 0);\n\n\tatl1c_reset_mac(&adapter->hw);\n\n\treturn PCI_ERS_RESULT_RECOVERED;\n}\n\n \nstatic void atl1c_io_resume(struct pci_dev *pdev)\n{\n\tstruct net_device *netdev = pci_get_drvdata(pdev);\n\tstruct atl1c_adapter *adapter = netdev_priv(netdev);\n\n\tif (netif_running(netdev)) {\n\t\tif (atl1c_up(adapter)) {\n\t\t\tif (netif_msg_hw(adapter))\n\t\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\t\"Cannot bring device back up after reset\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\tnetif_device_attach(netdev);\n}\n\nstatic const struct pci_error_handlers atl1c_err_handler = {\n\t.error_detected = atl1c_io_error_detected,\n\t.slot_reset = atl1c_io_slot_reset,\n\t.resume = atl1c_io_resume,\n};\n\nstatic SIMPLE_DEV_PM_OPS(atl1c_pm_ops, atl1c_suspend, atl1c_resume);\n\nstatic struct pci_driver atl1c_driver = {\n\t.name     = atl1c_driver_name,\n\t.id_table = atl1c_pci_tbl,\n\t.probe    = atl1c_probe,\n\t.remove   = atl1c_remove,\n\t.shutdown = atl1c_shutdown,\n\t.err_handler = &atl1c_err_handler,\n\t.driver.pm = &atl1c_pm_ops,\n};\n\nmodule_pci_driver(atl1c_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}