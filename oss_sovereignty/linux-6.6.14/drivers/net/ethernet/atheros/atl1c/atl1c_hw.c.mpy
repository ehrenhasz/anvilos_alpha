{
  "module_name": "atl1c_hw.c",
  "hash_id": "147190246fb0f1e5ef14eeebe66e11c52338d4a10e00af81ab4bacbb8e1979da",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/atheros/atl1c/atl1c_hw.c",
  "human_readable_source": "\n \n#include <linux/pci.h>\n#include <linux/delay.h>\n#include <linux/mii.h>\n#include <linux/crc32.h>\n\n#include \"atl1c.h\"\n\n \nint atl1c_check_eeprom_exist(struct atl1c_hw *hw)\n{\n\tu32 data;\n\n\tAT_READ_REG(hw, REG_TWSI_DEBUG, &data);\n\tif (data & TWSI_DEBUG_DEV_EXIST)\n\t\treturn 1;\n\n\tAT_READ_REG(hw, REG_MASTER_CTRL, &data);\n\tif (data & MASTER_CTRL_OTP_SEL)\n\t\treturn 1;\n\treturn 0;\n}\n\nvoid atl1c_hw_set_mac_addr(struct atl1c_hw *hw, u8 *mac_addr)\n{\n\tu32 value;\n\t \n\tvalue = mac_addr[2] << 24 |\n\t\tmac_addr[3] << 16 |\n\t\tmac_addr[4] << 8  |\n\t\tmac_addr[5];\n\tAT_WRITE_REG_ARRAY(hw, REG_MAC_STA_ADDR, 0, value);\n\t \n\tvalue = mac_addr[0] << 8 |\n\t\tmac_addr[1];\n\tAT_WRITE_REG_ARRAY(hw, REG_MAC_STA_ADDR, 1, value);\n}\n\n \nstatic bool atl1c_read_current_addr(struct atl1c_hw *hw, u8 *eth_addr)\n{\n\tu32 addr[2];\n\n\tAT_READ_REG(hw, REG_MAC_STA_ADDR, &addr[0]);\n\tAT_READ_REG(hw, REG_MAC_STA_ADDR + 4, &addr[1]);\n\n\t*(u32 *) &eth_addr[2] = htonl(addr[0]);\n\t*(u16 *) &eth_addr[0] = htons((u16)addr[1]);\n\n\treturn is_valid_ether_addr(eth_addr);\n}\n\n \nstatic int atl1c_get_permanent_address(struct atl1c_hw *hw)\n{\n\tu32 i;\n\tu32 otp_ctrl_data;\n\tu32 twsi_ctrl_data;\n\tu16 phy_data;\n\tbool raise_vol = false;\n\n\t \n\tif (atl1c_read_current_addr(hw, hw->perm_mac_addr))\n\t\treturn 0;\n\n\t \n\tAT_READ_REG(hw, REG_OTP_CTRL, &otp_ctrl_data);\n\tif (atl1c_check_eeprom_exist(hw)) {\n\t\tif (hw->nic_type == athr_l1c || hw->nic_type == athr_l2c) {\n\t\t\t \n\t\t\tif (!(otp_ctrl_data & OTP_CTRL_CLK_EN)) {\n\t\t\t\totp_ctrl_data |= OTP_CTRL_CLK_EN;\n\t\t\t\tAT_WRITE_REG(hw, REG_OTP_CTRL, otp_ctrl_data);\n\t\t\t\tAT_WRITE_FLUSH(hw);\n\t\t\t\tmsleep(1);\n\t\t\t}\n\t\t}\n\t\t \n\t\tif (hw->nic_type == athr_l2c_b || hw->nic_type == athr_l2c_b2) {\n\t\t\tatl1c_read_phy_dbg(hw, MIIDBG_ANACTRL, &phy_data);\n\t\t\tphy_data &= ~ANACTRL_HB_EN;\n\t\t\tatl1c_write_phy_dbg(hw, MIIDBG_ANACTRL, phy_data);\n\t\t\tatl1c_read_phy_dbg(hw, MIIDBG_VOLT_CTRL, &phy_data);\n\t\t\tphy_data |= VOLT_CTRL_SWLOWEST;\n\t\t\tatl1c_write_phy_dbg(hw, MIIDBG_VOLT_CTRL, phy_data);\n\t\t\tudelay(20);\n\t\t\traise_vol = true;\n\t\t}\n\n\t\tAT_READ_REG(hw, REG_TWSI_CTRL, &twsi_ctrl_data);\n\t\ttwsi_ctrl_data |= TWSI_CTRL_SW_LDSTART;\n\t\tAT_WRITE_REG(hw, REG_TWSI_CTRL, twsi_ctrl_data);\n\t\tfor (i = 0; i < AT_TWSI_EEPROM_TIMEOUT; i++) {\n\t\t\tmsleep(10);\n\t\t\tAT_READ_REG(hw, REG_TWSI_CTRL, &twsi_ctrl_data);\n\t\t\tif ((twsi_ctrl_data & TWSI_CTRL_SW_LDSTART) == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i >= AT_TWSI_EEPROM_TIMEOUT)\n\t\t\treturn -1;\n\t}\n\t \n\tif ((hw->nic_type == athr_l1c || hw->nic_type == athr_l2c)) {\n\t\totp_ctrl_data &= ~OTP_CTRL_CLK_EN;\n\t\tAT_WRITE_REG(hw, REG_OTP_CTRL, otp_ctrl_data);\n\t\tmsleep(1);\n\t}\n\tif (raise_vol) {\n\t\tatl1c_read_phy_dbg(hw, MIIDBG_ANACTRL, &phy_data);\n\t\tphy_data |= ANACTRL_HB_EN;\n\t\tatl1c_write_phy_dbg(hw, MIIDBG_ANACTRL, phy_data);\n\t\tatl1c_read_phy_dbg(hw, MIIDBG_VOLT_CTRL, &phy_data);\n\t\tphy_data &= ~VOLT_CTRL_SWLOWEST;\n\t\tatl1c_write_phy_dbg(hw, MIIDBG_VOLT_CTRL, phy_data);\n\t\tudelay(20);\n\t}\n\n\tif (atl1c_read_current_addr(hw, hw->perm_mac_addr))\n\t\treturn 0;\n\n\treturn -1;\n}\n\nbool atl1c_read_eeprom(struct atl1c_hw *hw, u32 offset, u32 *p_value)\n{\n\tint i;\n\tbool ret = false;\n\tu32 otp_ctrl_data;\n\tu32 control;\n\tu32 data;\n\n\tif (offset & 3)\n\t\treturn ret;  \n\n\tAT_READ_REG(hw, REG_OTP_CTRL, &otp_ctrl_data);\n\tif (!(otp_ctrl_data & OTP_CTRL_CLK_EN))\n\t\tAT_WRITE_REG(hw, REG_OTP_CTRL,\n\t\t\t\t(otp_ctrl_data | OTP_CTRL_CLK_EN));\n\n\tAT_WRITE_REG(hw, REG_EEPROM_DATA_LO, 0);\n\tcontrol = (offset & EEPROM_CTRL_ADDR_MASK) << EEPROM_CTRL_ADDR_SHIFT;\n\tAT_WRITE_REG(hw, REG_EEPROM_CTRL, control);\n\n\tfor (i = 0; i < 10; i++) {\n\t\tudelay(100);\n\t\tAT_READ_REG(hw, REG_EEPROM_CTRL, &control);\n\t\tif (control & EEPROM_CTRL_RW)\n\t\t\tbreak;\n\t}\n\tif (control & EEPROM_CTRL_RW) {\n\t\tAT_READ_REG(hw, REG_EEPROM_CTRL, &data);\n\t\tAT_READ_REG(hw, REG_EEPROM_DATA_LO, p_value);\n\t\tdata = data & 0xFFFF;\n\t\t*p_value = swab32((data << 16) | (*p_value >> 16));\n\t\tret = true;\n\t}\n\tif (!(otp_ctrl_data & OTP_CTRL_CLK_EN))\n\t\tAT_WRITE_REG(hw, REG_OTP_CTRL, otp_ctrl_data);\n\n\treturn ret;\n}\n \nint atl1c_read_mac_addr(struct atl1c_hw *hw)\n{\n\tint err = 0;\n\n\terr = atl1c_get_permanent_address(hw);\n\tif (err)\n\t\teth_random_addr(hw->perm_mac_addr);\n\n\tmemcpy(hw->mac_addr, hw->perm_mac_addr, sizeof(hw->perm_mac_addr));\n\treturn err;\n}\n\n \nu32 atl1c_hash_mc_addr(struct atl1c_hw *hw, u8 *mc_addr)\n{\n\tu32 crc32;\n\tu32 value = 0;\n\tint i;\n\n\tcrc32 = ether_crc_le(6, mc_addr);\n\tfor (i = 0; i < 32; i++)\n\t\tvalue |= (((crc32 >> i) & 1) << (31 - i));\n\n\treturn value;\n}\n\n \nvoid atl1c_hash_set(struct atl1c_hw *hw, u32 hash_value)\n{\n\tu32 hash_bit, hash_reg;\n\tu32 mta;\n\n\t \n\thash_reg = (hash_value >> 31) & 0x1;\n\thash_bit = (hash_value >> 26) & 0x1F;\n\n\tmta = AT_READ_REG_ARRAY(hw, REG_RX_HASH_TABLE, hash_reg);\n\n\tmta |= (1 << hash_bit);\n\n\tAT_WRITE_REG_ARRAY(hw, REG_RX_HASH_TABLE, hash_reg, mta);\n}\n\n \nbool atl1c_wait_mdio_idle(struct atl1c_hw *hw)\n{\n\tu32 val;\n\tint i;\n\n\tfor (i = 0; i < MDIO_MAX_AC_TO; i++) {\n\t\tAT_READ_REG(hw, REG_MDIO_CTRL, &val);\n\t\tif (!(val & (MDIO_CTRL_BUSY | MDIO_CTRL_START)))\n\t\t\tbreak;\n\t\tudelay(10);\n\t}\n\n\treturn i != MDIO_MAX_AC_TO;\n}\n\nvoid atl1c_stop_phy_polling(struct atl1c_hw *hw)\n{\n\tif (!(hw->ctrl_flags & ATL1C_FPGA_VERSION))\n\t\treturn;\n\n\tAT_WRITE_REG(hw, REG_MDIO_CTRL, 0);\n\tatl1c_wait_mdio_idle(hw);\n}\n\nvoid atl1c_start_phy_polling(struct atl1c_hw *hw, u16 clk_sel)\n{\n\tu32 val;\n\n\tif (!(hw->ctrl_flags & ATL1C_FPGA_VERSION))\n\t\treturn;\n\n\tval = MDIO_CTRL_SPRES_PRMBL |\n\t\tFIELDX(MDIO_CTRL_CLK_SEL, clk_sel) |\n\t\tFIELDX(MDIO_CTRL_REG, 1) |\n\t\tMDIO_CTRL_START |\n\t\tMDIO_CTRL_OP_READ;\n\tAT_WRITE_REG(hw, REG_MDIO_CTRL, val);\n\tatl1c_wait_mdio_idle(hw);\n\tval |= MDIO_CTRL_AP_EN;\n\tval &= ~MDIO_CTRL_START;\n\tAT_WRITE_REG(hw, REG_MDIO_CTRL, val);\n\tudelay(30);\n}\n\n\n \nint atl1c_read_phy_core(struct atl1c_hw *hw, bool ext, u8 dev,\n\t\t\tu16 reg, u16 *phy_data)\n{\n\tu32 val;\n\tu16 clk_sel = MDIO_CTRL_CLK_25_4;\n\n\tatl1c_stop_phy_polling(hw);\n\n\t*phy_data = 0;\n\n\t \n\tif ((hw->nic_type == athr_l2c_b2 || hw->nic_type == athr_l1d_2) &&\n\t\thw->hibernate)\n\t\tclk_sel = MDIO_CTRL_CLK_25_128;\n\tif (ext) {\n\t\tval = FIELDX(MDIO_EXTN_DEVAD, dev) | FIELDX(MDIO_EXTN_REG, reg);\n\t\tAT_WRITE_REG(hw, REG_MDIO_EXTN, val);\n\t\tval = MDIO_CTRL_SPRES_PRMBL |\n\t\t\tFIELDX(MDIO_CTRL_CLK_SEL, clk_sel) |\n\t\t\tMDIO_CTRL_START |\n\t\t\tMDIO_CTRL_MODE_EXT |\n\t\t\tMDIO_CTRL_OP_READ;\n\t} else {\n\t\tval = MDIO_CTRL_SPRES_PRMBL |\n\t\t\tFIELDX(MDIO_CTRL_CLK_SEL, clk_sel) |\n\t\t\tFIELDX(MDIO_CTRL_REG, reg) |\n\t\t\tMDIO_CTRL_START |\n\t\t\tMDIO_CTRL_OP_READ;\n\t}\n\tAT_WRITE_REG(hw, REG_MDIO_CTRL, val);\n\n\tif (!atl1c_wait_mdio_idle(hw))\n\t\treturn -1;\n\n\tAT_READ_REG(hw, REG_MDIO_CTRL, &val);\n\t*phy_data = (u16)FIELD_GETX(val, MDIO_CTRL_DATA);\n\n\tatl1c_start_phy_polling(hw, clk_sel);\n\n\treturn 0;\n}\n\n \nint atl1c_write_phy_core(struct atl1c_hw *hw, bool ext, u8 dev,\n\t\t\tu16 reg, u16 phy_data)\n{\n\tu32 val;\n\tu16 clk_sel = MDIO_CTRL_CLK_25_4;\n\n\tatl1c_stop_phy_polling(hw);\n\n\n\t \n\tif ((hw->nic_type == athr_l2c_b2 || hw->nic_type == athr_l1d_2) &&\n\t\thw->hibernate)\n\t\tclk_sel = MDIO_CTRL_CLK_25_128;\n\n\tif (ext) {\n\t\tval = FIELDX(MDIO_EXTN_DEVAD, dev) | FIELDX(MDIO_EXTN_REG, reg);\n\t\tAT_WRITE_REG(hw, REG_MDIO_EXTN, val);\n\t\tval = MDIO_CTRL_SPRES_PRMBL |\n\t\t\tFIELDX(MDIO_CTRL_CLK_SEL, clk_sel) |\n\t\t\tFIELDX(MDIO_CTRL_DATA, phy_data) |\n\t\t\tMDIO_CTRL_START |\n\t\t\tMDIO_CTRL_MODE_EXT;\n\t} else {\n\t\tval = MDIO_CTRL_SPRES_PRMBL |\n\t\t\tFIELDX(MDIO_CTRL_CLK_SEL, clk_sel) |\n\t\t\tFIELDX(MDIO_CTRL_DATA, phy_data) |\n\t\t\tFIELDX(MDIO_CTRL_REG, reg) |\n\t\t\tMDIO_CTRL_START;\n\t}\n\tAT_WRITE_REG(hw, REG_MDIO_CTRL, val);\n\n\tif (!atl1c_wait_mdio_idle(hw))\n\t\treturn -1;\n\n\tatl1c_start_phy_polling(hw, clk_sel);\n\n\treturn 0;\n}\n\n \nint atl1c_read_phy_reg(struct atl1c_hw *hw, u16 reg_addr, u16 *phy_data)\n{\n\treturn atl1c_read_phy_core(hw, false, 0, reg_addr, phy_data);\n}\n\n \nint atl1c_write_phy_reg(struct atl1c_hw *hw, u32 reg_addr, u16 phy_data)\n{\n\treturn atl1c_write_phy_core(hw, false, 0, reg_addr, phy_data);\n}\n\n \nint atl1c_read_phy_ext(struct atl1c_hw *hw, u8 dev_addr,\n\t\t\tu16 reg_addr, u16 *phy_data)\n{\n\treturn atl1c_read_phy_core(hw, true, dev_addr, reg_addr, phy_data);\n}\n\n \nint atl1c_write_phy_ext(struct atl1c_hw *hw, u8 dev_addr,\n\t\t\tu16 reg_addr, u16 phy_data)\n{\n\treturn atl1c_write_phy_core(hw, true, dev_addr, reg_addr, phy_data);\n}\n\nint atl1c_read_phy_dbg(struct atl1c_hw *hw, u16 reg_addr, u16 *phy_data)\n{\n\tint err;\n\n\terr = atl1c_write_phy_reg(hw, MII_DBG_ADDR, reg_addr);\n\tif (unlikely(err))\n\t\treturn err;\n\telse\n\t\terr = atl1c_read_phy_reg(hw, MII_DBG_DATA, phy_data);\n\n\treturn err;\n}\n\nint atl1c_write_phy_dbg(struct atl1c_hw *hw, u16 reg_addr, u16 phy_data)\n{\n\tint err;\n\n\terr = atl1c_write_phy_reg(hw, MII_DBG_ADDR, reg_addr);\n\tif (unlikely(err))\n\t\treturn err;\n\telse\n\t\terr = atl1c_write_phy_reg(hw, MII_DBG_DATA, phy_data);\n\n\treturn err;\n}\n\n \nstatic int atl1c_phy_setup_adv(struct atl1c_hw *hw)\n{\n\tu16 mii_adv_data = ADVERTISE_DEFAULT_CAP & ~ADVERTISE_ALL;\n\tu16 mii_giga_ctrl_data = GIGA_CR_1000T_DEFAULT_CAP &\n\t\t\t\t~GIGA_CR_1000T_SPEED_MASK;\n\n\tif (hw->autoneg_advertised & ADVERTISED_10baseT_Half)\n\t\tmii_adv_data |= ADVERTISE_10HALF;\n\tif (hw->autoneg_advertised & ADVERTISED_10baseT_Full)\n\t\tmii_adv_data |= ADVERTISE_10FULL;\n\tif (hw->autoneg_advertised & ADVERTISED_100baseT_Half)\n\t\tmii_adv_data |= ADVERTISE_100HALF;\n\tif (hw->autoneg_advertised & ADVERTISED_100baseT_Full)\n\t\tmii_adv_data |= ADVERTISE_100FULL;\n\n\tif (hw->autoneg_advertised & ADVERTISED_Autoneg)\n\t\tmii_adv_data |= ADVERTISE_10HALF  | ADVERTISE_10FULL |\n\t\t\t\tADVERTISE_100HALF | ADVERTISE_100FULL;\n\n\tif (hw->link_cap_flags & ATL1C_LINK_CAP_1000M) {\n\t\tif (hw->autoneg_advertised & ADVERTISED_1000baseT_Half)\n\t\t\tmii_giga_ctrl_data |= ADVERTISE_1000HALF;\n\t\tif (hw->autoneg_advertised & ADVERTISED_1000baseT_Full)\n\t\t\tmii_giga_ctrl_data |= ADVERTISE_1000FULL;\n\t\tif (hw->autoneg_advertised & ADVERTISED_Autoneg)\n\t\t\tmii_giga_ctrl_data |= ADVERTISE_1000HALF |\n\t\t\t\t\tADVERTISE_1000FULL;\n\t}\n\n\tif (atl1c_write_phy_reg(hw, MII_ADVERTISE, mii_adv_data) != 0 ||\n\t    atl1c_write_phy_reg(hw, MII_CTRL1000, mii_giga_ctrl_data) != 0)\n\t\treturn -1;\n\treturn 0;\n}\n\nvoid atl1c_phy_disable(struct atl1c_hw *hw)\n{\n\tatl1c_power_saving(hw, 0);\n}\n\n\nint atl1c_phy_reset(struct atl1c_hw *hw)\n{\n\tstruct atl1c_adapter *adapter = hw->adapter;\n\tstruct pci_dev *pdev = adapter->pdev;\n\tu16 phy_data;\n\tu32 phy_ctrl_data, lpi_ctrl;\n\tint err;\n\n\t \n\tAT_READ_REG(hw, REG_GPHY_CTRL, &phy_ctrl_data);\n\tphy_ctrl_data &= ~(GPHY_CTRL_EXT_RESET | GPHY_CTRL_PHY_IDDQ |\n\t\tGPHY_CTRL_GATE_25M_EN | GPHY_CTRL_PWDOWN_HW | GPHY_CTRL_CLS);\n\tphy_ctrl_data |= GPHY_CTRL_SEL_ANA_RST;\n\tif (!(hw->ctrl_flags & ATL1C_HIB_DISABLE))\n\t\tphy_ctrl_data |= (GPHY_CTRL_HIB_EN | GPHY_CTRL_HIB_PULSE);\n\telse\n\t\tphy_ctrl_data &= ~(GPHY_CTRL_HIB_EN | GPHY_CTRL_HIB_PULSE);\n\tAT_WRITE_REG(hw, REG_GPHY_CTRL, phy_ctrl_data);\n\tAT_WRITE_FLUSH(hw);\n\tudelay(10);\n\tAT_WRITE_REG(hw, REG_GPHY_CTRL, phy_ctrl_data | GPHY_CTRL_EXT_RESET);\n\tAT_WRITE_FLUSH(hw);\n\tudelay(10 * GPHY_CTRL_EXT_RST_TO);\t \n\n\t \n\tif (hw->nic_type == athr_l2c_b) {\n\t\tatl1c_read_phy_dbg(hw, MIIDBG_CFGLPSPD, &phy_data);\n\t\tatl1c_write_phy_dbg(hw, MIIDBG_CFGLPSPD,\n\t\t\tphy_data & ~CFGLPSPD_RSTCNT_CLK125SW);\n\t}\n\n\t \n\tif (hw->nic_type == athr_l2c_b || hw->nic_type == athr_l2c_b2) {\n\t\tatl1c_read_phy_dbg(hw, MIIDBG_CABLE1TH_DET, &phy_data);\n\t\tphy_data |= CABLE1TH_DET_EN;\n\t\tatl1c_write_phy_dbg(hw, MIIDBG_CABLE1TH_DET, phy_data);\n\t}\n\n\t \n\tif (!(hw->ctrl_flags & ATL1C_HIB_DISABLE)) {\n\t\tif (hw->nic_type == athr_l2c_b || hw->nic_type == athr_l2c_b2) {\n\t\t\tatl1c_read_phy_dbg(hw, MIIDBG_VOLT_CTRL, &phy_data);\n\t\t\tphy_data &= ~VOLT_CTRL_SWLOWEST;\n\t\t\tatl1c_write_phy_dbg(hw, MIIDBG_VOLT_CTRL, phy_data);\n\t\t}\n\t\t \n\t\tphy_data =\n\t\t\thw->nic_type == athr_l1d || hw->nic_type == athr_l1d_2 ?\n\t\t\tL1D_LEGCYPS_DEF : L1C_LEGCYPS_DEF;\n\t\tatl1c_write_phy_dbg(hw, MIIDBG_LEGCYPS, phy_data);\n\t\t \n\t\tatl1c_write_phy_dbg(hw, MIIDBG_SYSMODCTRL,\n\t\t\tSYSMODCTRL_IECHOADJ_DEF);\n\t} else {\n\t\t \n\t\tatl1c_read_phy_dbg(hw, MIIDBG_LEGCYPS, &phy_data);\n\t\tatl1c_write_phy_dbg(hw, MIIDBG_LEGCYPS,\n\t\t\tphy_data & ~LEGCYPS_EN);\n\t\t \n\t\tatl1c_read_phy_dbg(hw, MIIDBG_HIBNEG, &phy_data);\n\t\tatl1c_write_phy_dbg(hw, MIIDBG_HIBNEG,\n\t\t\tphy_data & HIBNEG_PSHIB_EN);\n\t}\n\t \n\tif (hw->nic_type == athr_l1d || hw->nic_type == athr_l1d_2 ||\n\t    hw->nic_type == athr_l2c_b2) {\n\t\tAT_READ_REG(hw, REG_LPI_CTRL, &lpi_ctrl);\n\t\tAT_WRITE_REG(hw, REG_LPI_CTRL, lpi_ctrl & ~LPI_CTRL_EN);\n\t\tatl1c_write_phy_ext(hw, MIIEXT_ANEG, MIIEXT_LOCAL_EEEADV, 0);\n\t\tatl1c_write_phy_ext(hw, MIIEXT_PCS, MIIEXT_CLDCTRL3,\n\t\t\tL2CB_CLDCTRL3);\n\t}\n\n\t \n\tatl1c_write_phy_dbg(hw, MIIDBG_ANACTRL, ANACTRL_DEF);\n\tatl1c_write_phy_dbg(hw, MIIDBG_SRDSYSMOD, SRDSYSMOD_DEF);\n\tatl1c_write_phy_dbg(hw, MIIDBG_TST10BTCFG, TST10BTCFG_DEF);\n\t \n\tatl1c_write_phy_dbg(hw, MIIDBG_TST100BTCFG,\n\t\tTST100BTCFG_DEF | TST100BTCFG_LITCH_EN);\n\n\t \n\tphy_data = IER_LINK_UP | IER_LINK_DOWN;\n\terr = atl1c_write_phy_reg(hw, MII_IER, phy_data);\n\tif (err) {\n\t\tif (netif_msg_hw(adapter))\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"Error enable PHY linkChange Interrupt\\n\");\n\t\treturn err;\n\t}\n\treturn 0;\n}\n\nint atl1c_phy_init(struct atl1c_hw *hw)\n{\n\tstruct atl1c_adapter *adapter = hw->adapter;\n\tstruct pci_dev *pdev = adapter->pdev;\n\tint ret_val;\n\tu16 mii_bmcr_data = BMCR_RESET;\n\n\tif (hw->nic_type == athr_mt) {\n\t\thw->phy_configured = true;\n\t\treturn 0;\n\t}\n\n\tif ((atl1c_read_phy_reg(hw, MII_PHYSID1, &hw->phy_id1) != 0) ||\n\t\t(atl1c_read_phy_reg(hw, MII_PHYSID2, &hw->phy_id2) != 0)) {\n\t\tdev_err(&pdev->dev, \"Error get phy ID\\n\");\n\t\treturn -1;\n\t}\n\tswitch (hw->media_type) {\n\tcase MEDIA_TYPE_AUTO_SENSOR:\n\t\tret_val = atl1c_phy_setup_adv(hw);\n\t\tif (ret_val) {\n\t\t\tif (netif_msg_link(adapter))\n\t\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\t\"Error Setting up Auto-Negotiation\\n\");\n\t\t\treturn ret_val;\n\t\t}\n\t\tmii_bmcr_data |= BMCR_ANENABLE | BMCR_ANRESTART;\n\t\tbreak;\n\tcase MEDIA_TYPE_100M_FULL:\n\t\tmii_bmcr_data |= BMCR_SPEED100 | BMCR_FULLDPLX;\n\t\tbreak;\n\tcase MEDIA_TYPE_100M_HALF:\n\t\tmii_bmcr_data |= BMCR_SPEED100;\n\t\tbreak;\n\tcase MEDIA_TYPE_10M_FULL:\n\t\tmii_bmcr_data |= BMCR_FULLDPLX;\n\t\tbreak;\n\tcase MEDIA_TYPE_10M_HALF:\n\t\tbreak;\n\tdefault:\n\t\tif (netif_msg_link(adapter))\n\t\t\tdev_err(&pdev->dev, \"Wrong Media type %d\\n\",\n\t\t\t\thw->media_type);\n\t\treturn -1;\n\t}\n\n\tret_val = atl1c_write_phy_reg(hw, MII_BMCR, mii_bmcr_data);\n\tif (ret_val)\n\t\treturn ret_val;\n\thw->phy_configured = true;\n\n\treturn 0;\n}\n\nbool atl1c_get_link_status(struct atl1c_hw *hw)\n{\n\tu16 phy_data;\n\n\tif (hw->nic_type == athr_mt) {\n\t\tu32 spd;\n\n\t\tAT_READ_REG(hw, REG_MT_SPEED, &spd);\n\t\treturn !!spd;\n\t}\n\n\t \n\tatl1c_read_phy_reg(hw, MII_BMSR, &phy_data);\n\tatl1c_read_phy_reg(hw, MII_BMSR, &phy_data);\n\treturn !!(phy_data & BMSR_LSTATUS);\n}\n\n \nint atl1c_get_speed_and_duplex(struct atl1c_hw *hw, u16 *speed, u16 *duplex)\n{\n\tint err;\n\tu16 phy_data;\n\n\tif (hw->nic_type == athr_mt) {\n\t\tu32 spd;\n\n\t\tAT_READ_REG(hw, REG_MT_SPEED, &spd);\n\t\t*speed = spd;\n\t\t*duplex = FULL_DUPLEX;\n\t\treturn 0;\n\t}\n\n\t \n\terr = atl1c_read_phy_reg(hw, MII_GIGA_PSSR, &phy_data);\n\tif (err)\n\t\treturn err;\n\n\tif (!(phy_data & GIGA_PSSR_SPD_DPLX_RESOLVED))\n\t\treturn -1;\n\n\tswitch (phy_data & GIGA_PSSR_SPEED) {\n\tcase GIGA_PSSR_1000MBS:\n\t\t*speed = SPEED_1000;\n\t\tbreak;\n\tcase GIGA_PSSR_100MBS:\n\t\t*speed = SPEED_100;\n\t\tbreak;\n\tcase  GIGA_PSSR_10MBS:\n\t\t*speed = SPEED_10;\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\n\tif (phy_data & GIGA_PSSR_DPLX)\n\t\t*duplex = FULL_DUPLEX;\n\telse\n\t\t*duplex = HALF_DUPLEX;\n\n\treturn 0;\n}\n\n \nint atl1c_phy_to_ps_link(struct atl1c_hw *hw)\n{\n\tstruct atl1c_adapter *adapter = hw->adapter;\n\tstruct pci_dev *pdev = adapter->pdev;\n\tint ret = 0;\n\tu16 autoneg_advertised = ADVERTISED_10baseT_Half;\n\tu16 save_autoneg_advertised;\n\tu16 mii_lpa_data;\n\tu16 speed = SPEED_0;\n\tu16 duplex = FULL_DUPLEX;\n\tint i;\n\n\tif (atl1c_get_link_status(hw)) {\n\t\tatl1c_read_phy_reg(hw, MII_LPA, &mii_lpa_data);\n\t\tif (mii_lpa_data & LPA_10FULL)\n\t\t\tautoneg_advertised = ADVERTISED_10baseT_Full;\n\t\telse if (mii_lpa_data & LPA_10HALF)\n\t\t\tautoneg_advertised = ADVERTISED_10baseT_Half;\n\t\telse if (mii_lpa_data & LPA_100HALF)\n\t\t\tautoneg_advertised = ADVERTISED_100baseT_Half;\n\t\telse if (mii_lpa_data & LPA_100FULL)\n\t\t\tautoneg_advertised = ADVERTISED_100baseT_Full;\n\n\t\tsave_autoneg_advertised = hw->autoneg_advertised;\n\t\thw->phy_configured = false;\n\t\thw->autoneg_advertised = autoneg_advertised;\n\t\tif (atl1c_restart_autoneg(hw) != 0) {\n\t\t\tdev_dbg(&pdev->dev, \"phy autoneg failed\\n\");\n\t\t\tret = -1;\n\t\t}\n\t\thw->autoneg_advertised = save_autoneg_advertised;\n\n\t\tif (mii_lpa_data) {\n\t\t\tfor (i = 0; i < AT_SUSPEND_LINK_TIMEOUT; i++) {\n\t\t\t\tmdelay(100);\n\t\t\t\tif (atl1c_get_link_status(hw)) {\n\t\t\t\t\tif (atl1c_get_speed_and_duplex(hw, &speed,\n\t\t\t\t\t\t\t\t\t&duplex) != 0)\n\t\t\t\t\t\tdev_dbg(&pdev->dev,\n\t\t\t\t\t\t\t\"get speed and duplex failed\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tspeed = SPEED_10;\n\t\tduplex = HALF_DUPLEX;\n\t}\n\tadapter->link_speed = speed;\n\tadapter->link_duplex = duplex;\n\n\treturn ret;\n}\n\nint atl1c_restart_autoneg(struct atl1c_hw *hw)\n{\n\tint err = 0;\n\tu16 mii_bmcr_data = BMCR_RESET;\n\n\terr = atl1c_phy_setup_adv(hw);\n\tif (err)\n\t\treturn err;\n\tmii_bmcr_data |= BMCR_ANENABLE | BMCR_ANRESTART;\n\n\treturn atl1c_write_phy_reg(hw, MII_BMCR, mii_bmcr_data);\n}\n\nint atl1c_power_saving(struct atl1c_hw *hw, u32 wufc)\n{\n\tstruct atl1c_adapter *adapter = hw->adapter;\n\tstruct pci_dev *pdev = adapter->pdev;\n\tu32 master_ctrl, mac_ctrl, phy_ctrl;\n\tu32 wol_ctrl, speed;\n\tu16 phy_data;\n\n\twol_ctrl = 0;\n\tspeed = adapter->link_speed == SPEED_1000 ?\n\t\tMAC_CTRL_SPEED_1000 : MAC_CTRL_SPEED_10_100;\n\n\tAT_READ_REG(hw, REG_MASTER_CTRL, &master_ctrl);\n\tAT_READ_REG(hw, REG_MAC_CTRL, &mac_ctrl);\n\tAT_READ_REG(hw, REG_GPHY_CTRL, &phy_ctrl);\n\n\tmaster_ctrl &= ~MASTER_CTRL_CLK_SEL_DIS;\n\tmac_ctrl = FIELD_SETX(mac_ctrl, MAC_CTRL_SPEED, speed);\n\tmac_ctrl &= ~(MAC_CTRL_DUPLX | MAC_CTRL_RX_EN | MAC_CTRL_TX_EN);\n\tif (adapter->link_duplex == FULL_DUPLEX)\n\t\tmac_ctrl |= MAC_CTRL_DUPLX;\n\tphy_ctrl &= ~(GPHY_CTRL_EXT_RESET | GPHY_CTRL_CLS);\n\tphy_ctrl |= GPHY_CTRL_SEL_ANA_RST | GPHY_CTRL_HIB_PULSE |\n\t\tGPHY_CTRL_HIB_EN;\n\tif (!wufc) {  \n\t\tmaster_ctrl |= MASTER_CTRL_CLK_SEL_DIS;\n\t\tphy_ctrl |= GPHY_CTRL_PHY_IDDQ | GPHY_CTRL_PWDOWN_HW;\n\t\tAT_WRITE_REG(hw, REG_MASTER_CTRL, master_ctrl);\n\t\tAT_WRITE_REG(hw, REG_MAC_CTRL, mac_ctrl);\n\t\tAT_WRITE_REG(hw, REG_GPHY_CTRL, phy_ctrl);\n\t\tAT_WRITE_REG(hw, REG_WOL_CTRL, 0);\n\t\thw->phy_configured = false;  \n\t\treturn 0;\n\t}\n\tphy_ctrl |= GPHY_CTRL_EXT_RESET;\n\tif (wufc & AT_WUFC_MAG) {\n\t\tmac_ctrl |= MAC_CTRL_RX_EN | MAC_CTRL_BC_EN;\n\t\twol_ctrl |= WOL_MAGIC_EN | WOL_MAGIC_PME_EN;\n\t\tif (hw->nic_type == athr_l2c_b && hw->revision_id == L2CB_V11)\n\t\t\twol_ctrl |= WOL_PATTERN_EN | WOL_PATTERN_PME_EN;\n\t}\n\tif (wufc & AT_WUFC_LNKC) {\n\t\twol_ctrl |= WOL_LINK_CHG_EN | WOL_LINK_CHG_PME_EN;\n\t\tif (atl1c_write_phy_reg(hw, MII_IER, IER_LINK_UP) != 0) {\n\t\t\tdev_dbg(&pdev->dev, \"%s: write phy MII_IER failed.\\n\",\n\t\t\t\tatl1c_driver_name);\n\t\t}\n\t}\n\t \n\tatl1c_read_phy_reg(hw, MII_ISR, &phy_data);\n\n\tdev_dbg(&pdev->dev, \"%s: suspend MAC=%x,MASTER=%x,PHY=0x%x,WOL=%x\\n\",\n\t\tatl1c_driver_name, mac_ctrl, master_ctrl, phy_ctrl, wol_ctrl);\n\tAT_WRITE_REG(hw, REG_MASTER_CTRL, master_ctrl);\n\tAT_WRITE_REG(hw, REG_MAC_CTRL, mac_ctrl);\n\tAT_WRITE_REG(hw, REG_GPHY_CTRL, phy_ctrl);\n\tAT_WRITE_REG(hw, REG_WOL_CTRL, wol_ctrl);\n\n\treturn 0;\n}\n\n\n \nvoid atl1c_post_phy_linkchg(struct atl1c_hw *hw, u16 link_speed)\n{\n\tu16 phy_val;\n\tbool adj_thresh = false;\n\n\tif (hw->nic_type == athr_l2c_b || hw->nic_type == athr_l2c_b2 ||\n\t    hw->nic_type == athr_l1d || hw->nic_type == athr_l1d_2)\n\t\tadj_thresh = true;\n\n\tif (link_speed != SPEED_0) {  \n\t\t \n\t\tif (hw->nic_type == athr_l1d_2) {\n\t\t\tatl1c_read_phy_ext(hw, MIIEXT_PCS, MIIEXT_CLDCTRL6,\n\t\t\t\t&phy_val);\n\t\t\tphy_val = FIELD_GETX(phy_val, CLDCTRL6_CAB_LEN);\n\t\t\tphy_val = phy_val > CLDCTRL6_CAB_LEN_SHORT ?\n\t\t\t\tAZ_ANADECT_LONG : AZ_ANADECT_DEF;\n\t\t\tatl1c_write_phy_dbg(hw, MIIDBG_AZ_ANADECT, phy_val);\n\t\t}\n\t\t \n\t\tif (adj_thresh && link_speed == SPEED_100 && hw->msi_lnkpatch) {\n\t\t\tatl1c_write_phy_dbg(hw, MIIDBG_MSE16DB, L1D_MSE16DB_UP);\n\t\t\tatl1c_write_phy_dbg(hw, MIIDBG_SYSMODCTRL,\n\t\t\t\tL1D_SYSMODCTRL_IECHOADJ_DEF);\n\t\t}\n\t} else {  \n\t\tif (adj_thresh && hw->msi_lnkpatch) {\n\t\t\tatl1c_write_phy_dbg(hw, MIIDBG_SYSMODCTRL,\n\t\t\t\tSYSMODCTRL_IECHOADJ_DEF);\n\t\t\tatl1c_write_phy_dbg(hw, MIIDBG_MSE16DB,\n\t\t\t\tL1D_MSE16DB_DOWN);\n\t\t}\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}